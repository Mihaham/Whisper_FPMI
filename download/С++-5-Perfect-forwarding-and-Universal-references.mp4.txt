[00:00.000 --> 00:14.280]  Так вот, план у нас на сегодня заключается в том, что мы заканчиваем разговор про муфсимантику,
[00:14.280 --> 00:21.560]  а это значит, что если у вас есть какие-то вопросы по ней, то вам нужно максимально
[00:21.560 --> 00:26.960]  использовать этот день. Вот вся та каша в голове, которая у вас осталась после предыдущих двух
[00:26.960 --> 00:38.080]  разов, а она, вероятно, велика. Я постараюсь ее сегодня размешать и подать к столу. Так,
[00:38.080 --> 00:47.840]  ну давай вопрос. У меня друг из основных спросил, что такое муфсимантика. Не смог ответить. Я понял,
[00:47.840 --> 00:56.000]  что ничего про нее не знаю. Ага. Точнее, я понял, что ничего адекватного про нее не знаю. Хорошо.
[00:56.000 --> 01:02.600]  Знаю, что есть какие-то парочки магических инстинктов. Давайте, да, ну давайте попробуем еще
[01:02.600 --> 01:07.960]  раз ответить на вопрос, что такое муфсимантика. Вот я вам два часа суммарно, то есть полчаса в
[01:07.960 --> 01:13.600]  первый раз и полтора часа во второй раз рассказывал какие-то вещи. Начали мы с каких-то
[01:13.600 --> 01:18.360]  магических заклинаний, потом я вел какие-то странные формальные определения, и мы начали
[01:18.360 --> 01:25.480]  какие-то примеры разбирать. Давайте, прежде чем копать на самый глубокий уровень, все-таки
[01:25.480 --> 01:33.040]  систематизируем, что мы уже знаем. Итак, что такое муфсимантика? У нас были проблемы. Мы иногда
[01:33.040 --> 01:38.480]  хотим перемещать объекты вместо того, чтобы копировать. Когда мы, например, делаем pushback
[01:38.480 --> 01:42.800]  вектор временного объекта, мы хотим, чтобы создавался только один раз объект, а не два,
[01:42.800 --> 01:48.640]  чтобы не было двойного копирования. Когда мы делаем реаллокацию векторе, мы хотим то же
[01:48.640 --> 01:54.240]  самое. Когда мы делаем swap, мы хотим, чтобы объекты мувались, чтобы это не значило, чтобы не
[01:54.240 --> 01:59.080]  пересоздавались они полностью, а просто забирали друг у друга поля. И вообще можно придумать много
[01:59.080 --> 02:04.600]  других сценариев, но это самые очевидные, в которых мы бы хотели, зная, что наш объект, ну как бы,
[02:04.600 --> 02:10.320]  не нужен на старом месте переложить его поля в новое и там про него забыть, а не копировать его
[02:10.320 --> 02:15.320]  полностью, чтобы потом там сразу уничтожить. В этом идее. Что мы для этого изобрели? Мы для этого
[02:15.320 --> 02:24.840]  изобрели какую-то волшебную функцию move, которая делает, это нам, да, мы раньше думали, что делает
[02:24.840 --> 02:32.600]  move на самом деле, move делает каст. По сути, move это, ну, такое название, скрывающее действительность.
[02:32.600 --> 02:38.000]  Вот можно даже сказать, что move это не очень удачное название, потому что на самом деле эта
[02:38.000 --> 02:46.120]  функция является ничем иным, как custom care value. Вот почувствуйте аналогию между, у нас с вами было
[02:46.120 --> 02:56.480]  между custom constant, custom derived и custom care value. У вас, у нас в три раза возникала логическая
[02:56.480 --> 03:00.800]  ситуация. Вот почувствуйте аналогию. Хороший математик, кто-то, кто видит аналогии, как говорил,
[03:00.800 --> 03:08.680]  по-моему, Арнольд, да, не помню, кто это говорил, нет, кто-то другой говорил, извиняюсь. Тебе вообще
[03:08.680 --> 03:21.840]  стыдно не знать, какой Арнольд. Вот, смотрите, давайте я вам приведу аналогию. У нас были,
[03:21.840 --> 03:30.040]  послушайте, пожалуйста, сейчас, у нас были не константные и константные ссылки. У нас раньше
[03:30.360 --> 03:43.240]  были такие ситуации. Вот у нас есть int и есть, значит, int&% и constant&% Чем отличается int&% от
[03:43.240 --> 03:50.280]  constant&% формально? Да просто тем, что над ним больше действий разрешено. Вот, и мы можем,
[03:50.280 --> 03:58.400]  имея int, его подать как сюда, так и сюда, но имея constant, мы не можем его подать сюда, мы можем
[03:58.400 --> 04:03.680]  подать его сюда только, а чтобы подать сюда, его нужно скастить, то есть нужно сказать некоторое
[04:03.680 --> 04:09.480]  специальное, эксклюзивное, так сказать, слово компилятору, я приказываю тебе, считай, что он
[04:09.480 --> 04:15.360]  такой, не забудь про то, что он константный. Вот, константный int, мы не можем подать туда,
[04:15.360 --> 04:21.720]  где ожидается обычный int. Мы для этого должны сказать, const cast на тебя, чтобы ты считал,
[04:21.720 --> 04:27.280]  что так вот можно с ним поступать. Аналогично у нас была ситуация с наследованием. У нас были
[04:27.280 --> 04:41.200]  base&% и derived&%. И были derived и base. Вот мы можем вот по этой ссылке подать как derived, так и
[04:41.200 --> 04:51.840]  base. А по этой ссылке мы можем подать только derived. Если мы хотим подать base, чем отличается
[04:51.840 --> 04:56.920]  derived от base, тем, что к ним больше действий разрешено, все те, которые над base и еще какие-то.
[04:56.920 --> 05:05.760]  Если мы хотим по ссылке на derived подать base, то мы должны сказать явно static cast к derived&% от
[05:05.760 --> 05:13.800]  base, считай, что он такой, вот, вообще-то он derived, вообще-то он base, тип у него,
[05:13.800 --> 05:18.480]  base с точки зрения компилятора, но мы говорим static cast просто к компилятору, считай, что он
[05:18.480 --> 05:27.080]  derived и делаем одним действием, как будто он derived. То же самое, по сути, происходит в move. Вот здесь
[05:27.080 --> 05:37.760]  вот мы делаем const cast, вот здесь мы сделаем static cast. А функция move это, по сути, аналогичную
[05:37.760 --> 06:01.800]  роль играет в ситуации, когда у нас есть int&&& и constant&&. И есть rvalue, а есть lvalue. Так вот,
[06:01.800 --> 06:10.400]  ну, что такое lvalue? Ну, прям какая-то переменная просто. Сюда мы можем подать как rvalue, так и lvalue,
[06:10.400 --> 06:19.720]  а сюда только rvalue. И что такое move? Это просто cast, аналогичный вот этим двум. Когда мы хотим
[06:19.720 --> 06:28.600]  по rvalue, ссылке, отдать lvalue, чем rvalue от lvalue отличается? Тем, что, ну, тут уже так не скажешь,
[06:28.600 --> 06:35.640]  не больше операции разрешено, но тем, что его как бы move, у него можно забирать поля и оставлять
[06:35.640 --> 06:41.160]  его в пустом состоянии. Вот когда мы в конструктор приняли что-то, в чем для нас принципиальная
[06:41.160 --> 06:47.000]  разница? Мы приняли lvalue или rvalue? Ну, lvalue, когда мы приняли, мы обычно считаем, что его портить
[06:47.000 --> 06:52.640]  нельзя, а rvalue его как бы портить можно, оно временное. Чем для нас отличается идея на rvalue
[06:52.640 --> 06:57.880]  от lvalue, когда мы принимаем куда-то? Тем, что rvalue приняв, мы считаем, что оно временно его
[06:57.880 --> 07:07.120]  портить можно. И за счет чего это обеспечивается? Если мы реально rvalue отдали, то мы его и так можем
[07:07.120 --> 07:13.720]  сюда получить. Ну, вот если мы вызываем f от чего-нибудь, я не знаю, от t круглой скобочки,
[07:13.720 --> 07:21.120]  это rvalue, это временный объект, и он и так попадет в эту версию. Но если мы хотим вызваться от x,
[07:21.120 --> 07:28.920]  чем бы ни был x, x это переменная, а значит lvalue. И если мы хотим отдать его сюда, где его испортят,
[07:28.920 --> 07:34.520]  мы должны сказать cast. Вот этот вот move это ничто иное, как просто cast, подсказка компилятору,
[07:34.520 --> 07:40.240]  что считай его таким, я тебе приказываю. Ты вообще-то думаешь, что он lvalue, но я тебе говорю cast
[07:40.240 --> 07:47.040]  к rvalue. И весь этот механизм rvalue ссылок, он нужен как раз для того, по сути это такая аналогичная
[07:47.040 --> 07:53.600]  защита тому, как мы cast к не консту. То есть вообще-то по умолчанию, если у вас есть какой-то объект,
[07:53.600 --> 08:01.920]  реально существующий x, вы не можете его отдать туда, где ожидается rvalue. В эту функцию вообще-то
[08:01.920 --> 08:07.680]  по умолчанию ожидается только вот такие штуки, временные выражения. Но move позволяет вам
[08:07.680 --> 08:15.240]  настоящую переменную, обычную живую переменную, скастить туда и отдать таким образом туда,
[08:15.240 --> 08:21.320]  где ожидает временный объект. Вот что такое move. Вот у вас после предыдущих двух раз могло это не,
[08:21.320 --> 08:27.320]  ну я как говорю там, сначала мы воспринимали move как магию, потом она вводила формальное
[08:27.320 --> 08:31.960]  определение. Но вот сейчас у вас, я надеюсь, начинает вырисовываться какая-то картина. По
[08:31.960 --> 08:37.360]  сути все эти определения про то, чем является rvalue и lvalue, они нужны для того, чтобы вот эта
[08:37.360 --> 08:43.120]  вся история корректно работала и проследовала вот эти вот аналогии. Понятно? То есть еще раз move,
[08:43.120 --> 08:50.240]  она позволяет вам по сути заставить компилятор считать, что это rvalue и вести себя с ним так,
[08:50.240 --> 08:55.480]  как будто это временная штука. А значит выбирать ту версию перегрузки, которая предназначена для
[08:55.480 --> 08:59.640]  временных штук, только что созданных и не существующих в памяти вообще возможно. Вот
[08:59.640 --> 09:06.920]  вот эта штука, она может быть временной, налету созданной, даже не положенной на стэк. move говорит
[09:06.920 --> 09:12.680]  компилятору, веди себя с этой штукой так, как будто она вот такая и отдавай ее в соответствующую
[09:12.680 --> 09:18.840]  версию. Поэтому rvalue ссылки позволяют унитализацию только от rvalue, чтобы lvalue в них не попало,
[09:18.840 --> 09:29.720]  а если хотите rvalue, то нужно сказать явный каст. move это и есть каст. Ну как, вам теперь стало
[09:29.720 --> 09:43.200]  понятно move семантика? Вот, отлично. Да. Нет, мы делали, это два разных конструктора. Нет-нет,
[09:43.200 --> 09:52.200]  есть copy конструктор, есть move конструктор. move конструктор, есть конструктор. move конструктор
[09:52.200 --> 09:56.640]  это конструктор перемещения, есть copy конструктор, это конструктор копирования, не бывает конструктора
[09:56.640 --> 10:06.160]  перемещения копирования. Да. Для строки. Почему мы не могли то же самое, ну просто написать его в
[10:06.160 --> 10:16.240]  обычном копе конструкторе. Что значит в обычном копе конструкторе? Это просто бы выдал lce,
[10:16.240 --> 10:21.760]  потому что обычный конструктор понимает const string% и ты не имеешь права менять ее поля, хотя бы
[10:21.760 --> 10:45.800]  по такой банальной причине это бы не работало. Не обсуждается. Нам нужно разное поведение для
[10:45.800 --> 10:54.440]  lvalue строк принятых и для rvalue строк. Что такое rvalue идейно? Вот я вам написал, сначала мы воспринимали
[10:54.440 --> 11:01.000]  rvalue как что-то, чему нельзя присваивать, но это некорректно, это наивное определение, хотя исторически
[11:01.000 --> 11:06.560]  оно было первым. Дальше он написал длинное формальное определение. А в чем интуиция этого
[11:06.560 --> 11:16.760]  определения? Что такое rvalue идейно? Это то, что временное, оно не лежащее где-то в памяти,
[11:16.760 --> 11:21.800]  не созданное как полноценный объект. Оно временное, на лету созданное, компилятор даже, вообще говоря,
[11:21.800 --> 11:28.400]  может не класть его никуда. Оно может в регистрах процессора считать как что-то мимолетное. rvalue
[11:28.400 --> 11:33.480]  это что-то мимолетное и временное, короче. Вот если у вас что-то в жизни происходит мимолетное,
[11:33.480 --> 11:46.680]  то это называйте rvalue. Произошло rvalue вчера и забыл я уже сегодня, что было. rvalue это что-то
[11:46.680 --> 11:52.000]  временное, которое возможно даже не лежит в памяти ни в какой. Оно в регистрах просто лежит
[11:52.000 --> 11:58.120]  процессора и сразу будет забыто. А вот все то формальное определение, это просто формализация
[11:58.120 --> 12:05.000]  нашего понимания, потому что такое временная штука. И в этом определении существенные нетривиальные
[12:05.000 --> 12:13.640]  пункты это cast.rvalue.ссылки или возврат.rvalue.ссылки из функции. Вот cast.rvalue.ссылки и возврат.rvalue.ссылки
[12:13.640 --> 12:22.600]  из функции это два случая, которые не интуитивны rvalue. Это как бы принудительно rvalue. Вот rvalue.ссылка
[12:22.600 --> 12:29.920]  позволяет вам какой-то объект, который существовал в памяти и уже как переменная был lvalue,
[12:29.920 --> 12:37.360]  скастить, ну трактовать как rvalue, чтобы при перегрузке оно отходило туда, где временный
[12:37.360 --> 12:48.520]  объект ожидается. Значит rvalue идейная, это временная штука. Так потому что она ничем не
[12:48.520 --> 12:53.560]  отличается от обычной ссылки, кроме двух... Она по свойствам как ссылка, полностью как ссылка.
[12:53.560 --> 13:00.680]  rvalue.reference это такой тип, который по свойствам абсолютно как ссылка себя ведет. Но у него есть
[13:00.680 --> 13:05.840]  два главных отличия от старых ссылок, которые мы теперь называем lvalue.ссылками. И я их называл.
[13:05.840 --> 13:12.760]  Два главных отличия в том, что во-первых, будучи возвращенной из функции или из каста, rvalue.ссылка
[13:12.760 --> 13:19.160]  дает rvalue.expression. И это ключевое свойство. Это свойство, благодаря которому все работает.
[13:19.160 --> 13:25.880]  Потому что именно благодаря этому свойству после move мы получаем rvalue, которое потом,
[13:25.880 --> 13:32.840]  благодаря второму свойству, попадает вот в эту версию. Второе свойство это, что rvalue.ссылка
[13:32.840 --> 13:45.480]  может быть только через rvalue проинцелизирована. Во-первых, ampersand заканчивается буквой D.
[13:45.480 --> 13:55.160]  Правильно говорить ampersand? Да. Я знаю. Я буду говорить это столько, сколько потребуется. Я же
[13:55.160 --> 14:05.200]  преподаватель, мое дело вас заставить это запомнить. Вот. Может писать constant 2 ampersand? Ну, я еще раз
[14:05.200 --> 14:11.360]  говорю. Эта штука, которая в чистом виде, вот непосредственно она, вам вряд ли когда-либо понадобится.
[14:11.360 --> 14:17.720]  Но она может возникнуть как наложение двух свойств. У вас может быть какой-нибудь константный объект,
[14:17.720 --> 14:25.440]  который вы move'ните. Вот. Я же могу, например, где-то в какой-то функции, да хоть в шаблонной,
[14:25.440 --> 14:36.480]  получить какой-то x и решить его отдать как rvalue куда-то. Я тогда напишу std move от x. Эта штука вернет
[14:36.480 --> 14:42.400]  мне тип, какой был у x с убранными амперсандами и навешанными двумя амперсандами, то есть rvalue.
[14:42.400 --> 14:48.880]  Но конст никуда не денется, если там был конст. И вот эта штука, если у x произвольный тип,
[14:48.880 --> 14:53.280]  неизвестный мне, вообще говоря, такая штука может мне вернуть константный тип с двумя амперсандами.
[14:53.280 --> 14:57.880]  Что произойдет, когда я константный тип с двумя амперсандами, пытаюсь отдать куда-то,
[14:57.880 --> 15:04.920]  где есть перегрузки для rvalue и для lvalue. У меня стандартный сценарий, у меня есть перегрузка f,
[15:04.920 --> 15:10.520]  которая принимает, ну скажем, string 2 амперсанда и перегрузка f, которая принимает const string
[15:10.520 --> 15:19.160]  амперсант. И представим, что я хочу отдать const string 2 амперсанда. Куда я попаду? Конечно же,
[15:19.160 --> 15:25.640]  во вторую. const это ничего не испортит, потому что сюда я не попаду по принципу константности,
[15:25.640 --> 15:36.400]  а это все принимает, это все съест. Это логичное поведение, то есть если вы move-нули константный
[15:36.400 --> 15:41.440]  объект случайно, то у вас все равно не получится отдать его в такое место, где его испортят,
[15:41.440 --> 15:46.560]  потому что константность, независимо от rvalue-лишности, работает и не дает вам пойти
[15:46.560 --> 15:55.000]  сюда, потому что константность рушается, а эта штука все съедает. Еще раз, непосредственно сам по
[15:55.000 --> 15:59.480]  себе он никогда не нужен, ну по крайней мере я не знаю случаев, когда он прям нужен, но он может
[15:59.480 --> 16:04.920]  случайно возникнуть в какой-нибудь шаблонном коде, как наложение двух свойств, и тогда после
[16:04.920 --> 16:18.840]  move-а вы все равно сюда попадете, потому что константность вас спасет. Зачем? Зачем
[16:18.840 --> 16:25.960]  вводить дополнительные костыли к правилам, если без костылей все работает как хочется? Так мы не
[16:25.960 --> 16:31.120]  сходим, я как раз об этом и говорю, что благодаря константности мы не попадем сюда опять-таки,
[16:31.120 --> 16:38.160]  а пойдем сюда. Если мы случайно получили const2ampersand, мы все равно не попадем в версию,
[16:38.160 --> 16:50.080]  где его испортят, потому что константность защитит, и мы пойдем сюда. Ну такое, я не знаю применение,
[16:50.080 --> 16:57.520]  константность не сильнее, это просто независимые два свойства, каждый из которых независимо
[16:58.240 --> 17:08.520]  они не сильнее. Вот эта штука принимает как R-value, так и L-value, причем как константное,
[17:08.520 --> 17:14.080]  так и неконстантное. Это мы еще и с первого семестра знаем. А эта штука принимает только
[17:14.080 --> 17:19.680]  R-value, да еще и причем только неконстантное. Куда же мы пойдем, если мы вызовемся от
[17:19.680 --> 17:29.240]  константного R-value? Сюда. Да. Вот если мы написали auto x равно, и вот const, ну что? Auto x равно что?
[17:29.240 --> 17:40.600]  Ну равно вот R-value reference, const R-value reference. Что значит равно? X, auto x равно? Y какому-нибудь,
[17:40.600 --> 17:44.680]  ну который является const R-value reference. Который является, тип которого const R-value reference?
[17:44.680 --> 17:58.160]  У вас отбросится и const и амперсант, по-моему у вас все отпадет. Чего? А, так я же auto без
[17:58.160 --> 18:03.360]  амперсантов написал. Auto без амперсантов означает, что у меня отбросится reference,
[18:03.360 --> 18:30.080]  а значит и const отбросится. Так, да. Тип этой штуки просто t. Тип этой штуки просто t, да. Ну нет,
[18:30.080 --> 18:35.480]  не константное. А с чего бы ей быть константной? Какой-то другой экспресс. Как? Какой экспресс? Ну,
[18:35.480 --> 18:40.560]  как? Ну, как я тебе скажу, как констанция определяется? Ну, нужно 5 страниц считать
[18:40.560 --> 18:45.360]  правил, как она определяется. Ну, вот у этого оно не константное, потому что здесь тип t явно
[18:45.360 --> 18:48.920]  сказан какой. Хорошо, а если там будет какая-нибудь функция, другая j, которая будет возвращать,
[18:48.920 --> 18:57.240]  например, const string, просто const string. const string? Да. А константные объекты из
[18:57.240 --> 19:04.980]  функций возвращать, это, кажется, вообще warning, начиная с и плюс плюс 20. И это бессмысленно. Как
[19:04.980 --> 19:11.440]  раз по той причине возвращать const t из какой-либо функции, не накладывая амперсант. Это вообще
[19:11.440 --> 19:17.160]  deprecated практика. И начиная с и плюс плюс 20, это, по-моему, даже warning. Если, ну, это, короче,
[19:17.160 --> 19:23.000]  не рекомендуется так делать. Ровно потому, что это бессмысленно. Это вы, получается, навесите
[19:23.000 --> 19:30.360]  const на штуку, которая временная, ввиду чего вы не сможете попасть сюда, если надо будет,
[19:30.360 --> 19:36.200]  и тем самым вы потеряете в эффективности ничего не выиграв. Не надо накладывать const на временный
[19:36.200 --> 19:41.720]  объект. Он временный, его можно, как RL, ее трактовать и отдавать туда, где из него быстро и эффективно
[19:41.720 --> 19:46.960]  заберут данные. А если вы const навесите искусственно на него, то вы потеряете это свойство и будете
[19:46.960 --> 20:01.280]  медленно копировать вместо этого. Потому что ты, дело не в том, что ты move, вот у тебя есть
[20:01.280 --> 20:06.880]  const rvalue ссылка, и ты move от нее делаешь. Ты можешь случайно наткнуться на такое. У тебя может
[20:06.880 --> 20:14.440]  в шаблонном коде где-нибудь быть x, который иногда const, иногда не const. И ты его move-аешь.
[20:14.440 --> 20:21.480]  Ну, тебе дали rvalue штуку, и ты move-аешь ее, но иногда она может быть константной, и тогда ты
[20:21.480 --> 20:26.680]  получишь константную rvalue ссылку. И за счет константности ты будешь защищен от вот этого.
[20:26.680 --> 20:30.280]  Константность — это просто дополнительное свойство, которое работает независимо,
[20:30.280 --> 20:33.640]  оно тоже может тебе помочь правильно перегрузку выбрать.
[20:33.640 --> 20:36.680]  Почему тогда в шаблонном коде не может встретиться ситуация,
[20:36.680 --> 20:51.160]  какая из функций возвращается const t? Ну, например, потому что я могу функцию принимать что-нибудь такое,
[20:51.160 --> 21:00.800]  вот функция с таким возвращаемым типом, она будет не отбрасывать const с таким принимаемым типом,
[21:00.800 --> 21:07.600]  здесь const t — константность не отбросится. Если здесь t был с константой, то и он и пойдет с
[21:07.600 --> 21:13.240]  константой. А если я в возвращаемом типе напишу t, то тут const уже отбрасывается. Ну, короче, когда я
[21:13.240 --> 21:18.360]  ссылку возвращаю, вы же помните правила вывода шаблонных типов, когда я ссылку навешиваю на тип,
[21:18.360 --> 21:23.120]  const в шаблоне не отбрасывается. А если я возвращаю просто t или принимаю просто t,
[21:23.120 --> 21:29.600]  то const с него снимается. Если я хочу const чтобы не снималось, то мне нужно явно написать const t,
[21:29.600 --> 21:34.240]  но это уже cringe. Так никто не пишет. Вот если я константную ссылку возвращаю, то это нормально.
[21:34.240 --> 21:39.760]  А если я просто объект возвращаю, то const с него снимается, потому что это бессмысленно. Но если
[21:39.760 --> 21:43.240]  вы явно напишите const t, то вам может компилятор warning скажет.
[21:43.240 --> 22:13.120]  Да, совершенно верно. Вы должны оставить поля
[22:13.120 --> 22:20.480]  этого объекта в каком-то условно пустом, чтобы это не значило, но корректном состоянии, чтобы он
[22:20.480 --> 22:30.040]  еще пережил вызов деструктора нормально после этого. Moved-нутый объект, из которого сделали
[22:30.040 --> 22:35.080]  move присваивание, он еще полноценно им можно пользоваться. То есть, вот бывает, знаете,
[22:35.080 --> 22:43.840]  задают такие вопросы на собеседованиях или на экзаменах. Вектор какой-нибудь int v равно move
[22:43.840 --> 22:50.880]  от другого вектора, от vv. И спрашивают, а вот теперь если я к vv обращусь, это ub или нет? Нет,
[22:50.880 --> 22:59.080]  конечно, это не ub. Просто он пустой. Вот. Ну это какой-то другой вектор был. Вот я взял,
[22:59.080 --> 23:04.680]  где создал вектор move из другого вектора. Что теперь с vv? И к нему можно обращаться? Можно. Он
[23:04.680 --> 23:09.480]  просто пустой. И потом будет вызвано деструктор. Ну пустого вектора деструктора просто ничего не
[23:09.480 --> 23:17.080]  сделает. Вот. И теперь также вы должны понимать, что функция move сама по себе. Вот, допустим,
[23:17.080 --> 23:23.240]  у меня был вектор. Я написал move от vv. запятой. Все. Что произошло? Да ничего не произошло. Компилятор
[23:23.240 --> 23:29.480]  эту строчку просто из кода выкинет. А это просто ничего не делает. Да, это все равно,
[23:29.480 --> 23:34.560]  как если бы вы меня спросили, а вот если я напишу статик каст гдирайф тамперсант,
[23:34.560 --> 23:41.200]  в скобочках от B, точка запятой, что произойдет? B сломается? Да ничего не произойдет. Просто вы
[23:41.200 --> 23:46.360]  скаставали и не воспользовались тем, что скаставали. Ведь эти касты, они все нужны только для
[23:46.360 --> 23:52.720]  разрешения перегрузки, по сути. Поэтому сама по себе функция move ничего не делает с объектом.
[23:52.720 --> 23:59.040]  Делает с объектом операция конструирования или присваивания. А move лишь говорит компилятору,
[23:59.040 --> 24:07.680]  в какую версию пойти за счет каста. Вот. Более того, вместо move всегда можно было бы писать
[24:07.680 --> 24:12.360]  просто статик каст к двум персантам данного типа и это было бы это было бы аналогично было. Просто
[24:12.360 --> 24:22.120]  чтобы не заставлять людей думать об этой фигне, move, ну, сейчас вы, понимая вот это все, уже должны
[24:22.120 --> 24:28.880]  понимать, что вместо move всегда можно просто писать статик каст к вашему типу с двумя персантами,
[24:28.880 --> 24:35.240]  это будет также точно работать. Move это и делает, по сути. Просто он делает это шаблонно для всех
[24:35.240 --> 24:41.960]  типов. Remove Reference T нужно из-за того, что там T шаблонная. Но если у вас T конкретная,
[24:41.960 --> 24:50.560]  то вы можете без всякой магии с шаблонами это сделать. Вот. Но move так называется, чтобы люди
[24:51.200 --> 24:56.680]  кто не хочет в этом разбираться, могли в этом не разбираться. Чтобы обычным пользователям,
[24:56.680 --> 25:07.240]  которые, значит, как бы сказать они их, а? Да ну нет, олимпиадники они все-таки поумнее обычно.
[25:07.240 --> 25:14.720]  Ну в общем, пользователям, ну, чувакам, которые, чувакам, которые, чувакам, которые пишут на плюсах,
[25:14.720 --> 25:19.960]  но на самом деле не хотят разбираться в том, как устроено вот это все, можно было просто писать
[25:19.960 --> 25:24.160]  move и оно как-то работает. Это то, с чего мы начали. То есть, собственно, мы и начали с того,
[25:24.160 --> 25:29.320]  что если вы ничего не знаете про move семантику, то вот все, что вам нужно знать на минимуме,
[25:29.320 --> 25:37.280]  значит, starter pack c++ разработчика для прохождения собеседований. Как пользоваться move? Ну вот так,
[25:37.280 --> 25:43.320]  все. Что делает move? Ну это сложный вопрос. Вот. Но теперь вы понимаете, что делает move. Он просто
[25:43.320 --> 25:47.920]  делает каст, который заставляет выбирать другую перегрузку. А эти правила с ревелусылками
[25:47.920 --> 26:00.120]  специально такие, чтобы правильно работала перегрузка. Вот. Миша понял. Кажется, что-то
[26:00.120 --> 26:09.440]  понятно. Это мы проверим, безусловно. Да. Нужно даже. Вот сейчас, нужно, сейчас у вас прям вот момент,
[26:09.440 --> 26:14.560]  когда нужно вот задать вопросы, чтобы, так сказать, преисполниться. В чем преимущество использовать
[26:14.560 --> 26:19.480]  R-value референс перед L-value референсом? Что значит преимущество? Ну, как бы, всем выигранного
[26:19.480 --> 26:24.560]  производительности. Если мы делаем там swap от R-value объектов или это L-value объектов. Так,
[26:24.560 --> 26:31.600]  во-первых, объекты не бывают R-value и L-value. То есть, если мы делаем, что? Если мы делаем,
[26:31.600 --> 26:41.280]  так опять, блин, ты задаешь какие-то… Тебе нужно вернуться к пункту 10.1 с самого начала, где я
[26:41.280 --> 26:48.640]  рассказывал про мусемантику, и вспомнить примеры, из-за которых мы ее изобрели. Я в начале этой пары
[26:48.640 --> 26:54.720]  очень коротко их повторил. Нам нужно было swap-ать объекты, push-back-ать вектор, перекладывать из одного
[26:54.720 --> 26:59.200]  вектора в другой. Я спрашиваю, что именно происходит, что делает R-value более эффективным?
[26:59.200 --> 27:08.080]  Что делает… Если у тебя есть две строки, и тебе нужно присвоить одну строку другой, или создать
[27:08.080 --> 27:16.640]  одну строку из другой. Вот у тебя есть стринг. Стринг S равно S1, где S1 — другая строка. S1 — это
[27:16.640 --> 27:23.440]  строка другая. В ней есть указатель на массив, размер и capacity. Этот указатель ведет на какой-то
[27:23.440 --> 27:30.160]  длинный массив. Что бы делало стандартное конструирование? Оно бы создало такой же указатель,
[27:30.160 --> 27:37.360]  size и capacity, и перевыделило бы этот массив, скопировав бы его по байтово. Что сделает move
[27:37.360 --> 27:45.880]  конструирование? Оно сделает этот указатель таким же, как этот. Этот указатель будет указывать
[27:45.880 --> 27:51.480]  сюда. Никакого нового массива мы строить не будем. Числа будут такими же, а этот указатель будет
[27:51.480 --> 27:57.120]  nullptr, и числа занулины. И это работает в завод единицы, в отличие от стандартного конструирования,
[27:57.120 --> 28:03.520]  копирующего, которое завод от N перекладывает, полностью глубокое копирование делает.
[28:03.520 --> 28:20.320]  Оно просто забирает поля у того и зануляет ему. А не создает полноценную копию. Да, а move — это
[28:20.320 --> 28:26.040]  функция, которая делает по сути каст, благодаря которому компилятор предпочитает эту версию,
[28:26.040 --> 28:35.640]  а не эту. Вот, если вы вызываетесь… Помните, я вам вначале говорил, что для такого случая f от…
[28:35.640 --> 28:45.160]  Ну, там был не совсем такой пример. Ну вот, если я говорю в вектор pushback вот такой string.
[28:45.160 --> 28:55.400]  Да, pushback вот такой string. Вот, если вы помните, там был разговор, что здесь move избыточен.
[28:55.400 --> 29:02.480]  Конечно, избыточен. Это и так R-value. Здесь не нужно говорить компилятору явно, что сделай,
[29:02.480 --> 29:09.480]  пожалуйста, R-value, считай это R-value. Это и так R-value. Мы и так попадем в версию, которая вот для этого.
[29:09.480 --> 29:16.240]  Если мы в вектор делаем pushback только что вот прямо в этом expression созданного объекта, то мы и так
[29:16.240 --> 29:21.840]  попадем в версию, которая для R-value. Потому что у pushback на самом деле тоже две версии. У pushback
[29:21.840 --> 29:27.440]  есть версия для R-value и для L. У pushback есть версия, которая принимает конс с t амперсант у вектора.
[29:27.440 --> 29:33.320]  А есть версия, которая принимает t2 амперсанда. И чем они отличаются? Просто лишь тем и больше ничем,
[29:33.320 --> 29:41.400]  что одна из них, когда делает placement new, делает t от этого x, а другая делает t от std move от этого x.
[29:41.400 --> 29:48.160]  Потому что приняв что-то, как R-value ссылку, вы и дальше move-аете. Собственно, когда вы что-то
[29:48.160 --> 29:53.320]  приняли, как R-value ссылку, вы понимаете, что если что, это можно дальше портить, отдавать, как будто это R-value.
[29:53.320 --> 30:05.440]  Все проблемы по объективе инициации получается у конструктора t. Конструктор t? А, ну, конструктор и
[30:05.440 --> 30:09.760]  оператор присваивания. Нет, вы можете и другие. Ну, я говорю, например, pushback по-разному реализован,
[30:09.760 --> 30:33.880]  в зависимости от того, какой V-value он принимает. Вот это, конечно. A++ изменяет a на 1. Нет,
[30:33.880 --> 30:46.440]  A++ изменяет значение переменной a на 1. Как отличает? Понимаешь, чтобы сделать A++,
[30:46.440 --> 30:52.680]  тебе нужно взять ячейку памяти и записать в нее значение на 1 больше предыдущего. А чтобы сделать
[30:52.680 --> 30:58.760]  move от V-value, вообще в runtime ничего не происходит. Во время исполнения происходит ничего буквально,
[30:58.760 --> 31:08.920]  ровным счетом. Вот эта строчка ничего не значит для процесса. Кто заходит? Компилятор.
[31:08.920 --> 31:25.480]  Компилятор генерирует задача компилятора сгенерировать ассемблер из C++ кода. Да, ну,
[31:25.480 --> 31:31.960]  выкинет из ассемблерного кода, я имею в виду. То есть в ассемблерном коде как будто нет этой
[31:31.960 --> 31:43.160]  строчки, потому что она ничего не делает. Она не транслируется ни во что. На самом деле это
[31:43.160 --> 31:47.880]  сначала транслируется в так называемый Intermediate Representation общую для многих языков, а потом уже
[31:47.880 --> 32:01.960]  в ассемблер, но это вам на втором курсе расскажут. Ну да, по сути move это просто штука,
[32:01.960 --> 32:10.920]  которая, можно воспринимать это как подавление некоторых ошибок компиляции и все. То есть по
[32:10.920 --> 32:20.360]  сути move это инструкция для компилятора, что с этой штукой можно выполнять те операции,
[32:20.360 --> 32:31.680]  которые ты бы думал, что с ВВ нельзя. Так, окей, тем не менее у нас вообще-то еще есть целых аж,
[32:31.680 --> 32:50.720]  еще аж целых несколько вещей, которые надо обсудить. Ну все стандартные объекты так себя ведут,
[32:50.720 --> 32:56.400]  и любой пользователь от ваших объектов будет ожидать того же самого. Если вы сделаете иначе,
[32:56.400 --> 33:04.800]  формально стандарт вы не нарушите, но вы рискуете получить пулю в лоб. Если нет чего,
[33:04.800 --> 33:15.920]  дефолтного конструктора. Не знаю, для каждого типа решайте по-своему, я не могу вам общий рецепт дать.
[33:15.920 --> 33:32.480]  Я думаю, что я бы хотел пойти дальше, ну давай быстро. Да, мы попадем в копий конструктор.
[33:32.480 --> 33:49.240]  Кого? Кого генерирует? Прости, пожалуйста, но я не буду пересказывать, потому что в начале прошлой
[33:49.240 --> 33:56.000]  пары я минут 15 рассказывал, как компилятор обрабатывает эти случаи. Компилятор не генерирует
[33:56.000 --> 33:59.800]  move конструктор, если у вас есть нетривиальный копий конструктор. Мы про это подробно говорили
[33:59.800 --> 34:08.160]  в начале прошлой пары. Вот, я уж наверное не буду повторять. Так, можно просто шепотом,
[34:08.160 --> 34:14.560]  я не знаю, хотя бы. Так, еще одна вещь, которую надо сказать. Я напоминаю, у нас параграф 10-5 был,
[34:14.560 --> 34:20.040]  R value референса с их свойства. Так вот, это все мы еще в нем. Так вот, у нас еще есть одна штука,
[34:20.040 --> 34:29.840]  которую я здесь расскажу, это референс квалифаерс. Рев квалифаерс. Что такое квалифаерс, помните?
[34:29.840 --> 34:39.400]  Ну это, ну это вот у вас была ошибка, что-то там дискарт с квалифаерс, когда вы константность
[34:39.400 --> 34:45.400]  нарушаете. Да-да-да-да, мы прям здесь, ну это потому что тоже относится к свойствам ссылок,
[34:45.400 --> 34:54.360]  отдельный параграф под это заводить как-то странно. У вас в классе может быть какая-нибудь версия F,
[34:54.360 --> 35:11.800]  которая там выводит единицу, и версия F-константная, которая выводит двойку. Вот. И это
[35:11.800 --> 35:15.760]  называется конст-квалифаер. То есть вот эта версия только для константных работает, а эта
[35:15.760 --> 35:26.440]  для всех, в общем-то. Вот. Да, и когда вы говорите x.f, если у икса константный тип, то он, ну короче,
[35:26.440 --> 35:33.880]  все понятно, не будут повторять, вы и так знаете, как работает. Не логично ли? Не напрашивается ли у вас
[35:33.880 --> 35:43.960]  какая-нибудь идея еще одна? Сделать RLU-квалифаер. Смотрите, что можно делать, начиная с C++11. Можно
[35:43.960 --> 35:51.240]  смотреть, что можно делать, начиная с C++11. Можно сказать void-f амперсант, а здесь два амперсанта.
[35:51.240 --> 36:04.120]  Это не бред, это C++11. Структура же не может быть RLU. Структура не может, но expression-то может.
[36:04.120 --> 36:14.560]  Вот если я вызываюсь у x, вот так, где x? Это s. Причем неважно, x был ссылкой на s, RLU ссылкой на s,
[36:14.560 --> 36:28.400]  константный. Я попадаю сюда. А если я от std.move от x напишу точка f, то я попаду сюда. Или если я
[36:28.400 --> 36:47.920]  сделаю вот так. Слушайте, кстати, я сделаю немножко шаг назад, я забыл вам сказать такую вещь.
[36:47.920 --> 36:59.240]  Это же бред. Да не бред это. Что тебя смущает здесь? Мне кажется, это повод для багов. И эта версия
[36:59.240 --> 37:05.960]  вызывается у LWL выражений, а это у RWL выражений. Вот и все. Точно так, ну ее можно комбинировать
[37:05.960 --> 37:14.200]  с константностью. То есть вы можете написать, допустим void-f, конст амперсант. Амперсант
[37:14.200 --> 37:23.480]  ставится, значит, в самом конце, вот здесь. Ну не в самом, перед try он еще ставится. И перед noexcept,
[37:23.480 --> 37:29.440]  наверное. Вот, вот это версия для константных LWL, а вот это для RWL. Соответственно, вот эта версия
[37:29.440 --> 37:35.640]  может быть вызвана от любого объекта, ну от любого expression, означающего данный объект. А это
[37:35.640 --> 37:43.040]  только у RWL. То есть если вы сделаете std.move от x.f, когда это может быть полезно? Ну представьте,
[37:43.040 --> 37:47.640]  что у вас в структуре S какие-нибудь данные лежат. Какая-нибудь строка, например. И ваш метод
[37:47.640 --> 37:53.200]  возвращает эту строку. Ну возвращает данные из объекта, дает вам какие-нибудь данные из объекта.
[37:53.200 --> 38:00.000]  Тогда имеет смысл сделать две версии. Одну, на случай, если объект LWL, тогда вы возвращаете
[38:00.000 --> 38:04.880]  копию данных. А другую, на случай, если объект RWL, тогда вы просто move эти данные из полей.
[38:04.880 --> 38:08.600]  Потому что это же RWL, это временный объект, значит, данные у него можно забрать.
[38:08.600 --> 38:19.240]  Ну пусть у меня возвращаемый тип string и там и там. И у меня есть поле типа string. И здесь я говорю
[38:19.240 --> 38:26.360]  return вот это string, это значит его копия создастся. А тут я скажу return std.move от этого string. Это
[38:26.360 --> 38:36.640]  значит, я просто его опустошу и возвращу просто в... Да. Конечно. Const вызывает, ну,
[38:36.680 --> 38:44.080]  константная версия, которая voidf const, вызывается от константных объектов, но они могут быть как RWL,
[38:44.080 --> 38:53.040]  так и LWL. А const&% вызывается только от константных... А, да, да, я понял, да. Кажется,
[38:53.040 --> 38:58.680]  что эта штука тоже от RWL должна вызываться. Да, похоже, что нет тогда. Потому что если вы напишите
[38:58.680 --> 39:09.800]  const&% это будет и для RWL тоже работать. Там есть тонкость, то есть вот эта штука... Я на самом деле
[39:09.800 --> 39:15.520]  не уверен, надо перепроверить, надо перечитать или протестить, но я сейчас не буду. Вот эта штука,
[39:15.520 --> 39:20.680]  ну, если вы напишите ampersand без const, то вы только от LWL сможете вызываться. А если напишите
[39:20.680 --> 39:24.440]  const&% то, по-моему, это работает по правилам обычных константных ссылок, то есть вы можете
[39:24.440 --> 39:39.200]  вызываться как от RWL, так и от LWL, оно просто не явно скастется к const&%. Да, да, по сути так и есть. И вот
[39:39.200 --> 39:45.800]  этот квалификатор, он, по сути, это то, по какой ссылке мы хотим принять наш объект with.
[39:45.800 --> 40:03.760]  Думаю, нет. Я думаю, что это мышление обманывает в строго меньшем под множество случаев,
[40:03.760 --> 40:13.700]  чем стандартное. Ну, то есть оно наоборот проясняет многие. Ну, оно вложено. Нет,
[40:13.700 --> 40:21.580]  это мышление обманывает в меньшем количестве случаев, чем предыдущее мышление. Нет, нет, нет. Ваше
[40:21.580 --> 40:26.060]  мышление стандартное обманывает вас в некотором под множество случаев, а это мышление не обманывает
[40:26.060 --> 40:30.140]  в некоторых из старых случаев, но, возможно, продолжает обманывать в каких-то новых, в каких-то других
[40:30.140 --> 40:38.860]  случаях. Повторяю мышление. Когда вы вызываете x.f, это на самом деле как будто вы вызываете метод
[40:38.860 --> 40:45.660]  s.f с параметром первым x и дальше с другими параметрами. Ну, просто этот метод, он как бы
[40:45.660 --> 40:50.380]  неявным аргументом принимает, ну, как в питоне, он как будто неявным аргументом принимает ваш x,
[40:50.380 --> 40:56.260]  и этот квалификатор на самом деле просто говорит, по какой ссылке x он хочет принять. И это объясняет,
[40:56.260 --> 41:02.460]  что вот по этой ссылке вы только std moved x можете отдать или вы можете дать временно созданный.
[41:02.460 --> 41:12.340]  Что в локаторах? Нет, в локатор trades, локатор trades метод статический, а это метод нестатический.
[41:12.340 --> 41:20.700]  Так, окей, референс-квалифаеры. Понятно ли, зачем могут быть нужны референс-квалифаеры?
[41:20.700 --> 41:37.780]  Сдохнуть? Что такое R-value конструктор, я не понимаю вообще. Нет, во-первых, амперсант,
[41:37.780 --> 41:44.740]  буква D на конце, правильно говорите амперсант, да. А во-вторых, нет, конечно, для конструкторов это
[41:44.740 --> 41:49.140]  бессмысленно. Вы и квалификаторы для конструкторов не можете писать, вы и конст не можете писать.
[41:49.140 --> 42:07.700]  Это правда. Так, нам осталось прояснить что. Ах да, я забыл сказать, как раз вы меня отвлекли
[42:07.780 --> 42:17.820]  вопросами, я забыл сказать еще одну важную мысль про R-value ссылки. Послушайте, пожалуйста,
[42:17.820 --> 42:22.700]  важную мысль про R-value ссылки. Возможно, это третья по важности мысль про R-value ссылки,
[42:22.700 --> 42:27.820]  которую я скажу в принципе. Первые две вы должны уже знать. Третья мысль про R-value ссылки,
[42:27.820 --> 42:32.260]  которая объясняет оставшееся их поведение, это что они реально, как и обычные ссылки,
[42:32.260 --> 42:41.200]  неотличимы от объектов, на которые они ссылаются. Вот вы мне говорите, вот помните у нас был
[42:41.200 --> 42:48.700]  пример, int двойной амперсант x равно чему-то там, а потом f от x, и мы внезапно попадаем в версию
[42:48.700 --> 42:55.540]  для L-value, а не для R-value. Да потому что ссылка это полноценное имя объекта, не должно быть
[42:55.540 --> 43:02.020]  разницы, через какую ссылку мы обращаемся к объекту. Вот это вот правило, оно согласуется
[43:02.020 --> 43:09.580]  с интуицией, что ссылка, она неотличима от объекта. Если бы у вас в зависимости от того,
[43:09.580 --> 43:13.820]  какая это ссылка, вы попадали то туда, то туда, то это получалось бы, что у вас x это какое-то
[43:13.820 --> 43:18.900]  неполноценное имя объекта, оно как-то его по-особенному называет, так что вы попадаете в другую версию. Нет,
[43:18.900 --> 43:23.820]  так не работает со ссылками с любыми. Любая ссылка неотличима от исходного объекта. И
[43:24.500 --> 43:29.100]  разница R-value ссылок с обычными только в том, что инициализироваться они могут R-value,
[43:29.100 --> 43:37.380]  ну и move-ать, если вы move-ать и получаете R-value. Но это уже полноценное имя объекта и ведет на себя
[43:37.380 --> 43:42.660]  как L-value. Поэтому если вы в версию какой-то функции приняли R-value ссылку и хотите дальше ее отдать
[43:42.660 --> 43:49.220]  как R-value, вам нужно move опять делать от нее, потому что она полноценное неотличимое имя объекта. Но
[43:49.220 --> 43:55.260]  благодаря тому, что вы приняли ее как R-value ссылку, вы как раз и знаете, что move над ней можно
[43:55.260 --> 43:59.420]  сделать, и это легально, потому что вам ее отдали в предположении, что вы будете с ней как с R-value
[43:59.420 --> 44:12.220]  обращаться. Имя объекта уже само по себе является L-value. Ну x, да, это L-value, конечно. Вот, ну раз уж у нас
[44:12.220 --> 44:17.020]  немножечко такой порядок изложения запутан, я вам говорил в первом семестре, что ссылка это
[44:17.020 --> 44:22.460]  неотличимая от объекта. Ну, короче, ссылка никак неотличима от объекта, кроме одного случая,
[44:22.460 --> 44:28.540]  который мы пока умолчим. Кроме какого случая? Вот если вы внимательно слушали Федину пару в
[44:28.540 --> 44:34.340]  прошлый раз, вы должны уже знать какого. Нет, decal type. Вот decal type это та единственная конструкция
[44:34.340 --> 44:40.380]  в языках C++11, которая позволяет вам отличить, настоящий это объект был или ссылка. Потому что
[44:40.380 --> 44:53.220]  если вы пишете decal type от x, decal type от x y равно x, например, вот я так напишу, это будет CE, ошибка
[44:53.220 --> 44:59.620]  компиляции. Вот это ошибка компиляции. Почему? Потому что это им два амперсанда. Decal type помнит
[44:59.620 --> 45:05.780]  какой тип формально на самом деле. И вы написали как будто бы им два амперсанда, y равно x. CE,
[45:05.780 --> 45:11.180]  потому что нельзя инициализировать R-value ссылку через L-value. Понятный пример? Вот этот вот
[45:11.180 --> 45:29.220]  пример. А вот если писать decal type от x, y равно sdmove от x, окей, все. Два амперсанда. CE, конечно.
[45:29.220 --> 45:34.260]  Естественно, это самый базовый пример, который, помните, про R-value ссылки, который мы забрали в
[45:34.260 --> 45:45.620]  прошлый раз. Так, господа, у нас, что? Когда нам нужен decal type с двойными скобочками? Просто на
[45:45.620 --> 45:51.180]  практике не очень понятно. Никогда, просто скорее, если вы так напишете, то у вас будет дополнительный
[45:51.180 --> 45:58.180]  амперсант. Почему decal type? Просто для логирования. Давайте не сейчас, пожалуйста, можно после пары,
[45:58.260 --> 46:04.380]  но мы сейчас не успеем оставшуюся часть. Нам нужно с вами, у нас с вами осталась одна нерешенная
[46:04.380 --> 46:10.100]  проблема. Помните какая? Почему move так странно реализован? Почему он принимает и возвращает такие
[46:10.100 --> 46:18.460]  странные типы? Move принимает, напоминаю, t двойной амперсант, а возвращает remove референса t
[46:18.460 --> 46:26.580]  двойной амперсант. Почему? Да, самый главный вопрос, почему, какого черта move принимает t
[46:26.580 --> 46:31.980]  два амперсанда, если он, если весь его смысл в том, чтобы скастить к двум амперсантам, почему он
[46:31.980 --> 46:38.900]  принимает t два амперсанда? Это главный вопрос, на который нам осталось ответить. И вот если мы
[46:38.900 --> 46:45.900]  успеем на него сегодня ответить, то мы, ну не совсем, конечно, молодцы, но почти молодцы. Хотелось бы
[46:45.900 --> 46:52.220]  еще кое-что успеть, ну да ладно. Ну может Федю чуть-чуть задержу, ладно. А для того, чтобы ответить на этот
[46:52.220 --> 46:57.540]  вопрос, нам нужно с вами пройти еще одну штуку, которая называется проблема perfect forwarding и
[46:57.540 --> 47:07.180]  универсальные ссылки. Это то, о чем Федя заикался вчера, в прошлый раз, но не, ну он вам, так сказать,
[47:07.180 --> 47:16.940]  дал некоторые намеки. Ну давайте, я сейчас напишу, так, какой маркер из этих нормальный,
[47:16.940 --> 47:34.780]  вот этот. Значит, пункт 10.6 будет называться, нет, это плохой маркер, perfect forwarding и,
[47:34.780 --> 47:41.580]  ну их можно называть forwarding references, а можно называть universal references. Давайте
[47:41.580 --> 47:54.060]  будем говорить universal references. А забыли про проблему, ну мы сейчас исследуем некоторую другую
[47:54.060 --> 48:00.620]  проблему, которая не связана с мувом, никак, почти, ну отдаленно связана с мувом, но поняв ее,
[48:00.620 --> 48:06.160]  мы поймем, почему мув так реализован. Вообще, на самом деле, я мув мог бы реализовать, просто
[48:06.160 --> 48:17.920]  приняв туда t&, и это было бы почти всегда правильно. Вот я могу в мув отдать t&, я вам написал реализацию,
[48:17.920 --> 48:24.600]  которая, я напоминаю, я не буду писать заново, потому что это долго, template tape name t, возвращаемый тип это std
[48:24.600 --> 48:31.480]  remove reference от t, и на это наверно 2&, а принимаемый тип t 2&, и вопрос, почему, черт возьми,
[48:31.480 --> 48:38.920]  2& принимаемый тип. Я мог бы принять 1& вместо 2&, и это бы работало почти всегда правильно,
[48:38.920 --> 48:48.120]  это бы работало неправильно, когда, вот кто понимает, в каком случае, когда в мув мы и так отдали rvalue,
[48:48.120 --> 48:53.360]  а такое вообще могло бы быть, потому что в мув мы могли бы случайно отдать rvalue, ввиду того,
[48:53.360 --> 49:01.640]  что какая-нибудь функция вернула нам rvalue, и мы отдаем его в мув, желая, чтобы оно по-любому
[49:01.640 --> 49:09.080]  стало rvalue на выходе. Вот, и тогда это просто не компилировалось бы, если мы в мув бы принимали
[49:09.080 --> 49:18.200]  такую ссылку, то случайно отдав в мув, и так rvalue, мы получили ce. Нам нужна такая реализация мув,
[49:18.200 --> 49:30.960]  которая принимает irvalue, но можно перегрузить две разных, а тем не менее, вот я утверждаю,
[49:30.960 --> 49:35.920]  что оказывается достаточно просто написать мув от t 2& и все, это будет универсальная,
[49:35.920 --> 49:44.360]  она так называется, универсальная ссылка. Пока еще непонятно, сейчас я эту проблему
[49:44.360 --> 49:50.520]  проиллюстрировал на более прикладном примере. Смотрите, вот у нас есть функция pushback,
[49:50.520 --> 49:58.600]  которая, ну на самом деле даже не так, у нас есть в векторе такая функция emplaceback, знаете такой
[49:58.600 --> 50:06.240]  метод. Вот мы с вами, кажется, его не обсуждали, но вообще-то у нас есть в векторе такой метод
[50:06.240 --> 50:14.880]  emplaceback, который принимает много аргументов, то есть что такое emplaceback, это вы создаете объект,
[50:14.880 --> 50:21.400]  кто знает, что такое emplaceback, чем от pushback отличается. Давайте расскажу, у вас допустим вектор строк,
[50:21.400 --> 50:38.560]  и я говорю v.emplaceback, там не знаю, 5 запятая а в одинарных кавычках, что я сделал, я в этот
[50:38.560 --> 50:48.240]  вектор положил строку длины 5, стоящую символов a, я не пишу здесь std string от 5 запятая а, emplaceback
[50:48.240 --> 50:53.240]  позволяет мне непосредственно в памяти, которая принадлежит вектору, сразу сконструировать стринг
[50:53.240 --> 50:57.880]  от нужных аргументов, а не создавать временный промежуточный стринг, который, ну я потом мувать
[50:57.880 --> 51:03.360]  буду или копировать буду, emplaceback позволяет мне сделать еще эффективнее, не создавать вообще
[51:03.360 --> 51:08.200]  промежуточный стринг, а сразу создать стринг от нужных аргументов на нужном месте, понятно?
[51:08.200 --> 51:18.640]  Вот, вот, у emplaceback сигнатура, ну ему нужно переменное количество шаблонных аргументов
[51:18.640 --> 51:32.400]  принять, template, typename, t, вот, emplaceback, и вот тут, typename многоточие args, и вот тут возникает
[51:32.400 --> 51:39.520]  вопрос, а как их принять-то? По какой ссылке? Ну, мы бы написали const args ampersand многоточие args,
[51:39.520 --> 51:49.320]  да, у нас есть пока мы только один способ знаем принять все что угодно, не копируя, у нас был
[51:49.320 --> 51:53.400]  другой пример на самом деле, ситуация, когда нам нужно было принять переменное количество шаблонных
[51:53.400 --> 52:00.280]  аргументов, каждый из которых мог быть как rvl и так и lvl, в чем проблема? У нас может быть каждый
[52:00.280 --> 52:07.480]  из аргументов по отдельности как rvl так и lvl, часть этих может быть rvl, а часть lvl, и вообще говоря
[52:07.480 --> 52:16.240]  мы не знаем, кто кем будет, у нас была и другая проблема, мы, кто вспомнит тот молодец, какая у нас
[52:16.240 --> 52:21.760]  была функция еще одна, вот с такой же почти сигнатуры, где был typename args, и мы написали
[52:21.760 --> 52:31.120]  const args ampersand, потому что другого способа у нас не было, у нас была allocator construct функция,
[52:31.120 --> 52:38.080]  когда мы говорим allocator construct от аргументов конструктора, мы там тоже должны принять
[52:38.080 --> 52:44.680]  переменное количество шаблонных аргументов и отдать их в placement new, но каждый из этих аргументов,
[52:44.680 --> 52:51.000]  мы-то теперь знаем, что это все не так-то просто, у нас аргументы могут быть как rvl и так и lvl,
[52:51.000 --> 52:57.040]  и если у нас allocator construct будет написан так, как он раньше был написан нами, то у нас никому
[52:57.040 --> 53:02.040]  в семантике ничего нам не даст, потому что мы все равно будем копировать все аргументы, вы понимаете,
[53:02.040 --> 53:08.120]  что при нашей реализации allocator, которая была до этого construct, мы будем копировать, потому что
[53:08.120 --> 53:17.040]  мы даже если приняли эти аргументы в pushback или в emplaceback как rvalue, в construct они будут
[53:17.040 --> 53:22.520]  отданы опять как lvalue, потому что по константной ссылке приняты и никакого move мы не сможем
[53:22.520 --> 53:29.560]  сделать с ними, когда мы их отдадим наконец в placement new, мы опять их скопируем, понимаете,
[53:29.560 --> 53:38.920]  вот когда мы сделаем pushback от std move от чего-то, мы примем его по t двойному амперсанду и дальше
[53:38.920 --> 53:46.800]  отдадим в construct, alloc.construct на месте ptr от этого x, который мы приняли, ну от std move от x,
[53:46.800 --> 53:51.680]  который мы приняли, потому что мы rvalue и дальше его move, но сюда-то он придет по константной ссылке
[53:51.680 --> 53:56.360]  опять, потому что у нас нет версии для rvalue здесь, на этом этапе, ну точнее в construct у нас нет
[53:56.360 --> 54:00.880]  версии для rvalue, и значит в placement new дальше он пойдет опять как lvalue, и значит мы его все-таки
[54:00.880 --> 54:11.440]  скопируем, как же нам решить проблему с тем, что мы имея какой-то объект, правильно передаем его
[54:11.440 --> 54:17.200]  дальше, независимо от того является он lvalue или rvalue, был он нам дан как lvalue или rvalue изначально,
[54:17.200 --> 54:22.680]  в частности как мы это делаем, когда у нас переменное количество шаблонных аргументов,
[54:22.680 --> 54:26.400]  если бы у нас был всего один шаблонный аргумент, мы могли написать перегрузку,
[54:26.400 --> 54:31.720]  одну для конст него амперсант, другую для него с двумя амперсантами и просто ходили бы то туда,
[54:31.720 --> 54:35.520]  то сюда в этот констракт, но у нас переменное количество шаблонных аргументов и половина из них
[54:35.520 --> 54:41.160]  может быть rvalue, половина lvalue, и тогда те из них, которые rvalue надо move-нуть при отдаче в new,
[54:41.160 --> 54:50.840]  placement new, а те, которые lvalue move-ать нельзя, что же делать, ну комитет думал-думал и понял,
[54:50.840 --> 54:59.960]  что надо делать костыль, совершенно верно, ничего тут не попишешь, потому что у нас нету,
[54:59.960 --> 55:06.680]  не хватает синтаксиса, чтобы выразить эту идею, нам нужен костыль, именно костыль, иначе это никак
[55:06.680 --> 55:13.240]  не могу назвать, нам нужен костыль, чтобы нам нужен специальный синтаксис, который бы позволял
[55:13.240 --> 55:20.880]  принимать как rvalue, так и lvalue, и как-то приняв их различать, что было реально передано,
[55:20.880 --> 55:26.680]  lvalue или rvalue, и они придумали этот костыль, он называется universal references или forwarding
[55:26.680 --> 55:34.600]  references, вот эта вот штука forwarding references, она же universal references, решает именно эту
[55:34.600 --> 55:42.080]  проблему, и на самом деле мы пишем не const args ampersand здесь, а мы пишем args двойной ampersand,
[55:42.080 --> 56:00.120]  как выглядит на самом деле сигнатура функции construct, она выглядит так, значит void construct,
[56:04.600 --> 56:15.120]  ну вот там t звёздочка ptr, ну тут еще t, и дальше args двойной ampersand многоточие args,
[56:15.120 --> 56:32.000]  вот это костыль, здесь мы используем двойной ampersand, несмотря на то, что можем принять как
[56:32.000 --> 56:37.440]  rvalue, так и lvalue, как же это чёрт возьми работает, ведь мы же договаривались с вами, что rvalue,
[56:37.440 --> 56:43.080]  что когда мы два амперсанда принимаем, это только rvalue может быть пронициализировано,
[56:43.080 --> 56:50.160]  понимаете, это не согласуется с тем, что я говорил раньше, как будто бы я говорил одно,
[56:50.160 --> 56:54.400]  а написал другое, мы же договаривались, что двойной амперсанд может принимать только rvalue,
[56:54.400 --> 57:02.520]  нет, это работает по-другому, это работает вот так, но есть исключение из правил,
[57:02.520 --> 57:11.840]  которое является костылем, не в множественных параметрах дела, а дело в том, что если это два
[57:11.840 --> 57:18.280]  амперсанда, которые навешаны на шаблонный параметр, который является шаблонным параметром
[57:18.280 --> 57:25.600]  этой самой функции, в которой мы объявляем, то правила другие, значит исключение из правил
[57:25.600 --> 57:30.640]  значит так, по ссылке с двумя амперсандами можно принимать только rvalue, за исключением
[57:30.640 --> 57:45.960]  случая, когда эта ссылка шаблонный параметр функции, которую мы и определяем, может быть,
[57:45.960 --> 57:53.400]  если это шаблонный параметр вот той самой функции, которую мы сейчас определяем, если это не шаблон
[57:53.400 --> 58:03.280]  параметров всего класса, вот например, если бы я здесь, тут нету type name t, так, потому что это
[58:03.280 --> 58:09.960]  и для и для одиночных параметров нужно, тебе бывает нужно какую-то функцию написать универсально,
[58:09.960 --> 58:18.120]  это как для move, например, тебе нужно принять в нее и rvalue и lvalue и одинаково обработать,
[58:18.120 --> 58:31.360]  ну это копипастить код всегда бы пришлось, да, именно move подпадает под это исключение, в move
[58:31.360 --> 58:36.760]  принимается t, который является его собственным шаблонным параметром и поэтому два амперсанды
[58:36.760 --> 58:48.960]  на t ведут себя иначе, чем два амперсанды во всех предыдущих случаях, а шаблонная функция,
[58:48.960 --> 58:56.240]  которая принимает только rvalue, а можно написать статик assert на то, что это rvalue и я покажу вам,
[58:56.240 --> 59:05.960]  как это сделать, нет, я сейчас вам покажу, как это сделать, короче, ты потерпи 10 минут,
[59:05.960 --> 59:11.560]  пожалуйста, сейчас мы дойдем до этого и ты поймешь, короче, исключение с правил такое,
[59:11.560 --> 59:19.040]  если у вас это исключение не работает, вот, вот если бы я здесь написал t двойной амперсант,
[59:19.040 --> 59:25.360]  это бы не работало, это бы принимало только rvalue, потому что это t не является шаблонным
[59:25.360 --> 59:29.680]  параметром констракта, оно является шаблонным параметром всего класса, аналогично, когда мы
[59:29.680 --> 59:36.560]  пишем pushback от t двух амперсандов, вот внимание, у нас есть две версии pushback теперь, pushback от
[59:36.560 --> 59:42.200]  const t амперсант и pushback от t два амперсанда, вот этот pushback, который от t два амперсанда,
[59:42.200 --> 59:48.600]  это не исключение, это не универсальная ссылка, это rvalue ссылка, потому что эти t два амперсанда,
[59:48.600 --> 59:54.080]  там t не от pushback, а от самого вектора, а если у вас это шаблонный параметр не функции, а самого
[59:54.080 --> 59:59.040]  класса, откуда функция или чего-то внешнего, то это не попадает под исключение из правил, только
[59:59.040 --> 01:00:04.920]  если это тип, шаблонный параметр того с той самой функции, которую мы определяем, это исключение
[01:00:04.920 --> 01:00:14.720]  из правил, и при этом не разрешено писать ни const, никакие бы еще это ни было украшатели на этот
[01:00:14.720 --> 01:00:20.560]  тип, то есть вот если я например здесь напишу const args два амперсанда, это уже не исключение из правил,
[01:00:20.560 --> 01:00:27.760]  const args два амперсанда это только rvalue, это не универсальная ссылка, если я напишу допустим,
[01:00:27.760 --> 01:00:36.640]  не знаю, vector от args и два амперсанда, это тоже не исключение из правил, это тоже rvalue ссылка,
[01:00:36.640 --> 01:00:43.280]  а не универсальная ссылка, универсальные ссылки прям захардкожно, это костыль, они имеют строго
[01:00:43.280 --> 01:00:49.040]  вот такой вид t, где t шаблонный параметр и функции и два амперсанда и все, если вы что угодно еще
[01:00:49.040 --> 01:00:59.200]  навесите, будет не универсальная ссылка, точно также работает это и с авто, вот вспомните,
[01:00:59.200 --> 01:01:03.840]  что вам Федя говорил на прошлой паре и проассоциируйте это с тем, что я вам сейчас
[01:01:03.840 --> 01:01:10.080]  сказал, когда у вас есть авто в принимаемых параметрах или когда вы говорите авто два
[01:01:10.080 --> 01:01:17.000]  амперсанда x равно чета, авто два амперсанда ведет себя также, как если бы это была шаблонная
[01:01:17.000 --> 01:01:22.680]  штука с template.title.net и два амперсанда, то есть как универсальная ссылка, авто два амперсанда
[01:01:22.680 --> 01:01:28.560]  тоже подчиняется этому исключению из правил, вот, в частности, например, если вы там написали,
[01:01:28.560 --> 01:01:38.640]  а ну ладно, сейчас я вам расскажу в чем исключение, значит по такой ссылке можно понимать как rvalue,
[01:01:38.640 --> 01:01:46.720]  так и lvalue, а теперь вопрос, а хорошо приняли мы его, а как нам дальше понять, оно является rvalue
[01:01:47.360 --> 01:01:55.240]  или lvalue, то есть оно как переменная, конечно, является lvalue, оно было принято как rvalue или как lvalue,
[01:01:55.240 --> 01:01:59.520]  как нам понять, то есть как нам теперь реализовать констракт, вот мы сейчас пишем констракт и
[01:01:59.520 --> 01:02:14.720]  нам нужно написать placement new от ptr, t от, ну args многоточие сюда надо отдать, но что написать-то
[01:02:14.720 --> 01:02:22.360]  надо, мы если мы напишем просто args многоточие, то это будет lvalue, определение lvalue никто не
[01:02:22.360 --> 01:02:28.920]  отменял, args это по-прежнему lvalue, никакое оно не rvalue, это имя переменной, ну многоточие,
[01:02:28.920 --> 01:02:35.400]  распакованный пакет, если мы так напишем, это будет опять копирование, мы ничего не добились,
[01:02:35.400 --> 01:02:42.720]  если мы напишем sdmove от args, мы мувнем все аргументы, и те которые были lvalue изначально,
[01:02:42.720 --> 01:02:50.640]  и те которые были rvalue изначально, потому что move он все кастует к rvalue, нам нужна какая-то еще
[01:02:50.640 --> 01:03:04.000]  одна функция специальная, магическая, которая, которая что? Это lvalue все, args это lvalue,
[01:03:04.000 --> 01:03:17.080]  мы не напишем перегрузку для move, мы напишем другую функцию, называется stdforward, которая как
[01:03:17.080 --> 01:03:22.840]  раз вот эту ситуацию решает, мы вызываем сейчас stdforward с шаблонным параметром args от args,
[01:03:22.840 --> 01:03:32.440]  и она так устроена, что если изначально args был принят как rvalue, то она его мувнет, а иначе не
[01:03:32.440 --> 01:03:42.920]  мувнет и вернет lvalue ссылку, откуда forward узнает надо move или нет, а из шаблонного параметра,
[01:03:42.920 --> 01:03:50.360]  просто правила вывода типа в этом случае другие, помните вам Федя в прошлый раз говорил, что если
[01:03:50.360 --> 01:03:57.800]  вы приняли вот по такой ссылке и приняли вы lvalue, то args будет с одним персандом на самом деле,
[01:03:57.800 --> 01:04:05.200]  а это как раз для того, чтобы вы по типу того, чем является args, могли понять оно как lvalue или
[01:04:05.200 --> 01:04:14.240]  как rvalue вам пришло. Значит, я сейчас пишу следующее заклинание, t от stdforward,
[01:04:14.240 --> 01:04:31.280]  stdforward с шаблонным параметром args от args, многоточие, и это волшебная функция номер два,
[01:04:31.280 --> 01:04:39.680]  которая глядя на этот тип, либо move, либо не move свой аргумент, ну то есть либо возвращает
[01:04:39.760 --> 01:04:47.960]  lvalue ссылку на аргумент, либо возвращает rvalue ссылку на аргумент. Как она понимает это? Она
[01:04:47.960 --> 01:04:53.880]  понимает это потому, если амперсанд на этом типе. Если на этом типе есть одиночные амперсанд,
[01:04:53.880 --> 01:04:59.980]  то она вернёт одиночные амперсанд ссылку на этот тип. Если на этом типе нету одиночного
[01:04:59.980 --> 01:05:06.420]  амперсанда, то есть если это либо 0 амперсандов либо 2, то она вернёт ссылку с 2
[01:05:06.420 --> 01:05:11.780]  амперсандами на этот тип. Таким образом, благодаря правилам вывода шаблонного типа,
[01:05:11.780 --> 01:05:19.260]  которые навешивают амперсанд искусственно, если это было принято как L-value, вы получите L-value
[01:05:19.260 --> 01:05:24.260]  на выходе в том и только том случае, если изначально вам отдали как L-value. Это называется perfect
[01:05:24.260 --> 01:05:35.900]  forwarding, идеальная передача. Сейчас я реализую forward. Конечно же, вы думали, вы избежите этого?
[01:05:35.900 --> 01:05:51.460]  Да, по сути forward просто casted karx, это правда. Да, по сути да. Давайте реализуем forward сразу.
[01:05:51.460 --> 01:06:12.060]  Это что, кринш? В смысле, почему? Что-то никогда шаблонную функцию от аргументов не вызывал?
[01:06:12.060 --> 01:06:20.020]  Как это не похоже? Многоточие это распаковка пакета, пакетом является все это. Мы с вами
[01:06:20.020 --> 01:06:29.580]  fold expression написали вообще. Да, да. Что? Во-первых, forward работает от одного элемента. Да, конечно.
[01:06:29.580 --> 01:06:35.140]  Это многоточие, оно через запятую повторяет SD forward от всего подряд. То есть move всегда
[01:06:35.140 --> 01:06:41.900]  превращает в R-value, не зависимо от того, чего он делает. Да. Forward это условный cast karx value,
[01:06:41.900 --> 01:06:47.260]  move это безусловный cast karx value. Что вы ему не дали, на выходе получите R-value, ссылку на это.
[01:06:47.260 --> 01:06:52.140]  Forward это такой cast karx value, что если вы ему дали вот с этим шаблонным параметром с
[01:06:52.140 --> 01:06:56.660]  амперсандом, вы получите R-value, ссылку. А если дали шаблонный параметр без амперсандов или с
[01:06:56.660 --> 01:07:04.900]  двумя, то получите R-value, ссылку. А давайте сейчас мы реализуем и поймем, как он поймет. Сейчас мы
[01:07:04.900 --> 01:07:15.180]  реализуем forward просто. Ну в этом же пункте я просто реализую forward. Какие еще вопросы были?
[01:07:15.660 --> 01:07:21.020]  Хорошо, а template type name T.
[01:07:21.020 --> 01:07:50.860]  да нет нет нет не только множественных у тебя move пример функции которые нужно
[01:07:50.860 --> 01:07:58.380]  принимать как rvalue так и lvalue вот move это банальнейший пример но можно придумать и другие примеры можно
[01:07:58.380 --> 01:08:04.460]  придумать функцию которая делает что-то длинное и дальше передает этот смысл названия perfect
[01:08:04.460 --> 01:08:11.380]  forwarding в чем почему оно perfect perfect forwarding в смысле передать ну пересылка да идеальная
[01:08:11.380 --> 01:08:18.580]  пересылка вы приняли объект какое-то value и отдали его дальше сохранив вид value вот что вам
[01:08:18.580 --> 01:08:24.580]  что такое perfect forwarding perfect forwarding это о том как принять объект и отдать его дальше в том же
[01:08:24.580 --> 01:08:29.100]  виде value в котором вы его приняли это не обязательно только для множественных
[01:08:29.100 --> 01:08:41.060]  аргументов нужно это может быть много для чего нужно мы не храним в том-то и дело сам объект
[01:08:41.060 --> 01:08:47.700]  сама переменная это всегда lvalue да причем забудь про пакет блин все нет многоточия здесь один
[01:08:47.700 --> 01:08:55.660]  аргумент у тебя у тебя есть переменная она всегда lvalue да за счет того что шаблонный параметр
[01:08:55.660 --> 01:09:00.740]  выведется по-другому если это было lvalue я тебе говорю и федя прошлый раз про это говорил если
[01:09:00.740 --> 01:09:09.100]  у вас вот такая сигнатура функции и вы передали lvalue то arc станет равен типу с навешенным
[01:09:09.100 --> 01:09:14.740]  искусственно одиночным персандом если вы вызвались это у вас пример был в прошлый раз
[01:09:14.740 --> 01:09:24.460]  если вы вот у меня был int x и я вызвался от x а функция у меня была шаблонная которая принимала
[01:09:24.460 --> 01:09:37.380]  t двойной амперсанд если я так сделаю то t будет равен int амперсанд да и значит передав forward
[01:09:37.380 --> 01:09:43.860]  этот arc ну то есть этот t мы будем видеть что нас вызвали шаблонным аргументом т с амперсандом
[01:09:43.860 --> 01:09:49.820]  а значит мы вернем t амперсанд и по сути что надо сделать реализации формат это просто
[01:09:49.820 --> 01:09:54.740]  проверить наш шаблонный аргумент он сам персандом с одиночным или нет и если да то не делать
[01:09:54.740 --> 01:10:07.980]  муфа если да то сделать наоборот да да причем тут пакет вообще ничего не меняет конечно может
[01:10:07.980 --> 01:10:16.420]  для каждого аркс выведется свой тип многоточие это просто синтеп просто банально как если бы
[01:10:16.420 --> 01:10:22.540]  через запятую написал template arc 1 type name arc 1 запятая type name arc 2 запятая type name arc n
[01:10:22.540 --> 01:10:30.100]  arc 1 2 амперсанды arc 1 arc 2 амперсанды arc 1 и так далее arc n arc n это просто повторение
[01:10:30.100 --> 01:10:35.100]  через запятую всего этого для всех типов для каждого конечно же выводится независимо
[01:10:35.100 --> 01:10:43.060]  конец многоточие здесь стоит многоточь вот это все через запятую повторяется для
[01:10:43.060 --> 01:10:53.940]  всех аркс из пакета для каждого арка отдельно выводится все это просто пакет fold expression это
[01:10:53.940 --> 01:10:58.540]  если поменять это все было соединено каким-то бинарным оператором например или и тут еще многоточие
[01:10:58.540 --> 01:11:05.060]  стояло это не fold expression это просто распаковка пакета стандартная c++ 11 fold expression появились
[01:11:05.060 --> 01:11:17.620]  только c++ 17 это штука c++ 11 да чего ничего чего ничего а реализуем форвард давайте реализуем
[01:11:17.620 --> 01:11:23.340]  форвард хотя бы сегодня я обещал федя что вы будете знать как работает форвард когда он придет
[01:11:23.340 --> 01:11:38.460]  поэтому нам надо поторопиться что пора в принципе дает того что я ему дом войти я не обещал так
[01:11:38.460 --> 01:11:48.140]  какой превозвращаемый тип должен быть вообще короче не знаю упражнения на даже не знаю на что
[01:11:48.140 --> 01:11:53.900]  придумайте как должен быть реализован форвард что должен он принимать и что должен возвращать
[01:11:53.900 --> 01:12:15.740]  хорошо молодец я не расслышал просто нам нужна нам нужно разное проведение в зависимости от
[01:12:15.740 --> 01:12:20.060]  того вот это те которые нам пришло как шаблонный аргумент оно с амперсандом или без
[01:12:20.060 --> 01:12:30.620]  значит смотрите давайте он сначала напишу неправильную реализацию форвард неправильная
[01:12:30.620 --> 01:12:35.660]  реализация форвард давайте возвращать т2 амперсанды и принимать т2 амперсандо
[01:12:35.660 --> 01:12:54.540]  нет значит тем не менее это довольно не тривиальный вопрос почему это будет
[01:12:54.540 --> 01:13:01.020]  неправильно работать оно принимает как смотрите я вас сейчас кручу верчу запутать хочу я принимаю
[01:13:01.020 --> 01:13:07.780]  сюда как рвл так и лвл что мне и нужно и возвращаю как рвл так и лвл что мне и нужно причем если
[01:13:07.780 --> 01:13:11.980]  было лвл то здесь будет один амперсанд и я верну один амперсанд потому что по правилам
[01:13:11.980 --> 01:13:18.860]  склопывания ссылок я напомню вернется т с одним амперсандом здесь было рвл то здесь же не
[01:13:18.860 --> 01:13:28.900]  будет т ну ты ты же у меня без амперсандов будет если там было рвл так еще раз мне нужно из
[01:13:29.680 --> 01:13:35.020]  форварда возвращать т амперсанд или т2 амперсанда смотря был ли исходит и т с амперсандом или без
[01:13:35.020 --> 01:13:43.100]  если ты был сам banned то когда его приму сюда он и будет сам бжан сильно что один амперсант
[01:13:43.100 --> 01:13:49.020]  плюс два пасана это один амперсанд значит это будет тем персант и я сделаю каст к т амперсанд
[01:13:49.020 --> 01:13:54.280]  и вер transitioning и здесь здесь будет по одному амперсанду и вернутьordum если ты был с двумя
[01:13:54.280 --> 01:13:59.120]  амперсандами или без амперсандов вообще, то здесь будет 2 амперсанды, здесь 2 амперсанды,
[01:13:59.120 --> 01:14:02.800]  здесь 2 амперсанды, и я верну 2 амперсанды. Вопрос, почему это неправильно работает?
[01:14:02.800 --> 01:14:04.040]  Чего?
[01:14:04.040 --> 01:14:10.040]  Это неправильно работает, потому что нужно сделать вашу блоговую параметру, потому что этот t просто заново выведет.
[01:14:10.040 --> 01:14:16.920]  Нет, нет, нет, нет. Я явно передаю сюда t.
[01:14:16.920 --> 01:14:18.440]  Так это же l value, разве нет?
[01:14:18.440 --> 01:14:19.440]  Кто l value?
[01:14:19.440 --> 01:14:20.440]  Перемены, которые вы передаете.
[01:14:20.440 --> 01:14:32.600]  Аркс, да. Нет, если я явно передаю, подождите, если, подождите, если я явно передаю функцию шаблонный параметр, то я, конечно же, побеждаю правила вывода.
[01:14:32.600 --> 01:14:36.200]  Ну, я явно говорю, с каким шаблонным параметром я вызываюсь.
[01:14:37.000 --> 01:14:43.360]  Ну окей, смотрите, вот, аркс это t2 амперсанды, когда у нас аргумент функции это...
[01:14:43.360 --> 01:14:44.880]  Подожди, аркс вот здесь?
[01:14:44.880 --> 01:14:50.600]  Да, ну пусть это, пусть аркс, ну да, пусть передаваем it правильным, это какая-то...
[01:14:50.600 --> 01:14:53.080]  Стринг, давайте говорить стринг, стринг 2 амперсанды.
[01:14:53.080 --> 01:14:59.000]  Стринг 2 амперсанды, то аргументу функции это тоже стринг 2 амперсанды, мы туда передаем l value.
[01:14:59.000 --> 01:15:02.840]  Да, это правильно, это правильный ответ, почему это не будет правильно работать.
[01:15:02.840 --> 01:15:03.840]  Ничего не возможно.
[01:15:03.960 --> 01:15:08.960]  Значит, это просто не будет компилироваться в случае, когда у нас на самом деле было l value здесь.
[01:15:09.960 --> 01:15:16.600]  Потому что мы принимаем стринг 2 амперсанды, ну вот представьте, что мы разбираем случай как...
[01:15:16.600 --> 01:15:23.640]  Если у нас случай с одним амперсандом, все нормально, если мы разбираем случай с двумя амперсандами, то у нас будет CE.
[01:15:23.640 --> 01:15:32.920]  Почему? Потому что тип аркс, он без амперсандов на самом деле, ну, аркс 2 амперсанды, это стринг 2 амперсанды.
[01:15:33.000 --> 01:15:39.240]  Просто аркс, это просто стринг, мы вызываем SD forward от стринг шаблонного параметра, от аркс.
[01:15:39.240 --> 01:15:47.720]  Аркс это l value, здесь тип оказывается стринг 2 амперсанды, и мы принимаем l value.
[01:15:47.720 --> 01:15:54.720]  Так это же CE, мы не можем от l value вызваться по l value ссылке.
[01:15:54.720 --> 01:16:00.200]  Это в параметре написано, это remove, reference.
[01:16:00.200 --> 01:16:10.000]  Точно! Именно поэтому в параметре forward нужно принимать не T2 амперсанды, а наоборот SD remover reference, а T.
[01:16:12.000 --> 01:16:22.000]  Значит, когда мы реализуем move, мы принимаем T2 амперсанды, а возвращаем SD remover reference, а в forward мы наоборот делаем.
[01:16:31.000 --> 01:16:40.000]  Амперсанды, да, во-первых, хорошо, ладно, ну я на всякий случай, я просто не расслышал.
[01:16:43.000 --> 01:16:48.000]  Смотрите, еще раз, предположим, что тут написано T2 амперсанды X.
[01:16:49.000 --> 01:16:59.000]  Это на самом деле вопрос, который, ну, я не знаю, это, ну, ну нет, это вопрос не на ОТО, скорее, ну, вы про 2, для вас это будет вопрос на HOR 7 где-то.
[01:16:59.800 --> 01:17:03.800]  Почему такая реализация forward неправильная? Это не очевидно, вот это вопрос на понимание, почему так нельзя.
[01:17:04.800 --> 01:17:06.800]  Почему нельзя принять T2 амперсанды и вернуть T2 амперсанды?
[01:17:07.800 --> 01:17:14.800]  Казалось бы, я для случая, когда l value у меня здесь будет 1 амперсант, здесь будет 1 амперсант, здесь 1 амперсант.
[01:17:15.800 --> 01:17:19.800]  Я принял l value и вернул тип с 1 амперсандом, что и нужно.
[01:17:20.600 --> 01:17:32.600]  Но проблема, когда я принимаю, подожди, проблема в том, что я, если мне здесь дали r value, оно превратилось в l value, args теперь l value.
[01:17:33.600 --> 01:17:38.600]  А тип у него string 2 амперсанды, args равно string.
[01:17:39.600 --> 01:17:46.600]  Значит, я вызываю std forward с параметром string от args, где args l value.
[01:17:47.400 --> 01:17:54.400]  И приходя сюда, я получаю тип шаблонного параметра string с 2 амперсандами.
[01:17:57.400 --> 01:17:59.400]  А принял я l value.
[01:18:00.400 --> 01:18:04.400]  То есть я пытаюсь string 2 амперсанды проинтересировать через l value. Это ошибка компиляции.
[01:18:07.400 --> 01:18:13.400]  Какое исключение? Я явно сказал, какое T я подставляю.
[01:18:14.200 --> 01:18:16.200]  Я forward'у явно говорю, какое T я подставляю.
[01:18:17.200 --> 01:18:20.200]  Если я forward'у явно не буду давать шаблонный параметр, это просто CE.
[01:18:21.200 --> 01:18:27.200]  Потому что это идея не может работать, потому что forward'у нужно явно передавать шаблонный параметр, чтобы он знал, как ему себя вести.
[01:18:28.200 --> 01:18:30.200]  Мне нужно сохранить для forward'а вот этот шаблонный параметр.
[01:18:31.200 --> 01:18:36.200]  Я явно подставляю сюда шаблонный параметр, и здесь образуется string с 2 амперсандами.
[01:18:37.000 --> 01:18:39.000]  T равно string 2 амперсандами.
[01:18:42.000 --> 01:18:44.000]  T 2 амперсанды равно string 2 амперсанды.
[01:18:45.000 --> 01:18:50.000]  Тогда я по l value ссылке пытаюсь проинтересировать l value.
[01:18:51.000 --> 01:18:53.000]  Это CE. Чего?
[01:18:53.800 --> 01:18:57.800]  У нас все перестает работать, потому что не работает l value дальше.
[01:19:00.800 --> 01:19:08.800]  Здесь я делаю явный подставок шаблонного параметра, поэтому T 2 амперсанды работает не по тем правилам, по которым надо.
[01:19:09.800 --> 01:19:11.800]  Не по тем правилам, по которым работает универсальная ссылка.
[01:19:12.800 --> 01:19:14.800]  И это универсальная ссылка.
[01:19:15.800 --> 01:19:19.800]  Но я явно говорю, с каким типом я вызываюсь, и поэтому правила типов не работают вообще.
[01:19:20.600 --> 01:19:25.600]  Если я явно говорю функции, с каким T я ее вызываю, то никаких правил вывода типов не применяются, используя тот T, который я дал.
[01:19:26.600 --> 01:19:27.600]  Да.
[01:19:29.600 --> 01:19:32.600]  Что такое forward от 1? С каким шаблонным параметром?
[01:19:35.600 --> 01:19:37.600]  Forward с шаблонным параметром int от 1.
[01:19:38.600 --> 01:19:39.600]  Можно.
[01:19:40.600 --> 01:19:41.600]  Подожди.
[01:19:43.600 --> 01:19:46.600]  Подожди, пожалуйста. У forward есть вторая перегрузка.
[01:19:47.600 --> 01:19:49.600]  Мы не полностью пока forward реализовали.
[01:19:50.600 --> 01:19:57.600]  А как раз для таких случаев, как вот такие вот умненькие ребята, значит, предлагают, есть все, комитет предусмотрел.
[01:19:58.600 --> 01:20:00.600]  Значит, смотрите, комитет все предусмотрел.
[01:20:01.600 --> 01:20:05.600]  Поэтому я принимаю не T 2 амперсанды, а standard move reference от T с одним амперсандом.
[01:20:06.600 --> 01:20:08.600]  С одним амперсандом, а не с двумя.
[01:20:09.600 --> 01:20:13.600]  Потому что если я буду принимать его с двумя, я проблему свою не переборю, я буду по-прежнему R-value.
[01:20:14.600 --> 01:20:18.600]  Я снимаю все амперсанды с T и навешиваю одиночный амперсанд.
[01:20:19.400 --> 01:20:20.400]  А почему без cons?
[01:20:21.400 --> 01:20:23.400]  Как бы вы пойдешь в 3?
[01:20:25.400 --> 01:20:26.400]  И от remove reference.
[01:20:27.400 --> 01:20:28.400]  Почему такое тимисочение?
[01:20:29.400 --> 01:20:32.400]  Ааа… Чего? Какое? Подожди.
[01:20:33.400 --> 01:20:35.400]  T это тип. Remove reference это метафункция.
[01:20:36.400 --> 01:20:41.400]  Короче, чтобы тип минимального значения был con, a и вот так.
[01:20:42.400 --> 01:20:45.400]  Remove reference это метафункция, она и так от T снимает.
[01:20:46.400 --> 01:20:48.400]  Она с T просто снимает амперсанды, а cons, если был, он там останется.
[01:20:48.600 --> 01:20:56.040]  вот и возвращай вот это и это правильно работает в обоих случаях если это был т
[01:20:56.040 --> 01:21:07.640]  амперсант мы с двумя персантами если мы приняли строку как рвл и сюда аркс это стринг мы с
[01:21:07.640 --> 01:21:16.080]  шаблонным параметром стринг вызываемся от лвл и стринга попадаем сюда здесь этот тип превращается
[01:21:16.080 --> 01:21:26.520]  в стринг 1 амперсант нет тип иногда бывает стринг с амперсантом а зачем рему в референс это
[01:21:26.520 --> 01:21:32.640]  отличный вопрос правильно почему бы не понимать да почему во классно вопрос номер два да да да
[01:21:32.640 --> 01:21:46.520]  отлично я забыл о давай заходи вопрос номер два почему почему нельзя так написать сейчас мы увидишь
[01:21:46.520 --> 01:21:56.800]  тут разбираем интересные случаи мне кажется свет можно включить уже весь значит окей с двумя
[01:21:56.800 --> 01:22:00.000]  персантами мы поняли что так нельзя а почему с одним амперсантом нельзя
[01:22:03.040 --> 01:22:08.520]  подожди нам и не нужен вывод типа для форвардом мы ему явно передаем шаблонный аргумент
[01:22:08.520 --> 01:22:22.560]  в каком случае реализация вот с ты одиночным персантом будет работать неверно это более
[01:22:22.560 --> 01:22:29.880]  сложный вопрос чем предыдущий когда мы перейдем рвл ию а когда и зачем мы можем передать
[01:22:29.880 --> 01:22:34.680]  форвард рвл но подождите ведь тогда и такая реализация тоже не будет работать
[01:22:34.680 --> 01:22:46.440]  да нам не старая перегрузка короче давайте я не буду не буду ждать вы потом как бы те видос
[01:22:46.440 --> 01:22:53.480]  пересматривать вы может осознайте есть две причины почему так не надо делать одна менее
[01:22:53.480 --> 01:22:59.120]  веская вторая более веская сначала начну с менее хотя кому как начну с менее веской причины если
[01:22:59.120 --> 01:23:04.400]  я буду принимать т амперсант просто как и т2 амперсанта в принципе то форвард будет работать
[01:23:04.400 --> 01:23:09.280]  и без явного указания шаблонного параметра а это значит что если я случайно забуду указать
[01:23:09.280 --> 01:23:14.040]  шаблонный параметр это не будет ошибкой компиляции и сделается все время версия которая мне не нужна
[01:23:14.040 --> 01:23:21.760]  может быть вот то что я принимаю такой тип лишает компилятор возможности самостоятельно вывести
[01:23:21.760 --> 01:23:28.080]  шаблонный параметр и мне необходимо явно его указывать всякий раз при вызове форварда если бы
[01:23:28.080 --> 01:23:33.040]  форвард принимал вот это то он бы автоматически выдел шаблонный параметр я бы мог просто забыть
[01:23:33.040 --> 01:23:38.000]  его указать и тем самым получил бы не ту версию которая мне нужна это не было бы никакой не
[01:23:38.000 --> 01:23:48.440]  ошибка ни в орнинг а это это первая причина менее веская ну или более вескому нравится вторая
[01:23:48.440 --> 01:23:56.880]  причина я могу вообще говоря форвард как ему вызвать от результата вызвать чего-нибудь другого
[01:23:56.880 --> 01:24:08.240]  но вот у меня есть какая-нибудь функция ты которая который я результат который хочу
[01:24:08.240 --> 01:24:16.400]  форварднуть если она мне вернула лвл и ссылку я хочу значит ее и дальше как лвл и передать а
[01:24:16.400 --> 01:24:21.960]  если вернула рвл это я хочу и дальше как рвл и передать я хочу вот эту штуку сделать либо
[01:24:21.960 --> 01:24:29.040]  рвл и либо лвл и в зависимости от того что было тут сейчас это какой-то дурацкий пример потому
[01:24:29.040 --> 01:24:34.080]  что оно и так оно и так правильно сработает сейчас подождите подождите подождите значит нужно
[01:24:34.080 --> 01:24:42.200]  посложнее пример давайте подумаю какой пример когда я могу получить а подождите сейчас сейчас
[01:24:42.200 --> 01:25:00.960]  блин что-то забыл пример слушать шаблонная функция есть шаблонная функция f которая
[01:25:00.960 --> 01:25:07.640]  сама что-то возвращает и ее результат я хочу форварднуть
[01:25:12.200 --> 01:25:17.480]  да я явно указывают т
[01:25:17.480 --> 01:25:32.240]  а так правильно смотрите эта функция она может случайно вернуть мне lвл вот я нахожусь в каком
[01:25:32.240 --> 01:25:38.880]  нибудь в какой-нибудь шаблонной функции в которую принял x и допустим я здесь хочу делать не от
[01:25:38.880 --> 01:25:46.680]  аркс вызов а от еще чего-нибудь от аркс например от f от аркс но я хочу делать форвард не с тем не
[01:25:46.680 --> 01:25:53.280]  в зависимости от чем мне это f вернуло в зависимости от что здесь было понимаете то есть у меня может
[01:25:53.280 --> 01:26:00.520]  быть функция какая-то вызвана вызвана от этих аргументов которая тоже иногда мне дает рвл иногда
[01:26:00.520 --> 01:26:07.000]  lвл но я хочу дальше форвардить эту штуку в зависимости от того вот здесь она была рвл или
[01:26:07.000 --> 01:26:17.280]  лвл может быть такая ситуация что я сюда принял эту штуку как лвл нет не так я сюда принял эту
[01:26:17.280 --> 01:26:25.720]  штуку как рвл это функция вернула мне лвл но я все равно хочу ее форварднуть как рвл потому что
[01:26:25.720 --> 01:26:36.160]  здесь на этой уровне я знаю что она рвл поэтому иногда мне бывает вот а может быть другая ситуация
[01:26:36.160 --> 01:26:44.200]  эта штука мне была рвл и f мне вернула рвл и я форварднуть я хочу как рвл но то есть иногда
[01:26:44.200 --> 01:26:51.280]  бывают сценарии в которых мне все-таки нужно вызывать форвард от рвл поэтому только лишь
[01:26:51.280 --> 01:26:57.840]  такой перегрузкой я не обойдусь и мне нужна вторая перегрузка вторая перегрузка отличается от
[01:26:57.840 --> 01:27:03.640]  этой ничем кроме того что статик ассерт написан значит вторая перегрузка выглядит так ты двойной
[01:27:03.640 --> 01:27:10.720]  персант форвард что-то у федя какой-то взгляд как будто ему самому страшно вторая перегрузка
[01:27:10.720 --> 01:27:17.680]  выглядит так ты двойной персант форвард от всего того же самого с двумя амперсантами и она делает
[01:27:17.680 --> 01:27:25.300]  то же самое но только здесь изначально написан статик ассерт что ты не лвл ю референс потому
[01:27:25.300 --> 01:27:33.760]  что если мы пытаемся форвардить то что здесь было лвл ю референсом а мы хотим его как рвл ю
[01:27:33.760 --> 01:27:41.120]  трактовать то это неправильное использование форварда и мы ци кидаем в этом случае кто не пройдет в эту
[01:27:41.120 --> 01:27:51.560]  версию если f вернула мне рвл ю ф меня вернула рвл ю и здесь было принято как рвл ю я хочу
[01:27:51.560 --> 01:27:56.000]  форварднуть как рвл ю тогда вот на тот случай мне как раз нужна вторая версия как раз то что
[01:27:56.000 --> 01:28:05.080]  сказал f форвард от инт от одного если у меня была ситуация что мне здесь приняли что мне здесь
[01:28:05.080 --> 01:28:17.160]  дали лвл ю а это f почему-то вернула мне рвл ю и я хочу его как рв а в смысле ци будет сейчас
[01:28:17.160 --> 01:28:24.920]  наоборот наоборот наоборот здесь было лвл ю а здесь рвл ю и я хочу в эту версию я хочу
[01:28:24.920 --> 01:28:33.040]  форварднуть его как лв как наоборот блин я все перепутал я хочу как рв я что хочу я хочу
[01:28:33.040 --> 01:28:40.640]  нарушить вид вл я хочу форварднуть как рв то что не было рв вот я хочу вот вот это было
[01:28:40.640 --> 01:28:48.480]  лв вот это стало рв и я хочу форварднуть его как лв и это значит что я попадаю во вторую версию
[01:28:48.480 --> 01:28:54.360]  ст с одиночным аперсаном и вот так не должно быть и форрот мне должен ци кинуть в этом случае
[01:28:54.360 --> 01:29:02.640]  это зависит от того чему равно аркс еще раз сценарий сюда я принял это как лв но
[01:29:02.680 --> 01:29:06.360]  по какой-то причине ввиду того что я не аккуратно здесь что сделал вернулась
[01:29:06.360 --> 01:29:14.600]  рв и изначально которое было лв вернулась как рв тогда я пытаясь отдать его форвард с
[01:29:14.600 --> 01:29:20.040]  параметром с лв должен получить ци потому что форвард не скажет чувак ты нарушаешь тебе
[01:29:20.040 --> 01:29:26.720]  далее лв ты не должен передавать дальше как рв ты должен и дальше передавать как лв статика
[01:29:27.040 --> 01:29:34.720]  что вот этот тип это лв референс вот этот тип лв референс ну например так можно писать все
[01:29:34.720 --> 01:29:44.880]  на сегодня давайте так собственно сегодня вопросы про тайп на им и тайпов не принимаются потому
[01:29:44.880 --> 01:29:49.800]  что я вам скидывал как те функции реализован кто хотел посмотрел я считаю и
[01:29:49.800 --> 01:30:06.240]  ну хорошо смотрите у меня есть 4 функции которые делают типа одно и то же принимают x возвращают
[01:30:06.240 --> 01:30:20.680]  x вот ну казалось бы все должно быть очень просто смотрите у меня есть вектор из стабулов
[01:30:20.680 --> 01:30:29.800]  давайте попробуем угадать какой тип возвращает функции ну сначала какой типу вектора давайте
[01:30:29.800 --> 01:30:46.960]  вектор был да класс вы еще здесь а у этого какой тип вектор был все верно что такое больше
[01:30:46.960 --> 01:30:54.640]  я не знаю как отвечать на этого ну смысле формально это функции ну оператор не странно
[01:30:55.240 --> 01:31:14.840]  сейчас в чем вопрос еще раз значит ребят но я считаю что вы должны знать что такое шаблонные
[01:31:14.840 --> 01:31:26.800]  аргументы если что это были шаблонные аргументы они передаются через угловые скобочки так же
[01:31:26.800 --> 01:31:38.120]  известный как больше меньше так как как как же вас кокнуло то ну хорошо давайте так если дому
[01:31:38.120 --> 01:31:52.240]  вектора что вернется два амперсанды три амперсанды кто больше ну сколько два или
[01:31:52.360 --> 01:32:08.960]  а вот кто один почему один а почему один амперсанд откуда взялся это правда но откуда взялся
[01:32:08.960 --> 01:32:31.800]  1 скобочки это expression ну в общем я утверждаю что вы не правы так хорошо так а вот этого какой
[01:32:31.800 --> 01:32:54.400]  тип ну просто вызываем создаем вектор спрашиваем какой давайте вот помните у нас
[01:32:54.400 --> 01:33:01.320]  есть два вида дикол тайпа вот в какой вид из дикол тайпов мы пойдем в обычный что делает
[01:33:01.320 --> 01:33:10.480]  обычный ну да смысл когда мы попадаем в обычный тип когда мы просто называем объект да но тут
[01:33:10.480 --> 01:33:20.800]  мы не называем объект мы создаем новый объект это expression я считаю это вектор был так вот
[01:33:20.800 --> 01:33:33.440]  один амперсант или два два почему два это expression airvalue но помните там была небольшая не то
[01:33:33.440 --> 01:33:39.280]  что путаница но сложный в конце семинара что я говорил что вот если у нас от expression дикол
[01:33:39.280 --> 01:33:45.800]  type вызывается и expression категория l value то у нас всегда будет амперсант а если категория
[01:33:45.800 --> 01:33:53.200]  airvalue это иногда 2 амперсанда иногда 0 амперсанда вот мы там еще про x-value что-то
[01:33:53.200 --> 01:34:06.040]  поговорили мне кажется 0 амперсанда вы еще еще нет хорошо ну в общем тут я утверждаю что будет
[01:34:06.040 --> 01:34:27.560]  0 амперсанда мы это еще проверим да а вот здесь вот должно быть что почему 2 я бы поставил на
[01:34:27.560 --> 01:34:35.200]  вот это но честно говоря я их не давно уже выпускал да типа скобочки вроде должны были
[01:34:35.200 --> 01:34:48.320]  добавить ничего да какая-то фигня какая нет
[01:34:48.320 --> 01:35:01.400]  смотри что тебе должен вернуть вектор булов от нуля вектор был от нуля что должен вернуть
[01:35:01.400 --> 01:35:10.080]  нет конечно же не был бит референс этот промежуточный объект он где-то хранится
[01:35:10.080 --> 01:35:17.520]  он создается на лету при доступе по квадратным скобочкам векторе был не хранятся не нам не
[01:35:17.520 --> 01:35:21.560]  возвращается ссылка на него нам создается новый объект и возвращается он без всяких ссылок
[01:35:21.560 --> 01:35:28.880]  поэтому я ставлю на то что здесь будет бит референс без ссылок а здесь
[01:35:28.880 --> 01:35:49.840]  вообще не мне кажется что хорошее правило так сказать большого пальца это что есть у
[01:35:50.840 --> 01:35:59.680]  количество амперсандов сохранится вот то есть если было 0 накинется 0 если было 2 типа
[01:35:59.680 --> 01:36:07.600]  накинется 2 получится 2 примерно так ну вот собственно говоря если верить в это правило
[01:36:07.600 --> 01:36:13.040]  большого пальца то здесь у нас накинулась 2 амперсанды я утверждаю что будет бит референс
[01:36:13.040 --> 01:36:28.160]  да да ну смотри и это рвл и это рвл но вот здесь не было амперсандов на самом деле века ну типа
[01:36:28.160 --> 01:36:34.840]  вектор булов вернет тебе новый объект новенький на него никого референция нет он его по значению
[01:36:34.840 --> 01:36:43.240]  вернет где без скобочек я тут все возможные варианты по моему разобрал по количеству скобочек
[01:36:43.240 --> 01:36:56.360]  после вот шестая функция у нас вызывается нужно принять он вызывается от объекта или от экспресс
[01:36:56.360 --> 01:37:15.000]  кстати говоря кстати говоря ну как бы в этом случае неважно ответ будет один тот же какой-то
[01:37:15.000 --> 01:37:21.840]  пойдет дикл тайп я кстати говоря не уверен потому что формально если не ошибаюсь оператор квадратной
[01:37:21.840 --> 01:37:26.720]  скобки это одно из исключений которое не считается выражением считается доступом но не уверен
[01:37:26.720 --> 01:37:35.920]  считается ли кастомный оператор квадратной скобки типа написанной они но что считался
[01:37:35.920 --> 01:37:41.720]  смысл в том что на самом деле то что вывести не зависит от того как бы куда мы считаем в
[01:37:41.720 --> 01:37:48.600]  какой дикл тайп мы попали вывести одно и то же я утверждаю вывести вывести должен быть референс
[01:37:48.600 --> 01:37:51.480]  без амперсандов
[01:37:51.480 --> 01:38:04.520]  хорошо сколько ты хочешь чтобы ссылок навесилось
[01:38:04.520 --> 01:38:19.560]  чем одна ну рвл обычно 2 типа значит ну смотри те квадратные скобочки просто возвращают новый
[01:38:19.560 --> 01:38:29.280]  объект даже вообще без референсов на него просто сам объект по значению это рвл если из функции
[01:38:29.280 --> 01:38:34.480]  возвращается объект это рвл самая классическая
[01:38:34.480 --> 01:38:51.160]  нет это не то ну давайте хорошо посмотрим результаты еще раз разберем быстренько
[01:38:51.160 --> 01:38:55.680]  вопрос и пойдем дальше я думал что вы все дома посмотрите этот палик вы ж прости скидывать
[01:38:56.280 --> 01:39:05.920]  identity 1 давайте посмотрим что такое identity 1 это мы авто икс return авто передаем туда 1
[01:39:05.920 --> 01:39:08.600]  и еще варианты
[01:39:08.600 --> 01:39:18.440]  все больше нет вариантов но я тогда с вами соглашусь это инт хорошо identity 2
[01:39:18.440 --> 01:39:23.680]  что такое identity 2 вот так скобочки добавились
[01:39:23.680 --> 01:39:41.840]  почему инт потому что на вывод типов для авто expression это у нас или просто название
[01:39:41.840 --> 01:39:46.720]  объекта никак не влияет я напомню это важно только для дикел тайпа
[01:39:46.720 --> 01:40:04.000]  хорошо identity 3 от единицы у нас вообще 3 автоводной строчки я замечу ну теперь он будет
[01:40:04.120 --> 01:40:20.380]  да все так это инт и последний тоже инт а на бонусные баллы скажи почему желтеньким посвящена это
[01:40:20.380 --> 01:40:30.000]  строка потому что у нас это декл тайпа это декл тайп скобочка скобочка но двойные так вот и поэтому
[01:40:30.000 --> 01:40:42.800]  он будет выводить не тип expression ну и видимо все плюсов не очень нравится то что мы нет но это
[01:40:42.800 --> 01:40:55.880]  warning желтенькая warning нет warning warning тут потому что действительно у нас ссылка на время объект это
[01:40:55.880 --> 01:41:00.360]  подсказка к тому что вернется а персант почему вернется а персант потому что мы добавили
[01:41:00.360 --> 01:41:10.360]  скобки по правилам дикл тайпа это теперь expression что это это l value значит один а персант вот
[01:41:10.360 --> 01:41:18.520]  такая цепочка рассуждений приводит нас к ворнингу а ворнинг в чем сейчас компилируем и увидим значит
[01:41:18.520 --> 01:41:40.720]  давай референс local variable все так ну и запускаем что у нас так 0 1 2 2 смотрим 0 1 2 2 пока
[01:41:40.720 --> 01:41:54.720]  рассуждения наши верны 0 0 0 0 2 0 0 0 0 2 и потом все инты кроме последнего кажется мы справились
[01:41:54.720 --> 01:42:03.920]  теперь да может что-то из этого максимальное возмущение у вас вызывает какой какой-то из
[01:42:03.920 --> 01:42:23.640]  номеров а вот скорее не очень понятно почему вектор от нуля да если бы это был вектор от нуля
[01:42:23.640 --> 01:42:28.600]  тут бы все поменялось в смысле векторы тентов тут бы конечно же все поменялось ну смотри давай
[01:42:28.600 --> 01:42:37.400]  посмотрим что такое вектор булл квадратные скобочки это у нас есть construct b его назовем да
[01:42:37.400 --> 01:42:51.760]  вот есть какая-то функция b get b вот когда мы называем вектор булл от квадратных скобочков
[01:42:51.760 --> 01:43:04.360]  скобочек происходит что-то вот такое вот тут-то понятно почему это прямо rvalue вот вот это то
[01:43:04.360 --> 01:43:10.160]  есть мы создаем новый объект и возвращаем его по значению вот квадратных скобочках создается
[01:43:10.160 --> 01:43:22.880]  новый объект и возвращается значит rvalue у него 0% по правилам большого пальца 0% и навешано
[01:43:22.880 --> 01:43:30.680]  ну правила большого пальца заключается в том что декл-тайп от экспрешена навешивает на
[01:43:30.680 --> 01:43:49.640]  rvalue типа не изменяет количество персантов rvalue потому что он создает новый как ты можешь
[01:43:49.640 --> 01:44:00.080]  вернуть 1% даже не скомпилиться потому что вот это вот rvalue тоже типа можно написать что-то
[01:44:00.080 --> 01:44:10.360]  вот такое и потом return res но это очевидно плохо потому что res разрушится что еще раз
[01:44:10.360 --> 01:44:33.080]  почему два персанта потому что да вот вот здесь да нет в третьем ну хорошо смотри
[01:44:33.080 --> 01:44:38.760]  стд move от вектора это что во-первых это экспрешен значит идем в декл-тайп экспрешен
[01:44:38.760 --> 01:44:46.400]  стд move это функция функция которая вернет нам стд vector bool 1% 1% если функция возвращает
[01:44:46.400 --> 01:44:54.560]  rvalue ссылку это rvalue мы попали в декл-тайп от экспрешена получили rvalue значит
[01:44:54.560 --> 01:45:04.000]  сохранили количество персантов значит остается два персанта окей окей ладно давайте это все
[01:45:04.000 --> 01:45:09.920]  грустная часть вообще на семинар должен быть наверное не очень забудробительным сегодня
[01:45:09.920 --> 01:45:29.120]  ничем что в чем вопрос ну потому что тут скобочки тут нет скобочек то есть ну вот
[01:45:29.120 --> 01:45:38.480]  это запись эквилент на записи вот такой это была это это была хитрость чтобы вас запутать
[01:45:38.480 --> 01:45:50.160]  вот это одно и то же окей окей давайте начнем у нас не очень забудробительный семинар мы
[01:45:50.160 --> 01:46:05.200]  сегодня узнаем как как жить здорово ну почти смотрите так или я тут мне нужна твоя
[01:46:05.200 --> 01:46:16.680]  помощь сетат это отдельный пункт да 11.3 значит пункт смотрите значит аббревиатура
[01:46:16.680 --> 01:46:26.520]  си тад что такое сетат это класс template argument deduction вот что такое класс template
[01:46:26.520 --> 01:46:35.000]  argument deduction это вывод шаблонных параметров класса ура как мы жили до того как вели сетат
[01:46:35.000 --> 01:46:43.600]  да как мы создавали пары знаете ли вы как мы создавали пары стд мэйк пэр почему мы
[01:46:43.600 --> 01:46:51.440]  создавали пары с помощью стд мэйк пэр да потому что функции шаблонные типы вывести можно то
[01:46:51.440 --> 01:47:03.440]  есть могли написать представьте у нас есть какая-нибудь переменная pair int double и мы хотим
[01:47:03.440 --> 01:47:07.200]  у нас нет ее потому что у нас нет
[01:47:07.200 --> 01:47:23.280]  utility да но вообще говоря канонически пара по-моему лежит в utility да квад ну типа если мы хотим
[01:47:23.280 --> 01:47:28.400]  чему-то ее присвоить мы могли бы написать либо стд еще раз полностью повторить тип
[01:47:28.400 --> 01:47:41.120]  int double 1 2 либо мы могли сделать специальную функцию помощник
[01:47:41.120 --> 01:47:54.200]  которая бы автоматически вывела за нас что это int double вот что удобно чуть меньше текста
[01:47:54.200 --> 01:48:13.280]  что в квадратных скобочках как именно вот так ну замечательно а что это такое ну вот это типа
[01:48:13.280 --> 01:48:36.280]  что это да который почему стало понятно какие типы у него потому что компилятор их
[01:48:36.280 --> 01:48:46.280]  подставил кажется с помощью ситада про который мы говорим вот сейчас так можно сейчас так можно
[01:48:46.280 --> 01:48:52.640]  раньше был нельзя вот собственно такая же проблема была вы можете довольно много таких штук найти мы
[01:48:52.640 --> 01:48:56.880]  должны некоторых из них уже смотрели вот мы помните про итераторы говорили было тогда такое когда-то
[01:48:56.880 --> 01:49:05.360]  вот там у нас была функция стд бэк инсертер вот стд бэк инсертер на самом деле это
[01:49:05.360 --> 01:49:12.520]  функция помощник для итератора стд бэк инсерт итератор вот чтобы не писать стд бэк инсерт итератор
[01:49:12.520 --> 01:49:22.920]  от полное название типа мы делали стд бэк инсертер от конч стд вектор там ну смысле не стд вектор
[01:49:22.920 --> 01:49:29.320]  а мы у нас был вектор мы передавали туда в этот вектор да и вот компилятор сам понимал что
[01:49:29.320 --> 01:49:38.360]  вызываем стд бэк инсертер от вектора и так далее вот окей собственно говоря давайте поговорим про
[01:49:38.360 --> 01:49:45.400]  ситад теперь с помощью некоторого механизма компилятор может догадываться как это делать на
[01:49:45.400 --> 01:49:52.960]  самом деле механизм этот несколько отличается от того как выводится шаблонные параметры у
[01:49:52.960 --> 01:50:06.520]  функций делается примерно следующим образом у вас для каждого конструктора который есть у типа
[01:50:06.520 --> 01:50:15.080]  создается такая воображаемая функция помощник то есть если у вас есть какой-нибудь тип да
[01:50:15.080 --> 01:50:30.320]  темплейтный и скажем у нас хранится кандидата есть там конструктор от
[01:50:30.320 --> 01:50:46.280]  вот так замечательно что происходит значит у нас сгенерируется такая вот тут на самом деле
[01:50:46.280 --> 01:50:50.120]  тексты по переференции очень смешной читать потому что гигантские предложения в которых написано
[01:50:50.120 --> 01:50:56.040]  для воображаемого типа генерируется гипотетическая функция для которой потом запускается какие-то
[01:50:56.040 --> 01:51:13.120]  процессы вот значит генерируется гипотетическая функция значит кое-нибудь с от value вот собственно
[01:51:13.120 --> 01:51:22.800]  говоря давайте назовем ее make s вот как мы бы и написали которая возвращает там значит она
[01:51:22.800 --> 01:51:40.640]  с от т шаблонная и возвращает она нам с от t вот value ну только форварер с аргументом
[01:51:40.640 --> 01:51:49.120]  нормально вот как бы это суть происходящего сложится там и длинные текты из описания начинаются
[01:51:49.120 --> 01:51:54.520]  из-за того что компилятор для вас сейчас генерирует много конструкторов за вас для
[01:51:54.520 --> 01:51:59.480]  этих конструкторов которые генерирует он тоже генерирует вот такие вот типа вспомогательные
[01:51:59.480 --> 01:52:10.440]  функции вот соответственно сейчас мы можем написать с с от 1 вот теперь можем там вывести
[01:52:10.440 --> 01:52:23.720]  тип us это будет s от int вот какие есть ограничения самое важное ограничение которое будет портить
[01:52:23.720 --> 01:52:45.120]  нам жизнь это значит что нельзя написать вот так вот кто мне скажет что я тут не так
[01:52:45.120 --> 01:52:57.520]  сделал ну я не указал темплэйтный размер то есть я могу либо указать вот так ну только 4d вот
[01:52:57.520 --> 01:53:09.320]  вот так и указать могу я могу указать вот так вот так могу он догадается что 4 да вы должны
[01:53:09.320 --> 01:53:17.640]  либо указать все шаблонные параметры явно либо не указать никаких вот сетат применяется
[01:53:17.640 --> 01:53:29.040]  только конструкциям в которых вы ноль параметров указали явно вот что еще ну понятно что шаблонные
[01:53:29.040 --> 01:53:37.800]  типы должны быть выводимы я не могу написать вот так ну компилятор не догадается он не может
[01:53:37.800 --> 01:53:46.360]  понять что это такое вот он даже вот так вот не поймет что это такое вот
[01:53:46.360 --> 01:54:01.680]  ну давай с круглых
[01:54:01.680 --> 01:54:21.120]  да есть можем ну короче фигурные скобочки ну ладно наверное короче можем фигурные скобочки
[01:54:21.120 --> 01:54:27.740]  на самом деле умеет вызывать конструктор и круглый умеет вызывать конструктор фигурным потом
[01:54:27.740 --> 01:54:32.900]  добавили больше возможностей с тем что они могут вызывать там агрегатную цилизацию все остальное
[01:54:32.900 --> 01:54:37.940]  но фигурный фигурный теперь тоже умеет в агрегатную цилизацию на самом деле то есть типа если
[01:54:37.940 --> 01:54:50.180]  напишу не знаю вот это кажется тоже сработает нет нет окей это не сработает ну тут только так и
[01:54:50.180 --> 01:54:58.980]  так нельзя но viable конструктор дедакшн гайд вот он вывести не смог кстати что интересно а вот
[01:54:58.980 --> 01:55:06.140]  подождите кстати может и смог вот здесь есть одна интересная деталь давайте какой файл кто-то
[01:55:06.140 --> 01:55:15.020]  помнит смок сам делится нормально почему же на меня тогда ругается подсветка синтаксиса потому
[01:55:15.020 --> 01:55:21.860]  что значит забавный момент в двадцатой версии стандарта добавили больше вариации больше
[01:55:21.860 --> 01:55:27.820]  различных правил по которым генерируются эти вспомогательные функции и в двадцатом стандарте
[01:55:27.820 --> 01:55:37.460]  вот так делать можно я почти уверен что его так можно делать давайте проверим да а 17 еще нет и
[01:55:37.460 --> 01:55:45.620]  вот нет два компилятора и гц ц он это уже поддерживает а мой кланк не поддерживает
[01:55:45.620 --> 01:55:52.260]  потому что не довольно новые оба на кланк 15 сколько-то
[01:55:52.260 --> 01:56:07.020]  а гц ц тоже довольно новые вот соответственно почему это некоторая проблема потому что если
[01:56:07.020 --> 01:56:19.260]  мы захотим написать свою пару вот пара простейшая пишется вот так да
[01:56:19.260 --> 01:56:44.060]  то есть вот на самом деле эта пара в двадцатом стандарте делает очень многое и она как-то в
[01:56:44.060 --> 01:56:50.420]  целом очень почти во всех случаях заменит вам стандартную пару можно спросить о каждой
[01:56:50.420 --> 01:57:04.900]  зоне стандартная пара а там 900 строк кода по разным причинам в паре да ну больше вот у нас 5
[01:57:04.900 --> 01:57:15.020]  так что не все не все так просто зачем а вот выясним зачем ну вот смысл в том что если мы
[01:57:15.020 --> 01:57:29.380]  взяли свою пару то мы не можем делать вот так да а хотелось бы ну знакомый компилятор не
[01:57:29.980 --> 01:57:38.060]  но до двадцатых не могли вот на самом деле есть способ как бы указать компилятору вот эту
[01:57:38.060 --> 01:57:45.220]  вспомогательную функцию руками греть вот ты не сгенерировал эти покажу как вести тип вот у этого
[01:57:45.220 --> 01:57:52.420]  есть особенный синтаксис который имеет именно такой смысл и никого другого смысла не имеет
[01:57:52.420 --> 01:57:58.620]  значит смотрите вы пишем ну в нашем случае шаблон потому что наша функция должна быть
[01:57:58.620 --> 01:58:02.500]  шаблонной мы передаем два аргумента и по этим двум аргументам мы хотим понять какого типа пара
[01:58:02.500 --> 01:58:23.420]  да затем мы пишем название класса мы пишем название класса пишем стрелочку и после этого
[01:58:23.420 --> 01:58:29.500]  пишем вот если мне дали такую функцию то какой тип у меня должен получиться тип у меня должен
[01:58:29.500 --> 01:58:45.940]  получиться пара от т у и хобана наш пара компилируется вот формально что происходит вот компилятор
[01:58:45.940 --> 01:58:52.340]  генерирует как бы незримых вот таких штук кучу смотрит на штуку для которой нужно применить
[01:58:52.700 --> 01:58:59.340]  он выбирает между всех это называется дедакшн гайд типа гайды к тому как выводит типы смотрит
[01:58:59.340 --> 01:59:08.620]  на все эти дедакшн гайд выбирает максимально полезный подходящий смысл и
[01:59:08.620 --> 01:59:33.700]  ну в смысле ну да на самом деле это не функции ты не можешь это вызвать это именно гайды эти
[01:59:33.700 --> 01:59:48.900]  гайды генерируется где а кажется можно не указывать я просто по привычке указал то есть
[01:59:48.900 --> 01:59:56.300]  это выглядит как объявление функции но это не объявление функции вот я просто по привычке написал
[01:59:56.300 --> 02:00:04.300]  да действительно можно сделать так ну в смысле вот в таком случае сам но мы все еще
[02:00:04.300 --> 02:00:14.460]  можем добавлять свои мы например можем сказать что потому что комплину типа кланки еще не
[02:00:14.460 --> 02:00:19.860]  поддерживает дополнительные но смотри у нас есть дедакшн гайды которые автоматически
[02:00:19.860 --> 02:00:26.220]  генерирует компилятор 20 плюсов и генерируется больше чем 17 их 20 их хватает чтобы просто
[02:00:26.220 --> 02:00:32.700]  для вот такой конструкции сразу же понять вот в таком выражении какой должен получиться тип
[02:00:32.700 --> 02:00:50.300]  как будто да поэтому в 20 плюсах и добавили чтобы такой простой случай работал вот вот я пытался
[02:00:50.300 --> 02:00:58.300]  это объяснить ну в общем случае в смысле в общих чертах первая смотрит все дедакшн гайды какие
[02:00:58.300 --> 02:01:03.380]  есть сгенерированный и пользовательские у пользовательских при равенстве приоритет
[02:01:03.380 --> 02:01:11.140]  мы выбираем на более подходящий дедакшн гайд после этого мы его используем только для того
[02:01:11.140 --> 02:01:17.140]  чтобы понять а какой тип у нас получится и затем мы пытаемся представить что вот здесь было
[02:01:17.140 --> 02:01:27.300]  написано что здесь вот этот тип то есть в нашем случае здесь как бы вот так да и потом уже
[02:01:27.300 --> 02:01:33.820]  для этого типа происходит выбор самого подходящего конструктора то какой конструктор выберется уже
[02:01:33.820 --> 02:01:45.260]  не зависит от дедакшн гайда вот такая небольшая тонкость с мыслью как-то о ты имеешь
[02:01:45.260 --> 02:02:00.940]  ну смысл хорошо смотри у нас есть название типа он видит 100 тип это на самом деле шаблон вот
[02:02:00.940 --> 02:02:09.700]  это шаблон после шаблона идет видимо токен как-то название identifier и потом фигурные скобочки
[02:02:09.700 --> 02:02:19.100]  это какая-то инициализация окей у меня есть шаблон у шаблона нет никаких параметров ну давай
[02:02:19.100 --> 02:02:24.860]  попробуем подидюсить потом происходит то что я писал если получилось замечательно если не
[02:02:24.860 --> 02:02:37.180]  получилось ц.е. так понятно какой-то какой
[02:02:37.180 --> 02:02:59.420]  ему неважно именно для дедакшн гайда нет ему хватило ну в смысле понятно что ну видимо
[02:02:59.420 --> 02:03:07.540]  смысл он сам генерил но я тебе говорю у тебя есть как он же его не генерирует прям плюсовым
[02:03:07.540 --> 02:03:13.020]  кодом поэтому до компилятора это куча разных ифов типа а если тип подходит для того чтобы
[02:03:13.020 --> 02:03:17.180]  для него нужно сгенерировать конструктор тогда нужно мне загенерирует дедакшн гайд даже если
[02:03:17.180 --> 02:03:34.180]  конструкта нет и вот больше этих ифов добавили в двадцатых плюсах как раз типа того вот да
[02:03:48.180 --> 02:03:52.620]  сейчас у нас есть конструктор который мы объявили для него сгенерировался дедакшн гайд у нас
[02:03:52.620 --> 02:03:58.660]  все вывелось если мы берем конструктор у нас как бы есть этот конструктор если мы укажем явно
[02:03:58.660 --> 02:04:08.500]  тип int double у нас сконструируется но дедакшн гайд не сгенерировался для такого случая вот
[02:04:08.500 --> 02:04:36.980]  окей давайте покажу еще один случай когда дедакшн дедакшн гайды да да да да да да
[02:04:38.500 --> 02:04:46.260]  да для записи замечание было в том что ну формально это не конструктор это типа
[02:04:46.260 --> 02:04:49.940]  возможность агрегатно инициализировать поэтому для конструктора которого нет
[02:04:49.940 --> 02:04:55.500]  не сгенерировался дедакшн гайд вот от 20 плюсов добавили вот этот дополнительный
[02:04:55.500 --> 02:05:11.740]  if что если есть агрегатное то попробуем сгенерировать еще раз это типа функция
[02:05:11.740 --> 02:05:19.540]  вообще у которой название равно названию класса но это дельный синтез такой вот вот такой
[02:05:19.540 --> 02:05:31.940]  фигурных тут нельзя я уверен на 99 процентов ну нельзя но я сказал сразу же это вот такой
[02:05:31.940 --> 02:05:37.460]  специальный синтез он означает то что означает вот если что в стандартной пары собственно
[02:05:37.460 --> 02:05:46.740]  говоря я могу показать там действительно 900 строк кода во первых а вторых есть дедакшн гайд
[02:05:46.740 --> 02:05:54.500]  вот специально если у нас поддерживаются дедакшн гайды мы делаем вот ровно то что
[02:05:54.500 --> 02:06:09.300]  я написал вот поэтому пара стандартная сработала вот для всех конструкторов он
[02:06:09.300 --> 02:06:15.380]  генерируется например для конструктора копирования тоже будет дедакшн гайд для
[02:06:15.380 --> 02:06:30.900]  каждого конструктора который есть у класса сейчас он считает так мне нужно понять какой
[02:06:30.900 --> 02:06:35.260]  у меня получится слева тип ага у меня есть подсказка от пользователя подходит ли она под
[02:06:35.260 --> 02:06:40.300]  мой случай подходит пользователь говорит что получится если бы вот это была функция у нее бы
[02:06:40.300 --> 02:06:46.020]  вы ага подсказка от пользователя если бы это была функция я бы у нее вывел типы int и double
[02:06:46.020 --> 02:06:52.500]  значит получилось бы пара int double эта подсказка подошла считая что у меня выявился тип int double
[02:06:52.500 --> 02:07:01.140]  ok пара от int double пытаюсь ее инцелизировать от единицей и двойки я могу могу инцелизирую вот
[02:07:01.140 --> 02:07:18.060]  но давайте все-таки ну мне кажется я одно и то же по кругу говорю да можем мы можем да дедакшн
[02:07:18.060 --> 02:07:22.620]  гайды мы можем делать разные собственно давайте посмотрим типа самый классический пример который
[02:07:22.620 --> 02:07:30.580]  есть это вот у нас есть вектор какой нибудь вот и мы хотим чтобы у нас был значит конструктор
[02:07:30.580 --> 02:07:40.300]  шаблонный конструктор вообще да ну раньше это делалось вот так
[02:07:40.300 --> 02:07:49.900]  там
[02:07:49.900 --> 02:08:07.460]  вот да и наш класс тоже шаблонный вот собственно говоря если у нас есть вектор и мы этот вектор
[02:08:07.460 --> 02:08:12.140]  хотим сконструировать скажем от двух итераторов листа чтобы там у нас ну у нас вектор просто
[02:08:12.140 --> 02:08:18.620]  скопировался или от двух итераторов другого вектора вот ну логичная кода другого контейнера
[02:08:18.620 --> 02:08:23.860]  потому что почему это нужно потому что контейнеров может быть сколько угодно итераторы у всех
[02:08:23.860 --> 02:08:28.820]  одинаковые а типа у всех разные в смысле итераторы ведут себя одинаково поэтому я могу захотеть
[02:08:28.820 --> 02:08:34.860]  создать вектор от листа или от дека или от мапа чего угодно как мне понять а какого типа будет
[02:08:34.860 --> 02:08:40.060]  этот вектор а вот дедакшн гайд нам поможет без дедакшн гайда вообще непонятно вот компилятор
[02:08:40.060 --> 02:08:44.420]  здесь нужно взять какую-то обратную функцию на типах вот он этого не делает вот он этого не
[02:08:44.420 --> 02:08:49.380]  делает даже у вас на лекции был пример с этим с ремуф референсом он там же сдается а тут ему
[02:08:49.380 --> 02:08:56.700]  нужно что по-хорошему сделать взять итератор trades value type потому что этот итератор там может
[02:08:56.700 --> 02:09:05.500]  быть например указатель да и вот мы в таком случае пишем что мы пишем вектор от итер итер
[02:09:05.500 --> 02:09:32.340]  нам выдаст стд итератор trades either value type это все вектор и это все type name вот при этом значит
[02:09:32.340 --> 02:09:46.780]  вот мы так можем указать что если нам дали два итератора то есть два чего-то что похоже на
[02:09:46.780 --> 02:09:52.780]  итератор вот вот это вот тоже чтобы сработало том если мы можем взять value type то давайте считать
[02:09:52.780 --> 02:10:10.180]  что вектор от value type и мы попадем на нужный конструктор класс ну вот я показываю ну потом
[02:10:10.180 --> 02:10:17.780]  я смогу сказать вот у меня есть какой-нибудь стд там не знаю лист интов лист и я смогу написать
[02:10:17.780 --> 02:10:30.300]  вектор век от лист точка begin лист точка end мне не нужно указывать типы он по итератору понял
[02:10:30.300 --> 02:10:44.660]  какой тип будет у вектора а как ну то есть смотри для него вот вот смотри вот у нас есть такой
[02:10:44.660 --> 02:10:49.460]  конструктор который принимает какой-то произвольный тип и мы не указываем даже
[02:10:49.460 --> 02:10:57.980]  какого типа вектор откуда ему знать а да важное замечание дедакшн гайды
[02:10:57.980 --> 02:11:05.300]  генерируется для конструкторов в основном шаблоне типа если я потом напишу где-то что а вот между
[02:11:05.300 --> 02:11:21.700]  прочим у не знаю там и пары от стд стринг и стд вектор стд стринг какой-нибудь особенный
[02:11:21.700 --> 02:11:30.220]  конструктор для него ничего не сгенируется вот все вот такое замечание то есть можно сказать
[02:11:30.220 --> 02:11:37.620]  так чтобы ничего не генерируется нет да
[02:12:01.220 --> 02:12:09.020]  не произойдет ли проблемы с тем что он дедакшн гайде попытается взять
[02:12:09.020 --> 02:12:19.340]  нет не думаю не произойдет
[02:12:19.340 --> 02:12:41.100]  сейчас еще раз смысле почему ну то есть ну смотри ну хорошо у меня есть
[02:12:41.100 --> 02:12:49.020]  так
[02:12:49.020 --> 02:12:55.140]  окей хорошо
[02:12:55.140 --> 02:13:10.220]  ну нет он просто говорит что он не понимает по задзет он не может вывести
[02:13:10.220 --> 02:13:20.060]  ну давай попробуем скомпилировать ну да но этот поэтому конструктор не можно понять какой тип
[02:13:20.060 --> 02:13:45.100]  вот кластин плейт аргумент дедакшн фейлт говорит значит кандидат со ст ст ну не могу понять
[02:13:45.100 --> 02:14:12.020]  что такое ты а шапка линковших он скомпилировался ну смотри тут скорее всего произошло вот что он не
[02:14:12.020 --> 02:14:22.260]  смог вот эту часть сделать и отбросил эту функцию он попытался заменить шаблонный параметр сказал
[02:14:22.260 --> 02:14:32.420]  что раз замена не удалась это не ошибка вот это очень полезное правило которое пригодится нам
[02:14:33.020 --> 02:14:59.980]  окей так давайте быстро глянем так что еще раз потом пока не важно
[02:14:59.980 --> 02:15:11.900]  окей так что посмотреть так ладно нормально давайте поговорим немножко внезапно сменим
[02:15:11.900 --> 02:15:20.180]  тему казалось бы ну на самом деле не сильно вот мы тут немножко поговорили про пары значит поговорим
[02:15:20.180 --> 02:15:30.580]  про такой очень полезный класс в стандартной библиотеке как тупл вот у него есть свой
[02:15:30.580 --> 02:15:40.420]  хедер отдельный кто-то знает здесь что такое тупл кортеж да то есть что это такое у нас есть
[02:15:40.420 --> 02:15:49.360]  класс куда можем складывать различные типы а причем
[02:15:55.660 --> 02:16:00.780]  идейно что это такое вот у нас как бы есть структура мы передаем какие-то шаблонные параметры
[02:16:00.780 --> 02:16:11.420]  вот и она сделает следующее она говорит но вот первый мы шаблонный параметр там
[02:16:11.420 --> 02:16:17.980]  т1 вот будет тут когда-нибудь дата 1 потом т2 будет дата 2 и так сколько указали параметры
[02:16:17.980 --> 02:16:25.900]  столько и получится у нее полей вот как она это делает мы наверное уже не успеем сегодня
[02:16:25.900 --> 02:16:32.300]  посмотреть ну может быть в другой раз но это можно написать самому на самом деле вот то есть
[02:16:32.300 --> 02:16:38.620]  мы напишем int int int это как бы структура из трех интов если напишем in double структура из
[02:16:38.620 --> 02:16:49.860]  трех доблов вот из нтн табла заговорился вот зачем-то может быть полезно ну например если
[02:16:49.860 --> 02:16:55.220]  у вас есть какая-то функция не знаю вы работаете с экраном и вам нужно вернуть там точку на
[02:16:55.220 --> 02:17:01.260]  экране вы не хотите заводить отдельную структуру специально для этой функции там точка структура
[02:17:01.260 --> 02:17:07.780]  поинт в отдельном на им спейсе у которой там int x int y и возвращаете структуру только из
[02:17:07.780 --> 02:17:19.580]  этой функции можете структуру просто вернуть стд тюпл иинт инт ну или пару то есть там
[02:17:19.580 --> 02:17:32.660]  гет кордс чего-то вот вот можно так сделать ну или там давайте до дабы иинт инт и какой-нибудь
[02:17:32.660 --> 02:17:40.060]  уинт 32 т значит обычно этот свет вот допустим нам какая-то точка возвращается не знаю точка на
[02:17:40.060 --> 02:17:59.300]  которую показывает мышка ее цвет вот такие о вот вот так классно соответственно я считаю
[02:17:59.300 --> 02:18:04.420]  справедливые вопросы должны быть как что-то прочитать из тупла вот я сказал что мы как будто
[02:18:04.420 --> 02:18:12.020]  бы дата 1 но понятно что на самом деле там не так так как у нас может быть неопределенное
[02:18:12.020 --> 02:18:20.860]  количество аргументов тупле вообще не очень понятно как они называются называются вот ну
[02:18:20.860 --> 02:18:26.420]  и у нас нет к ним прямого доступа не можем сказать точка даты или точка дата 1 вот у нас есть
[02:18:26.420 --> 02:18:36.500]  свободная функция стд гет вот у нее есть шаблонный не типовой параметр вот может передать туда
[02:18:36.500 --> 02:18:48.820]  сост 0 там гет от тупла вот это типа получить первый элемент получить второй элемент что
[02:18:48.820 --> 02:18:55.660]  еще можно значит у гета есть ну да соответственно можно изменять там вот здесь я могу написать там
[02:18:55.660 --> 02:19:08.300]  равно 0 x там 0 0 ff 0 0 ff что-нибудь такое какой-то цвет задать например что еще можно делать значит
[02:19:08.300 --> 02:19:15.140]  есть удобная у гета функции функциональность что по туплу и гету можно значит указать тип и
[02:19:15.980 --> 02:19:25.180]  и в том случае если этот тип один в тупле нам на этапе компиляции там найдется некоторой
[02:19:25.180 --> 02:19:31.620]  шаблонной магии типа где он именно лежит и вернуть ссылку на него вот собственно возвращает нам
[02:19:31.620 --> 02:19:42.380]  ссылку вот это туплы соответственно ступлами была та же проблема что и с парами раньше
[02:19:42.380 --> 02:19:55.500]  представим что вам нужен тупл из даже не так представим что у вас есть структура
[02:19:55.500 --> 02:20:19.260]  у которой есть тупл внутри ну тупл конечно же ссылки на инт и на стд стринг вот это тоже
[02:20:19.260 --> 02:20:26.220]  легально в тупле можно хранить ссылки как и в структуре почему нет вот и мы хотим написать
[02:20:26.220 --> 02:20:39.180]  значит как-то конструктор для этой структуры вот нам сбрело в голову как вы считаете как как
[02:20:39.180 --> 02:20:44.660]  как это можно было бы сделать ну представим что нам дают тупл даже нет нам дают собственно
[02:20:44.660 --> 02:20:58.020]  говоря и и стд стринг амперсант с вот как бы мы могли инцидировать дату по вашему
[02:20:58.020 --> 02:21:02.780]  но есть функция мэйк тупл как и мэйк пэр
[02:21:02.780 --> 02:21:22.820]  так что у нас там но мачинг констракшн не работает почему-то казалось бы а я не писал стд
[02:21:22.820 --> 02:21:32.500]  да все равно не работает почему же
[02:21:32.500 --> 02:21:43.380]  блин я почему-то думал что на этапе компиляции не поймает
[02:21:43.380 --> 02:21:53.460]  ну давайте вот так
[02:21:53.460 --> 02:22:02.660]  понятно да
[02:22:02.660 --> 02:22:21.220]  так как бы показать эту хитрость ладно давайте прямо скажу значит на самом деле мэйк тупл чуть
[02:22:21.220 --> 02:22:30.300]  более хитрая функция чем кажется она в отличие от мэйк пэр не просто берет и создает тупл вот
[02:22:30.300 --> 02:22:37.980]  она делает кое-что более хитрое что же она делает она например убирает ссылки у типов
[02:22:37.980 --> 02:22:47.140]  то есть даже я знаю почему не работала потому что она и так убрала ссылки у типов
[02:22:47.140 --> 02:23:04.700]  и так тоже не сработает нет обещально
[02:23:04.700 --> 02:23:11.140]  ладно вот
[02:23:11.140 --> 02:23:18.700]  давайте посмотрим другим способом
[02:23:18.700 --> 02:23:27.980]  такой
[02:23:27.980 --> 02:23:42.900]  так ну так нельзя
[02:23:42.900 --> 02:23:59.780]  вообще отказывается работать таким
[02:23:59.780 --> 02:24:24.020]  образом, ну и хорошо, я немножко запутался, ну мы распутаемся. Окей, ну простой
[02:24:24.020 --> 02:24:32.700]  способ понятно работает, у нас получится тупло от двух интов. Вот, и у тупла есть
[02:24:32.700 --> 02:24:38.420]  один if, так сказать, захардкоженный на типе стандартной библиотеки, если вы
[02:24:38.420 --> 02:24:56.140]  передайте ему std-reference-wrapper, вот, то он сделает кое-что хитрое.
[02:25:08.420 --> 02:25:32.540]  Сейчас вам покажу, что. А мне казалось, вы его обсуждали уже в чате, нет? Так, вектор,
[02:25:32.540 --> 02:25:43.940]  уберем вектор. Ага, std-reference-wrapper, окей. Смотрите, он вывел int&percent, хотя это
[02:25:43.940 --> 02:25:48.180]  был std-reference-wrapper. std-reference-wrapper это просто структура, которая хранит
[02:25:48.180 --> 02:25:59.940]  указательно какой-то объект и притворяется, что это референс. Да, но она нужна для
[02:25:59.940 --> 02:26:05.340]  некоторых h-кейсов, где референс нельзя принять, но хочется передать. Вот, ну вот
[02:26:05.340 --> 02:26:14.860]  такая особенность, что если вы передадите в make-tuple-reference-wrapper, он
[02:26:14.860 --> 02:26:22.660]  превратится в ampersand. Интересная особенность. Да, и что еще make-tuple на
[02:26:22.660 --> 02:26:31.780]  самом деле убирает у типов все референсы, также превращает, ну, array в
[02:26:31.780 --> 02:26:36.460]  поинтеры, вот, функции-выказатель на функции.
[02:26:42.460 --> 02:26:48.460]  Ну, что-то вроде. Но на самом деле чуть больше она делает.
[02:27:02.460 --> 02:27:13.340]  Нет, вот это явно сделано специально, то есть, видишь, то есть, у нас есть
[02:27:13.340 --> 02:27:19.180]  template, мы получаем какие-то произвольные элементы, мы на эти элементы к ним
[02:27:19.180 --> 02:27:25.740]  применяем функцию на типах, которая, собственно, делает все, что я описал, вот,
[02:27:25.740 --> 02:27:32.660]  и возвращаем tuple из вот этих элементов, где decay-strip там, оно же не
[02:27:32.660 --> 02:27:41.860]  находит просто так. Ну, да, он не здесь где-то, ну, не суть.
[02:27:41.860 --> 02:28:04.140]  Я не уверен. Я не уверен. Вот, что есть еще интересного. Есть, на самом деле,
[02:28:04.140 --> 02:28:09.340]  функция helper, чтобы специально работать с референсами, значит, функция, которая, на
[02:28:09.340 --> 02:28:12.980] оборот, навешивает референсы на ваши аргументы, которые вы дадите, и создает tuple
[02:28:12.980 --> 02:28:23.660]  референсов на то, что вы передали. Значит, std tie, ic, а я тут char хотел
[02:28:23.660 --> 02:28:34.100]  сделать, чтобы было поинтереснее. Вот, значит, std tie нам вернет tuple из
[02:28:34.100 --> 02:28:38.660]  референсов на эти переменные. Вот, зачем это может быть нужно? Ну, раньше это
[02:28:38.660 --> 02:28:46.780]  могло быть нужно, например, чтобы просто делать оператор сравнения. Что можно было
[02:28:46.780 --> 02:28:56.420]  сделать? Так как у tuple есть сравнение, можно было написать какой-нибудь bool less, там other,
[02:28:56.420 --> 02:29:20.860]  pair other, и написать std tie first, second, меньше tie other.first, other.second. Вот. Это такой был
[02:29:20.860 --> 02:29:25.620]  простой способ написать сравнение у, например, простых типов. Сейчас это не особо применяется,
[02:29:25.620 --> 02:29:34.820]  потому что сравнение само работает. Вот. Но есть некоторое другое применение. Ну,
[02:29:34.820 --> 02:29:41.180]  я, чтобы не писать оператор меньше, я написал less. Вот. Есть другое применение. Вот, например,
[02:29:41.180 --> 02:29:49.940]  есть функция, которая возвращает, значит, две штуки и цвет. Две каринеты и цвет. Вот у нас уже
[02:29:49.940 --> 02:30:04.900]  есть где-то определенные и переменные под это. То есть, что бы мы могли сделать? Мы могли получить
[02:30:04.900 --> 02:30:13.380]  сначала от этой функции этот tuple tuple и потом приравнять. Вот. А что бы мы могли еще сделать?
[02:30:13.380 --> 02:30:19.740]  Мы могли сделать лучше. Мы могли написать std tie, типа свяжи мне, пожалуйста, x, y и color,
[02:30:19.740 --> 02:30:36.220]  и сделай get cohorts. И он бы сразу записал эти три переменные. Довольно удобно. Вот. То есть,
[02:30:36.220 --> 02:30:47.820]  еще раз напомню, он просто навешивает 1% на все. Тут никаких особо... Навешивает 1% и создает tuple
[02:30:47.820 --> 02:31:15.660]  ссылок на то, что ему передали. Вот. Вот. Временный объект в смысле... Да, сюда ты единицу передать
[02:31:15.660 --> 02:31:22.060]  не можешь. Ну, потому что, собственно говоря, вот там было видно в реализации, что он просто там
[02:31:22.060 --> 02:31:26.340]  без всяких каких-то хитростей, с универсальными ссылками или еще чем-то он просто принимает
[02:31:26.340 --> 02:31:44.980]  lvl ссылку и все. Вот. Окей. Что еще нужно сказать про tuple? Есть третий способ создавать tuple. И вот
[02:31:44.980 --> 02:31:58.140]  он уже чуть более хитрый. Значит, называется std forward s tuple. Вот. Как вы думаете, что он делает?
[02:31:58.140 --> 02:32:16.900]  Интересное предположение. Напоминает ли вам это что-то?
[02:32:16.900 --> 02:32:39.140]  Ну, смотрите, он принимает универсальную ссылку. Std tuple явно указанного вот такого типа. Что это
[02:32:39.140 --> 02:32:52.060]  значит? Давайте подумаем. Еще раз вспомним. Если мы приняли rvalue, то elements это что?
[02:32:52.060 --> 02:33:13.420]  Нет, elements это 0 амперсантов. Если rvalue. Если rvalue, то либо 2, либо 0. Да, либо 2, либо 0. И вот эта штука в сумме дает 2.
[02:33:13.420 --> 02:33:28.260]  Здесь у нас будет 2 амперсанта. Ну, вот у вот этого типа в сумме 2 всегда, да. Но вот этого типа может быть не 2.
[02:33:28.260 --> 02:33:42.220]  У вот этого большого 2, да. Да, да, да. В сумме получится 2 всегда. Если rvalue, если lvalue,
[02:33:43.060 --> 02:33:47.620]  то вот у этого суммарного типа получится 1 амперсант, да.
[02:33:47.620 --> 02:34:10.420]  Ну, давай посмотрим. Вот, собственно говоря, если мы сейчас изменим x, то изменится и в тепле x.
[02:34:10.420 --> 02:34:14.140]  Если мы изменим в тепле, то изменится и в настоящих x. Забавно.
[02:34:14.140 --> 02:34:36.300]  То есть, понимаешь, он каждый тип отдельно forwarded.
[02:34:36.300 --> 02:34:48.460]  Типа, если у нас было 3 первых аргумента, это lvalue, они стали lvalue ссылками. Последний аргумент был rvalue. Он его сохранил как rvalue ссылку.
[02:34:48.460 --> 02:34:55.180]  Можно вернуться к какой-то функции? К стандартной функции.
[02:34:55.180 --> 02:35:05.020]  В строке с ветерным 2 амперсанта, если сам elements уже... Ну, это по сути мы же elements и навешиваем 2 амперсанта, да?
[02:35:05.020 --> 02:35:11.020]  Да. А сам elements уже будет либо амперсант, либо 2 амперсанта, в зависимости от того, что мы передали rvalue.
[02:35:11.020 --> 02:35:23.660]  Ну, это 0 амперсантов. В сумме так работает.
[02:35:23.660 --> 02:35:37.420]  Но, еще раз, у тебя универсальная ссылка выведет 0 амперсантов, если туда единицу передашь. Потом ты навесишь 2 амперсанта и получится int 2 амперсанта.
[02:35:38.380 --> 02:35:43.500]  А если ты не навешишь вот здесь 2 амперсанта, то ты передашь просто elements, то есть просто int.
[02:35:43.500 --> 02:35:55.500]  И он сохранит вот тот int, который я передал, не rvalue ссылку, а просто int. И это два разных поведения принципиально.
[02:35:56.140 --> 02:36:03.100]  Ну, если forward принят elements 2 амперсанта, так что... Нет? Да.
[02:36:03.100 --> 02:36:05.100]  Я представлю, да.
[02:36:10.060 --> 02:36:22.060]  Я, видимо, не понимаю, что происходит. Ну, как... В общем, какой тип будет у elements, когда мы универсальную ссылку поставляем, и что происходит?
[02:36:22.140 --> 02:36:27.660]  Какой тип будет у elements? Ну, смотри. Ну, хорошо, давай.
[02:36:36.620 --> 02:36:39.660]  Еще раз. Вот у нас есть универсальная ссылка.
[02:36:43.660 --> 02:36:45.660]  Давайте разберем.
[02:36:52.060 --> 02:36:56.060]  Окей. Вот. Давайте еще раз вот это вот все закомментим.
[02:37:04.060 --> 02:37:12.060]  От чего повызывать вы хотите? Вот от единицы могу. Могу так сделать, потом q от i.
[02:37:12.060 --> 02:37:22.060]  Могу еще q от std move от i. Можно так не делать, пожалуйста. Вот.
[02:37:22.060 --> 02:37:24.060]  Но давайте подумаем, что у нас получится?
[02:37:30.060 --> 02:37:32.060]  Вот. Я утверждаю, что от единицы...
[02:37:32.060 --> 02:37:34.060]  У нас будет 0 амперсантов и 2 амперсантов.
[02:37:40.060 --> 02:37:42.060]  0,2, 1,2, 1,2.
[02:37:48.060 --> 02:37:50.060]  Ну, и давайте подумаем, что у нас получится?
[02:37:54.060 --> 02:37:56.060]  Ну, я утверждаю, что от единицы...
[02:37:56.060 --> 02:37:58.060]  1,2.
[02:38:04.060 --> 02:38:06.060]  Потому что такие правила для универсальной ссылки.
[02:38:26.060 --> 02:38:30.060]  Окей. Кого-то еще есть вопросы по этой части?
[02:38:30.060 --> 02:38:32.060]  Так.
[02:38:52.060 --> 02:38:54.060]  Ну, потому что такие правила работы универсальной ссылки.
[02:38:54.060 --> 02:38:56.060]  Ну, я не знаю, что сейчас...
[02:38:56.060 --> 02:38:58.060]  Ну, смотри. Хорошо. Почему так?
[02:38:58.060 --> 02:39:06.060]  Когда forward передаем, да, что-то, мы потом обычно forward передаем t, да?
[02:39:06.060 --> 02:39:16.060]  И вот t для forward это будет символ. Если у него нет ссылок, значит rvalue было.
[02:39:16.060 --> 02:39:20.060]  Значит, если у него 1 амперсант, значит это было lvalue.
[02:39:29.060 --> 02:39:31.060]  Да. Нет.
[02:39:34.060 --> 02:39:38.060]  Я не знаю. Ну, вот давайте. Ну, не будет. Как?
[02:39:46.060 --> 02:39:52.060]  Ну, это универсальная ссылка. У нее особые правила вывода типов.
[02:39:52.060 --> 02:39:58.060]  Если она получает rvalue, значит тип без амперсанды, на который навешивается 2 амперсанды.
[02:40:09.060 --> 02:40:14.060]  Окей. В таком случае, если мы поняли, как работает вот эта штука,
[02:40:15.060 --> 02:40:25.060]  то forward as tuple, он вот для каждого элемента tuple эту операцию производит просто forward.
[02:40:29.060 --> 02:40:32.060]  Окей. Так, сколько у нас времени?
[02:40:32.060 --> 02:40:34.060]  Минус 18 минут.
[02:40:34.060 --> 02:40:36.060]  Минус 18 минут.
[02:40:36.060 --> 02:40:38.060]  Минус 8 минут.
[02:40:44.060 --> 02:40:52.060]  Окей. Что tuple быстро?
[02:41:00.060 --> 02:41:02.060]  Нет, это быстро мы не сделаем.
[02:41:04.060 --> 02:41:09.060]  Давайте быстро без edge-case посмотрим на такую вещь, как structured-binding.
[02:41:10.060 --> 02:41:12.060]  Значит, смотрите.
[02:41:15.060 --> 02:41:19.060]  Мы можем делать следующую вещь. Вот видите, что делал std-tie?
[02:41:22.060 --> 02:41:29.060]  Оно брало существующие переменные и собирало их в tuple.
[02:41:30.060 --> 02:41:34.060]  А мы можем сделать наоборот. Мы можем взять, например, tuple и еще некоторые вещи
[02:41:35.060 --> 02:41:37.060]  и разбить его на отдельные переменные.
[02:41:37.060 --> 02:41:39.060]  Вот такой особенный синтаксис.
[02:41:39.060 --> 02:41:42.060]  авто, квадратные скобочки,
[02:41:43.060 --> 02:41:55.060]  не знаю, ver равно, что у нас здесь, ну, verg равно forward.
[02:41:56.060 --> 02:41:58.060]  Так.
[02:42:02.060 --> 02:42:05.060]  Ладно, тут слишком сложный пример. Давайте тогда...
[02:42:05.060 --> 02:42:07.060]  А вот tuple.
[02:42:11.060 --> 02:42:13.060]  Вот. Что произошло?
[02:42:13.060 --> 02:42:17.060]  Мы объявили как бы
[02:42:18.060 --> 02:42:20.060]  типа три новые переменные
[02:42:21.060 --> 02:42:23.060]  и принципизировали их
[02:42:25.060 --> 02:42:28.060]  соответствующими значениями, которые лежат в tuple.
[02:42:30.060 --> 02:42:31.060]  Вот.
[02:42:31.060 --> 02:42:34.060]  Сейчас это копии. Мы можем сделать
[02:42:34.060 --> 02:42:37.060]  на весь этим персант, чтобы это были ссылки.
[02:42:37.060 --> 02:42:39.060]  Вот. Можем делать их константными.
[02:42:42.060 --> 02:42:44.060]  Вот. В этом смысле никаких особо сюрпризов.
[02:42:47.060 --> 02:42:49.060]  В каких ситуациях это применяется?
[02:42:50.060 --> 02:42:52.060]  Значит, первое.
[02:42:52.060 --> 02:42:55.060]  Если у вас справа стоит tuple или para,
[02:42:57.060 --> 02:42:59.060]  или ray из стандартных типов.
[02:43:01.060 --> 02:43:03.060]  Для std ray это тоже работает.
[02:43:03.060 --> 02:43:09.060]  То есть, если вы скажете, что у вас есть std ray int 3 rr,
[02:43:10.060 --> 02:43:12.060]  то здесь вы можете сделать rr.
[02:43:12.060 --> 02:43:14.060]  Вот это будут три константные ссылки на int.
[02:43:14.060 --> 02:43:16.060]  В таком случае.
[02:43:16.060 --> 02:43:19.060]  Вот. Если справа стоит сишный массив,
[02:43:19.060 --> 02:43:21.060]  то есть, мы можем написать int
[02:43:21.060 --> 02:43:23.060]  не знаю, давайте char
[02:43:23.060 --> 02:43:25.060]  3 char
[02:43:25.060 --> 02:43:27.060]  равно
[02:43:27.060 --> 02:43:31.060]  a, b, c
[02:43:33.060 --> 02:43:35.060]  и здесь char.
[02:43:38.060 --> 02:43:40.060]  Почему не нравится?
[02:43:42.060 --> 02:43:44.060]  А, потому что я не туда тройку написал.
[02:43:44.060 --> 02:43:46.060]  Вот.
[02:43:46.060 --> 02:43:48.060]  Можно так сделать.
[02:43:50.060 --> 02:43:52.060]  Но здесь, соответственно, их должно быть столько же.
[02:43:53.060 --> 02:43:54.060]  Меньше нельзя.
[02:43:54.060 --> 02:43:56.060]  Ну, больше тоже нельзя, понятным причинам.
[02:44:00.060 --> 02:44:02.060]  Указатель уже бы не сработало.
[02:44:08.060 --> 02:44:09.060]  Да.
[02:44:09.060 --> 02:44:10.060]  Ну, понятное.
[02:44:10.060 --> 02:44:12.060]  Указатель уже бы не сработало.
[02:44:14.060 --> 02:44:15.060]  Да, в смысле?
[02:44:15.060 --> 02:44:16.060]  А это неважно.
[02:44:16.060 --> 02:44:18.060]  Это же все на этапе компиляции происходит.
[02:44:19.060 --> 02:44:20.060]  Вот. Так нельзя.
[02:44:20.060 --> 02:44:22.060]  Собственно, потому что это происходит на этапе компиляции.
[02:44:22.060 --> 02:44:24.060]  Компилятор не может удостовериться, что все нормально.
[02:44:27.060 --> 02:44:28.060]  И
[02:44:28.060 --> 02:44:30.060]  самое интересное
[02:44:30.060 --> 02:44:32.060]  это, если у вас есть структура,
[02:44:32.060 --> 02:44:34.060]  которая, благодаря некоторым правилам, она достаточно простая.
[02:44:35.060 --> 02:44:37.060]  Да, например, не знаю, точка.
[02:44:39.060 --> 02:44:42.060]  Здесь есть int x, int y.
[02:44:44.060 --> 02:44:46.060]  То вы можете написать
[02:44:50.060 --> 02:44:52.060]  x, y
[02:44:52.060 --> 02:44:54.060]  равно point, например.
[02:44:56.060 --> 02:44:57.060]  Какие правила?
[02:44:57.060 --> 02:44:59.060]  Re-division of x.
[02:44:59.060 --> 02:45:00.060]  Ну, x, x, y, y.
[02:45:00.060 --> 02:45:02.060]  Какие правила?
[02:45:02.060 --> 02:45:04.060]  Все поля должны быть публичными.
[02:45:04.060 --> 02:45:06.060]  Все поля должны быть
[02:45:06.060 --> 02:45:08.060]  либо в самой структуре,
[02:45:08.060 --> 02:45:10.060]  либо в одном из ее родителей.
[02:45:11.060 --> 02:45:13.060]  То есть, если я тут напишу
[02:45:13.060 --> 02:45:14.060]  uh
[02:45:20.060 --> 02:45:21.060]  another point,
[02:45:22.060 --> 02:45:23.060]  который от point
[02:45:26.060 --> 02:45:27.060]  паблик
[02:45:28.060 --> 02:45:29.060]  вот
[02:45:30.060 --> 02:45:32.060]  то я могу сделать another point.
[02:45:34.060 --> 02:45:36.060]  Но если я сюда добавлю что-то еще,
[02:45:38.060 --> 02:45:39.060]  например,
[02:45:40.060 --> 02:45:41.060]  int 32t color,
[02:45:41.060 --> 02:45:42.060]  то уже не могу.
[02:45:45.060 --> 02:45:46.060]  Ну, так тоже не могу.
[02:45:47.060 --> 02:45:49.060]  Но чтобы они все были на одном уровне наследования.
[02:45:51.060 --> 02:45:52.060]  Вот.
[02:45:53.060 --> 02:45:55.060]  Ну, соответственно, как работает вот эта же вещь
[02:45:57.060 --> 02:46:00.060]  и как работает вот эта вещь, более-менее понятно.
[02:46:01.060 --> 02:46:04.060]  У нас есть структура, компилятор смотрит первое, второе, третье поле,
[02:46:04.060 --> 02:46:07.060]  компилятор у нас есть либо массив,
[02:46:07.060 --> 02:46:09.060]  он смотрит, берет первый, второе, третий элемент массива.
[02:46:09.060 --> 02:46:13.060]  С array и туплом и парой немножко более хитрая история.
[02:46:16.060 --> 02:46:17.060]  Значит,
[02:46:17.060 --> 02:46:20.060]  потому что эти структуры не удовлетворяют мне не тому, что они массив,
[02:46:20.060 --> 02:46:22.060]  не тому, что они вот такие простые.
[02:46:24.060 --> 02:46:27.060]  Есть специальный синтактис, чтобы
[02:46:28.060 --> 02:46:30.060]  указать компилятору, что с моей структурой можно делать вот так.
[02:46:31.060 --> 02:46:32.060]  Вот.
[02:46:32.060 --> 02:46:35.060]  Чтобы вот так можно было делать, мы для своей структуры должны написать
[02:46:36.060 --> 02:46:37.060]  значит
[02:46:37.060 --> 02:46:38.060]  значит
[02:46:41.060 --> 02:46:44.060]  мы должны специализировать два шаблона стандартных.
[02:46:47.060 --> 02:46:49.060]  Это tuple-size
[02:46:52.060 --> 02:46:55.060]  и tuple-element.
[02:46:56.060 --> 02:46:58.060]  Значит tuple-size нам должен вернуть
[02:47:02.060 --> 02:47:06.060]  размер, ну, то есть сколько у нас элементов в структуре,
[02:47:06.060 --> 02:47:08.060]  чтобы можно было проверить,
[02:47:09.060 --> 02:47:12.060]  что у нас правильное количество штук в авто написано.
[02:47:12.060 --> 02:47:14.060]  А tuple-element должен вернуть тип.
[02:47:14.060 --> 02:47:15.060]  Вот.
[02:47:15.060 --> 02:47:17.060]  И еще после этого должна быть функция get,
[02:47:17.060 --> 02:47:19.060]  которая собственно вернется
[02:47:20.060 --> 02:47:22.060]  элемент соответствующего типа.
[02:47:25.060 --> 02:47:27.060]  Нет, tuple-size это структура,
[02:47:28.060 --> 02:47:30.060]  то есть у нас есть std tuple-size.
[02:47:32.060 --> 02:47:34.060]  И что мы должны сделать?
[02:47:35.060 --> 02:47:37.060]  Что вроде
[02:47:38.060 --> 02:47:45.060]  struct std tuple-size от another point
[02:47:48.060 --> 02:47:52.060]  и здесь пишем size t static
[02:47:55.060 --> 02:47:58.060]  value равно 3 там в нашем случае.
[02:47:59.060 --> 02:48:00.060]  Вот.
[02:48:00.060 --> 02:48:01.060]  И тогда он
[02:48:02.060 --> 02:48:04.060]  уже решит, что, ага,
[02:48:04.060 --> 02:48:06.060]  это недостаточно простой тип,
[02:48:06.060 --> 02:48:08.060]  но пользователь что-то мне сказал.
[02:48:09.060 --> 02:48:10.060]  Вот.
[02:48:10.060 --> 02:48:12.060]  И сейчас он будет на меня ругаться за то,
[02:48:12.060 --> 02:48:14.060]  что мне не хватает get.
[02:48:14.060 --> 02:48:15.060]  Он не понял,
[02:48:15.060 --> 02:48:17.060]  он понял, что я ему хочу сказать,
[02:48:17.060 --> 02:48:19.060]  что можно с моей структурой так делать,
[02:48:19.060 --> 02:48:21.060]  но я не сказал как.
[02:48:21.060 --> 02:48:23.060]  Вот, поэтому get не хватает.
[02:48:24.060 --> 02:48:26.060]  Да, нужно еще
[02:48:26.060 --> 02:48:28.060]  get определить.
[02:48:28.060 --> 02:48:30.060]  Так же, да?
[02:48:30.060 --> 02:48:32.060]  Вы еще про type что-то говорили?
[02:48:32.060 --> 02:48:33.060]  Да, type.
[02:48:33.060 --> 02:48:35.060]  Ну, у нас должна быть вот такая же штука,
[02:48:35.060 --> 02:48:37.060]  значит,
[02:48:37.060 --> 02:48:39.060]  только от
[02:48:40.060 --> 02:48:42.060]  size t index
[02:48:43.060 --> 02:48:45.060]  tuple-element
[02:48:46.060 --> 02:48:48.060]  another point
[02:48:48.060 --> 02:48:50.060]  index
[02:48:50.060 --> 02:48:52.060]  и здесь будет using
[02:48:52.060 --> 02:48:54.060]  это где лежит?
[02:48:54.060 --> 02:48:56.060]  type, что именно?
[02:48:56.060 --> 02:48:58.060]  Что вы рележите, я не понимаю.
[02:49:01.060 --> 02:49:03.060]  Оригинальный шаблон я даже не знаю,
[02:49:03.060 --> 02:49:05.060]  честно говоря.
[02:49:08.060 --> 02:49:10.060]  И что мы делаем?
[02:49:11.060 --> 02:49:13.060]  Вот, но если бы здесь было int,
[02:49:13.060 --> 02:49:15.060]  мы бы всегда возвращали int.
[02:49:15.060 --> 02:49:17.060]  Сейчас для скорости сделаем вот так.
[02:49:18.060 --> 02:49:20.060]  Так, что мне нравится?
[02:49:21.060 --> 02:49:23.060]  А, потому что
[02:49:26.060 --> 02:49:28.060]  видимо в обратном порядке.
[02:49:31.060 --> 02:49:33.060]  Да, вот так.
[02:49:33.060 --> 02:49:35.060]  И нам еще нужна функция get.
[02:49:35.060 --> 02:49:37.060]  Ну, у нас будет всегда возвращать, например, int,
[02:49:37.060 --> 02:49:39.060]  get
[02:49:39.060 --> 02:49:41.060]  от нашего
[02:49:41.060 --> 02:49:43.060]  another point
[02:49:47.060 --> 02:49:49.060]  Нет, по-моему, это не обязан быть,
[02:49:49.060 --> 02:49:51.060]  если это get.
[02:49:51.060 --> 02:49:53.060]  И мы делаем return
[02:49:54.060 --> 02:49:56.060]  p.
[02:49:56.060 --> 02:49:58.060]  не знаю, x
[02:50:00.060 --> 02:50:02.060]  template
[02:50:02.060 --> 02:50:04.060]  size t
[02:50:04.060 --> 02:50:06.060]  index
[02:50:06.060 --> 02:50:08.060]  Ну, здесь, конечно, нужно не всегда
[02:50:08.060 --> 02:50:10.060]  x возвращать, понятно.
[02:50:10.060 --> 02:50:12.060]  Но вот все, теперь это скомпилировалось.
[02:50:14.060 --> 02:50:16.060]  То есть, это все такие
[02:50:16.060 --> 02:50:18.060]  быстрые наброски, чтобы показать, что если мы указали
[02:50:18.060 --> 02:50:20.060]  вот эти три вещи,
[02:50:20.060 --> 02:50:22.060]  компилятор по другим правилам теперь сказал,
[02:50:22.060 --> 02:50:24.060]  чтобы работать с этой структурой в таком контексте.
[02:50:24.060 --> 02:50:26.060]  Вот, пока она возвращает фигню,
[02:50:26.060 --> 02:50:28.060]  нужно доделать.
[02:50:28.060 --> 02:50:30.060]  Ну, это типа в качестве упражнения.
[02:50:30.060 --> 02:50:32.060]  Get ни к чему не привязан, просто
[02:50:32.060 --> 02:50:34.060]  функция.
[02:50:34.060 --> 02:50:36.060]  Да, ну, должна быть либо свободная функция get,
[02:50:36.060 --> 02:50:38.060]  либо кажется можно, чтобы это была
[02:50:38.060 --> 02:50:40.060]  функция член класса.
[02:50:42.060 --> 02:50:44.060]  Можно ли передать, если своей структуре
[02:50:44.060 --> 02:50:46.060]  передать шаблонный параметр int,
[02:50:48.060 --> 02:50:50.060]  можно ли потом ее распаковывать в int
[02:50:50.060 --> 02:50:52.060]  аргументах?
[02:50:52.060 --> 02:50:54.060]  В int аргументах.
[02:50:54.060 --> 02:50:56.060]  Не понял?
[02:50:56.060 --> 02:50:58.060]  В typical size можно будет ее распаковать.
[02:50:58.060 --> 02:51:00.060]  Кого?
[02:51:00.060 --> 02:51:02.060]  Если, например, у меня есть шаблонный аргумент int
[02:51:02.060 --> 02:51:04.060]  А, если шаблонный аргумент у структуры,
[02:51:04.060 --> 02:51:06.060]  да. Ну, типа у вас просто будет
[02:51:06.060 --> 02:51:08.060]  что-то вот такое тут.
[02:51:08.060 --> 02:51:10.060]  Вот тут опять будет такое.
[02:51:10.060 --> 02:51:12.060]  В плане, оно автоматически не определится,
[02:51:12.060 --> 02:51:14.060]  если у меня, например,
[02:51:14.060 --> 02:51:16.060]  в root 3 будет ray размеры.
[02:51:16.060 --> 02:51:18.060]  Не, автоматически тут ничего не определится,
[02:51:18.060 --> 02:51:20.060]  тебе нужно все прописывать.
[02:51:20.060 --> 02:51:22.060]  Нет, в плане, он же автоматически
[02:51:22.060 --> 02:51:24.060]  определяет для pointer.
[02:51:24.060 --> 02:51:26.060]  Для кого?
[02:51:26.060 --> 02:51:28.060]  Для pointer. Что он определяет?
[02:51:28.060 --> 02:51:30.060]  Как распаковывается. Ну, это еще раз, у тебя есть
[02:51:30.060 --> 02:51:32.060]  три разных правила, одно для массивов сишных,
[02:51:32.060 --> 02:51:34.060]  одно для простых структур, и вот это
[02:51:34.060 --> 02:51:36.060]  третье, где все руками.
[02:51:36.060 --> 02:51:38.060]  Вот у меня может быть структура, в которой, например,
[02:51:38.060 --> 02:51:40.060]  сишный массив.
[02:51:40.060 --> 02:51:42.060]  Ну, нет, так, ну, тогда
[02:51:42.060 --> 02:51:44.060]  она может распаковаться, но, типа,
[02:51:44.060 --> 02:51:46.060]  единственным элементом будет сишный массив.
[02:51:48.060 --> 02:51:50.060]  Типа, элементы массива ты так уже не получишь.
[02:51:52.060 --> 02:51:54.060]  Ну, все, ладно, давайте тогда закончим на этом.
[02:51:58.060 --> 02:52:00.060]  А, последнее, что я скажу, что
[02:52:00.060 --> 02:52:02.060]  вот этот синтаксис,
[02:52:02.060 --> 02:52:04.060]  его также можно внутри фора использовать,
[02:52:04.060 --> 02:52:06.060]  что очень удобно, например, проходиться по мапу.
[02:52:06.060 --> 02:52:08.060]  Можно писать const
[02:52:08.060 --> 02:52:10.060]  auto
[02:52:10.060 --> 02:52:12.060]  kvalue
[02:52:12.060 --> 02:52:14.060]  v.
[02:52:14.060 --> 02:52:16.060]  там какой-нибудь m.
[02:52:16.060 --> 02:52:18.060]  Вот, и внутри
[02:52:18.060 --> 02:52:20.060]  использовать этими kvalue.
[02:52:34.060 --> 02:52:36.060]  Наверное, да.
[02:52:40.060 --> 02:52:42.060]  Да, все.
[02:52:44.060 --> 02:52:46.060]  Все, теперь точно все.
