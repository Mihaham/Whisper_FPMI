[00:00.000 --> 00:30.000]  ПРОДОЛЖЕНИЕ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙС
[00:30.000 --> 00:35.940]  ПОЛИЦЕЙС обор trata
[00:41.280 --> 00:44.260]  Так, пусть у нас есть строка какая-то.
[00:45.620 --> 00:47.280]  Давайте я ее знаменирую.
[00:52.360 --> 00:54.080]  Которая заканчивается на доллар.
[01:00.000 --> 01:05.300]  Вот, ну как мы в SUFMAS дописываем решетку в конце, здесь традиционно
[01:05.300 --> 01:08.780]  дописываем доллар, но опять неважно, тут даже неважно,
[01:08.780 --> 01:11.460]  что этот символ меньше всех символов алфавита, просто
[01:11.460 --> 01:14.620]  какой-то отдельный, особенно выделенный символ, который
[01:14.620 --> 01:16.020]  не встречается больше нигде в строке.
[01:16.020 --> 01:37.220]  Ну и давайте я для удобства обозначу через S с верхним
[01:37.220 --> 01:42.260]  индексом и ты суффикс, то есть это строка начинающаяся
[01:42.260 --> 01:47.300]  с SE до конца.
[01:47.300 --> 02:00.420]  Вот, значит и суффиксное дерево, такая структура
[02:00.420 --> 02:03.540]  данных, которая по сути представляет из себя бор,
[02:03.620 --> 02:09.540]  на всех суффиксах строки S, определение, ну такое не
[02:09.540 --> 02:16.980]  очень формальное, давайте в кавычках возьму, суффдерева
[02:16.980 --> 02:28.980]  строки S это сжатый бор тех Е у суффиксов, то есть строк
[02:29.540 --> 02:43.860]  S с верхним индексом 0, 1 и так далее, N-1, вот есть все
[02:43.860 --> 02:46.260]  суффиксы, мы их как бы складываем в бор и в каком-то смысле
[02:46.260 --> 02:47.260]  делаем его сжатым.
[02:47.260 --> 02:52.580]  Значит, что такое сжатый бор, это когда мы удаляем
[02:52.580 --> 02:55.380]  проходные вершинки, то есть смотрите, если мы просто
[02:55.380 --> 02:58.220]  построим этот бор на всех вот этих вот словах, то в
[02:58.300 --> 03:03.260]  худшем случае у нас будет вот такая вот большая штука,
[03:03.260 --> 03:06.140]  то есть грубо говоря, если все буквы в слове различные,
[03:06.140 --> 03:08.100]  то все суффиксы начинаются на разные буквы и тогда
[03:08.100 --> 03:12.060]  все будет выглядеть вот так, где каждая вот такая дуга
[03:12.060 --> 03:14.460]  это суффикс, соответственно здесь куча вершин, куча
[03:14.460 --> 03:15.460]  ребер.
[03:15.460 --> 03:23.580]  А сжатый бор, это когда мы сжимаем вот такие вот длинные
[03:23.580 --> 03:27.020]  отрезки без витвлений, длинные вот такие вот, как бы
[03:27.020 --> 03:31.500]  сказал Андрей Михайлович, сардельки, такие длинные
[03:31.500 --> 03:35.420]  сардельки мы сжимаем просто в одно ребро, то есть говорим,
[03:35.420 --> 03:40.220]  что вот это все одно ребро и на нем написано не по
[03:40.220 --> 03:43.300]  одной букве много раз, а здесь написано какая-то
[03:43.300 --> 03:46.820]  сразу под строка, какая-то сразу под строка.
[03:46.820 --> 03:47.820]  Давайте какой-нибудь пример нарисуем.
[03:47.820 --> 04:02.260]  Для строки, ну такой, например, давайте построим для него
[04:02.260 --> 04:03.260]  суффиксное дерево.
[04:03.260 --> 04:23.460]  Ну, чего будет, Дина А, дальше, Дина А, Дина А, Дина А,
[04:23.460 --> 04:44.340]  Дина А.
[04:44.340 --> 04:45.560]  Проверяемся.
[04:45.560 --> 04:50.080]  Ну и доллар нарисовать из корня.
[04:50.080 --> 04:53.800]  Значит, вроде фотософикса есть, доллар есть, б-доллар,
[04:53.800 --> 05:02.680]  вот он, а-б-доллар, вот, а-а-б-доллар, п-а-а-б-доллар, а-б-а-б-доллар,
[05:02.680 --> 05:03.680]  все есть.
[05:03.680 --> 05:06.080]  Вот, и причем здесь я прям смело на ребрах пишу
[05:06.080 --> 05:08.960]  некие подстроки, да, не один символ, а несколько символов
[05:08.960 --> 05:09.960]  подряд.
[05:09.960 --> 05:14.200]  Ну, собственно, в этом и есть сжатость нашего убора,
[05:14.200 --> 05:16.800]  что на ребре мы можем писать не один символ, а несколько
[05:16.800 --> 05:17.800]  подряд.
[05:18.800 --> 05:22.800]  Вот, то есть, ну давайте я что-нибудь напишу, да, что...
[05:26.800 --> 05:28.800]  Какой-то марафин надо навести все-таки.
[05:28.800 --> 05:31.800]  Что такое сжатый бор на ребрах?
[05:34.800 --> 05:42.800]  Могут быть написаны строки.
[05:48.800 --> 05:52.800]  А не только символы.
[05:58.800 --> 06:01.800]  Ну, и раньше еще в боре было условие, что из вершинки
[06:01.800 --> 06:04.800]  не может быть несколько разных ребер по одной и
[06:04.800 --> 06:06.800]  той же букве, да, то есть, если в боре запрещалось что-то
[06:06.800 --> 06:11.800]  вот такое вот иметь, нельзя.
[06:11.800 --> 06:15.800]  То теперь при сжатии условие будет очень похожим, но
[06:15.800 --> 06:18.800]  только там будет смотреться не на раме ребра, а на первую
[06:18.800 --> 06:19.800]  букву ребер.
[06:19.800 --> 06:21.800]  То есть, теперь нельзя...
[06:24.800 --> 06:25.800]  Не знаю, там, ц...
[06:30.800 --> 06:33.800]  То есть, раньше мы говорили, что у нас должны быть обязательно
[06:33.800 --> 06:37.800]  все различные исходящие стрелочки, а теперь различия
[06:37.800 --> 06:38.800]  мы смотрим по первым буквам.
[06:38.800 --> 06:41.800]  Да, у всех исходящих ребер не должны быть одинаковые
[06:41.800 --> 06:44.800]  первые буквы, ну, потому что если у них одинаковые
[06:44.800 --> 06:46.800]  первые буквы, то их надо было бы вот так склеить,
[06:46.800 --> 06:48.800]  вот эти ребра надо было склеить, по крайней мере,
[06:48.800 --> 06:50.800]  по одному первому символу, и картинка была бы какая-то
[06:50.800 --> 06:54.800]  вот такая, да, что здесь С, а здесь вот эти вот кусочки.
[06:54.800 --> 06:55.800]  Вот.
[06:55.800 --> 06:59.800]  Ну, а соответственно говорить, что эти строки различные
[06:59.800 --> 07:02.800]  мы как бы не можем, потому что они могут где-то совпадать,
[07:02.800 --> 07:06.800]  да, например, может быть там АВ и БВ, вот такие вполне
[07:06.800 --> 07:08.800]  ребра могут быть.
[07:08.800 --> 07:11.800]  То есть, если действительно здесь в исходном боре было
[07:11.800 --> 07:15.800]  А вниз и В вниз, а здесь просто БВ, то тогда это просто
[07:15.800 --> 07:19.800]  сжимается вот в подстрочку АВ и подстрочку БВ.
[07:19.800 --> 07:21.800]  А, то есть...
[07:23.800 --> 07:25.800]  Еще раз?
[07:32.800 --> 07:36.800]  Ну, БВ, да, конечно, тоже.
[07:36.800 --> 07:39.800]  Ну, АВ, то есть еще раз, да, если у нас есть, скажем,
[07:39.800 --> 07:41.800]  какие-то вот...
[07:41.800 --> 07:45.800]  Ну, вот такую картинку, такая картинка, конечно, сжимается
[07:45.800 --> 07:47.800]  вот в такую.
[07:49.800 --> 07:51.800]  Окей?
[07:55.800 --> 07:57.800]  А, да, да, справедливые замечания, потому что здесь
[07:57.800 --> 08:01.800]  такого как будто нет. Да, конечно, так может быть.
[08:01.800 --> 08:05.800]  Давайте я какой-нибудь еще пример нарисую.
[08:05.800 --> 08:07.800]  Да, я вас понял.
[08:07.800 --> 08:11.800]  Да, нет, тут такого действительно нету.
[08:11.800 --> 08:13.800]  Сейчас придумаю.
[08:14.800 --> 08:16.800]  Ну, да, например, вот такое.
[08:16.800 --> 08:19.800]  Если я напишу такую строчку, то здесь после А всегда идет
[08:19.800 --> 08:23.800]  Б, поэтому из корня будет ребро АВ.
[08:23.800 --> 08:25.800]  И это нормально.
[08:25.800 --> 08:28.800]  Да, все остальное как-то там выглядит.
[08:28.800 --> 08:30.800]  Ну, давайте я уже нарисую.
[08:38.800 --> 08:40.800]  Да.
[08:40.800 --> 08:43.800]  Ребра, на которых написаны много букв, могут быть не
[08:43.800 --> 08:46.800]  только ведущими в листья, но и какие-то там посреди
[08:46.800 --> 08:48.800]  дерева тоже.
[08:48.800 --> 08:50.800]  Так, вопросы есть?
[08:50.800 --> 08:54.800]  Ну, и, соответственно, так же как в обычном боре,
[08:54.800 --> 08:57.800]  я буду называть терминальными те вершины, которые отвечают
[08:57.800 --> 09:00.800]  каким-то из вот этих вот словарных слов, да, то есть мы
[09:00.800 --> 09:03.800]  строим Бор по сути, по вот этому набору строк.
[09:03.800 --> 09:06.800]  Вершины, отвечающие концам этих строк, будут терминальными.
[09:06.800 --> 09:09.800]  Давайте подпишем, что вот эти вот слова отвечают
[09:09.800 --> 09:12.800]  терминальным вершинам.
[09:16.800 --> 09:19.800]  Терминальным вершинам.
[09:21.800 --> 09:23.800]  Так, окей.
[09:27.800 --> 09:30.800]  Вот, значит, еще вопрос у меня такой к вам.
[09:30.800 --> 09:33.800]  Вот, смотрите, если я буду прям таким явным образом
[09:33.800 --> 09:38.800]  хранить Бор и на всех ребрах писать прям вот, ну, строчку,
[09:38.800 --> 09:41.800]  набор символов, то сколько памяти будет занимать такая
[09:41.800 --> 09:45.800]  структура, если сходно в строке было N символов?
[09:49.800 --> 09:51.800]  Нет?
[09:51.800 --> 09:55.800]  N квадрат, да, потому что здесь каждый символ, ну, не
[09:55.800 --> 09:59.800]  так, да, здесь суммарная длина всех вот этих вот строк,
[09:59.800 --> 10:01.800]  которые написаны в дереве, равна суммарной длине всех
[10:01.800 --> 10:03.800]  суффиксов.
[10:04.800 --> 10:06.800]  В худшем случае, окей, может быть.
[10:06.800 --> 10:10.800]  В худшем случае может быть такое, что если все символы
[10:10.800 --> 10:12.800]  строки различны, то у меня получается вот такой вот
[10:12.800 --> 10:16.800]  Бор сжатый, и если на каждом, если на каждой вот этой
[10:16.800 --> 10:19.800]  сардельке написан суффикс, да, то суммарная длина всего,
[10:19.800 --> 10:21.800]  что написано, это квадрат, потому что там будет сумма
[10:21.800 --> 10:25.800]  длин, один плюс два плюс так далее, плюс N, на это
[10:25.800 --> 10:28.800]  по прям квадрат.
[10:28.800 --> 10:32.800]  Поэтому писать явным образом здесь вот прям строки на
[10:32.800 --> 10:34.800]  ребрах, это не очень выгодно.
[10:35.800 --> 10:38.800]  Вместо этого мы будем хранить на самом деле просто два
[10:38.800 --> 10:42.800]  индекса, каждое ребро у нас будет представлено в виде
[10:42.800 --> 10:46.800]  двух индексов LR, ну, как знак того, что строка написанная
[10:46.800 --> 10:49.800]  здесь, это просто подстрока исходной строки с LT позиции
[10:49.800 --> 10:51.800]  по R2, вот и все.
[10:51.800 --> 10:53.800]  Потому что понятно, что поскольку я работаю на одной
[10:53.800 --> 10:56.800]  строке, закидываю сюда все возможные суффиксы, ну,
[10:56.800 --> 10:58.800]  значит, здесь там какие-то префиксы, какие-то куски
[10:58.800 --> 11:00.800]  суффиксов, то есть это все в любом случае подстроки
[11:00.800 --> 11:01.800]  исходной строки.
[11:01.800 --> 11:03.800]  Я читаю несколько символов подряд, это обязательно
[11:03.800 --> 11:05.800]  подстрока исходной строки.
[11:05.800 --> 11:09.800]  Поэтому вместо хранения прям явно строки на ребрах
[11:09.800 --> 11:12.800]  нашего сжатого бора я буду хранить два индекса, начало
[11:12.800 --> 11:13.800]  и конец.
[11:13.800 --> 11:15.800]  То есть вот, например, здесь вместо AB$ я буду хранить
[11:15.800 --> 11:20.800]  два числа, два 4, да, потому что это 0, 1, 2, 3, 4.
[11:20.800 --> 11:24.800]  Вместо этого формально я буду хранить пару 2,4, ну,
[11:24.800 --> 11:29.800]  два индекса, левый и правый.
[11:29.800 --> 11:33.800]  И тогда уже можно будет надеяться, что размер этой
[11:33.800 --> 11:35.800]  штуки будет линейен, по крайней мере, в этом худшем
[11:35.800 --> 11:38.800]  случае размер точно линейен, потому что здесь, ну, там
[11:38.800 --> 11:43.800]  n плюс одна вершина, видимо, n, n ребер, и каждое ребро
[11:43.800 --> 11:45.800]  это просто хранение двух чисел.
[11:45.800 --> 11:47.800]  Тогда уже, по крайней мере, в этом случае память линейна,
[11:47.800 --> 11:51.800]  и можно надеяться, что алгоритм тоже может быть линейным.
[11:51.800 --> 11:56.800]  Ну, давайте докажем, что если мы храним ребра именно
[11:56.800 --> 12:00.800]  так, как под строки, началом и концом, то память действительно
[12:00.800 --> 12:01.800]  будет линейная.
[12:01.800 --> 12:12.800]  Значит, если длина s равна n, то в суфигном дереве строки
[12:12.800 --> 12:23.800]  s будет вершин и вот n ребер.
[12:23.800 --> 12:28.800]  Ну, соответственно, если там линейное число вершин
[12:28.800 --> 12:31.800]  и ребер, на каждом ребре написаны по два числа,
[12:31.800 --> 12:33.800]  значит, суммарная память здесь тоже будет линейная.
[12:33.800 --> 12:35.800]  Ну, доказательства тривиально.
[12:35.800 --> 12:39.800]  В качестве доказательства мы давайте предъявим алгоритм
[12:39.800 --> 12:42.800]  по строению суф-дерево за... вот он в квадрате.
[12:42.800 --> 12:59.800]  Алгоритм по строению суф-дерево за т т т квадрат.
[12:59.800 --> 13:05.800]  Так, алгоритм будет такой, давайте мы будем добавлять
[13:05.800 --> 13:09.800]  вбор по одному суффиксу в порядке убывания.
[13:09.800 --> 13:24.800]  Добавлять суффикс в порядке убывания длины.
[13:24.800 --> 13:25.800]  Будем это делать так.
[13:25.800 --> 13:29.800]  Сначала у нас есть корень, мы добавляем суффикс s нулевой,
[13:29.800 --> 13:31.800]  то есть всю строку, как одно длинное ребро, и на этом
[13:31.800 --> 13:34.800]  на этом ребре пишем под строку с 0 по n-1.
[13:34.800 --> 13:36.800]  Напоминаю, что саму строку мы не пишем, мы пишем только
[13:36.800 --> 13:38.800]  два индекса, начало, конец.
[13:38.800 --> 13:41.800]  Дальше мне нужно просчитать s1.
[13:41.800 --> 13:46.800]  Ну, смотрите, s1 и s0 могут иметь некий общий префикс,
[13:46.800 --> 13:48.800]  могут иметь несколько общих первых символов.
[13:48.800 --> 13:51.800]  Тогда давайте их найдем столько, сколько нужно,
[13:51.800 --> 13:54.800]  сколько у них совпадает первых символов,
[13:54.800 --> 13:57.800]  а дальше нужно будет отвитвиться.
[13:57.800 --> 14:00.800]  То есть вот здесь будет какая-то такая точка,
[14:00.800 --> 14:04.800]  что первые вот эти символы равны us0 и us1,
[14:04.800 --> 14:06.800]  а дальше начинается какое-то различие,
[14:06.800 --> 14:11.800]  и мне придется отвитвиться и написать здесь s1.
[14:11.800 --> 14:13.800]  Причем это будет всегда происходить,
[14:13.800 --> 14:14.800]  мне всегда нужно будет отвитвиться,
[14:14.800 --> 14:17.800]  потому что все наши суффиксы заканчиваются на доллар,
[14:17.800 --> 14:20.800]  а значит, мне всегда придется,
[14:20.800 --> 14:22.800]  ну, то есть когда я вот так буду делать
[14:22.800 --> 14:24.800]  итеративно по всем суффиксам,
[14:24.800 --> 14:29.800]  я всегда буду до какого-то момента читать общие символы,
[14:29.800 --> 14:31.800]  а потом мне придется отвитвиться,
[14:31.800 --> 14:33.800]  как минимум потому, что у меня встречается доллар
[14:33.800 --> 14:35.800]  на позиции раньше, чем все предыдущие.
[14:35.800 --> 14:37.800]  Потому что я перебираю в порядке выбывания длины,
[14:37.800 --> 14:39.800]  доллар будет на более ранней позиции,
[14:39.800 --> 14:43.800]  мне придется отвитвиться.
[14:43.800 --> 14:45.800]  Ну, То есть алгоритм такой,
[14:45.800 --> 14:47.800]  перебираем вот так вот суффиксы в порядке s0, s1, и так далее.
[14:47.800 --> 14:49.800]  Читаем в боре столько, сколько можно
[14:49.800 --> 14:51.800]  префикса текущего суффикса.
[14:51.800 --> 14:53.800]  Например, там s2 может выглядеть как-то вот так
[14:53.800 --> 14:55.800]  вот тут вот общая, тут вот общая,
[14:55.800 --> 14:57.800]  а потом придется Serv trying, ну, и так далее.
[14:57.800 --> 15:02.840]  суффикс обрабатывается за линейное время, потому что мне нужно сначала найти общий
[15:02.840 --> 15:06.280]  префикс, который есть в боре, ну то есть просто наибольший префикс текущей строки,
[15:06.280 --> 15:11.200]  которая есть в боре. Потом, когда уже нельзя дальше читать, нужно просто создать новое ребро,
[15:11.200 --> 15:16.960]  написать, что здесь там какой-то остаток нашего суффикса лежит. Ну и собственно все,
[15:16.960 --> 15:24.680]  мы закончили обработку строки. То есть мы просто создаем одно ребро. Мы должны расщепить, расщепить
[15:24.680 --> 15:29.360]  ребро, поставить здесь вершину, соответственно сказать, что здесь отдельное ребро, здесь
[15:29.360 --> 15:35.200]  отдельное ребро, ну и еще одно ребро добавить, чтобы выделить конец новой строки. То есть в
[15:35.200 --> 15:43.000]  худшем случае мне придется одно ребро расщепить, добавить одно ребро и еще добавить ребро с вершиной.
[15:43.000 --> 15:48.000]  Поэтому каждое добавление суффикса, каждое добавление этой строки в наш сжатый бор,
[15:48.000 --> 16:02.160]  ну там увеличивает число вершины ребер максимум на два видимо. Добавление каждой строки
[16:02.160 --> 16:09.400]  увеличивает число вершины ребер не больше чем на два.
[16:18.000 --> 16:32.440]  Ну конечно, да, если есть вершина, я стою здесь, мне нужно прочитать там какое-то слово, ну да,
[16:32.440 --> 16:38.000]  то есть продолжить чтение какой-то там строки. Я смотрю какие-то первые символы, выбираю тот,
[16:38.000 --> 16:41.440]  который совпадает с тем, что мне нужно прочитать и иду вниз, собственно, по этому ребру.
[16:41.440 --> 16:47.800]  Вот, ну а раз каждый из суффиксов добавляет максимум две вершины, два ребра, значит сумма
[16:47.800 --> 16:53.320]  армии там максимум 2n вершины ребер, значит линия, что и требовалось. Это классно?
[17:11.440 --> 17:31.160]  Так, что дальше? Заказали. Следующее, что нам нужно, это ввести понятие сувсылки. Ну, нет,
[17:31.160 --> 17:35.600]  давайте сначала поймем какие вообще бывают позиции в дереве, потом введем сувсылку,
[17:35.600 --> 17:44.520]  значит позиции в дереве. Смотрите, мы поняли, что вот у нас есть некий сжатый бор, и каждая
[17:44.520 --> 17:49.240]  позиция, там каждая вершина, по крайней мере, точно отвечает некоторые под строке. Но более того,
[17:49.240 --> 17:55.000]  в процессе чтения каких-то строк, начиная из корня, мы можем в момент времени находиться где-то
[17:55.000 --> 18:00.880]  посреди ребра. Да, вот, например, если я в этом боре прочитаю АА, то я закончу где-то вот здесь,
[18:01.120 --> 18:09.280]  и это не вершина, а просто какая-то позиция внутри ребра. Я не выделяю это как отдельную вершину,
[18:09.280 --> 18:15.000]  это просто позиция посреди ребра. Соответственно все позиции в дереве бьются на два типа. Во-первых,
[18:15.000 --> 18:20.880]  это просто вершины обычные, которые хранятся там как отдельные струк нод, из которых есть куча
[18:20.880 --> 18:26.320]  переходов. С ними все понятно, понятно как хранить. Но также есть позиции посреди ребра. Позиции,
[18:26.320 --> 18:37.400]  позиции внутри ребра, я так не пишу. И мы их будем в памяти, ну как бы, в реализации,
[18:37.400 --> 18:43.560]  сохраняя следующим образом. Значит, если есть ребро, на котором мы стоим, где-то вот здесь вот,
[18:43.560 --> 18:48.160]  где-то на какой-то его внутренней позиции, отличное вот начало и конца, потому что начало
[18:48.160 --> 18:55.400]  конца вершины, то тогда мы будем хранить. Это вот это вот первая вершина П в ребре, то есть то,
[18:55.400 --> 19:03.640]  откуда мы начинаем. Во-вторых, это первый символ А на этом ребре, потому что, как мы знаем,
[19:03.640 --> 19:11.280]  из вершины П все исходящие ребра имеют различные первые символы. Значит, чтобы как бы детерминировано
[19:11.280 --> 19:15.960]  выбрать именно это из тех исходящих из П, достаточно знать только первый символ. Не нужно знать всю
[19:15.960 --> 19:20.520]  подстроку, нужно знать только символ А. Ну и последнее, это то, сколько символов прочитано
[19:20.520 --> 19:40.360]  от начала строки. Ну как бы предок, да. Дальше А это первый символ на ребре, первый символ,
[19:40.360 --> 19:45.360]  ну и КАТА сколько символов прочитано.
[19:45.360 --> 19:51.520]  Сколько символов прочитано.
[20:07.520 --> 20:08.480]  Теперь дальше.
[20:15.480 --> 20:22.320]  Определение суффиксная ссылка. Значит, ну смотрите, мы поняли, что позиции в дереве это либо вершины,
[20:22.320 --> 20:27.160]  либо какие-то точки внутри ребра, и для каждой такой позиции можем определить суффиксную ссылку.
[20:27.160 --> 20:41.200]  Пусть В это позиция в дереве. Как обычно, мы все позиции можем отраждествить с строками,
[20:41.200 --> 20:46.960]  которые ведут из корня в эту позицию. То есть как так же, как у нас было в Боре, я буду перемешивать
[20:46.960 --> 20:52.480]  вот В временно, и позиция в дереве, и строка, которая ведет в эту позицию. То есть сколько
[20:52.480 --> 20:56.800]  есть тривиальная биекция между позициями и строками, которые ведут в эти позиции из корня,
[20:56.800 --> 21:03.080]  то я буду одной буквой это как бы обозначать то и то, и позицию, и саму строку. Так вот В позиция
[21:03.080 --> 21:08.200]  в дереве, то есть что-нибудь вот такое, например, да, какая-нибудь там позиция внутри ребра. И в то
[21:08.200 --> 21:16.800]  же время вот эта вот вся строка от корня до нее. Суффиксная ссылка это, как обычно, максимальный
[21:16.800 --> 21:27.000]  собственный суффикс строки В, который можно прочитать в Боре. Суффиксная ссылка линк от В,
[21:27.000 --> 21:52.120]  это, ну, допишем формально указатель на позицию, отвечающую максимальному собственному суффиксу В,
[21:52.120 --> 22:06.200]  который есть в Боре. Есть в Боре, то есть можно прочитать, начиная с корня, и закончить все в какой-то
[22:06.200 --> 22:16.280]  позиции дерева. Теперь у меня такой вопрос к вам. Вот смотрите, пусть В это какая-то позиция в дереве,
[22:16.280 --> 22:23.840]  соответственно, на некоторой строке. Некоторой подстроке исходной строки С. И мне нужно что? Мне
[22:23.840 --> 22:28.960]  нужно взять в этой строке максимальный собственный суффикс, который можно прочитать из корня. То есть
[22:28.960 --> 22:35.880]  суффикс максимальный по длине, но при этом отличный от самой строки В. Скажите, пожалуйста, что это за
[22:35.880 --> 22:58.520]  суффикс? Какая у него длина по сравнению с В? Длина какая тогда? Да, на один меньше. Да,
[22:58.520 --> 23:02.960]  действительно, все позиции в дереве это префикс суффикса, то есть на самом деле просто подстрока.
[23:02.960 --> 23:13.880]  А нет, сейчас. Ну да, потому что это одно и то же. Но главное, что раз у нас в Боре, по сути,
[23:13.880 --> 23:18.720]  представлены все суффиксы, то есть все префиксы всех суффиксов, то есть просто все подстроки,
[23:18.720 --> 23:24.720]  то значит, если я откушу всего лишь один фимал в начале строки В, то это тоже будет подстрока
[23:24.720 --> 23:30.080]  исходной строки С, а значит, ровно это и будет суффикс. Потому что среди всех собственных суффиксов
[23:30.080 --> 23:34.400]  это максималь, и он точно есть в Боре, потому что это меньше подстрока той же самой строки С.
[23:34.400 --> 23:43.840]  Раз В это подстрока, то и как бы меньше ее подстрока тоже подстрока С. Замечание, что линк от В всегда
[23:43.840 --> 24:03.720]  получается из В отбрасыванием первого символа. Вот такое соображение, что ссылка здесь,
[24:03.720 --> 24:08.720]  когда мы строим сух дерева на одной строке, это всегда отбрасывание одного символа. Не как было
[24:08.720 --> 24:13.840]  у нас в алгоритмах карасик, что это просто какой-то максимальный собственный суффикс. Здесь
[24:13.840 --> 24:17.400]  вот он ровно конкретно определен, это всегда отбрасывание всего одного символа.
[24:17.400 --> 24:38.880]  Отвержение. Ссылка вершины, вершина.
[24:47.400 --> 24:55.600]  В том смысле, что сувсылка у нас формально определена не только для вершин, но и для позиций в дереве,
[24:55.600 --> 25:01.000]  и казалось бы совсем не обязательно. Сувсылка вершины это обязательно вершина, потому что сувсылка
[25:01.000 --> 25:05.200]  вершины это просто некая позиция в дереве, которая вполне возможно может быть в позиции
[25:05.200 --> 25:11.800]  внутри ребра. Но это утверждение, если мы его докажем, скажет нам, что сувсылка вершины, да именно вершина,
[25:11.800 --> 25:20.360]  да не где-то позиция внутри ребра, а именно вершина. Ну доказательство будет следующим. Вообще,
[25:20.360 --> 25:24.920]  что только вершины в нашем дереве? Это либо листья, то есть те как бы точки, ниже которых
[25:24.920 --> 25:31.480]  никуда нельзя пойти, либо это точки, в которых возникает битвление, то есть есть как минимум
[25:31.480 --> 25:42.600]  два нисходящих ребра. Вершины все это либо листья, то есть точки, ниже которых вообще ничего нет,
[25:42.600 --> 25:55.640]  либо это вершины битвления. То есть те позиции в дереве, ниже которых есть по крайней мере два
[25:55.640 --> 26:01.320]  варианта куда пойти. Ну потому что иначе, если есть ровно один вариант, да если есть какая-то
[26:01.320 --> 26:09.240]  точка, ниже которой есть всего один вариант куда пойти, то значит на самом деле эта вершина
[26:09.240 --> 26:13.920]  проходная и можно было бы ее стянуть и сказать, что все вот это одно ребро без вот этой вершины.
[26:13.920 --> 26:23.600]  Ну окей, для формальности надо еще сказать, что есть корень иногда, да, корень на случай,
[26:23.600 --> 26:30.000]  если у нас ну как бы просто вот такое вот дерево. А вот корень, вот конец. Ну то есть это редко
[26:30.000 --> 26:38.560]  бывает, но иногда бывает. Да потому что еще раз иначе, если вершина не корень, у нее ровно потомок,
[26:38.560 --> 26:44.280]  то значит у нее есть родитель и можно было бы стянуть это ребро в одно и эта вершинка бы не
[26:44.280 --> 26:49.040]  была вершиной. Ну собственно нет никаких причин эту вершину в нашем вот сжатии не стянуть,
[26:49.040 --> 26:53.440]  она проходная, у нее сходящая и сходящая степень 1, мы ее стягиваем в одно длинное
[26:53.440 --> 26:58.560]  ребро и удаляем эту точку как вершину. Согласны? Вот.
[27:05.480 --> 27:10.200]  Давайте все-таки удалю корень, потому что корень никогда не может быть вершиной, потому что у него
[27:10.200 --> 27:15.120]  хотя бы из него есть хотя бы два разных исходящих символа, потому что есть всегда хотя бы один символ
[27:15.120 --> 27:22.080]  строки, есть всегда хотя бы хотя бы доллар, поэтому корень попадает вот сюда, это всегда вершина
[27:22.080 --> 27:34.960]  ветвления, мы ее как отдельную сущность удаляем. Ну вот, значит надо разобраться с листьями в первую
[27:34.960 --> 27:46.120]  очередь. Это ровно то, что соответствует суффиксам, то есть если я прочитаю слово ведущее из корни в
[27:46.120 --> 27:51.160]  некоторые лист, то я обязательно получу суффикс и наоборот, если я прочитал суффикс, то обязательно
[27:51.160 --> 27:57.720]  попаду в лист. Это обеспечивается за счет доллара, именно за счет доллара, потому что ну что такое
[27:58.320 --> 28:06.720]  какая-то такая точка, ниже которой пойти нельзя. Ну какой тогда был написан здесь последний символ,
[28:06.720 --> 28:11.760]  если тут написан не доллар, если последний символ на пути до листа не доллар, то ее точно можно
[28:11.760 --> 28:16.440]  продлить, да, потому что наша строка это что-то там что-то что-то что-то в конце доллар, значит если я
[28:16.440 --> 28:21.280]  здесь прочитал строчку без доллара, то ее гарантированно можно продолжить, ну как минимум долларом всегда,
[28:21.280 --> 28:25.600]  то есть там возможно что-то надо сначала прочитать, потом будет доллар, поэтому если у нас есть лист,
[28:25.600 --> 28:34.320]  то по суффиксу можно продлить. Иначе можно нашу нашу штучку продлить. А раз последний символ на пути это
[28:34.320 --> 28:41.200]  доллар, то значит это суффикс. Следовательно любой путь от корни до листа это суффикс. Ну и наоборот,
[28:41.200 --> 28:47.720]  если я прочитаю некоторый суффикс начиная из корня, то есть тут я взял лист и показал, чтобы пришли в
[28:47.720 --> 28:53.480]  суффикс, теперь пусть наоборот, я прочитал суффикс, тогда раз это суффикс, то я обязательно прочитал доллар в
[28:53.480 --> 29:00.240]  конце. И тогда это гарантированно лист, потому что дальше доллара идти нельзя. А значит наоборот,
[29:00.240 --> 29:07.400]  каждому суффиксу соответствует лист. Поэтому между ними есть тривиальная объекция, все листы
[29:07.400 --> 29:12.400]  соответствуют ровно суффиксам, и у них как раз таки все с суффислками очень просто. Потому что
[29:12.400 --> 29:19.400]  если мы рассмотрим позиции, отвечающие всем нашим суффиксам S0, S1, S2 и так далее, Sn-1, то они
[29:19.460 --> 29:25.100]  должны друг на дружку ссылатся. Как суффислки? Потому что это лист. Дальше, что такое суффсылка
[29:25.100 --> 29:29.620]  от этого листа? Это отборосленное первого символа, то есть просто вот эта эта вот вершинка. А это тоже
[29:29.620 --> 29:35.820]  лист. Суффсылка S1-то будет S2, потому что отборосленное первого символа и из S1 получается С2. Значит
[29:35.820 --> 29:41.300]  FDA идёт в лист. Ну и так далее. У нас будет вот такая вот последовательность.ซс- ссылок. То
[29:41.300 --> 29:46.400]  есть лист, они sends друг на дружку ссылаются в терминах суффсылки. Суффсылка от суффиксов. Это
[29:46.400 --> 29:50.600]  это чуть меньший суффикс длины на один меньше.
[29:50.600 --> 29:53.720]  Поэтому сувсылка листа это всегда либо лист, либо
[29:53.720 --> 29:59.240]  вот здесь в последнем эпизоде будет ссылка из s-n-1 в корень,
[29:59.240 --> 30:03.400]  потому что это строка, которая равна просто доллару,
[30:03.400 --> 30:05.680]  и сувсылка от этой штуки это просто пустая строка,
[30:05.680 --> 30:06.680]  то есть корень.
[30:06.680 --> 30:10.520]  Да, поэтому цепочка взять из сувсылки от самого длинного
[30:10.520 --> 30:13.740]  листа, от самого длинного суффикса, это по всем листьям
[30:13.740 --> 30:14.740]  и потом попадание в корень.
[30:14.740 --> 30:25.660]  Если я прочитал некий суффикс, начиная с корня, то я обязательно
[30:25.660 --> 30:28.140]  в конце прочитал доллар, потому что все суффиксы
[30:28.140 --> 30:32.460]  у меня кончаются на доллар, значит ниже отсюда я никуда
[30:32.460 --> 30:35.700]  пойти не могу, потому что нет ни одного, если я уже
[30:35.700 --> 30:39.460]  прочитал доллар, то ниже него ничего читать нельзя,
[30:39.460 --> 30:40.460]  значит это лист.
[30:40.460 --> 30:47.620]  Мы доказали, что сувсылка листьев это всегда либо
[30:47.620 --> 30:48.620]  листья, либо корень.
[30:48.620 --> 30:51.880]  Теперь осталось разбираться с вершинами ветвления,
[30:51.880 --> 30:54.020]  почему сувсылка вот такой вершины, это тоже вершина.
[30:54.020 --> 31:00.020]  Пусть есть вершина ветвления.
[31:00.020 --> 31:02.620]  Что это значит?
[31:02.620 --> 31:06.340]  Это значит, что мы как-то из корня читали некую строчку
[31:06.340 --> 31:10.420]  альфа, попали в вершину, а дальше из нее есть ветвление,
[31:10.420 --> 31:13.380]  ну как минимум, скажем, можно прочитать а и дальше
[31:13.380 --> 31:16.460]  что-то еще, а можно прочитать b и что-то еще, где а и b какие-то
[31:16.460 --> 31:17.460]  два разных символов.
[31:17.460 --> 31:20.700]  То есть вот была такая вершина ветвления.
[31:20.700 --> 31:22.900]  Что это значит в терминах нашей строки?
[31:22.900 --> 31:26.540]  Это означает, что в нашу исходную строчку с входит
[31:26.540 --> 31:29.860]  как под строки как минимум две следующие подстроки,
[31:29.860 --> 31:35.540]  альфа а и альфа б, ну потому что их можно просто прочитать
[31:35.540 --> 31:38.100]  из корня, а все что можно прочитать из корня это в
[31:38.260 --> 31:40.380]  подстроке нашей строки.
[31:40.380 --> 31:42.780]  Вот есть такие строки в нашей строке.
[31:42.780 --> 31:46.300]  Дальше, чтобы взять всу всылку вершины вот этой вот альфа,
[31:46.300 --> 31:49.100]  чтобы взять всу всылку от этой точки, мне нужно
[31:49.100 --> 31:54.620]  отбросить первый символ из альфа и понять, какая
[31:54.620 --> 31:55.620]  будет позиция в дереве.
[31:55.620 --> 31:58.340]  Ну давайте я отброшу и скажу, что это какая-то бета,
[31:58.340 --> 32:01.020]  вот эта вот бета, вот эта бета соответственно и вот
[32:01.020 --> 32:03.180]  эта бета.
[32:03.180 --> 32:09.260]  Ну тогда извините, бета а и бета б тем более будут
[32:09.260 --> 32:11.980]  под строками нашей исходной строки, а значит после бета
[32:11.980 --> 32:14.260]  есть ветвление, значит бета это вершина.
[32:14.260 --> 32:21.740]  Ну то есть еще раз, если альфа это вершина, то альфа
[32:21.740 --> 32:27.540]  а и альфа б это под строки с, под строки с, ну я имею
[32:27.540 --> 32:32.060]  в виду вершины ветвления здесь, потом если бета это
[32:32.060 --> 32:35.460]  линк от альфа, то есть ее всылка, то есть строка
[32:35.460 --> 32:39.580]  получающейся отбрасыванием одного символа, то тогда
[32:39.580 --> 32:44.260]  тем более бета а и бета б это тоже под строки с,
[32:44.260 --> 32:47.340]  под строки с, ну потому что я отбросил один символ
[32:47.340 --> 32:50.460]  из начала этих строк, это конечно под строки остались.
[32:50.460 --> 32:53.980]  Ну значит бета это опять вершина ветвления, бета
[32:53.980 --> 32:57.700]  это вершина ветвления, потому что после нее есть два
[32:57.700 --> 33:00.060]  разных как бы продолжения, можно читать а, можно читать
[33:00.860 --> 33:03.620]  поэтому если я б, то как ты прочитал из корня, то
[33:03.620 --> 33:06.860]  гарантированно здесь есть вот развилка, влево скажем
[33:06.860 --> 33:09.580]  можно читать а и что-то еще, а вправо б и что-то еще,
[33:09.580 --> 33:11.860]  возможно появляются еще какие-то новые ребра, которых
[33:11.860 --> 33:14.540]  там не было, но главное по крайней мере два ветвления
[33:14.540 --> 33:18.460]  здесь есть, поэтому это точно вершина, она не сжалась,
[33:18.460 --> 33:21.500]  она не проходная и это будет как бы ну вот точка в нашем
[33:21.500 --> 33:28.940]  дереве, вершина, вот, поэтому вершина ветвления это вершина
[33:28.940 --> 33:53.300]  ветвления, ну то есть вершина, окей, да, ну окей, давайте
[33:53.380 --> 34:00.500]  тогда теперь будем считать, будем считать, что если в
[34:00.500 --> 34:06.820]  дереве есть вершина, то мы знаем у нее ссылку, если
[34:07.380 --> 34:27.780]  дереве, есть вершина В, нам известна линка В, мы будем
[34:27.780 --> 34:37.860]  вместить с каждой вершиной хранить ее сувсылку, теперь
[34:37.860 --> 34:41.860]  если мы знаем, где находится сувсылка для любой вершины
[34:41.860 --> 34:47.060]  В, то давайте научимся находить сувсылку для любой позиции
[34:47.060 --> 34:52.220]  в дереве, то есть скажем сувсылки вершин мы храним, нам тогда
[34:52.220 --> 34:55.340]  еще нужно вместить сувсылку, ну находить сувсылки для
[34:55.340 --> 34:59.020]  позиций на ребре, а вот у меня позиция где-то на
[34:59.020 --> 35:04.460]  ребре, напоминаю, задаваемая тремя параметрами P, A и K, мне
[35:04.460 --> 35:09.420]  нужно для вот этой вот позиции найти сувсылку, ну давайте
[35:09.420 --> 35:20.620]  я это назову процедура GetLink, GetLink, ну так я назову это
[35:20.700 --> 35:29.420]  поз, позиция где-то на ребре, я хочу найти сувсылку, ну
[35:29.420 --> 35:34.660]  здесь ничего хитрого нет, в случае если P это не корень,
[35:34.660 --> 35:36.820]  то нужно просто взять сувсылку для P, а дальше прочитать
[35:36.820 --> 35:47.820]  те же самые K символы, значит случай 1, P не корень, тогда
[35:47.820 --> 35:52.060]  картинка будет такая, вот есть некий путь до P, потом
[35:52.060 --> 35:58.660]  есть длинное вот такое вибро, мы прочитали на нем K символов,
[35:58.660 --> 36:01.140]  тогда чтобы взять сувсылку для этой позиции, давайте
[36:01.140 --> 36:04.700]  я не буду выделять жирный, точку просто поставлю,
[36:04.700 --> 36:08.120]  значит чтобы найти сувсылку для этой позиции мне нужно
[36:08.120 --> 36:10.180]  взять всю вот эту длинную строчку и отбросить первый
[36:10.180 --> 36:13.620]  символ, но это то же самое, что отбросить первый символ
[36:13.620 --> 36:16.980]  вот этой строки от корня до P, а потом вот эти K символов
[36:16.980 --> 36:20.340]  прочитать, потому что все равно мне нужно отсюда
[36:20.340 --> 36:22.580]  отбросить один символ, это то же самое, что если я
[36:22.580 --> 36:25.980]  его отброшу сначала, прочитаю вот это, как сувсылку P, и
[36:25.980 --> 36:29.260]  потом дочитаю вот эти K символы, то есть в таком
[36:29.260 --> 36:34.180]  случае, если P не корень, я нахожу вершину, которая
[36:34.180 --> 36:37.740]  у меня уже известна, link от P, раз P это вершина, то
[36:37.740 --> 36:40.420]  link от P тоже вершина, которая у меня хранится где-то, вот
[36:40.420 --> 36:43.540]  я считаю, что я ее где-то сохранил, я знаю link от P,
[36:43.540 --> 36:47.020]  дальше мне нужно вот эти K символов прочитать, дальше
[36:47.020 --> 36:50.580]  мне нужно вот эти K символов как-то прочитать, ну и давайте
[36:50.580 --> 36:55.820]  я здесь это так и сделаю, как-то эти K символов читаю,
[36:55.820 --> 36:59.860]  но здесь может быть проблема в том, что даже если раньше
[36:59.860 --> 37:02.780]  эти K символы лежали все целиком на одном ребре,
[37:02.780 --> 37:06.720]  то здесь они уже могут начать витвиться, и эти K символы
[37:06.720 --> 37:09.300]  возможно лежат не на одном ребре, а на нескольких, то
[37:09.300 --> 37:11.980]  есть мне нужно сначала там wtькому б ор едно ребро,
[37:11.980 --> 37:15.820]  второе, третье, четвертое и так далее. И вот где-то в конце я где-то закончусь.
[37:15.820 --> 37:22.260]  То есть даже если раньше ко символов были как бы под строкой одного ребра, то при
[37:22.260 --> 37:26.380]  переходе к су-всылке вполне возможно, что это ребро как-то расщепляется. Ну потому что вот я
[37:26.380 --> 37:30.820]  там рисовал, что когда я перехожу к су-всылке, у меня могут возникать новые витвления. Значит,
[37:30.820 --> 37:35.580]  это ребро могло как-то там очень сильно под расщепиться, и для чтения этих ко символов мне
[37:35.580 --> 37:41.860]  возможно придется пройти много ребер. Ну что поделать, так и сделаем. Вот читаем эти ко символов,
[37:41.860 --> 37:48.980]  столько сколько нужно, пока не попадем в ту самую позицию, которая отвечает су-всылке для вот этой
[37:48.980 --> 37:59.300]  позиции поз. Поз – это линк от поз. Значит, в этом случае мы просто смотрим линк от П и читаем те же
[37:59.300 --> 38:12.740]  самые ко символов. Читаем те же ко символов. Скажите, пожалуйста, какое будет время работы
[38:12.740 --> 38:25.620]  вот этой процедуры чтения вот этих ко символов? Вот чего? Ну вот как можно точнее. Понятно, что это
[38:25.620 --> 38:37.020]  от n, потому что в принципе… Ну давай считаем, что у нас алфавит константный, размер. Ну там 26
[38:37.020 --> 38:50.940]  символов. Можно лучше. Ну еще раз. Сигма к, если сигма констант, то просто к. Логарифм не умею.
[38:50.940 --> 38:55.940]  А, логарифм, я понял. Да, ну еще раз. Если сигма констант, то сигма и логарифм сигма – это все единица.
[38:55.940 --> 39:02.060]  Ну тут на самом деле не закам. Здесь быстрее, чем закам на самом деле. Потому что вот это чтение,
[39:02.060 --> 39:07.260]  ну то есть понятно, что к – это верхнее ограничение, но на самом деле время работы вот этой процедуры,
[39:07.260 --> 39:12.860]  этого куска процедуры, оно пропорционально просто числу ребер, который я прохожу. Почему, да,
[39:12.860 --> 39:18.220]  почему не нужно каждый символ по отдельности читать? Ну, не знаю, давайте… Здесь было написано какая-то
[39:18.220 --> 39:24.340]  подстрока, скажем, с L по R, и здесь я читаю первый k символов. Тогда как просчитать те же k символов
[39:24.340 --> 39:31.420]  вот здесь? Смотрите, я знаю символ SLT. Соответственно, из этой вершины я нахожу ребро, которое начинается
[39:31.420 --> 39:38.620]  на то же самое SLT. Вот оно, да, у меня нарисовано. Тогда я точно могу сказать, что если длина этого
[39:38.620 --> 39:43.380]  ребра меньше, чем k, то я могу не читать все символы по одному вот здесь вот и вот здесь вот синхронно,
[39:43.380 --> 39:49.860]  а сразу перепрыгнуть вот сюда и вот сюда, конец этого ребра. Да, ну потому что если как бы здесь
[39:49.860 --> 39:56.980]  строка начинается на SL, она однозначно так определена, да, вот это вот все, и здесь тоже строка,
[39:56.980 --> 40:01.740]  которая начинается на SL, как-то вот так вот идет, то понятно, что символы следующие за SL там будут
[40:01.740 --> 40:06.100]  одинаковы. Нет смысла их перепроверять, потому что, как бы, если есть такой путь, то есть и такой путь,
[40:06.100 --> 40:10.740]  а раз нет лицеления, значит, ну просто однозначно у нас все определено. Если тут первые символы
[40:10.740 --> 40:15.620]  совпадают, то значит и вот это вот все тоже совпадает. Поэтому нет смысла все вот эти символы по одному
[40:15.620 --> 40:22.620]  перебирать. Достаточно посмотреть только на первый. Если они совпадают и длина этого меньше, чем мне
[40:22.620 --> 40:26.820]  нужно пропрыгать, то я просто сразу телепортируюсь в конец ребра. Я не перебираю по одному символу,
[40:26.820 --> 40:31.980]  а сразу туда перемещаюсь. Дальше. Я стою здесь и вот здесь. Опять знаю, какой мне нужно перешать
[40:31.980 --> 40:36.700]  следующий символ, нахожу его среди исходящих ребер и сразу перемещаюсь в конец ребра и здесь
[40:36.700 --> 40:41.520]  тоже делаю какой-то прыжок. Ну и в конце, когда я нахожу ребро, длина которого больше, чем мне
[40:41.520 --> 40:48.620]  нужно, а остаток вот К, то я просто перемещаюсь там, делаю плюс К и здесь вот встаю в позицию посреди
[40:48.620 --> 40:59.380]  ребра. То есть тогда на самом деле время работы этой процедуры, время работы, есть О от числа
[40:59.380 --> 41:17.980]  просмотренных ребер. Число просмотренных, просмотренных ребер. Давайте, давайте картинку нарисую.
[41:29.380 --> 41:50.580]  Итак, мне нужно отсюда прочитать вот эти К символы. Для этого я смотрю на первый символ здесь. Я знаю,
[41:50.580 --> 41:56.180]  что это, это какой-то символ нашей строки. Отсюда я нахожу исходящий ребро, начинающийся на тот же
[41:56.180 --> 42:02.820]  символ. Ну скажем, вот оно какое-то такое. Если его длина меньше либо равнока, то я сразу
[42:02.820 --> 42:07.540]  телепортируюсь в конец этого ребра здесь, а здесь я телепортируюсь, ну собственно, на длину этого ребра.
[42:07.540 --> 42:22.460]  Еще раз. Ну конечно, да, конечно. Если вот это вот, это под строка, то есть это путь в боре,
[42:22.460 --> 42:27.140]  значит это под строка, тогда когда я отбрасываю первый символ, то это конечно тоже будет под строка,
[42:27.140 --> 42:32.020]  она читается в боре. И более того, если первые символы здесь совпадают, и здесь нет выцеления,
[42:32.020 --> 42:35.460]  значит здесь просто единственное возможное продолжение, которое совпадает с тем, что тут
[42:35.460 --> 42:40.340]  написано. Поэтому эти символы можно даже не проверять. Вот, ну и тогда все. Я просто прочитал
[42:40.340 --> 42:45.260]  целом это ребро за один шаг, и указатель отсюда переместил вот сюда. Теперь я нахожусь в этой
[42:45.260 --> 42:50.020]  вершинке, вижу некую следующую букву, которую нужно прочитать, нахожу ребро, начинающийся на ту
[42:50.020 --> 42:55.300]  же самую букву, читаю его целиком это ребро, ну и соответственно телепортируюсь в какую-то позицию
[42:55.300 --> 43:01.980]  на вот этом исходном ребре. Тогда время работает, просто то, сколько ребер я прошел.
[43:01.980 --> 43:16.220]  Ну, а второй случай, когда p это корень, тут собственно все,
[43:16.220 --> 43:32.420]  когда ситуация такая, есть корень, есть некое вот такое ребро, я читаю на нем по символов,
[43:32.420 --> 43:37.700]  нахожусь где-то вот здесь, мне нужно взять всю всылку от этой позиции. Ну, то же самое,
[43:37.700 --> 43:43.780]  только мне нужно теперь читать не вот эту строчку, а вот эту строчку. А поскольку я не
[43:43.820 --> 43:47.700]  могу взять всю всылку от корня, то нужно просто отбросить первый символ и прочитать
[43:47.700 --> 44:01.940]  вот такую строчку из корня. Прочитать эту строчку из корня. А читать строку из вершины мы уже умеем.
[44:01.940 --> 44:07.180]  Вот у нас была процедура, мы стоим в вершине, мне нужно прочитать некую подстрочку. Опять нахожу
[44:07.180 --> 44:11.160]  первый символ, иду на длину ребра, потом
[44:11.160 --> 44:13.840]  телепортируюсь сюда, читаю следующий
[44:13.840 --> 44:15.600]  ребро целиком, ну и в общем точно так же
[44:15.600 --> 44:17.200]  будет, да, мы несколько ребра прочитали и
[44:17.200 --> 44:20.600]  где-то там опять встали посреди ребра.
[44:23.600 --> 44:26.760]  Вот, опять-таки время работы здесь будет
[44:26.760 --> 44:28.320]  пропорциональностью ребра, которое я
[44:28.320 --> 44:29.960]  прошел, потому что каждое ребро обрабатывается
[44:29.960 --> 44:34.040]  за вот единицы. Ну не буду переписывать,
[44:34.060 --> 44:37.060]  ассоциативная дотика такая же.
[44:38.500 --> 44:40.140]  Так, ну и теперь вроде у нас все готово к
[44:40.140 --> 44:43.620]  тому, чтобы написать алгоритм Мукунина.
[44:53.340 --> 44:56.820]  Устроение сувдерева
[44:59.420 --> 45:02.420]  за линейное время.
[45:04.040 --> 45:18.940]  Уконин, Ук-Конин, то ли швед, то ли норвежец, что-то такое.
[45:26.660 --> 45:29.620]  Не совсем, не совсем, это у нас будет
[45:29.620 --> 45:33.340]  внутри алгоритма, мы поймем, как это сделаем.
[45:34.740 --> 45:38.020]  Так, значит последняя теоретическая
[45:38.020 --> 45:41.420]  вставка следующая. Давайте рассмотрим вот,
[45:41.420 --> 45:43.040]  пусть у меня построено сувдерев в какой-то
[45:43.040 --> 45:47.740]  момент, в какой-то момент нашего, не так, не так, не так.
[45:47.740 --> 45:50.820]  Как работал Ритм Уконина? Он будет нашу строчку
[45:50.820 --> 45:54.460]  расширять по одному символу, право, и как бы
[45:54.460 --> 45:56.620]  для каждого префикса индуктивно строить
[45:56.620 --> 45:58.580]  текущую версию сувдерева. То есть для
[45:58.580 --> 46:00.700]  этой штуки построил сувдерева, молодец,
[46:00.700 --> 46:02.660]  потом взял следующий символ, перестроил
[46:02.660 --> 46:04.660]  сувдерева, получился сувдерева для большей строки и так далее.
[46:04.660 --> 46:06.640]  То есть он наращивает по одному символу
[46:06.640 --> 46:09.160]  нашу строчку и меняется в дерево.
[46:09.160 --> 46:16.640]  То есть ЭД-С, который запускается при
[46:16.640 --> 46:18.520]  прочтении каждого нового символа, ЭД-С.
[46:18.520 --> 46:21.640]  Прочитали символ, запустили ЭД с этим символом.
[46:23.640 --> 46:27.640]  Так вот, давайте посмотрим на
[46:30.640 --> 46:32.360]  нашу строчку в какой-то момент, когда я
[46:32.360 --> 46:35.020]  прочитал, скажем, символы С0 по СИ и
[46:35.020 --> 46:37.340]  построил для них сувдерева, а дальше
[46:37.340 --> 46:39.940]  приходит символ С.
[46:40.940 --> 46:45.780]  Тогда я утверждаю, что все позиции,
[46:45.780 --> 46:48.860]  отвечающие суффиксом, сейчас, да, все
[46:48.860 --> 46:50.580]  позиции, отвечающие суффиксом сувдерева
[46:50.580 --> 46:52.460]  в этот момент времени, то есть до того, как я его
[46:52.460 --> 46:54.180]  начал перестраивать, бьются на три
[46:54.180 --> 46:56.380]  категории. Значит, во-первых, это позиции,
[46:56.380 --> 47:00.060]  которые являются листьями. Будет первая
[47:00.060 --> 47:05.880]  категория листья. То есть такие позиции в
[47:05.880 --> 47:07.280]  дереве, которые одновременно листья и
[47:07.280 --> 47:10.720]  суффиксы вот этой вот строки с С0 по СИ.
[47:10.720 --> 47:15.160]  Дальше будет вторая категория позиций.
[47:15.160 --> 47:18.080]  Это не листья, из которых нет перехода
[47:18.080 --> 47:26.880]  по С. Не листья без перехода по С, без
[47:26.880 --> 47:33.080]  перехода по С. Ну и третья категория, это не
[47:33.080 --> 47:37.080]  листья, из которых есть переход по С.
[47:38.080 --> 47:47.880]  Не листья с переходом по С. То есть, если у меня
[47:47.880 --> 47:49.440]  построено корректное суффиксное дерево
[47:49.440 --> 47:52.320]  для вот такой строки,
[47:52.720 --> 47:56.360]  в позициях пока.
[47:58.060 --> 48:00.620]  Нет, именно вот для этого построено малого.
[48:00.620 --> 48:02.780]  Если у меня есть построенное
[48:02.780 --> 48:04.360]  сувдерево в этот момент времени,
[48:04.360 --> 48:06.200]  пока я не знаю, что происходило дальше,
[48:06.200 --> 48:07.760]  я предположу, что корректное сувдерево
[48:07.760 --> 48:09.260]  для вот этой штуки.
[48:09.260 --> 48:11.520]  Так вот здесь когда я рассматриваю
[48:11.520 --> 48:13.740]  все позиции, отвечающие всем суффиксам
[48:13.740 --> 48:14.920]  этой текущей версии моей строки,
[48:14.920 --> 48:16.420]  то есть все вот этиią
[48:16.420 --> 48:19.340]  строки, все суффиксы здесь,
[48:19.340 --> 48:22.120]  эти позиции бьются на три категории.
[48:22.120 --> 48:30.400]  1 и третья позиции листья дальше позиции не листья без новой символу c и не листья с переходом по c
[48:33.160 --> 48:40.320]  причем эти позиции именно вот в таком вот порядке убывания длины расположены то есть в первой категории находится несколько самых длинных суффиксов
[48:40.840 --> 48:46.520]  то есть скажем вся строка соснули по s и ее там ну вот это и несколько суффиксов
[48:47.080 --> 48:49.880]  дальше подряд идут несколько не листьев без перехода по ц
[48:50.720 --> 48:53.040]  опять в порядке убывания длины несколько подряд и
[48:53.680 --> 48:58.060]  потом в конце самые несколько коротких суффиксов это не листья с переходом по ц
[48:59.720 --> 49:05.440]  опять подряд несколько самых коротких значит почему подряд почему все идут в порядке убывания длины
[49:13.360 --> 49:17.120]  ну последующую причине значит рассмотрим рассмотрим
[49:20.720 --> 49:22.720]  самый короткий
[49:27.760 --> 49:32.640]  отвечаешь листу отвечаешь листу вот в этом дереве
[49:41.560 --> 49:43.560]  тогда те более длинные тоже точно листы
[49:44.280 --> 49:47.760]  потому что если есть какой-то более длинный суффикс с ветвлением
[49:48.760 --> 49:55.160]  да ну или вообще просто с прочтением чего-то вниз то тогда это же самое можно было прочитать вот здесь это соответственно было бы не лист
[49:56.840 --> 50:01.980]  потому что еще раз если это более длинная строка то есть окей давайте вот скажем это некий суффикс там с
[50:02.560 --> 50:03.880]  житая
[50:03.880 --> 50:07.700]  вот такой суффикс сж если есть некий больший суффикс с
[50:08.280 --> 50:10.280]  мт
[50:10.400 --> 50:12.400]  вот такой
[50:12.600 --> 50:18.760]  внизу куда можно что-то прочитать то есть не являешься листом то есть справа от см есть там ко election well x который можно прочитать
[50:18.880 --> 50:23.040]  и тогда его же можно было candle сж на потому что neuver
[50:23.920 --> 50:29.940]  расширение влево строки sg значит тот же сам из можно было были Calm мнеbridge это не могло быть суффикс с Morgan
[50:30.940 --> 50:34.980]  если это лист то здесь ничего не может быть иначе здесь staring можно было прочитать
[50:36.640 --> 50:41.800]  тем самым если я взял самый короткий суффикс отвечающую листу то все более длинные тоже листье
[50:42.400 --> 50:54.920]  Тогда все более длинные суффиксы тоже отвечают
[50:54.920 --> 50:55.920]  листьям.
[50:55.920 --> 51:06.080]  Окей?
[51:06.080 --> 51:08.720]  Поэтому первая категория это точно несколько самых
[51:08.720 --> 51:09.720]  длинных суффиксов.
[51:09.720 --> 51:12.920]  Начиная с самого короткого, а потом все больше длинных.
[51:12.920 --> 51:14.920]  Несколько последних – это обязательно листья.
[51:14.920 --> 51:15.920]  Первая категория.
[51:15.920 --> 51:16.920]  Значит, третья категория возьмем.
[51:16.920 --> 51:17.920]  Возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:17.920 --> 51:18.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:18.920 --> 51:19.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:19.920 --> 51:20.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:20.920 --> 51:22.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:22.920 --> 51:24.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:24.920 --> 51:25.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:25.920 --> 51:26.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:26.920 --> 51:27.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:27.920 --> 51:28.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:28.920 --> 51:29.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:29.920 --> 51:30.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:30.920 --> 51:31.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:31.920 --> 51:32.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:32.920 --> 51:33.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:33.920 --> 51:34.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:34.920 --> 51:35.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:35.920 --> 51:36.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:36.920 --> 51:37.920]  возьмем, возьмем, возьмем, возьмем, возьмем,
[51:37.920 --> 51:38.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:38.920 --> 51:39.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:39.920 --> 51:40.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:40.920 --> 51:41.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:41.920 --> 51:42.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[51:42.920 --> 51:43.920]  возьмем, возьмем, возьмем, возьмем, возьмем,
[52:13.920 --> 52:14.920]  возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
[52:14.920 --> 52:15.920]  возьмем, возьмем, возьмем, возьмем, возьмем,
[52:16.920 --> 52:19.360]  Ну он автоматически будет не лист, поскольку из него
[52:19.360 --> 52:22.000]  есть переход по С, но давайте это все равно напишу, отвечающий
[52:22.000 --> 52:28.480]  не листу, из которого есть переход по С, из которого
[52:28.480 --> 52:35.440]  есть переход по С. Вот это какой-то суффикс, ну точнее,
[52:35.440 --> 52:38.520]  вот это какая-то позиция в дереве такая, что внизу
[52:38.520 --> 52:40.920]  есть буква в КС, то есть можно из этой позиции непосредственно
[52:40.920 --> 52:46.920]  прочитать буквы С. Тогда, если это СГ, то любой другой
[52:46.920 --> 52:55.640]  более короткий суффикс СТ, конечно, тоже продолжается
[52:55.640 --> 52:58.400]  буквой С, потому что если после СГ можно было прочитать
[52:58.400 --> 53:01.600]  С, то после любого более короткого суффикса СТ тоже
[53:01.600 --> 53:04.360]  можно подавно прочитать С. Значит все более короткие
[53:04.360 --> 53:08.480]  суффиксы тоже имеют продолжение буквой С. Значит все более
[53:08.480 --> 53:11.000]  короткие вновь не листья, из которых есть переход
[53:11.000 --> 53:23.400]  по С. Тогда все более короткие суффиксы, такие же я напишу,
[53:23.400 --> 53:26.240]  такие же, то есть это вновь не листья, из которых есть
[53:26.240 --> 53:31.280]  переход по С. Значит третья категория это именно что
[53:31.280 --> 53:34.240]  несколько самых коротких по длине суффиксов подряд
[53:34.240 --> 53:37.040]  идущих. То есть если вот это, то что у меня там было
[53:37.040 --> 53:40.320]  написано СГ, длинные из третьей категории, то все
[53:40.320 --> 53:50.440]  более короткие тоже из третьей категории. Смотрите,
[53:50.440 --> 53:53.160]  это суффикс вот в этот момент времени. Когда я дойду
[53:53.160 --> 53:56.160]  до Саиды и пишу доллар, это будет лист, но пока у
[53:56.160 --> 53:59.840]  меня здесь бывает фитствление, пока я не доллар, то у нас
[53:59.840 --> 54:03.120]  не работает, что суффикс это лист обязательно. Ну и
[54:03.120 --> 54:04.800]  так, что у нас получилось? У нас получилось, что несколько
[54:04.800 --> 54:07.560]  самых длинных суффиксов отвечают листьям, несколько
[54:07.560 --> 54:09.740]  самых коротких отвечают не листьям с переходом
[54:09.740 --> 54:12.880]  по С, но значит все, что между ними, опять некий
[54:12.880 --> 54:16.000]  отрезок внутри, это не это и не это, то есть не листья
[54:16.000 --> 54:20.000]  без перехода по С. Все разбилось на три категории в порядке
[54:20.000 --> 54:22.960]  убывания длины. На каждой категории это отрезок суффиксов.
[54:22.960 --> 54:35.280]  Что может быть? Да, грубо говоря, может быть что-то
[54:35.280 --> 54:37.600]  вот такое, вы имеете в виду, что есть позиция третьей
[54:37.600 --> 54:41.640]  категории и внизу она же первой категории. Да, может
[54:41.640 --> 54:46.640]  быть, вот эта картинка, она не очень информативная,
[54:46.640 --> 54:49.400]  тут я как бы все вот так вот растащил, то есть я считаю,
[54:49.400 --> 54:51.700]  что вот эта-то отдельно первая, а эту я отдельно перерисовал
[54:51.700 --> 54:53.700]  как третью. То есть это не совсем суфф-дерево, а вот
[54:53.700 --> 54:57.300]  именно, что я все... Ну короче, правильное замечание, да,
[54:57.300 --> 55:01.500]  но тут я нарисовал именно, что я разнес все суффиксы
[55:01.500 --> 55:05.340]  по отдельным как бы веточкам и разложил их по категориям.
[55:05.340 --> 55:07.380]  Но главное, тут не столько картинка важна, сколько
[55:07.380 --> 55:09.900]  вот этого понимания, что несколько самых длинных
[55:09.900 --> 55:12.820]  листьев, несколько самых коротких не листьев с переходом,
[55:12.820 --> 55:19.060]  а все остальное это вот без перехода. Картинка
[55:19.060 --> 55:42.460]  там весьма условная. Так, что мы сделали? Построение
[55:42.460 --> 55:52.700]  суфф-дерева. А, ну да. Хорошо, мы поняли, что если суфф-дерево
[55:52.700 --> 55:55.580]  выглядит как-то так, то все развелось на три категории.
[55:55.580 --> 55:58.460]  Дальше, что происходит с суфф-деревом, когда добавляется
[55:58.460 --> 56:03.260]  новый символ c? Как оно должно поменяться? Ну, по сути,
[56:03.260 --> 56:05.620]  да, у меня вот здесь вот были как бы нарисованы позиции
[56:05.620 --> 56:09.380]  всех суффиксов. Вот эти все точки – это позиции всех
[56:09.380 --> 56:13.140]  суффиксов в нашем текущем суфф-дереве. Когда я дописываю
[56:13.140 --> 56:16.340]  к нашей строке символ c, то по сути все, что мне нужно
[56:16.340 --> 56:19.300]  сделать – это ко всем нашим суффиксам дописать символ
[56:19.300 --> 56:22.500]  c. Потому что вот все суффиксы автоматически продлились
[56:22.500 --> 56:26.260]  буковкой c. Плюс еще появился суффикс пустая строка.
[56:26.260 --> 56:28.940]  Потому что если здесь была пустая строка, то нам продлилось
[56:28.940 --> 56:32.180]  символ c, стало опять суффикс. Ну, еще появился суффикс
[56:32.180 --> 56:37.100]  пустой, отвечающий корнем. То есть, по сути, чтобы добавить
[56:37.100 --> 56:40.940]  новый символ к уже имеющемуся суфф-дереву, мне нужно просто
[56:40.940 --> 56:45.660]  все суффиксы как бы спустить вниз по букве c. Потому что
[56:45.660 --> 56:50.820]  они просто расширились с буквой c. Нужно каждый
[56:50.820 --> 56:55.420]  суффикс преобразовать в то же самое, только спустить
[56:55.420 --> 56:59.980]  суффикс вниз по букве c. В этом смысле давайте напишу,
[56:59.980 --> 57:13.940]  что нам нужно спустить из всех суффиксов терминальность
[57:13.940 --> 57:27.300]  вниз по букве c. Такое корявое предложение, которое подразумевает
[57:28.300 --> 57:30.660]  все, что было раньше суффиксом, то есть как бы было помещено
[57:30.660 --> 57:33.900]  терминальные позиции в дереве, сейчас перестает быть
[57:33.900 --> 57:36.500]  суффиксом и нужно как бы вот эту терминальность,
[57:36.500 --> 57:38.500]  которая здесь была написана, вот здесь было написано
[57:38.500 --> 57:41.300]  терм, то есть это суффикс, терминальная позиция. Мне
[57:41.300 --> 57:43.900]  нужно эту терминальность обменить и спустить ее
[57:43.900 --> 57:46.180]  вниз по букве c. И теперь помещу вот эта терминальная
[57:46.180 --> 57:50.500]  позиция. Она отвечает суффиксу. Потому что это уже не суффикс,
[57:50.500 --> 57:55.100]  только после расширения на c это будет суффикс. Ну,
[57:55.100 --> 57:58.700]  то есть это как бы что по сути происходит. На самом
[57:58.700 --> 58:00.100]  деле в самом алгоритме мы терминальности поддерживать
[58:00.100 --> 58:03.700]  не будем, потому что они будут не нужны по дороге,
[58:03.700 --> 58:05.300]  а в конце их восстановить будет очень просто, мы еще
[58:05.300 --> 58:13.100]  до этого дойдем. В алгоритме не храним лаги терминальности.
[58:13.100 --> 58:26.500]  То есть вот это вот терм мы нигде не будем помечать,
[58:26.500 --> 58:28.700]  мы его проставим в самом конце. Но по сути ровно это
[58:28.700 --> 58:30.600]  нам нужно сделать, что все вершины, которые раньше,
[58:30.600 --> 58:32.900]  все позиции, которые раньше отвечали суффиксом, нужно
[58:32.900 --> 58:39.300]  вниз спустить как бы на c. Вот. С первой категорией
[58:39.300 --> 58:44.900]  это делать в прочь простого. Первая категория это листья,
[58:44.900 --> 58:50.500]  вершины точкой помеченные. И мне нужно как бы отменить
[58:50.500 --> 58:53.900]  их терминальность, нарисовать вниз переход по c и терминальность
[58:53.900 --> 58:59.100]  перенести как бы вот сюда. Вот. Ну а с учетом того, что
[58:59.100 --> 59:01.700]  это был лист, то эта вершина будет проходная и по сути
[59:01.700 --> 59:04.300]  мне нужно будет просто продлить длину этого рябра. На один
[59:05.300 --> 59:09.600]  вниз. И скажешь, что теперь вот это будет конец нашего
[59:09.600 --> 59:14.700]  рябра. Более того, эта же самая процедура будет
[59:14.700 --> 59:18.300]  происходить на всех последующих итерациях. Потому что когда
[59:18.300 --> 59:20.600]  я буду дальше дописывать мою строчку новыми и новыми
[59:20.600 --> 59:23.700]  символами, у меня будет происходить то же самое.
[59:23.700 --> 59:26.900]  Вот есть вершина, она лист, и мне нужно будет ее вниз
[59:26.900 --> 59:29.700]  все время продлевать на новые буквы. Там d, e, f и так далее.
[59:29.700 --> 59:33.100]  И все время, если раньше это было листом, то он теперь
[59:33.100 --> 59:35.100]  тоже будет оставаться листом. Просто потому что я
[59:35.100 --> 59:38.900]  пририсовал к листу, и оно остается всегда листом,
[59:38.900 --> 59:41.100]  я соответственно предыдущую вершину сжимаю как проходную.
[59:41.100 --> 59:46.300]  Поэтому, если вершина в какой-то момент попала в первую
[59:46.300 --> 59:49.900]  категорию, то ее дальнейшая судьба тривиальна. Она
[59:49.900 --> 59:52.500]  всегда вот так вот будет по одной продлеваться вниз
[59:52.500 --> 59:55.900]  и все время сжиматься как проходная. Поэтому вместо
[59:55.900 --> 59:58.700]  того, чтобы делать это по одному разу, каждый раз
[59:58.700 --> 01:00:01.800]  для каждого нового символа, я сразу, как только вершина
[01:00:01.800 --> 01:00:07.200]  стала листом, как только v стала листом, я сразу ее
[01:00:07.200 --> 01:00:10.600]  продлю прямо до конца стрельбы, прямо до доллара. Посмотрю
[01:00:10.600 --> 01:00:14.400]  в будущем, скажем, вот здесь, в какой-то момент времени
[01:00:14.400 --> 01:00:17.400]  v стала листом. Тогда я понимаю, что все, что будет дальше
[01:00:17.400 --> 01:00:19.400]  вплоть до доллара, будет просто спускать терминальность
[01:00:19.400 --> 01:00:23.000]  на 1 вниз по одному ребру. И чтобы это не делать для
[01:00:23.000 --> 01:00:25.800]  каждого символа отдельно, я сразу все вот это дорисую
[01:00:25.800 --> 01:00:30.800]  вплоть до доллара, удалю эту вершину как проходную
[01:00:30.800 --> 01:00:33.400]  и скажу, что вот, пожалуйста, я сразу на будущее все
[01:00:33.400 --> 01:00:42.800]  сделал. Сразу вот этот v перенес вот сюда. Так, теперь
[01:00:42.800 --> 01:00:54.600]  надо какие-то слова написать. Если v в какой-то момент
[01:00:54.600 --> 01:01:08.500]  листом, она всегда будет листом, потому что она будет
[01:01:08.500 --> 01:01:10.900]  спускаться вниз и предыдущее сжиматься как проходная.
[01:01:10.900 --> 01:01:14.400]  Вместо того, чтобы добавлять по одному символу на каждой
[01:01:14.400 --> 01:01:21.200]  итерации, мы сразу допишем все до конца строки. Поэтому
[01:01:21.300 --> 01:01:36.300]  при создании листа, сразу дописываем весь насадок
[01:01:36.300 --> 01:01:46.400]  строки. То есть, если когда-то создался листик, то я сразу
[01:01:46.400 --> 01:01:48.700]  говорю, что на этом ребре написано не там все до
[01:01:48.700 --> 01:01:51.800]  символа c, а все до символа доллара, прямо до конца
[01:01:51.800 --> 01:01:54.600]  строки. Потому что всегда все равно это все равно будет
[01:01:54.600 --> 01:01:58.500]  просто вниз падать и вместо этого я могу сразу написать,
[01:01:58.500 --> 01:02:00.900]  что здесь все до доллара написано на этом ребре.
[01:02:00.900 --> 01:02:12.900]  То есть, с листами ситуация более-менее простая. Каждый
[01:02:12.900 --> 01:02:15.500]  раз, когда заводится лист, я сразу говорю, что ребро
[01:02:15.500 --> 01:02:22.300]  ведущее в него, оно на самом деле содержит все символы,
[01:02:22.300 --> 01:02:24.000]  начиная с того символа, который я тут прочитал,
[01:02:24.000 --> 01:02:26.300]  прямо до конца строки, до доллара. Все, что написано
[01:02:26.300 --> 01:02:30.500]  до доллара, это все введет в эту вершинку v.
[01:02:30.500 --> 01:02:35.000]  Вот, с первой категории разобрались. Теперь вторая,
[01:02:35.000 --> 01:02:40.500]  самая сложная, вторая категория вершин. Напоминаю, это те
[01:02:40.500 --> 01:02:44.700]  не листья, из которых нет перехода по c. То есть, это
[01:02:44.700 --> 01:02:47.500]  либо какие-то вершинки без перехода по c, либо позиции
[01:02:47.500 --> 01:02:54.900]  внутри ребра внизу, где c написано. Но, вспоминаем,
[01:02:54.900 --> 01:02:58.100]  что мне нужно сделать. Мне нужно при переходе, при обработке
[01:02:58.100 --> 01:03:01.500]  нового символа c, мне нужно этот c добавить явным образом.
[01:03:01.500 --> 01:03:03.700]  У меня появляется переход по боке c, я должен его как-то
[01:03:03.700 --> 01:03:06.300]  нарисовать. Но в случае вершины все просто, мне нужно просто
[01:03:06.300 --> 01:03:10.300]  добавить новое ребро c. А в случае, если мы находились
[01:03:10.300 --> 01:03:13.100]  посреди ребра, где-то внутри ребра, то мне нужно это ребро
[01:03:13.100 --> 01:03:16.500]  предыдущий расщепить, сказать, что это отдельное ребро,
[01:03:16.500 --> 01:03:19.100]  это отдельное ребро, и создать ребро по боку c здесь. Ну,
[01:03:19.100 --> 01:03:21.100]  как ни крути, да, мне нужно создать переход по c вот
[01:03:21.100 --> 01:03:25.100]  прям здесь, вот здесь или вот здесь. Но я его создаю,
[01:03:25.100 --> 01:03:27.400]  как могу. В этом случае, правда, придется расщепить
[01:03:27.400 --> 01:03:38.500]  ребро. Если v-позиция внутри ребра, то это ребро придется
[01:03:38.500 --> 01:03:55.700]  расщепить. Правильно. Да, и как только мы вот так вот
[01:03:55.700 --> 01:03:58.500]  сделали, да, нарисовали переход по боке c, нарисовали
[01:03:58.500 --> 01:04:01.100]  переход по боке c, эта вершина становится сейчас листом.
[01:04:01.100 --> 01:04:04.300]  А мы знаем, что мы делаем с листьями. Как только у
[01:04:04.300 --> 01:04:08.000]  нас появился лист, я сразу здесь вместо символа c пишу
[01:04:08.000 --> 01:04:10.400]  сразу всю подстрочку от c до конца строки прям до
[01:04:10.400 --> 01:04:14.000]  доллара. Вот по вот этим соображениям. Появился
[01:04:14.000 --> 01:04:17.300]  лист, который, да, вот здесь написан символ c. Но тогда
[01:04:17.300 --> 01:04:19.400]  мы знаем, какое его дальнейшее поведение. Он как бы сразу
[01:04:19.400 --> 01:04:21.100]  попадает в первую категорию, потому что это становится
[01:04:21.100 --> 01:04:23.300]  листом, и дальше он будет вот так вот по одному символу
[01:04:23.300 --> 01:04:27.000]  вниз-нис-нис расти по всему оставшемуся концу строки
[01:04:27.000 --> 01:04:32.300]  s. Поэтому здесь сразу я пишу не просто от c, а подстрочку
[01:04:32.300 --> 01:04:35.600]  символа c до символа доллар. То есть вот все прям вот отсюда
[01:04:35.600 --> 01:04:38.600]  до конца строки. То есть я знаю там, скажу, что это
[01:04:38.600 --> 01:04:41.800]  и плюс один, а здесь минус один. Тогда я пишу на этой вот
[01:04:41.800 --> 01:04:47.100]  строке пару и плюс один, запятая n минус один. Ну короче,
[01:04:47.100 --> 01:04:59.300]  от текущего символа до конца строки. Ну вот, например,
[01:04:59.300 --> 01:05:02.400]  вот у нас было ребро, я расщепил, вот она вид вершины выявления.
[01:05:02.400 --> 01:05:07.400]  То есть в этом случае мы сделали так. В случае, когда
[01:05:07.400 --> 01:05:09.400]  надо было расщеплять, то же самое. У меня появился
[01:05:09.400 --> 01:05:14.100]  новый исходящий, как бы, сарделька по букве c. Опять это стало
[01:05:14.100 --> 01:05:16.600]  листом, с листьями мы знаем, что происходит, поэтому
[01:05:16.600 --> 01:05:18.300]  вместо того, чтобы написать здесь просто от c, я пишу
[01:05:18.300 --> 01:05:21.900]  здесь всю подстрочку с c до доллара, прямо до конца
[01:05:21.900 --> 01:05:25.000]  строки. И теперь это как бы вот этот кусок отвечает
[01:05:25.000 --> 01:05:27.200]  листу, который я уже полностью обработал и больше к нему
[01:05:27.200 --> 01:05:32.900]  можно не возвращаться. То есть все вершины, все позиции
[01:05:32.900 --> 01:05:36.900]  второй категории нам должны как бы завести новое вот
[01:05:36.900 --> 01:05:40.000]  такое исходящее ребро по символу c, а значит сразу
[01:05:40.000 --> 01:05:42.500]  от c до доллара всю такую подстрочку из них надо будет
[01:05:42.500 --> 01:05:46.000]  уметь читать. Ну и так мне нужно проделать со всеми
[01:05:46.000 --> 01:05:56.400]  вершинами второй категории. Это нужно проделать со
[01:05:56.400 --> 01:06:15.000]  всеми позициями второй категории. Еще раз? Ну не
[01:06:15.000 --> 01:06:21.400]  все, а вот которые суффиксами являлись. Ну вот, вот эти
[01:06:21.400 --> 01:06:24.200]  вот позиции, да, которые не в первый, не в третий,
[01:06:24.200 --> 01:06:26.200]  все тут обрабатываем. Да, ну в частности, конечно,
[01:06:26.200 --> 01:06:37.900]  они бывают посреди ребра. Еще раз? Да, да, ну как бы
[01:06:37.900 --> 01:06:41.900]  ну, бывает такое, да, скажем, если у вас там не знаю, все
[01:06:41.900 --> 01:06:44.400]  символы были одинаковые, а потом пришел символ c,
[01:06:44.400 --> 01:06:46.200]  то скорее всего ровно так и будет. Вам нужно будет
[01:06:46.200 --> 01:06:48.600]  кучу раз отщепиться по c, да, то есть у вас была длинная
[01:06:48.600 --> 01:06:50.800]  такая ветка, вы дальше здесь везде отщепляетесь
[01:06:50.800 --> 01:06:59.400]  по c, скорее всего так и будет. Вот, нужно сказать,
[01:06:59.400 --> 01:07:02.200]  это как перебирать все вот эти вот позиции, как перебирать
[01:07:02.200 --> 01:07:06.100]  все позиции второй категории. Ну, можно сделать так, давайте
[01:07:06.100 --> 01:07:10.900]  мы заведем cur как указатель на самую длинную нелистовую
[01:07:10.900 --> 01:07:15.100]  позицию суффикса, тогда все позиции второй категории
[01:07:15.100 --> 01:07:19.100]  получаются с помощью getlink, потому что это некий суффикс,
[01:07:19.100 --> 01:07:21.800]  а это некие его более короткие суффиксы, да, то есть мы
[01:07:21.800 --> 01:07:25.500]  будем отбрасывать по одному символу от вот этого cur,
[01:07:25.500 --> 01:07:29.500]  до тех пор мы не попадем в позицию, то есть я просто
[01:07:29.500 --> 01:07:32.700]  беру от cur и getlink, до тех пор, пока не попаду в третью
[01:07:32.700 --> 01:07:46.100]  категорию. Значит, чтобы их перебрать, храним cur-
[01:07:46.100 --> 01:08:02.600]  суффикс не отвечающий листу, не отвечающий листу. Далее,
[01:08:02.600 --> 01:08:07.000]  пока из cur нет переход по c, я делаю вот такое преобразование,
[01:08:07.000 --> 01:08:11.340]  то есть явным образом создаю ребро от c до доллара и беру
[01:08:11.340 --> 01:08:23.340]  getlink от cur, потому что getlink отбрасывает по одному символу
[01:08:23.340 --> 01:08:29.080]  каждый раз, я так делаю, да, пока не появится переход
[01:08:29.080 --> 01:08:39.000]  по c из текущей позиции. Пока не появится переход
[01:08:39.000 --> 01:08:52.760]  по c, то есть пока мы не попадем в третью категорию. Вот это
[01:08:52.760 --> 01:08:56.320]  что мы делаем со второй категорией, а с третьей,
[01:08:56.320 --> 01:08:58.560]  тут смотрите, что нужно сделать, у меня была третья
[01:08:58.560 --> 01:09:01.280]  категория, это были позиции, из которых вниз и так был
[01:09:01.280 --> 01:09:06.060]  переход по c, тогда на самом деле я и что мы сделали,
[01:09:06.060 --> 01:09:08.520]  и мы cur вот этим вот, мы все, мы прошли всю целиком
[01:09:08.520 --> 01:09:11.200]  вторую категорию, и все их как бы в листья превратили,
[01:09:11.200 --> 01:09:13.180]  потому что вот у меня была позиция cur где-то вот здесь
[01:09:13.180 --> 01:09:16.320]  например, а мне нужно было спустить терминальность
[01:09:16.320 --> 01:09:20.120]  из нее вниз, и она спускается вот сюда, я завожу ребро,
[01:09:20.120 --> 01:09:22.720]  делаю это листом, и говорю, что если раньше это было
[01:09:22.720 --> 01:09:25.080]  суффиксом, то теперь это суффикс, и вместо cur я беру
[01:09:25.080 --> 01:09:30.280]  getlink от cur, то есть по сути все вот эти вот шаги мне
[01:09:30.280 --> 01:09:32.360]  уничтожают целиком вторую категорию, то есть все,
[01:09:32.360 --> 01:09:36.840]  что раньше было второй категорией на предыдущем шаге, целиком
[01:09:36.840 --> 01:09:41.220]  сливается в первую, потому что они все сразу становятся
[01:09:41.220 --> 01:09:45.040]  листьями, значит cur в итоге, после этого всего cur будет
[01:09:45.040 --> 01:09:48.160]  показывать вот сюда, на самый длинный суффикс, из
[01:09:48.160 --> 01:09:52.040]  которого есть переход по c, ну и тогда, чтобы перейти
[01:09:52.040 --> 01:09:54.960]  к следующему шагу, я просто должен эту самую терминальность
[01:09:54.960 --> 01:09:57.800]  спустить здесь вниз по букве c, давайте я это нарисую.
[01:10:07.840 --> 01:10:09.760]  То есть первой из второй категории мы разобрались,
[01:10:09.760 --> 01:10:14.640]  дальше в третьей категории у нас после вот этого вайла,
[01:10:14.640 --> 01:10:22.240]  после этого пока, и мне нужно здесь опять-таки из них
[01:10:22.240 --> 01:10:25.280]  всех провести переход по c, ну причем из них и всех
[01:10:25.280 --> 01:10:28.440]  он и так уже есть, мне нужно просто спуститься по нему,
[01:10:28.440 --> 01:10:34.600]  тогда давайте я просто cur по символу c, то есть прочитаю
[01:10:34.600 --> 01:10:39.120]  его из этой позиции, я из него могу однозначно прочитать
[01:10:39.120 --> 01:10:42.640]  символ c, и на этом закончусь, потому что что мне нужно
[01:10:42.640 --> 01:10:45.760]  от cur, мне нужно чтобы cur указывал на максимальный
[01:10:45.760 --> 01:10:49.680]  не лист, максимальный суффикс не лист, ну все
[01:10:49.680 --> 01:10:53.080]  большие суффиксы мы уже обработали, они стали листьями,
[01:10:53.080 --> 01:11:02.920]  а это после прощения c, так, хочу сказать не будет
[01:11:02.920 --> 01:11:06.920]  листом, ну да, но не будет листом, потому что в этот
[01:11:06.920 --> 01:11:10.680]  момент времени все листья сейчас они уже заканчиваются
[01:11:10.680 --> 01:11:14.400]  на доллар, поэтому прощение символа c меня точно в лист
[01:11:14.400 --> 01:11:17.880]  не переведет, поэтому когда я здесь просто спускаю вот
[01:11:17.880 --> 01:11:22.520]  это вот cur по букве c, я попадаю опять вне лист, самый длинный
[01:11:22.520 --> 01:11:25.040]  суффикс, который не является листом, и для следующей
[01:11:25.040 --> 01:11:26.720]  итерации, когда я здесь буду читать уже следующий
[01:11:26.720 --> 01:11:29.760]  символ там d какой-то, у меня cur будет как раз указывать
[01:11:29.760 --> 01:11:30.760]  туда куда нужно.
[01:11:31.680 --> 01:11:34.400]  Третью категорию я вообще максимально лениво обрабатываю,
[01:11:34.400 --> 01:11:36.960]  я здесь не спускаю все вот эти вот указатели вниз по
[01:11:36.960 --> 01:11:41.040]  букве c, я спускаю вниз только первый из них, а все остальные
[01:11:41.040 --> 01:11:44.000]  будут являться его с уксылками, то есть это будет getlink, это
[01:11:44.000 --> 01:11:46.560]  дважды getlink, это трижды и так далее, то есть их я
[01:11:46.560 --> 01:11:50.120]  как бы вообще не храню, я храню просто cur, вот он,
[01:11:50.120 --> 01:11:53.400]  один он спустился вниз по букве c, все, а все остальные
[01:11:53.400 --> 01:11:56.200]  автоматически как бы пересчитались, потому что все остальное
[01:11:56.200 --> 01:11:59.040]  это многократный getlink от этой позиции, вот это
[01:11:59.120 --> 01:12:02.320]  getlink от cur, это getlink от getlink от cur и так далее,
[01:12:02.320 --> 01:12:05.520]  а поэтому все вот эти вот автоматически уже не спустились,
[01:12:05.520 --> 01:12:07.840]  как только я cur вниз снес по букве c.
[01:12:16.320 --> 01:12:17.160]  Итого алгоритм.
[01:12:29.040 --> 01:12:36.640]  Ну, значит, база такая, когда у меня ничего не прочитано,
[01:12:36.640 --> 01:12:38.920]  у меня есть только корень и cur равен корню.
[01:12:38.920 --> 01:12:41.920]  Это когда я прочитал ноль символов.
[01:12:41.920 --> 01:12:46.480]  Процедура добавления символа c в конец нашей текущей
[01:12:46.480 --> 01:12:47.920]  прочитанной строке, add c.
[01:12:47.920 --> 01:12:53.720]  Значит, что мы должны сделать?
[01:12:53.720 --> 01:12:56.600]  Мы запоминаем, что cur, cur это у меня всегда указатель
[01:12:56.600 --> 01:12:57.600]  на самый длинный ниней лист.
[01:12:58.160 --> 01:13:00.440]  Ну, как бы корень я не считаю листом, это отдельная вершина,
[01:13:00.440 --> 01:13:03.440]  которая даже если лист, мы как бы в листе не причисляем.
[01:13:04.440 --> 01:13:09.720]  Значит, вот у меня есть cur, я должен пока из cur нет перехода
[01:13:09.720 --> 01:13:15.720]  по c, явно его завести, завести переход по c, взять getlink,
[01:13:15.720 --> 01:13:17.920]  ну и так прыгать, пока не появится переход по c.
[01:13:17.920 --> 01:13:19.920]  Давайте это сделаем.
[01:13:19.920 --> 01:13:28.760]  Я добавил, сейчас, одну секунду, вот тут немножко хитро
[01:13:28.760 --> 01:13:29.760]  надо сделать.
[01:13:29.760 --> 01:13:42.080]  Давайте напишу так, пока cur не равно root и c, нет перехода
[01:13:42.080 --> 01:13:43.080]  по c.
[01:13:43.240 --> 01:13:56.800]  Ну, если нужно расщепить ребро, если нужно расщепляем
[01:13:56.800 --> 01:14:11.800]  ребро, создаем переход по отрезку c до конца строки,
[01:14:12.520 --> 01:14:16.040]  ну и cur поднимаемся с помощью совсылки, cur равно getlink
[01:14:16.040 --> 01:14:17.040]  от cur.
[01:14:22.040 --> 01:14:25.480]  Так, while кончился, дальше в конце while мы либо пришли
[01:14:25.480 --> 01:14:28.840]  в корень, из которого нет перехода по c, либо перешли
[01:14:28.840 --> 01:14:30.280]  в нормальную вершину, из которой есть переход
[01:14:30.280 --> 01:14:31.280]  по c.
[01:14:31.280 --> 01:14:49.840]  Ну да, если из cur есть переход по c, тогда нужно просто
[01:14:49.840 --> 01:14:53.040]  по нему перейти, как здесь написано, cur равно, где оно
[01:14:53.040 --> 01:15:04.480]  у меня было, вот оно, go, cur, c, go, cur, c, это тот случай,
[01:15:04.480 --> 01:15:08.440]  когда у нас была третья категория, я в нее попал
[01:15:08.440 --> 01:15:11.240]  и мне нужно просто сделать спуск в ней.
[01:15:11.240 --> 01:15:16.400]  Иначе, когда я прошел все дерево, я брал совсылки
[01:15:16.400 --> 01:15:19.400]  кучу раз, брал-брал-брал совсылки и я не дошел до
[01:15:19.400 --> 01:15:21.600]  вершины, из которой был бы переход по c, то есть третья
[01:15:21.600 --> 01:15:24.040]  категория была пустая, мы дошли до самого корня
[01:15:24.040 --> 01:15:25.760]  и даже из корня нет перехода по c.
[01:15:25.760 --> 01:15:28.560]  В этом случае мне нужно просто создать переход
[01:15:28.560 --> 01:15:37.960]  по c из корня, создать переход по, ну не по c, как обычно,
[01:15:37.960 --> 01:15:41.800]  по отрезку с c до доллара, а из cur, который в этом
[01:15:41.800 --> 01:15:48.680]  момент равен корню, и все, cur оставить корнем, весь
[01:15:48.680 --> 01:15:49.680]  алгоритм.
[01:15:49.680 --> 01:16:04.440]  Давайте пару слов про корректность, мы много здесь проговорили.
[01:16:04.440 --> 01:16:08.160]  Значит, cur, напоминаю, это всегда должен быть указатель
[01:16:08.160 --> 01:16:12.680]  на позицию максимальной высотой листа, в начале
[01:16:12.680 --> 01:16:17.560]  это верно, корень мы листом не считаем, дальше, пока
[01:16:17.560 --> 01:16:20.640]  нет перехода по c, создаем, соответственно, вот сразу
[01:16:20.640 --> 01:16:23.600]  появляется лист, вот это вот то, что мы заводим,
[01:16:23.600 --> 01:16:27.600]  сразу идет в лист, а дальше, cur, мне нужно подняться по
[01:16:27.600 --> 01:16:30.280]  совсылке, взять следующий по длине суффикс.
[01:16:30.280 --> 01:16:35.360]  Это происходит до одного из двух исходов, либо я
[01:16:35.360 --> 01:16:38.480]  попал в третью категорию, и тогда в ней просто нужно
[01:16:38.480 --> 01:16:41.360]  спуститься вниз, и как бы это будет наша текущая
[01:16:41.360 --> 01:16:44.280]  cur, это будет самый длинный с ней лист, потому что все
[01:16:44.280 --> 01:16:47.000]  вот это вот листья, а это спустилось в ней лист.
[01:16:47.000 --> 01:16:51.000]  Или даже я всю вторую категорию целиком прошел, третьей
[01:16:51.000 --> 01:16:54.720]  не было, я попал в корень, то есть иначе, вот если
[01:16:54.720 --> 01:16:57.080]  if не сработал, то значит, я дошел на корня, и даже
[01:16:57.080 --> 01:16:59.720]  из корня не было перехода по c, тогда нужно его просто
[01:16:59.720 --> 01:17:01.560]  создать, а cur оставить в качестве корня.
[01:17:01.560 --> 01:17:06.120]  Давайте здесь допишу, что cur остается корнем, cur равно
[01:17:06.120 --> 01:17:09.680]  root остается, то есть он после вала стал корнем,
[01:17:09.680 --> 01:17:11.720]  и он не меняется с этой вот этой штуки, потому что
[01:17:11.720 --> 01:17:18.040]  я завел переход по длинному ребру до конца строки,
[01:17:18.040 --> 01:17:20.720]  и при этом кур поменялся, у меня все позиции теперь
[01:17:20.720 --> 01:17:23.640]  листья, у меня куча листьев, и есть листья, это корень,
[01:17:23.640 --> 01:17:25.240]  и вот мне нужно оставить, что cur это корень.
[01:17:25.240 --> 01:17:35.160]  Ну вот же картинка, смотрите, cur вполне была какая-то
[01:17:35.160 --> 01:17:43.240]  позиция на ребре, вот она здесь была, необязательно
[01:17:43.240 --> 01:17:51.480]  лист, да-да, не лист обязательно, здесь я его расщепляю.
[01:17:51.480 --> 01:17:56.000]  Ну давайте быстро переобсудим асимптотику, почему это будет
[01:17:56.000 --> 01:18:13.000]  линейное время от n, если считать алфавит константным,
[01:18:13.000 --> 01:18:19.760]  если считать, что алфавит константным, если алфавит
[01:18:19.760 --> 01:18:23.920]  не константно, то те же самые, что и в Боре у нас
[01:18:23.920 --> 01:18:26.960]  могут быть, то есть мы можем либо в каждой вершине явно
[01:18:26.960 --> 01:18:30.160]  хранить сигмы переходов, для каждой буквы хранить
[01:18:30.160 --> 01:18:32.560]  есть такой переход или нет, и если да, куда оно ведет,
[01:18:32.560 --> 01:18:35.840]  тогда будет n умножить на сигма памяти и столько
[01:18:35.840 --> 01:18:39.240]  же времени, либо можем хранить в качестве мапы, в каждой
[01:18:39.240 --> 01:18:41.080]  вершине хранить для каждой буквы есть такой переход
[01:18:41.080 --> 01:18:43.360]  или нет, ну то есть хранить в мапе, в двойственном дереве
[01:18:43.360 --> 01:18:47.160]  поиска все ребра упорядоченные по первой поиске, тогда будет
[01:18:48.160 --> 01:18:56.240]  сигма, если мы можем мапу памяти, потому что ребер линейное
[01:18:56.240 --> 01:19:00.320]  количество, ну вот давайте считать, что сигма константа
[01:19:00.320 --> 01:19:03.400]  и все переходы можно ведет за единицу, находясь в вершине
[01:19:03.400 --> 01:19:08.760]  я могу спуститься по ребру за единицу, значит тут есть
[01:19:08.760 --> 01:19:13.840]  две проблемы, сложных моментов, во-первых, не понятно насколько
[01:19:13.840 --> 01:19:17.560]  суммарно будет вайлов, потому что каждая обработка символа
[01:19:17.560 --> 01:19:20.840]  это много вайлов, может быть много итераций кло-вайлов,
[01:19:20.840 --> 01:19:26.680]  плюс это вот эта магическая гетлинг, которая тоже не
[01:19:26.680 --> 01:19:28.560]  понятно сколько работает, мы знаем, что его время работает
[01:19:28.560 --> 01:19:30.760]  по распространению числу пройденных ребер, а сколько
[01:19:30.760 --> 01:19:34.160]  он проходит, фиг знает, ну во-первых, вайлов будет
[01:19:34.160 --> 01:19:38.680]  не много, во-первых, итераций кло-вайлов,
[01:19:43.840 --> 01:19:48.960]  так как каждая его успешная итерация заводит по крайней
[01:19:48.960 --> 01:19:52.760]  мере один лист, нам это может каждый успешный вайл создает
[01:19:52.760 --> 01:19:55.760]  ребро из ц по доллару, то есть создает лист, а листьев
[01:19:55.760 --> 01:19:58.600]  мы знаем всего ровно столько сколько суффиксов, поэтому
[01:19:58.600 --> 01:20:01.360]  суммарная успешная вайла будет не больше, чем число
[01:20:01.360 --> 01:20:13.360]  суффиксов, так как каждая его итерация создает лист,
[01:20:13.360 --> 01:20:23.600]  так как в конце листья это суффикс и наоборот, значит
[01:20:23.600 --> 01:20:26.280]  вайлов на каждом конкретном этапе, на каждом конкретном
[01:20:26.280 --> 01:20:30.120]  шейх может быть много, но суммарно их будет линейное
[01:20:30.120 --> 01:20:32.120]  количество, потому что каждая успешная итерация это добавление
[01:20:32.120 --> 01:20:37.640]  листа, вторая проблема с гетлинг, что происходит,
[01:20:37.640 --> 01:20:43.280]  когда я много раз вешаю гетлинг, напомним, как у нас работает
[01:20:43.280 --> 01:20:47.080]  гетлинг, был некий путь до вершинки п, было длинное
[01:20:47.080 --> 01:20:50.240]  ребро, на котором мы пришли к символов, мы взяли линк
[01:20:50.240 --> 01:20:55.200]  от к символов, и потом читаем вот эти к символов как-то
[01:20:55.200 --> 01:21:00.800]  возможно используя несколько ребер, здесь для анализа
[01:21:00.800 --> 01:21:09.800]  давайте я определю вину позиции, это число ребер на
[01:21:09.800 --> 01:21:21.080]  пути позиции поз, именно ребер, сколько ребер мы
[01:21:21.080 --> 01:21:27.320]  задействовали, чтобы попасть в позицию поз, так вот что
[01:21:27.320 --> 01:21:32.700]  происходит с этой глубиной, когда я навешиваю гетлинг
[01:21:32.700 --> 01:21:35.520]  на кур, давайте посмотрим, пусть здесь у меня был какой-то
[01:21:35.520 --> 01:21:42.640]  кур, что происходит с глубиной, когда я навешиваю гетлинг,
[01:21:42.640 --> 01:21:47.600]  ну во-первых сначала я перенесся в начало ребра, то есть уменьшил
[01:21:47.600 --> 01:21:50.160]  глубину на один, потому что вот это ребро перестало
[01:21:50.160 --> 01:21:54.760]  учиться, я сначала уменьшил глубину на один, первый
[01:21:54.760 --> 01:21:59.400]  шаг, когда я от кура поднимаюсь к родителю, изменение глубины
[01:21:59.400 --> 01:22:06.400]  это в точности минус один, дальше я от п беру левый
[01:22:06.400 --> 01:22:11.760]  от п, что происходит с глубиной, вот я утверждаю, что на этом
[01:22:11.760 --> 01:22:17.200]  этапе, когда я от п перехожу к суфсыл, я утверждаю, что
[01:22:17.200 --> 01:22:20.680]  здесь изменение глубины больше либо равно чем минус
[01:22:20.680 --> 01:22:28.040]  один, чуть позже я это покажу, ну и третье, каждый спуск вниз,
[01:22:28.040 --> 01:22:32.080]  если я здесь делал м спусков вниз, то у меня увеличилось
[01:22:32.080 --> 01:22:38.000]  на м, потому что я прошел м ребер, если прошли м ребер,
[01:22:38.000 --> 01:22:51.480]  прошли м ребер, то дельта депс равно м, больше либо
[01:22:51.480 --> 01:22:56.120]  равно чем минус один, сейчас мы это докажем, ну там 0,
[01:22:56.120 --> 01:23:03.280]  1, 2 может быть, ну минус 2 уже не может, значит если
[01:23:03.280 --> 01:23:06.120]  я это докажу, то есть а понятно, потому что я просто перестал
[01:23:06.120 --> 01:23:09.200]  учиться, ве понятно, потому что ну сколько ребер прошли
[01:23:09.200 --> 01:23:12.920]  настолько глубина увеличилась, если мы докажем ве, то тогда
[01:23:12.920 --> 01:23:17.640]  понятно, что суммарное изменение может быть не больше чем
[01:23:17.640 --> 01:23:21.240]  от м, потому что вот эта штука уменьшает на единицу,
[01:23:21.240 --> 01:23:23.880]  это если уменьшает точность на единицу, а это вообще
[01:23:24.880 --> 01:23:28.600]  А мы помним, что время работы этого генетика, это от м,
[01:23:28.600 --> 01:23:31.240]  на я специально спрашивал, за сколько это работает,
[01:23:31.240 --> 01:23:33.880]  за то, за сколько ребер мы здесь спустились вниз,
[01:23:33.880 --> 01:23:39.280]  за от м, поэтому, поскольку суммарная глубина не может
[01:23:39.280 --> 01:23:43.160]  быть больше чем n, да, у меня всего n вершин в дереве,
[01:23:43.160 --> 01:23:46.040]  ну от n вершин в дереве, глубина никогда не может быть больше
[01:23:46.040 --> 01:23:52.040]  чем n, от n, поэтому раз здесь, на каждом шаге, у меня глубина
[01:23:52.200 --> 01:23:53.640]  уменьшилась максимум на 2 и потом увеличилась на
[01:23:53.640 --> 01:23:57.760]  m, суммарно этих увеличений будет тоже от n, а ну раз
[01:23:57.760 --> 01:24:01.440]  она ограничена с n, она уменьшается всего максимум на 2 на каждом
[01:24:01.440 --> 01:24:04.800]  шаге, то суммарное увеличение будет от n, поэтому сумма
[01:24:04.800 --> 01:24:10.000]  этих м будет тоже от n, то есть, чтобы все это завершить
[01:24:10.000 --> 01:24:21.000]  мне нужно сказать только пункт b, значит он доказывается
[01:24:21.120 --> 01:24:27.640]  так, вот у меня есть p, вот у меня есть линк от p, что
[01:24:27.640 --> 01:24:30.640]  такое depth от p, это по сути число вершин на этом пути,
[01:24:36.640 --> 01:24:38.640]  дальше, давайте возьмем ссылки от всех этих линк на
[01:24:38.640 --> 01:24:41.160]  этом пути, я утверждаю, что они обязательно будут
[01:24:41.160 --> 01:24:47.160]  на этом пути лежать, ну просто потому что все они отличаются
[01:24:47.160 --> 01:24:49.400]  от отбрасывания вот этого первого символа, значит
[01:24:49.760 --> 01:24:51.760]  если я знаю что, если ссылка
[01:24:52.760 --> 01:24:54.760]  это, то вот это, то есть отбрасывание при derived
[01:24:54.800 --> 01:25:00.900]  здесь,
[01:25:02.460 --> 01:25:03.800] актически часть бы a будет у меня в этом пути,
[01:25:03.800 --> 01:25:07.800]  ну если здесь будет V-ли spir, то они тоже будут, мы это
[01:25:07.800 --> 01:25:09.920]  с вами доказывали, что если у меня есть вершина, я взял
[01:25:09.920 --> 01:25:12.480]  ее backs fine, то это будет
[01:25:12.480 --> 01:25:17.020]  то все это тоже вершина.
[01:25:17.020 --> 01:25:20.980]  здесь будет отвечать вершине поэтому число ребер на этом пути будет такой же
[01:25:20.980 --> 01:25:26.140]  как здесь кроме возможно когда сух ссылка отсюда ведет вот сюда тогда у вас
[01:25:26.140 --> 01:25:28.980]  только в этом случае у вас может уменьшиться на один число вершин на
[01:25:28.980 --> 01:25:33.860]  этом пути именно отсюда возникает дельта депс больше ночи минус один то есть ну
[01:25:33.860 --> 01:25:38.060]  в идеальном случае в самом простом будет просто биекция между вершинами и сух ссылками
[01:25:38.060 --> 01:25:44.780]  вот такой да вот здесь будут вершины здесь будут их сух ссылки в худшем случае у меня будет ну не
[01:25:44.780 --> 01:25:51.260]  совсем биекция вот такое будет здесь вершины а здесь их сух ссылки только корень как бы я не
[01:25:51.260 --> 01:25:59.020]  учил меня будет на один меньше глубина вот здесь поэтому дельта депс может быть больше возможно
[01:25:59.020 --> 01:26:04.660]  если еще кто-то фиг его знает вполне возможно но больше ночи минус 1 если есть отличие то не
[01:26:04.660 --> 01:26:06.060]  больше чем на 1 все спасибо
