[00:00.000 --> 00:09.600]  У нас с вами задача с кратчайшими плечами продолжается.
[00:09.600 --> 00:14.320]  На чем мы закончили прошлый раз?
[00:14.320 --> 00:16.120]  На Форде Бэлмене.
[00:16.120 --> 00:18.640]  Почему Форд Бэлмен был хороший?
[00:18.640 --> 00:23.760]  Можно было найти отрицательный цикл и можно было работать
[00:23.760 --> 00:26.560]  просто с отрицательными реблями.
[00:26.560 --> 00:29.000]  Но это да и экстра выглядит все равно тоже прикольно.
[00:29.000 --> 00:30.000]  Правда?
[00:30.000 --> 00:31.000]  Вот.
[00:31.000 --> 00:38.240]  Фактически на прошлом занятии мы с вами говорили о задаче,
[00:38.240 --> 00:41.480]  чуть-чуть подсохнет, но существует несколько видов
[00:41.480 --> 00:44.720]  задач на нахождение кратчайших путей.
[00:44.720 --> 00:48.000]  Существует задача, когда вам нужно от вершины до
[00:48.000 --> 00:51.360]  вершины найти, существует задача, когда вам нужно
[00:51.360 --> 00:55.760]  от вершины до всех вершин найти, и от всех вершин существует
[00:55.760 --> 00:56.760]  до всех вершин.
[00:56.760 --> 01:06.920]  Задача от вершины до вершины — это, по сути, своя д-экстра
[01:06.920 --> 01:07.920]  почти что.
[01:07.920 --> 01:10.280]  Некоторые мои улучшения — это так называемые алгоритмы
[01:10.280 --> 01:11.280]  со звездой.
[01:11.280 --> 01:12.280]  Если у нас будет время, мы его разберем.
[01:12.280 --> 01:19.680]  А от вершины до всех остальных вершин — это д-экстра, это
[01:19.680 --> 01:23.240]  Форд Бэлмен, ну и пока все.
[01:23.240 --> 01:27.520]  Ну, БФС еще можно сюда отнести, если очень хочется.
[01:27.520 --> 01:28.520]  Согласны?
[01:28.520 --> 01:29.520]  Вот.
[01:29.520 --> 01:33.960]  Существует задача некоторая от всех вершин до всех
[01:33.960 --> 01:34.960]  вершин.
[01:34.960 --> 01:40.560]  В принципе, можно от каждой вершинки запустить д-экстру
[01:40.560 --> 01:43.480]  и получить какой-нибудь алгоритм, который будет
[01:43.480 --> 01:47.000]  показываться от всех вершин до всех вершин, но это будет
[01:47.000 --> 01:49.000]  занимать чуть дольше времени.
[01:49.000 --> 01:51.040]  Хочется придумать что-то другое.
[01:51.040 --> 01:56.080]  И вот что-то другое — это будет называться алгоритмом
[01:56.080 --> 01:59.120]  Флойда или алгоритмом Флойда Воршелла — одно из двух
[01:59.120 --> 02:00.120]  названий.
[02:00.120 --> 02:04.000]  В общем-то, какая задача?
[02:04.000 --> 02:08.960]  Предположим, что у нас все также на графе есть веса
[02:08.960 --> 02:10.520]  у каждого из ребер.
[02:10.520 --> 02:13.040]  Мы с этим работаем, мы с этим живем, как бы все как
[02:13.040 --> 02:14.040]  обычно.
[02:14.040 --> 02:18.160]  И нам нужно найти эти кратчайшие пути от каждой вершины до
[02:18.160 --> 02:19.160]  вершины.
[02:19.320 --> 02:20.320]  В принципе, что мы ожидаем?
[02:20.320 --> 02:25.600]  Мы ожидаем в качестве ответа некоторую матрицу, где у
[02:25.600 --> 02:31.080]  нас будет в строке указываться, от какой вершины в столбце
[02:31.080 --> 02:33.600]  до какой вершины, и мы будем смотреть, какие у нас есть
[02:33.600 --> 02:34.600]  расстояния.
[02:34.600 --> 02:37.240]  Все достаточно просто.
[02:37.240 --> 02:41.920]  Согласны ли вы с тем, что эта матрица ничего особенного
[02:41.920 --> 02:42.920]  не имеет?
[02:46.920 --> 02:47.920]  Или нет?
[02:49.920 --> 02:52.920]  Диагональ нули.
[02:58.920 --> 03:01.920]  Если у нас будет неориентированный граф, то какая матрица будет?
[03:01.920 --> 03:02.920]  Симметричная.
[03:02.920 --> 03:03.920]  Отлично.
[03:03.920 --> 03:06.920]  А диагональ нули?
[03:06.920 --> 03:09.920]  Всегда ли будет диагональ нули?
[03:11.920 --> 03:12.920]  Вот.
[03:12.920 --> 03:15.520]  Если будет отрицательный цикл, то логично, что там
[03:15.520 --> 03:18.800]  будет какие-то не те значения, которые мы хотим.
[03:18.800 --> 03:23.560]  Ну, как бы, наивный подход какой?
[03:23.560 --> 03:27.600]  Мы берем просто нашего Форда Белмана и запускаем
[03:27.600 --> 03:28.900]  его в RAS.
[03:28.900 --> 03:33.600]  Мы берем нашу DX3 и запускаем ее в RAS и смотрим, что у нас
[03:33.600 --> 03:34.600]  получается.
[03:34.600 --> 03:37.200]  Ну, для Форда Белмана у нас всегда получается
[03:37.200 --> 03:38.200]  VF4.
[03:38.880 --> 03:51.080]  Для DX3 это будет у нас либо A, но все достаточно просто.
[03:51.080 --> 03:57.600]  У нас же там EV, ну, в некоторых случаях, да, действительно
[03:57.600 --> 04:03.080]  будет V квадрат, ой, V куб, потому что я в RAS буду делать
[04:03.080 --> 04:06.080]  V на V.
[04:06.080 --> 04:07.080]  Вот.
[04:07.960 --> 04:10.400]  Ну, в общем, в своей сути у нас будут почти плотные
[04:10.400 --> 04:13.960]  графы почти всегда, вот.
[04:13.960 --> 04:15.960]  Поэтому будет там VF4.
[04:15.960 --> 04:19.840]  Но, да, в детпитительности, как бы, если у нас алгоритм
[04:19.840 --> 04:26.120]  будет всего лишь, алгоритм у нас будет на разрешенный
[04:26.120 --> 04:28.160]  граф, то у нас будет V куб.
[04:28.160 --> 04:31.400]  Если же мы с вами говорим про то, что у нас еще ребра
[04:31.400 --> 04:33.840]  будут не отрицательные, то тут включается DX3, и
[04:33.840 --> 04:35.880]  тогда это будет с одной стороны работать за V квадрат
[04:35.880 --> 04:40.200]  лог V на разрешенных графах, на плотных графах будет
[04:40.200 --> 04:41.720]  все работать за V куб.
[04:41.720 --> 04:46.120]  Но здесь важное утверждение, что у нас веса не отрицательные.
[04:46.120 --> 04:50.480]  Это очень-очень важно и нужно.
[04:50.480 --> 04:54.320]  Это все достаточно просто.
[04:54.320 --> 04:57.560]  Теперь поговорим про сам алгоритм Флойда.
[04:57.560 --> 05:00.320]  Что это такое?
[05:00.320 --> 05:02.320]  Смотрите.
[05:02.320 --> 05:05.440]  Хочется воспользоваться чем-то из первого семестра,
[05:05.440 --> 05:06.440]  какого-то знания.
[05:06.440 --> 05:09.280]  Мы же не просто так учились, правда?
[05:09.280 --> 05:13.200]  Во-вторых, какой-то такой очень простой и какой-то
[05:13.200 --> 05:15.720]  логичный момент использовать.
[05:15.720 --> 05:17.320]  Какой момент использовать?
[05:17.320 --> 05:21.000]  Смотрите, предположим, что у нас есть некоторая
[05:21.000 --> 05:24.800]  вершина V, есть некоторая вершина U.
[05:24.800 --> 05:28.560]  И вот давайте мы скажем следующее.
[05:28.560 --> 05:34.600]  У нас есть какое-то посчитанное расстояние здесь, и я зафиксирую
[05:34.720 --> 05:42.280]  какую-то вершину, не знаю там, а K.
[05:42.280 --> 05:47.480]  Я буду смотреть для любой пары VU, что у меня лучшее,
[05:47.480 --> 05:50.880]  расстояние, которое у меня есть сейчас тут, либо же
[05:50.880 --> 05:57.160]  расстояние, проложенное через эту вершину K, и буду
[05:57.160 --> 05:59.120]  обновлять все наши пути.
[05:59.120 --> 06:03.480]  Вот я буду вот через нее только ходить.
[06:03.480 --> 06:08.560]  Тут у меня какая-нибудь омега-1, тут омега-2, а тут
[06:08.560 --> 06:09.560]  просто омега.
[06:09.560 --> 06:11.560]  Вот я буду смотреть, что вот эта омега, она больше
[06:11.560 --> 06:13.200]  чем омега-1 плюс омега-2.
[06:13.200 --> 06:15.960]  Если она больше, тогда мне легче пройти через эту
[06:15.960 --> 06:16.960]  вершину K.
[06:16.960 --> 06:25.400]  Ага, пока понятно, что я говорю, или не очень.
[06:25.480 --> 06:30.560]  Теперь представьте следующее, я вот этот вот принцип разобью
[06:30.560 --> 06:31.560]  дальше.
[06:31.560 --> 06:36.600]  Что вот здесь подразумевается, смотрите, подразумевается
[06:36.600 --> 06:37.600]  следующее.
[06:37.600 --> 06:42.240]  Представляете, что у меня открываются вершины поочередно,
[06:42.240 --> 06:45.240]  и вот я смотрю на них, и вот их пытаюсь добавлять
[06:45.240 --> 06:49.000]  вот с учетом того, как у нас граф выглядит, то есть
[06:49.000 --> 06:53.000]  с учетом всех тех вещей, которые вот ребра там то
[06:53.000 --> 06:55.680]  в него смотрят, то из него исходят и так далее.
[06:55.680 --> 06:57.760]  И в зависимости от этого я пытаюсь вот именно вот
[06:57.760 --> 06:58.760]  так вот проходиться.
[06:58.760 --> 07:03.120]  Что это само по себе напоминает, что я использую какие-то
[07:03.120 --> 07:06.720]  условия под задачи, которые были до этого, вот это,
[07:06.720 --> 07:11.000]  то есть какой-то путь из уже открытых вершин, и смотрю
[07:11.000 --> 07:12.000]  на новую вершину.
[07:12.000 --> 07:16.720]  Фактически это динамическое программирование, которое
[07:16.720 --> 07:20.320]  у нас с вами будет, и вот таким вот образом мы все
[07:20.320 --> 07:21.320]  это перестраиваем.
[07:21.320 --> 07:24.880]  В начале у нас будет пустота, у нас будет все грустно,
[07:24.880 --> 07:28.640]  у нас одна вершина, а дальше мы добавляем эту вершину
[07:28.640 --> 07:32.880]  и смотрим какие пути проходят через нее и так далее.
[07:32.880 --> 07:36.960]  То есть грубо говоря, у нас есть некоторый граф,
[07:36.960 --> 07:39.360]  и вот мы знаем, что какое-то количество вершин хотя
[07:39.360 --> 07:42.640]  бы есть, но вот эти ребра, которые связаны с какой-то
[07:42.640 --> 07:45.240]  вершиной, мы вводим поочередно.
[07:45.240 --> 07:47.440]  Смотрим, что у нас происходит.
[07:48.360 --> 07:50.440]  И в зависимости от этого мы ввез
[07:50.440 --> 07:51.440]  свое улучшение.
[07:51.440 --> 07:55.360]  Я утверждаю, что этого будет достаточно, то есть если
[07:55.360 --> 07:58.760]  мы вот так вот будем добавлять по одной вершинке, и мы пройдемся
[07:58.760 --> 08:01.160]  по всем вершинам, то этого будет достаточно, чтобы
[08:01.160 --> 08:04.080]  понять, что вот эта омега – это действительно кратчайший
[08:04.080 --> 08:05.080]  путь.
[08:08.080 --> 08:10.960]  Фактически ребра связанные с вершиной.
[08:10.960 --> 08:13.960]  Почему так?
[08:13.960 --> 08:17.360]  Ну в действительности представьте, что у вас есть граф несвязанный,
[08:17.360 --> 08:22.640]  у вас будет везде расстояние какое-то бесконечное, вот,
[08:22.640 --> 08:26.360]  а потом мы добавляем ребра, связанные с конкретной вершинкой,
[08:26.360 --> 08:27.360]  мы начинаем прокладывать.
[08:27.360 --> 08:34.480]  Ну вот в него входит, из него исходит такого характера.
[08:34.480 --> 08:37.760]  Фактически, если говорить фактически, как это будет
[08:37.760 --> 08:41.920]  выглядеть с точки зрения реализации, достаточно будет следующего.
[08:41.920 --> 08:45.000]  Вы просто фиксируете какую-то вершину и пытаетесь прокладывать
[08:45.000 --> 08:46.720]  все пути через нее.
[08:46.720 --> 08:49.920]  И смотрите, если я проложу этот путь через эту вершину,
[08:49.920 --> 08:51.120]  то будет хорошо или плохо?
[08:51.120 --> 08:58.320]  Вот, ну и буду обновлять.
[08:58.320 --> 08:59.320]  Подходит, не подходит.
[08:59.320 --> 09:02.240]  Вот, в этом заключается алгоритм Флойда.
[09:02.240 --> 09:08.040]  Что здесь происходит?
[09:08.040 --> 09:11.720]  Смотрите, имеется в виду следующее, вот у нас есть
[09:11.920 --> 09:16.360]  Некоторая табличка, и я говорю, что этих табличек
[09:16.360 --> 09:17.360]  будет В.
[09:17.360 --> 09:25.920]  И вот dkt x, y это будет расстояние от x до y, в котором в качестве
[09:25.920 --> 09:28.440]  вот промежуточных вершин, то есть по которому я мог
[09:28.440 --> 09:32.520]  пройти по этому пути, используется только первый k вершинок.
[09:32.520 --> 09:45.600]  Ну, у нас типа k табличек, я называю так, В табличек,
[09:45.600 --> 09:46.600]  а?
[09:46.600 --> 09:47.600]  В табличек?
[09:47.600 --> 09:53.120]  Да, В табличек размером В на В, все правильно.
[09:53.120 --> 09:56.160]  Вот, я открываю эти вершины поочередно.
[09:56.160 --> 09:58.480]  Я говорю, вот я добавил одну вершину, вот добавил
[09:58.480 --> 10:01.080]  вторую вершину, вот третью вершину, вот четвертую и
[10:01.080 --> 10:02.080]  так далее.
[10:02.080 --> 10:05.320]  И я говорю, что каждая последующая табличка будет зависеть
[10:05.320 --> 10:06.560]  от результатов предыдущей.
[10:06.560 --> 10:16.480]  Вот, логично ли звучит?
[10:16.480 --> 10:17.480]  Примеры хочется?
[10:17.480 --> 10:20.280]  Ну, давайте возьмем тот пример, который здесь,
[10:20.280 --> 10:21.280]  например, нарисован, хорошо.
[10:21.280 --> 10:28.960]  Давайте сейчас нарисуем, а после этого будем разбираться
[10:28.960 --> 10:29.960]  дальше.
[10:29.960 --> 10:35.280]  Вот, но если это табличка, в начале как она должна
[10:35.280 --> 10:38.280]  быть заполнена?
[10:38.280 --> 10:53.480]  Это D0, везде L, кроме диагонали.
[10:53.480 --> 10:57.120]  Мы считаем, что все-таки сами элементы в себе будут,
[10:57.120 --> 10:59.120]  правильно?
[10:59.240 --> 11:01.240]  Согласно?
[11:01.240 --> 11:03.240]  А?
[11:03.240 --> 11:11.320]  Сейчас, петли могут быть, вот, если вопрос с петлями
[11:11.320 --> 11:16.680]  правильный, а какой он будет в отрицательных циклах
[11:16.680 --> 11:19.440]  и вот будут ли отрицательные петли, что они будут делать
[11:19.440 --> 11:20.440]  здесь?
[11:20.440 --> 11:22.760]  Действительно, если мы зафиксируем эту вершину, мы посмотрим
[11:22.760 --> 11:27.040]  путь через нее и увидим, что у нас все соходится.
[11:27.040 --> 11:29.240]  У меня же повторяющиеся вершины тоже будут от себя
[11:29.240 --> 11:30.240]  до себя.
[11:30.240 --> 11:35.920]  Вот, нолики, все остальное это бесконечности.
[11:35.920 --> 11:40.200]  Дальше я начинаю это обновлять, я фиксирую нулевую вершинку
[11:40.200 --> 11:43.760]  и говорю, ага, теперь смотрим все пути через эту вершину.
[11:43.760 --> 11:47.520]  Что у меня происходит?
[11:47.520 --> 11:55.040]  Какие обновятся, во-первых, эти вершины?
[11:55.040 --> 12:15.320]  Один, три, ну, смотрите, четыре, два, обновится, обновится.
[12:15.320 --> 12:29.320]  Вот у меня четыре, два, обновится здесь и станет четыре.
[12:29.320 --> 12:36.560]  Четыре, нет, почему.
[12:36.560 --> 12:56.200]  Ну, ты просто смотришь, у тебя есть вот это?
[12:56.200 --> 12:57.200]  Ребра эти есть или нет?
[12:57.200 --> 13:05.320]  Боже, нет, нет, нет, мы фиксируем конкретную вершину и идем
[13:05.320 --> 13:06.320]  через нее.
[13:06.320 --> 13:15.760]  Да, именно эту вершину фиксируем только и только
[13:15.760 --> 13:19.040]  к ней ходим, типа вот из четыре я должен в ноль прийти
[13:19.040 --> 13:23.240]  и из нуля в два, в этом случае пара четыре, два работает.
[13:23.240 --> 13:30.880]  Вот, и в действительности как бы в дальнейшем мы будем
[13:30.880 --> 13:34.080]  работать именно с этим и смотреть, что там дальше
[13:34.080 --> 13:35.080]  происходит.
[13:35.080 --> 13:37.520]  Если рассматривать эту табличку еще дальше, то
[13:37.520 --> 13:40.400]  в этом случае, когда у нас пара будет четыре, два,
[13:40.400 --> 13:42.800]  мы зафиксируем какую-нибудь новую вершину и попробуем
[13:42.800 --> 13:45.600]  походить еще через что-нибудь и так далее.
[13:45.600 --> 13:49.680]  И когда мы дойдем до третьей, до третьей вершинки, у
[13:49.680 --> 13:51.880]  нас будет, смотрите, до четыре, два я могу дойти
[13:51.880 --> 13:54.800]  до четыре, а в то же время до четыре, два я могу пройти
[13:54.800 --> 13:59.720]  через три и будет стоимость два и обновим.
[13:59.720 --> 14:02.560]  Как я это сделаю?
[14:02.560 --> 14:05.640]  Смотрите, я буду смотреть, а какое у меня вообще расстояние
[14:05.640 --> 14:08.300]  есть до четырех, какое у меня есть расстояние до
[14:08.300 --> 14:10.360]  двух и от этого входим.
[14:10.360 --> 14:12.840]  Вот, давайте чуть более подробно.
[14:12.840 --> 14:13.840]  Смотрите.
[14:13.840 --> 14:14.840]  Да.
[14:14.840 --> 14:25.840]  Четыре, пять, четыре, два, да.
[14:25.840 --> 14:31.280]  Вот, смотрите, ну что такое D0XY?
[14:31.280 --> 14:35.840]  Мы с вами уже говорили, что D0XY вообще в самом начале,
[14:35.840 --> 14:39.800]  в действительности, мы, чтобы вот не ходить вот таким
[14:39.800 --> 14:42.520]  вот путем, как мы сейчас делали, и вот не обновлять
[14:42.520 --> 14:45.800]  вот по одной ячейке очень долго, давайте с самого
[14:45.800 --> 14:49.480]  начала зафиксируем, что нулевая его часть, то есть то, когда
[14:49.480 --> 14:51.840]  у нас только появляется эта табличка, у нас будет
[14:51.840 --> 14:55.720]  равна весам все, которые есть.
[14:55.720 --> 14:59.800]  То есть вот все, что у нас с вами здесь было в действительности,
[15:00.200 --> 15:03.360]  мы возьмем и сразу скажем, что, ага, ну у нас же есть
[15:03.360 --> 15:05.680]  прямые пути, правильно?
[15:05.680 --> 15:09.520]  Вот, эти все прямые пути мы добавим, то есть фактически
[15:09.520 --> 15:13.000]  с самого начала, вот эту четверку пока сотру, у меня
[15:13.000 --> 15:22.760]  будет здесь 4, 0, это 1, у меня будет 4, 3, это 1, что там,
[15:23.480 --> 15:36.840]  0, 2, это 3, 0, 5, это 1, тут, тут, тут, давайте с единички
[15:36.840 --> 15:43.960]  начнем, а в единичке ничего, в двойке 2, 1, правильно?
[15:43.960 --> 15:54.720]  3, 2, 1, это 1, вот, тройки, тройки, это 3, 2, это 1, и это все,
[15:54.720 --> 16:03.760]  и в пятерке это 5, 1, да, правильно, правильно, вот,
[16:03.760 --> 16:07.040]  мы начнем вот с этого момента, ну потому что это прям
[16:07.040 --> 16:10.840]  ровный путь между вершинками, согласны?
[16:10.840 --> 16:18.400]  Вот, это отлично, что мы дальше, а, знаем, смотрите,
[16:18.400 --> 16:23.320]  если, вот как вы думаете, чему равен вот обновление
[16:23.320 --> 16:28.120]  вот этой таблицы, в случае, если вот у нас есть к плюс
[16:28.120 --> 16:32.000]  первая какая-то вершина, ну фактически катая, номер
[16:32.000 --> 16:34.400]  ее катый, таблица будет к плюс первая.
[16:41.680 --> 16:47.880]  Мы говорим, что, знаете, мы говорим, что дкт это пути,
[16:47.880 --> 16:52.320]  которые меньше, чем к, используют вершины, с номерами меньше,
[16:52.320 --> 16:57.920]  чем к, с нулевая это вот просто вот эту, без обновления
[16:57.920 --> 17:08.520]  одной вот этой штучки, на один побольше, нет, смотрите,
[17:08.520 --> 17:10.800]  давайте еще раз, хорошо, я возможно вас допутал,
[17:10.800 --> 17:19.120]  простите, пожалуйста, смотрите, дкт, само по себе, это минимальное
[17:19.120 --> 17:29.280]  расстояние, минимальное расстояние, проходящее
[17:29.280 --> 17:49.640]  через вершины, с номером, меньше к, меньше к, ага, вот
[17:49.640 --> 17:54.560]  здесь, так нет, прямые пути, у них ничего не проходит
[17:54.560 --> 18:02.880]  путь, д нулевое, не через одну вершину не проходит
[18:02.880 --> 18:09.520]  прямой, вот, смотрите, теперь вопрос, дк плюс первый,
[18:09.520 --> 18:13.640]  чмо он равен, если мы знаем, что кратчайший путь у нас
[18:13.640 --> 18:27.320]  не будет идти через вершину к, нет, пока мы не обновили,
[18:27.320 --> 18:33.720]  вот, д1 мы бы обновили, смотрите, да, д1, вот, если бы я добавил
[18:33.720 --> 18:40.000]  нулевой вершины, посмотрел пути через нее, ну, давайте
[18:40.000 --> 18:44.800]  хорошо, давайте д1 отмечу еще раз, вернемся к этому
[18:44.800 --> 19:02.920]  примеру, д1, да, тут соря, вот, тут ошибся, раз, два,
[19:02.920 --> 19:13.560]  три, четыре, пять, перебрал, раз, два, три, четыре, пять,
[19:13.560 --> 19:21.400]  а чо у нас тут нули, здесь у меня единичка, единичка,
[19:21.400 --> 19:26.240]  единичка, единичка, единичка, единичка, тройка единичка,
[19:26.240 --> 19:37.560]  да, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, ну, теперь смотрите,
[19:37.560 --> 19:45.120]  чо с этим делаем, я говорю, ага, теперь, д1, оно что делает,
[19:45.120 --> 19:48.720]  оно должно пройти через нулевую вершинку, ну, теперь вот
[19:48.720 --> 19:53.160]  я могу использовать эту нулевую вершину, что я смотрю, вот,
[19:54.000 --> 19:56.880]  заполнено бесконечности, через нулевую вершину у меня
[19:56.880 --> 20:04.680]  один путь, два, это 4, 2 и 4, 5, ну, вот я и ставлю, 4, 2, у
[20:04.680 --> 20:13.080]  меня будет 4, 4, 5, это будет 2, вот, все мое обновление
[20:13.080 --> 20:22.160]  пока, ага, вот, а теперь смотрите, давайте вернусь к вопросу,
[20:22.200 --> 20:24.600]  если у меня кратчайший путь не проходит через вершину
[20:24.600 --> 20:27.760]  k, то dk плюс 1, чему будет равен?
[20:35.200 --> 20:39.960]  dk тому, да, ну, то есть, смотрите, если кратчайший путь никак
[20:39.960 --> 20:44.480]  не проходит через нашу вершину, то, хоть добавляя, хоть не
[20:44.480 --> 20:46.880]  добавляя, у нас все равно кратчайший путь будет вести
[20:46.880 --> 20:51.280]  через другие вершинки, правильно, поэтому, как бы, ничего
[20:51.280 --> 20:56.040]  не изменится для нашей, для нашей вещи, вот, а если
[20:56.040 --> 20:58.880]  известно, что кратчайший путь идет через нашу вершину,
[20:58.880 --> 21:14.320]  значит, будет dk xk плюс dk ky, да, вот, ну и тогда в общем
[21:14.320 --> 21:16.480]  случае, чему будет dk плюс первое равно?
[21:16.480 --> 21:23.240]  Минимум из этих двух, все правильно, вот, то есть, мы
[21:23.240 --> 21:29.800]  возвращаемся вот к этой вот картинке, понятно, мы фиксируем
[21:29.800 --> 21:32.800]  конкретную вершину, смотрим, идем через нее или не через нее,
[21:32.800 --> 21:39.920]  все, это и есть алгоритм Floyd, в действительности, с точки
[21:39.920 --> 21:44.000]  зрения реализации это выглядит вот так, что вы делаете?
[21:44.000 --> 21:51.440]  Естественно, хранить типа k таблиц в таблиц не прикольно,
[21:51.440 --> 21:55.200]  храните одну, почему, потому что у нас каждая следующая
[21:55.200 --> 21:59.200]  итерация зависит от предыдущей, ни от чего дальше не зависит,
[21:59.200 --> 22:05.680]  согласны, вот, и пока что здесь трехмерная, хорошо,
[22:05.680 --> 22:08.600]  но подумайте на тему того, что они будут не зависеть,
[22:08.600 --> 22:12.120]  мы до этого сейчас дойдем, да, sorry, я говорю, что-то сегодня это,
[22:12.120 --> 22:18.320]  то есть, в общем-то, в действительности, что у нас происходит, у нас есть вот эта
[22:18.320 --> 22:23.360]  катная таблица, она зависит от каты, а k плюс первая таблица, она зависит от каты,
[22:23.360 --> 22:29.400]  вот, пока что в этой реализации, что мы должны сделать, мы должны пройтись по таблице от нуля
[22:29.400 --> 22:40.240]  до там, в этой табличке, вот, дальше пройтись по всем вершинам, по всем парам вершин и посмотреть,
[22:40.240 --> 22:48.960]  можем мы обновить, не можем мы обновить эту таблицу, согласны, ну вот, все, пока сложно
[22:48.960 --> 23:00.040]  выглядит или нет, понятно, как это написать, вот, единственное, что здесь у меня чуть-чуть косяк,
[23:00.040 --> 23:26.200]  хотя нет, нормально, в нулевом случае, в плане, или в каком, да,
[23:26.200 --> 23:42.320]  да, только путь, когда лежит через k, но в действительности надо, это нам будет помощь,
[23:42.320 --> 23:49.720]  почему надо, потому что мы не знаем, можем мы обновиться так или нет, ну, то есть, есть ли путь
[23:49.720 --> 23:55.800]  вообще какой-то из одной вершины в другой, это же проверить еще надо, что будет означать,
[23:55.800 --> 24:03.400]  что пути нету, вот, из v в k и с k в u, значит, хотя бы где-то здесь у нас как минимум там
[24:03.400 --> 24:09.640]  бесконечность возникнет, согласна, вот, в этом случае мы минимум пройдемся по вот этому,
[24:09.640 --> 24:18.120]  если ты хочешь, ты хочешь сократить количество действий, я так понимаю,
[24:18.120 --> 24:23.560]  все зависит от того, как будет выглядеть граф, то есть там он достаточно неплотный,
[24:23.560 --> 24:29.400]  который был на примере, если он будет плотный, там будут обновления больше, сильно больше,
[24:29.400 --> 24:38.000]  вот, а важный момент здесь следующий, заметьте, я сначала фиксирую таблицу k, а только потом
[24:38.080 --> 24:45.160]  рассматриваю все пары, то есть вот это fo k идет первым всегда, окей, фактически это просто три
[24:45.160 --> 24:53.640]  цикла в цикле, вот, ничего страшного, теперь следующий момент, следующий момент, это то,
[24:53.640 --> 24:59.520]  что чуть-чуть проговорился, в действительности вам не нужно хранить k таблику, у вас каждое
[24:59.520 --> 25:08.680]  последующее зависит от предыдущей, согласны, значит, можем хранить хотя бы две и уже неплохо,
[25:08.680 --> 25:14.160]  тогда в этом случае вы будете использовать просто предыдущие результаты и вот между собой их
[25:14.160 --> 25:19.320]  перекидывать, то есть сначала в одну записку, потом в другую, потом еще что-то и так далее,
[25:19.320 --> 25:29.720]  окей, нравится это, сколько памяти, давайте так, вопрос такой, сколько бы памяти задействовали,
[25:29.720 --> 25:39.440]  если бы мы так не сделали, в куб, а здесь в квадрат, уже неплохо, правда, вот, но я хочу
[25:39.440 --> 25:47.040]  сделать еще лучше, я хочу убрать эти две матрицы, я хочу оставить одну и в действительности не будет
[25:47.040 --> 26:04.920]  никакого аффекта в том, что вы возьмете и оставите эту одну матрицу, почему, все то же самое, только без матрицы,
[26:17.040 --> 26:26.240]  по сути своей это правда, то, что ты сейчас говоришь, кроме того, мы заполняем их вот таким вот образом,
[26:26.240 --> 26:32.840]  мы смотрим нулевую вершину в самом начале, когда ее добавляем, например, потом первую вершину,
[26:32.840 --> 26:37.200]  как только мы ее добавили, то есть мы смотрим вот в этом плане здесь именно таким образом,
[26:37.200 --> 26:45.480]  в действительности можно реализовывать это in place, здесь написано, что о памяти этот единичке,
[26:45.640 --> 26:52.400]  но это чуть-чуть может быть не так, почему, а все зависит от того, как вам даны все веса,
[26:52.400 --> 27:01.480]  если вам даны с помощью матрицы смежности, то все логично, у вас тисилки стоят, ну зачем вам
[27:01.480 --> 27:06.360]  создавать новую табличку, тогда у вас действительно будет этот единичке, а если вам дам список ребер,
[27:06.360 --> 27:14.360]  то в этом случае она будет в квадрат, но представьте, что ее так и далее, но у вас другого варианта нет,
[27:14.360 --> 27:19.880]  фактически сам алгоритм не будет использовать дополнительной памяти, вот вы использовали
[27:19.880 --> 27:29.120]  только то, что у вас есть матрица смежности, ага, вот в этом суть, вот, ну и все, вот это весь алгоритм,
[27:29.120 --> 27:41.640]  а дальше внутри этого всего мы увидим расстояние от x до y, можем ли мы вообще дойти, понятно,
[27:41.640 --> 27:54.800]  сложно, нет, это чудесно, вот, а в действительности, в действительности,
[27:54.800 --> 28:01.280]  а почему это можно, ну как бы здесь опять же нужно рассмотреть вот эти зависимости друг от дружки,
[28:01.280 --> 28:09.880]  а что вот если мы будем таким вот использовать типа и вот заглядывать на какие-то результаты,
[28:09.880 --> 28:14.520]  которые были в предыдущем шаге и возьмем не старые, а новые, изменится ли что-то,
[28:14.520 --> 28:18.760]  в действительности хуже ничего этого не сделает, поэтому это все будет ровно то же, что мне надо,
[28:18.760 --> 28:25.160]  вот, а как бы если у нас нету каких-то отрицательных циклов, то ничего не произойдет здесь,
[28:25.160 --> 28:30.720]  согласны, ну то есть не будет никаких вот этих вот круговорот, чудесно, а что с
[28:30.720 --> 28:44.800]  отрицательными циклами делать, как понять, что они есть, да, на диагонали окажется,
[28:44.800 --> 28:53.440]  что у нас какие-то отрицательные числа будут и в этом случае мы говорим, что у нас есть
[28:53.440 --> 29:10.280]  отрицательный цикл, все, есть ли тут вопросы, нет, все понятно, и все хорошо, окей, тогда мы с вами
[29:10.280 --> 29:16.920]  получаем, что у нас есть алгоритм Floyd, который всегда работает за V-куб и неважно у вас алгоритм,
[29:16.920 --> 29:26.200]  ой, у вас граф плотный или разреженный, без разницы, он всегда будет работать за V-куб, поэтому в
[29:26.200 --> 29:34.880]  моменте, когда у вас будет плотный граф и у вас будут веса отрицательного, ой,
[29:34.880 --> 29:43.840]  ребра отрицательного веса, в этом случае алгоритм Floyd полезен, а так как бы в других случаях он
[29:43.840 --> 29:51.840]  может занимать столько же времени, сколько там Форд Белман или Дейкстра, вот, это первый такой
[29:51.840 --> 30:00.880]  нюансик, теперь смотрите, начинается вот самое самое интересное, представим, представим такую
[30:00.880 --> 30:08.520]  картину, что я хочу все-таки, чтобы Дейкстра работала на отрицательных ребрах, что мне нужно
[30:08.520 --> 30:20.760]  сделать, мы чуть-чуть обсуждали этот прошлый раз, я сказал, подумайте, что для этого точно
[30:20.760 --> 30:30.040]  нужно сделать, нужно вести потенциал, кто помнит, что такое потенциал, какого флешбеки с амортизационного
[30:30.040 --> 30:42.160]  анализа, а, пункт С состояние, хорошо, почему потенциал, почему правильно вести какой-то потенциал,
[30:42.160 --> 31:00.600]  смотрите, здесь большинство с ПМФ или ПМИ, а, ну все, отлично, с ПМФ, смотрите,
[31:00.600 --> 31:15.920]  что означает потенциал физики, что она позволяет делать, хорошо, давайте другой вопрос задам,
[31:15.920 --> 31:21.640]  типа, с потенциалом, вот у вас есть земля и вот у вас есть здесь элемент, я могу вот так вот пройтись
[31:21.640 --> 31:29.520]  к какой-то другой части, не знаю, точки А до точки В, а могу вот так пройтись, будет ли у меня разница
[31:29.520 --> 31:36.320]  потенциала хоть как-то это зависеть, вот, здесь будет ровно так же, если мы с вами введем какую-то
[31:36.320 --> 31:46.600]  функцию потенциала, которая будет показываться в каждой вершине графа, то в этом случае, когда
[31:46.600 --> 31:51.560]  мы будем их вычитать, грубо говоря, вот у нас же что происходит, мы хотим с потенциалом попробовать
[31:51.560 --> 31:57.720]  сделать так, чтобы у нас он увеличивал расстояние и там что-то происходило, и вот это увеличение
[31:57.720 --> 32:03.520]  должно быть таким, чтобы оно зависело только от начальной и конечной точки, не зависело от пути,
[32:03.520 --> 32:15.040]  которые мы с вами проходим, а Dextra работает на графах, где у нас нет отрицательных ребер,
[32:15.040 --> 32:23.680]  я хочу, значит, избавиться от отрицательности ребер, просто прибавить всем не вариант, в прошлый
[32:23.680 --> 32:28.600]  раз мы с вами это посмотрели, правда, или есть вопросы, почему это не подходит,
[32:28.600 --> 32:41.760]  просто прибавить все, ребра, не знаю, плюс 100, репутация и мисс карисы, не знаю, вот так,
[32:41.760 --> 32:52.240]  все ли понимают, почему это не подходит, не только, даже если бы циклов не было,
[32:52.240 --> 33:09.920]  ну, почти что, смотрите, ладно, хорошо, давайте, я лучше подчерчу, у нас есть вот такой,
[33:09.920 --> 33:26.400]  вот такой вот путь, и смотрите, с одной стороны, я скажу, что, ага, ну вот у меня, не знаю, тут путь 100,
[33:26.400 --> 33:40.440]  вот, а здесь путь будет, не знаю, а 5, 7, 1, 3, ну вот где-то в графе там, где-то еще есть отрицательные
[33:40.440 --> 33:47.440]  ребра, ну, предположим, что они максимум 100, ну, отрицательные по модулю 100, давайте я попробую
[33:47.440 --> 33:56.120]  прибавить ко всему 100, что у меня будет проблема, у меня будет проблема в следующем, у меня здесь
[33:56.120 --> 34:15.760]  105, здесь 107, здесь 101, тут 103, а вот здесь 200, теперь смотрите, какой путь более выгодный, вначале путь
[34:15.760 --> 34:23.440]  был вот такой более выгодный, согласны, а теперь у меня более выгодный нижний, потому что сверху
[34:23.440 --> 34:30.560]  я прибавил по 100, и вот из-за того, что у меня количество ребер в этом пути другое, у меня увеличилась
[34:30.560 --> 34:39.880]  стоимость пути, что неправильно, я хочу избавиться от такого, мне, наоборот, такое нельзя, мне нужно
[34:39.880 --> 34:49.320]  вести некоторую функцию, то есть я хочу прибавить каждому ребру свой потенциал, разницу потенциалов
[34:49.320 --> 34:56.040]  от начала до конца, то есть в конечной точке до начальни, и тогда я буду понимать, как это работает,
[34:56.040 --> 35:04.800]  и тогда она будет не зависеть от пути, и тогда у нас все чудесно и прекрасно, ага, вот, это то, что я
[35:04.800 --> 35:16.800]  хочу здесь сделать, это называется алгоритм Джонсона, вот, а все окей, все хорошо, мы определяем новую
[35:16.800 --> 35:26.240]  какую-то весовую функцию на каждом из ребер, мы говорим, что пусть у нас новый вес ребра равен
[35:26.240 --> 35:33.920]  предыдущему весу ребра, плюс потенциал вершины, куда мы придем, ой, откуда мы придем, минус потенциал
[35:33.920 --> 35:42.960]  из вершины, где мы были, куда придем, ну вот, это разница потенциала, это все, что я хочу здесь
[35:42.960 --> 35:52.840]  добавить, могу так сделать, могу, то есть я должен вести потенциал для каждого из вершин, нужно
[35:52.840 --> 35:58.040]  понять, что у нас происходит, ну как изменится длина произвольной пути, да никак, у нас изменится на
[35:58.040 --> 36:05.640]  разницу потенциала, поэтому, если я захочу вернуться обратно к моменту, когда я был на нормальных
[36:05.640 --> 36:13.080]  ребрах и не изменял их никак, то я просто должен буду вычесть потенциалы начала и конца, вот эту
[36:13.080 --> 36:18.480]  разницу, согласны, потому что я буду ее понимать, то есть я хочу найти там, не знаю, расстояние от В до У,
[36:18.480 --> 36:27.280]  вот я вычил расстояние до У, ой, потенциал до У, прибавил потенциал до В, получил действительно
[36:27.280 --> 36:43.200]  свою весовую функцию. Окей, есть ли тут вопроса? Осталось понять. А следующий, а? А следующий вопрос, изменится ли
[36:43.200 --> 36:48.360]  кратчайший путь вообще, сам по себе? Нет, почему? Потому что вот из-за того, что мы будем прибавлять,
[36:48.360 --> 36:53.200]  убавлять потенциалы, у нас всегда останется вот эта разница потенциалов одна и та же, мы это с вами
[36:53.200 --> 37:03.320]  тоже сейчас сделаем. А изменится ли вес любого цикла? Не изменится, почему? Потому что мы в начало
[37:03.320 --> 37:10.320]  пришли, в начало, в начало пришли, в начало пришли, значит мы просто прибавили потенциал в этой точке,
[37:10.320 --> 37:19.520]  убавили потенциал в этой точке, получили ноль. Отлично. И теперь следующее, ну как бы мы с вами
[37:19.520 --> 37:28.200]  понимаем, что нам осталось придумать этот потенциал. Как бы в теории звучит все хорошо,
[37:28.200 --> 37:37.880]  осталось придумать это на практике. У кого какие идеи? Это не совсем хорошо, потому что представь,
[37:37.880 --> 37:42.360]  что у тебя есть продолжение пути в виде того, где не отрицательное ребро, и тебе нужно дойти еще.
[37:42.360 --> 37:58.080]  У тебя путь изменится тогда, у тебя может измениться путь. Вот. А сильно вас этим мучать не буду,
[37:58.080 --> 38:06.400]  объясню почему. Я б тоже не догадался, поэтому все хорошо. Книжки просто почитал умные и все,
[38:06.400 --> 38:14.480]  и я здесь. Но в действительности, смотрите, как это выглядит. У вас есть некоторый граф G. Что вы
[38:14.480 --> 38:27.680]  делаете? Формально, когда описывали алгоритм Джонсона, говорилось следующее. Давайте добавим
[38:27.680 --> 38:42.640]  фиктивную вершину. От этой фиктивной вершины проведем ребра во все остальные вершины и скажем,
[38:42.640 --> 39:02.760]  что все эти ребра весит 0. Следующий шаг. Давайте отрелаксируем все ребра. Фактически запустим
[39:02.760 --> 39:15.680]  алгоритм Форд Белмана. И тогда я в этом случае что сделаю? Найду кратчайшие пути от каждой вершины
[39:15.680 --> 39:26.640]  до вершины через вот эту вершинку. Почти всегда. Правильно? Тут 0, тут 0. Вот она проходит через нее. Вот.
[39:26.640 --> 39:39.560]  Если у нас был бы отрицательное число здесь какое-нибудь, то есть у нас бы появились бы новые отрицательные
[39:39.560 --> 39:54.360]  какие-нибудь штуки. Вот. Чудесно. Вот это оно в действительности и будет. Фактически мы говорим следующее.
[39:54.360 --> 40:01.640]  Вот здесь есть теорема Джонсона, который он и брал, что мы добавляем вот эту фиктивную вершину. Из нее
[40:01.640 --> 40:14.640]  исходят все ребра веса 0. Запускаем алгоритм Форда Белмана и находим кратчайшие расстояния от этой
[40:14.640 --> 40:22.640]  фиктивной вершины до остальных вершин. Все оно не нулевое, оно может быть отрицательное еще как-то.
[40:22.640 --> 40:27.760]  Почему? Ну потому что я могу вот либо по нулевой вершине пройтись, либо вот здесь вот у меня есть
[40:27.760 --> 40:38.800]  там минус 5. Я в этом случае дойду сюда через минус 5. Вот запускаю алгоритм Форда Белмана,
[40:38.800 --> 40:47.040]  нахожу и тогда в этом случае получаю некоторое число. Вот это число, которое является кратчайшим
[40:47.040 --> 40:58.040]  расстоянием будет потенциалом. Вот. Потенциал вершины, то есть это будет то кратчайшее расстояние
[40:58.040 --> 41:04.160]  от нашей вершины, фиктивной, которая есть, до всего остального. Ну какое здесь доказательство?
[41:04.160 --> 41:13.920]  Смотрите, я говорю следующее, что пусть у меня есть некоторый вес ребра с потенциалами. Он равен
[41:13.920 --> 41:21.480]  весу самого ребра плюс потенциал вершины В минус потенциал вершины У. Это хорошо. В этом случае
[41:21.480 --> 41:26.560]  тогда я возьму и скажу, что у меня является потенциалом. Я говорю, что потенциалом в этом
[41:26.560 --> 41:33.680]  случае является вот это кратчайшее расстояние от вершины фиктивной. Там у меня названа эта звезда.
[41:33.680 --> 41:48.200]  От вершины С-звездочка до вершины В минус расстояние от С до У. Почему оно больше либо равно нуля?
[41:48.200 --> 42:14.400]  С-в-в-у. Он не короче, давай так скажу. Ну то есть да, подразумевается следующее. Вот у меня есть
[42:14.400 --> 42:22.800]  эта звездочка, у меня она указывает в какую-то вершину В и у меня есть какая-нибудь вершина У. Вот,
[42:22.800 --> 42:29.640]  я подразумеваю следующее, что кратчайший путь от вершины С до вершины У, он может пролегать через
[42:29.640 --> 42:38.480]  какие-то другие вершины. Он явно не должен быть больше, чем просто путь из вершины С-звездочка в
[42:38.480 --> 42:47.720]  В. Согласны? Потому что это не факт, что кратчайший путь. Вот, значит последний у нас больше либо равно нуля.
[42:47.720 --> 42:59.120]  А тогда, если оно больше либо равно нуля, то мы получаем что? Что веса всех ребер не отрицательны.
[42:59.120 --> 43:06.080]  Согласны? А если у нас веса всех ребер не отрицательны, то что мы можем сделать?
[43:06.080 --> 43:14.520]  То запустите алгоритм Д-экстры. Да, именно так это и выглядит. То есть, фактически, алгоритм
[43:14.520 --> 43:21.520]  Джонсона звучит таким образом. Добавляем фиктивную вершину с нулевыми ребрами во все остальные вершины.
[43:21.520 --> 43:28.040]  Ищем кратчайшие пути для всех вершин, которые у нас есть с помощью алгоритма Форда Белмана.
[43:28.040 --> 43:37.800]  Смотрите, смотрите.
[43:37.800 --> 43:57.960]  Не совсем так. А вопрос примерно в следующем. За сколько? Ну, у нас как бы, да, это может
[43:57.960 --> 44:06.160]  все работать за ВЕ. Это прикольно, еще что-то. Но в действительности все будет завязано как раз
[44:06.160 --> 44:12.840]  таки на этих отрицательных ребрах и так далее. Алгоритм Д-экстры очень понятно, как формулируется,
[44:12.840 --> 44:19.280]  он не очень долго работает сам по себе. Но что здесь важно понимать? Важно понимать здесь
[44:19.280 --> 44:24.480]  следующее. А вот с помощью вот этого алгоритма Джонсона мы найдем расстояние от одной вершины
[44:24.480 --> 44:48.880]  до всех остальных. Или от всех до всех? От всех до всех. Да? Или нет? Ага. С со звездой вести
[44:48.880 --> 44:55.600]  ее изначально. На самом деле, вам ее вводить даже не нужно будет с точки зрения реализации. Ну,
[44:55.600 --> 45:04.080]  это следующий момент, когда я того же скажу. Вопрос следующий. Смотрите, а за сколько у нас
[45:04.080 --> 45:17.200]  работает Д-экстра? За ЕЛУКВ, предположим. За сколько работает Форд Белман? За ВЕ. Вот если я в раз буду
[45:17.200 --> 45:25.080]  запускать Форд Белмена, то у меня будет работать за В квадрат Е. А если я в раз буду запускать Д-экстра,
[45:25.080 --> 45:33.240]  то оно будет работать и один раз Форд Белман, то это будет ВЕ плюс ВЕЛУКВ. Что из этого лучше?
[45:33.240 --> 45:36.680]  Ну, то есть давайте еще раз. Сравнение следующее.
