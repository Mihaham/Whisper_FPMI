[00:00.000 --> 00:11.640]  Так, сегодня у нас с вами седьмая встреча.
[00:11.640 --> 00:20.760]  Начинаем, да.
[00:20.760 --> 00:27.840]  Значит, мы, наверное, заканчиваем с кучами, мы, я напомню,
[00:27.840 --> 00:31.280]  и двоичную, и биномиальную на лекциях.
[00:31.280 --> 00:33.680]  Сегодня еще немножко посмотрим на примерах.
[00:33.680 --> 00:35.960]  Вот там в семинаре была задача, если у вас уже было
[00:35.960 --> 00:38.400]  про инсерт в биномиальную кучу, что если у вас нет
[00:38.400 --> 00:41.240]  других операций, то инсерт в биномиальную работает
[00:41.240 --> 00:42.760]  амортизировано за от и днице.
[00:42.760 --> 00:46.160]  Вот сегодня мы поймем, что такое за амортизировано,
[00:46.160 --> 00:47.160]  что это значит, да.
[00:47.160 --> 00:49.200]  И в прошлый раз я тоже немножко про это говорил, строго
[00:49.200 --> 00:52.400]  ведем определение, докажем, почему в биномиальной куче
[00:52.400 --> 00:55.360]  инсерт амортизировано за от и днице работает, если
[00:55.360 --> 00:56.360]  нет других операций.
[00:56.520 --> 01:00.440]  Ну еще в конце, насколько останется времени, мы посмотрим
[01:00.440 --> 01:01.440]  на спарстейбл.
[01:01.440 --> 01:05.880]  Так, пока что мы начнем с амортизационного анализа.
[01:05.880 --> 01:16.880]  Анализ.
[01:16.880 --> 01:18.040]  Идея здесь следующая.
[01:18.040 --> 01:20.640]  Допустим, мы реализуем какую-то структуру данных, скажем,
[01:20.640 --> 01:30.760]  биномиальная куча, и она умеет обрабатывать какие-то
[01:30.760 --> 01:31.760]  запросы.
[01:31.760 --> 01:34.640]  Раньше у нас там были всякие декрески, инсерт, экстрактмин
[01:34.640 --> 01:35.640]  и так далее.
[01:35.640 --> 01:39.680]  Ну вот пусть есть, скажем, N типов запросов.
[01:39.680 --> 01:41.320]  Нет, давайте не N, давайте Q типов запросов.
[01:41.320 --> 01:46.280]  Q типов запросов к ней.
[01:47.280 --> 01:51.640]  Первый тип запроса это сделать что-то с кучей, ну или с нашей
[01:51.640 --> 01:52.640]  структурой.
[01:52.640 --> 01:54.600]  Второй тоже что-то сделать и так далее, кутый запрос
[01:54.600 --> 01:55.600]  тоже что-то сделать.
[01:55.600 --> 01:59.560]  Пусть также нам заданы какие-то функции, вот для каждого
[01:59.560 --> 02:02.120]  из этих запросов, для каждого, точнее, из типов запросов,
[02:02.120 --> 02:03.360]  у нас есть какая-то своя функция.
[02:03.360 --> 02:12.600]  T1 от N, T2 от N и так далее, TQ от N.
[02:12.600 --> 02:27.320]  Да, мы будем говорить, определение, будем говорить, что ТИТ это
[02:27.320 --> 02:40.760]  амортизированное или что-то же самое учетное.
[02:40.920 --> 02:47.560]  Время обработки этого запроса, точнее, время обработки
[02:47.560 --> 02:57.560]  запроса этого типа, если выполнять следующее условие.
[02:57.560 --> 03:00.920]  Значит, смотрите, есть у меня вот эти вот Q функции,
[03:00.920 --> 03:03.800]  которые как бы говорят, до сколько работает каждый
[03:03.800 --> 03:04.800]  тип запрос.
[03:04.800 --> 03:09.480]  Но на самом деле, каждый конкретный запуск запроса
[03:09.560 --> 03:12.120]  возможно, будет работать дольше, чем вот эта заявленная
[03:12.120 --> 03:12.920]  функция.
[03:12.920 --> 03:16.200]  Вот здесь написано какое-нибудь декресски, если мы говорим,
[03:16.200 --> 03:18.080]  что это амортизированно работать за от 1.
[03:18.080 --> 03:22.120]  Ну, то есть, вот это вот T2 аут N, равно простоpiano, то
[03:22.120 --> 03:25.360]  возможно, на каких-то конкретных запусках, на каких-то конкретных
[03:25.360 --> 03:27.700]  обработках этого запроса, мы будем работать дольше,
[03:27.700 --> 03:28.700]  чем от 1.
[03:28.700 --> 03:32.040]  Но если мы все просуммируем, то можно считать, что суммарно
[03:32.040 --> 03:34.360]  каждый из них обработан Crossing от 1.
[03:34.360 --> 03:36.360]  Значит, это мы здесь сейчас строго сформируем.
[03:36.360 --> 03:43.360]  Если для любого n и для любой последовательности из n запросов,
[03:43.360 --> 03:53.360]  я напишу так, для любого q1, не так, qi1, qi2 и так далее qin,
[03:53.360 --> 04:14.360]  запросы к структуре s, время обработки этих запросов есть o большое
[04:14.360 --> 04:19.360]  от суммы времен вот этих вот учетных обработки всех запросов.
[04:19.360 --> 04:27.360]  То есть сумма по i, давайте, по g от 1 до n, t, i, t, g, t от n.
[04:31.360 --> 04:33.360]  Значит, вот такое громоздкое формальное определение.
[04:33.360 --> 04:38.360]  Еще раз, какой здесь смысл? Есть у меня q типов запросов и какие-то учетные стоимости,
[04:38.360 --> 04:41.360]  просто какие-то функции с ними связанные, t1 и так далее tq.
[04:41.360 --> 04:51.360]  Тогда мы говорим, что это действительно амортизированное время обработки каждого запроса.
[04:51.360 --> 04:54.360]  Если какую бы последовательность запросов мы не подали,
[04:54.360 --> 04:58.360]  значит, здесь q это означает, что запрос, индекс это означает, какого он типа.
[04:58.360 --> 05:02.360]  Скажем q1, q5, q7 и так далее, значит, вот какого типа запрос.
[05:02.360 --> 05:06.360]  Вот один из этих q. Давайте подпишем, что и 1, и 2 и так далее.
[05:06.360 --> 05:09.360]  Это типы запросов, то есть это числа от 1 до q.
[05:12.360 --> 05:20.360]  Тогда суммарное время их обработки не больше, чем если мы просуммируем t с соответствующими индексами.
[05:22.360 --> 05:29.360]  Пример. Пусть к нашей структуре поступают запросы q1, q3, q2, q1.
[05:30.360 --> 05:35.360]  Тогда вот те t, которые я там написал, являются учетными амортизированными стоимостими,
[05:35.360 --> 05:43.360]  если время работы есть o большое от t1 от 4, получается, раз у меня 4 запроса.
[05:43.360 --> 05:50.360]  t1 от 4, t3 от 4, t2 от 4, t1 от 4.
[05:50.360 --> 05:56.360]  Ну, тут уже поскольку у меня все константное, то лучше здесь писать не o большое, а какой-то констант.
[05:56.360 --> 06:02.360]  Давайте напишу, что время работы не большим какая-то константом нужно эту сумму.
[06:06.360 --> 06:08.360]  Можно еще сказать следующее.
[06:08.360 --> 06:14.360]  Смотрите, вот это какие-то странные функции, которые, повторюсь, не обязательно равны настоящему времени работы на каждой такой террации.
[06:14.360 --> 06:19.360]  Это на самом деле какое-то перераспределение времен работы по вот этим типам операций.
[06:19.360 --> 06:24.360]  Например, есть у вас, как я сказал, здесь, например, второй тип запроса.
[06:24.360 --> 06:29.360]  В принципе, там может быть такое, что он обрабатывается довольно долго, скажем, за линейное время.
[06:29.360 --> 06:32.360]  Но, например, t2 от n у вас это константы единиц.
[06:32.360 --> 06:36.360]  То есть, как бы, в среднем вы делаете за единицу, обычно вы делаете там одно-два действия,
[06:36.360 --> 06:43.360]  но иногда бывают такие запросы, которые вам приходится обрабатывать за o от n, точнее, за ω от n за линейное время.
[06:43.360 --> 06:47.360]  Тогда, как бы, вот вы это n, то есть если такие запросы редкие,
[06:47.360 --> 06:53.360]  то вы можете как бы вот этот n так распихать либо по остальным запросам, либо по запросам того же типа,
[06:53.360 --> 06:57.360]  что в сумме это n как бы учтется в остальных t-шках.
[06:57.360 --> 07:01.360]  То есть вы как бы перераспределяете время тяжелых операций либо на остальные запросы,
[07:01.360 --> 07:05.360]  либо на запросы того же типа, ну просто на другие запросы того же типа.
[07:05.360 --> 07:11.360]  Скажем, если у вас вот здесь много единиц и мало n-ок, то это n вы можете как бы распихать по остальным единичкам,
[07:11.360 --> 07:18.360]  единички станут двойками, и сумма там увеличится в два раза, что останется в терминах у большого, останется корректным.
[07:20.360 --> 07:22.360]  Вот такое определение.
[07:23.360 --> 07:39.360]  Так, тогда, да, у нас сейчас будет пример чуть позже, у нас будет пример про динамический массив или вектор.
[07:39.360 --> 07:46.360]  Динамический массив, то, что в плюсах, это STD-вектор.
[07:46.360 --> 07:50.360]  Значит, это такая структура данных, которая позволяет хранить массив,
[07:50.360 --> 07:55.360]  который еще также умеет расширяться вправо или наоборот сокращаться вправо.
[07:55.360 --> 08:00.360]  То есть у него есть операции push-back и pop-back, удалить последний элемент, добавить последний элемент.
[08:00.360 --> 08:02.360]  Это мы еще чуть позже все напишем.
[08:02.360 --> 08:08.360]  И оказывается, что амортизированное время работы всех этих операций, это от единицы.
[08:08.360 --> 08:12.360]  Давайте я напишу вот так, вот со звездочкой это как раз значит, что оно амортизированное.
[08:12.360 --> 08:15.360]  Амортизированное, амортизированное.
[08:15.360 --> 08:20.360]  То есть какие-то конкретные операции push-back, pop-back, они могут работать довольно долго.
[08:20.360 --> 08:25.360]  У нас там будут такие будут тяжелые операции push-back, pop-back, которые работают ω от n,
[08:25.360 --> 08:27.360]  где n это текущая длина массива.
[08:27.360 --> 08:34.360]  Но в среднем, если вы просуммируете все время работы алгоритма, у вас получится O от общего числа операций.
[08:34.360 --> 08:40.360]  То есть как бы можно считать, хоть у вас и есть какие-то тяжелые операции, но можно считать, что каждый из них работает за единицу,
[08:40.360 --> 08:45.360]  тогда сумма как раз будет, сумма вот этих вот единичек, будет верхней оценкой на время работы.
[08:45.360 --> 08:50.360]  Вот, значит, потом на этом примере мы еще, ну то есть мы его чуть позже разберем,
[08:50.360 --> 08:54.360]  пока я введу метод, как можно эти т-шки находить.
[08:54.360 --> 08:57.360]  Потом на примере поймем, что вот там все единички подходят.
[09:10.360 --> 09:23.360]  Так, значит, есть такой метод, называется метод монеток или метод бухучета, метод бухгалтерского учета.
[09:23.360 --> 09:39.360]  Идея следующая, смотрите, мы уже поняли, что наша цель в каком-то смысле, вот чтобы получить эти т-шки,
[09:39.360 --> 09:44.360]  нам нужно как-то перераспределить время, которое мы тратим на редкие тяжелые операции каждого типа,
[09:44.360 --> 09:50.360]  ну вот скажем здесь, обычно как сделать pushback, ну просто там скажем, мы будем хранить массив побольше размера,
[09:50.360 --> 09:53.360]  и чтобы сделать pushback, мы просто сюда положим очередное число.
[09:53.360 --> 09:58.360]  Чтобы сделать popback, мы просто как бы про это число забудем и передвинем указатель на конец чуть-чуть влево.
[09:58.360 --> 10:03.360]  То есть как бы обычно эти операции очень простые, просто хранить массив в два раза большего размера,
[10:03.360 --> 10:09.360]  класть число в нужную позицию или там, ну просто про него забывать и сдвигать указатель на конец на один, то есть обычно это просто.
[10:09.360 --> 10:16.360]  Но иногда нам придется, когда, например, все вот эти ящики заняты, нам придется выделить вот здесь вот себе еще много места,
[10:16.360 --> 10:23.360]  чтобы положить сюда новое число, у нас будет такой алгоритм, что он выделяет себе столько нового места, сколько у него сейчас занят.
[10:23.360 --> 10:28.360]  И вот эта операция будет тяжелая. То есть мы потратим столько времени, какая у нас сейчас длина массива.
[10:28.360 --> 10:31.360]  То есть мы не за единицу работаем, а как бы за текущую длину.
[10:31.360 --> 10:38.360]  Но в среднем, если мы вот эту вот тяжелую операцию, которая редкая, понятно, что нам редко приходится раздувать в два раза,
[10:38.360 --> 10:45.360]  если мы эту операцию как бы распределим по другим операциям того же типа, то как бы получится, что в среднем мы делаем от 1 до 10.
[10:45.360 --> 10:52.360]  А также и здесь. Мне нужно как бы перераспределить время, которое я трачу на тяжелой операции, по другим операциям.
[10:52.360 --> 10:57.360]  Значит, вот как работает метод монеток. У нас есть какой-то банковский счет,
[11:00.360 --> 11:09.360]  на который мы можем вносить деньги. Вносим и снимаем с него деньги. Вносим и снимаем деньги.
[11:09.360 --> 11:16.360]  И смотрите, когда мне приходит какая-то простая операция, которую я могу быстро отработать,
[11:16.360 --> 11:23.360]  которую я могу быстро обработать, я просто ее быстренько делаю и могу себе еще положить на банковский счет несколько монеток, несколько рублей.
[11:23.360 --> 11:32.360]  Это значит, что я быстро обработал запрос, а еще на будущее как бы себе дал время, себе дал возможность с помощью этих монеток,
[11:32.360 --> 11:37.360]  время, которое я затрачу в будущем на какую-то тяжелую операцию, его как бы занять из текущего времени.
[11:37.360 --> 11:44.360]  То есть я сейчас говорю, ага, вот сейчас мне очень хорошо ел простой запрос, я отдыхаю, и давайте вот это время, которое я как бы экономлю,
[11:44.360 --> 11:48.360]  я его учту себе, вот внесу денюжки, которые я сейчас экономлю, на банковский счет.
[11:48.360 --> 11:55.360]  А потом, когда придет тяжелая операция, я на нее отвечу с помощью тех монеток, с помощью того времени, которое я накопил до этого.
[11:55.360 --> 12:04.360]  То есть были простые запросы легкие, они вносили какие-то монетки, и теперь я эти монетки буду снимать со счета, и за их счет буду отвечать на тяжелый запрос.
[12:05.360 --> 12:06.360]  Вот такая примерная идея.
[12:08.360 --> 12:12.360]  Ну давайте скажем следующее, как он работает.
[12:14.360 --> 12:23.360]  Пусть поступают запросы, давайте я напишу просто индексы q1, q2 и так далее, qn,
[12:25.360 --> 12:28.360]  и мы знаем реальное время обработки каждого из них.
[12:29.360 --> 12:31.360]  Реальное время обработки.
[12:35.360 --> 12:38.360]  Это t1, t2 и так далее, tn.
[12:41.360 --> 12:48.360]  И как бы в среднем, если у нас есть запрос какого-то одного типа, и мы знаем, что в среднем это простой запрос,
[12:48.360 --> 12:53.360]  но иногда встречаются такие выбросы, что они t и t, какое-то очень большое одно,
[12:54.360 --> 12:59.360]  и если его вот так распределить по остальным, то в среднем будет маленькое число, ну или там сумма небольшая.
[13:00.360 --> 13:02.360]  Тогда давайте скажем следующее.
[13:03.360 --> 13:20.360]  Пусть во время обработки этого запроса мы кладем в банк сколько-то монеток и снимаем с банковского счета тоже сколько-то монеток.
[13:23.360 --> 13:33.360]  Кладем на счет DIT монет, DIT от слова депозит, а также снимаем сколько-то монет.
[13:38.360 --> 13:46.360]  WIT, WIT тоже от слова снять, снять деньги со счета.
[13:47.360 --> 13:57.360]  Тогда я утверждаю, что вот такая величина равная реальному времени плюс числу внесенных монеток, минус числа снятых монеток,
[13:58.360 --> 14:02.360]  такая величина и будет являться учетной стоимостью WIT-го запроса.
[14:04.360 --> 14:13.360]  Учетная, то есть амортизированная стоимость WIT-го запроса.
[14:16.360 --> 14:23.360]  И это как раз отражает ту интуицию, которую я в начале пытался сформировать.
[14:24.360 --> 14:28.360]  Что такое WIT-го запрос? Сначала вы как-то на него отвечаете за какое-то реальное время WIT-го.
[14:29.360 --> 14:31.360]  Вам нужно сделать реально WIT-го действия.
[14:32.360 --> 14:38.360]  Затем, если у вас этот запрос простой и, скажем, WIT-го маленькое, то вы можете еще какое-то время фиктивно поработать,
[14:38.360 --> 14:48.360]  при этом положив в банк WIT монет, и считаем, что эти монетки, которые я себе на будущее кладу, мы их учитываем в текущем амортизированном времени, плюс WIT.
[14:49.360 --> 14:58.360]  А если, наоборот, WIT слишком большое, то я пытаюсь, наоборот, из банка взять много денег WIT, так чтобы эта разность была поменьше.
[14:59.360 --> 15:04.360]  То есть я как бы занимаю у себя прошлого время, то есть я когда-то его отложил, теперь я его забираю.
[15:05.360 --> 15:10.360]  И если TIT примерно такой же, как WIT, то вот это будет от 1, например.
[15:11.360 --> 15:17.360]  То есть чем больше WIT, тем больше я уменьшаю себе учетное время работы.
[15:29.360 --> 15:36.360]  Так, ну давайте я напишу это утверждение строго.
[15:37.360 --> 15:45.360]  Пусть на нашем счету, на банковском счету число монет всегда не отрицательно.
[15:48.360 --> 15:54.360]  Число монет всегда не отрицательно. То есть мы никогда не берем в кредит.
[15:59.360 --> 16:06.360]  Тогда AIT – это вот те самые настоящие учетные стоимости, учетные стоимости.
[16:09.360 --> 16:15.360]  То есть что значит, что это учетные стоимости? Давайте вспоминать определение учетной амортизированной сложности каждой операции.
[16:16.360 --> 16:26.360]  Это значит, что если я вместо реальных времен работы, вот этих вот T-шек, сложу Ашки, сложу учетные стоимости вместо реальных, то получу верхнюю оценку на реальное время работы.
[16:26.360 --> 16:31.360]  То есть сумма T-итых есть O-большое от суммы A-итых.
[16:33.360 --> 16:39.360]  Вот такое у меня было определение, что реальное время работы есть O-большое от учетных стоимости работы.
[16:40.360 --> 16:46.360]  То есть как бы реальное время работы оценивается сверху тем, как если бы я вместо настоящих времен работы учитывал вот это вот учетное A.
[16:47.360 --> 16:53.360]  Получается, что на самом деле реальное время работы каждой конкретно мне не интересно, мне достаточно знать только учетное.
[16:53.360 --> 16:55.360]  И если я учетные сложу, то получу верхнюю оценку на время работы.
[16:58.360 --> 16:59.360]  Ну доказательств элементарно.
[17:00.360 --> 17:02.360]  Что такое сумма A-итых? Давайте посчитаем.
[17:05.360 --> 17:10.360]  Это сумма T-итых плюс сумма D-итых минус сумма W-итых.
[17:11.360 --> 17:15.360]  То есть сколько я реально отработал, плюс сколько монеток я положил в банк, минус сколько я снял.
[17:16.360 --> 17:19.360]  Ну вот эта штука не отрицательна по предположению.
[17:20.360 --> 17:23.360]  Мы всегда кладем не меньше, чем снимаем.
[17:24.360 --> 17:27.360]  Поэтому суммарно мы положили больше броно, чем суммарно мы сняли.
[17:28.360 --> 17:29.360]  Значит эта штука не отрицательна.
[17:30.360 --> 17:35.360]  В итоге мы получаем, что чтобы получить сумму A-итых, мне нужно к сумме T-шек добавить что-то положительное.
[17:36.360 --> 17:37.360]  Ну не отрицательно.
[17:38.360 --> 17:41.360]  Значит сумма T-итых не больше, чем сумма A-итых.
[17:45.360 --> 17:46.360]  Потому что тут написано сумма A-шек.
[17:47.360 --> 17:48.360]  Здесь сумма T-шек плюс что-то не отрицательно.
[17:49.360 --> 17:50.360]  Значит такое неравенство автоматически следует.
[17:52.360 --> 17:54.360]  Ну собственно мы доказали то, что нужно.
[17:55.360 --> 18:01.360]  Мы доказали, что реальное время работы всей нашей программы, то есть без всяких вот этих монеток странных, реальное время обработки запросов,
[18:02.360 --> 18:04.360]  оценивается сверху суммой учетных стоимости.
[18:05.360 --> 18:06.360]  Понятная идея?
[18:08.360 --> 18:13.360]  Ну здесь простое замечание, что на самом деле мне достаточно хранить не то, что условия,
[18:13.360 --> 18:16.360]  достаточно не то, чтобы всегда было не отрицательное число монет,
[18:17.360 --> 18:18.360]  а только чтобы в самом конце.
[18:19.360 --> 18:21.360]  Потому что здесь мне нужно, чтобы сумма положенных минус сумма снятых больше на нуля.
[18:22.360 --> 18:24.360]  То есть в принципе где-то по дороге можно было занимать в кредит, это не страшно.
[18:25.360 --> 18:26.360]  Но главное, чтобы в конце было не отрицательно.
[18:27.360 --> 18:39.360]  На самом деле число монет может быть не отрицательным где-то по дороге,
[18:39.360 --> 18:50.360]  может быть отрицательным, может быть отрицательным в середине процесса.
[18:56.360 --> 18:58.360]  Главное, чтобы в конце была не отрицательная сумма.
[19:06.360 --> 19:08.360]  Главное, чтобы в конце было больше на нуля.
[19:09.360 --> 19:18.360]  Ну потому что если мы заменим вот это условие про не отрицательность всегда на не отрицательность только в самом конце,
[19:19.360 --> 19:22.360]  у меня вот это рассуждение останется, потому что мне нужно только чтобы эта штука была не отрицательной.
[19:23.360 --> 19:27.360]  Так, ну хорошо, вот определили такой метод монеток.
[19:28.360 --> 19:32.360]  Давайте мы его сейчас применим для задачи о динамическом массиве.
[19:39.360 --> 20:02.360]  То, что реализовано в плюсах через интерфейс STD Vector.
[20:03.360 --> 20:05.360]  Значит, что мы хотим от STD Vector?
[20:05.360 --> 20:09.360]  Мы хотим по сути хранить обычный массив, то есть с доступом по индексу,
[20:10.360 --> 20:15.360]  так чтобы вот если вы мне даете И, я могу за от 1 вам сообщить АИТ, какой элемент у меня находится в этой позиции.
[20:16.360 --> 20:19.360]  Но при этом он умеет расширяться направо и наоборот сужаться справа.
[20:20.360 --> 20:25.360]  То есть мне нужна такая структура данных, которая умеет отвечать на оператор квадратной скобки,
[20:26.360 --> 20:32.360]  то есть по индексу сообщать элемент, по И сообщить АИТ.
[20:32.360 --> 20:43.360]  Ну и дальше вот эти два запроса pushback x, это добавить в конец нашего списка x, добавить x справа.
[20:44.360 --> 20:53.360]  И popback это удалить элемент справа, удалить, ну я напишу так, удалить самый правый элемент.
[20:53.360 --> 20:57.360]  То есть по сути это то, что у нас было в самом начале, то, что у нас было в стеке,
[20:58.360 --> 21:02.360]  добавить в конец и удалить с конца, только появляется новый оператор квадратной скобки,
[21:03.360 --> 21:05.360]  который позволяет смотреть в данное конкретное место стека.
[21:06.360 --> 21:07.360]  Напомню, как у нас был стек.
[21:08.360 --> 21:12.360]  Стек у нас был реализован однозвязанным списком просто, вот такая штука.
[21:13.360 --> 21:17.360]  И мы конечно же умеем в стеке делать pushback, то есть добавлять элемент справа,
[21:17.360 --> 21:18.360]  и наоборот popback.
[21:19.360 --> 21:22.360]  Для этого нам нужно просто удалить этот элемент и сказать, что теперь последним является вот этот.
[21:23.360 --> 21:26.360]  То есть в обычном стеке pushback и popback работали за вот единицу,
[21:27.360 --> 21:29.360]  но мы не умели эффективно отвечать на запрос квадратной скобки.
[21:30.360 --> 21:32.360]  Потому что если я вас попрошу найти там десятый элемент,
[21:33.360 --> 21:38.360]  то лучшее, что вы можете сделать, это пройти с начала вашего массива или с конца в поисках элемента с индексом 10.
[21:39.360 --> 21:42.360]  Потому что они как угодно у вас стоят в памяти, это совсем необязательно,
[21:42.360 --> 21:45.360]  и чтобы получить данное конкретное число, вам нужно пройтись по всем этим стрелочкам.
[21:46.360 --> 21:49.360]  Мы никак не можем понять по индексу, где он конкретно лежит.
[21:50.360 --> 21:52.360]  Нам придется вот так целиком пройти весь список.
[21:53.360 --> 21:59.360]  Давайте это запишем, что в стеке мы умеем обрабатывать последние две операции за вот единицу,
[22:00.360 --> 22:01.360]  но не умеем квадратные скобки.
[22:02.360 --> 22:03.360]  Эффективно, по крайней мере, не умеем.
[22:05.360 --> 22:07.360]  Умеем обрабатывать квадратные скобки.
[22:07.360 --> 22:08.360]  Эффективно, по крайней мере, не умеем.
[22:10.360 --> 22:14.360]  Умеем обрабатывать pushback и popback
[22:20.360 --> 22:23.360]  за от единицы. За честное от единицы не амортизировано, а настоящее,
[22:24.360 --> 22:28.360]  потому что мне нужно создать новый элемент, переназначить стрелку, переназначить ссылку на хвост.
[22:29.360 --> 22:31.360]  Это все действия, которые всегда от единиц времени занимают.
[22:32.360 --> 22:38.360]  Но при этом запрос квадратной скобки у меня может быть очень долгий.
[22:40.360 --> 22:46.360]  Может выполняться ω от n, потому что если у меня есть стек размера n
[22:47.360 --> 22:50.360]  и мне нужно, скажем, какой-нибудь n пополам t-элемент, центральный элемент,
[22:51.360 --> 22:54.360]  то мне либо сначала нужно пройти n пополам стрелочек, либо с конца пройти n пополам стрелочек.
[22:55.360 --> 22:58.360]  Никак по-другому не получится, ну по крайней мере, вот в нашей наивной реализации.
[22:58.360 --> 23:03.360]  Поэтому в худшем случае у вас квадратные скобки работают за ωt.
[23:04.360 --> 23:10.360]  А вектор позволяет вам делать все за от единицы. Здесь будет чистое от единицы,
[23:11.360 --> 23:16.360]  а здесь будет учетное, то есть амортизированное. Я буду писать со звездочкой, значит оно амортизированное.
[23:24.360 --> 23:25.360]  Это то, что умеет вектор.
[23:26.360 --> 23:29.360]  То есть ведет себя как стек, только эти штуки становятся амортизированными,
[23:30.360 --> 23:33.360]  то есть каждая конкретная может работать долго, но в среднем суммарно как будто бы за единицу.
[23:34.360 --> 23:36.360]  Плюс еще квадратные скобки за чистое от единицы.
[23:44.360 --> 23:46.360]  Так, ну вот следующим образом можно это реализовать.
[23:47.360 --> 23:53.360]  Давайте мы будем хранить просто некий массив длины c.
[23:59.360 --> 24:01.360]  И в нем будет заполнено несколько первых элементов.
[24:02.360 --> 24:04.360]  То есть несколько первых его элементов – это содержимое нашего вектора,
[24:05.360 --> 24:08.360]  а все остальное справа – это как бы пустое место, которое у меня лежит в резерве.
[24:09.360 --> 24:13.360]  То есть вот это вот s – это число настоящих элементов, число элементов,
[24:13.360 --> 24:17.360]  число элементов, а все остальное – это как бы свободное резервное место.
[24:18.360 --> 24:22.360]  То есть посмотрите, я просто как бы храню массив, у которого справа есть какое-то свободное место.
[24:24.360 --> 24:28.360]  Ну и понятно, что обычно у меня pushback и popback очень простые.
[24:29.360 --> 24:33.360]  Мне нужно просто, если приходит pushback, мне нужно вот в эту вот ячейку массива написать x.
[24:34.360 --> 24:36.360]  Да, если у меня достаточно много памяти выделено справа,
[24:37.360 --> 24:39.360]  я смотрю на эту первую свободную ячейку, туда записываю нужное число.
[24:40.360 --> 24:42.360]  Ничего сложного. Ну и там учитывая, что s увеличится на единичку.
[24:43.360 --> 24:45.360]  То есть число активных элементов выросло.
[24:46.360 --> 24:49.360]  Если наоборот нужно сделать popback, вот было у меня s элементов, и мне нужно сделать popback,
[24:50.360 --> 24:54.360]  ну давайте тогда я просто s уменьшу на единичку и буду считать, что у меня массив теперь вот здесь заканчивается.
[24:55.360 --> 24:59.360]  То есть тут что-то лежит, бог с ним, но давайте просто как бы считаем, что там ничего нет.
[25:00.360 --> 25:02.360]  И что эта память на самом деле просто резервная, куда мы можем добавлять новые элементы.
[25:03.360 --> 25:06.360]  Просто сузили размер на единичку, ничего не поменялось.
[25:07.360 --> 25:08.360]  Вот, такая отличная реализация.
[25:09.360 --> 25:11.360]  Понятно, что квадратные скобки тоже можно зовут единицы,
[25:11.360 --> 25:14.360]  потому что массив умеет обрабатывать квадратные скобки, зовут единицы.
[25:15.360 --> 25:19.360]  Но как минимум проблема такая, что если мы много раз делаем себе pushback
[25:20.360 --> 25:23.360]  и целиком заполним всю выделенную исходную память,
[25:24.360 --> 25:26.360]  то мне уже будет некуда добавлять вот этот элемент направо.
[25:27.360 --> 25:29.360]  То есть если я целиком исчерпал всю выделенную себе память заранее,
[25:30.360 --> 25:33.360]  мне будет некуда, может быть, некуда добавлять новое число.
[25:34.360 --> 25:35.360]  Ну не беда.
[25:36.360 --> 25:39.360]  Давайте тогда мы просто попросим у системы себе выделить еще такой же длинный блок памяти.
[25:39.360 --> 25:43.360]  То есть вот напишу следующее, что если у меня приходит pushback,
[25:44.360 --> 25:51.360]  в случае s равно c, то есть если вся резервная память исчерпана,
[25:52.360 --> 25:53.360]  и у меня больше нет места.
[25:54.360 --> 25:55.360]  Тогда наш алгоритм будет делать следующее.
[25:56.360 --> 26:00.360]  Он попросит у системы новый кусок непрерывной памяти размера 2c,
[26:01.360 --> 26:07.360]  запрашиваем у системы массив длины 2c,
[26:07.360 --> 26:15.360]  ну то есть там что-то типа new вызываем или что-то такое, там какой-то молок.
[26:16.360 --> 26:18.360]  В общем как-нибудь просим у системы дать нам 2c элементов.
[26:19.360 --> 26:23.360]  Затем просто вот эти вот c элементы перекопируем туда, вот в этот наш новый массив.
[26:24.360 --> 26:27.360]  Ну и получается, что у нас есть длинный массив уже в два раза большего размера,
[26:28.360 --> 26:29.360]  в котором занято только половина элементов.
[26:30.360 --> 26:35.360]  Да, я завел новый массив размера 2c, старый массив сюда перекопировал,
[26:35.360 --> 26:39.360]  и теперь у меня опять идеальная ситуация, когда у меня очень много свободного места справа.
[26:40.360 --> 26:42.360]  Понятно? То есть просто перекопировал свободное место.
[26:43.360 --> 26:47.360]  И здесь еще нужно не забыть, что вот эту старую память нужно отдать системе, нужно вернуть системе.
[26:48.360 --> 26:53.360]  То есть давайте я напишу так. Вернуть старый массив системе.
[26:54.360 --> 26:57.360]  Старый массив системе.
[26:58.360 --> 27:05.360]  То есть вызвать delete или в общем free как-нибудь дать системе понять, что эта память нам больше не нужна,
[27:06.360 --> 27:07.360]  мы ее обратно возвращаем, чтобы она и пользовалась.
[27:08.360 --> 27:10.360]  Нам в программе она не нужна, чтобы у нас не текла память.
[27:11.360 --> 27:15.360]  Мне нужна ту память, которую нам исходно выделили, вернуть потом в конце системе, если мы ей больше не пользуемся.
[27:16.360 --> 27:18.360]  То есть мы скопировали все, понимаем, что нам это не нужно, а даем ее обратно системе.
[27:19.360 --> 27:20.360]  Через free или что-то такое.
[27:22.360 --> 27:25.360]  Ну и опять у нас хорошая ситуация, у нас очень много свободных элементов справа.
[27:25.360 --> 27:32.360]  Мы можем сюда при следующих пушбеках просто по одному эти элементы записывать, сдвигая s на единичку вправо.
[27:33.360 --> 27:39.360]  И опять следующая такая тяжелая операция, когда нужно будет вызывать перекопирование, будет только через c действий.
[27:40.360 --> 27:43.360]  Только когда я целиком все это заполню, может мне понадобится расширить этот массив еще в два раза.
[27:44.360 --> 27:49.360]  И вот как раз та интуиция, это будет происходить довольно редко, вот это расширение в два раза.
[27:50.360 --> 27:56.360]  И получается, что время на это перекопирование можно как бы перераспределить по запросам других типов или просто по более простым запросам.
[27:58.360 --> 28:01.360]  То есть это мы еще сейчас все докажем, пока давайте до конца алгоритма пишем.
[28:11.360 --> 28:15.360]  Так, мы описали как работает пушбек, если у нас есть свободное место, пишем туда элемент.
[28:15.360 --> 28:22.360]  Если нет, то выделяем массив в два раза большей памяти и перекопируем туда то, что было.
[28:23.360 --> 28:24.360]  Теперь как работает попбек.
[28:27.360 --> 28:35.360]  Ну можно сказать, что в такой наивной реализации, давайте просто уменьшим s на единичку, считать, что массив сжался на 1 справа и больше ничего не сделаем.
[28:36.360 --> 28:38.360]  То есть такая простая реализация, это минус, минус s и все.
[28:39.360 --> 28:53.360]  В принципе так можно делать, но здесь вот если мы хотим написать настоящий вектор, который удовлетает всем тем интуитивным ожиданием от него, то это не очень хорошо в следующем плане.
[28:54.360 --> 29:00.360]  Смотрите, например, у вас такая цепочка запросов. Пушбек, пушбек, пушбек, куча пушбеков, а потом куча попбеков.
[29:01.360 --> 29:04.360]  Тогда в самом конце, ну или там на одной из последних итераций, давайте я нарисую.
[29:05.360 --> 29:11.360]  Сначала мы сделали много пушбеков, завели какой-то огромный массив, потом потихоньку удаляем эти элементы, стираем, стираем, стираем, стираем.
[29:12.360 --> 29:22.360]  Тогда вот здесь ближе к концу у вас по сути эффективная память находится где-то вот здесь, то есть элементы, которые вам интересны, находятся вот здесь, а выделено у вас гораздо больше памяти.
[29:23.360 --> 29:27.360]  То есть вы как бы у системы забрали огромный кусок памяти, чтобы хранить совсем немножко там чисел.
[29:27.360 --> 29:29.360]  Скажем, вот здесь 10 чисел, а это длина там тысячи.
[29:30.360 --> 29:34.360]  Ну, так можно сделать, но понятно, что мы такого хотим избегать.
[29:35.360 --> 29:40.360]  Мы не хотим, чтобы у нас хранилось, то есть мы не хотим у системы забирать сильно больше ресурсов, чем нам нужно для хранения.
[29:52.360 --> 29:55.360]  Сейчас я напишу и поймем, что такого не будет возникать.
[29:56.360 --> 30:01.360]  Так вот, значит, чтобы такого не было, чтобы у нас не было очень много свободной памяти, мы поступим следующим образом.
[30:06.360 --> 30:23.360]  Ну, сначала, конечно, мы делаем минус-минус s, просто удаляя один элемент, и затем, если s стало меньше либо равно, чем 1 четверть c, то мы сократим c в два раза, то уменьшим c в два раза.
[30:23.360 --> 30:25.360]  Меньшим c в двое.
[30:28.360 --> 30:37.360]  То есть я вот так удаляю, удаляю, удаляю, и если у меня эффективная память меньше либо равно, чем четверть от сей выделенной, то вот эта используется, а эта сколько мне выделена?
[30:38.360 --> 30:42.360]  И если это c хотя бы в четыре раза больше, чем s, то я половину этих элементов удалю.
[30:43.360 --> 30:47.360]  И вот, отвечая на ваш вопрос, здесь константа не 2, а 4.
[30:48.360 --> 30:53.360]  То есть только когда мы в четыре раза аж меньше, чем c, только тогда мы сокращаем в два раза.
[30:54.360 --> 31:01.360]  Ну, чтобы уменьшить c в двое, можно, скажем, посмотреть на вот этот индекс и запустить от него free, то есть как бы отдать вот эту вот память системе.
[31:02.360 --> 31:15.360]  Ну, либо, если нам так не хочется, можно просто завести, то есть попросить у системы блок размера c пополам, блок непрерывной памяти размера c пополам, перекопировать вот эти элементы сюда, а это все удалить.
[31:16.360 --> 31:20.360]  Это все отдать обратно системе. Ну, это уже не важно.
[31:21.360 --> 31:27.360]  Главное, что не допустить утечек памяти, то есть нельзя не удалить этот указатель, его обязательно нужно вернуть системе.
[31:28.360 --> 31:31.360]  Если вы делаете такое перекопирование, то вам нужно это обязательно удалить.
[31:32.360 --> 31:40.360]  Ну вот, то есть, ну и да, вот, например, отвечая на этот запрос, представим, что у нас было много там пушбеков.
[31:40.360 --> 31:47.360]  Сделали, делали, делали пушбек, потом попробовали сделать еще один пушбек, в результате которого нам пришлось расширить в два раза наш массив.
[31:49.360 --> 31:51.360]  Расширить в два раза наш массив.
[32:05.360 --> 32:09.360]  И нам приходит, скажем, теперь попбек, мы удаляем вот этот только что добавленный элемент.
[32:10.360 --> 32:17.360]  Тогда, чтобы нам сократить обратно в два раза наш массив, мне нужно не просто один раз сделать попбек, а удалить все вот эти вот элементы.
[32:18.360 --> 32:20.360]  То есть всю вот эту правую половинку исходного массива придется удалить.
[32:21.360 --> 32:28.360]  И только если я их все удалю, я вот эту память себе освобождаю, отдаю обратно системе, и тем самым сокращаю в два раза резерв.
[32:29.360 --> 32:33.360]  Да, у меня теперь вот это у системы, а вот эти вот ячейки свободные, куда я могу добавлять элементы.
[32:34.360 --> 32:36.360]  Вот такой алгоритм.
[32:37.360 --> 32:41.360]  Значит, ну понятно, что здесь есть тяжелые операции, которые вот такие перекопирования.
[32:42.360 --> 32:46.360]  В попбеке есть тяжелые попбеки, когда нужно в какую-то новую память перекопировать ТС элементов.
[32:47.360 --> 32:50.360]  И то же самое есть в пушбеке, когда нужно в два раза расширить текущую область.
[32:51.360 --> 32:55.360]  Но оказывается, что суммарно можно считать, что каждый из них работает за от 1.
[32:56.360 --> 32:58.360]  И вот это вот то самое амортизованная оценка.
[32:59.360 --> 33:04.360]  Если мы сложим настоящее время работы, то оно будет не больше, чем если бы мы считали, что каждая операция работает в 1.
[33:05.360 --> 33:09.360]  Значит, теперь давайте докажем, что учетное время работы.
[33:13.360 --> 33:15.360]  Учетное время работы всех операций.
[33:20.360 --> 33:22.360]  Есть ОТ.
[33:23.360 --> 33:28.360]  Напомню, звездочка, значит, как раз время речи идет об амортизированной асимптотике.
[33:30.360 --> 33:32.360]  Так, ну хорошо.
[33:35.360 --> 33:37.360]  Давайте скажем следующее.
[33:38.360 --> 33:41.360]  Давайте скажем, что у меня есть как бы легкие и тяжелые пушбеки.
[33:43.360 --> 33:45.360]  Легкие и тяжелые.
[33:46.360 --> 33:48.360]  И то же самое с попбеками.
[33:51.360 --> 33:55.360]  Есть легкие, есть тяжелые.
[33:57.360 --> 34:03.360]  В том самом смысле, как я говорил, да, легкие это просто там положить число в конец, не нужно ничего перекопировать, то есть у меня есть достаточно памяти, чтобы это сделать.
[34:04.360 --> 34:11.360]  Тяжелое, наоборот, у меня вся память заполнена, мне нужно выделить новую, то есть тяжелое, когда происходит перекопирование, выделение новой памяти и так далее и так далее.
[34:12.360 --> 34:14.360]  Так вот, давайте тогда сделаем следующее.
[34:15.360 --> 34:29.360]  Каждый раз, когда мне приходит пушбек, который легкий, скажем, и он кладет х на позицию И, то есть х кладется в АИТ, ну я вот так напишу, то есть в ИТ-ю ячейку нашего массива.
[34:30.360 --> 34:36.360]  Мы вместе с этим, то есть поскольку это легкая операция, мы интуитивно хотим класть в банк себе деньги, то есть мы понимаем, что нам сейчас легко.
[34:37.360 --> 34:43.360]  Значит, мы можем как бы поднабрать жирка, подэкономить денег, положить их себе в банк, так чтобы потратить в будущем эти деньги.
[34:44.360 --> 35:02.360]  Так вот, давайте положим по монетке, положим по монетке на элементы АИ и А с индексом И минус С пополам, А с индексом и минус С пополам.
[35:03.360 --> 35:11.360]  То есть я кладу, вот возвращаясь к этой картинке, если я вот сюда добавляю новое число, то я добавляю монетку сюда и вот сюда, отступаю на С пополам, кладу вот сюда.
[35:14.360 --> 35:18.360]  Нет, сейчас, здесь С пополам будет видимо вот это вот, поэтому кладу вот сюда.
[35:20.360 --> 35:33.360]  Значит, в тяжелом пушбеке мы не будем класть никакие монетки, в легком попбеке мы тоже кладем, пусть какой-нибудь Y удаляется с позиции АИ,
[35:34.360 --> 35:50.360]  мы тогда положим монетку на АИТ и АИ минус С на 4.
[35:58.360 --> 35:59.360]  Кажется так.
[36:03.360 --> 36:15.360]  Давайте на примере, вот рассмотрим пушбек. Давайте рассмотрим пушбек первые легкие в своей цепочке.
[36:16.360 --> 36:25.360]  То есть когда-то мы что-то делали, скажем, и потом целиком заполнили вот этот вот блок, который у нас был выделен, потом выделили новый блок того же размера и сюда положили новое число.
[36:25.360 --> 36:34.360]  И вот этот вот как бы пушбек, когда мы кладем новое число, мы положим монетку вот сюда и монетку в позицию на С пополам меньше.
[36:35.360 --> 36:38.360]  Если вот это вот все С, то Ц пополам как раз половинка, получается монетка положится сюда.
[36:39.360 --> 36:45.360]  Затем я опять делаю пушбек, добавится такое число, положится монетка на него и на вот этот вот соответствующий ему в левой половинке.
[36:46.360 --> 36:57.360]  И так далее, чтобы дойти до этого, до конца нашего массива и чтобы опять потребовалось выделить какую-то память, у меня будет класса монетка на каждый добавленный элемент, а также на соответствующий ему в левой половинке.
[36:59.360 --> 37:08.360]  И получается, что когда я дойду до конца и мне потребуется завести новую память, выделить себе новую память и все перекопировать, у меня монеток будет столько, сколько нужно.
[37:08.360 --> 37:15.360]  То есть на каждом элементе лежит по монетке, и я вот этими монетками как бы расплачиваю за те операции, которые мне сейчас нужно сделать.
[37:16.360 --> 37:23.360]  Расплачиваю за выделение еще большей памяти, за перекопирование и за освобождение вот этой памяти. Я расплачиваюсь вот этими монетками.
[37:24.360 --> 37:27.360]  То есть их количество как раз равно длине этого массива, их ровно С.
[37:28.360 --> 37:31.360]  Ну а все операции вот эти вот работают как раз, ну можно считать, что за С действий.
[37:31.360 --> 37:42.360]  Ну за О, С формально говоря, потому что мне нужно выделить массив размера 2С, перекопировать и еще вот это все освободить.
[37:43.360 --> 37:49.360]  Ну в общем, грубо говоря, можно считать, что число монеток как раз равно количеству действий, которые мы сейчас делаем с точностью до коэффициента.
[37:50.360 --> 37:59.360]  Но чтобы про этот коэффициент не думать, можно говорить, что мы кладем не по одной монетке, а по пять монеток, и тогда как раз число монеток нам хватает на то, чтобы сделать все действия. Понятно?
[38:00.360 --> 38:07.360]  Вот нам монеток хватит, чтобы сделать все действия. То есть каждое действие сопровождается снятием, удалением какой-то монетки из банка.
[38:08.360 --> 38:16.360]  Ну и как раз получается, что у нас как бы время работы, вот это учетное, вспоминаем, что это реальное время работы.
[38:17.360 --> 38:25.360]  Реальное. Плюс сколько положили. Депозит. Минус сколько сняли.
[38:26.360 --> 38:32.360]  Не буду считать этого слова. Минус сколько сняли.
[38:33.360 --> 38:45.360]  И как раз, если у меня каждое действие, то есть там, ну, выделение массива, перекопирование, если каждое действие сопровождается снятием монетки, то у меня оно, по сути, Т будет равно W и AD вообще нулю.
[38:46.360 --> 38:51.360]  То есть по сути учетная стоимость будет просто нулевая. Как будто бы мы вообще прям за ноль действия это сделали.
[38:51.360 --> 38:56.360]  Хотя на самом деле здесь конечно очень много всяких действий. Вот это вот перекопирование, выделение и так далее.
[38:57.360 --> 39:01.360]  Но как бы за это мы расплатились на прошлых итерациях, когда клали монетки на элементы. Понятно?
[39:02.360 --> 39:10.360]  Вот. Ну то же самое происходит с поп-беком. Давайте поп-бек нарисуем. Вот был у меня какой-то массив такого размера.
[39:14.360 --> 39:15.360]  Так.
[39:21.360 --> 39:30.360]  Был у меня массив какого-то такого размера. И давайте посмотрим на два соседние тяжелые поп-бека. То есть вот когда-то мы длину этого массива уменьшили вдвое.
[39:31.360 --> 39:37.360]  Когда у меня тяжело вот этих вот задействованных, в четыре раза было меньше, чем весь массив. То есть весь массив был когда-то вот такой.
[39:38.360 --> 39:42.360]  Я удалил там очередной элемент. Их активных стало в четыре раза меньше.
[39:42.360 --> 39:44.360]  И я соответственно вот эту память себе освободил.
[39:45.360 --> 39:47.360]  Теперь смотрим, когда придет следующий поп-бек.
[39:48.360 --> 39:51.360]  Для следующего поп-бека я должен удалить вот половину этих элементов.
[39:52.360 --> 39:59.360]  Чтобы пришел следующий, в смысле тяжелый поп-бек, мне нужно, чтобы у меня активных стало в четыре раза меньше, чем вот этот размер. Чем вот это вот С.
[40:00.360 --> 40:02.360]  Ну то есть как раз половину вот этих я должен удалить.
[40:02.360 --> 40:04.360]  Ну тогда смотрите. Как это будет работать?
[40:05.360 --> 40:07.360]  Для этого у меня сначала должно быть вот столько легких поп-беков. Я должен удалить все вот эти элементы.
[40:08.360 --> 40:21.360]  Но каждое такое действие кладет по монетке...
[40:22.360 --> 40:28.360]  Ну вот как раз вот сюда, удаление этого положит по монетке монетку вот сюда, удаление вот этого положит монетку сюда, удаление вот этого положит здесь...
[40:29.360 --> 40:30.360]  И так далее.
[40:30.360 --> 40:33.360]  сюда, удаление вот этого, положить монетку сюда и так далее. Как раз потому что
[40:33.360 --> 40:37.400]  минус c на 4, то есть я как раз сдвигаюсь на четверть c и вот кладу монетку в
[40:37.400 --> 40:42.760]  соответствующий элемент на c на 4 позиции влево. То есть на самом деле здесь даже
[40:42.760 --> 40:47.040]  можно не класть монетку на а и т. Вот это можно взять скобки, это не обязательно.
[40:47.040 --> 40:51.320]  То есть я буду класть монетки на те элементы, которые соответствуют удаленным,
[40:51.320 --> 40:56.840]  которые левее их на c на 4. Ну и тогда чтобы попасть в следующий тяжелый
[40:56.840 --> 41:01.160]  поп-бэк, я должен сначала их все удалить, то есть положить по монетке на все вот
[41:01.160 --> 41:05.480]  эти элементы. Ну значит у меня будет опять достаточно денег, чтобы запуститься
[41:05.480 --> 41:09.920]  нашей нашей сложной вот этой операцией, выделить себе новую память, все
[41:09.920 --> 41:13.960]  перекопировать, освободить старую. Потому что как раз здесь монеток, их там c на 4
[41:13.960 --> 41:18.960]  и их достаточно, чтобы сделать все тяжелые действия. Опять там тоже будет
[41:18.960 --> 41:24.960]  реальное время работы равно числу снятых монеток, а депозит у нас будет нулевой.
[41:25.040 --> 41:28.600]  Понятно? Да.
[41:30.680 --> 41:34.160]  Какой ты константу?
[41:37.960 --> 41:44.000]  Нет-нет, мы с самого начала, это зависит от реализации, это не особо важно, можно
[41:44.000 --> 41:47.440]  считать, что с самого начала c равно 16, например. То есть изначально
[41:47.440 --> 41:54.840]  выделяем память под 16 элементов, а s равно нулю. Вот и тогда, например, когда мы
[41:54.840 --> 42:00.280]  там дойдем и целиком заполним все эти 16 элементов, мы сначала раздуемся до
[42:00.280 --> 42:06.600]  32. Когда мы будем вызывать поп-бэк, ну давайте считать, что у меня размер никогда не
[42:06.600 --> 42:11.400]  будет меньше, чем 16. То есть, да.
[42:19.000 --> 42:22.320]  Да, ну то есть тут просто вопрос про то, что мы делаем для маленьких размеров, но
[42:22.320 --> 42:26.400]  понятно, что если у меня там один элемент, то лучше не хранить массив длины один и
[42:26.400 --> 42:30.680]  потом расширять его до двух. Ну там хоть какое-то содержательное количество
[42:30.680 --> 42:35.280]  элементов нужно хранить, ну там 10, 16, что-то такое обычно кладут. Ну а раз у меня
[42:35.280 --> 42:39.480]  все равно всегда у меня там удвоение или деление пополам, то лучше какой-нибудь
[42:39.480 --> 42:45.520]  степень двойки взять, чтобы все хорошо делилось. Да. Что?
[42:45.520 --> 42:51.120]  Потому что просто все сходится, можно другие константы подбирать, ну типа
[42:51.120 --> 42:55.320]  наверное можно в три раза увеличивать и там уменьшать тоже, не знаю, в шесть,
[42:55.320 --> 42:59.080]  сейчас, ну то есть в полтора раза что-то такое. Наверняка, наверняка можно и по-другому.
[42:59.080 --> 43:06.560]  Ой, я не знаю, я не знаю, можно поработать, подумать, но здесь непонятно, что какое оптимальное.
[43:13.200 --> 43:16.360]  То есть непонятно, как определить оптимальную константу, во сколько раз надо раздувать,
[43:16.360 --> 43:26.800]  то есть чтобы, ну мне непонятно, да, как определить оптимальность, вроде так все сходится.
[43:26.800 --> 43:33.200]  Вот, последнее еще что я здесь скажу, то есть я здесь рассматривал, вот здесь вот я рассматривал
[43:33.200 --> 43:37.880]  действия между двумя последователями тяжелыми пушбеками, а здесь между двумя последователями
[43:37.880 --> 43:42.800]  попбеками тяжелыми, но может быть такое, что у меня сначала идет тяжелый пушбек, потом тяжелый
[43:42.880 --> 43:47.520]  попбек, но тогда тоже самое, что значит, что у меня пришел тяжелый пушбек? Это значит,
[43:47.520 --> 43:53.720]  что у меня была заклонена половинка, и я заполняю еще один, потом что-то происходит, какие-то пуши,
[43:53.720 --> 44:01.480]  какие-то попбеки, и следующая операция – это тяжелый попбек, тогда это значит, что вот столько
[44:01.480 --> 44:06.800]  элементов будет активных, вот эти активные, эти все удалились, значит опять вот все эти элементы
[44:06.800 --> 44:10.980]  должны были удалиться как минимум. То есть, возможно еще были какие-то пушбеки, кладущие
[44:10.980 --> 44:14.940]  монетки вот сюда, но также обязательно вот эти элементы должны были удалиться и
[44:14.940 --> 44:19.100]  каждый из них кладет по монетке вот сюда.
[44:30.780 --> 44:34.700]  Значит, то же самое, на монетах всегда хватит на то чтобы сделать
[44:34.700 --> 44:38.560]  тяжелые действия. Итак, давайте посчитаем вот этими ашками,
[44:38.560 --> 44:44.840]  давайте посчитаем, что делает легкий пушбэк. В легком пушбэке сколько нам
[44:44.840 --> 44:48.400]  нужно действий? Одно действие, чтобы просто присвоить одно значение, ну и там
[44:48.400 --> 44:53.680]  увеличить s, не знаю, давайте напишем 2, потому что нам нужно сделать аs-то
[44:53.680 --> 44:58.480]  равно x и плюс плюс s. Это такой легкий пушбэк, когда мы просто кладем число и
[44:58.480 --> 45:05.000]  сдвигаем указатель направо. Монеток мы кладем в этот момент тоже две, тоже две,
[45:05.000 --> 45:12.500]  ничего не снимаем. Вот, тогда учетное время работы, блин, тут коллизия, чтобы вот
[45:12.500 --> 45:19.800]  это а и вот это а, давайте я так напишу, учетное a и t равно 4 получается, да? t плюс d
[45:19.800 --> 45:31.440]  минус w это 4. Что такое тяжелый? Тяжелый пушбэк. Тяжелый пушбэк.
[45:32.120 --> 45:40.240]  Ну, мы поняли, что data это ноль, мы никаких монеток не кладем. Сколько мы снимаем?
[45:43.440 --> 45:47.080]  Так, мы снимаем монеток столько, сколько было элементов, потому что на каждом
[45:47.080 --> 45:52.320]  элементе обязательно есть по монетке. Мы снимаем c монеток. Ну и время работы,
[45:52.320 --> 45:58.880]  давайте я здесь напишу просто c, имея в виду, что, ну вот, вот то, что я здесь
[45:58.880 --> 46:03.320]  говорил, чтобы создать элемент, создать массив два раза большего размера и
[46:03.320 --> 46:07.120]  перекопировать туда эти элементы и удалить вот это, нам как бы достаточно, ну не то,
[46:07.120 --> 46:11.560]  что c операции, но o от c, не знаю, там 5 c операции, ну тогда вот здесь нужно было
[46:11.560 --> 46:15.920]  класть не по одной монетке, а по пять монеток, тогда бы как раз, ну не знаю, если
[46:15.920 --> 46:20.120]  вот здесь вот 10, тогда здесь у меня будет 10, ну и там чуть больше надо было
[46:20.120 --> 46:23.840]  класть, там нужно было класть по пять монеток на каждую. Но чтобы не возиться с этой
[46:23.840 --> 46:28.080]  константой, давайте считать, что у меня время работы здесь просто c и снимаю я
[46:28.080 --> 46:34.160]  тогда просто c, и получается учетное время будет 0 вообще. Учетное a и t равно
[46:34.160 --> 46:42.680]  нулю. Ну и получается, что все это от единицы, и это тоже от единицы, и то же
[46:42.680 --> 46:48.920]  самое с поп-бэками, значит, легкий поп-бэк,
[46:49.800 --> 46:56.800]  легкий поп-бэк, он делает просто одну операцию, уменьшение s, да, минус-минус s,
[46:56.960 --> 47:02.280]  кладет при этом, кажется, одну монетку мы договорились, и снимает 0, снимает 0,
[47:02.280 --> 47:09.640]  тогда a и t равно 2, что равно от единицы, вот, ну а тяжелый pushback по времени ведет
[47:09.640 --> 47:14.720]  себя, ну как бы по t-шкам, d-шкам, w-шкам, ведет себя также как тяжелый pushback, он
[47:14.720 --> 47:18.160]  снимает сколько-то монеток, за то же время выполняет все вот эти вот
[47:18.160 --> 47:21.520]  перекопирования, и не кладет ни одной монетки, поэтому там учетное время тоже
[47:21.520 --> 47:26.520]  будет нулем, что тоже равно от единицы, вот. Получается, что учетное время всех,
[47:26.520 --> 47:33.120]  всех этих операций это от единицы, значит, можно как бы считать, что каждый
[47:33.120 --> 47:36.720]  из них работает за одно действие, или там за c действий. Получается, что если у
[47:36.720 --> 47:42.680]  меня поступает q запросов к нашему вектору, если всего q запросов, то они
[47:42.680 --> 47:51.400]  суммарно обрабатываются за от q, они суммарно обрабатываются за от q, да,
[47:51.400 --> 47:54.520]  потому что если я просуммирую вот эти вот оценочки, все ашечки, то у меня
[47:54.520 --> 47:58.120]  получится как раз, ну там q умножен на какую-то константу, на не больше чем четыре,
[47:58.120 --> 48:04.920]  поэтому суммарное время работы это от q, понятно? Да.
[48:11.080 --> 48:16.600]  Ну смотрите, а это вот здесь я показывал, что перед тем как приходит тяжелый
[48:16.600 --> 48:21.080]  pushback, например, я обязательно кладу по одной монетке на каждое из вот этих вот,
[48:21.080 --> 48:26.040]  то есть у меня всегда монеток хватает на то, чтобы сделать все действия, да, вот здесь я не
[48:26.040 --> 48:31.000]  беру монетки из воздуха, я беру монетки с, ну в общем они у меня лежат на элементах, то есть я
[48:31.000 --> 48:35.600]  их уже себе когда-то дал в прошлом и теперь их использую просто, трачу на выполнение действий.
[48:35.600 --> 48:43.120]  У меня монеток всегда нетрицательное количество, но я объяснил, да, формально не писали, но я
[48:43.120 --> 48:48.000]  вот здесь показывал, что монеток всегда хватает на выполнение всех действий, да, это важно
[48:48.000 --> 48:55.040]  подчеркнуть, но вот здесь на рисуночке я показывал. Так, ура, значит с Vector мы справились,
[48:55.040 --> 48:59.800]  он работает от единицы амортизированной на pushback и popback. Хорошо.
[49:18.840 --> 49:19.880]  Так, одну секунду.
[49:31.680 --> 49:41.440]  Теперь давайте рассмотрим задачу. Инсерт в биномиальной куче. Ну скажем так, в отсутствие других
[49:41.440 --> 49:52.680]  операций, в отсутствие других операций. Что это значит? Вот в прошлый раз мы разбирали биномиальную
[49:52.680 --> 49:59.920]  кучу, которую мы показали, что инсерт работает за от логарифма, да, потому что если у меня есть
[49:59.920 --> 50:05.400]  какая-то корректная биномиальная куча, я добавляю, создаю новую кучу, в которой есть только одно
[50:05.400 --> 50:09.600]  дерево из одного элемента и потом запускаю мерч от этих куч, которые работают за логарифмическое
[50:09.600 --> 50:16.840]  время. Вот, но если считать, что других операций пока что нету, то есть у нас запросы такие,
[50:16.840 --> 50:25.360]  сначала куча инсертов, скажем n инсертов, а потом какие-то другие, там экстрактмины, декризы,
[50:25.360 --> 50:30.640]  новые инсерты и так далее, тогда можно считать, что вот эти вот первые n инсертов работают каждый
[50:30.640 --> 50:39.200]  за амортизированную единицу, от единицы каждой. Вот это было в профессиональском листочке, то есть
[50:39.200 --> 50:44.440]  как бы суммарно вот эти вот, если вы знаете, что у вас среди запросов первые n это инсерты,
[50:44.440 --> 50:49.640]  вы изначально пустую кучу, то суммарно они отрабатывают за от n, то есть каждый за от
[50:49.640 --> 51:01.760]  единицы амортизировано, то есть суммарно от n. Так, ну давайте это поймем. Значит, на самом деле
[51:01.760 --> 51:06.920]  здесь все довольно просто, потому что мы показывали, что биноменальная куча, по сути,
[51:06.920 --> 51:12.360]  это представляет количество элементов n в виде разложения по степеням двойки. Это мы просто
[51:12.360 --> 51:17.000]  пишем двоичную запись, и те единички, которые там участвуют, соответствуют деревьям, которые
[51:17.000 --> 51:21.600]  присутствуют в куче. Так вот, пусть у меня есть сколько-то элементов в куче, и это количество
[51:21.600 --> 51:28.240]  представляется какой-то какой-то строкой из 0 единиц. Не знаю, что-нибудь такое напишу. Здесь
[51:28.240 --> 51:34.120]  что-то такое. Это младшие биты, это старшие. Текущее число элементов это k. Тогда, если приходит
[51:34.120 --> 51:40.000]  какой-то новый элемент, инсерт какой-то x, я создаю кучу на одном элементе x, а дальше запускаю
[51:40.000 --> 51:46.800]  мёрч. И этот мёрч работает на самом деле за количество единичек вот здесь вот. Потому что как
[51:46.800 --> 51:52.640]  у меня работает мёрч? Я сначала склеиваю вот эти два дерева, вот это дерево ранга 0 и это дерево
[51:52.640 --> 51:57.640]  ранга 0, объединяю их в одно дерево ранга 1. Потом оно объединяется вот с этим, результат объединяется
[51:57.640 --> 52:01.440]  вот с этим, результат с этим, результат с этим, и в итоге все, что мы объединили, получается одно
[52:01.440 --> 52:07.600]  дерево вот этого порядка, а здесь все зануляется. Так работает просто сложение двоичных чисел. Я
[52:07.600 --> 52:11.880]  иду справа налево, храню этот перенос, и когда встречаю первый нолик, туда ставлю результат.
[52:11.880 --> 52:18.720]  То есть на самом деле время работы каждой конкретной операции равно, давайте так и напишем,
[52:18.720 --> 52:29.200]  время обработки катового запроса равно
[52:32.920 --> 52:44.000]  количеству единиц в двоичной записи, в конце двоичной записи k, в конце двоичной записи k.
[52:44.000 --> 52:50.000]  То есть я записал k в двоичной системе числения, иду справа налево, считаю сколько у меня единичек,
[52:50.000 --> 52:53.760]  идут перед первым нулем, и вот сколько у меня в конце единичек, за столько мы и работаем.
[52:53.760 --> 53:00.000]  Ну и теперь давайте поймем, что на самом деле это амортизированная единичка.
[53:00.000 --> 53:08.000]  Давайте поймем, что это амортизированная единичка. Например, можно сделать следующим образом,
[53:08.000 --> 53:13.880]  можно сделать так, давайте мы будем себе гарантировать, будем поддерживать такое,
[53:13.880 --> 53:19.040]  что на каждой единице в двоичной записи текущего числа и лежит по монетке,
[53:19.040 --> 53:35.360]  на каждой единице в k лежит по монетке. Давайте еще раз нарисую, вот есть там какой-то префикс,
[53:35.360 --> 53:41.480]  потом нолик и куча единиц, и на каждой из единичек лежит монетка. Давайте я вот закрашиваю,
[53:41.480 --> 53:48.880]  чтобы не путать с нулем. Вот есть такие монетки. И теперь смотрите, приходит операция insert,
[53:48.880 --> 53:54.760]  я добавляю как бы новый элемент, вот они так склеиваются за количество этих единиц,
[53:54.760 --> 54:00.000]  и в конце у меня получается, что размер вот такой, префикс остается, здесь единица, а здесь куча нулей.
[54:00.000 --> 54:08.680]  Ну и как раз получается то, что нужно. Время работы вот этого insert, склейки всех этих деревьев,
[54:08.680 --> 54:13.120]  оно как раз равно числу снятых монеток. Вот если тут у меня в конце было 6 монеток,
[54:13.120 --> 54:16.640]  то мне нужно сделать 6 объединений деревьев, ровно то, что нужно, и результат положить в
[54:16.640 --> 54:21.360]  отдельную ячейку. Тогда давайте говорить следующее, что вот если у меня, я понимаю,
[54:21.360 --> 54:27.200]  что время работы вот этого, время обработки, это количество единиц в конце, количество единиц
[54:27.200 --> 54:37.360]  в конце, единиц в конце. Ну и это же тоже самое, что WIT, потому что я снимаю по монетке с каждой единицей,
[54:37.360 --> 54:42.920]  я гарантирую себе, что на каждой единице есть монетка, я ее снимаю из банка, и поэтому число,
[54:42.920 --> 54:48.280]  реальное время работы равно числу снятых монеток. Ну еще потом в конце кладу одну монетку на ту самую
[54:48.280 --> 54:53.840]  единицу, которая получилась в конце. То есть я сначала много монеток снимаю, объединяю деревья,
[54:53.840 --> 54:59.120]  потом на последнюю единицу кладу новую монетку. Получается у меня учетная стоимость такая,
[54:59.120 --> 55:06.320]  T плюс D минус W, то есть точность единицы. Вот эти сократились и осталась одна новая
[55:06.320 --> 55:11.360]  монетка, которую я положил на единичку. Значит, учетная стоимость всех операций это единица.
[55:11.360 --> 55:19.200]  Да, что мы и хотели. Вот как я в начале анонсировал, что каждый из инсертов работает амортизировано
[55:19.200 --> 55:24.960]  за единицу. Еще раз, каждый конкретный может работать, в принципе, и логарифом. То есть если
[55:24.960 --> 55:31.840]  у вас K это куча единиц в конце вот здесь, то это работает за логарифом. Чтобы все вот эти единички
[55:31.840 --> 55:36.000]  склеить и получить одно большего дерева, нужно по ним по всем пройтись и там проставить вот эти
[55:36.000 --> 55:40.520]  вот ссылочки, что один это предок другого. То есть в принципе каждая конкретная операция может
[55:40.520 --> 55:45.360]  работать за логарифом. Но суммарно, если вы будете считать, что каждый работает за единицу, у вас
[55:45.360 --> 55:51.320]  получится корректная оценка сверху на время работы. Будет корректная ООТН. Понятно? Вот,
[55:51.320 --> 55:55.920]  ну и так работает всегда вот этот вот амортизационный анализ. Каждый конкретный может
[55:55.920 --> 56:00.640]  работать долго, но если правильно перераспределить время, то как будто бы каждый работает вот столько,
[56:00.640 --> 56:06.160]  сколько заявлено. И сумма всегда оценивается сверху суммой вот этих вот ООТ1 или в другом случае
[56:06.160 --> 56:22.400]  других функций. Да, ну можно модифицировать так, что будет не амортизирована единица, а чистая
[56:22.400 --> 56:31.280]  единица. Но это отдельное упражнение, которое мы на лекции не рассматриваем. Так, ну вот сделали.
[56:31.280 --> 56:42.520]  Отлично. Теперь давайте еще последний метод. Называется метод потенциалов. Это метод,
[56:42.520 --> 56:47.320]  альтернативный методу бухучета, методу монеток, который тоже самое позволяет делать, как-то
[56:47.320 --> 56:54.200]  получать амортизационные оценки на время работы. И так, значит, вспоминаем, пусть С структура данных,
[56:54.200 --> 57:05.440]  структура данных, и пусть Ф какая-то функция от ее состояния, пусть Ф большое от С,
[57:05.440 --> 57:18.000]  это какая-то функция состояния структуры. Ну то есть не знаю, если у нас С это массив какой-нибудь,
[57:18.000 --> 57:24.640]  то, например, феатес может быть размер массива или там длина двоичной записи чего-нибудь. В общем,
[57:24.640 --> 57:42.360]  какое-то такое свойство, которое отражает какой-то параметр нашей структуры. Пусть опять поступает
[57:42.520 --> 57:53.920]  Q запросов, пусть поступают запросы Q1 и так далее, Qn, и мы знаем потенциал нашей структуры после
[57:53.920 --> 58:11.520]  обработки каждого запроса. После обработки ИТ запроса потенциал равен ФИИТ. То есть мы знаем,
[58:11.520 --> 58:16.080]  как ведет себя вот этот вот потенциал. То, что я говорил, если там размер массива, то мы знаем,
[58:16.080 --> 58:20.700]  как он себя ведет. Сначала один, потом увеличивается в два раза, потом много раз один и то же, потом
[58:20.700 --> 58:26.120]  уменьшается в два раза и так далее. Вот какой-то потенциал после каждой операции мы знаем. Пусть
[58:26.120 --> 58:34.720]  также ТИТ это реальное время обработки ИТ запроса. Реальное время обработки ИТ запроса.
[58:41.520 --> 58:55.800]  Тогда определяем АИТ как ТИТ плюс ФИИТ минус ФИИ минус первое. То есть сколько нам реально
[58:55.800 --> 59:00.840]  пришлось поработать плюс изменение потенциала. То есть какой потенциал стал, минус какой он был.
[59:00.840 --> 59:05.800]  Плюс ФИИТ и минус ФИИ минус первое. Насколько изменился потенциал после этого запрос. Вот это
[59:05.800 --> 59:21.240]  вот будет учетное время работы. Очень похоже на метамонеток. Реальное время работы плюс что-то,
[59:21.240 --> 59:26.760]  минус что-то. Только теперь у меня не монетки, а какой-то потенциал от состояния структуры.
[59:27.360 --> 59:39.880]  Какой-то ФИИ и минус ФИИ минус первое. Учетное время работы. Ну и опять это все работает, если ФИИ конечная,
[59:39.880 --> 59:48.200]  минус ФИИ начальная больше или равно нуля. Если потенциал никогда не опускается ниже исходного
[59:48.200 --> 59:55.560]  уровня, тогда вот эти Ашки являются учетными временами работы. Доказательства здесь тоже
[59:55.560 --> 01:00:03.920]  элементарные. Мне нужно доказать, что сумма аитых, ну достаточно доказать, что сумма аитых больше
[01:00:03.920 --> 01:00:09.200]  выбрана, чем сумма теитых. Что сумма учетных стоимости, это верхняя оценка на реальное время
[01:00:09.200 --> 01:00:19.800]  работы. Ну давайте напишем, что такое сумма аитых. Это сумма теитых плюс ФИ1 минус ФИ0, плюс ФИ2 минус ФИ1,
[01:00:20.300 --> 01:00:28.660]  плюс так далее, плюс ФИН минус ФИН минус 1. Вот. Ну и тогда все вот эти соседние сократятся,
[01:00:28.660 --> 01:00:34.800]  ФИ1 сократится, ФИ2 сократится со следующим, ФИН минус М, сократится с предыдущим. И останется просто
[01:00:34.800 --> 01:00:42.240]  сумма теитых плюс ФИН минус ФИ0. Сумма теитых плюс ФИН минус ФИ 0.
[01:00:42.240 --> 01:00:51.120]  ноль так и если у меня выполняется это условие что конечно потенциал
[01:00:51.120 --> 01:00:54.080]  минус начально всегда не отрицательный тогда вот эта штука больше нуля и
[01:00:54.080 --> 01:00:57.800]  получается тоже самое не раньше что у нас было в методе в методе монеток что
[01:00:57.800 --> 01:01:04.280]  чтобы получить учетную вот эту сумму не нужно к настоящей сумме к настоящему
[01:01:04.280 --> 01:01:06.720]  времени работы прибавить что-то не отрицательное
[01:01:06.720 --> 01:01:10.400]  значит вот это не раньше выполняется
[01:01:15.840 --> 01:01:21.600]  пример использования пример использования
[01:01:23.720 --> 01:01:28.200]  упражнения даже скорее вот если мы вернемся к задачу про инсерт в
[01:01:28.200 --> 01:01:33.520]  биномиальную кучу тогда можно в качестве потенциала нашей структуры нашей
[01:01:33.520 --> 01:01:39.280]  биномиальной куче взять число единиц в конце двоичной записи текущего
[01:01:39.280 --> 01:01:47.920]  размера кучи число единиц в двоичной записи
[01:01:48.360 --> 01:01:51.880]  текущего размера кучи
[01:01:57.080 --> 01:02:00.280]  здесь в общем-то почти то же самое рассуждение просто в терминах
[01:02:00.280 --> 01:02:03.880]  потенциала вот если у меня текущее число элементов представляет в
[01:02:03.880 --> 01:02:08.280]  двоичной системе следующим образом нолик и куча единиц в конце и вот это вот
[01:02:08.280 --> 01:02:12.040]  количество этих единиц я считаю потенциалом тогда как у меня ведет
[01:02:12.040 --> 01:02:18.280]  себя ашка да когда когда я добавляю сюда новую единичку у меня время работы
[01:02:18.280 --> 01:02:22.200]  равно количество этих единиц и потенциал падает вот с пятерки до нуля
[01:02:22.200 --> 01:02:27.600]  потому что у меня это число превращается в число 1 и куча нулей здесь
[01:02:27.600 --> 01:02:31.440]  потенциал будет нулевой да и тогда как раз вот такая тяжелая операция она
[01:02:31.440 --> 01:02:36.680]  сопровождается с одной стороны падением потенциала и тогда вот эта
[01:02:36.680 --> 01:02:40.000]  вот штука отрицательна сильно отрицательна но при этом она занимает
[01:02:40.000 --> 01:02:43.480]  какое-то время работы и легко отследить что время работы как раз равно измене
[01:02:43.480 --> 01:02:49.000]  потенциала ты это равно минус дельты фи это поэтому как бы учетная учетная
[01:02:49.000 --> 01:02:54.080]  стоимость всех операций будет 0 вот таких вот операций когда мы за нуля им
[01:02:54.080 --> 01:02:57.520]  кучу единичек у меня будет учетная стоимость 0 но если там простая операция
[01:02:57.520 --> 01:03:02.960]  и не требуется вот так складывать единички то просто будет стоимость единицы
[01:03:03.440 --> 01:03:10.040]  вот понятно значит если нету вот попробуйте ну вот честно написать чему
[01:03:10.040 --> 01:03:14.080]  равен потенциал да понять как он меняется вот интерация к итерации и понять что
[01:03:14.080 --> 01:03:18.040]  вот эти ашки считаются по такой формуле они всегда равны от 1 либо 0 либо 1
[01:03:18.040 --> 01:03:22.840]  получается да конечно мы потенциал выбираем так как хотим главное чтобы
[01:03:23.160 --> 01:03:30.600]  нужно чтобы получилось наиболее опсимальное время работы какой мы можем
[01:03:30.600 --> 01:03:34.800]  получить вот у нас мы еще посмотрим у нас что будет потенци셔서 чуть позже
[01:03:34.800 --> 01:03:38.080]  когда мы будем говорить про деревья у нас там будет с плей дерево и время
[01:03:38.080 --> 01:03:41.640]  работы там тоже очень активно будет считаться через потенциал если мы увидим
[01:03:41.640 --> 01:03:47.360]  правильный потенциал у нас получится луч wh obscure на учетное время работы
[01:03:47.360 --> 01:03:51.400]  то есть нам нам вот здесь вот никто не говорит как уп casale выбирать если мы
[01:03:51.400 --> 01:03:56.240]  выберем такой, что аитое получится очень маленьким, значит, ну мы победили. Чем
[01:03:56.240 --> 01:04:00.280]  чем лучше наша оценка, тем мы точнее смогли оценить сверху время работы нашей
[01:04:00.280 --> 01:04:05.400]  программы. А это нам и нужно. Нам нужно оценить сверху время работы программы всегда.
[01:04:05.400 --> 01:04:25.200]  Так, хорошо. Тогда, наверное, с амортизационным анализом пока что все. Мы к нему еще вернемся
[01:04:25.200 --> 01:04:30.680]  чуть позже, как я сказал. Пока давайте мы разберем следующую структуру данных, которая называется
[01:04:30.680 --> 01:04:39.880]  спаррстейбл. Классическая задача, которую решает спаррстейбл, такова. У нас есть массив чисел,
[01:04:39.880 --> 01:04:46.800]  давайте считать, что занумерованный с нуля а 0, а 1, а 2 и так далее а n минус 1. И он неизменяемый.
[01:04:46.800 --> 01:04:55.920]  Неизменяемый. Я буду еще иначе говорить статический. Статический. То есть сами числа
[01:04:55.920 --> 01:05:05.720]  а и т никогда меняться не будут. И поступают запросы всего одного типа. Запрос. По двум числам
[01:05:05.720 --> 01:05:14.520]  l и r нужно найти минимум на отрезке с l по r. Найти минимальное число среди множества a lt,
[01:05:14.520 --> 01:05:29.720]  a l плюс 1 и так далее a rt. То есть минимум на отрезке. А за сколько вы умеете? Вот, мы научимся
[01:05:29.720 --> 01:05:43.000]  сделать единицы. Мы научимся находить минимум на отрезке за вот единицы. Решение довольно простое.
[01:05:43.000 --> 01:05:55.840]  Смотрите, давайте мы введем следующее обозначение. Пусть sparse rt, нет r плохо, давайте kt и t. Это
[01:05:55.840 --> 01:06:02.760]  минимум на отрезке длины 2 вкатой со стартом в точке i. Формально это минимум такого множества.
[01:06:02.760 --> 01:06:11.600]  Минимум среди а и т, а и плюс 1 и так далее и так далее, вплоть до и плюс 2 вкатой минус 1. То есть
[01:06:11.600 --> 01:06:17.360]  мы взяли это элемент в нашем массиве. Вот был весь массив. Мы взяли эту позицию, приложили сюда
[01:06:17.360 --> 01:06:23.800]  отрезок длины 2 вкатой и на нем нашли минимум. Вот на таком отрезке длины 2 вкатой нашли минимум.
[01:06:23.800 --> 01:06:30.280]  Тогда если я вот это вот быстро насчитаю, ну понятно, что k достаточно брать до логарифма,
[01:06:30.280 --> 01:06:34.560]  крайне большим логарифм, потому что если у нас k большим логарифм, то мы обязательно вылезем за
[01:06:34.560 --> 01:06:40.440]  пределы массива, это бессмысленно. Вот, если мы этот массив смогли насчитать, то тогда найти
[01:06:40.440 --> 01:06:44.720]  минимум на любом отрезке довольно просто. Смотрите, вот мне нужно найти минимум на отрезке с l по r,
[01:06:44.720 --> 01:06:52.080]  с l по r. Давайте тогда найдем максимальную степень двойки, которая целиком умещает в этот отрезок,
[01:06:52.080 --> 01:06:58.000]  то есть 2 вкатой, максимально, но при этом не больше, чем r минус l плюс 1, не больше длина
[01:06:58.000 --> 01:07:06.200]  отрезка. И теперь приложим этот отрезок слева и справа, к l и к r. Тогда они пересекутся,
[01:07:06.200 --> 01:07:10.320]  но главное, что в объединении они покроют целиком этот отрезок. Вот эти элементы все покрыты
[01:07:10.320 --> 01:07:14.800]  и эти элементы все покрыты. Ну а дальше, если я знаю минимум с верхнего отрезка и минимум с нижнего
[01:07:14.800 --> 01:07:20.720]  отрезка, то чтобы получать глобальный минимум, мне нужно взять минимум из них. Потому что все равно
[01:07:20.720 --> 01:07:25.200]  каждый элемент здесь учтен, и если минимум где-то и находится, вот здесь, скажем, х, то обязательно
[01:07:25.200 --> 01:07:29.280]  минимум в одной из половинок будет обязательно х, и поэтому минимум из двух минимумов это обязательно
[01:07:29.280 --> 01:07:36.680]  ответ. И здесь одно из приятных свойств минимума в том, что если мы как бы пересекаем наше множество,
[01:07:37.640 --> 01:07:42.700]  какие-то элементы вот эти вот, они участвуют, как бы они влияют и на минимум вот здесь и на
[01:07:42.700 --> 01:07:47.520]  минимум вот здесь. Но минимум такая хорошая операция, что если мы добавляем одни и те же числа в
[01:07:47.520 --> 01:07:52.080]  множество, по которым мы берем эту операцию, скажем, вот здесь были какие-то числа, если я какие-то числа
[01:07:52.080 --> 01:07:57.960]  буду дублировать, у меня и минимум не изменится. А если бы была какая-нибудь другая операция,
[01:07:57.960 --> 01:08:03.120]  например, вот здесь вместо минимума была бы сумма или произведение, тогда так бы уже не сработало.
[01:08:03.120 --> 01:08:05.640]  потому что если я знаю сумму вот здесь вот и сумму вот здесь вот,
[01:08:05.640 --> 01:08:09.280]  тогда мне нужно их сложить, но еще вычесть вот эти вот повторные элементы.
[01:08:09.280 --> 01:08:12.880]  А прелесть минимума как раз в том, что ничего вычитать не нужно.
[01:08:12.880 --> 01:08:26.280]  Для каждого k и для каждого i мы прикладываем отрезок длины 2 вкаты к этой позиции
[01:08:26.280 --> 01:08:28.680]  и считаем минимум вот на этом отрезке, длины 2 вкатых.
[01:08:28.680 --> 01:08:32.280]  То есть формально минимум среди вот такого множества.
[01:08:32.280 --> 01:08:35.360]  Аи-то, аи-плюс-первые и так далее и плюс 2 вкатые минус 1.
[01:08:35.360 --> 01:08:42.640]  Главное следующее, главное, что мы для любой стартной позиции и для любой длины отрезка
[01:08:42.640 --> 01:08:45.080]  равной степени двойки знаем на нем минимум.
[01:08:45.080 --> 01:08:50.320]  И тогда если мы это посчитали, то минимум на отрезке lr это минимум среди вот такого отрезка
[01:08:50.320 --> 01:08:54.520]  и такого отрезка. А такие мы уже знаем, потому что это степени двойки, мы на них уже посчитали ответ.
[01:09:02.280 --> 01:09:11.160]  Итак, давайте сначала тогда начитаем этот массив.
[01:09:11.160 --> 01:09:18.520]  На счет sparse. Первый слой очень простой.
[01:09:18.520 --> 01:09:23.040]  Sparse, нулевое и-то, это просто всегда аи-то.
[01:09:23.040 --> 01:09:31.680]  Если кара на нулю, то я получается прикладываю отрезок длины 1 к и-то позиции и беру минимум на отрезке длины 1.
[01:09:31.800 --> 01:09:34.600]  Ну это просто само число. Это очевидно.
[01:09:34.600 --> 01:09:43.360]  Дальше пусть мне известны sparse, kt, я вот так пишу, kt точка.
[01:09:43.360 --> 01:09:48.280]  То есть я знаю sparse, где первый аргумент k и для любого второго аргумента.
[01:09:48.280 --> 01:09:53.480]  То есть мне известно целиком строка этой матрицы. Я знаю kt строчку целиком.
[01:09:53.480 --> 01:10:01.880]  Тогда как найти sparse, k плюс первое, какое-нибудь конкретное и-тое?
[01:10:01.880 --> 01:10:06.800]  Sparse, k плюс первое, и-тое. Очень просто.
[01:10:06.800 --> 01:10:10.480]  Что такое sparse, k плюс первое, и-тое?
[01:10:10.480 --> 01:10:16.840]  Это мне нужно посмотреть на и-тою позицию в массиве, приложить отрезок длины 2 в степени k плюс 1.
[01:10:16.840 --> 01:10:20.920]  2 в степени k плюс 1 и найти на нем минимум.
[01:10:21.760 --> 01:10:26.800]  Ну тогда давайте я этот отрезок поделю пополам. Получится у меня два отрезка длины 2 вкатый.
[01:10:26.800 --> 01:10:31.200]  Ровно два отрезка длины 2 вкатый, на каждом из которых минимум уже известен.
[01:10:31.200 --> 01:10:38.160]  Потому что я знаю для каждого начала, знаю минимум на отрезках длины 2 вкатый с этим началом.
[01:10:38.160 --> 01:10:40.640]  То есть я знаю минимум вот здесь, минимум вот здесь.
[01:10:40.640 --> 01:10:44.040]  Тогда минимум из них равен тому, чему нужно.
[01:10:45.000 --> 01:10:49.040]  Формально можно написать так. Пусть g это i плюс 2 вкатый.
[01:10:49.040 --> 01:10:56.640]  Тогда sparse, k плюс первое, и-тое.
[01:10:56.640 --> 01:11:02.520]  Это минимум из sparse, k-тое, и-тое.
[01:11:02.520 --> 01:11:04.520]  И sparse, k-тое, g-тое.
[01:11:11.120 --> 01:11:13.120]  Понятно ли эта формула?
[01:11:15.040 --> 01:11:22.040]  Просто чтобы найти минимум на отрезках длины 2 вкатый плюс 1, я его бью на два кусочка одинаковой длины 2 вкатый.
[01:11:22.040 --> 01:11:26.040]  И минимум на них неизвестен. Вот этот вот минимум хранится здесь, да, в этом числе.
[01:11:26.040 --> 01:11:31.040]  Минимум с этого отрезка хранится в этом числе. Вот и все. И просто из них выбираю минимум.
[01:11:33.040 --> 01:11:38.040]  Ну, смотрите, я иду в проект возрастания k. Для k в нулю мне известны такие и такие минимумы.
[01:11:38.040 --> 01:11:43.040]  А дальше пусть мне известна целиком k-тое строчка, то есть я знаю, давайте напишу так.
[01:11:43.040 --> 01:11:49.040]  Для любого s мне известна sparse, k-тое, st. То есть я знаю целиком как бы k-тое слой.
[01:11:49.040 --> 01:11:55.040]  Теперь пытаюсь начать k плюс 1. Ну тогда мне вот это известно, и вот это известно, и я тогда знаю k плюс 1.
[01:11:58.040 --> 01:12:03.040]  Ну деревоотресков это громкое слово, но чуть-чуть похоже, да.
[01:12:03.040 --> 01:12:06.040]  Но это не деревоотресков, тем не менее.
[01:12:06.040 --> 01:12:10.040]  Потому что как минимум оно занимает n log n памяти, а деревоотресков линейный память занимает.
[01:12:11.040 --> 01:12:18.040]  Вот-вот-вот. Да, тут лучше нарисовать, вот оно, g вот здесь.
[01:12:18.040 --> 01:12:23.040]  Это начало вот этого второго кусочка. И начало левого кусочка g, и начало правого кусочка.
[01:12:23.040 --> 01:12:30.040]  Так, ну давайте код напишем тогда быстренько, если мы успеваем. Да, успеваем.
[01:12:30.040 --> 01:12:35.040]  Ну вот пусть есть у меня массив a.
[01:12:35.040 --> 01:12:47.040]  Сначала вот первая строчка я переписываю, и от 0 до n-1 я пишу, что sparse 0 i t это i t.
[01:12:47.040 --> 01:12:55.040]  Дальше я перебираю k от 0 до, ну вот здесь до логарифма, скажем, округленного.
[01:12:55.040 --> 01:13:02.040]  Ну давайте пока просто до логарифма, не будем думать, что там именно.
[01:13:10.040 --> 01:13:14.040]  До логарифма. Вложенный цикл по i от 0 до n-1.
[01:13:14.040 --> 01:13:18.040]  Заводим переменную g равную i плюс 2 вкатой.
[01:13:18.040 --> 01:13:30.040]  И говорим, что sparse k плюс первая i t это минимум из, ну вот то, что там написано справа.
[01:13:30.040 --> 01:13:45.040]  Все, весь алгоритм нахождения sparse table. Нахождение всех вот этих вот минимумов на отрезках.
[01:13:45.040 --> 01:13:53.040]  Так, асимптотика, здесь очевидно n log n. Даже я напишу theta от n log n.
[01:13:53.040 --> 01:13:58.040]  Потому что у меня есть массив размера, ну какие у него размерности.
[01:13:58.040 --> 01:14:06.040]  Первое число у меня до логарифма, второе число у меня до n, там все числа могут быть, от 0 до n-1.
[01:14:06.040 --> 01:14:10.040]  Получается у меня массив размера n log n, и каждое конкретное я насчитываю за от и единицы.
[01:14:10.040 --> 01:14:15.040]  Вот каждое конкретное sparse значение я нахожу как минимум из двух чисел, которые мне уже известны.
[01:14:15.040 --> 01:14:22.040]  То есть каждое число считается за от и единицы, поэтому суммарная симптотика просто n log n. Понятно?
[01:14:22.040 --> 01:14:31.040]  Ну, значит, sparse я насчитал. А дальше напишем код, как найти минимум на отрезке.
[01:14:39.040 --> 01:14:48.040]  Как найти минимум на отрезке? GetMin int l, int r.
[01:14:48.040 --> 01:15:00.040]  Сначала, как я и говорил, давайте скажем, что k, словами давайте напишем, максимальное такое, что 2 вкатой меньше либо равно r-l плюс 1.
[01:15:00.040 --> 01:15:07.040]  Тогда делаем просто return, картиночка будет нужна опять.
[01:15:07.040 --> 01:15:15.040]  Значит, есть у меня отрезок, и я прикладываю отрезок длины 2 вкатой слева и справа.
[01:15:15.040 --> 01:15:25.040]  Ну, соответственно, минимум из sparse вкатая l-t и sparse тоже вкатая.
[01:15:25.040 --> 01:15:29.040]  Только теперь вот здесь нужно написать начало этого отрезка.
[01:15:29.040 --> 01:15:35.040]  Начало этого отрезка это, видимо, r-2 вкатой плюс 1.
[01:15:35.040 --> 01:15:39.040]  Плюс 1.
[01:15:39.040 --> 01:15:43.040]  Скопка закрылась.
[01:15:43.040 --> 01:15:45.040]  Понятно?
[01:15:50.040 --> 01:15:52.040]  Так, ну тут есть несколько вопросов.
[01:15:52.040 --> 01:15:56.040]  Во-первых, как считать 2 вкатой быстро?
[01:15:56.040 --> 01:15:59.040]  Ну, как это написать на C++?
[01:15:59.040 --> 01:16:01.040]  Во-вторых, как вычитать такое k?
[01:16:01.040 --> 01:16:04.040]  Максимальная степень двойку не больше, чем что-то.
[01:16:04.040 --> 01:16:06.040]  И в-третьих, почему это вообще верно?
[01:16:06.040 --> 01:16:10.040]  Почему эти отрезки обязательно целиком покроют наш отрезок l?
[01:16:10.040 --> 01:16:12.040]  Ответы на все эти три вопроса очень простые.
[01:16:12.040 --> 01:16:15.040]  С++ есть команда bit и сдвиг.
[01:16:15.040 --> 01:16:19.040]  Если вы напишете 1 меньше меньше k, то вы как раз получите 2 вкатой.
[01:16:19.040 --> 01:16:21.040]  1 меньше меньше k это в точности 2 вкатой.
[01:16:21.040 --> 01:16:23.040]  Работает это так.
[01:16:23.040 --> 01:16:26.040]  То есть как воспринимает такую команду компилятор?
[01:16:26.040 --> 01:16:29.040]  Он пишет двоичное число 1 в двоичной записи.
[01:16:29.040 --> 01:16:31.040]  То есть это 1 и куча нулей слева.
[01:16:31.040 --> 01:16:35.040]  А потом выполняет сдвиг на k позиции влево.
[01:16:35.040 --> 01:16:38.040]  То есть просто берет и вот так вот целиком сдвигает влево.
[01:16:38.040 --> 01:16:40.040]  Получается вот такое число.
[01:16:40.040 --> 01:16:42.040]  Сдвигает влево на k позиции.
[01:16:42.040 --> 01:16:47.040]  Потом вот этот префикс обрубает, который вылезает за пределы 32 бит.
[01:16:47.040 --> 01:16:51.040]  И получается у вас как раз число, где единица стоит на кате с правой позиции.
[01:16:51.040 --> 01:16:53.040]  То есть в точности 2 вкатой.
[01:16:53.040 --> 01:16:55.040]  А была единица, а стала 2 вкатой.
[01:16:55.040 --> 01:16:58.040]  Вот так работает бинарный сдвиг влево с++.
[01:17:03.040 --> 01:17:06.040]  Второй вопрос. Какой у меня был?
[01:17:06.040 --> 01:17:08.040]  Как найти вот такое k?
[01:17:08.040 --> 01:17:11.040]  Ну самое простое, что можно сделать, это их все предпочитать.
[01:17:14.040 --> 01:17:21.040]  Наверное самое простое это посчитать какой-нибудь логарифм двоичный от этой штуки и округлить его куда-нибудь.
[01:17:21.040 --> 01:17:28.040]  Но такое есть правило, что если можно обойтись без логарифмирования, потенцирования и так далее,
[01:17:28.040 --> 01:17:31.040]  то есть без перехода к вещественным числам, то так лучше сделать.
[01:17:31.040 --> 01:17:35.040]  Потому что если вы считаете двоичный логарифм, то вы переходите обязательно либо к доблам,
[01:17:35.040 --> 01:17:41.040]  либо к тишам, еще каким-то типам, у вас может откуда возникнуть ошибка, погрешность и так далее и так далее.
[01:17:41.040 --> 01:17:43.040]  Поэтому давайте мы обойдемся без логарифмирования.
[01:17:43.040 --> 01:17:45.040]  Ну это очень просто.
[01:17:45.040 --> 01:17:56.040]  Давайте пусть дег хt это как раз вот то самое k такое, что 2 вкатой меньше, чем х.
[01:17:56.040 --> 01:18:01.040]  То есть для каждого х посчитаем максимальную степень войки, которая его не превосходит.
[01:18:01.040 --> 01:18:05.040]  И этот массив дег предпочитаем в самом начале вот здесь, в нашем алгоритме.
[01:18:05.040 --> 01:18:10.040]  То есть там, где мы объявляем массив а и считаем его, мы также посчитаем все деги.
[01:18:10.040 --> 01:18:12.040]  Считаются они очень просто.
[01:18:12.040 --> 01:18:15.040]  Дег от 1 это 0.
[01:18:15.040 --> 01:18:21.040]  Максимальная степень войки, которая не превосходит 1, это 2 в 0.
[01:18:21.040 --> 01:18:23.040]  Дальше.
[01:18:23.040 --> 01:18:26.040]  Идем по всем...
[01:18:26.040 --> 01:18:29.040]  Так, сейчас.
[01:18:29.040 --> 01:18:32.040]  Ну можно сделать как угодно, давайте я напишу, как я привык.
[01:18:32.040 --> 01:18:36.040]  Значит, перебираем х от 2 до n.
[01:18:36.040 --> 01:18:43.040]  Сначала говорим, что дег от ха это то же самое, что дег от х-1.
[01:18:43.040 --> 01:18:48.040]  То есть сначала говорим, что если х увеличится на единичку, то максимальная степень войки не увеличивается.
[01:18:48.040 --> 01:18:52.040]  Но потом, когда может увеличиться максимальная степень войки?
[01:18:52.040 --> 01:18:55.040]  Когда у него было какое-то число, давайте я двоичную запись напишу.
[01:18:55.040 --> 01:18:56.040]  Вот.
[01:18:56.040 --> 01:18:58.040]  Было какое-то число.
[01:18:58.040 --> 01:19:04.040]  Я к нему прибавил единицу, и у меня увеличилась максимальная степень войки, которая его меньше или равна.
[01:19:04.040 --> 01:19:06.040]  То есть на самом деле у меня тогда обязательно картинка такая.
[01:19:06.040 --> 01:19:11.040]  Здесь были все единицы, я прибавил единицу, и у меня все они превратились в нули.
[01:19:11.040 --> 01:19:14.040]  А единица старшая переместилась влево на один разряд.
[01:19:14.040 --> 01:19:21.040]  То есть, ну, иными словами, максимальная степень войки увеличится на единицу каждый раз, когда мы переходим в новую степень войки.
[01:19:21.040 --> 01:19:29.040]  Если мы знаем, что в тройке максимальная степень войки это 2, мы переходим в четверку, то максимальная степень войки становится равно 4.
[01:19:29.040 --> 01:19:41.040]  Здесь нужно написать такое условие, что если х это степень войки, тогда нужно сделать плюс-плюс дега от х.
[01:19:41.040 --> 01:19:46.040]  То есть, если я перешел в число, которое само по себе равно степень войки, то нужно эту дегу увеличить.
[01:19:47.040 --> 01:19:57.040]  И тогда вот здесь вот к можно писать просто дег от r-l плюс 1 с помощью вот этого массива, который я начал в самом начале.
[01:20:07.040 --> 01:20:11.040]  Теперь нам нужно еще научиться эффективно проверять, что х это степень войки.
[01:20:11.040 --> 01:20:20.040]  Ну, я утверждаю, что это выполняется в том случае, когда выполняется следующее условие.
[01:20:27.040 --> 01:20:29.040]  Так, ну что здесь есть?
[01:20:30.040 --> 01:20:32.040]  Выполняется следующее условие.
[01:20:40.040 --> 01:20:48.040]  Так, ну что здесь написано? Я считаю х, считаю х-1. Затем беру их побитую конъюнкцию.
[01:20:48.040 --> 01:20:51.040]  Вот я представляю, что х это у меня какое-то бинарное число в двоичной записи.
[01:20:51.040 --> 01:20:57.040]  х-1 это тоже двоичное число в записи с нулями единицами. Затем беру побитую их конъюнкцию.
[01:20:58.040 --> 01:21:01.040]  Так, что такое конъюнкция, понимаем, побитая?
[01:21:02.040 --> 01:21:06.040]  Ну, там если здесь 0, 0, то здесь 0, если тут 0, 1, то здесь 1.
[01:21:08.040 --> 01:21:11.040]  1, 1 переходит в 1, а 1, 0 переходит в 0.
[01:21:11.040 --> 01:21:13.040]  Вот так побитого делаю конъюнкцию.
[01:21:13.040 --> 01:21:18.040]  И утверждается, что если в конце получился 0, ну или там иными словами, если...
[01:21:18.040 --> 01:21:21.040]  Ну так работает, что вот вы это число посчитали.
[01:21:21.040 --> 01:21:25.040]  Давайте я напишу вот так. Можно написать вот так, что это просто равно 0.
[01:21:25.040 --> 01:21:27.040]  Вот это выражение.
[01:21:28.040 --> 01:21:33.040]  Либо то, что у меня было написано раньше, воскреслятельный знак, х, ant, х-1.
[01:21:34.040 --> 01:21:40.040]  If так работает, что если вы ему передаете внутри число, и оно нулевое, то оно считается false,
[01:21:40.040 --> 01:21:42.040]  а если оно не нулевое, то считается true.
[01:21:42.040 --> 01:21:48.040]  Если наоборот вы ставите воскреслятельный знак, то есть отрицание, то получается, что если вот это было 0, то условие верно,
[01:21:48.040 --> 01:21:49.040]  если это не 0, то это неверно.
[01:21:49.040 --> 01:21:52.040]  Ну иными словами можно написать, что вот это ant должен быть равен нулю.
[01:21:52.040 --> 01:21:59.040]  Ну и как раз в каком случае ant этих двух чисел 0 только в случае, когда х это степень двойки.
[01:21:59.040 --> 01:22:04.040]  Например, пусть х это степень двойки. То есть куча нулей, один и куча нулей.
[01:22:04.040 --> 01:22:10.040]  Тогда х-1 ведет себя так. Здесь остается куча нулей, единица переходит в 0, а здесь куча единиц.
[01:22:10.040 --> 01:22:13.040]  Ну понятно тогда, что их конъюнкция это куча нулей.
[01:22:13.040 --> 01:22:18.040]  Потому что у вас нет ни одного разряда, где и в х, и в х-1 стоит единица.
[01:22:19.040 --> 01:22:23.040]  Поэтому если х это степень двойки, то конъюнкция обязательно нулевая.
[01:22:23.040 --> 01:22:29.040]  Наоборот, если х это не степень двойки, значит у него в двоичной записи есть хотя бы две единицы.
[01:22:30.040 --> 01:22:33.040]  У него в двоичной записи есть хотя бы две единицы.
[01:22:33.040 --> 01:22:42.040]  Ну и тогда х-1 сохраняет на месте старшую из них, младшую может превратить в 0.
[01:22:42.040 --> 01:22:45.040]  Но главное, что после конъюнкции у вас старшая обязательно сохранится.
[01:22:45.040 --> 01:22:51.040]  Поэтому если х это не степень двойки, то хотя бы один общий бит у них будет, значит конъюнкция не нулевая.
[01:22:51.040 --> 01:22:53.040]  Поэтому это условие не пройдет.
[01:22:56.040 --> 01:23:04.040]  Поэтому вместо вот этого гуманитарной проверки, что х это степень двойки, мы пишем вот это условие, что если это 0, тогда мы увеличиваем дегат х.
[01:23:05.040 --> 01:23:06.040]  Да.
[01:23:14.040 --> 01:23:15.040]  Вот это?
[01:23:19.040 --> 01:23:21.040]  Это я таблицу для конъюнкции нарисовал.
[01:23:22.040 --> 01:23:25.040]  Да, смущающе, давайте не будем это писать.
[01:23:25.040 --> 01:23:27.040]  Просто если у вас есть два числа, как считается конъюнкция?
[01:23:27.040 --> 01:23:32.040]  По битве я написал, что конъюнкция 0 это 0, 0,1 это 0, 1,1 это 1, 1, 0 это 0.
[01:23:32.040 --> 01:23:34.040]  Это я написал таблицу для конъюнкции.
[01:23:37.040 --> 01:23:44.040]  Так, и последний вопрос, который нам остался, это почему верно вот эта вот формула, что почему мы целиком покроем наш отрезок?
[01:23:45.040 --> 01:23:51.040]  Почему приложить отрезок длины 2 вкатой слева и 2 вкатой справа обязательно целиком все покроют?
[01:23:52.040 --> 01:23:55.040]  Ну пусть не так, пусть мы не покрываем все целиком.
[01:23:55.040 --> 01:24:01.040]  То есть был вот наш массив, есть наш отрезок LR, и мы приложили слева 2 вкатой, справа 2 вкатой.
[01:24:01.040 --> 01:24:03.040]  И мы покрыли не все элементы отрезка.
[01:24:03.040 --> 01:24:07.040]  То есть у меня где-то здесь еще есть хотя бы один не покрытый, вот такой свободный.
[01:24:07.040 --> 01:24:14.040]  Ну тогда это значит, что 2 вкатой плюс 2 вкатой меньше, чем длина отрезка R-L плюс 1.
[01:24:16.040 --> 01:24:22.040]  Тогда K можно увеличить, взять следующую степень двойки, и будет выполняться такое неравенство, что мы изначально K взяли неверным.
[01:24:23.040 --> 01:24:25.040]  А еще раз, если... сейчас звенит.
[01:24:25.040 --> 01:24:31.040]  Еще раз, если у меня вот эти два отрезочка слева и справа не покрывают целиком мой отрезок LR,
[01:24:31.040 --> 01:24:34.040]  значит есть какой-то свободный элемент, не покрытый ни одним из них,
[01:24:34.040 --> 01:24:38.040]  тогда суммарная длина этих отрезков меньше, чем R-L плюс 1.
[01:24:38.040 --> 01:24:41.040]  А значит исходное K выбрано неверно, его можно увеличить,
[01:24:41.040 --> 01:24:45.040]  неравенство сохранится, что 2 в степени K плюс 1 будет меньше, чем R-L плюс 1.
[01:24:45.040 --> 01:24:49.040]  Значит исходное K подобрано неправильно, а мы предположили, что правильно.
[01:24:50.040 --> 01:24:53.040]  Все, значит мы целиком покроем отрезок и минимум там правильно найдем.
[01:24:55.040 --> 01:24:58.040]  И это работает за от идицы, потому что мы все правильно уже предпочитали.
[01:24:58.040 --> 01:25:04.040]  Мы знаем спасибо большое, мы знаем K, мы знаем вот это, мы знаем вот это,
[01:25:04.040 --> 01:25:06.040]  берем минимум за от идицы и получаем ответ.
[01:25:07.040 --> 01:25:08.040]  Все, спасибо.
