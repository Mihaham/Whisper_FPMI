[00:00.000 --> 00:09.640]  Так, такая у нас лекция по счету, по-моему, восьмая. Сегодня мы продолжим изучать потоки,
[00:09.640 --> 00:16.200]  ну поиск, алгоритм поиска потока и, надеюсь, закончим на этом на сегодня.
[00:16.200 --> 00:22.880]  Вот, ну окей, у нас с вами была схема Форд-Авкерсона, напомню.
[00:22.880 --> 00:43.600]  Которая заключалась в следующем, что шаг нулевой у вас fthds равен нулю. И что вы делали дальше? Вы
[00:43.600 --> 01:05.360]  берете, находите путь P, шаг второй, давайте в nf, шаг второй пропускаете
[01:05.360 --> 01:22.880]  вдоль P поток f', шаг третий, вы говорите, что f равно f плюс f', и четвертая, это
[01:22.880 --> 01:36.000]  перестроите nf, потому что у вас поток изменился, перестраивайте остаточную сеть. Это схема
[01:36.000 --> 01:42.280]  Форд-Авкерсона, ну или Фалкерсона. Вот, там разные варианты, как находить тот путь, либо
[01:42.280 --> 01:47.040]  DFS ему получить алгоритм Форд-Авкерсона, либо BFS ему получить алгоритм Адманса Карпа,
[01:47.040 --> 01:53.600]  здесь все присоединяется к остальному, одинаково. Вот, в этот раз нам предстоит
[01:53.600 --> 02:02.120]  познакомиться с новой схемой. Схема Диница, так называемая. Нам понадобится несколько определений,
[02:02.120 --> 02:19.600]  и определение первое. Пусть это сеть, тогда
[02:19.600 --> 02:36.920]  слоистой сетью nl, l от слова layer. Обзовем следующую штуку.
[02:36.920 --> 02:50.360]  AGL, VEL, TL, ST. То есть, у нас вершины не меняются, ST не меняются, меняются рёбра, меняются
[02:50.360 --> 03:13.240]  capacity. В чем суть? Где EL равно множеству UV таких, что UV лежит в Е, и dist от S до U, это dist
[03:13.240 --> 03:23.160]  от S до V, minus 1. То есть, вы оставляете только рёбра, которые ведут в следующий слой. Картинка
[03:23.160 --> 03:43.080]  сейчас будет, не расстраивайтесь. И есть CL. Это CL от UV обозначен. UV, если UV лежит
[03:43.680 --> 04:03.560]  0 иначе равно. То есть, у нас есть наша точка S, вершинка S. У нас есть какие-то слои, здесь там T.
[04:03.560 --> 04:11.400]  И вы оставляете только рёбра из S в первый слой, из первого слоя только во второй слой.
[04:11.400 --> 04:24.600]  Такое. Ну, соответственно, здесь тоже как-нибудь так вот. То есть, вы оставляете только те рёбра,
[04:24.600 --> 04:31.600]  у которых расстояние проходит между седними слоями. Вот. Какие рёбра еще могут быть?
[04:31.600 --> 04:37.960]  Ну, могут быть рёбра, которые внутри слоя. Мы их не рассматриваем как раз-таки. Рёбра,
[04:37.960 --> 04:42.600]  которые ведут назад, тоже могут быть. Мы их тоже не рассматриваем. Соответственно,
[04:42.600 --> 04:50.520]  как построить слоистую сеть? Вау, надо запустить BFS. Все рёбра, которые BFS просмотрит и явно пройдет
[04:50.520 --> 04:56.920]  по ним, они как раз-таки будут в слоистой сети лежать. То есть, это те рёбра, которые ведут еще
[04:57.000 --> 05:04.760]  в неизведанную вершину, скажем так. Не то что в неизведанную, а вершину,
[05:04.760 --> 05:12.160]  которая еще не помечена раскрытой. Вот так вот. Ну, цель понятна, это просто сужение нашей
[05:12.160 --> 05:36.880]  капасти на эти рёбра. И давайте еще одно определение. Пусть F – это поток ВМ. Тогда F блокирующий
[05:42.240 --> 06:02.040]  А если F нельзя увеличить? Нельзя увеличить, не строя NF. То есть, не строя остаточной сети.
[06:02.040 --> 06:07.080]  То есть, чем у нас была хороша наша остаточная сеть? Тем, что она обратными рёбрами позволяла
[06:07.080 --> 06:11.800]  отменять единицу потока, текущую через рёбро. Здесь мы себе это краски запрещаем.
[06:11.800 --> 06:16.880]  Ну, давайте сначала пример для блокирующего потока.
[06:16.880 --> 06:40.560]  Один из одного, один из одного, один из одного, здесь один. Вот пример блокирующего потока,
[06:40.560 --> 06:46.440]  потому что вы его явно никак увеличить не можете, не вводя обратные рёбра. То есть,
[06:46.440 --> 06:50.840]  как мы выискали максимальный поток? Мы ввели здесь обратное рёбро с способностью единицы,
[06:50.840 --> 06:55.800]  потом построили бы этот путь, который был бы то же самое, что мы отменяем вот эту единицу потока
[06:55.800 --> 07:03.160]  и проводим еще здесь по единице потока. Вот, в блокирующем потоке мы не строим остаточную сеть,
[07:03.160 --> 07:08.240]  поэтому у нас, собственно, этот поток блокирующий. Ну, это пример, когда блокирующий поток не
[07:08.240 --> 07:25.120]  является максимальным, в общем-то. Ну вот, окей. Собственно, давайте схему единицы напишем.
[07:25.120 --> 07:49.000]  Да, сразу скажу, что у диница фамилия Динец, вот, это автор, уважаемый советский ученый Ефим
[07:49.000 --> 08:00.400]  Динец, поэтому ставьте родительный падеж через нужную форму, то есть не динецы, а динеца. Вот,
[08:00.400 --> 08:10.400]  когда говорят алгоритм динецы, где-то рядом плачет один Ефим Динец. Вот, окей. Схема такая. Ну,
[08:10.400 --> 08:28.920]  нулевой шаг понятно, F тож, ясно, равны нулю. Шаг первый это, давайте так, строим NF. Шаг
[08:28.920 --> 08:41.880]  второй. Строим NFL, строим слоистую сеть по остаточной сети. Уже достоин, да, двойный индекс.
[08:41.880 --> 09:08.760]  Шаг третий. Находим блокирующий поток F' в NFL. Шаг четвертый. F' равно F'. Все. Соответственно,
[09:08.760 --> 09:14.400]  заканчивается алгоритм, когда вы не смогли найти блокирующий поток. То есть, как бы,
[09:14.400 --> 09:19.120]  смогли найти поток величины ноль. Это значит, что из-за недостижимоты в остаточной сети,
[09:19.120 --> 09:24.360]  потеряем форда Фоккерсон, вы нашли максимальный поток. Поэтому корректность очень тривиальная у
[09:24.360 --> 09:33.960]  этой схемы. Теперь нужно оценить время работы. Ну, давайте подумаем, где тут такие шаги. Ну,
[09:33.960 --> 09:41.680]  это очевидно от V plus E. Почему? Потому что на остаточной сеть построить легко. Грубо говоря,
[09:41.680 --> 09:47.320]  вы должны пробежаться по всем ребрам, которых у вас... Ну, и построить там обратные ребра,
[09:47.320 --> 09:57.080]  пересчитать их там. Поток через них и остаточная вместимость через ребро обратное и прямое. Это
[09:57.080 --> 10:21.000]  тоже от V plus E. Это запуск VFS. Это проход по всем ребрам. Так. Ну, это тоже очевидно. Это проход по
[10:21.000 --> 10:31.320]  ребрам. И остаются два момента. Первый момент – это сколько итераций. Второй момент – как
[10:31.320 --> 10:43.560]  сказать блокирующий поток. Первый F также сноровный нулю. Ну, инициация алгоритма у нас F тоже сноровенный
[10:43.560 --> 10:54.840]  нулю. Поэтому F от N не отличается здесь. Ну, давайте здесь напишу. Говорю, шаг 4F тоже сноровенный нулю.
[10:54.840 --> 11:04.760]  Вот. Окей. Что тогда теперь? Нам нужно оценить число итераций. Давайте оценим число итераций.
[11:04.760 --> 11:18.560]  Так. Утверждение. После итерации схемы динеца
[11:18.560 --> 11:41.480]  DIST от S до T увеличивается. Вы не разлили на меня вопрос, что такое DIST от S до T в данном контексте.
[11:41.480 --> 11:47.680]  Это имеется в виду число ребер. Вот. То есть у нас нет никаких весов. Имеется в виду
[11:47.680 --> 11:53.720]  реберное расстояние или то, что все веса равны единице. Так. Я утверждаю, что после итерации,
[11:53.720 --> 11:59.000]  после каждой итерации расстояние только увеличивается. Ну, доказательствую,
[11:59.000 --> 12:04.560]  что тут будет методом рукомахания и рисования картинок. Надеюсь, вы не разочарованы в этом.
[12:04.560 --> 12:16.400]  А как у нас устроен наш алгоритм? Вот он нашел какой-то блокирующий поток слейсты сети.
[12:16.400 --> 12:38.360]  Так, давайте побольше ребер нарисуем. Что мы с вами сделали? Мы строили с вами
[12:39.200 --> 12:49.800]  и мы нашли блокирующий поток f' . Что происходит при добавлении потока f' ? Как меняется? Давайте
[12:49.800 --> 13:07.680]  посмотрим так. Как меняется nf plus f'l относительно nfl? То есть когда вы увеличили поток, что у вас
[13:07.680 --> 13:17.440]  может измениться? Ну, утверждается, что что может произойти? Первое, что может произойти,
[13:17.440 --> 13:35.720]  это у вас добавятся обратные ребра новые. Обратные ребра. Ну, которые вот ведут,
[13:35.720 --> 13:42.720]  например, мы это ребро насытили, значит оно развернется. Второе, что может случиться, это
[13:42.720 --> 13:57.560]  если мы насытили ребро, значит у нас активируется ребро вот такой вот внутри слоя. Ну, мы же с вами
[13:57.560 --> 14:02.360]  перестроили по новому потоку. Мы с вами построили новый поток, построили новую остаточную сеть,
[14:02.360 --> 14:07.360]  которая могла уже добавиться, которой это ребро существовало. Потом сделали слоистую, так у вас
[14:07.360 --> 14:15.920]  это насыщенное ребро, у вас его нет, у вас там могло вот так вот произойти. Добавились ребра внутри
[14:15.920 --> 14:34.640]  слоя. Ну и шаг третий, это у вас, собственно, могли удалиться ребра слева направо. Назовем эти
[14:34.640 --> 14:57.860]  ребра прямые. Ну окей, тогда что можно сказать? Что, по сути дела, у меня путь от СДТ не может
[14:57.860 --> 15:05.940]  уменьшиться. Почему? Ну окей, давайте допустим, что у меня здесь был какой-то путь от СДТ,
[15:05.940 --> 15:16.660]  который я не насытил. Да, то есть если у меня существовал путь от СДТ, даже не так, вот так,
[15:16.660 --> 15:26.780]  вот так вот сделаем, что если я на пути из С в Т, здесь Т находится, пустил поток, но при этом найдется
[15:26.780 --> 15:32.900]  путь из СДТ, который не насыщен, то поток не блокирующий. Ну потому что есть просто путь от
[15:32.900 --> 15:38.900]  СДТ, вдоль которого можно пустить единичку потока. Значит, что я все пути от СДТ заблокировал,
[15:38.900 --> 15:46.500]  то есть у меня из СТ недостижимо, ну иначе просто поток не блокирующий был бы. А если из СТ теперь
[15:46.500 --> 15:54.500]  недостижимо, а в новой сети у меня появляются либо ребра вот такие вот, либо ребра внутри одного
[15:54.500 --> 16:00.860]  слоя и удаляются еще вот такие вот ребра, то могло и расстояние уменьшиться. Ну очевидно,
[16:00.860 --> 16:06.900]  нет. То есть у меня расстояние могут добавлять только вот эти вот ребра внутри слоя, но они
[16:06.900 --> 16:18.340]  увеличивают, они отдаляют от нас. Ну исходя из этого у вас расстояние только увеличивается. Ну и все.
[16:18.340 --> 16:39.380]  Окей? Что новых путей хотя бы той же длины?
[16:39.380 --> 17:00.020]  Нет. Так как они заблокированы. Ну все, тогда это мы доказали. А раз мы это доказали,
[17:00.020 --> 17:06.020]  то тогда очевидно сколько итераций максимум можно сделать. Вот В-1 это правильный ответ.
[17:06.020 --> 17:10.780]  Число ребра это много, потому что у вас путь не может быть длиннее, чем число вершин. У вас
[17:10.780 --> 17:21.140]  в каждом слое должна хотя бы одна вершинка находиться. А тогда число итераций не превосходит.
[17:21.140 --> 17:38.180]  В-1 мы будем говорить, что от В просто-напросто равно от В. Окей. Так, с этим разобрались. Теперь
[17:38.180 --> 17:45.140]  нужно разобраться с тем, как искать блокирующий поток. И тут есть куча вариантов. Мы рассмотрим самый
[17:45.140 --> 17:54.380]  простой. Да? Нет, мы рассмотрим самый наивный, а потом чуть менее наивный. Самый наивный он
[17:54.380 --> 18:03.540]  такой. Ну давайте запустим DFS. Если пути заспыта нашли, протухнем сквозь его поток. Запустим
[18:03.540 --> 18:14.780]  еще раз DFS. Все. Пока можем пропустить поток, запускаем DFS. Так как каждый такой DFS насыщает
[18:14.780 --> 18:23.100]  хотя бы одно ребро в сети, значит у вас максимум от запуска DFS будет. Если у вас от E запуска DFS,
[18:23.100 --> 18:29.980]  значит у вас от E квадрат время работы поиска блокирующего потока в таком случае. А если так,
[18:29.980 --> 18:35.300]  то асимпточка в E квадрат. И зачем мы это придумали, если Advanced Carb работает за такое время?
[18:35.300 --> 18:48.900]  Давайте чуть быстрее что-нибудь придумаем. А именно удаляющий обход. Мы будем искать сейчас
[18:48.900 --> 18:58.020]  блокирующий поток за VE, так сказать. А в чем глубинная суть этого метода? Она в том, что мы
[18:58.020 --> 19:02.900]  будем также запускать кучу раз DFS. Единственное, что мы будем для каждой вершины поддерживать
[19:02.900 --> 19:12.460]  индекс первого ребра, который мы еще не удалили из рассмотрения. Для каждой вершины
[19:12.460 --> 19:26.620]  поддерживаем индекс ребра,
[19:26.620 --> 19:42.100]  которая актуальна. Но ребро актуально, если оно еще не насыщено, и при этом из него можно дойти,
[19:42.100 --> 19:52.100]  из его конца можно дойти до ГРШДТ. Смотрите, у нас есть наша вершина какая-то, здесь множество ребер.
[19:52.100 --> 20:01.700]  Первое ребро, второе, третье, четвертое. Вот допустим из этого ребра нельзя дойти до Т.
[20:01.700 --> 20:14.860]  Ну тогда очевидно, что и в последующих запусках DFS нельзя будет пройти до Т из него,
[20:14.860 --> 20:25.020]  потому что мы там не умеем отменять потоки и вообще сеть не перестраиваем. А второй случай
[20:25.020 --> 20:31.540]  это, что мы можем дойти до Т, но ребро насыщено. Давайте это скажем, что ребро насыщено.
[20:31.540 --> 20:41.380]  Ну точнее не так, мы оставляем только ребра не насыщено, если ребро насыщено, мы его скипаем.
[20:41.380 --> 20:47.820]  А третий случай, может быть вообще, что ребро не из слоистой сети, мы же явно не будем все это
[20:47.820 --> 20:54.380]  перестраивать и строить новую сеть. Мы там будем помещать условно булями, и лежит ли ребро в
[20:54.380 --> 21:00.540]  слоистой сети или для каждой вершины хранить там дистанцию от S до нее. Поэтому может быть ребро
[21:00.540 --> 21:18.180]  не в слоистой сети, не в NFL. Вот это вот не актуальные ребра. И вот это ребро, из него мы можем
[21:18.180 --> 21:25.060]  дойти до Т, оно не насыщено, и оно в слоистой сети, и оно актуально тогда. Понятно, да, что мы
[21:25.060 --> 21:30.940]  хотим сделать. И сквозь него, и теперь мы будем пытаться понять. Вот допустим, нам пришел сюда
[21:30.940 --> 21:36.980]  какой-то поток F. Мы хотим понять, можно ли как-то его раскидать. Но очевидно, что сквозь это ребро
[21:36.980 --> 21:48.340]  сколько потока можно пропустить? Минимум из вот этого потока и остаточной вместимости. Больше
[21:48.340 --> 21:53.460]  пропустить нельзя. Ну минимум из потока берется, потому что больше чем этот поток пропустить не
[21:53.460 --> 21:58.420]  можете просто через это ребро. Мы считаем, что только вот это вот входит сюда. Ну или F-то суммарный
[21:58.420 --> 22:04.620]  поток со всех. Вот, ну так как нас-то будет DFS по сути, таким интеллектуальным, мы считаем,
[22:04.620 --> 22:10.500]  что вот весь поток через одно ребро идет. Пытаемся его пропустить сюда. Ну и аналогично,
[22:10.500 --> 22:16.060]  мы не можем больше чем CF пропустить сквозь это ребро, поэтому минимум из CF еще берется. Ну и все.
[22:16.060 --> 22:29.620]  Давайте подумаем с вами о том, за сколько работает это все дело, а именно поймем,
[22:29.620 --> 22:38.140]  за сколько у нас в частности работает одна итерация такого алгоритма. То есть смотрите,
[22:38.140 --> 22:44.780]  что мы делаем. Такая еще графическая интерпретацию можно предложить. Что вот если есть S, есть T,
[22:44.780 --> 22:52.260]  и вы нашли какой-то путь, то это значит, что все ребра выше вы уже просмотрели на текущий момент.
[22:52.260 --> 23:01.340]  Они либо из них нельзя дойти до T, либо они не в слоистой сети, либо оно насыщено. То есть вот
[23:01.340 --> 23:10.020]  есть какие-то ваши DFS пощадь какие-то ребра, ну и где-то они тут останавливаются. То есть не дойти
[23:10.020 --> 23:14.940]  до T там не могут или насыщенно. То есть ваш DFS где-то закончился. То есть все ребра выше этого
[23:14.940 --> 23:20.860]  пути вы уже рассмотрели. Но если выше, ввести в порядке того, что у вас сверху лежат номера с
[23:20.860 --> 23:26.500]  меньшим номером, а снизу с большим. Вот и поэтому дальше вы будете рассматривать только все,
[23:26.500 --> 23:34.220]  что ниже находится этого пути. Вот такая совсем неформальная интерпретация того,
[23:34.220 --> 23:50.940]  что происходит, вдруг вам так будет понятнее. Окей, так. Пусть K это количество сдвигов индексов.
[23:50.940 --> 23:59.500]  Что это значит? Вот мы же храним для каждой вершины индекс ребра, которая актуальна. Очевидно,
[23:59.500 --> 24:05.580]  что если ребро не актуально, мы делаем, мы просто прибавляем плюс один к индексу и делаем дальше.
[24:05.580 --> 24:12.620]  Вот. И вот краски вот этот вот сдвиг индексов имеется в виду, что вы делаете этот плюс-плюс индекс
[24:12.620 --> 24:22.420]  от вершинки. Вот. То есть это по сути, идейно, это количество ребер, которые вы рассмотрели сверху
[24:22.420 --> 24:28.740]  за одну интерацию. То есть те ребра, которые там у вас были, что нельзя дойти до T или там они
[24:28.740 --> 24:35.700]  неслывистой сетели, они уже насыщены. Вот. А как раз таки вот эта вот длина в пути от S до T,
[24:35.700 --> 24:48.580]  она не превосходит V. Поэтому время работы вот такого вот типа DFS, время работы одного запуска,
[24:48.580 --> 25:02.020]  от V плюс-K. А что дальше делают? Ну окей, мы нашли путь, но это же не блокирующий поток.
[25:02.020 --> 25:09.180]  Собственно, чтобы дойти до блокирующего потока, у вас вызывает вот эту вот процедуру, пока у вас
[25:09.180 --> 25:15.780]  поток вообще находится. Здесь пока у вас есть путь от S до T. Вот. Когда у вас нет пути из S
[25:15.780 --> 25:24.060]  до T, автоматически получается, что у вас поток уже блокирующий. Вот. Соответственно,
[25:24.060 --> 25:30.300]  по сути, будет код-код функции вот этой вот и будет внешний там while true, допустим,
[25:30.300 --> 25:37.780]  который в цикле пытается найти поток новый. Если у него получается, то он его находит. Вот. Ну,
[25:37.780 --> 25:42.540]  псевдокод еще напишем, не волнуйтесь, чтобы вам было проще жить. Ну попробуй написать,
[25:42.540 --> 25:51.180]  может не получится. Так. И теперь давайте оценим вообще количество запусков всех вот этих вот. То
[25:51.180 --> 25:58.180]  есть сколько раз мы можем найти вот такой вот путь из S в T? Ну, на самом деле, не очень много.
[25:58.180 --> 26:07.180]  Почему? Потому что каждый раз вы насыщаете хотя бы одно ребро. Если вы не насытили ни одного ребра
[26:07.180 --> 26:18.220]  на пути из S до T, значит, вы можете пропустить больший поток. А вы почему-то этого не сделаете.
[26:18.220 --> 26:24.340]  Вот все. Поэтому у вас каждый раз насыщает хотя бы одно ребро, всего ребра E, поэтому всего запусков
[26:24.340 --> 26:40.500]  всего запусков вот E. Так, ну что теперь нужно сделать? Давайте еще посчитаем,
[26:40.500 --> 26:53.260]  чему равна сумма по запускам каитов? По всем запускам. То есть сколько всего вообще можно
[26:53.260 --> 27:02.060]  сделать двигов за все запуски суммарно? Ну от E штука на самом деле. Потому что вы,
[27:02.060 --> 27:08.180]  если один раз уже забыли ребро, удалили, так сказать, но их явно не удаляете, вы вот
[27:08.180 --> 27:16.740]  этой вот штукой делаете. То есть двигаете индекс. Это значит, что если вы явно уже
[27:16.740 --> 27:23.340]  удалили ребро, то вы к нему больше никогда не вернетесь. Значит, всего сдвигов может быть не
[27:23.340 --> 27:39.620]  больше, чем E. Поэтому итоговое время работы. Ну, то есть если мы это суммируем и получаем от
[27:39.620 --> 27:49.780]  модуль V на модуль E, плюс модуль E, очевидно это вот VE. То есть смотрите, в чем отличие от наивного
[27:49.780 --> 27:57.300]  подхода, когда вы просто кучу раз запускали DFS? А тем, что вы каждый раз делали фор по всем соседям
[27:57.300 --> 28:05.140]  вершины, а здесь вы отсекаете вершины, с которых начинаете террироваться просто не надо. То есть
[28:05.140 --> 28:10.180]  у вас меньше соседей у каждой вершины получается каждую следующую итерацию. Поэтому и время
[28:10.180 --> 28:20.460]  улучшается с E2 до VE. Вот. Так, надо ли привести какой-то псевдокод? Попробовать. Или так понятно,
[28:20.460 --> 28:29.740]  плюс-минус, что происходит. Так, ну давайте быстренько время обоснуем, тогда работаем. Я напишу
[28:29.740 --> 28:39.980]  псевдокод. И что на самом получается? Мы с вами выяснили, что это от VE это удаляющий обход,
[28:39.980 --> 29:02.140]  а всего это от V. Откуда время работы? V2E. То есть мы квадрат с вами перекинули с E на V. Вот у нас
[29:02.740 --> 29:11.140]  был VE2, а здесь станет V2E. Грубо говоря, если оценивать осимпточку потоковых алгоритмов в степенях V,
[29:11.140 --> 29:21.460]  где E у вас порядка V2, в худшем случае, то у вас получается, что было V5, ну такое V5, а здесь V4.
[29:21.460 --> 29:29.380]  То есть вы на одну степень V понизили время алгоритма. Вот. Так, ну давайте псевдокод привести,
[29:29.380 --> 29:35.660]  наверное. У вас на семинарах уже должны были быть задачи, где там форт Фалкерсон работает очень
[29:35.660 --> 29:41.340]  быстро, потому что максимальный поток ограничен очень маленьким числом. В частности, у вас есть
[29:41.340 --> 29:47.980]  задача про минотавра в листочках. Про минотавра. Там минотавр из лабиринта пытается выбраться,
[29:47.980 --> 29:53.900]  а вы хотите его замуровать в нем. Вот. И выясняется, что там поток максимально не больше четырех,
[29:53.900 --> 30:01.060]  и вообще там за линейно от размеров графа время все работает. Вот. Здесь так не получится,
[30:01.060 --> 30:09.220]  потому что здесь не используется максимальный поток явного оценки. Но опять же, здесь нужно
[30:09.220 --> 30:17.140]  заметить, что эта оценка сугубо теоретическая, и во всяких других сетях специфичных она может
[30:17.140 --> 30:26.780]  быть улучшена. Вот. Ну пока что мы это оставим. Это будет чуть попозже. Так, ну давайте будет функция
[30:26.780 --> 30:38.180]  IntAugment. Augment, дополняющий по-английски. Которая будет, по сути, вот выполнять один
[30:38.180 --> 30:54.380]  запуск вот этого вот DFS удаляющего. F это поток, который приходит в вершину В текущей. Так,
[30:54.380 --> 31:06.180]  ну что можно здесь сказать? Что, ну очевидно, что если у вас вершина уже посещена, то там
[31:06.180 --> 31:13.780]  return ноль какой-нибудь. Да, возвращать мы будем количество потока, которое можно протолкнуть в
[31:13.780 --> 31:27.980]  итоге. Устат В равно true. Так, дальше что? Наверное, хочется рассмотреть случай, можно ли дойти до T.
[31:27.980 --> 31:39.100]  Что это значит? Давайте посмотрим, что происходит, что если V это T, то что тогда?
[31:39.100 --> 31:55.340]  Наверное, нужно просто сделать, верни поток, который пришел. Все. Окей. Так, теперь V неравно T.
[31:55.340 --> 32:08.500]  Значит, давайте, что сделаем с вами? Что если ребро не в слоистой сети, то мы тоже не идем.
[32:08.500 --> 32:16.900]  Я напишу это так, что if. А, ну все, теперь нужно, собственно говоря, пробегаться по
[32:16.900 --> 32:41.260]  соседней вершинке и разбирать случаи. Так, int to int i. Вот, idx это краски массив наших индексов будет.
[32:41.260 --> 33:00.540]  G от V это список соседей нашей вершины. Ну, я для краткости здесь пишу, понятно, что в общем случае
[33:00.540 --> 33:07.180]  вам придется код, он будет немножко более громоздкий, но не сильно. Вот так, окей, теперь мы перебегаем
[33:07.180 --> 33:12.660]  по соседней, и здесь важно, что idx от V. Так, смотрим. Первый случай, что ребро не в слоистой сети.
[33:12.660 --> 33:29.580]  Давайте сразу напишем, что to равно jet V it. То есть это то, куда у нас ведет ребро. То есть это у нас V, а это to.
[33:29.580 --> 33:52.380]  Так, if V to не лежит в NFL, то что тогда? Мы говорим plus plus idx от V, ну и заканчиваем эту
[33:52.380 --> 34:00.460]  итерацию для конкретно вот этой вот вершинки. Вот для idx, для вот этого to мы закончили все. И plus
[34:00.460 --> 34:07.860]  sum index, потому что мы ее игнорируем теперь. Окей, так мы разобрали, что ребро не в слоистой сети. Так,
[34:07.860 --> 34:31.700]  теперь давайте разберем, что ребро насыщено. Что если V to насыщено, абсолютно аналогично делаем.
[34:37.860 --> 34:48.460]  Так, ну и третий случай, это либо мы можем дойти до t, либо нельзя дойти до t. Чем он отличается
[34:48.460 --> 34:57.220]  тем, какой поток мы сможем пропустить? Логично? Вроде бы логично. Поэтому говорим, что int augment
[34:57.220 --> 35:14.980]  равен чему? Он нашей функции augment равен от вершинки to и, как я говорил, минимум из двух вещей.
[35:14.980 --> 35:30.340]  Первое это cf от V to, то есть с остаточной вместимости, и f. То есть это сколько я потока
[35:30.340 --> 35:36.420]  дополнительно могу пропустить. Ну и говорю return augment, то есть это вот сколько я смог вернуть из
[35:36.420 --> 35:50.820]  вершинки. То есть я смог найти первую вершину на своем пути, через которую я смог протолкнуть
[35:50.820 --> 35:57.620]  поток, то есть смог дойти до t. И значит, что это ребро мне интересует, потому что оно может быть
[35:57.620 --> 36:05.740]  ненасыщенным дальше. Если оно окажется насыщенным, ну как бы все, типа мы его тут вот скипнем.
[36:05.740 --> 36:18.220]  Допустим, что у нас нет больше ребер, которые нам актуальны. В смысле вы вернулись один раз,
[36:18.220 --> 36:27.940]  все. Ой, да, да, да, да, да, да, конечно, sorry, я не рассмотрел этот случай, что если augment равен нулю,
[36:27.940 --> 36:38.420]  то что это значит? Это значит, что вы не смогли достичь t. Если вы не смогли достичь t, то все,
[36:38.420 --> 36:54.020]  тогда происходит, что plus, plus и dx от v, continue. И если у вас augment не равен нулю,
[36:54.020 --> 37:06.180]  значит вы можете его вернуть. Здесь говорят, что неприятно писать return из цикла. Ну почему?
[37:06.180 --> 37:12.580]  Вы нашли в цикле подходящую вас штуку. Значит, просто сразу сделайте return, да и все. Чего мучиться?
[37:12.580 --> 37:22.060]  Ну и последний случай, это когда у вас здесь отработал целиком фору, у вас ничего не return.
[37:22.060 --> 37:30.140]  И здесь не return, и здесь не return. Какой тогда return? 0. Это значит, что вы не смогли дойти до t,
[37:30.140 --> 37:37.100]  грубо говоря. То есть вы не смогли дойти до t, это не интересный случай, можно даже use на самом деле
[37:37.100 --> 37:42.500]  не рассматривать, потому что у вас сеть слоистая. Поэтому даже можно use убрать по-хорошему. Давайте
[37:42.500 --> 37:53.660]  его уберем как бесполезный атовизм в ремеграфовых обходах. И для упрощенного анализа получается,
[37:53.660 --> 37:58.580]  что мы либо возвращаем поток, либо возвращаем augment, но поток мы возвращаем только в том случае,
[37:58.580 --> 38:05.860]  когда мы дошли до t. Если мы не вернулись отсюда, и augment равен нулю, то есть мы нигде не смогли
[38:05.860 --> 38:12.740]  вернуть нормальный augment, то тогда получается, что мы должны просто вернуть 0. Мы не смогли дойти до t.
[38:12.740 --> 38:27.860]  Так здесь return 0. Ну вот такая вот функция. Вот это функция поиска одной итерации. Соответственно,
[38:27.860 --> 38:33.780]  внутри мэйна у вас будет… Ой, давайте я немножко накринжу и напишу «дувайл».
[38:33.780 --> 38:54.980]  Давно не видели такого покемона, да? Так, dual f плюс равно dfs… Господи,
[38:54.980 --> 39:02.060]  это augment у нас функция. Augment от s до s бесконечности. То есть вы считаете,
[39:02.100 --> 39:06.780]  что вы можете пропустить бесконечное число потока, а потом вас обрадуют, что это неправда.
[39:06.780 --> 39:19.540]  Вот. Так. Ну и здесь будто бы надо написать, что вы должны перестроить сеть. Я это напишу,
[39:19.540 --> 39:42.980]  что вы должны, по сути, пропустить поток f. Пропустить поток f. В nfl, да. Наверное,
[39:42.980 --> 39:59.460]  все. Давайте не так скажем, что f' равно… Пропустить поток f' в nfl. Ну, плюс-минус сойдет,
[39:59.460 --> 40:15.100]  я думаю, понятно, что имеется в виду while, пока f' не ноль. Ну, примерно так. То есть пока вы
[40:15.100 --> 40:19.940]  можете найти дополнящий поток, вы его находите. Потом, когда вы не смогли,
[40:19.940 --> 40:26.660]  значит вы нашли блокирующий поток, и ваш while закончился. Один из немногих примеров,
[40:26.660 --> 40:34.500]  где нужен while. Потому что можно написать while true, если f' равен нулю, то break. Но это
[40:34.500 --> 40:41.900]  же неприятно. Так гораздо элегантнее. Ну да, в основном код ревью уроют, скорее всего,
[40:41.900 --> 40:46.780]  потому что эта конструкция какая-то очень странная. Это, знаете, как говорить с слишком
[40:46.780 --> 40:53.580]  высоким стилем на русском языке. Вот примерно такая же конструкция while. Давайте подпишем,
[40:53.580 --> 41:05.020]  что лучше в Augment. Лучше внутри Augment. Соответственно, вот это вот у вас будет функция поиска
[41:05.020 --> 41:12.860]  блокирующего потока. Да, то есть в итоге у вас алгоритм поиска максимального потока выглядит
[41:12.860 --> 41:20.620]  как. Он делает вот столько итераций, ну, точнее он вот делает эту схему, по сути, строит nf,
[41:20.620 --> 41:28.940]  строит nfl, потом вызывает блокирующий поток и делает это. Вот снова do while будет. Do while
[41:28.940 --> 41:34.540]  блокирующий поток не ноль. Внутри будет вызываться вот этот do while, который вызывает внутри
[41:34.540 --> 41:43.220]  себя вот этот Augment. Вот такая примерно схема кода будет. Так, ну, про потоки осталось немножко
[41:43.220 --> 41:54.140]  совсем. А это именно есть две классные теоремы. Товарища Корзанова, тоже советский ученый,
[41:54.140 --> 42:01.980]  к сожалению, не помню его имени и отчества. Вот у него есть две теоремы про схему Динеца,
[42:01.980 --> 42:08.140]  а я вам расскажу только одну. Ну, как расскажу? Я расскажу определение, которое нужно, чтобы
[42:08.220 --> 42:15.220]  сформулировать. Потом сформулирую и не докажу. Вот. А вторую теорему даже формулировать не буду.
[42:15.220 --> 42:22.380]  Ну, потому что там доказывать очень неприятно. Сразу скажу. Ну, когда я сформулировал Леню,
[42:22.380 --> 42:33.980]  вы поймете. Давайте так, то есть раздел теоремы Корзанова, определение, назовем c плюс от v
[42:33.980 --> 42:54.620]  c плюс это максимальная входящая Capacity, c минус от v, соответственно, максимальная исходящая Capacity.
[42:54.620 --> 43:22.380]  C, v, u. Максимальная входящая C, это максимальная исходящая C. Вот. Окей, тогда сейчас.
[43:24.620 --> 43:40.340]  И от v, насколько мне не изменяет память, это вот такая вот штука. То есть потенциал вершины в
[43:40.340 --> 44:00.100]  сети мы обзовем вот такую вот штуку. Потенциал вершины в сети. Дальше что? Ну, уже прикольно, да?
[44:00.100 --> 44:08.580]  Ну, это вроде еще плюс-минус что-то естественное. Это какой максимальный поток можно пропустить
[44:08.580 --> 44:20.900]  за одну икарацию, грубо говоря. А теперь вводят потенциал сети. Это вот такая вот странная штука.
[44:20.900 --> 44:33.020]  То есть по всем вершинам без стока и истока. И от v. То есть это суммарно потенциал сети,
[44:33.980 --> 44:46.900]  всех вершин, кроме истока истока. Жесть, да? Ну и первая теория Макарзанова состоит в том,
[44:46.900 --> 45:16.580]  что первая теория Макарзанова. Число итераций в схеме Динеца составляет, вы не поверите,
[45:16.580 --> 45:38.340]  сколько от Корнеес фиатен. Я думаю, вы не хотите слышать доказательства этого факта. Ладно,
[45:38.420 --> 45:51.940]  фиатен, но тут еще и корень совсем доставляет неудобств. Ну там, скорее всего, будет везде
[45:51.940 --> 45:58.940]  заходить, потому что у вас есть оценка v2e. То есть в общем случае у вас оценка будет v Корнеес
[45:58.940 --> 46:04.980]  фиатен, потому что у вас число итераций вот такое вот. Ну и в худшем случае получается,
[46:05.140 --> 46:12.060]  что это v. Вот так вот получается. Есть такая оценка, есть еще оценка другая,
[46:12.060 --> 46:18.500]  которая есть во второй теории Макарзанова. Она про то, что там есть связь неравенства на
[46:18.500 --> 46:27.960]  следующие величины. Длина максимального пути из СДТ в ребрах, максимальная capacity по всем
[46:27.960 --> 46:36.600]  ребрам и максимальный поток. Причем очень не очень очевидно, поэтому давайте мы оставим
[46:36.600 --> 46:42.660]  все это без доказательства и кому захочет, тот почитает подробнее про это все. Ну давайте
[46:42.660 --> 46:53.280]  рассмотрим, где вот эта оценочка наша применяется прекрасная. Давайте первый пункт единичные сети.
[46:53.280 --> 47:05.340]  Единичные сети. Это такие сети, в которых C тождественно равно единичке. То есть на всех
[47:05.340 --> 47:09.400]  ребрах, на которые есть сети, оно равно единице на тех ребрах, которые нет, понятное дело ноль.
[47:09.400 --> 47:22.400]  Я-то думаю, что не так. Мутные сомнения. Здесь не максимум, а сумма берется. А я думаю,
[47:22.400 --> 47:30.440]  где я вас обману. Тогда что можно сказать, что потенциал сети ограничен числом ребер.
[47:30.440 --> 47:37.120]  Можно прямо сходу заявить. Но это вроде тривиальная оценка, потому что у вас фи от в это минимум
[47:37.120 --> 47:45.480]  с ц плюс ц минус, а сумма по всем входящим и сумма по всем исходящим это краски от я. Фи от м
[47:45.480 --> 47:55.720]  равен вот е. Но откуда следует, что у вас корень из е итерации. Хорошо, это уже первая радость.
[47:55.720 --> 48:03.160]  То есть у вас если было от в это, то здесь лучше от корней из е итерации. А вторая радость,
[48:03.160 --> 48:21.040]  она такая, что давайте рассмотрим удаляющий обход в единичной сети. В чем была проблема
[48:21.040 --> 48:28.160]  удаляющего обхода, почему он работал за е в? Потому что у нас каждое ребро могло быть
[48:28.160 --> 48:34.600]  рассмотрено несколько раз. То есть у нас на этом пути далеко не все ребра насыщены,
[48:34.600 --> 48:41.240]  а только одно. Поэтому все остальные могут быть рассмотрены еще много-много раз. Но что происходит
[48:41.240 --> 48:48.040]  в единичных сетях? Вы насыщаете сразу весь путь. Поэтому у вас каждое ребро просматривается
[48:48.040 --> 48:54.520]  суммарно не более одного раза. Ну насыщается, точнее через него протихает поток ровно один раз.
[48:54.520 --> 49:00.240]  То есть оно либо удаляется, либо через него прозвукнули поток на текущей итерации. А если это так,
[49:00.240 --> 49:06.120]  то значит мы все ребра посмотрим ровно по одному разу, а значит время работы удаляющего обхода от е.
[49:06.120 --> 49:25.280]  Каждое ребро насыщается сразу же при пропускании потока.
[49:25.280 --> 49:49.880]  Из этого следует, что если ребро насыщается, то просматривается ребро один раз. А раз оно
[49:49.880 --> 50:04.120]  просматривается один раз. Из этого следует, что время работы от е. Складываем 1 и 2,
[50:04.120 --> 50:13.120]  получаем 3, а еще что время работы единица на единичных сетях от е корней из е. Ну то есть
[50:13.120 --> 50:18.720]  если у нас е порядка в квадрат, мы получаем уже в f3. Там было в f4. То есть уже мы еще на одну
[50:18.720 --> 50:25.480]  степень вы понизили оценку. Ну теперь самая мякотка. Это третья часть, которую мы хотим.
[50:25.480 --> 50:38.120]  Так называемый алгоритм Хобкрофта-Карпа. Ге корней из е. Потому что у вас потенциал е,
[50:38.120 --> 50:51.480]  она интерация е. Извините, корни из е. Алгоритм Хобкрофта-Карпа. В чем заключается алгоритм
[50:51.480 --> 50:57.800]  Хобкрофта-Карпа? У вас уже у всех был семинар по потокам и у всех был семинар про просочетание.
[50:57.800 --> 51:02.680]  Соответственно там вы уже строили сеть про то, как искать максимальное просочетание методом
[51:02.680 --> 51:10.040]  потоков. Если этого не было, то вы не были на семинаре. Вот где такая. Кратко напомню,
[51:10.040 --> 51:20.880]  что у нас есть двудольный граф. Просочетание это какое-то множество ребер, у которых нет
[51:20.880 --> 51:28.280]  концов общих. То есть, например, раз-два. Это не просочетание, потому что у них есть общий конец вот
[51:28.640 --> 51:36.040]  это вот. И мы хотим в таком графе найти максимальный просочетание. Что мы с вами делали? Кто знает
[51:36.040 --> 51:42.160]  алгоритм Куна, тот молодец. Кто не знает, тот строил потоки. Эйм настроил сеть, брал исток,
[51:42.160 --> 51:48.520]  проводил ребра. Сеть ребра ориентировал слева направо. Я не буду, потому что мне лень.
[51:48.520 --> 52:01.320]  Проводил сюда и везде писал единичные емкости. Ну и дальше максимальный поток в такой сети вам
[52:01.320 --> 52:07.000]  давал максимальное просочетание. Почему? Потому что утверждается, что в единичной сети у вас
[52:07.000 --> 52:13.320]  поток разбивается на реберно-непересекающиеся пути. Вот реберно-непересекающиеся пути краски
[52:13.320 --> 52:20.240]  вам дадут число звеньев в просочетании и все эти пути вам дадут сами ребра. Окей. Так,
[52:20.240 --> 52:26.120]  давайте оценивать потенциал этой сети. Давайте сразу лучше феатвы оценивать. Так будет проще жить.
[52:26.120 --> 52:35.120]  По сути у нас капасти равни единицы везде. По сути, мы можем отождествить вот это вот. Все с
[52:35.120 --> 52:41.880]  числом входящих ребер, число исходящих ребер. Мы всегда берем минимум из числа входящих и
[52:41.880 --> 52:46.800]  исходящих ребер. Если темы не учитываем в рассмотрение, рассматриваем только основные вершинки.
[52:46.800 --> 52:53.640]  Так, у этой всегда есть минимум, что одно входящее. У всех вершин левой доли одно входящее, у всех
[52:53.640 --> 52:59.960]  вершин правой доли одно исходящее. Поэтому потенциал вершины он меньше либо равни единички.
[52:59.960 --> 53:11.400]  Откуда следует, что потенциал сети непревосходит В? Откуда следует, что время работы?
[53:11.400 --> 53:31.800]  От Е, корни из В, конец. Ну это все на потоке, что хотелось бы сказать. Там еще очень много
[53:31.800 --> 53:39.040]  чего есть. Сразу скажу, что для особо интересующихся, как искать поток не за В квадрат Е, а за В куб,
[53:39.040 --> 53:45.720]  есть метод, как за В куб искать. Есть два варианта. Первый вариант — это там поиск блокирующего
[53:45.720 --> 53:53.200]  потока методом Малхотра, Кумара, Макешвари. Это три индуса таких есть. Это первый вариант.
[53:53.200 --> 54:01.040]  Второй вариант — вам придется ознакомиться с техникой проталкивания предпотока. То есть,
[54:01.040 --> 54:05.920]  вот смотрите, здесь мы что сами делали. Здесь вы сами везде строили остаточные сети и что-то
[54:05.920 --> 54:10.960]  с ними делали. Это первый подход. Есть второй подход, кардинально и деянно отличающийся — это
[54:10.960 --> 54:17.360]  проталкивание предпотока. Там будет функция предпотока, у которой там почти поток,
[54:17.360 --> 54:21.840]  только одно свойство отменяется, ослабляется, точнее, что входит больше либо равно, чем выходит.
[54:21.840 --> 54:29.440]  Вот вы проталкиваете предпоток, ну и потом вы балансируете, получается поток. Очень краткое
[54:29.440 --> 54:36.360]  описание того, что там происходит. Пуш префлоу по-английски. И есть еще дополнительно к нему
[54:36.360 --> 54:43.480]  ивристика, так называемая relabel to front. Она позволяет искать чисто за вакуум максимальный поток.
[54:43.480 --> 54:50.320]  То есть, еще одну степень вы скинули. Быстрее вакуума, я не помню алгоритмов, возможно, они есть.
[54:50.320 --> 54:57.320]  Они какие-то, скорее всего, крайне экзотические. На семинаре у вас будет классная штука под
[54:57.320 --> 55:05.280]  названием масштабирование потока. Как сказать, анонс семинара. Там вы будете применять техника
[55:05.280 --> 55:09.680]  масштабирования в том, что вы сначала рассматриваете ребра, в которых очень огромный capacity,
[55:09.680 --> 55:14.920]  потом capacity поменьше, потом совсем маленький capacity, потом жесть, какой маленький capacity.
[55:14.920 --> 55:21.680]  Вот. И получается, что у вас, если c — это максимальный capacity по всем ребрам, то у вас всего
[55:21.680 --> 55:27.120]  логарифм c будет итерацией в этом алгоритме масштабирования. И выяснится, что у вас время
[55:27.120 --> 55:33.520]  ve log c вообще. То есть, если у вас capacity максимальная маленькая, то это еще быстрее вообще будет работать.
[55:33.520 --> 55:39.080]  Но это будет на семинаре, я это вот краски оставлю, потому что мне лень-то на лекции рассказывать,
[55:39.080 --> 55:44.920]  уж тем более доказывать. Давайте строки. Тогда все, про потоки закончили. Теперь мы переходим
[55:44.920 --> 55:54.720]  к последней части лекции, самой большой. Это будут строки. Это будет пятый контест. Это будет
[55:54.720 --> 56:00.600]  жуть-жуткая. Собственно, на строке, да, у нас будет посвящено много лекций. Почему? Потому что там
[56:00.600 --> 56:10.040]  будет очень много разных подходов, включая то, что мы изучим немножко математики для строк. Ну,
[56:10.040 --> 56:15.560]  первый курс может радоваться то, что он таких слов не знает. Второй курс может грустить, что у них
[56:15.560 --> 56:21.400]  это на сессии еще сдавать. Именно преобразование, фурье и всякое такое дело. Третий курс может
[56:21.400 --> 56:28.400]  радоваться, что они уже это сдали. Вот, ну их еще ждет гос, поэтому они еще не до конца сдали.
[56:28.400 --> 56:38.360]  У нас будет с вами конкретная задача, одна по сути. Поиск паттерна в тексте. То есть,
[56:38.360 --> 56:43.800]  мы хотим с вами искать в тексте какое-то слово. Ну, ctrl-f ваш любимый по презентажкам,
[56:43.800 --> 56:49.960]  когда вы пишете контрольные. Вот. Как раз-таки он там устроен, вот мы сейчас будем писать ctrl-f с
[56:49.960 --> 56:56.480]  вами. Ну как, мы писать его не будем, мы напишем алгоритмическую часть. То есть первая задача,
[56:56.480 --> 57:07.920]  первое лекция у нас будет посвящена задача, это поиск точного вхождения одного паттерна в текст.
[57:08.320 --> 57:15.160]  Так, окей, это будет первая лекция, у нас будет с вами на лекции скорее всего два метода разобрана,
[57:15.160 --> 57:22.080]  а третья я оставлю на семинары, потому что мне он не нравится. Вот. Вторая задача у нас будет
[57:22.080 --> 57:27.040]  уже более интеллектуальная, а именно мы будем искать много паттернов в тексте.
[57:27.040 --> 57:39.400]  Поиск точного вхождения множество паттернов в текст.
[57:39.400 --> 57:49.360]  Собственно, под это определение, кстати, прекрасно подходит то, что вы пытаетесь
[57:49.360 --> 57:53.800]  найти текст по регулярке. Потому что в суть регулярка это множество паттернов,
[57:53.800 --> 57:59.760]  поэтому когда вы пишете в консоли греб что-то там, вот это вы решаете эту задачу по сути.
[57:59.760 --> 58:08.040]  Ну и мы рассмотрим алгоритм, который реализован внутри греба. Они решают абсолютно разные
[58:08.040 --> 58:16.600]  задачи. Лер Парсер разбирает слово бобдивое в грамматике, тогда как у вас здесь будет максимум
[58:16.600 --> 58:21.840]  что-то регулярное, причем простенькое. То есть у вас мало того, что регулярные языки они как бы
[58:21.840 --> 58:27.280]  заведомо уже чем контекстно свободные языки. Так еще у вас будет под множество регулярных языков
[58:27.280 --> 58:36.000]  здесь. То есть совсем все грустно. Лер Парсер пройдет, но по времени он вряд ли зайдет туда.
[58:36.000 --> 58:45.640]  Окей, так третья. Вот наша такая линейка. Потом третье у нас будет сразу две лекции. Они вот
[58:45.640 --> 59:00.960]  освещены всяким штукам типа операции с подстроками, назовем это так. Ну из таких примеров найти строку,
[59:00.960 --> 59:08.480]  которая входит к раз не пересекаясь. То есть найти подстроку, которая входит к раз без сам пересечений.
[59:08.480 --> 59:20.240]  За линию длинной строки, конечно же. Вот. Собственно, вот эти все штуки нужны в биоинформатике,
[59:20.240 --> 59:25.160]  когда у вас там геномы всякие разбираются. Потому что у вас там поиск всяких подпоследовательностей,
[59:25.160 --> 59:29.480]  подозрительных паттернов и так далее и так далее. Вот собственно это вот сюда.
[59:29.480 --> 59:36.640]  В этом посвящено две лекции, ну полторы. Мы там будем суффиксно автомат устроить. Будем,
[59:36.640 --> 59:42.160]  точнее, лекцию вводить в теорию и пол лекции строить. Примерно так. И четвертая часть,
[59:42.160 --> 59:51.040]  она будет посвящена задаче. Вообще у нас будет там две задачи. Это поиск с опечатками. У нас
[59:51.040 --> 59:55.360]  с опечатками бывают двух типов. Первый тип, это когда мы вместо одной буквы написали другую,
[59:55.360 --> 01:00:02.800]  явно, да. Например, не знаю там, без слова текст написали слова. Ну нет, здесь как-то сложно
[01:00:02.800 --> 01:00:11.680]  опечататься в одной букве, потому что все тут явно. Ну не знаю. Ну это сложно. Блин,
[01:00:11.680 --> 01:00:18.440]  здесь все слова, которые очень легко пишутся. Ну не знаю, вместо под строка написать под строка,
[01:00:18.440 --> 01:00:24.160]  например. Вот, ну не знаю, случайно опечатались. Вот, вы будете хотите искать в строке,
[01:00:24.160 --> 01:00:31.400]  есть ли у вас вхождение с опечатками. Вот. То есть, так сказать, вхождение с опечатками,
[01:00:31.400 --> 01:00:41.560]  это первая метрика. Она называется расстояние хемминга. Ей будет посвящено, чтобы ее решать,
[01:00:41.560 --> 01:00:47.800]  мы будем пройдем преобразование фурье как раз таки. То есть, здесь будут два, две метрики. Первая
[01:00:47.800 --> 01:00:58.280]  это будет хемминг. Это преобразование фурье. Фаст фурье трансформ по-русски. Вот. Соответственно,
[01:00:58.280 --> 01:01:07.400]  и вторая метрика, это ревенштейн. Это когда мы разрешаем себе не только опечатки, но еще разрешаем
[01:01:07.400 --> 01:01:13.480]  себе писать меньше символов или больше символов. То есть, например, мы случайно написали слово и
[01:01:13.480 --> 01:01:19.520]  пропустили букву. Мы хотим понять, есть ли слово с пропущенной буквой или с добавленной буквой,
[01:01:19.520 --> 01:01:25.000]  ведь может с к добавленными или пропущенными буквами. Вот. И здесь у нас будет решение это
[01:01:25.000 --> 01:01:41.200]  так называемый алгоритм Ландау Вишкина. Это не тот Ландау, я вам скажу. И давайте я это поставлю
[01:01:41.200 --> 01:01:48.920]  под звездочкой, потому что я еще не уверен, хочу ли это рассказывать. Можно-то не рассказывать,
[01:01:48.920 --> 01:01:53.840]  я согласен. Потому что один алгоритм легкий, там нужно искать кратчайшие пути в графе динамики,
[01:01:53.840 --> 01:02:00.360]  а другой алгоритм нужно строить суффиксные деревья и на них искать кратчайшие пути всякие. Вот.
[01:02:00.360 --> 01:02:10.240]  Соответственно, что еще? Ну и пятое. Это тоже со звездочкой, что хочется. Оно как-то как-то
[01:02:10.560 --> 01:02:23.320]  относится. Но все-таки это всякие свертки, многомерные фурьи. В частности, сюда
[01:02:23.320 --> 01:02:38.880]  рассмотрим, как устроены сверточные нейросети, как эффективно считаются свертки в них. Ну да,
[01:02:38.880 --> 01:02:46.800]  учитывая то, что сначала введет куча математики туда. Ну я уверен, что все умеют брать вот такой
[01:02:46.800 --> 01:03:02.240]  вот интеграл. Ну да, это преобразование в фурьи от функции. Ну вот, и мы будем выводить,
[01:03:02.240 --> 01:03:08.320]  что можно многомерные фурьи расписать как кратный интеграл, что фурье свертки это
[01:03:08.320 --> 01:03:15.880]  произведение фурье. Из этого будем выводить всякие приколы. Ладно, доказывать мы это не будем,
[01:03:15.880 --> 01:03:20.400]  потому что у вас для этого есть мата. Вот. Но я это, так сказать, поясню, когда придется.
[01:03:20.400 --> 01:03:25.320]  То есть вот такой вот план у нас на оставшийся семестр. Соответственно, в контесте будет
[01:03:25.320 --> 01:03:34.960]  это-это-это, вот это FFT будет. Ну в принципе все, в контесте больше ничего не будет,
[01:03:34.960 --> 01:03:38.560]  поэтому контест будет, скажем так, он будет до конца семестры идти,
[01:03:38.560 --> 01:03:45.520]  однако последние лекции будут не в контесте, а так чисто научпоповский материал. Конечно.
[01:03:45.520 --> 01:03:50.080]  Так, ну все, тогда я вас, пожалуй, отпущу, потому что за пять минут мне Лень что-то рассказывает.
