[00:00.000 --> 00:11.600]  Так, всем доброго дня. Мы с вами продолжаем наш курс. И нынче это такая последняя обязательная
[00:11.600 --> 00:17.400]  лекция в нашем курсе. Скорее всего, будет еще две дополнительных, потому что, сами понимаете,
[00:17.400 --> 00:22.840]  сейчас будет переход на 1 мая. То есть следующая среда это 1 мая. Наверное, никто из вас на пару
[00:22.840 --> 00:29.640]  не придет. Хотя я могу прийти на 1 мая на пару. Вот. Дальше у нас 8 мая будет контрольная,
[00:29.640 --> 00:34.880]  вторая. Вот. И 15 мая понятно, что после проведения всех контрольных будет только
[00:34.880 --> 00:41.560]  доп-лекция, в которой мы скорее всего поговорим про антипаторное программирование. То есть про то,
[00:41.560 --> 00:46.800]  как делать не надо. На самом деле, так или иначе большое количество антипаторных мы выявляем в
[00:46.800 --> 00:53.080]  то время, когда мы проверяем, когда мы делаем какие-то задания. Вы пишите проект. Собственно,
[00:53.080 --> 00:57.760]  у вас так или иначе подсвечивают эти антипаторные. Вот. Но сегодня мы с вами поговорим немножко о
[00:57.760 --> 01:03.920]  другом. Возможно, сразу скажу, что эту лекцию нужно было поместить немного раньше. Где-то сразу
[01:03.920 --> 01:11.200]  в середине курса, может быть, даже в самом начале курса с него начать наш блок лекций. Но так сложилось,
[01:11.200 --> 01:17.200]  что, в принципе, сейчас мы можем как раз поговорить про базовые понятия о языках
[01:17.200 --> 01:22.920]  программирования. Потому что, так или иначе, к концу семестра, возможно, кто-то из вас уже
[01:22.920 --> 01:27.360]  освоил два языка программирования в каком-то базовом варианте, а, возможно, кто-то и более,
[01:27.360 --> 01:32.000]  чем два языка программирования, потому что решили написать проект на своем собственном языке. Ну,
[01:32.000 --> 01:37.280]  не на своем собственном языке, имеется ввиду на языке, который выбрали. Да, собственно, язык там
[01:37.280 --> 01:46.200]  мы не заставили. А? Ну, на любом языке. Вот. И нам нужно понять вообще, в чем особенность
[01:46.200 --> 01:52.400]  каждых из этих языков и понять некоторые основные фишки, которые мы с вами наблюдали в разных
[01:52.400 --> 01:59.840]  языках программирования. Вот. Значит, и первое, с чего мы сегодня начнем. Давайте расскажу план.
[01:59.840 --> 02:04.120]  Мы начнем с вами с рассмотра разных парадигм-программирования, а потом приведем
[02:04.120 --> 02:09.200]  классификацию языков программирования. Какие они бывают, в чем у них есть особенности. Поехали.
[02:09.200 --> 02:14.600]  Давайте начнем с такого понятия, как парадигма программирования. Что такое парадигма
[02:14.600 --> 02:22.080]  программирования? Это, так сказать, область, в которой мы с вами рассматриваем вообще наш
[02:22.080 --> 02:28.560]  процесс написания кода. То есть, вообще, как мы именно мыслим в точке зрения написания кода. И
[02:28.560 --> 02:37.560]  здесь есть несколько различений того, где мы с вами пишем код. То есть, есть основная категоризация,
[02:37.560 --> 02:42.840]  да, и есть, так сказать, перпендикулярная ей категоризация. Вот это нужно понимать. То есть,
[02:42.880 --> 02:50.280]  сейчас мы поговорим про основные вещи, после этого мы с вами поговорим про дополнительные аспекты.
[02:50.280 --> 02:59.040]  Итак, давайте начнем со следующего вопроса. Когда мы пишем инструкции в коде, пишем какой-то код,
[02:59.040 --> 03:06.520]  давайте поймем, на какой мы с вами отвечаем вопрос. Тут именно нужно понять, какой вопрос мы
[03:06.520 --> 03:15.640]  задаем, когда мы говорим, что мы пишем код. Вот, давайте представим, мы пишем с вами код на C++,
[03:15.640 --> 03:30.360]  да, что мы говорим программе нашей? Исполни какие-то команды. То есть, мы даем именно
[03:30.360 --> 03:36.280]  императивный стиль написания кода. То есть, мы говорим, каким образом ты должен выполнить эти
[03:36.280 --> 03:42.400]  функции. И вот первое порадигма, первое разделение на парадигмы как раз состоит в том, на какой вопрос
[03:42.400 --> 03:50.560]  мы с вами отвечаем. То есть, первый вопрос это, как мы все делаем, второй это мы отвечаем немножко
[03:50.560 --> 03:56.920]  на другой вопрос. То есть, первое основное деление в парадигмах программирования это то, какое оно
[03:56.920 --> 04:02.160]  у нас. Оно у нас инперативное и мы работаем с вами в императивной парадигме или декларативной
[04:02.160 --> 04:07.480]  парадигме. И вот здесь явно нужно будет различить, на какие вопросы каждый из них
[04:07.480 --> 04:14.160]  отвечает. Итак, давайте начнем с первого. Императивная отвечает на вопрос как. То есть
[04:14.160 --> 04:22.480]  мы говорим то, именно как мы пишем наш код. Хорошо. Значит, давайте посмотрим, что это означает.
[04:22.480 --> 04:31.720]  Значит, с чем у нас заключается императивное программирование? Значит, смотрите, у нас в коде
[04:31.720 --> 04:35.740]  есть набор инструкций команд. То есть мы говорим выполни функцию foo, выполни функцию
[04:35.740 --> 04:40.980]  var, выполни функцию fi. Значит, дальше что мы говорим с вами? У нас инструкции выполняются
[04:40.980 --> 04:45.560]  последовательно. Ну преимущественно выполняются последовательно. Понятно, что мы не говорим про
[04:45.560 --> 04:49.720]  параллельное программирование, хотя это тоже одна из парадигм, в которой мы с вами должны
[04:49.720 --> 04:55.200]  уметь работать. Но они на самом деле, если мы говорим про разделение, то параллельное
[04:55.200 --> 04:57.200]  funçãoом 열�ная программирования
[04:57.260 --> 04:59.900]  параллельнаяâlシня
[05:01.800 --> 05:02.340]  парадигма
[05:02.420 --> 05:03.000]  которая
[05:03.040 --> 05:03.960]  перпендикулярна
[05:04.240 --> 05:06.160]  направление императивное и декларативное
[05:06.580 --> 05:08.240]  да? есть именно декларативные
[05:08.260 --> 05:09.000]  ой
[05:09.220 --> 05:10.140]  есть именно
[05:10.480 --> 05:11.960]  декларативные параллельные языки
[05:11.980 --> 05:13.560]  и императивные параллельные языки
[05:14.100 --> 05:15.000]  то есть этим нужно
[05:15.600 --> 05:17.500]  это нужно учитывать
[05:17.740 --> 05:18.280]  далее
[05:18.320 --> 05:19.280]  значит
[05:19.320 --> 05:20.080]  говорится следующее
[05:20.120 --> 05:20.980]  что данные
[05:20.980 --> 05:21.860]  которые у нас есть
[05:21.920 --> 05:23.180]  после выполнения в drin
[05:23.360 --> 05:24.800]  могут читаться
[05:24.800 --> 05:30.560]  инструкциями. То есть мы с вами говорим, что вот та инструкция, то есть мы записали
[05:30.560 --> 05:35.960]  результат в какое-то значение и дальше мы можем использовать этот результат для
[05:35.960 --> 05:41.240]  выполнения следующих операций. То есть одна из самых важных, смотрите, важных
[05:41.240 --> 05:47.120]  особенностей императивного программирования заключается в том, что мы можем записать
[05:47.120 --> 05:53.360]  в переменную какое-то значение. Вот это я подчеркну. То есть мы именно можем
[05:53.360 --> 05:56.920]  записать то, что у нас находится в переменной. То есть у нас есть такое
[05:56.920 --> 06:02.920]  понятие, как регистр, и с ним мы работаем. И вот оказывается, как ни странно, такой
[06:02.920 --> 06:07.680]  интересный аспект заключается в том, что на самом деле и на уровне железа у
[06:07.680 --> 06:14.120]  нас все по факту устроено в императивной парадигме. То есть мы именно с
[06:14.120 --> 06:17.680]  тачкой по императивной парадигме. То есть сейчас как раз идет параллельно курс по
[06:17.720 --> 06:23.600]  компиляторам. И у меня коллега, который пишет компилятор, решил написать компилятор
[06:23.600 --> 06:27.440]  для функционального языка программирования. И вот у него возникли огромные проблемы с
[06:27.440 --> 06:32.360]  тем, как вот, собственно, функциональный язык внедрить в императивную парадигму.
[06:32.360 --> 06:37.600]  Потому что на последних стадиях компиляции там именно преобладает императивная
[06:37.600 --> 06:42.440]  парадигма. То есть не состыковка парадигм, и это все ломает. В итоге мы договорились,
[06:42.440 --> 06:47.920]  что мы пишем компилятор, который, собственно, обходит все эти стадии. Ну, то есть обходят
[06:47.920 --> 06:53.360]  императивные стадии. Вот, значит, и при этом данные, которые у нас получены при
[06:53.360 --> 06:57.640]  выполнении некоторой инструкции, могут записываться в память. То есть мы записываем
[06:57.640 --> 07:02.720]  их в память, либо мы записываем на стэк, либо мы их записываем на память. Давайте
[07:02.720 --> 07:16.720]  тут нужно сразу сказать, как у нас выглядят разные аспекты. Значит, хорошо. У меня вопрос.
[07:16.720 --> 07:30.920]  Все знают, что такое куча или нет? Не структура данных. ХИП. Да-да.
[07:30.920 --> 07:46.400]  То есть, в принципе, давайте еще раз тогда напомню на всякий случай, что у нас, когда
[07:46.400 --> 07:55.800]  вызывается любая функция, у нас с вами возникает стэк. Значит, у нас есть у нашего стэка указатель
[07:55.800 --> 08:01.880]  на фреймпоинтер. То есть это то, в каком месте у нас начинается функция. Дальше мы в эту функцию
[08:01.880 --> 08:14.760]  кладем аргументы. Вот. До четырех аргументов обычно передается при помощи регистров. Дальше
[08:14.760 --> 08:20.960]  переменные передаются при помощи уже элементов на стэке. Ну и дальше мы с вами лоцируем элементы
[08:20.960 --> 08:27.440]  на стэке. Причем, что у нас может быть? Дальше мы говорим следующее, что если нам нужно выделить
[08:27.440 --> 08:33.680]  какой-то участок памяти, то мы делаем следующее. Мы выделяем некоторый участок памяти, а после этого
[08:33.680 --> 08:41.400]  он у нас отправляется в отдельное хранилище. То есть, ищется место, где мы можем выделить ХИП.
[08:41.400 --> 08:51.720]  Вот. При этом сразу хочу сказать, что на самом деле объем памяти, которая мы с вами явно требуем
[08:51.720 --> 08:57.520]  для процесса, он может быть больше. То есть мы можем затребовать данных больше, чем на самом деле
[08:57.520 --> 09:03.600]  этой памяти нам нужно. То есть у нас есть такое понятие, как виртуальная память, которая мы явно
[09:03.600 --> 09:11.240]  лоцируем. Она может полезна быть. И есть как раз выделенная память у всех процессов. Давайте я как
[09:11.240 --> 09:31.840]  раз покажу, что они сильно различаются. Так, я не знаю, тут видно? Нет, посмотрите, пожалуйста,
[09:31.840 --> 09:43.040]  на четвертый столбец. Какие числа там выглядят? То есть с правой стороны это процент памяти,
[09:43.040 --> 09:48.400]  который в MEM у нас процент памяти, который действительно у нас используется. Так, давайте
[09:48.400 --> 09:55.480]  sort by %mem. Вот. То есть у меня сейчас процесс Google Chrome занимает три с половиной процента
[09:55.480 --> 10:05.880]  реальной памяти. Но при этом выделяем мы именно виртуальной памяти 422 гигабайта. То есть в принципе
[10:05.880 --> 10:12.040]  вот процесс, для того чтобы он жил в отдельном адресном пространстве и у него хорошо работало,
[10:12.040 --> 10:16.440]  ему нужно как раз вот такое количество виртуальной памяти. При этом из этой виртуальной памяти мы
[10:16.440 --> 10:21.280]  резервируем некоторую часть. То есть мы по запросу можем выделить какое-то количество оперативной
[10:21.280 --> 10:29.360]  памяти. Вот. И как раз malloc, как раз функция ala malloc, они как раз позволяют выделить участок этой
[10:29.360 --> 10:38.880]  памяти. Функция aloc, malloc, new и так далее. Вот. То есть это что касается у нас операции. То есть
[10:38.880 --> 10:43.520]  в принципе данные мы можем записать вот в один из участков памяти. То есть либо мы записываем
[10:43.520 --> 10:55.320]  нас так, либо мы записываем на кучу. Хорошо. Так. Это понятно? Давайте подумаем, попробуем привести
[10:55.320 --> 11:09.840]  примеры языков с императивной парадигмой. Ну да, на самом деле большая часть языков,
[11:09.840 --> 11:15.480]  которые вы знаете, обладает императивной парадигмой. Это значит, что поскольку у нас большое
[11:15.480 --> 11:22.880]  количество языков работают в императивной парадигме, то нам нужно каким-то образом их
[11:22.880 --> 11:30.040]  отклассифицировать. Вот пример императивных языков. То есть это c++, это java, python, javascript,
[11:30.040 --> 11:34.800]  rast и так далее. Понятно, что они могут работать и в других парадигмах. То есть сейчас как раз
[11:34.800 --> 11:40.760]  возникают мульти парадигмальные языки программирования. Вот. Ну и давайте приведем
[11:40.760 --> 11:47.520]  некоторую категоризацию императивных языков, потому что они на самом деле есть разные и как
[11:47.520 --> 11:54.360]  минимум их можно выделить пять подкатегорий. Значит первые языки это языки с процедурным
[11:54.360 --> 12:00.320]  программированием. То есть мы с вами пишем функции, а после этого мы их выполняем. Давайте подумаем,
[12:00.320 --> 12:12.040]  какой язык является каноническим представителем процедурного программирования. Assembler. Ну c точно,
[12:12.040 --> 12:21.040]  да, потому что у нас там нет никаких классов. Assembler ну в целом тоже может сойти. То есть у нас
[12:21.040 --> 12:26.840]  по факту там называется это не процедура, это называются фреймы. Да, и мы в принципе выполняем
[12:26.840 --> 12:34.800]  команды по фреймам. Так, значит дальше у нас идет структурное программирование, то есть в котором
[12:34.800 --> 12:41.760]  мы сами собираем объекты, которые являются структурами и которые по факту не могут
[12:41.760 --> 12:48.440]  обладать своими методами и функциями и так далее. Вот. Это тоже на самом деле си, потому что мы
[12:48.440 --> 12:53.080]  можем как раз объекты собирать в определенную структуру. Да, но при этом мы не можем создать
[12:53.080 --> 12:58.800]  именно, то есть мы их не можем лоцировать на куче, мы их лоцируем преимущественно на стэке. Значит,
[12:58.800 --> 13:05.120]  третья вещь это аспекты ориентированное программирование. Значит, смотрите в чем интересная
[13:05.120 --> 13:11.000]  особенность. Особенность в том, что мы акцентируемся не на выполнении функции, а на выполнении
[13:11.000 --> 13:18.080]  некоторых аспектов, то есть выполнение некоторых точек триггеров для выполнения нашего кода. Вот.
[13:18.080 --> 13:24.800]  Какой здесь есть канонический пример для аспектов? Они обычно встроены в языке программирования,
[13:24.800 --> 13:33.040]  но в целом давайте вспоминать тему, связанную с тестированием. Какой у нас есть аспект, связанный
[13:33.040 --> 13:44.000]  с тестированием? Когда мы пишем с вами тестовый класс, что у нас помимо тестов может быть в
[13:44.000 --> 14:00.800]  этом тестовом классе? Это да. Да, смотрите, у нас есть некоторый набор функций, к которым мы
[14:00.800 --> 14:06.840]  задаем жизненный цикл нашего теста. Напоминаю, какие это функции. Первое это setup test class,
[14:06.840 --> 14:14.400]  которая вызывает, создаёт тесты перед, вызывается один раз перед созданием всех тестов. Дальше у нас
[14:14.400 --> 14:19.200]  есть функция setup, которая вызывается перед каждым тестом. То есть видите аспект как раз. То есть
[14:19.200 --> 14:24.840]  перед всеми тестами, перед каждым тестом. Потом после каждого теста у нас выполняется teardown,
[14:24.840 --> 14:30.480]  и в конце концов у нас все завершается тем, что мы вызываем функцию teardown test class, которая
[14:30.480 --> 14:35.320]  очищает все окружение. То есть у нас есть прямо аспекты, которые мы с вами прописываем. Понятно,
[14:35.320 --> 14:43.040]  что аспекты тоже могут быть и не только в императивных языках. Это что касается аспектно-ориентированного
[14:43.040 --> 14:50.280]  программирования. Следующая парадигма – это объектно-ориентированное программирование. То
[14:50.280 --> 14:56.320]  есть мы говорим, что у нас появляется такое понятие как объект, у которой мы можем с вами
[14:56.320 --> 15:04.760]  инстанциировать. У объектов у нас с вами есть возможность их создания и прописывания их
[15:04.760 --> 15:13.160]  атрибутов, полей модификаторов и методов. При этом понятно, что когда мы вводим объектно-ориентированное
[15:13.160 --> 15:22.840]  программирование, то у нас возникают три основных понятия. Какие? Энкапсуляция, полиморфизм и
[15:22.840 --> 15:28.640]  наследование. Все это знают? По идее сейчас у всех должен идти курс по объектно-ориентированному
[15:28.640 --> 15:44.800]  программированию. Ну да. Собственно как раз мы говорим, что у нас есть энкапсуляция. Давайте напишу.
[15:44.800 --> 16:04.160]  Наследование и полиморфизм. То есть энкапсуляция нам позволяет сокрыть детали реализации,
[16:04.160 --> 16:12.800]  наследование позволяет обобщить особенности определенного объекта, а полиморфизм позволяет
[16:12.800 --> 16:25.880]  определить поведение к какому объекту мы именно идем. Разделение, да. Согласен. Так и последняя
[16:25.880 --> 16:31.560]  категоризация императивных языков это обобщенное программирование. Что такое обобщенное
[16:31.560 --> 16:37.720]  программирование? Обобщенное программирование нам позволяет создавать объекты и объекты метода
[16:37.720 --> 16:44.200]  и функции, которые могут работать не только с одним типом данных, но и с несколькими типами данных.
[16:44.200 --> 16:54.560]  Давайте попробуем привести примеры. Да, конечно, это шаблоны. То есть ВС++ это шаблоны. Если мы говорим
[16:54.560 --> 17:08.320]  про джаву, то это... Так, есть здесь люди, кто джаву знает? Какой механизм в джаве? О том,
[17:08.320 --> 17:15.000]  что мы можем у функции подставлять разные типы, принимать разные типы, его класс принимать разные
[17:15.000 --> 17:22.120]  типы. Ну, конечно же, дженерики. Да, понятно, что в джаве дженерики работают не по такому
[17:22.120 --> 17:29.280]  принципу, как в С++ шаблоны. Да, потому что С++ шаблоны у нас определяются на этапе компиляции. В джаве
[17:29.280 --> 17:37.720]  все-таки дженерики, они смотрят на дерево наследования от типа object. Вот, это нужно учитывать. Вот,
[17:37.720 --> 17:44.560]  значит, это основная категоризация императивных языков, которые у нас существуют. Давайте по этим
[17:44.560 --> 17:58.200]  всем аспектам вопроса. Здесь кажется, что... Смотрите, здесь важная особенность состоит в том,
[17:58.200 --> 18:04.960]  что кажется, что это... С этим мы так или иначе уже сталкивались. Совсем. Давайте перейдем в другую
[18:04.960 --> 18:13.560]  парадигму. Парадигма декларативного программирования. Она отвечает на вопрос «что». Не как, а что. И
[18:13.560 --> 18:23.240]  должно быть сделано. Пример. Классический пример. Представьте себе, что некоторые друзья идут в гости.
[18:23.240 --> 18:29.000]  Значит, что вы сделаете в императивном языке программирования? Вы скажете «выйти на остановке
[18:29.000 --> 18:35.960]  ААА, пойди туда не зная куда, поверни налево, зайди в первый подъезд». Да, то есть мы говорим именно
[18:35.960 --> 18:45.680]  набор команд, при помощи которых мы с вами можем дойти до определенной цели. У кого-нибудь есть
[18:45.680 --> 18:54.360]  мысли по тому, что в декларативном программировании нам нужно? Да, просто вот вам адрес, координаты,
[18:54.360 --> 19:01.840]  вперед. Решайте сами, как вы добираетесь до этой цели. Да, именно так. Значит, вы в декларативном
[19:01.840 --> 19:11.440]  у нас есть адрес bbb, нам важно быть к cc2.dd, каким образом неважно. И это позволяет сделать некоторые
[19:11.440 --> 19:21.240]  специальные вещи, которые, так сказать, позволяют нам ограничить наши действия, то есть ограничить
[19:21.240 --> 19:27.960]  некоторые ошибки. Понятно, что тогда язык программирования на себя должен брать гарантии по
[19:27.960 --> 19:36.200]  поводу того, что у нас могут быть ошибки. Давайте я приведу один классический пример. Он касается
[19:36.200 --> 19:45.160]  не именно языков программирования, а именно самой парадигмы. Представьте себе, что бедный Паша
[19:45.160 --> 19:51.960]  увидел, что наступил дедлайн, и сказал, что ему нужно поставить 10 серверов АхЧек. Значит,
[19:51.960 --> 20:07.680]  он берет на АхЧек ставить 10 серверов. Дальше ему говорят, что надо поставить... Потом пришел не
[20:07.680 --> 20:12.920]  только курс по телевизору программирования, пришло еще какое-то количество курсов, и ему говорят,
[20:12.920 --> 20:19.240]  что нам теперь нужно 15 серверов. В интервативной парадигме мы можем очень легко запутаться и
[20:19.240 --> 20:24.960]  сказать следующее. Либо нам нужно поставить еще 5 серверов для того, чтобы у нас было 15,
[20:24.960 --> 20:41.760]  либо мы можем спутать команду и сказать, что нам должно быть... Сколько? Еще 15. То есть нам
[20:41.760 --> 20:52.080]  нужно производить какие-то вычисления. Особенно если у нас где-то неявная этипизация,
[20:52.080 --> 21:00.800]  мы работаем в Javascript, но так-то понятно, что мы получаем 25 серверов. И затраты сильно возрастают.
[21:00.800 --> 21:06.920]  Понятно, что 25 серверов это много, поэтому во всех таких языках, особенно в облачной инфраструктуре,
[21:07.480 --> 21:12.280]  когда мы уходим арендовать серверы, обычно работают чисто в декларативной парадигме,
[21:12.280 --> 21:21.000]  для того чтобы таких ошибок не было. А система должна сама решать, каким образом прийти в это
[21:21.000 --> 21:29.880]  состояние. И здесь, извините, мне нужно сделать некоторую отсылку к Матану. Как раз Матан был.
[21:29.880 --> 21:38.520]  Для того, чтобы работать в этой парадигме, нам важно, чтобы, особенно в установке серверов,
[21:38.520 --> 21:46.800]  нам очень важно обеспечить то, что мы можем прийти в это состояние. И для этого нужно два
[21:46.800 --> 21:49.920]  свойства основных. Во-первых.
[22:16.800 --> 22:40.800]  Первое. Это сходимость к предельной точке. То есть, смотрите, пример такой, что у вас надо
[22:40.800 --> 22:45.360]  арендовать 15 серверов, потом вы в какой-то момент понимаете, что вам осталось 14 арендовать,
[22:45.360 --> 22:52.600]  13 арендовать, 12 арендовать и так далее. То есть вы сходите в предельной точке. В математике есть такое
[22:52.600 --> 23:02.720]  понятие, как сжимающее отображение. И, возможно, эта идея у вас уже была в курсе математического
[23:02.720 --> 23:09.000]  анализа, когда вы берете какой-то набор точек, дальше каждый раз вы понимаете, что расстояние
[23:09.000 --> 23:23.520]  между точками уменьшается. Не было? Ну, к примеру, классическая задача, что у вас есть какая-то
[23:23.520 --> 23:34.920]  возрастающая функция, да, и она, известно, что ограничена сверху. Ну, значит, да, и причем
[23:34.920 --> 23:41.040]  она является у нас непрерывной. Вот это важно. И тогда в этой точке у нас существует предельное
[23:41.040 --> 23:48.320]  значение, которого мы придем, когда мы дойдем до правой границы. То есть мы можем дойти до
[23:48.320 --> 23:55.920]  предельной точки. И как раз цель вот этих вот декларативных языков, особенно в инфраструктуре
[23:55.920 --> 24:00.040]  настройки оборудования, как раз потихоньку приходить к этой предельной точке. Возможно,
[24:00.040 --> 24:04.120]  не за одну итерацию, а за большое количество итераций. Почему, как вы думаете, нельзя
[24:04.120 --> 24:16.640]  гарантировать, что мы придем к финальной точке за одну итерацию? Ну, все очень просто. Сеть
[24:16.640 --> 24:23.080]  может оборваться, сеть может выключиться и так далее. То есть у нас есть факторы, которые могут
[24:23.080 --> 24:30.360]  повлиять на это. А второе свойство, оно тоже очень важно, и оно говорит о том, что нам не стоит вообще
[24:30.360 --> 24:36.960]  рассчитывать на ошибки. То есть, смотрите, это свойство называется идентпотентностью.
[24:36.960 --> 24:48.280]  Наверное, у вас этого определения в курсе математического анализа еще не было?
[24:48.280 --> 24:56.600]  На алгейме было. Ну, давайте я тогда введу определение идентпотентности.
[24:56.600 --> 25:02.160]  Собственно, мы говорим, что функция f является идентпотентной.
[25:02.160 --> 25:31.680]  Функция f из x в x такая, что для любого x f от x равно f от f от x. Что это означает?
[25:31.680 --> 25:36.640]  На терминах языков программирования это означает, что мы какую-то функцию выполнили один раз,
[25:36.640 --> 25:41.840]  получили какой-то результат, и в принципе нам не страшно выполнить эту же функцию еще один раз для
[25:41.840 --> 25:50.040]  того, чтобы получить тот же самый результат. Потому что у нас могут быть ретраи, то есть нам
[25:50.040 --> 25:54.880]  нужно будет повторять какое-то действие. Давайте пример попробуем привести идентпотентной функции
[25:54.880 --> 26:02.440]  с точки зрения программирования. Ну, каких-то утилит, которые вы уже смотрели.
[26:02.440 --> 26:09.080]  Ладно, давайте это. Пример.
[26:09.080 --> 26:18.040]  Чего? А какое было?
[26:18.040 --> 26:35.880]  Ну, вполне возможно. Я просто, видимо, разограничил его на два определения. В принципе, первое обычно
[26:35.880 --> 26:41.400]  позволяет ослабить определение. То есть через некоторое количество итераций мы получим тоже
[26:41.400 --> 26:52.520]  самое значение. Давайте пример идентпотентной функции. Ну, ls нет, она не является идентпотентной,
[26:52.520 --> 26:58.360]  потому что у нас кто-то в какое-то время может создать какую-то директорию, вывод будет не тем
[26:58.360 --> 27:17.120]  же самым. Давайте мы как раз сделаем следующее. Так, мы выполнили функцию mcadirtest. Что произойдет,
[27:17.120 --> 27:27.320]  если мы еще раз выполним эту функцию? Вы уверены? Мы получим ошибку, что такая директория уже
[27:27.320 --> 27:34.560]  существует. Это неидентпотентная функция, потому что мы применили ее один раз, применили ее один,
[27:34.560 --> 27:39.800]  второй раз. Мы на второй раз получаем ошибку. Понятно, что возвращение ошибки не то же самое.
[27:39.800 --> 27:48.640]  Кто может сказать, какая функция будет идентпотентной в данном случае? mcdir-p. Она говорит,
[27:48.640 --> 27:54.160]  что я не буду создавать директорию, если она уже существует. Более того, она создает родительские
[27:54.160 --> 28:00.800]  директории. То есть мы теперь можем сделать и повторять эту функцию бесконечное количество раз,
[28:00.800 --> 28:11.880]  и у нас результат этой функции не поменяется. Вот это пример идентпотентной функции. Понятно,
[28:11.880 --> 28:16.640]  что для того, чтобы реализовать эту идентпотентную функцию, нам нужно проверять,
[28:16.640 --> 28:22.360]  существует ли директория, если нет, то ее создавать. То есть мы берем переклады в другую парадигму.
[28:22.360 --> 28:29.200]  Вот, то есть это важно сказать в аспекте декларативного программирования, что если мы
[28:29.200 --> 28:34.000]  уходим на какую-то инфраструктуру, обслуживание инфраструктуры, то нам нужно обеспечивать вот эти
[28:34.000 --> 28:45.080]  два свойства. Так, хорошо. Понятно ли вот эту вещь? Так, теперь давайте попробуем понять,
[28:45.080 --> 28:50.880]  какие же парадигмы есть в декларативном языке. Значит, здесь есть несколько категоризаций.
[28:50.880 --> 28:56.880]  Первое из них это функциональное программирование, то есть где мы считаем, что все, что у нас есть,
[28:56.880 --> 29:05.600]  это функция. Значит, и здесь обычно выделяют тройку лидеров в этих языках. Первый язык это хаскель,
[29:05.600 --> 29:12.360]  он очень часто используется именно даже в промышленной сфере. Второй язык, ну понятно,
[29:12.360 --> 29:22.040]  что это, так сказать, как называется, противопоставление языку хаскель, это язык f-sharp,
[29:22.040 --> 29:32.840]  в котором у нас с вами по факту аналогия с c-sharp. И третий это lisp. И есть логическое
[29:32.840 --> 29:38.920]  программирование, в которых мы пишем некоторый набор логических утверждений, а дальше мы делаем
[29:38.920 --> 29:45.720]  вывод, пытаемся сделать некоторый вывод из тех инструкций, которые мы с вами написали. Сейчас
[29:45.720 --> 29:51.720]  я буду показывать примеры языков, поэтому не бойтесь. Значит, смотрите, давайте поймем
[29:51.720 --> 30:00.000]  функциональное программирование. Вот пример кода на языке хаскель. Так написан qsort. Давайте
[30:00.000 --> 30:16.360]  поймем, что здесь у нас все, что есть, это функция. Да, это qsort. Давайте разбираться. Значит,
[30:16.360 --> 30:27.520]  смотрите, что у нас получается при получении пустого списка. Возвращает пустой список. Дальше
[30:27.520 --> 30:36.120]  что оно делает? А дальше p.xs, это мы берем список на две части разделяем. То есть мы говорим,
[30:36.120 --> 30:43.080]  значит, что p.xs, дальше мы говорим, что нам нужно будет запустить функцию... Это, кстати, не
[30:43.080 --> 30:49.000]  оптимальная реализация qsort, я сразу скажу. Это просто для показаний демонстрации. Значит,
[30:49.000 --> 30:54.560]  что нам нужно сделать дальше? Нам нужно будет сконкатенировать списки qsort от лесор,
[30:54.560 --> 31:04.920]  дальше взять наш код p и дальше использовать qsort от greater. Где greater это функция и lesser это
[31:04.920 --> 31:15.560]  функция. То есть все, что у нас есть, это функции. То есть у нас lesser это filter меньше, чем по
[31:15.560 --> 31:22.160]  значению p от xs. То есть мы оставляем результаты тех функций, тех значений, которые меньше,
[31:22.160 --> 31:31.760]  чем p. С другой стороны greater это тоже применение результатов функции filter к объекту xs. Ну,
[31:31.760 --> 31:38.000]  к списку. То есть у нас что? У нас есть список. В нем у нас есть...
[31:38.000 --> 31:53.640]  Значит, мы, когда работаем со списками, мы можем выделить голову p и xs. Вот. Значит,
[31:53.640 --> 32:07.080]  после применения функции lesser мы оставляем только те элементы, которые меньше, чем p. А те,
[32:07.080 --> 32:18.000]  которые greater, это те, которые имеют значение больше, равно, чем p. А дальше мы говорим,
[32:18.000 --> 32:34.560]  что нам нужно сконкатенировать вот это, вот это и вот это. А, когда мы начинаем применять эту
[32:34.560 --> 32:42.080]  функцию к какому-то объекту? То есть у нас получается по факту труба, в которую мы загружаем наш базовый
[32:42.080 --> 32:47.680]  объект. И после этого мы получаем какие-то результаты. То есть видите, здесь именно main
[32:47.680 --> 32:52.800]  это функция. То есть когда я запущу, она проницилизирует список и через этот конвейер
[32:52.800 --> 33:00.560]  прогонит этот список. То есть она для этого значения 834 начнет выполнять вот эту функцию. Она
[33:00.560 --> 33:07.120]  принимает огромное значение. После этого она отцепляет наши переменные, отцепляет наше,
[33:07.120 --> 33:15.520]  так сказать, значение 8 на 34 и делает сортировку. То есть она запускает qsort от lesser. Значит,
[33:15.520 --> 33:22.480]  что у нас lesser? Нам нужно как раз его получить. Собственно, мы применяем функцию lesser к
[33:22.480 --> 33:31.920]  аргументам xs, прогоняем ее на значение меньше чем p и greater на значение больше чем p. После этого
[33:31.920 --> 33:39.220]  у нас собирается итоговый результат. То есть у нас получается такой конвейер по выполнению этих
[33:39.220 --> 33:47.040]  функций. Вот, значит сразу скажу, что в отличие от языков, от классических именно чисто
[33:47.040 --> 33:56.880]  функциональных парадигм, список из 8, 3 и 4 это тоже функция. Если мы говорим про чисто лямбда
[33:56.880 --> 34:02.400]  исчисления, то восьмерка это специальная константа, тройка это тоже специальная константа и вообще нам
[34:02.400 --> 34:07.840]  нужно вводить операцию конкатинации для наших списков. Но давайте мы этого делать не будем.
[34:07.840 --> 34:14.840]  Но одна из важных особенностей функционального программирования, которая сильно помогает
[34:14.840 --> 34:20.360]  работать как раз в этой парадигме, это имутабельные объекты. То есть по факту вы не можете изменить
[34:20.360 --> 34:26.840]  объекты. То есть у вас все есть функция, вы ее зафиксировали, вы с ней работаете. То есть у вас нету
[34:26.840 --> 34:34.160]  такого свойства, как присвоить переменные какое-то значение. И если вы в каком-то
[34:34.160 --> 34:40.600]  функциональном коде видите имутабельные, присваивание переменной значения, значит вы
[34:40.600 --> 34:53.400]  выходите из функциональной парадигмы. Вот такой пример. Вот тоже организован таким
[34:53.400 --> 35:02.520]  образом, что мы берем один элемент и мы его тянем. Одним из главных важных особенностей
[35:02.520 --> 35:10.920]  функциональной парадигмы это коррирование. Давайте я его покажу на примере. Давайте открою
[35:10.920 --> 35:37.520]  какой-нибудь Python 3. Я открываю Python. Вот так. Так, вот мы написали функцию edit от
[35:37.520 --> 35:46.960]  аргумента phi и b. Вот в чистой парадигме мы бы выполнили так, что у нас 3 плюс 5 равно 8.
[35:46.960 --> 35:51.840]  Но что позволяет делать функциональная парадигма? Она позволяет выполнять опцию
[35:51.840 --> 35:57.240]  коррирования. То есть вы можете из объекта вида функций создать новую функцию. В Python это
[35:57.240 --> 36:17.720]  реализовывается следующим образом. По-моему, так модуль называется. Вот. Мы создали с вами
[36:17.720 --> 36:23.480]  функцию edit3, которая является partial объектом от add3. То есть по факту это новая функция,
[36:23.720 --> 36:39.000]  в которой вместо одного аргумента уже подставлено значение. То есть у нас получается функция add3.
[36:39.000 --> 36:46.520]  Это функция, которая будет возвращать на вход b значение 3 плюс b. Вот. И это одна из важных
[36:46.520 --> 36:56.280]  фишек как раз в функциональной парадигме. Зачем это может быть полезно? Как раз для того,
[36:56.280 --> 37:01.760]  чтобы если мы обрабатываем какие-то списки, чтобы у нас новая функция применялась не к нашему
[37:01.760 --> 37:10.600]  объекту вида списка, а уже к списку без головы. Там все как раз работает на списке. И тут,
[37:10.600 --> 37:14.800]  конечно, давайте я попробую сейчас найти какой-нибудь интересный пример. Я не помню,
[37:14.800 --> 37:30.320]  есть ли он у меня тут. Возможно... Нет, я не найду. В общем, там тоже есть некоторые приколы.
[37:30.320 --> 37:36.000]  Потом, возможно, если попросить, я покажу примеры. Как некоторые функции написать
[37:36.000 --> 37:42.040]  чисто в функциональной парадигме. Там будет взрыв голова. Так. Это что касается функциональных
[37:42.360 --> 37:45.400]  программирований. Теперь давайте перейдем к логическим языкам программирования.
[37:45.400 --> 37:56.960]  Собственно, здесь как раз у нас идет вывод в виде инструкций. Это язык пролог. На нем до сих пор
[37:56.960 --> 38:01.520]  можно использовать. Даже я где-то читал, что его можно использовать для искусственного интеллекта,
[38:01.520 --> 38:07.960]  правда, чисто для вывода всяких логических высказываний. Итак, смотрите, что мы делаем с вами.
[38:07.960 --> 38:15.640]  Здесь изначально на языке прологи мы делаем некоторую констатацию фактов. Что у нас есть?
[38:15.640 --> 38:22.480]  У нас есть некоторое магическое число x. Мы задаем некоторые условия. Там давайте,
[38:22.480 --> 38:26.840]  чтобы это не быть голословным, я покажу пример.
[38:38.800 --> 38:48.360]  Вот. Смотрите. Это констатация фактов. То есть у нас есть 3 магических числа 7, 9 и 42.
[38:48.360 --> 38:56.080]  То есть мы работаем в другой парадигме. А дальше мы говорим, что у нас есть некоторое
[38:56.080 --> 39:07.680]  магическое число x. И мы хотим сделать некоторую вещь. То есть plus x, y 100. Давайте как раз я
[39:07.680 --> 39:18.200]  попробую запустить это. Все дело. Значит, мы с вами загружаем. Это факт загрузки из файлов. Мы загрузили.
[39:29.440 --> 39:36.640]  Видите, plus это операция. И он нам выводит ответы, которые нам подходят.
[39:37.680 --> 39:47.200]  При этом можно сделать вывод всех ответов, не только этого текущего. То есть в принципе мы
[39:47.200 --> 39:54.720]  пытаемся из некоторого набора утверждений, которые мы задаем, получить некоторый вывод о том,
[39:54.720 --> 40:02.760]  какие значения нам подходят. То есть обычно мы делаем набор операций для того, чтобы получить
[40:02.760 --> 40:08.400]  результат. А здесь мы говорим наоборот. Что вот у нас есть какие-то финальные действия, и нам нужно
[40:08.400 --> 40:13.400]  вычислить последствия операции, которые нам нужны. То есть у нас есть финальный результат,
[40:13.400 --> 40:20.960]  что у нас есть магическое число x, и нам нужно получить, что x plus y равно 100. А какой x? То есть
[40:20.960 --> 40:29.360]  как именно получить наш результат? Тоже интересная вещь. И сразу скажу, что когда мы говорим про
[40:29.360 --> 40:34.480]  парадигмопрограммирование, просто важно понимать, что, грубо говоря, мы можем мыслить не только в
[40:34.480 --> 40:42.640]  текущей парадигме, в которой нас обычно учат писать наш код. Вот такие вот интересные примеры. Так,
[40:42.640 --> 40:50.720]  это что касается примера на языке пролог. Значит, голову сильно меняет. Нам учатся писать с этими
[40:50.720 --> 40:57.680]  языками. Так, понятно ли, в чем заключается декларативная парадигма? То есть здесь у нас
[40:57.680 --> 41:04.320]  получается, мы заранее декларируем функции, по которым мы должны работать, а после этого выполняем
[41:04.320 --> 41:09.920]  результат. Здесь мы говорим, что у нас есть набор уже утверждений, и в конце вот этот чисто
[41:09.920 --> 41:19.120]  декларативный язык. И мы вычисляем последствия действия, которые нам нужно сделать. Так,
[41:19.120 --> 41:26.000]  можем двигаться дальше. Теперь мы идем в другую периметикулярную ветку и рассмотрим другие
[41:26.000 --> 41:31.280]  парадигмы программирования, которые у нас могут существовать. Первое парадигма программирования
[41:31.280 --> 41:38.400]  это метапрограммирование. Я не буду тут детально говорить, тут вообще на четвертом курсе отдельный
[41:38.400 --> 41:48.720]  курс есть по метапрограммированию, в котором учатся писать. Это главная суть, что программы
[41:48.720 --> 41:54.480]  могут генерировать новые программы на этапе компиляции. Сразу тут есть небольшая добавка,
[41:54.480 --> 42:09.280]  версии 2023-2024 года. И это не прочат ГПТ. Да, потому что сейчас уже появились промежуточные искусственные тела,
[42:09.280 --> 42:14.240]  которые могут генерировать программы. В общем, суть в чем? Суть в том, что мы пишем инструкции,
[42:14.240 --> 42:23.760]  которые на этапе компиляции позволяют нам генерировать разные функции. Ну да, я согласен,
[42:23.760 --> 42:30.800]  поэтому про этап компиляции здесь как раз у нас не проходит утверждение. Смотрите, вот примеры два.
[42:30.800 --> 42:37.920]  С++ поддерживает несколько парадигм, перпендикулярно. Первое это ООП, и второе это
[42:37.920 --> 42:43.560]  метапрограммирование. Итак, у нас слева видно, что у нас есть класс блинкер, который обладает
[42:43.560 --> 42:47.840]  некоторыми атрибутами. То есть это у нас конкретный класс, в котором мы можем видеть объекты. А справа
[42:47.840 --> 42:55.440]  это у нас с вами метапрограммирование, которое позволяет нам создать уникальный объект определенного
[42:55.440 --> 43:03.160]  класса. То есть мы по факту делаем UniquePTR над определенным объектом. И при этом мы можем получить
[43:03.160 --> 43:10.320]  как L-value, так и R-value. То есть L-value это то, во что можно присваивать значение, R-value это то,
[43:10.320 --> 43:17.240]  во что нельзя присваивать значение. То есть в принципе чем особен как раз язык C++,
[43:17.240 --> 43:28.400]  что в нем можно разные интересные инструкции писать. Вот, такая интересная вещь. Значит,
[43:28.400 --> 43:35.240]  это что касается вот классического, классической парадигмы. А сейчас мы перейдем к некоторым
[43:35.240 --> 43:41.600]  перпендикулярным парадигмам, которые на самом деле сейчас изменили современный веб,
[43:41.600 --> 43:53.080]  современную веб-разработку. Это реактивное программирование. Да, в том числе через нее
[43:53.080 --> 44:00.600]  происходит динамическая генерация страниц. Значит, суть в следующем, что наша цель стоит в следующем,
[44:00.600 --> 44:06.720]  что как только мы изменили данные на входе, мы должны перезапустить триггер на изменение данных
[44:06.720 --> 44:11.920]  на выходе. То есть смотрите, за течение времени у нас есть какое-то событие, которое изменяет,
[44:11.920 --> 44:17.280]  допустим, данные нашей формы. То есть представим себе, что у нас возникло какое-то новое поле.
[44:17.280 --> 44:27.800]  У нас возникло какое-то поле, да, ну то есть при нажатии клика к нам приехали новые данные,
[44:27.800 --> 44:36.480]  и мы как раз получаем этот ответ и обновляем наш графический интерфейс на лету. Вот,
[44:36.800 --> 44:46.240]  давайте вопрос. Как вы думаете, какой инструмент поддерживает реативную парадигму, сказать,
[44:46.240 --> 44:55.920]  нативно? Это его важная особенность. Нет, JavaScript немножко по другой парадигме работает. Она работает
[44:55.920 --> 45:09.840]  больше по событийной парадигме. Нет, Django это прям модуль view-контроллер. Шутки шутками,
[45:09.840 --> 45:14.160]  но сейчас я кое-что сделаю.
[45:25.920 --> 45:40.200]  Да, это Excel. Пишем один, пишем два, пишем три, пишем четыре. Дальше делаем, я извините,
[45:40.200 --> 45:56.080]  с этим. Теперь смотрите, вот у нас, а как тут шрифт увеличить? А, зум нашел. Теперь смотрите,
[45:56.080 --> 46:01.200]  вот у нас функция есть, один плюс два плюс три плюс четыре равняется десять. Теперь мы меняем
[46:01.200 --> 46:10.760]  значение с четверки среднички на пятерке, у нас меняется значение. Меняем значение, получаем новое
[46:10.760 --> 46:27.840]  значение. Вот это как раз пример того, как работает реактивная парадигма. Да, согласен. На самом деле,
[46:27.840 --> 46:34.800]  смотрите, здесь особенность в том, что реактивное программирование это часть, я читал вчера
[46:34.800 --> 46:40.080]  действительно всякие разные вещи, когда готовился к лекции, и они говорят, что реактивное
[46:40.080 --> 46:45.560]  программирование это подмножество событийного программирования. То есть как раз вы описываете
[46:45.560 --> 46:49.960]  сейчас аспект событийного программирования. То есть у нас прилетает какое-то событие, именно это
[46:49.960 --> 46:58.600]  событие начинаем вешать, ограничить, вешать какие-то изменения. И вообще все современные как раз
[46:58.600 --> 47:04.720]  фреймворки, они так или иначе поддерживают эту реактивную парадигму. Давайте как раз посмотрим,
[47:04.720 --> 47:11.760]  что это за фреймворки. Значит, кем образом они работают. Значит, примеры Excel и библиотеки
[47:11.760 --> 47:17.520]  семейства Rx. То есть это именно, прям выделили отдельные семейства библиотек, которые работают
[47:17.520 --> 47:22.000]  именно в такой парадигме. Значит, здесь мы говорим следующее, что обычно есть два классических
[47:22.000 --> 47:29.360]  примера. Первое это Rx.java, который используется и в андроиде, то есть для того, чтобы обрабатывать
[47:29.360 --> 47:36.560]  события. И второе это Rx.js, при помощи которого используются все фреймворки. То есть, в принципе,
[47:36.560 --> 47:58.960]  наверное давайте рубрику эксперимент. Мы пойдем посмотрим package.json. То есть когда мы говорим про
[47:58.960 --> 48:14.440]  JavaScript. Ну, собственно, о чем нужно говорить? В зависимости от пакетов, несмотря на то,
[48:14.440 --> 48:20.960]  что написано это все на фреймворке Angular, видите под капотом стоит Rx.js. То есть для того,
[48:20.960 --> 48:27.520]  чтобы как раз динамически обрабатывать события при изменении данных. Ну и, собственно, как это
[48:27.520 --> 48:34.880]  пишется, допустим. Господи, я сейчас попытаюсь найти это.
[48:34.880 --> 48:57.400]  Так, давайте сделаем вот так.
[49:04.880 --> 49:23.840]  Вот пример. Парадигма называется ngif. Вот видите форма? То есть мы прямо в язык
[49:23.840 --> 49:29.760]  программирования, мы прямо в код вставляем вот такую вещь, что вот у нас есть некоторый класс,
[49:29.760 --> 49:37.680]  формочка. Видите? Формочка под названием форма. И мы говорим, что если у нас, когда она отображается
[49:37.680 --> 49:42.840]  у нас, она у нас отображается в том случае, если у нас не установлен пароль, переменная
[49:42.840 --> 49:51.800]  password set. Иначе мы ставим success message. То есть как только у нас в данных значение переменной и в
[49:51.800 --> 49:57.960]  password set будет установлена true, у нас эта форма пропадет и у нас появится success message.
[49:57.960 --> 50:08.400]  Месседж success, где он у нас? Вот он. Так, success, господи. Вот он, шаблон. То есть у нас после отрисовки
[50:08.400 --> 50:16.080]  этого поля у нас появится вот это вот поле. Давайте теперь посмотрим, как это работает.
[50:16.080 --> 50:40.360]  Смотрите, здесь есть форма. Вот она, форма. Вот, это форма смены пароля. Я поставил новый пароль.
[50:40.360 --> 50:52.000]  Вот, и у меня пропала форма как раз. Правда, нас по идее должны было редиректнуть. Ну,
[50:52.000 --> 51:00.560]  видимо это... А, это set new password. То есть это меню, когда мы пытаемся восстановить пароль. Вот,
[51:00.560 --> 51:06.400]  он дальше написано, что оно меняет на поле, где у вас пароль установлен. Да, пожалуйста,
[51:06.400 --> 51:14.920]  зайдите на страницу логина. То есть идет подмена форм в реактивном виде. Вот,
[51:14.920 --> 51:21.960]  и это основная вещь. Значит, и вот пример, собственно, который здесь есть, в каком стиле это
[51:21.960 --> 51:27.520]  можно написать, это можно написать и в функциональном стиле. То есть вот этот пример как раз у нас есть.
[51:27.520 --> 51:33.240]  У нас создается объект типа observable, элемент. То есть у нас есть некоторый список ops1,
[51:33.240 --> 51:39.320]  ops2. Список наблюдений. Да, то есть над объектом. А дальше мы говорим следующее, что давайте мы
[51:39.320 --> 51:46.160]  смёржим эти два объекта. То есть они у нас будут лететь. Вот эти два стрима, которые у нас летят.
[51:46.160 --> 51:52.800]  Дальше мы отфильтруем значение, которое меньше чем 4. После этого применим функцию map, которая будет
[51:52.800 --> 51:59.880]  менять из и и в и плюс один. И дальше у нас возникает подписка на определенные события. То есть это
[51:59.880 --> 52:06.120]  даже больше уже событийная история. То есть у нас получается, что по факту будут печататься только те
[52:06.120 --> 52:15.560]  элементы, которые у нас получаются меньше чем 4, и к ним прибавляется значение 1. И в итоге мы получаем
[52:15.560 --> 52:25.400]  подписку на наши события. Так, это понятная штука, что по факту мы можем работать именно в такой
[52:25.400 --> 52:30.160]  парадизме. Что у нас есть труба, в которую грузят данные, изменения данных. А дальше мы после изменения
[52:30.160 --> 52:38.960]  данных их устанавливаем в какой-то момент времени. Так, ну хорошо. Значит и здесь нам нужно будет,
[52:38.960 --> 52:46.240]  опять же, остановиться и понять, что у нас с вами здесь есть некоторый объект типа observable. У нас
[52:46.240 --> 52:52.000]  есть какая-то подписка на события. Это значит, что у нас должен быть новый паттерн. Ну собственно,
[52:52.000 --> 52:56.880]  как это реализовывать? Нам надо понять. Значит, для этого как раз используется паттерн Observer. Его
[52:56.880 --> 53:04.160]  вообще много как пишут. Это либо Observer, либо Publisher-Subscriber, либо Event Emitter. В общем,
[53:04.160 --> 53:10.200]  у него есть большое количество разнообразных определений, но важно в целом суть. Значит,
[53:10.200 --> 53:14.560]  цель этого паттерна будет состоять в том, что одним предоставить возможность подписки на какое-то
[53:14.560 --> 53:20.200]  событие, другим предоставить возможность отправлять подписчикам сведения о совершаемых изменениях. То
[53:20.200 --> 53:27.320]  есть, мы присылаем и совершаем изменения, и дальше мы делаем некоторые результаты. Вот.
[53:27.320 --> 53:35.040]  Реализация паттерна достаточно простая. Значит, у нас есть с вами Subject, у которого есть, значит,
[53:35.040 --> 53:42.640]  метод обновления всех полей, view. Вот. И мы можем установить какое-то значение для всех подписчиков.
[53:42.640 --> 53:49.680]  То есть, дальше, что у нас у этого субъекта есть? У нас есть у этого субъекта список всех
[53:49.680 --> 53:55.360]  подписчиков на событие, и дальше каждый из обсерверов пытается получить как раз состояние
[53:55.360 --> 54:01.440]  нашего субъекта и обновить состояние в связи с этого обновления. То есть, таким образом работает
[54:01.440 --> 54:11.440]  push-уведомление. Да, то есть, мы по факту говорим, пожалуйста, что мы хотим отправить всем необходимым
[54:11.440 --> 54:17.880]  клиентам некоторое push-уведомление через определенный канал связи. Значит, а дальше у вас как
[54:17.880 --> 54:24.280]  раз у вас стоит обработчик. У каждого клиента. Принимать это push-уведомление или нет. То есть,
[54:24.280 --> 54:30.040]  если у вас это push-уведомление запрещено в настройках, то вам ничего не работает. То есть,
[54:30.040 --> 54:36.000]  у вас это уведомление появляется. А если нет, то вам приходит уведомление. Кстати, в некоторые
[54:36.000 --> 54:41.560]  моменты времени, ну, то есть, сразу скажу, что push-уведомление это вещь как хорошая, так и плохая,
[54:41.560 --> 54:48.240]  потому что на самом деле один из способов как раз рассылки данных, зачастую, это отправка
[54:48.240 --> 54:53.960]  push-уведомлений. То есть, она проходит по отдельному протоколу связи, поэтому она может прислать
[54:53.960 --> 55:04.600]  некоторые метаданные, которые можно использовать. Ну, такая отсылка, что Telegram работал несколько
[55:04.600 --> 55:14.520]  лет назад благодаря push-уведомлению в нашей стране. Вот. Значит, каким образом это можно применять?
[55:14.520 --> 55:21.440]  Первое, это что у нас неизвестна реакция на события, которые у нас есть. И, возможно, что у нас
[55:21.440 --> 55:29.120]  некоторые люди по-разному наблюдают, используют наблюдение на сервисе. Ну, вы, наверное, уже
[55:29.120 --> 55:35.680]  знаете, что бывает такое, что вам говорят, пожалуйста, нажмите на колокольчик для того, чтобы это видео
[55:35.680 --> 55:41.560]  до вас доходило в первую очередь. А, собственно, вы меняете способ приоритета отправки уведомлений.
[55:41.560 --> 55:48.640]  То есть, в первую очередь будут рассылаться темы, у кого колокольчик, а вторую, с точки зрения, темы,
[55:48.640 --> 55:54.280]  у кого нет этого колокольчика. Ну, и с колокольчиками есть проблемы, и это недостаток паттерны. Какая
[55:54.280 --> 56:10.200]  проблема есть с уведомлениями на ютубе? Обычные блогеры любят жаловаться на эту тему. Не доходят,
[56:10.200 --> 56:16.920]  уведомления могут не дойти. То есть, во-первых, возможна задержка, во-вторых, уведомления могут
[56:16.920 --> 56:27.040]  не дойти. И, значит, более того, подписчики могут оповещаться в случайном порядке. Но, в принципе,
[56:27.040 --> 56:33.000]  мы это можем решить, если мы зададим приоритет наших подписок. Так, давайте я покажу пример.
[56:33.000 --> 56:51.760]  По-моему, он у нас есть. Так, Observer. Да, есть. Значит, здесь все в одном файле. Итак, смотрите,
[56:51.760 --> 56:59.640]  что у нас здесь есть. У нас здесь есть следующая вещь. Здесь очень простой механизм. Значит,
[56:59.680 --> 57:05.720]  у нас есть хранение сообщений. Это, кстати, базовая реализация очереди сообщений. И у нас есть мир.
[57:05.720 --> 57:13.040]  Да, тут переменные однобуквенные, к сожалению. Надо это исправить. Значит, у нас есть хранение
[57:13.040 --> 57:17.760]  сообщений. То есть, у нас как раз есть мир и есть отдельные существа для хранения сообщений. То
[57:17.760 --> 57:23.440]  есть, у нас по факту здесь реализован pattern-мост в какой-то степени. Пользуем композицию. Дальше у
[57:23.440 --> 57:33.200]  нас есть Editor и есть Listener. Значит, дальше мы делаем следующее. У нас мир. Мы подписываем игрока
[57:33.200 --> 57:44.560]  P1 на события во всем мире. И подписываем игрока на события во втором мире. При этом у нас Editor
[57:44.560 --> 57:53.200]  начинает читать сообщения, а T2 начинает писать сообщения. Т2 начинает писать сообщения T1.
[57:53.200 --> 58:00.960]  Собственно, значит, что делает process message? Он делает пока while true и мы указываем,
[58:00.960 --> 58:06.320]  к какому игроку мы отправляем сообщения. То есть, представь себе, что у нас будет чат. И у нас P2
[58:06.320 --> 58:13.480]  будет отправлять P1 по первому сообщению в чат. А когда мы делаем подписку на события, то мы
[58:13.480 --> 58:20.520]  добавляем наших игроков в чат. И дальше у нас как раз что происходит? Когда у нас один товарищ
[58:20.520 --> 58:27.920]  отправляет сообщения, смотрите, плеер отправляет сообщения определенному миру, он отправляет
[58:27.920 --> 58:43.680]  сообщения как раз во всю историю. Он отправляет сообщения во все место. Единственное, что здесь
[58:43.680 --> 58:51.160]  нужно сделать так, чтобы сообщения шли в правильном порядке, поэтому здесь идет некоторый примитив
[58:51.160 --> 58:57.400]  синхронизации. В общем, для того, чтобы у нас один поток не заходил, два потока параллельно не
[58:57.400 --> 59:02.680]  заходили в эту инструкцию. То есть, для того, чтобы сообщения рассылались всем подряд. Давайте как раз
[59:02.680 --> 59:17.480]  я, наверное, возьму прямо этот пример и его скомпилирую. По ходу дела.
[59:17.480 --> 59:35.720]  Кто лисенер, кто эдитер. Вот, эдитер, потому что мы его подключаем на функцию отправки сообщений,
[59:35.720 --> 59:41.320]  а остальные будут как раз получать сообщения. То есть, получается, мы подключаем отдельный поток
[59:41.320 --> 01:00:05.400]  на отправку. О, ошибка линковки. Надо не забывать линковать билетеку с PSRED. Вот, то есть, у нас
[01:00:05.400 --> 01:00:14.800]  получается вот, вот у нас идет отправка сообщений, у нас есть push message, вот, и дальше у нас в отдельном
[01:00:14.800 --> 01:00:21.960]  потоке у нас висит сообщение именно, чтобы мы получаем это сообщение. Понятно, что мы их могли,
[01:00:21.960 --> 01:00:31.560]  допустим, директивно поменять, то есть, отправить его в другое место. То есть, здесь по факту нужно
[01:00:31.560 --> 01:00:40.520]  было бы написать следующее, что это не классическая реализация, а именно, там,
[01:00:40.520 --> 01:00:49.440]  да, тут лучше было бы написать, что мы отправляем сообщение от определенного игрока и вызвать
[01:00:49.440 --> 01:00:54.440]  функцию игрока как раз, что мы можем прочитать сообщение. То есть, это не идеальный пример,
[01:00:54.680 --> 01:01:06.000]  конечно. То есть, как его как раз допиливать, так я остановлю. Вот-вот сюда нужно именно
[01:01:06.000 --> 01:01:13.120]  чтение сообщений, то есть, хранение сообщений должно отправляться к определенному игроку. То есть,
[01:01:13.120 --> 01:01:30.360]  то есть, что-нибудь типа вот функции void read, вот, и именно через нее отправляет сообщение. Ладно,
[01:01:30.360 --> 01:01:35.720]  это я, наверное, добавлю тогда обновленный пример, посмотрите это, как он реализуется. Просто здесь
[01:01:35.720 --> 01:01:41.400]  у нас у всех игроков возникает бра-отказ на весь мир, просто мы подключились как раз к текущему
[01:01:41.400 --> 01:01:49.800]  игроку. Если бы у нас было несколько игроков, был бы бра-отказ на несколько игроков. Немножко допилить
[01:01:49.800 --> 01:01:56.360]  этот пример надо мне, я это сделаю. То есть, по факту, все, что у нас работает в мире сейчас,
[01:01:56.360 --> 01:02:04.600]  это на системе паблишер, на системе подписок. Давайте я спрошу, понятно ли суть этого паттерна?
[01:02:04.600 --> 01:02:12.040]  То есть, одни отправляют сообщения, другие их получают. Кстати, вопрос, как вы думаете,
[01:02:12.040 --> 01:02:19.280]  кого больше, отправителей или получателей в мире? Да, получателей, причем в разы больше. Ну и всегда
[01:02:19.280 --> 01:02:26.200]  запоминаем, что операции на запись у нас обычно намного меньше, чем операции на чтение. На порядке.
[01:02:26.200 --> 01:02:32.600]  И как раз благодаря этому можно и проектировать архитектуру наших приложений. Так, следующая
[01:02:32.600 --> 01:02:38.480]  парадигма это обобщение реактивного программирования, это событийное программирование. Что такое event?
[01:02:38.480 --> 01:02:47.360]  Тут надо вести понятие. Event это значимое событие, которое возникает в программной среде. И на эти
[01:02:47.360 --> 01:02:53.960]  сообщения необходимо каким-то образом реагировать. Более того, некоторые события, к сожалению,
[01:02:53.960 --> 01:03:04.960]  мы с вами даже перехватить не сможем. Это особенности операционной системы устроено так. То есть,
[01:03:04.960 --> 01:03:11.200]  какие виды событий у нас с вами есть? У нас есть виды системных событий, которые передают,
[01:03:11.200 --> 01:03:15.880]  виды событий, это системные события, которые передаются через ядро с операционной системы,
[01:03:15.880 --> 01:03:22.600]  прямо нам прилетают. И есть пользовательские события, которые создаются пользователями через
[01:03:22.600 --> 01:03:29.160]  объект EventEmitter, то есть именно класс, который умеет отправлять определенные события. Значит,
[01:03:29.160 --> 01:03:38.840]  в качестве системных событий давайте я приведу пример. Я правда сейчас опять же могу сильно,
[01:03:38.840 --> 01:03:57.480]  я создам окружение и создам. Вот оно. Мы находимся в событии и здесь мы можем выполнить отправку
[01:03:57.480 --> 01:04:03.760]  определенного системного события, на которое мы даже не сможем отреагировать. Команда Kill.
[01:04:03.760 --> 01:04:27.120]  Давайте поймем, что она делает. Ответ неверный. А? Нет. Нет. Она отправляет сигнал. Она отправляет
[01:04:27.120 --> 01:04:38.560]  события под названием сигнал другому процессу. Правда сигналы бывают разные. Некоторые срабатывают,
[01:04:38.560 --> 01:04:47.880]  некоторые не срабатывают. Давайте мы попробуем эксперимент.
[01:05:08.560 --> 01:05:22.080]  Видите, набор единичек у нас. Так, смотрите. Если мы откроем сейчас HOTOP.
[01:05:22.080 --> 01:05:39.560]  Вот. И смотрите, здесь есть как раз F9 Kill.
[01:05:52.080 --> 01:05:58.560]  Теперь повторю в другом процессе, чтобы вы поняли, что произошло. Мы повторяем эту инструкцию
[01:05:58.560 --> 01:06:18.000]  и отправляем сигнал под номером 2. Поведение ровно такое же, если бы мы нажали на клавишу
[01:06:18.000 --> 01:06:24.880]  CTRL-C. Это называется interrupt-сигнал. То есть мы отправляем сигнал, который позволяет нам
[01:06:24.880 --> 01:06:30.480]  прервать исполнение. По умолчанию, кстати, любой процесс может принять событие обработки сигнала.
[01:06:30.480 --> 01:06:36.660]  Кроме, есть два сигнала, которые не перехватываются. Можете посмотреть,
[01:06:36.660 --> 01:06:49.380]  какой из них является вторым, а первый следующий. Этот сигнал не перехватывается под номером 9.
[01:06:49.380 --> 01:07:01.060]  Это нужно для экстренной остановки процесса. Вот такие системные события бывают. Понятно,
[01:07:01.060 --> 01:07:05.700]  что есть еще другие системные события. То есть, допустим, можно посмотреть, изменились ли файлы
[01:07:05.700 --> 01:07:10.900]  в определенной директории, можно подписываться на такие события. Это системные события. Значит,
[01:07:10.900 --> 01:07:15.540]  есть пользовательские события, которые создаются пользовательными. Так, понятно, что я пока... Да.
[01:07:15.540 --> 01:07:24.980]  Можно еще раз про перехват сигнала. То есть мы можем его проигнорировать? Да, да, да. То есть можно как раз посмотреть.
[01:07:24.980 --> 01:07:31.980]  Модуль сигнал, в нем как раз можно написать функцию, которая будет делать некоторые действия. Допустим,
[01:07:31.980 --> 01:07:38.340]  бывает такое, что вы хотите остановить какой-то процесс, но вам нужно сохранить данные,
[01:07:38.340 --> 01:07:45.460]  которые у вас были в этом процессе. Тогда вы делаете следующее. Вы пишете некоторый обработчик,
[01:07:45.460 --> 01:07:51.060]  который говорит, что если вы не нажмете на кнопку в течение какого-то момента времени,
[01:07:51.060 --> 01:07:59.740]  то мы остановим ваш процесс. Иначе мы продолжим работу. Давайте далеко ходить. Все видели
[01:07:59.740 --> 01:08:15.300]  Джупитер ноутбук? Ух, е-мое. Вот, у нас ноутбук. Видите, смотрите, и написано, что use ctrl-c to stop server and
[01:08:15.300 --> 01:08:23.580]  shutdown on kernels. Я нажимаю на ctrl-c и, видите, у меня возникает вот такая плашка. Видите,
[01:08:23.580 --> 01:08:28.540]  я не обработал событие в течение пяти секунд, значит оно продолжает работать с операцией.
[01:08:28.540 --> 01:08:34.420]  То есть как раз стоит сигнал-хендлер. То есть там можно установить тип сигнала и сказать функцию
[01:08:34.420 --> 01:08:41.940]  обработчика. Про это будут говорить на курсе операционных систем, как это делать. Поэтому я
[01:08:41.940 --> 01:08:47.260]  просто скажу, что вот такие события у нас действительно существуют. Так, двигаемся дальше.
[01:08:47.260 --> 01:08:56.300]  Значит, двигаемся дальше. Один из важных как раз механизмов работы с событиями это event loop.
[01:08:56.300 --> 01:09:03.180]  Значит, у нас есть некоторые, мы накапливаем некоторые стэк вызова функций и у нас функции
[01:09:03.180 --> 01:09:08.660]  могут разделиться на несколько основных частей. Это именно для веб-программирования работает,
[01:09:08.660 --> 01:09:13.940]  но в принципе работает и для других вещей. Значит, смотрите, когда мы работаем с вами в браузере,
[01:09:13.940 --> 01:09:19.100]  у нас есть несколько, некоторый набор вещей. У нас могут быть некоторые задачи, которые мы с
[01:09:19.100 --> 01:09:26.700]  вами отправляем. Есть некоторые микро задачи, которые мы по факту должны обработать достаточно
[01:09:26.700 --> 01:09:31.340]  быстро. То есть это маленькие задачи, которые просто проверяют, допустим, готов ли у вас какой-то
[01:09:31.340 --> 01:09:36.780]  результат. То есть если мы говорим с вами про chain of responsibility, нам же нужно по цепочке передать
[01:09:36.780 --> 01:09:41.660]  результат выполнения функции. Собственно, готов ли результат выполнения нашей функции для того,
[01:09:41.660 --> 01:09:46.580]  что мы его помогли передать по цепочке в следующее событие. Значит, дальше, если мы говорим про
[01:09:46.580 --> 01:09:51.620]  классические задачи, это может быть установка тайм-аутов или интервалов. То есть мы ставим
[01:09:51.620 --> 01:09:57.100]  событие о том, что у вас какое-то окно, какое-то событие должно пройти через какой-то промежуток
[01:09:57.100 --> 01:10:03.380]  времени. Через секунду, через две, через три. То есть вы сами ставите событие, которое вы можете
[01:10:03.380 --> 01:10:08.580]  потом обработать. То есть у вас, допустим, загорелась плашка, у вас загорелась плашка на 10 секунд.
[01:10:08.580 --> 01:10:20.820]  И есть информация про рендер, то есть каким образом мы отрисовываем наш объект. Тут в браузере
[01:10:20.820 --> 01:10:26.460]  тоже можно попробовать посмотреть, как можно поставить события. Функции обычно называют set
[01:10:26.460 --> 01:10:32.620]  timeout и set interval. И, собственно, у нас есть отдельный цикл, который у нас как раз вращается и
[01:10:32.620 --> 01:10:40.140]  позволяет обрабатывать задачи. То есть все вот эти вот истории, связанные с ассинхронным
[01:10:40.140 --> 01:10:45.180]  программированием, зачастую реализуются через event loop. То есть создается цикл, в котором мы
[01:10:45.180 --> 01:10:53.020]  начинаем обрабатывать события. В том числе в питоне, если вы посмотрите на любое событие,
[01:10:53.020 --> 01:10:59.380]  то на любое ассинхронное программирование вам тоже там будут создавать event loop, в котором вы
[01:10:59.380 --> 01:11:04.340]  начинаете обрабатывать задачи. И у вас возникает эфемерность многопоточности, хотя на самом деле
[01:11:04.340 --> 01:11:11.460]  там никакой многопоточности нет. Мы просто грамотно обрабатываем микрозадачами. И вот как раз
[01:11:11.460 --> 01:11:19.580]  вот по созданию вот таких вот event loop плюс еще квантовости времени внутри центральных процессоров,
[01:11:19.580 --> 01:11:25.660]  как устроено центральный процессор, у нас на самом деле возникает у каждого потока кванты
[01:11:25.660 --> 01:11:30.220]  времени, в течение которых он выполняет какой-то процесс. После этого мы можем переключиться на
[01:11:30.220 --> 01:11:36.460]  другой поток, и он тоже будет выполнять процесс в определенный квант времени. И в итоге у нас
[01:11:36.460 --> 01:11:43.100]  возникает иллюзия многопоточной системы, иллюзия многозадачности. Хотя на самом деле мы работаем
[01:11:43.100 --> 01:11:50.340]  в одном ядре. Какие библиотеки позволяют реализовывать event loop? На самом деле их много,
[01:11:50.340 --> 01:11:56.020]  и они так или иначе работают. Первая из классических реализаций, это самый низкий уровень
[01:11:56.020 --> 01:12:05.700]  библиотека, это libUV для C++, она достаточно большая. Более того, веб-твишки в браузерах работают
[01:12:05.700 --> 01:12:14.900]  на libUV под капотом. Второе это Async.io, это библиотека для синхронного программирования в Python,
[01:12:14.900 --> 01:12:22.620]  и она тоже внутри себя создает event loop. И третье это Qt. В чем особенность Qt? В нем есть как раз
[01:12:22.620 --> 01:12:32.940]  события, они называют сигналы. Вы можете отправить какое-то событие и к этому сигналу привязать
[01:12:32.940 --> 01:12:37.860]  слот. То есть какая функция должна быть выполнена в другом объекте при наступлении определенного
[01:12:37.860 --> 01:12:45.740]  события. То есть реагировать на кнопки. На то, что кто-то нажал кнопку, на то, что кто-то закрыл окно,
[01:12:45.740 --> 01:12:52.900]  кто-то убрал фокус с определенной вкладки в браузере. В общем, это можно как раз реализовать
[01:12:52.900 --> 01:13:06.220]  при помощи таких библиотек. На самом деле вы с event loop встречаетесь достаточно часто. Даже вот
[01:13:06.220 --> 01:13:12.340]  сейчас есть какой-то event loop скорее всего, который нам позволяет получить информацию. Так, давайте
[01:13:12.340 --> 01:13:19.900]  вопрос по вот этому слайду. Опять же понятно, что это больше части на будущее, затравка. Но в целом
[01:13:19.900 --> 01:13:27.620]  вы теперь понимаете, что если вам нужно реал тайм-игру реализовать, то вам сюда. Поэтому мы не
[01:13:27.620 --> 01:13:38.180]  требовали реализовать real-time-игры, потому что это сложно. Хорошо. Значит, собственно, в чем у нас
[01:13:38.180 --> 01:13:43.100]  отличаются реактивные событийные программирования? Реактивное программирование обычно работает на
[01:13:43.100 --> 01:13:52.700]  изменения данных, событийные на на обработку каких-то созданных событий. В нем отличие. Теперь давайте,
[01:13:52.700 --> 01:13:58.100]  это все, что касается парадигмопрограммирования. Давайте перейдем немножко к другим аспектам
[01:13:58.100 --> 01:14:03.380]  языков программирования. Вкратце их вспомним. Как раз на 10 минут. Значит, у нас есть компиляция и
[01:14:03.380 --> 01:14:22.820]  интерпретация. Кто может сказать, что такое компиляция? У кого есть какие мысли? Да, это это
[01:14:22.820 --> 01:14:31.620]  частное определение. На самом деле, если говорить честно, то с одной точки зрения, компилятор это
[01:14:31.620 --> 01:14:39.180]  язык, который транслирует наш текст в другой язык. Зачастую это машинный код, но при этом это может
[01:14:39.180 --> 01:14:44.700]  быть произвольный язык программирования. То есть оно может трансформировать код из одного языка
[01:14:44.700 --> 01:14:52.260]  программирования в другой. Примером того является TypeScript, который трансформирует наш код из TypeScript
[01:14:52.260 --> 01:15:01.380]  в JavaScript. При этом у нас могут быть трансляции именно в машинный код, в какие части машинного кода
[01:15:01.380 --> 01:15:09.540]  это может быть. Это может быть либо, собственно, исполняемый уже файл. Давайте вспомним языки
[01:15:09.540 --> 01:15:18.340]  программирования, которые транслируют все в исполняемый файл. В машинный код именно. C, C++, Go.
[01:15:18.340 --> 01:15:35.000]  Нет, Java не исполняемый файл транслирует. Ну окей. А есть еще промежуточная вещь. У нас есть как
[01:15:35.000 --> 01:15:44.900]  раз виртуальная машина, в которой мы выполняем наши действия. Это как раз Java. Что касается других
[01:15:44.900 --> 01:15:50.180]  языков? Это интерпретируемый язык. Интерпетатор выполняет команды текста программы по очереди.
[01:15:50.180 --> 01:15:59.220]  То есть мы как раз задаем инструкции и дальше мы задаем инструкции, которые мы выполняем по очереди.
[01:15:59.220 --> 01:16:05.300]  Важно сказать, что иногда мы можем использовать не чистую интерпретацию, а мы можем использовать
[01:16:05.300 --> 01:16:12.540]  трансляцию в промежуточное исполнение, в bytecode. И дальше интерпретировать этот bytecode. Таким
[01:16:12.540 --> 01:16:26.660]  образом работает Python, допустим. В третьем точно уже было. Модуль дезассомблирования там появился.
[01:16:26.660 --> 01:16:35.100]  Вот, значит здесь как раз есть пример того, как это все работает. То есть компилируемые языки это
[01:16:35.100 --> 01:16:42.980]  CC++, Pascal, Go. Она трансформирует машинный код в Java, Scala, Kotlin, C Sharp. Сразу скажу, что Scala,
[01:16:42.980 --> 01:16:52.220]  Kotlin и Java это одного поля ягода. Они транслируют JVM. C Sharp тоже на самом деле транслирует это в
[01:16:52.220 --> 01:17:00.900]  виртуальную машину Винды. Интерпретируемые языки это Python и JavaScript. Они являются интерпретируемыми
[01:17:00.900 --> 01:17:05.380]  по сути. А есть языки программирования, которые являются хитрыми. Они могут работать как в
[01:17:05.380 --> 01:17:12.020]  интерпретируемой основе, так и в компилируемой основе. Если мы говорим про язык Basic, то в нем так
[01:17:12.020 --> 01:17:20.020]  это происходит. А в языке R происходит чудеса. В общем в чем заключаются чудеса? В нем есть два
[01:17:20.020 --> 01:17:27.780]  факта. Первое это сборка пакетов. Вы устанавливаете какой-то пакет. А второе это вы запускаете какой-то
[01:17:27.780 --> 01:17:35.060]  код. Так вот, когда вы запускаете какой-то код, вы его интерпретируете. А когда вы собираете
[01:17:35.060 --> 01:17:42.260]  проект какой-то, когда вы собираете ваши функции, набор в отдельную библиотеку, вы компилируете
[01:17:42.260 --> 01:17:59.980]  эту библиотеку. Причем компилируете C с примочками. Когда вы делаете компиляцию, то есть когда вам
[01:17:59.980 --> 01:18:04.420]  нужно запустить какой-то код на R, вы не можете пройтись с дебаггером в определенное место точку
[01:18:04.420 --> 01:18:09.180]  проекта. То есть вам нужно включать как раз дебагг ключи для того, чтобы собрать этот проект.
[01:18:09.180 --> 01:18:17.700]  Вот, ну R это вообще замечательный язык. Давайте сейчас время останется, я про него немножко
[01:18:17.700 --> 01:18:29.300]  порассказываю. Какой? Ну по факту да. Ну просто у нас последуются инструкции, которые нам надо
[01:18:29.300 --> 01:18:38.420]  выполнять. Вот. Так, хорошо. Про языки программирования я думаю понятно. Дальше,
[01:18:38.420 --> 01:18:45.340]  какая типизация существует? Статическая и динамическая. Статический тип переменной я известен
[01:18:45.340 --> 01:18:50.820]  до момента выполнения программы. Вот, динамическая тип переменной определяется по ходу выполнения
[01:18:50.820 --> 01:19:00.220]  программы. Вот. И как раз мы говорим следующее, что, собственно, давайте приведем примеры языков
[01:19:00.220 --> 01:19:11.980]  со статической и динамической. Да, много языков статической типизации. Да, а с динамической
[01:19:11.980 --> 01:19:30.700]  типизации? Ну скорее даже джовескрип. Питоне у нас. Ну да, да, да. Все, да, согласен, что Питон 4,
[01:19:30.700 --> 01:19:38.460]  который неизвестно будет еще или нет. Но в принципе Питон можно превратить как раз в статический язык,
[01:19:38.460 --> 01:19:45.220]  по большей части. По-моему, Никифор нам в чате присылал код на Пайдантик написанный. Вот,
[01:19:45.220 --> 01:19:49.820]  Пайдантик как раз включает статическую типизацию, когда он этот скрапер вариантов контрольной
[01:19:49.820 --> 01:19:57.620]  прислал. Ой, скрапер результатов работы написал. Вот. И есть еще одна интересная вещь, это сильная
[01:19:57.620 --> 01:20:04.580]  строгая типизация и слабая типизация. Значит, сильная типизация это мы берем a равно 5, b равно
[01:20:04.580 --> 01:20:09.460]  name и дальше a присваиваем значение b, получаем ошибку, потому что у нас тип переменной уже
[01:20:09.460 --> 01:20:15.380]  известен и мы его не можем конвертировать. А слабая типизация это a равно 5, b равно name,
[01:20:15.380 --> 01:20:24.540]  складываем a плюс b, получаем 5 name. Давайте попробуем привести языки с слабой типизации. Да,
[01:20:24.540 --> 01:20:33.700]  это и есть джовескрипт. То есть он неявно умеет кастовать типа. Опять же, тут надо посмотреть,
[01:20:33.700 --> 01:20:42.100]  какие у нас в языке реально могут быть, так сказать, отголоски с точки зрения слабой типизации,
[01:20:42.100 --> 01:20:48.060]  но они там обычно ограничены каким-то свойствам. То есть нам нужно переопределять операторы,
[01:20:48.060 --> 01:20:58.340]  которые позволят нам менять эту типизацию. Так, это по-моему. А, вот еще последнее есть,
[01:20:58.340 --> 01:21:05.660]  явная типизация и неявная типизация. Мы в C++ устанавливаем определенные значения,
[01:21:05.660 --> 01:21:11.700]  и у нас видно, что явно, что тип переменной a это типа int. Есть неявная типизация, это Python,
[01:21:11.700 --> 01:21:19.260]  где можно написать a двоеточие float или string равно 5, и при этом у нас типы не будут соблюдаться.
[01:21:19.260 --> 01:21:27.740]  Так, это, кажется, конец презентации. Что? Расскажите вам немножко про Rast. Ой, про R.
[01:21:27.740 --> 01:21:34.820]  Ну, про Rast, к сожалению, не расскажу, но про R расскажу. Это вообще чудо-язык в кавычках.
[01:21:34.820 --> 01:21:47.740]  Байк стоит в том, как вы привыкли обращаться к переменным. Точнее, к полям и методам класса.
[01:21:47.740 --> 01:21:59.860]  Точкой, да, то есть это ключевое слово. Я не знаю, почему, но если какой-то человек увидит код на R,
[01:21:59.860 --> 01:22:17.780]  он скажет, что он всячески нарушает закон Demetri. Почему? Закон Demetri. Это на первой лекции,
[01:22:17.780 --> 01:22:22.300]  когда мы говорили, что a является другом b, b является другом c, значит a не является другом c.
[01:22:30.060 --> 01:22:53.660]  Смотрите, вот такой код. Как мы это прочитали в языке c++, c и c++ и так далее? У нас есть экземпляр
[01:22:53.740 --> 01:23:12.140]  foo. Дальше у него есть volle var, volle van. Ну да, это мы так прочитали в c++. Var это читается как
[01:23:12.140 --> 01:23:22.340]  переменная, которая имя foo.var.van.front. Это просто кардинально нарушает концепцию других языков
[01:23:22.580 --> 01:23:34.100]  программирования. И здесь еще есть одна важная вещь, что в языке R это надо писать вот так.
[01:23:34.100 --> 01:23:54.460]  Ну не знаю. Специфика, так сказать. Вот какая еще есть специфика в языках? Ну, в принципе,
[01:23:54.460 --> 01:24:03.700]  она тоже бывает. В современных языках можно создавать иммутабельные объекты. В разных
[01:24:03.700 --> 01:24:09.620]  языках, если мы говорим про те объекты, которые не меняются, и если мы ставим значение, по факту мы
[01:24:09.620 --> 01:24:16.660]  перезатираем объект, бывает иммутабельный объект. Смотрите, если мы говорим про R, то там есть два
[01:24:16.660 --> 01:24:24.740]  оператора, равно и стрелочка. Собственно, равно создает иммутабельный объект, стрелочка создает
[01:24:24.740 --> 01:24:31.540]  иммутабельный объект. И в других языках тоже есть такие именно объекты. То есть обычно они
[01:24:31.540 --> 01:24:39.780]  дают модификатор const. То есть если мы говорим про JavaScript, то там есть led, есть const, а есть var.
[01:24:39.780 --> 01:24:47.740]  Значит, что делает var? Var создает глобальную переменную, led создает локальную переменную,
[01:24:47.740 --> 01:24:52.580]  а const создает константу, которая в дальнейшем меняться не может. То есть, а здесь именно нету
[01:24:52.580 --> 01:24:57.660]  возможности создать иммутабельного объекта, который мы можем переписать var. Это есть возможность.
[01:25:01.540 --> 01:25:10.980]  Мощно. Собственно, давайте просуммируем. Я рассказал про языки программирования, некоторые
[01:25:10.980 --> 01:25:16.780]  вводные вещи. Понятно, что в этой стезе можно развиваться, можно даже записать компиляторы.
[01:25:16.780 --> 01:25:25.480]  Значит, что у нас будет в следующий раз? В следующий раз у нас по фактическому расписанию будет
[01:25:25.480 --> 01:25:34.600]  контрольная. Возможно, я предзапишу какую-нибудь лекцию интересную, уже связанную с, так сказать,
[01:25:34.600 --> 01:25:41.880]  какими-то более крутыми особенностями, которые мы не можем рассмотреть. А не забываем, что 15
[01:25:41.880 --> 01:25:52.560]  мая все-таки лекция будет, но она будет дополнительной. Постараемся сделать. Ну,
[01:25:52.560 --> 01:25:55.280]  я думаю, на этом все. Если вопросов есть, то задавайте.
