[00:00.000 --> 00:20.000]  Всем доброго дня. Сегодня мы продолжаем с вами говорить про алгоритмы. В прошлый раз у нас с вами был алгоритм RL, который мы с вами доказали уже.
[00:20.000 --> 00:30.000]  Я снимал еще дополнительную лекцию 9,75, в которой я еще более детально пояснил все аспекты доказательства.
[00:30.000 --> 00:40.000]  Это лекция на YouTube. Я скидывал запись с 40 минут, где-то с чем-то она длится, но я там детальнее именно старался все рассказать.
[00:40.000 --> 00:55.000]  Сегодня мы с вами поговорим про продвижение этого алгоритма, но немного зайдем с другой стороны и поймем, как алгоритм RL можно оптимизировать, но не для всех громадь, к сожалению.
[00:55.000 --> 01:08.000]  Я не знаю, сколько у нас получится эта тема. Эта тема, возможно, нам дастся за одну лекцию, но я не уверен, сильно не уверен.
[01:08.000 --> 01:17.000]  В большей степени я уверен, что она нам дастся за полторы лекции, ну а давайте апприксимативную оценку дам, что мы будем не сидеть две лекции.
[01:17.000 --> 01:30.000]  Сегодня я дам мотивацию, какие-то базовые примеры, а на следующей лекции мы уже с вами будем продолжать доказательства всех фактов, потому что там есть очень много всяких неприятных вещей, которые по дороге нам придется доказать.
[01:30.000 --> 01:44.000]  Вот, давайте вспоминать, что мы в прошлых сериях сделали. В прошлых сериях, совсем-совсем давно, мы с вами построили MP-автоматы, и в предыдущих сериях мы с вами рассматривали алгоритм RL.
[01:44.000 --> 01:54.000]  Сейчас давайте попробуем эти две абстракции немножечко соединить. Да, то есть с MP-автоматом мы возьмем с вами стэк, а с алгоритмом RL мы возьмем понятие ситуации.
[01:54.000 --> 02:03.000]  И давайте посмотрим в следующем. В чем же у нас состоит проблема алгоритма RL?
[02:04.000 --> 02:08.000]  Мы тоже в куларах обсуждали, но давайте повторим еще раз.
[02:26.000 --> 02:30.000]  Из-за чего у нас сложность? Кубическая получается или квадратичная?
[02:34.000 --> 02:36.000]  Из-за complete?
[02:36.000 --> 02:47.000]  Да, операция complete на самом деле стоит очень много операции, потому что мы для каждой буквы должны сделать O от длины слова в квадрате действия.
[02:47.000 --> 03:00.000]  То есть нам нужно для того, чтобы сдвинуть точку, напоминаю, что такое complete, это мы берем снизу дерева разбора, закрываем дерево разбора.
[03:00.000 --> 03:08.000]  То есть для того, чтобы нам сдвинуть точку вне терминала, нам надо обойти все дерево целиком.
[03:08.000 --> 03:14.000]  И чтобы эту состыковку сделать, нам нужен квадрат действий. И это только для одного символа.
[03:14.000 --> 03:22.000]  Хотелось бы идеологически сделать так, чтобы мы эту точку могли просто просвеснуть, пройти и все.
[03:22.000 --> 03:29.000]  Чтобы у нас это все стало за линейное время работать, пришло бы линейное время в сумме.
[03:29.000 --> 03:36.000]  А давайте подумаем. Вот наша цель сегодня ответить на вопрос, а можем ли мы это делать прямо сразу.
[03:36.000 --> 03:43.000]  Оказывается, что да, это можно сделать, но не для всех грамматик.
[03:43.000 --> 03:49.000]  Сейчас мы с вами будем рассматривать грамматики, которые являются однозначными.
[03:49.000 --> 04:01.000]  На самом деле из хода будущего алгоритма будет понятно, что все грамматики, которые возможны при рассмотрении алгоритма, которые у нас сегодня будут, они будут однозначными.
[04:01.000 --> 04:04.000]  Это факт будет доказываться не очень сложным образом.
[04:04.000 --> 04:12.000]  Итак, давайте мы с вами сейчас в качестве примера разберем вот такую вот грамматику.
[04:13.000 --> 04:23.000]  Опять же, каждый раз мы с вами добавляем правила в грамматике к алгоритме early, правила s's добавляем.
[04:23.000 --> 04:31.000]  И давайте сделаем два правила. Первое правило, это из s следует ab, а второе правило, из b следует b.
[04:31.000 --> 04:36.000]  Понятно, что эта грамматика разбирает только одно слово, и это слово ab.
[04:36.000 --> 04:45.000]  Давайте мы сделаем следующую вещь. Давайте мы попытаемся эту штуку рассмотреть жадным образом.
[04:45.000 --> 04:59.000]  Что значит жадным образом? Это значит, как только мы увидели какое-то правило разбора, мы сразу схлапываем вверх, то есть поднимаемся наверх пони терминал.
[04:59.000 --> 05:06.000]  Вот смотрите, давайте как раз вот пример, который у нас есть. У нас слово v равно ab, и будем хранить стэк.
[05:06.000 --> 05:18.000]  Специальный стэк, в котором мы потом сможем быстро доставать и заменять правую часть правила грамматики на левую часть правила грамматики.
[05:18.000 --> 05:38.000]  Вот смотрите, вот у нас слово с вами ab, а грамматика такая, давайте ее перепишу, чтобы она была s's, из s следует ab, а из b следует b.
[05:38.000 --> 05:47.000]  Давайте мы с вами будем строить дерево, я параллельно тут расскажу тоже. Вот смотрите. И храним стэк.
[05:47.000 --> 05:56.000]  То есть стэк из текущих символов, которые... А, что такое однозначная грамматика? Напомню определение.
[05:56.000 --> 06:12.000]  Это грамматика, в которой для любого слова существует ровно одно дерево разбора. То есть никаких других деревьев разбора появиться не может.
[06:12.000 --> 06:22.000]  Ну и смотрите, давайте анализировать. Как мы будем делать? У нас есть слово... Сначала мы находимся здесь.
[06:23.000 --> 06:38.000]  Следующий символ a. Давайте анализировать, есть ли у нас с вами правило, у которого правая часть является a. Состоит из одного символа a.
[06:38.000 --> 07:03.000]  Но кажется, таких нет. Если что, я ожидал вашего ответа. Когда я делаю паузу, желательно отвечать, а не сидеть в экране смотреть просто.
[07:03.000 --> 07:13.000]  Смотрите, у нас такого правила нету, поэтому мы берем... Что делаем? Мы двигаем букву a на стэк, а точку перемещаем вот сюда.
[07:16.000 --> 07:28.000]  Следующая буква b. Опять же, смотрите, здесь история такая. На стэке... Смотрим, что на стэке у нас с вами.
[07:28.000 --> 07:36.000]  Можем ли мы свернуть сейчас то, что находится по стэке, как правое часть правила? Нет. Поэтому мы берем и добавляем b в стэк.
[07:37.000 --> 07:45.000]  Вот смотрите, а тут, наверное, по карту. Да, вот добавляем b в стэк. Двигаем точку вот сюда.
[07:45.000 --> 07:57.000]  Давайте посмотрим теперь на стэк. Следующего символа у нас нет. Давайте скажем следующий символ от конца строки.
[07:57.000 --> 08:07.000]  Скажите, на стэке сейчас есть правая часть какого-то правила?
[08:07.000 --> 08:23.000]  Да, смотрите, у нас есть sb в b. Давайте сделаем следующее. Мы выкидываем этот b со стэка и добавляем левую часть правила на стэк.
[08:24.000 --> 08:33.000]  То есть мы заменяем sb с b. И мы делаем настройку с вами по этому правилу грамматики. Точка при этом переезжает сюда.
[08:34.000 --> 08:44.000]  Да, идея такая. Видим правую часть правила, заменяем на стэке ее левую часть. Вот смотрите, у нас появляется b.
[08:44.000 --> 08:57.000]  Так, теперь, если у нас на стэке правая часть правила. Да, смотрите, вот у нас ab это правая часть правила.
[08:58.000 --> 09:05.000]  Поэтому заменяем на стэке левую часть правила s. А здесь у нас получается вот такая штучка.
[09:05.000 --> 09:15.000]  Точка поднимается сюда. Точка напоминает текущую позицию условия. Вот, получается такая вещь.
[09:15.000 --> 09:21.000]  И, есть ли еще на стэке правая часть правила?
[09:30.000 --> 09:38.000]  Ну, есть, конечно же, еще s' в s есть. Ну, смотрите, давайте мы тоже ее выкидываем. И в итоге смотрите, что у нас получается.
[09:38.000 --> 09:48.000]  У нас на стэке с вами находится s'. Да, и мы дошли до конца слова. Это значит, что мы построили с вами дерево разбора грамматики.
[09:49.000 --> 10:04.000]  Причем, важно подчеркнуть очень важную вещь. Она заключается в том, что если мы идем слово слева направо, то грамматика разбирается справа налево.
[10:04.000 --> 10:08.000]  То есть, вывод в грамматике у нас правосторонний.
[10:21.000 --> 10:31.000]  Потому что мы раскрываем самый правый не терминал. Да, то есть, мы с вами понимаем, что если бы...
[10:31.000 --> 10:39.000]  Ну, тут надо был бы пример, на самом деле. Давайте абстрактно представим, что у нас было какое-то s, потом было bc.
[10:40.000 --> 10:48.000]  Там, я не знаю, b раскрывалась в какое-нибудь ab, а c раскрывалась в c маленькое.
[10:49.000 --> 10:57.000]  Да, давайте поймем, почему у нас в первом раскроется не терминал именно вот этот вот.
[11:00.000 --> 11:11.000]  Ну, тут, на самом деле, это как можно понять? Мы можем понять, что вот этот не терминал у нас появляется только в самом последнем случае.
[11:11.000 --> 11:21.000]  То есть, у нас получается ab заменится на b, да, потом c заменится на c, да, эти моменты времени проста.
[11:22.000 --> 11:31.000]  То есть, это первая замена будет, это вторая замена будет, а вот эта замена будет третья, которая поставит символ s совместно.
[11:32.000 --> 11:48.000]  Теперь отмотаем моменты времени назад. Да, то есть, это, считайте, у нас временная шкала была снизу вверх, но когда мы пойдем во временную шкалу сверху вниз, то нам эти чиселки надо будет расставить по убыванию.
[11:48.000 --> 12:09.000]  Нам надо будет эти чиселки расставить по убыванию, поэтому вот эта штучка раскроется первой, потом вот этот не терминал c раскроется вторым, а вот этот не терминал b раскроется третьим.
[12:09.000 --> 12:17.000]  Поэтому у нас вывод грамматики, который мы будем строить таким жадным образом, он является правосторонним.
[12:18.000 --> 12:25.000]  Да, с другой стороны в алгоритм нерли мы строили с вами левосторонний вывод грамматики, потому что мы шли сверху вниз.
[12:26.000 --> 12:34.000]  И тут давайте я введу некоторую классификацию, которую я не ввел на презентации. Есть два типа парсеров.
[12:38.000 --> 12:46.000]  Есть поп-даун парсеры, которые идут и анализируют дерево разбора сверху вниз.
[12:50.000 --> 12:54.000]  И к примеру, таких парсеров относятся алгоритм нерли.
[12:56.000 --> 13:07.000]  Ну, с какой-то степени в кавычках. Есть еще один тип парсеров, мы его не будем рассматривать на лекции, он называется ll парсеры, которые пытаются сделать следующую вещь.
[13:08.000 --> 13:11.000]  Давайте рекурсивно попытаемся раскрывать дерево разбора.
[13:12.000 --> 13:19.000]  А в нашем случае мы сегодня рассматриваем bottom-up парсеры, то есть которые идут снизу вверх.
[13:20.000 --> 13:30.000]  И пример такого парсера это lr алгоритм, но пока что мы находимся в базовом приближении этого алгоритма.
[13:31.000 --> 13:37.000]  Так, пример понятен, который я вот тут рассказал.
[13:37.000 --> 13:47.000]  Итак, и теперь смотрите, как мы наш алгоритм можем преобразовать.
[13:48.000 --> 13:52.000]  Он на самом деле называется алгоритм переноса свертка или shift-reduce.
[13:53.000 --> 13:58.000]  И мы по сути делаем две вещи. Первый, на вершине стека написана правая часть какого-то правила.
[13:59.000 --> 14:02.000]  Мы заменяем его на левую часть правила, осуществляем операцию reduce.
[14:02.000 --> 14:11.000]  Если нет, то мы добавляем символ в стек, то есть мы осуществляем операцию shift с вами.
[14:12.000 --> 14:25.000]  Вопрос. Какие проблемы у нас могут возникнуть с вами в реализации вот этого алгоритма?
[14:32.000 --> 14:46.000]  Может же быть такое, что какое-то дерево разбора, оно не является деревом разбора?
[14:47.000 --> 14:49.000]  Ну да.
[14:50.000 --> 14:52.000]  У нас не очистится стек и мы ничего не сможем сделать.
[14:53.000 --> 14:58.000]  Нет, ну тогда можно сказать, ну проиграли. Но это хорошее.
[14:58.000 --> 15:03.000]  Может он недетерминированный?
[15:04.000 --> 15:08.000]  Да, во-первых, он сильно недетерминированный. Вот вопрос.
[15:09.000 --> 15:13.000]  А что делать? Тут есть две проблемы.
[15:14.000 --> 15:18.000]  Первая проблема, а как понять, какая правая часть правила у нас находится на стеке?
[15:19.000 --> 15:24.000]  Потому что у нас там по сути нам нужно делать откат на несколько символов назад.
[15:24.000 --> 15:28.000]  И пытаться как-то эту штуку проанализировать. Это раз?
[15:29.000 --> 15:32.000]  Подождите, это же решает алгоритм Аха-Карасика?
[15:33.000 --> 15:49.000]  Ну, это да. Поскольку это первая у нас аппроксимация этого алгоритма, ну решим мы ее Аха-Карасикой, но на самом деле этот алгоритм применим к очень узкому количеству грамматик.
[15:49.000 --> 15:53.000]  И есть еще одна проблема, которая важная.
[15:54.000 --> 15:57.000]  А что делать, если вдруг у нас таких правил несколько?
[15:58.000 --> 16:05.000]  Да, то есть мы дошли до какой-то части стека, и в стеке у нас есть две правых части правил.
[16:09.000 --> 16:11.000]  Что делать будем?
[16:11.000 --> 16:13.000]  Ну, непонятно, что делать.
[16:14.000 --> 16:19.000]  Смотрите, давайте скажем сразу, что с этим мы ничего делать не будем.
[16:20.000 --> 16:24.000]  Мы просто скажем, что для такой грамматики, к сожалению, наш алгоритм не работает.
[16:25.000 --> 16:28.000]  И при этом сильно сузим класс, появляющий грамматик.
[16:29.000 --> 16:35.000]  А вот здесь давайте мы на самом деле проанализируем, в каких ситуациях мы с вами проанализируем.
[16:35.000 --> 16:41.000]  Итак, давайте переложим эту абстракцию дерева на то, что у нас с вами происходит.
[16:42.000 --> 16:44.000]  Я попытаюсь нарисовать на том же самом дереве разбора.
[16:45.000 --> 16:47.000]  Вспоминаем, что такое у нас была ситуация.
[16:48.000 --> 16:54.000]  Ситуация, это у нас было какое-то правило грамматики из А следует Альфа точка Бета.
[16:55.000 --> 16:57.000]  И мы ставили точку, вытягивая эту точку.
[16:57.000 --> 17:02.000]  Итак, ну и давайте теперь посмотрим, в каких ситуациях на самом деле мы с вами были.
[17:03.000 --> 17:06.000]  В тот момент времени, когда мы стартовали.
[17:07.000 --> 17:09.000]  Давайте я поставлю таймстемпы.
[17:12.000 --> 17:15.000]  Давайте я скопирую все-таки эту грамматику, чтобы...
[17:16.000 --> 17:18.000]  ...давайте я поставлю таймстемпы.
[17:18.000 --> 17:28.000]  Давайте я скопирую все-таки эту грамматику, чтобы деревья вывода, чтобы это у нас с вами не мешало нашей постановке.
[17:31.000 --> 17:32.000]  Так, давайте вот сюда.
[17:33.000 --> 17:34.000]  И скопируем вот сюда.
[17:35.000 --> 17:37.000]  Итак, давайте анализировать.
[17:37.000 --> 17:38.000]  И скопируем вот сюда.
[17:39.000 --> 17:41.000]  Итак, давайте анализировать.
[17:42.000 --> 18:00.000]  В момент времени, который он был в начале, в начальный момент, мы давайте вместо того, чтобы пропихивать точку здесь, давайте посмотрим все ситуации, которые у нас сохраняет эту точку.
[18:01.000 --> 18:03.000]  Как мы это можем сделать?
[18:03.000 --> 18:08.000]  Давайте мы сделаем операцию, обратную правилу, предикт.
[18:09.000 --> 18:10.000]  Напоминаю, что такое правило.
[18:11.000 --> 18:13.000]  Что у нас делает предикт, мы берем и заглядываем внутрь дерева разбора.
[18:14.000 --> 18:19.000]  Сейчас давайте гипотетически посмотрим, что произойдет, если мы с вами посмотрим вверх, в дереве разбора.
[18:21.000 --> 18:22.000]  Смотрите.
[18:23.000 --> 18:25.000]  Значит, изначально у нас в момент времени ноль.
[18:28.000 --> 18:29.000]  В момент времени ноль.
[18:30.000 --> 18:31.000]  У нас точка находилась здесь.
[18:32.000 --> 18:33.000]  Я сотру точки.
[18:34.000 --> 18:36.000]  Буду обозначать их с момента времени.
[18:37.000 --> 18:39.000]  Буду писать момент времени для точки.
[18:40.000 --> 18:41.000]  Эта точка была у нас в нулевой момент времени.
[18:42.000 --> 18:44.000]  Эта точка у нас тоже была в нулевой момент времени.
[18:45.000 --> 18:47.000]  И вот эта точка у нас тоже была в нулевой момент времени.
[18:48.000 --> 18:58.000]  В итоге в нулевой момент времени у нас правила, которые были, точнее ситуации которые были, это из и STEG стрелочка, вот это.
[18:58.000 --> 19:07.000]  И еще раз, спускаемся из стрелочка .AB. По сути сделали предикт.
[19:07.000 --> 19:15.000]  Только заметьте, что здесь у нас нет индексов, которые говорят, где в позиции слова мы находимся.
[19:15.000 --> 19:22.000]  Как раз, на самом деле, по секрету всему свету скажу, что именно хранение позиции занимало у нас квадрат времени.
[19:22.000 --> 19:25.000]  Это не очень эффективно.
[19:25.000 --> 19:31.000]  Теперь смотрите. В первый момент времени что мы можем сделать? Мы можем сдвинуть точку вот сюда.
[19:31.000 --> 19:33.000]  Раз.
[19:33.000 --> 19:40.000]  И после А у нас получается вот такая вот вещь, что С, стрелочка, А, точка B.
[19:40.000 --> 19:47.000]  Давайте я вот тут тоже апоксимативно построю это все. Здесь у нас ситуация тоже будет в первый момент времени.
[19:47.000 --> 19:52.000]  И после этого мы можем с вами сделать тот же самый предикт и опустить эту точку вниз.
[19:53.000 --> 19:58.000]  Получаем ситуацию B, стрелочка, точка B.
[20:01.000 --> 20:13.000]  И теперь во второй раз, когда мы делаем операцию shift, точнее сдвига буквы у нас, это будет второй момент времени.
[20:13.000 --> 20:17.000]  То есть на самом деле мы находимся в ситуации B, стрелочка, B, точка.
[20:22.000 --> 20:29.000]  Так, понятно ли по моментам времени, как мы получили эти ситуации?
[20:33.000 --> 20:36.000]  А может вопрос, почему у нас есть треугольник из единичек?
[20:36.000 --> 20:40.000]  На самом деле треугольник из единичек почему он возникает?
[20:40.000 --> 20:48.000]  Потому что если дерево построить не таким образом, а букву А поднять на один уровень, то на самом деле это будет одна и та же точка.
[20:49.000 --> 20:52.000]  А, да, точно.
[20:52.000 --> 20:55.000]  Да, я просто показал, что это одна и та же.
[20:55.000 --> 20:58.000]  И давайте посмотрим, как мы их получили.
[21:00.000 --> 21:07.000]  И тут самая гениальная идея, которая мы сейчас с вами сделаем продвинутым, наш алгоритм.
[21:07.000 --> 21:13.000]  Смотрите внимательнее. На самом деле, что такое операция предикт?
[21:18.000 --> 21:30.000]  Вот это самая нетривальная идея. Это на самом деле переход по Эпсилону.
[21:30.000 --> 21:40.000]  То есть чтобы раскрыть новые правила грамматики, нам нужно просто сдвинуться, прочитать пустое количество символов.
[21:40.000 --> 21:45.000]  То есть мы читаем пустое количество символов, переходим к этой точке.
[21:46.000 --> 21:54.000]  Значит, чтобы перейти, допустим, от ситуации вот этой к ситуации вот этой, нам надо прочитать букву Б.
[21:57.000 --> 22:00.000]  Да, то есть scan это переход по букве.
[22:05.000 --> 22:09.000]  А complete, как вы думаете, переход по какой букве?
[22:16.000 --> 22:18.000]  Не терминал.
[22:18.000 --> 22:23.000]  Да, это на самом деле будет переход по не терминалу, только он достаточно сложный.
[22:25.000 --> 22:33.000]  И на самом деле теперь мы с вами над множеством ситуаций можем построить недетерминированный конечный автомат.
[22:35.000 --> 22:37.000]  У нас все с вами готово.
[22:37.000 --> 22:46.000]  Итак, идея как раз этого алгоритма заключается в том, чтобы построить детерминированный конечный автомат над множеством ситуаций.
[22:46.000 --> 22:49.000]  А потом его как-то эффективно обходить.
[22:49.000 --> 22:52.000]  И смотрите, вот я построил его над множеством ситуаций.
[22:52.000 --> 23:01.000]  Итак, из С-С мы можем по Эпсилому перейти С с релочка точка АВ, потому что это операция с предиктом.
[23:01.000 --> 23:07.000]  Потом мы делаем переход по букве А, делаем переход вот таким вот, то есть точку сдвигаем.
[23:07.000 --> 23:10.000]  Дальше и происходит переход по букве Б.
[23:10.000 --> 23:13.000]  По не терминалу делаем такую вещь.
[23:13.000 --> 23:17.000]  Здесь ведет переход по Эпсилому, и здесь идет переход по Б.
[23:17.000 --> 23:22.000]  Давайте подумаем, как мы его можем детерминировать.
[23:22.000 --> 23:31.000]  При этом важно, в отличие от детерминирования, от классического автомата, что здесь все состояния необходимо сохранить.
[23:31.000 --> 23:43.000]  Что нам нужно вообще в классическом алгоритме построения НК сделать, построение ДК сделать?
[23:43.000 --> 23:50.000]  Можно смотреть два степени количества вершин, провести соответствующие рёбра.
[23:50.000 --> 23:57.000]  На самом деле ДФС сделать, либо ДФС, либо БФС по множеству состояний.
[23:57.000 --> 24:02.000]  Прежде чем мы это делаем, что нам надо сделать?
[24:02.000 --> 24:05.000]  Да, нам надо удалить Эпсилом переходы.
[24:05.000 --> 24:07.000]  Вспоминаем, как мы удаляем Эпсилом перехода.
[24:07.000 --> 24:22.600]  Мы берем состояние, этоái типа если мы в классическом
[24:22.600 --> 24:30.000]  алгоритме удалили Эпсилом переходы, то нам пришлось бы делать next, мы берем переход
[24:30.000 --> 24:35.000]  Мы берем переход по Epsilon, переход по A, стягиваем сюда переход по A делаем.
[24:35.000 --> 24:40.000]  Да, то есть строим традиционные замыкания. Здесь мы поступим немножечко иначе.
[24:40.000 --> 24:50.000]  Давайте для каждого состояния, при этом мы с вами будем, по сути, схлопывать все состояния в одно,
[24:50.000 --> 24:59.000]  из которого достижим Epsilon перехода. Да, то есть мы сделаем Epsilon замыкание.
[24:59.000 --> 25:04.000]  Сейчас давайте, чтобы было понятно, я поясню на примере.
[25:04.000 --> 25:14.000]  Вот смотрите, вот у нас было состояние из штриха .s и был Epsilon переход в s, a, b.
[25:14.000 --> 25:26.000]  Мы берем и с вами добавляем в это же состояние, состояние вида s, стрелочка .a, b.
[25:26.000 --> 25:35.000]  Потом из этого общего состояния мы делаем переход по букве A и пытаемся сдвинуть точку во всех переходах.
[25:35.000 --> 25:43.000]  Получаем s, стрелочка .a, .b. Причем здесь опять же у нас есть Epsilon переход,
[25:43.000 --> 25:48.000]  поэтому мы берем и притягиваем к себе ситуацию.
[25:48.000 --> 25:58.000]  Дальше у нас получается здесь есть переход по B, который делает B точка,
[25:58.000 --> 26:06.000]  а здесь у нас будет переход по B большой, из s выходит AB точка.
[26:06.000 --> 26:16.000]  Да, то есть вместо того, чтобы пропускать те состояния, которые мы приходили по Epsilon переходу,
[26:16.000 --> 26:24.000]  мы их наоборот притягиваем к себе. На самом деле притягивание к себе это тот же самый предикт.
[26:24.000 --> 26:32.000]  Можно вопрос? Вот у нас вкрой прямоугольник.
[26:32.000 --> 26:43.000]  А потому что мы пришли в это состояние, и потом из этого состояния по Epsilon переходу мы можем дойти сюда.
[26:43.000 --> 26:47.000]  То есть мы притягиваем все достижимые по Epsilon.
[26:47.000 --> 26:53.000]  То есть мы смотрим здесь уже для вот этого перехода, нам нужно дойти до этой ситуации,
[26:53.000 --> 26:57.000]  для этого состояния, ну поэтому давайте притянем их к себе.
[26:57.000 --> 27:05.000]  То есть по сути мы делаем предикты для всех возможных ситуаций в состоянии и добавляем его в текущее состояние.
[27:05.000 --> 27:11.000]  Вот такой вот автомат. Давайте разберем слово AB.
[27:11.000 --> 27:17.000]  Вот, тупик в автомате надо делать reduce, а какой делать бэктрек написано в правиле.
[27:17.000 --> 27:26.000]  Давайте разберу слово AB наше. Пусть это у нас состояние 0, это состояние 1, это состояние 2, это состояние 3.
[27:26.000 --> 27:37.000]  И на стеке мы будем хранить с вами путь вместо просто буквы KB, мы еще будем хранить путь в этом автомате.
[27:37.000 --> 27:43.000]  Давайте начнем. Значит, смотрите, здесь обычно строят такую табличку,
[27:43.000 --> 27:52.000]  в которой пишутся, какое слово осталось разобрать, какой у нас с вами стек и что мы делаем.
[27:56.000 --> 28:01.000]  Итак, слово у нас изначально AB.
[28:01.000 --> 28:05.000]  AB, давайте символ конца слова наберем.
[28:05.000 --> 28:10.000]  Дальше у нас в стек изначально кладется нулевое состояние.
[28:13.000 --> 28:21.000]  Смотрите, следующая буква A, поэтому что нам нужно сделать?
[28:21.000 --> 28:28.000]  Нам нужно сделать переход в состояние 1.
[28:28.000 --> 28:36.000]  При этом мы считаем, что мы эту букву прочитали с вами, а на стек кладем с вами вот такую вещь.
[28:36.000 --> 28:44.000]  Букву A и переход. И смотрите, что такое 0, A1, это по сути путь в текущем автомате от стартовой вершины.
[28:48.000 --> 28:54.000]  Дальше давайте, вот у нас стек 1, а следующая буква B, что мы должны сделать?
[28:54.000 --> 28:59.000]  Перейти, видимо, в тройку.
[28:59.000 --> 29:03.000]  Да, перейти в состояние тройку.
[29:03.000 --> 29:11.000]  Получаем 0, A1, B3, то есть добавляем состояние B, переходим в тройку.
[29:11.000 --> 29:16.000]  Дальше доллар, следующий символ доллар.
[29:16.000 --> 29:22.000]  Мы пришли в тупике, в тупик в автомате, но что у нас в этом тупике интересного есть?
[29:24.000 --> 29:30.000]  У нас на конце есть правило, правая часть правила.
[29:30.000 --> 29:35.000]  Правая часть правила, смотрите, в тупике всегда написано правая часть правила.
[29:35.000 --> 29:38.000]  Это мы еще с вами будем доказывать.
[29:38.000 --> 29:45.000]  Но тогда мы видим, что есть правило B, стрелочка B, значит надо сделать редьюс.
[29:45.000 --> 29:50.000]  Редьюс по правилам B, стрелочка B.
[29:51.000 --> 29:55.000]  И теперь смотрите, в чем прикол состоит.
[29:55.000 --> 29:58.000]  Мы зашли в тупик.
[29:58.000 --> 30:02.000]  Слышали ли вы про алгоритм бэктрекинга?
[30:06.000 --> 30:09.000]  То есть мы зашли с вами в тупик, нам что надо сделать?
[30:09.000 --> 30:13.000]  Нам надо взять, развернуться.
[30:13.000 --> 30:17.000]  И прежде чем смотреть, на стеке у нас хранится вот это вот B.
[30:17.000 --> 30:21.000]  Мы берем, возвращаемся наверх.
[30:21.000 --> 30:29.000]  По сути возвращение наверх, это значит, что мы с вами стираем со стека вот эту вот часть.
[30:29.000 --> 30:34.000]  И идем в правильное направление, то есть идем по букве B.
[30:34.000 --> 30:40.000]  В итоге у нас получается 0, 1, A, и B, а тут 2.
[30:40.000 --> 30:46.000]  То есть мы перестроили с вами путь, мы пошли сюда, пришли сюда.
[30:46.000 --> 30:49.000]  Дальше что делаем?
[30:52.000 --> 30:57.000]  А, давайте я тут еще один переход забыл нарисовать, давайте переход по S сделаем.
[30:58.000 --> 31:02.000]  Вот так вот. Это четвертое состояние.
[31:04.000 --> 31:07.000]  Так, что мы с вами делаем?
[31:07.000 --> 31:09.000]  Редюс.
[31:10.000 --> 31:14.000]  Редьюс при этом до какого состояния мы откатываемся с вами?
[31:16.000 --> 31:26.000]  Со стека, что мы с вами должны счистить при этом?
[31:26.000 --> 31:28.000]  A, B?
[31:28.000 --> 31:32.000]  Да, A, B счищается, а наверх кладется.
[31:35.000 --> 31:37.000]  Что?
[31:40.000 --> 31:42.000]  И?
[31:47.000 --> 31:50.000]  Из 0 по S мы куда переходим?
[31:53.000 --> 31:55.000]  В 4 состоянии.
[31:55.000 --> 32:01.000]  Да, в 4 состоянии. То есть видите, мы делаем бэктрек и идем в правильном направлении.
[32:02.000 --> 32:10.000]  И в итоге мы пришли в конец, потому что мы понимаем, что дальше надо свернуться по правилу S.
[32:10.000 --> 32:17.000]  Как хотите, тут можно сказать, что мы сразу слово принимаем или не принимаем его сразу.
[32:20.000 --> 32:30.000]  То есть видите, при помощи автомата на самом деле в стеке мы можем хранить не просто стек из текущих символов,
[32:30.000 --> 32:36.000]  но еще и текущий путь в автомате, а в каждом автомате в принципе мы уже понимаем какие переходы, куда ходить.
[32:36.000 --> 32:42.000]  Для каждого состояния, вообще для каждой буквы в детерминированном автомате мы можем просто написать действие, которое мы делаем.
[32:43.000 --> 32:53.000]  Да, то есть пришли в состояние 3, независимо от того, какой следующий символ у нас будет, мы должны с вами сделать операцию reduce.
[32:56.000 --> 32:58.000]  Если не получится?
[32:58.000 --> 33:02.000]  Ну если не получится, значит слово не лежит в языке с даваемой грамматикой.
[33:02.000 --> 33:04.000]  Все, сразу.
[33:06.000 --> 33:13.000]  Так, отлично. А теперь смотрите, давайте добавим в эту грамматику правила 1.
[33:13.000 --> 33:15.000]  Коварные.
[33:17.000 --> 33:21.000]  Если вот это понятно, то 1.
[33:25.000 --> 33:27.000]  Что это? 1?
[33:29.000 --> 33:31.000]  Я что-то не понимаю.
[33:31.000 --> 33:34.000]  Давайте добавим правило b, стрелочка bc.
[33:34.000 --> 33:36.000]  Грамантики.
[33:36.000 --> 33:40.000]  И тут вопрос состоит.
[33:40.000 --> 33:46.000]  Вот автомат строится точно таким же образом, детерминируется, да, переход по букве b.
[33:46.000 --> 33:49.000]  Вопрос, следующая буква c, что делать будем?
[33:49.000 --> 33:51.000]  Двигаться на следующую букву?
[33:51.000 --> 33:54.000]  Или откатываться по правилам b, стрелочка b.
[34:04.000 --> 34:07.000]  Откатываться, мы же вроде так в самом начале сказали.
[34:07.000 --> 34:10.000]  Да, отлично, если слово abc у нас.
[34:10.000 --> 34:16.000]  То есть у нас проблема в том, что у нас может быть два правила, два слова ab и abc.
[34:20.000 --> 34:23.000]  Для вот этого правила нам нужно сделать откат,
[34:23.000 --> 34:28.000]  а для вот этого правила, в этой ситуации нам нужно двинуть, прочитать букву c.
[34:28.000 --> 34:31.000]  То есть мы будем делать откат, мы не будем в тюрьму.
[34:31.000 --> 34:34.000]  А вот это правило, мы будем делать откат,
[34:34.000 --> 34:38.320]  нам нужно сделать откат, а для вот этого правила в этой ситуации нам нужно
[34:39.160 --> 34:42.160]  прочитать букву С.
[34:57.680 --> 35:02.680]  А, то есть, чего нам не хватает?
[35:03.680 --> 35:12.680]  Я не очень понял, в чем вопрос. Ведь, если у нас было слово ABC, и мы пришли вот в красное состояние, то
[35:12.680 --> 35:23.680]  мы в любом случае можем пройти, попробовать дальше. А если не получится, то мы откатом сможем все восстановить, нет?
[35:23.680 --> 35:38.680]  Нет, но тут история в том, что откаты у нас удобны, если мы зашли в тупик, и мы знаем, по какому правилу уже откатываться.
[35:38.680 --> 35:49.680]  А здесь у нас получается разветление алгоритма. То есть, там всегда, замечу, что в том алгоритме мы всегда, как только приходили в точку, у нас есть ровно одно правило.
[35:50.680 --> 36:03.680]  А если мы заранее, тут история такая, либо мы начнем двигаться сразу, и тогда мы прочитаем что-то лишнее, либо мы сделаем откат.
[36:03.680 --> 36:12.680]  То есть, у нас появляются две развилки, и на самом деле, количество таких развилок может быть экспоненциально большим.
[36:12.680 --> 36:19.680]  Из-за этого сложность алгоритма уже будет нелинейной, к которой мы стремимся, а экспоненциальной.
[36:22.680 --> 36:27.680]  Да, потому что у нас появилась развилка, а мы не хотим делать таких развилок.
[36:27.680 --> 36:44.680]  Давайте подумаем, что мы не учили вот здесь вот, но что мы уже с вами проговорили при этом.
[36:53.680 --> 36:55.680]  Нужно детерминировать?
[36:55.680 --> 36:58.680]  Нет, ну, мы вроде бы детерминировали.
[36:58.680 --> 37:03.680]  Ну, смотрите, у нас что получается. На самом деле, мы можем сделать if.
[37:03.680 --> 37:08.680]  If следующая буква C, то, пожалуйста, ее прочти.
[37:08.680 --> 37:10.680]  Значит, нам нужно сделать переход сюда.
[37:10.680 --> 37:14.680]  Иначе сделай откат.
[37:15.680 --> 37:28.680]  То есть, тут главная идея, что если мы в ситуацию зашьем, какая будет следующая буква, то мы сможем разрешить эту проблему.
[37:29.680 --> 37:34.680]  Поэтому давайте сделаем следующую вещь.
[37:34.680 --> 37:40.680]  Мы сделаем с вами вот, ведем понятие вот такой ситуации.
[37:40.680 --> 37:45.680]  А, стрелочка, альфа точка бета, запятая C.
[37:45.680 --> 37:47.680]  Причем, что эта C нам будет говорить?
[37:47.680 --> 37:54.680]  Она нам будет говорить, что если мы находимся в состоянии альфа, который вводит альфа точка бета,
[37:54.680 --> 37:58.680]  то следующий символ, который мы с вами можем вывести, это C.
[37:58.680 --> 38:03.680]  Первая буква из того, что мы можем вывести дальше.
[38:12.680 --> 38:18.680]  И тогда, смотрите, у нас вот эта ситуация на самом деле разобьется на две части.
[38:19.680 --> 38:27.680]  Да, то есть, тут вот ситуация будет конец слова, а здесь ситуация будет немножечко другая.
[38:27.680 --> 38:30.680]  Ну, давайте сейчас сделаем небольшой перерыв.
[38:30.680 --> 38:33.680]  Минуток на 5.
[38:33.680 --> 38:40.680]  А дальше посмотрим, как эту штуку можно конструировать на более продвинутом примере.
[38:40.680 --> 38:49.680]  Если можно вопрос, если бы мы в красную блок добавили еще из B, следует B точка D,
[38:49.680 --> 38:55.680]  то мы тогда могли прочитать и букву C, и букву D.
[38:55.680 --> 39:01.680]  Ну да, там вообще непонятно было, там бы вообще бы развилка.
[39:01.680 --> 39:07.680]  Либо свернись, либо у тебя буква D, значит ты идешь под букву D, либо у тебя буква C.
[39:07.680 --> 39:10.680]  Мы для такой штуки две ситуации получается добавляем?
[39:10.680 --> 39:16.680]  Да, на самом деле мы вот сейчас, давайте как раз после перерыва, перестроим автомат над этим множеством ситуаций
[39:16.680 --> 39:19.680]  и поймем, что там происходит.
[39:25.680 --> 39:31.680]  Итак, давайте продолжать, попытаемся разрешить проблему, которая у нас возникла здесь.
[39:31.680 --> 39:36.680]  Значит, как мы сказали, нам нужно делать просмотр на одну букву вперед.
[39:36.680 --> 39:45.680]  И на самом деле семейство алгоритмов LR, оно обычно говорится, что это семейство алгоритмов LRK,
[39:45.680 --> 39:49.680]  где K это количество букв, которые мы будем с вами просматривать вперед.
[39:49.680 --> 39:53.680]  На самом деле мы сейчас построили с вами алгоритм перенос свертка,
[39:53.680 --> 40:01.680]  или в другой абстракции он называется LR0 алгоритм, потому что мы не используем информацию для просмотра на 0 букв вперед.
[40:01.680 --> 40:04.680]  И давайте рассмотрим перенос на одну букву вперед.
[40:04.680 --> 40:11.680]  И я сейчас немножко вам попытаюсь на примере сначала показать, как преобразуется вот эта вот грамматика.
[40:11.680 --> 40:22.680]  И дальше мы перейдем с вами к формулировке, к формальным определениям, чтобы у нас с вами все это зафиксировано.
[40:22.680 --> 40:27.680]  Итак, все начинается с следующего состояния.
[40:27.680 --> 40:29.680]  Разблокируйся.
[40:31.680 --> 40:36.680]  Вот с такого.
[40:36.680 --> 40:40.680]  Значит, опять же, рассматриваем грамматику, мы с вами вот такую.
[40:40.680 --> 40:45.680]  S-трих.s-s-a-b.
[40:45.680 --> 40:50.680]  С b может вывести с либо b, либо bc.
[40:50.680 --> 41:07.680]  Итак, смотрите, давайте поймем, какая буква может вывестись после того, как мы рассмотрели правила из-за штрих следует s.
[41:07.680 --> 41:14.680]  Вот смотрите, точку ставим сюда.
[41:14.680 --> 41:28.680]  Вопрос, какое слово может вывести справа после того, как мы рассмотрим правила грамматики s-стрелочка.s?
[41:28.680 --> 41:30.680]  В смысле справа?
[41:30.680 --> 41:39.680]  Ну, справа. То есть мы обойдем это дерево разбора, под дерево разбора, и дальше нам надо понять, какое символ мы можем вывести.
[41:39.680 --> 41:41.680]  Первый пост токов мы обойдем от дерева разбора.
[41:41.680 --> 41:47.680]  Чтобы посмотреть вперед, а что будет, когда мы вот эту историю пройдем?
[41:47.680 --> 41:49.680]  C?
[41:49.680 --> 41:51.680]  Нет.
[41:51.680 --> 41:56.680]  Нет, мы по сути находимся в корне дерева разбора.
[41:56.680 --> 42:04.680]  То есть если мы разберем все слово целиком, то что справа останется?
[42:04.680 --> 42:05.680]  Эпсилон?
[42:05.680 --> 42:06.680]  Эпсилон, да.
[42:06.680 --> 42:16.680]  Но смотрите, для того, чтобы у нас все было однозначно и действительно был просмотр на одну букву вперед, давайте каждому слову, которое мы разбираем, добавляем символ конца слова.
[42:16.680 --> 42:22.680]  То есть у нас слова будут не a-b, а будет слово a-b-dollar.
[42:22.680 --> 42:27.680]  Не a-b-c, а a-b-c-dollar.
[42:28.680 --> 42:36.680]  И тогда, по сути, следующий символ, который мы выводим после всего дерева разбора, это будет символ доллара.
[42:36.680 --> 42:56.680]  То есть мы добавляем с вами ситуацию из штрих-стрелочка-точка-s, запятая доллар, означая, что после того, как мы проведем разбор в этом дереве разбора, следующий символ, который мы можем вывести, это будет доллар.
[42:56.680 --> 42:58.680]  Ну, точка s, а не s-точка.
[42:58.680 --> 43:06.680]  Ну, потому что мы начинаем, мы только начинаем дерево разбора проводить. То есть мы с левой части пока находимся.
[43:06.680 --> 43:10.680]  Потом делаем операцию predict, то есть спусков дерева вниз.
[43:10.680 --> 43:20.680]  Делаем s-стрелочка-точка-a-b, запятая, а здесь нам нужно понять, какой символ дальше выводится.
[43:20.680 --> 43:25.680]  Давайте посмотрим. Внимательно, значит, у нас s выводит a-b.
[43:30.680 --> 43:35.680]  И давайте поймем, какой первый символ у нас выводится после s.
[43:36.680 --> 43:38.680]  После строк мы разберем это под дерево.
[43:51.680 --> 43:55.680]  В смысле, после того, как мы сделаем complete из s?
[43:55.680 --> 43:57.680]  Да, да, да.
[44:11.680 --> 44:15.680]  При этом, что мы знаем, что у нас есть s-стрих-точка-s, запятая доллар.
[44:16.680 --> 44:22.680]  То есть первое символ, который мы выводим из родителя, это доллар после родителя.
[44:32.680 --> 44:34.680]  Доллар получается, нет?
[44:34.680 --> 44:36.680]  Ну, тоже доллар, конечно же.
[44:36.680 --> 44:41.680]  То есть, смотрите, если бы здесь был бы какой-нибудь вот тонкий момент,
[44:42.680 --> 44:46.680]  если бы мы с вами немножко поменяли бы грамматику,
[44:46.680 --> 44:53.680]  и у нас была бы грамматика такая, из s-стрих-sd и из s-a-b,
[44:53.680 --> 44:59.680]  тогда давайте из этой ситуации поймем, если бы у нас здесь было бы s-стрих-точка-s-доллар,
[44:59.680 --> 45:03.680]  то s-стрелочка-a-b здесь бы что стояло?
[45:08.680 --> 45:10.680]  Вместо доллара?
[45:10.680 --> 45:11.680]  D.
[45:11.680 --> 45:13.680]  D, да, здесь бы стояла буква D.
[45:13.680 --> 45:18.680]  И пересматриваем все возможные варианты, какая первая буква могла быть у нас выведена.
[45:18.680 --> 45:21.680]  Ну, это такой офф-топик у нас с вами.
[45:21.680 --> 45:26.680]  Если бы еще был из s-стрих-s, например, c, то мы бы еще одно что-то добавили.
[45:26.680 --> 45:28.680]  Да, да, да, да.
[45:30.680 --> 45:32.680]  Начинаем лавливать суть.
[45:32.680 --> 45:35.680]  Дальше мы делаем переход по букве a.
[45:35.680 --> 45:42.680]  Мы получаем с вами s-стрелочка-a-точка-b, запятая доллар, да.
[45:42.680 --> 45:49.680]  И дальше мы спускаемся вниз, получаем b-стрелочка-точка-b,
[45:49.680 --> 45:55.680]  запятая доллар, потому что, ну, по сути, смотрим, что мы можем вывести после b,
[45:55.680 --> 46:00.680]  но после b мы можем вывести только то, что было после того, как мы поднимаемся, то есть доллар.
[46:00.680 --> 46:04.680]  То есть доллар дублируется, если бы у нас справа ничего нет.
[46:04.680 --> 46:09.680]  И здесь у нас получается с вами переход из b в точка b-c, запятая доллар.
[46:09.680 --> 46:12.680]  А теперь важная ситуация.
[46:12.680 --> 46:20.680]  Если мы проходим по b, то у нас получается b-стрелочка-b-точка, запятая доллар,
[46:20.680 --> 46:25.680]  а здесь b-стрелочка-b-точка-c, запятая доллар.
[46:27.680 --> 46:31.680]  И дальше мы можем сделать где-то здесь переход по c,
[46:31.680 --> 46:37.680]  получаем мы с вами b-стрелочка-b-c, точка запятая доллар.
[46:38.680 --> 46:45.680]  А теперь давайте решать, что мы делаем после сталка, попадаем в эту ситуацию
[46:51.680 --> 46:53.680]  вот здесь.
[46:57.680 --> 46:59.680]  Есть ли гипотезы?
[47:01.680 --> 47:12.680]  Мы смотрим, у нас тут еще символ, и дальше уже принимаем действия какие-то.
[47:12.680 --> 47:19.680]  Да, смотрите, если следующий символ c, то мы не можем свернуться по вот этому правилу.
[47:19.680 --> 47:27.680]  Если next равен c, то мы не можем сделать reduce.
[47:31.680 --> 47:38.680]  Но почему? Потому что если бы мы сделали reduce, мы должны бы гарантировать,
[47:38.680 --> 47:41.680]  что следующий символ у нас прямо сразу появится.
[47:41.680 --> 47:44.680]  А у нас следующий символ это доллар, конец слова.
[47:44.680 --> 47:48.680]  Поэтому мы должны перейти по букве c.
[47:48.680 --> 47:53.680]  Если бы здесь не было переход по букве c, допустим, если бы next равно a,
[47:53.680 --> 48:00.680]  то мы бы сказали, что слово не лежит в языке, в грамматике,
[48:00.680 --> 48:04.680]  потому что мы не можем ни свернуться, ни перейти подальше.
[48:06.680 --> 48:12.680]  А если next доллар, то мы делаем reduce.
[48:16.680 --> 48:22.680]  Да, потому что двинуться мы никуда не можем, а вернуться обратно мы можем с вами.
[48:22.680 --> 48:25.680]  Потому что мы говорим следующий символ доллар, мы можем свернуться.
[48:30.680 --> 48:36.680]  Понятно, как разрешать конфликт, если мы добавляем переход на следующий символ?
[48:42.680 --> 48:46.680]  Можете еще раз повторить? У нас после запятой пишутся какие-то символы.
[48:46.680 --> 48:48.680]  Как мы понимаем, что писать?
[48:50.680 --> 48:55.680]  Я сейчас дам формальное определение, мы с вами это как раз посмотрим.
[48:56.680 --> 49:04.680]  Просто там сложно, там нужно еще научиться понимать, что мы можем написать первые буквы.
[49:04.680 --> 49:06.680]  Это хороший вопрос.
[49:15.680 --> 49:20.680]  А вопрос, какая проблема может внезапно гиптически возникнуть?
[49:20.680 --> 49:26.680]  Если бы, допустим, здесь у нас вместо B стрелочка B.$ появился бы запятая C,
[49:26.680 --> 49:31.680]  и здесь есть переход по C, то что надо сделать?
[49:35.680 --> 49:37.680]  Посмотреть на вторую букву?
[49:37.680 --> 49:45.680]  Да, либо посмотреть на вторую букву вперед, либо в классической теории применимости этой штуки делается следующее.
[49:45.680 --> 49:52.680]  Говорится, ребята, сидите и думайте, какую грамматику вы можете построить вместо текущей.
[49:52.680 --> 49:57.680]  Потому что это все-таки практическое применение и парсинг текста.
[49:57.680 --> 50:01.680]  А когда мы парсим текст, мы задаем свою грамматику обычно.
[50:01.680 --> 50:04.680]  Значит, модифицирую грамматику.
[50:05.680 --> 50:07.680]  Вот, вот это важно.
[50:07.680 --> 50:12.680]  Значит, смотрите, теперь, если с этим примером понятно,
[50:12.680 --> 50:16.680]  да, давайте поговорим над формальными определениями.
[50:16.680 --> 50:21.680]  Я, как обычно, это, забыл угловые скобки.
[50:21.680 --> 50:29.680]  Значит, смотрите, для того, чтобы формально определить, какую мы следующую букву пишем, введем множество first.
[50:29.680 --> 50:34.680]  First от альфа.
[50:34.680 --> 50:40.680]  Это у нас с вами множество всех таких буквок,
[50:40.680 --> 50:49.680]  что альфа, из альфа мы можем вывести ау, где у некоторое слово.
[50:50.680 --> 51:00.680]  Да, плюс добавляем сюда доллар, если альфа-эпсилон порождающий.
[51:00.680 --> 51:04.680]  То есть из альфа мы можем вывести, ну, мы ничего не можем вывести.
[51:04.680 --> 51:09.680]  Следующий символ, который мы можем вывести после альфы, это конец слова.
[51:09.680 --> 51:17.680]  Да, и тогда мы можем определить LR ситуацию, LR1 ситуацию,
[51:17.680 --> 51:24.680]  как а, стрелочка, альфа.б, а, запятая а, где а принадлежит сигма объединить с долларом,
[51:24.680 --> 51:28.680]  и а, альфа, бета, это у нас правила грамматики.
[51:28.680 --> 51:36.680]  То есть у нас с вами получается, что а, альфа.б, а, это LR1 ситуация.
[51:39.680 --> 51:44.680]  Контрольный вопрос, как мы будем писать с вами LR0 ситуацию?
[51:53.680 --> 51:55.680]  Вместо а, эпсилон?
[51:55.680 --> 51:59.680]  Ну, можем вообще не писать, можем просто эпсилон написать, да?
[51:59.680 --> 52:07.680]  Эпсилон или а, стрелочка, альфа.б.
[52:08.680 --> 52:16.680]  Хорошо. Теперь еще одно определение, которое нам важно, активный префикс.
[52:16.680 --> 52:23.680]  Нам нужно теперь перевести вот это неформальное определение работы со стеком в вывод грамматики.
[52:23.680 --> 52:27.680]  Напоминаю, что мы с вами строим правосторонний вывод в грамматики.
[52:27.680 --> 52:39.680]  И давайте скажем, что у нас слово, альфа, принадлежащее n объединить сигма со звездой, это активный префикс.
[52:44.680 --> 52:47.680]  Если выполнена следующая вещь.
[52:47.680 --> 52:49.680]  Давайте я картинку нарисую.
[52:50.680 --> 52:58.680]  Значит, из s штрих мы раскрываем эту штуку, как в альфа 1у.
[52:58.680 --> 53:06.680]  И потом за один вывод в правостороннем правиле грамматики, правостороннем выводе мы берем и делаем следующее.
[53:06.680 --> 53:10.680]  Раскрываем b1, b2.
[53:11.680 --> 53:19.680]  И тогда у нас с вами альфа 1, бета 1 равная альфа будет активный префикс.
[53:25.680 --> 53:33.680]  Давайте я, чтобы это было более понятно, я немножечко по-другому нарисую.
[53:34.680 --> 53:38.680]  Немножко на другой высоте.
[53:38.680 --> 53:44.680]  То есть смотрите, у нас было какое-то слово u, которое мы разобрали правосторонним выводом.
[53:44.680 --> 53:51.680]  Потом у нас было какое-то a, которое мы раскрываем, вот здесь как бета 1, бета 2.
[53:51.680 --> 53:59.680]  И здесь у нас уже тоже что-то потом будет разобрано, но это будет у нас какой-то не терминал альфа 1.
[54:00.680 --> 54:08.680]  Поскольку вы в грамматике правосторонний, то прежде чем раскрывать не терминал а, нам нужно раскрыть все, что находится здесь.
[54:08.680 --> 54:11.680]  Поэтому здесь написано чистое слово.
[54:11.680 --> 54:20.680]  И если внимательно посмотреть, давайте попробуем посмотреть, что происходит, когда мы анализируем эту штуку алгоритмом.
[54:20.680 --> 54:27.680]  Значит, берем и движемся.
[54:27.680 --> 54:29.680]  Вот сюда, вот сюда, вот сюда.
[54:29.680 --> 54:38.680]  Как только мы дойдем до слова альфа, не терминала а, на самом деле здесь мы уже с вами построим дерево вывода.
[54:38.680 --> 54:42.680]  И на стеке у нас с вами будет лежать альфа 1.
[54:42.680 --> 54:47.680]  А потом начнем разбирать следующие символы.
[54:47.680 --> 54:51.680]  И бета 1 уже тоже будет лежать на том же самом стеке.
[54:51.680 --> 54:55.680]  Напоминаю алгоритм сначала, когда мы закидывали слова на стек.
[54:55.680 --> 54:59.680]  И почему этот префикс альфа 1, бета 1 называется активным?
[54:59.680 --> 55:04.680]  Потому что он находится у нас на стеке.
[55:04.680 --> 55:12.680]  Потом понятно, когда на стеке появится бета 2, мы сможем раскрыть это правило, заменить то, что лежит на стеке бета 1, бета 2 на а.
[55:12.680 --> 55:15.680]  И тогда уже альфа 2 а.
[55:15.680 --> 55:19.680]  Нет, альфа 2 а тоже будет активным префикс.
[55:19.680 --> 55:27.680]  То есть вот такая вот картинка, это чисто формальное определение вообще того, что может лежать на стеке при разборе нашего слова.
[55:31.680 --> 55:35.680]  Вот, то есть можете воспринимать неформальное определение.
[55:36.680 --> 55:47.680]  Да, нам просто нужно будет, для того чтобы состаковать все практические формулировки, нам нужно это будет смысл вами посмотреть.
[55:47.680 --> 55:50.680]  Можете еще раз повторить смысл?
[55:50.680 --> 55:57.680]  А смысл, значит альфа 1, бета 1 это то, что может лежать на стеке во время алгоритма переноса свертки.
[56:01.680 --> 56:03.680]  Ну вот и все.
[56:05.680 --> 56:07.680]  Вот, теперь смотрите.
[56:17.680 --> 56:22.680]  Так, сейчас, значит смотрите дальше, что мы делаем.
[56:23.680 --> 56:27.680]  Давайте теперь определим допустимую ситуацию для активного префикса.
[56:35.680 --> 56:42.680]  Для альфа 1, бета 1.
[56:42.680 --> 56:44.680]  Смотрите, что происходит.
[56:44.680 --> 56:52.680]  Это как раз то, что нам вводит с вами смысл определения.
[56:52.680 --> 56:54.680]  Смотрите, значит s'.
[56:56.680 --> 57:00.680]  Дальше мы выводим с вами некоторую альфа ау.
[57:00.680 --> 57:06.680]  А дальше мы за один раз выводим с вами бета 1, бета 2.
[57:09.680 --> 57:11.680]  Ставим твку сюда.
[57:11.680 --> 57:15.680]  Тогда у нас альфа б1 по определению является активным префиксом.
[57:15.680 --> 57:16.680]  Да.
[57:16.680 --> 57:24.680]  А при этом у нас получается эта ситуация, которая из a, бета 1.
[57:24.680 --> 57:28.680]  А бета 2, бета u, бета a.
[57:28.680 --> 57:31.680]  Она будет допустима.
[57:33.680 --> 57:35.680]  Давайте вот так напишу.
[57:36.680 --> 57:38.680]  Такая ситуация.
[57:38.680 --> 57:40.680]  Почему она допустима?
[57:40.680 --> 57:43.680]  Потому что a принадлежит first at u.
[57:45.680 --> 57:48.680]  То есть иначе говоря,
[57:48.680 --> 57:55.680]  почему ситуация называется допустимой?
[57:55.680 --> 57:59.680]  Потому что у нас первый символ, который мы можем вывести справа
[57:59.680 --> 58:02.680]  после того, как мы раскроем это под дерево.
[58:08.680 --> 58:10.680]  Вот он.
[58:10.680 --> 58:12.680]  Давайте переформулирую.
[58:12.680 --> 58:16.680]  То, что мы пишем, что у нас следующая буква,
[58:16.680 --> 58:19.680]  которая может быть деревью разбора, это буква a.
[58:19.680 --> 58:21.680]  Вот и все.
[58:21.680 --> 58:25.680]  Как бы говорим вот такую вот вещь.
[58:28.680 --> 58:30.680]  Давайте, если что, задавайте вопрос.
[58:30.680 --> 58:33.680]  Потому что я, может быть, сейчас коряво это все определил.
[58:33.680 --> 58:36.680]  Ну а смысл ровно такой, что ситуация называется допустимой,
[58:36.680 --> 58:39.680]  если следующий символ, который может идти,
[58:39.680 --> 58:42.680]  действительно будет являться первым.
[58:44.680 --> 58:48.680]  А можно просто мы это определяем по нашей грамматике?
[58:48.680 --> 58:52.680]  Ну да, по грамматике смотрим.
[58:55.680 --> 58:57.680]  Хорошо.
[58:57.680 --> 59:00.680]  Так, теперь дальше давайте.
[59:00.680 --> 59:03.680]  Сейчас такая трудная формалистическая вещь,
[59:03.680 --> 59:05.680]  которую нам нужно с вами сделать.
[59:05.680 --> 59:07.680]  Я потом и с вами это.
[59:15.680 --> 59:16.680]  Следующая.
[59:16.680 --> 59:20.680]  Значит, нам нужно с вами теперь определить замыкание.
[59:21.680 --> 59:24.680]  Идея такая.
[59:24.680 --> 59:28.680]  Давайте у нас есть какое-то i множество ситуаций.
[59:34.680 --> 59:43.680]  И мы с вами говорим следующее, что пусть кложе от множества i,
[59:43.680 --> 59:45.680]  это некоторое множество g.
[59:45.680 --> 59:47.680]  Такое, что i является под множеством g,
[59:47.680 --> 59:50.680]  то есть это наименьшее множество, содержащее g.
[59:50.680 --> 59:52.680]  Такое, что...
[59:52.680 --> 59:57.680]  Теперь давайте я это на картинке нарисую, чтобы было понятно.
[59:57.680 --> 01:00:02.680]  Значит, у нас с вами есть ситуация A,
[01:00:02.680 --> 01:00:06.680]  выводящая α1, бета, а2.
[01:00:08.680 --> 01:00:12.680]  И дальше следующий символ, который мы можем вывести, это символ A.
[01:00:12.680 --> 01:00:14.680]  Давайте я следующий символ буду писать так,
[01:00:14.680 --> 01:00:17.680]  что первый символ, который мы можем вывести здесь, это A.
[01:00:17.680 --> 01:00:20.680]  Потом мы сможем с вами вывести бета,
[01:00:20.680 --> 01:00:22.680]  выводим гамма.
[01:00:22.680 --> 01:00:24.680]  Да, точку мы с вами спускаем.
[01:00:24.680 --> 01:00:26.680]  Так.
[01:00:26.680 --> 01:00:32.680]  Тогда первый символ, который мы можем вывести уже отсюда, вот отсюда,
[01:00:32.680 --> 01:00:36.680]  это будет символ first...
[01:00:36.680 --> 01:00:38.680]  А, first маленькими буквами прозначал.
[01:00:46.680 --> 01:00:50.680]  First от альфа до альфа до альфа.
[01:00:50.680 --> 01:00:57.680]  First от альфа2а.
[01:00:57.680 --> 01:01:01.680]  Да, потому что что мы можем сделать здесь?
[01:01:01.680 --> 01:01:05.680]  Мы здесь либо выводим альфа2, первый символ, если он не эпсилон порождающий,
[01:01:05.680 --> 01:01:08.680]  вытягиваем его сюда.
[01:01:08.680 --> 01:01:11.680]  Если он внезапно эпсилон порождающий, то мы еще и смотрим букву А.
[01:01:11.680 --> 01:01:16.680]  Да, то есть у нас получается с вами бета,
[01:01:16.680 --> 01:01:18.680]  стрелочка, гамма, точка,
[01:01:18.680 --> 01:01:22.680]  C, где C лежит first от альфа2а.
[01:01:26.680 --> 01:01:27.680]  Можно вопрос?
[01:01:27.680 --> 01:01:28.680]  Да, давай.
[01:01:28.680 --> 01:01:32.680]  На слайде слева, там нижняя строчка принадлежит G.
[01:01:32.680 --> 01:01:34.680]  Да.
[01:01:34.680 --> 01:01:38.680]  Не принадлежит G.
[01:01:39.680 --> 01:01:41.680]  Потому что замыкание может быть множественное.
[01:01:41.680 --> 01:01:43.680]  Мы сделали замыкание один раз,
[01:01:43.680 --> 01:01:44.680]  по сути сделали предикт один раз,
[01:01:44.680 --> 01:01:45.680]  потом сделали предикт второй раз,
[01:01:45.680 --> 01:01:47.680]  потом предикт третий раз и так далее.
[01:01:47.680 --> 01:01:50.680]  Эта цепочка идет такая.
[01:01:53.680 --> 01:01:54.680]  По сути, это операция предикт.
[01:01:54.680 --> 01:01:57.680]  Мы с вами еще докажем одну лему,
[01:01:57.680 --> 01:02:01.680]  которая нам нужно будет с вами сделать,
[01:02:01.680 --> 01:02:06.680]  но давайте успеем, успеем, не успеем, не успеем.
[01:02:06.680 --> 01:02:09.680]  И последнее определение, которое нам понадобится,
[01:02:09.680 --> 01:02:11.680]  это операция go2.
[01:02:16.680 --> 01:02:20.680]  По символу лямбона это у нас с вами следующее.
[01:02:21.680 --> 01:02:24.680]  Это будет у нас с вами замыкание
[01:02:26.680 --> 01:02:28.680]  следующего множества.
[01:02:29.680 --> 01:02:31.680]  Так, перенесу его.
[01:02:32.680 --> 01:02:33.680]  По сути, это сдвиг точки.
[01:02:33.680 --> 01:02:34.680]  Сдвиг точки.
[01:02:34.680 --> 01:02:38.680]  А, стрелочка, альфа, один, бета, точка, альфа, два.
[01:02:38.680 --> 01:02:39.680]  Так, стоп.
[01:02:41.680 --> 01:02:42.680]  Багу нашел.
[01:02:44.680 --> 01:02:45.680]  Надо вычитывать лекции.
[01:02:45.680 --> 01:02:47.680]  Лямбда вот тут стоит.
[01:02:48.680 --> 01:02:52.680]  То есть мы сдвигаем лямбду А
[01:02:53.680 --> 01:02:57.680]  при условии того, что А, стрелочка, альфа, один, точка, лямбда,
[01:02:57.680 --> 01:03:01.680]  А, два, А принадлежит множеству ситуаций И.
[01:03:03.680 --> 01:03:05.680]  То есть что мы делаем с вами?
[01:03:05.680 --> 01:03:07.680]  Мы делаем сдвиг точки
[01:03:09.680 --> 01:03:10.680]  и это.
[01:03:11.680 --> 01:03:13.680]  И делаем замыкание.
[01:03:16.680 --> 01:03:18.680]  Хорошо, скажите мне, пожалуйста,
[01:03:18.680 --> 01:03:21.680]  для осознания ситуации.
[01:03:25.680 --> 01:03:28.680]  Скажите, пожалуйста, что такое операция go2
[01:03:28.680 --> 01:03:30.680]  и что такое операция claw?
[01:03:30.680 --> 01:03:33.680]  В тех терминах, которые мы с вами уже показывали.
[01:03:34.680 --> 01:03:35.680]  В терминах картинок.
[01:03:36.680 --> 01:03:38.680]  Да, да, я исправлю баги в презентации.
[01:03:53.680 --> 01:03:56.680]  Давайте начнем с понимания того, что делает операция claw.
[01:03:56.680 --> 01:04:00.680]  Давайте начнем с понимания того, что делает операция claw,
[01:04:00.680 --> 01:04:03.680]  что кодирует операция claw
[01:04:03.680 --> 01:04:05.680]  в наших предыдущих терминах,
[01:04:05.680 --> 01:04:07.680]  которые мы занимали с первой половиной занятий в седешних.
[01:04:19.680 --> 01:04:21.680]  Это не просто множество переходов?
[01:04:22.680 --> 01:04:24.680]  Ну, это множество переходов.
[01:04:24.680 --> 01:04:27.680]  По сути, это то, что мы с вами делали это.
[01:04:31.680 --> 01:04:33.680]  Эпсилон замыкания делали.
[01:04:33.680 --> 01:04:35.680]  Да, вот когда мы взяли...
[01:04:35.680 --> 01:04:37.680]  Сейчас покажу, пытаюсь.
[01:04:39.680 --> 01:04:41.680]  Вот у нас...
[01:04:41.680 --> 01:04:43.680]  Где там был автомат?
[01:04:48.680 --> 01:04:50.680]  Вот у нас был автомат, да.
[01:04:50.680 --> 01:04:52.680]  Вот мы сделали эпсилон-переход.
[01:04:52.680 --> 01:04:54.680]  И что такое замыкание?
[01:04:54.680 --> 01:04:57.680]  Мы просто взяли вот эти два множества, объединили в одно.
[01:05:08.680 --> 01:05:10.680]  Понятно ли это?
[01:05:12.680 --> 01:05:14.680]  Это просто фундаментально важная вещь,
[01:05:14.680 --> 01:05:16.680]  которую нам надо все-таки понять.
[01:05:17.680 --> 01:05:22.680]  Не очень понятно, как это с формальным определением согласуется.
[01:05:22.680 --> 01:05:24.680]  Давайте посмотрим как раз.
[01:05:28.680 --> 01:05:30.680]  Вот, клоши А3, да.
[01:05:30.680 --> 01:05:32.680]  То есть что такое замыкание от вот этой ситуации?
[01:05:34.680 --> 01:05:36.680]  Точнее давайте от ситуации...
[01:05:36.680 --> 01:05:38.680]  Какой у нас был?
[01:05:38.680 --> 01:05:40.680]  От ситуации из S'.
[01:05:47.680 --> 01:05:49.680]  Клоше от ситуации...
[01:05:49.680 --> 01:05:51.680]  Там S'.
[01:05:51.680 --> 01:05:53.680]  Стрелочка, точка S,
[01:05:53.680 --> 01:05:55.680]  доллар.
[01:05:57.680 --> 01:05:58.680]  Да.
[01:05:58.680 --> 01:06:00.680]  Это множество ситуаций таких,
[01:06:00.680 --> 01:06:02.680]  что если у нас
[01:06:02.680 --> 01:06:04.680]  с вами есть...
[01:06:04.680 --> 01:06:06.680]  Начнем с первой штуки.
[01:06:06.680 --> 01:06:08.680]  У нас есть правило
[01:06:08.680 --> 01:06:10.680]  S'.
[01:06:10.680 --> 01:06:12.680]  точка S, да.
[01:06:12.680 --> 01:06:15.680]  При этом первый символ, который мы с вами раскрываем здесь,
[01:06:15.680 --> 01:06:17.680]  является доллар.
[01:06:17.680 --> 01:06:19.680]  Да.
[01:06:19.680 --> 01:06:21.680]  Дальше у нас правила какие были?
[01:06:21.680 --> 01:06:23.680]  У нас было правило SAB.
[01:06:23.680 --> 01:06:25.680]  Дорисовываем с вами правило AB.
[01:06:25.680 --> 01:06:27.680]  Прокидываем сюда точку.
[01:06:29.680 --> 01:06:33.680]  И смотрим, что у нас выводится здесь.
[01:06:33.680 --> 01:06:35.680]  В нашем случае α2 это пустое слово.
[01:06:37.680 --> 01:06:39.680]  Смотрим, что выводится первым символом
[01:06:39.680 --> 01:06:41.680]  first
[01:06:41.680 --> 01:06:43.680]  под epsilon$.
[01:06:43.680 --> 01:06:45.680]  Ну, это доллар будет.
[01:06:47.680 --> 01:06:49.680]  Точнее first от epsilon.
[01:06:49.680 --> 01:06:51.680]  Вот так вот.
[01:06:53.680 --> 01:06:55.680]  А, нет, давайте first от epsilon$.
[01:06:55.680 --> 01:06:57.680]  Это доллар. Вот.
[01:06:57.680 --> 01:06:59.680]  То есть у нас получается, что
[01:06:59.680 --> 01:07:01.680]  из S'
[01:07:01.680 --> 01:07:03.680]  точка S, да,
[01:07:03.680 --> 01:07:05.680]  из S'
[01:07:05.680 --> 01:07:07.680]  точка AB,
[01:07:07.680 --> 01:07:09.680]  есть AB правила,
[01:07:09.680 --> 01:07:11.680]  то мы в это замыкание должны добавить ситуацию.
[01:07:11.680 --> 01:07:13.680]  Во-первых, оно текущее,
[01:07:13.680 --> 01:07:15.680]  потому что оно есть.
[01:07:15.680 --> 01:07:17.680]  И дополнительно мы добавляем
[01:07:17.680 --> 01:07:19.680]  ситуацию S'
[01:07:19.680 --> 01:07:21.680]  точка AB, запятая доллар.
[01:07:33.680 --> 01:07:35.680]  Стало понятнее?
[01:07:35.680 --> 01:07:37.680]  То есть я просто те слова, которые
[01:07:37.680 --> 01:07:39.680]  проговаривал, именно
[01:07:39.680 --> 01:07:41.680]  еще раз это.
[01:07:41.680 --> 01:07:43.680]  То есть мы здесь делаем одно раскрытие,
[01:07:43.680 --> 01:07:45.680]  а потом смотрим, какие
[01:07:45.680 --> 01:07:47.680]  дальше будут
[01:07:47.680 --> 01:07:49.680]  прочитанные буквы, возможно.
[01:07:49.680 --> 01:07:51.680]  Да, да, да. Вот у нас тут просто
[01:07:51.680 --> 01:07:53.680]  как раз вот вопрос, который
[01:07:53.680 --> 01:07:55.680]  как раз задавал.
[01:07:55.680 --> 01:07:57.680]  Он заключался в том, а как мы понимаем,
[01:07:57.680 --> 01:07:59.680]  какие первые буквы мы дописываем, да?
[01:07:59.680 --> 01:08:01.680]  Вот как раз first от alpha2A,
[01:08:01.680 --> 01:08:03.680]  которая вот здесь, то есть
[01:08:03.680 --> 01:08:05.680]  вот как раз first от alpha2A,
[01:08:05.680 --> 01:08:07.680]  которая вот здесь написана. Мы понимаем,
[01:08:07.680 --> 01:08:09.680]  какие буквы могут быть здесь написаны.
[01:08:09.680 --> 01:08:11.680]  Это как раз возвращаться
[01:08:11.680 --> 01:08:13.680]  к тому вопросу, который уже задавался,
[01:08:13.680 --> 01:08:15.680]  на который я говорю, что
[01:08:15.680 --> 01:08:17.680]  я отвечу.
[01:08:29.680 --> 01:08:31.680]  Так, хорошо.
[01:08:33.680 --> 01:08:35.680]  А скажите тогда, если
[01:08:35.680 --> 01:08:37.680]  прокло уже понятно, что делает
[01:08:37.680 --> 01:08:39.680]  операция go2?
[01:08:41.680 --> 01:08:43.680]  В терминах автоматов.
[01:09:03.680 --> 01:09:05.680]  Чему
[01:09:05.680 --> 01:09:07.680]  равняем?
[01:09:07.680 --> 01:09:09.680]  Давайте вот на примерах,
[01:09:09.680 --> 01:09:11.680]  чтобы было понятно, что такое
[01:09:11.680 --> 01:09:13.680]  go2 от
[01:09:13.680 --> 01:09:15.680]  вот этого множества
[01:09:15.680 --> 01:09:17.680]  i,
[01:09:17.680 --> 01:09:19.680]  и штрих, который мы с вами обозначили.
[01:09:19.680 --> 01:09:21.680]  И что такое
[01:09:21.680 --> 01:09:23.680]  go2
[01:09:23.680 --> 01:09:25.680]  от
[01:09:25.680 --> 01:09:27.680]  вот этого множества
[01:09:27.680 --> 01:09:29.680]  i, и штрих, который мы с вами
[01:09:29.680 --> 01:09:31.680]  обозначили.
[01:09:31.680 --> 01:09:33.680]  Множество
[01:09:33.680 --> 01:09:35.680]  i, штрих, и по букве
[01:09:35.680 --> 01:09:37.680]  мы делаем его по букве
[01:09:39.680 --> 01:09:41.680]  по букве
[01:09:41.680 --> 01:09:43.680]  a маленькая.
[01:09:51.680 --> 01:09:53.680]  Смотрите,
[01:09:53.680 --> 01:09:55.680]  что мы делаем. Мы делаем перенос
[01:09:55.680 --> 01:09:57.680]  буквы a.
[01:09:57.680 --> 01:09:59.680]  Это, по сути, будет
[01:09:59.680 --> 01:10:01.680]  замыкание.
[01:10:01.680 --> 01:10:03.680]  Состояние s штрих
[01:10:05.680 --> 01:10:07.680]  стрелочка a, точка b
[01:10:07.680 --> 01:10:09.680]  dollar.
[01:10:09.680 --> 01:10:11.680]  То есть мы сделаем
[01:10:11.680 --> 01:10:13.680]  сдвиг и делаем замыкание.
[01:10:13.680 --> 01:10:15.680]  Да?
[01:10:15.680 --> 01:10:17.680]  Мы теперь смотрим внимательно,
[01:10:17.680 --> 01:10:19.680]  товарищи.
[01:10:19.680 --> 01:10:21.680]  Делаем
[01:10:21.680 --> 01:10:23.680]  сдвиг по букве a, делаем
[01:10:23.680 --> 01:10:25.680]  замыкание.
[01:10:29.680 --> 01:10:31.680]  То есть это переход
[01:10:31.680 --> 01:10:33.680]  в нашем автомате.
[01:10:35.680 --> 01:10:37.680]  Давайте я это
[01:10:37.680 --> 01:10:39.680]  как раз и напишу.
[01:10:39.680 --> 01:10:41.680]  А почему у нас точка переместилась вправо?
[01:10:41.680 --> 01:10:43.680]  Она же только влево перемещается, нет?
[01:10:43.680 --> 01:10:45.680]  Нет, вправо.
[01:10:45.680 --> 01:10:47.680]  Делаем сдвиг, мы читаем буквы a.
[01:10:47.680 --> 01:10:49.680]  Да, тут понятно,
[01:10:49.680 --> 01:10:51.680]  но в go2 непонятно почему.
[01:10:51.680 --> 01:10:53.680]  Ну вот, мы же казали, что
[01:10:53.680 --> 01:10:55.680]  go2 это замыкание от такого ситуации,
[01:10:55.680 --> 01:10:57.680]  где ситуация изначально была такая.
[01:10:57.680 --> 01:10:59.680]  Да, то есть мы точку,
[01:10:59.680 --> 01:11:01.680]  то что было справа, точка слева,
[01:11:01.680 --> 01:11:03.680]  точка слева от лямб дострела, мы двигаемся сюда.
[01:11:03.680 --> 01:11:05.680]  Ага, тут понятно.
[01:11:05.680 --> 01:11:07.680]  Вот, то есть смотрите,
[01:11:07.680 --> 01:11:09.680]  давайте как раз
[01:11:09.680 --> 01:11:11.680]  финализируем. Это go2,
[01:11:11.680 --> 01:11:13.680]  это переход в ДК.
[01:11:17.680 --> 01:11:19.680]  А closure, это
[01:11:21.680 --> 01:11:23.680]  давайте напишу
[01:11:23.680 --> 01:11:25.680]  удаление эпсилон переходов.
[01:11:27.680 --> 01:11:29.680]  Отлично.
[01:11:33.680 --> 01:11:35.680]  Можно вопрос,
[01:11:35.680 --> 01:11:37.680]  а если у нас
[01:11:37.680 --> 01:11:39.680]  go2 вызывается не
[01:11:39.680 --> 01:11:41.680]  от вершины
[01:11:41.680 --> 01:11:43.680]  НК, а например
[01:11:43.680 --> 01:11:45.680]  от нескольких вершин?
[01:11:45.680 --> 01:11:47.680]  Ну,
[01:11:47.680 --> 01:11:49.680]  тогда нужно
[01:11:49.680 --> 01:11:51.680]  взять все ситуации и по сути
[01:11:51.680 --> 01:11:53.680]  от них детерминизировать.
[01:11:53.680 --> 01:11:55.680]  То есть как в обычном ДК
[01:11:55.680 --> 01:11:57.680]  делается, но ровно так же тут и делает.
[01:11:57.680 --> 01:11:59.680]  Ровно такая же операция будет и тут.
[01:11:59.680 --> 01:12:01.680]  А если мы возьмем две различные вершины
[01:12:01.680 --> 01:12:03.680]  ДК, то это будет не переход
[01:12:03.680 --> 01:12:05.680]  в ДК, а
[01:12:05.680 --> 01:12:07.680]  множественный переход?
[01:12:07.680 --> 01:12:09.680]  Да, множественный переход.
[01:12:09.680 --> 01:12:11.680]  Ну, как множество дельта от множества ситуаций
[01:12:11.680 --> 01:12:13.680]  мы определяли это там
[01:12:13.680 --> 01:12:15.680]  в самом начале лекций.
[01:12:15.680 --> 01:12:17.680]  Это пример
[01:12:17.680 --> 01:12:19.680]  грамматики, который я тут готовил, но
[01:12:19.680 --> 01:12:21.680]  мы с вами пример уже посмотрели.
[01:12:21.680 --> 01:12:23.680]  Можете на досуге, кстати, посмотреть пример
[01:12:23.680 --> 01:12:25.680]  Вот этот вот. Нарисовать ним автомат.
[01:12:25.680 --> 01:12:27.680]  Нарисовать примеры go2 и переход.
[01:12:27.680 --> 01:12:29.680]  Итак, смотрите.
[01:12:29.680 --> 01:12:31.680]  Первые леммы. До них мы сегодня не дошли.
[01:12:31.680 --> 01:12:33.680]  Но они достаточно
[01:12:33.680 --> 01:12:35.680]  важны. Может быть одну докажем.
[01:12:35.680 --> 01:12:37.680]  Значит, смотрите. Если множество
[01:12:37.680 --> 01:12:39.680]  ситуаций являются
[01:12:39.680 --> 01:12:41.680]  допустимым,
[01:12:41.680 --> 01:12:43.680]  то его замыкание тоже является
[01:12:43.680 --> 01:12:45.680]  допустимым.
[01:12:45.680 --> 01:12:47.680]  Что это нам позволит?
[01:12:47.680 --> 01:12:49.680]  Это нам позволит на самом деле
[01:12:49.680 --> 01:12:51.680]  избавиться. Вот эта лемма
[01:12:51.680 --> 01:12:53.680]  позволяет избавиться от эпсилон переходов.
[01:12:55.680 --> 01:12:57.680]  Да, формально показать,
[01:12:57.680 --> 01:12:59.680]  почему мы можем избавиться от эпсилон
[01:12:59.680 --> 01:13:01.680]  переходов.
[01:13:01.680 --> 01:13:03.680]  Вторая лемма заключается в следующем.
[01:13:03.680 --> 01:13:05.680]  Что мы
[01:13:05.680 --> 01:13:07.680]  по сути с вами говорим,
[01:13:07.680 --> 01:13:09.680]  что допустимые ситуации,
[01:13:09.680 --> 01:13:11.680]  в допустимых ситуациях можно построить
[01:13:11.680 --> 01:13:13.680]  этот.
[01:13:13.680 --> 01:13:15.680]  Детерминированный автомат.
[01:13:15.680 --> 01:13:17.680]  То есть мы говорим
[01:13:17.680 --> 01:13:19.680]  сейчас,
[01:13:19.680 --> 01:13:21.680]  что мы с вами будем строить
[01:13:21.680 --> 01:13:23.680]  не какое-то
[01:13:23.680 --> 01:13:25.680]  ДКА над множеством ситуаций,
[01:13:25.680 --> 01:13:27.680]  а будем строить ДКА
[01:13:27.680 --> 01:13:29.680]  для допустимых ситуаций, которые являются
[01:13:29.680 --> 01:13:31.680]  корректными в нашем случае.
[01:13:31.680 --> 01:13:33.680]  И вот эта теорема
[01:13:33.680 --> 01:13:35.680]  показывает корректность
[01:13:35.680 --> 01:13:37.680]  построения ДКА.
[01:13:41.680 --> 01:13:43.680]  И давайте вопрос такой.
[01:13:43.680 --> 01:13:45.680]  Что показывает
[01:13:45.680 --> 01:13:47.680]  лемма 2?
[01:13:49.680 --> 01:13:51.680]  Что
[01:13:53.680 --> 01:13:55.680]  замыкание вот этого ситуации
[01:13:55.680 --> 01:13:57.680]  это множество допустимых ситуаций
[01:13:57.680 --> 01:13:59.680]  для слова эпсилон.
[01:14:03.680 --> 01:14:05.680]  Множество конечных состояний
[01:14:05.680 --> 01:14:07.680]  в нашем автомате?
[01:14:07.680 --> 01:14:09.680]  Нет, не конечных только.
[01:14:11.680 --> 01:14:13.680]  Вот эта вот ситуация
[01:14:13.680 --> 01:14:15.680]  у нас где находится?
[01:14:15.680 --> 01:14:17.680]  В нашем автомате.
[01:14:19.680 --> 01:14:21.680]  Стартовая?
[01:14:21.680 --> 01:14:23.680]  Да, стартовая.
[01:14:23.680 --> 01:14:25.680]  То есть что стартовая ситуация
[01:14:25.680 --> 01:14:27.680]  согласуется с тем, что мы
[01:14:27.680 --> 01:14:29.680]  по сути рассмотрели
[01:14:29.680 --> 01:14:31.680]  все ситуации,
[01:14:31.680 --> 01:14:33.680]  в которых мы
[01:14:33.680 --> 01:14:35.680]  говорим, что начало пустое.
[01:14:35.680 --> 01:14:37.680]  То есть мы строим множество ситуаций,
[01:14:37.680 --> 01:14:39.680]  в которых
[01:14:39.680 --> 01:14:41.680]  точка стоит в начале слова.
[01:14:43.680 --> 01:14:45.680]  А дальше мы показываем корректность
[01:14:45.680 --> 01:14:47.680]  всех переходов построения ДКА.
[01:14:47.680 --> 01:14:49.680]  То есть таким образом
[01:14:49.680 --> 01:14:51.680]  вот эти леммы нам позволят показать,
[01:14:51.680 --> 01:14:53.680]  что ДКА, который мы строим,
[01:14:53.680 --> 01:14:55.680]  корректно сформирована
[01:14:55.680 --> 01:14:57.680]  с точки зрения
[01:15:03.680 --> 01:15:05.680]  того, что мы выше говорили.
[01:15:05.680 --> 01:15:07.680]  Я думаю, на сегодня
[01:15:07.680 --> 01:15:09.680]  можно закончить. Давайте задавайте вопросы.
[01:15:09.680 --> 01:15:11.680]  Мне кажется, мы сегодня
[01:15:11.680 --> 01:15:13.680]  продуктивно поговорили. В следующий раз
[01:15:13.680 --> 01:15:15.680]  мы с вами уже будем формально сидеть
[01:15:15.680 --> 01:15:17.680]  и доказывать эти леммы все.
[01:15:17.680 --> 01:15:19.680]  И еще там
[01:15:19.680 --> 01:15:21.680]  посмотрим
[01:15:21.680 --> 01:15:23.680]  один аспект,
[01:15:23.680 --> 01:15:25.680]  который нам тоже нужен будет.
[01:15:25.680 --> 01:15:27.680]  То есть у нас есть
[01:15:27.680 --> 01:15:29.680]  еще один аспект, который
[01:15:29.680 --> 01:15:31.680]  нам тоже нужен будет.
[01:15:31.680 --> 01:15:33.680]  На, баги я пришлю, постараюсь презентацию прислать.
[01:15:41.680 --> 01:15:43.680]  Можете теперь им один еще раз пояснить?
[01:15:45.680 --> 01:15:47.680]  Сейчас поясню.
[01:15:47.680 --> 01:15:49.680]  Она заключается в следующем,
[01:15:49.680 --> 01:15:51.680]  что у нас есть
[01:15:51.680 --> 01:15:53.680]  один аспект,
[01:15:53.680 --> 01:15:55.680]  который нам тоже нужен будет.
[01:15:55.680 --> 01:15:57.680]  Сейчас поясню.
[01:15:57.680 --> 01:15:59.680]  Она заключается в следующем,
[01:15:59.680 --> 01:16:01.680]  что у нас есть
[01:16:01.680 --> 01:16:03.680]  сейчас
[01:16:03.680 --> 01:16:05.680]  покажу.
[01:16:05.680 --> 01:16:07.680]  То есть у нас есть состояние
[01:16:07.680 --> 01:16:09.680]  стартовая ку-ноль.
[01:16:09.680 --> 01:16:11.680]  Вот это вот.
[01:16:11.680 --> 01:16:13.680]  В котором лежит s' .s
[01:16:13.680 --> 01:16:15.680]  за 5$.
[01:16:15.680 --> 01:16:17.680]  Лемма 2
[01:16:17.680 --> 01:16:19.680]  что говорит?
[01:16:19.680 --> 01:16:21.680]  Говорит, что это соответствует
[01:16:21.680 --> 01:16:23.680]  активному префиксу
[01:16:23.680 --> 01:16:25.680]  epsilon.
[01:16:27.680 --> 01:16:29.680]  То есть все ситуации
[01:16:35.680 --> 01:16:37.680]  со стеком apps.
[01:16:39.680 --> 01:16:41.680]  С пустым стеком.
[01:16:41.680 --> 01:16:43.680]  Понятно, что мы когда еще будем
[01:16:43.680 --> 01:16:45.680]  в классическом магарите
[01:16:45.680 --> 01:16:47.680]  перенос свертки, то что этот стек у нас
[01:16:47.680 --> 01:16:49.680]  пустой.
[01:16:49.680 --> 01:16:51.680]  Потом мы говорим, окей, давайте посмотрим
[01:16:51.680 --> 01:16:53.680]  какие-то переходы.
[01:16:53.680 --> 01:16:55.680]  У нас, допустим, тут переход по букве
[01:16:55.680 --> 01:16:57.680]  x был.
[01:16:57.680 --> 01:16:59.680]  Тогда это у нас будет
[01:16:59.680 --> 01:17:01.680]  все ситуации
[01:17:01.680 --> 01:17:03.680]  с активным префиксом
[01:17:07.680 --> 01:17:09.680]  к активным префиксам x.
[01:17:09.680 --> 01:17:11.680]  То есть все ситуации со стеком x.
[01:17:11.680 --> 01:17:13.680]  То есть на самом деле
[01:17:13.680 --> 01:17:15.680]  если классически говорить
[01:17:15.680 --> 01:17:17.680]  да, давайте опять же к нашему примеру
[01:17:17.680 --> 01:17:19.680]  вернемся.
[01:17:19.680 --> 01:17:21.680]  То есть здесь мы
[01:17:21.680 --> 01:17:23.680]  в нашем примере можем сказать, что
[01:17:23.680 --> 01:17:25.680]  здесь у нас будут находиться
[01:17:25.680 --> 01:17:27.680]  все ситуации
[01:17:27.680 --> 01:17:29.680]  если мы
[01:17:29.680 --> 01:17:31.680]  здесь находятся все ситуации
[01:17:31.680 --> 01:17:33.680]  у которых на стеке будет лежать
[01:17:33.680 --> 01:17:35.680]  app.
[01:17:35.680 --> 01:17:37.680]  То есть у нас будут находиться
[01:17:37.680 --> 01:17:39.680]  все ситуации
[01:17:39.680 --> 01:17:41.680]  у которых на стеке будет лежать
[01:17:41.680 --> 01:17:43.680]  ab.
[01:17:47.680 --> 01:17:49.680]  То есть если мы попали в эту ситуацию
[01:17:49.680 --> 01:17:51.680]  то на стеке у нас действительно лежит ab
[01:17:51.680 --> 01:17:53.680]  и поэтому
[01:17:53.680 --> 01:17:55.680]  если у нас следующий символ конец слова
[01:17:55.680 --> 01:17:57.680]  то действительно мы можем свернуться
[01:17:57.680 --> 01:17:59.680]  по символу b
[01:17:59.680 --> 01:18:01.680]  и да, действительно
[01:18:01.680 --> 01:18:03.680]  то что у нас b.
[01:18:03.680 --> 01:18:05.680]  справа в конце находятся.
[01:18:09.680 --> 01:18:11.680]  То есть это поясняет корректность того
[01:18:11.680 --> 01:18:13.680]  что мы можем сделать здесь reduce
[01:18:13.680 --> 01:18:15.680]  операцию.
[01:18:25.680 --> 01:18:27.680]  Понятно?
[01:18:31.680 --> 01:18:33.680]  Хорошо, но мы еще на семинарах это будем
[01:18:33.680 --> 01:18:35.680]  обсуждать все.
[01:18:35.680 --> 01:18:37.680]  Ну и в следующий раз тоже
[01:18:37.680 --> 01:18:39.680]  продолжим это доказывать.
[01:18:39.680 --> 01:18:41.680]  Морально настраивайтесь, что
[01:18:41.680 --> 01:18:43.680]  будет формально и будет
[01:18:43.680 --> 01:18:45.680]  неприятно.
[01:18:45.680 --> 01:18:47.680]  Но все-таки это нам надо будет сделать.
[01:18:53.680 --> 01:18:55.680]  Все тогда всем спасибо, всем не болейте
[01:18:55.680 --> 01:18:57.680]  всем хорошего дня.
