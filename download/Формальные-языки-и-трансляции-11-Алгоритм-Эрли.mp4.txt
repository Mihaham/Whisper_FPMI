[00:00.000 --> 00:12.160]  всем доброго дня мы сегодня так сказать начинаем может быть продолжаем тему связанную с парсерами
[00:12.160 --> 00:20.200]  значит у кого-то на колокольни был вопрос посвященный парсерам да давайте попробуем
[00:20.200 --> 00:24.400]  сформулировать что же такое парсер да
[00:24.400 --> 00:51.520]  ну да по факту это алгоритм который имеет в инпуте
[00:51.520 --> 01:02.700]  в слово или грамматику же тут в зависимости от некоторые алгоритмы сами зашивают при
[01:02.700 --> 01:11.560]  процессе и грамматику некоторые не зашивают и наша цель ответить на следующий вопрос
[01:11.560 --> 01:19.640]  лежит ли слово w в языке задаваемой грамматика же если ответ на этот вопрос правда то построить
[01:19.640 --> 01:33.960]  дерево вода вот так это обозначу вот на какой парсер мы с вами уже разбирали
[01:33.960 --> 01:44.440]  алгоритм кока янгера косами и наша цель сегодняшняя будет понять как построить парсер который бы мог
[01:44.440 --> 01:51.360]  работать с произвольной грамматикой и мы начали с вами в прошлый раз немножечко колдовать значит
[01:51.360 --> 01:58.120]  мы с вами в прошлый раз построили дерево разбора то есть у нас есть грамматика из эс выводит ас бс
[01:58.120 --> 02:02.520]  и из эс выводит вэпсио мы с вами напомнили что это правильная скобочные последовательности
[02:02.520 --> 02:15.160]  и идея следующая давайте попробуем про эмулировать это дерево вывода то есть мы
[02:15.160 --> 02:27.040]  с вами попробуем сделать так чтобы мы обходом в глубину обошли это дерево вывода начиная слева
[02:27.040 --> 02:33.120]  верхней точки то есть мы начинаем слева верхнего узла и должны дай обойти все дерево целиком и
[02:33.120 --> 02:42.920]  дойти до правой штуки то есть вот так вот обойти наши дерево вот наша цель если мы на каком в
[02:42.920 --> 02:49.200]  каком-то моменте заткнемся замкнемся то значит можно сказать наверное что слово не лежит в языке
[02:49.200 --> 02:56.840]  задаваем на грамматик вот идея такая и по факту будем спускаться с вами вниз и пытаться
[02:56.840 --> 03:04.480]  пристроить какое-то дерево кусочек дерева вывода но возможно тут может быть несколько
[03:04.480 --> 03:13.360]  вариантов почему может быть несколько вариантов понятно да потому что грамматика не обязательно
[03:13.360 --> 03:23.520]  является однозначной вот поэтому нужно выявить хоть какой-то вывод поэтому мысленно мы будем
[03:23.520 --> 03:29.040]  с вами вот держать вот эту вот историю и попытаемся разобрать построить конструкцию
[03:29.040 --> 03:36.680]  которая позволит нам разобрать все слово целиком давайте подумаем какие у нас три ситуации возможно
[03:36.680 --> 03:44.480]  когда мы будем разбирать это дерево разбора ну опять же напоминаю что у нас есть слово ааб значит
[03:44.480 --> 03:51.120]  видим если у нас есть первая буква а в этом дереве то мы можем точку проскочить если идем
[03:51.120 --> 03:59.000]  вниз то опять же напоминаю что если посмотреть на внимательно на алгоритм обхода в глубину да то
[03:59.000 --> 04:06.840]  у нас по факту есть такая структура как стэк стэк вызовов рекурсии обходов глубину и по факту чтобы
[04:06.840 --> 04:12.360]  выскочить из этого стэка нам необходимо понять а где же точка возврата нашей функции то есть куда
[04:12.360 --> 04:17.960]  в какую точку мы возвращаемся здесь идея ровно такая же давайте мы возьмем значит позицию в которой
[04:17.960 --> 04:25.080]  мы находимся обозначим ее черный кругляшочком и позиция родительская где мы находимся у родителя
[04:25.080 --> 04:31.640]  нашего дерева разбора на текущий момент как круглую точку полую точку и когда мы прыгаем вниз мы
[04:31.640 --> 04:37.240]  по факту запоминаем где у нас эта точка была то есть вот у нас черная точка была здесь соответственно
[04:37.240 --> 04:41.600]  мы спускаемся вниз эта черная точка становится белой точкой для того чтобы потом мы могли из
[04:41.600 --> 04:53.840]  нее выпрыгнуть да да мы пытаемся обойти в глубину сейчас мы гипотетически его знаем вот а дальше мы
[04:53.880 --> 05:00.280]  будем пытаться перебирать все возможные префиксы для того чтобы строить гипотетическое сет возможно
[05:00.280 --> 05:07.560]  деревьев на текущем префиксе который у нас получается вот просто нам необходимо понять
[05:07.560 --> 05:13.480]  какие конфигурации какие правила у нас с вами есть то есть если у нас есть символ и у нас есть он
[05:13.480 --> 05:19.720]  хороший то мы можем прыгать вниз переходить двигать точку а если мы встречаем препятствие в виде
[05:19.720 --> 05:25.440]  не терминала то мы должны обойти наше дерево целиком спуститься вниз разобрать под слово
[05:25.440 --> 05:31.640]  который соответствует этому дереву выйти вверх вот и вот первый момент времени который у нас
[05:31.640 --> 05:39.040]  есть мы должны выйти из этого дерева целиком мы считайте обошли весь лист который у нас с вами
[05:39.040 --> 05:45.240]  был вот здесь ну я сам пустое слово поэтому нам надо вернуться вверх ну как понять куда вернуться
[05:45.800 --> 05:51.520]  значит у этой точки есть родительская точка она находится где-то здесь да а мышку видно кстати
[05:51.520 --> 05:59.240]  вот смотрите у этой точки мы знаем где родитель он находится здесь но а в этой
[05:59.240 --> 06:04.080]  точке мы обошли поэтому когда мы обошли все по дереву целиком мы можем взять и перепрыгнуть
[06:04.080 --> 06:10.940]  через этот терминал поет через этне терминал но собственно мы его стоп это не туда собственно
[06:10.940 --> 06:16.780]  мы его перепрыгиваем. Вот так вот. И повторяем все процедуры, которые здесь есть. Вот здесь мы
[06:16.780 --> 06:24.300]  закрыли все под дерево из SWET-ISBS и должны прыгнуть вот сюда. Оба прыгаем и так далее обходим слово
[06:24.300 --> 06:31.500]  целиком. Вот. Но на самом деле сейчас это гипотетическая история. И поэтому в прошлый раз, когда
[06:31.500 --> 06:38.100]  мы начали обсуждать эту картинку, мы сказали следующее, что на самом деле нам необходимо отслеживать
[06:38.100 --> 06:45.460]  позицию в слове, где мы находимся на текущий момент. То есть давайте зашифруем блоки,
[06:45.460 --> 06:52.860]  в которых мы находимся, через позиции точек и правила вывода. А именно, давайте определим
[06:52.860 --> 07:06.100]  следующую вещь как ситуация для определенного правила грамматики. То есть вводим новое понятие.
[07:06.100 --> 07:24.180]  Для правила давайте я напишу сначала так. А выводит гамма. Это следующий объект. Мы гамму
[07:24.180 --> 07:33.220]  разбиваем на некоторую последовательность двух терминалов. У нас получается следующее,
[07:33.220 --> 07:42.180]  что это мы будем записывать а, стрелочка, альфа, точка, бета. То есть у нас добавляется в нашем
[07:42.180 --> 07:47.060]  правиле грамматики где-то точка посередине. По факту это позиция, в которой мы будем с вами
[07:47.060 --> 07:54.300]  находиться. Дальше мы будем кодировать эту штуку некоторым элементом и. Сейчас я объясню. И вот
[07:54.300 --> 07:59.060]  эта вот штука будет находиться в некотором множестве дежиты. По факту мы можем сказать, давайте
[07:59.060 --> 08:04.060]  кодировать это двумя индексами элементов и и g. Но с точки зрения реализации алгоритма,
[08:04.060 --> 08:12.380]  иногда вот это вот g заменяют и пишут, что вот эта вот штука, вот эта вот история находится в
[08:12.380 --> 08:18.340]  некотором множестве, которое индексируется позиции g. Сейчас я попытаюсь объяснить,
[08:18.340 --> 08:26.300]  что же такое и и g. Для этого давайте я немножко перерисую наше дерево. Как оно у нас выглядело?
[08:29.060 --> 08:49.060]  И у нас слово ABB. И теперь смотрите. Вот если мы находимся вот в этом месте,
[08:49.060 --> 08:58.580]  у нас полая точка находится здесь, а жирная точка находится, я не предположим, где-то здесь.
[08:58.580 --> 09:07.260]  Это значит, что на самом деле мы находимся с вами в следующей ситуации. Давайте это пример.
[09:07.260 --> 09:17.220]  У нас будет что? Мы находимся в ситуации s стрелочка, а s точка. Видите, точку посередине
[09:17.220 --> 09:28.260]  этого правила ставим. B, S. Дальше. Смотрим, где у нас вот эта точка находится полая.
[09:28.260 --> 09:53.220]  Сколько букв мы до этого прочитали? Одну, одну. Да, да, да. Одну. Да, слева от полой точки,
[09:53.220 --> 10:05.140]  от родительской точки. Как вы думаете, жирную точку чем кодируем? А жирная точка это позиция,
[10:05.140 --> 10:18.060]  которая находится здесь. То есть сколько мы прочитали на текущий момент? Два. Что это за
[10:18.060 --> 10:23.420]  конструкция? Это по факту мы говорим, что нам вообще по боку что происходит в другой вещь.
[10:23.420 --> 10:29.100]  Мы можем, грубо говоря, из-за того, что мы обходим наше дерево обходом в глубину, нам важно только,
[10:29.100 --> 10:35.620]  где мы находимся в вытекущем правиле, где находится позиция точки, мы ее кодируем по факту. Поскольку
[10:35.620 --> 10:42.780]  мы разбираем определенное слово, то мы можем кодировать позиции в данном слове. И нам важно
[10:42.780 --> 10:52.540]  позиции вот этой точки. И мы ее кодируем позиции опять же в слове. А чтобы выпрыгивать потом из
[10:52.540 --> 10:57.900]  дерева вверх. То есть мы обошли все под дерево целиком, нам надо подняться наверх.
[10:57.900 --> 11:11.900]  Ну да, а при этом нам надо хранить вариант, где же позиция находится у родителя. То есть когда у нас
[11:11.900 --> 11:21.340]  есть два под дерево вывода, у нас точка находится здесь, точка находится здесь, то для этой точки нам
[11:21.340 --> 11:29.900]  необходимо выяснить, а где же позиция полой точки для этой точки. Чтобы без рекурсии достаться.
[11:29.900 --> 11:36.780]  Это будет перебором делать.
[11:36.780 --> 11:58.860]  Где-где-где? Вот тут?
[11:58.860 --> 12:08.460]  А черная точка должна встать вот сюда.
[12:08.460 --> 12:21.500]  Ну смотрите, давайте немножко разберем. Если мы дойдем до сюда, это значит, что мы сколько символов
[12:21.500 --> 12:30.380]  прочитали? Три. То есть у нас ситуация будет С-стрелочка, А, С, Б, С-точка. Значит сколько? Один-три?
[12:30.380 --> 12:46.980]  Три-три-три, это бы они прочитали еще. Эпсилон это не буква, это пустое слово. Конечно же, это пустое
[12:46.980 --> 12:58.420]  слово. Мечтаем, конечно же, терминал. Теперь смотрите, вопрос, если мы вот эту вот точку,
[12:58.420 --> 13:05.660]  которая у нас есть, поднимем наверх, сколько терминалов мы в данный момент прочитаем? Все,
[13:05.660 --> 13:12.460]  еще три. А теперь смотрите, смотрим вот в это правило, которое у нас здесь было.
[13:12.460 --> 13:35.780]  Какое? Вот теперь вот как раз к этому мы сейчас потихонечку переходим. Как склеивать эти все
[13:35.780 --> 13:43.620]  истории? То есть наша цель теперь научиться склеивать эти истории. Я утверждаю, значит это
[13:43.620 --> 13:49.820]  полгородство утверждает, что имея только вот эту информацию, мы можем грамотно склеивать все
[13:49.820 --> 14:01.940]  переходы. И наша цель сейчас определить эти три правила. Информация, значит как, значит это
[14:01.940 --> 14:06.900]  информация о том, где мы сейчас находимся в деле вывода, сколько мы разобрали до, сколько мы
[14:06.900 --> 14:21.020]  разобрали сейчас, и где мы сейчас находимся именно в конкретном правиле. Да, да, да. Ну теперь нам
[14:21.020 --> 14:26.780]  надо грамотно это все соединить. А дальше, когда мы увидим основную лему, которую мы будем доказывать,
[14:26.780 --> 14:41.060]  индукции в обе стороны, мы как раз и сложим наш пазл. Один, значит это сколько терминалов мы
[14:41.060 --> 14:47.340]  прочитали слева от этой точки вообще во всем дереве, а это сколько терминалов мы прочитали
[14:47.340 --> 15:01.060]  слева от этой точки. Собственно, барочка примеров. Скажите позиции белой точки и черной точки.
[15:01.060 --> 15:14.540]  4, 4, да. Значит это ситуация S стрелочка точка 4 принадлежит D4. Молодцы. Так, это мы уже закодировали,
[15:14.540 --> 15:24.420]  это С стрелочка АС точка БС, один принадлежит D2. А теперь смотрите, как мы будем это все мачить.
[15:24.420 --> 15:31.820]  Три операции. Значит будет три операции. Я обычно, если у меня есть цветные маркеры, а у меня нет
[15:31.820 --> 15:37.500]  тут цветных мелов, к сожалению, я их обозначаю тремя разными цветами. То есть scan. Это нам
[15:37.500 --> 15:44.980]  позволяется читать терминал, предикт. Будем спускаться вниз, пытаться предсказать,
[15:44.980 --> 15:50.660]  по какому правилу нам надо раскрываться. И третья история, это комплит. Мы поднимаемся наверх.
[15:50.660 --> 16:01.180]  Это пишется следующим образом. G это математический термин, а DG это как бы прогерский термин,
[16:01.180 --> 16:06.420]  потому что мы вот эти штуки будем хранить в определенном множестве. То есть DG это на самом деле
[16:06.420 --> 16:15.060]  set. То есть у нас есть переменная D, а в нем G это индекс. Итак, давайте подумаем. Если нам
[16:15.060 --> 16:20.980]  надо прочитать букву А, вот в данном моменте, мы находимся в такой определенной ситуации.
[16:20.980 --> 16:27.740]  Какая ситуация будет корректная после того, как мы прочтем эту букву? Я пока ищу сухую тряпку.
[16:27.740 --> 16:48.340]  Да-да-да, именно так. Это описание базовых шагов алгоритма. Сейчас он появится, подождите.
[16:48.340 --> 16:56.100]  Просто пока мы эти шаги не разберем, мы не сможем алгоритм построить.
[16:56.100 --> 17:19.920]  Смотрите. И при этом у нас важно, что G-тое букво равняется А. То есть как бы мы смотрим на наше
[17:19.920 --> 17:27.840]  слово, вот оно слово W, и вот она G-тое букво, она А. То есть мы в принципе и в текущем слове ее
[17:27.840 --> 17:33.400]  можем прочитать. То есть повезло. Так что в той позиции, в которой мы находились, за следующую
[17:33.400 --> 17:42.080]  букву А, которая есть. И если у нас есть такая ситуация, то при помощи операции scan и выполненной
[17:42.080 --> 17:56.240]  этой условия, то мы можем перейти в ситуацию такого рода. Вот мы теперь при помощи операции scan
[17:56.240 --> 18:13.080]  можем прочитать букву. Да, принимает дожитое и по факту пытается прочитать. Ну принимает множество
[18:13.080 --> 18:18.680]  всех ситуаций, которые находятся на текущей позиции. То есть нам надо прочитать букву по факту.
[18:18.680 --> 18:29.880]  Она берет все ситуации такого типа, проверяет может ли сдвинуть точку. И двигает точку для
[18:29.880 --> 18:44.120]  всех ситуаций, в которых буква G плюс один совпала. Ну да множество всех ситуаций, да.
[18:44.120 --> 19:02.800]  Да, мы храним все возможные ситуации, которые оканчиваются в джитое позиции. И дальше нам
[19:02.800 --> 19:13.480]  надо будет перестраивать это множество лавинообразно. Вот смотрите, со scan вот такая история. Теперь давайте
[19:13.480 --> 19:24.200]  вторую операцию рассмотрим. Оказалось все так, что у нас с вами есть не терминал, который нам
[19:24.200 --> 19:42.480]  мешает продвинуться дальше. Ну а мы можем его раскрыть по какому-то правилу. Ну повезло нам
[19:42.480 --> 19:48.400]  найти правила. Правил может быть несколько. Значит у нас была ситуация A стрелочка альфа
[19:48.400 --> 19:58.560]  точка B бета. И принадлежит джитое. Но есть правила грамматики. Давайте подумаем какую
[19:58.560 --> 20:14.400]  ситуацию мы с вами можем нарисовать. B стрелочка точка гамма. Давайте нарисую дерево.
[20:14.400 --> 20:38.400]  Смотрите, точка опускается вниз. Мы добавляем такую ситуацию. Если мы стоим перед не терминалом,
[20:38.400 --> 20:46.080]  и оказывается есть правило, которое может раскрывать этот не терминал. Пока нормально, да?
[20:46.080 --> 21:02.360]  Так, осталось последнее. Потому что вот эта позиция это житое позиция в слове. Когда мы
[21:02.360 --> 21:10.680]  спускаемся вниз, то сколько букв мы читаем? Ноль. Значит текущая позиция точки, когда мы
[21:10.680 --> 21:18.120]  спустимся вниз, она будет житой. А вот эта точка мы знаем, что она кодирует житую позицию. А эта
[21:18.120 --> 21:31.120]  точка стала вот такой полой точкой, поэтому это тоже житое. Отлично, разобрались. Давайте я сейчас
[21:31.120 --> 21:52.680]  нарисую дерево. Оно будет трехэтажным. Смотрите, мы закончили разбирать какое-то дерево. У нас
[21:52.680 --> 22:06.440]  картинка такая. Полая точка здесь, такая точка здесь. Тогда смотрите, что мы можем сделать. Мы с
[22:06.440 --> 22:18.800]  вами можем понимать следующее, что у нас есть B, стрелочка гамма. О, господи, точка. Давайте обозначим
[22:18.800 --> 22:27.360]  эту позицию к принадлежит дожитому. Теперь смотрите, давайте поймем, когда мы можем сдвинуть точку.
[22:27.360 --> 22:37.720]  Когда у нас мы в какой-то ситуации находились перед ней терминалом B. Мы находились с вами перед
[22:37.720 --> 22:44.960]  ней терминалом B. Нам надо достать правило, в котором точка находилась перед ней терминалом B.
[22:48.800 --> 22:57.920]  Тот же самый. Нет, мы читаем, а дальше мы будем лупаться между вот той операцией,
[22:57.920 --> 23:09.520]  вот той операцией. Живет в произвольной G, сейчас когда алгоритм откроем. Давайте отмотаемся,
[23:09.520 --> 23:15.560]  как эта штука у нас была получена. У нас была ситуация, здесь была родительская точка, здесь
[23:15.560 --> 23:24.600]  у нас альфа точка B бета. Здесь вот эта позиция, это позиция под индексом K, потому что позиция этой
[23:24.600 --> 23:38.840]  точки под индексом K. Это то, что было до этого. Давайте закодируем эту позицию точкой некоторым
[23:38.840 --> 23:47.320]  индексом И. Это значит, что из этой штуки у нас была ситуация вида, а стрелочка альфа точка B бета.
[23:47.320 --> 24:00.120]  Что у нас получается? И теперь мы берем и объединяем две истории и можем двигать точку.
[24:00.120 --> 24:16.960]  Сейчас, то есть мы можем, имея вот эту точку, имея вот это вот под дерево, вот имея вот эту
[24:16.960 --> 24:23.520]  точку и имея закрытое правило вывода, наконец-таки сдвинуть эту точку, то есть прочитать это под
[24:23.520 --> 24:24.520]  дерево целиком.
[24:53.520 --> 25:00.120]  То есть имея вот такую вот такую ситуацию, мы добавляем вот такую ситуацию.
[25:00.120 --> 25:25.380]  Да, да, да, именно так. Ну да, мы продвинулись, но поэтому добавляем. Да, предыдущий нельзя
[25:25.380 --> 25:37.740]  убирать, она еще может понадобиться. Да, это все возможные варианты разбора. Да, да, да, да.
[25:37.740 --> 25:53.860]  Да, ну ничего, мы боремся за симптонику. Вот такая картинка. Итак, у нас есть три базовых операции.
[25:53.860 --> 26:09.420]  Значит, scan, predict, complete. Теперь нам надо с вами... Комплит будет принимать множество. Доставать
[26:09.420 --> 26:18.620]  все ситуации, которые были здесь. К, лупаться по К. Причем искать именно те терминалы, которые
[26:18.620 --> 26:32.780]  находятся в левой части правила. Точку перед левыми частями правила. Да, сейчас будет псевдокод.
[26:32.780 --> 26:45.020]  Ну давайте, ладно, раз уж пьянка такая пошла, то давайте псевдокод complete напишем.
[26:45.020 --> 27:10.180]  Значит, смотрите, эффективная структура хранения данных в данном случае будет следующая. Множество
[27:10.180 --> 27:20.620]  будет храниться так. ДКТ от Б. Это множество всех не терминалов, которые имеют вид А. Множество всех ситуаций,
[27:20.620 --> 27:31.420]  которые имеют следующий вид. А, стрелочка Альфа, точка Б бета. Да, но при этом нам, понятно,
[27:31.420 --> 27:38.260]  у этой структуры данных необходимо, чтобы у нас хранился левый элемент быстро. Значит, собственно,
[27:38.500 --> 27:50.340]  правила грамматики, на всякий случай, и позиция родителя. Ну да, позиция, где мы находимся в
[27:50.340 --> 28:01.660]  текущем правиле. Давайте лев назовем. Так, ну поехали. Значит, нам нужно что сделать.
[28:01.660 --> 28:18.340]  ДКТ, ой, completed дежитово. 4. Что нам надо сделать? Нет, на самом деле, я утверждаю, что нам
[28:18.340 --> 28:31.540]  нужно пойти for. Смотрите, почему эта структура данных интересна. Доллар от конца слова. То есть
[28:31.540 --> 28:53.820]  нам надо выдернуть все ситуации, в которых точка находится в конце. Тоже заводим такие. То есть это
[28:53.820 --> 28:58.140]  по факту вот здесь будет храниться следующая позиция, следующий терминал или не терминал после точки.
[29:01.540 --> 29:09.140]  Вот. Ну и что нам надо взять тогда? То есть fo, b, стрелочка, гамма, точка, к, ind, dj. Дальше нам
[29:09.140 --> 29:37.700]  нужно обратиться с вами. Куда? Да-да-да. Да-да-да. Во. Да. То есть мы обращаемся к множеству
[29:37.700 --> 29:49.900]  DKTB. Здесь дежитовый доллар, здесь DKTB. И добавляем множество дежитов. На самом деле, чтобы честно,
[29:49.900 --> 30:03.380]  тут надо сделать... А? А чего? У нас вроде все маппится. Ну, if можно там, если, допустим,
[30:03.380 --> 30:08.540]  у нас на этой штуке еще какой-нибудь хэшмап навешан, чтобы не добавлять лишние множества в сет.
[30:08.540 --> 30:18.220]  Лишние ситуации, чтобы не добавлять. Лишние ситуации не добавляют множество дежитов. Но
[30:18.220 --> 30:34.460]  собственно, djt это получается а, стрелочка, альфа. Кстати, так. Так, что нам надо добавить и? Так,
[30:34.460 --> 30:47.020]  еще смотрите. Здесь бы полезно знать первую букву от b. От бета. Ну да. На всякий случай.
[30:48.220 --> 30:58.220]  Все равно может что ферс Виталий введет на следующей лекции, поэтому пусть оно сейчас появится.
[30:58.220 --> 31:09.980]  Все равно Виталий на следующей лекции будет вводить множество ферс. Да, ладно, да. В случае да,
[31:09.980 --> 31:15.300]  а там будет это вывод первой буквы. В общем, это первый терминал или не терминал, который у нас
[31:15.300 --> 31:24.340]  находится в В. Собственно, вот такой вот алгоритм. На самом деле, давайте чуть-чуть про оптимизация.
[31:24.340 --> 31:42.820]  Тут надо писать дельту. Да, если это djt от ферс бета. Так, рубрика оптимизации. Значит,
[31:42.820 --> 31:54.740]  поскольку первый символ, который есть у нас в бете. Но бета нулевое можно написать. Да,
[31:54.740 --> 32:08.420]  просто бета может состоять из нуля символов, тогда это доллар. Да, конечно. Вот, значит,
[32:08.420 --> 32:14.660]  про оптимизацию. Потому что, если вы сейчас так будете писать алгоритм, вы получите алгоритм
[32:14.660 --> 32:27.500]  за четвертую степень. А у нас как бы коккянгеракасами закуп работает. Тут не djt,
[32:27.500 --> 32:34.180]  тут дельта djt. То есть необходимо отслеживать изменения, которые мы добавляем в множество.
[32:34.180 --> 32:42.940]  Давайте я поясню почему. Давайте чуть-чуть вперед забежим. Алгоритм просто я покажу.
[32:42.940 --> 32:56.740]  Он гипотетически пытается строить дерево, всевозможные деревья вывода для префиксов нашего слова.
[32:56.740 --> 33:05.820]  Значит, смотрите. Помните, как мы грамматику в нормальной форме Хомского приводили? Помните,
[33:05.820 --> 33:16.340]  мы добавляли новое стартовое состояние? s'. Чтобы избавиться от s в правых частях правил.
[33:16.340 --> 33:25.140]  Вот, здесь всегда добавляется правило s'. Для того, чтобы мы явно могли задать правила вывода.
[33:25.140 --> 33:31.940]  То есть всегда добавляем правило это. И тогда мы точно с вами можем оттрекать,
[33:31.940 --> 33:36.180]  когда у нас старт алгоритма. Старт алгоритма у нас начинается в том случае,
[33:36.180 --> 33:41.180]  когда у нас есть ситуация s'. Стрелочка точка s, d0 принадлежит d0.
[33:41.180 --> 34:08.020]  Стрих выводит s, точка здесь, точка здесь. Конец. Как вы думаете, успешный конец когда будет?
[34:08.020 --> 34:36.460]  Ноль. Так, отлично. В общем, вот это алгоритм.
[34:36.460 --> 34:53.380]  Всевдокод. Значит, d0 это множество из одной ситуации. Дальше, пока наше множество d0 изменяется,
[34:53.380 --> 35:06.260]  мы выполняем комплит и предикт. Что, почему, что? Ну, мы насыщаем, мы пытаемся найти все
[35:06.260 --> 35:14.100]  возможные ситуации, которые заканчиваются, не разобрав еще ни одной буквы. Ну, по сути,
[35:14.100 --> 35:21.060]  шлейф будем хранить, который будет строить все возможные деревья вывода до тех пор,
[35:21.060 --> 35:24.620]  пока мы не разобраем первую букву. Потому что у нас первый не терминал, может раскрываться,
[35:24.620 --> 35:37.140]  раскрываться, раскрываться, раскрываться. А? Пример? Ну, окей, пример. Значит, s-штрих выводит s.
[35:37.140 --> 35:59.820]  Блин, зачем я пишу? s-a-s-b, s-a-s-v. Изначально у нас в d0 лежит следующее. s-штрих стрелочка s,
[35:59.820 --> 36:10.780]  точка s0, потом мы спускаемся вниз, раскрываем s-a-s-b0, потом мы еще спускаемся вниз, раскрываем эту
[36:10.780 --> 36:16.940]  всю штуку вот так. То есть мы, грубо говоря, спускаемся максимально вниз по дереву вывода до
[36:16.940 --> 36:26.460]  тех пор, пока мы не можем прочитать одну букву. И нам надо хранить все возможные спуски. Потом
[36:26.460 --> 36:34.140]  читаем букву, повторяем те же самые действия. Смотрите, тут важно в алгоритме, что пока дожитое
[36:34.140 --> 36:41.060]  меняется, мы выполняем эти стадии. Значит, кто понимает, как в этом алгоритме не напортачить и
[36:41.060 --> 36:50.780]  нормально написать псевдокод, чтобы он работал не за большую асимпточку? Ну, если его алгоритм
[36:50.780 --> 37:01.740]  вот так реализовать, это будет работать за пятую степень. Да, complete и predict должны возвращать
[37:01.740 --> 37:06.740]  изменения. И complete и predict в новых итерациях мы должны запускать только от новых полученных
[37:06.740 --> 37:28.020]  правил, от новых полученных ситуаций. Вот. Ну да, мы просто построили D0. А, вот, смотрите, вот,
[37:28.020 --> 37:33.500]  смотрите, вот раз, вот два. Мы уже обошли дерево с точкой, поэтому мы должны вот эту штуку передвинуть.
[37:33.500 --> 37:53.380]  Вот. Ноль. Ну да, тогда наша D0 заканчивается, мы переходим, может, туда идем. Когда мы не
[37:53.380 --> 38:02.220]  можем в операция complete и predict не добавить ни одного ситуации в нашей D0? Ну да, ну давайте
[38:02.220 --> 38:07.500]  попытаемся опуститься вниз, вроде опуститься вниз не сможем, закомплитить вроде тоже. А, не, подождите.
[38:07.500 --> 38:27.900]  Да. Complete вот этого правила и вот этого правила. Теперь все. Да, мы разобрали D0, да, теперь дальше
[38:28.380 --> 38:42.060]  если на что пустое мы победили, иначе двигаемся дальше. Мы по факту взяли и построили все деревья
[38:42.060 --> 38:47.340]  вывода, все, так сказать, ситуации, в которых мы могли оказаться во всех возможных гиптических
[38:47.340 --> 38:57.380]  деревьев вывода, не разобрав еще ни одной буквы. Вот. А блин, тут картинки рисовать, это уже, я не знаю,
[38:57.380 --> 39:05.580]  вы умеете рисовать на двумерной доске так, чтобы была трехмерная картинка? Вот я не умею. Нет,
[39:05.580 --> 39:11.780]  у нас сет деревьев выводов. Для разных возможных ситуаций. Для разных возможных ситуаций, для всех
[39:11.780 --> 39:17.460]  возможных слов, которые выводят в этой грамматике, но при этом мы еще ни одну букву не разобрали.
[39:17.460 --> 39:31.620]  Раз, два, три, четыре, пять ситуаций тут. Да, да, попытаться делать скан от них. Ну,
[39:31.620 --> 39:46.180]  понятно, что тут только одна ситуация подойдет. Рекурсивный спуск работает далеко не для всех
[39:46.180 --> 39:52.740]  грамматик. Да, еще он экспоненциальный. Да, он работает для всех грамматик, но за экспоненту.
[39:52.740 --> 39:57.260]  Этого алгоритма все-таки детерминированный. Почти. Кстати, для однозначных грамматик он работает
[39:57.260 --> 40:11.420]  за квадраты длины. Круто. А теперь физический смысл в математических терминах. Собственно,
[40:11.420 --> 40:17.980]  это основная лемма алгоритма Эрли, которая, если вы не поняли то, что я пытался донести в картинках,
[40:17.980 --> 40:25.740]  вот вам, собственно, то, что это формулируется. Давайте я выпишу эту лему, потому что...
[40:25.740 --> 40:47.500]  Так, коричительные напитки пошли. Значит, что там у нас? Можете продиктовать.
[40:47.980 --> 41:13.580]  Альфа выводит.
[41:17.980 --> 41:28.700]  Кстати, тут сразу скажу, что G включено. И тоже включено. А, не, подождите.
[41:28.700 --> 41:54.580]  Плохо. Тогда, ну по факту, черт, ладно, сейчас будем переписывать. Смотрите, в общем,
[41:54.580 --> 42:05.700]  идея такая, что мы с вами берем, разбираем все, что у нас было до этого слова. А, С. И дальше
[42:05.700 --> 42:23.420]  мы за один шаг берем и раскрываем эту ситуацию. Теперь в дереве. То есть, если у нас встретилась
[42:23.420 --> 42:29.420]  такая ситуация в алгоритме Эрли, она могла встретиться тогда и только тогда, когда у нас
[42:29.420 --> 42:35.380]  существует замечательное вот такое дерево вывода. Что у нас здесь выводится слово от нуля до итого.
[42:35.380 --> 42:44.860]  Дальше у нас есть АПСИ, которое за один шаг раскрывается, значит, по альфа бета, а потом из альфы
[42:44.860 --> 42:59.340]  выводится слово с итого до итого. Так, секунду. Ну давайте подумаем. Мне кажется, если говорить
[42:59.340 --> 43:12.540]  в честных питоновских определениях, то тут надо писать I-1 и G-1. В смысле? Ну смотрите,
[43:12.540 --> 43:26.140]  по факту вот здесь позиция родительской точки, а здесь позиция нашей точки. Это перевод картинки.
[43:26.140 --> 43:31.380]  То есть, здесь столько, сколько мы разобрали до родительской точки. Это позиция слова с нулевого
[43:31.380 --> 43:40.500]  до итого. То есть, сколько букв мы разобрали. А, стоп, у нас ноль нумераций, я дебилу кусок. Ну,
[43:40.580 --> 43:57.140]  вы же знаете, кто у нас лектор. Так, а здесь мы разобрали G-букв. Все, ура. Так, ну в общем. Так,
[43:57.140 --> 44:04.260]  это лемма, на самом деле, одна из самых сложных лемм, которые я буду доказывать в курсе. Собственно,
[44:04.260 --> 44:14.660]  угадайте, в какую сторону сложнее? Слева направо или справа налево? Справа налево намного сложнее.
[44:14.660 --> 44:28.420]  Что, вы хотите слева направо или справа налево? Доказывать будем. Ладно, давайте пожалеем.
[44:28.420 --> 44:36.700]  Начало докажем слева направо. Слева направо это индукция по количеству шагов алгоритма.
[44:36.700 --> 45:00.380]  База какая? Так, мне кажется, надо мне выписать все шаги. Значит, тут уже математика, поэтому давайте
[45:00.380 --> 45:08.380]  выпишем все шаги, которые у нас есть. Значит, scan это у нас, если у нас есть ситуация alpha точка a
[45:08.380 --> 45:19.060]  beta i принадлежит dg, то из этого мы делаем с вами alpha стрелочка alpha a точка beta i принадлежит dg
[45:19.060 --> 45:36.180]  плюс один. Предикт. У нас a стрелочка alpha точка b beta i принадлежит dg, есть b стрелочка гамма,
[45:36.180 --> 45:47.940]  принадлежащая правилам грамматики, то мы из этого получаем b стрелочка точка гамма, g принадлежит dg тому и complete
[45:47.940 --> 46:06.940]  Господи, b стрелочка гамма точка k принадлежит dg тому, a стрелочка alpha точка b beta i принадлежит dk тому,
[46:06.940 --> 46:23.420]  то мы можем двигать точку. Так, ну поехали, значит база. За сколько шагов? В первом шаге что мы делаем?
[46:23.420 --> 46:31.460]  На первом шаге у нас добавляем ситуацию a стрих стрелочка точка s.
[46:31.460 --> 46:50.060]  Че нам надо подобрать вот такую вот цепочку. Так, ну давайте выводить.
[46:50.060 --> 47:12.500]  V00 s штрих phi, ну тут просто s штрих, да, то есть в нашем случае получается psi будет равно
[47:13.100 --> 47:24.660]  и дальше за один шаг что мы выводим с вами? Эпсилон, вот этот эпсилон переходит в этот эпсилон,
[47:24.660 --> 47:45.260]  дальше мы выводим v00 s. Вот, ну собственно вот эта штука у нас эпсилон s и она нам кодирует как раз
[47:45.260 --> 47:51.180]  необходимую ситуацию. То есть мы просто расписали вывод s штрих выводит s в тербинах вот этой штуки.
[47:51.180 --> 48:05.300]  Вот это понятно? Ага, хорошо. Ну переходы будут такие, Миша, приблизительно. Ну переходы,
[48:05.300 --> 48:18.380]  значит какие у нас три стадия алгоритма могут быть? Давайте рассмотрим что происходит при скане.
[48:18.380 --> 48:26.220]  Давайте я наверное на отдельной доске буду писать, потому что я не хочу мельчить.
[48:26.220 --> 48:40.180]  Ну берем, короче, считаем, что каждый шаг алгоритма, каждая строчка алгоритма,
[48:40.180 --> 48:45.260]  которая мы исполнили при добавлении чего-то в джитово, это эффективный шаг в алгоритме.
[48:45.260 --> 48:50.060]  То есть как только какое-то множество мы что-то добавляем, это эффективный шаг.
[48:50.060 --> 48:59.820]  Так, переход. Значит, смотрите, у нас было правило, мы находились с вами в ситуации вот такой,
[48:59.820 --> 49:11.180]  а стрелочком альфа точка а бета и принадлежит джитому. Что это значит? По предположению индукции
[49:11.180 --> 49:29.260]  у нас есть такая цепочка вывода. Значит, мы из а штрих выводим в нолито, дальше верхнюю часть
[49:29.260 --> 49:52.700]  а, пси, дальше за один шаг мы выводим в нолито альфа точка а бета, так а, бета, так пси. При этом у
[49:52.700 --> 50:02.900]  нас, смотрите, из альфы будет выводиться слово ситово по-житому. Ага, а тогда скажите мне,
[50:02.900 --> 50:20.900]  что выводится из альфа а? Какое слово выводится? Ага, потому что у нас буква совпадает. Вот,
[50:20.900 --> 50:35.020]  а это значит, что мы в принципе за один шаг с вами альфа и бета. И вот это вот слово уже выводит
[50:35.020 --> 50:48.100]  джит плюс один. То есть мы по факту двинули точку. Да, если мы сейчас обозначим альфа штрих альфа
[50:48.100 --> 50:57.460]  а, то у нас индукционный переход выполнится. То есть вот это заменяем на альфа штрих и смотрим на
[50:57.460 --> 51:09.220]  индукционную картинку. Понятно, как делается шаг? Да, это мы сделаем скан. Это просто тут небольшое
[51:09.220 --> 51:32.980]  переобозначение. Давайте сделаем предикт комплит. Итак, предикт. У нас с вами было правило
[51:32.980 --> 51:50.220]  альфа точка б бета. Так, смотрите, давайте писать. Значит, что у нас есть? У нас из С. Есть вывод
[51:50.220 --> 52:08.460]  в 0 и т, а пси. Дальше за один шаг мы выводим с вами что? В 0 и т альфа б бета пси. При этом альфа у нас
[52:08.460 --> 52:33.580]  выводит слово в и ж. Давайте я тут вот это вот перенесу. Теперь, смотрите, сделаем финтушами. Мы
[52:33.580 --> 52:41.700]  понимаем с вами, что альфа выводит в и ж. Поэтому здесь мы можем заменить в 0 и т. Здесь мы пишем
[52:41.700 --> 52:50.540]  б бета пси. А теперь давайте сделаем еще один шаг вывода в этой штуке и раскроем не терминал b.
[52:50.540 --> 53:05.060]  В 0 и т. Вот здесь вот у нас будет в и ж и т, которое нам необходимо будет. Здесь будет гамма бета пси.
[53:05.060 --> 53:18.220]  Вот это мы с вами обозначаем как пси штрих. Да, и получаем. Смотрите, у нас из b выводится гамма.
[53:18.300 --> 53:27.460]  Та позиция, которая у нас была с точкой точкой находится здесь. А мы хотим, у нас из предикта,
[53:27.460 --> 53:34.420]  что получается? Что b это стрелочка точка гамма, ж принадлежит джи. То есть у нас добавляется эта
[53:34.420 --> 53:42.820]  штука. Ну здесь она и добавляется. То есть смотрите, получается до b мы разобрали g позиции. Перед гаммой мы
[53:42.820 --> 53:50.140]  тоже разобрали g позиции. Вот, поэтому то, что мы хотим в лемме индукционный переход для предикта
[53:50.140 --> 54:12.620]  тоже выполнен. Ага, или не ага? Не, а? Понятен ли этот этот шаг как расписан? То есть мы из
[54:12.860 --> 54:19.420]  мы сделали следующее. Мы явно раскрыли b и альфу вывели. Мы узнаем, что из альфы выводит w и gt
[54:19.420 --> 54:26.140]  по предположению индукции, потому как у нас инвариант сохраняется. Получается v0 и v и gt
[54:26.140 --> 54:34.940]  получаем v0 gt. Вот, а дальше за один шаг вот как раз вот этот вот b за один шаг раскрывает гамму,
[54:34.940 --> 54:43.700]  добавляя w gt. Собственно, что нам требовалось в инварианте? То есть как только наш не
[54:43.700 --> 54:49.700]  терминал, который в левой части ситуации находится, раскрывается, то из того, что находится за точки,
[54:49.700 --> 54:52.980]  выводится в позиции сытого до житого. Наш стучит в позиции с житого до житого.
[54:52.980 --> 55:09.300]  Здесь? Альфа штрих эпсилон, а бета штрих это гамма.
[55:09.300 --> 55:25.340]  А теперь, как говорится, Кракен подберите рифму сами.
[55:25.340 --> 55:44.620]  Комплит. Так, значит у нас есть ситуация. А стрелочка, альфа точка б бета и принадлежит
[55:44.620 --> 55:56.620]  до катому и бета стрелочка гамма точка катая принадлежит до житому. Давайте напишем для вот
[55:56.620 --> 56:04.700]  этой штуки предположение индукции. Значит, для вот этой штуки шагов-то меньше было. Мы получаем
[56:04.700 --> 56:15.380]  следующее, что у нас из с выводится в нулевое и, потом у нас выводится а, потом выводится у
[56:15.380 --> 56:26.860]  нас какой-то фи, потом за один шаг у нас выводится из в нулевого и, альфа у нас раскрывается как альфа
[56:26.860 --> 56:42.860]  б, альфа б бета, си. А при этом, смотрите дальше, что происходит. Дальше нам надо твинуть точку за
[56:42.860 --> 56:59.740]  не терминал b. Ну, смотрите, что мы понимаем, что в тот момент, когда мы с вами раскроем бета за
[56:59.740 --> 57:13.780]  один шаг. Давайте напишу в нулевое и т. Значит, альфа у нас раскрывается во что? Альфа у нас это
[57:13.780 --> 57:35.680]  w и kt, b бета, си. Да, а b из вот этой штуки. Если внимательно посмотреть, у нас из бета,
[57:35.680 --> 57:45.200]  как только мы раскрыли бету, то у нас из гаммы будет выводиться символ с катова пожитого.
[57:45.200 --> 57:59.120]  Да, это из предположения индукции будет. Ага, а это значит, что из бета выводится символ с катова
[57:59.120 --> 58:15.120]  пожитого. Ну и получается, что альфа бета у нас выводит символ с этого пожитого. То есть,
[58:15.120 --> 58:25.280]  в нашем случае альфа штрих будет равно альфа бета, бета штрих будет равняется бета. И, собственно,
[58:25.280 --> 58:33.480]  у нас появляется правило. Тут давайте напишу. А, стрелочка альфа, б, точка бета. И принадлежит
[58:33.480 --> 58:40.280]  дожитая. Ну, собственно, оно и появляется. То есть, у нас все, что было от нулевого до итого,
[58:40.280 --> 58:45.680]  мы раскрыли. Потом альфа штрих, который у нас альфа бета, получается, выводит с итого пожитого,
[58:45.680 --> 58:59.800]  и точка встает сюда. Где? Альфа б. Альфа выводит с итого до катого, б выводит с катого пожитого.
[58:59.800 --> 59:20.080]  Что, сошлось? Мне кажется, все в ауте. Тонкая манипуляция с теми фактами, которые у нас
[59:20.080 --> 59:26.200]  получаются. То есть, здесь главное, значит, все, что до точки, у нас на самом деле будет
[59:26.200 --> 59:34.440]  выводить символы скатого дожитого. Вот. Собственно, раскрываем эту штуку. Поскольку у нас бета выводит
[59:34.440 --> 59:40.800]  гамма с точкой, то бета выводит то же самое правило. Значит, бета может вывести дв скатого
[59:40.800 --> 59:47.800]  поджитого. Подставляем сюда, получаем. Собственно, из того, что альфа выводит еще тут. Это у нас по
[59:47.800 --> 01:00:01.920]  предположению. Конкатенируем это, получаем альфа, выводит w и т ж т. Это переход в одну сторону.
[01:00:01.920 --> 01:00:15.920]  Я боюсь, товарищи. Давайте соберемся с силами. Это была простая часть.
[01:00:31.920 --> 01:00:45.080]  Индукция по трем параметрам. Давайте я добавлю здесь некоторые индексы. Значит, смотрите, первая
[01:00:45.080 --> 01:00:55.760]  индукция это по параметру g. При равенстве g мы смотрим на суммарное количество выводов,
[01:00:55.760 --> 01:01:10.080]  которые у нас есть вот здесь и вот здесь. То есть смотрите, индукция по параметру g,
[01:01:10.080 --> 01:01:18.480]  по параметру k плюс l, то есть сумма длин вывода из альфы и из к. И если эта штука равняется,
[01:01:18.480 --> 01:01:29.600]  то мы смотрим на третий параметр l. Да, сколько шагов и с левой части правила нам
[01:01:29.600 --> 01:01:31.760]  понадобится для того, чтобы его раскрыть в слово.
[01:01:31.760 --> 01:01:59.440]  База. Нам надо найти ситуацию. Помогите.
[01:01:59.440 --> 01:02:09.600]  Смотрели мультик? Дора-путешественница. На русский язык переводится Даша-путешественница.
[01:02:09.600 --> 01:02:16.040]  Оригинал Дора. Скорее всего, на английском.
[01:02:16.040 --> 01:02:33.560]  Так, k равно 0, l равно 0. Так, ну давайте смотреть. Давайте поймем, что мы можем вывести за ноль
[01:02:33.560 --> 01:02:45.680]  шагов. За ноль шагов что мы вводим? s-штрих. Дальше за один шаг мы должны раскрыть этот s-штрих.
[01:02:45.680 --> 01:02:55.200]  Как мы можем раскрыть этот s-штрих за один шаг? Только в s. А дальше что нам надо сделать?
[01:02:55.200 --> 01:03:10.480]  Так, секунду. Нам надо из альфы тоже за ноль шагов что-то раскрыть. Что за ноль шагов у
[01:03:10.480 --> 01:03:18.080]  нас из альфа раскрывается? Пустое слово. То есть то, что стоит перед s. В нашем случае альфа равно
[01:03:18.080 --> 01:03:25.280]  пустое слово. И тогда какая ситуация у нас должна была возникнуть из этого?
[01:03:25.280 --> 01:03:35.920]  Можешь сообразить? Давайте подставлять. a равно s-штрих, альфа это эпсилон,
[01:03:35.920 --> 01:03:47.120]  а бета это у нас с. То есть у нас должно было появиться правило s-штрих.s0 принадлежит данной.
[01:03:47.120 --> 01:03:57.120]  То есть g равно нулю и тоже будет равняться нулею. А такая ситуация у нас есть? Да,
[01:03:57.120 --> 01:04:14.960]  мы с нее начинали. Так, базу доказали. Переход. Надо рассмотреть несколько случаев. Давайте
[01:04:14.960 --> 01:04:23.440]  рассмотрим последний символ не терминала a. Последний символ альфы. Давайте сейчас я
[01:04:23.440 --> 01:04:33.640]  проговорю сначала. Тут три случая возможны. Какие? Буква, не буква и эпсилон.
[01:04:33.640 --> 01:04:43.520]  Так, последний терминал альфы.
[01:04:53.440 --> 01:05:06.880]  Давайте рассмотрим первый случай. Альфа равно альфа-штрих b. Нагадываетесь какое у нас правило
[01:05:06.880 --> 01:05:16.680]  будет? Да, тут должен появиться скан. Ну, давайте смотреть. Значит, у нас получается из s-штрих,
[01:05:16.680 --> 01:05:24.160]  то давайте, наверное, деревьями рисовать. Потому что деревьями это вообще офигенно.
[01:05:24.160 --> 01:05:38.640]  У слайдов есть деревья. Смотрите. Вот так вот. Смотрите. Из альфы-штрих у нас выводится
[01:05:38.640 --> 01:05:50.800]  v и g-1. А выжитая буква значит символ b. И тогда у нас получается следующее, что у нас из s-штрих
[01:05:50.800 --> 01:05:59.200]  выводится альфа-штрих b бета-пси. То есть, смотрите, у нас мы знаем, что из альфы выводилось символ
[01:05:59.200 --> 01:06:15.160]  ситого до житого. Альфа равно альфа-штрих b. Следовательно, альфа-штрих выводил w и g-1, а b равно
[01:06:15.160 --> 01:06:24.160]  выжитая. А тогда давайте посчитаем просто аккуратненько, за сколько количество шагов мы
[01:06:24.160 --> 01:06:40.840]  выводили ту или иную вещь. Значит, смотрите. Из s-штрих, за те же k шагов, мы выводили v0 и t,
[01:06:40.840 --> 01:07:08.360]  аpsi. За один шаг мы вывели что? Альфа-штрих b бета-пси. Ну и понятно, что на самом деле из альфы-штрих,
[01:07:08.360 --> 01:07:16.120]  за то же самое количество шагов, мы вывели слово v и t g-1, потому что у нас ни в какие-нибудь
[01:07:16.120 --> 01:07:23.360]  терминалы не открываются. А теперь смотрите. У нас получается, что альфа-штрих выводило слово
[01:07:23.360 --> 01:07:30.680]  c и по g-1. Значит, в нашем дереве v0 и t за 1 шаг. Здесь количество шагов меньше. В итоге нам
[01:07:30.680 --> 01:07:41.160]  надо индукцию перевести для параметра g-1, k плюс l и k, k плюс l и l. Но для такого параметра индукция у нас верна.
[01:07:41.160 --> 01:07:51.800]  Да ведь? Ну мы индукцию сначала по параметру g делаем, потом по меньшему параметру. И в итоге
[01:07:51.800 --> 01:08:01.880]  получается, что, оказывается, из этого у нас была ситуация следующего рода, что из а мы, это
[01:08:01.880 --> 01:08:18.760]  предположение индукции, выводим альфа-точка b бета и принадлежит даже минус 1. Только мы делим
[01:08:18.760 --> 01:08:24.040]  эту часть на вот этот составляющий и вот этот составляющий. Ну а значит, наше правило, которое
[01:08:24.040 --> 01:08:31.800]  мы хотим показать. Как вот это правило тогда появляется у нас с вами? Если у нас есть вот эта
[01:08:31.800 --> 01:08:47.000]  ситуация и gt буква у нас b. Альфа-штрих. Значит, как это правило у нас могло появиться? Новое. Значит,
[01:08:47.000 --> 01:08:57.880]  применяя скан, мы получаем альфа-стрелочка альфа-бета-штрих бета-точка бета и принадлежит дожитое. А вот это как
[01:08:57.880 --> 01:09:20.760]  раз наша альфа. Так, понятна идея? Хорошо. Давайте следующий переход я нарисую на
[01:09:20.760 --> 01:09:42.360]  картинке, потому что иначе мы с вами будем очень-очень долго. Вот картинка. Значит, у нас из a-штрих за
[01:09:42.360 --> 01:09:53.480]  k шагов вывелось gt. Если что, мы рассматриваем в случае альфа-штрих равно альфа-бета. Альфа равно альфа-штрих
[01:09:53.480 --> 01:10:10.600]  бета. Апси. И дальше за один шаг мы смотрим, что такое альфа-штрих b-бета. А теперь смотрите
[01:10:10.600 --> 01:10:22.040]  чудеса. Мы понимаем с вами, что альфа-бета-штрих альфа-штрих бета за какое-то количество шагов k,
[01:10:22.040 --> 01:10:41.320]  за l шагов у нас выводит слово с итовопожитой. И теперь рубрика арифметика. Предположим,
[01:10:41.320 --> 01:10:58.200]  что у нас бета за один шаг выводит гамму. И мы закрываем это правилом. И теперь считаем,
[01:10:58.200 --> 01:11:09.680]  пусть вот эта штука за t раз у нас закрыла. Мы режем эту штуку пополам, получаем w. Сколько у
[01:11:09.680 --> 01:11:22.840]  нас получается с итово по м? Давайте считать количество шагов. В сумме вот здесь у нас должно
[01:11:22.840 --> 01:11:48.760]  быть l шагов. Значит здесь шагов l-t-1. Вmgt. Теперь смотрите. К сожалению, у меня нет цветных мелков,
[01:11:48.760 --> 01:11:55.920]  но тут надо заметить две картинки. Я их покажу двумя разными цветами. Смотрите, первая картинка,
[01:11:55.920 --> 01:12:10.800]  которую нам надо заметить, это вот этот вот вывод. И вот этот вот вывод. Для пары, смотрите,
[01:12:10.800 --> 01:12:22.800]  для пары g. Количество выводов здесь k плюс t и t. t меньше l, потому что здесь как минимум один
[01:12:22.800 --> 01:12:36.640]  шаг вывода есть. Мы получаем s штрих, ой, что из a выводится, что у нас выводится,
[01:12:36.640 --> 01:12:54.640]  а стрелочка, альфа штрих, точка b бета и принадлежит dmt. Потому что для вывода под вот
[01:12:54.640 --> 01:13:01.680]  этого вот подшага, для этого не терминала, нам потребуется в сумме меньше шагов. С другой стороны,
[01:13:01.680 --> 01:13:09.840]  вторая картинка. Тут внимательно, надо внимательно очень посмотреть. Давайте я их волнистой чертой обведу,
[01:13:09.840 --> 01:13:26.400]  либо обведу к крышке. Смотрите, давайте рассмотрим вот эту вещь и вот эту вещь. То есть как из этой
[01:13:26.400 --> 01:13:33.360]  штуки выводился этот кусок, а из этой штуки выводился первый кусок. Количество шагов здесь
[01:13:33.360 --> 01:13:56.360]  будет g. Считаем, значит k плюс t плюс l минус t минус 1 и плюс 1. Вот это? Смотрите, мы выводим альфа
[01:13:56.360 --> 01:14:01.360]  штрих только. Раскрываем только альфа штрих. Альфа штрих мы выводим за t шагов. Эту штуку мы выводим
[01:14:01.360 --> 01:14:07.960]  за k шагов. Значит сумма k плюс l в том случае, если мы рассматриваем вывод в альфа штрих,
[01:14:07.960 --> 01:14:14.600]  их будет количество k плюс t. Ну и третье, это сколько мы из этой штуки выводим, это t.
[01:14:14.600 --> 01:14:34.960]  Согласен. Согласен, да, m. Вот так, да. Ну либо m меньше k, либо m меньше j, либо, собственно,
[01:14:34.960 --> 01:14:40.200]  по второму параметру мы делаем инакционный переход. Спасибо за замечание. А здесь надо считать,
[01:14:40.200 --> 01:14:45.760]  то есть смотрите, здесь k, здесь t, здесь вот эта вот единичка, потому что она теперь включается
[01:14:45.760 --> 01:14:58.680]  в наш подвывод. Вот. И здесь l минус t минус 1. То есть смотрите, здесь у нас получается k плюс l,
[01:14:58.680 --> 01:15:07.800]  то есть мы не боремся с нашим вторым параметром, но третий параметр становится меньше. И из этого у нас
[01:15:07.800 --> 01:15:17.560]  получается, что альфа, что бета, стрелочка гамма точка, м принадлежит дожитой. Ну а значит,
[01:15:17.560 --> 01:15:19.760]  наши правила получились по комплиту.
[01:15:47.560 --> 01:15:57.360]  Третье, да? Значит, смотрите, мы рассматриваем вот это под дерево, то, что мы выводим до не
[01:15:57.360 --> 01:16:08.960]  терминала b, здесь. А вот это то, что после гаммы выводим. Да-да, после гаммы. Но мы же хотим завязать
[01:16:08.960 --> 01:16:14.080]  эту всю штуку на гамме и на b. То есть нам надо рассмотреть, за сколько шагов мы все вывели до b,
[01:16:14.080 --> 01:16:24.000]  и за сколько шагов мы из гаммы что-то выводили. Ну, чтобы точку после нее поставить. Вот. Ну и считаем.
[01:16:24.000 --> 01:16:35.320]  Значит, здесь мы, количество шагов у нас l минус t минус 1, а здесь k плюс 1 плюс получается t и плюс
[01:16:35.320 --> 01:16:54.280]  только здесь. Это понятно? Стало понятнее, откуда? Что третье? А, это количество шагов вывода из
[01:16:54.280 --> 01:17:00.600]  не терминала, который стоит, из последствий, которые стоит с левой точки. А в нашем случае это гамма.
[01:17:00.600 --> 01:17:06.200]  Ну, если мы хотим получить правило b стрелочка гамма точка, то надо посмотреть,
[01:17:06.200 --> 01:17:25.680]  за сколько шагов мы из гаммы что-то вывели. Так. Третий случай. Альфа штрих это эпсел.
[01:17:25.680 --> 01:17:39.280]  Тогда, если у нас альфа штрих это эпсел. Точнее, альфа это эпсел. Тут опечатка. Тогда у нас i равно g,
[01:17:39.280 --> 01:18:09.120]  и l равно 0. Альфа равно эпсел. Значит, если мы из альфа что-то попытаемся вывести до
[01:18:09.120 --> 01:18:23.800]  w и gt за l шагов, это значит, что i равно g и l равно 0. Да? А теперь давайте посмотрим,
[01:18:23.800 --> 01:18:33.360]  как это альфа появилась. Кто его породил? Собственно, у нас была такая картинка.
[01:18:33.360 --> 01:18:55.320]  0,0i, а,psi. За один шаг мы получили на самом деле какой-то терминал бета. Точка мы предполагаем
[01:18:55.320 --> 01:19:03.240]  будет здесь. А теперь, смотрите, давайте посмотрим, как получился альфа. Как получился
[01:19:03.240 --> 01:19:10.600]  а. На самом деле он появился из какого-то терминала бета. Если мы с вами сейчас посмотрим,
[01:19:10.600 --> 01:19:19.000]  как из этого терминала появился бета. Фиксуем тот момент, когда он появился. Тогда у нас тут гамма,
[01:19:19.000 --> 01:19:29.880]  а, дельта. Значит, из а мы за один шаг получаем бету. И теперь надо считать. Считать-считать
[01:19:29.880 --> 01:19:40.200]  очень долго. Это значит, если мы делаем s штрих, дальше мы делаем следующее. Значит,
[01:19:40.200 --> 01:19:47.200]  здесь мы вводим какой-то c штрих, а здесь мы должны сделать разбивку нашего слова. То есть,
[01:19:47.200 --> 01:19:54.440]  вот эта совокупность, вот эта совокупность у нас должна вывести слово с нулевого по итой,
[01:19:54.440 --> 01:20:01.600]  то есть поджитой. Значит, гамма у нас тоже за какое-то число шагов выводит слово с этого пожитой.
[01:20:01.600 --> 01:20:11.640]  Давайте считать. Мы с вами что понимаем? Мы с вами понимаем, что вот эту цепь мы выводим
[01:20:11.640 --> 01:20:19.720]  в сумме за k шагов. Вот это плюс вот это плюс вот это. Значит, если мы это выводим за t шагов,
[01:20:19.720 --> 01:20:34.920]  то вот эту цепь мы выводим за k-1-t шаг. Так, ну что? Давайте смотреть. Теперь нам надо как-то
[01:20:34.920 --> 01:20:43.120]  понять, что у нас тут хорошо. Давайте рассмотрим как раз. У нас из гаммы выводится,
[01:20:44.120 --> 01:20:51.600]  за сколько шагов? За t шагов у нас выводится w и jt. Значит, здесь гамма. Ой, здесь ставим t.
[01:20:51.600 --> 01:21:03.280]  Дальше смотрите, что здесь индекс у нас будет, если мы обрубаем по вот этой истории, по вот этой
[01:21:03.280 --> 01:21:13.440]  истории, то здесь у нас индекс p. p при этом может быть не больше, чем g. А здесь смотрите,
[01:21:13.440 --> 01:21:23.960]  суммарно количество правил вывода из этой штуки b, из этой штуки будет k-1-t плюс t. То есть это k-1.
[01:21:23.960 --> 01:21:35.440]  И в итоге у нас для тройки p k-1t мы можем написать следующее, что из b выводится гамма точка a дельта,
[01:21:35.440 --> 01:21:48.760]  она у нас была, p принадлежит дожитому. И у нас есть правило a стрелочка бета. Это значит,
[01:21:48.760 --> 01:22:01.680]  что наше правило a стрелочка точка бета могла появиться по правилу, получается какому? По
[01:22:01.680 --> 01:22:11.600]  правилу предикта. То есть еще раз, идея доказательства такая, что мы аккуратненько смотрим,
[01:22:11.600 --> 01:22:19.680]  как в нашем интерминале альфа какой был предпоследний шаг. Попытается понять,
[01:22:19.680 --> 01:22:26.960]  какой терминал мы до этого прямо раскрыли. Может быть три случая, если у нас эта буква,
[01:22:26.960 --> 01:22:36.400]  мы работаем по скану, если мы перепрыгнули не терминал, это скорее всего у нас
[01:22:36.400 --> 01:22:44.240]  комплит, а если у нас слово было пустое, то это предикт. И мы просто явно сидим и по деревьям это
[01:22:44.240 --> 01:23:07.440]  вытаскиваем. Вот. Кажется, я всех ухакошил. А теперь смотрите, финиш. Да, к сожалению,
[01:23:07.440 --> 01:23:16.080]  мы не сможем доказать асимптотику, но когда алгоритм будет написан за четвертую степень,
[01:23:16.080 --> 01:23:24.920]  вам по башке настучат на практикуме. Короче, если вы напишете алгоритм за четвертую степень,
[01:23:24.920 --> 01:23:30.000]  псевдокодом и не будете хранить множество дельта переходов, то есть тех ситуаций,
[01:23:30.000 --> 01:23:33.800]  которые добавляются на текущий момент, то вам скажут переписать, потому что это неэффективный
[01:23:33.800 --> 01:23:43.080]  алгоритм. А симптотика это алгоритма Куб. Но сильно меньше константы, чем алгоритмы Кока-Янгера-Касами.
[01:23:43.080 --> 01:23:58.280]  А для однозначной грамматики симптотика квадрат. Тоже квадрат. Итак, давайте в конце посмотрим,
[01:23:58.280 --> 01:24:04.880]  что же у нас получается. Мы говорили с вами следующее, что у нас слово лежит в грамматике.
[01:24:04.880 --> 01:24:17.280]  Смотрите, мы говорили, что вин у нас когда и только тогда, когда у нас есть вот такая ситуация.
[01:24:17.280 --> 01:24:33.720]  Да? Вы с вами же сказали так? Слово лежит в языке. Теперь надо доказать это. Так,
[01:24:33.720 --> 01:24:43.200]  теперь пишем это, что это значит. Это значит, что из штрих мы за какое-то количество шагов
[01:24:43.200 --> 01:24:52.480]  вывели слово с нулевого по нулевой. Вывели первую часть. Это что у нас? s штрих,
[01:24:52.480 --> 01:25:04.040]  psi. Но это по факту у нас пустое слово, мы с вами догадываемся. Дальше. Что получается? За один шаг
[01:25:04.320 --> 01:25:14.040]  мы выводим слово с нулевого по иты, с нулевого по нулевой. Дальше у нас какая-то непонятная
[01:25:14.040 --> 01:25:20.080]  альфа возникает. Ну, точнее, мы понимаем, что это за альфа. У нас выскакивает здесь не терминал s.
[01:25:20.080 --> 01:25:28.880]  Здесь по факту у нас точка, которую мы раскроем psi. И теперь получается следующее, что у нас из s,
[01:25:28.880 --> 01:25:42.000]  из нашей штуки, из нашей леммы мы выводим слово w в индексах с нулевого подлинно слово w. А это
[01:25:42.000 --> 01:25:54.800]  что у нас такое? То есть это верно тогда и только тогда. А это верно тогда и только тогда, когда что?
[01:25:54.800 --> 01:26:00.880]  Да, слово лежит в языке задаваемой данной грамматикой.
[01:26:00.880 --> 01:26:15.160]  Вот. Значит, смотрите, если интересно будет посмотреть, тут есть доказательства того,
[01:26:15.160 --> 01:26:25.320]  как это считать. Мы это не будем просить, но асимптотика, смотрите какая. Асимптотика,
[01:26:25.360 --> 01:26:43.160]  тут каждых шагов можно оценить. В общем, асимптотика длина от слова грамматики в кубе на количество
[01:26:43.160 --> 01:26:48.360]  суммарных правых частей, суммарное количество не терминалов и терминалов, которые встречаются
[01:26:48.360 --> 01:26:59.000]  во всех правилах в квадрате. Для однозначных, это длина слова в квадрате на g квадрат.
[01:26:59.000 --> 01:27:12.320]  Нет, это суммарно по всем. На одну операцию, на одну операцию для конкретного g надо поделить на
[01:27:12.320 --> 01:27:19.840]  длину слова w. Вот, но поскольку у нас с вами есть эффективная реализация, то это можно
[01:27:19.840 --> 01:27:27.920]  сесть аккуратно, посчитать амортизованным анализом. Я думаю, что мы поступим следующим образом,
[01:27:27.920 --> 01:27:37.240]  что если вдруг у вас попадется на экзамене билет с алгоритмом Эрли, то там будет процедура экзамена
[01:27:37.240 --> 01:27:42.680]  такая, что в качестве задачи на отл-8, потому что у нас система будет шкалированная, то есть там
[01:27:42.680 --> 01:27:49.640]  как на каокли, вы видели, то есть до 7 мы решаем какие-то базовые типовые задачи, отвечаем на билет,
[01:27:49.640 --> 01:27:55.800]  дальше на отл начинаем решать задачи. Так вот, будет такой вопрос, что если вдруг вам попадется
[01:27:55.800 --> 01:28:01.480]  билет с алгоритмом Эрли, то можно будет доказать асимптотику и перепрыгнуть с 7 на 8.
