[00:00.000 --> 00:23.160]  Всем здрасте, давайте стартовать. Сегодня заканчиваем говорить про динамику. Сегодня у
[00:23.160 --> 00:30.080]  нас последняя тема здесь. Это динамика по маскам или по подможествам.
[00:53.160 --> 01:00.920]  Идея такая, смотрите, пусть у нас есть какое-нибудь множество не очень большое. Давайте я его назову А. Оно состоит из
[01:00.920 --> 01:06.600]  тех целых неотрицательных чисел вплоть до н-с одного. Мы хотим как-нибудь, как можно
[01:06.600 --> 01:12.120]  более эффективно представлять подмножество этого А в памяти. Ну понятно, любое множество
[01:12.120 --> 01:18.080]  просто можно представлять перечислением его элементов, но мы сделаем немножко по-другому.
[01:18.080 --> 01:24.880]  Мы будем, во-первых, считать, что n не шибко большое, типа там 30, например, 20, 30, где-то так, ну может
[01:24.880 --> 01:32.640]  быть там 60. И будем каждое подмножество этого множества представлять в виде числа. Следующим
[01:32.640 --> 01:37.120]  простым образом, мы просто, если у нас есть какое-то подмножество, то мы давайте напишем битовую
[01:37.120 --> 01:41.920]  строчку длины n, где единичка будет означать, что число взято множество, нолик значит не взято.
[01:41.920 --> 01:53.480]  Например, если я напишу такую строчку, это означает, что у меня множество взято только единичка и двойка.
[01:53.480 --> 02:00.960]  Просто я для каждого числа говорю, беру я его подмножество или нет, соответственно,
[02:00.960 --> 02:06.440]  единицу или нолик пишу, и тем самым я однозначно кодирую все подмножества вот этого А с помощью
[02:06.440 --> 02:10.840]  битовых строк длины n. Давайте зафиксируем, что подмножество А
[02:10.840 --> 02:19.600]  тривиальным образом однозначно соответствует битовым строкам длины n.
[02:19.600 --> 02:31.320]  Ну и такие битовые строки можно хранить в виде просто числа какого-нибудь целого,
[02:31.320 --> 02:37.640]  например, int. Если у нас n действительно такое небольшое, то просто можно рассматривать вот
[02:37.640 --> 02:42.600]  это вот как представление числа в двуичной системе числения и говорить, что, ну окей,
[02:42.600 --> 02:47.720]  вот такую строчку будем хранить просто одним int, одним числом. Если там, скажем, n будет порядка
[02:47.720 --> 02:56.560]  60, то тогда вместо int нам нужен будет какой-нибудь long-long. Тем самым мы можем очень приятно,
[02:56.560 --> 03:03.240]  очень эффективно кодировать подмножество А просто числами. Например, в этом случае я рассматриваю
[03:03.240 --> 03:07.240]  вот эту вот строчку как двуичное представление какого-то числа. Давайте считаем, что у меня биты
[03:07.240 --> 03:12.160]  здесь написаны от меньших к большим, то есть это младший бит, это старший, как бы постарше,
[03:12.160 --> 03:16.360]  это еще старше, это самый старший. Тогда вот это вот множество будет просто соответствовать числу
[03:16.360 --> 03:25.320]  2 в первый плюс 2 во второй. Что это такое? Ну, видимо, видимо 5, 6, сори, 6. Вы знаете, тем самым мы
[03:25.320 --> 03:31.720]  закодировали все подмножества. Это понятно? Вот, ну используя такое представление множеств,
[03:31.720 --> 03:39.200]  мы будем решать всякие задачи на ДП. Но сначала нам надо будет с ними еще поподробнее познакомиться,
[03:39.200 --> 03:42.520]  значит, как мы вот так закодировали, теперь нам нужно научиться делать всякие операции.
[03:43.440 --> 03:52.680]  Первая операция, которая нам нужна, давайте напишем, что это операция над масками. Собственно,
[03:52.680 --> 03:58.280]  маски это вот как раз те самые численные представления всех подмножеств. Во-первых,
[03:58.280 --> 04:11.560]  нам нужна будет процедура извлечения бита. То есть это проверка того, есть ли какой-то
[04:11.560 --> 04:16.840]  элемент в нашем множестве. То есть вы рассматриваете какое-то подмножество А, вот это вот,
[04:16.840 --> 04:21.040]  какое-то подмножество А, и вы хотите как-то быстро определить, лежит ли в этом подмножество,
[04:21.040 --> 04:32.120]  не знаю, единица или там другое какое-то число К. То есть это проверка наличия какого-то
[04:32.120 --> 04:44.280]  элемента в множестве. Реализуется достаточно просто. Давайте это напишем прям кодом. Я это
[04:44.280 --> 04:49.160]  привык называть функцией bit, извлечение бита. Принимает два аргумента. Принимает маску,
[04:49.160 --> 04:54.960]  которая, собственно, и кодирует то множество, из которого надо извлечь этот бит, и принимает
[04:54.960 --> 05:00.040]  позицию числа, которой, собственно, надо проверить на принадлежность множеству. А то есть маска это,
[05:00.040 --> 05:06.400]  по сути, битовая строка длины n из нулей единиц. А поз — это то число, которое мы хотим проверить
[05:06.400 --> 05:10.360]  на принадлежности этой маски. То есть правда ли, что на позе позиции у меня стоит единичка?
[05:10.360 --> 05:15.600]  Правда ли, что на позе позиции единичка? Вот, ну и здесь давайте я перейду, что я буду все-таки
[05:15.600 --> 05:21.600]  записывать числа не слева направо в порядке возрастания битов, а, ну как, в общем, это обычно
[05:21.600 --> 05:25.520]  происходит, справа должны быть младшие биты. Когда мы пишем десятичное число, у нас справа
[05:25.520 --> 05:31.080]  единицы, потом десятки и так далее, то есть права будут младше. Так же будет и здесь. Ну,
[05:31.080 --> 05:45.760]  напишем следующее. Return маск больше-больше поз. Ant 1. Конец. Давайте Ant по-человечески напишем.
[05:45.760 --> 05:59.040]  Что такое значит больше-больше? Ну, это сдвиг на поз позиции вправо. Как он работает? Вот была у
[05:59.040 --> 06:05.440]  вас маска какая-то, число в двуичной записи. Вот здесь был его конец. Вы берете, сдвигаете его на
[06:05.440 --> 06:09.400]  поз позиции вправо. Вот представьте, да, просто это число подвинули на поз позиции вправо. Вот что-то
[06:09.400 --> 06:16.880]  такое. Соответственно, здесь вылезет поз последних бит. И когда вы делаете такой сдвиг, на самом деле,
[06:16.880 --> 06:23.160]  поскольку у вас, ну там, место в регистре, оно ограничено физически каким-то окончанием, то на
[06:23.160 --> 06:26.680]  самом деле просто все вот эти биты затираются. Вы как бы сдвинули, и все, что вылезло за пределы
[06:26.680 --> 06:31.080]  того, что у вас хранится, за нуляете, ну просто отбрасываете. И тогда ваше новое число, вот это
[06:31.080 --> 06:35.840]  вот маска больше-больше поз, это то, что останется, то, что останется слева от вот этого вот ограничителя.
[06:35.840 --> 06:40.920]  Ну и тогда понятно, что когда вы берете в конце ampersand с единичкой, то есть логическое и с единичкой,
[06:40.920 --> 06:47.320]  вы просто извлекаете вот этот вот последний бит. Сдвинули, осталась какая-то маска, и вы из нее
[06:47.320 --> 06:51.040]  извлекли последний бит. Потому что ans1 это как раз, ну вот представьте, да, у вас есть вот
[06:51.040 --> 06:57.680]  этого число, и вы ее andите с вот таким числом. Ну понятно, что вы просто тогда извлекаете последний
[06:57.680 --> 07:04.920]  бит. Потому что ans0 это 0, ans1 это то, что здесь было написано. Ну, собственно, а это ровно тот бит,
[07:04.920 --> 07:09.960]  который нам нужно было извлечь. Если здесь справа поз позиции, то в нольнэксации как раз вот этот
[07:09.960 --> 07:15.240]  бит имеет номер поз. В исходной маске он имел номер поз. Вот это ровно то, что мы хотели извлечь.
[07:15.240 --> 07:25.600]  Согласны? Хорошо. Вот это работает очень быстро, потому что здесь все операции булевские, ну битовые.
[07:25.600 --> 07:31.360]  Сдвиг на поз позиции вправо, это очень простая операция, явно это попроще, чем умножить,
[07:31.360 --> 07:36.440]  скажем, два числа. То есть мы понимаем, что числа хранятся там в регистрах, как какие-то
[07:36.440 --> 07:42.400]  последствия на ноль единиц. Понятно, что сдвинуть число на поз вправо и отбросить вот этот мусор,
[07:42.400 --> 07:47.760]  это сильно легче, чем, скажем, перемножить два числа. Ну мы считаем, конечно, что и то и то
[07:47.760 --> 07:52.160]  работает за вот эти единицы, но с точки зрения константы, вот эта вещь, конечно, гораздо более
[07:52.160 --> 07:57.080]  простая, чем умножение, деление и все такое. Ну и это ans1 тоже очень быстро работает, просто
[07:57.080 --> 08:04.280]  извлечение последнего бита, это прям супер быстро. Хорошо. Дальше нам нужны будут всякие операции
[08:04.280 --> 08:15.440]  над множествами, здесь все будет просто. Во-первых, это объединение множеств. Ну вот скажите мне,
[08:15.440 --> 08:21.240]  пожалуйста, есть у меня два множества, а и б, каждая какой-то маски соответствует, маск а,
[08:21.240 --> 08:29.440]  маск b. Я хочу построить новое множество, равное объединению двух старых, и, соответственно,
[08:29.440 --> 08:36.800]  написать здесь маску, которая соответствует этому множеству. Что я должен сделать? Конечно. Маск a
[08:36.800 --> 08:43.400]  or маск b. Побитого ели, действительно, ну потому что, что такое объединение? Это такая строка,
[08:43.400 --> 08:47.880]  что такое маска для объединения? Такая строка, где единица стоит, если только, если была единица
[08:47.880 --> 08:53.400]  в этом разряде хотя бы в одном из двух множеств, этим или том. Поэтому нужно просто взять побитого
[08:53.400 --> 08:57.240]  ели, в плюсах это вот такая вертикальная одна палочка. Ну это, наверное, вы и без меня знаете.
[08:57.240 --> 09:08.200]  Значит, третье пересечение. Здесь все то же самое, не буду это переписывать. Чтобы получить
[09:08.200 --> 09:15.720]  пересечение, нужно, ясное дело, взять, наоборот, конъюнкцию побитого. Маск а, конъюнкция, маск b.
[09:15.720 --> 09:45.680]  Давайте последнее нам, наверное, больше не понадобится. Разность множеств. Разность
[09:45.680 --> 09:52.160]  множеств. То есть было a, было b. Мы хотим построить a-b. Обычная теоретика множественного
[09:52.160 --> 09:58.280]  вычитания множеств. Вот, ну здесь есть много способов, конечно. Я привык к такому. Давайте
[09:58.280 --> 10:06.960]  я его напишу. Здесь маск a, маск b. Я сделаю следующее. Я сначала возьму дизюнкцию, а потом
[10:06.960 --> 10:17.760]  про ксориус b. Результат у меня будет такой. Маск а, ор, маск b, ксор, маск b. Вот так в плюсах
[10:17.760 --> 10:30.160]  пишется. Работает это вот почему. Есть у вас два множества, a и b. Сначала я получаю их объединение,
[10:30.160 --> 10:38.320]  то есть все, что вот здесь вот есть. А потом с помощью ксора, что такое ксор из одном на что другое. Ну,
[10:38.320 --> 10:43.440]  это симметрическая разность множеств. Но если, ну мы же понимаем, что вот это вот, это под множество
[10:43.440 --> 10:47.880]  вот этой штуки. Множество b целиком вложено в объединение a и b. Значит, когда я беру ксор,
[10:47.880 --> 10:52.960]  я просто исключаю из этого объединения целиком b вот этот вот, я выкидываю. То есть это выкидываю,
[10:52.960 --> 10:59.000]  и останется как раз разность a-b. Согласны? Вот, ну можно, конечно, по-другому. Можно было бы вот
[10:59.000 --> 11:02.080]  здесь как-нибудь в этой маске все биты инвертировать, построить множество,
[11:02.080 --> 11:06.560]  являющееся дополнением к маске b. Через тильду, например, да, есть оператор тильды, который
[11:06.560 --> 11:14.040]  инвертирует все биты. И потом взять пересечение. Потому что разность — это пересечение множества
[11:14.040 --> 11:22.360]  с дополнением к другому множеству. Согласны? Хорошо, ну еще раз подчеркну, что все операции
[11:22.360 --> 11:27.560]  здесь работают за вот единицы. И более того, они все ну прям супер быстрые. Быстрее, чем битовые
[11:27.560 --> 11:34.120]  вот эти вот операции or, xor и так далее. Никаких других там арифметических операций нет.
[11:34.120 --> 11:51.440]  Хорошо, теперь вооружившись с этим арсеналом, давайте решим следующую задачу. Пусть будет один.
[11:51.440 --> 12:10.400]  Дан полный взвешенный граф. Ну то есть n каких-то вершинок. И между каждой парой вершин есть стоимость
[12:10.400 --> 12:14.200]  ребра. Сколько стоит денег добраться из одной вершины в другую? И так для каждой парой вершин
[12:14.200 --> 12:21.320]  есть стоимость пути. Например, это там какая-нибудь карта страны, точка, вершина — это какой-нибудь
[12:21.320 --> 12:27.000]  аэропорт. И вес ребра из одного аэропорта в другой — это сколько стоит денег там перелететь
[12:27.000 --> 12:31.360]  из одного в другой. Куча всяких таких транспортных задач, они моделируются как раз таки взвешенными
[12:31.360 --> 12:36.560]  графами. Вот, значит есть такой граф, полный значит, что между любыми двумя есть ребро. Какое-то
[12:36.560 --> 12:58.080]  взвешенное с весом, то есть. Нужно найти самый дешевый гаметланов путь. Гаметланов путь, то есть такой путь,
[12:58.080 --> 13:10.800]  который где-то начинается и проходит все вершины ровно по одному разу. Все вершины посетить ровно по
[13:10.800 --> 13:21.520]  одному разу. Вот такая задачка. Есть граф, вам нужно, давайте какой-нибудь пример нарисую. Скажем,
[13:21.520 --> 13:27.640]  вот граф на четырех вершинах. Вам нужно найти какой-то путь, который все вершинки посещает и
[13:27.640 --> 13:32.200]  ровно по одному разу при этом. Например, что-нибудь вот такое подойдет. Такое ребро, потом такое,
[13:32.200 --> 13:38.560]  потом такое. Пожалуйста, на путь все вершины ровно один раз посещены. И среди всех таких путей я хочу
[13:38.560 --> 13:44.440]  найти самый дешевый. То есть, не знаю, я турист, хочу посетить все города, при этом мне очень не
[13:44.440 --> 13:48.120]  нравится, когда я дважды бываю в одном и том же городе. При этом, понятно, я хочу сэкономить
[13:48.120 --> 13:54.960]  либо деньги, либо время. Поэтому мне нужно найти минимальный по весу гаметланов цикл. Значит,
[13:54.960 --> 14:02.080]  эта задача в такой постановке NP трудная. В том же смысле, в котором NP трудный был рюкзак у нас.
[14:02.080 --> 14:08.360]  Я говорил, что задача в рюкзаке не решается пока что, пока никто не умеет решать задачу в рюкзаке
[14:08.360 --> 14:13.640]  за время полиномиальный от размера входа. То есть, у нас там был псевдополиномиальный алгоритм за n
[14:13.640 --> 14:19.440]  на w. Но, напоминаю, поскольку w это не полином от длины, вот количество битов во входе, это
[14:19.440 --> 14:24.880]  не полиномиальный алгоритм. То же самое здесь. Пока никому на планете не известно, как решать эту
[14:24.880 --> 14:30.040]  задачу за полином от числа вершин. То есть, ни за n в квадрате, ни за n в пятой, ни за n в десятой,
[14:30.040 --> 14:35.480]  никто это решать пока не умеет. Ну или, по крайней мере, нам не признается в этом. Вот. Ну, для нас
[14:35.480 --> 14:39.760]  как бы вот это словосочетание NP трудное, значит как раз, что пока нет надежды решать за полином.
[14:39.760 --> 14:45.360]  Поэтому будем решать за экспоненту. И здесь нам будут нужны маски. Давайте у меня будет такой
[14:45.360 --> 14:49.640]  вопрос. Вот смотрите, пусть мы как-то начали наш путь, какие-то вершинки посетили, где-то
[14:49.640 --> 14:54.840]  закончились. Есть начало, есть какой-то путь, есть конец. Теперь вопрос. Чтобы продолжить наш путь,
[14:54.840 --> 15:00.480]  чтобы продолжить этот путь, какой информации о вот этом вот начале, об этом префиксе пути
[15:00.480 --> 15:04.360]  мне достаточно? Что достаточно хранить, чтобы однозначно понимать, куда я могу пойти дальше?
[15:04.360 --> 15:14.560]  Все посещенные, да, и про вершину сказали. Ну да, на самом деле, действительно, все, что мне нужно
[15:14.560 --> 15:21.440]  хранить, это номер последней вершины и множество посещенных. Давайте напишу так. Состояние, состояние
[15:21.440 --> 15:37.160]  характеризуется номером последней вершины и множеством посещенных. Множеством посещенных.
[15:37.160 --> 15:45.800]  Зная это, я понимаю, что отсюда я могу пойти в любую другую, которая еще не было в этом множестве.
[15:45.800 --> 15:51.920]  Ну и, соответственно, пересчитать наш путь. Так вот, давайте заведем такую динамику. Пусть динамика
[15:51.920 --> 15:58.680]  от последней вершины и маски, это минимальная возможная стоимость пути, которая где-то начинается,
[15:58.680 --> 16:04.320]  проходит все вершины этой маски ровно по одному разу и заканчивается в V. То есть вот фиксируем
[16:04.320 --> 16:08.400]  эти параметры и найдем минимальную длину такого пути. Нам же нужно самый дешевый путь. Вот давайте
[16:08.400 --> 16:19.520]  с такими параметрами найдем самый дешевый путь. И как раз за счет того, что мы ввели в соответствие
[16:19.520 --> 16:22.720]  между множествами и числами, мы сейчас будем это очень легко хранить. То есть вот это множество,
[16:22.720 --> 16:27.360]  вот этот множество вершин, мы не будем хранить там, как, не знаю, перечисление элементов, мы будем
[16:27.360 --> 16:32.880]  хранить одним числом, просто маской, и затем с ними работать вот так, как у нас было вот эти вот
[16:32.880 --> 16:44.520]  всякие анды, булевые сдвиги и так далее, битовые сдвиги и так далее. Пусть dp в это маске это минимальный
[16:44.520 --> 17:01.280]  вес гаметлиного пути, sorry, просто пути, который заканчивается в V и посещается до шины из маска
[17:01.280 --> 17:25.480]  ровно по одному разу. Так, ну все, свели такую динамику, дальше пересчет здесь довольно тривиален.
[17:25.480 --> 17:32.080]  Начинаем с базы. База, это когда у нас есть пути с одной вершинки, то есть мы куда-то встали,
[17:32.080 --> 17:40.280]  из нее начинаем, и пока никуда не пошли. Тогда база будет такая, значит dp Vt 2 в степени V это 0,
[17:40.280 --> 17:46.760]  потому что мы можем начать в любой вершинке V, давайте подпишем что-то, любой V, можем в ней начать,
[17:46.760 --> 17:53.160]  тогда множество посещенных, это просто сама эта вершинка V, и это соответствует маске 2 в степени V.
[17:53.380 --> 17:57.160]  Мы знаем, что если мы какую-то множество посетили, то чтобы понять, какой маска 4000FA
[17:57.160 --> 17:59.560]  соответствует множеству. Нужно просто сложить соответствующей степени 2.
[17:59.560 --> 18:03.360]  Если мы посетили вершинки V1, V2, etc. и Vk, нужно сложить два в степени V1
[18:03.360 --> 18:08.680]  плюс secondly два в степени Vk. Соответственно, эта маска соответствующая в точности множеству
[18:08.680 --> 18:13.520]  из одной вершинки. Это понятно? Просто в двоечной записи у нас есть bit только на V этой позиции,
[18:13.520 --> 18:17.480]  это как раз вот эта вот 2 в степени V. Соответственно, мы не знаем,
[18:17.480 --> 18:23.640]  начало, это может быть любая вершинка v. Вот, а дальше переход такой. Переход, давайте у меня
[18:23.640 --> 18:33.760]  будет dp вперед. Есть dk вперед, а у нас dp вперед. Значит, пусть мы фиксировали v, и пусть мы
[18:33.760 --> 18:39.320]  фиксировали много что вершин, которые мы посетили, маск. Много что посещенных маск. Попытаемся
[18:39.320 --> 18:44.120]  продолжить этот путь одним ребром. Ну, просто тогда переберем, какие здесь исходящие ребра.
[18:44.120 --> 18:50.400]  Скажем, в u мы попытаемся попасть. Тогда как меняется наша dp? Ну, понятно, последняя вершинка
[18:50.400 --> 18:55.240]  раньше была v, теперь станет u, потому что мы сделали один шаг, путь продлился, последняя вершинка станет
[18:55.240 --> 19:01.040]  u. А маска посещенных тоже, очевидно, как поменялась, в нее просто добавляется это u. Вот была старая
[19:01.040 --> 19:05.560]  маска, мы посетили одну новую, поэтому здесь будет маск в объединении с множеством из одного вот
[19:05.560 --> 19:14.320]  этого элемента u. Ну, тогда переход будет такой. Вот если у меня фиксирована v и маска, я просто
[19:14.320 --> 19:21.600]  перебираю все возможные продолжения пути, то есть я перебираю все вершинки от 0 до 0,1. Дальше,
[19:21.600 --> 19:26.680]  если я могу сделать такой переход, то есть если u не лежало в маске, потому что если u лежало в
[19:26.680 --> 19:33.680]  маске, то я не могу вернуться, мне нельзя посещать то же самое два раза. Значит, если неверно,
[19:33.680 --> 19:46.880]  что bit маск u, тогда мы сделаем следующее. Так, я, к сожалению, вот туда перейду, не умещаюсь.
[19:46.880 --> 20:01.200]  Что? Ну, давайте. Если тут буду писать видо всем, давайте попробуем. Значит, если u не лежало в
[20:01.200 --> 20:08.600]  маске, тогда давайте заведем новую маску newMask. Это вот как раз дополнение маски новой вершинкой
[20:08.600 --> 20:20.080]  u. То есть маск or 1 меньше-менше u. Ну, понятно, вот эта вот штука, это как раз маска, отвечающая
[20:20.080 --> 20:26.240]  только вершинкой u, и мы их поорили, то есть получили объединение. Ну и теперь мне нужно обновить
[20:26.240 --> 20:44.680]  dp u newMask minimum из того, что там уже лежало. И, соответственно, стоимостью того пути,
[20:44.680 --> 20:51.440]  который я только что построил, это dp vtMask плюс стоимость ребра из v в u. Давайте напишу
[20:51.440 --> 20:57.920]  плюс кост из v в u. Я считаю, что есть какой-то массив, который для каждой пары вершин говорит
[20:57.920 --> 21:04.560]  стоимость ребра между ними. Значит, я сначала добрался до v, посетив маску, и потом вот это
[21:04.560 --> 21:11.800]  последнее ребро приклеил. Понятное дело, что стоимость стала ровно вот такой. Кажется,
[21:11.800 --> 21:18.080]  все. Вот такая формула пересчета. Согласны? Ну, то есть просто если у меня фиксировано множество
[21:18.080 --> 21:22.560]  посещенных и последнее, то я перебираю, какая будет следующая, не лежащая в маске обязательно.
[21:22.560 --> 21:28.480]  Неверно, что в маске этот бит включен. Ну и дальше просто вот доклеиваю одно последнее ребро из v в u.
[21:28.480 --> 21:39.280]  Так, форма пересчета есть. Теперь порядок. Начну с порядком. Здесь все тоже несложно. Смотрите,
[21:39.280 --> 21:48.640]  мы понимаем, что нам как бы нужно перебирать маски в порядке включения, что ли. То есть вот если
[21:48.640 --> 21:55.320]  я нахожусь в маске, то из нее я делаю ходы только в ее надмножество. Вот была маска раньше, а теперь
[21:55.320 --> 21:58.720]  я новую вершинку вставил, то есть попадаю в маску, которая является ее надмножеством,
[21:58.720 --> 22:04.040]  которая ее содержит. И поэтому вот здесь, когда я вот здесь пишу цикл for-mask, for-v,
[22:04.040 --> 22:09.080]  мне как бы их нужно перебирать в порядке включения. На самом деле для этого достаточно
[22:09.080 --> 22:20.480]  просто их перебирать в порядке возрастания. Маск от 0 до 2v на минус 1, v от 0 до n минус 1.
[22:20.480 --> 22:30.760]  И потом вот это вот то, что у меня здесь написано. Ну действительно, почему достаточно такой порядок,
[22:30.760 --> 22:34.480]  почему достаточно перебирать маски в порядке возрастания. Единственное, что мне нужно в такой
[22:34.480 --> 22:39.320]  динамике вперед, это что когда я дохожу до какой-то маски, то есть когда я дохожу вот
[22:39.320 --> 22:45.640]  здесь вот до этого цикла с параметрами mask и v, мне нужно, чтобы dp mask v было корректно
[22:45.640 --> 22:50.080]  определено, потому что я через него насчитываю какие-то большие маски. Но чтобы оно было
[22:50.080 --> 22:54.160]  корректно определено, единственное, что мне нужно, чтобы все меньшие маски были рассмотрены до нее,
[22:54.160 --> 22:59.960]  точнее все подмножество ее. Потому что я делаю переход из маски в new mask расширением по
[22:59.960 --> 23:05.040]  какому-то биту. Значит, чтобы mask, dp в этой маске было корректно насчитано, мне нужно, чтобы все
[23:05.040 --> 23:10.280]  подмножества были перебраны. Ну понятно, что они будут перебраны, потому что подмножество маски
[23:10.280 --> 23:15.240]  это число меньшее, чем маска. Вот есть маска какая-то, битовое число из 0 единиц. Подмножество
[23:15.240 --> 23:19.720]  это когда вы какие-то единички заменяете на нули в двуечной записи. Берете подмножество, соответственно
[23:19.720 --> 23:24.880]  какие-то элементы выкидываете, у вас получается битовая строка, в которой какие-то единички заменины на нули.
[23:24.880 --> 23:31.920]  Ну значит, это просто меньшее число. Просто по значению вот этой битовой строки это меньшее число.
[23:31.920 --> 23:37.440]  Значит, действительно, вот такая форма, такой порядок пересчета будет корректен опять из-за того,
[23:37.440 --> 23:42.480]  что все меньшее, как бы все подмножество маски к моменту рассмотрения маски уже будут перебраны.
[23:42.480 --> 23:49.320]  Они будут меньше по значению, значит уже перебраны. Понятно? Еще раз?
[23:49.320 --> 23:57.200]  Ну можно соединиться, действительно. Пустой маски у нас никогда не будет. Давайте соединиться.
[23:57.200 --> 24:06.920]  То есть это скорее неважно. Давайте вставим, что изначально мы считаем, что dp любое-любое
[24:06.920 --> 24:14.160]  это плюс бесконечность. Считаем, что изначально нет ни одного пути, который бы заканчивался в какой-либо
[24:14.160 --> 24:18.600]  вершине и поищал бы какую-либо маску. То есть изначально все плюс бесконечность, потом заполняем
[24:18.600 --> 24:23.880]  нулями вот эти вот пути длиной 1, а дальше, ну вот здесь вот в этом форе вложенном тройной фор у меня будет
[24:23.880 --> 24:29.640]  маска v и потом u. Ну вот здесь скажем, если вот эта штука бесконечность плюс бесконечность, то здесь
[24:29.640 --> 24:34.640]  ничего не произойдет. Поэтому, как бы в принципе, если мы попадаем в что-то неволидное, например, когда здесь
[24:34.640 --> 24:39.600]  маска нулевая, такого не может быть, или, например, v не лежит в маске, такого тоже не может быть,
[24:39.600 --> 24:43.480]  тогда просто вот это значение плюс бесконечность и никаких дополнительных случаев не возникает.
[24:43.480 --> 24:49.440]  Мы просто пытаемся какое число релаксировать плюс бесконечностью. Ну, это ничего не сделает просто,
[24:49.440 --> 25:03.280]  ничего плохого в этом нет. Вопросы? Не обязательно, потому что, смотрите, если я изначально всю ДПшку
[25:03.280 --> 25:08.400]  заполню плюс бесконечностями, то тогда, если вы не в маске, то там по-прежнему будет плюс бесконечность,
[25:08.400 --> 25:12.360]  потому что такое невозможно получить вот такими переходами. А значит, еще раз, вот это просто плюс
[25:12.360 --> 25:17.320]  бесконечность, и что бы я ни делал, вот эти строчки по сути эффективны, они ничего не сделают,
[25:17.320 --> 25:21.480]  ну, в частности, ничего плохого. Поэтому можно это явно не проверять. Но если там хотите чуть-чуть
[25:21.480 --> 25:33.480]  улучшить, то действительно можно вставить проверку, если не бит маск v, тогда continue. Это можно вставить,
[25:33.480 --> 25:36.680]  это будет чуть быстрее работать, ну а симпатичное улучшение не получите.
[25:42.680 --> 25:49.960]  Дальше идем? Давайте померим асимптотику здесь. Считается очень просто. У нас 3 вложенных цикла,
[25:49.960 --> 25:55.680]  первый по 2 в степени n, второй по n, третий по n, и внутри пересчет за вот единицы, потому что все вот
[25:55.680 --> 26:01.120]  эти вот штуки, взятие ора, взятие минимум, взятие суммы, это работает за вот единицы. Поэтому асимптотика,
[26:01.120 --> 26:23.840]  конечно же, 2 в n на n квадрат времени, ну если интересно, то 2 в n на n памяти. Вот такой очень,
[26:23.840 --> 26:27.840]  казалось бы, неэффективный алгоритм с точки зрения того, что там все, что у нас было до этого,
[26:27.840 --> 26:33.480]  было все-таки скорее полиномиальным, по n, по числу вершин, по длине массива, были какие-то
[26:33.480 --> 26:38.640]  полиномы или даже логарифмы. А здесь вот возникает экспонент, 2 в степени n. Ну это еще раз из-за того,
[26:38.640 --> 26:43.120]  что пока никто не умеет решать это сильно лучше, чем экспоненты. То есть там за какие-нибудь,
[26:43.120 --> 26:50.040]  не знаю, n в степени log n, возможно, кто-то и умеет, но даже это не полином. За полином пока никто не умеет.
[26:50.040 --> 27:02.560]  Окей. Так, ну это значит, мы нашли самый дешевый гамметлинов путь. А, да, давайте ответ еще напишем.
[27:02.560 --> 27:09.440]  Мы написали все, что нужно, кроме того, где лежит ответ. Ну, ответ, понятно, какой. Значит, что такое
[27:09.440 --> 27:14.360]  ответ? Это гамметлинов путь, то есть он должен постить все вершинки. Ну, значит, маска это все
[27:14.360 --> 27:19.760]  единички, да, маска это все единички, но последняя вершина может быть какая угодно. Поэтому давайте
[27:19.760 --> 27:28.080]  возьмем минимум по всем возможным последним вершинам dp vt. А вот здесь мне нужно написать условия того,
[27:28.080 --> 27:33.920]  что все вершины посещены. То есть это двоичное число, состоящее из всех единичек, но это просто 2 в степени n-1.
[27:33.920 --> 27:44.960]  Вот эта штука в двоичном представлении, это просто 1, 1, 1, 1, 1, n раз. Поэтому, не зная последнюю
[27:44.960 --> 27:50.440]  вершинку, мне нужно ее просто перебрать, а маска всегда должна быть ровно такая. И это будет как раз таки
[27:50.440 --> 28:01.280]  самый дешевый гамметлинов путь. Хорошо. Ну, еще на семинаре будет упражнение. Граф невзвешенный,
[28:01.280 --> 28:11.240]  и нужно просто найти, значит, надо проверить, существует ли хотя бы один гамметлинов путь.
[28:11.240 --> 28:24.240]  Гамметлинов путь. То есть уже не гарантируется, что граф полный. Граф не обязательно полный,
[28:24.240 --> 28:28.320]  потому что если он полный, то понятное дело, в нем есть гамметлинов путь. Нужно из первой пяти во
[28:28.320 --> 28:33.880]  второй, из второй в третью, и так далее в n. А если граф не обязательно полный, то задача
[28:33.880 --> 28:40.160]  обнаружения в нем, ну или проверка существования в нем гамметлиного пути, это тоже сложная задача.
[28:40.160 --> 28:44.960]  Вот. И здесь получится, ну то есть это тоже непотрудная задача, ее никто не умеет
[28:44.960 --> 28:56.120]  решать за полином. Вот. И здесь можно решить за чуть лучшую асимптотику 2v на n. И вот часто,
[28:56.120 --> 29:01.440]  да, когда мы решаем что-нибудь с помощью такой динамики по маскам, динамики по подмножествам,
[29:01.440 --> 29:07.520]  даже вот это вот улучшение от n квадрата к n может нам, ну как бы чуть-чуть нас продвинуть. То есть
[29:07.520 --> 29:11.040]  понятно, что основной множитель это, конечно, 2v, он сохраняется, никуда не девается здесь,
[29:11.040 --> 29:15.800]  к сожалению. Вот. Но вот дополнительный множитель этот можно чуть уменьшить. Было n квадрат,
[29:15.800 --> 29:20.040]  стало n, ну задача чуть упростилась. Ну то есть тут надо было самый дешевый из большого множества,
[29:20.040 --> 29:24.160]  здесь нужно просто узнать, есть ли хотя бы один. В каком-то смысле задача стала проще, поэтому
[29:24.160 --> 29:28.920]  асимптотика стала чуть меньше. Вот. Ну такое как бы может быть полезно, уменьшение вот степени
[29:28.920 --> 29:34.320]  при n-ке может быть выгодно там, не знаю. Если раньше вы умели решать задачу для n там не больше
[29:34.320 --> 29:58.160]  20, то теперь для n не больше 23 можете решить, например. Что имеем? Так, окей, тогда едем дальше.
[29:58.160 --> 30:07.240]  Ко второй задаче переходим. Это будет задача о максимальной клике. Опять у нас есть граф,
[30:07.240 --> 30:15.480]  уже не обязательно полный, веса нам не нужны, ну то есть просто вот какая-то картинка, что между
[30:15.480 --> 30:31.120]  какими-то вершинами есть ребра. В данном графе нам нужно найти в нем максимальную клику. Клика
[30:31.120 --> 30:36.200]  это множество вершин, которые попарно соединены между собой, которые попарно смежны. Например,
[30:36.200 --> 30:49.600]  вот клика размера 3, треугольник, вот клика размера 4, вот клика размера 5, ну и так далее. То есть
[30:49.600 --> 30:55.080]  это несколько вершин в графе, которые попарно соединены ребрами вот в исходном графе, которые
[30:55.080 --> 31:00.440]  попарно имеют между собой ребро. И нам нужно найти максимальную клику, ну то есть клику максимального
[31:00.440 --> 31:15.680]  размера. Максимальное количество вершин. Ну с точки зрения каких-то приложений можно сказать,
[31:15.680 --> 31:26.320]  что клика это когда у вас есть у вас какие-нибудь друзья, вершинки это люди, ребро это отношение
[31:26.320 --> 31:30.520]  дружбы, вы хотите на вечеринку позвать какого-то множества людей, чтобы все были со всеми знакомы и
[31:30.520 --> 31:35.200]  дружили, чтобы никому не было грустно. Вот тогда вам нужна клика на самом деле, что все друг друга
[31:35.200 --> 31:46.840]  знают, попарно и всем весело. Окей, значит это тоже НП трудная задача. И здесь надеяться на что-то
[31:46.840 --> 31:52.400]  дополнительное не получится. То есть хоть у меня там N вершин, но ни за N в квадрате, ни за N в сотой,
[31:53.080 --> 32:00.680]  за N в степени константа никто пока решать не умеет. Как обычно с этими задачами. Поэтому имеет
[32:00.680 --> 32:04.920]  смысл рассматривать какие-то экспоненциальные алгоритмы, перебирать под множество и соответственно
[32:04.920 --> 32:20.920]  использовать ДП по маскам. Начну здесь давайте разберем несколько решений. Решение первое. Самое
[32:20.920 --> 32:32.400]  тупое решение, пожалуйста, предложите мне. Полный перебор. За сколько это работает? Ну N факториал
[32:32.400 --> 32:38.080]  это слишком, но 2 в степени N на N квадрат действительно то, что нам нужно. На самом деле факториала
[32:38.080 --> 32:42.760]  нет, потому что нам не важен порядок, нам важно только множество элементов. Факториал это когда у
[32:42.760 --> 32:46.880]  вас порядок важен, когда вы все пересновки рассматриваете. Значит это просто полный перебор.
[32:46.880 --> 32:58.640]  Полный перебор всех под множество. Всех под множество. Ну 2 в степени N как раз таки возникает от
[32:58.640 --> 33:04.720]  перебора. Мы знаем, что вот если мы, значит, у нас есть соответствие между множествами и числами,
[33:04.720 --> 33:09.120]  между масками, да, мы просто перебиваем все возможные маски. Каждая маска соответствует
[33:09.120 --> 33:14.160]  кому-то множеству. Ну и дальше внутри этой маски проверяем за квадрат от ее размера то, что это
[33:14.160 --> 33:19.280]  действительно клика, что все вершины внутри этой маски попарны средней ребрами. Ну то есть это перебор
[33:19.280 --> 33:23.960]  маски, это проверка того, что это клика. За квадрат просто всех перебираем, проверяем, что есть ребро.
[33:23.960 --> 33:36.000]  Окей? Второе решение. Пока что никакой динамики даже нет. Второе решение. Давайте мы ведем динамику
[33:36.000 --> 33:42.560]  буллевскую. Она для каждой маски хранит флаг true или false в зависимости от того, является ли эта
[33:42.560 --> 34:02.120]  маска кликой. Это true, если маска это клика и false иначе. Тогда как эту динамику можно насчитывать?
[34:02.120 --> 34:08.720]  Вот рассмотрим какую-то маску, какое-то множество, какое-то множество вершин. Я хочу понять, правда ли,
[34:08.720 --> 34:15.880]  что между всеми парами вершин в этом множестве есть ребро. Это можно сделать, например, так. Давайте
[34:15.880 --> 34:23.280]  мы какую-то вершинку исключим из этого множества, ну просто назначим ее особенной. Тогда чтобы все
[34:23.280 --> 34:29.200]  было кликой, мне нужно, чтобы во-первых, V была соединена со всеми из остатка, во-вторых, остаток был
[34:29.200 --> 34:33.760]  кликой. Это необходимое достаточное условие. Что вот здесь, во-первых, клика, то есть что не все между
[34:33.760 --> 34:41.480]  собой соединены, а также что V с ними со всеми соединена. Ну давайте это напишем, что пусть V это
[34:41.480 --> 34:47.440]  произвольная вершина из маски. Я вот так немножко вольно пишу, что V принадлежит маске, ну по сути это
[34:47.440 --> 34:51.760]  число, но мы знаем, что числа и множество, когда мы говорим про маски, мы понимаем, что это по сути
[34:51.760 --> 34:58.600]  множество, поэтому я позволю себе такую запись, что число лежит в маске в множестве. Вот тогда dp
[34:58.600 --> 35:15.800]  маск равно true, если только если. Во-первых, dp маск XOR2 в степени V это true, то есть маска после
[35:15.800 --> 35:23.960]  выкидывания вершинки V является кликой. Это как раз маск XOR2 в степени V. И во-вторых, V соединена со
[35:23.960 --> 35:39.320]  всеми из вот этой вот маски. V соединена со всеми из вот этой вот маски. Маск XOR2 в степени V. Давайте.
[35:39.320 --> 36:01.080]  Давайте подумаем. То есть мы проявляем, что вот эта клика, потом проявляем, что вот эта вот клика,
[36:01.080 --> 36:13.920]  и это в частности, ой, это интересная идея, да, я о таком не думал. Сейчас, момент. Ну похоже на
[36:13.920 --> 36:17.920]  правду, да, кстати, действительно. То есть смотрите, если мы вместо вот этой одной вершины будем пытаться
[36:17.920 --> 36:23.200]  откусывать две и проверим, что значит вот эта вот клика, то есть все без V это клика, потом все без
[36:23.200 --> 36:27.960]  U это клика, то единственное ребро, которое мы не проверим, это то, что это ребро между U и V.
[36:27.960 --> 36:33.920]  Тогда давайте его проверим, еще завод единицы, будет переход, получается, завод единицы. Да,
[36:33.920 --> 36:39.440]  действительно работает. Согласен. Давайте я это добью, ладно. Действительно, тогда это
[36:39.440 --> 36:48.000]  будет за два степени N решение. Вы правы. Тут чуть больше надо думать. Тут чуть меньше.
[36:57.960 --> 37:07.020]  Да, собственно, а что тут осталось-то сказать? Ну осталось понять, что вот это вот условие можно
[37:07.020 --> 37:12.040]  проверить за U от N. Потому что смотрите, что мне нужно, мне нужно в маске найти какой-то бит,
[37:12.040 --> 37:17.320]  какую-то вершинку, лежащую в этом множестве. Проверить вот этот за вот единицы, и потом проверить,
[37:17.320 --> 37:20.720]  что V соединяется всеми из этого множества. Но это еще и линия. У меня есть вершина,
[37:20.720 --> 37:24.120]  у меня есть какое-то множество вершин, мне нужно проверить, что есть ребра отсюда во все вот эти.
[37:24.120 --> 37:28.120]  Но это линейное время, потому что размер вот этой маски линейен.
[37:28.120 --> 37:32.120]  Я просто для каждого элемента отсюда проверяю, что есть ребровая.
[37:32.120 --> 37:36.120]  Это линейный проход. Получилось у меня решение за 2n на n квадрат.
[37:36.120 --> 37:38.120]  Сорри, на n, на n, конечно.
[37:38.120 --> 37:40.120]  2n и на n.
[37:40.120 --> 37:44.120]  Потому что всего 2n масок, и у каждой вот этот флажок
[37:44.120 --> 37:48.120]  выставляется за линейное время от ее размера, от n в худшем случае.
[37:48.120 --> 37:56.120]  Третье решение.
[37:56.120 --> 38:00.120]  Наверное, достаточно было бы написать то, что вы предложили,
[38:00.120 --> 38:04.120]  что можно откусывать ни одну вершинку, а две сразу.
[38:04.120 --> 38:08.120]  И проверить, что получаются клики оба раза, и что есть ребро между U и V.
[38:08.120 --> 38:12.120]  Давайте я немножко другой подход расскажу, там будет полезная идея.
[38:12.120 --> 38:16.120]  Даже две полезных идеи.
[38:16.120 --> 38:24.120]  Давайте, во-первых, считать, что V это старший бит в маске.
[38:24.120 --> 38:28.120]  Старший бит в маске.
[38:28.120 --> 38:32.120]  Мы же сказали, что нам неважно, какую вершину откусывать.
[38:32.120 --> 38:34.120]  Можно любую отбросить и проверить те условия.
[38:34.120 --> 38:36.120]  Давайте считать, что это старший бит.
[38:36.120 --> 38:40.120]  Просто самая левая, самая значящая единица, у которой степень двойки наибольшая.
[38:40.120 --> 38:44.120]  Тогда вот этот V можно насчитывать следующим образом.
[38:44.120 --> 38:52.120]  Давайте я заведу переменную oldis, которая равна номеру старшего бита в текущей маске.
[39:04.120 --> 39:10.120]  Если я буду приводить маски в порядке возрастания, то вопрос, когда у меня меняется старший бит.
[39:10.120 --> 39:14.120]  Когда я просто к маске приворачиваю единичку, у меня старший бит обычно не меняется,
[39:14.120 --> 39:18.120]  он меняется только, если вот эта вот старшая единичка перекидывается в старший разряд.
[39:18.120 --> 39:20.120]  Но это может быть только, если все правей нее были единицами.
[39:20.120 --> 39:26.120]  То есть на самом деле oldis увеличивается, только если мы пришли в новую степень двойки.
[39:26.120 --> 39:30.120]  Это как проверить, что число является степень двойки, мы с вами уже когда-то делали.
[39:30.120 --> 39:40.120]  Если не маск, и маск минус один, тогда плюс-плюс oldis.
[39:44.120 --> 39:52.120]  Эта штука всегда, после этого if, значение в oldis равно индексу самого старшего бита в маске.
[39:52.120 --> 39:58.120]  Почему? Изначально у меня минус единичка, затем я попадаю в маск равно единице.
[39:58.120 --> 40:00.120]  Маск равно один, я понимаю, что это степень двойки.
[40:00.120 --> 40:06.120]  Например, я андио единицу и ноль, получаю ноль, поэтому это условие выполняется.
[40:06.120 --> 40:09.120]  Я oldis увеличиваю, будет oldis равно нулю.
[40:09.120 --> 40:15.120]  То есть как раз когда маск равно единице, у меня oldis показывает на единственный включенный старший бит.
[40:15.120 --> 40:18.120]  На два в нулевой. У меня будет oldis равно нулю.
[40:18.120 --> 40:22.120]  Ну и потом, когда я дальше иду по этому циклу, у меня маск, точнее oldis увеличивается,
[40:22.120 --> 40:24.120]  как только маск становится степенью двойки.
[40:24.120 --> 40:28.120]  Вот это условие, которое у нас было, когда мы спаррстейбл писали.
[40:28.120 --> 40:30.120]  Мы, кажется, там ровно так и делали.
[40:30.120 --> 40:35.120]  Нам нужно было в спаррстейбле для каждого k знать максимальную степень двойки,
[40:35.120 --> 40:38.120]  которая его не превосходит, и там делается ровно то же самое.
[40:38.120 --> 40:40.120]  Нам нужно, по сути, хранить старший бит.
[40:40.120 --> 40:42.120]  Это делается так.
[40:42.120 --> 40:48.120]  Тогда будем использовать oldis вместо v.
[40:54.120 --> 40:57.120]  Поскольку нам достаточно использовать любой бит, давайте использовать старший.
[40:57.120 --> 41:01.120]  Нам не важно какой, но для удовольствия будем использовать старший.
[41:01.120 --> 41:04.120]  У нас есть вот это v за вот единицы.
[41:04.120 --> 41:08.120]  Для каждой маски мы знаем вот этот вот v, точнее oldis, за вот единицы.
[41:08.120 --> 41:11.120]  Нам не нужно проходить по маске искать какой-то бит, нам он уже известен.
[41:11.120 --> 41:13.120]  У нас он лежит в перемене oldis.
[41:32.120 --> 41:35.120]  Что осталось? Осталось понять вот это второе условие.
[41:35.120 --> 41:39.120]  Правда лист этот oldis соединен со всеми вершин веського там множества.
[41:40.120 --> 41:42.120]  Для этого сделаем следующее.
[41:42.120 --> 41:54.120]  Для каждой вершины мы изначально предпочитаем маску всех ее соседей.
[42:00.120 --> 42:07.120]  Изначально найдем маску всех ее соседей.
[42:10.120 --> 42:16.120]  Пусть это будет массив neighbor от u.
[42:18.120 --> 42:20.120]  Это те, кто с ней соединили ребром.
[42:21.120 --> 42:23.120]  Те, в которые есть ребро из u.
[42:23.120 --> 42:29.120]  Тогда, чтобы проверить, что какая-то вершинка v соединена со всеми из какого-то множества,
[42:29.120 --> 42:31.120]  вот то условие давайте перепишем.
[42:31.120 --> 42:40.120]  v соединена со всеми из какого-то множества маск.
[42:40.120 --> 42:42.120]  Давайте я маск-штрих это назову.
[42:42.120 --> 42:47.120]  Это то же самое, что маск-штрих вложено в это множество.
[42:50.120 --> 42:53.120]  Маск-штрих вложено в neighbor от v.
[42:53.120 --> 42:58.120]  Вроде очевидно.
[42:58.120 --> 43:01.120]  Если это множество всех соседей, то есть множество всех вершин, связанных с v,
[43:01.120 --> 43:04.120]  мне нужно проверить, что v соединена со всеми отсюда.
[43:04.120 --> 43:06.120]  Они все должны быть соседями.
[43:06.120 --> 43:08.120]  В них во все должно быть ребро.
[43:08.120 --> 43:10.120]  Поэтому должно выполняться такое включение.
[43:10.120 --> 43:12.120]  Это должно быть под множеством этого.
[43:14.120 --> 43:18.120]  Теперь вопрос, как проверить, что одна маска является под множеством другой.
[43:18.120 --> 43:20.120]  За от и днице.
[43:23.120 --> 43:35.120]  Да, можно так, действительно.
[43:35.120 --> 43:38.120]  Тут опять можно действовать как угодно.
[43:38.120 --> 43:40.120]  Давайте напишем то, что предложили.
[43:40.120 --> 43:45.120]  Это то же самое, что маск-штрих минус neighbor от v, пусто.
[43:45.120 --> 43:47.120]  Я напишу равно нулю, как число.
[43:47.120 --> 43:49.120]  Ноль – это пустая маска.
[43:49.120 --> 43:51.120]  Действительно, одно это под множеством другого,
[43:51.120 --> 43:54.120]  если после вычитания из этого и этого никого не остается.
[43:54.120 --> 43:57.120]  Иначе есть кто-то, соответственно, первое не под множеством второго.
[43:57.120 --> 44:01.120]  Можно так, можно любым другим способом, как вам удобно, так и напишите.
[44:01.120 --> 44:03.120]  Главное, что это работает за от и днице,
[44:03.120 --> 44:07.120]  потому что все битовские операции, разности много, что мы уже писали.
[44:07.120 --> 44:09.120]  Хорошо.
[44:09.120 --> 44:14.120]  И значит, вот эту проверку мы теперь умеем делать за от и днице.
[44:14.120 --> 44:18.120]  У нас есть v равное oldest, у меня есть вот эта вот маска,
[44:18.120 --> 44:22.120]  и у меня есть уже насчитанная маска соседей neighbor от oldest.
[44:22.120 --> 44:24.120]  Я просто за от и днице проверяю это условие,
[44:24.120 --> 44:29.120]  и тем самым я понимаю, правда ли, что oldest связана со всеми из вот этого остатка.
[44:29.120 --> 44:33.120]  Зная это, я знаю, правда ли, что маска – это от и днице.
[44:33.120 --> 44:35.120]  Я понимаю, что это от и днице,
[44:35.120 --> 44:37.120]  и из вот этого остатка.
[44:37.120 --> 44:41.120]  Зная это, я знаю, правда ли, что маска – это клика.
[44:41.120 --> 44:46.120]  Получится решение за 2 в степени n, чистое, без всяких множителей,
[44:46.120 --> 44:49.120]  потому что я просто перебираю все маски.
[44:49.120 --> 44:52.120]  Для каждой маски у меня известен oldest, за от и днице,
[44:52.120 --> 44:56.120]  и потом еще за от и днице я проверяю, что вот это вот второе условие,
[44:56.120 --> 45:01.120]  тоже за от и днице, потому что это проверка, что одно множество вложено в другое.
[45:01.120 --> 45:04.120]  Профит. Получили ту же асимптотику, что вы предлагали,
[45:04.120 --> 45:06.120]  но чуть по-другому.
[45:06.120 --> 45:08.120]  Но здесь две приятные идеи.
[45:08.120 --> 45:12.120]  Во-первых, oldest мы научились считать, то есть какой-то конкретный бит в маске.
[45:12.120 --> 45:18.120]  А во-вторых, в каком-то смысле научились проверять,
[45:18.120 --> 45:21.120]  что v связана со всеми из-под множества.
[45:21.120 --> 45:26.120]  На что? Множество вложено в множество ее соседей.
[45:27.120 --> 45:29.120]  Вопросы?
[45:30.120 --> 45:32.120]  Окей.
[45:36.120 --> 45:38.120]  Что значит значение?
[45:44.120 --> 45:46.120]  Нет, смотрите, нам не обязательно.
[45:46.120 --> 45:50.120]  Нам в качестве oldest на самом деле сгодился бы любой бит, который лежит в маске.
[45:50.120 --> 45:52.120]  Здесь?
[45:53.120 --> 45:55.120]  Нет, нет, это не идея, это прям решение.
[45:55.120 --> 45:57.120]  То есть смотрите еще раз.
[45:57.120 --> 45:59.120]  Здесь, в том решении, которое я только что стер,
[45:59.120 --> 46:03.120]  мне нужно было вместо oldest использовать произвольную вершину,
[46:03.120 --> 46:06.120]  которая есть в маске, и для нее проверять, что после ее отбрасывания есть клика,
[46:06.120 --> 46:08.120]  и она со всеми соединена.
[46:08.120 --> 46:11.120]  Но смотрите, я там сказал, что вместо v, то есть в качестве v,
[46:11.120 --> 46:13.120]  можно брать любую вершину из маски.
[46:13.120 --> 46:18.120]  И чтобы ее хранить, чтобы ее находить за вот однице,
[46:18.120 --> 46:20.120]  можно в качестве v использовать просто oldest.
[46:22.120 --> 46:26.120]  Да-да-да, это поиск какого-то бита из маски. Все верно.
[46:28.120 --> 46:30.120]  Как вы думаете?
[46:37.120 --> 46:39.120]  Ну, z², на самом деле.
[46:41.120 --> 46:45.120]  Потому что, ну давайте заведем массив вот этот neighbor,
[46:45.120 --> 46:47.120]  заполним его изначально нулями.
[46:47.120 --> 46:49.120]  Потом пройдемся по всем ребрам u и v,
[46:49.120 --> 46:51.120]  и скажем, что в neighbor от u надо включить v,
[46:51.120 --> 46:53.120]  а в neighbor от v включить u.
[46:53.120 --> 46:55.120]  Это делается за вот однице.
[46:55.120 --> 46:57.120]  То есть, каждое ребро зовут однице,
[46:57.120 --> 46:59.120]  и расширяет нам вот эти два множества
[46:59.120 --> 47:01.120]  для каждого из концов этого ребра.
[47:01.120 --> 47:03.120]  Ну и тем самым мы просто все ребра проходим
[47:03.120 --> 47:05.120]  и neighbor от всех машин насчитываем.
[47:05.120 --> 47:07.120]  Похоже на правду?
[47:09.120 --> 47:11.120]  Окей.
[47:11.120 --> 47:13.120]  Ну, поэтому, да, поэтому это
[47:13.120 --> 47:15.120]  пренебрежимая маленькая вещь по сравнению с основной 8-м точкой,
[47:15.120 --> 47:17.120]  2v, поэтому мы здесь пишем только 2v,
[47:17.120 --> 47:19.120]  пренебрегая временем на предподсчет.
[47:19.120 --> 47:21.120]  Квадрат меньше, чем 2v,
[47:21.120 --> 47:23.120]  для всех, ну там, сильно меньше,
[47:23.120 --> 47:25.120]  чем 2v, для всех, начиная с некоторого.
[47:27.120 --> 47:29.120]  Окей.
[47:29.120 --> 47:31.120]  Так, тогда следующее решение
[47:31.120 --> 47:33.120]  еще круче.
[47:35.120 --> 47:37.120]  У нас получится за 2 в степени
[47:37.120 --> 47:39.120]  пополам на n.
[47:43.120 --> 47:45.120]  Раньше у меня было все время 2 в степени n,
[47:45.120 --> 47:47.120]  а теперь будет 2 в степени всего лишь n пополам.
[47:47.120 --> 47:49.120]  Это очень
[47:49.120 --> 47:51.120]  хорошее улучшение,
[47:51.120 --> 47:53.120]  потому что, ну, например,
[47:53.120 --> 47:55.120]  вот здесь, когда у меня было n равно 20, у меня здесь
[47:55.120 --> 47:57.120]  было 2 в 20, это там, ну, миллион операций,
[47:57.120 --> 47:59.120]  примерно. А здесь при n равно 20
[47:59.120 --> 48:01.120]  будет всего 2 в 10, это тысяча операций
[48:01.120 --> 48:03.120]  всего лишь.
[48:03.120 --> 48:05.120]  Ну и, соответственно, там, не знаю, для n равно
[48:05.120 --> 48:07.120]  30-и, 40-ка, уже только это решение
[48:07.120 --> 48:09.120]  будет укладываться в секунды,
[48:09.120 --> 48:11.120]  в единицы секунды в смысле, то уже будет работать,
[48:11.120 --> 48:13.120]  не знаю, десятки, сотни секунд, наверное.
[48:15.120 --> 48:17.120]  Ну и вообще, давайте такой вопрос,
[48:17.120 --> 48:19.120]  совсем простой.
[48:19.120 --> 48:21.120]  Я могу сказать,
[48:25.120 --> 48:27.120]  что 2 в n пополам на n
[48:27.120 --> 48:29.120]  есть... Ой, наоборот,
[48:29.120 --> 48:31.120]  ну, нет, ладно, нормально.
[48:33.120 --> 48:35.120]  Есть т,
[48:35.120 --> 48:37.120]  а 2 в n на n.
[48:39.120 --> 48:41.120]  Ну, потому что, как мы любили говорить,
[48:41.120 --> 48:43.120]  мы говорили, что если есть какая-то константа
[48:43.120 --> 48:45.120]  мультипликативная, то ее
[48:45.120 --> 48:47.120]  можно убрать, это не влияет на порядок роста.
[48:47.120 --> 48:49.120]  Вот. Ну, а здесь константы
[48:49.120 --> 48:51.120]  как бы в показательной степени.
[48:51.120 --> 48:53.120]  Можно так сказать?
[48:53.120 --> 48:55.120]  Ну, нельзя, конечно.
[48:55.120 --> 48:57.120]  Потому что вот это и вот это
[48:57.120 --> 48:59.120]  разные по скорости роста функции,
[48:59.120 --> 49:01.120]  потому что вот это, это, по сути,
[49:01.120 --> 49:03.120]  корень из 2 степени n, можно так записать.
[49:03.120 --> 49:05.120]  Корень из 2 степени n.
[49:05.120 --> 49:07.120]  А это, ну, 2 в n-й.
[49:07.120 --> 49:09.120]  Ну, понятно, что это растет сильно быстрее, чем это.
[49:09.120 --> 49:11.120]  Если хотим формально доказать,
[49:11.120 --> 49:13.120]  то можно рассмотреть их отношения,
[49:13.120 --> 49:15.120]  получится корень из 2 в n-й, отношение
[49:15.120 --> 49:17.120]  получается к нулю, ну, или там, к бесконечности.
[49:17.120 --> 49:19.120]  То есть, если мы поделим вот это на это,
[49:19.120 --> 49:21.120]  получим бесконечно большую функцию, значит,
[49:21.120 --> 49:23.120]  ну, точно не может быть, что ни одного роста.
[49:23.120 --> 49:25.120]  Не может быть у них одинаковый порядок роста, это растет быстрее, чем это.
[49:25.120 --> 49:27.120]  Вот. Ну, это такое
[49:27.120 --> 49:29.120]  воспоминание
[49:29.120 --> 49:31.120]  Маттана.
[49:31.120 --> 49:33.120]  Значит, мы сделаем следующее.
[49:33.120 --> 49:35.120]  Мы разобьем
[49:35.120 --> 49:37.120]  нашу множество вершин исходной на 2 множества
[49:37.120 --> 49:39.120]  размером пополам.
[49:39.120 --> 49:41.120]  Давайте я для удовольствия считаю, что n-четная.
[49:41.120 --> 49:43.120]  Разобьем исходное множество
[49:43.120 --> 49:45.120]  на 2 множества размера n пополам.
[49:45.120 --> 49:47.120]  Тогда, как устроена любая
[49:47.120 --> 49:49.120]  клика в исходном графе?
[49:49.120 --> 49:51.120]  Значит, это какой-то кусочек
[49:51.120 --> 49:53.120]  здесь, какой-то
[49:53.120 --> 49:55.120]  кусочек здесь. Давайте их
[49:55.120 --> 49:57.120]  назову u и v. Ну и какие
[49:57.120 --> 49:59.120]  на них требования? Во-первых, оба множества
[49:59.120 --> 50:01.120]  сами по себе являются кликами.
[50:01.120 --> 50:03.120]  То есть, все, между всеми парами
[50:03.120 --> 50:05.120]  вершин вот здесь вот есть ребро,
[50:05.120 --> 50:07.120]  между всеми парами вершин вот здесь вот есть ребро,
[50:07.120 --> 50:09.120]  ну, а еще есть ребро из любой вершинки u в
[50:09.120 --> 50:16.840]  любую вишенку v. Значит, клика, давайте напишем три условия, что, во-первых, u – это клика, во-вторых, v – это
[50:16.840 --> 50:31.980]  клика, в-третьих, для любого u из u, для любого v из v есть ребровая ве, у и v с одни ребром.
[50:31.980 --> 50:43.220]  Вот, собственно, критерии того, что этабенение является кликой. Хорошо.
[51:01.980 --> 51:08.020]  Так, да, давайте сделаем следующее. Давайте мы для каждого множества вершин слева, для каждого
[51:08.020 --> 51:13.140]  подмножия вершин слева, вот пусть это какое-то u, переберем u. Во-первых, мы понимаем, что u должно
[51:13.140 --> 51:19.740]  быть кликой, поэтому слева достаточно перебирать только клики. Во-вторых, мы понимаем, что в качестве
[51:19.740 --> 51:25.860]  v, в качестве дополнения к клике вот этого множества, можно взять только некоторые вершины отсюда,
[51:25.860 --> 51:31.080]  а именно те, которые соединились со всеми из u. Вот какое-то есть такое большое множество, это кандидат
[51:31.080 --> 51:36.160]  на v. Это те вершины, которые соединились со всеми отсюда. Ну и тогда, если мы обеспечили, получается,
[51:36.160 --> 51:41.720]  первое и третье условия, нам достаточно будет из этого множества взять максимальную клику. Потому
[51:41.720 --> 51:45.760]  что, еще раз, мы обеспечили, что это клика, мы обеспечили, что каждая вершина отсюда соединяется
[51:45.760 --> 51:50.680]  с каждой из u, поэтому последнее, что осталось сделать, это выделить здесь под клику. Первое и третье
[51:50.680 --> 51:54.880]  условия же выполнено, осталось здесь найти максимальную клику, чтобы сумма размеров u и v была
[51:54.880 --> 52:01.120]  максимально возможна. Поэтому, значит, нам нужны три вещи. Во-первых, для каждого множества слева
[52:01.120 --> 52:07.480]  понять, клик это или нет, ну это просто мы это уже делали, да, там какой-нибудь динамикой за два
[52:07.480 --> 52:12.200]  в степени размера этого множества. Значит, для каждого u определяем, клик это или нет. Затем,
[52:12.200 --> 52:17.920]  для каждого u мне надо понять вот это множество, вершин справа, которые соединились со всеми из u.
[52:17.920 --> 52:33.640]  Давайте я это назову какой-нибудь там dp штрих от u. Это множество, маска, точнее, маска вершин
[52:33.640 --> 52:58.680]  правой доли, каждая из которых соединена со всеми вершинами u, со всеми вершинами из u. Вот,
[52:58.680 --> 53:03.000]  значит, мне нужна такая динамика, чтобы находить вот это вот облачко. И дальше внутри этого облачка
[53:03.000 --> 53:07.160]  мне нужно выбрать максимальную клику. То есть мне нужна еще третья такая динамика, которая для
[53:07.160 --> 53:14.040]  каждого вот этого множества справа сообщает мне размер максимальной под клики, ну или там саму
[53:14.040 --> 53:20.560]  эту клику, да, как множество вершин. Давайте еще скажем, что dp какой-нибудь там два штриха w это
[53:20.560 --> 53:40.000]  размер максимальной под клики в маске w. Размер максимальной под клики в маске w. Это речь идет
[53:40.000 --> 53:52.200]  про правую долю, правая доля. Вот, если мы все это насчитаем, то еще раз, я просто перебираю за два
[53:52.200 --> 53:58.480]  в степени пополам клику здесь, фиксирую какую-то клику u здесь. Затем с помощью dp штрих я знаю,
[53:58.480 --> 54:04.680]  кого можно добавить к ней, чтобы получилось клика во всем графе. dp штрих от u насчитываю. Дальше
[54:04.680 --> 54:08.880]  внутри этого dp штрих от u мне нужно еще dp два штриха навесить, чтобы узнать размер вот этот
[54:08.880 --> 54:13.080]  максимальные клики внутри этого множества. Тогда как раз получится то, что нам нужно. Для этого u мы
[54:13.080 --> 54:25.240]  нашли максимальное по размеру v, которое дополняет его до клики. Вопросы? Хорошо. Давайте я скажу,
[54:25.240 --> 54:29.400]  что вот этот подход, который мы сделали, разделить пополам и что там сделать, называется meet in the middle.
[54:29.400 --> 54:40.800]  То есть поделить пополам, решить там как-то на половинках и потом склеить ответ из двух половинок.
[54:40.800 --> 54:51.960]  Итак, нам нужно насчитать вот эти две динамики dp два штриха.
[54:51.960 --> 55:10.040]  Здесь все несложно. Давайте мы скажем изначально, что dp... Давайте скажем следующее, что пусть слева
[55:10.040 --> 55:25.000]  n вершин. В левой доле n вершин, а справа m. И внутри каждой доли вершины занумерованы от 0 до размера
[55:25.000 --> 55:32.440]  минус 1. То есть слева вершинки 0 и так далее и минус 1, справа 0 и так далее m минус 1. То есть у нас
[55:32.440 --> 55:38.680]  как бы такая повторяющая нумерация. Слева от 0 до m минус 1 и справа от 0 до m минус 1. Ну что
[55:38.680 --> 55:46.440]  такое dp штрих, скажем, от 0, от пустой маски? Вот есть у меня пустая маска, пустое множество u,
[55:46.440 --> 55:52.280]  какое там множество слева? Вопрос, как выглядит маска вершин правой доли, каждая из которых
[55:52.280 --> 55:57.640]  соединяется всеми вершинами из u, где u пустое множество? Конечно, да, это просто 2 в степени m
[55:57.640 --> 56:04.400]  минус 1. Все вершины справа соединены со всеми вершинами с пустого множества. Ну это просто
[56:04.400 --> 56:09.600]  предикат, который всегда верный, поэтому любая вершинка здесь подойдет. Значит, мы в качестве
[56:09.600 --> 56:17.800]  dp штриха от 0 храним просто все правое множество, всю вот эту правую долю. Хорошо, ну тогда давайте
[56:17.800 --> 56:29.840]  считать, что... ну как найти какой-нибудь dp штрих от маски какой-нибудь? Вот есть маска у меня здесь
[56:29.840 --> 56:38.440]  в левой доле. Надо понять, с кем она... точнее, каково множество вершин справа, которые со всеми
[56:38.440 --> 56:44.480]  отсюда соединены. Ну давайте поступим так, как мы уже делали. Давайте мы откусим какой-то бит
[56:44.480 --> 56:49.520]  из этой маски, пусть это будет oldest. Неважно какой, вот пусть для удобства oldest, потому что его
[56:49.520 --> 56:56.240]  легче всего насчитывать. Давайте этот oldest откусим из нашей маски. Тогда как поменяется множество?
[56:56.240 --> 57:02.440]  Вот если, скажем, я знаю ответ для маски без oldest, это какое-то надмножество, понятное дело. Потому
[57:02.440 --> 57:09.520]  что, вот если я, скажем, из маски здесь слева удалю вот этот бит единственный, oldest, тогда множество
[57:09.520 --> 57:14.320]  вершин справа, которые соединиться всеми вот отсюда, оно может, понятное дело, только увеличится.
[57:14.320 --> 57:18.480]  Потому что здесь как бы новое условие добавляется, что мне нужно еще, чтобы все они были соединились
[57:18.480 --> 57:24.040]  с oldest. Поэтому я могу сделать следующее. Я могу отбросить oldest, найти dp штука для маски без oldest
[57:24.040 --> 57:29.920]  и потом еще наложить новое требование, что они все должны быть соединились с oldest. Это делается так.
[57:29.920 --> 57:42.720]  Значит, это просто-напросто dp штрих от маск без oldest, 2 в степени oldest, вот, and множество тех справа,
[57:42.720 --> 57:55.120]  которые соединились с oldest слева. Ну, по сути, это просто neighbor от oldest. Нам не нужно вот
[57:55.120 --> 57:59.760]  это множество сузить на множество тех, которые соединились с oldest. Ну, пусть это будет neighbor
[57:59.760 --> 58:14.800]  от oldest. Вот это вот эта маска соседей oldest правой долю. Согласны?
[58:14.800 --> 58:27.440]  Окей. Тогда эта форма пересчета зовут единицы. А для каждой маски мы знаем oldest, потому что мы
[58:27.440 --> 58:32.400]  его насчитываем, так как было раньше. Значит, мы знаем oldest, и мне нужно просто взять старое
[58:32.400 --> 58:36.560]  значение dp шки и поandить его с чем-то уже тоже насчитано. Ну, вот этот предпочет в самом начале делается
[58:36.560 --> 58:42.120]  за квадрат. Просто для каждой пары вершин добавляем какую-то единичку в зависимость
[58:42.120 --> 58:51.400]  запись этого neighbor. Все, это пока что за 2 в степени n пополам работает, потому что масок в левой
[58:51.400 --> 58:56.960]  доле, ну, вот их примерно столько. Если размер это n пополам, n маленький пополам, тогда всего масок
[58:56.960 --> 59:01.240]  вот столько. Каждый завод единицы считается, поэтому пока что время работы вот такой, 2 n пополам.
[59:01.240 --> 59:06.640]  Так, ну, теперь осталась последняя часть. dp 2 штриха нужно насчитать.
[59:19.640 --> 59:23.240]  Нет, мы именно что пересекаем, потому что, смотрите, вот у меня было старое множество,
[59:23.520 --> 59:29.440]  вот это вот большое. Они были соединили со всеми вот из этого множества. А теперь мне нужно добавить
[59:29.440 --> 59:33.560]  новое условие, то есть в дополнение к тому, что уже было, нужно добавить новое условие, что они
[59:33.560 --> 59:37.160]  должны быть соединили вот с этой вершинкой. То есть мне нужно взять такое подножество вот того
[59:37.160 --> 59:48.040]  большого, которое еще и вот с этим соединили, поэтому только and. Так, ну все, dp 2 штриха тогда,
[59:48.040 --> 01:00:03.600]  да. Давайте я перепишу нашу постановку. dp 2 штриха от, давайте маски. Это следующее,
[01:00:03.600 --> 01:00:09.360]  это размер максимальной подклики, который является под множеством маски. Максимальная
[01:00:09.440 --> 01:00:20.080]  мощность множества, давайте я назову сабмаск, такое, что сабмаск это клика и сабмаск это
[01:00:20.080 --> 01:00:36.840]  под множество маски. Сабмаск образует клику в правой доле, а еще сабмаск это под множество
[01:00:36.840 --> 01:00:48.880]  маски. Вот так переписал. То есть из всех из тех под множеств мне нужно выбрать максимальный
[01:00:48.880 --> 01:00:54.440]  размер так, чтобы это была клика. Хорошо, давайте тогда я еще немножко переформулирую эту задачу.
[01:00:54.440 --> 01:01:03.040]  Давайте я для каждой маски ввезу следующую функцию. Значит, это ноль, если маска это не клика,
[01:01:03.040 --> 01:01:13.960]  и мощность этого множества мощность маски, то есть по сути число единичек в этой маске,
[01:01:13.960 --> 01:01:23.160]  если маска это клика. Иначе. Тогда вот этот dp 2 штриха я могу переформулировать в терминах
[01:01:23.160 --> 01:01:34.200]  а чуть проще. Это просто максимальное значение а по всем подмаскам. Это максимум а от сабмаск,
[01:01:34.200 --> 01:01:41.240]  где сабмаск, это под множество маски.
[01:02:04.200 --> 01:02:22.240]  Я понял, сейчас, момент, момент, момент. Видимо действительно можем. Я опять рассказываю, что это
[01:02:22.240 --> 01:02:28.200]  слишком сложно. Похоже на правду. Давайте я запишу то, что мне предлагается. То есть пока про это
[01:02:28.200 --> 01:02:36.560]  давайте забудем. Но это опять скорее, скорее я просто свожу задачу к какой-то более общей,
[01:02:36.560 --> 01:02:40.600]  более общую решаю, чтобы как бы мы научились решать более общие задачи на вот этих частных
[01:02:40.600 --> 01:02:45.520]  примерах. Давайте напишем то, что вы сказали, тоже вроде работает. Значит, смотрите, как выглядит
[01:02:45.520 --> 01:02:50.320]  вот эта вот подмаска, на которой достигается максимальный размер. Давайте посмотрим,
[01:02:50.320 --> 01:02:56.120]  входит туда oldest или не входит, oldest исходной маски. Если не входит, то понятно, что нужно
[01:02:56.120 --> 01:03:06.240]  просто взять dp 2-out маски без oldest. Давайте так и напишем dp 2-out маски. Это максимум из, во-первых,
[01:03:06.240 --> 01:03:21.320]  dp 2-out маски без oldest. 2 в степени oldest. Либо мы его включаем в клику, но тогда мне нужно,
[01:03:21.320 --> 01:03:26.160]  тогда будет взять под клику из множества его соседей. И еще нужно будет добавить 1 из-за
[01:03:26.160 --> 01:03:47.680]  oldest. То есть будет, видимо, 1 плюс dp 2-о маск and neighbor от oldest. Правильно вас понял? Ну да,
[01:03:47.680 --> 01:03:51.840]  можно. Действительно, мы просто рассматриваем два случая, входит ли этот oldest в нашу подмаску.
[01:03:51.840 --> 01:03:56.680]  Если не входит, то задача сводится к более простой, когда этого oldest просто нет. Если входит,
[01:03:56.680 --> 01:04:02.320]  то мы его насильно добавляем, и осталось нам найти максимальную под клику среди всех соседей
[01:04:02.320 --> 01:04:05.680]  oldest. Ну вот, пожалуйста, по такой формуле это насчитывается, потому что это меньшая маска,
[01:04:05.680 --> 01:04:15.240]  для нее уже dp 2-о насчитано, и это есть ответ. Окей, да, согласен, можно сделать так. Сейчас.
[01:04:17.680 --> 01:04:27.560]  Вау, тогда мы получили решение, на самом деле, за 2 в n просто. Да, да, да, конечно. Прикольно,
[01:04:27.560 --> 01:04:32.720]  я не знал, спасибо. Действительно, получится когда решение общей задачи за 2 в степени пополам.
[01:04:32.720 --> 01:04:41.240]  Это 2 в степени пополам, это перебор под клик слева действительно такой. Согласен, хорошо. Но все-таки
[01:04:41.240 --> 01:04:45.600]  я еще расскажу этот кусок про сведение к общей задачи, решение общей задачи. Собственно,
[01:04:45.600 --> 01:04:51.000]  здесь у меня будет похуже асимптатика, но зато мы решим, какую задачу побольше,
[01:04:51.000 --> 01:05:07.800]  которая тоже сама по себе интересна. Так, вернемся сюда. Что здесь я сделал, почему это верная формула?
[01:05:07.800 --> 01:05:13.400]  Ну, потому что, когда я беру dp 2-о отмазки, по сути, что вот тут написано? Когда я беру все
[01:05:13.400 --> 01:05:17.400]  под множество, у меня либо это не клика, тогда a это ноль, и она как бы на максимум не влияет,
[01:05:17.400 --> 01:05:23.960]  либо это клика, с обмазкой это клика, тогда h от нее, это просто ее размер. Действительно,
[01:05:23.960 --> 01:05:30.440]  здесь я как раз-таки выбираю максимальный размер под множество, который является кликой.
[01:05:30.440 --> 01:05:37.640]  Вот, ну давайте тогда сделаем следующее. Так, кончились названия для dp-шки, пусть будет b.
[01:05:37.640 --> 01:05:49.400]  b, kt, mask-t. Значит, это следующая вещь. Это опять-таки максимальное значение по всем подмазкам,
[01:05:49.400 --> 01:05:59.240]  где с обмазкой это под множество маски. Но при этом это не просто под множество,
[01:05:59.240 --> 01:06:07.640]  а такое под множество, которое гарантированно совпадает в первых k-битах. С обмазк и маск
[01:06:07.640 --> 01:06:22.360]  совпадают в старших k-битах, в старших k-разрядах. Вот, значит, мы свели задачу к более общей,
[01:06:22.360 --> 01:06:29.360]  и сейчас эту более общую решим с помощью такой динамики. То есть, мы когда фиксируем k-шку,
[01:06:29.360 --> 01:06:33.400]  мы перебиваем не все под множество, а только те, у которых первый k-бит фиксирован. То есть,
[01:06:33.400 --> 01:06:37.960]  если бы у меня была произвольная маска, я хочу перебрать все ее под множество, то здесь я
[01:06:37.960 --> 01:06:42.920]  вот этот вот как бы заморозил, префикс длиныка заморозил, и перебираю только под маски,
[01:06:42.920 --> 01:06:46.480]  которые вот здесь могут что-то менять. То есть, это у меня фиксировано, а здесь может что-то
[01:06:46.480 --> 01:06:59.680]  быть поменено. Так, ну хорошо. Че нужно сделать? Да, ну, во-первых, база здесь будет вот такая,
[01:06:59.680 --> 01:07:16.600]  видимо, m-1. Вот маски. Это просто out маски. Просто m, sorry, просто m. Напоминаю, m – это число
[01:07:16.600 --> 01:07:21.800]  вершин справа. Значит, если я фиксировал все m-бит, то как бы, ну, единственная подмаска этой
[01:07:21.800 --> 01:07:25.800]  маски, в которой все биты фиксированы, это, собственно, сама маска. Поэтому здесь нет
[01:07:25.800 --> 01:07:29.920]  никаких случаев. Сабмаск просто равно маске обязательно, потому что у них совпадают все биты.
[01:07:29.920 --> 01:07:37.200]  Значит, это просто out маски. Это будет такая база. Вот, а дальше будет переход, пересчет.
[01:07:37.200 --> 01:07:57.560]  Значит, дальше будет пересчет. Следующий. Смотрите, давайте мы от k научимся пересчитать k-1.
[01:07:57.560 --> 01:08:04.720]  Вот пусть у меня написано, пусть у меня насчитано bkt для всех масок, я хочу насчитать bk-1 для
[01:08:04.720 --> 01:08:10.200]  всех масок. Изначально у меня k равно m. Смотрите, что такое? Вот пусть у меня есть какая-то маска,
[01:08:10.200 --> 01:08:18.960]  и у меня фиксированы первые ее k-1 бит. Дальше у меня получается, по сравнению со случаем,
[01:08:18.960 --> 01:08:23.200]  когда заморожены первые k-бит, у меня, по сути, возникает, ну, как бы, только одна степень
[01:08:23.200 --> 01:08:27.280]  свободы – это то, брать вот этот бит или нет, в подмаску брать его или нет. Значит, ну, в случае,
[01:08:27.280 --> 01:08:32.400]  когда здесь нолик стоит, когда вот этот cut и слева бит равен нулю, тогда, на самом деле,
[01:08:32.400 --> 01:08:36.600]  никакой свободы не появилось, потому что если здесь ноль, то подмаска тоже вынуждена здесь
[01:08:36.600 --> 01:08:42.040]  иметь ноль. Нельзя быть под множеством, поменяв здесь нолик на единицу, это будет как бы,
[01:08:42.040 --> 01:08:47.360]  ну, расширение, да, какой-то новый элемент появится. Поэтому, если здесь стоял нолик, то на самом деле
[01:08:47.360 --> 01:08:54.240]  можно считать не просто k-1 бит заморожено, а все k, потому что это нельзя менять. Давайте напишем,
[01:08:54.240 --> 01:09:05.560]  какой номер у этого товарища? Всего их m, нулевой и так далее, m-1, тогда какой номер у вот этого вот?
[01:09:05.560 --> 01:09:23.640]  Да, похоже, что этот бит имеет вот такой номер. Ну, если ты справа, да, мы номируем,
[01:09:23.640 --> 01:09:28.840]  как всегда справа, тогда номер этого бита вроде как m-k, потому что, например, когда k равно 2,
[01:09:28.840 --> 01:09:35.520]  у меня заморожен первый бит, я хочу взять второй, это как раз m-2, да, вроде верно. Ну вот,
[01:09:35.520 --> 01:09:45.720]  значит, напишем следующее, что если неверно, что в этой маске включен этот бит m-k, тогда динамика
[01:09:45.720 --> 01:09:56.760]  очень простая. Не динамика, а массив b. У меня b-k-1 mask t равно просто b-k mask t, потому что если
[01:09:56.760 --> 01:10:02.080]  первый k-1 бит фиксированный, то следующий тоже фиксированный, он равен нулю. Иначе, если здесь
[01:10:02.080 --> 01:10:08.760]  стоит единичка, то я могу его проварьировать. Могу поставить как нолик, так и единицу. Давайте
[01:10:08.760 --> 01:10:13.320]  его переберу. Давайте насильно здесь поставлю ноль. Тогда, если я поставлю здесь насильно ноль,
[01:10:13.320 --> 01:10:17.280]  то можно считать, что у меня замороженный первый k-bit, но маска стала маской без этого бита.
[01:10:17.280 --> 01:10:21.480]  Если я ставлю здесь единицу, то можно считать, что у меня замороженный k-bit,
[01:10:21.480 --> 01:10:27.480]  а маска осталась такой, какая была. Поэтому иначе я напишу следующее, значит b-k-1 mask
[01:10:27.480 --> 01:10:38.360]  равно максимум из b-k-t mask, то есть это у меня остается. Это случай, когда я не меняю вот этот
[01:10:38.360 --> 01:10:43.200]  вот бит. Кат и слева бит я не меняю. Могу считать, что он тоже замороженный, тогда у меня
[01:10:43.200 --> 01:10:49.080]  получается вот dp отсюда. И второе, это когда я его меняю с единицы на ноль, маска тогда у меня
[01:10:49.080 --> 01:10:59.480]  поменяется, станет маской без этого бита, mask xor 2 в степени минус k. Соответственно, я поменял
[01:10:59.480 --> 01:11:04.280]  единицу на ноль и считаю, что опять первый k-bit заморожен. То есть я поставил здесь насильно
[01:11:04.280 --> 01:11:09.880]  нолик, тогда первый k-bit как бы замороженный, я просто беру вот dp с k замороженными битами,
[01:11:09.880 --> 01:11:16.600]  которые уже я посчитал. Вот вроде все. Ну и тогда ответ, это просто ответ,
[01:11:16.600 --> 01:11:29.080]  dp 2 штриха для каждой маски, это просто-напросто b-нулевое маск. Потому что мне нужно по всем
[01:11:29.080 --> 01:11:34.320]  подножиям взять максимум, и значение здесь ноль, значит, что у меня никакие биты не заморожены.
[01:11:34.320 --> 01:11:39.560]  Я могу любые биты менять, тем самым я как раз таки возьму максимум по всем возможным подножиям,
[01:11:39.560 --> 01:11:45.440]  у которых все биты какие угодно, главное, что это подножие маски. Вопросы?
[01:11:52.240 --> 01:11:59.840]  Ну и вот собственно отсюда и берется 2 в степени m на m, потому что у меня вот эта динамика имеет
[01:11:59.840 --> 01:12:04.360]  размерность 2 в степени m на m, а пересчет за единицу, потому что это либо просто какое число,
[01:12:04.360 --> 01:12:11.120]  либо максимум из двух чисел. Поэтому вот эта вещь насчитывается у меня за 2 в м на m, но поскольку
[01:12:11.120 --> 01:12:18.480]  я вспоминаю, m это размер правой доли, то это по сути просто 2 в н пополамтый на n. Ну на н пополам,
[01:12:18.480 --> 01:12:25.320]  но половинку можно стереть. Получилось решение сложнее и медленнее, чем то, что вы предложили,
[01:12:25.320 --> 01:12:31.040]  но зато мы как бы решили еще попутно более общую задачу, вот такую. То есть у вас есть просто
[01:12:31.040 --> 01:12:36.520]  произвольный какой-то набор чисел, для каждой маски принадлежит своя ашка. И мы научились
[01:12:36.520 --> 01:12:41.560]  считать максимум ашек по всем подножествам. Но это в принципе довольно интересно само по себе.
[01:12:41.560 --> 01:12:48.280]  Так, есть какие-нибудь вопросы?
[01:12:48.280 --> 01:13:08.920]  Не уверен, что сработает. Давайте немножко порисуем. Давайте на 3 хотя бы попробуем,
[01:13:08.920 --> 01:13:14.400]  мне кажется уже с 3 будут беды какие-то. Вот есть 3 множества. Тогда мне кажется,
[01:13:14.500 --> 01:13:19.220]  что чтобы все однозначно задать, вам нужно перебрать под множество здесь и под множество
[01:13:19.220 --> 01:13:24.680]  здесь. Только зная и то и то, вы знаете, кого можно взять отсюда, чтобы они были со
[01:13:24.680 --> 01:13:28.680]  всеми соедены и здесь нужно выбрать максимальную подклику. А если вы фиксируете, скажем,
[01:13:28.680 --> 01:13:33.440]  только одно, вот это вот множество, только одно, тогда здесь в зависимости от того что будет здесь,
[01:13:33.440 --> 01:13:41.280]  у вас это влияет на вот это. Поэтому не перебирать вот это не понятно как. То есть это возможно как-то
[01:13:41.280 --> 01:13:45.480]  и доводится, и на самом деле что-то похоже, там еще чуть-чуть лучше можно симпатику улучшить,
[01:13:45.480 --> 01:13:49.480]  в смысле уменьшить, но вот по крайней мере так с ходу непонятно, как это делать.
[01:13:49.480 --> 01:14:05.800]  Так, ладно. Тогда давайте последние 10 минут обсудим немножечко динамику по профилю.
[01:14:05.800 --> 01:14:14.480]  Так, не шибко подробно. ДП по профилю.
[01:14:23.360 --> 01:14:30.400]  Ну давайте мы решим такую задачу. Есть у меня вот такая вот табличка n на m. Клеточная табличка
[01:14:30.400 --> 01:14:39.960]  n на m. У меня есть доминожки 2 на 1. Могу их класть вертикально или горизонтально. Моя задача
[01:14:39.960 --> 01:14:44.840]  это найти количество возможных замощений вот этой таблички, вот этой полоски такими доминожками.
[01:14:44.840 --> 01:14:45.960]  Доминожками 2 на 1.
[01:14:59.480 --> 01:15:02.840]  Вот замощение значит, что вы можете класть доминожки так, чтобы они не пересекались,
[01:15:02.840 --> 01:15:05.520]  при этом каждая клетка была покрыта ровно одной доминожкой.
[01:15:05.520 --> 01:15:18.640]  Вот. Это уже не n потрудная задача, но мы ее решим за, в общем, экспоненту от n. То есть на самом
[01:15:18.640 --> 01:15:25.040]  деле там есть какая-то явная формула. Если у вас n фиксировано, то у вас есть формула явная для
[01:15:25.040 --> 01:15:31.800]  ответа в зависимости от m, но мы с помощью динамики по профилю поймем, по крайней мере, как это считать
[01:15:31.800 --> 01:15:37.000]  для каких-то маленьких значений. Итак, смотрите, вот давайте мы будем как-то заполнять нашу табличку
[01:15:37.000 --> 01:15:43.680]  слева направо. Давайте считать, что у нас какой-то префикс уже заполнен, то есть скажем вот это вот
[01:15:43.680 --> 01:15:50.160]  все уже покрыто доминожками как нужно. Но я не могу просто так провести вот такой вертикальный разрез,
[01:15:50.160 --> 01:15:57.440]  потому что бывают горизонтальные доминожки, которые через него как бы за него выступают. То есть не
[01:15:57.440 --> 01:16:04.280]  только у меня покрыто все левее этого разреза, но еще и какие-то точки справа. Так вот, давайте тогда
[01:16:04.280 --> 01:16:12.400]  мы в состоянии динамики запомним следующее. В каких строчках происходит такое вылезание, то есть
[01:16:12.400 --> 01:16:17.640]  в каких строчках находится горизонтальная доминожка, которая вылезает за нашу линию разреза. Ну и
[01:16:17.640 --> 01:16:25.880]  соответственно номер столбца. Нам будет этого достаточно. Динамика будет такая, dp от номера
[01:16:25.880 --> 01:16:33.360]  столбца и от маски. Давайте я не буду это писать словами. Вот что это значит. Это значит,
[01:16:33.360 --> 01:16:38.160]  что мы рассматриваем только первый g столбцов нашей таблички. Только первый g столбцов. И они
[01:16:38.160 --> 01:16:45.400]  целиком покрыты. То есть все, что вот эти вот первые g, они целиком покрыты. Но при этом могут какие-то
[01:16:45.400 --> 01:16:51.840]  доминожки, лежащие вот в этом вот начале, вытарчиваться вправо. Это обязательно такие горизонтальные
[01:16:51.840 --> 01:16:56.960]  доминожки. И мы считаем, что множество строк, в которых лежат вот такие доминожки, которые нам
[01:16:56.960 --> 01:17:01.400]  как бы торчат вправо, заметают множество масок. Соответственно множество вот по вот этой вот,
[01:17:01.400 --> 01:17:10.560]  ну множество строк. Множество по вот этому вертикальному измерению. Тогда если у меня фиксирована
[01:17:10.560 --> 01:17:16.760]  какая-то маска. Давайте еще раз картинку нарисуем. Вот у меня фиксирован столбец. Фиксировано,
[01:17:16.760 --> 01:17:23.120]  где происходит вот это вот торчание. Тогда вопрос, как я могу продолжить мою картинку так,
[01:17:23.120 --> 01:17:28.480]  чтобы вот этот следующий столбец g плюс первый стал целиком покрыт, а дальше опять может быть
[01:17:28.480 --> 01:17:33.520]  какое-то вытарчивание. То есть моя задача такая. Если у меня фиксирована g, то это значит, что у меня
[01:17:33.520 --> 01:17:39.680]  первый g столбцов точно покрыты. А первый g точно покрыты. А в следующий g плюс первый может что-то
[01:17:39.680 --> 01:17:45.840]  торчать вот, ну точнее торчит что-то из множества маски. Тогда, когда я расширяюсь жишкой,
[01:17:45.840 --> 01:17:51.000]  перехожу на 1 вперед, мне нужно целиком покрыть вот этот появивший новый столбец. То есть тут уже
[01:17:51.000 --> 01:17:56.320]  что-то покрыто за счет вытарчивания, но оставшие клетки тоже нужно покрыть. Вот. И опять могут
[01:17:56.320 --> 01:18:04.280]  появиться какие-то новые торчащие клетки уже в следующем g плюс втором столбце. Поэтому мы будем
[01:18:04.280 --> 01:18:09.440]  действовать как-то так. Мы фиксируем g и маску. Затем мы фиксируем множество, скажем, вот этих
[01:18:09.440 --> 01:18:14.120]  доминошек, где будет происходить торчание в следующий столбец, а оставшиеся мне нужно тогда
[01:18:14.280 --> 01:18:36.080]  покрыть вертикальными доминошками. Давайте это запишем. Давайте я хочу из состояния g,
[01:18:36.080 --> 01:18:46.520]  маск 1, перейти в состояние g плюс 1, маск 2. То есть у меня в коде будет следующее. В цикле по g,
[01:18:46.520 --> 01:18:53.200]  в цикле по маск 1, в цикле по маск 2. Я пытаюсь из этого состояния перейти сюда. Что это значит?
[01:18:53.200 --> 01:18:58.040]  Давайте еще раз нарисуем. Вот есть g плюс столбец. Дальше множество строк, в которых происходит
[01:18:58.040 --> 01:19:02.840]  торчание в следующий g плюс первый, это маск 1. Вот здесь у меня или там что-то лежит, вот здесь,
[01:19:03.000 --> 01:19:13.480]  и вот здесь. Это множество, это маск 1. Дальше. Я хочу покрыть целиком вот это вот следующий столбец
[01:19:13.480 --> 01:19:19.880]  g плюс 1 и при этом еще сделать так, чтобы в следующий торчало что-то из множества маск 2. То есть я
[01:19:19.880 --> 01:19:24.360]  хочу положить горизонтальные доминошки, которые начинаются вот здесь и торчат сюда, в множестве
[01:19:24.360 --> 01:19:32.560]  строк маск 2. Вот это вот будет маск 2. Я тем самым перебираю и маск 1, и маск 2. Тогда если у меня
[01:19:32.560 --> 01:19:37.000]  это фиксировано, то есть у меня фиксирован множество доминошек, которые торчат из g в g плюс 1,
[01:19:37.000 --> 01:19:44.040]  из g плюс 1 в g плюс 2, тогда на самом деле все, что мне остается, чтобы доза мастить в g плюс
[01:19:44.040 --> 01:19:48.680]  первый столбец, мне остается здесь класть только вертикальные доминошки. Никакая горизонтальная
[01:19:48.680 --> 01:19:52.960]  уже не валидна, потому что если горизонтальная вот такая, то она должна была быть в маск 1,
[01:19:52.960 --> 01:19:58.600]  она не лежит. То есть если эта клетка не лежит в маск 1, то она не лежит в маск 1,
[01:19:58.600 --> 01:20:03.360]  ну значит нельзя положить такую доминошку. Здесь уже все покрыто, мы не можем еще одну добавить.
[01:20:03.360 --> 01:20:10.040]  То же самое мы не можем ее положить вот так, потому что иначе бы она была в маск 2. В маск 2 мы считаем,
[01:20:10.040 --> 01:20:16.080]  что ее уже нет. Поэтому все оставшиеся клетки, не лежащие ни в маск 1, ни в маск 2, нужно покрыть
[01:20:16.080 --> 01:20:30.720]  обязательно вертикальными доминошками. Оставшиеся свободные клетки нужно покрыть
[01:20:30.720 --> 01:20:44.680]  вертикальными доминошками. И тогда понятно, что такое покрытие,
[01:20:44.680 --> 01:20:49.400]  оно либо одно, либо их нет вообще. То есть представьте, у вас есть столбец G плюс первый,
[01:20:49.400 --> 01:20:54.120]  у вас что-то в нем уже покрыто, уже что-то занято, вам нужно все оставшиеся свободные
[01:20:54.120 --> 01:20:58.680]  покрыть вертикальными доминошками 2 на 1. Ну понятно, это можно сделать тогда и только тогда,
[01:20:58.680 --> 01:21:04.680]  когда все вот эти вот промежуточки, все блоки свободных клеток имеют четную длину. Потому что
[01:21:04.680 --> 01:21:10.240]  если есть там три подряд непокрытые клетки, то вы никак их вертикальными доминошками 2 на 1
[01:21:10.240 --> 01:21:17.080]  не покроете. Но если четная длина, то такой переход будет ровно 1. Поэтому если мы напишем
[01:21:17.080 --> 01:21:22.600]  какую-то процедуру, которая по двум маскам, маск 1 и маск 2, проверяет как раз такие условия,
[01:21:22.600 --> 01:21:29.240]  что можно вот здесь все покрыть вертикальными доминошками, то мы тем самым получим, можно ли
[01:21:29.240 --> 01:21:34.080]  вообще сделать такой переход из G, маск 1 в G плюс 1, маск 2. Причем такой переход будет ровно 1.
[01:21:34.080 --> 01:21:38.480]  То есть либо такой переход вообще нельзя построить, то есть никак нельзя здесь замастить все
[01:21:38.480 --> 01:21:44.240]  свободные клетки. Либо он будет ровно 1, когда все вот эти дырочки четной длины, и тогда, соответственно,
[01:21:44.240 --> 01:21:49.800]  такое покрытие единственное. Такое доза мощения единственное. Значит у меня будет в зависимости
[01:21:49.800 --> 01:21:54.880]  того, есть ли такой переход, то есть можно ли так делать, у меня будет просто прибавление ДПшки.
[01:21:54.880 --> 01:22:18.520]  Вот это вот плюс равно ДП житая маска 1, если вот это вот возможно. Я знаю вот это торчание,
[01:22:18.520 --> 01:22:22.960]  знаю это торчание, потом понимаю, что если можно вот здесь дозамастить все вертикальными,
[01:22:22.960 --> 01:22:26.360]  то это можно сделать единственным образом. И поэтому количество способов нужно просто
[01:22:26.360 --> 01:22:31.640]  увеличить на вот это вот ДП житая маска 1. То есть вот я ни на что не умножаю, потому что если бы,
[01:22:31.640 --> 01:22:35.200]  скажем, если бы у меня было несколько способов положить здесь вертикальные доминошки для
[01:22:35.200 --> 01:22:39.160]  дозамастения, тогда нужно было бы умножить на это количество, но оно всегда не больше чем 1,
[01:22:39.160 --> 01:22:47.520]  поэтому умножения никаких нет. Вот такая формула пересчета. Давайте базу и ответ мы пропустим.
[01:22:47.520 --> 01:22:56.440]  Базу и ответ мы пропустим, оставим упражнением. А сим-точку посчитаем.
[01:22:56.440 --> 01:23:07.000]  На самом деле можно понять, что она будет вот такая.
[01:23:07.000 --> 01:23:23.880]  Она будет вот такая. Вот почему. Потому что смотрите, у меня состояние динамики m на 2 венной,
[01:23:23.880 --> 01:23:28.760]  для каждого столбца и для каждой маски у меня есть свое состояние динамики, а дальше я перебираю
[01:23:28.760 --> 01:23:39.080]  2 венной маск 2. То есть если у меня фиксировано g маск 1, то я перебираю маск 2. У меня будет
[01:23:39.080 --> 01:23:46.520]  3 вложенных цикла g, маск 1, маск 2. Суммарно это будет как раз 4 венны на m. Но еще нужно будет
[01:23:46.520 --> 01:23:56.240]  как-то изначально предпочитать для каждой пары масок маск 1 и маск 2, можно ли дозамастить все
[01:23:56.240 --> 01:24:00.480]  вот в этом новом столбце. То есть мне нужно исходно для каждой пары, давайте я там какую-нибудь
[01:24:00.480 --> 01:24:11.240]  процедуру OK напишу. OK маск 1, маск 2. Это как бы флаг, можно ли сделать переход из маска 1 в маск 2.
[01:24:11.240 --> 01:24:21.560]  Можно ли сделать переход. Как раз в этом смысле, что если я их вот так вот накладываю, с лева маска 1,
[01:24:21.560 --> 01:24:26.600]  с права маск 2, то все вертикальные свободные окошки имеют четную длину, то есть их можно
[01:24:26.600 --> 01:24:34.320]  покрыть вертикальными доминожками. И это как раз работает за 4 венны на n, потому что я для каждой
[01:24:34.320 --> 01:24:40.360]  пары масок смотрю на то, где они не пересекаются, ну точнее, те свободные клетки, которые остаются
[01:24:40.360 --> 01:24:43.820]  непокрытыми, и проверяю, что все блоки имеют там четную длину, чтобы их можно было покрыть
[01:24:43.820 --> 01:24:48.760]  вертикальными доминожками. Это будет вот эта вот асимптотика. Ну и все, в сумме получается 4 венны на n,
[01:24:48.760 --> 01:24:58.960]  на n плюс m. Ок? Вот, ну это, конечно, убийственная асимптотика, да, но если n там какой-нибудь,
[01:24:58.960 --> 01:25:05.280]  не знаю, 5, 6, 7, то в принципе ничего страшного в этом нет. То есть если n, скажем, 6, а m, что-то
[01:25:05.280 --> 01:25:13.960]  порядка тысячи, то в принципе вот мы решили задачу. Вот, ну тогда все, спасибо.
