[00:00.000 --> 00:09.720]  Восьмая лекция нашего курса, функции процедуры триггера, расширенные возможностями.
[00:09.720 --> 00:21.880]  Позгресс, процедурное расширение, позволяющее добавлять сложную логику обработки запросов.
[00:21.880 --> 00:34.440]  Сегодня посмотрим на эту тему и будет сегодня лекция чуть короче обычного.
[00:34.440 --> 00:46.520]  Функции процедуры, в принципе здесь, поскольку вы уже люди, представляющие себе,
[00:46.520 --> 00:56.320]  что такое компьютер science и программирование, функции процедуры для вас соответственно,
[00:56.320 --> 01:06.400]  вещь вполне знакомая. В позгрессе здесь нет каких-то серьезных нюансов по сравнению с
[01:06.400 --> 01:12.520]  общепринятыми подходами, исключение здесь, пожалуй, составляет только то, что в отличие
[01:12.520 --> 01:21.640]  от типичных императивных языков, с которыми вы встречались, то, что в позгресс, во всяком
[01:21.640 --> 01:30.280]  случае в том процедуре расширения PLPG SQL, которая по умолчанию используется в позгрессе,
[01:30.280 --> 01:38.880]  функции процедуры там пишутся не на императивных языках соответственно, а на таком вот немножко
[01:38.880 --> 01:49.080]  доработанном варианте SQL, то есть по сути дела получается тоже смесь декларативной с императивной
[01:49.080 --> 01:58.280]  парадигмой. Можно писать как функции, так и процедуры, в позгрессе соответственно,
[01:58.280 --> 02:05.520]  отличаются они довольно просто, процедура не возвращает никогда никакие значения и есть разница
[02:05.520 --> 02:14.600]  с точки зрения вызова функций процедур, вызов происходит посредством специальной команды call,
[02:14.600 --> 02:20.480]  в то время как вызов функции допустим в принципе в любом месте, где можно расположить встроенную
[02:20.480 --> 02:32.360]  функцию SQL для того, что вы можете, если из таких вот относительно фантастических примеров назначить
[02:32.360 --> 02:43.160]  функцию на заполнение по умолчанию какого-нибудь поля в таблице, сделать там не дата стэмп,
[02:43.160 --> 02:48.960]  а не дейт стэмп, а сделать какую-нибудь свою специфическую функцию, которая будет вам выдавать
[02:48.960 --> 03:00.080]  например время исключительно там в вашем каком-то формате, условно говоря, конечно,
[03:00.200 --> 03:05.640]  не ограничивается, не только можно время менять, можно в принципе, повторюсь, в любое место,
[03:05.640 --> 03:12.480]  где употреблены функции встроенной SQL, можно вставлять, можно помещать в свою определенную
[03:12.480 --> 03:18.960]  функцию при условии, что она соответственно подходит по контексту, по принимаемым,
[03:18.960 --> 03:25.520]  возвращаемым значениям и таким образом существенно расширять встроенный функционал.
[03:25.520 --> 03:37.040]  Также на TLPJ SQL, в частности, возможно писать не только сугубо функции процедуры,
[03:37.040 --> 03:47.320]  есть еще подкласс функций специфических под названием триггера, то есть такие функции,
[03:47.320 --> 03:53.640]  которые выполняются условно независимо от ваших действий, ну скажем так, они конечно
[03:53.640 --> 04:01.960]  зависит от реально производимых действий, но есть нюанс заключающийся в том, что они
[04:01.960 --> 04:12.000]  непроизвольно выполняются при операциях, добавления, удаления, обновления данных к таблице.
[04:12.000 --> 04:25.840]  Также, по умолчанию, модуль TLPJ SQL встроен в поставку стандартной позгрысы, но при желании
[04:25.840 --> 04:33.880]  его можно исключить, таким образом повысив, например, безопасность на некоторой степени
[04:33.880 --> 04:41.600]  базы данных, тем что она будет более предсказуема и меньше соответственно возможностей будет по ее
[04:41.600 --> 04:50.440]  изменению, если уж у него пользователь, то у каких-то сторонних администраторов. А как уже было
[04:50.440 --> 04:57.560]  сказано, функции и процедуры различаются, два вида хранимых процедур, то есть родовое понятие
[04:57.560 --> 05:02.120]  хранимые процедуры, но видовое, одно из видовых понятий, как бы такое-то автологично немного,
[05:02.120 --> 05:08.320]  тоже называется процедурой, то есть как уже было сказано, не возвращает результат процедуры в
[05:08.320 --> 05:16.120]  отличие от функции, специальный оператор вызова и также важное еще отличие функции от процедуры
[05:16.120 --> 05:21.680]  заключается в том, что функции всегда выполняются в рамках одной транзакции, а процедуры могут
[05:21.680 --> 05:37.280]  транзакциями управлять. В качестве хранимых функций и процедурах можно использовать
[05:37.280 --> 05:45.680]  оператор SQL, в любом случае для языка PLPG SQL, потому что Postgres в принципе понимает не
[05:45.680 --> 05:52.480]  только PLPG из коробки, он также понимает C по умолчанию, как внутренний язык базы данных
[05:52.480 --> 06:02.440]  Postgres, также еще Python, Perl и TCL. Для других языков также есть свои расширения, можно в принципе
[06:02.440 --> 06:12.760]  писать свои функции и на них. Также важно отметить, что у нас нет каких-то способов передачи внутри
[06:12.760 --> 06:21.360]  процесса базы данных, скажем так, нет прямого способа, задокументированного в стандарте или
[06:21.360 --> 06:28.400]  в документации непосредственно, нет там команды SafeResult, какого-то условно говоря, такого нет,
[06:28.400 --> 06:33.920]  мы не можем передавать данные внутри процесса нашей базы данных, в широком смысле, так может
[06:33.920 --> 06:39.080]  быть много процессов. В общем, у нас нет возможности напрямую передавать эти данные через какую-то
[06:39.080 --> 06:49.160]  переменную или глобальную переменную, а у нас данные передаются между вызовами функций и
[06:49.160 --> 06:56.400]  процедур путем предоставления пользователям внутри своего запроса из клиентского приложения.
[06:56.400 --> 07:06.160]  Ну, как уже было сказано, что у нас есть несколько, грубо говоря, встроенных языков,
[07:06.160 --> 07:19.400]  на которых можно писать под программы. Главное, чтобы он был известен серверу, есть известные
[07:19.400 --> 07:23.040]  серверы из коробки, что называется, есть неизвестные, для них, повторюсь, есть
[07:23.760 --> 07:33.680]  здесь вы в принципе не ограничены. Ну, конечно, чем нативнее уровень, тем оптимальнее будут
[07:33.680 --> 07:47.120]  работать ваши запросы, и самое главное, тем прочее будет оптимизатору запросов ваши запросы считать,
[07:47.120 --> 07:51.240]  составлять по ним статистику и как-то прогнозировать с точки зрения составления
[07:51.240 --> 07:56.280]  деревьев запросов и каких-то оптимальных путей выполнения тех команд, с которыми
[07:56.280 --> 08:03.800]  вы обращаетесь к серверу базы данных. В этом смысле, в идеале, лучше писать, конечно, лучше,
[08:03.800 --> 08:11.960]  не то что лучше, проще для сервера писать, чтобы вы писали команды на PLPG SQL.
[08:11.960 --> 08:20.840]  Синтаксис приведен на экране такой минималистичный, синтаксис создания функций.
[08:20.840 --> 08:26.080]  Да, мы отдельно про процедуры в данном случае не говорить не будем с вами, потому что по большому
[08:26.080 --> 08:36.640]  счету это практически синонимичное изложение будет. Поэтому, с точки зрения синтаксис,
[08:36.640 --> 08:43.120]  с точки зрения примеров, по сути дела все, о чем мы сейчас скажем, применительно к функциям,
[08:43.120 --> 08:51.320]  применимо и к процедурам. Небольшие различия подробно описываются в стандарте документации.
[08:51.320 --> 08:59.960]  А синтаксис приведен на слайде, он минималистичен в том смысле, что если вы обратитесь к документации,
[08:59.960 --> 09:05.200]  увидите, что, конечно, гораздо более разветвленное есть описание, но по большому счету все,
[09:05.200 --> 09:13.640]  что нам нужно, это для создания функций, имеется в виду команда Create Function или Create Procedure будет
[09:13.640 --> 09:23.360]  в случае процедуры, имя функции с параметрами и команда Returns, после которой следует тип
[09:23.360 --> 09:33.560]  возвращаемого значения, и тело функции и указание на язык. Важно отметить еще, что у нас есть различного
[09:33.560 --> 09:43.680]  рода модификаторы, например, переменных. Мы можем назначать тип In, Out, Variedic, In, Out, то есть мы можем
[09:43.680 --> 09:51.560]  задавать явно по отношению к переменным, могут ли они принимать возвращаемые значения или не могут,
[09:51.560 --> 10:05.720]  может ли функция их перезаписывать или нет. Функция может возвращать пустой тип Void, то есть не
[10:05.720 --> 10:14.520]  возвращать ничего, грубо говоря, можно обозначить это как Void, и по сути дела ваша функция станет
[10:14.520 --> 10:26.600]  аналогом процедуры. Обязательно указывается язык, и варианты указания описания тела функции можно
[10:26.600 --> 10:34.080]  указывать в одинарных хавычках, можно в двойных долларах, лучше в двойных долларах указывать,
[10:34.080 --> 10:46.720]  и внутри тела может быть объявление в виде блока. Если что-то простое пишется,
[10:46.720 --> 10:54.800]  там можно, конечно, максимально все это упростить, но по умолчанию у вас есть три,
[10:54.800 --> 11:01.000]  ну здесь даже по сути, это тогда, наверное, четыре ключевых слова для объявления блока,
[11:01.000 --> 11:08.360]  это Declare, оно не обязательно, BeginEnd обязательно и exceptions тоже не обязательно для обработки
[11:08.360 --> 11:20.440]  исключения. На уровне Declare вы объявляете описание локальных переменных, их имя, их тип данных,
[11:20.440 --> 11:29.640]  да, кстати говоря, тип данных, она можно указывать в переменную и тип данных в объявление функции.
[11:31.000 --> 11:38.880]  Можно указывать просто тип данных, и тогда вы должны будете обязательно следить за тем,
[11:38.880 --> 11:44.520]  что вы передаете и за тем, как вы обращаетесь к своим аргументам.
[11:44.520 --> 11:54.040]  С точки зрения, опять же, возвращаясь в будущую структуру объявления, определение функции,
[11:54.040 --> 12:03.160]  вернее, в разделе BeginEnd содержится список выполнимых операторов, как сказано было,
[12:03.160 --> 12:11.440]  да, допускается раздел exception, обрабатывающий исключения, но он тоже не обязателен. С точки
[12:11.440 --> 12:19.440]  зрения синтакса, что возможно, ну понятно, здесь все довольно классическим образом выглядит,
[12:19.440 --> 12:31.200]  набор операторов для витления, вот условный оператор if-then и он начинается, оператор if-else,
[12:31.200 --> 12:39.520]  вернее, прошу прощения, начинается он с if условия then и может либо иметь внутри себя какое-то
[12:39.520 --> 12:50.840]  разветвление за счет союза else, да, или заканчивается просто по проверке единственного условия.
[12:50.840 --> 13:04.440]  Можно сделать проверку альтернативных вариантов через оператор case, здесь есть два варианта уже
[13:04.440 --> 13:12.200]  более сущностно отличающихся, мы можем проверять через case when условия или мы можем проверять
[13:12.200 --> 13:18.640]  значение выражения, если мы после case непосредственно написали какое-то выражение, то после when можем
[13:18.640 --> 13:26.440]  писать варианты значений, которые это выражение принимает и соответственно ветвить нашу логику
[13:26.440 --> 13:37.280]  по этим значениям. Есть операторы цикла, базово цикл обозначается через команды loop and loop,
[13:37.280 --> 13:48.480]  ключевые слова, вернее, внутри этих ключевых слов находятся операторы выполняемые, а количество
[13:48.480 --> 13:53.400]  повторений цикла определяется с помощью заголовков, тоже в общем-то знакомых по
[13:53.400 --> 14:02.240]  семейству и подобных во всяком случае языков точно. While условия, форма переменная in начало,
[14:02.240 --> 14:11.960]  многоточие, конец buy и после buy можно шаг указать переменной и for it, если у нас есть какой-то
[14:11.960 --> 14:23.280]  массив данных. Заголовки при этом пишутся перед ключевым словом loop первым, без заголовка цикл
[14:23.280 --> 14:31.760]  повторяется бесконечно. Обратите внимание на for цикл for у нас он имеет такой необычный,
[14:31.760 --> 14:36.160]  наверное, синтаксис с точки зрения наших процедурных классических языков, потому что мы
[14:36.160 --> 14:49.280]  обозначаем после слова in начало, многоточие и конец нашего диапазона, в котором мы работаем по
[14:49.280 --> 14:55.680]  циклу. То есть не предельные условия на границу, а обе границы цикла ставим, причем в такой не
[14:55.680 --> 15:02.840]  совсем классической записи, через многоточие. Посмотрим на примеры, ну тоже довольно все здесь,
[15:02.840 --> 15:16.480]  довольно все, наверное, понятно с точки зрения работы с функциями в процедурных языках. Здесь
[15:16.480 --> 15:24.720]  в данном случае функция, которая у нас выведет предложение hello world, ну предложение hello world
[15:24.720 --> 15:31.760]  она выведет, конечно, с репетом того, какой селек запрос написан в конце. То, о чем мы с вами
[15:31.760 --> 15:38.400]  говорили, да, все это в данном случае у нас есть. Create Replace Function в данном случае проверяет
[15:38.400 --> 15:51.440]  команда, если функция создана, она ее замещает, либо создает заново. А переменная P передается в
[15:51.440 --> 16:00.360]  функцию, переменная с значением, с типом данных текст, объявляется также внутри блока Declare,
[16:00.360 --> 16:09.600]  внутренняя переменная V тоже создача, с типом данных текст, и в блоке Begin End у нас происходит
[16:09.600 --> 16:19.360]  конкатонация двух текстовых фрагментов и, соответственно, представление конца восклицательного
[16:19.360 --> 16:29.720]  знака. С конечной строка будет hello world с колесательным знаком. Вот пример посложнее с циклом.
[16:29.720 --> 16:40.200]  В данном случае у нас внутри цикла будет выдаваться значение номер нашей итерации,
[16:40.200 --> 16:57.120]  по сути дела. Обратите внимание на цикл 4, как он написан, 1, 2.5 и опять же до заголовок цикла у
[16:57.120 --> 17:06.520]  нас перед ключевым словом loop идет. Еще более сложный пример в данном, ну во всяком случае
[17:06.520 --> 17:13.400]  громоздкий. В данном случае мы определили не просто числовую переменную, мы определили еще и
[17:13.400 --> 17:27.000]  массив числовой в блоке Declare и мы итерируем нашу функцию по этому массиву, начиная с наименьшего,
[17:27.000 --> 17:33.320]  заканчивая наибольшим числом массиве и тоже выводим значение каждого элемента полученного.
[17:33.320 --> 17:46.600]  Пример функции с ветвлением с операторами if else. В данном случае у нас функция выведет положительное
[17:46.600 --> 17:53.360]  число, ну ответ она выведет, что это положительное число, поскольку мы в select запросе передали число
[17:53.360 --> 18:02.720]  5 и функция с примером ветвления через оператор case выведет ответ отлично, потому что
[18:02.720 --> 18:11.400]  у нас переданный балл больше 90 и соответствует первому из обозначенных условий.
[18:11.400 --> 18:23.440]  Также пример процедуры, ну как мы с вами говорили процедура у нас встречается в первую очередь тем,
[18:23.440 --> 18:28.880]  что ничего не возвращает сама по себе, но в данном случае она вполне себе способна на побочный эффект,
[18:29.520 --> 18:38.440]  на изменение базы данных, ну как собственно говоря и функция теоретически, но здесь на что
[18:38.440 --> 18:45.160]  нужно обратить внимание. Вот у нас есть блок обработки исключения и в случае если у нас будут
[18:45.160 --> 18:54.000]  какие-то проблемы связанные с тем, что функция вставляет email в базу данных, почту какого-то
[18:54.000 --> 19:01.320]  пользователя вставляет, ну не create, а update user скорее так нужно было бы ее называть, но
[19:01.320 --> 19:22.800]  функция вставляет данные о адресе электронной почты пользователя и если у нас
[19:22.800 --> 19:34.040]  уже есть пользователь с данным email, то у нас соответственно не выполнится наша непростая
[19:34.040 --> 19:39.600]  функция, еще и транзакция откатится назад по команде rollback в блоке exception. Здесь такой
[19:39.600 --> 19:47.960]  немножко надуманный пример, потому что у нас по-хорошему надо было бы наверное update user
[19:47.960 --> 19:57.080]  email что-нибудь такое делать, получается урезанный, мы вставляем вроде бы уже в существующего
[19:57.080 --> 20:03.920]  пользователя запись его электронным почтом ящики, но попрошу не обращать внимания на
[20:03.920 --> 20:10.360]  какую-то существенную, на сущностную часть вопроса, на содержательную с точки зрения того,
[20:10.360 --> 20:16.360]  что функция делает, важно то как она делает в данном случае, в данном случае она создает
[20:16.360 --> 20:26.200]  процедуру, данные функция процедуры в данном случае процедуры не выдают итоговых никаких
[20:26.200 --> 20:32.760]  значений, опять же у нас здесь нет returns, ключевого слова, да никакого типа данных не обозначено,
[20:32.760 --> 20:39.640]  есть блок exception, соответственно напоминаю, что вызываться такая процедура будет по специальной
[20:39.640 --> 20:50.160]  команде call, call create user и ни в коем случае мы ее не сможем в запросе select использовать.
[20:50.160 --> 21:00.640]  Обязательно использовать коммит? Нет, не обязательно по большим учетам, то есть в принципе у нас
[21:00.640 --> 21:10.560]  окончание процедуры тоже получится автокоммита, тоже должно закончиться автокоммитом, ну здесь для
[21:10.560 --> 21:16.600]  больше такой что ли наглядности и под условие что возможно есть какие-то параллельные транзакции,
[21:16.600 --> 21:22.960]  давайте лучше мы здесь сделаем коммит в явном, явно сразу после добавления и на этом как бы все
[21:22.960 --> 21:30.960]  закончим, а дальше уже там вот raise notice при приятное дополнение, лагирование операции,
[21:30.960 --> 21:36.080]  как бы ни на что не влияющее, то есть не будем ждать пока система отработает, может у нас будет,
[21:36.080 --> 21:43.280]  не знаю, поток выходной заполнен и мы ждать выполнения raise notice будем больше, чем по сути
[21:43.280 --> 21:54.080]  дела проводить вставку данных в таблицу, поэтому коммит не обязателен, но желателен в случае если мы
[21:54.080 --> 22:02.480]  хотим явно обозначить точку завершения транзакции. Есть и негативные последствия использования
[22:02.480 --> 22:08.480]  функций процедур, но они такие, они не технологические, то есть дело не в изъянии технологий функций
[22:08.480 --> 22:17.680]  процедур как таковой, а дело в собственно тех кто функции процедуры пишет и их использует, то бишь
[22:17.680 --> 22:23.920]  у нас, ну во-первых, раздельное выполнение запросов, то есть вложенные запросы могут
[22:23.920 --> 22:32.920]  преобразовываться в операцию соединения, если мы используем наш стандартный SQL syntax, однако
[22:32.920 --> 22:40.920]  если мы размещаем наши под запросы какие-то структурированные запросы внутри функции, то
[22:40.920 --> 22:51.920]  здесь мы добавляем для оптимизатора такое вот, как бы белое поле, он не всегда может просчитать
[22:51.920 --> 22:58.720]  корректно, что и как происходит внутри наших функций процедур и вместо того, чтобы оптимизировать
[22:58.720 --> 23:05.320]  наш запрос так, как он бы его оптимизировал, если бы это был чистый SQL, он будет, ну вот, я извиняюсь,
[23:05.320 --> 23:14.400]  ступую идти по нашим инструкциям без каких-то исключений, ну как, если вы помните, у нас
[23:14.400 --> 23:22.880]  обозначен был порядок выполнения SQL запроса, когда об этом говорили, то есть селек запроса,
[23:22.880 --> 23:32.640]  в частности, мы когда говорили об этом, мы говорили, что у нас на уровне from и join идет
[23:32.640 --> 23:43.360]  сначала декартовое произведение, причем буквально получается почти всегда, ну с точки зрения
[23:43.360 --> 23:52.360]  описания, грубо говоря, да, идет декартовое произведение в отношении, если у нас несколько
[23:52.360 --> 23:56.840]  отношений в запросе, и только потом идет фильтрация, даже если мы используем, на самом деле, join,
[23:56.840 --> 24:05.680]  inner join, он какое-то условие, но на самом деле, конечно, никогда практически у нас не работает,
[24:05.680 --> 24:13.920]  не то что никогда, а в минимальном числе случаев работает декартовое произведение,
[24:13.920 --> 24:22.240]  оптимизатор максимально пытается всегда запросы сокращать для выполнения непосредственного,
[24:22.240 --> 24:28.200]  ну вот, а здесь бы, наоборот, грубо говоря, было бы всегда декартовое произведение всех наших
[24:28.200 --> 24:35.040]  join, потом выборка по условию, потом дополнительная выборка по условию, и так далее, и так далее,
[24:35.040 --> 24:45.840]  ну вот, такой, может быть, надуманный пример, но смысл в том, чтобы вы понимали, у нас оптимизатор
[24:45.840 --> 24:52.600]  внутри функции может не понимать, что происходит, для него это не всегда прозрачный код, даже если
[24:52.600 --> 24:59.920]  мы там, казалось бы, пишем обычный SQL. Попущенный эффект функции процедуры, ну, собственно говоря,
[24:59.920 --> 25:08.720]  то, о чем мы немножко вскользь упомянули только что на примере процедуры, как вы сами видели,
[25:08.720 --> 25:20.280]  у нас функции процедуры могут в принципе повлиять на содержимое базы данных, если мы допустили
[25:20.400 --> 25:26.800]  логические какие-то ошибки при формулировании наших функций процедуры, если мы что-то не
[25:26.800 --> 25:34.920]  предусмотрели в нашей схеме данных, то последствия использования функций процедур,
[25:34.920 --> 25:41.760]  последствия их работы могут быть неочевидными, могут нарушать, даже в том числе целостность
[25:41.760 --> 25:47.280]  данных, если она неоптимальным образом поддерживается, ну, опять же, это ошибки не
[25:47.280 --> 25:56.840]  технологические ошибки на уровне использования и пользователей, а недоступность оценок стоимости,
[25:56.840 --> 26:01.280]  ну, вот, собственно говоря, да, это по сути дела то же самое, что и связано, во всяком случае,
[26:01.280 --> 26:08.920]  связано с первым пунктом, оптимизатор не видит, не всегда может видеть, что происходит, не всегда,
[26:08.920 --> 26:13.480]  во всяком случае, может понимать, что происходит внутри вашей функции процедур, и, как бы,
[26:13.480 --> 26:20.840]  по умолчанию, ему проще, по большому счету, делать все последовательно, нежели оптимизировать.
[26:20.840 --> 26:35.400]  Триггеры, особый вид хранимых процедур, пользователь их не вызывает непосредственно
[26:35.400 --> 26:43.720]  на исполнение, их обусловлены действиями по модификации данных, insert, update, delete, truncate.
[26:43.720 --> 26:52.400]  Триггеры это, по сути дела, просто функция, но у них есть небольшие особенности в определении,
[26:52.400 --> 27:04.160]  и есть особенность по назначению триггера на конкретную таблицу или конкретное поле таблицы.
[27:04.160 --> 27:12.360]  Триггеры могут существенно дополнить или изменить семаничку стандартных операторов SQL,
[27:12.360 --> 27:21.340]  ну, в принципе, как и функции. И триггеры используются, в том числе, для поддержания
[27:21.340 --> 27:31.640]  целостности базы данных, то есть, помимо штатных средств стандартного SQL, ключей, ограничений,
[27:31.640 --> 27:42.280]  дефолтных значений, триггеры тоже являются таким средством, более продвинутым, более сложным,
[27:42.280 --> 27:50.720]  позволяющим указывать более сложную логику, тоже являются средством поддержания целостности данных.
[27:50.720 --> 27:55.680]  Ну, как бы, можно их рассматривать, скажем так, во всяком случае, они не обязательно являются,
[27:55.680 --> 28:05.960]  способом поддержания мы можем всё что угодно с ними делать, но, конечно, лучше так делать не стоит,
[28:05.960 --> 28:15.840]  лучше их в каких-то разумных пределах концептуальных для себя определить и использовать.
[28:15.840 --> 28:22.960]  Ну и вот как один из вариантов поддержания целостности. Для создания триггерной функции
[28:22.960 --> 28:29.400]  при определении хранимой процедуры нужно указать особый тип выходного значения.
[28:29.400 --> 28:40.360]  Returns trigger, как показано на слайде. Вот, собственно, в принципе, главное отличие функции обычного триггера.
[28:40.360 --> 28:48.280]  Помимо этого, собственно, триггер создается отдельным предложением Create, отдельный командный
[28:48.280 --> 28:59.680]  Create trigger и обязательно при этом указывается, во-первых, время его срабатывания, а во-вторых,
[28:59.680 --> 29:05.920]  события, на которые он срабатывает. Ну, конечно, да, имя таблицы. Ну, опять же, условно говоря,
[29:05.920 --> 29:14.360]  получается, как вы видите, у нас не все здесь элементы обязательны, но вот время события и
[29:14.360 --> 29:23.080]  имя таблицы, это вещи обязательные. Ну и, собственно говоря, необходимо задать, собственно, функцию,
[29:23.080 --> 29:31.400]  которая будет выполняться при срабатывании триггера. Событие, как мы с вами говорили, insert, update, delete, truncate.
[29:31.400 --> 29:48.800]  Обратите внимание на такой sub-bullet, sub-point. Существуют еще триггеры, которые не привязываются к действиям указанным,
[29:48.800 --> 30:06.600]  а привязываются к командам DDL, то есть create, alter, drop, вот такого рода. Но они работают, скажем так,
[30:06.600 --> 30:12.520]  несколько иначе и тоже, скажем так, у них несколько иной синтаксис, и мы их не будем рассматривать,
[30:12.520 --> 30:21.320]  и сейчас не в курсе, в принципе, это как бы немножко отдельная тема. Мы будем сосредоточены на триггерах,
[30:21.320 --> 30:33.400]  которые привязаны к data manipulation language и указанных командах. Триггерная функция должна вернуть либо null,
[30:33.400 --> 30:39.080]  либо запись или строку соответствующую структуре таблицы, для которой сработал триггер.
[30:39.080 --> 30:54.480]  Предложение for each row statement определяет, будет ли функция триггера срабатывать один раз для каждой
[30:54.480 --> 31:01.640]  строки, либо SQL-оператор. Если не указано ничего, то подразумевается, что for each statement будет
[31:01.640 --> 31:08.920]  работать триггерная функция, то есть для всего оператора. Для триггеров ограничений можно
[31:09.160 --> 31:20.200]  только указать команду for each. Условия работы. Время срабатывания before, after и instead of и,
[31:20.200 --> 31:27.000]  собственно говоря, события, и на что мы можем их назначать. Здесь что нужно обратить внимание,
[31:27.000 --> 31:35.080]  на так называемые сторонние таблицы. По сути дела, речь идет о каких-то внешних данных. Данных
[31:35.080 --> 31:43.560]  из внешних по отношению к базе данных таблиц. Может быть проще будет с точки зрения английского
[31:43.560 --> 31:52.720]  языка это foreign tables. То есть повторюсь, да, таблицы, находящиеся, данные, находящиеся за
[31:52.720 --> 32:02.840]  пределами нашей текущей базы, к которым мы обращаемся. Ну да, в общем-то из таблиц условия,
[32:02.840 --> 32:11.280]  когда какие триггеры работают, в принципе, наверное, понятно. Здесь что еще можно сказать,
[32:11.280 --> 32:19.280]  да, что у нас триггеры можно, помимо таблиц, вешать также и на представления и обуславливать
[32:19.280 --> 32:27.200]  работу представлений каким-то. Когда у нас, соответственно, изменяемые представления меняют
[32:27.200 --> 32:36.360]  данные в некоем отношении, можем таким образом триггерами менять явную логику, скажем так,
[32:36.360 --> 32:44.000]  добавляя какие-то условия. Триггеры подразумевают, что при их использовании создаются специальные
[32:44.000 --> 32:58.080]  переменные. Специальные переменные в триггерных функциях, ставные приведены на слайдах, они
[32:58.080 --> 33:09.280]  используются для обращения внутри-триггерной функции к объектам базы данных. Ну, new, old, новая строка,
[33:09.280 --> 33:17.280]  старая строка, tgName имя сработавшего триггера, tgName, tgWhen, когда, соответственно,
[33:17.280 --> 33:28.120]  level, role и statement в зависимости от определения триггера, op, операция, table, name, таблица,
[33:28.120 --> 33:44.080]  table, scheme, схема, название схемы. И еще из интересных, наверное, специальных переменных tgNarcs,
[33:44.080 --> 33:52.960]  число аргументов в команде create trigger, которые передаются в триггерную функцию. Есть еще переменные,
[33:52.960 --> 34:07.120]  некоторые, прошу прощения, некоторые переменные, там парочка, примерно, они остаются для
[34:07.120 --> 34:12.640]  поддержания обратной совместимости. Есть более специфические переменные, если обратитесь к
[34:12.640 --> 34:21.480]  документации, вы видите, но в принципе основные, перечисленные на слайде, new, old, name, when и так
[34:21.480 --> 34:33.200]  далее. Несколько примеров. Создание триггера checkUpdate, соответственно, до обновления в таблице
[34:33.200 --> 34:45.560]  счета для каждой записи, будет срабатывать функция, проверить обновление аккаунта.
[34:45.560 --> 34:55.480]  Здесь, в принципе, то же самое практически, да, но create or replace триггера, соответственно,
[34:55.480 --> 35:03.080]  будет заменен уже существующий триггер, если он существует. Обновляем баланс для таблицы
[35:03.080 --> 35:10.800]  аккаунта, для таблиц и счетов. И более сложный пример, это триггер, который при любом добавлении
[35:10.800 --> 35:15.200]  или изменении строки в таблице сохраняет в этой строке информацию о текущем пользователе,
[35:15.320 --> 35:25.280]  и отметку времени. Кроме того, также он проверяет указания имени сотрудника и зарплаты с положительным
[35:25.280 --> 35:32.760]  числом. Ну, то есть, по сути дела, здесь совмещение, да, отработки не просто какого-то более сложного
[35:32.760 --> 35:39.680]  триггера, но и версионирование таблиц, о котором мы с вами говорили на позапрошлой лекции.
[35:39.680 --> 35:51.040]  Создаем таблицу с сотрудниками, да, вот имя, заработная плата,
[35:51.040 --> 36:03.720]  прошлая дата и прошлый пользователь. И создаем пункт наш триггерный,
[36:03.720 --> 36:13.400]  ну и, собственно, что она делает. Во-первых, проверяет, указано ли имя сотрудника и зарплата.
[36:13.400 --> 36:22.480]  Обратите внимание, у нас здесь идет new, как вы только что увидели, это обращение к временной
[36:22.480 --> 36:27.720]  переменной, ну не к временной, а автоматически созданной переменной при использовании триггера,
[36:27.720 --> 36:35.040]  то есть мы и обращаемся к новой строке. Если в новой строке имя сотрудника не заполнено,
[36:35.040 --> 36:43.440]  тогда выдаются исключения, что мы не можем, что имя сотрудника не может быть пустым, нулевым.
[36:43.440 --> 37:00.040]  Проверяется дальше также значение зарплаты в новой строке и тоже выдаются исключения в случае
[37:00.040 --> 37:12.680]  отсутствия информации. Также указывается, что проверяется заработная плата на негативное
[37:12.680 --> 37:22.960]  значение, по сути, не имеющее какого-то смысла, и также выдаются исключения. И, наконец, у нас в
[37:22.960 --> 37:34.320]  нашу версионную часть таблицы, даже версионную часть записи, ту часть, которая отвечает за
[37:34.320 --> 37:48.960]  прошлое значение, заносится данные о том, какой пользователь вносит значение и текущее
[37:48.960 --> 37:55.640]  время, собственно говоря. Ну и заканчивается тем, что триггер функция возвращает запись new и,
[37:55.640 --> 38:08.480]  собственно говоря, заканчивается само тело. Обратите внимание, у нас здесь между знаками доллара
[38:08.480 --> 38:20.360]  есть дополнительная метка amp-stamp, ну, по сути дела это тегирование, это метка вот этого вот литерала
[38:20.360 --> 38:30.400]  заключенного в двойные доллары. Ну, она в данном случае не является принципиальной, но принцип
[38:30.400 --> 38:38.320]  синдексис допускает уточнение вот таких вот литералов двойных, заключенных в знаке двойного
[38:38.320 --> 38:46.040]  доллара и обращение к такого рода информации, к такого рода меткам. И, собственно, мы создаем
[38:46.040 --> 38:54.560]  теперь триггер amp-stamp, и мы назначаем время его использования до того, как вставляем или изменяем
[38:54.560 --> 39:09.320]  данные в таблице amp, и для каждой записи мы обязываем триггер выполнять функцию amp-stamp,
[39:09.320 --> 39:12.080]  описанную вот радио.
