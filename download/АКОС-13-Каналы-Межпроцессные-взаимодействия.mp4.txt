[00:00.000 --> 00:16.000]  Так, ну немного организационных вопросов сначала. Семестер у вас будет с тем же самым правом,
[00:16.000 --> 00:21.240]  оценки будут по тем же самым правилам, что и в прошлом семестре. То есть у вас будет два
[00:21.240 --> 00:31.040]  модуля. Это полусемистровый модуль по межпроцессному взаимодействию. Затем еще модуль по различным
[00:31.040 --> 00:38.360]  дополнительным фичам в современных и уникальных системах. Задачи и контрольные все тоже самое. То
[00:38.360 --> 00:44.440]  есть за каждый модуль ставится отдельная оценка, а итоговая оценка в семестре это просто среднее
[00:44.440 --> 00:54.920]  арифметическое. Можно вопрос задать? Да. По поводу контрольных. Я вот написал уже две контрольные,
[00:54.920 --> 00:59.040]  я так и не понял, как некоторые задачи решать. И на семинарах это не обсуждается, и на лекциях тоже.
[00:59.040 --> 01:09.080]  Вообще семинаристы должны были разбирать уже после контрольных разбор задач. Контрольные
[01:09.080 --> 01:16.760]  вообще больше по теоретическому материалу, а не по семинарскому. Если вас семинаристы это не
[01:16.760 --> 01:24.080]  проводили, ну можем тогда после контрольных на лекциях разбирать. Пожелание принимается.
[01:24.080 --> 01:42.480]  Тема сегодняшнего занятия это межпроцессное взаимодействие. Тут на самом деле несколько тем.
[01:42.480 --> 01:52.720]  И начнем мы с самого простого и очевидного способа межпроцессного взаимодействия. Это
[01:52.720 --> 02:03.160]  использование канала. Сначала о том, зачем нужно межпроцессное взаимодействие. Каждый
[02:03.160 --> 02:09.640]  процесс в любой UNIX системе это что-то самодостаточное, изолированное. То есть у каждого
[02:09.640 --> 02:18.120]  процесса есть свое виртуальное адресное пространство. Память процесса между собой не разделяют
[02:18.120 --> 02:27.320]  по умолчанию. Процессы могут взаимодействовать только с ядром для того, чтобы общаться как-то с
[02:27.320 --> 02:32.600]  внешним миром. Но достаточно часто возникает ситуация, что процессы все-таки должны между
[02:32.600 --> 02:40.160]  собой общаться. И это нельзя сделать не имея единого адресного пространства. То есть если вы
[02:40.160 --> 02:46.480]  хотите, например, сделать взаимодействие двух разных функций в любой программе на любом высоковаренном
[02:46.480 --> 02:50.600]  языке программирования, то вы можете использовать либо глобальные переменные, либо передачу
[02:50.600 --> 02:56.960]  документов. Когда у вас запущены несколько процессов, то это уже не получится. И здесь уже
[02:56.960 --> 03:02.920]  приходится использовать некоторые обходные пути, как процессы могут взаимодействовать друг с
[03:02.920 --> 03:08.600]  другом. Каждый процесс может взаимодействовать с ядром, а соответственно на ядро еще возлагаются
[03:08.600 --> 03:18.360]  задачи по организации взаимодействия между разными процессами. Какие есть способы с процессом
[03:18.360 --> 03:25.240]  взаимодействовать между собой? Самый простой, очевидный способ для тех, кто не знает о том,
[03:25.240 --> 03:30.280]  как устроены операционные системы, кто не изучал course и не изучал курс по операционным
[03:30.280 --> 03:38.400]  системам, это простое наивное решение создать какой-то файл, открыть этот файл в разных процессах и
[03:38.400 --> 03:47.880]  писать туда какие-то данные. Чем такой способ плох? Плох тем, что вы не знаете в какой момент у вас
[03:47.880 --> 03:54.520]  произошли какие-то изменения в файле. Тут возникает целый ряд проблем, начиная с синхронизации до
[03:54.520 --> 04:00.920]  уведомления других процессов о том, что данные действительно появились. Поэтому такой способ он
[04:00.920 --> 04:08.360]  конечно иногда используется, но очень плохой, очень неправильный. Кроме файлов есть еще разные
[04:08.360 --> 04:16.320]  механизмы, например сигналы. Что такое сигнал? Это некоторое уведомление от одного процесса к
[04:16.320 --> 04:24.640]  другому, либо уведомление от ядра к какому-то процессу, например, что выполнена какая-то
[04:24.640 --> 04:31.360]  недопустимая операция. Сигналы в принципе тоже могут быть использованы как способ межпроцессного
[04:31.360 --> 04:38.960]  взаимодействия, но у них есть очень серьезное ограничение. Во-первых, у большинства UNIX сигналов,
[04:38.960 --> 04:43.440]  которые поддерживаются всем UNIX-подобными системами, есть ограничение связано с тем,
[04:43.440 --> 04:50.280]  что отправка сигнала просто проставляет флаг наличия этого сигнала у процесса и, соответственно,
[04:50.280 --> 04:57.600]  если одновременно несколько других процессов отправили сигнал, то процесс прочитает только факт
[04:57.600 --> 05:03.920]  о том, что сигнал был, но не их количество. Кроме того, кроме номера сигнала, вы фактически
[05:03.920 --> 05:08.800]  никакую информацию передать не можете. В некоторых современных системах, например,
[05:08.800 --> 05:18.000]  Linux и FreeBSD, но есть еще дополнительный API для работы сигналами. Это так называемые сигналы
[05:18.000 --> 05:27.340]  регального времени, которые позволяют отправлять какие-то дополнительные данные очень небольшого
[05:27.340 --> 05:34.640]  размера, не превышающего размер машинного слота, 64 бита, и при этом, в отличие от обычных сигналов,
[05:34.640 --> 05:40.840]  их количество не теряется. Все, что связано с сигналами, это у нас будет на одной из последующих
[05:40.840 --> 05:49.280]  лекций, какие у нас бывают еще другие способы взаимодействия. Самый простой, с точки зрения
[05:49.280 --> 05:58.040]  использования и достаточно удобный способ, это последовательная передача данных. Для этого
[05:58.040 --> 06:05.200]  создаются некоторые файловые дискрипторы, в которые можно писать и из которых можно читать.
[06:05.200 --> 06:09.800]  Соответственно, если вы хотите передавать данные от одного процесса к другому, то вам нужно создать
[06:09.800 --> 06:18.400]  этот канал, для того чтобы этот канал, естественно, должен быть доступен обоим процессом. Каналы бывают
[06:18.400 --> 06:25.600]  двух видов, это неименованные и именованные. Именованные каналы еще называют FIFA. Разница между
[06:25.600 --> 06:34.800]  ними в том, что неименованные каналы должны быть созданы, например, родительскими процессами,
[06:34.800 --> 06:40.920]  дальше наследоваться дочерьми, а именованные можно открыть по им. У каналов есть некоторые
[06:40.920 --> 06:46.840]  ограничения, несмотря на их простоту. Например, взаимодействие может между собой только два
[06:46.840 --> 06:53.200]  процесса. Если вам нужно организовать взаимодействие между собой нескольких процессов, то требуется уже
[06:53.200 --> 06:58.720]  использовать более сложный механизм, который называется SOAP. Кроме последовательного доступа,
[06:58.720 --> 07:07.960]  есть более быстрый способ это использование какой-то общей памяти, которая доступна сразу
[07:07.960 --> 07:16.240]  нескольким процессам. Как это сделать? Вы уже это изучали в прошлом семестре на примере
[07:16.240 --> 07:21.520]  стеновызова MAP. Там есть такой флаг MAP-shared, который в противоположность MAP-private позволяет
[07:21.520 --> 07:29.800]  создать какую-то область памяти, доступную сразу нескольким процессам. Есть еще несколько
[07:29.800 --> 07:38.160]  механизмов, которые работают поверх MAP для того, чтобы можно было организовать взаимодействие
[07:38.160 --> 07:43.640]  не родственных процессов. Этот способ взаимодействия между процессами является самым быстрым,
[07:43.640 --> 07:53.560]  но при этом требует более аккуратной реализации, например, по части синхронизации каких-то общих данных.
[07:53.560 --> 08:03.360]  Тема сегодняшней лекции – это именно каналы, то есть механизм для последовательного обращения.
[08:03.360 --> 08:11.440]  Самый простой способ создать канал – это запустить некоторую команду в обычном
[08:11.920 --> 08:18.880]  интерпетаторе, точнее запустить две команды. Между ними можно поставить вертикальную черту.
[08:18.880 --> 08:25.480]  Вот что эта вертикальная черта означает? Это означает, что нужно взять вывод первой команды
[08:25.480 --> 08:31.840]  и вместо того, чтобы выводить его на экран, нужно просто перенаправить его на стандартный поток
[08:31.840 --> 08:37.760]  ввода следующей команды. На самом деле здесь процессов может быть не два, а какое-то произвольное
[08:37.760 --> 08:43.440]  количество. Можно выстраивать целый конвейер из нескольких каналов и нескольких команд.
[08:43.440 --> 08:52.000]  И кто у нас создает этот самый канал? Создает его сам Shell. Когда команда интерпетатора разбирает
[08:52.000 --> 08:58.000]  такую строку, он находит сначала все вертикальные черты, дальше все, что находится между ними,
[08:58.000 --> 09:04.000]  запускаются как отдельные процессы, которые работают параллельно друг к другу и используют
[09:04.000 --> 09:12.640]  канал для передачи данных. Что такое канал и как его создать? Что делает команда интерпетатора
[09:12.640 --> 09:19.760]  перед тем, как создать некоторые процессы? Он вызывает системный вызов Pipe, который существует
[09:19.760 --> 09:24.960]  во всех UNIX и подобных операционных системах. Это очень старый механизм, поэтому он есть везде.
[09:24.960 --> 09:35.880]  В качестве аргумента Pipe принимает массив, то есть указательное начало из двух целых чисел.
[09:35.880 --> 09:45.040]  Это является выходным параметром, то есть туда записывают в этом массив два числа. 0 и 1,
[09:45.040 --> 09:51.680]  соответственно 0 и первые аргументы, это два файла дескриптора, поэтому один из них доступен только
[09:51.680 --> 09:59.960]  для чтения, второй доступен только для записи. Дороже, чтобы не запутаться в том,
[09:59.960 --> 10:04.520]  какой из элементов массива доступен для чтения, какой для записи, можно просто
[10:04.520 --> 10:11.800]  представлять собой канал как некоторую трубу, в которой данные протекают справа налево. Тут
[10:11.800 --> 10:17.280]  просто есть некоторая аналогия, что у нас есть стандартный поток ввода, у которого номер 0,
[10:17.280 --> 10:24.320]  и стандартный поток вывода, у которого номер 1. Соответственно, нулевой файл для
[10:24.320 --> 10:28.480]  скриптора доступен не только для чтения, первый доступен только для записи.
[10:28.480 --> 10:37.840]  Как можно использовать каналы? Если у вас есть некоторая программа,
[10:37.840 --> 10:43.920]  которая вовсе не обязательно взаимодействует с каким-то другим процессом, то каналы можно
[10:43.920 --> 10:52.200]  использовать просто как механизм для передачи данных из одной части программы в другую. Если
[10:52.200 --> 10:59.120]  кто-то из вас знает язык программирования Go, то может знать, что в языке программирования есть
[10:59.120 --> 11:07.840]  такой тип данных как канал, который позволяет передавать данные из одной горутины в другую
[11:07.840 --> 11:14.080]  горутину. Здесь, естественно, нужно аккуратно следить за тем, чтобы у вас не было блокировок,
[11:14.080 --> 11:21.120]  то есть ситуации, когда вы записываете что-то, не записываете канал, но пытаетесь при этом
[11:21.120 --> 11:28.600]  прочитать, хотя данных нет, программа вас просто блокирует. Где можно использовать каналы без
[11:28.600 --> 11:36.600]  создания новых процессов? Например, если у вас программа многопоточная, то отдельные потоки
[11:36.760 --> 11:45.400]  могут точно так же писать канал, как и обычный процесс. Давайте на этом простом примере рассмотрим,
[11:45.400 --> 12:02.720]  как можно создать канал и его использовать. Для создания канала мы используем системный вызов
[12:02.720 --> 12:09.640]  pipe, которому нужно передать указатель на два последние лежащих целых числа. Обычно для этого
[12:09.640 --> 12:19.640]  используют массив, созданный на стэкип, просто по той причине, что 2 мта это очень мало и не имеет
[12:19.640 --> 12:27.280]  никакого смысла выделять память в куче. После того, как канал создан, вы можете что-то писать в
[12:27.280 --> 12:35.200]  канал и что-то читать. Используя самые обычные системные вызовы read и write, поскольку каждый
[12:35.200 --> 12:44.160]  элемент канала у нас является отдельным пайлом дескриптора. Запись возможна в элемент массива
[12:44.160 --> 12:52.520]  с номером 1, а чтение у нас доступно в элемент массива с номером 0. Запустим эту программу,
[12:52.520 --> 13:02.680]  убедимся, что она действительно работает. Вот мы прочитали какие-то данные из канала,
[13:02.680 --> 13:08.520]  как только данные закончились, то система вызов read просто возвращает значение 0,
[13:08.520 --> 13:18.640]  и по этому признаку можно, например, прервать чтение. И в чем бывает проблема при использовании
[13:18.640 --> 13:26.240]  каналов в рамках одного процесса. Давайте просто возьмем и поменяем 2 строчки местами,
[13:26.240 --> 13:35.200]  то есть сначала мы попытаемся прочитать что-то из канала, и только после этого будем канал записывать.
[13:48.640 --> 13:59.880]  Так, запускаем эту программу и получаем мы абсолютно ничего. Прервать процесс можем мы с помощью
[13:59.880 --> 14:07.280]  CTRL-C. Почему у нас ничего не происходит? Потому что сначала мы пытаемся что-то из канала прочитать
[14:07.280 --> 14:16.000]  до того, как что-то записали, но естественно висим на том, что read у нас блокирует текущий процесс,
[14:16.000 --> 14:22.040]  то есть перевольт его в состояние sleep до тех пор, пока не появятся какие-то данные в каналах,
[14:22.040 --> 14:28.480]  либо канал не будет закрыт. Поскольку запись у нас последовательно идет уже после попытки
[14:28.480 --> 14:34.320]  чтения, то данные у нас в каналах никогда не появляются, и мы получаем ситуацию название deadlock
[14:34.320 --> 14:45.000]  или мертвая блокировка, когда программа не может ничего выполнить. Поэтому каналы в этом плане
[14:45.000 --> 14:53.320]  более смысленно использовать, когда у вас есть несколько процессов. Как это можно сделать? Вы
[14:53.320 --> 14:59.760]  создаете канал, то есть создаете пару файлов и дискрипторов с помощью стеной из API, и когда
[14:59.760 --> 15:07.280]  вы создаете новый процесс, то новый процесс начальник у вас наследует часть атрибутов под
[15:07.280 --> 15:13.880]  разделительского процесса. Кто помнит, какие атрибуты у нас наследуются при эфорке,
[15:13.880 --> 15:26.280]  помимо файлов и дискрипторов? Ограничения тоже ведь? Да, это разные ограничения, лимиты,
[15:26.280 --> 15:30.640]  естественно файловые дискрипторы, которые у вас открыты, причем с теми же самыми номерами,
[15:30.640 --> 15:39.120]  и еще, если у процесса есть разделяемые страницы памяти, то дочерний процесс их тоже наследует.
[15:39.120 --> 15:46.160]  Там всякие мелочи, например, user ID, group ID и так далее. То есть используя тот факт, что файловые
[15:46.160 --> 15:52.960]  дискрипторы у нас всегда наследуются дочерним процессом, канал можно использовать как механизм
[15:52.960 --> 16:00.320]  межпроцессного взаимодействия. И здесь уже мы можем создать какой-то дочерний процесс,
[16:00.320 --> 16:07.120]  который либо читает, либо что-то записывает. Поскольку процессы, которые выполняют запись и
[16:07.120 --> 16:14.960]  чтение, у нас выполняются параллельно, то здесь уже уменьшается вероятность дедлока, но все-таки
[16:14.960 --> 16:24.640]  она не нулевая. И за этим нужно аккуратно следить. Давайте опять же рассмотрим это на каком-нибудь примере.
[16:24.640 --> 16:40.320]  Создадим все то же самое. У нас есть чтение из канала, запись из канала. Канал предварительно
[16:40.320 --> 16:51.720]  создается, но мы функцию для записи в канал запускаем в качестве дочернего процесса. Да,
[16:51.720 --> 16:57.840]  этот код у меня, сразу предупреждаю, немножко не тот идеал, который я обычно требую на семинарах,
[16:57.840 --> 17:04.880]  поскольку здесь нет проверки ошибок. Это связано с тем, чтобы большее тексты
[17:04.880 --> 17:10.880]  укладывалось на то. Итак, запускаем дочерний процесс. В дочернем процессе мы выполняем
[17:10.880 --> 17:16.280]  запись, в родительском процессе мы выполняем чтение. Что у нас будет происходить?
[17:16.280 --> 17:41.720]  Компилируем программу. Запускаем. Честно получаем вывод, который мы записали из дочернего
[17:41.720 --> 17:50.120]  процесса. И где же командная строка? Что-то у нас продолжает висеть. Ну ладно, мы можем прибить
[17:50.120 --> 17:58.280]  нашу программу с помощью CTRL-C. Давайте внимательно посмотрим, что у нас могло пойти не так. Мы
[17:58.280 --> 18:06.720]  запускаем дочерний процесс и в дочернем процессе мы честно делаем запись каких-то данных, закрываем
[18:06.720 --> 18:14.600]  канал, завершаем работу процесса. Казалось бы, все хорошо, все замечательно. Мы можем наблюдать,
[18:14.600 --> 18:21.520]  что родительский процесс, который вызывает ритм, честно прочитал наши данные, вывел,
[18:21.520 --> 18:30.800]  что он прочитал столько-то байк из пайпа, все это вывел. И программа у нас не завершается.
[18:30.800 --> 18:39.680]  Почему это может происходить? Здесь требуется соблюсти некоторые правила. Что у нас делает
[18:39.680 --> 18:46.200]  системный вызов RIT? Он читает не более чем то количество данных, которые вы просите,
[18:46.200 --> 18:55.640]  и возвращает количество реальных прочитаний с байка. Что RIT обычно возвращает? Это возможные
[18:55.640 --> 19:02.640]  значения минус один, если возникла какая-то ошибка, если данные закончились, значение больше нуля,
[19:02.640 --> 19:09.640]  если RIT что-то прочитал. То есть мы наблюдаем ситуацию, что RIT у нас ничего не возвращает,
[19:09.640 --> 19:15.560]  просто ждет. За чего это происходит? Потому что он пытается прочитать данные и не знает о том,
[19:15.560 --> 19:22.720]  что наш дочерний процесс завершился и канал закрыт. Но в программе у нас процесс завершился,
[19:22.720 --> 19:31.520]  он честно завершил свою работу, вызвал Exit 0, казалось бы, что мешает нашему RIT выполнять
[19:31.520 --> 19:41.600]  дальше. Мешает RIT продолжить выполнение программы дальше то, что у нас канал на самом деле не
[19:41.600 --> 19:48.360]  совсем закрыт. Давайте проследим за жизненным циклом нашего канала. Вот мы создали какой-то
[19:48.360 --> 19:58.040]  канал. Здесь у нас в Channel появились два каких-то числа. Обычно назначаются в качестве номеров
[19:58.040 --> 20:04.920]  самые минимальные не использованные номера для файлов дескриптора. То есть это значение 3 и 4.
[20:04.920 --> 20:16.800]  Затем мы вызываем систему Use a fork. Что у нас тут происходит? У нас существует две пары файлов
[20:16.800 --> 20:25.320]  дескрипторов с номерами 3 и 4 при листском процессе и плюс пара файлов дескрипторов с
[20:25.320 --> 20:36.120]  тем же самыми номерами с дочерним. Затем запускается дочерний процесс, что-то делает и после того,
[20:36.120 --> 20:44.880]  как дочерний процесс у нас завершился, он закрывает все файлы дескрипторы и все. Мы про это забываем.
[20:44.880 --> 20:53.640]  У нас остаются два открытых файлов дескриптора в родительском процессе с номером 3 и 4.
[20:53.640 --> 21:02.200]  Соответственно, процесс пытается прочесть данные из канала, который пока еще не закрыт,
[21:02.200 --> 21:09.360]  потому что с ним связан еще один файл дескриптор с номером 4 и тем самым канал не считается закрытым.
[21:09.360 --> 21:17.920]  Эту ситуацию нужно обязательно проверять, когда вы используете каналы. Мы совместно
[21:17.920 --> 21:24.360]  сценизуем форк. Не забывайте о том, что у вас могут создаваться лишние файлы дескрипторы,
[21:24.360 --> 21:30.040]  которые ссылаются на один и тот же канал, и это может прийти к ситуации deadlock. Как это
[21:30.040 --> 21:35.920]  можно избежать? Просто нужно по необходимости закрывать все, что вам становится не нужно.
[21:35.920 --> 21:42.960]  Итак, вот у нас есть родительский процесс. В родительском процессе, очевидно, не нужен
[21:42.960 --> 21:52.720]  файл дескриптор, связанный с записывающей стороной нашего канала, поэтому мы должны эту часть закрыть.
[21:52.720 --> 22:02.800]  После того, как мы закрываем эту сторону канала, все хорошо, все замечательно. После того,
[22:02.800 --> 22:14.560]  как додчатный процесс завершился, он закрывает свою часть канала и выполнение у нас, честно,
[22:14.560 --> 22:19.920]  завершается, поскольку ритм возвращается значением. На самом деле, здесь у нас есть
[22:19.920 --> 22:25.280]  еще какие-то лишние файлы дескрипторы. Сейчас они нам особо не мешают с точки зрения deadlock,
[22:25.280 --> 22:31.920]  но они все-таки потребляют ценный ресурс под названием количество используемых файлов
[22:31.920 --> 22:40.280]  дескрипторов. Этот ресурс тоже нужно экономить, поэтому по-хорошему нужно еще закрывать, например,
[22:40.280 --> 22:50.960]  в додчатном процессе неиспользованный файл дескриптор, канал для чтения. С точки зрения
[22:50.960 --> 22:58.240]  поведения нашей программы это ни на что не влияет, но может повлиять, когда у вас количество
[22:58.240 --> 23:09.980]  файлов дескрипторов является граничным. Так, ну и такие у нас есть правила, связанные с
[23:09.980 --> 23:18.440]  записью в канал. В канал мы можем записывать в том случае, если существует хотя бы одна читающая
[23:18.440 --> 23:26.040]  сторона. То есть на самом деле читателей у вас тоже может быть несколько. Это могут быть разные
[23:26.040 --> 23:32.560]  процессы, например, которые читают из канала. Если у вас читает из канала несколько процессов,
[23:32.560 --> 23:40.480]  то кто из них что прочитает, считается не поделенным. Но если у вас не существует ни одного процесса,
[23:40.480 --> 23:47.640]  который может прочитать из канала, то есть вы предварительно закрыли все файлы дескрипторы,
[23:47.640 --> 23:56.680]  связанные с читающей стороны канала, то эта операция запрещена и тот процесс, который попытается
[23:56.680 --> 24:07.920]  записать что-то в канал, который закрыт, получаем ошибку в виде сигнала sickpipe. Если у вас процесс
[24:07.920 --> 24:13.400]  выполняется как хранительский дискоманда и оболочки bash, то обычно bash подает ошибку
[24:13.400 --> 24:21.760]  по названию broken pipe. Как это можно наблюдать? Давайте опять же проведем небольшой эксперимент.
[24:21.760 --> 24:37.720]  Программа, которая только записывает в канал, но не читает. Здесь мы в дочернем процессе пытаемся
[24:37.720 --> 24:44.200]  что-то записать в канал. Аргильский процесс у нас вместо того, чтобы читать, просто берет и
[24:44.200 --> 24:51.240]  сразу же закрывает противоположную сторону канала. Сам дочерний процесс тоже он закрывает,
[24:51.240 --> 25:00.640]  но хотя бы по той причине, что ему этот файл дескриптора не нужен. И что у нас происходит при
[25:00.640 --> 25:13.760]  попытке записать что-то в канал. При попытке записать что-то в канал наша программа сейчас не
[25:13.760 --> 25:29.960]  грохнется, потому что эту попытку выполняет наш дочерний процесс. Аргильский процесс у нас честно
[25:29.960 --> 25:37.320]  отработал, а вот его дочерний процесс у нас грохнулся, и мы эту информацию можем получить через
[25:37.320 --> 25:46.560]  exit status дождавшись код возврата нашего дочернего процесса. И можно наблюдать, что процесс не был
[25:46.560 --> 25:54.640]  завершен корректным образом, а был прибит сигналом с номером 13, которому соответствует сигнал SIGPY.
[25:54.640 --> 26:02.160]  Если у вас такая ситуация возникла, например, из родительского процесса, то есть мы после
[26:02.160 --> 26:14.160]  закрытия канала просто напишем что-нибудь, записать в канал и какое-нибудь слово,
[26:14.160 --> 26:33.680]  то можем наблюдать диагностику, хотя нет, здесь не bash, а ZSH, он диагностику не отработал.
[26:33.680 --> 26:45.400]  А до этого случаи чем отличался? Что-то я не понимаю. Здесь дочерний процесс у нас грохнулся,
[26:45.400 --> 26:53.600]  соответственно у нас никакого вывода в текстовом виде нет, но мы через этот статус узнали о том,
[26:53.600 --> 27:00.880]  что процесс не дошел до строчки по названию exit 0, если бы он дошел до строчки exit 0,
[27:00.880 --> 27:07.960]  мы бы получили код возврата вот здесь. Вместо этого мы получаем, что процесс был прибит каким-то
[27:07.960 --> 27:16.840]  дочерным сигналом, то есть он не был корректно завершен, получил ошибку broken pipe. Здесь мы
[27:16.840 --> 27:33.440]  завершились с кодом 0, видимо потому что код 0 закрыт, либо он не отработал, здесь видимо просто
[27:33.440 --> 27:39.000]  у вас ошибка не всплыла в командам интерпретаторов ZSH, то есть это на самом деле ошибка,
[27:39.000 --> 27:45.000]  которых нужно избегать. Когда вы можете натыкаться на эти ошибки? На самом деле вы
[27:45.000 --> 27:54.360]  можете когда-нибудь косвенно или не явно все-таки делать запись, если не в канал,
[27:54.360 --> 28:04.720]  то хотя бы в socket. Например, если вы как-то взаимодействуете с каким-то удаленным сервером,
[28:04.720 --> 28:12.320]  то для socket действует те же самые правила, что и для каналов и запись в socket, который был закрыт
[28:12.320 --> 28:22.200]  противоположной стороной. Является ошибкой, которая также приводит к появлению сигнала SIGPipe.
[28:22.200 --> 28:32.560]  Если вы являетесь производителем рабочего окружения рабочего стола под Linux, то активным
[28:32.560 --> 28:38.560]  пользователем иногда встречали такие баги в программах, когда у вас что-то грохается с
[28:38.560 --> 28:46.680]  ошибкой broken pipe. Обычно это ситуация, когда не обрабатывается эта ошибка, вы пытаетесь записать
[28:46.680 --> 28:52.240]  в какой-то сетевой socket, который был закрыт по причине того, что интервейк отключился, сервер упал,
[28:52.240 --> 28:59.000]  программа может грохнуться, но на самом деле такие ошибки можно перехватывать,
[28:59.000 --> 29:09.760]  про это будет в лекции, связанной с сигналом. Что у нас еще нужно знать, когда вы пытаетесь записать
[29:09.760 --> 29:17.520]  что-то в канал? Нужно знать о том, что размер канала у нас ограничен, то есть каждый канал это
[29:17.520 --> 29:24.760]  некоторый буфер, куда выполняется запись. По стандарту POSIX у вас гарантируется, что размер
[29:24.760 --> 29:33.960]  этой трубы не менее чем 512 байт. 512 байт на самом деле достаточно мало и в старых реализациях Linux
[29:33.960 --> 29:40.240]  этот размер был 4 килобайта, в современных реализациях всех операционных систем его
[29:40.240 --> 29:48.760]  размер 64 килобайта. Соответственно, если вас никто не читает из канала, либо делает это медленно,
[29:48.760 --> 29:55.560]  вы можете смело выполнять запись, но до тех пор пока не заполнится буфер,
[29:55.560 --> 30:01.960]  связанный с каналом. После того, как вы этот буфер заполните, то у вас
[30:01.960 --> 30:22.400]  будет заблокировано. Вот простой пример. Запускаем некоторую программу, которая не
[30:22.400 --> 30:32.040]  порождает процессы, не создает новые потоки, просто записывает много данных в какой-то канал.
[30:32.040 --> 30:42.000]  И в случае успешного записи подает информацию о том, сколько байт удалось записать. Запускаем
[30:42.000 --> 30:53.320]  эту программу. Вот выполняем запись кусочками по 8 байт. Запись пока еще идет успешно. Обратите
[30:53.320 --> 31:00.880]  внимание, что я здесь нигде не читаю данных, только выполняю запись. Все, в какой-то момент у нас буфер
[31:00.880 --> 31:11.480]  заполнился. Мы успешно записали 65 506 байт или 64 килобайта данных. После этого процесс переходит
[31:11.480 --> 31:19.680]  состояние slip на 16 строчке при попытке записи. Сетевный вызов write просто ждет, пока кто-нибудь
[31:19.680 --> 31:27.120]  не прочитает из трубы и больше ничего записывать уже не может. Но поскольку у нас программа
[31:27.120 --> 31:34.000]  однопоточная, нет дочерних процессов, если никто не читает из канала, то единственный способ
[31:34.000 --> 31:44.280]  поставить программу, это ее прийти. На самом деле, поведение системного вызова read и поведение
[31:44.280 --> 31:51.880]  системного вызова write не обязательно может быть блокирующим. При открытии файлов, если вы внимательно
[31:51.880 --> 31:59.600]  смотрели на системный вызов open, там есть такой флаг под названием onOnBlock, который позволяет
[31:59.600 --> 32:06.320]  открыть какой-то файл в неблокирующем режиме. Что означает неблокирующий режим? Это означает,
[32:06.320 --> 32:14.080]  что вместо того, чтобы перевести процесс в состояние slip, когда чтение либо запись невозможны,
[32:14.080 --> 32:19.920]  у вас системные вызовы просто завершаются немедленно и возвращают значение в минус 1,
[32:19.920 --> 32:27.080]  как будто возникла ошибка. Но на самом деле ошибкой это не является. То есть переменной
[32:27.680 --> 32:34.880]  прописано специальное значение eAgain, которое означает, что у вас в данных новых нет для
[32:34.880 --> 32:41.880]  чтения, либо закончилось место в буфере, и поэтому запись невозможна, но при этом вы можете выполнять
[32:41.880 --> 32:50.840]  какие-то еще действия и, например, попытаться сделать запись в следующий раз. Все это хорошо работает,
[32:50.840 --> 32:57.760]  то есть вы можете открыть файлы с явным указанием флага onBlock, но когда вы создаете какой-то файловый
[32:57.760 --> 33:04.720]  дискриптор, например, с использованием системного вызова pipe, либо когда вы создаете файлы дискриптора
[33:04.720 --> 33:15.240]  по socket, то здесь уже указать флаг явным образом не получится, и необходимо использовать дополнительно
[33:15.240 --> 33:26.240]  некоторый системный вызов, который называется FileControl, который позволяет манипулировать
[33:26.240 --> 33:33.000]  атрибутами файловых дискрипторов. На самом деле здесь много всяких штук для модификации,
[33:33.000 --> 33:44.200]  но в данном случае нам нужно просто поменять какие-то атрибуты, связанные с открытием нашего
[33:44.200 --> 33:51.000]  файлового дискриптора, то есть сначала получить существующие, добавить флаг onBlock и вызвать
[33:51.000 --> 34:11.280]  команду setFlags. Давайте посмотрим на каком-то конкретном примере. Вот та же самая программа,
[34:11.280 --> 34:21.840]  которая создает канал, ничего из него не читает и записывает много раз значение по 8 байлов,
[34:21.840 --> 34:28.320]  до сих пор пока не будет заполнен буфер. Но предварительно выполним некоторую настройку.
[34:28.320 --> 34:37.440]  Мы получаем атрибуты нашего файлового дискриптора. Здесь мы можем в oldFlags узнать о том,
[34:37.440 --> 34:45.880]  что наш файловый дискриптор здесь доступен только для записи, но не для чтения. Добавляем
[34:45.880 --> 34:55.320]  к этим флагам еще флаг под названием nonBlock и после вызова FileControl с установкой флагов наш
[34:55.320 --> 34:59.960]  файловый дискриптор уже становится не блокирующим. То есть что у нас произойдет,
[34:59.960 --> 35:08.240]  когда место в буфере закончится и система вызовWrite не сможет ничего записать. В отличие
[35:08.240 --> 35:12.640]  от предыдущего случая, система вызовWrite не будет приостанавливать выполнение текущего процесса,
[35:12.640 --> 35:20.800]  а немедленно завершится вернув значение в минус один. То есть как будто возникла какая-то
[35:20.800 --> 35:28.800]  ошибка в записи и при этом ошибку пропишет значение Deg. Это означает, что мы можем когда-нибудь
[35:28.800 --> 35:37.280]  повторно записать что-то в файловый дискриптор, но сейчас он просто еще не готов. Если мы вызовем
[35:37.280 --> 35:43.960]  чтение из буфера просто для того, чтобы опустошить буфер связанный с каналом, то запись повторно у нас
[35:43.960 --> 35:56.520]  станет опять возможной. Вот тот же самый пример. Записываем все небольшими кусочками наш канал.
[35:56.520 --> 36:05.280]  До сих пор пока не будет достигнут лимит. Лимит мы достигли и здесь вместо того, чтобы зависнуть,
[36:05.280 --> 36:10.320]  мы честно выдаем какое-то диагнозическое сообщение. То есть мы упали в эту витку
[36:10.320 --> 36:18.040]  F, получили значение минус один и ошибку EG. Ну и после чтения некоторого тайм-аута,
[36:18.040 --> 36:25.240]  пока я с вами разговариваю, мы можем продолжить запись в канал. Сколько места там уже появилось.
[36:25.240 --> 36:33.240]  А место появилось потому, что там прочиталось? Да, место появилось потому,
[36:33.240 --> 36:43.600]  что был вызван вот этот вот стены вызов. Но как я уже говорил, у нас с каналом может быть связано
[36:43.600 --> 36:49.800]  несколько читателей и несколько писателей. Обычная ситуация возникает, когда вы создаете
[36:49.800 --> 36:57.320]  какие-то дочерние процессы, которые создаются в очередь копии файлов и дескрипторов, связанных
[36:57.320 --> 37:02.520]  с одним и тем же каналом. И возникает проблема, что у вас может быть несколько например дочерних
[37:02.520 --> 37:08.080]  процессов, которые читают из канала или несколько дочерних процессов, которые могут в канал записывать.
[37:08.080 --> 37:17.280]  Возникает проблема, как узнать, кто записал и что записал и как у нас вообще происходит смешивание
[37:17.280 --> 37:25.120]  данных в канале. На самом деле ответ никак узнать, кто записал и кто прочитал невозможно. То есть у нас
[37:25.120 --> 37:33.600]  данные всегда смешиваются. Но смешиваются они не совсем произвольным образом. У нас гарантируется,
[37:33.600 --> 37:40.800]  что есть некоторые минимальные атомарные куски данных, внутри которых данные не перемешиваются.
[37:40.800 --> 37:50.720]  По стандарту POSIX размер этого атомарного пуска равен 512 байтам. В современных реализациях
[37:50.720 --> 37:55.880]  новых операционных систем этот размер совпадает с размером одной страницы, то есть 4 килобайта.
[37:55.880 --> 38:10.280]  То есть что будет происходить, когда два процесса будут записывать что-то в один и тот же канал,
[38:10.280 --> 38:20.720]  читать мы будем где-то например из одного родителя. То есть один процесс у нас записывает в канал
[38:20.720 --> 38:30.800]  строку hello, другой записывает строку world. И что ожидается? Делает это все не параллельно друг к другу.
[38:31.240 --> 38:45.320]  Что мы ожидаем увидеть в родительском процессе? В родительском процессе мы видим, что мы получили
[38:45.320 --> 38:56.280]  два раза два независимых вызова read. То есть здесь у нас этот цикл чтения выполнется два раза и
[38:56.280 --> 39:03.120]  read два раза независимо. Вместо того чтобы прочитать максимальный размер буфера 4096 байт,
[39:03.120 --> 39:10.600]  он прочитал маленькие кусочки от каждого процесса по отдельности. Данные у нас не
[39:10.600 --> 39:23.000]  перемешались. То есть мы могли бы конечно наблюдать строчки вида v, e, o, l, r, l, l, o, d,
[39:23.000 --> 39:30.560]  поскольку процессы у нас выполняются параллельно друг к другу. Но этого мы не наблюдаем как раз за
[39:30.560 --> 39:37.440]  счет свойства атомарности. Потому что данные размеры в мини 512 байт идут от ним на проверённом
[39:37.440 --> 39:44.840]  куску. Процесс у меня сейчас висит, потому что я тут где-то не дописал в черных процессах,
[39:44.840 --> 39:53.600]  я в реалистском процессе не написал в открытии каналы, но это не особо принципиально. Чем важно
[39:53.600 --> 40:03.680]  это свойство и где на практике вы можете наблюдать смешивание канала. Ну вот обычное окошко терминала.
[40:03.680 --> 40:10.760]  Что такое обычный терминал? Это некоторая программа, которая запускает командный
[40:10.760 --> 40:19.120]  предприятие башки или что-то еще. Какие у нас есть пайлы дискрипторы, которые нужно с помощью
[40:19.120 --> 40:24.840]  канала перенаправлять на терминал. Это стандартный поток ввода, когда вы от клавиатуры к процессу
[40:24.840 --> 40:31.280]  направляете данные. Стандартный поток вывода, то что нужно прочитать, отрендерить, как-то
[40:31.280 --> 40:38.960]  красиво нарисовать моношириным шифтом. А еще есть стандартный поток ошибок. Стандартный поток
[40:38.960 --> 40:47.080]  ошибок обычно в терминалах записывается тот же самый поток, что и стандартный поток вывода.
[40:47.080 --> 40:51.560]  Но при этом, если вы независимо пишите в стандартный поток ошибок стандарт поток вывода,
[40:51.560 --> 40:58.440]  вы все-таки данные можете на терминале прочитать и эти данные будут содержать какой-то осмысленный
[40:58.440 --> 41:12.000]  текст, а вовсе не перемешанный по буквам. Ну и давайте еще раз вернемся к примеру, когда мы хотим
[41:12.000 --> 41:20.880]  запустить какой-то пару процессов и связать их каналом. Что у нас представляет собой каждый процесс?
[41:20.880 --> 41:28.440]  Это процессы, которые имеют стандартный поток вывода и стандартный поток вода. Когда мы создаем
[41:28.440 --> 41:36.160]  пайп, то мы создаем новую пару файлов дискрипторов, и у этой новой пары файлов дискрипторов есть
[41:36.160 --> 41:44.760]  какие-то в общем случае рандомные номера. Если у вас процесс достаточно свежий, то скорее всего эти
[41:44.760 --> 41:51.560]  номера будут 3 и 4, как самый первый неиспользуемый, но в общем случае это опять же рандом. Произвольные
[41:51.560 --> 41:59.040]  команды, например, если вы хотите использовать команду ls или wc или еще что-нибудь, они строго
[41:59.040 --> 42:04.320]  предполагают, что стандартные потоки, с которыми нужно взаимодействовать, располагаются по строго
[42:04.320 --> 42:11.920]  определенным файлам дискриптора. И как в этом случае можно поступить? Для этого существует
[42:11.920 --> 42:20.040]  системный вызов, который предназначен для создания нового файла дискриптора из уже
[42:20.040 --> 42:28.560]  существующего. Есть очень старый файл дискриптор под названием DAP, который создает просто копию
[42:28.560 --> 42:35.920]  файла дискриптора. Зачем он нужен? Непонятно, видимо когда-то очень давно, но сейчас он
[42:35.920 --> 42:42.200]  используется в некоторой левеси. Более важное значение есть системный вызов DAP с циферкой 2,
[42:42.200 --> 42:50.080]  который принимает два аргумента. Второй аргумент это номер файла дискриптора, то есть конкретное
[42:50.080 --> 43:03.160]  число, которое системный вызов должен вернуть. Что делает системный вызов DAP 2? Создает еще
[43:03.160 --> 43:08.240]  один новый валидный файловый дискриптор, при этом со строго указанным номером,
[43:08.240 --> 43:15.160]  который вы ему передали. Естественно может быть ситуация, что такой файловый дискриптор у нас
[43:15.160 --> 43:21.720]  уже был открыт, то есть уже существует. В этом случае он просто сначала закрывается, а затем
[43:21.720 --> 43:28.160]  создается новый файл дискриптора с тем же номером, который указывает на какой-то другой файл объект.
[43:28.160 --> 43:35.600]  Казалось бы можно было просто взять выполнить системный вызов close предварительно для какого-то
[43:35.600 --> 43:40.720]  файла дискриптора, который нужно освободить. Будем считать, что этот файл дискриптора у нас
[43:40.720 --> 43:46.320]  имеет уже минимальный номер. Дальше вызываем обычный DAP с цифрой 2, но это решение плохо тем,
[43:46.320 --> 43:54.400]  что будут два отдельных системных вызова и мало ли что произойдет, например между ними,
[43:54.400 --> 43:58.320]  особенно если многопоточенная программа может что-то произойти, открыться новый файл,
[43:58.320 --> 44:07.000]  и файл дискриптора будет зал. Системный вызов DAP2 гарантирует, что закрытие и создание
[44:07.000 --> 44:14.840]  новый файл дискриптора у вас всегда будет одной атомарной операцией. Ну и что полезного в этом
[44:15.440 --> 44:23.000]  полезного то, что мы можем в качестве второго аргумента указать какие-то стандартные номера
[44:23.000 --> 44:28.760]  файлов дискрипторов. 0 для стандартного потока ввода, 1 для стандартного потока вывода, 2 для стандартного
[44:28.760 --> 44:35.720]  потока ошибок и тем самым переназначить. Вот вывод любой производник программы, которая про это
[44:35.720 --> 44:49.000]  вообще ничего не знает по нашей пайпы, но что-то более осмысленное. Давайте рассмотрим
[44:49.000 --> 44:59.080]  практический пример использования DAP2. Вот у нас есть создание дочернего процесса. Дочерний
[44:59.080 --> 45:10.000]  процесс мы создали пайп, затем дочерний процесс у нас заменяется на некоторую внешнюю программу,
[45:10.000 --> 45:20.040]  для простоты это команда ls, и дальше мы должны вывод команда ls перенаправить канал, ну а дальше
[45:20.040 --> 45:26.680]  релизский процесс читает данные из этого канала и считает какой кабайт мы причитали и уводит что-то
[45:26.680 --> 45:38.760]  на экран с некоторым префиксом. Так запускаем нашу программу, вот честно мы получаем вывод что ls нам
[45:38.760 --> 45:47.360]  вернул 312 байп, как можно убедиться что у нас действительно правильный вывод, но опять же команда ls
[45:47.360 --> 45:55.600]  перенаправляем вывод на wc с опции минус c. Действительно мы ожидаем получить 312 байп.
[45:55.600 --> 46:05.520]  Так, за счет чего это происходит? За счет того что перед тем как вызвать команду ls, но при
[46:05.520 --> 46:13.280]  этом строго после форка, зачем нужно делать отдельные стадии создания процессов и замены
[46:13.280 --> 46:19.760]  текущего процесса на другую программу, для того чтобы можно было что-то настраивать между форками
[46:19.760 --> 46:27.640]  и дзеком. Например настраивать лимиты, а еще переназначать файлы дескрипта. И вот в момент
[46:27.640 --> 46:32.800]  вызова стена вызова DAP2 стандартный поток вывода для процесса, который потом превратится в ls,
[46:32.800 --> 46:44.600]  у нас превращается в некоторый канал. Здесь кстати я немножко не дописал, в хорошем после DAP2 нам
[46:44.600 --> 46:53.480]  становится не нужен вот этот файловый дескриптор и если мы не хотим чтобы у команды ls был файл
[46:53.480 --> 47:10.200]  дескриптер 4 надо его закрыть. Что будет если я не напишу DAP2? Если я DAP2 не напишу,
[47:10.200 --> 47:29.440]  несмотря на то что канал у меня действительно существует. Канал существует, но ls при этом
[47:29.440 --> 47:37.320]  продолжает писать стандартный поток вывода вовсе не в канал и поэтому получаем обычный вывод
[47:37.320 --> 47:46.520]  команды ls на терминал. Данные с канала мы не прочитали, просто процесс завершился и ничего не
[47:46.520 --> 47:52.080]  прочитали и не смогли посчитать количество об этом. Кстати почему мы этот вывод все-таки можем
[47:52.080 --> 47:58.320]  наблюдать? Потому что мы когда создали новый процесс у нашего родительского процесса уже есть
[47:58.320 --> 48:04.480]  какой-то стандартный поток вывода, соответственно дочерний процесс стандартного вывода тоже
[48:04.480 --> 48:14.720]  унаследовал и честно выполняет запись. Ну и зачем вообще нужны каналы, где они реально используются?
[48:14.720 --> 48:22.880]  Ну про один из примеров я вам уже сказал это окошко терминала, который создает три канала,
[48:22.880 --> 48:32.400]  причем всего два канала. Один в который пишет события от клавиатуры, и стандартный поток
[48:32.400 --> 48:44.200]  вывода и стандартного потока ошибок. Из стандартного потока вывода и стандартного
[48:44.200 --> 48:51.400]  потока ошибок терминал рисует какой-то текст. При этом первый и второй файлы дескрипторы в
[48:51.400 --> 48:59.960]  терминале обычно ссылаются на один и тот же пайм, поскольку рисовать терминал многим терминалом
[48:59.960 --> 49:07.000]  можно все одинаково, хотя бывают терминалы, которые например раскрашивают разными цветами
[49:07.000 --> 49:15.520]  стандартный поток вывода и стандартный поток ошибок. Смогут по-разному обрабатывать. Ну и взять
[49:15.520 --> 49:24.720]  любую среду разработки, который вы пишете код, запускаете, на самом деле селайн не является
[49:24.720 --> 49:32.200]  реализацией компилятора, не является реализацией оплатчика, он просто запускает команду GCC,
[49:32.200 --> 49:38.240]  Selang, GDB как внешний утилит, при этом использует команду из стандартной поставки вашего
[49:38.240 --> 49:46.440]  дистрибутива и взаимодействует с ними просто отправкой каких-то текстовых данных, опять же
[49:46.440 --> 49:55.160]  через обычные потоки вода и вывода или это используется канал. Ну и например взять
[49:55.160 --> 50:00.800]  какой-нибудь видеоплеер на базе Mplayer. Mplayer это консольный видео-проигрыватель, понятно,
[50:00.800 --> 50:07.000]  что видеоконтент через каналы гонят, это очень тяжело и так никто не делает, а вот управление
[50:07.000 --> 50:13.280]  самим плеером, то есть перемывка вперед-назад, звук громче-тише и так далее выполняется опять же
[50:13.280 --> 50:18.160]  через стандартный поток вода, стандартный поток вывода. Ну и на самом деле примеров очень много,
[50:18.160 --> 50:24.760]  при этом у каналов есть некоторые ограничения, но во-первых это файловый дескриптор,
[50:24.760 --> 50:31.000]  соответственно между собой взаимодействовать могут только родственные процессы, которые
[50:31.000 --> 50:37.120]  например унаследовали эти файлы дескриптора от родительского процесса. Если вы запускаете
[50:37.120 --> 50:43.880]  например разные вкладки в терминалы, разные программы, которые хотят между собой взаимодействовать,
[50:43.880 --> 50:54.040]  то они друг по другу естественно ничего не знают и как можно есть все-таки заставить процессы
[50:54.040 --> 51:00.840]  между собой общаться. Для этого есть специальный случай каналов, который называется именованные
[51:00.840 --> 51:07.960]  каналы, еще их называют файлы FIFO, First In, First Out. Это специальные типы файлов,
[51:07.960 --> 51:19.160]  создать их можно с помощью команды mkfifo, мы их создаем с помощью mkfifo какой-то канал.
[51:19.160 --> 51:32.000]  Вот у нас файл, который имеет размер 0 байт, специальный тип под названием FIFO,
[51:32.000 --> 51:38.520]  в линуксе немножко по-другому этот стат будет выглядеть, но суть в том, что у нас файл тает
[51:38.520 --> 51:47.200]  под некоторые FIFO. У файлов типа FIFO есть точно также права доступа, владелец,
[51:47.200 --> 51:53.200]  группа владельца и так далее. Ну, какой порядок работает с этим файлом? Давайте
[51:53.200 --> 51:58.320]  попытаемся из него что-то прочитать. Попытаемся что-то прочитать из канала,
[51:58.320 --> 52:06.880]  вот стенозавкат у нас в подвесе и ждет пока когда эти данные появятся. Мы можем
[52:06.880 --> 52:19.480]  в другой вкладке терминала взять и что-то записать в наш канал. Записали и теперь мы
[52:19.480 --> 52:26.800]  в другой вкладке получили это значение. Что будет если мы сначала запишем что-то в канал,
[52:26.800 --> 52:36.480]  а потом пытаемся прочитать. Вот утилита echo у нас зависает, поскольку она не может открыть
[52:36.480 --> 52:44.320]  от канала. В данном случае просто системный вызов open при открытии файла ждет пока кто-нибудь
[52:44.320 --> 52:50.480]  не откроет противоположную сторону этого канала. И после того как мы читаем что-то из канала,
[52:50.480 --> 53:02.960]  echo у нас завершает свою работу. То есть поведение здесь точно такое же как у обычных
[53:02.960 --> 53:12.760]  каналов. При этом у нас все-таки у fifa есть ограничение, но и у обычных каналов тоже связано
[53:12.760 --> 53:19.640]  с тем что они позволяют организовать взаимодействие только двух процессов между собой. Если вы будете
[53:19.640 --> 53:25.520]  использовать обычный неименованный канал для взаимодействия в нескольких процессах, то вы
[53:25.520 --> 53:31.960]  никогда не узнаете кто вам данные записал и никогда не узнаете кто у вас данные прочитал.
[53:31.960 --> 53:44.960]  Для именованных каналов fifa тут ситуация та же самая. То есть вы можете попытаться читать
[53:44.960 --> 53:59.520]  за одной вкладке. Можете попытаться читать еще из какой-то вкладки. И теперь делаю запись какой-то
[53:59.520 --> 54:06.280]  канал. Вопрос где у нас данные были прочитаны? Во вкладке номер 1 или во вкладке номер 3?
[54:06.280 --> 54:14.760]  Давайте смотрим. Вкладка номер 3 вывели, вкладка номер 1 ничего не вывели, но работу завершили.
[54:14.760 --> 54:21.960]  То есть поведение здесь считается неопределенным. Кто случайным образом первый смог прочитать,
[54:21.960 --> 54:30.440]  тот и прочитал. Поэтому для организации взаимодействия нескольких процессов каналы как
[54:30.440 --> 54:36.880]  именованные уже не подходят. И здесь надо использовать чуть более сложный механизм,
[54:36.880 --> 54:45.160]  который называется SOPET. Про SOPET у вас будет отдельно. Ну и последнее ограничение связанное
[54:45.160 --> 54:54.440]  с каналами. Опять же немного забегая вперед, в современных системах Linux и BSD macOS есть разные
[54:54.440 --> 54:58.920]  механизмы, которые позволяют работать с большим количеством файлов и скрипторов и сделать
[54:58.920 --> 55:05.560]  достаточно быстро, поскольку они обрабатывают события готовности файлов и скрипторов к чтению
[55:05.560 --> 55:11.960]  записи и открытии. Они работают с разными файловыми скрипторами, в том числе с каналами,
[55:11.960 --> 55:17.640]  но поддерживают неполный набор событий. Например события готовности к чтению, готовность к
[55:17.640 --> 55:25.720]  записи. Они умеют обрабатывать для каналов, а вот события связанные с закрытием канала
[55:25.720 --> 55:31.800]  противоположной стороной, они уже отследить не могут. И здесь есть некоторые функциональный аналог
[55:31.800 --> 55:40.560]  канала, который называется SOPETPR. То есть пара из двух локальных SOPET, но поддерживаются не всеми
[55:40.560 --> 55:47.680]  функционными системами. То есть Linux и BSD mac хорошо замечательная. Если взять какую-нибудь произвольную
[55:47.680 --> 55:56.360]  старинную UNIX-систему, то такого системного вызова там может быть. На этом все. Вот Рудалия
[55:56.360 --> 56:01.560]  от Сбера уже научился рисовать достаточно реалистичные картинки. Вот эту картинку он
[56:01.560 --> 56:11.360]  нарисовал по запросу Парик. Если у вас вопросы. Здравствуйте, Виктор Вадимович, можно задать вопрос
[56:11.360 --> 56:30.280]  о записи. Где она будет? Я эту запись кинул в слаг. Тут еще в чате вопрос, а нет никакой очереди?
[56:30.280 --> 56:39.600]  То есть FIFO? Для FIFO тут действует тот же самый порядок, что и для обычных канала. То есть данные
[56:39.600 --> 56:48.800]  размером менее, не превышающие размер кусочка 4000 га за 6 байт, они не перемешивают. Ну а дальше,
[56:48.800 --> 57:01.080]  кто первый случайно успел прочитать, тот прочитал. А следующая лекция также будет записываться,
[57:01.080 --> 57:09.880]  верно? Так, следующая лекция уже будет полноценная в аудитории. Насчет записи это скорее вопрос к
[57:09.880 --> 57:17.880]  тому, кто к лекторию фотомоиды. То есть конечно я могу делать запись, но у них это получается
[57:17.880 --> 57:29.080]  обычно лучше. Но с этого вместо я буду еще снимать акост, как лектория. В общем, стандартная съемка
[57:29.080 --> 57:39.440]  аудитории, все как обычно. Есть ли у вас еще содержательные вопросы?
[57:39.440 --> 57:50.680]  Будут ли выкладываться на презентации перстепенно или только перед? Я могу это делать,
[57:50.680 --> 57:54.680]  но напоминаете мне, что периодически презентации могу выкладывать тоже.
[57:59.080 --> 58:11.480]  Хорошо, я понял запрос. Сейчас тогда презентацию я могу скинуть прямо сейчас в iCloud, а видео
[58:11.480 --> 58:17.640]  с некоторым лагом, поскольку Zoom требует некоторую обработку. Если бы нужно было еще выложить на Google
[58:17.640 --> 58:35.920]  диск. Ну ладно, раз вопросов нет, тогда завершаемся.
