[00:00.000 --> 00:13.720]  Всем добрый день, давайте начнем. Сегодня мы продолжим изучать метапрограммирование в C++,
[00:13.720 --> 00:20.440]  ну и поговорим про некоторые особенности программирования на типах в C++. Наверное,
[00:20.440 --> 00:23.760]  для начала стоит сказать несколько слов по поводу того, что такое в принципе метапрограммирование.
[00:23.760 --> 00:30.480]  Ну, смотрите, если мы все время до этого изучали сам язык C++, как писать функции,
[00:30.480 --> 00:34.000]  как писать классы, их методы, то вообще говоря, мы программировали в терминах того,
[00:34.000 --> 00:38.280]  а как написать программу, то есть как написать программу, которая сделает определенные действия.
[00:38.280 --> 00:42.000]  Вот. Метапрограммирование же отвечает на вопрос, как написать программу,
[00:42.000 --> 00:46.680]  которая будет за меня писать программу. То есть, кругу говоря, мы пишем такую надстройку над
[00:46.680 --> 00:51.800]  программой, которая автоматически либо подставляет какой-то код, либо автоматически этот код убирает,
[00:51.800 --> 00:56.840]  и так далее. Вот. Соответственно, сегодня поговорим про классическое метапрограммирование,
[00:56.840 --> 01:03.400]  под которым я понимаю примерно следующее. Смотрите, современные стандарты C++ становятся
[01:03.400 --> 01:07.840]  все более-более лояльны к метапрограммированию. Они добавляют новые и новые фичи, которые
[01:07.840 --> 01:13.760]  позволяют более удобным способом сделать то, чего мы, собственно, хотим. А чего мы хотим,
[01:13.760 --> 01:18.000]  узнаем в течение сегодняшней лекции. Ну и под классический метапрограммирование я понимаю
[01:18.000 --> 01:24.760]  методы, которые существовали в языке C++ практически с момента его создания. Ну и, собственно,
[01:24.760 --> 01:29.560]  цель сегодняшней лекции показать, что на самом деле механизм шаблонов, который есть в языке C++,
[01:29.560 --> 01:35.760]  на самом деле очень мощный. Вот. Можно сказать, что вот такой вот шаблон. Шаблоны это такой вот,
[01:35.760 --> 01:41.200]  по сути, язык в языке, который позволяет делать много разных всяких вещей. Ну и, собственно,
[01:41.200 --> 01:46.360]  я надеюсь, что на сегодняшней лекции мы еще ближе познакомимся с шаблонами. То есть, появится
[01:46.360 --> 01:50.960]  больше понимания того, как они устроены, как они работают. Вот. И приведем примеры решения
[01:50.960 --> 01:57.080]  некоторых нетривиальных задач с помощью шаблонов. Ну прежде чем мы перейдем непосредственно к
[01:57.080 --> 02:00.640]  задачам, которые мы и собираемся решать, задачу метапрограммирования, которые мы собираемся
[02:00.640 --> 02:06.640]  решать, давайте вспомним или поговорим про такой механизм C++, как частично специализация шаблонов.
[02:06.640 --> 02:10.600]  Ну я напомню, что в C++ у нас есть механизм полной специализации, который говорит о том, что,
[02:10.600 --> 02:22.720]  если у меня есть какая-то шаблонная сущность, ну, допустим, шаблонная функция f, которая принимает
[02:22.720 --> 02:28.920]  аргументы шаблонным параметром t, и она каким-то образом работает, то для этого шаблона я могу
[02:28.920 --> 02:34.440]  написать специализацию. Что такое специализация? Специализация это, значит, сущность, которая
[02:34.440 --> 02:39.680]  начинается с вот такой преамбулы. Темплит с пустыми треугольными скобками. То есть, если мы встречаем
[02:39.680 --> 02:44.520]  темплит с пустыми треугольными скобками, означает, что сейчас будет идти специализация. Вот. Я хочу,
[02:44.520 --> 02:50.920]  допустим, специализировать этот шаблон. Что я могу сделать? Точнее, что я должен сделать? Я пишу полную
[02:50.920 --> 02:55.840]  сигнатуру функции f и везде вместо конкретного типа t, в сигнатуре функции данной или в типе
[02:55.840 --> 03:04.360]  функции, я прописываю конкретный тип. Ну, допустим, int x. Что это будет означать? Это будет означать
[03:04.360 --> 03:11.480]  следующее, что функция f является шаблонной, и в общем случае, что бы ни было подставлено в качестве
[03:11.480 --> 03:16.680]  шаблонного параметра t, функция f должна действовать вот таким вот образом. Но, конкретно в одном случае,
[03:16.680 --> 03:20.680]  конкретно в случае, если вдруг в качестве шаблонного параметра t мне подставит int,
[03:20.680 --> 03:28.480]  то шаблонная функция f должна раскрываться вот с такую сущность. То есть, я могу сказать следующее,
[03:28.480 --> 03:33.320]  что в общем случае шаблонная функция должна вести себя одним образом. Вот. Конкретно для
[03:33.320 --> 03:38.560]  какого-то специфичного типа функция должна вести себя некоторым другим образом. То есть,
[03:38.560 --> 03:45.560]  в частности, если я буду вызывать функцию f от doublet, то шаблон f от double будет инстанцироваться из
[03:45.560 --> 03:50.960]  этого общего шаблона. Если я буду вызывать f от int, то шаблон будет инстанцироваться из
[03:50.960 --> 03:55.720]  вот этой специализации. То есть, как все будет происходить? То есть, компилятор поймет,
[03:55.720 --> 04:01.080]  что функция f является шаблонной. Он взглянет в этот шаблон и поймет, что в качестве параметра t
[04:01.080 --> 04:07.560]  нужно вывести значение типа int. Вот. И в момент вывода типа t равным int, компилятор поймет, ага,
[04:07.560 --> 04:11.880]  а для t равным int у меня есть специальное указание. У меня есть специальные правила, которые говорят
[04:11.880 --> 04:16.520]  о том, что на самом деле нужно генерировать код не согласно вот этой функции, а согласно вот этой
[04:16.520 --> 04:21.120]  функции. То есть, механизм вывода шаблонных параметров происходит ровно так же, просто-напросто
[04:21.120 --> 04:26.520]  генерируется несколько иной код. То есть, в случае doublet и всех остальных типов генерируется вот такой
[04:26.520 --> 04:31.240]  код. В случае int генерируется вот такой код. Это механизм полной специализации, когда я полностью
[04:31.240 --> 04:35.680]  задаю все шаблонные параметры. То есть, я говорю, что если в качестве шаблонов параметров мне
[04:35.680 --> 04:42.560]  подставлены вот такие типы, то я буду действовать иначе. Окей? Вспомнили. Что такое частичная
[04:42.560 --> 04:46.120]  специализация? Ну, как следует из названия, частичная специализация это специализация,
[04:46.120 --> 04:51.400]  которая позволяет задать либо неполный список параметров, скажем, если у меня тут был еще
[04:51.400 --> 04:57.600]  какой-то шаблонный параметр. Вот. А тут я бы указал специализацию только для одного шаблона
[04:57.600 --> 05:04.800]  параметра, допустим. Вот. То есть, я, допустим, указал шаблонный параметр только для t. Тогда
[05:04.800 --> 05:08.320]  это была частичная специализация. Кстати, тут написан бред, потому что, как мы увидим далее,
[05:08.320 --> 05:13.640]  частичная специализация для функций не существует. Но в целом, идея, надеюсь,
[05:13.640 --> 05:18.880]  понятна. Что частичная специализация позволяет задать неполный набор типов или даже позволяет
[05:18.880 --> 05:23.760]  просто задать семейство типов, для которых частичная специализация будет работать. Вот. Ну,
[05:23.760 --> 05:27.240]  давайте посмотрим, например. Представь себе, что у меня есть структура isPointer, которая является
[05:27.240 --> 05:31.720]  шаблонной. Ну, шаблонная структура isPointer, которая параметризована произвольным типом t. Вот. И
[05:31.720 --> 05:39.040]  внутри себя содержит одно статическое poly bool value, которое равно false, и статический метод isn't
[05:39.040 --> 05:43.240]  pointer, который тоже означает false. Что это означает? Это означает, что я в этой структуре храню
[05:43.240 --> 05:51.640]  следующую информацию. В poly bool я буду хранить, является ли параметр t указателем, как следует
[05:51.640 --> 05:56.320]  из названия isPointer. Ну, а метод isIntPointer будет возвращать конкретно, является ли указатель,
[05:56.320 --> 06:03.160]  является ли передный тип интовым указателем или нет. Ну, понятное дело, что в общем случае
[06:03.160 --> 06:07.920]  передаваемый тип не является не указателем, ну, не тем более интовым указателем. Окей. Что я
[06:07.920 --> 06:13.840]  могу сделать? Ну, смотри, давайте посмотрим сразу вниз. Пропустим второй пункт. Давайте посмотрим
[06:13.840 --> 06:17.360]  вниз. Смотрите, внизу написано полная специализация. Как я уже сказал, полная специализация
[06:17.360 --> 06:23.560]  характеризуется тем, что я указываю конкретно тот тип, для которого я специализирую. И полная
[06:23.560 --> 06:27.080]  специализация начинается с преамбулы template пустые треугольные скобки. То есть я пишу template
[06:27.080 --> 06:31.480]  пустые треугольные скобки, дальше пишу структуру isPointer, и дальше в треугольных скобках для
[06:31.480 --> 06:37.640]  структуры могу указать, для какого типа я специализирую мой шаблон. Я говорю,
[06:37.640 --> 06:42.600]  что я специализирую структуру isPointer для типа инсозвездой. И в этом случае, если мне будет
[06:42.600 --> 06:47.720]  передан инсозвездой, то я говорю, что value, то есть в статическом поливалью, должно храниться true,
[06:47.720 --> 06:54.320]  а статический метод isPointer должен защищать true. Окей. Вот здесь нужно, вот что тут важно отметить.
[06:54.320 --> 06:59.880]  Важно отметить то, что на самом деле полная специализация, полная специализация, ну, здесь
[06:59.880 --> 07:07.760]  не полная, а вот полная специализация не обязана каким бы ты ни был образом соответствовать
[07:07.760 --> 07:12.880]  основному шаблону. То есть в целом, в теории, я могу тут написать, не знаю, вот в этой функции
[07:12.880 --> 07:24.200]  могу написать std.acout что-то, а здесь могу написать создание вектора, std.vector, его сортировку
[07:24.200 --> 07:28.880]  и так далее. То есть вообще говоря, шаблон и специализация могут вести себя абсолютно разным
[07:29.320 --> 07:34.320]  образом. То же самое касается структуры. То что я тут, так прости, то что я в основном шаблоне,
[07:37.200 --> 07:42.140]  и в специализацию я написал практически один и тот же код то есть то, что у меня основной шаблон и
[07:42.140 --> 07:46.400]  специализация содержит те же самые поля и те же самые методы, это, на самом ли, совпадение. То есть,
[07:46.400 --> 07:49.760]  в принципе, в специализации я могу прописать абсолютно другую структуру, которая ведет себя
[07:49.760 --> 07:53.140]  абсолютно другим образом. То есть у нее могут быть абсолютно другие поля, абсолютно другие методы.
[07:53.140 --> 07:58.080]  Окей. То есть в специализации основной шаблон не обязан быть хоть каким-либо каким бы ты
[07:58.080 --> 08:01.120]  это не было образом связано структурно, то есть у них не обязаны быть общие поля,
[08:01.120 --> 08:05.040]  не обязаны быть общие методы. Ну и конечно, частичная специализация,
[08:05.040 --> 08:08.000]  вот как раз, давайте посмотрим на середину. Частичная специализация, напомню,
[08:08.000 --> 08:11.520]  позволяет мне задать конкретное поведение, позволяет мне задать поведение не для
[08:11.520 --> 08:16.040]  конкретного типа, а для некоторого семейства типов. Ну, в частности, я могу написать
[08:16.040 --> 08:20.200]  следующее. Темпл от класс T, то есть ввожу шаблонный параметр T, и дальше пишу
[08:20.200 --> 08:25.080]  struct isPointerTestSsDoy. Что это будет означать? Это будет означать, что этот шаблон,
[08:25.080 --> 08:30.120]  точнее эта специализация, должна работать для всех типов,
[08:30.120 --> 08:35.760]  которые удовлетворяют следующему соотношению, которые имеют вот такой вид.
[08:35.760 --> 08:40.000]  Ну а какие типы имеют такой вид? Ну такой тип, такой вид имеют все указатели,
[08:40.000 --> 08:44.400]  согласны? Вот. То есть таким образом, я задал частичную специализацию для
[08:44.400 --> 08:48.240]  всевозможных указателей. Ну, на самом деле, не для всевозможных, ну это мы посмотрим дальше.
[08:48.240 --> 08:52.800]  В общем, для всех указателей, для всех обычных указателей это работает. Вот. И, собственно,
[08:52.800 --> 08:57.840]  в этой реализации я задаю в статическом поле value значение true, и в поле isIntPointer
[08:57.840 --> 09:01.320]  задаю false. Ну потому что в общем случае, ну потому что эта специализация принимает
[09:01.320 --> 09:06.480]  указатель, но при этом в общем случае это не обязательно новый указатель. Понятно? Ну,
[09:06.480 --> 09:12.600]  то есть примеры, какие примеры применения? Ну вот, соответственно, я могу создать,
[09:12.600 --> 09:16.800]  точнее я могу обратиться к структуре isPointer от int, то есть передать в качестве шаблонного
[09:16.800 --> 09:21.160]  параметра T int. И что будет происходить? Ну, понятное дело, в качестве шаблонного параметра T
[09:21.160 --> 09:27.440]  подставится int в основной шаблон. То есть сначала подставка происходит в основной шаблон. То есть
[09:27.440 --> 09:33.280]  в основной шаблон подставляется int, и дальше комплятор проверяет, а подходит ли тип int под
[09:33.280 --> 09:42.400]  T с звездой или под int с звездой. Ну, естественно, int не совпадает ни с int с звездой, не может
[09:42.400 --> 09:46.240]  быть представен в виде T с звездой. Поэтому работает общий шаблон, и в общем шаблоне у меня
[09:46.240 --> 09:52.760]  возвращается значение value, это false, и isPointer false. Что пройдет, если я передам в isPointer значение
[09:52.760 --> 09:59.960]  charge с звездой? Ну, пройдет следующее. Опять же, в общий шаблон подставится значение charge с звездой.
[09:59.960 --> 10:04.320]  Дальше charge с звездой будет проверяться со всеми специализациями, подходит ли charge с звездой,
[10:04.320 --> 10:07.960]  удовлетворяет ли charge с звездой вот этим соотношением. То есть то, что charge с звездой может
[10:07.960 --> 10:11.880]  быть равен одному из этих типов. Ну, понятное дело, charge с звездой не равен int с звездой, но при этом
[10:11.880 --> 10:16.680]  charge с звездой может быть представлен как T с звездой. Если я в качестве типа T, если я в
[10:16.680 --> 10:21.200]  качестве параметра T подставлю charge, то я получу точное соответствие. Согласны? Поэтому тут подходит
[10:21.200 --> 10:25.600]  частичная специализация, и в качестве структуры isPointer работает как раз таки частичная
[10:25.600 --> 10:30.960]  специализация, которая в качестве polyvalue хранит true, и истатическая функция isPointer возвращает
[10:30.960 --> 10:37.760]  false. Ну и наконец тоже простой пример. isPointer от int с звездой, естественно, вернет в обоих
[10:37.760 --> 10:43.920]  случаях true, в обоих случаях единицу, потому что у меня есть полная специализация на случай,
[10:43.920 --> 10:51.720]  если я в эту структуру передаю int с звездой. Окей? Механизм специализации понятен? Супер.
[10:51.720 --> 10:59.600]  На этом слайде показан еще один пример частичной специализации. Еще может быть
[10:59.600 --> 11:03.720]  специализация, которая указывает лишь какой-то определенный набор параметров. В частности,
[11:03.720 --> 11:07.600]  у меня есть общий шаблон структуры S, который принимает два шаблона параметра T и U. И у меня
[11:07.600 --> 11:11.800]  есть две специализации, которые являются частичными специализациями. Почему? Потому что первая
[11:11.800 --> 11:16.040]  частичная специализация, она сдает конкретный параметр для U, но при этом говорит, что типа T
[11:16.040 --> 11:20.000]  может быть любым. И вторая частичная специализация говорит о том, что первый параметр обязан быть
[11:20.000 --> 11:29.960]  float, а второй параметр может быть каким угодно. Если я создам структуру от bool bool, то я получу
[11:29.960 --> 11:35.320]  единицу. Почему? Потому что вот этот вот S с параметрами bool и bool не подходит ни под вторую,
[11:35.320 --> 11:42.440]  ни под третью специализацию. Структура bool int подходит по вторую специализацию, поэтому работает
[11:42.440 --> 11:48.240]  она. Cons-float bool подходит по первую специализацию. Почему? Потому что, несмотря на то, что тут
[11:48.240 --> 11:53.080]  качество первого типа указан cons-float, cons-float не совпадает с float. Поэтому третья частичная
[11:53.080 --> 11:56.920]  специализация не подходит и работает общий шаблон. Если я попытаюсь вызвать S-float int,
[11:56.920 --> 12:03.160]  то произойдет неоднозначный вызов. То есть компилятор увидит, что с одной стороны S от float
[12:03.160 --> 12:07.120]  int подходит под вторую частичную специализацию, в то же время S-float int подходит по третью
[12:07.120 --> 12:14.520]  частичную специализацию, и тут возникнет ошибка компиляции. Если подходят несколько частичных
[12:14.520 --> 12:19.320]  специализаций, то компилятор, во-первых, руководствуется принципом наименьших
[12:19.320 --> 12:25.440]  постановок, а если количество постановок одинаковое, то возникает проблема. Ну и конец,
[12:25.440 --> 12:31.040]  как я уже сказал, частичной специализации шаблонов функций не существует. Термин частичная
[12:31.080 --> 12:34.880]  специализация применим только к структурам и только к классам. Частично специализировать
[12:34.880 --> 12:39.240]  функции нельзя, функции можно специализировать только с помощью полной специализации. Договорились?
[12:39.240 --> 12:45.900]  Хорошо. pedestrians.com
[12:45.900 --> 12:50.280]  Давайте наконец перейдем к применениям этих самых частичных специализаций, что с помощью них
[12:50.280 --> 12:56.160]  можно делать, как на них метапрограммировать, так как можно программировать над программой или как
[12:56.160 --> 13:03.300]  можно программировать еще, Infod knighting , называютarda программирование над
[13:03.300 --> 13:05.700]  типами то есть мы в MOMY используем программируем над объектами, да, над значениями, вот
[13:05.700 --> 13:07.680]  а в метапрограммировании мы будем программировать над типами
[13:07.680 --> 13:11.340]  ну и давайте начнем с такое применение как определителя типов
[13:11.340 --> 13:15.620]  смотрите давайте я приставь себе следующую картину
[13:15.620 --> 13:21.180]  представлять тебе следующую картину у меня есть книг про шаблонная функция
[13:21.500 --> 13:22.860] verted?
[13:22.860 --> 13:38.940]  И что может быть с этой шаблонной функцией?
[13:38.940 --> 13:42.540]  С одной стороны, я могу вызвать функцию f от единицы
[13:42.540 --> 13:44.820]  и в качестве шаблона параметра t получить int.
[13:44.820 --> 13:45.820]  Согласны?
[13:45.820 --> 13:46.820]  То есть, если я вызову f из единицы, то в качестве
[13:46.820 --> 13:47.820]  t выводится степь int.
[13:47.820 --> 13:51.740]  С другой стороны, если я вызову функцию f вот так,
[13:51.740 --> 13:55.700]  const int и передам туда единицу, то что произошло?
[13:55.700 --> 13:57.900]  Я тут явно указал шаблонный параметр, и тогда в качестве
[13:57.900 --> 14:02.300]  шаблонового параметра t у меня будет выведен const int.
[14:02.300 --> 14:06.420]  Ну, понятное дело, что в зависимости того является
[14:06.420 --> 14:12.780]  тип t константом или нет, я могу выбирать различные
[14:12.780 --> 14:14.060]  варианты реализации.
[14:14.620 --> 14:17.860]  Ну или, например, не знаю, наверное, больше смысл
[14:17.860 --> 14:18.860]  имеет там персант.
[14:18.860 --> 14:24.300]  Ну и в частности, если мы передали просто int ссылка,
[14:24.300 --> 14:27.380]  то есть как, не знаю, не в этом случалось, f от x и тут
[14:27.380 --> 14:28.380]  f от x.
[14:28.380 --> 14:31.620]  Если мы передали int ссылку, то соответственно, я знаю,
[14:31.620 --> 14:35.820]  что вот этот x можно менять, то есть можно менять исходный
[14:35.820 --> 14:39.260]  x, и тогда это изменение отразится на внешней переменной.
[14:39.260 --> 14:42.020]  Если вы мне явно указали, что я хочу передать по
[14:42.020 --> 14:44.740]  константной ссылке, я хочу передать const int, то соответственно
[14:44.740 --> 14:46.580]  сюда вместо типа t будет поставлен const int, получится
[14:46.580 --> 14:48.620]  const int ссылка, и тогда этот x я менять не могу.
[14:48.620 --> 14:50.500]  Понятное дело, что в зависимости этого поведение моей функции
[14:50.500 --> 14:51.500]  может меняться.
[14:51.500 --> 14:52.500]  Согласны?
[14:52.500 --> 14:53.980]  То есть могу я изменять x или не могу я изменять x?
[14:53.980 --> 14:55.140]  Это абсолютно две разные вещи.
[14:55.140 --> 14:56.140]  Вот.
[14:56.140 --> 15:00.100]  Возникает вопрос, как находясь внутри функции, вот представьте,
[15:00.100 --> 15:02.580]  вот я пишу шаблонную функцию, и мне в какой-то момент нужно
[15:02.580 --> 15:07.700]  понять, вот тип t является константом или нет, как это
[15:07.700 --> 15:11.660]  можно было понять, имея на руках текущие знания.
[15:11.660 --> 15:13.420]  Кажется, что более-менее никак.
[15:13.420 --> 15:14.420]  Почему?
[15:14.420 --> 15:18.580]  Потому что, вот как я проверю, является ли t константом
[15:18.580 --> 15:19.580]  или нет?
[15:19.580 --> 15:23.220]  То есть мне нужно написать что-то типа, если тип t константный,
[15:23.220 --> 15:29.780]  если t константный, то нужно сделать что-то, а иначе нужно
[15:29.780 --> 15:30.780]  делать что-то другое.
[15:30.780 --> 15:36.260]  Через исключение, а каким образом через исключение?
[15:36.260 --> 15:43.260]  Вот, смотрите в чем проблема, проблема в том, что если
[15:43.260 --> 15:46.180]  я буду пытаться присваивать, ну понятно, как можно проверить
[15:46.180 --> 15:47.660]  константность или не константность?
[15:47.660 --> 15:49.980]  Я могу просто взять x и пытаться ему там присвоить
[15:49.980 --> 15:50.980]  какое-то значение.
[15:50.980 --> 15:51.980]  То есть в единицу.
[15:51.980 --> 15:52.980]  Вот.
[15:52.980 --> 15:53.980]  Что в этом случае произойдет?
[15:53.980 --> 15:55.700]  В этом случае, если тип t константный, то произойдет
[15:55.700 --> 15:56.700]  что?
[15:56.700 --> 15:59.700]  Пройдет ошибка компиляции, да?
[15:59.700 --> 16:01.860]  То есть у меня программа в принципе не скомпилируется,
[16:01.860 --> 16:03.820]  а я бы хотел, чтобы программа компилировалась, но при
[16:03.820 --> 16:06.220]  этом в зависимости того, является ли тип t константным
[16:06.220 --> 16:07.940]  или нет, она вела себя чуть иначе.
[16:07.940 --> 16:12.380]  И вот тут мы приходим к необходимости иметь такой
[16:12.380 --> 16:14.900]  механизм в языке, как определитель типов.
[16:14.900 --> 16:18.100]  То есть я бы хотел, чтобы шаблон каким-то образом
[16:18.100 --> 16:20.860]  смог проанализировать вот этот тип t и сказать мне,
[16:20.860 --> 16:23.380]  допустим, является он константный или нет.
[16:23.380 --> 16:25.580]  Знакомьтесь, как это можно сделать с помощью механизма
[16:25.580 --> 16:26.580]  частичной специализации?
[16:26.580 --> 16:27.580]  Смотрите, что я сделаю.
[16:27.580 --> 16:30.940]  Я напишу специальную структуру, которую назову искonst.
[16:30.940 --> 16:33.740]  Структура искonst будет шаблонной структурой, которая
[16:33.740 --> 16:36.340]  будет хранить внутри себя статическое поле value, которая
[16:36.340 --> 16:37.340]  будет хранить false.
[16:37.340 --> 16:40.140]  То есть я говорю, что в произвольном случае тип
[16:40.140 --> 16:41.140]  не является константной.
[16:41.140 --> 16:42.140]  Так?
[16:42.140 --> 16:45.420]  А в каком случае структура искonst должна хранить значение
[16:45.420 --> 16:46.420]  true?
[16:46.420 --> 16:48.540]  Ну а структура искonst должна хранить значение true только
[16:48.540 --> 16:50.860]  в том случае, если ей в качестве шаблонного параметра
[16:50.860 --> 16:52.780]  передали константный тип.
[16:52.780 --> 16:55.860]  Ну давайте я для этого случая напишу частичную специализацию.
[16:55.860 --> 16:56.860]  Вот.
[16:56.860 --> 16:57.860]  То есть что я пишу?
[16:57.860 --> 17:00.140]  Я пишу частичную специализацию, то есть я пишу template class
[17:00.140 --> 17:03.380]  t, структура искonst и в треугольной скобке передаю
[17:03.500 --> 17:04.500]  конст t.
[17:04.500 --> 17:10.580]  То есть в этот шаблон будут подставляться все типы,
[17:10.580 --> 17:15.620]  в этот шаблон будут подставляться все типы, которые удовлетворяют
[17:15.620 --> 17:16.620]  вот такому соотношению.
[17:16.620 --> 17:21.540]  То есть если тип представим вот в таком виде, то он будет
[17:21.540 --> 17:23.860]  выбран в качестве специализации.
[17:23.860 --> 17:24.860]  Понятно?
[17:24.860 --> 17:29.060]  Теперь, как это будет работать в коде?
[17:29.060 --> 17:30.500]  В коде это будет работать так.
[17:30.500 --> 17:35.700]  Ну давайте я напишу такую функцию.
[17:35.700 --> 17:38.420]  Я хочу в зависимости того, является ли тип так констант
[17:38.420 --> 17:40.220]  или нет, ну просто вывести на экран, допустим, констант
[17:40.220 --> 17:41.220]  или не констант.
[17:41.220 --> 17:42.220]  Я могу написать так.
[17:42.220 --> 17:59.660]  Если искonst от t, 2.2.value, то tout конст.
[18:00.660 --> 18:08.220]  А иначе, cout non-const.
[18:08.220 --> 18:15.020]  Понятно, как это работает?
[18:15.020 --> 18:21.900]  Да, 2.2.value, смотрите, у меня поле value статическое.
[18:21.900 --> 18:26.540]  Вот, поэтому искonst от t, это я создаю, ну обращаюсь
[18:26.540 --> 18:29.620]  к структуре, точнее, к констанцированию структуры искonst,
[18:29.620 --> 18:30.620]  параметром t.
[18:30.620 --> 18:32.300]  И в зависимости от того, что у меня будет передано
[18:32.300 --> 18:34.300]  в качестве параметра t, ну, допустим, если в качестве
[18:34.300 --> 18:38.140]  параметра t будет передан int, то я создам искonst от
[18:38.140 --> 18:39.140]  int.
[18:39.140 --> 18:42.740]  Искonst от int не подходит под шаблон конст t, поэтому
[18:42.740 --> 18:45.060]  работает первый шаблон, и там в статическом поле
[18:45.060 --> 18:47.820]  хранится значение false, поэтому тут будет false, я
[18:47.820 --> 18:48.820]  попаду вот сюда.
[18:48.820 --> 18:52.980]  Если же я в качестве параметра t передам констинт, то что
[18:52.980 --> 18:53.980]  произойдет?
[18:53.980 --> 18:57.180]  У меня искonst будет параметризован типом констинт, то есть
[18:58.180 --> 19:01.140]  сначала констинт подставится в первый шаблон, а дальше
[19:01.140 --> 19:02.900]  компилятор будет проверять, а подходит ли констинт
[19:02.900 --> 19:05.580]  под какую-то из частичных специализаций.
[19:05.580 --> 19:06.980]  И компилятор увидит, что действительно.
[19:06.980 --> 19:13.700]  У меня есть констинт, и констинт может совпадать
[19:13.700 --> 19:17.220]  с конст т в случае, если я в качестве т подставлю
[19:17.220 --> 19:18.220]  int.
[19:18.220 --> 19:22.300]  И в этом случае в статическом поле value будет храниться
[19:22.300 --> 19:25.420]  значение true, соответственно, тут вернется true, я попаду
[19:25.420 --> 19:27.140]  вот сюда, вот в эту ветку, и выведу конст.
[19:27.140 --> 19:28.140]  Окей?
[19:28.140 --> 19:35.220]  Я смог получить определитель типа, то есть я смог на основании
[19:35.220 --> 19:39.220]  шаблонового параметра сделать вывод о том, является
[19:39.220 --> 19:41.060]  ли это тип константа или нет.
[19:41.060 --> 19:45.260]  Кажется, что раньше существующими способами C++ я этого сделать
[19:45.260 --> 19:46.260]  не мог.
[19:46.260 --> 19:48.500]  Теперь же я могу анализировать, то есть я теперь могу брать
[19:48.500 --> 19:51.460]  шаблонные параметры, их анализировать, выяснять,
[19:51.460 --> 19:54.860]  есть ли у них какие-то требуемые свойства или нет.
[19:54.860 --> 19:55.860]  Понятно?
[19:55.860 --> 20:02.500]  Ну, собственно, упростим предыдущий пример, я напомню,
[20:02.500 --> 20:05.460]  что в прошлый раз мы с вами познакомились с таким
[20:05.460 --> 20:08.260]  классом из стандартной библиотеки C++ как integral constant,
[20:08.260 --> 20:12.380]  я напомню, что integral constant хранит внутри себя статическое
[20:12.380 --> 20:15.620]  поле value определенного типа, который я передал в качестве
[20:15.620 --> 20:16.620]  параметра шаблона.
[20:16.620 --> 20:20.460]  И предыдущий код можно упростить так, можно сказать,
[20:20.460 --> 20:23.660]  что из конст у нас следован от типа integral constant, вот
[20:24.340 --> 20:27.260]  хранит внутри себя статическое поле bool со значением false,
[20:27.260 --> 20:29.740]  а из конста от конста t, то есть частичная специализация
[20:29.740 --> 20:34.100]  у нас следована от integral constant, которая в качестве статического
[20:34.100 --> 20:38.060]  поля хранит bool и хранит значение true.
[20:38.060 --> 20:39.060]  Окей?
[20:39.060 --> 20:44.180]  Ну, пример можно упростить еще сильнее, на самом деле
[20:44.180 --> 20:47.660]  в стандартной библиотеке C++ есть еще целый набор типов,
[20:47.660 --> 20:50.700]  помимо того, что есть integral constant, есть еще bool constant,
[20:50.700 --> 20:59.580]  по сути можно считать, что тип bool constant от B это то
[20:59.580 --> 21:06.100]  же самое, что и integral, ну просто сокращение от integral
[21:06.100 --> 21:13.380]  constant от bool и B, вот, в то же время есть специальные
[21:13.380 --> 21:33.300]  типы true type и false type, которые равны типам bool constant от true
[21:33.300 --> 21:46.220]  и bool constant от false, ну просто-напросто вот эти типы true type, false type и bool
[21:46.220 --> 21:50.060]  constant, они позволяют упростить написание вот этих самых
[21:50.060 --> 21:52.260]  определителей типа, то есть сейчас, например, если я хочу
[21:52.260 --> 21:55.140]  написать, я хочу написать структуру, которая в качестве
[21:55.140 --> 21:59.140]  поля просто-напросто хранит значение false, как на предыдущем
[21:59.140 --> 22:01.820]  слайде, я хочу написать структуру из конст, которая просто-напросто
[22:01.820 --> 22:05.860]  хранит поле value, в котором хранится значение false, или я хочу написать
[22:05.860 --> 22:08.780]  специализацию, которая хранит в статическом поле value значение true, в общем,
[22:08.780 --> 22:11.780]  код можно упростить просто-напросто до вот такого, просто из конст унаследовать от
[22:11.780 --> 22:16.300]  false type и из конст от const t унаследовать от true type, да, false type и true type
[22:16.300 --> 22:19.860]  это такие специальные типы, которые внутри себя хранят поле value
[22:19.860 --> 22:26.020]  со значения false или true, окей, ну просто вот эти вот самые определители типов
[22:26.020 --> 22:30.100]  настолько часто используют, настолько часто пишутся, вот чтобы упростить
[22:30.100 --> 22:36.420]  написание кода используются вот специальные типы, окей, хорошо, давайте приведем еще
[22:36.420 --> 22:41.460]  пример, ну еще один пример, определитель типа это из pointer, ну опять же та же самая
[22:41.460 --> 22:46.780]  задача, я хочу понять, является ли тип t указателем или нет, да, ну вот, мне есть тип t,
[22:46.780 --> 22:50.300]  тут я выяснял, является ли тип т константы или нет, я сейчас хочу выяснить, является ли
[22:50.300 --> 22:59.020]  тип t указателем, является ли тип t указателем, окей, ну опять же, да, я пишу общий
[22:59.020 --> 23:03.500]  шаблон, общий шаблон из pointer, ну понятно, дел по умолчанию, произвольный тип указателем ни в
[23:03.500 --> 23:08.020]  коем случае не является, поэтому я общий шаблон из pointer наследую от false type, ну и дальше я
[23:08.020 --> 23:12.100]  прописываю следующий код, я говорю, что если у меня тип удовлетворяет вот такому шаблону, да, то есть
[23:12.100 --> 23:17.860]  если мне передный тип может быть выражен вот в таком виде, то это означает, что это указатель я
[23:17.860 --> 23:22.180]  должен вернуть, и значит, что у меня в статическом поле value должно храниться true, то есть я наследую
[23:22.180 --> 23:28.780]  из pointer от true type, вот, а последние три специализации они сделаны вот про что, смотрите, вот для чего
[23:28.780 --> 23:36.500]  представьте себе, представьте себе, что я в качестве шаблонного параметра, ну допустим вот из pointer,
[23:36.500 --> 23:46.260]  да, из pointer, а передаю не просто указатель, а константный указатель, допустим int звездочка
[23:46.260 --> 23:56.220]  const, вопрос, является ли это тип указателем или нет, ну константный указатель это указатель,
[23:56.220 --> 24:07.620]  например, константный int это int, ну да, конечно, то есть константный указатель это естественный
[24:07.620 --> 24:11.620]  указатель, потому что он куда-то указывает, но то, что его там изменить нельзя, ну ладно, это его
[24:11.620 --> 24:26.740]  проблема, вот, а смотрите, а вот int за звездой const, равен ты со звездой, вот, давайте решим вот такую
[24:26.740 --> 24:36.020]  загадку, что нужно подставить в качестве типа T, чтобы получилось равенство, ну кажется, что ничего,
[24:36.020 --> 24:40.900]  согласны, ну что можно поставить в качестве типа T, ну если в качестве типа T подставлю int, то я
[24:40.980 --> 24:44.880]  получу int за звездой, если я в качестве типа T подставлю const, то я получу constant за
[24:45.480 --> 24:49.060]  звездой, ну я получу справа, что, указатель на константу, а следует стоять константный
[24:49.060 --> 24:52.660]  указатель, ну я надеюсь мы ещё помним, что указатель, константный и константный указатель
[24:52.660 --> 24:57.960]  это разные вещи, вот, поэтому, конечно, что бы я тут не поставил, всё равно получится указатель,
[24:57.960 --> 25:01.580]  который не является константным, здесь указатель будет как ни крути не константным, а тут указатель
[25:01.580 --> 25:06.020]  сам константный, вот, так вот, чтобы справиться с этой проблемой я прописываю ещё частительная
[25:06.020 --> 25:16.020]  Я прописываю частичную специализацию в случае, если мне передали на вход константный указатель, дальше та же самая проблема может постигнуть волатайл указатель.
[25:16.020 --> 25:20.020]  Консты волатайла обладают тем же самым проблемом.
[25:20.020 --> 25:25.020]  Поэтому если в случае мне передали волатайл указатель, то я прописываю четвертый шаблон.
[25:25.020 --> 25:29.020]  И наконец, если мне передали одновременно и консты волатайла указатель, я прописываю 5D шаблон.
[25:29.020 --> 25:32.020]  Я учел вообще всевозможные случаи передачи указатель.
[25:32.020 --> 25:39.020]  Какой бы мне указатель ни передали, неважно там константный, волатильный или константный волатильный, то все будет окей.
[25:39.020 --> 25:40.020]  Понятно?
[25:46.020 --> 25:53.020]  Ну в целом да, но этого к сожалению не избежать, потому что сложно написать общий тип.
[25:53.020 --> 25:57.020]  Нет, точнее так. Смотрите, можно написать некоторый общий тип, можно было бы сократить.
[25:57.020 --> 26:02.020]  Если бы при передаче в испойнтере я бы сначала приводил указатель конст волатайла,
[26:02.020 --> 26:05.020]  только потом проверял подходит ли это указатель под конст волатайла.
[26:05.020 --> 26:11.020]  Но кажется, что для понимания вашего проще написать вот так.
[26:15.020 --> 26:19.020]  Нет, можно написать волатайл конст. Конст волатайл и волатайл конст абсолютно эквалентны.
[26:19.020 --> 26:29.020]  Волатайл конст, ну в целом да. Волатайл и конст они в целом артагональны друг к другу.
[26:29.020 --> 26:32.020]  Их можно писать в произвольном порядке.
[26:42.020 --> 26:46.020]  Сейчас, можно было передать enable if, но тут на самом деле enable if ни при чем.
[26:46.020 --> 26:50.020]  Нет, смотрите enable if он слушает для чего.
[26:50.020 --> 26:54.020]  А сейчас, можно ли тут использовать enable if?
[26:54.020 --> 26:57.020]  Можно ли тут использовать enable if?
[26:57.020 --> 27:01.020]  Ну нет, смотрите, чтобы использовать enable if, там скорее всего тоже нет.
[27:01.020 --> 27:05.020]  Чтобы использовать enable if вам нужно некоторое булевское выражение.
[27:05.020 --> 27:10.020]  То есть вам нужно как бы для использования enable if вам нужно быть в этом положении.
[27:10.020 --> 27:14.020]  То есть как бы для использования enable if вам нужно быть все равно какой-нибудь определитель типа.
[27:14.020 --> 27:17.020]  А мы как бы это определитель типа пишем.
[27:17.020 --> 27:19.020]  То есть как работает enable if?
[27:19.020 --> 27:22.020]  enable if принимает в качестве первого шаблона параметра некоторое значение типа bool.
[27:22.020 --> 27:25.020]  И дальше, ну собственно, тип, который я хочу подставить.
[27:25.020 --> 27:27.020]  А как я получу это булевское выражение?
[27:27.020 --> 27:32.020]  То есть как кажется, что в этом булевском выражении я должен понять, является ли тип каким.
[27:32.020 --> 27:34.020]  То есть является ли тип указателем.
[27:34.020 --> 27:37.020]  Я вроде как пишу уже определитель типа указатель.
[27:37.020 --> 27:39.020]  Ну в общем, ладно, дойдем до enable if, обсудим.
[27:39.020 --> 27:42.020]  Ну кажется, что тут enable if особо не применить.
[27:42.020 --> 27:45.020]  Так, есть ли еще вопросы?
[27:45.020 --> 27:47.020]  Окей.
[27:47.020 --> 27:49.020]  Значит, еще один пример.
[27:49.020 --> 27:55.020]  Ну абсолютно аналогичный с проверкой на то, является ли тип ссылкой.
[27:55.020 --> 27:59.020]  Например, я хочу, допустим, проверить, является ли передный тип T
[27:59.020 --> 28:03.020]  левой ссылкой, правой ссылкой, или вообще, в принципе, является он ссылкой или нет.
[28:03.020 --> 28:07.020]  Ну вот, собственно, первые два пункта, это проверка на то, является ли тип L-value ссылкой.
[28:07.020 --> 28:14.020]  То есть тип является L-value ссылкой, если он подходит под вот такой вот шаблон.
[28:14.020 --> 28:17.020]  То есть в первом случае, в общем шаблоне, я возвращаю false.
[28:17.020 --> 28:19.020]  Во втором, в частном случае, я возвращаю true.
[28:19.020 --> 28:22.020]  Я проверяю, является ли тип R-value ссылкой вот таким вот образом.
[28:22.020 --> 28:26.020]  То есть если тип удовлетворяется отношению T в двойном персент, то значит это R-value ссылка.
[28:26.020 --> 28:28.020]  В первом случае, в общем случае, это false.
[28:28.020 --> 28:30.020]  Так, вот.
[28:31.020 --> 28:33.020]  В первом случае, в общем случае, это false.
[28:33.020 --> 28:38.020]  Ну наконец, тип просто является ссылкой, если он либо L-value ссылкой, либо R-value ссылкой.
[28:38.020 --> 28:42.020]  Вот тут я использую краски bool constant, вот этот тип bool constant,
[28:42.020 --> 28:44.020]  в который я просто передаю требующее значение.
[28:44.020 --> 28:48.020]  Да, и, соответственно, bool constant принимает значение true,
[28:48.020 --> 28:53.020]  если тип является L-value reference, или он является R-value reference.
[28:53.020 --> 28:55.020]  Не-не, смотрите, это работает по-другому.
[28:55.020 --> 28:57.020]  Это работает по-другому.
[28:59.020 --> 29:01.020]  Смотрите, давайте разберем.
[29:01.020 --> 29:05.020]  Вот, что происходит, когда я передаю из R-value
[29:07.020 --> 29:09.020]  референс от...
[29:09.020 --> 29:11.020]  Ну, что? Интерперсант?
[29:11.020 --> 29:13.020]  Ну да, давайте передадим интерперсант.
[29:13.020 --> 29:15.020]  Что в этом случае произойдет?
[29:15.020 --> 29:17.020]  Смотрите, тут важно понимать, важно понимать, что
[29:18.020 --> 29:22.020]  в первую очередь, тип всегда сначала подставляется в общий шаблон.
[29:22.020 --> 29:25.020]  То есть, сначала у меня подставляется в качестве...
[29:25.020 --> 29:27.020]  Ну, сначала берется общий шаблон,
[29:27.020 --> 29:31.020]  и в качестве типа T подставляется интерперсант.
[29:31.020 --> 29:32.020]  Вот.
[29:32.020 --> 29:34.020]  Дальше берется значение интерперсант,
[29:34.020 --> 29:39.020]  и я его пробую подставить в частичную специализацию.
[29:39.020 --> 29:43.020]  То есть, я проверяю, верно ли что интерперсант представим вот в таком виде.
[29:43.020 --> 29:46.820]  То есть я проверяю, верный или что-нибудь имперсант представим вот в таком виде.
[29:48.780 --> 29:50.780]  Верный или что-то имперсант представим вот в таком виде.
[29:51.960 --> 29:53.960]  Почему? Как?
[29:54.260 --> 29:56.260]  Ну нет, не совсем, потому что
[29:56.920 --> 29:59.060]  нет не совсем так, потому что
[29:59.060 --> 30:01.060]  здесь навешана одна ссылка
[30:01.840 --> 30:05.260]  а здесь двойная ссылка. То есть смотрите, нет, смотрите, это не универсальная ссылка
[30:05.660 --> 30:07.540]  это именно R-value ссылка.
[30:07.540 --> 30:11.600]  Универсальная ссылка присутствует только в параметрах функций. Вот. То есть как бы
[30:13.020 --> 30:20.020]  Вот тут я не могу подставить какой-то тип, который бы удовлетворял вот этому соотношению.
[30:20.020 --> 30:25.020]  Поэтому тут эта частичная специализация не подойдет, и будет работать общая специализация,
[30:25.020 --> 30:28.020]  которая скажет о том, что это на самом деле не R-value ссылка.
[30:36.020 --> 30:40.020]  Ну и наконец еще один определитель типов, который на самом деле используется довольно часто.
[30:40.020 --> 30:43.020]  Ну представьте себе следующую картину.
[30:48.020 --> 30:57.020]  Вот у меня снова есть шаблон template класс T и класс U.
[30:57.020 --> 31:04.020]  Вот, и функция принимает TX у Y.
[31:05.020 --> 31:11.020]  И внутри этой функции я хочу проверить, верно ли, что тип T совпадает с типом U.
[31:11.020 --> 31:16.020]  Могу я написать T равно равно U? Проверить ли это на равенство 2 типа?
[31:16.020 --> 31:18.020]  Нет, операция равно равно к типам не применима.
[31:18.020 --> 31:21.020]  Операция равно равно применима только к объектам.
[31:21.020 --> 31:28.020]  Опять же, операции в обычной программировании я применяю к объектам. Я программирую объекты.
[31:28.020 --> 31:30.020]  К типам я такие операции применять, к сожалению, не могу.
[31:30.020 --> 31:33.020]  Но что я могу сделать для того, чтобы проверить одинаковые два типа или нет?
[31:33.020 --> 31:35.020]  А я могу написать частичную специализацию.
[31:35.020 --> 31:38.020]  Смотрите, я могу написать структуру isSame,
[31:38.020 --> 31:41.020]  которая в общем случае говорит о том, что два типа T и U, естественно, не равны друг другу.
[31:41.020 --> 31:44.020]  В общем случае isSame унаследован от false type.
[31:44.020 --> 31:47.020]  А в частном случае, если isSame удовлетворяет,
[31:47.020 --> 31:51.020]  точнее если передние параметры удовлетворяют вот такому соотношению T и T,
[31:51.020 --> 31:53.020]  то есть если это два одинаковых типа,
[31:53.020 --> 31:57.020]  то в этом случае isSame внутри себя будет хранить значение true.
[31:57.020 --> 32:00.020]  Вот, я наследую в этом случае isSame от true type.
[32:00.020 --> 32:03.020]  Ну и наконец такой небольшой бонус.
[32:03.020 --> 32:06.020]  Смотрите, что если я хочу проверить равенство не от двух типов,
[32:06.020 --> 32:08.020]  а равенство сразу многих типов?
[32:08.020 --> 32:10.020]  Тогда я могу написать такой определитель areSame,
[32:10.020 --> 32:14.020]  который будет использовать механизм вариативно-вариабельных шаблонов.
[32:14.020 --> 32:19.020]  Я беру тип T, беру откусовую голову, беру все остальные типы, other.
[32:19.020 --> 32:23.020]  И дальше говорю, что areSame унаследован от bool constant
[32:23.020 --> 32:27.020]  с параметром b, который равен isSame от t other.
[32:27.020 --> 32:32.020]  С параметром b, который равен isSame от t other и так далее.
[32:32.020 --> 32:34.020]  То есть во что это раскрывается?
[32:37.020 --> 32:45.020]  Что такое isSame от t other,
[32:45.020 --> 32:50.020]  двоеточие, двоеточие value и амперсант, амперсант.
[32:51.020 --> 32:53.020]  Помните этот синтактис?
[32:54.020 --> 32:56.020]  Ну это выражение свертки, да?
[32:56.020 --> 33:01.020]  То есть тут написано некоторый пакет параметров,
[33:01.020 --> 33:05.020]  и я распаковываю его с помощью операции амперсант и амперсант.
[33:05.020 --> 33:06.020]  Как это работает?
[33:06.020 --> 33:12.020]  Это работает так, что берется is и other 1,
[33:12.020 --> 33:22.020]  двоеточие, двоеточие value и isSame от t и other 2,
[33:22.020 --> 33:26.020]  двоеточие, двоеточие value и так далее.
[33:27.020 --> 33:29.020]  Да, тут просто раскрывается вот такое соотношение.
[33:29.020 --> 33:34.020]  То есть я беру параметр t и проверяю его с каждым параметром из пакета other.
[33:35.020 --> 33:36.020]  Понятно? Да.
[33:40.020 --> 33:41.020]  Что сработает?
[33:42.020 --> 33:45.020]  Короткая логика, короткая логика.
[33:46.020 --> 33:49.020]  Кстати, сейчас, хороший вопрос, работает ли тут короткая логика.
[33:49.020 --> 33:55.020]  Ну, кстати, нет, скорее всего нет, короткая логика не сработает.
[33:55.020 --> 33:59.020]  Почему? Потому что, ну, понятное дело, чтобы раскрыть вот это вот два амперсанта,
[33:59.020 --> 34:02.020]  ему нужно будет, так или иначе все типы проинстанцируются.
[34:02.020 --> 34:05.020]  Вот, поэтому короткой логики тут не произойдет.
[34:09.020 --> 34:11.020]  Так, есть ли тут вопрос?
[34:13.020 --> 34:14.020]  Хорошо.
[34:14.020 --> 34:16.020]  Так, ну, примеры применения.
[34:16.020 --> 34:20.020]  Да, кстати, вот хороший слайд про примеры применения.
[34:20.020 --> 34:26.020]  Смотрите, помните, когда мы говорили про вариативные шаблоны,
[34:26.020 --> 34:30.020]  у нас там была функция суммы, и мы там столкнулись с проблемой,
[34:30.020 --> 34:36.020]  в которой мы хотели написать функцию суммы, которая складывает несколько значений.
[34:36.020 --> 34:38.020]  Но при этом мы не смогли никак, ну, допустим, вот, представьте,
[34:38.020 --> 34:40.020]  я хочу написать шаблонную функцию сам,
[34:40.020 --> 34:42.020]  которая умеет складывать только целые числа.
[34:42.020 --> 34:45.020]  Но если я напишу вариабельный шаблон,
[34:45.020 --> 34:48.020]  то тогда функция суммы сможет принимать вообще какие угодно параметры.
[34:48.020 --> 34:51.020]  Я вообще никак не мог, по крайней мере, на тот момент,
[34:51.020 --> 34:53.020]  проверить, что все типы действительно являются интами.
[34:53.020 --> 34:55.020]  Вот вот как я могу это сделать.
[34:55.020 --> 34:59.020]  Я могу написать template class int, то есть просто назвать пакет параметров int.
[34:59.020 --> 35:01.020]  Понятно дело, что это никак не гарантирует то,
[35:01.020 --> 35:03.020]  что в пакет параметров int будут переданы инты.
[35:03.020 --> 35:06.020]  Понятно дело, что комплятору вообще плевать на то,
[35:06.020 --> 35:08.020]  как я называю пакет, как я называю аргументы и так далее.
[35:08.020 --> 35:11.020]  Но что я могу сделать? Я могу находиться внутри функции сам,
[35:11.020 --> 35:15.020]  вызвать определитель типа isSame.
[35:15.020 --> 35:18.020]  Ну, собственно, все те определители, которые я писал сейчас на слайдах,
[35:18.020 --> 35:21.020]  все те же самые определители есть в стандартной библиотеке.
[35:21.020 --> 35:23.020]  Ими можно активно пользоваться.
[35:23.020 --> 35:25.020]  То есть я могу написать isSame v.
[35:25.020 --> 35:28.020]  isSame v – это переменная, которая хранит тебе значение true или false,
[35:28.020 --> 35:30.020]  в зависимости от того, совпадает тип или нет.
[35:30.020 --> 35:35.020]  Я говорю, верно ли, что тип int совпадает с элементом пакета параметров int?
[35:35.020 --> 35:38.020]  Ну, и распаковываю его с помощью операции i.
[35:38.020 --> 35:43.020]  То есть я каждому типу из пакета параметров int сравниваю его с int.
[35:43.020 --> 35:47.020]  Если все параметры совпадают с int, то есть если первый параметр – это int,
[35:47.020 --> 35:50.020]  второй параметр – это int, третий параметр – это int,
[35:50.020 --> 35:53.020]  то, соответственно, возвращается true, и статическая проверка проходит.
[35:53.020 --> 35:55.020]  То есть проверка на этапе компиляции проходит успешно.
[35:55.020 --> 35:58.020]  Если же хотя бы один из типов пакета параметров не равен int,
[35:58.020 --> 36:01.020]  то тогда, понятно дело, тут какой-то isSame вернет false,
[36:01.020 --> 36:04.020]  ну и, соответственно, общее буллевское выражение будет false.
[36:04.020 --> 36:06.020]  Вот эта вот программа, точнее, вот эта вот функция,
[36:06.020 --> 36:08.020]  она вызовет ошибку в компиляции.
[36:08.020 --> 36:09.020]  Да.
[36:09.020 --> 36:13.020]  Если у нас у isSameV явное преимущество над isSame,
[36:13.020 --> 36:16.020]  или есть ли это частота, когда его иногда используют?
[36:16.020 --> 36:21.020]  Нет, у isSameV есть преимущество, которое состоит в том,
[36:21.020 --> 36:25.020]  что isSameV – это переменная, и у нее не нужно прописывать 2.2.value.
[36:25.020 --> 36:27.020]  А как это вы делали?
[36:27.020 --> 36:30.020]  Не делали два варианта, просто исторически так сложилось,
[36:30.020 --> 36:33.020]  что в шаблонных переменах появились только все плюс 17.
[36:33.020 --> 36:35.020]  Раньше не было шаблонов переменных,
[36:35.020 --> 36:38.020]  поэтому нужно было постоянно прописывать это 2.2.value.
[36:38.020 --> 36:40.020]  После того, как появились шаблоны переменных,
[36:40.020 --> 36:43.020]  теперь можно использовать не класс, а можно использовать переменную,
[36:43.020 --> 36:45.020]  которая делает, по сути, то же самое.
[36:48.020 --> 36:51.020]  На самом деле то, что метафункции принимают тип, а не значение,
[36:51.020 --> 36:53.020]  это как раз наследие старых стандартов,
[36:53.020 --> 36:57.020]  потому что если функция может принимать тип,
[36:57.020 --> 37:01.020]  то она также может принимать и константное выражение, то есть само значение.
[37:01.020 --> 37:03.020]  В целом, да.
[37:10.020 --> 37:12.020]  Второй пример, который показывает,
[37:12.020 --> 37:15.020]  он показывает то, что, допустим, у меня есть какая-то функция,
[37:15.020 --> 37:18.020]  которая работает с некоторой последовательностью значений.
[37:18.020 --> 37:22.020]  Например, у меня есть функция, которая может принимать на вход массив,
[37:22.020 --> 37:24.020]  причем массив произвольного типа.
[37:24.020 --> 37:28.020]  Он может принимать либо вектор, либо указатель на выделенную память.
[37:28.020 --> 37:31.020]  Понятное дело, что если я, допустим, передаю функцию вектор,
[37:31.020 --> 37:33.020]  то вектор уничтожится автоматически.
[37:36.020 --> 37:39.020]  Если же я передал просто обычный указатель на динамическую выделенную память,
[37:39.020 --> 37:41.020]  то мне нужно для этого типа вызвать delete.
[37:41.020 --> 37:45.020]  То есть как я могу проверить, нужно ли вызвать delete для этого массива или нет?
[37:45.020 --> 37:48.020]  Я, собственно, могу просто написать определить типа std isPointer,
[37:48.020 --> 37:52.020]  и если, действительно, в качестве storage или в качестве массива
[37:52.020 --> 37:54.020]  мне передали просто обычный указатель,
[37:54.020 --> 37:56.020]  то значит, указатель на динамически выделенные данные,
[37:56.020 --> 37:58.020]  я, соответственно, могу вызвать delete.
[37:58.020 --> 38:00.020]  Если же в качестве storage мне передали не указатель,
[38:00.020 --> 38:02.020]  ну а, допустим, какой-нибудь вектор,
[38:02.020 --> 38:04.020]  то есть вообще все что угодно, но не указатель,
[38:04.020 --> 38:06.020]  то я delete не вызываю, пропускаю просто эту строчку.
[38:06.020 --> 38:08.020]  Окей?
[38:08.020 --> 38:10.020]  Хорошо.
[38:10.020 --> 38:12.020]  Да, кстати, тут такой вопрос надо подумать.
[38:12.020 --> 38:18.020]  Почему я в этой строчке написал вот так?
[38:18.020 --> 38:20.020]  Так.
[38:20.020 --> 38:22.020]  Delete квадратной скобки адрес.
[38:30.020 --> 38:32.020]  Нет, ну, смотрите,
[38:32.020 --> 38:38.020]  ну, посмотрите, почему бы мне не написать просто delete storage?
[38:38.020 --> 38:42.020]  Ну, смотрите, я же вроде как в эфе проверил, что это указатель,
[38:42.020 --> 38:46.020]  а если это указатель, то я могу по этому указателю вызвать delete.
[38:46.020 --> 38:48.020]  В чем проблема?
[38:50.020 --> 38:54.020]  Так, а если это не указатель, то что тогда?
[39:00.020 --> 39:02.020]  Ну вот, смотрите,
[39:02.020 --> 39:06.020]  если у меня storage является указателем,
[39:06.020 --> 39:08.020]  то тогда я захожу внутрь delete,
[39:08.020 --> 39:12.020]  и у меня может выполниться вот такой код.
[39:12.020 --> 39:14.020]  А если у меня storage не является указателем,
[39:14.020 --> 39:16.020]  то я внутрь этого ифа не зайду.
[39:16.020 --> 39:18.020]  Вот.
[39:18.020 --> 39:20.020]  Ну, тогда спрашивается, зачем я пишу вот так?
[39:20.020 --> 39:22.020]  Зачем я себе усложняю жизнь?
[39:22.020 --> 39:24.020]  Если storage это указатель,
[39:24.020 --> 39:26.020]  то вот эта запись, это ровно то же самое, что и вот эта.
[39:26.020 --> 39:30.020]  Но почему я предпочитаю вызвать вот это, а не вот это?
[39:30.020 --> 39:32.020]  И вот тут есть один принципиальный момент.
[39:32.020 --> 39:34.020]  Смотрите, на самом деле,
[39:34.020 --> 39:38.020]  представьте себе следующую картину.
[39:38.020 --> 39:40.020]  Представьте, что в качестве storage я передал вектор.
[39:40.020 --> 39:42.020]  Так?
[39:42.020 --> 39:44.020]  Если я в качестве storage передал вектор,
[39:44.020 --> 39:46.020]  то компилятору, понятное дело,
[39:46.020 --> 39:48.020]  нужно все равно скомпилировать все строчки.
[39:48.020 --> 39:50.020]  Ему нужно проверить все строчки на корректность.
[39:50.020 --> 39:52.020]  Понятно?
[39:52.020 --> 39:54.020]  То есть, если бы я в качестве storage передал вектор,
[39:54.020 --> 39:58.020]  то компилятор бы увидел, что я хулиган.
[39:58.020 --> 40:02.020]  Он увидел бы, что я вызываю delete для вектора.
[40:02.020 --> 40:04.020]  Можно ли вызывать delete для вектора?
[40:04.020 --> 40:06.020]  Нет.
[40:06.020 --> 40:08.020]  Delete можно вызывать только для указателя.
[40:08.020 --> 40:10.020]  А если storage — это вектор, а не указатель,
[40:10.020 --> 40:14.220]  строчка приведет к ошибке компиляции. Понятно?
[40:16.700 --> 40:21.100]  Нет, смотрите какая история. Представьте себе, что вот тут в качестве шаблонного
[40:21.100 --> 40:25.940]  параметра storage я подставляю вектор. То есть компилятор берет сюда, подставляет
[40:25.940 --> 40:29.300]  вектор и начинает компилировать эту функцию. Предполагаю, что storage это вектор.
[40:29.300 --> 40:34.260]  Да, и в любом случае, понятно, что компилятор не знает вот это из pointer
[40:34.260 --> 40:38.740]  true или false, и он в любом случае зайдет вот в эту ветку if и
[40:38.740 --> 40:43.300]  попытается скомпилировать эту строчку. Точнее, вот эту строчку, да?
[40:43.300 --> 40:46.940]  Но вот эту строчку у него скомпилировать не получится, почему? Потому что delete нельзя вызвать для вектора.
[40:46.940 --> 40:51.780]  Delete можно вызвать только для указателя. Поэтому, чтобы убедиться, что
[40:51.780 --> 40:55.500]  справа delete всегда будет стоять указатель, я просто-апросто подстану вот так.
[40:55.500 --> 40:58.900]  То есть я как бы обманываю компилятор. Что как бы, хей, смотри, тут на самом деле указатель.
[40:58.900 --> 41:03.380]  И при этом я не говорю ему о том, что на самом деле ты строчки никогда в
[41:03.380 --> 41:05.380]  жизни не найдешь, в случае вектора.
[41:05.380 --> 41:07.380]  Да.
[41:07.380 --> 41:15.380]  В целом, да, на самом деле мы по-нормальному решим этот вопрос, когда поговорим про if-const export.
[41:15.380 --> 41:18.380]  На самом деле какие-то ветки можно компилировать, какие-то ветки можно не компилировать.
[41:18.380 --> 41:24.380]  Но вот если мы используем обычный if, то такое, к сожалению, необходимо, к сожалению, прописывать.
[41:24.380 --> 41:29.380]  Давайте продолжим обсуждение следующей проблемы. Смотрите.
[41:29.380 --> 41:35.380]  Чего бы я хотел? Смотрите, вот код, который написан ниже, он говорит следующее.
[41:35.380 --> 41:37.380]  Вот представь себе следующую картину, да, снова.
[41:37.380 --> 41:43.380]  Я передаю массив, но я передаю динамический массив в функцию процесс индестрой.
[41:43.380 --> 41:49.380]  Эта функция процесс индестрой, она каким-то образом обрабатывает этот самый динамический массив, да,
[41:49.380 --> 41:51.380]  но и в конце его уничтожает. Смотрите.
[41:51.380 --> 41:56.380]  Если в эту функцию я передам динамический массив в виде вектора, да, то понятно дело, что для вектора
[41:56.380 --> 42:00.380]  автоматически вызовется деструктор, то есть мне не нужно об этом задумываться.
[42:00.380 --> 42:06.380]  Если же в эту функцию я передам указатель на динамическую выделенную память, то мне необходимо будет вызвать дилит.
[42:06.380 --> 42:10.380]  В связи с тем, что я говорил до этого, кажется, что логично написать вот такой код.
[42:10.380 --> 42:17.380]  Смотрите, что я говорю. Если вот этот тип, если шаблонный параметр является указателем,
[42:17.380 --> 42:24.380]  то значит для этой переменной, storage с маленькой буквы, необходимо вызвать дилит.
[42:24.380 --> 42:29.380]  Если же storage не является указателем, то значит это вектор, но раз это вектор, то, соответственно,
[42:29.380 --> 42:32.380]  для него дилит вызывать не нужно. Но в чем проблема?
[42:32.380 --> 42:37.380]  Проблема в том, что если я попытаюсь скомпилировать вот этот код с параметром vector,
[42:37.380 --> 42:42.380]  у меня пройдет ошибка компиляции. Еще раз, почему пройдет ошибка компиляции?
[42:42.380 --> 42:47.380]  Потому что компилятор, когда представляет шаблонные параметры, он компилирует весь код целиком.
[42:47.380 --> 42:53.380]  То есть даже если я нахожусь, то понятно, что компилятор должен скомпилировать вообще все возможные ветки.
[42:53.380 --> 42:57.380]  То есть он компилирует if и он компилирует все, что находится внутри if.
[42:57.380 --> 43:01.380]  Но если у меня в качестве storage, если у меня в качестве переменной storage выступает вектор,
[43:01.380 --> 43:04.380]  то понятное дело, что для вектора дилит я вызвать никак не могу.
[43:04.380 --> 43:06.380]  И вот в этот момент пройдет ошибка компиляции.
[43:06.380 --> 43:12.380]  Понятно? То есть вот эта проверка происходит на этапе исполнения программы, а не этапе компиляции.
[43:12.380 --> 43:18.380]  То есть компилятор не может понять, что на самом деле внутрь этой ветки if я никогда не зайду,
[43:18.380 --> 43:20.380]  и поэтому эту ветку можно не компилировать.
[43:20.380 --> 43:24.380]  С точки зрения стандарта компилятор обязан скомпинировать все возможные ветки исполнения.
[43:24.380 --> 43:26.380]  Понятно?
[43:26.380 --> 43:28.380]  Как решить эту проблему? И можно ли ее решить?
[43:28.380 --> 43:34.380]  То есть, смотрите, очевидно, что вот это вот условие проверяемо на этапе компиляции. Согласны?
[43:34.380 --> 43:40.380]  Ну то есть компилятор, вообще говоря, может понять, является ли этот тип указательным или нет на этапе компиляции.
[43:40.380 --> 43:44.380]  То есть на этапе компиляции, то есть понятное дело, что на этапе компиляции происходит подстановка шаблонных параметров.
[43:44.380 --> 43:47.380]  То есть на этапе компиляции компилятор понимает, что скажем, это вектор.
[43:47.380 --> 43:51.380]  Раз он на этапе компиляции понимает, что это вектор, то он может шаблонные параметры подставить внутрь этого шаблона,
[43:51.380 --> 43:54.380]  но внутри этого шаблона будет храниться соответствующее значение, true или false.
[43:54.380 --> 43:58.380]  То есть понятное дело, что все эти операции компилятор может сделать на этапе компиляции.
[43:58.380 --> 44:02.380]  Поэтому на этапе компиляции он может понять, что вот эта ветка, в принципе, будет бесполезна.
[44:02.380 --> 44:04.380]  Да?
[44:04.380 --> 44:09.380]  Как заставить компилятор отбрасывать некоторые ветки исполнения в зависимости от некоторых условий?
[44:09.380 --> 44:13.380]  Давайте познакомимся с конструкцией, которая называется if constexpr.
[44:13.380 --> 44:15.380]  Что такое if constexpr?
[44:16.380 --> 44:19.380]  If constexpr, ну, собственно, тут мы описали проблему.
[44:19.380 --> 44:26.380]  Так вот, чтобы решить эту проблему, необходимо написать if constexpr.
[44:26.380 --> 44:32.380]  Вот тут, к сожалению, есть небольшая путаница.
[44:32.380 --> 44:36.380]  То есть, на самом деле, if constexpr, на мой взгляд, не совсем удачное название.
[44:36.380 --> 44:40.380]  Почему? Потому что кажется, что if constexpr проверяет, что правда ли,
[44:40.380 --> 44:42.380]  что выражение, которое находится в скобках, является константным выражением.
[44:42.380 --> 44:44.380]  На самом деле, не так.
[44:44.380 --> 44:48.380]  На самом деле, if constexpr, это такой, 입ка, которая работает на этапе компиляции.
[44:48.380 --> 44:52.380]  Смотрите, if constexpr обязательно должен принимать условия,
[44:52.380 --> 44:55.380]  которые проверяемы на этапе компиляции, вот.
[44:55.380 --> 44:58.380]  То есть, если обычное if проверяется на этапе исполнения программы,
[44:58.380 --> 45:01.380]  то есть, когда программа уже завелась и работает, вот,
[45:01.380 --> 45:05.380]  то if constexpr работает еще на этапе котлована,
[45:05.380 --> 45:07.380]  на этапе запущенного программа.
[45:07.380 --> 45:11.380]  То есть, программа компилируется, и компилятор проверяет вот это условие
[45:11.380 --> 45:12.380]  на этапе компиляции.
[45:12.380 --> 45:17.180]  условия истина, то он компилирует эту ветку. Если условие не истинно, то он просто на нее
[45:17.180 --> 45:23.640]  полностью забивает. Понятно? Вот. То есть if-constexpr, на самом деле, скорее грамотнее будет
[45:23.640 --> 45:28.860]  называть constexpr. if, да, то есть if, который работает на этапе компиляции. Вот. Ну, давайте посмотрим,
[45:28.860 --> 45:33.580]  ну, собственно, как это решает проблему. Решает эту проблему следующим образом. Если мне в качестве
[45:33.580 --> 45:37.980]  storage передали им-то указатель, ну нет, просто какой-то указатель, указатель динамическую выделенную
[45:37.980 --> 45:43.860]  память. Тогда if-constexpr проверяет, верно ли, что это указатель, значит, компилятор понимает,
[45:43.860 --> 45:48.540]  что да, это указатель, поэтому он оставляет эту ветку, точнее он оставляет этот код внутри
[45:48.540 --> 45:54.180]  функции, да, то есть он оставляет код delete storage. Вот. Если же, если же в качестве storage я передам
[45:54.180 --> 46:00.940]  вектор, то компилятор видит, что if-pointer от vector равно false, а значит, вот это if, проверка вот этого
[46:00.940 --> 46:06.620]  if-a не проходит, а значит, вот эту ветку можно, в принципе, не компилировать, что компилятор и
[46:06.620 --> 46:13.260]  делает, понятно? То есть if-constexpr позволяет либо включать какой-то код в зависимости
[46:13.260 --> 46:17.100]  от некоторого условия, либо не включать код в зависимости от некоторого условия, понятно?
[46:17.100 --> 46:24.420]  Окей! То есть я могу управлять кодой генерации с помощью constexpr, в зависимости от каких-то условий
[46:24.420 --> 46:28.500]  я могу говорить, что вот это надо компилировать, или в зависимости от этого условия могу сказать,
[46:28.500 --> 46:36.180]  что вот это компилировать мне нужно. Вот. Окей. Ну и смотрите,
[46:36.180 --> 46:41.060]  как это может помочь нам на практике?
[46:41.060 --> 46:44.000]  Например, это может нам помочь при работе с итераторами.
[46:44.000 --> 46:46.760]  Например, когда вы говорили про итераторы,
[46:46.760 --> 46:49.020]  я думаю, вы говорили про специальные функции,
[46:49.020 --> 46:53.060]  которые имеют работу с итераторами.
[46:53.060 --> 46:55.400]  Например, я хочу управлять итератором на n шагов вперед.
[46:55.400 --> 46:58.740]  Понятно, что если это итератор random access, то я должен просто делать plus равно n.
[46:58.740 --> 47:03.920]  Если это итератор просто forward итератор, то я должен n раз вызвать plus plus итератор.
[47:03.920 --> 47:08.320]  Так вот, как функции наподобие advance или next
[47:08.320 --> 47:13.040]  понимают, какие операции нужно выполнять.
[47:13.040 --> 47:14.600]  В общем, это можно сделать так.
[47:14.600 --> 47:18.720]  Допустим, я хочу по итератору получить элемент под номером n.
[47:18.720 --> 47:20.760]  Что я сделаю? Во-первых, я извлекаю тег,
[47:20.760 --> 47:24.600]  какой это итератор с помощью класса iterator.trade иterator.category.
[47:24.600 --> 47:29.440]  Этот тег хранит для себя либо bidirectional итератор, либо random access итератор.
[47:29.640 --> 47:34.140]  В контекст я проверяю, верно ли что мой тег, это random access,
[47:34.140 --> 47:38.340]  corner mixes итератор. Если тег наследован от random access итератора,
[47:38.340 --> 47:40.760]  Onu значит мой итератор является random access, а если
[47:40.760 --> 47:44.080]  итератор является random access, то я соответственно могу сделать return итератор от n.
[47:44.080 --> 47:47.580]  И при этом этот один итератор появляется только в
[47:47.580 --> 47:49.700]  том случае, если итератор действительно является random access.
[47:49.700 --> 47:52.000]  Если итератор не является random access, то этот итератор не будет
[47:52.000 --> 47:57.440]  компилирован. То есть этот итератор просто libreствует компилятор и направляется на sixteen и ISC.
[47:57.440 --> 47:59.440]  И также я могу написать ветку else.
[47:59.440 --> 48:02.940]  Тут важно еще понимать, что если я для ifConstExport написал ветку else,
[48:02.940 --> 48:04.940]  то ветка else тоже работает в constExport.
[48:04.940 --> 48:06.940]  То есть ветка else тоже разрешает сетапь компиляции.
[48:06.940 --> 48:08.940]  То есть если я написал ветку else, то она в зависимости от условий
[48:08.940 --> 48:11.940]  либо компилируется, либо не компилируется.
[48:11.940 --> 48:14.940]  То есть если на самом деле у меня итератор не удовлетворяет
[48:14.940 --> 48:19.940]  условию random access, то я использую вот такой обычный цикл while.
[48:19.940 --> 48:21.940]  Просто продвигаю вперед итератор на 1 шагу вперед
[48:21.940 --> 48:23.940]  и возвращаю разуменованный итератор.
[48:23.940 --> 48:25.940]  То есть в зависимости от того, является ли итератор random access или нет,
[48:26.440 --> 48:28.440]  я использую либо операцию квадратной скобки.
[48:28.440 --> 48:30.440]  Если же операция квадратной скобки не примема к итератору,
[48:30.440 --> 48:33.440]  то я применяю обычное продвижение итератора с помощью plus-plus
[48:33.440 --> 48:35.440]  и его разуменование.
[48:35.440 --> 48:37.440]  Понятно?
[48:37.440 --> 48:39.440]  Да.
[48:39.940 --> 48:41.940]  Ага.
[48:51.940 --> 48:53.940]  Нет, смотрите, у вас...
[48:53.940 --> 48:55.940]  Цикл работает на этапе...
[48:55.940 --> 48:57.940]  Цикл работает на этапе исполнения.
[48:57.940 --> 48:59.940]  Если у вас внутри цикла написан if constexpr,
[48:59.940 --> 49:03.940]  то есть цикл for какой-то,
[49:03.940 --> 49:07.940]  и внутри for'ика у вас стоит if constexpr.
[49:08.440 --> 49:10.440]  if constexpr.
[49:12.440 --> 49:14.440]  Ну, смотрите, очевидно, что вот это условие
[49:14.440 --> 49:18.440]  никак не может зависеть от итерации цикла for.
[49:18.440 --> 49:20.440]  Потому что вот это условие
[49:20.440 --> 49:22.440]  должно проявляться на этапе компиляции.
[49:22.440 --> 49:24.440]  На этапе компиляции у меня, вообще говоря,
[49:24.440 --> 49:26.440]  ну, я не могу там сказать, что там...
[49:26.440 --> 49:28.440]  Что там предстоит переиром, ну, хотя...
[49:28.440 --> 49:30.440]  Нет, не могу. Да, я не могу говорить,
[49:30.440 --> 49:32.440]  что должно предстоить переиром на нулю и так далее.
[49:32.440 --> 49:34.440]  Поэтому вот это if constexpr выполняется вообще
[49:34.440 --> 49:36.440]  для всех итераций цикла.
[49:36.440 --> 49:38.440]  Важно понимать, что вот это условие...
[49:38.440 --> 49:40.440]  Я не могу сюда прописать условие,
[49:40.440 --> 49:42.440]  которое будет зависеть от параметров цикла.
[49:42.440 --> 49:44.440]  Потому что параметры цикла будут работать
[49:44.440 --> 49:46.440]  только на этапе исполнения программы.
[49:48.940 --> 49:50.940]  Так. Окей.
[49:50.940 --> 49:53.940]  Поговорили про определители типов.
[49:53.940 --> 49:55.940]  То есть мы поговорили про то, как
[49:55.940 --> 49:57.940]  понимать, какими свойствами тип обладает,
[49:57.940 --> 49:59.940]  какими свойствами тип не обладает,
[49:59.940 --> 50:01.940]  проверять, допустим, является ли тип константой,
[50:01.940 --> 50:03.940]  ссылкой и так далее.
[50:03.940 --> 50:05.940]  И самое главное, как это можно применить на практике.
[50:06.440 --> 50:08.440]  С помощью использования if constexpr
[50:08.440 --> 50:10.440]  и в зависимости от каких-то условий.
[50:10.440 --> 50:12.440]  То есть, допустим, если тип константный,
[50:12.440 --> 50:14.440]  то я хочу, чтобы код содержал,
[50:14.440 --> 50:16.440]  чтобы код работал одним образом.
[50:16.440 --> 50:18.440]  Если тип не константный,
[50:18.440 --> 50:20.440]  я хочу, чтобы код работал другим образом.
[50:20.440 --> 50:22.440]  С помощью if constexpr я могу это организовать.
[50:22.440 --> 50:24.440]  Теперь давайте поговорим про модификаторы типов.
[50:24.440 --> 50:26.440]  То есть, что если я хочу
[50:26.440 --> 50:28.440]  переданный в, не знаю,
[50:28.440 --> 50:30.440]  допустим, шаблонную функцию параметр
[50:30.440 --> 50:32.440]  как-то видоизменить?
[50:32.440 --> 50:34.440]  Давайте про это...
[50:34.440 --> 50:36.440]  Давайте про это поговорим.
[50:36.440 --> 50:38.440]  Что такое модификатор типа?
[50:38.440 --> 50:40.440]  Ну, модификатор типа, как я уже сказал,
[50:40.440 --> 50:42.440]  позволяет изменить переданный навход тип.
[50:42.440 --> 50:44.440]  Ну, например, представь тебе,
[50:44.440 --> 50:46.440]  что мне передается навход некоторое...
[50:46.440 --> 50:48.440]  Давайте вот конкретный пример.
[50:48.440 --> 50:50.440]  CreateCopy.
[50:50.440 --> 50:52.440]  Смотрите, у меня есть функция CreateCopy,
[50:52.440 --> 50:54.440]  которая принимает на вход массив,
[50:54.440 --> 50:56.440]  массив, т.е. рей,
[50:56.440 --> 50:58.440]  размера n.
[50:58.440 --> 51:00.440]  Что я делаю?
[51:00.440 --> 51:02.440]  Я хочу создать массив той же длины
[51:02.440 --> 51:04.440]  и скопировать все элементы массива r8
[51:04.440 --> 51:06.440]  вот в новую созданную копию.
[51:06.440 --> 51:08.440]  И вернуть саму копию. В чем проблема?
[51:08.440 --> 51:10.440]  В чем проблема? Смотрите.
[51:16.440 --> 51:18.440]  CreateCopy.
[51:18.440 --> 51:20.440]  CreateCopy т.с.
[51:20.440 --> 51:22.440]  а, ну, допустим, n.
[51:26.440 --> 51:28.440]  Ну, и тут шаблонный параметр, класс.
[51:28.440 --> 51:30.440]  Смотрите, в чем проблема?
[51:30.440 --> 51:32.440]  Если я просто возьму
[51:32.440 --> 51:34.440]  и напишу
[51:34.440 --> 51:36.440]  autocopy
[51:36.440 --> 51:38.440]  равно
[51:38.440 --> 51:40.440]  nu t
[51:40.440 --> 51:42.440]  от n,
[51:42.440 --> 51:44.440]  то возникнет проблема следующего рода.
[51:44.440 --> 51:46.440]  Когда я начну копировать все элементы
[51:46.440 --> 51:48.440]  из a в копии, ну, допустим,
[51:48.440 --> 51:50.440]  с помощью цикла, да,
[51:50.440 --> 51:52.440]  pour int i равно 0,
[51:52.440 --> 51:54.440]  i меньше чем n,
[51:54.440 --> 51:56.440]  плюс-плюс i.
[51:56.440 --> 51:58.440]  Вот, если я начну копировать и напишу вот так
[51:58.440 --> 52:02.440]  copy от i равно i,
[52:02.440 --> 52:04.440]  то возникнет следующая проблема.
[52:04.440 --> 52:06.440]  Представьте себе, что в качестве шаблона параметра t
[52:06.440 --> 52:08.440]  мне передали const.
[52:08.440 --> 52:10.440]  Мне передали const int.
[52:10.440 --> 52:12.440]  Ну, представьте, у меня есть, допустим,
[52:12.440 --> 52:14.440]  есть массив constant,
[52:14.440 --> 52:16.440]  и я этот массив constant передаю функцию
[52:16.440 --> 52:18.440]  createCopy, и, соответственно,
[52:18.440 --> 52:20.440]  в качестве шаблона параметра t, допустим,
[52:20.440 --> 52:22.440]  вводится тип const int.
[52:22.440 --> 52:24.440]  К чему это приведет?
[52:24.440 --> 52:26.440]  Это приведет к тому, что, когда я попытаюсь
[52:26.440 --> 52:28.440]  вызвать new от const int,
[52:28.440 --> 52:30.440]  что в этом случае произойдет?
[52:30.440 --> 52:32.440]  Ну, на самом деле произойдет ошибка компиляции,
[52:32.440 --> 52:34.440]  да, почему?
[52:34.440 --> 52:36.440]  Потому что константы я не могу создавать по умолчанию,
[52:36.440 --> 52:38.440]  то есть я не могу создать массив
[52:38.440 --> 52:40.440]  constant, не задавая им никаких начали значений.
[52:40.440 --> 52:42.440]  То есть вот эта строчка даже не скомпилируется.
[52:42.440 --> 52:44.440]  То есть написать new
[52:44.440 --> 52:46.440]  const int
[52:46.440 --> 52:48.440]  от n нельзя.
[52:48.440 --> 52:50.440]  Вот. То есть возникает проблема,
[52:50.440 --> 52:52.440]  да, проблема, которая состоит с чем?
[52:52.440 --> 52:54.440]  Если в качестве параметра t мне передали
[52:54.440 --> 52:56.440]  какой-то const int, я хочу, чтобы при создании массива
[52:56.440 --> 52:58.440]  этот const исчез.
[52:58.440 --> 53:00.440]  Понятно?
[53:00.440 --> 53:02.440]  Ну, смотрите, вот если тип содержит константу,
[53:02.440 --> 53:04.440]  то я хочу вот тут написать такой тип,
[53:04.440 --> 53:06.440]  который константы не содержит.
[53:06.440 --> 53:08.440]  Вопрос. Ну, вот смотрите, вот у вас есть тип t.
[53:08.440 --> 53:10.440]  Вот. У вас есть тип t.
[53:10.440 --> 53:12.440]  И вам известно, что
[53:12.440 --> 53:14.440]  в нем содержится константа.
[53:14.440 --> 53:16.440]  Как эту константу можно убрать,
[53:16.440 --> 53:18.440]  ну, просто написав какой-нибудь обычный код?
[53:18.440 --> 53:20.440]  Есть идеи?
[53:20.440 --> 53:22.440]  Ну, кажется, что нет, да, потому что если const включен
[53:22.440 --> 53:24.440]  в тип t, то он там содержит просто
[53:24.440 --> 53:26.440]  обстановечно. Тип t он такой вот
[53:26.440 --> 53:28.440]  в общем, такой
[53:28.440 --> 53:30.440]  единый тип, неделимый, из которого
[53:30.440 --> 53:32.440]  никак нельзя вытащить слово const.
[53:32.440 --> 53:34.440]  Так вот, чтобы
[53:34.440 --> 53:36.440]  исправить тип t, чтобы из типа t получить
[53:36.440 --> 53:38.440]  некоторый другой тип, который конст не содержит,
[53:38.440 --> 53:40.440]  можно воспользоваться модификатором типа.
[53:40.440 --> 53:42.440]  И тоже на основе
[53:42.440 --> 53:44.440]  частительной специализации.
[53:44.440 --> 53:46.440]  Давайте посмотрим на пример сверху.
[53:46.440 --> 53:48.440]  Что я делаю?
[53:48.440 --> 53:50.440]  Ну, как обычно, я прописываю
[53:50.440 --> 53:52.440]  общий шаблон, называю его
[53:52.440 --> 53:54.440]  removeConst, который принимает
[53:54.440 --> 53:56.440]  произвольный шаблонный параметр t. И что я делаю?
[53:56.440 --> 53:58.440]  Смотрите, внутри этого шаблонного класса
[53:58.440 --> 54:00.440]  я прописываю шаблонный
[54:00.440 --> 54:02.440]  псевдоним type равно t.
[54:02.440 --> 54:04.440]  Ну, помните, что такое шаблонный псевдоним using type
[54:04.440 --> 54:06.440]  равно t. Ну, я просто нам
[54:06.440 --> 54:08.440]  создаю псевдоним, который доступен
[54:08.440 --> 54:10.440]  через имя этого класса.
[54:10.440 --> 54:12.440]  То есть, я внутри removeConst
[54:12.440 --> 54:14.440]  создаю новый тип, который называю type,
[54:14.440 --> 54:16.440]  и этот тип полностью совпадает с t.
[54:16.440 --> 54:18.440]  Что это означает? Это означает, что в общем случае
[54:18.440 --> 54:20.440]  я предполагаю, что
[54:20.440 --> 54:22.440]  на типе t нет
[54:22.440 --> 54:24.440]  никакой константности. Если на типе t
[54:24.440 --> 54:26.440]  нет никакой константности, то значит
[54:26.440 --> 54:28.440]  снять константность типа t
[54:28.440 --> 54:30.440]  то же самое, что и тип t.
[54:30.440 --> 54:32.440]  А далее я прописываю специализацию
[54:32.440 --> 54:34.440]  конкретно для случаев, когда тип удовлетворяет
[54:34.440 --> 54:36.440]  соотношению const t. Вот если мне в removeConst
[54:36.440 --> 54:38.440]  передали что-то похожее на const t,
[54:38.440 --> 54:40.440]  то это означает, что в качестве
[54:40.440 --> 54:42.440]  шаблонного псевдонима
[54:42.440 --> 54:44.440]  внутри removeConst я прописываю using type равно t.
[54:44.440 --> 54:46.440]  То есть, если мне передали нечто, что похоже
[54:46.440 --> 54:48.440]  на const t, то тип, который хранится
[54:48.440 --> 54:50.440]  внутри removeConst не должен содержать
[54:50.440 --> 54:52.440]  этого самого конста. Понятно?
[54:52.440 --> 54:54.440]  Да.
[54:54.440 --> 54:56.440]  А почему это не отвечает
[54:56.440 --> 54:58.440]  от работы const cast?
[54:58.440 --> 55:00.440]  Потому что const cast
[55:00.440 --> 55:02.440]  он... погодите.
[55:02.440 --> 55:04.440]  const cast работает только с указателями
[55:04.440 --> 55:06.440]  и ссылками. То есть const cast
[55:06.440 --> 55:08.440]  может добавить конст либо указатель,
[55:08.440 --> 55:10.440]  либо к ссылкам. К произвольным типам
[55:10.440 --> 55:12.440]  с произвольным типом const cast не работает.
[55:12.440 --> 55:14.440]  Ну и плюс,
[55:14.440 --> 55:16.440]  какой const cast нужно написать тут,
[55:16.440 --> 55:18.440]  чтобы это сработало?
[55:18.440 --> 55:20.440]  Ну, непонятно.
[55:20.440 --> 55:22.440]  Ну, короче,
[55:22.440 --> 55:24.440]  const cast, чтобы сделать const cast
[55:24.440 --> 55:26.440]  вам нужно явно указать тип, которым вы приводите.
[55:26.440 --> 55:28.440]  А как сказать, что тип t
[55:28.440 --> 55:30.440]  не должен содержать константу? Ну, кажется, никак.
[55:30.440 --> 55:32.440]  Вот.
[55:32.440 --> 55:34.440]  Ну и смотрите, как это работает. Теперь вместо того,
[55:34.440 --> 55:36.440]  чтобы вызывать new от t,
[55:36.440 --> 55:38.440]  вместо того, чтобы вызывать new от t,
[55:38.440 --> 55:40.440]  я вызываю new от
[55:40.440 --> 55:42.440]  removeConst от t.
[55:42.440 --> 55:44.440]  Двоеточие, двоеточие type. Я пишу
[55:44.440 --> 55:46.440]  removeConst от t, двоеточие, двоеточие type.
[55:46.440 --> 55:48.440]  И таким образом что получается?
[55:48.440 --> 55:50.440]  Если в removeConst мне подается на вход
[55:50.440 --> 55:52.440]  const int. Что происходит?
[55:52.440 --> 55:54.440]  Ну, removeConst понимает, что ему
[55:54.440 --> 55:56.440]  был передан const int.
[55:56.440 --> 55:58.440]  Дальше он видит, что под const int подходит частичная специализация
[55:58.440 --> 56:00.440]  const t. Соответственно, в качестве параметра
[56:00.440 --> 56:02.440]  t для частичной специализации выводится тип int.
[56:02.440 --> 56:04.440]  И поэтому в
[56:04.440 --> 56:06.440]  параметре
[56:06.440 --> 56:08.440]  типе type содержится
[56:08.440 --> 56:10.440]  значение int. И поэтому, когда я пишу
[56:10.440 --> 56:12.440]  removeConst от t, двоеточие, двоеточие type,
[56:12.440 --> 56:14.440]  вместо этого removeConst от const int
[56:14.440 --> 56:16.440]  подставится int. И таким образом я создам
[56:16.440 --> 56:18.440]  массив int, который можно изменять.
[56:18.440 --> 56:20.440]  Понятно?
[56:20.440 --> 56:22.440]  То есть таким образом вместо
[56:22.440 --> 56:24.440]  removeConst от t, двоеточие, двоеточие type
[56:24.440 --> 56:26.440]  подставится тип, который не содержит const.
[56:26.440 --> 56:28.440]  Причем на этапе компиляции
[56:28.440 --> 56:30.440]  я смог получить тип, который константности не содержит.
[56:30.440 --> 56:32.440]  Это понятно?
[56:32.440 --> 56:34.440]  Норм?
[56:34.440 --> 56:36.440]  Окей.
[56:36.440 --> 56:38.440]  Ну,
[56:38.440 --> 56:40.440]  собственно, упростим код
[56:40.440 --> 56:42.440]  ровно так же, как мы это делали в случае с
[56:42.440 --> 56:44.440]  определителями типов. В определитель
[56:44.440 --> 56:46.440]  типов мы использовали специальные типы
[56:46.440 --> 56:48.440]  стд trueType,
[56:48.440 --> 56:50.440]  стд falseType.
[56:50.440 --> 56:52.440]  Здесь я предлагаю использовать
[56:52.440 --> 56:54.440]  специальный тип typeIdentity, который просто
[56:54.440 --> 56:56.440]  хранит внутри себя
[56:56.440 --> 56:58.440]  параметры type
[56:58.440 --> 57:00.440]  равный t. То есть я просто в typeIdentity
[57:00.440 --> 57:02.440]  передаю какой-то тип t, и он хранит
[57:02.440 --> 57:04.440]  внутри себя псевдоним, который точно совпадает
[57:04.440 --> 57:06.440]  с шаблонным параметром.
[57:06.440 --> 57:08.440]  Тогда я могу removeConst унаследовать typeIdentity от t.
[57:08.440 --> 57:10.440]  Это будет означать, что removeConst будет содержать внутри себя
[57:10.440 --> 57:12.440]  type со значением t.
[57:12.440 --> 57:14.440]  И removeConst от constt унаследует
[57:14.440 --> 57:16.440]  typeIdentity от t. Это будет означать, что в нём
[57:16.440 --> 57:18.440]  будет содержаться псевдоним type,
[57:18.440 --> 57:20.440]  который точно совпадает с типом t.
[57:20.440 --> 57:22.440]  Ну, тип t, у которого я убрал слово const.
[57:24.440 --> 57:26.440]  Так. Ещё примеры
[57:26.440 --> 57:28.440]  модификаторов типов.
[57:28.440 --> 57:30.440]  Вот, например, модификатор типа
[57:30.440 --> 57:32.440]  removeReference. То есть, допустим, я хочу
[57:32.440 --> 57:34.440]  снова. Кстати, вот снова та же самая проблема может быть.
[57:34.440 --> 57:36.440]  Ну, кстати, ладно, тут
[57:36.440 --> 57:38.440]  такой проблемы, наверное, быть особо не может,
[57:38.440 --> 57:40.440]  потому что указателей
[57:40.440 --> 57:42.440]  на ссылку не существует. Ну, в целом,
[57:42.440 --> 57:44.440]  представьте себе, что я... Вот, представьте себе такую картину.
[57:44.440 --> 57:46.440]  Представьте себе
[57:48.440 --> 57:50.440]  вот такую историю.
[57:50.440 --> 57:52.440]  Я хочу написать функцию
[57:52.440 --> 57:54.440]  fill.
[57:58.440 --> 58:00.440]  Я хочу написать функцию template
[58:00.440 --> 58:02.440]  plus t,
[58:04.440 --> 58:06.440]  которая возвращает...
[58:06.440 --> 58:08.440]  Давайте, напишу тут auto,
[58:08.440 --> 58:10.440]  и назову её
[58:10.440 --> 58:12.440]  create
[58:12.440 --> 58:14.440]  and fill.
[58:14.440 --> 58:16.440]  И передам параметром tx.
[58:16.440 --> 58:18.440]  Что будет делать эта функция?
[58:18.440 --> 58:20.440]  Эта функция должна будет создать
[58:20.440 --> 58:22.440]  массив... Эта функция должна будет
[58:22.440 --> 58:24.440]  создать массив размера n,
[58:24.440 --> 58:26.440]  то есть тут int n,
[58:26.440 --> 58:28.440]  и заполнить его значениями типа x.
[58:28.440 --> 58:30.440]  Окей? Ну, что я могу написать?
[58:30.440 --> 58:32.440]  Я могу написать
[58:32.440 --> 58:34.440]  auto
[58:34.440 --> 58:36.440]  array равно
[58:36.440 --> 58:38.440]  t от n.
[58:38.440 --> 58:40.440]  Ну, и дальше заполнить этот массив значениями
[58:40.440 --> 58:42.440]  типа... Точнее, значениями x.
[58:42.440 --> 58:44.440]  В чём тут работа?
[58:44.440 --> 58:46.440]  Если в качестве типа t
[58:46.440 --> 58:48.440]  будет подставлена ссылка,
[58:48.440 --> 58:50.440]  то есть если я в качестве шаблона параметра
[58:50.440 --> 58:52.440]  передам ссылку, то что тут возникнет?
[58:52.440 --> 58:54.440]  Тут возникнет массив ссылок, а массивы ссылок
[58:54.440 --> 58:56.440]  запрещены.
[58:56.440 --> 58:58.440]  То есть мне хочется сделать так, чтобы
[58:58.440 --> 59:00.440]  вот тут оказался тип,
[59:00.440 --> 59:02.440]  которым нет ни константности, нет ни ссылки.
[59:02.440 --> 59:04.440]  То есть нам нужен модификатор
[59:04.440 --> 59:06.440]  типа, который снимет
[59:06.440 --> 59:08.440]  с параметра t все возможные
[59:08.440 --> 59:10.440]  ссылки. Так вот,
[59:10.440 --> 59:12.440]  для этого можно воспользоваться модификатором
[59:12.440 --> 59:14.440]  типа removeReference.
[59:14.440 --> 59:16.440]  Ну, как его можно реализовать? Очень просто.
[59:16.440 --> 59:18.440]  В общем случае, removeReference от t, это просто
[59:18.440 --> 59:20.440]  t. В общем случае, я предполагаю, что
[59:20.440 --> 59:22.440]  на типе нет никакой ссылки.
[59:22.440 --> 59:24.440]  Дальше я пишу специализацию
[59:24.440 --> 59:26.440]  на случай, когда у меня написан t&,
[59:26.440 --> 59:28.440]  то есть если тип подходит под определение,
[59:28.440 --> 59:30.440]  что он совпадает с t и дальше
[59:30.440 --> 59:32.440]  идет&, то соответственно в этом случае
[59:32.440 --> 59:34.440]  я получаю просто тип без&.
[59:34.440 --> 59:36.440]  На removeReference от t&
[59:36.440 --> 59:38.440]  унаследован от typeIdentity от t.
[59:38.440 --> 59:40.440]  Аналогично removeReference от t&
[59:40.440 --> 59:42.440]  унаследован от typeIdentity
[59:42.440 --> 59:44.440]  от t. То есть если у меня
[59:44.440 --> 59:46.440]  в типе содержится&, то он должен быть снят.
[59:46.440 --> 59:48.440]  Если у меня в типе содержится 2&,
[59:48.440 --> 59:50.440]  то он тоже должен быть снят.
[59:50.440 --> 59:52.440]  Соответственно, что я могу тут
[59:52.440 --> 59:54.440]  сделать, я могу тут сделать
[59:54.440 --> 59:56.440]  следующую. Я могу тут
[59:56.440 --> 59:58.440]  написать
[59:58.440 --> 01:00:00.440]  new
[01:00:00.440 --> 01:00:02.440]  remove
[01:00:02.440 --> 01:00:04.440]  reference
[01:00:04.440 --> 01:00:06.440]  от
[01:00:06.440 --> 01:00:08.440]  t
[01:00:08.440 --> 01:00:10.440]  2.
[01:00:10.440 --> 01:00:12.440]  type.
[01:00:12.440 --> 01:00:14.440]  Вот.
[01:00:14.440 --> 01:00:16.440]  И соответственно вот этот тип,
[01:00:16.440 --> 01:00:18.440]  вместо этого типа подставится
[01:00:18.440 --> 01:00:20.440]  тот же самый тип t, но без
[01:00:20.440 --> 01:00:22.440]  ссылки или
[01:00:22.440 --> 01:00:24.440]  либо без правой ссылки.
[01:00:24.440 --> 01:00:26.440]  Окей?
[01:00:30.440 --> 01:00:32.440]  Так.
[01:00:32.440 --> 01:00:34.440]  Как раз осталось время.
[01:00:34.440 --> 01:00:36.440]  Значит,
[01:00:36.440 --> 01:00:38.440]  давайте поговорим,
[01:00:38.440 --> 01:00:40.440]  в завершение поговорим вот о чем.
[01:00:40.440 --> 01:00:42.440]  Давайте поговорим про
[01:00:42.440 --> 01:00:44.440]  то, о чем мы с вами не говорили
[01:00:44.440 --> 01:00:46.440]  в основной части курса.
[01:00:46.440 --> 01:00:48.440]  Давайте поговорим про то, как реализованы
[01:00:48.440 --> 01:00:50.440]  всем известные функции
[01:00:50.440 --> 01:00:52.440]  stdmove и stdforward.
[01:00:58.440 --> 01:01:00.440]  Вот смотрите, мы с вами на самом деле говорили про то, что
[01:01:00.440 --> 01:01:02.440]  вот есть какая-то особая функция stdmove.
[01:01:02.440 --> 01:01:04.440]  Ну, представь себе, у меня есть какой-то
[01:01:04.440 --> 01:01:06.440]  x. Вот. И есть специальная особая
[01:01:06.440 --> 01:01:08.440]  функция
[01:01:08.440 --> 01:01:10.440]  stdmove от x.
[01:01:10.440 --> 01:01:12.440]  stdmove от x.
[01:01:12.440 --> 01:01:14.440]  А актор говорит о том, что
[01:01:14.440 --> 01:01:16.440]  ну, x-у нужно притвориться временным,
[01:01:16.440 --> 01:01:18.440]  и тогда, соответственно, если я вот это вот,
[01:01:18.440 --> 01:01:20.440]  если результат этой функции буду использовать в каком-то контексте,
[01:01:20.440 --> 01:01:22.440]  кто рождает временное значение,
[01:01:22.440 --> 01:01:24.440]  то вот в этом самом контексте
[01:01:24.440 --> 01:01:26.440]  и будет предполагаться временным.
[01:01:26.440 --> 01:01:28.440]  Мы с вами говорили о том,
[01:01:28.440 --> 01:01:30.440]  что делает move,
[01:01:30.440 --> 01:01:32.440]  но при этом мы с вами не говорили о том,
[01:01:32.440 --> 01:01:34.440]  как реализована stdmove. То есть как сделать так,
[01:01:34.440 --> 01:01:36.440]  чтобы move делал именно то, что мы хотим.
[01:01:36.440 --> 01:01:38.440]  Давайте об этом
[01:01:38.440 --> 01:01:40.440]  поговорим. Ну, собственно,
[01:01:40.440 --> 01:01:42.440]  stdmove выглядит примерно так.
[01:01:42.440 --> 01:01:44.440]  Понятно дело, что stdmove — это шаблонная
[01:01:44.440 --> 01:01:46.440]  функция.
[01:01:48.440 --> 01:01:50.440]  Понятно дело, что stdmove — это шаблонная функция.
[01:01:50.440 --> 01:01:52.440]  Вот. Она что-то возвращает.
[01:01:52.440 --> 01:01:54.440]  Она называется move.
[01:01:54.440 --> 01:01:56.440]  Она что-то принимает.
[01:01:56.440 --> 01:01:58.440]  Какой-то x.
[01:01:58.440 --> 01:02:00.440]  Вот.
[01:02:00.440 --> 01:02:02.440]  И она что-то
[01:02:02.440 --> 01:02:04.440]  возвращает.
[01:02:06.440 --> 01:02:08.440]  Ну, давайте попробуем понять,
[01:02:08.440 --> 01:02:10.440]  что нужно подставить на место пропусков,
[01:02:10.440 --> 01:02:12.440]  чтобы stdmove работала именно так, как она работает
[01:02:12.440 --> 01:02:14.440]  на этой библиотеке.
[01:02:14.440 --> 01:02:16.440]  Ну, давайте начнем по порядку.
[01:02:16.440 --> 01:02:18.440]  Давайте начнем
[01:02:18.440 --> 01:02:20.440]  последовательно ответить на вопросы.
[01:02:20.440 --> 01:02:22.440]  Что делает stdmove?
[01:02:22.440 --> 01:02:24.440]  Вот stdmove что-то принимает,
[01:02:24.440 --> 01:02:26.440]  и что stdmove делает с этим объектом?
[01:02:30.440 --> 01:02:32.440]  Да, смотрите, stdmove делает
[01:02:32.440 --> 01:02:34.440]  все, чтобы на выходе
[01:02:34.440 --> 01:02:36.440]  оказалось rvalue.
[01:02:36.440 --> 01:02:38.440]  Чтобы на выходе оказалось
[01:02:38.440 --> 01:02:40.440]  по сути значение, которое
[01:02:40.440 --> 01:02:42.440]  может быть проинтерпретировано как временное значение.
[01:02:42.440 --> 01:02:44.440]  Окей.
[01:02:44.440 --> 01:02:46.440]  Давайте тогда сразу ответим на
[01:02:46.440 --> 01:02:48.440]  вопрос.
[01:02:48.440 --> 01:02:50.440]  Какие там вопросы?
[01:02:50.440 --> 01:02:52.440]  Что возвращает? Бла-бла. Да.
[01:02:52.440 --> 01:02:54.440]  Давайте сразу ответим на вопрос,
[01:02:54.440 --> 01:02:56.440]  что
[01:02:56.440 --> 01:02:58.440]  что
[01:02:58.440 --> 01:03:00.440]  принимает stdmove?
[01:03:00.440 --> 01:03:02.440]  Нет, проще всего
[01:03:02.440 --> 01:03:04.440]  будет ответить на вопрос, что возвращает stdmove.
[01:03:04.440 --> 01:03:06.440]  Какой тип должен вернуть
[01:03:06.440 --> 01:03:08.440]  stdmove? Вот смотрите, мне в stdmove
[01:03:08.440 --> 01:03:10.440]  передали произвольный тип T.
[01:03:10.440 --> 01:03:12.440]  Абсолютно произвольный.
[01:03:12.440 --> 01:03:14.440]  Что мне нужно вернуть в качестве
[01:03:14.440 --> 01:03:16.440]  результата?
[01:03:18.440 --> 01:03:20.440]  Что еще раз?
[01:03:22.440 --> 01:03:24.440]  Да, смотрите, мне нужно вернуть
[01:03:24.440 --> 01:03:26.440]  тип. То есть, stdmove должен вернуть
[01:03:26.440 --> 01:03:28.440]  некоторый тип, на котором навешано
[01:03:28.440 --> 01:03:30.440]  2 амперсанта. Потому что 2 амперсанта
[01:03:30.440 --> 01:03:32.440]  означает, что это
[01:03:32.440 --> 01:03:34.440]  rvalue. Согласны?
[01:03:34.440 --> 01:03:36.440]  Верно ли, что я должен
[01:03:36.440 --> 01:03:38.440]  вернуть T
[01:03:38.440 --> 01:03:40.440]  двойной амперсант?
[01:03:40.440 --> 01:03:42.440]  Почему нет?
[01:03:44.440 --> 01:03:46.440]  Да, и move-reference это верно.
[01:03:46.440 --> 01:03:48.440]  Почему я не могу просто написать вот так?
[01:03:50.440 --> 01:03:52.440]  Да, смотрите,
[01:03:52.440 --> 01:03:54.440]  вот если мне в stdmove передали в качестве
[01:03:54.440 --> 01:03:56.440]  T int амперсант,
[01:03:56.440 --> 01:03:58.440]  то что тут произойдет?
[01:04:00.440 --> 01:04:02.440]  Да, если я навешаю
[01:04:02.440 --> 01:04:04.440]  2 амперсанта, получается амперсант. То есть,
[01:04:04.440 --> 01:04:06.440]  move мне вернет lvalue ссылку. Понятно?
[01:04:06.440 --> 01:04:08.440]  А я хочу, чтобы move всегда
[01:04:08.440 --> 01:04:10.440]  возвращал rvalue.
[01:04:10.440 --> 01:04:12.440]  Как сделать так, чтобы move всегда
[01:04:12.440 --> 01:04:14.440]  возвращал rvalue вне зависимости
[01:04:14.440 --> 01:04:16.440]  того, чем является тип T?
[01:04:20.440 --> 01:04:22.440]  Что?
[01:04:22.440 --> 01:04:24.440]  Так, как это
[01:04:24.440 --> 01:04:26.440]  a?
[01:04:26.440 --> 01:04:28.440]  Ну, нет, auto a2 амперсанта будет работать
[01:04:28.440 --> 01:04:30.440]  так же.
[01:04:30.440 --> 01:04:32.440]  Ну, хотя...
[01:04:32.440 --> 01:04:34.440]  Да, это будет зависеть
[01:04:34.440 --> 01:04:36.440]  от того, что я тут написал, но давайте...
[01:04:36.440 --> 01:04:38.440]  Да.
[01:04:38.440 --> 01:04:40.440]  Вот. Давайте еще тут авто напишем,
[01:04:40.440 --> 01:04:42.440]  пусть компилятор сам разбирается,
[01:04:42.440 --> 01:04:44.440]  как реализовывать.
[01:04:46.440 --> 01:04:48.440]  Вообще можно было действительно
[01:04:48.440 --> 01:04:50.440]  написать так.
[01:04:50.440 --> 01:04:52.440]  Auto и return
[01:04:52.440 --> 01:04:54.440]  stdmove.
[01:04:56.440 --> 01:04:58.440]  Вот.
[01:04:58.440 --> 01:05:00.440]  Так нет, мы же пишем свою версию
[01:05:00.440 --> 01:05:02.440]  move, и мою версию move вызывает stdmove.
[01:05:04.440 --> 01:05:06.440]  Вот.
[01:05:10.440 --> 01:05:12.440]  Нет, статикас
[01:05:12.440 --> 01:05:14.440]  мы не делаем.
[01:05:14.440 --> 01:05:16.440]  Нет, мы его сделаем. Давайте вот какой
[01:05:16.440 --> 01:05:18.440]  тип тут нужно писать? Смотрите, мне тут нужно
[01:05:18.440 --> 01:05:20.440]  писать такой тип, который
[01:05:20.440 --> 01:05:22.440]  с одной стороны бы являлся типом T,
[01:05:22.440 --> 01:05:24.440]  но с другой стороны являлся бы типом T,
[01:05:24.440 --> 01:05:26.440]  на который
[01:05:26.440 --> 01:05:28.440]  обязательно навешано 2 амперсанта,
[01:05:28.440 --> 01:05:30.440]  а не 1.
[01:05:30.440 --> 01:05:32.440]  Вот.
[01:05:32.440 --> 01:05:34.440]  Да, смотрите,
[01:05:34.440 --> 01:05:36.440]  чтобы на тип, который находится
[01:05:36.440 --> 01:05:38.440]  внутри T навесить 2 амперсанта,
[01:05:38.440 --> 01:05:40.440]  мне нужно сначала с типа T снять все амперсанты,
[01:05:40.440 --> 01:05:42.440]  1, 2,
[01:05:42.440 --> 01:05:44.440]  а потом просто навесить 2 амперсанты, согласны?
[01:05:44.440 --> 01:05:46.440]  Вот. Давайте я так и сделаю.
[01:05:46.440 --> 01:05:48.440]  Давайте я напишу...
[01:05:48.440 --> 01:05:50.440]  Давайте
[01:05:50.440 --> 01:05:52.440]  тут напишу... Давайте я уже воспользуюсь
[01:05:52.440 --> 01:05:54.440]  стандартным remove
[01:05:54.440 --> 01:05:56.440]  референсом.
[01:05:56.440 --> 01:05:58.440]  Remove
[01:05:58.440 --> 01:06:00.440]  референс
[01:06:00.440 --> 01:06:02.440]  T от
[01:06:02.440 --> 01:06:04.440]  и по T.
[01:06:04.440 --> 01:06:06.440]  Потом навешу 2 амперсанта
[01:06:06.440 --> 01:06:08.440]  на это.
[01:06:10.440 --> 01:06:12.440]  Move от
[01:06:12.440 --> 01:06:14.440]  кто-то X.
[01:06:14.440 --> 01:06:16.440]  Понятно?
[01:06:16.440 --> 01:06:18.440]  То есть я говорю, возьми,
[01:06:18.440 --> 01:06:20.440]  то есть remove референс, кстати,
[01:06:20.440 --> 01:06:22.440]  remove референс суффиксом T, это по сути
[01:06:22.440 --> 01:06:24.440]  псевдоним для... Давайте так вот.
[01:06:26.440 --> 01:06:28.440]  std что-то что-то
[01:06:28.440 --> 01:06:30.440]  2.2.type
[01:06:30.440 --> 01:06:32.440]  это то же самое,
[01:06:32.440 --> 01:06:34.440]  то std
[01:06:34.440 --> 01:06:36.440]  что-то что-то, нижнее подчеркнение
[01:06:36.440 --> 01:06:38.440]  T. Окей?
[01:06:38.440 --> 01:06:40.440]  Просто псевдоним. Чтобы не писать
[01:06:40.440 --> 01:06:42.440]  всегда 2.2.type, я могу написать
[01:06:42.440 --> 01:06:44.440]  нижнее подчеркнение T.
[01:06:44.440 --> 01:06:46.440]  Ну, это, собственно, шаблонный псевдоним.
[01:06:46.440 --> 01:06:48.440]  То есть вот, я беру тип T и говорю,
[01:06:48.440 --> 01:06:50.440]  давай снимем с него все ссылки,
[01:06:50.440 --> 01:06:52.440]  там, 1 ссылку,
[01:06:52.440 --> 01:06:54.440]  2 ссылки, а потом на то, что получилось, навесим
[01:06:54.440 --> 01:06:56.440]  2 ссылки. Если я на нечто бессылочное
[01:06:56.440 --> 01:06:58.440]  навешу 2 ссылки, то я получу тип с 2
[01:06:58.440 --> 01:07:00.440]  ссылками. Согласны? То есть я получу R-value ссылку.
[01:07:00.440 --> 01:07:02.440]  Ровно то, чего я хотел.
[01:07:02.440 --> 01:07:04.440]  То есть stdmove в любом случае,
[01:07:04.440 --> 01:07:06.440]  то есть stdmove в любом случае мне выдаст
[01:07:06.440 --> 01:07:08.440]  ссылку на какой-то тип.
[01:07:08.440 --> 01:07:10.440]  Двойную ссылку на какой-то тип. Понятно?
[01:07:10.440 --> 01:07:12.440]  Теперь,
[01:07:12.440 --> 01:07:14.440]  что еще, на что ответим? Давай теперь ответим
[01:07:14.440 --> 01:07:16.440]  на этот вопрос.
[01:07:16.440 --> 01:07:18.440]  О, а почему универсальную ссылку?
[01:07:18.440 --> 01:07:20.440]  Ответ правильный. Давайте обоснования.
[01:07:20.440 --> 01:07:22.440]  Почему универсальную ссылку?
[01:07:22.440 --> 01:07:24.440]  Да, потому что в качестве
[01:07:24.440 --> 01:07:26.440]  типа X,
[01:07:26.440 --> 01:07:28.440]  потому что я хочу передать,
[01:07:28.440 --> 01:07:30.440]  потому что stdmove должен работать именно
[01:07:30.440 --> 01:07:32.440]  тем объектом, который я передал.
[01:07:32.440 --> 01:07:34.440]  Ну а передать я могу как L-value, так и R-value.
[01:07:34.440 --> 01:07:36.440]  Ну а универсальная ссылка,
[01:07:36.440 --> 01:07:38.440]  это наиболее универсальный способ
[01:07:38.440 --> 01:07:40.440]  принять параметры.
[01:07:40.440 --> 01:07:42.440]  То есть если я передам L-value,
[01:07:42.440 --> 01:07:44.440]  то X передастся по L-value ссылке,
[01:07:44.440 --> 01:07:46.440]  то есть объект не будет скопирован.
[01:07:46.440 --> 01:07:48.440]  Если я передам L-value ссылке, то объект не будет
[01:07:48.440 --> 01:07:50.440]  тоже не скопирован, не перемещен, просто
[01:07:50.440 --> 01:07:52.440]  будет сохранена ссылка на этот объект.
[01:07:52.440 --> 01:07:54.440]  Поэтому я принимаю по универсальной ссылке.
[01:07:54.440 --> 01:07:56.440]  И наконец, что я пишу в return?
[01:08:04.440 --> 01:08:06.440]  Ну да, на самом деле,
[01:08:06.440 --> 01:08:08.440]  смотрите, мне нужно
[01:08:08.440 --> 01:08:10.440]  из X, который имеет вот такой тип,
[01:08:10.440 --> 01:08:12.440]  получить X, который имеет вот такой тип.
[01:08:12.440 --> 01:08:14.440]  Ну, тут
[01:08:14.440 --> 01:08:16.440]  придется написать вот нечто подобие такого.
[01:08:16.440 --> 01:08:18.440]  Кстати, cast
[01:08:18.440 --> 01:08:20.440]  от, ну и дальше вот это вот
[01:08:20.440 --> 01:08:22.440]  все,
[01:08:22.440 --> 01:08:24.440]  std
[01:08:24.440 --> 01:08:26.440]  remove
[01:08:26.440 --> 01:08:28.440]  ref
[01:08:28.440 --> 01:08:30.440]  variance t
[01:08:30.440 --> 01:08:32.440]  от t
[01:08:34.440 --> 01:08:36.440]  от X.
[01:08:44.440 --> 01:08:46.440]  Кстати, cast это встроенная
[01:08:46.440 --> 01:08:48.440]  операция приведения типа.
[01:08:48.440 --> 01:08:50.440]  Я говорю, что X,
[01:08:50.440 --> 01:08:52.440]  а, да, еще забыл два
[01:08:52.440 --> 01:08:54.440]  персонала.
[01:08:56.440 --> 01:08:58.440]  В стадии cast это встроенная
[01:08:58.440 --> 01:09:00.440]  операция C++, которая
[01:09:00.440 --> 01:09:02.440]  выполняет приведение типа.
[01:09:02.440 --> 01:09:04.440]  И стадий cast может преобразовывать
[01:09:04.440 --> 01:09:06.440]  один ссылочный тип
[01:09:06.440 --> 01:09:08.440]  в другой ссылочный тип.
[01:09:08.440 --> 01:09:10.440]  Все нормально.
[01:09:10.440 --> 01:09:12.440]  Вот.
[01:09:12.440 --> 01:09:14.440]  Как-то так.
[01:09:14.440 --> 01:09:16.440]  Окей?
[01:09:18.440 --> 01:09:20.440]  Вот, собственно, remove reference мне помог.
[01:09:20.440 --> 01:09:22.440]  Remove reference мне помог
[01:09:22.440 --> 01:09:24.440]  превентивно, точнее,
[01:09:24.440 --> 01:09:26.440]  как-то директивно, точнее
[01:09:26.440 --> 01:09:28.440]  навесить двойную ссылку
[01:09:28.440 --> 01:09:30.440]  на нужный тип.
[01:09:30.440 --> 01:09:32.440]  Вне зависимости от того, что было у типа t.
[01:09:32.440 --> 01:09:34.440]  Если у него не было ссылок, то отлично.
[01:09:34.440 --> 01:09:36.440]  Я просто на тип int навесил двойную ссылку.
[01:09:36.440 --> 01:09:38.440]  Если типа t был int ссылкой,
[01:09:38.440 --> 01:09:40.440]  то я одну ссылку убрал, получил int двойная ссылка.
[01:09:40.440 --> 01:09:42.440]  Если был int двойная ссылка, то я
[01:09:42.440 --> 01:09:44.440]  убрал двойную ссылку, навесил двойную ссылку,
[01:09:44.440 --> 01:09:46.440]  получил двойную ссылку. То есть, в любом случае, я получаю
[01:09:46.440 --> 01:09:48.440]  тип, на котором висит
[01:09:48.440 --> 01:09:50.440]  только двойная ссылка, то есть
[01:09:50.440 --> 01:09:52.440]  R-value. Вот. То есть, таким образом, move
[01:09:52.440 --> 01:09:54.440]  в качестве
[01:09:54.440 --> 01:09:56.440]  ответа всегда получает
[01:09:56.440 --> 01:09:58.440]  R-value.
[01:10:02.440 --> 01:10:04.440]  Вот, ну да. Мы про это говорили
[01:10:04.440 --> 01:10:06.440]  все время, что говорим про move.
[01:10:06.440 --> 01:10:08.440]  Move с объектом не делает вообще ничего.
[01:10:08.440 --> 01:10:10.440]  Просто переводит один тип ссылки в другой тип ссылки.
[01:10:14.440 --> 01:10:16.440]  Абсолютно.
[01:10:16.440 --> 01:10:18.440]  Что R-value ссылка, что R-value ссылка,
[01:10:18.440 --> 01:10:20.440]  это ссылка. А ссылки внутри устроены
[01:10:20.440 --> 01:10:22.440]  как указатели.
[01:10:24.440 --> 01:10:26.440]  Вот.
[01:10:26.440 --> 01:10:28.440]  Ну и, собственно, вот решение.
[01:10:30.440 --> 01:10:32.440]  На сегодня все.
[01:10:32.440 --> 01:10:34.440]  В следующий раз
[01:10:34.440 --> 01:10:36.440]  мы разобрали функцию move.
[01:10:36.440 --> 01:10:38.440]  Еще одна интересная функция forward.
[01:10:38.440 --> 01:10:40.440]  Функция forward — это такой условный move.
[01:10:40.440 --> 01:10:42.440]  То есть, в зависимости от условия,
[01:10:42.440 --> 01:10:44.440]  то есть, что было передано forward, он либо делает stmove,
[01:10:44.440 --> 01:10:46.440]  либо не делает stmove. В общем, в следующий раз
[01:10:46.440 --> 01:10:48.440]  посмотрим stforward, ну и еще кое-какие
[01:10:48.440 --> 01:10:50.440]  фишки метапрограммирования. Вот.
[01:10:50.440 --> 01:10:52.440]  Ну а на сегодня все. Всем спасибо.
