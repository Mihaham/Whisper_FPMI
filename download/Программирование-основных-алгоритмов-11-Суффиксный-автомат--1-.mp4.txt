[00:00.000 --> 00:10.640]  а так собственно это лекция где мы половина следующий будет посвящена суффиксному автомату
[00:10.640 --> 00:30.600]  однако о нем мы заговорим минут через 40 сначала немного теории а так определение
[00:30.600 --> 00:43.280]  пусть задан язык и тогда правый контекст
[00:43.280 --> 01:04.360]  слово в мы будем обозначать как р или тв но это райт права или то язык по которому мы берем
[01:05.360 --> 01:17.400]  это какое-то слово быть может не из языка вообще это не особо важно то есть это множество таких
[01:17.400 --> 01:35.360]  у что дописав их справок в мы получим слово из л ну пример очень простой тогда р л от а это
[01:35.360 --> 01:44.840]  будет б б б потому что если мы продлим а справа буквой б то больше слова обез языка аналогично
[01:44.840 --> 01:51.880]  со словом б б а б б в языке может быть пустой контекст со слов то есть не может может вообще
[01:51.880 --> 01:56.640]  таких слов не быть может быть контекст состоящий только из эпсилон это нормально то есть например
[01:56.640 --> 02:15.840]  р или таба это пустое слово эпсилон и бы вот соответственно обозначение будем говорить что два
[02:15.840 --> 02:24.920]  языка эквивалентны по два слова эквивалентны по языку л то есть у эквивалентно по л св тогда
[02:24.920 --> 02:38.200]  только тогда когда их правый контекст равны вот окей что тогда теперь будем говорить с вами
[02:38.200 --> 02:45.240]  вообще есть тема махиллони роуда такая из формалок что если мы ввели вот такое отношение
[02:45.240 --> 02:53.160]  эквивалентности то существует и автомат который распознает язык и содержащий в себе ровно
[02:53.160 --> 02:58.440]  столько состояния сколько классик и лентности и более того автомат с меньшим состоянием построить
[02:58.440 --> 03:06.080]  просто нельзя ну да имеется то конечно если конечно много нас все-таки конечные языки
[03:06.080 --> 03:17.440]  бесконечно мы не будем рассматривать вот окей теперь зафиксируем строку с ну ладно не буду
[03:17.440 --> 03:21.680]  писать просто у вас будет одна строка с фиксирована который будем хотеть построить наш автомат прекрасно
[03:21.680 --> 03:31.960]  вот тогда мы определим язык и это язык всех суффиксов
[03:31.960 --> 03:53.800]  т.е. если у нас строка давайте s равно a b a b тогда l это язык всех суффиксов a b a b b a b
[03:53.800 --> 04:02.120]  b ну добавляйте все он или нет в зависимости от того чем хотим эти пока не будем говорить
[04:02.120 --> 04:12.480]  вдруг пригодится где-то добавим вот окей так соответственно теперь тогда раз у нас язык
[04:12.480 --> 04:18.480]  порождается всеми суффиксами с я имею право записывать эквивалентность не по языку а по
[04:18.480 --> 04:36.120]  строке с ну просто замена переменной тогда у эквивалента по s строке в тогда и только тогда когда
[04:36.120 --> 04:51.160]  рл от у равно рл от в где где л это язык суффиксов
[04:51.160 --> 05:07.880]  вот в общем-то наша будет глобальная цель это построить автомат у которого вершина это класс
[05:07.880 --> 05:16.840]  эквивалентности вот что вот наш великий замысел давайте ему потихонечку приближаться а именно
[05:16.840 --> 05:28.160]  сначала сформулируем следующее что совсем просто утверждение нет сначала не утверждение замечание
[05:28.160 --> 05:52.200]  будет замечание такое что здесь и далее далее рассматриваем только
[05:52.200 --> 06:04.640]  под строке с то есть нас там будут всякие слова у слова в строка гамма например все
[06:04.640 --> 06:10.600]  будет под строками с если не сказано обратного вот теперь можно утверждение формулировать
[06:10.600 --> 06:21.040]  что у нас за утверждение утверждение такое пусть у и в под строке с бла бла бла если рл от
[06:21.040 --> 06:32.200]  у ну давайте напишем даже что неквивалентных новых обозначениях из этого следует что либо
[06:32.200 --> 06:50.560]  у суффикс в либо в суффикс у ну и здесь может сказать что у и в не равны однако можно считать
[06:50.560 --> 06:58.280]  что суффикс может быть совпадением полностью строк и стога все окей вот ну доказательства
[06:58.280 --> 07:09.000]  плюс-минус тревелина почему так давайте что значит что вообще мы рассмотрим под строки
[07:09.000 --> 07:21.760]  с значит у них правый контекст может пустым в смысле почему хотя бы всегда нет смотрите
[07:21.760 --> 07:29.480]  еще раз я смотрю произвольную под строку очевидно что не есть способ продолжить
[07:29.480 --> 07:35.960]  вправо до суффикса даже если я смотрю какой-то из суффиксов у него всегда степси он хотя бы
[07:35.960 --> 07:45.800]  но у оба будет либо оба либо в правом контексте убрали будет только я в правом контексте но
[07:45.800 --> 07:49.960]  никогда не пустой то есть он может состоять из одного пустого слова но все равно это один
[07:49.960 --> 08:02.880]  элемент значит нас так какую в это под строке даже здесь напишем то есть слова w такие что
[08:02.880 --> 08:23.440]  рл w не пустой так как рл от у равно рл от в не равно пустого множества за этого следует что
[08:23.440 --> 08:38.400]  существует давайте гамма скажем существует гамма такая что у гамма это суффикс с и вы гамма
[08:38.400 --> 08:57.120]  это суффикс с ну что тогда можно сказать вот ваша строка с и у нас есть у гамма суффикс
[08:57.120 --> 09:08.680]  с и вы гамма суффикс с то есть я смотрю здесь гамму рассмотреть здесь у рассмотреть здесь в но
[09:08.680 --> 09:15.400]  если дна уборщим длина в эту картинка вот такая иначе у его имеются местами то есть у вас вот
[09:15.400 --> 09:22.720]  всегда вот есть это вот граница на которой у его заканчивается потому что есть гамма в правом
[09:22.720 --> 09:27.840]  контексте раз так то значит у его заканчивается в одном месте значит одно из них суффикс другого
[09:27.840 --> 09:48.880]  давайте как запишем тогда у и вы заканчиваются давайте так имеют вхождение с правой границей
[09:49.360 --> 10:02.880]  длина с минус длины гамма ну то есть это индекс это длина с минус 1 гамма вот откуда следует что
[10:02.880 --> 10:10.800]  но одно суффикс другого сразу следует другого
[10:10.800 --> 10:22.720]  так с этим понятно вроде тривиального утверждения чуть-чуть менее тривиальная
[10:22.720 --> 10:30.880]  да конечно
[10:44.880 --> 10:45.760]  ну
[10:45.760 --> 10:53.520]  вот пример таких слов сейчас дать попробуем что-нибудь придумать такое простенькое чтобы
[10:53.520 --> 11:10.880]  у них были равные вхождения да сейчас так ну окей ну вот это самое простое что можно придумать
[11:10.880 --> 11:21.680]  я вот уже что этих двух слов равный контекст правой и оба пьесе все больше ничего нет
[11:21.680 --> 11:31.520]  ну нет я беру баб и а баб два слова они разные два под слова но при этом их контекста права
[11:31.520 --> 11:38.880]  одинаковый поэтому не квивалентно ну это нормально примерно так-то ну окей чуть
[11:38.880 --> 11:48.320]  менее тривиально хотите ну вот так вот действительно у баб и а баб права контекста
[11:48.320 --> 12:00.680]  права контекста все больше нет ничего так еще одно утверждение об устройстве одного класса
[12:00.680 --> 12:18.440]  пусть у это самая длинная строка
[12:18.440 --> 12:38.200]  в ц.к. вероятности тогда c состоит из у и нескольких самых длинных суффиксов
[12:38.200 --> 12:59.520]  доказательство следующее что ну раз у нас есть все лежит в одном классе квивалентности то есть
[12:59.520 --> 13:05.680]  нас верно вот это вот и при этом у это самая длинная строка в этом классе квивалентности
[13:05.680 --> 13:19.280]  значит любая в то есть давайте рассмотрим так пусть в лежит в ц.модуль очевидно меньше
[13:19.280 --> 13:32.320]  чем модуль у потому что ну длинная потому что у это самая длинная ц.тогда так как в у принадлежат
[13:32.320 --> 13:41.760]  ц. из этого следует что у и в эквивалентно по строке с раз не эквивалентно по строке 100 что
[13:41.760 --> 13:52.240]  тогда из этого следует что в суффикс у то есть я показал что если что-то лежит в классе квивалентности
[13:52.240 --> 13:58.720]  это обязательно суффикс у второй шаг нужно показать что это неприютный подотрезок по суффиксам
[13:58.720 --> 14:09.760]  будет так место мало ладно то есть картинка такая вот у вас есть ваша у и вот можно
[14:09.760 --> 14:10.880]  откусывать по одному символу
[14:24.880 --> 14:29.400]  хорошо если у то самодельно то пускай в будет самой короткой
[14:29.400 --> 14:54.960]  пусть и в самая короткая ц. то есть это вот в и пусть x это суффикс у
[14:54.960 --> 15:05.240]  такой что длина у больше длины x больше длины в то есть какой-то промежуточный суффикс мы
[15:05.240 --> 15:11.000]  рассматриваем отсюда я хочу показать что он лежит в том же классе квивалентности что у и в
[15:11.000 --> 15:16.720]  потому что у и в уже в ц. мне нужно показать что все промежуточные лежат окей рассмотрю
[15:16.720 --> 15:23.760]  произвольный промежуточный суффикс что тогда а тогда я утверждаю следующее что во-первых у
[15:23.760 --> 15:50.160]  меня есть такое вложение. почему это так давайте для этой пары рассмотрим что значит что x это
[15:50.160 --> 16:02.360]  суффикс у это значит что все продолжения справа у до суффикса с они являются и продолжениями x быть
[16:02.360 --> 16:08.000]  может у x есть другие продолжения но главное что отсюда все продолжения входят в этот
[16:08.000 --> 16:20.000]  отлично аналогично с x в получается но на самом деле вы на семинаре докажете что у вас
[16:20.000 --> 16:25.160]  бывает либо два случая когда у и в две подстроки либо один из классов ложим в другой тогда одно
[16:25.160 --> 16:32.400]  суффикс другого либо же вы докажете что их пересечение пустое вообще вот ну это пока что
[16:32.400 --> 16:44.080]  нам не нужно здесь но рл от у это что же самое что рл от в потому что они в одном классе лежат
[16:44.080 --> 16:52.880]  он доказали все то есть нас есть такое вложение и при этом это равно этому начни все три равны
[16:52.880 --> 16:57.600]  значит мы получаем что это какой-то подотрезок суффиксов непрерывных
[16:57.600 --> 17:08.200]  пухну самой легкой позади так теперь несколько обозначений определение даже будет
[17:08.200 --> 17:26.840]  так самая лонгест от класса ц это самая длинная строка в с точнее строка в ц
[17:26.840 --> 17:34.360]  то есть я мог бы там не писать в доказательстве что у это самая длинная страховца мог сказать
[17:34.360 --> 17:51.680]  что у равно лонгеста ц тоже самое будет дальше будет понятие лен это длина лонгеста так
[17:51.680 --> 17:58.800]  кажется стало плохо видно это с миним маркер и что еще нам нужно будет ну вашу
[17:58.800 --> 18:10.640]  любимую суффикс на ссылке конечно надо определить линка ц ведет в такой ц-штрих
[18:10.640 --> 18:28.040]  что лонгест от ц-штрих это суффикс самый длинный суффикс
[18:28.040 --> 18:45.640]  лонгеста ц нележащий в ц
[18:45.640 --> 19:02.260]  так давайте поймем как это выглядит давайте возьму какую-то произвольную подстроку и
[19:03.100 --> 19:06.540]  и мы посмотрим на ее суффикса
[19:06.540 --> 19:36.460]  так я сказал что по сути укладской верности это несколько подрядующих суффиксов допустим
[19:36.460 --> 19:49.260]  закончится где-то здесь тогда значит что суффиксная ссылка отсюда ведет сюда отсюда
[19:49.260 --> 19:55.180]  сюда ну и так далее то есть нас получается так называемые суффиксные пути это пути
[19:55.180 --> 20:03.300]  суффиксных ссылок линка ц ну суффиксная ссылка вершина ц введет в такой ц-штрих
[20:03.300 --> 20:14.860]  вот ц вот ваш ц-штрих будет что лонгеста ц-штрих это вот это вот это самый длинный
[20:14.860 --> 20:23.260]  суффикс лонгеста ц вот этой вот такой что вот этот вот этот суффикс не лежит в ц уже так
[20:23.260 --> 20:33.580]  теорема теорема собственно про то как мы определяем лонгеста как понять что строка
[20:33.580 --> 20:40.140]  является лонгестом в своем классе и в целом может быть вообще каким-то лонгестом может
[20:40.140 --> 20:56.180]  называть новый класс вот так скажем критерий лонгест ну как раз звучит что
[20:56.180 --> 21:12.420]  у равно лонгест от класса эквивалентности слова у то есть нас у лежит в каком-то классе
[21:12.420 --> 21:16.660]  эквивалентности то через квадратные скобочки у я буду обозначать класс хрена если в котором
[21:16.660 --> 21:22.500]  у лежит вроде это плюс минус тривиальное обозначение вот тогда у является лонгестом
[21:22.500 --> 21:34.460]  в своем же классе тогда итог тра когда выполнено одно из двух у это префикс с
[21:34.460 --> 21:48.620]  ну тогда вроде понятно у вас просто длиннее ничего нет а второе существует альфа неравный
[21:48.620 --> 22:13.900]  бета то есть это просто буковки это не строки такие что альфа у и бета у под строки с то есть
[22:13.900 --> 22:20.060]  если я могу влево продолжить по одной букве и получить под строки с по разному продолжить
[22:20.060 --> 22:30.340]  то эта штука является лонгестом в своем классе дать доказывать давайте докажем наверное в
[22:30.340 --> 22:41.340]  какую сторону окей ну попробуем давайте слева направо то есть если у это лонгест то либо префикс
[22:41.340 --> 22:53.100]  либо существует два разных продолжения ну окей докажем от контрпозиции то есть докажем что
[22:53.100 --> 23:13.900]  если это не верно значит не верно это пусть у не префикс с и не существует вон давайте просто
[23:13.900 --> 23:29.460]  напишу это все потом напишу отрицание под строки и возьму от этого отрицание вот как
[23:29.460 --> 23:41.780]  планторах распишите сами распишите вот тогда что тогда тогда у нас получается что у нас это
[23:41.780 --> 23:55.460]  есть наша с да строка есть какие-то хождения у но раз у меня не существует двух таких раз
[23:55.460 --> 24:05.500]  значит везде предваряет одна и та же буква ну и у не префикс мы сразу сказали то есть нас
[24:05.500 --> 24:20.420]  можно всегда слева предварить ее ну что тогда тогда любому вхождению у соответствует вхождение
[24:20.420 --> 24:43.060]  иксу откуда вас следует что икс у эквивалентно по строке сдавайте откуда следует что у просто
[24:43.060 --> 24:55.300]  не лонгест потому что у нас есть иксу в этом классике реверсности так в одно сон доказали
[24:55.300 --> 25:09.340]  дать обратно я хочу доказать что либо лонгест это префикс то есть если либо то либо это значит
[25:09.340 --> 25:26.140]  это лонгест так ну полный доказатель примерно также строится что возьмем контрпозицию и
[25:26.140 --> 25:36.860]  прием противоречия с тем что у нас будет один тот же класс эквалентности так пусть у не равно
[25:37.740 --> 25:52.220]  из этого следует что но при этом у лежит же в своем классе где лежит у поэтому у это суффикс
[25:52.220 --> 26:10.380]  лонгест от куда следует что существует гамма ну либо ну то же самое существует гамма такая
[26:10.380 --> 26:24.700]  что длина гамма больше либо равна 1 и эти гамма длина гамма будет равна единичке все-таки такая
[26:24.700 --> 26:39.860]  что гамма у лежит в классе эквалентности у но откуда вас следует что мы следует противоречие
[26:39.860 --> 26:51.340]  с этим вот то есть либо у не префикс с потому что мы смогли продолжить прямо вот либо у не
[26:51.340 --> 27:00.820]  будет всегда с этим условием либо это не либо все-таки я пишу человеческий что
[27:00.820 --> 27:26.220]  у не префикс с и любое вхождение у сопровождается вхождением гамма у
[27:26.220 --> 27:32.580]  ну тогда не существует просто различных ну конец на этом в общем-то
[27:32.580 --> 27:54.660]  ну вот это почему не выполняется потому что есть у вас то есть у вас у не лонгест значит у вас
[27:54.660 --> 28:00.300]  с любым вхождением у то есть продолжением вправо так абсолютно такое же продолжение есть у гаммы у
[28:00.300 --> 28:09.060]  значит любое вхождение у как под строки сопровождается в начале буквой гамма ну все
[28:09.060 --> 28:17.420]  значит не углу и разных просто выбрать ну то есть идея здесь такая же просто это то же самое
[28:17.420 --> 28:24.380]  как только в другую сторону чуть доказали смотрите у вас есть ум и она не лонгест вот
[28:24.380 --> 28:29.740]  значит есть когда все время входит с у все время ходит икс у если с у все время входит иксу но
[28:29.740 --> 28:35.900]  наш выключает гамма у получилось вот из этого следует что все вхождения у сопровождаются гаммой
[28:35.900 --> 28:41.300]  ну тогда у нас просто нельзя выбрать две различные буквы у нас нет таких вхождений у чтобы они
[28:41.300 --> 28:50.220]  предварялись по-разному так что теперь нужно понять нужно понять что если я знаю все лонгесты я
[28:50.220 --> 28:54.780]  легко восстановлю все классы то есть я хочу сказать что мне на самом деле автомате не надо
[28:54.780 --> 28:58.580]  будет следить за изменением состояния надо будет следить за именем именно лонгестов там будет
[28:58.580 --> 29:04.940]  типа объекция из классов лонгест очевидно отображение давайте как лонгест класса то есть
[29:04.940 --> 29:19.580]  как по лонгестам восстановить класс пусть что круто как в плане все подсроки как по распихивать по
[29:19.580 --> 29:25.340]  классу имеется ввиду это на завтра по сути читать под строки какие-то вот я хочу для каждой под
[29:25.340 --> 29:38.820]  строки по девко на классик вероятности лежит поэтому пусть известные все лонгест как определить
[29:38.820 --> 30:02.460]  от кота в где вы под строка с очень просто обращаемся к этой прекрасной картинке видим
[30:02.460 --> 30:07.500]  что у нас лонгесты ссылаются друг на друга с офисными ссылками поэтому давайте найдем среди
[30:07.500 --> 30:15.340]  лонгестов ведем отношения пейджа быть суффиксом тогда получится ну не очень интеллектуальная
[30:15.340 --> 30:20.380]  картина и что у вас получается вас какой-то суффикс огромный да очень огромное слово
[30:20.380 --> 30:29.380]  лонгест дальше вы рассматриваете все возможные слова которые вам даны в множестве лонгестов
[30:29.380 --> 30:44.460]  и выбирайте то которое самое длинное и суффикс этого и проводим такое ребро то есть можно сказать
[30:44.460 --> 30:50.860]  что мы на на всех лонгестах строим граф где ребро у нас проводится когда одно из них
[30:50.860 --> 31:01.420]  является суффиксом другого и нам останется лишь выделить и покрыть тот граф путями все то здесь
[31:01.420 --> 31:10.300]  вас вот какие-то суффиксы дальше у вас есть вот это вот один класс дальше у вас есть еще класс
[31:10.300 --> 31:19.580]  вот и раз если смогли так себе лонгесту порядочить такие цепи там будет дерево на
[31:20.060 --> 31:28.420]  цепи но это не очень важно по-моему там будет дерево с усылок вот если это будет дерево значит
[31:28.420 --> 31:33.060]  вы смогли их упорядочить так вот по иерархии все значит вы все подсроки можете теперь понять в
[31:33.060 --> 31:43.900]  какой какой вот такой класс их распихивать будете здорово давайте построим пример автомата для
[31:44.780 --> 31:54.100]  так давайте выпишем все подстройки разные и раскидываем их на классы эквивалентности
[31:54.100 --> 32:11.220]  срок здесь очень много а бы а бы а бы а бы а бы а бы а бы а бы вроде бы больше
[32:11.220 --> 32:21.020]  них вонят всех назвал давайте распихивать по классам эквивалентности а бы а бы может
[32:21.060 --> 32:29.180]  лежать только их какие-то суффиксы то есть первый класс вот а бы а бы будет
[32:29.180 --> 32:35.780]  бы а бы это первый класс вот потому что следующий суффикс а бы он уже будет у него будет другой
[32:35.780 --> 32:53.380]  кончик с правой у нас будет а бы и что еще видимо бы потому что чтобы я могу продолжить
[32:53.380 --> 33:00.740]  право либо а бы либо пустое слово что а бы а бы правы пустое слово так это использовали это
[33:00.740 --> 33:08.660]  использовали это использовали так следующий класс это а бы а будет у нас
[33:08.660 --> 33:22.860]  хоть либо вместе с ним вроде бы да потому что у а бы а продолжение б и у б продолжение
[33:22.860 --> 33:42.780]  б только вправо до суффикса но остается один класс а что нет это был потом был подстроен
[33:42.780 --> 33:48.580]  алгоритм пока что это просто бьет дон пристального взгляда то есть я перебираю все подстройки и
[33:48.580 --> 33:53.220]  смотрю правда и что у них правый контекст одинаковый будто бы если беру подстройку и
[33:53.220 --> 34:02.460]  делаю ей мапу из подстройки в множество грубо говоря продолжений вот и так я делаю для каждой
[34:02.460 --> 34:08.660]  для каждой вершины потом просто группирую по равенству этих мап по равенству продолжения
[34:08.660 --> 34:20.180]  вот а ну еще есть конечно же легендарная штука это я поселу все-таки у нас есть пустая подстрока
[34:20.180 --> 34:28.260]  давайте учитывать потому что типа корень нашего автомата будет стартовое состояние ну сюда по
[34:28.260 --> 34:39.380]  букве а можно только перейти сюда по б сюда по б дальше сюда по а сюда по б вот такой автомат
[34:39.380 --> 34:49.180]  получился вот сразу скажу что вы можете сказать что он неполный и это правда потому что чтобы
[34:49.180 --> 34:53.060]  сделать полный я должен завести эффективную вершину провести в нее оставшиеся ребра и
[34:53.060 --> 34:58.820]  они бы соответствовать ровно тому что я читаю не по строке а я говорил что нас
[34:58.820 --> 35:01.940]  интересует только подстройки нас не интересует что-то что не по строке
[35:01.940 --> 35:11.460]  я взял написал букву а к причитанному слову прочитал а то есть смотрите вот у меня был
[35:11.460 --> 35:16.660]  эпсион если я пройду по пути до вершинки б это я должен обязательно причесть класс
[35:17.660 --> 35:25.300]  то есть либо б либо а б тем дальше из каждого слова а б и б отсюда я приписываю букву а и
[35:25.300 --> 35:33.460]  попадаю в этот класс для каждого слова отсюда приписываю букву в этот класс вот про то почему
[35:33.460 --> 35:40.740]  это так работает чуть позже то есть графа постовка у вас такая вот ваш вход автомата
[35:40.740 --> 36:04.460]  а б а б вот ну красиво причем я могу прочесть и суффикс а да а бы а бы могу прочесть а
[36:04.460 --> 36:13.980]  бы а бы могу да да сразу скажу что я здесь не помечаю терминальность но ее можно этот явно
[36:13.980 --> 36:20.860]  найти просто пропустив все суффиксы по автомату так дальше бы а бы я могу прочесть могу а бы
[36:20.860 --> 36:29.620]  могу вроде вот такие вот терминальные состояния дальше бы могу прочесть да могу и пойду в
[36:29.700 --> 36:35.180]  терминал ну всё вот а вот дома от очень то удержаются что минимальный почту что меньше
[36:35.180 --> 36:40.440]  построить нельзя то есть смотрите что мы с вами наконец-то показали за себя показали что если мы
[36:40.440 --> 36:43.980]  знаем все вон Чтобы мы знаем все классы квентности в общем-то к rename построить как-то
[36:43.980 --> 36:51.280]  можем поэтому далее мы будем следить за руками и за онгестом почему session cassette будем нас equals
[36:51.280 --> 36:55.500]  не есть классный критерии того что строка a longTreasury это вот тут вот написано
[36:55.500 --> 37:00.460]  Так, что можно сказать про сам алгоритм? Алгоритм
[37:00.460 --> 37:05.660]  будет очень интеллектуальным. Сначала мы вообще не будем
[37:05.660 --> 37:09.820]  следить за терминальностью, мы просто в самом конце.
[37:09.820 --> 37:15.740]  Вот это первое. Второе, что можно сказать, это то,
[37:15.740 --> 37:23.480]  что... ну сейчас. Можно сказать так, что если у нас есть
[37:23.480 --> 37:25.840]  строка S, для которой мы уже построили автомат, то
[37:25.840 --> 37:28.200]  значит, мы будем дописывать одну букву и перестраивать
[37:28.200 --> 37:34.240]  автомат. То есть нас будет... Давайте, мы будем отвечать
[37:34.240 --> 37:53.400]  на вопросы. Какие новые лонгесты при переходе от S к SC?
[37:53.400 --> 38:01.800]  Ваши ставки сколько добавят с лонгестов? Вот не больше
[38:01.800 --> 38:08.120]  двух. Либо один, либо два, там по-разному бывает.
[38:08.120 --> 38:34.080]  Стой, так, всё, я понял, что забыл сказать. Смотрите,
[38:34.080 --> 38:39.480]  у нас было с вами критерий лонгест. И раз у нас инкрементальный
[38:39.480 --> 38:42.280]  подход, то есть мы увеличиваем на единичку длину строки
[38:42.280 --> 38:46.360]  и подописываем новую букву, тогда можно сказать что?
[38:46.360 --> 38:48.080]  Во-первых, всё, что было префиксами, префиксами
[38:48.080 --> 38:52.040]  останется, это понятно, да? Во-вторых, всё, что продолжал,
[38:52.040 --> 38:53.920]  всё, для чего существовало два разных предварения в
[38:53.920 --> 38:57.280]  лево, для него также будут оставаться два предварения
[38:57.280 --> 39:00.800]  в лево, потому что продолжаем вправо, а не влево. А из
[39:00.800 --> 39:03.400]  этого следует, что то, что было лонгестом, то лонгестом
[39:03.400 --> 39:06.960]  останется. Вот, поэтому давайте здесь напишем мулевой
[39:06.960 --> 39:13.280]  пункт сначала. То есть, как бы, отвечая на вопрос, какие
[39:13.280 --> 39:15.280]  новые лонгесты, сначала ответим на вопрос, какие
[39:15.280 --> 39:40.560]  старые лонгесты. Из критерий лонгест, тот, кто был лонгестом,
[39:40.560 --> 39:48.160]  им и останется. То есть, у нас старые вершины не пропадут.
[39:48.160 --> 39:55.520]  Вот, теперь, в принципе, какие новые будут. Есть по-хорошему
[39:55.520 --> 40:00.920]  вопрос, как изменяются лонгесты при переходе, но, короче,
[40:01.920 --> 40:19.440]  связан вопрос к этому. SC – новый лонгест по критерию. Потому что, во-первых, SC – это
[40:19.440 --> 40:22.280]  префикс. В общем-то, SC – это префикс строки SC, очень
[40:22.280 --> 40:26.760]  концептуальное знание. Но, во-вторых, в целом, никого
[40:26.760 --> 40:30.840]  длиннее SC быть не может вообще в строке. Вот, SC раньше
[40:30.840 --> 40:35.880]  входить не могла в SC, как под строка, поэтому все OK. Что теперь может быть?
[40:35.880 --> 40:50.160]  Может реализоваться второй случай критерия. Пусть T – новый лонгест. Неравный SC – новый
[40:50.160 --> 40:58.760]  лонгест. Давайте поймем, как он устроен. Устроен он не то, чтобы интеллектуально.
[40:58.760 --> 41:09.440]  Вообще, какие у нас новые подстройки, когда написано букву С в конец? Ну, только суффиксы
[41:09.440 --> 41:15.880]  добавились. То есть, вы когда написали SC, у вас новые подстройки – это что-то, что просто суффикс SC.
[41:15.880 --> 41:31.840]  Поэтому пункт A, T – это суффикс SC, потому что должна быть какая-то, видимо, новая подстрока или что-то
[41:31.840 --> 41:36.360]  такое. Потому что, если это не суффикс SC, значит оно должно было быть лонгестом еще здесь,
[41:36.360 --> 41:45.320]  потому что мы уже это рассматривали ранее. Так, пункт B.
[41:45.880 --> 41:58.200]  Давайте поймем, что если T – это суффикс SC, то все остальные… Так, T – суффикс SC. Давайте,
[41:58.200 --> 42:07.520]  что дальше нужно сказать? Если T – это новый лонгест, отличный от SC, то T должна быть под
[42:07.520 --> 42:22.800]  такой S изначально. Сейчас я это поясню. То есть, смотрите, T – это суффикс SC, и при этом мы должны,
[42:22.800 --> 42:30.360]  чтобы он раньше был. Да, смотрите, то есть, здесь все верно. Если T – это суффикс SC и не префикс,
[42:30.360 --> 42:37.240]  потому что T не равно SC, и T – это новый лонгест, значит у нас верна вот эта вот часть критерия. Значит,
[42:37.920 --> 42:46.920]  если T раньше не была лонгестом, то есть, она только сейчас стала, это значит, что у нас должно было
[42:46.920 --> 42:53.800]  получиться найти новое вхождение. То есть, у нас, допустим, все были альфа-Т, теперь добавилась бета-Т.
[42:53.800 --> 43:05.280]  Вот, поэтому T раньше была подстрокой. Нет, у вас добавилось… Включилось слово, что здесь критерий
[43:05.280 --> 43:10.440]  лонгест про то, что у вас слева дописывается буква. То есть, вот у вас вхождение Т были какие-то,
[43:10.440 --> 43:16.760]  раз T – это новый лонгест, да? Раз T – это новый лонгест, значит Т начала заново как-то входить в строку,
[43:16.760 --> 43:25.840]  поэтому появится первый пункт. И перед ним стоит бета. Но при этом у вас, чтобы реализовался критерий
[43:25.840 --> 43:31.880]  лонгеста, у вас должно быть второе вхождение Т, причем это не в SC, а именно в S, потому что вот
[43:31.960 --> 43:41.080]  вхождение Т как суффикс SC. Значит, он входит изначально в S, быть может, много раз. Вот она,
[43:41.080 --> 43:49.800]  ваша Т. Но при этом здесь везде стояла буква альфа всегда. А тут у вас добавилось снова Т,
[43:49.800 --> 43:57.480]  которая заканчивается на эту букву С. Но перед этим вхождением бета. Вот он, этот новый лонгест,
[43:57.480 --> 44:09.640]  который может быть. Значит, следующий шаг наших рассуждений, что, причем смотрите,
[44:09.640 --> 44:17.200]  это значит, что если у меня добавилось вот такое вхождение, и раньше его не было, значит,
[44:17.200 --> 44:26.400]  бета Т не под строка S. Раз добавилось новое вхождение,
[44:26.400 --> 44:38.800]  новое вхождение, это следует, что бета Т не под строка S.
[44:38.800 --> 45:02.400]  Из этого следует, что раз бета Т не под строка S, все суффиксы SC,
[45:02.400 --> 45:23.720]  длины большей, модуль T, они не были под строками SC. Потому что если у вас бета Т не была под строкой,
[45:23.720 --> 45:44.160]  то и подавно все больше суффиксы не были под строками S. То есть, по сути, что нас интересует?
[45:44.160 --> 45:56.280]  Нас интересует самый длинный суффикс, который уже был под строкой. Такой суффикс T самый длинный,
[45:56.280 --> 46:10.840]  который уже был под строкой. Вот такое вот нас дело интересует. Понятная идея?
[46:10.840 --> 46:29.440]  Самый длинный. То есть, если такой T существует, то он установлен вот так вот, как самый длинный суффикс,
[46:29.440 --> 46:54.880]  который под строка S. Почему? Потому что длиннее быть не может. Мы взяли самый длинный, который под
[46:54.880 --> 47:02.480]  строка S. Все остальные не являются под строкой, а значит, входят в класс SC. Теперь надо понять,
[47:02.480 --> 47:10.560]  почему все, кто короче, не являются лонгистами. Раз T под строка S, значит, все суффиксы – это тоже
[47:10.560 --> 47:17.200]  под строки S. Очень тривиальное замечание. У вас здесь все поменьше, они все являются суффиксами.
[47:17.200 --> 47:25.360]  Но при этом, если бы у них существовали разные предварения в исходной строке S, значит, она была бы
[47:25.360 --> 47:34.240]  уже лонгистом. Но в лонгистом она стать не могла. То есть, никто короче T стать не может. И поэтому
[47:34.240 --> 47:41.360]  у нас ровно два варианта. Либо у нас, точнее, вот этот всегда обязательно, а вот этот вот T – она
[47:41.360 --> 47:46.400]  реализуется. То есть, если она реализуется, то это самый длинный суффикс SC, который под строка S.
[47:46.400 --> 47:54.760]  Пока что мы еще не умеем определять нормально, реализуется ли вот этот случай. Но пока что нам
[47:54.760 --> 48:00.760]  это и не нужно. Мы просто поняли, что у нас не очень много новых лонгистов появляется, значит, у нас
[48:00.760 --> 48:06.280]  не очень много новых классов появляется. Тем более, раз у вас тут каждый шаг не более двух
[48:06.280 --> 48:13.600]  состояний добавляется, то у вас будет 2 на длину строки минус 1 число состояния в автомате. Не больше
[48:13.600 --> 48:20.840]  чем. По индукции доказывается. На самом деле, самое сложное рассуждение мы проделали. Все дальше,
[48:20.840 --> 48:25.720]  все будет проще. Это было самое сложное – понять, что их всего два. И последнее утверждение,
[48:26.320 --> 48:42.800]  которое надо доказывать перед тем, как к алгоритму переходить. Устройство переходов в вершину.
[48:42.800 --> 49:11.600]  Пусть рассмотрят такие вот состояния у 1, 2 и так далее, у к или строки. У порядочные по длине
[49:12.400 --> 49:18.160]  лонгиста имеется в виду. То есть уитов – это лонгист в своем классе. На самом деле, не важно,
[49:18.160 --> 49:28.360]  потому что сейчас будет проект, на что я хочу. Из уитова есть переход в.
[49:28.360 --> 49:50.620]  Есть переход в. Что тогда можно сказать? Тогда можно сказать два факта. Все эти переходы по одной
[49:50.620 --> 50:10.300]  букве. То есть у вас уитый. Переход по одной букве С в вершину В будет. Но это плюс-минус
[50:10.300 --> 50:25.540]  тривиально. Второе – чуть-чуть ныне тривиально. Что это такое? То есть я утверждаю, что когда
[50:25.540 --> 50:31.700]  вы переходите в новую вершину, то есть у вас что будет? То есть у вас есть такая картина.
[50:31.700 --> 50:51.780]  Давайте так. Это будет у1, в дальше по суффиксной строке у2, в у3, в
[50:51.780 --> 51:05.940]  в. То есть я утверждаю, что когда вы дописываете новую вершину, у вас как-то вот так все будет
[51:05.940 --> 51:14.700]  устроено. Сразу скажу замечание. Заметим, что у нас был суффиксный путь, он слопнулся в одну вершину.
[51:14.700 --> 51:20.220]  Вот. Это нам будет важно при оценке асимптотики. Мы будем следить за длиной суффисного пути.
[51:20.220 --> 51:25.900]  Но это будет уже, наверное, на следующей лекции оценка асимптотики. Все-таки мы не успеем сегодня,
[51:25.900 --> 51:41.860]  наверное. Так, давайте доказывать. Ну часть первая, она очевидна. Все слова из В заканчиваются на
[51:41.860 --> 51:55.180]  букву С. Но ребро по автомату, это значит просто дописать одну букву. То есть смотрите, у нас
[51:55.180 --> 52:00.900]  здесь какое-то слово было в каком-то из этих состояний. Мы к нему дописали С и получили
[52:00.900 --> 52:20.340]  слово отсюда. Ну не знаю, ПИТ. П лежит в каком-то УИТ. Тогда ПС лежит в В. Мы уже дописали просто
[52:20.340 --> 52:27.580]  букву С по определению толка с ребра в строенном автомате. Короче, я даже не знаю, насколько это
[52:27.580 --> 52:32.260]  нужно написать, потому что это, вроде, совсем очевидная материя. Или нет? Надо чуть-чуть расписать
[52:32.260 --> 52:42.300]  все-таки. Ладно, вы уже умерли, видимо. Все слова из В заканчиваются на букву С. Из этого следует,
[52:42.300 --> 52:59.340]  что для получения слова из В надо к П, принадлежащему УИТе, дописать в конец С.
[52:59.340 --> 53:20.300]  Еще более вместить ту кашу не хочу. По-моему, второй чуть-чуть интеллектуальнее. В этой вершине
[53:20.300 --> 53:25.300]  это классика вероятности. Все. То есть у нас вершина соответствует классику вероятности. Как мы
[53:25.300 --> 53:31.300]  строили вон там на доске, у нас классика вероятности это вершина в автомате, по сути. И слова из В
[53:31.300 --> 53:36.940]  значит, это просто слова, которые можно прочесть, придя, ну, сделав путь в автомате. Да это вершинки
[53:36.940 --> 53:52.180]  из корни. Что? Согласен, надо окно открыть. Это, конечно, глубокое замечание. Ладно, теперь
[53:52.180 --> 54:01.180]  давайте доказывать это. Давайте посмотрим на то, как устроен В, вообще сам по себе. До этого
[54:01.180 --> 54:06.660]  я сотру эту картинку и нарисую другую. Нет, ладно, я лучше сотру с этой доски все и нарисую картинку,
[54:06.660 --> 54:11.420]  потому что там будет большая. Да, вот вы думаете, что надо понимать глубоко эту теорию, я вам сразу
[54:11.420 --> 54:17.540]  скажу, что нет. В принципе, для решения задачи вам не нужно это знание вот этого всего. Для решения
[54:17.540 --> 54:22.220]  задачи вам нужно будет написать код в 40 строк. Да, в качестве автомата 40 строк пишется, я сразу
[54:22.220 --> 54:30.380]  говорю. Вот такая вот огромная штука, 40 строк занимает всего лишь. И под ревью тоже, он настолько
[54:30.380 --> 54:38.820]  простой. То есть там типа надо два часа теории и 15 минут написать его. В смысле под ревью у вас
[54:38.820 --> 54:43.980]  нет требований, вы что, я вам не прислал, я специально сказал, что вы уже взрослые ребята и должны были
[54:43.980 --> 54:52.700]  научиться правильно кодить. В смысле, нет, надо писать абстрактный код слофовит сначала, вот что.
[54:52.700 --> 54:57.740]  Причем от него отнаследовать неупорядочно и упорядочно флоид. Можно шаблонным параметром
[54:57.740 --> 55:08.020]  передать. Вот. Ну тогда и нужно создать картеж, но для этого есть просто спан, который хранит
[55:08.020 --> 55:15.980]  атеративные объекты. Используйте спан над алфавитом, получите строку. Ну ладно, это так, будни
[55:15.980 --> 55:22.060]  программистов, мы сегодня математики. Вот, я утверждаю, что класс В выглядит как-то так.
[55:22.060 --> 55:30.100]  Но здесь надо многоточие поставить, но я утверждаю, ну я хочу вот так вот закончить. Тут может быть еще
[55:30.100 --> 55:36.660]  что-то. Может быть дальше суффиксом написано. В это же не все суффиксы, в это какие-то суффиксы.
[55:36.660 --> 55:43.220]  Давайте рассмотрим наши строки без У, без С, точнее, без последней буквы.
[55:43.220 --> 55:54.220]  Так, по длине нарисовать.
[55:54.220 --> 56:10.460]  Так, кстати, в формалках есть два метода доказательства. Это формальный вывод написать
[56:10.460 --> 56:16.420]  со отношением выводимости, а есть метод доказательства картинкой силы убеждения. Вот я сейчас буду пользоваться вторым.
[56:16.420 --> 56:25.220]  Ну нет, елочки это по картинке как раз, метод убеждения.
[56:25.220 --> 56:32.460]  Получается так. То есть, смотрите, это лонгестат У1.
[56:32.460 --> 56:45.500]  Вот рассмотрим класс У1. Заметим уже, по сути, что мы переходим в те же самые, вот так вот отделяем их будто бы.
[56:45.500 --> 56:52.060]  То есть, у нас вот эти вот строки, это вот так вот классы строим.
[56:52.060 --> 56:57.780]  Ну это, думаю, понятно, да? То есть, я просто ко всем этим строкам приписал букву С и получил строки из В.
[56:57.780 --> 57:05.180]  Теперь дальше, смотрите, что. Раз у меня это единый класс эквивалентности, значит, вот эта вот штука, это суффикс вот этой.
[57:05.180 --> 57:11.900]  То есть, вот эта вот штука, это суффикс вот этой, по свойству класса эквивалентности.
[57:11.900 --> 57:20.300]  То есть, если я отпилю С отсюда, то эта штука будет суффиксом этой, но при этом она не входит в класс эквивалентности У1.
[57:20.300 --> 57:32.300]  То есть, вот это получается у нас лонгестату 2 и по определению суффиксной ссылки она указывает вот сюда, вот отсюда.
[57:32.300 --> 57:38.220]  Ну, абсолютно аналогично, дальше продолжается рассуждение.
[57:38.380 --> 57:42.380]  Достаточно убедительно рукомахание получилось.
[57:42.380 --> 57:44.380]  Вот с левой пластой меги начинается другое класс эквивалентности.
[57:44.380 --> 57:46.380]  Да, а с правой это один тот же.
[57:46.380 --> 57:48.380]  Это может комодипция на У1?
[57:48.380 --> 57:50.380]  Да.
[57:50.380 --> 57:52.380]  Вроде убедительно.
[57:54.380 --> 57:58.380]  Ну, так можно У2, У3 построить и так далее.
[58:00.380 --> 58:04.380]  А эти УИТы, все такие УИТы?
[58:04.540 --> 58:10.540]  Это все УИТы, из которых есть переход в В.
[58:10.540 --> 58:14.540]  В первом пункте мы доказали, что он в одной букве осуществляется.
[58:14.540 --> 58:20.540]  И теперь мы с помощью этого пункта доказали, что все эти УИТы объединены тогда в такой суффиксный путь, то есть в пути суффиксных ссылок.
[58:20.540 --> 58:22.540]  Ну, точнее не все, почему?
[58:22.540 --> 58:28.540]  Потому что дальше у нас будет вот здесь вот суффиксная ссылка В.
[58:28.700 --> 58:32.700]  Ладно, давайте я здесь вот закончу класс В, да?
[58:32.700 --> 58:36.700]  То есть у нас типа У1, У2 будто бы были только.
[58:40.700 --> 58:42.700]  Вот так вот.
[58:42.700 --> 58:48.700]  Как у нас схематичный пунктирчик, здесь сплошная отделяет новые классы.
[58:48.700 --> 58:54.700]  Но если у вас это новый класс, давайте это В1, вот это вот В1,
[58:54.860 --> 58:58.860]  то вот это вот может быть В2 какой-то.
[58:58.860 --> 59:02.860]  То есть сюда введет суффиксная ссылка этой вершинки.
[59:02.860 --> 59:08.860]  Ну тогда у вас в этой штуке будут соответствовать новые классы эквивалентности.
[59:08.860 --> 59:12.860]  То есть по сути у вас пути в автомате выглядят как?
[59:12.860 --> 59:16.860]  Как какой-то ряд суффиксных ссылок здесь,
[59:17.020 --> 59:19.020]  какой-то ряд суффиксных ссылок здесь.
[59:26.860 --> 59:30.860]  Вот как-то вот это Carson здесь и есть classes,
[59:30.860 --> 59:38.860]  а в organizing class, то есть суффикс не прит sixteen pounds.
[59:38.860 --> 59:40.860]  Может быть будетCEO.
[59:40.860 --> 59:44.860]  Так они здесьٹ goddess shapes Я так вот с вами полюбил.
[59:44.860 --> 59:48.860]  Вот как-то вот так вот у вас устроены пути в автомате.
[59:48.860 --> 59:54.860]  То есть у вас это суффиксный путь, и при выписывании буквы C будет новый суффиксный путь.
[59:58.860 --> 01:00:01.860]  То есть здесь очень красиво, на самом деле.
[01:00:01.860 --> 01:00:03.860]  Вот.
[01:00:07.860 --> 01:00:08.860]  Кого?
[01:00:10.860 --> 01:00:13.860]  Нет, нет. Ну так по примеру получилось.
[01:00:14.860 --> 01:00:18.860]  Типа можно так написать спокойно. Это валидная конструкция будет.
[01:00:18.860 --> 01:00:21.860]  Здесь вот одна вообще входит.
[01:00:21.860 --> 01:00:23.860]  Так получилось.
[01:00:24.860 --> 01:00:27.860]  Так, ну получается доказание в картинке.
[01:00:29.860 --> 01:00:31.860]  Так и напишем метод картинки.
[01:00:33.860 --> 01:00:36.860]  Кто посмотрит лекцию, тот поймёт.
[01:00:36.860 --> 01:00:40.860]  Кто не пришёл на лекцию, тот не получает баллов в контест.
[01:00:41.860 --> 01:00:44.860]  Вот. Так, окей.
[01:00:44.860 --> 01:00:46.860]  Что теперь нужно?
[01:00:47.860 --> 01:00:50.860]  Ну теперь, по сути говоря, мы готовы.
[01:00:50.860 --> 01:00:52.860]  Что мы готовы с вами?
[01:00:52.860 --> 01:00:54.860]  Кто с вами к линейному алгоритму?
[01:00:54.860 --> 01:00:56.860]  Постояние.
[01:00:56.860 --> 01:00:58.860]  Так, давайте.
[01:00:58.860 --> 01:01:01.860]  У нас будет переменная last.
[01:01:02.860 --> 01:01:07.860]  Она будет соответствовать текущему классовиковой варианте S.
[01:01:07.860 --> 01:01:10.860]  Мы рассматриваем переходы за S в СС.
[01:01:10.860 --> 01:01:12.860]  Состоянием автомата.
[01:01:12.860 --> 01:01:14.860]  Так, это будет last.
[01:01:16.860 --> 01:01:18.860]  А дальше что будет у нас?
[01:01:18.860 --> 01:01:20.860]  Ну вроде будет всё, что нам пока что нужно.
[01:01:23.860 --> 01:01:25.860]  Теперь смотрите, что нужно сделать.
[01:01:25.860 --> 01:01:27.860]  У нас появляется новый лонгест СС.
[01:01:30.860 --> 01:01:33.860]  Тогда как устроены ребра, ведущие в СС?
[01:01:34.860 --> 01:01:38.860]  Это вместо U1 у вас берётся last.
[01:01:38.860 --> 01:01:41.860]  Проводится по С, получается СС.
[01:01:42.860 --> 01:01:45.860]  И дальше рассматриваются под суффиксный путь.
[01:01:45.860 --> 01:01:48.860]  И вдоль него проводятся ребра по буквам С.
[01:01:55.860 --> 01:01:59.860]  Давайте пока что P равно last напишем.
[01:02:00.860 --> 01:02:02.860]  И шаг первый это
[01:02:04.860 --> 01:02:07.860]  while нет перехода по С.
[01:02:19.860 --> 01:02:21.860]  Функция tu, наша любимая,
[01:02:21.860 --> 01:02:23.860]  из П по букве С
[01:02:23.860 --> 01:02:25.860]  равно СС.
[01:02:25.860 --> 01:02:27.860]  То есть вы создаете новый класс СС
[01:02:27.860 --> 01:02:29.860]  и начинаете вот это вот делать.
[01:02:31.860 --> 01:02:33.860]  Это переменная P.
[01:02:33.860 --> 01:02:35.860]  Сильнее сотру,
[01:02:35.860 --> 01:02:37.860]  чтобы было лучше видно.
[01:02:37.860 --> 01:02:39.860]  Переменная P.
[01:02:39.860 --> 01:02:41.860]  P это у нас от слова путешественник.
[01:02:43.860 --> 01:02:45.860]  Она будет скакать по этому суффиксному пути.
[01:02:45.860 --> 01:02:47.860]  То есть мы скачем по суффиксному пути
[01:02:47.860 --> 01:02:49.860]  и ведём в СС.
[01:02:53.860 --> 01:02:55.860]  То есть если у нас вот это вот
[01:02:55.860 --> 01:02:59.860]  С и с ней суффиксные ссылки,
[01:03:01.860 --> 01:03:04.860]  из которых нет переходов по букве С,
[01:03:08.860 --> 01:03:11.860]  то мы должны построить вот эти вот переходы по С.
[01:03:11.860 --> 01:03:15.860]  Просто по утверждению переходов в дешинку.
[01:03:19.860 --> 01:03:21.860]  Да, сейчас минутку.
[01:03:21.860 --> 01:03:23.860]  Да.
[01:03:31.860 --> 01:03:33.860]  Да.
[01:03:37.860 --> 01:03:39.860]  Потому что смотрите,
[01:03:39.860 --> 01:03:41.860]  вам нужно найти всё,
[01:03:41.860 --> 01:03:43.860]  что может вести в СС.
[01:03:45.860 --> 01:03:47.860]  В СС может вести что?
[01:03:47.860 --> 01:03:49.860]  То есть вам нужно рассмотреть,
[01:03:49.860 --> 01:03:53.860]  то есть в СС по сути вы рассматриваете кого.
[01:03:53.860 --> 01:03:55.860]  Это все пути, по которым можно пройти в СС.
[01:03:55.860 --> 01:03:57.860]  Либо в классах вариантов СС.
[01:03:57.860 --> 01:03:59.860]  В классах вариантов СС
[01:03:59.860 --> 01:04:01.860]  это несколько суффиксов СС.
[01:04:01.860 --> 01:04:03.860]  Вопрос по определению.
[01:04:03.860 --> 01:04:05.860]  Что такое суффиксы СС?
[01:04:05.860 --> 01:04:07.860]  Они устроены как суффиксы С с дописанной буквой С.
[01:04:09.860 --> 01:04:11.860]  Ну вот.
[01:04:13.860 --> 01:04:15.860]  Причём в этом классе лежат те штуки,
[01:04:15.860 --> 01:04:17.860]  у которых в классах вариантов СС
[01:04:17.860 --> 01:04:19.860]  у которых в классах вариантов СС
[01:04:19.860 --> 01:04:21.860]  что это значит?
[01:04:21.860 --> 01:04:23.860]  Это значит, что у них такой же правый контекст, как у СС.
[01:04:23.860 --> 01:04:25.860]  Давайте здесь подпишу, что
[01:04:25.860 --> 01:04:27.860]  RL от СС
[01:04:27.860 --> 01:04:29.860]  по языку СС
[01:04:29.860 --> 01:04:31.860]  от СС, правый контекст.
[01:04:31.860 --> 01:04:33.860]  Он равен вот такому интересному множеству.
[01:04:33.860 --> 01:04:35.860]  Из Эпсилона.
[01:04:35.860 --> 01:04:37.860]  И вас интересуют все те,
[01:04:37.860 --> 01:04:39.860]  у кого тоже Эпсилон.
[01:04:39.860 --> 01:04:41.860]  Но это все суффиксы СС просто-напросто.
[01:04:41.860 --> 01:04:43.860]  В этом классе будут лежать.
[01:04:43.860 --> 01:04:45.860]  Все суффиксы СС.
[01:04:45.860 --> 01:04:47.860]  А что такое суффиксы СС?
[01:04:47.860 --> 01:04:49.860]  Это суффиксы из С.
[01:04:49.860 --> 01:04:51.860]  Да?
[01:04:51.860 --> 01:04:53.860]  При этом, раз текст пустой,
[01:04:53.860 --> 01:04:55.860]  значит все вот эти вот,
[01:04:55.860 --> 01:04:57.860]  кто лежат в СС,
[01:04:57.860 --> 01:04:59.860]  они не должны быть под строками
[01:04:59.860 --> 01:05:01.860]  вот по вот этому вот утверждению.
[01:05:01.860 --> 01:05:03.860]  Не должны быть под строками С.
[01:05:03.860 --> 01:05:05.860]  Это значит, что из них...
[01:05:05.860 --> 01:05:07.860]  То есть из таких вот...
[01:05:07.860 --> 01:05:09.860]  Сейчас.
[01:05:09.860 --> 01:05:11.860]  Ну да, их значит их просто нет в С.
[01:05:11.860 --> 01:05:13.860]  Вот.
[01:05:13.860 --> 01:05:15.860]  Что это значит?
[01:05:15.860 --> 01:05:17.860]  Это значит, что я беру все суффиксы СС.
[01:05:17.860 --> 01:05:19.860]  Это устроено как суффиксы С плюс буква С.
[01:05:21.860 --> 01:05:23.860]  И она не должна быть под строкой.
[01:05:23.860 --> 01:05:25.860]  Да?
[01:05:25.860 --> 01:05:27.860]  Ладно, я уже пошел дальше
[01:05:27.860 --> 01:05:29.860]  объяснять алгоритм, случайно.
[01:05:29.860 --> 01:05:31.860]  Я...
[01:05:33.860 --> 01:05:35.860]  Потому что, смотрите, пока что мы рассмотрим,
[01:05:35.860 --> 01:05:37.860]  пока нет перехода
[01:05:37.860 --> 01:05:39.860]  из по С из П.
[01:05:39.860 --> 01:05:41.860]  То есть мы идем вдоль суффиксного пути,
[01:05:41.860 --> 01:05:43.860]  по букве С.
[01:05:43.860 --> 01:05:45.860]  Что значит, что нет перехода по букве С?
[01:05:45.860 --> 01:05:47.860]  Это значит, что
[01:05:47.860 --> 01:05:49.860]  вот лонгест от этого класса
[01:05:49.860 --> 01:05:51.860]  и приписать букву С
[01:05:51.860 --> 01:05:53.860]  в автомате еще не встречалось.
[01:05:53.860 --> 01:05:55.860]  Значит, переход был бы уже по букве С.
[01:05:55.860 --> 01:05:57.860]  А если он еще не встречался,
[01:05:57.860 --> 01:05:59.860]  значит у него правый контекст пустой.
[01:06:01.860 --> 01:06:03.860]  То есть если мы добавим
[01:06:03.860 --> 01:06:05.860]  по букве С, перейдем сюда,
[01:06:05.860 --> 01:06:07.860]  то это будет правый контекст в течение пустой
[01:06:07.860 --> 01:06:09.860]  из пустого слова состоять.
[01:06:09.860 --> 01:06:11.860]  Поэтому рёбра восстанут.
[01:06:13.860 --> 01:06:15.860]  И, собственно, это первый шаг.
[01:06:15.860 --> 01:06:17.860]  И самый благоприятный случай один.
[01:06:23.860 --> 01:06:25.860]  В равно ку-ноль оказалось.
[01:06:25.860 --> 01:06:27.860]  То есть в стартовом состоянии.
[01:06:27.860 --> 01:06:29.860]  Что это значит? Когда это может вообще быть?
[01:06:29.860 --> 01:06:31.860]  Это значит, что
[01:06:31.860 --> 01:06:33.860]  буква С впервые вообще была встреча
[01:06:33.860 --> 01:06:35.860]  на нами.
[01:06:35.860 --> 01:06:37.860]  Лучший случай
[01:06:37.860 --> 01:06:39.860]  всегда был бы так.
[01:06:39.860 --> 01:06:41.860]  Если, к сожалению, оно нет,
[01:06:41.860 --> 01:06:43.860]  у нас была бы встречася буква С.
[01:06:43.860 --> 01:06:45.860]  Это большое упущение языков.
[01:06:45.860 --> 01:06:47.860]  Надо делать языки,
[01:06:47.860 --> 01:06:49.860]  где все слова из разных букв состоят.
[01:06:55.860 --> 01:06:57.860]  Там алфавит большой,
[01:06:57.860 --> 01:06:59.860]  константа большая будет, к сожалению.
[01:06:59.860 --> 01:07:01.860]  Ну, там язык динамический вообще штука.
[01:07:01.860 --> 01:07:03.860]  Она развивается, растет.
[01:07:03.860 --> 01:07:05.860]  И там тоже может алфавит расти.
[01:07:05.860 --> 01:07:07.860]  Я думаю, новые уроглифы там придумываются
[01:07:07.860 --> 01:07:09.860]  иногда.
[01:07:09.860 --> 01:07:11.860]  Ладно.
[01:07:11.860 --> 01:07:13.860]  В равно ку-ноль. Из этого следует,
[01:07:13.860 --> 01:07:15.860]  что ура,
[01:07:15.860 --> 01:07:17.860]  победа.
[01:07:19.860 --> 01:07:21.860]  Ура, победа, потому что больше
[01:07:21.860 --> 01:07:23.860]  ничего делать не надо.
[01:07:23.860 --> 01:07:25.860]  Осталось, давайте поймём, что нам нужно теперь
[01:07:25.860 --> 01:07:27.860]  проставить.
[01:07:27.860 --> 01:07:29.860]  Нам нужно понять,
[01:07:29.860 --> 01:07:31.860]  кто такая суффиксная ссылка СС.
[01:07:33.860 --> 01:07:35.860]  Ну, раз П равно ку-ноль,
[01:07:35.860 --> 01:07:37.860]  то С вообще впервые встречается.
[01:07:37.860 --> 01:07:39.860]  Из этого следует, что
[01:07:39.860 --> 01:07:41.860]  линк от СС
[01:07:43.860 --> 01:07:45.860]  равно ку-ноль просто-напросто.
[01:07:49.860 --> 01:07:51.860]  В этом случае новый
[01:07:51.860 --> 01:07:53.860]  лонгест не будет появляться,
[01:07:53.860 --> 01:07:55.860]  потому что у вас не было такого,
[01:07:55.860 --> 01:07:57.860]  что у вас под строка.
[01:07:57.860 --> 01:07:59.860]  Что у вас суффикс СС стал подстрокой.
[01:07:59.860 --> 01:08:01.860]  Потому что у вас из всех суффиксов С
[01:08:01.860 --> 01:08:03.860]  нет перехода по С.
[01:08:03.860 --> 01:08:05.860]  И это классно.
[01:08:05.860 --> 01:08:07.860]  Это прям вин-вин ситуация.
[01:08:07.860 --> 01:08:09.860]  Ещё мы обещали
[01:08:09.860 --> 01:08:11.860]  сами поддерживать лен.
[01:08:11.860 --> 01:08:13.860]  Это длина лонгеста,
[01:08:13.860 --> 01:08:15.860]  если кто забыл.
[01:08:15.860 --> 01:08:17.860]  Потому что сами лонгеста мы нигде не поддерживаем
[01:08:17.860 --> 01:08:19.860]  по памяти.
[01:08:19.860 --> 01:08:21.860]  Мы только
[01:08:21.860 --> 01:08:23.860]  храним лена.
[01:08:23.860 --> 01:08:25.860]  Длина СС
[01:08:27.860 --> 01:08:29.860]  или же
[01:08:29.860 --> 01:08:31.860]  лен от
[01:08:31.860 --> 01:08:33.860]  ласта плюс один.
[01:08:35.860 --> 01:08:37.860]  Конец новых состоений добавляется.
[01:08:37.860 --> 01:08:39.860]  Всё мы про это состояние узнали.
[01:08:39.860 --> 01:08:41.860]  Переходы узнали. Вообще шик блеск.
[01:08:41.860 --> 01:08:43.860]  Случай второй.
[01:08:43.860 --> 01:08:45.860]  П не равно KU 0.
[01:08:47.860 --> 01:08:49.860]  Это трагедия.
[01:08:49.860 --> 01:08:51.860]  Почему это трагедия?
[01:08:51.860 --> 01:08:53.860]  Потому что это следует, что есть
[01:08:57.860 --> 01:08:59.860]  По букве С в какую-то Q.
[01:09:01.860 --> 01:09:03.860]  То есть какая картинка здесь?
[01:09:03.860 --> 01:09:10.540]  по букве C в какой-то Q. То есть какая картинка здесь?
[01:09:15.020 --> 01:09:26.180]  Это S, это P, вот ваша SC. Вы действительно провели сюда ребра по C, и тут выяснилось,
[01:09:26.180 --> 01:09:36.220]  что у вас есть переход по C в Q. И вот это плохой случай, но не совсем плохой.
[01:09:36.220 --> 01:09:41.100]  Сейчас он будет снова биться на два случая. Это последнее разбиение, больше не будет.
[01:09:41.100 --> 01:09:47.380]  Вот два случая осталось разобрать, которые лежат в случае 2. Это когда будет появляться новый
[01:09:47.380 --> 01:09:52.500]  лонгест, когда не будет появляться новый лонгест. Теперь самое интеллектуальное.
[01:09:52.500 --> 01:10:04.340]  Вот что у нас получается. Тогда T это кто такой? Это суффикс SC подходит? Подходит.
[01:10:04.340 --> 01:10:11.740]  T под строка S. Потому что у нас уже был такой переход. То есть у нас самый длинный суффикс
[01:10:11.740 --> 01:10:25.980]  SC, который под строка S такой существует. То есть T это лонгест от P плюс C. Согласны?
[01:10:25.980 --> 01:10:38.540]  Мы нашли такой самый длинный суффикс SC. Понятная идея? Просто по определению того,
[01:10:38.540 --> 01:10:44.460]  что такое T у нас в этом случае. Это самый длинный суффикс SC, который под строка S так и есть.
[01:10:44.460 --> 01:10:54.540]  То есть это самый длинный суффикс S. Но при этом еще мы добавили к нему C. То есть есть подстрока
[01:10:54.540 --> 01:11:03.980]  такая. А Q существовал раньше, до добавления SC, поэтому это под строка S. Что тогда нужно сказать?
[01:11:03.980 --> 01:11:11.020]  Тогда нужно понять, нужно ли расщеплять здесь. То есть будет ли новый лонгест. Что значит,
[01:11:11.020 --> 01:11:24.860]  что T новый лонгест? Если T равно лонгест от Q, то что это значит?
[01:11:24.860 --> 01:11:45.820]  Это значит, что нового лонгеста не возникло. У вас уже был лонгест от Q. Новый лонгест не
[01:11:45.820 --> 01:11:51.580]  возник. То есть вы нашли вот такую T, и она уже была лонгестом. То есть нового лонгеста не возникло.
[01:11:51.580 --> 01:12:10.460]  Нового лонгест не возникло. Как проверить вот это вот? Проверить очень просто.
[01:12:10.460 --> 01:12:26.460]  То есть если у вас верно вот это равенство, значит у вас верно, что вот эта вот T-шка
[01:12:26.460 --> 01:12:34.220]  оплена вот так вот, это лонгест Q. Все. Значит, нового лонгеста не возникло. Значит, что нужно
[01:12:34.220 --> 01:12:41.820]  сказать тогда? Ну, Лен от СС понятно, он всегда будет вот таким вот. Надо понять, кто такой линк от СС.
[01:12:55.980 --> 01:13:02.700]  Ну, конец. Этого случая вообще все, он обработан. Потому что дальше у вас есть переходы по ценой
[01:13:02.700 --> 01:13:11.420]  в суффиксном пути. То есть смотрите, что у нас здесь происходит. В этом случае мы сжимаем просто
[01:13:11.420 --> 01:13:16.700]  суффиксный путь в один. Точнее, даже не так. Мы здесь никаких новых ребер проводим,
[01:13:16.700 --> 01:13:22.540]  только вот эти новые ребра. Вот. И поэтому если были бы только эти два случая, то линейность алгоритма
[01:13:22.540 --> 01:13:28.380]  следовала бы из того, что у нас линейное число ребер в автомате. Это правда, доказывать мы это
[01:13:28.380 --> 01:13:33.940]  не будем. Это сложная сиарема, что число ребер в автомате не больше, чем 3 на длину строки минус 4.
[01:13:33.940 --> 01:13:42.900]  Ну да, такая хитрая оценка. Я даже нигде нормального доказательства толка не нашел.
[01:13:42.900 --> 01:13:53.140]  Просто есть где-то в оригинальной статье существует. Ну и последний случай, это когда нам
[01:13:53.140 --> 01:14:07.300]  нужно расщеплять, когда у нас появился новый лонгест. Так. Последний случай. На этой доске разберем.
[01:14:23.140 --> 01:14:50.740]  Так. Случай 3. Это p не равно q 0. Из этого следует, что есть из p переход по c в q. И лен от p меньше,
[01:14:50.740 --> 01:15:01.740]  чем лен от q минус 1. Ну понятно, что больше он быть не может. Что тогда происходит? Ну это значит,
[01:15:01.740 --> 01:15:09.220]  надо расщеплять состояние автомата. Сейчас будет большая картинка, и потом будет пояснение. Так.
[01:15:09.220 --> 01:15:20.180]  Это наша s. Суфиксная ссылка, суфиксная ссылка, суфиксная ссылка, суфиксная ссылка. Еще суфиксная
[01:15:20.180 --> 01:15:29.420]  ссылка. Ну и еще одна. И, наверное, последняя. Я думаю, столько хватит для картинки. Так. Это наша c.
[01:15:29.420 --> 01:15:37.860]  Но я предположу только по двум, чтобы у нас было больше места здесь для рисования. Вот есть наш
[01:15:37.860 --> 01:15:48.740]  классный чувак q, которого ведет ребро по c и с p. Но при этом у нас появился новый лонгест. Это
[01:15:48.740 --> 01:16:04.420]  трагичная история. Тогда создается вместо q две вершинки. Создается q, создается клон. Ну так ее будем
[01:16:04.420 --> 01:16:10.780]  называть. А мы при этом q, это будет, давайте линк от q обзовем вершинку. Она нужна будет еще тоже
[01:16:10.780 --> 01:16:17.940]  для анализа. Вот такой у нас красивый пассион сложился. Теперь надо понять, что вообще происходит
[01:16:17.940 --> 01:16:32.540]  здесь. Давайте подумаем с вами о том, чем отличается правый контекст с и правый контекст q. Точнее правый
[01:16:32.540 --> 01:16:49.380]  контекст q от нового лонгеста. То есть нас интересует rsc от q, rsc от pc. Давайте последний случай,
[01:16:49.380 --> 01:16:54.460]  давайте. Хотите расскажу, если вам не сложно держаться на 5-10? Если нет, то тогда в следующий раз
[01:16:54.460 --> 01:16:58.260]  останется. Как хотите. До свидания.
