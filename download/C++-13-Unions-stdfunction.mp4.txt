[00:00.000 --> 00:17.360]  Тема четырнадцатая, пункт, видимо, третий. Вот, у нас план сегодня обсудить реализацию с
[00:17.360 --> 00:24.800]  defunction, но мы ее обсудим не до конца, то есть мы сделаем ее не совсем
[00:24.800 --> 00:33.360]  эффективной, а вот завтра, ну, у меня на самом деле бы уже, о, тут есть проект, кстати,
[00:33.360 --> 00:42.560]  может тогда я смогу код написать, потому что завтра сдача, ну что ж мы теперь пары проводить
[00:42.560 --> 00:49.880]  не будем, завтра будет сдача после пары, а все-таки пару я проведу, а потом уже принимаем,
[00:49.880 --> 00:57.000]  вот, ну, может до одиннадцати принимаю место за сидеть, не знаю. Так вот, но прежде чем реализователь с
[00:57.000 --> 01:06.320]  defunction, мы вот о чем еще поговорим, у нас есть такой важный, важная сущность в языке,
[01:06.320 --> 01:20.320]  которую мы до сих пор никак не затрагивали, не обсуждали, это юнионы. Юнионы. Объединение. Вот,
[01:20.320 --> 01:31.120]  но есть янамы, а есть юнионы. Эта штука тоже пришла из Си. Вот, кто знает, что такое юнионы? Юнион
[01:31.120 --> 01:39.120]  хранится одной из нескольких. Ну, да, ну, вот там, в принципе, да, одни и те же люди, ну, в принципе,
[01:39.120 --> 01:46.240]  ладно. Ну, вот, да, сейчас я поговорю о том, что такое юнионы и какими пользоваться, вот, довольно
[01:46.240 --> 01:51.840]  скоро, примерно через неделю, а может быть даже и завтра, может и сегодня, мы поймем, что пользоваться
[01:51.840 --> 01:58.120]  им почти никогда не надо, потому что есть современная, потому что есть, что? Сдовариант. Правильно, да,
[01:58.120 --> 02:05.200]  Сдовариант, в Сибирь-17, который я заменил, и вашей четвертой задачей будет как раз он. Да,
[02:05.200 --> 02:11.080]  спойлер небольшой. Ну, про то, как устроена Сдовариант внутри, это отдельная веселая песня, и там масса
[02:11.080 --> 02:18.120]  приколов, которые вас, я уверен, очень порадуют, но это мы, видимо, обсудим уже через неделю, а пока
[02:18.120 --> 02:30.160]  мы просто обсудим, что такое юнионы для начала. Ну, вот, смотрите, юнион, это, на виду с классом и
[02:30.160 --> 02:38.520]  структурой, еще один способ объявить пользовательский тип данных, и у него могут быть поля, я могу
[02:38.520 --> 02:53.640]  сказать, что в юнионе есть, не знаю, int x, ну, для начала что-то тупое, char c и там double d, вот, и, собственно,
[02:53.640 --> 03:03.080]  дальше я могу объявлять сущности такого типа, где-нибудь в мейне. Вот, ну, я могу битовые поля какие-нибудь
[03:03.080 --> 03:14.680]  делать вместо полей обычных, ну, то есть, я могу сказать, что на этом есть int x, там, 4 byte, ну, короче,
[03:14.680 --> 03:28.000]  как обычно. Вот, а теперь, что я могу делать? Я могу... В смысле, есть 4 bit. О, bit, да, bit. Вот, теперь, ну,
[03:28.000 --> 03:41.400]  главное, что отличает юнион от класса и структуры, это то, что размер его, это не сумма размеров полей,
[03:41.400 --> 03:57.640]  а максимум. Вот, то есть, размер такой штуки будет 8. Тебя это удивляет? Да. Почему? Я не поднимал руку.
[03:57.640 --> 04:06.960]  А, ты не поднимал руку? Я не поднимал руку. У меня ощущение было, что ты что-то там... А, просто остальные не делали даже
[04:06.960 --> 04:13.520]  этого. Я это воспринял как положительный знак. Ладно, хорошо. Хоть бы голову почешу. Вот, человек уже голову чешет.
[04:13.520 --> 04:21.520]  Ладно. Ну ладно, хорошо. Да, так вот, в чем смысл юниона? В том, что он позволяет вам прям вот так вот
[04:21.520 --> 04:33.080]  топорно хранить вещь одну из таких на одном и том же участке памяти. То есть, ну, логично, что тогда его
[04:33.080 --> 04:41.720]  размер будет максимум из размеров полей, и вы можете динамически подменять то, что там хранится в рантайме.
[04:41.720 --> 05:01.200]  Ну, например, я могу сказать у точка х равно пяти, и там вывести х. А потом сказать у точка
[05:01.200 --> 05:10.200]  с равно а в калычках. И снова вывести х. Х уже поменяется от этого. Ну, х перезатрется, потому что...
[05:10.200 --> 05:18.720]  Ну, на самом деле, я не уверен, прям вот поменяется ли х от такого, потому что это зависит от того, в каком порядке там
[05:18.720 --> 05:27.160]  что называется, литлэндион или бикэндион. Вот если я на какой-нибудь дабл, то уж точно поменяется. Вот если я так скажу,
[05:27.160 --> 05:35.160]  то все, х точно перезатрется и будет... А мы еще не можем писать сяут х, а можем писать сяут у точка х.
[05:35.160 --> 05:50.160]  Да, и у точка х. Я должен писать сяут у точка х, и здесь тоже напишу сяут у точка х. То есть, это в каком-то смысле рантайм RenderFedcast?
[05:50.160 --> 06:01.160]  Да. Ну да. Не, ну RenderFedcast, он в общем-то... Ну, а что? А еще формально бы написать вот так, у в. Это правда, да?
[06:01.160 --> 06:09.160]  А, ну да. Понятно. Ну, в смысле, вообще не гарантируется, как бы, что мы можем, когда мы... Если мы там присвоили у точка дэш,
[06:09.160 --> 06:15.160]  то у точка х вообще корректно используется. Ну, если это int, то корректно, всегда. Ну, формально. Да, вот самые веселые вещи
[06:15.160 --> 06:21.160]  начинаются когда-то с интервьюальными. Типа здесь, то есть, типа с интервьюальными конструкторами. Сейчас мы про это поговорим.
[06:21.160 --> 06:32.160]  Значит, существует понятие ActiveMemberOfUnion. Вот. Есть... Ну, вот один... В юнионе в нем так дела обстоят. В нем один из членов активный,
[06:32.160 --> 06:44.160]  а все остальные неактивные. Если я... Ну, вот, кстати, в такой... В таком случае я не знаю, кажется, активность становится первой по умолчанию.
[06:44.160 --> 06:54.160]  Вот. Ну, если у меня все... У всех членов поля... О, и все члены — это примитивные типы, то есть, там, типы без интервьюальных конструкторов, ну, как обычно,
[06:54.160 --> 07:06.160]  то активность члена, она определяется просто тем, кому мы последнему присвоили значение. Вот я сказал у точка х 75, и тем самым активным членом стал х.
[07:06.160 --> 07:18.160]  Вот. Я могу в любом момент сказать у точка Derm314, и тогда активным членом станет D, а обращение на чтение, там, к неактивным членам в юнионе — это будет UBR.
[07:18.160 --> 07:28.160]  Ну, на практике это будет реально просто интерпрет-каст, как будто бы. Вот ничего особо такого страшного.
[07:28.160 --> 07:30.160]  Обычная UBR. Нормальная, типичная.
[07:30.160 --> 07:33.160]  Обычная, да. Типичные плюсы, да.
[07:33.160 --> 07:35.160]  Да, базовый плюс.
[07:35.160 --> 07:46.160]  Вот. Хорошо. Я могу изначально юнион чем-то про создание проницилизировать, я могу сказать вот так.
[07:49.160 --> 07:54.160]  Ну, тогда он просто проницилизирует то из полей, которое по типу подходит.
[07:55.160 --> 07:57.160]  А здесь у вас все подходятся?
[07:57.160 --> 08:00.160]  Нет, ну, понятно, что одно подходит точнее.
[08:01.160 --> 08:05.160]  А еще у нас два инта — интыкс и интеллект.
[08:05.160 --> 08:07.160]  Ну, вероятно, он же вообще...
[08:07.160 --> 08:10.160]  Вроде он будет пытаться первый проницилизировать ситуацию.
[08:10.160 --> 08:19.160]  А, кстати, да, наверное, я соманул, наверное, он проницилизирует... Слушай-ка, не помню, не могу точно сказать, он проницилизирует.
[08:19.160 --> 08:23.160]  Ну, если агрегательно связывается, то первый. Ну, через фигурную скобочку.
[08:24.160 --> 08:30.160]  Вот, а так... Даже не знаю, может он действительно первый будет пытаться проницилизировать, а не какой-то.
[08:30.160 --> 08:33.160]  Но в любом случае я могу написать конструкторы.
[08:34.160 --> 08:36.160]  Вот так некомпилируется.
[08:36.160 --> 08:38.160]  А, так некомпилируется, да?
[08:38.160 --> 08:39.160]  Окей.
[08:40.160 --> 08:41.160]  Ну, хорошо.
[08:41.160 --> 08:43.160]  Но я могу написать конструкторы.
[08:44.160 --> 08:50.160]  То есть я могу честно сказать, что такое у, от, инта, у, от, чар.
[08:50.160 --> 08:53.160]  В общем, я могу честно там задать конструкторы.
[08:57.160 --> 09:00.160]  Там, ну, в принципе, вот так нужно работать, кажется.
[09:01.160 --> 09:03.160]  Ну вот, значит, union.
[09:06.160 --> 09:10.160]  Давайте я продублирую то, что писал, потому что сейчас дело пройдет быстро.
[09:12.160 --> 09:14.160]  И конструктор, скажем, от, инт.
[09:14.160 --> 09:17.160]  Вот, теперь я могу смело сказать так.
[09:19.160 --> 09:22.160]  Давай вывести, значит, что там в иксе.
[09:23.160 --> 09:26.160]  А теперь давайте я скажу, что у меня...
[09:26.160 --> 09:28.160]  U, U раз в один.
[09:29.160 --> 09:30.160]  Да.
[09:30.160 --> 09:35.160]  А теперь давайте я скажу, что я на что-то поменял double.
[09:35.160 --> 09:37.160]  И снова выведу то, что в иксе.
[09:37.160 --> 09:39.160]  Это будет UB.
[09:40.160 --> 09:42.160]  И снова выведу то, что в иксе.
[09:42.160 --> 09:43.160]  Это будет UB.
[09:43.160 --> 09:45.160]  Но мы, по всей видимости, увидим вот...
[09:47.160 --> 09:48.160]  UXO.
[09:48.160 --> 09:49.160]  Да.
[09:49.160 --> 09:50.160]  Гитовое представление.
[09:51.160 --> 09:52.160]  Какой-то части дома.
[09:52.160 --> 09:53.160]  Первый, четвертый убит.
[09:53.160 --> 09:54.160]  Ой, бай.
[09:54.160 --> 09:56.160]  А это разве не unspecified behavior?
[09:56.160 --> 09:57.160]  Почему это undefined?
[09:57.160 --> 09:58.160]  Undefined.
[09:58.160 --> 09:59.160]  Обращение к неактивному.
[10:00.160 --> 10:01.160]  Ну, почему это undefined?
[10:01.160 --> 10:02.160]  Потому что там может быть неймит.
[10:02.160 --> 10:04.160]  Если нет, то это просто бред.
[10:04.160 --> 10:06.160]  Ну, ты всегда его можешь интерпретировать.
[10:06.160 --> 10:07.160]  Он очистит.
[10:07.160 --> 10:09.160]  Как и нет, ты его не всегда можешь интерпретировать.
[10:09.160 --> 10:10.160]  Это правда.
[10:10.160 --> 10:11.160]  Это как бред не unspecified.
[10:11.160 --> 10:12.160]  Это не undefined.
[10:12.160 --> 10:15.160]  Ну, я думаю, что undefined, но это такие...
[10:17.160 --> 10:19.160]  Это очень такие технические детали, не особо...
[10:21.160 --> 10:22.160]  Существенные.
[10:22.160 --> 10:23.160]  Будем честными, кто из нас это использует.
[10:23.160 --> 10:24.160]  Все, да.
[10:24.160 --> 10:26.160]  Все понимают, что будет, если...
[10:27.160 --> 10:28.160]  Что так делать не надо.
[10:28.160 --> 10:29.160]  Надо просто...
[10:30.160 --> 10:32.160]  Правильно использовать union, да.
[10:33.160 --> 10:35.160]  Но это не так...
[10:35.160 --> 10:36.160]  Не так интересно.
[10:36.160 --> 10:37.160]  Нет, почему?
[10:37.160 --> 10:39.160]  Может кто-то из вас как раз будет использовать.
[10:39.160 --> 10:42.160]  Вам вот в задаче реализация вариантов вполне пригодится.
[10:42.160 --> 10:43.160]  Но...
[10:45.160 --> 10:47.160]  Никто из нас не будет реализовывать, я понял.
[10:48.160 --> 10:49.160]  Никто не будет цельно играть.
[10:49.160 --> 10:50.160]  Все-таки из-за ахиды сюда...
[10:51.160 --> 10:52.160]  В принципе...
[10:53.160 --> 10:54.160]  Подход на боль.
[10:54.160 --> 10:55.160]  Я знал, что...
[10:55.160 --> 10:56.160]  Я в ходу признал, что так на боль.
[10:56.160 --> 10:57.160]  А вы?
[11:00.160 --> 11:01.160]  Вот.
[11:01.160 --> 11:04.160]  Давайте рассмотрим случай теперь, когда у меня
[11:05.160 --> 11:07.160]  в union тип с негривляльными конструкторами.
[11:11.160 --> 11:12.160]  А...
[11:13.160 --> 11:14.160]  Смотрите.
[11:15.160 --> 11:17.160]  Давайте у меня в union будет, например...
[11:18.160 --> 11:19.160]  И...
[11:19.160 --> 11:20.160]  И стринг.
[11:20.160 --> 11:21.160]  Нет.
[11:25.160 --> 11:26.160]  Вот.
[11:26.160 --> 11:27.160]  Но я могу сказать, что
[11:28.160 --> 11:29.160]  U от...
[11:35.160 --> 11:36.160]  От XA...
[11:36.160 --> 11:38.160]  Ну, от NTA создается, получается, X.
[11:39.160 --> 11:41.160]  От строки создается, получается, S.
[11:42.160 --> 11:43.160]  Вот.
[11:44.160 --> 11:45.160]  Что будет,
[11:46.160 --> 11:47.160]  если я
[11:48.160 --> 11:49.160]  попробую...
[11:50.160 --> 11:51.160]  Ну, скажем...
[11:57.160 --> 11:58.160]  Что сделать?
[11:58.160 --> 11:59.160]  Ну, вот.
[12:05.160 --> 12:06.160]  Вот, допустим,
[12:06.160 --> 12:09.160]  я создал union, проницилизировал X,
[12:09.160 --> 12:11.160]  а теперь хочу вот так сделать.
[12:14.160 --> 12:16.160]  Ну, и вывести нормакресс.
[12:17.160 --> 12:18.160]  Вот.
[12:18.160 --> 12:19.160]  Проблем нет.
[12:19.160 --> 12:20.160]  Проблем нет.
[12:22.160 --> 12:24.160]  А вот, оказывается, будет секфолт сейчас.
[12:26.160 --> 12:27.160]  Хороший коз, добрый.
[12:28.160 --> 12:29.160]  Спасибо, я не хочу...
[12:29.160 --> 12:32.160]  Если я сейчас ничего не накутал, то кажется, будет секфолт.
[12:32.160 --> 12:33.160]  Давайте проверим.
[12:33.160 --> 12:34.160]  А, ну...
[12:34.160 --> 12:35.160]  Во-первых...
[12:35.160 --> 12:36.160]  Так, извиняюсь.
[12:36.160 --> 12:37.160]  Ну, во-первых,
[12:39.160 --> 12:40.160]  сначала CE.
[12:40.160 --> 12:42.160]  Давайте поймем, почему CE.
[12:43.160 --> 12:44.160]  Потому что,
[12:44.160 --> 12:49.160]  если у меня в union есть члены с нетрериальными конструкторами,
[12:50.160 --> 12:51.160]  типа string, например,
[12:52.160 --> 12:56.160]  то у такого union явно надо прописывать деструктор.
[12:56.160 --> 12:58.160]  Ну, это логично, потому что
[12:59.160 --> 13:01.160]  что должно происходить, когда union уничтожается?
[13:01.160 --> 13:03.160]  Деструктор активного.
[13:03.160 --> 13:04.160]  Да.
[13:05.160 --> 13:07.160]  Деструктор активный, а кто из них активный?
[13:07.160 --> 13:08.160]  Он же сам знает.
[13:08.160 --> 13:09.160]  Кто знает?
[13:09.160 --> 13:10.160]  Union не знает.
[13:10.160 --> 13:11.160]  Union не знает?
[13:11.160 --> 13:12.160]  Union...
[13:12.160 --> 13:13.160]  Нет, не знает.
[13:18.160 --> 13:20.160]  Блин, ты можешь просто не пропускать пары,
[13:20.160 --> 13:23.160]  просто потому, что без твоих комментариев гораздо гуснее, чем...
[13:23.160 --> 13:24.160]  У-у-у...
[13:26.160 --> 13:29.160]  Я этого и думал, что 4,5,10 лекции.
[13:29.160 --> 13:31.160]  Ну, вот давай, постарайся, а то прям вот...
[13:31.160 --> 13:34.160]  Мы очень скучаем без твоих, значит, этих...
[13:35.160 --> 13:36.160]  Хорошо.
[13:37.160 --> 13:38.160]  Да, но проблема.
[13:38.160 --> 13:40.160]  Потому что, как мы поймем,
[13:41.160 --> 13:42.160]  что он уничтожит?
[13:42.160 --> 13:43.160]  Union,
[13:44.160 --> 13:46.160]  когда выходит из области видимости,
[13:47.160 --> 13:49.160]  он должен что-то ветероятно уничтожить,
[13:49.160 --> 13:50.160]  у него явно есть поле и string,
[13:50.160 --> 13:51.160]  ему нужен деструктор.
[13:52.160 --> 13:54.160]  Он же откуда-то знает, кто у него активный,
[13:54.160 --> 13:55.160]  и вообще, как он?
[13:55.160 --> 13:56.160]  На B кидает.
[13:56.160 --> 13:59.160]  В том-то и смысл B, что он не знает,
[13:59.160 --> 14:00.160]  он делает так.
[14:03.160 --> 14:04.160]  О, какие беды, ладно.
[14:04.160 --> 14:07.160]  Если бы он знал, то его можно было бы избежать.
[14:07.160 --> 14:09.160]  В этом и смысл же.
[14:10.160 --> 14:11.160]  Вот, ну давайте.
[14:11.160 --> 14:13.160]  Плюс, кажется, надо вообще деструктор каждый раз,
[14:13.160 --> 14:15.160]  когда мы переприсваиваем что-то.
[14:15.160 --> 14:17.160]  Ну, меняем активный, да.
[14:17.160 --> 14:18.160]  Ну да.
[14:19.160 --> 14:21.160]  Я хотел предложить хранить еще и Bool,
[14:21.160 --> 14:24.160]  но как бы он не затрется.
[14:24.160 --> 14:26.160]  А вот, например, когда мы переприсваиваем,
[14:26.160 --> 14:27.160]  как он понимает,
[14:27.160 --> 14:29.160]  он понимает, кто был активным,
[14:29.160 --> 14:30.160]  что он нужен деструктор.
[14:30.160 --> 14:31.160]  Нет, он не знает,
[14:31.160 --> 14:33.160]  он просто его еще называет.
[14:33.160 --> 14:35.160]  В этом-то и причина segfault.
[14:37.160 --> 14:38.160]  Ну, давайте я скажу, что...
[14:38.160 --> 14:39.160]  Не понял.
[14:39.160 --> 14:40.160]  Сейчас поймешь.
[14:40.160 --> 14:41.160]  Ну, вот давайте я скажу,
[14:41.160 --> 14:43.160]  что деструктор ничего не делает.
[14:44.160 --> 14:45.160]  Так, наверное, должно быть, можно.
[14:45.160 --> 14:47.160]  А, нет, default...
[14:47.160 --> 14:48.160]  Default это что?
[14:48.160 --> 14:49.160]  Просто не что.
[14:49.160 --> 14:50.160]  Да, default он не умеет,
[14:50.160 --> 14:52.160]  лучше пустой просто оставлю.
[14:54.160 --> 14:55.160]  Вот.
[14:57.160 --> 14:58.160]  Отлично.
[14:59.160 --> 15:01.160]  И segfault, как я и говорил.
[15:02.160 --> 15:03.160]  Здорово.
[15:03.160 --> 15:04.160]  Кто понимает, почему?
[15:05.160 --> 15:06.160]  Мне кажется,
[15:06.160 --> 15:08.160]  в операторе присваивания строки...
[15:08.160 --> 15:09.160]  Ну, у нас в строке
[15:09.160 --> 15:10.160]  должна быть уже коррект
[15:10.160 --> 15:11.160]  на каком-то виде,
[15:11.160 --> 15:12.160]  когда мы присваиваем,
[15:12.160 --> 15:13.160]  а у нас там лидично написано.
[15:13.160 --> 15:14.160]  Ну, там у нас дел происходит
[15:14.160 --> 15:15.160]  по новому патеру.
[15:15.160 --> 15:16.160]  Конечно.
[15:16.160 --> 15:17.160]  Ну да.
[15:17.160 --> 15:18.160]  В этом вот месте
[15:18.160 --> 15:19.160]  вызывается оператор
[15:19.160 --> 15:21.160]  присваивания двух стрингов.
[15:23.160 --> 15:25.160]  Это же стринг и это стринг.
[15:25.160 --> 15:26.160]  Классическая проблема,
[15:26.160 --> 15:27.160]  как бы ярко ли было.
[15:27.160 --> 15:30.160]  Мы вызываем оператор присваивания,
[15:30.160 --> 15:32.160]  хотя стринг-то никакого нет
[15:32.160 --> 15:33.160]  на самом деле слева.
[15:33.160 --> 15:35.160]  Там, ну...
[15:35.160 --> 15:36.160]  Какие-то биты.
[15:36.160 --> 15:38.160]  Продобные байты, да.
[15:38.160 --> 15:40.160]  Слава, а если бы ты написал 0,
[15:40.160 --> 15:41.160]  то это было бы...
[15:41.160 --> 15:42.160]  0 где бы написал?
[15:42.160 --> 15:44.160]  Ну, урона 0.
[15:44.160 --> 15:45.160]  Ну, то есть...
[15:45.160 --> 15:47.160]  Нам могло бы повести.
[15:47.160 --> 15:48.160]  Зависит от того,
[15:48.160 --> 15:49.160]  как внутри устроен стринг.
[15:49.160 --> 15:50.160]  Ну да, зависит от того,
[15:50.160 --> 15:51.160]  как внутри устроен стринг.
[15:51.160 --> 15:52.160]  То есть, типа,
[15:52.160 --> 15:53.160]  сейчас нам могло бы повести
[15:53.160 --> 15:55.160]  и это бы означало, что...
[15:55.160 --> 15:56.160]  Не понял.
[15:56.160 --> 15:58.160]  Какая проблема с мусорной памятью?
[15:58.160 --> 15:59.160]  Ну, типа...
[15:59.160 --> 16:00.160]  Так ты дилит вызываешь.
[16:00.160 --> 16:01.160]  Там...
[16:01.160 --> 16:02.160]  Ну как?
[16:02.160 --> 16:03.160]  Еще раз.
[16:03.160 --> 16:04.160]  Какая была проблема?
[16:04.160 --> 16:05.160]  Указатель какой-то.
[16:05.160 --> 16:06.160]  Ну или что-то там.
[16:06.160 --> 16:07.160]  Я не понимаю.
[16:07.160 --> 16:08.160]  Но дилит он, наверное, не вызывает.
[16:08.160 --> 16:10.160]  Он же через аллокаты должен.
[16:10.160 --> 16:11.160]  Ну, какой аллокат?
[16:11.160 --> 16:12.160]  А, да.
[16:12.160 --> 16:13.160]  FC структура.
[16:13.160 --> 16:14.160]  Класс.
[16:14.160 --> 16:15.160]  Не-не-не.
[16:15.160 --> 16:16.160]  Сейчас.
[16:16.160 --> 16:18.160]  Это пришло FC,
[16:18.160 --> 16:19.160]  но это не значит,
[16:19.160 --> 16:21.160]  что у нас только C-шные разрешены.
[16:21.160 --> 16:22.160]  Он вызывает дилит,
[16:22.160 --> 16:24.160]  потому что стандартный жалобакар, конечно.
[16:25.160 --> 16:26.160]  Вот.
[16:27.160 --> 16:28.160]  Так.
[16:28.160 --> 16:29.160]  Все подли, почему U-base,
[16:29.160 --> 16:30.160]  а почему C-fold?
[16:30.160 --> 16:31.160]  С 0 не получилось.
[16:31.160 --> 16:32.160]  С 0 не получилось.
[16:32.160 --> 16:33.160]  А давайте проверим.
[16:33.160 --> 16:34.160]  Нет, я думал...
[16:34.160 --> 16:36.160]  Я ставлю на то, что не получится.
[16:36.160 --> 16:37.160]  Почему?
[16:37.160 --> 16:38.160]  Не получится.
[16:38.160 --> 16:39.160]  О-о-о!
[16:43.160 --> 16:44.160]  Мы с дематикой сжали.
[16:44.160 --> 16:45.160]  Ладно, хорошо.
[16:49.160 --> 16:50.160]  А что попрямо с мусором?
[16:50.160 --> 16:51.160]  Ну, значит,
[16:51.160 --> 16:52.160]  значит,
[16:52.160 --> 16:55.160]  в стринге первым полем лежит указатель, действительно.
[16:55.160 --> 16:56.160]  Да?
[16:56.160 --> 16:57.160]  Что мы поняли.
[17:00.160 --> 17:01.160]  Так.
[17:01.160 --> 17:02.160]  Вы поняли, что мы поняли?
[17:02.160 --> 17:03.160]  Или сайд.
[17:03.160 --> 17:04.160]  Хотя нет.
[17:04.160 --> 17:05.160]  Да, указатель.
[17:05.160 --> 17:08.160]  Типа, я должен явно вызывать структуру
[17:08.160 --> 17:09.160]  каждый раз, обычно.
[17:09.160 --> 17:10.160]  Да.
[17:10.160 --> 17:11.160]  Да.
[17:12.160 --> 17:14.160]  Значит, если у тебя union
[17:14.160 --> 17:16.160]  состоит из полей,
[17:16.160 --> 17:18.160]  которые являются интервьюальными типами,
[17:18.160 --> 17:19.160]  то чтобы корректно...
[17:19.160 --> 17:20.160]  Я не понял.
[17:20.160 --> 17:21.160]  А если играли тип...
[17:21.160 --> 17:22.160]  Ну, вот...
[17:22.160 --> 17:23.160]  И все равно он падает?
[17:23.160 --> 17:24.160]  Нет, нет.
[17:24.160 --> 17:27.160]  Если у тебя есть...
[17:27.160 --> 17:28.160]  Ты не можешь...
[17:28.160 --> 17:30.160]  Во-первых, ты должен вызывать структуру,
[17:30.160 --> 17:33.160]  прежде чем выключить одно из полей.
[17:33.160 --> 17:35.160]  А чтобы включить поле новое,
[17:35.160 --> 17:38.160]  ты не представляю, как должен использоваться placement tool.
[17:38.160 --> 17:41.160]  То есть правильное использование было бы таким.
[17:41.160 --> 17:42.160]  Не так.
[17:47.160 --> 17:48.160]  А вот так.
[17:48.160 --> 17:51.160]  У от...
[17:51.160 --> 17:53.160]  Понятное дело такого.
[17:53.160 --> 17:55.160]  СТД стринг АППЦ.
[17:59.160 --> 18:01.160]  Вот это правильное использование.
[18:01.160 --> 18:02.160]  Но теперь утечка памяти.
[18:02.160 --> 18:04.160]  Утечка памяти и в прошлом коде была.
[18:04.160 --> 18:06.160]  А чтобы утечки памяти не было,
[18:06.160 --> 18:08.160]  мне нужно вручную вызывать структуру.
[18:08.160 --> 18:11.160]  То есть мне нужно написать u.s.tilde...
[18:11.160 --> 18:12.160]  А вот tilde что?
[18:12.160 --> 18:14.160]  Basic string.
[18:14.160 --> 18:15.160]  Да.
[18:15.160 --> 18:17.160]  СТД basic string.
[18:19.160 --> 18:20.160]  Если я напишу tilde st string,
[18:20.160 --> 18:21.160]  то это не скомпилируется.
[18:21.160 --> 18:22.160]  Давайте проверим.
[18:22.160 --> 18:23.160]  Давай.
[18:23.160 --> 18:24.160]  Потому что...
[18:24.160 --> 18:26.160]  String это alias, поэтому...
[18:26.160 --> 18:27.160]  Да.
[18:27.160 --> 18:28.160]  Но должно же компилироваться.
[18:28.160 --> 18:29.160]  Using.
[18:30.160 --> 18:31.160]  Ну...
[18:31.160 --> 18:33.160]  Нету такого метода.
[18:34.160 --> 18:35.160]  А, виноват.
[18:35.160 --> 18:36.160]  Почему?
[18:36.160 --> 18:37.160]  Какой стд?
[18:37.160 --> 18:38.160]  Да-да-да.
[18:38.160 --> 18:41.160]  Здесь должно быть просто tilde.
[18:41.160 --> 18:43.160]  Но, опять-таки...
[18:45.160 --> 18:46.160]  Это не class string?
[18:46.160 --> 18:47.160]  Да.
[18:47.160 --> 18:49.160]  Ожидается имя класса, а не имя alias.
[18:49.160 --> 18:50.160]  Поэтому...
[18:54.160 --> 18:55.160]  Basic string char.
[18:55.160 --> 18:56.160]  Вот так.
[18:56.160 --> 18:57.160]  Вот так.
[18:57.160 --> 18:59.160]  Вот так скомпилируется.
[18:59.160 --> 19:01.160]  А если просто basic string?
[19:01.160 --> 19:03.160]  Так она шаблонная.
[19:03.160 --> 19:05.160]  Он скажет, я не знаю какой шаблонный аргумент.
[19:05.160 --> 19:07.160]  А, или ты думаешь, что std сработает?
[19:10.160 --> 19:12.160]  У нас же деструктор...
[19:12.160 --> 19:13.160]  А, все.
[19:13.160 --> 19:14.160]  Я понял.
[19:14.160 --> 19:15.160]  Да.
[19:15.160 --> 19:16.160]  Да, ты прав.
[19:16.160 --> 19:17.160]  Действительно.
[19:17.160 --> 19:18.160]  Что?
[19:18.160 --> 19:20.160]  Ну, в плане, он смотрел, такой...
[19:20.160 --> 19:21.160]  Опа.
[19:21.160 --> 19:24.160]  Ну, у деструктора ты не указываешь шаблонный параметр.
[19:24.160 --> 19:26.160]  Как-то в конструкторе копирования.
[19:26.160 --> 19:28.160]  Кто шаблонный параметр реализовал, то знает.
[19:28.160 --> 19:30.160]  Что шаблонный параметр...
[19:30.160 --> 19:32.160]  У нас указанный не мешает.
[19:32.160 --> 19:33.160]  Вот.
[19:33.160 --> 19:34.160]  Basic string.
[19:34.160 --> 19:36.160]  Вот, надо корректное использование теперь.
[19:36.160 --> 19:38.160]  Можно еще раз посмотри, почему тогда он использовал?
[19:38.160 --> 19:39.160]  Я не понял.
[19:39.160 --> 19:40.160]  А, то есть ты все-таки не понял.
[19:40.160 --> 19:41.160]  Еще раз.
[19:41.160 --> 19:42.160]  Нет.
[19:43.160 --> 19:48.160]  В точности такая же проблема, как когда ты реализуешь вектор.
[19:49.160 --> 19:50.160]  Когда ты...
[19:50.160 --> 19:53.160]  В чем была проблема, когда ты реализовал вектор?
[19:53.160 --> 19:56.160]  Я же был прекрасный, я сдал мист.
[19:57.160 --> 19:59.160]  Ну, до поры до времени.
[19:59.160 --> 20:00.160]  Ну, смотри.
[20:00.160 --> 20:01.160]  Еще раз.
[20:01.160 --> 20:04.160]  Тебе нужно на новом месте создать объект.
[20:05.160 --> 20:07.160]  Типа string.
[20:07.160 --> 20:09.160]  Ну, у тебя вектор строк, допустим.
[20:09.160 --> 20:13.160]  Там была проблема, что ты в новом месте хочешь создать string.
[20:13.160 --> 20:14.160]  Там сырая память.
[20:14.160 --> 20:17.160]  Ты не можешь делать присваивание string на то место.
[20:17.160 --> 20:18.160]  Ты не можешь сказать u там.
[20:18.160 --> 20:22.160]  Ты не можешь сказать там u r it присвоить старое.
[20:22.160 --> 20:25.160]  Потому что оператор присваивания строк будет.
[20:25.160 --> 20:28.160]  Оператор присваивания строк первым делом делает delete старого.
[20:28.160 --> 20:31.160]  Но на старом месте не лежит string.
[20:31.160 --> 20:32.160]  Там лежит сырый byte.
[20:32.160 --> 20:36.160]  Он делает delete, как будто бы там был указатель, но там не указатель.
[20:36.160 --> 20:38.160]  Получается, он делает delete по рандомному адресу.
[20:38.160 --> 20:40.160]  И получает sigfault.
[20:40.160 --> 20:42.160]  Здесь происходит то же самое.
[20:42.160 --> 20:44.160]  Ты вызываешь оператор присваивания строк.
[20:44.160 --> 20:45.160]  Как старый оператор.
[20:45.160 --> 20:47.160]  Так это же expression.
[20:47.160 --> 20:48.160]  Что это?
[20:48.160 --> 20:49.160]  Оператор присваивания.
[20:49.160 --> 20:50.160]  Слева string.
[20:50.160 --> 20:51.160]  Справа const char звезда.
[20:51.160 --> 20:52.160]  Ну, все.
[20:52.160 --> 20:53.160]  Делается оператор присваивание.
[20:53.160 --> 20:55.160]  Типа оператор присваивания строчный.
[20:55.160 --> 20:58.160]  И это никакой специальный для union.
[20:59.160 --> 21:01.160]  Для union может он и был бы специальным.
[21:01.160 --> 21:02.160]  Но это не union, это строка.
[21:02.160 --> 21:05.160]  Нет, ну для union может был специальный, чтобы он активно идти там очищал.
[21:05.160 --> 21:06.160]  А здесь...
[21:06.160 --> 21:07.160]  Что значит активно?
[21:07.160 --> 21:08.160]  Какой тип?
[21:08.160 --> 21:09.160]  Я понял, да.
[21:09.160 --> 21:10.160]  Вот.
[21:10.160 --> 21:11.160]  Это больно.
[21:11.160 --> 21:16.160]  Но особенно, конечно, забавно, что он не байдает вот в такой случае.
[21:16.160 --> 21:17.160]  Да ладно.
[21:17.160 --> 21:18.160]  Он не байдает.
[21:18.160 --> 21:19.160]  Ну, то есть, если...
[21:19.160 --> 21:20.160]  У меня падает, например.
[21:20.160 --> 21:23.160]  На G++11 падает, на Clang++ не падает.
[21:23.160 --> 21:25.160]  Ну, реально, у B.
[21:25.160 --> 21:26.160]  У B, да.
[21:26.160 --> 21:27.160]  Ну, в корейской.
[21:27.160 --> 21:30.160]  Причем интересно, что...
[21:30.160 --> 21:34.160]  Ведь там не все байты нули, вероятно.
[21:34.160 --> 21:36.160]  Не понял.
[21:36.160 --> 21:40.160]  Ну, вот давайте я, допустим, скажу double-d.
[21:41.160 --> 21:43.160]  Нет, давайте я еще скажу long-long.
[21:43.160 --> 21:45.160]  Типа второй байт.
[21:45.160 --> 21:46.160]  Long-long-y.
[21:46.160 --> 21:50.160]  Вот что, если я выведу сейчас y?
[21:51.160 --> 21:54.160]  Ну, просто указатель-то 8 байт, по идее, занимает.
[21:54.160 --> 21:57.160]  А им только первые 4 байта обнулил.
[21:57.160 --> 22:00.160]  Мне интересно, что вот он скажет сейчас.
[22:01.160 --> 22:03.160]  Скажет, привет.
[22:04.160 --> 22:06.160]  Секундочку.
[22:06.160 --> 22:09.160]  Корректное использование, что-то там.
[22:09.160 --> 22:11.160]  А где корректное использование?
[22:11.160 --> 22:14.160]  Нет, нет, я некорректное использование уже делаю.
[22:14.160 --> 22:16.160]  А с DSEALT US будет...
[22:16.160 --> 22:17.160]  Сейчас, еще раз.
[22:17.160 --> 22:19.160]  Он падет сейчас.
[22:19.160 --> 22:21.160]  Не падает, все равно.
[22:21.160 --> 22:24.160]  Да, то есть, у него, видимо, все байты обнулены.
[22:24.160 --> 22:25.160]  Стоп, черт.
[22:25.160 --> 22:28.160]  Ну, это, в смысле, это нормально.
[22:28.160 --> 22:30.160]  Все объекты выделят, хотя...
[22:30.160 --> 22:34.160]  Да, он мог бы и не обнулять.
[22:34.160 --> 22:36.160]  Ну, короче...
[22:36.160 --> 22:38.160]  В плане, более того, он обычно не обнуляет.
[22:38.160 --> 22:40.160]  Ну, ты с юниевым...
[22:40.160 --> 22:43.160]  Если даже интыксы выведешь x, то как будет?
[22:43.160 --> 22:44.160]  Это правда.
[22:44.160 --> 22:46.160]  Интыксы, а это юниевые.
[22:46.160 --> 22:48.160]  О-о-о!
[22:48.160 --> 22:49.160]  Глокая мысль.
[22:49.160 --> 22:50.160]  Так, ладно.
[22:50.160 --> 22:53.160]  Ну, в общем, повеселились и хватит.
[22:53.160 --> 22:57.160]  В общем, пора к следующему от порциона переходить.
[22:57.160 --> 22:59.160]  Изучили какой-то камин.
[22:59.160 --> 23:00.160]  Теперь...
[23:00.160 --> 23:02.160]  Как обычно.
[23:02.160 --> 23:03.160]  Давайте...
[23:03.160 --> 23:04.160]  Не знаю.
[23:04.160 --> 23:10.160]  Посмотрим на, что нам говорят эти перейтлингс по этому поводу.
[23:10.160 --> 23:11.160]  А...
[23:11.160 --> 23:12.160]  У нас...
[23:12.160 --> 23:15.160]  Да, вот это то, что мы сейчас разобрали, это только C++11.
[23:15.160 --> 23:20.160]  До C++11 не разрешалось в юнионах содержать члены, которые...
[23:20.160 --> 23:26.160]  Non-static data member, non-trivial special member function.
[23:26.160 --> 23:33.160]  Да, ну, то есть нельзя было в юнионы класть члены, у которых нетривиальный кооп-конструктор, копия sign или диструктор.
[23:33.160 --> 23:34.160]  Вот.
[23:34.160 --> 23:39.160]  А начиная с C++11, как видите, ситуация опять поменялась, как часто бывает.
[23:39.160 --> 23:49.160]  Если в юнионе есть такой член, то тогда эта соответствующая функция удалена в юнионе по умолчанию.
[23:49.160 --> 23:51.160]  Ну, то есть, что значит, какая функция?
[23:51.160 --> 23:52.160]  Вот.
[23:52.160 --> 24:02.160]  У string есть нетривиальный конструктор, нетривиальный конструктор получали, нетривиальный конструктор копировали, написание диструктор.
[24:02.160 --> 24:05.160]  Значит, соответственно, юнион у юнионных нет теперь.
[24:05.160 --> 24:09.160]  То есть даже если я пишу там u.s, попробую u...
[24:09.160 --> 24:10.160]  Нет, u.s есть.
[24:10.160 --> 24:13.160]  Просто один юнион ты ни другому не можешь присвоить, тебе явно надо определять.
[24:13.160 --> 24:15.160]  То есть, если у меня не было string...
[24:16.160 --> 24:19.160]  Ты мог бы сказать u, v равно u.
[24:19.160 --> 24:20.160]  Это был бы...
[24:20.160 --> 24:24.160]  Опять, автоматически сгенерировался бы конструктор копирования юнионов.
[24:24.160 --> 24:27.160]  Но только если бы не было строк, строки в нем в качестве поля.
[24:29.160 --> 24:34.160]  Она есть, поэтому конструктор копирования, операция писания юниона, тебе придется определять самостоятельно.
[24:36.160 --> 24:39.160]  А юнионы вообще хоть где-то используются?
[24:39.160 --> 24:40.160]  Да.
[24:40.160 --> 24:42.160]  И вот как раз сейчас мы...
[24:42.160 --> 24:43.160]  Кругли варианты даже.
[24:43.160 --> 24:45.160]  Придержать, например, где они используются.
[24:48.160 --> 24:58.160]  Это вообще, скажем так, впервые на арене, впервые на сцене, значит, впервые на столе нашего курса.
[24:58.160 --> 25:00.160]  То есть мы реально приведем предладной.
[25:00.160 --> 25:02.160]  Пример кроме варианта.
[25:02.160 --> 25:07.160]  Кстати, вариант можно и без юниона реализовать, и, вероятно, это даже удобнее будет.
[25:07.160 --> 25:10.160]  А юнион без юниона реализовать нельзя? Случайно?
[25:10.160 --> 25:11.160]  Ну да.
[25:11.160 --> 25:12.160]  Да.
[25:12.160 --> 25:13.160]  Ну да, ничего.
[25:13.160 --> 25:14.160]  Ну...
[25:16.160 --> 25:18.160]  Тебе придется явно риторпедкаст.
[25:18.160 --> 25:19.160]  Ну да.
[25:19.160 --> 25:20.160]  В смысле охранить.
[25:20.160 --> 25:22.160]  Свой звездочек там выделить память.
[25:22.160 --> 25:23.160]  Да, можно.
[25:23.160 --> 25:24.160]  Можно просто делать.
[25:24.160 --> 25:26.160]  Использовать будет примерно так же невозможно.
[25:26.160 --> 25:29.160]  Типа, охранить в поля, равнивание.
[25:29.160 --> 25:30.160]  Ну, чуть-чуть все равно.
[25:30.160 --> 25:31.160]  За каждым...
[25:31.160 --> 25:32.160]  За каждым...
[25:32.160 --> 25:34.160]  И можно что-нибудь оценивать, скажем так.
[25:34.160 --> 25:35.160]  Ну...
[25:39.160 --> 25:40.160]  Нет, это будет такой обстрак на вопросе.
[25:40.160 --> 25:41.160]  Ну, можно, короче.
[25:41.160 --> 25:43.160]  Ну, вы все понимаете.
[25:43.160 --> 25:45.160]  Ну, риторпедкаст придется делать.
[25:45.160 --> 25:46.160]  Это лучше, чем юнион.
[25:46.160 --> 25:47.160]  Да.
[25:47.160 --> 25:52.160]  Ну и как и в структуре, доступ к членам по умолчанию у юниона не публичный.
[25:53.160 --> 25:54.160]  Да.
[25:54.160 --> 25:56.160]  Еще вот важный момент.
[25:56.160 --> 25:57.160]  Union can have number function.
[25:57.160 --> 26:01.160]  То есть я могу объявлять точно так же методы у юниона спокойно.
[26:01.160 --> 26:03.160]  И даже операторы.
[26:03.160 --> 26:05.160]  Но не виртуальная функция.
[26:05.160 --> 26:07.160]  Юнион нельзя наследовать и не наследоваться.
[26:07.160 --> 26:08.160]  Юнион нельзя наследовать.
[26:08.160 --> 26:10.160]  И от него нельзя наследовать.
[26:10.160 --> 26:15.160]  И у юниона не может быть non-steady native members or reference types.
[26:15.160 --> 26:16.160]  В принципе, логично.
[26:16.160 --> 26:17.160]  Почему?
[26:17.160 --> 26:20.160]  Потому что тогда получается, что ссылку можно перепривязать.
[26:20.160 --> 26:22.160]  Хитро, хитро.
[26:22.160 --> 26:23.160]  Вот.
[26:23.160 --> 26:25.160]  А...
[26:25.160 --> 26:29.160]  Кстати, как вы думаете, может быть шаблонный юнион?
[26:29.160 --> 26:30.160]  Да.
[26:30.160 --> 26:31.160]  Правильно.
[26:31.160 --> 26:32.160]  Почему нет?
[26:32.160 --> 26:33.160]  Шаблонный юнион.
[26:33.160 --> 26:35.160]  Слеверен.
[26:35.160 --> 26:36.160]  Именно.
[26:36.160 --> 26:37.160]  Именно.
[26:37.160 --> 26:38.160]  Именно.
[26:38.160 --> 26:39.160]  Именно.
[26:39.160 --> 26:40.160]  Да что вы, дед?
[26:40.160 --> 26:41.160]  Нет.
[26:41.160 --> 26:42.160]  Стоп.
[26:42.160 --> 26:43.160]  А может ли он быть...
[26:43.160 --> 26:45.160]  С переменным количеством шаблонов аргументов, да?
[26:45.160 --> 26:46.160]  Ну...
[26:46.160 --> 26:47.160]  Стоп, стоп.
[26:47.160 --> 26:52.160]  Я недавно написал чудесный код, где у меня был шаблон.
[26:52.160 --> 26:55.160]  И типа это был класс шаблонный.
[26:55.160 --> 26:58.160]  Так вот, этот шаблон класс, он наследовался в краске своего
[26:58.160 --> 26:59.160]  параграмма.
[26:59.160 --> 27:00.160]  Ну да.
[27:00.160 --> 27:01.160]  Было весело.
[27:01.160 --> 27:02.160]  Cd shortptr.
[27:02.160 --> 27:03.160]  Смотрите.
[27:03.160 --> 27:04.160]  Нет.
[27:04.160 --> 27:05.160]  В плане типа паблика.
[27:05.160 --> 27:07.160]  Я могу сделать следующую вещь.
[27:07.160 --> 27:10.160]  Я могу сказать, шаблонный юнион...
[27:10.160 --> 27:13.160]  А что, теста куда пишется?
[27:13.160 --> 27:20.160]  Как мне сделать юнион, который хранит один из перечисленных
[27:20.160 --> 27:21.160]  типов?
[27:21.160 --> 27:22.160]  Юнион...
[27:22.160 --> 27:24.160]  А, нужно говорить шаблонную магию написать.
[27:24.160 --> 27:25.160]  Нет.
[27:25.160 --> 27:26.160]  Ну какую, ладно.
[27:26.160 --> 27:27.160]  Ну вот смотри.
[27:27.160 --> 27:28.160]  Обычно шестнадцать три точки.
[27:28.160 --> 27:31.160]  Чтобы такое выражение продлеваем много раз.
[27:31.160 --> 27:32.160]  Да.
[27:32.160 --> 27:34.160]  А план один хранить?
[27:34.160 --> 27:35.160]  Ну, еще раз.
[27:35.160 --> 27:36.160]  Я хочу сделать следующее.
[27:36.160 --> 27:37.160]  Я хочу сказать.
[27:37.160 --> 27:39.160]  Types.zip.
[27:39.160 --> 27:42.160]  Types.zip.
[27:42.160 --> 27:45.160]  Types.zip.
[27:45.160 --> 27:48.160]  Types.zip.
[27:48.160 --> 27:51.160]  Types.zip.
[27:51.160 --> 27:54.160]  Types.zip.
[27:54.160 --> 27:57.160]  Types.zip.
[27:57.160 --> 28:00.160]  Types.zip.
[28:01.160 --> 28:03.160]  Это звучит очень плохо.
[28:03.160 --> 28:05.160]  Да, так можно вроде бы?
[28:05.160 --> 28:07.160]  Обращаться к этому непонятно будет.
[28:07.160 --> 28:08.160]  Так же.
[28:08.160 --> 28:09.160]  Давайте сделаем так.
[28:09.160 --> 28:10.160]  В плане так же.
[28:10.160 --> 28:11.160]  Юнион.
[28:11.160 --> 28:12.160]  В плане так же.
[28:12.160 --> 28:13.160]  Юнион от одного аргумента и Types.
[28:13.160 --> 28:14.160]  Нет, давайте определим.
[28:14.160 --> 28:16.160]  Юнион и юнион если от одного аргумента.
[28:16.160 --> 28:17.160]  Как мы полностью с этим работать хотим?
[28:17.160 --> 28:18.160]  Как мы будем к этому обращаться?
[28:18.160 --> 28:21.160]  Надо будет написать соответствующие конструкторы, деструкторы
[28:21.160 --> 28:22.160]  и так далее.
[28:22.160 --> 28:23.160]  Это правда.
[28:23.160 --> 28:26.160]  Тут придется писать метод get, что-то в таком стиле.
[28:26.160 --> 28:29.160]  Ну, собственно, примерно варианты получаем.
[28:29.160 --> 28:31.160]  К этому мы и идем.
[28:31.160 --> 28:33.160]  Дичь заступила, я понял.
[28:33.160 --> 28:34.160]  Вот.
[28:34.160 --> 28:39.160]  Ну, типичный способ, классический путь решения какой.
[28:39.160 --> 28:45.160]  Я говорю, у меня есть type-name head и еще tail.
[28:45.160 --> 28:47.160]  Только там три точки.
[28:47.160 --> 28:48.160]  Да.
[28:48.160 --> 28:53.160]  И здесь я просто храню head.
[28:53.160 --> 28:55.160]  А еще
[28:56.160 --> 28:57.160]  Юнион.
[29:01.160 --> 29:03.160]  Юнион или template union?
[29:03.160 --> 29:05.160]  Ой, template union.
[29:09.160 --> 29:13.160]  Что-то именно такое я видел в исходниках тюпла.
[29:13.160 --> 29:18.160]  Ну, смотрите, в исходниках тюпла, по сути, о, кстати,
[29:18.160 --> 29:22.160]  очень сейчас красиво будет для кого-то может быть.
[29:22.160 --> 29:23.160]  Нет.
[29:23.160 --> 29:26.160]  Смотрите, что такое тюпл на самом деле?
[29:26.160 --> 29:30.160]  Тюпл — это структура с переменом количественных шаблонных аргументов,
[29:30.160 --> 29:37.160]  в которой есть поле head, а еще тюпл от оставшихся аргументов.
[29:37.160 --> 29:39.160]  Это не красиво, это отвратительно.
[29:39.160 --> 29:40.160]  Это отвратительно.
[29:40.160 --> 29:41.160]  И это еще не красиво.
[29:41.160 --> 29:43.160]  А что такой вариант, по сути?
[29:43.160 --> 29:46.160]  Это то же самое, только не структура, а union.
[29:46.160 --> 29:48.160]  Какой это union?
[29:48.160 --> 29:53.160]  Ну, если вот здесь я напишу struct вместо union,
[29:53.160 --> 29:56.160]  то получится, как будто бы я тюпл сделал.
[29:56.160 --> 30:01.160]  Если бы я здесь написал union, то получается я сделал как бы вариант.
[30:01.160 --> 30:03.160]  Ну, то есть, std вариант — это тип, который...
[30:03.160 --> 30:07.160]  Ну, давайте ладно, не буду пока рассказывать про std вариант.
[30:11.160 --> 30:15.160]  Ну, нужно писать соответствующий метод, потому что так просто оно не...
[30:15.160 --> 30:19.160]  imp, std, sameweb, все такое.
[30:19.160 --> 30:21.160]  Да, но...
[30:23.160 --> 30:26.160]  Казалось бы, просто надо написать там всякие методы, шаблоны.
[30:26.160 --> 30:28.160]  Нет, не sameweb, потому что у тебя самое...
[30:28.160 --> 30:30.160]  Может несколько одинаковых типов в нем быть.
[30:30.160 --> 30:32.160]  Типа in, double, union.
[30:32.160 --> 30:33.160]  А может ли в нем быть несколько одинаковых типов?
[30:33.160 --> 30:34.160]  Уметь ли это хоть какой-то...
[30:34.160 --> 30:36.160]  Ну, тюпл же умеет, так?
[30:36.160 --> 30:38.160]  Тюпл-то умеет, а тюпл-то тюпл и что?
[30:38.160 --> 30:40.160]  Ну, а здесь...
[30:40.160 --> 30:42.160]  Нет, я говорю, подожди, какая разница?
[30:42.160 --> 30:43.160]  Какая разница?
[30:43.160 --> 30:45.160]  Будем всегда использовать первый.
[30:46.160 --> 30:49.160]  Возможно, для логики, типа, ну, они разные вещи, значит, условно.
[30:49.160 --> 30:50.160]  Они могут знать разные вещи.
[30:50.160 --> 30:53.160]  Ему всего один активный в каждый момент времени.
[30:53.160 --> 30:55.160]  Ну, нет, вариант одинаковых типов — это какой-то...
[30:55.160 --> 30:57.160]  Какая-то жесть там.
[30:57.160 --> 30:59.160]  Я не помню, это сразу C или...
[30:59.160 --> 31:00.160]  Ну, короче, такого...
[31:00.160 --> 31:02.160]  Перегрузка, который будет...
[31:02.160 --> 31:04.160]  Такого быть не должно.
[31:04.160 --> 31:06.160]  Да, это очень...
[31:06.160 --> 31:09.160]  Сохрани, пожалуйста, int или можно int еще.
[31:13.160 --> 31:14.160]  Какой сложный выбор.
[31:14.160 --> 31:16.160]  int или int?
[31:16.160 --> 31:18.160]  Так, смотрите.
[31:18.160 --> 31:20.160]  А может int как сам, а может int звездочка?
[31:20.160 --> 31:22.160]  В общем, шаблоны имени, да.
[31:22.160 --> 31:26.160]  Ну, STD-вариант, он позволяет делать...
[31:26.160 --> 31:29.160]  Самая прикольная фишка STD-варианта в том,
[31:29.160 --> 31:32.160]  что вы можете написать STD-вариант от blah-blah-blah там.
[31:32.160 --> 31:35.160]  v равно, например, один.
[31:35.160 --> 31:39.160]  И он правильный член принципизирует сам догадаться, какой.
[31:39.160 --> 31:41.160]  Вот как раз вариант так умеет.
[31:41.160 --> 31:44.160]  И вот реализовать вариант, самое интересное в нем,
[31:44.160 --> 31:46.160]  это как раз чтобы он правильно делал это.
[31:46.160 --> 31:49.160]  Про это мы поговорим, наверное,
[31:49.160 --> 31:51.160]  либо завтра, либо через неделю, не знаю пока.
[31:51.160 --> 31:54.160]  По ощущениям там что-то очень...
[31:54.160 --> 31:57.160]  Так, давайте пойдем дальше.
[31:57.160 --> 31:59.160]  И я хочу...
[31:59.160 --> 32:01.160]  Это был пункт 14.3.
[32:05.160 --> 32:08.160]  Я хочу сейчас показать...
[32:11.160 --> 32:16.160]  Использование юнионов на практике реальное.
[32:16.160 --> 32:18.160]  И оно прям полезное.
[32:18.160 --> 32:20.160]  Где используются юнионы в стандартной библиотеке?
[32:20.160 --> 32:21.160]  Я вам...
[32:21.160 --> 32:23.160]  Гулту, кстати, тоже полезное.
[32:25.160 --> 32:31.160]  Ну, юнионы используются для оптимизации кое-чего.
[32:31.160 --> 32:33.160]  Гулту тоже.
[32:33.160 --> 32:35.160]  Вообще...
[32:37.160 --> 32:40.160]  Там как раз сложно эти условные конструкции...
[32:40.160 --> 32:42.160]  Ну да, да, в принципе, да.
[32:42.160 --> 32:44.160]  Так вот, продолжаем.
[32:44.160 --> 32:47.160]  Значит, пункт 14.4.
[32:47.160 --> 32:49.160]  Это будет...
[32:49.160 --> 32:52.160]  Ладно, низкорубку называется, давайте вы, может, догадаетесь.
[32:52.160 --> 32:54.160]  А может кто-то из вас знает?
[32:54.160 --> 32:56.160]  Клей.
[32:56.160 --> 32:58.160]  Нет, я шучу.
[32:58.160 --> 33:00.160]  А лучше не шучу.
[33:03.160 --> 33:05.160]  Юнион, например, используется...
[33:05.160 --> 33:07.160]  Вот видите, вот у меня есть вкладочка.
[33:07.160 --> 33:09.160]  Она не из проста.
[33:09.160 --> 33:11.160]  Вот я сейчас во второй вкладочке.
[33:11.160 --> 33:13.160]  Да, да, да.
[33:13.160 --> 33:15.160]  У меня там открыт какой стандарт библиотеки.
[33:15.160 --> 33:17.160]  Вы даже, вероятно, видели, какой.
[33:17.160 --> 33:19.160]  Но на самом деле там открыт Basic String.
[33:19.160 --> 33:21.160]  Там открыт библиотечный String.
[33:21.160 --> 33:23.160]  Его реализация используется юнионом.
[33:23.160 --> 33:25.160]  Отгадайте, для чего?
[33:25.160 --> 33:27.160]  Чего я разумею думаю?
[33:27.160 --> 33:29.160]  Нет.
[33:29.160 --> 33:31.160]  Не завидую.
[33:31.160 --> 33:33.160]  Да, Small String Optimization.
[33:33.160 --> 33:35.160]  Собственно, об этом и пункт.
[33:43.160 --> 33:45.160]  Значит, юнионы в стандартной библиотеке
[33:45.160 --> 33:47.160]  используются,
[33:47.160 --> 33:49.160]  ну, не только в стандартной библиотеке,
[33:49.160 --> 33:51.160]  а вообще, на практике,
[33:51.160 --> 33:53.160]  когда вам нужно сделать
[33:53.160 --> 33:55.160]  Small Object Optimization.
[33:55.160 --> 33:57.160]  Ну, в случае строк
[33:57.160 --> 33:59.160]  называется Small String Optimization.
[33:59.160 --> 34:01.160]  Ну, можно сказать
[34:01.160 --> 34:03.160]  Small Object Optimization.
[34:03.160 --> 34:05.160]  Давайте я просто покажу вам,
[34:05.160 --> 34:07.160]  как выглядит,
[34:07.160 --> 34:09.160]  ну, вот это вот просто
[34:09.160 --> 34:11.160]  Basic String реализации.
[34:11.160 --> 34:13.160]  Тут
[34:13.160 --> 34:15.160]  ну, давайте найдем
[34:15.160 --> 34:17.160]  юнион.
[34:17.160 --> 34:19.160]  Ну, тут вот есть Alloc Hider.
[34:19.160 --> 34:21.160]  А вот
[34:21.160 --> 34:23.160]  юнион.
[34:23.160 --> 34:25.160]  Смотрите, что здесь лежит.
[34:25.160 --> 34:27.160]  Ну, во-первых,
[34:27.160 --> 34:29.160]  прежде чем понять, что тут
[34:29.160 --> 34:31.160]  в нем перечислено, я хочу обратить
[34:31.160 --> 34:33.160]  вашу юниону на формулу.
[34:33.160 --> 34:35.160]  У него нет имени почему-то.
[34:35.160 --> 34:37.160]  Анонимный Юнион.
[34:37.160 --> 34:39.160]  Анонимный Юнион.
[34:39.160 --> 34:41.160]  А сверху тоже нет
[34:41.160 --> 34:43.160]  миния.
[34:43.160 --> 34:45.160]  Какой-то группа анонимных, я не знаю,
[34:45.160 --> 34:47.160]  вообще.
[34:47.160 --> 34:49.160]  Крупа анонимных членов.
[34:49.160 --> 34:51.160]  Ну, ладно.
[34:51.160 --> 34:53.160]  Крупа анонимных
[34:53.160 --> 34:55.160]  членов стрима.
[34:55.160 --> 34:57.160]  Там все надо быть анонимными.
[34:57.160 --> 34:59.160]  Спресс где-то засунутый, нормально.
[35:01.160 --> 35:03.160]  Что такое анонимный Юнион?
[35:03.160 --> 35:05.160]  А вот как вообще понять,
[35:05.160 --> 35:07.160]  это юнион, нет имени,
[35:07.160 --> 35:09.160]  это мы в телеклассе находимся.
[35:09.160 --> 35:11.160]  Ну, тогда все его объекты, они как бы
[35:11.160 --> 35:13.160]  поля класса и ровно один из вот этих
[35:13.160 --> 35:15.160]  всех активных.
[35:15.160 --> 35:17.160]  Да, все так. Значит,
[35:17.160 --> 35:19.160]  вы можете сделать юнионанимным.
[35:19.160 --> 35:21.160]  И давайте я
[35:21.160 --> 35:23.160]  вниз не пролистал, но вот тут есть
[35:23.160 --> 35:25.160]  тут рассказывается,
[35:25.160 --> 35:27.160]  что такое member lifetime, что такое
[35:27.160 --> 35:29.160]  активный и пассивный член юниона.
[35:29.160 --> 35:31.160]  Анонимный Юнион. Давайте посмотрим.
[35:31.160 --> 35:33.160]  Смотрите.
[35:33.160 --> 35:35.160]  Можно
[35:35.160 --> 35:37.160]  сказать, что
[35:37.160 --> 35:39.160]  у меня есть анонимный юнион.
[35:39.160 --> 35:41.160]  И...
[35:41.160 --> 35:43.160]  Значит...
[35:43.160 --> 35:45.160]  Ну, вот так
[35:45.160 --> 35:47.160]  это выглядит. Для анонимных юнионов
[35:47.160 --> 35:49.160]  применяются дальнейшие ограничения.
[35:49.160 --> 35:51.160]  Не может быть членов,
[35:51.160 --> 35:53.160]  не может быть статических членов
[35:53.160 --> 35:55.160]  и всех членов.
[35:55.160 --> 35:57.160]  А...
[35:57.160 --> 35:59.160]  Вот.
[36:05.160 --> 36:07.160]  То есть, если я здесь написал
[36:07.160 --> 36:09.160]  анонимный юнион, то у меня как бы появляется
[36:09.160 --> 36:11.160]  одновременно int i и const char звезда b,
[36:11.160 --> 36:13.160]  но они шерят одну и ту же
[36:13.160 --> 36:15.160]  память.
[36:15.160 --> 36:17.160]  То же самое могу делать
[36:17.160 --> 36:19.160]  тут есть union-like classes,
[36:19.160 --> 36:21.160]  но это какая-то довольно
[36:21.160 --> 36:23.160]  устаревшая штука.
[36:23.160 --> 36:25.160]  Так вот,
[36:25.160 --> 36:27.160]  если я это в полях объявляю, то у меня
[36:27.160 --> 36:29.160]  появляется как бы два поля,
[36:29.160 --> 36:31.160]  одновременно вот такое поле, я блок,
[36:31.160 --> 36:33.160]  elbuff и emulogic paste, и при этом
[36:33.160 --> 36:35.160]  они оба...
[36:35.160 --> 36:37.160]  Ну, при этом они шерят
[36:37.160 --> 36:39.160]  одно и то же место в памяти.
[36:39.160 --> 36:41.160]  А что это за ена
[36:41.160 --> 36:43.160]  шедевральна?
[36:43.160 --> 36:45.160]  А...
[36:45.160 --> 36:47.160]  Я не знаю, почему это ена,
[36:47.160 --> 36:49.160]  это просто константа, которая...
[36:49.160 --> 36:51.160]  Не знаю, честно, почему это ена
[36:51.160 --> 36:53.160]  сделана, но это константа,
[36:53.160 --> 36:55.160]  которая...
[36:55.160 --> 36:57.160]  В области видимости, то есть просто
[36:57.160 --> 36:59.160]  сериал ена мы получим то же самое.
[36:59.160 --> 37:01.160]  Нет.
[37:01.160 --> 37:03.160]  Объявление константы.
[37:03.160 --> 37:05.160]  Ну ладно. Я не знаю, почему это в виде
[37:05.160 --> 37:07.160]  ена мы сделана, но
[37:07.160 --> 37:09.160]  просто да, у меня такая константа 15 делить
[37:09.160 --> 37:11.160]  на sizers чарты, но то есть
[37:11.160 --> 37:13.160]  в случае чара обычного это будет 15.
[37:13.160 --> 37:15.160]  Вот, и
[37:15.160 --> 37:17.160]  эта константа используется для
[37:17.160 --> 37:19.160]  объявления вот этого массива, то есть у меня
[37:19.160 --> 37:21.160]  union из двух вещей,
[37:21.160 --> 37:23.160]  localbuff размера 16,
[37:23.160 --> 37:25.160]  а еще с свойства allocatedcapacity.
[37:25.160 --> 37:27.160]  Соответственно размер этого
[37:27.160 --> 37:29.160]  union 16.
[37:29.160 --> 37:31.160]  Так вот, что такое small string optimization?
[37:31.160 --> 37:33.160]  Идея в том, что
[37:33.160 --> 37:35.160]  если строка у вас короткая,
[37:35.160 --> 37:37.160]  короче, чем размер
[37:37.160 --> 37:39.160]  полей, которые нужно, чтобы ее хранить,
[37:39.160 --> 37:41.160]  ну вот, у вас есть
[37:41.160 --> 37:43.160]  строка, у нее обычно
[37:43.160 --> 37:45.160]  есть указатель
[37:45.160 --> 37:47.160]  на начало там sizecapacity.
[37:47.160 --> 37:49.160]  Если у вас строка
[37:49.160 --> 37:51.160]  размера 8, скажем,
[37:51.160 --> 37:53.160]  то ее можно
[37:53.160 --> 37:55.160]  всю целиком поместить
[37:55.160 --> 37:57.160]  в ту память, в которой вы указатель хранили.
[37:57.160 --> 37:59.160]  Вам не нужно алоцировать
[37:59.160 --> 38:01.160]  через new
[38:01.160 --> 38:03.160]  динамической памяти
[38:03.160 --> 38:05.160]  пространство для этой строки,
[38:05.160 --> 38:07.160]  вы можете прямо на стеке ее положить.
[38:07.160 --> 38:09.160]  А вот там pointer
[38:09.160 --> 38:11.160]  он всегда существует.
[38:11.160 --> 38:13.160]  Какой pointer?
[38:13.160 --> 38:15.160]  Ну вот там, чуть-чуть выше,
[38:15.160 --> 38:17.160]  pointer and the action data.
[38:17.160 --> 38:19.160]  Да.
[38:19.160 --> 38:21.160]  Есть, значит, pointer.
[38:21.160 --> 38:23.160]  Давайте посмотрим на вот эту структуру.
[38:23.160 --> 38:25.160]  Значит, я не буду сейчас
[38:25.160 --> 38:27.160]  говорить про то, что такое log-hider.
[38:27.160 --> 38:29.160]  Ну, в общем...
[38:29.160 --> 38:31.160]  А, а там to do есть?
[38:31.160 --> 38:33.160]  Ну, может потом как-нибудь поговорим.
[38:33.160 --> 38:35.160]  Что там?
[38:35.160 --> 38:37.160]  To do в коде.
[38:39.160 --> 38:41.160]  Это нормально.
[38:41.160 --> 38:43.160]  В кодис на библиотеке часто бывает to do,
[38:43.160 --> 38:45.160]  это нормально.
[38:45.160 --> 38:47.160]  Ну, короче говоря,
[38:47.160 --> 38:49.160]  там эта структура,
[38:49.160 --> 38:51.160]  она наследуется от локатора,
[38:51.160 --> 38:53.160]  то есть
[38:53.160 --> 38:55.160]  фактически получается,
[38:55.160 --> 38:57.160]  что у вас есть локатор
[38:57.160 --> 38:59.160]  и к нему еще более pointer добавлено.
[38:59.160 --> 39:01.160]  Ну, зачем
[39:01.160 --> 39:03.160]  это сделано, чтобы если локатор пустой,
[39:03.160 --> 39:05.160]  например, STD-локатор,
[39:05.160 --> 39:07.160]  то он вместо лишнего не занимал,
[39:07.160 --> 39:09.160]  потому что когда вы наследуете пустого класса,
[39:09.160 --> 39:11.160]  у вас лишних багging добавляется.
[39:11.160 --> 39:13.160]  Это называется empty-base-optimization.
[39:13.160 --> 39:15.160]  Это гениально.
[39:15.160 --> 39:17.160]  Потому что если бы я
[39:17.160 --> 39:19.160]  положил локатор как поле отдельное,
[39:19.160 --> 39:21.160]  то оно бы занимало лишний,
[39:21.160 --> 39:23.160]  а из-за пейдинга оно бы занимало целых 8.
[39:23.160 --> 39:25.160]  Я понимаю, почему
[39:25.160 --> 39:27.160]  человек в стрим...
[39:27.160 --> 39:29.160]  Код?
[39:29.160 --> 39:31.160]  Нет.
[39:31.160 --> 39:33.160]  Почему он там бугуктит на комитете?
[39:33.160 --> 39:35.160]  Я понял.
[39:35.160 --> 39:37.160]  Короче, это довольно
[39:37.160 --> 39:39.160]  распространенная техника,
[39:39.160 --> 39:41.160]  кстати, в Sherriff PTR, и она тоже используется в Australian.
[39:41.160 --> 39:43.160]  Но вам не надо.
[39:43.160 --> 39:45.160]  Так вот, pointer
[39:45.160 --> 39:47.160]  pointer, собственно, указывает
[39:47.160 --> 39:49.160]  на данные строки.
[39:51.160 --> 39:53.160]  Так вот, этот pointer
[39:53.160 --> 39:55.160]  он указывает либо
[39:55.160 --> 39:57.160]  на выделенную память,
[39:57.160 --> 39:59.160]  либо
[39:59.160 --> 40:01.160]  на...
[40:01.160 --> 40:03.160]  на юнион.
[40:03.160 --> 40:05.160]  И как мы проверяем,
[40:05.160 --> 40:07.160]  у нас сейчас
[40:07.160 --> 40:09.160]  строка выделена на стеке
[40:09.160 --> 40:11.160]  или на куче.
[40:11.160 --> 40:13.160]  Если этот pointer
[40:13.160 --> 40:15.160]  равен адресу вот этого вот
[40:15.160 --> 40:17.160]  поля,
[40:17.160 --> 40:19.160]  то значит, строка выделена на куче,
[40:19.160 --> 40:21.160]  и тогда нам не нужно
[40:21.160 --> 40:23.160]  capacity.
[40:23.160 --> 40:25.160]  А если она
[40:25.160 --> 40:27.160]  выделена на куче, тогда вот здесь
[40:27.160 --> 40:29.160]  активен член capacity,
[40:29.160 --> 40:31.160]  а pointer указывает на адрес, где
[40:31.160 --> 40:33.160]  она выделена.
[40:33.160 --> 40:35.160]  Понятно? То есть мы экономим
[40:35.160 --> 40:37.160]  один им, фактически.
[40:37.160 --> 40:39.160]  То есть вот capacity может
[40:39.160 --> 40:41.160]  быть поширена с
[40:41.160 --> 40:43.160]  локальным буфером.
[40:43.160 --> 40:45.160]  Ну один...
[40:45.160 --> 40:47.160]  Это не им, это лонг.
[40:47.160 --> 40:49.160]  А, да, один с айс-т, да.
[40:49.160 --> 40:51.160]  То есть 8 чаров.
[40:51.160 --> 40:53.160]  Это нихрена себе.
[40:53.160 --> 40:55.160]  Сейчас, только единственное, что меня смущает,
[40:55.160 --> 40:57.160]  то локаль бафт занимает 16 байтов, а айс-т
[40:57.160 --> 40:59.160]  занимает 8.
[40:59.160 --> 41:01.160]  Ну,
[41:01.160 --> 41:03.160]  смотрите, мы уже сэкономили 8 байт
[41:03.160 --> 41:05.160]  на локаторе.
[41:05.160 --> 41:07.160]  Можно эти 8 байт, так сказать,
[41:07.160 --> 41:09.160]  и занять по поводу.
[41:09.160 --> 41:11.160]  Почему мы в юнио локатора
[41:11.160 --> 41:13.160]  не положили?
[41:15.160 --> 41:17.160]  Так, это называется
[41:17.160 --> 41:19.160]  small string optimization.
[41:19.160 --> 41:21.160]  За счет этого стандартная строка работает
[41:21.160 --> 41:23.160]  гораздо быстрее, чем
[41:23.160 --> 41:25.160]  ну, может, не гораздо быстрее.
[41:25.160 --> 41:27.160]  Нет, не быстрее, именно экономия
[41:27.160 --> 41:29.160]  по памяти.
[41:29.160 --> 41:31.160]  Нет, это экономия времени
[41:31.160 --> 41:33.160]  в первую очередь. Главное здесь
[41:33.160 --> 41:35.160]  экономия времени, именно экономия эффективности.
[41:35.160 --> 41:37.160]  То, что ты сэкономил 8 байт,
[41:37.160 --> 41:39.160]  это не так важно. Важно то, что если твоя строка
[41:39.160 --> 41:41.160]  короткая, тебе не придется в локацию
[41:41.160 --> 41:43.160]  делать один ее.
[41:43.160 --> 41:45.160]  Вот, и это на самом деле
[41:45.160 --> 41:47.160]  очень...
[41:47.160 --> 41:49.160]  Ну, такая популярная штука, а это
[41:49.160 --> 41:51.160]  во всех.
[41:51.160 --> 41:53.160]  Ну, может, и прямо во всех,
[41:53.160 --> 41:55.160]  но, значит,
[41:55.160 --> 41:57.160]  во многих классах.
[41:57.160 --> 41:59.160]  Ну, странно, если
[41:59.160 --> 42:01.160]  он во многих, что-то в каком-то векторе...
[42:01.160 --> 42:03.160]  Ну, во многих можно
[42:03.160 --> 42:05.160]  и вектори использовать.
[42:05.160 --> 42:07.160]  Ну, почему эмо локаиры копальтики
[42:07.160 --> 42:09.160]  это же просто число.
[42:09.160 --> 42:11.160]  Да.
[42:11.160 --> 42:13.160]  LocalBug это все такие
[42:13.160 --> 42:15.160]  и не поможет.
[42:15.160 --> 42:17.160]  Жива?
[42:17.160 --> 42:19.160]  Сейчас. Ну, смотри.
[42:19.160 --> 42:21.160]  Красавчик, тебе нужно
[42:21.160 --> 42:23.160]  лишь одно из двух.
[42:23.160 --> 42:25.160]  Тебе нужен всегда либо LocalBuffer,
[42:25.160 --> 42:27.160]  либо Capacity число.
[42:27.160 --> 42:29.160]  А одновременно они оба не нужны.
[42:29.160 --> 42:31.160]  Capacity...
[42:31.160 --> 42:33.160]  AllocatedCapacity это обычная Capacity
[42:33.160 --> 42:35.160]  сфера.
[42:35.160 --> 42:37.160]  Это штука, где ты хранишь
[42:37.160 --> 42:39.160]  строку на стеке, если она слишком короткая.
[42:39.160 --> 42:41.160]  То есть, я
[42:41.160 --> 42:43.160]  объединил... Если у тебя
[42:43.160 --> 42:45.160]  строка
[42:45.160 --> 42:47.160]  переменной для хранения Capacity,
[42:47.160 --> 42:49.160]  ты хранишь на одном и том же месте
[42:49.160 --> 42:51.160]  с LocalBuffer. Если твоя строка короткая,
[42:51.160 --> 42:53.160]  то тебе не надо помнить Capacity,
[42:53.160 --> 42:55.160]  потому что ты его знаешь и так, какое оно.
[42:55.160 --> 42:57.160]  И вот те байты, которые
[42:57.160 --> 42:59.160]  под Capacity ты расходовал,
[42:59.160 --> 43:01.160]  ты можешь занять LocalBuffer как раз.
[43:01.160 --> 43:03.160]  Какая это...
[43:03.160 --> 43:05.160]  Он каждый раз и файт?
[43:05.160 --> 43:07.160]  Нет, он просто...
[43:07.160 --> 43:09.160]  Он по пойтеру обращается.
[43:09.160 --> 43:11.160]  Он просто по пойтеру обращается, да.
[43:11.160 --> 43:13.160]  А как он поймет? Он сейчас вот, я не понял,
[43:13.160 --> 43:15.160]  как мы понимаем...
[43:15.160 --> 43:17.160]  Как он понимает, что
[43:17.160 --> 43:19.160]  есть что и когда...
[43:19.160 --> 43:21.160]  Ну давайте, давайте...
[43:21.160 --> 43:23.160]  Указывает ли пойтер на юниору или нет?
[43:23.160 --> 43:25.160]  Так...
[43:25.160 --> 43:27.160]  Не, он не может... Типа, он всегда должен быть указан на юниору.
[43:27.160 --> 43:29.160]  Нет, он может
[43:29.160 --> 43:31.160]  на кучу указывать. Давайте посмотрим, как
[43:31.160 --> 43:33.160]  диструктор работает. Есть функция
[43:33.160 --> 43:35.160]  R-Sport. У тебя еще. У тебя юниор делит переменную,
[43:35.160 --> 43:37.160]  которая отвечает за реальный Capacity,
[43:37.160 --> 43:39.160]  если строка большая, или
[43:39.160 --> 43:41.160]  Buffer. Ну...
[43:41.160 --> 43:43.160]  Вот как работает диструктор.
[43:43.160 --> 43:45.160]  Надо что-то одно из двух знать.
[43:45.160 --> 43:47.160]  Как ты будешь понимать, что есть что?
[43:47.160 --> 43:49.160]  Если твой указатель,
[43:49.160 --> 43:51.160]  который ты отдельно хранишь, указывает на юниор,
[43:51.160 --> 43:53.160]  значит... Он всегда указывает на юниор?
[43:53.160 --> 43:55.160]  Нет!
[43:55.160 --> 43:57.160]  Еще раз, у вас перьюниор
[43:57.160 --> 43:59.160]  хранит либо Capacity, либо Buffer.
[43:59.160 --> 44:01.160]  Он всегда должен быть, наверное.
[44:01.160 --> 44:03.160]  У тебя кроме этого есть указатель. Есть указатель
[44:03.160 --> 44:05.160]  отдельный, просто PTR.
[44:05.160 --> 44:07.160]  У тебя есть пойтер. МПМ
[44:07.160 --> 44:09.160]  называется.
[44:09.160 --> 44:11.160]  Вот, блин, ну ты
[44:11.160 --> 44:13.160]  вспомни свою строку. У тебя есть
[44:13.160 --> 44:15.160]  пойтер,
[44:15.160 --> 44:17.160]  Size и Capacity.
[44:17.160 --> 44:19.160]  Пойтер остается,
[44:19.160 --> 44:21.160]  Size остается, а Capacity
[44:21.160 --> 44:23.160]  заменяется на юниор.
[44:23.160 --> 44:25.160]  Либо Capacity, либо
[44:25.160 --> 44:27.160]  Char, Massage Char.
[44:29.160 --> 44:31.160]  Соответственно, твой пойтер,
[44:31.160 --> 44:33.160]  если твоя строка короткая,
[44:33.160 --> 44:35.160]  то тебе не нужно Capacity.
[44:35.160 --> 44:37.160]  И ты на вот тех байках,
[44:37.160 --> 44:39.160]  на которых бы ты хранил Capacity, хранишь саму строку.
[44:39.160 --> 44:41.160]  И твой
[44:41.160 --> 44:43.160]  пойтер тогда указывает на это
[44:43.160 --> 44:45.160]  поле. Вот на это самое, которое было
[44:45.160 --> 44:47.160]  в ЭКПС, ты на самом деле сейчас со мной хранил
[44:47.160 --> 44:49.160]  Char.
[44:49.160 --> 44:51.160]  А если твоя строка длиннее,
[44:51.160 --> 44:53.160]  чем позволяет хранить эта
[44:53.160 --> 44:55.160]  штука, то твой пойтер,
[44:55.160 --> 44:57.160]  как в обычной строке,
[44:57.160 --> 44:59.160]  как в той, которую вы писали, делает
[44:59.160 --> 45:01.160]  U, и пойтер указывает куда-то во мне.
[45:01.160 --> 45:03.160]  Тогда ты понимаешь, что
[45:03.160 --> 45:05.160]  раз пойтер указывает не на моем поле,
[45:05.160 --> 45:07.160]  значит строка выняли на кучу,
[45:07.160 --> 45:09.160]  значит, на тех байках лежит Capacity,
[45:09.160 --> 45:11.160]  а не Char.
[45:15.160 --> 45:17.160]  Если она все еще умещается,
[45:17.160 --> 45:19.160]  то нормально, а если она не перестала
[45:19.160 --> 45:21.160]  участвовать, то реалацирует.
[45:27.160 --> 45:29.160]  Кто понял,
[45:29.160 --> 45:31.160]  как работает Small String Optimization?
[45:37.160 --> 45:39.160]  М из Local.
[45:39.160 --> 45:41.160]  Это я показываю,
[45:41.160 --> 45:43.160]  как работает Диструктор.
[45:43.160 --> 45:45.160]  Диструктор
[45:45.160 --> 45:47.160]  просто вызывает функцию
[45:47.160 --> 45:49.160]  fDispose, а функцию fDispose проверяет,
[45:49.160 --> 45:51.160]  если не m из Local, то fDestroy.
[45:51.160 --> 45:53.160]  Ну, понятно, что fDestroy.
[45:53.160 --> 45:55.160]  А m из Local вот.
[45:55.160 --> 45:57.160]  Ну вот, собственно,
[45:57.160 --> 45:59.160]  mData равно mLocalData.
[45:59.160 --> 46:01.160]  mLocalData вам просто вернет указатель
[46:01.160 --> 46:03.160]  на то самое поле, а mData вернет...
[46:03.160 --> 46:05.160]  Ну давайте.
[46:05.160 --> 46:07.160]  Ну давайте проверим.
[46:07.160 --> 46:09.160]  Кстати, можно догадаться, почему
[46:09.160 --> 46:11.160]  оно так называется.
[46:13.160 --> 46:15.160]  Вот mLocalData.
[46:15.160 --> 46:17.160]  Значит, что она возвращает?
[46:17.160 --> 46:19.160]  Ну она просто возвращает
[46:19.160 --> 46:21.160]  pointer на LocalBuffer.
[46:21.160 --> 46:23.160]  А mData
[46:23.160 --> 46:25.160]  возвращает
[46:25.160 --> 46:27.160]  тот pointer, который
[46:27.160 --> 46:29.160]  в, ну вот, собственно, наш pointer.
[46:31.160 --> 46:33.160]  Ну все,
[46:33.160 --> 46:35.160]  мы просто проверяем.
[46:35.160 --> 46:37.160]  Можешь еще
[46:37.160 --> 46:39.160]  диструктор показать?
[46:39.160 --> 46:41.160]  Какой из десяти?
[46:41.160 --> 46:43.160]  Я про то, что если мы пишем
[46:43.160 --> 46:45.160]  в кавычках
[46:45.160 --> 46:47.160]  abc, это вот,
[46:47.160 --> 46:49.160]  это что? Это литерал.
[46:49.160 --> 46:51.160]  Типа const char звездочки.
[46:51.160 --> 46:53.160]  А где, собственно, этот,
[46:53.160 --> 46:55.160]  где, собственно, сам этот литерал
[46:55.160 --> 46:57.160]  лежит в статической памяти?
[46:57.160 --> 46:59.160]  Ну да.
[46:59.160 --> 47:01.160]  То есть small string
[47:01.160 --> 47:03.160]  optimization не применяется.
[47:03.160 --> 47:05.160]  Или копируется.
[47:05.160 --> 47:07.160]  Ну мы его скопируем просто.
[47:07.160 --> 47:09.160]  А, ну да.
[47:09.160 --> 47:11.160]  Мы не можем
[47:11.160 --> 47:13.160]  указывать.
[47:13.160 --> 47:15.160]  Указывать можем, изменить нельзя.
[47:15.160 --> 47:17.160]  В смысле, мы не можем просто указывать
[47:17.160 --> 47:19.160]  и надеяться, что мы отлично сработаем.
[47:19.160 --> 47:21.160]  Так, окей, отлично. Мы разобрались,
[47:21.160 --> 47:23.160]  как работает small string optimization на строках.
[47:25.160 --> 47:27.160]  Хорошо.
[47:27.160 --> 47:29.160]  Следующий пункт
[47:29.160 --> 47:31.160]  это, знаете что?
[47:31.160 --> 47:33.160]  Это realization of the function.
[47:37.160 --> 47:39.160]  Кроме
[47:39.160 --> 47:41.160]  std string,
[47:41.160 --> 47:43.160]  следующий,
[47:43.160 --> 47:45.160]  ну другой класс, который
[47:45.160 --> 47:47.160]  существенно использует small,
[47:47.160 --> 47:49.160]  не string, а small object optimization,
[47:49.160 --> 47:51.160]  это std function как раз.
[47:51.160 --> 47:53.160]  И там это важно
[47:53.160 --> 47:55.160]  очень.
[47:55.160 --> 47:57.160]  Давайте вспомним,
[47:57.160 --> 47:59.160]  что такое std function?
[47:59.160 --> 48:11.160]  А,
[48:11.160 --> 48:13.160]  надо было на прошлые пары ходить.
[48:13.160 --> 48:15.160]  Ну ладно.
[48:15.160 --> 48:17.160]  Значит, что std function
[48:17.160 --> 48:19.160]  должно делать? Оно нужно
[48:19.160 --> 48:21.160]  хранить в себе указатель
[48:21.160 --> 48:23.160]  на,
[48:23.160 --> 48:25.160]  ну давайте, значит,
[48:25.160 --> 48:27.160]  наверное, это прям закрою.
[48:27.160 --> 48:29.160]  И, честно, сейчас я попробую написать
[48:29.160 --> 48:31.160]  некоторое подобие std function.
[48:33.160 --> 48:35.160]  Я решил в этом году
[48:35.160 --> 48:37.160]  function не делать задачей,
[48:37.160 --> 48:39.160]  потому что кажется, что
[48:39.160 --> 48:41.160]  мы ее прям,
[48:41.160 --> 48:43.160]  ну, мы ее почти реализуем и так.
[48:43.160 --> 48:45.160]  Тут интересно очень.
[48:45.160 --> 48:47.160]  А какая пятая задача?
[48:47.160 --> 48:49.160]  А...
[48:49.160 --> 48:51.160]  Typeist будет.
[48:51.160 --> 48:53.160]  Шаблонное метапрограммирование будет
[48:53.160 --> 48:55.160]  как кольненькое.
[48:55.160 --> 48:57.160]  Ну, увидите.
[48:57.160 --> 48:59.160]  Возможно,
[48:59.160 --> 49:01.160]  возможно, я
[49:01.160 --> 49:03.160]  позову Рому
[49:03.160 --> 49:05.160]  в санду, который...
[49:05.160 --> 49:07.160]  Ого.
[49:07.160 --> 49:09.160]  Ну, в общем, да, у нас был
[49:09.160 --> 49:11.160]  на физике пульс по шаблонным метапрограммированию
[49:11.160 --> 49:13.160]  отдельный, я чем-нибудь это возможно,
[49:13.160 --> 49:15.160]  чем-нибудь он расскажет на последних
[49:15.160 --> 49:17.160]  парах.
[49:17.160 --> 49:19.160]  Не знаю, посмотрим.
[49:19.160 --> 49:21.160]  Значит, смотрите, я хочу реализовать
[49:21.160 --> 49:23.160]  function.
[49:31.160 --> 49:33.160]  Давайте по...
[49:33.160 --> 49:35.160]  Рассуждаем, пообсуждаем,
[49:35.160 --> 49:37.160]  как должна быть она устроена,
[49:37.160 --> 49:39.160]  но, видимо, мы уже сегодня...
[49:39.160 --> 49:41.160]  Ну, мы сейчас целиком ее не реализуем,
[49:41.160 --> 49:43.160]  но мы реализуем как бы...
[49:43.160 --> 49:45.160]  Ну, основные идеи мы изложим,
[49:45.160 --> 49:47.160]  а там завтра, видимо,
[49:47.160 --> 49:49.160]  мы когда-то делаем
[49:49.160 --> 49:51.160]  уже еще там оптимизированную
[49:51.160 --> 49:53.160]  некую версию.
[49:55.160 --> 49:57.160]  Значит, во-первых...
[49:57.160 --> 49:59.160]  Во-первых, я говорю...
[49:59.160 --> 50:01.160]  А, ну, давайте
[50:01.160 --> 50:03.160]  скажу, что у меня есть мое
[50:03.160 --> 50:05.160]  пространство имен, чтобы они там
[50:05.160 --> 50:07.160]  коллектовались со стандартным.
[50:07.160 --> 50:09.160]  Ну, давайте я скажу, что у меня есть
[50:09.160 --> 50:11.160]  function,
[50:11.160 --> 50:13.160]  который без определения,
[50:13.160 --> 50:15.160]  и теперь есть
[50:19.160 --> 50:21.160]  вот такая вот
[50:21.160 --> 50:23.160]  специализация,
[50:25.160 --> 50:27.160]  вот от таких шаблонных параметров.
[50:29.160 --> 50:31.160]  И вот ее-то мы будем реализовывать.
[50:33.160 --> 50:35.160]  Res — это то, что возвращается.
[50:35.160 --> 50:37.160]  Да, возвращаем идти
[50:37.160 --> 50:39.160]  под принимаемых аргументов.
[50:39.160 --> 50:41.160]  Секунду, почему мы могли так объявить
[50:41.160 --> 50:43.160]  и сделать эту специализацию?
[50:43.160 --> 50:45.160]  Это обычная специализация?
[50:45.160 --> 50:47.160]  Это специализация.
[50:47.160 --> 50:49.160]  Секунду, там был один type-name,
[50:49.160 --> 50:51.160]  а тут их как-то...
[50:51.160 --> 50:53.160]  Какая разница? Нет, минуточку.
[50:53.160 --> 50:55.160]  Забыл отработать со шаблонов, видимо.
[50:55.160 --> 50:57.160]  Я могу сколько угодно.
[50:59.160 --> 51:01.160]  У меня есть...
[51:01.160 --> 51:03.160]  Это не выглядит как специализация тоже сверху.
[51:03.160 --> 51:05.160]  Может быть, на 3 точно же настаивать какой-нибудь?
[51:05.160 --> 51:07.160]  Да, слушай, ты, наверное, прав.
[51:07.160 --> 51:09.160]  Ну, давай я, наверное, вот так скажу.
[51:09.160 --> 51:11.160]  Вот так, наверное.
[51:13.160 --> 51:15.160]  Ничего не забывал.
[51:15.160 --> 51:17.160]  Ладно, хорошо.
[51:17.160 --> 51:19.160]  Не, наверное, так я сам тоже обработал,
[51:19.160 --> 51:21.160]  но вот так было бы правильнее.
[51:21.160 --> 51:23.160]  То есть, function от
[51:23.160 --> 51:25.160]  произвольного набора типов —
[51:25.160 --> 51:27.160]  это вещь без определения.
[51:29.160 --> 51:31.160]  Function вот от такого странного
[51:31.160 --> 51:33.160]  поднабора — это вот что.
[51:33.160 --> 51:35.160]  Так.
[51:35.160 --> 51:37.160]  Значит, мы хотим реализовать
[51:37.160 --> 51:39.160]  функцию...
[51:39.160 --> 51:41.160]  Значит, правила.
[51:41.160 --> 51:43.160]  Мы хотим применить
[51:43.160 --> 51:45.160]  Typerager.
[51:47.160 --> 51:49.160]  Что мы хотим сделать?
[51:51.160 --> 51:53.160]  Ну, что нам надо хранить? Вот function.
[51:53.160 --> 51:55.160]  Что будет в поляне?
[51:57.160 --> 51:59.160]  Нужно хранить объект, который...
[51:59.160 --> 52:01.160]  Наш муссальный объект, в общем-то, хранить
[52:01.160 --> 52:03.160]  может каким-то образом в конечном счете.
[52:03.160 --> 52:05.160]  Нет, сам объект мы храним не в конечном счете.
[52:05.160 --> 52:07.160]  Нет, указатель мы будем хранить слишком большим.
[52:07.160 --> 52:09.160]  На control-блок.
[52:09.160 --> 52:11.160]  Ну, не совсем на control-блок.
[52:11.160 --> 52:13.160]  Так, сейчас.
[52:13.160 --> 52:15.160]  Как у Strider Typer... Мы должны...
[52:15.160 --> 52:17.160]  Мы применяем ту же идею, которая была при
[52:17.160 --> 52:19.160]  реализации Any.
[52:19.160 --> 52:21.160]  У нас есть какой-то... У нас был
[52:21.160 --> 52:23.160]  kind of...
[52:23.160 --> 52:25.160]  StructBase, virtual destructor.
[52:25.160 --> 52:27.160]  Да, мы делаем
[52:27.160 --> 52:29.160]  структуру Base,
[52:31.160 --> 52:33.160]  у которой виртуальный
[52:37.160 --> 52:39.160]  destructor.
[52:39.160 --> 52:41.160]  У Any, наверное, должны быть виртуальные
[52:41.160 --> 52:43.160]  операторы круглоскопички, что могли вызывать.
[52:43.160 --> 52:45.160]  Или что-нибудь такое.
[52:45.160 --> 52:47.160]  Или функция Call.
[52:47.160 --> 52:49.160]  Ну, у нее там много чего...
[52:49.160 --> 52:51.160]  У нее, на самом деле, должно быть
[52:51.160 --> 52:53.160]  функции...
[52:53.160 --> 52:55.160]  Ну, у нее должна быть функция Copy,
[52:55.160 --> 52:57.160]  которая...
[52:57.160 --> 52:59.160]  Давайте скажем. Давайте скажем
[52:59.160 --> 53:01.160]  virtual res call
[53:03.160 --> 53:05.160]  const или не const?
[53:05.160 --> 53:07.160]  Мы хотим, чтобы можно было что
[53:07.160 --> 53:09.160]  угодно сделать, поэтому не
[53:09.160 --> 53:11.160]  const, видимо.
[53:11.160 --> 53:13.160]  А мы хотим иногда const.
[53:13.160 --> 53:15.160]  А что const function
[53:15.160 --> 53:17.160]  умеет? Он не умеет меняться, но он умеет
[53:17.160 --> 53:19.160]  хранить и вызывать. Значит, надо const.
[53:19.160 --> 53:21.160]  Наверное.
[53:21.160 --> 53:23.160]  Ну, а что если мы захотим
[53:23.160 --> 53:25.160]  присвоить ей объект, у которого
[53:25.160 --> 53:27.160]  круглоскопички не ограничены const?
[53:27.160 --> 53:29.160]  Нормально или нет?
[53:29.160 --> 53:31.160]  Ну, нам придется...
[53:31.160 --> 53:33.160]  У нас же будет член, который
[53:33.160 --> 53:35.160]  в геральде будет лежать
[53:35.160 --> 53:37.160]  объект,
[53:37.160 --> 53:39.160]  у которого будут круглые скопочки,
[53:39.160 --> 53:41.160]  и мы будем
[53:41.160 --> 53:43.160]  их вызывать, а они будут не константны.
[53:43.160 --> 53:45.160]  Ну, да вызывай ему mutable.
[53:45.160 --> 53:47.160]  const нам придется здесь не
[53:47.160 --> 53:49.160]  писать.
[53:49.160 --> 53:51.160]  Плохо, потому что...
[53:51.160 --> 53:53.160]  Чего?
[53:53.160 --> 53:55.160]  А почему не назвать mutable?
[53:55.160 --> 53:57.160]  Ну, типа...
[53:57.160 --> 53:59.160]  Если у него нечаянно констанен к
[53:59.160 --> 54:01.160]  не конст, у него могут вызваться не те круглые
[54:01.160 --> 54:03.160]  скопочки. Ну, а по логике вещей,
[54:03.160 --> 54:05.160]  какой у нас
[54:07.160 --> 54:09.160]  этот метод относительно класса B?
[54:09.160 --> 54:11.160]  Давайте просто поймем
[54:11.160 --> 54:13.160]  с точки зрения выяснения, этот метод константный
[54:13.160 --> 54:15.160]  или нет? Нет, потому что он может менять
[54:15.160 --> 54:17.160]  поля. Правда же? Он же может менять поля.
[54:17.160 --> 54:19.160]  Ну, так, вообще проверка.
[54:19.160 --> 54:21.160]  Поэтому я бы конст не писал. Но это на самом деле
[54:21.160 --> 54:23.160]  действительно большая проблема. Вот в std
[54:23.160 --> 54:25.160]  function есть проблемы с константностью
[54:25.160 --> 54:27.160]  по этой, потому что вы можете туда
[54:27.160 --> 54:29.160]  положить функцию, которая
[54:31.160 --> 54:33.160]  помечена как
[54:33.160 --> 54:35.160]  конст,
[54:35.160 --> 54:37.160]  но здесь константность
[54:37.160 --> 54:39.160]  потеряется. Сейчас, если у
[54:39.160 --> 54:41.160]  меня есть два оператора круглые скопочки
[54:41.160 --> 54:43.160]  с одинаковыми всем,
[54:43.160 --> 54:45.160]  кроме последнего слова конст,
[54:45.160 --> 54:47.160]  он может вызвать не то?
[54:47.160 --> 54:49.160]  Вот...
[54:49.160 --> 54:51.160]  Сходу не скажу,
[54:51.160 --> 54:53.160]  но знаю, что есть этим проблема
[54:53.160 --> 54:55.160]  у нас std function, не уверен.
[54:55.160 --> 54:57.160]  Давайте сейчас
[54:57.160 --> 54:59.160]  что-нибудь напишем, а дальше поймем, откуда работает
[54:59.160 --> 55:01.160]  сравним.
[55:01.160 --> 55:03.160]  Ну, короче, вот у нас и будет функция call,
[55:03.160 --> 55:05.160]  и у нас еще будет функция
[55:07.160 --> 55:09.160]  ну, копия.
[55:09.160 --> 55:11.160]  Скажите, а могли ли мы
[55:11.160 --> 55:13.160]  объявить виртуальный оператор?
[55:13.160 --> 55:15.160]  Конечно. А почему мы
[55:15.160 --> 55:17.160]  не сделали?
[55:17.160 --> 55:19.160]  Ну, можно.
[55:19.160 --> 55:21.160]  Для унификации, наверное.
[55:23.160 --> 55:25.160]  Да, здесь args нужно.
[55:25.160 --> 55:27.160]  Логично.
[55:27.160 --> 55:29.160]  Те же самые args. Да, логично.
[55:33.160 --> 55:35.160]  И он чисто виртуальный,
[55:35.160 --> 55:37.160]  потому что у base ничего вызвать нельзя.
[55:37.160 --> 55:39.160]  Ну, еще будет virtual,
[55:39.160 --> 55:41.160]  base, звездочка,
[55:41.160 --> 55:43.160]  copy.
[55:47.160 --> 55:49.160]  А мы хотим так args принимать?
[55:49.160 --> 55:51.160]  Да, потому что
[55:51.160 --> 55:53.160]  когда мы вызываем,
[55:53.160 --> 55:55.160]  когда мы создаем function, мы явно указываем шаблонные
[55:55.160 --> 55:57.160]  инструменты, и это могут быть...
[55:57.160 --> 55:59.160]  если это с ссылки, то мы явно скажем, что это с ссылки.
[56:01.160 --> 56:03.160]  Я не о том, что там
[56:03.160 --> 56:05.160]  mov...
[56:05.160 --> 56:07.160]  Так mov это объекты, а это типы.
[56:07.160 --> 56:09.160]  Это типы, все отлично, я ужасно старый.
[56:09.160 --> 56:11.160]  Нам еще, наверное, нужно как-нибудь
[56:11.160 --> 56:13.160]  delete, типа делокей, функция.
[56:13.160 --> 56:15.160]  Нравится сама ссылка, конечно.
[56:15.160 --> 56:17.160]  Нам нужно будет, который себя удалит еще,
[56:17.160 --> 56:19.160]  потому что как мы его удалим?
[56:19.160 --> 56:21.160]  Так подожди.
[56:21.160 --> 56:23.160]  Это деструкторы.
[56:23.160 --> 56:25.160]  Давайте напишем, собственно, derived.
[56:25.160 --> 56:27.160]  Теперь у нас будет template
[56:27.160 --> 56:29.160]  type name что?
[56:31.160 --> 56:33.160]  То конкретный тип, который
[56:33.160 --> 56:35.160]  мы хотим, function, да.
[56:35.160 --> 56:37.160]  type name,
[56:37.160 --> 56:39.160]  struct derived,
[56:41.160 --> 56:43.160]  public base.
[56:45.160 --> 56:47.160]  И здесь мы будем хранить, собственно, function.
[56:49.160 --> 56:51.160]  И вот здесь мы определим все эти методы.
[56:53.160 --> 56:55.160]  Ну,
[56:57.160 --> 56:59.160]  наверное,
[56:59.160 --> 57:01.160]  деструктор нам
[57:01.160 --> 57:03.160]  сгодится.
[57:03.160 --> 57:05.160]  Обычный.
[57:05.160 --> 57:07.160]  Мы...
[57:07.160 --> 57:09.160]  Хорошо.
[57:09.160 --> 57:11.160]  Правда?
[57:11.160 --> 57:13.160]  Где мы будем...
[57:13.160 --> 57:15.160]  У нас же это будет хранить в климатической памяти?
[57:15.160 --> 57:17.160]  Или как?
[57:17.160 --> 57:19.160]  Да.
[57:19.160 --> 57:21.160]  Кто будет удалять?
[57:21.160 --> 57:23.160]  Да все.
[57:23.160 --> 57:25.160]  Оператор delete.
[57:25.160 --> 57:27.160]  А где?
[57:27.160 --> 57:29.160]  Он будет удалять base.
[57:29.160 --> 57:31.160]  Ну хорошо, да, нормально.
[57:31.160 --> 57:33.160]  Так.
[57:33.160 --> 57:35.160]  У нас есть еще что?
[57:35.160 --> 57:37.160]  Нам нужно оператор круглой скобочки реализовать.
[57:37.160 --> 57:39.160]  Значит, я пишу res,
[57:39.160 --> 57:41.160]  оператор
[57:41.160 --> 57:43.160]  круглой скобочки от args,
[57:43.160 --> 57:45.160]  override.
[57:47.160 --> 57:49.160]  Что мы должны здесь сделать?
[57:51.160 --> 57:53.160]  Только...
[57:53.160 --> 57:55.160]  с args именами уже.
[57:55.160 --> 57:57.160]  Да.
[57:57.160 --> 57:59.160]  И return.
[57:59.160 --> 58:01.160]  f от std forward.
[58:01.160 --> 58:03.160]  А вот std forward или просто args?
[58:05.160 --> 58:07.160]  std forward.
[58:07.160 --> 58:09.160]  Ну, он всегда...
[58:09.160 --> 58:11.160]  он же хуже не сделает.
[58:11.160 --> 58:13.160]  Ну,
[58:13.160 --> 58:15.160]  сложно.
[58:15.160 --> 58:17.160]  Дело в том, что
[58:17.160 --> 58:19.160]  args-то может быть
[58:19.160 --> 58:21.160]  само с амперсандами.
[58:21.160 --> 58:23.160]  Если вы std forward
[58:23.160 --> 58:25.160]  вызовете типа, к которому
[58:25.160 --> 58:27.160]  амперсанды навестите, то это вы сделаете, кажется,
[58:27.160 --> 58:29.160]  не то, что хотелось бы.
[58:29.160 --> 58:31.160]  Ну, args.
[58:31.160 --> 58:33.160]  У args, у типов args
[58:33.160 --> 58:35.160]  могут у самих быть двойные амперсанды.
[58:35.160 --> 58:37.160]  Может быть std
[58:37.160 --> 58:39.160]  еще что-нибудь?
[58:39.160 --> 58:41.160]  Похоже на forward, только не
[58:41.160 --> 58:43.160]  forward.
[58:43.160 --> 58:45.160]  New forward.
[58:45.160 --> 58:47.160]  New forward.
[58:47.160 --> 58:49.160]  Ну, можем пока лезть просто.
[58:49.160 --> 58:51.160]  А в чем еще раз проблема? Мы же всегда...
[58:51.160 --> 58:53.160]  Ну, мы хотим сделать backward forward.
[58:53.160 --> 58:55.160]  В чем проблема?
[58:55.160 --> 58:57.160]  Ну, если нам...
[58:57.160 --> 58:59.160]  давайте разберемся в случае. Допустим,
[58:59.160 --> 59:01.160]  мы не создали функцию res от
[59:01.160 --> 59:03.160]  просто t.
[59:03.160 --> 59:05.160]  Ну, пусть, не знаю, хорошо,
[59:05.160 --> 59:07.160]  s. s у меня есть какая-то структура.
[59:07.160 --> 59:09.160]  Вот мне сделали функцию, которая возвращает нам
[59:09.160 --> 59:11.160]  void от s.
[59:11.160 --> 59:13.160]  Тогда я по значению сюда
[59:13.160 --> 59:15.160]  приму.
[59:15.160 --> 59:17.160]  И по значению передам.
[59:17.160 --> 59:19.160]  Ну, так оно, наверное, и хотелось бы сделать.
[59:19.160 --> 59:21.160]  Ну, можно было бы еще...
[59:21.160 --> 59:23.160]  Да, хорошо, да.
[59:23.160 --> 59:25.160]  Вот. Если мне дали ссылку,
[59:29.160 --> 59:31.160]  то я должен...
[59:31.160 --> 59:33.160]  то я, получается, по ссылке приму.
[59:33.160 --> 59:35.160]  Вот это args, оно будет сам лезвие
[59:35.160 --> 59:37.160]  с одним амперсандом.
[59:37.160 --> 59:39.160]  И по ссылке
[59:39.160 --> 59:41.160]  же передам.
[59:41.160 --> 59:43.160]  Ну, это совсем не страшно.
[59:43.160 --> 59:45.160]  А у нас copy-illusion тут не сработает?
[59:45.160 --> 59:47.160]  Copy-illusion...
[59:47.160 --> 59:49.160]  сработано,
[59:49.160 --> 59:51.160]  но это не связанная история.
[59:51.160 --> 59:53.160]  Тут же мы пока про принимаем
[59:53.160 --> 59:55.160]  аргументы и возвращаем их.
[59:55.160 --> 59:57.160]  Нет, copy-illusion имеется в виду,
[59:57.160 --> 59:59.160]  что res, если я верну res,
[59:59.160 --> 01:00:01.160]  то он не скидывается.
[01:00:01.160 --> 01:00:03.160]  Ну, мы сейчас про
[01:00:03.160 --> 01:00:05.160]  принимаем аргументы говорим.
[01:00:05.160 --> 01:00:07.160]  А если я вызовусь,
[01:00:07.160 --> 01:00:09.160]  вот, ну, если
[01:00:09.160 --> 01:00:11.160]  lvalue или обычная копия,
[01:00:11.160 --> 01:00:13.160]  то нормально. А если мне передали
[01:00:13.160 --> 01:00:15.160]  rvalue ссылку,
[01:00:15.160 --> 01:00:17.160]  то что я сделаю?
[01:00:17.160 --> 01:00:19.160]  Просто передаешь ее по значению дальше.
[01:00:19.160 --> 01:00:21.160]  Почему по значению?
[01:00:21.160 --> 01:00:23.160]  Ну, потому что... Нет?
[01:00:23.160 --> 01:00:25.160]  Если функция принимает
[01:00:25.160 --> 01:00:27.160]  rvalue ссылку,
[01:00:27.160 --> 01:00:29.160]  то кажется, что это будет
[01:00:29.160 --> 01:00:31.160]  вообще CE.
[01:00:33.160 --> 01:00:35.160]  Потому что...
[01:00:35.160 --> 01:00:37.160]  Ну, смотрите, пусть у меня функтов
[01:00:37.160 --> 01:00:39.160]  принимает s, двойной отверсант.
[01:00:39.160 --> 01:00:41.160]  А я передам ему arcs
[01:00:41.160 --> 01:00:43.160]  просто так.
[01:00:43.160 --> 01:00:45.160]  А это же будет lvalue ссылку,
[01:00:45.160 --> 01:00:47.160]  я не смогу сбайнить.
[01:00:47.160 --> 01:00:49.160]  Ну, короче, проблема, да.
[01:00:51.160 --> 01:00:53.160]  Если мы не напишем move
[01:00:53.160 --> 01:00:55.160]  у штуки с двойной отверсантом,
[01:00:55.160 --> 01:00:57.160]  то они превратятся в обычные штуки
[01:00:57.160 --> 01:00:59.160]  и просто не примутся в функцию.
[01:01:01.160 --> 01:01:03.160]  Как наш случай
[01:01:03.160 --> 01:01:05.160]  отличается от всех предыдущих,
[01:01:05.160 --> 01:01:07.160]  потому что
[01:01:07.160 --> 01:01:09.160]  в использовании forward
[01:01:09.160 --> 01:01:11.160]  обычно вот так это выглядит.
[01:01:11.160 --> 01:01:13.160]  У меня arcs, оно без
[01:01:13.160 --> 01:01:15.160]  амперсантов. У меня
[01:01:15.160 --> 01:01:17.160]  на arcs навешаны два амперсанта сверху,
[01:01:17.160 --> 01:01:19.160]  а с forward я делаю arcs.
[01:01:19.160 --> 01:01:21.160]  А тут сами arcs,
[01:01:21.160 --> 01:01:23.160]  они с амперсантами могут быть.
[01:01:23.160 --> 01:01:25.160]  Если я forward сделаю от них,
[01:01:25.160 --> 01:01:27.160]  это будет странно.
[01:01:27.160 --> 01:01:29.160]  Мы же хотим, чтобы в функцию
[01:01:29.160 --> 01:01:31.160]  можно было принимать объекты по сути.
[01:01:31.160 --> 01:01:33.160]  Вот допустим, у нас есть
[01:01:33.160 --> 01:01:35.160]  среди arcs один с двумя амперсантами.
[01:01:35.160 --> 01:01:37.160]  Вот мы передали в оператора,
[01:01:37.160 --> 01:01:39.160]  и он здесь LV view.
[01:01:39.160 --> 01:01:41.160]  Тогда он просто не примет его.
[01:01:41.160 --> 01:01:43.160]  Будет CE.
[01:01:43.160 --> 01:01:45.160]  Я бы даже и сказал.
[01:01:45.160 --> 01:01:47.160]  Может сделать статикаст к arcs?
[01:01:47.160 --> 01:01:49.160]  А если будет LV view,
[01:01:49.160 --> 01:01:51.160]  то он скастует.
[01:01:51.160 --> 01:01:53.160]  А он скастует, статикаст умеет делать
[01:01:53.160 --> 01:01:55.160]  то же самое, что move?
[01:01:55.160 --> 01:01:57.160]  А, секундочку.
[01:01:59.160 --> 01:02:01.160]  Ну, кстати,
[01:02:01.160 --> 01:02:03.160]  может быть.
[01:02:03.160 --> 01:02:05.160]  Я, честно говоря,
[01:02:05.160 --> 01:02:07.160]  не думал о этим местом.
[01:02:07.160 --> 01:02:09.160]  Может быть, что и так.
[01:02:09.160 --> 01:02:11.160]  Давайте я так напишу.
[01:02:13.160 --> 01:02:15.160]  И
[01:02:15.160 --> 01:02:17.160]  я оставлю здесь to do.
[01:02:19.160 --> 01:02:21.160]  Вот так.
[01:02:27.160 --> 01:02:29.160]  Я скажу вот так.
[01:02:29.160 --> 01:02:31.160]  То есть, вроде должно работать
[01:02:31.160 --> 01:02:33.160]  корректно во всех случаях.
[01:02:33.160 --> 01:02:35.160]  Вдруг мы что-то забыли,
[01:02:35.160 --> 01:02:37.160]  и влюбка там нужно красивее.
[01:02:39.160 --> 01:02:41.160]  Ну хорошо.
[01:02:41.160 --> 01:02:43.160]  Ну что еще? Копия.
[01:02:43.160 --> 01:02:45.160]  А поля-то у нас какие?
[01:02:45.160 --> 01:02:47.160]  Это private.
[01:02:47.160 --> 01:02:49.160]  Это значит type erasure.
[01:02:49.160 --> 01:02:51.160]  Теперь поля.
[01:02:51.160 --> 01:02:53.160]  В полях мы храним B и звездочку.
[01:02:53.160 --> 01:02:55.160]  Что?
[01:02:55.160 --> 01:02:57.160]  F, наверное.
[01:02:59.160 --> 01:03:01.160]  Да?
[01:03:01.160 --> 01:03:03.160]  Да.
[01:03:03.160 --> 01:03:05.160]  Вот.
[01:03:05.160 --> 01:03:07.160]  И как мы ей пользуемся?
[01:03:07.160 --> 01:03:09.160]  Если у нас
[01:03:09.160 --> 01:03:11.160]  если нас создают
[01:03:11.160 --> 01:03:13.160]  от какого-то объекта
[01:03:19.160 --> 01:03:21.160]  function от
[01:03:23.160 --> 01:03:25.160]  t
[01:03:25.160 --> 01:03:27.160]  ну от const
[01:03:27.160 --> 01:03:29.160]  f
[01:03:33.160 --> 01:03:35.160]  Сейчас. Мы должны
[01:03:35.160 --> 01:03:37.160]  научиться еще создавать
[01:03:37.160 --> 01:03:39.160]  derived.
[01:03:41.160 --> 01:03:43.160]  Что? Второй private пошел.
[01:03:43.160 --> 01:03:45.160]  Нормально.
[01:03:45.160 --> 01:03:47.160]  Ну я сначала private перечислил внутренние типы,
[01:03:47.160 --> 01:03:49.160]  потом private начал перечислять поля.
[01:03:49.160 --> 01:03:51.160]  Это быстроразделение.
[01:03:51.160 --> 01:03:53.160]  А тут я напишу public.
[01:03:53.160 --> 01:03:55.160]  А
[01:03:55.160 --> 01:03:57.160]  ну конструктор.
[01:03:57.160 --> 01:03:59.160]  Конструктор от чего?
[01:03:59.160 --> 01:04:01.160]  От функтора,
[01:04:01.160 --> 01:04:03.160]  видимо.
[01:04:07.160 --> 01:04:09.160]  Да?
[01:04:09.160 --> 01:04:11.160]  Это что?
[01:04:11.160 --> 01:04:13.160]  Сойдет, наверное.
[01:04:13.160 --> 01:04:15.160]  Ну, вроде.
[01:04:15.160 --> 01:04:17.160]  Опять как
[01:04:17.160 --> 01:04:19.160]  не понятно, как это все мувать.
[01:04:19.160 --> 01:04:21.160]  Ну это
[01:04:21.160 --> 01:04:23.160]  очень интересно.
[01:04:23.160 --> 01:04:25.160]  Я думаю,
[01:04:25.160 --> 01:04:27.160]  что да. Это не мысл.
[01:04:29.160 --> 01:04:31.160]  Кто понимает, о чем мы делаем?
[01:04:31.160 --> 01:04:33.160]  Я понимаю, что мы делаем.
[01:04:33.160 --> 01:04:35.160]  А, что ты не понимаешь.
[01:04:35.160 --> 01:04:37.160]  Нет, ну ладно, я тоже много чего не понимаю.
[01:04:37.160 --> 01:04:39.160]  Как минимум это,
[01:04:39.160 --> 01:04:41.160]  я тоже не понимаю.
[01:04:41.160 --> 01:04:43.160]  Класс.
[01:04:43.160 --> 01:04:45.160]  Нет, тут много проблем.
[01:04:45.160 --> 01:04:47.160]  Мы пишем сейчас просто MVP.
[01:04:47.160 --> 01:04:49.160]  Мы пишем такую вот
[01:04:49.160 --> 01:04:51.160]  простейшую версию,
[01:04:51.160 --> 01:04:53.160]  в которой куча проблем.
[01:04:53.160 --> 01:04:55.160]  И эти проблемы мы будем решать
[01:04:55.160 --> 01:04:57.160]  одна с другой. Но, видимо, завтра мы
[01:04:57.160 --> 01:04:59.160]  пооптимизируем это.
[01:04:59.160 --> 01:05:01.160]  То, что мы сейчас реализуем,
[01:05:01.160 --> 01:05:03.160]  это далеко не...
[01:05:03.160 --> 01:05:05.160]  Во-первых, сама SD-фанкшн,
[01:05:05.160 --> 01:05:07.160]  в ней куча проблем.
[01:05:07.160 --> 01:05:09.160]  И сам себе тип SD-фанкшн,
[01:05:09.160 --> 01:05:11.160]  у нее есть недостатки
[01:05:11.160 --> 01:05:13.160]  существенные.
[01:05:13.160 --> 01:05:15.160]  Но нашему пока далеко даже не ее.
[01:05:15.160 --> 01:05:17.160]  У нас есть структура,
[01:05:17.160 --> 01:05:19.160]  которая недалеко до реальной структуры.
[01:05:19.160 --> 01:05:21.160]  Ну, в смысле, реализовывали,
[01:05:21.160 --> 01:05:23.160]  а стояли много раз подряд?
[01:05:23.160 --> 01:05:25.160]  Пока нет.
[01:05:25.160 --> 01:05:27.160]  Но SharedPTR будет довольно близок.
[01:05:27.160 --> 01:05:29.160]  По счету.
[01:05:29.160 --> 01:05:31.160]  Только там у вас не будет
[01:05:31.160 --> 01:05:33.160]  empty-base optimization.
[01:05:33.160 --> 01:05:35.160]  Но это нормально.
[01:05:35.160 --> 01:05:37.160]  Он будет не совсем близок.
[01:05:37.160 --> 01:05:39.160]  Он будет ближе, чем все остальное,
[01:05:39.160 --> 01:05:41.160]  но все-таки, наверное, не очень близок.
[01:05:41.160 --> 01:05:43.160]  Почему он список не ближе?
[01:05:43.160 --> 01:05:45.160]  Ага, подкрой статуи.
[01:05:45.160 --> 01:05:47.160]  Есть.
[01:05:47.160 --> 01:05:49.160]  Кстати, может быть,
[01:05:49.160 --> 01:05:51.160]  лист действительно довольно близок.
[01:05:51.160 --> 01:05:53.160]  Ну, как?
[01:05:55.160 --> 01:05:57.160]  Там, скорее всего, тоже есть
[01:05:57.160 --> 01:05:59.160]  вот эти трюки
[01:05:59.160 --> 01:06:01.160]  с Аллок Хайдер
[01:06:01.160 --> 01:06:03.160]  и так далее.
[01:06:03.160 --> 01:06:05.160]  Кстати, вроде
[01:06:05.160 --> 01:06:07.160]  SD-фанк будет вполне себе прилично работать.
[01:06:07.160 --> 01:06:09.160]  Не никаких целья, ничего.
[01:06:09.160 --> 01:06:11.160]  Мне кажется, что мы что-то намудрили.
[01:06:11.160 --> 01:06:13.160]  Потому что SD-форум, по сути, примерно то же самое
[01:06:13.160 --> 01:06:15.160]  и делает, что мы сейчас написали.
[01:06:15.160 --> 01:06:17.160]  Ну, например,
[01:06:17.160 --> 01:06:19.160]  в чем, как я понял, сказать, что если
[01:06:19.160 --> 01:06:21.160]  ARKS уже с двойной персоной.
[01:06:21.160 --> 01:06:23.160]  Если функция принимает тебя
[01:06:23.160 --> 01:06:25.160]  что-то по ссылке или по двойной ссылке.
[01:06:25.160 --> 01:06:27.160]  Сложим ли мы в SD-фанкшн принимать
[01:06:27.160 --> 01:06:29.160]  что-то по ссылке или по двойной ссылке?
[01:06:29.160 --> 01:06:31.160]  Вот кажется, что да, все нормально.
[01:06:31.160 --> 01:06:33.160]  И что SD-форум в данном случае будет работать
[01:06:33.160 --> 01:06:35.160]  корректно.
[01:06:35.160 --> 01:06:37.160]  Но что-то я уже запутался с вами.
[01:06:37.160 --> 01:06:39.160]  Такой SD-форум.
[01:06:39.160 --> 01:06:41.160]  Не, может реально запутали.
[01:06:41.160 --> 01:06:43.160]  Ну, давайте пропустим эту часть
[01:06:43.160 --> 01:06:45.160]  про формординг.
[01:06:45.160 --> 01:06:47.160]  Мне тут больше хочется обсудить
[01:06:47.160 --> 01:06:49.160]  другие детали.
[01:06:49.160 --> 01:06:51.160]  Окей, мы создаем
[01:06:51.160 --> 01:06:53.160]  мы учили ситуацию от функтора.
[01:06:53.160 --> 01:06:55.160]  Но тут опять, конечно, есть история с тем
[01:06:55.160 --> 01:06:57.160]  мы создаемся мувом или копированием.
[01:06:57.160 --> 01:06:59.160]  Ну, надо мув конструктор
[01:06:59.160 --> 01:07:01.160]  еще сделать.
[01:07:01.160 --> 01:07:03.160]  Ну, то есть вот
[01:07:03.160 --> 01:07:05.160]  у меня есть такая штука, да.
[01:07:07.160 --> 01:07:09.160]  Вот, ну и чего?
[01:07:09.160 --> 01:07:11.160]  Я говорю просто
[01:07:11.160 --> 01:07:13.160]  что я здесь вот делаю?
[01:07:13.160 --> 01:07:15.160]  В этом конструкторе
[01:07:15.160 --> 01:07:17.160]  что я делаю?
[01:07:19.160 --> 01:07:21.160]  Эээ, подожди.
[01:07:21.160 --> 01:07:23.160]  Систэр функции, это далеко не самое все.
[01:07:25.160 --> 01:07:27.160]  Ну, чекать имени не надо,
[01:07:27.160 --> 01:07:29.160]  поэтому мы просто
[01:07:29.160 --> 01:07:31.160]  вызываем под new.
[01:07:31.160 --> 01:07:33.160]  Ну, надо
[01:07:33.160 --> 01:07:35.160]  сказать new
[01:07:35.160 --> 01:07:37.160]  F
[01:07:37.160 --> 01:07:39.160]  derived
[01:07:39.160 --> 01:07:41.160]  Вот. Ну, надо F
[01:07:41.160 --> 01:07:43.160]  нацелезировать вот таким.
[01:07:43.160 --> 01:07:45.160]  Да, F, да.
[01:07:45.160 --> 01:07:47.160]  Ну, и тело пустое.
[01:07:49.160 --> 01:07:51.160]  Вот.
[01:07:51.160 --> 01:07:53.160]  Ну, соответственно, диструктор. Да, чего?
[01:07:53.160 --> 01:07:55.160]  Такой стиль, как бы, вот с ног, это мы переносим.
[01:07:55.160 --> 01:07:57.160]  Да, это нормально.
[01:07:57.160 --> 01:07:59.160]  Это так нормально, да.
[01:07:59.160 --> 01:08:01.160]  Да, это как раз так и надо.
[01:08:01.160 --> 01:08:03.160]  Это как...
[01:08:04.160 --> 01:08:06.160]  С оператора начинать новую строку.
[01:08:06.160 --> 01:08:08.160]  Вот есть, кстати, еще вот такой.
[01:08:08.160 --> 01:08:10.160]  Я еще рекомендую вам вот так делать.
[01:08:10.160 --> 01:08:12.160]  Что это?
[01:08:12.160 --> 01:08:14.160]  Запятую.
[01:08:14.160 --> 01:08:16.160]  А, все, увидел. О, боже мой.
[01:08:16.160 --> 01:08:18.160]  Ну, вот так. Давайте еще то, что мы вносили.
[01:08:18.160 --> 01:08:20.160]  Ну, вот.
[01:08:20.160 --> 01:08:22.160]  Ну, вот такой стиль
[01:08:22.160 --> 01:08:24.160]  я очень рекомендую, потому что это
[01:08:24.160 --> 01:08:26.160]  видно и удобно,
[01:08:26.160 --> 01:08:28.160]  и добавлять новое поле удобно,
[01:08:28.160 --> 01:08:30.160]  потому что самое главное, что вам не нужно
[01:08:30.160 --> 01:08:32.160]  запятую. Вы с запятой
[01:08:32.160 --> 01:08:34.160]  вы начинаете, а не заканчиваете.
[01:08:34.160 --> 01:08:36.160]  Да.
[01:08:36.160 --> 01:08:38.160]  Ну, просто...
[01:08:38.160 --> 01:08:40.160]  Так, ну, что делает диструктор?
[01:08:40.160 --> 01:08:42.160]  Ну, я делаю delete.
[01:08:44.160 --> 01:08:46.160]  Что делает
[01:08:46.160 --> 01:08:48.160]  конструктор копирования?
[01:08:50.160 --> 01:08:52.160]  Копируют.
[01:08:54.160 --> 01:08:56.160]  Ну, давайте скажу other.
[01:08:58.160 --> 01:09:00.160]  Я говорю, что...
[01:09:01.160 --> 01:09:03.160]  Так, мне нужно
[01:09:03.160 --> 01:09:05.160]  сказать f это
[01:09:05.160 --> 01:09:07.160]  что?
[01:09:07.160 --> 01:09:09.160]  Это мое f
[01:09:09.160 --> 01:09:11.160]  стрелочка getCopy.
[01:09:14.160 --> 01:09:16.160]  Ну, там просто копия.
[01:09:16.160 --> 01:09:18.160]  Давайте я скажу getCopy, а то, наверное, оно...
[01:09:18.160 --> 01:09:20.160]  Наверное, other
[01:09:20.160 --> 01:09:22.160]  f.getCopy.
[01:09:22.160 --> 01:09:24.160]  Да.
[01:09:24.160 --> 01:09:26.160]  Да, other
[01:09:26.160 --> 01:09:28.160]  f.getCopy.
[01:09:29.160 --> 01:09:31.160]  И, видимо, все.
[01:09:34.160 --> 01:09:36.160]  Что это было секунду?
[01:09:36.160 --> 01:09:38.160]  А мы свой не удалили.
[01:09:38.160 --> 01:09:40.160]  Это же конструктор.
[01:09:40.160 --> 01:09:42.160]  Справедливо.
[01:09:44.160 --> 01:09:46.160]  Значит, b звездочка getCopy,
[01:09:46.160 --> 01:09:48.160]  что будет делать?
[01:09:50.160 --> 01:09:52.160]  Наверное, это будет константная функция.
[01:09:55.160 --> 01:09:57.160]  Но она будет
[01:09:57.160 --> 01:09:59.160]  возвращать new.
[01:10:01.160 --> 01:10:03.160]  Собственно, derived.
[01:10:06.160 --> 01:10:08.160]  Вот, наверное, да, пишу вот так.
[01:10:12.160 --> 01:10:14.160]  И add.
[01:10:16.160 --> 01:10:18.160]  Да.
[01:10:18.160 --> 01:10:20.160]  Если мы...
[01:10:20.160 --> 01:10:22.160]  А мы там не писали, ну,
[01:10:22.160 --> 01:10:24.160]  какое шоу было, где мы дирали, когда new
[01:10:24.160 --> 01:10:26.160]  делали в конструкторе, надо?
[01:10:26.160 --> 01:10:28.160]  Где?
[01:10:28.160 --> 01:10:30.160]  В конструкторе уже, ну,
[01:10:30.160 --> 01:10:32.160]  function, вот тут.
[01:10:32.160 --> 01:10:34.160]  А, здесь надо, да.
[01:10:34.160 --> 01:10:36.160]  Дирается шаблон параметром f.
[01:10:36.160 --> 01:10:38.160]  Большое это.
[01:10:38.160 --> 01:10:40.160]  А он не повел у него же единственный конструктор от
[01:10:40.160 --> 01:10:42.160]  const, functor, f?
[01:10:44.160 --> 01:10:46.160]  Ну, может и сработается.
[01:10:46.160 --> 01:10:48.160]  Лучше не бесковать.
[01:10:48.160 --> 01:10:50.160]  Но я на всякий случай познакомусь,
[01:10:50.160 --> 01:10:52.160]  потому что вдруг он поймет что-нибудь не то
[01:10:52.160 --> 01:10:54.160]  и придет не туда.
[01:10:54.160 --> 01:10:56.160]  Нет конструктора от base
[01:10:56.160 --> 01:10:58.160]  звездочки.
[01:10:58.160 --> 01:11:00.160]  Ну, вы пытаетесь это дирать от base
[01:11:00.160 --> 01:11:02.160]  звездочки. Где?
[01:11:02.160 --> 01:11:04.160]  Нет, я создаю, дираю звездочку,
[01:11:04.160 --> 01:11:06.160]  а инициализирую, а возвращаю base
[01:11:06.160 --> 01:11:08.160]  звездочку. Все корректно.
[01:11:08.160 --> 01:11:10.160]  Это не явный кастинг для родителей.
[01:11:14.160 --> 01:11:16.160]  Вот. Ну ладно.
[01:11:16.160 --> 01:11:18.160]  Вот, окей.
[01:11:18.160 --> 01:11:20.160]  Все то, что я сейчас написал, это...
[01:11:20.160 --> 01:11:22.160]  Это база, да.
[01:11:22.160 --> 01:11:24.160]  Это ковинушка.
[01:11:24.160 --> 01:11:26.160]  Это тривиально. Короче...
[01:11:26.160 --> 01:11:28.160]  Ой, что я здесь делал?
[01:11:28.160 --> 01:11:30.160]  Смотрите, ну то, что я сейчас написал,
[01:11:30.160 --> 01:11:32.160]  по сути ничего нового. По сути мы повторили
[01:11:32.160 --> 01:11:34.160]  то, что делали неделю назад.
[01:11:34.160 --> 01:11:36.160]  Просто теперь, просто с этими...
[01:11:36.160 --> 01:11:38.160]  с функциями.
[01:11:38.160 --> 01:11:40.160]  Вот. Но!
[01:11:40.160 --> 01:11:42.160]  Это очень-очень плохая
[01:11:42.160 --> 01:11:44.160]  реализация для function,
[01:11:44.160 --> 01:11:46.160]  потому что она чертовски
[01:11:46.160 --> 01:11:48.160]  медленная.
[01:11:48.160 --> 01:11:50.160]  Потому что
[01:11:50.160 --> 01:11:52.160]  если вы будете использовать...
[01:11:52.160 --> 01:11:54.160]  Как правило, функции,
[01:11:54.160 --> 01:11:56.160]  которые вы используете, они
[01:11:56.160 --> 01:11:58.160]  небольшие.
[01:11:58.160 --> 01:12:00.160]  И эта реализация
[01:12:00.160 --> 01:12:02.160]  приведет к тому, что
[01:12:02.160 --> 01:12:04.160]  на каждую функцию
[01:12:04.160 --> 01:12:06.160]  новую вы будете
[01:12:06.160 --> 01:12:08.160]  заново алоцировать.
[01:12:08.160 --> 01:12:10.160]  Если вы используете сишный pointer,
[01:12:10.160 --> 01:12:12.160]  или вы используете даже функциональный класс,
[01:12:12.160 --> 01:12:14.160]  маленький компаратор, или вы используете
[01:12:14.160 --> 01:12:16.160]  лямбда функцию, которая ничего не захватила,
[01:12:16.160 --> 01:12:18.160]  вы всегда будете
[01:12:18.160 --> 01:12:20.160]  алоцировать заново.
[01:12:20.160 --> 01:12:22.160]  Это очень эффективно.
[01:12:22.160 --> 01:12:24.160]  Поэтому для std function
[01:12:24.160 --> 01:12:26.160]  как раз очень важную роль играет
[01:12:26.160 --> 01:12:28.160]  вот эта вот small object optimization.
[01:12:28.160 --> 01:12:30.160]  Мы хотим сделать так, чтобы у нас
[01:12:30.160 --> 01:12:32.160]  не было локаций в случае,
[01:12:32.160 --> 01:12:34.160]  когда мы можем уместиться
[01:12:34.160 --> 01:12:36.160]  в какие-нибудь 16 байт, скажем.
[01:12:40.160 --> 01:12:42.160]  То есть я хочу function
[01:12:42.160 --> 01:12:44.160]  хранить не просто
[01:12:44.160 --> 01:12:46.160]  вот это, вот.
[01:12:46.160 --> 01:12:48.160]  А я хочу хранить
[01:12:50.160 --> 01:12:52.160]  что?
[01:12:52.160 --> 01:12:54.160]  Ну, указатель
[01:12:54.160 --> 01:12:56.160]  на юнион.
[01:12:56.160 --> 01:12:58.160]  Ну, вот как нам
[01:12:58.160 --> 01:13:00.160]  организовать это дело?
[01:13:00.160 --> 01:13:02.160]  Я хочу, чтобы
[01:13:02.160 --> 01:13:04.160]  new, вот эта вот вся история,
[01:13:04.160 --> 01:13:06.160]  да, кстати, еще с аллокатором наделать,
[01:13:06.160 --> 01:13:08.160]  но аллокатора не будет.
[01:13:08.160 --> 01:13:10.160]  Я обещал, что не будет аллокатора.
[01:13:10.160 --> 01:13:12.160]  Я из-за этих аллокаторов
[01:13:12.160 --> 01:13:14.160]  не могу спать.
[01:13:14.160 --> 01:13:16.160]  Я реально спать не могу.
[01:13:16.160 --> 01:13:18.160]  Я не понимаю, как это вскользь.
[01:13:18.160 --> 01:13:20.160]  Я не понимаю, мне код устраивать.
[01:13:20.160 --> 01:13:22.160]  Мне надо влезать что-то или не надо влезать.
[01:13:22.160 --> 01:13:24.160]  А ты не забыл добавить аллокатора?
[01:13:24.160 --> 01:13:26.160]  Что это такое?
[01:13:26.160 --> 01:13:28.160]  Это.
[01:13:28.160 --> 01:13:30.160]  Что нужно выдавать?
[01:13:30.160 --> 01:13:32.160]  Последнее, пока Филипп не пришел,
[01:13:32.160 --> 01:13:34.160]  придумаем что?
[01:13:34.160 --> 01:13:36.160]  Здесь так написать, чтобы избавиться
[01:13:36.160 --> 01:13:38.160]  от локаций, когда у нас тут
[01:13:38.160 --> 01:13:40.160]  небольшой параметр.
[01:13:40.160 --> 01:13:42.160]  Мы храним либо B-звездочку F,
[01:13:42.160 --> 01:13:44.160]  либо что-то еще, видимо.
[01:13:44.160 --> 01:13:46.160]  Но тогда мы не сможем
[01:13:46.160 --> 01:13:48.160]  понимать, что именно мы храним.
[01:13:48.160 --> 01:13:50.160]  Значит, нам нужно хранить B-звездочку F.
[01:13:50.160 --> 01:13:52.160]  Просто нам нужен другая структура,
[01:13:52.160 --> 01:13:54.160]  которая от B-а наследуется,
[01:13:54.160 --> 01:13:56.160]  которая хранит что-нибудь клевенькое.
[01:13:56.160 --> 01:13:58.160]  А как мы поймем, что она сейчас лежит?
[01:13:58.160 --> 01:14:00.160]  Так мы могли бы сказать, или на B есть все равно.
[01:14:00.160 --> 01:14:02.160]  Dynamic Cast, чувак.
[01:14:02.160 --> 01:14:04.160]  Не знаю.
[01:14:04.160 --> 01:14:06.160]  Нет, Dynamic Cast не очень приятно.
[01:14:06.160 --> 01:14:08.160]  С звучит хайпово.
[01:14:08.160 --> 01:14:10.160]  Сейчас сделать отдельного наследника,
[01:14:10.160 --> 01:14:12.160]  который будет хранить всех
[01:14:12.160 --> 01:14:14.160]  small челеков.
[01:14:16.160 --> 01:14:18.160]  Но как это реализовать, не понятно.
[01:14:18.160 --> 01:14:20.160]  Ну ты и small челек.
[01:14:20.160 --> 01:14:22.160]  Человек не понимает, что этот челек small.
[01:14:26.160 --> 01:14:28.160]  Оцени свою маленькую, да?
[01:14:28.160 --> 01:14:30.160]  Да.
[01:14:30.160 --> 01:14:32.160]  Ну, я
[01:14:34.160 --> 01:14:36.160]  не знаю,
[01:14:36.160 --> 01:14:38.160]  может быть, можно придумать что-то лучшее,
[01:14:38.160 --> 01:14:40.160]  но то, что я предлагаю сделать,
[01:14:40.160 --> 01:14:42.160]  это просто здесь сохранить отдельно.
[01:14:42.160 --> 01:14:44.160]  Ну вот, к сожалению, так привез,
[01:14:44.160 --> 01:14:46.160]  потому что надо будет тяжелее.
[01:14:46.160 --> 01:14:48.160]  Это не круто, но, видимо, нам плевать на память,
[01:14:48.160 --> 01:14:50.160]  нам главное время.
[01:14:50.160 --> 01:14:52.160]  О, маленькая.
[01:14:52.160 --> 01:14:54.160]  Ну, у нас function будет
[01:14:54.160 --> 01:14:56.160]  не один указатель, а побольше.
[01:14:56.160 --> 01:14:58.160]  И на самом деле
[01:14:58.160 --> 01:15:00.160]  тут есть некоторый
[01:15:00.160 --> 01:15:02.160]  обман.
[01:15:02.160 --> 01:15:04.160]  Знаете почему? Вот здесь
[01:15:04.160 --> 01:15:06.160]  все в пицце.
[01:15:08.160 --> 01:15:10.160]  Ладно, не буду показывать.
[01:15:10.160 --> 01:15:12.160]  Короче, тут бывают трудности
[01:15:12.160 --> 01:15:14.160]  в случае, когда у меня
[01:15:14.160 --> 01:15:16.160]  функция, функция
[01:15:16.160 --> 01:15:18.160]  это указатель начлен, на самом деле,
[01:15:18.160 --> 01:15:20.160]  pointer to member.
[01:15:20.160 --> 01:15:22.160]  Это вообще проблема.
[01:15:22.160 --> 01:15:24.160]  Если функтор это pointer to member,
[01:15:24.160 --> 01:15:26.160]  то вот такая вот нотация
[01:15:26.160 --> 01:15:28.160]  не будет
[01:15:28.160 --> 01:15:30.160]  работать.
[01:15:30.160 --> 01:15:32.160]  Но это мы потом
[01:15:32.160 --> 01:15:34.160]  разберем. Давайте пока поймем,
[01:15:34.160 --> 01:15:36.160]  что мы здесь храним. Здесь мы хотим
[01:15:36.160 --> 01:15:38.160]  хранить, ну, прости
[01:15:38.160 --> 01:15:40.160]  меня, господи,
[01:15:40.160 --> 01:15:42.160]  а массив чаров что?
[01:15:42.160 --> 01:15:44.160]  Значит, нам нужно хранить массив чаров.
[01:15:44.160 --> 01:15:46.160]  Поможет не задавать массив чаров
[01:15:46.160 --> 01:15:48.160]  хотя бы пять минут.
[01:15:52.160 --> 01:15:54.160]  На стейке.
[01:15:54.160 --> 01:15:56.160]  Но на самом деле есть более красивый
[01:15:56.160 --> 01:15:58.160]  способ это написать.
[01:15:58.160 --> 01:16:00.160]  STD вариант. Нет, STD
[01:16:00.160 --> 01:16:02.160]  align storage.
[01:16:02.160 --> 01:16:04.160]  Оу, е.
[01:16:04.160 --> 01:16:06.160]  А что-нибудь...
[01:16:06.160 --> 01:16:08.160]  Наверное,
[01:16:08.160 --> 01:16:10.160]  нужно было раньше про него вспомнить.
[01:16:10.160 --> 01:16:12.160]  Сейчас, давайте-ка я... А у меня интернета нет.
[01:16:12.160 --> 01:16:14.160]  А, а, я не могу.
[01:16:14.160 --> 01:16:16.160]  А, вот.
[01:16:16.160 --> 01:16:18.160]  Прекрасно.
[01:16:18.160 --> 01:16:20.160]  То есть, ну, как раз на этом
[01:16:20.160 --> 01:16:22.160]  наверное придаваемся. Ну, короче,
[01:16:22.160 --> 01:16:24.160]  что мы сейчас...
[01:16:24.160 --> 01:16:26.160]  Какой план?
[01:16:26.160 --> 01:16:28.160]  Ну, там два шаблон-фрагмента, len и align.
[01:16:28.160 --> 01:16:30.160]  Ну, align это, наверное,
[01:16:30.160 --> 01:16:32.160]  не обязательный.
[01:16:32.160 --> 01:16:34.160]  Ну, да.
[01:16:34.160 --> 01:16:36.160]  Align storage, не знаю, 16.
[01:16:36.160 --> 01:16:38.160]  Бафф.
[01:16:38.160 --> 01:16:40.160]  Значит, ну, все.
[01:16:40.160 --> 01:16:42.160]  Какой план? В чем мы собираемся дальше сделать?
[01:16:42.160 --> 01:16:44.160]  У нас есть вот это.
[01:16:44.160 --> 01:16:46.160]  И дальше мы просто хотим...
[01:16:46.160 --> 01:16:48.160]  Дальше мы просто вот этот
[01:16:48.160 --> 01:16:50.160]  pointer, он будет
[01:16:50.160 --> 01:16:52.160]  наверное уже не B из звездочка,
[01:16:52.160 --> 01:16:54.160]  а B от звездочка.
[01:16:54.160 --> 01:16:56.160]  Ну, я не знаю, надо подумать, чем он
[01:16:56.160 --> 01:16:58.160]  именно будет, но этот pointer будет
[01:16:58.160 --> 01:17:00.160]  указывать то на вот этот буфер,
[01:17:00.160 --> 01:17:02.160]  то на что-то внешнее.
[01:17:02.160 --> 01:17:04.160]  И мы будем таким образом понимать, если этот
[01:17:04.160 --> 01:17:06.160]  pointer указывает на вот эту штуку,
[01:17:06.160 --> 01:17:08.160]  значит, у нас локальная функция, мы ничего не
[01:17:08.160 --> 01:17:10.160]  алоцируем. Если у нас pointer указывает на
[01:17:10.160 --> 01:17:12.160]  что-то внешнее,
[01:17:12.160 --> 01:17:14.160]  ну, значит, алоцируем.
[01:17:14.160 --> 01:17:16.160]  Ну, и надо ивчики
[01:17:16.160 --> 01:17:18.160]  будет расставить, соответственно, что там
[01:17:18.160 --> 01:17:20.160]  когда мы алоцируем, когда нет,
[01:17:20.160 --> 01:17:22.160]  когда мы должны пилить вызывать, когда нет.
[01:17:22.160 --> 01:17:24.160]  Ну, ладно, тогда мы завтра
[01:17:24.160 --> 01:17:26.160]  продолжим. Завтра у нас еще
[01:17:26.160 --> 01:17:28.160]  предстоит нам решить проблему
[01:17:28.160 --> 01:17:30.160]  с случаем, когда у нас pointer to member,
[01:17:30.160 --> 01:17:32.160]  и еще одну
[01:17:32.160 --> 01:17:34.160]  проблему, про которую я скажу потом.
[01:17:34.160 --> 01:17:36.160]  Ну, в общем, все, пока.
