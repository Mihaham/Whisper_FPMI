[00:00.000 --> 00:13.400]  Ну, давайте сегодня закончим с теоремой, с признаком
[00:13.400 --> 00:25.720]  РДШ хватало, упоминая вам, что мы доказываем, признак
[00:25.720 --> 00:47.160]  РДШ хватало. Вот, значит, кусь же связанная грав.
[00:47.160 --> 01:07.360]  Такое, что альфа-аджи меньше либо равно, чем кападжи,
[01:07.360 --> 01:27.960]  или даже гамильтонов. Вот, ну, давайте, доказательства,
[01:28.960 --> 01:39.640]  что мы начали? Было, было. Значит, мы ввели, было, сначала
[01:39.640 --> 01:47.560]  мы показали, что же не дерево, же, да, забыл, связанный
[01:47.560 --> 01:56.960]  грав на больше либо равно, чем трех вершинах. Вот,
[01:56.960 --> 02:13.160]  же было, же не дерево. Далее, пусть с, самый длинный
[02:13.160 --> 02:39.600]  цикл, уже самый длинный, простой цикл, уже. Так,
[02:39.600 --> 02:47.600]  вот теперь, так, следующий шаг, что мы, как вот, который
[02:47.600 --> 02:54.400]  мы сделали, да, но если ц, если ц содержит все вершины
[02:54.400 --> 03:09.600]  графа, если ц состоит из n вершин, из n вершин, n число вершин
[03:09.600 --> 03:30.160]  графа, то теперь мы доказаны. Пусть ц состоит из строго
[03:30.160 --> 03:40.480]  меньше, чем n вершин. Пусть длина ц, длина ц строго
[03:40.480 --> 03:44.920]  меньше, чем n. Ну, вот, из этого как раз предположение
[03:44.920 --> 03:50.720]  мы должны вывести противоречие. Вот. Что тогда? Тогда у нас
[03:50.720 --> 04:04.120]  получается, что дальше мы делали, вспоминайте,
[04:04.120 --> 04:08.040]  мы удаляли, да, удаляли ребра этого самого, мы удаляли
[04:08.040 --> 04:13.440]  вершины этого цикла c и смотрели на компоненты связанности,
[04:13.440 --> 04:24.400]  которые получаются после удаления. Мы удалили, удалим
[04:24.400 --> 04:29.480]  вершины ц. Посмотрим на компоненты связанности,
[04:29.480 --> 04:38.520]  которые получатся. Что-что? Нет, именно вершины, вершины,
[04:38.520 --> 04:44.320]  это важно. Сейчас увидите. Посмотрим на компоненты
[04:44.320 --> 04:47.280]  связанности. Если тогда ребра, говорил, это была ошибка.
[04:47.280 --> 05:01.720]  Вот. На компоненты связанности образовываешься после
[05:01.720 --> 05:16.640]  этого. Рассмотрим любую компоненту связанности,
[05:16.640 --> 05:22.360]  из этих компонентов связанности обозначим ее W. Рассмотрим
[05:22.360 --> 05:46.720]  любую компоненту связанности и обозначим ее W. Вот. Теперь
[05:46.880 --> 06:03.680]  Еще одно обозначение. Обозначим W у нас такое было, как множество
[06:03.680 --> 06:15.840]  вершин W из вершин вне W такие, что существует U из W, что
[06:15.840 --> 06:33.360]  У в ребро. То есть соседи W. Да? Соседи вне самого W. Вот. Что было дальше? Дальше
[06:33.360 --> 06:55.880]  мы доказали лемму. Далее мы доказали, мы доказали следующие леммы. Первая лемма.
[06:55.880 --> 07:15.320]  Состоит в том, что у нас Nw есть под множество C. То есть соседи вне W,
[07:15.320 --> 07:24.120]  у W только внутри цикла. Это мы доказывали. Помните, да? Это первая лемма. Вторая лемма.
[07:24.120 --> 07:51.880]  Если. Ну давайте как-нибудь перенумируем элементы цикла. Ну вот пусть наш цикл вот
[07:51.880 --> 08:15.360]  какой-нибудь такой. И хитая принадлежит до Nw, то х и плюс первая не принадлежит Nw. Это тоже было, вроде, да? Помните такое? Вот. И, кажется,
[08:15.360 --> 08:33.040]  вот на этом мы остановились, да? Ну, смотрите, теперь давайте ведем вот такое множество. Это B, это T. Это х и плюс
[08:33.040 --> 08:44.720]  первые такие, что х и т.е. принадлежат Nw. Ну то есть, короче говоря, за B обозначим
[08:44.720 --> 08:59.240]  следующие под циклу за элементами Nw. И вот про это B как раз давайте докажем еще одну лему.
[08:59.240 --> 09:24.240]  Лему 3. Пусть. Так, что нет, подождите, я уже упутаюсь. Первое утверждение леммы, что мощность B равна
[09:24.240 --> 09:51.320]  мощности Nw. Второе утверждение, что B и Nw не пересекаются. Тоже кажется довольно просто, да? И самое интересное утверждение,
[09:51.320 --> 10:09.080]  что B независимое множество. И вот это самая сложная часть этой леммы. Давайте докажем.
[10:09.080 --> 10:31.440]  Значит, смотрите. Сюда, да, переведите туда. Ну, то, что B и Nw не пересекаются, это понятно, да, наверное?
[10:31.440 --> 10:41.800]  Ну, потому что B это следующий под циклу за элементами Nw. И, собственно, то, что не пересекать, следует из леммы 2.
[10:41.800 --> 11:02.240]  Следующая, что мощность B равна мощности Nw. А как это доказать?
[11:02.240 --> 11:29.680]  Ну, да. Так, и что? И что? Ну, ну, ну, ну, ну, да. Да, это биекция. Есть биекция между Nw и B. Xe. В Xe плюс 1 биекция.
[11:30.560 --> 11:45.560]  Из Nw в B. Поэтому у них одинаковые мощности. Вот. Прямая биекция просто построена. Вот. Смотрите дальше.
[11:45.560 --> 11:58.040]  А теперь почему B независимое множество? B независимое множество. Ну, вот это вопрос интересный.
[11:58.040 --> 12:08.760]  Значит, смотрите. Пусть существует и ижи. Ну, давайте и строго меньше, чем жи. Такое, что
[12:08.760 --> 12:33.360]  Xe-то из Nw, Xe-то и ижи-то из Nw. А Xe плюс первое, и ижи плюс первое, они... Кстати, я забыл сказать, извините, в каком смысле Xe плюс первое?
[12:33.360 --> 12:42.160]  Ну, если для окатого, то это первое. Понимаете, да? То есть Xe плюс первое условно следующее по циклу. Вот.
[12:42.160 --> 12:53.480]  И предположим, что между вот Xe плюс первым и Xe плюс первым есть ребро. Ну, мы же не знаем, на самом деле.
[12:53.480 --> 13:02.960]  Мы взяли просто цикл C. Ну, да. Вот внутри цикла подряд они не идут. Мы это выяснили. Но вдруг в самом графе,
[13:02.960 --> 13:11.520]  вне цикла между ними, ребро есть. Почему бы нет, спрашивается, да? А почему так не может быть?
[13:11.520 --> 13:18.640]  Даже в самом большом графе, если положить все ребра вместе с циклом, почему между вот этими
[13:18.640 --> 13:35.760]  шинами ребра быть не может? Давайте посмотрим на эту картинку. Так, значит...
[13:48.640 --> 14:10.800]  Ну, вот такая вот штука у нас есть. Вот сюда вот идут какие-то ребра. Вот тут у нас компонент
[14:10.800 --> 14:24.600]  связанности W. И тут между вот этими затытыми, зажитыми есть какой-то путь внутри компонента связанности.
[14:24.600 --> 14:33.760]  Так, ребята. Ну, давайте посмотрим, как это... А, и предположим, что вот это вот ребро существует. Вот.
[14:33.760 --> 14:44.880]  Тогда мы можем построить цикл длиннее. Правильно. Каким образом? Смотрите. Вот стартуем из Икситова.
[14:44.880 --> 14:55.920]  Икс первая. Двигаемся до Икситова. Вот так вот я его буду обозначать. Потом переходим вот сюда,
[14:55.920 --> 15:15.520]  по этому ребру. Так. Переходим... Сейчас, сейчас, сейчас. Немножко. Да, нам нужно перейти в затытые,
[15:15.520 --> 15:36.920]  а потом вот так, потом вот так, потом... Так, так, так. Вот здесь я все время путаюсь. Сейчас. Так. Вот если так, так.
[15:36.920 --> 15:59.320]  Вот так, да? Потом вот так, да? То есть вот так. Вверх, потом А. Да. То есть переходим в затытые. Далее по пути в зажитые.
[15:59.320 --> 16:16.680]  То есть мы двигаемся вот сюда, потом из зажитого в их зажитые. Так. Потом в их зажитые плюс первое, так?
[16:16.680 --> 16:24.280]  Как? А, вот так, да, да, да.
[16:24.280 --> 16:51.320]  Икс и плюс первое. Потом по ребру в экс и плюс первое. И возвращаемся в экс первое. Поняли? И возвращаемся в экс первое.
[16:51.320 --> 17:19.320]  Все. Вот. Но до экскатого, а потом экс первое. Вот. Замыкаем цикл. То есть сначала опять, еще раз, сначала до экс с этого, потом в компоненту, потом из компонента вот здесь, по пути, как по любому пути в зажитые, потом возвращаемся в экс зажитые, проходим вот тут, так?
[17:19.320 --> 17:47.320]  Проходим по этому ребру и возвращаемся. Вопрос, почему цикл длиннее? Смотрите, в этом новом цикле вот этих двух ребер нет. То есть два ребра мы из цикла С, по сути, удалили. Но почему новый цикл, хотя бы на одно ребро длиннее? Почему?
[17:47.320 --> 18:10.320]  Какие? Вот это ребро. Вот это новое ребро. Вот это новое. Ну, если там что-то есть. Мы здесь не можем гарантировать. Вот это тоже новое ребро. И вот это новое ребро.
[18:17.320 --> 18:44.320]  То есть мы удалили два ребра, но добавили как минимум три. Поэтому новый цикл длиннее. Этот цикл длиннее С, так как из С было удалено два ребра.
[18:47.320 --> 18:57.320]  А добавлено как минимум три.
[18:57.320 --> 19:25.320]  Ну, собственно, ляма доказана. Ну, вот теперь, собственно, давайте сам признак докажем.
[19:25.320 --> 19:36.320]  Так. Смотрите. Ой, зачем не стер?
[19:55.320 --> 20:13.320]  Вот. Доказательство теоремы 1.
[20:13.320 --> 20:27.320]  Ну, что теперь? Теперь нам известно, что вот есть это самое НВ, есть независимое множество В.
[20:27.320 --> 20:51.320]  Смотрите. В. Ну, больше того, есть как минимум НВ плюс один независимое множество размера НВ плюс один. Почему? Как вы думаете?
[20:51.320 --> 21:01.320]  Ну да, все правильно. Возьмем любую вершину из этой компонент связанности В. В никак не связана с вершинками из НВ.
[21:01.320 --> 21:16.320]  Поэтому мы к В можем добавить любую вершину из НВ, и это все равно останется независимым множеством.
[21:16.320 --> 21:30.320]  Полиме 3. Полиме 3. В. Независимое множество.
[21:30.320 --> 21:55.320]  И полиме 2. В. Любой вершинки В из НВ. В объединить с В. Тоже независимое множество.
[21:55.320 --> 22:20.320]  Ну, отсюда получается, что максимальное, но мое число независимости, это размер максимально независимого множества, как минимум больше либо равен, чем мощность В плюс один, то есть мощность НВ плюс один.
[22:25.320 --> 22:46.320]  Хорошо. Теперь, что мы можем сказать про вершину связанность Графа Ж? Верно ли, что если удалить все вершинки НВ, то Граф потеряет связанность? Правда, да, ребята? Согласны?
[22:46.320 --> 23:09.320]  Отвалится ДВ, как минимум. То есть образуется как? Если удалить вершинки НВ, то ДВ станет полноценно связанной компонентой, и еще куски цикла как минимум еще образуются, которые с этой ДВ никак не связаны ребрами. Так, ребята?
[23:09.320 --> 23:37.320]  То есть Граф точно потеряет связанность, если мы удалим НВ вершин, мощность НВ вершин. Ну, значит, вершина связанность максимум мощности НВ. То есть при удалении вершин Ж теряет связанность.
[23:39.320 --> 24:04.320]  Вот. Значит, мощность НВ сверху оценивает вершинная связанность Ж.
[24:04.320 --> 24:31.320]  Ну, теперь давайте эти оценки сравнивать между собой, смотреть. Альфа Ж больше либо равно, альфа Ж больше либо равно, чем мощность НВ плюс один,
[24:31.320 --> 24:53.320]  что строго больше, чем мощность НВ, а мощность НВ больше либо равно, чем КПЖ. Ну, то есть получается альфа Ж строго больше, чем КПЖ, что противоречит условиям теоремы. Поняли?
[25:02.320 --> 25:12.320]  Противоречие с условием теоремы.
[25:29.320 --> 25:30.320]  Понятно?
[25:31.320 --> 25:57.320]  Ну, что теперь? Давайте приложение какое-нибудь признаков. РДШ хватал, дадим. Наиболее красивое приложение. Да, ребят, а можете придумать граф, для которого условия вот это вот альфа Ж меньше либо равно, чем КПЖ не выполнено?
[25:57.320 --> 26:11.320]  Не выполнено. Но при этом он Агмельтонов. Чтобы не было искушения в обратную сторону этот признак применять.
[26:11.320 --> 26:39.320]  Какой? Цикл. Цикл простой. Какой длина? Нечетная. Давайте возьмем длины. Тогда там число независимости хотя бы три, да, для нечетного цикла, нечетной длины. Ой, нет, неправда. Четной длины, наоборот. Там число независимости, кажется, хотя бы три, правильно?
[26:41.320 --> 27:05.320]  Хотя бы два. Так, если длина нечетная и больше либо равна чем три, то есть пять там и больше, то уже число независимости хотя бы три. То есть цикл длины больше либо равно чем пять, в нем число независимости хотя бы три, а вершинная связанность два.
[27:06.320 --> 27:10.320]  И получается это условие не выполнено, граф Агмельтонов.
[27:10.320 --> 27:39.320]  Опять же, это не критерий получается. Критерий в Гамильтоновости, как я говорил, нету. Неизвестно. Вот, значит, приложение. Смотрите, рассмотрим вот такой граф. Он обозначается GEN 3.1.
[27:41.320 --> 27:46.320]  Классическая такая теоретика числовая конструкция.
[27:46.320 --> 27:58.320]  Значит, вершины графа это подмножество размера 3 от 1DN.
[27:58.320 --> 28:23.320]  То есть вершины В все возможные подмножество размера 3.
[28:23.320 --> 28:43.320]  Ну, вообще говоря, у нас же нет ограничений на то, какое множество вершин у нашего графа.
[28:43.320 --> 28:57.320]  Граф это множество вершин, множество ребер. Множество вершин, может быть, там хоть не знаю, олени какие-нибудь. Вы можете тройки, можете множество, можете любой природоэлемент туда в качестве вершин добавить.
[28:57.320 --> 29:14.320]  Вот, давайте возьмем все подмножество размера 3 от 1DN. Вот, а ребрами будем соединять, значит, U, V. Это напоминает подмножество размера 3.
[29:14.320 --> 29:24.320]  УВ из Е, УВ из В. Соединены ребром тогда и только тогда, когда У и В пересекаются по одному элементу.
[29:24.320 --> 29:44.320]  Ну вот, два подмножества, у них есть какое-то пересечение. Вот, соединим те три подмножества, у которых одноэлементное пересечение ребрами.
[29:44.320 --> 29:59.320]  Такой граф называется. Укладка этого графа выглядит следующим образом. Есть набор точек на плоскости, которые помечены тройками чисел.
[29:59.320 --> 30:08.320]  Ну, давайте возрастающими тройками чисел. И ребро проводится между двумя вершинами, если их пометки пересекаются по одному элементу.
[30:08.320 --> 30:13.320]  Это вот укладка уже будет такого графа, так?
[30:13.320 --> 30:20.320]  Ну, а теоретика числовая вообще, вот это просто теоретика носится на объект, вполне классический.
[30:20.320 --> 30:30.320]  Вот, формально задается так. Чаще его там рисуют вот чем-то таким. Ну, вот, например, G.
[30:30.320 --> 30:59.320]  4, 3, 1 можно нарисовать, давайте как-нибудь. То есть давайте 1, 2, 3, 1, 2, 4, 2, 3, 4 и 1, 3, 4.
[30:59.320 --> 31:13.320]  Какие ребра? Когда у нас по одному элементу пересекаются?
[31:13.320 --> 31:18.320]  Ну да, я плохой пример выбрал. Здесь ребер нет.
[31:18.320 --> 31:25.320]  Ну да, правильно, начались маленькое число. Я просто не хотел очень много вершин рисовать.
[31:25.320 --> 31:29.320]  Вершины растут довольно быстро, количество вершин в данном случае.
[31:29.320 --> 31:38.320]  Но да, здесь ребер нет, потому что все пересечения по два здесь идут. Беда.
[31:38.320 --> 31:44.320]  Но вот пример.
[31:44.320 --> 31:54.320]  Так, в качестве такого объекта может получиться даже пустой граф без ребер.
[31:54.320 --> 32:03.320]  Ну что ж, давайте докажем, что он гамильтонов, но, конечно, если там ребра есть.
[32:03.320 --> 32:09.320]  То есть для достаточно больших n, вот так сформулируем, 3, 1 это константы,
[32:09.320 --> 32:16.320]  для достаточно больших n, я очень маленькое n взял, это гамильтонов граф.
[32:16.320 --> 32:45.320]  Докажем, что для достаточно больших m, gn, 3, 1 гамильтонов.
[32:45.320 --> 32:54.320]  Ну давайте посмотрим, в первую очередь, сколько вершин в нашем графе.
[32:54.320 --> 33:01.320]  Сезон по три.
[33:01.320 --> 33:13.320]  А вот как посчитать количество ребер?
[33:13.320 --> 33:16.320]  Так, степень верда, нужно посчитать степень каждой вершины.
[33:16.320 --> 33:20.320]  Он равномерный граф, да, действительно, хороший свойство у него есть.
[33:20.320 --> 33:24.320]  У него степень каждой вершины одна и та же, так называемый равномерный граф.
[33:24.320 --> 33:35.320]  Вот, значит, какова степень каждой вершины?
[33:35.320 --> 33:45.320]  Каждой вершины равна 3 на c из n минус 3 по 2.
[33:45.320 --> 33:48.320]  Понимаете, почему?
[33:48.320 --> 33:54.320]  То есть вот вершинка это множество размера 3, фиксированное множество размера 3.
[33:54.320 --> 34:05.320]  Если мы хотим количество подножств посчитать, которые это множество, два данные, пересекают по одному элементу,
[34:05.320 --> 34:14.320]  то есть выбираем тремя способами общий элемент и двумя способами извне уже выбираем еще два оставшиеся.
[34:14.320 --> 34:22.320]  Понимаете, да, ребят?
[34:22.320 --> 34:31.320]  Ну, то есть вот так, вот фиксированная тройка, тремя способами выбираем общий элемент.
[34:31.320 --> 34:33.320]  Какой-нибудь выбрали.
[34:33.320 --> 34:40.320]  А потом к нему добавляем еще два извне, c из n минус 3 по 2 способами.
[34:40.320 --> 34:45.320]  Получается, что количество степени каждой вершины вот такая.
[34:45.320 --> 35:03.320]  Следовательно, ребер у нас 3 вторых на c из n минус 3 по 2 на c из n по 3.
[35:03.320 --> 35:05.320]  Такая величина.
[35:05.320 --> 35:11.320]  Просто просуммируем степени всех вершин и разделим на два.
[35:11.320 --> 35:14.320]  По терями рукопожатия, тогда получится количество ребер.
[35:14.320 --> 35:17.320]  Ну а симпатически, если посчитать, то это что?
[35:17.320 --> 35:31.320]  Это вот n куб на 6, это симпатически n квадрат на 2, то есть n пятый на 6 на 2 умножить на 3 вторых.
[35:31.320 --> 35:36.320]  То есть равно n в пятый на 4.
[35:36.320 --> 35:38.320]  Вот.
[35:38.320 --> 35:41.320]  А вот это симпатически n куб на 6.
[35:49.320 --> 35:51.320]  Так, к чему я веду?
[35:51.320 --> 35:54.320]  К тому, что, например, по признаку дирока здесь работать нельзя.
[35:54.320 --> 35:55.320]  Почему?
[35:55.320 --> 36:03.320]  Потому что по признаку дирока должно быть как минимум половина от максимально возможного числа ребер.
[36:03.320 --> 36:11.320]  Если хотите, чтобы он сработал, то должно быть количество ребер как минимум половина от максимально возможного.
[36:11.320 --> 36:16.320]  Максимально возможное симпатически это квадрат пополам вот этого дела.
[36:16.320 --> 36:21.320]  То есть n в шестой на 72.
[36:21.320 --> 36:24.320]  А здесь точно не половина.
[36:24.320 --> 36:27.320]  Для достаточно больших n это симпатически меньше.
[36:27.320 --> 36:30.320]  То есть граф, так называемый не плотный.
[36:30.320 --> 36:32.320]  Что такое плотный граф?
[36:32.320 --> 36:38.320]  Это граф, у которого количество ребер это константа умножить на максимально возможное.
[36:38.320 --> 36:42.320]  Константа, естественно, между 0 и 1.
[36:42.320 --> 36:44.320]  И граф не плотный.
[36:44.320 --> 36:47.320]  Ребер не может быть выражено как константа.
[36:47.320 --> 36:53.320]  Она вот связана по 3 в квадрате пополам.
[36:53.320 --> 36:57.320]  А дирок работает для плотных графов исключительно.
[36:57.320 --> 36:58.320]  Вот.
[36:58.320 --> 37:04.320]  Еще один пример, где граф гамильтонов, а признак дирка не работает.
[37:04.320 --> 37:06.320]  Вот.
[37:06.320 --> 37:09.320]  Значит...
[37:09.320 --> 37:10.320]  А?
[37:11.320 --> 37:13.320]  Нет еще.
[37:13.320 --> 37:17.320]  Мы как раз хотим доказать по признаку Эрнши Хватова.
[37:19.320 --> 37:23.320]  Сейчас докажем, что он гамильтонов, тогда будет пример.
[37:23.320 --> 37:25.320]  Сейчас докажем.
[37:28.320 --> 37:34.320]  Что нужно, чтобы доказать, что он гамильтонов по признаку Эрнши Хватова?
[37:34.320 --> 37:37.320]  Нужно...
[37:40.320 --> 37:46.320]  Оценить число независимости и вершинную связанность нашего графа G.
[37:46.320 --> 37:52.320]  Но вершина связанности, как ни странно звучит, оценивается проще, чем число независимости.
[37:52.320 --> 37:56.320]  Для оценки числа независимости нужен линейно-алгебрический метод.
[37:56.320 --> 37:58.320]  Я его изложу.
[37:58.320 --> 38:01.320]  Давайте сначала вершинную связанность.
[38:01.320 --> 38:04.320]  Вершина связанности.
[38:04.320 --> 38:06.320]  Я его изложу.
[38:06.320 --> 38:09.320]  Давайте сначала вершинную связанность.
[38:09.320 --> 38:12.320]  Вершинную связанность оценим снизу.
[38:12.320 --> 38:14.320]  Значит, смотрите.
[38:17.320 --> 38:19.320]  Ка под G.
[38:21.320 --> 38:25.320]  Больше ли бы равна, чем минимум.
[38:25.320 --> 38:29.320]  Между x и y из V.
[38:29.320 --> 38:33.320]  x и y не соединены ребром.
[38:34.320 --> 38:37.320]  Вот таких величин,
[38:38.320 --> 38:42.320]  где f от x и y,
[38:44.320 --> 38:48.320]  это количество общих соседей x и y.
[38:48.320 --> 38:54.320]  Количество общих соседей
[38:59.320 --> 39:01.320]  x и y.
[39:02.320 --> 39:08.320]  Почему вершинная связанность как минимум такая?
[39:08.320 --> 39:13.320]  Это очень грубая оценка, но здесь она хорошо работает.
[39:13.320 --> 39:17.320]  Потому что у нас общих соседей очень много.
[39:17.320 --> 39:24.320]  Почему? Потому что, смотрите, вот рассмотрим вершинки, не соединенные ребром.
[39:24.320 --> 39:29.320]  Рассмотрим их общих соседей всех возможных.
[39:32.320 --> 39:37.320]  Если мы их этих общих соседей удалим,
[39:37.320 --> 39:43.320]  то между ними исчезнут все пути длины 2.
[39:45.320 --> 39:50.320]  А чтобы терялась связанность, нужно, чтобы исчезли пути любой длины.
[39:50.320 --> 39:53.320]  В том числе и длины 2.
[39:53.320 --> 39:58.320]  То есть меньше, чем удалением вот этого минимального количества,
[39:58.320 --> 40:00.320]  ну никак не обойтись.
[40:00.320 --> 40:06.320]  Потому что тогда между любыми двумя вершинами,
[40:06.320 --> 40:10.320]  не соединенными ребром, останутся пути длины 2.
[40:10.320 --> 40:12.320]  То есть связанность сохранится.
[40:12.320 --> 40:14.320]  Понимаете, да?
[40:14.320 --> 40:20.320]  Конечно, может быть недостаточно, но как минимум столько точно нужно удалить.
[40:20.320 --> 40:22.320]  Так, ребят?
[40:24.320 --> 40:26.320]  Смотрите дальше.
[40:26.320 --> 40:30.320]  Но давайте вот эту f от x и y оценим.
[40:32.320 --> 40:34.320]  Смотрите.
[40:36.320 --> 40:39.320]  Сейчас рисуночки будем рисовать.
[40:39.320 --> 40:45.320]  В нашем случае вершины под множество размера 3.
[40:47.320 --> 40:49.320]  И между ними ребра не должна быть.
[40:49.320 --> 40:51.320]  То есть они должны пересекаться по одному элементу.
[40:51.320 --> 40:55.320]  То есть они могут либо не пересекаться,
[40:57.320 --> 41:02.320]  тогда количество общих соседей сколько?
[41:06.320 --> 41:08.320]  Ну, смотрите.
[41:08.320 --> 41:12.320]  Общий сосед должен цеплять по одной вершинке вот это множество,
[41:12.320 --> 41:15.320]  по одной вершинке вот это множество,
[41:15.320 --> 41:18.320]  и еще одну вершинку где-то отсюда должен брать.
[41:20.320 --> 41:22.320]  Да.
[41:23.320 --> 41:27.320]  9 на n-6,
[41:29.320 --> 41:36.320]  если x и y не пересекаются.
[41:42.320 --> 41:46.320]  9 – это тремя способами можно эту вершинку общую выбрать.
[41:46.320 --> 41:48.320]  Тремя способами вот эту вершинку.
[41:48.320 --> 41:52.320]  И n-6 способов для вот этой вершинки.
[41:54.320 --> 41:56.320]  Так, хорошо.
[42:00.320 --> 42:05.320]  А вот если x и y пересекаются по двум элементам.
[42:13.320 --> 42:15.320]  Вот такая у нас картинка.
[42:15.320 --> 42:17.320]  Сколько общих соседей?
[42:19.320 --> 42:23.320]  На самом деле есть общие соседи двух типов.
[42:23.320 --> 42:26.320]  Тип номер один.
[42:26.320 --> 42:29.320]  Общий сосед вот такого вида.
[42:30.320 --> 42:38.320]  Таких общих соседов два умножить на c и z – минус четыре по два.
[42:38.320 --> 42:40.320]  Правильно?
[42:42.320 --> 42:44.320]  Так, все понимают сейчас?
[42:45.320 --> 42:48.320]  Есть общий сосед вот такого типа.
[42:57.320 --> 42:59.320]  Есть общий сосед вот такого типа.
[42:59.320 --> 43:04.320]  То есть одна вершинка, ну одна, не общая у двух этих множеств.
[43:04.320 --> 43:06.320]  И одна, вторая не общая.
[43:06.320 --> 43:08.320]  И еще.
[43:08.320 --> 43:10.320]  Таких соседов сколько?
[43:10.320 --> 43:12.320]  Минус четыре.
[43:12.320 --> 43:14.320]  Минус четыре.
[43:16.320 --> 43:18.320]  Если
[43:21.320 --> 43:25.320]  x и y пересекаются по двум элементам.
[43:25.320 --> 43:27.320]  Ну, если они по одному элементу пересекаются,
[43:27.320 --> 43:30.320]  то рассматривать как вы понимаете не надо,
[43:30.320 --> 43:32.320]  потому что тогда между ними есть рецепт.
[43:32.320 --> 43:35.320]  Но если они пересекаются по одному элементу,
[43:35.320 --> 43:37.320]  то рассматривать как вы понимаете не надо,
[43:37.320 --> 43:39.320]  потому что тогда между ними есть ребро уже.
[43:44.320 --> 43:47.320]  Ну, давайте просто минимум нам нужен же
[43:47.320 --> 43:50.320]  по всем парам x и y, которые объемами соединены.
[43:50.320 --> 43:53.320]  Минимум для достаточно больших n вот это.
[43:53.320 --> 43:55.320]  Девять на n минус шесть.
[43:55.320 --> 43:58.320]  Правда? Но это симпатически быстрее растет.
[43:59.320 --> 44:02.320]  Давайте не будем оценивать там начиная с какого,
[44:02.320 --> 44:06.320]  просто будем говорить начиная с какого достаточно большего n.
[44:06.320 --> 44:09.320]  На самом деле не настолько уж достаточно,
[44:09.320 --> 44:12.320]  не настолько уж большой тут n требуется,
[44:12.320 --> 44:14.320]  чтобы это было бы больше.
[44:14.320 --> 44:17.320]  Просто не хочется какие-то дурацкие там квадратные уравнения,
[44:17.320 --> 44:19.320]  которые получается решать.
[44:25.320 --> 44:27.320]  А?
[44:28.320 --> 44:30.320]  А?
[44:31.320 --> 44:34.320]  Ну, то есть вот k по отn больше выбрано,
[44:34.320 --> 44:36.320]  чем девять на н минус шесть.
[44:36.320 --> 44:38.320]  Нам такая досценка достаточно.
[44:38.320 --> 44:42.320]  Ну, смотрите, а лучше вот из этого лучше-то не получится.
[44:42.320 --> 44:45.320]  Нам нужен минимум, минимум вот здесь.
[44:47.320 --> 44:51.320]  Ну вот непосредственно вот отсюда не получится лучше.
[44:57.320 --> 45:14.320]  Так, то есть, то есть k по отg больше либо равно,
[45:14.320 --> 45:17.320]  чем девять на н минус шесть.
[45:18.320 --> 45:21.320]  Вот, нам нужна верхняя оценка на числа независимости.
[45:21.320 --> 45:23.320]  Давайте смотреть.
[45:24.320 --> 45:26.320]  Нужно оценить.
[45:27.320 --> 45:29.320]  Нужно оценить.
[45:33.320 --> 45:35.320]  Сверху.
[45:40.320 --> 45:45.320]  Число под множество размера три.
[45:54.320 --> 45:59.320]  Но максимальная числа, я имею в виду, максимальная.
[46:05.320 --> 46:09.320]  Под множество размера три таких, что
[46:11.320 --> 46:15.320]  любые два из них пересекаются либо по одному,
[46:15.320 --> 46:18.320]  либо по нулю, либо по двум элементам.
[46:18.320 --> 46:20.320]  Любые два.
[46:20.320 --> 46:23.320]  Нужно множество независимости.
[46:23.320 --> 46:29.320]  То есть между этими вершинками, набором вершин не должно быть ребер вообще.
[46:29.320 --> 46:30.320]  А когда не будет ребер?
[46:30.320 --> 46:35.320]  Когда любые пары пересекаются по ноль либо по двум элементам.
[46:36.320 --> 46:43.320]  Любые два множества пересекаются
[46:46.320 --> 46:51.320]  по двум
[46:52.320 --> 46:57.320]  или по нулю элементов.
[47:06.320 --> 47:08.320]  Вот.
[47:12.320 --> 47:17.320]  Вот для этого нужен называемый лименогабарический метод.
[47:19.320 --> 47:25.320]  Сейчас как раз им, я его, ну, в данном, для данной задачи изложу.
[47:25.320 --> 47:27.320]  Смотрите, ладно, так.
[47:27.320 --> 47:30.320]  Но все-таки придется здесь стереть.
[47:36.320 --> 47:40.320]  Когда мы должны? В двенадцать десять, да?
[47:44.320 --> 47:50.320]  Следующая лекция уже будет, все, это последний эпизод про графы.
[47:50.320 --> 47:53.320]  Следующую лекцию будем уже теории алгоритмов.
[47:53.320 --> 47:57.320]  У нас пять лекций осталось, как раз теории алгоритмов за пять лекций.
[47:57.320 --> 48:00.320]  И нужно покрыть.
[48:00.320 --> 48:03.320]  Вот, ребят.
[48:05.320 --> 48:10.320]  Ну просто, я не знаю, как это выяснить, но
[48:12.320 --> 48:16.320]  вы же в курсе, что майские праздники больше через дни учебных.
[48:18.320 --> 48:22.320]  Что там не учебные, только первое, второе, там девятое, десятое мая.
[48:22.320 --> 48:28.320]  А девятое и так воскресенье, поэтому зачем его в список включили, не до конца понятно.
[48:28.320 --> 48:33.320]  Подождите, десятое вторник, девятое, значит, понедельник.
[48:33.320 --> 48:37.320]  Второе, кажется, воскресенье, что-то такое, то ли первое, то ли второе.
[48:37.320 --> 48:42.320]  Одно из них непонятно зачем включено, потому что является воскресением.
[48:42.320 --> 48:49.320]  Но, тем не менее, остальные дни учебные, соответственно, пары будут.
[48:49.320 --> 48:55.320]  Но есть традиция у студентов из Теха, на эти праздники уезжает домой,
[48:55.320 --> 48:58.320]  поэтому посещаемость почти никакая.
[48:58.320 --> 49:02.320]  А вы-то будете хоть на лекции в майские праздники?
[49:08.320 --> 49:09.320]  Хорошо.
[49:09.320 --> 49:13.320]  А то, честно, вот с семинарами просто катастрофа.
[49:13.320 --> 49:19.320]  Иногда просто бывает, нужно провести занятия, ты приходишь, ни одного студента нет.
[49:19.320 --> 49:22.320]  Так часто бывает просто.
[49:22.320 --> 49:27.320]  Семинар срывается, потому что он должен быть, понимаете, в чем проблема.
[49:27.320 --> 49:29.320]  Он обязан быть.
[49:29.320 --> 49:33.320]  И нам говорят из деканата, ну, явились студенты,
[49:33.320 --> 49:38.320]  тогда считаемся, что он прошел, и материал вы не компенсируете.
[49:38.320 --> 49:41.320]  Они пускай сами изучают.
[49:41.320 --> 49:55.320]  Так, значит, смотрите, чтобы линейно-алгебридический метод применить,
[49:55.320 --> 49:59.320]  нужно, собственно, постановку линейно-алгебридическую сделать.
[49:59.320 --> 50:03.320]  Ну, то есть перевести вот эти подмножства в вектора.
[50:03.320 --> 50:05.320]  Следующий прием.
[50:05.320 --> 50:23.320]  То есть каждому подмножству пусть А, А1, АС.
[50:23.320 --> 50:26.320]  Максимально по размеру такая система.
[50:26.320 --> 50:48.320]  Максимально по размеру система подмножства размера 3 такая, что
[50:48.320 --> 50:56.320]  Для любых И меньше же АИТ пересечь сожитым.
[50:56.320 --> 51:00.320]  Ну, по мощности либо 0, либо 2.
[51:00.320 --> 51:03.320]  Вот.
[51:03.320 --> 51:14.320]  Теперь, смотрите, вот этим АИТом сопоставим вектора ХИТ.
[51:18.320 --> 51:33.320]  Ну, пускай вот.
[51:33.320 --> 51:37.320]  Ну, и соответственно от одного до С.
[51:37.320 --> 51:47.320]  Где вот эти ХИ, житые, равны, смотрите, единица,
[51:47.320 --> 51:56.320]  если И принадлежит, а жит, жи принадлежит АИТому, наоборот.
[51:56.320 --> 52:06.320]  И ноль, если иначе, если ж не принадлежит АИТому.
[52:06.320 --> 52:23.320]  Ну, то есть там, не знаю, множеству 1, 2, 4 в 1, 2, 3, 4, 5 мы сопоставим вот такой объектор.
[52:23.320 --> 52:28.320]  Соответственно 1, 1, 0, 1, 0.
[52:28.320 --> 52:30.320]  Понимаете, да?
[52:30.320 --> 52:39.320]  То есть на те позиции по номеру, в которые элементы множества есть, ставим единички, на остальные нули.
[52:39.320 --> 52:42.320]  Понимаете?
[52:42.320 --> 52:44.320]  Такой вектор из нулей единицы поставляем.
[52:44.320 --> 52:54.320]  То есть если элемент жи лежит в АИТом, то единица на этой позиции, если не лежит, то ноль.
[52:54.320 --> 53:03.320]  Таким образом мы сопоставляем каждому АИТому набор векторов из нулей единиц.
[53:03.320 --> 53:09.320]  Значит такой, что в ней на самом деле 3 единицы только.
[53:09.320 --> 53:13.320]  В каждом из векторов 3 единицы, все остальные нули. Правда, ребята?
[53:13.320 --> 53:25.320]  Вот. Теперь смотрите. А вот скалярное произведение иксы икс житая, она какая?
[53:25.320 --> 53:32.320]  Количество элементов пересечения. Правильно.
[53:32.320 --> 53:38.320]  Это понимаете все, что скалярное произведение именно такое?
[53:38.320 --> 53:46.320]  Ну, это количество общих единичек на количество позиций, в которых одновременно единички стоят у иксы этого икс житого.
[53:46.320 --> 53:51.320]  Это как раз мощность пересечения.
[53:51.320 --> 53:59.320]  Понятно, да, ребята? Вот. То есть это скалярное произведение по нашему условию либо 0, либо 2.
[53:59.320 --> 54:04.320]  Вот это нам как раз и нужно. Смотрите, о чем мы сделаем.
[54:04.320 --> 54:13.320]  Мы рассмотрим такое линейное пространство.
[54:20.320 --> 54:25.320]  Оно обозначается вот так. Сейчас я напишу.
[54:25.320 --> 54:28.320]  Оно обозначается вот так.
[54:29.320 --> 54:40.320]  Линейное пространство Z2 в степени N над Z2.
[54:40.320 --> 54:49.320]  Что это такое? Ну, это вектора из нулей единиц, которые складываются, обратите внимание, по модулю 2.
[54:49.320 --> 54:53.320]  Ну, просто сложение, по компонентное сложение по модулю 2.
[54:53.320 --> 55:00.320]  В линейном пространстве 2 операции.
[55:00.320 --> 55:04.320]  Сложение векторов и умножение на скаляр.
[55:04.320 --> 55:07.320]  Скаляр из Z2 берутся.
[55:07.320 --> 55:13.320]  Соответственно, сложение векторов – это по компонентное сложение по модулю 2.
[55:13.320 --> 55:17.320]  А умножение на скаляр – это умножение на 0, либо 0, либо 1.
[55:17.320 --> 55:21.320]  Понятно, да, что будет? Какой вектор получится?
[55:21.320 --> 55:25.320]  Ну, 1 станет тем же, если 0, то 0 станет.
[55:25.320 --> 55:31.320]  Ну, это будет нормальное линейное пространство.
[55:31.320 --> 55:39.320]  И наши вектора, вот эти иксы, они в этом линейном пространстве лежат. Правда?
[55:39.320 --> 55:47.320]  Больше того, вот это N-мерное пространство.
[55:48.320 --> 55:53.320]  Давайте докажем, что эти векторы линейно-независимы вот там.
[55:53.320 --> 55:56.320]  Ну, давайте.
[56:08.320 --> 56:13.320]  Пусть есть линейная комбинация. Что такое линейная независимость?
[56:13.320 --> 56:17.320]  Из того, что есть нулевая линейная комбинация…
[56:17.320 --> 56:22.320]  Ну, цииты все по модулю 2. Естественно, все по модулю 2.
[56:25.320 --> 56:32.320]  Из того, что вот такая линейная комбинация нулевая, должно следовать, что все цииты той же нули.
[56:32.320 --> 56:34.320]  Давайте докажем это.
[56:34.320 --> 56:38.320]  Скаляр умножим это на X1.
[56:43.320 --> 57:03.320]  Тоже число. Тут вектор не надо ставить. Скалярное произведение дает число.
[57:03.320 --> 57:06.320]  Ну, тоже по модулю 2.
[57:06.320 --> 57:14.320]  Вот. Смотрите, это же мощность пересечения?
[57:14.320 --> 57:16.320]  Да.
[57:16.320 --> 57:20.320]  А то есть это 0,2. 0 либо 0, либо 2. Но по модулю 2 это 0.
[57:20.320 --> 57:23.320]  То есть вот эти все штуки нули.
[57:27.320 --> 57:34.320]  А вот эта штука X1 и X1, это мощность самого вектора 3. Это единиц по модулю 2.
[57:34.320 --> 57:40.320]  То есть вот эта единица, получается, первая равна 0 по модулю 2. Правильно?
[57:48.320 --> 57:50.320]  По модулю 2.
[57:50.320 --> 57:54.320]  А логично, умножаем на X2, скаляр, на это все.
[58:04.320 --> 58:20.320]  Все вот эти штуки, за исключением вот этого, обнулятся. Останется вот эта одна, которая единица.
[58:20.320 --> 58:23.320]  Ну, C2 на 1. Соответственно, C2, 0.
[58:27.320 --> 58:30.320]  Ну, аналогично все остальные. Так же 0.
[58:35.320 --> 58:45.320]  Аналогично, C3 равна C, равно 0 по модулю 2. Вот.
[58:45.320 --> 58:49.320]  А значит, система X1, Xs независима.
[58:55.320 --> 58:58.320]  Xs линейно независима.
[58:58.320 --> 59:12.320]  З2 в степени n. А значит, ее количество векторов не превосходит размерности пространства.
[59:12.320 --> 59:15.320]  Размерности, то есть s не может быть больше, чем n.
[59:19.320 --> 59:21.320]  Такая верхняя оценка.
[59:22.320 --> 59:24.320]  N.
[59:24.320 --> 59:30.320]  А s – это число независимости в нашем графе.
[59:30.320 --> 59:36.320]  Помните, мы свели задачу к тому, чтобы наценить сверху максимальное число множества размера 3,
[59:36.320 --> 59:40.320]  что любые 2 пересекаются по 2 элементам или по 0.
[59:42.320 --> 59:45.320]  Мы доказали, что это максимальное число не превосходит n.
[59:45.320 --> 59:48.320]  На самом деле, для каких-то n это можно даже посчитать.
[59:49.320 --> 59:52.320]  Райгородский в некоторых курсах это считает.
[59:52.320 --> 59:58.320]  Он в своем стиле доказывает много, махая руками.
[59:58.320 --> 01:00:01.320]  Там ответ есть.
[01:00:01.320 --> 01:00:06.320]  Для некоторых n кажется кратных 4.
[01:00:06.320 --> 01:00:09.320]  Даже достигаются верхние границы.
[01:00:09.320 --> 01:00:12.320]  Для некоторых n не достигаются.
[01:00:12.320 --> 01:00:14.320]  То есть она точная.
[01:00:14.320 --> 01:00:17.320]  Но если n делится на 4, кажется так.
[01:00:17.320 --> 01:00:19.320]  Боюсь соврать.
[01:00:19.320 --> 01:00:22.320]  Там ответ в зависимости от остатков отделения на 4 разный.
[01:00:27.320 --> 01:00:30.320]  Но нам в точности вот это не нужно.
[01:00:30.320 --> 01:00:32.320]  Нам нужно вот это смотреть.
[01:00:32.320 --> 01:00:34.320]  Давайте соединим.
[01:00:34.320 --> 01:00:40.320]  Kappa же хотя бы 9n-6, а α не больше, чем n.
[01:00:40.320 --> 01:00:49.320]  То есть у нас получается Kappa же больше либо равно, чем 9n-6.
[01:00:49.320 --> 01:00:53.320]  Больше либо равно, чем n.
[01:00:53.320 --> 01:00:56.320]  Больше либо равно, чем α же.
[01:01:00.320 --> 01:01:04.320]  Отсюда условия теории Мэрдыша хватало.
[01:01:05.320 --> 01:01:07.320]  Значит, я гоню к тонов.
[01:01:10.320 --> 01:01:12.320]  Все.
[01:01:16.320 --> 01:01:18.320]  Вот так.
[01:01:18.320 --> 01:01:21.320]  Ох, сколько у нас осталось.
[01:01:25.320 --> 01:01:26.320]  На.
[01:01:26.320 --> 01:01:29.320]  Давайте про машину чуринга тогда поговорим.
[01:01:29.320 --> 01:01:32.320]  Начнем алгоритмы.
[01:01:32.320 --> 01:01:34.320]  Начнем алгоритмы.
[01:01:34.320 --> 01:01:40.320]  Ребят, если графы показались, ну не знаю.
[01:01:40.320 --> 01:01:47.320]  В общем, алгоритмы обычно нравятся, пока мы не заходим в довольно сложные вещи.
[01:01:47.320 --> 01:01:51.320]  И всего в этом году, наверное, хорошо прям получится.
[01:01:51.320 --> 01:01:55.320]  То есть мы раньше начали, чем в прошлом году эту тему.
[01:01:55.320 --> 01:01:56.320]  Вот.
[01:01:56.320 --> 01:01:59.320]  Я сейчас посмотрел там свои записи.
[01:01:59.320 --> 01:02:01.320]  На пол лекции раньше начали.
[01:02:01.320 --> 01:02:03.320]  Значит, мы не будем бежать в конце.
[01:02:03.320 --> 01:02:06.320]  И поэтому мы хорошо все там успеем.
[01:02:06.320 --> 01:02:07.320]  Вот.
[01:02:10.320 --> 01:02:14.320]  Там дальше, там в конце довольно сложные вещи идут.
[01:02:14.320 --> 01:02:17.320]  Про имсводимость.
[01:02:17.320 --> 01:02:18.320]  В начале.
[01:02:18.320 --> 01:02:22.320]  Что это за наука, собственно, про которую хотелось рассказать?
[01:02:22.320 --> 01:02:25.320]  Это то, что мы сейчас говорим.
[01:02:25.320 --> 01:02:28.320]  Что это за наука, собственно, про которую хотелось рассказать?
[01:02:28.320 --> 01:02:31.320]  Это то, что рассказывается обычно в визтехе.
[01:02:31.320 --> 01:02:35.320]  На потоке PMI и PMF рассказывается.
[01:02:35.320 --> 01:02:38.320]  Это в курсе мат-логики.
[01:02:38.320 --> 01:02:41.320]  Там курс называется курс мат-логики и теория алгоритмов.
[01:02:41.320 --> 01:02:44.320]  То есть соединили две вещи.
[01:02:44.320 --> 01:02:51.320]  Теория алгоритмов это, знаете, это не программирование, если вы подумали.
[01:02:51.320 --> 01:02:53.320]  Программирование это используется.
[01:02:53.320 --> 01:02:56.320]  Но это теоретическая, так сказать, часть программирования.
[01:02:56.320 --> 01:02:59.320]  То есть то, что...
[01:02:59.320 --> 01:03:02.320]  В общем, наука по большей части изучает, что можно,
[01:03:02.320 --> 01:03:05.320]  какие задачи можно решить при помощи алгоритма.
[01:03:05.320 --> 01:03:07.320]  Просто в принципе решить.
[01:03:07.320 --> 01:03:09.320]  А какие нельзя.
[01:03:09.320 --> 01:03:10.320]  Вот.
[01:03:10.320 --> 01:03:13.320]  Какие задачи алгоритмизированы, какие нет.
[01:03:13.320 --> 01:03:14.320]  Вот.
[01:03:14.320 --> 01:03:18.320]  А следующая итерация, это так называемые сложности вычислений.
[01:03:18.320 --> 01:03:22.320]  Это как быстро это если можно решить, то как быстро это можно решить.
[01:03:22.320 --> 01:03:23.320]  Вот.
[01:03:23.320 --> 01:03:27.320]  Но первая итерация, это вообще можно ли это сделать, в принципе.
[01:03:27.320 --> 01:03:32.320]  Хоть за, не знаю, за гига каким-то жутко сложным алгоритмом,
[01:03:32.320 --> 01:03:37.320]  который будет считать миллион лет, но хоть как-нибудь можно это сделать или нет.
[01:03:37.320 --> 01:03:40.320]  Вопрос первый в этом.
[01:03:40.320 --> 01:03:41.320]  Вот.
[01:03:41.320 --> 01:03:46.320]  Значит, для того, чтобы понять алгоритмизируемость,
[01:03:46.320 --> 01:03:48.320]  такой алгоритм.
[01:03:48.320 --> 01:03:51.320]  И вот тут есть теоретическая модель, которая была...
[01:03:51.320 --> 01:03:54.320]  Сейчас основным считается вот эта теоретическая модель,
[01:03:54.320 --> 01:03:58.320]  которая предложена еще в 50-60-х годах,
[01:03:58.320 --> 01:04:01.320]  1950-60-х годах,
[01:04:01.320 --> 01:04:04.320]  Алланом Тьюрингом, называется машина Тьюринга.
[01:04:04.320 --> 01:04:07.320]  Он тогда, тогда еще, кстати, компьютеров не было,
[01:04:07.320 --> 01:04:12.320]  но они почти не использовались, они только изобретались в тот момент.
[01:04:12.320 --> 01:04:13.320]  Вот.
[01:04:13.320 --> 01:04:18.320]  И он придумал такую теоретическую модель,
[01:04:18.320 --> 01:04:21.320]  попытаясь объяснить, что такое алгоритм.
[01:04:21.320 --> 01:04:23.320]  Интуитивно-то всем более-менее понятно,
[01:04:23.320 --> 01:04:30.320]  что это последовательность неких действий, которые должно привести к результату.
[01:04:30.320 --> 01:04:36.320]  Четко описанная последовательность действий, если в общем виде.
[01:04:36.320 --> 01:04:41.320]  Вот хотелось бы какой-то модель вычислений задать.
[01:04:41.320 --> 01:04:44.320]  Вот машина Тьюринга, давайте неформально.
[01:04:44.320 --> 01:04:47.320]  Он придумал такую модель.
[01:04:49.320 --> 01:04:51.320]  Он описывал это так.
[01:04:51.320 --> 01:04:56.320]  Значит, есть лента, это аналог памяти.
[01:04:56.320 --> 01:04:59.320]  Современная аналог памяти.
[01:04:59.320 --> 01:05:02.320]  Лента, на которой, собственно, бесконечно много ячейка,
[01:05:02.320 --> 01:05:04.320]  она бесконечна вправо и влево.
[01:05:04.320 --> 01:05:08.320]  То есть это машина, компьютер, вычислитель с бесконечной памятью.
[01:05:08.320 --> 01:05:10.320]  Дисковой памяти имеется в виду.
[01:05:10.320 --> 01:05:12.320]  Не оперативной, обратите внимание.
[01:05:12.320 --> 01:05:15.320]  Аналог оперативной памяти, сейчас я объясню, что это такое.
[01:05:15.320 --> 01:05:17.320]  Это конечная штука должна быть.
[01:05:17.320 --> 01:05:21.320]  Пространство на диске предполагается бесконечным.
[01:05:21.320 --> 01:05:23.320]  И, соответственно, вот.
[01:05:23.320 --> 01:05:24.320]  Давайте смотреть.
[01:05:24.320 --> 01:05:26.320]  Есть некая головка,
[01:05:26.320 --> 01:05:30.320]  которая смотрит всегда на какую-то одну ячейку этой ленты.
[01:05:30.320 --> 01:05:31.320]  Вот.
[01:05:31.320 --> 01:05:37.320]  И она у набор команд следующий.
[01:05:37.320 --> 01:05:39.320]  Есть набор состояний.
[01:05:41.320 --> 01:05:44.320]  Вот это две выделенных состояния.
[01:05:47.320 --> 01:05:50.320]  Q0 – это конечное, так сказать, состояние.
[01:05:50.320 --> 01:05:52.320]  Эта команда остановится.
[01:05:52.320 --> 01:05:54.320]  Если машина переходит в это состояние,
[01:05:54.320 --> 01:05:56.320]  дальше ничего не происходит.
[01:05:56.320 --> 01:05:57.320]  Оно останавливается.
[01:05:57.320 --> 01:05:59.320]  Q11 – стартовое состояние.
[01:05:59.320 --> 01:06:01.320]  То есть с чего начинается.
[01:06:01.320 --> 01:06:02.320]  Q2 – это все остальные состояния.
[01:06:02.320 --> 01:06:04.320]  Вот это аналог оперативной памяти.
[01:06:04.320 --> 01:06:08.320]  В состояниях мы можем запомнить какие-то вещи,
[01:06:08.320 --> 01:06:10.320]  условно говоря.
[01:06:12.320 --> 01:06:14.320]  Что происходит?
[01:06:14.320 --> 01:06:19.320]  Значит, машина находится каждый раз в каком-то состоянии
[01:06:19.320 --> 01:06:23.320]  и считывает какое-то число вот здесь.
[01:06:23.320 --> 01:06:26.320]  И в зависимости, программа заключается в том,
[01:06:26.320 --> 01:06:31.320]  что из состояния Куитова по символу аитому
[01:06:31.320 --> 01:06:34.320]  записать какой-то другой символ,
[01:06:34.320 --> 01:06:37.320]  перейти в другое состояние и сдвинуться.
[01:06:37.320 --> 01:06:41.320]  Либо вправо найден, либо влево, либо остаться на месте.
[01:06:41.320 --> 01:06:43.320]  Так?
[01:06:43.320 --> 01:06:45.320]  То есть вот такой набор команд.
[01:06:45.320 --> 01:06:48.320]  Программа должна состоять из такого набора команд.
[01:06:48.320 --> 01:06:52.320]  И, соответственно, машина, таким образом перемещаясь,
[01:06:52.320 --> 01:06:55.320]  может произвести какие-то вычисления.
[01:06:55.320 --> 01:06:59.320]  Вот, собственно, он непосредственно там предложил,
[01:06:59.320 --> 01:07:02.320]  как при помощи этой машины складывать числа,
[01:07:02.320 --> 01:07:05.320]  которые заданы на ленче, не знаю, вычитать.
[01:07:05.320 --> 01:07:08.320]  Вот эти операции можно так делать.
[01:07:08.320 --> 01:07:11.320]  То есть это довольно мерзко программировать.
[01:07:11.320 --> 01:07:15.320]  У нас на семинарах, я помню, нас заставляли такое писать
[01:07:15.320 --> 01:07:17.320]  на машине тюринга.
[01:07:17.320 --> 01:07:20.320]  Но, тем не менее, это возможно.
[01:07:20.320 --> 01:07:23.320]  Мы будем по большей части здесь, на семинарах,
[01:07:23.320 --> 01:07:26.320]  рассуждательно это все делать.
[01:07:26.320 --> 01:07:30.320]  То есть примерно писать алгоритм, как это примерно будет действовать.
[01:07:30.320 --> 01:07:34.320]  Понятно, что за теоретическая модель.
[01:07:34.320 --> 01:07:40.320]  И вот это основная модель алгоритма.
[01:07:40.320 --> 01:07:43.320]  Ну, вычислителя.
[01:07:43.320 --> 01:07:45.320]  И программы, соответственно.
[01:07:45.320 --> 01:07:47.320]  Что такое программа?
[01:07:47.320 --> 01:07:51.320]  Это вот программа-набор команд, которые допустим конкретно этого вычислителя.
[01:07:51.320 --> 01:07:54.320]  Так, ребята?
[01:07:54.320 --> 01:07:57.320]  Вот он такую модель придумал.
[01:07:57.320 --> 01:07:59.320]  Сейчас это приоритетно.
[01:07:59.320 --> 01:08:02.320]  Но для теоретиков, понимаете, если мы изучаем
[01:08:02.320 --> 01:08:05.320]  теоретическую возможность алгоритмизации,
[01:08:05.320 --> 01:08:09.320]  удобно предполагать, что хотя бы пространство
[01:08:09.320 --> 01:08:14.320]  на диске не ограничено.
[01:08:14.320 --> 01:08:17.320]  Это удобно, по крайней мере, теоретически предположить.
[01:08:17.320 --> 01:08:20.320]  Потому что, на самом деле, в каждый конечный момент времени
[01:08:20.320 --> 01:08:23.320]  занят только конечное количество и человек, правда?
[01:08:23.320 --> 01:08:29.320]  То есть изначально лента заполнена вот такими пустыми символами.
[01:08:29.320 --> 01:08:32.320]  А в каждый конечный момент времени
[01:08:32.320 --> 01:08:37.320]  количество непустых символов будет у нас конечна.
[01:08:37.320 --> 01:08:41.320]  Поэтому, собственно, размер занимаемого пространства
[01:08:41.320 --> 01:08:45.320]  всегда конечен на каждом конкретном моменте.
[01:08:45.320 --> 01:08:49.320]  Но он может расширяться неограниченно.
[01:08:49.320 --> 01:08:52.320]  Вот такое вот предположение.
[01:08:52.320 --> 01:08:55.320]  Значит, смотрите.
[01:08:55.320 --> 01:08:59.320]  Что я хотел рассказать?
[01:08:59.320 --> 01:09:02.320]  Успели ли я это сделать?
[01:09:02.320 --> 01:09:05.320]  Вот еще вопрос.
[01:09:05.320 --> 01:09:08.320]  Двадцать минут. Ну, давайте попробуем.
[01:09:08.320 --> 01:09:11.320]  Значит, я хочу формально задать машину чью ринга.
[01:09:11.320 --> 01:09:16.320]  Вот что такое неформально, я надеюсь, задал?
[01:09:16.320 --> 01:09:19.320]  То есть...
[01:09:19.320 --> 01:09:22.320]  Что такое программа, соответственно?
[01:09:22.320 --> 01:09:25.320]  Это набор команд такого типа.
[01:09:25.320 --> 01:09:28.320]  Символ подголовкой АИТ.
[01:09:28.320 --> 01:09:31.320]  Состояние КУИТ.
[01:09:31.320 --> 01:09:34.320]  Пишем символ ОЖИТОЕ.
[01:09:34.320 --> 01:09:37.320]  Переходим в состояние КУЖИТОЕ
[01:09:37.320 --> 01:09:40.320]  и двигаемся в каком-то направлении.
[01:09:40.320 --> 01:09:43.320]  То есть...
[01:09:43.320 --> 01:09:47.320]  Ну, левт налево,
[01:09:47.320 --> 01:09:50.320]  ньютрал на месте,
[01:09:50.320 --> 01:09:53.320]  райт вправо.
[01:09:53.320 --> 01:09:56.320]  В одно из трех.
[01:09:56.320 --> 01:09:59.320]  И дальше продолжаем таким же образом.
[01:09:59.320 --> 01:10:02.320]  И в зависимости от состояния, соответственно...
[01:10:02.320 --> 01:10:05.320]  Ну, понятно, что алфавит
[01:10:05.320 --> 01:10:08.320]  вот этот должен быть конечен.
[01:10:08.320 --> 01:10:11.320]  Ну, давайте формально.
[01:10:14.320 --> 01:10:17.320]  Значит, формально...
[01:10:20.320 --> 01:10:23.320]  Это такой набор.
[01:10:23.320 --> 01:10:26.320]  Сигма, КУ.
[01:10:29.320 --> 01:10:32.320]  Забыл, как обозначается набор состояния.
[01:10:32.320 --> 01:10:35.320]  Сигма, КУ.
[01:10:41.320 --> 01:10:44.320]  Нет, побольшой набор состояния.
[01:10:44.320 --> 01:10:47.320]  А, вот гамма, вспомню.
[01:10:47.320 --> 01:10:50.320]  Просто пытался стандартное обозначение
[01:10:50.320 --> 01:10:53.320]  выполнить для этих штук.
[01:10:53.320 --> 01:10:56.320]  Вот. Смотрите, вот такая шестерка.
[01:10:56.320 --> 01:10:59.320]  Соответственно, сигма – это входной алфавит.
[01:11:07.320 --> 01:11:10.320]  Входной алфавит.
[01:11:10.320 --> 01:11:13.320]  Гамма – это так называемый ленточный алфавит.
[01:11:13.320 --> 01:11:16.320]  Входной алфавит – это тот алфавит,
[01:11:16.320 --> 01:11:19.320]  который используется на входе.
[01:11:19.320 --> 01:11:22.320]  Понимаете, те буквы, которые на входе передаются.
[01:11:22.320 --> 01:11:25.320]  Гамма – ленточный алфавит.
[01:11:25.320 --> 01:11:28.320]  То есть гамма...
[01:11:28.320 --> 01:11:31.320]  Он...
[01:11:31.320 --> 01:11:34.320]  Гамма должно быть шире, чем сигма.
[01:11:34.320 --> 01:11:37.320]  Как минимум на один символ.
[01:11:37.320 --> 01:11:40.320]  Вот этот пустой символ в входном алфавите
[01:11:40.320 --> 01:11:43.320]  не должен быть. Понимаете?
[01:11:43.320 --> 01:11:46.320]  Ну, мы можем рассматривать машину тюринга,
[01:11:46.320 --> 01:11:49.320]  у которой есть некий вход, машина ввода.
[01:11:49.320 --> 01:11:52.320]  Которая, например, может быть,
[01:11:52.320 --> 01:11:55.320]  дает на ленту эти символы.
[01:11:55.320 --> 01:11:58.320]  То есть на самом деле можно чуть-чуть модифицировать.
[01:11:58.320 --> 01:12:01.320]  То есть на вход выдается еще сверху какие-нибудь символы
[01:12:01.320 --> 01:12:04.320]  и по символу на входе, и по символу на ленте.
[01:12:04.320 --> 01:12:07.320]  И по состоянию выдается
[01:12:07.320 --> 01:12:10.320]  своя реакция. То есть программы вот такого
[01:12:10.320 --> 01:12:13.320]  вида реакции выдаются.
[01:12:13.320 --> 01:12:16.320]  Можно так модифицировать машину тюринга со входа.
[01:12:16.320 --> 01:12:19.320]  Но входной алфавит – это, грубо говоря,
[01:12:19.320 --> 01:12:22.320]  ленточный алфавит без пустого символа.
[01:12:22.320 --> 01:12:25.320]  В основном часть всего – это именно вот это вот.
[01:12:25.320 --> 01:12:28.320]  Пустой символ в входном алфавите нет.
[01:12:28.320 --> 01:12:31.320]  То есть все данные в алфавите в входном.
[01:12:31.320 --> 01:12:34.320]  Это конечный алфавит. Конечный, конечно же.
[01:12:37.320 --> 01:12:40.320]  Здесь тоже конечный алфавит.
[01:12:40.320 --> 01:12:43.320]  Гамма конечный.
[01:12:43.320 --> 01:12:46.320]  Ну, конечно же.
[01:12:46.320 --> 01:12:49.320]  Гамма конечная.
[01:12:51.320 --> 01:12:54.320]  Q – это множество состояний.
[01:12:54.320 --> 01:12:57.320]  Тоже конечная.
[01:12:57.320 --> 01:13:00.320]  Это важно.
[01:13:04.320 --> 01:13:07.320]  Q0, Q1 – это состояние.
[01:13:07.320 --> 01:13:10.320]  Я просто отдельно их выделил.
[01:13:10.320 --> 01:13:13.320]  Это выделенное состояние.
[01:13:13.320 --> 01:13:16.320]  Это важно это стартоваться, а не Q0 – это остановка.
[01:13:21.320 --> 01:13:24.320]  Q – конечная.
[01:13:27.320 --> 01:13:30.320]  Q1 – стартовое состояние.
[01:13:30.320 --> 01:13:33.320]  Q0 – состояние остановки.
[01:13:42.320 --> 01:13:45.320]  Конечное состояние.
[01:13:45.320 --> 01:13:48.320]  Давайте так запишем.
[01:13:56.320 --> 01:13:59.320]  Ну, а дельта – это наша программа.
[01:14:00.320 --> 01:14:14.320]  Это функция из символа гамма на u без q0.
[01:14:16.320 --> 01:14:21.320]  Как я сказал, если мы оказываемся в состоянии q0, мы останавливаемся.
[01:14:21.320 --> 01:14:31.320]  В начале состояние q0 не должно появляться, там никаких вычислений в этом состоянии не производится.
[01:14:32.320 --> 01:14:41.320]  Мы переходим в символ гамма, в новое состояние, тут может быть, кстати, состояние q0.
[01:14:48.320 --> 01:14:52.320]  Ну и, собственно, маркер перемещения, лево-вправо на месте.
[01:14:54.320 --> 01:14:57.320]  Это программа, все это функция такая.
[01:14:58.320 --> 01:15:03.320]  Сигма – это подножие гамма.
[01:15:07.320 --> 01:15:12.320]  По пустому символу, вообще говоря, тоже нужно обрабатывать, что мы делаем.
[01:15:18.320 --> 01:15:20.320]  Понятно, да, ребята?
[01:15:21.320 --> 01:15:32.320]  То есть, по строку говоря, раз это функция, мы должны задать для любого символа из гамма и для любого состояния, кроме конечного, что дальше делать в машине.
[01:15:33.320 --> 01:15:35.320]  Это и будет программа наша.
[01:15:36.320 --> 01:15:38.320]  Поняли?
[01:15:43.320 --> 01:15:47.320]  10 минут. Давайте попробуем успеть.
[01:15:48.320 --> 01:15:51.320]  Что такое вычисление в машине теоринга?
[01:15:51.320 --> 01:15:56.320]  Так, значит, теоретическая модель вычислений машины теоринга.
[01:16:21.320 --> 01:16:23.320]  Ну, машины теоринга.
[01:16:42.320 --> 01:16:47.320]  Ну, в данном случае это последовательности так называемых состояний машины теоринга.
[01:16:48.320 --> 01:16:52.320]  Значит, состояние – это вот что.
[01:16:56.320 --> 01:16:58.320]  Конфигурация.
[01:17:01.320 --> 01:17:03.320]  Конфигурация машины теоринга.
[01:17:09.320 --> 01:17:12.320]  Давайте я буду сокращать МТ – машина теоринга.
[01:17:13.320 --> 01:17:14.320]  Что такое конфигурация?
[01:17:14.320 --> 01:17:16.320]  Конфигурация – это вот что.
[01:17:17.320 --> 01:17:18.320]  Смотрите.
[01:17:19.320 --> 01:17:21.320]  Вот положение головки.
[01:17:22.320 --> 01:17:24.320]  Вот тут записано символа.
[01:17:25.320 --> 01:17:27.320]  Машина находится в состоянии Q.
[01:17:28.320 --> 01:17:34.320]  Вот тут до символа некое слово A большое, а после символа некое слово B большое.
[01:17:35.320 --> 01:17:43.320]  Ну, то есть, по сути, мы записали все, чем выражается текущее состояние машины теоринга на настоящий момент.
[01:17:44.320 --> 01:17:57.320]  Что до, на каком месте головка находится, что под ней написано, что она считает, в каком состоянии она находится, что до ее позиции, что после ее позиции написано.
[01:17:58.320 --> 01:17:59.320]  Это конечные слова.
[01:18:00.320 --> 01:18:07.320]  Смотрите, если до A ничего нет, то A большое – пустой символ.
[01:18:08.320 --> 01:18:21.320]  Если до A ничего нет, то A большое – пустой символ.
[01:18:22.320 --> 01:18:24.320]  Ну, вот такое решеточка обозначается.
[01:18:25.320 --> 01:18:29.320]  Если после A ничего нет, то B большое – пустой символ.
[01:18:30.320 --> 01:18:40.320]  Если после A ничего нет, то B – это пустой символ.
[01:18:41.320 --> 01:18:44.320]  Таким образом мы задаем конфигурацию машины теоринга.
[01:18:45.320 --> 01:18:50.320]  Вычисление – это последовательство конфигурации.
[01:18:51.320 --> 01:19:01.320]  Конечная конфигурация должна содержать по идее ответ на нашу задачу, которую мы решаем при помощи данного алгоритма.
[01:19:02.320 --> 01:19:08.320]  То есть, как вы понимаете, машина теоринга, с учетом того, что там внутри зашита программа, это алгоритм.
[01:19:09.320 --> 01:19:11.320]  Это формальное определение алгоритма.
[01:19:14.320 --> 01:19:19.320]  Да, да, да, прямо за ними.
[01:19:20.320 --> 01:19:24.320]  Ну, мы записываем все символы, не пустые, которые до A и после.
[01:19:25.320 --> 01:19:28.320]  Если там нет, то, соответственно, пустой символ пишем.
[01:19:29.320 --> 01:19:32.320]  Вот. Смотрите дальше.
[01:19:32.320 --> 01:20:00.320]  Если команда программы A из овку там перейти в B, перейти в состояние овку…
[01:20:02.320 --> 01:20:11.320]  Штрих, не знаю, давайте U-штрих, и остаться на месте, то следующая конфигурация какая?
[01:20:12.320 --> 01:20:14.320]  То следующая конфигурация.
[01:20:18.320 --> 01:20:20.320]  Следующая конфигурация.
[01:20:33.320 --> 01:20:42.320]  A значит B-штрих-B, правильно?
[01:20:49.320 --> 01:20:50.320]  Что-что?
[01:20:54.320 --> 01:20:55.320]  Какие-то слова?
[01:20:57.320 --> 01:21:01.320]  Ну, какие-то слова, да, но мы же записываем просто содержание ленты.
[01:21:03.320 --> 01:21:06.320]  Таким образом, вот.
[01:21:07.320 --> 01:21:11.320]  Ну, вот A, A-большое, плюс A-маленькое, плюс B-большое – это полное содержание ленты.
[01:21:12.320 --> 01:21:15.320]  Кроме пустых символов, хвостов из пустых символов. Поняли?
[01:21:20.320 --> 01:21:25.320]  Вот. Следующая. Если команда программы…
[01:21:33.320 --> 01:21:34.320]  А?
[01:21:38.320 --> 01:21:40.320]  Новое состояние Q-штрих.
[01:21:41.320 --> 01:21:50.320]  Ну, то есть по символу A в состояние Q мы пишем символ B, переходим в состояние Q-штрих и настаиваемся на месте.
[01:21:56.320 --> 01:22:00.320]  Q-штрих, конечно, но здесь Q-штрих же написано.
[01:22:02.320 --> 01:22:18.320]  Вот. Если команда программы A, Q мы переходим в B, переходим в состояние Q-штрих и двигаемся вправо,
[01:22:21.320 --> 01:22:23.320]  то следующая конфигурация такая.
[01:22:24.320 --> 01:22:26.320]  Следующая конфигурация.
[01:22:41.320 --> 01:22:43.320]  Смотрите, вот какая.
[01:22:44.320 --> 01:22:53.320]  Значит, слева будет у нас A и B.
[01:22:56.320 --> 01:22:57.320]  Это одно слово.
[01:23:00.320 --> 01:23:01.320]  Так?
[01:23:02.320 --> 01:23:08.320]  Мы перейдем под символ B1,
[01:23:11.320 --> 01:23:18.320]  окажемся в состоянии Q-штрих и будет слово, не знаю, B-штрих.
[01:23:19.320 --> 01:23:28.320]  Что такое B1, B-штрих? Где B? Это B1, B-штрих. Ну, вот такой набор, такое слово. Поняли?
[01:23:31.320 --> 01:23:43.320]  Ну, немножко упрощенно написал. Почему? Потому что тут, если так скурпулезно, нужно разбирать случаи.
[01:23:44.320 --> 01:23:58.320]  То есть, если в B хотя бы один символ, если бы пустое слово, то, соответственно, B1 тоже пустое слово, B-штрих пустое слово. Понимаете, да?
[01:23:58.320 --> 01:24:08.320]  То есть, мы сместились вправо, теперь головка, вот это B1, первый символ, слово B,
[01:24:09.320 --> 01:24:14.320]  перешли в состояние Q-штрих и после следующий символ, слово B.
[01:24:17.320 --> 01:24:19.320]  Понятно, да? Пояснить что-то.
[01:24:21.320 --> 01:24:26.320]  Ну, а влево, если команда сместится влево, понятно, что сделать.
[01:24:28.320 --> 01:24:56.320]  Если команда программы A, QM, и нужно B-штрих или left, то у нас будет вот такая штука.
[01:24:58.320 --> 01:25:09.320]  Да, как раз успели, притык. Ну ладно, это отлично, что мы успели сегодня машину тьюринга.
[01:25:10.320 --> 01:25:17.320]  Вот дальше пойдет неформальная вещь, ребят. Я не люблю махать руками, там есть такие вещи.
[01:25:17.320 --> 01:25:33.320]  Значит, то следующая конфигурация. Там уже неформальная такая вещь, ребят, и обычно начало все понимают,
[01:25:34.320 --> 01:25:42.320]  но в конце теряются, постарайтесь, я постараюсь уже не потерять вас к концу, там довольно сложные вещи идут.
[01:25:42.320 --> 01:26:01.320]  Значит, A-штрих мы переходим в A-N-T, состояние Q-штрих, и дальше будет слово B.
[01:26:01.320 --> 01:26:16.320]  Ну, то есть если мы должны сместиться влево, то есть где A есть A-штрих, то есть мы должны сместиться влево,
[01:26:17.320 --> 01:26:26.320]  теперь после смещения мы смотрим вот сюда, до этого A-штрих идет, а после как раз символ B, который мы написали на этом месте,
[01:26:26.320 --> 01:26:38.320]  следующие слова. Поняли, да? Вот это формально вычисление на машине тьюринга так задается. Ну, продолжим в следующий раз.
