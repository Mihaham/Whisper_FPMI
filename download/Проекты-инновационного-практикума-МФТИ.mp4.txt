[00:00.000 --> 00:07.800]  Итак, всем привет.
[00:07.800 --> 00:10.480]  Моя тема называется синтез музыкальных фраз и мелодий
[00:10.480 --> 00:14.480]  генеративными алгоритмами.
[00:14.480 --> 00:17.800]  Вообще область создания генеративной музыки достаточно
[00:17.800 --> 00:23.840]  молодая, и в ней нет каких-то серьезных солидных достижений,
[00:23.840 --> 00:26.320]  которые можно было бы пустить в массы.
[00:26.320 --> 00:32.560]  Пока все, что создается, звучит не очень вкусно,
[00:32.560 --> 00:38.600]  и пока что вот так вот.
[00:38.600 --> 00:42.960]  Но недавние достижения в области генерации картинок,
[00:42.960 --> 00:47.800]  лиц способствуют, расширяют возможность генерации
[00:47.800 --> 00:55.800]  музыки, но создание настраиваемого, полного, красивого мелодии
[00:55.800 --> 00:58.680]  является еще достаточно тяжелой задачей.
[00:58.680 --> 01:04.360]  Есть несколько основных методов в области генерации
[01:04.360 --> 01:09.000]  музыки, и один из них является использование генеративно-соседательных
[01:09.000 --> 01:10.000]  сетей.
[01:10.000 --> 01:16.040]  Поэтому целью моей работы является попробовать применить
[01:16.040 --> 01:22.240]  эти ганы в области создания музыки и получить какую-то
[01:22.240 --> 01:23.240]  приятную мелодию.
[01:24.120 --> 01:27.760]  Наверное, вы все знаете, как работают эти генеративно-соседательные
[01:27.760 --> 01:28.760]  сети.
[01:28.760 --> 01:33.000]  Она состоит из двух нейронных сетей.
[01:33.000 --> 01:39.640]  Одна из них генерирует стэмпл, а вторая пытается
[01:39.640 --> 01:43.680]  предугадать, является он реальным или генерированным.
[01:43.680 --> 01:45.480]  И так они друг друга тренируют.
[01:45.480 --> 01:54.760]  Если понаблюдать, как музыканты создают песни, они чаще
[01:54.760 --> 01:59.280]  всего пользуются программами работы с midi-файлами.
[01:59.280 --> 02:10.360]  Это всегда небольшое число хорошо сочетаемых звуков,
[02:10.360 --> 02:11.360]  немного баса.
[02:11.360 --> 02:13.760]  На бас я пока не зарекаюсь.
[02:13.760 --> 02:21.640]  Поэтому мое предложение подать на вход генератору
[02:21.640 --> 02:26.760]  заранее выбранный, возможно, достаточно большой набор
[02:26.760 --> 02:32.880]  тех звуков, которые станут базовыми в генерируемых
[02:32.880 --> 02:33.880]  мелодиях.
[02:33.880 --> 02:50.360]  И на выходе я должен получить хорошо звучащий мелодию.
[02:50.360 --> 02:52.200]  Вот такие мои ожидания.
[02:52.200 --> 02:55.160]  Наверное, это все.
[03:03.880 --> 03:12.520]  Я примерно представляю, как ганн генерируется лица,
[03:12.520 --> 03:13.520]  например.
[03:13.520 --> 03:20.320]  Но у меня сейчас такая мысль, что лица будут более
[03:20.320 --> 03:21.320]  однородны, что ли.
[03:21.320 --> 03:23.320]  Массив данных гораздо, чем сэмпл.
[03:23.320 --> 03:26.040]  Как вообще будет бороться с этим?
[03:26.040 --> 03:28.520]  Откуда взять хорошую базу данных сэмплов, чтобы они
[03:28.520 --> 03:31.320]  были условно как-то примерно?
[03:32.200 --> 03:35.120]  Вообще существуют базы данных midi-файлов.
[03:35.120 --> 03:39.320]  Само себе midi-файл, там может быть что угодно.
[03:39.320 --> 03:41.320]  Совершенно неприятные.
[03:45.320 --> 03:48.320]  Существуют базы хороших уже готовых мелодий.
[03:48.320 --> 03:52.320]  И если пробовать применить.
[03:52.320 --> 03:59.320]  То, что я видел, эти примеры обычно связаны с какими-то
[03:59.320 --> 04:03.320]  классическими инструментами.
[04:03.320 --> 04:07.320]  Я, наверное, хотел бы, во-первых, попробовать сделать
[04:07.320 --> 04:11.320]  мелодии в другом стиле, не использовать классические
[04:11.320 --> 04:13.320]  инструменты, а использовать какие-то синтетические
[04:13.320 --> 04:17.320]  звуки, которые популярны в каких-то поп, хайпер поп
[04:17.320 --> 04:18.320]  треках.
[04:24.320 --> 04:26.320]  Наверное, так.
[04:29.320 --> 04:33.320]  Но ты же не можешь просто там послушать и сказать,
[04:33.320 --> 04:36.320]  о, у меня какие-то слухи с кем-то остальные.
[04:36.320 --> 04:38.320]  Какой-то кейсик почитать.
[04:42.320 --> 04:47.320]  То, что я читал, честно говоря, предлагается все-таки
[04:47.320 --> 04:49.320]  оценивание человеком.
[04:53.320 --> 04:58.320]  Метрикой хорошего стрека будет то, что моя сеть уловит
[04:58.320 --> 05:03.320]  то, что надо повторять какие-то части, то есть
[05:03.320 --> 05:05.320]  будут какие-то повторяющиеся куски.
[05:08.320 --> 05:12.320]  Ну, будет мелодия с какой-то, ну, какой-то явной структурой.
[05:15.320 --> 05:16.320]  Ну, как-то так.
[05:19.320 --> 05:22.320]  Всем привет, я Алиан Алиев и тема моей работы
[05:22.320 --> 05:24.320]  «Афинность взаимодействия протеинов».
[05:25.320 --> 05:26.320]  Вот.
[05:26.320 --> 05:31.320]  В целом мы изучаем протеиновые комплексы и их взаимодействия,
[05:31.320 --> 05:34.320]  где мерой силы взаимодействия мы будем рассматривать
[05:34.320 --> 05:36.320]  константу диссоциации.
[05:36.320 --> 05:40.320]  Наша цель – это вывести модель для предсказания
[05:40.320 --> 05:42.320]  этой самой константа.
[05:49.320 --> 05:51.320]  Чтобы чуть подробнее разобраться, как это все выглядит,
[05:51.320 --> 05:52.320]  можно обратиться к картинке.
[05:52.320 --> 05:55.320]  Это обычный пример протеинного комплекса.
[05:55.320 --> 05:58.320]  И мы считаем, что он состоит из двух протеинов,
[05:58.320 --> 06:00.320]  которые, собственно, взаимодействуют друг с другом,
[06:00.320 --> 06:04.320]  где каждый протеин – это набор каких-то цепочек.
[06:04.320 --> 06:07.320]  Цепочка состоит, в свою очередь, из атомов,
[06:07.320 --> 06:10.320]  и эти атомы образуют некоторые аминокислоты,
[06:10.320 --> 06:13.320]  их там примерно 20 штук, вообще известные.
[06:13.320 --> 06:16.320]  Истресноатом – это просто точка в трехмерном пространстве.
[06:16.320 --> 06:20.320]  То есть, если подытожить, вся наша фигура – это просто
[06:20.320 --> 06:22.320]  какой-то набор точек в 3D.
[06:25.320 --> 06:27.320]  Здесь вы можете видеть список литературы,
[06:27.320 --> 06:29.320]  которым я вдохновлялся в процессе.
[06:35.320 --> 06:38.320]  Еще немного поговорим про наш датасет.
[06:38.320 --> 06:42.320]  Основная проблема с данными в том,
[06:42.320 --> 06:45.320]  что не до конца понятно, какие именно атомы
[06:45.320 --> 06:47.320]  или даже цепочки взаимодействуют друг с другом.
[06:47.320 --> 06:49.320]  И это тоже одна из проблем,
[06:49.320 --> 06:51.320]  которую нам предстоит решить.
[06:51.320 --> 06:54.320]  В частности, самый интуитивно-логичный подход,
[06:54.320 --> 06:56.320]  который мы применяем в данный момент –
[06:56.320 --> 06:58.320]  это сказать, что атомы взаимодействующие,
[06:58.320 --> 07:00.320]  если они расположены близко друг к другу,
[07:00.320 --> 07:02.320]  а, соответственно, цепочки назовем взаимодействующими
[07:02.320 --> 07:04.320]  и будем рассматривать дальше их,
[07:04.320 --> 07:07.320]  если у них как можно больше взаимодействующих пар атомов.
[07:09.320 --> 07:10.320]  Продолжим отсюда.
[07:10.320 --> 07:13.320]  Мы будем предсказывать таргет константа диссоциации,
[07:13.320 --> 07:15.320]  логарифм константа диссоциации,
[07:15.320 --> 07:17.320]  потому что она визуально похожа на нормальную,
[07:17.320 --> 07:19.320]  поэтому очень приятная величина для предсказания.
[07:19.320 --> 07:22.320]  И будем в частности использовать метрику МСЕ
[07:22.320 --> 07:24.320]  и batch accuracy.
[07:24.320 --> 07:27.320]  То есть мы разобьём вот этот вот логарифм
[07:27.320 --> 07:29.320]  на бачи примерно равномерные
[07:29.320 --> 07:36.320]  и будем считать точность уже на вот этих вот категориальных таргетах.
[07:40.320 --> 07:42.320]  Перед нами теперь встает проблема,
[07:42.320 --> 07:44.320]  а как же вот эту всю большую фигуру,
[07:44.320 --> 07:46.320]  которая просто набор точек в трёхмерии,
[07:46.320 --> 07:49.320]  представить в каком-то адекватном виде.
[07:49.320 --> 07:51.320]  И мы предлагаем два пути.
[07:51.320 --> 07:54.320]  Первый из них – это сказать,
[07:54.320 --> 07:57.320]  что вот мы выбрали две цепочки взаимодействующих.
[07:57.320 --> 08:00.320]  Взять центр масс всех взаимодействующих пар атомов,
[08:00.320 --> 08:02.320]  сказать, что это центр взаимодействия.
[08:02.320 --> 08:05.320]  Дальше отложить в каждую сторону небольшое расстояние.
[08:05.320 --> 08:08.320]  Мы рассматриваем примерно 10-20 angstroms.
[08:08.320 --> 08:11.320]  Angstrom – это 10-10 метра.
[08:11.320 --> 08:15.320]  И сказать, что теперь у нас есть кубик 20 на 20 на 20.
[08:15.320 --> 08:18.320]  Все атомы, которые уже попали, мы учтём,
[08:18.320 --> 08:20.320]  а остальные нас не так уж и интересуют.
[08:20.320 --> 08:22.320]  Таким образом мы получим вот этот кубик,
[08:22.320 --> 08:26.320]  и его уже можно скормить любой КНН-модели.
[08:28.320 --> 08:30.320]  Второй подход, крайне различающийся, –
[08:30.320 --> 08:35.320]  это скормить что-нибудь гафом, нейронком.
[08:35.320 --> 08:39.320]  В частности, у нас есть такой вариант
[08:39.320 --> 08:42.320]  сказать, что набор вершин – это все атомы,
[08:42.320 --> 08:46.320]  и мы проводим ориентированное ребро из итового атома в житый,
[08:46.320 --> 08:50.320]  если житый попал в ка ближайших соседей к итому.
[08:53.320 --> 08:57.320]  Тут какие-то графики обучения наших моделей,
[08:57.320 --> 08:59.320]  которые в целом пока сделаны на искусственных данных,
[08:59.320 --> 09:01.320]  более-менее, поэтому не очень нас интересует.
[09:01.320 --> 09:04.320]  Тут тоже какие-то метрики.
[09:04.320 --> 09:07.320]  И вывод, что наше достижение в том,
[09:07.320 --> 09:10.320]  что мы представили два новых взгляда на проблему
[09:10.320 --> 09:14.320]  и провели какой-то эксперимент, все посчитали, поведи.
[09:22.320 --> 09:27.320]  Ну вот, к Майе планирую это все доделать на всех данных, как минимум,
[09:27.320 --> 09:31.320]  и планирую сделать какой-то более подробный вывод.
[09:33.320 --> 09:37.320]  Они не совсем искусственные, я бы сказал, что они неполные.
[09:37.320 --> 09:40.320]  Ну и в частности у нас есть еще несколько идей.
[09:40.320 --> 09:43.320]  Например, можно подробнее осмотреть графовый подход,
[09:43.320 --> 09:47.320]  можно, например, рассматривать как вершины не только атомы,
[09:47.320 --> 09:49.320]  но и цепочки, брать их в центр масс,
[09:49.320 --> 09:52.320]  можно ребра проводить не только как КНН,
[09:52.320 --> 09:56.320]  а, например, ставить какой-то trash-hold один на все,
[09:56.320 --> 10:00.320]  можно также брать диаграмму Вороновой
[10:00.320 --> 10:02.320]  и проводить ребра руководствуясь ей.
[10:02.320 --> 10:05.320]  В общем, простор для воображения есть.
[10:05.320 --> 10:09.320]  Минимизируем функцию риска, представляемого в виде суммы,
[10:09.320 --> 10:12.320]  соответственно, f, i, t, h, n, l, d, n,
[10:12.320 --> 10:15.320]  где n мы берем достаточно большим.
[10:15.320 --> 10:21.320]  В данном случае наша работа исследуется для функции риска конкретного вида,
[10:21.320 --> 10:23.320]  вы можете видеть на слайде.
[10:25.320 --> 10:30.320]  Естественно, существуют различные алгоритмы поиска минимум этих функций,
[10:30.320 --> 10:34.320]  алгоритмы первого порядка имеют особенность в том,
[10:34.320 --> 10:38.320]  что они зависят от...
[10:42.320 --> 10:44.320]  Так, да.
[10:44.320 --> 10:46.320]  Я понял.
[10:46.320 --> 10:50.320]  Что они были выкопаны,
[10:50.320 --> 10:52.320]  что они были выкопаны,
[10:52.320 --> 10:54.320]  что они были выкопаны,
[10:54.320 --> 10:56.320]  что они были выкопаны,
[10:56.320 --> 10:58.320]  я понял.
[10:58.320 --> 11:02.320]  Что они в определенных сетках
[11:02.320 --> 11:05.320]  имеют плохую скорость сходимости,
[11:05.320 --> 11:09.320]  то есть, например, при большом отношении
[11:09.320 --> 11:13.320]  между собственным значением и матрицей
[11:15.320 --> 11:18.320]  а транспонированная а
[11:18.320 --> 11:22.320]  с алгоритмом могут сходиться очень плохо.
[11:22.320 --> 11:25.320]  Поэтому используются методы Ньютона второго порядка,
[11:25.320 --> 11:29.320]  соответственно, зависят от матрицы Гесиана.
[11:31.320 --> 11:35.320]  Тем не менее, в случае большого Н,
[11:35.320 --> 11:39.320]  если использовать обычный нестахотический алгоритм,
[11:41.320 --> 11:45.320]  на каждой тарасе нам придется вычислять Н Гесианов,
[11:45.320 --> 11:48.320]  что достаточно долго и сложно.
[11:48.320 --> 11:52.320]  Поэтому хотелось бы использовать стахотический алгоритм,
[11:52.320 --> 11:56.320]  в отличие от методов первого порядка,
[11:56.320 --> 11:58.320]  он не будет сходиться.
[11:58.320 --> 12:01.320]  То есть, за счет того, что метода второго порядка
[12:01.320 --> 12:03.320]  сходится очень быстро к функции,
[12:03.320 --> 12:06.320]  в случае использования бачей,
[12:06.320 --> 12:10.320]  то есть, выбора какого-то подможества функции F
[12:10.320 --> 12:14.320]  и сходения к максимуму конкретному подможеству,
[12:14.320 --> 12:16.320]  мы будем сходиться к...
[12:16.320 --> 12:20.320]  очень быстро сходиться к оптимуму конкретно этих функций,
[12:20.320 --> 12:26.320]  из-за чего оптимум глобальной суммы будет находиться очень плохо.
[12:26.320 --> 12:30.320]  Поэтому используется мотивикация алгоритма,
[12:30.320 --> 12:32.320]  использующая память.
[12:32.320 --> 12:34.320]  То есть, мы не...
[12:34.320 --> 12:37.320]  Каждый шаг стахотического алгоритма
[12:37.320 --> 12:41.320]  мы не выбираем какое-то подможество
[12:41.320 --> 12:43.320]  и переходим к...
[12:43.320 --> 12:45.320]  и сдвигаемся в сторону оптимума,
[12:45.320 --> 12:48.320]  а сдвигаемся лишь с каким-то весом
[12:48.320 --> 12:51.320]  в сторону оптимума.
[12:51.320 --> 12:53.320]  Не в сторону оптимума,
[12:53.320 --> 12:55.320]  мы лишь изменяем...
[12:55.320 --> 12:57.320]  Давайте открою.
[12:59.320 --> 13:02.320]  Мы лишь изменяем
[13:04.320 --> 13:08.320]  какую-то долю значений из нашей суммы.
[13:09.320 --> 13:12.320]  В случае обычного стахотического алгоритма
[13:12.320 --> 13:15.320]  функции выбираются равновероятно
[13:15.320 --> 13:18.320]  соответственно из множества от 1 до n.
[13:18.320 --> 13:21.320]  Мы же решили попробовать
[13:21.320 --> 13:23.320]  другие стратеги выбора
[13:23.320 --> 13:25.320]  батча.
[13:25.320 --> 13:27.320]  В данном случае мы берем
[13:27.320 --> 13:31.320]  константу липшица для каждой функции афыта
[13:31.320 --> 13:35.320]  и выбираем функцию афыта с вероятностью пропорционального этой константе.
[13:37.320 --> 13:43.320]  За основу были взяты алгоритмы из статей,
[13:43.320 --> 13:45.320]  которые вы можете видеть на слайдинг,
[13:45.320 --> 13:47.320]  и стратеги сэмплирования из 2 ст.
[13:57.320 --> 14:00.320]  Мы рассматриваем следующую характеристику
[14:00.320 --> 14:02.320]  нашей сходимости.
[14:02.320 --> 14:04.320]  Поскольку алгоритм работает
[14:04.320 --> 14:09.320]  только в окрестности максимума,
[14:09.320 --> 14:12.320]  мы рассматриваем отношение
[14:12.320 --> 14:16.320]  до оптимального значения
[14:16.320 --> 14:18.320]  к расстоянию из точки,
[14:18.320 --> 14:20.320]  в которой мы стартовали.
[14:20.320 --> 14:23.320]  Мы сначала запускаем обычный
[14:23.320 --> 14:26.320]  гридиентный спуск
[14:26.320 --> 14:30.320]  с той итерацией,
[14:30.320 --> 14:32.320]  и дальше смотрим,
[14:32.320 --> 14:35.320]  насколько наш алгоритм
[14:36.320 --> 14:40.320]  запускаем наш алгоритм из данной точки.
[14:40.320 --> 14:43.320]  Сравнивается он с алгоритмом
[14:43.320 --> 14:46.320]  запущенного на 10 000 полуметрацей.
[14:50.320 --> 14:54.320]  На данный момент мы провели
[14:54.320 --> 14:59.320]  пробный эксперимент для небольшого количества лямб и бачей.
[14:59.320 --> 15:02.320]  Лямб – это соответственно
[15:03.320 --> 15:06.320]  параметр регулизации
[15:06.320 --> 15:09.320]  нашей функции фриты.
[15:09.320 --> 15:12.320]  Пока что ускорение получилось
[15:12.320 --> 15:14.320]  в 2.2 раза.
[15:14.320 --> 15:17.320]  Мы в перспективе проведем
[15:17.320 --> 15:20.320]  в более адекватный вид
[15:20.320 --> 15:23.320]  в виде какой-то гипотезы
[15:23.320 --> 15:26.320]  и длительного интервала.
[15:28.320 --> 15:31.320]  Это план на ближайший месяц.
[15:33.320 --> 15:36.320]  Спасибо.
[15:38.320 --> 15:41.320]  По сравнению с классическим алгоритмом
[15:41.320 --> 15:44.320]  с весом взятым одной N.
[15:49.320 --> 15:52.320]  Из-за задачи используется именно этот алгоритм.
[15:52.320 --> 15:55.320]  Задача довольно узкая в том смысле,
[15:55.320 --> 15:58.320]  что в нашей задачи мы осмотрим очень большое N
[15:58.320 --> 16:01.320]  и при этом хотим использовать стахистические алгоритмы.
[16:01.320 --> 16:04.320]  Это классический алгоритм
[16:04.320 --> 16:07.320]  стахистического вида.
[16:07.320 --> 16:10.320]  В нём используется обычный выбор весов.
[16:10.320 --> 16:13.320]  Мы немножко модифицируем
[16:13.320 --> 16:16.320]  и рассмотрим разные стратегии сэмплинга.
[16:19.320 --> 16:22.320]  Два раза больше?
[16:22.320 --> 16:25.320]  Два раза больше.
[16:25.320 --> 16:28.320]  Два раза больше.
[16:29.320 --> 16:32.320]  Два раза, да.
[16:32.320 --> 16:35.320]  Но это на бачах небольшого размера.
[16:35.320 --> 16:38.320]  Обычно используются бачи большого размера.
[16:38.320 --> 16:41.320]  Нам конкретно в какой-то проблеме
[16:41.320 --> 16:44.320]  научного руководителя нужны именно маленькие бачи.
[16:44.320 --> 16:47.320]  Поэтому на маленьких бачах
[16:47.320 --> 16:50.320]  классический алгоритм работает не очень хорошо.
[16:50.320 --> 16:53.320]  Мы его оптимизируем под конкретные бачи.
[16:53.320 --> 16:56.320]  Просто нужна была задача в узком виде.
[16:58.320 --> 17:01.320]  Но в сайте действительно уже есть
[17:01.320 --> 17:04.320]  некоторое теоретическое обоснование,
[17:04.320 --> 17:07.320]  пока не до конца.
[17:07.320 --> 17:10.320]  В общем, доказана сходимость
[17:10.320 --> 17:13.320]  этого алгоритма с взвешенными вероятностями
[17:13.320 --> 17:16.320]  в случае, если они отклоняются
[17:16.320 --> 17:19.320]  от того, что мы делали.
[17:19.320 --> 17:22.320]  В общем, доказана сходимость
[17:22.320 --> 17:25.320]  этого алгоритма с взвешенными вероятностями
[17:25.320 --> 17:28.320]  если они отклоняются от 1n
[17:28.320 --> 17:31.320]  не более чем в 4 раза.
[17:31.320 --> 17:34.320]  То есть, если
[17:34.320 --> 17:37.320]  каждый вес хотя бы 1 на 4n
[17:37.320 --> 17:40.320]  вниз не больше чем в 4 раза.
[17:40.320 --> 17:43.320]  Так же будем стараться
[17:43.320 --> 17:46.320]  улучшить эту техническую оценку
[17:46.320 --> 17:49.320]  до произвольных весов.
[17:49.320 --> 17:52.320]  Вот так было
[17:52.320 --> 17:55.320]  построение модели,
[17:55.320 --> 17:58.320]  которая могла бы находить
[17:58.320 --> 18:01.320]  формату различных слов в тексте
[18:01.320 --> 18:04.320]  независимо от его языковой принадлежности.
[18:04.320 --> 18:07.320]  Также были
[18:07.320 --> 18:10.320]  установлены некоторые
[18:10.320 --> 18:13.320]  жесткие ограничения на размерственной модели
[18:13.320 --> 18:16.320]  для ее практического использования,
[18:16.320 --> 18:19.320]  на 100 гигабайт объем,
[18:19.320 --> 18:22.320]  а также время обучения должно
[18:22.320 --> 18:25.320]  происходить 24 часа.
[18:25.320 --> 18:28.320]  Именно самая задача текстового поиска
[18:28.320 --> 18:31.320]  в стандартный момент решается как получение фил
[18:31.320 --> 18:34.320]  либо эмбридинга текстового документа,
[18:34.320 --> 18:37.320]  а далее уже в данном пространстве векторном
[18:37.320 --> 18:40.320]  мы кандидатами на плагиат называем те документы,
[18:40.320 --> 18:43.320]  которые имеют довольно близкое расстояние.
[18:43.320 --> 18:46.320]  И в нашей работе
[18:46.320 --> 18:49.320]  предполагается использовать в качестве модели,
[18:49.320 --> 18:52.320]  которая получает текстовый эмбридинг
[18:52.320 --> 18:55.320]  к тематическому эмбридованию.
[18:55.320 --> 18:58.320]  Сама тематическая модель по коллекции документов
[18:58.320 --> 19:01.320]  строит вариаторное распределение
[19:01.320 --> 19:04.320]  слов в тексте, а также
[19:04.320 --> 19:07.320]  принадлежность к тексту в тексте.
[19:07.320 --> 19:10.320]  А также можно использовать модальность.
[19:10.320 --> 19:13.320]  И мы можем понимать различные методы информации
[19:13.320 --> 19:16.320]  по статье, например, автора статьи, различные
[19:16.320 --> 19:19.320]  изображения на этой статье, те, кто не был
[19:19.320 --> 19:22.320]  ссылал, или кто был ссылал статья. И вся эта информация
[19:22.320 --> 19:25.320]  также позволяет нам больше получить информацию
[19:25.320 --> 19:28.320]  о самом документе.
[19:28.320 --> 19:31.320]  Также сам подвод.
[19:31.320 --> 19:34.320]  И мы планируем использовать 100 языков в качестве
[19:34.320 --> 19:37.320]  кроме модальности. Основной литературой,
[19:37.320 --> 19:40.320]  которую я прислал в данной статье, является методичка
[19:40.320 --> 19:43.320]  Испаранцова, которая описана тематическое моделирование,
[19:43.320 --> 19:46.320]  а также обычный способ регуляризации для того, чтобы
[19:46.320 --> 19:49.320]  его использовать.
[19:49.320 --> 19:52.320]  Теперь я хочу описать самые данные о изучении модели.
[19:52.320 --> 19:55.320]  Это были статьи с двух сайтов. Один в Икипетии,
[19:55.320 --> 19:58.320]  а другой в Элайвере.
[19:58.320 --> 20:01.320]  Все статьи были взяты примерно на 100 языках.
[20:01.320 --> 20:04.320]  И для большинства этих статьей уже были заранее известны
[20:04.320 --> 20:07.320]  УДК, это Универсальный Личный Классификатор.
[20:07.320 --> 20:10.320]  Это 10 основных тематик довольно обширных.
[20:10.320 --> 20:13.320]  И Гарантии. Гарантии это тоже рубрики,
[20:13.320 --> 20:16.320]  при этом немного большие, около 70. И они более точно
[20:16.320 --> 20:19.320]  описывают тему документов.
[20:19.320 --> 20:22.320]  Также был произведен машинный перевод по точной статье
[20:22.320 --> 20:25.320]  на 42 языка.
[20:25.320 --> 20:28.320]  Далее я хочу описать оценки качества.
[20:28.320 --> 20:31.320]  Для каждого документа я просто сказал, что заранее был 10-й перевод.
[20:31.320 --> 20:34.320]  Я хотел бы просто понять, как точная модель
[20:34.320 --> 20:37.320]  составляет перевод и оригинал в объекторном пространстве.
[20:37.320 --> 20:40.320]  Насколько были взяты.
[20:40.320 --> 20:43.320]  Поэтому были предложены две значения.
[20:43.320 --> 20:46.320]  Первая – это метрика качества личного поиска.
[20:46.320 --> 20:49.320]  То есть та доля случаев, в которых документы перевода
[20:49.320 --> 20:52.320]  попадают в 10% в ближайших документах оригинала.
[20:52.320 --> 20:55.320]  То есть фиксируется оригинал, для него уже сортируются
[20:55.320 --> 20:58.320]  все кандидаты на публикаторе.
[20:58.320 --> 21:01.320]  А также средний процент документов с той же самой рубрикой.
[21:01.320 --> 21:04.320]  То есть также мы знаем рубрику документа оригинала.
[21:04.320 --> 21:07.320]  И мы смотрим, какая средняя доля документов
[21:07.320 --> 21:10.320]  имеет ту же самую рубрику в 10%
[21:10.320 --> 21:13.320]  ближайших 10% документов.
[21:13.320 --> 21:16.320]  Также стоит отметить, что для каждого документа
[21:16.320 --> 21:19.320]  мы проводим поиск не по всей рубрике документов,
[21:19.320 --> 21:22.320]  лишь по ее подубрике.
[21:22.320 --> 21:25.320]  Мы устроили таким образом, что 10% документов имеет тот же самый код,
[21:25.320 --> 21:28.320]  к примеру, ДК. А 90% документов
[21:28.320 --> 21:31.320]  имеют отличный код.
[21:31.320 --> 21:34.320]  На самой модели, качестве базовой модели,
[21:34.320 --> 21:37.320]  была взята темдическая модель, как я уже сказал.
[21:37.320 --> 21:40.320]  И для нее был предложен ряд эвристий.
[21:40.320 --> 21:43.320]  Во-первых, были выделены 125 отдельных тем.
[21:43.320 --> 21:46.320]  Так как в темдической модели можно оригиналировать
[21:46.320 --> 21:49.320]  технические темы, и вот было предложено остановиться
[21:49.320 --> 21:52.320]  на 25. Также были все физиков, которые
[21:52.320 --> 21:55.320]  включались в различные столбства.
[21:55.320 --> 21:58.320]  И сам алгоритм
[21:58.320 --> 22:01.320]  обучения темдической модели итерационно.
[22:01.320 --> 22:04.320]  Соответственно, на каждой итерации мы делали
[22:04.320 --> 22:07.320]  подвыборку тех документов более равномерно
[22:07.320 --> 22:10.320]  для обучения того, чтобы модель
[22:10.320 --> 22:13.320]  включалась на всех сразу по рубрикам.
[22:13.320 --> 22:16.320]  Потому что, если я вот туда-то немного ориентируюсь,
[22:16.320 --> 22:19.320]  мы видим, сами рубрики вообще не сбалансировали.
[22:19.320 --> 22:22.320]  Вот. Сами первая рубрика про УДК
[22:22.320 --> 22:25.320]  существует, бля, шестая рубрика, в которой очень много документов,
[22:25.320 --> 22:28.320]  как откажется, тысяча и седьмая рубрика, в которой почти ничего нет.
[22:28.320 --> 22:31.320]  Вот. Ну и, соответственно, то же самое с ГРНТИ.
[22:31.320 --> 22:34.320]  Также стоит отметить, что в рубрике ГРНТИ существует рубрика «Нет»,
[22:34.320 --> 22:37.320]  в которую попали все документы, для которой не было
[22:37.320 --> 22:40.320]  не было понятного такой рубрики в отношении.
[22:40.320 --> 22:43.320]  Это, кажется, четвертая рубрика или пятая.
[22:43.320 --> 22:46.320]  То есть эта рубрика довольно большая,
[22:46.320 --> 22:49.320]  модель сложена на таких документах,
[22:49.320 --> 22:52.320]  в которых не понятно, какая у них тема,
[22:52.320 --> 22:55.320]  ну, определить ее тема. Вот.
[22:55.320 --> 22:58.320]  Также в процессе предобработки текстов используется
[22:58.320 --> 23:01.320]  такая организация, это разбиение слова
[23:01.320 --> 23:04.320]  на группы, ну, группы губ,
[23:04.320 --> 23:07.320]  например, три или четыре, вот.
[23:07.320 --> 23:10.320]  Ими используют для каждого языка 11 тысяч токенов.
[23:10.320 --> 23:13.320]  Для того, чтобы, во-первых, ограничить предмет модели,
[23:13.320 --> 23:16.320]  потому что существует именно количество токенов
[23:16.320 --> 23:19.320]  и влияет на общие нуждевые модели.
[23:19.320 --> 23:22.320]  А также для того, чтобы сохранить родительность
[23:22.320 --> 23:25.320]  и способность модели именно, как обрабатывать текст.
[23:25.320 --> 23:28.320]  Вот. Ну, и было использовано временное решение
[23:28.320 --> 23:31.320]  отгадаться в самую среднюю рубрику «Нет» для того, чтобы
[23:31.320 --> 23:34.320]  ну, не загружать модель, чтобы она не пыталась построить свою цитату.
[23:34.320 --> 23:37.320]  Вот. И в итоге модель
[23:37.320 --> 23:40.320]  занимает 96 гигабайт,
[23:40.320 --> 23:43.320]  с теми ограничениями, которые были установлены.
[23:43.320 --> 23:46.320]  И обучение занимает примерно 27 часов. Вот.
[23:46.320 --> 23:49.320]  Здесь показано, как меняется одна из метрик,
[23:49.320 --> 23:52.320]  например, средняя частота ГРМТИ. Вот, мы видим, что
[23:52.320 --> 23:55.320]  на первых, там, десяти итерациях определяем
[23:55.320 --> 23:58.320]  алгоритм при пехотичке составляется. Вот.
[23:58.320 --> 24:01.320]  Далее ставим сравнение базовой модели
[24:01.320 --> 24:04.320]  тематической, которая без пехотички будет быть, и итоговой.
[24:04.320 --> 24:07.320]  Как мы видим, качество довольно серьезно повышается.
[24:07.320 --> 24:10.320]  Вот. А также в будущем планируется
[24:10.320 --> 24:13.320]  использовать также еще
[24:13.320 --> 24:16.320]  брейтлайн-модель Exelembramberta. Это нерестивая модель,
[24:16.320 --> 24:19.320]  которая, ну, которая тоже строит
[24:19.320 --> 24:22.320]  рубрик и текст. Вот.
[24:22.320 --> 24:25.320]  Ну, и в заключение мы сказали, что мы предложили метод,
[24:25.320 --> 24:28.320]  который получает реакторное
[24:28.320 --> 24:31.320]  представление текста, а также была построена модель для поиска
[24:31.320 --> 24:34.320]  дублика, и ограничения, которые были
[24:34.320 --> 24:37.320]  установлены, были достигнуты. Вот.
[24:37.320 --> 24:40.320]  За ближайший месяц планируется провести также эвакуационные эксперименты,
[24:40.320 --> 24:43.320]  которые покажут, насколько серьезными были те
[24:43.320 --> 24:46.320]  или иные выклады каких-то отдельных предок пиши.
[24:46.320 --> 24:49.320]  У меня все. Спасибо.
[24:54.320 --> 24:57.320]  Ограничение о каком железе?
[24:57.320 --> 25:00.320]  Просто говорите про время.
[25:00.320 --> 25:03.320]  Все-таки зависит от того, где вы учитесь.
[25:03.320 --> 25:06.320]  Да, там, в более строгих ограничениях, там указано
[25:06.320 --> 25:09.320]  даже как это железо, которым можно было проследить ограничение.
[25:09.320 --> 25:12.320]  А я вот здесь его не указываю.
[25:12.320 --> 25:15.320]  Но оно вот так действует.
[25:15.320 --> 25:18.320]  Дальше вопрос про машины перевода.
[25:18.320 --> 25:21.320]  Сделано для того, чтобы отыскивать плагиаты, которые
[25:21.320 --> 25:24.320]  должны в машинном переводе, или как истинный
[25:24.320 --> 25:27.320]  перевод текста? Ну, он сделан для того, чтобы
[25:27.320 --> 25:30.320]  и поискать реальную машину в переводе, но ей не стоящих
[25:30.320 --> 25:33.320]  текста. Вот. Ну, значит, кажется мне, что
[25:33.320 --> 25:36.320]  именно эти документы нужно было переводить для того,
[25:36.320 --> 25:39.320]  чтобы перевести на какие-то не очень распространенные языки.
[25:39.320 --> 25:42.320]  Там было указано про 15 языков. Это основные
[25:42.320 --> 25:45.320]  французский, английский, например, немецкий. Вот. А есть
[25:45.320 --> 25:48.320]  какие-то языки, например, что я даже не помню.
[25:48.320 --> 25:51.320]  Ну, не очень распространенные, на которые просто перевода
[25:51.320 --> 25:54.320]  документов в частке нет. Поэтому нужно было как-то такие данные
[25:54.320 --> 25:57.320]  тоже получать. Поэтому было предложено
[25:57.320 --> 25:59.320]  для обучения себя в модели и использовать на машину
[25:59.320 --> 26:01.320]  перевода.
[26:03.320 --> 26:06.320]  Как вы считаете, Реги не помыли, может быть, в каждом
[26:06.320 --> 26:09.320]  моделе?
[26:09.320 --> 26:12.320]  А, Гриндель, это у вас число?
[26:12.320 --> 26:15.320]  Да, это просто первая категория.
[26:15.320 --> 26:18.320]  А вы видите, что это
[26:18.320 --> 26:21.320]  первая категория, а вторая категория.
[26:21.320 --> 26:24.320]  Мы перебираем декабры
[26:24.320 --> 26:27.320]  по всему документу. И у этого документа может быть
[26:27.320 --> 26:30.320]  только первая.
[26:30.320 --> 26:33.320]  И это же усоединяется по всем документам. Мы зафиксировали
[26:33.320 --> 26:36.320]  регионал. У кого регионал есть какой-то под, вот уже
[26:36.320 --> 26:39.320]  на стене этого пода на складке.
[26:39.320 --> 26:42.320]  Что еще раз?
[26:45.320 --> 26:48.320]  Ну, типа того.
[26:49.320 --> 26:52.320]  Угу.
[26:57.320 --> 27:00.320]  Такие названия предположены.
[27:00.320 --> 27:03.320]  Да.
[27:05.320 --> 27:08.320]  Ну, у вас, как раз, тоже, Реги,
[27:08.320 --> 27:11.320]  переобучалась под это. Мы использовали именно
[27:11.320 --> 27:14.320]  генерацию больше, то есть мелких публичных, чтобы как раз
[27:14.320 --> 27:17.320]  контенсировать в некотором роде.
[27:17.320 --> 27:20.320]  Была такая герма, и в ее решении мы использовали
[27:20.320 --> 27:23.320]  именно генерацию больше, например, тех, которые мало.
[27:23.320 --> 27:26.320]  И наоборот, меньше, чем больше, чтобы не было просто
[27:26.320 --> 27:29.320]  полного переобучения в сторону больших.
[27:29.320 --> 27:32.320]  Так, давайте начнем.
[27:32.320 --> 27:35.320]  Так, меня зовут Лидер Кача и я. Я сегодня хочу рассказать про свой проект.
[27:35.320 --> 27:38.320]  Это верификация Cypher на Coq. Значит, давайте сначала обсудим,
[27:38.320 --> 27:41.320]  что такое Cypher, что такое Coq. Значит, Cypher
[27:41.320 --> 27:44.320]  это, значит, есть SQL.
[27:44.320 --> 27:47.320]  Это довольно привычный, значит, язык запросов
[27:47.320 --> 27:50.320]  к революционной базе данных.
[27:50.320 --> 27:53.320]  Но люди в какой-то момент подумались о том,
[27:53.320 --> 27:56.320]  что есть, ну, некоторые данные,
[27:56.320 --> 27:59.320]  но удобнее представлять веграфов.
[27:59.320 --> 28:02.320]  И, соответственно, появился графовый база данных.
[28:02.320 --> 28:05.320]  И Cypher – это язык запросов.
[28:05.320 --> 28:08.320]  Значит, так как SQL появился достаточно давно,
[28:08.320 --> 28:11.320]  то его достаточно давно и верифицировали.
[28:11.320 --> 28:14.320]  По-моему, они полностью верифицированы.
[28:14.320 --> 28:17.320]  Большая часть SQL – она верифицирована.
[28:17.320 --> 28:20.320]  То есть фактически известно, что то, что делают,
[28:20.320 --> 28:23.320]  если вы пишете запрос, то под капотом
[28:23.320 --> 28:26.320]  делается именно то, что вы хотите от запроса.
[28:26.320 --> 28:29.320]  То есть есть некоторые соответствия,
[28:29.320 --> 28:32.320]  семантики языка и кода языка.
[28:32.320 --> 28:35.320]  И возник вопрос в том, что хорошо бы
[28:35.320 --> 28:38.320]  для SQL это тоже сделать.
[28:39.320 --> 28:42.320]  Значит, давайте перед тем,
[28:42.320 --> 28:45.320]  как я расскажу про цели,
[28:45.320 --> 28:48.320]  я вообще в целом расскажу, как это все устроено,
[28:48.320 --> 28:51.320]  потому что цели завязаны на то, как это устроено.
[28:51.320 --> 28:54.320]  Значит, нужно сначала понять,
[28:54.320 --> 28:57.320]  какая у нас семантика языка.
[28:57.320 --> 29:00.320]  Значит, и у нас вот эта семантика
[29:00.320 --> 29:03.320]  нашей базы данных представляется в виде
[29:03.320 --> 29:06.320]  graph-своист или property-graph.
[29:06.320 --> 29:09.320]  Тут что-то достаточно простое в том плане,
[29:09.320 --> 29:12.320]  что это ребра, вершины и метки.
[29:12.320 --> 29:15.320]  Метки – это, соответственно,
[29:15.320 --> 29:18.320]  это, во-первых, те данные, которые хранятся.
[29:18.320 --> 29:21.320]  То есть там в конце фея обозначены.
[29:21.320 --> 29:24.320]  Фея – пара ключ-значений.
[29:24.320 --> 29:27.320]  То есть у меня может данные храниться как на ребре,
[29:27.320 --> 29:30.320]  так и на вершине.
[29:30.320 --> 29:33.320]  А еще есть метки, которые позволяют нам
[29:33.320 --> 29:36.320]  какие-то ограничения.
[29:36.320 --> 29:39.320]  То есть это неляется непосредственно данными,
[29:39.320 --> 29:42.320]  но при этом они будут давать нам ограничения
[29:42.320 --> 29:45.320]  на поиск каких-то данных внутри этой базы данных.
[29:45.320 --> 29:48.320]  Вот, значит, тут пример такой графический.
[29:48.320 --> 29:51.320]  Наши графы базы данных,
[29:51.320 --> 29:54.320]  то есть у нас есть вершины, ребра между ними,
[29:54.320 --> 29:57.320]  и, соответственно, мы можем находить
[29:57.320 --> 30:00.320]  вершины, значит, какие-то люди,
[30:00.320 --> 30:03.320]  ребра – это какие-то связи между ними,
[30:03.320 --> 30:06.320]  например, коллеги, или один выучит другого.
[30:06.320 --> 30:09.320]  Естественно, я могу сделать запрос такого вида,
[30:09.320 --> 30:12.320]  условно выведение, пожалуйста, человека,
[30:12.320 --> 30:15.320]  у которого учитель-профессор.
[30:15.320 --> 30:18.320]  Ну и, собственно, такие запросы в графы базы данных.
[30:18.320 --> 30:21.320]  Значит, как вы видите,
[30:21.320 --> 30:25.320]  как я показал, что любой запрос в графы базы данных –
[30:25.320 --> 30:28.320]  это какой-то поиск пути в графы базы данных.
[30:28.320 --> 30:31.320]  И последующая вывод информации.
[30:31.320 --> 30:34.320]  И нам нужно для формализации вообще понять,
[30:34.320 --> 30:37.320]  как вы видите паттерны,
[30:37.320 --> 30:40.320]  то есть паттерны, которые еще внутри графа.
[30:40.320 --> 30:43.320]  И для этого нужно понять, что такой вообще
[30:43.320 --> 30:46.320]  паттерн вершины,
[30:46.320 --> 30:49.320]  нот-паттерн – это, фактически,
[30:49.320 --> 30:52.320]  некоторые ограничения, которые мы не сделаем для вершины.
[30:52.320 --> 30:55.320]  То есть мы даем ограничения на лобла,
[30:55.320 --> 30:58.320]  то есть на предыдущей картинке,
[30:58.320 --> 31:01.320]  например, то, что вершина должен быть учителем.
[31:01.320 --> 31:04.320]  И также мы можем дать какие-то ограничения на пары ключ значения.
[31:04.320 --> 31:07.320]  Гразно более интересный является
[31:07.320 --> 31:10.320]  паттерн для…
[31:10.320 --> 31:13.320]  Тут описка, значит, здесь не нот-паттерн,
[31:13.320 --> 31:16.320]  это h-паттерн. Он достаточно похож,
[31:16.320 --> 31:19.320]  но нот-паттерн… Отличия только
[31:19.320 --> 31:22.320]  к красным цветам здесь выделены.
[31:23.320 --> 31:26.320]  Выделены красным цветом.
[31:26.320 --> 31:29.320]  Первое, мы можем давать ограничения на ребра,
[31:29.320 --> 31:32.320]  это первое. А второе,
[31:32.320 --> 31:35.320]  мы можем давать ограничения на количество
[31:35.320 --> 31:38.320]  ребра, которые мы можем пройти в паттерне.
[31:38.320 --> 31:41.320]  То есть, если нот-паттерн для одной вершины,
[31:41.320 --> 31:44.320]  то, значит,
[31:44.320 --> 31:47.320]  h-паттерн он для
[31:47.320 --> 31:50.320]  последовательной…
[31:50.320 --> 31:53.320]  Некоторых предыдущих ребр. То есть, вы можете мне сказать,
[31:53.320 --> 31:56.320]  что я хочу найти вершину,
[31:56.320 --> 31:59.320]  которая будет связана с данной вершиной через два ребра.
[31:59.320 --> 32:02.320]  И эти ребра должны быть приведены к каким-то свойствам.
[32:02.320 --> 32:05.320]  В общем, значит…
[32:05.320 --> 32:08.320]  В целом, это все приведет нас к тому, что у нас есть
[32:08.320 --> 32:11.320]  Reddit-паттерн. Это фактически просто
[32:11.320 --> 32:14.320]  чередование этих, значит,
[32:14.320 --> 32:17.320]  нот-паттернов и h-паттернов.
[32:17.320 --> 32:20.320]  То есть, вы делаете ограничение на ноту,
[32:20.320 --> 32:23.320]  потом ограничение на путь из этой ноты куда-то,
[32:23.320 --> 32:26.320]  на следующую ноту и так далее. То есть, таким образом, ваш запрос
[32:26.320 --> 32:29.320]  непосредственный,
[32:29.320 --> 32:32.320]  он перформируется в этот паттерн,
[32:32.320 --> 32:35.320]  с которым он будет работать.
[32:35.320 --> 32:38.320]  Теперь наша задача — сопоставить этот паттерн в некоторый путь и граф.
[32:38.320 --> 32:41.320]  То есть, паттерн в некоторую структуру, которую мы ищем,
[32:41.320 --> 32:44.320]  а путь — это то, что практически будет нашим ответом.
[32:44.320 --> 32:47.320]  Для этого у нас есть гомоморфизм.
[32:47.320 --> 32:50.320]  Это фактически поиск этого пути.
[32:50.320 --> 32:53.320]  Почему он волк? Потому что там есть еще
[32:53.320 --> 32:56.320]  другие гомоморфизмы.
[32:56.320 --> 32:59.320]  Гомоморфизм является самым общим, потому что он разрешает
[32:59.320 --> 33:02.320]  всевозможные пути. А и гомоморфизмы, которые запрещают,
[33:02.320 --> 33:05.320]  чтобы были какие-то циклы, чтобы были посещены
[33:05.320 --> 33:08.320]  вершины ребра, которые мы уже посещали и так далее.
[33:08.320 --> 33:11.320]  Собственно, здесь снова наш
[33:11.320 --> 33:14.320]  пример.
[33:14.320 --> 33:17.320]  Здесь я написал
[33:17.320 --> 33:20.320]  как это выглядит.
[33:20.320 --> 33:23.320]  Первая строчка — как выглядит запрос
[33:23.320 --> 33:26.320]  на джакуэля.
[33:26.320 --> 33:29.320]  То есть, я хочу найти вершину,
[33:29.320 --> 33:32.320]  у которой есть label-person.
[33:32.320 --> 33:35.320]  Ребро
[33:35.320 --> 33:38.320]  должно удовлетворять такому свойству,
[33:38.320 --> 33:41.320]  что у него есть метка DAS.
[33:41.320 --> 33:44.320]  Ребро должно быть одно, а то, куда я приду, мне все равно.
[33:44.320 --> 33:47.320]  И после этого я показал,
[33:47.320 --> 33:50.320]  как это переформулируется в терминах
[33:50.320 --> 33:53.320]  риги-паттерна.
[33:53.320 --> 33:56.320]  Хорошо, это вообще в целом про семантику.
[33:56.320 --> 33:59.320]  Давайте поговорим, причем тут кок.
[33:59.320 --> 34:02.320]  Что хочется сделать? Хочется понять, что
[34:02.320 --> 34:05.320]  вот у меня есть запрос, и он удовлетворяет кому-то свойство запрос.
[34:05.320 --> 34:08.320]  Он должен вывести то, что
[34:08.320 --> 34:11.320]  я от него хочу, семантически.
[34:11.320 --> 34:14.320]  Это можно понять.
[34:14.320 --> 34:17.320]  Для этого используется следующая модель.
[34:17.320 --> 34:20.320]  То есть, я строю модель на коке,
[34:20.320 --> 34:23.320]  и для этой модели буду что-то доказывать.
[34:23.320 --> 34:26.320]  Соответственно, если я буду доказывать корректность модели на коке,
[34:26.320 --> 34:29.320]  если я считаю, что я модель построил правильно,
[34:29.320 --> 34:32.320]  то это происходит в GQL, в Syfy.
[34:32.320 --> 34:35.320]  Значит, как мы строим модель?
[34:35.320 --> 34:38.320]  Модель строится следующим образом.
[34:38.320 --> 34:41.320]  Вот я показывал, что у нас есть лейбл
[34:41.320 --> 34:44.320]  и у нас есть пары ключ-значений.
[34:44.320 --> 34:47.320]  Для каждой пары ключ-значений
[34:47.320 --> 34:50.320]  я привезу матрицу смежности.
[34:50.320 --> 34:53.320]  То есть, там будет полик идиучки,
[34:53.320 --> 34:56.320]  которая будет соответствовать, что на этом ребре есть такой-то лейбл
[34:56.320 --> 34:59.320]  и пара ключ-значений.
[34:59.320 --> 35:02.320]  То есть, у меня будет множество таких матриц.
[35:02.320 --> 35:05.320]  И смотрите, что дальше происходит.
[35:05.320 --> 35:08.320]  Дальше любой вот тот паттерн, который я должен искать,
[35:08.320 --> 35:11.320]  я могу его переформулировать с точки зрения
[35:11.320 --> 35:14.320]  регулярного выражения.
[35:14.320 --> 35:17.320]  Потому что, условно, если я хочу найти путь
[35:17.320 --> 35:20.320]  из одной вершины в другую,
[35:20.320 --> 35:23.320]  длину условно 2,
[35:23.320 --> 35:26.320]  то что нужно сделать?
[35:26.320 --> 35:29.320]  Мне нужно просто взять матрицу смежности,
[35:29.320 --> 35:32.320]  взять другую матрицу смежности и просто их перемножить.
[35:32.320 --> 35:35.320]  Дальше просто посмотреть на нужную чейку.
[35:35.320 --> 35:38.320]  Есть там нолик и есть не там единичка.
[35:38.320 --> 35:41.320]  Соответственно, что мы делаем?
[35:41.320 --> 35:44.320]  Мы строим матрицу регулярных выражений.
[35:44.320 --> 35:47.320]  То есть, мы по паттерну строим регулярное выражение из матриц.
[35:47.320 --> 35:50.320]  И потом подставляем туда матрицу смежности нашего графа.
[35:50.320 --> 35:53.320]  И дальше мы уже с получившейся матрицой работаем.
[35:53.320 --> 35:56.320]  Значит, в чем тут проблема?
[35:56.320 --> 35:59.320]  Потому что казалось бы достаточно просто
[35:59.320 --> 36:02.320]  какие-то там выражения с матрицами делать
[36:02.320 --> 36:05.320]  и смотреть результат.
[36:05.320 --> 36:08.320]  На самом деле, сегодня так тривиально. Почему?
[36:08.320 --> 36:11.320]  Потому что, давайте назад откатимся.
[36:11.320 --> 36:14.320]  Тут я пишу, и это пара натуральных чисел,
[36:14.320 --> 36:17.320]  которые означают минимальное, максимальное количество ребра в обходе.
[36:17.320 --> 36:20.320]  В Cypher есть такие запросы такого вида,
[36:20.320 --> 36:23.320]  что ты можешь идти,
[36:23.320 --> 36:26.320]  условно, давайте запрос сформулирован,
[36:26.320 --> 36:29.320]  что я хочу дойти из вершины А
[36:29.320 --> 36:32.320]  до какой-то вершины Б
[36:32.320 --> 36:35.320]  по ребрам какого-то типа,
[36:35.320 --> 36:38.320]  и это ребро какого-то типа я могу брать сколько угодно раз.
[36:38.320 --> 36:41.320]  То есть, фактически правая граница, второе натуральное число
[36:41.320 --> 36:44.320]  является бесконечностью.
[36:44.320 --> 36:47.320]  Если работать, ну, просто пишете регулярное выражение,
[36:47.320 --> 36:50.320]  то это будет просто звезда к линии.
[36:50.320 --> 36:53.320]  Вот.
[36:53.320 --> 36:56.320]  Ну, а как подставлять,
[36:56.320 --> 36:59.320]  ну, то есть, если у вас есть регулярное выражение, которое нужно оценить
[36:59.320 --> 37:02.320]  вот матрицами, как туда подставлять
[37:02.320 --> 37:05.320]  матрицу смежности, считать не очень понятно.
[37:05.320 --> 37:08.320]  То есть, из-за вот этого бесконечности.
[37:08.320 --> 37:11.320]  Вот в частности, из-за этого, значит,
[37:11.320 --> 37:14.320]  нужно пользоваться инструментами релиционной алгебы,
[37:14.320 --> 37:17.320]  которыми я и пользуюсь.
[37:17.320 --> 37:20.320]  И, собственно, есть такая прекрасная библиотека.
[37:20.320 --> 37:23.320]  Вот, но она достаточно абстрактная, наверное, потому что
[37:23.320 --> 37:26.320]  как бы вы, ну, там
[37:26.320 --> 37:29.320]  из-за того, что у вас выражение,
[37:29.320 --> 37:32.320]  оно должно быть не вычислимым, а перечислимым,
[37:32.320 --> 37:35.320]  вот, то там, как бы, есть некоторые
[37:35.320 --> 37:38.320]  достаточно
[37:38.320 --> 37:41.320]  большой уровень абстракции. Условно,
[37:41.320 --> 37:44.320]  например, как бы
[37:44.320 --> 37:47.320]  матрица там представляется, как просто
[37:47.320 --> 37:50.320]  некоторое, типа,
[37:50.320 --> 37:53.320]  множество морфизмов над манойдом.
[37:53.320 --> 37:56.320]  Вот, значит,
[37:56.320 --> 37:59.320]  да.
[37:59.320 --> 38:02.320]  В частности, еще также, смотрите, почему
[38:02.320 --> 38:05.320]  библиотека достаточно абстрактная, потому что
[38:05.320 --> 38:08.320]  мне хочется работать как с матрицами,
[38:08.320 --> 38:11.320]  значит, над обычными буллским значениями,
[38:11.320 --> 38:14.320]  так и над матрицами с регулярными выражениями
[38:14.320 --> 38:17.320]  внутри и снаружи. Вот, поэтому
[38:17.320 --> 38:20.320]  это требует достаточно
[38:20.320 --> 38:23.320]  большой абстракции.
[38:23.320 --> 38:26.320]  Вот, значит,
[38:26.320 --> 38:29.320]  какие основные цели? Значит, первое, самое важное,
[38:29.320 --> 38:32.320]  это построение базовой модели графа и паттерна,
[38:32.320 --> 38:35.320]  под базовостью, а именно то, что она поддерживает
[38:35.320 --> 38:38.320]  какие-то очень простые запросы. Условно,
[38:38.320 --> 38:41.320]  у вас нет никакой свободы на то,
[38:41.320 --> 38:44.320]  сколько у вас ребер может идти, у вас может быть идти только одно ребро,
[38:44.320 --> 38:47.320]  у вас не может идти несколько ребер. Кроме того,
[38:47.320 --> 38:50.320]  значит,
[38:50.320 --> 38:53.320]  ну, такое, ну, основное ограничение.
[38:53.320 --> 38:56.320]  Значит, второе, то есть вы
[38:56.320 --> 38:59.320]  после того, как я, значит,
[38:59.320 --> 39:02.320]  вы построили все эти паттерны и модель графа
[39:02.320 --> 39:05.320]  в непосредственной оплоке, нужно использовать эту губитепу
[39:05.320 --> 39:08.320]  для того, чтобы можно было как-то валидировать
[39:08.320 --> 39:11.320]  запросы непосредственно.
[39:11.320 --> 39:14.320]  Собственно, первые два пункта мы уже сделали,
[39:14.320 --> 39:17.320]  и в оставшийся месяц я собираюсь
[39:17.320 --> 39:20.320]  сделать оставшиеся три. Значит,
[39:20.320 --> 39:23.320]  это будет очень здорово, если у меня удастся это сделать. Значит,
[39:23.320 --> 39:26.320]  какие это три? Первое, это улучшение модели паттернов,
[39:26.320 --> 39:29.320]  я делаю их более приближенным к тому,
[39:29.320 --> 39:32.320]  что находятся непосредственно в Cypher, за счет
[39:32.320 --> 39:35.320]  того, что я попытаюсь снять это ограничение
[39:35.320 --> 39:38.320]  на пути. Кроме этого,
[39:38.320 --> 39:41.320]  в Cypher есть различные вариации модель запросов,
[39:41.320 --> 39:44.320]  то есть, например, до этого есть,
[39:44.320 --> 39:47.320]  если моя модель до этого только обрабатывает, что давайте мы найдем путь
[39:47.320 --> 39:50.320]  и выведем последнюю лобу, что в ней там хранится,
[39:50.320 --> 39:53.320]  то в Cypher можно, например, искать путь и
[39:53.320 --> 39:56.320]  выводить то, что находится посередине.
[39:56.320 --> 39:59.320]  То есть, это более затруднительно,
[39:59.320 --> 40:02.320]  потому что вам нужно
[40:02.320 --> 40:05.320]  просто строить регулярное выражение,
[40:05.320 --> 40:08.320]  считаете, что-то находите, а тут нужно
[40:08.320 --> 40:11.320]  построить частично два регулярных выражения,
[40:11.320 --> 40:14.320]  типа до и после, посмотреть, что происходит в середине.
[40:14.320 --> 40:17.320]  Соответственно, и последнее,
[40:17.320 --> 40:20.320]  сам важное, это формализация доказательства
[40:20.320 --> 40:23.320]  корректности поиска пути. То есть, есть
[40:23.320 --> 40:26.320]  некоторые утверждения о том, что значит, что
[40:26.320 --> 40:29.320]  Cypher работает корректно,
[40:29.320 --> 40:32.320]  и нужно непосредственно доказать, что
[40:32.320 --> 40:35.320]  для этой операции
[40:35.320 --> 40:38.320]  выполняется какое-то свойство.
[40:38.320 --> 40:41.320]  Вот, собственно, для чего это все и делается. То есть, это неинтересно
[40:41.320 --> 40:44.320]  строить модель. Это уже все.
[40:44.320 --> 40:47.320]  Да. То есть, не очень интересно строить
[40:47.320 --> 40:50.320]  модель и определить на какие-то конкретных
[40:50.320 --> 40:53.320]  случаев, а хочется доказать общее утверждение
[40:53.320 --> 40:56.320]  для всех возможных графов и запросов.
[40:56.320 --> 40:59.320]  Ну, это у меня все. Так, спасибо.
[40:59.320 --> 41:02.320]  Если есть какие-то вопросы.
[41:02.320 --> 41:05.320]  Да, да.
[41:05.320 --> 41:08.320]  Ну, то есть, смотрите, что происходит.
[41:08.320 --> 41:11.320]  Вот у меня есть некоторая операция,
[41:11.320 --> 41:14.320]  условно запрос в графовом языке,
[41:14.320 --> 41:17.320]  и я описываю семантику, как это работает
[41:17.320 --> 41:20.320]  под капотом.
[41:20.320 --> 41:23.320]  Семантика языка – это не специальная
[41:23.320 --> 41:26.320]  семантика.
[41:26.320 --> 41:29.320]  Семантика языка – это не специальная
[41:29.320 --> 41:32.320]  семантика.
[41:32.320 --> 41:35.320]  Семантика – она есть имбиризация. Да.
[41:35.320 --> 41:38.320]  Да.
[41:38.320 --> 41:41.320]  Я это понял.
[41:41.320 --> 41:44.320]  А...
[41:44.320 --> 41:47.320]  Ну, если кто-то спросит о том, чтобы
[41:47.320 --> 41:50.320]  на экране наоборот обвенчали две медицины,
[41:50.320 --> 41:53.320]  то что бы он сказал?
[41:53.320 --> 41:56.320]  Ну...
[41:56.320 --> 41:59.320]  Просто у вас фактически не будет
[41:59.320 --> 42:02.320]  бесконечного ответа, почему? Потому что у вас база данных
[42:02.320 --> 42:05.320]  конечная. Вот.
[42:05.320 --> 42:08.320]  Вы не ограничиваете путь. То есть, вы говорите,
[42:08.320 --> 42:11.320]  что путь может быть сколько на большом. То есть, вы говорите, что путь 10.
[42:11.320 --> 42:14.320]  Можете там 100 взять, путь 150.
[42:14.320 --> 42:17.320]  Вот. Но фактически это будет конечный ответ, потому что у вас база данных
[42:17.320 --> 42:20.320]  конечная.
[42:20.320 --> 42:23.320]  Сейчас. Нет. Значит, что
[42:23.320 --> 42:26.320]  вы говорите?
[42:26.320 --> 42:29.320]  Ну...
[42:29.320 --> 42:32.320]  Ну...
[42:32.320 --> 42:35.320]  Ну...
[42:35.320 --> 42:38.320]  Ну...
[42:38.320 --> 42:41.320]  Ну...
[42:41.320 --> 42:44.320]  Ну...
[42:44.320 --> 42:47.320]  Ну...
[42:47.320 --> 42:50.320]  Ну...
[42:50.320 --> 42:53.320]  Ну...
[42:53.320 --> 42:56.320]  Ну.
[43:09.320 --> 43:12.320]  Ну...
[43:12.320 --> 43:15.320]  Ну...
[43:15.320 --> 43:44.560]  так то есть не знаю я что на данный момент
[43:44.560 --> 43:52.600]  на данный момент у меня построена база модель графа что имеет то есть есть граф и
[43:52.600 --> 44:01.280]  есть я поддерживаю паттерны типа ну то есть ригит паттерна в которых их паттерны они
[44:01.280 --> 44:06.100]  нет фиксировано типа ограничение 1 1 то есть я могу только по одному ребру походить между
[44:06.100 --> 44:14.340]  ребрами то есть я обязательно должен между ними тыкать ограничение по нормам и для значит для
[44:14.340 --> 44:22.060]  такой модели собственно я умею строить по паттерну непосредственно регулярное выражение и поэтому
[44:22.060 --> 44:29.860]  регулярным выражением я могу оценивать матрицу непосредственно какого-то конкретного графа и
[44:29.860 --> 44:40.980]  вводить результат то есть практически пятый пункт то есть пока не действительно ничего общего
[44:40.980 --> 44:45.860]  про эту модель не доказано но показано что это модель рабочая условно если поставить
[44:45.860 --> 44:52.140]  конкретное значение но сделать то что нужно перед тем моего доклада стояние триктория движения
[44:52.140 --> 44:58.140]  руки по низу основной целью исследования заключается обобщить метод канонического
[44:59.060 --> 45:06.420]  с помощью менты судех�с для решений задачи по решению задачи высекает две подзадачи это
[45:06.420 --> 45:14.280]  получение трикторного пространство по временному ряду и выбор метрики для медитации и предлагая
[45:14.280 --> 45:19.020]  предлагается решение предлагаемо решение заключается в построении матрицы двигов по временному
[45:19.020 --> 45:25.460]  ряду и обучение представления фазового пространства вообще глобально решаем датчик
[45:25.460 --> 45:30.040]  что прогнозирование многомерного временного ряда на основе
[45:30.040 --> 45:33.440]  другого и одной из трудностей, которая возникает в решении
[45:33.440 --> 45:37.640]  данной задачи, заключается в том, что размер сисотных
[45:37.640 --> 45:41.720]  временных рядов она миляка, и это приводит к неустойчивости
[45:41.720 --> 45:42.720]  паралитической модели.
[45:42.720 --> 45:46.720]  И одним из возможных решений данной сдачи заключается
[45:46.720 --> 45:52.520]  в применении методов конечного коллекционного анализа
[45:52.520 --> 45:57.200]  или методов, методчатечных на меньше квадратов, сокращённо
[45:57.200 --> 45:59.720]  они называются CCA и PLS.
[45:59.720 --> 46:03.160]  В чём где заключаются этих методов?
[46:03.160 --> 46:12.820]  У нас есть и сотные, и целевая нанимерные ряды, x, y, и мы
[46:12.820 --> 46:16.060]  проецируем эти ряды в некое латетное пространство
[46:16.060 --> 46:21.240]  меньшей размерности, причём полученные проекции должны
[46:21.240 --> 46:22.240]  быть согласованы.
[46:22.240 --> 46:27.140]  Под согласованностью подразумевается в случае PLS максимизация
[46:27.140 --> 46:29.880]  к вариации соответствующих столбцов матрицы ТИУ, а
[46:29.880 --> 46:34.800]  в случае CCA максимум корреляции.
[46:34.800 --> 46:37.200]  Другим методом, другим способом решения данной проблемы
[46:37.200 --> 46:43.360]  является метод сугехары, в чём основная идея его
[46:43.360 --> 46:48.400]  заключается в том, что мы для каждой компоненты
[46:48.400 --> 46:53.960]  целевого временного ряда y, zhi, t хотим выбрать некое
[46:53.960 --> 46:59.000]  фиксированное количество компонентов x, y, t, которые
[46:59.000 --> 47:02.480]  наиболее связаны с этим рядом.
[47:02.480 --> 47:06.720]  Тезисно в чём заключается данный метод, мы проецируем,
[47:06.720 --> 47:12.080]  мы составляем по одномерным временам x, y, zhi, t трикторные
[47:12.080 --> 47:18.960]  матрицы и полученные столбцы в этих трикторных матрицах
[47:18.960 --> 47:23.960]  образуют трикторное пространство hx, hx соответственно.
[47:23.960 --> 47:29.560]  И далее мы задаём между этими пространствами некое
[47:29.560 --> 47:35.680]  отображение phi и утверждается, что эти ряды связаны друг
[47:35.680 --> 47:45.240]  с другом, если phi от y0 с крышкой, оно близко в некотором
[47:45.240 --> 47:51.680]  смысле с y0, и в теоретической части будет показано, что
[47:51.680 --> 47:58.960]  метод сугехары является, что методы PLS ECC являются
[47:58.960 --> 48:03.440]  в частном случае методом сугехары, вот здесь приведён
[48:03.440 --> 48:06.240]  список литературы и далее более подробно про метод
[48:06.240 --> 48:10.680]  сугехары, трикторная матрица для одномерного временного
[48:10.680 --> 48:13.280]  ряда выглядит следующим образом, мы берём окно размера
[48:13.280 --> 48:19.400]  n и это у нас получается будет первый столбец нашей
[48:19.400 --> 48:24.280]  матрицы, потом сдвигаем окно на один шаг вправо
[48:24.280 --> 48:28.400]  или там на какой-то шаг tau, получаем второй столбец
[48:28.400 --> 48:29.400]  нашей матрицы и так далее.
[48:29.400 --> 48:36.800]  Теперь вот отображение phi, его определение приведено
[48:36.800 --> 48:41.440]  на слайде, только стоит сказать, что индексы t1 и так
[48:41.440 --> 48:50.640]  далее tk, это индексы ближайших соседей элемента x0 в пространстве
[48:50.640 --> 49:01.800]  hx, вот, и мы утверждаем, что временные ряды связаны
[49:01.800 --> 49:07.640]  если, то есть один из способов заключается в том, что отображение
[49:07.640 --> 49:11.480]  phi является Липшицевым, другим способом, который
[49:11.480 --> 49:13.560]  проведён был в оригинальной статье заключается в том,
[49:13.560 --> 49:17.880]  то что коэффициент корреляции, коэффициент корреляции
[49:17.880 --> 49:29.080]  пирсона между z0 с крышкой z0, он растёт с увеличением
[49:29.080 --> 49:35.240]  обучающей выборки и довольно высок, вот, и поэтому метрика
[49:35.240 --> 49:38.880]  связанности временных рядов, здесь рассматривается
[49:38.880 --> 49:44.880]  разность метода сугехара, применённого для всего
[49:44.880 --> 49:51.280]  ряда и для некоторой его части. Пару слов про представительную
[49:51.280 --> 49:56.040]  модель, которая применяется, это просто авторегрессионная
[49:56.040 --> 50:02.600]  модель порядка 0-1, вот, при этом вот эти вот элементы
[50:02.600 --> 50:08.720]  x с индексом t0 являются полимерным произведением
[50:08.720 --> 50:17.720]  элементов x и t, x и t мало и вес w и t, который пропорционален
[50:17.720 --> 50:28.360]  расстоянию от некой точки x до точки x с индексом t0.
[50:28.360 --> 50:31.160]  Далее был проведён вычлительный эксперимент, основной целью
[50:31.160 --> 50:35.320]  которого заключается сравнение различной стратегии снижения
[50:35.320 --> 50:40.920]  размерности целевого пространства. Более подробно про данные,
[50:40.920 --> 50:44.840]  которые использовались. Слева на слайде вы видите
[50:44.840 --> 50:48.680]  данные акселерометрии гироскопа, а справа данные
[50:48.680 --> 50:50.960]  видео кейпоинтов, значит, так они были получены.
[50:50.960 --> 50:56.440]  По видеодвижению руки человека с помощью фреймворка
[50:56.440 --> 51:01.400]  AlphaPose было получено скелетное пристреление человека,
[51:01.400 --> 51:10.280]  и на этом графике показано как изменение конкретного
[51:10.280 --> 51:15.440]  кейпоинта за течение времени. Получены результаты.
[51:15.440 --> 51:27.560]  В первой таблице вы видите строение ошибок, видно ошибка
[51:27.560 --> 51:32.840]  и её дисперсия паралитической модели, применённой в траекторном
[51:32.840 --> 51:36.960]  пространстве и в его подпространстве. Вот по вертикали,
[51:36.960 --> 51:44.160]  stop to space, subspace соответствует траекторную пространацию
[51:44.160 --> 51:48.200]  и подпространство, а по горизонтали это наши целевые
[51:48.200 --> 51:51.440]  переменные, это показания акселерометра по осям
[51:52.040 --> 51:58.440]  и показания гироскопа. И видно, что применение предсказательной
[51:58.440 --> 52:04.960]  модели в подпространстве увеличивает её точность.
[52:04.960 --> 52:11.960]  На другой таблице вы видите результаты применения
[52:11.960 --> 52:14.400]  предсказательной модели использованных различных
[52:14.400 --> 52:19.760]  методов снижения размерности, по горизонтали это метод
[52:19.760 --> 52:27.160]  гехар, плс, се, я говорил ранее, а наив это то, что
[52:27.160 --> 52:32.000]  мы получается не делаем никакой отбор признаков.
[52:32.000 --> 52:37.520]  Это то, что мы не применяем дополнительных данных,
[52:37.520 --> 52:43.520]  то есть мы, то есть во всех предыдущих методах мы использовали
[52:43.520 --> 52:46.000]  дополнительные данные, которые представляют
[52:46.000 --> 52:51.480]  по себе наборки поинтов, полученных по видео, а
[52:51.480 --> 52:54.560]  соответственно, стопцы наив, мы не использовали
[52:54.560 --> 53:03.360]  данные из видеоряда. Вот здесь видно, что использование
[53:03.360 --> 53:09.160]  данных из видеоряда, оно повышает качество предсказания.
[53:09.160 --> 53:16.560]  И что сделано на текущий момент, был проведен вычислительный
[53:16.560 --> 53:22.040]  эксперимент на данных устройств и видеоряда, и были подтверждены
[53:22.040 --> 53:26.200]  гипотезы о том, что использовать данных из видео повышает
[53:26.200 --> 53:29.920]  качество прогнозирования и что прогнозическая модель
[53:29.920 --> 53:32.560]  менее устойчива в случае, когда та применяется в
[53:33.560 --> 53:43.480]  На будущее планируется доделать теорическую часть и явным
[53:43.480 --> 53:48.320]  образом показать, как из метод SugeHarp вывести методы
[53:48.320 --> 53:52.040]  PLS и CCM. Спасибо, на этом все.
[53:52.040 --> 54:13.720]  Нет, мы предсказываем сейчас. Нет, у нас вот по руке, то есть
[54:13.720 --> 54:16.840]  есть набор никаких keypoint, то есть вот с помощью фреймворка
[54:16.840 --> 54:21.040]  мы получаем вот такой многомерный временной ряд, то есть у нас
[54:21.040 --> 54:25.200]  есть изменение конкретного keypoint с течением времени,
[54:25.200 --> 54:32.920]  но их там довольно много, то есть 150 где-то получается,
[54:32.920 --> 54:37.600]  то есть размерность вот то есть 150 keypoint это довольно много и
[54:37.600 --> 54:42.080]  то есть они получены по всему телу и понятное дело то, что
[54:42.080 --> 54:54.320]  ну то есть да, то есть данных keypoints понятно, что они все
[54:54.320 --> 54:58.600]  keypoints влияют на показания акселером три гироскопа,
[54:58.600 --> 55:05.000]  поэтому хочется снизить размерность данных полученных
[55:05.000 --> 55:12.720]  по видео ряду, и мы применяем эти данные в припрогнозировании
[55:12.720 --> 55:20.640]  показаний акселером три гироскопа. Они на руке закреплены,
[55:20.640 --> 55:33.440]  да. Нет, мы хотим вот именно показаний
[55:34.040 --> 55:46.160]  цельевых. Да, я думаю, я готов начинать. Приветствую всех, меня зовут Шишацкий
[55:46.160 --> 55:49.880]  Михаил и моя научная работа посвящена построению развертывания
[55:49.880 --> 55:54.000]  кластеров Kubernetes с применением стандарта азистоско. Сначала я расскажу, что такое
[55:54.000 --> 55:58.160]  кубернетис, причем здесь азистоско, затем подведу к постановке моей задачи,
[55:58.160 --> 56:03.040]  опишу решение, которое я хочу получить к танцу этого семейства.
[56:03.040 --> 56:08.640]  Итак, кубернетис. Кубернетис – это популярная распределенная платформа для
[56:08.640 --> 56:14.440]  кистрации контейнеров, которая является чуть ли не стандартом de facto и используется
[56:14.440 --> 56:18.120]  повсеместно, согласно последним вопросам. Таким образом, актуальность
[56:18.120 --> 56:22.720]  развертывания и поддержки таких кластеров возрастает. Кубернетис
[56:22.720 --> 56:26.480]  чрезвычайно гибок и может быть развернут во множестве различных окружений и
[56:26.800 --> 56:30.440]  различных конфигураций. В часть конфигурации вы можете видеть на слайде.
[56:30.440 --> 56:35.680]  Однако, существующие инструменты для предоставляющего возможность развертывания
[56:35.680 --> 56:41.760]  кубернетис либо предоставляют ограниченный набор конфигураций,
[56:41.760 --> 56:48.000]  давая готовое решение, либо слишком низкоуровневые и не позволяют сделать
[56:48.000 --> 56:52.280]  все автоматически и требуют какое-то количество специалистов, разбирающихся в
[56:52.280 --> 56:56.440]  области для настройки и поддержки таких кластеров. Одним из возможных
[56:56.440 --> 57:01.040]  решений уменьшения сложности может быть добавление еще одного слоя абстракции,
[57:01.040 --> 57:08.520]  которым может стать модель Азистоско. Что такое Азистоско? Это язык для
[57:08.520 --> 57:13.480]  моделирования облачных приложений и задача управления, связанных с этими
[57:13.480 --> 57:20.520]  приложениями. Как вы можете видеть из слайда, этот язык графовый и атомарные
[57:20.520 --> 57:25.600]  элементы топологии представляются в нем в виде вершин графа, которые имеют свои
[57:25.600 --> 57:33.000]  способности и требования. Ноды между собой связываются с помощью отношений.
[57:33.000 --> 57:38.480]  Язык тоско является наиболее популярным в последнее время языком для описания
[57:38.480 --> 57:49.440]  такого рода облачных топологий и почему нам выгодно его применять. Можете,
[57:49.440 --> 58:01.640]  пожалуйста, пролистать слайд на следующий, еще один. Там разные слайды, просто зуммей
[58:01.640 --> 58:07.640]  в моей презентации. В общем, основные плюсы использования Азистоско это один
[58:07.640 --> 58:12.400]  язык для описания как инфраструктуру, так и сервисов, которые работают в этой
[58:12.400 --> 58:18.280]  инфраструктуре. Это дает нам переносимости в встраиваемость, это
[58:18.640 --> 58:23.840]  позволяет не терять контроль над всеми параметрами конфигурации, составляющих
[58:23.840 --> 58:30.480]  Kubernetes и упрощает навигацию в таком большом количестве параметров с помощью
[58:30.480 --> 58:34.400]  графового представления. Также это позволяет верифицировать конфигурацию
[58:34.400 --> 58:39.120]  перед развертыванием, так как все параметры отображены, собственно, в графе и
[58:39.120 --> 58:45.160]  стандарт Азистоско позволяет накладывать ограничения на параметры. Это же
[58:45.160 --> 58:51.440]  позволяет нам обновлять отдельные Kubernetes, отдельные компоненты, инфраструктуры
[58:51.440 --> 58:56.680]  и автоматически масштабировать их. Также это не привязывает нас к
[58:56.680 --> 59:00.760]  конкретному инструменту, потому что Азистоско это только язык для описания,
[59:00.760 --> 59:07.760]  который может быть поддержан большим количеством оркестраторов. Таким образом
[59:07.760 --> 59:14.760]  это, можете вернуть на предыдущий слайд, это приводит меня к постановке задачи.
[59:14.760 --> 59:18.000]  Моей задачей является построение системы типов и топологии сервисов на
[59:18.000 --> 59:23.800]  языке Тоска для описания инфраструктуры Kubernetes и дальнейшей ее поддержки
[59:23.800 --> 59:28.400]  конфигурации. Новизна работы заключается в том, что существующая работа в данной
[59:28.400 --> 59:34.680]  области исследовали топологии сервисов, запускаемых в Kubernetes, но не уделяли
[59:34.680 --> 59:39.080]  внимания описанию самой инфраструктуры Kubernetes. В моем
[59:39.080 --> 59:44.600]  предположении такое описание в комбинации с существующими оркестраторами
[59:44.600 --> 59:51.600]  создаст расширяемый, ширококонфигурируемый инструмент для управления
[59:51.600 --> 59:55.280]  инфраструктуры Kubernetes.
[59:57.400 --> 01:00:05.040]  Деталями, теперь перейдем к деталям решения. Сам язык Тоска использует язык
[01:00:05.040 --> 01:00:12.240]  разметки Ямл. Все типы и топологии описываются на языке Ямл. Для дальнейшего
[01:00:12.240 --> 01:00:16.080]  развертывания этой топологии используются скрипты, написанные на
[01:00:16.080 --> 01:00:20.880]  ансибл. В своей работе я использую скрипты из инструмента
[01:00:20.880 --> 01:00:26.640]  CubeSpray, адаптируя их под модель Тоска, потому что в инструменте CubeSpray нет
[01:00:26.640 --> 01:00:31.800]  возможности атомарного развертывания отдельных компонентов
[01:00:31.800 --> 01:00:36.720]  топологии. В качестве оркестратора я использую Xopera, это легковесный
[01:00:36.720 --> 01:00:45.080]  Тоска-оркестратор, который написан на Python. В качестве результатов ожидается
[01:00:45.080 --> 01:00:49.840]  получение полной модели инфраструктуры Kubernetes, то есть нужно выделить
[01:00:49.840 --> 01:00:56.760]  отдельные типы и отношения между этими типами. Разработать ансибл роли для
[01:00:56.760 --> 01:01:03.640]  деплоя всей инфраструктуры. И к майской конференции я планирую получить тестовый
[01:01:03.640 --> 01:01:09.000]  стенд, который позволит продемонстрировать возможность деплоя Kubernetes и обновления
[01:01:09.000 --> 01:01:15.080]  отдельных его компонентов. На этом у меня все, здесь представлены источники,
[01:01:15.080 --> 01:01:22.440]  которыми я пользуюсь. Спасибо за внимание, готов идти на ваши вопросы.
[01:01:33.640 --> 01:01:46.840]  Я могу предоставить какой-то демонстрационный стенд, также планируется измерить время
[01:01:46.840 --> 01:01:51.960]  деплоя, когда у меня появится что-то, какой-то прототип, я измерю время деплоя, время
[01:01:51.960 --> 01:01:59.120]  обновления, какие-то другие операционные метрики, которые позволят оценить качество
[01:01:59.120 --> 01:02:09.640]  концепции, которые я предлагаю. В связи с программой, просто я на ноутбуке могу запустить что-то.
[01:02:09.640 --> 01:02:18.320]  Меня зовут Ковалев Константин, у меня тема работы, то есть аргументов теории EOPEN и отношения
[01:02:18.320 --> 01:02:25.040]  между ними. Это тема по математической логике. Будем работать в такой сигнатуре,
[01:02:26.000 --> 01:02:32.320]  у нас есть символ S для последователя, плюс умножить ноль и отношение неравенства.
[01:02:32.320 --> 01:02:39.160]  У нас будет такая базовая теория, все теории, которые мы будем рассматривать,
[01:02:39.160 --> 01:02:44.640]  будет ее расширять. Она называется такая теория Айхмедика Робинсона. Вот она состоит из следующих
[01:02:44.640 --> 01:02:48.800]  аксиомов. Тех, наверное, перечитывать не буду, все. Вот они здесь так на слайде есть.
[01:02:48.800 --> 01:02:59.400]  Вот такая наша основная теория. Это как раз будет это EOPEN. Это теория, состоящая из этих аксиомов Q,
[01:02:59.400 --> 01:03:03.640]  которые были на предыдущем слайде, и схема аксиома индукции для бискваторной формулы.
[01:03:03.640 --> 01:03:13.680]  То есть такая формула, что если у нас phi от нуля и для любого х из phi от х и до phi от следующего
[01:03:13.680 --> 01:03:21.600]  элемента, то тогда для любого х phi от х и с каким-то еще параметром. Вот чем хороша эта теория,
[01:03:21.600 --> 01:03:28.080]  тем что у нее есть рекуссивные нестандартные модели. В отличие от каких-то более сильных
[01:03:28.080 --> 01:03:36.200]  теорий, например, индукции по ограниченным формулам, неформально это означает, что мы можем
[01:03:36.200 --> 01:03:42.080]  следовать эту теорию и ее какие-то по теории теоретико-модельными методами. То есть как-то
[01:03:42.080 --> 01:03:47.280]  предъявляя какие-то контрмодели для того, чтобы окраирна доказуемость каких-то утверждений.
[01:03:47.280 --> 01:03:52.040]  Ну как, например, это сделал Шеферсен в своей статье и доказал, что нельзя в этой теории доказать
[01:03:52.040 --> 01:03:59.920]  рациональность корни из двух, ну и теремофирма, например. Ну вот известной логик Фарри Фридман
[01:03:59.920 --> 01:04:06.680]  заметил, что большая часть основных свойств, которые может доказать про модели этой теории,
[01:04:06.680 --> 01:04:12.760]  их можно доказать используя индукцию не по всем бисклаторным формулам, а только по атомарным
[01:04:12.760 --> 01:04:22.920]  и их отрицаниям. Ну это вот мотивирует нас на такое-то определение. Вот и от ELITE, ну ELITE это типа
[01:04:22.920 --> 01:04:29.400]  литералы. Это теория, состоящая из аксемку и индукции по атомарным формулам и их отрицаниям.
[01:04:29.400 --> 01:04:34.200]  Ну логично можно определить вот такие еще более слабые теории. Индукция по равенству,
[01:04:34.280 --> 01:04:42.960]  отрицание у равенства, порядку и отрицание порядка. Ну и вот у нас появились такие вопросы. Правда ли,
[01:04:42.960 --> 01:04:49.560]  что EOPEN сильнее, чем вот эта индукция по литералам? Если да, то какие можно предъявить доказания
[01:04:49.560 --> 01:04:58.480]  в EOPEN, которые нельзя доказать в ELITE? Можно ли ELITE как-то оконечно аксемитизировать на тпу?
[01:04:59.480 --> 01:05:04.560]  И какие у нас вообще есть отношения между вот этими слабыми теориями? Вот этими четырьмя в конце.
[01:05:04.560 --> 01:05:14.960]  Так, ну вот промежутки индукции у меня практически такие, что вот мы, у нас первый вопрос был,
[01:05:14.960 --> 01:05:21.840]  эквелинт на ли, да, мы получили, что у нас EOPEN эквелинт на ELITE. Вот схема доказательств
[01:05:21.840 --> 01:05:27.760]  примерно следующее. Ну, нам сначала мы хотим сформулировать анатирему, вот такую анатирему
[01:05:27.760 --> 01:05:36.200]  про EOPEN. Для этого нам вот еще понадобится пара определений. Вот, мы скажем, что у нас, если у нас
[01:05:36.200 --> 01:05:40.680]  есть какие-то два порядоченных кольца, m и r, которые оно уложено в другое, и причем m действительно
[01:05:40.680 --> 01:05:46.320]  упорядочено, ну то есть у нас енис это наименьший элемент в m, то тогда m называется целой частью r,
[01:05:46.320 --> 01:05:52.880]  если вот для любого элемента r, из нашего тогда большего кольца r, такой элемент m, вот только
[01:05:52.880 --> 01:05:57.360]  здесь печатка, здесь получается m меньше ебровной чем r, меньше чем m плюс 1. То есть получается для
[01:05:57.360 --> 01:06:02.200]  каждого элемента r существует такая типа целая часть для m. Ну можно заметить, что так как у нас
[01:06:02.200 --> 01:06:09.040]  кольцо дискретно упорядочено m, то такое m будет единственным. Еще одно определение, вещественное
[01:06:09.040 --> 01:06:13.240]  замкнутое поле. Вот если у нас есть какое-то упорядоченное поле, то мы будем называть его
[01:06:13.240 --> 01:06:18.000]  вещественным замкнутым, если в нем выполняется и ремо промежуточного значения для всех многочленов.
[01:06:18.000 --> 01:06:24.280]  Ну то есть если у нас у нас на щелен f и f от a больше 0, f от b меньше 0, то у нас существует корень между a и b.
[01:06:24.280 --> 01:06:33.400]  И если у нас есть какое-то упорядоченное поле, то можно доказать, что у него существует какое-то
[01:06:33.400 --> 01:06:38.760]  наименьшее его вещественное замкнутое расширение. И такое расширение мы будем называть вещественным
[01:06:38.760 --> 01:06:45.440]  замыканием. Ну и еще там можно доказать, что оно будет гибридическое. Так, вот и ремо,
[01:06:45.440 --> 01:06:50.440]  который доказал тоже ферцон. Вот заключается в следующем, что вот если у нас есть какое-то
[01:06:50.440 --> 01:06:56.640]  дискретно упорядоченное кольцо, мы обозначим через m плюс полукольцо его неотрасательных элементов,
[01:06:56.640 --> 01:07:03.040]  то тогда это m плюс будет являться моделью и open, тогда только тогда, когда у нас m является
[01:07:03.040 --> 01:07:09.400]  целой частью вот этого вещественного замыкания более частных этого кольца. И вот с помощью как
[01:07:09.400 --> 01:07:16.240]  раз-таки ремы мы сможем доказать этот эквивалент. Вот схема примерно такая. Сначала мы можем
[01:07:16.240 --> 01:07:20.480]  вот так вот руками доказать, что у нас выводятся все аксиомы дискретно упорядоченных полуколец
[01:07:20.480 --> 01:07:25.840]  нашей этой более слабой теории. Ну потом мы фиксируем какую-то модель нашей теории и
[01:07:25.840 --> 01:07:34.400]  вот эта лемма нам позволяет построить такое кольцо m, которое вкладывается, вот это кольцо наше
[01:07:34.400 --> 01:07:44.240]  полукольцо m0, так что у нас m0 равно полукольцу неотрасательных элементов m. Мы еще обозначим
[01:07:44.240 --> 01:07:49.000]  через r вещественного замыкания более частных m и тогда можно доказать такую лему, что у нас
[01:07:49.000 --> 01:07:59.400]  если есть какой-то мночлен f с коэффициентом из m, такой, что на каком-то n делит на q0 на
[01:07:59.400 --> 01:08:08.400]  каком-то m на q больше 0, где m и q из m0, то тогда у нас существует какой-то корень его вещественного
[01:08:08.400 --> 01:08:15.360]  замыкания такой, что у него есть целая часть в m. Он не обязательно будет лежать на вот этом интервале
[01:08:15.360 --> 01:08:22.280]  от n на q до m на q, но из этого можно будет выяснить, что именно все элементы r будут иметь
[01:08:22.280 --> 01:08:28.720]  целую часть в m. Ну отсюда, пользуясь теориям и шеферационами, можно доказать, что m0 будет моделью eopen.
[01:08:28.720 --> 01:08:38.600]  На второй вопрос ответ тоже отрицательный, то есть у нас elite не является конечной аксиматизированной,
[01:08:38.600 --> 01:08:46.040]  но идея доказательства закая, что вот мы можем посмотреть на ту модель, которую придумал шеферацион,
[01:08:46.040 --> 01:08:53.800]  для доказательства той теории, мы в самом начале, которая рекурсивная и не стандартная. И вот мы можем
[01:08:53.800 --> 01:09:00.520]  как-то вот аккуратно выкинуть из нее некоторые элементы так, чтобы она была моделью вот этой
[01:09:00.520 --> 01:09:07.400]  конечной аксиматизации, которую мы якобы предполагаем, но там существовали элементы, целые части не для всех
[01:09:07.400 --> 01:09:14.440]  элементов естественного замыкания, а только для элементов, которых небольшая степень над этим кольцом.
[01:09:14.440 --> 01:09:23.040]  Но на этот вопрос пока еще до конца не удалось ответить. Пока я доказал, что у нас из трех теорий
[01:09:23.040 --> 01:09:28.920]  не выводятся остальные, ну у меня предположение такое, что они все из друг друга не выводятся,
[01:09:28.920 --> 01:09:37.200]  то есть они все по парню как-то не вкладываются друг в друга. Дальнейшие планы какие у нас есть?
[01:09:37.200 --> 01:09:46.080]  Вот можем мы рассмотреть вот такой аналог вот этого первого опроса только уже для теорий, в которых у нас
[01:09:46.080 --> 01:09:52.320]  не зависит он порядок. То есть получается вот это и от равенства и отрицания равенства, это
[01:09:52.320 --> 01:10:00.440]  ну такой аналог ELITE без знака неравенства, и его панат равенства это индукция по всем
[01:10:00.440 --> 01:10:10.120]  дисконторным формулам, в которых все атомарные формулы имеют mit s равно t. Можно еще исследовать
[01:10:10.120 --> 01:10:14.840]  как-то более подробно вот эту теорию и от равенства, потому что она как-то выглядит более-менее естественно
[01:10:14.840 --> 01:10:20.360]  в отличие от остальных. Возможно у нее есть какая-то хорошая аксиматизация, возможно даже конечная,
[01:10:20.360 --> 01:10:27.280]  вот с этим я пока не развалился до конца. Ну еще интересный вопрос, который можно позадавать
[01:10:27.280 --> 01:10:34.120]  насчет этих теорий. Вот мы можем определить такое множество разрешимых диафантовых уравнений в моделях
[01:10:34.120 --> 01:10:41.440]  нашей теории какой-то t. Вот это получается формально такое множество, что это пара термов s и t, такие,
[01:10:41.440 --> 01:10:47.720]  что у нас существует модель нашей теории и такой формул, что существует такое решение уравнение
[01:10:47.720 --> 01:10:54.560]  s равно t. Ну вот есть такие частичные результаты, что если мы возьмем ту самую такую базовую
[01:10:54.560 --> 01:11:02.640]  нашу теорию, рифмитику Робинсона, то d от q будет разрешима. Это не данный результат. Еще можно заметить,
[01:11:02.640 --> 01:11:09.840]  что d от вот этой теории и от равенства тоже разрешима. Ну там, в принципе, все не сложно доказываться,
[01:11:09.840 --> 01:11:14.640]  там на самом деле, но хватает всего лишь одной простой модели, которая у нас содержат все решения,
[01:11:14.640 --> 01:11:23.800]  если не есть вообще. Но разрешимость d от eopen является до сих пор открытой проблемой. Там есть
[01:11:23.800 --> 01:11:28.880]  частичные результаты. Вот Билки доказал, что есть такой критерий, который формулирует,
[01:11:28.880 --> 01:11:33.360]  формулируется терминных идеалов, что вот если у нас есть какой-то хороший идеал,
[01:11:33.360 --> 01:11:40.840]  у нас такое уравнение разрешимо, когда у нас какой-то хороший идеал в кольце z от x,
[01:11:40.840 --> 01:11:50.640]  в котором лежит наше такое многочлено. Вандедопиз доказал, что если мы ограничимся не всеми термами,
[01:11:50.640 --> 01:11:58.200]  а термами только с не более чем двумя переменными, то это все-таки будет разрешимо. И ADER доказала,
[01:11:58.200 --> 01:12:05.720]  что у нас разрешимо такое множество, что если мы будем рассматривать не все такие термы,
[01:12:05.720 --> 01:12:14.520]  а только термы определенного вида. Меня зовут Клупа Дмитрий. Я в РАБКах инновационно-працикума
[01:12:14.520 --> 01:12:20.640]  занимался задачами экстремальной комбинаторики. Конкретно задача, которая решала это была,
[01:12:20.640 --> 01:12:28.880]  ну в частном случае, гипотеза Эрди-Шапова сочетания. Давайте посмотрим, что у нас есть. Пусть у нас есть
[01:12:28.880 --> 01:12:35.800]  натуральные числа mk, тогда можно рассмотреть какое-то семейство коэлементных подмножеств,
[01:12:35.800 --> 01:12:44.000]  н-элементного множества, ну скажем чисел от 1 до n. И давайте через ню от f обозначим максимальное
[01:12:44.000 --> 01:12:51.400]  количество попарно непересекающихся элементов этого семейства. Ну тогда же натуральных чисел
[01:12:51.400 --> 01:13:00.400]  sk и n больше, чем с плюс 1 на k, можно рассмотреть вот такие два семейства. Одно это все коэлементные
[01:13:00.400 --> 01:13:09.200]  подмножества, множество чисел от 1 до s плюс 1 на k минус 1. И другое это все множества коэлементные,
[01:13:09.200 --> 01:13:18.320]  которые пересекаются подмножество с множеством чисел от 1 до s. Ну для этих семейств не трудно
[01:13:18.320 --> 01:13:24.800]  понять, что у одного и другого максимальное количество попарно непересекающихся будет s.
[01:13:24.800 --> 01:13:34.160]  В чем состоит гипотеза Эрди-Шапова сочетания? Она состоит в том, что вот эти два семейства I-B,
[01:13:34.160 --> 01:13:41.080]  их мощность это максимально то, что может быть. То есть если у нас семействе f максимальное
[01:13:41.080 --> 01:13:45.840]  количество попарно непересекающихся не больше s, то тогда и мощность не больше, чем максимум из
[01:13:45.840 --> 01:13:55.760]  мощности a и мощности b. Вот, ну для s равно 1 на самом деле это превращается в известную теорему Эрди-Ши
[01:13:55.760 --> 01:14:03.200]  Курада. Ну если рассматривать при n больше, чем больше или равно 2 умножить на k, тогда там,
[01:14:03.200 --> 01:14:11.000]  как известно, ответ это число сочетания из n минус 1 по k минус 1. Ну и там на самом деле, например,
[01:14:11.000 --> 01:14:17.840]  там реализуется и обе конструкции, когда a максимальный, когда b. Ну когда b максимальный,
[01:14:17.840 --> 01:14:23.440]  это там получается пример, который называется звезда, это когда все множества содержат один
[01:14:23.440 --> 01:14:30.280]  общий элемент. А конструкция, когда максимальная мощность равна мощности a, она только при n равно
[01:14:30.280 --> 01:14:39.160]  2 умножить на k, это надо взять все коэлементные множества 2k минус 1 элементное множество. Дальше,
[01:14:39.160 --> 01:14:48.720]  при достаточно больших n, на самом деле при не очень больших n, уже выполнено то, что мощность
[01:14:48.720 --> 01:14:57.240]  a меньше, чем мощность b. И вот работа, ну случай, когда максимальная конструкция является, вот как
[01:14:57.240 --> 01:15:05.000]  раз множество b, они много где разбирались, вот в частности сам Эрди-Ши он доказал, что как раз
[01:15:05.000 --> 01:15:11.600]  реализуется максимальная оценка это мощность b при всех достаточно больших n, ну если зафиксировать
[01:15:11.600 --> 01:15:19.320]  k и s. Вот потом Франкл доказал, что это верно при n больше, ну что-то типа 2 умножить на k и s,
[01:15:19.320 --> 01:15:28.160]  кажется 2 на s плюс 1 на k. Вот потом Франкл и Купаски доказали, что там при всех достаточно
[01:15:28.160 --> 01:15:37.200]  больших s и при n больше, чем 5 с третьих s и k, минус что-то еще маленькое. Вот, ну я занимался,
[01:15:37.200 --> 01:15:46.560]  ну работал в случае, когда максимальным, ну когда правильной верхней оценкой является мощность a. Вот.
[01:15:46.560 --> 01:15:56.080]  В 2017 году Франкл доказал вот такую теорему, то что при n больше, главное с плюс 1 на k и при этом
[01:15:56.080 --> 01:16:02.800]  меньше, чем с плюс 1 умножить на k плюс что-то очень маленькое, как раз максимальным, максимальной
[01:16:02.800 --> 01:16:10.320]  мощностью является мощность a. Вот, там на самом деле может показать, что, ну там цель работы была в общем
[01:16:10.320 --> 01:16:15.720]  доказать, что какое-то вот число существует, то есть оно тут очень маленькое, получилось k в степени
[01:16:15.720 --> 01:16:23.440]  минус 2 k минус 1, но там просто задача была показать, что какое-то существует. На самом деле можно заметить,
[01:16:23.440 --> 01:16:31.000]  что при не очень больших s, ну при s меньше, чем k в степени, ну вот как раз то, что там написано,
[01:16:31.000 --> 01:16:36.960]  там у нас вот это неравенство, оно превращается в равенство n равно s плюс 1 на k, и для него все
[01:16:36.960 --> 01:16:43.920]  так уже давно было все доказано, это доказано Клейтманом, там можно это доказать, используя
[01:16:43.920 --> 01:16:52.520]  вероятностный метод, похожий на то, что в теории мерде Шикарады было. Вот. Я в рамках математического
[01:16:52.520 --> 01:17:00.640]  практику на втором курсе, который был, доказал вот такой результат, то есть что можно заменить вот
[01:17:00.640 --> 01:17:08.520]  это страшное число k в степени минус 2 k минус 1 на что-то побольше, там k в степени минус 2,
[01:17:08.520 --> 01:17:16.480]  но при этом там требовалось достаточно не очень хорошее ограничение на s, там s больше, чем k в
[01:17:16.480 --> 01:17:23.560]  степени 4 k. На самом деле от него было достаточно легко избавиться, там, ну это я в общем сделал,
[01:17:23.560 --> 01:17:29.880]  чтобы было проще доказывать. Вот уже в рамках математического практику, у меня получилось
[01:17:29.880 --> 01:17:35.320]  доказать вот это на данный момент, видимо больше ничего не получится доказать, потому что там
[01:17:35.320 --> 01:17:44.440]  уже сильно сложнее, то что при s тут уже достаточно разумное ограничение 100k в кубе, то есть это
[01:17:44.440 --> 01:17:50.840]  естественно намного лучше, чем k в степени k и что-то такое ужасное, и при n меньше чем s
[01:17:50.840 --> 01:17:58.840]  плюс 1 на k плюс 1 делить на 100k, вот выполнено то же самое. Вообще хочется глобально доказать,
[01:17:58.840 --> 01:18:05.080]  что 1 делить, ну вот это 1 делить на k можно заменить на константу, но вот это на самом деле
[01:18:05.080 --> 01:18:11.280]  кажется достаточно сложным, потому что уже видно, что при константе 1 вторая там мощность будет
[01:18:11.280 --> 01:18:18.920]  больше, чем мощность а, и там не работают те методы, которыми я доказывал вот это, я на самом деле
[01:18:18.920 --> 01:18:25.320]  доказывал это используя ту же технику, что была в статье Франкла, там достаточно хитрый двойной
[01:18:25.320 --> 01:18:30.640]  счет и плюс то, что можем считать, что f, ну так называемое сдвинутое множество, то есть
[01:18:30.640 --> 01:18:37.760]  негоязычный термин shifted там водится на элементы, ну на множество, на коэлементных множествах специальный
[01:18:37.760 --> 01:18:45.720]  shifted порядок, и мы считаем, ну семейство сдвинутое, это когда для любого множества все, которые меньше
[01:18:45.720 --> 01:18:53.280]  него в этом специальном порядке, они тоже будут лежать в семействе, вот и там используя ту же технику
[01:18:53.280 --> 01:18:59.120]  получить, доказать вот это, ну в общем, видимо, больше ничего не смогу доказать, так что на это все, наверное
[01:18:59.120 --> 01:19:13.880]  как минимум записать вот это, потому что пока она не записана, ну да, вот это я не так давно доказал, неделю
[01:19:13.880 --> 01:19:20.880]  две назад, то есть до этого была оценка вида, где 1 делить на k, на какую-то константу, она уже была достаточно
[01:19:20.880 --> 01:19:26.960]  давно у меня, но при этом там по-прежнему на s осталось вот это плохое ограничение, то что там, ну
[01:19:26.960 --> 01:19:35.080]  какая-то такая в степени k, и вот я занимался, ну и вот нормальным ограничением пытался сделать на s,
[01:19:35.080 --> 01:19:45.800]  чтобы оно было хотя бы полиномиальным, вот на данный момент такое есть, да,
[01:19:50.960 --> 01:19:51.960]  а
[01:19:57.960 --> 01:20:17.680]  сейчас нет, нет, звезда не про это говорил, я звезда говорил про, там звезда это я, когда упоминал теорию
[01:20:17.720 --> 01:20:23.600]  я уже говорил пример звезда, потому что там у нас s равно 1, то есть это означает, что у нас вообще нет по парам не пересекающихся
[01:20:23.600 --> 01:20:31.960]  элементов, то есть у нас любые 2 будут пересекаться, ну звезда она как раз вот в общем случае соответствует
[01:20:31.960 --> 01:20:33.680]  вот конструкции, которая семейство b.
[01:20:33.680 --> 01:20:54.160]  Добрый день, я занимался пересечением дисков в скоросочетаниях максимальной суммой, значит вначале я
[01:20:54.160 --> 01:21:03.040]  опишу формировку задачи, над которой я работал, про контекст, задача в котором она возникла,
[01:21:03.040 --> 01:21:11.040]  дальше опишу какие результаты удалось получить, и над какими дальнейшими задачами, близкими можно
[01:21:11.040 --> 01:21:20.240]  думать, значит формировка изначальной задачи, вот пусть у нас есть на множестве четное число точек,
[01:21:20.240 --> 01:21:31.720]  некоторые из которых возможно совпадают, и для этого паросочетания мы рассматриваем полное
[01:21:31.720 --> 01:21:43.160]  паросочетание, которое максимизирует сумму отрезков между точками паросочетания, и хочется
[01:21:43.160 --> 01:21:51.560]  доказать лично на плоскости точки о, такое что вот выполнено это равенство, другими словами,
[01:21:51.560 --> 01:22:01.160]  что она суммарно от двух концов любого отрезка паросочетания отстоит не больше, чем соответственно
[01:22:01.160 --> 01:22:07.640]  вот какая-то константа больше единицы на отрезок паросочетания, вот, ну кинем у нас первое
[01:22:07.640 --> 01:22:15.880]  наблюдение, вот это условие, оно у нас задает, вот если мы в нем поставим равенство, оно у нас
[01:22:15.880 --> 01:22:21.440]  будет задавать эллипс, соответственно если мы не стал границы ставим, то это получается внутренность
[01:22:21.440 --> 01:22:26.640]  эллипса замкнутая, и задача можно понимать так, что у нас есть четный число точек на плоскости,
[01:22:26.640 --> 01:22:33.200]  мы взяли максимальное паросочетание, нужно доказать, что все эллипсы вот с такой константой у нас имеют
[01:22:33.200 --> 01:22:43.080]  общую точку, собственно, да, и вот эта константа 2,9 на корень из трех, она берется у нас не случайно,
[01:22:43.080 --> 01:22:55.360]  это эллипс, в общем, если мы посмотрим равномерно этот угольник с углом 120 и с основанием отрезок
[01:22:55.360 --> 01:23:07.480]  паросочетания, то его вершина будет на нашем эллипсе, то есть вот у нас констант 2,9 на корень из трех,
[01:23:07.480 --> 01:23:13.200]  ее нельзя улучшить, потому что если мы, например, посмотрим на равномерный треугольник, то у него
[01:23:13.200 --> 01:23:20.000]  каждую вершину взяли дважды, то ясно, что максимальное паросочетание, это будет просто
[01:23:20.000 --> 01:23:29.120]  все стороны этого треугольника, они у нас будут идти через точку центр этого треугольника, да, и вот основное
[01:23:29.120 --> 01:23:37.720]  наблюдение, которое можно сделать, это то, что эллипсы у нас это выпуклые, ну, в смысле эллипс вместе с
[01:23:37.720 --> 01:23:45.040]  внутренностью, это выпуклое множество, поэтому нам нужно доказать, что n выпуклых множеств пересекаются для
[01:23:45.040 --> 01:23:56.080]  максимального паросочетания, вот, можно доказывать любые три из них, что они пересекаются, и поэтому можно
[01:23:56.080 --> 01:24:02.800]  эквалентную формировку задачи рассмотреть, что вот пусть у нас есть шесть точек, рассматриваемые шести точек
[01:24:02.800 --> 01:24:11.800]  максимального паросочетания, и тогда у нас эллипс будет иметь общую точку, вот, значит, ну, эта задача
[01:24:11.800 --> 01:24:23.000]  про эллипса, она возникла в контексте довольно шокового класса, задача про диски, вот, значит, пусть у нас есть
[01:24:23.000 --> 01:24:31.760]  две точки на плоскости, и через этот эксцепик мы обозначим круг, который построен на отрезке эксцепика, как на
[01:24:31.760 --> 01:24:43.160]  диаметре, вот, тогда граф Тверберга, назовем граф, так что если мы на каждом либре этого графа построили диск, как на
[01:24:43.160 --> 01:24:51.520]  диаметре, все эти диски будут иметь общую точку, то есть, ну, вот, про такие графы достаточно много изучено, есть
[01:24:51.520 --> 01:24:59.640]  множество результатов про там разные циклы, которые являются графами Тверберга, и вот, в частности, нас
[01:24:59.640 --> 01:25:09.160]  интересует, вот, в мои задачи нас интересует паросочетание, и вот, верен факт, что для любой конфигурации точек в РД есть
[01:25:09.160 --> 01:25:18.080]  паросочетание, которое является графом Тверберга, вот, интересно понять, является ли одним из таких паросочетаний, для
[01:25:18.080 --> 01:25:30.800]  которых пересекаются все круги, является ли одним из таких паросочетаний и паросочетаний, которые максимизируют сумму, то есть,
[01:25:30.800 --> 01:25:39.520]  та же самая фактически задача, что у меня, только мы на отрезках паросочетания строим не элипсы, а круги, вот, значит,
[01:25:39.520 --> 01:25:51.280]  какие результаты удалось получить. Задачу вот этого самого, которое про элипсы, удалось доказать, и вот, как бы, верно, что, ну, в общем, верен факт, что максимальное
[01:25:51.280 --> 01:26:04.000]  паросочетание, действительно, все элипсы имеют общую точку. Также, вот, статья в 2019 году был опубликован результат, что для
[01:26:04.000 --> 01:26:11.920]  максимального паросочетания круги пересекаются, и он был переборный, то есть, там, просто, как бы, перечисляли все разные конфигурации точек в апостоле,
[01:26:11.920 --> 01:26:22.800]  какие могут быть отрезки, все они рассматривались, и доказывалось, что вот, всегда у нас круги пересекаются, ну, вот, и удалось получить, доказать
[01:26:22.800 --> 01:26:34.280]  и доказывалось, что у нас есть устранение для кругов, которое значительно менее объемное, чем статья Берега. Ну, Берега, это автор для следующего
[01:26:34.280 --> 01:26:48.840]  года. И вот, следующие задачи, над которыми можно думать, это аналогичное утверждение в R3, то есть, тоже рассматривать такие паросочетания, и рассматривать элипсы,
[01:26:48.840 --> 01:26:58.440]  там уже другая константа будет, которая будет соответствовать правильному тетраидову, так, чтобы элипс, построенный на его стороне, проходил через центр правильного
[01:26:58.440 --> 01:27:15.080]  автотрайдера. Да, вот, и интересно еще подумать, что будет, если элипсы заменить на какие-то другие выпуклые центрально-осимметричные тела, и смотреть, что на отрезках максимально, что вот, какие
[01:27:15.080 --> 01:27:34.080]  свойства они должны обладать, чтобы на отрезках максимального паросочетания удалось, чтобы они тоже все имели общую точку. Вот, ну, спасибо за внимание, и вот, как бы, результаты, которые удалось получить, я ставлю в мае более конкретно.
[01:27:46.080 --> 01:28:03.080]  Ну, вот, сейчас, как раз, я думаю над утверждениями в R3, может быть, там удастся что-то получить, но там сильно сложнее, что-то.
[01:28:03.080 --> 01:28:05.080]  Вот так.
[01:28:12.080 --> 01:28:14.080]  Да.
[01:28:14.080 --> 01:28:29.080]  Почтение вида, что когда у нас осмотрится точка, то мы собираемся проделать это на, допустим, 9 нока, мы рассматриваем рупление на, не на пару, там, на камеры, пожалуйста.
[01:28:29.080 --> 01:28:43.080]  Ну, нет, не рассматривались. То есть, с парами тут понятно, какие-то вот, можно взять какой-то функционал сказать, давайте, вот, в основном, просвещение, какое-то экстремальное окружение, что-то такое.
[01:28:43.080 --> 01:29:08.080]  Ну, нет, не рассматривались. То есть, с парами тут понятно, какие-то вот, можно взять какой-то функционал сказать, давайте, вот, в основном, просвещение, какое-то экстремальное, которое там, в котором функционал достигает минимума или максимума, а для K, по множеству точек, там сложно что-то, как бы, подобное придумать.
[01:29:08.080 --> 01:29:38.080]  Смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набьем, смарт набь
[01:29:38.080 --> 01:29:51.080]  Ну, то есть, задача, она не меняет вид, кроме того, что плоскость заменяется просто на rd, и мы просматриваем множество точек в rd и какие-то просочетания между ними.
[01:29:53.080 --> 01:29:55.080]  Ну и меняется констант эллипс.
[01:29:55.080 --> 01:30:20.080]  Ну, как раз вот для сфер это тоже интересный результат, как я говорил, что для любой конфигурации точек есть пара сочетания, так что сферы все будут иметь общую точку, но известно, является ли максимальное просочение одним из них.
[01:30:20.080 --> 01:30:29.080]  То есть, для плоскости это уже понятно, это удалось получить, а для сферы, для r3 непонятно пока что.
[01:30:29.080 --> 01:30:43.080]  Добрый день, моя работа посвящена задачам геометрии чисел и их связи с системой общих представителей.
[01:30:43.080 --> 01:31:02.080]  Вот, соответственно, основным объектом, с которым мы будем работать, будет решетка. То есть, решеткой мы называем, следующий объект мы берем некоторое количество линейных независимых векторов и рассматриваем их линейные комбинации с целыми коэффициентами.
[01:31:02.080 --> 01:31:16.080]  Ну, и конкретно те решетки нас будут интересовать, которые содержат в качестве множества всех точек пространства с целыми координатами.
[01:31:16.080 --> 01:31:44.080]  И основная характеристика решетки, которая нас будет интересовать, это ее дефект. То есть, мы говорим, что у нас в любом базисе есть решетки, которых много может быть, есть как единичные векторы, то есть те, у которых одна из координат один, остальные нули, так и все остальные.
[01:31:44.080 --> 01:31:58.080]  Вот, и для каждой решетки мы смотрим минимальное возможное количество не единичных векторов в базисе. И, соответственно, это минимальное количество для решетки, это дефект.
[01:31:58.080 --> 01:32:11.080]  И наша задача стоит в том, чтобы оценивать для разных классов решеток, оценивать максимально возможный дефект.
[01:32:11.080 --> 01:32:30.080]  Для просто решеток эта задача не очень интересная, и мы будем рассматривать решетки, припустимые относительно некоторых тел.
[01:32:30.080 --> 01:32:37.080]  Мы будем говорить, что решетка допустима относительно тела, если тело из всех точек решетки попадает только ноль.
[01:32:37.080 --> 01:32:59.080]  И, в частности, удалось получить некоторую оценку для тел, которые обозначены S от PRN, то есть это сфера с центром в нуле, в n-мерном пространстве, в p-normе.
[01:32:59.080 --> 01:33:12.080]  Вот, и мы хотим посчитать максимальный дефект, n-мерные решетки, допустимые относительно этого.
[01:33:12.080 --> 01:33:29.080]  И удалось оценить некоторым образом верхнюю, получить верхнюю оценку, но уже был известен заранее аналогичный результат для Гиперкуба.
[01:33:29.080 --> 01:33:39.080]  А Гиперкуб – это шар в существенно по равной бесконечности.
[01:33:39.080 --> 01:34:02.080]  Вот, а удалось получить аналогии с известным уже рассуждением, удалось получить верхнюю оценку для максимального дефекта решетки, допустимая относительно шара в любой такой метрике.
[01:34:02.080 --> 01:34:23.080]  Но для Гиперкуба еще известна нижняя оценка, то есть построена конструкция с достаточно большим дефектом, для более общего случая не удалось получить нижние оценки.
[01:34:23.080 --> 01:34:36.080]  И поэтому было решено, сейчас мы занимаемся частным случаем, а именно мы рассматриваем единичный октайдер размерности n, он уже довольно во многом хорошо изучен.
[01:34:36.080 --> 01:34:45.080]  И в частности известна асимптическая точная оценка для некоторого класса решеток, а именно следующих.
[01:34:45.080 --> 01:35:09.080]  Если мы возьмем линейную оболочку всех единичных векторов и какого-то еще добавленного к ним вектора с рациональными координатами А, то тогда известна асимптически точная оценка на максимальный дефект решетки.
[01:35:09.080 --> 01:35:31.080]  Дефект решетки как раз и показывает связь со системами общих представителей, то есть оно основано на том, что чтобы посчитать дефект решетки можно посчитать размер минимальной системы общих представителей некоторых множеств.
[01:35:31.080 --> 01:35:52.080]  Каждая из множеств это множество некоторых координат вектора А, то есть мест таких, что знаменательные.
[01:35:52.080 --> 01:36:17.080]  У нас стоят какие-то дроби, точнее координат вектора А, и вот если знаменатели этих дробей не делятся на какое-то простое число, на которое делится хотя бы одна из всех знаменателей, то мы сводим их всех в множество, берем все такие множества,
[01:36:17.080 --> 01:36:23.080]  выбираем их минимальной системы общих представителей, и было известно, что она та и разная дефект решетки.
[01:36:23.080 --> 01:36:39.080]  И эта оценка она асимптически точная, потому что есть асимптически точная оценка на размер минимальной системы общих представителей семейства множеств с задними параметрами.
[01:36:39.080 --> 01:37:04.080]  И в обратную сторону тоже было известно рассуждение, которое строит систему с достаточно большим дефектом из известного примера системы с достаточно большим размером систем общих представителей.
[01:37:04.080 --> 01:37:13.080]  И вот верхняя оценка тоже уже известно, что ее можно обобщить.
[01:37:13.080 --> 01:37:23.080]  И, соответственно, факты тоже используют теорию систем общих представителей.
[01:37:23.080 --> 01:37:38.080]  Но хотелось бы... Нет, ну это же у нас зависит по сути от самой решетки.
[01:37:38.080 --> 01:37:57.080]  Да, вот. Ну, скажем так, Octoider выбран потому, что там есть... Ну, там есть решетки, там есть, собственно, у нас не только бактерии, но и в других местах.
[01:37:57.080 --> 01:38:11.080]  В других местах также нам хорошо помогает Лева Минковского, который позволяет, соответственно, связать объем тела и пределитель решетки.
[01:38:11.080 --> 01:38:20.080]  Вот. И, ну, Octoider хорошо считается.
[01:38:20.080 --> 01:38:30.080]  Так. Всем добрый день. Я занимаюсь Андреем Борисовичем Купавским одной задачей экстремальной комбинаторики, которая называется гипотез захвата.
[01:38:30.080 --> 01:38:38.080]  Ну, в общем-то, это главная тема моего исследования. Она выглядит, в общем случае, достаточно просто.
[01:38:38.080 --> 01:38:48.080]  То есть, вот, что я рассматриваю? Я рассматриваю, конечно, множество от 1 до N, и мы хотим что-то узнать о системах его подможеств.
[01:38:48.080 --> 01:38:59.080]  Мы называем семейство подможеств замкнутым вниз, если для любого множества этой системы все его поднося также лежат в этой системе.
[01:38:59.080 --> 01:39:08.080]  Ну, и формула Егоровка гипотеза состоит в том, что для его замкнутого низ такого семейства, наибольший пересекающийся подсемейство,
[01:39:08.080 --> 01:39:18.080]  Ну, пересекающийся подсемейство мы называем тема, где каждые два множества этого семейства имеют непустой пересечения.
[01:39:18.080 --> 01:39:30.080]  И утверждается, что наибольший пересекающийся подсемейство, оно имеет вид все множества данного семейства, содержащие какой-либо заданный элемент.
[01:39:30.080 --> 01:39:38.080]  Так, ну, в общем, как с этим работать? Что вообще известно про эту проблему?
[01:39:38.080 --> 01:39:43.080]  Тут очень помогает анализ булевых функций.
[01:39:43.080 --> 01:39:55.080]  Скажем так, что тут можно вести равномерную меру на булевом кубе.
[01:39:55.080 --> 01:40:02.080]  Ну, очевидно, что булев куб можно представить, можно отрешить с подношествами количества множества.
[01:40:02.080 --> 01:40:07.080]  Если мы введем там равномерную меру, то можно вести так называемую корреляцию семейств.
[01:40:07.080 --> 01:40:13.080]  Это просто мера пересечения этих семестов минус произведение мер.
[01:40:13.080 --> 01:40:18.080]  Мера самих семестов. Думаю, понятно, как не выводится.
[01:40:18.080 --> 01:40:24.080]  Так, ну, и что у нас еще тут есть? Мы можем вести так называемый инфлюенс катова элемента.
[01:40:24.080 --> 01:40:29.080]  Наверное, я зря это не прописал тут, но ладно, скажу на словах.
[01:40:29.080 --> 01:40:37.080]  Что инфлюенс катового элемента в одного семеста множества.
[01:40:37.080 --> 01:40:53.080]  Это удвоенная мера множества множества этого семеста таких, что если поменять в нем принадлежность или не принадлежность этого катового элемента, то оно уже лежать в семесте не будет.
[01:40:53.080 --> 01:41:00.080]  Он обозначается и КТ от того, как мы обозначаем связь, в данном случае обозначен АТА.
[01:41:00.080 --> 01:41:05.080]  И минимальный АТА это минимальный инфлюенс по всем К.
[01:41:05.080 --> 01:41:14.080]  Ну и оказывается, что гипотеза Кватова просто эквивалентна тому, что сейчас вот написано на слайде.
[01:41:14.080 --> 01:41:22.080]  То есть можно также заметить, что мы теперь замыкаем множество вверх, то есть с каждым множеством теперь содержится любое его надо множество в семесте.
[01:41:22.080 --> 01:41:50.080]  То есть если А и Б станут по версиям под множество от 1 до n, а Б еще и антиподальная система, то есть такая система под множество, что для любого под множество 2 в степени n в квадратных скобках, оно содержит либо это семейство, либо его дополнение, то оказывается вот таких вот А и Б, оно больше или равно 1 четверти минимального инфлюенса А.
[01:41:50.080 --> 01:41:56.080]  Это эквивалентная переформулировка гипотеза Кватова, там это, вообще говоря, достаточно сложно доказывается.
[01:41:56.080 --> 01:42:10.080]  Но это гипотеза, но существует теорема, что если мы возьмем какой-нибудь, если мы ведем, скажем так, случай...
[01:42:10.080 --> 01:42:39.080]  Вот у нас есть совокупность всех таких замкнутых версий систем под множество, и если мы будем брать случайные из них, то мотожидание вот этих вот выражений, которые написаны здесь, правда, тут, насколько я помню, еще нужно меру А сделать равной 1 и 2, то если мы возьмем мотожидание, то они будут относиться ровно так, как тут написано, то есть мотожидание корриации А, Б больше или равно 1 четверти мотожидание минимального инфлюенса А.
[01:42:40.080 --> 01:42:42.080]  Это уже доказанная теорема.
[01:42:44.080 --> 01:42:53.080]  Ну и, собственно говоря, еще немножко про то, как можно подступить к этой гипотезе, тут можно также рассмотреть анализ Афурия.
[01:42:53.080 --> 01:43:09.080]  Афурия. Оказывается, что пространство из функций из булева Куба в действительные числа, оно и в КЛИ2, там можно вести ассоциированный базис, и если мы будем раскладывать функции по этим коэффициентам Фурии, то там все внезапно окажется очень хорошо.
[01:43:09.080 --> 01:43:29.080]  То есть, например, если мы будем выражать инфлюенс ИТ-переменной этого элемента, то окажется, что он просто равен 4 суммам квадратам коэффициентов Фурии характеристической функции заданного семейства.
[01:43:29.080 --> 01:43:36.080]  Но не всего, а множество этого семейства таких, что в них лежит ИТ-элемент.
[01:43:36.080 --> 01:43:39.080]  Сложно выразить, тут, наверное, лучше проще написать.
[01:43:39.080 --> 01:43:43.080]  Ладно, если будут вопросы, то я в конце у них отвечу.
[01:43:43.080 --> 01:43:55.080]  А если у нас еще так окажется, что система множества, она еще и замкнута куда-либо, то есть вверх или вниз, то там вообще все прекрасно с выражением через коэффициент Фурии.
[01:43:55.080 --> 01:44:09.080]  Там никаких сумм квадратов нет, а там просто удвоенный коэффициент Фурии множества стоящего из одного элемента И.
[01:44:09.080 --> 01:44:19.080]  То есть, тут, по общей анализе Фурии, тут очень много теорем доказано, которые в будущем также могут помочь, но я их пущу пока.
[01:44:19.080 --> 01:44:30.080]  Ну, я пока расскажу свои планы на то, на будущее, которое я понял осуществить в этой задаче.
[01:44:30.080 --> 01:44:36.080]  Так что-то, учитывая мой метод дельта-систем, это уже отличный от анальзабуливых функций метод.
[01:44:36.080 --> 01:44:45.080]  Он немножко другой, и конкретно, как в дипутсе, я еще не рассматривал его применение, но он больше такой чисто комбинаторный и аналитический.
[01:44:45.080 --> 01:44:54.080]  Как в одном из прошлых глухов было сказано, это уже намного более приблизно к одной из предыдущих докладов.
[01:44:54.080 --> 01:44:58.080]  И также есть так называемый метод Р распространяющихся мер.
[01:44:58.080 --> 01:45:11.080]  Это тоже, про этот метод я пока что знаю совсем мало, но то, что я знаю, оно, опять же, отбыскивается к более комбинаторным рассуждениям.
[01:45:11.080 --> 01:45:26.080]  И сегодня я о том, что еще могу дать коэффициент Фурье. Вот как я уже до этого сказал, что коэффициент Фурье этих множеств, которые содержат какой-либо элемент, они дают просто инфлюенс этого элемента, а то еще и лучше.
[01:45:26.080 --> 01:45:37.080]  И также я еще забыл сказать, что коэффициент Фурье от пустого множества, он будет равен просто мере само этого множества. То есть, как закономерность в этом прослеживается.
[01:45:37.080 --> 01:45:45.080]  Если мы какие-нибудь более хорошие, ну или не очень хорошие множества рассмотрим, то там еще что-нибудь интересное, наверное, для нашей проблемы.
[01:45:45.080 --> 01:45:48.080]  Ну, на этом у меня все.
[01:45:48.080 --> 01:45:59.080]  Хорошо. Коротко к Максиму. Я буду, я занимаюсь защищением комагоровской сложности с ограничениями на ресурсы.
[01:45:59.080 --> 01:46:17.080]  Комагоровская сложность это объект, который довольно широко изучается. Идейный это длина наименьшей программы, которая печатает, ну комагоровская сложность данного слова, длина наименьшей программы, которая печатает это слово.
[01:46:17.080 --> 01:46:33.080]  Понятно, встает вопрос, какой язык программирования, но я говорю идейно. Комагоровская сложность не является вычислимой функцией, как известно.
[01:46:33.080 --> 01:46:44.080]  И это можно решить, накладывая какие-то ограничения на процессы вычисления. Можно наложить ограничения на память, можно наложить ограничения на время.
[01:46:44.080 --> 01:46:56.080]  Много также исследований, где накладывается ограничение на время и машина, на которой мы работаем, является детерминированной или не детерминированной.
[01:46:56.080 --> 01:47:04.080]  Я собираюсь исследовать случаи, когда машина альтернирующая, у нас есть ограничение на количество смен состояний.
[01:47:04.080 --> 01:47:26.080]  У нас есть некоторые универсальные альтернирующие машины тюнинга с доступом к аракулам. Мы сразу будем рассматривать проблемы с аракулами, потому что многие утверждения связаны с комагоровской сложностью без аракула.
[01:47:26.080 --> 01:47:40.080]  Для них можно показать эквалентность проблем вида P равно NP, которые решать сложно, поэтому мы сразу будем работать с добавлением аракула.
[01:47:40.080 --> 01:48:03.080]  Мы можем определить сложность вычисления, сложность, которую я обозначил как C sigma N D для машины U со временем T и аракулом A.
[01:48:03.080 --> 01:48:21.080]  Это длина наименьшей такой программы, что U с аракулом A на программе P на воде Y дает единицу, когда X равно Y, то есть наша программа распознает слово X.
[01:48:21.080 --> 01:48:48.080]  Есть ограничение T на время работы программы. Главное ограничение, которое я добавляю в сравнение со состоянием результатов, это я ограничиваю число переходов в состояние существует для любого.
[01:48:48.080 --> 01:49:08.080]  Первое определение должно происходить в существует состоянии. В аналогичном мы можем определить сложность TPN, где первое определение будет происходить не в существует состоянии, а в состоянии для любого.
[01:49:08.080 --> 01:49:30.080]  Для сложностей в работе на не детерминированных и детерминированных машинах уже есть какие-то результаты, я сейчас их расскажу и расскажу как планирую улучшить.
[01:49:30.080 --> 01:49:42.080]  Если у нас машины детерминированные, то сложность можно ограничить следующим образом.
[01:49:42.080 --> 01:50:09.080]  Для всех слов X длины N из языка A можно ограничить через удвоенный логарифм часа элементов длины N в множестве A плюс от логарифма.
[01:50:09.080 --> 01:50:34.080]  Это делается при помощи хэширования слов из A и никак нельзя улучшить этот метод для перехода к детерминированным машинам, чтобы понизить константу.
[01:50:34.080 --> 01:50:44.080]  При этом если добавить время, то можно получить, что на втором уровне для A2 и P2 константу можно улучшить и оценивать сверх логарифм.
[01:50:44.080 --> 01:50:53.080]  Почему такая идея возникает? Потому что удвоенный логарифм дает оценку 2N при языке A большой плотности.
[01:50:53.080 --> 01:51:06.080]  А есть оценки величиной N, поэтому есть идея, что эту двойку можно убрать в некоторых случаях.
[01:51:06.080 --> 01:51:23.080]  Эта идея оказывается неверна для работы с детерминированными машинами. Есть аремы, которые утверждают, что для некоторого примера есть похожая оценка снизу через удвоенный логарифм.
[01:51:23.080 --> 01:51:31.080]  Вот как я сказал, если пленом заменить на что-то большее, а именно на экспонент, то уже на втором уровне эту двойку можно убрать.
[01:51:31.080 --> 01:51:38.080]  По-видимому для детерминированного случая это не получается, но это тоже нужно проверить.
[01:51:38.080 --> 01:51:56.080]  Есть оценки снизу. Хочется оценивать сложность при доступе к ракулу A для всех слов из этого языка.
[01:51:56.080 --> 01:52:23.080]  Например, почему именно так? Это дает некоторые оценки на плотность, некоторые соотношения между классами P и NP, например, которые заключаются в существовании языков какой-то плотности,
[01:52:23.080 --> 01:52:31.080]  как под языка из одного, который не являющимся языком из другого.
[01:52:31.080 --> 01:52:43.080]  В общем, это обобщается на какие-то другие задачи, поэтому это интересно.
[01:52:43.080 --> 01:52:57.080]  Есть следующие результаты. Теорема для детерминированного случая и ее улучшенная и распространенная версия для случая sigma1.
[01:52:57.080 --> 01:53:20.080]  Хочется как-то расширить это для произвольного, но оказывается, что это невозможно, что уже для P1 есть верхняя оценка в виде логарифма для некоторой последовательности слов из языка.
[01:53:20.080 --> 01:53:32.080]  Напомню, здесь было линейное, это с точностью до константа, близко к максимуму, а тут мы получаем логарифмический для некоторого под языка.
[01:53:32.080 --> 01:53:46.080]  Ну и как следствие, можно получить, что то же самое верно и для всех Pn, для n больше равно 1, и для всех sigma n, для n больше равно 2.
[01:53:46.080 --> 01:53:58.080]  То есть гипотеза, что подобные линейные оценки можно получить и для других альтернирующих машин, оказывается неверной.
[01:53:58.080 --> 01:54:04.080]  В связи с этим ломается и другая гипотеза, которая изначально ставилась.
[01:54:04.080 --> 01:54:30.080]  Хочется как-то отличить сложности при заменах альтернирующих машин. Изначально выдвигается гипотеза, что при увеличении числа допустимых переходов в состоянии мы можем как-то улучшить сложность.
[01:54:31.080 --> 01:54:37.080]  Конкретно это сформулировано в виде гипотезы, которые я записал.
[01:54:41.080 --> 01:54:48.080]  Хотелось бы утверждать, что для всех n и любого polynomial P существует язык A, такой же для всех слов из него.
[01:54:48.080 --> 01:55:00.080]  При вычислениях с ним как с A, сложность с увеличенным количеством шагов есть у маленького, сложность с прошлого числа шагов переходов в состоянии.
[01:55:01.080 --> 01:55:07.080]  Но ввиду прошлого утверждения она уже неверна для n больше единички.
[01:55:07.080 --> 01:55:17.080]  Но планируется ее скорректировать и проверить при корректировке одним из следующих двух способов.
[01:55:17.080 --> 01:55:37.080]  Либо можно в условии звездочка требовать только для хотя бы какой-то доли слов из языка A, либо же можно требовать его на некотором языке B, который может не зависеть.
[01:55:37.080 --> 01:55:49.080]  Возможно второе более естественно, но кажется, что оно приводит к из него уволиться меньше внешних результатов.
[01:55:50.080 --> 01:56:02.080]  Оно слабее и выглядит подобным, поэтому возможно, что там можно получить результат.
[01:56:02.080 --> 01:56:19.080]  Из других результатов есть некоторые минорные утверждения про всякие технические переносы, утверждения, которые мы знаем для полиномиальной иерархии.
[01:56:19.080 --> 01:56:34.080]  Все такие утверждения, например, об эквалентности определений можно переформулировать и перенести на сложности, которые я сформулировал.
[01:56:35.080 --> 01:56:47.080]  Возможно эти технические результаты помогут в дальнейшем, но я не стал их выписывать, потому что они довольно минорные.
[01:56:47.080 --> 01:57:02.080]  Дальнейшие планы описаны здесь, и в оценках сверху планируется как-то понизить константу или показать, что сделать этого невозможно.
[01:57:02.080 --> 01:57:06.080]  На этом все.
[01:57:06.080 --> 01:57:34.080]  Дальше все время будет логарифмическое.
[01:57:36.080 --> 01:57:42.080]  То есть это в первый раз падает, а потом будет логарифмическое.
[01:57:42.080 --> 01:57:46.080]  Да, это верхнее.
[01:57:46.080 --> 01:57:54.080]  Там можно показать, что это утверждение ломается для эмблочений.
[01:57:54.080 --> 01:58:08.080]  Там несложно получается, но логарифм не обязательно точный, но маленького уже не достичь.
[01:58:08.080 --> 01:58:14.080]  Еще такой удар.
[01:58:14.080 --> 01:58:21.080]  Ну, в общем, ассоциатива речи такая, по-настоящему, раз мы рассматриваем поведомство.
[01:58:21.080 --> 01:58:28.080]  Я объяснял, что это приводит также к некоторым внешним следствиям.
[01:58:28.080 --> 01:58:45.080]  Например, есть теорема, что существует язык ИСП, у которого нет под языков какой-то небольшой плотности.
[01:58:45.080 --> 01:58:52.080]  То есть мы можем задать такое ограничение на плотность, выбрать язык ИСП, некоторые ораков.
[01:58:52.080 --> 01:59:04.080]  Из двух авторов этой теоремы, например, она следует из второй теоремы на этом слайде.
[01:59:04.080 --> 01:59:29.080]  В этих теоремах интересно изучать какое-то подмножество А.
[01:59:29.080 --> 01:59:38.080]  В этих теоремах А потому что получается не только для подмножества, а для всего А.
[01:59:38.080 --> 01:59:44.080]  Почему интересно изучать подмножество? Потому что это дает результаты по типу того, который я говорил.
[01:59:44.080 --> 01:59:57.080]  Можно разделять классы языков таким способом, что не разделять, а исследовать взаимоотношения.
[01:59:57.080 --> 02:00:15.080]  Мы можем как следствие из второй теоремы показать, что существует при вычислениях с некоторым оракулом язык ИСП такой, что у него уже нет никакого подмножества,
[02:00:15.080 --> 02:00:28.080]  которое является языком ИСП и при этом не очень большой плотности, то есть не непримерно разреженный, но там и лучшую оценку можно дать.
[02:00:28.080 --> 02:00:43.080]  Да, все здравствуйте, меня зовут Бучаев Абдукадыр. Моя тема это агентивная комбинаторика, а именно я буду изучать некоторые характеристики конечных множеств, нормы.
[02:00:43.080 --> 02:00:53.080]  Давайте начнем с видения. В общем, агентивная комбинаторика у нас абелевая группа какая-то есть объемлющая.
[02:00:53.080 --> 02:01:01.080]  Классическая комбинаторика изучает некоторые вопросы про мощности множества, про какие-то может экстремальные.
[02:01:01.080 --> 02:01:09.080]  Агентивная комбинаторика изучает вопросы такого же рода, но в формулировке должна присутствовать групповая операция плюс.
[02:01:09.080 --> 02:01:19.080]  Основные понятия это сумма и разность множеств, то есть это еще называется сумма Минковского, как все знают, но мы будем говорить про сумму и разность.
[02:01:19.080 --> 02:01:26.080]  И вот изучается страшная разность, можно, то есть вот, допустим, два минус два взять.
[02:01:26.080 --> 02:01:40.080]  Да, ну вот, то есть да, и вот мы сразу понимаем, что у нас появляются сразу в зависимости от того, как устроена наша групповая операция, разные множества.
[02:01:40.080 --> 02:01:52.080]  То есть вот, например, возьмем альфантическую прогрессию, то есть позже мы живем в ЗТН и возьмем, допустим, там числа от одного до П, вычеты.
[02:01:52.080 --> 02:02:07.080]  Вот, ну мы сразу понимаем, что между ними много всяких соотношений, но при этом если мы возьмем, не знаю, какую-нибудь геометрическую прогрессию, например, там в степени десятки в целых числах, мы понимаем, что между ними таких вот аддитивных соотношений вообще почти нет.
[02:02:07.080 --> 02:02:23.080]  Вот. Далее. Мы хотим как-то характеризовать, вот, что означает, что множество аддитивно-богато, то оно не богато, это уводим вот определение энергии.
[02:02:23.080 --> 02:02:33.080]  Вот аддитивная энергия наводится для двух множеств и определяется просто как количество вот решений такого-то равнения, что a1 плюс b1 равно a2 плюс b2.
[02:02:33.080 --> 02:02:45.080]  Вот. Ну и в частности изучаются, когда b равно a, пишут просто и это, изучается вот, значит, такая постановка, то есть сколько вот внутри a есть отношений таких аддитивных.
[02:02:45.080 --> 02:02:55.080]  Вот. Ну, аддитивная энергия она довольно хорошо изучена, но при этом есть еще старшая энергия, когда мы, значит, к тому же самому дописываем еще несколько равнений.
[02:02:55.080 --> 02:03:05.080]  Да, старшие энергии, они уже определяются для одного a, ну потому что для b, в общем, там есть некоторые сложности в определении.
[02:03:05.080 --> 02:03:15.080]  Вот. И на самом деле можно понять, что, ну это естественно обобщение, потому что вот вообще как считать аддитивную энергию?
[02:03:15.080 --> 02:03:27.080]  Вот для множества, то есть у нас там a1 плюс a2 равно a3 плюс a4, это то же самое, что если мы перекинем a3 влево и a2 вправо, a1 минус a3 равно a4 минус a2.
[02:03:27.080 --> 02:03:34.080]  Это все равно какого-то s. То есть количество решений уравнения, это что такое?
[02:03:34.080 --> 02:03:44.080]  Это мы берем, смотрим, сколько, сколькими способами число s можно представить в виде разности элементов из a и возводим это в квадрат.
[02:03:44.080 --> 02:03:50.080]  Когда мы смотрим на e-каты, мы понимаем, что это то же самое, только мы возводим эту увеличенную не в квадрат, а в катую степени.
[02:03:50.080 --> 02:04:03.080]  То есть таким образом это в некотором смысле более старший момент, то есть вот мы же знаем, да вот, из теории вероятности, например, что старший момент звучать полезно, да, то есть вот, что не только там от ожидания квадрата, но еще и кубы, и табяли.
[02:04:03.080 --> 02:04:10.080]  Вот так вот. Теперь дальше, вот это одна из характеристик, энергия, точнее класса характеристик.
[02:04:11.080 --> 02:04:27.080]  Следующая это норма Гаурса, катаформула, конечно, да, изначально вообще непонятно, что означает, вот, но давайте вот посмотрим, что, что это такое для, значит, ну для k равно там 2 или 3.
[02:04:27.080 --> 02:04:35.080]  Пускай, допустим, k равно 2, да, то есть вот у нас, вот смотри, у нас есть произведение по epsilon из 0.1 в квадрате.
[02:04:36.080 --> 02:04:48.080]  Да, еще оператор комплекса на сопряжение, но вот внизу написано, что мы нормой Гаурса, не функция, а конечного множества, называем нормой Гаурса у характеристической функции.
[02:04:48.080 --> 02:04:56.080]  Характеристическая функция она принимает значение только 0 и 1, вещественное число, поэтому сопряжение можно про него забыть в нашем случае.
[02:04:56.080 --> 02:05:11.080]  Вот, то есть там написано, что a от x, a от x плюс s1, a от x плюс s2 и a от x плюс s1 плюс s2, то есть мы, по сути, берем такой вот аддитивный квадрат, x, x плюс s1, x плюс s2, x плюс s1 плюс s2, вот.
[02:05:11.080 --> 02:05:22.080]  Соответственно, да, и вот суммируем по всем x-алам, по всем s, то есть по сути, вот эта норма Гаурса, она показывает, сколько у нас множества таких квадратов.
[02:05:22.080 --> 02:05:29.080]  Когда мы берем k равно 3, то вместо квадратов у нас кубы, ну и так далее, в общем, да.
[02:05:29.080 --> 02:05:38.080]  Что интересного можно сказать про эту величину, на самом деле, когда k равно 2, то у нас совпадает с аддитивной энергией,
[02:05:38.080 --> 02:05:43.080]  а когда k равно 1, то она совпадает с квадратом мощностью множества.
[02:05:43.080 --> 02:05:56.080]  Вот, при этом, значит, энергии, то есть e1 это тоже считается, что первая энергия это просто квадрат множества, а вторая энергия это аддитивная энергия, то есть они вот на первых двух совпадают.
[02:05:56.080 --> 02:06:02.080]  Вот, теперь в чем же, значит, была задача?
[02:06:02.080 --> 02:06:07.080]  Мы изучаем множество а-а. Почему его логично изучать?
[02:06:07.080 --> 02:06:13.080]  Потому что если а само по себе был аддитивно-богатым, то есть внутри него было много соотношений, там, например, а был прогрессией,
[02:06:13.080 --> 02:06:21.080]  то а-а будет тоже аддитивно-богатым, потому что если из прогрессии вычесть само себя, то получится тоже вот прогрессия.
[02:06:21.080 --> 02:06:32.080]  При этом если а не аддитивно-богатая, то когда мы рассматриваем а-а, то мы как бы насильно добавляем много соотношений.
[02:06:32.080 --> 02:06:40.080]  Это означает, что множество а-а, по идее, должно быть в любом случае аддитивно-богатым в некоторой степени.
[02:06:40.080 --> 02:06:54.080]  Ну и, значит, в одной статье Шкредов мой научный руководитель доказал, что третья энергия d в некоторых приположениях, то что аддитивная энергия а меньше, чем а в кубе на к,
[02:06:54.080 --> 02:07:04.080]  с некоторой консантой, то что тогда третья энергия множества d будет, снизу у него оценка, это к в степени 7 четвертых на а в четвертый.
[02:07:04.080 --> 02:07:12.080]  Вот. И, значит, моя задача была основной доказать что-нибудь подобное не для третьей энергии d, а для ката энергии d.
[02:07:12.080 --> 02:07:17.080]  Вот. Да, кстати, немножко про энергии, давайте я вернусь назад.
[02:07:17.080 --> 02:07:28.080]  Вот. Из определения ката энергии видно, что на нее оценка сверху, тривиальная, это а в к плюс первой степени, потому что в этом а1, а2 и ак, вот все эти,
[02:07:28.080 --> 02:07:33.080]  зафиксируем какими угодно, тем самым уже а в ката вариантов получили.
[02:07:33.080 --> 02:07:41.080]  Далее а1 штрих положим еще чему-нибудь, и тогда у нас все остальные а2 штрих, и так далее, ак и штрих тоже зафиксируются.
[02:07:41.080 --> 02:07:52.080]  Вот. То есть оценка сверху это а в к плюс первой, а оценка снизу это просто а в катой, потому что можно а1 положить равным а1 штрих, 0 получится.
[02:07:52.080 --> 02:07:57.080]  И так здесь во всех уравнениях. То есть у нас я ката, они живут от а в катой до а в ка плюс первой.
[02:07:57.080 --> 02:08:11.080]  Вот. Да, и соответственно получается, что третья энергия от d, у нее оценка сверху, это d в четвертый, и в аддитивно-богатом случае это то же самое, что а в четвертый, то есть то, что это константа.
[02:08:11.080 --> 02:08:17.080]  А мы, получается, доказали, что, точнее, было доказано, что это оценка снизу тоже, то есть а в четвертую какую-то константу.
[02:08:17.080 --> 02:08:29.080]  Вот. Это была первая цель. Да, вот. Да, после этого, что еще нужно сделать? То есть оценка есть, нужно проверить, насколько она точна.
[02:08:29.080 --> 02:08:41.080]  После этого можно, да, после этого нужно рассмотреть, естественно, обобщение энергии, это норма Галлса третья, и доказать тоже что-нибудь похожее.
[02:08:41.080 --> 02:08:47.080]  А дальше проверить точность на разных классах множеств. Да, вот класс у нас в аддитивной календарике их несколько.
[02:08:47.080 --> 02:08:53.080]  Основные это прогрессии, как аддитивно-богатые, потом аддитивно-небогатые, это случайное множество.
[02:08:53.080 --> 02:09:03.080]  Между ними бывает малость на отношении. И наконец, ну еще есть такой промежуточный вариант, это подпространство плюс дезинсертивное множество,
[02:09:03.080 --> 02:09:08.080]  но можно понимать его просто как случайно множество. То есть пространство какое-то, подпространство, плюс случайный шум.
[02:09:08.080 --> 02:09:19.080]  Вот. Да. В общем, какие у меня результаты? Оценка есть на карту энергии от D. Она вот такая чуть страшной получилась.
[02:09:19.080 --> 02:09:29.080]  Вот. Да. А малая это мощность, а просто. Так же в ней возникнула бит энергии, которую вот я обозначу как E к и к-1.
[02:09:30.080 --> 02:09:38.080]  На самом деле можно еще там сверху оценить и получить оценку только на энергию от D. Вот.
[02:09:38.080 --> 02:09:42.080]  Но я пока не стал этого делать, потому что то есть это новый вид энергии.
[02:09:42.080 --> 02:09:47.080]  Вот тоже можно интересно изучить без того, чтобы терять точность. Возможно лучше пока оставить как есть и потом посмотреть.
[02:09:47.080 --> 02:09:56.080]  То есть вот. Да. Дальше что еще по продвижениям? У меня уже есть оценка для третьей нормы Гаурса.
[02:09:56.080 --> 02:10:01.080]  Но пока я не стал ее писать, потому что я не уверен, что она закончена.
[02:10:01.080 --> 02:10:09.080]  В каком плане? То есть я еще планирую проверить точностью. Вот. Если точность совпадет, то оставим как есть.
[02:10:09.080 --> 02:10:14.080]  Если нет, то придется немножко доработать. То есть она скорее всего в адестивно-богатом случае точно совпадает.
[02:10:14.080 --> 02:10:22.080]  То есть, ну, точна. Вот. Но в случайном случае, когда у нас случайно множество, я пока там не уверен.
[02:10:22.080 --> 02:10:31.080]  Вот. Даут. Дальнейшие цели. То есть доработать эту оценку, проверив ее точность и подкорректировав, если нужно.
[02:10:31.080 --> 02:10:37.080]  Даут. Кстати, если точка сходится, то задача может стать решенной. То есть мы доказали точную оценку.
[02:10:37.080 --> 02:10:47.080]  Да. Ну и на самом деле еще, в общем, когда закончится норма Гаурса, я планирую вернуться к оценке энергии,
[02:10:47.080 --> 02:10:53.080]  потому что мне кажется, что я там очень много где грубо и нереально использовал.
[02:10:53.080 --> 02:10:57.080]  Вот. И где-то можно оценить потоньше и лучше результат получить.
[02:10:57.080 --> 02:11:02.080]  Ну, такие цели. То есть в целом у меня уже нереально готовы все. Осталось только там проверить, насколько они хороши.
[02:11:02.080 --> 02:11:09.080]  И если это возможно, как-то из инструментов выжать максимум и доработать их. Уточнить.
[02:11:09.080 --> 02:11:13.080]  Все, спасибо за внимание. Если есть вопросы, кто-то есть.
[02:11:13.080 --> 02:11:23.080]  Да.
[02:11:23.080 --> 02:11:33.080]  Да.
[02:11:33.080 --> 02:11:47.080]  Не, не, не. Ну, кстати, да, я забыл сказать, что E это, просто E это вторая энергия, не первая.
[02:11:47.080 --> 02:11:57.080]  Вот. Ну, это такое ограничение. Не очень. Ну да, по сути. То есть у нас на самом деле есть оценка,
[02:11:57.080 --> 02:12:05.080]  то, что E это больше оборудование овку поделить на K. Вот. А тут меньше-менше. То есть это символ винограда.
[02:12:05.080 --> 02:12:11.080]  То есть существует некоторая констанция.
[02:12:11.080 --> 02:12:21.080]  Ну, да, но это энергия не от множества, а от разного множества. То есть D, а-а.
[02:12:21.080 --> 02:12:29.080]  Ну, в целом, да. Ну, то есть там не на самом деле со случайным множеством все не так понятно,
[02:12:29.080 --> 02:12:40.080]  потому что да, там есть небольшие сложности с подсчетом. Если а случайно, то а-а чуть тяжело считать.
[02:12:40.080 --> 02:12:45.080]  Вот. И соответственно, это константа двоения тоже там, она в общем для случайного множества не такая тревожная.
[02:12:45.080 --> 02:12:51.080]  Ну, в целом, да. То есть там такая, что, в общем, так называется это неравенство, там отдельно доказано одно неравенство
[02:12:51.080 --> 02:12:58.080]  для отдельно богатого случая, отдельное неравенство для небогатого случая, дальше не скомбинируемое, и получается такое вообще.
[02:12:58.080 --> 02:13:06.080]  Вот. Ну, в целом, да. Ну, да, в общем, философия в том, что для D должна получиться большая энергия,
[02:13:06.080 --> 02:13:16.080]  для D мы его насильно делаем интимным богатым. Вот.
[02:13:16.080 --> 02:13:26.080]  Да.
[02:13:26.080 --> 02:13:39.080]  Ну. Ну, да, да. В смысле, разговор, потому что результат ужасен. Ну, да, есть такое. Не, на самом деле.
[02:13:39.080 --> 02:13:53.080]  Заново? Ну, такое и хотели. Ну, то есть. Нет, просто вопрос в том, что.
[02:13:53.080 --> 02:14:03.080]  Ну, проблема в том, что там есть вот этот новый вид энергии. E к, E к-1. То есть можно еще чуть-чуть оценить через E к,
[02:14:03.080 --> 02:14:10.080]  и потерять в точности. Вот. Потому что там важна не только симптатика А. То есть А в степени, там, К квадрат, еще что-то там.
[02:14:10.080 --> 02:14:19.080]  Но у нас еще там стоит К большое, констант удвоения. И мы также немножко за ней уборемся, то есть какой там показатель в степени и так далее.
[02:14:19.080 --> 02:14:27.080]  Вот. Потому что от него много зависит. Потому что, допустим, в небогатом случае, допустим, возьмем геометрическую прогрессию, да.
[02:14:27.080 --> 02:14:37.080]  У нас А это у него, допустим, мощность стен. Тогда у А-а будет мощность примерно N в квадрате. Правильно? То есть этот К большое, оно может быть по порядку где-то А.
[02:14:37.080 --> 02:14:39.080]  То есть за него тоже надо бороться. И да.
