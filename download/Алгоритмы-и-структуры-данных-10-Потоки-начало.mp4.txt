[00:00.000 --> 00:09.200]  Так, у меня остался долг про минимальное вершинное
[00:09.200 --> 00:11.200]  покрытие и максимальное независимое множество.
[00:11.200 --> 00:13.080]  Извините, я сегодня буду немножко в нос говорить,
[00:13.080 --> 00:14.080]  не до конца выздоровел.
[00:14.080 --> 00:17.160]  Значит, давайте я напомню, что мы сделали, мы доказывали
[00:17.160 --> 00:24.400]  термин Кёнига, который говорит, что размер минимального
[00:24.400 --> 00:26.640]  вершинного покрытия в вдольном графе.
[00:26.640 --> 00:37.920]  Я напишу так, минимальное вершинное покрытие, собственная
[00:37.920 --> 00:42.140]  аббревиатура Vertex Cover, вершинное покрытие, равно по размеру
[00:42.140 --> 00:47.320]  максимальному, по рассочетанию, matching.
[00:47.320 --> 01:01.240]  Ну и в качестве доказательства я там привожу какой-то
[01:01.240 --> 01:05.360]  алгоритм, типа давайте мы возьмем наш граф, наш
[01:05.360 --> 01:10.440]  двудольный граф, ориентируем его как-то ребра, ребра
[01:10.440 --> 01:12.800]  не из поршитания слева направо, ребра из поршитания
[01:12.800 --> 01:13.800]  справа налево.
[01:14.680 --> 01:17.000]  Право налево те, которые лежат, ну вот в том самом
[01:17.000 --> 01:20.000]  максимальном поршитании M, а слева направо те, которые
[01:20.000 --> 01:23.000]  не принадлежат M.
[01:23.000 --> 01:26.840]  Дальше запустим какой-нибудь обход типа DFS из всех ненасыщенных
[01:26.840 --> 01:30.480]  вершин левой доли, из тех, которые ненасыщены поршитанием,
[01:30.480 --> 01:33.360]  и обойдем все, что из них достижено по вот этим ребрам
[01:33.360 --> 01:34.360]  ориентированным.
[01:34.360 --> 01:37.240]  Дальше у нас физиграф распадется на, точнее все вершины распадутся
[01:37.240 --> 01:41.120]  на 4 категории, посещенные и непосещенные в левой
[01:41.120 --> 01:43.000]  доле и в правой доле.
[01:43.000 --> 01:47.000]  То есть вот здесь находились все ненасыщенные левой
[01:47.000 --> 01:49.040]  доли, из которых мы запускали обход.
[01:49.040 --> 01:51.760]  Дальше мы как-то ходили по стрелочкам, посетили
[01:51.760 --> 01:55.600]  все вот это, и еще все вот эти вершинки, то есть мы
[01:55.600 --> 01:57.720]  иногда могли доходить до насыщенных вершин левой
[01:57.720 --> 01:58.720]  доли, их тоже посещать.
[01:58.720 --> 02:02.200]  Соответственно они все лежат в плюсиках L+, R+, а все,
[02:02.200 --> 02:04.480]  что недостижимо, это вот это L-R-, соответственно
[02:04.480 --> 02:07.480]  левая и правая доля.
[02:07.480 --> 02:13.560]  И, значит, я всегда путаю вот это вот и вот это вот,
[02:13.560 --> 02:15.840]  одно из них это минимальное вершинное покрытие, другое
[02:15.840 --> 02:18.520]  максимально не здесь, вот сейчас поймем, кто из них
[02:18.520 --> 02:19.520]  кто.
[02:19.520 --> 02:21.560]  Значит, для этого надо понять, каких ребер в этом графе
[02:21.560 --> 02:22.560]  точно нету.
[02:22.560 --> 02:24.800]  Давайте напишем, каких ребер точно нет.
[02:24.800 --> 02:34.760]  Ну, во-первых, очевидно, нет никогда ребер из плюсов
[02:34.760 --> 02:44.600]  L-, поэтому нет ребер из L+, R-, нет ребер из R+, L-.
[02:44.600 --> 02:54.840]  Значит, и третье, нет ребер, видимо, из R+, L-, наоборот,
[02:54.840 --> 03:04.600]  из, сейчас, сейчас скажу, из R-, L+, да, да.
[03:04.600 --> 03:07.560]  Я в прошлый раз вроде успел заметить, что таких ребер
[03:07.560 --> 03:12.120]  не бывает, потому что если бы они были, то давайте
[03:12.120 --> 03:13.120]  поймем, что это за ребро.
[03:13.120 --> 03:15.360]  Это какое-то ребро, ведущее справа налево, то есть это
[03:15.360 --> 03:18.240]  ребро из парасочетания, это какое-то ребро из
[03:18.240 --> 03:20.720]  парасочетания, ведущее справа налево, поэтому оба
[03:20.720 --> 03:22.720]  его конца насыщенные вершины.
[03:22.720 --> 03:26.400]  Значит, вот отсюда DFS не запускался, это не начальные
[03:26.400 --> 03:28.840]  вершины никакого пути, поэтому мы, получается, в нее как-то
[03:28.840 --> 03:29.840]  дошли.
[03:29.840 --> 03:31.920]  Но дойти в нее из другой ненасыщенной можно было
[03:31.920 --> 03:33.960]  только с помощью вот этого ребра справа налево.
[03:33.960 --> 03:35.560]  Это единственное ребро, справа налево, которое
[03:35.560 --> 03:36.560]  в нее ведет.
[03:36.560 --> 03:38.960]  Поэтому попасть сюда мы никак не могли, кроме как
[03:38.960 --> 03:40.200]  с помощью этого ребра.
[03:40.200 --> 03:43.120]  Да, но если это плюсик, значит, это тоже должно быть плюсик,
[03:43.120 --> 03:44.120]  противоречие.
[03:44.120 --> 03:47.600]  Вот, значит, таких ребер точно нет, из этого следует,
[03:47.600 --> 03:52.560]  что уже вот это вот множество, это независимое множество,
[03:52.560 --> 03:54.360]  да, потому что нет ребер ни слева направо, ни справа
[03:54.360 --> 03:55.360]  налево.
[03:55.360 --> 03:56.360]  Вот они, вот они два.
[03:56.360 --> 04:02.400]  Значит, L+, R-, это независимое множество.
[04:02.400 --> 04:09.520]  Ну и как мы отмечали в прошлый раз, значит, дополнение
[04:09.520 --> 04:10.520]  к нему это вершинное покрытие.
[04:10.520 --> 04:16.520]  Значит, все остальное R+, в объединении с L-, это вершинное
[04:16.520 --> 04:17.520]  покрытие.
[04:17.520 --> 04:26.080]  Докажем, что это минимально, то есть нет никакого другого
[04:26.080 --> 04:28.920]  вершинного покрытия, которое было бы меньшего размера.
[04:28.920 --> 04:31.440]  Меньше вершин в покрытии иметь нельзя.
[04:31.480 --> 04:33.800]  Вот столько минимум меньше, меньше не получится.
[04:33.800 --> 04:37.640]  Вот, ну для этого заметим давайте, что вот здесь вот
[04:37.640 --> 04:39.640]  лежат только насыщенные вершины.
[04:39.640 --> 04:43.000]  В обоих множествах лежат только насыщенные по рассчитанию
[04:43.000 --> 04:44.000]  вершины.
[04:44.000 --> 04:52.040]  R+, L-, лежат только насыщенные вершины.
[04:52.040 --> 05:08.440]  Ну, с тем минусом вроде понятно, потому что ненасыщенные
[05:08.440 --> 05:10.560]  вершины левой доли, они точно были плюсики.
[05:10.560 --> 05:14.280]  Из ненасыщенных левой доли мы запускали обход, поэтому
[05:14.280 --> 05:18.040]  они точно были объединены в нашем обходе, ну как мы
[05:18.040 --> 05:19.200]  из них запускались.
[05:19.200 --> 05:21.520]  Поэтому все ненасыщенные вершины левой доли точно
[05:21.600 --> 05:23.400]  вот здесь.
[05:23.400 --> 05:25.400]  Ну а значит насыщенные могут быть только здесь.
[05:25.400 --> 05:26.680]  Ну в смысле не так.
[05:26.680 --> 05:29.960]  Насыщенные могут быть и здесь и здесь, да, но здесь
[05:29.960 --> 05:31.320]  ненасыщенные быть не может.
[05:31.320 --> 05:32.380]  То есть тут только насыщенные.
[05:32.380 --> 05:35.600]  Поэтому с L минусом очевидно, здесь только насыщенные.
[05:35.600 --> 05:40.800]  Вот, а с R+, почему там только насыщенные?
[05:40.800 --> 05:44.720]  Потому, что чтобы там была ненасыщенная, то раз она
[05:44.720 --> 05:48.000]  в R+, значит мы до нее смогли дойти из ненасыщенных
[05:48.000 --> 05:48.880]  вершины левой доли.
[05:48.880 --> 05:54.520]  Значит, мы смогли начать где-то в L+, закончиться в R+, и, получается, мы нашли, на самом деле,
[05:54.520 --> 05:59.800]  увеличивающий путь. Если бы, если мы нашли путь из ненасыщенного в ненасыщенную, вот в нашем
[05:59.800 --> 06:03.040]  таком графе, то у нас получился бы увеличивающий путь, а мы предположили, что исход на прошествии
[06:03.040 --> 06:13.600]  максимально. Вот, поэтому такого тоже не будет. Значит, если бы в R+, была ненасыщенная вершина,
[06:13.600 --> 06:33.600]  то в G был бы увеличивающий путь. Да, но потому что, что значит, что здесь есть какая-то ненасыщенная,
[06:33.600 --> 06:40.600]  вот она V ненасыщенная. Раз она в R+, значит, она как-то достижима. То есть, мы начали в какой-то
[06:40.600 --> 06:46.160]  вершине U ненасыщенной вершины левой доли, как-то походили по ребрам слева-направо,
[06:46.160 --> 06:50.760]  справа-налево, и рано или поздно пришли в V. Ну, значит, просто по определению это увеличивающий путь.
[06:50.760 --> 06:55.880]  Я рисовал в прошлый раз тоже картинку. Мы начали, закончили в ненасыщенной, длина хотя бы единица,
[06:55.880 --> 07:00.640]  потому что это разные доли, ну и как раз у меня есть чередование типов ребер слева-направо,
[07:00.640 --> 07:05.720]  справа-налево. Это как раз не из порштани, а из поросочетания. Вот, поэтому в R+, это тоже только
[07:05.720 --> 07:22.480]  насыщенные. Окей? Вот. Более того, я утверждаю, что размер вот этого множества не превосходит
[07:22.480 --> 07:28.400]  размеры поросочетания. То есть, вершин вот там вот суммарно не больше, чем ребер в поросочетании.
[07:28.400 --> 07:32.600]  Напоминаю, что здесь мы как бы вершинки меряем, количество вершин измеряем, а здесь количество ребер,
[07:32.600 --> 07:38.240]  потому что M это у нас семейство ребер. Потому здесь мощность — это количество вершин,
[07:38.240 --> 07:46.320]  здесь мощность — это количество ребер. Вот. А почему здесь вершин не больше, чем здесь ребер? Ну,
[07:46.320 --> 07:51.200]  потому что я утверждаю, что каждое ребро поросочетания, каждое ребро поросочетания,
[07:51.200 --> 08:03.360]  ну, точнее не так. Никакое ребро поросочетания не может выглядеть вот так. Потому что вот я уже
[08:03.360 --> 08:09.320]  замечал, что ребер из R+, в L-, не бывает. Поэтому на самом деле любое ребро поросочетания мы нарисовали,
[08:09.320 --> 08:16.600]  что не может идти из R+, в L+, не может идти из R-, в L+, значит оно либо вот такое, либо вот такое. То есть,
[08:16.700 --> 08:22.320]  из R– в L– или из R++ в L+. Но главное, что это значит — смотрите, вот здесь вот какие-то насыщенные вершины,
[08:22.780 --> 08:27.380]  и здесь какие-то насыщенные вершины. При этом нет никакого ребра поросочетания,
[08:27.380 --> 08:31.700]  который бы соответствовал однонавременно двум вершинам отсюда и отсюда. Любое ребро поросочетания
[08:31.700 --> 08:36.400]  то либо соответственно одно вершине отсюда, либо одно отсюда. Поэтому ребр должно быть хотя бы
[08:36.400 --> 08:41.660]  столько, сколько вершин. Потому что вот они вершины, каждый из них соответствует хотя бы одно ребро,
[08:41.660 --> 08:45.120]  при этом эти ребра все разные. То есть не бывает такого, что двум вершинам соответствует одно и
[08:45.120 --> 08:47.640]  то же ребро про сочетание. То есть вот этим вершинам
[08:47.640 --> 08:49.880]  соответствуют такие ребра, а этим вершинам соответствуют
[08:49.880 --> 08:54.200]  такие ребра. Поэтому суммарный вершин не меньше, чем ребер.
[08:54.200 --> 08:55.580]  Потому что каждой вершине соответствует сходящее
[08:55.580 --> 08:58.920]  ребро. Либо такое, либо такое. Ну вот отсюда сразу следует
[08:58.920 --> 09:11.240]  такое неравенство. Да, так как каждой вершине из
[09:11.240 --> 09:25.440]  этого множества можно сопоставить уникальное ребро из поросочетания.
[09:25.440 --> 09:33.880]  Уникальное ребро из M. Ну вот, и поскольку они уникальны,
[09:33.880 --> 09:37.440]  то есть все попарно различны для всех разных вершинок,
[09:37.440 --> 09:39.800]  то получается, что ребер хотя бы столько, сколько
[09:39.800 --> 09:45.840]  вершин. Вот. Получилось у нас что?
[09:45.840 --> 09:48.720]  Смотрите, у нас получилась вот эта штука, это вершинное
[09:48.720 --> 09:52.080]  покрытие, но при этом его размер не больше, чем размер
[09:52.080 --> 09:55.680]  максимального поросочетания. Не больше, чем размер M.
[09:55.680 --> 10:04.640]  Но не бывает вершинных покрытий размера меньше, чем размер
[10:04.640 --> 10:17.960]  поросочетания. Не бывает вершинных покрытий размера
[10:17.960 --> 10:21.840]  меньше, чем размер M. Потому что если есть размер какой-то
[10:21.840 --> 10:23.680]  поросочетания, да, вот есть поросочетания, давайте
[10:23.680 --> 10:27.160]  вот так красиво нарисую. Вот есть какой-то поросочетания.
[10:27.160 --> 10:28.960]  Тогда понятно, что чтобы покрыть все эти ребра, мне
[10:28.960 --> 10:30.720]  нужно взять хотя бы по одной вершинке с каждого
[10:30.720 --> 10:34.840]  ребра. Да, ну там, я должен взять хотя бы одну из них,
[10:34.840 --> 10:36.560]  хотя бы одну из них, хотя бы одну из них, хотя бы
[10:36.560 --> 10:40.200]  одну из них. Никак меньшим числом не обойтись, поскольку
[10:40.200 --> 10:44.520]  все эти концы различны, поросочетания у нас все
[10:44.520 --> 10:47.600]  концы попарно отличаются. Значит, мне нужно с каждого
[10:47.600 --> 10:50.080]  ребра взять хотя бы одну вершинку. Значит, меньше
[10:50.080 --> 10:55.080]  чем M получить нельзя. Получается, что любое покрытие, любое
[10:55.080 --> 10:57.900]  вершинное покрытие по размеру хотя бы больше
[10:57.900 --> 11:01.740]  либо равно, чем M. А мы получили здесь меньше либо равно.
[11:01.740 --> 11:09.300]  Значит, это минимальное, и мы все доказали. Меньше
[11:09.300 --> 11:11.980]  быть нельзя, здесь у нас значок меньше либо равно,
[11:11.980 --> 11:14.780]  поэтому там на самом деле достигается равенства. R
[11:14.780 --> 11:18.780]  плюс в объединении с L минусом, это в точности M по мощности.
[11:18.780 --> 11:22.460]  Вот. Ну и меньше нельзя. Значит, это самое маленькое
[11:22.460 --> 11:34.940]  вершинное покрытие. Минимальное вершинное покрытие. Все.
[11:34.940 --> 11:38.540]  Мы получили утверждение теоремы, что есть вот такое
[11:38.540 --> 11:40.500]  вот вершинное покрытие размеров точности, размер
[11:40.500 --> 11:43.520]  просочетания, и меньше нельзя. Меньше нельзя получить
[11:43.520 --> 11:46.820]  никакое вершинное покрытие, потому что вот замечания,
[11:46.820 --> 11:50.140]  да, не бывает таких просто. А такое есть. Размеров
[11:50.140 --> 11:55.340]  точности M. Вот. Поэтому мы с вами получили конструкцию
[11:55.340 --> 11:57.460]  для нахождения минимального вершинного покрытия. Ну
[11:57.460 --> 11:59.820]  и на халяву мы можем заметить, что R минус в объединении
[11:59.820 --> 12:03.300]  с L плюс это автоматически максимально независимое
[12:03.300 --> 12:10.780]  множество. Потому что одно всегда дополнение к другому,
[12:10.780 --> 12:13.260]  дополнение к вершинному покрытию всегда независимое множество,
[12:13.260 --> 12:16.300]  и наоборот. Значит, если мы одно минимизируем, то
[12:16.380 --> 12:22.380]  автоматически максимизируется по размеру. Ну все. Теорему
[12:22.380 --> 12:25.260]  доказали, алгоритм предъявили, и мы, получается, можем,
[12:25.260 --> 12:29.180]  если у нас, если у нас M уже найдено, то мы можем вот
[12:29.180 --> 12:31.700]  это вот все дело сделать всего лишь за линейное от
[12:31.700 --> 12:34.740]  размера графа время, потому что по сути просто DFS. Я
[12:34.740 --> 12:37.020]  ориентировал как-то ребра, потом запустил какой-то
[12:37.020 --> 12:43.060]  обход и сказал, что там вот эти два куска это что-то,
[12:43.060 --> 12:45.380]  а вот эти два куска это что-то другое. Ну там одно независимо
[12:45.380 --> 12:47.540]  что другое вершины покрытие. Получается, за линейное
[12:47.540 --> 12:57.260]  время я могу найти вот эти две штуки. Окей? Да. Напомню
[12:57.260 --> 13:00.300]  в отличие от произвольного графа, где вот эту вот вещь
[13:00.300 --> 13:06.540]  мы быстрее, чем за экспонент искать не умеем. Так, ну
[13:06.540 --> 13:11.620]  хорошо. Тогда с этим закончили. Давайте переходить к потокам.
[13:11.620 --> 13:24.500]  В следующей несколько лекций будет про потоки. Определение.
[13:24.500 --> 13:34.580]  Значит, сетью я буду называть следующую штуку. Я буду
[13:34.580 --> 13:39.540]  называть ориентированный граф G с двумя выделенными
[13:39.580 --> 13:54.820]  различными вершинами. Которые я буду называть и сток и
[13:54.820 --> 14:03.900]  сток. То есть, грубо говоря, начало и конец. Вот. А C это
[14:03.900 --> 14:10.420]  какая-то целочисленная функция, выражающая пропускные
[14:10.420 --> 14:17.420]  способности всех ребер. Функция из E в так. Ну давайте
[14:17.420 --> 14:25.980]  вот так напишу. Целые неотрясательные числа, которые будут называться
[14:26.060 --> 14:41.820]  пропускные способности ребер. Вот. Ну и смысл здесь
[14:41.820 --> 14:45.260]  очень простой. Если у меня есть какой-то граф, есть выделенный
[14:45.260 --> 14:50.500]  в нем начало и конец, есть на ребрах какие-то ограничения.
[14:50.500 --> 14:54.020]  Сколько на каждом конкретном ребре может в единицу времени
[14:54.060 --> 14:58.660]  течь водички. Соответственно, C от E для каждого ребра
[14:58.660 --> 15:00.900]  это какое-то ограничение, сколько воды может протекать
[15:00.900 --> 15:10.220]  по ребру. Ну давайте что-нибудь нарисую. Вот. На каждом ребре
[15:10.220 --> 15:22.220]  напишем какое-нибудь число. Ну пусть будет вот так. Ну
[15:22.420 --> 15:28.340]  что, вам ноль надо нарисовать где-нибудь? Давайте ноль. Капасти
[15:28.340 --> 15:32.100]  все неотрясательные всегда. Капасти всегда неотрясательные.
[15:32.100 --> 15:35.460]  Вот. Ну и нам нужно переправить как можно больше водички
[15:35.460 --> 15:39.540]  из S в T. Как это можно здесь сделать? Можно ли три единицы
[15:39.540 --> 15:42.260]  здесь делать? Да, вроде на халяву. Можно вот здесь
[15:42.260 --> 15:44.980]  вот пустить единичку по вот этому пути и вот здесь
[15:44.980 --> 15:49.540]  вот двоечку. Нет, нельзя двоечку, да? Ну вот так вот.
[15:49.540 --> 15:56.300]  Ну как-нибудь можно короче, ну вроде видно. Сейчас давайте
[15:56.300 --> 16:04.220]  нарисую три пути просто. Такой вот путь. Такой вот путь.
[16:04.220 --> 16:22.060]  Нарисовался примерно на свою голову. А? Тип того, да. Ну ноль
[16:22.060 --> 16:24.300]  значит, что мы по факту по нему ничего пускать не можем.
[16:24.300 --> 16:27.820]  Но нам такие ребра будут на самом деле нужны когда-то. Вот.
[16:27.820 --> 16:32.820]  Значит я нарисовал три пути. Оранжевый, красный и синий. Если по каждому из них
[16:33.380 --> 16:39.180]  пустить единичку потока, то мы суммарно передали из S в T три единицы и при этом нигде не нарушили
[16:39.180 --> 16:42.940]  ограничений. Да, вот здесь вот максимум. Ну здесь течет вообще единица потока,
[16:42.940 --> 16:47.300]  которая не больше чем два. Здесь две единички как раз это ребро мы целиком насытили. Его
[16:47.300 --> 16:51.340]  больше не можем использовать. Здесь течет единичка из синий. Ну и так далее. Вот это
[16:51.340 --> 16:56.300]  вот ребро еще тоже насыщенное. Один из одного. Вот. Ну и можно бдиться очень легко, что это
[16:56.300 --> 17:00.540]  максимальный поток. Просто потому что из S мы больше ничего выпустить не можем. Да,
[17:00.620 --> 17:05.420]  здесь суммарное ограничение будет три. Один плюс два. Ну вот как раз три единицы я выпустил. Больше
[17:05.420 --> 17:10.340]  понятно. Больше нельзя. Вот. Ну и задача это найти как раз тот самый максимальный поток. То есть как
[17:10.340 --> 17:17.540]  можно больше водички успеть передать из S в T за единицу времени. За у нас будет лучший алгоритм
[17:17.540 --> 17:25.380]  ЗВ квадрат Е. Ну такое на самом деле. Но оно на самом деле летает, потому что эти симптотики,
[17:25.380 --> 17:29.140]  они только прям очень теоретически, чтобы оно реально столько работало. Граф должен быть
[17:29.140 --> 17:33.740]  очень специфический, но такое не достигается на практике. Обычно там сильно лучше будет.
[17:33.740 --> 17:47.500]  Да. Пока оно, пока не нужно, пока можно. Потом, потом поймем зачем нужно. Вот. Так, что надо дальше
[17:47.500 --> 17:57.140]  сказать. Да. Зачем нужны ребра capacity 0? Я буду говорить по-русски capacity от слова собственно
[17:57.140 --> 18:03.260]  capacity. Потому что пропускные способности тяжело мне выговорить, а capacity довольно легко. Так вот.
[18:03.260 --> 18:12.020]  Мы на самом деле можем считать, что те ребра, которых нет, имеют capacity 0. Ну потому что как
[18:12.020 --> 18:15.780]  мы видим, вот эта ребра веса 0, она абсолютно бесполезна. Мы все равно по нему ничего передавать
[18:15.780 --> 18:21.940]  не можем. И как бы что оно есть, что его нет, абсолютно ни на что не влияет. Поэтому если что,
[18:21.940 --> 18:28.420]  я могу считать, что между всеми вершинами, где нет ребра, на самом деле есть ребро capacity 0. И
[18:28.420 --> 18:35.420]  более того, даже вот такие обратные ребра будут с capacity 0. Если ребро из У в В, а из В в У нет,
[18:35.420 --> 18:42.220]  то можно сделать обратное с capacity 0. Вот. И нам это на самом деле будет нужно. Давайте как бы
[18:42.220 --> 18:48.820]  виртуально проводить все, вообще все ребра в этом графе попарно, и там где нормального ребра не было,
[18:48.820 --> 18:59.020]  будем считать, что capacity равно нулю. Так. Ну давайте, значит, определение тогда. Дадим,
[18:59.020 --> 19:14.180]  что такое поток. Ну пусть вот у нас есть какая-то сеть. Тогда функция f из В квадрат в Z называется
[19:14.180 --> 19:23.220]  потоком, если одновременно выполняются три условия. Во-первых, самое естественное условие,
[19:23.220 --> 19:31.900]  самое простое, это что поток всегда не большим capacity. Для любой пары у В, f у В не больше,
[19:31.900 --> 19:39.780]  чем c у В, где c у В это capacity на ребре у В. А если ребра нет, то оно автоматически считается 0.
[19:39.780 --> 19:57.940]  Давайте это пропишу, что если ребра нет, то считаем, что c равно нулю. Да, все может быть.
[19:57.940 --> 20:08.140]  Второе, а второе антисимметричность, свойство антисимметричности на любом
[20:08.140 --> 20:14.620]  ребре, точнее для любой пары вершин, f в одном направлении равно минус f в другом направлении.
[20:15.180 --> 20:27.780]  На счет называется антисимметричность. Тип того, да. То есть как бы если вы пустили из У в В
[20:27.780 --> 20:33.340]  единичку потока, то это то же самое, что вы из В в У заняли единичку потока. То есть если один
[20:33.340 --> 20:40.780]  игрок отдает другому единичку, то второй должен первому единичку. Вот и третье,
[20:40.780 --> 20:50.620]  свойство сохранения потока говорит о следующем, что если мы выберем любую вершину, отличную от
[20:50.620 --> 21:04.380]  s и t, то для нее сумма всех исходящих ребер, так вот так придется написать, равна нулю, точнее
[21:04.380 --> 21:11.540]  сумму всех исходящих потоков. Это называется свойство сохранения потока. Свойство сохранения
[21:11.540 --> 21:31.580]  потока. Вот. Значит по смыслу, по смыслу это значит, что у нас поток в вершинах не задерживается. То
[21:31.580 --> 21:35.180]  есть не может быть такого, что вершину притекло больше, чем вытекло или наоборот вытекло больше,
[21:35.180 --> 21:42.500]  чем притекло. То есть если есть какая-то вершинка В, в нее сколько-то потока притекло, сколько-то
[21:42.500 --> 21:47.860]  вытекло. Вот не нужно, чтобы суммарно вот здесь было равно то, чему вот здесь. Это как раз обеспечено
[21:47.860 --> 21:52.620]  за счет антсимметричности и третьего свойства, потому что когда какой-то поток вот здесь вот втек,
[21:52.620 --> 22:00.860]  представьте там, не знаю, x, y, z. Вот. А здесь выйти какой-нибудь a, b, вот эти величины потоков.
[22:00.860 --> 22:06.660]  Тогда на вот этих вот обратных ребрах справа налево по антсимметричности будет написан
[22:06.660 --> 22:12.140]  противоположный поток. Вот здесь будет минус a, здесь будет минус b. Ну и я как бы хотел бы
[22:12.140 --> 22:19.660]  написать равенство, что x плюс y плюс z равно a плюс b. Но это то же самое, что я написал вот там,
[22:19.660 --> 22:26.860]  что x плюс y плюс z минус a минус b равно нулю. Потому что x плюс y плюс z это как бы нормальные
[22:26.860 --> 22:32.580]  втекающие, а минус a минус b это ну как бы втекающее, но со знаком минус. Ну от того,
[22:32.580 --> 22:39.780]  что их перенес сюда, не раз сохранилось таким же, как надо. Поэтому третье свойство, как раз
[22:39.780 --> 22:45.220]  смысл ровно такой, что сколько втекло, столько и вытекло. Вот эта вот сумма входящих равна сумме
[22:45.220 --> 22:49.220]  исходящих. Просто за счет антсимметричности у меня появляются вот эти вот противоположные
[22:49.220 --> 22:54.140]  ребра, противоположные потоки, ведущие обратно в В, но они будут с противоположным знаком и как
[22:54.140 --> 23:02.540]  раз здесь встутся. То есть это одно и то же равенство получилось. Потому что для stt это очевидно
[23:02.540 --> 23:14.020]  не выполняется. Скажем вот здесь вот для вершинки s. Но для вершинки s смотрите, у нас есть одно
[23:14.020 --> 23:19.580]  ребро с потоком единица, одно ребро с потоком 2 и больше никаких ребер исходящих здесь нету из нее.
[23:19.580 --> 23:25.820]  То же самое для t. Здесь входит двойка потока, здесь входит единичка потока. То есть отсюда как бы
[23:25.820 --> 23:32.420]  вытекло 3, а сюда как бы втекло 3. Ну и это соответствует тому, что мы хотим. У нас как бы тут,
[23:32.420 --> 23:36.620]  не знаю, есть какая-то нефтяная скважина, которая качает нефть и передает ее дальше. А здесь,
[23:36.620 --> 23:43.380]  наоборот, какой-нибудь склад, куда это нефть переливается. Поэтому отсюда она как бы появляется
[23:43.380 --> 23:50.340]  неоткуда, а здесь она исчезает никуда. А по дороге она как раз нигде не накапливается. Вот.
[23:50.340 --> 24:08.060]  Значит, вот такой поток. Ау. Не слышу. Дальше. Следующее определение, это остаточная сеть.
[24:08.060 --> 24:26.300]  Ж с индексом f. То есть если у меня была какая-то сеть, ж и поток f. Значит, тогда я определяю для
[24:26.300 --> 24:34.760]  каждой пары вершин, я определяю остаточную пропускную способность, как просто сколько
[24:34.760 --> 24:43.480]  дополнительным потоком можно перебру пустить. То есть это сув минус фув. Сколько можно было
[24:43.480 --> 24:49.560]  вообще, минус сколько я уже пропустил. Очень известная штука. Называется остаточная пропускная
[24:49.560 --> 25:03.480]  способность. Остаточная пропускная способность. Все. То есть мы вот так определяем остаточные
[25:03.480 --> 25:10.760]  capacity, сколько дополнительно можно еще пропустить по ребру. Но вот здесь, в остаточной сети,
[25:10.760 --> 25:24.320]  мы давайте, значит, я скажу вот здесь вот. Мы удаляем ребра нулевой capacity. Удаляем
[25:24.320 --> 25:35.160]  ребра нулевой пропускной способности. Нулевой capacity. То есть мы понимаем, что ребра нулевой
[25:35.160 --> 25:39.560]  capacity, по ним все равно поток не течет, и вот здесь вот мне удобно будет их прям насильно
[25:39.560 --> 25:55.360]  исключить из графа. Тогда будет выполняться следующее утверждение, очень удобное, что поток
[25:55.360 --> 26:01.000]  максимален, если и только если вот в этой остаточной сети относительно этого потока нет никакого
[26:01.000 --> 26:15.280]  пути из s в t. То есть поток f максимален, если и только если в его остаточной сети нет пути из s в t.
[26:15.280 --> 26:31.040]  Вот. В такой постановке максимальность потока это то же самое, что отсутствие
[26:31.040 --> 26:36.000]  какого-либо пути из s в t в остаточной сети g f. Ну, потому что понятно, если какой-то
[26:36.000 --> 26:41.360]  остаточный путь есть, если есть путь вот здесь вот, g f, какой-нибудь вот такой вот путь,
[26:41.360 --> 26:48.080]  это значит, что на всех этих ребрах capacity положительная, да, раз capacity всегда это
[26:48.080 --> 26:51.880]  понятное дело, не отрицательная величина, потому что поток всегда не большим capacity,
[26:51.880 --> 26:57.040]  значит это разность всегда не отрицательная, и при этом нулевые capacity мы выкинули. Значит,
[26:57.040 --> 27:03.120]  здесь все capacity положительны, все остаточные capacity положительны. Значит, если я выберу просто из
[27:03.120 --> 27:08.800]  них минимальное, то я по этому ну или там просто единичку возьму, то я по этому пути могу протокнуть
[27:08.800 --> 27:14.200]  единицу потока, тем самым увеличу весь поток, а значит изначально не максимальный. Вот. Ну,
[27:14.200 --> 27:17.600]  в обратную сторону мы докажем чуть позже. Пока вот как бы главный пафос в том, что,
[27:17.600 --> 27:25.160]  ну во многом схоже с предыдущей лекцией, максимальность достигается в отсутствие каких-то
[27:25.160 --> 27:38.560]  увеличивших путей. Ну, ну как бы, ну да, я не определил, но величина потока, давайте,
[27:38.560 --> 27:52.080]  давайте сформализуем тоже все это, давайте. Значит, величина потока это просто сколько из
[27:52.080 --> 28:04.600]  s вытекает. Модуль f это сколько течет водички из s. Вот. Ну и поток максимальный, если вот эта
[28:04.600 --> 28:13.320]  штука максимальна среди всех потоков. Максимальный поток, это соответственно нам
[28:13.320 --> 28:33.440]  нужно максимизировать значение потока. Так, еду дальше. Значит, смотрите, чтобы нам доказать вот
[28:33.440 --> 28:40.360]  это утверждение, да, критерии максимальности потока, мне нужно будет вести еще несколько
[28:40.360 --> 28:44.440]  определений и доказать их там по циклу. То есть, чтобы вот эти два доказать, нужно вести еще третье
[28:44.440 --> 28:49.400]  эквивалентное к ним свойство и потом как бы с его помощью доказать эквивалентность первых двух.
[28:49.400 --> 29:03.400]  Значит, определение пусть g это сеть, значит, тогда пара st называется разрезом, если,
[29:03.400 --> 29:13.000]  если выполняется следующее свойство. s-маленькое лежит в s-большом, t-маленькое лежит в t-большом,
[29:13.000 --> 29:22.280]  и их дизинктное объединение равно множеству всех вершин. Вот. То есть, мне нужно все вершинки
[29:22.280 --> 29:27.560]  разбить на две группы, s-большое, t-большое, такие, что s-маленькое в s-большом, t-маленькое в t-большом,
[29:27.560 --> 29:32.960]  и они как раз покрывают все вершины по одному разу. То есть, любая вершина либо здесь, либо здесь.
[29:32.960 --> 29:51.080]  Значит, дальше величиной потока, sorry, разреза, величина разреза st. Это следующая сумма. Сумма
[29:51.080 --> 30:02.480]  по всем u из s, v из t. Capacity u, v. То есть, если есть у меня разбиение моих вершин на два множества,
[30:02.480 --> 30:06.960]  s-большое, t-большое, то величина этого разреза это просто сумма всех вот этих
[30:06.960 --> 30:13.240]  capacities слева направо. Ну, из st точнее. Вот эти все capacities складываю, получаю величину разреза.
[30:13.240 --> 30:33.160]  Вот. И третье. Величина потока через разрез. Величина потока f через разрез st. Это следующая
[30:33.160 --> 30:44.960]  величина. Сумма опять-таки по всем u из s, v из t. Величины потока слева направо, f, v. То есть,
[30:44.960 --> 30:58.480]  та же самая сумма, только мы берем не capacity, а потоки. Вот. Например, вот на этом рисуночке я
[30:58.480 --> 31:04.160]  уже на самом деле нарисовал какой-то разрез. Вот он очень простой. s-большое это множество из
[31:04.160 --> 31:10.240]  одной вершины s, а t соответственно все остальное. t-большое это все остальное. Тогда вот на этом
[31:10.240 --> 31:15.520]  рисунке у меня получилось capacity этого разреза, величина этого разреза 3, потому что вот всего два
[31:15.520 --> 31:22.320]  ребра пересекают наш разрез. 1 и 2. А в сумме будет 3. Ну и на самом деле поток тоже здесь суммарно
[31:22.320 --> 31:27.560]  исходящий равен тройке. Вот здесь единичка потока и здесь два единички потока. Тоже суммарно тройка
[31:27.560 --> 31:37.320]  получилась. Вот. Ну давайте сначала следующее. Давайте утверждение это напишу. Утверждение
[31:37.320 --> 31:47.240]  величина потока через разрез равна величине разреза. Вот и потока. Извините, заговариваюсь.
[31:47.240 --> 32:00.920]  То есть вот эта сумма, которую здесь определил, это на самом деле то же самое, что вот это. То есть
[32:00.920 --> 32:06.760]  вот по факту я утверждаю равен с вот этих двух сумм. Доказательства. Давайте напишем, что такое FST.
[32:06.760 --> 32:25.720]  Я хочу переписать это вот так. Вот. Ну это вроде понятно. То есть здесь у меня ушко бегает по
[32:25.720 --> 32:30.920]  вершинам из S, вешка бегает по вершинам из T. Давайте я сначала разрешу вешке бегать по всем
[32:30.920 --> 32:35.760]  вершинам, а потом вычту ту сумму, которая получается, если V бегает по S. За счет того,
[32:35.760 --> 32:40.800]  что S и T в объединении дают в точности все V, то у меня вот здесь вот в этой разности как раз
[32:40.800 --> 32:51.440]  учтутся только нужные слагаемые. Дальше. Я утверждаю, что вот это ноль, потому что здесь каждый
[32:51.440 --> 32:59.120]  ребро между вершинами будет учтено два раза. Значит, давайте напишем, что такое FSS. Это сумма
[32:59.120 --> 33:07.680]  по U из S, V из S, FUV. Значит, это, ну давайте напишу так, давайте формально напишем,
[33:07.680 --> 33:19.400]  сумма по всем U меньше V, U из S, V из S, FUV плюс FVU, и плюс там будут слагаемые, когда U и V
[33:19.400 --> 33:33.200]  одинаковые. Давайте напишу X из S, FXX. Ну вот, на самом деле F для любой пары множеств, множество
[33:33.200 --> 33:37.280]  запятая множество, эта сумма вот такая. Просто когда я беру одну вершину из первого множества,
[33:37.280 --> 33:46.280]  другую из второго и складываю все такие потоки. Если нет ребра, то мы считаем, что там есть ребро
[33:46.280 --> 33:57.760]  capacity 0. Ну значит, на самом деле, не обязательно, но обычно да. Например, если между вершинами есть
[33:57.760 --> 34:02.600]  ребро в одну из двух сторон и там течет какой-то поток, единица, то по обратному ребру на самом
[34:02.600 --> 34:08.360]  деле что-то поток и минус единица, даже несмотря на то, что его нет. Так, я ответил на ваш вопрос.
[34:08.560 --> 34:19.160]  Ну, на самом деле все очень просто. Смотрите, я определяю для любых множеств A и B. F от A-B это
[34:19.160 --> 34:31.400]  сумма по A из A и B из B. F-A-B. Поэтому, когда я здесь пишу S-T, у меня одна переменная бегает по S,
[34:31.400 --> 34:36.520]  а другая по T. Я отражаю, что вот эта сумма, это же самое, что если я первую перемену фиксирую по S,
[34:36.600 --> 34:42.120]  а вторую сначала она бегает по всему V, но потом я вычитаю все, когда она бегает по S. Тогда как раз
[34:42.120 --> 34:48.000]  я сначала беру слишком много, но все ненужное потом вычитаю. Вот я хочу доказать, что это равно 0.
[34:48.000 --> 34:57.560]  Вот это вот слагаемое равно 0. Я сейчас это доказываю. Так вот, почему FSS равно 0? FSS это сумма
[34:57.560 --> 35:03.640]  вот такая, просто по определению. Сумма по всем вершинам U из S, V из S. F-U-V. Значит, дальше все
[35:03.640 --> 35:10.040]  слагаемые я разбиваю на группы. Если U и V различные вершины, то я их разбиваю вот в такие два слагаемые.
[35:10.040 --> 35:18.040]  F-U-V и F-V-U. То есть в две стороны. И последняя группа слагаемых, это когда U и V одинаковые. Я их
[35:18.040 --> 35:27.160]  обзывал за X. Ну все, а мы знаем по антисимметричности, что вот это вот 0. На что всегда F-U-V плюс F-V-U это 0.
[35:27.160 --> 35:35.280]  Вот оно написано. Они противоположные. Потоки в две стороны противоположные. Но эта штука тоже равна 0.
[35:35.280 --> 35:43.000]  Собственно, тоже из-за антисимметричности, потому что если я вот здесь вот напишу вместо U и VX, у меня
[35:43.000 --> 35:57.320]  получится F-X-X равно минус F-X-X. Значит, он равен 0. F-X-X. OK. Вот. Все. И из-за антисимметричности у меня
[35:57.320 --> 36:06.040]  получается все слагаемые здесь нулевые. Значит, вот эта штука равна 0 просто. Так, едем дальше. Зачем
[36:06.040 --> 36:24.960]  мы это сделали? Едем дальше. Мы показали, что F-S-T это то же самое, что F-S-V. Потому что эта штука равна 0.
[36:24.960 --> 36:34.840]  Дальше. Я в S-большом выделю отдельно вершинку S-маленькая и соответственно все остальное.
[36:34.840 --> 36:44.120]  S-большое без S-маленького. Опять-таки это очевидно, что вот здесь выполняется вот это равенство,
[36:44.120 --> 36:49.720]  потому что в чем отличие? Здесь я первой переменной U разрешал бегать по всему S,
[36:49.720 --> 36:56.160]  так я просто возьму эту сумму, расщеплю на две суммы. В первой U равна S, во второй U не равна S.
[36:56.160 --> 37:03.720]  Но бегает по всему S-большому. Вот. Значит, дальше. Смотрите, это в точности величина потока по
[37:03.720 --> 37:14.680]  определению. Потому что величина потока это как раз сумма всех F-S-V. Вот она, в точности вот
[37:14.680 --> 37:29.760]  эта вот вещь. Так, ну а и это хотелось бы показать, что это равно 0. Значит, почему F-S без S-V, почему эта
[37:29.760 --> 37:38.680]  штука равна 0? Давайте посмотрим. Значит, на самом деле сумма по всем U из S без S-маленького,
[37:38.680 --> 37:50.800]  сумма по всем V из V-большого F-U-V. Ну извините, я знаю, что вот это вот всегда 0. Из-за третьего
[37:50.800 --> 38:06.560]  свойства. Профит. Конечно, вот оно. У нас же S-T разрез. Вот. Поэтому S-маленькое здесь,
[38:06.560 --> 38:13.240]  T-маленькое здесь. Все, поэтому смотрите, когда у меня U бегает по S без S, у меня U одновременно
[38:13.240 --> 38:18.600]  не S и не T. Потому что оно лежит в S-большом, значит, там точно T не лежит, потому что T-маленькое в
[38:18.600 --> 38:24.200]  F-T-большом. Ну и S-маленькое тоже выкинул. Поэтому все вот эти вот, ну здесь у меня поменял название,
[38:24.200 --> 38:29.560]  короче, переменной, но U бегает по всем вот этим хорошим вершинкам, V-большое без S и T,
[38:29.560 --> 38:35.040]  а V бегает просто по всем вершинам. И эта штука равна 0 в точности по третьему свойству. Все.
[38:35.040 --> 38:42.800]  Поэтому это все тоже 0. Значит, мы доказали, что F-S-T равно величине потока плюс 0. Значит,
[38:42.800 --> 38:52.240]  просто величина потока. Так, ну вроде сейчас будет перерыв, так что давайте 5 минут перерыв,
[38:52.240 --> 38:57.560]  потом продолжаем. Стерема Форда Фалкерсона. Это вот то самое обобщение, утверждение о том,
[38:57.560 --> 39:03.160]  что поток максимален, если только, если в остаточности нет пути. Так вот, следующие
[39:03.160 --> 39:15.280]  три условия эквивалентные. Следующие три условия эквивалентные. Первое, F это максимальный поток,
[39:15.280 --> 39:23.880]  то есть его величина максимальна среди всех потоков. Да, величина потока максимальна среди
[39:23.880 --> 39:35.040]  всех потоков. Второе, то самое слово про остаточную сеть. GF нет путей из S в T. Нет
[39:35.040 --> 39:50.080]  путей из S в T. И третье, величина F равна величине какого-то разреза. Существует разрез S в T такой,
[39:50.080 --> 39:59.600]  что величина F равна величине разреза S в T. Вот это вот достаточно для того, чтобы поток был максимальным.
[40:03.600 --> 40:11.320]  Доказайся, ну давайте по кругу просто, из 1 в 2. На самом деле из 1 в 2 я уже доказал,
[40:11.320 --> 40:19.000]  потому что если поток максимален, но при этом есть какой-то путь в остаточной сети,
[40:19.000 --> 40:23.680]  то я могу по нему протолкнуть единичку потока. Поток увеличится, значит исходный был мне
[40:23.680 --> 40:37.880]  максимальный. Если F максимальный, а в GF есть путь, то F можно увеличить.
[40:37.880 --> 40:46.400]  Можно просто протолкнуть единичку потока по тому самом пути. Поток, очевидно, увеличится на ту
[40:46.440 --> 40:56.120]  самую единичку. И значит исходный поток максимальным быть не мог. Дальше из 2 в 3. Если нет пути из S в T в
[40:56.120 --> 41:03.040]  остаточной сети, то есть разрез, равный по величине потоку. Ну раз в этом письмаре существует,
[41:03.040 --> 41:10.320]  давайте его конструктивно построим. Я скажу, что S большое – это все вершины,
[41:10.320 --> 41:24.280]  достижимые из S маленького в нашей остаточной сети. Достижимые из S маленького в нашей остаточной
[41:24.280 --> 41:37.800]  сети GF. Ну, соответственно, T – это все остальное. Значит, понятно, что это разрез. Ну, поскольку
[41:37.800 --> 41:41.520]  выполняются все необходимые свойства, S маленькое в S большом, T маленькое, очевидно,
[41:41.520 --> 41:46.440]  в T большом, потому что если бы T маленькое было в S большом, то у меня был бы путь. Ну, а поскольку
[41:46.440 --> 41:52.840]  она недостижима, то обязательно T маленькое в T большом. Ну и из вот этого определения очевидно,
[41:52.840 --> 41:59.560]  что их объединение дизюнктно дает в остаточности V. Я хочу доказать, что величина этого конкретного
[41:59.560 --> 42:08.440]  разреза равна величине потока. Вот у меня даже нарисован какой-то разрез.
[42:08.440 --> 42:32.120]  Смотрите, давайте посмотрим на все ребра, ведущие из S большого в T большое. Все эти ребра имеют
[42:32.120 --> 42:38.560]  нулевую капасти в остаточной сети, потому что на самом деле в остаточной сети нет ни одного
[42:38.560 --> 42:44.760]  такого ребра, поскольку вот где-то здесь была S маленькая, это все достижимые, это все недостижимые
[42:44.760 --> 42:49.560]  из S маленького. Значит, на самом деле таких ребров слева направо, но их как бы нет, в остаточной
[42:49.560 --> 42:58.240]  сети их нету. А это в точности означает, что у них нулевое капасти. Да, потому что мы удаляем,
[42:58.240 --> 43:03.680]  мы не проводим в остаточности в точности ребра, имеющие нулевую капасти. Поэтому для любой пары
[43:03.680 --> 43:12.360]  U из S, V из T мы на самом деле имеем, давайте напишем, что если U из S, V из T, то мы на самом
[43:12.360 --> 43:18.000]  деле имеем, что остаточная капасти слева направо равно нулю, потому что мы как раз только такие
[43:18.000 --> 43:26.040]  ребра не проводим в GF. А что это означает? Что такое CF? Это на самом деле обычная капасти,
[43:26.400 --> 43:35.160]  минус поток. Получается, что для любого ребра U, V слева направо мы имеем равное значение
[43:35.160 --> 43:51.040]  capacity и потока. Вот. Ну все, а дальше получается, что если мы это просуммируем, то мы получим
[43:51.040 --> 43:55.080]  величину разреза. Если мы это просуммируем, мы получим величину потока через разрез, но она
[43:55.080 --> 44:05.360]  по утверждению равна просто величине потока. Вот это? Ну потому что, смотрите, давайте рассмотрим
[44:05.360 --> 44:09.880]  просто любую вершину отсюда, любую вершину отсюда. Между ними, ну как бы по договоренности,
[44:09.880 --> 44:15.320]  есть ребро. Если ребро нет, то оно имеет нулевую капасти. Вот я в этом графе остаточном GF,
[44:15.320 --> 44:20.560]  остаточной сети, рассматриваю все такие ребра. Если там есть ребро положительной capacity,
[44:20.560 --> 44:25.840]  то это бред, потому что левые вершины достижены, правые не достижены. Значит ребер слева направо,
[44:25.840 --> 44:30.440]  как бы положительной capacity быть не может. Потому что иначе, если бы оно было, то я мог бы еще вот
[44:30.440 --> 44:37.560]  эту вершину посетить. Значит не все нулевой capacity, значит вот. Все, я теперь это суммирую по всем
[44:37.560 --> 44:51.600]  УССВСТ. Получаю, слева получаю величину разреза, как сумму по всем УССВСТ СУВ. Здесь аналогичная
[44:51.600 --> 45:03.600]  сумма потоков. Это по определению в точности равно FST, и это по утверждению равно величине потока.
[45:03.600 --> 45:16.880]  Вот он. Профит. Мы предъявили некий конкретный разрез, величина которого равна величине потока.
[45:16.880 --> 45:28.040]  Вот оно. Доказали. Так, ну теперь из 3 в 1.
[45:28.040 --> 45:49.400]  Из 3 в 1. Если поток равен разрезу, то поток максимальный. Здесь на самом деле нужно сделать
[45:49.400 --> 46:01.600]  следующее простое наблюдение. Давайте напишу его словами. Величина любого потока не превосходит
[46:01.600 --> 46:23.760]  величины любого разреза. По следующим опять же очень простым соображением. Значит поток равен
[46:23.760 --> 46:36.480]  потоку через разрез равен сумме нашей любимой по УССВСТ СУВ. Дальше. Поток из УВ всегда ограничен
[46:36.480 --> 46:42.480]  на капасти из УВ. Вот это первое свойство, F всегда не большим С. Поэтому здесь в сумме я могу все
[46:42.480 --> 46:52.560]  слагаемые заменить сверху на СУВ. Получится сумма по УССВСТ СУВ. Но это в точности просто
[46:52.560 --> 47:00.720]  определение величины разреза. Поэтому любой поток не больше, чем любой разрез, собственно то,
[47:00.720 --> 47:05.560]  что мне здесь написано. Величина любого потока не превосходит величины любого разреза. Значит,
[47:05.560 --> 47:12.720]  давайте я для удобства вот так визуализирую. Если я нарисую ось, там, вещественную или целочисленную,
[47:12.720 --> 47:16.920]  то у меня, смотрите, и давайте на нее нанесу все возможные величины потока и все возможные
[47:16.920 --> 47:22.560]  величины разреза. Тогда у меня потоки будут где-то вот здесь вот, а разрезы где-то вот здесь вот.
[47:22.560 --> 47:27.400]  Ну поскольку любой поток меньше либо равен любого разреза, то у меня как бы вот здесь вот все потоки
[47:27.400 --> 47:35.880]  F, величины F, а здесь величины всех разрезов ССТ. Любой отсюда не больше любого отсюда, поэтому они
[47:35.880 --> 47:41.680]  как бы так отделимы. Вот эти все слева, эти все справа. Но если вдруг оказалось, смотрите,
[47:41.680 --> 47:48.320]  что он говорит третий пункт, что какой-то поток равен какому-то разрезу, тогда на самом деле вот
[47:48.320 --> 47:54.360]  эти вот множества пересекаются в единственной точке. Вот здесь есть какая-то засечка, которая
[47:54.360 --> 48:00.760]  одновременно и является величиной какого-то F и какого-то разреза. Ну значит, это максимальный
[48:00.760 --> 48:06.960]  поток и при этом одновременный минимальный разрез. Потому что, если они пересекаются,
[48:06.960 --> 48:12.520]  то это экстремальный элемент здесь и экстремальный элемент, короче, в обоих множествах, поэтому это
[48:12.520 --> 48:22.360]  одновременно максимальный поток и минимальный разрез. Вот, значит, если F равно какому-то разрезу,
[48:22.360 --> 48:36.680]  то F это максимальный поток, а ST это минимальный разрез. Вот и все.
[48:36.680 --> 48:52.880]  Вопросик есть?
[48:52.880 --> 49:20.840]  Ну хорошо. Да. Вот это? Вот это. Ну как? Понятно, что F всегда не больше чем C. Нет, не стало. У нас
[49:21.160 --> 49:25.920]  всегда выполняется. У нас F всегда не больше чем C. Оттого, что F отрицательно, смотрите, это вы вот
[49:25.920 --> 49:30.320]  опять к этой картинке. Если у меня было какое-то нормальное ребро у В, не знаю, с капастию,
[49:30.320 --> 49:36.800]  например, два, по которому я опустил дницу потока. Что это значит? Значит, что я как бы на самом деле
[49:36.800 --> 49:44.720]  ввожу обратное ребро с нулевой капаститию и потоком минус один, но минус один уже не больше чем ноль.
[49:44.720 --> 49:54.920]  Вот и все. У нас просто определение потока такое, что вот здесь всегда меньше чем C. А
[49:54.920 --> 50:00.560]  остаточная капастити здесь единица, потому что если я вычту минус 1 из нуля, капастити минус
[50:00.560 --> 50:05.120]  поток, у меня получится единица. Поэтому в остаточной сети у меня будет вот здесь вот
[50:05.120 --> 50:11.120]  ребро один и здесь ребро один. Потому что вот это вот ребро на самом деле имеет остаточную
[50:11.120 --> 50:17.000]  капастити, значит, что я могу отменить вот здесь единицу потока. Могу направить ее из
[50:17.000 --> 50:21.600]  конца в начало, тем самым я как бы отменяю вот эту единичку потока, которую пустил сначала в конец.
[50:21.600 --> 50:34.040]  Поэтому это просто свойство потока, что F не больше. Хорошо. Ну и отсюда, собственно,
[50:34.040 --> 50:47.800]  получаем простейший алгоритм Форда Фалкерсона, который просто делает следующее. Пока в GF есть
[50:47.800 --> 50:53.480]  какой-то путь из S в T, пусти по нему единичку потока, ну или там сколько влезет потока и
[50:53.480 --> 50:58.280]  перестрой сети. Так делаем пока, пока есть, собственно, путь в остаточной сети.
[50:58.280 --> 51:15.000]  Пока в GF есть путь из S в T, ну давайте я скажу следующее, что пусть X это минимальная из
[51:15.000 --> 51:26.760]  остаточных капастий на этом пути, минимальная из CF на этом пути. Дальше мы, собственно,
[51:26.760 --> 51:40.520]  по этому пути проталкиваем X потока на этом пути. Давайте добавляем X единиц потока.
[51:40.520 --> 51:49.640]  Вот. Ну и всё, перестраиваем GF. Перестроить GF.
[51:49.640 --> 52:12.760]  Пример. Давайте рассмотрим такую сеть. Здесь все капасти единичные. Чтобы не загружать картинку,
[52:12.760 --> 52:18.760]  все капасти единичные. Значит, как может работать алгоритм Форда Фалкерсона? Например, может
[52:18.840 --> 52:25.880]  сработать так. Он берет, находит вот этот вот путь, проталкивает по нему единицу потока. Что
[52:25.880 --> 52:31.160]  будет после этого? После проталкивания единички потока у меня вот эти все ребра остаются,
[52:31.160 --> 52:35.320]  но смотрите, у меня же на самом деле всегда вот так вот мысленно, надо не забывать,
[52:35.320 --> 52:40.920]  что всегда есть обратные ребра с нулевой капастью. В момент, когда я проталкиваю обычный поток по
[52:40.920 --> 52:45.480]  нормальному ребру, у меня на обратном ребре остается поток минус один, так? Потому что если
[52:45.480 --> 52:50.720]  здесь один, то здесь минус один по антисимметричности. И как я вот здесь пытался объяснить, у меня
[52:50.720 --> 52:55.640]  получается, что возникает обратный ребро с единичной капасти. Потому что если здесь
[52:55.640 --> 53:02.000]  капасти ноль, а поток минус один, то их разность будет единица. Поэтому после проталкивания здесь
[53:02.000 --> 53:07.880]  единицы потока у меня граф будет такой. Значит, вот есть S, вот есть T. Эти ребра будут вот такими
[53:07.880 --> 53:16.360]  обратными, а здесь они останутся прямыми. Вот, и смысл этих ребров в том, что я могу как бы отменить
[53:16.360 --> 53:21.000]  единицу потока, которую я опустил по этому ребру. То есть если надо, я мог бы как-нибудь использовав
[53:21.000 --> 53:26.000]  это ребро, пуская по нему единицу потока, это то же самое, что я отменяю вот эту единицу,
[53:26.000 --> 53:31.240]  которая течет слева направо. Вот, но здесь это мне не понадобится, ну просто формально граф вот так
[53:31.240 --> 53:47.040]  перестроится. Потому что на самом деле мы путь какой-то ищем, путь из S в T, а путь из S в T это
[53:47.040 --> 53:52.840]  всегда какой-то маршрут из S в T. И если мы как бы сложим все изменения, то на всех промежутных
[53:52.840 --> 53:57.760]  вершинах у нас ничего не изменится, а из S начнет что-то вытекать, и в T начнет что-то втекать.
[53:57.760 --> 54:05.000]  Поэтому сумма как раз увеличится на то, сколько мы пустили здесь. Ну это порисовать на самом деле
[54:05.000 --> 54:11.400]  надо просто. Вот, значит дальше я могу найти такой путь, протолкнуть здесь еще одну единичку потока,
[54:11.400 --> 54:17.480]  и получится, что я уже нашел, что за первый раз это вторая. После этого вновь то же самое,
[54:17.480 --> 54:21.800]  у меня вот здесь возникает обратное ребро, капасти 1, здесь обратное ребро, капасти 1,
[54:21.800 --> 54:34.040]  граф становится таким. Вот. Ну здесь уже видно, что из S в T никак попасть нельзя. Ну просто даже
[54:34.040 --> 54:38.600]  из S нет ни одного исходящего ребра, поэтому мы нашли максимальный поток. Максимальный поток
[54:38.600 --> 54:47.240]  очень простой, вот здесь вот надо пустить единичку потока, и здесь единичку. Так, это он мог работать
[54:47.240 --> 55:08.320]  вот так, а мог работать чуть хуже, но тоже корректно. Ну что, мог взять и внезапно найти
[55:08.320 --> 55:16.360]  такой вот путь. Вот такой. Я же никак не специфицирую, какой именно мы путь находим,
[55:16.360 --> 55:22.000]  просто какой-то, нам останется в стих какой-нибудь путь. Вот он мог найти вот такой вот путь. Это не
[55:22.000 --> 55:27.640]  страшно, мы пускаем здесь единичку потока, давайте построим, как теперь выглядит наша сеть. Это ребро
[55:27.640 --> 55:34.560]  само по себе удаляется, потому что на нем остается нулевая капазиция, но возникает обратное. Это остается,
[55:34.560 --> 55:39.240]  здесь то же самое, ребро сверху вниз исчезает, потому что оно насытилось, там стало, ну как бы там
[55:39.240 --> 55:44.560]  нельзя больше ничего пустить, но возникает снизу вверх, потому что на нем 0 минус минус 1 это единица.
[55:44.560 --> 55:49.960]  Вот, ну здесь остается, и это тоже переориентируется справа налево.
[55:49.960 --> 56:00.000]  Теперь смотрите, вот тут как раз отмена потока происходит. Теперь в этой сети опять есть путь
[56:00.000 --> 56:08.240]  из SFT, вот он. Использую вот это вот обратное ребро, которое у меня появилось из-за того,
[56:08.240 --> 56:14.200]  что я, ну по факту на самом деле я отменяю вот здесь единичку потока. Да, у меня есть путь из
[56:14.200 --> 56:20.280]  SFT, задействующий вот это центральное ребро, я могу пустить по нему единицу потока, и остаточная сеть
[56:20.280 --> 56:33.040]  будет, ну видимо, такая же. И по факту, что произошло, я пустил здесь единицу потока, и здесь единицу
[56:33.040 --> 56:37.480]  потока. Центральная на самом деле съелась сама собой, потому что сверху вниз и снизу вверх я
[56:37.480 --> 56:41.440]  пустил по единичке, они сами уничтожились, и получился такой же поток, у меня на самом деле
[56:41.440 --> 56:50.240]  единица течет вот здесь, единица течет вот здесь. Вот такой пример работы, когда какие-то,
[56:50.240 --> 56:53.960]  грубо говоря, ошибки, которые допускает наш алгоритм, используют какие-то неправильные
[56:53.960 --> 56:59.240]  ребра, он потом сам их может пофиксить, отменив поток по неправильному ребру. Вот в чем мораль
[56:59.240 --> 57:04.040]  вот этого ребра, что даже если я его как бы напрасно использую, я могу его отменить и добавить
[57:04.040 --> 57:18.000]  единичку там, где надо. Вот. Так, ну еще примерчик. Давайте то же самое, только величины побольше,
[57:18.000 --> 57:26.360]  короче, капасти большие я нарисую здесь. Вот, представьте, что здесь капальство что-то типа 10
[57:26.360 --> 57:36.480]  9, а здесь единица. Ну понятно, умный алгоритм бы сказал следующее, надо пустить вот здесь вот 10
[57:36.480 --> 57:42.920]  9 потока, здесь 10 9 потока, мы найдем максимальный. Конечно, больше чем 2 на 10 9 пустить нельзя. Но
[57:42.920 --> 57:48.600]  если наш алгоритм глупенький, ну и как-нибудь у него неправильные ребра упорядочены, и он делает
[57:48.600 --> 57:53.280]  какой-то DFS такой странный, он может на самом деле делать следующее, он вот здесь отпускает единичку
[57:53.280 --> 57:58.880]  потока, потом это ребро инвертирует. Пускать вот здесь единичку потока, опять ребро инвертирует,
[57:58.880 --> 58:06.680]  так делать 2 на 10 9 раз. Поэтому на самом деле лучше, что можем сказать про симптотику,
[58:06.680 --> 58:16.760]  это что-то типа f умножить на e, где f это собственно та самая величина максимального потока,
[58:16.920 --> 58:26.440]  но e это, грубо говоря, то, за сколько работает DFS, потому что по факту внутри мне нужен только
[58:26.440 --> 58:34.120]  DFS, чтобы найти какой-то путь из SFT. Вот, и в случае, когда у вас бывают большие capacity,
[58:34.120 --> 58:39.120]  и соответственно, бывает большой поток, вам возможно придется делать очень много
[58:39.120 --> 58:45.000]  итерации в вашем алгоритме, и это ну как бы не фиксится. То есть если мы говорим, что наш путь
[58:45.000 --> 58:49.760]  произвольным образом выбирается, то вот пожалуйста пример, где он может работать 2 на 10 9 итерации,
[58:49.760 --> 59:08.280]  хотя граф очень маленький. Вот, так это понятно пока? Ну ладно, тогда давайте это фиксить как-то.
[59:08.280 --> 59:19.280]  Да, тут возникают, конечно, возникают обратные, которые постепенно наращивают capacity. Сначала 1,
[59:19.280 --> 59:24.000]  потом 2, потом 3. Да, ну потому что когда я здесь пустил единичку потока, у меня появилась обратная
[59:24.000 --> 59:28.000]  1, потому что я умею отменять эту единицу потока. Потом, когда пустил вторую единицу потока,
[59:28.000 --> 59:33.360]  здесь возникло на самом деле не еще одно, а просто увеличивается capacity здесь, ну и так далее. Поэтому
[59:33.360 --> 59:37.400]  они тоже конечно возникают, но они все равно не используются. И главное, что вот здесь вот
[59:37.400 --> 59:46.880]  переключается это ребро. Вот, хорошо. Так вот как это можно пофиксить? Как можно избавиться от
[59:46.880 --> 59:59.680]  зависимости от лишней потока? Очень просто. Называется алгоритм Эдман Сакарпа. И он отличается
[59:59.680 --> 01:00:04.280]  от алгоритма Форда Фалгрессона только тем, что вместо произвольного пути мы выбираем кратчайший
[01:00:04.280 --> 01:00:24.480]  путь почт лури обер. В GF всегда выбираем кратчайший путь, кратчайший почт лури обер.
[01:00:24.480 --> 01:00:41.720]  Еще проще, мы заменяем DFS на BFS. Если раньше я искал какой-нибудь путь с помощью DFS,
[01:00:41.720 --> 01:00:47.960]  каким-нибудь обходом DFS, например, то теперь вместо этого я нахожу кратчайший путь с помощью
[01:00:47.960 --> 01:00:53.560]  BFS и по нему пускаю столько поток, сколько могу. И тогда оказывается, что здесь асимптотика
[01:00:53.560 --> 01:01:01.440]  сразу улучшается до вот такой. Ну, если это можно назвать улучшением. Но асимптотика будет вот
[01:01:01.440 --> 01:01:15.280]  такая. Мы по крайней мере избавляемся от зависимости от капастей. Давайте попробуем доказать,
[01:01:15.280 --> 01:01:20.360]  почему асимптотика будет такая. Понятное дело, корректность этого алгоритма очевидна,
[01:01:20.360 --> 01:01:27.320]  потому что это по факту модифицированный Форт Фалкерсон, который просто пока есть поток в GF,
[01:01:27.320 --> 01:01:31.880]  пока есть путь в GF, пускает по нему что-нибудь. Понятно, что он корректен, поэтому в конце
[01:01:31.880 --> 01:01:35.160]  обязательно будет максимальный поток. Почему он работает за столько? То есть единственный вопрос
[01:01:35.160 --> 01:01:44.600]  это асимптотика. Почему мы работаем за столько? Но давайте попробовать доказывать. Для этого
[01:01:44.600 --> 01:01:57.000]  надо будет постараться. Шлема первая, пусть F и F', это два последовательных потока в алгоритме
[01:01:57.000 --> 01:02:11.760]  Эдманса Карпа. В алгоритме Эдманса Карпа. Понятно, он у нас работает итеративно. Каждый раз
[01:02:11.760 --> 01:02:16.920]  восторженности находит в кратчайший путь и по нему пускает поток. Вот пусть сначала был F,
[01:02:16.920 --> 01:02:29.960]  а после очередной итерации стал F'. Пусть D от V это кратчайшее расстояние в графе GF от S
[01:02:29.960 --> 01:02:41.400]  до V, ну а D' это соответственно расстояние в графе GF' от S до V. Понятно, да, у нас Эдманс Карп
[01:02:41.400 --> 01:02:49.800]  работает с расстояниями невзвешенными. Давайте вот определим D от V это расстояние в оснащенности
[01:02:49.800 --> 01:03:00.120]  GF', D' это расстояние в оснащенности GF'. Вот тогда я утверждаю, что для любой вершины D от V не
[01:03:00.120 --> 01:03:10.240]  больше, чем D' от V. То есть в процессе работы Эдманс Карпа расстояния только увеличиваются,
[01:03:10.240 --> 01:03:15.120]  ну не строго увеличиваются. То есть либо остаются, либо остаются больше. Вот одну итерацию к следующей
[01:03:15.120 --> 01:03:23.560]  у меня может произойти только возрастание. Доказательства пусть не так. То есть пусть есть
[01:03:23.560 --> 01:03:26.680]  какие-то вершины, для которых это не нравится, в другую сторону достигается. То есть здесь будет
[01:03:26.680 --> 01:03:41.360]  строго больше. D от V строго больше, чем D' от V. Тогда давайте выберем такую V, ну для которой верно отрицание
[01:03:41.360 --> 01:03:47.720]  этого нашего неравенства, то есть D от V больше, чем D' от V. Для которой D' от V минимально возможно.
[01:03:47.720 --> 01:04:01.900]  То есть, грубо говоря, смотрите, у меня есть, у меня возможно есть много вершин, для которых это
[01:04:01.900 --> 01:04:07.920]  неравенство нарушается. Давайте из них всех, то есть из всех, для которых верно вот это, вот возьмем
[01:04:07.920 --> 01:04:14.080]  то для которого D' от V минимально. Понятно, это может достигаться, вот это вот неравенство может
[01:04:14.080 --> 01:04:17.640]  достигаться на многих вершинах, но из них всех я возьму такое, что дж-стрих минимально
[01:04:17.640 --> 01:04:25.480]  возможен. Из всех таких выбираю вершину с минимальным дж-стрихом от v. Тогда, ну
[01:04:25.480 --> 01:04:33.400]  давайте рассмотрим кратчайший путь от s до v в графе gf-стрих. Рассмотрим
[01:04:33.400 --> 01:04:50.080]  кратчайший путь от s до v в gf-стрих. Вот s, вот v, это было все в графе gf-стрих.
[01:04:50.080 --> 01:05:02.760]  Ну, во-первых, я утверждаю, что v точно не s, потому что для вершинки s у меня
[01:05:02.760 --> 01:05:10.200]  всегда d от s равно d-стрих от s равно 0. Понятно, расстояние от вершины до
[01:05:10.200 --> 01:05:14.640]  само себя это 0, поэтому для вершины s это неравенство не выполняется. Значит,
[01:05:14.640 --> 01:05:19.080]  она точно не участвует вот в том множестве v-ш, которые я выбираю, поэтому v это
[01:05:19.080 --> 01:05:24.920]  точно не s. Значит, на пути от s до v есть какая-то предыдущая вершина u, раз это
[01:05:24.920 --> 01:05:29.520]  различные вершины, то есть какая-то предыдущая u, которая лежит на пути от
[01:05:29.520 --> 01:05:44.840]  s до v. Давайте ее рассмотрим. Так, значит, что про нее мы можем сказать? Смотрите,
[01:05:44.840 --> 01:05:49.440]  поскольку она лежит на кратчайшем пути от s до v, я смело могу написать такое
[01:05:49.440 --> 01:05:59.280]  равенство. d-стрих от u плюс 1 равно d-стрих от v. Ну, это почти очевидно, вот он кратчайший
[01:05:59.280 --> 01:06:05.040]  путь от s до v, это в частности кратчайший путь от s до u плюс одно ребро. Значит,
[01:06:05.040 --> 01:06:09.560]  d-стрих от u плюс 1 равно d-стрих от v. Просто я взял кратчайший путь до u, добавил одно
[01:06:09.560 --> 01:06:16.120]  ребро, получил кратчайший путь до v. Это первое наблюдение. Второе наблюдение, что для u,
[01:06:16.120 --> 01:06:23.760]  вот из этого следует, что для u это выполняться не может. То есть для u обязательно выполняется
[01:06:23.760 --> 01:06:30.320]  вот такое неравенство. Потому что иначе, если бы для u выполнялась такое же неравенство,
[01:06:30.320 --> 01:06:38.240]  как для v, то из вот этого следовало бы, что d-стрих от u меньше, чем d-стрих от v. Значит,
[01:06:38.240 --> 01:06:42.840]  раз это меньше, и это выполняется, то я вот здесь v неправильно определил, мне надо было бы
[01:06:42.840 --> 01:06:51.360]  брать вместо v u. Ну, поскольку я взял v правильно, то вот этого неравенства обязано выполняться,
[01:06:51.360 --> 01:06:58.240]  иначе я должен был бы взять другую вершину в качестве v. Так как d-стрих от v минимально,
[01:06:58.240 --> 01:07:22.440]  среди вершин с d-стрих от v меньше d от v. Вот. Хорошо, вот есть такие два наблюдения. Теперь
[01:07:22.440 --> 01:07:35.200]  давайте зададимся вопросом. Что ребро uv делает в графе gf-стрих? Откуда на том взялось? Откуда
[01:07:35.200 --> 01:07:54.880]  ребро uv присутствует в графе gf-стрих. Значит, ответ первый, вариант первый. Оно было в предыдущем
[01:07:54.880 --> 01:08:11.080]  графе, в графе gf, и оно осталось после пропускания потока. Ну, то есть как бы вот я смотрю на
[01:08:11.080 --> 01:08:18.080]  конкретную пару uv. Вот я знаю, что в этом графе gf-стрих тут есть ребро из uv. Вот вопрос, а было ли
[01:08:18.080 --> 01:08:22.840]  оно в предыдущем графе? Было ли оно в gf? Два варианта ответа, либо да, либо нет. Давайте первый
[01:08:22.840 --> 01:08:31.120]  случай, когда оно было ребро. uv было в графе gf. То есть в графе gf тоже есть ребро из uv. Точно
[01:08:31.120 --> 01:08:40.520]  также как в графе gf-стрих. Что это значит? Это значит, например, что d от v не больше d от u
[01:08:40.520 --> 01:08:58.120]  плюс 1. Ну, вроде понятно. Потому что если есть какое-то конкретное ребро, то дойти до конца этого
[01:08:58.120 --> 01:09:03.240]  ребра можно точно используя не больше, чем вот столько вот столько ребер. Я могу сначала дойти
[01:09:03.240 --> 01:09:11.080]  до u, а потом добавить одно ребро в конец. Здесь я пишу обычные d, потому что d это расстояние в gf,
[01:09:11.080 --> 01:09:18.480]  не в gf-стрих, а в gf. Вот. Ну и теперь я утверждаю, что вот эти вот все неравенства, которые я написал,
[01:09:18.480 --> 01:09:24.000]  на самом деле ведут к противоречию. Давайте попробуем это продолжить. Что такое d от u
[01:09:24.000 --> 01:09:35.960]  плюс 1? Это не больше, чем d-стрих от u плюс 1, а d-стрих от u плюс 1 это d-стрих от v. То есть отсюда
[01:09:35.960 --> 01:09:56.200]  получилось, что d от v не больше, чем d-стрих от v противоречия. Потому что вот. Значит, используя все неравенства,
[01:09:56.200 --> 01:10:01.880]  которые мы написали, мы пришли к противоречию, поэтому первый случай быть не может. Случай второй.
[01:10:01.880 --> 01:10:25.160]  Случай второй. Ребра uv вот в предыдущей осадочности не было. Уv не было в gf. Что это значит?
[01:10:25.160 --> 01:10:33.520]  Почему его не было в gf, но оно каким-то образом оказалось в gf-стрих? Скажите мне, пожалуйста,
[01:10:33.520 --> 01:10:38.200]  откуда ребро могло появиться в осадочной сети. То есть его не было на предыдущем шаге, но теперь оно
[01:10:38.200 --> 01:10:48.360]  есть в gf-стрих. Да, ребро появиться могло только если по обратному к нему пустили поток. То есть
[01:10:48.360 --> 01:10:56.680]  вот uv не было в gf, значит было vu, и мы по vu пустили сколько-то потока, потому что только в этом
[01:10:56.680 --> 01:11:14.880]  случае могло появиться обратное к нему ребро uv. Значит, чтобы uv появилось в gf-стрих, мы должны
[01:11:14.880 --> 01:11:32.560]  были протолкнуть поток по обратному ребру. Мы должны были протолкнуть поток по vu. Значит,
[01:11:32.560 --> 01:11:42.560]  ребро vu не просто было в графе gf, но еще и по нему мы пустили поток. Значит, это не просто какое-то
[01:11:42.560 --> 01:11:49.160]  ребро в gf, но это какое-то ребро лежащее на кратчайшем пути из s в t. А раз так ребро лежащее на кратчайшем
[01:11:49.160 --> 01:11:56.280]  пути лежащее на кратчайшем пути из s в t, то значит мы можем смело написать, что d от v плюс 1 равно du.
[01:11:56.280 --> 01:12:06.000]  Еще раз, то есть это не абы какое ребро в gf, а такое ребро, по которому мы пустили поток,
[01:12:06.000 --> 01:12:13.440]  значит это ребро на кратчайшем пути от s до t. Но раз это ребро на кратчайшем пути, то кратчайшее
[01:12:13.440 --> 01:12:19.120]  станет до v, на единицу меньше кратчайшее станет до u. Поэтому вот такое такое равенство можно
[01:12:19.120 --> 01:12:27.680]  писать. Ну а дальше я скажу, что опять какие-то противоречия будут. Давайте d от u напишем,
[01:12:27.680 --> 01:12:42.760]  что это не больше d штриха от u. Дальше d штрих от u, это d штрих от v минус 1. Так,
[01:12:42.760 --> 01:12:47.840]  сейчас я, наверное, как-нибудь получше нарисую, все. Давайте туда перейду.
[01:12:47.840 --> 01:13:14.720]  Еще раз, у меня вот там вот написано, что d от u не больше d штрих от u. Дальше d штрих
[01:13:14.720 --> 01:13:18.280]  от u равно d штрих от v минус 1, я верхнее этого равенства переношу единичку направо.
[01:13:18.280 --> 01:13:31.960]  Так, ну собственно все, вот это мне нужно. Получается, смотрите, что, что d от v меньше
[01:13:31.960 --> 01:13:42.440]  либо равно d штрих от v минус 2. А мы предполагали, что d от v больше, чем d штрих от v. Ну опять
[01:13:42.440 --> 01:13:54.200]  противоречие. Да, d от v больше, чем d штрих от v. А вот оно, вот оно, и здесь единичку просто
[01:13:54.200 --> 01:14:06.000]  перенес туда. Вот, не может число быть больше, чем другое, если оно не больше, чем оно минус 2.
[01:14:06.000 --> 01:14:13.720]  Опять противоречие. Значит, ни один из случаев быть не может, поэтому наше исходное предположение
[01:14:13.720 --> 01:14:19.640]  неверно, значит, мы все доказали. То есть вот это вот v вот с этим условием существовать не могла,
[01:14:19.640 --> 01:14:33.200]  ну поэтому мы доказали то, что хотели. Так, окей. Хорошо, значит, тогда отсюда лемма вторая.
[01:14:33.200 --> 01:14:57.840]  Лемма вторая. Значит, каждое ребро, увы, может насытиться, может насытиться не больше от v раз.
[01:14:57.840 --> 01:15:08.880]  Ну что такое насытиться? Это когда ребро не было насыщенным, а стало насыщенным. То есть раньше
[01:15:08.880 --> 01:15:17.200]  по нему тек поток меньше, чем его capacity, а после вот очередной итерации поток стал равен capacity,
[01:15:17.200 --> 01:15:24.280]  то есть ребро насытилось, по нему течет максимально возможный поток. Так вот,
[01:15:24.280 --> 01:15:29.000]  количество насыщений не превосходит от v. Для каждого конкретного ребра не больше, чем от v раз
[01:15:29.000 --> 01:15:34.760]  он насыщается. Ну почему? Давайте вообще поймем, как какое-то ребро может насытиться несколько раз.
[01:15:34.760 --> 01:15:43.160]  Это значит, что я вот взял очередную итерацию. Эта вот скарпа, наше ребро, увы, насытил. Вот там,
[01:15:43.160 --> 01:15:47.880]  давайте рассмотрим первый раз, когда он насыщается. Вот какой-то конкретный раз мы пустили по этому пути
[01:15:47.880 --> 01:15:53.560]  такой поток, что это ребро стало насыщенным. Дальше, чтобы оно стало насыщенным вновь,
[01:15:53.560 --> 01:15:59.240]  мне нужно сначала его раз насытить, то есть сделать его ненасыщенным. Значит,
[01:15:59.240 --> 01:16:03.680]  отменить поток по нему, то есть на самом деле пустить какой-то вот такой вот поток. То есть
[01:16:03.680 --> 01:16:08.360]  на самом деле пустить поток по обратному ребру. После этого ребро, увы, опять появляется в нашей
[01:16:08.360 --> 01:16:14.200]  сети, и я могу его вновь насытить. То есть чтобы насытить ребро еще раз, мне нужно сначала снять
[01:16:14.200 --> 01:16:19.400]  с него какой-то поток и потом еще добить до максимального. То есть получается, что чтобы
[01:16:19.400 --> 01:16:33.560]  насытить ув, насытить ув дважды, нужно сначала, нужно насытить его, потом пустить поток по обратному
[01:16:33.560 --> 01:16:46.840]  ребру, потом опять его насытить. Давайте напишем, насытить ув, потом пустить поток пву,
[01:16:46.840 --> 01:16:53.160]  потом опять насытить ув.
[01:17:07.480 --> 01:17:16.440]  Но смотрите, насыщение ув происходит, когда я когда-то насытил ув, потом пустил поток по
[01:17:16.440 --> 01:17:29.800]  обратному ребру, потом его опять насытил. Значит, в этот момент d от u плюс 1 это d от v, в этот
[01:17:29.800 --> 01:17:44.840]  момент d штрих от v плюс 1 это d штрих от u, и в этот момент d2 штриха от u плюс 1 равно d2 штриха от v.
[01:17:44.840 --> 01:17:51.600]  Ну потому что насыщение и проталкивание потока происходит только если это ребро лежит на
[01:17:51.600 --> 01:17:56.520]  кратчажем пути от s до t, поэтому вот такие вот у меня получается равенства на расстояние от s.
[01:17:56.520 --> 01:18:10.200]  Вот, ну смотрите, вот если здесь было какое-то d от u, значит здесь у меня d от u плюс 1, здесь хотя бы d от u
[01:18:10.200 --> 01:18:16.760]  плюс 1, потому что я знаю, что по первой лемме между итерациями расстояние может только вырасти,
[01:18:16.760 --> 01:18:21.920]  если здесь до v было такое расстояние, то здесь до v будет хотя бы такое расстояние, по первой
[01:18:21.920 --> 01:18:30.400]  лемме у меня d только только возрастает, значит здесь хотя бы d от u плюс 2. Две минуты и заканчиваем,
[01:18:30.400 --> 01:18:37.800]  сори. Значит, смотрите, получилось, что к моменту, когда вот эта вот вершина u может насытиться во
[01:18:37.800 --> 01:18:44.480]  второй раз, у меня расстояние до нее выросло хотя бы на двойку. Если изначально было d от u при
[01:18:44.480 --> 01:18:51.040]  первом насыщении, то ко второму насыщению d будет хотя бы d от u плюс 2. Вот по этим неравенствам,
[01:18:51.040 --> 01:18:57.080]  потому что d всегда возрастает и при проходе по ребру обратно d еще раз выросло, получается,
[01:18:57.080 --> 01:19:04.760]  что между двумя насыщениями d выросло хотя бы на два. Ну а сколько раз мы можем вот это d
[01:19:04.760 --> 01:19:09.200]  увеличивать на два? Понятно, что d всегда не превосходит, скажем, числа вершин, числа вершин
[01:19:09.200 --> 01:19:16.280]  минус 1 на самом деле. Ну и получается, что каждое насыщение соответствует увеличению d хотя бы
[01:19:16.280 --> 01:19:27.480]  на два. Значит, насыщение на самом деле максимум v пополам. Значит, насыщение v соответствует
[01:19:27.480 --> 01:19:43.680]  увеличению d от v, d от u хотя бы на два. Ну и при этом понятно, что d от u не больше,
[01:19:43.680 --> 01:19:55.640]  чем v минус 1. Значит, насыщение не больше, чем, ну, примерно v минус 1 пополам. Но главное,
[01:19:55.640 --> 01:20:09.040]  что это все от v. Что и требовалось. Вот. Ну все, таким образом, вторую лиму доказали,
[01:20:09.040 --> 01:20:13.280]  а завершу давайте уже в следующий раз. Спасибо за внимание, извините, что задержал.
