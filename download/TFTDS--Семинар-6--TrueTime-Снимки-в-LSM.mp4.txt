[00:00.000 --> 00:13.640]  Давайте по порядку к базе данных придем. Итак, мы говорим про задачу про алгоритм ABD,
[00:13.640 --> 00:29.760]  в котором нам нужно было реплицировать ячеек памяти, ну или целый диапазон ячеек
[00:29.760 --> 00:36.200]  памяти. И вы должны были эту задачу решить, ну по крайней мере, используя логические часы.
[00:36.200 --> 00:39.880]  Чтобы решить задачу используя логические часы, никакого ума не надо, это позорное решение.
[00:39.880 --> 00:49.480]  Если вы им ограничились, то никуда не годится, нужно продолжать. Это был первый пункт, чтобы
[00:49.480 --> 00:55.480]  просто освоиться с фреймворком, чтобы скопировать этот кусок, еще один, вставить его. Ну и по
[00:55.480 --> 01:00.520]  возможности, все это организовались в две функции, конечно. Если у вас RPC call повторяется в
[01:00.520 --> 01:06.920]  программе больше, чем два раза, то вы ошиблись где-то, что где-то вы пошли не туда. Кроме того,
[01:06.920 --> 01:11.360]  еще один простой критерий, как понять, что вы пошли не туда. У вас в структуре write timestamp
[01:11.360 --> 01:17.040]  по-прежнему одно поле. Вот если у вас там одно поле, то как бы задумайтесь, зачем вообще структура
[01:17.040 --> 01:24.920]  нужна для того, чтобы объявить один 64-битный int. Вот, убедитесь, что все упорядочивание в вашем коде
[01:24.920 --> 01:30.400]  выполняется, то есть у вас есть только write timestamp с оператором меньше, или какими-то другими
[01:30.400 --> 01:35.080]  операторами сравнения, и вы сравниваете только эти timestamps, потому что в конце концов весь
[01:35.080 --> 01:40.200]  ordering в алгоритме, то есть упорядочивание всех операций, выполняется только по timestamp. Если вы
[01:40.200 --> 01:44.520]  где-то сравниваете timestamp, а потом еще что-нибудь, то задумайтесь, что вы делаете что-то странное,
[01:44.520 --> 01:51.280]  потому что сравнение должно быть только на timestamp. Если вы делаете так, то изменитесь срочно и
[01:51.280 --> 01:57.760]  перепишите свой код, чтобы там остался только один простой оператор меньше. Это понятно, Вить, да?
[01:57.760 --> 02:15.800]  Ты опоздал. Ничего не поделать уже. Что? Сравнивать только write timestamp и упорядочивание записи не
[02:15.800 --> 02:22.520]  должно как-то расплываться, размазываться по коду. В структуре write timestamp одного поля
[02:22.520 --> 02:27.720]  64-гитного мало, потому что вы так не сможете гарантировать разумным образом его уникальность.
[02:27.720 --> 02:33.800]  Вам нужно еще что-то. Для уникальности у вас генератор гуидов есть, у вас есть ID-узла, и там
[02:33.800 --> 02:41.120]  можно с разной степенью аккуратности все это сделать. Понятно. На всякий случай, конечно,
[02:41.120 --> 02:45.640]  неправильно держать локальный счетчик и брать ID-узла, потому что если узел перезагрузится,
[02:45.640 --> 02:55.800]  у него будет тот же самый ID. Ну, в общем, лучше... Что? Смотри, дело не в том, что нельзя использовать.
[02:55.800 --> 03:01.960]  Ты можешь получить корректное решение, сравнивая еще и value. Но это же просто нарушает декомпозицию.
[03:01.960 --> 03:09.520]  У тебя упорядочивание операции через timestamp происходит. Логика алгоритма такова, что там
[03:09.520 --> 03:14.480]  выбирается timestamp ровно для упорядочивания. Если тебе их мало, то, видимо, ты как-то свою
[03:14.480 --> 03:20.680]  ментальную модель в коде не выразил. Для алгоритма сами значения это просто какие-то байты,
[03:20.680 --> 03:24.880]  они не используются при упорядочивании. При упорядочивании используются timestamp.
[03:24.880 --> 03:33.800]  Ты не знаешь, можешь hash от значения брать в timestamp. Мне кажется, что хорошо, когда в программе
[03:33.800 --> 03:38.680]  все упорядочивание заключено в одном таком объекте, и ты смотришь на оператор сравнения и понимаешь.
[03:38.680 --> 03:44.400]  И в коде сравниваются только поля timestamp. Вот о чем была моя мысль.
[03:44.400 --> 03:52.800]  Ну а теперь про интересное решение, про true time. Не то, чтобы оно очень драматически все усложняет,
[03:52.800 --> 04:03.280]  но все же там есть, на чем можно попасться. Итак, у вас есть сервис true time, у которого есть,
[04:03.280 --> 04:10.520]  в первую очередь, один единственный вызов now, который возвращает вам интервал earliest-latest.
[04:10.520 --> 04:18.360]  Такое, что время вызова этой функции попадает в этот интервал. Это единственная гарантия,
[04:18.360 --> 04:22.320]  которая у нас есть. Гарантия, что этот интервал какой-то очень маленький или как-то он там,
[04:22.320 --> 04:28.040]  не знаю, монотонный, у правой и левой границы, вот таких гарантий сервис не дает. Пользоваться
[04:28.040 --> 04:35.320]  ими не нужно. Смысл этого сервиса в том, что вызов now – это локальное действие, оно не требует
[04:35.320 --> 04:42.400]  коммуникации по сети. И задача этого true time позволяет помогать узлам выбирать глобально
[04:42.400 --> 04:47.240]  монотонные timestamp. У нас геораспределенная система, узлы находятся друг от друга далеко,
[04:47.240 --> 04:51.560]  и вместо того, чтобы строить логические часы, которые требуют лишнего раунда коммуникации,
[04:51.560 --> 04:58.280]  мы собираемся выбрать временные метки так, чтобы с одной стороны, если у нас есть две записи,
[04:58.280 --> 05:07.280]  которые во времени не пересекаются, то timestamp первой записи был меньше, чем timestamp второй
[05:07.280 --> 05:12.600]  записи, потому что мы упорядочивали в линейнализации эти записи по timestamp.
[05:12.600 --> 05:18.960]  А с другой стороны, во-первых, мы их монотонно должны выбрать, а во-вторых, мы должны сделать это по
[05:18.960 --> 05:25.000]  возможности не устраивая лишней коммуникации, потому что она дорогая, а true time у нас локальный.
[05:25.000 --> 05:31.440]  True time использует коммуникацию, но там узлы коммуницируют с тайм-мастерами внутри DC
[05:31.440 --> 05:37.880]  асинхронно относительно вызовов now. Но еще через спутники GPS, в конце концов, со всеми другими
[05:37.880 --> 05:41.800]  общаются, то есть можно сказать, что коммуникация между ними есть, она просто наполовину в космосе
[05:41.800 --> 05:48.160]  происходит, ну и относительно вызова now асинхронно, поэтому мы за нее в своих запросах не платим.
[05:48.160 --> 05:54.720]  Мы пользуемся только тем, что нам вот дают такой интервал. Ну и задача выбрать эти timestamp
[05:54.720 --> 06:03.440]  монотонно. Вроде бы в такой постановке мы должны думать, вот если у нас есть две операции, то у этой
[06:03.440 --> 06:12.640]  должно быть timestamp больше, чем у этой. Вот смысл... Это так, если мы говорим про логические часы,
[06:12.640 --> 06:17.880]  и мы должны думать про вот две эти операции разом, но с физическими часами, с физическими временными
[06:17.880 --> 06:23.040]  метками, мы можем думать об этом проще. То есть мы можем не думать про две операции. Чтобы
[06:23.040 --> 06:29.400]  гарантировать вот такое вот свойство, нам достаточно гарантировать следующее, что если у нас есть запись,
[06:29.400 --> 06:38.800]  то наша задача выбрать временную метку для этой записи просто внутри интервала этой записи.
[06:38.800 --> 06:47.720]  Мы не знаем, когда операция началась, этим вообще не мы управляем. Ну конечно мы управляем,
[06:47.720 --> 06:54.920]  когда она закончится. И вот если мы выберем свою временную метку физическую в интервале этой операции,
[06:54.920 --> 07:06.080]  самой этой операции, то очевидно мы получим такую монотонность. Так что используя true time для выбора
[07:06.080 --> 07:09.560]  монотонных меток, мы можем не думать про разные операции, мы можем думать только про себя.
[07:09.560 --> 07:22.120]  Соображение понятно? Ну вот, а дальше как это сделать? Ну вот у нас есть true time. Если вы решили задачу,
[07:22.120 --> 07:29.240]  то вы знаете, что делать. Если вы не решили задачу, то есть у вас какие-то гипотезы. Как выбрать
[07:29.240 --> 07:36.080]  временную метку? Ну вот вы вызвали now. Вот у вас операция началась. В момент времени, давайте так,
[07:36.080 --> 07:42.120]  вот здесь напишем. Операция в момент времени t1 началась. И вот здесь вы спросили,
[07:42.120 --> 07:56.000]  t service true time. Спросили now. И вот получили какой-то интервал. Можно его нарисовать.
[07:56.000 --> 08:08.720]  Можно ли в качестве... Да, и нам теперь нужно выбрать временную метку. Ну предлагается как-то
[08:08.720 --> 08:13.640]  выбрать наверное из этого интервала, значит зачем мы этот now позвали. Вот можно ли в качестве
[08:13.640 --> 08:20.720]  временной метки выбрать левую границу интервала? Ну кажется, что даже по рисунку нельзя, потому что
[08:20.720 --> 08:26.560]  она оказалась слева от t1, а на t1 мы не влияем. Вот так что левая граница интервала не годится.
[08:26.560 --> 08:41.760]  Совсем не чувствуешь задачи. t1-то мы не знаем. Откуда мы его знаем? У нас есть свои неточные часы.
[08:41.760 --> 08:51.960]  Если у нас были точные, мы бы и true time не использовали. Я про другое сейчас говорю. Во-первых, нет, во-вторых,
[08:51.960 --> 09:02.080]  середина тоже не годится. По рисунку годится, но если отрезок сильно смещен влево, то и середина
[09:02.080 --> 09:08.240]  может оказаться за границами интервала меньше t1. Вот в интервале от e до l есть только одна точка,
[09:08.240 --> 09:18.800]  которая гарантированно попадает в интервал операции. То есть мы знаем, что во-первых, время вызова true time
[09:18.800 --> 09:28.160]  не меньше, чем t1, неизвестная нам, и мы знаем, что видимо true time принадлежит вот этот неизвестный t,
[09:29.120 --> 09:36.640]  принадлежит этому отрезку. А это означает, что l не меньше, чем true time. Время true time.
[09:37.120 --> 09:41.120]  Мы говорим, что, например, наше оно не уходит за...
[09:41.120 --> 09:43.120]  Что?
[09:43.120 --> 09:50.320]  Ну, наше, помните, мы говорили, мы обращаемся к true time, он смотрит какой сейчас реальный пробежиток времени,
[09:50.320 --> 09:54.320]  и пока он возвращается, прошло какое-то время.
[09:54.320 --> 09:58.320]  Но он нам дает какой-то интервал. Сейчас мы не говорим, как true time устроен, нам сейчас это неважно.
[09:58.320 --> 10:02.720]  Мы пользуемся просто гарантией, что время вызова true time принадлежит этому интервалу.
[10:02.800 --> 10:06.800]  Но если ты хочешь, можешь считать, что у нас вызов true time, это сам некоторый отрезок,
[10:06.800 --> 10:12.800]  и вот он пересекается с отрезком от еда l.
[10:12.800 --> 10:18.800]  Но это все как бы усложняет немножко неравенство, но не добавляет ничего содержательного.
[10:18.800 --> 10:20.800]  Поэтому мы считаем, что он мгновенно работает.
[10:20.800 --> 10:26.800]  Но если считать, что он мгновенно работает, то мы знаем, что правая граница не меньше, чем tt по гарантиям true time,
[10:26.880 --> 10:32.880]  и мы знаем, что это время вызова true time нау не меньше, чем t1.
[10:32.880 --> 10:36.880]  Так что l не точно не меньше, чем t1.
[10:36.880 --> 10:40.880]  И вот это единственный разумный кандидат на выборы timestamp.
[10:40.880 --> 10:44.880]  Вот мы взяли это l, но с ним вторая беда.
[10:44.880 --> 10:52.880]  Беда в том, что это l может быть далеко в будущем, в прошлом оно быть уже не может, в будущем оно может быть.
[10:52.960 --> 10:58.960]  Ну и нам нужно как-то убедиться, что мы не управляем левой границей интервала,
[10:58.960 --> 11:00.960]  правой границей мы управляем.
[11:00.960 --> 11:04.960]  То есть это наше решение, когда операцию завершить.
[11:04.960 --> 11:10.960]  Так что мы можем подождать, пока l точно не наступит.
[11:10.960 --> 11:14.960]  Вот spanner это называется правило commit weight.
[11:14.960 --> 11:20.960]  Если вы пробовали читать статью про spanner, то commit weight, потому что мы ждем.
[11:21.040 --> 11:25.040]  Вместо того, чтобы общаться и выбирать временную ветку, мы ждем, пока она не наступит.
[11:25.040 --> 11:27.040]  Как дождаться этого?
[11:27.040 --> 11:37.040]  Вот попытка первая это написать slip от l до l-e.
[11:45.040 --> 11:47.040]  Что?
[11:47.120 --> 11:53.120]  Нау, если бы нам было известно, задача была бы решена уже сразу.
[11:53.120 --> 11:57.120]  Как плохо, что задачи не решаешь.
[11:57.120 --> 12:01.120]  Нау мы не знаем, у нас есть только диапазон такой.
[12:01.120 --> 12:05.120]  Вот мы взяли l и хотим его дождаться.
[12:05.120 --> 12:09.120]  Вот так делать можно, но этого недостаточно, потому что вы не знаете,
[12:09.120 --> 12:11.120]  а вдруг ваши часы торопятся и вы проспите меньше, чем l-e.
[12:11.120 --> 12:15.120]  То есть часы торопятся в симуляции, поэтому проспите меньше.
[12:15.200 --> 12:17.200]  Поэтому нужно как-то убедиться.
[12:17.200 --> 12:19.200]  Как проверить вообще, что l наступило?
[12:19.200 --> 12:21.200]  Это вопрос какой-то.
[12:21.200 --> 12:23.200]  Или ты просто проводишь рукой?
[12:23.200 --> 12:25.200]  Хорошо.
[12:25.200 --> 12:27.200]  Как убедиться, что l наступило?
[12:27.200 --> 12:29.200]  У нас снова есть true time для этого.
[12:29.200 --> 12:33.200]  Спросим еще раз true time, если он скажет, что что?
[12:33.200 --> 12:35.200]  Как понять, что l наступило по его ответу?
[12:35.200 --> 12:41.200]  Если e больше, если новый e больше нашего l.
[12:41.280 --> 12:45.280]  Вот спросили true time, вот e больше, чем l, значит все, l наступило.
[12:45.280 --> 12:49.280]  Но в true time есть просто метод, который называется after,
[12:49.280 --> 12:53.280]  и он не возвращает future, что немного не согласовано.
[12:53.280 --> 12:57.280]  И самому этому true time не хватает метода, который возвращает future,
[12:57.280 --> 13:01.280]  но тогда смысл задачи пропадает, если его добавить.
[13:01.280 --> 13:05.280]  Вы спите, это лучшее, что вы можете сделать,
[13:05.280 --> 13:09.280]  и проверяете верно ли, что ваше временнометко оказалось в прошлом.
[13:09.360 --> 13:13.360]  Если оказалось, то вы добились...
[13:13.360 --> 13:15.360]  Дальше можно...
[13:15.360 --> 13:17.360]  После этого, видимо, можно операцию завершать.
[13:23.360 --> 13:27.360]  Вообще этот разговор задумывался для тех, которые решили задачу.
[13:27.360 --> 13:29.360]  Вот.
[13:29.360 --> 13:31.360]  Ты не помнишь, что after.
[13:31.360 --> 13:33.360]  True time принимает временную метку.
[13:33.360 --> 13:35.360]  В смысле, временную метку.
[13:35.440 --> 13:39.440]  В смысле, временной метку, точку временной,
[13:39.440 --> 13:41.440]  если и говорит, она в прошлом или в будущем.
[13:41.440 --> 13:45.440]  Как? Вызывая true time, сравнивая эту точку с левой границы интервала.
[13:45.440 --> 13:47.440]  Если левая граница от интервала больше.
[13:47.440 --> 13:49.440]  То есть это просто...
[13:49.440 --> 13:53.440]  Просто шорткат такой для этой проверки.
[13:53.440 --> 13:55.440]  Ты можешь ее сам написать, можешь автор позвать.
[13:57.440 --> 13:59.440]  Да.
[13:59.520 --> 14:05.520]  А может так получиться, что у нас две машины получили один и тот же интервал?
[14:05.520 --> 14:07.520]  Ну, конечно, может.
[14:07.520 --> 14:09.520]  Проблема-то она...
[14:09.520 --> 14:11.520]  Мы так же решаем какие...
[14:11.520 --> 14:15.520]  Да. Здесь от логических и от true time ничего не зависит.
[14:15.520 --> 14:17.520]  Проблема одна и та же. Ты должен гарантировать,
[14:17.520 --> 14:19.520]  что временные метки получились уникальными.
[14:19.520 --> 14:21.520]  А как она помогает вообще?
[14:25.520 --> 14:27.520]  Она просто помогает узнать, верно ли,
[14:27.600 --> 14:29.600]  что точка времени наступила и все.
[14:33.600 --> 14:35.600]  В смысле автор просто зовет now и сравнивает
[14:35.600 --> 14:37.600]  аргумент с этой границей.
[14:39.600 --> 14:41.600]  Тебе помогает узнать,
[14:41.600 --> 14:43.600]  время наступило, точка или нет.
[14:43.600 --> 14:45.600]  Не slip, конечно, а true time помогает узнать.
[14:47.600 --> 14:49.600]  Возвращая тебе новый E.
[14:49.680 --> 14:51.680]  Возвращая тебе новый E.
[14:51.680 --> 14:53.680]  Получается, что
[14:53.680 --> 14:55.680]  внутри автора
[14:55.680 --> 14:57.680]  вызывает true time now
[14:57.680 --> 14:59.680]  и сравнивает...
[14:59.680 --> 15:01.680]  Да.
[15:01.680 --> 15:03.680]  Так он сейчас не было никакого утверждения,
[15:03.680 --> 15:05.680]  что он делает что-то сложнее.
[15:05.680 --> 15:07.680]  Там же функция реализована в одну строчку,
[15:07.680 --> 15:09.680]  которая вызывает now как раз.
[15:09.680 --> 15:11.680]  Возвращается, что он сразу же
[15:11.680 --> 15:13.680]  как-то интервалов,
[15:13.680 --> 15:15.680]  который наступает нам,
[15:15.680 --> 15:17.680]  передавать...
[15:17.760 --> 15:19.760]  Откуда мы его можем знать?
[15:25.760 --> 15:27.760]  Мне кажется, что разумно вот так делать.
[15:27.760 --> 15:29.760]  Это вот очень достаточно.
[15:31.760 --> 15:33.760]  Что?
[15:33.760 --> 15:35.760]  Тут уже можно разные юристики придумать.
[15:35.760 --> 15:37.760]  В текущей симуляции тебе без разницы,
[15:37.760 --> 15:39.760]  потому что там все настолько вывернуто,
[15:39.760 --> 15:41.760]  что
[15:41.760 --> 15:43.760]  там все равно полный фарш получается.
[15:43.760 --> 15:45.760]  Я вот сейчас доделал задачу
[15:45.840 --> 15:47.840]  и немножко в симуляторе что-то дорабатываю.
[15:47.840 --> 15:49.840]  Я, надеюсь, доделаю бенчмарки,
[15:49.840 --> 15:51.840]  чтобы можно было
[15:51.840 --> 15:53.840]  запустить симуляцию
[15:53.840 --> 15:55.840]  с нормальными таймингами
[15:55.840 --> 15:57.840]  и с разумным true time,
[15:57.840 --> 15:59.840]  чтобы там это работало быстрее.
[15:59.840 --> 16:01.840]  Чтобы можно было увидеть, что работает быстрее.
[16:01.840 --> 16:03.840]  Да.
[16:07.840 --> 16:09.840]  А, ну это просто баг был, да.
[16:09.920 --> 16:11.920]  Да.
[16:15.920 --> 16:17.920]  Там была проблема в том, что ты написал цикл
[16:17.920 --> 16:19.920]  со slipform, а время не идет, все равно.
[16:19.920 --> 16:21.920]  Но если ты напоролся, то ты об этом знаешь.
[16:21.920 --> 16:23.920]  Если не напоролся, то 100 д.
[16:25.920 --> 16:27.920]  Не молчи.
[16:27.920 --> 16:29.920]  Ты напоролся, никому не сказала об этом.
[16:29.920 --> 16:31.920]  А человек из шада сказал,
[16:31.920 --> 16:33.920]  и я могу исправить через 5 минут.
[16:39.920 --> 16:41.920]  Ну нет, сейчас.
[16:41.920 --> 16:43.920]  Я, кстати, не понимаю.
[16:43.920 --> 16:45.920]  Это такой вопрос, который нужно всегда себе задавать.
[16:45.920 --> 16:47.920]  Какова семантика slip 0?
[16:47.920 --> 16:49.920]  Скажем.
[16:49.920 --> 16:51.920]  Может быть, по-разному для тех,
[16:51.920 --> 16:53.920]  где написано, может быть, if delay равен 0,
[16:53.920 --> 16:55.920]  то просто выйти, а может быть,
[16:55.920 --> 16:57.920]  какое-нибудь приключение сделать.
[16:57.920 --> 16:59.920]  Ну, в общем, это, конечно, не фича.
[16:59.920 --> 17:01.920]  В симуляторе время идет только, когда ты блокируешься.
[17:01.920 --> 17:03.920]  В частности, на фьюче из таймсервиса.
[17:03.920 --> 17:05.920]  Так что, если ты
[17:05.920 --> 17:07.920]  вызываешь slipform от чего-то
[17:08.000 --> 17:10.000]  отрицательного, положительного,
[17:10.000 --> 17:12.000]  то время должно идти.
[17:12.000 --> 17:14.000]  Если время не идет, то у тебя просто симуляция
[17:14.000 --> 17:16.000]  зацикливается.
[17:16.000 --> 17:18.000]  Время может медленно идти,
[17:18.000 --> 17:20.000]  но если оно совсем не идет,
[17:20.000 --> 17:22.000]  то вот это плохо, потому что
[17:22.000 --> 17:24.000]  симуляция не завершается.
[17:24.000 --> 17:26.000]  Ладно.
[17:26.000 --> 17:28.000]  Да.
[17:32.000 --> 17:34.000]  Ну, смотри, тебе Google говорит,
[17:34.000 --> 17:36.000]  что у них здесь
[17:36.080 --> 17:38.080]  восемь лет назад
[17:38.080 --> 17:40.080]  было не больше
[17:40.080 --> 17:42.080]  шести миллисекунд.
[17:42.080 --> 17:44.080]  Вот это L-E.
[17:44.080 --> 17:46.080]  А сейчас они там научились
[17:46.080 --> 17:48.080]  синхронизировать.
[17:48.080 --> 17:50.080]  Но у них статья была Google Sundail в прошлом году о том,
[17:50.080 --> 17:52.080]  что они научились синхронизировать
[17:52.080 --> 17:54.080]  часы с точностью до какие-то
[17:54.080 --> 17:56.080]  нанесекунд, что это выглядит вообще
[17:56.080 --> 17:58.080]  как безумие какое-то.
[18:00.080 --> 18:02.080]  Roundtrip через Атлантику,
[18:02.080 --> 18:04.080]  например, он занимает
[18:04.160 --> 18:06.160]  десятки миллисекунд.
[18:06.160 --> 18:08.160]  То есть ты ускоряешься там
[18:08.160 --> 18:10.160]  на порядок минимум.
[18:12.160 --> 18:14.160]  В этом и смысл,
[18:14.160 --> 18:16.160]  что они быстрее, чем логические часы.
[18:16.160 --> 18:18.160]  У тебя есть реплика в Африке, есть в Антарктиде,
[18:18.160 --> 18:20.160]  и есть где-то
[18:20.160 --> 18:22.160]  в Гренландии, ну и просто
[18:22.160 --> 18:24.160]  между ними долго проводам сообщением лететь.
[18:24.160 --> 18:26.160]  А ты можешь в этих трех точках,
[18:26.160 --> 18:28.160]  далеко друг от друга, там все равно нет ДЦ,
[18:28.160 --> 18:30.160]  но если представить их там, то
[18:30.160 --> 18:32.160]  эти три машины в трех ДЦ могут
[18:32.240 --> 18:34.240]  получать монотонные временные метки,
[18:34.240 --> 18:36.240]  не коммуницируя друг с другом,
[18:36.240 --> 18:38.240]  просто поспав там несколько миллисекунд,
[18:38.240 --> 18:40.240]  или, может быть, меньше уже на миллисе.
[18:40.240 --> 18:42.240]  Я просто забыл, что есть такое ограничение.
[18:42.240 --> 18:44.240]  Нет, этого ограничения нет,
[18:44.240 --> 18:46.240]  но чем меньше этот интервал,
[18:46.240 --> 18:48.240]  тем лучше.
[18:48.240 --> 18:50.240]  И смысл в том, чтобы
[18:50.240 --> 18:52.240]  гарантировать, что настоящее время
[18:52.240 --> 18:54.240]  там лежит, но гарантировать этого конечно невозможно.
[18:54.240 --> 18:56.240]  Я не знаю, как Google под этими словами имеет в виду.
[18:58.240 --> 19:00.240]  Они делают интервал настолько широким,
[19:00.320 --> 19:02.320]  настолько узким, где они еще могут
[19:02.320 --> 19:04.320]  давать какую-то разумную гарантию.
[19:04.320 --> 19:06.320]  Где они сами верят,
[19:06.320 --> 19:08.320]  что время действительно лежит.
[19:08.320 --> 19:10.320]  Но они, кажется, верят в это очень сильно
[19:10.320 --> 19:12.320]  и могут этот интервал ужать.
[19:14.320 --> 19:16.320]  Это имеет все смысл
[19:16.320 --> 19:18.320]  только в том, когда у тебя
[19:18.320 --> 19:20.320]  ширина этого интервала меньше,
[19:20.320 --> 19:22.320]  чем скорость передачи сообщения по сети.
[19:22.320 --> 19:24.320]  Если не становится сопоставимым,
[19:24.320 --> 19:26.320]  то в этом всем теряется смысл.
[19:26.320 --> 19:28.320]  То есть если у тебя машины в одном ДЦ
[19:28.400 --> 19:30.400]  в этом смысла никакого вообще нет.
[19:30.400 --> 19:32.400]  Потому что там тайминги и так уже меньше
[19:32.400 --> 19:34.400]  миллисекунды. То есть по сети сходить
[19:34.400 --> 19:36.400]  быстро.
[19:38.400 --> 19:40.400]  Так вот, как теперь выглядит
[19:40.400 --> 19:42.400]  алгоритм? Мы вызываем
[19:42.400 --> 19:44.400]  нау, получаем правую границу,
[19:44.400 --> 19:46.400]  а потом спим, да?
[19:46.400 --> 19:48.400]  А потом пишем на квором.
[19:48.400 --> 19:50.400]  Делали кто-нибудь не так,
[19:50.400 --> 19:52.400]  но потому что это не эффективный способ.
[19:52.480 --> 19:54.480]  Можно параллельно спать.
[19:56.480 --> 19:58.480]  Вот этот следующий шаг,
[19:58.480 --> 20:00.480]  который нужно было сделать.
[20:00.480 --> 20:02.480]  В самом деле,
[20:02.480 --> 20:04.480]  вы выбираете временную метку,
[20:04.480 --> 20:06.480]  чтобы писать на квором под ней.
[20:06.480 --> 20:08.480]  И вот интуитивно вы делаете так,
[20:08.480 --> 20:10.480]  выбираете временную метку, ждете, пока она в прошлом,
[20:10.480 --> 20:12.480]  потом пишете под ней.
[20:12.480 --> 20:14.480]  Никто не мешает делать это параллельно.
[20:14.480 --> 20:16.480]  Вот вы выбрали временную метку
[20:16.480 --> 20:18.480]  и сразу под ней пишете.
[20:18.560 --> 20:20.560]  Да, нет?
[20:20.560 --> 20:22.560]  В смысле нет?
[20:22.560 --> 20:24.560]  Вот мы выбрали, вызвали нау, мы знаем,
[20:24.560 --> 20:26.560]  что временная метка L.
[20:26.560 --> 20:28.560]  Но она, правда, еще в будущее может быть.
[20:28.560 --> 20:30.560]  То есть эта L еще не наступила.
[20:30.560 --> 20:32.560]  Но мы могли бы дожидаться
[20:32.560 --> 20:34.560]  параллельно с тем, чтобы собирать квором.
[20:38.560 --> 20:40.560]  Потому что, смотрите,
[20:42.560 --> 20:44.560]  ну, конечно,
[20:44.560 --> 20:46.560]  у нас есть параллельно,
[20:46.640 --> 20:48.640]  но, конечно, мы должны
[20:48.640 --> 20:50.640]  завершить операцию аккуратно.
[20:50.640 --> 20:52.640]  То есть мы должны завершить ее,
[20:52.640 --> 20:54.640]  когда L окажется в прошлом
[20:54.640 --> 20:56.640]  и когда квором соберется для записи.
[20:56.640 --> 20:58.640]  То есть мы выбираем максимум
[20:58.640 --> 21:00.640]  из двух, фактически.
[21:00.640 --> 21:02.640]  В коде вы не ждете параллельно.
[21:02.640 --> 21:04.640]  Вы собираете квором, потом вы дожидаетесь,
[21:04.640 --> 21:06.640]  пока еще L пройдет.
[21:06.640 --> 21:08.640]  В другом порядке, но по смыслу это параллельно.
[21:08.640 --> 21:10.640]  И вот этого достаточно,
[21:10.640 --> 21:12.640]  потому что если две записи будут
[21:12.640 --> 21:14.640]  упорядочены,
[21:14.720 --> 21:16.720]  а что с записью и чтением?
[21:16.720 --> 21:18.720]  Вот у вас есть запись,
[21:18.720 --> 21:20.720]  вот у вас есть чтение,
[21:20.720 --> 21:22.720]  и чтение, оно смотрит на квором.
[21:24.720 --> 21:26.720]  Но у вас здесь квором собрался,
[21:26.720 --> 21:28.720]  и у чтения собирался квором,
[21:28.720 --> 21:30.720]  и снова пересеклось.
[21:30.720 --> 21:32.720]  То есть здесь у нас работает
[21:32.720 --> 21:34.720]  ожидание для монотонности,
[21:34.720 --> 21:36.720]  а здесь работают кворомы
[21:36.720 --> 21:38.720]  для монотонности.
[21:38.720 --> 21:40.720]  Но вы дождались и того, и другого, поэтому у вас все хорошо.
[21:40.720 --> 21:42.720]  Есть один нюанс там,
[21:42.720 --> 21:44.720]  но как бы на него наступить
[21:44.720 --> 21:46.720]  интересно самому.
[21:46.720 --> 21:48.720]  Это неправильно так делать.
[21:48.720 --> 21:50.720]  То есть если вы так сделаете,
[21:50.720 --> 21:52.720]  то у вас работать не будет.
[21:52.720 --> 21:54.720]  Несмотря на то, что я вроде бы объяснил,
[21:54.720 --> 21:56.720]  что должно.
[21:58.720 --> 22:00.720]  Можно написать
[22:00.720 --> 22:02.720]  и попробовать посмотреть,
[22:02.720 --> 22:04.720]  что получится.
[22:04.720 --> 22:06.720]  Я уж не буду все секреты раскрывать.
[22:06.720 --> 22:08.720]  Но кажется, что
[22:08.720 --> 22:10.720]  спаннер и квором собирает
[22:10.720 --> 22:12.720]  и выбирает временную метку параллельно.
[22:16.720 --> 22:18.720]  Потому что если можно еще сэкономить,
[22:18.720 --> 22:20.720]  то почему бы еще и не сэкономить?
[22:26.720 --> 22:28.720]  Ну что?
[22:28.720 --> 22:30.720]  Мы освоили это?
[22:34.720 --> 22:36.720]  По-моему, для того, что я не рассказал,
[22:36.720 --> 22:38.720]  что делать с...
[22:38.720 --> 22:40.720]  Почему не работать?
[22:40.720 --> 22:42.720]  Не будет работать?
[22:42.720 --> 22:44.720]  Все остальное понятно?
[22:48.720 --> 22:50.720]  Это я предлагаю тебе
[22:50.720 --> 22:52.720]  все-таки самому увидеть.
[22:54.720 --> 22:56.720]  В смысле,
[22:56.720 --> 22:58.720]  будут падать
[22:58.720 --> 23:00.720]  стимуляции с нарушением реализуемости?
[23:00.720 --> 23:02.720]  Должны?
[23:06.720 --> 23:08.720]  А...
[23:10.720 --> 23:12.720]  Вот на лекции у тебя были
[23:12.720 --> 23:14.720]  шутки более уместные.
[23:16.720 --> 23:18.720]  Нужно взять true time,
[23:18.720 --> 23:20.720]  нужно выбрать правую границу
[23:20.720 --> 23:22.720]  в качестве временной метки
[23:22.720 --> 23:24.720]  и нужно написать решение, где ты
[23:24.720 --> 23:26.720]  ждешь параллельно.
[23:26.720 --> 23:28.720]  То есть ты начинаешь писать на квором
[23:28.720 --> 23:30.720]  и вместе с этим, не дожидаясь,
[23:30.720 --> 23:32.720]  пока временная метка уже в прошлом,
[23:32.720 --> 23:34.720]  ты сразу начинаешь писать на квором.
[23:34.720 --> 23:36.720]  Потом дожидаешься, что еще временная метка оказалась в прошлом.
[23:36.720 --> 23:38.720]  То есть ты параллельно ждешь, что она окажется в прошлом
[23:38.720 --> 23:40.720]  и пишешь на квором.
[23:40.720 --> 23:42.720]  В этом решении что-то будет
[23:42.720 --> 23:44.720]  не работать, хотя вроде бы
[23:44.720 --> 23:46.720]  рассуждение...
[23:46.720 --> 23:48.720]  Звучит разумно.
[23:50.720 --> 23:52.720]  Давай ты что-нибудь напишешь и сам увидишь.
[23:54.720 --> 23:56.720]  Должен же ты чему-то научиться.
[23:58.720 --> 24:00.720]  Ладно.
[24:00.720 --> 24:02.720]  Значит, это true time.
[24:04.720 --> 24:06.720]  Вторая часть задачи,
[24:06.720 --> 24:08.720]  которая мне кажется любопытной,
[24:08.720 --> 24:10.720]  полезной, состоит в том, чтобы
[24:10.720 --> 24:12.720]  оптимизировать...
[24:14.720 --> 24:16.720]  оптимизировать код реаплики, которая хранит
[24:16.720 --> 24:18.720]  собственно данные на диске.
[24:20.720 --> 24:22.720]  Наверное,
[24:22.720 --> 24:24.720]  вы заметили, что я из
[24:24.720 --> 24:26.720]  кода решения относительно, например,
[24:26.720 --> 24:28.720]  фреймворка удалил mutex, чтобы было
[24:28.720 --> 24:30.720]  интереснее немножко.
[24:30.720 --> 24:32.720]  Может быть, вы это заметили, а может быть вы поняли,
[24:32.720 --> 24:34.720]  что у вас просто без него не работает.
[24:36.720 --> 24:38.720]  Вот.
[24:38.720 --> 24:40.720]  Вам нужно... Вы приходите
[24:40.720 --> 24:42.720]  в хранилище... Вы, координатор, приходите в
[24:42.720 --> 24:44.720]  хранилище с операцией апдейта
[24:44.720 --> 24:46.720]  значения, у вас есть ключ
[24:46.720 --> 24:48.720]  в значении временная метка, и вы хотите
[24:48.720 --> 24:50.720]  атомарно проверить, что если текущая
[24:50.720 --> 24:52.720]  временная метка не меньше,
[24:52.720 --> 24:54.720]  меньше, чем ваша,
[24:54.720 --> 24:56.720]  если временная метка
[24:56.720 --> 24:58.720]  ключа в данном узбе
[24:58.720 --> 25:00.720]  меньше, чем ваша метка, то значение
[25:00.720 --> 25:02.720]  перезаписать. Если вы просто
[25:02.720 --> 25:04.720]  напишете чтение, проверка
[25:04.720 --> 25:06.720]  запись, то вы получите не атомарную операцию,
[25:06.720 --> 25:08.720]  про это было весь весенний семестр, это работать
[25:08.720 --> 25:10.720]  не будет. Поэтому вы берете mutex.
[25:10.720 --> 25:12.720]  Ну и получаете что-то дикое, на самом деле,
[25:12.720 --> 25:14.720]  потому что, ну представьте, вот вы пишете
[25:14.720 --> 25:16.720]  промышленную систему, и у вас там, как бы,
[25:16.720 --> 25:18.720]  она обрабатывает кучу запись, и вы приходите,
[25:18.720 --> 25:20.720]  берете один mutex, и все
[25:20.720 --> 25:22.720]  у него упирается. Хотя, как бы,
[25:22.720 --> 25:24.720]  сама база данных, она, как бы, сама по себе
[25:24.720 --> 25:26.720]  линиализуемая, атомарная, и там внутри какая-то конкурентность есть,
[25:26.720 --> 25:28.720]  она могла обработать.
[25:30.720 --> 25:32.720]  Ну, можно было бы mutex.rv mutex заменить,
[25:32.720 --> 25:34.720]  которого вы выйдете, нет, стоило бы его написать.
[25:34.720 --> 25:36.720]  Ну, это, наверное, не сильно вас все равно
[25:36.720 --> 25:38.720]  обрадовало, потому что все равно один mutex.
[25:38.720 --> 25:40.720]  Ну, если вы
[25:40.720 --> 25:42.720]  хоть о чем-то подумали, то, наверное,
[25:42.720 --> 25:44.720]  можно было бы просто шардировать его.
[25:44.720 --> 25:46.720]  Ну, то есть, у вас есть разные ключи,
[25:46.720 --> 25:48.720]  вы берете там массивы 128 mutex,
[25:48.720 --> 25:50.720]  и считаете хэш от ключа,
[25:50.720 --> 25:52.720]  и берете там какой-то свой. Ну, лучше, чем ничего,
[25:52.720 --> 25:54.720]  чем один mutex.
[25:54.720 --> 25:56.720]  Но в целом ситуация странная,
[25:56.720 --> 25:58.720]  потому что вы навешиваете
[25:58.720 --> 26:00.720]  эту блокировку,
[26:00.720 --> 26:02.720]  и у вас получается, что все записи
[26:02.720 --> 26:04.720]  происходят последовательно.
[26:06.720 --> 26:08.720]  Можно как-то попытаться это оптимизировать.
[26:08.720 --> 26:10.720]  И давайте мы
[26:12.720 --> 26:14.720]  сначала посмотрим
[26:14.720 --> 26:16.720]  на экран немножко, а потом вернемся
[26:16.720 --> 26:18.720]  на доску.
[26:18.720 --> 26:20.720]  Что я предлагаю?
[26:22.720 --> 26:24.720]  Я предлагаю немного доработать
[26:24.720 --> 26:26.720]  интерфейс базы.
[26:26.720 --> 26:28.720]  Никакого касса там не будет,
[26:28.720 --> 26:30.720]  потому что интерфейс базы
[26:30.720 --> 26:32.720]  не произвольный, не то чтобы я его выбираю.
[26:32.720 --> 26:34.720]  Я его выбираю
[26:34.720 --> 26:36.720]  я, но исходя из того,
[26:36.720 --> 26:38.720]  как этот интерфейс можно реализовать
[26:38.720 --> 26:40.720]  в промышленной системе.
[26:40.720 --> 26:42.720]  Я говорю, что мы в качестве
[26:42.720 --> 26:44.720]  такой
[26:44.720 --> 26:46.720]  дефолтной реализации этого интерфейса
[26:46.720 --> 26:48.720]  базы данных предполагаем levelDB.
[26:48.720 --> 26:50.720]  Это lsm, написанное Google,
[26:50.720 --> 26:52.720]  помимо мотивом своей системы Bigtable,
[26:52.720 --> 26:54.720]  которая поверх GFS работала.
[26:54.720 --> 26:56.720]  Ну и смотрим
[26:56.720 --> 26:58.720]  на то, что она умеет.
[26:58.720 --> 27:00.720]  Она умеет
[27:00.720 --> 27:02.720]  путы, гетты, дыриты,
[27:02.720 --> 27:04.720]  она умеет атомарно сделать несколько мутаций.
[27:04.720 --> 27:06.720]  Вы можете их сложить
[27:06.720 --> 27:08.720]  в такой write-batch.
[27:10.720 --> 27:12.720]  И вот атомарно его применить.
[27:12.720 --> 27:14.720]  Еще
[27:14.720 --> 27:16.720]  у вас есть
[27:16.720 --> 27:18.720]  замечание,
[27:18.720 --> 27:20.720]  как бы у нас оно не касается.
[27:20.720 --> 27:22.720]  По умолчанию все эти путы, дыриты, они
[27:22.720 --> 27:24.720]  асинхронные, но для наших целей
[27:24.720 --> 27:26.720]  асинхронность не подходит, поэтому у нас все по умолчанию просто синхронные.
[27:26.720 --> 27:28.720]  Ну а кроме того,
[27:28.720 --> 27:30.720]  еще есть итераторы
[27:30.720 --> 27:32.720]  и снапшоты.
[27:32.720 --> 27:34.720]  Ну, с итераторами я бы так сказал,
[27:34.720 --> 27:36.720]  глупо итерироваться,
[27:36.720 --> 27:38.720]  опасно итерироваться по словарю,
[27:38.720 --> 27:40.720]  которую вы меняете, непонятно, что вы получите.
[27:40.720 --> 27:42.720]  Поэтому есть снапшоты, вы можете взять
[27:42.720 --> 27:44.720]  и снапшот это снимок
[27:44.720 --> 27:46.720]  состояния, то есть вы фиксируете текущее
[27:46.720 --> 27:48.720]  состояние всего вашего хранилища, там лежит
[27:48.720 --> 27:50.720]  100 гигабайт ключей значений, вы берете
[27:50.720 --> 27:52.720]  и фиксируете это состояние,
[27:52.720 --> 27:54.720]  а дальше по нему можете итерироваться.
[27:56.720 --> 27:58.720]  Итерироваться и можете делать
[27:58.720 --> 28:00.720]  сик, то есть прыгнуть
[28:00.720 --> 28:02.720]  в нужное место к нужному ключу
[28:02.720 --> 28:04.720]  сразу.
[28:04.720 --> 28:06.720]  Предлагается
[28:06.720 --> 28:08.720]  такой интерфейс
[28:08.720 --> 28:10.720]  использовать у нас, то есть сделать функцию
[28:10.720 --> 28:12.720]  makeSnapshot, которая строит вам снапшот,
[28:12.720 --> 28:14.720]  а у снапшота можно
[28:14.720 --> 28:16.720]  читать или строить по нему итератор,
[28:16.720 --> 28:18.720]  а дальше с помощью этих итераторов
[28:18.720 --> 28:20.720]  итерироваться по снапшоту,
[28:20.720 --> 28:22.720]  при этом рассчитывая, что этот снапшот
[28:22.720 --> 28:24.720]  не может меняться,
[28:24.720 --> 28:26.720]  даже если с базой данных
[28:26.720 --> 28:28.720]  после этого работают какие-то другие
[28:28.720 --> 28:30.720]  пута и делиты.
[28:30.720 --> 28:32.720]  То есть состояние базы может
[28:32.720 --> 28:34.720]  меняться, а снапшот остается
[28:34.720 --> 28:36.720]  в неизменном состоянии.
[28:36.720 --> 28:38.720]  Ну и тут два вопроса.
[28:38.720 --> 28:40.720]  Первый вопрос, как этим воспользоваться,
[28:40.720 --> 28:42.720]  чтобы сделать
[28:42.720 --> 28:44.720]  реализацию без бьютокса?
[28:44.720 --> 28:46.720]  А второй вопрос,
[28:46.720 --> 28:48.720]  как эта функция makeSnapshot работает?
[28:48.720 --> 28:50.720]  Потому что она, кажется, берет снапшот
[28:50.720 --> 28:52.720]  сталь гигабайт данных
[28:52.720 --> 28:54.720]  и может быть не совсем понятно,
[28:54.720 --> 28:56.720]  как это могло бы быть устроено.
[28:58.720 --> 29:00.720]  Я предложил
[29:00.720 --> 29:02.720]  на первый вопрос ответить самим,
[29:02.720 --> 29:04.720]  нам,
[29:04.720 --> 29:06.720]  написав код.
[29:06.720 --> 29:08.720]  Второй вопрос
[29:08.720 --> 29:10.720]  я собираюсь объяснить, но
[29:10.720 --> 29:12.720]  он касается...
[29:12.720 --> 29:14.720]  он с первым тоже помогает вам,
[29:14.720 --> 29:16.720]  но и это полезно само по себе.
[29:16.720 --> 29:18.720]  Итак, мы хотим разобраться,
[29:18.720 --> 29:20.720]  как в LSM можно сделать снапшоты,
[29:20.720 --> 29:22.720]  насколько это дорогая операция.
[29:22.720 --> 29:24.720]  Я вам буквально предлагаю
[29:24.720 --> 29:26.720]  на каждый запрос создавать по снапшоту.
[29:28.720 --> 29:30.720]  Это не выглядит
[29:30.720 --> 29:32.720]  как чего-то очень дешевое, потому что
[29:32.720 --> 29:34.720]  за снапшотом 100 гигабайт данных
[29:34.720 --> 29:36.720]  непонятно, как можно было бы эффективно.
[29:36.720 --> 29:38.720]  Но тем не менее, мы собираемся
[29:38.720 --> 29:40.720]  это сделать.
[29:44.720 --> 29:46.720]  На каждую нашу операцию,
[29:46.720 --> 29:48.720]  которую мы выполняем с нашей системой,
[29:48.720 --> 29:50.720]  мы хотим строить...
[29:50.720 --> 29:52.720]  на какие-то операции мы хотим
[29:52.720 --> 29:54.720]  строить снапшоты.
[29:54.720 --> 29:56.720]  Итак, давайте
[29:56.720 --> 29:58.720]  быстро вспомним, как
[29:58.720 --> 30:00.720]  работал
[30:00.720 --> 30:02.720]  LevelDB.
[30:02.720 --> 30:04.720]  Это был
[30:04.720 --> 30:06.720]  LSM.
[30:06.720 --> 30:08.720]  Мы сказали, что
[30:08.720 --> 30:10.720]  в нем есть операция put
[30:10.720 --> 30:12.720]  по ключу записать значение,
[30:12.720 --> 30:14.720]  есть операция
[30:14.720 --> 30:16.720]  delete,
[30:16.720 --> 30:18.720]  удаление ключа есть, операция
[30:18.720 --> 30:20.720]  get, поиск по ключу.
[30:20.720 --> 30:22.720]  Но есть еще вот эти
[30:22.720 --> 30:24.720]  итерации снапшот.
[30:26.720 --> 30:28.720]  Мы сначала
[30:28.720 --> 30:30.720]  решили такую задачу. Сказали,
[30:30.720 --> 30:32.720]  что пусть у нас есть...
[30:34.720 --> 30:36.720]  Пусть у нас набор данных
[30:36.720 --> 30:38.720]  иммутабельный,
[30:38.720 --> 30:40.720]  пусть у нас есть
[30:40.720 --> 30:42.720]  киты, которые должны выполняться
[30:42.720 --> 30:44.720]  быстро,
[30:44.720 --> 30:46.720]  но и мы должны хранить данные надежно
[30:46.720 --> 30:48.720]  на диске.
[30:50.720 --> 30:52.720]  Вот эту задачу мы решили с помощью
[30:52.720 --> 30:54.720]  SSTable,
[30:56.720 --> 30:58.720]  сортированного файла.
[30:58.720 --> 31:00.720]  Мы побили его на блоке,
[31:00.720 --> 31:02.720]  запомнили для каждого
[31:02.720 --> 31:04.720]  блока
[31:04.720 --> 31:06.720]  его граничные ключи,
[31:08.720 --> 31:10.720]  и построили разреженный индекс
[31:10.720 --> 31:12.720]  в памяти,
[31:12.720 --> 31:14.720]  в памяти, разумеется, который по
[31:14.720 --> 31:16.720]  вот этому первому ключу ставит
[31:16.720 --> 31:18.720]  в соответствие offset файле.
[31:18.720 --> 31:20.720]  И когда мы быстро
[31:20.720 --> 31:22.720]  должны были что-то найти в этом сортированном
[31:22.720 --> 31:24.720]  файле, мы искали блок подходящий,
[31:24.720 --> 31:26.720]  его читали, и в нем находили уже
[31:26.720 --> 31:28.720]  нужный ключ.
[31:28.720 --> 31:30.720]  Дальше мы сказали, что давайте все-таки у нас данные
[31:30.720 --> 31:32.720]  будут мутабельные, мы хотим
[31:32.720 --> 31:34.720]  делать много путов и хотим
[31:34.720 --> 31:36.720]  по-прежнему durability.
[31:38.720 --> 31:40.720]  Но при этом нас совсем не беспокоит
[31:40.720 --> 31:42.720]  время гета.
[31:42.720 --> 31:44.720]  Тогда нужно организовать данные
[31:44.720 --> 31:46.720]  по-другому, нужно сделать append-only-log.
[31:48.720 --> 31:50.720]  Приходит новый пут,
[31:50.720 --> 31:52.720]  и мы его помещаем просто в конец лога.
[31:52.720 --> 31:54.720]  Делаем append файл.
[31:56.720 --> 31:58.720]  Вот.
[31:58.720 --> 32:00.720]  А когда мы делаем get, мы этот лог сканируем
[32:00.720 --> 32:02.720]  сначала и просто ищем последний
[32:02.720 --> 32:04.720]  пут в этом логе для данного ключа.
[32:04.720 --> 32:06.720]  Это неэффективно, поэтому мы
[32:06.720 --> 32:08.720]  говорим, что давайте это ускорим,
[32:08.720 --> 32:10.720]  сделав maintainable.
[32:10.720 --> 32:12.720]  То есть контейнер
[32:12.720 --> 32:14.720]  в оперативной памяти, который просто
[32:14.720 --> 32:16.720]  дублирует содержимое лога.
[32:16.720 --> 32:18.720]  Когда мы кладем что-то в лог,
[32:20.720 --> 32:22.720]  мы
[32:22.720 --> 32:24.720]  сначала кладем
[32:24.720 --> 32:26.720]  запись в...
[32:26.720 --> 32:28.720]  Когда мы кладем что-то в lsm,
[32:28.720 --> 32:30.720]  мы кладем это в лог,
[32:30.720 --> 32:32.720]  а после этого кладем
[32:32.720 --> 32:34.720]  в memtable.
[32:42.720 --> 32:44.720]  Получается вот такая вот конструкция.
[32:46.720 --> 32:48.720]  Диск RAM.
[32:48.720 --> 32:50.720]  На диске лежит лог.
[32:50.720 --> 32:52.720]  Все путы попадают в него.
[32:58.720 --> 33:00.720]  А после этого попадают в memtable.
[33:10.720 --> 33:12.720]  Когда мы что-то ищем,
[33:12.720 --> 33:14.720]  то мы идем, конечно, сразу в memtable.
[33:14.720 --> 33:16.720]  Ну и все бы это работало, если бы
[33:16.720 --> 33:18.720]  memtable, если бы память была бесконечная,
[33:18.720 --> 33:20.720]  но memtable заполняется,
[33:20.720 --> 33:22.720]  и мы воспользуемся первым
[33:22.720 --> 33:24.720]  представлением данных,
[33:24.720 --> 33:26.720]  мы сбрасываем memtable на диск
[33:26.720 --> 33:28.720]  в виде этого сортированного файла
[33:28.720 --> 33:30.720]  sst.
[33:32.720 --> 33:34.720]  И после этого можем
[33:34.720 --> 33:36.720]  дропнуть весь лог.
[33:36.720 --> 33:38.720]  Ну потом memtable
[33:38.720 --> 33:40.720]  снова заполняет память,
[33:40.720 --> 33:42.720]  мы дампим его
[33:42.720 --> 33:44.720]  еще раз,
[33:44.720 --> 33:46.720]  а потом сливаем вот эти маленькие
[33:46.720 --> 33:48.720]  memtable в memtable
[33:48.720 --> 33:50.720]  в sstable побольше.
[33:50.720 --> 33:52.720]  У нас получается такой каскад
[33:52.720 --> 33:54.720]  этих sstables.
[33:58.720 --> 34:00.720]  Ну и мы ищем сначала в memtable,
[34:00.720 --> 34:02.720]  а потом если не нашлось, то мы где-то здесь.
[34:06.720 --> 34:08.720]  Вот такая была конструкция.
[34:10.720 --> 34:12.720]  А теперь мы хотим
[34:12.720 --> 34:14.720]  путы get понятны,
[34:14.720 --> 34:16.720]  делать delete тоже понятны,
[34:16.720 --> 34:18.720]  мы говорили, что это пут просто с некоторым
[34:18.720 --> 34:20.720]  специальным ключом томстованным,
[34:20.720 --> 34:22.720]  который говорит, что запись удалена.
[34:22.720 --> 34:24.720]  Мы не можем ничего удалить, потому что
[34:24.720 --> 34:26.720]  у нас много данных в умутабельном состоянии,
[34:26.720 --> 34:28.720]  мы не можем из сортированного файла ничего из середины стереть.
[34:30.720 --> 34:32.720]  Так что мы просто делаем новую запись, которая
[34:32.720 --> 34:34.720]  пропихивается через весь этот каскад
[34:34.720 --> 34:36.720]  и за собой все стирает.
[34:36.720 --> 34:38.720]  А теперь мы хотим
[34:38.720 --> 34:40.720]  к этой конструкции добавить снэпшот.
[34:40.720 --> 34:42.720]  Мы хотим захватить состояние
[34:42.720 --> 34:44.720]  структуры данных в какой-то момент времени.
[34:44.720 --> 34:46.720]  И это выглядит довольно дорогой операцией.
[34:46.720 --> 34:48.720]  Дорогой, если не думать.
[34:48.720 --> 34:50.720]  А если подумать, то мы сразу увидим,
[34:50.720 --> 34:52.720]  что задача-то фактически уже решена.
[34:52.720 --> 34:54.720]  Потому что
[34:54.720 --> 34:56.720]  снэпшот это некоторое имутабельное состояние
[34:56.720 --> 34:58.720]  текущее.
[34:58.720 --> 35:00.720]  А у нас в LSM и так
[35:00.720 --> 35:02.720]  большинство данных хранится в имутабельном состоянии
[35:02.720 --> 35:04.720]  в виде sstables.
[35:04.720 --> 35:06.720]  Это нам очень подходит для снэпшотов.
[35:06.720 --> 35:08.720]  Делать даже ничего не нужно.
[35:08.720 --> 35:10.720]  Но есть вот этот memtable
[35:10.720 --> 35:12.720]  и вот он часто меняется.
[35:14.720 --> 35:16.720]  Как заснапшить снэпшот с memtable?
[35:18.720 --> 35:20.720]  Ну не то чтобы мы хотели бы взять его
[35:20.720 --> 35:22.720]  скопировать в памяти, потому что
[35:22.720 --> 35:24.720]  память у вас может быть много.
[35:24.720 --> 35:26.720]  Память у вас может быть очень много.
[35:26.720 --> 35:28.720]  Оперативной.
[35:28.720 --> 35:30.720]  И вы там не будете
[35:30.720 --> 35:32.720]  копировать десятки, сотни гигабайт.
[35:32.720 --> 35:34.720]  Мы хотим операцию снэпшот,
[35:34.720 --> 35:36.720]  которая очень дешево.
[35:36.720 --> 35:38.720]  Поэтому что мы сделаем?
[35:38.720 --> 35:40.720]  Ну может кто-то знает или кто-то понимает, что
[35:40.720 --> 35:42.720]  нужно делать.
[35:48.720 --> 35:50.720]  Ну вот тут какие-то номера берутся. Не совсем понятно как их использовать.
[35:50.720 --> 35:52.720]  Ну вот предлагайте делать следующее.
[35:52.720 --> 35:54.720]  Давайте
[35:54.720 --> 35:56.720]  мы все путы пронумеруем.
[35:58.720 --> 36:00.720]  Вот каждый пут в memtable
[36:00.720 --> 36:02.720]  и вообще в это хранилище, он будет получать некоторые
[36:02.720 --> 36:04.720]  последовательные номер.
[36:04.720 --> 36:06.720]  Всяма на одной машине живет.
[36:06.720 --> 36:08.720]  Сделать так несложно. У нас будет
[36:08.720 --> 36:10.720]  sequenceNumber.
[36:14.720 --> 36:16.720]  Вот для всего LSM есть
[36:16.720 --> 36:18.720]  некоторые текущие sequenceNumber.
[36:18.720 --> 36:20.720]  Когда мы делаем пут какой-то, мы берем
[36:20.720 --> 36:22.720]  увеличим его на единицу.
[36:22.720 --> 36:24.720]  Наш пут с текущим значением ассоциирован.
[36:24.720 --> 36:26.720]  Если мы делаем
[36:26.720 --> 36:28.720]  сразу серию апдейтов,
[36:28.720 --> 36:30.720]  то там тоже можно учесть.
[36:30.720 --> 36:32.720]  И
[36:32.720 --> 36:34.720]  внутри memtable
[36:34.720 --> 36:36.720]  ну да,
[36:36.720 --> 36:38.720]  он вроде бы хранит пару ключей значения.
[36:38.720 --> 36:40.720]  Но под капотом
[36:40.720 --> 36:42.720]  он хранит не совсем те же самые ключи
[36:42.720 --> 36:44.720]  значения. Ну значения он те же хранит,
[36:44.720 --> 36:46.720]  а ключи у него другие.
[36:46.720 --> 36:48.720]  Когда мы делаем пут
[36:48.720 --> 36:50.720]  вот ключа K по значению
[36:50.720 --> 36:52.720]  V,
[36:52.720 --> 36:54.720]  то мы трансформируем его в такой вот
[36:56.720 --> 36:58.720]  волнистый пут,
[36:58.720 --> 37:00.720]  где в качестве ключа будет пара
[37:00.720 --> 37:02.720]  ключ и текущий
[37:02.720 --> 37:04.720]  sequenceNumber.
[37:06.720 --> 37:08.720]  И вот этот memtable
[37:08.720 --> 37:10.720]  будет упорядочен по вот такому составному ключу.
[37:12.720 --> 37:14.720]  Как это нам помогает?
[37:16.720 --> 37:18.720]  Задача уже решена, в общем-то.
[37:18.720 --> 37:20.720]  В таком подходе
[37:20.720 --> 37:22.720]  взять снэпшот всего хранилища.
[37:22.720 --> 37:24.720]  Это значит просто
[37:24.720 --> 37:26.720]  прочесть текущий sequenceNumber.
[37:26.720 --> 37:28.720]  Вот просто снэпшот
[37:28.720 --> 37:30.720]  это чтение sequenceNumber.
[37:30.720 --> 37:32.720]  Фиксируем его, запомнили все.
[37:42.720 --> 37:44.720]  Как сделать чтение?
[37:44.720 --> 37:46.720]  Вот мы приходим
[37:46.720 --> 37:48.720]  и собираемся читать по ключу.
[37:48.720 --> 37:50.720]  Как нам быть?
[37:50.720 --> 37:52.720]  Сейчас.
[37:56.720 --> 37:58.720]  Во-первых,
[37:58.720 --> 38:00.720]  в levelDB
[38:00.720 --> 38:02.720]  операция чтения получает параметры.
[38:02.720 --> 38:04.720]  И там указан либо снэпшот, либо
[38:04.720 --> 38:06.720]  используя текущий снэпшот.
[38:06.720 --> 38:08.720]  То есть операция чтения
[38:08.720 --> 38:10.720]  всегда с некоторым sequenceNumber, либо
[38:10.720 --> 38:12.720]  из снэпшота, который мы запомнили раньше,
[38:12.720 --> 38:14.720]  либо мы просто выбираем текущую версию.
[38:14.720 --> 38:16.720]  То есть у нас всегда это
[38:16.720 --> 38:18.720]  некоторый get
[38:18.720 --> 38:20.720]  с волной от ключа k
[38:20.720 --> 38:22.720]  и некоторого значения s.
[38:28.720 --> 38:30.720]  Читаем все,
[38:30.720 --> 38:32.720]  в смысле 100 гигабайт из памяти оперативный.
[38:36.720 --> 38:38.720]  100 гигабайт ключей читаем или что?
[38:40.720 --> 38:42.720]  Так а не факт, что он такой есть
[38:42.720 --> 38:44.720]  в базе.
[38:44.720 --> 38:46.720]  У нас этот s апдейтится
[38:46.720 --> 38:48.720]  на каждый пут. Мы может быть
[38:48.720 --> 38:50.720]  сделали 100 путов с какими-то другими ключами,
[38:50.720 --> 38:52.720]  а теперь мы ищем с тем же ключом.
[38:52.720 --> 38:54.720]  В смысле?
[38:54.720 --> 38:56.720]  Ну вот, да. Мы пользуемся тем, что у нас контейнер
[38:56.720 --> 38:58.720]  упорядочен и упорядочен по вот этой паре ks.
[39:00.720 --> 39:02.720]  И когда мы ищем
[39:02.720 --> 39:04.720]  по ключу k что-то в текущем снэпшоте
[39:04.720 --> 39:06.720]  с sequenceNumber s,
[39:06.720 --> 39:08.720]  мы просто в ментейбле
[39:08.720 --> 39:10.720]  ищем ключ,
[39:10.720 --> 39:12.720]  максимальный ключ,
[39:12.720 --> 39:14.720]  который меньше, чем наш ks.
[39:16.720 --> 39:18.720]  Ключ, у которого первая компонента k,
[39:18.720 --> 39:20.720]  а вторая компонента
[39:20.720 --> 39:22.720]  максимальная, не больше,
[39:22.720 --> 39:24.720]  чем s.
[39:24.720 --> 39:26.720]  И вот мы теперь...
[39:26.720 --> 39:28.720]  И разумеется, так можно и итерироваться по снэпшоту.
[39:28.720 --> 39:30.720]  То есть у нас с ментейбл меняются,
[39:30.720 --> 39:32.720]  там появляются новые
[39:32.720 --> 39:34.720]  те же самые ключи с большими
[39:34.720 --> 39:36.720]  sequenceNumber,
[39:36.720 --> 39:38.720]  но со старыми остаются,
[39:38.720 --> 39:40.720]  и мы можем при итерации просто их скипать.
[39:40.720 --> 39:42.720]  То есть сам контейнер
[39:42.720 --> 39:44.720]  не умеет скипать, он умеет просто проходить
[39:44.720 --> 39:46.720]  по всему, что есть, но вы в итераторе просто
[39:46.720 --> 39:48.720]  смотрите, почему вы идете, если вы видите большой
[39:48.720 --> 39:50.720]  sequenceNumber, то вы его выпускаете и даете пользователю.
[39:50.720 --> 39:52.720]  Если маленький
[39:52.720 --> 39:54.720]  sequenceNumber не больше, чем ваш номер
[39:54.720 --> 39:56.720]  снэпшота, то вы даете пользователю
[39:56.720 --> 39:58.720]  запись.
[39:58.720 --> 40:00.720]  А с сестейблом еще проще, потому что там
[40:00.720 --> 40:02.720]  просто все имитабельно.
[40:02.720 --> 40:04.720]  Ну и то же самое.
[40:04.720 --> 40:06.720]  Взятие снэпшота это супер дешевая
[40:06.720 --> 40:08.720]  операция. Это просто взятие...
[40:08.720 --> 40:10.720]  Мы запоминаем sequenceNumber.
[40:18.720 --> 40:20.720]  Ну под капотом LevelDB
[40:20.720 --> 40:22.720]  хранит так, да.
[40:22.720 --> 40:24.720]  Это внутреннее представление, ты нигде
[40:24.720 --> 40:26.720]  к этому всему, ты с этим напрямую нигде не работаешь.
[40:30.720 --> 40:32.720]  То есть у тебя есть просто put, get,
[40:32.720 --> 40:34.720]  delete в API, и ты про вот эти
[40:34.720 --> 40:36.720]  sequenceNumber ничего не знаешь.
[40:36.720 --> 40:38.720]  LevelDB сам все это нумирует.
[40:38.720 --> 40:40.720]  Ты не можешь подставить какое-то свое
[40:40.720 --> 40:42.720]  значение.
[40:44.720 --> 40:46.720]  Да нет, конечно.
[40:48.720 --> 40:50.720]  У тебя же ключи маленькие,
[40:50.720 --> 40:52.720]  они...
[40:52.720 --> 40:54.720]  Ждем.
[40:56.720 --> 40:58.720]  Эх, упала.
[40:58.720 --> 41:00.720]  Она могла ехать вниз.
[41:00.720 --> 41:02.720]  Но нет.
[41:06.720 --> 41:08.720]  Мы же теперь не можем спокойно
[41:08.720 --> 41:10.720]  мержить.
[41:10.720 --> 41:12.720]  Нет, в смысле, мержить-то
[41:12.720 --> 41:14.720]  мы можем,
[41:14.720 --> 41:16.720]  но аккуратно нужно знать
[41:16.720 --> 41:18.720]  какие снэпшоты в хранилище есть.
[41:18.720 --> 41:20.720]  Давайте я вот LevelDB немножко покажу,
[41:20.720 --> 41:22.720]  чтобы мы видели,
[41:22.720 --> 41:24.720]  что я вам нигде не наврал.
[41:36.720 --> 41:38.720]  Ну вот,
[41:38.720 --> 41:40.720]  когда мы что-то читаем,
[41:40.720 --> 41:42.720]  то смотрите, мы берем readOptions,
[41:42.720 --> 41:44.720]  и если в
[41:44.720 --> 41:46.720]  options есть снэпшот,
[41:46.720 --> 41:48.720]  то мы...
[41:48.720 --> 41:50.720]  Вообще, что такое снэпшот?
[41:50.720 --> 41:52.720]  Давайте
[41:52.720 --> 41:54.720]  посмотрим сначала.
[41:58.720 --> 42:00.720]  Snapshot — это структурка,
[42:00.720 --> 42:02.720]  которая...
[42:02.720 --> 42:04.720]  Ну, есть интерфейс снэпшот, у которого кажется
[42:04.720 --> 42:06.720]  у LevelDB есть интерфейсная часть,
[42:06.720 --> 42:08.720]  и сейчас
[42:08.720 --> 42:10.720]  вернусь сюда.
[42:20.720 --> 42:22.720]  Вот, есть интерфейс снэпшот,
[42:22.720 --> 42:24.720]  в котором ничего нет.
[42:24.720 --> 42:26.720]  То есть пользователь с ним напрямую
[42:26.720 --> 42:28.720]  не работает.
[42:28.720 --> 42:30.720]  Он может его только получить,
[42:30.720 --> 42:32.720]  но он не может это сделать.
[42:32.720 --> 42:34.720]  Он может его только получить,
[42:34.720 --> 42:36.720]  вызвав
[42:36.720 --> 42:38.720]  соответствующую функцию.
[42:38.720 --> 42:40.720]  Ну и может его потом...
[42:40.720 --> 42:42.720]  Может сказать, что он больше не нужен.
[42:42.720 --> 42:44.720]  Но этот снэпшот, он для пользователя не прозрачен.
[42:46.720 --> 42:48.720]  Его можно передать в Get,
[42:48.720 --> 42:50.720]  и тогда
[42:50.720 --> 42:52.720]  в Get он
[42:52.720 --> 42:54.720]  скастется к снэпшот импл,
[42:54.720 --> 42:56.720]  а в снэпшот импл у нас...
[43:02.720 --> 43:04.720]  лежит этот самый sequence number.
[43:04.720 --> 43:06.720]  То есть вот снэпшот —
[43:06.720 --> 43:08.720]  когда вы делаете снэпшот, вы буквально
[43:08.720 --> 43:10.720]  получаете один sequence number.
[43:18.720 --> 43:20.720]  Вот.
[43:20.720 --> 43:22.720]  Так что эта операция очень деш...
[43:22.720 --> 43:24.720]  очень дешевая, и можно
[43:24.720 --> 43:26.720]  звать ее, ну,
[43:26.720 --> 43:28.720]  скорой годно часто.
[43:28.720 --> 43:30.720]  Можно хоть там на каждую маленькую...
[43:30.720 --> 43:32.720]  на каждое маленькое чтение делать.
[43:32.720 --> 43:34.720]  То есть можно каждое
[43:34.720 --> 43:36.720]  чтение или каждую... короче,
[43:36.720 --> 43:38.720]  каждую операцию на уровне вашей системы
[43:38.720 --> 43:40.720]  ее выполнять надо каким-то снэпшотом,
[43:40.720 --> 43:42.720]  строить его заново, потому что это
[43:42.720 --> 43:44.720]  не требует никакого
[43:44.720 --> 43:46.720]  чтения сканирования данных вообще.
[43:46.720 --> 43:48.720]  Это всего лишь запоминание одного числа.
[43:48.720 --> 43:50.720]  Ну и когда вы
[43:50.720 --> 43:52.720]  говорите,
[43:52.720 --> 43:54.720]  например,
[43:54.720 --> 43:56.720]  когда вы говорите
[43:56.720 --> 43:58.720]  write, то вы
[43:58.720 --> 44:00.720]  sequence number глобально обновляете.
[44:00.720 --> 44:02.720]  Вот вы где-то его читаете здесь,
[44:04.720 --> 44:06.720]  а потом пишете
[44:06.720 --> 44:08.720]  новый.
[44:10.720 --> 44:12.720]  Когда вы читаете данное,
[44:12.720 --> 44:14.720]  то вы берете этот sequence number
[44:14.720 --> 44:16.720]  либо из снэпшота,
[44:18.720 --> 44:20.720]  либо если вы снэпшот не передали,
[44:20.720 --> 44:22.720]  то вы берете
[44:22.720 --> 44:24.720]  просто текущий последний.
[44:24.720 --> 44:26.720]  Ну а дальше
[44:26.720 --> 44:28.720]  вы читаете
[44:28.720 --> 44:30.720]  что-то из memtable.
[44:30.720 --> 44:32.720]  И для того чтобы искать
[44:32.720 --> 44:34.720]  уже в memtable вы строите вот такой
[44:34.720 --> 44:36.720]  вот lookup key,
[44:36.720 --> 44:38.720]  где у вас есть
[44:38.720 --> 44:40.720]  ключ пользователя и снэпшот.
[44:42.720 --> 44:44.720]  Это даже sequence number уже
[44:44.720 --> 44:46.720]  а не снэпшот.
[44:48.720 --> 44:50.720]  И этот ключ
[44:50.720 --> 44:52.720]  он
[44:52.720 --> 44:54.720]  он
[44:54.720 --> 44:56.720]  сейчас сбился.
[44:58.720 --> 45:00.720]  Он кажется определенно здесь.
[45:08.720 --> 45:10.720]  Вот пользовательский ключ,
[45:10.720 --> 45:12.720]  sequence number и из него составляется
[45:12.720 --> 45:14.720]  внутренний ключ, который...
[45:14.720 --> 45:16.720]  Вот описание формата.
[45:18.720 --> 45:20.720]  И вот по нему внутри логически
[45:20.720 --> 45:22.720]  все сортируется.
[45:24.720 --> 45:26.720]  Да в общем-то идея
[45:26.720 --> 45:28.720]  лежит на поверхности, на самом деле,
[45:28.720 --> 45:30.720]  если вы хоть немного подумать,
[45:30.720 --> 45:32.720]  потому что вы строите снэпшот,
[45:32.720 --> 45:34.720]  это означает, что у вас есть старая версия данных
[45:34.720 --> 45:36.720]  и новая есть, которую вы обновляете.
[45:36.720 --> 45:38.720]  Поэтому это не могут быть одни и те же данные.
[45:38.720 --> 45:40.720]  Вы должны как-то их дубировать.
[45:40.720 --> 45:42.720]  Но делать это прямо
[45:42.720 --> 45:44.720]  в момент взятия снэпшота
[45:44.720 --> 45:46.720]  нельзя, потому что это бесконечно дорого.
[45:46.720 --> 45:48.720]  Так что вы должны эту работу как-то амортизировать.
[45:48.720 --> 45:50.720]  Вот вы и так ее делаете.
[45:50.720 --> 45:52.720]  Вы строите мультиверсионное хранилище.
[45:54.720 --> 45:56.720]  Правда в этом хранилище все эти версии
[45:56.720 --> 45:58.720]  от вас скрыты,
[45:58.720 --> 46:00.720]  а у вас задача сделать хранилище,
[46:00.720 --> 46:02.720]  где у вас версии собственные
[46:02.720 --> 46:04.720]  снаружи, и вы сами
[46:04.720 --> 46:06.720]  управляете.
[46:06.720 --> 46:08.720]  В этом оставшаяся
[46:08.720 --> 46:10.720]  часть домашней состоит.
[46:10.720 --> 46:12.720]  Как
[46:12.720 --> 46:14.720]  поверх такого интерфейса
[46:14.720 --> 46:16.720]  с итераторами и ключами
[46:16.720 --> 46:18.720]  можно сделать
[46:18.720 --> 46:20.720]  свое хранилище
[46:20.720 --> 46:22.720]  с версиями.
[46:22.720 --> 46:24.720]  То, что вы придумаете в нем
[46:24.720 --> 46:26.720]  и можете написать, в этом Mutex
[46:26.720 --> 46:28.720]  и не будет в этом решении.
[46:28.720 --> 46:30.720]  Но в то же время возникнет другая задача.
[46:34.720 --> 46:36.720]  Это все слишком абстрактно, потому что мы еще не придумали.
[46:36.720 --> 46:38.720]  Давайте
[46:38.720 --> 46:40.720]  вы это сделаете, а чтобы вам было
[46:40.720 --> 46:42.720]  интересно, я могу вам что-нибудь за это пообещать.
[46:46.720 --> 46:48.720]  Нет, но уважение само собой за такое.
[46:48.720 --> 46:50.720]  Но уважение
[46:50.720 --> 46:52.720]  в карман не положишь.
[46:52.720 --> 46:54.720]  Балла тоже не положишь в карман, но все-таки приятнее,
[46:54.720 --> 46:56.720]  чем просто уважение.
[46:56.720 --> 46:58.720]  Так что
[46:58.720 --> 47:00.720]  тут можно
[47:00.720 --> 47:02.720]  поторговаться немножко.
[47:06.720 --> 47:08.720]  Но мне очень хочется, чтобы кто-то попробовал, потому что
[47:08.720 --> 47:10.720]  все остальное вроде бы в этой задаче мы понимаем,
[47:10.720 --> 47:12.720]  как делать, а здесь
[47:12.720 --> 47:14.720]  такая деталь, которая нам...
[47:14.720 --> 47:16.720]  Мне это еще важно, потому что в будущем нам это понадобится.
[47:16.720 --> 47:18.720]  У нас будут транзакции, а там все это
[47:18.720 --> 47:20.720]  будет необходимо. Так что если мы сейчас сделаем,
[47:20.720 --> 47:22.720]  то в будущем
[47:22.720 --> 47:24.720]  это нам упростит, добавит
[47:24.720 --> 47:26.720]  понимание в соответствующей теме.
[47:30.720 --> 47:32.720]  Ну и просто, ты поставил киврию хранища, где ты Mutex берешь
[47:32.720 --> 47:34.720]  глобально, ну что ты, что сделаешь?
[47:34.720 --> 47:36.720]  Ты не должен быть удовлетворен этим.
[47:36.720 --> 47:38.720]  Во-первых, она берет Mutex
[47:38.720 --> 47:40.720]  только на запись, во-вторых, она может
[47:40.720 --> 47:42.720]  бачить работу, точнее предполагается,
[47:42.720 --> 47:44.720]  что в нее
[47:44.720 --> 47:46.720]  на дней баченку выполняют.
[47:46.720 --> 47:48.720]  Так что нет, конечно,
[47:48.720 --> 47:50.720]  не берет она Mutex один.
[47:50.720 --> 47:52.720]  То есть она берет, но аккуратно.
[47:52.720 --> 47:54.720]  Ну или там может быть использована идея
[47:54.720 --> 47:56.720]  flat-компания, когда ты берешь один Mutex
[47:56.720 --> 47:58.720]  и под ним делаешь сразу много работы.
[47:58.720 --> 48:00.720]  Это опять же очень
[48:00.720 --> 48:02.720]  может быть разумно.
[48:02.720 --> 48:04.720]  Ну и понимаешь же, тут
[48:04.720 --> 48:06.720]  Mutex на запись это одно,
[48:06.720 --> 48:08.720]  а ты берешь Mutex не на запись,
[48:08.720 --> 48:10.720]  ты берешь Mutex на чтение плюс
[48:10.720 --> 48:12.720]  запись, ну как будто у тебя
[48:12.720 --> 48:14.720]  больше scope получается, и там уже меньше
[48:14.720 --> 48:16.720]  оптимизации доступно тебе.
[48:16.720 --> 48:18.720]  Так что ты делаешь хуже, ты баченку вообще
[48:18.720 --> 48:20.720]  исключаешь из своего решения.
[48:22.720 --> 48:24.720]  Так что Mutex, Mutex в розе.
[48:24.720 --> 48:26.720]  Вот тут правильный Mutex.
[48:26.720 --> 48:28.720]  Кого надо Mutex?
[48:28.720 --> 48:30.720]  Кого надо Mutex?
[48:30.720 --> 48:32.720]  Кого надо Mutex?
[48:32.720 --> 48:34.720]  А вот сверх он уже
[48:34.720 --> 48:36.720]  не такой хороший.
[48:38.720 --> 48:40.720]  Ну что?
[48:40.720 --> 48:42.720]  Прошло 3 часа, да?
[48:42.720 --> 48:44.720]  С момента старта пары.
[48:44.720 --> 48:46.720]  4 минуты осталось.
[48:48.720 --> 48:50.720]  Если у вас нет вопросов,
[48:50.720 --> 48:52.720]  то мы можем на этом сегодня остановиться.
