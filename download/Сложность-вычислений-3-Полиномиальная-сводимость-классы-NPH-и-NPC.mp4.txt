[00:00.000 --> 00:18.160]  Так, наверное надо начинать. Да, меня слышно нормально там на записи. Так, значит, вот
[00:18.160 --> 00:24.400]  эти вот лекции следующие будут такими центральными, по крайней мере, в первой части курса. Они будут
[00:24.400 --> 00:32.840]  посвящены теме NP-полноты. И в целом многие понятия, которые в этой теме возникнут,
[00:32.840 --> 00:37.680]  прежде всего понятия свадимости, понятия полноты, они будут не только про класс NP,
[00:37.680 --> 00:45.800]  но и, в принципе, про практически любые другие классы. Мы познакомимся вот с такой картиной,
[00:45.800 --> 01:03.000]  как разные задачи расположены. Эта облачка, это весь класс NP. Тут как бы по вертикальной
[01:03.000 --> 01:11.560]  оси наверх идёт сложность. Значит, вот где-то здесь в нижней части будет класс P. Значит,
[01:11.560 --> 01:25.160]  дальше будет такое вот ножство NPH. Это NP-трудные задачи, а пересечение NP-трудных и NP-называется NP-полное.
[01:25.160 --> 01:33.280]  Тут, соответственно, NPC. А вот эти вот NP-промежуточные,
[01:33.280 --> 01:46.280]  те, которые в NP, но не полные и не пальномиальные. Соответственно, вот на всё это мы посмотрим.
[01:46.280 --> 01:59.160]  Значит, если вы изучали, что ко М-свадимость в логике, значит, с PMF точно изучали, да, с PMF тоже было.
[01:59.160 --> 02:06.200]  Хорошо, значит, в целом у вас есть понятия о свадимости, а вот АМ-полнота там была? Тоже была,
[02:06.200 --> 02:13.880]  очень хорошо. Соответственно, вот свадимость в NP и NP-полнота примерно тоже самое. Только вместо
[02:13.880 --> 02:21.440]  вычислимости будет полинавиальная вычислимость. Соответственно, определение сначала свадимости.
[02:21.440 --> 02:34.440]  Значит, свадимость между вообще любыми двумя задачами. То есть пусть А и Б это два языка.
[02:34.440 --> 03:02.560]  Значит, пусть А и Б это два языка. Значит, тогда А сводится к Б, тогда А сводится к Б,
[03:02.560 --> 03:09.000]  и тут буквка П и означает полинавиальная свадимость или свадимость по карпу.
[03:09.000 --> 03:27.480]  Значит, читается, как А сводится к Б по карпу. Ну или полинавиально сводится, да, это в принципе то
[03:27.480 --> 03:39.840]  же самое. Значит, если верно следующее. Если существует полинавиально вычислимая функция F,
[03:39.840 --> 03:47.760]  значит, так, ну тут нужно сказать, откуда эти языки берутся. Ну, например, они из двоечных слов.
[03:47.760 --> 03:57.200]  То есть они оба под множество 0,1 со звездочкой. Конечные слова в двоечном алфавите.
[03:57.200 --> 04:03.600]  Вот, тогда F будет, соответственно, тоже из 0,1 со звездочкой в 0,1 со звездочкой.
[04:03.600 --> 04:15.640]  Значит, полинавиально вычислимая F из 0,1 со звездочкой в 0,1 со звездочкой. Значит, такая,
[04:15.640 --> 04:27.440]  что верно следующее. Значит, такая, что для любого Х будет, что Х лежит в А тогда и только тогда,
[04:27.440 --> 04:42.800]  когда F от Х лежит в Б. Вот, значит, такое определение. Так, самое главное свойство, давайте,
[04:42.800 --> 04:46.920]  сейчас будет несколько свойств, но самое главное, которое мотивирует вообще это определение,
[04:46.920 --> 05:02.800]  это такое, что утверждение, утверждение, что если Б лежит в П, а А сводится к Б, то тогда А тоже лежит в П.
[05:02.800 --> 05:12.280]  Значит, это вообще зачем нужна сводимость, что мы сводим задачу к какой-то другой задачу,
[05:12.280 --> 05:21.400]  которую мы уже умеем решать. Соответственно, если мы уже умеем решать задачу СП и у нас,
[05:21.400 --> 05:25.800]  соответственно, умеем решать задачу СП, у нас есть задача СП, мы к ней свели нашу,
[05:25.800 --> 05:33.320]  тогда нашу мы тоже умеем решать. Вот, но это вообще почти очевидное утверждение, основано на том,
[05:33.320 --> 05:43.640]  что композиция полинов это полином. То есть, тут получается, что есть, значит, Б лежит в П,
[05:43.640 --> 05:56.800]  это означает, что существует полиномиально вычислимый какой-то алгоритм или машина М,
[05:56.800 --> 06:13.560]  значит, такая, что будет, что х лежит в Б тогда и только тогда, когда М от х равно 1. Вот. Ну,
[06:13.560 --> 06:24.320]  и тогда получается, что х будет лежать в А, х будет лежать в А тогда и только тогда, когда f от х лежит в
[06:24.320 --> 06:33.680]  B, а это тогда и только тогда, когда М от f от х равняется 1. Ну и, соответственно, если f полинально
[06:33.680 --> 06:39.560]  вычислимо и М полинально вычислимо, то композиция тоже полинально вычислима, потому что композиция
[06:39.560 --> 06:50.200]  полинов это полином. Ну вот, в общем, так и доказывается, надеюсь, что это понятно. Так, теперь давайте
[06:50.200 --> 07:03.320]  парочку простых примеров. Накинь совсем простые примеры. Но, например, можно рассмотреть задачу
[07:03.320 --> 07:23.960]  раскраски в три цвета. Значит, три раскраска – это множество графов таких, что существует раскраска
[07:23.960 --> 07:35.560]  вершин в три цвета. То есть существует функция call coloring из вершин графа G в множество из трех
[07:35.560 --> 07:49.400]  элементов, например, 1, 2, 3. Значит, такое, что для любого ребра УВ, который – ребро этого графа,
[07:49.400 --> 08:01.680]  будет верно, что цвет У не равен цвету В. Значит, в общем, вот стандартное определение раскрашиваемости
[08:01.680 --> 08:11.960]  в три цвета. Так, значит, а дальше другая задача будет задача выполнимости. Значит, задача выполнимости
[08:11.960 --> 08:26.040]  сад. То есть это множество фи таких, что фи – это выполнимая буллива формула. Ну вот, утверждается,
[08:26.040 --> 08:32.600]  что три раскраска сводятся к выполнимости. Ну, на самом деле и наоборот, но наоборот мы, наверное,
[08:32.600 --> 08:43.080]  в следующий раз обсудим. А в эту сторону не очень сложно. На самом, мы на логике на ПМИ это даже
[08:43.080 --> 08:52.880]  изучали. На ПМФ не было такого, да? Не было, да. Сейчас тогда обсудим. Значит, вот три раскраска
[08:52.880 --> 09:04.840]  сводятся к выполнимости. Значит, смотрите, в чём идея. Единственное, что нужно как-то закодировать раскраску
[09:04.840 --> 09:11.920]  через булливопеременные. Ну, смотрите, если было бы два цвета, то достаточно было бы одной
[09:11.920 --> 09:17.560]  переменной на вершину. Если было бы четыре цвета, то двух. А тут получается, что как бы одна мало,
[09:17.560 --> 09:23.920]  две много, но всё равно нужно использовать две, но один вариант исключить. Соответственно,
[09:23.920 --> 09:41.000]  каждой вершине графа мы сопоставим две переменных – булливых ПУТ и КУТ. Ну и дальше будет,
[09:41.000 --> 09:52.240]  если две перемен, то четыре варианта. Значит, 0, 0, 0, 1, 1, 0, 1, 1. Ну и вот нижние три варианта
[09:52.240 --> 10:03.760]  мы будем считать соответствующими цветам. То есть это будет цвет 1, это 2, это 3. А 0, 0 будет
[10:03.760 --> 10:12.560]  просто некорректным. Чтобы потребовать, чтобы все цвета были корректными, мы наложим условия
[10:12.560 --> 10:32.040]  просто дизьюнцию. Значит, ПУТ или КУТ. Это условия для всех У. Это условия корректности. Но кроме
[10:32.040 --> 10:36.280]  того, нужно ещё, чтобы это была правильная раскраска. То есть это условие того, что именно
[10:36.280 --> 10:44.400]  три цвета, а ещё нужно вот это условие, что они различные. Но так и запишем просто, что вот это
[10:44.400 --> 10:53.360]  как буллива строка из двух битов, различная, если У и В соединены ребром. То есть дальше условия,
[10:53.360 --> 11:07.320]  что если У и В это ребро, то тогда должно быть условие ПУТ не равно ПВТ или КУТ не равно КУВТ.
[11:07.320 --> 11:16.000]  И дальше нужно взять большую конъюнцию. Дальше возьмём большую конъюнцию всех этих условий,
[11:16.000 --> 11:22.520]  и будет как раз формула, выполнимость которой равносильно раскрашиваемости графа.
[11:22.520 --> 11:43.320]  Вот это ФИ. Это конъюнция всех условий. И мы получили, что ФИ выполнима только тогда,
[11:43.320 --> 11:52.680]  когда граф раскрашиваемый. Можно вкратце обсудить почему. Важно, что здесь в две стороны
[11:52.680 --> 12:00.240]  равносильность и в ту и другую сторону. Соответственно, наверное, справа налево проще,
[12:00.240 --> 12:07.920]  потому что мы так и строили конструкцию. Если есть граф, у нём есть раскраска, тогда для каждой
[12:07.920 --> 12:13.800]  вершины есть цвет, и мы этот цвет закодируем по этой табличке. Поскольку тут цвета 1, 2, 3,
[12:13.800 --> 12:19.840]  то тогда все вот эти условия будут выполнены автоматически. Ну а кроме того, поскольку это
[12:19.840 --> 12:25.280]  правильная раскраска, то у соседних вершин цвета разные, и поэтому вот эти условия тоже будут
[12:25.280 --> 12:33.920]  выполнены. И поэтому конъюнция тоже будет выполнена, значит, ФИ выполнима. В другую сторону,
[12:33.920 --> 12:41.480]  значит, в другую сторону пусть есть выполняющий набор значений всех переменных, так что все эти
[12:41.480 --> 12:48.600]  условия выполнены. Тогда, во-первых, поскольку выполнены все вот эти вот условия, то варианта
[12:48.600 --> 12:55.280]  0, 0 нету, а все остальные варианты по этой табличке нам доздают цвета. Поэтому получается раскраска
[12:55.280 --> 13:02.120]  именно в три цвета. То есть мы скажем, что цвет вершины У это 1, если значение переменных 0, 1,
[13:02.120 --> 13:12.680]  2, 1, 0 и 3, если 1, 1. Значит, это раскраска. Ну и правильность тоже получается из этого условия.
[13:12.680 --> 13:18.400]  Раз все эти условия выполнены, то значит все соседние в разные цвета покрашены. Так, хорошо,
[13:18.400 --> 13:31.520]  значит, вот это вот простая конструкция. Так, давайте я еще даже, еще проще опишу конструкцию,
[13:31.560 --> 13:42.880]  чтобы показать место, где нужно не ошибиться. Да, это мы, я надеюсь, сегодня успеем доказать. Ну не любую,
[13:42.880 --> 13:51.080]  но любую из NP. Потому что вообще задачи сколько угодно сложные бывают, а SAT все-таки лежит в NP.
[13:51.080 --> 14:10.080]  Так, значит, смотрите, вот такая еще проще утверждение, что раскраску в три цвета можно
[14:10.080 --> 14:15.200]  свести к раскраске в четыре цвета. Но здесь есть очень простое и неправильное рассуждение,
[14:15.200 --> 14:19.760]  что мы возьмем просто тот же самый граф. Если он раскрашился в три цвета, то будет в четыре
[14:19.760 --> 14:25.840]  тоже раскрашиваться. Проблема в том, что в этом рассуждении только в одну сторону будет импликация,
[14:25.840 --> 14:31.400]  нужно, чтобы в обе стороны была импликация. То есть нужно как-то граф все-таки преобразовать так,
[14:31.400 --> 14:37.880]  чтобы если новый граф раскрашивался в четыре цвета, то старый раскрашивался бы в три цвета.
[14:37.880 --> 14:44.960]  Да, совершенно верно, совершенно верно. Тем не менее, правильная конструкция тоже очень простая.
[14:44.960 --> 14:54.040]  Значит, нужно взять граф и взять одну новую вершину и ее просто соединить со всеми.
[14:54.040 --> 15:09.680]  Да не проще, я бы сказал. Не проще. Нет, это...
[15:15.000 --> 15:21.040]  Нет, подождите, нам в другую сторону нужно. Да, четыре кол к САТ усвоится точно так же,
[15:21.040 --> 15:28.120]  а вот САТ к четыре кол, и это не сильно проще, чем к три кол, и это целая конструкция там на 20 минут.
[15:28.120 --> 15:33.280]  Мы ее пройдем, либо на лекс, либо на семинаре обязательно, но не сейчас.
[15:33.280 --> 15:47.720]  Вот здесь рассуждение так проводится, что смотрите, если старый граф раскрашивался в три цвета,
[15:47.720 --> 15:54.160]  то мы его так и раскрасим, добавим четвертый цвет этой вершины. Ну и наоборот тоже, наоборот,
[15:54.160 --> 15:59.880]  что если новый граф раскрашивался в четыре цвета, то какой-то один цвет должен быть в этой вершины,
[15:59.880 --> 16:04.360]  а у всех остальных вершин должны быть другие цвета, их как раз три осталось,
[16:04.360 --> 16:14.040]  поэтому старый граф должен раскрашиваться в три цвета. Так, ну я надеюсь, это понятно.
[16:14.040 --> 16:38.200]  Так, хорошо. Давайте еще парочку простых свойств сводимости, общих свойств
[16:38.200 --> 16:51.400]  сводимости изучим. Другие свойства сводимости. Так, ну во-первых, транзитивность,
[16:51.400 --> 17:07.640]  транзитивность, если а сводится к b, значит аb сводится к c, то тогда а сводится к c.
[17:07.640 --> 17:16.760]  Более-менее по той же самой причине. Да, по той же самой причине, что композиция полинов это
[17:16.760 --> 17:26.160]  полином и композиция полинарного числемых функций и полинарного числема. Значит дальше есть переход
[17:26.160 --> 17:39.960]  к дополнению, что а сводится к b, тогда и только тогда, когда дополнение к а сводится к дополнению
[17:39.960 --> 17:53.480]  к b. Мы требуем большая полинарная вычислимость, да, то есть полинарная вычисленность это мы считаем,
[17:53.480 --> 18:00.800]  что не просто в конечное время, а ограничено полиномом. Да-да-да, на любом входе. На любом входе
[18:00.800 --> 18:11.960]  функция завершает вычисление за полином от длины входа. Не-не-не, сейчас, давай считать, что если
[18:11.960 --> 18:17.840]  время ограничено, то оно везде ограничено, а если не о полином, то это оно как бесконечное время.
[18:17.840 --> 18:33.200]  Переход к дополнению тоже очевидно, просто ту же самую функцию можно использовать и в
[18:33.200 --> 18:43.560]  определении нервонасильности прийти к отрицанию с левого и справа. Ну и еще, наверное, сводимость
[18:43.560 --> 18:56.560]  к NP. Значит, сводимость к NP, что по аналогии с первым утверждением, что если a сводится к b,
[18:56.560 --> 19:12.480]  а b лежит в NP, то тогда a лежит в NP. Ну, тут тоже можно использовать какое хотите определение NP,
[19:12.480 --> 19:22.080]  у нас есть определение через нетерминированную машину, есть определение через сертификат. Ну и
[19:22.080 --> 19:31.600]  в принципе и там, и там. То есть можно также как здесь сказать, что мы берем композицию,
[19:31.600 --> 19:37.400]  только здесь ем нетерминированное, и тогда композиция тоже будет нетерминированная и работать
[19:37.400 --> 19:43.400]  за композицию этих полиномов. Ну а можно расписать определение через сертификат,
[19:43.400 --> 19:50.400]  а в общем тоже получится. Да, здесь будет существовать какой-то сертификат f от x,
[19:50.400 --> 19:58.560]  и тогда его же можно использовать для проверки x, что сначала по x вычислить f от x, потом к этому f
[19:58.560 --> 20:10.920]  от x принять сертификат из старой алгоритм-проверки. На самом деле вот это нижнее утверждение не только
[20:10.920 --> 20:19.680]  для AP, не только для NP справедливо, а вообще для очень многих классов, которые у нас в курсе
[20:19.680 --> 20:41.600]  будут встречаться. Ну более-менее да. Ну конечно, да, конечно. Конечно у нас примерно так и будет.
[20:41.600 --> 21:00.960]  То есть вообще общая идея такая, что вот эта сводимость, она вот для вопроса равны ли p и NP,
[21:00.960 --> 21:07.920]  как придумано. И всегда, когда есть какой-то такой вопрос про равенство классов, и известно,
[21:07.920 --> 21:14.520]  что меньше вложено в больший, то всегда возникает сводимость, и сама сводимость должна быть из
[21:14.520 --> 21:22.160]  меньшего класса. Вот, а применяем мы ее к языкам из большего класса. То есть как здесь все вот эти
[21:22.160 --> 21:36.960]  вот и 3 кол, 4 кол, и SAT, они все в NP, и вот мы их так друг к другу свозим. Так. Вот, кстати,
[21:36.960 --> 21:45.200]  4 кол к 3 кол я не знаю элементарного рассуждения. То есть можно свести к SAT, потом SAT к 3 кол,
[21:45.200 --> 21:56.520]  а вот так, чтобы чисто с графами работать, это я не знаю. Ну может и можно как-то. Вот так. Ну
[21:56.520 --> 22:08.680]  хорошо, наверное теперь можно перейти к определению NP полноты и NP трудности. Вот это вот ключевое
[22:08.680 --> 22:18.600]  определение первой половины курса, по крайней мере. Точнее тут два. Вот я там стер диаграмму,
[22:18.600 --> 22:32.840]  там были NP трудная и NP полная. Значит NP трудная, то есть B лежит в классе NP-H, NP-hard.
[22:32.840 --> 22:50.800]  Значит, верно следующее, если для любого A из NP верно, что A сводится к B. Это NP трудность.
[22:50.800 --> 23:05.880]  Сейчас, кто имеет внимание по включению? Не, ну понятно, да, NP полная, это множество всех таких B,
[23:05.880 --> 23:16.600]  для которых вот это выполнено. Конечно это имеется в виду. Ну а NP трудная, а NP полная,
[23:16.600 --> 23:31.160]  это NP трудный и NP одновременно. То есть NP полная, NP complete. Значит это NP в пересечение с NP
[23:31.160 --> 23:43.000]  трудными. То есть это те языки из NP, к которым сводится любой другой язык из NP. Ну типа того,
[23:43.000 --> 23:52.840]  да. Да, в частности, посмотрите, поскольку NP вложено в EXP, можно перебором решить за экспоненциальное
[23:52.840 --> 24:09.840]  время, то в частности любая задача из EXP будет NP трудной. Ну да, вы правы. Ну да, хорошо,
[24:09.840 --> 24:32.040]  из EXP там, ну не более простые. Так, сюда эти словами тоже напишу. Те языки, те языки из NP,
[24:32.040 --> 24:58.440]  к которым сводятся остальные из NP. Так, и это NP полнота. Так, ну еще есть NP промежуточные,
[24:58.440 --> 25:06.360]  да, они были там на диаграмме, но давайте я их тут напишу тоже NP. NP intermediate. NP промежуточное,
[25:06.360 --> 25:22.080]  значит это NP без NP полных и без P. Ну а если нет, то слева-слева направо. Ну давайте я более
[25:22.080 --> 25:48.720]  однозначно напишу. Так. Что по словам множество? Что-то я не понял про эксиматику.
[25:52.080 --> 26:06.960]  А, в смысле, что, не, ну да, если P равно NP, то тогда, смотрите, это интересная штука вообще. Вопрос,
[26:06.960 --> 26:17.120]  что если вдруг P равно NP, то как это все выглядит? Смотрите, там будет два исключения, это как раз
[26:17.120 --> 26:28.320]  пустое множество и, наоборот, все слова, язык из тех слов. То есть вот так, та картинка,
[26:28.320 --> 26:43.400]  которую я рисовал, значит давайте я ее перерисую в случае, когда P равно NP. Значит, если, если P
[26:43.400 --> 26:55.320]  равно NP, то это будет так выглядеть. Значит, вот это будет, значит, это будет P равно NP. Значит,
[26:55.320 --> 27:06.000]  а NP полные будут все, кроме двух исключений. Да, то есть тут вот будет пустое множество и,
[27:06.000 --> 27:15.840]  наоборот, все слова вместе, а вот это будут NP полные. А NP трудные будут все, кроме,
[27:15.840 --> 27:28.960]  кроме, опять же, вот этих вот двух. А предвручных вообще не будет. Вот. Почему так будет? Ну,
[27:28.960 --> 27:47.160]  потому что, смотрите, если утверждение, утверждение, если пересечение P и NP полных не пусто, то P равно NP.
[27:47.160 --> 28:02.400]  Значит, почему это так? Ну, конечно, да, из определения. Получается, да, у нас есть там какая-то
[28:02.400 --> 28:09.200]  задача, с одной стороны она лежит в P, с другой стороны любая из NP к ней сводится, но и по утверждению
[28:09.200 --> 28:17.680]  сводимости к P, она тоже будет лежать в P. Отсюда NP будет вложена в P, а P вложена в NP всегда. Вот.
[28:17.680 --> 28:29.280]  Хорошо. Ну, значит, дальше еще есть несколько очевидных утверждений, они более-менее следуют
[28:29.280 --> 28:41.600]  из свойств сводимости. Значит, смотрите, если A у нас NP полная, значит, если A NP полная и A
[28:41.600 --> 28:55.960]  сводится к B, то тогда B тоже NP полная. Ой, сейчас, пока NP трудные, пока, да, извините. Если A NP
[28:55.960 --> 29:01.800]  трудная и A сводится к B, то B тоже NP трудная, потому что любая из NP сводится к A, потом A к B по
[29:01.800 --> 29:09.440]  транзитивности любая к B. Вот. А с NP полными, ну, нужно еще дополнительно потребовать, чтобы B тоже
[29:09.440 --> 29:23.200]  лежала в NP, да, то есть если A, значит, если A лежит в NP полных, значит, A сводится к B и B лежит в NP,
[29:23.200 --> 29:37.000]  то тогда B тоже NP полная. Ну, например, по тем же причинам, что мы любую из NP свели к A, потом к B,
[29:37.000 --> 29:45.240]  значит, любую к B, а B само в NP мы явно потребовали, и поэтому она NP полная. Вот. Соответственно,
[29:45.240 --> 29:50.680]  вот это последнее утверждение, оно при всей своей простоте очень важно, потому что именно оно
[29:50.680 --> 30:03.160]  позволяет получать новые NP полные задачи. То есть, в принципе, типичная ситуация, когда какая-то
[30:03.160 --> 30:09.480]  новая задача где-то возникла, да, она по характеру переборная, но вот мы хотим для начала понять,
[30:09.480 --> 30:16.000]  будет она NP полная или не будет. Вот. Но не будет это сложно, а вот если будет, то нужно,
[30:16.000 --> 30:23.280]  во-первых, сказать, что она действительно переборная и лежит в NP. Но это обычно, это бывает несложно,
[30:23.280 --> 30:30.200]  там какой-нибудь очевидный перебор, но бывает сложно. И во-вторых, нужно какую-то известную NP
[30:30.200 --> 30:38.000]  полную задачу свести к данной. Вот. Ну и известных NP полных задач очень много, в том числе в разных
[30:38.000 --> 30:50.480]  конкретных областях. Ну и с некоторыми из них мы познакомимся. Так. Ну ладно, это, наверное, понятно.
[30:50.480 --> 30:57.960]  Хорошо. Но возникает вопрос, а почему хотя бы одна есть полная задача? Да, вот если у нас одна есть,
[30:57.960 --> 31:06.520]  то мы ее уже можем сводить. Это мы уже поняли. Но с чего начать? Откуда хотя бы одну найти? Но вообще-то
[31:06.520 --> 31:13.800]  это не тривиальный вопрос, да, то есть это вообще не в любом классе есть полная задача. Значит, есть
[31:13.800 --> 31:23.080]  классы, в которых, ну по крайней мере, неизвестно есть полная или нет. Например, связанные с
[31:23.080 --> 31:32.160]  вероятностными вычислениями. Вот. Но здесь есть. И есть так называемая генерическая NP полная задача,
[31:32.160 --> 31:51.000]  generic. Значит, генерическая NP полная задача. Значит, обычно она TM SAT обозначается. TM это
[31:51.000 --> 32:01.680]  Turing-машин. То есть Turing-машин Satisfiability. Значит, выполнимость на машине Тюринга. Ну и на самом деле,
[32:01.680 --> 32:13.920]  так, как правило, если в классе есть полная задача, то в том числе вот такая задача будет в нем полной.
[32:13.920 --> 32:23.680]  Я сейчас напишу, что это такое. Наверное, нужно написать, иначе вообще непонятно, на чем речь.
[32:23.680 --> 32:31.720]  Значит, задача такая. Хотя на PMF это вроде должно было быть в семинарах, по крайней мере, в некоторых
[32:31.720 --> 32:42.280]  группах. Значит, задача такая. У нас есть тройка из машины, входа и еще некоторого ограничения в
[32:42.280 --> 32:51.400]  геонарной записи. Значит, вот эта степень, это значит единица, повторенная T раз. И, соответственно,
[32:51.400 --> 33:01.520]  требуется проверить следующее, что существует y, значит, такой, что m от x и y, во-первых,
[33:01.520 --> 33:17.440]  храняется единица, и, во-вторых, работает не больше, чем T шагов. То есть мы фактически зашили
[33:17.440 --> 33:24.600]  определение NP через сертификат, зашили определение этого языка. Вот эта вот называется генерическая
[33:24.600 --> 33:34.360]  задача, когда мы тот тип машины, через который определяется язык, зашиваем как часть условия задачи.
[33:34.360 --> 33:51.760]  Значит, NP-трудность в данном случае почти очевидна. Нужно взять определение NP через
[33:51.760 --> 34:00.880]  сертификаты. То есть нужно написать, что, скажем, х лежит в b, тогда и только тогда существует y,
[34:00.880 --> 34:12.160]  такое, что m от x и y равно единице. Дальше в том же определении сказано, что m работает полинарное
[34:12.160 --> 34:28.840]  время от длины x. Значит, m работает не больше, чем какой-то полином от длины x шагов. Ну и сводимость
[34:28.840 --> 34:46.640]  будет устроена так, что x отображается в тройку из m, x и единицы, повторённой как раз по длины x раз.
[34:46.640 --> 35:02.040]  Вот, значит, вот это сводимость. Ну и получается как раз по определению, что если есть такой y,
[35:02.040 --> 35:12.360]  то он как раз закончит работу за сколько нужно, и как раз это будет означать, что x лежит в b.
[35:12.360 --> 35:23.560]  А если такого y нет, то и тут такого y не будет, это будет означать, что x не лежит в b. Вот,
[35:23.560 --> 35:33.000]  значит, это трудность. Ну а для того, чтобы оно само лежало в NP, как раз важна вот здесь унарная
[35:33.000 --> 35:45.920]  запись, что m и t записываем в унарной запися. Значит, принадлежность к NP делается так, что вот это
[35:45.920 --> 35:50.800]  вот условие можно проверить как раз за полинарное время, ну, грубо говоря, через универсальную машину
[35:50.800 --> 36:14.480]  тюринга. Да, значит, что можно запустить m от x и y как раз на t шагов, значит, и тем проверить.
[36:14.480 --> 36:34.640]  Ну вот это условие. Проверить, что y подходит. Да-да-да, на вход какое-то описание машины тюринга.
[36:34.640 --> 36:44.120]  Ну универсальное как раз то, что мы здесь делаем. То есть когда мы запускаем m от x и y на t шагов,
[36:44.120 --> 36:51.400]  то да, мы используем машину тюринга. Значит, важно вот что. Важно, что моделирование одного шага,
[36:51.400 --> 36:57.760]  но требует какого-то не слишком большого числа шагов, поэтому общее число шагов вот этой
[36:57.760 --> 37:05.480]  проверки будет как раз, ну уж точно по линомам от t. Да, там t в квадрате может быть, там зависимость
[37:05.480 --> 37:10.720]  от деталей моделя. Но также важно, что это по линомам от t будет также по линомам от длины
[37:10.720 --> 37:17.080]  записи ровно за счет унарности вот здесь вот. То есть у нас есть t символов вот уже в этой части,
[37:17.080 --> 37:22.320]  и поэтому то, что работает по линомам от t, будет работать по линомам от длины входа. И поэтому это
[37:22.320 --> 37:45.920]  будет в NP. Так, ну что, какие-нибудь вопросы? Ну смотрите, значит тут то, что мы не обсудили,
[37:45.920 --> 37:54.920]  это вот эти вот, собственно, два исключения. Там, смотрите, какая фишка, что если p равно NP,
[37:54.920 --> 38:04.040]  то мы как бы, то любая задача из, вообще, если мы рассмотрим две задачи из P, то они будут друг
[38:04.040 --> 38:09.920]  другу сводиться за исключение того случая, когда кто-то из них вот такой вот. Да, значит,
[38:09.920 --> 38:21.600]  тут, знаете, я тут-то напишу, что можно, значит, смотрите, если там b0 не лежит в b, а b1 лежит в b,
[38:21.600 --> 38:32.200]  а a лежит в p. Тогда можно посмотреть на вот такую сводимость f от x, это будет b1,
[38:32.200 --> 38:44.680]  если x лежит в a, значит и b0, если x не лежит в a. И тут, смотрите, неважно, откуда мы взяли b0 и b1,
[38:44.680 --> 38:51.360]  потому что их всего две штуки. Если они, в принципе, есть, то вот такая сводимость будет
[38:51.360 --> 38:56.960]  пальномиальной, такая функция будет пальномиальной, поскольку вот это мы можем проверить за
[38:56.960 --> 39:16.240]  пальномиальное время. И это будет когда сводимость a к b. Ну, конечно, да. Нет, потому что если
[39:16.240 --> 39:22.080]  уберете сводимость из большего класса, а не из меньшего, да, вот то, что я вот здесь говорил,
[39:22.080 --> 39:29.800]  что нам сводимость нужна из меньшего класса. Но если они совпали, то мы, получается,
[39:29.800 --> 39:35.480]  взяли сводимость из большего класса. А тогда, если мы как бы и так умеем решать задачу,
[39:35.480 --> 39:40.760]  то не нужно ее куда-то сводить, мы ее просто решим. И именно это выражает вот та конструкция.
[39:40.760 --> 39:49.840]  Так, ладно, давайте сейчас сделаем перерывчик и потом поговорим про другие по полной задачи.
[39:49.840 --> 40:10.240]  Ну что ж, давайте продолжим. Давайте посмотрим на еще одну важную сводимость. Она тоже должна
[40:10.240 --> 40:20.720]  была быть на логике для PMI, а на PMF, наверное, не было. Но, тем не менее, давайте на нее посмотрим.
[40:20.720 --> 40:29.920]  Значит, есть такая задача 3. SAT. Это вариация задачи SAT, то есть выполненности формул.
[40:29.920 --> 40:45.800]  Да, то есть это множество таких формул ФИ, да, что ФИ имеет вид, имеет вид 3 KNF. Значит, и,
[40:45.800 --> 40:56.600]  ну, можно сказать, что ФИ лежит в SAT, да, то есть ФИ выполнимо. Что такое 3 KNF? Ну,
[40:56.680 --> 41:02.960]  вообще, KNF — это конъюнкция скобочек, где каждая скобочка — это дизюнкция переменных или отрицаний,
[41:02.960 --> 41:10.600]  а 3 KNF означает, что в каждой скобочке не больше трех литералов, то есть не больше трех переменных
[41:10.600 --> 41:22.400]  или их отрицаний. Да, то есть вот это вот, значит, конъюнкция, конъюнкция дизюнктов,
[41:22.400 --> 41:41.160]  конъюнкция дизюнктов из не более чем трех литералов. Вот. Ну, вот утверждается,
[41:41.160 --> 41:47.360]  что выполнимость любой формулы свойствует к выполнимости 3 KNF. Да, значит, при этом,
[41:47.360 --> 41:53.400]  заметим, в скобках это, ну, может, либо вернемся в какой-то момент, либо на семинарах, может быть,
[41:53.400 --> 42:05.960]  будет, да, значит, при этом два SAT, да, то есть аналог для два KNF — это задача ИСП. Ну, или,
[42:05.960 --> 42:12.760]  может, даже кто-то знает, как это решать. Ну, например, да, только доказать, что он сработает
[42:12.760 --> 42:24.280]  достаточно быстро. Да, вроде на PMI была такая задача даже. А, не знаю, где-нибудь на алгоритмах
[42:24.280 --> 42:41.880]  не было такой задачи? Было, да. Понятно. Два SAT, да. Хорошо, ладно, давайте это замечание в скобках.
[42:41.880 --> 42:53.600]  Вот, а вот про сводимость. Поговорим, да, утверждение, что, значит, SAT полинамиально сводится к три SAT.
[42:53.600 --> 43:09.640]  Ну, тут формально описание довольно громоздкое, так что давайте я на примере это покажу. Надеюсь,
[43:09.640 --> 43:17.280]  что будет понятно. Значит, вот пусть у нас какая-то есть формула, но она как-то выглядит, да,
[43:17.280 --> 43:30.560]  например, скажем, P и Q влечет, а тут, скажем, не R или S. Вот такая форма, она, конечно, очевидно,
[43:30.560 --> 43:37.200]  выполнима, но я на ее примере покажу, как сводимость работает. Значит, сводимость устроена так.
[43:37.200 --> 43:47.520]  Значит, мы фактически строим дерево синтактического разбора, то есть формула она из более мелких
[43:47.520 --> 43:54.080]  строится потихоньку более-более крупная, и вот только вся формула получается. Вот, и мы для каждой
[43:54.080 --> 44:04.280]  подформулы заведем свою новую переменную. Значит, например, вот это обозначим за T. Так,
[44:04.280 --> 44:11.960]  но тут можно сокращать, давайте я не буду сокращать. Значит, не R обозначим за U, вот это
[44:11.960 --> 44:25.800]  обозначим за V, и все вместе обозначим за W. И построим такую систему условий. 4 равняется P
[44:25.800 --> 44:41.760]  конъюнция Q, дальше U равняется не R, V равняется U или S, W равняется T, T влечет V,
[44:41.760 --> 44:53.840]  и еще W само по себе. Вот, и будем рассмотреть такую систему. Так, ну в общем случае, наверное,
[44:53.840 --> 44:59.960]  понятно, что делать, что мы строим полное дерево разбора, для каждой подформулы заводим новую
[44:59.960 --> 45:06.240]  переменную, делаем так, чтобы это было двоичное дерево, ну не более чем двоичное, либо отрицание,
[45:06.240 --> 45:15.760]  либо двоичная конъюнция, дизъюнция или импликация. Вот, если мы там делаем конъюнцию трех,
[45:15.760 --> 45:25.360]  то нужно на два шага разбить. Значит, и после этого записываем условия для каждой подформулы,
[45:25.360 --> 45:29.560]  записываем, что перемена, которая есть соответствует, равняется нужной функции,
[45:29.560 --> 45:35.400]  примененной к соответствующим компонентам. И кроме того, еще добавляем вот это последнее условие,
[45:35.400 --> 45:41.160]  что перемена соответствующей всей формуле должна быть истинна. Вот, равенство понимается как
[45:41.160 --> 45:49.400]  эквиваленция, как булева операция. Но утверждается, что вот эта система совместна тогда и только тогда,
[45:49.400 --> 45:57.000]  когда исходная формула совместна. Почему? Ну, в одну сторону. Пусть у нас есть набор,
[45:57.000 --> 46:03.440]  на котором формула истинна. Тогда это значит, что мы по этому синтактическому дереву считаем значение
[46:03.440 --> 46:10.120]  всех подформул и в итоге получаем единицу. Но мы в качестве каждой новой переменной как раз значение
[46:10.120 --> 46:15.200]  подформулы и возьмем. Которая получается, тогда ровно по правилам подсчета значения выражения
[46:15.200 --> 46:20.760]  это все будет выполнено. И в итоге получилось единица, значит и последняя тоже выполнена.
[46:20.760 --> 46:28.720]  Теперь наоборот. Пусть формула невыполнима. Это означает, что на любом значении она равна нулю.
[46:28.720 --> 46:39.440]  Но тогда с новыми переменными есть два варианта. Либо мы в какой-то момент новую переменную берем
[46:39.440 --> 46:45.600]  не по правилу вычислений, тогда соответствующее равенство будет ложно. Либо мы все вычисляем по
[46:45.600 --> 46:52.680]  правилу, тогда последнее w будет ложно. То есть хотя бы одно нарушение здесь будет. Но получается,
[46:52.680 --> 47:02.080]  что исходная формула выполнима тогда, когда такая система условий выполнима. А после этого
[47:02.080 --> 47:09.880]  тут в каждой строчке максимум три переменных. Просто потому что у нас были бинарные операции,
[47:09.880 --> 47:18.800]  у нас было два аргумента, и одна переменная это значение. Ну а дальше знаем же теорему,
[47:18.800 --> 47:26.640]  что любая формула к KNF приводится. Если там всего три переменных, то это будет три KNF. А потом
[47:26.640 --> 47:30.960]  мы возьмем большую конъюнцию всех этих KNF и получим ту форму, которая нужна.
[47:30.960 --> 47:44.960]  Ну что, понятно примерно? Это, конечно, пальномиальная процедура. То есть нужно обосновать,
[47:44.960 --> 47:50.840]  что синтактический разбор, это выражение со скобками, это пальномиальная процедура.
[47:50.840 --> 47:56.800]  Наверное, что-нибудь такое писали где-нибудь. Искать закрывающую скобку, выделять под формулы,
[47:56.800 --> 48:02.120]  что-нибудь такое. В общем, ясно, что это не очень сложная операция, и за пальном можно сделать.
[48:02.120 --> 48:15.680]  Нет, тут все-таки нужно правильно дерево построить еще. Нет, реально это работа со скобками. То есть
[48:15.680 --> 48:21.720]  нужно для каждой скобки находить парную и закрывающую, и дальше рекурсивно запускаться
[48:21.720 --> 48:29.200]  от этого фрагмента. Ну или не рекурсивно, а как-нибудь более умно. В общем, это ясно,
[48:29.200 --> 48:50.800]  что должно получиться. Но это примерно как было с 2 и 3 раскраской. Да, то есть тут, смотрите,
[48:50.800 --> 48:58.120]  если у вас скобки только из двух литералов, то если один из них ложный, то второй автоматически
[48:58.160 --> 49:11.920]  истинный. А если из трех и один ложный, то еще есть три варианта для оставшихся двух, и это увеличивает
[49:11.920 --> 49:20.960]  перебор. Примерно такая ситуация. Точно так же было с раскраской в два цвета. Если один конец
[49:20.960 --> 49:25.600]  ребра покрашен в один цвет, то другой точно в другой. А с 3 цветами же есть два варианта.
[49:25.600 --> 49:35.960]  И там этот перебор накапливался. Так, ну хорошо.
[49:35.960 --> 49:57.440]  Ну а сейчас познакомимся с теоремой, с которой вообще началась вот эта вся история с PNP.
[49:57.440 --> 50:11.680]  Долгое время она называлась теоремой Кука даже в русскоязычной литературе, но потом справедливая
[50:11.680 --> 50:18.880]  атрибуция восторжествовала, и она называется теоремой Кука-Левина. Это я обсуждал на первой
[50:18.880 --> 50:26.600]  лекции, что Кук и Левин одновременно, независимо друг от друга, в разных странах и в разных
[50:26.600 --> 50:45.360]  терминах, но в принципе доказали одно и то же. Теорема Кука-Левина. Ну можно, если коротко,
[50:45.360 --> 50:54.560]  просто написать, что SAT это NP-полная задача. Ну и как следствие три SAT тоже NP-полная задача.
[50:54.560 --> 51:03.480]  Да, вот из предыдущего утверждения отсюда следует, что три SAT это тоже NP-полная задача,
[51:03.480 --> 51:16.120]  и собственно дальнейшие свадимости будут именно с три SAT начинаться. Любую задачу свели к SAT,
[51:16.120 --> 51:23.040]  потом SAT к три SAT, а потом три SAT уже куда сводятся, и там такое дерево разрастающееся
[51:23.040 --> 51:36.480]  получается дерево свадимости, они все друг другу сводятся. Смотрите, у нас уже был пример в самом
[51:36.480 --> 51:48.240]  начале, что мы три раскраску свели к SAT. Ну и в принципе так не очень удивительно, что поиск
[51:48.240 --> 51:56.760]  любого конкретного Y можно свести к каким-то логическим условиям, но все-таки тут чтобы
[51:56.760 --> 52:04.480]  получилось полное доказательство, нужно так или иначе рассуждать про какие-то низкоуровневые
[52:04.480 --> 52:15.760]  детали того, как машина тюринга устроена, на которой это все происходит. Давайте доказывать,
[52:15.760 --> 52:27.480]  для одноленточной машины и для сертификатного определения. Доказательства. Тут будет
[52:27.480 --> 52:35.880]  одноленточная машина, одноленточная машина тюринга и сертификатное определение.
[52:35.880 --> 52:55.440]  Надо как-то закодировать данные. Это опять же можно делать по-разному, но смотрите, у нас есть
[52:55.440 --> 53:03.200]  одноленточная машина, у нее есть одна лента, где-то в одной ячейке, в каждый момент в одной ячейке
[53:03.200 --> 53:14.920]  находится головка управляющая и машина в каком-то состоянии. Есть понятие конфигурации машины
[53:14.920 --> 53:23.400]  тюринга, состоит из содержимого ленты, координаты указателя и состояния машины.
[53:23.400 --> 53:37.920]  Конфигурация – это содержимые ленты, содержимые ленты плюс положение указателя
[53:37.920 --> 53:52.920]  и плюс состояние машины. Один из способов это все кодировать, это все написать в одну строчку.
[53:52.920 --> 54:08.200]  Значит, вот так вот можно написать, сертификат тоже где-то на этой ленте записан, то есть нет,
[54:08.200 --> 54:17.280]  не будет отдельной ленты для сертификата. Нет, а сертификаты мы тоже будем считать полимонной
[54:17.280 --> 54:31.280]  длины. Просто смотрите, время работы машины тюринга полиномиально длины входа, а не сертификата,
[54:31.280 --> 54:37.400]  и поэтому длину сертификата тоже можно ограничить тем же самым полиномом, поэтому все-таки оно будет
[54:37.400 --> 54:47.480]  конечное. Так, давайте я допишу. Это вот такой способ кодирования, когда а маленькая – это символ
[54:47.480 --> 55:00.320]  алфавита, а и b большие – это слова и какое это состояние. Имеется в виду следующее, что вот
[55:00.320 --> 55:10.440]  это одна лента, здесь записано слово, до него идут сплошные бланки, при этом внутри а и b больших
[55:10.440 --> 55:19.280]  тоже могут быть бланки. Это не запрещено, но заведомо, что левее а только все пустые клетки.
[55:19.280 --> 55:30.600]  Дальше здесь символ а, на него указывает машина, находится состояние q, дальше слово b и дальше тоже
[55:30.600 --> 55:43.760]  бланки. Вот так вот мы будем кодировать. Смотрите, машина работает какое-то время полиномиальное,
[55:43.760 --> 55:53.520]  и соответственно в каждый момент времени будет своя конфигурация. И мы будем рассматривать таблицу
[55:53.520 --> 56:09.040]  с этой конфигурацией, на которой будет как бы выровненное. И можно заранее ограничить размер,
[56:09.040 --> 56:16.960]  если мы знаем время работы машины тюринга, то ясно, что число, опять же при стандартной модели,
[56:16.960 --> 56:25.720]  когда за один шаг можно сместиться только на одну ячейку, заведомо число использованных ячеек будет
[56:25.720 --> 56:36.640]  не больше, чем время работы. А время работы у нас полиномиальное. И тут получается такая таблица,
[56:36.640 --> 56:46.080]  я ее так нарисую, а дальше я перерисую покрупнее. Вот здесь вот будет какое-то время t.
[56:46.080 --> 57:03.960]  Здесь соответственно тоже можно выделить t ячеек. Тут будет начальная конфигурация,
[57:03.960 --> 57:18.200]  начальная конфигурация, дальше там следующая конфигурация, и так далее. И в последний момент
[57:18.200 --> 57:26.880]  будет какая-то итоговая конфигурация. И нам нужно сказать следующее, что в начальной конфигурации
[57:26.880 --> 57:38.520]  будет x фиксирован, а еще где-то там будет y, то есть сертификат. И собственно это будет степень свободы,
[57:38.520 --> 57:46.120]  что y может быть какой угодно. А дальше мы хотим, чтобы все переходы были корректные, а в итоге
[57:46.120 --> 57:53.360]  была бы принимающая конфигурация, чтобы вот эта итоговая была принимающей. И вот это все нам нужно
[57:53.360 --> 58:01.000]  записать формулой, причем полиномиального размера. Ну по крайней мере пока что ясно,
[58:01.000 --> 58:07.360]  что у нас полиномиальное число переменных, потому что у нас число символов вообще константа.
[58:07.360 --> 58:14.120]  Символы это либо символ алфавита, либо символы состояний и того и другого константа, в смысле,
[58:14.120 --> 58:24.960]  что не зависит от x. Число символов константа, число ячеек t в квадрате, а t это полином,
[58:24.960 --> 58:32.920]  то есть квадрат полинома это тоже полином, значит у нас всего полином переменных. Но конечно от
[58:32.920 --> 58:37.720]  полинома переменных могут быть формулы длины экспонента, поэтому нам нужно показать, что здесь
[58:37.720 --> 58:40.360]  формулу можно так построить, что она тоже будет длиной полином.
[58:40.360 --> 58:54.720]  Не, сейчас, у нас вот такие вот слова записаны.
[58:54.720 --> 59:06.200]  Q прям как символ в ячейке тоже. Сейчас, смотрите, вот здесь вот, внутри таблицы,
[59:06.200 --> 59:18.200]  здесь будет не так, как вот здесь, а будет вот так. Значит A, потом Q, потом A и потом B.
[59:18.200 --> 59:27.240]  Q это состояние, и Q мы тоже прям в ячейку напишем.
[59:27.240 --> 59:32.400]  Ну мы это символом будем называть.
[59:32.400 --> 59:44.080]  Ну да, то есть нужно сделать так, чтобы символы леночного алфавита не пересекались состоянием
[59:44.080 --> 59:49.840]  машины, и значит по коду в ячейке могли бы понять однозначно, что это такое.
[59:49.840 --> 59:56.800]  Ну типа того, да.
[59:56.800 --> 01:00:13.000]  Так, ну хорошо, давайте я тут еще чуть-чуть подробнее нарисую.
[01:00:13.000 --> 01:00:18.600]  В таблице конкретное исполнение.
[01:00:18.600 --> 01:00:29.240]  Ну сейчас вот поговорим про это. Значит, во-первых, как выглядит начальная конфигурация.
[01:00:29.240 --> 01:00:32.960]  Значит, есть какое-то начальное состояние Q1.
[01:00:32.960 --> 01:00:47.320]  Да, давайте еще считать, что у нас лента слева ограничена, что у нас лента на стороне только вправо.
[01:00:47.320 --> 01:01:00.400]  Для удобства будем так считать. Соответственно, здесь будет Q1, дальше будет X,
[01:01:00.400 --> 01:01:16.240]  значит, некоторый блок, дальше пробел, значит, дальше Y, ну и дальше пробелы до конца.
[01:01:16.240 --> 01:01:23.920]  Вот это мы будем называть начальной конфигурацией.
[01:01:23.920 --> 01:01:33.480]  Теперь дальше, будем нумеровать, давайте с нуля нумеровать, значит, ноль.
[01:01:33.480 --> 01:01:51.960]  Не, подождите, у нас есть X, который вход, написано на ленте, но кроме того, мы используем
[01:01:52.000 --> 01:01:57.480]  сертификатное определение, то есть кроме X еще есть сертификат Y, и мы будем считать,
[01:01:57.480 --> 01:02:02.000]  что они закодированы так просто через пробел, написано на одной и той же ленте.
[01:02:02.000 --> 01:02:15.920]  Так, в общем, строки нумируют момент времени, ну и последнее будет какое-то P от N.
[01:02:15.920 --> 01:02:30.320]  Вот, остался и нумеруют положение на ленте, ну и тоже, значит, будет 0, 1,
[01:02:30.320 --> 01:02:42.160]  значит, так далее N, да, X длины N, значит, N, тут N плюс 1, значит, N плюс 2 и так далее, ну тут
[01:02:42.160 --> 01:02:56.160]  какой-нибудь там M, ну и так далее, здесь тоже P от N, потому что как раз даже если указатель каждый
[01:02:56.160 --> 01:03:01.360]  раз будет сдвигаться направо на один шаг, то он за P от N шагов как раз только до P от N сможет
[01:03:01.360 --> 01:03:15.880]  сдвинуться. Вот, значит, итоговая формула будет из трех частей состоять, значит,
[01:03:15.880 --> 01:03:33.560]  Phi будет состоять из трех частей, значит, Phi start и Phi accept и Phi step. Да, давайте еще
[01:03:33.560 --> 01:03:39.360]  словимся так, что если машина пришла в завершающее состояние, а время еще не кончилось, то дальше она
[01:03:39.360 --> 01:03:45.600]  просто ничего не меняет, то есть если где-то здесь по дороге это члене завершилось, то дальше все
[01:03:45.600 --> 01:03:55.320]  последующие строчки будут тем же самыми. Так, хорошо, значит, как устроены эти формулы.
[01:03:55.320 --> 01:04:12.960]  Phi start, ну Phi start выражает, что, а, во-первых, какие у нас переменные, ну переменные у нас в каждой
[01:04:12.960 --> 01:04:24.240]  ячейке будет столько переменных, чтобы было достаточно закодировать любой символ алфавита и любое состояние.
[01:04:42.960 --> 01:04:55.200]  Так, значит, тут так, P у нас полинов, ну давайте скажем Q и gt. Значит, Q и gt это набор переменных,
[01:04:55.200 --> 01:05:08.720]  кодирующий символ в ячейке и g. Значит, это набор переменных. Ой, Q у нас состояние. Так, какие у нас еще буквы есть?
[01:05:08.720 --> 01:05:23.640]  Ну не знаю, s давайте. Так, значит, набор переменных, кодирующий символ, о, s от слова символ,
[01:05:23.640 --> 01:05:37.840]  кодирующий символ в ячейке и g. Так, значит, смотрите, как будет выглядеть Phi start. Значит,
[01:05:37.920 --> 01:05:46.840]  Phi start фактически означает, что вот там написано то, что действительно, что в ячейке тоже то, что здесь написано,
[01:05:46.840 --> 01:05:55.000]  но есть тонкость с этим y, потому что y мы заранее не знаем. Мы заранее не знаем, но мы знаем все-таки,
[01:05:55.000 --> 01:06:02.640]  что y никакое угодно, а он должен состоять из битов, из нулей и единиц. Но вот это и запишем.
[01:06:02.640 --> 01:06:29.200]  Значит, Phi start выглядит так. Значит, s00 это q1 и s01 это x1 и так далее, и s0n это xn.
[01:06:29.200 --> 01:06:50.560]  Дальше s0n1 это пробел. И дальше будет так. Значит, s0n2 это, так, давайте я тут покажу,
[01:06:50.560 --> 01:07:06.320]  в кавычке возьму ноль, что это как бы символ 0. Или s0n2 это символ 1. Ну дальше и так далее,
[01:07:06.320 --> 01:07:27.360]  и так до m. И s0m2 это 0, или s0m2 это 1. И все последующие должны быть пустыми.
[01:07:27.360 --> 01:07:41.920]  Значит, m плюс 1 это бланк и так далее. Последний это бланк. Так, какой вопрос?
[01:07:41.920 --> 01:07:49.800]  Давай считать, что мы это знаем, потому что это определяется алгоритмом, который используется.
[01:07:49.800 --> 01:08:00.200]  То есть мы знаем машину тюринга. В принципе, m это какой-то полином. В принципе, даже смотрите,
[01:08:00.200 --> 01:08:07.040]  если даже у вас используются сертификаты разной длины, то вы, например, можете использовать
[01:08:07.040 --> 01:08:13.720]  беспрефиксные кодирования и дополнять каким-то мусором, и тогда у вас те сертификаты станут одной длины.
[01:08:13.720 --> 01:08:28.360]  Это правда, но есть общая граница, это время работы. В принципе, можно считать,
[01:08:28.360 --> 01:08:36.560]  что этого блока вообще нету, а m просто идет прям досюда. В какой-то момент алгоритм решит,
[01:08:36.560 --> 01:08:41.040]  что он уже все прочел из сертификата, все остальное можно стирать и использовать для вычислений.
[01:08:41.040 --> 01:08:54.480]  А x у нас есть заранее. Смотрите, мы по x устроим формулу, и на самом деле это ровно
[01:08:54.480 --> 01:08:59.080]  то место, где мы используем, какой у нас был x. Больше мы x нигде не используем.
[01:08:59.080 --> 01:09:11.520]  Дальше phi accept будет очень простым. Будет просто, что где-то в последней строке
[01:09:11.520 --> 01:09:26.280]  будет принимающее состояние q accept или и так далее, или s, p от n, p от n, это будет q accept.
[01:09:26.280 --> 01:09:43.400]  Phi accept означает, что мы пришли в принимающее состояние. Ну и последнее, самое интересное,
[01:09:43.400 --> 01:09:55.920]  это phi step. Как записать, что все шаги корректны? Тут есть некоторая ключевая идея.
[01:09:55.920 --> 01:10:01.720]  Потому что, смотрите, вообще, конечно, каждая следующая строчка однозначно определяется
[01:10:01.720 --> 01:10:10.200]  предыдущей строчкой. Но если мы просто как попало это запишем, то у нас будет как бы полином
[01:10:10.200 --> 01:10:15.640]  аргументов, функция полинома аргументов может иметь экспоненциальную запись, если мы просто ее
[01:10:15.640 --> 01:10:22.720]  стандартным образом куда-то приводим. И важно следующее, важно, что на самом деле именно в
[01:10:22.720 --> 01:10:30.360]  машине тюринга любые изменения происходят очень локально. Смотрите, как работает машина тюринга.
[01:10:30.360 --> 01:10:45.800]  У нее есть место указателя, и она заменяет вот эту клетку, куда указывает, и еще сдвигается либо налево,
[01:10:45.800 --> 01:10:51.800]  либо направо. Соответственно, получается, что если клетка больше, чем на расстоянии 1 от положения
[01:10:51.800 --> 01:10:58.220]  головки, то клетка вообще точно не изменится. То есть вообще почти вся лента не изменится, кроме небольшой
[01:10:58.220 --> 01:11:06.680]  окрестности того места, где стоит указатель. Ну и на самом деле это можно выразить вот так вот.
[01:11:06.680 --> 01:11:21.720]  Можно выразить вот так вот, что мы рассмотрим четыре клетки подряд, и утверждается следующее,
[01:11:21.720 --> 01:11:29.680]  что вот эта вот клетка однозначно зависит от этих четырех. Значит, это однозначно
[01:11:29.680 --> 01:11:42.240]  определяется четырьмя верхними. Так, почему четырьмя? Почему не симметрично? Но это с нашим
[01:11:42.240 --> 01:11:51.520]  соглашением связано, что мы состояние и символ пишем в разных клетках, и тогда, например, если вот
[01:11:51.520 --> 01:11:57.600]  здесь стоит состояние, то тогда, например, то куда сдвинется машина зависит от того, какой символ
[01:11:57.600 --> 01:12:04.640]  вот здесь. И, соответственно, она может сдвинуться вот сюда, а может не сдвинуться. А в остальном,
[01:12:04.640 --> 01:12:13.920]  применив правила машин тюринга, можно посмотреть, что это будет. То есть, например, если не здесь,
[01:12:13.920 --> 01:12:21.160]  не здесь, не здесь нет состояния, то просто нужно скопировать то, что вот здесь. Если, например...
[01:12:21.160 --> 01:12:27.760]  В смысле, почему проиграли? Смотрите, вот это...
[01:12:35.760 --> 01:12:43.000]  Не-не-не, сейчас, подождите. Вот такие вот треугольнички, не треугольнички, а пентамины такие,
[01:12:43.000 --> 01:12:51.000]  они по всем клеткам ездят, то есть вот такая функция, она так ездит слева направо и вычисляет,
[01:12:51.000 --> 01:12:58.680]  каждую следующую клеточку. Как она работает? Примерно, что если не здесь, не здесь, не здесь нет
[01:12:58.680 --> 01:13:04.760]  указателя, то она просто копирует символ отсюда, а если где-то здесь есть указатель, то есть символ
[01:13:04.760 --> 01:13:12.560]  состояния, то она смотрит в программу и меняется соответствующим образом. В общем, в итоге...
[01:13:12.560 --> 01:13:20.320]  У меня две минуты остается. В итоге фисте будет выглядеть примерно вот так вот. Это будет
[01:13:20.320 --> 01:13:33.120]  большая конъюнция. Значит, большая конъюнция по i от единицы до p от n, а j от нуля до p от n.
[01:13:33.120 --> 01:13:45.720]  И будет вот так вот, что s, i, t, j, t это будет некоторая конкретная функция, которая определяется в
[01:13:45.720 --> 01:14:02.720]  машине тюринга f от, соответственно, s, i-1, j-1, s, i-1, j, t, s, i-1, j-1 и s, i-1, j-2,
[01:14:02.720 --> 01:14:13.800]  где вот эта функция f одна и та же для всей таблицы и определяется машиной тюринга.
[01:14:13.800 --> 01:14:21.720]  Значит, соответственно, это может быть большая формула, но ее размер не зависит от x. То есть
[01:14:21.720 --> 01:14:30.800]  эта формула большая, но константная. И размер всей формулы будет как раз паттерн в квадрате в этой
[01:14:30.800 --> 01:14:36.720]  фист-степ. Ну и дальше нужно уже лезть в детали, доказывать, что если это все выполнено, то
[01:14:36.720 --> 01:14:42.120]  действительно вся таблица это корректное вычление машины тюринга. Ну и после этого что
[01:14:42.120 --> 01:14:49.000]  получается? Получается, что если x лежало в языке, то тогда было корректное вычисление для какого-то
[01:14:49.000 --> 01:14:56.120]  y, и если мы его подставим вот в эту формулу, то все условия сойдутся, все условия корректности
[01:14:56.120 --> 01:15:02.440]  сойдутся. Но и наоборот, если есть корректное вычисление, то ровно так должна работать машина
[01:15:02.440 --> 01:15:10.720]  для вот этого данного x и того y, который получается из значений вот этих вот переменных. И отсюда
[01:15:10.720 --> 01:15:15.560]  будет получаться, что из выполнимости следует, что x лежал в том языке, потому что для него был
[01:15:15.560 --> 01:15:23.800]  хороший сертификат. Ну вот вроде все. Спасибо за внимание.
