[00:00.000 --> 00:20.280]  Добрый день.
[00:20.280 --> 00:23.920]  Мы продолжаем говорить про графы, про приложение
[00:23.920 --> 00:24.920]  DFS.
[00:24.920 --> 00:28.840]  Напомню, в прошлый раз мы сделали следующее.
[00:28.840 --> 00:30.680]  Мы определили, что такое мост.
[00:30.680 --> 00:34.880]  Мост – это ребро в неориентированном графе, такое, что его удаление
[00:34.880 --> 00:36.280]  делает граф несвязанным.
[00:36.280 --> 00:38.720]  То есть, изначально мы считаем, что граф связанный, удаляем
[00:38.720 --> 00:46.120]  вот это одно ребро, тогда граф становится несвязанным.
[00:46.120 --> 00:50.200]  Удаление которого делает граф несвязанным.
[00:50.200 --> 01:05.120]  Хочется тогда понять, что будет, если таких ребер
[01:05.120 --> 01:06.120]  нет.
[01:06.120 --> 01:08.360]  То есть, как выглядят такие графы, в которых нет мостов,
[01:08.360 --> 01:11.120]  и соответственно, как выглядят такие кусочки в каком-то
[01:11.120 --> 01:13.160]  произвольно связанном графе, в котором есть мосты.
[01:13.160 --> 01:16.440]  То есть, удалили какие-то кусочки, которые вот становятся
[01:16.440 --> 01:18.600]  несвязанными после удаления никакого одного ребра.
[01:18.600 --> 01:28.960]  Определение, пусть же это неориентированный граф,
[01:28.960 --> 01:30.800]  тогда мы вводим такое отношение эквивалентности.
[01:30.800 --> 01:52.440]  Говорим, что вершины У и В, ребер надвусвязаны.
[01:52.440 --> 01:55.560]  Если существует два пути между ними, два пути между
[01:55.560 --> 02:01.040]  У и В, такие, что они не пересекаются по ребрам.
[02:01.040 --> 02:15.640]  Если между У и В существует два пути, которые не имеют
[02:15.640 --> 02:19.320]  общих ребер, напишу так, которые не имеют общих
[02:19.320 --> 02:20.320]  ребер.
[02:20.320 --> 02:34.040]  Ну, значит, картинка какая-то такая, вот есть две вершинки,
[02:34.040 --> 02:36.920]  есть какой-то один путь, есть какой-то другой путь.
[02:36.920 --> 02:40.040]  Потенциально они могут пересекаться, но только по вершинам.
[02:40.040 --> 02:43.480]  То есть, возможно, есть в пересечении этих путей
[02:43.480 --> 02:45.920]  какая-то общая вершина, или они могут несколько
[02:45.920 --> 02:46.920]  раз пересекаться.
[02:46.920 --> 02:49.880]  Но главное, что нет общих ребер.
[02:49.880 --> 02:52.160]  Тогда мы говорим, что они находятся в этом отношении
[02:52.160 --> 02:54.080]  эквивалентности реберной двусвязанности.
[02:54.080 --> 02:59.280]  Как всегда, для приличия надо доказать, что это отношение
[02:59.280 --> 03:00.280]  эквивалентности.
[03:00.280 --> 03:05.520]  Реберная двусвязанность – это отношение эквивалентности
[03:06.400 --> 03:08.440]  на вершинах.
[03:13.040 --> 03:18.600]  Мы это сейчас с вами докажем, потом поймем, как в графе
[03:18.640 --> 03:20.000]  выделить компоненты реберной двусвязlavности.
[03:20.000 --> 03:26.240]  И тогда как раз компоненты – это такие множества
[03:26.240 --> 03:28.480]  вершин, компоненты реберной двусвязанности, которые
[03:28.480 --> 03:30.680]  получаются в факторизации по этому отношению, íкотор
[03:30.680 --> 03:33.040]  мы докажем, что они являются отношением эквивалентности.
[03:33.040 --> 03:37.040]  это когда между любыми двумя вершинами есть, по сути, два непересекающихся пути.
[03:37.040 --> 03:39.040]  Ну, по ребрам, по крайней мере.
[03:39.040 --> 03:42.040]  И это значит, что если вы какое-то одно конкретное ребро удалите,
[03:42.040 --> 03:44.040]  то граф останется связным.
[03:44.040 --> 03:47.040]  Потому что, если оно и участвовало в каком-то пути от У до В,
[03:47.040 --> 03:51.040]  то обязательно существует какой-то другой путь от У до В, который это ребро не содержит.
[03:51.040 --> 03:53.040]  Потому что он с этим путем не пересекается вообще.
[03:53.040 --> 03:56.040]  Значит, если мы рассмотрим все такие компоненты,
[03:56.040 --> 03:59.040]  то это будут как раз вот такие куски, что в них нет мостов.
[03:59.040 --> 04:02.040]  Наибольшие, по включению множества, такие, что в них нет мостов.
[04:02.040 --> 04:04.040]  У них нет мостов.
[04:04.040 --> 04:07.040]  Так, ну, здесь, значит, как всегда.
[04:07.040 --> 04:10.040]  Что у нас? Рефлексивность.
[04:12.040 --> 04:18.040]  Ну, понятно, если У равно В, то между ними, конечно, существует два пути.
[04:18.040 --> 04:21.040]  Надо просто стоять на месте, там ноль ребер, и они поэтому не пересекаются.
[04:21.040 --> 04:23.040]  По ребрам пересечений нет.
[04:23.040 --> 04:25.040]  Симметричность, очевидно.
[04:27.040 --> 04:30.040]  Потому что если есть два пути из У в В, не пересекаются,
[04:30.040 --> 04:32.040]  то есть, собственно, пути из В в У.
[04:32.040 --> 04:35.040]  Потому что граф не ориентирован, ребра можно проходить справа налево,
[04:35.040 --> 04:38.040]  все останется точно так же, они пересекаться не будут.
[04:38.040 --> 04:41.040]  Вот, ну и третья, транзитивность здесь чуть похитрее.
[04:43.040 --> 04:44.040]  Транзитивность.
[04:44.040 --> 04:49.040]  Смотрите, вот есть у меня два пути от У до В, реберно не пересекающиеся.
[04:50.040 --> 04:54.040]  Есть два пути от В до ВВ, тоже реберно не пересекающиеся.
[04:55.040 --> 04:58.040]  Я как-нибудь вот так вот нарисую.
[05:01.040 --> 05:06.040]  Основная проблема может быть в том, что когда я рисую вот эти вот пути от В до ВВ,
[05:06.040 --> 05:09.040]  они могут как-то пересекаться с тем, что я нарисовал раньше.
[05:09.040 --> 05:13.040]  Могут пересекаться по ребрам с путями, которые от У до В идут.
[05:14.040 --> 05:19.040]  Поэтому просто склеить, скажем, пути от У до В, от В до ВВ,
[05:19.040 --> 05:22.040]  одну пару пути склеить и другую пару пути склеить, возможно, не получится,
[05:22.040 --> 05:25.040]  потому что у них может быть где-то вот здесь пересечение, скажем.
[05:25.040 --> 05:27.040]  Если эта штука содержала какое-то ребро здесь,
[05:27.040 --> 05:31.040]  то тогда нельзя брать вот эту вот часть пути от У до В.
[05:31.040 --> 05:33.040]  Нам будет такое пересечение.
[05:33.040 --> 05:36.040]  Поэтому надо чуть более тонко здесь рассуждать.
[05:37.040 --> 05:39.040]  Давайте скажем следующее.
[05:39.040 --> 05:46.040]  Пусть С это реберно простой цикл
[05:46.040 --> 05:56.040]  между У и В.
[05:58.040 --> 06:02.040]  Мы знаем, что между У и В есть два ребра непересекающихся пути.
[06:02.040 --> 06:05.040]  Значит, есть какой-то цикл.
[06:05.040 --> 06:08.040]  Ну, собственно, если вот эти два пути пройти вот так вот,
[06:08.040 --> 06:11.040]  сначала от У до В, потом от В до У, то это будет реберно простой цикл.
[06:11.040 --> 06:15.040]  То есть это какой-то цикл такой, что все ребра в нем не повторяются.
[06:16.040 --> 06:19.040]  Значит, вот его рассмотрим, говорим, что это С.
[06:19.040 --> 06:22.040]  Все вершинки, все ребра образуют цикл С.
[06:22.040 --> 06:30.040]  Дальше пусть, я скажу так,
[06:30.040 --> 06:38.040]  П1 и П2 это два пути от В до В, которые не имеют общих ребер.
[06:38.040 --> 06:43.040]  Ну и, наконец, пусть Q1 и Q2
[06:43.040 --> 06:51.040]  это первые вершины соответствующих пути, которые попали на цикл С.
[06:54.040 --> 06:58.040]  Вот это все.
[06:58.040 --> 07:02.040]  Пусть С это реберно простой цикл,
[07:02.040 --> 07:05.700]  Это первые вершины соответствующих путей, которые попали на
[07:05.700 --> 07:10.200]  цикл С.
[07:10.200 --> 07:17.800]  Первые вершины путей P1 и P2, которые лежат в С.
[07:17.800 --> 07:28.400]  То есть есть наш цикл С, давайте я его так разверну
[07:28.400 --> 07:31.240]  для удобства, чтобы он не сам пересекался.
[07:31.240 --> 07:33.840]  Есть у него две вершинки у и в.
[07:33.840 --> 07:37.240]  Дальше есть два пути, P1 и P2, которые начинают где-то
[07:37.240 --> 07:40.440]  там в W и как-то вот так вот ходят, и оба заканчиваются
[07:40.440 --> 07:41.440]  в В.
[07:41.440 --> 07:43.360]  Давайте просто тогда, здесь он может быть много раз
[07:43.360 --> 07:46.080]  пересекает цикл С, возможно даже по ребрам пересекает,
[07:46.080 --> 07:48.320]  но давайте просто рассмотрим первое пересечение по вершине,
[07:48.320 --> 07:50.760]  вот эта вершинка и вот эта вершинка, соответственно
[07:50.760 --> 07:51.760]  Q1, Q2.
[07:51.760 --> 07:57.580]  Просто в пути от W до В находим, какая первая вершина лежит
[07:57.580 --> 08:11.580]  на цикле С и говорим, что это Q1, Q2.
[08:11.580 --> 08:21.500]  Тогда давайте картинку перерисую.
[08:21.500 --> 08:22.500]  Что мне нужно?
[08:22.500 --> 08:24.700]  Мне нужно найти два ребер на не пересекающиеся пути
[08:24.700 --> 08:26.900]  от У до W.
[08:26.900 --> 08:30.400]  При этом у меня есть какой-то цикл С, на нем отмечены две
[08:30.400 --> 08:33.280]  точки Q1, Q2.
[08:33.280 --> 08:37.880]  Такие что из вот этих вот Q1, Q2 есть такие пути до W,
[08:37.880 --> 08:40.880]  которые между собой не пересекаются и с циклом не пересекаются.
[08:40.880 --> 08:45.620]  Еще раз, они не пересекаются, вот эти два кусочка не пересекаются
[08:45.620 --> 08:49.080]  между собой, потому что это куски путей по 1 по 2 с одной
[08:49.080 --> 08:50.080]  стороны.
[08:50.080 --> 08:52.120]  С другой стороны они не пересекаются с ребрами цикла
[08:52.120 --> 08:54.860]  С, потому что если бы пересекались, то соответственно на этих
[08:54.860 --> 08:57.260]  кусках была бы более ранняя вершина, которая лежала
[08:57.260 --> 08:58.260]  бы в цикле.
[08:58.260 --> 09:02.980]  Вот это вот все, это ребра и вершины, не лежащие в
[09:02.980 --> 09:03.980]  С.
[09:03.980 --> 09:05.700]  Значит, можно поступить очень просто.
[09:05.700 --> 09:09.740]  Можно от У, скажем, идя в одну сторону, дойти до Q2,
[09:09.740 --> 09:13.540]  затем взять вот эту часть, давайте напишу, что это часть
[09:13.540 --> 09:14.540]  пути по 2.
[09:14.540 --> 09:19.100]  И то же самое здесь, от У дойти сначала до Q1, потом
[09:19.100 --> 09:25.860]  закончится частью пути по 1, часть пути по 1.
[09:25.860 --> 09:30.080]  Ну и все, и у нас получилось как раз два ребер на простых
[09:30.080 --> 09:31.080]  пути.
[09:31.080 --> 09:35.220]  То есть тут идея, конечно, такая, что нужно просто склеить
[09:35.220 --> 09:37.940]  путь от У до В, потом от В до W, только нужно немножко
[09:37.940 --> 09:39.740]  поаккуратнее это сделать, потому что если в тупую
[09:39.740 --> 09:42.340]  склеить, то они могут пересекаться, чтобы этого исключить надо
[09:42.340 --> 09:44.220]  просто взять вот какие-то экстремальные вершины, самые
[09:44.220 --> 09:48.900]  близкие к W, и потом вот так вот наш цикл обойти.
[09:48.900 --> 09:54.020]  Так, ну и вот, я утверждаю, что вне зависимости от того,
[09:54.020 --> 09:57.300]  как Q1, Q2 попали в этом цикле, у нас обязательно получится
[09:57.300 --> 09:58.300]  так сделать.
[09:58.300 --> 09:59.740]  Но потому что картинка будет обязательно такая.
[09:59.740 --> 10:02.540]  Есть какой-то цикл, в нем выделена вершина У, еще какие-то
[10:02.540 --> 10:08.820]  две вершины Q1, Q2, которые могут совпадать, и при этом
[10:08.820 --> 10:10.980]  нам не важно, в каком у них порядке расположены.
[10:10.980 --> 10:15.380]  Например, там могло быть, наоборот, тут Q1, тут Q2, или
[10:15.380 --> 10:16.980]  они вообще могли быть одной вершиной.
[10:16.980 --> 10:19.140]  Но это ничего не меняет, даже давайте, вот худший
[10:19.140 --> 10:22.420]  случай, когда они равны, когда это одна и та же вершина.
[10:22.420 --> 10:26.900]  Тогда можно просто от У, скажем, против числа дойти
[10:26.900 --> 10:32.180]  до Q1, затем взять вот эту часть пути по 2, ну, окей,
[10:32.180 --> 10:35.220]  часть одного пути дойти до W, и потом пройти в другом
[10:35.220 --> 10:37.220]  направлении, взять часть другого пути тоже дойти
[10:37.220 --> 10:38.220]  до W.
[10:38.220 --> 10:40.780]  Здесь будет пересечение по вершине этих двух путей,
[10:40.780 --> 10:45.380]  но не по ребрам, потому что эти ребра цикла, тут нет
[10:45.380 --> 10:46.380]  одинаковых ребер.
[10:46.380 --> 10:49.700]  Ну, здесь я уже тоже говорил, что здесь ребра не пресекаются,
[10:49.700 --> 10:52.420]  то есть нет общих ребер, и у частей этих путей тоже
[10:52.420 --> 10:55.780]  нет ребер из цикла, поэтому мы получили два хороших
[10:55.780 --> 10:56.780]  пути.
[10:56.780 --> 10:57.780]  Согласны?
[10:57.780 --> 11:01.940]  Ну, значит, есть транзитивность, значит, отношение эквивалентности
[11:01.940 --> 11:05.620]  и, значит, есть, как бы, основание говорить о компонентах
[11:05.620 --> 11:06.620]  ребер над усвязанностью.
[11:06.620 --> 11:35.300]  Компоненты ребер над усвязанностью, ну, это просто класс эквивалентности
[11:35.300 --> 11:38.660]  по тому отношению, которое мы так что ввели.
[11:38.660 --> 11:52.980]  Класс эквивалентности относительно, давайте, по отношению ребер
[11:52.980 --> 11:53.980]  над усвязанностью.
[11:53.980 --> 12:03.860]  Так, ну, и, соответственно, вопрос, как найти эти компоненты,
[12:04.540 --> 12:05.540]  ребер над усвязанностью.
[12:05.540 --> 12:07.940]  Ответ очень простой.
[12:07.940 --> 12:10.860]  Достаточно найти в графе все мосты, давайте я вот
[12:10.860 --> 12:16.740]  так нарисую, значит, достаточно найти в графе все мосты,
[12:16.740 --> 12:20.660]  и тогда оставшиеся компоненты связанности будут компонентами
[12:20.660 --> 12:22.500]  ребер над усвязанностью в исходном графе.
[12:22.500 --> 12:25.780]  То есть вот я нарисовал так мой граф, здесь там, ну,
[12:25.780 --> 12:28.340]  много ребер, так что здесь нет мостов внутри вот этого
[12:28.340 --> 12:31.260]  облачка, а вот эти отдельные перемычки между кружочками
[12:31.260 --> 12:32.260]  – это мосты.
[12:32.260 --> 12:35.380]  Тогда если я удалю все мосты и буду рассматривать
[12:35.380 --> 12:38.060]  просто компоненты связанности в получившемся графе, то
[12:38.060 --> 12:41.060]  это будут в точности компоненты ребер над усвязанностью.
[12:41.060 --> 12:52.340]  Значит, утверждение такое, компоненты реберной двусвязанности
[12:52.340 --> 13:02.500]  в G – это компоненты просто связанности, компоненты
[13:02.500 --> 13:22.900]  связанности в графе G минус мосты, G минус мосты.
[13:22.900 --> 13:37.860]  Так, значит, нам это надо доказать.
[13:37.860 --> 13:41.580]  Давайте сфокусируем внимание на какой-нибудь компоненте
[13:41.580 --> 13:42.580]  связанности в нашем графе.
[13:42.580 --> 13:47.700]  Докажем, что здесь все вершины попарно находятся в отношении
[13:47.700 --> 13:48.700]  ребер над усвязанностью.
[13:48.700 --> 13:51.340]  То есть вот я удалил мосты, рассмотрел какую-то одну
[13:51.340 --> 13:53.660]  компоненту связанности в получившемся графе.
[13:53.660 --> 13:56.980]  То есть по сути я рассмотрел некое множество вершин,
[13:56.980 --> 13:59.620]  ну и ребер между ними, такие, что все ребра здесь не
[13:59.620 --> 14:00.620]  мосты.
[14:00.620 --> 14:02.100]  Я мосты удалил, оставил только не мосты, поэтому
[14:02.100 --> 14:05.140]  здесь в этой компоненте все не мосты.
[14:05.140 --> 14:07.860]  Вот как устроено множество вершин, таких что все ребра
[14:07.860 --> 14:09.860]  не мосты.
[14:09.860 --> 14:12.060]  Все ребра не мосты.
[14:12.060 --> 14:20.180]  Давайте вспомним, как мы вообще находили мосты,
[14:20.180 --> 14:21.780]  у кого у нас там был критерий.
[14:21.780 --> 14:26.580]  Мы находили, во всем графе мы находили, мы запускали
[14:26.580 --> 14:27.580]  DFS.
[14:27.580 --> 14:30.820]  У нас в каждой вершинке присваивалось время входа,
[14:30.820 --> 14:31.820]  ты на тв.
[14:31.820 --> 14:36.340]  И мы еще для каждой вершины определяли return на тв.
[14:36.340 --> 14:40.620]  Это, напомню картинку, мы стоим в ве, можем спуститься
[14:40.620 --> 14:43.780]  куда угодно в под дерево до вершинки w произвольной,
[14:43.780 --> 14:46.100]  и потом один раз по обратному ребру прыгнуть куда-то
[14:46.100 --> 14:47.100]  в у.
[14:47.420 --> 14:50.180]  И нужно было, вот это вот red на тв, указывать самую
[14:50.180 --> 14:52.740]  высокую вершину, куда мы можем прыгнуть наверх за
[14:52.740 --> 14:55.100]  один шаг, за один прыжок, спустившись предварительно
[14:55.100 --> 14:56.380]  куда-то вниз по под дереву.
[14:56.380 --> 15:00.740]  Ну и соответственно все вот эти вот, мы говорили,
[15:00.740 --> 15:07.500]  что, точнее, ребро является мостом, значит, это мост,
[15:07.500 --> 15:10.740]  если только если, так сейчас вспомним условия, видимо
[15:10.740 --> 15:16.540]  red на тв равно t на тв, так же мы написали.
[15:17.380 --> 15:18.940]  Вот, хорошо.
[15:18.940 --> 15:21.980]  Значит, тогда вот здесь, в этой компоненте все ребра,
[15:21.980 --> 15:22.980]  наоборот, не такие.
[15:22.980 --> 15:27.380]  Вот эти равенства не выполнены, значит, вот давайте я посмотрю
[15:27.380 --> 15:30.300]  сначала древесные ребра, те ребра, которые проходят
[15:30.300 --> 15:31.300]  наш ДФС.
[15:31.300 --> 15:39.980]  У древесных ребер вот это равенство не выполнено,
[15:39.980 --> 15:42.700]  раз это не мосты, значит, не удалены, поэтому не равенство,
[15:42.700 --> 15:43.700]  sorry, равенство не выполнено.
[15:44.180 --> 15:49.260]  Значит, вы помните, наоборот, red на тв меньше, чем t на тв.
[15:49.260 --> 15:52.940]  Ну потому что red всегда не больше, чем t на тв, там
[15:52.940 --> 15:55.140]  был большой минимум, в котором в частности участвует
[15:55.140 --> 15:58.500]  t на тв от текущей вершины, и еще там какие-то другие
[15:58.500 --> 15:59.500]  вершины.
[15:59.500 --> 16:01.260]  Поэтому если здесь не равенство, то точно меньше.
[16:01.260 --> 16:05.900]  Окей, то есть вот у меня есть такая штука, по всем
[16:05.900 --> 16:09.460]  ребрам, если я возьму какое-то древесное ребро в t на тв,
[16:09.460 --> 16:13.620]  я знаю, что return у этой вершинки меньше, чем t на t.
[16:14.020 --> 16:17.140]  Тогда давайте докажем следующее, что если v2 это древесное
[16:17.140 --> 16:25.660]  ребро, если v2 это древесное ребро, ну вот в этой компоненте
[16:25.660 --> 16:35.540]  связанности, в новой компоненте связанности, то v2 лежат,
[16:35.540 --> 16:40.300]  ну как бы, между ними, короче, они лежат в отношении реберной
[16:40.300 --> 16:41.300]  связанности.
[16:41.300 --> 16:43.500]  То есть между ними есть два реберно-непересекающихся
[16:43.500 --> 16:44.500]  пути.
[16:48.500 --> 16:55.300]  Есть два реберно-непересекающихся пути.
[16:55.300 --> 17:02.740]  Так, у меня вопрос к вам, как, если я знаю, что v2 это неудаленное
[17:02.740 --> 17:07.260]  древесное ребро, и знаю вот это, как найти два реберно-непересекающихся
[17:07.260 --> 17:08.260]  пути между ними?
[17:12.300 --> 17:15.300]  Да, это первый путь, а второй?
[17:24.300 --> 17:26.300]  Ну да, да, да, да.
[17:29.300 --> 17:30.300]  Давайте запишем.
[17:33.300 --> 17:35.300]  Ну, я напишу так, я напишу, что первый путь это просто
[17:35.300 --> 17:36.300]  ребро v2.
[17:39.300 --> 17:41.300]  Первый путь это просто ребро v2.
[17:41.300 --> 17:46.300]  А второй путь, значит, ну раз мы знаем, что reta2 меньше,
[17:46.300 --> 17:51.300]  чем t и n2, это означает следующее, что под дереве t можно куда-то
[17:51.300 --> 17:54.300]  спуститься, так что потом можно будет прыгнуть за одно
[17:54.300 --> 17:59.300]  ребро, и потом, соответственно, мы окажемся в вершине, которая
[17:59.300 --> 18:01.300]  лежит раньше, чем t.
[18:01.300 --> 18:02.300]  Раньше, чем t.
[18:02.300 --> 18:05.300]  Ну и, значит, от нее еще можно спуститься до v.
[18:07.300 --> 18:10.300]  Потому что мы обязательно попадем в какого-то предка,
[18:10.300 --> 18:13.300]  ну вот в этом нашем дереве, мы пойдем в какую-то вершину,
[18:13.300 --> 18:14.300]  чем t.
[18:14.300 --> 18:16.300]  Значит, это либо v, либо еще более ранее, чем v, поэтому
[18:16.300 --> 18:18.300]  если нужно, мы потом до v спустимся.
[18:20.300 --> 18:21.300]  Ну и что?
[18:21.300 --> 18:25.300]  Надо еще сказать, что все вот эти ребра не мосты, чтобы
[18:25.300 --> 18:27.300]  они существовали в нашем графе.
[18:27.300 --> 18:32.300]  Ну, понимаешь, что это не мосты.
[18:32.300 --> 18:35.300]  Для всех вот этих ребер существует такой спуск, который
[18:35.300 --> 18:38.300]  ведет их выше, поэтому здесь равенство на этих ребрах
[18:38.300 --> 18:39.300]  не выполняется.
[18:39.300 --> 18:42.300]  Это обратное ребро, обратное ребро мы не удаляем.
[18:42.300 --> 18:44.300]  Ну и здесь то же самое.
[18:44.300 --> 18:47.300]  По дереве всех этих вершин есть прыжок более высоко,
[18:47.300 --> 18:49.300]  поэтому все эти ребра тоже не мосты.
[18:49.300 --> 18:52.300]  Значит, все эти ребра сохранятся, и вот вам два неперескающие
[18:52.300 --> 18:53.300]  пути.
[18:53.300 --> 18:56.300]  Итого мы доказали следующее, что после удаления мостов
[18:56.300 --> 19:00.300]  внутри каждой компонентной связанности точно все,
[19:00.300 --> 19:01.300]  скажем так, все пара вершин, соединенных
[19:01.300 --> 19:04.300]  с деревесным ребром, они точно в отношении нашим хорошим.
[19:05.300 --> 19:09.300]  Ну а поскольку дерево DFS оно как бы связывает, оно
[19:09.300 --> 19:11.300]  позволяет нам обойти все вершины каждой компоненты,
[19:11.300 --> 19:15.300]  значит, если каждые соседи лежат в отношении, значит,
[19:15.300 --> 19:18.300]  все вот эти чуваки по транзитивности все в одном отношении
[19:18.300 --> 19:19.300]  лежат.
[19:20.300 --> 19:22.300]  Все вершины в каждой компоненте связанности, они точно
[19:23.300 --> 19:25.300]  лежат в одной и той же компоненте реберной связанности.
[19:25.300 --> 19:33.780]  Отсюда первый вывод, что каждая компонента связности
[19:33.780 --> 19:52.720]  в графе g минус мосты точно подмножество одной компоненты
[19:52.720 --> 20:02.800]  переребрана до связности g.
[20:02.800 --> 20:06.120]  Потому что любая пара вершин в этой компоненте, соединенная
[20:06.120 --> 20:08.800]  древесным ребром, лежит в отношении, значит по транзестивности
[20:08.800 --> 20:10.760]  вся компонента по парам лежит в отношении, поэтому
[20:10.760 --> 20:17.240]  это все подмножество одного блока, одного класса эквалемности.
[20:17.240 --> 20:20.640]  Но остается доказать, что если у вас вершины лежат
[20:21.120 --> 20:24.240]  в разных компонентах связности после удаления мостов,
[20:24.360 --> 20:26.400]  то они в разных компонентах реб Muk relative связности.
[20:26.400 --> 20:29.060]  Но это очевидно, если они нет в разных компонентах
[20:29.060 --> 20:32.080]  связанности после удаления мостов, значит на любом
[20:32.080 --> 20:34.920]  пути между ними лежит хотя бы один мост.
[20:34.920 --> 20:38.000]  Поэтому не может существовать двух непресягавших путей
[20:38.000 --> 20:39.000]  между ними.
[20:39.000 --> 20:41.000]  Обязательно есть какой-то мост.
[20:41.000 --> 20:45.240]  Такое, что после его удаления у меня пропадает путь,
[20:45.240 --> 20:49.280]  значит все эти пути этот мост содержит.
[20:49.280 --> 20:53.380]  не может быть такого, что вершины из разных компонентов связности попадают в
[20:53.380 --> 20:59.380]  одну и ту же компоненту реберной связности. Поэтому, ну вот, мы доказали, что каждый
[20:59.380 --> 21:04.580]  вот этот кружочек это в точности компонента реберной связности. Так, давайте тоже зафиксируем.
[21:04.580 --> 21:17.980]  Вершины разных компонентов связности
[21:17.980 --> 21:34.900]  не могут лежать в одной компоненте реберной связности,
[21:34.900 --> 21:53.260]  так как на пути между ними есть мост. Ну а значит, все они проходят через этот мост.
[21:53.260 --> 22:08.020]  Так, хорошо. Ну и теперь еще можно заметить, что когда мы сжимаем вот так вот компоненты
[22:08.020 --> 22:11.180]  реберной связности, то есть находим классы эквивалентности по введенному отношению
[22:11.180 --> 22:15.380]  эквивалентности, то на самом деле у нас получается такое дерево. И вот этот граф,
[22:15.380 --> 22:19.460]  который я нарисовал, кружочки большие это компоненты реберной связности, а ребра между
[22:19.460 --> 22:24.020]  ними это мосты. Вот это вот все мосты. Можно показать, что это дерево, то есть граф без циклов.
[22:24.020 --> 22:30.500]  Так же, как у нас было в конденсации ориентирована графа, когда мы находили
[22:30.500 --> 22:35.420]  компоненты сильной связности, мы там выделили компоненты сильной связности и доказали,
[22:35.420 --> 22:40.300]  что если сжать это все в конденсацию, то есть рассматривать компоненты как отдельные вершины,
[22:40.300 --> 22:45.540]  то тогда там не будет циклов, будет дак. То же самое здесь. После сжатия
[22:45.540 --> 23:02.020]  компонент реберной связности будет дерево. Дерево, то есть граф без циклов.
[23:10.300 --> 23:22.620]  Доказательств такое же от противного. Если есть цикл, то можно найти два пути между нашими
[23:22.620 --> 23:27.660]  товарищами, между какими-нибудь вершинами, значит они все должны сжать в одном классе эквивалентности.
[23:27.660 --> 23:35.740]  Представим, что после сжатия есть какой-то цикл вот такой, например. Ну тогда рассмотрим
[23:35.740 --> 23:44.900]  произвольную вершину вот здесь, произвольную вершину вот здесь. У и В. Что можно тогда сказать?
[23:44.900 --> 23:54.380]  Так, момент. Давайте для удобства скажем, что это не произвольная вершина, а вот те, куда ведет,
[23:54.380 --> 24:00.780]  скажем, вот это вот ребро. Вот это вот будет в У, а это скажем в В. Тогда понятно, что есть путь
[24:00.780 --> 24:05.860]  от У в В, скажем, идущий сюда, используя этот мост. Здесь как-то, ну понятно, раз это компоненты
[24:05.860 --> 24:10.060]  связанности после удаления мостов, то здесь есть какой-то путь. Ну и соответственно здесь тоже по
[24:10.060 --> 24:16.460]  мосту можно дойти до В. Второй путь можно сделать такой. Значит мы сначала от У доходим здесь до начала
[24:16.460 --> 24:22.540]  этого ребра, а потом телепортируемся по мосту. Здесь идем, поскольку компоненты связанности
[24:22.540 --> 24:27.620]  доходим до начала этого ребра, ну опять здесь все то же самое, доходим до сюда и потом до В. Вот мы
[24:27.620 --> 24:33.540]  получили два ребра не пересекающихся пути между У и В, хотя предположили, что это, ну это класс
[24:33.540 --> 24:39.460]  эквивалентности, значит тогда У и В должны были бы лежать в одном и том же классе. Если есть цикл,
[24:39.460 --> 24:53.460]  то У и В должны лежать в одном классе. Противоречие.
[24:53.460 --> 25:10.340]  Да, да, действительно можно так, да. Если есть цикл, то все это не мосты, потому что любой из них
[25:10.340 --> 25:17.940]  можно выбросить, а останется связанность. Согласен. Так, ну хорошо, значит вот мы научились находить
[25:17.940 --> 25:23.100]  компоненты, да, и поняли, что граф имеет структуру дерева после жатия этих компонентов,
[25:23.100 --> 25:27.540]  ребер на до связанности. Значит, ну последнее замечание, что работает за линию, конечно, все.
[25:27.540 --> 25:39.460]  За N плюс M, за число вершин плюс число ребер, ну потому что по сути это опять DFS. Сначала мы
[25:39.460 --> 25:45.780]  сбустили DFS, чтобы посчитать все реты для всех вершинок. Значит дальше, используя это, мы умеем
[25:45.780 --> 25:49.660]  определять, является ли ребро мостом или нет, но дальше нужно просто там, скажем, удалить все
[25:49.660 --> 25:54.580]  мосты и запустить там, по всем вершинам проходиться. Если она еще не посещена запускать DFS,
[25:54.580 --> 25:59.700]  проходить все, что из нее достижимо, это отдельные компоненты. Тогда суммарно мы обойдем как раз все
[25:59.700 --> 26:04.540]  вершины ровно по одному разу, каждый ребро ровно по одному разу, поэтому всем точка линейная по размеру
[26:04.540 --> 26:34.260]  графа. Так, хорошо. Значит, немного альтернативный вариант, как можно было бы находить вот эти
[26:34.260 --> 26:42.620]  компоненты без явного удаления мостов и дальше прохода по новому графу. Это не то что какая-то
[26:42.620 --> 26:57.460]  новая идея, но я напишу альтернативный алгоритм. Он будет действовать следующим образом. Давайте мы
[26:57.460 --> 27:06.300]  заведем очередь вершин, куда будем, значит, куда изначально положим корень нашего дерева,
[27:06.300 --> 27:14.620]  то есть ту вершину, от которой мы запустили первый самый DFS. Купу шрут. Дальше алгоритм будет
[27:14.620 --> 27:19.700]  работать следующим образом. Он достает вершину из очереди, пустит какая-то вершинка V, и давайте
[27:19.700 --> 27:27.020]  мы просто начнем обходить все, что из нее достижимо, используя не мосты. Что такое не мосты? Это мы знаем,
[27:27.020 --> 27:35.340]  это древесное ребро V2, это мост, если return at 2 меньше, чем return at 2. Поэтому давайте просто
[27:35.340 --> 27:42.540]  запустим DFS из вот этой вершины, которая посещает только, ну, которая использует только древесные
[27:42.540 --> 28:04.700]  ребра, у которых return меньше, чем TIN. Значит, обработка вершины из очереди. Обойти все
[28:04.700 --> 28:27.580]  ребра, обойти все, что достижимо под древесным ребром, под древесным ребром, так, ну, не в эту,
[28:27.580 --> 28:33.220]  давайте уже назовем X, Y, которые не являются мостами, то есть у которых return от конца
[28:33.220 --> 28:42.900]  меньше, чем TIN от конца. Это мы, собственно, тогда обойдем вот эту компоненту, но при этом еще,
[28:42.900 --> 28:47.780]  смотрите, раз мы ее все обойдем, то в частности обойдем те вершины, из которых торчат еще какие-то
[28:47.780 --> 28:52.260]  мосты. То есть вот, скажем, на этой картинке, если я запускаюсь, если я начинаю обрабатывать эту
[28:52.260 --> 28:56.860]  вершину, то я здесь все обхожу, обхожу, обхожу, это все не мосты, я их все посещаю, и в частности я
[28:56.860 --> 29:02.300]  увижу вот эти вот вершинки, из которых торчат мосты. Тогда давайте, когда я увижу такую вершинку,
[29:02.300 --> 29:09.940]  я прохожусь по этому ребру и добавляю конец этих ребр в очередь. Я вижу такие ребра, это там X1, Y1,
[29:09.940 --> 29:17.580]  X2, Y2, вижу, что это мосты, значит, не обхожу их в этом DFS, но добавляю их в очередь. То есть это как бы начальные
[29:17.580 --> 29:22.180]  вершинки, из которых надо будет еще обойти вот эти компоненты. Поэтому я их добавляю в очередь,
[29:22.180 --> 29:26.580]  и потом из них, пока очередь не пустая, достаю вершинку, все обхожу, опять здесь все обошел,
[29:26.580 --> 29:34.100]  и увидел вот эти три моста, добавил их, вот эти вот конечные вершинки в очередь. Если видим мост
[29:34.100 --> 29:49.180]  X, Y, то добавляем Y в очередь, купушь Y. Ну вот, то есть явным образом не нужно даже перестраивать
[29:49.180 --> 29:56.220]  граф. Вот, например, можно с помощью такого, ну, по сути, по очереди просто все компоненты обходят.
[29:56.220 --> 30:01.620]  Понятно? Хорошо.
[30:19.180 --> 30:34.420]  Так, ну тогда мы идем дальше. Рассматриваем новое отношение к эвалентности, вершины эдуфиазности.
[30:34.420 --> 30:43.260]  Ну, давайте даже не так. Давайте сначала начнем тоже с точки сочленения. Значит,
[30:43.260 --> 31:02.020]  точка сочленения, сочленение, вот по-английски это cut point в связном графе G. Это такая вершина,
[31:02.180 --> 31:19.660]  удаление которой делает граф несвязанным. Такая вершина, удаление которой делает граф несвязанным.
[31:19.660 --> 31:29.980]  Ну, так же, как у нас раньше мы ребра удалили, теперь давайте вершины посмотрим удалить. То есть,
[31:29.980 --> 31:35.900]  ну, идея такая же. Вот есть у нас какая-то сеть и теперь мы спрашиваем себя, какие не ребра нам
[31:35.900 --> 31:40.780]  критически важно поддерживать для обеспечения связанности, а вершины. То есть, какие такие
[31:40.780 --> 31:45.900]  компьютеры, серверы нам важно поддерживать так, чтобы вообще они могли между собой общаться. Если
[31:45.900 --> 31:50.500]  они посылают друг другу сигналы как-то по цепочке, то вот какие вершины нам нужно поддерживать.
[31:50.500 --> 31:58.900]  Так, ну, тогда я утверждаю, что используя вот эти вот ретёрны, которые мы посчитали по нашему
[31:58.900 --> 32:05.300]  DFS для всех вершин, мы сможем сейчас найти критерии того, что вершина является точкой сочленения.
[32:05.300 --> 32:23.220]  Вершина В является точкой сочленения ТС, если и только если выполнена одна из двух. Первая,
[32:23.220 --> 32:32.540]  В это корень, то есть та вершина, от которой мы первой запустили DFS, корень нашего дерева,
[32:32.620 --> 32:45.980]  корень дерева обхода. И при этом у В торчит хотя бы два древесных ребра. Значит, из В исходит хотя
[32:45.980 --> 32:52.500]  бы два древесных ребра. Ну, это, собственно, значит, что в дереве обхода у корня хотя бы два сына.
[32:52.500 --> 33:05.660]  Второе условие, когда В не корень, тогда у В, значит, из В должно исходить хотя бы одно
[33:05.660 --> 33:22.420]  ребро древесное. Значит, В не корень, из В есть древесное ребро в некую вершинку ТУ. Такое,
[33:22.420 --> 33:43.180]  что return от ТУ больше либо равно 3 над В. То есть, если мы запустим наш обычный DFS,
[33:43.180 --> 33:47.940]  посчитаем вот эти вот returnы, так же, как мы считали это, когда находили мосты, то достаточно
[33:47.940 --> 33:50.980]  просто будет для каждой вершины проверить. Ну, либо это корень, тогда у него хотя бы два сына,
[33:50.980 --> 33:55.300]  либо это не корень, тогда нужно просто пройтись по детям и узнать, есть ли хотя бы одного ребёнка
[33:55.300 --> 34:04.020]  такое неравенство. Доказательства. Ну, давайте сначала начнём со случая не корня. Пусть В не
[34:04.020 --> 34:15.940]  корень. Пусть В не корень. Не корень дерева обхода. Тогда как это выглядит? Вот есть В,
[34:16.020 --> 34:23.420]  раз В это не корень, значит, у него есть какой-то родитель в дереве обхода. Такую стрелочку даже
[34:23.420 --> 34:29.460]  нарисую. То есть, напоминаю, что DFS мы обычно часто пишем, передавая текущую вершину и её предка.
[34:29.460 --> 34:38.180]  Вот пусть P это тот самый предок, когда мы запускали наш DFS. Так, я, наверное, доказываю справа-налево.
[34:38.180 --> 34:47.700]  Ну, или сейчас. Сейчас вместе всё докажем. Вот есть вершина В. Если из неё есть какое-то
[34:47.700 --> 34:52.340]  древесное ребро исходящее в некое тум, такое, что выполняется то неравенство, то что это значит?
[34:52.340 --> 35:01.520]  Это значит, что из всего вот этого поддерева я не могу прыгнуть выше, чем В. То есть, вот здесь
[35:01.520 --> 35:05.860]  неравенство больше или равно. Ну, самое лучшее, самое высокое, это я, возможно, могу прыгнуть В,
[35:05.860 --> 35:11.580]  но не выше. Не могу прыгнуть в вершины с меньшим тейном. То есть, скажем, до P я точно не допрыгну.
[35:11.580 --> 35:18.100]  До P я не допрыгну. То есть, как бы я ни старался, вот всё, что достижимо отсюда в поддереве и
[35:18.100 --> 35:25.340]  прыжок один по обратному ребру не поднимет меня в P. Поэтому, если В удалить, то вот это вот поддерево
[35:25.340 --> 35:30.700]  станет компонентой связанности отдельной, из которой я не смогу попасть в P, например. Значит,
[35:30.700 --> 35:47.300]  мы получили, что граф распадается. Если есть древесное ребро ВТУ, такое, что return от ТУ больше
[35:47.900 --> 36:09.060]  В, то после удаления В нет пути между ТУ и П. Между ТУ и П. Ну, значит, граф несвязный.
[36:09.060 --> 36:20.580]  Теперь обратно. Пусть у В все дети, наоборот, хорошие. Такие, что у них ред меньше,
[36:20.580 --> 36:27.980]  чем ТУ меньше, чем ТИ на В. То есть, пусть есть В, это я в обратную сторону доказываю. Пусть есть
[36:27.980 --> 36:35.660]  П. Значит, это что было? Справа налево, теперь слева направо. Вот есть у него куча детей, и у каждого
[36:35.660 --> 36:42.900]  return меньше, чем ТИ на В. У них у всех return меньше, чем ТИ на В. Это значит, что из всех вот этих
[36:42.900 --> 36:50.460]  поддеревьев есть обратное ребро в П или выше. Поскольку return у них меньше, чем В, значит,
[36:50.460 --> 36:55.940]  я могу подняться выше, чем В. То есть, это либо родитель В, либо еще куда-то выше. Ну, значит,
[36:55.940 --> 37:00.780]  если это удалю, то у меня, конечно же, граф остается связанным. Я могу из любого поддерева прыгнуть
[37:00.780 --> 37:05.140]  куда-то туда наверх и потом дойти до П. Из любого поддерева могу прыгнуть куда-то наверх и потом
[37:05.140 --> 37:10.620]  дойти до П, просто спустившись вниз. Поэтому связанность не нарушается. Все вот эти вот компоненты,
[37:10.620 --> 37:17.220]  они будут связаны с П. Ну, значит, они связаны между собой, скажем, можно попасть отсюда сюда. То есть,
[37:17.220 --> 37:23.860]  если я могу отсюда пойти до П и отсюда пойти до П, то, понятно, я могу под П сделать вот такой путь.
[37:23.860 --> 37:37.660]  Между ними, то есть, тоже есть пути. Значит, если для всех детей return у меньше,
[37:37.660 --> 37:57.020]  чем 3 над В, то после удаления В все дети связаны с П. Все дети связаны с П, значит, граф связанный.
[37:57.020 --> 38:21.500]  Вот это случай, когда В не корень. Когда В корень, тут еще проще ситуация. Пусть В корень.
[38:21.500 --> 38:28.820]  Значит, тут два случая. Либо у него, ну, случая, когда у него 0 детей, значит, что в графе всего одна
[38:28.820 --> 38:33.660]  вершина. Понятно, что она не является точкой исчления, потому что удаление вершины, ну,
[38:33.660 --> 38:37.820]  как бы оставляет граф связан. Между любыми двумя вершинами есть путь, потому что вообще вершин нет.
[38:37.820 --> 38:47.300]  Давайте такое не будем рассматривать. Пусть у В ровно один сын. Пусть у В ровно один сын в дереве обхода.
[38:47.300 --> 39:00.660]  Что это значит? Вот есть В, есть какое-то ребро из В вту. Такое, что если мы запускаем DFS от
[39:00.660 --> 39:07.740]  ту, он обходит вообще весь граф. Больше нет вершин, которые не достигнутся из ту. Они все посетятся.
[39:07.740 --> 39:13.100]  Значит, если В удалю, то у меня все пути сохранятся. Между ними всеми есть пути,
[39:13.100 --> 39:21.780]  потому что они все достижены из ту. Поэтому В не точка исчления. Если это верно, тогда DFS от ту
[39:21.780 --> 39:35.300]  посещает все, кроме В. Значит, удаление В не влияет на связанность,
[39:35.300 --> 39:50.700]  не влияет на связанность. Ну, если хотя бы два сына, значит, между этими под деревьями нет
[39:50.700 --> 39:55.140]  никаких ребер, поэтому удаление корня оставит нам хотя бы две компоненты, между которыми мы не
[39:55.140 --> 40:08.820]  сможем телепортироваться. Если у В хотя бы два сына, то картинка такая, что вот есть В. Мы
[40:08.820 --> 40:13.860]  нашли какого-то сына, запустили от него DFS, обошли все, что возможно, и при этом обошли не весь
[40:13.860 --> 40:20.420]  граф. Потом нашли какого-то другого сына, запустили от него DFS, обошли опять все возможно. Ну, там
[40:20.420 --> 40:24.620]  возможно обошли все, возможно есть еще какие-то дети. Но главное, что если мы запустились отсюда,
[40:24.780 --> 40:29.180]  обошли все, что можно, и не попали куда-то, значит, понятное дело, после удаления В у меня пропадают
[40:29.180 --> 40:48.020]  пути отсюда-сюда. Значит, ну кратко напишу. Тогда дети не связаны после удаления В. Ну, значит,
[40:48.020 --> 40:52.980]  тоже мы доказали в обе стороны, что если меньше, чем два ребенка, то это не точка счленения. Если
[40:52.980 --> 41:05.460]  хотя бы два, то точка счленения. Вопросы? Хорошо. Ну, тогда наш алгоритм, нахождение,
[41:05.460 --> 41:09.900]  по крайней мере, точек счленения, он работает, в общем-то, так же, как алгоритм поиска мостов,
[41:09.900 --> 41:14.940]  что мы сначала насчитываем вот эти ретерны, которые по сути какая-то ДП-шка на дереве. Мы
[41:14.940 --> 41:20.380]  насчитываем все эти ретерны, а дальше для каждой вершины просто проверяем вот это условие. Получается
[41:20.380 --> 41:27.460]  опять линейный алгоритм. Давайте какой-нибудь пример нарисую. Пример. Как это может выглядеть?
[41:41.460 --> 41:48.660]  Вот если у нас есть такой граф, то как здесь выглядит точка счленения? Ну вот, понятное
[41:48.820 --> 41:53.140]  дело, точка счленения, потому что после ее удаления, скажем, отсюда нельзя будет попасть сюда. Вот
[41:53.140 --> 41:57.940]  точка счленения, потому что после отк mediа нельзя будет попасть отсюда сюда. Вот точка
[41:57.940 --> 42:05.380]  счленения и вот точка счленения. Так, давайте еще какой-нибудь пример нарисуем, давайте вот
[42:05.380 --> 42:16.240]  здесь чего-нибудь подвешу еще. Вот так. С жирным выделено точка счленения. Значит, тут можно заметить
[42:16.240 --> 42:23.240]  Две вещи. Во-первых, что если есть мосты, то понятное дело, оба конца моста являются
[42:23.240 --> 42:29.760]  фришками сочленения. То есть если удалить ребро, то мы знаем, что если ребро
[42:29.760 --> 42:32.160]  является мостом, то после его удаления граф не связан.
[42:32.160 --> 42:45.240]  Поэтому, ну то есть если в графе, сейчас, момент. Еще раз. Да-да-да, вы правы, это я
[42:45.240 --> 42:50.800]  погорячился. То есть скорее, если это мост, и здесь хотя бы две вершины,
[42:50.800 --> 42:55.400]  и здесь хотя бы две вершины, выше-ниже этого ребра, то эти обе точки сочленения,
[42:55.400 --> 42:59.200]  потому что после удаления, скажем, одного из них, я не смогу попасть снизу наверх.
[42:59.680 --> 43:06.880]  Надо хотя бы, чтобы было по две вершины сверху снизу. Вот есть еще мост, обе его. Да,
[43:06.880 --> 43:10.960]  давайте тогда, чтобы это проиллюстрировать, можно еще вот здесь добавить. Тогда вот это
[43:10.960 --> 43:18.040]  точка сочленения, а это нет, хотя это мост. Спасибо. То есть вот это мост, но только это
[43:18.040 --> 43:22.800]  является точкой сочленения. Но главное, скорее, я хотел показать следующее, что бывают такие
[43:22.800 --> 43:27.080]  точки, которые не инцидентны мостам, но при этом все равно являются точками сочленения. Вот она,
[43:27.080 --> 43:31.120]  например. Она соединяет вот этот квадратик с этим треугольником. Понятно, что после ее
[43:31.120 --> 43:37.920]  удаления у меня граф становится несвязанным, но она никаким мостам не инцидентна. Вот, хорошо.
[43:37.920 --> 43:47.680]  Значит, такой, так вот это все выглядит. Ну и можно, давайте, наверное, сильно, ну посмотрим.
[43:47.680 --> 43:52.980]  Значит, можно также определить отношение вершины и додосвязанности, чтобы затем выделять
[43:53.860 --> 43:59.300]  вершины и додосвязанности. Как раньше мы выделяли, как бы классы Take-equality-ности
[43:59.300 --> 44:02.460]  по 요�rock волей, то есть максимальные по включение множество такие что все вершины
[44:02.460 --> 44:08.060]  попарно имеют два пути не перес Bottom по ребрам, то теперь тоже самое и можно сделать по вершинам.
[44:08.060 --> 44:12.880]  Только чтобы это было отношение эквивалентности, нам придется завести это отношение на ребрах,
[44:12.880 --> 44:17.340]  а не на вершинах. Потому что вот теперь мы не можем сказать, мы не можем завести отношение на
[44:17.340 --> 44:20.500]  вершинах, который говорил бы, что между вершинами есть два вершина не пересnee VER-шИна,
[44:20.500 --> 44:24.800]  ни пересекаешься пути. Потому что это уже будет не отношения эквалентности.
[44:24.800 --> 44:30.140]  Например, между вот этими вершинками есть 2 ни пересекаешься пути по вершинам.
[44:30.140 --> 44:35.980]  Вот этот и вот этот. И вот между этими двумя тоже есть. Вот этот и вот этот.
[44:35.980 --> 44:38.980]  Но по транзестивности мы не можем сказать что отсюда, есть два ни пересекащих пути сюда.
[44:38.980 --> 44:42.140]  Потому что они все проходят обязательно через точку пос boron.
[44:42.140 --> 44:47.100]  Поэтому мы не можем такое отношение вести на вершинах. Значит вместо отношения на
[44:47.100 --> 45:02.140]  вершинах мы ведем отношение на ребрах. И это уже будет хорошее отношение. И тогда по нему все
[45:02.140 --> 45:06.860]  распадется на следующие компоненты вершины двухсвязанности. Вот эта вот будет одна компонента,
[45:06.860 --> 45:15.980]  вот эта другая, вот это третья, мост отдельная, вот компонента, вот компонента, вот компонент,
[45:15.980 --> 45:21.900]  еще мост, вот компонент и вот компонент. То есть они будут пересекаться по вершинам. Пожалуйста,
[45:21.900 --> 45:28.420]  вот эти вот две пересекаются по вершине, по точке сленения, но не по ребрам. Это как раз
[45:28.420 --> 45:39.260]  иллюстрация того, что это отношение к вершине по ребрам. Ну, определение. Пусть g неориентированный
[45:39.260 --> 45:49.180]  граф. Тогда говорим, что два его ребра, давайте связанное добавлю. Ну да, давайте считать, что мы
[45:49.180 --> 45:53.460]  только со связанными работаем, иначе в каждой компоненте отдельно такой алгоритм можно пускать.
[45:53.460 --> 46:15.300]  Значит, говорим, что два его ребра вершин надусвязаны, если выполняется одно из двух. Значит,
[46:15.300 --> 46:22.620]  два ребра e1, e2. Это либо одно и то же ребро, либо они лежат на общем вершине в простом цикле.
[46:22.620 --> 46:49.460]  На общем, вершин на простом цикле. Вот такое отношение. На что на самом деле это очень похоже на то,
[46:49.460 --> 46:53.380]  что у нас было про реберную недосвязанность для вершин. Значит, там напомню, когда мы
[46:53.380 --> 46:57.140]  определяли для вершины реберную недосвязанность, мы говорили, что между вершинами есть два
[46:57.140 --> 47:04.260]  реберно не пересекающихся пути. Ну, это то же самое означает, что они лежат на каком-то общем
[47:04.260 --> 47:10.100]  реберно-простом цикле. Потому что если их объединить, то, то есть если два пути склеить, то получится цикл
[47:10.100 --> 47:14.860]  реберно-простой. Кроме случая, когда они совпадают. Если они совпадают, то вполне возможно цикла нету,
[47:14.860 --> 47:21.180]  но они все равно в отношении, потому что между ними есть два не пересекающихся пути. Поэтому вот
[47:21.180 --> 47:25.260]  этот случай, то есть на самом деле, если бы мы формулировали в тех же терминах определение для
[47:25.260 --> 47:29.420]  реберной недосвязанности вершин, тогда у нас было бы то же самое. Либо две вершины одинаковые,
[47:29.420 --> 47:33.660]  либо лежат на реберно-простом цикле. Поэтому это определение можно также переформулировать.
[47:33.660 --> 47:44.700]  Так, ну, сюда вернемся, значит в тверждение без доказательства. Отношение вершинной
[47:44.700 --> 47:53.260]  двусвязанности, вершинной двусвязанности, это отношение эквивалентности на ребрах.
[47:53.260 --> 48:12.220]  Отношение эквивалентности на ребрах. Доказ точно так же, значит симметричность и рефлексивность
[48:12.220 --> 48:19.180]  очевидны, транзитивность точно так же. Есть там два ребра какие-то, E1, E2, E3. Мы берем какой-то
[48:19.180 --> 48:24.580]  цикл вершинно-простой между E1 и E2, рассматриваем там два куска пути от E2 до E3, пересекаем,
[48:24.580 --> 48:33.140]  ну, в общем, все то же самое. С поправкой на то, что вместо реберной простоты нужна вершинная
[48:33.140 --> 48:44.980]  простота. Вот, ну и тогда теперь мы можем профакторизовать, поэтому, отношение эквивалентности,
[48:44.980 --> 49:00.980]  найти класс эквивалентности, определение класса эквивалентности по отношению вершинной
[49:00.980 --> 49:11.220]  двусвязанности, значит, называется блоком, ну, то есть, можно сказать, что компонента
[49:11.220 --> 49:18.740]  реберной двусвязанности, компонента, сори, сори, вершины двусвязанности, компонента вершины
[49:18.740 --> 49:37.460]  двусвязанности, вот, или блок, короче. По-английски это называется bi-connected component. Вот, ну, будем говорить
[49:37.460 --> 49:46.180]  блок для краткости. Значит, ну, вот на этом, на этом рисунке кружочками обвезены как раз блоки,
[49:46.180 --> 50:01.460]  но алгоритм выделения блоков. Алгоритм я опять на очереди напишу, значит, у меня будет очередь
[50:01.460 --> 50:07.780]  каких-то ребер, я буду обходить все, что возможно, что лежит в том же блоке, и в очередь добавлять те
[50:07.780 --> 50:16.100]  найденные ребра, которые, как бы, лежат в других компонентах, в других блоках. Значит, смотрите,
[50:16.100 --> 50:24.700]  да, вот что я еще хотел на том примере проиллюстрировать, что каждая конкретная вершина может,
[50:24.700 --> 50:29.540]  как бы, мы ее можем пометить точкой сшлиния много раз, а именно, от каждого ребенка, у которого
[50:29.540 --> 50:35.780]  ретерн больше равен, чем ее t-in. То есть, если у него есть много детей, у которых ретерн больше
[50:35.780 --> 50:41.600]  реальность, то согласно этой вершины, чем t-in от v, то соответственно эта вершина много раз будет помешана
[50:41.600 --> 50:45.620]  точкой сшлиния, и это как бы значит, что после ее удаления вот эта будет одна компонента, вот эта
[50:45.620 --> 50:49.660]  одна компонента, вот эта одна компонент, и так далее. То есть, если, скажем, я здесь не было бы
[50:49.660 --> 50:56.980]  равенства, то у меня было бы много блоков, которые на v, вот так вот, подвешены. Вот, то есть, главная
[50:56.980 --> 51:03.900]  мысль, что v может быть пометчена, может как бы, является точкой сшлиния много раз, а именно ровно
[51:03.900 --> 51:06.980]  ну, будет компонент после удаления, ну там, плюс один
[51:06.980 --> 51:09.900]  возможно, от того, что есть еще верхняя компонента,
[51:09.900 --> 51:10.900]  которая отвалится.
[51:10.900 --> 51:14.820]  Вот, давай тогда сделаем следующее, значит мы заведем
[51:14.820 --> 51:15.820]  очередь ребер.
[51:15.820 --> 51:26.860]  Так, ну я напишу edge, q, это очередь вот этих вот как
[51:26.860 --> 51:31.460]  бы ребер, которые доказывают то, что начальная вершина
[51:31.460 --> 51:32.780]  этого ребра является точкой шлининия.
[51:32.780 --> 51:46.420]  Значит, очередь ребер доказывающих, что их начало это точка
[51:46.420 --> 51:47.420]  шлининия.
[51:47.420 --> 51:51.980]  Ну, проще говоря, это просто те ребра, которые я нашел,
[51:51.980 --> 51:53.820]  ну, те древесные ребра, которые я нашел, у которых
[51:53.820 --> 51:57.300]  ретерн меньше равен, чем тин вот этот вот, ну вот как
[51:57.300 --> 52:00.900]  раз те ребра, которые показывают, что начало, начало ребра
[52:00.900 --> 52:01.900]  это точка шлининия.
[52:01.900 --> 52:07.460]  Тогда, в агритм следующий, мы встаем в корень, проходим
[52:07.460 --> 52:10.820]  по всем древесным ребрам, смотрим те из них, которые
[52:10.820 --> 52:12.980]  удовлетворяют тому условию, добавляем их в очередь.
[52:12.980 --> 52:15.340]  То есть, ну в нашем случае корень не помечен точкой
[52:15.340 --> 52:18.020]  шлининия, потому что когда мы скажем, ну запускаемся
[52:18.020 --> 52:21.740]  DFS вот отсюда, мы посетим весь граф, поэтому древесное
[52:21.740 --> 52:24.420]  ребро отсюда будет только одно, поэтому оно не пометится
[52:24.420 --> 52:25.420]  как точка шлининия.
[52:25.420 --> 52:28.260]  Но, тем не менее, это ребро как бы неформально доказывает,
[52:28.260 --> 52:29.260]  что это точка шлининия.
[52:29.260 --> 52:31.180]  То есть, если бы там выше кто-то был, то это была бы
[52:31.180 --> 52:32.180]  точка шлининия.
[52:32.180 --> 52:40.300]  Значит, первый шаг добавить в очередь на самом деле
[52:40.300 --> 52:44.580]  просто все древесные ребра, исходящие из корня, все
[52:44.580 --> 52:54.100]  древесные ребра, исходящие из корня, потому что каждое
[52:54.100 --> 52:56.820]  такое ребро как бы отдельно само по себе доказывает,
[52:56.820 --> 52:59.180]  что корень точка шлининия, если бы выше кто-то был.
[52:59.820 --> 53:02.220]  А вот если там еще кто-то есть, и я знаю, что из всего
[53:02.220 --> 53:04.660]  этого поделива нельзя прыгнуть выше, чем в корень, то значит
[53:04.660 --> 53:06.900]  после ее удаления она была бы точкой шлининии.
[53:06.900 --> 53:07.900]  Ну так, неформально.
[53:07.900 --> 53:12.820]  Значит, первым делом добавляем в очередь все эти вершины,
[53:12.820 --> 53:13.820]  сори все ребра.
[53:13.820 --> 53:17.340]  Ну и дальше делаем похожий трюк, значит у меня есть
[53:17.340 --> 53:20.340]  ребро, то есть я, по сути, вошел в новый блок, в новую
[53:20.340 --> 53:21.820]  компоненту вершины десвязности.
[53:21.820 --> 53:26.940]  Вот давайте, вот это вот ребро, я нашел это первое
[53:26.940 --> 53:30.260]  ребро новой компоненты вершины десвязности, нового
[53:30.260 --> 53:31.260]  блока.
[53:31.260 --> 53:36.700]  Тогда давайте я просто запущу DFS вот отсюда, обходя все
[53:36.700 --> 53:40.460]  ребра, которые не вот такие, которые не доказывают,
[53:40.460 --> 53:41.460]  что это точка шлининия.
[53:41.460 --> 53:43.860]  То есть отсюда, скажем, я вот это вот все обойду,
[53:43.860 --> 53:46.340]  сложу их в одну и ту же компоненту, но при этом я найду вот
[53:46.340 --> 53:49.260]  эти вот ребра древесные, которые доказывают, что
[53:49.260 --> 53:51.860]  текущий вершина точка шлининия, вот это, вот это и вот это.
[53:51.860 --> 53:55.020]  Тогда я их добавлю в очередь, и потом, ну, с ним мы проделаем
[53:55.100 --> 53:56.100]  то же самое.
[53:56.100 --> 53:59.860]  Есть ребро, первое ребро в блоке, я от него создаю
[53:59.860 --> 54:03.340]  новую компоненту, обхожу все, что возможно в этой
[54:03.340 --> 54:05.620]  компоненте, скажем, вот здесь все обойду, и дальше
[54:05.620 --> 54:08.540]  все вновь найденные ребра, доказывающие, что это точка
[54:08.540 --> 54:09.540]  шлининия, добавлю в очередь.
[54:09.540 --> 54:17.980]  Так, второе, пока очередь не пустая, очередь не пустая.
[54:17.980 --> 54:29.780]  Ну, мы по сути делаем, давайте я достать, достать ребро
[54:29.780 --> 54:30.780]  в эту из очереди.
[54:30.780 --> 54:40.700]  Значит, дальше запустить что-то типа DFS и STU, и все
[54:40.700 --> 54:45.660]  ребра, которые не доказывают, что начало ребра это точка
[54:45.660 --> 54:47.900]  шлининия, отнести к той же компоненте связанности,
[54:47.900 --> 54:48.900]  что и в эту.
[54:48.900 --> 55:02.780]  Значит, DFS и STU, все ребра, не доказывающие, т.е. такие
[55:02.780 --> 55:05.860]  ребра, у которых ред вот здесь вот, меньше, чем тин
[55:05.860 --> 55:09.580]  вот здесь вот, значит, ред вот здесь, меньше, чем тин
[55:09.580 --> 55:10.580]  вот здесь.
[55:10.580 --> 55:13.140]  Это тогда значит, что эта вершина, ну, как бы, не является
[55:13.140 --> 55:15.500]  точкой шлининия с точки зрения вот этого ребра.
[55:15.500 --> 55:22.260]  Все такие ребра добавить в тот же блок.
[55:22.260 --> 55:29.460]  Ну, а все остальные ребра добавить в очередь и их рассматривать
[55:29.460 --> 55:30.940]  одно с другим, пока очередь не опустеть.
[55:30.940 --> 55:47.540]  Значит, остальные просмотренные ребра, добавить в очередь
[55:47.540 --> 56:03.620]  так, ну, на примере давайте вот этого графа опять это
[56:03.620 --> 56:20.700]  сделаем.
[56:20.700 --> 56:23.300]  Давайте я жирным выделю еще древесные ребра здесь.
[56:23.300 --> 56:28.460]  Вот древесное ребро, значит, вот так вот мы пойдем, вот
[56:29.020 --> 56:38.180]  так вот, ну, туда я уже не пойду.
[56:38.180 --> 56:41.140]  Вот, жирным выделю древесные ребра.
[56:41.140 --> 56:42.860]  Значит, на первом шаге я добавляю вот это ребро
[56:42.860 --> 56:43.860]  в очередь.
[56:43.860 --> 56:47.500]  Из корня больше нет никаких других исходящих древесных
[56:47.500 --> 56:49.780]  ребр, я добавляю только его, говорю, что это начало
[56:49.780 --> 56:50.780]  очередного блока.
[56:50.780 --> 56:55.180]  Дальше, достаю это ребро из очереди, обхожу все,
[56:55.480 --> 57:00.260]  что возможно из этой вершины, которая не доказывает, что
[57:00.260 --> 57:01.620]  текущий вершины точка ш organs.
[57:01.620 --> 57:04.540]  То есть, из этой вершины есть много исходящих ребер,
[57:04.540 --> 57:08.240]  древесных, вот эта, вот эта, но у этой не доказывает,
[57:08.240 --> 57:10.420]  что точка ш organs, потому что это как-бы говорит, что
[57:10.420 --> 57:13.940]  мы переходим в новую компонент, это тоже говорит, что мы
[57:13.940 --> 57:15.240]  переходим в новую компонент.
[57:15.240 --> 57:16.240]  И поэтому мы перейдем только сюда.
[57:16.240 --> 57:18.720]  Ну, здесь тоже видим обратное ребро, об decidedly, обратные
[57:18.720 --> 57:21.840]  ребры, понятно, лежат там же, где и текущие вершины,
[57:21.840 --> 57:23.760]  потому что они еще выше куда-то поднимаются, поэтому
[57:23.760 --> 57:28.220]  мы вот тем самым найдем одну компоненту вершин до связности, и при этом найдем
[57:28.220 --> 57:31.860]  еще три ребра, которые мы положили в очередь. Мы положили вот это ребро в очередь,
[57:31.860 --> 57:36.020]  вот это ребро в очередь, и вот это. Они являются как бы началами новых блоков.
[57:36.020 --> 57:40.540]  Ну и с ними то же самое. Значит, вот отсюда мы это ребро из очереди достаём, обходим
[57:40.540 --> 57:44.380]  всё, что возможно, находим целиком новую компоненту вершин до связности, больше
[57:44.380 --> 57:50.380]  ничего не находим. Дальше обрываем, скажем, вот это ребро. Видим, что отсюда нет ни
[57:50.380 --> 57:55.320]  одного ребра, которое бы доказывало, что оно не точка шлининия. Поэтому это будет
[57:55.320 --> 57:58.480]  отдельная компонента с одним ребром, но зато мы найдем, что вот это вот ребро
[57:58.480 --> 58:01.640]  доказывает, что это точка шлининия, поэтому даваем его в очередь.
[58:01.640 --> 58:06.840]  Сейчас в очереди вот это ребро и вот это два, ну мы их также не рекурсивно,
[58:06.840 --> 58:15.680]  а в вайле пока очередь не пустая, обрабатываем. Вот, вопросы?
[58:15.680 --> 58:32.900]  Смотрите, есть древесное ребро v2, я говорю, что оно в кавычках доказывает, что v это
[58:32.900 --> 58:46.860]  точка шлининия, ну нет, даже без кавычек, если r2 больше и равно 3 на v. То есть как раз,
[58:46.860 --> 58:50.780]  что его удаление делает так, что вот это всё под дерево, perdон, после удаления v,
[58:50.780 --> 58:57.820]  ну да, после удаления v, я не смогу из этого под дерево прыгнуть выше, чем v. Соответственно,
[58:57.820 --> 59:01.340]  наоборот, оно не доказывает, если это неравенство выполнило в обратную сторону, тогда наоборот,
[59:01.500 --> 59:04.940]  что я могу по этому ребру пройти и всё равно потом отсюда прыгнуть,
[59:04.940 --> 59:08.900]  куда-то наверх, значит, якобы, должен продолжить эту компоненту вершины десантности.
[59:08.900 --> 59:21.020]  Ну, для удобства я бы сказал так, у нас есть первый DFS, который находит таинные ретёрны,
[59:21.020 --> 59:27.660]  а дальше есть вот этот алгоритм отдельно, который по очереди, ну то есть в очереди все
[59:27.660 --> 59:31.100]  ребра обрыватывает и запускает ещё отдельный DFS, то есть скорее два DFS,
[59:31.100 --> 59:37.820]  а первый находит ретёрны, а второй просто всё обходит, ну, не выходящие за границы
[59:37.820 --> 59:42.700]  текущей компоненты, и все плохие ребра, наоборот, добавляют в очередь.
[59:42.700 --> 59:52.660]  Ну да, но это несложно, конечно. На самом деле, это не обязательно делать,
[59:52.660 --> 59:59.380]  потому что если вы не перемешиваете порядок ребер, то у вас как бы, ну и второй алгоритм сам может
[59:59.380 --> 01:00:03.420]  понимать, какие ребра древесные, потому что если просто, ну, он обходит ребра в том же порядке,
[01:00:03.420 --> 01:00:13.940]  значит, всегда, когда он пойдёт вниз, это древесное ребро. Так, ну хорошо, вроде мы закончили с этими
[01:00:13.940 --> 01:00:25.860]  компонентами с двусвязностью. Три связанности я уже не умею, не знаю, что это даже, поэтому
[01:00:25.860 --> 01:00:38.860]  возьмём ещё отдельный кусочек про эйлеровые циклы, эйлеровые циклы, эйлеровые пути.
[01:00:38.860 --> 01:01:07.820]  Так, определение. Вершина называется изолированной, если она не инзидента ни одному ребру. Ну или так,
[01:01:07.820 --> 01:01:22.140]  она не является концом ни одного ребра. То есть просто это вот прям точка, подвешенная в пустоте,
[01:01:22.140 --> 01:01:25.740]  а весь граф где-то вот отдельно от неё располагается. Она ни с кем не соединена,
[01:01:25.740 --> 01:01:33.260]  нет ребер никаких ни в неё, ни из неё. Значит, если бы граф был не ориентированный, то мне нужно
[01:01:33.340 --> 01:01:39.880]  было бы просто сказать, что у неё степень равна 0, на степень это число просто ребер,
[01:01:39.880 --> 01:01:44.480]  которые из неё исходят. Число ребер, который её содержит скорее всего конца. Если бы граф был
[01:01:44.480 --> 01:01:48.700]  ориентированный, то мне нужно было бы сказать, что в неё не входит ни одно ребро и не изходит ни
[01:01:48.700 --> 01:01:54.140]  одно ребро. Потому что в ориентированной графе степень не определяется, определяется входная
[01:01:54.140 --> 01:01:58.220]  степень и исходящия степень. Поэтому, значит, это в случае неориентированного графа я говорю,
[01:01:58.220 --> 01:02:02.500]  0, а в случае ориентированной я говорю, что in degree равна
[01:02:02.500 --> 01:02:06.220]  0 и out degree равна 0. То есть ни одно ребро не входит
[01:02:06.220 --> 01:02:09.420]  и ни одно ребро не выходит. Это если граф ориентированных.
[01:02:09.420 --> 01:02:34.660]  Теорема. Пусть g это такой граф, который становится связанным после удаления всех
[01:02:34.660 --> 01:02:41.620]  изолированных вершин. Неориентированный. Пусть g это неориентированный граф, становящийся
[01:02:41.620 --> 01:02:51.180]  связанным после удаления всех изолированных вершин.
[01:02:51.180 --> 01:03:14.340]  Я забыл определить error в цикл, ну ладно. Тогда в g есть error в цикл, то есть такой цикл,
[01:03:14.340 --> 01:03:24.980]  который проходит по каждому ребру ровно один раз. То есть цикл, проходящий по каждому ребру,
[01:03:24.980 --> 01:03:48.500]  ровно один раз. Если и только если, продолжите утверждение теоремы. Все верно. Степень
[01:03:48.500 --> 01:04:09.140]  всех вершин чётная. Замещание в сторону. Смотрите, мы говорим про error в цикл, который посещает все
[01:04:09.140 --> 01:04:16.020]  ребра по одному разу. До этого, когда мы говорили про динамику по маскам, мы рассматривали гамельные
[01:04:16.020 --> 01:04:21.900]  циклы, которые пытались посещать все вершины по одному разу. Эти задачи принципиально разной
[01:04:21.900 --> 01:04:29.380]  сложности, по крайней мере на текущий момент развития алгоритмической науки. Гамельные циклы
[01:04:29.380 --> 01:04:35.060]  мы не умеем находить или проверять существование за какое-то адекватное время. А для error в цикла
[01:04:35.060 --> 01:04:40.420]  есть такой простой критерий, что нужно проверить связанность изолированных и дальше нужно
[01:04:40.420 --> 01:04:46.180]  просто проверить, что все вершины чётной степени. Такое большое различие в сложности
[01:04:46.180 --> 01:05:00.500]  определения существования гамельного и error в циклу. Просто для принятия к сведению, поднимите
[01:05:00.500 --> 01:05:13.900]  пожалуйста руки те, кто видели эту теорему. Давайте мы её докажем, нам всё равно строить алгоритм,
[01:05:13.900 --> 01:05:21.860]  мы построим конструктивное доказательство. В одну сторону очевидно, что если есть error
[01:05:21.860 --> 01:05:25.460]  в циклу, то понятное дело, что степень у всех высшинчётная, потому что что такое error в циклу?
[01:05:25.460 --> 01:05:33.020]  Ну это какая-то такая картинка. Что-то вот такое, вот такое. Цикла, проходящая по всем рёбрам,
[01:05:33.020 --> 01:05:38.300]  надо тогда сказать, что степень всех высшинчётная. То есть есть ещё понятное дело, где-то изолированные,
[01:05:38.300 --> 01:05:41.940]  которые не нужно посещать, потому что они ни с кем не соединены, они там рёбер из них нету,
[01:05:41.940 --> 01:05:47.780]  значит с ними всё хорошо, у них ноль чётная. Ну а дальше понятное дело, что если мы проходим,
[01:05:47.780 --> 01:05:53.660]  значит если мы берём какой-то цикл, можно сказать так вот, мы приходим в вершину, значит нашли
[01:05:54.540 --> 01:05:59.160]  входящее в нее ребро, затем вышли и нашли исходящее, то есть когда мы заходим в вершину и выходим из нее,
[01:05:59.160 --> 01:06:05.120]  мы по сути находим два ребра, которые инцидентны. Значит вот нашли два ребра из нее, здесь тоже
[01:06:05.120 --> 01:06:08.440]  самое, нашли два ребра, которые инцидентны этой вершине и так далее. Ну там на пересечении,
[01:06:08.440 --> 01:06:13.820]  есть ребро входящего и исходящего когда мы шли вот так, есть опять входящего, исходящего когда
[01:06:13.820 --> 01:06:19.900]  шли вот так. Поэтому если мы пустили все ребра, то больше никаких ребр нету, и у каждой вершины
[01:06:19.900 --> 01:06:24.640]  на этом цикле, понятно дело, четные степени, потому что мы в нее зашли, вышли, степень изменили на два каждый раз.
[01:06:24.640 --> 01:06:29.340]  Да, мы можем входить несколько раз, но вот это как раз соответствует этой картинке, что мы можем, скажем,
[01:06:29.340 --> 01:06:33.580]  увеличить на два несколько раз степень какой-то вершины, это ничему не противоречит.
[01:06:33.580 --> 01:06:41.020]  Ну вот на пальцах как-то так. Просто рисуем картинку, понимаем, что в каждую вершину мы как бы...
[01:06:41.020 --> 01:06:48.460]  Ну заход в вершину, это означает увеличение степени на два. Значит всегда все степени четные.
[01:06:48.460 --> 01:06:55.140]  Так, ну вот в обратную сторону, будет похитрее, мы сейчас напишем алгоритм.
[01:07:13.140 --> 01:07:18.060]  Мы считаем, что наш граф связан, давайте сразу там изолированные вершины игнорируем,
[01:07:18.060 --> 01:07:24.740]  пусть наш граф связан и все степени всех решит четные. Тогда хочу написать такую процедуру
[01:07:24.740 --> 01:07:37.020]  нахождения Эйлерова цикла. Эйлер от вершины В делает следующее, пытается проходить все вершины,
[01:07:37.020 --> 01:07:43.140]  все ребра торчащие из В, и давайте для каждого ребра поддерживать оно уже посещено или нет,
[01:07:43.140 --> 01:07:47.580]  помечено оно или нет. Тогда делаем следующее, пока есть хотя бы одно непомеченное ребро,
[01:07:47.580 --> 01:07:59.060]  значит пока из В есть исходящее непомеченное ребро, непомеченное ребро,
[01:07:59.060 --> 01:08:12.980]  значит мы какое-то такое одно ребро конкретно находим, пусть в ВУ такое ребро. Тогда,
[01:08:13.020 --> 01:08:20.860]  во-первых, я хочу поместить его помеченным, помечаем его как использованным, помечаем его
[01:08:20.860 --> 01:08:31.860]  использованным, чтобы не ходить по ребрам два раза, ну и рекурсивно запускаемся от вершинки У.
[01:08:31.860 --> 01:08:49.900]  Вайл кончился, в конце принт В, конец. Академик просто встает в вершину, пытается найти какое-нибудь
[01:08:49.900 --> 01:08:55.020]  исходящее ребро, которое еще не использовано, не помечено, если он его находит, то просто
[01:08:55.020 --> 01:08:59.380]  рекурсивно запускается от, то есть помечается сначала его помеченным, конечно, использованным,
[01:08:59.380 --> 01:09:05.740]  потом запускается рекурсивно от конца этого ребра. Вот и в конце, если Вайл целиком отработал,
[01:09:05.740 --> 01:09:19.100]  то мы печатаем вершину В как очередную вершину нашего цикла. Так, как это работает? Давайте на
[01:09:19.100 --> 01:09:37.140]  конце примера нарисуем. Ну вот что-нибудь такое. Вот, есть некая вершина С, и мы, соответственно,
[01:09:37.140 --> 01:09:48.300]  из мейна запускаем Иль Ротес. Тогда в результате вот этого запуска я утверждаю, что мы обойдем все
[01:09:48.300 --> 01:09:53.460]  ребра ровно по одному разу, и напечатается у нас какой-то Эйлеров цикл. То есть последовательная
[01:09:53.460 --> 01:10:00.380]  вершина, которая, если по ней идти в этом порядке, то получится Эйлеров цикл. Ну давайте промоделируем,
[01:10:00.380 --> 01:10:05.260]  как это работает вот здесь. Значит, сначала мы встаем в Эйлер Ротес, пытаемся идти просто по
[01:10:05.260 --> 01:10:10.380]  ребрам, помечая их использованными, и рекурсивно запускать от конца этого ребра. Например, вот здесь
[01:10:10.380 --> 01:10:14.620]  мы пошли сюда пометили использованным, рекурсивно запустились отсюда, пошли сюда, сюда, сюда,
[01:10:14.620 --> 01:10:22.700]  например, вот так пошли. Идем, идем, идем, идем, идем, идем. В конце запускаем Эйлер Ротес и видим,
[01:10:22.700 --> 01:10:28.180]  что теперь же уже из С нет ни одного не помеченного ребра, они все помечены. Поэтому первое, что мы
[01:10:28.180 --> 01:10:36.460]  сделаем, это напечатаем С. То есть мы нашли вот такой цикл, опять запустились Эйлером от С,
[01:10:36.460 --> 01:10:41.380]  то есть у меня теперь в стеке рекурсии вершинка С два раза лежит. Сначала вот из мейна, и потом
[01:10:41.380 --> 01:10:45.580]  еще когда мы весь цикл обошли, мы ее опять кладем на стек рекурсии, достаем, видим, что нет ни
[01:10:45.580 --> 01:10:49.980]  одного неиспользованного ребра, значит печатаем. Потом откатываемся в рекурсии, понимаем, что у всех
[01:10:49.980 --> 01:10:56.820]  этих вершинок нет ни одного не помеченного ребра исходящего, значит поэтому начало нашего цикла
[01:10:56.820 --> 01:11:04.300]  оно вот такое. Ну давайте я как-нибудь тут обзову их там 1, а 2 и так далее. Пока. Тогда мы их вот так
[01:11:04.300 --> 01:11:14.020]  напечатаем. Рекурсия развернется до этой вершины. Дальше отсюда есть, конечно, какие-то исходящие
[01:11:14.020 --> 01:11:21.540]  ребра не помеченные. Например, мы пойдем вот так. Вот. Запускаемся рекурсивно от нее, от нее,
[01:11:21.540 --> 01:11:33.420]  от нее. Здесь, например, мы пойдем вот сюда. Потом опять запустимся рекурсивно вот от нее и дойдем
[01:11:33.420 --> 01:11:41.060]  вот так. Вот что может быть, например. Тогда что? Тогда я дойду до этой вершины и она будет без
[01:11:41.060 --> 01:11:46.860]  не помеченных исходящих ребр, я ее должен буду напечатать. Потом рекурсия развернется досюда и
[01:11:46.860 --> 01:11:58.020]  досюда. Так, ну давайте, как ее назвать? Давайте я назову у. 1, у, 2. Это будет у. Потом мы развернем
[01:11:58.020 --> 01:12:05.420]  и напечатаем у. 1, у, 2. Потом напечатаем у, потому что из у нет исходящих. Затем мы вспоминаем,
[01:12:05.420 --> 01:12:11.460]  как мы попали в у. Мы попали из нее, проходя по этому циклу вот в ту сторону. Тогда мы их тоже
[01:12:11.460 --> 01:12:23.500]  напечатаем. Там b1, b2, b3, b4. Затем мы опять из рекурсии, из стек рекурсии достанем у. Опять видим,
[01:12:23.500 --> 01:12:28.740]  что из нее нет исходящих, поэтому печатаем у. Ну и потом, значит, наконец нам нужно будет вот
[01:12:28.740 --> 01:12:34.260]  здесь вот так у. 3, у. 4 напечатать. Рекурсия развернется. Потом она развернется до вот этого
[01:12:34.260 --> 01:12:38.820]  x, из которого опять нет исходящих ребр, поэтому мы его печатаем. Ну и наконец вот эту вот последнюю
[01:12:38.820 --> 01:12:45.020]  вершинку t мы тоже напечатаем и дойдем до s, который тоже в конце напечатаем. Вот такой будет Эллеров
[01:12:45.020 --> 01:12:57.780]  цикл. Это пример работы. Тут в странном порядке. Относительно того, в каком порядке мы просматриваем
[01:12:57.780 --> 01:13:03.620]  ребра, это все порядок совсем не такой, в котором мы его просматриваем. Еще раз, я начал вот так вот,
[01:13:03.620 --> 01:13:11.300]  а цикл начинаю вот так вот. Дальше здесь я как-то вот так вот обходил и первое, что напечатал,
[01:13:11.300 --> 01:13:15.380]  так, ну первое, что напечатал, стало у, да, ну то есть потом я как бы в обратную сторону разворачиваю.
[01:13:15.380 --> 01:13:21.620]  Если я прошел вот так вот эту восьмерку, то я как бы с конца начинаю печатать. x, у. 1, у. 2, у. Вот этот
[01:13:21.620 --> 01:13:27.380]  вот хвост я напечатал, потом я как бы в обратную сторону развернул. Ну а получился, как видите,
[01:13:27.380 --> 01:13:36.820]  Эллеров цикл. Давайте я его нарисую. Мы сначала прошли вот так, до x, потом вот так, до у,
[01:13:36.820 --> 01:13:43.300]  потом разворот. Ну в общем, вот эту восьмерку так обошли в каком-то порядке и потом вернулись в
[01:13:43.300 --> 01:13:50.500]  с. Так, вот, ну и хочется сказать, что в общем случае мы нашим Эллером все посетим,
[01:13:50.500 --> 01:14:05.420]  серебра по одному разу, получишь Эллеров цикл. Смотрите, смотрите, вот мы когда эту рекурсию
[01:14:05.540 --> 01:14:10.180]  развернули, мы дошли до х. Значит мы запускаемся рекурсивно отсюда, отсюда, отсюда, отсюда, отсюда,
[01:14:10.180 --> 01:14:15.220]  отсюда, отсюда, отсюда и это будет первая вершина, которую мы увидим, без исходящих
[01:14:15.220 --> 01:14:29.420]  неотноточных ребер. Поэтому ее вот здесь напечатаем. Значит, главная мысль здесь такая, смотрите,
[01:14:29.420 --> 01:14:34.900]  давайте мы рассмотрим вообще первую вершину, которую напечатаем. Понятно, что это с. Почему?
[01:14:34.900 --> 01:14:39.900]  Вот мы запустились айлером от вершинки S и делаем следующее.
[01:14:39.900 --> 01:14:41.900]  Мы просто идем, пока не устанем.
[01:14:41.900 --> 01:14:43.900]  Вот идем, идем, идем, идем, идем, идем.
[01:14:43.900 --> 01:14:46.900]  Каждый раз, заходя в вершину, когда мы заходим в вершину,
[01:14:46.900 --> 01:14:48.900]  мы, по сути, уменьшаем ее степень на один,
[01:14:48.900 --> 01:14:52.900]  потому что мы отмечаем одно из ребер в нее помеченным.
[01:14:52.900 --> 01:14:54.900]  И затем, когда выходим, тоже уменьшаем степень на один,
[01:14:54.900 --> 01:14:56.900]  потому что еще одно ребро нашли.
[01:14:56.900 --> 01:14:59.900]  И поскольку все вершины изначально имеют четную степень,
[01:14:59.900 --> 01:15:02.900]  то единственная вершина, где мы можем завершить этот обход,
[01:15:02.900 --> 01:15:04.900]  это только S.
[01:15:04.900 --> 01:15:07.900]  Что значит, что мы завершаем обход?
[01:15:07.900 --> 01:15:09.900]  Значит, мы больше не видим ни одного исходящего ребра.
[01:15:09.900 --> 01:15:13.900]  Но если я вычитаю по два из каждой вершины,
[01:15:13.900 --> 01:15:15.900]  то значит, я могу продолжить путь,
[01:15:15.900 --> 01:15:17.900]  коль скоро исходная степень была двойка.
[01:15:17.900 --> 01:15:20.900]  То есть я буду так ходить, ходить, ходить, ходить,
[01:15:20.900 --> 01:15:22.900]  и закончиться могу только в S.
[01:15:22.900 --> 01:15:23.900]  Это первая вершина.
[01:15:23.900 --> 01:15:25.900]  То есть эта вершина, когда я из нее вышел,
[01:15:25.900 --> 01:15:27.900]  у нее стала как бы нечетная степень.
[01:15:27.900 --> 01:15:31.900]  И значит, не продолжить путь я смогу только, если приду в нее.
[01:15:31.900 --> 01:15:34.900]  Потому что у всех остальных она всегда четная остается.
[01:15:34.900 --> 01:15:36.900]  Мы вошли-вышли, остается четная степень,
[01:15:36.900 --> 01:15:38.900]  только у нее нечетная.
[01:15:38.900 --> 01:15:40.900]  Значит, у S исходная степень может быть,
[01:15:40.900 --> 01:15:42.900]  то есть она исходно четная,
[01:15:42.900 --> 01:15:44.900]  но когда я выхожу из нее, она становится нечетная,
[01:15:44.900 --> 01:15:46.900]  значит завершить это я буду обязан в ней.
[01:15:46.900 --> 01:15:48.900]  Поэтому мораль следующая,
[01:15:48.900 --> 01:15:52.900]  что когда я что-то печатаю,
[01:15:52.900 --> 01:15:56.900]  это значит, что я нашел какой-то вот такой цикл.
[01:15:56.900 --> 01:15:58.900]  Первая вершинка будет напечатана,
[01:15:58.900 --> 01:16:00.900]  это обязательно S.
[01:16:00.900 --> 01:16:02.900]  Вот оно, S стоит в начале.
[01:16:02.900 --> 01:16:05.900]  Значит, затем моя рекурсия начнет разворачиваться.
[01:16:05.900 --> 01:16:07.900]  Ну и, например, там первые несколько вершин
[01:16:07.900 --> 01:16:09.900]  будут без еще исходящих ребер,
[01:16:09.900 --> 01:16:11.900]  то есть с ней, скажем, были степени 2.
[01:16:11.900 --> 01:16:13.900]  Вот я их так обошел, просто напечатал.
[01:16:13.900 --> 01:16:17.900]  А затем будет вершина с исходящими ребрами.
[01:16:17.900 --> 01:16:20.900]  Ну тогда картинку можно представить следующим образом.
[01:16:20.900 --> 01:16:22.900]  Вот давайте мы этот цикл как бы вычтем
[01:16:22.900 --> 01:16:24.900]  из нашего графа исходного,
[01:16:24.900 --> 01:16:26.900]  тогда степень всех вершин останутся четными.
[01:16:26.900 --> 01:16:28.900]  И я, по сути, запускаю Эйлера от вот этой вершины,
[01:16:28.900 --> 01:16:30.900]  Эйлер от X.
[01:16:30.900 --> 01:16:32.900]  Вот как в этом случае, я дошел до вершины,
[01:16:32.900 --> 01:16:34.900]  из которой есть разветвление,
[01:16:34.900 --> 01:16:36.900]  у меня запускается там Эйлер от X.
[01:16:36.900 --> 01:16:38.900]  При этом все эти ребра уже помечены использованными.
[01:16:38.900 --> 01:16:40.900]  Ну тогда понятное дело, что опять,
[01:16:40.900 --> 01:16:42.900]  если я запускаю тупой просто обход
[01:16:42.900 --> 01:16:44.900]  и пояс какого-то цикла,
[01:16:44.900 --> 01:16:46.900]  то завершиться смогу только в X.
[01:16:46.900 --> 01:16:49.900]  Потому что раз я пометил все вот эти старые ребра использованными,
[01:16:49.900 --> 01:16:52.900]  то эта вершина будет единственной вершиной нечетной степени,
[01:16:52.900 --> 01:16:54.900]  когда я запускаю Эйлер от X.
[01:16:54.900 --> 01:16:56.900]  То есть я вот вышел первое ребро,
[01:16:56.900 --> 01:16:58.900]  и единственный момент, когда я могу закончиться,
[01:16:58.900 --> 01:17:00.900]  не найти исходящих еще,
[01:17:00.900 --> 01:17:02.900]  это только вот здесь,
[01:17:02.900 --> 01:17:04.900]  потому что все остальные четные степени имеют.
[01:17:04.900 --> 01:17:10.900]  Я буду вот так вот обходить наш граф,
[01:17:10.900 --> 01:17:13.900]  всегда буду завершаться в той вершине,
[01:17:13.900 --> 01:17:15.900]  из которой я начал.
[01:17:15.900 --> 01:17:19.900]  То есть если я из вершины вижу какое-то исходящее ребро,
[01:17:19.900 --> 01:17:24.900]  то вот этот Эйлер видит какое-то исходящее ребро.
[01:17:24.900 --> 01:17:26.900]  Тогда он первым делом напечатает,
[01:17:26.900 --> 01:17:28.900]  то есть первая выведенная вершинка будет X.
[01:17:28.900 --> 01:17:30.900]  Это нам гарантирует то,
[01:17:30.900 --> 01:17:32.900]  что когда мы разворачиваем вот эту штуку,
[01:17:32.900 --> 01:17:34.900]  всю рекурсию,
[01:17:34.900 --> 01:17:36.900]  то мы сначала напечатаем вот этот кусок пути,
[01:17:36.900 --> 01:17:38.900]  потом напечатаем X,
[01:17:38.900 --> 01:17:40.900]  здесь как-то этот цикл обойдем,
[01:17:40.900 --> 01:17:42.900]  опять напечатаем X,
[01:17:42.900 --> 01:17:44.900]  и потом продолжим разворачивать нашу рекурсию.
[01:17:44.900 --> 01:17:46.900]  И в каждом минуте времени мы действительно,
[01:17:46.900 --> 01:17:48.900]  то есть соседние вершинки обязательно будут соединили ребром,
[01:17:48.900 --> 01:17:50.900]  потому что,
[01:17:50.900 --> 01:17:52.900]  из этого соображения,
[01:17:52.900 --> 01:17:54.900]  мы получили простую рекурсию
[01:17:54.900 --> 01:17:56.900]  и просто поднялись
[01:17:56.900 --> 01:17:58.900]  между связанными ребром вершинами,
[01:17:58.900 --> 01:18:02.900]  либо вошли в такую более сложную рекурсию,
[01:18:02.900 --> 01:18:04.900]  когда нужно обходить новый цикл,
[01:18:04.900 --> 01:18:06.900]  и по индукции сначала обошли цикл,
[01:18:06.900 --> 01:18:08.900]  потом опять напечатали X,
[01:18:08.900 --> 01:18:10.900]  потому что из X не остался ребер.
[01:18:14.900 --> 01:18:16.900]  Наверное, максимально формально,
[01:18:16.900 --> 01:18:18.900]  что я могу здесь сказать.
[01:18:18.900 --> 01:18:20.900]  Давайте какие-то мысли запишем.
[01:18:22.900 --> 01:18:24.900]  Элеротез
[01:18:24.900 --> 01:18:26.900]  завершается
[01:18:28.900 --> 01:18:30.900]  на вершине S.
[01:18:34.900 --> 01:18:36.900]  То есть это первая выведенная вершина.
[01:18:36.900 --> 01:18:38.900]  Дальше.
[01:18:38.900 --> 01:18:40.900]  Когда мы этот S напечатали,
[01:18:40.900 --> 01:18:44.900]  давайте удалим из графа все использованные ребра.
[01:18:46.900 --> 01:18:48.900]  Удалим мысленно
[01:18:48.900 --> 01:18:50.900]  все использованные ребра.
[01:18:52.900 --> 01:18:54.900]  Значит, опять останется,
[01:18:54.900 --> 01:18:56.900]  что степень всех вершин чётная.
[01:18:56.900 --> 01:18:58.900]  Опять.
[01:18:58.900 --> 01:19:00.900]  Степень всех вершин чётная.
[01:19:04.900 --> 01:19:06.900]  Всех вершин чётная.
[01:19:06.900 --> 01:19:08.900]  То есть, по сути, мы нашли какой-то цикл,
[01:19:08.900 --> 01:19:10.900]  он льёт в стеке рекурсии.
[01:19:10.900 --> 01:19:12.900]  Мы его удаляем,
[01:19:12.900 --> 01:19:14.900]  поочерёдно выводя вот эти вершинки.
[01:19:14.900 --> 01:19:16.900]  Затем можем опять попасть в какую-то вершину,
[01:19:16.900 --> 01:19:18.900]  из которой есть неиспользованные исходящие ребра.
[01:19:18.900 --> 01:19:20.900]  То есть вершина положительная,
[01:19:20.900 --> 01:19:22.900]  доходим до неё,
[01:19:22.900 --> 01:19:24.900]  в стеке рекурсии.
[01:19:26.900 --> 01:19:28.900]  Доходим до X.
[01:19:34.900 --> 01:19:36.900]  Ну и там, скажем, по предположению индукции,
[01:19:36.900 --> 01:19:38.900]  там индукция почту ребер в графе.
[01:19:38.900 --> 01:19:40.900]  Мы удалили какой-то цикл.
[01:19:40.900 --> 01:19:42.900]  Дальше считаем, что у нас
[01:19:42.900 --> 01:19:44.900]  находится корректный
[01:19:44.900 --> 01:19:46.900]  Эйлеров цикл со стартом в X.
[01:19:46.900 --> 01:19:48.900]  То есть мы обходим всё, что у нас есть.
[01:19:48.900 --> 01:19:50.900]  Мы обходим всё, что из него достижимо.
[01:19:50.900 --> 01:19:52.900]  Печатаем по индукции.
[01:19:52.900 --> 01:19:54.900]  Соответственно у меня напечатается
[01:19:54.900 --> 01:19:56.900]  корректный весь цикл.
[01:19:56.900 --> 01:19:58.900]  Ну и дальше я продолжу разворачивать
[01:19:58.900 --> 01:20:00.900]  внешнюю рекурсию, у меня напечатается дальше
[01:20:00.900 --> 01:20:02.900]  продолжение этого пути.
[01:20:02.900 --> 01:20:04.900]  То есть я до сюда дошёл,
[01:20:04.900 --> 01:20:06.900]  отвлёкся на то, чтобы напечатать этот цикл,
[01:20:06.900 --> 01:20:08.900]  и потом опять продолжил печатать цикл,
[01:20:08.900 --> 01:20:10.900]  который я в самом начале нашёл.
[01:20:10.900 --> 01:20:12.900]  Всё, поэтому единственное, что мне нужно,
[01:20:12.900 --> 01:20:14.900]  это что все степени чётные,
[01:20:14.900 --> 01:20:16.900]  для того, чтобы цикл обязательно завершался там же,
[01:20:16.900 --> 01:20:18.900]  вот в общем-то и всё.
[01:20:18.900 --> 01:20:20.900]  Так, ну здесь
[01:20:20.900 --> 01:20:22.900]  не очень формально, понимаю,
[01:20:22.900 --> 01:20:24.900]  но формальнее давайте не будем.
[01:20:24.900 --> 01:20:26.900]  И требовать этого
[01:20:26.900 --> 01:20:28.900]  с вас я тоже не буду.
[01:20:32.900 --> 01:20:34.900]  Ну да, кажется всё.
[01:20:34.900 --> 01:20:36.900]  Ну симпточка тоже понятное дело линейная.
[01:20:38.900 --> 01:20:40.900]  А, сори,
[01:20:40.900 --> 01:20:42.900]  чтобы до начала симпточки
[01:20:42.900 --> 01:20:44.900]  надо сначала алгоритм написать.
[01:20:44.900 --> 01:20:46.900]  То есть мы его написали так,
[01:20:46.900 --> 01:20:48.900]  как бы без кода, я бы сказал,
[01:20:48.900 --> 01:20:50.900]  потому что нам нужно как-то
[01:20:50.900 --> 01:20:52.900]  понимать, когда есть исходящее ребро
[01:20:52.900 --> 01:20:54.900]  непосещённое,
[01:20:54.900 --> 01:20:56.900]  как его находить.
[01:21:00.900 --> 01:21:02.900]  Как находить
[01:21:02.900 --> 01:21:04.900]  непомеченное ребро.
[01:21:08.900 --> 01:21:10.900]  Здесь можно, например,
[01:21:10.900 --> 01:21:12.900]  применить такой трюк.
[01:21:12.900 --> 01:21:14.900]  Давайте мы
[01:21:14.900 --> 01:21:16.900]  заведём структуру ребро,
[01:21:16.900 --> 01:21:18.900]  struct edge.
[01:21:18.900 --> 01:21:20.900]  Значит, ребро ханит
[01:21:20.900 --> 01:21:22.900]  два параметра, откуда оно и куда.
[01:21:22.900 --> 01:21:24.900]  Две вершины, откуда куда.
[01:21:26.900 --> 01:21:28.900]  И, соответственно, ну поскольку
[01:21:28.900 --> 01:21:30.900]  у меня граф не ориентированный,
[01:21:30.900 --> 01:21:32.900]  я, если вижу ребро из У в В,
[01:21:32.900 --> 01:21:34.900]  то я его по сути раздваиваю
[01:21:34.900 --> 01:21:36.900]  и превращаю в ребро из У в В,
[01:21:36.900 --> 01:21:38.900]  из В в У.
[01:21:38.900 --> 01:21:40.900]  Ну и всё, мы так делаем,
[01:21:40.900 --> 01:21:42.900]  когда пускаем, скажем, DFS
[01:21:42.900 --> 01:21:44.900]  по неориентированному графу,
[01:21:44.900 --> 01:21:46.900]  мы каждое вот такое ребро,
[01:21:46.900 --> 01:21:48.900]  если мы видим ребро из У в В,
[01:21:48.900 --> 01:21:50.900]  то мы в список для У добавляем В,
[01:21:50.900 --> 01:21:52.900]  и в список для В добавляем У,
[01:21:52.900 --> 01:21:54.900]  то есть по сути раздаваем ребро всегда.
[01:21:54.900 --> 01:21:56.900]  И дальше давайте сделаем так.
[01:21:56.900 --> 01:21:58.900]  Давайте скажем, что вот эти два ребра
[01:21:58.900 --> 01:22:00.900]  имеют номера, ну скажем,
[01:22:00.900 --> 01:22:02.900]  2k и 2k плюс 1.
[01:22:02.900 --> 01:22:04.900]  То есть если у меня это было ката-ребро
[01:22:04.900 --> 01:22:06.900]  в моём входном файле,
[01:22:06.900 --> 01:22:08.900]  то эти будут ребра номер 2k и 2k плюс 1.
[01:22:08.900 --> 01:22:10.900]  Что у вас первые два ребра,
[01:22:10.900 --> 01:22:12.900]  которые у вас хранятся,
[01:22:12.900 --> 01:22:14.900]  это по сути одно и то же ребро входного графа,
[01:22:14.900 --> 01:22:16.900]  который вы раздвоили.
[01:22:16.900 --> 01:22:18.900]  Дальше, второе и третье тоже одно и то же самое ребро,
[01:22:18.900 --> 01:22:20.900]  ну, противоположные ребра просто.
[01:22:20.900 --> 01:22:22.900]  4-5 противоположные ребра, ну и так далее.
[01:22:22.900 --> 01:22:24.900]  В общем случае, 2k и 2k плюс 1
[01:22:24.900 --> 01:22:26.900]  это два противоположных ребра
[01:22:26.900 --> 01:22:28.900]  из У в В из В У.
[01:22:28.900 --> 01:22:30.900]  И это удобно следующим,
[01:22:30.900 --> 01:22:32.900]  что если E это одно из ребер,
[01:22:32.900 --> 01:22:34.900]  тогда E 41 это другое ребро.
[01:22:38.900 --> 01:22:40.900]  Ну потому что вам нужно просто поменять чётность,
[01:22:40.900 --> 01:22:42.900]  скажем, если вы видите 5-ое ребро,
[01:22:42.900 --> 01:22:44.900]  то, значит, дополнить, ну обратное к нему,
[01:22:44.900 --> 01:22:46.900]  это 4-ое, то есть вам нужно
[01:22:46.900 --> 01:22:48.900]  поменять чётность последнего бита.
[01:22:48.900 --> 01:22:50.900]  Поменять просто последний бит, значит,
[01:22:50.900 --> 01:22:52.900]  из 5-ого сделать 4-ку.
[01:22:52.900 --> 01:22:54.900]  Наоборот, скажем, если вы видите 2-ое ребро,
[01:22:54.900 --> 01:22:56.900]  то вы знаете, что с ним в паре стоит 3-е,
[01:22:56.900 --> 01:22:58.900]  а обратное ребро это 3-е.
[01:22:58.900 --> 01:23:00.900]  Но это как раз отличается от 4-ого ребра.
[01:23:00.900 --> 01:23:02.900]  А обратное ребро это 3-е.
[01:23:02.900 --> 01:23:04.900]  Но это как раз отличается чётностью,
[01:23:04.900 --> 01:23:06.900]  просто нужно поменять чётность последнего бита.
[01:23:06.900 --> 01:23:08.900]  Поэтому дальше всё очень просто.
[01:23:08.900 --> 01:23:10.900]  Мы заводим массив UST
[01:23:10.900 --> 01:23:12.900]  для ребер,
[01:23:12.900 --> 01:23:14.900]  ну скажем, там размеры 2m
[01:23:14.900 --> 01:23:16.900]  для ребер.
[01:23:18.900 --> 01:23:20.900]  И когда мы какое-то ребро
[01:23:20.900 --> 01:23:22.900]  помечаем использованным,
[01:23:22.900 --> 01:23:24.900]  мы помечаем использованное также обратное к нему.
[01:23:26.900 --> 01:23:28.900]  То есть у нас там будет строчка в стиле
[01:23:28.900 --> 01:23:30.900]  равно Ustat exur 1
[01:23:32.900 --> 01:23:34.900]  равно true.
[01:23:34.900 --> 01:23:36.900]  Это помечает использованным
[01:23:36.900 --> 01:23:38.900]  ребро и обратное к нему.
[01:23:38.900 --> 01:23:40.900]  То есть мы не только по е не можем проходить,
[01:23:40.900 --> 01:23:42.900]  но и по обратному тоже.
[01:23:42.900 --> 01:23:44.900]  Поскольку у меня это всё-таки одна сущность,
[01:23:44.900 --> 01:23:46.900]  я не то что его раздвоил и могу ходить туда-обратно
[01:23:46.900 --> 01:23:48.900]  по одному разу,
[01:23:48.900 --> 01:23:50.900]  а могу суммарно по ним пройти ровно один раз.
[01:23:50.900 --> 01:23:52.900]  Мне нужно их оба пометить использованными.
[01:23:58.900 --> 01:24:00.900]  И тогда давайте я,
[01:24:00.900 --> 01:24:02.900]  давайте напишу, значит мы заводим вектор
[01:24:02.900 --> 01:24:04.900]  ptr
[01:24:06.900 --> 01:24:08.900]  для всех
[01:24:08.900 --> 01:24:10.900]  для всех вершинок.
[01:24:10.900 --> 01:24:12.900]  Значит как мы тогда пишем while в
[01:24:12.900 --> 01:24:14.900]  ailer?
[01:24:14.900 --> 01:24:16.900]  ptr это номер
[01:24:16.900 --> 01:24:18.900]  первого неиспользованного ребра.
[01:24:18.900 --> 01:24:20.900]  Первое
[01:24:20.900 --> 01:24:22.900]  неиспользованное ребро.
[01:24:24.900 --> 01:24:26.900]  Значит while какой?
[01:24:26.900 --> 01:24:28.900]  Пока
[01:24:28.900 --> 01:24:30.900]  ptr от v
[01:24:30.900 --> 01:24:32.900]  меньше, чем
[01:24:32.900 --> 01:24:34.900]  gvt.size
[01:24:36.900 --> 01:24:38.900]  То есть скажем, ну gv это у меня список
[01:24:38.900 --> 01:24:40.900]  всех исходящих ребер.
[01:24:40.900 --> 01:24:42.900]  Если есть средний хотя бы одно неиспользованное.
[01:24:42.900 --> 01:24:44.900]  ptr от v это указательное первое не просмотренное ребро.
[01:24:44.900 --> 01:24:46.900]  Значит во-первых, если оно
[01:24:46.900 --> 01:24:48.900]  использовано, надо его скипнуть
[01:24:48.900 --> 01:24:50.900]  и увеличить ptr.
[01:24:50.900 --> 01:24:52.900]  Значит сначала я скажу, что e это
[01:24:52.900 --> 01:24:54.900]  gvt
[01:24:54.900 --> 01:24:56.900]  ptr vt
[01:24:58.900 --> 01:25:00.900]  Если use от e, continue
[01:25:00.900 --> 01:25:02.900]  use от e
[01:25:02.900 --> 01:25:04.900]  ну тогда plus plus ptr от v
[01:25:04.900 --> 01:25:06.900]  и continue.
[01:25:12.900 --> 01:25:14.900]  То есть ptr от v это грубо говоря
[01:25:14.900 --> 01:25:16.900]  кандидат на первое не просмотренное ребро.
[01:25:16.900 --> 01:25:18.900]  Если я вижу, что он посещен,
[01:25:18.900 --> 01:25:20.900]  то gv ptr vt
[01:25:20.900 --> 01:25:22.900]  это то самое ребро, которое мне сейчас хочется посмотреть.
[01:25:22.900 --> 01:25:24.900]  Если оно использовано, если оно помещено
[01:25:24.900 --> 01:25:26.900]  использованным, то я просто перехожу
[01:25:26.900 --> 01:25:28.900]  к следующему и делаю continue, возвращаюсь вот сюда.
[01:25:28.900 --> 01:25:30.900]  Иначе я нашел какое-то ребро,
[01:25:30.900 --> 01:25:32.900]  все до него рассмотрены, это первое
[01:25:32.900 --> 01:25:34.900]  неиспользованное. Ну значит дальше нужно
[01:25:34.900 --> 01:25:36.900]  просто сказать, что там пусть v
[01:25:36.900 --> 01:25:38.900]  u точнее
[01:25:38.900 --> 01:25:40.900]  это
[01:25:40.900 --> 01:25:42.900]  конец ребра
[01:25:42.900 --> 01:25:44.900]  e
[01:25:46.900 --> 01:25:48.900]  пометить его использованным, вместе
[01:25:48.900 --> 01:25:50.900]  с xor1 вот эту строчку сюда вставить.
[01:25:50.900 --> 01:25:52.900]  Что я помечаю это ребро e
[01:25:52.900 --> 01:25:54.900]  использованным, дальше увеличу
[01:25:54.900 --> 01:25:56.900]  ptr, потому что это ребро уже стало использованным
[01:25:56.900 --> 01:25:58.900]  плюс ptr от v.
[01:25:58.900 --> 01:26:00.900]  Ну и дальше eiler от u.
[01:26:00.900 --> 01:26:02.900]  Eiler от u, все.
[01:26:06.900 --> 01:26:08.900]  То есть это просто техническая реализация, вот
[01:26:08.900 --> 01:26:10.900]  той штуки, когда мы выбираем какое-то
[01:26:10.900 --> 01:26:12.900]  неиспользованное ребро. Мы для всех ребер
[01:26:12.900 --> 01:26:14.900]  храним оно использованное или нет, храним первого
[01:26:14.900 --> 01:26:16.900]  кандидата на неиспользованное, и
[01:26:16.900 --> 01:26:18.900]  пока это использовано, будем просто увеличивать.
[01:26:18.900 --> 01:26:20.900]  Увеличивая этот поинтер, пока не дойдем до первого
[01:26:20.900 --> 01:26:22.900]  неиспользованного.
[01:26:22.900 --> 01:26:24.900]  Все, и тогда вот теперь видно, что
[01:26:24.900 --> 01:26:26.900]  асимптотика будет линейная.
[01:26:32.900 --> 01:26:34.900]  Потому что за счет этих поинтеров
[01:26:34.900 --> 01:26:36.900]  для каждой вершины
[01:26:36.900 --> 01:26:38.900]  суммарно мы пройдем ну просто все ребра
[01:26:38.900 --> 01:26:40.900]  слева направо для нее, один раз.
[01:26:40.900 --> 01:26:42.900]  Потому что если есть какой-то
[01:26:42.900 --> 01:26:44.900]  ptrv, то мы просто
[01:26:44.900 --> 01:26:46.900]  либо непосещенный
[01:26:46.900 --> 01:26:48.900]  мы запускаемся рекурсивно и увеличиваем ptr,
[01:26:48.900 --> 01:26:50.900]  либо оно посещенное, и тогда мы его просто скипаем.
[01:26:50.900 --> 01:26:52.900]  Значит суммарно все ребра, все
[01:26:52.900 --> 01:26:54.900]  вершины рассмотрятся по одному разу. Профит.
[01:26:56.900 --> 01:26:58.900]  Все, спасибо за внимание.
