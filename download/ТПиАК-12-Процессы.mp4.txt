[00:00.000 --> 00:13.100]  Империруем обе, два исполняемых файла, запустили, запустили
[00:13.100 --> 00:14.100]  вторую.
[00:14.100 --> 00:34.380]  Что произошло?
[00:34.380 --> 00:36.660]  Первая программа записала поверх второй.
[00:36.660 --> 00:43.140]  Но это в каком порядке они сработали, зависит от
[00:43.140 --> 00:44.140]  общего результата.
[00:44.140 --> 00:57.940]  По один запустили, вторую запустили, одна завершилась,
[00:57.940 --> 00:58.940]  вторая завершилась.
[00:58.940 --> 01:05.740]  Осталось только то, что записал вторая, в прошлом
[01:05.740 --> 01:08.500]  случае у нас был кусок от одного от другого, потому
[01:08.500 --> 01:11.260]  что вторая записала более длинный пик.
[01:11.260 --> 01:16.540]  То есть, не очень хороший метод, когда мы можем взять
[01:16.540 --> 01:18.020]  и заселить данные соседа.
[01:18.020 --> 01:25.820]  Значит, нужно искать какие-то другие варианты межпроцессного
[01:25.820 --> 01:26.820]  взаимодействия.
[01:26.820 --> 01:29.620]  Ну а зачем это нужно?
[01:29.620 --> 01:35.700]  Вот у вас есть какая-то система, которая обходит
[01:36.700 --> 01:39.700]  стоять нескольких процессов, и они между собой должны
[01:39.700 --> 01:40.700]  как-то общаться.
[01:40.700 --> 01:46.700]  В том числе, для того чтобы не писать одновременно
[01:46.700 --> 01:51.060]  в один и тот же файл, или в область памяти не делать
[01:51.060 --> 01:52.420]  какое-то действие вместе.
[01:52.420 --> 02:02.020]  Кстати, некоторые из ваших анагруппников уже стали
[02:02.020 --> 02:04.740]  устраиваться на всякие работы и на собеседованиях
[02:04.740 --> 02:06.460]  и примерно это иначе спрашивать.
[02:06.460 --> 02:31.940]  Мы поставим файл.
[02:31.940 --> 02:35.740]  Вместо этого мы можем передавать друг другу
[02:35.740 --> 02:56.500]  данные по некоторой трубе или файлу.
[02:56.500 --> 03:02.940]  Эту абстракцию предлагает нам файловая система в
[03:02.940 --> 03:06.100]  отличие от файла, где мы можем многократно прочитать.
[03:06.100 --> 03:09.260]  Как только мы прочитали с другой стороны пайпа,
[03:09.260 --> 03:11.700]  эти данные оттуда пропадают и читается только один
[03:11.700 --> 03:25.140]  раз.
[03:26.140 --> 03:42.660]  Берет и некоторую строчку, пытается создать файл.
[03:42.660 --> 03:46.740]  Если операционную систему дает, тогда туда пишет.
[03:46.740 --> 03:51.180]  Причем интерфейс ровно такой же, как работа с файлом.
[03:51.180 --> 04:07.300]  Затем читает из этого файлового дескриптора и смотрит, что
[04:07.300 --> 04:08.300]  произошло.
[04:21.180 --> 04:28.300]  Опять слегка поругались.
[04:28.300 --> 04:53.300]  Но это не так интересно, если программа общается
[04:53.300 --> 04:54.300]  сама с собой.
[04:54.300 --> 05:03.300]  Это полезнее, если общаются разные программы, но откуда
[05:03.300 --> 05:13.980]  они лежали из две разных, они размножаются при помощи
[05:13.980 --> 05:14.980]  форков.
[05:14.980 --> 05:42.740]  При этом все файловые дескрипторы, включая Pipe, они наследуют.
[05:43.740 --> 05:51.740]  После этого размножаемся, проверяем, что успешно размножились.
[05:51.740 --> 05:59.060]  Один файловый дескриптор закрываем, ребенок закрывает
[05:59.060 --> 06:07.740]  первый, родитель пишет первый, ребенок читает
[06:07.740 --> 06:08.740]  из нулевого.
[06:08.740 --> 06:31.020]  Отработал родителей, тем ребенок, и эти два процесса
[06:31.020 --> 06:32.020]  работают параллельно.
[06:32.020 --> 06:40.660]  Но чтобы их слегка анатомировать, делаем ту же самую задержку,
[06:40.660 --> 06:41.660]  например, при помощи сканфа.
[07:02.020 --> 07:21.180]  Обратите внимание до того, как мы с вами туда запишем.
[07:21.180 --> 07:42.060]  Скомпинировали, запускаем.
[07:51.180 --> 08:07.420]  Через некоторое время отработал и ребенок.
[08:07.420 --> 08:10.140]  А вот теперь мы запустили программу и число пока
[08:10.140 --> 08:12.460]  не вводим, чтобы посмотреть, что же у нас происходит.
[08:12.460 --> 08:18.540]  Интересно, какие у нас есть процессы.
[08:18.540 --> 08:25.860]  С именем аут.
[08:25.860 --> 08:36.060]  Два процесса с номерами 30 на 3043 и 30 на 3044.
[08:36.060 --> 08:42.940]  Что у нас есть в файловой системе ProDs про эти процессы.
[08:42.940 --> 08:55.860]  Это не файлы на диске, это такой способ общаться
[08:55.860 --> 09:01.340]  с ядром операционной системы, конкретно линуксом, и получать
[09:01.340 --> 09:16.740]  какую-то информацию.
[09:16.740 --> 09:18.700]  Какие у нас файловые скрипторы есть.
[09:18.700 --> 09:35.940]  Процесс номер 31 на 3043 имеет несколько файловых
[09:35.940 --> 09:36.940]  скриптов.
[09:36.940 --> 09:38.940]  Нулевой, первый, второй.
[09:38.940 --> 09:43.700]  Вспомните, а что же это за файловые скрипты такие.
[09:43.700 --> 09:45.620]  Нулевой, первый, второй, которые обычно с процессом
[09:45.620 --> 09:46.620]  связаны.
[09:46.620 --> 09:56.980]  Стандартный поток ввода, стандартный поток вывода
[09:56.980 --> 09:58.420]  и стандартный поток ошибок.
[09:58.420 --> 09:59.860]  Все у нас связано с консолькой.
[09:59.860 --> 10:06.940]  То есть, читая все с консолем, выводится в консольку.
[10:06.940 --> 10:09.740]  А четвертый это pipe, это та самая труба, через которую
[10:09.740 --> 10:10.740]  они общаются.
[10:10.740 --> 10:30.900]  А из девайсов это терминал, давайте туда что-нибудь
[10:30.900 --> 10:33.900]  напишем.
[10:33.900 --> 11:00.220]  О, вот нам в терминалку пришло, а что это?
[11:00.220 --> 11:13.980]  Да, в UNIX у нас все файл, левый процесс.
[11:13.980 --> 11:17.820]  Хороший вопрос, а у нас есть еще один процесс.
[11:17.820 --> 11:28.020]  Процесс номер 31 на 3044.
[11:28.820 --> 11:33.580]  Как вы думаете, а в каких отношениях состоят эти
[11:33.580 --> 11:34.580]  процессы?
[11:34.580 --> 11:56.380]  31 на 3043, 31 на 3044?
[11:56.740 --> 12:05.380]  Точнее так, 31 043 это родитель, 31 044 ребенок, по простому
[12:05.380 --> 12:06.380]  принципу причинности.
[12:06.380 --> 12:32.620]  Теоретически бывает, но в исходном тексте,
[12:32.620 --> 12:42.300]  ребенок закрывает первый дескриптор, родитель закрывает
[12:42.300 --> 12:45.300]  нулевой дескриптор.
[12:45.300 --> 12:50.660]  Вот поэтому нулевой, первый, второй у них есть, а из новых
[12:50.660 --> 12:55.140]  файловых дескриптов, третий, четвертый, из которых ребенок
[12:55.140 --> 12:58.100]  оставил себе третий, родитель оставил себе четвертый.
[12:58.580 --> 13:00.580]  Просто из исходного кода нашей программы.
[13:01.060 --> 13:29.060]  Так, Аш, что будет, если мы в...
[13:29.060 --> 13:32.540]  третий файл, ему что-нибудь напишем.
[13:59.540 --> 14:08.540]  Да, на самом деле они оба ожидают ввода.
[14:18.540 --> 14:21.540]  Итак, эволютирующая строчка вместо хэллоу вольт оказалась,
[14:21.540 --> 14:22.540]  а что будет?
[14:23.020 --> 14:28.020]  Вот мы написали его в pipe, в трубу вместо...
[14:38.020 --> 14:43.020]  Точнее, мы написали первым, потом родитель, который
[14:43.020 --> 14:48.020]  просто стоял и ждал, пока мы ведем число с scanf, написал
[14:48.500 --> 14:55.500]  еще, но до этого ребенок прочитал первый, попавшись
[14:55.500 --> 14:59.500]  из этой трубы, в данном случае то, что написали мы, и завершилось.
[15:11.500 --> 15:16.500]  Запускаем еще раз.
[15:18.020 --> 15:35.500]  Мы в прошлый раз писали ему третий хэллоу скриптер.
[15:48.500 --> 15:59.500]  А если в четвертый?
[15:59.500 --> 16:24.980]  Ну, то же самое, ребенок о, а в четвертый дальше хэллоу.
[16:29.980 --> 16:39.980]  Кусочек остался, потому что мы читаем просто ровно
[16:39.980 --> 16:40.980]  14 символов.
[16:52.980 --> 16:55.980]  Поэтому мы прочитали вот этот кусочек.
[16:56.460 --> 16:58.460]  Ну, точнее, ровно 14 байт.
[16:58.460 --> 17:01.460]  А то, что эти байты можно интерпретировать как некий
[17:01.460 --> 17:03.460]  текст, это уже наша проблема.
[17:11.460 --> 17:13.460]  В принципе, существуют и двунаправленные пайпы,
[17:13.460 --> 17:15.460]  но у люкса они обычно однонаправленные.
[17:18.460 --> 17:20.460]  Однонаправленные есть, например, в Solaris.
[17:26.460 --> 17:37.460]  Ну и как, удобно ли общаться через такую однонаправленную
[17:37.460 --> 17:38.460]  трубу?
[17:38.460 --> 17:41.460]  Ну и хорошо, делать две однонаправленные трубы
[17:41.460 --> 17:43.460]  в одну сторону и в другую.
[17:43.460 --> 17:45.460]  В принципе, для общения этого достаточно.
[17:49.460 --> 17:51.460]  Главное, данные в одну и в другую стороны проходят,
[17:51.460 --> 17:54.460]  а дальше реализую любую логику на них самостоятельно.
[17:56.460 --> 17:58.460]  Какие еще абстракции нам могут пригодиться?
[18:05.460 --> 18:07.460]  Помимо потока байтов.
[18:26.460 --> 18:40.460]  Первых, нам охота общаться с неродственным процессом.
[18:43.460 --> 18:45.460]  Не просто унаследовать файловый дискритик.
[18:45.460 --> 18:59.940]  Мы можем сделать FIFO, в сокращении от First In, First Out.
[19:15.940 --> 19:17.940]  Общаться через него.
[19:17.940 --> 19:23.940]  Обратите внимание, как генерируется по имени файла.
[19:45.940 --> 19:51.940]  Почему мы не можем позапустить программу повторно?
[19:59.940 --> 20:03.940]  Потому что у нас уже есть файл.
[20:04.420 --> 20:18.420]  Такой специальный тип файла, FIFO.
[20:18.420 --> 20:26.420]  На диске он нигде не хранится, просто читает что-то.
[20:26.420 --> 20:30.420]  Но оттуда можно читать и туда можно писать.
[20:30.420 --> 20:32.420]  Как только прочитали, убираются.
[20:33.940 --> 20:52.420]  А вот таким способом мы можем повторно удалить файл.
[21:04.420 --> 21:10.420]  Помимо последовательной передачи данных, есть еще возможные варианты.
[21:26.420 --> 21:30.420]  Например, мы хотим общаться в поизвольном доступе.
[21:30.900 --> 21:32.900]  Мы умеем работать с оперативной памятью.
[21:32.900 --> 21:34.900]  Помним про адресную арифметику.
[21:40.900 --> 21:46.900]  Как только у нас есть адресная арифметика, мы можем на ней сделать свой аллокатор.
[21:46.900 --> 21:50.900]  Который вы писали в контесте Илье Семировича.
[21:50.900 --> 21:52.900]  И расположить любые данные, которые вам нужны.
[21:54.900 --> 21:58.900]  Поэтому нам нужно, чтобы кусочек памяти между двумя процессами был общий.
[21:59.380 --> 22:01.380]  Любой может читать, любой писать.
[22:15.380 --> 22:21.380]  Ну а каким образом они будут значить кусочек у них общий?
[22:21.380 --> 22:27.380]  Операционная система, благодаря поддержке со стороны процессора,
[22:27.860 --> 22:33.860]  позволяет каждому процессу иметь свое отдельное адресное пространство,
[22:33.860 --> 22:35.860]  которое не присыпляется с другими.
[22:35.860 --> 22:41.860]  И то, что какой-то кусочек памяти у них у нас будет общий, это будет не совсем стандартное поведение.
[22:45.860 --> 22:47.860]  Мы генеруем ключик из имени файла.
[22:48.340 --> 22:58.340]  В сам файл ничего у нас не записывается. Делать все из имени.
[22:58.340 --> 23:08.340]  Вспомните немножко алгоритм RCA, который вы вам рассказывали в прошлом семе.
[23:08.340 --> 23:13.340]  Там аналогично генерируется ключик.
[23:13.820 --> 23:23.820]  Самое главное, чтобы не обмениваясь самим ключом, две стороны сгенерируют один и тот же ключ.
[23:23.820 --> 23:31.820]  Ну или, допустим, пару ключей для зашифровки и расшифровки.
[23:32.300 --> 23:38.300]  Ну а затем, возможно, на основе этих ключей,
[23:38.300 --> 23:44.300]  быстренько обменялись одноразовым ключом для симметричного шифрования,
[23:44.300 --> 23:46.300]  дальше продолжили общение.
[23:46.300 --> 23:48.300]  Здесь тот же самый принцип.
[23:48.300 --> 23:52.300]  Из одного и того же имени файла генерируется один и тот же ключ.
[23:52.780 --> 24:02.780]  И с помощью него можно будет взять и добыть кусочек памяти.
[24:06.780 --> 24:12.780]  Ключ нам нужен для того, чтобы несколько программ,
[24:13.260 --> 24:21.260]  запросивший этот кусочек памяти и желающий общаться друг с другом,
[24:21.260 --> 24:25.260]  получили один и тот же кусочек в общей владении.
[24:25.260 --> 24:31.260]  Заказываем, указывая размер, сколько нам нужно.
[24:33.260 --> 24:39.260]  Для отчтения записи при отсутствии создаем,
[24:39.740 --> 24:47.740]  если не удалось, то смотрим по переменной ErrorNumber.
[24:49.740 --> 24:53.740]  Не может создать или не может найти.
[24:57.740 --> 25:07.740]  После этого оттачиваем наш массив и кусочек памяти
[25:08.220 --> 25:10.220]  и что-нибудь напишем.
[25:24.220 --> 25:28.220]  В нулевой элемент считаем сколько
[25:28.700 --> 25:30.700]  у нас.
[25:52.700 --> 25:54.700]  Сколько записывается одна и вторая программа.
[25:54.700 --> 25:56.700]  А еще вы должны понять.
[25:57.180 --> 26:01.180]  Мы первые, кто нашли этот кусочек памяти или нет.
[26:03.180 --> 26:05.180]  По умолчанию считаем, что первые.
[26:07.180 --> 26:11.180]  Если мы не можем создать этот кусочек,
[26:19.180 --> 26:21.180]  потому что он уже существует,
[26:21.660 --> 26:25.660]  тогда мы не первые, кто-то этот кусочек уже использует.
[26:29.660 --> 26:31.660]  А в нулевой элемент запишем суммарное количество.
[26:31.660 --> 26:33.660]  Сколько запускалось первая программа.
[26:33.660 --> 26:35.660]  Первый элемент массива сколько вторая.
[26:43.660 --> 26:47.660]  После этого мы больше не хотим привязывать наш массив
[26:47.660 --> 26:49.660]  к этому общему куску памяти.
[26:51.660 --> 26:53.660]  Он будет существовать отдельно.
[27:07.660 --> 27:09.660]  Вот она наша память.
[27:11.660 --> 27:13.660]  И где же она лежит?
[27:21.660 --> 27:25.660]  До этого мы можем воспользоваться командой ipsys.
[27:31.660 --> 27:33.660]  Видим, что многие программы у нас здесь используют
[27:35.660 --> 27:37.660]  разделяемую память.
[27:51.660 --> 27:53.660]  Пабличка здесь немножко съехала.
[27:53.660 --> 27:55.660]  12 байтов.
[27:55.660 --> 27:57.660]  Это подозрительно.
[28:21.660 --> 28:23.660]  Вот она у нас кусочки по 12 байтов.
[28:43.660 --> 28:45.660]  Которым никто не приотачен.
[28:51.660 --> 28:55.660]  В Unix time, то есть в дубе в секундах прошедших
[28:57.660 --> 28:59.660]  с 1 января 1990 года.
[29:01.660 --> 29:03.660]  Время доступа.
[29:03.660 --> 29:05.660]  Время создания.
[29:21.660 --> 29:23.660]  А вот эта, вот эта.
[29:37.660 --> 29:39.660]  И можем взять удалить что-нибудь.
[29:45.660 --> 29:47.660]  Мы можем удалить кусочек разделяемой памяти.
[29:51.180 --> 30:19.540]  По своему ID-шнику.
[30:19.540 --> 30:22.900]  Такого кусочка разделяемой памяти у нас нету больше.
[30:22.900 --> 30:27.620]  Давайте снесём её второй.
[30:27.620 --> 30:37.060]  Ну вот программа начала работать заново.
[30:37.060 --> 30:41.500]  Снова создала кусочек разделяемой памяти.
[30:50.020 --> 30:56.580]  Обратите внимание, даже после завершения программы разделяемая память осталась.
[30:56.580 --> 31:11.260]  Да, может хочет генерировать ключик и по нему залезет ещё ко что-то.
[31:20.540 --> 31:26.580]  Видите number of attach? Никто не приаттачен.
[31:42.700 --> 31:49.300]  Вот вторая программа, которая генерирует ключик из того же имени файла.
[31:49.300 --> 32:05.620]  Получается такой же кусочек и пишет ровно стол за кусок.
[32:05.620 --> 32:26.860]  Мы можем её так же искусственно затормозить и прежде чем она отцепится от нашей оперативной
[32:26.860 --> 32:29.580]  памяти с помощью SM detatch.
[32:56.860 --> 33:14.220]  Искусственно замедлим провод с помощью сканфа.
[33:14.220 --> 33:21.220]  Перекомпилируем, запускаем.
[33:21.220 --> 33:36.100]  Прячем её в бэкграунд, нажатим CTRL Z и видим вот у нас кусочек разделяемой памяти.
[33:36.100 --> 33:42.460]  Доступна всем на чтении запись.
[33:42.460 --> 33:51.100]  Обратите внимание, как типичные кусочки разделяемой памяти, которые используются
[33:51.100 --> 33:57.260]  процессами, которые у меня на ноуте запущены, право на чтение запись только для владельца.
[33:57.260 --> 34:05.980]  Давать всем это небезопасно. Но зато мы хорошо видим, какой кусочек памяти точно наш с
[34:05.980 --> 34:15.460]  небезопасными правами размером 12 байтов, и вот у нас одна программа к ней приаттательна.
[34:15.460 --> 34:20.460]  Одна программа, которая в бэкграунде ждет, пока мы ведем число.
[34:20.460 --> 34:30.380]  Вызовем ее на передний план. Введем число, программа перестала ждать.
[34:30.380 --> 34:43.340]  Количество сегментов разделяемой памяти, но обратите внимание, в отличие от пифо,
[34:43.340 --> 34:50.380]  которое у нас создавалось и дальше его создать было нельзя, мы можем спускать нашу программу
[34:56.860 --> 34:57.860]  многократно.
[35:13.340 --> 35:37.380]  Но поскольку ключик один и тот же, мы доступаемся к одному этому же кусочку оперативной памяти.
[35:43.340 --> 36:13.180]  Теперь мы хотим чтобы
[36:13.500 --> 36:32.940]  вся память была общая. Для этого у нас есть, помимо процессов, потоки. У процессов все раздельное,
[36:32.940 --> 36:51.700]  а трэды это куча студентов живущих в общей жизни. У них все общие, вся оперативная память в них
[36:51.700 --> 37:16.380]  общая. Все переменные общие, но только регистр разный. Вот наша основная функция.
[37:16.380 --> 37:35.260]  Ждаем поток. Порсик Стрэд Креит. Выясняем кто мы такие. Что-нибудь вычисляем, присоединяемся и
[37:35.260 --> 37:46.820]  ждем пока трэд завершится. Ну а в самом трэде просто увеличиваем переменную, которая у нас
[37:46.820 --> 38:04.460]  глобальная и доступна всем. Что же у нас такое произошло? На нас компилятор ругается. На что
[38:04.460 --> 38:26.460]  он на нас ругается? Что заголошный пал опять забыли?
[38:34.460 --> 38:59.780]  Условь по трэд аж. Есть по трэд аж. На что он на нас ругается тогда? А не нашел у нас линковщик,
[38:59.780 --> 39:05.740]  то есть компилитор и вот это все скомпилировалось в объектные файлы, но линковка не произошла.
[39:05.740 --> 39:19.900]  Понимаем как мы делали библиотеку. Прилинковать библиотеку по трэду. Вот это уже действительно
[39:19.900 --> 39:32.900]  библиотека, а не заголошный файл. Вот у нас родилось по два трэда. Каждый увеличил число.
[39:32.900 --> 39:48.540]  Ну и в каком-то порядке не успели вылезти.
[39:48.540 --> 40:06.980]  А что будет если мы не будем дожидаться окончания потока?
[40:18.540 --> 40:27.100]  Какой-то из них успеет вывезти. Может скажет что 1, может скажет что 2.
[40:39.020 --> 40:41.500]  То есть поведение у нас становится неопределенным.
[40:41.500 --> 40:49.620]  Зависит от нет случайности как это трэду будут выполнять.
[41:11.500 --> 41:28.980]  Ну а в этом примере мы используем разделяемую память и много раз у нее что-нибудь пишем.
[41:41.500 --> 41:58.340]  Почему она много работает? Потому что там большой большой большой трэд.
[41:58.340 --> 42:15.620]  А здесь мы тоже генерируем ключик из имени файла. Добываем унификатор разделяемой памяти.
[42:29.340 --> 42:31.820]  Запускаем.
[42:47.940 --> 42:50.100]  То есть операция у нас относительно долгая.
[42:50.100 --> 42:58.100]  А если мы эти программки запустим параллельно?
[42:58.100 --> 43:12.740]  Причем долго они не ожидают из-за ожидания ввода-вывода, а из-за вычислений. Мы сделаем большой большой цепь.
[43:20.100 --> 43:28.420]  Запустили.
[43:28.420 --> 43:47.860]  Запускаем снова.
[43:59.380 --> 44:08.660]  Ну а смотрите программа 1 запустилась 6 раз, программа 2 5 раз. Итого сколько?
[44:08.660 --> 44:20.340]  Почему-то 10. Почему? Как-то удивлены медсестра. Как же так? Что нам программа ругается?
[44:20.340 --> 44:35.380]  Потому что у нас две программы пытались параллельно писать в один и тот же кусочек атеротивной памяти.
[44:35.380 --> 44:46.020]  Ну и поведение языка неопределенное.
[44:50.340 --> 45:09.540]  А когда у нас результат работы двух независимо работающих программ будет однозначно определен.
[45:10.020 --> 45:20.740]  Вот допустим первая программа читает данные множество R1 и пишет множество V1.
[45:20.740 --> 45:27.460]  Вторая программа читает данные R2 и пишет множество V2.
[45:27.460 --> 45:39.460]  При каком условии на эти данные они друг другу гарантированно не переберутся и результат будет определенный независимо от пресса запуска.
[45:39.460 --> 45:57.380]  Ничего? Хорошо проверяем. R1 и R2 пересекаются могут?
[45:57.620 --> 46:07.860]  Значит V1 и V2 не пересекаются.
[46:07.860 --> 46:14.340]  R1 и R2 могут?
[46:14.340 --> 46:19.140]  То что они читают.
[46:19.140 --> 46:24.340]  Хорошо R1 и V2 могут?
[46:24.340 --> 46:31.540]  Р1 и V1 пересекаться могут?
[46:31.540 --> 46:36.660]  Могут, но тогда уже программа сама разберется с ними.
[46:36.660 --> 46:41.700]  Даже если вы запускаете одну результат от этого не изменится.
[46:41.700 --> 46:43.700]  Он все равно будет определен.
[46:43.700 --> 46:45.700]  R2 и V2 тоже.
[46:46.580 --> 46:54.580]  А R1 и V2.
[47:00.580 --> 47:04.580]  То есть мы не должны записывать то, что пишет другая программа.
[47:16.580 --> 47:18.580]  Вот такое вот условие.
[47:24.580 --> 47:28.580]  Ну и называется это условие Бенстайна.
[47:28.580 --> 47:34.580]  Однозначности того как работает программа.
[47:35.460 --> 47:47.460]  Теперь задачка похожа мне.
[47:47.460 --> 47:53.460]  В жиль были у нас китайские философы.
[47:53.460 --> 47:59.460]  И после очередного симпозиума решили поесть суши китайскими палочками.
[47:59.460 --> 48:03.460]  У них есть большой большой круглый стол.
[48:04.340 --> 48:10.340]  В основном сидят эти философы по кругу.
[48:10.340 --> 48:16.340]  Перед ними лежат суши.
[48:16.340 --> 48:20.340]  Между каждыми двумя философами лежит по китайской палочке.
[48:20.340 --> 48:24.340]  Весно, что они едят двумя палочками.
[48:24.340 --> 48:28.340]  Им нужно взять в правую руку палочку, в левую руку палочку.
[48:28.340 --> 48:32.340]  И тогда они смогут ехать.
[48:33.220 --> 48:37.220]  А как вы думаете, как могут развиваться события?
[48:43.220 --> 48:49.220]  Так каждый философ берет палочку справа.
[48:49.220 --> 48:53.220]  И ждет пока заводится палочка слева.
[48:53.220 --> 48:57.220]  Бедные философы умерли от голода.
[49:03.220 --> 49:11.220]  Хорошо, а как их наиболее быстро накормить?
[49:23.220 --> 49:27.220]  Набираться с нуля или соединиться?
[49:28.100 --> 49:32.100]  Не обязательно.
[49:38.100 --> 49:42.100]  Но оно по крайней мере целое.
[49:42.100 --> 49:46.100]  Иначе это будет слишком жестоко.
[49:46.980 --> 50:10.980]  Возьмем какого-то философа, назначим его на левую.
[50:10.980 --> 50:14.980]  Введем понятие направо.
[50:15.860 --> 50:19.860]  Занумируем всех философов.
[50:19.860 --> 50:23.860]  После этого могут ли поесть все чётные?
[50:33.860 --> 50:35.860]  Дискриминация.
[50:35.860 --> 50:39.860]  Дискриминация по принципу чётности.
[50:40.740 --> 50:44.740]  Значит кто смог поесть?
[50:44.740 --> 50:48.740]  Хорошо, чётные не смогут поесть, а нечётные.
[50:50.740 --> 50:53.740]  Так, нечётные цапают палочку справа,
[50:53.740 --> 50:57.740]  цапают палочку слева, едят.
[50:57.740 --> 51:03.740]  После этого поели.
[51:03.740 --> 51:07.740]  Считаю, что они съели не все суши.
[51:08.620 --> 51:12.620]  Что остальные останутся не голодными.
[51:12.620 --> 51:14.620]  Положили две палочки.
[51:14.620 --> 51:18.620]  Что можно делать дальше?
[51:18.620 --> 51:22.620]  Ну, допустим, все чётные, за исключением может быть
[51:22.620 --> 51:26.620]  последнего, если изначально было нечётное число.
[51:26.620 --> 51:30.620]  Допустим, четвертый сосед с нулевым.
[51:30.620 --> 51:34.620]  Взяли по палочке и едят.
[51:35.500 --> 51:39.500]  И наконец, третьим этапом, тот несчастный,
[51:39.500 --> 51:43.500]  последний философ,
[51:43.500 --> 51:47.500]  надеется, что так же съели не все суши и доедает.
[51:57.500 --> 52:01.500]  Видим, что в худшем случае,
[52:01.500 --> 52:03.500]  при эффективном алгоритме,
[52:04.380 --> 52:08.380]  три времени обеда.
[52:10.380 --> 52:12.380]  В худшем случае, без эффективного алгоритма,
[52:12.380 --> 52:14.380]  у нас бесконечное ожидание.
[52:14.380 --> 52:16.380]  Или демок.
[52:18.380 --> 52:20.380]  Так и с взаимодействующими программами.
[52:20.380 --> 52:24.380]  Если одна что-то захватила,
[52:24.380 --> 52:28.380]  и при этом другая не даёт,
[52:28.380 --> 52:30.380]  тогда демок.
[52:30.380 --> 52:33.380]  А нужно ли вообще что-то захватывать?
[52:34.260 --> 52:40.260]  Судя по примеру, вот с этой программой.
[52:44.260 --> 52:48.260]  Имеет смысл хранить там посуду,
[52:48.260 --> 52:54.260]  и при этом писать в неё эксклюзивно?
[52:55.140 --> 52:57.140]  Вот смотрите, 6 плюс 5 равно 10.
[53:11.140 --> 53:13.140]  Сломалось.
[53:17.140 --> 53:21.140]  Из-за того, что мы параллельно писали,
[53:25.140 --> 53:29.140]  что-то прочитали, данные изменились,
[53:29.140 --> 53:31.140]  а мы тем временем записали.
[53:35.140 --> 53:37.140]  Ну и данные оказались некорректны,
[53:37.140 --> 53:39.140]  как у той медсестры.
[53:39.140 --> 53:43.140]  Или мы писали параллельно файловую систему,
[53:43.140 --> 53:47.140]  и записали данные на один и тот же кусочек нашего диска.
[53:47.140 --> 53:51.140]  Ну или диска уже по современному СВ,
[53:51.140 --> 53:53.140]  по прямоугольничке.
[53:55.140 --> 53:57.140]  Запустим снова.
[54:11.140 --> 54:13.140]  7 плюс 6, 12.
[54:14.140 --> 54:16.140]  7 плюс 6, 13.
[54:25.140 --> 54:27.140]  8 плюс 7, 14.
[54:30.140 --> 54:32.140]  8 плюс 7, 15.
[54:33.140 --> 54:35.140]  Они одновременно прочитали, одна изменила,
[54:35.140 --> 54:37.140]  другая ещё не знает об этом изменении.
[54:39.140 --> 54:41.140]  То есть есть какие-то места, которые критичные.
[54:41.140 --> 54:43.140]  Вот я здесь копаюсь,
[54:45.140 --> 54:47.140]  не мешайте.
[54:49.140 --> 54:51.140]  Это такие специальные таблички,
[54:51.140 --> 54:53.140]  которые вешают на электрощитную систему.
[54:54.020 --> 54:56.020]  А когда проводка что-то делает,
[54:56.020 --> 54:58.020]  не включать, обводы видят.
[55:06.020 --> 55:08.020]  А возможно,
[55:08.020 --> 55:10.020]  вы ездили на МЦД
[55:10.020 --> 55:12.020]  и видели,
[55:12.020 --> 55:14.020]  что переда почему-то,
[55:14.020 --> 55:16.020]  несмотря на весь головолёт,
[55:16.020 --> 55:18.020]  который сейчас,
[55:18.020 --> 55:20.020]  умудряется не сталкиваться.
[55:20.020 --> 55:22.020]  Как они догоняют друг друга,
[55:22.900 --> 55:24.900]  то догнали бы друг друга,
[55:24.900 --> 55:26.900]  сказали, что ты меня подрезал на рельсах.
[55:28.900 --> 55:30.900]  Я тут пассажиров везу,
[55:30.900 --> 55:32.900]  в лучшем традиции,
[55:32.900 --> 55:34.900]  в маршруте.
[55:34.900 --> 55:36.900]  Что же им мешает?
[55:46.900 --> 55:48.900]  Там есть система централизации блокировки,
[55:48.900 --> 55:50.900]  целая,
[55:51.780 --> 55:53.780]  а элементом, который одним из элементов
[55:53.780 --> 55:55.780]  является светофор.
[55:55.780 --> 55:57.780]  А раньше,
[55:57.780 --> 55:59.780]  когда эффективных
[55:59.780 --> 56:01.780]  источников света не было,
[56:01.780 --> 56:03.780]  использовался семафор.
[56:05.780 --> 56:07.780]  Ну и название такое
[56:07.780 --> 56:09.780]  сохранили.
[56:21.780 --> 56:23.780]  Ну и название такое
[56:23.780 --> 56:25.780]  сохранили.
[56:27.780 --> 56:29.780]  Ну и название такое
[56:29.780 --> 56:31.780]  сохранили.
[56:31.780 --> 56:33.780]  Ну и название такое
[56:33.780 --> 56:35.780]  сохранили.
[56:35.780 --> 56:37.780]  Ну и название такое
[56:37.780 --> 56:39.780]  сохранили.
[56:39.780 --> 56:41.780]  Ну и название такое
[56:41.780 --> 56:43.780]  сохранили.
[56:43.780 --> 56:45.780]  Ну и название такое
[56:45.780 --> 56:47.780]  сохранили.
[56:47.780 --> 56:49.780]  Ну и название такое
[56:50.660 --> 56:52.660]  сохранили.
[56:56.660 --> 56:58.660]  В частности,
[56:58.660 --> 57:00.660]  есть средство
[57:00.660 --> 57:02.660]  межпроцессного взаимодействия семафор.
[57:04.660 --> 57:06.660]  А в данный момент
[57:06.660 --> 57:08.660]  все семафоры
[57:10.660 --> 57:12.660]  у нас, ну никаких семафоров у нас
[57:12.660 --> 57:14.660]  в 6-мине нету.
[57:14.660 --> 57:16.660]  Ну а где можно использовать?
[57:16.660 --> 57:18.660]  Например,
[57:19.540 --> 57:21.540]  может быть вы
[57:21.540 --> 57:23.540]  замечали,
[57:25.540 --> 57:27.540]  как P-Judge
[57:27.540 --> 57:29.540]  на больших контестах
[57:29.540 --> 57:31.540]  не очень быстро проверял. А почему?
[57:31.540 --> 57:33.540]  Ну нужно точно
[57:33.540 --> 57:35.540]  замерить время исполнения программы.
[57:35.540 --> 57:37.540]  То есть проверить, что никто
[57:37.540 --> 57:39.540]  в это время никто ничего не делает
[57:39.540 --> 57:41.540]  другой, не конкурирует с вами
[57:41.540 --> 57:43.540]  за шину данных, не конкурирует с вами
[57:43.540 --> 57:45.540]  за доступ к риску.
[57:45.540 --> 57:47.540]  Поэтому используется
[57:47.540 --> 57:49.540]  семафор, который запрещает
[57:53.540 --> 57:55.540]  взаимодействовать,
[57:55.540 --> 57:57.540]  запрещает запускать другую программу, пока
[57:57.540 --> 57:59.540]  не тестировался первая.
[57:59.540 --> 58:01.540]  Для
[58:01.540 --> 58:03.540]  точности вы создаете
[58:03.540 --> 58:05.540]  эти эксперименты.
[58:05.540 --> 58:07.540]  Ну а поскольку уже
[58:07.540 --> 58:09.540]  был звонок,
[58:09.540 --> 58:11.540]  и скоро придет следующий лектор,
[58:11.540 --> 58:13.540]  то семафоров уже в следующий раз.
[58:17.540 --> 58:19.540]  Ну
[58:19.540 --> 58:21.540]  на железных дорогах
[58:21.540 --> 58:23.540]  да, такая вот
[58:23.540 --> 58:25.540]  поворачивающаяся палка
[58:25.540 --> 58:27.540]  сейчас на железных дорогах она уже
[58:27.540 --> 58:29.540]  не используется.
[58:31.540 --> 58:33.540]  Там сейчас современная автоматическая
[58:33.540 --> 58:35.540]  блокировка с тональными цепями.
[58:37.540 --> 58:39.540]  Благодаря ней более-менее приличные
[58:39.540 --> 58:41.540]  интервалы, особенно метро.
[58:41.540 --> 58:43.540]  В полторы минуты между
[58:43.540 --> 58:45.540]  переданиями.
[58:45.540 --> 58:47.540]  Но звание
[58:47.540 --> 58:49.540]  в операционных системах
[58:49.540 --> 58:51.540]  сохранилось в историческом режиме.
[58:51.540 --> 58:53.540]  То есть
[58:53.540 --> 58:55.540]  можно тебе ехать или нельзя.
[58:57.540 --> 58:59.540]  Вот это уже будет
[58:59.540 --> 59:01.540]  на следующий раз.
