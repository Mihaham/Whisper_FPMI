[00:00.000 --> 00:12.600]  Всем доброго дня или утра. Я не знаю, у кого какое время суток. Вот, мы будем считать, что сейчас утро.
[00:12.600 --> 00:20.460]  Значит, мы с вами продолжаем изучать наш курс. Значит, у нас, как вы уже могли заметить,
[00:20.460 --> 00:25.940]  лекционная и семинарская часть немного отличаются. Причем сейчас они отличаются кардинальным
[00:25.940 --> 00:31.760]  образом. Но в какой-то момент времени у нас настанет пересечение. Вот, и на самом деле первый
[00:31.760 --> 00:35.740]  момент, в котором у нас так или иначе настанет пересечение, это будет сегодня, потому что мы
[00:35.740 --> 00:40.540]  сегодня с вами рассмотрим первые баторные проектирования, то есть то, каким образом можно
[00:40.540 --> 00:45.420]  писать код. Давайте в качестве разминки вспомним, что у нас было в прошлый раз.
[00:45.420 --> 01:01.780]  Да, критерии хорошей архитектуры. Первое, что у нас было. Еще что было? Да, тоже было. Мы еще
[01:01.780 --> 01:09.500]  какой-то закон с вами посмотрели. Да, мы с вами рассмотрели закон Диметра. Про что он говорит?
[01:09.500 --> 01:20.380]  Давайте попробуем вспомнить. Да, смотрите, если у нас есть класс А, который что-то знает о классе
[01:20.380 --> 01:30.580]  В, и есть класс В, который что-то знает о классе С, то по идее в практиках объектно-ориентированного
[01:30.580 --> 01:36.100]  программирования лучше не допускать, чтобы А что-то знала С. То есть так называемая
[01:36.100 --> 01:40.300]  антитранзитивность, если мы говорим в математических терминах. И посмотрели,
[01:40.300 --> 01:46.780]  каким образом ее можно решать. То есть мы с вами рассмотрели критерии хорошей архитектуры и закон
[01:46.780 --> 01:54.780]  Диметра. Сегодня мы с вами двинемся дальше и посмотрим, а каким образом можно избегать из
[01:54.780 --> 02:00.460]  лишней жесткости в архитектуре и делать ее максимально гибкой и адаптируемой. Вот, значит,
[02:00.460 --> 02:06.340]  план на сегодняшнюю лекцию у нас будет следующий. Это попробовать расшифровать четыре аббревиатуры.
[02:06.340 --> 02:14.020]  Первая аббревиатура это solid, вторая аббревиатура это dry, третья аббревиатура это kiss и четвертая
[02:14.020 --> 02:20.580]  аббревиатура это yagni. Сразу скажу, что solid больше относится к объектно-ориентированному
[02:20.580 --> 02:24.900]  программированию, в то время как другие аббревиатуры на самом деле не относятся
[02:25.200 --> 02:30.740]  к объектно-ориентированному программированию, а вообще относятся к написанию кода и к
[02:30.740 --> 02:36.060]  проектированию самих систем. И давайте как раз познакомимся с ними по порядку. Начнем
[02:36.060 --> 02:42.580]  мы с вами с соли. Давайте я спрошу, есть ли среди вас те, кто не знает вообще, что такое
[02:42.580 --> 02:51.220]  объектно-ориентированное программирование. Но у кого-то сейчас курс идет по объектно-
[02:51.220 --> 02:58.420]  оритированного программирования. Главное знать, что в нем есть классы. У классов есть экземпляры,
[02:58.420 --> 03:05.540]  у классов, точнее, классы могут представляться экземплярами, у классов есть поля и у классов
[03:05.540 --> 03:14.540]  есть методы. Причем методы могут быть различного вида доступа. Хорошо, давайте я спрошу следующее.
[03:14.540 --> 03:33.260]  Знаете ли вы, что такое абстрактный класс? Что такое абстрактный класс? Да, то есть это класс,
[03:33.260 --> 03:39.940]  который по факту не полностью реализован, у которого некоторые методы могут не иметь реализацию.
[03:39.940 --> 03:45.260]  Они обычно называются, в зависимости от языков программирования, это либо абстрактные методы,
[03:45.260 --> 03:52.740]  либо могут быть виртуальные методы, если мы говорим про C++. Хорошо, давайте я теперь задам
[03:52.740 --> 03:58.580]  еще один вопрос. Коллеги, которые приходят, давайте аккуратненько, чтобы не мешать слушать.
[03:58.580 --> 04:14.340]  Знаете ли вы, что такое интерфейс? Смотрите, здесь я точно хочу уточнить, что по факту,
[04:14.340 --> 04:21.900]  если мы сейчас посмотрим на обычные языки программирования, то даже в джаве класс абстрактный
[04:21.900 --> 04:26.420]  и интерфейс сильно отличаться не будут, по крайней мере с восьмой версией джавы. Но,
[04:26.460 --> 04:32.740]  если мы посмотрим истинную натуру интерфейсов, то до восьмой версии джавы интерфейсы имели свою
[04:32.740 --> 04:41.660]  собственную сущность. Смотрите, интерфейс это роль, которую можно приписать классу. То есть это что
[04:41.660 --> 04:50.300]  значит? Это допустим, если нам нужно получить метод write у какого-то класса, то по-хорошему
[04:50.300 --> 04:57.060]  должен быть интерфейс типа writable. У него должен быть прописан метод, который имеется write,
[04:57.060 --> 05:03.020]  и у него точно не должно быть реализации. То есть смотрите, у интерфейсов по классике не должно
[05:03.020 --> 05:09.900]  быть никаких полей. Раз, все методы должны быть публичными. Два, три, ни одного метода не должно
[05:09.900 --> 05:17.060]  быть реализован. То есть это чисто роль, которую можно приписать объекту. Там дальше я это расскажу,
[05:17.060 --> 05:24.020]  просто нам нужно будет это для того, чтобы мы с вами разобрали аббревиатуру solid. Из чего
[05:24.020 --> 05:29.940]  она состоит? Она состоит из пяти пунктов, как это можно увидеть. И эти пять пунктов такие. Первый
[05:29.940 --> 05:35.300]  это single responsibility principle. То есть принцип единой ответственности. Сейчас мы будем детальнее
[05:35.300 --> 05:45.300]  еще про них говорить. Вторая вещь это open-closed principle. Принцип открытости-закрытости. Третий
[05:45.300 --> 05:52.980]  принцип замены Барбары Лисков. Сразу скажу, что у Лисков фамилия не склоняемая, потому что это
[05:52.980 --> 06:00.340]  женская иностранная фамилия. Правило русского языка шестого класса. Следующий это interface
[06:00.340 --> 06:07.180]  segregation principle. Принцип разделения на интерфейс. И как раз здесь мы и поймем, что такое интерфейс.
[06:07.180 --> 06:14.500]  И последняя вещь это принцип обратимости-зависимости или, как он еще называется, dependency
[06:14.500 --> 06:22.700]  inversion principle. То есть все вот эти шесть методов мы сейчас с вами рассмотрим. Давайте попробуем
[06:22.700 --> 06:29.140]  догадаться чисто визуально. Как вы думаете, что будет говорить single responsibility principle?
[06:29.140 --> 06:43.140]  Да, именно так. Single responsibility principle говорит следующее, что один класс должен играть одну роль.
[06:43.140 --> 06:48.900]  И здесь я как раз буду показывать на картинке, которую я нашел, по-моему, на хабре. Собственно,
[06:48.900 --> 06:57.740]  у нас есть слева робот, который себя представляет, ты ж программиста, он умеет, и повар, и садовник,
[06:57.740 --> 07:04.380]  и маляр, и водитель. Но нам будет удобно из этого робота в точки зрения ООП сделать четыре
[07:04.380 --> 07:11.460]  отдельных подробота, каждый из которых будет повара, садовником, маляром и водителем. То есть
[07:11.460 --> 07:17.300]  мы создаем с вами четыре класса. Давайте вспомним как раз связь с предыдущим занятием. Помните,
[07:17.300 --> 07:22.980]  мы с вами говорили про cohesion и про coupling. То есть cohesion это что у нас с вами?
[07:22.980 --> 07:31.300]  Да, связность у три класса, coupling это связность между классами. Соответственно,
[07:31.300 --> 07:38.860]  давайте подумаем, если мы у нашего товарища разделим на четыре класса, то что мы с вами
[07:39.100 --> 07:51.580]  в терминах cohesion и coupling сделаем? Так, давайте подумаем. То есть у нас был класс, у него было
[07:51.580 --> 08:01.620]  четыре ответственности, каждые из которых явно пересекались внутри одного объекта. И это все было
[08:01.620 --> 08:16.100]  у нас в одном классе. Cohesion у этого класса какой? У нас нет ребер между вот этими объектами зачастую.
[08:16.100 --> 08:24.740]  То есть у нас наоборот cohesion был низкий. А так у нас получается четыре класса с более высоким
[08:24.740 --> 08:34.540]  cohesion. То есть в терминах cohesion мы с вами растем. Это cohesion, это coupling. Нам хотелось бы,
[08:34.540 --> 08:45.700]  чтобы мы оказались здесь. Хорошо, cohesion это связность внутри класса, coupling это связность
[08:45.700 --> 09:10.020]  между классами. Так, лучше? Все. Нет, нет, нет. Внутри одного класса. Смотрите, у нас
[09:10.620 --> 09:18.020]  сначала вот это все, в сущности это были объекты одного класса. А потом мы их разделим на четыре
[09:18.020 --> 09:24.740]  класса. То есть в момент времени t равна нулю, когда мы не разделили обязанности, у нас получается
[09:24.740 --> 09:33.620]  есть по факту один общий класс, в котором есть внутри связи. Если неформально математически
[09:33.620 --> 09:39.500]  говорить, давайте скажу, что это, грубо говоря, количество связи графе, поделенное на общее
[09:39.500 --> 09:44.820]  количество связи. Понятно, формальное определение немного другое. Вот. Ну, тем самым у нас
[09:44.820 --> 09:50.460]  получается доля связи внутри каждого класса растет. То есть у нас в терминах, вот если мы находили
[09:50.460 --> 09:59.780]  здесь, то cohesion, так, стоп, high cohesion, low coupling. То есть мы находимся здесь, cohesion у нас точно
[09:59.780 --> 10:13.500]  растет. Так. Что касается coupling? Связанности между классами. Ну, тут надо замерять. В общем,
[10:13.500 --> 10:20.780]  потому что у нас, возможно, эти классы между собой сильно были связаны, но тогда надо смотреть по
[10:20.780 --> 10:27.100]  зависимости в классе, все хорошо или нет. То есть мы можем пойти как и сюда, так и сюда. Но скорее
[10:27.100 --> 10:32.540]  всего, если у нас хорошо продумана архитектура системы, то мы вправо не пойдем. Мы пойдем либо
[10:32.540 --> 10:37.140]  вверх, либо влево. Собственно, приближаясь к нашей идеальной точке. Понятно? Сразу скажу, что
[10:37.140 --> 10:44.220]  вся эта вещь чисто субъективная. Поэтому тут не надо воспринимать это все как истину в последней
[10:44.220 --> 10:50.780]  инстанции. И сразу скажу, что solite обычно применяется в последней стадии. То есть перед,
[10:50.780 --> 10:58.020]  точнее, после всех аббревиатур, которые мы с вами рассмотрели. Тут важно сказать, что бывает такое,
[10:58.020 --> 11:04.700]  что один класс играет одну обязанность, или один класс должен выполнять одно дело. Но тут важно
[11:04.700 --> 11:13.540]  обычно именно разделить по ролям все. То есть в принципе человек, он многозадачный. Но при этом
[11:13.540 --> 11:19.580]  не стоит делать сразу класс человек, который умеет делать все сразу. Хотя в жизни такие примеры
[11:19.580 --> 11:49.340]  случаются. Понятен ли вот этот принцип? Стараемся... Да. Вы еще раз говорите, у нас был класс, в котором было много внутрифункционала, потом мы разделили на много подкласса. Почему у нас тогда акохижен, который является связанным с внутри класса, увеличивается? Потому что, смотрите, еще раз, изначально в момент времени А это был один класс. А акохижен, считаю, если мы говорим в среднем по программам продуктов, он считается в среднем по всем классам.
[11:49.340 --> 12:19.100]  Вот. То есть получается акохижен у нас внутри каждого класса относительно вырос, потому что здесь связи было много. Ну представьте себе, что у нас вот здесь типа было там очень полный граф. То есть внутри каждого из этих подклассов у нас акохижен единица. Ну можем считать. А тогда у нас получается, что в момент времени Т1 у нас акохижен для этих четырех классов.
[12:19.100 --> 12:30.860]  Будет средний единичка. А в момент времени Т0, когда мы еще не разделили на классы связанность, то было меньше. Потому что у нас каких-то ребер здесь нету. Каких-то взаимосвязей.
[12:30.860 --> 12:44.620]  То, соответственно, у нас в момент времени Т0 акохижен был меньше единиц. Вот. Но опять же, если акохижен в такой момент времени не растет, значит что-то у нас проблема с кодом.
[12:44.620 --> 12:54.540]  Опять же, говорю, что это чисто субъективно. И тут у нас больше именно про такую вещь говорим. Так. Есть вопросы по этому принципу?
[12:56.060 --> 13:08.540]  То есть если вы видите в коде, что у вас, допустим, какой-то класс а-ля университет делает много чего, ну подумайте. Может быть его надо на департаменты разбить. Или на какие-то другие роли.
[13:09.420 --> 13:13.420]  Вот. Собственно, опять же, это помогает разрешать GotObject.
[13:13.420 --> 13:21.420]  То есть, у нас не полный граф связанств между этими подклассами.
[13:21.420 --> 13:27.420]  Да, да. Именно так.
[13:29.420 --> 13:37.420]  Так, следующий принцип, который очень хороший и связан с тем, что не нужно копипастить много кода.
[13:38.300 --> 13:40.300]  То есть не нужно переформатировать код из одного места в другое.
[13:40.300 --> 13:44.300]  Метод называется открытость и закрытость.
[13:44.300 --> 13:50.300]  Значит, запоминаем. С ним часто будем встречаться. Класс обычно открыт для расширения.
[13:50.300 --> 13:54.300]  Чтобы вы понимали, что такое расширение, это extents.
[13:54.300 --> 13:56.300]  С другой точки зрения это наследование.
[13:56.300 --> 14:02.300]  То есть мы можем сказать, что класс обычно должен быть открыт для наследования и закрыт для модификации.
[14:03.180 --> 14:09.180]  Как пример. Представьте себе робота, который умел резать что-то.
[14:09.180 --> 14:11.180]  Дальше он говорит, окей, я закрываюсь на ремонт.
[14:11.180 --> 14:17.180]  А дальше я говорю, что он говорит, что я умею красить.
[14:17.180 --> 14:19.180]  Через некоторое время.
[14:19.180 --> 14:23.180]  Понятно, что мы внесли модификацию нашего исходного робота.
[14:23.180 --> 14:27.180]  И если наш робот снова захочет что-то резать, то у него возникнут проблемы.
[14:27.180 --> 14:29.180]  Потому что мы это откатить не можем.
[14:30.060 --> 14:34.060]  Поэтому лучше, если так делать, лучше создать наследника класса.
[14:34.060 --> 14:38.060]  Робота, который умеет резать, который теперь есть функция красить.
[14:38.060 --> 14:42.060]  То есть у него добавляется дополнительная функциональность.
[14:42.060 --> 14:46.060]  Связано с тем, что мы с вами можем дополнительно красить.
[14:46.060 --> 14:50.060]  Соответственно, если мы хотим, это на самом деле не очень хороший пример.
[14:50.060 --> 14:54.060]  Лучше сделать так, что если у нас есть какие-то два класса.
[14:54.060 --> 14:56.060]  Создать какой-то базовый класс.
[14:56.940 --> 15:06.940]  И дальше отнаследовать от него два класса, которые умеют что-то делать.
[15:06.940 --> 15:10.940]  Образно говоря, мы можем...
[15:10.940 --> 15:16.940]  Если у нас какое-нибудь, допустим, есть транспортное средство.
[15:16.940 --> 15:22.940]  То у нас в качестве транспортного средства может быть, например, какая-нибудь машина.
[15:23.820 --> 15:25.820]  Либо самокат.
[15:25.820 --> 15:29.820]  Кто знает, как самокат по-английски пишется?
[15:33.820 --> 15:35.820]  Ну давайте скейт его назовем.
[15:35.820 --> 15:37.820]  Конечно, это не будет самокатом.
[15:39.820 --> 15:43.820]  И, допустим, эти оба транспорта умеют ездить с какой-то скоростью.
[15:43.820 --> 15:47.820]  Допустим, у нас есть метод move.
[15:47.820 --> 15:51.820]  Но при этом они могут передвигаться по разной поверхности.
[15:52.700 --> 15:58.700]  Конечно, это не очень хорошо, и это обычно всех бесит, но все же реальности у нас такие.
[15:58.700 --> 16:02.700]  Допустим, у скейта есть свои ограничения по скорости,
[16:02.700 --> 16:06.700]  у машины есть свои ограничения по скорости.
[16:06.700 --> 16:12.700]  И вот как раз зачастую паттерны проектирования, про которые мы сегодня будем говорить,
[16:12.700 --> 16:16.700]  они заточены про то, чтобы как раз разрешать принцип открытости-закрытости.
[16:17.580 --> 16:23.580]  То есть, смотрите, если у вас чешутся руки в каком-нибудь родительском классе,
[16:23.580 --> 16:29.580]  поменять код, то значит, что-то в вашем коде, возможно, не так.
[16:31.580 --> 16:35.580]  Так, давайте спрошу вопрос по этому принципу.
[16:39.580 --> 16:41.580]  Так, нет вопросов. Хорошо.
[16:42.460 --> 16:46.460]  Третий принцип называется принцип замены Барбары Лисков.
[16:46.460 --> 16:54.460]  Значит, если говорить неформально, представим себе, что у нас класс B наследуется от класса A,
[16:54.460 --> 17:02.460]  это значит, что замена класса A на класс B не ломает логику функционала.
[17:02.460 --> 17:10.460]  То есть, вы пользовались объектом класса A, потом вы пытаетесь перейти на наследника
[17:11.340 --> 17:13.340]  и пытаетесь вызвать тот же самый код.
[17:13.340 --> 17:19.340]  Канонический пример, который есть, это вычисление площади фигуры.
[17:21.340 --> 17:25.340]  В чем есть проблема вычисления площади фигуры?
[17:29.340 --> 17:33.340]  Вот, у вас есть, допустим, класс Эллипсис.
[17:35.340 --> 17:39.340]  И в качестве его наследника какой есть класс?
[17:41.340 --> 17:43.340]  Круг.
[17:45.340 --> 17:47.340]  И у него есть метод Эрия.
[17:49.340 --> 17:55.340]  Допустим, который принимает какие-то параметры и вычисляет AB.
[17:55.340 --> 17:59.340]  И он вычисляет по какой-то формуле эту функциональность.
[18:01.340 --> 18:05.340]  Мы с вами понимаем, что если мы хотим посчитать площадь круга,
[18:06.220 --> 18:10.220]  то есть, у нас есть Эллипс и мы хотим у него посчитать формулу круга,
[18:10.220 --> 18:14.220]  то, соответственно, замена Эллипса на круг не должна менять формулы вычислений.
[18:16.220 --> 18:22.220]  Если мы явно пропишем просто методы, которые у нас здесь есть,
[18:22.220 --> 18:28.220]  точнее, параметры, которые у нас есть, то и площадь круга у нас посчитается неверно.
[18:28.220 --> 18:34.220]  Потому что мы хотим для площади круга посчитать площадь это 1 квадрат,
[18:35.100 --> 18:41.100]  а как минимум в Эллипсе нам нужно не использовать несколько параметров, а не 1.
[18:41.100 --> 18:45.100]  То есть, если у нас будет поле, относительно которого мы можем посчитать код,
[18:45.100 --> 18:47.100]  то тогда без проблем.
[18:49.100 --> 18:53.100]  Если мы говорим про пример здесь, то мы говорим следующее.
[18:53.100 --> 18:55.100]  Давайте посмотрим на картинку.
[18:55.100 --> 19:01.100]  Представьте себе, у нас есть отец и сын.
[19:01.980 --> 19:07.980]  Сэм говорит, что я готовлю кофе, а этот товарищ говорит, что давай тоже кофе.
[19:07.980 --> 19:10.980]  Ему, говорит Сэм, сделаешь кофе.
[19:10.980 --> 19:12.980]  Он говорит, что отлично, спасибо.
[19:13.980 --> 19:19.980]  А теперь доверяют это все тоже самое сыну, дочернему классу,
[19:19.980 --> 19:21.980]  вот этого маленького робота.
[19:21.980 --> 19:25.980]  Он говорит, что я готовить кофе не умею, но вот вам вода.
[19:25.980 --> 19:28.980]  То есть, он умеет отдавать какой-то другой результат,
[19:29.860 --> 19:31.860]  чтобы функция «сготовь кофе».
[19:31.860 --> 19:33.860]  Это не очень хорошо.
[19:33.860 --> 19:37.860]  Соответственно, если мы говорим, что сделаем кофе,
[19:37.860 --> 19:40.860]  то мы можем, допустим, сделать конкретный кофе.
[19:40.860 --> 19:44.860]  Это нам никто не запрещает по спецификации.
[19:44.860 --> 19:48.860]  Поэтому с этим нужно быть аккуратнее.
[19:48.860 --> 19:54.860]  Зачастую этот принцип не часто встречается на практике,
[19:54.860 --> 19:58.860]  но тоже с ним нужно будет быть аккуратнее.
[19:59.740 --> 20:03.740]  И примеры. Тут как раз про фигуры.
[20:03.740 --> 20:05.740]  Будьте аккуратны. Как решать его?
[20:05.740 --> 20:08.740]  Нужно выносить функциональность не через параметры,
[20:08.740 --> 20:12.740]  чтобы у нас ничего не ломалось, а заносить это в поля.
[20:12.740 --> 20:14.740]  Этого класса.
[20:18.740 --> 20:20.740]  Так, понятен ли этот принцип?
[20:20.740 --> 20:23.740]  Этот принцип на самом деле самый сложный для понимания.
[20:24.620 --> 20:26.620]  Почему это важно?
[20:26.620 --> 20:32.620]  Потому что, зачастую, что нам позволяет вообще делать наследование?
[20:32.620 --> 20:34.620]  И принцип ООП.
[20:34.620 --> 20:36.620]  У нас есть класс А.
[20:36.620 --> 20:42.620]  Мы можем объявить с вами образно говоря.
[20:42.620 --> 20:44.620]  Давайте я на С++ напишу.
[20:45.500 --> 20:47.500]  То есть у нас есть класс А,
[20:47.500 --> 20:50.500]  который является новым экземпляром класса B.
[20:50.500 --> 20:54.500]  Мы общаемся с вами с объектом класса A.
[20:54.500 --> 20:57.500]  Потому что у нас класс A наследуется от класса B,
[20:57.500 --> 21:00.500]  а наследуется от класса A.
[21:00.500 --> 21:02.500]  Что мы с вами хотим?
[21:02.500 --> 21:06.500]  Мы хотим, чтобы когда мы, допустим, высунули,
[21:06.500 --> 21:09.500]  чтобы у нас было не только класс A,
[21:09.500 --> 21:11.500]  но и класс B.
[21:12.380 --> 21:19.380]  Мы хотим с вами, чтобы когда мы, допустим, вызовем A.find,
[21:19.380 --> 21:23.380]  у нас выполнился функционал именно нормального класса,
[21:23.380 --> 21:25.380]  а не наследника.
[21:25.380 --> 21:27.380]  То есть, допустим, это если у нас есть абстрактный класс.
[21:27.380 --> 21:29.380]  Вот.
[21:29.380 --> 21:31.380]  Иначе это все будет работать.
[21:31.380 --> 21:33.380]  Значит, как вы думаете,
[21:33.380 --> 21:36.380]  когда можно обнаружить принцип нарушения барбаралисков?
[21:36.380 --> 21:38.380]  В коде.
[21:42.380 --> 21:44.380]  Виртуальное наследование.
[21:44.380 --> 21:46.380]  Виртуальное наследование,
[21:46.380 --> 21:50.380]  оно нам как раз помогает сделать вообще наследование.
[21:50.380 --> 21:52.380]  Виртуальное может быть...
[21:52.380 --> 21:56.380]  Смотрите, если вы в коде где-нибудь касты встречаете,
[21:56.380 --> 21:58.380]  особенно динамик касты,
[21:58.380 --> 22:02.380]  это скорее всего, что вам нужно перейти именно в конкретный экземпляр
[22:02.380 --> 22:04.380]  конкретного класса.
[22:04.380 --> 22:08.380]  А в принципе ОХОП лучше такого не делать.
[22:08.380 --> 22:10.380]  То есть, закладывать функционал
[22:11.260 --> 22:13.260]  в сам класс,
[22:13.260 --> 22:17.260]  допустим, передавая в него какой-то параметр.
[22:17.260 --> 22:19.260]  Вот.
[22:19.260 --> 22:21.260]  Соответственно, если у вас в вашем коде будет достаточно много кастов
[22:21.260 --> 22:23.260]  или проверка на типы,
[22:23.260 --> 22:27.260]  значит, скорее всего, где-то принцип барбаралисков нарушен.
[22:27.260 --> 22:29.260]  Так.
[22:29.260 --> 22:31.260]  Давайте еще раз уточню.
[22:31.260 --> 22:33.260]  Понятно ли это?
[22:33.260 --> 22:35.260]  Угу.
[22:35.260 --> 22:37.260]  Следующий принцип интересен.
[22:37.260 --> 22:39.260]  И, как ни странно,
[22:40.140 --> 22:42.140]  он является нативным джави.
[22:42.140 --> 22:44.140]  Это принцип интерфейс сегрегейшн.
[22:44.140 --> 22:46.140]  То есть,
[22:46.140 --> 22:48.140]  суть в чем состоит?
[22:48.140 --> 22:50.140]  Суть в том, что
[22:50.140 --> 22:52.140]  не нужно ставить клиент
[22:52.140 --> 22:54.140]  в зависимости от методов,
[22:54.140 --> 22:56.140]  которые он не использует.
[22:56.140 --> 22:58.140]  То есть, мы стараемся,
[22:58.140 --> 23:00.140]  все наши функциональности, которые есть,
[23:00.140 --> 23:04.140]  попытаться разделить на максимальное количество интерфейсов.
[23:04.140 --> 23:06.140]  И вот в джави, допустим, запрещен такой факт,
[23:06.140 --> 23:08.140]  как ромбовидное наследование.
[23:08.140 --> 23:10.140]  Что такое ромбовидное наследование?
[23:12.140 --> 23:14.140]  Давайте я это покажу.
[23:14.140 --> 23:16.140]  Например, может быть, кто-то из вас знает.
[23:16.140 --> 23:18.140]  Представьте себе, что у нас есть класс A,
[23:18.140 --> 23:20.140]  в котором
[23:20.140 --> 23:22.140]  у вас есть классы B.
[23:22.140 --> 23:24.140]  Это я рисую так
[23:24.140 --> 23:26.140]  наследник класса.
[23:26.140 --> 23:28.140]  И есть класс C.
[23:28.140 --> 23:30.140]  И мы говорим, что давайте
[23:30.140 --> 23:32.140]  мы с вами класс D будем наследовать
[23:32.140 --> 23:34.140]  от
[23:34.140 --> 23:36.140]  класса B
[23:36.140 --> 23:38.140]  до класса C.
[23:40.140 --> 23:42.140]  И это обычно от.
[23:42.140 --> 23:44.140]  Почему?
[23:50.140 --> 23:52.140]  Почему не очень хорошо использовать
[23:52.140 --> 23:54.140]  ромбовидное наследование?
[24:06.140 --> 24:08.140]  Ну да.
[24:08.140 --> 24:10.140]  Да, у нас будут методы,
[24:10.140 --> 24:12.140]  которые не используют вообще.
[24:12.140 --> 24:14.140]  Более того, если, допустим, у нас
[24:14.140 --> 24:16.140]  реализации методов B и C
[24:16.140 --> 24:18.140]  в какой-то момент времени совпадут,
[24:18.140 --> 24:20.140]  точнее не совпадут, то непонятно,
[24:20.140 --> 24:22.140]  какую реализацию класс D
[24:22.140 --> 24:24.140]  должен брать.
[24:24.140 --> 24:26.140]  И для этого
[24:26.140 --> 24:28.140]  как раз возникает принцип разрешения зависимости.
[24:28.140 --> 24:30.140]  И в общем, с ромбовидным наследованием
[24:30.140 --> 24:32.140]  все обычно сложно.
[24:32.140 --> 24:34.140]  Собственно, каким
[24:34.140 --> 24:36.140]  образом его можно разрешать?
[24:36.140 --> 24:38.140]  Если мы говорим в терминах ООП,
[24:38.140 --> 24:40.140]  нам как раз понадобится понятие
[24:40.140 --> 24:42.140]  интерфейсов.
[24:42.140 --> 24:44.140]  И что нам поможет сделать
[24:44.140 --> 24:46.140]  интерфейс?
[24:46.140 --> 24:48.140]  Мы можем сказать
[24:48.140 --> 24:50.140]  с вами, что у нас есть, допустим, класс A,
[24:50.140 --> 24:52.140]  от него
[24:52.140 --> 24:54.140]  наследуется класс B,
[24:54.140 --> 24:56.140]  а от него
[24:56.140 --> 24:58.140]  наследуется класс D.
[24:58.140 --> 25:00.140]  Но при этом мы можем сказать,
[25:00.140 --> 25:02.140]  что у нас с вами
[25:02.140 --> 25:04.140]  есть
[25:04.140 --> 25:06.140]  интерфейс C.
[25:08.140 --> 25:10.140]  И мы будем
[25:10.140 --> 25:12.140]  имплементировать
[25:12.140 --> 25:14.140]  интерфейс класса C.
[25:14.140 --> 25:16.140]  Точнее, имплементировать
[25:16.140 --> 25:18.140]  интерфейс C. Это, допустим,
[25:18.140 --> 25:20.140]  у него был метод read,
[25:22.140 --> 25:24.140]  который, естественно, является публичным,
[25:24.140 --> 25:26.140]  поскольку он имеет интерфейс,
[25:26.140 --> 25:28.140]  и мы должны будем имплементировать этот конкретный метод,
[25:28.140 --> 25:30.140]  который нам нужен.
[25:30.140 --> 25:32.140]  Вот.
[25:32.140 --> 25:34.140]  Вот так это работает в джаве,
[25:34.140 --> 25:36.140]  то есть в джаве нет равновидного наследования.
[25:36.140 --> 25:38.140]  Оно просто запрещено.
[25:38.140 --> 25:40.140]  Но вам разрешается имплементировать большое
[25:40.140 --> 25:42.140]  количество классов.
[25:42.140 --> 25:44.140]  Если мы с вами сейчас пойдем
[25:44.140 --> 25:46.140]  в любую документацию в джаве,
[25:46.140 --> 25:48.140]  то зачастую
[25:48.140 --> 25:50.140]  мы увидим вот такое вот.
[25:50.140 --> 25:52.140]  У нас
[25:52.140 --> 25:54.140]  я взял библиотеку Hadoop
[25:54.140 --> 25:56.140]  для обработки больших объемов данных,
[25:56.140 --> 25:58.140]  ну и давайте посмотрим на замечательный класс
[25:58.140 --> 26:00.140]  IntWriteable, который позволяет
[26:00.140 --> 26:02.140]  реализовать обертку над интеджером.
[26:02.140 --> 26:04.140]  В основном мы видим
[26:04.140 --> 26:06.140]  с вами, что IntWriteable наследуется
[26:06.140 --> 26:08.140]  от класса Object.
[26:08.140 --> 26:10.140]  В джаве за счет того, что у нас
[26:10.140 --> 26:12.140]  идет линейное наследование,
[26:12.140 --> 26:14.140]  мы всегда можем отпочковаться
[26:14.140 --> 26:16.140]  от корневого класса, который является
[26:16.140 --> 26:18.140]  Object. Но посмотрите,
[26:18.140 --> 26:20.140]  сколько интерфейсов оно реализует.
[26:22.140 --> 26:24.140]  Метод Writeable.
[26:24.140 --> 26:26.140]  Как вы думаете,
[26:26.140 --> 26:28.140]  что-то у Writeable есть?
[26:28.140 --> 26:30.140]  Write. Хорошо.
[26:30.140 --> 26:32.140]  Comparable?
[26:32.140 --> 26:34.140]  Comparable, да.
[26:34.140 --> 26:36.140]  И Writeable Comparable?
[26:36.140 --> 26:38.140]  Comparable Write.
[26:38.140 --> 26:40.140]  Да, это скорее всего Comparing Write.
[26:40.140 --> 26:42.140]  Надо смотреть документацию, точно не помню.
[26:42.140 --> 26:44.140]  То есть видно, что
[26:44.140 --> 26:46.140]  вот у нас такая обертка есть.
[26:46.140 --> 26:48.140]  Дополнительно, кстати, в джаве
[26:48.140 --> 26:50.140]  есть такое понятие как Generic.
[26:50.140 --> 26:52.140]  Это не совсем шаблоны,
[26:52.140 --> 26:54.140]  но работает по похожим принципам.
[26:54.140 --> 26:56.140]  Мы сразу видим, что
[26:56.140 --> 26:58.140]  у нас класс InWriteable,
[26:58.140 --> 27:00.140]  если мы захотим,
[27:00.140 --> 27:02.140]  мы можем сделать intComparable.
[27:02.140 --> 27:04.140]  Что нужно сделать, чтобы сделать
[27:04.140 --> 27:06.140]  intComparable?
[27:08.140 --> 27:10.140]  Сколько интерфейсов нам нужно будет
[27:10.140 --> 27:12.140]  реализовать?
[27:14.140 --> 27:16.140]  Один. На самом деле нам достаточно
[27:16.140 --> 27:18.140]  будет реализовать интерфейс Comparable.
[27:20.140 --> 27:22.140]  Вот таким вот образом
[27:22.140 --> 27:24.140]  это можно решать.
[27:24.140 --> 27:26.140]  То есть можно оплодить большое количество интерфейсов.
[27:26.140 --> 27:28.140]  Это без проблем.
[27:28.140 --> 27:30.140]  То есть старайтесь максимально сильно думать,
[27:30.140 --> 27:32.140]  нужно ли вам большое количество
[27:32.140 --> 27:34.140]  абстрактных классов или можете обойтись
[27:34.140 --> 27:36.140]  с интерфейсами.
[27:36.140 --> 27:38.140]  Так, давайте я спрошу про
[27:38.140 --> 27:40.140]  Interface Segregation принцип, ясно?
[27:42.140 --> 27:44.140]  Понятно.
[27:44.140 --> 27:46.140]  Тут две разные диаграммы.
[27:46.140 --> 27:48.140]  Была необходимость в Diamond
[27:48.140 --> 27:50.140]  на следовании, а слева мы сказали,
[27:50.140 --> 27:52.140]  что у нас же цели просто вообще другое.
[27:52.140 --> 27:54.140]  Ну, согласен.
[27:56.140 --> 27:58.140]  Согласен, это новая архитектура,
[27:58.140 --> 28:00.140]  и здесь нужно решить, просто какие из методов
[28:00.140 --> 28:02.140]  класса B и C действительно нам нужны или нет
[28:02.140 --> 28:04.140]  и может быть их стоит вынести в интерфейс отдельный.
[28:04.140 --> 28:06.140]  А когда вообще может возникнуть
[28:06.140 --> 28:08.140]  ромовидное...
[28:14.140 --> 28:16.140]  Не знаю. Обычно
[28:16.140 --> 28:18.140]  это последствия
[28:18.140 --> 28:20.140]  к чему может привести
[28:20.140 --> 28:22.140]  неправильное архитектурирование.
[28:22.140 --> 28:24.140]  Но зачастую, допустим, у нас
[28:24.140 --> 28:26.140]  A.
[28:26.140 --> 28:28.140]  Вот как раз пример.
[28:28.140 --> 28:30.140]  Допустим, у нас есть
[28:30.140 --> 28:32.140]  класс, собственно, обертка
[28:32.140 --> 28:34.140]  над writable, дальше мы применяем
[28:34.140 --> 28:36.140]  определенный тип, дальше мы
[28:36.140 --> 28:38.140]  применяем метод для сравнения.
[28:38.140 --> 28:40.140]  Соответственно, что такое int writable?
[28:40.140 --> 28:42.140]  Это, собственно, int, который
[28:42.140 --> 28:44.140]  и в writable, и comparison.
[28:44.140 --> 28:46.140]  Готов к write, имеет
[28:46.140 --> 28:48.140]  реализация метода write, имеет реализация
[28:48.140 --> 28:50.140]  метода compare. Ну, пожалуйста.
[28:50.140 --> 28:52.140]  Мы получаем как раз вот, типа,
[28:52.140 --> 28:54.140]  вот этот класс, наследник этого класса
[28:54.140 --> 28:56.140]  и этого класса. Но зачем
[28:56.140 --> 28:58.140]  нам делать, если мы можем, допустим, сделать
[28:58.140 --> 29:00.140]  два интерфейса и от них отимплементироваться?
[29:00.140 --> 29:02.140]  Да, кода будет больше.
[29:02.140 --> 29:04.140]  Но, по крайней мере,
[29:04.140 --> 29:06.140]  с ромовидностью мы исправимся.
[29:06.140 --> 29:08.140]  Есть еще некоторые паттерны,
[29:08.140 --> 29:10.140]  которые позволяют избавиться от такого
[29:10.140 --> 29:12.140]  ромовидного наследования.
[29:12.140 --> 29:14.140]  Если забегать наперед, это
[29:14.140 --> 29:16.140]  как раз запринтонный мост.
[29:18.140 --> 29:20.140]  Вот. Там как раз вот
[29:20.140 --> 29:22.140]  похожий пример
[29:22.140 --> 29:24.140]  с, так сказать,
[29:24.140 --> 29:26.140]  с устройством
[29:26.140 --> 29:28.140]  и с тем, кем оно управляет,
[29:28.140 --> 29:30.140]  можно будет разделить. То есть там
[29:30.140 --> 29:32.140]  по факту у вас есть какое-то
[29:32.140 --> 29:34.140]  ромовидное наследование, оно делится на
[29:34.140 --> 29:36.140]  два простых наследования и
[29:36.140 --> 29:38.140]  связь между ними.
[29:38.140 --> 29:45.140]  Если будет два интерфейса с одинаковым функционалом, который был общим функционалом, это А.
[29:45.140 --> 29:52.140]  Там же будет та же проблема, что непонятно, сколько в ДРС.
[29:52.140 --> 29:54.140]  Там в ДРС будет условно два метода Райта.
[29:54.140 --> 29:59.140]  То есть те методы, которые есть в А, которые общие в Б и Ц.
[29:59.140 --> 30:03.140]  Если даже их разделить делом для копии А, то все равно они не решают.
[30:03.140 --> 30:07.140]  Потому что сам проблема с тем, что у нас один тот же метод и не по этому кто выбирать.
[30:08.140 --> 30:13.140]  А, типа что у нас?
[30:13.140 --> 30:17.140]  Все равно же есть общий функционал и идея того, что просто их сделают.
[30:17.140 --> 30:19.140]  Да, согласен.
[30:19.140 --> 30:22.140]  Смотрите, тогда мы можем сделать следующее.
[30:22.140 --> 30:28.140]  Давайте мы скажем, что Ц, вот если нам нужен, допустим, отдельный класс Ц в сопринянной роли,
[30:28.140 --> 30:30.140]  мы создадим интерфейс Е.
[30:30.140 --> 30:35.140]  Ц будет наследоваться от класса А и имплементировать интерфейс Е.
[30:35.140 --> 30:40.140]  А тогда что у нас будет делать класс Д?
[30:40.140 --> 30:44.140]  У нас должен быть такой же функционал, как у класса С.
[30:44.140 --> 30:46.140]  А класс С что делает?
[30:46.140 --> 30:49.140]  Наследуется от класса А и имплементирует интерфейс Е.
[30:49.140 --> 30:54.140]  Тем самым нам по факту нужно сделать так, чтобы класс Д наследовался от класса Б.
[30:54.140 --> 30:57.140]  И имплементировал интерфейс Е.
[30:57.140 --> 31:02.140]  То есть вот таким вот образом мы прокидываем и решаем ромбовидную наследовательство.
[31:02.140 --> 31:05.140]  Это один из способов решения.
[31:05.140 --> 31:10.140]  Спасибо за вопрос.
[31:10.140 --> 31:15.140]  Нет, не всегда.
[31:15.140 --> 31:20.140]  Тут надо смотреть по коду и читать, в него вникать.
[31:20.140 --> 31:25.140]  Да.
[31:45.140 --> 31:47.140]  Да, да, да.
[31:47.140 --> 31:51.140]  Ну то есть зачастую вам излишней реализации просто не нужно.
[31:51.140 --> 31:56.140]  То есть ее можно добавить по месту.
[32:02.140 --> 32:04.140]  Так, хорошо.
[32:04.140 --> 32:09.140]  И давайте теперь еще один принцип, если с этим разобрались, будет очень важный.
[32:09.140 --> 32:14.140]  На самом деле он такой фундаментальный и помогает решать проблемы не ромбовидного наследования,
[32:14.140 --> 32:16.140]  а ромбовидной зависимости.
[32:16.140 --> 32:21.140]  Смотрите, он формулируется из четырех тезисов.
[32:21.140 --> 32:26.140]  Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
[32:26.140 --> 32:30.140]  Второе, модули должны зависеть от абстракции.
[32:30.140 --> 32:36.140]  То есть если у вас есть класс Б, дальше у вас класс Б что-то использует,
[32:36.140 --> 32:39.140]  то лучше это делать через обертку.
[32:39.140 --> 32:42.140]  Эта обертка, как ни странно, называется адаптером.
[32:42.140 --> 32:46.140]  Дальше, абстракции не должны зависеть от деталей.
[32:46.140 --> 32:50.140]  То есть нижний уровень не должен зависеть от деталей реализации.
[32:50.140 --> 32:53.140]  А вот детали реализации должны зависеть от абстракции.
[32:53.140 --> 32:58.140]  То есть смотрите, давайте я сразу на примере покажу, чтобы было понятно.
[32:58.140 --> 33:00.140]  Вот пример.
[33:00.140 --> 33:07.140]  Что мы здесь видим? У нас видите здесь четырехугольник A, B, E, C.
[33:07.140 --> 33:09.140]  На левой картинке.
[33:09.140 --> 33:13.140]  То есть у нас A, смотрите, зависит от B, B зависит от E.
[33:13.140 --> 33:16.140]  A зависит от C, C зависит от E.
[33:16.140 --> 33:23.140]  В чем проблема? Если мы с вами в E поменяем код, то что может произойти?
[33:23.140 --> 33:27.140]  Ляжет либо B, либо C.
[33:27.140 --> 33:31.140]  С высокой степень вероятности ляжет только A.
[33:31.140 --> 33:36.140]  Ответственно, мы можем стрелочки из B в E и из C в E инвертировать.
[33:36.140 --> 33:39.140]  Это как раз называется вет от инвертирования зависимости.
[33:39.140 --> 33:41.140]  Принцип инвертирования зависимости.
[33:41.140 --> 33:44.140]  Давайте мы скажем, что E, что B.
[33:44.140 --> 33:49.140]  Для того, чтобы реализовать зависимость, нужно сделать интерфейс.
[33:49.140 --> 33:52.140]  Роль, который ему нужно.
[33:52.140 --> 33:57.140]  Мы ставим его в экземпляры класса.
[33:57.140 --> 34:02.140]  И дальше у C ставим экземпляры класса тоже в зависимости от интерфейса.
[34:02.140 --> 34:05.140]  А дальше E, который зависит снизу.
[34:05.140 --> 34:09.140]  Получается деталь будет зависеть от абстракции.
[34:09.140 --> 34:12.140]  Что нам это позволяет сделать?
[34:12.140 --> 34:14.140]  Нам позволяет сделать так.
[34:14.140 --> 34:19.140]  У нас метод C каким-то образом поменял функционал.
[34:19.140 --> 34:22.140]  Ему нужно внести в зависимость в интерфейс.
[34:22.140 --> 34:28.140]  В интерфейс лучше не менять, но допустим нам код E каким-то образом нужно поменять.
[34:28.140 --> 34:32.140]  Мы меняем код E, но при этом интерфейсы у нас не меняются.
[34:32.140 --> 34:37.140]  Они пристыковываются как к B, так и к C.
[34:37.140 --> 34:40.140]  И ничего не ломается.
[34:40.140 --> 34:43.140]  В хорошем случае.
[34:54.140 --> 34:56.140]  Да, такое может быть.
[34:56.140 --> 35:04.140]  Но обычно, скорее всего, вот прямо жестко копифасты в данный момент прямо не возникнет.
[35:14.140 --> 35:18.140]  Нет, смотрите, это так.
[35:18.140 --> 35:22.140]  Наследоваться от E в каком месте? Влево, вправо?
[35:26.140 --> 35:30.140]  E в зависимости от C. E нет. Они в зависимости от интерфейса.
[35:30.140 --> 35:33.140]  Ну да, они в зависимости от интерфейса.
[35:33.140 --> 35:35.140]  Но по факту мы говорим следующее.
[35:35.140 --> 35:38.140]  Представьте себе классический пример.
[35:38.140 --> 35:41.140]  Тут, кстати, есть картинка.
[35:41.140 --> 35:44.140]  Давайте посмотрим внимательно на картинку.
[35:44.140 --> 35:46.140]  Я не знаю, плохо видно.
[35:46.140 --> 35:51.140]  У робота есть рука, которая заменена на пилу.
[35:52.140 --> 35:57.140]  Понятно, чтобы заменить эту пилу на какую-то другую вещь,
[35:57.140 --> 36:03.140]  надо отпилить эту пилу и вставить что-то новое.
[36:03.140 --> 36:06.140]  Что обычно делают в этом месте?
[36:06.140 --> 36:11.140]  Делают переходник, который позволит одно заменить на другое.
[36:11.140 --> 36:18.140]  В этом месте переходник – это как раз интерфейс, с которого мы можем подключиться.
[36:18.140 --> 36:22.140]  Грубо говоря, если мы хотим с вами поменять зависимость,
[36:22.140 --> 36:24.140]  то нам нужно сделать переходник.
[36:24.140 --> 36:28.140]  И при этом, возможно, нам код класса E вообще придется переписывать.
[36:28.140 --> 36:35.140]  Главное, просто в те пазы, которые у нас есть для класса C и B, встал интерфейс E.
[36:35.140 --> 36:42.140]  А теперь направо. Какая зависимость между E и B и C?
[36:42.140 --> 36:48.140]  Смотрите, в левой картинке B дергал на прямую E, и C дергал на прямую E.
[36:48.140 --> 36:52.140]  А в правой, он говорит, так, B нам нужна функция, образно говоря,
[36:52.140 --> 36:57.140]  чтобы мы готовим, допустим, какое-то блюдо, оно что-то взмешивало.
[36:57.140 --> 37:02.140]  То есть мы взбалтываем блюдо при помощи инструмента E.
[37:02.140 --> 37:08.140]  Мы говорим, что у B есть метод взболтать, у интерфейса есть метод взболтать.
[37:08.140 --> 37:13.140]  И у C есть, допустим, метод перемешать.
[37:13.140 --> 37:16.140]  Хотят болтать, перемешать, это одно и то же.
[37:16.140 --> 37:18.140]  Давайте добавить приправу.
[37:18.140 --> 37:22.140]  Что мы могли сделать? Мы могли пойти купить мясорубку,
[37:22.140 --> 37:25.140]  какую-нибудь, которая это все будет делать.
[37:25.140 --> 37:31.140]  Но потом, когда мы берем и вместо мясорубки подключаем какой-нибудь кухонный комбайн,
[37:31.140 --> 37:37.140]  то мы понимаем, что у нас электричества внезапно нету, чтобы это все подключить.
[37:37.140 --> 37:44.140]  А здесь мы говорим, что нам для того, чтобы работать с B и C, нам нужно два метода.
[37:44.140 --> 37:47.140]  А кто именно их будет делать, нам вообще без разницы.
[37:47.140 --> 37:55.140]  То есть, образно говоря, давайте еще, кстати, какой-нибудь такой классический пример.
[37:55.140 --> 38:02.140]  Нам, допустим, нужно написать код какой-нибудь, который якобы будет работать как линукс-система.
[38:02.140 --> 38:07.140]  То есть нам неважно, что именно и на каком устройстве это будет эмулироваться.
[38:07.140 --> 38:12.140]  Мы делаем специальную прослойку, которая обладает этим интерфейсом.
[38:12.140 --> 38:18.140]  А зависимость, которая находится внизу, она просто должна реализовывать эти интерфейсы.
[38:18.140 --> 38:22.140]  Вы можете использовать Windows Subsystem for Linux для этих целей.
[38:22.140 --> 38:27.140]  Либо поставить виртуалку, либо использовать Docker.
[38:27.140 --> 38:29.140]  Вот у вас три варианта.
[38:29.140 --> 38:34.140]  И это позволяет нам легко переходить и эмигрировать с одной платформы на другой.
[38:34.140 --> 38:36.140]  То есть это больше пропортируемость.
[38:36.140 --> 38:38.140]  Я ответил на вопрос?
[38:38.140 --> 38:39.140]  Все, отлично.
[38:39.140 --> 38:41.140]  Интерфейсы без полей.
[38:41.140 --> 38:43.140]  Вообще без.
[38:43.140 --> 38:48.140]  В классической терминологии интерфейсов интерфейсы не имеют никаких полей.
[38:48.140 --> 38:53.140]  Да, то есть наследование полей происходит при наследовании классов только.
[38:53.140 --> 38:56.140]  Ну вот, а у вас какой-то пример?
[38:56.140 --> 38:58.140]  У нас есть интерфейс с полями.
[38:58.140 --> 39:00.140]  У нас есть интерфейс без полей.
[39:00.140 --> 39:02.140]  У нас есть интерфейс без полей.
[39:02.140 --> 39:04.140]  У нас есть интерфейс без полей.
[39:04.140 --> 39:06.140]  У нас есть интерфейс без полей.
[39:06.140 --> 39:08.140]  У нас есть интерфейс без полей.
[39:08.140 --> 39:10.140]  У нас есть интерфейс без полей.
[39:10.140 --> 39:12.140]  У нас есть интерфейс без полей.
[39:12.140 --> 39:14.140]  У нас есть интерфейс без полей.
[39:14.140 --> 39:17.140]  Полей происходит при наследовании классов только.
[39:17.140 --> 39:21.140]  Ну вот, а в какой ситуации у нас в ебулике суперважные поля,
[39:21.140 --> 39:23.140]  которые должны быть влепаться и а,
[39:23.140 --> 39:25.140]  и тогда интерфейс не прокатится?
[39:25.140 --> 39:28.140]  Ну, придется дублировать код немного.
[39:30.140 --> 39:32.140]  То есть обычно есть, говорю,
[39:32.140 --> 39:36.140]  что обычно все-таки есть одна общая ветка наследования,
[39:36.140 --> 39:40.140]  и дальше уже от нее ответление в виде интерфейсов.
[39:40.140 --> 39:43.140]  Мы же в одном из предыдущих принципов убедились,
[39:43.140 --> 39:47.140]  что если у наследника есть такой же метод,
[39:47.140 --> 39:50.140]  так его лучше выносим из типа поля.
[39:50.140 --> 39:53.140]  Например, площадь.
[39:54.140 --> 39:56.140]  Так, вот этот, да?
[39:57.140 --> 40:00.140]  Open-closed principle. Так, еще раз?
[40:00.140 --> 40:02.140]  Можете сформулировать, я?
[40:02.140 --> 40:06.140]  Площадь мы выносим в поле, чтобы могли...
[40:06.140 --> 40:09.140]  А, согласен.
[40:09.140 --> 40:11.140]  А, принцип замены барбаралисков.
[40:11.140 --> 40:13.140]  Да, есть такое.
[40:13.140 --> 40:15.140]  Собственно, видно, что некоторые из принципов
[40:15.140 --> 40:17.140]  могут между собой конфликтовать.
[40:17.140 --> 40:21.140]  Собственно, принцип лисков и принцип dependency inversion.
[40:22.140 --> 40:25.140]  Выход посмотреть, насколько сложная у нас система
[40:25.140 --> 40:27.140]  и использовать более приоритетно.
[40:27.140 --> 40:31.140]  То есть если у нас система с огромным количеством зависимости,
[40:31.140 --> 40:33.140]  ну, просто большая экосистема,
[40:33.140 --> 40:35.140]  то лучше смотреть dependency inversion,
[40:35.140 --> 40:39.140]  потому что самое важное в нашей системе это гибкость.
[40:39.140 --> 40:41.140]  А что такое гибкость?
[40:41.140 --> 40:43.140]  Гибкость — это возможность в любой момент времени
[40:43.140 --> 40:46.140]  быстро адаптировать нашу систему к реалиям.
[40:46.140 --> 40:49.140]  Вот, при помощи dependency inversion мы можем, в принципе, взять,
[40:49.140 --> 40:54.140]  оцепить наш интерфейс Е, который здесь имеется,
[40:54.140 --> 40:57.140]  и заменить его на новый.
[40:58.140 --> 41:03.140]  И это нам намного важнее, чем смотреть на какие-то вот принципы замены.
[41:03.140 --> 41:07.140]  То есть мы один из приоритетов, мы один принцип вставим, приоритет нет?
[41:07.140 --> 41:09.140]  Да, да, да, да, конечно же.
[41:09.140 --> 41:11.140]  Смотрите, у нас пять принципов,
[41:11.140 --> 41:13.140]  и понятно, что возможных взаимосвязей,
[41:13.140 --> 41:17.140]  типа включаем-выключаем принцип 32, 2 в пятый.
[41:18.140 --> 41:21.140]  Поэтому некоторые из них могут в какой-то степени конкретовать.
[41:21.140 --> 41:23.140]  Опять же, это субъективная вещь,
[41:23.140 --> 41:25.140]  то есть надо смотреть, к чему стремиться,
[41:25.140 --> 41:27.140]  и попытаться выставить приоритеты.
[41:28.140 --> 41:31.140]  То есть обычно single responsibility — это хорошая вещь,
[41:31.140 --> 41:36.140]  потом на практике часто очень сильно встречается dependency inversion,
[41:36.140 --> 41:38.140]  и это вот обычно боль,
[41:38.140 --> 41:41.140]  с которой я даже сталкиваюсь на практике,
[41:41.140 --> 41:46.140]  в которой собственно классы приходится самим руками раздвигать.
[41:47.140 --> 41:50.140]  Interface segregation — он в некоторых языках реализован.
[41:50.140 --> 41:54.140]  Open-closed тоже зачастую важен, чтобы не лезть в родительский класс.
[41:54.140 --> 41:58.140]  Потому что, смотрите, мы когда работаем с вами с программным продуктом,
[41:58.140 --> 42:00.140]  работаем не только мы.
[42:00.140 --> 42:03.140]  Работаем большое количество пользователей и большое количество программистов.
[42:03.140 --> 42:08.140]  Соответственно, если мы пойдем править что-то, грубо говоря, в щиток,
[42:08.140 --> 42:11.140]  то может произойти такое, что щиток вырубит,
[42:11.140 --> 42:13.140]  и все останутся без света.
[42:15.140 --> 42:17.140]  Так, это все принципы солят.
[42:17.140 --> 42:18.140]  Давайте еще раз напомню.
[42:18.140 --> 42:22.140]  Single responsibility principle, open-closed principle,
[42:22.140 --> 42:26.140]  list of substitution, interface segregation, dependency inversion.
[42:28.140 --> 42:31.140]  Так, есть ли вопросы по ним?
[42:33.140 --> 42:34.140]  Хорошо.
[42:34.140 --> 42:38.140]  Давайте тогда движемся к другим вещам.
[42:38.140 --> 42:41.140]  Собственно, на самом деле,
[42:41.140 --> 42:44.140]  солят обычно применяется после того,
[42:44.140 --> 42:47.140]  как мы применим еще несколько принципов.
[42:47.140 --> 42:52.140]  Первый принцип, который здесь возникает, это принцип ягни.
[42:52.140 --> 42:56.140]  Он расшифровывается, вы не поверите как.
[42:56.140 --> 42:58.140]  Вам этого не надо.
[42:58.140 --> 43:03.140]  То есть зачастую, особенно мы в фистехе,
[43:03.140 --> 43:05.140]  есть такая расположенность,
[43:05.140 --> 43:08.140]  сразу сделает что-то вот такое супер-мега-уникальное.
[43:08.140 --> 43:13.140]  То есть кажется, что давайте продумаем убер-мега-систему.
[43:13.140 --> 43:15.140]  Кстати, про пример.
[43:15.140 --> 43:19.140]  Помните, у нас возникали дебаты по поводу того,
[43:19.140 --> 43:24.140]  что у нас сложная процедура верификации на курс.
[43:24.140 --> 43:28.140]  Что там вручную надо одобрять заявки все и так далее.
[43:28.140 --> 43:32.140]  А нельзя ли придумать какую-нибудь систему,
[43:32.140 --> 43:35.140]  которая автоматически будет принимать заявки,
[43:35.140 --> 43:37.140]  ну по крайней мере делать какие-то фильтры.
[43:37.140 --> 43:40.140]  На самом деле, изначально, когда задумывалась система,
[43:40.140 --> 43:45.140]  она не подразумевшляла, что в ней будет большое количество пользователей.
[43:45.140 --> 43:49.140]  Изначально она вообще писалась для одного курса технологии программирования.
[43:49.140 --> 43:52.140]  То есть нам не нужно было вот слишком сложные проверки.
[43:52.140 --> 43:54.140]  То есть нам этого просто не надо.
[43:54.140 --> 43:57.140]  И мы начинали отсекать все лишнее.
[43:57.140 --> 43:59.140]  То есть вы читаете спецификацию,
[43:59.140 --> 44:02.140]  и вообще, когда вы читаете первое техническое задание,
[44:02.140 --> 44:04.140]  которое вам может прийти,
[44:04.140 --> 44:09.140]  это не те технические задания, которые вы будете задавать.
[44:09.140 --> 44:14.140]  Это, допустим, задание на выполнение какого-то проекта или какой-то стартап.
[44:14.140 --> 44:17.140]  Вы начинаете думать о какой-то замечательной идее,
[44:17.140 --> 44:19.140]  которую можно реализовать.
[44:19.140 --> 44:22.140]  Вы понимаете, читаете, начинаете набрасывать идеи,
[44:22.140 --> 44:25.140]  у вас скапливается огромный ворох идей.
[44:25.140 --> 44:28.140]  А потом это называется брейншторм.
[44:28.140 --> 44:30.140]  Кстати, важный совет.
[44:30.140 --> 44:32.140]  Во время брейншторма не перебивайте людей.
[44:32.140 --> 44:35.140]  То есть это именно накидывание идей на вентилятор.
[44:35.140 --> 44:39.140]  После этого собирается и отсекается все лишнее.
[44:39.140 --> 44:45.140]  То есть не нужно, так сказать, ограничивать себя в мыслях,
[44:45.140 --> 44:49.140]  но, правда, нужно потом это жестко будет обрезать.
[44:49.140 --> 44:52.140]  Все эти дополнительные функционалы.
[44:55.140 --> 44:59.140]  Может быть, у кого-нибудь есть примеры,
[44:59.140 --> 45:02.140]  как вы понимаете это все дело.
[45:02.140 --> 45:05.140]  Возможно, мы с вами синхронизируемся сейчас.
[45:07.140 --> 45:09.140]  Был ли у вас такой кейс,
[45:09.140 --> 45:13.140]  что вы начинали делать какие-то вещи,
[45:13.140 --> 45:15.140]  надумывали себе много-много-много,
[45:15.140 --> 45:17.140]  а потом оказывается, что большую часть,
[45:17.140 --> 45:19.140]  когда вы доходите до них, вам вообще не нужны?
[45:21.140 --> 45:23.140]  Это такой жизненный принцип.
[45:28.140 --> 45:30.140]  Допустим, вы говорите,
[45:30.140 --> 45:32.140]  я сейчас реализую супер-пупер-мега-систему,
[45:32.140 --> 45:35.140]  потом понимаете, так, это не надо, это не надо, это не надо.
[45:35.140 --> 45:37.140]  То есть вы очищаете все шелухи.
[45:39.140 --> 45:41.140]  Следующий принцип,
[45:41.140 --> 45:43.140]  который позволяет нам это все сделать,
[45:43.140 --> 45:45.140]  это метод кейс.
[45:46.140 --> 45:48.140]  Это keep it simple-stupid.
[45:48.140 --> 45:52.140]  То есть старайтесь сделать все максимально тупо,
[45:52.140 --> 45:54.140]  в первую очередь.
[45:56.140 --> 45:58.140]  Начинайте придумывать,
[45:58.140 --> 46:00.140]  и потом начинайте вычислить.
[46:01.140 --> 46:03.140]  Начинайте придумывать,
[46:03.140 --> 46:05.140]  и потом оказывается следующее.
[46:07.140 --> 46:09.140]  Здесь изображен,
[46:09.140 --> 46:11.140]  мне не надо бежать впереди перевоза.
[46:12.140 --> 46:14.140]  То есть сначала нужно остановиться,
[46:14.140 --> 46:16.140]  попытаться выделить какие-то простые сущности
[46:16.140 --> 46:18.140]  и начать реализовывать ее.
[46:18.140 --> 46:20.140]  Здесь важен фазовый переход.
[46:20.140 --> 46:22.140]  Обычно, когда мы что-то придумываем новое,
[46:22.140 --> 46:24.140]  есть обычно несколько фазовых переходов.
[46:24.140 --> 46:28.140]  Первый фазовый переход от нуля к единице.
[46:29.140 --> 46:31.140]  То есть у вас ничего нету,
[46:31.140 --> 46:33.140]  а потом вы делаете переход к тому,
[46:33.140 --> 46:35.140]  что у вас что-то есть.
[46:35.140 --> 46:37.140]  Как вы думаете, какой второй фазовый переход?
[46:40.140 --> 46:42.140]  От единицы к двойке?
[46:44.140 --> 46:46.140]  Нет, ну на самом деле от двойки до ста
[46:46.140 --> 46:48.140]  бежать намного быстрее,
[46:48.140 --> 46:50.140]  чем от единицы до двойки.
[46:50.140 --> 46:52.140]  Как ни странно, потому что вы придумываете масштабирование.
[46:52.140 --> 46:54.140]  На самом деле, если кто-то
[46:54.140 --> 46:56.140]  уже решал математические задачи,
[46:56.140 --> 46:58.140]  там бывает тоже такой кейс,
[46:58.140 --> 47:00.140]  что для n равно 1 очевидно,
[47:00.140 --> 47:02.140]  для n равно 2 какой-то простой пример,
[47:02.140 --> 47:04.140]  а потом оказывается вся идея
[47:04.140 --> 47:06.140]  раскрывается в том момент времени,
[47:06.140 --> 47:08.140]  когда вы переходите от n равно двойки
[47:08.140 --> 47:10.140]  к n равно тройки.
[47:10.140 --> 47:12.140]  Возможно, сталкивались,
[47:12.140 --> 47:14.140]  если решали какие-то телепиадные задачи по математике.
[47:14.140 --> 47:16.140]  Поэтому давайте это зафиксируем,
[47:16.140 --> 47:18.140]  что для того, чтобы перейти
[47:18.140 --> 47:20.140]  от 0 к единице,
[47:20.140 --> 47:22.140]  нужно делать все максимально просто,
[47:22.140 --> 47:24.140]  потому что, скорее всего, от вас
[47:24.140 --> 47:26.140]  очень быстро запросят новый прототип.
[47:26.140 --> 47:28.140]  А потом вы только займетесь
[47:28.140 --> 47:30.140]  масштабированием и внедрением
[47:30.140 --> 47:32.140]  всяких технологий.
[47:34.140 --> 47:36.140]  То есть это важнее.
[47:36.140 --> 47:38.140]  То есть вы не можете
[47:38.140 --> 47:40.140]  перейти от 0 к единицы,
[47:40.140 --> 47:42.140]  а вы можете перейти
[47:42.140 --> 47:44.140]  от 0 к единицы.
[47:44.140 --> 47:46.140]  То есть стараемся очищать
[47:46.140 --> 47:48.140]  все лишнее.
[47:48.140 --> 47:50.140]  Смотрите, ягни
[47:50.140 --> 47:52.140]  нам помогают оставить
[47:52.140 --> 47:54.140]  только то,
[47:54.140 --> 47:56.140]  что необходимо,
[47:56.140 --> 47:58.140]  чтобы вообще начать реализовывать
[47:58.140 --> 48:00.140]  единичку, чтобы не заглохнуть в этом.
[48:00.140 --> 48:02.140]  А кис
[48:02.140 --> 48:04.140]  позволяет как раз сделать переход
[48:04.140 --> 48:06.140]  от 0 к единицы.
[48:06.140 --> 48:08.140]  И следующая вещь
[48:08.140 --> 48:10.140]  это драй.
[48:10.140 --> 48:12.140]  Это мы больше
[48:12.140 --> 48:14.140]  уже говорим про
[48:14.140 --> 48:16.140]  переход от 1 к 2
[48:16.140 --> 48:18.140]  или про другие
[48:18.140 --> 48:20.140]  интересные вещи.
[48:20.140 --> 48:22.140]  Ну, собственно,
[48:22.140 --> 48:24.140]  не копипастим, если
[48:24.140 --> 48:26.140]  грубо говорить.
[48:26.140 --> 48:28.140]  Метод называется Do not repeat yourself.
[48:28.140 --> 48:30.140]  Тут как раз Барт
[48:30.140 --> 48:32.140]  Симпсон, который пытается написать
[48:32.140 --> 48:34.140]  текст 500 раз.
[48:34.140 --> 48:36.140]  В любой заставке Симпсонов
[48:36.140 --> 48:38.140]  можно увидеть.
[48:38.140 --> 48:40.140]  Стараемся не дублировать код.
[48:40.140 --> 48:42.140]  Максимально
[48:42.140 --> 48:44.140]  и четко.
[48:44.140 --> 48:46.140]  Точнее, максимально
[48:46.140 --> 48:48.140]  в многих местах, потому что, смотрите,
[48:48.140 --> 48:50.140]  что у нас получается?
[48:50.140 --> 48:52.140]  Если мы начинаем сильно дублировать код,
[48:52.140 --> 48:54.140]  то у нас сильно растет каплинг.
[48:54.140 --> 48:56.140]  Причем, самый худший
[48:56.140 --> 48:58.140]  уровень каплинга, который существует.
[48:58.140 --> 49:00.140]  Вы не поверите, есть
[49:00.140 --> 49:02.140]  противоположный этому принципу
[49:02.140 --> 49:04.140]  принцип.
[49:04.140 --> 49:06.140]  Кто знает Антоним слово
[49:06.140 --> 49:08.140]  WET?
[49:08.140 --> 49:10.140]  Есть принцип WET.
[49:12.140 --> 49:14.140]  Расшифровывается он как
[49:14.140 --> 49:16.140]  write everything twice.
[49:18.140 --> 49:20.140]  И, знаете, шутки
[49:20.140 --> 49:22.140]  шутками, но если
[49:22.140 --> 49:24.140]  мы говорим про
[49:24.140 --> 49:26.140]  разработку систем, он обычно не
[49:26.140 --> 49:28.140]  подходит. Но как только мы идем
[49:28.140 --> 49:30.140]  в работу высоконагруженных
[49:30.140 --> 49:32.140]  баз данных,
[49:32.140 --> 49:34.140]  там как раз начинает
[49:34.140 --> 49:36.140]  работать принцип WET. Он называется
[49:36.140 --> 49:38.140]  принципом денормализации и
[49:38.140 --> 49:40.140]  дублирования данных.
[49:40.140 --> 49:42.140]  Потому что система начинает просто работать
[49:42.140 --> 49:44.140]  быстрее.
[49:44.140 --> 49:46.140]  Но про это вам расскажут детали,
[49:46.140 --> 49:48.140]  наверное, на курсе баз данных или, если вас
[49:48.140 --> 49:50.140]  это заинтересует, немного поговорим
[49:50.140 --> 49:52.140]  про нормальные формы здесь.
[49:52.140 --> 49:54.140]  Так, это принцип
[49:54.140 --> 49:56.140]  dry. Теперь, смотрите, чтобы вы понимали,
[49:56.140 --> 49:58.140]  в каком порядке они применяются.
[49:58.140 --> 50:00.140]  Первый, применяются
[50:00.140 --> 50:02.140]  ягни, то есть мы отфильтровываем лишнюю
[50:02.140 --> 50:04.140]  шелуху. То есть здесь мы видим, что у нас
[50:04.140 --> 50:06.140]  шифровывается желтая фигурка,
[50:08.140 --> 50:10.140]  цилиндрик и так далее.
[50:10.140 --> 50:12.140]  Дальше мы
[50:12.140 --> 50:14.140]  вот у нас есть какие-то сложные
[50:14.140 --> 50:16.140]  абстракции. Мы делаем их максимально
[50:16.140 --> 50:18.140]  простыми, чтобы клиент сразу
[50:18.140 --> 50:20.140]  получил хоть какую-то версию продукта.
[50:20.140 --> 50:22.140]  Потому что, собственно, продукт это
[50:22.140 --> 50:24.140]  деньги, деньги это время.
[50:24.140 --> 50:26.140]  Наоборот.
[50:26.140 --> 50:28.140]  Время это
[50:28.140 --> 50:30.140]  деньги. Продукт это
[50:30.140 --> 50:32.140]  время, время это деньги. Вот так вот.
[50:32.140 --> 50:34.140]  Вот. А после этого мы с вами
[50:34.140 --> 50:36.140]  уже начинаем группировать объекты,
[50:36.140 --> 50:38.140]  для того, чтобы они не дублировались и для того, чтобы мы
[50:38.140 --> 50:40.140]  могли поддерживать систему для
[50:40.140 --> 50:42.140]  дальнейших фазовых переходов.
[50:44.140 --> 50:46.140]  Так.
[50:46.140 --> 50:48.140]  Понятны ли эти принципы?
[50:48.140 --> 50:50.140]  Хорошо. Вопрос на понимание. Как вы думаете,
[50:50.140 --> 50:52.140]  где в этой цепи солят будет находиться?
[50:54.140 --> 50:56.140]  Где-то там еще...
[50:56.140 --> 50:58.140]  Да, правее. Правее dry обычно
[50:58.140 --> 51:00.140]  находится солят.
[51:00.140 --> 51:02.140]  Я где-то пирамиду
[51:02.140 --> 51:04.140]  видел. Мне надо будет ее, видимо, в чат
[51:04.140 --> 51:06.140]  прислать. Я пришлю в
[51:06.140 --> 51:08.140]  тему вопросов по лекционным материалам.
[51:08.140 --> 51:10.140]  Типа, из чего эта вся пирамида стоит?
[51:10.140 --> 51:12.140]  Ну, ягнитом на самом первом месте находится.
[51:12.140 --> 51:14.140]  Так. Давайте двигаться дальше,
[51:14.140 --> 51:16.140]  если вы не против. Теперь давайте
[51:16.140 --> 51:18.140]  немного мы отклонимся в сторону,
[51:18.140 --> 51:20.140]  для того, чтобы мы дальше
[51:20.140 --> 51:22.140]  все понимали общий язык.
[51:22.140 --> 51:24.140]  Мы будем с вами говорить про язык Unified
[51:24.140 --> 51:26.140]  Moduling Language, UML.
[51:26.140 --> 51:28.140]  И, собственно, здесь, как ни странно,
[51:28.140 --> 51:30.140]  мы видим, что я уже
[51:30.140 --> 51:32.140]  все классы писал не при помощи
[51:32.140 --> 51:34.140]  кода, а при помощи вот таких вот диаграмм.
[51:34.140 --> 51:36.140]  И давайте
[51:36.140 --> 51:38.140]  как раз научимся механизмом использования
[51:38.140 --> 51:40.140]  этих диаграмм. В следующий раз
[51:40.140 --> 51:42.140]  мы будем рассматривать более детально
[51:42.140 --> 51:44.140]  эти диаграммы. Они как раз будут полезны
[51:44.140 --> 51:46.140]  для того, чтобы спроектировать первую
[51:46.140 --> 51:48.140]  итерацию вашего проекта.
[51:48.140 --> 51:50.140]  Давайте введем
[51:50.140 --> 51:52.140]  нотацию, которая будет полезна
[51:52.140 --> 51:54.140]  далее. Сразу говорю, что
[51:54.140 --> 51:56.140]  обычно люди в 90...
[51:56.140 --> 51:58.140]  Эта вся история возникла в 90-х годах,
[51:58.140 --> 52:00.140]  и люди думали, что при помощи всех этих
[52:00.140 --> 52:02.140]  диаграмм можно спроектировать весь код.
[52:02.140 --> 52:04.140]  То есть, если сейчас
[52:04.140 --> 52:06.140]  код пишется посредством чата ГПТ,
[52:08.140 --> 52:10.140]  люди пытаются писать. Правда,
[52:10.140 --> 52:12.140]  скоро скажу, чат ГПТ иногда фигню дает.
[52:12.140 --> 52:14.140]  Причем очень жесткую
[52:14.140 --> 52:16.140]  фигню. То есть оно кажется...
[52:16.140 --> 52:18.140]  Знаете, читаете,
[52:18.140 --> 52:20.140]  оно пишет, пишет, пишет,
[52:20.140 --> 52:22.140]  а потом вы понимаете, что оно фигню
[52:22.140 --> 52:24.140]  всякую написало.
[52:24.140 --> 52:26.140]  То есть, которая даже может быть
[52:26.140 --> 52:28.140]  визуальные тесты проходят, но потом
[52:28.140 --> 52:30.140]  по существу оно делает не то,
[52:30.140 --> 52:32.140]  что надо. Поэтому с этой штукой будьте
[52:32.140 --> 52:34.140]  аккуратнее.
[52:34.140 --> 52:36.140]  То в 90-х годах думали
[52:36.140 --> 52:38.140]  все намного проще. Давайте мы нарисуем
[52:38.140 --> 52:40.140]  диаграммы, а по диаграммам сгенерируем код.
[52:40.140 --> 52:42.140]  То есть наладим четкие связи,
[52:42.140 --> 52:44.140]  и дальше у нас
[52:44.140 --> 52:46.140]  появится код. Это
[52:46.140 --> 52:48.140]  далеко не зашло, но для проектирования
[52:48.140 --> 52:50.140]  архитектуры это достаточно важно.
[52:50.140 --> 52:52.140]  И в текущий момент времени.
[52:52.140 --> 52:54.140]  Поэтому давайте знакомиться.
[52:54.140 --> 52:56.140]  Представим себе, что у нас есть
[52:56.140 --> 52:58.140]  template class.
[52:58.140 --> 53:00.140]  Классы обозначены синим цветом. Кстати, мне
[53:00.140 --> 53:02.140]  надо цветовую гамму будет поменять.
[53:02.140 --> 53:04.140]  И у него здесь есть
[53:04.140 --> 53:06.140]  следующее. У конструктора класса
[53:06.140 --> 53:08.140]  есть модификаторы
[53:08.140 --> 53:10.140]  доступа, во-первых.
[53:10.140 --> 53:12.140]  Сверху написано поля,
[53:12.140 --> 53:14.140]  снизу написаны методы.
[53:14.140 --> 53:16.140]  Мы видим, что здесь
[53:16.140 --> 53:18.140]  есть конструктор класса, template class.
[53:18.140 --> 53:20.140]  Дальше у нас есть методы. Они
[53:20.140 --> 53:22.140]  могут быть публичные и приватные.
[53:22.140 --> 53:24.140]  И поля тоже могут быть
[53:24.140 --> 53:26.140]  публичные и приватные. Вот эта штука
[53:26.140 --> 53:28.140]  это комментарий.
[53:28.140 --> 53:30.140]  Таким образом обозначаются комментарии
[53:30.140 --> 53:32.140]  в этой диаграмме.
[53:32.140 --> 53:34.140]  И здесь есть важный момент. Здесь есть
[53:34.140 --> 53:36.140]  подчеркнутый метод.
[53:36.140 --> 53:38.140]  Это означает статический метод.
[53:38.140 --> 53:40.140]  Кто слышал понятие
[53:40.140 --> 53:42.140]  статический метод?
[53:44.140 --> 53:46.140]  Отлично.
[53:46.140 --> 53:48.140]  Давайте еще раз
[53:48.140 --> 53:50.140]  поясним, что такое статический метод.
[53:50.140 --> 53:52.140]  Это метод, который можно вызвать
[53:52.140 --> 53:54.140]  без наличия экземпляра класса.
[53:56.140 --> 53:58.140]  Таким образом выглядит класс.
[53:58.140 --> 54:00.140]  При этом между классом
[54:00.140 --> 54:02.140]  могут быть разные типы взаимодействия.
[54:02.140 --> 54:04.140]  В UML выделяют
[54:04.140 --> 54:06.140]  три типа. В связи
[54:06.140 --> 54:08.140]  первая композиция.
[54:08.140 --> 54:10.140]  Давайте расскажу, каким образом это читать.
[54:10.140 --> 54:12.140]  Это читается
[54:12.140 --> 54:14.140]  следующим образом. У машины
[54:14.140 --> 54:16.140]  есть четыре колеса.
[54:16.140 --> 54:18.140]  Одна машина, если здесь не указано,
[54:18.140 --> 54:20.140]  это означает, что здесь единичка.
[54:20.140 --> 54:22.140]  Здесь указывается модификатор кратности.
[54:22.140 --> 54:24.140]  У машины четыре колеса.
[54:24.140 --> 54:26.140]  Причем важный момент. Здесь, видите,
[54:26.140 --> 54:28.140]  у нас есть вот этот закрашенный ромбик.
[54:30.140 --> 54:32.140]  Это означает следующая.
[54:32.140 --> 54:34.140]  Это означает две вещи. Во-первых,
[54:34.140 --> 54:36.140]  колесо это часть машины.
[54:38.140 --> 54:40.140]  И без понятия колеса
[54:40.140 --> 54:42.140]  понятие машины так или иначе
[54:42.140 --> 54:44.140]  существовать не может. Почему?
[54:46.140 --> 54:48.140]  Почему без понятия колеса
[54:48.140 --> 54:50.140]  машина не может существовать?
[54:52.140 --> 54:54.140]  Ну, какая цель и главная машина?
[54:54.140 --> 54:56.140]  Ездить.
[54:56.140 --> 54:58.140]  Вот.
[54:58.140 --> 55:00.140]  А машина может ездить без колес?
[55:00.140 --> 55:02.140]  Во принцетонах ездила.
[55:02.140 --> 55:04.140]  Ну, во принцетонах ездила,
[55:04.140 --> 55:06.140]  но зачастую нет. То есть
[55:06.140 --> 55:08.140]  как бы это получается непосредственно
[55:08.140 --> 55:10.140]  и важная часть
[55:10.140 --> 55:12.140]  общего, единого целого.
[55:16.140 --> 55:18.140]  Так, сейчас давайте вспомним.
[55:20.140 --> 55:22.140]  Ну, да, наоборот, скорее
[55:22.140 --> 55:24.140]  всего. Сейчас.
[55:26.140 --> 55:28.140]  Наоборот неправда.
[55:28.140 --> 55:30.140]  Значит у меня багов в презентации.
[55:34.140 --> 55:36.140]  Это объект, который позволяет
[55:36.140 --> 55:38.140]  осуществлять какое-то вращение.
[55:38.140 --> 55:40.140]  То есть оно может вращаться,
[55:40.140 --> 55:42.140]  но при этом колесо
[55:44.140 --> 55:46.140]  получается колесо
[55:46.140 --> 55:48.140]  непосредственная часть машины.
[55:50.140 --> 55:52.140]  Поэтому обычно не запариваются,
[55:52.140 --> 55:54.140]  потому что вот эти вот
[55:54.140 --> 55:56.140]  тонкие связи как раз на человеческом уровне
[55:56.140 --> 55:58.140]  сложно разделить.
[55:58.140 --> 56:00.140]  То есть мы можем считать, что
[56:00.140 --> 56:02.140]  машина без колес не поедет.
[56:08.140 --> 56:10.140]  При этом колесо часть машины.
[56:10.140 --> 56:12.140]  Сейчас давайте подумаем.
[56:12.140 --> 56:14.140]  Как-то бы аккуратнее сделать.
[56:18.140 --> 56:20.140]  Ну да, да, смотрите.
[56:20.140 --> 56:22.140]  При создании объекта машины
[56:22.140 --> 56:24.140]  вот это хорошее замечание
[56:24.140 --> 56:26.140]  должно создаться в нем список
[56:26.140 --> 56:28.140]  из четырех колес. Прямо при его
[56:28.140 --> 56:30.140]  создании.
[56:30.140 --> 56:32.140]  После вызова конструктора.
[56:32.140 --> 56:34.140]  Можно просто для камеры вот
[56:34.140 --> 56:36.140]  спросить, это может быть список
[56:36.140 --> 56:38.140]  из четырех или что?
[56:38.140 --> 56:40.140]  Нет, это здесь уже идет
[56:40.140 --> 56:42.140]  реализация на уровне кода. То есть вы можете
[56:42.140 --> 56:44.140]  как раз написать, что у вас
[56:44.140 --> 56:46.140]  по факту в машине
[56:46.140 --> 56:48.140]  будет список из четырех колес.
[56:48.140 --> 56:50.140]  Как таким-то образом
[56:50.140 --> 56:52.140]  в классе машины будет храниться
[56:52.140 --> 56:54.140]  четыре объекта класса колеса?
[56:54.140 --> 56:56.140]  Да, каким образом?
[56:56.140 --> 56:58.140]  Если у нас объект класса машины
[56:58.140 --> 57:00.140]  в класс машины как-то зависит от класса колеса,
[57:00.140 --> 57:02.140]  зачем нам вот этот вот ромбик?
[57:02.140 --> 57:04.140]  Если и так очевидно, что
[57:04.140 --> 57:06.140]  у нас, чтобы
[57:06.140 --> 57:08.140]  существовал класс машины, просто
[57:08.140 --> 57:10.140]  обязательно нужно понимать, что такое
[57:10.140 --> 57:12.140]  колесо, потому что в машине задействовано колесо.
[57:12.140 --> 57:14.140]  Разве это не изучная
[57:14.140 --> 57:16.140]  информация?
[57:16.140 --> 57:18.140]  Смотрите, здесь как раз если мы
[57:18.140 --> 57:20.140]  говорим про композицию,
[57:20.140 --> 57:22.140]  то по факту это же дело
[57:22.140 --> 57:24.140]  все для автоматической валидации.
[57:24.140 --> 57:26.140]  То есть на этапе валидации, как раз
[57:26.140 --> 57:28.140]  если мы...
[57:28.140 --> 57:30.140]  А?
[57:30.140 --> 57:32.140]  Ну на этапе, когда мы начнем запускать
[57:32.140 --> 57:34.140]  этот код, проверять нашу диаграмму,
[57:34.140 --> 57:36.140]  там вызовем каким-то образом
[57:36.140 --> 57:38.140]  конструктор класса машины, и в нем не
[57:38.140 --> 57:40.140]  окажется четыре колеса.
[57:40.140 --> 57:42.140]  Да, все. Это означает,
[57:42.140 --> 57:44.140]  что проверка не прошла
[57:44.140 --> 57:46.140]  и, собственно, диаграмма неверная.
[57:48.140 --> 57:50.140]  Вот что это означает.
[57:50.140 --> 57:52.140]  То есть раньше затачились
[57:52.140 --> 57:54.140]  под то, чтобы эта диаграмма работала.
[57:54.140 --> 57:56.140]  И по ней можно было генерировать
[57:56.140 --> 57:58.140]  работающий код.
[57:58.140 --> 58:00.140]  То есть если бы, смотрите,
[58:00.140 --> 58:02.140]  здесь бы ромбик был не такой, а
[58:02.140 --> 58:04.140]  не закрашенный, то в принципе
[58:04.140 --> 58:06.140]  мы могли бы сделать следующее. Создать класс
[58:06.140 --> 58:08.140]  машины, а после этого в какой-то момент времени
[58:08.140 --> 58:10.140]  в будущем добавить в нее четыре колеса.
[58:10.140 --> 58:12.140]  Сейчас, нет, у нас уже в машине
[58:12.140 --> 58:14.140]  описано, что у нее есть колесо. Разве это в описании
[58:14.140 --> 58:16.140]  не достаточно? А, вот про вот это
[58:16.140 --> 58:18.140]  колесо? А, да, это излишнее
[58:18.140 --> 58:20.140]  описание. То есть в данном случае ромбик
[58:20.140 --> 58:22.140]  это излишнее описание?
[58:22.140 --> 58:24.140]  Нет, вот это вот излишнее описание.
[58:24.140 --> 58:26.140]  Вот это, то есть его можно убрать.
[58:26.140 --> 58:28.140]  То есть ромбик означает, что
[58:28.140 --> 58:30.140]  в чем-то есть... Да, что-то другое, да.
[58:32.140 --> 58:34.140]  Все.
[58:34.140 --> 58:36.140]  А можно в описании
[58:36.140 --> 58:38.140]  не указывать поле вилл
[58:38.140 --> 58:40.140]  класса вилл, потому что оно из диаграммы
[58:40.140 --> 58:42.140]  подтягивается.
[58:42.140 --> 58:44.140]  Вот, причем смотрите,
[58:44.140 --> 58:46.140]  поле, которое указывается, оно указывается
[58:46.140 --> 58:48.140]  прямо с классом вилл.
[58:48.140 --> 58:50.140]  Типа получается, как
[58:50.140 --> 58:52.140]  это читать? У класса машины
[58:52.140 --> 58:54.140]  есть четыре экземпляра класса
[58:54.140 --> 58:56.140]  колеса, в котором можно
[58:56.140 --> 58:58.140]  обратиться по полю вилл.
[58:58.140 --> 59:00.140]  Вот такая же ромбик, это
[59:00.140 --> 59:02.140]  именно является...
[59:02.140 --> 59:04.140]  Как обязательный объект.
[59:04.140 --> 59:06.140]  Содержится как объект.
[59:06.140 --> 59:08.140]  Как обязательный объект.
[59:08.140 --> 59:10.140]  Потому что есть и содержится как необязательный объект.
[59:12.140 --> 59:14.140]  Вот, это агрегация.
[59:14.140 --> 59:16.140]  Да.
[59:16.140 --> 59:18.140]  Собственно...
[59:18.140 --> 59:20.140]  Такой
[59:20.140 --> 59:22.140]  интересный пример.
[59:22.140 --> 59:24.140]  Собственно, класс состоит из
[59:24.140 --> 59:26.140]  студентов, но при этом
[59:26.140 --> 59:28.140]  студент, в принципе, может
[59:28.140 --> 59:30.140]  существовать помимо класса,
[59:30.140 --> 59:32.140]  он может присоединиться к какому-то
[59:32.140 --> 59:34.140]  другому классу.
[59:34.140 --> 59:36.140]  Либо вообще сделать индивидуальный учебный
[59:36.140 --> 59:38.140]  план и ходить на занятия с кем угодно.
[59:40.140 --> 59:42.140]  Вот, а та... А?
[59:42.140 --> 59:44.140]  Просто тут я вижу
[59:44.140 --> 59:46.140]  проявляться с предыдущей подписью.
[59:46.140 --> 59:48.140]  Да.
[59:48.140 --> 59:50.140]  Существование правой, штуки без лев.
[59:50.140 --> 59:52.140]  А в предыдущей подпись мы решили,
[59:52.140 --> 59:54.140]  что там не то должно быть.
[59:54.140 --> 59:56.140]  А, блин, черт.
[59:56.140 --> 59:58.140]  Может быть, все-таки там было описано то, что мы хотели?
[59:58.140 --> 01:00:00.140]  Наверное, да.
[01:00:00.140 --> 01:00:02.140]  Э...
[01:00:02.140 --> 01:00:04.140]  Сейчас, секунду.
[01:00:04.140 --> 01:00:06.140]  Наверное, да.
[01:00:08.140 --> 01:00:10.140]  Тупню, туплю.
[01:00:10.140 --> 01:00:12.140]  Да, давайте разбираться.
[01:00:14.140 --> 01:00:16.140]  Скорее всего...
[01:00:18.140 --> 01:00:20.140]  Сейчас.
[01:00:22.140 --> 01:00:24.140]  Ну, тогда и пример с колесом
[01:00:24.140 --> 01:00:26.140]  не очень хороший, потому что колесо
[01:00:26.140 --> 01:00:28.140]  может существовать само по себе.
[01:00:28.140 --> 01:00:30.140]  Хорошо.
[01:00:30.140 --> 01:00:32.140]  Ну, например, какой-то такой руль пойдет?
[01:00:32.140 --> 01:00:34.140]  Руль пойдет.
[01:00:34.140 --> 01:00:36.140]  Ну, чем
[01:00:36.140 --> 01:00:38.140]  тогда он управлять будет?
[01:00:38.140 --> 01:00:40.140]  Ну, чем тогда он управлять будет?
[01:00:40.140 --> 01:00:42.140]  То есть, руль это обычное устройство управления,
[01:00:42.140 --> 01:00:44.140]  к чему-то привязанное.
[01:00:44.140 --> 01:00:46.140]  Ну, тогда это делается
[01:00:46.140 --> 01:00:48.140]  через наследование.
[01:00:48.140 --> 01:00:50.140]  То есть, у нас есть базовый класс вида руль,
[01:00:50.140 --> 01:00:52.140]  который присоединяется к классу вида
[01:00:52.140 --> 01:00:54.140]  устройства движения,
[01:00:54.140 --> 01:00:56.140]  и тогда это будет композиция.
[01:00:58.140 --> 01:01:00.140]  Вообще, смотрите.
[01:01:00.140 --> 01:01:02.140]  Тут можно четко не
[01:01:02.140 --> 01:01:04.140]  разграничивать роли.
[01:01:04.140 --> 01:01:06.140]  Опять же, это чисто вот нотация EML.
[01:01:06.140 --> 01:01:08.140]  Она вот явно показывается.
[01:01:08.140 --> 01:01:10.140]  То есть, можно не разграничивать роли,
[01:01:10.140 --> 01:01:12.140]  а можно не разграничивать роли,
[01:01:12.140 --> 01:01:14.140]  но она вот явно показывается.
[01:01:14.140 --> 01:01:16.140]  То есть, вы можете рисовать ромбики,
[01:01:16.140 --> 01:01:18.140]  и, в принципе, этого будет достаточно.
[01:01:18.140 --> 01:01:20.140]  Главное, чтобы вы понимали, каким образом связи работают,
[01:01:20.140 --> 01:01:22.140]  что одно содержит другое.
[01:01:22.140 --> 01:01:24.140]  Вот. И для наших целей этого будет достаточно.
[01:01:24.140 --> 01:01:26.140]  Мы тут не пришли для того,
[01:01:26.140 --> 01:01:28.140]  чтобы EML изучать.
[01:01:28.140 --> 01:01:30.140]  Потому что, а для того, чтобы изучить EML,
[01:01:30.140 --> 01:01:32.140]  нужно отдельный семестровый курс,
[01:01:32.140 --> 01:01:34.140]  который неприятный при чем.
[01:01:34.140 --> 01:01:36.140]  Зачастую.
[01:01:36.140 --> 01:01:38.140]  Визитивский закрашенный ромбик
[01:01:38.140 --> 01:01:40.140]  обозначает то, что это теперь является
[01:01:41.140 --> 01:01:43.140]  Ну, можно считать, да.
[01:01:48.140 --> 01:01:50.140]  Да, да, да.
[01:01:50.140 --> 01:01:52.140]  Да, да.
[01:01:52.140 --> 01:01:54.140]  Вот.
[01:01:54.140 --> 01:01:56.140]  А здесь студент может входить
[01:01:56.140 --> 01:01:58.140]  посредственно в другие классы,
[01:01:58.140 --> 01:02:00.140]  и ничто это ему не мешает.
[01:02:00.140 --> 01:02:02.140]  Вот. Есть обычное
[01:02:02.140 --> 01:02:04.140]  соединение, связь, ассоциация.
[01:02:04.140 --> 01:02:06.140]  То есть, это когда у нас один объект
[01:02:06.140 --> 01:02:08.140]  использует другой объект, но при этом
[01:02:08.140 --> 01:02:10.140]  он является частью другого.
[01:02:10.140 --> 01:02:12.140]  То есть, это обычные поля, которые
[01:02:12.140 --> 01:02:14.140]  не специфицируются никаким образом.
[01:02:14.140 --> 01:02:16.140]  То есть, у нас же может быть,
[01:02:16.140 --> 01:02:18.140]  что у нас у класса
[01:02:18.140 --> 01:02:20.140]  хранится какое-то другое поле, при этом,
[01:02:20.140 --> 01:02:22.140]  которое не является его составной частью.
[01:02:22.140 --> 01:02:24.140]  Ну, в принципе, да.
[01:02:24.140 --> 01:02:26.140]  Такие связи обозначаются
[01:02:26.140 --> 01:02:28.140]  ассоциацией. То есть, это просто
[01:02:28.140 --> 01:02:30.140]  связь без специальных
[01:02:30.140 --> 01:02:32.140]  концов.
[01:02:32.140 --> 01:02:34.140]  Значит, следующая вещь, это
[01:02:34.140 --> 01:02:36.140]  интерфейс. Мы про него уже
[01:02:36.140 --> 01:02:38.140]  рассказали, что интерфейс у нас
[01:02:38.140 --> 01:02:40.140]  исполняет роли, у него есть только методы,
[01:02:40.140 --> 01:02:42.140]  и не может быть полей и реализации.
[01:02:42.140 --> 01:02:44.140]  Здесь мы видим, что
[01:02:44.140 --> 01:02:46.140]  у него обычно есть
[01:02:46.140 --> 01:02:48.140]  только методы. То есть, видите, нет разделения
[01:02:48.140 --> 01:02:50.140]  на полей и класса.
[01:02:50.140 --> 01:02:52.140]  Ой, на полей и
[01:02:52.140 --> 01:02:54.140]  методы. Вот. При этом
[01:02:54.140 --> 01:02:56.140]  класс треугольник может имплементировать
[01:02:56.140 --> 01:02:58.140]  интерфейс фигуры, и
[01:02:58.140 --> 01:03:00.140]  класс circle имеет
[01:03:00.140 --> 01:03:02.140]  имплементацию в виде
[01:03:02.140 --> 01:03:04.140]  класса shape.
[01:03:04.140 --> 01:03:06.140]  То есть, у них у всех есть площадь.
[01:03:06.140 --> 01:03:08.140]  То есть, по-хорошему говоря, если мы хотим
[01:03:08.140 --> 01:03:10.140]  соблюдать принцип Барбар Лисков,
[01:03:10.140 --> 01:03:12.140]  то его можно решать
[01:03:12.140 --> 01:03:14.140]  при помощи наличия интерфейсов.
[01:03:14.140 --> 01:03:16.140]  То есть, мы делаем интерфейс отдельной круга,
[01:03:16.140 --> 01:03:18.140]  отдельный интерфейс для эллипса.
[01:03:18.140 --> 01:03:20.140]  Да, тем более это важно, потому что
[01:03:20.140 --> 01:03:22.140]  у эллипса, так или иначе, обычно
[01:03:22.140 --> 01:03:24.140]  есть специфичные поля, такие как
[01:03:24.140 --> 01:03:26.140]  эксцентритет, большая и малая
[01:03:26.140 --> 01:03:28.140]  полуось и так далее.
[01:03:28.140 --> 01:03:30.140]  Вы же знакомы с
[01:03:30.140 --> 01:03:32.140]  атрибутами эллипсов?
[01:03:32.140 --> 01:03:34.140]  По-моему, на линейной алгебре должно
[01:03:34.140 --> 01:03:36.140]  было проходить.
[01:03:38.140 --> 01:03:40.140]  Ну, хорошо.
[01:03:40.140 --> 01:03:42.140]  То есть, интерфейсы обозначаются
[01:03:42.140 --> 01:03:44.140]  вот таким, обычно, методом,
[01:03:44.140 --> 01:03:46.140]  способом интерфейс. Причем, есть
[01:03:46.140 --> 01:03:48.140]  программы, которые
[01:03:48.140 --> 01:03:50.140]  умеют рисовать такие диаграммы.
[01:03:50.140 --> 01:03:52.140]  И реализация интерфейсов
[01:03:52.140 --> 01:03:54.140]  важно, что она обозначается пунктирной
[01:03:54.140 --> 01:03:56.140]  стрелочкой.
[01:03:56.140 --> 01:03:58.140]  В отличии от наследования.
[01:03:58.140 --> 01:04:00.140]  В наследовании используется
[01:04:00.140 --> 01:04:02.140]  прямая стрелочка
[01:04:02.140 --> 01:04:04.140]  с треугольничком.
[01:04:04.140 --> 01:04:06.140]  То есть, у нас здесь есть животное,
[01:04:06.140 --> 01:04:08.140]  animal. У него есть абстрактные методы,
[01:04:08.140 --> 01:04:10.140]  moveTo.
[01:04:10.140 --> 01:04:12.140]  Они обычно обозначаются курсивом.
[01:04:12.140 --> 01:04:14.140]  И абстрактные классы тоже обозначаются
[01:04:14.140 --> 01:04:16.140]  курсивом. То есть, у нас есть животное,
[01:04:16.140 --> 01:04:18.140]  у него есть наследники класса
[01:04:18.140 --> 01:04:20.140]  млекопитающий и птица,
[01:04:20.140 --> 01:04:22.140]  а у класса млекопитающий есть
[01:04:22.140 --> 01:04:24.140]  наследники
[01:04:24.140 --> 01:04:26.140]  вида кот
[01:04:26.140 --> 01:04:28.140]  и пёс. Один говорит мяу,
[01:04:28.140 --> 01:04:30.140]  другой говорит гав
[01:04:30.140 --> 01:04:32.140]  на реализацию метода сей.
[01:04:32.140 --> 01:04:34.140]  Так, это понятно?
[01:04:34.140 --> 01:04:36.140]  Угу.
[01:04:36.140 --> 01:04:38.140]  Хорошо. Вот, наконец-таки мы с вами
[01:04:38.140 --> 01:04:40.140]  разобрались с диаграммами.
[01:04:40.140 --> 01:04:42.140]  И давайте, наконец-таки, начнём
[01:04:42.140 --> 01:04:44.140]  мы с вами разбираться с
[01:04:44.140 --> 01:04:46.140]  достаточно важной вещью. Это паттерны
[01:04:46.140 --> 01:04:48.140]  проектирования. То есть, пока мы с вами
[01:04:48.140 --> 01:04:50.140]  говорили про какие-то эфемерные принципы,
[01:04:50.140 --> 01:04:52.140]  а теперь давайте поговорим
[01:04:52.140 --> 01:04:54.140]  про принципы, которые имеют чёткое
[01:04:54.140 --> 01:04:56.140]  решение в виде кода.
[01:04:56.140 --> 01:04:58.140]  Вот. И, как ни странно, некоторые
[01:04:58.140 --> 01:05:00.140]  принципы уже позволяют нам реализовать
[01:05:00.140 --> 01:05:02.140]  определённые паттерны.
[01:05:02.140 --> 01:05:04.140]  Значит, давайте поймём, что такое паттерны
[01:05:04.140 --> 01:05:06.140]  проектирования. А это
[01:05:06.140 --> 01:05:08.140]  некоторые принципы, которые
[01:05:08.140 --> 01:05:10.140]  заранее оговорены между
[01:05:10.140 --> 01:05:12.140]  людьми. То есть, чтобы вы понимали,
[01:05:12.140 --> 01:05:14.140]  если я сейчас на каком-нибудь
[01:05:14.140 --> 01:05:16.140]  собеседование приду
[01:05:16.140 --> 01:05:18.140]  про программную инженерию, вам
[01:05:18.140 --> 01:05:20.140]  скорее всего спросят, а какие
[01:05:20.140 --> 01:05:22.140]  паттерны вы знаете?
[01:05:22.140 --> 01:05:24.140]  Соответственно, все сразу поймут, что
[01:05:24.140 --> 01:05:26.140]  мы говорим про паттерны проектирования.
[01:05:26.140 --> 01:05:28.140]  Вот. Теперь давайте поймём,
[01:05:28.140 --> 01:05:30.140]  каким образом они обозначаются. У каждого
[01:05:30.140 --> 01:05:32.140]  паттерна есть заранее определённое
[01:05:32.140 --> 01:05:34.140]  имя, либо несколько имён, по которым
[01:05:34.140 --> 01:05:36.140]  все сразу понимают, что это за паттерн.
[01:05:36.140 --> 01:05:38.140]  Значит,
[01:05:38.140 --> 01:05:40.140]  к имени привязывается задача,
[01:05:40.140 --> 01:05:42.140]  которую решает этот паттерн. То есть,
[01:05:42.140 --> 01:05:44.140]  заранее есть задача, которую мы хотим решить.
[01:05:44.140 --> 01:05:46.140]  У этой задачи
[01:05:46.140 --> 01:05:48.140]  есть конкретное решение.
[01:05:48.140 --> 01:05:50.140]  Конкретный подход
[01:05:50.140 --> 01:05:52.140]  к решению этой задачи.
[01:05:52.140 --> 01:05:54.140]  И те результаты
[01:05:54.140 --> 01:05:56.140]  достоинства и недостатки, которые
[01:05:56.140 --> 01:05:58.140]  даёт каждый из паттернов.
[01:05:58.140 --> 01:06:00.140]  Потому что некоторые паттерны
[01:06:00.140 --> 01:06:02.140]  зачастую могут считать
[01:06:02.140 --> 01:06:04.140]  именно анти-паттернами. То есть, те подходы,
[01:06:04.140 --> 01:06:06.140]  которые мне не стоит использовать.
[01:06:06.140 --> 01:06:08.140]  Вредные советы, так сказать.
[01:06:08.140 --> 01:06:10.140]  Но в некоторых
[01:06:10.140 --> 01:06:12.140]  случаях они сильно помогают.
[01:06:12.140 --> 01:06:14.140]  Так, давайте познакомимся.
[01:06:14.140 --> 01:06:16.140]  Всего бывают три вида
[01:06:16.140 --> 01:06:18.140]  паттернов,
[01:06:18.140 --> 01:06:20.140]  типа паттернов. Первые
[01:06:20.140 --> 01:06:22.140]  паттерны – это порождающие паттерны,
[01:06:22.140 --> 01:06:24.140]  которые помогают создавать
[01:06:24.140 --> 01:06:26.140]  новые объекты. Второй
[01:06:26.140 --> 01:06:28.140]  тип паттернов – это структурные,
[01:06:28.140 --> 01:06:30.140]  которые описывают связь между
[01:06:30.140 --> 01:06:32.140]  объектами. И вот как раз паттерн
[01:06:32.140 --> 01:06:34.140]  Bridge, про который я тут уже упомянул,
[01:06:34.140 --> 01:06:36.140]  это как раз структурный паттерн.
[01:06:36.140 --> 01:06:38.140]  И повиндейческий паттерн – это
[01:06:38.140 --> 01:06:40.140]  паттерны, которые помогают наследовать,
[01:06:40.140 --> 01:06:42.140]  посмотреть, каким образом
[01:06:42.140 --> 01:06:44.140]  идёт общение между объектами.
[01:06:44.140 --> 01:06:46.140]  То есть, выполнение функционала.
[01:06:46.140 --> 01:06:48.140]  Если мы говорим,
[01:06:48.140 --> 01:06:50.140]  так сказать, про физические
[01:06:50.140 --> 01:06:52.140]  аналоги, я не знаю,
[01:06:52.140 --> 01:06:54.140]  тут, наверное, половину у меня сейчас
[01:06:54.140 --> 01:06:56.140]  заклюют, потому что ненавидят физику.
[01:07:00.140 --> 01:07:02.140]  Но половину скажут, типа,
[01:07:02.140 --> 01:07:04.140]  нормас, потому что есть
[01:07:04.140 --> 01:07:06.140]  физика. Собственно, смотрите,
[01:07:06.140 --> 01:07:08.140]  чтобы вы понимали,
[01:07:08.140 --> 01:07:10.140]  порождающий паттерн – это создание материальных
[01:07:10.140 --> 01:07:12.140]  точек.
[01:07:12.140 --> 01:07:14.140]  Структурные
[01:07:14.140 --> 01:07:16.140]  паттерны – это как раз так
[01:07:16.140 --> 01:07:18.140]  называемая статика, или физика твёрдого
[01:07:18.140 --> 01:07:20.140]  тела. То есть, как связь между
[01:07:20.140 --> 01:07:22.140]  объектами. А повиденческие – это
[01:07:22.140 --> 01:07:24.140]  обычная динамика. То есть, как у нас
[01:07:24.140 --> 01:07:26.140]  всё происходит в динамике. Взаимосвязь
[01:07:26.140 --> 01:07:28.140]  между объектами.
[01:07:28.140 --> 01:07:30.140]  Вы не поверите,
[01:07:30.140 --> 01:07:32.140]  паттернов всего насчитывают
[01:07:32.140 --> 01:07:34.140]  или 22, или
[01:07:34.140 --> 01:07:36.140]  23 штуки.
[01:07:36.140 --> 01:07:38.140]  Пять из них повиденческих,
[01:07:38.140 --> 01:07:40.140]  ой, извините, пять из них порождающих,
[01:07:40.140 --> 01:07:42.140]  семь структурных,
[01:07:42.140 --> 01:07:44.140]  и десять,
[01:07:44.140 --> 01:07:46.140]  или одиннадцать повиденческих.
[01:07:46.140 --> 01:07:48.140]  То есть, часть мы будем
[01:07:48.140 --> 01:07:50.140]  с вами рассматривать на лексах, часть мы
[01:07:50.140 --> 01:07:52.140]  будем с вами рассматривать на семинарах.
[01:07:52.140 --> 01:07:54.140]  То есть, как только вы пройдёте
[01:07:54.140 --> 01:07:56.140]  семинары по гиту и башу, у вас будет
[01:07:56.140 --> 01:07:58.140]  первая пара по паттернам.
[01:07:58.140 --> 01:08:00.140]  Давайте начнём
[01:08:00.140 --> 01:08:02.140]  с первого паттерна. Это будет
[01:08:02.140 --> 01:08:04.140]  порождающий паттерн, и он называется
[01:08:04.140 --> 01:08:06.140]  фабричный метод.
[01:08:06.140 --> 01:08:08.140]  Это как раз пример того, каким образом
[01:08:08.140 --> 01:08:10.140]  можно реализовать open clause principle
[01:08:10.140 --> 01:08:12.140]  в конкретном примере.
[01:08:12.140 --> 01:08:14.140]  Представьте себе, что у вас есть
[01:08:14.140 --> 01:08:16.140]  бизнес, который производит сетевые кабели,
[01:08:16.140 --> 01:08:18.140]  и вы
[01:08:18.140 --> 01:08:20.140]  занимались созданием хабов.
[01:08:20.140 --> 01:08:22.140]  То есть, что такое хаб? Это
[01:08:22.140 --> 01:08:24.140]  коробка, которая умеет разветлять сетевой
[01:08:24.140 --> 01:08:26.140]  трафик. То есть,
[01:08:26.140 --> 01:08:28.140]  вы засовываете в неё
[01:08:28.140 --> 01:08:30.140]  что-то, и дальше идёт
[01:08:30.140 --> 01:08:32.140]  перенаправление трафика. То есть, это обычно проводной
[01:08:32.140 --> 01:08:34.140]  интернет. Ну вот, представьте
[01:08:34.140 --> 01:08:36.140]  себе, ваш бизнес расширяется, и
[01:08:36.140 --> 01:08:38.140]  вы думаете, куда двигаться.
[01:08:38.140 --> 01:08:40.140]  И оказывается следующее. А давайте
[01:08:40.140 --> 01:08:42.140]  попробуем производить Wi-Fi роутеры.
[01:08:44.140 --> 01:08:46.140]  В чём
[01:08:46.140 --> 01:08:48.140]  особенность роутеров?
[01:08:48.140 --> 01:08:50.140]  Особенность роутеров
[01:08:50.140 --> 01:08:52.140]  состоит в том, что они сами
[01:08:52.140 --> 01:08:54.140]  создают собственную сеть.
[01:08:54.140 --> 01:08:56.140]  И про это мы с вами ещё будем говорить.
[01:08:56.140 --> 01:08:58.140]  Более того, если у нас с вами
[01:08:58.140 --> 01:09:00.140]  Wi-Fi роутер, то
[01:09:00.140 --> 01:09:02.140]  какую сеть может поднимать Wi-Fi роутер?
[01:09:04.140 --> 01:09:06.140]  Wi-Fi, то есть беспроводную сеть. То есть, у нас
[01:09:06.140 --> 01:09:08.140]  получается ещё один сетевой интерфейс, который мы с
[01:09:08.140 --> 01:09:10.140]  вами можем использовать.
[01:09:10.140 --> 01:09:12.140]  Вот. И дальше
[01:09:12.140 --> 01:09:14.140]  как... То есть, у нас
[01:09:14.140 --> 01:09:16.140]  получается две отдельных сущности.
[01:09:16.140 --> 01:09:18.140]  То есть, мы хотим реализовать одну сущность
[01:09:18.140 --> 01:09:20.140]  и хотим реализовать вторую сущность. Вопрос.
[01:09:20.140 --> 01:09:22.140]  Каким образом связать
[01:09:22.140 --> 01:09:24.140]  производство? Это делается
[01:09:24.140 --> 01:09:26.140]  следующим образом. Давайте мы попробуем
[01:09:26.140 --> 01:09:28.140]  найти что-то общее между хабами
[01:09:28.140 --> 01:09:30.140]  и роутерами. То есть, между
[01:09:30.140 --> 01:09:32.140]  допустим, созданием беспроводной сети и
[01:09:32.140 --> 01:09:34.140]  проводной сетью.
[01:09:34.140 --> 01:09:36.140]  Ну, да,
[01:09:36.140 --> 01:09:38.140]  порты, общие интерфейсы
[01:09:38.140 --> 01:09:40.140]  какие-то и так далее. То есть,
[01:09:40.140 --> 01:09:42.140]  цель как раз вычленить общие.
[01:09:42.140 --> 01:09:44.140]  Я говорю про общий случай, это просто
[01:09:44.140 --> 01:09:46.140]  конкретный пример.
[01:09:46.140 --> 01:09:48.140]  Давайте попробуем сделать.
[01:09:48.140 --> 01:09:50.140]  И как раз что делает паттерн под названием
[01:09:50.140 --> 01:09:52.140]  фабричный метод? Это порождающий паттерн,
[01:09:52.140 --> 01:09:54.140]  который позволяет
[01:09:54.140 --> 01:09:56.140]  определять общий
[01:09:56.140 --> 01:09:58.140]  интерфейс создания объектов
[01:09:58.140 --> 01:10:00.140]  в конкретном классе. И он позволяет
[01:10:00.140 --> 01:10:02.140]  изменить поведение в
[01:10:02.140 --> 01:10:04.140]  некотором подклассе. То есть,
[01:10:04.140 --> 01:10:06.140]  сейчас давайте попробую пояснить
[01:10:06.140 --> 01:10:08.140]  на примерах. То есть,
[01:10:08.140 --> 01:10:10.140]  мы выделяем. У нас создается
[01:10:10.140 --> 01:10:12.140]  два конкретных вида
[01:10:12.140 --> 01:10:14.140]  классов. Первый у нас возникает абстрактный
[01:10:14.140 --> 01:10:16.140]  класс под названием создатель.
[01:10:16.140 --> 01:10:18.140]  То есть, это то, что мы вычленяем
[01:10:18.140 --> 01:10:20.140]  общего в создании этих
[01:10:20.140 --> 01:10:22.140]  объектов. И есть интерфейс
[01:10:22.140 --> 01:10:24.140]  того, что именно мы с вами создаем.
[01:10:24.140 --> 01:10:26.140]  То есть, допустим, здесь у нас будет
[01:10:26.140 --> 01:10:28.140]  завод по производству роутеров.
[01:10:28.140 --> 01:10:30.140]  Значит, конкретный
[01:10:30.140 --> 01:10:32.140]  криейтор
[01:10:32.140 --> 01:10:34.140]  А у нас, допустим, это завод
[01:10:34.140 --> 01:10:36.140]  по производству хабов. Отдел
[01:10:36.140 --> 01:10:38.140]  по производству хаб роутеров
[01:10:38.140 --> 01:10:40.140]  обычных. А второй, это Brazil по
[01:10:40.140 --> 01:10:42.140]  производству беспроводных роутеров,
[01:10:42.140 --> 01:10:44.140]  беспроводных сетей. Что они будут
[01:10:44.140 --> 01:10:46.140]  создавать? Здесь они будут создавать
[01:10:46.140 --> 01:10:48.140]  беспроводную сеть.
[01:10:48.140 --> 01:10:50.140]  А здесь они будут создавать проводную сеть.
[01:10:52.140 --> 01:10:54.140]  Теперь вопрос. Если вдруг
[01:10:54.140 --> 01:10:56.140]  придумают сеть 5g,
[01:10:56.140 --> 01:10:58.140]  то что нам придется
[01:10:58.140 --> 01:11:00.140]  в этом классе сделать?
[01:11:00.140 --> 01:11:03.500]  в этой диаграмме
[01:11:03.500 --> 01:11:05.500]  да смотрите нам нужно будет добавить
[01:11:05.500 --> 01:11:07.560]  еще одного криэйтора который будет
[01:11:07.560 --> 01:11:10.860]  создавать сеть 5g
[01:11:10.860 --> 01:11:12.580]  и параллельно создать интерфейс то есть
[01:11:12.580 --> 01:11:13.260]  смотрите
[01:11:13.260 --> 01:11:15.540]  мы не ломаем логику в методе класса
[01:11:15.540 --> 01:11:17.380]  криэйтор
[01:11:17.380 --> 01:11:20.660]  возникает желание перелопатить код и
[01:11:20.660 --> 01:11:22.860]  и что-то в него встроить
[01:11:22.860 --> 01:11:25.420]  и не ломаем логику самих продуктов то
[01:11:25.420 --> 01:11:27.940]  есть мы соединяем общую функцию допустим
[01:11:28.900 --> 01:11:30.660]  при помощи интерфейса
[01:11:30.660 --> 01:11:32.780]  из-за того что мы не ломаем конкретную
[01:11:32.780 --> 01:11:35.540]  реализацию криэйтора
[01:11:35.540 --> 01:11:39.100]  и не ломаем абстрактный класс
[01:11:39.100 --> 01:11:41.580]  базовый класс это как раз нам позволяет
[01:11:41.580 --> 01:11:43.220]  не нарушать принцип открытости
[01:11:43.220 --> 01:11:44.940]  закрытости
[01:11:44.940 --> 01:11:46.980]  да то есть это как раз пример применения
[01:11:46.980 --> 01:11:48.300]  принципа открытости закрытости про
[01:11:48.300 --> 01:11:50.220]  который мы с вами говорили
[01:11:50.220 --> 01:11:53.060]  а вот и собственно
[01:11:53.060 --> 01:11:55.500]  что на самом деле обычно делает
[01:11:55.500 --> 01:11:57.820]  фабричный метод
[01:11:57.860 --> 01:11:59.460]  просто создает объект определенного
[01:11:59.460 --> 01:12:02.180]  класса
[01:12:02.180 --> 01:12:05.020]  ну как раз то есть в конкрет creation
[01:12:05.020 --> 01:12:07.200]  А у нас будет создаваться фабричный метод
[01:12:07.200 --> 01:12:08.840]  создаваться
[01:12:08.840 --> 01:12:10.900]  конкрет продукта а в конкрет CreatorB
[01:12:10.900 --> 01:12:13.060]  создается конкретный пример
[01:12:13.060 --> 01:12:15.860]  класса B
[01:12:15.860 --> 01:12:16.700]  хорошо
[01:12:16.700 --> 01:12:19.020]  давайте посмотрим на примере
[01:12:19.020 --> 01:12:20.060]  как это происходит
[01:12:20.060 --> 01:12:22.220]  да здесь есть пример базовых
[01:12:22.220 --> 01:12:23.020]  кодов
[01:12:23.020 --> 01:12:26.180]  на каком языке посмотрим с вами
[01:12:26.180 --> 01:12:30.380]  О, Господи! Ну ладно, давайте попробуем плюсы посмотреть.
[01:12:30.380 --> 01:12:33.620]  Значит, cpp-source.
[01:12:33.620 --> 01:12:38.820]  Смотрите, давайте сразу абстракцию.
[01:12:38.820 --> 01:12:43.100]  Так, код создался вот такой.
[01:12:43.100 --> 01:12:46.500]  Извините, что написано на shared PTR.
[01:12:46.500 --> 01:12:50.300]  Так, тему светлую оставим или тёмную?
[01:12:50.300 --> 01:12:52.500]  Светлую нормально видно?
[01:12:52.540 --> 01:12:54.300]  Смотрите, что мы делаем.
[01:12:54.300 --> 01:12:56.420]  Мы пишем следующую вещь.
[01:12:56.420 --> 01:12:59.820]  У нас есть метод connection via hub.
[01:12:59.820 --> 01:13:03.140]  Дальше у нас возникает shared PTR-раутер.
[01:13:03.140 --> 01:13:05.940]  Мы создаём вот этот вот hub.
[01:13:05.940 --> 01:13:08.100]  Да, кстати, не нужный мне поиск.
[01:13:08.100 --> 01:13:10.500]  То есть, видите, у нас класс типа router.
[01:13:10.500 --> 01:13:14.260]  И у класса типа router есть метод connect to net.
[01:13:14.260 --> 01:13:18.780]  То есть в зависимости от типа роутера мы будем подсоединяться к определённой сети.
[01:13:18.860 --> 01:13:22.220]  Значит, если мы говорим с вами про Wi-Fi роутер,
[01:13:22.220 --> 01:13:25.700]  делаем то же самое и создаём вызов сети.
[01:13:25.700 --> 01:13:31.420]  То есть здесь кажется, что у нас просто есть два наследника класса router.
[01:13:31.420 --> 01:13:34.060]  Это либо hub, либо Wi-Fi роутер.
[01:13:34.060 --> 01:13:35.820]  И дальше вызываем метод создания сети.
[01:13:35.820 --> 01:13:39.380]  Но не всё так просто.
[01:13:39.380 --> 01:13:42.540]  Давайте мы как раз посмотрим.
[01:13:42.540 --> 01:13:46.660]  О, здесь же вот такая штука появилась в GitHub.
[01:13:46.740 --> 01:13:51.660]  Давайте мы с вами откроем класс роутер h.
[01:13:53.180 --> 01:13:54.980]  Вот, да, опять же извините.
[01:13:54.980 --> 01:13:59.500]  Видите, у нас есть у класса роутера два метода.
[01:13:59.500 --> 01:14:01.500]  Первый метод это создать маршрут.
[01:14:01.500 --> 01:14:05.860]  И здесь как раз мы увидим с вами, что у нас есть класс route.
[01:14:05.860 --> 01:14:07.380]  И есть метод connect to net.
[01:14:07.380 --> 01:14:10.700]  То есть присоединиться к сети.
[01:14:10.700 --> 01:14:16.100]  Так, давайте посмотрим на реализацию каждой из этих классов.
[01:14:16.100 --> 01:14:21.820]  Соответственно, видите, и вот этот метод create route – это как раз фабричный метод.
[01:14:21.820 --> 01:14:26.300]  Который у hub будет создавать Ethernet route,
[01:14:26.300 --> 01:14:32.660]  а у router, у Wi-Fi роутера будет создавать как ни странно Wi-Fi route.
[01:14:32.660 --> 01:14:37.340]  То есть вот она как раз связь, которую мы с вами видели на презентации.
[01:14:37.340 --> 01:14:38.140]  Вот она связь.
[01:14:38.140 --> 01:14:45.540]  И в данном случае фабричный метод – это метод create route.
[01:14:45.580 --> 01:14:46.620]  Так, хорошо.
[01:14:46.620 --> 01:14:51.620]  И давайте посмотрим, собственно, теперь, что у нас в раутах есть.
[01:14:51.620 --> 01:14:55.580]  Собственно, у метода route cpp ничего нет.
[01:14:55.580 --> 01:14:57.460]  У метода route есть connect.
[01:14:57.460 --> 01:15:01.420]  Метод connect, который мы с вами и вызываем.
[01:15:01.420 --> 01:15:03.820]  Так, секунду, я что-то забыл рассказать.
[01:15:03.820 --> 01:15:07.500]  Наверное, у роутеров было, да?
[01:15:07.500 --> 01:15:08.900]  А, вот оно.
[01:15:08.900 --> 01:15:11.380]  Вот каким образом у нас происходит соединение к сети.
[01:15:11.380 --> 01:15:14.140]  К сожалению, здесь тоже можно разделять код.
[01:15:14.140 --> 01:15:18.580]  То есть мы создаем с вами раут, вид маршрута, который нам нужен,
[01:15:18.580 --> 01:15:20.700]  и дальше к этому рауту подсоединяемся connect.
[01:15:20.700 --> 01:15:25.060]  То есть мы это делаем в базовом классе, не в классе наследника.
[01:15:25.060 --> 01:15:30.260]  То есть это в данном случае вот метод, который здесь есть, – это метод do stuff.
[01:15:32.460 --> 01:15:35.100]  Да, в итоге у нас получается цепь.
[01:15:35.100 --> 01:15:35.780]  Какая?
[01:15:35.780 --> 01:15:36.780]  Внимание!
[01:15:38.220 --> 01:15:39.220]  Внимание!
[01:15:40.420 --> 01:15:41.420]  Поверная!
[01:15:41.900 --> 01:15:42.900]  Весело!
[01:15:45.140 --> 01:15:46.140]  Да.
[01:15:47.140 --> 01:15:49.140]  Ладно, давайте это…
[01:15:49.140 --> 01:15:52.700]  В общем, вот такой вот паттерн, он работает.
[01:15:52.700 --> 01:15:57.340]  Поскольку нас тут прерывает пожарная тревога, то мы сделаем
[01:15:57.340 --> 01:15:58.340]  следующее.
[01:15:58.340 --> 01:16:01.500]  Мы не успели рассмотреть один паттерн, мы его в следующий
[01:16:01.500 --> 01:16:02.500]  раз рассмотрим.
[01:16:04.500 --> 01:16:05.500]  Ну да.
[01:16:05.500 --> 01:16:06.500]  Так что…
[01:16:11.500 --> 01:16:12.860]  А теперь аккуратненько выходим.
