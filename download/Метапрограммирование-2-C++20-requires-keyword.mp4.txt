[00:00.000 --> 00:10.620]  Итак, сегодня нас ждет увлекательная трехчасовая
[00:10.620 --> 00:16.440]  лекция, хотя и интерактивная, про прикол и C++20.
[00:16.440 --> 00:19.060]  Никакие карутины на другом курсе, вам уже все рассказали
[00:19.060 --> 00:21.360]  про карутины на втором курсе.
[00:21.360 --> 00:26.360]  Как там задачи с карутиными?
[00:26.360 --> 00:27.360]  Какие карутины?
[00:27.360 --> 00:29.360]  Так, карутины были на курсе конкарнси.
[00:29.360 --> 00:30.360]  У вас были?
[00:30.360 --> 00:31.360]  Да.
[00:31.360 --> 00:32.360]  Ну все, больше их не будет.
[00:32.360 --> 00:33.360]  Дальше уже сами.
[00:33.360 --> 00:34.360]  Вот там я вам не помощник.
[00:34.360 --> 00:39.360]  Тем более, что там и в 23-26 что-то фиксит, правит,
[00:39.360 --> 00:40.360]  и там непонятно.
[00:40.360 --> 00:44.680]  Мы будем только про эти концепты говорить, но там оказывается
[00:44.680 --> 00:47.280]  столько говорить, что вот нам на три часа вот так вот
[00:47.280 --> 00:48.280]  хватит.
[00:49.000 --> 00:53.560]  Ну вот, сосредоточились, собрались силами и поехали.
[00:53.560 --> 00:57.680]  Первое, о чем надо сказать, это о named requirements.
[00:57.680 --> 01:00.680]  Слышали такие слова?
[01:00.680 --> 01:03.880]  Они с нами непонятно с какого стандарта, наверное,
[01:03.880 --> 01:06.880]  с самблок первого.
[01:06.880 --> 01:08.360]  Сразу видно, кто всю ночь ботл.
[01:08.360 --> 01:11.960]  Ну что такое named requirements?
[01:11.960 --> 01:15.280]  Вот есть какое-то слово, имя, и там написано, что
[01:15.280 --> 01:19.280]  подовлетворяет требованию итератор, если у него тыры-пыры-пыры-пыры.
[01:19.280 --> 01:20.280]  Что-то написано.
[01:20.280 --> 01:22.280]  Какой-то оператор плюс, еще чего-то.
[01:22.280 --> 01:25.280]  Там еще виды разных этих итераторов начинаются,
[01:25.280 --> 01:28.280]  и много их, короче, в стандарте.
[01:28.280 --> 01:31.280]  Очевидно, что это не самая хорошая идея, вот эти вот
[01:31.280 --> 01:32.280]  requirements.
[01:32.280 --> 01:35.280]  Ну как бы в чем их смысл вообще?
[01:35.280 --> 01:38.280]  В некоторых местах стандарта говорят, что если вы используете
[01:38.280 --> 01:41.280]  вот этот алгоритм, то от вашего типа требуется исполнять
[01:41.280 --> 01:44.280]  вот такие требования, а если вы их не исполняете,
[01:45.280 --> 01:47.280]  надевать behavior.
[01:47.280 --> 01:50.280]  Ну вот как часто вы залезаете в стандарт, написав там свой
[01:50.280 --> 01:52.280]  итератор или какой-нибудь свой контейнер и проверяете,
[01:52.280 --> 01:54.280]  что все эти требования строго соблюли?
[01:54.280 --> 01:56.280]  Каждый раз.
[01:56.280 --> 02:00.280]  Ну, это вброс, да, вот статистический.
[02:00.280 --> 02:04.280]  В среднем народ вообще не парится, как хочет, так и пишет.
[02:04.280 --> 02:09.280]  И, ну, иногда внезапно оказывается, что все-таки какие-то требования
[02:09.280 --> 02:13.280]  нарушены, у нас undefined behavior, и один раз на миллион
[02:13.280 --> 02:17.280]  внезапно оказывается так, что компилятор вокруг этого undefined
[02:17.280 --> 02:20.280]  behavior что-то оптимизирует, и потом ты сидишь неделю
[02:20.280 --> 02:23.280]  дебажишь, не можешь понять, что пошло не так.
[02:23.280 --> 02:26.280]  Это, конечно, супер редкие случаи, обычно там все проще,
[02:26.280 --> 02:29.280]  что там какая-нибудь ошибка компиляции просто вылазит,
[02:29.280 --> 02:31.280]  что, мол, я сломался.
[02:31.280 --> 02:34.280]  Ну, все равно неприятно, хочется, чтобы как-то
[02:34.280 --> 02:36.280]  попонятнее было.
[02:36.280 --> 02:39.280]  Ну, собственно, вот список минусов кратко.
[02:39.280 --> 02:42.280]  В коде мы никак эти named requirements не описали.
[02:42.280 --> 02:45.280]  Поэтому, ну, нужно куда-то еще лезть, что-то там смотреть,
[02:45.280 --> 02:46.280]  неприятно.
[02:46.280 --> 02:49.280]  А сообщения об ошибках абсолютно жуткие, да?
[02:49.280 --> 02:51.280]  Ну, сейчас посмотрим на них.
[02:51.280 --> 02:54.280]  Ну, и проверять, собственно, насколько наш тип подходит,
[02:54.280 --> 02:56.280]  мы должны просто глазками.
[02:56.280 --> 02:59.280]  Это как-то немножко тупо, сидеть и высматривать,
[02:59.280 --> 03:02.280]  где там я что там ошибся, где там что-то не удовлетворил.
[03:02.280 --> 03:05.280]  Ну, поэтому, очевидно, и вот зашел весь этот разговор
[03:05.280 --> 03:08.280]  о том, к чему мы в самом конце сегодня подойдем, о концептах.
[03:08.280 --> 03:10.280]  Вот такой примерчик.
[03:10.280 --> 03:12.280]  Вот stdsort, он требует random access-атератора.
[03:12.280 --> 03:14.280]  Понятно, почему, да?
[03:14.280 --> 03:18.280]  На forward-атераторах за какую симпточку можно сортировку сделать?
[03:22.280 --> 03:24.280]  Ну, как бы это и верно, и нет.
[03:24.280 --> 03:26.280]  Тут каверзный вопрос.
[03:26.280 --> 03:28.280]  Разрешается ли доп-память?
[03:28.280 --> 03:31.280]  Вот если доп-память разрешается, то можно и за n log n тоже.
[03:31.280 --> 03:34.280]  Да, если не разрешается, то действительно за квадрат,
[03:34.280 --> 03:37.280]  потому что там, ну, как-то нужно что-то типа пузырька делать, наверное.
[03:37.280 --> 03:39.280]  Вот.
[03:39.280 --> 03:41.280]  Ну, соответственно, такое требование наложено
[03:41.280 --> 03:43.280]  на ваши итераторы, которые вы sort-запихиваете.
[03:43.280 --> 03:47.280]  Ну, вот случайно пришел стажер, такой код написал.
[03:47.280 --> 03:49.280]  Что мы получим?
[03:49.280 --> 03:51.280]  Ну, казалось бы, если бы у нас был нормальный язык,
[03:51.280 --> 03:55.280]  нам бы сказали, ой, извините, простите, вот этот итератор,
[03:55.280 --> 03:57.280]  он как бы forward, а это же знаете, что значит?
[03:57.280 --> 03:59.280]  Там его только вперед-назад двигать нельзя,
[03:59.280 --> 04:01.280]  а просто как-то плюсовать нельзя,
[04:01.280 --> 04:05.280]  и вот мы как бы это, извините, выберите другой контейнер, пожалуйста.
[04:05.280 --> 04:07.280]  Ну, то есть РАСТ вот так делает.
[04:07.280 --> 04:11.280]  Но на языке C++ говорят вот так, и это прекрасно.
[04:11.280 --> 04:15.280]  Ну, то есть тут нужно обладать некоторым опытом и скиллом,
[04:15.280 --> 04:17.280]  чтобы понять, в чем проблема.
[04:17.280 --> 04:22.280]  Тут реверс-итератор какой-то упоминается, и что-то ну жутко.
[04:22.280 --> 04:25.280]  Хочется более адекватных сообщений об ошибках как минимум.
[04:29.280 --> 04:31.280]  Что я хотел сказать?
[04:31.280 --> 04:36.280]  Ну вот еще, помимо алгоритмов каких-то обобщенных,
[04:36.280 --> 04:39.280]  мы иногда пишем обобщенные структуры данных.
[04:39.280 --> 04:43.280]  Ну, для них тоже как-то хочется понимать,
[04:43.280 --> 04:47.280]  а что вообще требуется вот от этих вот шаблонных аргументов.
[04:47.280 --> 04:49.280]  Здравствуй.
[04:49.280 --> 04:54.280]  Ну, наверное, можно догадаться, что тут внутри key-value написано,
[04:54.280 --> 04:57.280]  наверное, это какой-нибудь мапчик упорядочный.
[04:57.280 --> 04:59.280]  Наверное, тут оператор меньше требуется.
[04:59.280 --> 05:02.280]  А может, это хэш-мапчик, и требуется std-hash.
[05:02.280 --> 05:05.280]  Ну, и вот непонятно, и нужно какие-то комментарии идти смотреть,
[05:05.280 --> 05:07.280]  или просто пробовать, или код читать.
[05:07.280 --> 05:10.280]  Да, вот, ну, а что? Ответа нету в коде.
[05:10.280 --> 05:15.280]  Нужно как-то вне структуры языка ответ на этот вопрос искать,
[05:15.280 --> 05:17.280]  либо методом тыка.
[05:17.280 --> 05:20.280]  А бывают еще более сложные случаи,
[05:20.280 --> 05:24.280]  когда у нас не просто что-то конкретное можно подставить,
[05:24.280 --> 05:28.280]  ну, аля там требуется, чтобы хэш был у ключа.
[05:28.280 --> 05:30.280]  А бывает, что мы в зависимости от того,
[05:30.280 --> 05:33.280]  какими свойствами обладает тип T,
[05:33.280 --> 05:36.280]  наделяем этими свойствами сам контейнер.
[05:36.280 --> 05:38.280]  Вот так вот.
[05:38.280 --> 05:40.280]  Поняли, что я сказал?
[05:40.280 --> 05:42.280]  Ну, по-моему, даже на схемке понятно,
[05:42.280 --> 05:45.280]  что std-ri-t можно двигать, ну, делать move,
[05:45.280 --> 05:47.280]  только если сам t-move был.
[05:47.280 --> 05:50.280]  И вот это вот тоже наследование каких-то свойств,
[05:50.280 --> 05:52.280]  оно как-то никак не выражается,
[05:52.280 --> 05:55.280]  и это вообще сюрприз, и комментарии, и все это неприятно.
[05:55.280 --> 05:58.280]  Поэтому мы начнем углубляться в C++20,
[05:58.280 --> 06:00.280]  где все это фиксится.
[06:00.280 --> 06:02.280]  Ну, я сказал как бы концепты,
[06:02.280 --> 06:05.280]  но концепты будут в самом-самом-самом конце.
[06:05.280 --> 06:07.280]  Потому что до них нужно еще дойти.
[06:07.280 --> 06:09.280]  Тут другие слова будут.
[06:09.280 --> 06:11.280]  Первые слова — это constraint.
[06:11.280 --> 06:13.280]  Ну, по-русски это ограничение.
[06:15.280 --> 06:18.280]  Ну, можно выпендриваться и пытаться говорить по-русски,
[06:18.280 --> 06:20.280]  но я думаю, я не справлюсь,
[06:20.280 --> 06:22.280]  и буду все равно иногда проскакивать constraints,
[06:22.280 --> 06:24.280]  а то и чаще.
[06:24.280 --> 06:25.280]  Другие constraints.
[06:25.280 --> 06:27.280]  А очень просто.
[06:27.280 --> 06:30.280]  Новое ключевое слово добавили — requires.
[06:30.280 --> 06:32.280]  Ну, и вот вы что-то пишете,
[06:32.280 --> 06:36.280]  и можете написать после заголовка шаблона requires.
[06:36.280 --> 06:38.280]  А дальше какое-то булевое выражение.
[06:38.280 --> 06:40.280]  Тут тупо написано.
[06:40.280 --> 06:44.280]  Вот этот шаблон требует, чтобы n был не больше 10.
[06:44.280 --> 06:46.280]  Понятно? Понятно.
[06:46.280 --> 06:48.280]  Ну, если подставить и больше,
[06:48.280 --> 06:50.280]  то ошибка компиляции вам напишут.
[06:50.280 --> 06:52.280]  Требование не выполнено.
[06:52.280 --> 06:54.280]  И отлично.
[06:55.280 --> 06:57.280]  Вот так, ок, вот так ошибка.
[07:01.280 --> 07:04.280]  И вот эта вот вся конструкция вместе requires что-то там,
[07:04.280 --> 07:07.280]  это называется requires clause.
[07:07.280 --> 07:10.280]  Почему я акцентирую внимание на какой-то терминологии дурацкой?
[07:10.280 --> 07:12.280]  Потому что будет еще requires expression.
[07:12.280 --> 07:14.280]  И нужно не путать.
[07:16.280 --> 07:18.280]  А вот, собственно, вот тот кусочек,
[07:18.280 --> 07:21.280]  который уже после слова requires написан внутри этого clause,
[07:21.280 --> 07:23.280]  это называется constraint.
[07:23.280 --> 07:25.280]  Ну, и констрейтов, конечно, может быть, несколько,
[07:25.280 --> 07:27.280]  но сейчас все это увидим.
[07:28.280 --> 07:30.280]  Вот еще примерчик.
[07:30.280 --> 07:32.280]  Это переменная.
[07:32.280 --> 07:34.280]  Ну, шаблон переменной, если быть точным,
[07:34.280 --> 07:36.280]  и причем constexpr,
[07:36.280 --> 07:42.280]  оно просто превращает какое-то число в минус число.
[07:42.280 --> 07:44.280]  Ну, и тут навешан constraint,
[07:44.280 --> 07:46.280]  что тип числа должен быть знаковый.
[07:46.280 --> 07:48.280]  Это, конечно, дурацкий примерчик,
[07:48.280 --> 07:52.280]  но суть можно и на переменных тоже писать constraint.
[07:55.280 --> 07:57.280]  Ой, а вот это я более не переправил,
[07:57.280 --> 07:59.280]  надо переправить.
[07:59.280 --> 08:03.280]  Ну ладно, на юзингах можно писать constraint внезапно.
[08:03.280 --> 08:06.280]  Я вот не знаю, насколько это полезно, но можно.
[08:08.280 --> 08:10.280]  Ну и, конечно же, на функциях можно.
[08:11.280 --> 08:13.280]  Но можно двумя разными способами.
[08:15.280 --> 08:17.280]  Вот следите за руками, что называется.
[08:17.280 --> 08:19.280]  В чем разница сверху и снизу?
[08:19.280 --> 08:21.280]  Видите?
[08:21.280 --> 08:23.280]  Да, тут оно сразу после заголовка шаблона,
[08:23.280 --> 08:26.280]  а вот здесь после уже круглых скобочек,
[08:26.280 --> 08:28.280]  то есть после сигнатуры функции.
[08:30.280 --> 08:32.280]  Ну и можно и там, и там написать,
[08:32.280 --> 08:34.280]  чтобы совсем круто было.
[08:34.280 --> 08:36.280]  Чем отличается? Да ничем.
[08:36.280 --> 08:38.280]  Просто вот это преобразовывается вот в это.
[08:38.280 --> 08:40.280]  Сейчас все будет.
[08:40.280 --> 08:43.280]  Ну вот в таком виде ничем не отличается.
[08:43.280 --> 08:46.280]  Можно просто переписать это на одну такую штучку,
[08:46.280 --> 08:48.280]  где два раза написаны персенты.
[08:51.280 --> 08:53.280]  Ну и чем честно отличается?
[08:53.280 --> 08:55.280]  Это тем, что вот здесь, когда вы пишете
[08:55.280 --> 08:57.280]  сразу после template что-то там,
[08:59.280 --> 09:02.280]  у вас уже есть все названия шаблонных аргументов.
[09:02.280 --> 09:05.280]  То есть имена вот эти вот, которые относятся к чему-то,
[09:05.280 --> 09:07.280]  что вы в треугольных скобках написали,
[09:07.280 --> 09:09.280]  они у вас уже в области видимости.
[09:09.280 --> 09:11.280]  Можно обращаться к ним.
[09:11.280 --> 09:13.280]  Вот здесь к имени вы обращаемся.
[09:13.280 --> 09:15.280]  А когда пишем вот здесь,
[09:15.280 --> 09:17.280]  к именам, которые шаблонные аргументы,
[09:17.280 --> 09:21.280]  можно еще и к именам аргументов функции обращаться внезапно.
[09:23.280 --> 09:26.280]  Ну как бы к именам этим вы обращаться можете,
[09:26.280 --> 09:28.280]  но это будут не сами аргументы.
[09:28.280 --> 09:30.280]  Это вот важно понимать.
[09:30.280 --> 09:32.280]  Вот эти все требования, они в compile-time проверяются
[09:32.280 --> 09:34.280]  на этапе компиляции где-то.
[09:34.280 --> 09:36.280]  То есть можно, например,
[09:36.280 --> 09:38.280]  ну тут примерчика, к сожалению, нет,
[09:38.280 --> 09:40.280]  но если мы здесь какой-нибудь,
[09:42.280 --> 09:44.280]  блин, не знаю,
[09:44.280 --> 09:47.280]  массив какой-нибудь сделаем произвольной длины
[09:47.280 --> 09:49.280]  и назовем его foo,
[09:49.280 --> 09:51.280]  то вот здесь мы можем написать size of foo.
[09:51.280 --> 09:54.280]  Да, то есть можно упоминать имена аргументов, но...
[09:54.280 --> 09:56.280]  Если это constexpr функция,
[09:56.280 --> 09:58.280]  то можно ли упоминать?
[09:58.280 --> 10:00.280]  Нет, все равно нельзя.
[10:00.280 --> 10:02.280]  Для constexpr функции мы считаем,
[10:02.280 --> 10:04.280]  что все равно есть два этапа.
[10:04.280 --> 10:06.280]  Этап компиляции, а потом этап интерпретации
[10:06.280 --> 10:08.280]  внутри компилятора.
[10:08.280 --> 10:10.280]  Поэтому то же самое.
[10:10.280 --> 10:12.280]  Еще раз, о чем был его вопрос?
[10:12.280 --> 10:14.280]  Что?
[10:14.280 --> 10:16.280]  Да, вопрос был
[10:16.280 --> 10:18.280]  для constexpr функций,
[10:18.280 --> 10:20.280]  где аргументы известны в compile-time,
[10:20.280 --> 10:22.280]  нельзя ли случайно их как-то
[10:22.280 --> 10:24.280]  использовать в Requires?
[10:24.280 --> 10:26.280]  Ответ нет, нельзя, потому что даже для
[10:26.280 --> 10:28.280]  constexpr функции мы различаем
[10:28.280 --> 10:30.280]  два этапа. Первая это компиляция
[10:30.280 --> 10:32.280]  в кавычках, второй этап
[10:32.280 --> 10:34.280]  это интерпретация.
[10:34.280 --> 10:36.280]  Ну и то и другое происходит во время работы компилятора,
[10:36.280 --> 10:38.280]  а не в runtime, но это все равно
[10:38.280 --> 10:40.280]  два разных этапа как бы.
[10:42.280 --> 10:44.280]  Не обязательно.
[10:44.280 --> 10:46.280]  Но если он все-таки во время компиляции был,
[10:46.280 --> 10:48.280]  то вот...
[10:48.280 --> 10:50.280]  Наверное, то же самое для constval, верно?
[10:50.280 --> 10:52.280]  Да, конечно, все то же самое.
[10:52.280 --> 10:54.280]  Про constval будет позже.
[10:54.280 --> 10:56.280]  Так вот,
[10:56.280 --> 10:58.280]  зачем такие выкрутасы на самом деле
[10:58.280 --> 11:00.280]  нужны?
[11:00.280 --> 11:02.280]  Можно было просить вас догадаться,
[11:02.280 --> 11:04.280]  но тут уже есть люди, которые что-то знают,
[11:04.280 --> 11:06.280]  поэтому неинтересно.
[11:06.280 --> 11:08.280]  А нужны это вот для этого на самом деле.
[11:08.280 --> 11:10.280]  Приглядитесь.
[11:10.280 --> 11:12.280]  Чувствуете, в чем понт?
[11:12.280 --> 11:14.280]  Это вот максимально
[11:14.280 --> 11:16.280]  круто.
[11:18.280 --> 11:20.280]  Может, кто-нибудь может сказать
[11:20.280 --> 11:22.280]  причину, почему это максимально
[11:22.280 --> 11:24.280]  круто и где вот такое очень хочется
[11:24.280 --> 11:26.280]  писать?
[11:26.280 --> 11:28.280]  Для кого там иклец, для кого дробнется?
[11:28.280 --> 11:30.280]  Ну, для кого-то да.
[11:30.280 --> 11:32.280]  Ну, если пофотатся
[11:32.280 --> 11:34.280]  этот метод использовать,
[11:34.280 --> 11:36.280]  то, ну, с копируемым
[11:36.280 --> 11:38.280]  типом, то он просто
[11:38.280 --> 11:40.280]  сейчас работает как нужно, а если будет
[11:40.280 --> 11:42.280]  не копировано, то будет ошибка
[11:42.280 --> 11:44.280]  компиляции, которая явно укажет,
[11:44.280 --> 11:46.280]  что данный метод
[11:46.280 --> 11:48.280]  не инстанцировался.
[11:48.280 --> 11:50.280]  Да, но
[11:50.280 --> 11:52.280]  самый главный понт в том, что
[11:52.280 --> 11:54.280]  это вам позволяет для контейнеров
[11:54.280 --> 11:56.280]  вот то, о чем я уже упомянул,
[11:56.280 --> 11:58.280]  делать как бы наследование
[11:58.280 --> 12:00.280]  свойств от
[12:00.280 --> 12:02.280]  шаблонного аргумента.
[12:02.280 --> 12:04.280]  Потому что здесь пример с клоун.
[12:04.280 --> 12:06.280]  Ну, если бы вас
[12:06.280 --> 12:08.280]  попросили это сделать на C++17,
[12:08.280 --> 12:10.280]  кто у нас самый сильный
[12:10.280 --> 12:12.280]  программист? Нет,
[12:12.280 --> 12:14.280]  не хватит. Вот если
[12:14.280 --> 12:16.280]  просто сюда написать какой-то enable if не хватит,
[12:16.280 --> 12:18.280]  вам просто дадут ошибку, что
[12:18.280 --> 12:20.280]  ой, не смог скомпилировать, тут
[12:20.280 --> 12:22.280]  что-то проблема.
[12:22.280 --> 12:24.280]  Да, да, да, да, да, вот именно.
[12:24.280 --> 12:26.280]  Нужно еще сюда шаблон
[12:26.280 --> 12:28.280]  навесить, сделать
[12:28.280 --> 12:30.280]  здесь один аргумент, который будет
[12:30.280 --> 12:32.280]  равен void, потом второй аргумент,
[12:32.280 --> 12:34.280]  который будет enable if, туда подставить
[12:34.280 --> 12:36.280]  первый, который на самом деле...
[12:38.280 --> 12:40.280]  Ну, как бы да,
[12:40.280 --> 12:42.280]  я хотел услышать именно эти
[12:42.280 --> 12:44.280]  детали, что нужно будет вот
[12:44.280 --> 12:46.280]  эту функцию саму шаблонной сделать.
[12:46.280 --> 12:48.280]  Но если здесь это еще как-то
[12:48.280 --> 12:50.280]  приемлемо, то конструкторы
[12:50.280 --> 12:52.280]  копирования и мува,
[12:52.280 --> 12:54.280]  и операторы присваивания копирования
[12:54.280 --> 12:56.280]  и мува, их делать шаблонами
[12:56.280 --> 12:58.280]  нельзя, поэтому с помощью
[12:58.280 --> 13:00.280]  enable if вы их отключить не сможете.
[13:00.280 --> 13:02.280]  Понимаете, в чем цимис,
[13:02.280 --> 13:04.280]  а с помощью этого одной строчкой
[13:04.280 --> 13:06.280]  можете.
[13:06.280 --> 13:08.280]  Вот если вы когда-то пытались писать
[13:08.280 --> 13:10.280]  какие-то шаблонные контейнеры
[13:10.280 --> 13:12.280]  в библиотеке, в чем-то приближенном
[13:12.280 --> 13:14.280]  к реальной жизни, вот вы на это
[13:14.280 --> 13:16.280]  должны были наткнуться. И вот я
[13:16.280 --> 13:18.280]  натыкался и чертыхался, что мы до сих пор
[13:18.280 --> 13:20.280]  на C++20 не перешли.
[13:20.280 --> 13:22.280]  А теперь все так
[13:22.280 --> 13:24.280]  удобно.
[13:24.280 --> 13:26.280]  Да.
[13:26.280 --> 13:28.280]  Смотри,
[13:28.280 --> 13:30.280]  представим, что мы хотим, чтобы вот этот
[13:30.280 --> 13:32.280]  враппер у него был...
[13:32.280 --> 13:34.280]  Давай так, чтобы он работал
[13:34.280 --> 13:36.280]  как бокс в расте.
[13:36.280 --> 13:38.280]  То есть это аналог
[13:38.280 --> 13:40.280]  UniquePTR, но который можно копировать.
[13:40.280 --> 13:42.280]  Но что значит скопировать
[13:42.280 --> 13:44.280]  UniquePTR? Это значит скопировать сам объект,
[13:44.280 --> 13:46.280]  который внутри лежит.
[13:46.280 --> 13:48.280]  То есть такую структуру данных хотим сделать,
[13:48.280 --> 13:50.280]  назвали враппер. Вполне резонно.
[13:50.280 --> 13:52.280]  То есть оно хранит что-то на куче,
[13:52.280 --> 13:54.280]  чтобы, например,
[13:54.280 --> 13:56.280]  с помощью форвардекларации
[13:56.280 --> 13:58.280]  что-нибудь не инклюдить. Вот такие какие-то приколы.
[13:58.280 --> 14:00.280]  Но копировать мы тоже хотим.
[14:00.280 --> 14:02.280]  Ну, а когда мы хотим
[14:02.280 --> 14:04.280]  копировать? Тогда и только тогда, когда
[14:04.280 --> 14:06.280]  в копируемой.
[14:06.280 --> 14:08.280]  Но здесь же написано тривиально, копируемой.
[14:08.280 --> 14:10.280]  Ну, не важно.
[14:10.280 --> 14:12.280]  Здесь какой-то дурацкий пример, который
[14:12.280 --> 14:14.280]  я написал год назад, а то и больше.
[14:14.280 --> 14:16.280]  Надо
[14:16.280 --> 14:18.280]  запомнить и вставить сюда
[14:18.280 --> 14:20.280]  хороший пример. То есть можно представить,
[14:20.280 --> 14:22.280]  что здесь написано просто из копии.
[14:22.280 --> 14:24.280]  Можно представить, что здесь написан
[14:24.280 --> 14:26.280]  оператор копирования,
[14:26.280 --> 14:28.280]  конструктор копирования
[14:28.280 --> 14:30.280]  и просто из копиабл.
[14:30.280 --> 14:32.280]  И вот тогда, вот в этом суть.
[14:32.280 --> 14:34.280]  Мы как бы явно удаляем оператор
[14:34.280 --> 14:36.280]  копирования, если нет
[14:36.280 --> 14:38.280]  оператора копирования УВ.
[14:38.280 --> 14:40.280]  Можно?
[14:40.280 --> 14:42.280]  Ну,
[14:42.280 --> 14:44.280]  на прошлый парик смотрели как раз,
[14:44.280 --> 14:46.280]  что если у нас есть метод,
[14:46.280 --> 14:48.280]  который может
[14:48.280 --> 14:50.280]  сделать потенциально
[14:50.280 --> 14:52.280]  СЕ,
[14:52.280 --> 14:54.280]  мы
[14:54.280 --> 14:56.280]  можем его не вызвать.
[14:56.280 --> 14:58.280]  Да, да, да, да.
[14:58.280 --> 15:00.280]  Да.
[15:00.280 --> 15:02.280]  Почему нам это здесь не подходит?
[15:02.280 --> 15:04.280]  Потому что мы хотим в итоге,
[15:04.280 --> 15:06.280]  нам зачем делать его копируемым
[15:06.280 --> 15:08.280]  или некопируемым таким хитрым образом?
[15:08.280 --> 15:10.280]  Вот у STD-вектора такого свойства,
[15:10.280 --> 15:12.280]  как я сейчас описываю с вот этими
[15:12.280 --> 15:14.280]  вот реквайерсами, его нету.
[15:14.280 --> 15:16.280]  Но это в некотором смысле плохо, а в некотором
[15:16.280 --> 15:18.280]  смысле хорошо. Вообще,
[15:18.280 --> 15:20.280]  блин, конечно, это бы просто с кодом
[15:20.280 --> 15:22.280]  отложить, вот наконец, если у нас останется
[15:22.280 --> 15:24.280]  время.
[15:24.280 --> 15:26.280]  Давайте действительно вот этот вопрос
[15:26.280 --> 15:28.280]  отложим. Те, кого это сильно волнует,
[15:28.280 --> 15:30.280]  обязательно напомните мне в конце.
[15:30.280 --> 15:32.280]  Ну, что это очень тонкий момент,
[15:32.280 --> 15:34.280]  но он может вам пригодиться.
[15:34.280 --> 15:36.280]  Семинары или семестра?
[15:36.280 --> 15:38.280]  Пары, вернее двух пар
[15:38.280 --> 15:40.280]  с сегодняшнего занятия. Вот,
[15:40.280 --> 15:42.280]  откладываем на потом. Давайте пойдем дальше.
[15:42.280 --> 15:44.280]  Здесь так можно только отвечать,
[15:44.280 --> 15:46.280]  включать, или можно какие-то другие
[15:46.280 --> 15:48.280]  штуки вписать?
[15:48.280 --> 15:52.280]  А сейчас
[15:52.280 --> 15:54.280]  увидим.
[15:54.280 --> 15:56.280]  Ну, можно, короче, ответ.
[15:56.280 --> 15:58.280]  Все можно, кроме того, что сейчас
[15:58.280 --> 16:00.280]  расскажу нельзя.
[16:00.280 --> 16:02.280]  Вот такой код.
[16:02.280 --> 16:04.280]  Нельзя.
[16:04.280 --> 16:06.280]  Ну, то есть,
[16:06.280 --> 16:08.280]  что мы хотели? Мы хотели
[16:08.280 --> 16:10.280]  разные классы, вернее как,
[16:10.280 --> 16:12.280]  разные шаблоны для одного и того
[16:12.280 --> 16:14.280]  же имени использовать,
[16:14.280 --> 16:16.280]  в зависимости от шаблонных аргументов.
[16:16.280 --> 16:18.280]  Вот это два разных шаблона,
[16:18.280 --> 16:20.280]  они не специализации,
[16:20.280 --> 16:22.280]  ничего, это просто два разных шаблона,
[16:22.280 --> 16:24.280]  но с одним именем.
[16:24.280 --> 16:26.280]  И компилятор вам скажет
[16:26.280 --> 16:28.280]  а-та-та. Нельзя два разных шаблона
[16:28.280 --> 16:30.280]  с одним именем, но разными
[16:30.280 --> 16:32.280]  реквайерсами. Ну, казалось бы, что мешает
[16:32.280 --> 16:34.280]  разрешить, но вот так оно работает.
[16:34.280 --> 16:36.280]  И изменять это никто не планирует.
[16:36.280 --> 16:38.280]  А если
[16:38.280 --> 16:40.280]  это все-таки специализация?
[16:40.280 --> 16:42.280]  То все можно.
[16:42.280 --> 16:44.280]  Буквально все, я просто помню,
[16:44.280 --> 16:46.280]  что иногда компилятор
[16:46.280 --> 16:48.280]  очень странно
[16:48.280 --> 16:50.280]  понимает, какой
[16:50.280 --> 16:52.280]  constraint строже какого.
[16:52.280 --> 16:54.280]  Про это тоже...
[16:54.280 --> 16:56.280]  Про это подробнее
[16:56.280 --> 16:58.280]  поговорим.
[16:58.280 --> 17:00.280]  Про это все подробнее
[17:00.280 --> 17:02.280]  поговорим, как там, что там выбирает.
[17:02.280 --> 17:04.280]  Просто вот, для начала
[17:04.280 --> 17:06.280]  запоминаем, что
[17:06.280 --> 17:08.280]  просто два разных шаблона с разными реквайерсами
[17:08.280 --> 17:10.280]  написать нельзя. Для классов,
[17:10.280 --> 17:12.280]  для переменных и там
[17:12.280 --> 17:14.280]  тоже самое, я почти уверен,
[17:14.280 --> 17:16.280]  но лучше проверить. А вот для функций,
[17:16.280 --> 17:18.280]  для функций, мы же можем
[17:18.280 --> 17:20.280]  две разные функции с одним и тем же именем
[17:20.280 --> 17:22.280]  написать. Можем, это
[17:22.280 --> 17:24.280]  перегрузки называется. Вот для функций перегрузки
[17:24.280 --> 17:26.280]  есть, для всего остального нет.
[17:26.280 --> 17:28.280]  Поэтому вот этот механизм перегрузок
[17:28.280 --> 17:30.280]  вот спокойно взяли и встроили
[17:30.280 --> 17:32.280]  этот механизм реквайерсов.
[17:32.280 --> 17:34.280]  То есть, как бы без вот этого
[17:34.280 --> 17:36.280]  реквайерса, что бы вот такой код вызвал?
[17:36.280 --> 17:38.280]  Вопрос.
[17:38.280 --> 17:40.280]  Какую?
[17:40.280 --> 17:42.280]  Редиклорейшн.
[17:42.280 --> 17:44.280]  Ну, наверное,
[17:44.280 --> 17:46.280]  да, наверное, редиклорейшн
[17:46.280 --> 17:48.280]  могло еще быть
[17:48.280 --> 17:50.280]  что-то про амбигиус, ой, стоп,
[17:50.280 --> 17:52.280]  про амбигиус кол, ну, то есть
[17:52.280 --> 17:54.280]  эти перегрузки, они как бы полностью
[17:54.280 --> 17:56.280]  одинаковые. Они слишком одинаковые.
[17:56.280 --> 17:58.280]  Мы не умеем их отличать без вот этого
[17:58.280 --> 18:00.280]  реквайерса, а реквайерсы нам позволяют
[18:00.280 --> 18:02.280]  их отличить.
[18:02.280 --> 18:04.280]  Ну, соответственно, так делать
[18:04.280 --> 18:06.280]  можно теперь.
[18:06.280 --> 18:08.280]  Вот да, если
[18:08.280 --> 18:10.280]  требования в них могут
[18:10.280 --> 18:12.280]  навременно выполниться, то у вас будет
[18:12.280 --> 18:14.280]  амбигиус кол, то, что называется.
[18:14.280 --> 18:16.280]  Ну, как бы компилятор не знает,
[18:16.280 --> 18:18.280]  что выбрать, это или это. Они оба подходят.
[18:18.280 --> 18:20.280]  А вот
[18:20.280 --> 18:22.280]  теперь пришло время поговорить как раз
[18:22.280 --> 18:24.280]  про то, как, собственно, работает
[18:24.280 --> 18:26.280]  вызов функции
[18:26.280 --> 18:28.280]  в C++. Вы думали, вы знаете? Нет, вы не знаете.
[18:28.280 --> 18:30.280]  Три этапа таких
[18:30.280 --> 18:32.280]  общих.
[18:32.280 --> 18:34.280]  Конечно, все это в гораздо больших деталях
[18:34.280 --> 18:36.280]  можно освещать, но
[18:36.280 --> 18:38.280]  это дома, заперевшись в ванной, читаете
[18:38.280 --> 18:40.280]  стандарт. Три главных этапа
[18:40.280 --> 18:42.280]  это поиск всех имен, которые
[18:42.280 --> 18:44.280]  подходят. Вот про это еще в прошлый раз
[18:44.280 --> 18:46.280]  мы что-то говорили немножко, да,
[18:46.280 --> 18:48.280]  что, видя в тексте
[18:48.280 --> 18:50.280]  программы какое-то имя, компилятор
[18:50.280 --> 18:52.280]  шагает искать, какие сущности
[18:52.280 --> 18:54.280]  определенные в программе подходят
[18:54.280 --> 18:56.280]  к этому имени. Они там в правильных
[18:56.280 --> 18:58.280]  namespace должны лежать, там как-то
[18:58.280 --> 19:00.280]  аргументы еще могут влиять, еще
[19:00.280 --> 19:02.280]  что-то. Вот ищем имена.
[19:02.280 --> 19:04.280]  Нашли множество имен.
[19:04.280 --> 19:06.280]  Что в этом множестве имен для функции может быть
[19:06.280 --> 19:08.280]  для вызова функции?
[19:12.280 --> 19:14.280]  Какие сущности
[19:14.280 --> 19:16.280]  для выражения вызова функции?
[19:18.280 --> 19:20.280]  Ну, функции-то да. Могут функции
[19:20.280 --> 19:22.280]  методы еще.
[19:24.280 --> 19:26.280]  Шаблоны.
[19:26.280 --> 19:28.280]  Вот, это то, что хотел услышать.
[19:28.280 --> 19:30.280]  Принципиальная разница между ними есть.
[19:30.280 --> 19:32.280]  У вас этот сет множества
[19:32.280 --> 19:34.280]  имен, оно состоит из
[19:34.280 --> 19:36.280]  функций, ну там любых неважных методов,
[19:36.280 --> 19:38.280]  что угодно, и шаблонов.
[19:38.280 --> 19:40.280]  И вот если функцию вы можете просто взять
[19:40.280 --> 19:42.280]  и вызвать, то шаблон еще надо инстанцировать,
[19:42.280 --> 19:44.280]  как-то что-то там сделать, найти.
[19:44.280 --> 19:46.280]  Поэтому принципиально по-разному
[19:46.280 --> 19:48.280]  мы их обрабатываем. Ну, то есть
[19:48.280 --> 19:50.280]  имена функций мы там
[19:50.280 --> 19:52.280]  на следующий этап прокидываем и пофиг,
[19:52.280 --> 19:54.280]  а вот имена шаблонов, для них второй этап
[19:54.280 --> 19:56.280]  делается. Мы выводим
[19:56.280 --> 19:58.280]  типы, если они явно не указаны,
[19:58.280 --> 20:00.280]  в прошлый раз говорили, можно вызвать шаблонную
[20:00.280 --> 20:02.280]  функцию, не указав шаблонные аргументы, нам их
[20:02.280 --> 20:04.280]  выведут. Вот ровно здесь оно
[20:04.280 --> 20:06.280]  происходит, а потом
[20:06.280 --> 20:08.280]  подстановка собственно шаблонных аргументов
[20:08.280 --> 20:10.280]  и инстанциация шаблона.
[20:10.280 --> 20:12.280]  Вот она здесь происходит.
[20:12.280 --> 20:14.280]  Если вы помните еще что-то про
[20:14.280 --> 20:16.280]  SFINAE, то это вот
[20:16.280 --> 20:18.280]  ровно вот про это.
[20:18.280 --> 20:20.280]  Инстанцируется сигнатура,
[20:20.280 --> 20:22.280]  именно сигнатура только,
[20:22.280 --> 20:24.280]  функция. Если происходит ошибка,
[20:24.280 --> 20:26.280]  вот при инстанциации
[20:26.280 --> 20:28.280]  этой сигнатуры,
[20:28.280 --> 20:30.280]  что одной из множества,
[20:30.280 --> 20:32.280]  мы ошибку не выдаем,
[20:32.280 --> 20:34.280]  мы просто выкидываем
[20:34.280 --> 20:36.280]  из нашего множества эту функцию.
[20:38.280 --> 20:40.280]  Вспомнили, что такое SFINAE с этой точки зрения?
[20:40.280 --> 20:42.280]  Я надеюсь.
[20:42.280 --> 20:44.280]  Возможно, здесь стоит прилепить какую-нибудь диаграмму
[20:44.280 --> 20:46.280]  со стрелочками, но уж не судьба.
[20:46.280 --> 20:48.280]  И последний этап.
[20:48.280 --> 20:50.280]  Теперь у нас
[20:50.280 --> 20:52.280]  в множестве есть только функции,
[20:52.280 --> 20:54.280]  шаблонов больше нет. Мы их все заинстанцировали,
[20:54.280 --> 20:56.280]  затайп дидюсили.
[20:56.280 --> 20:58.280]  Теперь есть только
[20:58.280 --> 21:00.280]  названия, какие-то сущности функции,
[21:00.280 --> 21:02.280]  берем и выбираем из них
[21:02.280 --> 21:04.280]  наилучшую. Вот это вот overload resolution
[21:04.280 --> 21:06.280]  называется как раз.
[21:06.280 --> 21:08.280]  Ну и вам там когда-то, наверное, Илья
[21:08.280 --> 21:10.280]  рассказывал долго и нудно, что там какие-то правила,
[21:10.280 --> 21:12.280]  кто лучше подходит, инты там, клангам,
[21:12.280 --> 21:14.280]  что-то вот, ну, про это не будем.
[21:14.280 --> 21:16.280]  Это скучно и нудно, и оно не
[21:16.280 --> 21:18.280]  поменялось. А поменялся второй этап.
[21:18.280 --> 21:20.280]  C++20.
[21:20.280 --> 21:22.280]  Теперь у вас
[21:22.280 --> 21:24.280]  самым последним шагом
[21:24.280 --> 21:26.280]  в втором пункте проверяют
[21:26.280 --> 21:28.280]  констраинты.
[21:28.280 --> 21:30.280]  Вот те самые, про которые мы сейчас начали
[21:30.280 --> 21:32.280]  говорить. То есть мы уже там
[21:32.280 --> 21:34.280]  подставили,
[21:34.280 --> 21:36.280]  вывели типы,
[21:36.280 --> 21:38.280]  подставили в сигнатуру
[21:38.280 --> 21:40.280]  функции эти
[21:40.280 --> 21:42.280]  типы и выкинули функцию с рассмотрения,
[21:42.280 --> 21:44.280]  если там свиная произошла.
[21:44.280 --> 21:46.280]  И дальше уже идем проверять констраинты.
[21:46.280 --> 21:48.280]  Если они не удовлетворены,
[21:48.280 --> 21:50.280]  тоже выкидываем функцию.
[21:50.280 --> 21:52.280]  Вот.
[21:52.280 --> 21:54.280]  Собственно, это и позволяет
[21:54.280 --> 21:56.280]  нам вот за счет
[21:56.280 --> 21:58.280]  этих реквайерсов
[21:58.280 --> 22:00.280]  как-то перегружать еще более хитро.
[22:00.280 --> 22:02.280]  Потому что мы просто
[22:02.280 --> 22:04.280]  фильтруем вот это вот множество найденных
[22:04.280 --> 22:06.280]  имен по каким-то там предикатам
[22:06.280 --> 22:08.280]  относительно шаблонных аргументов.
[22:08.280 --> 22:10.280]  Окей.
[22:10.280 --> 22:12.280]  Надеюсь, вот это вот вы не будете упускать
[22:12.280 --> 22:14.280]  из головы или запомните, что такое
[22:14.280 --> 22:16.280]  есть и сможете потом нагуглить просто,
[22:16.280 --> 22:18.280]  потому что когда у вас адские ошибки
[22:18.280 --> 22:20.280]  шаблонные происходят, нередко приходится
[22:20.280 --> 22:22.280]  на это как-то ориентироваться, чтобы понять
[22:22.280 --> 22:24.280]  что вообще происходит.
[22:24.280 --> 22:26.280]  Но мы идем дальше.
[22:26.280 --> 22:28.280]  Что вообще в констраинты можно вписывать?
[22:28.280 --> 22:30.280]  Вот реквайерс
[22:30.280 --> 22:32.280]  и что дальше? Ну я сказал там бульевые выражения,
[22:32.280 --> 22:34.280]  но не только.
[22:34.280 --> 22:36.280]  Конечно, можно писать вот эти концепты
[22:36.280 --> 22:38.280]  загадочные, пока их не существует.
[22:38.280 --> 22:40.280]  И можно писать конъюнкцию и дизъюнкцию.
[22:40.280 --> 22:42.280]  Но конъюнкция
[22:42.280 --> 22:44.280]  и дизъюнкция они
[22:44.280 --> 22:46.280]  они не простые, они золотые.
[22:46.280 --> 22:48.280]  Ну и вот в ближайшие
[22:48.280 --> 22:50.280]  10 слайдов мы будем пытаться подобраться к тому,
[22:50.280 --> 22:52.280]  чтобы понять, что там за конъюнкция и дизъюнкция
[22:52.280 --> 22:54.280]  и почему они золотые, а не обычные.
[22:54.280 --> 22:56.280]  А...
[22:56.280 --> 22:58.280]  Да.
[23:00.280 --> 23:02.280]  Какие-то вот слова
[23:02.280 --> 23:04.280]  говорить и по факту
[23:04.280 --> 23:06.280]  непонятно, что они значат. Поэтому сейчас
[23:06.280 --> 23:08.280]  будем очень подробно это все демонстрировать.
[23:08.280 --> 23:10.280]  На примере вот этого.
[23:10.280 --> 23:12.280]  А походу дело еще и с констекспроме разберемся.
[23:12.280 --> 23:14.280]  Функция.
[23:14.280 --> 23:16.280]  Тут написан какой-то код. Давайте
[23:16.280 --> 23:18.280]  секунду. Две даю, чтобы посмотреть.
[23:20.280 --> 23:22.280]  Что такое
[23:22.280 --> 23:24.280]  StaticStream? InputFileStream.
[23:24.280 --> 23:26.280]  Короче, мы
[23:26.280 --> 23:28.280]  читаем из файла int и возвращаем.
[23:28.280 --> 23:30.280]  Функция.
[23:32.280 --> 23:34.280]  Я геймдевелопер.
[23:34.280 --> 23:36.280]  У нас не существует исключений.
[23:36.280 --> 23:38.280]  Они отменены.
[23:38.280 --> 23:40.280]  Если файла нет, то чего?
[23:40.280 --> 23:42.280]  Есть.
[23:42.280 --> 23:44.280]  Ну патч выпустишь,
[23:44.280 --> 23:46.280]  пофиксишь баг. Ну какие проблемы?
[23:48.280 --> 23:50.280]  Зачем это все нужно?
[23:50.280 --> 23:52.280]  Да.
[23:52.280 --> 23:54.280]  Зачем это нам нужно? Эту функцию нельзя
[23:54.280 --> 23:56.280]  посчитать в компайлтайме. Согласна?
[23:56.280 --> 23:58.280]  Просто нельзя и все. Там какие-то
[23:58.280 --> 24:00.280]  исключения есть, еще что-то. Нельзя и
[24:00.280 --> 24:02.280]  отлично. Запомнили, да?
[24:02.280 --> 24:04.280]  Дальше везде она будет.
[24:04.280 --> 24:06.280]  LoadConstants, повсюду еще 10 слайдов,
[24:06.280 --> 24:08.280]  надо помнить. Ее нельзя в компайлтайме.
[24:08.280 --> 24:10.280]  Добавляем вот такой кусок
[24:10.280 --> 24:12.280]  кода.
[24:12.280 --> 24:14.280]  Здесь constexpr функция,
[24:14.280 --> 24:16.280]  которая в одной ветке
[24:16.280 --> 24:18.280]  просто возвращает x, а в другой
[24:18.280 --> 24:20.280]  ветке умножает его на
[24:20.280 --> 24:22.280]  загруженные с файла значения.
[24:22.280 --> 24:24.280]  Скомпилируется ли это?
[24:24.280 --> 24:26.280]  Кажется.
[24:26.280 --> 24:28.280]  С какого-то стандарта
[24:28.280 --> 24:30.280]  можно не constexpr функцию
[24:30.280 --> 24:32.280]  в теле constexpr.
[24:32.280 --> 24:34.280]  Ну в общем, да, вы правы.
[24:34.280 --> 24:36.280]  Это скомпилируется вот в таком виде.
[24:36.280 --> 24:38.280]  Пятерочку сюда вставили,
[24:38.280 --> 24:40.280]  выбралась первая ветка,
[24:40.280 --> 24:42.280]  все работает.
[24:42.280 --> 24:44.280]  Просто 5 вернули.
[24:44.280 --> 24:46.280]  А вот так, ну,
[24:46.280 --> 24:48.280]  я думаю, понятно, что
[24:48.280 --> 24:50.280]  уже без вариантов не должно это
[24:50.280 --> 24:52.280]  компилироваться.
[24:52.280 --> 24:54.280]  Почему так
[24:54.280 --> 24:56.280]  происходит?
[24:56.280 --> 24:58.280]  Куда?
[24:58.280 --> 25:00.280]  А, нет, еще один вопрос.
[25:00.280 --> 25:02.280]  А вот так скомпилируется?
[25:02.280 --> 25:04.280]  А до этого
[25:04.280 --> 25:06.280]  constexpr?
[25:06.280 --> 25:08.280]  Ага, все, вы включились.
[25:08.280 --> 25:10.280]  До этого был constexpr.
[25:10.280 --> 25:12.280]  Да, то есть
[25:12.280 --> 25:14.280]  вот так нет, потому что мы потребовали
[25:14.280 --> 25:16.280]  в compile-time вычислить функцию
[25:16.280 --> 25:18.280]  compute, а вот так мы сделали,
[25:18.280 --> 25:20.280]  и уже все нормально будет.
[25:20.280 --> 25:22.280]  Потому что, ну, функция compute и функция
[25:22.280 --> 25:24.280]  compute, вычислим ее в run-time.
[25:24.280 --> 25:26.280]  Не важно, что на constexpr отмечено,
[25:26.280 --> 25:28.280]  это нас ни к чему не обязывает.
[25:28.280 --> 25:30.280]  Вот мораль всего этого,
[25:30.280 --> 25:32.280]  что constexpr это рекомендация вообще-то
[25:32.280 --> 25:34.280]  для функций. Она говорит,
[25:34.280 --> 25:36.280]  я разрешаю тебе
[25:36.280 --> 25:38.280]  компилятор, считать эту функцию в compile-time,
[25:38.280 --> 25:40.280]  если можешь,
[25:40.280 --> 25:42.280]  пожалуйста, посчитай.
[25:42.280 --> 25:44.280]  Ну, и сам обязуюсь там какие-то вещи вообще
[25:44.280 --> 25:46.280]  делать. Ну, вот тут
[25:46.280 --> 25:48.280]  написано, какие вещи вы как программисты обязуетесь
[25:48.280 --> 25:50.280]  делать, указав функцию constexpr.
[25:50.280 --> 25:52.280]  Литеральный тип
[25:52.280 --> 25:54.280]  для аргументов, для ретерна.
[25:54.280 --> 25:56.280]  Ну,
[25:56.280 --> 25:58.280]  что такое литеральный тип вообще, не будем
[25:58.280 --> 26:00.280]  говорить. Какие-то инты, флоты, все работает.
[26:00.280 --> 26:02.280]  Тыкайтесь, смотрите, работает или нет.
[26:02.280 --> 26:04.280]  В зависимости от стандарта, разные
[26:04.280 --> 26:06.280]  вещи работают, так что вообще убой
[26:06.280 --> 26:08.280]  ни в коем случае не надо пытаться
[26:08.280 --> 26:10.280]  запомнить.
[26:10.280 --> 26:12.280]  Что?
[26:12.280 --> 26:14.280]  Структуры тоже литеральные,
[26:14.280 --> 26:16.280]  но с некоторыми оговорками.
[26:16.280 --> 26:18.280]  Надо просто тыкнуться, попробовать, если сработает
[26:18.280 --> 26:20.280]  класс.
[26:20.280 --> 26:22.280]  Нас интересует больше всего
[26:22.280 --> 26:24.280]  последний пункт.
[26:24.280 --> 26:26.280]  Хотя бы для одного набора
[26:26.280 --> 26:28.280]  аргументов функцию должно быть
[26:28.280 --> 26:30.280]  можно вычислить в compile-time.
[26:30.280 --> 26:32.280]  Угадайте, что иначе.
[26:34.280 --> 26:36.280]  Убе.
[26:36.280 --> 26:38.280]  Как ты это проверишь?
[26:38.280 --> 26:40.280]  Проблема останова эквивалентно.
[26:40.280 --> 26:42.280]  Не может компилятор проверить,
[26:42.280 --> 26:44.280]  что все нормально будет.
[26:48.280 --> 26:50.280]  Нет, просто убе.
[26:50.280 --> 26:52.280]  Ты не понимаешь,
[26:52.280 --> 26:54.280]  суть убе.
[26:54.280 --> 26:56.280]  Давайте повторим суть убе.
[26:56.280 --> 26:58.280]  Убе это значит, что
[26:58.280 --> 27:00.280]  ваша программа не является программой
[27:00.280 --> 27:02.280]  на C++.
[27:02.280 --> 27:04.280]  Это не обязывает ни компилятор
[27:04.280 --> 27:06.280]  ни к чему, ни итоговый бинарь,
[27:06.280 --> 27:08.280]  который у вас компилируется, если вам повезет
[27:08.280 --> 27:10.280]  ни к чему. Может произойти все, что угодно.
[27:10.280 --> 27:12.280]  А
[27:12.280 --> 27:14.280]  соответственно, тут тоже компилятор
[27:14.280 --> 27:16.280]  старается проверять убе.
[27:16.280 --> 27:18.280]  Есть всякие проверочки, которые
[27:18.280 --> 27:20.280]  компилятор способен сделать, какое-нибудь разыменование
[27:20.280 --> 27:22.280]  nullptr, если вы прямо напишете
[27:22.280 --> 27:24.280]  in звездочка равно null и разыменуйте.
[27:24.280 --> 27:26.280]  То вам, конечно, компилятор скажет,
[27:26.280 --> 27:28.280]  так ты же тут null написал, как ты его разыменуешь.
[27:28.280 --> 27:30.280]  Но
[27:30.280 --> 27:32.280]  в общем случае, вот как понять,
[27:32.280 --> 27:34.280]  есть ли набор аргументов,
[27:34.280 --> 27:36.280]  при котором можно запустить
[27:36.280 --> 27:38.280]  функцию в compile-time.
[27:38.280 --> 27:40.280]  Давайте
[27:40.280 --> 27:42.280]  вспомним matlog.
[27:42.280 --> 27:44.280]  Там была замечательная теорема.
[27:44.280 --> 27:46.280]  Кто-нибудь вспомнит ее название.
[27:46.280 --> 27:48.280]  Что-то там нетривиальное множество
[27:48.280 --> 27:50.280]  программ
[27:50.280 --> 27:52.280]  не является
[27:52.280 --> 27:54.280]  разрешимым.
[27:54.280 --> 27:56.280]  Не помните?
[27:56.280 --> 27:58.280]  Клине?
[27:58.280 --> 28:00.280]  А?
[28:00.280 --> 28:02.280]  А может и не клине?
[28:02.280 --> 28:04.280]  Ну я тоже не помню.
[28:04.280 --> 28:06.280]  Но суть теоремы помните, надеюсь,
[28:06.280 --> 28:08.280]  что вот любое нетривиальное свойство для программ
[28:08.280 --> 28:10.280]  выбрали, и вы уже его не умеете
[28:10.280 --> 28:12.280]  проверять. Не вычислимо.
[28:12.280 --> 28:14.280]  Вот и все.
[28:14.280 --> 28:16.280]  Ну и свойство вот это, оно тоже
[28:16.280 --> 28:18.280]  как бы не вычислимо. Поэтому компилятор вам помочь
[28:18.280 --> 28:20.280]  не сможет. Если ваш там
[28:20.280 --> 28:22.280]  функция ни при каких наборах
[28:22.280 --> 28:24.280]  аргументов не компилируется
[28:24.280 --> 28:26.280]  в нельзя
[28:26.280 --> 28:28.280]  выполнить в compile-time,
[28:28.280 --> 28:30.280]  то у вас вообще-то UB.
[28:30.280 --> 28:32.280]  Ну то есть какая дальше развитие событий может быть?
[28:32.280 --> 28:34.280]  Вы реально эту функцию зовете и вам реально скажут
[28:34.280 --> 28:36.280]  ой, я не могу с таким набором аргументов
[28:36.280 --> 28:38.280]  вычислить, все плохо. А может вы такую
[28:38.280 --> 28:40.280]  функцию не зовете, но это все равно UB
[28:40.280 --> 28:42.280]  и ваша программа все равно не считается
[28:42.280 --> 28:44.280]  программной C++.
[28:44.280 --> 28:46.280]  О!
[28:48.280 --> 28:50.280]  Не знаю.
[28:50.280 --> 28:52.280]  Наверное смысл в том, чтобы
[28:52.280 --> 28:54.280]  тебя в тонусе держать.
[28:54.280 --> 28:56.280]  Ты должен чувствовать боль,
[28:56.280 --> 28:58.280]  чувствовать вот это вот, что на иголках,
[28:58.280 --> 29:00.280]  на иголках. Всегда проверяй
[29:00.280 --> 29:02.280]  что ты пишешь. Если хотя бы одного набора
[29:02.280 --> 29:04.280]  нет, то все, твою программу
[29:04.280 --> 29:06.280]  сломаем.
[29:06.280 --> 29:08.280]  Да ничего не будет на самом деле, все нормально
[29:08.280 --> 29:10.280]  будет.
[29:10.280 --> 29:12.280]  Это одно из тех мест, где все нормально на самом
[29:12.280 --> 29:14.280]  деле будет. Но это как бы
[29:14.280 --> 29:16.280]  и ограничение, и развязывает нам руки.
[29:16.280 --> 29:18.280]  Это все
[29:18.280 --> 29:20.280]  к тому, что у нас с констраксом
[29:20.280 --> 29:22.280]  компилируется, отбесы нет.
[29:22.280 --> 29:24.280]  Да, потому что, заметь,
[29:24.280 --> 29:26.280]  не для всех. Здесь квантер,
[29:26.280 --> 29:28.280]  существование не всеобщности. Вот это самое главное
[29:28.280 --> 29:30.280]  на самом деле.
[29:30.280 --> 29:32.280]  То есть у тебя может быть только один набор
[29:32.280 --> 29:34.280]  аргументов, с которыми все работает и в компелтайме
[29:34.280 --> 29:36.280]  вычисляется, а все остальные наборы аргументов
[29:36.280 --> 29:38.280]  ну ничего работать не будет. За счет этого
[29:38.280 --> 29:40.280]  и работает вот этот пример, что
[29:40.280 --> 29:42.280]  вот так нельзя, вот так можно. Вот с этим набором
[29:42.280 --> 29:44.280]  аргументов все компилируется, а с этим нет.
[29:44.280 --> 29:46.280]  То есть оно как бы и
[29:46.280 --> 29:48.280]  развязывает нам руки с одной стороны,
[29:48.280 --> 29:50.280]  а с другой стороны, ну нафига они
[29:50.280 --> 29:52.280]  впихнули это сюда.
[29:52.280 --> 29:54.280]  Почему от list1? Почему нельзя
[29:54.280 --> 29:56.280]  зачем undefined behavior
[29:56.280 --> 29:58.280]  на ровном месте в стандарт впихивать?
[29:58.280 --> 30:00.280]  Ну возможно.
[30:02.280 --> 30:04.280]  Ну вообще
[30:04.280 --> 30:06.280]  ну просто
[30:06.280 --> 30:08.280]  позволить.
[30:10.280 --> 30:12.280]  Ну не знаю. Короче, это вот
[30:12.280 --> 30:14.280]  странное место, что они вот так вот
[30:14.280 --> 30:16.280]  компилировали, но будьте внимательны.
[30:16.280 --> 30:18.280]  Меняем
[30:18.280 --> 30:20.280]  красная стрелочка.
[30:22.280 --> 30:24.280]  Новое слово
[30:24.280 --> 30:26.280]  для кого-то.
[30:26.280 --> 30:28.280]  Предположите, что оно значит.
[30:30.280 --> 30:32.280]  Да, это значит, что функция всегда
[30:32.280 --> 30:34.280]  считается только в компелтайме.
[30:34.280 --> 30:36.280]  Вы запрещаете компилятору
[30:36.280 --> 30:38.280]  считать ее в рентайме.
[30:38.280 --> 30:40.280]  Ну и такой код просто
[30:40.280 --> 30:42.280]  скомпилируется, потому что
[30:42.280 --> 30:44.280]  ну там всякая ленивость, он даже смотреть
[30:44.280 --> 30:46.280]  внутри этой функции не будет, но как только вы
[30:46.280 --> 30:48.280]  вот так напишете,
[30:48.280 --> 30:50.280]  вопрос.
[30:50.280 --> 30:52.280]  Скомпилируется или нет?
[30:52.280 --> 30:54.280]  Да,
[30:54.280 --> 30:56.280]  все то же самое.
[30:56.280 --> 30:58.280]  Там все еще точно такие же ограничения,
[30:58.280 --> 31:00.280]  что ну типа мы не
[31:00.280 --> 31:02.280]  проверяем для всех наборов аргументов,
[31:02.280 --> 31:04.280]  мы для конкретного. Вот пятерка.
[31:04.280 --> 31:06.280]  Можно в компелтайме с пятеркой вычислить?
[31:06.280 --> 31:08.280]  Можно. Вычисляем, получаем 5.
[31:08.280 --> 31:10.280]  О,
[31:10.280 --> 31:12.280]  ну вот так
[31:12.280 --> 31:14.280]  точно нет,
[31:14.280 --> 31:16.280]  а вот так тоже нет.
[31:16.280 --> 31:18.280]  Потому что теперь мы
[31:18.280 --> 31:20.280]  компилятор как бы увидит.
[31:20.280 --> 31:22.280]  Нужно в компилтайме вообще-то,
[31:22.280 --> 31:24.280]  потому что конставал написано,
[31:24.280 --> 31:26.280]  а мы не можем, и все.
[31:26.280 --> 31:28.280]  Окей, ну я думаю,
[31:28.280 --> 31:30.280]  тогда должно быть понятно, зачем вообще ключевое слово
[31:30.280 --> 31:32.280]  конставал добавили.
[31:32.280 --> 31:34.280]  Иногда мы хотим гарантировать себе,
[31:34.280 --> 31:36.280]  что вот это сложное вычисление, которое
[31:36.280 --> 31:38.280]  предподсчитывает какую-нибудь таблицу
[31:38.280 --> 31:40.280]  прыжков куда-нибудь, чего-нибудь,
[31:40.280 --> 31:42.280]  мы хотим гарантировать, что оно в компилтайме
[31:42.280 --> 31:44.280]  считается.
[31:44.280 --> 31:46.280]  Пример, когда аргумент 5
[31:46.280 --> 31:48.280]  и нет констэкспор?
[31:48.280 --> 31:50.280]  Ну, когда аргумент 5
[31:50.280 --> 31:52.280]  и на переменной нет констэкспор,
[31:52.280 --> 31:54.280]  вопрос к вам, что будет?
[31:54.280 --> 31:56.280]  Ну, в принципе да.
[31:56.280 --> 31:58.280]  Ну, вернее как?
[31:58.280 --> 32:00.280]  Не факт.
[32:00.280 --> 32:02.280]  Потому что я вот не уверен,
[32:02.280 --> 32:04.280]  если вы констэкспор здесь напишете, и здесь
[32:04.280 --> 32:06.280]  5, будет ли он вычислять в компилтайме?
[32:06.280 --> 32:08.280]  Наверное, будет.
[32:08.280 --> 32:10.280]  А может и нет.
[32:10.280 --> 32:12.280]  Да вот в том-то и дело,
[32:12.280 --> 32:14.280]  что по-моему не делает.
[32:14.280 --> 32:16.280]  И ради этого еще одно ключевое слово добавили в C++.
[32:16.280 --> 32:18.280]  Да.
[32:18.280 --> 32:20.280]  Которого, да, кстати, у меня в презентации нет.
[32:20.280 --> 32:22.280]  Давайте я вам быстренько скажу.
[32:22.280 --> 32:24.280]  Можно перед переменными теперь писать
[32:24.280 --> 32:26.280]  const init.
[32:26.280 --> 32:28.280]  Это что говорит? Что переменная, она обычная.
[32:28.280 --> 32:30.280]  Это просто обычная глобальная
[32:30.280 --> 32:32.280]  переменная, но мы хотим,
[32:32.280 --> 32:34.280]  чтобы выражение,
[32:34.280 --> 32:36.280]  которое она инициализируется,
[32:36.280 --> 32:38.280]  вычислили в компилтайме.
[32:38.280 --> 32:40.280]  Почему-то она и в констэкспор отличается.
[32:40.280 --> 32:42.280]  Констэкспорт переменная,
[32:42.280 --> 32:44.280]  она еще и константная.
[32:44.280 --> 32:46.280]  А const init только
[32:46.280 --> 32:48.280]  инициализируется в компилтайме.
[32:48.280 --> 32:50.280]  А дальше в рантайме ты ее менять можешь.
[32:50.280 --> 32:52.280]  Неужели функционал спориальный кому-то нужен?
[32:52.280 --> 32:54.280]  Кому-то нужен, да, в embedded.
[32:54.280 --> 32:56.280]  Там ребята пишут под
[32:56.280 --> 32:58.280]  микропроцессоры всякие,
[32:58.280 --> 33:00.280]  с частотой полгерца,
[33:00.280 --> 33:02.280]  не знаю, и вот им очень важно.
[33:04.280 --> 33:06.280]  Да-да-да, всякие вышки там
[33:06.280 --> 33:08.280]  мобильные, какие-нибудь...
[33:10.280 --> 33:12.280]  Короче, им бед везде.
[33:16.280 --> 33:18.280]  Да, это тоже полезно, но
[33:18.280 --> 33:20.280]  мне не удается на работе добиться,
[33:20.280 --> 33:22.280]  чтобы что-то констанитилось, потому что
[33:22.280 --> 33:24.280]  пока тяжело.
[33:24.280 --> 33:26.280]  Все плохо.
[33:26.280 --> 33:28.280]  Можно вопрос?
[33:28.280 --> 33:30.280]  Если вернуться на несколько свадебных данных,
[33:30.280 --> 33:32.280]  где у нас был вот так,
[33:32.280 --> 33:34.280]  в видеорке.
[33:34.280 --> 33:36.280]  Здесь мы пришли к лучшему, что скомпилировали.
[33:36.280 --> 33:38.280]  Так же, как констэкспорт.
[33:38.280 --> 33:40.280]  С точки зрения стандарта,
[33:40.280 --> 33:42.280]  программа корректная?
[33:42.280 --> 33:44.280]  Да.
[33:44.280 --> 33:46.280]  То, что скомпилировалось,
[33:46.280 --> 33:48.280]  еще не значит, что...
[33:48.280 --> 33:50.280]  Это абсолютно корректно, с точки зрения стандарта
[33:50.280 --> 33:52.280]  все нормально. По крайней мере, я так думаю,
[33:52.280 --> 33:54.280]  но уверенным в этом никогда нельзя быть.
[33:54.280 --> 33:56.280]  Просто здесь же...
[33:56.280 --> 33:58.280]  Ты сказал, что не проявляется для всех
[33:58.280 --> 34:00.280]  аргументов потенциальных.
[34:00.280 --> 34:02.280]  Это избыточно было бы делать, потому что достаточно
[34:02.280 --> 34:04.280]  АСТ посмотреть просто.
[34:04.280 --> 34:06.280]  У нас в одной из веток вызов функции...
[34:06.280 --> 34:08.280]  Так ты забываешь про теорему Клини вроде.
[34:08.280 --> 34:10.280]  Теорема Клини говорит, что
[34:10.280 --> 34:12.280]  смотри на АСТ, не смотри, ты все равно
[34:12.280 --> 34:14.280]  никакое нетривиальное свойство точно
[34:14.280 --> 34:16.280]  проверить не сможешь. Только евристически.
[34:16.280 --> 34:18.280]  То есть это может быть включать какими-нибудь
[34:18.280 --> 34:20.280]  дополнительными отцами проверки,
[34:20.280 --> 34:22.280]  но это точно должно быть в стандарте.
[34:22.280 --> 34:24.280]  Да, ты не можешь в стандарте требовать
[34:24.280 --> 34:26.280]  от людей решать проблему останова.
[34:28.280 --> 34:30.280]  Это центральная идея стандарта.
[34:30.280 --> 34:32.280]  И вот должно быть возможно написать
[34:32.280 --> 34:34.280]  в виде компилятора. Если это невозможно,
[34:34.280 --> 34:36.280]  то это плохой стандарт.
[34:36.280 --> 34:38.280]  Давайте дальше поедем.
[34:40.280 --> 34:42.280]  Да, const и val на функциях
[34:42.280 --> 34:44.280]  значит, эту функцию запрещено
[34:44.280 --> 34:46.280]  считать в run-time, только в compile-time.
[34:48.280 --> 34:50.280]  То есть вот...
[34:50.280 --> 34:52.280]  Вот такая штука все равно даст ошибку тебе.
[34:52.280 --> 34:54.280]  Потому что ты функцию пометила
[34:54.280 --> 34:56.280]  как const и val,
[34:56.280 --> 34:58.280]  это значит, что в run-time ее считать нельзя,
[34:58.280 --> 35:00.280]  а в compile-time мы
[35:00.280 --> 35:02.280]  умрем из-за того, что
[35:02.280 --> 35:04.280]  из файла читаем число.
[35:04.280 --> 35:06.280]  А когда здесь был const export,
[35:06.280 --> 35:08.280]  это была рекомендация.
[35:08.280 --> 35:10.280]  Можно в compile-time,
[35:10.280 --> 35:12.280]  если тебе нужно.
[35:12.280 --> 35:14.280]  То есть мы не можем написать
[35:14.280 --> 35:16.280]  for там,
[35:16.280 --> 35:18.280]  say in что-то,
[35:18.280 --> 35:20.280]  и в зависимости от того,
[35:20.280 --> 35:22.280]  что вышло, вызвать в компьютере.
[35:22.280 --> 35:24.280]  То есть мы так написать уже
[35:24.280 --> 35:26.280]  не можем, если она const и val.
[35:26.280 --> 35:28.280]  Если у тебя в зависимости от того,
[35:28.280 --> 35:30.280]  что пришло...
[35:30.280 --> 35:32.280]  Я вызываю хорошую функцию,
[35:32.280 --> 35:34.280]  а пришла двоечка
[35:34.280 --> 35:36.280]  или ноль,
[35:36.280 --> 35:38.280]  вызываю в компьютере. Так написать не могу.
[35:38.280 --> 35:40.280]  Да, потому что у тебя компилятор
[35:40.280 --> 35:42.280]  должен знать значение этой функции.
[35:42.280 --> 35:44.280]  Если по-простому сказать,
[35:44.280 --> 35:46.280]  то в const и val функцию
[35:46.280 --> 35:48.280]  можно только const export переменные
[35:48.280 --> 35:50.280]  подставлять, если совсем
[35:50.280 --> 35:52.280]  по-простому. На самом деле, конечно же,
[35:52.280 --> 35:54.280]  там опять правила, вот эти вот
[35:54.280 --> 35:56.280]  constant expressions прекрасные.
[35:56.280 --> 35:58.280]  То есть const int тоже можно
[35:58.280 --> 36:00.280]  подставить в const и val функцию.
[36:06.280 --> 36:08.280]  Нет.
[36:08.280 --> 36:10.280]  Я знаю, что в Rasty подобные штуки
[36:10.280 --> 36:12.280]  появляются, но
[36:12.280 --> 36:14.280]  в Kotlin тоже мне кто-то, кажется,
[36:14.280 --> 36:16.280]  рассказывал. Но нет, у нас такого
[36:16.280 --> 36:18.280]  пока нет, мы страдаем.
[36:20.280 --> 36:22.280]  Такого, чтобы компилятор
[36:22.280 --> 36:24.280]  по предшествующему коду мог
[36:24.280 --> 36:26.280]  делать предположения о дальнейшем коде.
[36:26.280 --> 36:28.280]  Например, видя if,
[36:28.280 --> 36:30.280]  помнить, что этот if...
[36:30.280 --> 36:32.280]  Вот если мы внутрь него зашли,
[36:32.280 --> 36:34.280]  компилятор как бы помнит, что это условие
[36:34.280 --> 36:36.280]  выполняется, и из этого
[36:36.280 --> 36:38.280]  делает какие-то дидактические выводы
[36:38.280 --> 36:40.280]  о свойстве всего, что внутри.
[36:40.280 --> 36:42.280]  Например, вот было if x
[36:42.280 --> 36:44.280]  равно равно 2,
[36:44.280 --> 36:46.280]  который с input ввели
[36:46.280 --> 36:48.280]  x,
[36:48.280 --> 36:50.280]  вот эту функцию compute от x вызываем.
[36:50.280 --> 36:52.280]  Казалось бы, компилятор мог догадаться.
[36:52.280 --> 36:54.280]  Мы только что проверили, что x равен 2.
[36:54.280 --> 36:56.280]  Пошли в ветку.
[36:56.280 --> 36:58.280]  И здесь, в этой ветке, x он всегда
[36:58.280 --> 37:00.280]  2. То есть выражение
[37:00.280 --> 37:02.280]  x, оно как бы константно,
[37:02.280 --> 37:04.280]  потому что мы внутри if, который проверяет,
[37:04.280 --> 37:06.280]  что он равен 2, но нет, мы так не умеем.
[37:06.280 --> 37:08.280]  Некоторые языки умеют.
[37:08.280 --> 37:10.280]  Ну вот да.
[37:10.280 --> 37:12.280]  Да.
[37:12.280 --> 37:14.280]  Некоторые языки умеют все это проверять.
[37:14.280 --> 37:16.280]  Они знают, когда он остался таким же
[37:16.280 --> 37:18.280]  двойкой, когда его изменили,
[37:18.280 --> 37:20.280]  а в плюсах так не получится.
[37:26.280 --> 37:28.280]  Все нормально.
[37:28.280 --> 37:30.280]  Да, но выражение
[37:30.280 --> 37:32.280]  тебе важно не переменные,
[37:32.280 --> 37:34.280]  от которых вызываешь, а выражение.
[37:34.280 --> 37:36.280]  Выражение, от которого ты вызываешь
[37:36.280 --> 37:38.280]  компьютер, должно быть константным.
[37:38.280 --> 37:40.280]  Литерал 2, константное выражение.
[37:40.280 --> 37:42.280]  Это если констэкспорт.
[37:42.280 --> 37:44.280]  Да.
[37:44.280 --> 37:46.280]  А если констэкспорт, то
[37:46.280 --> 37:48.280]  коль скоро у тебя все аргументы
[37:48.280 --> 37:50.280]  константные выражения, он, наверное,
[37:50.280 --> 37:52.280]  вызовет в компайл тайме.
[37:52.280 --> 37:54.280]  Если хотя бы одно из них не константное выражение,
[37:54.280 --> 37:56.280]  то точно в рантайме.
[37:56.280 --> 37:58.280]  По-моему, так.
[37:58.280 --> 38:00.280]  Констэнит, это
[38:00.280 --> 38:02.280]  только про переменные, оно говорит.
[38:02.280 --> 38:04.280]  У меня переменная
[38:04.280 --> 38:06.280]  инициализируется долго, там какой-то алгоритм
[38:06.280 --> 38:08.280]  вычисляет число p до 10
[38:08.280 --> 38:10.280]  знаков. Я хочу, чтобы ты
[38:10.280 --> 38:12.280]  этот алгоритм в компайл тайме запустил.
[38:12.280 --> 38:14.280]  То есть выражение,
[38:14.280 --> 38:16.280]  инициализирующее
[38:16.280 --> 38:18.280]  переменную, должно быть вычислено в компайл тайме.
[38:18.280 --> 38:20.280]  А потом эта переменная
[38:20.280 --> 38:22.280]  должна быть просто
[38:22.280 --> 38:24.280]  обычной переменной в рантайме, ее должно быть можно
[38:24.280 --> 38:26.280]  менять. То есть
[38:26.280 --> 38:28.280]  констэнит плюс конст
[38:28.280 --> 38:30.280]  равно констэкспорт для переменных.
[38:30.280 --> 38:32.280]  Вот так вот давайте запомним.
[38:32.280 --> 38:34.280]  То есть мы можем констэнит
[38:34.280 --> 38:36.280]  писать в ветках, которые в рантайме.
[38:36.280 --> 38:38.280]  В ветках, которые в рантайме.
[38:38.280 --> 38:40.280]  Нет.
[38:40.280 --> 38:42.280]  Вот инициализатор констэнит
[38:42.280 --> 38:44.280]  должен быть константным выражением,
[38:44.280 --> 38:46.280]  известному в момент компиляции.
[38:46.280 --> 38:48.280]  А потом
[38:48.280 --> 38:50.280]  можно менять уже эту переменную,
[38:50.280 --> 38:52.280]  как хочешь, в рантайме.
[38:52.280 --> 38:54.280]  Опять же, поступает число
[38:54.280 --> 38:56.280]  x равно 2.
[38:56.280 --> 38:58.280]  И дальше я пишу
[38:58.280 --> 39:00.280]  констэнит
[39:00.280 --> 39:02.280]  ин z равно компьют 100.
[39:02.280 --> 39:04.280]  Вот так я могу сделать? Да.
[39:04.280 --> 39:06.280]  Ну у тебя выражение компьют 100, а нет,
[39:06.280 --> 39:08.280]  100 давай 5.
[39:08.280 --> 39:10.280]  Компьют 5 можешь.
[39:10.280 --> 39:12.280]  Потому что компьют 5 это константное выражение.
[39:12.280 --> 39:14.280]  Ты потребовал, чтобы z
[39:14.280 --> 39:16.280]  инициализировалось в момент компиляции,
[39:16.280 --> 39:18.280]  оно инициализировалось в момент компиляции,
[39:18.280 --> 39:20.280]  а дальше по коду ты можешь сделать
[39:20.280 --> 39:22.280]  плюс-плюс z, например.
[39:22.280 --> 39:24.280]  Спокойно.
[39:24.280 --> 39:26.280]  То есть это констэкспорт, но без конст.
[39:26.280 --> 39:28.280]  Ну вот так
[39:28.280 --> 39:30.280]  странно. Давайте дальше ехать.
[39:38.280 --> 39:40.280]  Ну вот, честно говоря, я не уверен, что происходит,
[39:40.280 --> 39:42.280]  когда ты вот тут вот пишешь
[39:42.280 --> 39:44.280]  конст... Нет, сейчас.
[39:44.280 --> 39:46.280]  Вот когда у него есть
[39:46.280 --> 39:48.280]  выбор, по-моему, там ничего не требуется.
[39:48.280 --> 39:50.280]  В этом проблема. Он может
[39:50.280 --> 39:52.280]  решить так, а может решить всяко.
[39:52.280 --> 39:54.280]  Либо там какие-то правила очень сложные,
[39:54.280 --> 39:56.280]  предлагаю открыть стандарт и вот это
[39:56.280 --> 39:58.280]  вот вычитать. Давайте дальше ехать,
[39:58.280 --> 40:00.280]  у нас еще столько материала,
[40:00.280 --> 40:02.280]  а еще я вас прошу следить за временем,
[40:02.280 --> 40:04.280]  потому что я сейчас дико увлекусь, и нам нужно
[40:04.280 --> 40:06.280]  на перерыв. Еще полчаса,
[40:06.280 --> 40:08.280]  и мы идем на перерыв. Но за эти полчаса
[40:08.280 --> 40:10.280]  мы должны добить вот эту цепочку рассуждений.
[40:10.280 --> 40:12.280]  Я напомню, что про все это мы не по приколу
[40:12.280 --> 40:14.280]  начали рассуждать, а потому что
[40:14.280 --> 40:16.280]  я сказал, пообещал,
[40:16.280 --> 40:18.280]  что в констрейнтах
[40:18.280 --> 40:20.280]  волшебные два амперсанда
[40:20.280 --> 40:22.280]  и две палки.
[40:22.280 --> 40:24.280]  К чему это все?
[40:24.280 --> 40:26.280]  Да, вот мораль констатовал нельзя в рантайме,
[40:26.280 --> 40:28.280]  а констэкспорт был
[40:28.280 --> 40:30.280]  рекомендацией. Вот теперь
[40:30.280 --> 40:32.280]  будет самая суть. Вам нужно
[40:32.280 --> 40:34.280]  напрячься сейчас всем,
[40:34.280 --> 40:36.280]  все, кто выключался, пока мы беседовали о разных
[40:36.280 --> 40:38.280]  напросах на сущных, включитесь.
[40:40.280 --> 40:42.280]  Все еще тот же компьют,
[40:42.280 --> 40:44.280]  он констэкспорт.
[40:44.280 --> 40:46.280]  Взяли его.
[40:46.280 --> 40:48.280]  И сделали из него констэкспорт буль.
[40:50.280 --> 40:52.280]  В зависимости от n и результата
[40:52.280 --> 40:54.280]  от компьюта,
[40:54.280 --> 40:56.280]  будет буль либо true, либо false.
[40:56.280 --> 40:58.280]  Это такой предикат
[40:58.280 --> 41:00.280]  на типах,
[41:00.280 --> 41:02.280]  на числах. Он в compile-time для каждого
[41:02.280 --> 41:04.280]  числа говорит хорошее число или плохое,
[41:04.280 --> 41:06.280]  или удовлетворительное, или нет.
[41:06.280 --> 41:08.280]  И вот если мы вот так вот сделаем
[41:08.280 --> 41:10.280]  для пятерки,
[41:10.280 --> 41:12.280]  ну тут уже написано, что все будет ок,
[41:12.280 --> 41:14.280]  а если для сотни, то все сломается.
[41:14.280 --> 41:16.280]  Ситуацией принципиально
[41:16.280 --> 41:18.280]  не отличается то, что было до этого.
[41:18.280 --> 41:20.280]  Просто мы вот этот вот вызов
[41:20.280 --> 41:22.280]  компьют от 5 или компьют от 100
[41:22.280 --> 41:24.280]  затолкали куда-то под шаблон
[41:24.280 --> 41:26.280]  в инициализатор, и теперь вот есть еще
[41:26.280 --> 41:28.280]  шаблонный аргумент. Все то же самое.
[41:28.280 --> 41:30.280]  Дальше идем.
[41:32.280 --> 41:34.280]  Это констэкспорт буль.
[41:34.280 --> 41:36.280]  Констэкспорт значит переменная
[41:36.280 --> 41:38.280]  должна быть инициализирована в compile-time
[41:38.280 --> 41:40.280]  и не меняться никогда.
[41:40.280 --> 41:42.280]  Поэтому оно скажет
[41:42.280 --> 41:44.280]  проблема, как это я тебе вычислю
[41:44.280 --> 41:46.280]  от 100 в compile-time.
[41:46.280 --> 41:48.280]  Идем дальше.
[41:48.280 --> 41:50.280]  Помимо из acceptable
[41:50.280 --> 41:52.280]  появился из good.
[41:58.280 --> 42:00.280]  Пока мы ничему не верим.
[42:00.280 --> 42:02.280]  Но вот утверждается, что да,
[42:02.280 --> 42:04.280]  действительно вот это будет работать.
[42:04.280 --> 42:06.280]  Если вот кто-то из вас не верит
[42:06.280 --> 42:08.280]  мне, а такие должны быть, вбивайте в good bolt.
[42:08.280 --> 42:10.280]  Иногда тут
[42:10.280 --> 42:12.280]  бывает, что на слайдах лажа, иногда бывает, что
[42:12.280 --> 42:14.280]  я за ночь успел забыть, какой
[42:14.280 --> 42:16.280]  вывод был у конкретного слайда.
[42:16.280 --> 42:18.280]  Но здесь, кажется, все будет нормально работать.
[42:18.280 --> 42:20.280]  Почему?
[42:22.280 --> 42:24.280]  Да, тут
[42:24.280 --> 42:26.280]  точно такая же ситуация.
[42:26.280 --> 42:28.280]  Потому что мы вот, ну
[42:28.280 --> 42:30.280]  этот два или, это тот же самый
[42:30.280 --> 42:32.280]  выпросительный знак, который у нас внутри
[42:32.280 --> 42:34.280]  компьютера. Вот тернарный оператор
[42:34.280 --> 42:36.280]  внутри компьютера, от этого,
[42:36.280 --> 42:38.280]  от этих двух палок особо не
[42:38.280 --> 42:40.280]  отличается здесь.
[42:40.280 --> 42:42.280]  Да.
[42:42.280 --> 42:44.280]  Вот они все трое работают одинаково
[42:44.280 --> 42:46.280]  в таких контекстах.
[42:46.280 --> 42:48.280]  И из good и из acceptable
[42:48.280 --> 42:50.280]  ну, примерно одно и то же.
[42:50.280 --> 42:52.280]  Идем дальше.
[42:52.280 --> 42:54.280]  И ставим вот сюда.
[42:58.280 --> 43:00.280]  Вопрос. Что будет?
[43:02.280 --> 43:04.280]  Все нормально будет?
[43:04.280 --> 43:06.280]  Я думаю, что нормально.
[43:06.280 --> 43:08.280]  Ну да.
[43:08.280 --> 43:10.280]  Ну да.
[43:12.280 --> 43:14.280]  А теперь, наверное, нет.
[43:14.280 --> 43:16.280]  Теперь?
[43:16.280 --> 43:18.280]  Да.
[43:18.280 --> 43:20.280]  Сделем, что да.
[43:20.280 --> 43:22.280]  Нормально.
[43:22.280 --> 43:24.280]  Как будто бы да.
[43:24.280 --> 43:26.280]  Сейчас у нас
[43:26.280 --> 43:28.280]  не изменилось то, что мы просто
[43:28.280 --> 43:30.280]  переписали условия на напрямую в билет.
[43:30.280 --> 43:32.280]  Да, ничего не поменялось, вы правы.
[43:32.280 --> 43:34.280]  Это серия слайдов, на которые
[43:34.280 --> 43:36.280]  даже я себя запутываю, потому что тут
[43:36.280 --> 43:38.280]  каждый раз хочется сказать, а теперь изменилось, а теперь
[43:38.280 --> 43:40.280]  нет, ничего не меняется.
[43:40.280 --> 43:42.280]  Вот абсолютно неважно, мы там выписали
[43:42.280 --> 43:44.280]  это определение из good и прямо
[43:44.280 --> 43:46.280]  уже впихнули, нет, все еще так же работает,
[43:46.280 --> 43:48.280]  все нормально, никакого отличия нет. Пока.
[43:48.280 --> 43:50.280]  А теперь
[43:50.280 --> 43:52.280]  да.
[43:52.280 --> 43:54.280]  Такой, секой
[43:54.280 --> 43:56.280]  отличия нету.
[43:56.280 --> 43:58.280]  Нет, значит мы все
[43:58.280 --> 44:00.280]  перепутали. Давайте вбивать good bolt.
[44:00.280 --> 44:02.280]  Вот видите, я обещал, что
[44:02.280 --> 44:04.280]  я за ночь забуду, я забыл.
[44:04.280 --> 44:06.280]  Судя по подсказкам дальше
[44:06.280 --> 44:08.280]  здесь будет даже
[44:08.280 --> 44:10.280]  не здесь после, а дальше.
[44:20.280 --> 44:22.280]  Good bolt.
[44:24.280 --> 44:26.280]  Шлеп, шлеп, шлеп, шлеп.
[44:28.280 --> 44:30.280]  Я прямо чувствую, как мой
[44:30.280 --> 44:32.280]  компьютер с ума сходит.
[44:32.280 --> 44:34.280]  Я надеюсь, он не умрет.
[44:34.280 --> 44:36.280]  Ну вот мы как бы не доверяем
[44:36.280 --> 44:38.280]  каким-то там презентациям,
[44:38.280 --> 44:40.280]  мы доверяем только компилятору, а компилятор по факту
[44:40.280 --> 44:42.280]  что говорит? Что вот этот вот
[44:44.280 --> 44:46.280]  вот эта палочка, disjunction
[44:46.280 --> 44:48.280]  да, disjunction, она у нас
[44:48.280 --> 44:50.280]  казалась неленивой.
[44:50.280 --> 44:52.280]  Сейчас проверял acceptable и
[44:52.280 --> 44:54.280]  сказала плохо.
[44:54.280 --> 44:56.280]  Ну оно пошло в из good,
[44:56.280 --> 44:58.280]  проверяет
[44:58.280 --> 45:00.280]  disjunction и как бы оно
[45:00.280 --> 45:02.280]  не видит, что вот это вот true, да?
[45:04.280 --> 45:06.280]  Но почему-то все равно идет сюда.
[45:06.280 --> 45:08.280]  А, а почему оно идет сюда?
[45:08.280 --> 45:10.280]  И что значит идет сюда?
[45:10.280 --> 45:12.280]  Вот, вот
[45:12.280 --> 45:14.280]  где деталь, да, вот где
[45:14.280 --> 45:16.280]  деталь, которую я пропустил. Потому что
[45:16.280 --> 45:18.280]  смотрите, разница-то в чем?
[45:18.280 --> 45:20.280]  Вот здесь мы выражение вычисляли,
[45:20.280 --> 45:22.280]  так?
[45:22.280 --> 45:24.280]  Мы, ну как бы нам значение
[45:24.280 --> 45:26.280]  было важно. Тип, у вот этого
[45:26.280 --> 45:28.280]  load constant понятно какой.
[45:28.280 --> 45:30.280]  Это вот эта функция, у нее там тип int
[45:30.280 --> 45:32.280]  от ничего,
[45:32.280 --> 45:34.280]  ну мы запустили от ничего, получили int.
[45:34.280 --> 45:36.280]  Но вот здесь-то надо понять какой
[45:36.280 --> 45:38.280]  тип хотя бы.
[45:38.280 --> 45:40.280]  Для этого нужно инстанцировать шаблон.
[45:40.280 --> 45:42.280]  А когда мы
[45:42.280 --> 45:44.280]  с пятидесятью попытаемся этот шаблон
[45:44.280 --> 45:46.280]  инстанцировать,
[45:46.280 --> 45:48.280]  все умрет.
[45:48.280 --> 45:50.280]  Поняли?
[45:50.280 --> 45:52.280]  Даже себя умудрился
[45:52.280 --> 45:54.280]  запутать. Но мы разобрались.
[45:54.280 --> 45:56.280]  Что значит ответ?
[45:56.280 --> 45:58.280]  Нет, пока ответов нет, только вопросы.
[46:06.280 --> 46:08.280]  Вот так.
[46:08.280 --> 46:10.280]  Сейчас оно опять
[46:10.280 --> 46:12.280]  поиздевается надо мной.
[46:12.280 --> 46:14.280]  Давай full screen.
[46:42.280 --> 46:44.280]  Ну?
[46:56.280 --> 46:58.280]  Сейчас еще раз просмотрим и проговорим.
[46:58.280 --> 47:00.280]  Это важно.
[47:02.280 --> 47:04.280]  Да чтоб его!
[47:12.280 --> 47:14.280]  Пожалуйста, работай.
[47:14.280 --> 47:16.280]  Давайте просто slideshow
[47:16.280 --> 47:18.280]  даже без презентер
[47:18.280 --> 47:20.280]  мода уж.
[47:20.280 --> 47:22.280]  Так.
[47:22.280 --> 47:24.280]  Проговорим еще раз
[47:24.280 --> 47:26.280]  в самый последний,
[47:26.280 --> 47:28.280]  чтобы совсем закрепить
[47:28.280 --> 47:30.280]  и больше не тупить.
[47:30.280 --> 47:32.280]  Вот здесь
[47:32.280 --> 47:34.280]  мы считаем
[47:34.280 --> 47:36.280]  выражение.
[47:36.280 --> 47:38.280]  Вот здесь
[47:38.280 --> 47:40.280]  мы считаем выражение.
[47:40.280 --> 47:42.280]  Мы считаем выражение.
[47:42.280 --> 47:44.280]  Выражение считается лениво.
[47:44.280 --> 47:46.280]  Увидели, что это true?
[47:46.280 --> 47:48.280]  Во вторую ветку считать
[47:48.280 --> 47:50.280]  выражение идти не надо.
[47:50.280 --> 47:52.280]  Первую вернули, о!
[47:54.280 --> 47:56.280]  Вот здесь
[47:56.280 --> 47:58.280]  все становится наоборот.
[47:58.280 --> 48:00.280]  Здесь мы даже тип
[48:00.280 --> 48:02.280]  не знаем вот этой фигни.
[48:02.280 --> 48:04.280]  Вот это вот выражение
[48:04.280 --> 48:06.280]  это
[48:06.280 --> 48:08.280]  специализация какого-то
[48:08.280 --> 48:10.280]  шаблона. Нам надо идти искать шаблон,
[48:10.280 --> 48:12.280]  инстанцировать его и смотреть,
[48:12.280 --> 48:14.280]  что там получилось.
[48:16.280 --> 48:18.280]  Что-что?
[48:18.280 --> 48:20.280]  Ну,
[48:20.280 --> 48:22.280]  можно.
[48:22.280 --> 48:24.280]  Ну, вообще-то
[48:24.280 --> 48:26.280]  да, вообще-то можно сделать так, чтобы
[48:26.280 --> 48:28.280]  в зависимости от вот этого
[48:28.280 --> 48:30.280]  n вот здесь был разный тип.
[48:30.280 --> 48:32.280]  Одной и той же переменной.
[48:32.280 --> 48:34.280]  Одной и той же шаблона переменной.
[48:34.280 --> 48:36.280]  То есть нам как минимум, чтобы
[48:36.280 --> 48:38.280]  затайпчекать программу и понять, какие типы
[48:38.280 --> 48:40.280]  где, нам нужно пойти инстанцировать.
[48:40.280 --> 48:42.280]  Соответственно, вариантов у нас
[48:42.280 --> 48:44.280]  нету. Мы не можем.
[48:44.280 --> 48:46.280]  А если бы из Excerpt так же была некорректно,
[48:46.280 --> 48:48.280]  но там был бы шаблон, а там скажи так
[48:48.280 --> 48:50.280]  ну, аргумент, который проводит
[48:50.280 --> 48:52.280]  некорректно, то что там у компьютера?
[48:52.280 --> 48:54.280]  Короче, я не понял,
[48:54.280 --> 48:56.280]  что ты сказал, но видимо вопрос в том, что если
[48:56.280 --> 48:58.280]  здесь были бы круглые скобочки?
[48:58.280 --> 49:00.280]  Да, вот если бы здесь были круглые
[49:00.280 --> 49:02.280]  скобочки констекспро функция,
[49:02.280 --> 49:04.280]  все бы работало, как раньше.
[49:04.280 --> 49:06.280]  Почему работает не как раньше?
[49:06.280 --> 49:08.280]  И что даже меня убило?
[49:08.280 --> 49:10.280]  Это то, что скобочки треугольные меняют ситуацию.
[49:10.280 --> 49:12.280]  Нету ленивости.
[49:12.280 --> 49:14.280]  Вот здесь вот. И вот это вот просто
[49:14.280 --> 49:16.280]  не скомпилируется.
[49:18.280 --> 49:20.280]  Вот. И вот это тоже не скомпилируется.
[49:20.280 --> 49:22.280]  Потому что мы все еще сразу пойдем
[49:22.280 --> 49:24.280]  подставлять эту 50, вот сюда,
[49:24.280 --> 49:26.280]  сюда, сюда. Подставили
[49:26.280 --> 49:28.280]  ошибка. Не скомпилировалось.
[49:28.280 --> 49:30.280]  А вот здесь
[49:30.280 --> 49:32.280]  будет все работать.
[49:32.280 --> 49:34.280]  Вот в чем златость этих
[49:34.280 --> 49:36.280]  двух палочек.
[49:44.280 --> 49:46.280]  Оно
[49:46.280 --> 49:48.280]  увидев, что вот это вот
[49:52.280 --> 49:54.280]  что вот это вот вернуло true,
[49:54.280 --> 49:56.280]  оно даже инстанцировать шаблоны
[49:56.280 --> 49:58.280]  во второй половинке не будет.
[49:58.280 --> 50:00.280]  Но ничего не пойдет туда
[50:00.280 --> 50:02.280]  делать, смотреть вообще.
[50:06.280 --> 50:08.280]  Да.
[50:10.280 --> 50:12.280]  А нам и не важно.
[50:12.280 --> 50:14.280]  Ну, вернее как, мы точно знаем,
[50:14.280 --> 50:16.280]  что это должен был бы быть
[50:16.280 --> 50:18.280]  бул.
[50:18.280 --> 50:20.280]  Короче, оно еще более злато работает.
[50:26.280 --> 50:28.280]  Да, кажется, что
[50:28.280 --> 50:30.280]  да, он просто даже не будет проверять это.
[50:30.280 --> 50:32.280]  Ему будет все равно. Но лучше вбить в
[50:32.280 --> 50:34.280]  Godbolt. Но суть всех
[50:34.280 --> 50:36.280]  этих рассуждений в том, что
[50:36.280 --> 50:38.280]  во-первых, мы не можем
[50:38.280 --> 50:40.280]  с помощью констэкспорт булов
[50:40.280 --> 50:42.280]  брать и как-то вот сокращать
[50:42.280 --> 50:44.280]  себе количество кода, которое мы сюда
[50:44.280 --> 50:46.280]  пишем. Это сломается.
[50:46.280 --> 50:48.280]  Потому что, ну, это пример искусственный,
[50:48.280 --> 50:50.280]  да? Дико искусственный.
[50:50.280 --> 50:52.280]  Но суть остается той же.
[50:52.280 --> 50:54.280]  Если у вас вдруг даже подстановка
[50:54.280 --> 50:56.280]  шаблона приводит к какой-то ошибке
[50:56.280 --> 50:58.280]  подстановки,
[50:58.280 --> 51:00.280]  никакой SFINAE не сработает,
[51:00.280 --> 51:02.280]  и у вас просто будет ошибка компиляции.
[51:02.280 --> 51:04.280]  Всей компиляции.
[51:04.280 --> 51:06.280]  А вы, наверное, хотели, чтобы если вот тут
[51:06.280 --> 51:08.280]  в том, что вы в requires запихали, где-то там
[51:08.280 --> 51:10.280]  любая ошибка произошла,
[51:10.280 --> 51:12.280]  вы хотели, наверное, просто false получить
[51:12.280 --> 51:14.280]  и отключить эту функцию.
[51:14.280 --> 51:16.280]  А вот там был такой requires на время,
[51:16.280 --> 51:18.280]  как остается, а он последний был.
[51:18.280 --> 51:20.280]  Так оно же здесь получается, мы должны
[51:20.280 --> 51:22.280]  инстанцировать, не надо типать.
[51:22.280 --> 51:24.280]  Или это просто было причастление?
[51:24.280 --> 51:26.280]  Нет, там инстанциация происходит
[51:26.280 --> 51:28.280]  вот с самого вот этого шаблона.
[51:28.280 --> 51:30.280]  Вот этого вот.
[51:32.280 --> 51:34.280]  Ну, тут есть
[51:34.280 --> 51:36.280]  маленькие детали, конечно, а
[51:36.280 --> 51:38.280]  пойдет ли оно инстанцировать
[51:38.280 --> 51:40.280]  те вот штуки, непонятно.
[51:40.280 --> 51:42.280]  Надо стандарт вычитывать.
[51:42.280 --> 51:44.280]  Давай главную мораль
[51:44.280 --> 51:46.280]  все поймем и запомним, что
[51:46.280 --> 51:48.280]  дизъюнкция и конъюнкция
[51:48.280 --> 51:50.280]  в requires-ах, она более ленивая, чем
[51:50.280 --> 51:52.280]  дизъюнкция и конъюнкция
[51:52.280 --> 51:54.280]  просто в constexpr булах.
[51:54.280 --> 51:56.280]  Или в принципе у вас в коде.
[51:56.280 --> 51:58.280]  Она ленивая относительно типов, она вот даже
[51:58.280 --> 52:00.280]  на типы смотреть не будет, если
[52:00.280 --> 52:02.280]  получила тот ответ, который искала.
[52:02.280 --> 52:04.280]  Ну и да,
[52:04.280 --> 52:06.280]  перегружать вот эту конъюнкцию-дизъюнкцию
[52:06.280 --> 52:08.280]  нельзя, как бы.
[52:08.280 --> 52:10.280]  В каком-то смысле.
[52:10.280 --> 52:12.280]  То есть если вы здесь напишете
[52:12.280 --> 52:14.280]  какие-то типы,
[52:14.280 --> 52:16.280]  для которых перегружен оператор две палки
[52:16.280 --> 52:18.280]  и возвращает в итоге буль,
[52:18.280 --> 52:20.280]  то вот этой ленивости вы не получите.
[52:22.280 --> 52:24.280]  Да?
[52:24.280 --> 52:26.280]  Ну, чем отличается
[52:26.280 --> 52:28.280]  встроенный оператор двух палок
[52:28.280 --> 52:30.280]  от бами перегруженного?
[52:30.280 --> 52:32.280]  Ключевое отличие.
[52:32.280 --> 52:34.280]  Вот это вот точно
[52:34.280 --> 52:36.280]  должны были явно проговаривать на парах
[52:36.280 --> 52:38.280]  когда-то.
[52:38.280 --> 52:40.280]  Да, вот когда вы свой перегруженный
[52:40.280 --> 52:42.280]  оператор две палки делаете,
[52:42.280 --> 52:44.280]  у вас будут оба аргумента
[52:44.280 --> 52:46.280]  вычисляться, ленивости не будет.
[52:46.280 --> 52:48.280]  А встроенный и ленивый.
[52:48.280 --> 52:50.280]  Здесь то же самое. Если вот это вот
[52:50.280 --> 52:52.280]  и вот это вот не были какие-то ваши
[52:52.280 --> 52:54.280]  типы, для которых вы свой оператор
[52:54.280 --> 52:56.280]  две палки определили,
[52:56.280 --> 52:58.280]  то вас ждет поражение.
[52:58.280 --> 53:00.280]  Ленивость вообще отвалится и у вас будет
[53:00.280 --> 53:02.280]  просто ваш оператор две палки как функция
[53:02.280 --> 53:04.280]  зваться.
[53:04.280 --> 53:06.280]  Да.
[53:06.280 --> 53:08.280]  Окей.
[53:08.280 --> 53:10.280]  Ну,
[53:10.280 --> 53:12.280]  еще одно, что это наталкивает,
[53:12.280 --> 53:14.280]  что вот constexpr bool,
[53:14.280 --> 53:16.280]  хочется ведь вот эти вот сложные выражения
[53:16.280 --> 53:18.280]  запихивать в какие-то
[53:18.280 --> 53:20.280]  переменные что-ли,
[53:20.280 --> 53:22.280]  как-то имена давать вот этим
[53:22.280 --> 53:24.280]  сложным набором каких-то требований,
[53:24.280 --> 53:26.280]  как-то их вот выпихивать куда-то. Но constexpr bool
[53:26.280 --> 53:28.280]  не подходит, потому что работают
[53:28.280 --> 53:30.280]  по-разному.
[53:30.280 --> 53:32.280]  Это должно вас натолкнуть на мысль о том,
[53:32.280 --> 53:34.280]  что такое концепт. Но об этом чуть позже.
[53:34.280 --> 53:36.280]  Вот, эти работают
[53:36.280 --> 53:38.280]  по-разному. Все, мы справились.
[53:38.280 --> 53:40.280]  Наверное, время
[53:40.280 --> 53:42.280]  перерыва перед тем, как мы пойдем дальше.
[53:42.280 --> 53:44.280]  Правда ведь?
[53:44.280 --> 53:46.280]  Десять минут.
[53:46.280 --> 53:48.280]  Ну, за десять минут вот про это мы успеем поговорить.
[53:48.280 --> 53:50.280]  А потому что тут просто.
[53:50.280 --> 53:52.280]  Да?
[53:52.280 --> 53:54.280]  Да.
[53:54.280 --> 53:56.280]  То, что вы увидели,
[53:56.280 --> 53:58.280]  это буквально из того,
[53:58.280 --> 54:00.280]  что вы написали
[54:00.280 --> 54:02.280]  о том, что
[54:02.280 --> 54:04.280]  сначала инстанционные шаблоны,
[54:04.280 --> 54:06.280]  а потом проверяются requires.
[54:06.280 --> 54:08.280]  Вот, по-моему, это не совсем так.
[54:08.280 --> 54:10.280]  Нет, наоборот, что там в одном пункте
[54:10.280 --> 54:12.280]  было и инстанционные шаблоны, и requires.
[54:12.280 --> 54:14.280]  Да, вот в каком порядке это в рамках этого
[54:14.280 --> 54:16.280]  пункта делается, по-моему, все-таки requires
[54:16.280 --> 54:18.280]  и проверяются самыми последними, а
[54:18.280 --> 54:20.280]  подстановка шаблонов имелась в виду не тех,
[54:20.280 --> 54:22.280]  которые где-то у вас в рамках вашей
[54:22.280 --> 54:24.280]  функции, а именно, что
[54:24.280 --> 54:26.280]  на вход пришло множество функций,
[54:26.280 --> 54:28.280]  подходящих под ваше имя,
[54:28.280 --> 54:30.280]  и множество шаблонов функций.
[54:30.280 --> 54:32.280]  И под инстанциацией имелась в виду именно
[54:32.280 --> 54:34.280]  инстанциация этих шаблонов функций,
[54:34.280 --> 54:36.280]  которые нашлись по имени,
[54:36.280 --> 54:38.280]  чтобы получить уже настоящие функции.
[54:38.280 --> 54:40.280]  Вот они инстанцируются.
[54:40.280 --> 54:42.280]  И потом уже проверяются requires.
[54:42.280 --> 54:44.280]  Вот, то есть тут надо
[54:44.280 --> 54:46.280]  не запутаться.
[54:46.280 --> 54:48.280]  А вот у нас на requirements сейчас был
[54:48.280 --> 54:50.280]  тоже шаблон.
[54:50.280 --> 54:52.280]  Да.
[55:02.280 --> 55:04.280]  Ну, вот потому что так работает
[55:04.280 --> 55:06.280]  оператор две палки, в этом
[55:06.280 --> 55:08.280]  суть того, как он работает.
[55:08.280 --> 55:10.280]  Оператор две палки в requires выраживать
[55:10.280 --> 55:12.280]  в этих constraints, он особенно
[55:12.280 --> 55:14.280]  и работает вот так. Если у него
[55:14.280 --> 55:16.280]  что-то не скомпилировалось во второй ветке,
[55:16.280 --> 55:18.280]  он вообще false просто делает, насколько
[55:18.280 --> 55:20.280]  я помню. Может даже так.
[55:20.280 --> 55:22.280]  Ну, об эту деталь
[55:22.280 --> 55:24.280]  вы разбиваться будете не часто,
[55:24.280 --> 55:26.280]  но иногда будете, а может и не будете,
[55:26.280 --> 55:28.280]  как повезет.
[55:28.280 --> 55:30.280]  Впрочем,
[55:30.280 --> 55:32.280]  как и со всем материалом,
[55:32.280 --> 55:34.280]  наизусть сейчас запомнить все это
[55:34.280 --> 55:36.280]  от вас я, конечно, не требую, это невозможно.
[55:36.280 --> 55:38.280]  Я хочу, чтобы это где-то
[55:38.280 --> 55:40.280]  осело, что какая-то тут закорюка есть,
[55:40.280 --> 55:42.280]  и вы смогли потом нагуглить эту закорюку.
[55:42.280 --> 55:44.280]  Вот.
[55:44.280 --> 55:46.280]  Давайте дальше по-быстрому, вот там
[55:46.280 --> 55:48.280]  сколько? 8 минут, вот на этот раздел нам хватит.
[55:48.280 --> 55:50.280]  Помимо requires,
[55:50.280 --> 55:52.280]  который мы уже видели, requires
[55:52.280 --> 55:54.280]  close это называлось, напоминаю,
[55:54.280 --> 55:56.280]  в C++ добавили еще одно
[55:56.280 --> 55:58.280]  использование этого ключевого слова, requires
[55:58.280 --> 56:00.280]  expression.
[56:00.280 --> 56:02.280]  Ну, почему одно и то же ключевое
[56:02.280 --> 56:04.280]  слово используется в двух местах?
[56:04.280 --> 56:06.280]  Ну, давайте посчитаем,
[56:06.280 --> 56:08.280]  сколько у нас там есть C++
[56:08.280 --> 56:10.280]  типов статических чего-то.
[56:10.280 --> 56:12.280]  Статические переменные,
[56:12.280 --> 56:14.280]  статические переменные функциях,
[56:14.280 --> 56:16.280]  статические глобальные переменные,
[56:16.280 --> 56:18.280]  в классах оно там по-другому
[56:18.280 --> 56:20.280]  работает, а еще статические функции
[56:20.280 --> 56:22.280]  по-другому работают. Ну, вот
[56:22.280 --> 56:24.280]  экономим мы ключевые слова, понимаете?
[56:24.280 --> 56:26.280]  Ключевые слова дорого,
[56:26.280 --> 56:28.280]  вдруг мы там кому-то код сломаем,
[56:28.280 --> 56:30.280]  поэтому надо как можно больше фигни
[56:30.280 --> 56:32.280]  назвать одним словом, чтобы все запутались.
[56:32.280 --> 56:34.280]  Зато legacy код не сломаем.
[56:34.280 --> 56:36.280]  Итак, к чему это все?
[56:36.280 --> 56:38.280]  requires expression,
[56:38.280 --> 56:40.280]  вот это вот.
[56:40.280 --> 56:42.280]  Что оно делает?
[56:44.280 --> 56:46.280]  Во-первых, это все вместе
[56:46.280 --> 56:48.280]  бульевое выражение.
[56:48.280 --> 56:50.280]  Ну, они как будто созданы друг для друга, да?
[56:50.280 --> 56:52.280]  Вот requires close и requires
[56:52.280 --> 56:54.280]  expression. Одному нужно
[56:54.280 --> 56:56.280]  бульевое выражение, другое им является.
[56:56.280 --> 56:58.280]  И вычисляется оно
[56:58.280 --> 57:00.280]  как бы вот в компайл
[57:00.280 --> 57:02.280]  тайме это выражение, всегда.
[57:02.280 --> 57:04.280]  А значение его true,
[57:04.280 --> 57:06.280]  если все, что вы в фигурных скобках написали,
[57:06.280 --> 57:08.280]  скомпилируется.
[57:10.280 --> 57:12.280]  Видите, что я там написал?
[57:12.280 --> 57:14.280]  Тут какой-то v есть шаблонный
[57:14.280 --> 57:16.280]  аргумент.
[57:16.280 --> 57:18.280]  И в requires expression я написал
[57:18.280 --> 57:20.280]  v фигурные скобки,
[57:20.280 --> 57:22.280]  то есть дефолтная инициализация
[57:22.280 --> 57:24.280]  v. Соответственно, выражение это
[57:24.280 --> 57:26.280]  будет true, если v можно
[57:26.280 --> 57:28.280]  инициализировать по умолчанию,
[57:28.280 --> 57:30.280]  то есть там структурка какая-нибудь,
[57:30.280 --> 57:32.280]  либо есть конструктор без аргументов.
[57:32.280 --> 57:34.280]  И false, если нельзя.
[57:34.280 --> 57:36.280]  А есть какой-нибудь
[57:36.280 --> 57:38.280]  requires after?
[57:38.280 --> 57:40.280]  Ну, как было декл-тайп,
[57:40.280 --> 57:42.280]  выражение, а потом
[57:42.280 --> 57:44.280]  подозрение.
[57:44.280 --> 57:46.280]  И вот
[57:46.280 --> 57:48.280]  хотелось бы requires adapter,
[57:48.280 --> 57:50.280]  чтобы, типа, если тело скомпилировалось,
[57:50.280 --> 57:52.280]  то да. Так, утверждается, что
[57:52.280 --> 57:54.280]  такое сделать, в принципе, можно с точки зрения
[57:54.280 --> 57:56.280]  компиляторов, но ни в коем случае не нужно.
[57:56.280 --> 57:58.280]  А в чем смысл requires adapter?
[57:58.280 --> 58:00.280]  Давай не будем даже думать.
[58:00.280 --> 58:02.280]  Вот под конец этой пары
[58:02.280 --> 58:04.280]  я, наверное, могу сказать, почему это плохая
[58:04.280 --> 58:06.280]  идея, что имелось в виду и почему не надо
[58:06.280 --> 58:08.280]  так. А сейчас просто не будем
[58:08.280 --> 58:10.280]  грешном думать. Будем думать о хорошем,
[58:10.280 --> 58:12.280]  о том, что вот мы так написали,
[58:12.280 --> 58:14.280]  и вот для Интайта будет true.
[58:14.280 --> 58:16.280]  А если написали какую-то штуку, которую
[58:16.280 --> 58:18.280]  удалили, дефолтный конструктор
[58:18.280 --> 58:20.280]  без аргументов, то будет false.
[58:20.280 --> 58:22.280]  Это всяко
[58:22.280 --> 58:24.280]  удобнее, чем то, что вас, возможно,
[58:24.280 --> 58:26.280]  заставляло Илья на первом курсе делать,
[58:26.280 --> 58:28.280]  чтобы проверять такие вещи. Правда?
[58:28.280 --> 58:30.280]  Что?
[58:32.280 --> 58:34.280]  Вот с финайе
[58:34.280 --> 58:36.280]  и там начинаются какие-то специализации,
[58:36.280 --> 58:38.280]  которые там, если скомпилировалось, то и это
[58:38.280 --> 58:40.280]  нет.
[58:40.280 --> 58:42.280]  Ну, аналогичные
[58:42.280 --> 58:44.280]  штуки из дефолта констракта был, он
[58:44.280 --> 58:46.280]  нас наверняка заставлял писать. И там был какой-то
[58:46.280 --> 58:48.280]  ад. Просто стрёмное, стрёмное.
[58:48.280 --> 58:50.280]  Здесь всё вообще
[58:50.280 --> 58:52.280]  красота.
[58:52.280 --> 58:54.280]  Дальше идём.
[58:54.280 --> 58:56.280]  Не в ту сторону? Нет, в ту
[58:56.280 --> 58:58.280]  сторону.
[58:58.280 --> 59:00.280]  Это что, лишний слайд?
[59:00.280 --> 59:02.280]  А, это слайды
[59:02.280 --> 59:04.280]  перепутались. Ой, ладно.
[59:04.280 --> 59:06.280]  Следующий забавный синтаксис
[59:06.280 --> 59:08.280]  можно
[59:08.280 --> 59:10.280]  переменные, аргументы впихнуть
[59:10.280 --> 59:12.280]  в requires expression.
[59:12.280 --> 59:14.280]  Да,
[59:14.280 --> 59:16.280]  вот уже сказали, это деклвал.
[59:16.280 --> 59:18.280]  Помните такое у зверя?
[59:18.280 --> 59:20.280]  Вот когда вы там пишете какое-то
[59:20.280 --> 59:22.280]  жуткое с финайе, вам иногда нужно
[59:22.280 --> 59:24.280]  проверить, что работает такое
[59:24.280 --> 59:26.280]  выражение, и вам там, типа, нужно из воздуха
[59:26.280 --> 59:28.280]  взять какую-то переменную,
[59:28.280 --> 59:30.280]  какого-то типа.
[59:30.280 --> 59:32.280]  Теперь для этого есть явный, чёткий
[59:32.280 --> 59:34.280]  синтаксис.
[59:34.280 --> 59:36.280]  Ну и понимать всё это вместе нужно
[59:36.280 --> 59:38.280]  следующим образом.
[59:38.280 --> 59:40.280]  Если нам даны va
[59:40.280 --> 59:42.280]  и vb, то есть две переменные
[59:42.280 --> 59:44.280]  типа v, то
[59:44.280 --> 59:46.280]  должно компилироваться следующее выражение
[59:46.280 --> 59:48.280]  a-b.
[59:48.280 --> 59:50.280]  Это можно понимать как некий квантор
[59:50.280 --> 59:52.280]  всеобщности, на самом деле.
[59:52.280 --> 59:54.280]  Откуда a и b берутся?
[59:54.280 --> 59:56.280]  А не откуда.
[59:56.280 --> 59:58.280]  Это бульёвое выражение, это всё
[59:58.280 --> 01:00:00.280]  как бы предикат.
[01:00:00.280 --> 01:00:02.280]  Синтаксис со скобочками, это квантор
[01:00:02.280 --> 01:00:04.280]  всеобщности по любым a и по любым b,
[01:00:04.280 --> 01:00:06.280]  оба из которых типа v.
[01:00:06.280 --> 01:00:08.280]  А в чём ещё одна плава?
[01:00:08.280 --> 01:00:10.280]  Ну, не знаю.
[01:00:10.280 --> 01:00:12.280]  Нет, здесь можно, конечно, они и ссадь
[01:00:12.280 --> 01:00:14.280]  делают, но...
[01:00:14.280 --> 01:00:16.280]  Ну так как-то более понятно, ты же...
[01:00:16.280 --> 01:00:18.280]  То есть проверяется, что для них перегружено
[01:00:18.280 --> 01:00:20.280]  оператор в 4? Да.
[01:00:20.280 --> 01:00:22.280]  Что имея две переменные в коде
[01:00:22.280 --> 01:00:24.280]  где угодно типа v, ты можешь их
[01:00:24.280 --> 01:00:26.280]  вычесть. То есть такой код
[01:00:26.280 --> 01:00:28.280]  скомпилируется.
[01:00:28.280 --> 01:00:30.280]  И интуиция про квантор всеобщности, она очень
[01:00:30.280 --> 01:00:32.280]  правильная здесь.
[01:00:32.280 --> 01:00:34.280]  Для любых двух переменных a и b можно их
[01:00:34.280 --> 01:00:36.280]  друг из друга вычесть. Вот если это верно,
[01:00:36.280 --> 01:00:38.280]  то всё выражение будет true.
[01:00:38.280 --> 01:00:40.280]  Если это неправда, то это будет false.
[01:00:40.280 --> 01:00:42.280]  Но, конечно же, никакую всеобщность
[01:00:42.280 --> 01:00:44.280]  компилятор не проверяет, он как бы
[01:00:44.280 --> 01:00:46.280]  это...
[01:00:46.280 --> 01:00:48.280]  Что?
[01:00:48.280 --> 01:00:50.280]  Вот.
[01:00:50.280 --> 01:00:52.280]  Вот я тоже как-то писал код и очень хотел,
[01:00:52.280 --> 01:00:54.280]  чтобы ещё можно было пихнуть квантор
[01:00:54.280 --> 01:00:56.280]  всеобщности по типам. Нельзя.
[01:00:58.280 --> 01:01:00.280]  Так, стой. Я не очень...
[01:01:00.280 --> 01:01:02.280]  Вот человеку интересно извращение,
[01:01:02.280 --> 01:01:04.280]  это вот его лично.
[01:01:04.280 --> 01:01:06.280]  Это не извращение, это вполне нормальный
[01:01:06.280 --> 01:01:08.280]  use case. Я хочу проверить.
[01:01:10.280 --> 01:01:12.280]  Нет, у меня тоже был нормальный
[01:01:12.280 --> 01:01:14.280]  use case. Да, я вот...
[01:01:14.280 --> 01:01:16.280]  Хочется проверять наличие шаблонного метода.
[01:01:16.280 --> 01:01:18.280]  Да, да. Вот ровно такое
[01:01:18.280 --> 01:01:20.280]  же у меня было. То есть представьте,
[01:01:20.280 --> 01:01:22.280]  вы хотите проверить, что
[01:01:22.280 --> 01:01:24.280]  у a можно вызвать метод
[01:01:24.280 --> 01:01:26.280]  get шаблонный с любым типом.
[01:01:26.280 --> 01:01:28.280]  Не знаю, зачем вам
[01:01:28.280 --> 01:01:30.280]  это может быть, но хочется.
[01:01:30.280 --> 01:01:32.280]  Вот этот синток...
[01:01:32.280 --> 01:01:34.280]  Вот эта вся фигня
[01:01:34.280 --> 01:01:36.280]  никак вам не позволит это сделать.
[01:01:42.280 --> 01:01:44.280]  Да, много чего интересного можно было бы натворить,
[01:01:44.280 --> 01:01:46.280]  но нет.
[01:01:48.280 --> 01:01:50.280]  Ну, смотри, хочется написать
[01:01:50.280 --> 01:01:52.280]  a.get и в треугольных
[01:01:52.280 --> 01:01:54.280]  скобках любой тип. Что типа
[01:01:54.280 --> 01:01:56.280]  не просто для конкретного типа, а для
[01:01:56.280 --> 01:01:58.280]  произвольного. Такой квантор всеобщенности
[01:01:58.280 --> 01:02:00.280]  по типам. Нельзя.
[01:02:00.280 --> 01:02:02.280]  Что?
[01:02:04.280 --> 01:02:06.280]  Да, там опять проблема остановки где-то вылезает,
[01:02:06.280 --> 01:02:08.280]  но вот приходится
[01:02:08.280 --> 01:02:10.280]  таким обходиться.
[01:02:14.280 --> 01:02:16.280]  А, переменные типа v внутри
[01:02:16.280 --> 01:02:18.280]  requires нельзя. Вот это важно.
[01:02:18.280 --> 01:02:20.280]  Сюда можно вписывать только
[01:02:20.280 --> 01:02:22.280]  выражение, expression.
[01:02:22.280 --> 01:02:24.280]  Statement сюда писать нельзя.
[01:02:26.280 --> 01:02:28.280]  Да, можно несколько expression через
[01:02:28.280 --> 01:02:30.280]  точку с запятой. Сейчас про это подойдем.
[01:02:30.280 --> 01:02:32.280]  Нет,
[01:02:32.280 --> 01:02:34.280]  через точку с запятой. Здесь как бы каждая строчка
[01:02:34.280 --> 01:02:36.280]  отдельная expression.
[01:02:36.280 --> 01:02:38.280]  Да.
[01:02:44.280 --> 01:02:46.280]  Да.
[01:02:50.280 --> 01:02:52.280]  Почему? Обычный код.
[01:02:52.280 --> 01:02:54.280]  Если нам дана переменная типа
[01:02:54.280 --> 01:02:56.280]  rvalue ссылка на v,
[01:02:56.280 --> 01:02:58.280]  то и так далее.
[01:02:58.280 --> 01:03:00.280]  При этом как имя, если ты ее назовешь вот здесь,
[01:03:00.280 --> 01:03:02.280]  у тебя обычным образом все работает.
[01:03:02.280 --> 01:03:04.280]  Если
[01:03:04.280 --> 01:03:06.280]  у имени переменной
[01:03:06.280 --> 01:03:08.280]  всегда категория expression
[01:03:08.280 --> 01:03:10.280]  lvalue.
[01:03:10.280 --> 01:03:12.280]  То есть оно точно так же работает, как
[01:03:12.280 --> 01:03:14.280]  если бы функцией все это было.
[01:03:24.280 --> 01:03:26.280]  Что еще раз?
[01:03:26.280 --> 01:03:28.280]  А минус равно b можно написать,
[01:03:28.280 --> 01:03:30.280]  потому что а минус равно b это expression.
[01:03:30.280 --> 01:03:32.280]  Ну да, для int
[01:03:32.280 --> 01:03:34.280]  а минус равно b
[01:03:34.280 --> 01:03:36.280]  тоже возвращается ссылку на int вообще-то.
[01:03:42.280 --> 01:03:44.280]  Тут все по-обычному работает.
[01:03:44.280 --> 01:03:46.280]  Вся lvalue у нас
[01:03:46.280 --> 01:03:48.280]  здесь работает как у обычной функции,
[01:03:48.280 --> 01:03:50.280]  но как бы без
[01:03:50.280 --> 01:03:52.280]  use case сложно что-то еще сказать.
[01:03:52.280 --> 01:03:54.280]  Все как обычно работает.
[01:03:56.280 --> 01:03:58.280]  Еще раз, они работают как аргументы функции.
[01:03:58.280 --> 01:04:00.280]  Это просто какая-то переменная
[01:04:00.280 --> 01:04:02.280]  типа v.
[01:04:02.280 --> 01:04:04.280]  Ну, функция обычная,
[01:04:04.280 --> 01:04:06.280]  если вы принимаете аргумент типа v
[01:04:06.280 --> 01:04:08.280]  и называете его вот здесь.
[01:04:08.280 --> 01:04:10.280]  Это какая категория значения?
[01:04:10.280 --> 01:04:12.280]  lvalue.
[01:04:12.280 --> 01:04:14.280]  А здесь lvalue.
[01:04:22.280 --> 01:04:24.280]  Я говорю, все по-обычному работает.
[01:04:28.280 --> 01:04:30.280]  Да.
[01:04:40.280 --> 01:04:42.280]  Да, нового синтаксиса
[01:04:42.280 --> 01:04:44.280]  чтобы объявлять в скопе expression
[01:04:44.280 --> 01:04:46.280]  у нас нет. Здесь объявляются
[01:04:46.280 --> 01:04:48.280]  именно что переменные.
[01:04:48.280 --> 01:04:50.280]  Такие же как объявляются аргументы функции.
[01:04:50.280 --> 01:04:52.280]  То есть оно работает
[01:04:52.280 --> 01:04:54.280]  точно так же как функция
[01:04:54.280 --> 01:04:56.280]  объявили, все то же самое.
[01:04:56.280 --> 01:04:58.280]  Окей?
[01:04:58.280 --> 01:05:00.280]  Вот насчет этого, надеюсь,
[01:05:00.280 --> 01:05:02.280]  прояснилось, ничего настолько
[01:05:02.280 --> 01:05:04.280]  сложного здесь нет. Все тупо пока.
[01:05:06.280 --> 01:05:08.280]  Ну и использовать это можно очень легко
[01:05:08.280 --> 01:05:10.280]  и очень полезно, очень эффективно.
[01:05:10.280 --> 01:05:12.280]  Вот такой код пишите и радуйтесь.
[01:05:14.280 --> 01:05:16.280]  Ну вы знаете, наверное, про вот эту вот
[01:05:16.280 --> 01:05:18.280]  функцию distance в стандарте она есть.
[01:05:18.280 --> 01:05:20.280]  Она считает расстояние между двумя
[01:05:20.280 --> 01:05:22.280]  итераторами.
[01:05:22.280 --> 01:05:24.280]  Ну и почему ее вообще следует использовать?
[01:05:24.280 --> 01:05:26.280]  Да, а ровно потому, что здесь написано.
[01:05:26.280 --> 01:05:28.280]  Если у вас
[01:05:28.280 --> 01:05:30.280]  хорошие итераторы,
[01:05:30.280 --> 01:05:32.280]  random access, то вы можете вычесть
[01:05:32.280 --> 01:05:34.280]  и за от единицы найти расстояние.
[01:05:34.280 --> 01:05:36.280]  А вот если итераторы плохие,
[01:05:36.280 --> 01:05:38.280]  то как бы беда
[01:05:38.280 --> 01:05:40.280]  и нужно просто в цикле один двигать,
[01:05:40.280 --> 01:05:42.280]  пока он не дойдет до второго, и тогда
[01:05:42.280 --> 01:05:44.280]  уже вы насчитали сколько-то там.
[01:05:44.280 --> 01:05:46.280]  Ну вот, и тут мы с помощью
[01:05:46.280 --> 01:05:48.280]  if constexpr, это C++17,
[01:05:48.280 --> 01:05:50.280]  надеюсь, все знают,
[01:05:50.280 --> 01:05:52.280]  сделали либо одно, либо другое.
[01:05:52.280 --> 01:05:54.280]  Окей.
[01:05:56.280 --> 01:05:58.280]  Requires, requires.
[01:06:00.280 --> 01:06:02.280]  Ну понятно же, да, что написано.
[01:06:02.280 --> 01:06:04.280]  Где-то еще такое.
[01:06:04.280 --> 01:06:06.280]  А, noexcept от noexcept. Видели?
[01:06:06.280 --> 01:06:08.280]  Noexcept от noexcept.
[01:06:08.280 --> 01:06:10.280]  Ну опять же,
[01:06:10.280 --> 01:06:12.280]  есть noexcept clause, который
[01:06:12.280 --> 01:06:14.280]  на функции навешивается,
[01:06:14.280 --> 01:06:16.280]  и этот noexcept clause может принимать
[01:06:16.280 --> 01:06:18.280]  бульевую константу, типа
[01:06:18.280 --> 01:06:20.280]  noexcept от true или noexcept от false,
[01:06:20.280 --> 01:06:22.280]  включать или выключать, в зависимости
[01:06:22.280 --> 01:06:24.280]  от того, что происходит.
[01:06:24.280 --> 01:06:26.280]  А есть noexcept expression,
[01:06:26.280 --> 01:06:28.280]  который на вход берет другой expression и говорит,
[01:06:28.280 --> 01:06:30.280]  является ли он noexceptом.
[01:06:30.280 --> 01:06:32.280]  Поэтому можем еще сюда написать
[01:06:32.280 --> 01:06:34.280]  noexcept от noexcept от
[01:06:34.280 --> 01:06:36.280]  r-l. И вообще-то должны.
[01:06:36.280 --> 01:06:38.280]  Но я сюда
[01:06:38.280 --> 01:06:40.280]  не вписал.
[01:06:40.280 --> 01:06:42.280]  Еще же есть template, template, typename, typename.
[01:06:42.280 --> 01:06:44.280]  А, ну, по-моему,
[01:06:44.280 --> 01:06:46.280]  template, template, по-моему, мы уже
[01:06:46.280 --> 01:06:48.280]  видели, да. Ну у нас
[01:06:48.280 --> 01:06:50.280]  языкающийся язык слегка,
[01:06:50.280 --> 01:06:52.280]  под целевую аудиторию
[01:06:52.280 --> 01:06:54.280]  под нас.
[01:06:54.280 --> 01:06:56.280]  Дальше будут концепты, и на этой ноте, я думаю,
[01:06:56.280 --> 01:06:58.280]  перерыв.
