[00:00.000 --> 00:22.320]  Так, добрый день, второе, да, так, ну что, мы переходим
[00:22.320 --> 00:24.400]  к графам, у нас до конца семестра будет граф, так
[00:24.400 --> 00:31.100]  что brace yourself, что называется, а очень кратко, что такое
[00:31.100 --> 00:35.760]  граф, граф у нас будет неориентированный и ориентированный, что такое ориентированный
[00:35.760 --> 01:01.640]  граф, это пара VE, VV это какое-то конечное множество, а E вложено
[01:01.640 --> 01:10.560]  в V на V, соответственно картинка, мы будем элементы V изображать
[01:10.560 --> 01:13.400]  точечками, а элементы E изображать стрелочками из
[01:13.400 --> 01:15.240]  одной вершины в другую, то есть если у нас есть как
[01:15.240 --> 01:19.560]  бы что такое E под множество V на V, значит это набор пар,
[01:19.560 --> 01:21.600]  каждая пара упорядочена, у нее есть первый элемент
[01:21.600 --> 01:24.480]  второй, первый это то откуда ведет, стрелочка второй
[01:24.480 --> 01:29.200]  это куда, например если есть три вершинки и вот такие
[01:29.200 --> 01:34.920]  вот ребра, мы можем сказать, что у нас есть ребра один-два,
[01:34.920 --> 01:42.720]  один-три и два-три, вот, дальше неориентированный граф
[01:42.720 --> 02:05.560]  ну, начало такое же, вот, а E теперь это у нас под множество,
[02:05.560 --> 02:11.660]  чего бы вы думали, CSV подва, где CSV подва это все неупорядоченные
[02:11.660 --> 02:15.300]  под множество из двух элементов, потому что когда у нас граф
[02:15.300 --> 02:17.740]  неориентированный, у нас соответственно, мы хотим
[02:17.740 --> 02:20.780]  чтобы в E лежали неупорядоченные пары, то есть по факту множество
[02:20.780 --> 02:23.780]  двуэлементное, но CSV подва это как раз все двуэлементные
[02:23.780 --> 02:30.980]  под множество, тот же граф, если я нарисую уже без стрелочек,
[02:30.980 --> 02:38.420]  у нас ребра будут один-два, два-три и один-три, их как
[02:38.420 --> 02:41.220]  бы оптимальные всего рисовать именно в фигурных скобках,
[02:41.520 --> 02:44.340]  потому что это неупорядоченная пара, и мы всегда можем менять местами,
[02:44.340 --> 02:48.460]  а круглые скобки, вообще говоря, да, правильнее было бы оставлять
[02:48.460 --> 02:52.140]  для ориентированных ребер, вот, я не всегда буду придерживаться
[02:52.140 --> 02:54.820]  такой оптимальной нотации, часто я буду просто обозначать
[02:54.820 --> 02:58.200]  в ребро, независимо от того он ориентированный или
[02:58.200 --> 03:01.520]  нет, но правильнее было бы всегда делать оставить
[03:01.520 --> 03:04.340]  этоimalу для ориентированных ребер, а вот это estrutки
[03:04.340 --> 03:05.340]  ориентированных.
[03:05.340 --> 03:08.580]  Но это в идеальном мире, мы часто будем просто вот
[03:08.580 --> 03:09.980]  так вот обозначать и то, и то, аosition ohm, и ориентированные
[03:09.980 --> 03:10.980]  и ориентированно, и неориентированно.
[03:10.980 --> 03:18.280]  Так, ну, значит, я не буду давать нам всякое определение
[03:18.280 --> 03:22.100]  путей, циклов и так далее, нам будет хватать интуитивного
[03:22.100 --> 03:24.300]  понимания, благо, это можно очень легко формализовать.
[03:24.300 --> 03:28.180]  Ну, тогда, когда мы будем про это говорить, мы и так
[03:28.180 --> 03:30.740]  будем понимать, о чем речь, поэтому всякие остальные
[03:30.740 --> 03:35.740]  определения я не пишу.
[03:35.740 --> 03:48.900]  Называется DFS, расшифровывается depth first search или поиск в
[03:48.900 --> 03:49.900]  глубину.
[03:49.900 --> 03:57.980]  Значит, ну, что он делает, да, классическая постановка
[03:57.980 --> 04:02.060]  такая, вы стоите в лабиринте, вы граф воспринимаете как
[04:02.060 --> 04:04.820]  лабиринт, вы находитесь в какой-то точке, в одной
[04:04.820 --> 04:08.220]  из вершин, и вам нужно, ну, там, например, обойти
[04:08.220 --> 04:10.340]  все или дойти до какой-то конкретной вершины.
[04:10.340 --> 04:14.380]  И вы не очень хотите думать, вы просто берете и переходите
[04:14.380 --> 04:15.380]  по кому-то доступному ребру.
[04:15.380 --> 04:20.380]  Значит, мы реализуем его, я сейчас напишу наиболее
[04:20.380 --> 04:23.060]  полную реализацию, которая сохраняет наибольшее количество
[04:23.060 --> 04:24.700]  информации, которая нам потенциально понадобится.
[04:24.700 --> 04:29.580]  Значит, во-первых, как я храню граф.
[04:29.580 --> 04:34.740]  Сегодня у меня будет только ориентированные графы,
[04:34.740 --> 04:37.660]  и я их буду хранить в виде вектора-вектора.
[04:37.660 --> 04:41.580]  Значит, у меня для каждой вершины будет список ее
[04:41.580 --> 04:42.580]  соседей.
[04:42.580 --> 04:48.620]  Значит, давайте я вот здесь вот напишу, что g вот v, это
[04:48.620 --> 04:52.980]  ну, давайте прям формально, все такие u, что v, u это ребро.
[04:52.980 --> 05:02.100]  То есть для каждой вершинки v у меня есть список всех
[05:02.100 --> 05:04.420]  ее соседей, то есть то, куда я могу добраться за один
[05:04.420 --> 05:05.420]  шаг.
[05:05.420 --> 05:09.260]  Вот есть v, вот есть все ребра из нее исходящие, и они все
[05:09.260 --> 05:13.380]  лежат в списке g вот v, в векторе точнее, в векторе g вот v, все
[05:13.380 --> 05:14.620]  ее соседи за один шаг.
[05:14.620 --> 05:18.140]  Вот, ну а дальше всякая вспомогательная информация.
[05:18.140 --> 05:28.140]  Значит, давайте я заведу vector int parent, это как бы предыдущая
[05:28.140 --> 05:38.740]  вершина на пути, vector int t int out, значит, это время
[05:38.740 --> 05:41.500]  входа, время выхода из вершины, мы пока будем блуждать по
[05:41.500 --> 05:44.380]  лабиринту, каждый раз, когда мы заходим в вершину, мы
[05:44.380 --> 05:46.620]  говорим, что мы туда пришли в очередной момент времени,
[05:46.620 --> 05:48.700]  то есть у нас есть какой-то таймер, который увеличивается
[05:48.700 --> 05:51.620]  постоянно, когда мы заходим в вершину, мы туда записываем,
[05:51.620 --> 05:53.780]  когда мы пришли, когда выходим, тоже записываем, когда мы
[05:53.780 --> 05:54.780]  из нее вышли.
[05:55.780 --> 05:59.780]  Так, color мне еще нужно, видимо, все.
[05:59.780 --> 06:01.780]  Да, color.
[06:03.780 --> 06:08.780]  Давайте я строку эту назову, да, конечно, можно это гораздо
[06:08.780 --> 06:11.020]  более компактно хранить, но давайте у меня будут строки
[06:11.020 --> 06:18.700]  vector string, color, значит, я по ходу работы нашего алгоритма
[06:18.700 --> 06:23.780]  буду вершины красить в три цвета, белые, серые, черные.
[06:24.780 --> 06:26.780]  Давайте сразу напишу, что это будет значить, белые
[06:26.780 --> 06:29.780]  значит, что мы в вершине еще не были, серые значит,
[06:29.780 --> 06:32.780]  что уже побывали, но еще как бы не до конца ее просмотрели,
[06:32.780 --> 06:35.780]  то есть в каком-то смысле она в обработке, а черные
[06:35.780 --> 06:36.780]  значит, что мы ее полностью обработали, больше туда
[06:36.780 --> 06:39.780]  заходить не будем, потому что мы уже все оттуда изучили.
[06:39.780 --> 06:44.780]  Значит, white это еще не просмотренные,
[06:49.780 --> 06:52.780]  ну и поэтому изначально все вершины белые,
[06:52.780 --> 06:58.780]  gray это те вершины, которые в обработке, то есть мы их
[06:58.780 --> 07:04.780]  уже увидели, мы в них уже зашли, но еще они полностью
[07:04.780 --> 07:06.780]  обработали, то есть не закрыли, не можем сказать, что мы
[07:06.780 --> 07:11.780]  их полностью обработали, и так у меня склероз, черные
[07:11.780 --> 07:14.840]  забыл как называется, черные это те, которые полностью
[07:14.840 --> 07:17.780]  обработали, полностью обработали.
[07:22.780 --> 07:30.380]  Вот, значит, как работает DFS.
[07:30.380 --> 07:40.020]  Он принимает вершину, где мы начинаем наш путь, и
[07:40.020 --> 07:41.020]  делает следующее.
[07:41.020 --> 07:44.740]  Первым делом, когда заходит вершина, он, во-первых, помечает
[07:44.740 --> 07:48.060]  ее серой, потому что она изначально была белая, мы
[07:48.060 --> 07:50.300]  как бы вот только что в нее вступили, должны пометить,
[07:50.300 --> 07:52.260]  что мы как бы сейчас ее обрабатываем, она в обработке.
[07:52.940 --> 07:54.420]  Мы говорим, что у нее цвет серый.
[07:54.420 --> 08:01.620]  Color of V is equal to gray.
[08:01.620 --> 08:03.700]  Также мы помечаем, что мы в нее только что вошли.
[08:03.700 --> 08:12.020]  T in V равно, но я напишу timer++, в том смысле, что есть какая-то
[08:12.020 --> 08:15.940]  глобальная переменная timer, изначально равная, например,
[08:15.940 --> 08:16.940]  нулю.
[08:16.940 --> 08:17.940]  Вот.
[08:17.940 --> 08:20.020]  Ну и тогда, соответственно, мы зашли, положили сюда
[08:20.020 --> 08:21.140]  таймер и таймер увеличили.
[08:21.140 --> 08:26.620]  А то есть сказали, что вершину зашли вот в очередной момент
[08:26.620 --> 08:27.620]  времени.
[08:27.620 --> 08:28.620]  Дальше.
[08:28.620 --> 08:30.380]  Что мы делаем, собственно, с вершиной?
[08:30.380 --> 08:33.060]  Мы из нее начинаем перебирать все возможные достижимые
[08:33.060 --> 08:34.060]  ребра.
[08:34.060 --> 08:35.940]  Ну, просто все возможные исходящие ребра.
[08:35.940 --> 08:36.940]  Вот V.
[08:36.940 --> 08:38.540]  Вот мы пытаемся по всем вот этим ребрам пройти.
[08:38.540 --> 08:42.660]  Если мы видим ребро в какую-то интересную вершину, а именно
[08:42.660 --> 08:46.180]  в белую вершину, то мы, получается, нашли какой-то новый путь,
[08:46.180 --> 08:47.820]  новый маршрут, по которому мы еще не следовали.
[08:47.820 --> 08:48.820]  Вершина белая.
[08:48.980 --> 08:51.780]  Мы в ней еще как бы не бывали, она не просмотрена.
[08:51.780 --> 08:53.900]  Поэтому давайте просто из нее запустимся рекурсивно.
[08:53.900 --> 08:56.460]  Вот просто возьмем и насильно спустимся туда.
[08:56.460 --> 08:59.180]  Если мы раньше стояли в V, а нашли какую-то новую вершинку
[08:59.180 --> 09:03.620]  ту, например, которая была белая, я забываю про V, ну
[09:03.620 --> 09:06.380]  не то что забываю, а из V перехожу в ту и теперь начинаю
[09:06.380 --> 09:09.380]  делать то же самое из ту.
[09:09.380 --> 09:10.380]  Вот.
[09:10.940 --> 09:11.940]  Вот такой.
[09:13.940 --> 09:14.940]  Сейчас, одну секунду.
[09:25.940 --> 09:27.980]  Я перебираю все элементы вектора желтвы.
[09:27.980 --> 09:31.820]  Через двоеточие перебираю все элементы вектора желтвы.
[09:31.820 --> 09:35.140]  Если свет вершины ту не белый, то я просто ее скипаю.
[09:35.140 --> 09:37.460]  Потому что если она не белая, значит она либо уже в обработке
[09:37.460 --> 09:39.380]  и так, то есть мы там уже как бы побывали, не надо
[09:39.380 --> 09:40.380]  еще раз запускаться.
[09:40.380 --> 09:42.580]  Либо она вообще черная и значит мы ее полностью
[09:42.580 --> 09:45.300]  обошли и повторно делать то же самое вообще нет никакого
[09:45.300 --> 09:46.300]  смысла.
[09:46.300 --> 09:52.900]  Поэтому, если color2 не равно white, то continue.
[10:02.900 --> 10:03.900]  Так.
[10:05.900 --> 10:06.900]  Дальше.
[10:07.900 --> 10:08.900]  Значит, иначе.
[10:09.900 --> 10:15.260]  Иначе, я просто рекурсивно хочу вызваться, но еще давайте
[10:15.260 --> 10:18.140]  на всякий случай я запомню, что parent от ту равно V.
[10:18.140 --> 10:21.180]  То есть я хочу сказать, что предыдущая вершина
[10:21.180 --> 10:26.700]  на пути до ту, это V, то есть непосредственно перед тем,
[10:26.700 --> 10:29.540]  как попасть в ту, я посетил V, и собственно прошел вот
[10:29.540 --> 10:30.540]  это вот.
[10:30.540 --> 10:33.620]  Чтобы попасть в ту, я прошел, приберу V2, записал, что
[10:33.620 --> 10:36.580]  предыдущая вершинка это V, ну и соответственно
[10:36.580 --> 10:37.580]  Vfs от ту.
[10:40.580 --> 10:46.260]  Вот цикл закончился, и в конце, когда мы все ребра
[10:46.260 --> 10:48.380]  перебрали, то есть смотрите, вот этот цикл полностью
[10:48.380 --> 10:53.220]  завершился, мы перебрали все исходящие ребра, и теперь
[10:53.220 --> 10:57.780]  мы должны завершить вызов рекурсии, пометить вершину
[10:57.780 --> 10:59.980]  использованной, полностью обработанной, то есть, во-первых,
[10:59.980 --> 11:01.980]  мы ей цвет меняем на черный.
[11:06.580 --> 11:11.300]  Во-вторых, мы говорим, что мы из нее выходим, то
[11:11.300 --> 11:16.300]  есть tout задаем, время выхода задаем, какое-то фиксированное,
[11:16.300 --> 11:18.380]  опять-таки таймер плюс-плюс, потому что у меня сквозное
[11:18.380 --> 11:19.380]  время всего.
[11:19.380 --> 11:20.380]  Вот.
[11:20.380 --> 11:25.340]  Ну и все, завершить рекурсивный вызов, вот очень простой
[11:25.340 --> 11:26.340]  алгоритм.
[11:26.340 --> 11:28.900]  Да, вот на этом примере, если мы стояли вот здесь
[11:28.900 --> 11:31.620]  вот, то есть если мы сначала как-то попали в V, потом прошли
[11:31.620 --> 11:34.620]  по ту, то мы сначала обойдем целиком все, что достижено
[11:34.620 --> 11:37.780]  из ту, как бы, потом вызов рекурсивный закончится,
[11:37.780 --> 11:41.460]  мы пометим ту черный, вернемся в V, то есть у меня завершился
[11:41.460 --> 11:44.660]  рекурсивный вызов, я вернулся на уровень рекурсии наверх,
[11:44.660 --> 11:47.340]  у меня стал обрабатываться опять V, я здесь дошел все
[11:47.340 --> 11:50.220]  вот эти вот ребра, что-то там еще обошел, потом завершился
[11:50.220 --> 11:53.060]  вызов из V, опять поднялись наверх, ну и так далее, пока
[11:53.060 --> 11:57.300]  у нас вся рекурсия не… короче, пока stack рекурсии
[11:57.300 --> 11:58.300]  не очистится.
[11:58.300 --> 12:03.100]  Так, вот такой алгоритм, пока, просто без измысления
[12:03.100 --> 12:06.780]  того, что он делает, понятно ли, в смысле, без измысления
[12:06.780 --> 12:10.100]  того, как бы, на что он направлен, на что он там посещает и
[12:10.100 --> 12:12.620]  так далее, что проверяет, понятно ли реализация.
[12:12.620 --> 12:19.180]  Так, ну хорошо, вот, вроде ничего не забыл.
[12:19.180 --> 12:24.300]  Значит, Лемма, о том, как он работает, называется
[12:24.300 --> 12:25.300]  Лемма о белых путях.
[12:25.300 --> 12:41.940]  Я вот ожидаю следующее, смотрите, вот давайте рассмотрим
[12:41.940 --> 12:47.140]  момент времени, вот этот, когда мы только-только зашли
[12:47.140 --> 12:50.420]  в вершину, пометили ее серой, и соответственно, проставили
[12:50.420 --> 12:55.660]  в ней момент входа, время входа, значит, дальше прокрутили
[12:55.660 --> 12:59.420]  какое-то время, пока все вот это прошло, когда произойдет
[12:59.420 --> 13:02.180]  вот это, то есть рассмотрим два момента времени, начало
[13:02.180 --> 13:04.980]  входа в вершину и, соответственно, конец выхода из вершины.
[13:04.980 --> 13:07.260]  Вот я вот ожидаю, что за это время, между этими два
[13:07.260 --> 13:10.180]  момента времени, между этими два момента, между входом
[13:10.180 --> 13:13.980]  и выходом из вершины конкретной, мы посетим те и только те
[13:13.980 --> 13:16.660]  вершины, которые достижены по белым путям.
[13:16.660 --> 13:45.100]  Для любого, за время между ТИ на ТВ и ТАУТ от В, DFS обойдет
[13:45.100 --> 13:53.580]  и пометит черными те и только те вершины, которые были
[13:53.580 --> 14:02.200]  в этот момент времени достижимы по белым путям, те и только
[14:02.200 --> 14:19.600]  те вершины, которые были достижимы из В в момент времени
[14:20.380 --> 14:40.780]  входа по полностью белым путям. Вот есть какая-то
[14:40.780 --> 14:45.740]  вершинка В, мы в нее зашли, сразу покрасили в серый,
[14:45.740 --> 14:48.540]  а теперь, значит, мой вопрос, а что будет к моменту времени,
[14:48.540 --> 14:52.720]  когда этот ДФС от В закончится, когда я обойду, ДФС от В закончится,
[14:52.720 --> 14:55.520]  я все ребра там переберу. Вот я утверждаю, что все,
[14:55.520 --> 14:58.720]  что посетим, все, что мы посетим, это в точности
[14:58.720 --> 15:02.360]  такие пути, точнее вершины на путях, что здесь все вершинки
[15:02.360 --> 15:05.560]  были белые изначально. Вот если там они все были
[15:05.560 --> 15:08.360]  белые, то я их все обязательно посещу к моменту времени
[15:08.360 --> 15:11.280]  выхода из В, и более того, я их уже перекрашу в черный,
[15:11.280 --> 15:13.560]  то есть не просто посещу, но и целиком закончу обработку.
[15:13.560 --> 15:18.180]  Такое нехитрое утверждение. Доказательства.
[15:18.180 --> 15:30.420]  Так, ну почему мы не посетим ничего лишнего? Почему мы
[15:30.420 --> 15:32.420]  можем посетить только то, что достижимо по белым
[15:32.420 --> 15:35.500]  путям? Ну потому что, что такое достижимо, да, это
[15:35.500 --> 15:38.500]  то, куда я как бы перейду в процессе обхода. Перехожу
[15:38.500 --> 15:41.300]  я только в белые вершины каждый раз, поэтому ничего
[15:41.400 --> 15:44.120]  кроме белых вершин, ничего кроме тех вершин, которые
[15:44.120 --> 15:46.640]  были изначально белыми, я посетить не смогу. Поэтому
[15:46.640 --> 15:51.400]  могу посетить только то, что белое. Могу посетить
[15:51.400 --> 16:07.400]  только белые вершины по белым путям. Следовательно,
[16:07.400 --> 16:15.140]  на лишнего ничего не обойду. Лишнего не обойду. Вот.
[16:15.140 --> 16:17.740]  Значит, почему я верну в обратную сторону, что все,
[16:17.740 --> 16:20.020]  что достижимо по белым путям, обойдется? Давайте
[16:20.020 --> 16:28.140]  рассмотрим произвольный белый путь. Почему к моменту
[16:28.140 --> 16:34.300]  времени выхода отсюда я все это обойду? Так, ну для
[16:34.300 --> 16:36.300]  этого надо сначала понять, как у нас устроен стэк
[16:36.300 --> 16:39.340]  рекурсии. Значит, что у нас лежит в стэке рекурсии?
[16:39.340 --> 16:45.640]  В стэке рекурсии, я утверждаю, всегда лежит некоторый путь
[16:45.640 --> 16:56.640]  по серым вершинам. Путь из серых вершин. Значит,
[16:56.640 --> 16:59.520]  это более или менее очевидно, потому что как он формируется?
[16:59.520 --> 17:02.040]  Мы запускаемся откуда-то там из начала, из некого
[17:02.040 --> 17:06.040]  корня, сразу покрасили его в серый. Дальше, когда у
[17:06.040 --> 17:08.040]  нас раздувается стэк рекурсия, когда я из текущей вершины
[17:08.040 --> 17:10.160]  перехожу куда-то дальше, в вершину, которая была
[17:10.160 --> 17:12.520]  до этого белой. То есть вот я нашел очередное ребро
[17:12.520 --> 17:18.000]  в белую вершину, перекрасил ее в серый, грей, и запустился
[17:18.000 --> 17:20.240]  от нее рекурсивно. То есть у меня было ребро из этой
[17:20.240 --> 17:24.640]  серой в эту серую. Дальше, запускаюсь отсюда. Опять
[17:24.640 --> 17:28.080]  перебираю все ребра, нахожу ребро в белую, если нашел,
[17:28.080 --> 17:32.200]  то запускаюсь отсюда, перекрашиваю сразу в серую. Ну и так далее.
[17:32.200 --> 17:34.260]  Поэтому в любой момент времени стэк это всегда путь по
[17:34.260 --> 17:39.540]  серым. Ну и когда я откатываюсь, когда запускается рекурсивный
[17:39.540 --> 17:42.180]  запуск от какой-то вершины, у меня просто наш путь немножко
[17:42.180 --> 17:43.900]  обрывается, последнее ребро удаляется, последняя
[17:43.900 --> 17:46.500]  вершина с ним удаляется. Поэтому в стэке всегда путь
[17:46.500 --> 17:49.980]  из серых вершин. И значит, давайте рассмотрим, что
[17:49.980 --> 17:52.140]  происходит в момент времени ты над В. То есть я начал
[17:52.140 --> 17:57.260]  в Р, шел по серым вершинам, дошел до В, и В только что
[17:57.260 --> 17:59.020]  поместилось в качестве очередной серой вершины
[17:59.020 --> 18:01.460]  в наш стэк рекурсии. То есть я дошел до сюда, стэк
[18:01.460 --> 18:03.660]  у меня теперь вот такой, стэк рекурсии. И дальше
[18:03.660 --> 18:06.420]  я начинаю что-то обходить. Тогда в момент времени
[18:06.420 --> 18:09.220]  ты аут от В, это когда я вот здесь что-то еще пообходил
[18:09.220 --> 18:11.660]  и стэк вернулся к тому состоянию, когда вот, как
[18:11.660 --> 18:14.660]  если бы В еще не было добавлен. То есть я В опять удаляю
[18:14.660 --> 18:17.060]  из стэка рекурсии, это как условие выхода отсюда.
[18:17.060 --> 18:20.460]  Я ее удаляю, делаю черной, она уходит из стэка рекурсии,
[18:20.460 --> 18:25.500]  как бы мы закончили ее обработку. Поэтому смотрите,
[18:25.500 --> 18:29.100]  к моменту времени выхода серое это то же самое, что
[18:29.100 --> 18:32.820]  было изначально. То есть что было серым в начале,
[18:32.820 --> 18:35.060]  с момента времени ты и на ТВ, оно же собственно
[18:35.060 --> 18:37.980]  и есть серое к моменту времени ты аут от В. Потому что это
[18:37.980 --> 18:42.580]  просто вот весь этот путь. Поэтому ничего кроме белого
[18:42.580 --> 18:45.140]  и черного я здесь получить не могу. У меня серые все
[18:45.140 --> 18:50.780]  только вот эти. Все что было серым остается серым. Значит,
[18:50.780 --> 18:56.680]  отсюда вот эти вот вершины, которые достижимы по белым
[18:56.680 --> 19:04.120]  путям, они теперь точно не серые. Значит, вершины
[19:04.120 --> 19:17.760]  достижимые по белым путям точно не серые. Значит, надо
[19:17.760 --> 19:19.700]  только разобраться с белыми и черными. То есть серые
[19:19.700 --> 19:22.720]  отдельно, они вот здесь, с ними все нормально. Вопрос
[19:22.720 --> 19:25.240]  почему тогда они все покрасятся в черные? Почему? То есть
[19:25.320 --> 19:27.340]  мы понимаем, что они не могут покраситься в серые, потому
[19:27.340 --> 19:29.680]  что они не могут попасть в стек рекурсии выше чем
[19:29.680 --> 19:32.080]  В. Значит, они все либо белые, либо черные. Вот почему
[19:32.080 --> 19:33.960]  не все в черные окрасть, а почему не все обработаются.
[19:55.240 --> 20:16.840]  Так, интересно. Давайте предпологаем, что это неверно,
[20:16.840 --> 20:18.680]  и что найдется какая-то вершина, которая раньше была
[20:18.680 --> 20:23.160]  достижена по белому пути, но после выхода из В она
[20:23.200 --> 20:25.680]  будет не обработана, то есть будет белой. Если она
[20:25.680 --> 20:28.360]  черная, то уже все хорошо, мы доказали, что надо. Вопрос
[20:28.360 --> 20:30.200]  почему она может быть белой? Может она быть белой? То
[20:30.200 --> 20:37.960]  есть вот раньше был какой-то путь по белым, и к моменту
[20:37.960 --> 20:41.800]  времени выхода отсюда это по-прежнему белое. Ну хорошо,
[20:41.800 --> 20:43.640]  давайте рассмотрим этот путь. Вот какой-то путь из
[20:43.640 --> 20:46.400]  белых, которые изначально были белые, пусть это белое
[20:46.400 --> 20:51.480]  в конце. Давайте на этом пути посмотрим самую низкую
[20:52.100 --> 20:55.520]  И� пусть вот эта перекрасилась черной, эта перекрасилась
[20:55.520 --> 20:59.200]  черная, а эта осталась белой. То есть из всех вершин
[20:59.200 --> 21:02.320]  на белом пути рассмотрим самую высокую оставшуюся
[21:02.320 --> 21:05.640]  белую. Эти все перекрасились, мы знаем, что они обязательно
[21:05.640 --> 21:07.880]  перекрасились в черный, потому-что серый мы знаем,
[21:07.880 --> 21:11.160]  мы их уже обработали, это стекр рекурсия. Все их
[21:11.160 --> 21:13.620]  в черный, а эта осталась в белый. Но вот извините,
[21:13.620 --> 21:16.740]  как вот эта могла в черный перекраситься, если это
[21:16.740 --> 21:19.320]  по-прежнему белое? Потому что в черный мы вершину
[21:19.320 --> 21:21.480]  можем перекрасить только в случае, когда мы из нее
[21:21.480 --> 21:24.320]  все ребра просмотрели и все ходы в белые вершины
[21:24.320 --> 21:27.760]  совершили. А здесь, смотрите, у меня было ребро отсюда
[21:27.760 --> 21:31.680]  в белую, и она осталась белой, то есть я как бы туда
[21:31.680 --> 21:34.880]  не зашел, ДФС туда не заходил, но при этом эта вершина почему-то
[21:34.880 --> 21:36.800]  черная. Ну, понятно, что бред, у нас алгоритм не так
[21:36.800 --> 21:40.040]  работает. Значит, такого не бывает, и все, весь путь
[21:40.040 --> 21:42.600]  должен быть обязательно черный. Значит, давайте
[21:42.600 --> 21:50.200]  зафиксируем как-нибудь. Пусть какая-то ум осталась
[21:50.200 --> 22:02.960]  белой, осталась белой. Тогда рассмотрим самую высокую
[22:02.960 --> 22:19.040]  вершину на пути из ВДУ. Ее родитель перекрасился
[22:19.040 --> 22:21.400]  черный, значит, это ребро должно было быть просмотрено
[22:21.400 --> 22:31.280]  противоречием. Ее родитель черный. Черный, значит,
[23:01.280 --> 23:16.080]  белый. Такое техническое утверждение, казалось бы,
[23:16.080 --> 23:19.520]  зачем мы его доказываем. Ну, раз уж мы хотим хоть
[23:19.520 --> 23:22.040]  какой-то формализм придать, то, наверное, стоит. Вот,
[23:22.040 --> 23:24.480]  зато отсюда сразу следует следующие два простых факта.
[23:24.480 --> 23:30.720]  Значит, факт первый, следствие. Если мы изначально все вершины
[23:30.860 --> 23:35.240]  окрасим в белый, и из мейна запускаем DFS от S, какой-то
[23:35.240 --> 23:37.680]  произвольной вершины, то к моменту завершения
[23:37.680 --> 23:41.200]  мы обойдем в точности все, что достижено из С, потому
[23:41.200 --> 23:43.820]  что если изначально все белое, то достижимость по
[23:43.820 --> 23:45.600]  белым вершинам, это то же, что просто достижимость,
[23:45.600 --> 23:47.800]  потому что у нас все вершины белые изначально. Значит,
[23:47.800 --> 23:50.240]  к моменту завершения DFS мы обойдем просто все, что
[23:50.240 --> 23:55.280]  достижено. Если все вершины изначально белые в тех
[24:00.720 --> 24:08.720]  то давайте напишу так. Внешне давайте напишу я запуске
[24:08.720 --> 24:11.360]  DFS буду разрядить на внешне и внутреннее. Внешне это
[24:11.360 --> 24:13.720]  те, которые запускаются, грубо говоря, из мейна,
[24:13.720 --> 24:16.120]  из собственного тела программы, а внутренне это то, когда
[24:16.120 --> 24:18.760]  DFS сам себя запускает. Вот внутренне это как бы рекурсивные
[24:18.760 --> 24:22.800]  запуски DFS самого себя, а внешне когда вот там другая
[24:22.800 --> 24:25.160]  процедура его использует. Мы в качестве мейна его
[24:25.160 --> 24:35.480]  использует. Внешний запуск DFS обойдет в точности все
[24:36.280 --> 24:55.720]  DFS. Потому что достижимость и достижимость по белым
[24:55.720 --> 24:58.360]  это одно и то же, а лемма белых путях говорит, что все,
[24:58.360 --> 25:02.160]  что достижим по белому путям мы обойдем. Так, это был
[25:02.360 --> 25:09.480]  следствие 1, следствие 2. DFS позволяет проверять граф на
[25:09.480 --> 25:12.960]  отключенность или, наоборот, на наличие цикла. Значит,
[25:12.960 --> 25:23.200]  как найти цикл? Я утверждаю следующее, что в графе
[25:23.200 --> 25:35.440]  существует цикл, достижимый из S. Цикл – это замкнутый
[25:35.440 --> 25:37.520]  маршрут по ребрам, то есть я иду-иду по ребрам, их
[25:37.520 --> 25:40.520]  ваза 6 туда откуда начал. Цикл, достижимый из S, значит,
[25:40.520 --> 25:44.400]  что я встал в S, прошел по ребрам и потом вошел в цикл
[25:44.400 --> 25:46.880]  каким-то образом. Сначала как бы предпериод, потом
[25:46.880 --> 25:50.760]  период по циклу. Так вот, такой цикл существует, если
[25:50.760 --> 25:52.640]  и только если в какой-то момент времени мы видим
[25:52.640 --> 26:08.600]  ребро в серую вершину. Если, если после внешнего
[26:08.600 --> 26:24.960]  запуска DFS от S, когда-то находит ребро в серую вершину.
[26:24.960 --> 26:27.640]  Не просто если, а если и только если. Давайте равносильность
[26:27.640 --> 26:31.160]  тут напишем. Если и только если, мы когда-либо видим
[26:31.160 --> 26:35.320]  ребро в серую вершину. Давайте напомню, как у нас работает
[26:35.880 --> 26:42.400]  мы идем по стеку рекурсии, красим вершины в серый. В
[26:42.400 --> 26:45.240]  момент времени, когда мы целиком рассмотрели все
[26:45.240 --> 26:47.640]  ребра, идти дальше некуда, мы вершину из стеки рекурсии
[26:47.640 --> 26:50.360]  удаляем и поднимаемся к предыдущей вершине в стеке
[26:50.360 --> 26:52.720]  рекурсии. Так вот, если я когда-то вижу ребро из
[26:52.720 --> 26:56.720]  текущей в какую-то более раннюю серую, а серый у меня
[26:56.720 --> 26:58.760]  это только более ранний, да, поэтому только куда-то
[26:58.760 --> 27:01.320]  выше по стеку рекурсии, если я нахожу такое ребро,
[27:01.320 --> 27:03.800]  то у меня есть цикл. И наоборот, любой цикл, ну не любой
[27:03.800 --> 27:07.040]  цикл я нахожу, а по крайней мере один такой цикл я найду.
[27:07.040 --> 27:13.400]  Значит, ну доказательства. То есть тут на самом деле
[27:13.400 --> 27:16.600]  два утверждения, что если цикл есть, то я его найду,
[27:16.600 --> 27:22.400]  и что если я нашел ребро в серую, то это цикл. Давайте
[27:22.400 --> 27:25.640]  справа налево. Так раз если я нашел ребро в серую, то
[27:25.640 --> 27:28.160]  это цикл. Ну это тривиально. Что такое ребро в серую?
[27:28.160 --> 27:30.400]  Еще раз вспоминаем, что стек рекурсии это все серые
[27:31.400 --> 27:42.520]  вершины. Серые. Поэтому ребро в серую это как раз ребро
[27:42.520 --> 27:45.520]  в одного из предков. То есть был вот такой путь по серым.
[27:45.520 --> 27:51.000]  Серая, серая, серая, серая. И я из текущей нашел ребро
[27:51.000 --> 27:53.760]  в серую. Ну поэтому вот он вам цикл, понятное дело.
[27:53.760 --> 27:56.400]  Да, если был путь, и я нашел ребро в какую-то одну из
[27:56.400 --> 27:58.240]  предыдущих, то очевидно есть цикл.
[27:58.240 --> 28:06.440]  Теперь обратно. Почему я гарантированно найду хотя
[28:06.440 --> 28:08.520]  бы один из циклов таким образом? То есть почему если
[28:08.520 --> 28:11.880]  в графе есть цикл, то я найду его таким алгоритмом, то
[28:11.880 --> 28:15.840]  есть что обязательно будет ребро в серую. Давайте посмотрим.
[28:15.840 --> 28:20.160]  Пусть есть некий цикл конкретный. Вот есть S, есть достижимый
[28:20.240 --> 28:25.240]  из S некий цикл. Почему я обязательно его обнаружу?
[28:25.240 --> 28:34.240]  Ну на самом деле это неверно. Я скорее обнаружу. Я просто
[28:34.240 --> 28:36.680]  обнаружил один из циклов. На самом деле задача нахождения
[28:36.680 --> 28:39.760]  всех циклов, наверное, трудная. Я не ставлю себе такой задачи.
[28:39.760 --> 28:42.960]  Я просто как бы найду хоть какой-то цикл. Так вот почему
[28:42.960 --> 28:44.960]  если есть один цикл, то я найду хотя бы какой-то.
[28:44.960 --> 28:49.800]  Ну вот смотрите, давайте я в этом цикле найду вершину
[28:49.800 --> 28:54.400]  с минимальным т.ин. Вот если есть цикл, какой-то замкнутый
[28:54.400 --> 28:57.600]  маршрут, давайте я в этом цикле найду вершину с минимальным
[28:57.600 --> 29:01.400]  т.ин. А поскольку у меня из S достижим весь этот цикл,
[29:01.400 --> 29:04.120]  то значит все эти вершины рано или поздно, я в них
[29:04.120 --> 29:06.600]  рано или поздно приду, поэтому я могу выбрать вершину с
[29:06.600 --> 29:18.480]  минимальным т.ин. Так вот пусть U это вершина из цикла
[29:18.480 --> 29:28.480]  с минимальным значением т.ин. Вот она U. Да, ну потому
[29:28.480 --> 29:31.160]  что на самом деле я не знаю как именно я от S добрался
[29:31.160 --> 29:34.600]  до этого цикла. Я мог как-нибудь вот так добраться. Мог как-нибудь
[29:35.440 --> 29:37.880]  вот так вот и потом другой цикл какой-то найти. Короче
[29:37.880 --> 29:40.480]  все кого знают. Вот пусть U это самое первое вот вхождение
[29:40.480 --> 29:43.960]  которое наш DFS нашел. То есть я к моменту времени
[29:43.960 --> 29:46.960]  входа в U еще больше ни в каких других вершинах этого
[29:46.960 --> 29:51.920]  цикла не бывал. Но тогда смотрите, когда я зашел сюда,
[29:51.920 --> 29:57.080]  я сразу крашу ее серый, а остальные вершины цикла
[29:57.080 --> 29:59.480]  по-прежнему белые, потому что U это вершина с минимальным
[29:59.480 --> 30:03.000]  т.ин. Значит к моменту времени входа в нее еще никакие другие
[30:03.160 --> 30:07.720]  цикла не были даже просмотрены, не были увидены. Значит к моменту
[30:07.720 --> 30:10.960]  времени выхода отсюда я все эти вершины полей на белых
[30:10.960 --> 30:14.200]  путях, я все эти вершины обработаю покрашив черный.
[30:14.200 --> 30:21.600]  Но давайте в частности посмотрим на вот эту вершину как бы
[30:21.600 --> 30:26.200]  предыдущую на цикле. Я ее обработаю, я закончил обработку
[30:26.200 --> 30:29.080]  до того как я закончил обработку вершины U. Значит к моменту
[30:29.080 --> 30:31.880]  времени когда я нахожусь здесь, у меня вершина U по-прежнему
[30:31.880 --> 30:38.760]  серая, значит я найду ребро в серую вершину победа. Так
[30:38.760 --> 30:43.160]  вот, в этот момент времени давайте запишем в этот момент
[30:43.160 --> 30:49.920]  U серая, а остальные вершины цикла белые.
[31:02.880 --> 31:09.480]  Пусть V это предыдущая вершина на цикле, предыдущая перед U,
[31:09.480 --> 31:18.160]  предыдущая перед U вершина на цикле,
[31:18.160 --> 31:28.040]  значит мы до нее дойдем до того как завершим обход U, потому
[31:28.120 --> 31:32.880]  что V достижим по белым пути. Значит в момент времени
[31:32.880 --> 31:38.400]  обработки V мы увидим ребро в серую вершину U. При обработке
[31:38.400 --> 32:00.080]  V мы увидим ребро в серую вершину U. Победа. Нормально?
[32:00.080 --> 32:08.640]  Чудесно.
[32:30.640 --> 32:33.440]  Если бы у нас была задача просто такая, проверить
[32:33.440 --> 32:36.880]  существует ли в графе цикл достижимый из S, я запускаю
[32:36.880 --> 32:40.960]  DFS от S, внешне DFS от S, он что там обходит, и если надо
[32:40.960 --> 32:44.480]  еще DFS подправить, то если я вижу ребро в серую, то
[32:44.480 --> 32:47.720]  говорим, что вот-вот он цикл. Более того, если бы мне
[32:47.720 --> 32:50.160]  нужно было именно вывести последовательность вершин
[32:50.160 --> 32:52.320]  на этом цикле, то есть что это за цикл, не просто сказать
[32:52.320 --> 32:54.840]  есть он или нет, а сказать вершины лежащие на этом
[32:54.840 --> 32:58.880]  цикле, то мне можно было бы просто по pair'ам пропрыгать
[32:58.880 --> 33:02.880]  до вершинки U, и это был бы как раз тот самый цикл,
[33:02.880 --> 33:04.920]  который мы ищем, потому что если мы здесь нашли
[33:04.920 --> 33:08.040]  ребро вот сюда, то parent у меня как раз все ребра из
[33:08.040 --> 33:11.200]  stack'а рекурсии. Вот это вот parent от текущей вершины,
[33:11.200 --> 33:13.440]  это parent от parent и так далее, то есть я могу прыгать по
[33:13.440 --> 33:16.160]  parent, пока не дойду до этой вершинки, которая ведет
[33:16.160 --> 33:19.640]  по стрелке, и тогда это и будет как раз цикл, который
[33:19.640 --> 33:25.360]  мы искали. Все, вот такой мощный инструмент.
[33:25.360 --> 33:38.120]  Дальше, значит, что мы хотим сделать? Ну, давайте пусть
[33:38.120 --> 33:51.600]  будет определение. DAG, от английского directed acyclic graph,
[33:51.600 --> 33:55.320]  это собственно ориентированный циклический граф, ориентированный
[33:55.320 --> 34:08.480]  граф без циклов, напишу так, граф без циклов. Я буду
[34:08.480 --> 34:10.960]  часто говорить просто DAG, потому что мне лень говорить
[34:10.960 --> 34:27.280]  фразу граф без циклов, да, DAG проще, acyclic, ну, как бы
[34:27.280 --> 34:28.520]  acyclic. Вот, и для DAG'ов есть такое удобное понятие как
[34:28.520 --> 34:39.840]  топологическая сортировка. Это перестановка вершин,
[34:40.160 --> 34:43.180]  что любое ребро ведет только из вершины с меньшим номером
[34:43.180 --> 34:54.120]  вершин с большим номером. Такая перестановка вершин,
[34:54.120 --> 35:06.560]  что любое ребро ведет, ну, я напишу, слева направо.
[35:06.560 --> 35:08.240]  То есть, из вершины с меньшим номером, вершины с большим
[35:08.240 --> 35:10.480]  большим номером. То есть я могу вот так вот изобразить
[35:10.480 --> 35:14.400]  мои вершины на прямой, что все ребра ведут как бы вот
[35:14.400 --> 35:17.960]  так вот, слева направо. Нет ребер, нет ребер в обратную
[35:17.960 --> 35:29.760]  сторону. Вот. Ну, простое утверждение
[35:29.760 --> 35:35.120]  терреалгоритм, что топсор существует только у дагов,
[35:36.060 --> 35:39.580]  топсорт существует только если граф является дагом
[35:39.580 --> 35:43.940]  и топсорт можно найти за линейное время.
[35:43.940 --> 35:50.000]  Топологическая сортировка существует только если
[35:50.000 --> 35:58.960]  граф является дагом. И находится за линейное время.
[35:58.960 --> 36:03.960]  Значит, топ-сорт существует и находится линейное время.
[36:03.960 --> 36:09.960]  Вот, ну, смотрите, значит, здесь линейное время – это
[36:09.960 --> 36:11.960]  всегда линейное время от размера графа.
[36:11.960 --> 36:14.960]  Размер графа – это у меня n плюс m, где n – это число
[36:14.960 --> 36:17.960]  вершин, то есть мощность в множество v, а m – это число
[36:17.960 --> 36:18.960]  ребер.
[36:18.960 --> 36:19.960]  Я буду всегда, скорее всего, использовать такие
[36:19.960 --> 36:20.960]  обозначения.
[36:20.960 --> 36:22.960]  n вершины и m ребер у меня в графе.
[36:22.960 --> 36:25.960]  Ну, поэтому линия у меня мерится суммарно от размера
[36:25.960 --> 36:27.960]  графа, от n плюс m.
[36:27.960 --> 36:28.960]  Вот.
[36:28.960 --> 36:31.960]  Ну, доказательства.
[36:31.960 --> 36:34.960]  Значит, слева направо.
[36:34.960 --> 36:37.960]  Почему, если топ-сорт есть, то граф циклический?
[36:37.960 --> 36:41.960]  Ну, я симпеню, у меня все ребра слева направо, а цикл
[36:41.960 --> 36:42.960]  он как бы есть.
[36:42.960 --> 36:45.960]  Если он идет слева направо, то ему надо когда-то вернуться
[36:45.960 --> 36:48.960]  в начало, значит, ему надо, чтобы ребро его справа
[36:48.960 --> 36:49.960]  налево.
[36:49.960 --> 36:53.960]  Очевидно, даже не знаю, что это написать.
[36:53.960 --> 36:56.960]  Просто если все ребра слева направо, то цикл мы никак
[36:56.960 --> 36:57.960]  не получим.
[36:57.960 --> 36:59.960]  Мы всегда только увеличиваем номер, мы не можем вернуться
[36:59.960 --> 37:00.960]  туда, откуда начали.
[37:00.960 --> 37:04.960]  Теперь в обратную сторону.
[37:04.960 --> 37:07.960]  Мне нужно показать, как найти топ-сорт дага за линейное
[37:07.960 --> 37:08.960]  время.
[37:08.960 --> 37:13.960]  Предъявим алгоритм.
[37:13.960 --> 37:16.960]  Предъявим алгоритм.
[37:16.960 --> 37:25.960]  Поиска топ-сорт на даге за линейное время.
[37:25.960 --> 37:34.960]  Так, алгоритм следующий.
[37:34.960 --> 37:37.960]  Алгоритм следующий.
[37:37.960 --> 37:47.960]  Мы перебираем все вершины графа и запускаем внешний
[37:47.960 --> 37:51.960]  DFS для всех белых вершин.
[37:51.960 --> 38:07.960]  Если color от s равно white, то запускаем DFS от s.
[38:07.960 --> 38:09.960]  Потому что мы знаем, что DFS от s обойдет только то,
[38:09.960 --> 38:12.960]  что достижено из s, но, возможно, не весь граф, то есть какой-то
[38:12.960 --> 38:13.960]  кусок графа.
[38:13.960 --> 38:15.960]  А я хочу весь граф обойти, поэтому я сначала прохожусь
[38:15.960 --> 38:17.960]  по всем вершинам, да, во внешнем цикле.
[38:17.960 --> 38:19.960]  Если вижу, что вершина не посещена, я из нее запускаю
[38:19.960 --> 38:20.960]  DFS.
[38:20.960 --> 38:21.960]  Он там что-то обойдет.
[38:21.960 --> 38:22.960]  Вот.
[38:22.960 --> 38:29.960]  И в конце топологичная сортировка – это сортировка
[38:29.960 --> 38:36.960]  вершин в порядке убывания tout.
[38:36.960 --> 38:52.960]  Но у нас DFS работает, он при входе, при выходе выставляет
[38:52.960 --> 38:53.960]  конкретное tntout.
[38:53.960 --> 38:55.960]  Это какие-то числа.
[38:55.960 --> 38:57.960]  Причем, более того, это небольшие числа, не больше
[38:57.960 --> 39:00.960]  чем 2n примерно, да, потому что таймер у нас увеличивается
[39:00.960 --> 39:02.960]  при входе и увеличивается при выходе.
[39:02.960 --> 39:05.960]  Всего в ходах и выходах линейное количество, поэтому
[39:05.960 --> 39:06.960]  числа не очень большие.
[39:06.960 --> 39:09.960]  Но если уж надо, сортировку в порядке убывания можно
[39:09.960 --> 39:11.960]  сделать за линейное время, сортировкой подсчетом,
[39:11.960 --> 39:13.960]  потому что все значения небольшие, поэтому можно
[39:13.960 --> 39:15.960]  посортить за линию.
[39:15.960 --> 39:18.960]  Поэтому сортировка – это не очень страшная вещь.
[39:18.960 --> 39:21.960]  Но на самом деле можно и похитрее, можно заметить,
[39:21.960 --> 39:23.960]  что можно просто каждый раз, когда мы вышли из вершины,
[39:23.960 --> 39:27.960]  у нее минимальный tout, мы можем запихнуть в конец
[39:27.960 --> 39:28.960]  нашего списка.
[39:28.960 --> 39:30.960]  Ну и тогда, соответственно, справа налево восстановить
[39:30.960 --> 39:32.960]  эту перестановку, и тоже будет за линию, даже без
[39:32.960 --> 39:33.960]  всякой сортировки.
[39:33.960 --> 39:36.960]  Ну то есть тут нет проблем с тем, как это посортировать,
[39:36.960 --> 39:38.960]  это уже вопрос реализации.
[39:38.960 --> 39:40.960]  То есть получается вот этот конкретный шаг.
[39:40.960 --> 39:43.960]  Если у нас весь алгоритм отработал за быстро, то
[39:43.960 --> 39:45.960]  сама сортировка работает за линию.
[39:45.960 --> 39:48.960]  Так или иначе, можем все вершины порядочить за
[39:48.960 --> 39:50.960]  длинное время.
[39:50.960 --> 39:55.960]  Ну а алгоритм DFS, очевидно, работает за m+, потому что
[39:55.960 --> 39:58.960]  мы никакую вершину больше одного раза не войдем.
[39:58.960 --> 40:01.960]  Вход в вершину означает ее покраска с белой на серую,
[40:01.960 --> 40:03.960]  выход с серой на черную.
[40:03.960 --> 40:05.960]  Поэтому вход в вершину максимум один раз, и каждый
[40:05.960 --> 40:08.960]  ребро просмотрится тоже максимум один раз.
[40:08.960 --> 40:11.960]  Потому что, если я сюда зашел один раз, то, соответственно,
[40:11.960 --> 40:14.960]  каждое конкретное ребро просмотрится только один раз.
[40:14.960 --> 40:16.960]  Значит, у меня каждая вершина просмотрится максимум
[40:16.960 --> 40:19.960]  один раз, и каждое ребро максимум один раз, поэтому
[40:19.960 --> 40:21.960]  время суммарно на n+.
[40:21.960 --> 40:23.960]  Время таковой корректности мы докажем после перерыва.
[40:23.960 --> 40:27.960]  Смотрите, я предъявил алгоритм, сейчас хочу доказать
[40:27.960 --> 40:28.960]  его корректность.
[40:28.960 --> 40:29.960]  То есть мы чего-то делаем.
[40:29.960 --> 40:35.000]  Я утверждаю, что если у меня на входе был DAG, то такая
[40:35.000 --> 40:38.080]  перестановка вершины является, на самом деле, типологической
[40:38.080 --> 40:39.080]  сортировкой.
[40:39.080 --> 40:40.080]  Ну почему?
[40:40.080 --> 40:41.920]  Надо просто доказать отсутствие ребер справа налево.
[40:41.920 --> 40:45.560]  То есть я управлял вершины в порядке бывания таута,
[40:45.560 --> 40:47.720]  хочу доказать, что если есть какое-то ребро, то
[40:47.720 --> 40:56.080]  он обязательно слева направо, доказать свою корректность.
[40:56.080 --> 40:58.920]  Мне достаточно показать, что если какое-то ребро
[40:58.920 --> 41:02.440]  было в исходном графе, то эта вершина напечатается
[41:02.440 --> 41:08.040]  в нашей сортировке раньше, то есть у нее больше таут.
[41:08.040 --> 41:10.000]  Если есть ребро, то это должно быть раньше, то есть у нее
[41:10.000 --> 41:12.520]  должно быть больше таут.
[41:12.520 --> 41:19.480]  Достаточно доказать, что таут от Ум больше, чем
[41:19.480 --> 41:20.480]  таут от В.
[41:20.480 --> 41:27.760]  Чтобы это доказать, давайте переберем, какая из двух
[41:27.760 --> 41:30.920]  вершин У и В была посещена первой, то есть у кого из
[41:30.920 --> 41:31.920]  них меньше Таин.
[41:31.920 --> 41:40.760]  Случай первый, Таин от У меньше Таин от В, то есть
[41:40.760 --> 41:45.040]  когда я зашел в У, В белая, В еще не обработана, я в ней
[41:45.040 --> 41:46.520]  еще не был, вообще ни разу не видел.
[41:46.520 --> 41:51.320]  Значит, тогда вот У к моменту времени входа серая, то
[41:51.320 --> 41:57.560]  есть я сюда зашел, а В белая, ну значит, поскольку В достижимо
[41:57.560 --> 42:01.360]  по белому пути, вот, собственно, он один, да, просто по ребру
[42:01.360 --> 42:06.040]  в белую вершину, значит, до выхода из У я выйду из
[42:06.040 --> 42:09.520]  В, то есть я ее целиком обработаю, перекрашу в черный, значит,
[42:09.520 --> 42:13.040]  выйду отсюда раньше, чем отсюда, поэтому получаю
[42:13.040 --> 42:14.280]  требования неравенственно таута.
[42:14.280 --> 42:24.340]  Значит, по, опять-таки, лени о белых путях, к моменту
[42:24.340 --> 42:29.340]  времени Таут от У, В будет целиком обработана, значит,
[42:29.340 --> 42:31.540]  она будет, из нее вышли еще раньше, чем этот момент
[42:31.540 --> 42:39.660]  времени выхода из У, к моменту Таут от У, В уже целиком
[42:39.660 --> 42:47.540]  обработана, то есть выход из нее состоял еще раньше,
[42:47.540 --> 42:52.540]  к моменту Таут от У.
[42:52.540 --> 42:59.140]  Второй случай, наоборот, с другой стороны неравенственно,
[42:59.140 --> 43:00.140]  давайте здесь.
[43:00.140 --> 43:09.020]  Наоборот, сначала мы зашли в В, то есть сначала я попал
[43:09.020 --> 43:13.460]  сюда, покрасил В серый, а У еще белая, к моменту
[43:13.460 --> 43:25.660]  времени входа в В, У еще белая, У еще белая, ну окей, давайте
[43:25.660 --> 43:29.740]  предположим, что это неверно, сейчас или нет, не надо
[43:29.740 --> 43:39.220]  даже, ну да, давайте предположим, что это неверно, пусть не
[43:39.220 --> 43:41.460]  так, то есть не нравится верно в обратную сторону,
[43:41.460 --> 43:50.300]  наоборот, Таут от У меньше, чем Таут от В, что это значит?
[43:50.300 --> 43:55.340]  Это значит, что вершина У обработана целиком до
[43:55.340 --> 43:58.780]  того, как обработана вершина В целиком, то есть смотрите,
[43:58.780 --> 44:00.940]  как у нас тогда история событий была, мы сначала
[44:00.940 --> 44:05.180]  увидели В, покрасили ее в серый, потом что-то поделали,
[44:05.180 --> 44:08.260]  вышли из У, то есть мы ее целиком обработали, и только
[44:08.260 --> 44:11.500]  после этого вышли из В, значит, в частности, я с помощью
[44:11.500 --> 44:16.460]  стека рекурсии дошел из В до У, потому что чтобы
[44:16.460 --> 44:19.620]  обработать у меня опять-таки по леймам белых путях, обработаются
[44:19.620 --> 44:21.940]  к моменту времени выхода Таут от В, те и только те
[44:21.940 --> 44:24.620]  вершины, которые были достижены по белым путям, поэтому
[44:24.620 --> 44:28.700]  раз я успел закончить обработку У до обработки В, значит,
[44:28.700 --> 44:31.500]  я ее посетил по какому-то белому пути, обработал,
[44:31.500 --> 44:34.580]  вышел, и только после этого вышел из В, да, лейма белых
[44:34.580 --> 44:36.860]  путях, говоришь, что как раз, если это верно, то есть если
[44:36.860 --> 44:40.180]  я У успел обработать до выхода из В, значит, она была достижена
[44:40.180 --> 44:44.180]  по белому пути. Это противоречит тому, что у нас графа циклический,
[44:44.180 --> 44:46.980]  да, потому что если В достижимый, наоборот, У достижимый из
[44:46.980 --> 44:49.980]  В по белому пути, значит, есть цикл противоречия.
[44:49.980 --> 44:55.900]  Конец. Значит, давайте это запишем, пусть не так Таут
[44:55.900 --> 45:05.020]  от У меньше, чем Таут от В, тогда У обработается раньше
[45:05.020 --> 45:14.460]  чем У обработается В, значит, опять-таки по леймам белых
[45:14.460 --> 45:36.620]  путях, а У достижимый из В по белому пути, противоречие
[45:36.620 --> 45:48.660]  с ацикличностью. Ну все, показали. Значит, в любом случае
[45:48.660 --> 45:52.060]  верное неравенство, поэтому я сначала напечатаю У, потом
[45:52.060 --> 45:53.860]  напечатаю В, значит, у меня реально все ребра будут
[45:53.860 --> 46:02.380]  идти слева направо. Прекрасно. Значит, мы топ-сорт построили
[46:03.380 --> 46:11.060]  Зачем это может быть вообще нужно? Ну, на дагах очень
[46:11.060 --> 46:15.700]  просто считать всякие динамики. А, и вообще, если у Вас, ну,
[46:15.700 --> 46:21.660]  скажем так, граф зависимости в переходах динамики вообще
[46:21.660 --> 46:23.660]  должен быть всегда дагом, потому что мы когда там
[46:23.660 --> 46:25.820]  говорим, что какое-то значение ДП, динамики зависит от
[46:25.820 --> 46:28.700]  каких-то других, если нарисовать стрелку зависимости, то
[46:28.700 --> 46:30.620]  у меня, по сути, не должно быть циклов, потому что
[46:30.620 --> 46:31.860]  у меня всегда получается циклическая зависимость,
[46:31.860 --> 46:34.100]  и мы не можем определить значение. А так у нас в
[46:34.100 --> 46:37.540]  каком-то смысле вся динамика, это ее формула пересчета
[46:37.540 --> 46:39.860]  и так граф образует. То есть, что из чего пересчитывается?
[46:39.860 --> 46:42.500]  Вот если стрелку рисовать как зависимость, зависимость
[46:42.500 --> 46:46.260]  пересчета, то у меня получается как раз даг. Ну и, собственно,
[46:46.260 --> 46:48.540]  как раз мы представляем то, как у нас всякая динамика
[46:48.540 --> 46:53.580]  может насчитываться. Например, на даге нас могут попросить
[46:54.300 --> 47:01.300]  число путей, найти число путей в даге. Вот это очень легко
[47:07.860 --> 47:11.860]  делается. Да, ну давайте я нарисую общую картинку.
[47:11.860 --> 47:17.860]  Давайте ДП вот в, это количество путей, начинающихся в, тогда
[47:17.860 --> 47:21.020]  если я нахожусь где-то в и пытаюсь продолжить путь,
[47:21.020 --> 47:23.260]  то я могу либо сразу закончиться и получить путь из одной
[47:23.260 --> 47:26.580]  вершины, либо перейти в любого из сыновей и взять
[47:26.580 --> 47:33.580]  ДП. Если ДП от В это количество путей, начинающихся в, тогда
[47:44.020 --> 47:48.220]  ДП в это, это 1 плюс сумма по всем исходящим ребрам
[47:48.220 --> 47:54.860]  ДПУТ. То есть я либо сразу заканчиваюсь, либо куда-то
[47:54.860 --> 47:58.180]  перехожу, и тогда мне подойдет в качестве завершения любой
[47:58.180 --> 48:01.220]  путь начинающихся в У. И все они будут различны, потому
[48:01.220 --> 48:04.340]  что у них вторые вершины различны. Ну поэтому я все
[48:04.340 --> 48:08.980]  путей перебираю. Вот. И как раз-таки если я все ребра
[48:08.980 --> 48:11.940]  смогу порядочить слева-направо, то есть если у меня есть перестановка
[48:11.940 --> 48:16.580]  вершин, такая, что все ребра ведут ровно вот так вот,
[48:16.580 --> 48:19.980]  то я могу мою динамику насчитывать динамикой
[48:19.980 --> 48:24.780]  справа-налево. То есть я знаю, что здесь ДП равно единицы,
[48:24.780 --> 48:26.460]  здесь ДП получится равно двойки, потому что можно
[48:26.460 --> 48:29.140]  либо стоять здесь, либо прыгнуть сюда. Здесь ДП,
[48:29.140 --> 48:31.820]  ну короче в общем, у меня все более правые вершины,
[48:31.820 --> 48:34.300]  для всех более правых вершин ДП уже посчитано, поэтому
[48:34.300 --> 48:37.380]  я в сумме все слагаемые знаю. Надо просто сложить все,
[48:37.380 --> 48:40.780]  что нужно и получить ДП вот здесь. И так я иду справа-налево,
[48:40.780 --> 48:43.740]  все более правое уже почитано, поэтому я могу сложить нужные
[48:43.740 --> 48:48.500]  слагаемые и положить сюда то самое ДП. Вот как раз
[48:48.500 --> 48:50.940]  такой удобный способ упорядочения вершин, чтобы всякие
[48:50.940 --> 48:52.540]  такие штуки можно было справа-налево считать.
[48:52.540 --> 49:09.540]  Так. Хорошо. Хорошо. Что-то был случай графов без циклов.
[49:09.540 --> 49:12.260]  Теперь давайте отказываемся от этого предположения
[49:12.260 --> 49:14.580]  и будем изучать произвольный граф, возможно, с циклами.
[49:14.580 --> 49:24.820]  Определение. Значит, пусть G это граф ориентированный,
[49:24.820 --> 49:35.620]  пусть G ориентированный граф. Я буду говорить, что вершины
[49:35.620 --> 49:41.140]  У и В сильно связаны, если есть путь из У в В. Нет,
[49:41.140 --> 49:51.140]  есть путь в обе стороны. Будем говорить, что вершины
[49:51.140 --> 50:02.140]  У и В сильно связаны. Сегодня буду обозначать тильдочки
[50:02.140 --> 50:05.300]  как отношение к эквивалентности. Значит, они сильно связаны,
[50:05.300 --> 50:10.620]  если из У существует путь В и из В существует путь
[50:10.620 --> 50:24.620]  В. Из У есть путь В и из В есть путь В. Короче, в обе
[50:24.620 --> 50:32.180]  стороны есть путь в одну и в другую, и туда и обратно.
[50:32.180 --> 50:35.460]  Я вот это утверждение, что вот это вот отношение,
[50:35.460 --> 50:37.820]  которое я только что ввел, получается у меня отношение
[50:37.820 --> 50:41.740]  на парах вершин. Бинарное отношение, я утверждаю, что
[50:41.740 --> 50:46.980]  оно является отношением эквивалентности. Отношение
[50:46.980 --> 50:54.100]  тильда, отношение к эквивалентности. Так, у кого не было матлога?
[50:54.100 --> 50:57.780]  Или, точнее, так, кто не знает, что такое отношение к
[50:57.780 --> 51:04.780]  эквивалентности? Так, хорошо. Не всегда так, не всегда
[51:04.780 --> 51:08.500]  все знают. На всякий случай проговорю. Отношение к
[51:08.500 --> 51:10.380]  эквивалентности значит, что у меня все вершины разбиваются
[51:10.380 --> 51:15.700]  на некие классы, что внутри класса все вершины попарно
[51:15.700 --> 51:18.060]  эквивалентны друг другу. То есть, что внутри класса
[51:18.060 --> 51:20.940]  есть пути в обе стороны между вершинами, а между
[51:20.940 --> 51:23.980]  классами хотя бы одного из двух путей нету. То есть,
[51:23.980 --> 51:29.980]  что либо нету такого пути, либо нету другого пути.
[51:29.980 --> 51:35.100]  Доказательства. Отношение к эквивалентности по определению
[51:35.100 --> 51:42.260]  это совокупность трех условий. Рефлексивность. То есть,
[51:42.260 --> 51:45.460]  что каждая вершина сама себе эквивалентна. Ну,
[51:45.460 --> 51:47.660]  понятно, что каждая вершина сама себе сильно связана,
[51:47.660 --> 51:49.780]  потому что можно стоять на месте. Это путь из У в У
[51:49.780 --> 51:56.580]  и из У в У. Как бы это глупо не звучало. Дальше называется
[51:56.580 --> 52:02.220]  симметричность. Ну, симметричность тоже тривиально. Потому что
[52:02.220 --> 52:05.020]  если У и В сильно связаны, то В и У сильно связаны. Ну,
[52:05.020 --> 52:07.780]  потому что у меня это определение от перестановки условий остается
[52:07.780 --> 52:12.780]  тем же самым. Здесь тоже очевидно. Ну и третья транзитивность.
[52:13.380 --> 52:20.580]  Почему, если У и В сильно связаны, В и В сильно связаны, то У и,
[52:20.580 --> 52:23.580]  вstudy-выс сильно связаны. Ну, понятно,
[52:23.580 --> 52:27.700]  у меня есть вот такие два пути, есть такие два пути,
[52:27.700 --> 52:30.880]  если их скр Down, то получится путь отсюда сюда и отсюда.
[52:30.880 --> 52:34.820]  Я могу сначала пройти от У до В до В В. Это будет путь
[52:34.820 --> 52:38.420]  в одну сторону, и могу пройти от В до В до USB это будет путь в другую
[52:38.420 --> 52:41.820]  сторону. Поэтому, У и В сильно связаны. А это как раз
[52:41.820 --> 52:47.380]  интранзитивности, то есть, что если u сильно связана с v, v сильно связана с w,
[52:47.380 --> 52:53.220]  то u сильно связана с w. Доказательство картинка.
[52:56.900 --> 53:04.380]  Нет, нет. Но на самом деле, если есть какой-то путь, то есть обязательно простой путь.
[53:04.380 --> 53:09.580]  Тут возможно есть повторения, но их всегда можно высечь, потому что
[53:10.220 --> 53:14.860]  достижимость не меняется от того, что вы можете повторять вершины, вы можете вот эту циклическую
[53:14.860 --> 53:20.260]  петлю обрубить, и тогда у вас путь укоротится, но это не влияет ни на что. То есть тут я, на самом
[53:20.260 --> 53:27.100]  деле, мог в определении зашить простоту пути, но это не влияет на определение. Все остается таким же
[53:27.100 --> 53:37.580]  самым. Так. Это хороший вопрос про простоту, но это будет чуть более актуально, когда мы будем
[53:37.580 --> 53:42.060]  говорить про мосты и точку слинения, когда мы будем говорить про двусвязанность в неориентированном
[53:42.060 --> 53:47.660]  графе, вот там уже за простотой придется следить чуть более пристально, потому что там это по
[53:47.660 --> 54:03.100]  интереснее условие. А тут не надо еще. Так. Ну и вот еще, значит, определение. Надеюсь, мы
[54:03.660 --> 54:09.820]  классы эквивалентности после факторизации по этому отношению называются компонентами
[54:09.820 --> 54:15.140]  сильно связанности. То есть вот я сказал, что это отношение эквивалентности, значит, все вершины
[54:15.140 --> 54:20.340]  разбиваются на такие группы, на такие классы, внутри которых все вершины попарно сильно связаны,
[54:20.340 --> 54:25.180]  а между классами не сильно связаны попарно, и так вот эти вот группы называются компонентами
[54:25.180 --> 54:41.860]  сильно связанности. Значит, ну формально классы эквивалентности по отношению тильда это называются
[54:41.860 --> 54:59.260]  компонентами сильно связанности. Вот я буду опять-таки для краткости говорить КСС,
[54:59.260 --> 55:09.780]  компоненты сильно связанности, КСС. Вот. Следующая наша задача это по графу найти его разбиение на
[55:09.780 --> 55:17.100]  КСС, найти его разбиение на компонент сильно связанности. Ну и выделить все КСС. Алгоритм,
[55:17.100 --> 55:33.940]  который ее решает, это так называемый алгоритм Косараю. Выделение КСС. Значит, алгоритм очень
[55:33.940 --> 55:45.540]  простой. Шаг первый идентичен тому, что мы делаем в топ-сорте. Мы проходим по всем вершинам в порядке
[55:45.540 --> 55:52.540]  от 0 до минус одного и запускаем внешний ДФС обычный из всех белых вершин, а дальше сортируем
[55:52.540 --> 56:08.580]  вершины порядка бывания таута. Давайте напишу так же как в топ-сорте, как в топ-сорте ДФС плюс
[56:08.580 --> 56:24.660]  сортировка побывания таут. Вот. Шаг второй. У меня теперь есть некоторый порядок вершин. В случае
[56:24.660 --> 56:30.620]  ациклического графа это топ-сорт. В случае не ациклического графа, ну просто какой-то порядок.
[56:30.620 --> 56:34.940]  Мы пока про такой порядок ничего не доказывали. Это какая-то присуновка вершин. Так вот давайте
[56:35.020 --> 56:41.740]  в этом порядке пройдемся по вершинам. В порядке, который диктуется нам вот этой сортировкой и будем
[56:41.740 --> 56:47.340]  запускать из вершины ДФС по обратным ребрам. То есть не по ребру вниз, которая там у него было прямое
[56:47.340 --> 56:59.180]  ребро, а по обратному ребру. Сейчас формализую. Но неформально. Значит, запускаем ДФС. Напишу так
[56:59.180 --> 57:21.420]  ДФСР в скобочках ДФС по обратным ребрам для вершин в этом порядке. И все, что я обошел в результате
[57:21.420 --> 57:27.100]  одного внешнего запуска ДФСР, то есть ДФСР по обратным ребрам, это будет очередная КСС.
[57:27.100 --> 57:43.460]  Все, что обошли в результате одного запуска, это очередная компонента сильной связанности.
[57:43.460 --> 57:57.300]  Значит, формально, что такое ДФСР. Смотрите, обычный граф, он как-то задан у нас. У нас есть там
[57:57.300 --> 58:04.860]  какие-то ребра УВ, Х, Ю и так далее. Обратный граф, Ж с верхним униксом Р, это когда я меняю
[58:04.860 --> 58:12.740]  ориентацию всех ребр. То есть ребро УВ превращается в ребро ВУ, ребро ХИ превращается в ребро УВХ. Ну и
[58:12.740 --> 58:20.380]  так далее. Я просто беру и меняю стрелочку у всех ребр. Соответственно, если у меня был ЖВ представлен
[58:20.380 --> 58:25.380]  как вектор векторов, для каждой вершины у меня был записан, куда можно из нее попасть. То есть для
[58:25.380 --> 58:31.540]  УВ было записано В, для Х, Ю и так далее. То теперь я могу построить такой же вектор векторов,
[58:31.540 --> 58:36.260]  только для обратного графа, где для каждой вершины храни, наоборот, как бы откуда в нее можно было
[58:36.260 --> 58:41.620]  бы попасть. То есть В можно было попасть из У. И значит, теперь я как бы ее инвертирую, говорю, что
[58:41.620 --> 58:47.100]  можно из В попасть в У. Меняю направление стрелки, ну и по сути как бы переставляю начало и конец у всех
[58:47.100 --> 58:51.780]  ребр. Поэтому такое проявление очень простое. Надо просто поменять стрелочку, надо просто поменять,
[58:51.780 --> 58:58.660]  где начало, где конец. Вот. И я запускаю вот этот самый ДФС в новом графе Ж с верхним униксом Р,
[58:58.660 --> 59:04.900]  обратный Ж. И все, что я смог достичь за очередной вершинки по этим ребрам, это вот очередная КСС.
[59:04.900 --> 59:14.660]  Примерно так это будет выглядеть. Смотрите, вот у меня был граф Ж. Как это будет работать, да? Вот,
[59:14.660 --> 59:23.340]  ну, например, его, если я сожму КСС, картинка будет примерно вот такая. Что-нибудь такое я нарисую. То
[59:23.340 --> 59:27.860]  есть у меня кружочки это КСС, то есть там все по парам достижены как-нибудь вот так вот,
[59:27.860 --> 59:35.100]  во все стороны. Здесь тоже КСС какой-нибудь, здесь КСС. Вот. А эти в КСС клеить нельзя,
[59:35.100 --> 59:39.500]  значит здесь вообще между ними, например, нет ребер. Есть ребра отсюда-сюда, есть ребра отсюда-сюда,
[59:39.500 --> 59:47.060]  но нет ребер обратно. Вот, например, такая картинка. Тогда как работает ДФС по обратным ребрам? Вот,
[59:47.060 --> 59:51.940]  если я его запущу от какой-нибудь вершины внутри этой компоненты, я обойду целиком только эту
[59:51.940 --> 59:57.180]  компоненту. Ну, потому что у меня ДФС только по обратным ребрам идет, он это ребро не просмотрит,
[59:57.180 --> 01:00:02.340]  но поскольку здесь все вершины достижены по парам в обе стороны, то я по обратным ребрам обойду
[01:00:02.340 --> 01:00:08.260]  целиком всю эту компоненту. Я запускаюсь отсюда, все достижено из нее и наоборот из нее, ну, она из
[01:00:08.260 --> 01:00:13.060]  всех достижено, поэтому по обратным ребрам я целиком эту всю компоненту обойду. Тоже самое,
[01:00:13.060 --> 01:00:17.820]  здесь, если запускаюсь ДФС по обратным ребрам отсюда, я обойду целиком только эту компоненту,
[01:00:17.820 --> 01:00:22.260]  а сюда не перейду, и последний шаг, у меня будет как раз обход вот этой вот у этой вот штуки.
[01:00:22.260 --> 01:00:27.340]  там в частности будут просмотрены эти ребра, но поскольку их концы уже
[01:00:27.340 --> 01:00:31.940]  просмотрены, и им уже назначены компоненты сильно связанности, то я в них не
[01:00:31.940 --> 01:00:34.960]  поднимаюсь, я только обхожу эту компоненту и говорю, что это очередная
[01:00:34.960 --> 01:00:43.740]  ксс. Понятно? То есть еще раз, мы сейчас все докажем, что это
[01:00:43.740 --> 01:00:48.180]  корректно работает, идея такая, что каждый вот этот вот dfsr, если я его
[01:00:48.180 --> 01:00:54.860]  запускаю в очередной вершинке, он обойдет только свою ксс, только то, что
[01:00:54.860 --> 01:00:58.420]  надо. Весь класс эквивалентности и больше ничего. То есть какая проблема
[01:00:58.420 --> 01:01:04.940]  могла бы быть, если бы вдруг у меня был вот такой граф, и я запускаюсь первым
[01:01:04.940 --> 01:01:09.540]  делом вот отсюда, dfsr по обратным ребраммам, из этой вершинки. Я, скажем, взял, обошел всю эту
[01:01:09.540 --> 01:01:14.020]  ксс, правильно сделал, но еще внезапно взял, обнаружил это ребро и поднялся сюда,
[01:01:14.020 --> 01:01:17.740]  и сказал, что эти все лежат там же, где и вот это. То есть я их все положил скорее в
[01:01:17.740 --> 01:01:22.460]  одну ксс. Вот нам надо будет отследить, что я такого не делаю, что если я
[01:01:22.460 --> 01:01:25.700]  запускаюсь в вершинке какой-то компоненты, то все вот эти вот уже
[01:01:25.700 --> 01:01:29.980]  обработаны. Я не склею две разные ксски.
[01:01:33.900 --> 01:01:36.900]  Так.
[01:01:47.740 --> 01:02:17.140]  Так, ну значит опять, вот я определил какой-то алгоритм. Время работы, наверное, понятно,
[01:02:17.180 --> 01:02:20.940]  что оно линейное, потому что первое это то же самое, что в топ-сорте. Это понятно, что от n
[01:02:20.940 --> 01:02:26.420]  плюс m, потому что по факту это просто dfs какой-то. Второй шаг, то это то же
[01:02:26.420 --> 01:02:30.260]  самое, только dfs по обратному графу. Опять, никакого ребра, никакой вершины я не
[01:02:30.260 --> 01:02:34.220]  обойду больше, чем один раз, поэтому этот шаг тоже работает за линию, и со
[01:02:34.220 --> 01:02:40.380]  симптомикой здесь все шикарно. Быстрее, чем линия работать нельзя. Вот, значит,
[01:02:40.380 --> 01:02:45.900]  доказательство корректности опять. Доказательство корректности.
[01:02:47.140 --> 01:02:53.740]  Значит, первое замечание такое, что каждый внешний запуск dfs по обратным
[01:02:53.740 --> 01:03:09.140]  ребрам обходит одну или несколько ксс целиком. Каждый внешний запуск dfs по
[01:03:09.140 --> 01:03:26.900]  обратным ребрам обходит одну или несколько ксс целиком, ну, потому что если
[01:03:26.900 --> 01:03:33.180]  вершина, это первая белая, взятая вершина из компонентов сильно связанности, то
[01:03:33.180 --> 01:03:37.820]  есть все остальные тоже белые внутри нее, и я запускаю dfs по обратным ребрам, так
[01:03:37.820 --> 01:03:41.300]  момент времени выхода, то есть к моменту завершения этого dfs, я точно обойду
[01:03:41.300 --> 01:03:44.860]  всю эту ксс, ну, потому что они были белые изначально, они были достижены
[01:03:44.860 --> 01:03:48.300]  по обратным ребрам, потому что это ксс, в ксс достижены все, и в одну сторону, и
[01:03:48.300 --> 01:03:51.700]  в другую, и по прямым, и по обратным. Значит, к моменту времени выхода из этой
[01:03:51.700 --> 01:03:56.580]  компоненты я точно ее все обойду. Ну, и то самое вот с всеми остальными. Возможно,
[01:03:56.580 --> 01:03:59.980]  я мог как-то вот так вот прыгнуть, нехорошо взять, кроме этой компоненты,
[01:03:59.980 --> 01:04:03.820]  обойти что-нибудь еще. Ну, тогда если я обошел, то я тоже целиком обошел, потому что
[01:04:03.820 --> 01:04:09.020]  если я внезапно наступил сюда, то здесь опять-таки все белые, ну, то есть по
[01:04:09.020 --> 01:04:12.420]  предложении индукции, да, я, если раньше только несколько компонентов откусил, то
[01:04:12.420 --> 01:04:15.700]  эта компонента целиком белая, я сюда пришел, здесь все белое, поэтому к моменту
[01:04:15.700 --> 01:04:19.940]  времени выхода опять по леймам о белых путях, о белых путях я все обойду. Поэтому я
[01:04:19.940 --> 01:04:23.980]  обхожу точно свою компоненту сильно связанности и, возможно, несколько еще
[01:04:23.980 --> 01:04:28.740]  целых компонентов связанности, сильно связанности. Вот надо доказать, что кроме
[01:04:28.740 --> 01:04:31.740]  себя мы ничего не обойдем.
[01:04:33.820 --> 01:04:36.820]  Что не обойдем лишних КСС.
[01:04:39.820 --> 01:04:42.820]  Значит, ну, кто такие лишние?
[01:04:43.820 --> 01:04:47.820]  Лишние могут быть только те, которые вот как раз достижимы по вот такому
[01:04:47.820 --> 01:04:54.820]  обратному ребру. То есть плохая ситуация только такая, когда я взял и запустился
[01:04:54.820 --> 01:05:01.820]  ДФС от какой-то вершины В, обошел всю эту КСС и нашел ребро ведущее в эту КСС
[01:05:01.820 --> 01:05:07.820]  из другой КСС, при этом она еще не, как бы она еще целиком не обедена, она целиком
[01:05:07.820 --> 01:05:14.820]  белая еще, ну, как бы, давайте напишу, не обедена. Вот это плохая ситуация,
[01:05:14.820 --> 01:05:18.820]  потому что тогда я обойду сразу две и скажу, что не обедена.
[01:05:19.820 --> 01:05:24.820]  Вот это плохая ситуация, потому что тогда я обойду сразу две и скажу, что не одно
[01:05:24.820 --> 01:05:30.820]  и то же, а мне так делать нельзя. Вот, ну, смотрите, если это происходит, то у меня
[01:05:30.820 --> 01:05:36.820]  что получается? Поскольку у меня эта вершина, точнее, из этой вершины я запустил внешний
[01:05:36.820 --> 01:05:41.820]  ДФС раньше, чем мог бы запустить отсюда, то это значит, что у этой вершины ТАУТ
[01:05:41.820 --> 01:05:46.820]  больше, чем вот здесь, у всех этих вершин. Да, потому что иначе, если бы у этой
[01:05:46.820 --> 01:05:50.820]  вершины ТАУТ был бы меньше, чем, скажем, вот этой, то поскольку я запускаю ДФС
[01:05:50.820 --> 01:05:56.820]  Р в порядке убывания ТАУТа, то я тогда бы сначала запустил ДФС Р отсюда, обошел бы
[01:05:56.820 --> 01:06:00.820]  всю эту КСС и только после этого обошел бы вот эту КСС. Поэтому такая проблема
[01:06:00.820 --> 01:06:07.820]  может быть только в случае, когда ТАУТ от В больше, чем ТАУТ от всех вершин этой
[01:06:07.820 --> 01:06:17.820]  компоненты. Ну, давайте С1 я напишу, ТАУТ С1. Ну, вот доказываю, что такого не
[01:06:17.820 --> 01:06:27.820]  бывает. Ну, давайте напишем утверждение. Пусть С1, С2, две компоненты сильно
[01:06:27.820 --> 01:06:36.820]  связанности, причем есть, по крайней мере, одно ребро из С1 в С2. Есть. Ну, их на
[01:06:36.820 --> 01:06:40.820]  самом деле может быть несколько, вполне возможно такое. У нас же это не точки, а
[01:06:40.820 --> 01:06:43.820]  именно, что много точек. У нас может быть много ребер. Так вот, причем, есть хотя бы
[01:06:43.820 --> 01:06:58.820]  одно ребро из С1 в С2. Тогда вот, утверждаю я, максимальное значение ТАУТа
[01:06:58.820 --> 01:07:09.820]  по всем УСС1 больше, чем максимальное значение ТАУТа по всем УСС2. Если мы это
[01:07:09.820 --> 01:07:13.820]  докажем, то автоматически покажем, что такого не бывает.
[01:07:28.820 --> 01:07:44.820]  Так, доказательства. Опять давайте рассмотрим два случая. А именно, давайте посмотрим
[01:07:44.820 --> 01:07:47.820]  на минимальный ТОИН. То есть опять, у нас на самом деле все рассуждения, вот эти
[01:07:47.820 --> 01:07:52.820]  доказываются так. Рассмотрим на ту вершину, куда попали первые. То есть, из всех вот
[01:07:52.820 --> 01:07:59.820]  этих вершин С1, С2 мы рассмотрим вершину с минимальным ТОИН. Где она была? Здесь
[01:07:59.820 --> 01:08:06.820]  или здесь? Рассмотрим два случая. Первый случай. Минимальное значение ТОИНа по
[01:08:06.820 --> 01:08:19.820]  Х, по всем ХСС1 меньше, чем минимальное значение ТОИНа по всем УСС2. То есть,
[01:08:19.820 --> 01:08:24.820]  напоминаю, вот эти ТОИН, ТАУТы, это то, что у меня после первого шага получилось. То есть,
[01:08:24.820 --> 01:08:29.820]  я запускал обычный ДФС по прямым ребрам, обычный, без вот этого обращения пока что,
[01:08:29.820 --> 01:08:36.820]  обычный ДФС по прямым ребрам. И там просадил все ТОИН, ТАУТы. Так вот, в этом плане ТОИН,
[01:08:36.820 --> 01:08:42.820]  ТАУТ, ТОИНы соотносятся так. То есть, я сначала пришел сюда, потом сюда. Ну, вроде понятно,
[01:08:42.820 --> 01:08:50.820]  что если это верно, значит, давайте рассмотрим, пусть вот эта вот штука равна ТОИН от Х. То есть,
[01:08:50.820 --> 01:08:56.820]  вот здесь вот самая первая посещаемая вершина, это Х. То есть, к моменту времени входа в Х, это все
[01:08:56.820 --> 01:09:02.820]  еще белое. Вот эти все вершинки белые и эти все белые. Ну, тогда понятно, что к моменту времени выхода
[01:09:02.820 --> 01:09:07.820]  из Х все это покрасится в черный. И значит, это все тоже покрасится в черный. Значит, ТАУТ от Х
[01:09:07.820 --> 01:09:15.820]  больше, чем ТАУТ от всех отсюда. Если Х это первая просмотренная вершина, тогда опять-таки
[01:09:15.820 --> 01:09:34.820]  полемим в белых путях. К моменту времени ТАУТ от Х и С1 и С2 будут целиком просмотрены, значит,
[01:09:34.820 --> 01:09:50.820]  у них ТАУТ меньше, чем ТАУТ от Х. Так, С2 будет целиком обработано. Значит, все вот эти вот ТАУТы,
[01:09:50.820 --> 01:10:02.820]  максимальное значение ТАУТ от В, то В из С2 меньше, чем ТАУТ от Х. Победа. То есть, что все ТАУТы
[01:10:02.820 --> 01:10:07.820]  отсюда произошли раньше, чем ТАУТ от Х. Значит, максимальный ТАУТ отсюда меньше, чем максимальный
[01:10:07.820 --> 01:10:18.820]  ТАУТ отсюда. Это то, что мы хотели. Кейс номер два. Они нас в другую сторону. Минимум, например,
[01:10:18.820 --> 01:10:40.820]  достигается вот здесь. Давайте напишем. Пусть вот это равно 3 над Y. То есть, из всех этих
[01:10:40.820 --> 01:10:49.820]  вершин обеих компонентов я сначала увидел какую-то вершину второй компоненты. Почему-то впервые
[01:10:49.820 --> 01:10:55.820]  первая просмотренная вершина была вот эта. Первая, точнее, увиденная вершина была вот эта Y. Это могло произойти
[01:10:55.820 --> 01:10:59.820]  по тысячи разных причин. Например, потому что эта вершина имеет наименьший номер, и из нее запустился
[01:10:59.820 --> 01:11:04.820]  внешний DFS впервые. Либо, может быть, мы как-нибудь дошли до этой компоненты из какой-то другой
[01:11:04.820 --> 01:11:09.820]  компоненты. То есть, сначала вот это там обошли, потом пришли сюда. И тогда это увидено раньше, чем все
[01:11:09.820 --> 01:11:19.820]  остальные. То есть, это вполне спокойно может быть. Так вот. Но нам это не важно. Значит, пусть это верно.
[01:11:19.820 --> 01:11:39.820]  Сейчас, на секунду. А, ну да. В общем, я утверждаю, что к моменту времени, то есть, как обычно,
[01:11:39.820 --> 01:11:45.820]  к моменту времени T out от Y, я обойду только то, что достижено по белым. А это точно не C1.
[01:11:45.820 --> 01:11:51.820]  Потому что если бы из Y было достижено C1 по белым вершинам, то у меня бы они все склеились в одну большую
[01:11:51.820 --> 01:11:57.820]  КСС, потому что есть путь отсюда-сюда. Значит, такого не может быть. Значит, к моменту времени выхода из Y,
[01:11:57.820 --> 01:12:04.820]  это будет черным, а это останется белым. Значит, T out и отсюда подавно больше, чем все T out отсюда.
[01:12:04.820 --> 01:12:24.820]  Ну, давайте заметим, что не может быть белого пути из Y в C2, так как иначе у меня был бы путь в обе стороны
[01:12:24.820 --> 01:12:31.820]  между C1 и C2. Иначе есть путь в обе стороны, а значит, есть сильно связанные перерывы.
[01:12:31.820 --> 01:12:39.820]  Иначе между C1 и C2 есть путь в обе стороны, противоречие. Мы считаем, что это разные компоненты,
[01:12:39.820 --> 01:12:52.820]  и есть путь только из C1 и C2. Значит, опять-таки, по нашей любимой технично-леме, к моменту времени выхода
[01:12:52.820 --> 01:12:58.820]  из Y мы обойдем только то, что было достижено по белым путям из Y, а значит, C1 вообще не обойдем,
[01:12:58.820 --> 01:13:08.820]  даже не увидим. По-леме, к моменту T out от Y мы даже не увидим C1.
[01:13:08.820 --> 01:13:21.820]  Значит, у них T out еще больше. Мы их не видели, обошли целиком C2, потому что к моменту времени выхода отсюда
[01:13:21.820 --> 01:13:27.820]  мы обойдем целиком C2, опять-таки по-леме. То есть, все отсюда вышли, а сюда еще даже не вошли.
[01:13:27.820 --> 01:13:32.820]  То есть, у них еще больше T in и еще больше T out. Доказали.
[01:13:33.820 --> 01:13:40.820]  Значит, здесь даже получается неравенство такое, что любой T out отсюда больше любого T out отсюда.
[01:13:40.820 --> 01:13:52.820]  Могу даже вот так написать. Для любого VSC2, для любого USC1, T out от V меньше T out от U.
[01:13:52.820 --> 01:13:57.820]  Значит, частности доказали то, что нужно.
[01:14:02.820 --> 01:14:06.820]  Ну и все получается, что наш алгоритм действительно вот такой дичь никогда не делает.
[01:14:06.820 --> 01:14:14.820]  То есть, он никогда не пытается перейти в другую CSS из текущей. Он всегда именно в том порядке сверху вниз их обрабатывает.
[01:14:14.820 --> 01:14:24.820]  Если бы как-то так можно было представить наш граф, например, если я к CSS представлю такими кружочками
[01:14:24.820 --> 01:14:31.820]  и проведу ребра между CSS, если они там есть, вот такой граф, например, то мой алгоритм примерно вот так работает.
[01:14:31.820 --> 01:14:36.820]  Он сначала вот это откусит как CSS, вот это откусит, потом вот это откусит, потом вот это, потом вот это.
[01:14:36.820 --> 01:14:40.820]  То есть, он не будет идти снизу вверх, скорее наоборот сверху вниз будет идти.
[01:14:40.820 --> 01:14:48.700]  Вот, вопрос есть?
[01:14:48.700 --> 01:14:52.100]  Так, хорошо.
[01:15:10.820 --> 01:15:17.740]  Замечание давайте здесь еще сделаем.
[01:15:17.740 --> 01:15:21.940]  Нам понадобится либо сегодня, либо через раз.
[01:15:21.940 --> 01:15:28.100]  Давайте мы для каждой компоненты, точнее для каждой высшины запомним номер.
[01:15:28.100 --> 01:15:30.380]  Номер компонента сильной связи, где она лежит.
[01:15:30.380 --> 01:15:38.260]  Пусть, так у меня кончились буквы, ну пусть будет ID.
[01:15:38.260 --> 01:15:49.300]  ID от V это номер ксс вершины V в алгоритме Косараю.
[01:15:49.300 --> 01:15:56.100]  Ну то есть давайте мы в коде сделаем еще следующее.
[01:15:56.100 --> 01:16:00.900]  Каждый раз, когда мы находим очередную ксс, для всех ее вершин проставляем ID-шник.
[01:16:00.900 --> 01:16:03.820]  То есть говорим, что они все лежат там ID от V равно номеру компоненты.
[01:16:03.820 --> 01:16:05.940]  Проставили им всем одинаковый ID-шник.
[01:16:06.180 --> 01:16:11.020]  А потом увеличили текущий номер компонента, чтобы все следующие вершины лежали в других компонентах сильной связности.
[01:16:11.020 --> 01:16:13.540]  То есть вот это у меня обратный DFS, DFSR.
[01:16:13.540 --> 01:16:16.820]  Все, что посещает, помечает как бы в текущей компоненте.
[01:16:16.820 --> 01:16:21.540]  А потом увеличивают номер компонента на один, чтобы все остальные лежали уже в следующей, после следующей и так далее.
[01:16:21.540 --> 01:16:27.860]  То есть на этой картинке у меня скажем, вот это будет 0-й ID-шник, 1-й, 2-й, 3-й, 4-й.
[01:16:27.860 --> 01:16:31.700]  То есть все вершины отсюда имеют 0-й ID, все отсюда 1-й и так далее.
[01:16:31.700 --> 01:16:49.300]  Так вот, тогда я утверждаю, что если AB это ребрографа, то ID от A меньше равного ID от B.
[01:16:49.300 --> 01:17:14.580]  Почему? Действительно, если они лежат в одной KSS, то есть если они сильно связаны, то, понятно, у них должно быть одинаковый ID.
[01:17:14.580 --> 01:17:18.180]  И поскольку мы доказали корректность алгоритма Косара, у них будут просто одинаковые ID-шники.
[01:17:19.060 --> 01:17:21.460]  То ID-А равно ID-B.
[01:17:24.740 --> 01:17:32.660]  Значит, иначе мы что знаем? Мы знаем, что они в разных KSS, но при этом есть ребро из A в B.
[01:17:32.660 --> 01:17:34.100]  Поэтому картинка вот такая.
[01:17:37.300 --> 01:17:42.100]  Есть ребро из A в B, при этом A в KSS №C1, а B в KSS №C2.
[01:17:42.980 --> 01:17:49.700]  Ну и тогда мы знаем, что Косарайо сначала посмотрит на эту KSS и ее целиком обойдет.
[01:17:49.700 --> 01:17:51.700]  Скажет, что у нее какой-то конкретный ID-шник.
[01:17:51.700 --> 01:17:57.620]  И только после этого, когда-то в будущем, он обойдет эту KSS и всем вершинам этой KSS назначит свой новый ID-шник.
[01:17:57.620 --> 01:18:06.660]  Потому что иначе, если бы мы сначала обошли вот это, то есть если бы мы начали с этого, то мы бы тогда обошли целиком ID-C1 и ID-C2 и сказали бы, что они лежат в одной KSS.
[01:18:06.660 --> 01:18:08.980]  А мы так не делаем, потому что мы доказали корректность.
[01:18:09.060 --> 01:18:14.100]  А мы доказали корректность, значит мы не можем начать отсюда.
[01:18:14.100 --> 01:18:17.300]  Мы не можем сказать, что эта компонента идет раньше, чем вот эта.
[01:18:17.300 --> 01:18:22.580]  Реально, C1 была найдена раньше, поэтому у него просто меньше ID-шник.
[01:18:22.580 --> 01:18:27.620]  KSS №C1 обходится раньше,
[01:18:31.620 --> 01:18:34.580]  следовательно, у нее меньше ID.
[01:18:34.580 --> 01:18:41.140]  Значит ID A строго меньше, чем ID B.
[01:18:41.140 --> 01:18:45.460]  Вот такой интересный факт.
[01:18:45.460 --> 01:18:54.020]  Вот это нам понадобится, когда мы двасад будем решать, но давайте я уже за две минуты не успею, давайте закончим сейчас.
[01:18:54.020 --> 01:18:57.300]  И в следующий раз мы вот это утверждение еще раз запишем и будем использовать.
[01:18:57.300 --> 01:18:58.820]  Все, спасибо всем.
