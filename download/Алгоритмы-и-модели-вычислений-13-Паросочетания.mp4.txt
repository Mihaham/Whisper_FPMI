[00:00.000 --> 00:22.760]  Я сегодня хотел рассказать про алгоритм поиска парсочетаний,
[00:22.760 --> 00:25.920]  на всякий случай спрошу, не было ли это у вас уже
[00:25.920 --> 00:32.480]  где-нибудь там те ремы холла такого не было да в принципе бываешь даже в мошколах изучают
[00:32.480 --> 00:57.440]  лк тг а нет я понимаю для меня просто лк тг означает летняя конференция турнира городов
[00:57.440 --> 01:12.240]  и там прям с доказательством было понятно да хорошо ладно мне но собственно я хочу по
[01:12.240 --> 01:17.360]  двум причинам поговорить про эту тему да и вообще этот уже традиционно включается
[01:17.360 --> 01:24.760]  во-первых это интересно интересно само по себе да это относится там центральным алгоритмом
[01:24.760 --> 01:32.160]  вот ну и соответственно посмотреть я это я на эту тему хочу не из точки зрения собственно
[01:32.160 --> 01:38.080]  математики доказательства с точки зрения алгоритм в которые возникают вот ну а вторая
[01:38.080 --> 01:47.120]  причина историческая даже на самом деле именно в статье которая это описывала даже нигде
[01:47.120 --> 01:55.760]  те ремы холла а где те те те рема об алгоритме стягивания цветков значит и ремы этманса вот
[01:55.760 --> 02:02.880]  в той статье впервые было написано что полиновия значит быстрая да то есть там статья была примерно
[02:02.880 --> 02:10.560]  так устроена что этман сначала доказывает что его его алгоритм работает потом оценивает время
[02:10.560 --> 02:16.480]  работы этого алгоритма и потом говорит что вот видите получился поляном вот ну и вообще надо
[02:16.480 --> 02:25.640]  сказать что вот поляном это эффективно вот это был еще 1965 год еще до постановки про пнп вот
[02:25.640 --> 02:37.440]  этом это важно в историческом плане так но хорошо значит вот значит у нас алгоритма
[02:37.440 --> 02:55.200]  алгоритма поиска паросочетаний значит так вообще паросочетания но по определению в
[02:55.200 --> 03:06.480]  графе паросочетания это набор ребер которые не пересекаются по вершинам что вообще
[03:06.480 --> 03:35.160]  паросочетания это набор ребер не имеющих общих концов вот значит сначала
[03:35.160 --> 03:40.160]  разберем лучи двудольного графа
[03:40.160 --> 03:58.000]  значит поэтому там теория мы холла еще час называть там теория о марьежах да потому что
[03:58.000 --> 04:07.560]  предполагает что вот есть там юноши и девушки и у них есть какие-то предпочтения ну это значит
[04:07.560 --> 04:13.600]  есть теория мхоп предпочтения где там устойчивый паросочетания а есть принципе приемлемые
[04:13.600 --> 04:23.800]  паросочетания да что у каждой стороны есть список партнеров с которыми они готовы быть в паре вот и
[04:23.800 --> 04:32.560]  это все выглядит как не предудольный граф какое-то количество вершин с одной стороны
[04:32.560 --> 04:39.280]  есть какое-то количество вершин с другой стороны какие-то ребра даже вот как-то идут
[04:39.280 --> 04:58.240]  так значит я тут нарисовал а значит я тут нарисовал что у меня в левой части на один
[04:58.240 --> 05:04.200]  элемент меньше чем в правой части вот поэтому совершенного паросочетания здесь не получится
[05:04.200 --> 05:11.160]  дальше совершенно называется паросочетания в котором каждый вершина участвует значит
[05:11.160 --> 05:31.680]  совершенное паросочетания вот это значит такое такое в котором участвуют все вершины
[05:31.680 --> 05:45.360]  значит дальше есть максимальные паросочетания и наибольший паросочетания и это немножко разные
[05:45.360 --> 05:52.120]  вещи дальше как вообще когда говорят о частичном порядке то максимальные означает элемент меньше
[05:52.120 --> 05:59.760]  элемент больше которого нету она и больше означает но тут больше всех вот но здесь имеется в виду что
[06:00.160 --> 06:14.560]  максимальная максимальные паросочетания означает не увеличиваемые не увеличиваемые
[06:14.560 --> 06:22.160]  вот ну а наибольшие паросочетания это содержащие наибольшее число ребр
[06:22.160 --> 06:32.320]  наибольшее паросочетания это содержащие
[06:32.320 --> 06:48.800]  наибольшее число ребр вот и это не одно и то же да значит вот простейший пример
[06:48.800 --> 07:00.120]  значит простейший пример когда у вас ну например вот так вот соответственно если мы возьмем
[07:00.120 --> 07:09.840]  значит если мы возьмем вот это вот ребро то одно это ребро будет не увеличиваемый паросочетания
[07:10.320 --> 07:18.840]  потому что тут больше никого нельзя добавить вот соответственно максимальная конечно будет
[07:18.840 --> 07:26.400]  на то есть вот это вот будет это будет максимальная а наибольшее наоборот другие два будут вот эти
[07:26.400 --> 07:39.760]  вот будут наибольшее но наибольшее потому что больше никак не может быть так так что это
[07:39.760 --> 07:46.280]  разные вещи но и максимально искать очень просто да максимально ищется простейшим жадным алгоритмом
[07:46.280 --> 07:51.960]  просто берете ребра пока еще можно взять да если нельзя взять значит оно есть максимальное по
[07:52.360 --> 07:59.720]  определению вот поэтому значит с максимальным никакой проблемы нету вот ну соответственно
[07:59.720 --> 08:07.880]  а значит основная задача наибольшее по рассчитания да потому что к ней совершенно легку сводится
[08:07.880 --> 08:13.260]  значит если вы ищите наибольшая если в нем столько ребер сколько вершин в каждой доле то оно и будет
[08:13.260 --> 08:20.080]  будет и совершенное вот если наибольшее если наибольшей не все вершины входят значит совершенно
[08:20.080 --> 08:36.160]  нету значит существует совершенное существует совершенное тогда и только тогда когда значит
[08:36.160 --> 08:43.560]  в наибольшее ходят и вершины
[08:51.280 --> 08:58.400]  поэтому основная задача это задача наибольшим по рассочетания вот значит в прочем про именно
[08:58.400 --> 09:05.320]  про совершенной есть вот эта известная теорема холла так давайте я ее сформулирую ну и докажем
[09:05.320 --> 09:21.640]  так значит теорема холла 4 холла о совершенных по рассочетаниях да или там о марьежах ее называют
[09:21.640 --> 09:31.120]  значит смотрите существует совершенная пара сочетания
[09:31.120 --> 09:51.960]  тогда и только тогда когда но на самом деле бывает еще так что совершенно называют как максимально
[09:51.960 --> 09:59.840]  возможная да то есть так чтобы хотя бы в одной доля все были включены ну либо может сказать что
[09:59.840 --> 10:08.360]  заранее сказано что да что слева и справа одинаковое количество вот значит существует
[10:08.360 --> 10:17.080]  совершенно пощадка тогда и только тогда когда для любого множества да значит тут может кинуть
[10:17.080 --> 10:26.840]  обозначение да значит давайте графя левая часть правая часть и рёбра
[10:26.840 --> 10:37.680]  да значит удольный граф значит существует тогда и только тогда когда для любого под множество
[10:37.680 --> 10:54.160]  с под множество l значит размер множество соседей больше ли браин чем размер нововица
[10:54.160 --> 11:06.720]  значит вот это вот и на тес это но что вершин но что вершин естественно р значит соединенных
[11:06.720 --> 11:13.200]  соединенных хотя бы с одним элементом вес
[11:25.160 --> 11:38.160]  вот но то есть что здесь происходит какие какие могут быть нарушения ну например может быть
[11:38.160 --> 11:45.800]  если с одного элемента и это элемент вообще ни с кем не соединен ну тогда понятно что совершенно
[11:45.800 --> 11:55.240]  не получится сделать вот да еще это предполагаю что либо у нас заранее задано что или р одного
[11:55.240 --> 12:08.680]  размера либо мы совершенном называем то у которого все вершины л входят а и а и как получится да
[12:08.680 --> 12:15.640]  значит может быть так что есть один элемент который вообще ни с кем не соединен так тогда
[12:15.640 --> 12:20.760]  здесь будет один а здесь ноль будет нарушение но и понятно что это элемент мы никак включить не
[12:20.760 --> 12:28.920]  сможем может быть ситуация такая что есть два элемента у которых ровно один сосед и сосед один
[12:28.920 --> 12:41.440]  и тот же вот но тогда тоже ясно что максимум в одному из них можно этого соседа включить
[12:41.440 --> 12:50.920]  пара сочетания ну и так далее и так далее в общем вполне может быть там что у каждого из них
[12:50.920 --> 12:58.120]  что например с 10 элементов у каждого из них 9 соседей но это одно и то же но что с девяти
[12:58.120 --> 13:07.560]  соседей тогда соответственно хотя бы один элемент пары не хватит вот ну и так далее
[13:07.560 --> 13:23.320]  так хорошо значит тут более более менее очевидно необходимость на то есть и существование
[13:23.320 --> 13:33.920]  совершенно про сочетание это следует более менее очевидно так знаете я все к нему писать очевидно
[13:33.920 --> 13:49.480]  да распишу немножко да что у каждого у каждого элемента с должна быть своя пара
[13:49.480 --> 14:16.880]  должна быть своя пара вверх и все эти все эти пары это различные элементы и на тес
[14:19.480 --> 14:27.240]  вот значит ну тогда более менее очевидно получается да что значит в вн от с есть по
[14:27.240 --> 14:32.400]  крайней мере столько же различных элементов сколько есть в с значит все получается значит
[14:32.400 --> 14:49.520]  размеры размера н от с будет не меньше вот значит это лево направо так сейчас камеры
[14:49.520 --> 15:02.680]  доску это не снимает значит это слева направо значит теперь справа налево справа налево уже
[15:02.680 --> 15:12.640]  совсем не так очевидно вот и будем доказывать от противного на то есть предположим что
[15:12.640 --> 15:30.080]  совершенного нету но какое-то то есть и возьмем самое большое значит возьмем наибольшее значит
[15:30.080 --> 15:49.680]  пусть совершенного нет значит рассмотрим наибольшее значит и значит назовем его м
[16:00.080 --> 16:16.400]  так но и будем дальше будем доказать если оно не да значит если оно не самое несовершенное
[16:16.400 --> 16:23.080]  то его на самом можно еще увеличить но то есть как это можно дальше то ты можешь делать как
[16:23.080 --> 16:26.720]  рассуждение противного возьмем наибольше если он несовершенен то покажем что он не наибольшего
[16:26.720 --> 16:33.440]  можно увеличить а можно просто сказать что любой несовершенно можно увеличить и мы будем
[16:33.440 --> 16:38.680]  увеличивать увеличивать увеличивать пока не дойдем до совершенного и это же даст и алгоритм
[16:38.680 --> 16:48.640]  поиска если мы сможем понять как именно увеличивать значит рассмотрим наибольшее м и покажем что
[16:48.640 --> 17:06.680]  его можно увеличить покажем что его можно увеличить вот так у нас получает противоречие
[17:07.040 --> 17:19.880]  так получается противоречие и заодно получается алгоритм поиска если у
[17:19.880 --> 17:24.440]  нас есть процедура процедура этого увеличения да то можно его последовательно применить
[17:24.440 --> 17:53.720]  да значит в общем что также получится алгоритм поиска начнем с какого-то значит
[17:53.800 --> 18:00.480]  например одного ребра и будем последовательно последовательно увеличивать
[18:00.480 --> 18:14.320]  и будем последовательно последовательно увеличивать
[18:14.320 --> 18:29.280]  но и заодно видно почему эффективно получится да потому что у нас каждый раз
[18:29.280 --> 18:34.360]  если мы увеличиваем то мы увеличим хотя бы на одно ребро вот поэтому мы можем
[18:34.360 --> 18:41.360]  n раз увеличивать и дальше те слену то число вершин в каждой доля вот и соответственно
[18:41.360 --> 18:48.040]  если процедура поиска вот это увеличение значит сама по себе полиномиальное но
[18:48.040 --> 18:55.480]  то мы ее н раз применим и получим в итоге значит полиномиальное время
[18:59.280 --> 19:16.640]  вот хорошо значит теперь как мы это будем делать значит тут основной инструмент это
[19:16.640 --> 19:31.680]  вот так называемый улучшающий путь улучшающий путь по английски augmenting path
[19:31.680 --> 19:43.200]  значит улучшающий путь устроен следующим образом значит это спочка вершин в
[19:43.360 --> 19:53.520]  все вершины разные на то что получается а 0 1 2 и так далее значит это обязательно будет
[19:53.520 --> 20:08.920]  нечетное число ребер что будет адвокат и адвокат плюс первая значит это улучшающий путь путь если
[20:08.920 --> 20:23.160]  так первая ну первое может сказать что все аи ты различная я и ты различная второе второе что
[20:23.160 --> 20:37.880]  концы этого пути не входят в парсочетание на то есть вот это а 0 и а 2к плюс 1 не входят в м да но
[20:37.880 --> 20:42.040]  это не универсальное понятие улучшающего пути это улучшающий именно для конкретного
[20:42.040 --> 20:49.840]  парсочетания да то есть путь улучшающий м вот соответственно первые последние вершины не
[20:49.840 --> 21:07.800]  входят в м вообще вот и более того значит все ну все ребру которых все соседи вершины у которых
[21:07.800 --> 21:19.000]  первые вершины мечетный номер не входят в м да то есть а 2 и т и а 2 и плюс первая не входят в
[21:19.000 --> 21:25.600]  м но входят все-таки в я да то есть это ребро из графа то есть это будет лежать в е без м
[21:25.600 --> 21:41.960]  ну а все и наоборот нечетная чета 2 и плюс 1 на 2 и плюс 2 ходят в м вот то есть в этом пути
[21:41.960 --> 21:51.920]  значит в этом пути есть такое чередование да то есть получается что выглядит он каким-то
[21:51.920 --> 22:05.320]  таким вот образом да значит например если на вот так вот я буду элемент м рисовать значит вот так
[22:05.400 --> 22:21.160]  вот просто ребро вот он как-то вот так вот он выглядит и тогда что тут получается получается
[22:21.160 --> 22:31.000]  мы можем заменить вот эти вот три ребра из м на 4 ребра неизвестно соответственно есть такой путь
[22:31.000 --> 22:41.520]  есть есть такой путь есть то можно и ребра которые в нем и в м заменить на те которые в нем и не в м
[22:41.520 --> 23:02.040]  значит если есть улучшающий путь то можно заменить можно заменить
[23:02.040 --> 23:28.240]  его ребра его ребра из м на его ребра неизвестно и тогда это тоже будет пар сочетания ровно
[23:28.240 --> 23:35.720]  потому что оно ли первой последней вершины в м не входит на то есть отсюда нет никакого
[23:35.720 --> 23:42.680]  ребра вот такого жирного отсюда тоже нету поэтому того что мы так заменили у нас это не перестанет
[23:42.680 --> 23:53.160]  быть пар сочетанием вот но то есть тут получается что-то типа такой рецепт но реакции да что мы
[23:53.160 --> 23:59.160]  хотим вот этому элементу найти пару на наш нашли но это уже был в паре вот с этим поэтому мы
[23:59.160 --> 24:05.360]  тоже что-нибудь другое находим да и так это и идет зигзагом и потом вот это вы наконец находим
[24:05.360 --> 24:20.840]  элемент который ни с кем паре не состоял вот но теперь вопрос почему улучшающий путь
[24:20.840 --> 24:28.880]  существует и как его искать значит если он если он есть мы его нашли то тогда можно применить
[24:28.880 --> 24:36.480]  вот процедула увеличение так значит но вот первый называется лемма бержа
[24:36.480 --> 25:02.640]  лемма бержа если пар сочетания не максимальная если пар сочетания не максимальная то существует
[25:02.640 --> 25:28.440]  улучшающий вот но и второй вопрос как его искать но на самом как вопрос о том как его искать даже
[25:28.440 --> 25:47.400]  немножко попроще ой не наибольшая да правильно так да спасибо да если если пар сочетания не
[25:47.400 --> 25:52.960]  наибольшая то существует улучшающий путь ну да с как бы с не максимально тоже было верно это очевидно
[25:52.960 --> 26:02.520]  значит принципе еще нужно читать путем отдельное ребро не в пар сочетания чтобы это было верным
[26:02.520 --> 26:13.720]  значит нужно вырожденный в случае когда там кара в нулю тоже считать улучшающим путем вот
[26:22.960 --> 26:39.960]  вот ну а и значит искать его можно процедуры типа поисковая в глубину да значит а именно мы берем
[26:39.960 --> 26:48.560]  какую-то вершину дальше берем берем какую-то вершину не в пар сочетания с одной стороны да и как
[26:48.560 --> 26:58.920]  бы выстраиваем такое дерево на что у нас значит берем как бы всех соседей на если у нас какой-то
[26:58.920 --> 27:07.760]  сосед не в пар сочетания да то тогда мы можем просто трибров добавить на соответственно если у
[27:07.760 --> 27:16.680]  нас все соседи в пар сочетания на то мы как бы идем сюда и у нас теперь слева позиция получается
[27:16.680 --> 27:25.080]  столько же столько же точек сколько было здесь соседей и дальше мы из каждой из них опять же
[27:25.080 --> 27:35.160]  смотрим все выходящие ребра в еще не рассмотренные вершины на если какое-то ребро там идет в вершину
[27:35.160 --> 27:41.320]  не в пар сочетания то мы снова нашли да значит такой зигзак вот если не тоже все пар сочетания
[27:41.320 --> 27:47.320]  то и ищем снова те те которые с ними соединены вот ну и так далее получается что в этой процедуре
[27:47.320 --> 27:55.960]  мы ну какие-то ветки у нас будут обрываться даже когда у нас очередной вершины лево будут все
[27:55.960 --> 28:03.280]  соседей уже рассмотрены ранее справа вот али в какой-то момент мы доберемся вот досюда вот
[28:03.280 --> 28:10.080]  на такой вершины справа у которой уже соседей слева не будет в пар сочетания
[28:14.960 --> 28:25.960]  вот но в общем-то можно аккуратно оценить сколько это времени будет занимать вот
[28:25.960 --> 28:37.880]  значит дать докажем что есть действительно будет будет что искать так смотрите вот пусть
[28:37.880 --> 28:51.600]  значит пусть им это текущие пар сочетания им текущие пар сочетания вот а им со звездочкой
[28:51.600 --> 29:06.760]  это наибольшие пар сочетания значит и мы рассмотрим
[29:06.760 --> 29:28.920]  рассмотрим такую вещь им твор им со звездочкой значит им сором со звездочкой то есть те рёбра
[29:28.960 --> 29:35.480]  которые ровно в одном из мм со звездочкой значит рёбра
[29:35.480 --> 29:53.960]  ходящие ровно в одно ровно в одно из мм со звездочкой
[29:53.960 --> 30:04.280]  значит тут получается что у каждой вершины степень будет не больше двух
[30:04.280 --> 30:10.400]  наш каждой вершины максимум в одно ребро входит в мм максимум в одном рам со звездочкой
[30:10.400 --> 30:32.240]  значит у этого под графа у этого под графа и степени не больше двух значит 0 1 или 2
[30:32.240 --> 30:39.880]  это значит что как он выглядит но я знаю что он стоит из циклов цепочек изолированных вершин
[30:39.880 --> 31:01.000]  да то есть получается что он состоит из циклов из циклов цепочек и изолирных вершин
[31:01.000 --> 31:08.240]  вот а при этом рёбра
[31:08.240 --> 31:27.880]  рёбра из м и им со звездочкой передурится это вот за этим я брал кор да потому что
[31:27.880 --> 31:33.480]  вообще принес можно было просто все рёбра из м и им со звездочкой брать это все было бы верно вот
[31:33.480 --> 31:41.080]  но вот про чередование было бы неверно да потому что если бы я не взял ксор то одно
[31:41.080 --> 31:49.680]  ребро могло быть сразу и в м и в им со звездочкой а так оно либо в одном либо в другом вот раз
[31:49.680 --> 31:55.760]  они чередуются значит все циклы четной длины вот правда про двудольный граф мы это и так
[31:55.760 --> 32:01.720]  знали в вдольном графе все циклы все циклы четной длины но на самом деле это лемма верна
[32:01.720 --> 32:17.400]  и для небу вдольного графа значит поэтому я так в общем не доказываю значит все циклы четной длины
[32:17.400 --> 32:30.080]  но это раз не чёт длины и м и им со звездочкой чередуют значит у них поровну рёбер из м и им
[32:30.080 --> 32:37.840]  со звездочкой если цепочка четной длины там тоже поровну из м и им со звездочкой если не
[32:37.840 --> 32:43.520]  чётный то какого-то одного из них на один больше но поскольку всего в им со звездочкой больше рёбер
[32:43.520 --> 32:49.200]  чем в им то должна хотя бы хотя бы одна цепочка которая тоже рёбер из им со звездочкой больше
[32:49.200 --> 33:04.640]  чем в им но вот эта цепочка и будет улучшающим путем так дайте я вот тут вот допишу значит
[33:04.640 --> 33:18.200]  существует цепочка которой элементов им со звездочкой на один больше
[33:18.400 --> 33:27.200]  тем элементов им значит она будет
[33:27.200 --> 33:40.720]  она будет улучшающим путем на потому что мы как раз начинаем им со звездочкой да
[33:40.720 --> 33:49.280]  значит потом им им со звездочкой им и так далее но вот так вот она и будет выглядеть вот
[33:49.280 --> 34:05.440]  вот ну все значит получается доказали это мы что доказали мы вообще пока еще никак это не
[34:05.440 --> 34:16.000]  связали с условиям тиремы холла пока что мы доказали что можно улучшить не не наибольший
[34:16.000 --> 34:23.920]  парсочетание вот флага сейчас перерыв сделаем и в конце докажем тиремы холла с ним в конце
[34:23.920 --> 34:39.680]  в начале 2 половины а потом пойдем к недвудольным графам так дать продолжим
[34:39.680 --> 34:51.120]  значит теперь вот это вот все надо связать с тиремы холла да значит пока что
[34:51.120 --> 35:01.840]  значит мы что доказали значит мы связали улучшающий путь с тем что сочетание наибольшее вот а мы
[35:01.840 --> 35:08.560]  хотим что доказать что если у каждого множество слева соседей больше чем элементов самого
[35:08.560 --> 35:16.440]  множества тогда лучший путь есть вот но это сами легко понять вот по этой картинке чему это
[35:16.440 --> 35:27.840]  будет так что смотрите пусть у нас значит пусть у нас сочетание не там нет нет совершенного да
[35:27.840 --> 35:34.680]  значит есть наш есть наибольшее вот раз он несовершенно значит какая-то вершина слева есть
[35:34.680 --> 35:45.560]  из нее должно какое-то ребро ну либо там из нее вообще ребр нет и у нас условия нарушена вот дальше
[35:45.560 --> 35:54.400]  дальше если у этого ребра если это ребро пока не входит парсочетания если если вот это вершина
[35:54.400 --> 35:59.600]  пока не входит парсочетания тогда можно вот это ребро добавить и соответственно этому все
[35:59.600 --> 36:07.080]  закончится есть но входят на что рассмотрен советско ребру который входит дальше смотрите
[36:07.080 --> 36:24.280]  если вот у этих на двоих только один сосед то нарушен наши условия вот значит что ну значит
[36:24.280 --> 36:34.160]  вообще может быть что отсюда еще много выходит вот но дальше что может быть но мы на
[36:34.160 --> 36:42.000]  самую такую штуку возьмем для каждого соседа вот этой вершины значит если у этой шли есть
[36:42.000 --> 36:47.800]  какой-то сосед который не входит парсочетания то мы добавим это ребро если они все входят да
[36:47.800 --> 36:54.920]  то мы как бы вот для каждого из них да значит добавим там вот такую вот штуку
[36:54.920 --> 37:02.960]  вот и все равно да что-то на этой картинке тут получается 4 вот таких вот вершины да и
[37:02.960 --> 37:15.440]  3 сосед слева в правом смысле вот значит если если не у одной из значит у этой мы уже всех
[37:15.440 --> 37:23.600]  всех соседей взяли если не у одной из этих нету соседа не среди этих трех вершин то у нас
[37:23.600 --> 37:32.880]  нарушено условия вот значит хотя бы у одной из них значит есть сосед не из этих трех где-то
[37:32.880 --> 37:41.520]  еще но опять мы возьмем всех таких соседей если один из них не в парсочетании то мы получим
[37:41.520 --> 37:47.760]  улучшающий путь если не все в парсочетании то мы снова возьмем ребра в левую часть но и так
[37:47.760 --> 37:52.880]  будем наращивать и рано или поздно ли получим улучшающий путь либо получим нарушение условия
[37:52.880 --> 37:58.360]  так ну что это понятно
[37:58.360 --> 38:08.720]  нет они могут поискаться потому что вот это у нас парсочетания да рассвет парсочетания не
[38:08.720 --> 38:17.840]  могут в одну и ту вершину прийти вот поэтому они будут разветвляться ну и более-менее да
[38:17.840 --> 38:25.160]  значит более-менее односамый тархаежная процедура который улучшающий путь ищется вот его
[38:25.160 --> 38:29.360]  ровно так и надо искать мы возьмем какую-то вершину не в парсочетании возьмем всех ее соседей
[38:29.360 --> 38:37.400]  вот возьмем ребра в парсочетании в которые они входят возьмем снова всех соседей вот ну и
[38:37.400 --> 38:45.840]  так далее и либо ну и раз у нас полемия улучшающий путь есть то рано или поздно такой процедуры мы к
[38:45.840 --> 38:54.440]  нему должны прийти вот а при этом у нас каждый раз задействуется какая-то новая вершина значит
[38:54.440 --> 39:11.800]  это будет процедура там не длиннее вот так ничего понятно но я и я считаю что у нас получается что
[39:11.800 --> 39:20.280]  мы разобрались полностью с кучей вдвудольных графов значит я только хочу подчеркнуть следующее
[39:20.280 --> 39:29.080]  то проверять условия теремы холл непосредственно и это как раз долгая процедура да потому что
[39:29.080 --> 39:34.400]  перебирать все множество там для них вычислять но что соседей всех под множество будет экспедициальное
[39:34.400 --> 39:41.320]  количество вот поэтому на самом деле хотя терема холла математически красиво и полезно и связано
[39:41.320 --> 39:48.160]  с разными другими утверждениями но применять ее для проверки существования совершенно
[39:48.160 --> 39:55.040]  парасочетания это идея плохая значит вместо этого нужно просто строить наибольшие парасочетания
[39:55.040 --> 40:03.760]  вот таким вот образом и либо оно построится и будет совершенное либо в какой-то момент оно
[40:03.760 --> 40:12.200]  остановится да и значит совершенно не будет вот что на самом деле вот такая такая процедура она
[40:12.200 --> 40:19.120]  если есть улучшающий путь найдет его а вот если нет то она остановится не найдя его значит его нету
[40:19.120 --> 40:34.680]  вот так ну чего понятно так ну ладно тогда переходим дальше переходим к случаю нет
[40:34.680 --> 40:56.400]  вдольных графов 2 это случай лучей нет вдольных графов значит что здесь можно сказать ну конечно
[40:56.400 --> 41:06.880]  никакой терема холл тут уже нету потому что нельзя вот так вот разделить на две части вот
[41:06.880 --> 41:12.960]  но тем не менее есть понятие улучшающего пути да то есть понятие парасочетания остается да
[41:12.960 --> 41:19.760]  значит парасочетания набора ребра которые не пересекаются по вершинам соответственно
[41:19.760 --> 41:26.880]  понятие улучшающего пути тоже остается и лема берже тоже остается верный да что-то остается
[41:26.880 --> 41:48.000]  понятия тогда остаются остаются понятия парасочетания включая совершенное наибольшие
[41:48.000 --> 41:53.680]  максимальное значит тут с понять парасочетания значит улучшающего пути
[41:53.680 --> 42:02.080]  значит и также верна лема берже
[42:18.000 --> 42:35.840]  значит но чем может быть проблема значит может быть проблема с поиском улучшающего пути
[42:35.840 --> 42:54.480]  значит может возникнуть может возникнуть проблема с поиском
[42:54.480 --> 43:12.680]  улучшающего пути значит что может быть проблема и почему не возникал раньше но
[43:12.680 --> 43:20.680]  дело в том что раньше мы не не могли в общем прийти в одну и ту же точку да то есть мы как бы
[43:20.680 --> 43:27.440]  строили вот такое вот дерево да и у нас все вершины как-то в него вставали а здесь
[43:27.440 --> 43:34.120]  можно смотреть что получится значит вот мы значит начинаем строить улучшающий путь
[43:34.120 --> 43:42.520]  значит как-то его так строим
[43:42.520 --> 43:49.280]  так сейчас
[44:04.120 --> 44:13.200]  и пришли вот так вот ту же точку где мы уже были значит поскольку граф нет вудульных тут
[44:13.200 --> 44:21.560]  возможно нечетные циклы ну и мы так гуляя по дереву могли в этот нечетный цикл и войти вот
[44:21.560 --> 44:30.240]  но и как после этого да не поймать что делать да то есть мы как бы вернулись туда откуда приходили
[44:30.240 --> 44:40.640]  да и дальше этот путь на расчет нельзя вот и вполне возможно значит вполне возможно нужно было
[44:40.640 --> 44:48.960]  идти не по нему а ну и вообще тут как бы его нельзя переключить да потому что если вы
[44:48.960 --> 44:56.840]  переключаете тут тоже получается что вот этих жирных ребер уже имевшихся на одно больше чем
[44:56.840 --> 45:06.360]  наоборот на одну меньше чем тонких но тонкий не образует парусочетания вот поэтому так взять
[45:06.360 --> 45:19.160]  переключить не можем вот и кроме того значит тут возможно это альтернативная цепочка которая
[45:19.160 --> 45:29.840]  может быть будет даже длиннее так может быть длиннее может быть даже не длиннее а вот этих
[45:29.840 --> 45:41.600]  вот нету она такой же длины но как бы с этой цепочкой можно переключить да да конечно пришли
[45:41.600 --> 45:46.800]  вот сюда то мы не можем взять переключить то есть в общем идеи в том что нам как бы как нужно так
[45:46.800 --> 45:51.480]  построить алгоритм чтобы мы находили именно вот эту цепочку да они ту которая сворачивает
[45:51.480 --> 46:04.760]  само на себя вот понятно до сложности так ну ладно
[46:04.760 --> 46:32.520]  сейчас что еще раз так я про то и говорю да я про то и говорю что цикл нам не подойдет
[46:32.520 --> 46:40.480]  как увеличивающий путь вот но при этом нужно как то с него сходить а мест где нужно сходить
[46:40.480 --> 46:45.080]  может быть много поэтому как если это напрямую делать то будешь какой-то экспоненциальный перебор
[47:02.520 --> 47:26.920]  вот ну вот значит вот собственно что придумал эдмонс он на верх он придумал такую штуку
[47:27.640 --> 47:37.480]  не нечетный цикл где чередуются до ребра из ваш сочетание не из него кроме вот одной
[47:37.480 --> 47:49.160]  точки в которой приходит снаружи и он придумал что его можно стянуть алгоритм эдмонса
[47:49.160 --> 48:01.920]  значит заключается в том что значит мы
[48:01.920 --> 48:23.720]  тянем виток вот то есть построим новый граф который вместо вот этого цветка будет одна вершина
[48:23.720 --> 48:33.000]  построим новый граф
[48:33.000 --> 48:44.840]  которым вместо цветка
[48:44.840 --> 48:51.200]  значит будет всего одна вершина
[49:14.840 --> 49:34.200]  но они как бы исчезнут вместе но смотрите значит тут что может сказать про цветок что из
[49:34.200 --> 49:40.480]  него выходит ровно одно ребро из пар сочетания на то есть вот из остальных вершин могут какие-то
[49:40.480 --> 49:58.080]  ребра выходить но они точно будут не участвовать пар сочетания да да да да цвет цветок это цикл
[49:58.080 --> 50:02.480]  нечетной длины в котором каждый второй в пар сочетания а вот у одной вершины где сходят
[50:02.480 --> 50:09.680]  два не из пар сочетания тоже обязательно есть какое-то выходящее ребро что здесь вот есть
[50:09.680 --> 50:23.600]  выходящее ребро тоже из пар сочетания вот то есть в общем получается что значит теперь вместо той
[50:23.600 --> 50:34.160]  картины которая была да значит вот вот тут как раз будет как бы вот большая такая вершина
[50:34.160 --> 50:45.960]  вот и из нее да я так условно покажу дат похоже на то что там нарисовано значит из нее будут
[50:45.960 --> 50:58.720]  выходить всевозможные ребра вот во все те которые раньше были соединены с вершинами
[50:58.720 --> 51:14.480]  этого цикла вот ну значит остаток будет так вот я стараюсь точно перерисовать
[51:14.480 --> 51:28.360]  вот значит ну и теперь получается что вот это вот новая вершина которая соответствует цветку
[51:28.360 --> 51:36.240]  она тоже входит пар сочетания значит той вершиной которая раньше была соединена 100 вершины цветка у
[51:36.240 --> 51:45.360]  которых у которой оба ребра внутри цветка не из пар сочетания да то есть вот так как у нас было
[51:45.360 --> 51:53.920]  одно одно ребро приходящее из из вне витка в цветок и который было по из пар сочетания так оно
[51:53.920 --> 52:05.240]  вот здесь вот и осталось вот значит теперь тут ждать следующее что мы получили граф меньшего
[52:05.240 --> 52:13.720]  размера да начнем меньше вершин но и меньше ребер автоматически нам все все все ну даже
[52:13.720 --> 52:18.160]  неважно что ваше меньше вершин да но ребер меньше потому что все все все которые внутри
[52:18.160 --> 52:40.240]  до 4 исчезли вот ну и тогда на что говорится говорит что если в новом графе мы найдем
[52:40.240 --> 52:52.480]  улучшающий путь то тогда его можно превратить в улучшающий путь в старом графе значит
[52:52.480 --> 53:07.040]  улучшающий путь в новом графе можно превратить ва улучшающий путь в старом
[53:07.040 --> 53:24.480]  ну конечно интересен случай когда улучшающий путь в новом очеред цветок проходить на что же
[53:24.480 --> 53:29.320]  такая процедура разлетеленная дальше могли где-то найти цветок его стянуть а потом в
[53:29.320 --> 53:32.720]  итоге оказалось что улучшающий путь этот цветок вообще не затрагивает это да где-то там еще
[53:32.720 --> 53:40.240]  проходит вот так что интересен конечно случай когда он через цветок проходят вот ну тут
[53:48.400 --> 53:52.600]  что нужно делать значит ну
[53:56.000 --> 54:00.400]  что вообще нужно делать значит нужно взять все все ребра которые вот в этом новом графе
[54:00.680 --> 54:07.000]  рёбра которые есть новым графе они есть и в старом графе но старом графе тут получается разрыв
[54:07.000 --> 54:13.000]  да тут как будто отдельно вот такая цепочка значит отдельно такая цепочка но это цепочка
[54:13.000 --> 54:20.960]  как раз нужно соединить внутри цветка значит именно вот здесь вот вот но при этом обратите
[54:20.960 --> 54:28.240]  обратите внимание что если тут какой-то в каком другом месте да было бы да то есть тут пусть
[54:28.240 --> 54:32.840]  Пусть вот это там как-нибудь по-другому закончилось, а мы нашли вот это вот.
[54:32.840 --> 54:39.240]  Значит, тогда если мы пойдем вот как бы по этой части, то это будет неправильно,
[54:39.240 --> 54:42.840]  но в том-то и дело, что мы можем идти как понязо, так и поверху.
[54:42.840 --> 54:53.240]  Вот сюда вот нужно идти понязо, вот так вот, а сюда нужно идти поверху, вот так вот.
[54:53.240 --> 54:58.240]  Да, и в том и другом случае получается, что и вот с этим хвостом получается улучшающий путь,
[54:58.240 --> 55:01.240]  и вот с этим вот получается улучшающий путь.
[55:03.240 --> 55:16.240]  Как раз за счет нечетной длины циклы мы можем и там, и там прийти как бы с нужной чётностью к старту,
[55:16.240 --> 55:19.240]  к старту оставшейся части.
[55:20.240 --> 55:24.240]  Так, ну чего, понятно.
[55:27.240 --> 55:33.240]  Ну вот, что есть получается алгоритм такой.
[55:35.240 --> 55:44.240]  Начинаем искать улучшающий путь, вот в исходном графе, каким-то таким поиском в глубину.
[55:44.240 --> 55:49.240]  Значит, если этот поиск привел к цветку, то мы этот цветок стягиваем.
[55:49.240 --> 55:54.240]  Ну, если забоиться об эффективности, нужно сохранить какую-то информацию из предыдущего этапа,
[55:54.240 --> 55:57.240]  но в принципе в теории можно с нуля начинать.
[55:57.240 --> 56:03.240]  Вот мы его стянули, запомнили какие там были ребра внутри стянутого цветка,
[56:03.240 --> 56:08.240]  и заново начинаем процедуру поиска улучшающего пути рекурсивно.
[56:08.240 --> 56:14.240]  Ну, поскольку у нас каждый раз уменьшается размер графа, то для совсем маленьких графов всё очевидно,
[56:14.240 --> 56:18.240]  если там две вершины, то понятно, откуда брать улучшающий путь.
[56:20.240 --> 56:28.240]  Вот, а потом, соответственно, мы начинаем поднимать улучшающий путь на исходный граф.
[56:30.240 --> 56:32.240]  Вот, сколько времени это будет работать?
[56:32.240 --> 56:35.240]  Ну, смотрите, поскольку у нас каждый раз уменьшается размер графа,
[56:35.240 --> 56:37.240]  ну и на самом деле он сокращается минимум на два.
[56:37.240 --> 56:40.240]  Потому что самый маленький цветок – это треугольник.
[56:45.240 --> 56:49.240]  Вот, соответственно, будет шагов рекурсии не больше, чем энтополам.
[56:53.240 --> 56:59.240]  Ну и, соответственно, превращение на неразборчивый граф,
[56:59.240 --> 57:08.240]  ну и, соответственно, превращение улучшающего пути в новом графе,
[57:08.240 --> 57:10.240]  до улучшающего пути в старом графе.
[57:10.240 --> 57:13.240]  Ну и тоже какая-то там простая процедура.
[57:15.240 --> 57:21.240]  Вот, то есть получается энтополам этапов.
[57:23.240 --> 57:28.240]  Вот, и на каждом тоже какая-то, ну уж не больше, чем энн, наверное.
[57:29.240 --> 57:34.240]  Тут как бы есть некоторые, там можно более точные оценки делать из-за того, что у нас,
[57:34.240 --> 57:37.240]  либо у нас какие-то очень простые восстановления, вот это вот,
[57:37.240 --> 57:41.240]  либо у нас очень сильно размер падает.
[57:41.240 --> 57:43.240]  На это будет меньше шагов рекурсии.
[57:44.240 --> 57:47.240]  Ну, в общем, домен в квадрате вроде должно получиться.
[57:47.240 --> 57:53.240]  Ну, правда, это вот, если у нас тягиваются, да, вообще-то это же у нас поиск глубины,
[57:53.240 --> 57:59.240]  и мы там должны все ребра обрабатывать, да, и тогда уже этот поиск там, наверное, в квадрате займет.
[58:00.240 --> 58:04.240]  Но тогда, если мы его умножим на число рекурсии, это будет типа n в кубе.
[58:05.240 --> 58:08.240]  На число шагов рекурсии это будет типа n в кубе, вот.
[58:08.240 --> 58:11.240]  Ну вот, примерно это, собственно, Эдман списал свои стандарты.
[58:11.240 --> 58:14.240]  И после этого он написал, что вот, видите, у меня тут n в кубе.
[58:16.240 --> 58:19.240]  И это хорошо, потому что это растет не слишком быстро.
[58:21.240 --> 58:26.240]  Вот. И там у него на паре страниц дискуссия, что вот, если это в какой-то степени, да,
[58:26.240 --> 58:27.240]  то это нужно считать быстро.
[58:30.240 --> 58:31.240]  Вот.
[58:34.240 --> 58:35.240]  Вот.
[58:36.240 --> 58:37.240]  Вот.
[58:41.240 --> 58:43.240]  Значит, вот такая история.
[58:46.240 --> 58:48.240]  Есть ли по ней какие-нибудь вопросы?
[59:05.240 --> 59:06.240]  Спасибо.
[59:35.240 --> 59:40.240]  Ну, значит, тут нужна...
[59:43.240 --> 59:48.240]  Значит, смотрите, идея такая, почему n в кубе, что n шагов рекурсии
[59:48.240 --> 59:52.240]  и на каждом шаге есть и н шагов рекурсии,
[59:52.240 --> 59:55.240]  и у каждой этой степени есть и н шагов рекурсии,
[59:55.240 --> 59:58.240]  и это не то, что и на каждом шаге.
[59:59.240 --> 01:00:01.240]  То есть это не то, что и на каждом шаге.
[01:00:01.240 --> 01:00:09.520]  что n шагов рекурсия и на каждом шаге мы вообще говоря запускаем пояс глубину вот а
[01:00:09.520 --> 01:00:16.600]  пояс глубину но после того чтобы еще искать вот такие вот пути с чередованием вот а пояс
[01:00:16.600 --> 01:00:23.200]  глубину подразумевает а ну и я имею в виду число вершин да да то есть по пояс глубину
[01:00:23.200 --> 01:00:28.840]  подразумевает там перебор ребер какой-то да ребер как раз может быть порядком в квадрате
[01:00:31.240 --> 01:00:45.080]  вот хорошо начну а сам деле это некоторые малая часть этой области которая рассказала
[01:00:45.080 --> 01:00:53.840]  что тут есть много разных алгоритмов значит есть всякие взвешенные варианты значит есть связь
[01:00:53.840 --> 01:01:04.400]  с теоремой о максимальном потоке минимальным разрезе и там рассказывали где-нибудь
[01:01:04.400 --> 01:01:16.680]  не мин кат макс флоу там форда фолкер сона не знакомые слова что форда фолкер сона
[01:01:16.680 --> 01:01:30.080]  или еще там мин кат макс флоу это называется корма не конечно да в корму нет и есть вот
[01:01:30.080 --> 01:01:39.600]  в общем это все с этим может быть связано значит особенно значит например для вдольных
[01:01:39.600 --> 01:01:48.720]  парсочетаний значит можно сослаться вот значит можно сослаться на теорему о минимальном разрезе
[01:01:48.720 --> 01:01:58.360]  максимальном потоке значит вот там какой-то граф дальше ты и можно
[01:01:58.360 --> 01:02:13.000]  добавить еще источник добавить сток на и сказать что мы хотим как можно больше поток провести
[01:02:13.000 --> 01:02:20.280]  отсюда сюда тогда вот в этой части этот поток должен идти по парсочетанию на то есть тут нужно
[01:02:20.280 --> 01:02:29.880]  но имея ввиду что вот там по каждому ребру мы можем провести максимум единицу на тогда вот
[01:02:29.880 --> 01:02:36.960]  это вот единица пришла сюда значит и она должна да тут конечно еще важно у нас дискретно задачи
[01:02:36.960 --> 01:02:44.920]  или непрерывная да то есть непрерывная обозначала что может как-то делиться вот так вот вот дискретная
[01:02:44.920 --> 01:02:51.160]  ну а считать что у нас просто в каждое каждое ребро либо полностью занято либо вообще не
[01:02:51.160 --> 01:02:56.880]  занято вот тогда это получается ровно задача максимальный парсочетания он наибольшим
[01:02:56.880 --> 01:03:06.400]  задача наибольшим парсочетаниям вот хорошо
[01:03:15.080 --> 01:03:23.920]  значит что еще можно сказать с кем-то еще связано есть например связь вот с чем на
[01:03:23.920 --> 01:03:30.520]  первый взгляд совершенно другой задачи на самом то же самое значит есть такое понятие
[01:03:30.520 --> 01:03:48.600]  перманент не слышали такое понятие слышали о каком контексте у матрицы да конечно да не все
[01:03:49.280 --> 01:03:56.000]  вообще смотрите перманент это такая штука которая вычисляется как детерминат только без знаков
[01:03:56.000 --> 01:04:09.320]  да то есть перманент значит перманент матрицы а это значит сумма по всем перестановкам сигма
[01:04:09.320 --> 01:04:19.840]  если матрица n на n на сумму по всем перестановкам сигма тут будет произведение по и от единицы до
[01:04:19.840 --> 01:04:31.480]  n а и ты и сигма ты ты вот вот если тут еще будет минус один степени счетность перестановки это
[01:04:31.480 --> 01:04:41.600]  будет определитель на детерминат дальше давайте это напишу значит а вот у детермината здесь
[01:04:41.600 --> 01:04:56.360]  на том минус один степени сигма вот и для детермината есть алгоритмы подсчета на там
[01:04:56.360 --> 01:05:04.360]  через какой метод гаусса да или там раскладывать там по строке и столбцу не раскладывать на это
[01:05:04.360 --> 01:05:14.920]  сейчас на труде тоже работает да но можно там приводить преобразованиями гаусса да там
[01:05:14.920 --> 01:05:20.920]  ступенчатому виду а вот письма виду просто перемножить на диагонали это будет будет детерминат
[01:05:20.920 --> 01:05:27.160]  довольно быстро происходит может быть еще какие-нибудь там или у разложения там какие-то
[01:05:27.160 --> 01:05:37.000]  в общем есть разные методы вот вот для для перманента никаких нормальных методов неизвестно
[01:05:37.000 --> 01:05:43.320]  вот то есть понятно что можно почитать по определению но перестановка всех
[01:05:43.920 --> 01:05:51.240]  вот соответственно это будет вот какое-то вот такое большое реальное множество на
[01:05:51.240 --> 01:05:58.720]  факториала даже еще немножко больше чем линейный экспонента на факториал это не два в степени цена
[01:05:58.720 --> 01:06:15.160]  на два степени цены цена и налог и вот значит соответственно по по определению перманент а считается
[01:06:15.160 --> 01:06:27.320]  нас считается за экспоненциальное время вот а других методов неизвестно
[01:06:27.320 --> 01:06:43.040]  других методов неизвестно значит при этом у него есть много разных приложений значит но в
[01:06:43.040 --> 01:06:53.200]  частности ясности перманент связан со числом пар сочетания с числом совершенных пар сочетаний
[01:06:53.200 --> 01:07:09.200]  Число совершенных паросочетаний в двудольном графе
[01:07:09.200 --> 01:07:20.200]  Это перманент матриц, который называется матрицей ТАТТА
[01:07:20.200 --> 01:07:34.200]  Есть матрица смежности, это аежит, аежит равно единице, если есть соединенный ребром
[01:07:34.200 --> 01:07:43.200]  Но если у нас граф двудольный, то мы знаем, что в половине этой матрицы это нули
[01:07:43.200 --> 01:08:01.200]  Число совершенных паросочетаний в двудольном графе это перманент его матрицы ТАТТА
[01:08:01.200 --> 01:08:11.200]  Матрица ТАТТ это кусок матрицы смежности
[01:08:11.200 --> 01:08:25.200]  Но если у меня граф двудольный и неориентированный, то тут будут нули
[01:08:25.200 --> 01:08:35.200]  Если вот это ль, вот это р и здесь вот это ль, вот это р, то внутри ль ребр нет и внутри р ребр нет
[01:08:35.200 --> 01:08:43.200]  А вот эти вот друг с другом будут транспонированы
[01:08:43.200 --> 01:08:48.200]  То есть тут какое-то б, а тут б транспонированы
[01:08:48.200 --> 01:08:58.200]  Но вот это вот б и будет матрица ТАТТА
[01:08:58.200 --> 01:09:12.200]  То есть тут получается, что б и аежитое равно единице, если пара l и t и r аежитое лежит в е
[01:09:12.200 --> 01:09:20.200]  Значит, где l и t и t вершина слева, а е аежитое это вершина справа
[01:09:20.200 --> 01:09:33.200]  Так вот, у этой матрицы перманент равен к раз числу совершенных паросочетаний
[01:09:33.200 --> 01:09:41.200]  Так, и чему? Очевидно
[01:09:41.200 --> 01:09:51.200]  Не очевидно, ну сейчас
[01:09:51.200 --> 01:10:07.200]  Ну да, совершенно верно
[01:10:07.200 --> 01:10:27.200]  Совершенно верно, значит, если все а и t сигма от и t равны единице, то тогда множество пар и t сигма от и t это совершенные паросочетания
[01:10:37.200 --> 01:10:47.200]  Ну и наоборот, на самом деле
[01:10:47.200 --> 01:10:53.200]  Любое паросочетание задает некоторую перестановку
[01:10:53.200 --> 01:10:59.200]  И в этой перестановке и должно быть соединено с сигма от и t
[01:10:59.200 --> 01:11:07.200]  Ой, только не а, а, б
[01:11:07.200 --> 01:11:18.200]  Вот, и это там, это а, тут это уже б
[01:11:18.200 --> 01:11:27.200]  Да-да-да, мы, во-первых, считаем, что у них одинаковое число, иначе заведом нет совершенных паросочетаний
[01:11:27.200 --> 01:11:35.200]  А дальше мы просто фиксируем какую-то нумерацию в левой доле и какую-то нумерацию в правой доле
[01:11:35.200 --> 01:11:40.200]  Вот
[01:11:40.200 --> 01:11:47.200]  Хорошо, значит, отсюда получаем, что, смотрите, какой эффект
[01:11:47.200 --> 01:11:59.200]  Да, значит, сравнить перманент матрицы, то есть выяснить перманент равен нулю или нет, это задача простая
[01:11:59.200 --> 01:12:15.200]  Выяснить верно ли то перманент b равен нулю, это простая задача
[01:12:15.200 --> 01:12:21.200]  По крайней мере, если у нас, если b из нулей единиц
[01:12:21.200 --> 01:12:27.200]  Значит, b из нулей единиц
[01:12:27.200 --> 01:12:33.200]  Потому что и наоборот, любая матрица из нулей единиц дает двудольный граф
[01:12:33.200 --> 01:12:41.200]  И тогда выяснить, равен ли перманент b нулю означает выяснить, есть ли хоть одно совершенное паросочетание
[01:12:41.200 --> 01:12:46.200]  А это ровно то, чем мы занимались в первой части лекции
[01:12:46.200 --> 01:12:53.200]  То есть выяснить, равен ли перманент b нулю, это простая задача
[01:12:53.200 --> 01:12:57.200]  А посчитать точно
[01:12:57.200 --> 01:13:00.200]  Значит, посчитать точно
[01:13:00.200 --> 01:13:07.200]  Сложная
[01:13:07.200 --> 01:13:14.200]  Вот так, ну, давайте я слова напишу, а уже не успею объяснить, что они означают
[01:13:14.200 --> 01:13:18.200]  Sharp P полная
[01:13:18.200 --> 01:13:24.200]  Вот, это да, это такой класс, это класс задач подсчета
[01:13:24.200 --> 01:13:32.200]  Значит, класс задач подсчета, когда нам нужно выяснить, как бы, сколько у нас подходящих сертификатов, фактически
[01:13:32.200 --> 01:13:37.200]  Вот это, смотрите, дайте еще минуту, скажу
[01:13:37.200 --> 01:13:42.200]  Поэтому вот эта вот задача сложнее, чем
[01:13:42.200 --> 01:13:44.200]  Сейчас, нет, не так
[01:13:44.200 --> 01:13:48.200]  Вот это вот эффект, который мы здесь наблюдаем
[01:13:48.200 --> 01:13:53.200]  Это эффект, которого нет для ANP полных задач
[01:13:53.200 --> 01:14:00.200]  В том смысле, что для ANP полных задач сложно уже понять, есть ли хоть один сертификат
[01:14:00.200 --> 01:14:05.200]  Да, то есть понятно, что сложно посчитать число выполняющих наборов у формулы
[01:14:05.200 --> 01:14:10.200]  Потому что даже понять, есть ли хоть один, это уже сложная задача
[01:14:10.200 --> 01:14:15.200]  Вот, а здесь получается, что есть ли хоть один, мы понять можем легко
[01:14:15.200 --> 01:14:22.200]  Вот, а вот посчитать точно количество не можем, но тут вот эта сложная конструкция, на самом деле
[01:14:22.200 --> 01:14:27.200]  Что это означает, ну вот, ну а Sharp P это вообще задача подсчета
[01:14:27.200 --> 01:14:31.200]  Каких-то объектов, когда мы можем понять, по объекту подходящий он или нет
[01:14:31.200 --> 01:14:36.200]  То есть, можно считать, что это подсчеты сертификатов для ANP
[01:14:38.200 --> 01:14:41.200]  Вот так, ну все, спасибо за внимание
[01:14:46.200 --> 01:14:49.200]  Так, следующий раз последняя лекция получается
[01:14:49.200 --> 01:14:52.200]  Наверное, я про задачу апроксимации поговорю
