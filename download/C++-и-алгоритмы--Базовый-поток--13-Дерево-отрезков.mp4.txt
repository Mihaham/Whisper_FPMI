[00:00.000 --> 00:13.440]  Мы сегодня продолжаем говорить про задачи RMQ-RSQ. В прошлый раз, я напомню, мы поговорили про то,
[00:13.440 --> 00:18.800]  как решать задачу статик-RSQ с помощью массива префиксных сумм. Поговорили о том,
[00:18.800 --> 00:25.680]  как решать задачу статик-RMQ с помощью разреженных таблиц. Тут надо сказать несколько моментов.
[00:25.680 --> 00:32.240]  В прошлой лекции в качестве формулы для запроса разреженной таблицы была написана следующая вещь.
[00:32.240 --> 00:44.760]  Если мы хотим найти минимум на отрезке от L до R, то нужно обратиться к следующим элементам.
[00:44.760 --> 00:55.240]  Естественно, в качестве K мы берем алгоритм 2-ичный R-R плюс 1, округленный вниз.
[00:55.240 --> 01:08.840]  Обращаемся к элементам K, L, к элементам K, R-2 в степени К, и тут надо написать плюс 1.
[01:08.920 --> 01:17.240]  Вот этот плюс 1 мы потеряли. Просто потому что, если мы возьмем, начиная с этого элемента, два степеника элементов,
[01:17.240 --> 01:27.400]  то мы закончим в позиции R. Вот первый момент. Второй, мы не обсудили, какие вообще операции
[01:27.400 --> 01:34.920]  можно осуществлять с помощью разреженной таблицы. Давайте кратко обсудим, какие вообще у нас есть
[01:34.920 --> 01:44.040]  требования на операцию в случае разреженных таблиц. В общем-то, понятно, что, как и в любой другой
[01:44.040 --> 01:50.560]  структуре данных, нам нужна ассоциативность. Второй пункт, что еще? Что нам было необходимо для
[01:50.560 --> 01:56.040]  разреженных таблиц, чтобы она корректно работала? Идемпатентность. Да, обратимость нам не нужна.
[01:56.040 --> 02:05.000]  Идемпатентность. Да, ну почему она нам была нужна? Потому что, если мы хотели посчитать минимум на
[02:05.000 --> 02:09.600]  отрезке, то мы говорили, что мы его разбиваем на один подотрезок, на второй подотрезок. Эти подотрезки
[02:09.600 --> 02:14.680]  могут теоретически пересекаться. Идемпатентность нам гарантирует, что операция будет посчитана
[02:14.680 --> 02:22.320]  корректно. Вот. Значит, на самом деле этих двух операций вполне достаточно. Ну и давайте то же
[02:22.320 --> 02:26.560]  самое сделаем для дерева Фенвика. Значит, мы обсуждали дерево Фенвика. И давайте обсудим,
[02:26.560 --> 02:36.200]  какие там требования на операцию. Ну, первое классически это ассоциативность. Второе требование
[02:36.200 --> 02:49.880]  это коммутативность. Это неочевидный пункт, поэтому я оставляю его в качестве упражнения. В общем,
[02:49.880 --> 02:57.360]  посмотрите, где там на самом деле нужна коммутативность. Спойлер она там нужна. И третье
[02:57.360 --> 03:02.880]  свойство, какое? Естественная обратимость. Да, ну потому что в случае суммы, скажем, если нам
[03:02.880 --> 03:09.280]  дан массив, напомню, если мы хотим посчитать сумму на каком-то отрезке, то сумму на отрезке мы
[03:09.280 --> 03:13.840]  сводим к суммам на префексе. То есть мы считаем сумму на таком префексе, сумму на таком префексе,
[03:13.840 --> 03:20.080]  и вычитаем одну сумму из другой. Вот. И здесь мы, естественно, пользуемся обратимостью.
[03:20.080 --> 03:29.120]  Вот. Это значит, что касается прошлой лекции, ну вот вкратце вспомнили, да, то есть мы обсуждали
[03:29.120 --> 03:33.360]  префексные суммы, обсуждали разрешенную таблицу, которая позволяет решать задачу статика RMQ,
[03:33.360 --> 03:40.780]  и посмотрели на дерево Фенвика, которое помогает решать задачу динамик RSQ. И у нас осталась одна
[03:40.780 --> 03:51.940]  и покрытая задача. Какая? Да, динамика RMQ. То есть мы хотим считать какую-либо инопатентную операцию,
[03:51.940 --> 04:01.260]  вот. И при этом желательно, чтобы мы дополнительно могли еще изменять эти самые элементы. Так.
[04:01.260 --> 04:07.500]  Значит, сегодня мы рассмотрим структуру данных под названием деревоотресков, и она будет решать
[04:07.500 --> 04:21.100]  более широкий класс задач, а именно динамик что угодно. Вот. Значит, мы сейчас построим деревоотресков,
[04:21.100 --> 04:26.500]  научимся решать вообще произвольную динамическую задачу. Вот. Ну и заодно, соответственно, посмотрим,
[04:26.500 --> 04:31.500]  как с помощью такой структуры данных может решаться задача динамика RMQ. Вот. Значит,
[04:31.500 --> 04:41.100]  почему деревоотресков? Сегмент. Сегмент 3. Почему деревоотресков умеет решать любую задачу? Ну,
[04:41.100 --> 04:44.020]  потому что единственное требование, которое накладывает на операцию, это ассоциативность. Ну,
[04:44.020 --> 04:47.020]  сейчас мы на это посмотрим. Давайте дадим сначала формальное определение. Значит,
[04:47.020 --> 05:08.260]  сегмент 3 или деревоотресков? Деревоотресков. Значит, это структура данных в виде... Так,
[05:08.260 --> 05:25.660]  неправильно начал. Давайте чуть выше. Пусть А массив из N равна 2 в степенька элементов. Значит,
[05:25.660 --> 05:30.460]  предположим, что мне дан массив, этот массив имеет размер 2 в степенька. То есть размер массива имеет
[05:30.460 --> 05:37.100]  степень... его размер равен некоторой степени двойке. Ну, в общем случае, понятно, что у нас массивы
[05:37.100 --> 05:42.100]  не равны степени двойке, но мы потом посмотрим, что с этим можно сделать. Пусть есть некоторый массив,
[05:42.100 --> 05:49.420]  который состоит из N элементов. N равно 2 в степеньках, где K это некоторое натуральное число. Вот.
[05:49.420 --> 06:05.220]  Тогда деревоотресков. Это структура данных в виде полного бинарного дерева. Бинарного дерева в
[06:05.220 --> 06:33.260]  листьях которого хранятся элементы А, а во внутренних вершинах хранятся, хранится,
[06:33.300 --> 06:50.140]  результат применения некоторой бинарной ассоциативной операции.
[06:50.140 --> 07:10.180]  Вот требования на ассоциативность, ассоциативной операции от детей во внутренних вершинах,
[07:10.220 --> 07:25.140]  от детей этой вершины. Этих вершин, давайте. Этих вершин. Пусть А это массив из N элементов,
[07:25.140 --> 07:29.940]  где N это 2 в степеньках. Тогда деревоотресковая структура данных в виде полного бинарного дерева,
[07:29.940 --> 07:33.860]  в листьях которого хранятся элементы массива А, а во внутренних вершинах хранится результат
[07:33.860 --> 07:40.340]  применения некоторой бинарной ассоциативной операции от детей этих вершин. Тут необходим пример.
[07:40.340 --> 08:01.780]  Пусть у меня есть массив А, ну, какой-нибудь, не знаю, 7, 1, 2, 5, 4, 0, 2, 3, 2, 3, 4, 5, 6, 7, 8, да. Вот
[08:01.780 --> 08:07.020]  такой массив. И давайте попробуем, исходя из этого пределения, построить деревоотреск. Что нам
[08:07.020 --> 08:12.020]  говорится? Нам говорится, что у этого дерева есть, что это полное бинарное дерево. Напомню, полное
[08:12.020 --> 08:17.820]  бинарное дерево означает, что у него, что у каждой вершины ровно два сына, и все уровни этого
[08:17.820 --> 08:23.580]  дерева заполнены. В листьях этого дерева хранятся собственные элементы массива. Давайте нарисуем
[08:23.580 --> 08:43.980]  8 листьев. И нарисуем в них, напишем в них значение этого массива. То есть тут 7, 1, 2, 5, 4, 0, 2, 3.
[08:43.980 --> 08:52.380]  Ну и, понятное дело, листья собираются в узлы более верхнего уровня. Эти узлы, в свою очередь,
[08:52.580 --> 09:00.700]  имеют родителя, ну и корень дерева здесь. Значит, читаем дальше. Во внутренних вершинах хранится
[09:00.700 --> 09:05.020]  результат применения некоторой бинарной ассоциативной операции от детей этих вершин. Ну давайте считать,
[09:05.020 --> 09:09.900]  что у нас в качестве операции выступает, ну что минимум, максимум. Ну давайте максимум.
[09:09.900 --> 09:18.940]  Все-таки мы стремимся решать задачу RMQ. Давайте возьмем в качестве операции максимум. Значит,
[09:18.940 --> 09:24.220]  дети вот этой вершины это 7, 1, поэтому здесь мы сохраним семерку. Здесь 2, 5, максимум это пятерка.
[09:24.220 --> 09:30.380]  Здесь 4, 0, максимум это четверка. 2, 3, максимум тройка. Здесь максимум это четверка. Здесь
[09:30.380 --> 09:40.460]  максимум семерка. Ну и в корне хранится 7. Вот, построили дерево отрезков. Почему дерево отрезков
[09:40.460 --> 09:44.540]  называется дерево отрезков? Ну, на самом деле, должно быть понятно, что если мы рассмотрим
[09:44.540 --> 09:51.980]  произвольную вершину, ну скажем вот эту, что в ней хранится? Что такое 4?
[09:51.980 --> 10:04.740]  Да, значит в узле, вот в этом узле, хранится максимум на вот этом подотрезке. Что хранится
[10:04.740 --> 10:09.540]  здесь? Здесь хранится максимум вот на таком подотрезке. Что хранится здесь? Здесь хранится
[10:09.540 --> 10:15.500]  максимум вот на таком подотрезке. То есть каждая вершина отвечает за некоторый свой подотрезок,
[10:15.500 --> 10:28.740]  причем длина этого подотрезка равна степени двойки. Хорошо. Ну давайте, уже наверное понятно,
[10:28.740 --> 10:35.180]  что в этом дереве каким-то образом закодирована некоторая информация о максимум. То есть,
[10:35.180 --> 10:38.820]  если мы хотим максимум на всем отрезке, то мы смотрим сюда. Если мы хотим узнать максимум,
[10:38.820 --> 10:44.940]  скажем, вот на таком отрезке, то мы должны посмотреть сюда и так далее. Давайте пока посмотрим,
[10:44.940 --> 10:52.140]  как эту самую структуру данных можно построить. Пока все понятно, да? Давайте первый пункт,
[10:52.140 --> 11:03.700]  построение. Давайте еще обсудим, что делать, если у меня вдруг так оказалось, что массив имеет
[11:03.700 --> 11:11.580]  длину неравную степени двойки. Допустим, здесь нет тройки. Допустим, у меня массив имеет размер 7.
[11:11.580 --> 11:15.620]  Что в этом случае делать? Ну на самом деле ничего сложного нет. Достаточно просто дополнить массив
[11:15.620 --> 11:19.780]  так называемыми нейтральными элементами. То есть нейтральный элемент такой элемент, который не
[11:19.780 --> 11:24.820]  меняет результат выполнения операции. Ну скажем, для сложения это 0. То есть каким бы числом вы не
[11:24.820 --> 11:29.180]  сложили 0, результат операции не изменится. В случае максимума это какое число или какое значение?
[11:29.180 --> 11:34.380]  Минус бесконечность, да. Давайте просто тут вот на тех элементах, которые не вошли в степень
[11:34.380 --> 11:39.080]  двойки, то есть если нам не дан массив, который не дотягивает до степени двойки, то я просто
[11:39.080 --> 11:44.180]  его дополню до ближайшей степени двойки значениями, некоторыми нейтральными значениями. Ну в случае
[11:44.180 --> 11:51.560]  максимума это минус бесконечность. Поэтому понятно, что в этом случае результат применения двойки и минус
[11:51.560 --> 12:03.360]  бесконечности будет двойкой, ну и так далее. Здесь максимум 4. Поэтому если у вас массив имеет длину
[12:03.360 --> 12:09.000]  не степень двойки, то ничего страшного в этом нет. Как выглядит построение? Ну построение на самом
[12:09.000 --> 12:13.280]  деле выглядит очень просто. Мы по сути это алгоритм только что и провели. То есть построение выглядит
[12:13.280 --> 12:17.920]  ровно по определению. Значит у нас есть нижний ряд и нижний ряд мы будем заполнять непосредственно
[12:17.920 --> 12:24.880]  значениями нашего массива. Сначала построим листья, потом построим следующий уровень,
[12:24.880 --> 12:30.800]  потом следующий уровень и так далее. Вопрос. Каким образом мы будем хранить вот это дерево в памяти?
[12:30.800 --> 12:38.800]  Какие есть предложения? Куча. Ну массив, да. Собственно у нас был уже пример в курсе, а именно
[12:38.800 --> 12:45.400]  бинарная пирамида, которая тоже имела вид бинарного дерева, который мы хранили непосредственно
[12:45.400 --> 12:49.800]  в одном массиве. Ну действительно давайте просто занумеруем следующим образом
[12:49.800 --> 13:06.160]  элементы дерева. То есть сверху вниз, слева направо. Просто просто некоторым образом заиндексируем
[13:06.160 --> 13:10.520]  наши элементы и будем все это хранить в одном массиве. Причем каждый элемент, например элемент
[13:11.320 --> 13:19.920]  5 будет храниться в массиве под инденсом номер 4. Ну и давайте ведем некоторые вспомогательные функции.
[13:19.920 --> 13:29.200]  Скажем, если я нахожусь в вершине номер и, то как мне получить родителей этой вершины? И пополам.
[13:29.200 --> 13:41.640]  Ну да. Целая часть. Если я хочу получить левую вершину, я нахожусь в вершине и я хочу получить
[13:41.640 --> 14:05.120]  ее левостонно. Ага. И минус один пополам. В чем проблема? А, вот тут? Да, согласен. И минус один пополам.
[14:05.120 --> 14:32.480]  Здесь. Вот так. Ага. Right от и return 2 и плюс 2. Ну вот.
[14:32.480 --> 14:54.360]  Ну и давайте, наконец-то, напишем код для build. Значит, заведем массив t, размера,
[14:54.360 --> 15:16.560]  размера 2 модуля а-1, но предполагаю, что у меня размер массива это некоторая степень двойки.
[15:16.560 --> 15:26.800]  Если у меня массив длину 2 степеника, то мне нужна длина массива равная а плюс а-1.
[15:26.800 --> 15:35.720]  Если число листьев равно а, то общее количество внутренних вершин равно а-1. Ну и поехали, значит.
[15:35.720 --> 15:49.960]  Сначала заполняем нижний уровень. То есть for i, for 0, to модуль а-1. Что делаем? t от i плюс,
[15:49.960 --> 16:04.240]  смещение у нас равно а-1. Согласны? То есть, если я хочу проитерироваться по листьям,
[16:04.240 --> 16:09.120]  то я должен взять ну, взять нулевой элемент, первый элемент, второй, и так далее, но со смещением
[16:09.120 --> 16:28.720]  а-1. Вот. Это равно просто аи. Ну и далее for i, from. Теперь я хочу пойти вот так. Теперь я хочу
[16:28.720 --> 16:36.680]  пройтись по уровням отсюда влево, отсюда влево и так. Ну то есть взять вот этот элемент и
[16:36.680 --> 16:43.120]  пройтись по всем индексам, начиная от шестого по нулевой. Что я должен сделать? Я должен взять,
[16:43.120 --> 16:56.240]  точнее i, а-2 до нуля и сделать следующую вещь. t от i равно, давайте в общем случае напишем
[16:56.240 --> 17:03.240]  некоторая операция. Давайте операцию будем обозначать сразу вот таким символом. Вот таким
[17:03.240 --> 17:09.280]  символом я буду обозначать бинарную астативную операцию. Нужно тут сразу обозначить. Вот так.
[17:09.280 --> 17:24.240]  Значит это что будет? Это будет t от left от i, применение операции к t от right от i. Ну вот.
[17:24.240 --> 17:38.000]  Кажется так. Ну то есть создаем массив из 2-1 элемента. Дальше проходим по всем листям и
[17:38.000 --> 17:43.800]  заполняем его значениями массива. Дальше проходим по всем внутренним вершинам и заполняем их согласно
[17:43.800 --> 17:53.160]  вот такой формулой. Естественно построение как и затраты по памяти являются линейными.
[17:53.160 --> 18:09.480]  Ну хорошо, поняли как устроена эта структура данных, поняли как ее строить. Наверное до сих
[18:09.480 --> 18:25.240]  пор непонятно как устроить запросы к ней. Ну скажем мне нужно найти минимум или максимум на вот
[18:25.240 --> 18:38.040]  таком отрезке. На отрезке от сюда до сюда. Что я должен сделать? Давайте сначала идейно. Что должно
[18:38.040 --> 18:42.880]  произойти? Как посчитать сумму, максимум, минимум вот на таком на таком отрезке?
[18:42.880 --> 19:00.840]  Что разбить? 1, 2, 5, 4. Ну смотрите, если я буду смотреть на эти элементы все, то я потрачу линейное время.
[19:01.360 --> 19:10.640]  ну то есть да идея стей за том что вот это большой отрезок чьим-то образом разбить на
[19:10.640 --> 19:16.840]  узлы так чтобы этот отрезок был целиком покрыт. Ну то в данном случае что получается я должен
[19:16.840 --> 19:23.460]  взять вот эту вершину должен взять вот эту вершин, и должна взять вот эту вершину. Все таким образом
[19:23.460 --> 19:27.760]  смотрите один отвечает вот за этот подотрезок, пятерка отвечает вот за этот подотрезок,
[19:27.760 --> 19:33.760]  Четверка отвечает за этот подотрезок. Идея состоит в том, чтобы разбить
[19:33.760 --> 19:39.760]  отрезок запроса на какое-то количество не пересекающихся подотрезков.
[19:39.760 --> 19:45.760]  И вот сейчас мы понимаем, почему в случае деревоотрезков нам достаточно всего лишь ассоциативности.
[19:45.760 --> 19:49.760]  Нам нужна неидомпатентность, не обратимость. Почему?
[19:49.760 --> 19:54.760]  Потому что если мы разбиваем наш исходный отрезок запроса на несколько не пересекающих подотрезков,
[19:54.760 --> 19:58.760]  то нам не важна неидомпатентность, не обратимость. То есть мы просто собираем наш исходный ответ
[19:58.760 --> 20:04.760]  из нескольких различных подотрезков.
[20:04.760 --> 20:12.760]  Остается непонятный вопрос, сколько всего этих узлов может быть?
[20:12.760 --> 20:20.760]  То есть верно ли, что их всегда от единицы?
[20:20.760 --> 20:30.760]  Вообще говоря, можно придумать пример, когда у вас на каждом уровне дерева будет хотя бы по одной вершине, кроме последнего.
[20:30.760 --> 20:36.760]  Верно ли, что их всегда логарифмически? Верно ли, что их будет линейное количество?
[20:36.760 --> 20:42.760]  То есть верно ли, что существует такой отрезок, который разобьется потенциально на очень большое количество маленьких подотрезков?
[20:42.760 --> 20:48.760]  Давайте эти узлы, эти отрезки будем называть фундаментальными.
[20:48.760 --> 20:54.760]  Вот это фундаментальный узел.
[20:54.760 --> 21:00.760]  Ключевой вопрос в анализе этой самой структуры данных, этого самом деле отрезка,
[21:00.760 --> 21:04.760]  стоит в том, а сколько всего фундаментальных узлов нам понадобится для того, чтобы покрыть любой отрезок?
[21:04.760 --> 21:10.760]  Вот утверждение состоит в том, что нам всегда будет достаточно логарифмического числа фундаментальных узлов.
[21:10.760 --> 21:14.760]  Давайте это докажем.
[21:26.760 --> 21:36.760]  А для покрытия произвольного отрезка
[21:40.760 --> 21:48.760]  О от лога N фундаментальных узлов.
[21:48.760 --> 21:54.760]  А на каждом отрезке
[21:54.760 --> 22:00.760]  для покрытия всего отрезка достаточно
[22:00.760 --> 22:08.760]  О от лога N фундаментальных узлов.
[22:14.760 --> 22:18.760]  Рассуждения простые.
[22:18.760 --> 22:24.760]  Значит, покажем, что на каждом уровне
[22:30.760 --> 22:36.760]  не более двух фундаментальных узлов.
[22:40.760 --> 22:46.760]  Ну почему это так? От противного.
[22:46.760 --> 22:52.760]  Допустим, их больше брало, чем 3.
[22:52.760 --> 22:58.760]  Допустим, у меня есть какой-то отрезок, и получилось так, что на этом уровне я взял 3 фундаментальных узла.
[22:58.760 --> 23:04.760]  Что тогда?
[23:04.760 --> 23:10.760]  Давайте их рассмотрим.
[23:10.760 --> 23:18.760]  Вот есть какой-то узел, дальше идет какое-то количество узлов, дальше еще один узел, еще какое-то количество узлов, и последний узел.
[23:18.760 --> 23:24.760]  Давайте мы их синим цветом обозначаем.
[23:24.760 --> 23:30.760]  Есть 3 узла, между ними есть какое-то количество узлов.
[23:30.760 --> 23:36.760]  Может быть 0, может быть 1, неважно.
[23:36.760 --> 23:42.760]  Что мы знаем?
[23:42.760 --> 23:48.760]  Каждый из этих узлов отвечает за какой-то свой подотрезок.
[23:48.760 --> 23:56.760]  И все эти отрезки целиком лежат в отрезке, на котором мы вычисляем сейчас запрос.
[23:56.760 --> 24:02.760]  Давайте посмотрим на центральный элемент.
[24:14.760 --> 24:22.760]  Я обозначаю центральные в кавычках, потому что если их 4, то не понятно, какой центральный, если узлов 5.
[24:22.760 --> 24:28.760]  Это просто некоторый промежуточный, то есть не крайний.
[24:28.760 --> 24:34.760]  Что можно про него сказать? Так ли он нам сильно нужен?
[24:34.760 --> 24:40.760]  Можно ли от него как-то избавиться?
[24:40.760 --> 24:46.760]  Вообще говоря, неправда, мы не можем взять соседа.
[24:46.760 --> 24:52.760]  Вместо четверки мы не можем взять пятерку, двойку.
[24:52.760 --> 25:00.760]  Если мы берем соседа, то сосед отвечает за другой подотрезок.
[25:00.760 --> 25:06.760]  Поэтому на соседа заменить вот эту штуку нельзя.
[25:06.760 --> 25:12.760]  А на что ее можно заменить? На родителя.
[25:12.760 --> 25:20.760]  Согласно, что если я перейду в родителя, то я уберу вот эту вершину и возьму родителя.
[25:20.760 --> 25:26.760]  За какой отрезок мне отвечает родитель?
[25:26.760 --> 25:32.760]  За тот же самый плюс еще какой-то.
[25:32.760 --> 25:38.760]  То есть родитель покроет вот этот отрезок.
[25:38.760 --> 25:44.760]  А если я беру вот этот отрезок, то родитель покроет старый отрезок и плюс возьмет еще вот такой отрезок.
[25:44.760 --> 25:50.760]  Возникает вопрос, а вот этот отрезок не выйдет за границы всего запроса или нет?
[25:50.760 --> 25:56.760]  Давайте пока остановимся, давайте пока напишем.
[25:56.760 --> 26:06.760]  Посмотрим центральный элемент. Его можно заменить на родителя.
[26:06.760 --> 26:14.760]  Еще раз, почему его можно заменить на родителя?
[26:14.760 --> 26:20.760]  Потому что если я заменяю его на родителя, то, во-первых, он покрывает старый отрезок.
[26:20.760 --> 26:34.760]  Так как он покрывает старый отрезок.
[26:34.760 --> 26:40.760]  И хочется написать, что он не выходит за границы всего запроса.
[26:40.760 --> 26:46.760]  Почему это верно?
[26:46.760 --> 26:52.760]  Да, потому что этот элемент центральный и правее него есть еще какой-то узел.
[26:52.760 --> 27:00.760]  И вот этот узел, он, ну, короче, понятно, что если мы переходим в родители, то этот узел максимум, что можно сделать, он может покрыть и вот этот отрезок.
[27:00.760 --> 27:08.760]  Но он не выходит за границы. Он контролирует старый отрезок.
[27:08.760 --> 27:14.760]  Давайте здесь.
[27:14.760 --> 27:34.760]  И он не выходит за границы запроса.
[27:34.760 --> 27:58.760]  Так как у старого узла есть брат и слева, и справа.
[27:58.760 --> 28:10.760]  Вот. То есть таким образом мы получили, что если у меня в одном ряду находятся три фундаментальных узла, то я все центральные, то есть все некрайние, могу просто-напросто взять и заменить на их родителей.
[28:10.760 --> 28:18.760]  И хуже не станет.
[28:18.760 --> 28:24.760]  Если у меня получилось по какой-то причине, что я выбрал три листа в качестве фундаментальных, то я могу центрально из них свести к родителю.
[28:24.760 --> 28:30.760]  Дальше иду к верхнему уровню снова, смотрю, если у меня там больше либранов, чем три листа, то я просто свожу к родителям.
[28:30.760 --> 28:40.760]  Ну и так далее. И в итоге я могу отрезок целиком разбить на фундаментальные узлы так, что у меня на каждом уровне будет не более, чем два фундаментальных узла.
[28:40.760 --> 28:48.760]  Это значит, что я любой отрезок могу покрыть логарифмическим числом фундаментальных узлов.
[28:48.760 --> 29:02.760]  Что мы на текущий момент понимаем? Мы понимаем, что для того, чтобы покрыть произвольный отрезок, нам достаточно всего лишь логарифмического числа вот таких узлов.
[29:02.760 --> 29:06.760]  Проблема все еще остается, и она заключается в том, что непонятно, как их искать.
[29:06.760 --> 29:08.760]  Давайте попробуем разобраться.
[29:08.760 --> 29:14.760]  Первая стратегия, которую мы рассмотрим, это стратегия поиска снизу вверх.
[29:14.760 --> 29:25.760]  Возьмем какой-нибудь запрос, например, вот такой.
[29:25.760 --> 29:29.760]  Мне хочется найти максимум вот на таком подотрезке.
[29:29.760 --> 29:31.760]  Давайте сделаем следующую вещь.
[29:31.760 --> 29:36.760]  Я буду стартовать с границ этого отрезка.
[29:36.760 --> 29:39.760]  Возьму вот этот элемент и вот этот элемент.
[29:39.760 --> 29:45.760]  И буду потихоньку откусывать фундаментальные отрезки с этого края и с этого края.
[29:45.760 --> 29:47.760]  Каким образом я буду делать?
[29:47.760 --> 29:49.760]  Буду делать это жадным образом.
[29:49.760 --> 29:53.760]  Я буду смотреть сюда и буду думать, могу ли я перейти в родители или нет.
[29:53.760 --> 29:55.760]  Если я могу перейти в родители, то я буду переходить в родители.
[29:55.760 --> 29:58.760]  Если переход в родители даст мне какой-то плохой результат,
[29:58.760 --> 30:03.760]  то я возьму этот отрезок и перейду в данном случае чуть правее и выше.
[30:03.760 --> 30:06.760]  Ну, давайте пока чисто и дейно посмотрим, как это работает.
[30:06.760 --> 30:08.760]  Смотрите, я нахожусь здесь.
[30:08.760 --> 30:11.760]  Когда я нахожусь в вершине, я задаю себе следующий вопрос.
[30:11.760 --> 30:13.760]  Что мне выгоднее сделать?
[30:13.760 --> 30:15.760]  Мне выгоднее взять этот отрезок в качестве фундаментального,
[30:15.760 --> 30:17.760]  взять этот узел в качестве фундаментального,
[30:17.760 --> 30:19.760]  или подняться выше?
[30:19.760 --> 30:21.760]  Что мне тут стоит сделать?
[30:21.760 --> 30:23.760]  Подняться выше. А почему? Как вы это поняли?
[30:23.760 --> 30:27.760]  Потому что он правый ребенок.
[30:27.760 --> 30:30.760]  Да, потому что он является правым ребенком.
[30:30.760 --> 30:33.760]  И если я перейду чуть выше, то я, грубо говоря, поднимусь влево.
[30:33.760 --> 30:37.760]  То есть если я перейду в родители, то я покрою как этот отрезок, так и что-то слева.
[30:37.760 --> 30:39.760]  Согласны?
[30:39.760 --> 30:41.760]  Поэтому здесь действительно я перехожу сюда.
[30:41.760 --> 30:43.760]  Теперь смотрим здесь.
[30:43.760 --> 30:45.760]  Идем слева конца.
[30:45.760 --> 30:47.760]  Что мне тут выгоднее? Остаться или подняться выше?
[30:47.760 --> 30:50.760]  Остаться. Да, если я поднимусь выше, то что произойдет?
[30:50.760 --> 30:52.760]  Я захвачу что-то лишнее.
[30:52.760 --> 30:58.760]  Поэтому я остаюсь здесь и перехожу на уровень выше к элементу,
[30:58.760 --> 31:00.760]  который отвечает уже за следующий подотрезок.
[31:00.760 --> 31:02.760]  То есть вот этот отрезок я уже взял в качестве ответа.
[31:02.760 --> 31:04.760]  Эту часть меня не интересует.
[31:04.760 --> 31:08.760]  То есть я сдвигаю левую границу вот сюда и перехожу вот к этому элементу.
[31:08.760 --> 31:10.760]  То есть я всегда буду подниматься выше.
[31:10.760 --> 31:12.760]  Я нахожу здесь.
[31:12.760 --> 31:14.760]  Теперь смотрим сюда.
[31:14.760 --> 31:16.760]  Что мне выгоднее сделать?
[31:16.760 --> 31:18.760]  Остаться или подняться выше?
[31:18.760 --> 31:20.760]  Снова остаться. Почему?
[31:20.760 --> 31:22.760]  Потому что если я поднимусь выше, то что произойдет?
[31:22.760 --> 31:26.760]  Вот этот узел, он левый сын своего родителя.
[31:26.760 --> 31:28.760]  Так он левый сын своего родителя,
[31:28.760 --> 31:33.760]  то если я поднимусь выше, то вот этот узел верхний захватит какую-то правую часть.
[31:33.760 --> 31:37.760]  А правая часть у меня уже обработана.
[31:37.760 --> 31:42.760]  Считается, что либо она обработана, либо она меня не интересует.
[31:42.760 --> 31:46.760]  Грубо говоря, тот узел, в котором я нахожусь, он отвечает за самую правую границу,
[31:46.760 --> 31:48.760]  которая мне интересна.
[31:48.760 --> 31:50.760]  Если я поднимусь правее и выше, то я захвачу что-то лишнее.
[31:50.760 --> 31:55.760]  Поэтому я тут остаюсь и перехожу на уровень выше и лево.
[31:55.760 --> 31:57.760]  То есть вот этот узел.
[31:57.760 --> 32:01.760]  Вот этот следующий уровень и перехожу на левую часть.
[32:01.760 --> 32:03.760]  Так, слева я нахожусь здесь.
[32:03.760 --> 32:07.760]  Давайте прыжки вот так изображу.
[32:09.760 --> 32:11.760]  Я нахожусь здесь.
[32:11.760 --> 32:13.760]  Что мне тут нужно сделать?
[32:13.760 --> 32:16.760]  Тоже остаться. По той же самой причине. Почему?
[32:16.760 --> 32:20.760]  Этот узел мне отвечает за самую левую еще не рассмотренную границу.
[32:20.760 --> 32:22.760]  Если я поднимусь выше, то я поднимусь налево.
[32:22.760 --> 32:26.760]  А если я иду налево, то я захвачу ту часть, которая меня уже не интересует.
[32:26.760 --> 32:31.760]  Поэтому я остаюсь здесь и прыгаю на уровень выше и право.
[32:31.760 --> 32:33.760]  То есть вот сюда.
[32:35.760 --> 32:39.760]  Ну и все. У меня так получилось, что левая граница теперь находится правее, чем правая.
[32:39.760 --> 32:41.760]  На этом я завершаю работу.
[32:41.760 --> 32:44.760]  Границы у меня пересеклись. Весь отрезок я покрыл.
[32:44.760 --> 32:53.760]  Ну и действительно, если я рассмотрю эти отрезки, то у меня весь отрезок целиком разбивается вот на такие штуки.
[32:53.760 --> 32:55.760]  Идея понятна?
[32:55.760 --> 32:57.760]  То есть я просто иду с левого и правого конца.
[32:57.760 --> 33:00.760]  И если мне выгодно подняться в родители, то я поднимаюсь в родители.
[33:00.760 --> 33:06.760]  Если мне в родителя подниматься не выгодно, то я сохраняю эти фундаментальные узлы и поднимаюсь на уровень выше.
[33:06.760 --> 33:12.760]  Давайте изобразим это в виде некоторого кода.
[33:12.760 --> 33:14.760]  Так, значит, пункт называется
[33:21.760 --> 33:23.760]  реализация запроса
[33:30.760 --> 33:32.760]  снизу
[33:38.760 --> 33:41.760]  к Юри от L до R.
[33:42.760 --> 33:44.760]  Значит, первым делом я должен перейти к листям.
[33:44.760 --> 33:46.760]  То есть у меня как выглядит запрос?
[33:46.760 --> 33:51.760]  В данном случае у меня запрос выглядит как найти максимум на отрезке от единицы до...
[33:51.760 --> 33:53.760]  чего тут?
[33:53.760 --> 33:55.760]  До пятерки, да?
[33:55.760 --> 33:57.760]  1, 2, 3, 4, 5.
[33:57.760 --> 34:01.760]  То есть найти на отрезке от единицы до пятерки максимум.
[34:01.760 --> 34:03.760]  Но стартую я с листьев, да?
[34:03.760 --> 34:05.760]  Поэтому сначала я смещаю мои индексы до листьев.
[34:05.760 --> 34:07.760]  Ну как это делается?
[34:07.760 --> 34:10.760]  R плюс равно N минус 1.
[34:10.760 --> 34:13.760]  И R плюс равно N минус 1.
[34:13.760 --> 34:17.760]  То есть я оказываю в позицию номер 8.
[34:17.760 --> 34:20.760]  И здесь оказываюсь в позицию номер 12.
[34:20.760 --> 34:22.760]  Понятно?
[34:22.760 --> 34:24.760]  Вот.
[34:24.760 --> 34:26.760]  Ну а дальше цикл
[34:29.760 --> 34:31.760]  while L меньше, чем R.
[34:31.760 --> 34:34.760]  То есть пока у меня левая и правая границы не пересеклись,
[34:34.760 --> 34:37.760]  да, я делаю следующую вещь.
[34:37.760 --> 34:40.760]  Значит, для левой границы что я должен проверить?
[34:40.760 --> 34:44.760]  В каком случае я беру вот этот узел?
[34:44.760 --> 34:48.760]  Мы вспоминаем, что мы проверяли.
[34:48.760 --> 34:52.760]  Если он является правым сыном своего родителя,
[34:52.760 --> 34:54.760]  то мы должны этот отрезок взять.
[34:54.760 --> 34:59.760]  То есть мы пишем, если L является
[34:59.760 --> 35:04.760]  правым сыном своего родителя,
[35:04.760 --> 35:07.760]  right of parent от L.
[35:07.760 --> 35:08.760]  Ну так.
[35:08.760 --> 35:10.760]  Такая запись, понятно?
[35:10.760 --> 35:14.760]  Если L правый сын своего родителя,
[35:14.760 --> 35:18.760]  то давайте еще введем некоторые переменные.
[35:18.760 --> 35:22.760]  Тут буду хранить результат, который накапливается слева.
[35:22.760 --> 35:25.760]  Изначально он равен ничему.
[35:25.760 --> 35:28.760]  И результат, который мне будет накапливаться справа.
[35:29.760 --> 35:33.760]  Если так, то я должен взять вот этот узел в качестве ответа.
[35:33.760 --> 35:38.760]  Это означает, что я делаю left res,
[35:38.760 --> 35:42.760]  такая операция, plus равно.
[35:42.760 --> 35:45.760]  Давайте просто напишем равно.
[35:47.760 --> 35:53.760]  left res plus L.
[35:53.760 --> 36:01.760]  Ну и в итоге, куда мне должен L сместиться?
[36:01.760 --> 36:06.760]  Наверх и вправо.
[36:06.760 --> 36:09.760]  Если у меня L находится здесь,
[36:09.760 --> 36:11.760]  то я смещаюсь вот сюда.
[36:11.760 --> 36:14.760]  А если у меня L находился вот здесь,
[36:14.760 --> 36:16.760]  то куда бы я сместился?
[36:16.760 --> 36:20.760]  Ну тоже сюда.
[36:21.760 --> 36:24.760]  Короче говоря, формула выглядит следующим образом.
[36:24.760 --> 36:34.760]  В общем случае L равно parent от L плюс 1.
[36:34.760 --> 36:37.760]  Должно быть похоже на правду.
[36:37.760 --> 36:39.760]  Смотрите, если я нахожусь здесь,
[36:39.760 --> 36:41.760]  то я иду вправо-вобратно и поднимаюсь наверх.
[36:41.760 --> 36:42.760]  Попал.
[36:42.760 --> 36:44.760]  Если я нахожусь здесь, то мне тоже надо попасть сюда.
[36:44.760 --> 36:46.760]  То есть я иду вправо-вобратно и сюда.
[36:46.760 --> 36:48.760]  Кажется, все работает.
[36:48.760 --> 36:53.760]  Ну и аналогично мне нужно написать для правой границы.
[36:53.760 --> 37:00.760]  Если R равно уже левый сын своего родителя.
[37:04.760 --> 37:06.760]  Ну вот, что мы тут делали?
[37:06.760 --> 37:10.760]  Вот здесь мы что делали.
[37:10.760 --> 37:14.760]  Мы проверяли, если вот этот узел является левым сыном своего родителя,
[37:14.760 --> 37:17.760]  то есть если при подъеме наверх мы захватим что-то лишнее,
[37:17.760 --> 37:19.760]  мы тут останавливаемся и берем это в качестве ответа.
[37:19.760 --> 37:21.760]  Окей? Вот ровно это здесь написано.
[37:21.760 --> 37:36.760]  То мы пишем write res равно tr плюс write res.
[37:36.760 --> 37:38.760]  Ну и обновляем R.
[37:38.760 --> 37:44.760]  R равно parent.
[37:44.760 --> 37:47.760]  Ну по аналогии с вот этой формулой, что мы должны сделать?
[37:47.760 --> 37:51.760]  Да, мы должны перейти в лево брата и перейти в родителя.
[37:51.760 --> 37:55.760]  Parent от R-1.
[37:55.760 --> 38:03.760]  Все, на этом цикл заканчивается.
[38:03.760 --> 38:08.760]  Так, дальше оставьте место на одну строчку.
[38:08.760 --> 38:21.760]  И напишем return left res плюс write res.
[38:21.760 --> 38:25.760]  Вот, этот алгоритм почти работает.
[38:25.760 --> 38:27.760]  Он не работает в одном крайнем случае.
[38:27.760 --> 38:33.760]  Какой случай мы не рассмотрели?
[38:33.760 --> 38:37.760]  Да, смотрите, что произойдет, если у меня LRs впадут?
[38:37.760 --> 38:45.760]  Когда такое может быть вообще?
[38:45.760 --> 38:54.760]  Если возьмем отрезок 2, 3.
[38:54.760 --> 38:56.760]  Ну, например, да.
[38:56.760 --> 38:59.760]  Самый простой пример, это когда мы возьмем весь отрезок.
[38:59.760 --> 39:04.760]  Либо весь отрезок, либо просто какой-то отрезок, который в итоге сходится в одну точку.
[39:04.760 --> 39:07.760]  Понятно, мы в этом случае решили не брать этот отрезок в качестве фундаментального.
[39:07.760 --> 39:09.760]  И тут мы решили его не брать в качестве фундаментального.
[39:09.760 --> 39:14.760]  В итоге сошлись сюда, и в итоге в ответ ничего не записали.
[39:14.760 --> 39:17.760]  И вот в случае, если мы подаем какой-то общий отрезок,
[39:17.760 --> 39:21.760]  то это значит, что этот отрезок является хорошим как для левого сына, так и для правого сына.
[39:21.760 --> 39:23.760]  Поэтому мы должны его в итоге включить в ответ.
[39:23.760 --> 39:26.760]  Согласны?
[39:26.760 --> 39:31.760]  То есть тут дополнительно нужно опять проверить, что если в итоге оказалось так,
[39:31.760 --> 39:34.760]  что я попал в один общий узел,
[39:34.760 --> 39:41.760]  я должен, например, добавить что-то к левому ответу.
[39:41.760 --> 39:44.760]  Плюс равно t.
[39:44.760 --> 39:46.760]  Вот так.
[39:46.760 --> 39:49.760]  Вот, теперь кажется все.
[39:54.760 --> 39:56.760]  Давайте еще раз проговорим, что мы делаем.
[39:56.760 --> 39:59.760]  Мы берем левую границу и правую границу
[39:59.760 --> 40:02.760]  и сдвигаемся к соответствующим элементам в листьях.
[40:02.760 --> 40:04.760]  Дальше что мы делаем?
[40:04.760 --> 40:07.760]  Идем последовательно слева и справа, поднимаемся чуть выше.
[40:07.760 --> 40:09.760]  Значит, как мы это делаем?
[40:09.760 --> 40:11.760]  Смотрим сюда, если нам выгодно подняться в родителя,
[40:11.760 --> 40:13.760]  то мы просто поднимаемся в родителя.
[40:13.760 --> 40:15.760]  Вот эта строчка.
[40:15.760 --> 40:19.760]  Если мы понимаем, что при подъеме в родителя мы захватим что-то лишнее,
[40:19.760 --> 40:23.760]  то мы должны перед тем, как подняться выше, сохранить этот результат.
[40:23.760 --> 40:28.760]  То же самое мы делаем для правой границы.
[40:28.760 --> 40:33.760]  И повторяем все это до тех пор, пока у меня левая и правая границы не пересекутся.
[40:33.760 --> 40:37.760]  Если они пересеклись совсем, то есть вышли друг за друга, то я на этом заканчиваю работу.
[40:37.760 --> 40:39.760]  Если они в итоге сошлись к одному и тому же узлу,
[40:39.760 --> 40:43.760]  то это значит, что верхний узел отвечает как и за левую границу, так и за правую границу.
[40:43.760 --> 40:46.760]  Поэтому я просто его включаю в ответ.
[40:49.760 --> 40:51.760]  Так, точно вопросов нет.
[40:51.760 --> 40:53.760]  А вообще должен быть.
[40:53.760 --> 40:55.760]  И не один.
[40:55.760 --> 41:10.760]  Не смущает вас, например, вот это, вот это, ну и в принципе вот это.
[41:14.760 --> 41:16.760]  Ну какой нормальный человек будет так писать?
[41:16.760 --> 41:22.760]  Да, отлично. В общем, вопрос стоял в этом.
[41:22.760 --> 41:27.760]  Можно ли левт и райт заменить просто на рез?
[41:27.760 --> 41:32.760]  Ну казалось бы, мы же можем в одной общей переменной накапливать общий результат.
[41:32.760 --> 41:36.760]  Ну то есть неважно же, в каком порядке я считаю максимум, и так далее.
[41:36.760 --> 41:39.760]  Ну здесь я нарочно так сделал, потому что, вообще говоря,
[41:39.760 --> 41:44.760]  когда я давал определение деревоотресков, я не гарантировал коммунативность операции.
[41:44.760 --> 41:47.760]  И собственно здесь я некоммунативность сохранил.
[41:47.760 --> 41:51.760]  То есть я здесь отдельно накапливаю результат слева, то есть отдельно там левые подотрески,
[41:51.760 --> 41:54.760]  и отдельно накапливаю правые подотрески.
[41:54.760 --> 41:57.760]  И потом складываю их в нужном мне порядке.
[41:57.760 --> 41:59.760]  То есть заметьте, что я здесь тоже сохраню порядок.
[41:59.760 --> 42:03.760]  То есть сначала накопленный результат слева, и только потом добавляю TL.
[42:03.760 --> 42:09.760]  Здесь наоборот, беру отрезок, который слева, и добавляю к нему райтрес.
[42:09.760 --> 42:11.760]  Ну это все, чтобы не было проблем с коммунативностью.
[42:11.760 --> 42:14.760]  Вот если у вас операция коммунативная, она как правило коммунативна,
[42:14.760 --> 42:16.760]  там всякие суммы, минимум, максимумы,
[42:16.760 --> 42:20.760]  то можно просто накапливать одним минимумом и максимумом, и их проблем нет.
[42:25.760 --> 42:27.760]  Давайте поясним.
[42:27.760 --> 42:36.760]  Это для некоммунативных операций.
[42:36.760 --> 42:44.760]  Хорошо.
[42:44.760 --> 42:46.760]  Ну и отлично.
[42:46.760 --> 42:53.760]  Заметьте, что это построение, оно в точности работает по той теории,
[42:53.760 --> 42:56.760]  которую мы недавно доказали.
[42:56.760 --> 42:59.760]  А именно, мы на каждом уровне берем максимум два фундаментальных отрезка.
[42:59.760 --> 43:02.760]  Либо левый и правый.
[43:02.760 --> 43:04.760]  Кроме левого и правого мы ничего взять не можем.
[43:04.760 --> 43:06.760]  То есть мы protective агр Consulting какой-то bangs.
[43:06.760 --> 43:09.760]  Потому что имascal работает airplanes.
[43:09.760 --> 43:22.760]  Ониprofезид 103
[43:22.760 --> 43:24.760] Inspector код намет и нас pouvoir отказывать,
[43:24.760 --> 43:31.760]  а Dh Phys.
[43:31.760 --> 43:33.760]  Что мы на either front end и defense.
[43:33.760 --> 43:38.260]  Давайте попробуем понять, как выполнять обновления в данной структуре данных.
[43:38.260 --> 43:42.260]  Снова давайте сначала на примере.
[43:42.260 --> 43:48.260]  Давайте уберем.
[43:48.260 --> 43:54.260]  И попробуем что-нибудь пообновлять.
[43:54.260 --> 43:57.260]  Самое простое обновление – это обновление в точке.
[43:57.760 --> 44:05.760]  Представьте себе, что мне дан запрос – изменить вот этот 0 на 8.
[44:12.760 --> 44:18.760]  То есть изменить элемент в пятом индексе с 0 на 8.
[44:18.760 --> 44:22.760]  Как выполнять такое обновление?
[44:22.760 --> 44:26.760]  Да, на самом деле достаточно просто взять, пройтись по родителям и обновить их.
[44:27.260 --> 44:29.260]  Ну почему? Давайте просто просуждаем.
[44:29.260 --> 44:31.260]  Вот я изменил здесь 0 на 8.
[44:31.260 --> 44:34.260]  Кажется, что здесь понятно, что делать.
[44:34.260 --> 44:38.260]  Если мне сказали 0 изменить на 8, я просто пишу тут 8.
[44:38.260 --> 44:43.260]  Дальше. На какие элементы повлияла вот эта 8 вот на этом уровне?
[44:43.260 --> 44:47.260]  Значит, вот на этом уровне за вот эту 8 отвечает только вот этот узел.
[44:47.260 --> 44:49.260]  То есть вот эта 8 покрывает только этот узел.
[44:49.260 --> 44:55.260]  Поэтому я перехожу в родителя и беру максимум из нового значения и старого значения здесь.
[44:57.260 --> 45:00.260]  Нет, не так. Я беру максимум из левого сына и правого сына.
[45:00.260 --> 45:03.260]  То есть просто пересчитываю значение здесь.
[45:03.260 --> 45:05.260]  Вижу, что оно обновилось, ставлю сюда 8.
[45:05.260 --> 45:10.260]  Дальше. Какие узлы выше затронула вот эта 8?
[45:10.260 --> 45:12.260]  Ну только вот этот узел.
[45:12.260 --> 45:15.260]  Вот этому узлу вообще плевать, что там изменилось, потому что он отвечает за другой подотрезок.
[45:15.260 --> 45:18.260]  Поэтому идем сюда и изменяем тут 4 на 8.
[45:18.260 --> 45:21.260]  Почему 8? Потому что это максимум из вот этой 8 и вот этой 2.
[45:21.260 --> 45:24.260]  Вот этот узел в свою очередь повлиял только на корень.
[45:24.760 --> 45:26.760]  Здесь только корень на этом уровне.
[45:26.760 --> 45:28.760]  Ставим 8.
[45:28.760 --> 45:31.760]  То есть обновление в точке выглядит очень просто.
[45:31.760 --> 45:34.760]  Идем снизу вверх и обновляем все элементы.
[45:34.760 --> 45:36.760]  Ну давайте напишем что ли.
[45:54.760 --> 45:56.760]  Так, обновление в точке.
[46:07.760 --> 46:10.760]  Снизу вверх.
[46:14.760 --> 46:16.760]  Так, как мы это будем делать?
[46:17.260 --> 46:19.260]  Обновление в точке.
[46:21.260 --> 46:23.260]  Обновление и.
[46:25.260 --> 46:27.260]  В.
[46:29.260 --> 46:33.260]  Ну, во-первых, как обычно, берем индекс листа.
[46:33.260 --> 46:37.260]  Индекс листа получается просто как n-1.
[46:37.260 --> 46:40.260]  Ну где n? Это размер исходного массива.
[46:47.260 --> 46:52.260]  Вот. Ну и просто говорю t от i равно v.
[46:54.260 --> 46:56.260]  Вот.
[47:00.260 --> 47:04.260]  Ну и дальше просто соберу и в цикле поднимаюсь наверх.
[47:04.260 --> 47:06.260]  Значит while i.
[47:06.260 --> 47:08.260]  Ну как написать?
[47:08.260 --> 47:16.260]  Давайте напишу while i не равно root в скобочках ноль.
[47:16.760 --> 47:20.760]  То есть пока я не добрался до корня, я сделаю следующую вещь.
[47:20.760 --> 47:42.760]  i равно parent от i и t от i равно t left от i плюс t right от i.
[47:43.260 --> 47:45.260]  Вот.
[47:47.260 --> 47:49.260]  Ну, кажется, все.
[47:53.260 --> 47:55.260]  Давайте проверим, значит.
[47:55.260 --> 47:57.260]  Нахожусь в листе, обновляю лист.
[47:57.260 --> 48:01.260]  Дальше проверяю. Эту вершину у меня не корень, поэтому захожу внутрь цикла,
[48:01.260 --> 48:06.260]  поднимаюсь к родителю и беру максимум из левой и правой части.
[48:06.260 --> 48:08.260]  Дальше. Снова это не корень, поэтому поднимаюсь выше.
[48:08.260 --> 48:10.260]  Снова обновляю здесь.
[48:10.260 --> 48:12.260]  Это не корень, поднимаюсь выше, обновляю здесь.
[48:12.260 --> 48:14.260]  Это корень, выхожу из цикла.
[48:14.260 --> 48:16.260]  Ну все.
[48:16.260 --> 48:18.260]  Окей?
[48:18.260 --> 48:20.260]  Ну снова, что я тут делаю?
[48:20.260 --> 48:22.260]  Существенная часть заключается всего лишь в этом цикле.
[48:22.260 --> 48:24.260]  А в этом цикле я поднимаюсь от листа к корню.
[48:24.260 --> 48:27.260]  Ну естественно, так у меня дерево полное и бинарное,
[48:27.260 --> 48:32.260]  то это все занимает эту от log n.
[48:34.260 --> 48:36.260]  Что?
[48:37.260 --> 48:41.260]  Да, можно и такую оптимизацию устроить.
[48:41.260 --> 48:43.260]  Если вы понимаете, что вы поднимаетесь-поднимаетесь,
[48:43.260 --> 48:45.260]  и здесь у вас результат не обновился,
[48:45.260 --> 48:47.260]  то вы можете на этом просто брейкнуться и закончить цикл.
[48:47.260 --> 48:51.260]  Если у вас какой-то узел не изменился, то и выше тоже ничего не изменится.
[48:51.260 --> 48:53.260]  Можно так.
[48:53.260 --> 48:59.260]  Так или иначе, на астимптотику это особо не влияет.
[48:59.260 --> 49:08.260]  На этом базовая часть, которая относится к деревьям отрезков,
[49:08.260 --> 49:10.260]  я думаю, закончена.
[49:10.260 --> 49:14.260]  Что я подразумеваю под базовой частью?
[49:14.260 --> 49:20.260]  Базовая часть – это запрос, построение и обновление в точке.
[49:20.260 --> 49:23.260]  Теперь давайте двигаться дальше.
[49:23.260 --> 49:30.260]  И к чему мы будем стремиться сейчас?
[49:30.260 --> 49:32.260]  Мы уже умеем достаточно много.
[49:32.260 --> 49:35.260]  Мы умеем делать запрос, мы умеем выполнять обновление в точке.
[49:35.260 --> 49:39.260]  Вообще говоря, дерево отрезков – это гораздо более мощная структура данных,
[49:39.260 --> 49:42.260]  которая позволяет осуществлять не просто обновление в точке,
[49:42.260 --> 49:45.260]  но и позволяет обновлять целую группу элементов,
[49:45.260 --> 49:48.260]  причем тоже за логарифмическое время.
[49:48.260 --> 49:52.260]  И наша цель за оставшуюся пару – научиться этим всем трюкам.
[49:52.260 --> 49:55.260]  То есть как обновлять значение не только в одном элементе,
[49:55.260 --> 49:57.260]  но и сразу на группе элементов.
[49:57.260 --> 50:01.260]  При этом не важно для произвольной операции.
[50:01.260 --> 50:04.260]  Прежде чем мы перейдем к этой части,
[50:04.260 --> 50:07.260]  давайте рассмотрим некоторую другую реализацию,
[50:07.260 --> 50:11.260]  которая нам понадобится, а именно реализацию запроса сверху вниз.
[50:11.260 --> 50:16.260]  Давайте просто возьмем и немного этот запрос изменим.
[50:16.260 --> 50:20.260]  Сделаем это здесь.
[50:20.260 --> 50:24.260]  Попробуем придумать какую-то другую стратегию запроса,
[50:24.260 --> 50:28.260]  которая бы двигалась не от листьев в корню,
[50:28.260 --> 50:31.260]  а наоборот, от корню к листьям.
[50:31.260 --> 50:35.260]  Ну, снова давайте возьмем тот же самый отрезок,
[50:35.260 --> 50:39.260]  который мы брали до этого,
[50:41.260 --> 50:44.260]  и придумаем какую-то другую стратегию.
[50:44.260 --> 50:48.260]  Давайте изначально мы находимся в корне.
[50:48.260 --> 50:52.260]  Что делать? Жду предложений.
[51:04.260 --> 51:08.260]  А если сама вершина уже полностью все покрывает?
[51:08.260 --> 51:11.260]  Понятно, что давайте так.
[51:11.260 --> 51:13.260]  Я нахожусь в корне.
[51:13.260 --> 51:16.260]  Если меня попросили минимум или максимум на всем отрезке сразу,
[51:16.260 --> 51:18.260]  то я уже победил.
[51:18.260 --> 51:20.260]  Согласны?
[51:20.260 --> 51:24.260]  То есть у меня корень уже отвечает за весь подотрезок.
[51:24.260 --> 51:43.260]  Давайте как-то зафиксируем, что запрос сверху вниз.
[51:43.260 --> 51:45.260]  Идея.
[51:49.260 --> 51:54.260]  Двигаемся от корня.
[51:56.260 --> 52:09.260]  Если вершина целиком покрывает подотрезок,
[52:14.260 --> 52:20.260]  запроса, то заканчиваем.
[52:24.260 --> 52:27.260]  Ну, точнее, давайте так.
[52:27.260 --> 52:30.260]  То возвращаем ответ.
[52:34.260 --> 52:37.260]  Ответ из вершины.
[52:39.260 --> 52:40.260]  Это первый момент.
[52:40.260 --> 52:42.260]  Это первая и самая простая ситуация.
[52:42.260 --> 52:46.260]  Мы находимся в вершине, и мы, допустим, понимаем, что мы покрываем весь отрезок целиком.
[52:46.260 --> 52:49.260]  Все, тогда мы можем остановиться и сразу вернуть ответ.
[52:49.260 --> 52:52.260]  Здесь не такая ситуация, здесь другая ситуация.
[52:52.260 --> 52:57.260]  Здесь мы видим, что этот отрезок не покрывает этот отрезок целиком, а пересекает его.
[52:57.260 --> 53:01.260]  Что мы должны сделать в этом случае?
[53:01.260 --> 53:08.260]  Давайте просто возьмем и рекурсивно запустим все отлево сына и право сына.
[53:08.260 --> 53:12.260]  Вот этот отрезок, вот этот узел, он ничего сделать сам не может.
[53:12.260 --> 53:17.260]  Поэтому он просто делегирует свою работу левому сыну и правому сыну.
[53:17.260 --> 53:45.260]  Если есть пересечение, то рекурсивно отправляем запрос в левого и правого сына.
[53:45.260 --> 53:54.260]  В левого и правого сына.
[53:54.260 --> 53:58.260]  Ну, давайте так и сделаем.
[53:58.260 --> 54:03.260]  В корне мы ничего не можем сделать, поэтому отправляемся в левый сын и правый сын.
[54:03.260 --> 54:10.260]  Находимся здесь. Что мы тут понимаем?
[54:10.260 --> 54:15.260]  Нет, подождите, пока мы не смотрим правого сына, пока вот здесь.
[54:15.260 --> 54:18.260]  Здесь мы находимся во второй ситуации.
[54:18.260 --> 54:21.260]  Вот этот отрезок сам ничего решить не может.
[54:21.260 --> 54:24.260]  Поэтому мы рекурсивно запускаемся от левого сына и правого сына.
[54:24.260 --> 54:27.260]  Давайте пойдем влево. Что мы тут понимаем?
[54:27.260 --> 54:32.260]  То же самое, он как-то пересекается с нашим запросом, но при этом полость его не покрывает.
[54:32.260 --> 54:39.260]  Поэтому рекурсивно запускаемся влево и вправо, влево.
[54:39.260 --> 54:43.260]  Да, вот этот узел вообще не при делах. Он вообще не понимает, чего от него хотят.
[54:43.260 --> 54:46.260]  И вот это третья ситуация, которая может быть.
[54:46.260 --> 54:48.260]  То есть всего возможно три ситуации.
[54:48.260 --> 54:52.260]  Узел целиком понимает, что ему делать, то есть узел целиком отвечает за весь отрезок.
[54:52.260 --> 54:55.260]  Или какой-то подотрезок, поэтому он просто возвращает результат.
[54:55.260 --> 54:58.260]  Второй, он что-то понимает, но целиком решить задачу не может.
[54:58.260 --> 55:00.260]  Поэтому мы делегируем левому и правому.
[55:00.260 --> 55:04.260]  И наконец, третий, это отрезок вообще не при делах.
[55:04.260 --> 55:06.260]  Если он совсем не при делах, то что делаем?
[55:09.260 --> 55:11.260]  Да, ну просто возвращаем некоторый нейтральный элемент.
[55:11.260 --> 55:15.260]  То есть говорим, что мы ничего не знаем и возвращаем просто ноль или минусу бесконечности.
[55:15.260 --> 55:18.260]  Это последняя ситуация.
[55:18.260 --> 55:42.260]  То есть если узел не пересекается запросом, то возвращаем нейтральный элемент.
[55:42.260 --> 55:45.260]  Давайте его обозначать как-то так.
[55:45.260 --> 55:47.260]  Ну вот.
[55:47.260 --> 55:51.260]  То есть здесь мне вернулся сюда нейтральный элемент.
[55:51.260 --> 55:54.260]  Дальше идем вправо.
[55:54.260 --> 55:56.260]  А вот здесь как раз первая ситуация.
[55:56.260 --> 55:59.260]  То есть вот этот узел целиком лежит внутри запроса.
[55:59.260 --> 56:02.260]  Поэтому он может вернуть свой результат, то есть единицу.
[56:02.260 --> 56:07.260]  То есть он тройке сюда возвращает единицу.
[56:07.260 --> 56:09.260]  Здесь рекурсивный вызов закончился из тройки.
[56:09.260 --> 56:11.260]  Что получается?
[56:11.260 --> 56:14.260]  В тройку вернулся нейтральный элемент единица.
[56:14.260 --> 56:16.260]  Что возвращает тройка в качестве ответа?
[56:16.260 --> 56:18.260]  Единицу, да.
[56:18.260 --> 56:20.260]  Он просто агрегирует результат, получает единицу.
[56:20.260 --> 56:23.260]  Мы от семерки рекурсивно запустились вправо.
[56:23.260 --> 56:25.260]  Что тут происходит?
[56:25.260 --> 56:28.260]  Пятерка полностью лежит внутри запроса.
[56:28.260 --> 56:31.260]  Поэтому тут мы можем сразу вернуть пятерку.
[56:31.260 --> 56:34.260]  Все, семерка получила ответ от левого сына и правого сына.
[56:34.260 --> 56:35.260]  То есть это единица и пять.
[56:35.260 --> 56:37.260]  И что мы возвращаем в качестве ответа?
[56:37.260 --> 56:39.260]  Результат применения операции к единице и пятерке.
[56:39.260 --> 56:41.260]  Ну в данном случае пятерку.
[56:42.260 --> 56:45.260]  Дальше мы рекурсивно спустились сюда.
[56:45.260 --> 56:47.260]  Вот эта восьмерка не понимает, что ей делать,
[56:47.260 --> 56:51.260]  поэтому делегирует полномочия этому сыну и этому сыну.
[56:51.260 --> 56:53.260]  Вот.
[56:53.260 --> 56:56.260]  Этот сын не понимает, что делать.
[56:56.260 --> 56:58.260]  Вот его отрезок, за который он отвечает,
[56:58.260 --> 57:00.260]  вообще не пересекается запросом.
[57:00.260 --> 57:04.260]  Возвращаем пирожок с ничем.
[57:04.260 --> 57:06.260]  А здесь?
[57:07.260 --> 57:11.260]  Да, он полностью покрывает наш отрезок.
[57:11.260 --> 57:15.260]  Поэтому возвращаем восьмерку.
[57:15.260 --> 57:19.260]  Все, значит родитель получил результат от левого сына и правого сына.
[57:19.260 --> 57:20.260]  Это восемь и ничего.
[57:20.260 --> 57:23.260]  Поэтому возвращаем в итоге сюда восемь.
[57:23.260 --> 57:24.260]  Ну и все, корень получил ответ.
[57:24.260 --> 57:25.260]  Это пять и восемь.
[57:25.260 --> 57:27.260]  Ну соответственно общий ответ это восемь.
[57:27.260 --> 57:29.260]  Ну куда-нибудь.
[57:32.260 --> 57:34.260]  То есть это ритм рекурсивный.
[57:34.260 --> 57:36.260]  Понятно, да, как работает?
[57:36.260 --> 57:39.260]  Ну давайте напишем.
[57:39.260 --> 57:41.260]  Напишем, напишем.
[57:41.260 --> 57:44.260]  Ну вот вместо этого запроса.
[57:56.260 --> 57:59.260]  Реализацию запроса сверху.
[57:59.260 --> 58:02.260]  Здесь кьюри, вход.
[58:02.260 --> 58:05.260]  А вот тут интересно.
[58:05.260 --> 58:08.260]  Здесь будем поступать следующим образом.
[58:08.260 --> 58:12.260]  Помимо того, что будем хранить LR,
[58:12.260 --> 58:15.260]  давайте еще добавим несколько аргументов,
[58:15.260 --> 58:18.260]  а именно аргументы a,
[58:18.260 --> 58:22.260]  аргумент node и аргумент ab.
[58:25.260 --> 58:28.260]  Ну LR понятно, да, это граница запроса.
[58:28.260 --> 58:31.260]  node это текущий узел.
[58:37.260 --> 58:40.260]  ab это отрезок,
[58:46.260 --> 58:48.260]  за который
[58:50.260 --> 58:53.260]  отличает узел node.
[58:54.260 --> 58:56.260]  Понятно, да?
[58:56.260 --> 58:58.260]  То есть в данном случае у меня запрос
[58:58.260 --> 59:01.260]  на отрезке от единицы до
[59:01.260 --> 59:04.260]  два, три, четыре, пять, до пятерки.
[59:04.260 --> 59:06.260]  И скажем, если я нахожусь вот в этом узле,
[59:06.260 --> 59:08.260]  то этот узел отвечает за отрезок
[59:08.260 --> 59:10.260]  от нуля до трех.
[59:10.260 --> 59:13.260]  То есть ab у него 0,3.
[59:15.260 --> 59:18.260]  Ну давайте решать.
[59:18.260 --> 59:20.260]  В каких случаях мы точно знаем,
[59:20.260 --> 59:23.260]  что нам делать?
[59:23.260 --> 59:25.260]  Ну во-первых вот в этом случае,
[59:25.260 --> 59:28.260]  да?
[59:28.260 --> 59:30.260]  Давайте проверять.
[59:30.260 --> 59:32.260]  Значит, если
[59:32.260 --> 59:35.260]  отрезок ab
[59:35.260 --> 59:38.260]  целиком лежит в отрезке LR,
[59:40.260 --> 59:42.260]  то что в этом случае нужно делать?
[59:42.260 --> 59:44.260]  То есть если отрезок, за который отвечает node,
[59:44.260 --> 59:46.260]  целиком лежит внутри запроса,
[59:46.260 --> 59:49.260]  то просто возвращаем до ответа.
[59:49.260 --> 59:52.260]  То есть делаем return
[59:53.260 --> 59:56.260]  to node.
[59:56.260 --> 59:58.260]  Дальше.
[59:58.260 --> 01:00:00.260]  Второй случай, когда мы знаем, что делать,
[01:00:00.260 --> 01:00:02.260]  это случай, когда ab
[01:00:02.260 --> 01:00:04.260]  вообще не пересекается
[01:00:04.260 --> 01:00:07.260]  с отрезком LR.
[01:00:11.260 --> 01:00:13.260]  В этом случае мы просто возвращаем
[01:00:13.260 --> 01:00:15.260]  нейтральный элемент.
[01:00:15.260 --> 01:00:17.260]  Окей?
[01:00:17.260 --> 01:00:19.260]  Ну в данном случае там минус бесконечности,
[01:00:19.260 --> 01:00:21.260]  или в случае суммы ноль.
[01:00:21.260 --> 01:00:23.260]  Важно.
[01:00:23.260 --> 01:00:25.260]  Ну и наконец, самое интересное,
[01:00:25.260 --> 01:00:27.260]  что делать,
[01:00:27.260 --> 01:00:29.260]  если у меня все-таки пересечение есть.
[01:00:29.260 --> 01:00:31.260]  То есть если не вот это и не вот это,
[01:00:31.260 --> 01:00:33.260]  то это значит, что ab каким-то образом пересекается с LR.
[01:00:33.260 --> 01:00:35.260]  Но при этом ab целиком не лежит в LR.
[01:00:35.260 --> 01:00:37.260]  Что в этом случае мы делали?
[01:00:44.260 --> 01:00:46.260]  Да, просто рекурсивно спускались
[01:00:46.260 --> 01:00:48.260]  левостына и правостына,
[01:00:48.260 --> 01:00:50.260]  и соединяли их результаты.
[01:00:50.260 --> 01:00:52.260]  Итак, напишем
[01:00:52.260 --> 01:00:54.260]  левторез равно
[01:00:56.260 --> 01:00:58.260]  кьюри, от чего
[01:00:58.260 --> 01:01:00.260]  по-прежнему у нас интересует отрезок LR.
[01:01:00.260 --> 01:01:02.260]  В какой узел мы спускаемся?
[01:01:02.260 --> 01:01:04.260]  В левый.
[01:01:04.260 --> 01:01:06.260]  Да, то есть
[01:01:06.260 --> 01:01:08.260]  левтатноут.
[01:01:08.260 --> 01:01:10.260]  Дальше. За какой отрезок отвечает
[01:01:10.260 --> 01:01:12.260]  левтноут?
[01:01:12.260 --> 01:01:14.260]  Если узел отвечает за отрезок ab,
[01:01:14.260 --> 01:01:16.260]  то его левый сын отвечает за что?
[01:01:16.260 --> 01:01:18.260]  Левая граница остается a,
[01:01:18.260 --> 01:01:20.260]  а правая граница
[01:01:20.260 --> 01:01:22.260]  a плюс b пополам
[01:01:22.260 --> 01:01:24.260]  в целой части.
[01:01:24.260 --> 01:01:26.260]  Ну, в терминах интовой арифметики
[01:01:26.260 --> 01:01:28.260]  просто a плюс b пополам.
[01:01:32.260 --> 01:01:34.260]  Ну и аналогично получаем
[01:01:34.260 --> 01:01:36.260]  результат справа.
[01:01:36.260 --> 01:01:38.260]  Это просто запрос
[01:01:38.260 --> 01:01:40.260]  на том же отрезке LR
[01:01:40.260 --> 01:01:42.260]  от
[01:01:42.260 --> 01:01:44.260]  right node.
[01:01:44.260 --> 01:01:46.260]  Что у нас выступает в качестве левой границы
[01:01:46.260 --> 01:01:48.260]  у правого сына?
[01:01:50.260 --> 01:01:52.260]  Да, то есть вот эта штука,
[01:01:52.260 --> 01:01:54.260]  но плюс один.
[01:01:56.260 --> 01:01:58.260]  А плюс b пополам, целая часть, плюс один.
[01:01:58.260 --> 01:02:00.260]  А правая часть,
[01:02:00.260 --> 01:02:02.260]  правая граница, просто b.
[01:02:02.260 --> 01:02:04.260]  Все. И в качестве ответа
[01:02:06.260 --> 01:02:08.260]  ретерн, ну, результат операции, да.
[01:02:08.260 --> 01:02:10.260]  То есть
[01:02:10.260 --> 01:02:12.260]  левтрез,
[01:02:12.260 --> 01:02:14.260]  операция
[01:02:16.260 --> 01:02:18.260]  ретерн.
[01:02:18.260 --> 01:02:20.260]  Все.
[01:02:24.260 --> 01:02:26.260]  Вот. Ну, эта штука тоже работает
[01:02:26.260 --> 01:02:28.260]  за
[01:02:28.260 --> 01:02:30.260]  θ от логарифма.
[01:02:30.260 --> 01:02:32.260]  Ну, по какой причине? Ну, ровно под...
[01:02:32.260 --> 01:02:34.260]  Ну, собственно, это следует из теоремы, которую мы обсудили.
[01:02:34.260 --> 01:02:36.260]  Да, то есть если в какой-то момент, то есть если мы
[01:02:36.260 --> 01:02:38.260]  спускаемся вниз и понимаем, что у нас там
[01:02:38.260 --> 01:02:40.260]  возникает три узла, то есть, точнее так, на каждом уровне
[01:02:40.260 --> 01:02:42.260]  мы берем не более чем два узла.
[01:02:42.260 --> 01:02:44.260]  Вот. То есть мы спускаемся вниз, вниз, вниз,
[01:02:44.260 --> 01:02:46.260]  и общий размер рекурсии у нас не превосходит
[01:02:46.260 --> 01:02:48.260]  два логарифма Я.
[01:02:48.260 --> 01:02:50.260]  Вот.
[01:02:50.260 --> 01:02:52.260]  Ну, потому что если в какой-то момент мы попали
[01:02:52.260 --> 01:02:54.260]  в отрезок, который целиком
[01:02:54.260 --> 01:02:56.260]  покрывает какую-то часть
[01:02:56.260 --> 01:02:58.260]  нашего запроса, то мы сразу возвращаемся.
[01:02:58.260 --> 01:03:00.260]  То есть рекурсия растет не сильно.
[01:03:00.260 --> 01:03:02.260]  Вот.
[01:03:10.260 --> 01:03:12.260]  Да, смотрите, да.
[01:03:12.260 --> 01:03:14.260]  Именно это я хотел прокомментировать.
[01:03:14.260 --> 01:03:16.260]  Значит, смотрите, у нас есть теперь две стратегии.
[01:03:16.260 --> 01:03:18.260]  То есть либо выполнять запрос снизу-верх,
[01:03:18.260 --> 01:03:20.260]  либо выполнять запрос сверху-вниз.
[01:03:20.260 --> 01:03:22.260]  В каких случаях какой запрос выполнять?
[01:03:22.260 --> 01:03:24.260]  Значит, ответ такой.
[01:03:26.260 --> 01:03:28.260]  Вообще говоря, запрос,
[01:03:28.260 --> 01:03:30.260]  выполнение запроса снизу-верх, он чуть более эффективный.
[01:03:30.260 --> 01:03:32.260]  Почему? Потому что он не рекурсивный.
[01:03:32.260 --> 01:03:34.260]  То есть на рекурсию
[01:03:34.260 --> 01:03:36.260]  какая-то память уходит.
[01:03:36.260 --> 01:03:38.260]  Ну, потому что нужно
[01:03:38.260 --> 01:03:40.260]  сохранить контекст, нужно создавать
[01:03:40.260 --> 01:03:42.260]  локальные переменные, и так далее, и так далее.
[01:03:42.260 --> 01:03:44.260]  Вот.
[01:03:44.260 --> 01:03:46.260]  С другой стороны,
[01:03:46.260 --> 01:03:48.260]  вот эта реализация, она нам, как я уже анонсировал,
[01:03:48.260 --> 01:03:50.260]  она нам поможет решать
[01:03:50.260 --> 01:03:52.260]  задачи, которые связаны с обновлением на целых отрезках.
[01:03:52.260 --> 01:03:54.260]  Вот.
[01:03:54.260 --> 01:03:56.260]  Запросы снизу-верх
[01:03:56.260 --> 01:03:58.260]  такого делать не умеют.
[01:03:58.260 --> 01:04:00.260]  Поэтому если у вас задача есть, скажем, какое-то групповое обновление,
[01:04:00.260 --> 01:04:02.260]  скажем, нужно взять отрезок и обновить
[01:04:02.260 --> 01:04:04.260]  сразу что-то все на нем, то это, скорее всего, вам
[01:04:04.260 --> 01:04:06.260]  необходимо писать вот такую реализацию.
[01:04:06.260 --> 01:04:08.260]  Если вам достаточно обновлять всего лишь один элемент,
[01:04:08.260 --> 01:04:10.260]  то для эффективности лучше писать запросы
[01:04:10.260 --> 01:04:12.260]  снизу-верх.
[01:04:12.260 --> 01:04:14.260]  Значит, ну тут еще, наверное, стоит
[01:04:14.260 --> 01:04:16.260]  написать, а как, ну то есть
[01:04:16.260 --> 01:04:18.260]  нам же приходят запросы вида
[01:04:18.260 --> 01:04:20.260]  кьюери lr,
[01:04:20.260 --> 01:04:22.260]  да, то есть вообще говоря,
[01:04:22.260 --> 01:04:24.260]  пользователь не должен знать о том, что
[01:04:24.260 --> 01:04:26.260]  у нас есть какие-то вершины, у нас есть какие-то ab,
[01:04:26.260 --> 01:04:28.260]  но вот кьюери lr
[01:04:28.260 --> 01:04:30.260]  в данном случае просто-напросто равносильно
[01:04:32.260 --> 01:04:34.260]  кьюери от lr
[01:04:34.260 --> 01:04:36.260]  0
[01:04:38.260 --> 01:04:40.260]  0, n-1
[01:04:42.260 --> 01:04:44.260]  да, 0 это корень.
[01:04:44.260 --> 01:04:46.260]  Ну согласны, да, почему?
[01:04:46.260 --> 01:04:48.260]  Ну запрос от lr, начинаем
[01:04:48.260 --> 01:04:50.260]  мы с корня, и корень отвечает
[01:04:50.260 --> 01:04:52.260]  за весь отрезок целиком,
[01:04:52.260 --> 01:04:54.260]  то есть от 0 до n-1,
[01:04:54.260 --> 01:04:56.260]  где n имеет степень двойки,
[01:04:56.260 --> 01:04:58.260]  где n равна степени двойки.
[01:04:58.260 --> 01:05:00.260]  На этом давайте сделаем
[01:05:00.260 --> 01:05:02.260]  перерыв и дальше уже
[01:05:02.260 --> 01:05:04.260]  ворвемся в групповые обновления
[01:05:04.260 --> 01:05:06.260]  на отрезках.
[01:05:06.260 --> 01:05:08.260]  Переходим к главной цели
[01:05:08.260 --> 01:05:10.260]  на сегодня,
[01:05:10.260 --> 01:05:12.260]  а именно
[01:05:12.260 --> 01:05:14.260]  мы как бы хотим научиться
[01:05:14.260 --> 01:05:16.260]  выполнять групповые операции
[01:05:16.260 --> 01:05:18.260]  на целом отрезке.
[01:05:18.260 --> 01:05:20.260]  Скажем, что если мне
[01:05:20.260 --> 01:05:22.260]  хочется взять
[01:05:22.260 --> 01:05:24.260]  какой-то вот такой отрезок
[01:05:24.260 --> 01:05:26.260]  и на всем нём прибавить
[01:05:26.260 --> 01:05:28.260]  двойку.
[01:05:32.260 --> 01:05:34.260]  Понятно,
[01:05:34.260 --> 01:05:36.260]  что брутфорс алгоритм
[01:05:36.260 --> 01:05:38.260]  это просто нам пройтись по всем элементам,
[01:05:38.260 --> 01:05:40.260]  мы умеем обновлять каждый элемент
[01:05:40.260 --> 01:05:42.260]  по отдельности и там скажем
[01:05:42.260 --> 01:05:44.260]  снизу вверх каждый элемент пообновлять.
[01:05:44.260 --> 01:05:46.260]  Естественно, это всё будет работать
[01:05:46.260 --> 01:05:48.260]  за каллоген.
[01:05:48.260 --> 01:05:50.260]  Вопрос можно ли
[01:05:50.260 --> 01:05:52.260]  быстрее? И ответ
[01:05:52.260 --> 01:05:54.260]  оказывается, можно, и более того,
[01:05:54.260 --> 01:05:56.260]  это можно сделать
[01:05:56.260 --> 01:05:58.260]  за алгоритмическое время.
[01:05:58.260 --> 01:06:00.260]  Давайте сначала обсудим идею.
[01:06:00.260 --> 01:06:02.260]  Без записей просто
[01:06:02.260 --> 01:06:04.260]  как бы
[01:06:04.260 --> 01:06:06.260]  это могло быть устроено.
[01:06:06.260 --> 01:06:08.260]  Аналогия тут на самом деле вполне
[01:06:08.260 --> 01:06:10.260]  себе жизненная.
[01:06:10.260 --> 01:06:12.260]  Смотрите, давайте будем
[01:06:12.260 --> 01:06:14.260]  идея такая,
[01:06:14.260 --> 01:06:16.260]  когда мы выполняли запрос,
[01:06:16.260 --> 01:06:18.260]  мы вроде как брали наш отрезок целиком
[01:06:18.260 --> 01:06:20.260]  и разбивали его на некоторые
[01:06:20.260 --> 01:06:22.260]  фундаментальные отрезки и брали запросы от них.
[01:06:22.260 --> 01:06:24.260]  Вот здесь история такая же.
[01:06:24.260 --> 01:06:26.260]  Давайте просто возьмём этот отрезок,
[01:06:26.260 --> 01:06:28.260]  разобьём его на фундаментальные подотрезки
[01:06:28.260 --> 01:06:30.260]  и будем хранить обновление не
[01:06:30.260 --> 01:06:32.260]  в самих листях, а в фундаментальных
[01:06:32.260 --> 01:06:34.260]  подотрезках.
[01:06:34.260 --> 01:06:36.260]  Как мы это будем делать?
[01:06:36.260 --> 01:06:38.260]  Аналогия такая,
[01:06:38.260 --> 01:06:40.260]  смотрите,
[01:06:40.260 --> 01:06:42.260]  допустим, мне нужен запрос,
[01:06:42.260 --> 01:06:44.260]  давайте какой-нибудь,
[01:06:44.260 --> 01:06:46.260]  пусть здесь будет, отсюда
[01:06:46.260 --> 01:06:48.260]  с нулевого элемента по
[01:06:48.260 --> 01:06:50.260]  четвёртой на плюс
[01:06:50.260 --> 01:06:52.260]  два.
[01:06:52.260 --> 01:06:54.260]  Устроено всё как в бюрократе
[01:06:54.260 --> 01:06:56.260]  в какой-то абстрактной стране.
[01:06:56.260 --> 01:06:58.260]  Есть
[01:06:58.260 --> 01:07:00.260]  некоторые глава и некоторое министерство.
[01:07:00.260 --> 01:07:02.260]  И министерство
[01:07:02.260 --> 01:07:04.260]  дает поручение.
[01:07:04.260 --> 01:07:06.260]  Вот этим слоям населения
[01:07:06.260 --> 01:07:08.260]  нужно улучшить жизнь на плюс два.
[01:07:10.260 --> 01:07:12.260]  Что происходит?
[01:07:12.260 --> 01:07:14.260]  Министерство понимает,
[01:07:14.260 --> 01:07:16.260]  что задача улучшить жизнь вот этим чувакам,
[01:07:16.260 --> 01:07:18.260]  а вот этим не надо улучшать ничего.
[01:07:18.260 --> 01:07:20.260]  Просто так взять
[01:07:20.260 --> 01:07:22.260]  и пообещать, что у всех
[01:07:22.260 --> 01:07:24.260]  жизнь станет лучше на плюс два нельзя.
[01:07:24.260 --> 01:07:26.260]  Эти расстроятся.
[01:07:26.260 --> 01:07:28.260]  Поэтому мы сделаем проще.
[01:07:28.260 --> 01:07:30.260]  Это министерство
[01:07:30.260 --> 01:07:32.260]  говорит,
[01:07:32.260 --> 01:07:34.260]  это министерство поручает своим
[01:07:34.260 --> 01:07:36.260]  подконтрольным, подминистерством,
[01:07:36.260 --> 01:07:38.260]  вы разберитесь со своими людьми,
[01:07:38.260 --> 01:07:40.260]  вы разберитесь со своими людьми.
[01:07:40.260 --> 01:07:42.260]  Мы спускаем запрос на обновление
[01:07:42.260 --> 01:07:44.260]  сюда и сюда.
[01:07:44.260 --> 01:07:46.260]  Давайте спустимся сюда.
[01:07:46.260 --> 01:07:48.260]  Эти чуваки тоже не глупые, они понимают,
[01:07:48.260 --> 01:07:50.260]  что всем пообещать сразу плюс два мы не можем.
[01:07:50.260 --> 01:07:52.260]  Нас это и не просили.
[01:07:52.260 --> 01:07:54.260]  Нам просили улучшить жизнь только у этих чуваков.
[01:07:56.260 --> 01:07:58.260]  Поэтому
[01:07:58.260 --> 01:08:00.260]  этот узел понимает,
[01:08:00.260 --> 01:08:02.260]  что пообещать всем сразу он не может,
[01:08:02.260 --> 01:08:04.260]  поэтому мы просто делегируем полномочия
[01:08:04.260 --> 01:08:06.260]  сюда и сюда.
[01:08:06.260 --> 01:08:08.260]  Что делает этот чувак?
[01:08:08.260 --> 01:08:10.260]  Он понимает, что а я тут при чем вообще?
[01:08:10.260 --> 01:08:12.260]  Он попал под раздачу вообще ни за что.
[01:08:12.260 --> 01:08:14.260]  Говорят,
[01:08:14.260 --> 01:08:16.260]  что надо улучшить жизнь здесь,
[01:08:16.260 --> 01:08:18.260]  здесь ничего делать не надо, но он ничего и не делает.
[01:08:18.260 --> 01:08:20.260]  Заканчиваем работу.
[01:08:20.260 --> 01:08:22.260]  Что происходит здесь? Здесь то же самое,
[01:08:22.260 --> 01:08:24.260]  как и на верхних уровнях.
[01:08:24.260 --> 01:08:26.260]  Здесь ничего улучшать нельзя,
[01:08:26.260 --> 01:08:28.260]  улучшать не надо.
[01:08:28.260 --> 01:08:30.260]  Поэтому мы спускаем поручение сюда и сюда.
[01:08:30.260 --> 01:08:32.260]  Этот чувак совсем ни при чем.
[01:08:32.260 --> 01:08:34.260]  И здесь соответственно мы уже в конце концов
[01:08:34.260 --> 01:08:38.260]  можем сохранить значение плюс два.
[01:08:38.260 --> 01:08:40.260]  Что происходит здесь?
[01:08:40.260 --> 01:08:42.260]  А вот здесь происходит интересная вещь.
[01:08:42.260 --> 01:08:44.260]  Вот этот узел целиком отвечает
[01:08:44.260 --> 01:08:46.260]  зависеть от подотрезок целиком.
[01:08:46.260 --> 01:08:48.260]  Ему поручили,
[01:08:48.260 --> 01:08:50.260]  надо вот здесь улучшить
[01:08:50.260 --> 01:08:52.260]  что-то, улучшить жизнь на плюс две единицы.
[01:08:52.260 --> 01:08:54.260]  Но как бы спускать,
[01:08:54.260 --> 01:08:56.260]  выполнять поручение это долго,
[01:08:56.260 --> 01:08:58.260]  дорого и вообще говоря не хочется.
[01:08:58.260 --> 01:09:00.260]  Поэтому мы не будем улучшать жизнь,
[01:09:00.260 --> 01:09:02.260]  а мы пообещаем когда-нибудь улучшить жизнь.
[01:09:02.260 --> 01:09:04.260]  То есть сохраним здесь
[01:09:04.260 --> 01:09:06.260]  некоторое обещание на плюс два.
[01:09:06.260 --> 01:09:08.260]  И вот собственно вот такой схемой
[01:09:08.260 --> 01:09:10.260]  с обещаниями мы будем как бы реализовывать
[01:09:10.260 --> 01:09:12.260]  наши групповые подновления.
[01:09:16.260 --> 01:09:18.260]  Да, вот это следующий пункт.
[01:09:18.260 --> 01:09:20.260]  Значит как
[01:09:20.260 --> 01:09:22.260]  сохраняются обещания понятно.
[01:09:22.260 --> 01:09:24.260]  Теперь происходит момент
[01:09:24.260 --> 01:09:26.260]  написания отчетов.
[01:09:26.260 --> 01:09:28.260]  Вот этот чувак
[01:09:28.260 --> 01:09:30.260]  он поручил своим подчиненным
[01:09:30.260 --> 01:09:32.260]  улучшить жизнь здесь и здесь на плюс два.
[01:09:32.260 --> 01:09:34.260]  В качестве ответа
[01:09:34.260 --> 01:09:36.260]  они выдают некоторый ответ.
[01:09:36.260 --> 01:09:38.260]  Каково теперь
[01:09:38.260 --> 01:09:40.260]  благосостояние наших граждан?
[01:09:40.260 --> 01:09:42.260]  Что возвращает этот чувак?
[01:09:42.260 --> 01:09:44.260]  Там как было восемь, так и осталось восемь.
[01:09:44.260 --> 01:09:46.260]  Поэтому возвращает восемь.
[01:09:46.260 --> 01:09:48.260]  Ему ничего не поручали.
[01:09:48.260 --> 01:09:50.260]  Что возвращает здесь?
[01:09:50.260 --> 01:09:52.260]  Ему поручили улучшить на плюс два,
[01:09:52.260 --> 01:09:54.260]  тут раньше было четыре.
[01:09:54.260 --> 01:09:56.260]  Поэтому возвращаем шесть.
[01:09:56.260 --> 01:09:58.260]  Ну соответственно максимум из восьмерки шестерки
[01:09:58.260 --> 01:10:00.260]  остается восьмеркой.
[01:10:00.260 --> 01:10:02.260]  Здесь аналогично. Здесь возвращает двойку,
[01:10:02.260 --> 01:10:04.260]  так как тут ничего не изменилось.
[01:10:04.260 --> 01:10:06.260]  Тут тоже возвращается восьмерка, так ничего не изменилось.
[01:10:06.260 --> 01:10:08.260]  Соответственно тут сохраняется восьмерка.
[01:10:08.260 --> 01:10:10.260]  Теперь самое интересное здесь.
[01:10:10.260 --> 01:10:12.260]  Корень от своего правого сына
[01:10:12.260 --> 01:10:14.260]  получает ответ
[01:10:14.260 --> 01:10:16.260]  восемь.
[01:10:16.260 --> 01:10:18.260]  Возвращается ответ здесь.
[01:10:18.260 --> 01:10:20.260]  Он спрашивает, каково благосостояние граждан здесь?
[01:10:20.260 --> 01:10:22.260]  Вот этот чувак понимает, что реально семь.
[01:10:22.260 --> 01:10:24.260]  Но когда-то он пообещал плюс два.
[01:10:24.260 --> 01:10:26.260]  Поэтому тут возвращается девять.
[01:10:28.260 --> 01:10:30.260]  И соответственно здесь обновляется значение
[01:10:30.260 --> 01:10:32.260]  на девяти.
[01:10:34.260 --> 01:10:36.260]  В итоге получается вот такое дерево.
[01:10:36.260 --> 01:10:38.260]  Здесь хранятся какие-то значения.
[01:10:38.260 --> 01:10:40.260]  Плюс в каждом узле
[01:10:40.260 --> 01:10:42.260]  хранится некоторое обещание.
[01:10:42.260 --> 01:10:44.260]  Когда-нибудь там что-то сделать.
[01:10:46.260 --> 01:10:48.260]  Общая идея понятна.
[01:10:54.260 --> 01:10:56.260]  Это действительно правда.
[01:10:56.260 --> 01:10:58.260]  Почему? Потому что если мы посмотрим сюда,
[01:10:58.260 --> 01:11:00.260]  то мы этот отрезок взяли и разбили
[01:11:00.260 --> 01:11:02.260]  на фундаментальные подотрески.
[01:11:02.260 --> 01:11:04.260]  Поэтому мы раздали обещание
[01:11:04.260 --> 01:11:06.260]  ровно в фундаментальном количестве подотресков.
[01:11:06.260 --> 01:11:08.260]  Поэтому их всего грифмическое количество.
[01:11:12.260 --> 01:11:14.260]  Нет.
[01:11:14.260 --> 01:11:16.260]  Сейчас пока просто идея.
[01:11:16.260 --> 01:11:18.260]  Сейчас более формально все опишем.
[01:11:18.260 --> 01:11:20.260]  Пока все понятно, да?
[01:11:22.260 --> 01:11:24.260]  Теперь, формально.
[01:11:30.260 --> 01:11:32.260]  Пусть
[01:11:34.260 --> 01:11:36.260]  обновление
[01:11:36.260 --> 01:11:38.260]  происходит
[01:11:48.260 --> 01:11:50.260]  по некоторой.
[01:11:50.260 --> 01:11:52.260]  И вот теперь какая должна быть операция обновления?
[01:11:52.260 --> 01:11:54.260]  Операция должна быть
[01:11:54.260 --> 01:11:56.260]  ассоциативной
[01:12:00.260 --> 01:12:02.260]  и дистрибутивной
[01:12:02.260 --> 01:12:04.260]  по
[01:12:06.260 --> 01:12:08.260]  операции
[01:12:10.260 --> 01:12:12.260]  по операции запроса
[01:12:14.260 --> 01:12:16.260]  операции.
[01:12:16.260 --> 01:12:18.260]  Будем обозначать ее вот так.
[01:12:20.260 --> 01:12:22.260]  Что означает дистрибутивность?
[01:12:22.260 --> 01:12:24.260]  Дистрибутивность означает следующее.
[01:12:32.260 --> 01:12:34.260]  Если я к результату операции
[01:12:34.260 --> 01:12:36.260]  применяю обновление С,
[01:12:36.260 --> 01:12:38.260]  то это то же самое, как если бы я сначала применил
[01:12:38.260 --> 01:12:40.260]  обновление к А
[01:12:42.260 --> 01:12:44.260]  и обновление к В,
[01:12:44.260 --> 01:12:46.260]  а потом посчитал результат.
[01:12:52.260 --> 01:12:54.260]  Ну, в частности, понятное дело, что плюс
[01:12:54.260 --> 01:12:56.260]  дистрибутивен по максимуму.
[01:13:04.260 --> 01:13:06.260]  То есть, если я к максимуму
[01:13:06.260 --> 01:13:08.260]  от АВ
[01:13:08.260 --> 01:13:10.260]  прибавлю С,
[01:13:10.260 --> 01:13:12.260]  то это то же самое,
[01:13:12.260 --> 01:13:14.260]  что я возьму максимум
[01:13:14.260 --> 01:13:16.260]  из А
[01:13:16.260 --> 01:13:18.260]  плюс С
[01:13:18.260 --> 01:13:20.260]  и
[01:13:20.260 --> 01:13:22.260]  В плюс С.
[01:13:22.260 --> 01:13:24.260]  Для такой операции это верно.
[01:13:26.260 --> 01:13:28.260]  Соответственно,
[01:13:28.260 --> 01:13:30.260]  операция умножения
[01:13:34.260 --> 01:13:36.260]  дистрибутивна по сложению.
[01:13:36.260 --> 01:13:38.260]  То есть, если у вас в качестве операции
[01:13:38.260 --> 01:13:40.260]  в дереве отрезка выступает сложение,
[01:13:40.260 --> 01:13:42.260]  то вы можете
[01:13:42.260 --> 01:13:44.260]  выполнять умножение на отрезке.
[01:13:48.260 --> 01:13:50.260]  В общем случае, эта штука
[01:13:50.260 --> 01:13:52.260]  работает для дистрибутивных операций.
[01:13:52.260 --> 01:13:54.260]  Что делать, если операция не дистрибутивна,
[01:13:54.260 --> 01:13:56.260]  мы обсудим чуть позже.
[01:13:56.260 --> 01:13:58.260]  Короче, так или иначе,
[01:13:58.260 --> 01:14:00.260]  вся задача сводится к тому,
[01:14:00.260 --> 01:14:02.260]  чтобы из недистрибутивной операции сделать дистрибутивную операцию.
[01:14:02.260 --> 01:14:04.260]  Но это поговорим отдельно.
[01:14:04.260 --> 01:14:06.260]  Давайте пока считать, что мы работаем с максимумами
[01:14:06.260 --> 01:14:08.260]  и в качестве операции мы прибавляем
[01:14:08.260 --> 01:14:10.260]  элементы на отрезках.
[01:14:12.260 --> 01:14:14.260]  Дальше продолжим описание
[01:14:14.260 --> 01:14:16.260]  того, что хотим сделать.
[01:14:20.260 --> 01:14:22.260]  Теперь в каждом узле дерева,
[01:14:22.260 --> 01:14:24.260]  помимо того, что будем хранить одно значение,
[01:14:24.260 --> 01:14:26.260]  результат операции,
[01:14:26.260 --> 01:14:28.260]  мы будем хранить еще дополнительное поле,
[01:14:28.260 --> 01:14:30.260]  которое мы так и будем называть промис.
[01:14:30.260 --> 01:14:32.260]  В вершине
[01:14:40.260 --> 01:14:42.260]  будем хранить
[01:14:42.260 --> 01:14:57.260]  будем хранить поля, ну давайте как назовем? Дайте value.
[01:14:57.260 --> 01:15:18.260]  Результат операции на отрезке без учета обещания.
[01:15:18.260 --> 01:15:46.260]  Без учета обещания. Будем хранить поля value и поля promise. Отложенное обновление.
[01:15:46.260 --> 01:15:54.260]  В частности, вот здесь, что означает 7 и плюс 2? Это означает, что сейчас результат
[01:15:54.260 --> 01:16:02.260]  операции тут 7, но с учетом обновления 7 плюс 2, 9. То же самое здесь.
[01:16:02.260 --> 01:16:12.260]  С учетом обновления без учета обновления 4, с учета обновления 4 плюс 2, 6.
[01:16:12.260 --> 01:16:25.260]  Такие дела. Мы научились давать обещания. Мы попали вот в этот узел,
[01:16:25.260 --> 01:16:29.260]  этот узел обещает когда-нибудь выполнить обновление на плюс 2.
[01:16:29.260 --> 01:16:35.260]  Но когда-нибудь обещание все-таки нужно выполнять. Поэтому давайте научимся выполнять обещание.
[01:16:35.260 --> 01:16:41.260]  Выполнять обещание будем с помощью специальной операции, которую назовем push.
[01:16:41.260 --> 01:17:00.260]  Вывалкивание. Пушноут. Выполнение. Обе. Обещание.
[01:17:00.260 --> 01:17:05.260]  Вопрос. Как выполнить обещание? То есть я нахожусь здесь. И в какой-то момент
[01:17:05.260 --> 01:17:23.260]  к этому в этот узел стучат и говорят, давай выполняй обещание. Что он должен сделать?
[01:17:23.260 --> 01:17:37.260]  То есть мы должны обновить свой value. Давайте напишем так. Умножить равно на denote.promise.
[01:17:37.260 --> 01:17:43.260]  Ага. То есть выполнение обещания стоит в том, что мы тут обновляем значение на то,
[01:17:43.260 --> 01:17:51.260]  которое реально тут должно быть. Это 9. Так, что дальше мы делаем? Да, то есть смотрите,
[01:17:51.260 --> 01:17:57.260]  мы вроде как выполнили обещание. И вот это обещание мы должны спустить к детям.
[01:17:57.260 --> 01:18:07.260]  Это плюс двойку. Мы должны спустить сюда и сюда. Дети же ничего об обещаниях не знали до этого.
[01:18:07.260 --> 01:18:13.260]  Выполнение обещания стоит в том, что мы говорим, что у вас на самом деле должно быть плюс два.
[01:18:13.260 --> 01:18:19.260]  Соответственно эту информацию мы до них и доносим. Понятно? То есть вот до того, как мы не начали
[01:18:19.260 --> 01:18:25.260]  выполнять обещание здесь, вот эти дети ничего про плюс два не знали. Как только мы начинаем
[01:18:25.260 --> 01:18:30.260]  выполнять обещание, мы спускаем это обещание к детям. Окей, да?
[01:18:30.260 --> 01:18:53.260]  Поэтому что мы делаем? Мы говорим tLeft от node.promise умножить равно tNode от promise.
[01:18:53.260 --> 01:18:59.260]  То есть обновляем обещание в левом сцене и в правом сцене.
[01:18:59.260 --> 01:19:16.260]  tLeft от node.promise умножить равно tNode от promise.
[01:19:16.260 --> 01:19:28.260]  Ой, да, tLeft. А, нет, все нормально, все нормально, да.
[01:19:28.260 --> 01:19:33.260]  Да, давайте сначала с этим разберемся. Значит, что мы сделали? Мы обновили значение в узле,
[01:19:33.260 --> 01:19:38.260]  обновили обещание в левом сцене и правом сцене. Ну и после того, как мы обещание выполнили,
[01:19:38.260 --> 01:19:43.260]  что мы делаем? Ну, забываем про это обещание. Все, обещать больше нечего.
[01:19:43.260 --> 01:19:55.260]  Поэтому мы говорим в конце tNode.promise равно какой-то нейтральный элемент.
[01:19:55.260 --> 01:19:59.260]  Ну, там некоторые значения, которые говорят о том, что никакого обещания на самом деле нет.
[01:19:59.260 --> 01:20:13.260]  Ну, в случае сложения это ноль. Вот. Вот и все. Работает за единицу.
[01:20:13.260 --> 01:20:21.260]  Ну, тут просто четыре альфантические операции, да?
[01:20:21.260 --> 01:20:25.260]  Окей.
[01:20:29.260 --> 01:20:35.260]  Не-не-не, вот этот push он просто выполняет обещание в одном узле node.
[01:20:35.260 --> 01:20:43.260]  То есть мы говорим, что нужно выполнить обещание здесь, все, он выполняет обещание.
[01:20:43.260 --> 01:20:55.260]  Так, давайте теперь напишем запрос на отрезке, но уже с учетом обещаний.
[01:20:55.260 --> 01:21:03.260]  Давайте теперь посмотрим, как дружат вот эти обещания с запросами на отрезках.
[01:21:03.260 --> 01:21:09.260]  Давайте рассмотрим вот такую конфигурацию, которая у нас получилась.
[01:21:09.260 --> 01:21:15.260]  Вот такое дерево отрезков, тут есть обещание на плюс два, тут есть обещание на плюс два, и тут есть обещание на плюс два.
[01:21:15.260 --> 01:21:23.260]  Ну и давайте сделаем какой-нибудь запрос интересный.
[01:21:23.260 --> 01:21:29.260]  Давайте запрос на таком отрезке.
[01:21:29.260 --> 01:21:37.260]  Значит, вопрос сразу такой. Все ли понимают, что выполнять запрос снизу вверх нам нельзя теперь?
[01:21:37.260 --> 01:21:41.260]  Почему? Потому что про обещание знают только родители.
[01:21:41.260 --> 01:21:43.260]  То есть как у нас? У нас обещание спускается сверху вниз.
[01:21:43.260 --> 01:21:47.260]  Если мы будем выполнять запросы снизу вверх, то дети, возможно, о каких-то обещаниях не знают.
[01:21:47.260 --> 01:21:51.260]  Поэтому, смотрите, вот тут в детях хранятся ложные значения.
[01:21:51.260 --> 01:21:53.260]  Вот тут, вот тут, окей?
[01:21:53.260 --> 01:21:59.260]  Поэтому, чтобы обещания сверху вниз все-таки дошли до детей, нам нужно выполнять запрос сверху вниз.
[01:21:59.260 --> 01:22:09.260]  Давайте обновим, но заодно вспомним, выполнение запроса сверху вниз.
[01:22:09.260 --> 01:22:13.260]  Ну, на самом деле, там придется исправить всего лишь пару строк.
[01:22:13.260 --> 01:22:17.260]  Поэтому, не знаю, можете заново писать, можете просто как-то исправить.
[01:22:17.260 --> 01:22:37.260]  Значит, запрос сверху вниз с учетом обещаний.
[01:22:37.260 --> 01:22:41.260]  Что мы делаем?
[01:22:41.260 --> 01:22:47.260]  Как ранее, мы находимся здесь, то есть стартуем с корня.
[01:22:47.260 --> 01:22:49.260]  Что происходит далее?
[01:22:49.260 --> 01:22:55.260]  Этот корень отвечает за весь отрезок целиком, и этот отрезок целиком пересекается с нашим запросом.
[01:22:55.260 --> 01:23:01.260]  Поэтому мы рекурсивно запускаемся от левого сына и рекурсивно запускаемся от правого сына.
[01:23:01.260 --> 01:23:05.260]  Ну, давайте пойдем с правого сына.
[01:23:05.260 --> 01:23:08.260]  Значит, правого сына рекурсивно запускаются от левого.
[01:23:08.260 --> 01:23:14.260]  И правого, в правом все заканчивается, ну вот возвращается ничего.
[01:23:14.260 --> 01:23:18.260]  Дальше, восьмерка, восьмерка рекурсивно запускается от вот этого элемента.
[01:23:18.260 --> 01:23:24.260]  Значит, этот элемент ни за что не отвечает.
[01:23:24.260 --> 01:23:28.260]  Этот элемент целиком лежит внутри запроса, поэтому что он должен вернуть?
[01:23:28.260 --> 01:23:30.260]  Он должен вернуть 4 뭐-то.
[01:23:30.260 --> 01:23:34.260]  он целиком покрывает некоторый подотрезок, то, что в нём хранится.
[01:23:34.260 --> 01:23:40.260]  В нём хранится текущее обещание, точнее, в нём хранится текущее значение и, соответственно, обещание.
[01:23:40.260 --> 01:23:45.260]  Поэтому общий результат – это текущее значение плюс некоторое обещание, которое было дано до этого.
[01:23:46.260 --> 01:23:50.260]  Давайте это и напишем.
[01:23:50.260 --> 01:23:53.260]  Как и ранее.
[01:23:53.260 --> 01:23:59.260]  Q или L, R, node, A, B.
[01:23:59.260 --> 01:24:04.260]  Напомню, что есть вершина node.
[01:24:04.260 --> 01:24:10.260]  Она отвечает за отрезок от A до B, и общий запрос – это L, R.
[01:24:10.260 --> 01:24:13.260]  Ну, как-то так.
[01:24:13.260 --> 01:24:21.260]  Мы говорим, что если отрезок A, B целиком лежит в L, R,
[01:24:21.260 --> 01:24:31.260]  то делаем return t-node.value,
[01:24:31.260 --> 01:24:40.260]  обновлённое на t-node.promise.
[01:24:40.260 --> 01:24:45.260]  То есть, по сравнению с обычным запросом сверху-вниз,
[01:24:45.260 --> 01:24:54.260]  у нас добавился вот этот суффикс.
[01:24:54.260 --> 01:24:57.260]  Ещё один момент.
[01:24:57.260 --> 01:25:02.260]  Если A, B вообще не пересекается с L, R,
[01:25:02.260 --> 01:25:08.260]  то только как и ранее мы просто возвращаем ничего.
[01:25:08.260 --> 01:25:13.260]  А вот теперь интересно.
[01:25:13.260 --> 01:25:21.260]  Мы спустились сюда, передали запрос сюда, и передали запрос сюда.
[01:25:21.260 --> 01:25:24.260]  Смотрим здесь.
[01:25:24.260 --> 01:25:27.260]  Мы хотим выполнить запрос вот на этом узле.
[01:25:27.260 --> 01:25:30.260]  Что мы должны сделать?
[01:25:30.260 --> 01:25:35.260]  Как и ранее, вот этот узел некоторым образом пересекается с отрезком запроса,
[01:25:35.260 --> 01:25:37.260]  но не покрывает его целиком.
[01:25:37.260 --> 01:25:40.260]  Поэтому мы снова должны рекурсивно запуститься от левой части и от правой части.
[01:25:40.260 --> 01:25:42.260]  Согласны?
[01:25:42.260 --> 01:25:46.260]  Но есть проблема. Какая?
[01:25:46.260 --> 01:25:53.260]  Почему я не могу просто взять и рекурсивно, как и раньше, запуститься от левой части и правой части?
[01:25:53.260 --> 01:25:55.260]  Да, потому что надо сначала спустить обещание.
[01:25:55.260 --> 01:25:59.260]  Смотрите, я нахожусь здесь.
[01:25:59.260 --> 01:26:02.260]  И я делегирую запрос левому сыну и правому сыну.
[01:26:02.260 --> 01:26:06.260]  Но левый сын и правый сын вообще ничего не знают об обещаниях.
[01:26:06.260 --> 01:26:08.260]  Согласны?
[01:26:08.260 --> 01:26:12.260]  Но раз они ничего не знают об обещаниях, то это значит, что прежде чем спускать запрос ниже,
[01:26:12.260 --> 01:26:16.260]  нужно сказать, оказывается, было до этого какое-то обещание.
[01:26:16.260 --> 01:26:22.260]  Как раз таки push выполняется в момент, когда мы спускаем запрос с верхнего элемента к нижнему элементу.
[01:26:22.260 --> 01:26:27.260]  Как раз таки это тот момент, когда нас приперли к стенке и говорят, выполняй запрос.
[01:26:27.260 --> 01:26:29.260]  Что у вас на самом деле там происходит?
[01:26:29.260 --> 01:26:37.260]  Когда приходит какая-то проверка и так далее, в этот момент начинают выполняться все обещания и тому подобное.
[01:26:37.260 --> 01:26:45.260]  То есть, если у меня AB не целиком лежит в LR, и AB не пересекается с LR,
[01:26:45.260 --> 01:26:50.260]  то это значит, что AB пересекается с LR, и это означает, что мне нужно спустить запрос в левый сын и правый сына.
[01:26:50.260 --> 01:26:54.260]  Прежде чем спускать запрос в левый сын и правый сына, как мы обсудили, нужно спустить обещание вниз.
[01:26:54.260 --> 01:26:56.260]  Ну, ровно это и сделаем.
[01:26:56.260 --> 01:27:00.260]  Пишем push node.
[01:27:00.260 --> 01:27:03.260]  И вот push как раз пригодился здесь.
[01:27:03.260 --> 01:27:08.260]  То есть, прежде чем мы начинаем делегировать запрос в левый сын и правого сына,
[01:27:08.260 --> 01:27:12.260]  мы сначала спускаем им обещание, то есть делаем push.
[01:27:12.260 --> 01:27:17.260]  Вот.
[01:27:17.260 --> 01:27:21.260]  Ну а далее все просто. Ну а далее как и раньше?
[01:27:21.260 --> 01:27:25.260]  Далее как и раньше.
[01:27:25.260 --> 01:27:31.260]  Ну да, да, да.
[01:27:31.260 --> 01:27:37.260]  Там LR равно бла-бла-блан, то есть то, что было раньше.
[01:27:37.260 --> 01:27:42.260]  LR равно то, что было раньше.
[01:27:42.260 --> 01:27:54.260]  Ну и делаем return LR плюс LR.
[01:27:54.260 --> 01:27:58.260]  Вот.
[01:27:58.260 --> 01:28:02.260]  То есть вот обновили две строчки.
[01:28:02.260 --> 01:28:07.260]  Вот это и вот это.
[01:28:07.260 --> 01:28:12.260]  Задайте какой-нибудь вопрос.
[01:28:12.260 --> 01:28:17.260]  Почему?
[01:28:17.260 --> 01:28:22.260]  Ну, обновление мы еще не написали, но обновление тоже будет выполнено за log n.
[01:28:22.260 --> 01:28:26.260]  Ну опять же, в чем идея обновления на отрезке?
[01:28:26.260 --> 01:28:32.260]  Наш исходный отрезок разбиваем на фундаментальные подотрески и в них записываем обещание.
[01:28:32.260 --> 01:28:38.260]  То есть мы также будем спускаться сверху вниз и записывать обещание при необходимости.
[01:28:38.260 --> 01:28:41.260]  Ну давайте еще раз проговорю.
[01:28:41.260 --> 01:28:46.260]  Значит, если у меня отрезок, за который отвечает узел, целиком лежит в запросе,
[01:28:46.260 --> 01:28:48.260]  то я сразу могу вернуть ответ.
[01:28:48.260 --> 01:28:54.260]  Ответ теперь у меня состоит из текущего значения в узле плюс обещание, которое я должен был выполнить.
[01:28:54.260 --> 01:28:58.260]  Теперь, если у меня отрезок AB вообще не пересекается с отрезком LR,
[01:28:58.260 --> 01:29:04.260]  то есть отрезок AB вообще не имеет никаких общих точек с отрезком LR, то я просто возвращаю ничего.
[01:29:04.260 --> 01:29:09.260]  Ну и в случае, если у меня отрезок AB пересекается с отрезком R,
[01:29:09.260 --> 01:29:12.260]  то я должен делегировать, как и раньше, полномочия левому сыну и правому сыну,
[01:29:12.260 --> 01:29:17.260]  но перед этим я должен сообщить им о том, что до этого были какие-то обещания.
[01:29:17.260 --> 01:29:21.260]  Вот как здесь.
[01:29:21.260 --> 01:29:25.260]  Прежде чем спуститься в единицу, я должен был в единицу, ну давайте до конца проведем.
[01:29:25.260 --> 01:29:30.260]  Значит, тут плюс два убирается, теперь тут есть обещание на плюс два, и тут есть обещание на плюс два.
[01:29:30.260 --> 01:29:34.260]  Все, я спустил это обещание в единицу, и теперь, когда я буду спрашивать значение у единицы,
[01:29:34.260 --> 01:29:40.260]  единица мне вернет что? Она мне вернет тройку.
[01:29:40.260 --> 01:29:44.260]  Потому что единица теперь знает про свое обещание.
[01:29:44.260 --> 01:29:47.260]  Значит, единица вернула тройку, тут вернулось ничего,
[01:29:47.260 --> 01:29:51.260]  значит, теперь тут вернулась тройка,
[01:29:51.260 --> 01:29:55.260]  значит, я спустил запрос сюда, вот этот отрезок целиком лежит внутри запроса,
[01:29:55.260 --> 01:30:00.260]  то есть тут пять, и плюс еще было обещание на плюс два, поэтому возвращается семь.
[01:30:00.260 --> 01:30:06.260]  Значит, отсюда вернулось три, вернулось семь, берем максимум, возвращается семь.
[01:30:06.260 --> 01:30:13.260]  Ну и здесь четыре плюс два, шесть, соответственно шесть, соответственно шесть, все.
[01:30:13.260 --> 01:30:18.260]  Общий ответ семь. Похоже на правду? Ну да.
[01:30:18.260 --> 01:30:24.260]  То есть вот у меня был исходный отрезок, один, два, пять, четыре, но при этом вот этот отрезок был обновлен на плюс два,
[01:30:24.260 --> 01:30:29.260]  и вот это значение тоже было обновлено на плюс два, поэтому максимум это семь.
[01:30:29.260 --> 01:30:33.260]  Все, согласны?
[01:30:33.260 --> 01:30:38.260]  Окей.
[01:30:38.260 --> 01:30:43.260]  Да, если несколько изменений, то обещания будут суммироваться.
[01:30:43.260 --> 01:30:48.260]  Ну давайте сейчас напишем код обещаний, а потом приведем какой-нибудь ультимативный пример,
[01:30:48.260 --> 01:30:53.260]  посмотрим, как это все работает на практике. Согласны?
[01:30:53.260 --> 01:31:02.260]  Давайте напишем обновления, чтобы все стало...
[01:31:03.260 --> 01:31:09.260]  Ясно.
[01:31:09.260 --> 01:31:14.260]  Так.
[01:31:14.260 --> 01:31:21.260]  Да, обновления.
[01:31:21.260 --> 01:31:26.260]  Так, значит, обновления также будем выполнять сверху вниз.
[01:31:26.260 --> 01:31:34.260]  Так мы выполняем обновления сверху вниз, то нам снова потребуются дополнительные аргументы,
[01:31:34.260 --> 01:31:40.260]  ну точно такие же, LRB.
[01:31:40.260 --> 01:31:45.260]  Так, давайте лишь мне что-нибудь сотрем.
[01:31:57.260 --> 01:32:02.260]  Так, тут плюс два, тут плюс два, тут плюс два.
[01:32:06.260 --> 01:32:14.260]  Так, ну и давайте на том же самом отрезке теперь выполним апдейт.
[01:32:14.260 --> 01:32:17.260]  Ну, логика, вообще говоря, должна быть такой же.
[01:32:17.260 --> 01:32:22.260]  Значит, смотрите, я рекурсивно спускаюсь сверху вниз, спускаюсь-спускаюсь, и в итоге оказываюсь вот здесь.
[01:32:22.260 --> 01:32:27.260]  Что я должен сделать, если я в какой-то момент оказался в вершине, которая целиком покрывает
[01:32:27.260 --> 01:32:30.260]  некоторый отрезок запроса?
[01:32:30.260 --> 01:32:34.260]  Ну да, я должен остановиться и просто сохранить обещание, да, как и раньше.
[01:32:34.260 --> 01:32:38.260]  То есть вот из девятки я спускаюсь сюда, сюда, вижу, что этот узел целиком покрывает
[01:32:38.260 --> 01:32:41.260]  отрезок запроса, поэтому я тут просто беру и сохраняю обещание.
[01:32:41.260 --> 01:32:45.260]  То есть спускаться в детей и реально там что-то выполнять, выполнять какие-то обещания,
[01:32:45.260 --> 01:32:47.260]  реально там обновлять элементы, это долго.
[01:32:47.260 --> 01:32:51.260]  Поэтому я просто беру самый крупный отрезок и сохраняю обещание в нем.
[01:32:51.260 --> 01:33:06.260]  То есть как и раньше, if ab целиком лежит в lr, я говорю tenode.promise.
[01:33:06.260 --> 01:33:26.260]  Ну собственно, насколько мы изменяем? На плюс 2, на плюс 3, на минус 5 и так далее.
[01:33:26.260 --> 01:33:32.260]  То есть берем promise и делаем умножить равно delta.
[01:33:32.260 --> 01:33:40.260]  Вот. Ну и сразу делаем return. На этом останавливаемся.
[01:33:40.260 --> 01:33:55.260]  Так, естественно, если у меня отрезок ab совсем-совсем не пересекается с отрезком lr,
[01:33:55.260 --> 01:33:59.260]  то что я должен сделать? Ну ничего, да, просто return.
[01:33:59.260 --> 01:34:09.260]  Ну и наконец интересная ситуация. Интересная ситуация возникает где?
[01:34:09.260 --> 01:34:18.260]  Например, здесь. Я нахожусь в этой вершине, и мне сказали, что нужно обновить значение здесь.
[01:34:18.260 --> 01:34:22.260]  Но при этом этот узел отвечает не за этот отрезок, а еще за какую-то часть.
[01:34:22.260 --> 01:34:35.260]  Ага. То есть предлагается сделать следующее. Предлагается выполнить update.
[01:34:35.260 --> 01:34:44.260]  То есть если мне сказали, что нужно выполнить обновление здесь, то я рекурсивно запускаю update здесь
[01:34:44.260 --> 01:34:54.260]  То есть я делаю update от lr в левой вершине, и эта вершина отвечает за такой отрезок.
[01:34:54.260 --> 01:35:04.260]  Что? Да, еще delta.
[01:35:04.260 --> 01:35:20.260]  И update тоже самое lr, но уже write node, plus b пополам, plus 1b на delta.
[01:35:20.260 --> 01:35:30.260]  Что-то еще? Ну хорошо, смотрите, у меня есть 8. Ну, допустим, тут я выполнил update на минус 1.
[01:35:30.260 --> 01:35:39.260]  Что я делаю? Я спускаю update сюда, спускаю update сюда.
[01:35:39.260 --> 01:35:45.260]  Дальше спускаю update сюда, спускаю update сюда.
[01:35:45.260 --> 01:35:51.260]  Этот узел целиком лежит, поэтому я тут просто обновляю на минус 1.
[01:35:51.260 --> 01:35:58.260]  Дальше спускаю update сюда. Он говорит update здесь и update здесь. Здесь ничего не происходит.
[01:35:58.260 --> 01:36:03.260]  Здесь дополнительно минус 1.
[01:36:03.260 --> 01:36:15.260]  Что я должен сделать еще? Ну, смотрите, вот семерка делегировала update сюда и делегировала update сюда.
[01:36:15.260 --> 01:36:23.260]  Да, у меня семерка потенциально от этих изменений могла пострадать. Согласны?
[01:36:23.260 --> 01:36:31.260]  Давайте сначала с семеркой разберемся. Семерка сказала update слева, update справа.
[01:36:31.260 --> 01:36:39.260]  Update слева и update справа потенциально изменил тут максимум.
[01:36:39.260 --> 01:36:53.260]  Получается, что я должен написать t-node.value равно t-node.value.
[01:36:53.260 --> 01:37:13.260]  Получается, что я должен написать t-node.value равно t-node.value.
[01:37:13.260 --> 01:37:29.260]  Давайте хотя бы так. t-node.value умножить на t только left.
[01:37:29.260 --> 01:37:34.260]  Ну, я тоже так думаю, но раз так начали, пусть так будет.
[01:37:34.260 --> 01:37:50.260]  t от leftnode.promise, то есть значение, которое находится в левом сыне.
[01:37:50.260 --> 01:37:55.260]  Ну, к этому результату нужно прибавить еще то же самое, но для right.
[01:37:55.260 --> 01:37:59.260]  Ну, давайте тут напишем, как по-другому можно это сделать.
[01:37:59.260 --> 01:38:11.260]  Это можно просто написать как qri от отрезка qri на отрезке a plus b.
[01:38:11.260 --> 01:38:16.260]  Нет, не хочу так.
[01:38:16.260 --> 01:38:20.260]  Ну, этот qri он еще будет мне что-то спускать, наверное.
[01:38:20.260 --> 01:38:32.260]  Не, не будет ничего спускать. Давайте напишем qri от. За что отвечает правый отрезок?
[01:38:32.260 --> 01:38:47.260]  Да, a plus b пополам плюс один, b, right node. Ну, и тут то же самое.
[01:38:47.260 --> 01:38:55.260]  a plus b пополам плюс один, b. Ну, либо так, либо так.
[01:38:55.260 --> 01:39:14.260]  Ну, не обязательно. Ну, по традиции это почти работает.
[01:39:14.260 --> 01:39:26.260]  И что?
[01:39:26.260 --> 01:39:32.260]  Сейчас, подождите. Нет, в этом ифе все нормально, смотрите.
[01:39:32.260 --> 01:39:38.260]  Вот этот первый if, он отвечает за вот этот узел. То есть мы спускались-спускались, попали сюда.
[01:39:38.260 --> 01:39:43.260]  То есть он отвечает за всех детей сразу. В нем уже было какое-то обещание, про которое дети не знали.
[01:39:43.260 --> 01:39:48.260]  Просто обновили это обещание и все. То есть значение осталось прежним.
[01:39:48.260 --> 01:39:52.260]  То есть значение тут по-прежнему старое. То есть значение тут хранит...
[01:39:52.260 --> 01:39:58.260]  Короче говоря, тут значение это то, что знают дети. А вот это то, что дети не знают.
[01:39:58.260 --> 01:40:03.260]  Вот в этом коде чего-то не хватает.
[01:40:03.260 --> 01:40:22.260]  А пока это не работает. Тут не хватает одной детали.
[01:40:22.260 --> 01:40:39.260]  Чего-то не хватает. Ну, сравните, например, update с query.
[01:40:39.260 --> 01:40:46.260]  Не обновили промесы в листьях. Ну, вроде как вот update и вот update. Чего не хватает.
[01:40:46.260 --> 01:40:51.260]  Давайте еще раз логика. Как выглядит update? Мне приходит update на некотором отрезке.
[01:40:51.260 --> 01:40:58.260]  Я снова начинаю сверху вниз. Если я прихожу в узел, который целиком лежит в отрезке запроса,
[01:40:58.260 --> 01:41:02.260]  то я просто в нем обновляю промес. Все нормально. Если я пришел в какой-то узел,
[01:41:02.260 --> 01:41:06.260]  который вообще не пересекается запросом, то тоже все нормально. Я ничего не делаю.
[01:41:06.260 --> 01:41:12.260]  Дальше у меня история следующая. Я попал в какой-то узел. Вот в этот узел.
[01:41:12.260 --> 01:41:18.260]  И говорю следующую вещь. Я должен обновить все промесы здесь и обновить все промесы здесь.
[01:41:18.260 --> 01:41:26.260]  А потом обновить здесь value. Вот, смотрите, общая логика такая. Что делает push?
[01:41:26.260 --> 01:41:31.260]  Push выполняет обещания. Push говорит детям, что у них есть какие-то обещания,
[01:41:31.260 --> 01:41:36.260]  про которые они не знали. Так вот, прежде чем спускаться в детей, нужно им сообщить,
[01:41:36.260 --> 01:41:41.260]  что у них на самом деле были какие-то обещания, про которые они не знали. Понятно?
[01:41:41.260 --> 01:41:48.260]  Поэтому вот тут нужно дополнительно написать push от node.
[01:41:51.260 --> 01:41:57.260]  То есть это общее правило. Прежде чем спускаться в детей, вы должны пропушить в них обещания.
[01:41:57.260 --> 01:42:01.260]  Вот это выполняется здесь. Прежде чем спускаться в детей, мы выполняем push.
[01:42:01.260 --> 01:42:06.260]  То же самое и здесь. Прежде чем спускаться в детей, мы выполняем push.
[01:42:12.260 --> 01:42:18.260]  Двойного не будет. Почему? Потому что то, что написано вот здесь, то, что написано вот здесь
[01:42:18.260 --> 01:42:25.260]  и то, что написано здесь, это не пересекающиеся ветки. То есть либо выполняется вот это, либо вот это,
[01:42:25.260 --> 01:42:34.260]  либо вот это. Вот. Соответственно, что происходит при push? При push мы передаем обещание в детей,
[01:42:34.260 --> 01:42:39.260]  обновляем свое значение и выставляем промес в ноль. То есть мы ничего не обещаем,
[01:42:39.260 --> 01:42:59.260]  обещают только дети. Все. Мы уже засрали картинку. Давайте нарисуем новую и поиграемся с ней,
[01:42:59.260 --> 01:43:15.260]  чтобы понимать. Давайте какой-нибудь массив. 4, 5, 6, 7, 8. Давайте скинить значение, сгенерируем.
[01:43:29.260 --> 01:43:34.260]  Ну слишком большое. Давайте, чтобы максимум был разумный.
[01:43:50.260 --> 01:43:56.260]  Ну и снова будем делать максимум. Нет, давайте дайте минимум.
[01:44:00.260 --> 01:44:06.260]  Сумму мы еще поработаем. Давайте пока минимум, максимум. Короче, минимум.
[01:44:06.260 --> 01:44:29.260]  Операция минимума. 0, минус 5, 5, минус 5, 0, минус 5.
[01:44:29.260 --> 01:44:36.260]  Так, ну выполнять запрос не интересно. Ну а давайте делаем перерыв, а потом поиграем.
[01:44:36.260 --> 01:44:41.260]  Так, срок говоря, мы весь код, который сегодня был запланирован, написали.
[01:44:41.260 --> 01:44:48.260]  В принципе, мы решили задачу динамика RMQ, ну на самом деле динамика что угодно,
[01:44:48.260 --> 01:44:53.260]  с обновлением на подотресках. Да, единственный вопрос, который мы не обсудили,
[01:44:53.260 --> 01:45:04.260]  это нужна дистрибутивность. Вы помните, от вот этой операции требовалось, чтобы выполнялось вот такое свойство.
[01:45:04.260 --> 01:45:23.260]  Да, ну собственно, вот эта операция нам нужна, грубо говоря, в пуше.
[01:45:23.260 --> 01:45:32.260]  Да, ну то есть вот, представьте, что вот это вот, то, что у нас хранится в node.value, а вот это, это промисс.
[01:45:32.260 --> 01:45:38.260]  И вот когда мы выполняем пуш, мы на самом деле что делаем? Мы избавляемся от своего обещания
[01:45:38.260 --> 01:45:42.260]  и говорим, что мы спускаем обещание в левого сына, спускаем обещание в правого сына,
[01:45:42.260 --> 01:45:47.260]  и общий результат это вот эта штука. Так вот, чтобы это было корректно, чтобы пуш работал корректно,
[01:45:47.260 --> 01:45:52.260]  у нас должно выполняться вот это свойство. Согласны?
[01:45:52.260 --> 01:46:01.260]  Теперь давайте пример, ну давайте выполним какой-нибудь апдейт. Какой апдейт выполнить?
[01:46:17.260 --> 01:46:31.260]  4,6 плюс 5. Окей, давайте рассуждать. Мы находимся здесь. Этот узел отвечает за гораздо больший отрезок, чем нам нужно.
[01:46:31.260 --> 01:46:36.260]  Поэтому мы рекурсивно спускаемся влево и рекурсивно спускаемся вправо.
[01:46:36.260 --> 01:46:42.260]  Так, слева ничего, поэтому тут сразу заканчиваем работу.
[01:46:42.260 --> 01:46:48.260]  Идем вправо. Снова, этот отрезок отвечает за вот такой вот большой отрезок, и он пересекается с вот этим.
[01:46:48.260 --> 01:46:52.260]  Поэтому спускаемся рекурсивно влево, спускаемся рекурсивно вправо.
[01:46:52.260 --> 01:46:59.260]  Что происходит здесь? Этот узел целиком отвечает за отрезок, который лежит в запросе.
[01:46:59.260 --> 01:47:08.260]  Поэтому здесь сохраняем апдейт на плюс 5, как здесь.
[01:47:08.260 --> 01:47:13.260]  Обновляем промес, то есть раньше тут был промес 0, теперь мы обновили промес на плюс 5.
[01:47:13.260 --> 01:47:20.260]  Окей, что делаем далее? Далее запускаемся отсюда, этот рекурсивно запускается сюда и сюда.
[01:47:20.260 --> 01:47:27.260]  Тут ничего не происходит, а тут здесь сохраняем тоже апдейт на плюс 5.
[01:47:27.260 --> 01:47:33.260]  После рекурсивного вызова здесь, что происходит? Вот мы тут рекурсивно вызвали апдейт вот этот слева,
[01:47:33.260 --> 01:47:38.260]  рекурсивно вызвали апдейт справа, и теперь мы должны обновить значение здесь.
[01:47:38.260 --> 01:47:43.260]  Вот из этого узла мы пошли влево, что-то обновили, из этого узла мы пошли вправо, что-то обновили.
[01:47:43.260 --> 01:47:48.260]  Поэтому вот это значение теоретически могло обновиться. Но оно действительно обновилось.
[01:47:48.260 --> 01:47:56.260]  На сколько? Да, теперь когда я спрашиваю результат операции слева, мне возвращается 10.
[01:47:56.260 --> 01:47:58.260]  Когда я спрашиваю результат операции справа, мне возвращается бесконечности.
[01:47:58.260 --> 01:48:04.260]  Поэтому я тут пишу просто 10. Дальше поднимаемся выше. То же самое здесь.
[01:48:04.260 --> 01:48:10.260]  Здесь я делился на левый вызов и на правый вызов, поэтому теоретически вот это значение могло обновиться.
[01:48:10.260 --> 01:48:14.260]  Когда я вызывался слева, я вызывал вот этот апдейт, когда я вызывался справа, я вызывал вот этот апдейт.
[01:48:14.260 --> 01:48:21.260]  Теперь пришло время обновить значение. Что тут должно быть написано? 0.
[01:48:21.260 --> 01:48:25.260]  Потому что теперь результат операции здесь – это 0, результат операции здесь – это 10.
[01:48:25.260 --> 01:48:30.260]  Ну и рекурсивно я вызывался от корня. Поэтому корень рекурсивно вызывался.
[01:48:30.260 --> 01:48:36.260]  Вызывал апдейт отсюда, вызывал апдейт отсюда. Вот. И здесь я теперь должен сохранить 0.
[01:48:36.260 --> 01:48:55.260]  Нет, неправда. Промес у родителя – нейтральный элемент, то у всех его детей… Нет, неправда.
[01:48:55.260 --> 01:49:00.260]  Давайте пример еще. Хорошо, вот это с выявленным запросом понятно, да?
[01:49:00.260 --> 01:49:14.260]  Давайте другой запрос. Давайте синий. Давайте запрос, не знаю, ну вот здесь, вот на таком отрезке, на минус 1. Согласны?
[01:49:14.260 --> 01:49:19.260]  Что я делаю? Я нахожусь здесь, иду рекурсивно влево, ну снова, да, давайте по порядку, вот здесь, что происходит.
[01:49:19.260 --> 01:49:24.260]  Я нахожусь здесь. Вот это условие у меня не выполняется, вот это условие у меня не выполняется.
[01:49:24.260 --> 01:49:27.260]  Поэтому я выполняю push, ну там push-ить нечего, поэтому переходим сюда.
[01:49:27.260 --> 01:49:32.260]  То есть рекурсивно вызываемся слева, от левой части. Ну левая часть совсем не пересекается, поэтому там неинтересно.
[01:49:32.260 --> 01:49:36.260]  И рекурсивно вызываемся влево. Ну вот здесь.
[01:49:37.260 --> 01:49:40.260]  Вот этот узел целиком отвечает за запрос.
[01:49:40.260 --> 01:49:43.260]  Поэтому что я должен сделать?
[01:49:43.260 --> 01:49:46.260]  Сохранить минус единицу.
[01:49:46.260 --> 01:49:49.260]  Все.
[01:49:49.260 --> 01:49:52.260]  И вот здесь.
[01:49:52.260 --> 01:49:55.260]  И вот здесь.
[01:49:55.260 --> 01:49:58.260]  И вот здесь.
[01:49:58.260 --> 01:50:01.260]  И вот здесь.
[01:50:01.260 --> 01:50:04.260]  Сохранить минус единицу.
[01:50:04.260 --> 01:50:07.260]  Все.
[01:50:12.260 --> 01:50:15.260]  Ну вот вам пример.
[01:50:15.260 --> 01:50:20.260]  Здесь не нейтральный элемент, и у детей тоже не нейтральный элемент.
[01:50:20.260 --> 01:50:23.260]  Ну то есть проверим, что у нас действительно все правильно.
[01:50:23.260 --> 01:50:28.260]  Значит, вот тут мы ничего не изменяли, вот этот элемент должен был измениться на сколько?
[01:50:28.260 --> 01:50:30.260]  На плюс 4, да?
[01:50:30.260 --> 01:50:34.260]  Здесь 5, которое приходит отсюда, есть минус 1, который идет отсюда. Ну плюс 4.
[01:50:34.260 --> 01:50:39.260]  У этого элемента. Этот элемент тоже долженels도 замениться на плюс 4. То есть вот он плюс 5 и вот он минус 1. То есть 4.
[01:50:39.260 --> 01:50:43.260]  У этого элемента тоже. Вот он сам плюс 5 и минус 1.
[01:50:43.260 --> 01:50:46.260]  Вот этот элемент должен был измениться на минус 1.
[01:50:46.260 --> 01:50:50.260]  То есть вот он на минус 1 приходит только отсюда. На плюс 5 никакого запроса нет.
[01:50:50.260 --> 01:50:56.260]  Аwolf, а вот у нас допустим инцидизированное минусmiсконечность, и нам на этот ответ是 минус 5?
[01:50:56.260 --> 01:51:03.720]  Ну, ничего. Да. Ну то есть нейтральный элемент это вот как раз такой элемент,
[01:51:03.720 --> 01:51:15.920]  который, чтобы вы к нему не применили, останется то же самое. Ну и давайте
[01:51:15.920 --> 01:51:26.880]  выполнить какой-нибудь запрос. Так, вот это уберем. Какой запрос будем выполнять?
[01:51:26.880 --> 01:51:37.040]  Ну или давайте еще какое-нибудь обновление, чтобы прям точно все кейсы покрыть. Не знаю,
[01:51:37.040 --> 01:51:51.760]  давайте еще сделаем апдейт в таком отрезке на плюс три. Что происходит? Запускаемся отсюда,
[01:51:51.760 --> 01:51:59.760]  рекурсия нас ведет влево и вправо. Идем влево. Значит снова здесь рекурсивно запускаемся слева,
[01:51:59.760 --> 01:52:06.280]  рекурсивно запускаемся справа. Здесь ничего интересного для нас нет. Поэтому сразу завершаем
[01:52:06.280 --> 01:52:11.560]  работу. Запускаемся рекурсивно справой части. Вот этот отрезок, то есть попадаем вот в первый
[01:52:11.560 --> 01:52:21.560]  случай. Вот этот отрезок AB целиком лежит в запросе. Поэтому тут пишем обещание на плюс три. Все,
[01:52:21.560 --> 01:52:25.560]  вот тут два рекурсивных вызова закончились. То есть вот когда мы находились вот в этом узле,
[01:52:25.560 --> 01:52:30.680]  мы сделали рекурсивный вызов слева, рекурсивный вызов справа. И теперь мы должны просто обновить
[01:52:30.680 --> 01:52:38.040]  значение здесь. Обновляем значение, тут три. То есть минимум из пятерки и ноль плюс тройки это
[01:52:38.040 --> 01:52:46.240]  тройка. Все, ну и родителю тоже сообщаем, что у нас новый результат три. Так, теперь рекурсивно
[01:52:46.240 --> 01:52:56.560]  вызываемся отсюда. Значит, не очень хорошо. Давайте вот такой отрезок возьмем. Ну что бы было
[01:52:56.560 --> 01:53:04.680]  интереснее. Значит, снова вот этот отрезок, он покрывает чуть больше, чем нужно. Поэтому что
[01:53:04.680 --> 01:53:11.880]  делаем? Да, вот теперь сначала пушем. Понятно? То есть прежде чем переходить к обновлению здесь и
[01:53:11.880 --> 01:53:16.280]  обновлению здесь, мы должны этим детям сообщить, что у них где-то выше было вот это обновление.
[01:53:16.280 --> 01:53:22.680]  Поэтому делаем push. Как выглядит push? Мы просто избавляемся от обещания, обновляем значение
[01:53:22.680 --> 01:53:33.200]  здесь и добавляем обещание сюда и сюда. Ну здесь можно сразу написать плюс четыре. Вот для чего
[01:53:33.200 --> 01:53:40.440]  нужен push. Понятно? Все, теперь наконец сделали push и со спокойной совестью можем рекурсивно
[01:53:40.440 --> 01:53:48.080]  запуститься от левой части от правой части. Находимся здесь. Общий апдейт на плюс три, поэтому
[01:53:48.080 --> 01:53:54.760]  этот плюс четыре заменяем на плюс семь. Вот, это как раз тот момент, который не всем был понятен.
[01:53:54.760 --> 01:54:01.520]  Смотрите, я обновил промес здесь два раза. Видно? То есть когда мне пришел сюда минус один, и теперь
[01:54:01.520 --> 01:54:06.880]  мне пришелся запрос на плюс три. Это не один и тот же апдейт. Когда я обновлял здесь плюс пятерки
[01:54:06.880 --> 01:54:13.000]  на плюс четверку, я выполнил тот старый промес, который был еще до этого, когда-то давно. А вот теперь,
[01:54:13.000 --> 01:54:17.240]  когда я наконец дошел до сюда, я делаю тот самый апдейт, который меня просят сейчас.
[01:54:17.240 --> 01:54:25.240]  Естественно. То есть если вы не выполнили старый промес, то вы его просто потеряете.
[01:54:25.240 --> 01:54:49.000]  Если вы оставите его в родителе, то тогда вы не сможете корректно обновить значение здесь и здесь.
[01:54:49.000 --> 01:54:57.000]  То есть рекурсия, в принципе, она может пойти дальше-дальше. Вот. Ну то есть здесь-то может быть все нормально, возможно.
[01:54:57.000 --> 01:55:03.000]  Но когда вы будете, например, здесь спускаться рекурсивно влево и вправо, то у вас дойдут до сюда и до сюда некорректные значения обновления.
[01:55:03.000 --> 01:55:22.000]  Поэтому так нельзя.
[01:55:22.000 --> 01:55:29.000]  Ну давайте подумаем. Давайте подумаем. Ну вот тут что было?
[01:55:29.000 --> 01:55:36.000]  Тут было 0, тут минус 1. Ну вот допустим мы этот минус 1 тут и оставляем.
[01:55:36.000 --> 01:55:43.000]  Вот. Тут было что у нас? Тут было плюс 5. Мы делаем...
[01:55:43.000 --> 01:55:49.000]  Так. И тут мы теперь должны сделать тут на плюс 3, то есть тут плюс 8.
[01:55:49.000 --> 01:55:58.000]  И вот так кажется делать нельзя. Почему? Потому что у вас тут... Ну смотрите, когда вас в следующий раз попросят...
[01:55:58.000 --> 01:56:07.000]  Короче, тут все запутано. Смотрите, вот когда вас попросят выполнить запрос вот на этом узле, что вы вернете?
[01:56:07.000 --> 01:56:26.000]  То есть как раз таки разделение на promise и на value оно как раз заключается в том, что вот про это обновление не знают дети.
[01:56:26.000 --> 01:56:32.000]  Давайте попробуем привести какой-нибудь пример, когда все сломается. Допустим я вот это обещание не спускаю детей.
[01:56:32.000 --> 01:56:44.000]  Тогда тут спускается на плюс 3. Вот тут я обновляю плюс 5 до плюс 2. И все.
[01:56:44.000 --> 01:56:50.000]  Тут что было? Плюс 5. Да, поэтому плюс 8.
[01:56:50.000 --> 01:57:00.000]  Хорошо, я теперь тут должен... Теперь я должен обновить значение здесь. Какое значение должно быть здесь?
[01:57:00.000 --> 01:57:10.000]  Тут значение 13. Сюда я должен вернуть... Справа возвращается 3, отсюда возвращается 13.
[01:57:10.000 --> 01:57:23.000]  Здесь я должен записать сюда. Здесь я должен записать 3.
[01:57:23.000 --> 01:57:43.000]  И ничего не сломалось, да, хотите сказать?
[01:57:43.000 --> 01:58:02.000]  Давайте еще подумаем. Про этот promise дети не знают, знают только родители. В принципе, наверное, я согласен.
[01:58:02.000 --> 01:58:08.000]  В случае promise вот это обещание можно не спускать. Вот это обещание можно не спускать. Почему?
[01:58:08.000 --> 01:58:14.000]  Потому что когда мы будем выполнять запрос, если мы в итоге придем сюда, то тут хранится значение, про которое знают дети,
[01:58:14.000 --> 01:58:20.000]  а вот тут хранится promise, про которое дети не знают, поэтому мы там корректно все обновим.
[01:58:20.000 --> 01:58:28.000]  Наверное, можно не обновлять. Но мне кажется, что если мы все-таки обновляем, то так понятнее.
[01:58:28.000 --> 01:58:38.000]  Ну почему? Потому что мы проталкиваем значение в детей.
[01:58:38.000 --> 01:58:44.000]  Мне кажется, что вот этот push просто доваляет симметрию в то, что было написано здесь, и в то, что было написано там.
[01:58:44.000 --> 01:58:55.000]  В принципе, я пока не вижу причин, по которым push обязателен вот здесь, но если что-то придумаю, то я напишу об этом.
[01:58:55.000 --> 01:59:05.000]  Так, давайте. Тут что у нас было? Тут было плюс пять. То есть тут должно быть плюс семь, да?
[01:59:05.000 --> 01:59:17.000]  Запутали. Какие у нас обновления тут были? То есть плюс семь. Суммарный.
[01:59:17.000 --> 01:59:31.000]  А здесь? Какие обновления вот этот узел затрагивали?
[01:59:31.000 --> 01:59:41.000]  Давайте так. Какие обновления мы вообще в принципе выполняли?
[01:59:41.000 --> 01:59:55.000]  Так, плюс пять. Вот так?
[01:59:55.000 --> 02:00:19.000]  То есть плюс пять было вот так? Вот так? Все, отлично. Вот так на плюс пять. Дальше?
[02:00:19.000 --> 02:00:29.000]  Плюс три, да? Так, здесь плюс три. Дальше, вот тут суммарное обновление должно было приехать на плюс семь.
[02:00:29.000 --> 02:00:38.000]  Да, все нормально. Здесь обновление мы пропушили, поэтому здесь два.
[02:00:38.000 --> 02:00:44.000]  Здесь суммарное обновление. Здесь мы тоже в конце должны были пропушить.
[02:00:44.000 --> 02:00:50.000]  Поэтому сюда в итоге пришло обновление на плюс пять минус один, то есть плюс семь тоже.
[02:00:50.000 --> 02:01:11.000]  Вот, и здесь двенадцать. Похоже на правду. Ну, кажется так.
[02:01:11.000 --> 02:01:21.000]  Давайте тут, значит, полностью на плюс три, тут полностью на плюс семь. Значит, тут плюс пять минус один плюс три, тут на плюс семь.
[02:01:21.000 --> 02:01:29.000]  Здесь двенадцать. То есть тут нет никаких невыполненных обещаний. Здесь тоже, здесь тоже. Вот.
[02:01:29.000 --> 02:01:35.000]  Ну, сюда пришло два.
[02:01:35.000 --> 02:01:47.000]  Ну, давайте выполним какой-нибудь запрос. Ну, давайте запрос выполним, не знаю, вот здесь.
[02:01:47.000 --> 02:01:58.000]  Что мы делаем? Мы спускаемся в левую часть, то есть здесь сразу тройка, то есть тройка сразу отвечает за весь подотрез, поэтому тройка возвращается обратно.
[02:01:58.000 --> 02:02:08.000]  Здесь рекурсивно спускаемся сюда, рекурсивно спускаемся сюда и сюда. Получаем, что здесь нам не рады, ничего не возвращаем.
[02:02:08.000 --> 02:02:21.000]  Спускаемся сюда, вот тут делаем push за счет того, что тут плюс семь и тут плюс семь.
[02:02:21.000 --> 02:02:29.000]  Вот, спустились сюда и этот отрезок целиком лежит в запросе, поэтому возвращаем пятьдесят. Здесь тоже возвращаем.
[02:02:29.000 --> 02:02:39.000]  Так, нет. Здесь возвращаем пятьдесят, здесь возвращаем два. Соответственно, берем минимум, возвращается два.
[02:02:39.000 --> 02:02:49.000]  Ну, бла-бла, возвращаемся два, всеобще ответ два.
[02:02:49.000 --> 02:03:01.000]  Нет. Еще раз. Когда мы спустились сюда, мы сделали push, то есть выполнили туда обещание, спустили обещание сюда на плюс семь, спустили обещание сюда на плюс семь.
[02:03:01.000 --> 02:03:11.000]  Когда мы рекурсивно вызвались от левой части и от правой части, когда мы рекурсивно вызвались от правой части, нам ничего не вернулось, то есть нам вернулось не два, а ничего.
[02:03:11.000 --> 02:03:20.000]  Потому что у нас обещание было раньше здесь, мы выполнили push, а потом поехали вниз.
[02:03:20.000 --> 02:03:25.000]  Вот. То есть отсюда нам вернулось ничего, а отсюда нам вернулось пятьдесят.
[02:03:25.000 --> 02:03:33.000]  Поэтому отсюда суммарно вернется пятьдесят и сюда вернется пятьдесят. Поэтому ответ три.
[02:03:33.000 --> 02:03:51.000]  Ну вот такая история.
[02:03:51.000 --> 02:04:02.000]  Ну и теперь давайте коротко поговорим про то, что делать в случае сумм, что делать в случае недистрибутивных операций.
[02:04:02.000 --> 02:04:17.000]  Давайте еще один пример приведем уже в случае сумм.
[02:04:17.000 --> 02:04:28.000]  Итак, ну снова давайте заведем какой-нибудь, ну давайте уже поменьше пример рассмотрим.
[02:04:28.000 --> 02:04:44.000]  Достаточно будет. Ну пусть. Три, семь, минус пять, два. Пусть мы строим дерево отрезков по сумме.
[02:04:44.000 --> 02:04:50.000]  Ну как обсуждали ранее, чтобы можно было выполнять обновление на отрезках, операция должна быть дистрибутивна.
[02:04:50.000 --> 02:04:53.000]  То есть какую мы знаем дистрибутивную по сложению операцию? Ну это умножение.
[02:04:53.000 --> 02:05:00.000]  То есть если мы хотим умножать на отрезки, то все равно тоже повторяется.
[02:05:00.000 --> 02:05:05.000]  То есть вопрос заключается в том, а что если я хочу выполнять присваивание на отрезке?
[02:05:05.000 --> 02:05:19.000]  То есть плюс в качестве ответа.
[02:05:19.000 --> 02:05:26.000]  В данном примере я хочу не только складывать на отрезках, но еще выполнять обновление на подотрезке.
[02:05:26.000 --> 02:05:32.000]  Например, взять вот этот отрезок целиком и тут прибавить всеми элементам плюс три.
[02:05:32.000 --> 02:05:40.000]  Я думаю понятно, что старый способ не прокатит. Да, почему?
[02:05:40.000 --> 02:05:44.000]  Ну почти, да. То есть я хочу показать, что старый способ не сработает. Почему?
[02:05:44.000 --> 02:05:49.000]  Ну потому что если я тут сохраню обещание на плюс три и тут сохраню обещание на плюс три,
[02:05:49.000 --> 02:05:54.000]  то вообще говоря неправда, что результат операции здесь это минус три плюс три.
[02:05:54.000 --> 02:06:03.000]  То есть сложение не дистрибутивная операция, поэтому нельзя сказать, что минус три плюс три
[02:06:03.000 --> 02:06:13.000]  это то же самое, что минус пять плюс три плюс два плюс три.
[02:06:13.000 --> 02:06:18.000]  То есть нельзя просто взять обещание и спустить сюда и сюда.
[02:06:18.000 --> 02:06:29.000]  Но можно прибегнуть к трюку и перейти в некоторое другое пространство,
[02:06:29.000 --> 02:06:36.000]  в котором операция плюс будет все-таки дистрибутивна.
[02:06:36.000 --> 02:06:53.000]  Смотрите, давайте перейдем к другим элементам, для которых плюс будет дистрибутивен.
[02:06:53.000 --> 02:06:57.000]  И вот в качестве таких элементов я предлагаю хранить следующую вещь.
[02:06:57.000 --> 02:07:17.000]  Помимо самого элемента давайте хранить пару решений.
[02:07:17.000 --> 02:07:27.000]  Храним пару v и количество элементов.
[02:07:27.000 --> 02:07:32.000]  Вот здесь хранится значение три, и он отвечает за один элемент.
[02:07:32.000 --> 02:07:35.000]  Здесь хранится значение семь, и он отвечает за один элемент.
[02:07:35.000 --> 02:07:43.000]  Здесь то же самое. Минус пять и один. Здесь два и один.
[02:07:43.000 --> 02:07:51.000]  Дальше здесь десять и два. То есть сумма десять, и в этой сумме всего два слагаемых.
[02:07:51.000 --> 02:07:57.000]  Здесь тоже минус три и два слагаемых. Здесь общая сумма семь и четыре слагаемых.
[02:07:57.000 --> 02:08:02.000]  Чем это нам поможет? А поможет это нам следующим.
[02:08:02.000 --> 02:08:12.000]  Смотрите, что должно произойти, если я пытаюсь, скажем, к семь запятая, давайте так, в общем случае,
[02:08:12.000 --> 02:08:25.000]  к а запятая n прибавить дельту. Чему это должно быть равно?
[02:08:25.000 --> 02:08:49.000]  Это должно быть равно, это должно быть a плюс дельта n, n плюс, ну и все.
[02:08:49.000 --> 02:08:53.000]  То есть вот этот апдейт, он теперь работает следующим образом.
[02:08:53.000 --> 02:08:58.000]  Он берет само значение, он берет количество слагаемых, и просто каждому слагаемому прибавляет дельту.
[02:08:58.000 --> 02:09:02.000]  Ну а так как всего слагаемых у меня n, у меня выполняется вот такое соотношение.
[02:09:02.000 --> 02:09:08.000]  Почему это будет дистрибутивно? Ну давайте посмотрим вот сюда.
[02:09:08.000 --> 02:09:20.000]  Теперь я храню пары a, n, a плюс b, n, b. И здесь я выполняю плюс c.
[02:09:20.000 --> 02:09:24.000]  Почему у меня равно плюс c?
[02:09:24.000 --> 02:09:31.000]  Значит смотрите, если у меня есть сумма n, a слагаемых и сумма равна a, есть сумма n, b слагаемых,
[02:09:31.000 --> 02:09:43.000]  которая равна b, то по сути эта штука вся равна a плюс b на n, a плюс n, b.
[02:09:43.000 --> 02:09:50.000]  Согласны?
[02:09:50.000 --> 02:09:56.000]  Согласно тому определению, которое мы ввели до этого, согласно тому определению, как складывать пару с числом,
[02:09:56.000 --> 02:09:59.000]  у нас получается следующая вещь.
[02:09:59.000 --> 02:10:18.000]  a плюс b плюс n, a плюс n, b умножить на c, n, a плюс n, b.
[02:10:18.000 --> 02:10:27.000]  Вот.
[02:10:27.000 --> 02:10:31.000]  Ну вот эту штуку мы уже можем расписать как?
[02:10:31.000 --> 02:10:45.000]  Итак, a плюс n, a умножить на c, n, a плюс b плюс n, b умножить на c, n, b.
[02:10:45.000 --> 02:10:56.000]  Получили дистрибутивность. Согласны?
[02:10:56.000 --> 02:11:06.000]  Весь трюк заключается в том, что если у вас есть какая-то недистрибутивная операция, то вы должны ввести некоторую дополнительную информацию так,
[02:11:06.000 --> 02:11:10.000]  чтобы операция в итоге стала дистрибутивной.
[02:11:10.000 --> 02:11:13.000]  То есть в итоге этот плюс 3 действует так.
[02:11:13.000 --> 02:11:18.000]  Он берет количество слагаемых, ну скажем, если вам поступил запрос в этом узле,
[02:11:18.000 --> 02:11:30.000]  то вам в качестве ответа нужно вернуть минус 3 плюс 3 умножить на 2.
[02:11:30.000 --> 02:11:43.000]  Вот такое решение.
[02:11:43.000 --> 02:11:45.000]  А теперь самое интересное.
[02:11:45.000 --> 02:11:50.000]  Это, что касается формальной стороны вопроса, то есть как из сложения по сложению,
[02:11:50.000 --> 02:11:54.000]  из недистрибутивного сложения по сложению сделать дистрибутивное сложение по сложению.
[02:11:54.000 --> 02:11:57.000]  Теперь как-то реально должно быть устроено.
[02:11:57.000 --> 02:12:02.000]  Вообще говоря, хранить вот эти самые количества это не очень удобно. Согласны?
[02:12:02.000 --> 02:12:06.000]  Вот я утверждаю, что вот эти вот количества, 4, 2 и так далее, у нас уже где-то хранится.
[02:12:06.000 --> 02:12:10.000]  И вот это значение мы можем легко получить.
[02:12:10.000 --> 02:12:15.000]  Два в типе не уровень. Нормально, но можно лучше.
[02:12:31.000 --> 02:12:34.000]  То есть когда мы выполняем q или когда мы выполняем update,
[02:12:34.000 --> 02:12:40.000]  мы одновременно с этим храним границу отрезка, за которую он отвечает.
[02:12:40.000 --> 02:12:44.000]  Ну а зная границу отрезка, за которую он отвечает, мы всегда можем получить количество элементов,
[02:12:44.000 --> 02:12:48.000]  за которые отвечает этот узел.
[02:12:48.000 --> 02:12:51.000]  Поэтому в случае сложения по сложению, что тут нужно исправить?
[02:12:51.000 --> 02:12:57.000]  Ну, во-первых, вот тут нужно промес.
[02:12:57.000 --> 02:12:59.000]  Ну короче, как выглядит вот этот update?
[02:12:59.000 --> 02:13:07.000]  Мы должны взять value и прибавить промес, умноженный на n,
[02:13:07.000 --> 02:13:11.000]  где n берется вот по такой формуле.
[02:13:11.000 --> 02:13:17.000]  Что дальше? Здесь понятно.
[02:13:17.000 --> 02:13:25.000]  Ну и здесь пересчет, точнее, вот тут.
[02:13:25.000 --> 02:13:35.000]  В value мне должен быть plus равно tnotedpromise умноженный на n.
[02:13:45.000 --> 02:13:48.000]  Вот такая история.
[02:13:48.000 --> 02:13:53.000]  Ну и в принципе таким же образом выполняется любая и другая операция.
[02:13:53.000 --> 02:14:00.000]  Мы сейчас, например, обсудим, вот что если мне теперь хочется выполнять обновление не на plus,
[02:14:00.000 --> 02:14:07.000]  а скажем, ну опять же, я работаю в той же парадигме, я работаю со сложением.
[02:14:07.000 --> 02:14:16.000]  То есть у меня по-прежнему дерево отрезков хранит результаты суммы,
[02:14:16.000 --> 02:14:24.000]  но в качестве апдейта у меня поступает операция присваивания внезапно.
[02:14:24.000 --> 02:14:32.000]  То есть я хочу взять и на отрезке всем элементам присвоить единицу.
[02:14:32.000 --> 02:14:42.000]  Но снова, присваивание – это не дистрибутивная операция.
[02:14:43.000 --> 02:14:47.000]  Да нет, нет.
[02:14:47.000 --> 02:14:59.000]  Если вы A, B берете, приравниваете дельта, то это не то же самое, что A присвоит дельта, плюс B присвоит дельта.
[02:14:59.000 --> 02:15:03.000]  Операция присваивания – считаем, что возвращает результат присваивания.
[02:15:03.000 --> 02:15:08.000]  В данном случае понятно, что дельта не равна сумме двух дельт.
[02:15:08.000 --> 02:15:17.000]  Но ровно таким же трюком, если мы дополнительно в рассмотрение обводим количество элементов, за которые отвечает каждый узел,
[02:15:17.000 --> 02:15:19.000]  мы можем выполнять и обновления.
[02:15:19.000 --> 02:15:27.000]  То есть тут мы сохраняем обещание равно единице, и тут мы сохраняем обещание равно единице.
[02:15:27.000 --> 02:15:31.000]  И когда нас реально попросит результат, то что мы должны сделать?
[02:15:31.000 --> 02:15:39.000]  Ну не присвоить, нам достаточно просто вернуть.
[02:15:39.000 --> 02:15:42.000]  Давайте, как выглядит результат.
[02:15:42.000 --> 02:15:55.000]  Результат A, A на A, на дельту.
[02:15:55.000 --> 02:15:57.000]  Что мы должны в этом случае вернуть?
[02:15:57.000 --> 02:16:03.000]  То есть у меня есть узел, в котором хранится A и A, то есть в данном случае минус 3 и 2 элемента.
[02:16:03.000 --> 02:16:10.000]  И поступает запрос, что я должен вернуть результат старого значения с учетом обновления.
[02:16:10.000 --> 02:16:16.000]  Что я должен вернуть?
[02:16:16.000 --> 02:16:20.000]  На самом деле, я должен просто вернуть вот эту штуку.
[02:16:20.000 --> 02:16:31.000]  Ну да.
[02:16:31.000 --> 02:16:38.000]  Мне тут говорится, что раньше когда-то здесь было два слагаемых, и их сумма была равна минус 3.
[02:16:38.000 --> 02:16:43.000]  Но теперь тут хранится обещание, что нужно присвоить единицу.
[02:16:43.000 --> 02:16:46.000]  Чему тогда будет равен результат операции в этом узле?
[02:16:46.000 --> 02:16:52.000]  Ну раз тут всем элементам в этом узле была присвоена единица, и тут всего два слагаемых, то значит сумма эта 2 умножить на 1.
[02:16:52.000 --> 02:16:56.000]  Поэтому 2.
[02:16:56.000 --> 02:17:00.000]  Понятно?
[02:17:00.000 --> 02:17:06.000]  Соответственно, здесь вместо вот этого значения вы должны вернуть просто промес, умноженный на n.
[02:17:06.000 --> 02:17:09.000]  Ну в случае, если промес действительно есть.
[02:17:09.000 --> 02:17:13.000]  Тут еще тонкий момент. А как отличить, есть промес или нет промеса?
[02:17:13.000 --> 02:17:22.000]  Какой результат является нейтральным? Что является нейтральным результатом по вот этому обновлению на присваивании?
[02:17:22.000 --> 02:17:27.000]  Самой value.
[02:17:27.000 --> 02:17:30.000]  Ну вообще говоря, непонятно. Вообще говоря, это неправда.
[02:17:30.000 --> 02:17:37.000]  Почему? Потому что если я тут храню равно 10, то когда меня попросит push, я вот это равно 10, пропушу влево и вправо.
[02:17:37.000 --> 02:17:41.000]  Поэтому мне нужно просто хранить некоторое отдельное значение,
[02:17:41.000 --> 02:17:47.000]  ну короче, некоторое специальное значение, которое будет говорить, что на самом деле присваивания не было, и все.
[02:17:47.000 --> 02:17:53.000]  Ну не знаю, можно дополнительно bool хранить типа true или false.
[02:17:53.000 --> 02:18:01.000]  Ну типа реально тут есть обновление какое-то или нет?
[02:18:01.000 --> 02:18:08.000]  Все ясно.
[02:18:08.000 --> 02:18:15.000]  Понятно, как разбираться с недистрибутивными операциями и тому подобное.
[02:18:15.000 --> 02:18:27.000]  Ну в принципе минут пять есть, давайте тогда еще какую-нибудь задачу разберем.
[02:18:27.000 --> 02:18:34.000]  Ну давайте какую-нибудь классику.
[02:18:34.000 --> 02:18:40.000]  Дерево отрезков на самом деле очень мощная структура данных, она позволяет делать много чего,
[02:18:40.000 --> 02:18:43.000]  то есть она позволяет выполнять групповые обновления на отрезках,
[02:18:43.000 --> 02:18:46.000]  плюс несмотря на то, что формально она требует дистрибутивной операции,
[02:18:46.000 --> 02:18:50.000]  практически любую операцию можно сделать дистрибутивной, ну там, с помощью некоторых хаков.
[02:18:50.000 --> 02:18:53.000]  Может какие-то хаки дополнительно вы обсудите еще на семинарах.
[02:18:53.000 --> 02:18:56.000]  Ну давайте небольшой мостик следующей лекции вброшу.
[02:18:56.000 --> 02:19:00.000]  Дерево отрезков очень мощная структура данных, которая позволяет сделать многое.
[02:19:00.000 --> 02:19:02.000]  Но не все.
[02:19:02.000 --> 02:19:08.000]  Ну например дерево отрезков не позволяет вставлять новый элемент.
[02:19:08.000 --> 02:19:11.000]  Ну представьте, что вы хотите в отрезок добавить некоторый новый элемент.
[02:19:11.000 --> 02:19:14.000]  Или вы хотите выполнить операцию обновления,
[02:19:14.000 --> 02:19:20.000]  в виде взять какой-то подотрезок и перевернуть его.
[02:19:20.000 --> 02:19:22.000]  Как это сделать за алгоритм, непонятно.
[02:19:22.000 --> 02:19:26.000]  В следующий раз мы научимся выполнять всякие перевороты отрезков.
[02:19:26.000 --> 02:19:30.000]  Не знаю, взять вот этот кусок отрезка, переставить его в начало.
[02:19:30.000 --> 02:19:32.000]  И все это будем делать за алгоритмическое время.
[02:19:32.000 --> 02:19:35.000]  Но уже с помощью какой-то другой структуры данных.
[02:19:35.000 --> 02:19:37.000]  Так, вернемся к дереву отрезков.
[02:19:37.000 --> 02:19:40.000]  Значит, задачи ставят следующим образом.
[02:19:40.000 --> 02:19:42.000]  Снова у меня есть массив.
[02:19:42.000 --> 02:19:44.000]  Ну пусть тут один, ноль.
[02:19:44.000 --> 02:19:47.000]  Понимаете, просто бинарный массив.
[02:19:55.000 --> 02:19:58.000]  Задача стоит следующим образом.
[02:19:58.000 --> 02:20:00.000]  Посчитать количество нулей на подотрезке.
[02:20:00.000 --> 02:20:03.000]  То есть мне данный некоторый подотрезок.
[02:20:03.000 --> 02:20:06.000]  Нужно сказать, сколько в нем нулей.
[02:20:06.000 --> 02:20:09.000]  Как будем решать?
[02:20:09.000 --> 02:20:12.000]  И что будем хранить в узлах?
[02:20:16.000 --> 02:20:18.000]  Да, решение стоит в следующем.
[02:20:18.000 --> 02:20:20.000]  Давайте хранить в узлах не сами значения, как раньше,
[02:20:20.000 --> 02:20:22.000]  а просто количество нулей.
[02:20:22.000 --> 02:20:25.000]  Возьмем и вот этот массив инвертируем.
[02:20:25.000 --> 02:20:28.000]  То есть тут ноль нулей, тут один ноль,
[02:20:28.000 --> 02:20:31.000]  ноль нулей, ноль.
[02:20:31.000 --> 02:20:33.000]  Тут один ноль, тут один ноль,
[02:20:33.000 --> 02:20:36.000]  ноль нулей, ноль,
[02:20:36.000 --> 02:20:39.000]  ноль, один, один,
[02:20:39.000 --> 02:20:42.000]  тут ноль нулей.
[02:20:42.000 --> 02:20:45.000]  Ну и дальше просто-напросто складываем все значения.
[02:20:45.000 --> 02:20:47.000]  То есть тут на этом отрезке один ноль,
[02:20:47.000 --> 02:20:50.000]  тут нет нулей, тут один ноль, тут один ноль,
[02:20:50.000 --> 02:20:52.000]  тут два нуля.
[02:20:52.000 --> 02:20:58.000]  Ну и суммарно на всем моем массиве было три нуля.
[02:20:58.000 --> 02:21:00.000]  Хорошо, это простая задача.
[02:21:00.000 --> 02:21:02.000]  Даже можно поплотить обновления,
[02:21:02.000 --> 02:21:04.000]  даже групповые обновления, все нормально.
[02:21:04.000 --> 02:21:06.000]  Вопрос звучит в следующем.
[02:21:06.000 --> 02:21:09.000]  А вот что, если мне приходит запрос вида
[02:21:09.000 --> 02:21:11.000]  найти не количество нулей,
[02:21:11.000 --> 02:21:13.000]  а найти
[02:21:20.000 --> 02:21:22.000]  найти кат и ноль?
[02:21:31.000 --> 02:21:33.000]  Скажем, найти позицию,
[02:21:33.000 --> 02:21:35.000]  в которой расположен кат и ноль.
[02:21:35.000 --> 02:21:38.000]  Не знаю, первый, второй, третий и так далее.
[02:21:40.000 --> 02:21:43.000]  Как решить задачу с алгоритмическое время?
[02:21:43.000 --> 02:21:45.000]  Поиск по бинарному дереву.
[02:21:45.000 --> 02:21:47.000]  Поиск по бинарному дереву.
[02:21:47.000 --> 02:21:49.000]  Ну понятно, что не такое.
[02:21:49.000 --> 02:21:51.000]  Ну, допустим, мы идем в левую ветру,
[02:21:51.000 --> 02:21:54.000]  смотрим, есть там меньше нулей, чем кат и ноль.
[02:21:54.000 --> 02:21:56.000]  Ну примерно так, да.
[02:21:56.000 --> 02:21:59.000]  Ну при этом понятно с учетом возможных обновлений.
[02:21:59.000 --> 02:22:01.000]  И идея, на самом деле, простая, действительно.
[02:22:01.000 --> 02:22:03.000]  Допустим, мне нужно найти какой?
[02:22:03.000 --> 02:22:05.000]  Не знаю, давайте второй ноль.
[02:22:07.000 --> 02:22:09.000]  Найти второй ноль.
[02:22:09.000 --> 02:22:11.000]  Как мы это делаем?
[02:22:11.000 --> 02:22:13.000]  Ну, смотрите, мы находимся в узле.
[02:22:13.000 --> 02:22:15.000]  В верхнем узле.
[02:22:15.000 --> 02:22:18.000]  Смотрите, если номер нуля, который меня попросили,
[02:22:18.000 --> 02:22:20.000]  он больше, чем общее количество нулей,
[02:22:20.000 --> 02:22:22.000]  то я сразу возвращаю, короче,
[02:22:22.000 --> 02:22:24.000]  какой-нибудь none,
[02:22:24.000 --> 02:22:26.000]  ну, минус один.
[02:22:26.000 --> 02:22:28.000]  Ну понятно, если общее количество нулей
[02:22:28.000 --> 02:22:30.000]  больше, чем ноль, который я запросил,
[02:22:30.000 --> 02:22:32.000]  то ничего делать не надо.
[02:22:32.000 --> 02:22:34.000]  Теперь мне нужно понять,
[02:22:34.000 --> 02:22:36.000]  а в какой ветке мне нужно этот кат и ноль искать?
[02:22:36.000 --> 02:22:38.000]  В левой или в правый?
[02:22:38.000 --> 02:22:40.000]  Меня попросили второй ноль.
[02:22:40.000 --> 02:22:42.000]  Я иду в левую ветку.
[02:22:42.000 --> 02:22:44.000]  Тут написано единица, что это означает?
[02:22:44.000 --> 02:22:46.000]  Это означает, что левая ветка меня не интересует.
[02:22:46.000 --> 02:22:48.000]  Тут всего один ноль, а меня попросили второй.
[02:22:48.000 --> 02:22:50.000]  Это значит, что я иду сюда,
[02:22:50.000 --> 02:22:52.000]  и что делаю?
[02:22:52.000 --> 02:22:54.000]  И ищу первый ноль.
[02:22:54.000 --> 02:22:56.000]  То есть, если у меня тут было,
[02:22:56.000 --> 02:22:58.000]  скажем, m нулей,
[02:22:58.000 --> 02:23:00.000]  и меня попросили k ты ноль,
[02:23:00.000 --> 02:23:02.000]  то в правой ветке я должен искать
[02:23:02.000 --> 02:23:04.000]  k минус m ты ноль.
[02:23:04.000 --> 02:23:06.000]  Согласны?
[02:23:06.000 --> 02:23:08.000]  Иду сюда, ну и так далее.
[02:23:08.000 --> 02:23:10.000]  Здесь то же самое.
[02:23:10.000 --> 02:23:12.000]  Смотрю, верно ли, что тут мне хватает,
[02:23:12.000 --> 02:23:14.000]  ну, что мне тут хватает количества нулей,
[02:23:14.000 --> 02:23:16.000]  смотрю, сколько нулей слева, смотрю, сколько нулей слева,
[02:23:16.000 --> 02:23:18.000]  и решаю, там, где мне продолжить поиск
[02:23:18.000 --> 02:23:20.000]  в левой ветке или в правой ветке.
[02:23:20.000 --> 02:23:22.000]  Вот.
[02:23:22.000 --> 02:23:24.000]  Хорошо.
[02:23:24.000 --> 02:23:26.000]  Гениально.
[02:23:26.000 --> 02:23:28.000]  Более сложная задача.
[02:23:30.000 --> 02:23:32.000]  Найти
[02:23:34.000 --> 02:23:36.000]  k ты ноль на отрезке.
[02:23:42.000 --> 02:23:44.000]  То есть, до этого задача формулировалась так.
[02:23:44.000 --> 02:23:46.000]  Мне дан весь массив, и мне надо во всем массиве
[02:23:46.000 --> 02:23:48.000]  найти k ты ноль.
[02:23:48.000 --> 02:23:50.000]  Теперь задача ставится другим образом.
[02:23:50.000 --> 02:23:52.000]  Есть конкретный отрезок,
[02:23:52.000 --> 02:23:54.000]  и вот на этом конкретном отрезке
[02:23:54.000 --> 02:23:56.000]  нужно найти k ты ноль.
[02:24:00.000 --> 02:24:02.000]  Что ищем?
[02:24:12.000 --> 02:24:14.000]  Вот этот?
[02:24:22.000 --> 02:24:24.000]  Мы идем в вершину и смотрим.
[02:24:24.000 --> 02:24:26.000]  Если в этой вершине
[02:24:26.000 --> 02:24:28.000]  чай, чайная,
[02:24:28.000 --> 02:24:30.000]  там есть ноль,
[02:24:30.000 --> 02:24:32.000]  тогда, естественно, запускаемся от левого в правый левый.
[02:24:38.000 --> 02:24:40.000]  Ну, сейчас, ну, допустим, я дошел как-то сюда,
[02:24:40.000 --> 02:24:42.000]  и я понимаю, что здесь,
[02:24:42.000 --> 02:24:44.000]  ну, у меня есть достаточно
[02:24:44.000 --> 02:24:46.000]  количества нулей, но при этом...
[02:24:48.000 --> 02:24:50.000]  Ну, то есть, меня попросили k ты ноль,
[02:24:50.000 --> 02:24:52.000]  и я знаю, что у меня тут k нулей.
[02:24:52.000 --> 02:24:54.000]  Это же не правда, что мне нужно искать поиск,
[02:24:54.000 --> 02:24:56.000]  в общем, нужно продолжать поиск здесь.
[02:24:56.000 --> 02:24:58.000]  У меня потенциальный k ты ноль может находиться здесь.
[02:24:58.000 --> 02:25:00.000]  Так.
[02:25:12.000 --> 02:25:14.000]  Давайте формально алгоритм.
[02:25:14.000 --> 02:25:16.000]  Как он работает? Что мы делаем?
[02:25:20.000 --> 02:25:22.000]  А как мы понимаем?
[02:25:22.000 --> 02:25:24.000]  Есть у нас в целом где?
[02:25:24.000 --> 02:25:26.000]  В целом на всем массиве или в целом здесь?
[02:25:34.000 --> 02:25:36.000]  Ну, хорошо. Допустим, находимся здесь,
[02:25:36.000 --> 02:25:38.000]  и мы понимаем, что вот суммарно вот здесь
[02:25:38.000 --> 02:25:40.000]  у меня есть достаточное количество нулей.
[02:25:46.000 --> 02:25:48.000]  Или даже так. Вот я нахожусь здесь,
[02:25:48.000 --> 02:25:50.000]  и я понимаю, что вот тут количества нулей мне не достаточно.
[02:25:52.000 --> 02:25:54.000]  Что тогда?
[02:25:54.000 --> 02:25:56.000]  Ну, это же ничего не значит.
[02:25:58.000 --> 02:26:00.000]  Наверное.
[02:26:04.000 --> 02:26:06.000]  Ну, короче, метод решения
[02:26:06.000 --> 02:26:08.000]  заключается к сведению к предыдущей задачи.
[02:26:08.000 --> 02:26:10.000]  Какой задачей свести предыдущий?
[02:26:10.000 --> 02:26:12.000]  Самый простой способ, который я знаю.
[02:26:12.000 --> 02:26:14.000]  Возможно, можно действительно...
[02:26:14.000 --> 02:26:16.000]  То есть, один из возможных еще вариантов
[02:26:16.000 --> 02:26:18.000]  это действительно разбить на вот такие фундаментальные узлы,
[02:26:18.000 --> 02:26:20.000]  посчитать общее количество нулей здесь,
[02:26:20.000 --> 02:26:22.000]  и тут уже дальше понятно,
[02:26:22.000 --> 02:26:24.000]  в каком узле нужно продолжить искать и так далее.
[02:26:26.000 --> 02:26:28.000]  Что?
[02:26:32.000 --> 02:26:34.000]  И как это нам поможет?
[02:26:38.000 --> 02:26:40.000]  А, в смысле, вот тут обновить?
[02:26:40.000 --> 02:26:42.000]  Ну, не хочется массив портить.
[02:26:42.000 --> 02:26:44.000]  А вдруг у меня много запросов таких будет?
[02:26:46.000 --> 02:26:48.000]  Смотрите, если я хочу найти
[02:26:52.000 --> 02:26:54.000]  кат и ноль здесь.
[02:26:56.000 --> 02:26:58.000]  Какой это ноль во всем массиве?
[02:27:04.000 --> 02:27:06.000]  Ну, в данном случае каплю с первой.
[02:27:06.000 --> 02:27:08.000]  А в общем случае?
[02:27:08.000 --> 02:27:10.000]  Ага, кат и ноль
[02:27:12.000 --> 02:27:14.000]  на b.
[02:27:14.000 --> 02:27:16.000]  Это то же самое,
[02:27:16.000 --> 02:27:18.000]  что k плюс
[02:27:20.000 --> 02:27:22.000]  количество нулей
[02:27:22.000 --> 02:27:24.000]  на
[02:27:26.000 --> 02:27:28.000]  а,
[02:27:28.000 --> 02:27:30.000]  и
[02:27:30.000 --> 02:27:32.000]  и
[02:27:32.000 --> 02:27:34.000]  и
[02:27:34.000 --> 02:27:36.000]  и
[02:27:36.000 --> 02:27:38.000]  и
[02:27:38.000 --> 02:27:40.000]  ноль а-1
[02:27:48.000 --> 02:27:50.000]  так, и
[02:27:54.000 --> 02:27:56.000]  на всем
[02:27:58.000 --> 02:28:00.000]  массиве.
[02:28:02.000 --> 02:28:04.000]  То есть, чтобы найти кат и ноль здесь,
[02:28:04.000 --> 02:28:06.000]  я могу просто посчитать количество нулей вот здесь.
[02:28:08.000 --> 02:28:10.000]  Но о количестве нулей и как
[02:28:10.000 --> 02:28:12.000]  посчитать количество sanity здесь, я думаю, понятно.
[02:28:12.000 --> 02:28:14.000]  Мы просто
[02:28:14.000 --> 02:28:16.000]  идем влево, влево и почитаем,
[02:28:16.000 --> 02:28:18.000]  ищем вот эти самые фундаментальные 65-мин JK,
[02:28:18.000 --> 02:28:20.000]  ну, то есть количество нулей мы считать умеем.
[02:28:20.000 --> 02:28:22.000]  Это мы решили в качестве нулевой задачи, вообще говоря.
[02:28:22.000 --> 02:28:24.000]  Да?
[02:28:24.000 --> 02:28:26.000]  То есть мы считаем количество нулей здесь, допустим n.
[02:28:26.000 --> 02:28:28.000]  И тогда кат и ноль на
[02:28:28.000 --> 02:28:30.000]  этом отрезке, это просто n плюс
[02:28:30.000 --> 02:28:32.000]  кат и ноль
[02:28:32.000 --> 02:28:40.400]  все массиве. Вот и все. Хорошо, на сегодня закончим.
