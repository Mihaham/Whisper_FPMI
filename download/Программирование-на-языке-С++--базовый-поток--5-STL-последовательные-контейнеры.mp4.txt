[00:00.000 --> 00:12.000]  Сегодня мы с вами начнем рассматривать темы, связанные с работой стандартной библиотеки C++.
[00:12.000 --> 00:20.000]  На самом деле это не совсем правда, потому что у нас лекционные занятия и практические занятия будут в целом по направленности немного отличаться.
[00:20.000 --> 00:41.000]  Но в целом глобальный план состоит в том, чтобы погрузиться чуть глубже в устройство стандартной библиотеки, понять как она работает, понять за счет чего она работает, почему она стандартная, почему она реализована на шаблонах, как она достигает того, что работает с практически любыми данными и так далее.
[00:41.000 --> 00:47.000]  Сегодня поговорим, и на самом деле в следующий раз тоже поговорим про контейнеры.
[00:47.000 --> 00:51.000]  Давайте для начала начнем с того, что определим, что такое контейнер.
[00:51.000 --> 00:56.000]  Контейнер – это такой тип данных, который обеспечивает хранение объектов других типов, а также интерфейс для доступа к ним.
[00:56.000 --> 00:58.000]  На самом деле все довольно просто.
[00:58.000 --> 01:09.000]  Контейнер – это просто в обыденном понимании, есть некоторое хранилище, туда вы можете что-то положить, вы оттуда можете что-то достать, вы можете узнать, есть ли в этом контейнере то, что вам нужно и так далее.
[01:09.000 --> 01:15.000]  Контейнер – это некая интерфейс, которая позволяет вам каким-то образом управлять набором данных.
[01:15.000 --> 01:17.000]  Что такое последовательный контейнер?
[01:17.000 --> 01:25.000]  Последовательный контейнер – это контейнер, который обеспечивает, грубо говоря, некоторую четкую последовательность хранения элементов.
[01:25.000 --> 01:33.000]  То есть, грубо говоря, вы всегда можете конкретный элемент, конкретный объект положить в нужное место вашей структуры данных.
[01:34.000 --> 01:40.000]  Грубо говоря, вы хотите, чтобы ваш элемент находился на самом вершине, на самом первой позиции вашей структуры данных, вы это можете сделать.
[01:40.000 --> 01:45.000]  Вы можете положить элемент в конец вашей структуры данных, можете положить элемент в середину структуры данных.
[01:45.000 --> 01:50.000]  То есть, в каждый момент времени вы всегда знаете, где, в каком конкретном месте находится ваш объект.
[01:50.000 --> 01:59.000]  Это зависит от последовательного добавления элементов, это зависит от того, в какой момент был добавлен элемент, ну так и иначе вы сами можете контролировать то, где какой элемент находится.
[01:59.000 --> 02:06.000]  Окей, то есть у вас все данные расположены строгой какой-то последовательности, вы точно знаете, что на второй позиции, допустим, находиться элемент х, на десятой позиции находится элемент у.
[02:06.000 --> 02:12.000]  И так далее, и более того, вы эту последовательность элементов можете контролировать, вы ее можете создавать самостоятельно.
[02:12.000 --> 02:15.000]  Вот в этом состоит суть последовательных контейнеров. Понятно?
[02:15.000 --> 02:22.000]  Вот. Ну проблема или просто представление в том, что на самом деле все контейнеры c++, как мы с вами впоследствии увидим, являются последовательными.
[02:22.000 --> 02:28.000]  Я natürlich не всегда interconnect훈ag, ну, потому что структура данных может как-то особину образом
[02:28.000 --> 02:30.600]  менять ваши элементы так, чтобы ей было удобно.
[02:30.600 --> 02:32.700]  Классический пример из алгоритмов, которые вы уже изучали,
[02:32.700 --> 02:37.000]  это, наверное, куча пирамид или то же самое
[02:37.000 --> 02:38.700]  динамическое дерево поиска. То есть я не могу просто так
[02:38.700 --> 02:40.500]  взять и вставить элементы в произвольное место.
[02:40.500 --> 02:45.100]  Потому что из-за этого нарушится структура моих данных.
[02:45.100 --> 02:47.500]  Например, в дереве поиска мы точно знаем, что все элементы,
[02:47.500 --> 02:49.700]  все элементы, которые меньше x находятся слева,
[02:49.700 --> 02:51.100]  все элементы, которые больше x находятся справа,
[02:51.100 --> 02:54.500]  в куче тоже есть свои иерархии. В общем, в этих структурах данных
[02:54.500 --> 02:56.700]  мы не можем положить элемент в то место, которое мы хотим.
[02:56.700 --> 02:58.900]  В последующих контейнерах мы так делать можем.
[02:58.900 --> 03:04.100]  Дальше, с вашего позволения, я пропущу несколько слайдов,
[03:04.100 --> 03:08.200]  просто сделаю такую обзорную экскурсию по контейнерам,
[03:08.200 --> 03:10.100]  потому что, наверное, все-таки имеет больше смысл
[03:10.100 --> 03:12.700]  рассматривать контейнеры на практике, знакомиться с их методами,
[03:12.700 --> 03:17.100]  их устройством и так далее уже вживую, решая практические сдачи
[03:17.100 --> 03:20.600]  или обсуждая на семинарах. Я остановлюсь на моментах,
[03:20.600 --> 03:26.200]  которые будут нам интересны в плане, скажем так, теоретического
[03:26.200 --> 03:31.900]  рассмотрения C++. Ну, в общем, все вы, наверное, знакомы уже
[03:31.900 --> 03:35.700]  с таким классом, как RA, то есть все его, я надеюсь, реализовывали
[03:35.700 --> 03:37.900]  в первом семестре. В общем, RA – это просто аналог
[03:37.900 --> 03:39.500]  обычного стишного массива, который представляет
[03:39.500 --> 03:42.400]  некоторый набор методов и некоторый более удобный
[03:42.400 --> 03:45.400]  интерфейс для работы с стишными массивами. То есть, их можно
[03:45.400 --> 03:47.500]  копировать в отличие от стишных массивов, можно передавать
[03:47.500 --> 03:50.700]  по значению, можно передавать по ссылкам. В общем, они стильные
[03:50.700 --> 03:54.500]  модные молодежные, их стоит использовать вместо обычных
[03:54.500 --> 03:58.500]  стишных массивов. Следующий контейнер, с которым, ну, так
[03:58.500 --> 04:00.300]  или иначе, мы с вами вроде как не знакомились ни на
[04:00.300 --> 04:04.200]  практике, ни на лекции, это контейнер-вектор. Вот если
[04:04.200 --> 04:07.000]  STD RA – это был контейнер, который являлся аналогом
[04:07.000 --> 04:10.500]  обычного стишного массива, то есть обычный массив, я
[04:10.500 --> 04:13.500]  имею в виду, который мы создаем просто задавая размер.
[04:16.500 --> 04:21.700]  RA 10. То есть, это массивы, фиксированные длины, в которых
[04:21.700 --> 04:23.700]  вот тут стоят константы времени компиляции. STD
[04:23.700 --> 04:26.700]  Vector – это, по сути, аналог динамического массива,
[04:26.700 --> 04:28.700]  который мы выделяем с помощью NU. То есть, если нам вдруг
[04:28.700 --> 04:31.700]  размер массива не известен на этапе компиляции, если
[04:31.700 --> 04:33.700]  он, допустим, вводится с клавиатуры, или если размер
[04:33.700 --> 04:36.700]  массива превышает допустимый размер стэковой памяти,
[04:36.700 --> 04:39.700]  то, напоминаю, в этих ситуациях мы используем динамическую
[04:39.700 --> 04:43.700]  память, и, собственно, Vector является полным его аналогом.
[04:43.700 --> 04:46.700]  Ну, причем со всеми приколюхами, которые вносит ООП в нашу
[04:46.700 --> 04:49.700]  жизнь. Это с деструктором, с конструктором компирования,
[04:49.700 --> 04:52.700]  и так далее, и так далее. Ну, собственно, как я уже
[04:52.700 --> 04:54.700]  сказал, с методами поближе познакомитесь на практических
[04:54.700 --> 04:57.700]  занятиях. Что тут больше всего интересного? Ну да,
[04:57.700 --> 04:59.700]  собственно, Vector в отличие от Array позволяет изменять
[04:59.700 --> 05:02.700]  данные, то есть, он позволяет добавлять элементы, позволяет
[05:02.700 --> 05:06.700]  удалять элементы. То есть, имеет методы pushback, popback,
[05:06.700 --> 05:09.700]  insert, erase в произвольное место массива. То есть, если Array
[05:09.700 --> 05:12.700]  – это массив с фиксированным размером, то Vector – это массив,
[05:12.700 --> 05:15.700]  который не имеет какой-то определенный фиксированный
[05:15.700 --> 05:23.700]  размер. Про устройство можем поговорить сейчас. В общем,
[05:23.700 --> 05:28.700]  как устроен Vector? Как Vector добивается того, что он позволяет
[05:28.700 --> 05:31.700]  довольно быстро добавлять элементы в конец, удалять элементы
[05:31.700 --> 05:35.700]  из конца? В общем, как он устроен в общих чертах? В общем,
[05:35.700 --> 05:40.700]  Vector на самом деле довольно хитрый тип, потому что,
[05:40.700 --> 05:45.700]  вот, смотрите, когда мы с вами выделяем память с помощью
[05:45.700 --> 05:52.700]  new int n, то при этом происходит следующее. У вас выделяется
[05:52.700 --> 05:58.700]  память для хранения n элементов, и при этом вам гарантируется,
[05:58.700 --> 06:02.700]  что вы можете использовать только эти n ячеек, которые вы
[06:02.700 --> 06:04.700]  видели. Ну и при этом, соответственно, все эти n ячеек, они
[06:04.700 --> 06:06.700]  создаются, то есть, они реально хранятся в памяти, то есть,
[06:06.700 --> 06:08.700]  тут реально создаются какие-то объекты. Ну, допустим, есть тут
[06:08.700 --> 06:12.700]  new int, какой-то тип, а вам гарантируется, что для каждого
[06:12.700 --> 06:14.700]  элемента будет вызван свой конструктор по умолчанию.
[06:14.700 --> 06:18.700]  Вот. Vector устроен несколько хитрее, потому что он учитывает
[06:18.700 --> 06:21.700]  то, что, в принципе, в теории он может в дальнейшем расширяться.
[06:21.700 --> 06:25.700]  То есть, на самом деле Vector устроен следующим образом.
[06:25.700 --> 06:31.700]  Значит, у него есть три принципиальные характеристики.
[06:31.700 --> 06:33.700]  Значит, первая характеристика, это, ну, собственно, понятное,
[06:33.700 --> 06:36.700]  делает указатель на сами данные. То есть, вот здесь у нас
[06:36.700 --> 06:39.700]  какой-то указатель P, то аналогом вот этого указателя P будет указатель
[06:39.700 --> 06:41.700]  на динамические данные, которые выделил Vector.
[06:41.700 --> 06:44.700]  А дальше уже начинаются хитрости, связанные вот с чем.
[06:44.700 --> 06:47.700]  Дело в том, что Vector на самом деле хранит памяти, ну,
[06:47.700 --> 06:49.700]  несколько больше, чем вам на самом деле нужно. Вот.
[06:49.700 --> 06:52.700]  Вот эта характеристика памяти, которую он на самом деле хранит,
[06:52.700 --> 06:55.700]  называется Capacity или вместимость.
[06:55.700 --> 06:58.700]  Вот. Это то, сколько элементов может вместить в тебя Vector
[06:58.700 --> 07:00.700]  без дальнейшего переведения памяти.
[07:00.700 --> 07:02.700]  То есть, мы с вами понимаем, что если вдруг у меня есть
[07:02.700 --> 07:05.700]  массив n элементов, и мне нужно добавить в этот массив еще один элемент,
[07:05.700 --> 07:08.700]  мне придется выделить новый кусок памяти большего размера,
[07:08.700 --> 07:10.700]  копировать старые данные в новый массив и, соответственно,
[07:10.700 --> 07:12.700]  добавить же элемент в освободившуюся ячейку.
[07:12.700 --> 07:15.700]  Вот. Vector поступает хитрее, Vector, в общем, ну, понятно дело,
[07:15.700 --> 07:17.700]  он не хочет постоянно делать переведения для каждого добавления,
[07:17.700 --> 07:21.700]  поэтому он хранит памяти чуть больше, чем ему нужно.
[07:21.700 --> 07:24.700]  Вот. И вот эта характеристика, сколько элементов он может вместить
[07:24.700 --> 07:26.700]  в себя без переведения памяти, называется Capacity.
[07:26.700 --> 07:28.700]  Вот. Вторая характеристика, это Size.
[07:28.700 --> 07:31.700]  Вот. В контексте данного примера, Size в этом случае равен n.
[07:31.700 --> 07:34.700]  Да, то есть, тут мы выделили память для n объектов,
[07:34.700 --> 07:36.700]  и тут реально хранится n объектов, вот.
[07:36.700 --> 07:38.700]  И, если в моем массиве, ну, то есть в моем векторе,
[07:38.700 --> 07:40.700]  хранится n элементов, то вот это…
[07:40.700 --> 07:42.700]  за вот это значение, сколько реального элементов
[07:42.700 --> 07:45.700]  хранится в моем векторе, значит, эта характеристика хранится
[07:45.700 --> 07:48.700]  в поле Size, да? нуили ее можно получить с помощью вызова
[07:48.700 --> 07:53.700]  соответствующего метода size.
[07:53.700 --> 07:56.700]  Вот. Ок. Да.
[07:56.700 --> 08:01.460]  Значит, ну соответственно, есть несколько методов,
[08:01.460 --> 08:03.700]  которые позволяют контролировать вот эти две характеристики,
[08:03.700 --> 08:08.580]  Вместимость массива и его размер. Одна характеристика, один метод называется
[08:08.580 --> 08:14.460]  резерв. Ну там какое-то количество элементов. Вторая характеристика называется resize.
[08:14.460 --> 08:24.460]  Resize вот n. Что делает резерв? Резерв никак и не изменяет размер, то есть резерв никак на самом
[08:24.460 --> 08:28.900]  деле не изменяет количество хранимых элементов. Все, что делает резерв, это увеличивает capacity до
[08:28.900 --> 08:37.020]  тех пор, пока он не будет удовлетворять условия, что capacity больше либо меньше, чем n. То есть
[08:37.020 --> 08:42.500]  резерв от n говорит следующее. Зарезерируй память для хранения n элементов. Ну как минимум n элементов,
[08:42.500 --> 08:50.140]  на самом деле может быть чуть больше. А resize говорит следующее. Выстави size значение n. Почему
[08:50.140 --> 08:54.980]  это приводит? Если у вас resize уменьшает размер, то вот эти элементы будут уничтожены. То есть у вас
[08:54.980 --> 09:00.260]  размер массива уменьшится, и эти элементы, которые тут находились, они будут уничтожены. Если
[09:00.260 --> 09:06.780]  resize наоборот увеличивает размер, размер вектора, то вот эти вот элементы будут достроены соответствующими
[09:06.780 --> 09:11.380]  значениями. Либо значениями по умолчанию, либо значениями, которые вы указали через запятую.
[09:11.380 --> 09:22.380]  Окей? То есть как у нас есть две характеристики, одна capacity, которая отвечает только за само хранилище,
[09:22.380 --> 09:26.220]  то есть, грубо говоря, вот у вас есть полка, и на полке есть свободные места. То есть полки
[09:26.220 --> 09:31.620]  не заняты, но теоретически их можно будет потом дополнить. И size, сколько реально вещей у вас
[09:31.620 --> 09:36.740]  хранится на этих самых полках. Ну и соответственно с помощью функции reserve вы можете либо увеличить
[09:36.740 --> 09:40.620]  вместимость, докупить новый шкаф, доделать новые полки и так далее. А с помощью resize вы
[09:40.620 --> 09:47.260]  можете либо убрать какие-то вещи с полки, либо добавить какие-то вещи, которые реально хранятся
[09:47.260 --> 09:59.140]  в векторе. Окей? Пока это пропустим, в общем, что хотелось бы, на чем бы хотелось сегодня заострить
[09:59.140 --> 10:06.660]  внимание. Сегодня хотелось бы поговорить про следующие интересные методы вектора и поставить
[10:06.660 --> 10:11.500]  некоторую проблему, которую, к сожалению, на нашем уровне развития мы пока решить не можем,
[10:11.500 --> 10:18.060]  но, надеюсь, к концу сегодняшней лекции научимся это делать. Смотрите, в чем проблема. Значит,
[10:18.060 --> 10:32.140]  как я уже сказал, у вектора есть такой замечательный метод как pushback. Что делает метод pushback?
[10:32.140 --> 10:43.220]  Pushback просто берет и добавляет элемент в конец вектора. Но, опять же, если вектору памяти хватает,
[10:43.220 --> 10:50.980]  если capacity больше, чем size, то он просто добавляет новый элемент концу size. Если же вместимости
[10:50.980 --> 10:54.860]  не хватает, то вектор переводеляет память. Естественно, все это скрыто от ваших глаз,
[10:54.860 --> 10:59.540]  то есть он внутри себя переводеляет память, копирует старые элементы, добавляет элемент.
[10:59.540 --> 11:06.500]  Смотрите, в чем тут может быть проблема. Проблема может быть следующим. Давайте посмотрим,
[11:06.500 --> 11:11.780]  например, представь себе, что у меня есть вектор векторов. Такой, естественно, может быть. У меня
[11:11.780 --> 11:15.500]  может быть динамический массив, который внутри себя хранит динамические массивы. Нормально.
[11:15.500 --> 11:21.340]  Вот, вектор векторов. Что я делаю? Допустим, в какой-то момент я в этот вектор векторов vw хочу
[11:21.340 --> 11:27.540]  добавить очередной вектор. Как я это делаю? Я говорю vw.pushback std vector int, допустим, 10.1.
[11:27.540 --> 11:34.220]  Добавляю мой вектор, еще один вектор размера 10. Либо с помощью метода insert в начало вектора
[11:34.220 --> 11:39.700]  добавляю, в начало вектора тоже добавляю какой-то другой вектор. Что тут проблема? Давайте посмотрим
[11:39.700 --> 11:45.740]  вот на этот код и попробуем пошагать. И попробуем по шагам понять, что он делает. Вот я написал,
[11:45.740 --> 12:02.060]  vw.pushback std vector int, 10.1. Ну, что такое вектор 10.1? Это вектор размера 10, который хранит,
[12:02.060 --> 12:06.940]  короче, это вектор, который хранит 10 единиц. То есть, конструктор вектора, который принимает
[12:06.940 --> 12:11.900]  два параметра, он принимает первым параметром размер, а вторым параметром, чем эти элементы
[12:11.900 --> 12:18.300]  нужно заполнить. То есть, тут я создал вектор из 10 единиц и запихал его в конец вектора vw. Давайте
[12:18.300 --> 12:27.340]  посмотрим, что при этом происходит. При этом происходят следующие вещи. Первое. Создается
[12:27.340 --> 12:31.780]  временный вектор, согласны? То есть, pushback это функция, функция передает какой-то временный
[12:31.780 --> 12:47.100]  объект. Этот временный объект должен создаться, согласна? Создание. Создание вектор 10.1. Второй
[12:47.100 --> 12:56.300]  пункт. Что происходит дальше? Ну, а дальше этот вектор передается функцию pushback. Да, pushback
[12:56.300 --> 13:19.780]  его принимает и что делает? Ну, заполняет. Заполняем ячейку vw этим вектором. Вопрос. Как
[13:19.820 --> 13:27.540]  вы думаете, что будет вызовано на втором шаге? Как будет создана эта самая ячейка? С помощью чего?
[13:27.540 --> 13:39.860]  Смотри, когда создается объект, что происходит? Что происходит при создании любого объекта?
[13:39.860 --> 13:50.140]  Что? Нет, при создании объекта аллокация не всегда происходит. Что? Вызывается конструктор.
[13:50.140 --> 13:54.660]  Чтобы создать произвольный объект, в частности, вектор должен быть вызван конструктор, согласны?
[13:54.660 --> 14:06.380]  То есть, заполнение ячейки неизбежно приведет к тому, что тут вызовется конструктор.
[14:06.380 --> 14:16.060]  То есть, заполнение ячейки на самом деле вызовет конструктора. Вопрос. Какой конструктор будет
[14:16.060 --> 14:22.460]  вызван? Вот я передал в pushback временный объект и, соответственно, с помощью этого временного объекта
[14:22.460 --> 14:32.220]  мне нужно заполнить ячейку. Какой конструктор в этом случае будет вызван? Перемещение, да. То есть,
[14:32.220 --> 14:39.420]  если мы создаем объект, скажем так, с помощью временного значения, то, соответственно, в этом
[14:39.420 --> 14:47.500]  случае у нас вызывается конструктор перемещения. Перемещение я. То есть, происходят две вещи.
[14:47.500 --> 14:53.180]  Смотрите, тут уже возникает проблема. В чем? Мы создаем временный вектор, а потом этот временный
[14:53.180 --> 15:00.300]  вектор перемещаем внутри другого вектора. Возникает некоторая проблема с тем, а зачем мы делаем два
[15:00.300 --> 15:05.580]  действия? Смотрите, мы создаем вектор, а потом... То есть, мы создали вектор только для того, чтобы
[15:05.580 --> 15:13.020]  его взять и переместить в нужное место. Согласитесь, это довольно странно с обычной точкой зрения.
[15:13.020 --> 15:18.580]  Опять же, давайте вернемся к примеру со шкафом. Вот представьте, вот вы взяли какую-то вещь, сначала
[15:18.580 --> 15:21.940]  ее положили в какое-то временное хранилище, а потом из этого хранилища взяли и переместили
[15:21.940 --> 15:25.740]  внутрь вашего шкафа. Ну нет же. То есть, если нам нужно, чтобы что-то появилось внутри шкафа,
[15:25.740 --> 15:29.140]  мы просто берем эту вещь и кладем сразу туда. То есть, вообще говоря, хотелось бы, чтобы этот вектор
[15:29.140 --> 15:38.780]  просто-напросто за один шаг взял и создался внутри нужной ячейки. Согласны? Вот. На самом деле,
[15:38.780 --> 15:43.940]  тут еще более... с этим pushback есть еще одна более страшная проблема, которая заключается в следующем.
[15:43.940 --> 15:48.540]  Теперь давайте представим, что вектор хранит не вектора, а вектор хранит какой-то тип A,
[15:48.540 --> 15:59.180]  у которого нет конструктора перемещения. Допустим, A10.1.
[16:06.180 --> 16:11.900]  Вот просто вот я для своего класса A сказал, что этот мой класс перемещать нельзя. То есть,
[16:11.900 --> 16:23.140]  конструктор от A10.1 равно delete. Вопрос. Что тогда будет происходить на втором этапе? Да,
[16:23.140 --> 16:27.660]  смотрите, если объект нельзя переместить, тогда он будет копирован. А копирование, в общем случае,
[16:27.660 --> 16:31.740]  мы с вами понимаем, оно работает долго. То есть, смотрите, что-то произошло. Я создал временный
[16:31.740 --> 16:36.220]  объект, а потом взял этот объект и трачу время на клонирование этого объекта, чтобы потом создать
[16:36.220 --> 16:41.380]  его внутри вектора. То есть, если брать аналогию со шкафа, вы берете вещь, вы хотите, о, я хочу,
[16:41.380 --> 16:45.380]  чтобы эта вещь оказалась у меня в шкафу. А давайте я куплю еще одну вещь, пусть одна вещь лежит у меня
[16:45.380 --> 16:51.460]  в руках, а вторая вещь окажется в шкафу. Но это, естественно, работает не так. Еще более страшная
[16:51.460 --> 17:06.020]  проблема. Теперь давайте я запрещу копирование. Вот. У меня есть тип A, у которого нет ни конструктора
[17:06.020 --> 17:10.780]  копирования, ни конструктора перемещения. Вот. То есть, объекты типа A нельзя ни копировать,
[17:10.780 --> 17:14.580]  ни перемещать. Вот. Их можно только создавать. То есть, я могу создать просто переменные этого типа. Вот.
[17:14.580 --> 17:22.780]  Но при этом копировать и перемещать друг друга нельзя. К чему это приведет? Да, в принципе,
[17:22.780 --> 17:28.180]  тогда pushback к этому вектору применим не будет. То есть, если вектор хранит элементы, которые нельзя
[17:28.180 --> 17:34.140]  копировать и перемещать, тогда окажется, что их просто-напросто их нельзя будет хранить в моем
[17:34.140 --> 17:44.260]  контейнере. Но это же какая-то ерунда. Почему? Потому что кажется, что если мне нужно взять
[17:44.260 --> 17:50.580]  какую-то вещь и просто-напросто положить ее в шкаф, я как бы хочу уметь это делать. То есть,
[17:50.580 --> 17:56.380]  какая разница? Вектор, какая тебе разница? Умею я копировать элементы? Не умею копировать
[17:56.380 --> 18:03.740]  элементы. В общем, кажется, что это нужно суметь сделать. Ну, опять же, при условии, что у нас не
[18:03.740 --> 18:10.100]  происходит никаких переведений, перелокации памяти. На самом деле, возможно, это, в принципе,
[18:10.100 --> 18:16.860]  как-то не сработает. Ну ладно. В общем, проблема ясна. То есть, так или иначе, у меня есть лишнее
[18:16.860 --> 18:22.060]  копирование либо лишнее перемещение. То есть, у меня есть явное требование на то, чтобы, в общем,
[18:22.060 --> 18:28.500]  я мог вот эти вот временные объекты либо копировать, либо перемещать. Согласны? Вот. И в любом
[18:28.500 --> 18:34.380]  случае есть некий лишний шаг в виде создания объекта, а потом его дальнейшего копирования
[18:34.380 --> 18:40.220]  перемещения. Вот. Соответственно, для решения этой проблемы в векторе есть отдельный метод,
[18:40.220 --> 18:45.460]  который называется emplace. На самом деле, он появился в C++11, но в целом мы уже не делаем разниц
[18:45.660 --> 19:03.300]  обычного C++11. В общем, у вектора есть метод emplaceback, который устроит хитрым образом. Что он
[19:03.300 --> 19:12.100]  делает? Значит, смотрите, pushback принимает объект, который нужно вставить в мой вектор.
[19:12.100 --> 19:19.980]  Emplaceback принимает параметры конструктора, которыми нужно создать объект в нужном месте в памяти.
[19:19.980 --> 19:28.820]  Вот. Сравните вот эту запись и вот эту запись. Что я сделал тут? Тут мне пришлось создать объект
[19:28.820 --> 19:34.340]  для дальнейшего перемещения или копирования в вектор. Здесь же я просто обскал, вектор,
[19:34.340 --> 19:41.220]  возьми вот эти параметры, а потом в нужную ячейку просто создай нужный элемент с этими
[19:41.220 --> 19:52.020]  параметрами. У вектора в треугольной скобке я указываю тип. То есть у меня каждый контейнер
[19:52.020 --> 19:56.980]  хранит элементы определенного типа. Вот. Поэтому если у меня вектор, допустим, хранит элементы типа A,
[19:56.980 --> 20:08.580]  STD, вектор от A, vw. Вот. То когда я делаю vw emplaceback и передаю ему параметры, он просто-напросто
[20:08.660 --> 20:19.660]  берет ячейку нужную и с этими параметрами 10.1 создает нужный элемент. Окей? Emplace в переводе
[20:19.660 --> 20:24.300]  это просто разместить. Вот. То есть как бы возьми эти параметры и размести объект сразу в нужном месте.
[20:24.300 --> 20:29.620]  То есть тут я избавляюсь просто. То есть тут, если у меня тут было создание объекта и потом копирование
[20:29.620 --> 20:39.260]  или перемещение, то тут у меня просто-напросто выполняется один шаг. Да. Создание, ну я так напишу,
[20:39.260 --> 20:48.180]  A10.1. Ну вот тут. В нужные ячейки памяти сразу. Все. Одно действие. Все. Я сделал, что хотел. Создал
[20:48.180 --> 20:56.820]  именно в той ячейке, то есть именно в конце вектора нужный мне элемент. Понятно? Вот. Значит, это было
[20:56.820 --> 21:03.300]  предисловие на самом деле. Значит, о чем бы я на самом деле хотел поговорить. Давайте посмотрим на EmplaceBack.
[21:03.300 --> 21:12.820]  Вот. Попрос, который я бы хотел рассмотреть, он следующий. Вот смотрите. С pushback на самом деле более-менее
[21:12.820 --> 21:17.900]  все понятно. Ну, то есть у вас есть задание, в первом задании у вас есть задание string, то есть
[21:17.900 --> 21:22.420]  реализовать свою строку, и в принципе там тоже есть метод pushback, и с ним все понятно. То есть pushback
[21:22.420 --> 21:27.220]  принимает один объект, и этот объект мне нужно сделать так, чтобы этот объект оказался в конце
[21:27.220 --> 21:33.580]  моего контейнера. Все довольно просто и понятно. Теперь. Давайте я вам скажу следующее. Давайте с вами
[21:33.580 --> 21:39.620]  реализуем метод EmplaceBack. Да, то есть ну с pushback все понятно, но не интересно, там если памяти хватает,
[21:39.620 --> 21:43.060]  то просто-напросто заполняем последнюю ячейку, если памяти не хватает, то переведем память,
[21:43.060 --> 21:49.220]  и так далее, и так далее. Все. Это уже скучно. Идем сюда. Давайте реализуем EmplaceBack. Никто не
[21:49.220 --> 21:55.100]  против. Давайте попробуем написать. Вот, допустим, я написал вектор, а вектор у меня имеет шаблонный
[21:55.100 --> 22:03.940]  параметр, шаблонный параметр t, и я начинаю писать. Ну, пусть EmplaceBack возвращает void, пишу EmplaceBack,
[22:03.940 --> 22:33.300]  и что? Что принимает EmplaceBack? Да, смотри, то есть я на самом деле утверждаю, что мы вообще не
[22:33.300 --> 22:42.540]  знаем, что тут будет передано. Почему? Потому что t это произвольный тип, абсолютно произвольный
[22:42.540 --> 22:49.500]  тип. Вот. Знаю ли я, как создается абсолютно произвольный тип? Нет. У типа может быть,
[22:49.500 --> 22:55.140]  ну, во-первых, существует большое количество конструкторов. То есть есть конструктор копирования,
[22:55.140 --> 22:58.500]  есть конструктор перемещения, есть конструктор одного аргумента, двух аргументов, трех аргументов,
[22:58.500 --> 23:05.380]  и так далее. То есть, с какими параметрами будет вызываться EmplaceBack, я не знаю. Вот. Более того,
[23:05.380 --> 23:09.300]  я не знаю, какие в принципе конструкты у меня существуют для типа t. Да? То есть, смотрите,
[23:09.300 --> 23:15.860]  еще раз, идея. С pushBack все понятно. Почему pushBack простой и тупой? Потому что pushBack принимает
[23:15.860 --> 23:21.500]  конкретный объект. Вот, конкретный объект типа t. То есть, если у меня шаблонный параметр t,
[23:21.500 --> 23:30.020]  он принимает конкретный объект типа t. EmplaceBack вообще не знает, что ему передадут. Даже если предположить,
[23:30.020 --> 23:35.300]  что тип t известен заранее. Не знаю, у вас тип не тоже шаблон, а вот вам прям заранее известен тип.
[23:35.300 --> 23:40.940]  Все равно, для конкретного типа t может существовать огромное количество конструкторов. Да? И какой
[23:40.940 --> 23:48.500]  конкретный конструктор будет вызван для EmplaceBack, непонятно. Что делать? Как написать функцию,
[23:48.500 --> 23:52.780]  которая может принимать все что угодно. То есть, не то, что все что угодно, а все что угодно,
[23:52.780 --> 23:59.660]  причем в произвольном количестве. Вот на этот вопрос мы сегодня постараемся ответить. Все,
[23:59.660 --> 24:05.660]  предусловие закончено, давайте переходить к теме. Тема шаблоны с переменом числом аргументов.
[24:05.660 --> 24:14.700]  Ну, собственно, начну опять же с... Еще раз повторю, проблема. Вот, допустим, у нас возникло желание
[24:14.700 --> 24:19.020]  написать что-то наподобие EmplaceBack. То есть, чего-то, что может принимать непонятное количество
[24:19.020 --> 24:23.580]  параметров. То есть, количество параметров может быть равно как 2, как так, 3, там, 4, 5 и так далее.
[24:23.580 --> 24:28.700]  Ну, собственно, тут предоставили еще какие-то примеры. Например, функция printf. То есть,
[24:28.700 --> 24:35.700]  функция из библиотеки C. Но в целом эта функция, она утверждает, что она может принимать произвольное
[24:35.700 --> 24:39.660]  количество аргументов. То есть, первым аргументом передаем ей формат строку, а остальные аргументы
[24:39.660 --> 24:44.580]  передаем. Ну, собственно, дальше мы передаем аргументы, которые соответствуют этой формат строке.
[24:44.580 --> 24:49.980]  При этом формат строка может содержать какое угодно количество специальных символов. Ну,
[24:49.980 --> 24:54.420]  соответственно, printf должен уметь принимать в себя произвольное количество параметров. Второй
[24:54.420 --> 24:58.460]  пример, с которого вы, возможно, тоже знакомы, это функция makeUnique. Вот makeUnique, она, по сути,
[24:58.460 --> 25:03.980]  устроена примерно так же, как EmplaceBack. То есть, как устроен makeUnique? makeUnique это шаблонная
[25:03.980 --> 25:08.060]  функция, которая в качестве своего шаблонного параметра принимает тип умного указателя,
[25:08.060 --> 25:13.100]  который нужно создать. Ну, в данном случае makeUnique от A это умный указатель UniquePTR,
[25:13.100 --> 25:18.220]  который указывает на объект типа A. Вот. Ну, и в своих параметрах принимает аргументы конструктора,
[25:18.220 --> 25:34.900]  с которыми нужно создать этот элемент. Ну, то есть, makeUnique от A, допустим, 1, 2, по сути, аналогия
[25:34.900 --> 25:45.740]  с привычным нам newA от 1, 2. То есть, с makeUnique точно такая же проблема. makeUnique принимает просто
[25:45.740 --> 25:49.540]  параметры конструктора, но при этом, естественно, заранее мы не знаем, а сколько этих параметров
[25:49.540 --> 25:56.580]  будет, какие это параметры, какой тип они имеют, и так далее, и так далее. Вот. Собственно, давайте
[25:56.580 --> 26:01.540]  посмотрим, что можно предложить в качестве решений в этих ситуациях. Ну, этот слайд, на самом
[26:01.540 --> 26:07.300]  деле, просто чисто для такой исторической справки. В общем, как с этим всем справлялись в языке C,
[26:07.300 --> 26:16.340]  то есть, как были устроены функции в языке C. Значит, в языке C существовался специальный аргумент,
[26:16.340 --> 26:22.060]  многоточие, ну, или эллипсис, который указывался в конце параметров функции. Ну, в общем, если мне
[26:22.060 --> 26:27.300]  нужно было написать функцию, которая печатает int, то я мог, например, сделать так. Передать ей
[26:27.300 --> 26:31.220]  на вход, ну, собственно, поток, в который нужно вывести эти самые int, дальше, например, указать
[26:31.220 --> 26:34.980]  количество int, в который нужно вывести, ну, и дальше указать аргумент многоточия. Ну, собственно,
[26:34.980 --> 26:39.580]  в этом аргументе многоточия у меня бы, по сути, это аргумент многоточия означал принять произвольное
[26:39.580 --> 26:45.500]  количество параметров, да, сколько угодно. Вот. Дальше нужно было, в общем, совершить некоторые, там,
[26:45.500 --> 26:50.100]  приседания, некоторую магию. Например, нужно было создать специальный аргумент violist, который,
[26:50.100 --> 26:53.700]  собственно, ну, это специальный такой тип, который умеет работать с этим самым произвольным количеством,
[26:53.700 --> 26:58.900]  произвольным количеством параметров. Дальше нужно было вызвать macros va start, в котором нужно
[26:58.900 --> 27:04.020]  было передать вот этот самый объект violist и передать параметр, который предшествует этому
[27:04.020 --> 27:08.260]  самому многоточию. Вот. Ну, и дальше использовать, ну, и дальше для получения этих самых аргументов
[27:08.260 --> 27:14.340]  нужно было использовать macros va arc, ну, собственно, с параметром вот этого, вот это самое violist,
[27:14.340 --> 27:20.900]  и дальше тип, тип аргумента, который я хочу получить. Вот. Ну, то есть, тут в целом, как бы,
[27:20.900 --> 27:28.500]  тут все для примера, в общем, в языке C все работало примерно, примерно вот так. Вот. В чем тут
[27:28.500 --> 27:33.340]  проблема? Проблема заключается в том, что, ну, давайте, кто-нибудь понимает, в чем проблема вот этого кода?
[27:33.340 --> 27:43.260]  Почему этот код небезопасен? Да. Да, во-первых, непонятно количество параметров. То есть, тут мы,
[27:43.260 --> 27:46.900]  как бы, верим, надо посмотреть, у меня есть параметр int n, который вроде как отвечает за количество
[27:46.900 --> 27:50.740]  параметров, которые я передал. И вообще говоря, мы тут просто-напросто верим, что пользователь не
[27:50.740 --> 27:57.580]  ошибется. Мы верим, что пользователь передаст нам нужное количество параметров n. Вот. То есть,
[27:57.580 --> 28:00.940]  это проблема. То есть, тут мы не можем узнать, сколько параметров нам реально было передано.
[28:00.940 --> 28:11.380]  Еще проблемы. Да. Да, вот, смотрите, у меня есть специальная функция va arc, которая, это не функция,
[28:11.380 --> 28:15.740]  простите, это macros, вот, которая принимает второй параметр, и вторым параметром я должен явно
[28:15.740 --> 28:19.780]  указать, какой тип я принимаю, да, какой тип я ожидаю. Вот. То есть, если мне вдруг пользователь
[28:19.780 --> 28:25.540]  передал неожиданно, то есть, не тот тип, который я там указал, вот, или вдруг указал, то случайность
[28:25.540 --> 28:31.300]  не тот тип, то, соответственно, получаю неопределенное поведение. Вот. Ну и вообще говоря,
[28:31.300 --> 28:35.580]  этот код довольно многословен, да, то есть, необходимо там завести va list, va start, не забыть
[28:35.580 --> 28:41.020]  про va end. Да, кстати, я сказал, что после va start нужно обязательно сделать va end. Вот. Ну и,
[28:41.020 --> 28:44.540]  собственно, получать все аргументы с помощью va arc. В общем, это не безопасно, это неудобно,
[28:44.540 --> 28:53.660]  и вообще c style. Вот. Значит, что у нас есть в языке C++? А точнее, в языке C++, начиная с 11
[28:53.660 --> 29:03.380]  стандарта. C++ предоставляет шаблоны с переменным числом аргументов. Давайте разбираться с интоксисом.
[29:08.940 --> 29:13.300]  Значит, если в C++ хочется написать функцию, которая может принимать произвольное количество
[29:13.300 --> 29:25.380]  аргументов, мы пишем шаблон с переменным числом аргументов. Значит, как они выглядят? Значит,
[29:25.380 --> 29:31.300]  если нам нужен, если мы хотим передать функцию произвольное количество аргументов, причем непонятно
[29:31.300 --> 29:37.740]  какого типа, мы пишем следующий синтаксис. Class многоточий, ну и даже каким-то образом называем
[29:37.740 --> 29:44.100]  вот эти самые аргументы. Arcs. Что означает эта запись? Эта запись означает, что шаблонный
[29:44.100 --> 29:53.940]  параметр arcs будет являться так называемым пакетом параметров. Пакет параметров. То есть,
[29:53.940 --> 29:59.340]  вот в этом аргументе, вот в этом аргументе будет храниться список типов, которые я передал
[29:59.340 --> 30:14.900]  функцию. Вот. Дальше. Я пишу функцию print и указываю следующее. Например, указываю arcs многоточия
[30:14.900 --> 30:24.460]  arcs. Что означает эта запись? Эта запись означает следующее, что моя функция может принимать
[30:24.460 --> 30:28.540]  произвольное количество параметров типов. То есть, раньше я шаблонный параметр указывал явно,
[30:28.540 --> 30:32.340]  класс T, класс U, класс V и так далее. Тут я говорю, что этих шаблонных параметров может быть сколько
[30:32.340 --> 30:36.780]  угодно. На самом деле хоть 0, хоть 1, хоть 2 и так далее. Вот это многоточие принимает, давайте так
[30:36.780 --> 30:43.420]  напишу. От нуля до примерно бесконечности, с вами там есть естественно какое-то ограничение. Я не
[30:43.420 --> 30:50.660]  помню сколько, вам хватит. Вот. Шаблонная функция принимает произвольное количество шаблонных
[30:50.660 --> 30:59.860]  параметров. Вот. Ну и, собственно, эти параметры передаются в функцию вот таким образом. Вот. Вот
[30:59.860 --> 31:05.380]  это шаблонный, вот это пакет параметров типов, а вот эта вот переменная, которую я создаю arcs,
[31:05.380 --> 31:11.620]  тоже является пакетом параметров, но пакетом параметров этих самых, ну значений передных
[31:11.620 --> 31:17.820]  функций. Вот. То есть, пока можно считать, ну пока можно, в общем, про это думать так, что вот это,
[31:17.820 --> 31:22.460]  это просто некоторая сущность языка C++, которая хранит внутри себя в виде списка
[31:22.460 --> 31:29.500]  типы, которые переданы в эту функцию. Вот это, это некоторая сущность языка C++,
[31:29.500 --> 31:36.060]  которая внутри себя хранит список аргументов, которые в эту функцию переданы. Окей? Да.
[31:36.060 --> 31:52.940]  После void print. Просто название функции. Вот. Вот эта функция print, давайте перейдем примеры.
[31:52.940 --> 32:04.180]  Вот эта функция print может работать вот так. Тогда arcs, это будет пустой список, ну и arcs с
[32:04.180 --> 32:14.980]  маленькой буквой тоже будет пустой список. Print может принимать, например, 1 и true. Вот.
[32:14.980 --> 32:32.940]  Тогда arcs, это будет список из int и bool, а arcs с маленькой буквой, это будет 1 и true. Окей?
[32:32.940 --> 32:42.460]  Вот. Ну, когда я говорю список, на самом деле, это не совсем список в смысле языка C++,
[32:42.460 --> 32:47.420]  в смысле аргументов, это просто там, некоторые пакеты, которые в жатом виде хранит вот такую вот
[32:47.420 --> 32:59.340]  информацию. Вот. Окей? Вот общий синтаксис такой. Давайте, давайте разбираться. Собственно,
[32:59.340 --> 33:03.180]  ну вот эти вот самые пакеты параметров, да, класс, многоточки и так далее, можно использовать,
[33:03.180 --> 33:10.220]  естественно, не только в функциях, но и в шаблонах классов. Вот. Но, в общем, стоит помнить по следующую
[33:10.220 --> 33:18.700]  проблему. Дело в том, что вот эти вот пакеты параметров, они работают жадным образом. Что это
[33:18.700 --> 33:23.500]  означает? Это означает, что как только вы начали заполнять пакет, C++ не остановится его заполнять до
[33:23.500 --> 33:31.260]  тех пор, пока он не прочитает все типы. Значит, примеры следующие. Ну, давайте посмотрим на первый
[33:31.260 --> 33:35.780]  пример. Вот тут у меня есть шаблонная функция function, которая принимает шаблонный тип T и
[33:35.780 --> 33:39.820]  дальше произвольное количество других типов. То есть, эта шаблонная функция принимает хотя бы
[33:39.820 --> 33:44.780]  один шаблонный параметр. Окей? То есть, функция, которая принимает хотя бы один шаблонный параметр,
[33:44.780 --> 33:48.620]  записывается вот так. Я бы говорю, что она принимает какой-то шаблонный параметр T и дальше
[33:48.620 --> 33:53.900]  произвольное количество других параметров. Вот. Ну и функция принимает аргумент TX и дальше
[33:53.900 --> 33:58.540]  произвольное количество других аргументов. Вот. Соответственно, что происходит? Если я функцию вызову
[33:58.540 --> 34:03.620]  от 0 и 0.0, то в качестве типа T выведется тип int, естественно. В качестве пакета параметров
[34:03.620 --> 34:08.820]  args выведется пакет, в котором хранится только тип double. Вот. Если я функцию function вызову явно
[34:08.820 --> 34:15.540]  от трех int, то, соответственно, у меня в качестве параметра T выведется тип int. В качестве параметра,
[34:15.540 --> 34:19.580]  в качестве пакета параметра выведется, ну, собственно, да, тоже выведут типа int-int,
[34:19.580 --> 34:25.100]  потому что я в треугольных скобках явно указал. Вот. Ну и, собственно, вот параметры будут переданы
[34:25.100 --> 34:31.380]  в функцию, которая принимает три int. Тут все понятно, да? То есть, первый шаблон параметра ушел в T,
[34:31.380 --> 34:37.620]  а остальные шаблонные параметры ушли в args. Вот. Теперь более хитрые примеры. Смотрите, а что
[34:37.620 --> 34:42.540]  произойдет, если я вот в шаблонном описании, вот в этом template, поменяю местами класс T и класс args?
[34:42.540 --> 34:48.340]  В этом случае произойдет следующая странная история. Ну, по-прежнему, если я вызову function
[34:48.340 --> 34:55.020]  от 0 и 0.0, то в качестве типа T, точнее, в качестве типа, да, смотрите, как это работает, да, function
[34:55.020 --> 35:01.420]  от 0 и 0.0, компилятор смотрит на то, как объявлена функция function, и компилятор видит, что в функции
[35:01.420 --> 35:06.460]  function первый параметр относится к типу T, поэтому, ну, там 0, поэтому тип T будет выведен как int. Вот.
[35:06.460 --> 35:11.940]  Но остальные параметры — это args. Соответственно, в args у меня указан 0.0, да, поэтому это тип double,
[35:11.940 --> 35:19.300]  то есть пакет параметров типов, args хранит только значение double. Теперь начинаются странности. Что
[35:19.300 --> 35:24.380]  произойдет, если я в этом случае вызову function от трех int? В этом случае произойдет следующее. В
[35:24.380 --> 35:28.700]  этом случае произойдет проблема, про которую я сказал. Проблема заключается в том, что пакеты
[35:28.700 --> 35:32.580]  параметров типов, они работают жадным образом. То есть, как только вы начнете заполнять пакет,
[35:32.580 --> 35:37.100]  этот пакет никогда не закончит свое заполнение, ну, до тех пор, пока вы не закончите, пока,
[35:37.100 --> 35:41.380]  соответственно, вы не встретите треугольную скобку. Когда я написал function int int int, вот в
[35:41.380 --> 35:45.940]  этом случае компилятор заявит об ошибке, скажет, что, погодите, ну, я понял, да, пакет нужно
[35:45.940 --> 35:52.580]  заполнить тремя intами, а чем нужно заполнить t? Непонятно. То есть, вот, я написал function int int int,
[35:52.580 --> 35:56.460]  и, собственно, в качестве первого шаблонного параметра указан класс многоточия args, и, собственно,
[35:56.460 --> 36:00.420]  компилятор начал заполнять этот самый args. Он взял int, взял int, взял int. Все, пакет параметров
[36:00.420 --> 36:05.300]  закончен, все, точнее, параметры закончились, значит, описание пакета закончено. Дальше он хочет
[36:05.300 --> 36:10.700]  понять, а чему равен тип t, и тут он поймет, что, ну, как бы, погодите, ну, тип t, типу t ничего
[36:10.700 --> 36:15.620]  не соответствует, да, потому что все ушло в args. Вот, в args три параметра, вот, в пункцию предали
[36:15.620 --> 36:25.580]  три параметра, значит, тип t невозможно вывести. Что? Смотрите, в первом случае у вас в описании
[36:25.580 --> 36:34.180]  template class t. Class t идет в начале. Когда вы пишете, давайте так. В первом случае у вас написан template
[36:38.180 --> 36:50.860]  class t, дальше class многоточия args. Ну, там void f. Ну, там неважно что. В этом случае, когда вы пишете f от int,
[36:50.860 --> 36:59.660]  int. В этом случае компилятор смотрит сюда и понимает, что вы вызываете функцию f с
[36:59.660 --> 37:04.620]  конкретными шаблонными параметрами. Ну, компилятор ставит соответствие вот этому списку, вот этот
[37:04.620 --> 37:11.340]  список. И, собственно, что он понимает? Ага, первый элемент списка это t, поэтому t равно int. Дальше,
[37:11.340 --> 37:15.620]  второй элемент списка начинает с дополнения пакета параметров, ну, и поэтому он сжирает вообще все,
[37:15.620 --> 37:26.060]  что находится от вот этого места до конца. То есть args, это int, int. Окей? Что придет, если я поменяю эти
[37:26.060 --> 37:35.580]  штуки местами? Давайте, тут class многоточие args, запятаю class t. Вот, и сделаю то же самое.
[37:35.580 --> 37:45.500]  В этом случае снова я начинаю, ну, собственно, компилятор хочет поставить соответствие вот
[37:45.500 --> 37:52.260]  этот список, вот этому списку. Ну, что он делает? Видишь, что первый параметр int. Он видит, что первым
[37:52.260 --> 37:56.540]  параметром идет пакет параметров типов. Пакет параметров типов не знает, где он заканчивается,
[37:56.540 --> 38:01.060]  поэтому он жадным образом просто забирает в себя все. То есть вот начинается пакет, я говорю,
[38:01.060 --> 38:08.180]  что я завожу пакет параметров типов args, значит туда запихиваю int, дальше туда запихиваю int,
[38:08.180 --> 38:14.380]  туда запихиваю int. Все, пакет закончился, точнее, все, список параметров закончился,
[38:14.380 --> 38:20.420]  поэтому пакет завершил работу. Вот. Чему равен тип t, пока не понятно. Ну, окей, потом разберемся. Вот.
[38:20.420 --> 38:24.940]  И смотрим на то, как вызывается функция function. Функцию function передается три аргумента. Ну,
[38:24.940 --> 38:28.020]  компилятор такой, ага, три аргумента. Ну, соответственно, все эти три аргумента, значит,
[38:28.020 --> 38:36.340]  это вот эти самые args. А чему равен t, непонятно. До сих пор. Все, ошибка. Вот. Проблема понятна?
[38:36.340 --> 38:41.300]  Та же самая проблема возникает, если я, ну, смотрите, снова, я возвращаюсь к исходному описанию
[38:41.300 --> 38:46.140]  template, то есть класс t, класс многоточия args, но при этом поменяло местами параметры функции.
[38:46.140 --> 38:51.220]  Видите, да? То есть сначала идет args многоточия args, а потом tx. Вот. Здесь уже обратная проблема.
[38:51.220 --> 38:56.820]  Вот с таким описанием все будет окей. Почему? Потому что понятно, что первый параметр это t,
[38:56.820 --> 39:02.620]  а остальные два параметра это args. Вот. Но если вы вызываете функцию function от 0 и 0.0,
[39:02.620 --> 39:07.340]  то компилятор начинает действовать жадным образом. Да, он видит, что первым аргументом функции
[39:07.340 --> 39:16.100]  function идут, ну, вот эти самые варарги. Да? Вот. Поэтому он говорит, что 0 это args int, 0.0 это args
[39:16.100 --> 39:20.140]  double. Ну, на этом все. А дальше он видит, что, ой, у меня еще есть тип t. А для тип t вы ничего не указали.
[39:20.140 --> 39:29.020]  Вот. Окей? Вот. Ну, наконец, последний пример, самый худший, это когда у вас вот этот вот самый
[39:29.020 --> 39:33.940]  пакет параметров типов идет в начале, и пакет параметров функций тоже идет в самом начале. В этом
[39:33.940 --> 39:38.220]  случае эту функцию, к сожалению, никак не получится вызвать. Потому что и в первом, и в втором случае
[39:38.220 --> 39:42.300]  у вас просто-напросто вот эти вот класс многоточия args и args многоточия, они просто-напросто съедят
[39:42.300 --> 39:45.660]  все параметры, и для t-шки ничего не останется. То есть компилятор скажет, ой, а я не знаю,
[39:45.660 --> 39:52.140]  как увести t. Я все съел. Окей? Вот. То есть на самом деле мораль состоит в том, чтобы вот эти вот
[39:52.140 --> 40:02.780]  класс многоточия args писать в конце описания, ну, либо в конце шаблона, ну, либо в конце самой функции.
[40:02.780 --> 40:08.100]  Окей? Вот. Ну, иначе возможны вот такие вот приколы. Да.
[40:15.660 --> 40:25.460]  Сейчас еще раз, я совсем понял. Так, тут последний пример, и мы там...
[40:25.460 --> 40:37.860]  Сейчас, последний пример, так? А, предпоследний. Так, и что мы делаем?
[40:37.860 --> 40:55.340]  Инт. Ну, там типа, допустим, 0, 0.0. Так, ну, давайте посмотрим, что будет происходить.
[40:55.340 --> 41:01.140]  Предпоследний пример. Ну, собственно, в предпоследнем примере у меня в описании шаблона указаны
[41:01.140 --> 41:07.980]  тип t и args многоточия. Вот. В этом случае, ну, просто нам составим соответствует этот список
[41:07.980 --> 41:14.140]  к этому списку. Это означает, что мы т-шки, в качестве т-шки, вводим int. В качестве argsa, ну, пока ничего не понятно.
[41:14.140 --> 41:24.020]  Вот. Смотрим теперь сюда. Окей, компилятор понял. Ага, 0 это... А, сейчас, нет. Так, дальше смотрим на вызов
[41:24.020 --> 41:29.260]  функции, а функция принимает args многоточия и t. Вот. А, ну, вот в этом случае снова будет проблема.
[41:29.260 --> 41:33.860]  Почему? Потому что компилятор увидит, что функция function объявлена как args многоточия. Ему нужно
[41:33.860 --> 41:39.020]  попытаться понять, что такое args. И он начинает пытаться. Он понимает, ага, первый параметр это int.
[41:39.020 --> 41:47.980]  Второй параметр это double. Все, список закончен. Ну, на этом все. А дальше компилятор понимает, так,
[41:47.980 --> 41:52.660]  погодите, args у меня int double, t это int. То есть, функция у меня принимает три параметра, а мы
[41:52.660 --> 42:08.100]  передали два. Как так? Просчитался, но где? Ну, еще раз, мы в тезе писали int, но вот про args мы пока
[42:08.100 --> 42:14.620]  ничего не поняли. Он может быть, ну, погодите, он может быть пустым, но компилятор-то не знает,
[42:14.620 --> 42:19.820]  пустой он или нет. Пока компилятор не знает, какой он. Чтобы понять, что он пустой, ему нужно
[42:19.820 --> 42:24.220]  проделать какую-то работу. Ну, это как, ну, не знаю, ему нужно вывести параметры, ему нужно вывести
[42:24.220 --> 42:28.460]  параметры для args. То есть, ему нужно понять, пустой он или нет. Вот, собственно, компилятор видит,
[42:28.460 --> 42:33.460]  что вызывается function, который первым параметром принимает произвольное количество аргументов. Вот.
[42:33.460 --> 42:37.820]  Он смотрит на вызов вот этой функции и видит, ага, первым параметром действительно идет произвольное
[42:37.820 --> 42:43.860]  количество элементов. Причем все мое. То есть, 0 это мое, 0.0 это мое, все, я понял, что args это int и double.
[42:43.860 --> 42:50.100]  Вот. То есть, компилятор сгенерировал функцию, которая принимает int, double и в конце int. А дальше
[42:50.100 --> 42:55.060]  компилятор снова возвращает сюда и видит, а погодите, тут же всего два параметра, а не три. Вот.
[42:55.060 --> 43:15.620]  Где он будет дефолтным? Ну, если тут... А, ну, не, это не важно, потому что связь с дефолтным значением,
[43:15.620 --> 43:20.620]  она происходит после этапа выбора шаблона. То есть, сначала будут проведутся вот эти шаги, а потом
[43:20.620 --> 43:25.820]  с нужным значением свяжутся значения по умолчанию. Значение по умолчанию, еще раз напомню, не влияет
[43:25.820 --> 43:46.620]  на вывод шаблонного параметра. Да. Да. Нет, давайте по порядку. Как происходит инстанцирование
[43:46.620 --> 43:53.980]  шаблона? Вот. Давайте я коротко запишу снова. У меня есть t, у меня есть args многоточие, а функция f
[43:53.980 --> 44:08.420]  принимает args многоточие и t. Вот. Я вызвал функцию f от int 0, ну, допустим, 0.0. Для начала компилятору
[44:08.420 --> 44:13.340]  нужно понять, что это за шаблонная функция. Для того, чтобы компилятор сгенерировать код, ему нужно
[44:13.340 --> 44:21.220]  понять, что это за функция. Ему нужно понять, что это функция f от каких шаблонов параметров.
[44:21.220 --> 44:29.980]  Для этого ему нужно заполнить тип t и заполнить тип args. Тип t он берет вот отсюда. Так, все,
[44:29.980 --> 44:36.540]  вот первый шаг, тип t он берет отсюда. Int. Дальше компилятор анализирует, а что же такое вы ему
[44:36.540 --> 44:42.900]  передали сюда? Вы ему сюда передали int и double. Окей. Значит, компилятор видит, что функция f
[44:42.900 --> 44:46.940]  принимает произвольное количество шаблонов параметров. Вот когда компилятор это видит, он
[44:46.940 --> 44:53.540]  впадает в режим берсерка и берет все, что ему впадает с под руку. Он видит, что args многоточие,
[44:53.540 --> 45:04.380]  все, это мое. Int мое, double мое. Все. Компилятор сгенерировал вот такую функцию. Функцию f,
[45:04.380 --> 45:13.980]  которую принимает int, int, double. Все. Как выглядит эта функция? Эта функция выглядит так.
[45:13.980 --> 45:27.620]  int x, int y, double z, ну типа. Вот. Все, он сгенерировал такую функцию. Теперь он пытается,
[45:27.620 --> 45:31.740]  ну теперь он, собственно, пытается вот эти вот параметры связать с этой функцией. Видите? Ага,
[45:31.740 --> 45:40.380]  0 это x, 0.0 это y, а тут что? Ой. Так, я перепутал. Да, у нас, а нет, все нормально. Нет, все
[45:40.380 --> 45:53.820]  нормально. У нас int, int, double, а не int, double, int. А, да, простите, да, да, да. Вот тут я
[45:53.820 --> 46:01.100]  перепутал. Да, тут сначала args, а потом t. Да, то есть тут сначала double, а тут int. Да, согласен.
[46:01.100 --> 46:12.460]  Ну, в любом случае 0 связывает с x, 0.0 с double, а на z ничего не осталось. Последние параметры
[46:12.460 --> 46:21.180]  дефолтное значение? Ну, давайте разбираться. Допустим, тут написано t равно int. Ой, не t равно,
[46:21.740 --> 46:29.580]  равно нулю. Давайте разбираться снова, что произойдет. Я пишу f от int, то есть в качестве параметра
[46:29.580 --> 46:35.540]  t будет int. Дальше функция вызывается от двух значений. Снова, тут вот до этого даже не дойдет,
[46:35.540 --> 46:43.460]  потому что компилятор увидит args и все. И тут начался сущий кошмар. Ноль, первый аргумент,
[46:43.460 --> 46:50.660]  0.0, второй аргумент. Все, args имеет два типа. Все. Теперь, то есть компилятор генерировал вот такую
[46:50.660 --> 47:01.500]  функцию int x, double y, int z равно нулю. Вот. А, ну, кстати, тут да. Тут, кстати, скомпилируется,
[47:01.500 --> 47:06.560]  похоже. Потому что 0 уйдет в x, double уйдет в y, а третий параметр окажется так, что имеет
[47:06.560 --> 47:16.060]  дефолтное значение. Да, тут, кажется, сработает. Да. Но все равно это плохой стиль, потому что,
[47:16.060 --> 47:19.620]  чтобы разобраться с тем, что на самом деле вот это сработает, ну, потребовалось какое-то
[47:19.620 --> 47:28.940]  время. Вот. Поэтому ставить параметры в начале не стоит. И чем, если вы указываете args многоточие,
[47:28.940 --> 47:33.940]  да, ну, вообще просто собранные параметры переменным количеством аргументов, то лучше указывать
[47:33.940 --> 47:45.420]  в конце. Окей? Хорошо. Так, ну, в общем, мы довольно много времени потратили вот на понимание того,
[47:45.420 --> 47:54.420]  как работают args, args, что они принимают, в общем, как они, какие типы при этом выводятся. Ну,
[47:54.420 --> 47:58.340]  собственно, самый интересный вопрос это, а как их использовать? То есть вот я все время говорю,
[47:58.340 --> 48:01.500]  что вот есть пакет параметров, пакет типов. А как, собственно, из этого пакета достать
[48:01.500 --> 48:06.300]  конкретный тип, да, или как из этого пакета достать какой-то конкретный параметр? Вот, собственно,
[48:06.300 --> 48:12.540]  давайте об этом начнем говорить. Значит, ну, пункт номер ноль состоит в следующем. Значит,
[48:12.540 --> 48:18.700]  по пакету параметров, вот в отличие от языка C, по пакету параметров вы всегда можете понять,
[48:18.700 --> 48:22.980]  какое количество аргументов там было передано. Ну, смотрите, вот пакеты параметров, а вот,
[48:22.980 --> 48:26.980]  смотрите, вот в отличие от языка C, пакеты параметров они обрабатываются на этапе компиляции.
[48:26.980 --> 48:31.180]  Подстановка шаблонных параметров происходит на этапе компиляции, а раз это происходит на
[48:31.180 --> 48:36.220]  этапе компиляции, то уже на этапе компиляции понятно, сколько аргументов принимает функция, да? Вот. А раз на
[48:36.220 --> 48:41.300]  этапе компиляции известно, сколько аргументов принимает функция, то я на этапе компиляции могу
[48:41.300 --> 48:46.860]  узнать, сколько там параметров передано. Вот. И делается это с помощью операции sizeof. Вот пример.
[48:46.860 --> 48:52.340]  Вот у меня есть функция function, я пишу класс многоточия args и дальше, собственно, принимаю какое-то
[48:52.340 --> 48:58.900]  количество параметров. Вот. А, тут, кстати, пример про то, как все аргументы принять по
[48:58.900 --> 49:02.620]  константной ссылке. То есть мы на самом деле на args можем навесить все что угодно. Давайте тоже
[49:02.620 --> 49:08.420]  прокомментирую, кажется, у меня там слайды есть, но можно прокомментировать. В общем, если я напишу args многоточие
[49:08.420 --> 49:14.740]  args, то это означает, что все параметры будут переданы по значению, да? Как передать все параметры по ссылке?
[49:14.740 --> 49:22.420]  Я пишу args, ссылка многоточие args. Как все параметры передать по константной ссылке? Ну, пишу const
[49:22.420 --> 49:33.380]  args, ссылка многоточие args. Вот. Как передать по указателю? Ну, собственно, пишу args, указатель
[49:33.380 --> 49:40.740]  многоточие args, ну и так далее. Вы просто-напросто нужный модификатор навешиваете на вот этот вот
[49:40.740 --> 49:44.060]  args. И тогда все параметры будут иметь вот ровно такой тип. То есть тут все параметры будут иметь
[49:44.060 --> 49:56.420]  тип ссылка, тут конст ссылка, тут звездочка. Первое, просто по значению. Ну, типа то же самое,
[49:56.420 --> 50:01.620]  как если вы написали, допустим, tx. Вот тут то же самое, как если вы написали t&x. Тут
[50:01.620 --> 50:11.020]  конст т&x, тут t со звездой x и так далее. Ну, то есть это просто-напросто типа, на который ничего
[50:11.020 --> 50:20.260]  не навешано. Да, не звездочки, не апельсанды, ничего. Отдельного поведения нет, к сожалению, нет.
[50:20.260 --> 50:26.740]  Можно, короче, на самом деле можно, то есть на самом деле можно принять типы в зависимости
[50:26.740 --> 50:31.180]  того, что вам передано, но об этом в следующий раз. Про универсальные ссылки потом. Вот.
[50:31.180 --> 50:36.260]  Окей. Ну и теперь, собственно, с помощью операции сайзов многоточия можно понять,
[50:36.260 --> 50:40.460]  сколько параметров было передано в функцию. Вот у меня есть функция function, которая принимает
[50:40.460 --> 50:45.140]  произвольное количество, произвольное количество аргументов. Я могу применить операцию сайзов к,
[50:45.140 --> 50:49.580]  ну, самому пакету параметров типов, то есть аркс с большой буквы. Могу применить сайзов
[50:49.580 --> 50:53.220]  многоточия к аркс с маленькой буквы. В этом случае у меня всегда будет просто
[50:53.220 --> 50:56.620]  обсвободиться количество параметров, которые, которые было передано в функцию. Например, если
[50:56.620 --> 51:03.340]  вызову function от 1, 2, 3, то у меня выведется две строки со значением 3. Окей. Вот. Ну это вот
[51:03.340 --> 51:08.660]  такой просто нулевой пункт. Собственно, как понять, сколько аргументов было передано в функцию. Вот.
[51:08.660 --> 51:18.500]  Теперь давайте поговорим про то, как функции вызывать. Вызываются функции следующим образом.
[51:18.500 --> 51:24.740]  Значит, есть три способы, ну, таких принципиально три способы вызвать функцию с переменным числом
[51:24.740 --> 51:30.340]  аргументов. Первый способ – это вызвать другую функцию, которая принимает произвольное количество
[51:30.340 --> 51:35.180]  аргументов. Значит, этот способ называется распаковка пакета. Ну, это такой читерский способ,
[51:35.180 --> 51:39.620]  который начинается с следующих слов. Допустим, у нас уже есть какая-то функция,
[51:39.620 --> 51:43.780]  которая может принимать произвольное количество параметров. Ну, допустим, как-то за вас реализовала
[51:43.780 --> 51:50.120]  такую функцию, вот. Как мне взять вот пакет, пакет параметров, и целиком передать его в другую
[51:50.120 --> 51:55.540]  функцию. Вот. Чтобы это сделать, необходимо такая операция, как распаковка пакета. Значит, смотрите.
[51:55.540 --> 51:59.940]  Тут у меня написано, то есть, представьте себе, что у меня написана функция print, которая может
[51:59.940 --> 52:02.680]  принимать произвольное количество параметров. То есть, пак crises can be printed opening the
[52:02.680 --> 52:11.380]  количество параметров vseout. А я пишу функцию printTitle, которая до вывода всех этих типов пишет некоторые из заголовок.
[52:11.380 --> 52:14.680]  Какую-то отладочную информацию или какой-то лог.
[52:14.680 --> 52:22.680]  Функция printTitle выглядит следующим образом. Она принимает пакет типов class.args, дальше она принимает первым параметром заголовок,
[52:22.680 --> 52:27.680]  который нужно вывести в начале, а дальше принимает параметры, которые нужно вывести затем.
[52:27.680 --> 52:34.680]  Функция printTitle выглядит следующим образом. std.seout.title, то есть я вывел заголовок, а дальше вывожу все остальные параметры.
[52:34.680 --> 52:42.680]  Чтобы вызвать функцию print от всех параметров, которые были переданы функцию, я использую синтаксис распаковки пакета.
[52:43.680 --> 52:50.680]  Это принт, args, многоточие.
[52:50.680 --> 52:56.680]  Вот эта вот запись, в целом, можно считать, что она представляет вот эти данные вот в таком виде.
[52:56.680 --> 53:02.680]  Ну, а 0, запятая а1, запятая а2, и так далее, а n-1.
[53:02.680 --> 53:10.680]  То есть args, многоточие, вот эта вот многоточие, которая написана уже внутри функции, означает распаковать пакет.
[53:10.680 --> 53:16.680]  То есть расправить пакет, первый, второй, третий, и разложить их вот по порядку.
[53:20.680 --> 53:24.680]  Второй пример. Что еще можно делать с этим самым пакетом?
[53:24.680 --> 53:29.680]  На самом деле, вот эти вот параметры в процессе распаковки можно каким-то образом модифицировать или каким-то образом менять.
[53:29.680 --> 53:32.680]  Вот пример ниже. Сумма квадратов.
[53:32.680 --> 53:40.680]  У меня есть пакет параметров args, ну и, собственно, сумма квадратов принимает произвольное количество аргументов.
[53:40.680 --> 53:48.680]  Вот. Допустим, у меня уже есть написанная функция sum, которая принимает произвольное количество параметров и просто-напросто суммирует все аргументы.
[53:48.680 --> 53:52.680]  Вот. Как мне сделать так, чтобы эта сумма суммировала квадраты всех значений?
[53:52.680 --> 53:56.680]  Ну, собственно, я делаю, ну, я поступаю так, как написано выше.
[53:56.680 --> 54:01.680]  Да, я пишу sum, args умножить на args многоточие. Вот.
[54:01.680 --> 54:05.680]  В чем заключается этот синтаксис распаковки?
[54:05.680 --> 54:10.680]  Вот пусть у меня есть какая-то функция f, и я хочу каким-то образом модифицировать пакет параметров.
[54:10.680 --> 54:17.680]  Я могу сделать следующее. То есть я могу применить какую-то операцию к пакету args.
[54:17.680 --> 54:21.680]  И дальше указать многоточие. Вот это вот g означает просто-напросто произвольную операцию.
[54:21.680 --> 54:24.680]  То есть с этим args я могу сделать все, что угодно. Вот.
[54:24.680 --> 54:35.680]  В этом случае это будет расписано так. f от g а0 запятая g от a1 запятая g от a2, ну и так далее.
[54:35.680 --> 54:45.680]  Понятно? То есть вот это вот sum от args умножить на args многоточие означает sum от a0 умножить на a0
[54:45.680 --> 54:51.680]  запятая a1 умножить на a1 запятая и так далее. Вот.
[54:51.680 --> 54:56.680]  То есть перед распаковкой вы можете применить нужную операцию каждому элементу пакета,
[54:56.680 --> 55:00.680]  и таким образом он будет распакован вот в то, что вам нужно. Пример понятен?
[55:05.680 --> 55:09.680]  Вот. Ну и еще примеры. Допустим, я хочу напечатать адреса передаваемых аргументов.
[55:09.680 --> 55:13.680]  Тогда я принимаю все аргументы по константной ссылке. Вот. Print addresses.
[55:13.680 --> 55:18.680]  Ну и каждому аргументу применяю операцию получения адреса.
[55:18.680 --> 55:26.680]  Print % args и многоточие. Тогда у меня каждому аргументу будет применена операция взятия адреса.
[55:26.680 --> 55:29.680]  Вот. И передана функцию print. Вот.
[55:29.680 --> 55:33.680]  И еще функция print part sums это функция, которая считает частичные суммы.
[55:33.680 --> 55:37.680]  То есть считает допустим сумму всех элементов без нулевого элемента,
[55:37.680 --> 55:41.680]  потом сумму всех элементов без первого элемента, сумму всех элементов без второго, ну и так далее.
[55:41.680 --> 55:43.680]  Теперь давайте, ну собственно, самый интересный вопрос.
[55:44.680 --> 55:49.680]  А нет у меня такой функции. Ну вот все. Вот мы вот только изобрели вот шаблоны с переменочным аргументом.
[55:49.680 --> 55:53.680]  Нужно написать самую первую в мире функцию, которая принимает произвольное количество аргументов.
[55:53.680 --> 55:58.680]  Как это сделать? Значит, есть два способа. Первый способ старый, второй способ новый.
[55:58.680 --> 56:00.680]  Начнем, как обычно, со старого способа.
[56:00.680 --> 56:04.680]  Значит, старый способ – это мета-откусывание, ну или мета-рекурсии.
[56:04.680 --> 56:06.680]  Вот. Смотрите. В чем проблема?
[56:06.680 --> 56:10.680]  Проблема стоит в том, что ну давайте напишем какую-нибудь функцию.
[56:10.680 --> 56:12.680]  Ну давайте функцию print напишем.
[56:12.680 --> 56:18.680]  Проблема состоит в том, что вот этот вот пакет параметров – это довольно-таки непонятная сущность.
[56:18.680 --> 56:22.680]  Вот. И если вы все это время надеялись, что я вам расскажу, что на самом деле пакет параметров – это вектор,
[56:22.680 --> 56:24.680]  или на самом деле пакет параметров – это array, вот не так.
[56:24.680 --> 56:27.680]  Пакет параметров – это просто пакет параметров. Вот такая сущность.
[56:27.680 --> 56:32.680]  Вот. И как-то на самом деле в Github C++ нет какого-то определенного инструмента,
[56:32.680 --> 56:34.680]  который позволит вам работать с этим пакетом.
[56:34.680 --> 56:38.680]  То есть нельзя сказать, что ARX 0, или там возьми ARX 1, и так далее.
[56:38.680 --> 56:40.680]  То есть вот пакет – он просто пакет. Вот он целиковый.
[56:40.680 --> 56:42.680]  Вот такая вот целиковая история. Ну это не знаю.
[56:42.680 --> 56:45.680]  В достаке он привезли, и вот завязали как следует.
[56:45.680 --> 56:47.680]  И их фиг развяжешь. Вот та же самая история.
[56:47.680 --> 56:49.680]  Вот пакет, который не развязывается.
[56:49.680 --> 56:55.680]  Вот. Поэтому просто так взять и достать оттуда аргументы, и обрабатывать их по отдельности,
[56:55.680 --> 56:58.680]  ну вот непосредственные функции, к сожалению, не получится.
[56:58.680 --> 57:00.680]  Вот. Вопрос, как обмануть компилятор.
[57:00.680 --> 57:02.680]  Вот. Да, смотрите.
[57:02.680 --> 57:05.680]  Знаете, в чем тут проблема? В чем проблема вот этой функции?
[57:05.680 --> 57:08.680]  Проблема вот этой функции в том, что мы взяли все аргументы,
[57:08.680 --> 57:10.680]  сразу запаковали вот в одну сущность.
[57:10.680 --> 57:13.680]  И вот из этой сущности мы ничего отдельно выделить не можем.
[57:13.680 --> 57:15.680]  А давайте напишем такую программу.
[57:15.680 --> 57:18.680]  Давайте выделим один отдельный элемент из этого пакета,
[57:18.680 --> 57:20.680]  и весь остальной пакет.
[57:20.680 --> 57:23.680]  Давайте перепишу эту функцию другим образом.
[57:23.680 --> 57:25.680]  Давайте я скажу, что у меня функция print.
[57:27.680 --> 57:31.680]  Функция print принимает какой-то произвольный параметр t,
[57:32.680 --> 57:34.680]  а потом все, что угодно.
[57:37.680 --> 57:39.680]  Ну, давайте так напишу t, x,
[57:40.680 --> 57:42.680]  args многоточие args.
[57:44.680 --> 57:47.680]  Вот, смотрите, то есть я сказал, что первый аргумент,
[57:47.680 --> 57:49.680]  который я передам в функцию print,
[57:49.680 --> 57:51.680]  он пойдет в аргумент t.
[57:51.680 --> 57:53.680]  А все остальное пойдет в args.
[57:53.680 --> 57:56.680]  Ну, смотрите, ну кажется, что стало чуть понятнее.
[57:56.680 --> 57:59.680]  Почему? Потому что если у меня есть первый аргумент,
[57:59.680 --> 58:03.680]  то мне нужно вывести в аргумент std cout x.
[58:03.680 --> 58:07.680]  Ну и дальше там не знаю, пусть с новой строки все выводится.
[58:07.680 --> 58:09.680]  Понятно?
[58:09.680 --> 58:11.680]  Вопрос, а что делать с пакетом параметров?
[58:15.680 --> 58:17.680]  Ну что значит, мне же надо,
[58:17.680 --> 58:20.680]  то есть у меня же задача стоит не в том, чтобы вывести первый аргумент.
[58:20.680 --> 58:22.680]  Мне нужно все аргументы вывести.
[58:23.680 --> 58:25.680]  Да, смотрите, у меня же есть функция print.
[58:25.680 --> 58:27.680]  Давайте я вывожу в функцию print.
[58:27.680 --> 58:30.680]  print от args многоточие.
[58:32.680 --> 58:34.680]  И в этом стоит откусывание.
[58:36.680 --> 58:39.680]  Да, вот эти параметры снова передаются в функцию print,
[58:39.680 --> 58:41.680]  и уже первый аргумент вот этого пакета параметров
[58:41.680 --> 58:43.680]  откусится в x.
[58:43.680 --> 58:45.680]  Понятно? То есть давайте пример.
[58:45.680 --> 58:48.680]  Вот я вызываю print от 1, 2, 3.
[58:49.680 --> 58:51.680]  Что происходит в этом случае?
[58:51.680 --> 58:53.680]  У меня откусывается x равный 1
[58:53.680 --> 58:56.680]  и args равный 2, 3.
[58:57.680 --> 58:58.680]  Согласны?
[58:58.680 --> 59:00.680]  Единицу я увожу,
[59:00.680 --> 59:04.680]  а дальше вызываю функцию print от 2, 3.
[59:06.680 --> 59:08.680]  Что откусывается?
[59:08.680 --> 59:10.680]  Двойка откусывается в x,
[59:11.680 --> 59:14.680]  а в пакете args остается тройка.
[59:15.680 --> 59:17.680]  Что происходит дальше?
[59:18.680 --> 59:20.680]  Вызывается print от тройки,
[59:21.680 --> 59:23.680]  откусывается тройка,
[59:23.680 --> 59:26.680]  которая выводится,
[59:26.680 --> 59:29.680]  и остается args пустым пакетом.
[59:29.680 --> 59:31.680]  Что происходит дальше?
[59:34.680 --> 59:36.680]  Вызывается print.
[59:36.680 --> 59:38.680]  Ну смотрите, у меня не важно, пустой пакет, не пустой,
[59:38.680 --> 59:40.680]  я же вызывал print от пакета.
[59:40.680 --> 59:42.680]  Если пакет пустой, то сюда передается 0 параметров.
[59:42.680 --> 59:44.680]  Вызывается print без аргументов
[59:44.680 --> 59:46.680]  и ошибка импиляции,
[59:46.680 --> 59:48.680]  потому что откусывать нечего.
[59:48.680 --> 59:50.680]  Понятно?
[59:51.680 --> 59:53.680]  Да, ну собственно, смотрите, так как мы реализовали
[59:53.680 --> 59:55.680]  функцию рекурсивно,
[59:55.680 --> 59:57.680]  рекурсия должна когда-то кончиться.
[59:57.680 --> 59:59.680]  Поэтому тут нужно рассмотреть особый случай.
[59:59.680 --> 01:00:01.680]  Особый случай это, видимо, как раз-таки
[01:00:01.680 --> 01:00:03.680]  print без аргументов.
[01:00:03.680 --> 01:00:05.680]  Давайте отдельно напишем функцию, просто void print,
[01:00:05.680 --> 01:00:07.680]  которая не принимает никаких аргументов,
[01:00:07.680 --> 01:00:09.680]  но она просто ничего не делает.
[01:00:09.680 --> 01:00:11.680]  Если вы сказали напечатать ничего, то я ничего не печатаю.
[01:00:11.680 --> 01:00:13.680]  Когда вызываю print, то будет вызываться
[01:00:13.680 --> 01:00:15.680]  уже вот эта функция print,
[01:00:15.680 --> 01:00:17.680]  и все, на этом завершится работа.
[01:00:17.680 --> 01:00:19.680]  Окей?
[01:00:19.680 --> 01:00:21.680]  Вот этот откусывание.
[01:00:21.680 --> 01:00:23.680]  То есть я просто напишу рекурсивную функцию,
[01:00:23.680 --> 01:00:25.680]  и все остальное, и дальше просто
[01:00:25.680 --> 01:00:27.680]  всю эту функцию рекурсивного вызываю,
[01:00:27.680 --> 01:00:29.680]  и по очереди по одному элементу откусываю.
[01:00:29.680 --> 01:00:31.680]  Ну да, по очереди просто откусываю элементы
[01:00:31.680 --> 01:00:33.680]  и обрабатываю их
[01:00:33.680 --> 01:00:35.680]  с помощью рекурсии.
[01:00:35.680 --> 01:00:37.680]  Окей?
[01:00:37.680 --> 01:00:39.680]  Ну вот.
[01:00:39.680 --> 01:00:41.680]  Давайте посмотрим на пример, тот самый пример
[01:00:41.680 --> 01:00:43.680]  с функцией print.
[01:00:43.680 --> 01:00:45.680]  Тут у меня
[01:00:45.680 --> 01:00:47.680]  чуть по-другому написано, то есть тут у меня
[01:00:47.680 --> 01:00:49.680]  конец рекурсии был, когда в функцию print передали
[01:00:49.680 --> 01:00:51.680]  ноль аргументов, вот тут конец рекурсии,
[01:00:51.680 --> 01:00:53.680]  когда в функцию print передали один аргумент.
[01:00:53.680 --> 01:00:55.680]  Вот. То есть если функцию print передали
[01:00:55.680 --> 01:00:57.680]  один аргумент, то просто-напросто его ввожу.
[01:00:57.680 --> 01:00:59.680]  Вот. Если в функцию print передали
[01:00:59.680 --> 01:01:01.680]  один аргумент и еще что-то,
[01:01:01.680 --> 01:01:03.680]  то вызывается
[01:01:03.680 --> 01:01:05.680]  функция print, то есть печатается
[01:01:05.680 --> 01:01:07.680]  head, ну вот тут параметры я назвал head
[01:01:07.680 --> 01:01:09.680]  и tail, классическое название на самом деле.
[01:01:09.680 --> 01:01:11.680]  То есть откусывается голова, и дальше вызывается
[01:01:11.680 --> 01:01:13.680]  print от хвоста. Вот.
[01:01:13.680 --> 01:01:15.680]  Когда я вызываю print от 1, дальше
[01:01:15.680 --> 01:01:17.680]  строка, дальше 0.0, все прекрасно обрабатывается.
[01:01:17.680 --> 01:01:19.680]  Понятно, да?
[01:01:21.680 --> 01:01:23.680]  Вот.
[01:01:23.680 --> 01:01:25.680]  Значит, второй пример для суммы.
[01:01:25.680 --> 01:01:27.680]  Вот.
[01:01:27.680 --> 01:01:29.680]  Сумму можно тоже реализовать,
[01:01:29.680 --> 01:01:31.680]  ну, короче, сумму точно так же можно реализовать, да?
[01:01:31.680 --> 01:01:33.680]  То есть базовый случай, то есть конец рекурсии,
[01:01:33.680 --> 01:01:35.680]  когда в сумму передали один аргумент,
[01:01:35.680 --> 01:01:37.680]  то есть если у меня в сумму передали один аргумент, то я просто-напросто его
[01:01:37.680 --> 01:01:39.680]  возвращаю. Вот. Если в сумму передали
[01:01:39.680 --> 01:01:41.680]  много параметров, то есть, точнее, более одного
[01:01:41.680 --> 01:01:43.680]  параметра, то я беру этот
[01:01:43.680 --> 01:01:45.680]  первый параметр и складываю его с результатом
[01:01:45.680 --> 01:01:47.680]  суммы от хвоста, да?
[01:01:47.680 --> 01:01:49.680]  То есть я беру head плюс сумма
[01:01:49.680 --> 01:01:51.680]  от всего остального. Согласны?
[01:01:51.680 --> 01:01:53.680]  Все, таким образом получается сумма.
[01:01:53.680 --> 01:01:55.680]  Вот. Тут
[01:01:55.680 --> 01:01:57.680]  да, тут я еще обратил
[01:01:57.680 --> 01:01:59.680]  внимание, смотрите, вот на вторую функцию,
[01:01:59.680 --> 01:02:01.680]  на возвращаемое значение,
[01:02:01.680 --> 01:02:03.680]  тут я указал auto, то есть я не помню, явно мы
[01:02:03.680 --> 01:02:05.680]  проговаривали это или нет, но вообще говоря, для возвращаемого значения
[01:02:05.680 --> 01:02:07.680]  функции можно указывать auto, и если
[01:02:07.680 --> 01:02:09.680]  по return можно этот тип увести,
[01:02:09.680 --> 01:02:11.680]  то компилятор этот тип увидит.
[01:02:11.680 --> 01:02:13.680]  На самом деле использование auto в качестве возвращаемого значения оно не очень
[01:02:13.680 --> 01:02:15.680]  рекомендуется, но тут на самом деле оно осмысленно
[01:02:15.680 --> 01:02:17.680]  по двум причинам. Первая причина,
[01:02:17.680 --> 01:02:19.680]  все все понимают, то есть понятно, что сумма возвращает
[01:02:19.680 --> 01:02:21.680]  сумму всех аргументов, то есть более-менее понятно
[01:02:21.680 --> 01:02:23.680]  какой тип, да? Тип, ну, тип
[01:02:23.680 --> 01:02:25.680]  это результирующий тип для суммы
[01:02:25.680 --> 01:02:27.680]  всех элементов. Вот. А второе
[01:02:27.680 --> 01:02:29.680]  замечание стоит в том, что тип на самом деле
[01:02:29.680 --> 01:02:31.680]  явно написать можно, мы про это поговорим ближе
[01:02:31.680 --> 01:02:33.680]  к концу семестра, как? Вот. Но он
[01:02:33.680 --> 01:02:35.680]  будет настолько сложный и большой, что
[01:02:35.680 --> 01:02:37.680]  в целом лучше написать auto,
[01:02:37.680 --> 01:02:39.680]  чтобы никого не путать, окей?
[01:02:39.680 --> 01:02:41.680]  Вот. Поэтому
[01:02:41.680 --> 01:02:43.680]  в общем, auto просто автоматически уводит тип возвращаемого значения,
[01:02:43.680 --> 01:02:45.680]  тут такое можно делать, ну, в шаблонах функциях
[01:02:45.680 --> 01:02:47.680]  или в обычных функциях, вот. Но это делать не
[01:02:47.680 --> 01:02:49.680]  рекомендуется. Вот.
[01:02:49.680 --> 01:02:51.680]  Окей?
[01:02:51.680 --> 01:02:53.680]  Так.
[01:02:53.680 --> 01:02:55.680]  Хорошо. Ну, наконец,
[01:02:55.680 --> 01:02:57.680]  современный метод
[01:02:57.680 --> 01:02:59.680]  использования
[01:02:59.680 --> 01:03:01.680]  шаблонов,
[01:03:01.680 --> 01:03:03.680]  в общем, страшно сказать, но
[01:03:03.680 --> 01:03:05.680]  с момента появления современного метода,
[01:03:05.680 --> 01:03:07.680]  точнее, от современного метода
[01:03:07.680 --> 01:03:09.680]  до создания вот этих самых шаблонов с переменающим
[01:03:09.680 --> 01:03:11.680]  аргументом прошло 6 лет, то есть
[01:03:11.680 --> 01:03:13.680]  был стандарт с плюс 11, потом...
[01:03:13.680 --> 01:03:15.680]  И вот это вот fold expressions появились и плюс 17.
[01:03:15.680 --> 01:03:17.680]  Вот. То есть, как на самом деле
[01:03:17.680 --> 01:03:19.680]  стоит реализовывать функции
[01:03:19.680 --> 01:03:21.680]  с переменами числонов аргумента?
[01:03:21.680 --> 01:03:23.680]  Для этого стоит использовать выражение
[01:03:23.680 --> 01:03:25.680]  свертки.
[01:03:25.680 --> 01:03:27.680]  Что такое выражение свертки?
[01:03:27.680 --> 01:03:29.680]  Выражение свертки, на самом деле, по сути,
[01:03:29.680 --> 01:03:31.680]  это просто-напросто
[01:03:31.680 --> 01:03:33.680]  еще один способ
[01:03:33.680 --> 01:03:35.680]  распаковки параметров.
[01:03:35.680 --> 01:03:37.680]  Смотрите, тут мы обычно
[01:03:37.680 --> 01:03:39.680]  распаковывали параметры
[01:03:39.680 --> 01:03:41.680]  просто через запятую, грубо говоря.
[01:03:41.680 --> 01:03:43.680]  Применяли какую-то операцию каждому аргументу
[01:03:43.680 --> 01:03:45.680]  и через запятую их перечисляли и передавали функцию.
[01:03:45.680 --> 01:03:47.680]  Выражение свертки это следующее.
[01:03:47.680 --> 01:03:49.680]  Я могу написать, допустим,
[01:03:49.680 --> 01:03:51.680]  args. Дальше какая-то операция
[01:03:51.680 --> 01:03:53.680]  многоточие.
[01:03:53.680 --> 01:03:55.680]  Вот.
[01:03:55.680 --> 01:03:57.680]  И это будет означать, что все аргументы
[01:03:57.680 --> 01:03:59.680]  ко всем аргументам
[01:03:59.680 --> 01:04:01.680]  нужно применить бинарную операцию op.
[01:04:01.680 --> 01:04:03.680]  Да?
[01:04:03.680 --> 01:04:05.680]  То есть, вот там сверху написано.
[01:04:05.680 --> 01:04:07.680]  Аргументы op многоточие.
[01:04:07.680 --> 01:04:09.680]  Это означает, что нужно взять а0
[01:04:09.680 --> 01:04:11.680]  и применить операцию ко всему остальному.
[01:04:11.680 --> 01:04:13.680]  Вот если многоточие пишется справа
[01:04:13.680 --> 01:04:15.680]  от операции, то это означает, что
[01:04:15.680 --> 01:04:17.680]  будет так называемая правая свертка.
[01:04:17.680 --> 01:04:19.680]  Это значит, что сначала будут выполняться операции
[01:04:19.680 --> 01:04:21.680]  над последними аргументами.
[01:04:21.680 --> 01:04:23.680]  Сначала, допустим, сложатся последние два аргумента,
[01:04:23.680 --> 01:04:25.680]  потом сумма этих двух аргументов прибавится
[01:04:25.680 --> 01:04:27.680]  к предпредпред последним аргументам,
[01:04:27.680 --> 01:04:29.680]  ну и так далее.
[01:04:29.680 --> 01:04:31.680]  Ну, собственно, запись понятна.
[01:04:31.680 --> 01:04:33.680]  Есть также левая свертка.
[01:04:33.680 --> 01:04:35.680]  Операция. Дальше, собственно, пакет параметров.
[01:04:35.680 --> 01:04:37.680]  В этом случае операции
[01:04:37.680 --> 01:04:39.680]  выполняются слева направо.
[01:04:39.680 --> 01:04:41.680]  То есть, сначала a0, a1, потом к результату a2,
[01:04:41.680 --> 01:04:43.680]  потом к результату a3, и так далее.
[01:04:43.680 --> 01:04:45.680]  Наиболее интересные, наверное,
[01:04:45.680 --> 01:04:47.680]  случаи 3 и 4 — это
[01:04:47.680 --> 01:04:49.680]  так называемая распаковка с анициализацией.
[01:04:49.680 --> 01:04:51.680]  Что такое init? Ну, представьте себе, что у вас
[01:04:53.680 --> 01:04:55.680]  ну, грубо говоря, вы хотите применить
[01:04:55.680 --> 01:04:57.680]  операцию, вы хотите сделать следующее.
[01:04:57.680 --> 01:04:59.680]  Вы хотите сложить a0
[01:04:59.680 --> 01:05:01.680]  плюс a1, плюс a2, плюс a3
[01:05:01.680 --> 01:05:03.680]  и так далее. Ну, и там прибавить
[01:05:03.680 --> 01:05:05.680]  какое-то начальное значение.
[01:05:05.680 --> 01:05:07.680]  Это начальное значение можно указать, ну, либо
[01:05:07.680 --> 01:05:09.680]  справа от многоточия, либо слева от многоточия.
[01:05:09.680 --> 01:05:11.680]  В этом случае будет просто GooGoo,
[01:05:11.680 --> 01:05:13.680]  с некотором начальным значением.
[01:05:13.680 --> 01:05:15.680]  То есть, добавляется
[01:05:15.680 --> 01:05:17.680]  некоторое начальное значение. Norwegian speak.
[01:05:17.680 --> 01:05:19.680]  Ну либо левое sốло с начальным значением.
[01:05:19.680 --> 01:05:21.680]  OK?
[01:05:21.680 --> 01:05:22.680]  在. plot.
[01:05:22.680 --> 01:05:23.680]  В Muitoareth Penguin.
[01:05:23.680 --> 01:05:25.680]  На самом деле, это начальное значение очень важно
[01:05:25.680 --> 01:05:27.680]  в контексте, например, реализации
[01:05:27.680 --> 01:05:29.680]  функций print. Давайте посмотрим на примеры.
[01:05:29.680 --> 01:05:37.160]  Вот реализация функции print с испортным выражением
[01:05:37.160 --> 01:05:38.160]  сперки.
[01:05:38.160 --> 01:05:39.800]  Смотрите, никакой рекурсии, просто-напросто одно выражение,
[01:05:39.800 --> 01:05:41.520]  ровно то, чего мы вроде как и хотели.
[01:05:41.520 --> 01:05:44.360]  Вот есть шаблонная функция print, которая принимает
[01:05:44.360 --> 01:05:46.560]  пакет параметров args, все аргументы мы принимаем
[01:05:46.560 --> 01:05:48.680]  по константной ссылке, и дальше пишем просто-напросто
[01:05:48.680 --> 01:05:50.160]  следующую fold expression.
[01:05:50.160 --> 01:05:54.040]  std seout, выводим многоточие, дальше args.
[01:05:54.040 --> 01:05:58.120]  Какому из fold expressions соответствует этот вот синтаксис?
[01:05:58.120 --> 01:06:00.880]  Смотрите, 1, 2, 3 или 4.
[01:06:00.880 --> 01:06:06.200]  Да, смотрите, 4, seout это init, операция побитого с двига
[01:06:06.200 --> 01:06:10.080]  влево это вот это вот самое op, дальше вот ноготочие,
[01:06:10.080 --> 01:06:11.800]  дальше вот это операция, дальше пакет параметров.
[01:06:11.800 --> 01:06:14.720]  И собственно это распаковывается вот так, как написано внизу.
[01:06:14.720 --> 01:06:17.680]  Сначала seout применяется к 1 параметру, потом результат
[01:06:17.680 --> 01:06:20.240]  этого seout применяется к 2 параметру и так далее.
[01:06:20.240 --> 01:06:27.200]  Но мы с вами знаем, что если я применяю seout к чему-то,
[01:06:27.200 --> 01:06:29.040]  то что тут возвращается?
[01:06:29.040 --> 01:06:31.640]  Да, возвращается сам seout.
[01:06:31.640 --> 01:06:40.480]  Поэтому, когда я в следующий раз применяю seout, то у меня
[01:06:40.480 --> 01:06:44.000]  по сути seout применяется к y, то есть у меня seout применяется
[01:06:44.000 --> 01:06:46.240]  к 1 аргументу, потом seout применяется к 2 аргументу,
[01:06:46.240 --> 01:06:47.240]  к 3, 4 и так далее.
[01:06:47.240 --> 01:06:50.760]  То есть понятно, да?
[01:06:50.760 --> 01:06:51.760]  Понятно, почему это работает.
[01:06:52.760 --> 01:06:57.760]  То есть просто происходит распаковка с помощью некоторой
[01:06:57.760 --> 01:06:58.760]  бинарной операции.
[01:06:58.760 --> 01:07:00.840]  Ну и то же самое с суммой, но с суммой все гораздо
[01:07:00.840 --> 01:07:01.840]  проще.
[01:07:01.840 --> 01:07:05.680]  У меня есть аргументы args, я принимаю их по константной
[01:07:05.680 --> 01:07:09.800]  ссылке и дальше возвращаю свертку с операции сложения.
[01:07:09.800 --> 01:07:11.640]  Дай пишу args plus многоточие.
[01:07:11.640 --> 01:07:14.440]  То есть тут у меня на самом деле правая свертка, то
[01:07:14.440 --> 01:07:15.840]  есть тут у меня сначала складываются последние
[01:07:15.840 --> 01:07:17.600]  два аргумента, потом это все складывается с третьим
[01:07:17.600 --> 01:07:19.680]  аргументом, с четвертым и так далее и так далее.
[01:07:19.920 --> 01:07:22.080]  Если хочется применить левую свертку, то есть если
[01:07:22.080 --> 01:07:23.600]  хочется на самом деле, чтобы складывались слева
[01:07:23.600 --> 01:07:26.720]  направо, то можно применить return многоточие plus args.
[01:07:28.720 --> 01:07:29.720]  Понятно?
[01:07:33.720 --> 01:07:34.720]  Вот.
[01:07:34.720 --> 01:07:35.720]  Так.
[01:07:35.720 --> 01:07:38.720]  Задайте какие-нибудь вопросы, если есть.
[01:07:41.720 --> 01:07:42.720]  Что?
[01:07:42.720 --> 01:07:43.720]  О!
[01:07:43.720 --> 01:07:46.480]  Да, про этот вопрос сейчас мы поговорим, есть какие-то
[01:07:46.520 --> 01:07:47.520]  вопросы по синтаксисту вопроса.
[01:07:47.520 --> 01:07:50.520]  Все окей, да?
[01:07:50.520 --> 01:07:56.520]  Ну, в общем вот, fold expression это ваш друг, можно пользоваться
[01:07:56.520 --> 01:08:01.520]  им и писать собственно функции с переменным числом аргументов.
[01:08:01.520 --> 01:08:02.520]  Вот.
[01:08:02.520 --> 01:08:03.520]  Да.
[01:08:06.520 --> 01:08:09.520]  init – это просто некоторый объект, к которому применяется
[01:08:09.520 --> 01:08:10.520]  операция.
[01:08:10.520 --> 01:08:11.520]  Ну, давайте так.
[01:08:11.560 --> 01:08:16.560]  Ну, init – это просто какой-то объект.
[01:08:16.560 --> 01:08:17.560]  Вот.
[01:08:17.560 --> 01:08:25.560]  То есть если я пишу init plus многоточие plus args, то это
[01:08:25.560 --> 01:08:33.560]  то же самое, что init plus a0 plus a1, ну, давайте так,
[01:08:33.560 --> 01:08:38.560]  напишу просто init plus a0 plus a1 plus a2 plus a3 plus и так
[01:08:38.560 --> 01:08:39.560]  далее.
[01:08:39.600 --> 01:08:41.600]  Plus – это операция левоассоциативная, поэтому вот
[01:08:41.600 --> 01:08:42.600]  так.
[01:08:42.600 --> 01:08:46.600]  Ну, init – это просто некоторый объект, к которому прибавляется
[01:08:46.600 --> 01:08:47.600]  все остальное.
[01:08:50.600 --> 01:08:52.600]  Ну, это может, ну, естественно, должен быть тип, который
[01:08:52.600 --> 01:08:54.600]  к которому применима операция сложения с a0.
[01:08:56.600 --> 01:08:59.600]  Ну, тут, например, вот, во втором примере у нас в качестве
[01:08:59.600 --> 01:09:01.600]  init выступался this out.
[01:09:01.600 --> 01:09:02.600]  Ну, почему?
[01:09:02.600 --> 01:09:03.600]  Потому что если я просто напишу ко всем параметрам
[01:09:03.600 --> 01:09:05.600]  применю операцию по bit.ly с двига, то все элементы
[01:09:05.600 --> 01:09:07.600]  просто будут сдвигаться относительно друг друга.
[01:09:07.600 --> 01:09:08.600]  Да.
[01:09:08.640 --> 01:09:10.640]  А тут я применил this out, и теперь, собственно, this
[01:09:10.640 --> 01:09:12.640]  out применяется к первому параметру, потом результат.
[01:09:12.640 --> 01:09:13.640]  Это this out тоже применяется к второму параметру и так
[01:09:13.640 --> 01:09:14.640]  далее.
[01:09:16.640 --> 01:09:17.640]  Так.
[01:09:17.640 --> 01:09:18.640]  Еще вопросы?
[01:09:21.640 --> 01:09:25.640]  Так, ну, теперь давайте погрузимся чуть глубже.
[01:09:25.640 --> 01:09:28.640]  Смотрите, на самом деле, вот в этой реализации есть
[01:09:28.640 --> 01:09:29.640]  несколько косяк.
[01:09:29.640 --> 01:09:32.640]  И косяк заключается в том, что, ну, да, все действительно
[01:09:32.640 --> 01:09:34.640]  будет выведено на экран, но тут не будет никаких
[01:09:34.640 --> 01:09:35.640]  пробелов.
[01:09:35.640 --> 01:09:36.640]  Почему?
[01:09:36.680 --> 01:09:39.680]  Потому что если я применил std this out a, std this out a, b, c,
[01:09:39.680 --> 01:09:40.680]  и так далее.
[01:09:40.680 --> 01:09:42.680]  То есть, если я увожу все вот так вот подряд, то,
[01:09:42.680 --> 01:09:44.680]  ну, естественно, никаких пробелов не появляется,
[01:09:44.680 --> 01:09:45.680]  никаких переносов строк не появляется.
[01:09:45.680 --> 01:09:46.680]  Вот.
[01:09:46.680 --> 01:09:47.680]  Вопрос.
[01:09:47.680 --> 01:09:48.680]  Что делать?
[01:09:48.680 --> 01:09:53.680]  Как сделать так, чтобы у меня появились пробелы?
[01:09:53.680 --> 01:09:58.680]  Ну, вот, к сожалению, так не получится.
[01:09:58.680 --> 01:10:04.680]  То есть, если я напишу вот так, что-то типа std this
[01:10:04.720 --> 01:10:12.720]  out a, c out, многоточие, не знаю, там, arx.
[01:10:14.720 --> 01:10:15.720]  Вот.
[01:10:15.720 --> 01:10:18.720]  Ну, во-первых, это не скомпилируется, потому что, ну,
[01:10:18.720 --> 01:10:20.720]  такого синтеза, ну, просто среди всех выражений свертки
[01:10:20.720 --> 01:10:21.720]  такого выражения нет.
[01:10:21.720 --> 01:10:22.720]  Вот.
[01:10:22.720 --> 01:10:25.720]  Если я напишу вот так, то это скомпилируется, но
[01:10:25.720 --> 01:10:26.720]  это скомпилируется как?
[01:10:26.720 --> 01:10:28.720]  Вот, что получится тут?
[01:10:29.720 --> 01:10:32.720]  Да, сначала все выведется, а потом в конце выведется
[01:10:32.720 --> 01:10:33.720]  один одинокий пробел.
[01:10:33.720 --> 01:10:45.960]  Вот. Что делать? Что добавить? А, в args пробел, ну типа через каждый args наставлять
[01:10:45.960 --> 01:10:54.440]  пробелов. Кстати, это интересная задача, типа вот взять args и между каждым
[01:10:54.440 --> 01:11:02.680]  args вставить пробел. Вот. Но я не уверен, что сейчас мы хотим это реализовывать.
[01:11:06.680 --> 01:11:11.080]  Вот это вот как раз такие идеи. Точнее, а, каждому args добавить пробел? Ну смотри, а как
[01:11:11.080 --> 01:11:24.880]  вы добавить каждому args пробел? А если тип не костуется к string view? И не как-то
[01:11:24.880 --> 01:11:29.560]  изменить. Ну можно, короче, ну можно написать свой собственный класс, у которого
[01:11:29.560 --> 01:11:32.080]  выбор с произволием типом будет работать как cout и плюс добавление
[01:11:32.080 --> 01:11:35.480]  пробелов. Ну давайте так, какой-нибудь неинвазивный мет, который бы не заставил
[01:11:35.480 --> 01:11:44.080]  нас писать какие-то новые типы, какие-то новые функции. Через что? Ну да, один из метных
[01:11:44.080 --> 01:11:48.440]  это использовать откусывание, но не хочется. Хочется вот в рамках этого. Смотрите, на
[01:11:48.440 --> 01:11:56.320]  самом деле, давайте просто вспомню, как это происходит на самом деле. Ну как мы
[01:11:56.320 --> 01:12:03.720]  обычно выводим данные через пробел? Ну мы обычно пишем что-то типа std cout x
[01:12:04.400 --> 01:12:15.000]  пробел, потом std cout y пробел, ну и так далее. Ну там обычно это происходит в цикле,
[01:12:15.000 --> 01:12:20.040]  да, ну так или иначе. Мы просто используем разные, мы просто используем для каждого
[01:12:20.040 --> 01:12:25.800]  вывода свою операцию, да, то есть cout x пробел, cout y пробел и так далее. Согласны? Вот.
[01:12:25.800 --> 01:12:31.720]  Вопрос. Есть ли какая-то операция, которая позволяет выполнить несколько операций подряд?
[01:12:31.720 --> 01:12:39.680]  Короче, я утверждаю, что нам сейчас нужно делать свертку не с операции вывода в поток,
[01:12:39.680 --> 01:12:43.360]  а с какой-то другой операции, которая позволит несколько операций выполнить вот в одном выражении.
[01:12:43.360 --> 01:12:51.200]  Операция запятая, вот. Давайте вспомним, что у нас на самом деле есть такая замечательная операция,
[01:12:51.200 --> 01:12:57.440]  как запятая. Ну и на самом деле с запятой тоже можно делать свертку. Да, то есть я могу написать
[01:12:57.440 --> 01:13:04.280]  номер args запятая многоточие. Что это означает? Это означает нужно применить операцию запятая
[01:13:04.280 --> 01:13:12.200]  к каждому аргументу, ну точнее ко всем аргументам. То есть args 0, args 1, args 2 и так далее. Так. Ну и
[01:13:12.200 --> 01:13:32.880]  собственно, что делаем? Предлагаю написать вот такой код. std sout, std sout args, дальше пробел,
[01:13:32.880 --> 01:13:46.920]  запятая многоточие круглые скобки. Давайте разбираться. Вот, смотрите, что стоит слева от
[01:13:46.920 --> 01:13:55.640]  запятой? Тут стоит пакет. Вот. Смотрите, если args пакет, то функция g применена к args это тоже пакет.
[01:13:55.640 --> 01:14:04.280]  Окей? Тут стоит args, это пакет. И к args я применил следующую операцию, выводов поток сиал и
[01:14:04.280 --> 01:14:08.720]  последующего вывода пробела. Вот. То есть это операция, которую нужно применить к отдельному
[01:14:08.720 --> 01:14:13.480]  аргументу. А теперь мне вот эту операцию нужно применить к каждому аргументу. Что я делаю? Я
[01:14:13.480 --> 01:14:21.960]  ставлю бинарную операцию запятая многоточие, вот вам свертка. Давайте проще. Просто если я написал
[01:14:21.960 --> 01:14:34.400]  вот так вот f от args, запятая многоточие, это было бы то же самое, как f от a0, запятая f от a1,
[01:14:34.400 --> 01:14:42.720]  запятая и так далее. Теперь представьте, что в качестве f выступает вот это вот. Понятно? Тогда
[01:14:42.720 --> 01:14:49.240]  будет std sout args, вывод пробела, запятая std sout args, вывод пробела и так далее. Понятно?
[01:14:52.200 --> 01:15:03.600]  Ну вот. Ну тут чуть наоборот, но ладно. Да-да-да, вот эти круглые скобки обязательно, потому что
[01:15:03.600 --> 01:15:14.160]  они ограничивают пакет. Вот. А, внешние? Внешние тоже обязательно, да. Давайте с плюсом. Если
[01:15:14.160 --> 01:15:21.920]  я напишу вот так, все понимают, что это a0, плюс a1, плюс и так далее, плюс an-1. Так? Ну, на самом
[01:15:21.920 --> 01:15:26.160]  деле, там правая статья, ну то есть там сначала будет справа, то есть складываться будет справа
[01:15:26.160 --> 01:15:29.760]  налево, но в целом идеологически понятно, да? Нет, смотрите, вот у меня функция print,
[01:15:29.760 --> 01:15:33.480]  которая принимает отдельно head и отдельно в список параметров. То есть тут я, блин,
[01:15:33.480 --> 01:15:36.960]  тут я на самом деле просто-напросто перемудрил, наверное, тут просто реализация функции print,
[01:15:36.960 --> 01:15:43.880]  которая не печатает лишних пробелов. Вообще говоря, можно и без этого обойтись, давайте целым. Как
[01:15:43.880 --> 01:16:01.760]  проще всего эту функцию реализовать? Просто template class многоточие args, void print, args, ну там по
[01:16:01.760 --> 01:16:09.520]  константной ссылке можно, многоточие args. Все, вот это единственная точка, которая содержится в функции
[01:16:09.520 --> 01:16:13.440]  print. Вот. Она выведет все параметры через пробел, ну там в конце еще будет лишний пробел, ну ладно,
[01:16:13.440 --> 01:16:21.360]  бог с ним. Окей? Вот. То есть как это работает? Это работает так, что, ну вот, давайте с операцией плюс
[01:16:21.360 --> 01:16:28.080]  рассмотрим. Вот args плюс что-то раскрывается вот с такую штуку. Если я к функции args применю
[01:16:28.080 --> 01:16:39.960]  какую-нибудь f от args, многоточие, то у меня будет f от 0, f от a0, плюс f от a1, плюс и так далее.
[01:16:39.960 --> 01:16:46.080]  Тоже понятно. Теперь мысленно заменяем f вот на, ну то есть представь себе, что f делает вот такую
[01:16:46.080 --> 01:16:52.000]  штуку. Да, функция f, она просто-напросто берет args, точнее берет аргумент и к нему применяет
[01:16:52.000 --> 01:17:07.240]  слева cout, справа вывод пробела. Все. std cout args пробел и плюс заменяем на запятую, потому что
[01:17:07.240 --> 01:17:17.520]  запятая тоже операция. Все. В итоге получается, ну вот это вот cout, давайте напишем, cout a0,
[01:17:17.520 --> 01:17:28.560]  пробел, запятая, cout a1, пробел, запятая, ну и так далее. Ну head тут нужен просто, ну смотрите,
[01:17:28.560 --> 01:17:33.640]  head мне нужен для того, чтобы я сначала вывел head, а потом все остальное через пробел. Ну потому
[01:17:33.640 --> 01:17:39.480]  что смотрите, вот в этой реализации как у меня все выводится? У меня выводится a0-пробел, a1-пробел,
[01:17:39.480 --> 01:17:45.560]  a2-пробел и так далее, an-пробел. То есть у меня в конце оказывается лишний пробел. Вот эта
[01:17:45.560 --> 01:17:50.720]  реализация просто написана для того, чтобы вот лишнего пробела в конце не было. Ну тут ладно,
[01:17:50.720 --> 01:18:00.400]  я переусложнил просто. Вот реализация. Окей? Ну и все, и последняя проблема. У вас мог возникнуть
[01:18:00.400 --> 01:18:04.920]  вопрос, ну смотрите, вот мы можем принимать произвольное количество параметров, а можно ли
[01:18:04.920 --> 01:18:09.280]  сделать так, чтобы я принимал произвольное количество параметров, но определенного типа. Например,
[01:18:09.280 --> 01:18:14.080]  я хочу написать функцию сумма int, и эта сумма int должна принимать только int. Могу ли я, например,
[01:18:14.080 --> 01:18:20.680]  написать вот так? Ответ нет, к сожалению. Вот. Просто так написать нельзя. На самом деле, в общем,
[01:18:20.680 --> 01:18:26.080]  эту проблему тоже можно победить, но с помощью шаблонной магии. В общем, если вам очень хочется,
[01:18:26.080 --> 01:18:30.360]  то можно попробовать написать что-то подобие такого. Вот. Вот такие штуки мы с вами тоже будем
[01:18:30.360 --> 01:18:36.640]  рассматривать, но ближе опять же к концу семестра. Но в целом мораль такая, что, к сожалению, шаблоны
[01:18:36.640 --> 01:18:41.760]  с переменом числом аргументов не позволяют очень просто написать функцию, которая бы принимала,
[01:18:41.760 --> 01:18:47.480]  например, только int или функцию, которая бы принимала только вектора и так далее. То есть это
[01:18:47.480 --> 01:18:53.600]  сделать можно, но довольно сложно. Что тогда, всем спасибо, до встречи на следующей неделе.
