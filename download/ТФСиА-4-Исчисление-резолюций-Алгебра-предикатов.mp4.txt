[00:00.000 --> 00:08.480]  Давайте начнем, наверное, по моим часам уже пора.
[00:08.480 --> 00:14.160]  Я напомню, что в прошлый раз я начал рассказывать
[00:14.160 --> 00:17.640]  о другой системе доказательств, основанной не на исчислении,
[00:17.640 --> 00:22.160]  высказывание, основанной на правильной резолюции.
[00:22.160 --> 00:26.520]  Я напомню, что такое правильная резолюция, это когда у нас
[00:26.520 --> 00:32.640]  есть две формулы, А дизюнция В и не А дизюнция С, мы можем
[00:32.640 --> 00:38.240]  вывести формулу В дизюнция С, но то, что это корректно,
[00:38.240 --> 00:41.160]  что если верхние две формулы истины, то нижние истины
[00:41.160 --> 00:46.400]  легко проверить, я в прошлый раз проверял, и я уже в прошлый
[00:46.400 --> 00:51.520]  раз сказал, что мы будем применять правила резолюции
[00:51.520 --> 00:55.520]  только для дизюнцев, то есть для дизюнций литералов
[00:55.520 --> 00:59.280]  переменных или их отрицаний, то есть фактически будем
[00:59.280 --> 01:03.360]  проверять для КНФ, причем для КНФ мы будем проверять
[01:03.360 --> 01:06.160]  невыполнимость, то есть мы будем доказывать автологичность
[01:06.160 --> 01:12.000]  ДНФ, а как в случае общих формул сводить к этому
[01:12.000 --> 01:15.760]  частному, ну в прошлый раз я объяснил сводимость.
[01:26.400 --> 01:28.960]  По любой булевой формуле я объяснил, как построить
[01:28.960 --> 01:33.640]  КНФ, выполнимость которой равносильна выполнимости
[01:33.640 --> 01:38.240]  исходной формулы, и построение достаточно эффективно.
[01:38.240 --> 01:43.080]  Для системы доказательств нам существенно, чтобы действия,
[01:43.080 --> 01:49.600]  которые мы выполняем были эффективны, занимали полимериальное
[01:49.600 --> 01:55.480]  общий длины входа-время, длины формулы и длины доказательства,
[01:55.480 --> 01:59.200]  но это я повторять не буду, это сводимость вам еще
[01:59.200 --> 02:03.040]  понадобится в следующем семестре в курсе по вычислительной
[02:03.040 --> 02:06.480]  сложности, поэтому вы с ней еще раз столкнетесь,
[02:06.480 --> 02:11.840]  но в ней вроде бы ничего особо сложного нет.
[02:11.840 --> 02:14.120]  Сегодня я хочу рассказать вторую часть этой системы
[02:14.120 --> 02:15.960]  доказательств, собственно некоторое формальное
[02:15.960 --> 02:19.160]  исчисление, которое я буду называть исчислительной
[02:19.160 --> 02:20.160]  дизолюцией.
[02:20.160 --> 02:33.160]  Оно устроено совершенно не так, как исчисление вы
[02:33.160 --> 02:35.080]  сказали, например у нас не будет ни одной аксиумы
[02:35.080 --> 02:42.440]  в этом исчислении, а что будет, будут дизюнкты, причем
[02:42.440 --> 02:45.800]  не произвольные, а некоторые стандартные дизюнкты.
[02:46.800 --> 02:54.800]  Что такое стандартные дизюнкты?
[02:54.800 --> 02:59.680]  Давайте я сразу напишу очевидные эквивалентности,
[02:59.680 --> 03:02.560]  если у вас есть дизюнкты х и не х, то это обязательно
[03:02.560 --> 03:06.440]  единица, если есть дизюнкты х и не х, то это равносильно
[03:06.440 --> 03:11.720]  х, поэтому если у вас есть дизюнкты, то есть дизюнкты
[03:11.720 --> 03:16.720]  переменных и их отрицаний, каких-то переменных, какие-то
[03:16.720 --> 03:20.320]  переменные могут быть позитивны, какие-то негативны, то что
[03:20.320 --> 03:25.040]  мы можем легко сделать с этим дизюнктом, мы, во-первых,
[03:25.040 --> 03:29.560]  можем проверить, что нет вот таких вот пар противоположных
[03:29.560 --> 03:31.680]  литералов, потому что если они есть, этот дизюнкт
[03:31.680 --> 03:34.560]  х и не х и не единица, мы его можем из рассмотрения
[03:34.560 --> 03:40.040]  выбросить, и никакой литерал не повторяется, потому
[03:40.240 --> 03:46.280]  что не только х или х равносильно х, но и не х или не х равносильно
[03:46.280 --> 03:51.560]  не х, значит, если у нас какой-то литерал повторяется,
[03:51.560 --> 03:57.120]  то мы можем выбросить повторение, оставить только одно вхождение.
[03:57.120 --> 04:04.000]  Другими словами, стандартный дизюнкт мы можем рассматривать,
[04:04.000 --> 04:07.040]  вспомним еще, что дизюнкты коммутативно и ассоциативно,
[04:07.040 --> 04:11.120]  неважно в каком порядке в дизюнке записаны литералы,
[04:11.120 --> 04:17.760]  и вот стандартный дизюнкт нам удобно так будет считать,
[04:17.760 --> 04:31.800]  это множество литералов, не содержащие противоположных
[04:31.800 --> 04:50.880]  литералов. Ну вот как в этом примере. Множество
[04:50.880 --> 04:52.880]  это уже самокупность, то есть нам не важно в каком
[04:52.880 --> 04:54.920]  они идут в порядке, мы просто будем рассматривать как
[04:54.920 --> 04:58.400]  множество, хотя записывать я буду точно также с помощью
[04:58.400 --> 05:07.400]  операции дизюнкт. И вот мы будем строить исчисления,
[05:07.400 --> 05:09.520]  в котором будут использоваться стандартные дизюнкты,
[05:09.520 --> 05:11.840]  это будут те формулы, которые мы используем, никаких
[05:11.840 --> 05:19.680]  других формул у нас не будет. На стандартных дизюнктах
[05:19.680 --> 05:27.840]  я определю операцию дизюнкт, определю я немножко необычным
[05:27.840 --> 05:49.080]  способом, это настоящая дизюнкта, если она не содержит
[05:49.080 --> 05:54.200]  противоположных литералов, ну а если вдруг возникают
[05:54.200 --> 06:00.560]  повторения, мы их убираем. А в противном случае мы
[06:00.560 --> 06:07.320]  будем считать, что операция не определена. То есть вот
[06:07.320 --> 06:23.240]  смотрите, если я возьму дизюнцию двух таких литералов, ну
[06:23.720 --> 06:29.680]  то есть дизюнция х или у или х или не у, то у меня получится
[06:29.680 --> 06:32.360]  в результате, если я просто как множество объединю, у
[06:32.360 --> 06:38.240]  меня получится такое множество х, у, не у. Ну вот мы считаем,
[06:38.240 --> 06:40.960]  мы хотим ограничиться только стандартными дизюнтами,
[06:40.960 --> 06:43.040]  результат перестает быть стандартным дизюнтом, поэтому
[06:43.040 --> 06:45.480]  мы считаем, что операция в этом случае не определена,
[06:45.480 --> 06:49.640]  а так удобнее. То есть у нас дизюнция на стандартных
[06:49.640 --> 06:55.720]  дизюнках не всегда определена. Есть конечно специальный
[06:55.720 --> 06:59.760]  дизюнт, вот я его так напишу, ложь это пустое множество
[06:59.760 --> 07:15.160]  литералов. И теперь используя эту операцию и правила резолюции
[07:15.160 --> 07:19.240]  я определю, что такое вывод в исчислении резолюции.
[07:19.240 --> 07:43.320]  Я буду называть резолютивный вывод. Ну поскольку у нас
[07:43.320 --> 07:47.400]  вообще нет аксиом, из чего-то выводить нам нужно, поэтому
[07:47.520 --> 07:50.000]  мы считаем, что у нас есть некоторое множество дизюнтов
[07:50.000 --> 07:56.200]  заранее заданное, и мы строим из него вывод. Вывод, это
[07:56.200 --> 08:01.600]  как раз похоже на то, что у нас было раньше, это последовательность
[08:01.600 --> 08:12.440]  дизюнтов. Вот это вот вывод. Если выполнены обоснования,
[08:12.440 --> 08:14.440]  я напомню, что когда у нас было исчисление высказывания,
[08:14.480 --> 08:18.320]  у нас вывод тоже был последовательность формул, и каждая формула
[08:18.320 --> 08:20.320]  в выводе должна была быть обоснована. Обоснования
[08:20.320 --> 08:23.960]  у нас теперь будут другими. Первое обоснование для
[08:23.960 --> 08:33.400]  любого и одно из возможных обоснований, что этот
[08:33.400 --> 08:38.640]  дизюнт просто входит в множество гамма. Это напоминает вывод
[08:38.640 --> 08:42.160]  из епотез вычислений высказываний, то есть то, что у нас множество
[08:42.160 --> 08:45.360]  гамма входит, мы вывод можем вставлять, этого достаточно
[08:45.360 --> 08:53.320]  для обоснования этого дизюнта. А вот второй случай, он такой,
[08:53.320 --> 08:57.080]  у нас наш дизюнт получается из каких-то предыдущих
[08:57.080 --> 08:59.600]  правилам резолюции. Я сейчас формально напишу, что это
[08:59.600 --> 09:03.760]  означает. Вот у нас есть какие-то индексы ж и к, строго
[09:03.760 --> 09:10.520]  меньше, чем и. Дж т – это какой-то дизюнт х или дизюнт
[09:10.520 --> 09:18.480]  с чем-то там д штрих ж т. Д к т – это наоборот не х или
[09:18.480 --> 09:27.080]  какой-то дизюнт д штрих к т. А д и т, вот посмотрите
[09:27.080 --> 09:30.400]  на эти два дизюнта, на правила резолюции, что мы с помощью
[09:31.360 --> 09:38.440]  этих двух дизюнтов можем вывести в новую дизюнцию
[09:38.440 --> 09:43.440]  этих вот хвостиков. То есть мы убираем переменную х,
[09:43.440 --> 09:46.000]  которая входит противоположно в эти дизюнты и берем дизюнцию
[09:46.000 --> 09:50.120]  всего, что осталось. При этом здесь я имею в виду, что
[09:50.120 --> 09:53.240]  я применяю операцию на стандартных дизюнтах. То
[09:53.240 --> 09:56.800]  есть это все стандартные дизюнты. Я дальше снова
[09:56.800 --> 10:01.240]  стандартные буду все время пропускать, потому что
[10:01.240 --> 10:06.600]  в этом исчислении у нас только стандартные дизюнты
[10:06.600 --> 10:11.400]  используют. И в частности мы не можем вставлять не
[10:11.400 --> 10:15.000]  стандартные дизюнты, там х или не х мы не вставляем.
[10:15.000 --> 10:19.440]  Хуже бы от этого не было, но так удобнее для последующего
[10:19.440 --> 10:24.040]  доказательства, удобнее сразу запретить такие вставки.
[10:24.040 --> 10:31.800]  Это вывод. Значит мы пишем, что из множества гамма,
[10:31.800 --> 10:36.720]  вот я напомню такая вертикальная черта, сопровождаемая горизонтальной
[10:36.720 --> 10:39.320]  чертой, означает синтаксический вывод. Чтобы отличать от
[10:39.320 --> 10:45.280]  вывода в исчислении высказывания я букву QR припишу. И вот
[10:45.280 --> 10:48.960]  если из множества дизюнктов гамма мы можем вывести
[10:48.960 --> 10:53.360]  пустой дизюнт, то это называется, такой вывод называется
[10:53.360 --> 11:05.160]  опроверирование гамм. Ну почему так называется? А вот
[11:05.160 --> 11:10.480]  почему. КНФ мы можем рассматривать тоже как множество дизюнктов,
[11:10.480 --> 11:12.640]  потому что кайюнтся тоже коммутативно и ассоциативно,
[11:12.640 --> 11:15.240]  не важно в каком порядке мы ставим дизюнкты. У нас
[11:15.240 --> 11:18.120]  есть КНФ, мы можем взять множество входящих в нее
[11:18.120 --> 11:22.560]  дизюнктов и начать делать вот такие резолютивные
[11:22.560 --> 11:28.080]  выводы. И если у нас получилась ложь, я сейчас вам докажу,
[11:28.080 --> 11:34.040]  это очень просто, это означает, что КНФ не выполнимо. И верное
[11:34.040 --> 11:38.560]  и обратное, если КНФ не выполнимо, мы можем вывести
[11:38.560 --> 11:41.600]  тождественноложные дизюнты с дизюнтом этой КНФ. То
[11:41.600 --> 11:45.760]  есть у нас есть теоремы корректности и полноты.
[11:45.760 --> 12:04.840]  Корректность означает, что если мы вывели пустой
[12:04.840 --> 12:17.000]  дизюнт, то, ну я это запишу, вот использую значок семантического
[12:17.000 --> 12:20.240]  следствия, потому что это коротко, а на словах расскажу,
[12:20.240 --> 12:23.160]  что это множество невыполнимо, то есть у нас нет выполняющего
[12:23.160 --> 12:27.360]  набора для гаммы. Какой бы набор переменных мы ни
[12:27.360 --> 12:32.160]  взяли, хотя бы один из дизюнтов обращается в ноль. И тогда
[12:32.160 --> 12:37.180]  только такие невыполнимые наборы, из них может семантически
[12:37.180 --> 12:39.560]  следовать ложь, потому что если хотя бы на каком-то
[12:39.560 --> 12:43.280]  наборе все дизюнты были бы истинны, мы пришли бы
[12:43.280 --> 12:45.920]  противоречию с определением к тому, что этот дизюнт всегда
[12:45.920 --> 12:49.760]  ложен на любом наборе. Ну а полнота это в обратную
[12:49.760 --> 13:07.160]  сторону. Если наше множество дизюнтов не выполнимо, то
[13:07.160 --> 13:12.560]  существует резолютивный вывод тождест наложенного
[13:12.560 --> 13:15.240]  дизюнта, то есть можно опровернуть с помощью резолютивного
[13:15.240 --> 13:20.400]  вывода это множество дизюнтов. Вот сейчас моя цель доказать
[13:20.400 --> 13:23.920]  эти две теоремы. Первая, как обычно, проще намного.
[13:23.920 --> 13:26.160]  Вторая чуть посложнее, но тоже не сказать, что очень
[13:26.160 --> 13:42.280]  сложная. Давайте корректность. Удобно доказывать контрапозицию.
[13:42.280 --> 13:46.480]  Я напомню, что если из А следует Б, равно сильно
[13:46.480 --> 13:49.040]  тому, что из НЕ Б следует НЕ А. Это контрапозиция
[13:49.040 --> 13:57.760]  называется. И я буду доказывать, что если наше множество
[13:57.760 --> 14:01.800]  дизюнтов выполнимо, то есть на каком-то наборе значений
[14:01.800 --> 14:05.080]  переменных все дизюнты обращаются в единицу, то
[14:05.080 --> 14:09.200]  тогда из такого множества мы точно не сможем вывести
[14:09.200 --> 14:17.720]  пустой дизюнт. Как это доказывать? Индукции по длине вывода.
[14:17.720 --> 14:31.400]  Смотрите база. Если у нас в выводе всего один дизюнт,
[14:31.400 --> 14:34.800]  то он не может получиться резолюцией, потому что резолюция
[14:34.800 --> 14:37.360]  требует, чтобы было хотя бы два предшественника.
[14:37.360 --> 14:41.640]  Значит первый дизюнт в выводе всегда принадлежит
[14:41.640 --> 14:45.880]  гамма и значит на вот этом наборе, у нас по предположению
[14:45.880 --> 14:49.680]  есть выполняющий набор, он равен единице. Теперь
[14:49.680 --> 14:54.680]  я буду доказывать, что любой дизюнт в этом выводе, да
[14:54.680 --> 15:01.120]  вот тут я это забыл написать где-нибудь, вот что я буду
[15:01.120 --> 15:03.440]  доказывать по индукции, что любой дизюнт в этом
[15:03.440 --> 15:06.200]  выводе не выполним. И этого достаточно, потому что понятно,
[15:06.200 --> 15:11.520]  что это ждестоложный дизюнт не выполним ни на каком
[15:11.520 --> 15:17.080]  наборе, значит он в выводе не встретится. Ну давайте
[15:17.080 --> 15:24.000]  смотреть, что нам нужно осталось проверить. Перехват шах индукции.
[15:24.000 --> 15:31.560]  Опять-таки если dkt принадлежит гамма, уже разобрались,
[15:31.560 --> 15:54.120]  то пусть dkt получается правилом резолюции. И из каких-то ds dr с меньшими индексами.
[15:54.120 --> 15:59.720]  По индуктивному предположению ds на выполняющем наборе
[15:59.720 --> 16:04.720]  равен единице и dr на выполняющем наборе равен единице. Но
[16:04.720 --> 16:10.080]  тогда мы проверяли корректность правила резолюции тогда
[16:10.080 --> 16:13.080]  и то, что получается по правилам резолюции тоже будет равно
[16:13.080 --> 16:19.640]  единице. Ну и все, значит все дизюнты, если у нас
[16:19.640 --> 16:24.200]  есть выполняющий набор для множества дизюнтов гамма,
[16:24.200 --> 16:30.880]  то все дизюнты, которые мы можем резолютивно вывести, они все на
[16:30.880 --> 16:35.320]  этом наборе обращаются в единицу. Так что, как видите, теорема корректности совсем
[16:35.320 --> 16:39.520]  простая. Теорема о полноте существенно проще, чем теорема о полноте для
[16:39.520 --> 16:47.840]  исчисления высказываний, но она тоже, конечно, требует некоторых рассуждений.
[16:47.840 --> 16:56.280]  Давайте я, ну про стандартные дизюнты я думаю это понятно, я это сотру.
[16:56.280 --> 17:13.440]  Так я буду доказывать полноту. Причем я опять-таки буду доказывать контрапозицию,
[17:13.480 --> 17:35.120]  что если из гамма не выводится пустой дизюнт, то тогда гамма выполним. Доказательство тоже
[17:35.120 --> 17:39.160]  использует идею пополнения, как и в случае исчисления высказываний. Но там, если вы
[17:39.160 --> 17:44.280]  помните, пополнение было таким достаточно хитроумным, здесь пополнение будет существенно проще.
[17:44.280 --> 18:00.280]  Ну у нас вообще и аксиом нет, сама формальная система выглядит проще. В пополнение я включу
[18:00.280 --> 18:07.240]  все дизюнты, которые можно вывести из этого множества. Тут самое время сказать, посмотрите
[18:07.240 --> 18:13.560]  на формулировку. От множества дизюнтов я не требую, чтобы оно было конечным. Дальше,
[18:13.560 --> 18:18.160]  во второй части курса, это мне будет очень существенно. Когда мы проверяем выполнимость
[18:18.160 --> 18:24.760]  КНФ, у нас, конечно, мы все выводим из конечного множества дизюнтов. Но дальше мы будем использовать
[18:24.760 --> 18:30.040]  исчисление резолюции в более сложной ситуации, у нас будет бесконечная множество дизюнтов. Так вот
[18:30.040 --> 18:35.000]  то, что я сейчас рассказываю, на всякий случай держите в голове, если возникнут подозрения,
[18:35.000 --> 18:41.680]  то обязательно переспросите. Множество гамма может быть бесконечным. Ничего не испортится
[18:41.680 --> 18:50.720]  в моем рассуждении. Итак, это я буду называть пополнением. И по нашему предположению, если взять
[18:50.720 --> 18:58.320]  контрапозицию, я знаю, что пустой дизюнт не принадлежит пополнению, его нельзя вывести. И вот
[18:58.320 --> 19:07.720]  исходя из вот этого, мне нужно, исходя из этого условия, мне нужно построить выполняющий набор.
[19:07.720 --> 19:14.120]  Здесь построение будет просто конструктивным. Я вам сейчас явно предъявлю правила, как этот
[19:14.120 --> 19:25.760]  набор строить. Вот пусть мы уже присвоили значение первым К переменным. Первым К
[19:25.760 --> 19:27.320]  минус одной давайте переменной.
[19:27.320 --> 19:55.160]  Да, здесь мне удобно ввести еще одно понятие, еще одно обозначение.
[19:55.160 --> 20:23.840]  Я хочу разбить вот это пополнение на множество.
[20:23.840 --> 20:30.280]  В каждой дизюнт входит лишь конечное количество переменных. И вот в множество гамма К-та я включу
[20:30.280 --> 20:36.880]  те дизъемки, куда входит только переменная с номерами х1, х2, хк. У нас множество переменных,
[20:36.880 --> 20:43.000]  оно вообще говоря бесконечно, но оно счетно. Мы считаем, то есть оно занумеровано какими-то
[20:43.000 --> 20:50.880]  натуральными числами. И поэтому возникает такое разбиение в соответствии с тем, какие перемены
[20:50.880 --> 20:56.840]  входят. Если входит только первая К переменных, причем К-та обязательно входит, то это дизъюнт из
[20:56.840 --> 21:01.920]  множества гамма К-та. Второе условие нужно для того, чтобы эти множества не пересекались. То есть у нас
[21:01.920 --> 21:07.720]  всегда в каждом дизъюнте будет литерал с наибольшим индексом, переменная или отрицание с наибольшим
[21:07.720 --> 21:15.160]  индексом. Вот в соответствующее множество этот дизъюнт будет входить. И вот теперь правило,
[21:15.160 --> 21:24.960]  как определить значение альфа-катова. Альфа-ката это значение переменной хкатой на наборе альфа.
[21:24.960 --> 21:53.720]  И мы его определяем так. Это ноль. Сейчас давайте я напишу, чтобы потом сказать словами, а то получится
[21:53.720 --> 22:07.360]  плохо. Смотрите, мы пробуем все дизъюнты из гамма К-това. То есть я сейчас присваиваю катой
[22:07.360 --> 22:15.200]  переменной значения. Смотрю на все дизъюнты из гамма К-това. И смотрю, есть ли такой дизъюнт,
[22:15.200 --> 22:19.840]  что вот всем предыдущим переменным значение уже присвоено. Теперь я катой переменной присваиваю
[22:19.840 --> 22:26.160]  значение ноль. И смотрю, не случилось ли так, что какой-то из дизъюнтов обратился в ноль. Если не
[22:26.160 --> 22:33.800]  случилось, я присваиваю альфа-катой ноль. А если случилось, то тогда присваиваю единицу. Причем
[22:33.800 --> 22:38.040]  заметьте, что вот этот вот случай, он не обязательно означает, что у нас есть дизъюнты
[22:38.040 --> 22:43.920]  в гамма-кате. Поэтому я тут так сложен и писал. Нет, дизъюнта. Если гамма-катая пустой, такой же
[22:43.920 --> 22:51.800]  может быть, что нет дизъюнта, в котором максимальный индекс литерала именно ровно к. Почему нет? Такое,
[22:51.800 --> 22:57.760]  в принципе, может случиться. Ну, тогда у нас все равно нет дизъюнта из этого множества, на котором,
[22:57.760 --> 23:03.280]  который бы обращался в ноль, вот на таком наборе. И значит, мы смело присваиваем катой
[23:03.280 --> 23:09.080]  переменной значения ноль. А в противном случае, если такой дизъюнт нашелся, мы присваиваем единицу.
[23:09.080 --> 23:26.880]  То есть, как видите, очень простой процесс.
[23:26.880 --> 23:41.040]  Простое правило. То есть, мы присваиваем ноль, если мы не видим, что какой-то из дизъюнтов уже
[23:41.040 --> 23:48.160]  обратился в ноль. Тогда плохо. Я напомню, что мы хотим построить выполняющий набор. Если бы я вот
[23:48.160 --> 23:55.280]  в такой ситуации присвоил бы катой переменной значения ноль, соответствующий набор значений
[23:55.280 --> 24:01.120]  переменных уже не был бы выполняющим. Вот он дизъюнт, который обратился в ноль. То есть, мы
[24:01.120 --> 24:09.840]  присваиваем единицу только в том случае, когда мы явно видим проблему, что вот если присвоить ноль,
[24:09.840 --> 24:16.560]  то плохо. Конечно, правило однозначно. Он задает набор значений переменных. Но будет ли этот
[24:16.560 --> 24:23.600]  набор выполняющим, пока не ясно. Почему? Потому что может же так случиться, что какой-то другой
[24:23.600 --> 24:32.480]  дизъюнт обращается в ноль, когда значение этой переменной равно единице. Это мы пока не проверяли.
[24:32.480 --> 24:46.880]  И вот нам нужно убедиться. Значит, альфа-выполняющий набор я хочу доказать. И доказывать я это буду по
[24:46.880 --> 24:52.520]  шагам индукции по вот этому k. То есть, я буду доказывать, что каждый дизъюнт из каждого множества
[24:52.800 --> 25:00.520]  гаммакаты на этом наборе выполнимый. Заметьте, что у нас пустой дизъюнт не входит, поэтому объединение
[25:00.520 --> 25:08.200]  гаммакатых, начиная с единицы, она просто совпадает со всем пополнением. То есть, если я докажу вот это
[25:08.200 --> 25:14.160]  утверждение, то это и будет означать, что все пополнение выполнимо на этом наборе. А пополнение,
[25:14.160 --> 25:20.600]  конечно, содержит все дизъюнты исходного множества. Потому что один из возможных
[25:20.600 --> 25:26.800]  резолютивных выводов это просто написать дизъюнт из исходного множества. То есть, гамма-штрих заведомо
[25:26.800 --> 25:39.680]  содержит гамму. Вот план доказательства. Теперь надо проверить, что все-таки построенный набор выполняющий.
[25:39.680 --> 25:59.520]  Ну, сейчас сделаем. Опять-таки база. У нас есть ровно два дизъюнта, которые могут входить в множество
[25:59.520 --> 26:09.640]  гамма-1. Это переменная х1 или отрицание переменной х1. Оба этих литерала входить не могут. Почему? Потому
[26:09.680 --> 26:17.120]  что иначе по правилу резолюции мы могли вывести пустой дизъюнт. Я напомню, что к таким дизъюнтам вполне
[26:17.120 --> 26:26.080]  себе можно применить правила резолюции. И получается как раз пустой дизъюнт. А мы знаем, что пустой дизъюнт
[26:26.080 --> 26:30.960]  вывести нельзя. Значит, у нас входит либо один, либо другой. Давайте рассмотрим два случая. Пусть
[26:30.960 --> 26:43.360]  входит х1. И это тогда в точности гамма-1. Может вообще ничего не входить, но тогда вообще проблем
[26:43.360 --> 26:52.560]  нет. У нас все дизъюнты выполнимы, поскольку ни одного нет. Значит, если входит х1, давайте смотреть.
[26:52.560 --> 27:00.040]  Это правило применимое при к равном единице. Просто вот присвоенных значений пока ни одного
[27:00.040 --> 27:06.920]  нет. Значит, есть ли у нас дизъюнт, который в нуле обращается в ноль? Есть. Это х1. Значит, по нашему
[27:06.920 --> 27:13.600]  построению в таком случае альфа-1 равен единице. Ну и на таком наборе значений переменных, понятное
[27:13.600 --> 27:26.120]  дело, дизъюнт х1 выполним. А если отрицание входит в гамма-1, то тогда смотрите, нет дизъюнта,
[27:26.120 --> 27:31.960]  который бы в нуле обращался бы в ноль, потому что отрицание обращается в единицу. Значит,
[27:31.960 --> 27:40.960]  альфа-1 равно нулю. И опять-таки вот этот дизъюнт выполним. Вот база разбор двух случаев. Теперь шаг.
[27:40.960 --> 28:00.960]  Значит, мы предполагаем, что мы уже доказали, что дизъюнт из множества гамма житом на наборе
[28:00.960 --> 28:08.520]  альфа обращается в единицу при всех же меньших k. Теперь мы рассматриваем дизъюнт из множества
[28:08.520 --> 28:24.720]  гамма k. Давайте рассуждать от противного. Пусть он обращается в ноль. Что мы можем сказать про
[28:24.720 --> 28:34.160]  этот дизъюнт? Я утверждаю тогда, что альфа-катая обязательно равно единице. Посмотрите на правило.
[28:34.160 --> 28:40.400]  Альфа-катая равно нулю только в том случае, когда все такие дизъюнты не обращаются в ноль на
[28:40.400 --> 28:48.600]  таком наборе. Значит, альфа-катая равно единице. А при этом, да, и переменная х-катая входит в этот
[28:48.600 --> 29:02.480]  дизъюнт. Как она может входить? Только позитивно. И это вот какие-то в дизъюнт д-штрих входят какие-то
[29:02.480 --> 29:09.120]  переменные с меньшими номерами. Потому что, если входило отрицание х-катого, то этот дизъюнт
[29:09.120 --> 29:23.880]  обращался бы в единицу. Сейчас, или я перепутал. Перепутал. Должен ходить негативно, потому что на
[29:23.880 --> 29:29.880]  единицу он должен обращаться в ноль. Значит, если я подставляю вместо х-катого единицу и стояла бы
[29:29.880 --> 29:35.680]  позитивно эта переменная, то тогда это уже была бы единица. Нет, нам нужно именно, чтобы он входил
[29:35.680 --> 29:47.960]  негативно, то есть входило отрицание этой переменной. Это вот то, что мы из нашего предположения,
[29:47.960 --> 29:54.720]  что есть какой-то дизъюнт, который обращается в ноль. Но теперь давайте извлечем информацию вот
[29:54.720 --> 30:02.520]  отсюда. Посмотрим на наши правила. Раз мы присвоили единицу, значит, у нас должен быть какой-то
[30:02.520 --> 30:21.240]  другой дизъюнт D1, который обращается в ноль вот на таком наборе. Что это означает? Это означает,
[30:21.240 --> 30:31.400]  что D1, вот в D1 как раз х-катая должна входить позитивно. То есть сама переменная не ее отрицание,
[30:31.400 --> 30:36.880]  потому что если я подставляю вместо х-катого ноль, этот дизъюнт должен обратиться в ноль. И в
[30:36.880 --> 30:43.880]  частности, кстати, вот эти вот хвостики один и другой тоже должны обращаться в ноль. Это же у
[30:43.880 --> 30:53.320]  нас дизъюнт С. Раз D от α равно нулю и D это дизъюнт С2 формул, то каждая должна обращаться в ноль.
[30:53.320 --> 31:03.400]  То же самое здесь. И D' это два штриха уже принадлежат меньшим множествам. То есть D' принадлежит
[31:03.400 --> 31:18.520]  ну какому-то гамма и тому и меньше k. D' принадлежит какому-то гамма ж тому и меньше k. Потому что мы
[31:18.520 --> 31:27.640]  выделили х-каты это максимальный к это максимальный индекс переменной, которая входит в дизъюнт D. Все
[31:27.640 --> 31:37.440]  остальные имеют меньшее номера. И мы знаем, что они еще обращаются в ноль. Ну теперь смотрите. Вот у
[31:37.440 --> 31:49.840]  нас есть такой дизъюнт. Есть такой дизъюнт. Поскольку мы говорим о множестве гамма kt, это множество
[31:49.840 --> 31:55.800]  пополнения. То есть оба эти дизъюнта можно вывести резолюциями из исходного множества гамма. Но я
[31:55.800 --> 32:03.920]  утверждаю, что тогда, смотрите, тут х-каты или D' а тут не х-каты или D'. Но применим правило
[32:03.920 --> 32:18.440]  резолюции. Значит получаем, что вот такой дизъюнт, ну он принадлежит какому-то, он тоже принадлежит
[32:18.440 --> 32:22.840]  множеству гамма, пополнению. Потому что он получается из имеющихся дизъюнтов применением
[32:22.840 --> 32:28.520]  резолюции. В пополнении мы включаем все, что можно вывести. Мы могли бы добавить этот шаг в вывод.
[32:30.520 --> 32:40.880]  Ну и теперь смотрите, этот дизъюнт обращается в ноль. И второй дизъюнт обращается в ноль. Ну
[32:40.880 --> 32:49.600]  значит их дизъюнт обращается в ноль. А мы предположили, вот смотрите, у нас есть индуктивное
[32:49.600 --> 32:55.840]  предположение, что все дизъюнты, которые попали множество с меньшими номерами, обращаются в единицу.
[32:55.840 --> 33:04.480]  Пришли к противоречию. Рассуждение всем хорошо, но есть в нем один недостаток. Может быть кто-то уже
[33:04.480 --> 33:20.000]  видит. Ну тут может быть это трудно заметить, я тщательно это замаскировал. Когда я так лихо
[33:20.000 --> 33:33.200]  применяю правила резолюции, у меня же на стандартных дизъюнтах резолюция определения
[33:33.200 --> 33:39.600]  всегда вдруг правила резолюции применяют только тогда, когда то, что получилось является стандартным
[33:39.600 --> 33:47.600]  дизъюнтом. Вдруг так не получится. На самом деле в этом рассуждении уже скрытое объяснение,
[33:47.600 --> 33:56.960]  почему такого в нашем случае не будет. Ведь смотрите, если бы D' это два штриха включали
[33:56.960 --> 34:04.200]  в себя пару противоположных литералов, скажем Y и не Y. В дизъюнтце входило бы Y или не Y и такой
[34:04.200 --> 34:12.800]  дизъюнт был тождественно равен единице. Но мы знаем, что и этот дизъюнт ноль, и этот дизъюнт ноль,
[34:12.800 --> 34:19.280]  значит дизъюнция двух нулевых дизъюнтов тоже ноль, поэтому такого быть не может. Значит правила
[34:19.280 --> 34:28.640]  резолюции в данном случае применяют. Ну вот и все. Полнота тоже доказана. То есть как видите,
[34:28.640 --> 34:34.720]  здесь доказательства проще. Идея очень похожа. Вот почему я хотел рассказать именно то доказательство
[34:34.720 --> 34:40.880]  для исчисления высказаний. Идея пополнения, она очень важна. Это такая путеводная идея для
[34:40.880 --> 34:47.520]  доказательства полноты в логике. Здесь это все гораздо проще во многом за счет того, что мы
[34:47.520 --> 34:58.400]  можем вот так вот достаточно просто построить выполняющий набор. Нам, помните, для исчисления
[34:58.400 --> 35:02.720]  высказаний нужна была лемма кальмара, какие-то там строить выводы, то есть там было такое очень
[35:02.720 --> 35:07.320]  неявное построение. А здесь буквально мы просто смотрим, то есть все очень конструктивно. Мы
[35:07.320 --> 35:13.880]  смотрим на дизъюнты, которые у нас есть. Причем, заметьте, это для будущего будет полезно. В каждое
[35:13.880 --> 35:18.000]  множество гамма вкатая входит лишь конечное множество дизъюнтов. Потому что стандартных
[35:18.000 --> 35:26.720]  дизъюнтов на N переменных, их не очень много. Какие у нас варианты для каждой переменной? Ну три. Входят
[35:26.720 --> 35:31.880]  позитивно, входят негативно или вообще не входят. Значит всего стандартных дизъюнтов на N
[35:31.880 --> 35:38.000]  переменных 3 в степени N. То есть когда я делаю такое построение, я на каждом шаге этого построения
[35:38.000 --> 35:45.440]  работаю только с конечным множеством. Все конструктивно. Даже если все множество бесконечно,
[35:45.440 --> 35:51.480]  каждый шаг, тем не менее до каждого шага с номером K я дойти могу за конечное время. Это будет
[35:51.480 --> 36:01.400]  существенно дальше. Ну и вот все, значит эти теоремы доказаны. Давайте теперь соберемся вместе,
[36:01.400 --> 36:10.240]  то что я говорил в прошлый раз. Это исчисление резолюции. Я напомню, значит у нас появляется
[36:10.240 --> 36:25.120]  такая система доказательств тавтологии. То есть я напомню, что это значит. У нас есть какой-то
[36:25.120 --> 36:31.440]  алгоритм, который получает на вход формулу. То есть он получает два текста. Формула и
[36:31.440 --> 36:40.640]  доказательства. Доказательства в кавычках, потому что это может быть все что угодно. Важно что этот
[36:40.640 --> 36:46.600]  алгоритм работает эффективно, то есть за полимониальное время от длины записи формулы и доказательства.
[36:46.600 --> 36:57.320]  И он дает единицу в том случае, если это действительно доказательство для формулы. То есть
[36:57.320 --> 37:01.360]  что это означает? Что если формула тавтология, какое-то доказательство это подтверждает. Может
[37:01.360 --> 37:24.000]  быть ни одно. Я напомню это важное понятие. Если у нас формула тавтология, то мы можем
[37:24.000 --> 37:41.840]  подобрать подходящее доказательство. Если ФИ не тавтология, то какое бы доказательство мы не
[37:41.840 --> 37:46.400]  совали в систему доказательств, система доказательств его отвергнет. Будет говорить,
[37:46.400 --> 37:51.920]  что нет. Доказательство неправильное. Где-то там есть ошибка. То есть наш алгоритм проверяет,
[37:51.920 --> 37:57.320]  что П является доказательством тавтологичности формулы ФИ. И вот какую же систему доказательств
[37:57.320 --> 38:11.720]  мы построили? Берем формулу. Первым делом мы ее заменяем на отрицание. Затем, посмотрите на
[38:11.720 --> 38:24.520]  левую доску. Применяем сводимость, строим КНФ. А затем мы должны построить резолютивный вывод
[38:24.520 --> 38:36.720]  лжи из этой КНФ. То есть мы должны... У нас П, доказательство, будет содержать себе такую вещь.
[38:36.720 --> 38:52.160]  Ну мы можем записать туда вот эту вот КНФ и резолютивный вывод. И теперь что нам нужно? Что
[38:52.160 --> 38:56.240]  наш алгоритм должен сделать? Он должен проверить, что вот эта запись корректно соответствует
[38:56.240 --> 39:01.960]  формуле. То есть что алгоритму несложно приписать к формуле отрицания. После этого он должен
[39:01.960 --> 39:06.840]  проделать те шаги, которые я в прошлый раз описал. То есть сделать разбор формул отрицания ФИ,
[39:06.840 --> 39:12.840]  ввести дополнительные переменные, построить эту КНФ, которая там у меня была построена, и проверить,
[39:12.840 --> 39:20.360]  что в доказательстве записана именно она. После этого остальная часть доказательств это резолютивный
[39:20.360 --> 39:25.680]  вывод. Ну и алгоритм должен проверять, что каждый следующий шаг в этой выводе обоснован. То есть
[39:25.680 --> 39:31.320]  что либо мы видим в соответствующем, в этой КНФ видим соответствующий дизюнт, если нет,
[39:31.320 --> 39:37.400]  то нужно из предыдущих дизюнтов получить данные с помощью резолюции. Понятно, что это проверяется
[39:37.400 --> 39:43.080]  эффективно. Вы просто перебираете все пары, возможно, и смотрите, получается ли данный дизюнт.
[39:43.080 --> 39:50.880]  Из этого применением резолюция. Правило-то очень простое. Таким образом у нас получается система
[39:50.880 --> 39:56.680]  доказательств. Так, ну давайте продолжим. Значит, итак, у нас появились две системы
[39:56.680 --> 40:07.040]  доказательств тавтологии. И, как всегда, в таких случаях хочется их сравнить. Какая лучше? Ну,
[40:07.040 --> 40:13.320]  в каком смысле лучше? Они обе адекватные, они обе доказывают тавтологичность. Лучше в том смысле,
[40:13.320 --> 40:19.920]  в каких доказательствах короче? Я напомню, что нас, естественно, больше интересуют случаи,
[40:19.920 --> 40:23.640]  когда есть короткие доказательства. Если все доказательства очень длинные, это не очень
[40:23.640 --> 40:39.320]  интересно. И тут ответ на этот вопрос, какая лучше, он очень неожиданный. В теории исчисление
[40:39.320 --> 40:50.600]  высказываний лучше исчисления резолюции. Что это означает? Это означает две вещи. Что если у вас
[40:50.600 --> 40:58.600]  есть короткое доказательство резолюциями, то есть и короткий вывод в исчисление высказываний.
[40:58.600 --> 41:04.800]  В эту сторону довольно легко, и я даже сформулирую это в виде очередной бонусной задачи.
[41:10.280 --> 41:18.600]  Это, я думаю, все-таки посильно, хотя и не очень просто. Значит, и так пусть у нас есть КНФ.
[41:18.600 --> 41:44.760]  В ней К дизюнктов, N переменных. И существует дизюнктивное, дизюнктивное
[41:44.760 --> 41:53.960]  опровержение этой КНФ, в котором L дизюнктив. Ну, это основные параметры, от которых зависит
[41:53.960 --> 41:58.880]  доказательство в системе доказательства, основанной на резолюциях. Нам нужно записать
[41:58.880 --> 42:10.920]  КНФ, нам нужно записать резолютивный вывод. Тогда утверждаю я, уже в исчислении высказываний мы
[42:10.920 --> 42:17.840]  можем доказать отрицание этой КНФ. Ну, раз существует вывод теждеасположенного дизюнка,
[42:17.840 --> 42:25.000]  КНФ невыполнимо. Значит, отрицание КНФ – это автология. Так вот, мы можем доказать отрицание
[42:25.000 --> 42:37.480]  этой КНФ в исчислении высказываний. И длина вывода не очень большая. Она оценивается,
[42:37.480 --> 42:46.520]  как О, плюс число дизюнков, плюс число переменных, умноженное на длину резолютивного вывода. Длина
[42:46.520 --> 42:52.440]  вывода – это количество формул, я напоминаю. Это важно. Потому что, если считать количество
[42:52.440 --> 42:57.880]  символов, то есть длину текста, который у нас там доказательствует, получится немножко другие
[42:57.880 --> 43:04.280]  оценки. Я считаю именно число формул вывода. Ну, О, я думаю, вы знаете, что значит с точностью до
[43:04.280 --> 43:17.400]  константа. Так что, видите, если у нас есть короткое опровержение резолюциями, мы в исчислении
[43:17.400 --> 43:32.980]  высказываний его можем смоделировать. В обратную сторону неверно существует КНФ. Такая, что есть
[43:32.980 --> 43:44.140]  вывод отрицания этой КНФ, размера там, полиномат, размера записи КНФ, в общем, я не буду уточнять.
[43:44.140 --> 43:55.580]  И она, конечно, поскольку она невыполнима, то у нас существует возможность вывести пустой дизюн. Но любой вывод
[43:55.580 --> 44:09.460]  содержит что-то там экспоненциально большое от длины записи КНФ. Ну, экспоненциально большое,
[44:09.460 --> 44:21.100]  это имеется ввиду тоже, на самом деле, тут квадратный корень можно поставить, в общем,
[44:21.100 --> 44:27.780]  какая-то степень от размера КНФ. Но раздувание получается экспоненциальным, то есть доказательство
[44:27.780 --> 44:36.380]  вычисления высказываний достаточно короткое, а любое опровержение отрицания в резолюциях
[44:36.380 --> 44:44.940]  достаточно длинное. То есть, в теоретической точке зрения все понятно. Исчисление высказываний лучше.
[44:44.940 --> 44:49.780]  Вообще, исчисление высказываний это очень сильная система, она лучше почти всех систем, которые
[44:49.780 --> 44:56.140]  изучаются в сложности доказательств. Ну, на самом деле, можно скомбинировать эти системы, как всегда,
[44:56.140 --> 45:00.180]  если у нас есть несколько систем, мы их можем как-то скомбинировать и получить еще что-то более
[45:00.180 --> 45:14.020]  мощное. И такие вещи проделываются и с исчислением высказываний, но, в общем, это достаточно сложно.
[45:14.020 --> 45:19.620]  Тем не менее, и, в общем, оно настолько сложное, что мы вот не знаем результатов такого типа. Есть ли
[45:19.620 --> 45:25.260]  вообще тавтологии, у которых любое доказательство вычисления высказываний имеет сверхпальномиальную
[45:25.260 --> 45:35.380]  длину? До сих пор мы не можем исключить такого варианта, что для каждой тавтологии есть какое-то
[45:35.380 --> 45:42.020]  короткое доказательство. Может быть, его очень трудно придумать, но оно есть. Люди, правда, в это не верят,
[45:42.020 --> 45:49.220]  но это вот в следующем семестре вам будут объяснять про НП, про кое НП, почему не верится такое. Это сейчас
[45:49.220 --> 45:58.860]  меня бы слишком далеко в сторону. Но вопрос открыт. Но это, я говорю, в теории. Теперь практика.
[45:58.860 --> 46:16.060]  Исчисление резолюции гораздо лучше. Исчисление высказываний. Первое преимущество я уже в прошлый раз
[46:16.060 --> 46:21.380]  называл. Если вы пытаетесь написать программу, которая доказывает тавтологичность формулы с
[46:21.380 --> 46:27.180]  помощью исчисления высказываний, совершенно непонятно, с чего эта программа должна начинать. Какую
[46:27.180 --> 46:34.460]  аксиому она должна первой написать, абсолютно не ясно. То есть можно, конечно, если вы готовы
[46:34.460 --> 46:39.540]  согласиться на доказательства экспоненциальной длины, то есть стандартный способ для любой
[46:39.540 --> 46:43.380]  тавтологии написать с помощью леммы кальмара, написать доказательства. Но не интересно,
[46:43.380 --> 46:51.260]  он всегда будет очень длинным. А чего-то более разумного придумать не удаётся. А для исчисления
[46:51.260 --> 46:57.620]  резолюции понятно, что нужно делать. Я, собственно, показал, вы берёте KNF, но даже если вам нужно
[46:57.620 --> 47:02.780]  проделать все эти шаги, вы потом берёте KNF и начинаете применять резолюции. У вас есть конечное
[47:02.780 --> 47:07.500]  множество дезюнктов. Каждый раз вы знаете, что всё, что вы можете сделать следующее, что добавить к
[47:07.500 --> 47:12.660]  этому множеству. Если добавили, отлично, пытайтесь ещё добавить. В какой-то момент вы уже не можете
[47:12.660 --> 47:17.180]  ничего добавить. Если пустого дезюнкта не появилось, теорема о полноте гарантирует,
[47:17.180 --> 47:24.140]  что KNF выполним. То есть, в общем-то, понятно, как писать такую программу. Но, на самом деле,
[47:24.140 --> 47:30.580]  исчисление резолюции даёт даже больше. Я всё-таки потрачу пять минут, это интересный сюжет,
[47:30.580 --> 47:39.180]  про него хочется сказать. Оказывается, сейчас существуют программы, они называются SAT-солверы.
[47:39.180 --> 47:48.620]  Ну, вот эта вот задача проверки выполнимости, она SAT называется. Так вот, существует очень
[47:48.620 --> 47:53.980]  эффективная SAT-солвера. Настолько эффективная, что в последние годы, даже в научных статьях,
[47:53.980 --> 48:00.060]  можно увидеть такое рассуждение. Ну вот, нам надо какую-то трудную комбинаторную задачу решить,
[48:00.060 --> 48:08.180]  не понятно, как это делать, а давайте мы её сведём к SAT и запустим какой-нибудь SAT-солвер хороший.
[48:08.180 --> 48:17.140]  Хотя, теоретически, все эти солверы должны работать плохо, теоретически, на каких-то входах. А если
[48:17.140 --> 48:23.900]  вы берёте реальные входы, они все работают хорошо. И это вот действительно удивительная ситуация. То
[48:23.900 --> 48:29.620]  есть, вот тут возникает разрыв. Там, где вот эта вот экспонента, тут стоит всё-таки корень квадратный
[48:29.620 --> 48:35.220]  из размера. То есть, если посмотреть, чтобы достигнуть этой границы, ну вот ещё пока не хватает мощности
[48:35.220 --> 48:44.540]  компьютеров. То есть, плохие примеры, они пока за тем горизонтом, который мы видим на практике. Ну,
[48:44.540 --> 48:50.820]  SAT-солверы, конечно, применяются их очень большим формулом, там, длиной в миллионы символов, но это
[48:50.820 --> 48:55.700]  формулы, возникающие из индустрии, и там эти формулы, они не произволены, они имеют достаточно
[48:55.700 --> 49:02.980]  специальный вид, ну там, скажем, описание какой-нибудь микросхемы. Понятно, что там очень много структуры есть
[49:02.980 --> 49:07.900]  в этой формуле. Поэтому то, что для неё работает какой-то SAT-солвер, это может быть даже не так удивительно.
[49:07.900 --> 49:14.140]  Откуда взялись такие хорошие SAT-солверы? Это тоже очень интересная история. В теории же их быть не
[49:14.140 --> 49:23.180]  должно. А на практике они есть. А взялись они вот откуда. Уже больше 20 лет проводятся чемпионаты.
[49:23.180 --> 49:30.620]  По-моему, они называются SAT-competition. Я боюсь ошибиться, но думаю, что если вы поищете вот по такой ссылке
[49:30.620 --> 49:37.420]  в Google, вы найдете сайт, на котором собираются результаты. То есть люди стали соревноваться, стали писать
[49:37.420 --> 49:43.220]  программы, которые проверяют выполнение. Все знали, что задача трудная, поэтому это интересно. У кого-то
[49:43.220 --> 49:48.380]  получается лучше, у кого-то хуже. Понятно, что программы пишутся на каком-то стандартном коде, там, не знаю,
[49:48.380 --> 49:54.380]  как сейчас. Поначалу это был чистый C, и этот чистый C запускался, ну, на некотором тестовом компьютере, то
[49:54.380 --> 49:59.820]  есть все программы запускались на одном и том же железе, чтобы можно было сравнивать время. Ну и устраивались
[49:59.820 --> 50:04.620]  соревнования, как обычно, как в легкой атлетике. Есть много видов бега. Тут тоже очень много видов.
[50:04.620 --> 50:12.100]  На случайный КНФ, на три КНФ, где не больше трех литералов, на КНФ, которая там дерется из каких-то вот из этих
[50:12.100 --> 50:21.180]  теоретических вот оценок. Ну и понятно, что дальше. Дальше люди пытаются победить. Соревнуются не программы,
[50:21.180 --> 50:28.020]  соревнуются люди, которые пишут программы. И это очень мощный стимул. За 20 лет люди насобачились писать эти
[50:28.020 --> 50:34.500]  программы очень эффективно, потому что каждый хотел победить, и каждый вот что-то такое придумал,
[50:34.500 --> 50:41.340]  вкладывал. Это оказалось намного эффективнее любых заказов от индустрии, от военно-промышленного комплекса,
[50:41.340 --> 50:48.420]  от чего угодно. То есть вот игра это очень мощный двигатель прогресса. Так вот, что я хотел сказать,
[50:48.660 --> 50:55.100]  почему этот разговор сейчас затеял? Дело в том, что в основе практически всех соц.олверов, конечно,
[50:55.100 --> 51:02.100]  чемпионские соц.олверы сейчас устроены очень сложно. Они обрабатывают там какие-то специальные
[51:02.100 --> 51:06.300]  случаи. То есть они проверяют, что, допустим, КНФ имеет какую-то специальную структуру. Тогда запускают
[51:06.300 --> 51:11.220]  какую-то отдельную листику. То есть это гигантские программы. Они уже имеют коммерческую ценность,
[51:11.220 --> 51:18.220]  поэтому они не открыты. Сейчас, по-моему, чемпионские программы типа 14-15 года открыты. Они считаются
[51:18.220 --> 51:27.780]  уже старьём и их открывают. Ну, и они очень хороши. У меня был студент, который использовал
[51:27.780 --> 51:33.780]  такие программы как раз для решения совсем другой задачи. Ну, вот он взял эту программу
[51:33.780 --> 51:41.180]  чемпионскую 14-го года и ускорил свою программу в 600 раз, когда её применил. При том, что ему там
[51:41.180 --> 51:46.100]  ну, там не очень сложная сводимость, но всё равно нужно было ещё программа должна была его задачу
[51:46.100 --> 51:58.620]  превратить в SAT. Так вот, внутри всех этих программ, там, помимо всех наворотов, есть базовый такой
[51:58.620 --> 52:06.340]  комплекс. Вот как в автомобиле может быть много всяких разных плюшек и фентифлёшек, но бензин
[52:06.340 --> 52:13.100]  нужен. Вот бензином для всех SAT-солверов являются резолюции. Точнее, резолюции в комбинации с ещё
[52:13.100 --> 52:18.780]  одной очень простой идеей. Вот какая идея. Идея такого частичного разбора переменных. Вот,
[52:18.780 --> 52:24.660]  представьте, мы берём переменную X1. Она может равняться 0 или единице. Если я присвою значение 0,
[52:24.660 --> 52:33.820]  у меня может упроститься моя КНФ. Ну, если в какой-то дизьюнт ходит отрицание переменной X1,
[52:33.820 --> 52:39.020]  то он уже обращается в единицу. Дальше можно его не рассматривать. Если входит позитивно,
[52:39.020 --> 52:42.740]  мы просто сокращаем этот дизьюнт. Мы можем выбросить переменную. В любом случае происходит
[52:42.740 --> 52:49.460]  упрощение. И дальше мы можем вот так вот разбирать, разбирать, разбирать. Но не обязательно строить
[52:49.460 --> 52:53.860]  полное дерево перебора. В какой-то момент мы окажемся в ситуации, когда вот по этим частичным
[52:53.860 --> 53:00.020]  значениям мы можем определить дизьюнт, который обращается в ноль. Тогда дальше разбирать не нужно.
[53:00.020 --> 53:04.780]  Если какой-то дизьюнт обратился в ноль от того, что вы ещё каким-то переменным присвоите значение,
[53:04.780 --> 53:10.620]  он нулём быть не перестанет. То есть эта ветка уже, ну её нужно обрывать. Вот здесь есть какой-то
[53:10.620 --> 53:20.260]  дизьюнт. Там X и вот тут вот X ветвимся. И D1. Поэтому мы можем сделать здесь рекурсивный
[53:20.260 --> 53:31.180]  возврат и начать ветвиться по другому значению. И здесь тоже может так случиться, что произойдет
[53:31.180 --> 53:36.820]  рекурсивный возврат. Где-то может быть глубже. Потом мы вот так вот рекурсивно продолжим до этого
[53:36.820 --> 53:42.700]  уровня. У нас каждый раз, когда мы делаем рекурсивный возврат, мы знаем дизьюнт, который обращается в ноль.
[53:42.700 --> 53:54.100]  А теперь смотрите. Это же ровно те дизьюнты, которым можно применить резолюцию. Мы можем вывести
[53:54.100 --> 53:59.900]  новый дизьюнт. То есть мы дизьюнт, резолюцию применяем не просто так вот как-нибудь, а мы
[53:59.900 --> 54:05.180]  смотрим, какие мы будем применять правила, глядя на этот частичный разбор. Чем это хорошо? У нас
[54:05.180 --> 54:09.140]  получается такой взаимоподдерживающийся процесс. Чем больше дизьюнтов, тем больше условий, тем
[54:09.140 --> 54:14.620]  быстрее будет обрываться вот этот частичный перебор. А когда он обрывается, мы увеличиваем
[54:14.620 --> 54:19.380]  количество дизьюнтов. То есть получается такой самоподдерживающийся процесс. И он действительно
[54:19.380 --> 54:25.500]  получается очень эффективный. Даже без дополнительных наворотов при разумных и вристиках, как строить,
[54:25.500 --> 54:30.300]  как выбирать эти переменные. Мы же можем каждый раз выбирать, по какой переменной мы витвимся.
[54:30.300 --> 54:34.740]  Но лучше, например, витвиться по той переменной, которая сильнее всего упрощает формулу, по тому
[54:34.740 --> 54:39.700]  или иному функционалу. Если написать даже очень простые такие вристики, у вас получится программа,
[54:39.700 --> 54:44.260]  которая не чемпионская, она будет очень хорошо работать. Гораздо лучше, чем можно было бы себе
[54:44.260 --> 54:53.020]  представить на первый взгляд. Ну а дальше уже начинаются хитрости. Сейчас, конечно, люди используют
[54:53.020 --> 54:59.620]  разные другие идеи. Линейная алгебра очень не тривиально используется. Но вот это используется
[54:59.620 --> 55:07.580]  всегда. Потому что, да, а и вристики, которые строятся сейчас, вы знаете, эпоха нейронных сетей. А тут
[55:07.580 --> 55:12.540]  безумное количество, это же вот все очень большое. То есть там еще проблема, что если это дерево
[55:12.540 --> 55:17.300]  начинается, если достаточно большим, нужна и вристика, какую его часть держать в памяти, какую обрезать.
[55:17.300 --> 55:24.700]  И на такие гигантские данные просятся напустить нейронные сети. Современные программы, они устроены
[55:24.700 --> 55:31.580]  так. Вот они эти вристики по ветвлению определяют, ну вот как бы анализируя предыдущие ветвления. То есть
[55:31.580 --> 55:36.020]  там запускают нейронную сеть, которая говорит, вот теперь надо бы ветвиться по такой переменной. Тут
[55:36.020 --> 55:42.180]  уже вообще непонятно, как оценить, насколько эта вристика хороша. Но она работает, то есть они все
[55:42.180 --> 55:48.340]  больше и больше решают задачи. То есть это вот такая интересная деятельность практического
[55:48.340 --> 55:54.500]  плана. В общем, здесь есть некоторый разрыв, который до конца не закрыт. И это некоторая очень интересная
[55:54.500 --> 56:02.820]  тема в теоретической информатике. То есть теорему никто не опровергнет. На самом деле, за лекцию я
[56:02.820 --> 56:08.700]  бы вам ее доказал, просто у меня нет этой лишней лекции. То есть построить такую КМФ и доказать,
[56:08.700 --> 56:14.860]  что все резолюции длинные, это не очень сложно. Там есть даже несколько идей. Сейчас эта техника
[56:14.860 --> 56:19.940]  вообще очень развита. И для более сложных систем доказательств есть доказательства. Но проблема
[56:19.940 --> 56:24.380]  в том, что это доказательства асимпатические. Они там на каких-то очень больших значениях что-то
[56:24.380 --> 56:34.780]  дают. А вот на практике получается другое. Хорошо. На этом я, в интересном сюжете, но выходящем за
[56:34.780 --> 56:41.620]  рамки этого курса, я закончу рассказ про булевые формулы, про тавтологичность. У меня еще сегодня
[56:41.620 --> 56:48.860]  есть время и я начну рассказ про вторую часть курса. Сегодня будут разные предварительные
[56:48.860 --> 56:55.820]  замечания. Что будет во второй части курса? Я напомню, я в самом начале про это говорил,
[56:55.820 --> 57:05.020]  что логика вообще возникла как попытка обосновать математические доказательства. Вот тавтологи и
[57:05.020 --> 57:10.580]  всего вот этого вот, там исчисление высказываний, исчисление резолюций, нам недостаточно, чтобы
[57:10.580 --> 57:19.340]  формализовать даже математические утверждения. Это все-таки только частный случай математических
[57:19.340 --> 57:26.660]  утверждений, относящихся к конечным множествам. Поэтому нам нужен какой-то более широкий
[57:26.660 --> 57:32.940]  формализм. И оказалось, что такой формализм есть. Я про это говорил и, в общем-то, я буду
[57:32.940 --> 57:49.900]  ему рассказывать, что называется логика первого порядка. И вот этого формализма уже достаточно,
[57:49.900 --> 57:55.140]  чтобы по крайней мере сформулировать любое математическое утверждение и по крайней мере хоть
[57:55.140 --> 58:00.980]  как-то описать, как устроены математические доказательства. Разумеется, те формальные
[58:00.980 --> 58:06.180]  выводы, которые получаются в процессе, они не напоминают рассуждения настоящих математиков.
[58:06.180 --> 58:12.340]  Они гораздо более дробные. Вот вы видели вычисления, высказывания. У нас очень мелкие шаги. То есть,
[58:12.340 --> 58:15.900]  если вы проверяете тавтологичность какой-то формулы, вы можете себе позволить какие-то
[58:15.900 --> 58:20.860]  более сложные рассуждения. А в формализме они разбиваются на очень мелкие шаги. Здесь то же
[58:20.860 --> 58:29.060]  самое. И поэтому прям так записывать всю математику в формализме первого порядка это может быть не
[58:29.060 --> 58:38.540]  самая разумная идея. Но если, скажем, вы хотите что-то доказывать с помощью программ, то есть
[58:38.540 --> 58:44.300]  конкуренты, но они не доработаны. То есть, в сущности, это почти что единственный способ. Там другое дело,
[58:44.300 --> 58:50.900]  что у этого формализма есть, как всегда, много вариантов. Но более-менее, так сказать, это базовый
[58:50.900 --> 58:55.380]  способ как-то представлять математические знания так, чтобы можно было писать программы, которые
[58:55.380 --> 59:02.580]  чего-то там доказывают, проверяют корректность каких-то доказательств. Поэтому это важная, в общем-то,
[59:02.580 --> 59:12.580]  вещь. У нас же не все сводится только к проверке тавтологии формул. Бывают более сложные структуры.
[59:12.580 --> 59:19.740]  И сегодня, вот за оставшееся время, у меня где-то 20 минут есть, а я начну вот с чего. Я начну с
[59:19.740 --> 59:27.580]  некоторых предварительных замечаний. Значит, смотрите, у нас так же, как было с буливыми
[59:27.580 --> 59:33.660]  формулами, как вообще всегда в логике, у нас есть две стороны. Синтакс и сомантика. То есть, вот
[59:33.660 --> 59:38.780]  формализм какой-то, как мы пишем какие-то там слова, которым мы придаем смысл каких-то утверждений. И
[59:38.780 --> 59:45.780]  семантика, о чем мы, собственно, говорим. Так вот, чтобы замахнуться на такую гигантскую цель, как
[59:45.780 --> 59:52.660]  получить формализм, на котором всю математику можно выразить, он получается неминуумо сложный.
[59:52.660 --> 59:59.180]  Ну, достаточно сложный. И я сегодня начну с того, чтобы скорее объяснять семантику, которая за этим
[59:59.180 --> 01:00:05.260]  стоит. А вообще, почему всю математику можно так изложить, я оставлю на потом. Наконец, этой
[01:00:05.260 --> 01:00:14.100]  второй части. Сейчас пока у нас будет конструкции, которые, на первый взгляд, может их и не хватить.
[01:00:14.100 --> 01:00:18.980]  Как я буду брать эти конструкции? Давайте просто вспомним, как мы рассуждаем в математике, что нам
[01:00:18.980 --> 01:00:32.260]  нужно, что нам не хватает вычислений и высказываний. Ну вот, вот два типичных математических утверждения.
[01:00:32.260 --> 01:00:39.700]  Четыре меньше семи, четыре делитер семи. Вот то, что одно истинно, а другое ложно, это даже мне не
[01:00:39.700 --> 01:00:49.860]  очень важно. Важно, что я не могу вот эти утверждения представить в виде высказываний. Это уже
[01:00:49.860 --> 01:00:55.100]  элементарное высказывание. Ну, либо истинно, либо ложно. Но внутри, видите, есть структура. Это не
[01:00:55.100 --> 01:00:59.580]  просто какое-то абстрактное высказывание, которое истинно или ложно, а это высказывание о каких-то
[01:00:59.580 --> 01:01:08.020]  объектах. То есть, все математические утверждения, они о чем-то. И вот этого у нас в вычислении
[01:01:08.020 --> 01:01:15.700]  высказываний совсем не было. А здесь это должно появиться. И проявляется это так. Это называется
[01:01:15.700 --> 01:01:28.820]  отношение или предикаты. Логики любят слово предикаты. Математики любят слово отношения. Что
[01:01:28.820 --> 01:01:38.940]  это такое? Вот как всю совокупность вот таких вот высказываний можно объединить? Можно рассмотреть
[01:01:38.940 --> 01:01:51.580]  множество пар чисел таких, что их строго меньше. Тогда вот это вот утверждение с 4 меньше 7 просто
[01:01:51.580 --> 01:02:01.260]  означает, что пара 4 и 7 принадлежит этому множеству. Мы делаем такой хитрый финт. Мы массу однотипных
[01:02:01.260 --> 01:02:06.220]  утверждений объединяем в одно множество. Вот это множество называется отношение. Другим словом,
[01:02:06.220 --> 01:02:21.220]  если у нас есть какое-то множество m, то k-r отношение. Это под множество декартового
[01:02:21.220 --> 01:02:31.020]  произведения, декартовой степени k этого множества. То есть, это наборы из k элементов нашего множества.
[01:02:31.020 --> 01:02:40.980]  Какое-то множество таких наборов. То есть, вот получается, что у нас есть вот такие базовые высказывания.
[01:02:40.980 --> 01:02:51.980]  То есть, с каждым отношением или предикатом. Я дальше часто это буду называть предикатом,
[01:02:51.980 --> 01:02:58.940]  поскольку мы про логику говорим. Как связаны вот такие вот утверждения конкретного типа. Возьмите
[01:02:58.940 --> 01:03:07.260]  какие-то элементы из вашего множества и скажите утверждение, что эти элементы, этот набор,
[01:03:07.260 --> 01:03:15.060]  порядочный набор k-элементов принадлежит данному множеству. То есть, еще логики говорят, выполняется
[01:03:15.060 --> 01:03:20.540]  на этом наборе, выполняется предикат. Вот я определил предикат для отношения меньше. Ясно,
[01:03:20.540 --> 01:03:27.140]  что аналогично можно определить предикат вот здесь. Сразу могу сказать, как это будет у нас
[01:03:27.140 --> 01:03:35.620]  устроено синтоксически. Видите, здесь мы используем в математике всякие хитрые записи. Вот, в частности,
[01:03:35.620 --> 01:03:41.460]  очень часто для бинарных отношений принята инфиксная запись, когда знак отношения стоит
[01:03:41.460 --> 01:03:48.300]  между аргументами. Вот так получаются более читаемые формулы, но нам хочется иметь общий
[01:03:48.300 --> 01:03:55.340]  формализм. И в общем формализме мы будем это записывать вот так. То есть, у нас будет имя отношения,
[01:03:55.940 --> 01:04:01.540]  какой-то символ. И дальше в квадратных скобках мы перечисляем переменные. Вот это вот будут
[01:04:01.540 --> 01:04:17.700]  переменные. Это будут предикатные символы, а это будет переменная. И вот такого рода запись будет
[01:04:17.700 --> 01:04:25.380]  означать вот это вот утверждение. Она уже будет истиной или ложной. И дальше с этими утверждениями
[01:04:25.380 --> 01:04:31.460]  можем применять булевую логику. А булева логика, заметьте, хорошо согласуется с теоретико-множественными
[01:04:31.460 --> 01:04:36.420]  операциями. Вот я определил отношения как под множество, но тогда если я применю, скажем,
[01:04:36.420 --> 01:04:42.660]  к двум отношениям объединения, это то же самое, что взять дизьюнцию этих отношений. Единственное,
[01:04:42.660 --> 01:04:49.780]  что смотрите, вот эти отношения могут определяться быть разной арности. Например, я могу взять
[01:04:49.780 --> 01:05:00.060]  дизьюнцию отношений а меньше b и а простое. Или а простое. Тогда у меня получится какое-то
[01:05:00.060 --> 01:05:03.780]  странное отношение, но какая у него будет арность? Арность будет 2. То есть, смотрите,
[01:05:03.780 --> 01:05:15.980]  если я беру а меньше b или а простое. Вот это бинарное отношение, это унарное отношение. Тут
[01:05:15.980 --> 01:05:23.160]  для одного числа оно определено. Если я возьму такую дизьюнцию, как это в виде теоретико-множественной
[01:05:23.160 --> 01:05:28.940]  операции представить? Ну надо представить, что здесь у нас есть несущественная переменная b,
[01:05:28.940 --> 01:05:37.420]  от которой не зависит вообще значение этого высказывания. Ну и взять тогда уже просто объединение.
[01:05:37.420 --> 01:05:43.540]  И понятно, что не только дизьюнцию, можно и конъюнцию применить, и отрицание, это получится
[01:05:43.540 --> 01:05:50.540]  дополнение к этому множеству. И импликацию. В общем, мы можем применять булевые связки из
[01:05:50.540 --> 01:05:57.740]  каких-то заданных отношений, ну скажем, там меньше, делимость, еще что-то. Можем строить
[01:05:57.740 --> 01:06:05.820]  новые отношения, записывая их в виде булевых форм. Это напоминает то, что мы делали раньше,
[01:06:05.820 --> 01:06:16.140]  потому что у нас теперь вместо булевых переменных, которые были раньше, будут вот такого рода объекты.
[01:06:16.140 --> 01:06:22.580]  То есть в каком-то смысле мы так расщепляем булевые переменные, как расщепляют атомы. У нас
[01:06:22.580 --> 01:06:28.340]  возникает там структура. Вот ядро, предикатные символы, вот эти вот переменные. В общем, у нас
[01:06:28.340 --> 01:06:33.740]  возникает внутренняя структура. То есть помимо высказывания, которые имеют значение истина и
[01:06:33.740 --> 01:06:40.380]  ложь, у нас появляются части в нашем формализме, которые отвечают уже не за истину или ложь, а за
[01:06:40.380 --> 01:06:46.340]  какую-то содержательную часть. Это элемент какого-то множества. Какого? А это вот мы должны указать,
[01:06:46.340 --> 01:06:51.660]  чтобы придать смысл такому выражению, мы должны объяснить на каком множестве это отношение задан.
[01:06:51.660 --> 01:06:56.700]  Если мы изменим это множество, та же самая формула будет нам задавать что-то совершенно другое.
[01:06:56.700 --> 01:07:06.420]  Это самый важный этап при построении формализма, но его недостаточно. Точнее,
[01:07:06.420 --> 01:07:11.220]  как? Им можно обойтись, но очень неудобно. Давайте вспомним, что нам хотелось, а нет,
[01:07:11.220 --> 01:07:18.580]  только им точно нельзя обойтись, но чего нам не хватает с точки зрения вот обычной математики.
[01:07:18.660 --> 01:07:25.820]  Но уже даже в этих примерах видно, я же использовал тут не переменные, а именно конкретность 4, 7,
[01:07:25.820 --> 01:07:34.980]  это константы. А есть еще функции. Вот допустим, я хочу сформулировать такое утверждение,
[01:07:34.980 --> 01:07:45.220]  x квадрат плюс один равно нулю. Ну как это сделать? x это какая-то переменная, то есть вообще это вот
[01:07:45.220 --> 01:07:49.000]  то, что здесь написано, это какое-то утверждение в зависимости от значения x оно истинно или
[01:07:49.000 --> 01:07:58.620]  ложно. То есть так хочется верить, что это получается унарный предикат, зависящий от одной переменной,
[01:07:58.620 --> 01:08:05.980]  но как его задать? Тут у меня есть единица, ноль, квадрат. Вот в том, что я до сих пор делал,
[01:08:05.980 --> 01:08:20.700]  ничего этого нет, а хочется это иметь. Поэтому у нас еще будут функции. Функции это очень похоже на
[01:08:20.700 --> 01:08:29.740]  отношения, но только у нас значение функции лежит в том же самомножии. То есть это фибрическая
[01:08:29.740 --> 01:08:41.820]  операция, как еще любят говорить в математике. То есть у нас есть для каждого набора упорядоченного
[01:08:41.820 --> 01:08:48.140]  k элемента множь, то мы задаем значение функции. В случае предиката мы задаем булево значение,
[01:08:48.140 --> 01:08:56.380]  то есть на предикат можно еще смотреть как на функцию со значениями в 0,1. То есть мы берем опять
[01:08:56.380 --> 01:09:07.980]  такие наборы элементов нашего множества и сопоставляем каждому 0 или 1, находятся они в
[01:09:07.980 --> 01:09:14.860]  этом отношении или нет. Ну а в общем случае мы строим функции в то же самое множество. Вы конечно
[01:09:14.860 --> 01:09:20.020]  скажете, что не обязательно в то же самое, что вы уже заведомо видели ситуации, когда функция бьет из
[01:09:20.020 --> 01:09:28.780]  одного множества в другого. Мы хотим, чтобы было попроще, поэтому давайте ограничим все этим случаем.
[01:09:28.780 --> 01:09:40.380]  А кажется, что его достаточно. Это пока не столь очевидно, но я не хочу все мыслимые вещи из
[01:09:40.380 --> 01:09:45.640]  математической практики засунуть в свой формализм. Я хочу что-то самое необходимое. Но функции нам
[01:09:45.640 --> 01:09:51.480]  нужны. Константы нам нужны. Константы это очень просто. Константы это просто-напросто элемент
[01:09:51.480 --> 01:09:58.680]  какого-то множества. Скажем множество действительных чисел. А функция, ну вот, то есть это просто имя
[01:09:58.680 --> 01:10:03.000]  какого-то конкретного числа. Вот так у нас и будет ходить формализм. У нас для константа будут
[01:10:03.000 --> 01:10:09.120]  запасивные специальные символы, которые обозначают константы. А функции будут записываться, похоже на
[01:10:09.120 --> 01:10:20.560]  предикаты, тоже имя функции, потом в скобках перечисления ее аргументов. И вот обратите
[01:10:20.560 --> 01:10:30.360]  внимание, вот это уже не высказывание. Смысл вот такой записи уже другой. Это элемент множества
[01:10:30.360 --> 01:10:36.920]  m. Чтобы появилось логическое значение, мы этот элемент должны в какой-то предикат вставить.
[01:10:36.920 --> 01:10:42.200]  То есть логические значения у нас появляются только из предикатов. Функции нам дают элементы множества.
[01:10:42.200 --> 01:10:48.600]  Но что они нам позволяют? Вот если у нас там был только вот такой совсем простой предикат,
[01:10:48.600 --> 01:10:55.280]  то здесь смотрите, что получается. Получается так, у меня есть предикат, ну давайте я его назову
[01:10:55.280 --> 01:11:07.600]  равенством. И здесь я применяю функции. Какие? Я применяю функцию сложения к функции квадрат и
[01:11:07.600 --> 01:11:15.400]  константе единица. А второй элемент предиката равенства 0. То есть вот такая вот запись в формализме,
[01:11:15.400 --> 01:11:19.680]  мы так, конечно, писать обычно не будем, но нужно понимать, что в формализме это превращается вот
[01:11:19.680 --> 01:11:26.320]  что-то такое. Предикат, а аргументы могут быть не обязательно переменными, а могут быть константами,
[01:11:26.320 --> 01:11:35.440]  или какими-то более сложными выражениями, состоящими из функции, и констант, и перемен.
[01:11:35.440 --> 01:11:44.840]  Вот эти вот выражения, я прошу прощения за это слово, в синтаксе все будут называться термы.
[01:11:44.960 --> 01:11:52.160]  Почему прошу прощения? Потому что опыт показывает, что почему-то формализм не то чтобы очень простой,
[01:11:52.160 --> 01:11:59.800]  но безумно трудный. Но вот когда появляются термы, почему-то люди перестают воспринимать. То есть вот
[01:11:59.800 --> 01:12:05.920]  рассуждения, в которых возникают термы, кажутся уже какими-то совершенно ясными. Хотя вроде бы
[01:12:05.920 --> 01:12:11.680]  вот так все понятно. Пока я не начал давать строгие определения, вроде бы все хорошо. Термами я
[01:12:11.680 --> 01:12:18.280]  просто называю имена каких-то элементов нашего вот этого основного множества, на котором мы рассуждаем.
[01:12:18.280 --> 01:12:30.240]  Предикаты это отношение. Вроде бы понятно, но тем не менее возникают сложности в этом месте.
[01:12:30.240 --> 01:12:43.400]  Давайте подумаем, все ли у нас есть, чтобы начать высказываться о разных интересных
[01:12:43.400 --> 01:12:53.720]  математических вещах. Одного у нас точно нет, а именно кванторов. Вы знаете о кванторах,
[01:12:53.720 --> 01:12:59.360]  вы их используете, там на анализе без этого не обходится. И это не удивительно, потому что
[01:12:59.360 --> 01:13:03.920]  если использовать только вот эти выразительные средства, мы конечно много предикатов можем
[01:13:03.920 --> 01:13:09.240]  выразить. На самом деле разных интересных утверждений мы сделать не сможем. Например,
[01:13:09.240 --> 01:13:15.200]  вы знаете, что в действительных числах это уравнение не имеет решения. Как это записать?
[01:13:15.200 --> 01:13:22.280]  Вот для этого нужен квантор.
[01:13:22.280 --> 01:13:48.080]  Что эта запись означает? Ну отрицание это понятно. Это я применил логическую операцию. То есть
[01:13:48.760 --> 01:13:55.040]  предикат неровно. Что у нас есть предикат равенства, то отрицание будет предикат неровенства. А что такое
[01:13:55.040 --> 01:14:05.600]  квантор? Вот заметьте, вот здесь стоит предикат от одной унарной предикаты. Навешивание квантора
[01:14:05.600 --> 01:14:12.440]  на переменную, которая входит в предикат, уменьшает арность предиката. Вот все вот это становится
[01:14:13.020 --> 01:14:22.460]  нулярный предикат. Вы скажете, а что такое нулярный предикат? Предикат, у которого нет переменных.
[01:14:22.460 --> 01:14:29.480]  Что это такое? Ну предикат всегда принимает логические значения, а переменных нет. Значит это
[01:14:29.480 --> 01:14:35.480]  просто одно из двух логических значений. То есть нулярный предикат это всегда истинная или
[01:14:35.480 --> 01:14:39.200]  ложная. То есть когда я навесил квантор на ту переменную, которая входит в этот предикат,
[01:14:39.200 --> 01:14:44.760]  у меня уже получится истина или ложь. Но в данном случае, если x мы считаем, берем из
[01:14:44.760 --> 01:14:48.760]  действительных чисел, это будет истина. Если мы их будем брать из комплексных чисел, это будет
[01:14:48.760 --> 01:14:54.680]  ложь. Тут нужно помнить, что значение нашего высказания зависит от того, как мы понимаем
[01:14:54.680 --> 01:14:59.240]  переменные. Переменные принадлежат некоторому базовому множеству, которое будет называться
[01:14:59.240 --> 01:15:05.680]  областью интерпретации, но давайте про это в следующий раз более аккуратные слова скажу. Как
[01:15:05.680 --> 01:15:26.960]  в общем случае определить предикат? Вот у нас есть НР предикат, я навешиваю квантор, ну давайте
[01:15:26.960 --> 01:15:32.400]  по первой переменной все будет совершенно симметрично. Это какой-то предикат, как я уже
[01:15:32.400 --> 01:15:37.320]  сказал, который зависит от всех остальных переменных, кроме вот той, на которую навешан квантор.
[01:15:37.320 --> 01:15:44.760]  Навешивание квантора делает эту переменную мнимой, от нее уже значение высказывания не зависит. И
[01:15:44.760 --> 01:16:00.840]  определяется это очень просто. R с тильдой от каких-то значений x1, x2, xn равно единице, если для
[01:16:00.840 --> 01:16:13.360]  любого x1, вот наш исходный предикат, я подставляю теперь аргументы со второго по Энтой. Те, что у
[01:16:13.360 --> 01:16:19.240]  меня здесь есть, а вот вместо недостающего аргумента подставляю какое-то. Вот если для любого это истина,
[01:16:19.240 --> 01:16:24.960]  то тогда единица, иначе ноль. Ну это обычное понимание кванторов все в общемстве. То есть
[01:16:24.960 --> 01:16:30.600]  содержательно мы говорим, что для любого x должно что-то выполняться. Но формально это означает,
[01:16:30.600 --> 01:16:35.040]  что мы должны зафиксировать все переменные, кроме вот той, по которой мы навешиваем квантор, и
[01:16:35.040 --> 01:16:43.080]  посмотреть при разных значениях этой переменной из квантора, что получается. Второй квантор,
[01:16:43.080 --> 01:16:48.840]  который у нас всегда в математике используется, квантор существования, он определяется очень похоже.
[01:16:48.840 --> 01:17:13.760]  Собственно единицей будет, если для какого-то,
[01:17:13.760 --> 01:17:27.280]  х1, предикат под квантором обращается в единицу. Ну с остальными значениями переменных. И здесь
[01:17:27.280 --> 01:17:41.040]  ноль. Иначе. Легко видеть, что кванторы существования и кванторы всеобщности связаны. Вас почти заведомо такой
[01:17:41.040 --> 01:17:54.120]  формуле учили, что отрицание квантора всеобщности это квантор существования по отрицанию вашего
[01:17:54.120 --> 01:18:00.320]  высказывания. Это просто вот из этих определений мгновенно следует. Мы к этому вопросу еще вернемся,
[01:18:00.320 --> 01:18:07.000]  конечно. Смотрите, что значит, что для любого x, r ложен. Смотрим на определение. Это означает,
[01:18:07.000 --> 01:18:14.840]  что найдется такой набор значений переменных x, что r ложен. Но если r ложно, отрицание r истинно.
[01:18:14.840 --> 01:18:21.120]  Когда смотрим вот здесь. Но это означает, что наш предикат вот этот квантором существования истинен.
[01:18:21.120 --> 01:18:26.880]  Ну и в обратную сторону рассуждения точно такое же. Это равносильные, как говорят, высказывания.
[01:18:26.880 --> 01:18:36.160]  Ну вот. Вот у нас появляется такой формализм. Удивительным образом больше, если ставить цель
[01:18:36.160 --> 01:18:42.400]  просто принципиально выразить всю математику, то больше ничего не нужно. Это кажется странным,
[01:18:42.400 --> 01:18:47.920]  потому что в математике формализм больше гораздо там много чего там хитрого и сложного. Но вот
[01:18:47.920 --> 01:18:55.160]  оказывается, что вот этого достаточно. Точнее, я скажу аккуратнее. Есть очень продвинутые области
[01:18:55.160 --> 01:19:02.600]  математики, которые никто никогда до уровня этого формализма не доводил. Математики верят,
[01:19:02.600 --> 01:19:08.000]  что это можно сделать. Но в книжках написано иначе. Написаны какие-то другие слова. И некоторые
[01:19:08.000 --> 01:19:13.520]  математики говорят, а вот представьте ситуацию. Мы начнем доводить до уровня вот этого формализма
[01:19:13.520 --> 01:19:18.920]  и столкнемся с проблемами. Потому что слова-то мы уже там 50 лет говорим гораздо более сложные.
[01:19:18.920 --> 01:19:26.640]  Может быть, мы уже используем какие-то принципы, которые выражаются таким образом. Но логики в
[01:19:26.640 --> 01:19:31.760]  это не очень верят. Большинство математиков тоже. Но такие еретики имеются. Может быть,
[01:19:31.760 --> 01:19:37.680]  в математике уже где-то сидит что-то большее, чем этот формализм. Потому что опустить продвинутое
[01:19:37.680 --> 01:19:42.560]  содержательное математическое рассуждение до этого уровня достаточно трудно. Тут, вы видите,
[01:19:42.560 --> 01:19:48.040]  возможностей на самом деле очень мало. На первый взгляд, кажется вообще странным, как мы можем
[01:19:48.040 --> 01:19:53.720]  обойтись только этим, при том, что даже та математика, которую вы знаете, там много чего еще
[01:19:53.720 --> 01:19:59.720]  есть всяких выразительных средств, которые буквально так не выглядят. Тем не менее есть
[01:19:59.720 --> 01:20:07.640]  универсальный способ выразить все с помощью этого формализма. Но у меня время вышло, поэтому я тут остановлюсь.
