[00:00.000 --> 00:19.800]  Закончим эту самую теорему, значит, теорема говорит, что для, если, следующее, следующее утверждение эквивалента.
[00:30.000 --> 00:56.800]  Значит, первое утверждение, а перечислимо. Второе, существует f из n в n, частичная функция f, вычислимая.
[00:57.600 --> 01:17.600]  Такая, что domain f равен 2, а третья, а существует f, частичная, f, вычислимая.
[01:18.400 --> 01:41.400]  Такая, что range f равен, а вот в четвертом пункте я в прошлый раз сделал небольшую, короче, не совсем корректно сформулировал, потому что я забыл записать одно условие, при котором это выполняется.
[01:42.200 --> 01:51.200]  Почему, собственно, вот этот пункт все еще нужен? Потому что здесь не всегда такая тотально вычислимая функция существует, а только если a не пусто.
[01:52.200 --> 01:57.200]  Для пустого, конечно, тотально вычислимая функция, у которой range пустой, не бывает.
[01:57.200 --> 02:27.000]  Значит, если a не пусто, то существует тотально вычислимая функция f из n в n.
[02:28.000 --> 02:33.000]  Такая, что range f равна a.
[02:37.000 --> 02:51.000]  Ну и последняя, пятая, существует вычислимая под множество, существует разрешимая, существует разрешимая b,
[02:51.800 --> 03:08.800]  под множество n² такое, что a есть проекция на первую координату b.
[03:09.600 --> 03:20.600]  Что мы доказали? Один эквивалент на два доказали, один эквивалент на три я хочу доказать по-другому, потому что я усложнил это доказательство.
[03:23.600 --> 03:28.600]  Нет, в обратную сторону, из 3 в 1, как мы доказывали?
[03:29.600 --> 03:35.600]  Я там как-то какую-то тотально вычислимую номерацию придумал, на самом деле там это все не нужно.
[03:39.600 --> 03:52.600]  Из 1 в 3 я усложнил, слишком усложнил, то есть предъявить нужно функцию, у которой range f равна a.
[03:53.600 --> 03:56.600]  Из 3 в 1, да, я сослался, я помню.
[03:57.600 --> 04:04.600]  Из 1 в 3 я усложнил, то есть на самом деле очень простая функция вычислимая, у которой range f равна a.
[04:05.600 --> 04:08.600]  Знаете какая? Какую я привел?
[04:09.600 --> 04:16.600]  А, это, я это сказал, да? Извините, тогда все хорошо.
[04:17.600 --> 04:26.600]  То есть 1-2 эквивалентно мы доказали, 1-3 эквивалентно мы доказали, 1-5 тоже, или что, где мы закончили?
[04:31.600 --> 04:38.600]  То есть, вот это да, я знаю, знаю, это осталось, я помню.
[04:39.600 --> 04:55.600]  Это осталось, так, то есть осталось у нас из 5 в 1, да, что проекция разрешима.
[04:56.600 --> 05:01.600]  Ну давайте, значит, как мы будем перечислять проекцию?
[05:02.400 --> 05:23.400]  То есть существует разрешимая b под множество m квадрат такой, что a проекция на первую координату b.
[05:24.200 --> 05:35.200]  Вот, значит, смотрите, как доказать, что разрешима перечислима?
[05:36.200 --> 05:39.200]  Ну, собственно, в этом суть утверждения, да?
[05:40.200 --> 05:43.200]  Ну, как перечислить проекцию?
[05:44.200 --> 05:50.200]  Ну давайте просто, у нас же разрешима b, будем перебирать пары, ну не знаю, по номерам просто.
[05:51.000 --> 05:58.000]  Сначала первую, у нас есть тотально вычислимая номерация, можно в принципе в любом порядке перебирать пары n квадрат.
[06:09.000 --> 06:13.000]  mn из n квадрат, в любом порядке.
[06:21.000 --> 06:40.000]  Если и проверяем для каждой пары, принадлежит она b или нет, проверяем mn принадлежит b или нет.
[06:40.800 --> 06:51.800]  Вот, если принадлежит, то выписываем первую координату, если не принадлежит, к следующей паре переходим, и так далее.
[06:52.800 --> 06:53.800]  Поняли, да?
[06:54.800 --> 07:03.800]  Если mn принадлежит b, то печатаем m.
[07:10.800 --> 07:15.800]  Иначе переходим к следующей паре.
[07:24.800 --> 07:29.800]  Ну, собственно, все, таким образом мы проекцию перечислим.
[07:34.800 --> 07:35.800]  Понятно?
[07:36.600 --> 07:49.600]  Ну хорошо, пример множества, для которого множество b из n квадрат, для которого проекция только перечислема, но неразрешима.
[07:50.600 --> 07:54.600]  Наверное, может быть, на этой, может быть, на следующей лекции даже дадим.
[07:55.600 --> 07:57.600]  Ну, ссылаясь на вот это утверждение, на самом деле.
[07:58.400 --> 07:59.400]  Значит, смотрите.
[08:00.400 --> 08:02.400]  Ну, теперь 1,4.
[08:06.400 --> 08:09.400]  Смотрите, а перечислимо и а не пусто.
[08:10.400 --> 08:17.400]  Вот, а перечислимо, а не пусто.
[08:18.200 --> 08:22.200]  Пусто множество тоже перечислимо, я про это вам говорил.
[08:23.200 --> 08:28.200]  Перечислитель там забавный, это программа, которая ничего не выводит, но работает бесконечно долго.
[08:33.200 --> 08:38.200]  Ну, понятно, что тотально вычислимые функции, которые range пустой, нельзя придумать, в принципе.
[08:39.200 --> 08:41.200]  Но она не будет тотально вычислимой.
[08:42.200 --> 08:46.200]  Поэтому с этим проблема, то есть здесь нужно требовать, чтобы они пусто были.
[08:47.000 --> 08:48.000]  Ну, хорошо.
[08:49.000 --> 08:51.000]  Тогда, на самом деле, вот такая конструкция.
[08:52.000 --> 08:54.000]  Строим следующую.
[08:54.800 --> 08:55.800]  Пусть к.
[09:14.800 --> 09:16.800]  Самый первый шаг.
[09:24.800 --> 09:31.800]  На котором перечислителя вывел какое-то число, но самое первое число.
[09:32.800 --> 09:45.800]  На котором перечислителя вывел первое число.
[09:54.800 --> 10:00.800]  k – это шаг, на котором появилось самое первое число перечислителя.
[10:01.800 --> 10:14.800]  Тогда f0 – это то число, которое на катом шаге было выведено.
[10:15.600 --> 10:20.600]  Число, появившееся на перечислителе.
[10:31.600 --> 10:33.600]  На катом шаге.
[10:34.400 --> 10:43.400]  А вот дальше, давайте скажем вот так.
[10:44.400 --> 10:51.400]  f1 – это последнее число, которое появилось на перечислителе на k-plus первом шаге.
[10:52.400 --> 10:54.400]  Ну, или до, или раньше.
[10:57.400 --> 10:59.400]  Последнее число.
[11:00.200 --> 11:17.200]  Число выведено перечислителем на k-plus первом шаге.
[11:18.200 --> 11:20.200]  До k-plus первого шага.
[11:27.200 --> 11:29.200]  Включительно.
[11:30.200 --> 11:32.200]  Ну и так далее.
[11:47.200 --> 11:49.200]  Вот сюда вот переведите.
[11:50.000 --> 11:56.000]  f at n – это…
[12:00.000 --> 12:01.000]  Подождите.
[12:02.000 --> 12:03.000]  А?
[12:04.000 --> 12:08.000]  На k-plus n, до k-plus n-го шага, да, наверное так.
[12:15.000 --> 12:17.000]  Последнее число.
[12:17.800 --> 12:25.800]  Последнему числу, которое было выведено…
[12:26.800 --> 12:30.800]  Подождите, проверю, что у меня сомнения появились.
[12:36.800 --> 12:38.800]  А, да, все правильно.
[12:39.800 --> 12:42.800]  Последнему числу, выведенному перечислителем.
[12:47.800 --> 12:49.800]  До k-plus n-го шага.
[13:03.800 --> 13:07.800]  Ну, то есть он дальше будет печатать, да, может там следующее, следующее.
[13:08.800 --> 13:10.800]  Но вот как выглядит эта функция?
[13:11.800 --> 13:14.800]  Она в нуле – это самое первое число, которое будет выведено.
[13:15.600 --> 13:20.600]  А потом, потом вот расстояние по шагам между первым и вторым
[13:21.600 --> 13:26.600]  будет то самое первое число постоянно в качестве значений, да.
[13:27.600 --> 13:30.600]  Потом второе число, которое было выведено, и так далее.
[13:31.600 --> 13:33.600]  Если множество конечное, то это будет там дальше
[13:34.600 --> 13:37.600]  бесконечный хвост из одинаковых значений, да.
[13:38.600 --> 13:41.600]  И эта функция тотального числима понятна, да, почему.
[13:42.400 --> 13:44.400]  Просто очень вполне разрешимое свойство.
[13:45.400 --> 13:50.400]  Нужно количество шагов сделать, посмотреть последнее число, которое появилось.
[13:51.400 --> 13:53.400]  Правильно, ребята?
[13:54.400 --> 13:55.400]  Вот.
[13:56.400 --> 13:58.400]  То есть вот она, тотально вычислимая функция из n-vent,
[13:59.400 --> 14:01.400]  такая же, что rangef равно a.
[14:02.400 --> 14:05.400]  Такая вот конструкция, красивая, да, ребят?
[14:06.400 --> 14:07.400]  Вот.
[14:08.400 --> 14:09.400]  Из 4 в 1.
[14:10.200 --> 14:19.200]  Ну, то, что область значений вычислимой функции перечислима,
[14:20.200 --> 14:23.200]  в данном случае даже очень понятно, почти как перечислять
[14:24.200 --> 14:25.200]  эта область значений.
[14:26.200 --> 14:29.200]  Тут даже, она же тотально вычислима, то есть тут даже изгаляться-то не надо.
[14:30.200 --> 14:32.200]  Можно просто по очереди брать натуральные числа, вычислять значения
[14:33.200 --> 14:34.200]  и печатать их.
[14:35.200 --> 14:36.200]  Вот все.
[14:37.200 --> 14:38.200]  Вот вам перечислитель.
[14:39.000 --> 14:41.000]  Это просто вычислимая функция, тут нужно было стараться,
[14:42.000 --> 14:44.000]  нужно было вот эту тотальную нумерацию брать,
[14:45.000 --> 14:47.000]  делать какое-то количество шагов, потому что если
[14:48.000 --> 14:50.000]  функция не определена, в какой-то точке вы закончите число шагов,
[14:51.000 --> 14:53.000]  вы это не выясните, это неразрешимое свойство.
[14:54.000 --> 14:55.000]  Вот.
[14:56.000 --> 14:58.000]  Поэтому приходилось, собственно, перебирать, делать какое-то
[14:59.000 --> 15:02.000]  количество шагов алгоритма, если он вывел, только тогда печатать.
[15:03.000 --> 15:06.000]  А вот здесь стараться даже не надо, оно всегда закончится
[15:06.800 --> 15:07.800]  в любом натуральном числе.
[15:08.800 --> 15:09.800]  Вот.
[15:10.800 --> 15:12.800]  Поэтому перебираем все n,
[15:19.800 --> 15:21.800]  все n из m,
[15:22.800 --> 15:23.800]  вычисляем
[15:28.800 --> 15:29.800]  f от n
[15:30.800 --> 15:31.800]  и печатаем.
[15:36.800 --> 15:37.800]  Все.
[15:38.800 --> 15:41.800]  Вот это свойство удобное, вот это конкретно свойство удобное,
[15:42.800 --> 15:45.800]  но правда, видите, нужно не забывать, что для множества
[15:46.800 --> 15:47.800]  должно быть не пустые.
[15:48.800 --> 15:49.800]  Вот.
[15:50.800 --> 15:51.800]  Ну хорошо.
[15:52.800 --> 15:53.800]  Теорема 2.
[15:55.800 --> 15:57.800]  Давайте небольшое определение дадим.
[15:58.800 --> 15:59.800]  Определение.
[16:01.800 --> 16:03.800]  Дана вычислимая функция,
[16:04.600 --> 16:05.600]  дана вычислимая функция f.
[16:06.600 --> 16:08.600]  Ну давайте просто дана функция f,
[16:09.600 --> 16:10.600]  частичная функция f.
[16:14.600 --> 16:15.600]  Ее графиком,
[16:16.600 --> 16:17.600]  ее графиком
[16:25.600 --> 16:27.600]  называется множество.
[16:34.600 --> 16:35.600]  Гамма от f,
[16:36.600 --> 16:37.600]  которая есть
[16:39.600 --> 16:41.600]  множество пар m, n,
[16:43.600 --> 16:44.600]  n, m, давайте вот так,
[16:45.600 --> 16:46.600]  n, m из n квадрат.
[16:48.600 --> 16:49.600]  Такие что
[16:50.600 --> 16:51.600]  f, m равно
[16:53.600 --> 16:54.600]  f от m.
[16:57.600 --> 16:59.600]  Ну понятно, в всех точках
[17:00.600 --> 17:02.600]  n из domain f.
[17:04.600 --> 17:05.600]  Вот.
[17:06.600 --> 17:07.600]  График функции.
[17:08.600 --> 17:09.600]  Множество точек,
[17:10.600 --> 17:12.600]  точек на плоскости, собственно говоря,
[17:13.600 --> 17:14.600]  первая координата x,
[17:15.600 --> 17:16.600]  вторая f от x,
[17:17.600 --> 17:18.600]  но только для тех точек,
[17:19.600 --> 17:20.600]  которых определена, конечно же.
[17:21.600 --> 17:22.600]  Вот.
[17:24.600 --> 17:25.600]  Давайте теперь теорема 2.
[17:25.600 --> 17:26.600]  И вам.
[17:32.600 --> 17:33.600]  Функция f
[17:39.600 --> 17:40.600]  из n
[17:41.600 --> 17:42.600]  в m
[17:43.600 --> 17:44.600]  вычислима
[17:52.600 --> 17:53.600]  тогда и только тогда,
[17:53.600 --> 17:55.600]  когда ее график
[17:56.600 --> 17:57.600]  перечислим.
[18:07.600 --> 18:09.600]  Это вот такой вот критерий.
[18:15.600 --> 18:17.600]  Ну давайте докажем.
[18:21.600 --> 18:22.600]  Ну,
[18:24.600 --> 18:27.600]  как ни странно, вот в эту, в прямую сторону,
[18:28.600 --> 18:30.600]  то есть нам известно, что функция вычислима,
[18:31.600 --> 18:32.600]  график,
[18:33.600 --> 18:34.600]  тогда график перечислим.
[18:38.600 --> 18:40.600]  Несколько сложнее будет доказать.
[18:42.600 --> 18:44.600]  Ну смотрите, можно
[18:45.600 --> 18:47.600]  теперь вот на ту теорема 1,
[18:48.600 --> 18:49.600]  которая сейчас такой стер,
[18:50.600 --> 18:51.600]  сослаться.
[18:51.600 --> 18:52.600]  Вот, значит,
[18:53.600 --> 18:54.600]  ну давайте смотреть.
[19:00.600 --> 19:02.600]  Есть такое читерское доказательство,
[19:03.600 --> 19:04.600]  но давайте попробуем его привести.
[19:05.600 --> 19:06.600]  Значит,
[19:09.600 --> 19:10.600]  f
[19:13.600 --> 19:14.600]  из n
[19:17.600 --> 19:18.600]  вот в эту сторону,
[19:19.600 --> 19:20.600]  то есть мы знаем, что она вычислима.
[19:22.600 --> 19:23.600]  Известно, что она вычислима.
[19:29.600 --> 19:31.600]  Тогда и domain,
[19:32.600 --> 19:36.600]  и range, область значения, область определения, они перечислимы.
[19:38.600 --> 19:40.600]  Мы это доказали вот в теореме 1.
[19:49.600 --> 19:50.600]  Перечислимы.
[19:51.600 --> 19:53.600]  А ну, коль скорая они перечислимы,
[19:54.600 --> 19:56.600]  к сожалению, к хорошему критерию про существование
[19:57.600 --> 19:59.600]  тотального числима мы здесь сослаться не можем,
[20:00.600 --> 20:03.600]  потому что мы не знаем, не пустыли эти domain и range,
[20:04.600 --> 20:05.600]  у нас общие случаи.
[20:06.600 --> 20:09.600]  Поэтому придется как-то довольствоваться более,
[20:10.600 --> 20:11.600]  более простым критериям,
[20:12.600 --> 20:13.600]  которым существует
[20:14.600 --> 20:15.600]  таталь,
[20:16.600 --> 20:17.600]  таталь,
[20:18.600 --> 20:19.600]  таталь,
[20:19.600 --> 20:20.600]  простым критериям,
[20:21.600 --> 20:22.600]  в котором существует
[20:23.600 --> 20:25.600]  собственно, существует функция,
[20:26.600 --> 20:28.600]  существует g
[20:30.600 --> 20:31.600]  из n
[20:33.600 --> 20:34.600]  в n.
[20:35.600 --> 20:36.600]  Такая, что
[20:37.600 --> 20:39.600]  domain g
[20:40.600 --> 20:41.600]  равен
[20:42.600 --> 20:43.600]  domain f.
[20:45.600 --> 20:47.600]  Ну, как бы, вот такая функция.
[20:47.600 --> 20:49.600]  Ну, мы ее давайте даже просто
[20:50.600 --> 20:52.600]  определим, что ли.
[20:57.600 --> 20:58.600]  Подождите.
[21:02.600 --> 21:04.600]  Да, зачем это нам функция нужна?
[21:09.600 --> 21:10.600]  А, давайте вот так.
[21:11.600 --> 21:12.600]  Нет.
[21:13.600 --> 21:14.600]  Придумал, прошу прощения.
[21:18.600 --> 21:21.600]  Если g, если domain f пуст,
[21:25.600 --> 21:26.600]  если domain f пуст.
[21:30.600 --> 21:32.600]  Так, нет, все равно чушь.
[21:33.600 --> 21:34.600]  Так, так, так, так, так.
[21:39.600 --> 21:41.600]  Сейчас пытаюсь, пытаюсь сообразить.
[21:42.600 --> 21:44.600]  Нет, нам нужна, нужна, нужна.
[21:45.600 --> 21:46.600]  Существует g
[21:47.600 --> 21:48.600]  из n
[21:49.600 --> 21:50.600]  в n частично.
[21:51.600 --> 21:52.600]  Такая, что
[21:54.600 --> 21:56.600]  domain f, domain g
[21:58.600 --> 21:59.600]  это
[22:00.600 --> 22:01.600]  domain f.
[22:03.600 --> 22:04.600]  Так?
[22:05.600 --> 22:06.600]  Угу.
[22:17.600 --> 22:18.600]  Так, ну да,
[22:19.600 --> 22:20.600]  в принципе, подождите.
[22:24.600 --> 22:25.600]  Ну, да.
[22:26.600 --> 22:27.600]  Да, я просто,
[22:27.600 --> 22:28.600]  знаете, я более формально,
[22:29.600 --> 22:31.600]  знаете, такое алгебраическое
[22:31.600 --> 22:33.600]  доказательство пытаюсь вспомнить,
[22:33.600 --> 22:35.600]  но что-то не вспоминается.
[22:35.600 --> 22:37.600]  Да, так-то вот не алгебраически,
[22:37.600 --> 22:39.600]  если излагать, то именно так мы
[22:39.600 --> 22:40.600]  и делаем.
[22:40.600 --> 22:41.600]  Вот.
[22:41.600 --> 22:42.600]  Мы перечисляем,
[22:43.600 --> 22:44.600]  мы перечисляем,
[22:44.600 --> 22:45.600]  именно так мы и делаем.
[22:46.600 --> 22:47.600]  Вот.
[22:47.600 --> 22:48.600]  Мы перечисляем domain,
[22:49.600 --> 22:51.600]  в каждой точке перечисленной
[22:51.600 --> 22:53.600]  считаем значение, собственно,
[22:53.600 --> 22:54.600]  и выводим пару.
[22:56.600 --> 22:57.600]  Вот.
[22:57.600 --> 22:58.600]  Ну, давайте.
[23:01.600 --> 23:02.600]  Так.
[23:03.600 --> 23:05.600]  Я пытался просто алгебраически как-то это сделать,
[23:05.600 --> 23:06.600]  ну ладно.
[23:07.600 --> 23:09.600]  Так, значит, перечисляем.
[23:14.600 --> 23:15.600]  Domain F.
[23:20.600 --> 23:21.600]  В каждой
[23:28.600 --> 23:29.600]  выведенной точке
[23:39.600 --> 23:40.600]  x считаем
[23:45.600 --> 23:46.600]  f от x
[23:47.600 --> 23:48.600]  и печатаем
[23:53.600 --> 23:54.600]  x от x
[23:57.600 --> 23:59.600]  Вот так перечисляем график.
[24:07.600 --> 24:09.600]  Это будет перечислением графика.
[24:15.600 --> 24:17.600]  Ну, как же.
[24:19.600 --> 24:20.600]  Так.
[24:21.600 --> 24:23.600]  Из той теории мы, наверное,
[24:24.600 --> 24:26.600]  ну, в принципе, оно доказывается также.
[24:26.600 --> 24:29.600]  Доказывается также, конечно, напрямую не следует.
[24:30.600 --> 24:32.600]  Доказывается также, как перечислить
[24:32.600 --> 24:34.600]  область определения, область значения.
[24:35.600 --> 24:36.600]  Ну, как?
[24:37.600 --> 24:38.600]  Да она вычислимая функция.
[24:38.600 --> 24:39.600]  Как перечислить?
[24:39.600 --> 24:41.600]  Ну, просто берем, перебираемся пары.
[24:41.600 --> 24:42.600]  x, k.
[24:42.600 --> 24:43.600]  Да.
[24:44.600 --> 24:47.600]  На входе x, k шагов алгоритма делаем.
[24:48.600 --> 24:51.600]  Перечисляем там, не знаю, по возрастанию номеров или как-то.
[24:51.600 --> 24:54.600]  На самом деле можно даже не заморачивать
[24:54.600 --> 24:56.600]  с этой номерацией тотально вычислимой.
[24:57.600 --> 25:00.600]  Просто в любом порядке перечислять вот эти пары.
[25:01.600 --> 25:05.600]  Считать, значит, запускать алгоритм
[25:05.600 --> 25:08.600]  и сделать первые k шагов этой алгоритмы.
[25:08.600 --> 25:11.600]  А если что-то будет выведено,
[25:11.600 --> 25:14.600]  то, собственно, если мы перечисляем domain,
[25:14.600 --> 25:16.600]  то мы пишем x, печатаем x.
[25:16.600 --> 25:20.600]  Если мы перечисляем range,
[25:20.600 --> 25:22.600]  то печатаем вторую координату.
[25:22.600 --> 25:24.600]  Ну и все, собственно.
[25:24.600 --> 25:27.600]  Ну, не второй координат, а то, что вычислено.
[25:32.600 --> 25:35.600]  Ну, просто отдельной LEM можно просто,
[25:35.600 --> 25:40.600]  что для вычислимой функции domain range перечислимая.
[25:42.600 --> 25:45.600]  Просто принцип доказательства такой же.
[25:45.600 --> 25:47.600]  Там я привел рассуждение.
[25:48.600 --> 25:50.600]  Да, это некорректно ссылаться.
[25:50.600 --> 25:52.600]  Напрямую-то, конечно, я-то и не доказывал,
[25:52.600 --> 25:54.600]  и с той теориями не следует.
[25:54.600 --> 25:56.600]  Просто рассуждение такое же.
[25:57.600 --> 25:59.600]  Так, это будет перечислителем.
[26:05.600 --> 26:07.600]  Gamma t.
[26:09.600 --> 26:11.600]  В обратную сторону.
[26:15.600 --> 26:18.600]  Пусть Gamma t, наоборот, перечислил.
[26:18.600 --> 26:20.600]  Это нам известно.
[26:24.600 --> 26:26.600]  Как вычислить значение f от x,
[26:26.600 --> 26:28.600]  если оно определено?
[26:30.600 --> 26:31.600]  Перечисляем пары.
[26:31.600 --> 26:32.600]  Да.
[26:33.600 --> 26:34.600]  Тогда...
[26:38.600 --> 26:40.600]  Тогда на входе x...
[26:41.600 --> 26:43.600]  На входе x...
[26:49.600 --> 26:51.600]  Перечисляем Gamma t.
[26:53.600 --> 26:55.600]  Перечисляем Gamma t.
[27:02.600 --> 27:04.600]  И ждем пару.
[27:08.600 --> 27:10.600]  И ждем пару.
[27:15.600 --> 27:17.600]  С первой компоненты x.
[27:27.600 --> 27:29.600]  Ну, если такая пара появилась,
[27:29.600 --> 27:31.600]  то печатаем вторую компоненту.
[27:34.600 --> 27:36.600]  Если она появилась,
[27:44.600 --> 27:47.600]  печатаем вторую компоненту пары Гамаев.
[28:00.600 --> 28:02.600]  Компоненту этой пары.
[28:07.600 --> 28:10.600]  Если в точке x функция не определена,
[28:10.600 --> 28:13.600]  то такая пара с такой первой компонентой
[28:13.600 --> 28:16.600]  никогда перечислена не будет.
[28:17.600 --> 28:19.600]  Ну, а значит, мы будем бесконечно долго ждать,
[28:19.600 --> 28:21.600]  но, то есть, по сути, зациклимся.
[28:21.600 --> 28:23.600]  Это нам и нужно.
[28:23.600 --> 28:26.600]  Если x не из домейна f,
[28:33.600 --> 28:36.600]  то такой пары на перечислителе не появится.
[28:38.600 --> 28:41.600]  То пары с первой компонентой x
[28:48.600 --> 28:50.600]  не появляются.
[28:54.600 --> 28:57.600]  Никогда не будет перечислено.
[29:15.600 --> 29:18.600]  Но это нам и надо, собственно говоря.
[29:24.600 --> 29:27.600]  Нужно зациклиться, если значений нет,
[29:27.600 --> 29:30.600]  и если значение будет, то вычислить.
[29:30.600 --> 29:33.600]  Ну, собственно, вот все это и сделали.
[29:40.600 --> 29:42.600]  Хорошо.
[29:46.600 --> 29:49.600]  Так, что еще я хотел рассказать?
[29:49.600 --> 29:51.600]  В этой части, прошу прощения,
[29:51.600 --> 29:54.600]  чтобы не забыть ничего.
[29:59.600 --> 30:01.600]  Ну, хорошо.
[30:05.600 --> 30:07.600]  Давайте следствие у вас этой теории
[30:07.600 --> 30:09.600]  мы два небольшое выведем
[30:09.600 --> 30:11.600]  и начнем, собственно,
[30:11.600 --> 30:15.600]  универсальные вычислимые функции изучать.
[30:21.600 --> 30:23.600]  Вопрос?
[30:51.600 --> 30:53.600]  Думаю, просто потому, что там напрямую следует
[30:53.600 --> 30:55.600]  с первой сиремой все-таки,
[30:55.600 --> 30:58.600]  что рейндж и домейн перечислим.
[30:58.600 --> 31:01.600]  Там не надо ничего дополнительного доказывать.
[31:01.600 --> 31:03.600]  В обратную сторону...
[31:03.600 --> 31:05.600]  А, подождите, действительно,
[31:05.600 --> 31:07.600]  то есть в обратную сторону же
[31:07.600 --> 31:09.600]  это именно так и звучит.
[31:09.600 --> 31:11.600]  То есть если f вычислима,
[31:11.600 --> 31:13.600]  то у нее домейн перечислим.
[31:13.600 --> 31:15.600]  То есть это в обратную сторону и есть.
[31:15.600 --> 31:17.600]  Мы это доказали.
[31:17.600 --> 31:19.600]  Следствие.
[31:25.600 --> 31:33.600]  Если f у нас вычислимая функция,
[31:35.600 --> 31:37.600]  вычислимая,
[31:37.600 --> 31:47.600]  а перечислима,
[31:53.600 --> 31:57.600]  то f от а и f-1 это тоже перечислим.
[32:07.600 --> 32:13.600]  Как вы думаете, как такое доказать?
[32:21.600 --> 32:23.600]  А как?
[32:29.600 --> 32:31.600]  Подождите еще раз.
[32:31.600 --> 32:33.600]  У нас же а не обязательно,
[32:33.600 --> 32:35.600]  а под множество n перечислимое.
[32:35.600 --> 32:37.600]  Как перечислить f от а?
[32:47.600 --> 32:49.600]  f-1 как?
[32:51.600 --> 32:53.600]  Подождите еще раз.
[32:53.600 --> 32:55.600]  Перечисляем а, а вдруг...
[32:55.600 --> 32:59.600]  Я же не сказал, что а под множество домейн f.
[32:59.600 --> 33:03.600]  То есть не в всех точках...
[33:05.600 --> 33:07.600]  Повторяю.
[33:07.600 --> 33:09.600]  Хорошо, а мы можем перечислить,
[33:09.600 --> 33:11.600]  но не во всех точках мы можем вычислить значение.
[33:11.600 --> 33:13.600]  Как делать?
[33:29.600 --> 33:31.600]  Подождите.
[33:31.600 --> 33:33.600]  Не разрешитель?
[33:33.600 --> 33:35.600]  Это не годится.
[33:35.600 --> 33:37.600]  Нам нужно перечислить.
[33:47.600 --> 33:49.600]  Что значит одна итерация?
[33:55.600 --> 33:57.600]  Шаг, что ли, один алгоритм?
[33:57.600 --> 33:59.600]  Да.
[33:59.600 --> 34:01.600]  А вдруг алгоритм не вычислен?
[34:01.600 --> 34:03.600]  f от x определено,
[34:03.600 --> 34:05.600]  f от x не обязательно вычисляется за один шаг.
[34:05.600 --> 34:07.600]  Почему?
[34:21.600 --> 34:23.600]  f от а, да, конечно.
[34:23.600 --> 34:25.600]  Но не обязательно перечислимое.
[34:25.600 --> 34:27.600]  Перечислимое не верно.
[34:27.600 --> 34:29.600]  Давайте просто тупо подумаем.
[34:29.600 --> 34:33.600]  Мы подумаем, если перечислимое множество без...
[34:33.600 --> 34:37.600]  перечислимых множество конечно верно.
[34:37.600 --> 34:39.600]  Поэтому с собой не обязательно
[34:39.600 --> 34:41.600]  под множество разрешимого, перечислимого,
[34:41.600 --> 34:43.600]  перечислимого или разрешимого.
[34:43.600 --> 34:45.600]  Вот.
[34:55.600 --> 34:57.600]  То есть два перечисления делает, да?
[35:01.600 --> 35:03.600]  Трудно так перечислять,
[35:03.600 --> 35:05.600]  честно говоря.
[35:05.600 --> 35:07.600]  То есть видите,
[35:07.600 --> 35:09.600]  я бы придумал что-нибудь поинтереснее,
[35:09.600 --> 35:11.600]  например,
[35:11.600 --> 35:13.600]  скажем, запускать x
[35:13.600 --> 35:15.600]  вычисление f,
[35:15.600 --> 35:17.600]  перечислитель f на k шагов.
[35:17.600 --> 35:21.600]  Перечислителя давайте запускать на k шагов.
[35:21.600 --> 35:27.600]  И еще m шагов делать алгоритму вычисляющего af.
[35:31.600 --> 35:35.600]  На последнем элементе, который перечислитель вывел.
[35:35.600 --> 35:37.600]  То есть мы перечисляем все тройки
[35:37.600 --> 35:39.600]  натуральных чисел
[35:39.600 --> 35:41.600]  вычислимым образом.
[35:45.600 --> 35:47.600]  И делаем вот что.
[35:47.600 --> 35:49.600]  То есть мы перечисляем a,
[35:49.600 --> 35:53.600]  делаем k шагов перечисления.
[35:53.600 --> 35:57.600]  Потом на последнем выведенном перечисленном элементе
[35:57.600 --> 35:59.600]  делаем m шагов алгоритма,
[35:59.600 --> 36:01.600]  если при этом что-нибудь...
[36:01.600 --> 36:03.600]  Ну и на входе x.
[36:03.600 --> 36:05.600]  Соответственно, если при этом будет что-то выведено,
[36:05.600 --> 36:07.600]  то печатаем.
[36:07.600 --> 36:09.600]  Вот как-нибудь так, например,
[36:09.600 --> 36:13.600]  f от a будем разрешать.
[36:13.600 --> 36:17.600]  Давайте просто воспользуемся вот этой предыдущей теорем,
[36:17.600 --> 36:19.600]  почему я написал, что это следствие.
[36:19.600 --> 36:21.600]  f вычислимо...
[36:25.600 --> 36:27.600]  f вычислимо...
[36:33.600 --> 36:35.600]  Следовательно, график f перечислим.
[36:37.600 --> 36:47.600]  Теперь, что такое у нас f от a?
[36:53.600 --> 36:55.600]  Это пересечение графика.
[36:55.600 --> 36:57.600]  С чем?
[36:59.600 --> 37:03.600]  С множеством a декартов m.
[37:07.600 --> 37:09.600]  Правда?
[37:09.600 --> 37:11.600]  Да, да, проекция.
[37:11.600 --> 37:15.600]  Проекция на вторую координату вот этого дела.
[37:15.600 --> 37:19.600]  Это f от a.
[37:21.600 --> 37:25.600]  Смотрите, вот это перечислимо.
[37:31.600 --> 37:35.600]  Вот это тоже перечислимо.
[37:37.600 --> 37:39.600]  Значит, пересечение перечислимых –
[37:39.600 --> 37:41.600]  это перечислимое множество.
[37:41.600 --> 37:43.600]  Ну, как раз под множество это неверно,
[37:43.600 --> 37:47.600]  но пересечение перечислимых перечислимое.
[37:47.600 --> 37:51.600]  И проекция перечислимого множества тоже перечислимое.
[37:51.600 --> 37:55.600]  Значит, все это перечисbled...
[38:02.600 --> 38:04.600]  Это f от a
[38:07.600 --> 38:23.680]  ну перечисляем а и не знаю нужно все пары до вывести нужно все по вместе
[38:23.680 --> 38:32.680]  ну да да да можно так
[38:32.680 --> 38:49.520]  ну да да то есть как бы перечисляем а потом перечисляем для каждого выведенного нового
[38:49.520 --> 38:58.960]  элемента перечисляем все предыдущие элементы на n там пускай n элемент был выведен а все
[38:58.960 --> 39:08.520]  предыдущие декартовы n перечисляем да и ну все все числа с новым элементом от одного декартова
[39:08.520 --> 39:14.440]  от одного dn вот такие пары и так так мы перечислим то есть придется конечно работать со всеми
[39:14.440 --> 39:20.640]  предыдущими то есть если вот для первого мы выведем первый элемент 1 потом когда
[39:20.640 --> 39:32.720]  второе число появится выведем первый элемент 2 второй элемент 1 2 ну и так далее поняли да это
[39:32.720 --> 39:37.520]  тоже можно мы доказывали что декартовы при произведении перечислим это перечислима а
[39:37.520 --> 39:45.760]  а перечислима поэтому оно перечислима это вот на самом деле можно да сослаться на теоремы
[39:45.760 --> 39:54.920]  которые мы уже доказали а проекция на первую координату гамма f пересечь а декартовы
[39:54.920 --> 40:07.320]  это это вот это фота а вот это f-1 это поэтому оно тоже перечислима
[40:07.320 --> 40:30.320]  ну все вот следствие так ну хорошо теперь так 12 20 да или 10 у нас 10
[40:30.320 --> 40:36.720]  теперь про универсально вычислимые функции будет говорить
[40:36.720 --> 40:51.160]  но более менее удовлетворимое объяснение формальной доказательства я не дам того что
[40:51.160 --> 40:57.200]  существует универсально вычислимая функция вот потому что для каждой конка я объяснял почему
[40:57.200 --> 41:07.040]  потому что для каждой конкретной модели алгоритма там на самом деле их много например ну вот мы еще
[41:07.040 --> 41:15.760]  на михмате нас любил наш декан у нас читал правда предмет назывался мат логика но читал нам
[41:15.760 --> 41:25.040]  дискретно математику вот не знаю почему так было сделано но он декан он может вот значит
[41:25.040 --> 41:34.200]  то есть у нас был поток разбит на два подпотока и одного подпотока был один лектор и другого
[41:34.200 --> 41:42.960]  подпотока был второй лектор тот лектор который не наш был он логику читал наш читал дискретно
[41:42.960 --> 41:51.480]  математику вот ну так вот он во время этой логики дискретной математики значит давал
[41:51.480 --> 42:00.160]  вторую модель на самом деле это так называемые автоматные функции можно еще там некоторые еще
[42:00.160 --> 42:11.520]  некоторые есть модели вычисления алгоритмов но по каждой модели в принципе можно привести
[42:11.520 --> 42:22.960]  формальные доказательства того что есть универсальная вычислимая функция но это очень
[42:22.960 --> 42:30.000]  долго очень сложно там не знаю по машинам тюринга есть целая книжка которая доказывает вот главный
[42:30.000 --> 42:34.240]  результат который это вот что есть универсальная вычислимая функция ну параллельно построена
[42:34.240 --> 42:41.240]  хорошая классификация всех вычислимых функций но вот этот под задачи которая нужна чтобы это
[42:41.240 --> 43:06.840]  доказать значит что такое сейчас сначала определение а потом такое рукомахательное
[43:06.840 --> 43:17.960]  объяснение почему она бывает такая значит функция вычислить тотально так вычислимая функция
[43:17.960 --> 43:30.120]  от двух аргументов
[43:30.120 --> 43:58.920]  но это частичная функция из антикарта вн вн называется называется универсальная вычислимая
[43:58.920 --> 44:21.680]  функции если для любого вычислимого f для любой вычислимой функции
[44:21.680 --> 44:37.440]  что делать что делать так любой вычислимая
[44:37.440 --> 44:56.800]  существует такое n из n такое что для любого x из n вот сейчас я напишу значок потом объясню
[44:56.800 --> 45:01.760]  нужно сам деле самом начале этот значок было определить но я всегда забываю определить потому
[45:01.760 --> 45:08.360]  что в начале курса ну в начале вот нашей темы он не нужен он не используется вот он начинает
[45:08.360 --> 45:20.280]  использоваться вот именно здесь значок вот такой вот сейчас надо объяснить что он значит значит
[45:20.280 --> 45:27.200]  что это значит это значит что если вот это он x точке x определена то знать то f от x тоже
[45:27.200 --> 45:35.560]  определена и значения их совпадают если у он x точке x не определена то ф от x тоже не
[45:35.560 --> 45:44.080]  определена и в обратную тоже да то есть у них если если у них один одновременно либо они
[45:44.080 --> 45:52.880]  определены у них тогда одинаковые значения либо они не определены но тоже в обе стороны как бы
[45:52.880 --> 46:01.840]  совпадающие частичные функции получается у нас такая вот такой значок равенство с волной ну
[46:01.840 --> 46:07.480]  просто вот чистое равенство писать некорректно просто потому что ну может в этих точках она не
[46:07.480 --> 46:14.560]  определена тогда равенство какое о каком равенство речь идет да то есть они одновременно либо не
[46:14.560 --> 46:21.680]  определены условное равенство тогда будет либо поделены тогда не равны вот
[46:21.680 --> 46:37.760]  хорошо то есть смотрите вот такая вот штука у н x что это такое то есть вот n зафиксировано x
[46:37.760 --> 46:43.360]  меняется да и у нас получается вот какая-то понятно что смотрите если у нас он x это
[46:43.500 --> 46:49.600]  функция как вы понимаете научи conquest как функция двух переменных то есть и anat��고
[46:49.600 --> 46:55.240]  функция двух перемен вы чтобы при фиксации любого любого числа вот на первой позиции мы можем в
[46:55.240 --> 47:01.680]  принципе мы получаем в качестве вот мы если менять вторую координату получаем тоже вычислимая
[47:01.680 --> 47:07.140]  функцию да только что такой в bola小心о функция эта функция такая что при всех
[47:07.140 --> 47:13.680]  фиксациях, но тут все возможные вычислимые функции будут в качестве срезок, так
[47:13.680 --> 47:20.320]  называемых срезок. Иногда это обозначается вот так у n, ну то есть вот n зафиксирован,
[47:20.320 --> 47:31.440]  а x вот так. Поняли, да? То есть в срезках все возможные вычислимые функции, которые
[47:31.440 --> 47:40.560]  существуют. Это универсальная вычислимая функция. Почему такая в принципе существует? Ну вот такое
[47:40.560 --> 47:50.200]  объяснение зиждется на недоказанном предположении о том, что множество всех возможных программ
[47:50.200 --> 48:02.400]  перечислимо. Вот смотрите, вот слово, слово алфавит сигма, на котором алгоритмы строятся,
[48:02.400 --> 48:15.000]  программа это слово в алфавите сигмы, да, набор команд. Поскольку у нас алфавит конечен, множество
[48:15.000 --> 48:20.680]  слов вообще-то перечислимо, но это не факт, что множество программ отсюда, не следует, что отсюда,
[48:20.680 --> 48:26.920]  что множество программ перечислимо, это под множество какое-то, которое компилируется,
[48:26.920 --> 48:35.200]  да, но вот интуитивно предполагаем, что множество всех программ над алфавитом сигмы перечислимо.
[48:35.200 --> 48:48.320]  Ну да, оно же всегда алфавит конечен, над которым у нас все делается. А раз оно перечислимо,
[48:48.320 --> 48:54.440]  то есть тотально вычислено, понятно это не пустое, это бесконечно множество само собой,
[48:54.440 --> 49:04.040]  значит есть тотально вычислимая функция. Алфавит сигма, но слов-то бесконечно много и
[49:04.040 --> 49:14.320]  программ бесконечно много. Конечно, там длина-то не ограничена. Вот это не обосновано,
[49:14.320 --> 49:20.520]  чтобы доказать, книжки надо писать целые, но давайте предположим, что вот это верно,
[49:20.520 --> 49:41.320]  тогда у нас существует тотально вычислимая функция f из n в n такая, что range f равен множеству
[49:41.320 --> 49:58.960]  всех программ. Я обозначу p, множество всех программ. Ну, вычислимая функция соответствует
[49:58.960 --> 50:06.640]  программу, которая ее вычисляет. Мы предполагаем, что множество всех программ можно перечислить,
[50:06.640 --> 50:14.160]  значит есть тотально вычислимая функция, у которой область значения это все вычислимые
[50:14.160 --> 50:21.080]  программы. Единственное, туда не в n, а в сигма со звездой. Но тут тонкость в чем? В том,
[50:21.080 --> 50:29.920]  что это еще множество, поэтому в принте можно такое предположить. То есть как-то перенумеровать
[50:29.920 --> 50:50.920]  вот эти программы, ну, слова. Слова, в принципе, можно перенумеровать, то есть взять просто,
[50:50.920 --> 50:56.760]  например, по длинным сначала индексировать, помните? Но не знаю, это в первом семестре вы
[50:56.760 --> 51:02.600]  делали, но я даже на семинарах, на лекциях вроде рассказывал, то есть фиксируем длину,
[51:02.600 --> 51:08.360]  перечисляем все слова данной длины, это конечное множество в любом порядке, потом увеличиваем
[51:08.360 --> 51:16.100]  и следующий, ну и так далее. Можно как-то перенумеровать. Слова, множество слов над
[51:16.100 --> 51:36.500]  конечным алфавитом оно счетно. Даже над счетным, кстати, алфавитом тоже счетно. Так. Смотрите
[51:36.500 --> 51:44.420]  теперь, как описать программу, которая, собственно, печатает, считает универсальные
[51:44.420 --> 52:14.060]  вычислимые функции. Программа, вычисляющая значение, значит, по ходу nx,
[52:14.060 --> 52:32.980]  что мы сделаем? Мы считаем значение, считаем значение, значение fat n, получаем слово,
[52:32.980 --> 52:42.620]  которое есть программа, программу переделываем на какой-нибудь язык программирования, запускаем
[52:42.620 --> 52:55.580]  на входе x, получаем программу. Эту программу
[52:55.580 --> 53:25.500]  на входе, запускаем на входе x. Ну, если что-то выведется за конечным
[53:25.500 --> 53:38.220]  время, выводим. Если не выведется, мы зациклимся. Собственно, все, что мы будем делать. Понятно,
[53:38.220 --> 53:43.780]  да? Почему универсальная вычислимая функция? Ну, потому что в качестве range все возможные
[53:43.780 --> 53:52.260]  программы, а значит, все вычислимые функции там будут. Но я не утверждаю, кстати, что для одной
[53:52.260 --> 53:58.340]  и той же вычислимой функции нельзя написать несколько программ, которые ее считают. Конечно,
[53:58.340 --> 54:10.460]  можно. То есть, конечно, в качестве срезок есть повторяющиеся вычислимые функции. И это, кстати,
[54:10.460 --> 54:15.860]  очень интересный факт. Мы позже выясним, что, например, для хороших универсальных вычислимых
[54:15.860 --> 54:22.860]  функций, так называемых главных. Чуть позже определю, что это такое. Их даже бесконечно много таких
[54:22.860 --> 54:28.740]  вот записей. То есть, каждая вычислимая функция бесконечно много раз встречается в качестве срезок.
[54:28.740 --> 54:42.340]  Значит, ну ладно. Вот так вот условно доказали, что существует универсальная вычислимая функция.
[54:42.340 --> 54:49.300]  Хорошо, да. Повторюсь, это не есть формально доказательство. Как минимум оно основано
[54:49.300 --> 54:54.020]  на одном недоказанном утверждении, что множество программ перечислимые.
[54:54.020 --> 55:10.340]  Ну да, проблема вот с чем. В том, что это вот на такое рассуждение не предполагает,
[55:10.340 --> 55:18.580]  что у нас получится вычислимая функция двух аргументов. Нам нужно получить вычислимую
[55:18.580 --> 55:23.860]  функцию двух аргументов. Да, понятное дело, берем перечисляемую. Я также рассуждал,
[55:23.860 --> 55:29.180]  когда вот начинал преподавать, я тоже не до конца разобрался с теми, вот так же рассуждал.
[55:29.180 --> 55:35.660]  Берем все вычислимые функции еще одномного. Берем первую функцию в первую срезку,
[55:35.660 --> 55:43.220]  вторую функцию во вторую, третью в целей, и так далее. Пожалуйста, универсальная вычислимая
[55:43.220 --> 55:49.540]  функция. А почему некорректное рассуждение? Потому что такая функция о двух переменах и факт,
[55:49.540 --> 55:58.300]  что вычислимая. Ну а как вы алгоритм же нужен? Как вы алгоритм построите, который считает
[55:58.300 --> 56:09.100]  такую функцию? Ну а как вы вычислимым образом сопоставите числу натуральному вычислимую
[56:09.100 --> 56:12.780]  функцию? Это же вычислимым образом делать, но это нельзя сделать вычислимым образом,
[56:12.780 --> 56:22.140]  потому что вычислимым образом можно число числа сопоставлять. Вот число функции нельзя. Да-да,
[56:22.460 --> 56:28.820]  собственно, здесь я алгоритм вам описал даже, который все считает. А вот такое рассуждение
[56:28.820 --> 56:38.340]  просто строит функцию из n в квадрат В, но не доказывает, что она вычислима. А нам
[56:38.340 --> 56:45.740]  нужна именно вычислимая функция от двух аргументов. Ну хорошо, теперь определим свойства,
[56:45.740 --> 56:58.460]  на которых мы дальше будем работать. Знаете, есть два способа записать. Я предпочитать буду вот
[56:58.460 --> 57:18.300]  такой nx, nk, na. Ну забыл еще, вспомнил, что еще нужно вести. Если у nx универсальная вычислимая
[57:18.300 --> 57:35.620]  функция будем сокращать вот так uvf, универсальная вычислимая функция, то если у n есть f от x,
[57:35.620 --> 57:54.860]  то мы будем писать, то будем писать. Что? Я просто хочу обозначения вести, которые нам нужны будут.
[57:54.860 --> 58:13.660]  Вот такие фигурные скобочки n, это функция. Еще универсальная вычислимая функция называется
[58:13.660 --> 58:26.380]  нумерацией. Вот функция по нумерации u с номером n обозначается вот такими скобочками фигурными.
[58:26.380 --> 58:31.260]  Иногда сама нумерация здесь в индексе указывается, но если по контексту понятно,
[58:31.260 --> 58:36.060]  какая нумерация, если в теории она одна, этот индекс мы будем пропускать. Если там
[58:36.060 --> 58:41.060]  нумерации будет несколько, то нужно будет в качестве индекса указать, по какой нумерации
[58:41.620 --> 58:50.740]  но то есть вот это в квадратных скобочках это функция с номером n по нумерации u. Поняли?
[58:50.740 --> 59:08.380]  Это нам нужно понадобиться. В доказательствах теоремы для сокращения некоторых записей,
[59:08.380 --> 59:13.300]  иногда там будет громоздкие штуки появляться. Вот иногда там нужно будет такая штука.
[59:13.300 --> 59:23.980]  Что хотел рассказать? Нужно было вести это определение, сейчас я забыл его вести,
[59:23.980 --> 59:46.540]  поэтому сейчас. Что дальше нужно? А, да, свойства. Два способа записать. Есть два предиката,
[59:46.660 --> 59:54.700]  так называемые t предикаты. Потом мы дальше будем пользоваться чуть позже. Эти t предикаты
[59:54.700 --> 01:00:02.700]  конкретно в нашем курсе нужны будут. Как предикат мы можем писать вот как, либо
[01:00:02.700 --> 01:00:15.780]  есть t предикат просто, есть t штрих еще предикат. Сейчас определю, что это такое. Второй способ это
[01:00:15.780 --> 01:00:34.740]  вот так записать. Это предикат. Это утверждение, которое на каждом наборе либо 1, либо 0. Это
[01:00:34.740 --> 01:00:45.100]  вычислимый предикат. Важно. Тотально вычислимый предикат равный единице тогда и только тогда.
[01:00:45.100 --> 01:00:59.140]  Что? Предикат это функция из n в куб в данном случае в 0,1. Значит вычислимая функция,
[01:00:59.140 --> 01:01:04.460]  тотально вычислимая функция, которая говорит вот что это единица тогда и только тогда,
[01:01:04.460 --> 01:01:31.100]  когда у nx, он собственно на входе xn нашим nx, остановится заказ шагов.
[01:01:31.100 --> 01:01:44.620]  Вполне себе вычислимое свойство, правда? У нас есть программа вычисляющая универсально
[01:01:44.620 --> 01:01:53.500]  вычислимую функцию и мы можем вычислить, то есть программу запустить на входе nx, сделать ко шагу
[01:01:53.500 --> 01:02:08.100]  и выяснить остановится в данном случае за ровно ко шагу. Второй t-штрих предикат или менее то ложь, да, то ложь.
[01:02:08.100 --> 01:02:28.100]  Есть еще t-штрих предикат чуть более расширенный, он четырехместный, значит
[01:02:28.100 --> 01:02:48.100]  тоже тотально вычислимый предикат, значит который говорит вот что, что у nx остановится
[01:02:48.100 --> 01:03:16.660]  за ровно ко шагу, за ровно ко шагу и выведет y, и выведет y.
[01:03:16.660 --> 01:03:26.460]  Тотально вычислимый предикат, вполне проверяемое свойство алгоритмически.
[01:03:26.460 --> 01:03:49.340]  Вот, t-предикаты, ну и такую задачку, да, ребят, а вы на семинарах что сейчас изучаете? Что закончили?
[01:03:56.460 --> 01:04:20.340]  В смысле, вы закончили с точечными функциями или что, я не понял? А если у него время есть чужонный весь, интересно, время вагона, да, интересно, нужно спросить, а кто у вас?
[01:04:20.340 --> 01:04:50.220]  Нет, я понимаю, что в некоторых группах застряли на графах и еле-еле успеют этот листочек про вычислимые функции, да, я понимаю, да, и там еще по Тимашиной Чьюринга листочек, да, про это я в курсе, поэтому, собственно, в некоторых группах приняли решение только половину, потому что другую не успеет, половина листочка.
[01:04:50.220 --> 01:05:18.100]  Изучить, но если у вас время-то есть, то чего, непонятно. Ну, собственно, подскок, вы листочек не успеваете, я буду из листочка некоторые вещи разбирать здесь, тем более, что я немножко с опережением графика иду, значит, по ходу вот этого вот, вот этой вещи, такая задача.
[01:05:18.100 --> 01:05:47.980]  Она в листочках была А, Б, под множество М, перечислимые множество, тогда существует А штрих, Б штрих,
[01:05:48.100 --> 01:06:10.980]  перечислимые такие, что А штрих объединит с Б штрих, есть А объединит с Б, то есть их объединение то же самое, но А штрих, Б штрих не пересекаются при этом.
[01:06:10.980 --> 01:06:40.860]  В чем тут главная загвоздка в этой задаче? В том, что, ну, вот тупо рассуждать, в чем идея, что нужно сделать? Нужно, у нас есть пересечение, да, у нас есть пересечение, и это пересечение нужно как-то разделить между множествами А и Б, А штрих и Б штрих, так, чтобы они не пересекались.
[01:06:40.860 --> 01:07:10.740]  Они стали перечислимыми, ну, просто взять, например, ВА отдать все пересечение, Б минус А не всегда перечислимо, разность двух перечислимых множеств не обязательно перечислима, а поэтому не факт, что просто все отдать можно будет, так, чтобы А штрих, Б штрих остались перечислимыми, то есть нужно вот это пересечение таким перечислимым образом разделить между ними, так, чтобы они...
[01:07:10.860 --> 01:07:27.740]  не пересекались. Ну вот, в этом и загвоздка. А, значит, как кто-нибудь, кто разобрал на семинарах, у кого разобрали эту задачу? Была? Ну и как?
[01:07:40.860 --> 01:08:01.740]  Ну давайте, чуть более формально хочу рассказать с Т-предикатами, в данном случае с Т-предикатами хочу рассказать. Решение-то правильное.
[01:08:01.740 --> 01:08:27.020]  Значит, действительно, перечисляем А и Б, и смотрим вот что. Если те элементы, которые появились на ленте перечислителя А, раньше, чем на ленте перечислителя Б, пишем во штрих, те, которые появились позже, пишем в Б штрих.
[01:08:27.020 --> 01:08:48.780]  Ну понятно, что элементы не из пересечения однозначно в какую-то из множества попадут, да? Понятно, да? Вот. А, собственно, а элементы не из пересечения, собственно, как-то между собой поделятся.
[01:08:48.780 --> 01:09:12.220]  Ну вот идея доказательства такая, да? То есть мы запускаем оба перечислителя и смотрим, что раньше появится. Если там, где раньше появилось, но если на первое раньше, чем на второй, то в А штрих пишем, если в Б штрих позже, чем на первое, то пишем в Б штрих этот элемент.
[01:09:12.220 --> 01:09:21.820]  Вот. Значит, давайте. А у вас кто? Вот у кого закончилось всё?
[01:09:21.820 --> 01:09:25.820]  Согдеева.
[01:09:25.820 --> 01:09:55.420]  Угу. Значит, давайте формальнее чуть-чуть просто. Тут есть простор, где формулы пописать. Значит, если А или Б пусто, то у нас то понятно, как разделить.
[01:09:55.420 --> 01:10:25.020]  Правда? То А штрих равно А, и Б штрих равно Б, тут без проблем, если одно из них пусто. Тогда пусть А штрих, А и Б не пусты, не пусты.
[01:10:25.020 --> 01:10:51.020]  Тогда, хотя, наверное, это не надо. Ну, в принципе, да. Тогда пусть... Сейчас, думаю, подождите, подождите.
[01:10:51.020 --> 01:11:19.020]  Тут нужно к УВФ как-то свести, собственно, сейчас. Забыл, как это сводится. А, да.
[01:11:19.020 --> 01:11:37.020]  Существует F и существует G частичные функции. Такие, что...
[01:11:37.020 --> 01:11:59.020]  Значит, Domain F равно Domain G равно B. Что теперь сделаем? Делаем вот что.
[01:11:59.020 --> 01:12:27.020]  Значит, вот рассмотрим любую УВФ у Nx. Тогда у нас, собственно, есть нумерация вычислимых функций. Есть вот вычислимые функции F и G, да, наши.
[01:12:27.020 --> 01:12:50.020]  Значит, тогда, что мы сделаем? Не знаю, как это обозначить? F штрих это номер. Это номер F в нумерации У.
[01:12:50.020 --> 01:13:03.020]  А G штрих это номер G в нумерации У. Тогда вот что.
[01:13:03.020 --> 01:13:31.020]  Тогда A штрих есть Tx, для которых такие что? Существует K, для которого Tx...
[01:13:31.020 --> 01:13:51.020]  Так, T, F штрих, x, K. То есть вычисляем F штрих. На номере F штрих, собственно, читаем. На входе x делаем K шагов. Вычисления закончились.
[01:13:51.020 --> 01:14:18.020]  То есть Domain x принадлежит Domain F штрих. Тут формула должна быть. Ну и, собственно говоря, как формально записать, что раньше появилось на перечислителе F штрих, грубо говоря, но не появилось на перечислителе G штрих.
[01:14:18.020 --> 01:14:44.020]  Ну и для любого M меньше либо равно, чем K, не T, G штрих, x, M. Вот такое вот свойство.
[01:14:44.020 --> 01:15:03.020]  Теперь B штрих. Это все x, для которых существует K, наоборот, для которого T, G штрих, x, K.
[01:15:03.020 --> 01:15:29.020]  Но для любого M в данном случае придется записать меньше, строго меньше, несимметрично немножко. Не T, F штрих, x, M.
[01:15:29.020 --> 01:15:56.020]  Вот так. Это понятно? Вот. Тут, собственно, мы еще перечислили, описали, куда пойдут элементы, которые в неформальном этом рассуждении, куда пойдут элементы,
[01:15:56.020 --> 01:16:14.020]  которые одновременно появляются на перечислителе F штрих и G штрих. Вот мы сказали, что они в А штрих пойдут. Вот формально. Что надо доказать, что A штрих перечислимо, что B штрих перечислимо,
[01:16:14.020 --> 01:16:26.020]  что их объединение совпадает с объединением AB, и что они не пересекаются. Как доказать, что A штрих перечислимо? Вот это свойство разрешимо, правда?
[01:16:26.020 --> 01:16:44.020]  Свойство тотально разрешимо. Причем даже вот эта формула тотально... Подождите, неправильно говорю. Это вот это свойство перечислимо конкретно, поскольку вот эти штуки разрешимы. Почему?
[01:16:44.020 --> 01:17:05.020]  Помните, как мы перечисляли проекции всякие? То есть мы перебирали все пары. В данном случае xk. Вычисляли F штрих xk. Так, ребята?
[01:17:05.020 --> 01:17:25.020]  То есть потом нужно будет проверить вот это свойство. Если t штрих xk оказалось верным, то есть перечисляем пары xk, считаем t F штрих xk. Если оно верно оказалось, то проверяем вот это свойство.
[01:17:25.020 --> 01:17:37.020]  Вот здесь конечное число проверок нужно сделать, поэтому это вполне вычислимо, если мы знаем, что это верно. Поняли, ребята?
[01:17:37.020 --> 01:17:47.020]  Как устроены функции fg? Fg – какие-то вычислимые функции, у которых domain равен a и domain равен b.
[01:17:47.020 --> 01:18:04.020]  Ну, не знаю, какая разница. Здесь в t предикатах значение – это неважно. Мы же само их перечислили. То есть мы по сути на domain только внимание t обращаем.
[01:18:04.020 --> 01:18:09.020]  Если бы нас интересовало значение, мы бы вот t штрих предикат использовали, не t.
[01:18:09.020 --> 01:18:22.020]  Так, вы запутались, да? Это сложно? Нет? Я просто почему? Дальше еще сложнее будет, и нам придется эти формулы писать.
[01:18:22.020 --> 01:18:31.020]  Значит, с t предикатами. Поэтому я хочу сразу вас приучить. Да, это задача можно рукомаханиями доказать.
[01:18:31.020 --> 01:18:40.020]  И вам, скорее всего, на семинарах будут так делать. Но я хочу с формулами с t предикатов это сделать, чтобы вы привыкли к ним.
[01:18:40.020 --> 01:18:50.020]  Потому что там в следующих задачах уже не обойтись без них. Нужно будет эти формулы писать, чтобы привыкали постепенно.
[01:18:50.020 --> 01:19:01.020]  То есть, смотрите, это перечислимое множество. Просто вот перечислитель описывает. Перечисляем все пары, считаем вот это.
[01:19:01.020 --> 01:19:07.020]  Если единица, то проверяем еще вот это. Если одновременно выполнено, пишем x.
[01:19:07.020 --> 01:19:18.020]  Ну и так перечисляем все пары и вот так делаем. Поняли, да? И это тоже перечислимое множество.
[01:19:18.020 --> 01:19:26.020]  Теперь, почему их объединение вместе это объединить b?
[01:19:26.020 --> 01:19:38.020]  Потому что вот этот предикат существует k, для которого f'xk верен, только если x принадлежит domain f. Согласны?
[01:19:38.020 --> 01:19:48.020]  Ну, может быть, верен. Вот это утверждение, вот эта формула существует k, f.
[01:19:48.020 --> 01:19:54.020]  Верно, только если x принадлежит domain f, то есть из a.
[01:19:54.020 --> 01:20:02.020]  А вот эта формула может быть верна только тогда, когда x принадлежит domain g, то есть b.
[01:20:02.020 --> 01:20:10.020]  Без вот этих формул это же все не истинно, правда? То есть вот здесь формула ложна, если x не из domain a.
[01:20:10.020 --> 01:20:16.020]  А здесь, если x не из domain b. Поняли?
[01:20:20.020 --> 01:20:28.020]  Не перечислители это функции. Мы их определяли в теореме как полухарактеристические.
[01:20:28.020 --> 01:20:34.020]  Помните, это единица, если x принадлежит ta и не определено иначе.
[01:20:38.020 --> 01:20:44.020]  Вот тогда это вычислимая функция, потому что у нас a перечисляем, перечисляем a.
[01:20:44.020 --> 01:20:50.020]  Если она перечислилась, то выводим единицу, если не перечислилась, то мы зациклимся и не выведем ничего.
[01:20:50.020 --> 01:20:54.020]  То есть не определено.
[01:20:54.020 --> 01:21:00.020]  Мы можем взять такие функции, полухарактеристические, например.
[01:21:00.020 --> 01:21:06.020]  Но это не перечислитель. Это, конечно, не перечислитель.
[01:21:06.020 --> 01:21:12.020]  Так, понятно сейчас? Почему они не пересекаются?
[01:21:20.020 --> 01:21:26.020]  Ну да.
[01:21:26.020 --> 01:21:30.020]  Но если они пересекутся, то что у нас получится?
[01:21:30.020 --> 01:21:46.020]  То есть есть k, для которого f' xk и для любого m' либо равно не g' xm.
[01:21:46.020 --> 01:21:52.020]  И существует l. Ну давайте просто проверим, что эти формулы несовместимы.
[01:21:52.020 --> 01:22:00.020]  То есть у нас получилось, если они пересекаются, то у нас получается на уровне формул вот такая штука.
[01:22:04.020 --> 01:22:08.020]  Конъюнкция двух формул выходит.
[01:22:08.020 --> 01:22:28.020]  Существует k, f' xk и для любого m' либо равно не g' xm.
[01:22:28.020 --> 01:22:52.020]  И существует l, такое, что t g' xl и для любого m меньше, чем l, не t f' xl.
[01:22:52.020 --> 01:22:57.020]  Правда? Если одновременно бы это выполнялось.
[01:22:57.020 --> 01:23:11.020]  Смотрите, то есть если k меньше либо равно l, то у нас что у нас будет?
[01:23:11.020 --> 01:23:22.020]  Смотрите, существует k, которое t f' xk, но для всех m строго меньше, чем l.
[01:23:22.020 --> 01:23:32.020]  Обратите внимание, не f' xm. Правда?
[01:23:32.020 --> 01:23:37.020]  Но правда, если давайте строго меньше только.
[01:23:37.020 --> 01:23:50.020]  И вот из этой части у нас получается и не t f' xk. Всё. Противоречие. Правда?
[01:23:50.020 --> 01:23:56.020]  Если k наоборот больше либо равно, чем l, то у нас получается вот что.
[01:23:56.020 --> 01:24:13.020]  Значит у нас t g' xm, t g' xl, вот.
[01:24:13.020 --> 01:24:33.020]  А отсюда у нас будет следовать, что не t g' xl, потому что для всех меньше либо равно k, значит для l в том числе. Правда?
[01:24:33.020 --> 01:24:39.020]  В любом случае противоречие, то есть которое доказывает, что они не пересекаются.
[01:24:39.020 --> 01:24:46.020]  Ну вот, собственно, вот формальное построение этих заданий, этих ашторих в виде формул.
