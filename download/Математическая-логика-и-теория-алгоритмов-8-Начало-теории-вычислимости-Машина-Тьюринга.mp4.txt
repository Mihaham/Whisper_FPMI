[00:00.000 --> 00:07.880]  Сегодня поговорим про модели вычислений.
[00:30.000 --> 00:55.000]  Мы начинаем новую большую часть курса о теории вычислимости,
[00:55.000 --> 01:03.000]  которая оправдывает слова о теориях алгоритмов в названии курса.
[01:03.000 --> 01:18.000]  Сначала поговорим про то, что вообще такое алгоритм, что такое вычисление.
[01:18.000 --> 01:25.000]  Что такое алгоритм?
[01:25.000 --> 01:30.000]  Тут есть два подхода к ответу на этот вопрос.
[01:30.000 --> 01:36.000]  Один подход стоит в том, что мы понимаем, что такое алгоритм.
[01:36.000 --> 01:44.000]  Это такое же неопределимое понятие, как множество, точка и другие понятия в математике.
[01:44.000 --> 01:48.000]  Мы не можем дать прямоопределение, а можем дать только некоторое пояснение.
[01:48.000 --> 01:53.000]  Такое словарное определение, а не математическое.
[01:53.000 --> 02:01.000]  Второй подход стоит в том, что мы вводим некоторую формальную систему,
[02:01.000 --> 02:07.000]  которая как раз некоторые формальные определения не дает,
[02:07.000 --> 02:21.000]  которая в каком-то смысле ловит какие-то ключевые вещи в неформальном понятии.
[02:21.000 --> 02:26.000]  Если мы говорим неформально, то что такое алгоритм?
[02:26.000 --> 02:32.000]  Это некоторая инструкция или процедура.
[02:32.000 --> 02:51.000]  Это инструкция по решению некоторой задачи.
[02:51.000 --> 03:16.000]  Соответственно, у алгоритма есть вход, то есть условия задачи.
[03:16.000 --> 03:29.000]  И выход. То есть то или иное решение.
[03:29.000 --> 03:45.000]  При этом и вход, и выход, и сам алгоритм как инструкция могут быть описаны некоторыми конечными строками.
[03:45.000 --> 04:11.000]  Вход, и выход, и сам алгоритм описываются конечными строками.
[04:11.000 --> 04:31.000]  Ну или как вариант можно считать, что натуральными числами это стандартный подход,
[04:31.000 --> 04:41.000]  что можно смотреть на все эти конструктивные объекты, как на строки, может как на числа.
[04:41.000 --> 04:51.000]  Смотрите, исторически первый подход это смотреть как на числа, потому что это все шло из формальной арифметики, теории Гёдали и так далее.
[04:51.000 --> 05:05.000]  Но более современный подход это смотреть как на строки из нулей единиц, потому что мы привыкли, что в компьютерной памяти все записывается битами, нольками, единичками,
[05:05.000 --> 05:10.000]  и любые данные можно так закодировать.
[05:10.000 --> 05:19.000]  Но конечно строки и числа можно взаимно однозначно друг другу декодировать, поэтому это не очень важно.
[05:19.000 --> 05:45.000]  Что еще важно? Еще важно, что любой алгоритм выполняется пошагово, то есть там время дискретно, любой алгоритм выполняется пошагово.
[05:45.000 --> 05:54.000]  В каждый момент есть некоторая конфигурация, которая также описывает с конечной строкой,
[05:54.000 --> 06:02.000]  и соответственно от текущей конфигурации к следующей переход происходит при помощи вот этой самой инструкции.
[06:15.000 --> 06:28.000]  В каждый момент, ну нельзя сказать, что там алгоритмы находятся, но исполнение алгоритма находится в некоторой конфигурации.
[06:28.000 --> 06:40.000]  В каждый момент исполнения алгоритма задана некоторая конфигурация,
[06:40.000 --> 06:52.000]  ну и соответственно переход от данной конфигурации к следующей,
[06:52.000 --> 07:17.000]  переход от данной конфигурации к следующей происходит в соответствии с инструкцией.
[07:17.000 --> 07:36.000]  Ну в общем более-менее это вот такое рамочное описание, любая конкретная модель этому всему соответствует.
[07:36.000 --> 07:44.000]  То есть есть преобразование входа в выход, да, еще важно отметить, что тут в принципе входов, тут бесконечное число,
[07:44.000 --> 07:53.000]  а при этом сама инструкция конечная. Если входов в конечное число, то это не очень интересно,
[07:53.000 --> 08:02.000]  тогда более-менее любую функцию можно описать просто таблично, но если входов в бесконечное число,
[08:02.000 --> 08:07.000]  а описание конечное, то вот это уже получается что-то интересное.
[08:07.000 --> 08:15.000]  Ну вот, значит есть преобразование входа в выход с конечным описанием,
[08:15.000 --> 08:23.000]  и вот это описание применяется как инструкция по переходу от одной конфигурации к следующей,
[08:23.000 --> 08:29.000]  и соответственно в результате конечного числа таких переходов возникает ответ.
[08:29.000 --> 08:35.000]  Вот, хорошо, значит это вот общее рамочное определение, которое годится и для всех моделей,
[08:35.000 --> 08:39.000]  и для реальных вычислительных устройств.
[08:39.000 --> 08:49.000]  Вот, значит существует, да, значит в принципе существенную часть теории можно изучать
[08:49.000 --> 08:59.000]  и вот в такой общности, то есть без конкретизации, в общем, многие вещи можно объяснить
[08:59.000 --> 09:03.000]  просто из каких-то общих соображений, либо вообще без конкретизации,
[09:03.000 --> 09:09.000]  либо имея в виду какой-то там обычный язык программирования.
[09:09.000 --> 09:33.000]  Вот, хорошо, ну а тем не менее на этой лекции я хотел бы рассказать про некоторые конкретные модели,
[09:33.000 --> 09:36.000]  ну а именно мы в основном будем работать с машиной Тьюринга,
[09:36.000 --> 09:51.000]  которая в общем-то исторически была самой первой прям такой математической моделью,
[09:51.000 --> 09:57.000]  ну и она до сих пор остается сравнительно популярным подходом.
[09:57.000 --> 10:05.000]  Значит, особенно хороша машина Тьюринга для теории сложности вычислений,
[10:05.000 --> 10:10.000]  когда нас интересует число использованных ресурсов.
[10:10.000 --> 10:17.000]  Вообще бывают и другие модели, например, рам-машина со случайным доступом к памяти,
[10:17.000 --> 10:25.000]  еще там разного рода машины с регистрами, где можно хранить целом натуральное число в некотором регистре.
[10:25.000 --> 10:31.000]  Разные другие подходы, но вот машина Тьюринга довольно хорошо сбалансирована,
[10:31.000 --> 10:39.000]  с одной стороны она достаточно простая сама по себе, с другой стороны с ней довольно удобно работать.
[10:39.000 --> 10:44.000]  Поэтому, значит, мы с ней будем работать.
[10:44.000 --> 10:54.000]  Так, значит, пока что я давайте на этом слайде нарисую неформально, что это такое.
[10:54.000 --> 11:03.000]  Значит, имеется вот лента, которая разбита на ячейке.
[11:04.000 --> 11:08.000]  И в каждой ячейке находится какой-то символ.
[11:08.000 --> 11:18.000]  Например, может быть, AB, C, AC, AB, что-нибудь такое.
[11:18.000 --> 11:29.000]  И, например, есть еще управляющий блок, который находится в каком-то состоянии Q
[11:29.000 --> 11:36.000]  и указывает на какую-то ячейку.
[11:36.000 --> 11:45.000]  Соответственно, здесь есть память, эта лента разбита на ячейке, причем эта лента бесконечная.
[11:45.000 --> 11:50.000]  Можно говорить, что она прям бесконечная, можно говорить, что потенциально бесконечная.
[11:50.000 --> 11:53.000]  Потенциально бесконечная, это означает, что если мы дошли до края,
[11:53.000 --> 11:59.000]  то можно подклеить еще кусочек и работать на этом новом кусочке.
[11:59.000 --> 12:06.000]  Вот, значит, есть что-то типа процессора, то есть управляющий блок,
[12:06.000 --> 12:10.000]  который может находиться в одном из конечного числа состояний.
[12:10.000 --> 12:18.000]  Ну и, соответственно, в каждый момент машина указывает на только одну ячейку.
[12:18.000 --> 12:27.000]  И у машины есть программа, которой команда вот такого вида.
[12:27.000 --> 12:36.000]  Например, Q, C переходят в S, A, E, R.
[12:36.000 --> 12:40.000]  Значит, если вот такая команда, то это означает, что...
[12:40.000 --> 12:47.000]  Давайте каким-то другим цветом покажу, что будет происходить на следующем этапе.
[12:47.000 --> 12:52.000]  Это означает, что вместо Q...
[12:52.000 --> 12:54.000]  Давайте я так отдельно нарисую.
[12:54.000 --> 13:00.000]  Значит, вместо Q машина оказывается в состоянии S.
[13:00.000 --> 13:09.000]  Значит, дальше вот эта вот C она заменяет на A.
[13:09.000 --> 13:15.000]  И сама сдвигается направо, то есть указывает вот на клетку прогрения.
[13:15.000 --> 13:20.000]  А после этого ей нужно искать следующую команду, там S.
[13:20.000 --> 13:23.000]  Значит, дальше будет какая-нибудь другая команда, S, A.
[13:23.000 --> 13:32.000]  Например, будет снова Q, а тут будет B, и тут будет R.
[13:32.000 --> 13:37.000]  Да, R большое, значит, направо.
[13:37.000 --> 13:44.000]  Там еще бывает L налево или N на месте, то есть нейтрально.
[13:44.000 --> 13:54.000]  Ну, значит, там либо один из двух, либо один из трех, но третий, в смысле, на месте.
[13:54.000 --> 13:58.000]  Да, на одну клетку направо.
[13:58.000 --> 14:05.000]  Тут, смотрите, тут нет того, что называется произвольный доступ,
[14:05.000 --> 14:09.000]  и что как раз активно используется в настоящих компьютерах.
[14:09.000 --> 14:20.000]  Призвольный доступ означает, что машина может получить адрес ячейки и, соответственно, пройти по этому адресу.
[14:20.000 --> 14:29.000]  Считать данные, расположенные по этому адресу.
[14:29.000 --> 14:34.000]  Тут такого нету.
[14:34.000 --> 14:41.000]  Тут, чтобы куда-то дойти, нужно делать по одному шагу, пока не дойдем до того места, куда нужно прийти.
[14:41.000 --> 14:47.000]  Но, тем не менее, рано или поздно дойти можно.
[14:47.000 --> 14:56.000]  Можно все это как-то взять и посчитать.
[14:56.000 --> 14:59.000]  Так, хорошо.
[14:59.000 --> 15:04.000]  Ну, теперь давайте я покажу, что такое формально.
[15:04.000 --> 15:17.000]  Так, формальное определение машины тюринга.
[15:17.000 --> 15:25.000]  Во-первых, определение немножко зависит от того, для какой задачи мы это используем.
[15:25.000 --> 15:36.000]  Например, пусть у нас задача то, что называется распознавание или разрешение языка.
[15:36.000 --> 15:41.000]  Задача распознавания языка.
[15:41.000 --> 15:44.000]  То есть ответ да или нет.
[15:44.000 --> 16:11.000]  Здесь получается, что вход некоторый х, а выход это один, если х принадлежит а, и ноль, если х не принадлежит а.
[16:11.000 --> 16:16.000]  Тут важно, что ответ это один или ноль.
[16:16.000 --> 16:27.000]  Получается, что есть всего два варианта, и можно эти варианты прямо записать в состояние.
[16:27.000 --> 16:32.000]  Еще вопрос, откуда это а.
[16:32.000 --> 16:37.000]  Давайте считать, что у нас есть какой-то алфавит, сигма.
[16:37.000 --> 16:42.000]  Например, сигма может быть из нуля единицы, может быть какой-то другой алфавит.
[16:42.000 --> 16:49.000]  И, соответственно, вот это вот а, это под множество всех слов в этом алфавите.
[16:49.000 --> 16:58.000]  А тут, соответственно, х тоже в том же самом алфавите записан.
[16:58.000 --> 17:05.000]  Хорошо, начну тогда. Машина тюринга.
[17:05.000 --> 17:11.000]  Машина тюринга это кортеж.
[17:11.000 --> 17:17.000]  Кортеж из большого количества разных вещей.
[17:17.000 --> 17:22.000]  Во-первых, тут есть сигма, и это сигма то же самое, что вот этот.
[17:22.000 --> 17:41.000]  Сигма, гамма, q, дальше q0, qa, qr и дельта.
[17:41.000 --> 17:46.000]  Сейчас расскажу, что все это такое.
[17:46.000 --> 17:52.000]  Сигма мы уже изучили. Сигма называется входной алфавит.
[17:52.000 --> 17:59.000]  Сигма это входной алфавит.
[17:59.000 --> 18:06.000]  То есть символами этого алфавита записывают все, что на вход подается.
[18:06.000 --> 18:20.000]  В нем, соответственно, записан вход алгоритма.
[18:20.000 --> 18:35.000]  Дальше гамма. Гамма это ленточный алфавит.
[18:35.000 --> 18:47.000]  Тут есть лента, но тут как минимум есть такие пустые ячейки.
[18:47.000 --> 18:53.000]  И вообще, раз лента бесконечная, там должна быть только конечная информация.
[18:53.000 --> 18:57.000]  Соответственно, все, кроме ограниченной части, должно быть занято пустотой.
[18:57.000 --> 19:01.000]  Ну и проще всего считать, что это такой специальный символ.
[19:01.000 --> 19:13.000]  Он называется бланк или правильный символ, которым и занята вся лента, кроме конечного числа ячей, где-то, собственно, какая-то информация.
[19:13.000 --> 19:26.000]  Ленточный алфавит, соответственно, предполагается, что он включает в себя сигма, но при этом строго включает в себя.
[19:26.000 --> 19:32.000]  Например, есть специальный символ бланк. Он, например, вот так обозначается.
[19:32.000 --> 19:37.000]  Но эта решетка, это похоже на пустую клетку. Это мотивируется такое обозначение.
[19:37.000 --> 19:44.000]  А бывает по-другому. Может быть там буква Б какая-нибудь специальная, может быть там какое-нибудь подчеркивание.
[19:44.000 --> 19:55.000]  Разно есть обозначения. Соответственно, вот этот бланк будет лежать в гамма без сигма, но, возможно, там какие-то другие еще есть.
[19:55.000 --> 20:01.000]  То есть тут не ограничивается. Вот эти могут быть какие-то другие вспомогательные символы.
[20:01.000 --> 20:07.000]  Ну, например, можно считать, что там буквы разного цвета, что мы как-то там помечаем.
[20:07.000 --> 20:14.000]  Или там буквы со звездочкой, какие-то пометки мы делаем. Или просто какие-то совсем новые символы, зачем-то нужные.
[20:14.000 --> 20:23.000]  Это скорее для удобства. То есть, в принципе, можно считать, что сигма это 0 и 1, а гамма это 0 и 1 и пробел.
[20:24.000 --> 20:25.000]  Да.
[20:33.000 --> 20:40.000]  Нет, лямбда это пустое слово обычно обозначает. Пустосил? Нет, я сказал, есть там буква Б, есть просто подчеркивание.
[20:40.000 --> 20:43.000]  А вот лямбда или епсилон это пустое слово.
[20:45.000 --> 20:51.000]  Вот, дальше Q. Q это множество состояний, просто какое-то конечное множество.
[20:53.000 --> 20:59.000]  Q это множество внутренних состояний.
[21:04.000 --> 21:10.000]  Значит, множество внутренних состояний, но обязательно конечное. Собственная алфавита тоже обязательно конечная.
[21:10.000 --> 21:23.000]  Вот, значит, теперь Q0, Qa и Qr.
[21:23.000 --> 21:39.000]  Сейчас давайте-ка, знаете что, я лучше сделаю это не Q0, а Q1. Так удобнее.
[21:40.000 --> 21:43.000]  Значит, пусть это будет Q1.
[21:47.000 --> 21:50.000]  Вот, а Q0-то будет другое состояние.
[21:51.000 --> 21:56.000]  Так, хорошо. Значит, Q1, Qa, Qr это просто элементы Q. Различные.
[21:56.000 --> 22:08.000]  Значит, Q1, Qa, Qr это элементы Q.
[22:09.000 --> 22:13.000]  Конечно, Q1 это начальное состояние.
[22:17.000 --> 22:21.000]  Значит, Qa это принимающее состояние.
[22:26.000 --> 22:29.000]  И Qr это отвергающее состояние.
[22:29.000 --> 22:38.000]  Ну, то есть, иными словами, A это accept, R это reject.
[22:38.000 --> 22:48.000]  Соответственно, вот эти вот принимающие отвергающее состояние завершают работы машины и, собственно, дают ответ.
[22:48.000 --> 22:58.000]  Значит, получается, что они дают ответ.
[22:58.000 --> 23:07.000]  Ну, и еще бывает вариант. Другой вариант, что есть одно завершающее состояние, а ответ каким-то образом берется с ленты.
[23:07.000 --> 23:15.000]  Другим цветом напишу. Другой вариант.
[23:18.000 --> 23:30.000]  Другой вариант. То есть, одно завершающее состояние Q0.
[23:30.000 --> 23:40.000]  Ну и, соответственно, ответ записывается на ленте.
[23:40.000 --> 23:50.000]  Значит, ответ записывается на ленте.
[24:01.000 --> 24:11.000]  Ну и дельта. Дельта самая интересная. Дельта это функция перехода.
[24:16.000 --> 24:19.000]  Дельта функции перехода.
[24:19.000 --> 24:33.000]  Соответственно, она отображает, читайте так, Q без Qa и Qr.
[24:33.000 --> 24:45.000]  На, соответственно, леночный алфавит гамма, и тут, соответственно, Q на гамма и на сдвиг.
[24:45.000 --> 24:51.000]  Налево, на месте или направо.
[24:51.000 --> 24:57.000]  То есть, получается, что функция перехода получает состояние, но не конечное состояние.
[24:57.000 --> 25:01.000]  Если конечное состояние, то уже дальше никаких изменений не происходит.
[25:01.000 --> 25:06.000]  Значит, дельта получает состояние, получает символ.
[25:06.000 --> 25:13.000]  И дальше, соответственно, возвращает тоже еще одно состояние, еще один символ.
[25:13.000 --> 25:19.000]  И один из трех сдвигов. Налево, на месте или направо.
[25:19.000 --> 25:29.000]  Ну вот, также дельту могут называть программой машины тюринга.
[25:39.000 --> 25:47.000]  Ну а тогда, соответственно, отдельные значения этой дельты называть командами.
[25:47.000 --> 25:57.000]  Вот. Хорошо.
[25:57.000 --> 26:03.000]  Ну дальше, как устроена работа машины тюринга.
[26:03.000 --> 26:11.000]  Дальше, соответственно, в начальный момент вычисления.
[26:11.000 --> 26:22.000]  Начальный момент вычисления.
[26:22.000 --> 26:32.000]  Значит, на ленте записан вход X.
[26:32.000 --> 26:53.000]  Вот, соответственно, машина находится в состоянии Q1 и указывает на первый бит X.
[26:53.000 --> 26:57.000]  Ну и тут нужна оговорка, что вообще-то вход может быть даже и пустой.
[26:57.000 --> 27:02.000]  Да, пустая строка это тоже возможный вход, тогда у нее нет первого бита.
[27:02.000 --> 27:12.000]  Ну тогда просто вся лента на входе пустая, ну и машина там куда-то указывает.
[27:12.000 --> 27:24.000]  Вот. Ну, после этого происходят перемены в соответствии с программой.
[27:24.000 --> 27:49.000]  На каждом шаге машина заменяет символ, на который указывает.
[27:49.000 --> 28:08.000]  На который указывает в соответствии с программой.
[28:08.000 --> 28:18.000]  Значит, она заменяет символ в соответствии с программой.
[28:18.000 --> 28:23.000]  Вот.
[28:23.000 --> 28:39.000]  Меняет состояние, переходит в новое состояние и сдвигается.
[28:39.000 --> 28:44.000]  И все эти три вещи в соответствии с программой.
[28:44.000 --> 28:49.000]  В соответствии с тем, в каком машине было состояние и на какой символ она указывала.
[28:49.000 --> 28:58.000]  Ну и в итоге, если машина приходит в завершающее состояние,
[28:58.000 --> 29:18.000]  если машина приходит в QA или QR, то вычисление завершается.
[29:18.000 --> 29:29.000]  Значит, вычисление завершается с соответствующим ответом.
[29:29.000 --> 29:35.000]  Но очень важно, что может быть и бесконечное вычисление.
[29:35.000 --> 29:41.000]  То есть может машина никуда не прийти, никогда не остановиться.
[29:41.000 --> 29:54.000]  Значит, может быть и бесконечное вычисление.
[29:54.000 --> 29:58.000]  Причем бесконечное вычисление может быть по самым разным причинам.
[29:58.000 --> 30:07.000]  Может быть, потому что машина зациклилась.
[30:07.000 --> 30:26.000]  Например, из-за зацикливания, но не только.
[30:26.000 --> 30:31.000]  Ну понятно, что такое бесконечный цикл, я думаю, все более-менее понимают.
[30:31.000 --> 30:43.000]  Например, если машина будет бесконечно инкрементировать клейный счетчик,
[30:43.000 --> 30:47.000]  если такой идеальный счетчик, который без ограничения на память,
[30:47.000 --> 30:54.000]  то это будет бесконечный процесс, не зацикливающийся, но бесконечный.
[30:54.000 --> 31:00.000]  Но могут быть и еще какие-нибудь даже более сложные вещи,
[31:00.000 --> 31:06.000]  например, связанные с какой-нибудь математикой.
[31:06.000 --> 31:19.000]  Например, никто не знает, есть ли нечетное совершенное число.
[31:19.000 --> 31:22.000]  Знаете про совершенные числа?
[31:22.000 --> 31:29.000]  Совершенные числа это такие числа, которые равны сумме всех своих делителей, кроме самого себя.
[31:29.000 --> 31:40.000]  Есть число 6, у него делители 3, 2 и 1.
[31:40.000 --> 31:48.000]  Есть число 28, это 4 плюс 7 плюс 4 плюс 2 плюс 1.
[31:48.000 --> 31:51.000]  Следующие уже 496.
[31:51.000 --> 31:58.000]  В общем, этих чисел известно какое-то конечное количество,
[31:58.000 --> 32:04.000]  не известно их всего конечное количество или бесконечное количество,
[32:04.000 --> 32:08.000]  и также не известно ни одного нечетного совершенного числа.
[32:08.000 --> 32:20.000]  Неизвестно нечетного совершенного числа, но также нет теоремы о том, что его нет.
[32:20.000 --> 32:23.000]  В общем, это открытый вопрос.
[32:23.000 --> 32:27.000]  Но смотрите, можно писать программу, которая будет идти по всем нечетным числам,
[32:27.000 --> 32:35.000]  раскладывать их на простые множители, искать все делители и проверять, будут они совершенными или нет.
[32:35.000 --> 32:40.000]  Например, если aye найдет совершенно нечетное число, то оно остановится.
[32:40.000 --> 32:48.000]  Но тогда получается, что мы вообще не знаем, остановится такая программа или нет.
[32:48.000 --> 32:56.000]  Если она остановится, значит нечетное совершенно число есть, если не остановится, значит нету.
[32:56.000 --> 33:03.000]  Но также ясно, что если оно не остановится, то не то, чтобы там был какой-то регулярный процесс.
[33:03.000 --> 33:09.000]  Ну, он, конечно, в каком-то смысле регулярный, но не то, что там все повторяется,
[33:09.000 --> 33:15.000]  а там какие-то сложные вещи с разложением на множество и так далее.
[33:15.000 --> 33:26.000]  Поэтому вывод, который я хочу сейчас сделать, что вопрос об установке важен,
[33:26.000 --> 33:34.000]  и также важен не только внутри теории вычислений, но и вообще во всей математике.
[33:34.000 --> 33:43.000]  Так, ладно, сейчас сделаем перерыв, потом немножко еще поговорим формально,
[33:43.000 --> 33:47.000]  что все это вот значит, что такое вычисление.
[33:47.000 --> 33:57.000]  Давайте продолжим. Да, перерывы задавали разные вопросы.
[33:57.000 --> 34:03.000]  На самом деле эта проблема установки – это очень интригующая вещь.
[34:03.000 --> 34:08.000]  С одной стороны, она связана со многими такими открытыми вопросами.
[34:08.000 --> 34:14.000]  Если вообще какая-то задача стоит в том, что нужно найти пример или контрпример чего-нибудь
[34:14.000 --> 34:23.000]  про конечные объекты, типа числа, графы и так далее, то тогда, конечно, можно написать программу,
[34:23.000 --> 34:28.000]  которая будет перебирать все такие объекты и пытаться найти пример или контрпример.
[34:28.000 --> 34:39.000]  И, соответственно, исходный вопрос будет эквивалентен тому, остановится эта программа или нет.
[34:40.000 --> 34:44.000]  И таких задач очень много на самом деле.
[34:51.000 --> 34:57.000]  Ну, соответственно, возникает вопрос, а нельзя ли научиться решать проблемы остановки
[34:57.000 --> 35:02.000]  и с помощью нее решить все остальные проблемы.
[35:02.000 --> 35:07.000]  Но вот нет, к сожалению, так не получается, и мы это, собственно, изучим.
[35:07.000 --> 35:16.000]  Мы прямо изучим, что нет. По крайней мере алгоритмически сама по себе проблема остановки неразрешима.
[35:16.000 --> 35:21.000]  То есть нельзя написать программу, которая будет получать текст другой программы
[35:21.000 --> 35:29.000]  и вход этой другой программы, и, соответственно, говорить, остановится эта программа на этом входе или нет.
[35:29.000 --> 35:33.000]  Это вот ключевой результат, который мы подойдем, наверное, через пару лекций.
[35:36.000 --> 35:47.000]  И более того, можно и ряд более конкретных задач, уже не связанных с машинами тюринга
[35:47.000 --> 35:54.000]  и с программами, а связанных с группами или многочленами или чем-нибудь еще,
[35:54.000 --> 36:02.000]  много таких задач, для многих задач можно показать, что они тоже неразрешимы,
[36:02.000 --> 36:06.000]  иначе можно было бы проблемы остановки разрешить.
[36:06.000 --> 36:10.000]  Но тот, наверное, самый известный пример – это диафантовое уравнение.
[36:10.000 --> 36:14.000]  Это была проблема Гильберта, только я не помню, какая по номеру.
[36:14.000 --> 36:17.000]  Проблема была такая, дана система диафантовых уравнений,
[36:17.000 --> 36:22.000]  то есть алгебридических уравнений с целыми коэффициентами.
[36:22.000 --> 36:28.000]  И вопрос стоит в том, есть ли у этой системы уравнений целочистое решение.
[36:28.000 --> 36:35.000]  И оказывается, что если там хотя бы квадратичные уравнения будут,
[36:35.000 --> 36:38.000]  то эта задача неразрешима алгебридически.
[36:38.000 --> 36:42.000]  Вообще Гильберт не так ее ставил.
[36:42.000 --> 36:49.000]  Гильберт ставил задачу, что надо научиться решать,
[36:49.000 --> 36:54.000]  что дана система диафантовых уравнений, надо научиться решать,
[36:54.000 --> 36:57.000]  находить все решения или понимать, что их нет.
[36:57.000 --> 37:04.000]  Но оказалось, это Матисеевич доказал, когда-то в 60-х или 70-х годах.
[37:04.000 --> 37:12.000]  Матисеевич доказал, что нельзя так вообще сделать,
[37:12.000 --> 37:16.000]  что это алгоритмически неразрешимая задача,
[37:16.000 --> 37:20.000]  и не может быть алгоритм, который будет искать все решения.
[37:20.000 --> 37:26.000]  Ну и вот есть ряд других задач в разных конкретных предметных областях.
[37:26.000 --> 37:32.000]  До этого я уже не знаю, дойдем мы или нет.
[37:32.000 --> 37:41.000]  Так, хорошо, теперь немножко подробнее про механику работы машины тьюринга.
[37:41.000 --> 37:46.000]  Смотрите, из чего стоит вообще конфигурация.
[37:46.000 --> 37:53.000]  Конфигурация машины тьюринга.
[37:53.000 --> 38:00.000]  Это содержимые ленты,
[38:00.000 --> 38:10.000]  плюс внутреннее состояние и плюс положение указателя.
[38:19.000 --> 38:26.000]  При этом вообще у нас лента бесконечная, но там только конечное число непробельных символов,
[38:26.000 --> 38:32.000]  поэтому все это вместе будет конечным объектом.
[38:32.000 --> 38:36.000]  Да, в принципе, конечно, указатель может быть и на пустом символе,
[38:36.000 --> 38:44.000]  который как бы за пределами этой части, но все равно мы добавим пустую часть.
[38:44.000 --> 39:07.000]  Так, хорошо, получается, есть лента, есть какая-то ячейка, есть какой-то символ.
[39:07.000 --> 39:14.000]  На эту ячейку указывает головка, она находится в состоянии Q.
[39:14.000 --> 39:22.000]  Ну и есть какое-то слово A и какое-то слово B.
[39:22.000 --> 39:26.000]  Значит, A слева от выделенной ячейки, B справа от выделенной ячейки.
[39:26.000 --> 39:34.000]  Кстати, я вот тут вот раньше, знаете, я на несколько слайдов назад это иду.
[39:34.000 --> 39:42.000]  Давайте я напишу, чтобы мы различали, что Q не пересекается с гамма.
[39:42.000 --> 39:48.000]  То есть про каждый символ мы понимаем, то ли это символ ленточного алфавита, то ли это состояние.
[39:48.000 --> 40:04.000]  Тогда мы их можем подряд записывать и понимать, что где.
[40:04.000 --> 40:22.000]  Соответственно, вот такую вот конфигурацию мы кодируем строкой AQAB.
[40:22.000 --> 40:34.000]  Ну теперь, в зависимости от команд машины, можно просто описать, как будет меняться конфигурация.
[40:34.000 --> 40:40.000]  Да, вот это вот однозначно расшифровывается, ровно потому, что состояние и символ – это разные объекты.
[40:40.000 --> 40:47.000]  Поэтому, если есть строка, в которой ровно один символ состояния, все остальные символы из леночного алфавита,
[40:47.000 --> 40:55.000]  то эта строка однозначно декодируется в такую конфигурацию.
[40:55.000 --> 41:18.000]  Так, изменения конфигурации при разных командах.
[41:18.000 --> 41:28.000]  Ну значит, смотрите, самое простое – это когда у нас команда QA переходит в S, B и на месте.
[41:28.000 --> 41:32.000]  Вот такая вот команда. Это я так записываю.
[41:32.000 --> 41:39.000]  Можно написать, что функция дельта от значений Q и A равняется тройке S, B и N.
[41:39.000 --> 41:45.000]  Коротко можно вот так через стрелочку написать.
[41:45.000 --> 41:56.000]  Значит, тогда будет просто QAB переходит в ASBB.
[41:56.000 --> 42:06.000]  То есть тут, соответственно, префикс и суффикс никак не меняются, меняется только то, куда мы указываем.
[42:06.000 --> 42:11.000]  Ну хорошо, пусть сдвиг направо.
[42:11.000 --> 42:15.000]  Например, R, C и R.
[42:15.000 --> 42:20.000]  Новое состояние R, новый символ C и сдвиг направо.
[42:20.000 --> 42:27.000]  Ну тогда тут есть разные варианты в зависимости от того, B пустой или не пустой.
[42:27.000 --> 42:32.000]  Значит, если B не пустое, то у него там есть какой-то первый символ.
[42:32.000 --> 42:53.000]  Например, AQABB', значит, переходит в ACRBB'.
[42:53.000 --> 43:02.000]  Ну это похоже на то, что я в самом начале рисовал. У меня A заменилось на C, но при этом указатель сдвинулся на B.
[43:02.000 --> 43:08.000]  Поэтому это C записано как-то слева от состояния, потом состояние, потом B, которое подним.
[43:08.000 --> 43:17.000]  А если B пустое, то тогда вот так вот просто.
[43:17.000 --> 43:22.000]  Ну на самом деле, можно считать, что не пустое, а там есть пустой символ пробеленный.
[43:22.000 --> 43:32.000]  Тогда будет ACRBB'.
[43:32.000 --> 43:47.000]  Ну и аналогично, если тут какое-нибудь состояние T, D и L,
[43:47.000 --> 43:54.000]  то тут, аналогично, если A не пустое, то тут будет какой-то A',
[43:54.000 --> 44:17.000]  значит, A'Z, тут будет QAB, значит, это превращается в A'TZDB.
[44:17.000 --> 44:23.000]  Ну я тут считаю, что кое расстоит от состояния, все остальное это символы.
[44:23.000 --> 44:29.000]  Значит, что здесь произошло? Здесь A заменилось на D, вот оно здесь D,
[44:29.000 --> 44:35.000]  но потом мы сдвинулись налево, поэтому теперь на Z указываем, и еще перешли в состояние T.
[44:35.000 --> 44:50.000]  Значит, поэтому вот так вот. Ну а если A было пустым, то просто QAB переходит в T'DB.
[44:50.000 --> 45:06.000]  Ну вот, соответственно, получаются вот такие строковые операции. То есть то, что делает машина тюринга,
[45:06.000 --> 45:15.000]  это вот такая вот, в общем-то не сложная строковая операция, довольно локальные замены одних символов на других,
[45:15.000 --> 45:25.000]  может быть, транспозиция небольшая. Это тоже очень важная концепция, что на самом деле вычисления происходят локально.
[45:25.000 --> 45:32.000]  В каждый конкретный момент изменения, это и про обычные компьютеры, верно?
[45:32.000 --> 45:37.000]  В каждый конкретный момент изменения происходят в какой-то небольшой части.
[45:37.000 --> 45:43.000]  Но все в целом так организовано, что возникает какое-то вот такое сложное вычисление.
[45:43.000 --> 45:50.000]  Да, может быть, то, что называется там многоядерный процессор, тогда действительно может быть несколько мест,
[45:50.000 --> 46:01.000]  где одновременно происходит вычисление, но все равно, значит, все равно каждое ядро, оно как бы в каждый момент работает с небольшим участком памяти.
[46:01.000 --> 46:07.000]  По крайней мере, принципиально это должно быть верно.
[46:07.000 --> 46:16.000]  Да, ну и возможно это есть некоторое отличие с тем, как человеческий мозг работает,
[46:16.000 --> 46:24.000]  потому что там тоже, в принципе, есть разные измерения активности, что при одних активностях одни области мозга работают,
[46:24.000 --> 46:31.000]  при других другие, но все равно в целом много разных процессов параллельно происходят.
[46:31.000 --> 46:38.000]  Не то, что где-то в одном месте только какие-то нейроники что-то изменяют.
[46:38.000 --> 46:49.000]  В принципе, мы утыкаемся в философскую дискуссию про то, является ли мышление вычислением.
[46:49.000 --> 46:56.000]  Да, этой дискуссии уже там 400 лет, это еще либнец в таком духе рассуждал, но в общем,
[46:56.000 --> 47:03.000]  окончательного ответа нет, и разные ученые сейчас думают по-разному.
[47:03.000 --> 47:11.000]  Вот, хорошо.
[47:11.000 --> 47:24.000]  Так, ну тогда можно сказать, можно закончить формальное определение, можно сказать, что такое вычисление.
[47:24.000 --> 47:36.000]  Значит, вычисление – это цепочка конфигураций.
[47:40.000 --> 47:45.000]  Значит, вычисление – это цепочка конфигураций.
[47:45.000 --> 48:02.000]  Значит, такая что для любых двух соседних,
[48:02.000 --> 48:20.000]  переход осуществляется в соответствии с программой.
[48:20.000 --> 48:38.000]  Да, то есть вот как раз по этим правилам, как раз для любых двух соседних вычислений происходит переход.
[48:38.000 --> 48:48.000]  Так, ну хорошо.
[48:48.000 --> 49:01.000]  Значит, дальше можно сказать, что означает, что машина распознает язык или разрешает язык.
[49:01.000 --> 49:16.000]  Значит, машина разрешает или распознает язык А.
[49:16.000 --> 49:39.000]  Значит, верно следующее, для любого х, принадлежащего А, существует вычисление,
[49:39.000 --> 49:46.000]  значит, начинающиеся с Q1х.
[49:46.000 --> 49:49.000]  Это как раз начальник конфигурации, как мы ее описывали.
[49:49.000 --> 49:57.000]  Да, записано только х. Машина в состоянии Q1 указывает на первый символ х.
[49:57.000 --> 50:15.000]  Значит, начинающиеся с Q1х и, соответственно, заканчивающиеся в конфигурации, содержащие QA.
[50:15.000 --> 50:33.000]  Ну а для любого х неиза, будет все в общем то же самое, только тут будет QR.
[50:33.000 --> 50:36.000]  Ну да, а у нас есть стигма со звездочкой.
[50:36.000 --> 50:45.000]  Ну как правило, можно считать, что это нольки и единички, можно считать, что натуральные числа.
[50:45.000 --> 50:50.000]  И вот это называется разрешимый язык или разрешимое множество.
[50:50.000 --> 50:57.000]  Слово язык тут тоже по историческим причинам употребляется просто как синоним слова множество.
[50:57.000 --> 51:11.000]  Просто когда эта вся наука бурно развивалась в 50-х годах, то ей много занимались с прицелом на лингвистические приложения.
[51:11.000 --> 51:22.000]  Тогда думали, что можно довольно легко создать компьютерный переводчик, хотя бы в итоге оказалось, что это существенно более сложная задача.
[51:22.000 --> 51:32.000]  Да, но вот рассуждали в терминах языков, поэтому часто говорят про разрешимые языки, но могут говорить и про разрешимые множества.
[51:32.000 --> 51:38.000]  В общем, термины взаимозаменяемые у нас будут.
[51:38.000 --> 51:53.000]  Ну и также очень важно определить, что такое вычислимая функция.
[51:53.000 --> 52:11.000]  Что означает, что машина вычисляет частично определенную функцию.
[52:11.000 --> 52:27.000]  Значит, f из 0,1 со звездочкой... ой, давайте из sigma со звездочкой.
[52:27.000 --> 52:39.000]  Так, из sigma со звездочкой в sigma со звездочкой.
[52:39.000 --> 52:43.000]  Так, верно следующее.
[52:43.000 --> 52:53.000]  Для любого x, во-первых, если f от x определено...
[52:53.000 --> 52:57.000]  Что такое частично определенная функция?
[52:57.000 --> 53:02.000]  Это означает, что она либо определена и равна чему-то, либо не определена.
[53:02.000 --> 53:14.000]  Значит, для любого x, если f от x определено, то тогда существует вычисление,
[53:14.000 --> 53:40.000]  значит, переходящее из конфигурации q1x в конфигурацию q0 f от x.
[53:40.000 --> 53:56.000]  Ну и важно следующее. Если f от x не определено,
[53:56.000 --> 54:04.000]  то тогда должно быть бесконечное вычисление, начинающееся с q1x.
[54:05.000 --> 54:23.000]  Значит, тогда существует бесконечное вычисление, начинающееся с q1x.
[54:23.000 --> 54:33.000]  То есть, ну иными словами можно сказать так, что программа начинает на входе x работать,
[54:33.000 --> 54:38.000]  если f от x определено, то программа останавливается и возвращает f от x,
[54:38.000 --> 54:42.000]  а если f от x не определено, то программа не останавливается.
[54:42.000 --> 54:46.000]  Значит, вот это тоже самое, но немножко более формально записано,
[54:46.000 --> 54:52.000]  как свойство некоторых кортежей, последовательств и так далее.
[54:52.000 --> 55:11.000]  Надо дать, я неформально тоже расскажу, значит, что если f от x определено,
[55:11.000 --> 55:34.000]  то тогда машина на входе x возвращает f от x, да, значит, если f от x не определено,
[55:34.000 --> 55:43.000]  то тогда машина на входе x не останавливается.
[55:43.000 --> 55:48.000]  Вот, и это очень важно, что именно так, да, потому что можно было бы определить по-другому,
[55:48.000 --> 55:52.000]  что если функция определена, то тогда машина возвращает f от x,
[55:52.000 --> 55:56.000]  а если функция не определена, то машина сообщает, что функция не определена,
[55:56.000 --> 56:00.000]  возвращает там какой-нибудь специальный символ неопределенности.
[56:00.000 --> 56:09.000]  И это будет другое определение, не эквивалентное, и в общем там теория
[56:09.000 --> 56:15.000]  с таким определением похуже получается, да, и это на самом не то, что мы хотим.
[56:15.000 --> 56:19.000]  Чтобы получилась правильная теория, нужно именно такое определение давать.
[56:19.000 --> 56:34.000]  Так, ну хорошо.
[56:34.000 --> 56:40.000]  Так, теперь что я еще хочу сказать именно про модели.
[56:40.000 --> 56:44.000]  Значит, вот это вот, да, значит, важное определение, разрешимое множество,
[56:44.000 --> 56:49.000]  значимые функции, то, с чем мы будем плотно работать на следующих лекциях.
[56:49.000 --> 56:54.000]  Вот, а сегодня я еще хотел бы немножко сказать про модели.
[56:54.000 --> 57:01.000]  Значит, мы на самом деле делали довольно произвольный выбор.
[57:01.000 --> 57:08.000]  Когда мы давали определение, то мы много довольно произвольных вещей выбрали,
[57:08.000 --> 57:14.000]  например, ну вот мы сказали, что асфальт произвольный,
[57:14.000 --> 57:18.000]  а можно было бы сделать какой-нибудь фиксированный, например, бинарный.
[57:18.000 --> 57:23.000]  Мы сказали, что лента бесконечная обе стороны, а можно было бы,
[57:23.000 --> 57:27.000]  что она была бесконечная в одну сторону, или наоборот, была бы не лента,
[57:27.000 --> 57:32.000]  а целая кратиклечистая плоскость или несколько лент.
[57:32.000 --> 57:38.000]  Вот, у нас двиги налево, направо и на месте, а можно было бы только налево или направо,
[57:38.000 --> 57:42.000]  а можно было бы, наоборот, разрешать какие-нибудь прыжки.
[57:42.000 --> 57:47.000]  Делается команда, что перепрыгнуть настолько-то шагов в такую-то сторону,
[57:47.000 --> 57:52.000]  может быть, даже на произвольное число шагов там можно записывать.
[57:52.000 --> 57:57.000]  Ну и так далее, значит, и так далее.
[57:57.000 --> 58:01.000]  Вот машина Тьюринг – это очень устойчивое определение,
[58:01.000 --> 58:06.000]  то есть для очень большого числа вот таких вот вариаций будет то же самое.
[58:06.000 --> 58:11.000]  Ну, конечно, не для всех. Не для всех, например, если разрешить только
[58:11.000 --> 58:15.000]  на месте или направо сдвигаться, то это будет уже не то же самое,
[58:15.000 --> 58:21.000]  будет более слабая модель. Но, например, если запретить на месте,
[58:22.000 --> 58:27.000]  то тогда это будет то же самое.
[58:27.000 --> 58:39.000]  Ну вот, значит, получается, что класс разрешимых языков или разрешимых множеств
[58:40.000 --> 58:48.000]  или вычислимых функций, получается, одним и тем же
[58:58.000 --> 59:04.000]  для огромного числа различных моделей.
[59:04.000 --> 59:14.000]  Значит, для самых разных вариаций машины Тьюринга
[59:21.000 --> 59:27.000]  и других вычислительных моделей.
[59:27.000 --> 59:33.000]  Значит, этот эффект суммируется таким утверждением,
[59:33.000 --> 59:39.000]  что называется тезис Чорча. Ну и тезис Чорча Тьюринга он часто называет.
[59:39.000 --> 59:48.000]  Значит, тезис Чорча Тьюринга.
[59:48.000 --> 59:53.000]  Почему такое странное слово тезис?
[59:53.000 --> 59:59.000]  Почему там не теорема, там не аксиома?
[59:59.000 --> 01:00:05.000]  Но суть в том, что это вообще не математическое утверждение,
[01:00:05.000 --> 01:00:11.000]  это утверждение об окружающем мире.
[01:00:11.000 --> 01:00:21.000]  И утверждение такое, что любая функция, которую можно вычислить,
[01:00:21.000 --> 01:00:37.000]  можно вычислить на реальном вычислительном устройстве,
[01:00:37.000 --> 01:00:47.000]  можно вычислить и на машине Тьюринга.
[01:00:47.000 --> 01:00:57.000]  Можно вычислить и на машине Тьюринга.
[01:00:57.000 --> 01:01:07.000]  Сам Чорч такой же тезис не для машины Тьюринга выдвигал,
[01:01:07.000 --> 01:01:13.000]  а для своей собственной модели общерекурсивных функций.
[01:01:13.000 --> 01:01:17.000]  В отличие от машины Тьюринга эта модель сейчас представляет
[01:01:17.000 --> 01:01:23.000]  исторический интерес, напрямую мало где применяется.
[01:01:23.000 --> 01:01:29.000]  А вот приведение к машине Тьюринга он стал довольно известен, популярен.
[01:01:29.000 --> 01:01:33.000]  Ну и даже есть такое понятие Тьюринг полные языки программирования.
[01:01:33.000 --> 01:01:39.000]  Это, собственно, кивчатинские модели, для которых вот этот тезис верен.
[01:01:39.000 --> 01:01:49.000]  Разумеется, все стандартные языки обладает вот этой самой Тьюринг-полнотой.
[01:01:49.000 --> 01:02:05.000]  Тьюринг-полнота означает, что вы на языке можете запрограммировать любую функцию вычислимую.
[01:02:05.000 --> 01:02:11.000]  Ну в частности, если вы на языке можете запрограммировать машину Тьюринга,
[01:02:11.000 --> 01:02:17.000]  то значит вы и как следствие любую другую функцию тоже можете запрограммировать.
[01:02:17.000 --> 01:02:23.000]  Потому что вы можете запрограммировать ту машину Тьюринг, которая вычисляет данную функцию.
[01:02:27.000 --> 01:02:33.000]  Но, соответственно, если есть какая-то конкретная вариация, то этот тезис становится теоремой.
[01:02:33.000 --> 01:02:39.000]  Ну, например, давайте, это больше для семинаров тема, дайте какой-нибудь простой пример.
[01:02:39.000 --> 01:02:45.000]  Да, например, почему можно не стоять на месте.
[01:02:45.000 --> 01:03:05.000]  Значит, пример, если сдвиги только L и R, то получится эквивалентно.
[01:03:05.000 --> 01:03:09.000]  Очень просто, если нужно стоять на месте, а вы не можете стоять на месте,
[01:03:09.000 --> 01:03:13.000]  но нужно сделать шаг налево, потом шаг направо.
[01:03:13.000 --> 01:03:29.000]  То есть если есть старая программа, в которой была команда QA,
[01:03:29.000 --> 01:03:49.000]  превращается в R, B и на месте, то в новой программе будет две команды.
[01:03:49.000 --> 01:04:05.000]  Значит, QA превращается в R', B и, например, налево, а дальше R' и что угодно превращается в R, что угодно, и направо.
[01:04:05.000 --> 01:04:15.000]  То есть получается, что мы сначала заменили, сдвинулись, а потом ничего не меняем и сдвигаемся обратно.
[01:04:15.000 --> 01:04:23.000]  И по итогу две вот эти команды работают точно так же, как одна команда вот эта.
[01:04:23.000 --> 01:04:31.000]  Если у нас есть программы, в которой есть сдвиги налево и направо, и на месте тоже,
[01:04:31.000 --> 01:04:37.000]  то можно написать новую программу, в которой сдвигов, ну, не сдвигов, а наоборот,
[01:04:37.000 --> 01:04:45.000]  состояние на месте не будет, все будет заменено на сдвиги налево-направо.
[01:04:45.000 --> 01:04:55.000]  Ну, соответственно, вот такие более или менее сложные конструкции получаются.
[01:04:55.000 --> 01:05:01.000]  Так, ну, у меня есть еще некоторое время.
[01:05:01.000 --> 01:05:07.000]  Давайте, значит, другие примеры оставлены в семинарах. Есть еще одно очень важное понятие.
[01:05:07.000 --> 01:05:11.000]  Давайте я постараюсь про него рассказать, по крайней мере вкратце.
[01:05:11.000 --> 01:05:31.000]  Значит, вкратце понятие это универсальная машина, универсальная машина тьюринга.
[01:05:31.000 --> 01:05:35.000]  Значит, тут опять же можно немножко удариться в историю учительной техники.
[01:05:35.000 --> 01:05:43.000]  Да, и концепцию архитектуры компьютеров. Значит, есть вообще два принципа компьютерной архитектуры.
[01:05:43.000 --> 01:06:11.000]  Значит, есть Гарвардская архитектура, да, есть Принстонская, Принстонская или Неймановская.
[01:06:11.000 --> 01:06:23.000]  Гарвардская архитектура, грубо говоря, означает, что программа это часть железа.
[01:06:23.000 --> 01:06:39.000]  Ну, можно сказать, что программное обеспечение выражено в аппаратном.
[01:06:39.000 --> 01:07:03.000]  Программа это часть аппаратуры, а данные отдельно, данные на некотором носителя.
[01:07:03.000 --> 01:07:17.000]  Ну а Принстонская архитектура заключается в том, что программа на таком же носителе, что и данные.
[01:07:17.000 --> 01:07:27.000]  Значит, на таком же носителе, что и данные.
[01:07:27.000 --> 01:07:35.000]  Ну и, соответственно, подавляющее большинство современных компьютеров построено как раз на Принстонской архитектуре.
[01:07:35.000 --> 01:07:42.000]  На одном и том же жестком диске есть и операционная система, и программы, и пользовательские файлы.
[01:07:42.000 --> 01:07:52.000]  Все это вот в одном и том же месте, все это одними тем же битами записано, и как-то это все работает.
[01:07:52.000 --> 01:08:00.000]  Ну и, соответственно, чем хороша Принстонская архитектура, что ее очень удобно перепрограммировать.
[01:08:00.000 --> 01:08:06.000]  Если вам нужно обработать по-другому, ну вы там меняете программу, которая лежит там же для данные.
[01:08:06.000 --> 01:08:12.000]  Престанавливается операционную систему, установится новая программа и так далее. Все это очень легко делается.
[01:08:12.000 --> 01:08:18.000]  Если у вас программа это часть аппаратуры, то получается, что чтобы сменить программу, вам нужно что-то перепаивать.
[01:08:19.000 --> 01:08:24.000]  Заменить какие-то детали, и это явно более сложная задача.
[01:08:24.000 --> 01:08:34.000]  Поэтому сейчас вот такая гарморская архитектура только для каких-то нишевых вещей, которые точно нужны для одной цели.
[01:08:34.000 --> 01:08:44.000]  Например, в аудиоаппаратуре бывает такое, что какая-то обработка звука делается так, что у вас прямо программа запаяна в микросхему,
[01:08:44.000 --> 01:08:52.000]  которая там обрабатывает звук. Ну или еще один пример, это фермы для майнинга криптовалют.
[01:08:52.000 --> 01:08:57.000]  Они тоже могут быть сделаны для конкретной криптовалюты с конкретной там хэш-функцией.
[01:08:57.000 --> 01:09:04.000]  Специально все запаяно так, чтобы именно очень быстро и экономно по электричеству получалось именно эту валюту майнить,
[01:09:04.000 --> 01:09:08.000]  а больше там ничего она делать не может.
[01:09:08.000 --> 01:09:18.000]  Ну хорошо, соответственно, вот то, что у нас до сих пор было, это на самом деле была гарморская архитектура, вот эта машина тюринга.
[01:09:18.000 --> 01:09:24.000]  Там отдельно получались данные на ленте, а отдельно программа, которая вообще неизвестна где.
[01:09:24.000 --> 01:09:30.000]  Ну вот, а универсальная машина, она вот работает на принцессской архитектуре.
[01:09:31.000 --> 01:09:35.000]  Так, ну я уж только определение успеваю дать.
[01:09:35.000 --> 01:09:54.000]  Соответственно, универсальная машина тюринга работает как, ну можно писать так, u от mx равно m от x.
[01:09:54.000 --> 01:10:04.000]  То есть здесь m это какое-то описание машины тюринга в каком-то формате, в том, как мы описали, как кортеж,
[01:10:04.000 --> 01:10:10.000]  или какие-нибудь конкретные соглашения могут быть, как записывается программа.
[01:10:10.000 --> 01:10:18.000]  m это получается описание машины тюринга, а x это получается ее вход.
[01:10:18.000 --> 01:10:34.000]  Соответственно, универсальная машина тюринга получает эти вещи и возвращает как раз то, что эта машина на этом входе возвращает.
[01:10:34.000 --> 01:10:50.000]  Ну, теорема, которую тюринг доказал, что универсальная машина тюринга существует.
[01:10:50.000 --> 01:10:58.000]  Но мы ее прям так подробно не будем доказывать.
[01:10:58.000 --> 01:11:02.000]  Да-да-да, и на самом при этом машина тюринга.
[01:11:02.000 --> 01:11:10.000]  Вообще это похоже на компилятор какого-нибудь языка программирования, который написан на этом же самом языке программирования.
[01:11:10.000 --> 01:11:14.000]  Да, это не очень удивительно, что так можно сделать.
[01:11:14.000 --> 01:11:18.000]  Можно вообще не доказывать теорему, а оставаться на тезисчорча.
[01:11:18.000 --> 01:11:24.000]  Мы же можем там на питоне написать машину тюринга.
[01:11:24.000 --> 01:11:36.000]  Ну, раз на питоне можно написать машину тюринга, значит и на машине тюринга можно написать машину тюринга.
[01:11:36.000 --> 01:11:44.000]  Ну все, на сегодня все. Спасибо за внимание.
[01:11:44.000 --> 01:11:50.000]  В следующий раз у нас будут свойства вычислимых функций и разрешимых множеств.
[01:11:50.000 --> 01:11:54.000]  А также еще появятся перечислимые множества, которые тоже очень важны.
