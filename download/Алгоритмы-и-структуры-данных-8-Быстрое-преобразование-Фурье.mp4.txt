[00:00.000 --> 00:22.720]  Первое, что я хочу сказать, это следующее. Смотрите, вот в прошлый раз мы за интересное
[00:22.720 --> 00:30.960]  время, а Н в степени алгорифм 7 по основанию 2, кажется, построили алгоритм Штрассена,
[00:30.960 --> 00:35.440]  который перемножает матрицы быстрее, чем наивный куб, когда мы просто построчно
[00:35.440 --> 00:41.680]  по столкцам умножаем. Так вот упражнения. Есть такой алгоритм Корацубы, который действует,
[00:41.680 --> 00:47.680]  в общем-то, аналогично, только перемножает многочлены. Здесь у вас два многочлена,
[00:47.840 --> 00:53.320]  тоже считаем, что длины, либо просто одинаковые длины N, либо одинаковые длины 2 в степени N,
[00:53.320 --> 01:01.000]  если удобно. И вот примерно так же мы поступаем. Мы сначала бьем оба многочлена пополам. Здесь
[01:01.000 --> 01:04.760]  младшая коэффициента, здесь старшая, здесь младшая, здесь старшая. И потом как-то с помощью
[01:04.760 --> 01:10.000]  трех умножений вот этих более коротких многочленов сводим задачу перемножения двух исходных к трём
[01:10.000 --> 01:20.640]  умножениям более коротких. И тогда симптотика будет, видимо, вот такая. Плюс, ну видимо,
[01:20.640 --> 01:27.040]  что-то линейное, потому что нам нужно просто складывать какие-то многочлены внутри. И решением
[01:27.040 --> 01:37.440]  такой рекурренты будет N в степени алгоритма тройки по основанию 2. Вот этого большого это
[01:37.440 --> 01:45.440]  примерно N в степени 59. В смысле 1 в степени 59. Ну и соответственно в качестве упражнения
[01:45.440 --> 01:50.400]  надо подобрать, вот представьте, что у вас вы первый многочлен разбили на многочлены a1, a2,
[01:50.400 --> 01:55.200]  второй на многочлены b1, b2. Нужно тоже как-то построить какие-то линейные комбинации,
[01:55.200 --> 02:01.120]  как-то их перемножить, свести, то есть перемножить какие-то три линейные комбинации здесь, так что в
[02:01.120 --> 02:06.800]  конце результат a умножить на b должен представляться в виде там опять линейной комбинации вот этих вот
[02:06.800 --> 02:11.960]  трех результатов перемножений. То есть нужно сделать три перемножения многочленов с длины N
[02:11.960 --> 02:25.360]  пополам. Вот это получится алгоритм коротцуба. Я его не разбираю, оставляю в качестве упражнения,
[02:25.360 --> 02:29.240]  потому что, во-первых, все необходимые техники у нас уже есть. У нас есть мастер теорема,
[02:29.240 --> 02:34.960]  которая немедленно позволяет от этой строчки прийти к этой. А также у нас есть описание алгоритма
[02:34.960 --> 02:39.160]  Штрассена, который еще более сложный, потому что там нужно, ну не три умножения сделать, а семь,
[02:39.160 --> 02:44.320]  и там формы гораздо более громоздкие, поэтому это можете сами придумать. Вторая причина,
[02:44.320 --> 02:48.640]  по которой мы не будем это полностью разбирать, потому что сегодня мы построим еще более эффективный
[02:48.640 --> 02:55.360]  алгоритм, который нам вот здесь будет не N в степени, полтора примерно, а N log N. N log N
[02:55.360 --> 03:03.440]  это вот то, к чему мы сейчас переходим. Быстрое преобразование фурья. Так, давайте я где-нибудь
[03:03.440 --> 03:07.760]  здесь напишу все-таки, что это многочлена, потому что как-то это слово надо зафиксировать все-таки.
[03:07.760 --> 03:23.160]  Есть два многочлена, ищем произведение. Вот. И такую же задачу мы будем решать с помощью
[03:23.160 --> 03:41.000]  быстрого преобразования фурья. Быстрое преобразование фурья. Так, смотрите. Значит,
[03:41.000 --> 03:49.240]  сначала давайте вспомним следующий факт. Если у вас есть какая-то многочлен п от х, равный,
[03:49.240 --> 03:58.960]  скажем, а0 плюс а1х плюс и так далее, плюс а N-1 х в N-1, то есть многочлен в степени N-1,
[03:58.960 --> 04:06.800]  у которого N коэффициентов, то он однозначно восстанавливается по значениям в произвольных
[04:06.800 --> 04:25.600]  N различных точках. П однозначно восстанавливается по своим значениям в произвольных N попарно
[04:25.600 --> 04:45.920]  различных точках. Попарно различных точек. То есть, если вы задаете себе систему уравнений вот
[04:45.920 --> 04:55.720]  таких вот, что P от х1 равно какой-нибудь у1 и так далее, P от хN равно уN, и вам известны все х и все у,
[04:55.720 --> 05:00.920]  и вы ищете многочлен P в степени меньше, чем N, то есть максимум с N коэффициентами,
[05:00.920 --> 05:06.280]  тогда такое многочлен единственно определен. Так, ну, наверное, это знакомый факт какой-то. Кому он
[05:06.280 --> 05:13.520]  знаком? Поднимите, пожалуйста, руки. Так, мало кому. Хорошо, не всем, по крайней мере. Ну, можно сказать так,
[05:13.520 --> 05:19.120]  что такое вот эта система? Это на самом деле какая-то система линейных уравнений на ашке,
[05:19.120 --> 05:24.320]  потому что здесь мне что нужно найти? Мне нужно восстановить набор ашек, а0, а1, и так далее, а1-1.
[05:24.320 --> 05:33.560]  И я подставляю туда степени х, то есть я подставляю сюда х1 в нулевой, х1 в первой, х1 в квадрате,
[05:33.560 --> 05:37.680]  и так далее. То же самое с х2, и так далее. То есть на самом деле у меня получается такая система
[05:37.680 --> 05:46.200]  уравнений, которую можно записать в виде матрицы. Здесь будут ашки, а0, и так далее, а1-1. Здесь будут
[05:46.200 --> 05:53.040]  значения, все у. А здесь будет просто матрица Вандермонда степеней хов всех. х1 в нулевой,
[05:53.040 --> 06:01.960]  х1 в первой, и так далее, х1 в н-1, х2 в нулевой, х2 в первой, и так далее, х2 в н-1, и так
[06:01.960 --> 06:12.040]  сводь до х. Ну и известный факт из линейной алгебры, что вот эта вот матрица, если у вас все х попарно
[06:12.040 --> 06:17.880]  различны, все х не равны х, для любых неравных и ижи, тогда эта матрица просто обратима, она не
[06:17.880 --> 06:22.440]  выражена, у нее не нулевой детерминат, поэтому ее можно обратить, тем самым у вас вот этот столбец
[06:22.440 --> 06:29.600]  однозначно выражается через столбец у. Ну вот, например, так это можно объяснить. Ну хорошо,
[06:29.600 --> 06:34.520]  то есть в принципе есть у нас какой-то метод обращения матрицы, чтобы найти столбец
[06:34.520 --> 06:40.840]  коэффициентов, но это слишком долго, неэффективно, и нам это и будет и не нужно. Нам важно просто факт,
[06:40.840 --> 06:47.800]  что многочлен однозначно восстанавливается по коэффициентам. Если вы возьмете точек на
[06:47.800 --> 06:52.640]  одну большую степень, вот здесь точек n, а степень n-1, если точек на одну большую степень,
[06:52.640 --> 06:58.560]  тогда многочлен однозначно восстанавливается. Вот что нам будет нужно. Ну и тогда смотрите,
[06:58.560 --> 07:04.240]  наш алгоритм перемножения многочленов будет выглядеть как-то так. Пусть наша цель это
[07:04.240 --> 07:16.560]  перемножить по IQ, дай получить многочлен r. Нам известно по IQ, нам нужно получить r.
[07:16.560 --> 07:26.120]  Алгоритм перемножения будет выглядеть так. Давайте мы сначала многочлены P и Q найдем в каких-то n
[07:26.120 --> 07:37.000]  точках, n различных точках, как-нибудь посчитаем. Первый шаг. Найдем P от x1 и так далее, P от xn,
[07:37.000 --> 07:53.320]  Q от x1 и так далее, Q от xn. В каких-то местических точках x1 и так далее xn. В каких-то точках x1 и так далее xn.
[07:53.320 --> 08:00.800]  На втором шаге мы их поточечно перемножим, потому что если я знаю значение P в точке x1 и значение Q
[08:00.800 --> 08:06.880]  в точке x1, то значение r тривиально восстанавливается. Это просто произведение. На r и x это P и x это
[08:06.880 --> 08:13.760]  умножено Q и x это. Ну просто из определения r. Просто поточечно перемножили эти два набора
[08:13.760 --> 08:24.360]  значений. Ну и третье. Восстановим r по этому набору значений в этих точках. Восстановим r по его
[08:24.360 --> 08:37.880]  значениям в точках x1 и так далее x. На высоком уровне это описание того, что мы будем делать.
[08:37.880 --> 08:42.920]  Взяли какие-то точки, пришли мы смотреть. Вот эти x мы вольны выбирать сами. Какие хотим,
[08:42.920 --> 08:48.040]  такие поставим. Нам не важно, какие они. Главное, чтобы их было достаточно много, чтобы их было
[08:48.040 --> 08:52.440]  больше, чем степень r. Чтобы точек было большим степень результата. Чтобы можно было восстановить.
[08:52.440 --> 08:57.120]  Но все остальное какие-то простые шаги. То есть нам нужно учиться как-то вот это быстро делать,
[08:57.120 --> 09:02.520]  находить значение многочленов во многих точках и обратную задачу по значениям в точках найти
[09:02.520 --> 09:06.160]  многочлен. Восстановить многочлен. Вот, но этим мы будем заниматься.
[09:22.160 --> 09:27.960]  Так, давай там еще тоже фиксируем. Что чтобы все это работало, мне нужно, чтобы n было больше,
[09:27.960 --> 09:33.320]  чем степень r. Чтобы однозначно можно было восстановить, количество точек должно быть больше,
[09:33.320 --> 09:46.040]  чем степень r. Ну то есть n, ну а дек r это дек p плюс дек q. При перемножении многочленов степени
[09:46.040 --> 09:50.600]  складываются. Вообще это не обязательно так. Если мы работаем в каком-нибудь там, в общем,
[09:50.600 --> 09:55.480]  не в поле, тогда у нас старшие коэффициенты могут перемножиться и стать делителем нуля, в общем,
[09:55.480 --> 09:58.840]  обнулиться. Но давайте считать, что у нас такого не происходит. Мы работаем всегда в поле,
[09:58.840 --> 10:04.840]  поэтому степень r равна сумме степеней по иq. Ну значит просто достаточно взять в качестве n
[10:04.840 --> 10:20.680]  хотя бы сумму степеней плюс один. Дек p плюс дек q плюс один. Вот, и значит наш алгоритм будет
[10:20.680 --> 10:27.920]  основаться на том, что в качестве х мы возьмем все корни из единицы, все комплексные корни из
[10:27.920 --> 10:46.080]  единицы. Значит в качестве х мы возьмем комплексные корни из единицы степени n, степени n.
[10:46.080 --> 10:56.840]  Напомню, как это выглядит. Значит есть у меня комплексная плоскость, вещественная, компоненты
[10:56.840 --> 11:04.360]  имнимы. Мы рисуем единичную окружность, вот такую вот, рисуем единичную окружность и спрашиваем
[11:04.360 --> 11:09.760]  себя, значит какие точки в n степени дают единицу. Ну это понятное дело единица, а также все ее
[11:09.760 --> 11:24.280]  повороты на угол 2p делить на n. Ну да, да, да, правильный n угольник, одна вершина в единичке,
[11:24.280 --> 11:30.240]  ну и с центром вот здесь вот, то есть вписано в эту окружность. Иными словами, мы можем повернуть
[11:30.240 --> 11:35.240]  вот этот вектор длины 1 на угол 2p делить на n, то есть как бы ну разбиваем всю окружность на n
[11:35.240 --> 11:40.680]  равных таких секторов, поворачиваем, получаем очередной очередной корень каждый раз. Значит
[11:40.680 --> 11:47.160]  повернули, получили, повернули, получили, повернули, получили, так несимметрично. В общем, как-то так
[11:47.160 --> 11:57.560]  получим. Очень часто минус 1 будет корнем, если n четно, то минус 1 будет корнем, вот. Тут уже
[11:57.560 --> 12:05.800]  моя художественная полномочия все. Ну в общем, какая-то такая картинка. И давайте мы вот эту
[12:05.800 --> 12:11.280]  штучку обозначим за омегу. Примитивный корень из единицы, на самом деле не важно, что именно
[12:11.280 --> 12:15.840]  обозначать за омегу, можно обозначить любой примитивный корень, то есть такой корень,
[12:15.840 --> 12:21.520]  степени которого порождают всю группу корней. Ну вот нам важно будет, что омега это такое число,
[12:21.520 --> 12:26.640]  что все возможные корни за единицы это степени омеги. То есть вот здесь у меня написано омега в
[12:26.640 --> 12:31.760]  нулевой, здесь у меня омега в первой, здесь омега во второй и так далее и так далее. Последний чувак
[12:31.760 --> 12:37.160]  будет омега в n-1. То есть все корни за единицы это степени какого-то одного числа омега. Ну и
[12:37.160 --> 12:47.760]  понятно, что это за число, это е в степени и 2p делить на n. Вот такое число. Так, хорошо,
[12:47.760 --> 12:55.960]  никто не испугался комплексных чисел? Отлично. Так, ну тогда смотрите, значит, тогда наша задача
[12:55.960 --> 13:05.920]  следующая. Нам нужно вот взять омегу и в ее степенях посчитать значение многочлена, ну там двух
[13:05.920 --> 13:12.400]  многоченов p и q. p во всех вот этих точках, q во всех этих точках как-нибудь быстро. Потом перемножить по
[13:12.400 --> 13:17.800]  точечной это ревиально, ну просто знаем результат тут, знаем результат тут для p и для q, перемножаем,
[13:17.800 --> 13:23.440]  получаем результат для r. А потом нужно опять, для многочлена r уже, у меня есть его значение в этих
[13:23.440 --> 13:28.440]  точках, у меня есть значение r в этих точках и мне нужно его восстановить. Ну и оба этих шага мы
[13:28.440 --> 13:34.080]  будем делать за n log n. За n log n, где n это вот как раз степень степени омеги, чтобы вернуться в единицы.
[13:34.960 --> 13:45.720]  Так, хорошо, ну давайте начнем тогда с первого шага, с нахождения значений многочлена вот в этих
[13:45.720 --> 14:08.040]  вот n точках. Да, мы будем с комплексами активно работать. Ну на самом деле он есть в плюсах,
[14:08.040 --> 14:14.640]  есть в плюсах вот такой комплекс от, ну а здесь там double или long double вы пишете, вот и в общем-то
[14:14.640 --> 14:21.000]  делать вам особо ничего не нужно, поэтому не проблема это. Итак, значит первый шаг,
[14:21.000 --> 14:32.480]  вычисления, вычисления p во всех степенях омеги. p от омега в нулевой, p от омега в первой и так
[14:32.480 --> 14:43.320]  далее, p от омега в степени n минус 1 во всех степенях омеги. Да, ну давайте напишем еще разочек,
[14:43.320 --> 14:50.920]  что такое p. Пусть p от x расписывается вот так, a0 плюс a1x плюс так далее, плюс an минус 1,
[14:50.920 --> 15:00.960]  xn минус 1. Вот, напоминаю, да, мне нужно взять такую омегу, что у нее степеней больше играно,
[15:00.960 --> 15:07.000]  чем степень p плюс степень q плюс 1, да, вот это условие должно быть. То есть омега это корень из
[15:07.000 --> 15:13.320]  единицы хотя бы вот такой степени. То есть на самом деле у меня вот этот многочлен p, у него вот здесь
[15:13.320 --> 15:19.080]  куча нулей, вот этих вот последних, куча последних коэффициентов нули, но просто для удобства я
[15:19.080 --> 15:24.640]  давайте буду считать, что размер этого многочлена и степень омеги до того, чтобы ее получать единичка,
[15:24.640 --> 15:29.160]  это одно и то же. Просто если это не так, то я могу это многочлен добить нулями до n минус 1 степени.
[15:29.160 --> 15:35.160]  Вот, мне так будет удобно. То есть здесь на самом деле куча нулей, но это не важно. Вот, давайте сделаем
[15:35.160 --> 15:40.840]  следующее странное преобразование. Мы разобьем наш многочлен на два кусочка по четным коэффициентам
[15:40.840 --> 15:52.720]  и по нечетным. Значит будет а0, а2х, а4 х квадрат, а6 х куб, ну и так далее. То есть мы оставляем
[15:52.720 --> 15:59.200]  только четные коэффициенты, при этом степени х обычные, да, 0, 1, 2, 3 и так далее. И аналогично
[15:59.200 --> 16:09.440]  с нечетными а1 плюс а3х, а5 х квадрат, а7 х куб и так далее. Вновь оставляем нечетные коэффициенты,
[16:09.440 --> 16:15.840]  а набор степеней обычных х0, х1 и так далее. Тогда выполняем следующее замечательное
[16:15.840 --> 16:32.120]  тождество, что p от x это p0 от x квадрате плюс x на p1 от x квадрате. Вот, ну плюс-минус очевидно,
[16:32.120 --> 16:36.000]  потому что если вы вот сюда вот, всюду вместо x поставьте x квадрате, то у вас как раз получится
[16:36.000 --> 16:39.960]  слагаемый с четными номерами. Если вы здесь поставите вместо x и x квадрате, то у вас получится
[16:39.960 --> 16:44.160]  то, что нужно, только вот как раз без недостающего x. Ну давайте на него и домножим, получим то,
[16:44.500 --> 16:51.320]  что нужно. Это вот прям совсем простое тождество. Ну зато смотрите, что это нам позволяет сделать.
[16:51.320 --> 17:02.060]  Давайте считаем что N четно. Смотрите какая прелесть. Чтобы найти значение p во всех
[17:02.060 --> 17:13.960]  степенях ω, мне достаточно найти значения p0 и p1 во всех четных степенях ω. Потому
[17:13.960 --> 17:15.960]  потому что если здесь стоит какой-то омега вжитый,
[17:15.960 --> 17:17.960]  то здесь будет омега в степени 2ж,
[17:17.960 --> 17:19.960]  и здесь тоже будет омега в степени 2ж.
[17:19.960 --> 17:24.960]  И если у меня n четно, то как у меня выглядит
[17:24.960 --> 17:26.960]  в четной степени омеги?
[17:26.960 --> 17:28.960]  Давайте я их нарисую.
[17:28.960 --> 17:30.960]  Так, у меня вообще как это было?
[17:30.960 --> 17:34.960]  0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
[17:34.960 --> 17:36.960]  Все нормально должно быть.
[17:43.960 --> 17:45.960]  Вот так, да.
[17:45.960 --> 17:47.960]  Значит, если у меня n четное,
[17:47.960 --> 17:50.960]  то у меня четных степеней омеги ровно половина.
[17:56.960 --> 17:58.960]  Мы не видели вроде.
[18:01.960 --> 18:03.960]  Я тут ничего не вижу.
[18:06.960 --> 18:08.960]  Ничего.
[18:08.960 --> 18:10.960]  Итак, если n четно,
[18:10.960 --> 18:12.960]  то четные степени омеги
[18:12.960 --> 18:13.960]  это половина точек.
[18:13.960 --> 18:15.960]  Омега в нулевой, омега в второй, в четвертой,
[18:15.960 --> 18:17.960]  в шестой и так далее.
[18:17.960 --> 18:19.960]  Вплоть до n-2 получится.
[18:21.960 --> 18:24.960]  Чтобы нам победить задачу для исходного p,
[18:24.960 --> 18:26.960]  мне достаточно посчитать p0 и p1
[18:26.960 --> 18:28.960]  в двое меньшем числе точек.
[18:29.960 --> 18:31.960]  Давайте это напишем.
[18:31.960 --> 18:36.960]  Достаточно найти значение
[18:36.960 --> 18:40.960]  p0 и p1 в точках
[18:42.960 --> 18:46.960]  омега 0, омега 2, омега 4 и так далее,
[18:46.960 --> 18:48.960]  омега в степени n-2.
[18:48.960 --> 18:50.960]  И здесь точек будет вдвое меньше.
[18:50.960 --> 18:52.960]  Ну и потом, соответственно,
[18:52.960 --> 18:54.960]  если мы знаем значение p0 и p1
[18:54.960 --> 18:56.960]  в этом наборе точек,
[18:56.960 --> 18:58.960]  то чтобы получить набор значений p
[18:58.960 --> 19:00.960]  во всех обычных степенях омеги,
[19:00.960 --> 19:02.960]  то нужно просто пройтись по этому набору
[19:02.960 --> 19:04.960]  и там с какими-то коэффициентами их сложить.
[19:04.960 --> 19:06.960]  Здесь бы как раз омега в степени g вылезать.
[19:06.960 --> 19:08.960]  Ну и все.
[19:08.960 --> 19:10.960]  На самом деле мы свели исходную задачу
[19:10.960 --> 19:12.960]  вычисления значений p в n-точках
[19:12.960 --> 19:14.960]  к двум задачам вычисления значений
[19:14.960 --> 19:16.960]  p0 и p1 в n-пополам точках.
[19:16.960 --> 19:18.960]  Поэтому если t от n это время работы
[19:18.960 --> 19:20.960]  нашего алгоритма на исходном массиве,
[19:20.960 --> 19:24.960]  то t от n это 2t от t от n-пополам
[19:24.960 --> 19:26.960]  плюс o от n
[19:26.960 --> 19:28.960]  плюс t от n.
[19:32.960 --> 19:34.960]  Потому что еще раз,
[19:34.960 --> 19:36.960]  я вычислил два многочлена,
[19:36.960 --> 19:38.960]  мне достаточно найти их значение
[19:38.960 --> 19:40.960]  в n-пополам точках,
[19:40.960 --> 19:42.960]  я делал это рекурсивно с помощью
[19:42.960 --> 19:44.960]  этой же процедуры.
[19:44.960 --> 19:46.960]  Посчитал их значение в этих точках
[19:46.960 --> 19:48.960]  и потом за линейное время,
[19:48.960 --> 19:50.960]  то есть за количество корней,
[19:50.960 --> 19:52.960]  за количество степеней омеги
[19:52.960 --> 19:54.960]  склеил эти два вектора
[19:54.960 --> 19:56.960]  в вектор значений p по вот этой форме.
[19:56.960 --> 19:58.960]  Понятно?
[19:58.960 --> 20:00.960]  Ну и все, получается у меня симптотика заявленная.
[20:00.960 --> 20:02.960]  В идеале, конечно, считать n в степенье двойки,
[20:02.960 --> 20:04.960]  потому что если я здесь на каждом шаге
[20:04.960 --> 20:06.960]  предполагаю, что он четно,
[20:06.960 --> 20:08.960]  то лучше в самом начале ее сделать в степенье двойки.
[20:08.960 --> 20:10.960]  Но опять, если n это не степень двойки,
[20:10.960 --> 20:12.960]  то давайте добьем нулями
[20:12.960 --> 20:14.960]  столько, сколько нужно здесь
[20:14.960 --> 20:16.960]  до ближайшей степени двойки.
[20:16.960 --> 20:18.960]  Ну и заодно мы увеличим
[20:18.960 --> 20:20.960]  показатель n-ки,
[20:20.960 --> 20:22.960]  то есть мы посчитаем многочлены
[20:22.960 --> 20:24.960]  в большем числе точек,
[20:24.960 --> 20:26.960]  чем больше точек,
[20:26.960 --> 20:28.960]  тем как бы проще
[20:28.960 --> 20:30.960]  находить многочлены по этим точкам.
[20:30.960 --> 20:32.960]  Поэтому ничего страшного не произойдет.
[20:32.960 --> 20:34.960]  Ну, кажется, с первым шагом мы справились.
[20:34.960 --> 20:36.960]  Мы вот так вот можем рекурсивно
[20:36.960 --> 20:38.960]  найти значения в наших n-корнях
[20:38.960 --> 20:40.960]  раз за единицей.
[20:40.960 --> 20:42.960]  Так, хорошо.
[20:42.960 --> 20:44.960]  Давайте я это оставлю
[20:44.960 --> 20:46.960]  пока что.
[20:46.960 --> 20:48.960]  Второй шаг тривиален.
[20:48.960 --> 20:50.960]  Если мне известны значения p
[20:50.960 --> 20:52.960]  во всех степенях омеги,
[20:52.960 --> 20:54.960]  то у меня есть значение
[20:54.960 --> 20:56.960]  п,
[20:56.960 --> 20:58.960]  и значение q
[20:58.960 --> 21:00.960]  во всех степенях омеги,
[21:04.960 --> 21:06.960]  то значение r-ки получается тривиально.
[21:06.960 --> 21:08.960]  Это нужно просто перемножить соответствующие числа.
[21:08.960 --> 21:10.960]  Вот это на это, вот это на это,
[21:10.960 --> 21:12.960]  вот это на это и так далее.
[21:12.960 --> 21:14.960]  Прямо как там написано.
[21:14.960 --> 21:16.960]  r от омега вжитой равно p от омега вжитой
[21:16.960 --> 21:18.960]  умножить на q от омега вжитой.
[21:18.960 --> 21:20.960]  И этот шаг,
[21:20.960 --> 21:22.960]  второй шаг нашего алгоритма
[21:22.960 --> 21:24.960]  работает очевидно за
[21:24.960 --> 21:26.960]  линейное время.
[21:26.960 --> 21:28.960]  Просто нужно поточечно
[21:28.960 --> 21:30.960]  перемножить два массива.
[21:32.960 --> 21:34.960]  Так, ну хорошо.
[21:34.960 --> 21:36.960]  Давайте тогда я это убью.
[21:50.960 --> 21:52.960]  Теперь осталось нам
[21:52.960 --> 21:54.960]  обратное преобразование сделать
[21:54.960 --> 21:56.960]  по набору значений в омегах,
[21:56.960 --> 21:58.960]  в степенях омеги.
[21:58.960 --> 22:00.960]  Нужно наоборот найти многочлен.
[22:02.960 --> 22:04.960]  Для этого давайте посмотрим внимательно,
[22:04.960 --> 22:06.960]  что мы вот здесь сделали.
[22:06.960 --> 22:08.960]  Давайте еще раз напишем это на языке матриц.
[22:08.960 --> 22:10.960]  Вот есть у меня многочлен какой-то p,
[22:10.960 --> 22:12.960]  не буду переписывать, с коэффициентами h-ки.
[22:12.960 --> 22:14.960]  И мы находили его значение
[22:14.960 --> 22:16.960]  в степенях омеги.
[22:16.960 --> 22:18.960]  То есть по сути мы написали следующее,
[22:18.960 --> 22:20.960]  мы вычислили следующее преобразование.
[22:20.960 --> 22:22.960]  Мы нашли значение p-шки
[22:22.960 --> 22:24.960]  в степенях омеги.
[22:26.960 --> 22:28.960]  Путем домножения столбца коэффициентов
[22:30.960 --> 22:32.960]  слева на какую-то матрицу.
[22:32.960 --> 22:34.960]  Ну это вот ровно то самое,
[22:34.960 --> 22:36.960]  что у меня было написано здесь когда-то.
[22:36.960 --> 22:38.960]  Что такое
[22:38.960 --> 22:40.960]  вычисление многочленов
[22:40.960 --> 22:42.960]  в каких-то точках.
[22:42.960 --> 22:44.960]  Это мы берем столбец коэффициентов и умножаем его
[22:44.960 --> 22:46.960]  на матрицу Вандермонда, где построчно
[22:46.960 --> 22:48.960]  стоят степени точек, в которые мы
[22:48.960 --> 22:50.960]  считаем значение.
[22:50.960 --> 22:52.960]  Ну соответственно здесь будет то же самое.
[22:52.960 --> 22:54.960]  Здесь будет омега в степени 0 умножить на 0,
[22:54.960 --> 22:56.960]  омега 0 на 1 и так далее,
[22:56.960 --> 22:58.960]  омега 0 на n-1.
[22:58.960 --> 23:00.960]  Здесь будут степени кратные единицы,
[23:00.960 --> 23:02.960]  то есть 1 на 0,
[23:02.960 --> 23:04.960]  1 на 1,
[23:04.960 --> 23:06.960]  1 на n-1.
[23:06.960 --> 23:08.960]  Последние строчки будут в степени кратной n-1.
[23:08.960 --> 23:10.960]  n-1 на 0,
[23:10.960 --> 23:12.960]  n-1 на 1
[23:12.960 --> 23:14.960]  и так далее, n-1 на n-1.
[23:18.960 --> 23:20.960]  Просто мы написали матрицу Вандермонда
[23:20.960 --> 23:22.960]  для набора точек, в которых мы считаем
[23:22.960 --> 23:24.960]  наш многочлен.
[23:24.960 --> 23:26.960]  И посмотрите, что мы сделали.
[23:26.960 --> 23:28.960]  Нашим вот этим алгоритмом
[23:28.960 --> 23:30.960]  за n лог n мы
[23:30.960 --> 23:32.960]  умножили
[23:32.960 --> 23:34.960]  столбец размера n
[23:34.960 --> 23:36.960]  на матрицу n на n.
[23:36.960 --> 23:38.960]  Мы знали вот это,
[23:38.960 --> 23:40.960]  мы знаем вот это.
[23:40.960 --> 23:42.960]  У нас не знает матрица в явном виде,
[23:42.960 --> 23:44.960]  как матрица размера n в квадрате,
[23:44.960 --> 23:46.960]  но мы знаем, как каждый ее элемент задается.
[23:46.960 --> 23:48.960]  Каждый элемент это просто ω в степени i умножить на j.
[23:48.960 --> 23:50.960]  ω в степени умножить на j.
[23:50.960 --> 23:52.960]  И вот мы за n лог n
[23:52.960 --> 23:54.960]  можем перемножить эту матрицу на этот столбец,
[23:54.960 --> 23:56.960]  получить столбец значений.
[23:56.960 --> 23:58.960]  Вот по сути, что мы сделали с помощью
[23:58.960 --> 24:00.960]  вот того первого пункта.
[24:00.960 --> 24:02.960]  Умножили какой-то столбец на набор
[24:02.960 --> 24:04.960]  на матрицу из степени ω.
[24:04.960 --> 24:06.960]  Теперь наша задача становится обратной.
[24:06.960 --> 24:08.960]  Вот я это сделал,
[24:08.960 --> 24:10.960]  теперь у меня есть наоборот набор значений
[24:10.960 --> 24:12.960]  многочлена r в этих точках,
[24:12.960 --> 24:14.960]  и мне нужно восстановить набор его коэффициентов.
[24:14.960 --> 24:16.960]  Мы уже говорили достаточно,
[24:16.960 --> 24:18.960]  просто умножить на обратную матрицу.
[24:20.960 --> 24:22.960]  Давайте я напишу следующее.
[24:22.960 --> 24:24.960]  Давайте мы скажем, что r от x
[24:24.960 --> 24:26.960]  это c0 плюс c1x плюс так далее,
[24:26.960 --> 24:28.960]  плюс cn-1xv-1.
[24:30.960 --> 24:32.960]  Тогда у меня выполняется следующее.
[24:32.960 --> 24:34.960]  Столбец коэффициентов,
[24:34.960 --> 24:36.960]  результирующего многочлена,
[24:36.960 --> 24:38.960]  получается из столбца значений
[24:38.960 --> 24:40.960]  этого многочлена
[24:40.960 --> 24:44.960]  в наших корнях из 1.
[24:46.960 --> 24:48.960]  Путем домножения
[24:48.960 --> 24:50.960]  на матрицу обратную вот к этой.
[24:50.960 --> 24:52.960]  Давайте я здесь напишу вот это жирное w
[24:52.960 --> 24:54.960]  в степень минус 1,
[24:54.960 --> 24:56.960]  где w это вот эта матрица,
[24:56.960 --> 24:58.960]  матрица степени ω.
[25:00.960 --> 25:02.960]  То есть еще раз, чтобы получить
[25:02.960 --> 25:04.960]  столбец коэффициентов из столбца значений,
[25:04.960 --> 25:06.960]  мне нужно просто вот этот столбец
[25:06.960 --> 25:08.960]  домножить слева на матрицу обратную вот к этой,
[25:08.960 --> 25:10.960]  обратную к матрице w. Понятно?
[25:26.960 --> 25:28.960]  На самом деле можно очень легко понять,
[25:28.960 --> 25:30.960]  как выглядит эта матрица.
[25:38.960 --> 25:40.960]  А у нас как бы нижний это верхний?
[25:40.960 --> 25:42.960]  У нас x и t это ω в степени i.
[25:44.960 --> 25:46.960]  Вот.
[25:46.960 --> 25:48.960]  Но смотрите, я утверждаю следующее,
[25:48.960 --> 25:50.960]  что есть у меня исходная матрица,
[25:50.960 --> 25:52.960]  у которой в этой житой клетке
[25:52.960 --> 25:54.960]  стоит ω в степени ij.
[25:54.960 --> 25:56.960]  Тогда давайте рассмотрим матрицу
[25:56.960 --> 25:58.960]  вот такую, давайте я обозначу v,
[25:58.960 --> 26:00.960]  где в этой житой клетке будет
[26:00.960 --> 26:02.960]  ω в степени ij.
[26:02.960 --> 26:04.960]  Вот.
[26:04.960 --> 26:06.960]  Вот.
[26:06.960 --> 26:08.960]  Где в этой житой клетке
[26:08.960 --> 26:10.960]  будет стоять ω в минус
[26:10.960 --> 26:12.960]  первой степени ij.
[26:12.960 --> 26:14.960]  То есть мы один раз нашли обратное к ω
[26:14.960 --> 26:16.960]  и возводим в ту же степень.
[26:16.960 --> 26:18.960]  Тогда я утверждаю, что
[26:18.960 --> 26:20.960]  эти матрицы почти что обратные.
[26:20.960 --> 26:22.960]  А именно их произведение
[26:22.960 --> 26:24.960]  в n раз больше, чем
[26:24.960 --> 26:26.960]  единичная матрица.
[26:28.960 --> 26:30.960]  Единичная матрица.
[26:30.960 --> 26:32.960]  То есть, ну,
[26:32.960 --> 26:34.960]  а если нам известно это,
[26:34.960 --> 26:36.960]  то нам известно, как выглядит обратное
[26:36.960 --> 26:38.960]  к ω, ну, к матрице w.
[26:38.960 --> 26:40.960]  Это просто 1nnv.
[26:44.960 --> 26:46.960]  Так.
[26:46.960 --> 26:48.960]  Ну, наверное, вот это надо доказать.
[26:48.960 --> 26:50.960]  Еще раз, да,
[26:50.960 --> 26:52.960]  у меня есть матрица w,
[26:52.960 --> 26:54.960]  у которой строки столбцы
[26:54.960 --> 26:56.960]  занумерованы от 0 до n-1,
[26:56.960 --> 26:58.960]  и на перечене этой строки житого столбца
[26:58.960 --> 27:00.960]  ω в степени ij.
[27:00.960 --> 27:02.960]  Я рассматриваю аналогичную матрицу w и j,
[27:02.960 --> 27:04.960]  только там не степени ω, а степени ω в минус
[27:04.960 --> 27:06.960]  первой, но в те же самых степенях и умножить
[27:06.960 --> 27:08.960]  ij. Тогда оказывается, что если их просто
[27:08.960 --> 27:10.960]  перемножу по обычному умножению матрицы,
[27:10.960 --> 27:12.960]  то получится единичная матрица, умноженная
[27:12.960 --> 27:14.960]  на n.
[27:14.960 --> 27:16.960]  Вот. Ну, чего, давайте, наверное,
[27:16.960 --> 27:18.960]  ну, если не докажем,
[27:18.960 --> 27:20.960]  то хотя бы набросаем доказательства.
[27:22.960 --> 27:24.960]  Вот я перемножаю w и хочу сказать,
[27:24.960 --> 27:26.960]  что у меня получается вот такая матрица,
[27:26.960 --> 27:28.960]  в главной диагонали стоят n-ки,
[27:28.960 --> 27:30.960]  а в основных местах 0, то есть
[27:30.960 --> 27:32.960]  единичная умноженная на n.
[27:32.960 --> 27:34.960]  Вопрос, да?
[27:34.960 --> 27:36.960]  Как это доказать?
[27:36.960 --> 27:38.960]  Ну, смотрите, давайте мы перемножим, скажем,
[27:38.960 --> 27:40.960]  и ту строчку
[27:40.960 --> 27:42.960]  и и ты столбец.
[27:42.960 --> 27:44.960]  И ту строчку и и ты столбец.
[27:44.960 --> 27:46.960]  Мы хотим показать, что должно получиться n.
[27:46.960 --> 27:48.960]  Окей.
[27:48.960 --> 27:50.960]  Что находится в клетке ij вот здесь?
[27:50.960 --> 27:52.960]  Значит, берем какую-то житую
[27:52.960 --> 27:54.960]  столбец здесь и, соответственно, житую строчку здесь.
[27:54.960 --> 27:56.960]  Что находится здесь
[27:56.960 --> 27:58.960]  в клетке ij?
[27:58.960 --> 28:00.960]  Ну, ω в минус 1
[28:00.960 --> 28:02.960]  в степени i умножить на j.
[28:02.960 --> 28:04.960]  Здесь будет ω
[28:04.960 --> 28:06.960]  обычная в степени j умножить на i.
[28:08.960 --> 28:10.960]  ω обычная в степени j умножить на i.
[28:10.960 --> 28:12.960]  Ну, это единица, да, просто?
[28:12.960 --> 28:14.960]  Потому что здесь написано ω в степени
[28:14.960 --> 28:16.960]  минус ij, здесь написано ω в степени ji.
[28:16.960 --> 28:18.960]  Поэтому это единица.
[28:18.960 --> 28:20.960]  Ну, а нам нужно скалярно умножить
[28:20.960 --> 28:22.960]  эту строчку на этот столбец,
[28:22.960 --> 28:24.960]  сначала перемножили вот эти, получили единичку,
[28:24.960 --> 28:26.960]  вот эти получили единичку и так далее и так далее.
[28:26.960 --> 28:28.960]  У меня все эти произведения равны единице.
[28:28.960 --> 28:30.960]  Потом мы их складываем, получаем n по количеству слагаемых.
[28:30.960 --> 28:32.960]  Поэтому действительно
[28:32.960 --> 28:34.960]  перемножение iй строки и iй столбца
[28:34.960 --> 28:36.960]  дает мне n в клетке ii.
[28:36.960 --> 28:38.960]  То есть на главной диагонали точно n.
[28:40.960 --> 28:42.960]  Теперь, что происходит с недиагональными элементами?
[28:52.960 --> 28:54.960]  Так, что происходит с недиагональными элементами?
[28:54.960 --> 28:56.960]  Ну, давайте посмотрим. Давайте мы перемножим
[28:56.960 --> 28:58.960]  i ту строчку опять-таки
[28:58.960 --> 29:00.960]  на какой-нибудь столбец k,
[29:00.960 --> 29:02.960]  накатый столбец,
[29:02.960 --> 29:04.960]  где k не равно i.
[29:04.960 --> 29:06.960]  Тогда мне нужна следующая сумма.
[29:06.960 --> 29:08.960]  Мне нужна найти сумму
[29:08.960 --> 29:10.960]  по j от 0 до n-1.
[29:10.960 --> 29:12.960]  Ну, я не знаю, как это делать.
[29:12.960 --> 29:14.960]  Я не знаю, как это делать.
[29:14.960 --> 29:16.960]  Я не знаю, как это делать.
[29:16.960 --> 29:18.960]  Я не знаю, как это делать.
[29:18.960 --> 29:20.960]  Я не знаю, как это делать.
[29:20.960 --> 29:22.960]  Нужно найти сумму по j от 0 до n-1,
[29:24.960 --> 29:26.960]  слева остается ω в минус
[29:26.960 --> 29:28.960]  первой степени ij,
[29:28.960 --> 29:38.960]  а справа будет
[29:42.960 --> 29:44.960]  zad salah Argentine раздав derivative
[29:44.960 --> 29:48.960]  шаблон тебя
[29:48.960 --> 29:52.800]  и g, здесь степень g умножить на k. Давайте я g вынесу и
[29:52.800 --> 30:03.800]  будет у меня и-k. Так? Или иными словами, это вот такая
[30:03.800 --> 30:17.680]  сумма, и-kg. Да, спасибо, спасибо. Это я поторопился,
[30:17.680 --> 30:26.560]  к минусы, конечно. Ну а это уже просто геометрическая
[30:26.560 --> 30:34.960]  прогрессия, у которой отношение не единице. Из-за того, что
[30:34.960 --> 30:40.080]  k не равно i, у меня получается, что вот это не ноль, значит
[30:40.080 --> 30:43.560]  у меня как бы шаг прогрессии не единица. Ну в смысле
[30:43.560 --> 30:46.480]  отношение, вот это q в прогрессии не единица. Ну а мы знаем,
[30:46.480 --> 30:54.760]  как считать сумму геометрической прогрессии, наверное. Короче,
[30:54.760 --> 30:56.960]  давайте я напису ноль и скажу, что это сумма геометрической
[30:56.960 --> 30:59.200]  прогрессии. Я эту формулу никогда не могу запомнить.
[30:59.200 --> 31:02.520]  Если она бесконечная, то я знаю, если она конечная,
[31:02.520 --> 31:06.560]  нет. Пытайте меня, но я не скажу эту формулу. Сумма
[31:06.560 --> 31:13.280]  геометрической прогрессии. Типа вот есть у вас 1 плюс
[31:13.280 --> 31:18.200]  q в степени n минус 1. Что это? Ну это видимо что-то в стиле
[31:18.200 --> 31:24.920]  1 минус qn на 1 минус q. Похоже, да. Ну вот здесь q это как
[31:24.920 --> 31:30.840]  раз ω в степени k минус i, и вы вот это вот складываете
[31:30.840 --> 31:33.960]  в несколько первых степеней. Получится как раз у вас вот
[31:33.960 --> 31:39.240]  здесь 1 минус q в степени n, где q это ω в степени k минус
[31:39.240 --> 31:42.320]  i. Ну понятно, что если ω в степени n это единица, то
[31:42.320 --> 31:44.960]  ω в степени k минус i умножить на n это тоже единица. Ну
[31:44.960 --> 31:50.880]  значит у вас числитель просто нулевой, и все. Так, окей?
[31:50.880 --> 31:54.600]  Вот. Ну эта арифметическая выкладка нам нужна для
[31:54.600 --> 31:57.960]  того, чтобы понять, как выглядит обратная матрица к матрице
[31:57.960 --> 32:01.480]  w. Давайте еще раз это напишем, что обратная к w это просто
[32:01.480 --> 32:06.840]  одна n в. То есть если я каждую ячейку v поделю на n, то получится
[32:06.840 --> 32:11.400]  наша хорошая матрица. Ну или там сначала сделаю преобразование
[32:11.400 --> 32:14.080]  с v, а потом весь результат поделю на n, то тоже будет
[32:14.080 --> 32:17.480]  обратное преобразование. Ну тогда смысл такой. Смысл
[32:17.480 --> 32:21.080]  вот этого равенства в следующем. Если мне нужно домножить
[32:21.080 --> 32:26.160]  вот этот столбец на матрицу обратную к w, то я давайте
[32:26.160 --> 32:28.320]  поступлю следующим образом. Смотрите, у меня же есть
[32:28.320 --> 32:31.080]  уже алгоритм, который столбец умножает просто на матрицу
[32:31.080 --> 32:35.240]  w за n лог n. А теперь давайте я вот здесь всюду подменю
[32:35.240 --> 32:39.960]  ω на ω в минус 1. Я здесь всюду заменю ω на ω в минус
[32:39.960 --> 32:44.720]  1. Тогда по сути я умножу вот этот столбец на матрицу
[32:44.720 --> 32:49.520]  w, потому что это как раз будет матрица w. Ну и в конце
[32:49.520 --> 32:54.440]  нужно просто будет поделить результат на n из-за этого
[32:54.440 --> 33:03.760]  коэффициента. То есть, сейчас мы все это напишем. То есть
[33:03.760 --> 33:06.640]  вот это обратный шаг, обратное преобразование в фурье, оно
[33:06.640 --> 33:09.760]  не отличается от исходного. Оно отличается от исходного
[33:09.760 --> 33:12.520]  только тем, что мы вместо ω пишем ω в минус 1, еще в
[33:12.520 --> 33:15.720]  конце делим на n. Вот и все. Третий шаг реализуется
[33:15.720 --> 33:26.720]  так. Запускаем первый шаг. С ω равно ω в минус 1. То
[33:26.720 --> 33:31.400]  есть мы вместо ω всюду пишем ω в минус 1. Считаем результат.
[33:31.400 --> 33:45.840]  И в конце делим все получившиеся числа на n. Делим все числа
[33:45.840 --> 33:58.920]  на n. Ну плюс-минус все. Вот это будет обратное преобразование
[33:58.920 --> 34:04.960]  в фурье. Обратное преобразование в фурье. Ну а соответственно
[34:04.960 --> 34:08.960]  первый шаг это обычное преобразование в фурье. То есть еще раз. На
[34:08.960 --> 34:12.840]  первом шаге мы научились, если мы берем произвольную
[34:12.840 --> 34:14.840]  ω, произвольный примитивный корень за единицей, который
[34:14.840 --> 34:17.680]  порождает все остальные, мы умеем умножать любой
[34:17.680 --> 34:21.360]  столбец на матрицу вот таких ω. Тогда если я запущу тот
[34:21.360 --> 34:25.800]  же алгоритм, просто с другой ω в минус 1, тогда у меня
[34:25.800 --> 34:28.240]  как раз получится вот это вот практически умножение
[34:28.240 --> 34:31.800]  на обратную матрицу только с коэффициентом n еще лишним.
[34:31.800 --> 34:34.240]  Ну давайте я просто в конце вот этот столбец получившийся
[34:34.240 --> 34:42.240]  поделю просто на n и все. Понятно? Вот здесь есть такая тонкость,
[34:42.240 --> 34:44.640]  которая может смущать, что раньше мы воспринимали
[34:44.640 --> 34:47.240]  вот этот столбец как набор коэффициентов многочлена.
[34:47.240 --> 34:49.640]  Что у меня там было а0 плюс а1х и так далее и так далее.
[34:49.640 --> 34:52.440]  Я считаю значение этого многочлена в каких-то точках.
[34:52.440 --> 34:55.440]  Это то же самое, что умножить на матрицу. А здесь, когда
[34:55.440 --> 34:57.240]  я делал обратное преобразование в фурье, у меня как бы по
[34:57.240 --> 35:01.240]  сути уже есть значение многочлена, и я делаю наоборот восстанавливаю коэффициенты.
[35:01.240 --> 35:06.240]  Ну давайте не думать об этом. Давайте считать просто этот столбец чисел
[35:06.240 --> 35:10.240]  опять коэффициентами какого-то многочлена. Потому что по сути мне нужно
[35:10.240 --> 35:14.240]  построить вот этот многочлен по вот этим коэффициентам и посчитать его значение
[35:14.240 --> 35:19.240]  в этих точках, там ω в минус ij. Ну и получится вот это вот.
[35:19.240 --> 35:22.240]  То есть как ни странно, если воспринимать набор значений
[35:22.240 --> 35:26.240]  как набор коэффициентов и работать с ним как раньше, как в первом пункте,
[35:26.240 --> 35:29.240]  тогда мы получим набор коэффициентов.
[35:29.240 --> 35:31.240]  Окей?
[35:31.240 --> 35:34.240]  Так, ну отлично.
[35:34.240 --> 35:39.240]  Отлично. Тогда этот шаг работает тоже за n log n.
[35:39.240 --> 35:43.240]  И суммарно мы решили задачу за n log n.
[35:43.240 --> 35:45.240]  Задача.
[35:45.240 --> 35:55.240]  Это все назовем n log n, где n это...
[35:55.240 --> 35:59.240]  Ну давайте я напишу так. По порядку это максимальная степень
[35:59.240 --> 36:02.240]  dq и dq.
[36:06.240 --> 36:10.240]  То есть нам их там нужно сложить, прибавить единичку, еще добить до
[36:10.240 --> 36:14.240]  максимальной степени двойки. Ну по порядку это просто максимум.
[36:15.240 --> 36:17.240]  Окей.
[36:20.240 --> 36:24.240]  Так. Ну какие тут есть проблемы? Тут, конечно, проблемы большие с точностью,
[36:24.240 --> 36:28.240]  потому что когда мы считаем корни комплексной заденицы, там, конечно,
[36:28.240 --> 36:31.240]  возникает куча... Ну вот когда я рисовал окружность, там, конечно,
[36:31.240 --> 36:36.240]  далеко не целые и даже не рациональные вот эти вот, получается, координаты у них.
[36:36.240 --> 36:39.240]  И здесь куча всяких умножений. Возведение в степень всякие,
[36:39.240 --> 36:42.240]  рекурсивные спуски, в которых еще куча умножений и сложений.
[36:42.240 --> 36:46.240]  Поэтому, на самом деле, ошибка тут копится такая существенная.
[36:46.240 --> 36:53.240]  Вот. На практике это все работает точно, если выполнять следующее условие.
[36:53.240 --> 36:56.240]  Значит, если вы перемножаете два целочисленных многочлена,
[36:56.240 --> 37:03.240]  если перемножаем целочисленные многочлены,
[37:08.240 --> 37:11.240]  то есть многочлены, у которых коэффициенты это целые числа,
[37:11.240 --> 37:16.240]  то это все работает точно, если у вас получающиеся коэффициенты,
[37:16.240 --> 37:28.240]  они по модулю примерно 10 в 11, то погрешность не велика,
[37:28.240 --> 37:48.240]  если коэффициенты r не превосходят примерно 10 в 11, 10 в 12, что-то такое.
[37:48.240 --> 37:51.240]  То есть если у вас есть два целочисленных многочлена,
[37:51.240 --> 37:55.240]  и вы хотите их перемножить точно, то есть понятно, что результат это целочисленный многочлен,
[37:55.240 --> 38:00.240]  но если вы просто напишете два fft для p, fft для q,
[38:00.240 --> 38:04.240]  потом поточно перемножите и построите обратный fft,
[38:04.240 --> 38:06.240]  то, понятное дело, там будет не целые числа,
[38:06.240 --> 38:10.240]  потому что у вас есть переход в комплексный, понятное дело, куча погрешностей,
[38:10.240 --> 38:12.240]  все в конце будет не целое.
[38:12.240 --> 38:16.240]  Но если в конце их округлить просто, если округлить коэффициенты к ближайшему целому,
[38:16.240 --> 38:19.240]  то это будет правильно работать, если эти числа не очень большие,
[38:19.240 --> 38:22.240]  не больше 10 в 11, 10 в 12.
[38:22.240 --> 38:25.240]  Если они сильно больше, то, к сожалению, там возникает погрешность,
[38:25.240 --> 38:27.240]  и вы получаете коэффициенты с какой-то погрешностью.
[38:27.240 --> 38:31.240]  Это не то, что нужно, это все довольно было бы глупо.
[38:31.240 --> 38:35.240]  Есть, конечно, обобщение, которое с этим борется, но мы его не рассматриваем.
[38:35.240 --> 38:40.240]  Мы считаем, что в наших задачах либо коэффициенты, результирующие реально вот такие...
[38:43.240 --> 38:44.240]  Еще раз?
[38:46.240 --> 38:49.240]  Тильда. Ну, как бы, примерно равно.
[38:49.240 --> 38:59.240]  Если коэффициенты по модулю не больше 10 в 11-10 в 12, тогда все работает точно.
[38:59.240 --> 39:05.240]  Еще раз, для нас мы можем считать, что либо мы перемножаем такие многочлены,
[39:05.240 --> 39:07.240]  для которых результирующие коэффициенты вот такие,
[39:07.240 --> 39:09.240]  то есть мы можем считать как бы без погрешности,
[39:09.240 --> 39:17.240]  либо чуть позже мы еще рассмотрим, как можно делать преобразование Fourier в ZP,
[39:17.240 --> 39:21.240]  то есть там у нас будет только целые числа, никакой погрешности не будет.
[39:21.240 --> 39:23.240]  Вот это чуть позже еще тоже посмотрим.
[39:30.240 --> 39:32.240]  Вот сейчас мы этим и займемся, да.
[39:34.240 --> 39:37.240]  Сначала я хочу рассказать о разворачивании рекурсии.
[39:38.240 --> 39:40.240]  Разворачивание рекурсии.
[39:47.240 --> 39:49.240]  Так, смотрите, еще раз повторю наш алгоритм.
[39:49.240 --> 39:53.240]  Чтобы перемножить два многочлена, мне нужно написать, по сути, три FFT.
[39:53.240 --> 40:00.240]  Одно для P, одно для Q, потом поточно перемножить, потом обратное FFT для R.
[40:00.240 --> 40:02.240]  Ну а обратное FFT выражается через обычное.
[40:02.240 --> 40:06.240]  То есть по сути мне нужна одна функция FFT, которая там рекурсивно что-то делает.
[40:06.240 --> 40:11.240]  К сожалению, если мы напишем ее вот так рекурсивно, то это может работать довольно долго.
[40:11.240 --> 40:14.240]  То есть, казалось бы, N log N, но это довольно толстый N log N,
[40:14.240 --> 40:18.240]  потому что очень много, во-первых, очень много сложных вычислений,
[40:18.240 --> 40:21.240]  ну вот всякие степени Омеги и так далее.
[40:21.240 --> 40:25.240]  Это не очень простые операции, это не битовые сдвиги и ничего такое.
[40:25.240 --> 40:30.240]  Это большие сложные операции над длинными, ну дабовскими числами.
[40:30.240 --> 40:33.240]  Так, а во-вторых, здесь большие беды с памятью,
[40:33.240 --> 40:38.240]  потому что когда мы вспоминаем, есть у меня массив длины N коэффициентов,
[40:38.240 --> 40:42.240]  я четные сдвигаю влево, нечетные сдвигаю вправо,
[40:42.240 --> 40:46.240]  и потом как-то между ними вот так прыгаю, соединяю Омега в степени 2G,
[40:46.240 --> 40:49.240]  склеиваю как-то и ставлю в другую ячейку.
[40:49.240 --> 40:52.240]  То есть на самом деле у меня будут большие-большие скачки по памяти,
[40:52.240 --> 40:55.240]  это тоже влияет на время работы.
[40:55.240 --> 40:58.240]  Поэтому рекурсивный алгоритм довольно медленный.
[40:58.240 --> 41:02.240]  Давайте мы сейчас рекурсию развернем так, что у нас будет нерекурсивная реализация.
[41:02.240 --> 41:11.240]  Итак, давайте посмотрим, как работает FFT, скажем, на массиве длины 8.
[41:21.240 --> 41:29.240]  FFT принимает массив значений и воспринимает этот массив как набор коэффициентов коэффициентов многочлена.
[41:30.240 --> 41:33.240]  Затем происходит следующее.
[41:33.240 --> 41:37.240]  Мы четные индексы перемещаем как бы влево, это будет наш левый ветвый рекурсий.
[41:37.240 --> 41:43.240]  У нас будет многочлен с коэффициентами a0, a2, a4, a6.
[41:43.240 --> 41:49.240]  А вправое ветвье все нечетные, a1, a3, a5, a7.
[41:49.240 --> 41:54.240]  Ну и соответственно здесь опять на каждом шаге мы строим вот такой многочлен,
[41:54.240 --> 42:00.240]  a0 плюс a2x плюс a4x квадрат плюс a6x куб, то есть просто по этому набору коэффициентов строим многочлен.
[42:00.240 --> 42:05.240]  И рекурсивно находим его значения во всех точках, во всех корнях из единицы.
[42:05.240 --> 42:09.240]  Здесь в степени 4, тут в степени 8, ниже будет степень 2 и так далее.
[42:09.240 --> 42:13.240]  Давайте дорисуем это дерево до конца, посмотрим, что будет в самом низу.
[42:13.240 --> 42:18.240]  Здесь опять выписываем четное, то есть нелевое, и второй, a0, a4.
[42:18.240 --> 42:21.240]  Здесь нечетное, то есть a2 и a6.
[42:24.240 --> 42:28.240]  Здесь тоже четное, то есть a1 и a5.
[42:28.240 --> 42:31.240]  Нечетное, а3 и a7.
[42:31.240 --> 42:39.240]  То есть когда мы два раза спустимся в рекурсии, у меня уже будет многочлен всего с двумя коэффициентами в стиле a0 плюс a4x.
[42:39.240 --> 42:44.240]  И наконец последний шаг, это просто разбиение первых коэффициентов и вторых коэффициентов.
[42:44.240 --> 42:47.240]  Это будет наш последний уровень рекурсии.
[42:48.240 --> 42:53.240]  A1, a5, a3, a7.
[43:03.240 --> 43:06.240]  И еще раз, это мы нарисовали дерево рекурсии.
[43:06.240 --> 43:15.240]  И на каждом слое, в каждой вершине этого дерева алгоритм fft получает многочлен с n коэффициентами.
[43:15.240 --> 43:17.240]  Вот пусть здесь n равно 4.
[43:17.240 --> 43:21.240]  И находит значение этого многочлена во всех корнях за 1 степени n.
[43:21.240 --> 43:25.240]  То есть здесь во всех корнях четвертой степени, здесь во всех корнях восьмой степени.
[43:25.240 --> 43:27.240]  Здесь во всех корнях второй степени, здесь во всех корнях первой степени.
[43:28.240 --> 43:35.240]  Скажите, пожалуйста, чему равно значение вот такого многочлена в единственном корне за 1 степени 1?
[43:38.240 --> 43:40.240]  Что?
[43:40.240 --> 43:44.060]  А warum не institutions?
[43:44.060 --> 43:46.300]  Да, просто это число, конечно.
[43:46.300 --> 43:48.400]  Потому что на этом нижнем уровне у меня многочлен
[43:48.400 --> 43:53.000]  состоит из одного коэффициента, ну и этого свободного члена,
[43:53.000 --> 43:54.500]  тогда значение этого многочлена в любой точке
[43:54.500 --> 43:56.220]  – это оно само.
[43:56.220 --> 43:57.220]  Этот самый коэффициент.
[43:57.220 --> 44:04.280]  На нижнем уровне мы знаем, что сразу не только М spielt
[44:04.280 --> 44:05.460]  sweeping, но и значение multiplying в любой точке.
[44:05.460 --> 44:08.860]  Хорошо, теперь давайте посмотрим вот здесь.
[44:08.860 --> 44:16.240]  Тут у меня написан по сути многочлен а0 плюс а4х, а0 плюс а4х, и я хочу
[44:16.240 --> 44:21.580]  найти его значение в корнях из одни со степени 2, то есть в 1 и в минус
[44:21.580 --> 44:28.540]  1. Есть всего два корня степени 2, это 1 и минус 1, 1 и минус 1, но то есть понятно,
[44:28.540 --> 44:33.340]  как это сделать. Нужно писать а0 плюс а4 и а0 минус а4, теперь вместо вот
[44:33.340 --> 44:41.980]  этого вот массива я должен буду писать а0 плюс а4 и а0 минус а4. Я заменяю
[44:41.980 --> 44:44.900]  массив коэффициентов на массив значений вот в этих вот корнях из
[44:44.900 --> 44:48.300]  единиц. То, что там будет здесь, да, вот эти два числа поменяются на их сумму и
[44:48.300 --> 44:53.700]  разность. Вот, и мне хочется как-то вот сделать так, развернуть всю эту рекурсию
[44:53.700 --> 44:56.620]  снизу вверх, чтобы нашла, то есть на нижнем шаге у меня в каком-то порядке
[44:56.620 --> 45:00.820]  стоят коэффициенты, затем мне нужно, скажем, вот по парам их так склеить,
[45:00.820 --> 45:04.820]  написать сумму и разность. Здесь тоже сумма-разность, сумма-разность. Потом мне
[45:04.820 --> 45:08.500]  нужно вот эти две пары склеить в одну четверку, тоже как-то понять, с какими
[45:08.500 --> 45:12.860]  коэффициентными. Вот, и тем самым, как бы я не буду запускать рекурсию, я просто
[45:12.860 --> 45:19.540]  промоделирую ее в вычислении снизу вверх. Вот.
[45:19.540 --> 45:33.500]  Так, ну давайте, давайте смотреть. Во-первых, мне нужно понять, давайте сначала
[45:33.500 --> 45:37.660]  поймем, в каком порядке вот эти коэффициенты здесь написаны. То есть почему вдруг так
[45:37.660 --> 45:42.660]  случилось, что у меня на втором месте стоит А4, тут где-то А6, тут там А5 и так далее.
[45:42.660 --> 45:49.260]  Ну, это очень просто. Давайте считать, что у меня исходная длина массива N равна
[45:49.260 --> 45:54.740]  два в степенька, там на степени двойки. Тогда вот на этом нижнем уровне элементы
[45:54.740 --> 46:01.780]  будут написаны в порядке увеличения развернутой битовой записи. То есть у меня
[46:01.780 --> 46:05.220]  на самом деле будет написано следующее. Вот на этом нижнем уровне будет всегда
[46:05.220 --> 46:10.940]  написано А с индексом рев от нуля, А с индексом рев от единицы, и так далее, и так
[46:10.940 --> 46:15.920]  далее, А с индексом рев от N-1. Где рев — это просто разворачивание битовой
[46:15.920 --> 46:27.320]  записи или там вращение ее слева-направо. Как работают ревоты. Мы выписываем I как
[46:27.320 --> 46:39.320]  число в двоичной системе числения с K-знаками. То есть если она маленькая,
[46:39.320 --> 46:42.960]  то добиваем слева ведущими нулями. А затем просто разворачиваем эту
[46:42.960 --> 47:02.760]  запись слева-направо. Точнее справа-налево лучше сказать. Читаем справа-налево. На нашем
[47:02.760 --> 47:07.440]  конкретном примере в этом легко убедиться. Что такое у меня K? K это у меня тройка. То есть я
[47:07.440 --> 47:14.040]  все числа представляю как числа трехбитовая. Тогда что такое 0? 0 это то же самое, что 0,0,0,
[47:14.040 --> 47:19.760]  поэтому рев от него это тоже 0. И вначале у меня стоит А с индексом рев от нуля. Все верно. Дальше
[47:19.760 --> 47:25.720]  у меня идет единица. Я ее представляю как 001. Затем пишу реверс, разворачиваю строчку, читаю
[47:25.720 --> 47:31.920]  справа-налево. Будет 1,00. Ну это как раз 4. В двоичной записи это четверка. Поэтому здесь как раз стоит
[47:31.920 --> 47:40.160]  четверка. Давайте с двойкой то же самое еще сделаем. Двойка имеет запись 1,01, ее реверс такой же.
[47:40.160 --> 47:56.000]  В смысле 0,1,0 будет двойка. Дальше, если я тройку разверну, то у меня будет 1,1,0. То есть как раз
[47:56.000 --> 48:02.600]  шестерка, что и стоит на третьем месте, ну и так далее. На нашем частном примере в этом легко
[48:02.600 --> 48:08.240]  убедиться. А в общем случае это легко доказать, потому что смотрите, какие коэффициенты идут в
[48:08.240 --> 48:15.280]  левое поддерево? Те у которых младше бит 0. А 0, а 2, а 4 и так далее. Те у которых младше бит 0. Те,
[48:15.280 --> 48:22.600]  которые четные. Соответственно здесь все нечетные. Поэтому в терминах развернутой записи, если у них
[48:22.600 --> 48:29.880]  0 был последним, то здесь у них, наоборот, у меня вот это вот дерево бьется пополам, нижний слой
[48:29.880 --> 48:33.840]  делится пополам. И здесь идут все коэффициенты, меньше чем половинка, то есть у которых старше
[48:33.840 --> 48:38.260]  бит 0. А здесь идут те, у которых старше коэффициент 1. Больше половинки. Ну соответственно в реверсном
[48:38.260 --> 48:51.680]  порядке это как раз 0 в конце или 1 в конце. Можно за n. Ну давай чуть позже. Значит дальше
[48:51.680 --> 48:59.640]  спускаемся. Вот у меня есть а0, а2, а4, а6. Какие идут влево, какие идут вправо? Ну по сути что мы
[48:59.640 --> 49:08.800]  сделали? Раз мы налево положили все коэффициенты четные, а0, а2, а4, а6 и так далее. И тогда мы по
[49:08.800 --> 49:13.920]  сути у каждого числа, его номер в этом массиве поделили на два. То есть если мы половину элементов
[49:13.920 --> 49:20.360]  удалили, то скажем вот а4 встает на место, ну на второе место, а6 встанет на третье место. То есть
[49:20.360 --> 49:27.560]  каждый индекс поделится на два. Дальше то же самое. Мы смотрим на последний бит в записи. Вот это
[49:27.560 --> 49:35.080]  уже 0, 1, 2, 3. И последний бит становится как бы самым решающим. Те у которых последний бит 0 идут
[49:35.080 --> 49:39.560]  влево, те у которых последний бит 1 идут вправо. А в терминах вот этого как раз обратного порядка,
[49:39.560 --> 49:46.280]  это значит что второй, ну здесь же по, значит здесь второй с конца бит мы рассматривали. Здесь
[49:46.280 --> 49:51.320]  мы, наоборот, второй сначала бит рассматриваем. И здесь как раз, да, сначала идут те числа,
[49:51.320 --> 49:57.480]  у которых 0, 0, в тычной записи, потом 0, 1, потом 1, 0, потом 1, 1. В терминах, в терминах реверса,
[49:57.480 --> 50:02.520]  это как раз то, что нужно. Сначала те, у которых младший бит 0, потом те, у которых как бы
[50:02.520 --> 50:09.280]  предмладший бит 0, потом предмладший бит 1, ну и так далее. То есть это можно доказать, ну собственно,
[50:09.280 --> 50:15.680]  я и ПСАК как это доказывается, просто на каждом шаге у меня по сути смотрится там it и с конца бит.
[50:15.680 --> 50:20.640]  Если это it и слой рекурсии, то я смотрю на it и с конца бит и по его значению распределяю либо влево,
[50:20.640 --> 50:28.880]  либо вправо. Поэтому на it позиции вот в этом результившем массиве, вот в этом, будет стоять
[50:28.880 --> 50:38.800]  as индексом ревоты. Вот такой список у меня получается. Окей, вопросы? Хорошо. Так, ну как считать эти
[50:38.800 --> 50:44.560]  реверсы? Как считать эти реверсы? Ну как угодно на самом деле. Конечно, можно эти реверсы посчитать
[50:44.560 --> 50:49.440]  в самом начале за n log n, потому что, ну или там за два в степняка множество на k, потому что
[50:49.440 --> 50:54.960]  мне нужно посчитать реверсы для всех чисел от 0 до 2 в степняка минус 1, то есть для всех битовых
[50:54.960 --> 51:01.240]  чисел длины k. Можно просто честно для каждого числа написать эти k bit, прочитать справа налево и
[51:01.240 --> 51:06.280]  воспринимать как двоичное число. То есть каждое число я обработаю за его длину, и понятное дело,
[51:06.280 --> 51:12.360]  что это можно сделать за n log n просто. Все эти реверсы можно посчитать за n log n. Либо можно сделать
[51:12.360 --> 51:19.560]  это за линейное время. Давайте тоже такую оптимизацию напишем. Не то, что это сильно
[51:19.560 --> 51:23.760]  повлияет на время работы, потому что основная сложность все равно не в этом. Основная сложность
[51:23.760 --> 51:30.360]  в обращении к памяти и в сложных вычислениях. Ну если можно, то почему бы не сделать?
[51:30.360 --> 51:47.720]  Так, с реверсами можно поступать следующим образом. Давайте мы посмотрим на старший бит числа.
[51:47.720 --> 51:55.040]  Давайте будем смотреть на старший бит числа. И смотрите, вот если я знаю какой-нибудь здесь
[51:55.040 --> 52:03.040]  старший бит, старший бит нашего числа, тогда как выглядит у меня реверс? Мне нужно написать
[52:03.040 --> 52:08.920]  сначала вот этот кружочек реверснутый. Давайте я его назову S. Я сначала пишу S реверснутая,
[52:08.920 --> 52:13.400]  потом 1, потом вот это вот. Ну а здесь будет просто куча нулей. Если это старшие дницы,
[52:13.400 --> 52:21.000]  то здесь будет просто куча нулей. И если я знаю, что вот это текущий мой старший бит, то понятно,
[52:21.000 --> 52:25.400]  да? То есть я знаю вот это число текущее, у него старший бит стоит вот здесь. То если я его вычту,
[52:25.400 --> 52:30.840]  то я получу как бы число меньшее, для которого я уже знаю реверс. Если я напишу вот здесь вот
[52:30.840 --> 52:35.640]  нулик вместо единицы, то вот это число, которое просто заканчивается на S, равно S. Для него
[52:35.640 --> 52:39.520]  реверс я уже как бы знаю. Я знаю рев от S, потому что это меньшее число, до которого я уже как бы
[52:39.520 --> 52:44.120]  все посчитал. Так я мне нужно просто написать будет рев от S и прибавить к нему единицу на там нужной
[52:44.120 --> 52:50.320]  позиции. На позиции типа K минус и минус 1, если это и эта позиция. Ну а кон будет примерно такой.
[52:50.320 --> 53:01.800]  Рев от 0 равно 0. Дальше oldest равно минус 1. Когда-то мы уже находили старший бит в каждой маске. Теперь
[53:01.800 --> 53:15.720]  давайте перебираем маски от 1 до 2 степенька. Перебираем все маски в проект возрастания.
[53:15.720 --> 53:23.080]  Проверяем увеличится ли старший бит. Это мы тоже помним как делать. Старший бит у меня переключается,
[53:23.080 --> 53:29.240]  когда у меня число маски становится новой степенью двойки. Старший бит сначала не меняется,
[53:29.240 --> 53:34.280]  потом стал степенью двойки. Старший бит перешел в более старший разряд, а здесь все занулилось.
[53:34.280 --> 53:44.680]  Здесь мы пишем, если маска является степенью двойки, если маск и маск минус 1 равно 0, тогда oldest
[53:44.680 --> 53:54.760]  плюс-плюс. А дальше я могу, как я здесь говорил, я могу эту единичку исключить, могу выкинуть эту
[53:54.760 --> 54:00.200]  единицу. Я знаю, чему будет равен реверс для результата, и потом мне нужно будет просто эту единицу
[54:00.200 --> 54:11.320]  вставить в нужное место. Видимо, надо написать что-то типа такого. Реверс от маски равно реверс от маск
[54:11.320 --> 54:20.480]  XOR 1 меньше-менше oldest. Это я выкинул старший бит, посчитал реверс до вот этой оставшейся строки.
[54:20.480 --> 54:34.160]  Это я написал вот это, а еще мне нужно вставить эту единичку. И мне нужно еще вставить эту единичку.
[54:34.160 --> 54:47.160]  Ее можно вставить так. 1 меньше-менше k-oldest-1. Потому что после реверса вот эта позиция oldest
[54:47.160 --> 54:58.640]  встанет на место k-oldest-1. Ну вот вам подсчет реверсов за отn. Потому что у меня есть цикл по n
[54:58.640 --> 55:03.200]  числам, ну и внутри все за от1 считается, то есть мы обращаемся к какому-то уже посчитанному числу,
[55:03.200 --> 55:13.480]  а дальше какие-то битовые просто сдвиги к XOR и так далее. Так, окей? Хорошо. Все, мы разобрались с тем,
[55:13.480 --> 55:18.200]  как выглядит этот последний уровень. И давайте прям так и сделаем. Вот был у меня исходный массив А,
[55:18.200 --> 55:26.040]  вот этот А0, А1 и так далее А7. Давайте я сначала посчитаю все реверсы, заведу новый массив там,
[55:26.040 --> 55:32.880]  не знаю, какой-нибудь B и сейчас. Нет-нет-нет, новый массив мне даже не нужен. Секунду.
[55:32.880 --> 55:44.360]  Я забыл. То есть на самом деле еще одна прелесть FFT, что его можно вот прям на том же массиве писать,
[55:44.360 --> 55:49.440]  что исходной. То есть вам выдали массив длины n и вот прям на том же месте, без привлечения до
[55:49.440 --> 55:53.920]  памяти. Считайте все вот это вот дерево. И вот сейчас мне нужно каким-то образом переставить
[55:53.920 --> 56:01.800]  эти элементы так, чтобы они шли вот в этом порядке. Так, что-то я не помню как делается.
[56:23.920 --> 56:44.840]  Ну это слишком сложно. Ладно, в общем, давайте тогда на это забьем. Да, давайте скажем,
[56:44.840 --> 56:51.760]  что просто вот был у меня исходный массив А, А0, А1 и так далее, Аn-1. Я создаю новый массив,
[56:51.760 --> 56:59.880]  в котором располагаю А в этом порядке. То есть А с индексом ревод 0, А с индексом ревод 1 и так
[56:59.880 --> 57:04.640]  далее, А с индексом ревод n-1. Вот, в качестве упражнения можете подумать, как это сделать без
[57:04.640 --> 57:08.400]  привлечения вот этого массива. То есть как переставить вот эти элементы здесь так, чтобы они
[57:08.400 --> 57:13.840]  шли ровно в нужном порядке. Как их здесь переставить, чтобы они шли ровно в этом порядке. Без там,
[57:13.840 --> 57:19.680]  без до памяти, без копирований. Ну хорошо, неважно. Мы можем там в два раза себя расширить память,
[57:19.680 --> 57:25.040]  не страшно. Есть у меня теперь такой массив. То есть у меня по сути есть целиком информация о том,
[57:25.040 --> 57:31.080]  что будет в этом нашем дереве на нижнем уровне. Теперь давайте научимся подниматься снизу вверх.
[57:31.080 --> 57:35.200]  Вот есть у меня информация про нижний уровень, я хочу посчитать информацию на предыдущем уровне.
[57:35.200 --> 57:41.440]  Потом на этом, потом на этом. Давайте сразу скажем, что пусть у меня есть информация там на каком-нибудь
[57:41.440 --> 57:58.320]  и там с конца уровня. Значит пусть мы знаем состояние массива на житом снизу уровня,
[57:58.320 --> 58:12.960]  житом снизу уровня. Ну и в массиве лежат просто числа a0, a1 и так далее an-1. То есть еще раз,
[58:12.960 --> 58:19.560]  даже если делать все на одной памяти, то есть у меня как-то там переставляется числа, ну или там
[58:19.560 --> 58:22.960]  можно сказать, что я вот этот массив завел сюда, сюда их поставил в нужном порядке, потом просто
[58:22.960 --> 58:27.840]  перезаписал на место первого. То есть я первый массив теряю, у меня уже нет информации про исходный
[58:27.840 --> 58:32.280]  набор коэффициентов a0 и так далее an-1, мне он будет не нужен. У меня сейчас вот есть текущая
[58:32.280 --> 58:36.360]  информация, я считаю, что набор вот этих ашек это вот эта вот перестановка, вот в самом конце.
[58:36.360 --> 58:40.680]  Потом я поднялся как-то, посчитал набор вот здесь, вот здесь и так далее и так далее,
[58:40.680 --> 58:44.880]  поднимаюсь снизу вверх. И пусть у меня в какой-то момент написано вот такой вот массив ашек.
[58:44.880 --> 58:53.080]  Тогда, ну давайте считаем, что здесь на этом уровне у меня ж равно нулю будет, здесь будет
[58:53.080 --> 59:01.480]  ж1, здесь ж2, здесь ж3, ж снизу. Тогда смотрите, чтобы перейти к ж плюс первому уровню снизу,
[59:01.480 --> 59:11.600]  мне нужно разбить все мои ашки на куски по 2 в степени ж и объединить их в большой кусок длины
[59:11.600 --> 59:18.720]  2 в степени ж плюс 1. У меня корзинка какая-то такая, вот есть мой большой массив, я его разбиваю на
[59:18.720 --> 59:30.880]  блоке длины 2 в степени ж, 2 в степени ж, 2 в степени ж и так далее. И потом парами их объединяю
[59:30.880 --> 59:36.480]  в длинный блок длины 2 в степени ж плюс 1. Вот это будет блок длины 2 в степени ж плюс 1, вот это,
[59:36.480 --> 59:43.440]  ну и так далее. И что это значит? Это значит, что вот был у меня какой-то массив коэффициентов
[59:43.960 --> 59:49.800]  на этом шаге, да. Вот эти два кружочка переходят в этот прямоугольник, вот так. Был у меня какой-то
[59:49.800 --> 59:54.760]  массив коэффициентов, я разбил и чётный коэффициент отправил сюда, а не чётный отправил сюда,
[59:54.760 --> 59:58.800]  затем рекурсивно нашел значение вот этого многош painters во всех нужных точках и вот этого
[59:58.800 --> 01:00:02.480]  многошmakerperson тоже во всех нужных точках я нашел значение. Теперь мне нужно найти значение вот
[01:00:02.480 --> 01:00:09.860]  этого многошмином во всех точках. Нет-нет, рекурсию мы разворачиваем. От вас у нас будет
[01:00:09.860 --> 01:00:13.580]  просто цикл пожи сейчас. То есть мы сначала развернули вот эти все нижние
[01:00:13.580 --> 01:00:19.060]  индексы, и теперь у меня будет цикл пожи от нуля до там логарифма, до подъема в корень.
[01:00:39.860 --> 01:00:45.220]  Так, давайте попишем формулу. Вот есть у меня какой-то массив коэффициентов, он
[01:00:45.220 --> 01:00:53.180]  развивается на 2, и здесь я все знаю. Давайте я назову это многочленом t, и
[01:00:53.180 --> 01:00:59.940]  соответственно он выглядит как-то так. Это там какой-то a и t, плюс a и плюс первое x,
[01:01:00.420 --> 01:01:14.200]  плюс так далее. Плюс а с индексом и, плюс 2 в степени g, плюс 1, минус 1, x в степени 2 в степени g,
[01:01:14.200 --> 01:01:18.980]  плюс 1, минус 1. Что-то такое страшное. Короче, я понимаю, что длина этого многочлена у меня 2 в
[01:01:18.980 --> 01:01:23.320]  степени g, 2 в степени g плюс 1, 2 в степени g плюс 1 коэффициент у него. Соответственно,
[01:01:23.320 --> 01:01:27.940]  максимальная степень здесь будет 2 в степени g плюс 1, минус 1. Ну и h здесь
[01:01:27.940 --> 01:01:32.340]  соответствующим индексам. То есть это какой-то кусок, скажем, вот этот кусочек,
[01:01:32.340 --> 01:01:44.660]  или вот этот. Это а1, а3, а5, а7. Так, сейчас. Х в степени 2 в степени g плюс 1,
[01:01:44.660 --> 01:02:03.820]  минус 1. Так, секунду. Да, хорошо. Вот. Тогда, соответственно, я отправляю аi, аi плюс 2 и так
[01:02:03.820 --> 01:02:10.020]  далее сюда, сюда аi плюс 1, аi плюс 3 и так далее вот сюда. Хорошо. И причем я знаю, давайте тоже
[01:02:10.020 --> 01:02:16.980]  напишем, что t от x это то, что мы отправляем налево, t0 от x в квадрате плюс x на то, что мы
[01:02:16.980 --> 01:02:23.340]  отправляем направо, t1 от x в квадрате. Здесь будет t0, здесь будет t1, а здесь нагрешен t. То есть я просто
[01:02:23.340 --> 01:02:30.060]  любой нагрешен всегда в рекурсе разбиваю на 2 почетным индексом и понечетным. Так, теперь смотрите,
[01:02:30.060 --> 01:02:34.560]  вот здесь вот я знаю значение во всех нужных точках, и здесь тоже хранятся значения во всех
[01:02:34.560 --> 01:02:44.880]  нужных точках. Теперь давайте попробуем понять. Значит, пусть ω это корень из единицы в степени
[01:02:44.880 --> 01:02:57.520]  2g плюс 1, тогда я ищу значение t во всех корнях омеги этой степени, то есть во всех степенях омеги.
[01:02:57.520 --> 01:03:07.500]  Ищем t от омега в нулевой, t от омега в первой, и так далее, t от омега. Давайте вот это как-нибудь
[01:03:07.500 --> 01:03:22.000]  обозначу за g большое, допустим, g минус 1. Так, ну хорошо, давайте поймем. Здесь у меня где-то будет
[01:03:22.000 --> 01:03:29.400]  серединка. Для левых чисел у меня будет простое выражение. Например, там что такое t от омега в
[01:03:29.400 --> 01:03:39.400]  степени g? Нет, g плохо, g у меня уже занято. И gk, пусть будет s, омега в степени s. Вот если я просто
[01:03:39.400 --> 01:03:54.560]  сюда подставлю, это что такое? Это t нулевое от омега 2s плюс омега в степени s, t1 омега 2s. Вот, это
[01:03:54.560 --> 01:04:07.840]  если у меня s меньше чем половинка. А если у меня, ну а для больших у меня будет следующее выполняться,
[01:04:07.840 --> 01:04:14.120]  у меня будет 1 вторая g плюс s равно t0. А здесь смотрите, здесь проблема следующая, что когда я
[01:04:14.120 --> 01:04:21.080]  умножаю вот этот вот показатель в два раза, умножаю на 2, у меня s переходит как бы в 2s. И если у меня s
[01:04:21.080 --> 01:04:27.800]  близко к g, то у меня как бы происходит перехлёс вот на окружности. У меня была такая окружность, у меня
[01:04:27.800 --> 01:04:32.160]  омега в степени s была где-то здесь. То есть оно вот так прошло, и еще степень умножается в два раза.
[01:04:32.160 --> 01:04:36.680]  То есть по сути я как бы два раза прохожу этот круг, и там где-то останавливаюсь, омега в степени 2s.
[01:04:36.680 --> 01:04:45.680]  Вот, и для этого, чтобы не было вот этого перехода за, ну лишнего перехода за единицу, я вычленяю
[01:04:45.680 --> 01:04:52.240]  отдельно вот этот вот слагаемый 1 вторая 1 вторая g. И у меня тогда что будет здесь? У меня будет
[01:04:52.240 --> 01:04:59.000]  ну формально тоже омега в степени 2s плюс g, но мы знаем что омега в степени g это единица. Омега
[01:04:59.000 --> 01:05:04.080]  в степени g это единица, потому что омега это корень за единицей степени g большой. Поэтому
[01:05:04.080 --> 01:05:09.200]  здесь на самом деле вот это вот 1 вторая g не влияет на аргумент. Здесь остается омега в степени 2s,
[01:05:09.200 --> 01:05:16.560]  здесь будет что? Здесь будет плюс омега в степени 1 вторая g плюс s. Но понятно
[01:05:16.560 --> 01:05:20.980]  что омега в степени 1 вторая g это просто минус 1. Потому что если омега в g это единица,
[01:05:24.240 --> 01:05:29.880]  то омега в степении 1 вторая g это минус 1. Ну и мы считаем, что g четное, g это степень
[01:05:29.880 --> 01:05:36.880]  Поэтому вот здесь вот будет написано минус омега в эстой на то же t1 от омега в степени 2s.
[01:05:36.880 --> 01:05:48.880]  Так, давайте еще раз повторю. Мы взяли омегу как корень степени g большой из 1.
[01:05:48.880 --> 01:05:51.880]  Омега в g это равно единице, омега в степени g большой равно единице.
[01:05:51.880 --> 01:05:55.880]  Тогда у меня есть много точек, в которых я хочу посчитать значение t.
[01:05:56.880 --> 01:06:02.880]  Вот этого исхода многошлина t. У меня есть омега в нулевой, омега в первой и так далее и так далее, вплоть до омега в степени g минус 1.
[01:06:02.880 --> 01:06:12.880]  Хорошо, что такое t от омега в степени s? Если s достаточно маленькая, если s это меньше, чем 1 вторая g, то это просто я поставил вот в эту формулу омега в степени s.
[01:06:12.880 --> 01:06:17.880]  Здесь будет t0 от омега в 2s, t1 от омега в 2s с каким-то коэффициентом.
[01:06:17.880 --> 01:06:26.880]  Дальше, если омега хотя бы 1 вторая g, то степень больше равна, чем половина от всех коэффициентов, от всех вот этих вот корней,
[01:06:26.880 --> 01:06:34.880]  тогда смотрите, когда она удваивается, то здесь мне нужно написать формуль 2s плюс g, потому что вот это множество на 2 будет g.
[01:06:34.880 --> 01:06:38.880]  Но омега в g это единица, поэтому она не влияет на результат.
[01:06:38.880 --> 01:06:46.880]  Здесь я могу написать плюс g, плюс g вот здесь в показателе, но это не повлияет на результат, я могу это стереть, потому что омега в g это единица.
[01:06:46.880 --> 01:06:50.880]  То же самое здесь, я пишу просто омега в степени 2s.
[01:06:50.880 --> 01:06:59.880]  Но вот этот вот коэффициент перед вторым слагаемым был раньше плюс омега в s, а теперь это омега в s, омега в степени s,
[01:06:59.880 --> 01:07:05.880]  еще плюс 1 вторая g в степени. Но омега в степени 1 вторая g это минус единица.
[01:07:05.880 --> 01:07:11.880]  Омега в степени 1 вторая g это минус единица, ну потому что если у меня g большой в отчетности, g большой это степень двойки,
[01:07:11.880 --> 01:07:16.880]  то тогда омега в степени 1 вторая g это как раз минус 1, противоположный к единице корень.
[01:07:16.880 --> 01:07:19.880]  Значит здесь просто можно поменять плюс на минус.
[01:07:19.880 --> 01:07:25.880]  Итого, смотрите, что получилось. Если я возьму какие-то два соответствующие корни c0 и t1,
[01:07:25.880 --> 01:07:29.880]  два какие-то значения, вот там st значение здесь и s значение здесь,
[01:07:29.880 --> 01:07:35.880]  то тогда с помощью их линейной комбинации с коэффициентами омега в s или минус омега в s,
[01:07:35.880 --> 01:07:43.880]  я могу посчитать вот здесь вот st член, а также коэффициент с номером s плюс 1 вторая g.
[01:07:47.880 --> 01:07:55.880]  То есть еще раз, у меня st и s плюс 1 вторая gt, вот эти вот значения, они зависят от двух чисел,
[01:07:55.880 --> 01:07:59.880]  t0 от омега в степени 2s и t1 от омега в степени 2s.
[01:07:59.880 --> 01:08:02.880]  То есть по сути я просто беру вот эти вот числа, которые здесь у меня уже посчитаны,
[01:08:02.880 --> 01:08:07.880]  и с помощью какого-то преобразования получаю значение вот здесь и вот здесь.
[01:08:07.880 --> 01:08:13.880]  Причем эти ячейки, даже можно получше нарисовать, эти ячейки лежат прямо над ними,
[01:08:13.880 --> 01:08:19.880]  то есть вот здесь же, в этой позиции, это лежит вот здесь же, в позиции s плюс 1 вторая g.
[01:08:19.880 --> 01:08:21.880]  Смысл такой.
[01:08:32.880 --> 01:08:36.880]  В итоге мы получаем следующий алгоритм.
[01:08:36.880 --> 01:08:42.880]  Считаем, что у меня на нижнем уровне все посчитано, вот эти вот реверснутые ашки уже написаны.
[01:08:42.880 --> 01:08:51.880]  Теперь давайте перебирать g от нуля до k, видимо.
[01:08:51.880 --> 01:08:57.880]  То есть будет переход от житого слоя к g плюс 1.
[01:09:03.880 --> 01:09:07.880]  Так, сейчас. Что-что?
[01:09:07.880 --> 01:09:10.880]  Ну вроде нет, потому что у меня в примере было k равно тройке,
[01:09:10.880 --> 01:09:14.880]  и я переходил от нуля к первому, от первого к второму, от центрового к третьему.
[01:09:14.880 --> 01:09:17.880]  То есть вроде заканчивается на камен с первым шагом.
[01:09:17.880 --> 01:09:22.880]  Четыре уровня внутри перехода.
[01:09:22.880 --> 01:09:32.880]  Так, и меньше, чем n.
[01:09:32.880 --> 01:09:37.880]  Так, сейчас надо будет внимательно быть, сейчас я напишу.
[01:09:37.880 --> 01:09:41.880]  Видимо, 2 в степени g плюс 1, да?
[01:09:41.880 --> 01:09:45.880]  Так, ну здесь я вольно напишу 2 в степени g плюс 1.
[01:09:45.880 --> 01:09:50.880]  Понятно, что в плюсах это 1 меньше, меньше g плюс 1.
[01:09:50.880 --> 01:09:55.880]  Степени-то? Нет, степени не надо предпочитывать, сдвиг работает моментально.
[01:09:55.880 --> 01:09:58.880]  Сдвиг работает быстрее, чем вращение в память.
[01:09:58.880 --> 01:10:01.880]  Поэтому лучше это не делать.
[01:10:01.880 --> 01:10:09.880]  Итак, смотрите, вот это вот моя текущая позиция, куда я буду складывать ответ.
[01:10:09.880 --> 01:10:15.880]  И у меня сначала вот здесь, я колею какие-то два результата, потом и будет вот здесь, и так далее.
[01:10:15.880 --> 01:10:17.880]  И теперь смотрите, что мне нужно.
[01:10:17.880 --> 01:10:30.880]  Мне нужно перебрать s-ку от нуля до половинки g, то есть до 2 в степени g.
[01:10:30.880 --> 01:10:33.880]  Так?
[01:10:33.880 --> 01:10:36.880]  Пишем, давайте следующее.
[01:10:36.880 --> 01:10:44.880]  x равно, давайте напишу array, вот то, что у меня хранится в массиве, я буду называть array.
[01:10:44.880 --> 01:10:55.880]  array от i плюс s, y равно array от i плюс s плюс 2 в степени g.
[01:10:55.880 --> 01:11:02.880]  То есть в этой формуле я взял вот это вот за x, первое слагаемое x, второе слагаемое без коэффициента за y.
[01:11:02.880 --> 01:11:05.880]  То есть вот эти вот два числа, из которых я сейчас буду все склеивать.
[01:11:05.880 --> 01:11:07.880]  Вот это и вот это, это x и y.
[01:11:07.880 --> 01:11:12.880]  Соответственно, это лежит в позиции i плюс s, это в позиции i плюс s плюс 2 в степени g.
[01:11:12.880 --> 01:11:13.880]  Так?
[01:11:13.880 --> 01:11:21.880]  И мне нужно просто на те же самые позиции i плюс s и i плюс s плюс 2 в степени g в этом массиве перезаписать их вот такую вот комбинацию.
[01:11:21.880 --> 01:11:23.880]  Ну давайте так и напишем.
[01:11:23.880 --> 01:11:38.880]  То есть array i плюс s равно x плюс омега, сейчас, сейчас, омега вестой, да, омега вестой y.
[01:11:38.880 --> 01:11:50.880]  И array i плюс s плюс 2 в степени g равно x минус омега вестой умножить на y.
[01:11:50.880 --> 01:11:54.880]  Вот, кажется, это все. Скопка, скопка, скопка.
[01:11:57.880 --> 01:11:59.880]  Так.
[01:12:02.880 --> 01:12:10.880]  Ну и по сути мы как раз развернули рекурсию, мы смогли от предыдущего слоя как бы перейти к следующему, ну то есть следующему вверх.
[01:12:10.880 --> 01:12:13.880]  Давайте повторю еще раз концепцию, что здесь произошло.
[01:12:13.880 --> 01:12:24.880]  Смотрите, мы считаем, что вот в этот момент времени, после входа в очередную трассу цикла по g, у меня есть какое-то состояние массива array.
[01:12:24.880 --> 01:12:35.880]  Там лежат какими-то блоками длины 2 в степени, ну 2 в какой-то степени, 2 в степени g, лежат значения каких-то многочленов в каких-то корнях за единицей.
[01:12:35.880 --> 01:12:41.880]  Вот такие значения вот здесь, да? Это корню многочлена в каких-то корнях из единицы, это корни другого, извините, а не корня, а значения.
[01:12:41.880 --> 01:12:46.880]  Значения многочлена в каких-то корнях из единицы. Тут значения другого многочлена, тут другого и тут другого.
[01:12:46.880 --> 01:12:53.880]  Моя цель их разбить по парам, и из вот этих вот значений и вот этих получить значение большего многочлена в большем числе корня из единиц.
[01:12:54.880 --> 01:13:00.880]  То есть вот эти два склеить сюда. Эти два, опять, это какие-то значения двух многочленов, мне нужно из них получить значение большего многочлена.
[01:13:00.880 --> 01:13:07.280]  Значит, это я здесь и делаю. Я перебираю в качестве i вот этот вот стартовый индекс блока, где
[01:13:07.280 --> 01:13:10.760]  будет лирать значение большего многочлена, то есть вот это вот, мне нужно перебирать вот это,
[01:13:10.760 --> 01:13:16.280]  вот это и так далее. Это как раз будет i с шагом 2 в степени g плюс 1, потому что получается у меня
[01:13:16.280 --> 01:13:22.800]  больше многочлена размера 2 в степени g плюс 1. Ну а дальше делаю то магическое преобразование,
[01:13:22.800 --> 01:13:27.820]  которое там написано. Я пробегаюсь по всем этим элементам, индексом s параллельно вот так вот,
[01:13:27.820 --> 01:13:34.180]  s вот так бежит. Ну потом как-то мы там доказали формулой, что если я возьму соответствующие
[01:13:34.180 --> 01:13:39.420]  элементы s ты здесь и s ты здесь, то их можно с помощью какой-то линейной комбинации перезаписать
[01:13:39.420 --> 01:13:48.820]  в s ты сюда и в s ты сюда, то есть в s ты и s плюс 2 в степени g индекса. Вот это делается таким
[01:13:48.820 --> 01:13:55.700]  вот преобразованием. И здесь как раз еще профит, что мне не нужно на каждом шаге заводить новый
[01:13:55.700 --> 01:14:02.780]  массив. То есть я взял вот эти два числа x и y с каких-то двух позиций, их нужным образом сложил и
[01:14:02.780 --> 01:14:08.020]  записал прямо на те же позиции, где они лежали, на те же самые позиции и plus s и plus s плюс 2 в
[01:14:08.020 --> 01:14:13.340]  степени g. То есть я не привлекаю новой памяти, мне не нужен новый массив, чтобы все это пересчитать,
[01:14:13.340 --> 01:14:18.180]  я прям делаю на месте, прям там же, где были все эти исходные числа. Мне не нужно будет дергать
[01:14:18.180 --> 01:14:25.100]  всякие new, создавать новые векторы и так далее. Я прям все делаю там же, где числа лежат. Так,
[01:14:25.500 --> 01:14:30.820]  ну здесь еще нужны какие-то оптимизации, типа как считать омегу в s, как считать все эти корни.
[01:14:30.820 --> 01:14:42.140]  Так, ну давайте поймем, как это сделать. Ну можно вот здесь вот сказать, что омега это корень нужной
[01:14:42.140 --> 01:14:54.700]  степени. Так, только видимо не s, а 2s. Нет, омега это корень из 1 степени 2 в степени g
[01:14:54.700 --> 01:14:59.780]  плюс 1. Вот здесь я сначала начитал омегу, как-нибудь там написал, что просто написал
[01:14:59.780 --> 01:15:05.980]  честные координаты, что это cos 2p делить на n и sin 2p делить на n, где n это вот это вот.
[01:15:05.980 --> 01:15:16.540]  Ну можно так, но это неважно, потому что у нас все равно итерация логарифом, можно пересчитывать,
[01:15:16.540 --> 01:15:20.660]  можно там ее изначально где-нибудь завести, потом степень его завести. Можно так.
[01:15:20.660 --> 01:15:36.580]  Да, на самом деле это не обязательно. Если у меня есть омега, то здесь я перебираю степень
[01:15:36.580 --> 01:15:40.700]  омега в порядке возрастания. Поэтому на самом деле я могу хранить просто текущую степень омега и
[01:15:40.700 --> 01:16:00.620]  умножать ее на омегу каждый раз. Я вас понял. Действительно, наверное, так лучше сделать,
[01:16:00.620 --> 01:16:05.060]  что вот здесь мы посчитали омегу, а также давайте в этом же месте посчитаем все ее степени. Просто
[01:16:05.060 --> 01:16:09.700]  заведем массивчик степеней, где сохраним омегу в нулевой, омега в первой и так далее, омега в
[01:16:09.700 --> 01:16:26.700]  степени, ну вот там максимум 2 в степени g плюс 1. Даже если можно, да, кажется можно, потому что
[01:16:26.700 --> 01:16:32.340]  все независимо. Действительно кажется, что можно, но здесь я думаю, что это будет хуже, потому что вы
[01:16:32.340 --> 01:16:36.300]  больше скачете по памяти. То есть вы смотрите, вы посчитали вот это, потом вот это, потом вот это,
[01:16:36.820 --> 01:16:40.780]  потом вот это, вот это, вот это. Вы очень много скачете по памяти. А у меня чуть более локальные
[01:16:40.780 --> 01:16:47.060]  вычисления, то есть я сначала здесь все посчитал, потом вот здесь, потом вот здесь. Согласны? Скорее
[01:16:47.060 --> 01:16:53.700]  всего так можно, да, но будет больше прыжков. То есть даже если так удобнее, то скорее всего это
[01:16:53.700 --> 01:17:01.580]  будет менее эффективно. Ну вот, то есть я предпочитал все степени омега, а дальше вот здесь я не буду
[01:17:01.580 --> 01:17:05.740]  уже там омега бинарного степени s или что-нибудь такое. Я просто возьму из этого массива, который
[01:17:05.740 --> 01:17:11.820]  я предпочитал. Вот, а все остальные операции, они у меня уже там просто сложение. Еще смотрите,
[01:17:11.820 --> 01:17:16.780]  можно немножко оптимизировать. Можно вот здесь написать умножить на омега в степени s, а здесь
[01:17:16.780 --> 01:17:21.340]  стереть вот эти коэффициенты. Чтобы не умножать два раза, а только один, можно изначально предпочитать
[01:17:21.340 --> 01:17:31.980]  и сделать вот так. х плюс у, х минус у. Чтобы просто там еще чуть-чуть ускорить. Потому что,
[01:17:31.980 --> 01:17:37.940]  ну на самом деле здесь все довольно жестоко все обычно с тайм-лимитом в этих задачах на FFT,
[01:17:37.940 --> 01:17:43.020]  потому что много всяких вычислений, много скачков по памяти. В общем, здесь иногда придется
[01:17:43.020 --> 01:17:46.780]  поупихивать. Еще особенно с точностью, если это, ну это ладно.
[01:17:46.780 --> 01:18:13.980]  Типа, чтобы сумму, в смысле не складывать и плюс с, а обращаться к какой-то ячейке.
[01:18:16.780 --> 01:18:31.580]  А как одна переменная, типа плюс-плюс делать? И потом делать плюс-плюс? А вы про то,
[01:18:31.580 --> 01:18:38.780]  чтобы два раза не складывать, а просто завести в одну переменную? Да бог его знает, мне кажется,
[01:18:38.780 --> 01:19:03.220]  не особо уже. Так, ну это я уже не знаю, что там оптимизирует компилятор или нет. Ну в общем,
[01:19:03.220 --> 01:19:08.020]  да, то есть здесь как бы, ну вообще на самом деле этого кода скорее всего хватит, да, но если вам
[01:19:08.020 --> 01:19:12.100]  надо еще поупихивать, то какие-нибудь такие, да, можно вот это вот объявить отдельной переменной
[01:19:12.100 --> 01:19:17.340]  и не считать ее два раза. То же самое вот с этой. Как-то можно, да, но это уже такое, совсем какая-то
[01:19:17.340 --> 01:19:22.820]  жесть. Так, последний сюжет, который я хочу рассказать, это отказ от комплексных чисел.
[01:19:22.820 --> 01:19:33.860]  Отказ от комплексных чисел и переход в ZP. Переход в ZP. Значит, смотрите, предположим,
[01:19:33.860 --> 01:19:38.020]  что у вас задача такая, что вам нужно не просто, ну то есть вам не нужно перемножить многочлены
[01:19:38.020 --> 01:19:45.660]  прям точно, вам нужно их перемножить в ZP, то есть найти все коэффициенты по модулю P. Тогда работает
[01:19:45.660 --> 01:19:57.460]  следующий интересный факт, что если P имеет вот такой вот вид 2 в степенька на R плюс 1, то есть ну понятно,
[01:19:57.460 --> 01:20:02.700]  что если P достаточно большое, то оно нечетное, мы вычисляем енишку и вычисляем максимальную
[01:20:02.700 --> 01:20:10.980]  степень двойки из результатов. То есть P равно 2 в степенька умножить на R, где R нечетно. То
[01:20:10.980 --> 01:20:17.380]  оказывается, в ZP есть такое число, что все его степени, нулевая, первая, вторая, третья и так далее,
[01:20:17.380 --> 01:20:27.460]  вплоть до 2 в степени катой, все различны. То существует такой элемент из ZP, что омега в нулевой,
[01:20:27.460 --> 01:20:33.300]  омега в первой и так далее и так далее, омега в степени 2 в степенька минус 1, попарно различны.
[01:20:33.300 --> 01:20:42.820]  И по сути нам ровно это и нужно было от поликомплексных чисел. Нам нужно было
[01:20:42.820 --> 01:20:51.020]  уметь из единицы извлечь кучу корней. Кучу корней, ну там 2 в степеньках корней. Оказывается,
[01:20:51.020 --> 01:20:55.620]  что в ZP, если вот это вот K достаточно большое, то в ZP мы можем тоже такое же делать. То есть
[01:20:55.620 --> 01:21:01.500]  есть такая омега, что все ее степени различны, но при этом это корень из единицы в степени 2 в
[01:21:01.500 --> 01:21:07.100]  степенька. То есть в некоторых ZP, точнее, если P вот такое хорошее и K достаточно большое,
[01:21:07.100 --> 01:21:16.460]  то мы можем найти омегу со всеми нужными свойствами. То есть мне от комплексных чисел
[01:21:16.460 --> 01:21:21.140]  нужно было только, что есть корень из единицы вот такой степени, что все его вот эти вот степени
[01:21:21.140 --> 01:21:28.180]  различны. Больше мне ничего от комплексных по сути не нужно было. Ну, значит, если у меня P
[01:21:28.180 --> 01:21:32.340]  достаточно хорошее, то есть такое, что K достаточно большое, и я могу извлекать корни
[01:21:32.340 --> 01:21:37.900]  достаточно больших степеней, то у меня просто все вычисления из C можно отнаследовать в ZP,
[01:21:37.900 --> 01:21:51.620]  и уже не будет никаких пробен с точностью. Вот классический пример P вот такой. 9,9,8,
[01:21:52.500 --> 01:22:02.580]  3,5,3, очень часто, ну то есть. Я хотел сказать на практике, но это, конечно, нет, но там на всяких
[01:22:02.580 --> 01:22:08.900]  контестах на codeforces, если нужные FFT и авторы не хотят считать в комплексных, то они просто пишут
[01:22:08.900 --> 01:22:17.260]  вот такое P. Оно хорошо в следующем, что у него действительно большое K. Оно раскладывается вот
[01:22:17.260 --> 01:22:21.860]  Вот так вот. Здесь х23. То есть по сути, мы тогда умеем перемножать все многочлены,
[01:22:21.860 --> 01:22:26.860]  у которых результирующая степень произведения меньше, чем 2 в степени 23.
[01:22:26.860 --> 01:22:30.360]  Но это большое число, поэтому почти любые многочлены можем перемножить.
[01:22:30.360 --> 01:22:34.660]  Ну и здесь подойдет, например, омега равная 31.
[01:22:34.660 --> 01:22:38.060]  Если вы честно напишите программу, которая перебирает все степени омега
[01:22:38.060 --> 01:22:44.960]  от 0 до 2 в степени 23 минус 1, вы можете убедиться, что все они попарно различны.
[01:22:44.960 --> 01:22:48.460]  И при этом омега в степени 2 в степени 23 – это единица.
[01:22:48.460 --> 01:22:52.760]  То есть как раз вот это число является тем самым примитивным корнем из единицы.
[01:22:52.760 --> 01:22:56.760]  Там любой степень, какой вам нужно.
[01:22:56.760 --> 01:23:00.660]  И замечательно тем, что не нужно никаких комплексных чисел,
[01:23:00.660 --> 01:23:05.160]  нет никаких погрешностей и так далее.
[01:23:05.160 --> 01:23:11.760]  Ну да, тоже правда, считается быстрее.
[01:23:11.760 --> 01:23:15.360]  Но если вы там 10 раз это напишете, то да.
[01:23:15.360 --> 01:23:19.360]  Вы про вот эти числа?
[01:23:19.360 --> 01:23:23.860]  Вот, еще смотрите, как найти вот эту омегу.
[01:23:23.860 --> 01:23:26.360]  То есть если у вас в задаче написано P какой-нибудь,
[01:23:26.360 --> 01:23:30.860]  и вам нужно сделать преобразование флея по модулю ZP,
[01:23:30.860 --> 01:23:33.860]  то найти омегу в принципе можно простым перебором.
[01:23:33.860 --> 01:23:36.860]  Давайте запустим цикл. То есть понятно, что омегу достаточно найти один раз,
[01:23:36.860 --> 01:23:38.560]  и потом ее просто много раз переиспользовать.
[01:23:38.560 --> 01:23:42.560]  Давайте напишем цикл перебора омеги 2, 3, 4, 5 и так далее,
[01:23:42.560 --> 01:23:45.560]  и проверяем, что все степени различны, и омегов 2 вкат – это единица.
[01:23:45.560 --> 01:23:49.560]  Ну и вот утверждается, что вы там найдете подходящую омегу довольно скоро,
[01:23:49.560 --> 01:23:51.560]  потому что вот этих вот таких корней их на самом деле много.
[01:23:51.560 --> 01:23:54.560]  То есть он далеко не один такой,
[01:23:54.560 --> 01:23:58.560]  и очень часто вы найдете там коинь, ну не знаю,
[01:23:58.560 --> 01:24:01.560]  в районе вроде сотни или даже меньше.
[01:24:01.560 --> 01:24:04.560]  То есть корней таких много, вы можете их легко находить просто каким-нибудь предпочетом.
[01:24:04.560 --> 01:24:07.560]  Сначала нашли, потом используете.
[01:24:07.560 --> 01:24:12.560]  Вот. А еще, зачем это может быть нужно? Зачем вычислять zp?
[01:24:12.560 --> 01:24:17.560]  Ну, смотрите, пусть у вас есть все-таки два многочлена, которые нужно перемножить.
[01:24:17.560 --> 01:24:22.560]  И вы знаете, что их коэффициенты в результате сильно больше 10 в 11 и 10 в 12.
[01:24:22.560 --> 01:24:25.560]  Ну, например, у вас есть два многочлена степени 10 в 5,
[01:24:25.560 --> 01:24:27.560]  у которых все коэффициенты по модулю 10 в 5.
[01:24:27.560 --> 01:24:31.560]  Тогда при произведении у вас будут коэффициенты до 10 в 15.
[01:24:31.560 --> 01:24:34.560]  Коэффициент умноженной коэффициентой и так один раз. Максимум 10 в 15.
[01:24:34.560 --> 01:24:37.560]  Ну, давайте тогда сделаем следующее. Мы не будем считать комплексных.
[01:24:37.560 --> 01:24:43.560]  Мы посчитаем их произведение в zp1 и zp2.
[01:24:43.560 --> 01:24:46.560]  Ну, где p1, p2 какие-то достаточно большие простые.
[01:24:46.560 --> 01:24:50.560]  То есть я буду знать значение каждого коэффициента по модулю p1 и по модулю p2.
[01:24:50.560 --> 01:24:53.560]  Ну, а дальше просто китайская терминка об остатках.
[01:24:56.560 --> 01:25:02.560]  Если мы знаем значение коэффициента a i t по модулю p1, там какой-нибудь x,
[01:25:02.560 --> 01:25:07.560]  и знаем его значение по модулю p2, то значение по модулю произведения вычитается однозначно.
[01:25:07.560 --> 01:25:11.560]  Значит, если нам точно понятно, что коэффициенты все не больше 10 в 15,
[01:25:11.560 --> 01:25:14.560]  а скажем p1, p2 это чисто порядка 10 в 9,
[01:25:14.560 --> 01:25:21.560]  то, значит, из этих двух сравнений мы можем однозначно найти a i t.
[01:25:21.560 --> 01:25:24.560]  a i t однозначно находится.
[01:25:24.560 --> 01:25:31.560]  Значит, a i t однозначно находится, если оно меньше, чем p1, p2.
[01:25:31.560 --> 01:25:36.560]  Ну, значит, если мы найдем достаточно большие p1, p2 вот с тем хорошим свойством,
[01:25:36.560 --> 01:25:39.560]  что у них вот эта вот степень двойки достаточно большая,
[01:25:39.560 --> 01:25:42.560]  и сможем сделать преобразование Fourier над этими двумя полями,
[01:25:42.560 --> 01:25:45.560]  тогда мы сможем найти a i t точно.
[01:25:46.560 --> 01:25:48.560]  Вот еще зачем-то может быть нужно.
[01:25:48.560 --> 01:25:51.560]  Так, ну, на этом все. Спасибо.
