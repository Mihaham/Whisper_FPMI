[00:00.000 --> 00:08.620]  Так, кей, поехали. У нас времени очень мало. Поехали сегодня без каких-то особых вступлений, лекция вторая.
[00:08.620 --> 00:16.800]  Так, что мы успели на прошлой лекции? Мы обсудили с вами DFS, время входа-выхода и цвета вершин,
[00:16.800 --> 00:20.960]  лему о белых путях, обсудили, что такое табологическая сортировка, как ее искать,
[00:20.960 --> 00:32.300]  и доказали утверждение следующего вида, что пусть C и C штрих – это вершины
[00:32.300 --> 00:41.040]  DAC. DAC у всех же семинар был, поэтому вы должны знать эту аббревиатуру directed cyclic graph,
[00:41.040 --> 01:04.080]  и есть ребро CC штрих. Тогда таут от чего от C, видимо, будет больше, чем таут от C штрих.
[01:04.080 --> 01:10.760]  Вот это мы с вами доказывали в рамках того, что мы доказывали, когда строили топсорт, мы доказывали,
[01:10.760 --> 01:17.240]  что в циклическом графе, если есть ребро, то сначала мы выйдем из истока ребра, потом из конца ребра.
[01:17.240 --> 01:22.240]  Наоборот, сначала выйдем отсюда, потом отсюда, потому что есть время выхода больше.
[01:22.240 --> 01:31.920]  И еще мы с вами доказали следующее утверждение в конце. Мы доказывали растягивать время как могли.
[01:31.920 --> 01:55.600]  Граф конденсации отцикличен. Конденсации по отношению сильной связности отцикличен.
[01:55.600 --> 01:59.040]  Нам нужны будут эти два утверждения, чтобы доказать алгоритм поиска компонент
[01:59.040 --> 02:05.720]  сильной связанности. Напомню, две отцикли сильно связаны, если есть путь из У в В и из В в У.
[02:05.720 --> 02:10.880]  Вот это для ориентированных графов, соответственно, их можно выделять компоненты, потому что это отношение
[02:10.880 --> 02:16.560]  к эквивалентности с точностью до выполнения рефлексивности. Но мы их считали по умолчанию выполненными.
[02:16.560 --> 02:34.400]  Окей, алгоритм Косараю. Давайте вот так транскрибируем. И в скобочках поиск КСС, поиск компонент
[02:34.400 --> 02:52.640]  сильной связанности. Шаг 1 будет простой. Практически ищем топ-сорт. Найдем времена выхода всех вершин.
[02:52.640 --> 03:02.240]  Ну и давайте для простоты рассуждения буду считать, что граф это одна большая компонента
[03:02.240 --> 03:06.680]  слабой связанности. То есть если я уберу ориентацию у всех ребер, то у меня граф станет связанным,
[03:06.680 --> 03:14.080]  точнее станет просто связанным. Это будет просто полезно для упрощения рассуждения, однако на коде
[03:14.080 --> 03:18.840]  это будет меняться то, что просто будет вызываться еще от одной компоненты. Найдем времена выхода
[03:18.840 --> 03:32.840]  всех вершин. Упорядочим вершины. Сейчас скажу в кое порядке каком. Давайте в порядке убывания,
[03:32.840 --> 03:44.560]  если что, я поправлю. Но если не сойдется где-то здесь, то там убывание надо будет заменить на
[03:44.560 --> 03:54.440]  возрастание. Шаг 2. Смотрите, здесь мы по сути это был топ-сорт, мы так и сказали. Но прием в том,
[03:54.440 --> 04:00.840]  что у нас граф содержит циклы, поэтому это формально топ-сортом называть нельзя, хотя по факту мы
[04:00.840 --> 04:13.200]  вернули тот же порядок вершин. Шаг 2. Транспонируем граф. Что значит транспонируем граф? Это значит,
[04:13.200 --> 04:17.480]  что если у нас было ребро УВ, мы его удаляем и проводим в ребро ВУ. То есть меняем ориентацию
[04:17.480 --> 04:34.840]  всех ребер. Ориентация всех ребер. Почему транспонируем? Потому что если мы рассмотрим
[04:34.840 --> 04:39.560]  матрицу смежности обычного графа, то поменять ориентацию всех ребер то же самое, что транспонировать
[04:39.560 --> 04:48.320]  эту матрицу. Вот такое вот наблюдение. И шаг 3. На транспонированном графе
[04:48.320 --> 05:11.240]  запускаем ДФС из вершин в порядке убывания ТАУТ. Вот такой способственный алгоритм. Утверждается,
[05:11.240 --> 05:16.800]  что каждый запуск ДФС вам выдаст новый компонент усиленной связанности. Более того, в итоге они
[05:16.800 --> 05:22.760]  будут в порядке топологической сортировки. То есть вы сразу сортируете конденсацию. Это то,
[05:22.760 --> 05:30.160]  что нужно сделать в контесте. Вау. Вот. Но некоторые уже сделали. Некоторые молодцы.
[05:30.160 --> 05:35.480]  Так, давайте доказывать корректность. Что нам нужно доказать? По сути нам нужно доказать,
[05:35.480 --> 05:41.280]  что на третьем шаге мы каждый раз что делаем. Но по чьим компонент усиленной связанности только ее.
[05:41.280 --> 06:10.160]  Давайте утверждение. Алгоритм корректен. То есть надо доказать, что на третьем шаге запуск КСС
[06:10.160 --> 06:28.200]  ДФС посещает КСС только ее. Ну, третий шаг. Здесь мы ничего, по сути, не делали. Вот именно
[06:28.200 --> 06:35.920]  этот третий шаг. Ну, давайте посмотрим на наш граф. Что у нас было изначально? У нас
[06:35.920 --> 06:48.160]  была какая-то КСС и из нее было ребро в С'. Да? Это все КСС две большие. Будем считать,
[06:48.160 --> 06:54.560]  что мы типа построили конденсацию как-то для наглядности. Так, ребро из С в С'. Что мы сделали,
[06:54.560 --> 07:02.160]  когда мы транспонировали граф? У нас получилось наоборот. Ребро из С' в С. А достижимость внутри
[07:02.160 --> 07:17.640]  компонента усиленной связанности не поменялась. Достижимость после два внутри КСС не изменилась.
[07:17.640 --> 07:24.440]  То есть при транспонировании графа у вас сами компоненты усиленной связанности не меняются
[07:24.440 --> 07:31.840]  никак. Ну, это вроде тривиальное утверждение. Вот. Что теперь заметим? Что у нас, по сути,
[07:31.840 --> 07:38.040]  здесь делается? Мы запускаем в порядке убывания таут. Это значит, что мы берем и первую вершинку
[07:38.040 --> 07:43.840]  берем у которой наибольший таут. Что значит, что у нее наибольший таут? Давайте посмотрим на это
[07:43.840 --> 07:54.680]  утверждение. Это значит, что, раз у нее наибольший таут, что? Да, это исток будет. То есть раньше
[07:54.680 --> 08:09.880]  в этом графе не существовало ребер в С. Таких ребер нет. Ну согласны, да? Так как С имеет
[08:09.880 --> 08:25.400]  максимальный. Могли, да. А в него? Нет, еще раз смотрите. Нет, это конденсация имеется в
[08:25.400 --> 08:32.680]  виду. То есть это отдельные КССки. Конечно так не может. Ну понятно, да. Так как С имеет максимальный
[08:32.680 --> 08:49.720]  таут, давайте отмечу, что КСС. Давайте не так напишем. Давайте так скажем. Пусть В имеет
[08:49.720 --> 09:03.600]  максимальный таут, да, и В принадлежит С. С- это КСС у нас будет. Вот так вот. Это была какая-то
[09:03.600 --> 09:17.240]  вершинка В. То есть у нас не было ребер в С. Тогда нет ребер в С в исходном графе.
[09:17.240 --> 09:38.680]  Откуда вас следует, что нет ребер из С в транспонированном графе. То есть теперь мы из С не можем
[09:38.680 --> 09:46.600]  выйти никуда. У нас нет исходящих ребер. У нас только вот все сюда ведет. Ну не все здесь может куда-то еще
[09:46.600 --> 09:52.400]  вести, но суть в том, что у нас нет ребер выходящих из С теперь. А из этого следует, что ДФС посетит
[09:52.400 --> 10:06.640]  при запуске из вершинки в С только С. Он больше выйти никуда не может. Тогда ДФС от В посещает только С.
[10:06.640 --> 10:17.480]  Ну конец. Представляешь, что каждый шаг помещает целую компоненту сильно связанности только ее.
[10:17.480 --> 10:23.640]  Почему он посещает ее? Потому что здесь достижимость не меняется никак внутри. Почему только ее? Потому что
[10:23.640 --> 10:32.840]  он выйти никуда не может этот ДФС. У нас нет исходящих ребер из компонента. Ну и поэтому дело,
[10:32.840 --> 10:38.280]  что вы будете их получать в порядке того, что у вас здесь будет меньший номер, здесь будут какие-то
[10:38.280 --> 10:42.560]  большие номера, здесь еще большие. Чтобы получить топ сорта, вам нужно будет реверснуть порядок.
[10:42.560 --> 10:50.240]  Ну порядок к СС, к самих. Все. Вопросы.
[10:50.240 --> 11:05.240]  Вот это вот утверждение, что если у нас в С максимальный тал, из этого следует, что в него не идет ребер, мы доказываем через вот эту лену?
[11:05.240 --> 11:15.360]  Ну да. Ну доказывается, что там один логический шаг. Вот вы берете максимальный т-аут. Хорошо,
[11:15.360 --> 11:19.320]  давайте предположим, что из нее есть ребро. Ну все, тогда применяем лему.
[11:19.320 --> 11:25.240]  А там есть какие вершины? Конденсация.
[11:25.240 --> 11:31.120]  Хорошо, т-аут от конденсации определяется как максимальный т-аут из всех вершин.
[11:31.120 --> 11:39.600]  Какая разница? У вас в графе конденсации это не меняется? Хорошо.
[11:39.600 --> 11:57.640]  Ну значит, что что-то делаете не так. Хорошо. Ну, потому что, хорошо, окей, давайте так.
[11:57.640 --> 12:18.760]  Определение. Пусть С под множество В. Тогда т-аут от С, давайте так скобкой даже возьмем, равно максимум по В из С т-аут от В.
[12:18.760 --> 12:25.160]  Почему это так? Имеется в виду, что это время выхода из целого под множества вершин. Ну что значит,
[12:25.160 --> 12:30.560]  что вы вышли из под множества вершин? Знаете, чтобы все их уже посетили. Вроде как максимально натуральное
[12:30.560 --> 12:38.160]  поделение. И там доказательства абсолютно аналогичны этому будет. То есть там с точностью до замены
[12:38.160 --> 12:46.040]  одного, ну ладно, двух строчек, двух слов, хорошо, вот так вот. Аналогично, давайте влежь совсем педантов.
[12:51.280 --> 13:04.440]  Тогда т-и на С это минимальное время. То есть время входа в компоненты, это когда вы только-только вошли, а время,
[13:04.440 --> 13:13.680]  когда вы вышли, ну это максимальное время, когда вы вышли, вот. За сколько времени, за сколько времени все это
[13:13.680 --> 13:21.400]  работает, давайте подумаем. Ну это за линию от размеров графа, поэтому мы с вами делали уже неделю назад.
[13:21.400 --> 13:28.080]  Это в зависимости того, как вы граф храните. Либо это будет В квадрат из-за матрицы смежности,
[13:28.080 --> 13:32.840]  потому что нужно всю матрицу транспонировать. Либо же это будет В плюс Е, если это просто список
[13:32.840 --> 13:41.040]  смежности. Берете просто и перелопачиваете его с ног на голову, строите новый. Вот это вот, ну это просто
[13:41.040 --> 13:48.640]  запустить DFS, опять же используя все эти юзды и так далее, то есть снова за линию работает. Откуда
[13:48.640 --> 13:55.240]  суммарное время линейное? То есть мы умеем выделять компоненты сильно связанности за линейное время от размеров графа.
[13:55.240 --> 14:03.720]  Хорошо, тогда давайте. Все, с ориентированным графом закончили пока что.
[14:03.720 --> 14:08.040]  DFS на неориентированных графах.
[14:19.840 --> 14:20.640]  Определение.
[14:25.240 --> 14:35.600]  Ребро называется древесным,
[14:35.600 --> 14:51.680]  если DFS вдоль него идет в белую вершину.
[14:55.240 --> 15:08.760]  Обратное ребро называется обратным,
[15:08.760 --> 15:38.720]  если DFS вдоль него идет в серую вершину. Тривиальное наблюдение, что ребер в черной
[15:38.720 --> 15:43.360]  вершины быть не может на неориентированном графе. Почему ребер в неориентированном графе не может быть
[15:43.360 --> 15:49.400]  черной вершины? Мы из нее вышли, а эту вершину уже должны были посетить тогда по лемме белых
[15:49.400 --> 15:54.560]  путях, потому что она была достижима в момент времени входа в ту вершину по белому пути. В
[15:54.560 --> 16:00.040]  ориентированных же графах бывают ребра в черные вершины, и там есть еще два типа ребер, это прямые
[16:00.040 --> 16:06.440]  и перекрестные, но пока что они нам не нужны и в целом в курсе не понадобится, поэтому мы будем
[16:06.440 --> 16:15.320]  только вот эти два определять. Почему ребра древесные называются? Давайте приведем пример.
[16:15.320 --> 16:30.680]  Ну и запустим DFS с единицы. Я буду рисовать дерево обхода DFS, так называемое. Сняв корень,
[16:30.680 --> 16:38.760]  это единичка, потому что я с нее начинаю. Дальше я иду в двойку. Допустим у меня DFS в двойку пришел,
[16:38.760 --> 16:57.760]  это двойка. Дальше, допустим, у меня DFS идет в тройку. Из тройки у меня есть ребро в единичку,
[16:57.760 --> 17:03.360]  но оно уже серо к этому моменту, поэтому это ребро обратное, мы будем рисовать пунктиром.
[17:03.360 --> 17:10.440]  Дальше. Ну все, из тройки ребра закончились, поднимаемся вверх в двойку, в постаку рекурсия.
[17:10.440 --> 17:19.600]  Дальше из двойки есть пятерку ребро. Из пятерки в четверку. Вот такую вот конструкцию мы будем
[17:19.600 --> 17:26.560]  называть деревом обхода DFS. То есть она состоит из древесных ребер, причем они ориентированы
[17:26.560 --> 17:36.200]  в ходе того, как шел DFS. И обратные ребра это не древесные ребра, назовем это так. Да,
[17:36.200 --> 17:42.760]  есть определение, как у вас DFS устроен, но зачем нам это надо? Нам нужно это не для того,
[17:42.760 --> 17:49.600]  чтобы строить деревья обхода DFS внезапно, мы просто будем пользоваться этой штукой как наглядным
[17:49.600 --> 18:01.720]  инструментом. Для того, чтобы решать, ну, чтобы искать два следующих таких компонента, что ли, графов.
[18:01.720 --> 18:30.440]  Определение. Две вершины ребер на двух связаны. У и В ребер на
[18:30.440 --> 18:51.800]  двух связаны. Если существует два ребер до не пересекающихся пути,
[18:51.800 --> 19:18.360]  пути из У в В. Ну, пример очень простой. Здесь, на этом графе давайте посмотрим. 1 и 2 ребер на
[19:18.360 --> 19:27.400]  двух связаны. Почему? Потому что есть 1 и 2, а есть 1 и 3 и 2. Два пути ребер не пересекаются,
[19:27.400 --> 19:36.280]  у них все ребра различные на пути. У вас есть ребро 2 и 5, который обязательно лежит на любом пути.
[19:36.280 --> 19:48.880]  Собственно, мы будем называть такое ребро мостом. Вот. Сейчас. Что я хочу? А, ну я хочу
[19:48.880 --> 19:53.800]  сказать, что это по отношению эквивалентности. С точностью, как отношение сильно связанности было
[19:53.800 --> 19:59.080]  эквивалентностью. То есть транзитивность здесь вроде тривиальна, симметричность очевидна,
[19:59.080 --> 20:12.080]  рефлексивность не выполняется, но она и не нужна. Ну, давайте мы не будем вдаваться в крайность и
[20:12.080 --> 20:24.320]  просто уверуем в это. Мы еще пока что ничего не называем мостом. Это так, спойлер был. То,
[20:24.320 --> 20:31.040]  что мы назовем мостом появится на доске. Окей, так, это мы сформулировали. Отвержение
[20:31.040 --> 20:43.520]  это отношение эквивалентности. Из этого съедут, что можно выдать классы эквивалентности, которые
[20:43.520 --> 20:56.720]  называются компоненты рёберной двусвязности. Компонента рёберной двусвязности
[20:56.720 --> 21:22.200]  это класс эквивалентности. По отношению рёберной, давайте рёберной двусвязности, напишем это еще раз.
[21:26.720 --> 21:47.560]  Окей. Ну, в частности, давайте здесь их нарисуем. Это раз, это два и три. Как вы можете догадаться,
[21:47.560 --> 21:54.200]  если удалю любой ребро внутри одной компоненты рёберной двусвязности, у меня граф не развалится.
[21:54.200 --> 22:03.200]  Однако, если удалю между, то он развалится. Поэтому определение, перестань быть связанным,
[22:03.200 --> 22:17.680]  увеличится числом компонент связанности. Определение, ребро Е это мост, если при его
[22:17.680 --> 22:40.640]  удалении число компонент связанности увеличится. Связанность увеличится.
[22:47.680 --> 22:55.920]  Утверждение, которое я не буду доказывать, потому что это тривиальное утверждение,
[22:55.920 --> 23:15.840]  ребро Е, мост тогда и только тогда, когда Е соединяет две компоненты рёберной двусвязности.
[23:15.840 --> 23:35.760]  Ну, есть более сильная или более слабая формулировка. Короче, другая формулировка,
[23:35.760 --> 23:41.040]  что ребро Е мост тогда и только тогда, когда не существует цикла его содержащего.
[23:41.040 --> 23:53.600]  Суммарно, можно построить порядка восьми эквивалентных определений моста.
[23:53.600 --> 24:01.600]  Вот. Так что когда-нибудь вас попросят доказать эквивалентность. Возможно.
[24:01.600 --> 24:06.040]  Вот одно из них это то, что ребро Е мост тогда и только тогда, когда оно не лежит мне на одном цикле.
[24:06.040 --> 24:26.600]  Вот. Окей. На цикле просто. Можно реберно просто взять цикл, например. Не очень принципиально, вроде как здесь.
[24:26.600 --> 24:35.040]  Окей, так. Что нам нужно? Нам нужно научиться искать мосты. Зачем они нужны?
[24:35.040 --> 24:45.760]  Ну, как вы сами видите, если у нас есть мосты, значит мы умеем выделять компоненты рёберной двусвязности.
[24:45.760 --> 24:51.040]  Почему? Мы взяли, удалили мосты, нашли компоненты связности, это и будут компоненты рёберной двусвязности.
[24:51.040 --> 24:56.960]  Чем еще мосты хороши? Ну, тем, что они определяют слабые места в вашей какой-то сети.
[24:56.960 --> 25:02.840]  Поэтому искать мосты достаточно классная штука. Давайте научимся искать.
[25:02.840 --> 25:10.440]  Определение. Ведем такую функцию red от V.
[25:10.440 --> 25:40.040]  Red будет равна минимуму из T in от V и T in от U, где U такой предок V.
[25:40.040 --> 26:07.640]  Что существует W из-под дерева обхода DFS и ребро W у обратное.
[26:10.040 --> 26:17.640]  Ну, да, имеется только W из-под дерева.
[26:17.640 --> 26:27.640]  Да, да, да. Ну, минимум на все, вообще минимум навешивает.
[26:27.640 --> 26:29.640]  Туда можно минимум еще написать.
[26:29.640 --> 26:33.640]  Что это такое? Это что-то очень страшное.
[26:33.640 --> 26:35.640]  Давайте на картинке.
[26:36.240 --> 26:41.240]  Вот, допустим, у вас есть ваш корень, вашего дерева обхода DFS,
[26:41.240 --> 26:43.240]  и вы как-то добрались до вершинки V.
[26:43.240 --> 26:47.240]  И где-то есть там на пути предок U.
[26:47.240 --> 26:49.240]  Вот ваше под дерево.
[26:49.240 --> 26:54.240]  Тогда если у вас здесь есть какой-то путь до вершинки W,
[26:54.240 --> 26:58.240]  такое, что есть обратное ребро в вершинку U,
[26:58.240 --> 27:03.240]  то red от V это T in от U.
[27:03.240 --> 27:05.240]  Зачем нам это нужно?
[27:05.240 --> 27:08.240]  Нам это нужно, на самом деле, по очень простой причине,
[27:08.240 --> 27:13.240]  что мы хотим понять, можно ли из вершинки, из ее под дерева,
[27:13.240 --> 27:16.240]  выпрыгнуть выше, чем она лежит.
[27:16.240 --> 27:19.240]  Если да, то значит, у нас есть цикл, у его содержащий.
[27:21.240 --> 27:26.240]  Но если у нас есть цикл, у его содержащий, значит, это не мосты, короче, все.
[27:28.240 --> 27:32.240]  Конечно, у нас ориентированности здесь нет нигде.
[27:32.240 --> 27:35.240]  У нас там написано, что DFS на неорграфах.
[27:35.240 --> 27:40.240]  Потому что понятие моста для ориентированных графов немножко не имеет смысла.
[27:42.240 --> 27:44.240]  Окей.
[27:44.240 --> 27:46.240]  Как это будем делать?
[27:47.240 --> 27:49.240]  Нам нужно первые две вещи доказать.
[27:49.240 --> 27:53.240]  Первое, как читать red, и что это может делать за линейное время суммарно.
[27:53.240 --> 27:57.240]  Второе, это доказать критерии того, что ребро мост.
[27:57.240 --> 27:59.240]  Мы это окажем критерией сначала.
[28:00.240 --> 28:02.240]  Теорема.
[28:03.240 --> 28:05.240]  Критерии моста.
[28:11.240 --> 28:15.240]  В нем два утверждения, первое даже записывать не буду, но тригиальное.
[28:15.240 --> 28:17.240]  Обратное ребро мостом быть не может.
[28:18.240 --> 28:20.240]  Почему это так?
[28:21.240 --> 28:25.240]  Потому что если у вас обратное ребро – это мост, значит, у вас есть цикл.
[28:25.240 --> 28:27.240]  Значит, этот мост лежит на ком-то цикле.
[28:27.240 --> 28:32.240]  Значит, при его удалении у вас все связаны, все еще сохранится через кусок цикла второй.
[28:34.240 --> 28:37.240]  Поэтому я сразу напишу так. Древесное ребро.
[28:39.240 --> 28:40.240]  Ребро.
[28:43.240 --> 28:44.240]  ВТ.
[28:45.240 --> 28:46.240]  Мост.
[28:47.240 --> 28:48.240]  Тогда и только тогда.
[28:48.240 --> 28:53.240]  И сейчас будет что-то очень неприятное, потому что я не помню неравенство.
[28:53.240 --> 28:55.240]  Сейчас, я попробую вспомнить.
[28:57.240 --> 28:59.240]  Тин от Т.
[29:01.240 --> 29:02.240]  Равен.
[29:03.240 --> 29:05.240]  Тап от Т.
[29:06.240 --> 29:07.240]  Вроде бы так.
[29:10.240 --> 29:11.240]  Тин равен Тапу.
[29:13.240 --> 29:14.240]  Ой, ой, ой, ой.
[29:14.240 --> 29:15.240]  Ну давайте Тап.
[29:16.240 --> 29:17.240]  Рец, да.
[29:17.240 --> 29:20.240]  Ну, потому что просто в разных местах по-разному обозначают.
[29:20.240 --> 29:21.240]  Давайте рец обозначаем.
[29:21.240 --> 29:23.240]  Ну раз мы уже начали рец, то рец.
[29:26.240 --> 29:27.240]  Так.
[29:29.240 --> 29:30.240]  Да.
[29:31.240 --> 29:36.240]  Ну, можно сказать, что он меньше либо равен.
[29:36.240 --> 29:39.240]  Неравенство строго меньше не выполняется никогда.
[29:40.240 --> 29:45.240]  Потому что у вас рец – это минимум из этой штуки и чего-то там.
[29:46.240 --> 29:47.240]  Поэтому именно равенство.
[29:47.240 --> 29:48.240]  Давайте доказывать.
[29:50.240 --> 29:52.240]  Давайте докажем в одну сторону.
[29:54.240 --> 29:55.240]  В прямую сторону.
[29:55.240 --> 29:56.240]  Если в этом мост.
[29:58.240 --> 29:59.240]  Что значит в этом мост?
[30:07.240 --> 30:08.240]  Сейчас.
[30:08.240 --> 30:09.240]  Может в противном правом доказать.
[30:10.240 --> 30:11.240]  То есть, если это неверно.
[30:13.240 --> 30:14.240]  То есть у нас как бы.
[30:14.240 --> 30:15.240]  Давайте от противного докажем.
[30:16.240 --> 30:17.240]  Будто бы.
[30:18.240 --> 30:19.240]  От противного.
[30:23.240 --> 30:24.240]  Вроде так будет нормально.
[30:25.240 --> 30:26.240]  То есть Ти на Т.
[30:28.240 --> 30:30.240]  Строго больше, чем рец.
[30:31.240 --> 30:32.240]  От Т.
[30:33.240 --> 30:34.240]  Да.
[30:35.240 --> 30:36.240]  Внуш строго меньше, он быть не может.
[30:37.240 --> 30:38.240]  Опять же, мы это уже сказали.
[30:38.240 --> 30:39.240]  Если рец строго меньше.
[30:40.240 --> 30:45.240]  То следует, что существует у в поддереве.
[30:46.240 --> 30:47.240]  Не, у такой предок.
[30:51.240 --> 30:52.240]  Что тра-та-та.
[30:54.240 --> 30:55.240]  Короче говоря.
[30:56.240 --> 30:58.240]  То есть у нас выполняется этот случай.
[31:00.240 --> 31:01.240]  То есть у нас есть такой предок.
[31:02.240 --> 31:03.240]  То есть у нас есть такой предок.
[31:04.240 --> 31:05.240]  То есть у нас есть такой предок.
[31:05.240 --> 31:06.240]  То есть у нас выполняется этот случай.
[31:08.240 --> 31:10.240]  Потому что у нас здесь рец от В.
[31:11.240 --> 31:12.240]  Он строго меньше, чем Ти на Т.
[31:13.240 --> 31:14.240]  Значит он где-то здесь должен быть.
[31:15.240 --> 31:16.240]  На предке.
[31:17.240 --> 31:18.240]  То есть у нас реализуется вот этот случай.
[31:19.240 --> 31:20.240]  Значит существует такая.
[31:21.240 --> 31:22.240]  У, это такой предок, что...
[31:23.240 --> 31:24.240]  Вот.
[31:25.240 --> 31:26.240]  А раз существует такой предок.
[31:27.240 --> 31:28.240]  Из этого следует, что у нас есть цикл.
[31:35.240 --> 31:36.240]  Цикл.
[31:37.240 --> 31:38.240]  У.
[31:39.240 --> 31:40.240]  В.
[31:41.240 --> 31:42.240]  Дубль В.
[31:43.240 --> 31:44.240]  У.
[31:45.240 --> 31:46.240]  Но для этого следует, что у В не мост.
[31:47.240 --> 31:48.240]  Просто на...
[31:49.240 --> 31:50.240]  Ой.
[31:51.240 --> 31:52.240]  Ну сейчас.
[31:53.240 --> 31:55.240]  В наших терминах есть такой случай, что это В, а это Т.
[31:56.240 --> 31:57.240]  Да.
[32:02.240 --> 32:03.240]  Сейчас.
[32:03.240 --> 32:04.240]  Сейчас.
[32:05.240 --> 32:06.240]  У это из определения был.
[32:07.240 --> 32:08.240]  У нас здесь ВТ, у нас здесь нет У.
[32:09.240 --> 32:10.240]  Вот.
[32:11.240 --> 32:12.240]  Вот так вот, да.
[32:13.240 --> 32:14.240]  Существует В.
[32:15.240 --> 32:16.240]  В нашем случае это В будет.
[32:17.240 --> 32:18.240]  Не-не-не, вру.
[32:19.240 --> 32:20.240]  Вру-вру.
[32:21.240 --> 32:22.240]  Существует У, это предок.
[32:23.240 --> 32:24.240]  Потому что у нас есть...
[32:25.240 --> 32:26.240]  Давайте здесь нарисую.
[32:27.240 --> 32:28.240]  У нас есть ребро ВТ.
[32:29.240 --> 32:32.240]  А есть здесь какой-то У, который там где-то лежит на пути.
[32:33.240 --> 32:34.240]  Это никто не мешает вам.
[32:36.240 --> 32:37.240]  Тогда у вас есть цикл.
[32:38.240 --> 32:40.240]  Давайте его пишем нормально.
[32:41.240 --> 32:42.240]  Какой он получится в итоге.
[32:49.240 --> 32:50.240]  Так, начинаем в Т.
[32:52.240 --> 32:54.240]  Идем в Дубль В.
[32:55.240 --> 32:57.240]  Приходим в У.
[32:58.240 --> 33:00.240]  Идем в В.
[33:01.240 --> 33:02.240]  И приходим в Т.
[33:03.240 --> 33:04.240]  Во, все.
[33:04.240 --> 33:05.240]  Вот такой цикл получился.
[33:06.240 --> 33:09.240]  Ну, можно я не буду доказывать, что если ребро лежит на цикле, то на мостом быть не может.
[33:12.240 --> 33:13.240]  ВТ.
[33:14.240 --> 33:15.240]  Не.
[33:15.240 --> 33:16.240]  Мост.
[33:18.240 --> 33:20.240]  Так, в одну сторону доказали, надо в другую теперь.
[33:22.240 --> 33:23.240]  В обратную сторону.
[33:26.240 --> 33:28.240]  То есть если я тарарист, то это мост.
[33:28.240 --> 33:29.240]  Здесь вроде совсем тривиально.
[33:34.240 --> 33:35.240]  Ой, а Т.
[33:36.240 --> 33:37.240]  Т равно рета Т.
[33:38.240 --> 33:40.240]  Из этого следует, что мы не можем выпрыгнуть выше чем В.
[33:41.240 --> 33:42.240]  Выше чем Т.
[33:43.240 --> 33:44.240]  Не.
[33:44.240 --> 33:45.240]  Можем.
[33:46.240 --> 33:47.240]  Выпрыгнуть.
[33:51.240 --> 33:52.240]  Выше.
[33:54.240 --> 33:55.240]  Выше.
[33:56.240 --> 33:57.240]  Выше.
[33:59.240 --> 34:00.240]  Т.
[34:02.240 --> 34:04.240]  То есть какая у нас ситуация получается?
[34:05.240 --> 34:06.240]  У нас есть наш корень.
[34:08.240 --> 34:10.240]  Мы как-то дошли до нашей вершинки В.
[34:11.240 --> 34:12.240]  Есть вершинка Т.
[34:13.240 --> 34:16.240]  И у ее по дереву не существует пути выбраться выше чем Т.
[34:19.240 --> 34:20.240]  Откуда вас следует?
[34:23.240 --> 34:24.240]  При удалении.
[34:25.240 --> 34:26.240]  ВТ.
[34:31.240 --> 34:32.240]  Под дерево Т.
[34:35.240 --> 34:36.240]  Теряет связь с руд.
[34:42.240 --> 34:44.240]  То есть у вас вот эта вот штука изолирована.
[34:45.240 --> 34:46.240]  У нее нет других ребер.
[34:47.240 --> 34:48.240]  Снаружу.
[34:49.240 --> 34:50.240]  А раз у вас есть ребро, вот это вот.
[34:51.240 --> 34:52.240]  И оно единственное, что связывает вас с корнем.
[34:52.240 --> 34:55.240]  Если вы перерубаете все, у вас изолированная компонента получается.
[34:58.240 --> 35:00.240]  Откуда вас следует, что ВТ это мост?
[35:04.240 --> 35:05.240]  Все.
[35:06.240 --> 35:07.240]  Отказали.
[35:08.240 --> 35:11.240]  Так, Кей, ну допустим, что если мы научимся считать ред, то мы победили.
[35:12.240 --> 35:13.240]  Мы умеем искать мосты.
[35:14.240 --> 35:16.240]  Ой, ну, что сказать?
[35:17.240 --> 35:18.240]  Я вам сочувствую, потому что мы идем дальше.
[35:19.240 --> 35:20.240]  Пока что ред мы не будем считать.
[35:20.240 --> 35:21.240]  Определение.
[35:23.240 --> 35:24.240]  Вершина В.
[35:27.240 --> 35:28.240]  Точка сочленения.
[35:30.240 --> 35:31.240]  Ой, первый раз пишу.
[35:32.240 --> 35:33.240]  Не пишу полностью.
[35:34.240 --> 35:37.240]  Точка сочленения.
[35:39.240 --> 35:44.240]  Если при ее удалении
[35:44.240 --> 35:51.240]  и число компонент-связанности увеличится,
[35:54.240 --> 35:57.240]  забавное утверждение стоит в том, что
[35:58.240 --> 36:01.240]  наличие мостов не гарантирует наличие точек сочинения.
[36:05.240 --> 36:06.240]  Более того, неверное и обратное.
[36:09.240 --> 36:11.240]  Можете придумать контрпример на каждый случай.
[36:11.240 --> 36:15.240]  Упражнение на секунд 30.
[36:17.240 --> 36:19.240]  Наличие моста не гарантирует наличие точек сочинения.
[36:20.240 --> 36:21.240]  Верное и обратное.
[36:22.240 --> 36:25.240]  То есть, что наличие точек сочинения не гарантирует наличие моста.
[36:26.240 --> 36:27.240]  Так, поехали дальше.
[36:28.240 --> 36:29.240]  Это определение.
[36:31.240 --> 36:32.240]  Что можно сказать дальше?
[36:33.240 --> 36:35.240]  Можно было бы выделить, конечно, компоненты вершины доусвязанности.
[36:36.240 --> 36:39.240]  Давайте скажем так, две вершины называются вершинно доусвязанными.
[36:39.240 --> 36:42.240]  Если между ними существует вершина не пересекающейся пути.
[36:45.240 --> 36:49.240]  Вот внезапно это уже не очень приятно доказывать, что там есть какие-то компоненты.
[36:51.240 --> 36:53.240]  Поэтому давайте мы этим заниматься не будем.
[36:54.240 --> 36:56.240]  И забьем на существование такой вещи.
[36:58.240 --> 37:01.240]  Просто скажем, что существуют вершины доусвязанности и типа все.
[37:03.240 --> 37:06.240]  Потому что нам это не очень надо, нам нужно учиться искать точки сочинения.
[37:06.240 --> 37:07.240]  Теорема следующая.
[37:12.240 --> 37:13.240]  Первый случай.
[37:14.240 --> 37:15.240]  Пусть В.
[37:17.240 --> 37:18.240]  Корень дерева ДФС.
[37:24.240 --> 37:25.240]  Тогда.
[37:27.240 --> 37:28.240]  В. Корень.
[37:29.240 --> 37:30.240]  Господи, В. Точка сочинения.
[37:30.240 --> 37:36.240]  Тогда и только тогда, когда у В хотя бы два ребенка в дереве.
[37:42.240 --> 37:43.240]  Это первое.
[37:44.240 --> 37:45.240]  Второе.
[37:48.240 --> 37:49.240]  Пусть В.
[37:50.240 --> 37:51.240]  Корень дерева ДФС.
[37:53.240 --> 37:54.240]  В.
[37:55.240 --> 37:56.240]  Корень дерева ДФС.
[37:57.240 --> 37:58.240]  В.
[37:59.240 --> 38:00.240]  Пусть В.
[38:01.240 --> 38:02.240]  Не корень.
[38:05.240 --> 38:06.240]  Тогда.
[38:08.240 --> 38:09.240]  В.
[38:10.240 --> 38:11.240]  Точка сочинения.
[38:12.240 --> 38:15.240]  Тогда и только тогда еще надо вспомнить снова неравенство такое прикольное.
[38:16.240 --> 38:17.240]  Рет от В.
[38:19.240 --> 38:22.240]  Равнутый от В. Вроде так. Вроде бы так.
[38:23.240 --> 38:25.240]  Первый случай простой достаточно.
[38:26.240 --> 38:27.240]  В. Корень.
[38:28.240 --> 38:29.240]  Давайте доказывать в какую сторону.
[38:30.240 --> 38:31.240]  Давайте в эту сторону доказывать.
[38:32.240 --> 38:33.240]  От противного.
[38:36.240 --> 38:40.240]  Что если у вершины один ребенок, то она не точка сочинения.
[38:41.240 --> 38:43.240]  У В один ребенок.
[38:46.240 --> 38:47.240]  То есть у вас как выглядит?
[38:48.240 --> 38:49.240]  Это В.
[38:50.240 --> 38:51.240]  Не знаю. Ребенок Т.
[38:52.240 --> 38:53.240]  И это все под дерево.
[38:53.240 --> 38:54.240]  ДФС больше и ничего нет.
[38:57.240 --> 38:58.240]  Откуда следует что?
[38:58.240 --> 38:59.240]  Что?
[39:02.240 --> 39:03.240]  Нет.
[39:03.240 --> 39:04.240]  Вот это одно утверждение.
[39:05.240 --> 39:06.240]  Это второе утверждение.
[39:09.240 --> 39:10.240]  Если рассмотреть два случая.
[39:10.240 --> 39:11.240]  В это корень и В не корень.
[39:12.240 --> 39:13.240]  И у вас для каждого случая свой критерий.
[39:17.240 --> 39:18.240]  У В один ребенок.
[39:19.240 --> 39:20.240]  Тогда.
[39:21.240 --> 39:22.240]  Удаление В.
[39:24.240 --> 39:26.240]  Равносильное удаление ребру ВТ.
[39:27.240 --> 39:28.240]  Ну не так точнее.
[39:28.240 --> 39:29.240]  Удаление В.
[39:30.240 --> 39:32.240]  Меняет число компонент связности.
[39:35.240 --> 39:38.240]  Компонент связности.
[39:39.240 --> 39:41.240]  Из этого следует что В не точка сочинения.
[39:46.240 --> 39:47.240]  В обратную сторону.
[39:47.240 --> 39:49.240]  То есть если у В хотя бы два ребенка в дереве.
[39:49.240 --> 39:50.240]  Тогда В точка сочинения.
[39:50.240 --> 39:52.240]  Ну это вроде бы тоже тривиально.
[39:53.240 --> 39:54.240]  Давайте рассмотрим вершинку В.
[39:55.240 --> 39:56.240]  И два каких-то ее ребенка.
[39:56.240 --> 39:57.240]  Т1 и Т2.
[40:01.240 --> 40:02.240]  Ну если у нее нет детей.
[40:02.240 --> 40:05.240]  То это унылая ситуация.
[40:06.240 --> 40:08.240]  Ну типа компонента связности из одной вершины.
[40:09.240 --> 40:11.240]  Ну типа ОК да.
[40:13.240 --> 40:14.240]  Ну вот.
[40:14.240 --> 40:15.240]  Ну типа ОК да.
[40:17.240 --> 40:19.240]  Вырожденные случаи выйти в контесте рассматривать.
[40:20.240 --> 40:21.240]  И здесь.
[40:21.240 --> 40:22.240]  Ну это вроде да.
[40:22.240 --> 40:23.240]  Тривиально.
[40:26.240 --> 40:27.240]  Ну то есть третий случай что.
[40:28.240 --> 40:30.240]  Если В это единственная вершина в компоненте.
[40:31.240 --> 40:32.240]  То она является точкой сочинения.
[40:32.240 --> 40:33.240]  Действительно.
[40:33.240 --> 40:34.240]  Вы ее удаляете.
[40:34.240 --> 40:35.240]  У вас число компонент связности.
[40:37.240 --> 40:38.240]  Не увеличивается.
[40:39.240 --> 40:40.240]  Не увеличивается.
[40:40.240 --> 40:41.240]  Да.
[40:41.240 --> 40:42.240]  Если у вас было типа.
[40:43.240 --> 40:44.240]  Две вершинки.
[40:44.240 --> 40:45.240]  Два изолированных вершины.
[40:45.240 --> 40:46.240]  Вы взяли удалили вершину.
[40:46.240 --> 40:47.240]  У вас было две компоненты.
[40:47.240 --> 40:48.240]  Стало одна.
[40:48.240 --> 40:49.240]  То есть уменьшилось вообще.
[40:50.240 --> 40:51.240]  Прикольно.
[40:52.240 --> 40:53.240]  Нет почему.
[40:53.240 --> 40:54.240]  Тогда это просто не точка сочинения.
[40:55.240 --> 40:56.240]  Подгоняем под определение.
[40:58.240 --> 40:59.240]  Окей.
[40:59.240 --> 41:00.240]  В обратную сторону.
[41:00.240 --> 41:01.240]  Рассмотрим двух детей.
[41:02.240 --> 41:04.240]  Вот я утверждаю, что они изолированы друг от друга.
[41:07.240 --> 41:08.240]  Пусть.
[41:08.240 --> 41:09.240]  Дети В.
[41:10.240 --> 41:11.240]  Т1 и Т2.
[41:13.240 --> 41:14.240]  Дети В.
[41:15.240 --> 41:16.240]  Т1 и Т2.
[41:18.240 --> 41:19.240]  Соответствующие.
[41:20.240 --> 41:21.240]  Т и Итому под деревья.
[41:26.240 --> 41:28.240]  Если бы существовало ребро из Т1 в Т2.
[41:29.240 --> 41:30.240]  Да.
[41:32.240 --> 41:34.240]  То существовала бы какая-нибудь вершинка У здесь.
[41:35.240 --> 41:36.240]  То есть ребро сюда какое-то.
[41:37.240 --> 41:39.240]  Тогда автоматически вы должны были бы отцепить этот кусок.
[41:43.240 --> 41:44.240]  Но это вроде тривиально почему.
[41:44.240 --> 41:45.240]  Потому что ДФС так работает.
[41:48.240 --> 41:49.240]  То есть как вы смотрите.
[41:50.240 --> 41:51.240]  Что вы сделали.
[41:51.240 --> 41:52.240]  По сути у вас здесь есть цикл.
[41:52.240 --> 41:53.240]  На самом-то деле.
[41:54.240 --> 41:55.240]  Здесь у вас существует ребро какое-то.
[41:56.240 --> 41:57.240]  Значит вы нашли цикл.
[41:57.240 --> 41:58.240]  Значит удаление В.
[41:58.240 --> 41:59.240]  Ничего не меняет.
[42:00.240 --> 42:02.240]  Но у вас-то вы доказываете, что вы доказываете.
[42:03.240 --> 42:04.240]  Что если хотя бы два ребенка.
[42:04.240 --> 42:05.240]  Точка сочинения.
[42:07.240 --> 42:08.240]  Сейчас.
[42:09.240 --> 42:10.240]  Ну окей хорошо.
[42:11.240 --> 42:12.240]  Давайте допустим, что существует ребро АВ.
[42:13.240 --> 42:14.240]  Да.
[42:15.240 --> 42:16.240]  Пусть АВ.
[42:19.240 --> 42:20.240]  АВ.
[42:21.240 --> 42:22.240]  Это ребро.
[42:24.240 --> 42:26.240]  Между Т1 и Т2.
[42:27.240 --> 42:28.240]  Это А, это В.
[42:31.240 --> 42:32.240]  Ну тогда.
[42:33.240 --> 42:35.240]  И допустим, что 3 над А меньше чем 3 над В.
[42:37.240 --> 42:39.240]  Ну или 3 над Т1 меньше чем 3 над Т2.
[42:41.240 --> 42:42.240]  Да.
[42:43.240 --> 42:44.240]  И скажем, что 3 над Т1.
[42:47.240 --> 42:50.240]  Меньше чем 3 над Т2.
[42:51.240 --> 42:54.240]  Что это значит, что 3 над Т1 меньше чем 3 над Т2.
[42:55.240 --> 42:58.240]  Ну это значит, что 3 над Т2 находился полностью под деревья просто-напросто.
[42:59.240 --> 43:00.240]  Потому что она достижима из Т1.
[43:01.240 --> 43:04.240]  Но мы предполагаем, что Т2 находится в другом под деревья.
[43:04.240 --> 43:06.240]  Значит просто у вас здесь как бы ребер быть не может.
[43:07.240 --> 43:08.240]  Между под деревьями.
[43:09.240 --> 43:10.240]  Между под деревьями.
[43:11.240 --> 43:12.240]  Конечно, да, да.
[43:19.240 --> 43:21.240]  Давайте попробуем прийти к противоречию еще раз.
[43:22.240 --> 43:23.240]  Что мы хотим?
[43:24.240 --> 43:26.240]  Что у нас есть два ребенка в дереве, значит мы точка сочинения.
[43:27.240 --> 43:28.240]  Сейчас.
[43:29.240 --> 43:30.240]  Если у нас есть два ребенка, значит мы точка сочинения.
[43:31.240 --> 43:32.240]  Ну то есть хорошо.
[43:32.240 --> 43:35.240]  У нас есть два ребенка, и попробуем сказать, что это не точка сочинения.
[43:36.240 --> 43:37.240]  Что это не точка сочинения.
[43:38.240 --> 43:39.240]  Сейчас.
[43:41.240 --> 43:46.240]  Короче, я хочу доказать, что существует лишь единственный путь из Т1 в Т2.
[43:47.240 --> 43:48.240]  Вот так скажем.
[43:49.240 --> 43:50.240]  Единственная вершина непересекающейся путь.
[43:51.240 --> 43:52.240]  То есть что из Т1 в Т2 можно только через В добраться.
[43:53.240 --> 43:54.240]  Вот что я хочу доказать.
[43:55.240 --> 43:56.240]  Давайте так сформулируем уже на следующей, видимо, доске.
[43:57.240 --> 44:11.240]  Хочу доказать, что из Т1 в Т2 все пути через В.
[44:12.240 --> 44:14.240]  Даже там обратные ребра включаем, да.
[44:15.240 --> 44:17.240]  Если что, товарищ Георгий.
[44:22.240 --> 44:24.240]  Нет, они есть, у вас есть обратные ребра.
[44:25.240 --> 44:27.240]  Нет, мы рассматриваем обратные ребра.
[44:28.240 --> 44:29.240]  Да, все-таки рассматриваем.
[44:30.240 --> 44:31.240]  Это я че-то лажу сказал.
[44:32.240 --> 44:35.240]  Я хочу доказать, что у меня все из пути из Т1 в Т2 идут через вершину В.
[44:36.240 --> 44:39.240]  Но предположу противное, что найдется путь не через вершину В.
[44:41.240 --> 44:43.240]  У меня ваша вершинка В.
[44:44.240 --> 44:45.240]  Вот у меня здесь Т1.
[44:46.240 --> 44:47.240]  Это Т2.
[44:48.240 --> 44:49.240]  Соответственно под деревья.
[44:49.240 --> 44:50.240]  Соответственно под деревья.
[44:53.240 --> 45:07.240]  Из этого следует, что есть путь Т1, А, В, Т2.
[45:08.240 --> 45:12.240]  То есть, есть какое-то ребро АВ между двумя под деревьями.
[45:20.240 --> 45:22.240]  Вот как-то такая конструкция.
[45:24.240 --> 45:30.240]  Но тогда я хочу доказать, что без ограничения общности
[45:33.240 --> 45:37.240]  ТИ над Т1 меньше, чем ТИ над Т2.
[45:42.240 --> 45:44.240]  В полеме о белых путях
[45:49.240 --> 45:55.240]  Т2 лежит в Т1.
[45:56.240 --> 45:57.240]  Почему?
[45:58.240 --> 46:01.240]  Потому что к моменту, когда вы вошли в Т1, у вас все вершины были белыми.
[46:02.240 --> 46:04.240]  Но все вершины, достижимые из Т1, были белыми.
[46:05.240 --> 46:07.240]  Когда вы вошли в Т1 и покрасили их серой.
[46:08.240 --> 46:09.240]  По белым путям.
[46:10.240 --> 46:11.240]  Ну, не очень важно.
[46:12.240 --> 46:15.240]  Когда вы зашли в Т1, у вас все вершины должны быть белыми.
[46:16.240 --> 46:20.240]  А к тому моменту, когда вы выйдете из Т1, покрасите их черной.
[46:21.240 --> 46:22.240]  У вас Т2 уже станет черной.
[46:23.240 --> 46:24.240]  То есть, что у вас получится?
[46:25.240 --> 46:29.240]  Вы сначала зашли в Т1, потом в Т2, потом вышли из Т2, потом вышли из Т1.
[46:30.240 --> 46:32.240]  То есть, у вас Т2 в поддереве Т1 должна находиться.
[46:33.240 --> 46:34.240]  Потому что надо достижимые из Т1.
[46:35.240 --> 46:36.240]  И мы в Т1 пришли раньше.
[46:37.240 --> 46:38.240]  Но это же неправда.
[46:39.240 --> 46:40.240]  У нас Т1 и Т2 это разные поддеревья.
[46:41.240 --> 46:42.240]  Противоречие.
[46:43.240 --> 46:49.240]  Но 2 и Т1 пересечатся 2.
[46:50.240 --> 46:52.240]  Это пустое множество, потому что они не пересекаются.
[46:53.240 --> 46:54.240]  Все, вот и противоречия пришли.
[46:57.240 --> 46:58.240]  Так, окей, доказали.
[46:59.240 --> 47:01.240]  В простой случае доказали, остался сложный.
[47:02.240 --> 47:09.240]  Рассмотрим ребро ВТ.
[47:09.240 --> 47:15.240]  И В это точка сочинения тогда и только тогда, когда
[47:16.240 --> 47:21.240]  Та под Т равно ТИ над В.
[47:23.240 --> 47:24.240]  Больше либо равно, да.
[47:25.240 --> 47:29.240]  Рето Т больше либо равно.
[47:30.240 --> 47:31.240]  Такое вот предлагается.
[47:32.240 --> 47:33.240]  Давайте это докажем.
[47:34.240 --> 47:35.240]  Хорошо.
[47:36.240 --> 47:37.240]  В какую сторону?
[47:37.240 --> 47:38.240]  Какое-то ребро В, какое-то ребро Т.
[47:39.240 --> 47:42.240]  Но будто бы в прямую сторону, наверное, проще доказать, да.
[47:45.240 --> 47:47.240]  В какой-то случае есть ребро на те рут.
[47:50.240 --> 47:51.240]  Как-то дошли до В.
[47:52.240 --> 47:53.240]  И есть ребро в Т.
[47:55.240 --> 47:56.240]  И что нам говорят?
[47:57.240 --> 47:59.240]  Нам говорят, что рет от Т больше либо равен ТИ над В.
[47:59.240 --> 48:02.240]  Может ли быть рет от Т строго меньше, чем ТИ над В?
[48:04.240 --> 48:05.240]  Давайте подумаем.
[48:08.240 --> 48:09.240]  Да, нет, не так.
[48:10.240 --> 48:12.240]  Рет от Т значит, что мы смогли выпрыгнуть выше, чем В.
[48:13.240 --> 48:14.240]  Все окей, это может быть.
[48:16.240 --> 48:17.240]  Давайте так, что бы хотим.
[48:18.240 --> 48:19.240]  Мы хотим сказать, что если это точка сочинения,
[48:20.240 --> 48:22.240]  тогда у нас выполнен этот неравенец.
[48:22.240 --> 48:23.240]  Хорошо.
[48:24.240 --> 48:25.240]  Давайте посмотрим, что можно здесь делать.
[48:26.240 --> 48:27.240]  В, точка сочинения.
[48:29.240 --> 48:31.240]  Из этого следует, что при удалении
[48:36.240 --> 48:37.240]  число компонент связанности
[48:42.240 --> 48:43.240]  увеличивается.
[48:46.240 --> 48:47.240]  В, точка сочинения.
[48:48.240 --> 48:49.240]  Увеличивается.
[48:52.240 --> 48:53.240]  Откуда вас следует,
[48:55.240 --> 48:56.240]  то,
[48:59.240 --> 49:00.240]  сейчас,
[49:01.240 --> 49:03.240]  что из Т нельзя выпрыгнуть выше, чем из В.
[49:05.240 --> 49:06.240]  Из Т,
[49:07.240 --> 49:08.240]  из под дерева Т,
[49:13.240 --> 49:14.240]  нельзя прыгнуть выше,
[49:14.240 --> 49:15.240]  нельзя прыгнуть выше,
[49:17.240 --> 49:18.240]  нельзя
[49:19.240 --> 49:20.240]  прыгнуть выше В.
[49:27.240 --> 49:28.240]  Почему это так?
[49:29.240 --> 49:30.240]  Потому что,
[49:31.240 --> 49:32.240]  если мы могли, то это была бы не точка сочинения.
[49:34.240 --> 49:37.240]  А что значит, что мы не можем прыгнуть выше В?
[49:39.240 --> 49:40.240]  Из этого следует, что рет
[49:42.240 --> 49:43.240]  от Т
[49:45.240 --> 49:47.240]  он больше либо равен, чем 3 на Т, да.
[49:51.240 --> 49:53.240]  Сейчас, рет от Т больше, чем 3 на Т строго?
[49:55.240 --> 49:56.240]  Почему? Может быть.
[49:57.240 --> 49:58.240]  Рет от Т равен 3 на Т.
[49:59.240 --> 50:00.240]  Может быть.
[50:01.240 --> 50:02.240]  Вроде бы, в эту сторону очевидно, как доказывать.
[50:03.240 --> 50:06.240]  Да? Вроде все приходы максимально наивные.
[50:07.240 --> 50:09.240]  В обратную сторону доказывать теперь.
[50:11.240 --> 50:12.240]  Ой, так, ладно.
[50:12.240 --> 50:14.240]  Что мы хотим доказать, что из неравенства?
[50:20.240 --> 50:21.240]  Сейчас, мы хотим доказать, что
[50:22.240 --> 50:23.240]  рет от Т,
[50:24.240 --> 50:25.240]  да,
[50:26.240 --> 50:27.240]  больше либо равен 3 на Т.
[50:29.240 --> 50:31.240]  Из этого следует, что В – точка сочинения.
[50:31.240 --> 50:32.240]  В смысле?
[50:33.240 --> 50:35.240]  У вас ребро ВТ существует уже в утверждении?
[50:40.240 --> 50:41.240]  Да.
[50:49.240 --> 50:50.240]  ВТ древесное.
[50:56.240 --> 50:57.240]  В Т – точка сочинения.
[50:58.240 --> 50:59.240]  В Т – точка сочинения.
[50:59.240 --> 51:00.240]  Да.
[51:09.240 --> 51:11.240]  То есть, вы рассматриваете произвольное древесное ребро ВТ.
[51:12.240 --> 51:15.240]  Тогда, если для любой вершины Т такое, что ВТ это древесное,
[51:15.240 --> 51:16.240]  верно вот это вот,
[51:18.240 --> 51:19.240]  короче, здесь можно там
[51:20.240 --> 51:21.240]  правой части написать клантер для любого Т,
[51:22.240 --> 51:23.240]  ребёнка, древесного,
[51:24.240 --> 51:25.240]  древесного ребру В.
[51:26.240 --> 51:27.240]  Ну, окей.
[51:27.240 --> 51:40.080]  что хочется сделать? Ну окей, что это значит? То есть у нас есть вершина root, есть какой-то
[51:40.080 --> 51:48.920]  путь до v, есть ребро до t. Мы утверждаем, что ред от t больше ребра равен, чем t над v. Думаю,
[51:48.920 --> 51:53.280]  окей, давайте пробуем от противного что-ли? Потому что мне как-то страшно здесь в обратном
[51:53.280 --> 52:02.520]  сторонке стрелки. Противного, то есть я хочу доказать, что v не точка сочинения, из этого следует,
[52:02.520 --> 52:12.520]  что ред от t меньше, чем t над v. Ну хорошо, что значит, что v не точка сочинения? Из этого следует,
[52:12.520 --> 52:20.360]  что для любого ребёнка v я всегда из него смогу выпрыгнуть вверх, согласны? То есть,
[52:20.360 --> 52:30.200]  если я рассмотрю ее детей t1, t2, tk, t, ее под деревья,
[52:36.520 --> 52:40.840]  тогда я из любого смогу найти нужный мне путь наверх какой-то.
[52:40.840 --> 52:52.360]  Что-то такое хочу, да? Нет, если из одного, то у меня эти отделятся,
[52:52.360 --> 53:01.400]  поэтому из всех я хочу. Хорошо, v не точка сочинения, из этого следует, что для любого
[53:01.400 --> 53:18.720]  t1 такое, что v, t1 – древесное ребро. Господи, не редро, а ребро. Существует
[53:18.720 --> 53:41.720]  w it, лежащее в t it, где t it – соответствующая под деревья. Такие, что существуют w it предки
[53:41.720 --> 54:06.400]  v, такие, что ребро w it – это обратное ребро. То есть, это у вас w1, w2. Это у вас будет u1, это u2.
[54:06.400 --> 54:15.800]  Хорошо. Почему это так? Потому что если это не упомянув, значит у меня есть такой-то
[54:15.800 --> 54:20.880]  ребенок, который изолирован будет при удалении v. Мы предлагаем, что это неверно.
[54:20.880 --> 54:34.840]  Хорошо. Если это верно, сейчас вот так вот. Из этого следует, что если у нас есть обратные
[54:34.840 --> 54:52.920]  ребра, значит r e t, для любой вершины t, r e t меньше, чем t in от v. Для любой t такое,
[54:52.920 --> 54:59.400]  что это древесное ребро. Я здесь уже не буду подписывать. Доказали? Ну, конец вроде как, да?
[54:59.400 --> 55:06.760]  Ну, короче, мы переливали из пустого в порожни и получили критерий.
[55:06.760 --> 55:16.800]  Окей, что нам осталось? Нам осталось научиться читать рет. Мы все еще умеем делать. Если мы
[55:16.800 --> 55:23.240]  научимся читать рет, то все, мы научились сказать масты про чечнение. Ну, давайте что сделаем?
[55:23.240 --> 55:39.280]  Давайте напишем алгоритм подсчета рет. Шикарно. Так, как читать реты? Давайте void dfs от int v,
[55:39.280 --> 55:54.720]  int p равно минус 1. p это предок, parent или ancestor. Окей. Здесь мы пишем, что если used от v,
[55:54.720 --> 56:13.240]  теперь return. Теперь дальше v не посещена. Говорим, что t in от v равно time++, то есть это текущее
[56:13.240 --> 56:20.040]  время, это время входа, и увеличим его на единику сразу. Что мы дальше делаем? Теперь нужно
[56:20.040 --> 56:36.200]  посчитать реты. Мы говорим сразу, что рет от v равно t in от v. Дальше мы делаем for у сосед v,
[56:36.200 --> 57:01.400]  у него есть u, уиты здесь. Очевидно, что p тоже входит в соседей, поэтому если у равно родителю,
[57:01.400 --> 57:22.880]  у сосед v. Если у это родитель, то скипаем. Хорошо, теперь у это наш ребенок. Будто
[57:22.880 --> 57:40.400]  мы делаем dfs от u. И теперь давайте поймем, что у нас на самом деле здесь есть. Я утверждаю,
[57:40.400 --> 58:07.160]  что вернем вроде как следующая формула от v. Рет у. Давайте вдумаем, правда ли это? Что значит,
[58:07.160 --> 58:12.760]  что у меня есть рет от u? Это значит, что у меня есть какая-то вершинка u, такая, что мы там куда-то
[58:12.760 --> 58:22.960]  пришли. Это root. Значит, что мы из u куда-то смогли пройти. Тогда чему равен рет от v? Это либо что-то,
[58:22.960 --> 58:32.680]  что мы смогли из u пройти, обратное ребро. То есть тогда мы знаем, что это рет от u. Сейчас,
[58:32.680 --> 58:38.320]  надо здесь рет от v понять, как считается. Ладно, давайте ставим на семинар по счет
[58:38.320 --> 58:46.760]  рет. Ладно, пока что так оставим заготовкой, потому что нам сегодня еще нужно успеть bfs рассказать.
[58:46.760 --> 59:07.240]  Кто такой bfs? Это обход графа. По-моему, так оно расшифровывается, breadth first search. Или обход ширину.
[59:07.240 --> 59:21.040]  Делаем это следующим образом. Он посещает все вершины в порядке удаления от старта.
[59:21.040 --> 59:24.520]  То есть смотри, что у вас есть. Вот у вас есть вершинка.
[59:24.520 --> 59:34.600]  Тогда bfs, если мы запускаем вот сюда эту вершину первой,
[59:34.600 --> 59:44.920]  эту второй, эту третей, эту четвертой, эту пятой, эту шестой. Такой вот интеллектуальный алгоритм.
[59:44.920 --> 59:58.320]  Как он устроен? Давайте напишем просто его код. Он не рекурсивный уже. Вот если вы писали
[59:58.320 --> 01:00:04.080]  bfs не рекурсивным, вы там делали явно stack рекурсии. Вы писали stack вершин, извлекали вершину из
[01:00:04.080 --> 01:00:11.560]  stack, добавляли всех идей в stack. Вот здесь bfs будет заменяться от этого кода ровно одним словом.
[01:00:11.560 --> 01:00:30.440]  Вы меняете stack на q, все. Заводим q, qeue int bfsq, очередь. Сразу говорим,
[01:00:30.440 --> 01:00:50.680]  что dist от v равно 0, делаем bfsq. У нас нет рекурсии. Вот это инициализация. Это значит,
[01:00:50.680 --> 01:00:57.440]  что вы засунули в очередь одну вершинку, и у вас дистанция этой вершинки равна 0. Ну и начинается сам обход.
[01:00:57.440 --> 01:01:16.600]  For у сосед v. А здесь надо еще сказать, что... Давайте скажем, что изначально все расстояние до всех минус 1 равное.
[01:01:16.600 --> 01:01:29.400]  Конечно, так в ходе вам делать нельзя, но что поделать? Мы идем на жертву ради краткости.
[01:01:29.400 --> 01:01:41.600]  Почему нельзя? Потому что вы весь требуете хранить. Ну, почитайте требования на ревью,
[01:01:41.600 --> 01:01:58.000]  там все гораздо хуже, чем вы думаете. Отличное требование, 10 из 10. Вы реализовать, да. Вы реализуете
[01:01:58.000 --> 01:02:12.640]  оба, но используете одно. Это я вам все расскажу на семинаре. For у сосед v. Так, мы делаем,
[01:02:12.640 --> 01:02:28.720]  что если dist до u равно минус 1. Сейчас, подождите. Не, вру, все, отмена. Что я несу? Меня сбили,
[01:02:28.720 --> 01:02:43.120]  смысле. Так, while. Пока очередь BFS не пустая. Size больше 0. Что вы делаете? Вы берете,
[01:02:43.120 --> 01:03:10.960]  извлекаете вершину. Current равно BFS.top BFSQ. BFSQ.pop. Теперь дальше идете по всем вершинкам,
[01:03:10.960 --> 01:03:30.760]  по всем соседям. For у сосед current. Если dist от u минус 1, то есть, если вы еще в u не заходили,
[01:03:30.760 --> 01:03:48.240]  тогда вы что делаете? Вы говорите, что у вас dist от u равно dist от current плюс 1. Это первое,
[01:03:48.240 --> 01:04:08.560]  что вы делаете. Второе, что вы делаете, вы добавляете u в очередь. Все. Весь обход. В чем его суть?
[01:04:08.560 --> 01:04:14.480]  Во-первых, он так же, как DFS, обходит всю компоненту связанности. То есть, он посещает все
[01:04:14.480 --> 01:04:20.560]  достиженные вершины. Просто в другом порядке. Второе, чем он хорош, тем, что он у вас выделяет
[01:04:20.560 --> 01:04:26.800]  вершины по слоям. То есть, во-первых, он до каждой вершины считает вам расстояние до корня. То есть,
[01:04:26.800 --> 01:04:34.560]  до откуда вы запускали. Во-вторых, он работает тоже за v плюс e опять же. Почему? Потому что,
[01:04:34.560 --> 01:04:40.720]  вроде бы, очевидно. Почему? Потому что у вас каждый реберок посмотрит не более 1 раз.
[01:04:40.720 --> 01:04:49.680]  Вот. Собственно, если у вас кавиограф не связан, то там BFS посетит компоненту связанности. В BFS вы
[01:04:49.680 --> 01:04:58.280]  нашли цикл, вроде как, когда пришли вершины, которые уже есть dist посчитанной. Но это не точно. Но,
[01:04:58.280 --> 01:05:10.880]  по идее, это так. Не очень принципиально. Выключите DFS. Теперь модификация нашего BFS. То есть,
[01:05:10.880 --> 01:05:16.560]  мы с вами научились решать базовую задачу. Если у нас дан невзвешенный граф, то есть,
[01:05:16.560 --> 01:05:22.040]  все веса ребер ровно единички, то искать расстояние от данной вершины до всех остальных мы умеем.
[01:05:22.040 --> 01:05:30.240]  Ну и, соответственно, можно там также писать предков. То есть, да, кстати, можно доказать,
[01:05:30.240 --> 01:05:34.360]  что если вы будете рассматривать только ребра, которые вам вот такие вот, вот эти вот,
[01:05:34.360 --> 01:05:47.880]  current u. То есть, ребра, которые у вас как раз-таки просматриваются вот здесь вот. Сейчас. Вот,
[01:05:47.880 --> 01:05:54.240]  вот здесь вот, вот эти вот. DSTATU равноминус 1. То есть, вот эти вот current u, ребра. То есть,
[01:05:54.240 --> 01:05:59.680]  из них будет дерево кратчайших путей, кстати, построено. Но это так. Это будет потом сказано,
[01:05:59.680 --> 01:06:04.600]  уже когда у нас будет на следующей лекции. А, поехали. Так, первая, то ли один BFS.
[01:06:04.600 --> 01:06:13.600]  В чем меняется постановка задачи? То, что весовая функция, то есть, вес ребра оттуда в,
[01:06:13.600 --> 01:06:21.120]  он лежит в множестве 0.1. То есть, у вас есть ребра веса 0 и есть ребра веса 1. Внезапно.
[01:06:21.120 --> 01:06:27.560]  Очень классная постановка. То есть, что вам говорят? Теперь я умею делать,
[01:06:27.560 --> 01:06:34.680]  говорить, что есть ребра веса 0, есть ребра веса 1. Что-нибудь такое. То есть,
[01:06:34.680 --> 01:06:40.640]  с точки зрения расстояний, вершины 2 и 3 то же самое, что 1. Но так мы действовать не
[01:06:40.640 --> 01:06:48.400]  будем, это слишком сложно. Сделаем круче и проще одновременно. Сделаем следующее, что…
[01:06:48.400 --> 01:06:58.120]  Сделаем просто дэк.
[01:06:58.120 --> 01:07:04.960]  Ладно, заведем вместо очереди дэк.
[01:07:04.960 --> 01:07:32.640]  Если вершина 0, если вес ребра current u равен 0, то в голову вставляем
[01:07:32.640 --> 01:07:47.160]  иначе в хвост. То есть, смотрите, у вас есть два случая. Вот ваш дэк, отсюда вы извлекаете,
[01:07:47.160 --> 01:07:57.760]  это head, это tail, вы сюда вставляете. И первый случай, вам приходит ребро веса 0, от current
[01:07:57.760 --> 01:08:06.040]  до u. То есть, вот отсюда вы извлекаете current, и первую очередь вам приходит вершина u такая,
[01:08:06.040 --> 01:08:15.640]  что есть здесь ребро веса 0. Тогда вы current пихаете вот сюда, вот в этот конец. Иначе,
[01:08:15.640 --> 01:08:25.240]  если у вас ребро веса 1, вторая ситуация, current, это u, у нее ребро веса 1, тогда вы u пихаете в
[01:08:25.240 --> 01:08:33.880]  другой конец. Почему это так? Почему это валидно вообще? Потому что движется следующее. Есть утверждение
[01:08:33.880 --> 01:08:41.280]  в строении очереди BFS, что в любой момент времени в очереди в голове находится сколько-то вершин,
[01:08:41.280 --> 01:08:49.160]  удаленных на минимальное расстояние от корня, на расстояние l, на текущий момент. Дальше все
[01:08:49.160 --> 01:08:57.360]  остальные удалены хотя бы на l плюс 1. Быть может там с повторами какими-то они были засунуты,
[01:08:57.360 --> 01:09:05.520]  повторно, не очень важно. Здесь главное то, что если у нас вершинки 0, значит у нас по сути
[01:09:05.520 --> 01:09:09.960]  расстояние это не изменилось, мы должны запихать в начало очереди, потому что они эквивалентны
[01:09:09.960 --> 01:09:15.720]  для рассмотрения. То есть, мы должны сначала рассмотреть все, до которых тоже самое кратчайшее
[01:09:15.720 --> 01:09:20.360]  расстояние, потому что мы проходим именно в этом порядке. А если у нас плюс 1, то значит,
[01:09:20.360 --> 01:09:29.800]  это уже должно после рассматриваться когда-то. Теперь мы умеем не только с единичками решать,
[01:09:29.800 --> 01:09:37.000]  а еще и с ноликами. Круто, да? Теперь у нас не множество размера 1, а множество размера 2.
[01:09:37.000 --> 01:09:46.120]  К сожалению, ДР мы еще не дошли. ДР дойдем на следующей лекции. Сейчас мы еще сильнее расширим
[01:09:46.120 --> 01:10:00.760]  наши горизонты. Что? Значит, что ребро веса 0, все, по нему ничего не стоит пройти. Так, ладно,
[01:10:00.760 --> 01:10:16.120]  давайте я просто скажу принцип действия следующего алгоритма, а доказывать будете
[01:10:16.120 --> 01:10:24.920]  на семинаре, потому что как-то на следующей лекции тратить совсем времени не хочется. Хочется
[01:10:24.920 --> 01:10:38.440]  сразу переходить к адекватным алгоритмам. 1K BFS. Это черепашка 1K, так называемая в контесте.
[01:10:38.440 --> 01:10:47.800]  Вот та черепашка 3, это черепашка 1K. Что мы будем делать? А теперь у нас W от УВ очень-очень страшно,
[01:10:47.800 --> 01:10:56.160]  но мы расширяем еще сильнее наши границы. Это 1, 2, 3, тра-та-та-ка. Вот, очень страшно.
[01:10:56.160 --> 01:11:05.080]  Очень страшно. Что делать будем? Делать будем следующее. Давайте заведем, заведем
[01:11:05.080 --> 01:11:23.400]  модуль V-1 на K чередей. 1, 4K. У вас веса ребер 1, тра-та-та-ка. Заведем вот столько
[01:11:23.400 --> 01:11:41.040]  очередей. Зачем нам столько? Что это K, это V-1. Имножить. Вот я хочу столько очередей. И что буду
[01:11:41.040 --> 01:12:03.240]  делать? Будем называть, что это массив очередей. ADDIST, где в ADDIST ИТЫ лежат только вершины,
[01:12:03.240 --> 01:12:25.160]  чадист равен И. Собственно максимально оправдывает свое название. Вот так вот. То есть что у меня
[01:12:25.160 --> 01:12:33.120]  есть вершинка на расстоянии 5, я ее помещу в пятую очередь. Почему модуль V-1 на K? Потому
[01:12:33.120 --> 01:12:38.720]  что каждый путь длины не больше, чем модуль V-1. Следует, что вес пути не больше, чем вот такая штука.
[01:12:38.720 --> 01:12:47.680]  Вот. Потому что у вас в принципе все ребра веса K на этом пути. Там бамбук и все ребра веса K.
[01:12:47.680 --> 01:12:55.040]  Тогда у вас достигнется эта экстремальная оценка. Тогда вроде как понятно, что делать. Вы берете,
[01:12:55.040 --> 01:13:02.880]  проходите, типа пока все очереди не пусты. Запоминайте, сколько у вас размер очередей
[01:13:02.880 --> 01:13:08.160]  суммарный и поддерживайте его там, когда вам надо. Что вы делаете дальше? Вы делаете вайлом,
[01:13:08.160 --> 01:13:17.680]  пока все очереди не пусты. Берете вершинку из текущей очереди. Даже не так можно. Давайте
[01:13:17.680 --> 01:13:32.440]  вот так сделаем. 4. Н пишу код. И равный нулю. И меньше, чем у нас 1 на K. Ну здесь можно сказать,
[01:13:32.440 --> 01:13:39.880]  что вообще от единицы надо брать. Ну давайте так напишем. Что дальше происходит? Берем вершинку.
[01:13:39.880 --> 01:13:58.680]  While at dist iti size больше единички. Больше ребра не единички. То есть только больше нуля.
[01:13:58.680 --> 01:14:21.200]  То мы говорим следующее. Что текущая вершина равна at dist iti.pop.top.at dist.pop. Ну короче,
[01:14:21.200 --> 01:14:25.480]  здесь повторяется вот весь тот BFS, который вы делали. То есть вот весь этот кусок кода,
[01:14:25.480 --> 01:14:34.240]  он банально повторяется туда. Единственное, что вы делаете, вы делаете не BFS push этой вершинки U,
[01:14:34.240 --> 01:14:51.680]  а at dist dist iti push от U. То есть здесь будет 4. Сколько времени? Нормально, еще целых 10 минут
[01:14:51.680 --> 01:15:01.760]  до лекции. А опоздать на 5 минут не страшно. 4U сосед current. Мы говорим следующее, что если dist от U
[01:15:01.760 --> 01:15:15.920]  равен минус 1, то что мы делаем? Мы говорим следующее, что at dist от U, просто говорим dist от U
[01:15:15.920 --> 01:15:40.400]  равно dist от V плюс вес ребра plus вес ребра из current в U. И теперь делаем at dist iti.
[01:15:40.400 --> 01:16:08.160]  at dist iti push at dist iti push от U. Еще фигурная скобка и еще фигурная скобка. Вот это один KBFS.
[01:16:08.160 --> 01:16:18.880]  Так, ладно. Вроде все корректно, да? Единственная проблема с тем, что сколько мы шагов делаем.
[01:16:18.880 --> 01:16:33.360]  Не в шагах. Давайте посчитаем, сколько времени это занимает. Здесь KBFS, но суммарно мы рассмотрим
[01:16:33.360 --> 01:16:51.280]  каждый ребро не более одного раза, согласны? Поэтому время от KV плюс E. Память от K на модуль V,
[01:16:51.280 --> 01:17:08.640]  согласна? Потому что у вас K на V очередей. А сколько хотите? Но вы каждый ребро посещаете не более
[01:17:08.640 --> 01:17:14.480]  одного раза, поэтому E. KV, потому что у вас здесь цикл по KV. Хорошо, последнее утверждение,
[01:17:14.480 --> 01:17:21.360]  которое нужно доказать, давайте его не буду записывать, что хватит K очередей. Не нужно столько
[01:17:21.360 --> 01:17:27.520]  памяти делать. Хватит ровно K очередей. Почему? Потому что каждый шаг, когда вы рассматриваете
[01:17:27.520 --> 01:17:34.160]  какую-то вершинку, она у вас не может больше, чем на K сдвинуться по очередям. Значит, суммарно у
[01:17:34.160 --> 01:17:42.960]  вас единовременно заполнено не более, чем K очередей на самом деле. Мыслительный процесс, давайте.
[01:17:42.960 --> 01:17:53.120]  Потому что так просто понять. Это подготовка, да. Теперь смотрите, достаточно K очередей,
[01:17:53.120 --> 01:18:00.160]  почему? Потому что у вас единовременно работает не более, чем K очередей, согласны? Ну, кто не
[01:18:00.160 --> 01:18:09.920]  согласен, тот подумает и согласится. Поэтому здесь можно писать, вот нужно все вот это норм. Только
[01:18:09.920 --> 01:18:27.760]  здесь берется и%K, здесь берется dist2%K. Все, а нет, еще здесь, еще здесь %K. Все, это победа. Мы
[01:18:27.760 --> 01:18:34.800]  сократили память сразу с вами с KV на просто от V. Ну, на память графа, скажем так. Потому что
[01:18:34.800 --> 01:18:41.280]  вам нужно хренепанально очередь эту. Поэтому у вас суммарно от K памяти, вот так скажем. То есть
[01:18:41.280 --> 01:18:51.440]  умножить превратили в K+. Ну и последняя вишенка на торте, самая последняя. Как заменить единицу
[01:18:51.440 --> 01:18:59.480]  на ноль? Здесь. То есть как сделать 0K BFS? Нет, массив деков делать не будем. Просто будем пихать,
[01:18:59.480 --> 01:19:08.600]  если у нас вес вибра равен нулю, в ту же самую очередь, в которой мы находимся. Все, мы вывели 0K BFS и победа.
