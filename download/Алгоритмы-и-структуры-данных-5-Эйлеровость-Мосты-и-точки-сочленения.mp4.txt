[00:00.000 --> 00:14.340]  Я продолжаю говорить про DFS-like алгоритмы. Начнем с
[00:14.340 --> 00:24.080]  эйлеровых циклов и путей. Эйлеровые циклы и пути.
[00:24.080 --> 00:32.720]  Самое определение. Эйлеров цикл — это просто цикл, который проходит по всем ребрам графа ровно один раз.
[00:32.720 --> 00:45.040]  Эйлеров цикл — это цикл, проходящий по всем ребрам графа ровно один раз.
[00:45.040 --> 01:04.560]  То есть какая-нибудь картинка такая, пусть, например, будет.
[01:04.560 --> 01:13.720]  Что-нибудь такое. Если это, например, стартовая вершина, можно вот так обойти все ребра графа,
[01:13.720 --> 01:19.120]  вернуться туда же, откуда начали, получить цикл. Мы заканчиваемся там же, где начали.
[01:19.120 --> 01:22.840]  И при этом каждый реброр ровно один раз в нашем цикле поучаствовал.
[01:22.840 --> 01:30.200]  Аналогичное определение эйлеров-путь. То же самое, только это путь, проходящий по всем
[01:30.200 --> 01:34.560]  ребрам ровно один раз. Не буду писать, скажу, что эйлеров-путь аналогичен.
[01:34.560 --> 01:48.760]  И есть очень простой критерий существования эйлеров-пути, эйлеров цикла. Мы его сейчас докажем
[01:48.760 --> 01:53.440]  и предъявим конструктивный алгоритм нахождения эйлерового цикла, что в ориентированном,
[01:53.440 --> 01:58.840]  что в неориентированном графе. Здесь мне надо предварительно сказать пару слов,
[01:58.840 --> 02:02.480]  которые наверняка вы знаете, но на всякий случай для формальности ввиду.
[02:02.960 --> 02:16.340]  Это степень вершины. Это просто количество ребр, которые из нее торчат.
[02:16.340 --> 02:20.920]  В случае ориентированного графа, это суммарное количество —
[02:20.920 --> 02:24.880]  сколько ребер входит, сколько выходит. В случае неориентированного графа —
[02:24.880 --> 02:29.160]  это просто н horizont на этой вершине, сколько ребер содержит ее как один из своих концов.
[02:29.160 --> 02:37.360]  То есть формально давайте для ориентированного случая напишу,
[02:37.360 --> 02:48.160]  например, степень вершины v это просто количество таких e, маленьких из e большого,
[02:48.160 --> 02:55.160]  что v... ну я все равно так напишу, v принадлежит e.
[02:55.160 --> 03:00.160]  Потому что e это у меня пара упорядоченная или неупорядоченная,
[03:00.160 --> 03:02.160]  в случае ориентированного графа упорядоченная.
[03:02.160 --> 03:06.160]  Ну вот, соответственно, в скольких парах v участвует как один из элементов пары?
[03:06.160 --> 03:08.160]  То есть буквально где она участвует?
[03:08.160 --> 03:10.160]  То есть она может участвовать как вторым элементом пары,
[03:10.160 --> 03:14.160]  то есть когда в нее идет ребро, или первым, когда из нее выходит ребро.
[03:14.160 --> 03:16.160]  Суммарное количество ребр это степень,
[03:16.160 --> 03:19.160]  ну а если я живу в ориентированном случае,
[03:19.160 --> 03:22.160]  и мне хочется посчитать суммарное количество входящих и исходящих,
[03:22.160 --> 03:26.160]  то это называется, соответственно, входная и исходная степень, исходящая степень.
[03:26.160 --> 03:31.160]  Я это буду обозначать in degree это входная степень,
[03:31.160 --> 03:40.160]  и out degree это исходящая степень.
[03:41.160 --> 03:45.160]  Сколько ребр входит в вершину, сколько ребр выходит из вершины.
[03:45.160 --> 03:49.160]  Ну, наверное, значит в какой-то степени вершина, да?
[03:49.160 --> 03:51.160]  Вот, хорошо.
[03:51.160 --> 03:53.160]  Ну и теорема.
[03:53.160 --> 03:58.160]  Давайте я сформулирую две штуки отдельно для ориентированного, для неориентированного случая.
[03:58.160 --> 04:00.160]  Теорема первая.
[04:00.160 --> 04:07.160]  Эйлеровость в неориентированных графах.
[04:08.160 --> 04:12.160]  Тоже наверняка где-то слышали.
[04:12.160 --> 04:14.160]  Я утверждаю следующее.
[04:14.160 --> 04:22.160]  Во-первых, ну, начало, пусть же это неориентированный граф,
[04:22.160 --> 04:33.160]  тогда в нем есть эйлеров цикл.
[04:33.160 --> 04:40.160]  Если только, если верно, следующее.
[04:40.160 --> 04:42.160]  Ну, почти, да.
[04:42.160 --> 04:47.160]  Граф G после удаления изолированных вершин становится связным,
[04:47.160 --> 04:52.160]  и степень каждой вершины четна.
[04:52.160 --> 05:00.160]  Граф G после удаления изолированных вершин
[05:00.160 --> 05:07.160]  становится связным,
[05:07.160 --> 05:19.160]  и для любого V степень V четна.
[05:19.160 --> 05:22.160]  Ну, потому что нам связанность нужна.
[05:22.160 --> 05:33.160]  Если граф не связан, то там эйлерово... эйлерово цикла нет.
[05:33.160 --> 05:35.160]  Еще раз, если у вас граф...
[05:35.160 --> 05:38.160]  Смотрите, вам надо добавить требования связности,
[05:38.160 --> 05:42.160]  потому что без связанности, например, если у вас просто там два цикла,
[05:42.160 --> 05:45.160]  то понятно, тут нет эйлерово цикла в таком графе.
[05:45.160 --> 05:47.160]  Поэтому связанность вам нужна в каком-то виде.
[05:47.160 --> 05:50.160]  Ну, а если вы требуете связанности, и у вас есть изолированные вершины,
[05:50.160 --> 05:54.160]  то это тоже некорректные условия, потому что если у вас есть цикл изолированных вершин,
[05:54.160 --> 05:58.160]  то это граф эйлеров, потому что вот, пожалуйста, эйлеров цикл, который все проходит.
[05:58.160 --> 06:05.160]  Поэтому единственное замкнутое требование на граф для наличия эйлерово цикла вот такое,
[06:05.160 --> 06:09.160]  что можно выкинуть изолированные вершины изолированными,
[06:09.160 --> 06:13.160]  как раз те, у которых вообще нет ребер, у которых степень нулевая.
[06:13.160 --> 06:17.160]  Вот мы их все удаляем, понятное дело, потому что они не влияют на эйлеровость,
[06:17.160 --> 06:21.160]  их не надо обходить вообще, они как бы для графа несущественны.
[06:21.160 --> 06:25.160]  Дальше понятно, что граф должен получиться связанным,
[06:25.160 --> 06:28.160]  потому что иначе, если есть две какие-то компоненты, одна другая,
[06:28.160 --> 06:30.160]  мы не сможем одним циклом их все обойти.
[06:30.160 --> 06:34.160]  Ну и в чётной степени понятно более-менее, потому что если у нас есть цикл,
[06:34.160 --> 06:38.160]  то мы в каждую вершину зашли и вышли, возможно несколько раз,
[06:38.160 --> 06:42.160]  то есть возможно там мы можем как-то петлять, не знаю, вот что-нибудь такое может быть.
[06:42.160 --> 06:46.160]  Но тем не менее мы в эту вершину вышли, зашли, вышли, зашли.
[06:46.160 --> 06:50.160]  Поэтому суммарное количество посещений вершины будет чётное, значит степень должна быть чётная.
[06:50.160 --> 06:55.160]  Вот, значит это для случая цикла, для случая пути,
[06:55.160 --> 07:00.160]  ну верно всё то же самое, только возможно для каких-то двух вершин степень нечётная.
[07:00.160 --> 07:08.160]  Значит уже есть эллеров путь, если только если.
[07:08.160 --> 07:13.160]  Ну выполняется всё вот это вот, давайте я это просто скопирую.
[07:13.160 --> 07:19.160]  И у всех вершин, кроме быть может двух, степень чётный.
[07:19.160 --> 07:30.160]  У всех вершин, кроме быть может двух, степень чётный.
[07:36.160 --> 07:40.160]  Ну это как раз соответствует какой-то вот такой картинке, давайте нарисую.
[07:40.160 --> 07:44.160]  Знаете, какой-то старт и финиш, то есть начало и конец эллерово пути.
[07:44.160 --> 07:48.160]  Такой, что суммарно он покрывает все ребографы по одному разу.
[07:48.160 --> 07:51.160]  Ну и тогда понятно, что здесь у всех промежуточных степень чётная,
[07:51.160 --> 07:55.160]  потому что мы зашли, вышли в вершину, возможно несколько раз, но суммарно, понятно,
[07:55.160 --> 07:59.160]  чётное количество раз как бы сквозь неё прошли.
[07:59.160 --> 08:03.160]  Ну это верно для всех вершин, кроме вот этих двух, кроме СТ.
[08:03.160 --> 08:07.160]  Соответственно путь есть, если, ну либо вообще в идеальном мире, если есть цикл,
[08:07.160 --> 08:15.160]  потому что понятно, если есть цикл, то есть и путь, цикл в частном случае пути.
[08:15.160 --> 08:20.160]  Ну либо же содержательно, цикла нет, а путь есть, тогда это какая-то такая картинка,
[08:20.160 --> 08:25.160]  что есть две вершины нечётной степени, а все остальные чётные.
[08:25.160 --> 08:33.160]  Похоже на правду? Ещё раз? Одной вершины нечётной степени быть не может,
[08:33.160 --> 08:37.160]  по алеме рукопожатиях у нас сумма всех степеней чётная обязательно,
[08:37.160 --> 08:39.160]  значит если есть одна нечётная, то есть обязательно дополнительная вторая,
[08:39.160 --> 08:42.160]  поэтому если есть одна, то есть другая.
[08:42.160 --> 08:48.160]  Вот, ну и очень похожая теорема для эйлеровости в ориентированных графах.
[08:55.160 --> 08:58.160]  Ещё раз? Ещё раз?
[08:59.160 --> 09:03.160]  Должен, почему же? То же самое, то же самое требование,
[09:03.160 --> 09:07.160]  значит мне надо проходить по всем ребрам ровно по одному разу.
[09:12.160 --> 09:17.160]  В смысле, если просто цикл, ну цикл это частный случай пути, это же путь, правильно?
[09:17.160 --> 09:20.160]  Путь это по сути вершина такая, что любые два седа соедены ребром,
[09:20.160 --> 09:23.160]  поэтому цикл частный случай пути.
[09:23.160 --> 09:28.160]  Вот, ну значит здесь опять пусть же это уже ориентированный граф в этот раз,
[09:30.160 --> 09:35.160]  значит тогда в нём есть эйлеров цикл,
[09:39.160 --> 09:44.160]  если и только если, ну опять, после удаления всех изолированных вершин,
[09:44.160 --> 09:49.160]  то есть вершин степени ноль, граф становится сильно связным,
[09:49.160 --> 09:52.160]  я не могу говорить про ориентированный граф, слово просто связанный,
[09:52.160 --> 09:56.160]  потому что связность в ориентированном случае это что-то странное,
[09:56.160 --> 10:00.160]  мы определялись в прошлый раз в сильную связность, вот ровно оно,
[10:00.160 --> 10:04.160]  и плюс у каждой вершины должна быть входящая степень равна исходящей,
[10:04.160 --> 10:09.160]  то есть сколько раз вершины зашли, столько раз и вышли, это критерий эйлерового цикла.
[10:09.160 --> 10:19.160]  Значит, граф G, после удаления всех изолированных вершин становится сильно связным,
[10:22.160 --> 10:35.160]  ну то есть между любой парой вершин есть путь в обе стороны,
[10:35.160 --> 10:41.160]  да, и при этом для любой вершины V входящая степень равна исходящей,
[10:41.160 --> 10:49.160]  потому что если у меня есть цикл, и я в какую-то вершину много раз захожу,
[10:49.160 --> 10:52.160]  то количество входов должно быть равно количеству выходов,
[10:52.160 --> 10:55.160]  потому что у меня, грубо говоря, нет конца, нет начала у цикла,
[10:55.160 --> 10:57.160]  если я зашел, то я должен смочь выйти, если я опять посетил,
[10:57.160 --> 11:01.160]  то я опять дальше могу пойти вдоль какого-то нового ребра.
[11:01.160 --> 11:08.160]  Ну и случай пути, собственно, аналогичен, либо верно все то же самое,
[11:08.160 --> 11:14.160]  либо вот какая-то такая же картинка, только в этом случае уже требования на S это немножко другие,
[11:14.160 --> 11:18.160]  на S должно быть требование такое, что у него исходящих на 1 больше, чем входящих,
[11:18.160 --> 11:21.160]  а у T, наоборот, входящих на 1 больше, чем исходящих.
[11:21.160 --> 11:26.160]  Ну давайте я не буду полностью формулировать про путь аналогично,
[11:26.160 --> 11:33.160]  только вот в случае, когда реально путь, а не цикл,
[11:33.160 --> 11:41.160]  на S и T немножко другие условия, но могут быть две вершины, могут быть вершины S и T,
[11:41.160 --> 11:51.160]  такие, что у S исходящая степень на 1 побольше, чем входящая,
[11:51.160 --> 12:03.160]  а у T, наоборот, исходящая на 1 меньше, чем входящая.
[12:03.160 --> 12:09.160]  Ну тоже, значит, картинка такая же, если у вас представьте та же картинка,
[12:09.160 --> 12:13.160]  только она теперь ориентированная, у вас все ребра ориентированные,
[12:13.160 --> 12:19.160]  тогда у вас понятно, что для всех промежуточных вышин на 5 вы сколько раз зашли, столько раз и вышли,
[12:19.160 --> 12:25.160]  а для S вы вышли на 1 раз больше, чем зашли, потому что вы оттуда начинаете, вы в нее не входите, но выходите,
[12:25.160 --> 12:32.160]  соответственно, на 1 раз больше вы из нее вышли, и в T, наоборот, вы входите на 1 раз больше, чем выходите.
[12:32.160 --> 12:35.160]  Ну вот. Да.
[12:36.160 --> 12:43.160]  Нет, все то же самое, вот это копируется точно так же.
[12:43.160 --> 12:47.160]  Да, справедливо, справедливо, справедливо, справедливо, вы правы, конечно.
[12:47.160 --> 12:54.160]  Ой, да, надо это латать, конечно.
[12:54.160 --> 12:59.160]  Ну конечно, да, конечно, конечно.
[12:59.160 --> 13:06.160]  Так, ну вообще в оригинальной постановке вот здесь вместо сильной связанности пишется слабая связанность.
[13:06.160 --> 13:10.160]  Слабая связанность, когда вы игнорируете ориентацию ребер, ну типа стираете стрелочки на ребрах
[13:10.160 --> 13:15.160]  и говорите, что он должен быть связан после удаления ориентации.
[13:15.160 --> 13:20.160]  Ну давайте здесь тогда это пропишу. Здесь это неважно, потому что в цикл там все равно есть пути во все стороны,
[13:20.160 --> 13:22.160]  потому что все в одном цикле лежит.
[13:22.160 --> 13:27.160]  И здесь давайте это пропишем, что вот в этом случае, видимо, если есть одна такая вершина,
[13:27.160 --> 13:30.160]  то из С должно быть все достижимо, можно так сказать.
[13:30.160 --> 13:35.160]  В этом случае из С должно быть достижимо все.
[13:35.160 --> 13:50.160]  В этом случае из С должно быть достижимо все.
[13:50.160 --> 13:54.160]  Ну, так можно сделать.
[13:54.160 --> 13:58.160]  Давайте потихоньку доказывать.
[13:58.160 --> 14:02.160]  Ну смотрите, вот первую я оставлю, она доказывается абсолютно аналогичной на второму.
[14:02.160 --> 14:05.160]  Давайте для ориентированного случая докажем только.
[14:05.160 --> 14:10.160]  И давайте сразу сведем пункт В к пункту А.
[14:10.160 --> 14:15.160]  Как можно свести поиск пути к поиску цикла?
[14:15.160 --> 14:20.160]  Прикумать еще далеко, да, еще соединить вот эти две вершины.
[14:20.160 --> 14:21.160]  Да, да, да, да, да.
[14:21.160 --> 14:24.160]  Потому что вот если у меня есть вот эти две вершины, где должен начинаться и кончаться путь,
[14:24.160 --> 14:29.160]  то давайте мы проведем ребро из одной в другую, и тогда мне нужно будет найти уже цикл.
[14:29.160 --> 14:33.160]  То есть если у меня граф какой-то вот такой, я понимаю, что начало здесь, а конец здесь,
[14:33.160 --> 14:35.160]  ну, в случае ориентированного графа,
[14:35.160 --> 14:39.160]  тогда я могу просто добавить одно вот такое ребро из ТВС.
[14:39.160 --> 14:44.160]  Тогда у меня все вот эти вот равенства превратятся в обычные, когда in degree равно out degree,
[14:44.160 --> 14:49.160]  входная равна исходящей, и достаточно найти цикл.
[14:49.160 --> 14:53.160]  Ну и понятно, если я его здесь найду, то просто удаление этого ребра мне даст путь из СВТ.
[14:53.160 --> 14:59.160]  То есть любой какой-то здесь был путь, я его дозамыкаю ребром до цикла,
[14:59.160 --> 15:04.160]  и потом, если я в этом графе нашел цикл, то после удаления ребра я получаю как раз путь из СВТ.
[15:04.160 --> 15:08.160]  Ну вот, в этом смысле как бы путь не сложнее, чем цикл,
[15:08.160 --> 15:13.160]  поэтому давайте жить в парадигме, что я ищу циклы леверов.
[15:13.160 --> 15:15.160]  Окей?
[15:15.160 --> 15:19.160]  Вот, хорошо, теперь я доказываю пункт А.
[15:19.160 --> 15:25.160]  Ну, в одну сторону я уже проговорил, что слева-направо более-менее очевидно,
[15:25.160 --> 15:32.160]  потому что если есть error of cycle, то у всех содержательных решин входная степень равна исходной исходящей.
[15:32.160 --> 15:36.160]  То есть если есть какой-то граф, то сколько раз зашли, столько раз вышли.
[15:36.160 --> 15:38.160]  Вот, интересно, в обратную сторону.
[15:38.160 --> 15:44.160]  И в обратную сторону мы предъявим просто алгоритм, который находит error of cycle.
[15:44.160 --> 15:48.160]  Предъявим алгоритм.
[15:55.160 --> 15:58.160]  То есть я считаю, что граф вот такой,
[15:58.160 --> 16:00.160]  он хороший, после удаления из СВТ сильно связан,
[16:00.160 --> 16:03.160]  и любой вершины исходящей равна входящей.
[16:03.160 --> 16:06.160]  Как тогда найти error of cycle?
[16:06.160 --> 16:08.160]  Ну, давайте сделаем следующее.
[16:08.160 --> 16:13.160]  Давайте запустим такой тупой DFS без запоминания вершин.
[16:13.160 --> 16:18.160]  То есть давайте просто запустим какой-то обход графа, который идет по ребрам.
[16:18.160 --> 16:20.160]  Ну, понятно, ребра нам нельзя переиспользовать,
[16:20.160 --> 16:23.160]  поэтому как бы по ребрам он идет только один раз,
[16:23.160 --> 16:26.160]  но он не запоминает вот эти вот метки посещенности вершин.
[16:26.160 --> 16:30.160]  Если он когда-то видит ребро в вершину, даже в которой он когда-то бывал,
[16:30.160 --> 16:32.160]  то он все равно идет вдоль этого ребра.
[16:32.160 --> 16:37.160]  То есть, ну, такой давайте напишу, в кавычках DFS без запоминания.
[16:37.160 --> 16:41.160]  Потому что у меня DFS всегда был такой, что я дохожу до вершины
[16:41.160 --> 16:44.160]  и не иду туда, где я уже был.
[16:44.160 --> 16:47.160]  То есть я не иду в небелые вершины в DFS.
[16:47.160 --> 16:49.160]  Ну, типа того, да.
[16:49.160 --> 16:51.160]  То есть я просто не говорю, что у меня есть какие-то цвета,
[16:51.160 --> 16:55.160]  и просто вижу новое ребро, иду вдоль него, запускаюсь рекурсивно вот в этой новой вершинке.
[16:55.160 --> 16:59.160]  То есть, ну, там, не знаю, какая-нибудь процедурка у меня есть.
[16:59.160 --> 17:02.160]  Ailer, какой-нибудь error of cycle от вершины В.
[17:02.160 --> 17:04.160]  Значит, что он делает?
[17:04.160 --> 17:06.160]  Это функция рекурсивная.
[17:06.160 --> 17:10.160]  Находит произвольное неиспользованное еще ребро из вершинки В,
[17:10.160 --> 17:13.160]  то есть ребро, которое мы еще не обошли.
[17:13.160 --> 17:16.160]  И запускается рекурсивно вот от этого конца этого ребра.
[17:16.160 --> 17:19.160]  То есть, просто находит первое неиспользованное ребро и идет сюда.
[17:19.160 --> 17:21.160]  Запускается отсюда рекурсивно.
[17:21.160 --> 17:24.160]  Ну и так делает, пока есть неиспользованный ребро.
[17:24.160 --> 17:27.160]  Так, давайте я какое-то подобие кода напишу.
[17:27.160 --> 17:30.160]  Значит, у меня есть код.
[17:30.160 --> 17:33.160]  Так, давайте я какое-то подобие кода напишу.
[17:35.160 --> 17:43.160]  Ну, во-первых, я, видимо, скажу, что у меня в каждой вершине есть некий счетчик,
[17:43.160 --> 17:47.160]  который указывает на первое неиспользованное ребро.
[17:47.160 --> 17:52.160]  То есть, ну, понятно, у меня из этой вершины все исходящие ребра пронумерованы как-то,
[17:52.160 --> 17:56.160]  ну, потому что они лежат в каком-то там списке, в каком-то массиве.
[17:56.160 --> 17:57.160]  Значит, они пронумерованы.
[17:57.160 --> 18:00.160]  Давайте хранить просто номер первого неиспользованного.
[18:00.160 --> 18:02.160]  Пусть ptr от v.
[18:02.160 --> 18:12.160]  ptr от v – это номер первого неиспользованного ребра в g от v.
[18:12.160 --> 18:15.160]  То есть, в списке исходящих ребер из вершинки v.
[18:18.160 --> 18:21.160]  Ну и тогда вот эта процедура поиска лидерного цикла.
[18:21.160 --> 18:25.160]  Так, давайте я еще вот здесь вот передам вторым параметрам.
[18:25.160 --> 18:32.160]  Я добавлю сюда parent edge.
[18:32.160 --> 18:33.160]  Давайте так его назову.
[18:33.160 --> 18:35.160]  То есть parent edge.
[18:35.160 --> 18:40.160]  То есть это ребро, по которому мы вошли в эту вершинку.
[18:40.160 --> 18:45.160]  То есть я зашел в вершину v с помощью какого-то ребра вот эта вот parent edge.
[18:45.160 --> 18:47.160]  parent edge.
[18:47.160 --> 18:48.160]  Вот.
[18:48.160 --> 18:51.160]  Значит, тогда эта процедура делает следующее.
[18:51.160 --> 18:55.160]  Пока ptr от v не равен к концу этого списка, то есть пока есть неиспользованные ребра,
[18:55.160 --> 18:58.160]  идем вдоль ребра с номером ptr от v.
[18:58.160 --> 19:05.160]  То есть пока ptr от v не равно…
[19:05.160 --> 19:07.160]  Ну давайте напишу out degree от v.
[19:07.160 --> 19:10.160]  То есть не равно количеству исходящих ребер.
[19:10.160 --> 19:17.160]  Я просто получаю вот это вот очередное ребро.
[19:17.160 --> 19:24.160]  Значит, пусть e это ребро вот с этим вот номером в списке g от v.
[19:24.160 --> 19:29.160]  Давайте же g vt от ptr от v.
[19:29.160 --> 19:35.160]  То есть я получил очередное ребро, исходящее из вершинки v.
[19:35.160 --> 19:37.160]  И просто иду вдоль него.
[19:37.160 --> 19:41.160]  Предварительно сдвину в счетчик, потому что вот я взял очередное неиспользованное ребро.
[19:41.160 --> 19:45.160]  Мне нужно увеличить счетчик на единичку, потому что все, я теперь его использую.
[19:45.160 --> 19:47.160]  Запускаю рекурсивно от конца этого ребра.
[19:47.160 --> 19:51.160]  То есть увеличиваю счетчик на 1.
[19:51.160 --> 19:52.160]  Вот.
[19:52.160 --> 19:58.160]  И просто рекурсивно, не думая, запускаюсь от конца этого ребра.
[19:58.160 --> 20:07.160]  Ну, давайте напишу e.to, давайте напишу e.second и e.
[20:07.160 --> 20:14.160]  То есть я запускаюсь от конца этого ребра, зная, что я пришел в него с помощью вот этого ребра.
[20:14.160 --> 20:17.160]  Это while.
[20:17.160 --> 20:21.160]  И все, в конце, когда я обошел все исходящие ребра, когда я просмотрел все исходящие ребра,
[20:21.160 --> 20:24.160]  от всех запустился рекурсивно, я просто...
[20:24.160 --> 20:29.160]  Давайте в какой-нибудь список добавлю вот это вот ребро parentage.
[20:29.160 --> 20:41.160]  Давайте какой-нибудь order, pushback, ребро, с помощью которого я зашел в вершинку v.
[20:54.160 --> 21:07.160]  Пример, как это работает.
[21:07.160 --> 21:15.160]  Вот такой граф нарисую.
[21:15.160 --> 21:17.160]  Вот что-то такое.
[21:17.160 --> 21:23.160]  Давайте предположим, что изначально наша процедура, наш вот этот вот обход рекурсивный запустился отсюда.
[21:23.160 --> 21:24.160]  Что он делает?
[21:24.160 --> 21:29.160]  Он просто берет первое попавшееся неиспользованное ребро, идет вдоль него и пытается этот путь как-то продолжить.
[21:29.160 --> 21:33.160]  Ну, вот, например, давайте предположим, что этот обход как-то вот так вот проходил.
[21:33.160 --> 21:39.160]  Он пошел сюда, сюда, потом здесь у него был выбор, ну, например, он пошел сюда, потом сюда.
[21:39.160 --> 21:45.160]  Когда-то он еще раз запустился, наша функция error сначала запустилась отсюда, отсюда, отсюда, потом прошла сюда.
[21:45.160 --> 21:47.160]  И еще раз запустилась вот отсюда.
[21:47.160 --> 21:51.160]  В этот момент я понимаю, что я обошел все исходящие ребра из данной вершины.
[21:51.160 --> 21:55.160]  Все ребра, которые были, я уже обошел, у меня ptr от v равен количеству исходящих ребр.
[21:55.160 --> 21:58.160]  То есть у меня больше нету неиспользованных исходящих.
[21:58.160 --> 22:01.160]  Тогда я говорю, окей, значит, я обошел все, что можно.
[22:01.160 --> 22:06.160]  Я откатываюсь в рекурсии на шаг назад, то есть у меня эта рекурсия завершается, я возвращаюсь вот сюда вот.
[22:06.160 --> 22:10.160]  И в список order добавляю вот это вот ребро.
[22:10.160 --> 22:14.160]  И это ребро будет последним ребром error-го цикла, который я нахожу.
[22:14.160 --> 22:15.160]  То есть я нашел вот это ребро.
[22:15.160 --> 22:18.160]  Дальше здесь то же самое, я поднялся в рекурсии сюда.
[22:18.160 --> 22:21.160]  Отсюда все исходящие ребра уже перебраны.
[22:21.160 --> 22:25.160]  Поэтому рекурсия завершается, и в order добавляется вот это вот ребро.
[22:25.160 --> 22:29.160]  Теперь моя рекурсия поднимается до вот этого вот запуска.
[22:29.160 --> 22:31.160]  Я прошел сюда, здесь все обошел.
[22:31.160 --> 22:34.160]  Теперь у меня есть возможность идти дальше, но только вот сюда вот.
[22:34.160 --> 22:39.160]  Например, пусть этот обход пошел вот так вот, вот так вот, вот так вот опять.
[22:39.160 --> 22:42.160]  Тогда опять мы рекурсивно пришли сюда.
[22:42.160 --> 22:45.160]  Видим, что в этой вершине уже больше нет ни одного исходящего ребра.
[22:45.160 --> 22:49.160]  Поэтому я просто в список order добавляю последнее вот это вот ребро.
[22:49.160 --> 22:52.160]  Потом откатываюсь сюда, откатываюсь сюда.
[22:52.160 --> 22:53.160]  Ну и здесь то же самое.
[22:53.160 --> 22:57.160]  У меня здесь aler пытается найти вот этот путь, то есть находит этот путь.
[22:57.160 --> 23:03.160]  И затем рекурсия разворачивается, и эти ребра добавляются в order в обратном порядке.
[23:03.160 --> 23:05.160]  То есть вот это, вот это, вот это.
[23:05.160 --> 23:08.160]  Потом отсюда опять же все ребра уже перебрали.
[23:08.160 --> 23:14.160]  Но ребро, с которым я прошел сюда, было вот это вот.
[23:14.160 --> 23:17.160]  Потом я откачусь вот до сюда, откачусь вот до сюда.
[23:17.160 --> 23:22.160]  Получается, что у меня в список order добавляются, ну как бы в противоположном порядке,
[23:22.160 --> 23:26.160]  как раз ребра вот этого вот alero цикла.
[23:26.160 --> 23:35.160]  То есть если я в конце, значит в самом конце я делаю реверс всего вектора order,
[23:35.160 --> 23:42.160]  тогда в нем будет лежать список ребер на alero цикле.
[23:42.160 --> 23:44.160]  Вот, сейчас докажу.
[23:44.160 --> 23:49.160]  Понятно, как работает?
[23:49.160 --> 23:52.160]  Ну хорошо, значит давайте.
[23:52.160 --> 23:55.160]  Да.
[23:55.160 --> 24:00.160]  Это скорее список смежности, как обычно gout v, это список как бы всех ребер,
[24:00.160 --> 24:02.160]  исходящих из вершины.
[24:02.160 --> 24:15.160]  А, ну я имею в виду, что gout v это список ребер, исходящих из вершины.
[24:15.160 --> 24:19.160]  Вот у меня есть вершинка v, вот у меня есть исходящие ребра из нее.
[24:19.160 --> 24:22.160]  Пусть все они лежат в неком списке gout v.
[24:22.160 --> 24:26.160]  Что такое ребро? Ребро это по факту, ну там, какая-то структурка, не знаю.
[24:26.160 --> 24:28.160]  Откуда, куда и номер ребра.
[24:28.160 --> 24:30.160]  Или там какие-то еще характеристики, если надо.
[24:30.160 --> 24:32.160]  Вот. Ну second, в смысле, куда оно ведет.
[24:32.160 --> 24:35.160]  Могу написать точка to, то есть то, куда ведет ребро.
[24:35.160 --> 24:39.160]  Значит, по факту я просто беру очередное ребро, e.
[24:39.160 --> 24:43.160]  У него есть начало, есть конец, вот конец это там, точка second.
[24:43.160 --> 24:49.160]  Ну а само ребро это ребро e.
[24:49.160 --> 24:54.160]  Нормально?
[24:54.160 --> 24:58.160]  Да, да, да, да. А точка second это конец ребра.
[25:04.160 --> 25:08.160]  Да. Я каждый раз, когда прохожу очередное, я его увеличиваю.
[25:10.160 --> 25:15.160]  Ну вот, значит, почему это будет реально eiler's?
[25:15.160 --> 25:20.160]  Почему в конце, если я разверну order, почему это будет у меня eiler's cycle?
[25:20.160 --> 25:25.160]  Ну, смотрите, давайте поймем какое вообще ребро самым первым добавится в order.
[25:25.160 --> 25:29.160]  То есть как у меня работает алгоритм, он что-то там ходит ходит по графу.
[25:29.160 --> 25:32.160]  И когда-то, вот в первый момент времени, дошел до вершины,
[25:32.160 --> 25:35.160]  у которой все исходящее уже были просмотрены.
[25:35.160 --> 25:39.160]  То есть он ходил, ходил, ходил... возможно запускался много раз в одной из вершины.
[25:39.160 --> 25:44.160]  И когда-то дошел до такой вершины, у которой все исходящее уже были просмотрены.
[25:44.160 --> 25:46.160]  То есть я от них от всех запустился как-то рекурсивно.
[25:46.160 --> 25:51.160]  Вот я утверждаю, что эта вершина обязательно будет вот эта вот из которой я начал.
[25:51.160 --> 25:57.160]  То есть если я изначально запускаю какой-то вот айлер от вершинки s,
[25:57.160 --> 26:04.160]  то первое добавленное в ордер ребро будет обязательно ребро ведущее в s.
[26:04.160 --> 26:07.160]  Ну почему? Потому что как у меня устроен алгоритм?
[26:07.160 --> 26:11.160]  Вот я встал в s и как-то иду просто по ребрам вдоль какого-то пути.
[26:11.160 --> 26:15.160]  Возможно там зацикливаюсь, запускаясь многократно от вот этих вот вершин.
[26:15.160 --> 26:21.160]  Вот, но понятно, что я всегда могу продолжить путь,
[26:21.160 --> 26:24.160]  коль скоро у меня выполняется вот это вот требование,
[26:24.160 --> 26:27.160]  что входная степень равна исходящей.
[26:27.160 --> 26:30.160]  Значит, если я пришел в вершину с помощью какого-то ребра,
[26:30.160 --> 26:33.160]  то у меня обязательно есть еще какое-то неиспользованное исходящее,
[26:33.160 --> 26:37.160]  потому что когда я попадаю в вершинку, значит я нашел какое-то входящее,
[26:37.160 --> 26:41.160]  значит есть обязательно к ней в пару какое-то исходящее ребро.
[26:41.160 --> 26:45.160]  И получается из всех вот этих вершин, я если пришел, то я обязательно смогу выйти.
[26:45.160 --> 26:47.160]  Единственная вершина, для которой это неверно, это s,
[26:47.160 --> 26:52.160]  потому что я начал с того, что откусил у нее одно исходящее ребро.
[26:52.160 --> 26:56.160]  Значит, когда-то, возможно, я могу сюда вернуться и дальше не смогу продолжить этот путь,
[26:56.160 --> 27:01.160]  потому что у меня уже вот сейчас уравнялось количество найденных входных и исходных.
[27:01.160 --> 27:04.160]  А, да, для всех остальных я всегда смогу продолжить путь.
[27:04.160 --> 27:06.160]  Значит, вершина, на которую я закончусь,
[27:06.160 --> 27:09.160]  точнее впервые напечатаю какое-то ребро, добавлю какое-то ребро в ордер,
[27:09.160 --> 27:11.160]  это обязательно вершинка s.
[27:11.160 --> 27:16.160]  Вот я обязательно найду в конце какое-то ребро, ведущее в s.
[27:16.160 --> 27:24.160]  Давайте запишем это, что первое добавленное в ордер ребро,
[27:30.160 --> 27:33.160]  это обязательно ребро в s.
[27:39.160 --> 27:55.160]  Так, хорошо.
[27:55.160 --> 28:00.160]  Еще надо заметить, что таким образом мы точно уж пощетим все ребра.
[28:00.160 --> 28:05.160]  Потому что по факту это какой-то тупой DFS, который обходит все, что можно.
[28:05.160 --> 28:10.160]  Можно, ну как бы понятно, что если что-то достижимо, то наш алгоритм точно эту вершинку найдет.
[28:10.160 --> 28:13.160]  Ну и значит там просмотрит все исходящие из нее ребра.
[28:13.160 --> 28:19.160]  Поэтому в этом вот ордере точно будут все ребра,
[28:19.160 --> 28:25.160]  в ордере будут точно все ребра, значит вопрос в каком порядке они там будут.
[28:25.160 --> 28:40.160]  Более того, в итоге ордер содержит все ребра.
[28:40.160 --> 28:43.160]  Ну и надо доказать, что они там в правильном порядке лежат.
[28:43.160 --> 28:48.160]  То есть до этого, до реверса, там реально какой-то путь в обратном порядке написан.
[28:48.160 --> 28:54.160]  Сначала последнее ребро, потом предпоследнее, вот это, вот это и так далее.
[28:54.160 --> 29:00.160]  Ну, доказывается более-менее так же, как мы понимали, что последнее ребро обязательно ребро в S.
[29:00.160 --> 29:05.160]  Вот пусть мы поняли, что в ордер я в каком-то порядке добавляю какой-то вот такой вот путь,
[29:05.160 --> 29:10.160]  ну там какой-то конец эйлерового цикла, то есть ну там что-нибудь такое, например.
[29:10.160 --> 29:14.160]  Вот как-то я вот так вот их в обратном порядке добавлял.
[29:14.160 --> 29:22.160]  Тогда если этот путь, что-то вот такое начинающееся не в S, то есть в какой-то еще вершинке T,
[29:22.160 --> 29:26.160]  тогда, ну то есть, что это значит?
[29:26.160 --> 29:29.160]  Значит, что я когда-то запустился эйлером от T,
[29:29.160 --> 29:32.160]  прошел вдоль этого ребра, там как-то позапускался,
[29:32.160 --> 29:37.160]  и все, для всех этих вершин уже просмотрел все исходящие ребра, и значит эти ребра добавил.
[29:37.160 --> 29:41.160]  Теперь дальше что я могу делать, как у меня дальше работает эйлер от T?
[29:41.160 --> 29:44.160]  То есть он вот по этой веточке запустился, там обошел все, что можно.
[29:44.160 --> 29:49.160]  Дальше, возможно, он пойдет сам по каким-то другим веточкам, и что-то обойдет.
[29:49.160 --> 29:57.160]  Ну, тогда понятно опять же, что первая вершина, которую он найдет без исходящих ребр, это может быть только T.
[29:57.160 --> 30:01.160]  Ну, потому что, что значит, как работает эйлер от T?
[30:01.160 --> 30:03.160]  То есть он сходил туда, там уже все посетил.
[30:03.160 --> 30:08.160]  Дальше он, ну опять, возможно, ходит какие-то ребра, ходит по каким-то путям, возвращается в T.
[30:08.160 --> 30:11.160]  Куда-то еще пошел, опять вернулся в T, ну и так далее.
[30:11.160 --> 30:17.160]  И, как обычно, поскольку у меня все степени, исходящая степень у всех одинаковая,
[30:17.160 --> 30:20.160]  то, значит, я обязательно смогу продолжить свой путь,
[30:20.160 --> 30:23.160]  ну, кроме, возможно, случаев, когда я нахожусь в T.
[30:23.160 --> 30:29.160]  Потому что сейчас у меня у всех вершин уравнен баланс между входящей и сходящей степенью.
[30:29.160 --> 30:56.160]  Вот, значит, если в order лежит в развернутой порядке путь от T до S,
[30:56.160 --> 31:03.160]  то, значит, очередной вызов эйлер от T,
[31:03.160 --> 31:11.160]  ну, точнее, не так, да, то следующее добавленное ребром может быть только ребром в T.
[31:26.160 --> 31:38.160]  Потому что я обошел что-то, да, вот у всех вот этих вот вершин, которые я уже просмотрел,
[31:38.160 --> 31:40.160]  от них эйлер завершился и какие-то ребра намчат.
[31:40.160 --> 31:47.160]  Значит, у всех этих вершин уже просмотрены все ребра, все исходящие ребра точно просмотрены.
[31:47.160 --> 31:51.160]  Возможно, у T не все просмотрены, но если я нахожу какое-то новое непросмотренное ребро из T,
[31:51.160 --> 31:57.160]  то я запускаюсь и обязательно вернусь в T, потому что у всех вершин вот этих вот,
[31:57.160 --> 32:01.160]  ну, сюда я попасть не могу.
[32:01.160 --> 32:05.160]  Сейчас, секунду, почему я сюда не могу попасть?
[32:28.160 --> 32:32.160]  Нет, я могу туда попасть, это я не правда говорю, конечно.
[32:32.160 --> 32:34.160]  Вот, не, все, сори.
[32:34.160 --> 32:36.160]  Значит, на самом деле я что сказал?
[32:36.160 --> 32:44.160]  Я для всех вершин, даже вот для этих, я изменил входную и исходящую степень на одну и ту же величину.
[32:44.160 --> 32:46.160]  То есть вот здесь вот я учел по одному ребру,
[32:46.160 --> 32:51.160]  здесь для этого вершинка я учел два входящих и два исходящих, ну и так далее.
[32:51.160 --> 32:56.160]  То есть у меня нарушено неравенство между входящей и исходящей только для T сейчас.
[32:56.160 --> 32:59.160]  Ну вот, значит, я вернуться, как бы я завершиться могу только в ней опять.
[32:59.160 --> 33:04.160]  Поэтому следующее ребро, которое я добавляю в ордера, оно будет какое-то ребро в T.
[33:04.160 --> 33:06.160]  Как-то так.
[33:06.160 --> 33:14.160]  Ну, смотрите, для S оно нарушено, но можно сказать, что мы в S больше никогда не зайдем,
[33:14.160 --> 33:18.160]  потому что, ну, до S я просто не могу больше добраться,
[33:18.160 --> 33:23.160]  потому что если я напечатал вот это ребро, значит, я из S исчерпал все исходящие ребра,
[33:23.160 --> 33:25.160]  а значит, я исчерпал все входящие тоже.
[33:25.160 --> 33:29.160]  Поэтому больше я в S не попаду.
[33:29.160 --> 33:31.160]  Значит, только для T эта проблема.
[33:31.160 --> 33:35.160]  Ну, то есть только T может напечататься.
[33:35.160 --> 33:37.160]  Ну вот.
[33:37.160 --> 33:41.160]  Что-то понятно?
[33:41.160 --> 33:42.160]  Хорошо.
[33:42.160 --> 33:44.160]  Ну, вот тут как бы тут очень простой алгоритм,
[33:44.160 --> 33:46.160]  но если задуматься, непонятно, почему он работает,
[33:46.160 --> 33:50.160]  но я вроде попробовал объяснить.
[33:50.160 --> 33:51.160]  Вот, все.
[33:51.160 --> 33:54.160]  Ну, понятно, что эта штука работает за линейное время.
[33:54.160 --> 33:57.160]  Симптотика алгоритма, конечно, N плюс M,
[33:57.160 --> 34:02.160]  потому что, ну, понятно, каждое ребро один раз просматривается.
[34:02.160 --> 34:05.160]  Даже можно сказать просто O от M,
[34:05.160 --> 34:08.160]  потому что в случае Эйдерова цикла мне нужна связанность,
[34:08.160 --> 34:11.160]  ну, там, сильная связанность или просто связанность в случае обычного графа.
[34:11.160 --> 34:15.160]  Если граф связан, то там ребер хотя бы столько, сколько вершин,
[34:15.160 --> 34:17.160]  ну, возможно, минус одно.
[34:17.160 --> 34:19.160]  Короче, это можно опустить.
[34:19.160 --> 34:22.160]  Ну, неважно, поскольку я все равно завожу там какой-то список,
[34:22.160 --> 34:24.160]  для каждой вершины список исходящих ребер,
[34:24.160 --> 34:26.160]  то N в каком-то виде присутствует.
[34:26.160 --> 34:29.160]  Пусть она будет.
[34:29.160 --> 34:30.160]  Вот.
[34:30.160 --> 34:34.160]  Ну, все.
[34:34.160 --> 34:36.160]  Туда еще раз проговорю на всякий случай.
[34:36.160 --> 34:39.160]  Вот такая процедура, которая просто находит первое
[34:39.160 --> 34:41.160]  попавшееся неиспользованное ребро, идет вдоль него,
[34:41.160 --> 34:44.160]  запускается рекурсивно от конца этого ребра.
[34:44.160 --> 34:47.160]  И дальше, если все ребра уже исчерпаны,
[34:47.160 --> 34:49.160]  если все исходящие ребра были просмотрены,
[34:49.160 --> 34:52.160]  то я просто в некий списочек добавляю ребро,
[34:52.160 --> 34:54.160]  с помощью которого дошел до этой вершинки V.
[34:54.160 --> 34:59.160]  То есть то, с помощью которого я дошел до сюда в очередном рекурсивном запуске.
[34:59.160 --> 35:02.160]  И дальше в конце просто запускаю реверс от ордера,
[35:02.160 --> 35:05.160]  тогда в этом порядке уже будет корректный путь из SLS.
[35:05.160 --> 35:08.160]  Да.
[35:08.160 --> 35:10.160]  Счетчик PTR?
[35:10.160 --> 35:14.160]  Ну да, чтобы не просматривать кучу раз список JOTV,
[35:14.160 --> 35:16.160]  я просто храню список на первое.
[35:16.160 --> 35:25.160]  Что значит наш родитель?
[35:25.160 --> 35:28.160]  Да, список исходящих ребер.
[35:28.160 --> 35:34.160]  Хотим, хотим.
[35:34.160 --> 35:39.160]  Вы, видимо, вот про такой случай.
[35:39.160 --> 35:43.160]  Я, честно, запускаюсь оттуда, все нормально.
[35:43.160 --> 35:48.160]  Давайте какую-нибудь картинку тоже нарисую.
[35:48.160 --> 35:53.160]  Там и здесь что-нибудь.
[35:53.160 --> 35:55.160]  Как я могу, например, обойти?
[35:55.160 --> 35:57.160]  Я могу обойти вот этот треугольничек,
[35:57.160 --> 36:00.160]  напечатать это ребро, добавить его в ордер.
[36:00.160 --> 36:02.160]  Дальше отсюда тоже запускаюсь эйдером.
[36:02.160 --> 36:04.160]  Я иду сюда и сюда. Ну окей.
[36:04.160 --> 36:06.160]  Пусть я, например, схожу вот так вот.
[36:06.160 --> 36:08.160]  То есть я спустился по какому-то ребру,
[36:08.160 --> 36:10.160]  и дальше по ребру родителя.
[36:10.160 --> 36:12.160]  Ну ничего страшного, я нашел очередную часть цикла,
[36:12.160 --> 36:16.160]  я его разворачиваю, запускаюсь эйдером отсюда.
[36:16.160 --> 36:18.160]  Он находит этот треугольник,
[36:18.160 --> 36:20.160]  и все, будет у меня вот такой корректный эйдеров цикл.
[36:20.160 --> 36:22.160]  То есть то, что я поднимаюсь в родителя,
[36:22.160 --> 36:24.160]  то есть я здесь, в общем-то, нигде не использую,
[36:24.160 --> 36:26.160]  что я не хожу по противоположному ребру.
[36:26.160 --> 36:39.160]  Это ничего страшного.
[36:39.160 --> 36:41.160]  Смотрите, я говорю следующее.
[36:41.160 --> 36:43.160]  Мне нужно просто понять,
[36:43.160 --> 36:45.160]  что в ордере лежит.
[36:45.160 --> 36:47.160]  Вот я утверждаю, что в конце, после реверса,
[36:47.160 --> 36:49.160]  в ордере лежит эйдеров цикл.
[36:49.160 --> 36:51.160]  То есть писок ребер, который начинается заканчиваться
[36:51.160 --> 36:53.160]  в одной вершине, и любые два седних ребра,
[36:53.160 --> 36:55.160]  смежные, инцидентные,
[36:55.160 --> 36:57.160]  то есть они образуют путь какой-то.
[36:57.160 --> 36:59.160]  Ну я начинаю с следующего.
[36:59.160 --> 37:01.160]  Я говорю, что понятно, что первое добавленное
[37:01.160 --> 37:03.160]  в ордер ребро это какое-то ребро в S,
[37:03.160 --> 37:05.160]  а дальше говорю, вот пусть у меня в какое-то момент времени
[37:05.160 --> 37:07.160]  в ордере лежит вот такой путь.
[37:07.160 --> 37:09.160]  Путь заканчивающийся в S.
[37:09.160 --> 37:11.160]  В самом начале путь из одного ребра,
[37:11.160 --> 37:13.160]  но дальше по мере
[37:13.160 --> 37:15.160]  продолжения алгоритма там будет какой-то путь.
[37:19.160 --> 37:21.160]  Путь будет из T в S,
[37:21.160 --> 37:23.160]  но в ордере он будет вжать
[37:23.160 --> 37:25.160]  в обратном порядке.
[37:25.160 --> 37:27.160]  То есть в ордере сначала вот это ребро,
[37:27.160 --> 37:29.160]  потом вот это, потом вот это,
[37:29.160 --> 37:31.160]  вот это, вот это, вот это.
[37:31.160 --> 37:33.160]  Нет, нет, нет.
[37:33.160 --> 37:35.160]  Элер как бы из внешнего, из мейна
[37:35.160 --> 37:37.160]  я запускаю только элер от S.
[37:37.160 --> 37:39.160]  Вот.
[37:39.160 --> 37:41.160]  Дальше. Я понимаю, что первое добавленное в ордер
[37:41.160 --> 37:43.160]  ребро это вот это, ну какое-то ребро в S.
[37:43.160 --> 37:45.160]  Скажем, вот это.
[37:45.160 --> 37:47.160]  Давайте посмотрим
[37:47.160 --> 37:49.160]  второе добавленное ребро.
[37:49.160 --> 37:51.160]  Пусть будет вот это, третье вот это,
[37:51.160 --> 37:53.160]  четвертое и так далее.
[37:53.160 --> 37:55.160]  Вот пусть там последнее, которое я знаю,
[37:55.160 --> 37:57.160]  ребро добавленное в ордер,
[37:57.160 --> 37:59.160]  это вот это вот ребро.
[37:59.160 --> 38:01.160]  Тогда я утверждаю, что следующее добавленное ребро
[38:01.160 --> 38:03.160]  обязательно ребро ведущее в T.
[38:05.160 --> 38:07.160]  Вот это я тут как-то на пальцах объяснил.
[38:09.160 --> 38:11.160]  Тогда, если я это доказал,
[38:11.160 --> 38:13.160]  то получается, что конец ордера,
[38:13.160 --> 38:15.160]  точнее начало ордера,
[38:15.160 --> 38:17.160]  это всегда какой-то путь.
[38:17.160 --> 38:19.160]  То есть у меня первое ребро вот это,
[38:19.160 --> 38:21.160]  второе вот это, третье вот это и так далее.
[38:21.160 --> 38:23.160]  Ну значит, раз это все в конце путь
[38:23.160 --> 38:25.160]  и обойдут все ребра, то я нашел как бы путь
[38:25.160 --> 38:27.160]  из S в S по всем ребрам.
[38:27.160 --> 38:29.160]  А вот я его здесь передаю.
[38:31.160 --> 38:33.160]  Когда я иду в вершину,
[38:33.160 --> 38:35.160]  я говорю, с помощью какого ребра
[38:35.160 --> 38:37.160]  я в него пришел просто.
[38:37.160 --> 38:39.160]  Ну какая-то пометочка, что
[38:39.160 --> 38:41.160]  ну ниоткуда не пришел, не печатай его.
[38:45.160 --> 38:47.160]  Так, еще может вопрос?
[38:53.160 --> 38:55.160]  Ну по тем же причинам, что вот здесь,
[38:55.160 --> 38:57.160]  вот я изначально запускаюсь
[38:57.160 --> 38:59.160]  лиром от S.
[38:59.160 --> 39:01.160]  Как он ходит?
[39:01.160 --> 39:03.160]  Он как-то идет по какому-то пути,
[39:03.160 --> 39:05.160]  что-то делает.
[39:05.160 --> 39:07.160]  И он всегда может пойти,
[39:07.160 --> 39:09.160]  если он пришел куда-то,
[39:09.160 --> 39:11.160]  он всегда может выйти,
[39:11.160 --> 39:13.160]  потому что входная равна исходящей.
[39:13.160 --> 39:15.160]  Если я в вершину пришел, то обязательно смогу выйти.
[39:15.160 --> 39:17.160]  Это верно для всех вершин, кроме S.
[39:17.160 --> 39:19.160]  Потому что у S я изначально
[39:19.160 --> 39:21.160]  использовал одно исходящее,
[39:21.160 --> 39:23.160]  но ни одного входящего.
[39:23.160 --> 39:25.160]  И все промежуточные, во все остальные вершины,
[39:25.160 --> 39:27.160]  если я вошел, то могу выйти.
[39:27.160 --> 39:29.160]  Единственные вершины, которые я не могу выйти,
[39:29.160 --> 39:31.160]  это только S.
[39:31.160 --> 39:33.160]  Потому что я в самом начале использовал одно исходящее,
[39:33.160 --> 39:35.160]  и теперь нашел еще одно входящее.
[39:35.160 --> 39:37.160]  Первый момент времени,
[39:37.160 --> 39:39.160]  когда у меня исчерпались все исходящие,
[39:39.160 --> 39:41.160]  может наступить только вершинка S.
[39:41.160 --> 39:43.160]  Значит первое добавленное в орды ребро
[39:43.160 --> 39:45.160]  это какое-то вот такое ребро.
[39:53.160 --> 39:55.160]  На самом деле,
[39:55.160 --> 39:57.160]  здесь
[39:57.160 --> 39:59.160]  мне достаточно того,
[39:59.160 --> 40:01.160]  что из S все достижимо.
[40:01.160 --> 40:03.160]  Это мне нужно для того, чтобы сказать,
[40:03.160 --> 40:05.160]  что в ордере будут содержаться все ребра.
[40:07.160 --> 40:09.160]  Поскольку я говорю про цикл,
[40:09.160 --> 40:11.160]  я S могу,
[40:11.160 --> 40:13.160]  волен выбрать любой вершиной,
[40:13.160 --> 40:15.160]  я сказал, что S произвольная вершина.
[40:17.160 --> 40:19.160]  Если он сильно связан,
[40:19.160 --> 40:21.160]  то из любой все достижимо.
[40:23.160 --> 40:25.160]  Так,
[40:25.160 --> 40:27.160]  ну что,
[40:27.160 --> 40:29.160]  давай тогда перерыв сделаем,
[40:29.160 --> 40:31.160]  и потом продолжим.
[40:31.160 --> 40:33.160]  Так, давайте продолжать.
[40:33.160 --> 40:35.160]  Теперь давайте поговорим
[40:35.160 --> 40:37.160]  про DFS в неориентированных графах.
[40:37.160 --> 40:39.160]  Вот.
[40:39.160 --> 40:41.160]  Значит,
[40:41.160 --> 40:43.160]  ну,
[40:43.160 --> 40:45.160]  давайте вспомним,
[40:45.160 --> 40:47.160]  как работает DFS в ориентированном графе.
[40:47.160 --> 40:49.160]  Можно было бы в принципе его переложить
[40:49.160 --> 40:51.160]  на DFS в неориентированном,
[40:51.160 --> 40:53.160]  но если я просто каждое ребро
[40:53.160 --> 40:55.160]  УВ воспринимаю как пара ребер
[40:55.160 --> 40:57.160]  УВ ВУ.
[40:57.160 --> 40:59.160]  И вот,
[40:59.160 --> 41:01.160]  вот,
[41:01.160 --> 41:03.160]  вот,
[41:03.160 --> 41:05.160]  вот,
[41:05.160 --> 41:07.160]  пара ребер УВ ВУ.
[41:07.160 --> 41:09.160]  Если я просто вот так вот добавлю
[41:09.160 --> 41:11.160]  по два ребра
[41:11.160 --> 41:13.160]  на каждое неориентированное,
[41:13.160 --> 41:15.160]  то можно было бы просто запускать обычный DFS
[41:15.160 --> 41:17.160]  на ориентированном графе.
[41:17.160 --> 41:19.160]  Но можно его чуть-чуть подсекономить,
[41:19.160 --> 41:21.160]  избавившись
[41:21.160 --> 41:23.160]  от цветов.
[41:23.160 --> 41:25.160]  Потому что, если вы помните,
[41:25.160 --> 41:27.160]  у нас в случае ориентированного графа
[41:27.160 --> 41:29.160]  я заводил три цвета вершин.
[41:29.160 --> 41:31.160]  Значит, первый это белый,
[41:31.160 --> 41:33.160]  когда я его вообще еще не видел.
[41:33.160 --> 41:35.160]  Второй, когда он на стеке рекурсии.
[41:35.160 --> 41:37.160]  И третий черный, когда мы его уже полностью обработали
[41:37.160 --> 41:39.160]  и заходить туда больше вообще нет смысла.
[41:39.160 --> 41:41.160]  Вот, в случае
[41:41.160 --> 41:43.160]  неориентированного графа
[41:43.160 --> 41:45.160]  я утверждаю, что серый цвет
[41:45.160 --> 41:47.160]  никого смысла не имеет.
[41:47.160 --> 41:49.160]  То есть нет смысла хранить серость вершины.
[41:49.160 --> 41:51.160]  Но вообще, зачем нам надо было,
[41:51.160 --> 41:53.160]  когда у нас возникало,
[41:53.160 --> 41:55.160]  зачем нам надо было серые вершины вообще хранить?
[41:59.160 --> 42:01.160]  Да, серость нам нужна,
[42:01.160 --> 42:03.160]  если черность отличается только в том случае,
[42:03.160 --> 42:05.160]  если я хочу определить,
[42:05.160 --> 42:07.160]  есть ли в графе цикл,
[42:07.160 --> 42:09.160]  то в ориентированном графе
[42:09.160 --> 42:11.160]  мне нужно проверять, что есть ребро в серую.
[42:11.160 --> 42:13.160]  Если есть ребро в серую вершинку,
[42:13.160 --> 42:15.160]  то есть цикл.
[42:21.160 --> 42:23.160]  В случае неориентированного графа
[42:23.160 --> 42:25.160]  я утверждаю, 못 забить и сказать,
[42:25.160 --> 42:27.160]  что серые и черные вanto одно и то же.
[42:27.160 --> 42:35.720]  неориентированном случае, можно не делать разницы между серыми и черными.
[42:42.280 --> 42:52.200]  Между серыми и черными. Вот, ну почему? Потому что раньше у меня ребро в черную
[42:52.200 --> 42:57.040]  еще не означало цикла. Что такое ребро в черную? Это, например, вот такая картинка.
[42:57.040 --> 43:04.120]  Вот если сначала, если у меня ДФС обошел сначала этот путь, потом здесь все обошел,
[43:04.120 --> 43:08.920]  покрасил эту вершинку в черный, и потом нашел только это ребро, то я вижу ребро в черную,
[43:08.920 --> 43:17.000]  и в принципе это не цикл. Потому что, ну как бы, это не цикл, понятное дело. А, соответственно,
[43:17.000 --> 43:21.280]  ребро в серую, это когда, наоборот, я вот так вот прошел, и у меня появляется ребро куда-то наверх.
[43:21.280 --> 43:27.280]  То есть, грубо говоря, черная, это когда ребро куда-то вниз, где я уже был, а серая, ребро в серую
[43:27.280 --> 43:32.640]  вершинку, это ребро наверх, где я в процессе обхода, где я еще вот на стеке рекурса, она лежит.
[43:32.640 --> 43:37.240]  Вот, ну понятно, что в случае неориентированного графа эти два случая никак не отличаются.
[43:37.240 --> 43:44.040]  Если я буду игнорировать ориентацию ребер, то ребро в серую тоже означает не цикл. Ну просто,
[43:44.040 --> 43:51.720]  как бы, который я нашел сверху вниз, а не снизу вверх. Вот, поэтому можно просто забить на серый
[43:51.720 --> 43:55.720]  цвет и красить просто все в белый и черный. Ну или другими словами, использован, не использован.
[43:55.720 --> 44:03.160]  Значит, тогда можно просто вместо цветов хранить булевский флаг. Вместо цветов можно хранить
[44:03.160 --> 44:23.160]  булевский какой-нибудь юст. Вот В. Ну были ли мы в вершине когда-то или нет. Были ли мы В. Вот.
[44:23.160 --> 44:31.560]  Ну и все. То есть, как бы, просто можно вырезать цвета и хранить юзды вместо цветов. Тогда
[44:31.560 --> 44:55.200]  все равно каждое ребро ведущее в посещенную вершину будет циклом. Вот. Ну и вообще в неориентированном
[44:55.200 --> 45:03.960]  случае можно рассмотреть как бы типы ребер. Типы ребер. Значит, как у меня работает DFS? Он
[45:03.960 --> 45:10.760]  начинается из какой-то старта вершинки S и что-то там обходит. Он как бы рассматривает все ребра и
[45:10.760 --> 45:17.560]  идет вдоль ребра, если вершина еще не посещена. Ну тогда я утверждаю, что, как бы, вот давайте те
[45:17.560 --> 45:23.960]  ребра вдоль которых идет DFS я нарисую со стрелочкой. Тогда у меня какая-то вот такая картинка будет.
[45:23.960 --> 45:33.560]  Вот. Значит, ребра со стрелочками это те, которые, как бы, вдоль которых я прошел в DFS. Они образуют
[45:33.560 --> 45:38.400]  так называемое дерево обхода DFS. Ну понятно, потому что есть как бы общий корень и дальше от него все
[45:38.400 --> 45:47.600]  как бы все идет вниз. Вот. И дальше я утверждаю, что, в общем, как еще могут быть устроены ребра
[45:47.600 --> 45:53.120]  этого графа. Это либо вот эти вот древесные ребра, которые я обошел в DFS, либо могут быть еще так
[45:53.120 --> 46:05.160]  называемые обратные ребра. Обратные ребра могут вести из потомков предка в этом дереве. Вот. Ну понятно,
[46:05.160 --> 46:11.520]  могут быть такие ребра. Самое главное, что я здесь утверждаю, это то, что не может быть ребер между
[46:11.520 --> 46:18.800]  разными по деревьям. То есть вот какой-нибудь такой картинки, например, и вот здесь вот ребро. Вот
[46:18.800 --> 46:26.360]  такого не бывает. Ну потому что, если у меня есть ребро между разными по деревьями, то, ну извините,
[46:26.360 --> 46:31.040]  когда у меня, скажем, DFS был вот здесь вот, он же должен был это ребро просмотреть. Поэтому тогда
[46:31.040 --> 46:35.240]  эта вершина должна быть не вот в том пути, а вообще как бы вот здесь вот она должна быть подвешена.
[46:35.240 --> 46:42.520]  То есть она должна идти куда-то здесь вниз. Поэтому как бы ребра между разными по деревьями в нашем
[46:42.520 --> 46:46.880]  графе быть не могут. Потому что иначе я просто это бы рассмотрел в процессе обхода вот этого DFS.
[46:46.880 --> 46:52.280]  Значит, единственные ребра, не являющиеся древесными, то есть те, по которым не ходил DFS,
[46:52.280 --> 46:56.720]  могут быть только вот эти вот обратные между потомком и предком. То есть как бы снизу вверх
[46:56.720 --> 47:03.920]  в дереве. Не там как бы, не из разных по деревьям вершины соединённые, а только как бы снизу вверх,
[47:03.920 --> 47:11.600]  ну или сверху вниз. На одном пути из корня. Вот. Ну давайте скажу, что вот это вот древесные
[47:11.680 --> 47:19.360]  ребра, да? Древесные ребра. А вот эти вот пунктирные, это обратные ребра.
[47:19.360 --> 47:25.240]  Брат это кто?
[47:25.240 --> 47:34.360]  Ещё раз.
[47:34.360 --> 47:40.360]  Вот такое? Ну то же самое.
[47:40.360 --> 47:50.000]  Если DFS сначала зашёл сюда, то перед выходом он должен был упустить вот эту. Значит,
[47:50.000 --> 47:54.640]  это ребро он тоже должен был бы просмотреть, и эта вершина была бы подвешена куда-то сюда. То же самое.
[47:54.640 --> 48:05.520]  Вот. Поэтому, когда у меня граф не ориентированный, у меня ребер на самом деле всего два типа. Это
[48:05.520 --> 48:11.280]  древесные ребра, по которым проходит DFS и обратные как бы ведущие снизу вверх вот в этом вот дереве.
[48:11.280 --> 48:18.760]  Вот. То есть ключевой момент, что таких перекрёстных ребер между разными по деревьям не бывает.
[48:18.760 --> 48:29.360]  Вот. Хорошо. Давайте это отметили. Следующее, что мы хотим сделать, это, значит, следующее
[48:29.360 --> 48:41.760]  определение. Пусть G не ориентированный граф, тогда ребро E называется мостом,
[48:41.760 --> 49:02.480]  если количество компонент связанности в графе без этого ребра E, то есть после удаления ребра E,
[49:02.480 --> 49:17.400]  количество компонент связанности строго больше, чем в исходном графе. То есть это такое ребро,
[49:17.400 --> 49:21.560]  удаление которого увеличивает несвязанность, увеличивает количество компонент связанности.
[49:21.560 --> 49:28.120]  Ну, простой пример. Какой-нибудь вот такой вот. Если у меня есть вот такой граф, то удаление вот
[49:28.120 --> 49:32.520]  это вот перемычки между треугольниками, понятное дело, если у меня была изначально одна компонента
[49:32.520 --> 49:38.840]  связанности, теперь станет две. Вот одна, вторая. Вот. Ну и родственное определение,
[49:38.840 --> 49:43.160]  это точка сочленения, это, наоборот, такая вершина удаления, которая увеличивает количество
[49:43.160 --> 50:00.480]  компонент связанности. В называется точкой сочленения, если, ну то же самое, в G-V,
[50:00.480 --> 50:26.880]  то есть после удаления вершины V, число компонент связанности больше, чем в G. Ну и,
[50:26.880 --> 50:32.080]  естественно, удаление вершины подразумевается вместе с удалением всех ребер, которые в нее
[50:32.080 --> 50:36.840]  торчали. То есть когда удаляю вершину, конечно, я удаляю также все ребра, которые ей были инциденты.
[50:36.840 --> 50:43.480]  Например, если два вот таких вот зацепленных уже по вершине треугольника, то вот эта вот вершина
[50:43.480 --> 50:48.560]  является точкой сочленения, потому что после удаления ее и всех инцидентных ей ребер у меня
[50:48.560 --> 50:56.240]  остаются две компоненты связанности, вот эта и вот эта. Значит более того, бывают ситуации,
[50:56.240 --> 51:00.960]  когда точка сочленения, точнее удаление точка сочленения оставляет не две компоненты связанности,
[51:00.960 --> 51:08.280]  а много. Например, просто если у вас много таких треугольников зацеплено, то удаление одной
[51:08.280 --> 51:13.520]  вершины делает вам сразу много компонент связанности. В отличие от мостов, потому что если вы
[51:13.520 --> 51:17.920]  удаляете мост, то более-менее интуитивно понятно, что максимум две компоненты связанности
[51:17.920 --> 51:29.920]  получится, а в случае удаления вершины может быть сколько угодно. Ну зачем это может быть нужно?
[51:29.920 --> 51:37.480]  Ну в каком-то смысле вот эти вот мосты и точка сочленения показывают вам уязвимости в вашем
[51:37.480 --> 51:42.160]  графе. То есть если у вас там какая-нибудь коммуникационная сеть, где вершинки такие там
[51:42.160 --> 51:47.560]  компьютеры, а ребра это каналы общения между ними, между какими компьютерами есть общение,
[51:47.560 --> 51:54.520]  тогда вот если есть какой-то мост и внезапно он каким-то образом ломается, тогда у вас вообще
[51:54.520 --> 51:59.400]  вся сеть становится не связана, вы не можете с одного компьютера придать информацию на другой. То
[51:59.400 --> 52:03.520]  же самое с точкой сочленения. Если есть какие-то вот такие вот компьютеры, которые завязаны на
[52:03.520 --> 52:08.280]  несколько вот таких компонент, которые без них были бы не связаны, тогда вам нужно ну вот прям
[52:08.280 --> 52:12.400]  хоть и деться, но поддерживать работоспособность этого компьютера, чтобы можно было передавать как-то
[52:12.400 --> 52:16.960]  информацию с одному на другой. То есть скажем отсюда до сюда, любой путь проходит через эту вершинку,
[52:16.960 --> 52:29.720]  поэтому вам нужно, чтобы она всегда работала. Ну вот. Соответственно задача состоит в том,
[52:29.720 --> 52:36.120]  чтобы в неориентированном графе найти все, скажем, мосты и точки сочленения. Ну давайте искать.
[52:36.120 --> 52:42.880]  Значит, для этого сначала я заведу следующую функцию на моем вот этом дереве обхода.
[52:42.880 --> 52:55.960]  Вот здесь есть дерево обхода DFS. Вот. Давайте я введу следующую функцию.
[52:55.960 --> 53:10.400]  Ретюрн от V, для каждой вершины V, показывает следующее. Как высоко я могу прыгнуть из-под дерева
[53:10.400 --> 53:19.800]  вершины V наверх, используя ровно одно обратное ребро. То есть вот представьте, я нахожусь в V,
[53:19.800 --> 53:24.640]  я могу спуститься куда-то вниз под ревестным ребром, куда-то могу спуститься вниз. И дальше
[53:24.640 --> 53:29.160]  я могу использовать одно обратное ребро. То есть могу как-то прыгнуть куда-то вот наверх. Могу,
[53:29.160 --> 53:33.640]  например, прыгнуть сюда, отсюда могу, например, прыгнуть сюда. Ну и так далее. Вот есть какие-то
[53:33.640 --> 53:37.840]  такие обратные ребра, которые торчат из этого по дереву куда-то вот наверх. И я хочу понять,
[53:37.840 --> 53:43.280]  какой максимальной высоты я могу получить. То есть насколько высоко я могу прыгнуть,
[53:43.280 --> 53:50.440]  используя одно такое ребро. Вот. Формально это следующее. Давайте напишу формально. Это минимум из.
[53:50.440 --> 53:55.960]  Ну, во-первых, может таких обратных ребер из этого по дереву вообще не быть. Тогда давайте
[53:55.960 --> 54:04.640]  просто напишем здесь T и нот В. Ну, время входа в вершинку В. Я буду хранить не вершину, а время
[54:04.640 --> 54:10.240]  входа в нее скорее. Вот. Значит, в случае, когда нету интересных ребер наверх, я просто храню
[54:10.240 --> 54:16.240]  время входа в вершинку В. А дальше, ну вот я могу перебрать все вот эти вот обратные ребра,
[54:16.240 --> 54:23.840]  ведущие снизу вверх. Дальше будет минимум по. Давайте переберем обратные ребра. Скажем,
[54:23.840 --> 54:33.560]  пусть оно ведет из W куда-то в U. Тогда я возьму T и нот U. И мне нужен этот минимум взять по всем
[54:33.560 --> 54:45.760]  таким обратным ребрам WU, что W в по дереве В. То есть минимум по всем обратным ребрам WU такое,
[54:45.760 --> 54:58.880]  что W в по дереве В. Что? Чуть позже, чуть позже покажу. Покажу, что давайте ведем вот эту штуку.
[54:58.880 --> 55:04.320]  То есть еще раз, насколько высоко я могу прыгнуть из всего этого по дереву по одному обратному ребру.
[55:04.320 --> 55:11.640]  Почему минимум? Ну, еще раз. Ред показывает не номер вершины, куда я могу прыгнуть,
[55:11.640 --> 55:16.400]  а скорее время входа в вершину. Но тогда понятно, что чем выше я поднимаюсь в дереве,
[55:16.400 --> 55:21.040]  тем меньше у меня время входа. Потому что я вхожу как раз, у меня DFS идет сверху вниз по
[55:21.040 --> 55:26.280]  этому дереву. Чем ниже, тем больше время входа в вершинку. Соответственно, чем выше, тем меньше.
[55:26.440 --> 55:30.480]  Я хочу минимальное время входа. Среди всех вершин, куда я могу прыгнуть, хочу понять
[55:30.480 --> 55:42.440]  минимальное время входа. Определение понятно? Да, вот все, что в по дереве, из любой могу
[55:42.440 --> 55:50.120]  прыгнуть наверх. Главное, что в по дереве было. Теперь, если эту функцию ввел, чуть позже я покажу,
[55:50.120 --> 56:01.400]  как ее находить. Давайте сначала поймем, зачем это надо. Утверждение. Ребро у В. Мост,
[56:01.400 --> 56:26.200]  если и только если, во-первых, оно древесное, во-вторых, ред от В равно тын от В. То есть
[56:26.200 --> 56:35.360]  картинка. Вот у меня есть какое-то ребро у В. Что вот это условие означает? Это значит,
[56:35.360 --> 56:41.720]  что из всего вот этого поддерева я не могу прыгнуть выше, чем В. То есть у меня, ну по
[56:41.720 --> 56:46.320]  умолчанию, ред от В просто тын от В, возможно меньше, если я могу прыгнуть выше. Но если равенство,
[56:46.320 --> 56:51.560]  значит я вот отсюда не могу, у меня нет ни одного вот такого ребра наверх. То есть выше, чем В,
[56:51.560 --> 56:56.760]  я прыгнуть не могу. То есть есть какие-то такие ребра, возможно, но выше ребер нет. Тогда понятно
[56:56.760 --> 57:00.660]  дело, что если я это ребро удаляю, то у меня вообще пропадает связанность между вот этой компонентой
[57:00.660 --> 57:06.080]  и у, например. Я никак не могу вот отсюда выбраться за пределы... Ну как бы, я не могу до у, например,
[57:06.080 --> 57:11.160]  дойти. Потому что таких ребер просто нет. То есть вот таких обратных ребер нету, потому что у меня
[57:11.160 --> 57:16.440]  ред от В равно тын от В, а вот таких перекрестных, то есть куда-то в другие поддеревья, их тоже нет,
[57:16.440 --> 57:21.560]  потому что граф не ориентирован. Нет у меня таких ребер в другие поддеревья. И получается,
[57:21.560 --> 57:25.360]  что у меня вот это вот отдельное, после удаления у В, это будет отдельная компонента связанности,
[57:25.360 --> 57:34.920]  из которой я до у никак не дойду. Да, это более-менее как бы в обе стороны было доказательств. Давайте
[57:34.920 --> 57:43.600]  я чуть аккуратнее докажу. Значит слева направо, пусть ребро мост. Почему оно древесное? Ну понятно,
[57:43.600 --> 57:46.960]  не древесное ребро мостом быть не может, потому что если я удалю любое не древесное,
[57:46.960 --> 57:55.840]  то у меня граф останется связанным под древесным ребром. Значит у В, давайте так, если у В не
[57:55.840 --> 58:16.120]  древесное, то его удаление не влияет на связанность. Потому что, ну как бы у меня связанность по факту
[58:16.120 --> 58:20.040]  обеспечивается только древесными ребрами сверху вниз, а все обратные можно спокойно удалять,
[58:20.040 --> 58:24.400]  связанность от этого не нарушится. Во-первых, оно тогда обязательно должно быть древесным,
[58:24.400 --> 58:33.880]  чтобы быть мостом. Ну и, да, если, например, вот это вот неверно, то есть ряд вот В меньше,
[58:33.880 --> 58:40.960]  чем ты на В, ну тогда это значит, что даже если у меня есть такое древесное ребро у В,
[58:40.960 --> 58:45.360]  и это неравенство выполняется. Значит из этого поддельного я могу прыгнуть куда-то выше,
[58:45.360 --> 58:53.360]  чем В. Значит, если я это ребро удалю, то связанность сохранится, потому что я отсюда,
[58:53.520 --> 58:57.440]  то есть из В могу дойти вниз до этого ребра, дальше прыгнуть по обратному куда-то сюда,
[58:57.440 --> 59:02.160]  и дальше, если что, спуститься до вершинки У. Я удаляю только у В, поэтому связанность у меня
[59:02.160 --> 59:05.800]  сохраняется. За счет вот этого вот обратного ребра, которое меня выводит куда-то наверх,
[59:05.800 --> 59:17.320]  я смогу обратно соединить В и У. Понятно? Вот, ну обратно, значит, если все это верно,
[59:17.320 --> 59:30.240]  то понятное дело, что удаление у В делает несвязанным у и В. Удаление у В делает у и В несвязанными.
[59:47.320 --> 59:55.200]  Значит, у нас есть критерии моста в терминах вот этой функции return. Ну теперь давайте критерий
[59:55.200 --> 01:00:07.320]  на точку сочленения. Значит, В это точка сочленения, если и только если. Значит, первое,
[01:00:07.320 --> 01:00:15.720]  первый случай, В это корень, да, то есть внешний ДФС запустился вот в вершинке В,
[01:00:15.720 --> 01:00:22.920]  В корень вот этого дерева обхода. И при этом у В, точнее из В исходят хотя бы два древесных ребра.
[01:00:22.920 --> 01:00:42.920]  Либо же второй случай, когда он не корень, то есть у меня один из двух случаев выполняется,
[01:00:42.920 --> 01:01:02.720]  В не корень, и существует древесное ребро В2 такое, что return от 2 больше равно 3 от В.
[01:01:12.920 --> 01:01:23.480]  Так, давайте с первого пункта начну. Что происходит в случае, когда В это корень, да, то есть когда
[01:01:23.480 --> 01:01:29.640]  корень дерева может быть точкой сочленения. Вот у меня есть какой-то корень дерева В, я что-то там
[01:01:29.640 --> 01:01:35.120]  обхожу с помощью ДФС. Вот я утверждаю, что тогда В это точка сочленения, если и только если мне
[01:01:35.120 --> 01:01:42.120]  нужно было пойти хотя бы два раза вдоль каких-то ребер из В. Ну понятно, если я пошел всего лишь
[01:01:42.120 --> 01:01:48.200]  вдоль одного ребра, то значит я взял просто первое попавшееся ребро, запустился ДФС отсюда и обошел
[01:01:48.200 --> 01:01:54.960]  вообще весь граф. Ну тогда понятно, что В не влияет на связанность, ее можно было бы удалить, и все,
[01:01:54.960 --> 01:02:01.480]  что остается, осталось бы связано. Ну а наоборот, если есть хотя бы два исходящих ребра, что это
[01:02:01.480 --> 01:02:08.080]  значит? Почему из корня может быть два исходящих ребра древесных? Значит, я сюда пошел, что-то обошел,
[01:02:08.080 --> 01:02:12.760]  но не все. Мне пришлось вот эту рекурсию всю завершить, подняться сюда и взять еще одно ребро.
[01:02:12.760 --> 01:02:17.200]  Но это просто значит, что вот эта, скажем, вершина недостижима вот отсюда, потому что
[01:02:17.200 --> 01:02:23.120]  будь она достижима, я бы ее нашел в этом поддере, был бы путь. Значит, если есть хотя бы два ребра,
[01:02:23.120 --> 01:02:32.480]  значит вот эти вот компоненты после удаления В останутся не связаны. Понятно? Вот. Значит,
[01:02:32.720 --> 01:03:01.240]  корня. Простой случай. Теперь пусть В не корень. Пусть В не корень. Ну давайте разберем два случая.
[01:03:01.240 --> 01:03:08.880]  Существует такое ребро или не существует? Пусть такое ребро существует. Что это значит? Поскольку
[01:03:08.880 --> 01:03:13.360]  В не корень, то у него есть обязательно родитель. Вот в дереве обхода ДФС обязательно есть у него
[01:03:13.360 --> 01:03:18.960]  какой-то родитель. То есть есть древесное ребро ПВ. Давайте скажем, что пусть такое ребро есть.
[01:03:18.960 --> 01:03:29.960]  То есть пусть существует такое ребро из В вту, что return отту больше бравно, чем ты нот В.
[01:03:29.960 --> 01:03:39.920]  Ну что это значит? Это значит, что из всего вот этого вот поддерева нельзя прыгнуть выше,
[01:03:39.920 --> 01:03:48.440]  чем В. Возможно вот есть такое обратное ребро, но выше нету. Тогда понятно, что если вы В удалите,
[01:03:48.440 --> 01:03:55.480]  то у вас П и Т станут не связанными. Потому что из всего вот этого поддерева единственное,
[01:03:55.480 --> 01:03:58.880]  что вы могли сделать, это прыгнуть В, но теперь В не существует, поэтому это ребро удалено. И
[01:03:58.880 --> 01:04:04.440]  значит это будет отдельная компонента связанности. Вы из нее никуда в другое место пойти не сможете.
[01:04:04.440 --> 01:04:13.200]  То есть если такая есть, то П и Т будут не связаны. П и Т не связаны после удаления В.
[01:04:13.200 --> 01:04:23.400]  Ну а в обратную сторону, если это неверно и, наоборот, для любого сына В не нравится
[01:04:23.400 --> 01:04:28.080]  выполняться в обратную сторону, скажем вот пусть есть один ребенок, другой ребенок,
[01:04:28.080 --> 01:04:31.800]  третий ребенок, пусть для них, для всех не нравится в обратную сторону.
[01:04:31.800 --> 01:04:42.320]  То есть скажем у1, у2, у3 и пусть return для каждого из них строго меньше, чем ты нот В.
[01:04:42.320 --> 01:04:53.160]  Это значит, что из каждого вот этого поддерева есть ребро куда-то выше, чем В. Ну то есть в П или
[01:04:53.160 --> 01:04:57.360]  еще даже куда-то выше. То есть отсюда скажем есть такое обратное ребро, отсюда куда-нибудь туда
[01:04:57.360 --> 01:05:02.400]  еще выше, отсюда куда-нибудь туда еще выше и так далее. Из каждого поддерева есть обратное
[01:05:02.400 --> 01:05:09.480]  ребро в П или еще выше. Ну тогда понятно, что В не влияет на связанность. Вы ее можете удалить,
[01:05:09.480 --> 01:05:14.480]  да, и за счет как раз вот этих обратных ребер из каждого из поддерев можете подняться наверх,
[01:05:14.480 --> 01:05:25.160]  значит всех связать в одну компонент. Норм? Ну вот, значит тогда доказали вроде.
[01:05:44.480 --> 01:05:52.760]  Получается, что для того, чтобы найти мосты и точка сочленения нам достаточно вот эту функцию
[01:05:52.760 --> 01:05:58.120]  эффективно посчитать, потому что дальше написано тривиально проверяемое условие на точке сочленения
[01:05:58.120 --> 01:06:06.640]  и на мосты. Значит как вот это искать? Ну, ищется на самом деле очень простой динамикой. Потому что
[01:06:06.640 --> 01:06:15.000]  смотрите, вот давайте посмотрим наше дерево, дерево обхода. Ну какая база динамики? Понятно,
[01:06:15.000 --> 01:06:20.280]  если у вас вершинка В это лист этого дерева, то есть вершина, из которой больше ничего не исходит,
[01:06:20.280 --> 01:06:28.360]  никаких древесных ребер не исходит, то return от В считается очень просто. Return от В, это нужно
[01:06:28.360 --> 01:06:34.280]  просто просмотреть вообще все ребра, которые из нее есть, ну и найти из них самое высокое. Если
[01:06:34.280 --> 01:06:43.360]  здесь есть несколько обратных ребер, надо просто найти из них самое высокое, самое высокое ребро из В.
[01:06:43.360 --> 01:06:54.760]  Потому что в случае, когда В это лист, у него нет под дерево, у нас как бы ниже идти некуда,
[01:06:54.760 --> 01:07:01.920]  можно только отсюда куда-то прыгать наверх. Ну а дальше, если я для всех скажем, вот пусть
[01:07:01.920 --> 01:07:06.480]  для этих листов я все посчитал, как для этой вершинки посчитать? То есть если какая-то вершинка
[01:07:06.480 --> 01:07:11.720]  теперь пусть будет опять тоже В, для всех ее детей я return посчитал. То есть для всех вот этих вот штук
[01:07:11.720 --> 01:07:28.600]  я знаю red. Как найти red от В? Да просто минимум вроде. Я же храню как бы самую высокую вершину,
[01:07:29.560 --> 01:07:34.960]  ну просто как бы я либо отсюда, я либо из В куда-то прыгаю наверх, либо из одного из этих под деревьев
[01:07:34.960 --> 01:07:40.520]  куда-то тоже прыгаю. Поэтому мне нужно просто взять минимум из вот этих вот return и опять-таки
[01:07:40.520 --> 01:07:49.480]  минимум по всем обратным ребрам ведущим из В. В этом случае это либо по обратному ребру из В,
[01:07:49.480 --> 01:08:04.840]  либо return от одного из сыновей, либо минимум из return от U, давайте return от
[01:08:04.840 --> 01:08:11.200]  U по всем вот этим вот древесным ребрам. Таким, что V запитает U это древесное ребро.
[01:08:11.200 --> 01:08:23.740]  Потому что либо я сразу из В прыгаю куда-то наверх, либо я сначала спускать в одно из под
[01:08:23.740 --> 01:08:27.960]  деревьев. Ну либо сюда, либо сюда, либо сюда. Вот я куда-то спустился и оттуда прыгаю наверх.
[01:08:27.960 --> 01:08:33.120]  Для каждого из них я уже знаю return, знаю red и надо просто взять минимальный из них. То есть как
[01:08:33.120 --> 01:08:44.040]  высоко я могу прыгнуть. Ну и все. Получается, что вот эту штуку, вот этот red можно насчитывать даже
[01:08:44.040 --> 01:08:53.360]  сразу вот в процессе DFS. Если я просто пишу DFS, то сразу же я могу насчитывать red. Потому что
[01:08:53.360 --> 01:08:58.000]  что такое листья? Понятно, листья это как бы вершины, из которых DFS дальше никуда не идет. Если
[01:08:58.000 --> 01:09:02.960]  V такая, то return надо просто перебрать все обратные ребра и посчитать, вот, проставить здесь значение red
[01:09:02.960 --> 01:09:09.960]  от V. Если у меня DFS вот всех под деревьев завершился и я знаю корректные return для них, то return от V
[01:09:09.960 --> 01:09:14.440]  считается, опять же, по такой же форме, прям внутри DFS. То есть нам не нужно писать вспомогательную
[01:09:14.440 --> 01:09:19.200]  функцию. Ну как бы можно при желании, но эти return можно в принципе насчитать и прям внутри DFS.
[01:09:19.200 --> 01:09:30.760]  Чтобы еще раз не обходить граф, можно все эти штуки насчитать прям внутри DFS. Ну вот. Нормально?
[01:09:32.960 --> 01:09:50.200]  Хорошо. Так, ну тогда давайте еще чуть-чуть дальше посмотрим. Дальше можно говорить так же,
[01:09:50.200 --> 01:09:59.840]  как у нас было про сильную связность, можно вести двусвязность. Определение вершины
[01:09:59.840 --> 01:10:23.120]  U и V называются реберно-двусвязными, если между ними существует два реберно-непересекающихся пути.
[01:10:29.840 --> 01:10:49.240]  То есть пути могут пересекаться по вершинам, но главное, чтобы по ребрам не пересекались.
[01:10:49.240 --> 01:10:59.800]  Да. То есть может быть какой-то такой путь и какой-нибудь вот такой путь. То есть им можно
[01:10:59.800 --> 01:11:05.400]  пересекаться по вершинам, но главное, чтобы по ребрам не было. Тогда такие вершины, если есть
[01:11:05.400 --> 01:11:16.280]  такие два пути, вершины называются реберно-двусвязными. Утверждение. Реберно-двусвязанность
[01:11:16.280 --> 01:11:32.600]  это отношение к эволентности на вершинах. Ну не совсем. Почему, очевидно?
[01:11:46.280 --> 01:12:03.280]  Да. А транзитивность? Что? Транзитивность вот похитрее, надо немножко повозиться. Вот надо
[01:12:03.280 --> 01:12:11.800]  аккуратно сказать какие. Ну да, значит, начало простое. Давайте я так и напишу,
[01:12:11.800 --> 01:12:18.960]  что рефлексивность и симметричность, они очевидны. Ну почему вершина сама с собой
[01:12:18.960 --> 01:12:23.680]  реберно-двусвязана? Потому что можно стоять на месте, это тривиальный путь, и второй путь тоже
[01:12:23.680 --> 01:12:29.280]  стоять на месте просто. Это два пути, они не пересекаются по ребрам, поэтому любая вершина сама
[01:12:29.280 --> 01:12:33.800]  с собой двусвязана. Почему симметрична? Ну понятно, если есть два пути из УВ, то есть два пути из ВВ,
[01:12:33.800 --> 01:12:42.280]  потому что граф неориентированный. Теперь транзитивность. Вот пусть мне известно,
[01:12:42.280 --> 01:12:50.120]  что между У и В есть два пути реберно-непересекающихся, и между В и ВВ есть какие-то два пути реберно-непересекающихся.
[01:12:50.120 --> 01:12:58.360]  Проблема в том, что путь, скажем, от В до ВВ и от В до У могут очень сильно пересекаться. Они
[01:12:58.360 --> 01:13:05.720]  пришли как бы из разных условий, и они могут вот как бы вот, давайте получу картинку, нарисую,
[01:13:05.720 --> 01:13:14.400]  может быть что-то вот такое, например, в таком стиле. Поэтому просто склеить их не получится,
[01:13:14.400 --> 01:13:20.080]  нельзя просто сказать, давайте от У дойдем до В, от В до ВВ, склеив там какие-то два пути, и от У до В
[01:13:20.080 --> 01:13:30.440]  и от В до ВВ по другому пути. Ну можно, да, вот надо сказать как. Ну для этого действительно давайте
[01:13:30.440 --> 01:13:43.920]  просто посмотрим вот этот вот цикл. Пусть С это реберно-простой цикл, то есть без повторов ребер,
[01:13:43.920 --> 01:13:55.640]  на У и В. То есть это вот те ребра, которые обеспечивают два непересекающихся пути из У в. Это
[01:13:55.640 --> 01:14:01.800]  какой-то цикл. Возможно он с самопересечениями, но неважно, это просто какой-то цикл. И дальше
[01:14:01.800 --> 01:14:07.560]  давайте посмотрим два пути. Вот пусть у меня есть путь П1 из ВВ до В, есть путь П2, тоже из ВВ до В.
[01:14:07.560 --> 01:14:13.040]  У меня есть два таких реберно-непересекающихся пути. Тогда давайте просто возьмем вот на этом
[01:14:13.040 --> 01:14:26.040]  вот пути П1 и на пути П2 самые первые вершины, попадающие в цикл С. Пусть Х1, Х2 это первые вершины
[01:14:26.040 --> 01:14:47.880]  путей П1, П2, лежащие на цикле С. В этой картинке вот это и вот это. Возможно сам путь многократно
[01:14:47.880 --> 01:15:04.680]  пересекается с циклом. Давайте рассмотрим первые пересечения. Тогда какая у меня картинка? У меня
[01:15:04.680 --> 01:15:11.960]  есть реберно-простой цикл между У и В, на котором еще выделены какие-то две вершинки Х1, Х2. Возможно
[01:15:11.960 --> 01:15:20.240]  одинаковые, возможно разные. Давайте вот так нарисую Х1, Х2. Что я знаю? Я знаю, что если я нарисую пути
[01:15:20.240 --> 01:15:27.240]  от Х1 до В и от Х2 до В, то они, во-первых, между собой не пересекаются по ребрам, потому что это
[01:15:27.240 --> 01:15:33.680]  были куски путей между В и В. И более того, они не пересекаются с циклом вообще, потому что это были
[01:15:33.680 --> 01:15:39.160]  первые вершины на путях, попавшие в цикл. То есть вот эти куски я могу смело добавлять в ответ. Они
[01:15:39.160 --> 01:15:44.240]  и между собой не пересекаются, и с циклом тоже не пересекаются. Ну а дальше нужно просто аккуратно
[01:15:44.240 --> 01:15:49.000]  на этом цикле выбрать два пути. Ну скажем вот, на этой картинке можно взять вот так, от У до Х1
[01:15:49.000 --> 01:15:56.160]  и по тому пути, и от У до Х2 и по вот этому пути. Тогда я обеспечивал как раз два не пересекающихся
[01:15:56.160 --> 01:16:03.320]  пути от У до В. Ну и здесь нужно перебирать в случае, как именно расположены Х1, Х2 на цикле,
[01:16:03.320 --> 01:16:13.040]  потому что, например, если они расположены ну как-нибудь вот так вот, то мне, ну по сути,
[01:16:13.040 --> 01:16:19.800]  то же самое. Но только у меня вот этот путь будет как бы подлиннее. И дальше опять они доходят до В.
[01:16:19.800 --> 01:16:28.600]  Вот. Ну это неважно. Главное, что у меня на этом цикле есть какие-то две вершинки. Понятно,
[01:16:28.600 --> 01:16:34.000]  что я могу от У нарисовать два не пересекающихся пути до них, до Х1 и до Х2, и дальше эти пути
[01:16:34.000 --> 01:16:44.920]  продолжить до пути до В. Тогда вот это все будет два реберно-не пересекающихся пути. Понятно? Ну вот.
[01:16:44.920 --> 01:16:50.080]  Значит это действительно свойство отношения эквивалентности. Значит по нему можно выделять
[01:16:50.080 --> 01:17:02.440]  компоненты как бы реберно-дву связанности. Вот. Ну, давайте утверждение тогда, наверное.
[01:17:02.440 --> 01:17:09.600]  Как выделить вот эти компоненты? То есть я говорю, что, окей, это отношение-дву связанности,
[01:17:09.600 --> 01:17:14.680]  отношение-эквалентности. Значит все вершины распадаются на какие-то компоненты дву связанности.
[01:17:14.680 --> 01:17:32.000]  Вот как их искать? Я утверждаю следующее. Что если из G удалить все мосты, то компоненты
[01:17:32.000 --> 01:17:48.840]  связанности в новом графе совпадают с компонентами реберно-дву связанности исходного графа.
[01:18:02.000 --> 01:18:06.560]  Вот. То есть чтобы выделить компоненты реберно-дву связанности, достаточно удалить мосты и посмотреть на
[01:18:06.560 --> 01:18:24.400]  компоненты связанности уже. Просто связанности. Ну пример какой-нибудь давайте нарисуем. Вот
[01:18:24.400 --> 01:18:31.480]  что-нибудь такое. Такой граф. Понятно, здесь два моста и вот эти два ребра. Вроде видно,
[01:18:31.480 --> 01:18:36.120]  что все остальные лежат на каких-то циклах, поэтому они точно не мосты. Вот это вот мост и вот это
[01:18:36.120 --> 01:18:40.240]  мост. Если я их удалю, у меня получатся три компонента связанности. Одна вот эта, другая вот
[01:18:40.240 --> 01:18:48.160]  эта, третья вот эта. Ну и можно показать, что внутри вот этих вот компонент связанности все вершины
[01:18:48.160 --> 01:18:58.080]  попарно реберно-дву связаны. Вот. Ну соответственно тогда у меня вот, если мне почему-то хочется
[01:18:58.080 --> 01:19:01.800]  выделить компоненты реберно-дву связанности на нашем графе, я могу просто удалить все мосты и
[01:19:01.800 --> 01:19:07.440]  все что останется компонентами связанности будет компонентами дву связанности. Ну почему это так?
[01:19:07.440 --> 01:19:16.880]  Почему это так? Ну понятно, что если между двумя вершинами есть пути в две стороны, то удаление
[01:19:16.880 --> 01:19:30.760]  мостов эти два пути сохранит. Значит, если у и в реберно-дву связаны, то удаление мостов, удаление
[01:19:30.760 --> 01:19:52.320]  всех мостов не повлияет вот на эти два пути. Не повлияет на пути между ними. Ну потому что,
[01:19:52.320 --> 01:19:59.600]  если они были дву связаны, то понятно дело, что ни одно из этих реберов вот на этих путях не может
[01:19:59.600 --> 01:20:05.840]  быть мостом. Потому что если ребро не может быть мостом, то это в цикле. Потому что удаление
[01:20:05.840 --> 01:20:10.280]  ребра оставляет понятное дело связанность между его концами, потому что есть вот такой длинный
[01:20:10.280 --> 01:20:15.440]  путь от сюда до сюда. Поэтому ребра на этих путях точно не мосты, значит если удалю мосты,
[01:20:15.440 --> 01:20:22.800]  эти пути сохранятся. И у меня вершины останутся точно в одной компоненте связанности. Вот. Ну и
[01:20:22.800 --> 01:20:29.560]  обратно надо показать, что, значит обратно, почему если вот в этом графе какие-то две вершины попали
[01:20:29.560 --> 01:20:38.840]  в одну компоненту связанности, то они двусвязаны. Ну для этого давайте посмотрим на какое-нибудь
[01:20:38.840 --> 01:20:54.360]  ребро древесное, да, значит пусть оно не мост, пусть УВ не мост. Тогда почему У и В двусвязаны?
[01:20:54.360 --> 01:21:10.120]  Вопрос к вам. Вот пусть УВ это древесное ребро графа, но при этом не мост. Тогда
[01:21:10.120 --> 01:21:29.240]  я отжаю, обязательно У и В двусвязаны. Почему? Не совсем. Сейчас, сейчас. Ну а вдруг какой-то
[01:21:29.240 --> 01:21:43.560]  другой путь там из ВВ содержит мост. Но возможно по-разному, возможно для разных пути разные
[01:21:43.560 --> 01:22:13.480]  ребра получаются. Да, да. Да, но почему, если я удалю все мосты,
[01:22:13.480 --> 01:22:20.960]  то у меня сохранится связанность. Тут, смотрите, тут можно рассуждать даже вот, вот это можно
[01:22:20.960 --> 01:22:26.840]  сказать без удаления мостов. Смотрите, вот пусть у меня есть ребро УВ, не являющийся мостом. Тогда
[01:22:26.840 --> 01:22:34.320]  почему У и В двусвязаны? Ну потому что, что значит оно не мост? В терминах ред, это значит,
[01:22:34.320 --> 01:22:41.800]  что ред вот В меньше либо равно 3 на ту. Значит, что из этого поддерева можно прыгнуть с помощью
[01:22:41.800 --> 01:22:49.360]  обратного ребра куда-то наверх. Ну тогда понятно, почему они двусвязаны. У вас есть вот один такой
[01:22:49.360 --> 01:22:55.880]  путь, есть другой вот такой путь. Потому что из В можно куда-то спуститься так, чтобы потом по
[01:22:55.880 --> 01:23:00.640]  обратному ребру прыгнуть куда-то выше, чем У и дальше до У спуститься. Значит, они точно двусвязаны,
[01:23:00.640 --> 01:23:05.120]  есть два пути. Вот есть один такой и другой такой, через вот то самое обратное ребро,
[01:23:05.120 --> 01:23:14.160]  которое существует, потому что УВ не мост. Ну и все, а значит получается, что если я сохраняю только
[01:23:14.160 --> 01:23:22.240]  древесные не мосты, то у меня соединены могут быть только те вершины, которые двусвязаны.
[01:23:22.240 --> 01:23:27.640]  Ну значит, вот все, что останется здесь в компонентной связанности после удаления мостов,
[01:23:27.640 --> 01:23:33.320]  они внутри будут по парам двусвязаны, ну потому что любые соседи двусвязаны, и по транзитивности
[01:23:33.320 --> 01:23:44.480]  получается любые две вершины двусвязаны внутри одной компоненты. Вот, вроде доказали. Вопросы?
[01:23:44.480 --> 01:23:55.400]  Ну если нет, тогда да. Да, ну не строгие, потому что условие моста, это когда рецепт В равно ТИ на ТВ,
[01:23:55.400 --> 01:24:00.800]  а раз оно не равно, значит, он куда-то выше, чем В, значит, меньше либо равно ТИ на ТУ.
[01:24:00.800 --> 01:24:07.280]  Ну да, спасибо, закончили, если что, вопрос подадите, уточним.
