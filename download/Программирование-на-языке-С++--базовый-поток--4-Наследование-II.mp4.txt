[00:00.000 --> 00:07.000]  Начнем с того, что вспомним о чем мы говорили в прошлый раз.
[00:07.000 --> 00:10.000]  В прошлый раз мы с вами начали говорить про наследование.
[00:10.000 --> 00:13.000]  В прошлый раз мы говорили про наследование как инструмент,
[00:13.000 --> 00:17.000]  который вроде как позволяет избавиться от некоторого дублирования кода.
[00:17.000 --> 00:22.000]  Условно, если у нас есть множество классов, у которых есть какая-то общая часть,
[00:22.000 --> 00:24.000]  есть какие-то общие поля, есть какие-то общие методы,
[00:24.000 --> 00:28.000]  то мы этот общий функционал можем вынести в какой-то так называемый базовый класс.
[00:28.000 --> 00:32.000]  А дальше все остальные классы наследуют от этого базового или строят целые иерархии классов.
[00:32.000 --> 00:35.000]  Каждый следующий класс добавляет какой-то новый функционал.
[00:35.000 --> 00:39.000]  О чем мы с вами не поговорили, так это про понятие родства.
[00:39.000 --> 00:42.000]  То есть на самом деле мы бы хотели еще дополнительное свойство,
[00:42.000 --> 00:45.000]  которое бы задавало бы нам некоторое родство классов.
[00:45.000 --> 00:48.000]  В том смысле, что мы бы хотели, наверное, некоторые классы,
[00:48.000 --> 00:51.000]  если мы понимаем, что они все принадлежат какому-то общему концепту,
[00:51.000 --> 00:53.000]  мы бы хотели, например, хранить их в одном массиве.
[00:53.000 --> 00:57.000]  Но опять же, если возвращаться к примеру с мебелью, то есть у нас есть стол, стул,
[00:57.000 --> 00:59.000]  не знаю, там есть всякие парты, шкафы,
[00:59.000 --> 01:04.000]  и мы бы, наверное, хотели бы потенциально иметь возможность сохранить массив мебели,
[01:04.000 --> 01:08.000]  в нулевой ячейке хранится стол, в первой ячейке хранится стол, ну и так далее.
[01:08.000 --> 01:12.000]  Но при этом у каждой мебели есть свое собственное свойство,
[01:12.000 --> 01:15.000]  которого нет у других элементов.
[01:15.000 --> 01:19.000]  И мы с вами в прошлый раз в конце самом поговорили вот о чем.
[01:19.000 --> 01:24.000]  Условно, если у меня есть какой-то класс А,
[01:24.000 --> 01:26.000]  и от него наследован класс В,
[01:26.000 --> 01:30.000]  то мы с вами сказали, что, в принципе, если наследование публичное,
[01:30.000 --> 01:35.000]  то вот этот публичный наследок задает связь между этими классами следующее.
[01:35.000 --> 01:39.000]  В является А.
[01:39.000 --> 01:44.000]  То есть из этого следует, что везде, где я могу использовать А, там же я могу использовать и В.
[01:44.000 --> 01:48.000]  Ну, в частности, я могу, например, создавать объекты вот такие.
[01:49.000 --> 01:55.000]  То есть я могу создать объект А и при этом создать его с помощью объекта типа В.
[01:55.000 --> 01:58.000]  Ну и то же самое касается, например, массивов.
[01:58.000 --> 02:02.000]  Я могу завести массив, допустим, из трех элементов,
[02:02.000 --> 02:05.000]  и заполнить его элементами В.
[02:05.000 --> 02:09.000]  Допустим, В от единицы, В от двойки.
[02:09.000 --> 02:12.000]  Ну, казалось бы, я достиг, чего я хотел.
[02:12.000 --> 02:16.000]  То есть я могу в массиве, в котором хранятся объекты А,
[02:16.000 --> 02:18.000]  сохранить туда объекты типа В.
[02:18.000 --> 02:22.000]  Ну, вот на самом деле нет. На самом деле я не совсем добился, чего хотел. Почему?
[02:22.000 --> 02:27.000]  Потому что при присваивании объектов производного класса объектом базового класса, что происходит?
[02:27.000 --> 02:30.000]  Происходит срезка.
[02:30.000 --> 02:34.000]  То есть в объекте А остаются только те части, которые...
[02:34.000 --> 02:38.000]  В общем, в объекте А остаются только общие части с объектом В.
[02:38.000 --> 02:42.000]  И плюс, когда я буду вызывать методы, то есть если я буду вызывать, допустим,
[02:43.000 --> 02:47.000]  Вот представь себе, что у меня есть метод F и в классе А, и в классе B.
[02:47.000 --> 02:50.000]  Какой метод тут будет вызываться?
[02:53.000 --> 02:57.000]  Вот если и в классе А есть метод F, и в классе B тоже есть свой собственный метод F.
[02:57.000 --> 02:59.000]  Какой будет метод вызываться?
[02:59.000 --> 03:02.000]  Да, всегда будет вызываться метод...
[03:02.000 --> 03:06.000]  метод класса А. Почему? Потому что у нас есть такой процесс как затенение.
[03:06.000 --> 03:10.000]  Точнее, нет, тут не совсем затенение. Тут речь идет о том, что если у меня есть объект А,
[03:10.000 --> 03:14.000]  то компилятор принимает решение о том, какой метод вызвать на основании
[03:14.000 --> 03:17.000]  типа самого объекта.
[03:17.000 --> 03:20.000]  А вообще говоря, нам бы хотелось следующего свойства.
[03:20.000 --> 03:23.000]  Нам бы хотелось, чтобы все работало так.
[03:23.000 --> 03:26.000]  Нам бы хотелось, чтобы компилятор каким-то образом мог посмотреть,
[03:26.000 --> 03:29.000]  точнее, компилятор самопрограмма каким-то образом могла посмотреть,
[03:29.000 --> 03:32.000]  какой объект там на самом деле лежит, и в зависимости от этого выбрать
[03:32.000 --> 03:35.000]  один метод или второй метод. Давайте более конкретно.
[03:35.000 --> 03:38.000]  Вот представь себе, у меня есть два класса. Есть класс А, есть класс B.
[03:38.000 --> 03:41.000]  И в классе B есть метод F.
[03:41.000 --> 03:44.000]  При этом B унаследован от А.
[03:44.000 --> 03:48.000]  То есть метод F в классе А говорит о том, что был вызван метод F из А,
[03:48.000 --> 03:53.000]  и метод F в классе B говорит о том, что был вызван метод F из класса B.
[03:53.000 --> 03:56.000]  При этом B является наследником А.
[03:56.000 --> 03:59.000]  Ну, смотрите, что происходит. Тут я создаю объект типа B.
[03:59.000 --> 04:02.000]  Вот. Это B.
[04:02.000 --> 04:05.000]  Тут часть, которая относится к А.
[04:05.000 --> 04:08.000]  Тут часть, которая относится к B без А.
[04:08.000 --> 04:11.000]  Что я делаю дальше? Дальше я создаю указатель Bptr.
[04:11.000 --> 04:15.000]  А со звездой Bptr.
[04:15.000 --> 04:18.000]  Который указывает вот сюда.
[04:18.000 --> 04:21.000]  Ну, смотрите, объект типа B унаследован от А публичным образом,
[04:21.000 --> 04:23.000]  поэтому B является А.
[04:23.000 --> 04:26.000]  Поэтому раз я могу создать указатель на А, то я могу создать указатель на А,
[04:26.000 --> 04:28.000]  который указывает на B. Согласны?
[04:28.000 --> 04:30.000]  Ну, представьте себе, что А это мебель, а B это стул.
[04:30.000 --> 04:33.000]  То есть указатель на мебель может указывать на стул. Логично.
[04:33.000 --> 04:35.000]  Вот. Окей.
[04:35.000 --> 04:38.000]  И дальше что я делаю? Я говорю Bptr.
[04:38.000 --> 04:41.000]  Велочка F.
[04:41.000 --> 04:44.000]  И тут вопрос. Чего бы я на самом деле хотел?
[04:44.000 --> 04:47.000]  Ну, согласитесь, я бы на самом деле хотел, чтобы Bptr,
[04:47.000 --> 04:50.000]  так как он на самом деле указывает на объект типа B,
[04:50.000 --> 04:56.000]  я бы хотел, чтобы он вызвал мне метод F, который находится в B. Согласны?
[04:56.000 --> 04:59.000]  Ну то есть если я говорю, используй мебель, я бы хотел, чтобы
[04:59.000 --> 05:01.000]  мебель использовалась по назначению.
[05:01.000 --> 05:03.000]  Я указываю, мебель давайте использовать по назначению.
[05:03.000 --> 05:04.520]  Я бы на самом деле не хотел, чтобы...
[05:04.520 --> 05:08.000]  Не знаю, что можно делать с мебелью. Ну, мебель можно купить.
[05:08.000 --> 05:11.000]  Вообще говоря, когда я говорю, давайте использовать мебель по назначению,
[05:11.000 --> 05:14.000]  имею в виду, что давайте на него что-нибудь положим, и так далее. Согласны?
[05:14.000 --> 05:18.000]  То есть хотелось бы, чтобы программа каким-то образом могла посмотреть,
[05:18.000 --> 05:21.000]  а что же там на самом деле за объект лежит и в зависимости от этого принимала решение
[05:21.000 --> 05:23.000]  какое метод вызывать.
[05:23.000 --> 05:26.480]  такого делать не получится. Почему? Потому что, ну, компилятор, потому что у нас язык C++
[05:26.480 --> 05:30.880]  это статически типизированный язык. Да, компилятор что делает? Он просто смотрит, ага, bptr,
[05:30.880 --> 05:34.880]  какой тип имеет bptr? bptr имеет тип указатель на a, но раз это указатель на a, то значит,
[05:34.880 --> 05:40.400]  что он указывает на объект a, поэтому я буду называть метод f, который находится в a. Вот, беда.
[05:40.400 --> 05:46.920]  Как эта проблема решается? Эта проблема решается с помощью такого механизма как виртуальные
[05:46.920 --> 05:53.280]  функции. Собственно, чтобы получилось то поведение, которое мы хотим, необходимо метод f объедить
[05:53.280 --> 06:01.240]  виртуальным. Итак, что такое виртуальный метод или виртуальная функция? Виртуальная функция — это
[06:01.240 --> 06:11.480]  функция или метод, выбор реализации которого происходит на этапе выполнения программы. Вот,
[06:11.480 --> 06:15.320]  то есть, если я помечаю метод виртуальным, то я говорю компилятору. Вот, когда ты будешь
[06:15.320 --> 06:22.240]  вызывать метод, погоди, не торопись, подумай. На том объекте, для того объекта, от которого я вызываю f,
[06:22.240 --> 06:27.680]  вот там, возможно, лежит не то, что ты ожидаешь. Как это происходит? Вот, допустим, снова тут метод
[06:27.680 --> 06:33.080]  f не виртуальный. Как все устроено? Снова, объект есть объект типа b, есть указатель bptr,
[06:33.080 --> 06:37.600]  который указывает на b, но на самом деле он является указателем на a. Я говорю bptr f, что
[06:37.600 --> 06:43.320]  происходит? Компилятор видит, ага, f — это виртуальный метод, а раз f — это виртуальный метод, то значит,
[06:43.320 --> 06:48.520]  тут не все так просто как кажется. И тут компилятор говорит, ага, на самом деле, по факту, я не знаю,
[06:48.520 --> 06:52.240]  что тут может быть. То есть, указатель на a может указывать как на объекты a, так и на объекты b,
[06:52.240 --> 06:57.000]  согласны? Вот, тут компилятор говорит, я не знаю, что на самом деле будет, поэтому тут я пока ничего
[06:57.000 --> 07:00.920]  делать не буду. И потом, когда уже программа начнет свое выполнение, в процессе выполнения
[07:00.920 --> 07:05.160]  программы, когда мы дойдем до этой строчки, программа посмотрит, что тут находится,
[07:05.160 --> 07:16.080]  ага, тут лежит объект типа b, поэтому я буду вызывать метод f, который находится в b. Понятно? То есть,
[07:16.080 --> 07:22.120]  виртуальные методы — это те методы, перед вызовом которых программа сначала смотрит,
[07:22.120 --> 07:32.280]  что там за объект реально лежит, и только потом происходит реальный вызов. Ну, собственно,
[07:33.240 --> 07:37.720]  да, то есть говорит, что решение о том, какую версию методы выбрать нужно, то есть, это решение
[07:37.720 --> 07:42.900]  принимается во время исполнения программы, так называемое позднее связыванием, а не на этапе
[07:42.900 --> 07:45.680]  компиляции. То есть, до этого у нас все функции разрешались на этапе компиляции. То есть,
[07:45.680 --> 07:49.800]  до этого программа всегда знала на этапе компиляции какую функцию ей вызывать. Ну,
[07:49.800 --> 07:53.360]  за исключением того, что мы использовали указатель на функцию. Вот этот механизм,
[07:53.360 --> 07:57.680]  когда решение о том, какую функцию вызвать, откладывается на этап выполнения, называется
[07:57.680 --> 08:00.760]  позднем связывание. Почему позднем связывание? Потому что, собственно, сама
[08:00.760 --> 08:04.520]  функция A с реализацией связывается и на этапе исполнения программы,
[08:04.520 --> 08:08.720]  не на этапе компиляции. Что следует знать про виртуальные функции?
[08:08.720 --> 08:11.680]  Достаточно всего лишь один раз объявить метод виртуальным, и дальше во всех
[08:11.680 --> 08:15.800]  наследниках он будет виртуальным. Вот у меня есть класс A, в нем я объявил
[08:15.800 --> 08:19.800]  виртуальную функцию F, и дальше в структуре B, если я объявил точно такую же
[08:19.800 --> 08:23.440]  функцию, то эта функция автоматически станет виртуальной. Все функции с такой же
[08:23.440 --> 08:28.280]  сигнатурой, точнее с таким же типом, будут виртуальными. Вот. Ну и тут есть метод G,
[08:28.280 --> 08:31.960]  метод G не объявлен в виртуальном ни в структуре A, ни в структуре B, поэтому, когда
[08:31.960 --> 08:35.880]  я буду звать PTR G, у меня будет вызываться метод G, который находится в A. Почему?
[08:35.880 --> 08:40.200]  Потому что G не объявлен в виртуальной, поэтому происходит раннее связывание. То
[08:40.200 --> 08:43.080]  есть компилятор принимает решение, какую функцию вызвать на этапе компиляции. На этапе
[08:43.080 --> 08:46.880]  компиляции все, что знает компилятор, это то, что PTR указывает на A.
[08:46.880 --> 08:51.720]  Ну раз PTR указывает на A, значит G должен вызываться из класса A. Вот. А во
[08:51.720 --> 08:55.800]  второй, в последней строчке PTR F, F это виртуальная функция, поэтому тут работает
[08:55.800 --> 08:59.080]  позднее связывание, то есть программа принимает решение, какую функцию вызвать
[08:59.080 --> 09:02.160]  на этапе исполнения. То есть сначала она смотрит, какой там объект реально лежит,
[09:02.160 --> 09:11.000]  видит, что там реально лежит объект типа B, ну и потом вызывает F. Окей? Хорошо. Ну,
[09:11.000 --> 09:16.560]  собственно, вопрос такой. Вот исходя из всего этого, можно было подумать следующее.
[09:16.560 --> 09:27.400]  Давайте посмотрим вот на эти строчки кода. Ну или даже вот тут. Я создал объект B, потом
[09:27.400 --> 09:33.480]  создал указатель ABPTR, потом сделал BPTR стрелочка F. Тут может возникнуть естественный вопрос. Ну
[09:33.480 --> 09:37.320]  погодите, а зачем компилятору откладывать решение о том, какую функцию вызвать на
[09:37.320 --> 09:42.120]  этап исполнения, если кажется, что тут все можно сделать на этапе компиляции? Ну смотрите,
[09:42.120 --> 09:45.520]  компилятор же не дурак, компилятор же может все проанализировать. Он же может понять, что,
[09:45.520 --> 09:50.600]  смотрите, у меня есть тут объект B, у меня есть указатель A, он указывает на самом деле на B,
[09:50.600 --> 09:55.720]  поэтому тут нужно вызывать метод из B. И вот в том примере то же самое. Ну компилятор же тоже
[09:55.720 --> 09:59.520]  все видит, он же программу вообще читает, он же видит, что PTR на самом деле указывает на объект
[09:59.520 --> 10:04.560]  B в динамической памяти. Поэтому, когда он будет вызывать PTR от F, ему нужно вызвать метод F из B.
[10:04.560 --> 10:08.560]  То есть как бы зачем его откладывать на этап исполнения, если он все это может сделать на
[10:08.560 --> 10:16.640]  этапе компиляции? Вопрос. Зачем откладывать на этап исполнения, если кажется, что всегда можно
[10:16.640 --> 10:22.520]  сделать все на этапе компиляции? Или не всегда? Всегда ли по указателю можно понять во время
[10:22.520 --> 10:31.840]  компиляции, на что он указывает? Ну да, конечно нет. Ну вот пример, собственно очень простой пример.
[10:31.840 --> 10:37.600]  Представь себе, что тот факт, на что указывает указатель, зависит от того, какие данные мне
[10:37.600 --> 10:42.600]  пришли на вход. Ну допустим, вот я пишу int x, sin x, и дальше, если мне ввели x, то я создаю объект B.
[10:42.600 --> 10:50.000]  Если мне ввели не 0, то говорю new A. Вот. Можно ли вот по этому участку кода сказать,
[10:50.000 --> 10:55.840]  на что будет указывать PTR? На A или B? Нет, то есть на этапе компиляции это неизвестно. Это будет
[10:55.840 --> 10:59.920]  известно только на этапе исполнения. Вот. Для этого нам нужно позднее связывание. И тут вот будет,
[10:59.920 --> 11:04.800]  и соответственно вот этот вот пример, когда, в общем, позднее связывание помогает. Потому что,
[11:05.400 --> 11:11.360]  если я введу значение 0, то в последней строчке будет вызываться метод F из B. Если я введу не 0,
[11:11.360 --> 11:14.600]  то соответственно у меня PTR будет указывать на объект типа A, и в последней строчке будет
[11:14.600 --> 11:18.560]  вызываться метод F из A. То есть в зависимости от введённых данных, у меня будет вызываться либо
[11:18.560 --> 11:26.520]  один метод, либо другой метод. Вот. Собственно, для этого нужно позднее связывание. Ну и тут
[11:26.520 --> 11:30.720]  внизу написано замечание про то, что позднее связывание, естественно, работает дольше,
[11:30.720 --> 11:35.600]  чем раннее связывание. Вот. Ну, я думаю, вы понимаете, да? Потому что если компилятор всё знает заранее,
[11:35.600 --> 11:40.200]  он может всё заранее соптимизировать. Если вот тут в позднем связывании, ну тут явно происходит,
[11:40.200 --> 11:43.880]  сначала компилятор должен, точнее программа должна посмотреть, что там реально за объект лежит,
[11:43.880 --> 11:49.080]  только потом вызвать метод. Это всё более накладно. Ну, про накладные расходы мы поговорим чуть позже.
[11:49.080 --> 11:57.120]  Пока концептуально всё понятно, да? Супер. Ну, давайте, собственно, попробуем поупражняться,
[11:57.200 --> 12:03.000]  посмотрим, какие методы где будут вызваться. Собственно, вот у меня есть структура А, вне объявлен
[12:03.000 --> 12:07.460]  виртуальный метод f и не виртуальный метод g. Дальше есть структура B, вне объявлен метод f и
[12:07.460 --> 12:15.600]  виртуальный метод g. Структура C, вне объявлен метод f и константный метод g. Ну, давайте посмотрим
[12:15.600 --> 12:21.920]  сначала вот сюда, попробуем понять, что там у нас будет происходить. Вот я создал объект A,
[12:21.920 --> 12:28.800]  а равный b, объект b равный c и объект c равный c. Вызываю a.f, что будет вызываться?
[12:28.800 --> 12:42.480]  Так, вот тут, то есть тут есть два варианта, либо a, либо b. Кто за a? А кто за b? Так, кто за a?
[12:42.480 --> 12:57.480]  А, поясните, почему тут будет a? Ну, смотрите, вроде как я написал, а a равно b и вызываю a.f,
[12:57.480 --> 13:04.960]  при этом метод f, он виртуальный. Почему тут на самом деле будет вызываться все равно метод f? Вот такой.
[13:04.960 --> 13:16.000]  Вот, да, смотрите. Что у меня происходит? Что такое a? А это переменная. Какой тип имеет
[13:16.000 --> 13:26.600]  переменная a? Переменная a имеет тип a. То есть в памяти у меня хранится только объект a. Что тут
[13:26.600 --> 13:32.120]  происходит? Тут происходит срезка. То есть я тут создал объект b, то есть создал временный объект b,
[13:32.120 --> 13:38.800]  а потом этот объект скопировал в настоящую переменную a. При этом я скопировал только вот эту
[13:38.800 --> 13:43.080]  часть, которая относится к a. То есть у меня в памяти хранится только часть, которая относится к
[13:43.080 --> 13:49.600]  a. И поэтому a является объектом типа a, и ничего кроме метода a у него вызвано быть не может.
[13:49.600 --> 13:58.080]  Понятно? Короче, вот весь второй столбец, на самом деле он довольно-таки понятный, потому что тут
[13:58.080 --> 14:04.840]  везде вызывается тут метод a, тут метод b, тут метод c. Почему? Потому что это не контекст применения
[14:04.840 --> 14:08.920]  виртуальных функций. Еще раз, виртуальные функции работают только в случае, когда я работаю с
[14:08.920 --> 14:14.400]  указателями или ссылками. Смотрите, обычная переменная, если у меня есть переменная a, и она имеет
[14:14.400 --> 14:19.920]  тип a, то значит под этой переменной однозначно скрывается объект типа a. Понятно? Но если у меня есть
[14:19.920 --> 14:24.440]  указатель на a, то указатель на a может указывать как на объект типа a, так и на объект типа b, так и на объект
[14:24.440 --> 14:33.600]  типа c. Виртуальные методы работают только с указателями или ссылками. С обычными переменами
[14:33.600 --> 14:38.400]  виртуальные функции не работают, потому что если у меня есть обычная переменная, то я всегда знаю,
[14:38.400 --> 14:44.640]  что там за объект лежит. Если переменная типа a, значит там лежит объект типа a. Если переменная типа b,
[14:44.640 --> 14:58.680]  значит там лежит объект типа b и так далее. Мы об этом в конце поговорим. Вот, поэтому второй столбится
[14:58.680 --> 15:03.200]  чисто на понимание. Если у вас есть обычная переменная, то для обычных переменных всегда вызываются
[15:03.200 --> 15:11.320]  ровно те методы, которые вы ожидаете. Так, кстати, в последней строчке будет ce. Я понимаю почему.
[15:11.320 --> 15:25.800]  Почему в последней строчке будет ce на самом деле? Да, потому что g тут константный метод. В общем,
[15:25.800 --> 15:33.240]  константные методы можно вызвать... Так, стоп. Нет, бред. Все нормально будет. Все окей. Это если бы,
[15:33.240 --> 15:39.000]  наоборот, a и b были константными, то метод других нельзя было вызвать. Нет, все нормально. Так,
[15:39.000 --> 15:44.040]  давайте посмотрим вот на последний столбец. И вот тут уже интересно, потому что тут в дело
[15:44.040 --> 15:50.560]  вступают указатели. Давайте разберемся с первой группой примеров. Вот у меня есть указатель на a,
[15:50.560 --> 15:55.520]  который на самом деле указывает на объект типа b в динамической памяти. Если я вызываю метод f,
[15:55.520 --> 16:03.320]  что происходит? Да, вызывается метод f из b. Почему? Что делает компилятор? Компилятор видит,
[16:03.320 --> 16:10.280]  что указатель a по b указывает на a. То есть, реальный тип указателя a по b — это a. Он идет в структуру a,
[16:10.280 --> 16:14.920]  видит, что там есть метод f, но этот метод f — виртуальный. Значит, ему нужно дополнительно
[16:14.920 --> 16:19.160]  посмотреть на то, на что указывает указатель, и принять решение, какой метод вызвать. Ну, соответственно,
[16:19.160 --> 16:26.760]  он смотрит на объект, видит, что там лежит объект типа b, и он вызывает метод f из b. Вызываю a по b
[16:26.760 --> 16:35.160]  g. Почему? Да, потому что метод g не виртуальный, там раннее связано, там все делается исходя из
[16:35.160 --> 16:40.720]  типа указателя. Вторая группа. A по c указывает на a, но на самом деле там лежит объект типа c.
[16:40.720 --> 16:51.920]  Так, что тут? c, да, почему? Потому что, еще раз повторяю, что достаточно объедить виртуальность
[16:51.920 --> 16:55.480]  один раз, и все остальные методы тоже будут виртуальными. То есть, что делает компилятор?
[16:55.480 --> 16:59.400]  Компилятор заглядывает в класс a, видит, что метод f — виртуальный, значит, ему нужно дополнительно
[16:59.400 --> 17:05.120]  посмотреть на то, какой там объект реально лежит, и вызвать метод того объекта, который там реально
[17:05.120 --> 17:10.640]  лежит. Там лежит реально объект c, в классе c есть своя версия функции, поэтому будет вызвана именно
[17:10.640 --> 17:19.520]  она. Вот. Окей. Так, последняя строчка. Ну, тут понятно, да, тут тоже a. Окей, ну и наконец у меня есть
[17:19.520 --> 17:28.440]  указатель b, который на самом деле указывает на объекте по c. Вызываю метод f, что будет? c. Так,
[17:28.440 --> 17:38.400]  вызываю метод g, а вот не совсем. Вот смотрите, действительно в классе b метод g объявлен как
[17:38.400 --> 17:43.480]  виртуальный. Согласны? Вот. Но какой там метод объявлен виртуальным? Там объявлен виртуальный метод
[17:43.480 --> 17:56.240]  вот такой. void g. А в классе c какой метод? А в классе c метод void g const. Вот этот да этот метод — это
[17:56.240 --> 18:04.560]  не одно и то же. Понятно? То есть в классе b объявлен вот такой виртуальный метод. Вот это — это другой
[18:04.560 --> 18:13.080]  метод, который не совпадает с этим. Поэтому на самом деле в классе c нет метода g, которые соответствуют
[18:13.080 --> 18:21.640]  тому, что в b, поэтому будет вызываться именно метод из b. Что? Первая цепь, потому что метод f — виртуальный.
[18:21.640 --> 18:29.920]  Виртуальность наследуется. Сейчас, в классе a метод f — виртуальный, а класс b у наследован от a,
[18:29.920 --> 18:39.280]  поэтому и в b f тоже будет виртуальным. Вот он смотрит в класс b, видит там метод f, но еще раз,
[18:39.280 --> 18:44.640]  виртуальность наследуется в том смысле, что не явно там будет подставлен виртуал. То есть компилятор
[18:44.640 --> 18:49.480]  все равно не явно там отставит виртуал. Вот. Я согласен, это не очевидно, это плохо. То есть когда мы
[18:49.480 --> 18:53.800]  смотрим на класс b, мы хотим явно понимать, что это метод виртуальный. Вот. Я покажу, как это правильный
[18:53.800 --> 18:58.280]  дел. Вот так делать неправильно. В общем, это скомпилируется. Метод f будет виртуальный,
[18:58.280 --> 19:03.160]  но с точки зрения там читаемости кода это плохо. Значит, дальше я покажу, как правильно
[19:03.160 --> 19:08.920]  прописывать виртуальные методы в наследниках. Так, тут все примеры понятны. Вот последний
[19:08.920 --> 19:14.120]  пример понятен. Виртуальность относится именно к конкретному типу метода. Если метод поменялся,
[19:14.120 --> 19:18.840]  поменялся сигнатура, то это уже другой метод. Вот. Вот этот метод g, который сверху и вот этот
[19:18.840 --> 19:25.040]  метод g, который снизу, это два разных метода. Вот. Поэтому класс c не объявляет, не определяет
[19:25.040 --> 19:30.240]  свои собственные версии верхнего метода, поэтому к компилятору ничего не остается, как вызвать
[19:30.240 --> 19:47.560]  метод из b. Окей? А вот, короче, вот тут никак. Да. Вот тут? Потому что, смотрите, еще раз,
[19:47.560 --> 19:52.160]  APC указывает на a. Поэтому компилятор заглядывает, ну, то есть тип указателя APC,
[19:52.160 --> 19:57.480]  это указатель на a. Поэтому он заглядывает в структуру a, видит, что там лежит метод g. Этот метод g не
[19:57.480 --> 20:04.760]  виртуальный. Раз он не виртуальный, значит, просто его вызываю и все. Вот. Ну, короче, вот последние
[20:04.760 --> 20:10.920]  строчки, ну, можно было вызвать метод g, но, в общем, нужно было сначала указатель на b, привести
[20:10.920 --> 20:15.480]  указатель на c, потом вызвать метод g, но про это еще поговорим. Вот. Вот так вот, просто через указатель
[20:15.480 --> 20:35.280]  вызвать g из c нельзя. Да. Да. Тогда b определяет свою версию g и пользуется, ну, тогда смотрите,
[20:35.280 --> 20:44.280]  что бы было. Давайте подробно пропишем. Значит, вопрос такой. Есть, давайте я коротко напишу,
[20:44.280 --> 20:55.440]  что вот у меня есть класс a, в нем есть void g. Так. Какой просто void g? Виртуал, окей. Виртуал
[20:55.440 --> 21:13.320]  void g. Дальше есть b, в котором определен void g. И c, в котором объявлен void g. Что бы тогда было?
[21:13.320 --> 21:19.800]  Вот давайте тут пропишу, что не явно есть. Тогда вот тут, ну, понятное дело, тут есть только виртуальный
[21:19.800 --> 21:25.360]  метод g. Вот тут, помимо вот этого метода, не явно компилятор еще дополнительно добавляет
[21:25.360 --> 21:37.520]  virtual void a.g. То есть, на самом деле, в b тоже есть метод g неконстантный и тоже виртуальный. То есть,
[21:37.520 --> 21:41.440]  метод b будет использовать, то есть, если я буду обращаться к неконстантному методу g, то тогда
[21:41.440 --> 21:47.760]  он будет обращаться к неконстантному методу из a. Вот. А тут c переопределяет свою версию g и при
[21:47.760 --> 22:10.160]  этом содержит, ну, я так напишу, b, void g, константный. Вот. Окей? А, звездочка p равно new t,
[22:10.160 --> 22:29.880]  то когда p стрелочка g будет вызывать c. Да, если будет, давайте так напишем. Давайте,
[22:29.880 --> 22:45.360]  если напишу s.const, разуменованный g, точка, ой, разуменованный p, точка g, то тогда вызовется,
[22:45.360 --> 22:53.120]  ну, давайте, а, тогда ничего не вызовется. Вот тут ошибка компиляции будет. Смотрите,
[22:53.120 --> 22:57.480]  если я разуменую p и скажу, что воспринимает как константу и вызову метод g, то тогда, ну,
[22:57.480 --> 23:01.280]  смотрите, что это сделал компилятор? Компилятор видит, что на самом деле p это указатель на a,
[23:01.280 --> 23:05.880]  поэтому, когда я разуменую указатель на a, получится ссылка на a. Согласны? Дальше говорю,
[23:05.880 --> 23:09.440]  что эту ссылку нужно сделать константной ссылкой. Вот. Окей. И теперь я через константную
[23:09.440 --> 23:14.000]  ссылку на a вызываю метод g. Иду в a и вижу, что тут нет константного метода g. Поэтому ошибка
[23:14.000 --> 23:26.760]  компиляции. Окей. Ну, давайте короче напишем. Если указатель был бы константным, я вызывал бы
[23:26.760 --> 23:34.040]  p, стрелочка g, то была бы ошибка компиляции. Почему? Потому что компилятор идет в класс a,
[23:34.040 --> 23:41.960]  и еще тут константный метод g, тут константного метода g нет. Вот. То есть сначала компилятор
[23:41.960 --> 23:45.720]  проверяет, есть ли такой метод в базовом классе, а уже потом там смотрит виртуальность,
[23:45.720 --> 24:02.000]  невиртуальность и так далее. Есть ли вопросы? Окей. Окей. Окей. Так. Ну, собственно, виртуальность
[24:02.000 --> 24:07.120]  работает и внутри методов, да, то есть если вы внутри какого-то метода вызываете виртуальный
[24:07.120 --> 24:12.560]  метод, то он будет работать. Ну вот, собственно, пример такой. У меня есть структура a, в ней есть
[24:12.560 --> 24:17.400]  не виртуальный метод printName. Вот. Важно отметить, что printName не виртуальный. И есть виртуальный
[24:17.400 --> 24:22.160]  метод name, который в зависимости от типа возвращает либо a, либо b. То есть вот есть структура b,
[24:22.160 --> 24:26.880]  которая переопределяет виртуальный метод name, который возвращает b. Вот. И смотрите, внутри
[24:26.880 --> 24:31.760]  printName я вызываю метод name. И вот внутри printName этот name будет работать как виртуальный. То есть
[24:31.760 --> 24:37.440]  вот я сделаю ptr стрелочком printName и будет выведен b. Почему? Потому что в классе a есть метод
[24:37.440 --> 24:41.840]  printName, будет вызван метод printName, но этот printName из себя вызывает name, который виртуальный. И
[24:41.840 --> 24:49.240]  вот тут в этот момент компилятор будет думать, какой метод ему вызвать, из a или из b. Окей? Нормально?
[24:49.240 --> 25:01.120]  Окей. Так. Единственное место, где не работают виртуальные методы, это конструкторы и деструкторы.
[25:01.760 --> 25:06.520]  Вот если вы в конструкторе или деструкторе вызываете виртуальный метод, то метод всегда
[25:06.520 --> 25:10.020]  будет выбран именно тот, который относится к текущему конструктору или к текущему деструктору.
[25:10.020 --> 25:15.360]  Ну, оно и в целом не понятно почему. Потому что, когда вы находитесь в конструкторе,
[25:15.360 --> 25:18.440]  вот представьте себе, что вы находитесь в конструкторе базового класса и вызываете
[25:18.440 --> 25:23.700]  виртуальный метод. А этот виртуальный метод в теории должен вызвать метод своего наследника.
[25:23.700 --> 25:27.920]  Но смотрите, что мы знаем. Мы знаем, что, как создает наследник. Наследник создает так.
[25:27.920 --> 25:31.340]  Сначала создается базовая часть, а потом все, что отн brought, к наследнику.
[25:31.900 --> 25:34.180]  И вот представьте себе, вы создаете наследника.
[25:34.180 --> 25:36.120]  Далее создается базовая часть.
[25:36.120 --> 25:39.120]  И в конструкторе базовой части вы обращаетесь к методу наследника.
[25:39.120 --> 25:41.140]  Наследник еще не создан.
[25:41.140 --> 25:43.260]  Поэтому как вы к нему обратитесь?
[25:43.260 --> 25:45.160]  По-этому так делать нельзя.
[25:45.160 --> 25:49.400]  И в этот момент будет вызваться именно метод именно того класса, который создается.
[25:49.400 --> 25:51.280]  Аналогичная проблема с деструктором.
[25:51.280 --> 25:56.220]  Если вы вызываете деструктор, сначала заш приготовится часть, которая отн Anita наследника.
[25:56.220 --> 25:59.340]  вы идете в деструктор базового класса, и если в деструкторе базового класса вы
[25:59.340 --> 26:02.700]  вызываете виртуальный метод, то этот виртуальный метод может относиться к
[26:02.700 --> 26:06.620]  наследнику, а наследник уже уничтожен. Поэтому виртуальность в
[26:06.620 --> 26:10.620]  конструкторах и деструкторах просто-напросто не работает, окей?
[26:10.620 --> 26:19.740]  Хорошо. Ну и собственно, при чем тут полиморфизм?
[26:19.740 --> 26:24.880]  Мы с вами говорили про что? Мы с вами говорили про то, что есть основные
[26:24.900 --> 26:29.240]  концепции ОП, это Abstraction, encapsуляция, полиморфизм и наследование.
[26:29.240 --> 26:34.200]  Про наследование мы в целом поговорили. Вот теперь полиморфизм.
[26:34.200 --> 26:37.040]  В прошлом семестре мы с вами говорили про так называемый статический полиморфизм.
[26:37.040 --> 26:40.400]  Полиморфизм времени компиляции. Что у нас было про полиморфизм
[26:40.400 --> 26:44.480]  времени компиляции? Ну, это понятное дело там. Перегрузка операцией, то és мы делали так,
[26:44.480 --> 26:47.840]  что разные объекты использует одну и ту же операцию при сложения и работают
[26:47.840 --> 26:51.160]  по-разному, или, например, шаблоны. Шаблоны Texas тоже пример статического
[26:51.160 --> 26:53.840]  полиморфизма, то есть мы используем одну и ту же функцию, которая работает занимать
[26:53.840 --> 26:59.280]  множество разных типов. Значит, смотрите, на самом деле, что мы сейчас
[26:59.280 --> 27:01.960]  сделали с помощью виртуальных функций, так это динамический полиморфизм.
[27:01.960 --> 27:07.400]  Почему? Потому что, смотрите, у меня есть несколько классов, есть класс A, есть
[27:07.400 --> 27:11.720]  класс B, есть класс C, и я к ним могу обращаться одинаковым образом, то есть я
[27:11.720 --> 27:15.920]  могу у всех их вызвать метод F. Но в зависимости того, на что указывает
[27:15.920 --> 27:19.560]  указатель A, на объект A, на объект B или на объект C, у меня будет
[27:19.560 --> 27:23.960]  работать разные реализации. То есть, смотрите, я написал один и тот же код, но
[27:23.960 --> 27:29.120]  в зависимости того, что тут за тип лежит, у меня будут
[27:29.120 --> 27:32.480]  вызываться разные методы. Собственно, это и есть свойство полиморфизма.
[27:32.480 --> 27:34.840]  Полиморфизм — это свойство системы, которая позволяет использовать различные
[27:34.840 --> 27:39.880]  реализации в рамках одного интерфейса. То есть, еще раз, у меня есть указатель
[27:39.880 --> 27:49.040]  ap, использую p стрелочка f. То есть, смотрите, у меня есть общий интерфейс, то есть я
[27:49.040 --> 27:53.040]  вот этот стройш кода никак не меняю. Но в зависимости того, на что реально
[27:53.040 --> 27:58.040]  будет указывать p, у меня может быть вызван либо метод из A, либо метод из B,
[27:58.040 --> 28:07.320]  либо метод из C, либо и так далее. Окей? Вот. Ну и, собственно, практическое применение, ну
[28:07.320 --> 28:12.280]  пример такое. Я утверждаю, что, имея на руках динамический полиморфизм, я теперь
[28:12.280 --> 28:18.600]  могу создать массив из элементов разных типов, ну, какими-то ухищрениями.
[28:18.920 --> 28:21.760]  Ну, смотрите, как это работает, например. Ну, смотри, допустим, я хочу, ну, допустим,
[28:21.760 --> 28:27.520]  у меня есть там, не знаю, какой-то зоопарк или какая-то игра, в которой, соответственно,
[28:27.520 --> 28:32.560]  мне нужно создать систему, которая будет хранить всю информацию о животных и так
[28:32.560 --> 28:37.400]  далее. Вот. Я завожу общий класс animal, то есть базовый класс animal, в котором будет
[28:37.400 --> 28:41.640]  просто-напросто базовый, в котором будет просто-напросто виртуальный метод voic, ну,
[28:41.640 --> 28:45.160]  собственно, там, не знаю, животное, пусть подаст голос. Вот. Дальше пишу структуру
[28:45.160 --> 28:48.160]  кошка, структуру собака, структуру леса и, собственно, как-то реализовываю для них
[28:48.480 --> 28:52.400]  метод voic. То есть метод voic он виртуальный, и, соответственно, для разных, для разного
[28:52.400 --> 28:55.920]  типа животных он будет работать по-разному. Что я делаю дальше? Дальше остаюсь массив,
[28:55.920 --> 29:03.800]  допустим, из десяти указателей на животных. Ну, а то есть вот мне есть массив. Ну, и,
[29:03.800 --> 29:07.200]  соответственно, есть указатели, которые указывают, каждый из которых указывает на свой,
[29:07.200 --> 29:14.560]  там, на свой объект. Ну и, собственно, что я хочу сделать? Я, допустим, хочу сделать так,
[29:14.560 --> 29:19.000]  чтобы вот весь зоопарк разом подал голос. Что я делаю? Я просто-напросто в цикле прохожусь по всем,
[29:19.000 --> 29:26.040]  по всем элементам, и у каждого элемента вызываю метод voic. Ну и теперь, смотрите, если тут кошка,
[29:26.040 --> 29:32.280]  то будет вызван, то будет вызван метод voic из кошки. Если будет док, то из собаки. Если покс,
[29:32.280 --> 29:37.240]  то из весы и так далее. То есть, смотрите, я смог создать массив элементов одного типа. Я напомню,
[29:37.240 --> 29:42.040]  что C++ можно вставать массивы только из элементов общего типа, в данном случае указательно животное.
[29:42.040 --> 29:47.920]  Вот, но при этом каждый элемент работает по-своему. То есть, я у каждого элемента вызываю свой метод,
[29:47.920 --> 29:52.680]  и каждый метод работает по-разному, в зависимости от того, на какой реальный тип я указываю. Понятно?
[29:52.680 --> 30:05.160]  Супер. Так, что у нас по времени? Нормально. Так, давайте поговорим про... Так, есть ли вопросы по
[30:05.160 --> 30:13.560]  виртуальным функциям? В целом, общие такие слова про виртуальные методы, все. Теперь давайте поговорим
[30:13.560 --> 30:24.760]  про частные случаи, и в частности поговорим про виртуальный деструктор. Ну, давайте посмотрим на
[30:24.760 --> 30:31.680]  мотивирующий пример. Вот у меня есть какой-то класс, ну, допустим, я написал свой собственный класс stack.
[30:31.680 --> 30:37.920]  Дальше моя программа развивается, я решил, а почему бы мне в своей программе не написать дополнительный
[30:37.920 --> 30:42.200]  класс stack с поддержкой максимума? То есть, ну, просто это то же самое стать, но при этом поддерживает,
[30:42.200 --> 30:48.760]  в любой момент знает, какой максимум у меня хранится сейчас в элементах stack. Ну, естественно,
[30:48.760 --> 30:52.280]  предполагаю, что stack max каким-то образом наследован от stack. Ну, почему? Потому что везде, где я
[30:52.280 --> 30:57.160]  подставляю stack, я хочу иметь возможность подставлять stack max. Потому что stack max является частным
[30:57.160 --> 31:02.240]  случаем stack, то есть stack max реализует отношение, то есть stack max является stack, поэтому логично сделать
[31:02.240 --> 31:09.520]  публичное наследование. Что я делаю дальше в программе? Я создаю указатель stack и создаю new stack max,
[31:09.520 --> 31:14.560]  то есть, у меня есть указатель на stack, но на самом деле он указывает на stack max. Все нормально. Дальше
[31:14.560 --> 31:19.160]  вызываю delete. Ну, собственно, так как я выделил динамическую память new stack max, я должен для
[31:19.160 --> 31:25.240]  указателя stack, для указателя stack ptr вызвать delete. Вызываю delete, и вот в этот момент у меня
[31:25.240 --> 31:39.720]  программа ломается. Вопрос, почему? А почему двойное? Где двойное? Давайте посмотрим, как все работает. Вот у
[31:39.720 --> 31:51.600]  меня есть указатель stack, допустим ptr, который на самом деле указывает на stack max. Давайте вот тут.
[31:51.600 --> 32:01.280]  Это часть, которая относится к stack, это часть, которая относится к stack max. Вот. Выделено с помощью
[32:01.280 --> 32:08.080]  new. Дальше делаю delete. Давайте отсудим сначала двойное удаление. А где будет двойное удаление?
[32:08.080 --> 32:16.640]  Что делает delete? Давайте вспомним. Delete делает две вещи. Какие? Первое вызывает деструктор для
[32:16.640 --> 32:20.400]  объекта, на который указывают. То есть, по этому объекту будет вызван деструктор. А второе, ну,
[32:20.400 --> 32:27.960]  очищает память. Вопрос, в чем двойное удаление? Понятное дело, что у этого объекта вызывается
[32:27.960 --> 32:33.080]  деструктор, то есть, там свою память очистит. А дальше, собственно, delete очистит саму память,
[32:33.080 --> 32:43.000]  вернет в системе. Скажется, двойного удаления нет. Но есть другая проблема. Какая? Вот, да, смотрите.
[32:43.000 --> 32:52.600]  Действительно, проблема будет в том, что вот тут вызовется только деструктор stack. Почему? Смотрите.
[32:52.600 --> 32:57.000]  Вот компилятор видит эту строчку. Давайте поработаем компилятором. Вот он видит эту строчку,
[32:57.000 --> 33:00.640]  ему нужно генерировать какой-то код, ему нужно генерировать какие-то инструкции. Что он видит?
[33:00.640 --> 33:05.880]  Он видит, ага, нужно вызвать очищение ptr. Значит, delete по указателю означает, что мне нужно первое
[33:05.880 --> 33:12.440]  вызвать деструктор, второе очистить память. Он смотрит на тип ptr. Видишь, что ptr имеет тип указатель
[33:12.440 --> 33:16.600]  на stack. А раз ptr имеет тип указатель на stack, то значит, я должен вызвать деструктор для
[33:16.600 --> 33:27.080]  stack. Он говорит, что первым делом вызывают деструктор stack. Ну а потом, не знаю, очищение памяти.
[33:27.080 --> 33:37.280]  Ну, погодите, реально-то у меня хранится не только stack, но и вот stack max. Что с ним произойдет?
[33:37.280 --> 33:42.480]  Он просто останется там висеть в воздухе ночью. В худшем случае он просто останется висеть в воздухе,
[33:42.480 --> 33:46.280]  а в лучшем случае, не знаю, там будет какая-нибудь ошибка во время исполнения, да.
[33:46.280 --> 34:00.560]  Ну, на самом деле Free там сработает нормально, потому что Free уже работает на уровне… Программа,
[34:00.560 --> 34:04.360]  короче, посмотрит на указатель. У программы где-то сохраняется информация о том, что по этому указателю
[34:04.360 --> 34:07.800]  было выделено столько-то байт-памяти, поэтому Free сработает нормально. Тут главная проблема
[34:07.800 --> 34:13.040]  с деструктором. Еще раз, всем понятно, в чем проблема? Виртуальный деструктор – это вот ключевой
[34:13.040 --> 34:17.480]  вопрос. Ну, не знаю, по крайней мере на 90% собеседований спрашивают про виртуальный деструктор.
[34:17.480 --> 34:25.440]  Смотрите, еще раз, ptr – это указатель на stack. Но при этом реально он указывает на stack max.
[34:25.440 --> 34:31.560]  Если я делаю delete ptr, то компилятор видит, что ptr – это указатель на stack и вызывает деструктор
[34:31.560 --> 34:37.600]  только для stack. То есть снова delete опирается только на сам тип указателя. Вопрос – как решить эту
[34:37.600 --> 34:44.120]  проблему? Ну, кажется, вот такую проблему мы уже сталкивались, когда работали с методами. То есть
[34:44.120 --> 34:49.680]  у нас был указатель на A, который указывал на B. Когда мы вызывали метод F, он вызывал всегда метод
[34:49.680 --> 34:56.680]  F. А нам бы хотел, чтобы он вызывал иногда метод B. Как мы решили эту проблему? Да, с помощью слова
[34:56.680 --> 35:02.560]  virtual. Поэтому решение такое. Вот тут описание проблемы. Решение – использовать виртуальный деструктор.
[35:02.560 --> 35:08.640]  То есть если я хочу, чтобы компилятор, точнее, чтобы программа принимала решение о том,
[35:08.640 --> 35:12.720]  какой деструктор вызвать, в зависимости от того, на что указывает указатель, а не на реальный
[35:12.720 --> 35:20.320]  тип указателя, я должен делать деструктор виртуальным. То есть в стэке я делаю виртуальным
[35:20.320 --> 35:24.160]  деструктор, ну и соответственно дальше все будет окей. То есть что теперь будет происходить.
[35:24.160 --> 35:38.200]  Теперь тут появится шаг 0. То есть понять, что за объект. То есть нулевым пунктом delete сначала
[35:38.200 --> 35:42.200]  выясняешь, что там реально лежит за объект. Понимаешь, что там лежит на самом деле stack
[35:42.200 --> 35:52.160]  max. Вызывай деструктор stack max. Ну и потом возвращает память системе. Окей? Мораль. Если вы
[35:52.160 --> 35:58.120]  используете виртуальные методы, то в вашем классе обязательно должен быть виртуальный
[35:58.120 --> 36:03.080]  деструктор, окей? То есть если вы предполагаете, что ваш класс будет использовать полиморфизм,
[36:03.080 --> 36:07.860]  короче, правило такое, очень простое. Если в вашем классе есть хотя бы один виртуальный метод,
[36:07.860 --> 36:14.600]  то и обязан быть виртуальный деструктор, окей? Вот, если в вашем классе нет виртуальных метод,
[36:14.600 --> 36:19.200]  виртуальный деструктор вам тоже не нужен. Мы обсудили виртуальный деструктор,bum,а
[36:19.200 --> 36:30.000]  следующий на очереди это ключевые слова overwrite и final. про что это?
[36:30.000 --> 36:37.360]  смотрите, вот тут мы уже вот мы уже тут толкнулись со следующей проблемой. вот по
[36:37.360 --> 36:42.920]  коду, допустим, мы смотрим в класс C, вот по этому коду, вообще говоря,
[36:42.920 --> 36:49.160]  не всегда очевидно, что мы делаем. то есть если мы пишем void.g, то есть что это
[36:49.500 --> 36:53.600]  может означать, что мы создаем какую-то новую, новую невиртуальную функцию G, или это
[36:53.600 --> 36:56.940]  может означать что мы создаем что мы переопределяем виртуальную функцию G
[36:56.940 --> 37:00.840]  которую уже объявят в каком-то классе senator, в каком-то классе предки.
[37:00.840 --> 37:05.140]  чтобы разобраться, в том что, что ook это же на самом деле означает создание новой
[37:05.140 --> 37:09.160]  невиртуальной функции или переопределение старый виртуальной, нам необходимо
[37:09.160 --> 37:13.620]  пройтись по всей герархии наследования и понять есть ли виртуальные
[37:13.620 --> 37:18.440]  versions G или нет. вот, это первая проблема. то есть когда мы читаем код, неочевидно
[37:18.440 --> 37:22.200]  Это виртуальный метод или нет? Вторая проблема заключается в следующем.
[37:22.200 --> 37:27.360]  Смотрите. Да, кстати, она тоже тут указана. Вот смотрите, вот я написал void j const.
[37:27.360 --> 37:32.120]  Смотрите, возможно я имел в виду, что я бы хотел переопределить
[37:32.120 --> 37:35.800]  виртуальный метод j, но допустим каким-то образом ошибся. Ну, например, добавил
[37:35.800 --> 37:40.760]  лишний const. Или, что еще чаще бывает, не написал const. Просто взял и забыл написать
[37:40.760 --> 37:45.240]  const. То есть тут объявлен метод j как const, а тут я const забыл. Ну или, например,
[37:45.240 --> 37:49.780]  у меня в классе A написан виртуал void f int, а в классе B решил написать void f
[37:49.780 --> 37:53.320]  long, ну и думая, что я как бы переобредил виртуальный метод f. Ну, при этом понятно
[37:53.320 --> 37:57.080]  дело, что f от long и f от int – это две разные функции, поэтому метод f от long не
[37:57.080 --> 38:01.160]  будет виртуальным, а метод f от int будет виртуальным. Ну и то же самое, вот как я
[38:01.160 --> 38:04.680]  сказал, с константностью. То есть очень частый паттерн – это забыть const. В
[38:04.680 --> 38:10.160]  классе A const есть, в классе B const нет. В этом случае виртуальность будет
[38:10.160 --> 38:14.320]  потеряна. То есть, когда я буду вызывать метод f от нуля или j через PTR, у меня
[38:14.320 --> 38:18.480]  будет вызываться метод sA, то есть у меня будет вызываться метод f sA и метод j sA
[38:18.480 --> 38:27.960]  просто-напросто потому, что методы в B они не являются виртуальными.
[38:28.440 --> 38:34.160]  Что делать? То есть как решить эту проблему? Проблема решается очень просто с помощью
[38:34.160 --> 38:39.020]  ключевого слова override. Кто делает ключевое слово override? Override говорит
[38:39.020 --> 38:46.020]  следующее. Я могу вот к этой функции добавить в конце override. Override говорит
[38:46.020 --> 38:50.300]  следующее. Компилятор, пожалуйста, проверь, что я действительно переопределил какую-то
[38:50.300 --> 38:54.820]  виртуальную функцию. То есть override делает следующие, делает две вещи. Первое, он
[38:54.820 --> 38:58.900]  явно показывает в коде, что вот эта функция, что вот этот метод является виртуальным,
[38:58.900 --> 39:03.180]  и он переопределяет какой-то виртуальный метод, ну снаружи, ну точнее из базовой
[39:03.180 --> 39:10.380]  класса. А второе, если на самом деле, вот, допустим, тут const. Если на самом деле этот
[39:10.380 --> 39:14.700]  метод не соответствует никакому виртуальному методу из базового класса, то тогда у вас
[39:14.700 --> 39:17.940]  будет ошибка компиляции. Компилятор просто-напросто возьмет и скажет, погодите, вы
[39:17.940 --> 39:20.940]  хотели переопределить какую-то виртуальную функцию, но при этом никакой виртуальной
[39:20.940 --> 39:24.860]  функции с такой сигнатурой, ну да, с таким типом, с такой сигнатурой просто-напросто
[39:24.860 --> 39:29.820]  нет. Понятно? То есть override защищает от ошибок. Override говорит, что вот я хочу
[39:30.680 --> 39:33.340]  переопределить какую-то виртуальную функцию. Вот. Если вы примените override к структуре
[39:33.340 --> 39:37.220]  B, то увидите следующее сообщение об ошибке. Ну, во-первых, увидите, что есть функция B от
[39:37.220 --> 39:40.580]  FNLONGINT, и компилятор скажет, что она помещена как override, но на самом деле ничего не
[39:40.580 --> 39:45.500]  переопределяет. И, например, BG. Компилятор говорит, вы пометили ее как функция,
[39:45.500 --> 39:49.140]  которая переопределяет какую-то виртуальную, но при этом она ничего не переопределяет. Вот. То
[39:49.140 --> 39:52.020]  есть override зависит, во-первых, защищает от ошибок, а во-вторых, просто-напросто
[39:52.020 --> 39:55.020]  документирует ваш код и говорит, что вот этот метод на самом деле виртуальный, и он
[39:55.020 --> 40:00.780]  приопределяет виртуальный метод из базового класса. Замечательное слово, пользуйтесь на здоровье.
[40:00.780 --> 40:11.060]  В смысле, перегружен? Нет, в этом нет. Это просто ошибка компиляции. Потому что f отlong и f отint
[40:11.060 --> 40:16.060]  это две разные функции. Если напишете f отlong overwrite, компилятор посмотрит в базовый класс, увидит,
[40:16.060 --> 40:21.060]  что нет никакого метода f отlong и скажет ошибка компиляции, потому что такого метода просто нет.
[40:21.060 --> 40:34.300]  Конст overwrite пишется в конце типа функции.
[40:34.300 --> 40:50.340]  Хорошо. Я сказал, что виртуальные функции работают только для полностью
[40:50.340 --> 40:54.900]  совпадающих типов. Это означает, что если у вас типы функций чем-то отличаются, например,
[40:54.900 --> 41:04.620]  одна функция принимает int, а в наследнике функция принимает long, то это будут две разные функции.
[41:04.620 --> 41:11.740]  Или если они отличаются константностью, то тоже будут две разные функции. Из этого правила есть
[41:11.740 --> 41:15.540]  одно исключение. И это исключение называется ковариантные возвращаемые типы. Что такое
[41:15.540 --> 41:21.460]  ковариантные возвращаемые типы? Ковариантными называются следующие типы. Если у вас есть
[41:21.460 --> 41:33.460]  класс A и класс B, допустим, класс C, и допустим, есть методы f. Что я могу менять в методах f?
[41:33.460 --> 41:36.980]  При этом я говорю, что вот этот метод f соответствует этому методу f, и этот метод f соответствует
[41:36.980 --> 41:45.380]  этому методу f. Все эти методы являются разными реализациями одной и той же функции. Так вот,
[41:45.380 --> 41:49.580]  эти функции могут отличаться только одним свойством. Это возвращаемым значением. При этом
[41:49.580 --> 41:53.300]  возвращаемые значения должны следовать свойству ковариантности. Ковариантность означает следующее,
[41:53.300 --> 42:00.820]  что если f возвращает, допустим, указатель на A, то вот этому f разрешено возвращать наследника A,
[42:00.820 --> 42:07.820]  то есть наследника указателя A. Например, указатель на B, и вот этому f тоже разрешено возвращать
[42:07.820 --> 42:17.460]  указатель на C. Вот такую замену делать можно. Понятно? То есть я могу заменять указатель на
[42:17.460 --> 42:23.060]  базовый класс на указатель наследника, или ссылку на базовый класс могу заменять ссылку на наследника.
[42:23.060 --> 42:29.380]  То есть единственное изменение, которое я могу выносить в виртуальной функции, это заменять
[42:29.380 --> 42:34.060]  указатель на базовый класс на указатель наследника, или ссылки на базовый класс ссылка
[42:34.060 --> 42:41.420]  наследника, но только в возвращаемом значении. Нормально? Хорошо. Так, следующая полезная ключевая
[42:41.420 --> 42:45.820]  слоя это ключевое слово final. Ключевое слово final тоже применимо к виртуальным функциям, и оно
[42:45.820 --> 42:53.180]  означает следующее, что вот эта версия метода, она финальная, ее дальше переопределять нельзя. Вот
[42:53.180 --> 42:57.740]  пример. Вот у меня есть структура A, в ней есть виртуальный метод f. Дальше есть структура B,
[42:57.740 --> 43:03.580]  я тоже объявил метод f в тот же самый и пометил его как final. Смотрите, final на самом деле работает
[43:03.580 --> 43:08.980]  точно так же, как overwrite. То есть final говорит о том, что есть где-то виртуальный метод, и я сейчас
[43:08.980 --> 43:13.660]  его переопределяю. Но final дополнительно еще говорит следующее, что вот этот метод является последней
[43:13.660 --> 43:18.700]  версией этого метода. Мои наследники этот метод переопределять не имеют права. Смотрите, почему это
[43:18.700 --> 43:24.140]  приводит. Я создаю структуру C, которая тоже публичного рода наследника от B. Переопределяю функцию f,
[43:24.140 --> 43:29.260]  метод f, и в этот момент я получу ошибку компиляции. Ошибка компиляции мне скажет, что виртуальная функция
[43:29.260 --> 43:38.020]  C переопределяет final function. Она переопределяет final function, но при этом делать это не имеет права.
[43:38.020 --> 43:45.500]  То есть final просто говорит, что в дальнейшем этот метод будет, в дальнейшем этот метод
[43:45.500 --> 43:50.540]  переопределять просто-напросто нельзя. Ну для чего это может быть полезно? Ну это может быть
[43:50.540 --> 43:57.340]  полезно просто-напросто если вы понимаете, что в него ничего нельзя добавить, и нет
[43:57.340 --> 44:01.580]  никакого смысла в него что-то добавлять, что-то изменять. И плюс это помогает делать некоторые
[44:01.580 --> 44:09.300]  оптимизации. Ну например, представьте себе, что у меня есть вот такая иерархия. Тут есть метод f,
[44:09.300 --> 44:15.460]  тут есть метод f, который обозначен как final, но тут как бы ничего нет. Какую оптимизацию может
[44:15.460 --> 44:23.260]  сделать компилятор? Смотрите, я делаю b, звездочка b, равно ну что-то там, ну там, new какой-то тип. И
[44:23.260 --> 44:33.900]  дальше делаю b, стрелочка f. Смотрите, вот да, и тут этот f виртуальный. Вот смотрите, если бы вот
[44:33.900 --> 44:37.940]  этого final не было, то в чем бы пришлось делать компилятор? Что пришлось бы делать в программе?
[44:37.940 --> 44:44.740]  В программе пришлось бы смотреть, на что реально указывает b, да, на какой объект. На объект типа
[44:44.740 --> 44:50.260]  b или на объект типа c. И в зависимости от этого вызвать метод f. Согласны? Ну а если метод f помечен
[44:50.260 --> 44:58.740]  как final, то что теперь достаточно мне сделать? Мне достаточно просто подставить вызов метода f из b,
[44:58.740 --> 45:03.460]  согласны? Потому что у меня есть указатель на b. Указатель на b может указывать либо на b,
[45:03.460 --> 45:08.220]  либо на его наследников. Но наследники не имеют права переопиливать f. Следовательно, f единственное
[45:08.220 --> 45:12.820]  возможно это вот это. И поэтому тут просто-напросто будет вызван метод f, без какого-либо позднего
[45:12.820 --> 45:23.380]  связывания. Понятно? Да, тоже ce. Overwrite это всего лишь подсказка. Вот если бы вы не писали
[45:23.380 --> 45:32.260]  overwrite, то была бы ошибка императора, потому что void f везде одна и та же. С final тоже понятно?
[45:32.260 --> 45:39.860]  Окей. Так, а ключевое слово, так, финальный, да, финальный может помнить только виртуальную
[45:40.060 --> 45:43.780]  функцию. Это я сказал, да, можно объединить виртуальную функцию и сразу сделать ее финальным,
[45:43.780 --> 45:47.580]  как бы. В общем, это может быть полезно только в случае, если вы просто-напросто не хотите,
[45:47.580 --> 45:52.240]  чтобы в наследниках появлялась такая же функция. Вот если вы не хотите, чтобы в наследниках
[45:52.240 --> 45:55.880]  переопределялась функция с такой же сигнатурой, с таким же типом, вы просто пишете
[45:55.880 --> 46:00.100]  virtual функцию и сразу же объявляете ее финальный. Вот. Тогда наследник просто-напросто не сможет
[46:00.860 --> 46:06.580]  заново эту функцию переопределить. Вот. Ну редко возникает, но иногда встречается такой паттерн.
[46:06.580 --> 46:09.580]  Вот. Значит, что еще можно сделать финальным?
[46:09.580 --> 46:12.580]  А финальным можно сделать не только метод, но и класс.
[46:13.580 --> 46:14.580]  Смотрите.
[46:17.580 --> 46:19.580]  Вот. Ну, кстати, все написано, да?
[46:19.580 --> 46:21.580]  Вот у меня есть структура A, есть структура B,
[46:21.580 --> 46:23.580]  и она объявлена как final.
[46:23.580 --> 46:26.580]  То есть, я говорю, struct B, final, ну, и она унаследована от A.
[46:26.580 --> 46:28.580]  Что означает финальная структура или финальный класс?
[46:28.580 --> 46:30.580]  Это означает, что от этого класса или структуры
[46:30.580 --> 46:32.580]  наследоваться больше нельзя.
[46:32.580 --> 46:35.580]  Если вы хотите запретить наследоваться от данной структуры или класса,
[46:35.580 --> 46:37.580]  то просто помечаете ее как final, и все.
[46:38.580 --> 46:42.580]  Вот. Ну, для чего структура или класс может быть помещена как final?
[46:42.580 --> 46:45.580]  Ну, например, по следующей причине.
[46:45.580 --> 46:48.580]  Ну, во-первых, вы можете просто так пометить,
[46:48.580 --> 46:52.580]  что в логике вашей программы от этого класса ничего наследовать нельзя,
[46:52.580 --> 46:54.580]  плюс final можно поветить те классы,
[46:54.580 --> 46:56.580]  для которых вы написали...
[46:56.580 --> 46:57.580]  Ну, точнее так.
[46:57.580 --> 47:00.580]  В общем, допустим, у вас есть какая-то иерархия классов, да?
[47:00.580 --> 47:01.580]  И мы с вами говорили, что...
[47:01.580 --> 47:04.580]  Вот представьте, что у меня есть класс A, класс B, класс C,
[47:04.580 --> 47:08.580]  и у меня есть виртуальный метод f.
[47:08.580 --> 47:11.580]  Тут тоже есть метод f, тут тоже метод f.
[47:11.580 --> 47:13.580]  Вот. Смотрите, о чем мы говорили.
[47:13.580 --> 47:15.580]  Мы говорили, что для каждого класса,
[47:15.580 --> 47:17.580]  для каждого класса, у которого есть виртуальный метод,
[47:17.580 --> 47:19.580]  мы обязаны написать виртуальный деструктор.
[47:19.580 --> 47:20.580]  Да?
[47:20.580 --> 47:22.580]  Но представьте, что мы знаем,
[47:22.580 --> 47:24.580]  что вот этот класс будет последним в иерархии,
[47:24.580 --> 47:26.580]  то есть от него больше ничего не будет наследовано.
[47:26.900 --> 47:28.580]  Так вот, собственно, вот для этого класса
[47:28.580 --> 47:30.580]  можно не писать виртуальный деструктур, вот.
[47:30.580 --> 47:33.780]  возможных проблем, да, вдруг там кто-то там возьмет ваш код и наследует свой C.
[47:33.780 --> 47:36.740]  Чтобы пометить, что от этого класса нельзя наследоваться, ну, потому что в моем
[47:36.740 --> 47:39.620]  классе, например, нет виртуального деструктора. Ну, то есть, я не ожидал, что от моего класса
[47:39.620 --> 47:42.820]  будут наследоваться, поэтому не стал писать виртуальный деструктур. И вот для
[47:42.820 --> 47:46.420]  этих целей я могу пометить структуру или класс как final, и, таким образом,
[47:46.420 --> 47:50.180]  сказать, ну, там остальным разработчикам, ну, или себе в будущем, да, что вот я запретил
[47:50.180 --> 47:56.900]  наследоваться от этого класса, возможно, каким-то ненадуманным причинам. Вот. Понятно?
[47:57.140 --> 48:05.140]  Окей. Так. Следующий пункт, в общем, следующий пункт это чисто виртуальные
[48:05.140 --> 48:11.900]  функции и абстрактные классы. Это все про что? Значит, давайте рассмотрим
[48:11.900 --> 48:18.980]  следующую проблему. Вот. Значит, реальный пример. Вот, допустим, вы пишете свой
[48:18.980 --> 48:24.300]  собственный messenger, вот. Пишете его на C++ и, соответственно, вводите вашу
[48:24.720 --> 48:27.560]  программу какие-то сущности. Какие сущности? Ну, одна из очевидных
[48:27.560 --> 48:31.200]  сущностей это, соответственно, так, как вы пишете messenger, да, то, естественно,
[48:31.200 --> 48:35.960]  иметь под рукой класс сообщения. Вот. Соответственно, мы пишем класс сообщения,
[48:35.960 --> 48:39.500]  ну и что мы понимаем? Мы понимаем, что, в целом, в общем, да, сообщение можно
[48:39.500 --> 48:43.400]  отправить к какой-то чат, вот. И, сообщение можно отобразить, там, на экране
[48:43.400 --> 48:46.580]  какого-то там устройства. Ну, то есть, грубо говоря, каждое сообщение поддерживает
[48:46.580 --> 48:51.000]  две операции, да, это отправка в чат и, соответственно, отображение. Вот. А дальше
[48:51.000 --> 48:53.440]  сообщение делится на несколько видов. Да, то есть, есть текстовое сообщение,
[48:53.440 --> 48:58.720]  есть картинка, есть видео, есть голосовое, есть, соответственно, стикер и так далее. То есть, есть куча разных сообщений,
[48:59.440 --> 49:04.240]  при этом в целом они все отличаются способом отображения на экране. То есть, метод
[49:04.800 --> 49:09.360]  send у них общий, там у них какая-то мета информация тоже общая, но при этом метод display может отличаться.
[49:09.720 --> 49:15.760]  Поэтому разумный способ какой? Создать общий базовый класс message, то есть, общая, в которой буду хранить общую информацию для всех сообщений.
[49:16.000 --> 49:20.800]  Ну а каждое конкретное сообщение, типа text message или sticker message, я просто-напросто наследую от message.
[49:21.040 --> 49:23.960]  Вот, и при этом сделаю виртуальный метод display, и каждый
[49:24.560 --> 49:31.680]  последующий класс будет просто-напросто переопределять свой виртуальный метод display, и таким образом я буду хранить массив сообщений. Давайте еще раз покажу, зачем мне нужно
[49:32.800 --> 49:34.800]  Зачем мне нужны виртуальные функции и
[49:35.360 --> 49:37.800]  наследования. Ну, смотрите, я могу просто-напросто завести
[49:40.800 --> 49:43.400]  массив message, давайте, допустим, вместо d
[49:45.080 --> 49:47.080]  вектор вот
[49:48.080 --> 49:50.080]  message указатель
[49:52.080 --> 50:00.080]  message вот. Ну и дальше, собственно, я могу в цикле, например, for int i равно нулю, ну давайте просто
[50:03.080 --> 50:05.080]  А, мы это не проходили, ладно.
[50:07.680 --> 50:13.680]  Просто for int i равно нулю и меньше чем message.size
[50:17.080 --> 50:19.080]  плюс плюс i
[50:19.840 --> 50:22.000]  ну просто отображаю все сообщения, да
[50:24.160 --> 50:26.520]  messages от i, стрелочка
[50:29.800 --> 50:36.960]  display. Вот, то есть я написал вот такие вот три строчки, и при этом мне не важно, что там, какие там реальные сообщения у меня хранятся, да, то есть если там
[50:37.080 --> 50:44.080]  если там в этой ячейке хранится стикер, то он корректно отобразится, если там хранится текст, то он корректно отобразится. Вот, собственно, вот наглядно преимущество
[50:44.080 --> 50:51.080]  наглядно преимущество полиморфизма и виртуальных функций, да, то есть я написал общий код, и мне вообще, говоря, плевать, что там за сообщение. То есть, конечно, сообщение отобразится корректно.
[50:53.080 --> 50:56.080]  Но в чем проблема? Давайте порассуждаем.
[50:57.080 --> 51:03.080]  Идет этим на следующие вопросы. Вот на предыдущем слайде я написал class message, написал класс сообщения.
[51:04.080 --> 51:12.080]  Вот мне кажется, что с этим классом что-то не так. Почему? Потому что мне кажется, что этот класс он не жизнецпособен по следующим причинам.
[51:12.080 --> 51:17.080]  Первый вопрос. Имеет ли смысл просто глядеть и создать абстрактное сообщение?
[51:18.080 --> 51:23.080]  Ну, смотрите, у меня есть текстовое сообщение, я понимаю, что это такое. Есть видео сообщение, я понимаю, что это такое.
[51:24.080 --> 51:29.080]  Есть голосовые сообщения, сомнительно, но окей. Есть там всякие стикеры, то есть все понятно.
[51:30.080 --> 51:36.080]  А мне говорят, что пришло сообщение. Что это за сообщение? Как мне отобразить произвольное сообщение? Есть понимание?
[51:36.080 --> 51:41.080]  Но кажется, что нет. Непонятно, как вообще устроено просто абстрактное сообщение в вакууме.
[51:42.080 --> 51:46.080]  То есть создавать объекты типа message кажется неприкольно, потому что у него нет никакой конкретики.
[51:47.080 --> 51:53.080]  Дальше. Вот смотрите, в классе message есть метод display. Что значит отобразить произвольное сообщение?
[51:54.080 --> 51:59.080]  Непонятно. Я понимаю, как отобразить текст, я понимаю, как отобразить картинку. Как отобразить просто сообщение? Ну, непонятно.
[52:00.080 --> 52:08.080]  Дальше. Следующая проблема. Я сказал, что я планирую, что у меня будут создаваться новые типы сообщений, и я буду наследовать их от message.
[52:09.080 --> 52:14.080]  И я хочу, чтобы каждый сообщение реализовывал метод display. Вопрос. Как мне заставить каждый класс реализовывать этот display?
[52:15.080 --> 52:20.080]  Потому что если я создам какой-то тип сообщения, например, видео, и не напишу метод display, ну просто забуду.
[52:21.080 --> 52:23.080]  У меня будет использоваться display из базового класса.
[52:24.080 --> 52:29.080]  А я бы хотел, чтобы компилятор мне как-то говорил, что, ну погоди, вот для этого класса нужно обязательно реализовать метод display.
[52:30.080 --> 52:36.080]  А такого у меня нет. Если я не реализую для своего собственного класса метод display, то он просто-напросто будет браться из общего класса message.
[52:39.080 --> 52:46.080]  Короче, проблема. Хотелось бы, чтобы все это как-то было как-то учено в программе.
[52:53.080 --> 53:03.080]  Оверайт просто-напросто проверяет, то действительно ли вы переопределяете какой-то виртуальный метод из базового класса.
[53:08.080 --> 53:12.080]  Не-не-не. Еще раз. Вот. Оверайт он просто-напросто спасает от ошибок.
[53:13.080 --> 53:18.080]  Ну, например. Вот. Ну вот тут пример.
[53:18.080 --> 53:25.080]  Представь себе, что у меня есть класс A, я в нем определил виртуальный метод F.
[53:26.080 --> 53:32.080]  Дальше я в классе B пишу вот такой вот метод. При этом, то есть я хочу в классе B переопределить вот этот виртуальный метод.
[53:33.080 --> 53:37.080]  Если я напишу просто вот так, то тут есть две проблемы. Первая проблема, ну, для читающего код.
[53:38.080 --> 53:43.080]  Вот, представь себе, я просто так взял и заглянул в класс B. Как мне вот по этому коду понять, что этот метод что-то переопределяет?
[53:43.080 --> 53:47.080]  Ну, никак. У него не написано ни виртуал, ничего и так далее.
[53:48.080 --> 53:53.080]  Вторая проблема. Ну, смотрите, я хотел переопределить метод F из класса A, но при этом забыл написать конст.
[53:54.080 --> 53:59.080]  Если я забыл написать конст, то этот метод будет просто-напросто отдельным методом, который никак не связан с этим.
[54:00.080 --> 54:04.080]  Как мне защититься от этих двух проблем? Я пишу снова оверайт.
[54:04.080 --> 54:08.080]  Оверайт означает, что этот метод переопределяет виртуальный метод из базового класса.
[54:09.080 --> 54:13.080]  То есть оверайт утверждает, этот метод что-то переопределяет.
[54:14.080 --> 54:19.080]  То есть теперь, когда я читаю код, как я вижу, что этот метод переопределяет виртуальный метод, это во-первых.
[54:20.080 --> 54:23.080]  А во-вторых, если на самом деле он ничего не переопределяет, как вот тут.
[54:24.080 --> 54:28.080]  Насмори, здесь метод конст, а тут не конст. То есть компьютер смотрит, ага, вот.
[54:28.080 --> 54:33.920]  А тут не const. То есть компилятор смотрит, ага. Вот есть такой метод, в базовом классе такого метода нет.
[54:33.920 --> 54:37.920]  Он дает ошибку компиляции, говорит, ты хотел что-то переопределить, но на самом деле ничего не переопределяешь.
[54:37.920 --> 54:40.920]  Вот, понятно?
[54:48.920 --> 54:51.920]  Если напомните, где конкретно CE было?
[54:51.920 --> 54:56.920]  А, ну так вот, то же самое.
[54:57.760 --> 55:02.760]  Вот. Я написал fatlong и написал, что он override.
[55:02.760 --> 55:05.760]  Но на самом деле никакой виртуальной функции fatlong нет.
[55:05.760 --> 55:08.760]  Поэтому CE.
[55:15.760 --> 55:19.760]  Да, почему мне в message нужен метод display?
[55:19.760 --> 55:23.760]  Потому что вот в такой ситуации, в этом примере, я тогда не смогу вызвать display.
[55:24.600 --> 55:28.600]  Потому что компилятор возьмет, то есть он поймет, что message от I это указатель на message.
[55:28.600 --> 55:30.600]  И указатель на message я вызываю display.
[55:30.600 --> 55:33.600]  Ну, а если у message нет метода display, то тогда ошибка компиляции.
[55:33.600 --> 55:35.600]  Понятно?
[55:35.600 --> 55:39.600]  То есть он сначала заглядывает в нужный ему класс, и дальше засмотрит виртуальный или не виртуальный метод.
[55:39.600 --> 55:43.600]  Вот. Если он этого метода не находит, то ошибка, естественно.
[55:47.600 --> 55:51.600]  Да, если бы снизу не было const, override бы выдал ошибку.
[55:54.600 --> 55:56.600]  Так.
[55:56.600 --> 55:58.600]  Окей. Как решаем эту проблему?
[55:58.600 --> 56:00.600]  Как отвечаем на эти вопросы?
[56:00.600 --> 56:05.600]  Для решения этих проблем используют так называемые чисто виртуальные функции.
[56:05.600 --> 56:07.600]  Вот. Еще одно определение.
[56:07.600 --> 56:09.600]  Чисто виртуальные функции.
[56:09.600 --> 56:13.600]  Чисто виртуальная функция, это функция, которая объявлена следующим образом.
[56:13.600 --> 56:16.600]  Виртуальная функция равно 0.
[56:16.600 --> 56:20.600]  Вот. Равно 0 означает, что эта функция чисто виртуальная.
[56:20.600 --> 56:22.600]  Вот.
[56:23.440 --> 56:25.440]  Что такое чисто виртуальная функция?
[56:25.440 --> 56:29.440]  Чисто виртуальная функция, это такая функция, чисто виртуальный метод,
[56:29.440 --> 56:33.440]  это такой метод, который можно оставлять без реализации.
[56:33.440 --> 56:35.440]  Первое правило.
[56:35.440 --> 56:39.440]  Если вы объявили чисто виртуальный метод, то его можно оставлять без реализации.
[56:39.440 --> 56:43.440]  Исключением является чисто виртуальный дисструктор,
[56:43.440 --> 56:47.440]  perquè у чисто виртуального дисструктора обязана быть реализация.
[56:47.440 --> 56:49.440]  При этом реализация чисто виртуального метода обязана быть вне класса.
[56:49.440 --> 56:56.620]  То есть, я тут написал класс iMessage, создал чисто виртуальный деструктор,
[56:56.620 --> 57:02.020]  и поэтому внизу, ниже этого класса, я пишу реализацию этого самого деструктора.
[57:02.020 --> 57:08.380]  К чему приводит наличие чисто виртуального метода? Кроме того, что его можно не реализовывать.
[57:08.380 --> 57:13.100]  Во-первых, мы решили одну из проблем. Мы решили проблему два.
[57:13.100 --> 57:17.420]  То есть, если мы понимаем, что для класса message не имеет смысла какого-то дисплея,
[57:17.420 --> 57:21.060]  то можем просто написать дисплей и не писать его реализацию. Вот это первое.
[57:21.060 --> 57:27.700]  Второе. Если в вашем классе есть хотя бы один чисто виртуальный метод,
[57:27.700 --> 57:30.620]  то этот класс автоматически становится абстрактным.
[57:30.620 --> 57:38.540]  Что такое абстрактный класс? Абстрактный класс, по определению, это класс с хотя бы одним чисто виртуальным методом.
[57:38.540 --> 57:40.580]  Кем свойством обладают абстрактные классы?
[57:40.580 --> 57:43.340]  Первое. Объекта абстрактного класса создавать нельзя.
[57:43.340 --> 57:46.260]  То есть, вы не можете создать объект абстрактного класса.
[57:46.260 --> 57:57.300]  Если вы попробуете создать объект абстрактного класса, например, i message m, будет ошибка компиляции.
[57:57.300 --> 58:06.420]  Или если вы попробуете сделать new i message, тоже будет ошибка компиляции.
[58:06.420 --> 58:09.300]  Объекты абстрактных классов создавать нельзя.
[58:09.300 --> 58:14.940]  Но может создавать указатели и ссылки на абстрактный класс.
[58:14.940 --> 58:22.940]  Вот тут у меня есть message, но тут векторе я храню только указатели на сообщения.
[58:22.940 --> 58:30.700]  Вот такое делать можно. Создавать сами объекты абстрактного класса нельзя, но создавать указатели и ссылки на него можно.
[58:30.700 --> 58:37.980]  Вот, соответственно, вот пример. У меня есть i message ptr, который указывает на текстовые сообщения.
[58:37.980 --> 58:41.980]  Или есть ссылка на i message, которая, на самом деле, ссылается на text message.
[58:42.860 --> 58:47.900]  Вот. Это отмет, который объявлен с равно нулю.
[58:51.900 --> 58:57.500]  Его можно не реализовывать, а второе, наличие чисто виртуального метода, говорит о том, что класс является абстрактным.
[59:00.940 --> 59:06.540]  Вот, дальше. Что еще можно сказать про чисто виртуальные методы и про абстрактные классы?
[59:06.940 --> 59:15.580]  Если у вас в классе объявлен чисто виртуальный метод, и наследник не реализует этот самый чисто виртуальный метод, то он сам становится абстрактным.
[59:19.020 --> 59:25.900]  То есть у вас есть класс, в нем есть чисто виртуальный метод, наследники могут реализовывать этот метод и перестать быть абстрактными.
[59:25.900 --> 59:28.580]  Но если какой-то из наследников не реализует данный метод, то он становится абстрактным.
[59:28.580 --> 59:30.580]  то он становится абстрактным, то есть объекты этого класса
[59:30.580 --> 59:32.580]  создавать нельзя.
[59:36.580 --> 59:38.580]  Ну и, собственно, таким образом, смотрите, мы решили
[59:38.580 --> 59:40.580]  все вот эти вот проблемы.
[59:40.580 --> 59:42.580]  Смотрите, если я сделаю message
[59:42.580 --> 59:44.580]  абстрактным классом, то есть, например,
[59:44.580 --> 59:46.580]  вот тут я сделаю метод display
[59:46.580 --> 59:48.580]  чисто виртуальным методом.
[59:48.580 --> 59:50.580]  Что тогда произойдет? Первое.
[59:50.580 --> 59:52.580]  Ответ на первый вопрос. Я тогда не смогу создавать
[59:52.580 --> 59:54.580]  объекты типа message. Круто.
[59:54.580 --> 59:56.580]  Я этого и не хотел, на самом деле.
[59:56.580 --> 59:58.580]  Я теперь могу не реализовывать display.
[59:58.580 --> 01:00:00.580]  Ответ на второй вопрос.
[01:00:00.580 --> 01:00:02.580]  И, наконец, ответ на третий вопрос.
[01:00:02.580 --> 01:00:04.580]  Как заставить наследников реализовывать display? Очень просто.
[01:00:04.580 --> 01:00:06.580]  Я делаю display чисто виртуальным методом.
[01:00:06.580 --> 01:00:08.580]  И если наследники не реализуют display,
[01:00:08.580 --> 01:00:10.580]  то тогда их самих создавать будет нельзя.
[01:00:10.580 --> 01:00:12.580]  Я буду получать ошибку компиляции. Понятно?
[01:00:12.580 --> 01:00:14.580]  То есть таким образом я гарантирую,
[01:00:14.580 --> 01:00:16.580]  что я могу не реализовывать display в классе message,
[01:00:16.580 --> 01:00:18.580]  а все наследники message обязаны
[01:00:18.580 --> 01:00:20.580]  будут реализовывать этот метод display.
[01:00:20.580 --> 01:00:22.580]  Вот.
[01:00:22.580 --> 01:00:24.580]  Чем хороши абстрактные классы?
[01:00:24.580 --> 01:00:26.580]  Почему внезапно тут в процессе слайдов
[01:00:26.580 --> 01:00:28.580]  у меня message превратился в iMessage?
[01:00:28.580 --> 01:00:30.580]  Смотрите, абстрактные классы, как правило,
[01:00:30.580 --> 01:00:32.580]  помещаются префиксом i от слова interface.
[01:00:32.580 --> 01:00:34.580]  Потому что абстрактные классы
[01:00:34.580 --> 01:00:36.580]  создают так называемый interface.
[01:00:36.580 --> 01:00:38.580]  То есть сами классы,
[01:00:38.580 --> 01:00:40.580]  сами объекты абстрактных классов
[01:00:40.580 --> 01:00:42.580]  создать нельзя. И вот абстрактные классы
[01:00:42.580 --> 01:00:44.580]  реализуют так называемый interface. То есть как бы
[01:00:44.580 --> 01:00:46.580]  они говорят, как устроены
[01:00:46.580 --> 01:00:48.580]  вообще все объекты, которые у нас следованы
[01:00:48.580 --> 01:00:50.580]  от моего класса. То есть, в частности,
[01:00:50.580 --> 01:00:52.580]  interface iMessage говорит следующее. Все объекты
[01:00:52.580 --> 01:00:54.580]  сообщений реализуют метод display.
[01:00:54.580 --> 01:00:56.580]  То есть все сообщения можно отобразить.
[01:00:56.580 --> 01:00:58.580]  Вот. То есть это interface.
[01:00:58.580 --> 01:01:00.580]  То есть каждому сообщению можно обратиться
[01:01:00.580 --> 01:01:02.580]  к дисплею. Понятно?
[01:01:06.580 --> 01:01:08.580]  Окей. Ну и вызов
[01:01:08.580 --> 01:01:10.580]  чисто виртуального метода в конструкторе и диструктуре абстрактного класса
[01:01:10.580 --> 01:01:12.580]  приводит к undefinedBehaviour. Но это понятно,
[01:01:12.580 --> 01:01:14.580]  потому что мы с вами говорили, что в конструкторах
[01:01:14.580 --> 01:01:16.580]  и диструктурах виртуальность не работает.
[01:01:16.580 --> 01:01:18.580]  Вот. Если вы в конструкторе
[01:01:18.580 --> 01:01:20.580]  или в диструктуре вызываете чисто виртуальный метод,
[01:01:20.580 --> 01:01:22.580]  то это приведет к неопределенному поведению.
[01:01:22.580 --> 01:01:24.580]  Вот. Ну и, собственно, вот в последнем пункте
[01:01:24.580 --> 01:01:26.580]  я сказал, абстрактный класс используется для определения
[01:01:26.580 --> 01:01:28.580]  интерфейсов и создания семейства классов
[01:01:28.580 --> 01:01:30.580]  с одинаковыми свойствами. То есть, грубо говоря,
[01:01:30.580 --> 01:01:32.580]  как все выглядит. Вы описываете интерфейс,
[01:01:32.580 --> 01:01:34.580]  то есть описываете абстрактный класс,
[01:01:34.580 --> 01:01:36.580]  и все интерфейсные методы, ну типа как,
[01:01:36.580 --> 01:01:38.580]  взаимодействие там с вашими классами, описываете
[01:01:38.580 --> 01:01:40.580]  вот с помощью чисто виртуальных методов.
[01:01:40.580 --> 01:01:42.580]  А дальше наследуетесь от этого интерфейса
[01:01:42.580 --> 01:01:44.580]  и реализуете те методы, которые
[01:01:44.580 --> 01:01:46.580]  нужны. Окей?
[01:01:46.580 --> 01:01:48.580]  Ну вот.
[01:01:48.580 --> 01:01:50.580]  Ну, например, я бы мог создать, например,
[01:01:50.580 --> 01:01:52.580]  интерфейс-контейнер в C++.
[01:01:52.580 --> 01:01:54.580]  Я создал интерфейс-контейнер и говорю,
[01:01:54.580 --> 01:01:56.580]  что в любой контейнер можно добавить
[01:01:56.580 --> 01:01:58.580]  элемент, ну, например, с помощью метода push.
[01:01:58.580 --> 01:02:00.580]  У любого контейнера можно спросить размер size
[01:02:00.580 --> 01:02:02.580]  и, не знаю, у любого контейнера
[01:02:02.580 --> 01:02:04.580]  можно, не знаю,
[01:02:04.580 --> 01:02:06.580]  спросить, пустой он или нет.
[01:02:06.580 --> 01:02:08.580]  Что бы я сделал? Я бы сказал,
[01:02:08.580 --> 01:02:10.580]  класс iContainer,
[01:02:10.580 --> 01:02:12.580]  интерфейс-контейнеры,
[01:02:12.580 --> 01:02:14.580]  и вот.
[01:02:14.580 --> 01:02:16.580]  И вот.
[01:02:16.580 --> 01:02:18.580]  Вот.
[01:02:18.580 --> 01:02:20.580]  Паблик.
[01:02:20.580 --> 01:02:22.580]  И написал бы следующие методы.
[01:02:22.580 --> 01:02:24.580]  virtual
[01:02:24.580 --> 01:02:26.580]  size
[01:02:26.580 --> 01:02:28.580]  t
[01:02:28.580 --> 01:02:30.580]  size
[01:02:30.580 --> 01:02:32.580]  const
[01:02:32.580 --> 01:02:34.580]  равно 0.
[01:02:34.580 --> 01:02:36.580]  Ну, и там какие-то другие методы.
[01:02:36.580 --> 01:02:38.580]  И тогда любой наследник
[01:02:38.580 --> 01:02:40.580]  класс iContainer обязан был бы реализовывать метод size,
[01:02:40.580 --> 01:02:42.580]  но тогда в каждом наследнике был бы тоже метод size.
[01:02:42.580 --> 01:02:44.580]  Окей?
[01:02:44.580 --> 01:02:46.580]  Вот.
[01:02:46.580 --> 01:02:48.580]  Какой вопрос?
[01:02:50.580 --> 01:02:52.580]  Да.
[01:02:52.580 --> 01:02:54.580]  В абстрактных классах
[01:02:54.580 --> 01:02:56.580]  могут быть
[01:02:56.580 --> 01:02:58.580]  как и виртуальные методы, так и не виртуальные методы,
[01:02:58.580 --> 01:03:00.580]  так и поля. Единственное, нельзя
[01:03:00.580 --> 01:03:02.580]  создавать просто объекты этого класса.
[01:03:02.580 --> 01:03:04.580]  По всем остальным они ведут себя как обычные классы.
[01:03:08.580 --> 01:03:10.580]  Да.
[01:03:10.580 --> 01:03:12.580]  У абстрактных классов могут быть и конструкторы,
[01:03:12.580 --> 01:03:14.580]  да, вполне.
[01:03:20.580 --> 01:03:22.580]  Да, абстрактный класс нужен только для того,
[01:03:22.580 --> 01:03:24.580]  чтобы от них наследовались.
[01:03:24.580 --> 01:03:26.580]  То есть абстрактный класс — это класс, который нельзя создать,
[01:03:26.580 --> 01:03:28.580]  от него можно только унаследоваться.
[01:03:32.580 --> 01:03:34.580]  Есть ли вопросы?
[01:03:36.580 --> 01:03:38.580]  Окей.
[01:03:38.580 --> 01:03:40.580]  Ну, и давайте в конце
[01:03:40.580 --> 01:03:42.580]  поговорим, у нас как раз 5 минут осталось,
[01:03:42.580 --> 01:03:44.580]  давайте поговорим про то,
[01:03:44.580 --> 01:03:46.580]  как же на самом деле это все работает, как это все устроено.
[01:03:54.580 --> 01:03:56.580]  Ну, заглянем чуть под капот
[01:03:56.580 --> 01:03:58.580]  C++ и
[01:03:58.580 --> 01:04:00.580]  поговорим о том, как работает это самое,
[01:04:00.580 --> 01:04:02.580]  ну, как C++ достигает вот этого
[01:04:02.580 --> 01:04:04.580]  самого позднего связывания.
[01:04:04.580 --> 01:04:06.580]  Давайте еще раз поясню, в чем у нас
[01:04:06.580 --> 01:04:08.580]  идея. Вот есть указатель P, который
[01:04:08.580 --> 01:04:10.580]  указывает на
[01:04:10.580 --> 01:04:12.580]  B, то есть у меня есть
[01:04:14.580 --> 01:04:16.580]  объект B,
[01:04:16.580 --> 01:04:18.580]  вот, и P указывает
[01:04:18.580 --> 01:04:20.580]  на самом деле вот сюда.
[01:04:20.580 --> 01:04:22.580]  Ну, и допустим, у меня
[01:04:22.580 --> 01:04:24.580]  в классе A, давайте еще напишем, что у меня есть
[01:04:24.580 --> 01:04:26.580]  класс A, в нем объявлен
[01:04:28.580 --> 01:04:30.580]  виртуальный метод F
[01:04:30.580 --> 01:04:32.580]  и есть B, ну, который тоже
[01:04:32.580 --> 01:04:34.580]  определяет свой собственный F,
[01:04:34.580 --> 01:04:36.580]  overwrite.
[01:04:36.580 --> 01:04:38.580]  Вот. Я делаю следующую вещь,
[01:04:38.580 --> 01:04:40.580]  я говорю P
[01:04:40.580 --> 01:04:42.580]  от F.
[01:04:42.580 --> 01:04:44.580]  Ключевой вопрос такой,
[01:04:44.580 --> 01:04:46.580]  а как компилятор понимает,
[01:04:46.580 --> 01:04:48.580]  точнее, как программа понимает,
[01:04:48.580 --> 01:04:50.580]  что вот тут лежит объект типа B?
[01:04:50.580 --> 01:04:52.580]  Давайте снова взглянем,
[01:04:52.580 --> 01:04:54.580]  давайте взглянем на программу с точки зрения,
[01:04:54.580 --> 01:04:56.580]  ну, с точки зрения того,
[01:04:56.580 --> 01:04:58.580]  как программа видит память.
[01:04:58.580 --> 01:05:00.580]  Вот. С точки зрения программы
[01:05:00.580 --> 01:05:02.580]  память компьютера выглядит так.
[01:05:06.580 --> 01:05:08.580]  Вот.
[01:05:08.580 --> 01:05:10.580]  Вот, когда программа читает
[01:05:10.580 --> 01:05:12.580]  данные вот по этому указателю,
[01:05:12.580 --> 01:05:14.580]  она идет по этому указателю
[01:05:14.580 --> 01:05:16.580]  и видит там 0, 0, 1, 1, всякие нолики, единички.
[01:05:16.580 --> 01:05:18.580]  Вопрос, как по этой последовательности ноликов и единичек
[01:05:18.580 --> 01:05:20.580]  вообще, говоря, понять, что там за объект?
[01:05:24.580 --> 01:05:26.580]  Ну, непонятно, да,
[01:05:26.580 --> 01:05:28.580]  потому что, ну, смотрите, в теории
[01:05:28.580 --> 01:05:30.580]  объект типа A может содержать
[01:05:30.580 --> 01:05:32.580]  такую последовательность ноликов и единичек, да?
[01:05:32.580 --> 01:05:34.580]  Объект типа B тоже может содержать
[01:05:34.580 --> 01:05:36.580]  такую последовательность ноликов и единичек.
[01:05:36.580 --> 01:05:38.580]  Вот.
[01:05:38.580 --> 01:05:40.580]  То есть отсюда мы делаем
[01:05:40.580 --> 01:05:42.580]  такой вывод, что на самом деле,
[01:05:44.580 --> 01:05:46.580]  чтобы понять,
[01:05:46.580 --> 01:05:48.580]  какую версию функцию f нужно вызывать,
[01:05:48.580 --> 01:05:50.580]  компилятору нужно сохранять
[01:05:50.580 --> 01:05:52.580]  какую-то дополнительную информацию о том,
[01:05:52.580 --> 01:05:54.580]  которая бы говорила на этапе исполнения,
[01:05:54.580 --> 01:05:56.580]  какой класс тут
[01:05:56.580 --> 01:05:58.580]  на самом деле лежит.
[01:05:58.580 --> 01:06:00.580]  И история звучит
[01:06:00.580 --> 01:06:02.580]  в следующем. Смотрите.
[01:06:02.580 --> 01:06:04.580]  Если у вас
[01:06:04.580 --> 01:06:06.580]  в классе есть хотя бы
[01:06:06.580 --> 01:06:08.580]  один виртуальный метод,
[01:06:08.580 --> 01:06:10.580]  то компилятор для этого класса
[01:06:10.580 --> 01:06:12.580]  создает так называемую таблицу виртуальных функций.
[01:06:12.580 --> 01:06:14.580]  Что такое таблица виртуальных функций?
[01:06:14.580 --> 01:06:16.580]  Вот у вас есть класс A,
[01:06:16.580 --> 01:06:18.580]  и компилятор для него
[01:06:18.580 --> 01:06:20.580]  создает таблицу виртуальных функций, значит,
[01:06:20.580 --> 01:06:22.580]  в ней записана следующая информация.
[01:06:22.580 --> 01:06:24.580]  В ней, грубо говоря, записана функция,
[01:06:24.580 --> 01:06:26.580]  точнее метод, и адрес,
[01:06:26.580 --> 01:06:28.580]  по которому он расположен.
[01:06:28.580 --> 01:06:30.580]  Там 0x, там a, f
[01:06:30.580 --> 01:06:32.580]  и так далее.
[01:06:32.580 --> 01:06:34.580]  Потом есть класс B.
[01:06:36.580 --> 01:06:38.580]  В классе B тоже есть виртуальный метод,
[01:06:38.580 --> 01:06:40.580]  ну, допустим, это тоже виртуальный метод f,
[01:06:40.580 --> 01:06:42.580]  ну, и допустим, есть еще виртуальный метод g.
[01:06:42.580 --> 01:06:44.580]  Что тогда делает компилятор?
[01:06:44.580 --> 01:06:46.580]  Компилятор создает две записи
[01:06:46.580 --> 01:06:48.580]  в таблице виртуальных функций для b.
[01:06:48.580 --> 01:06:50.580]  Значит, создает
[01:06:50.580 --> 01:06:52.580]  запись для f,
[01:06:52.580 --> 01:06:54.580]  что функция f лежит вот по такому-то адресу.
[01:06:54.580 --> 01:06:56.580]  И есть функция g, которая тоже лежит вот по какому-то другому адресу.
[01:06:56.580 --> 01:06:58.580]  То есть для каждой виртуальной функции
[01:06:58.580 --> 01:07:00.580]  компилятор создает таблицу
[01:07:00.580 --> 01:07:02.580]  для каждого
[01:07:02.580 --> 01:07:04.580]  класса с виртуальными функциями.
[01:07:04.580 --> 01:07:06.580]  Компилятор создает таблицу виртуальных функций,
[01:07:06.580 --> 01:07:08.580]  которая просто- просто говорит,
[01:07:08.580 --> 01:07:10.580]  какая функция, где расположена,
[01:07:10.580 --> 01:07:12.580]  то есть, где искать код соответствующей функции.
[01:07:12.580 --> 01:07:14.580]  А дальше
[01:07:14.580 --> 01:07:16.580]  что делает компилятор?
[01:07:16.580 --> 01:07:18.580]  Компилятор перед
[01:07:18.580 --> 01:07:20.580]  каждым таким классом, у которого есть таблица виртуальных функций,
[01:07:20.580 --> 01:07:22.580]  кладет указатель,
[01:07:22.580 --> 01:07:36.260]  Указатель, который называется указатель на таблицу виртуальных
[01:07:36.260 --> 01:07:37.260]  функций.
[01:07:37.260 --> 01:07:49.660]  Вот, и что на самом деле происходит?
[01:07:49.660 --> 01:07:55.180]  Сначала идёт указатель на таблицу виртуальных
[01:07:55.180 --> 01:07:57.740]  функций, потом часть, которая относится к А, потом часть,
[01:07:57.740 --> 01:07:58.900]  которая относится к Б без А.
[01:07:58.900 --> 01:08:00.580]  И вот этот указатель на самом деле указывает вот
[01:08:00.580 --> 01:08:01.580]  сюда.
[01:08:01.580 --> 01:08:07.060]  Что происходит в момент исполнения программы?
[01:08:07.060 --> 01:08:08.220]  В моменте исполнения программы происходит следующее.
[01:08:08.220 --> 01:08:12.180]  Компиляторы видят, что П указывает на А.
[01:08:12.180 --> 01:08:16.940]  У Ашки есть виртуальные функции, а раз у Ашки есть виртуальные
[01:08:16.940 --> 01:08:21.420]  то это значит что вот этот метод add возможно не тот, чем кажется.
[01:08:21.420 --> 01:08:23.720]  Поэтому что делает компилятор?
[01:08:23.720 --> 01:08:27.000]  Компилятор понимает, что так как а имеет виртуальной
[01:08:27.000 --> 01:08:28.840]  функции у него есть таблицы виртуальных функций,
[01:08:28.840 --> 01:08:32.060]  и поэтому компилятор понимает, что на самом деле этот указатель
[01:08:32.060 --> 01:08:35.880]  указывает на указатель на таблицу виртуальных
[01:08:35.880 --> 01:08:37.020]  функций.
[01:08:37.020 --> 01:08:38.620]  Вот так.
[01:08:40.800 --> 01:08:41.660]  И что он делает?
[01:08:41.660 --> 01:08:45.120]  Он просто-напросто идет по этому указателю, дальше
[01:08:45.120 --> 01:08:50.360]  идет по этому указателю, и в этой таблице ищет нужную ему функцию.
[01:08:50.360 --> 01:09:02.120]  Понятно? Что происходит? Еще раз, допустим, я сделал вот так. Если я сделал вот так,
[01:09:02.120 --> 01:09:07.040]  то вот этот указатель на таблицу виртуальных функций будет указывать на
[01:09:07.040 --> 01:09:11.280]  таблицу виртуальных функций для a. Когда я буду вызывать p стрелочка f, что будет
[01:09:11.280 --> 01:09:15.120]  происходить? Компилятор пойдет по указателю p, потом пойдет по этому
[01:09:15.120 --> 01:09:19.120]  указателю из таблиц виртуальных функций, и вот из этой таблицы возьмет указатель
[01:09:19.120 --> 01:09:24.400]  на f. Понятно? Если бы тут хранился указатель на b,
[01:09:24.400 --> 01:09:30.680]  тогда бы программа тут сохранила указатель на таблицу b,
[01:09:30.680 --> 01:09:35.520]  этот указатель пошел бы сюда, поэтому из этой таблицы виртуальных
[01:09:35.520 --> 01:09:38.920]  функций он пошел бы сюда, и дальше он увидел, что f расположена по такому-то
[01:09:38.920 --> 01:09:46.240]  адресу, и запустил бы функцию вот по такому-то адресу. Понятно? Домашнее задание,
[01:09:46.240 --> 01:09:50.880]  лабораторная работа. Можете самостоятельно поиграть и проверить.
[01:09:50.880 --> 01:09:57.040]  Смотрите, можете создать иерархию этих полиморфных классов
[01:09:57.040 --> 01:10:02.920]  с виртуальными функциями и проверить, что, допустим, a со звездочкой p равно
[01:10:02.920 --> 01:10:13.640]  nu a, а со звездочкой q равно nu a, ну и там то же самое сделать с nu b и nu b, и просто
[01:10:13.640 --> 01:10:16.600]  просто взять и прочитать вот эти вот первые 8 байт. Ну как это можно сделать?
[01:10:16.600 --> 01:10:39.960]  Ну, например, с помощью RinterpreterCast, size t указатель от, например, p,
[01:10:39.960 --> 01:10:46.200]  разыминовать его, вывести, и тогда вы увидите, что для всех указателей, которые указывают на a,
[01:10:46.920 --> 01:10:50.080]  для всех указателей, которые указывают на a, будут выводиться одно и то же число,
[01:10:50.080 --> 01:10:53.380]  для всех указателей, которые указывают на b, будут вывод�иться одно и то же число,
[01:10:53.380 --> 01:10:59.340]  allemaal число будет равным для a и для b, вот. Это как раз говорит о том, что в начале каждого
[01:10:59.340 --> 01:11:02.600]  объекта лежит вот, собственно, какой-то указатель размером 8 байт
[01:11:02.600 --> 01:11:04.640]  который указывает нам таблицы виртуальных функций.
[01:11:04.640 --> 01:11:10.160]  И еще одно замечание. Вот это как раз-таки тоже обосновывает, почему позднее связывание
[01:11:10.160 --> 01:11:14.120]  работает несколько дольше чем обычный вызов методов и функций. Почему? Потому
[01:11:14.120 --> 01:11:17.960]  Давайте проверим, сколько у нас тут обращений по указателю происходит.
[01:11:17.960 --> 01:11:23.120]  Сначала мы обращаемся к указателю P, потом мы обращаемся к указателю из таблиц виртуальных функций,
[01:11:23.120 --> 01:11:27.080]  потом мы обращаемся к указателю, где лежит сама функция, и только потом вызываем эту самую функцию.
[01:11:27.080 --> 01:11:32.680]  То есть, раз, два, три, как минимум три прыжка по памяти, и только после этого вызывается сам метод.
[01:11:32.680 --> 01:11:40.160]  Поэтому по производительности виртуальные функции работают чуть дольше, чем вызов обычных функций.
[01:11:40.160 --> 01:11:43.160]  Есть вопросы?
[01:11:43.200 --> 01:11:46.200]  В пронтайме такая целинкопка происходит?
[01:11:46.200 --> 01:11:51.200]  Ну, типа того, да. В пронтайме происходит выбор нужного метода.
[01:11:51.200 --> 01:11:53.200]  То есть, делается сама система?
[01:11:53.200 --> 01:11:56.200]  Да, это уже делает сама программа.
[01:11:56.200 --> 01:12:00.200]  Ну, про Dynamic Cast поговорите на семинарах.
[01:12:00.200 --> 01:12:03.200]  Так, есть ли еще вопросы?
[01:12:03.200 --> 01:12:06.200]  Давайте.
[01:12:06.240 --> 01:12:10.240]  Да, если класс абстрактный, то он будет хранить 8 байт.
[01:12:10.240 --> 01:12:15.240]  Короче, если абстрактный класс пустой, то он будет хранить только указательную таблицу виртуальных функций.
[01:12:15.240 --> 01:12:19.240]  То есть, пустой абстрактный класс будет занимать 8 байт.
[01:12:19.240 --> 01:12:21.240]  А, вот, сейчас, секунду.
[01:12:21.240 --> 01:12:24.240]  Еще одна лаборатория, которую вы можете проверить.
[01:12:24.240 --> 01:12:29.240]  Вы можете написать класс с виртуальными функциями и без виртуальных функций.
[01:12:29.240 --> 01:12:32.240]  То есть, один тот же класс.
[01:12:32.280 --> 01:12:35.280]  Но в одном классе виртуальные функции, в другом классе не виртуальные функции.
[01:12:35.280 --> 01:12:37.280]  И сравните их sizeOf.
[01:12:37.280 --> 01:12:40.280]  И увидите, что sizeOf класса с виртуальными функциями на 8 байт больше,
[01:12:40.280 --> 01:12:42.280]  чем sizeOf класса без виртуальных методов.
[01:12:42.280 --> 01:12:44.280]  Вот.
[01:12:44.280 --> 01:12:46.280]  Ладно, все, спасибо.
