[00:00.000 --> 00:15.000]  Продолжим. В прошлый раз мы начали говорить про графы, обходы графов, разобрали обход ширину,
[00:15.000 --> 00:37.280]  но сегодня мы продолжаем тему обходов и говорим про глубину. В прошлый раз мы придумали одну из
[00:37.280 --> 00:45.080]  стратегий, как можно, имея на руках какую-то вершину, обойти все остальные вершины, которые
[00:45.080 --> 00:49.560]  достижены из нее. И стратегия была буквально следующей. Вот у нас из вершины есть некоторый
[00:49.560 --> 00:55.080]  набор ребер, по которым можно куда-то перейти. И что мы делали? В первую очередь мы проходили
[00:55.080 --> 01:01.840]  во все вершины сразу и посещали их. Дальше смотрели, до куда можно добраться из этих новых вершин,
[01:01.840 --> 01:11.360]  и проходили в них. Ну и так далее. То есть постепенно увеличивали область нашего покрытия.
[01:11.360 --> 01:17.480]  Вот это стратегия, про которую говорили в прошлый раз. Теперь давайте попробуем придумать какую-то
[01:17.480 --> 01:25.240]  другую стратегию. У нас есть какая-то вершина, и мы в ней уже находимся. У нас есть определенное
[01:25.240 --> 01:32.960]  количество направлений, по которым можем пройти. И вот здесь действует стратегия такая. Если хочешь
[01:32.960 --> 01:44.120]  идти, иди. Давайте просто возьмем и будем идти, куда глаза глядят. Возьмем произвольное
[01:44.120 --> 01:51.080]  направление и пойдем туда. Из этой вершины тоже посмотрим на произвольное направление,
[01:51.080 --> 02:00.960]  куда можно пойти и пойдем туда. Ну и так далее. Понятно? То есть таким жадным образом будем идти,
[02:00.960 --> 02:06.800]  пока идется. Но мы знаем, что в конце пути ничего уже не вернуть. Поэтому в какой-то момент лафа
[02:06.800 --> 02:14.960]  закончится. В какой-то момент у нас идти дальше уже не получится. Ну почему такое может произойти?
[02:14.960 --> 02:20.280]  Ну, допустим, мы пришли вершину, из которой в принципе не торчит ни одного ребра. Это первый вариант.
[02:20.280 --> 02:26.040]  Второй вариант. Из нее могут торчать ребра, но все эти ребра, они ведут уже ранее посещенные вершины.
[02:26.040 --> 02:30.280]  То есть в такой ситуации мы тоже ни в какую новую вершину пройти не можем.
[02:30.280 --> 02:37.680]  Что мы в этот момент будем делать? В этот момент мы будем просто-напросто брать и откатываться назад.
[02:37.680 --> 02:43.720]  То есть откатываться в вершину, из которой мы пришли, ну и продолжать поиск из нее же. Вот отсюда мы
[02:43.720 --> 02:47.440]  никуда не можем пойти, дальше мы идем в новую вершину, из этой вершины приходим в новую вершину,
[02:47.440 --> 02:53.440]  и за этой снова никуда не можем пойти. Откатываемся назад в эту вершину. Ну и идем далее. Понятно, да?
[02:54.440 --> 02:58.440]  То есть мы просто жадным образом перебираем все возможные пути из этой вершины.
[02:58.440 --> 03:03.440]  Ну каким образом мы это делаем? Мы идем в произвольную вершину и перебираем пути уже из этой вершины. И так далее.
[03:03.440 --> 03:05.440]  Окей?
[03:05.440 --> 03:07.440]  Идея понятна.
[03:07.440 --> 03:11.440]  Вот это, собственно, и называется обходом в глубину.
[03:11.440 --> 03:18.440]  Так, что можно сказать про этот обход?
[03:18.440 --> 03:23.440]  Ну давайте я введу несколько понятий, которые нам понадобятся для непосредственно анализа алгоритма,
[03:23.440 --> 03:26.440]  ну и плюс для доказательств некоторых его полезных свойств.
[03:26.440 --> 03:33.440]  Ну, наверное, первое стоит отметить. Всем ли понятно, что вот такой вот обход в глубину не особо подходит для поиска кратчайших путей?
[03:33.440 --> 03:36.440]  Вот как это было раньше в случае обхода в ширину?
[03:36.440 --> 03:41.440]  Ну потому что здесь мы берем вообще произвольный путь, он может быть сколько угодно длинным,
[03:41.440 --> 03:44.440]  поэтому кратчайшие пути, скорее всего, мы таким образом не найдем.
[03:44.440 --> 03:47.440]  Но обходы в глубину, на самом деле, есть куча других хороших свойств.
[03:47.440 --> 03:53.440]  Вот давайте перед тем, как ним проходить, попробуем ввести некоторые обозначения.
[03:53.440 --> 04:00.440]  Значит, смотрите, в процессе обхода в глубину я буду красить вершины.
[04:00.440 --> 04:02.440]  Вот буду раскрашивать.
[04:02.440 --> 04:07.440]  Ну, не забываем, где мы находимся, то есть звучит весело, но будем красить, на самом деле, в черные, белые и серые цвета.
[04:07.440 --> 04:11.440]  Соответственно, у нас будет три цвета.
[04:11.440 --> 04:13.440]  Первый цвет – это белый.
[04:16.440 --> 04:18.440]  Вот вершина является белой.
[04:20.440 --> 04:26.440]  Это вершина, которая еще не обнаружена.
[04:32.440 --> 04:37.440]  Вот если вы до какой-то вершины еще не дошли, ну, например, вот до этой вершины.
[04:37.440 --> 04:40.440]  То есть мы тут гуляли-гуляли, но до этой еще не дошла очередь.
[04:40.440 --> 04:42.440]  Вот она в этот момент белой.
[04:42.440 --> 04:46.440]  Изначально все вершины в моем графе, они белые, по понятным причинам.
[04:47.440 --> 04:52.440]  Далее. В процессе своей жизни вершина может посереть, стать серой.
[04:55.440 --> 04:58.440]  Вот это обнаруженная вершина.
[04:58.440 --> 05:00.440]  Вот это обнаруженная вершина.
[05:11.440 --> 05:15.440]  Значит, какие вершины здесь серые? Ну, давайте снова попробуем восстановить какой-нибудь обход.
[05:15.440 --> 05:19.440]  Если мы стартуем с этой вершиной, то изначально мы ее обнаружили, мы ее посетили.
[05:19.440 --> 05:26.440]  Красим серым цветом. Давайте я буду белое обзначать вот так, серое – вот так, ну и черное, потом впоследствии вот так.
[05:27.440 --> 05:30.440]  Изначально я зашел в эту вершину, она посеряла.
[05:31.440 --> 05:34.440]  Дальше я иду в какую-то произвольную вершину, ну, допустим, в эту.
[05:34.440 --> 05:37.440]  Как только я ее обнаружил, я ее делаю серой.
[05:37.440 --> 05:41.440]  Дальше я иду сюда. Обнаружил, сделал серой.
[05:41.440 --> 05:45.440]  Дальше пошел сюда, сделал серой. Вот.
[05:45.440 --> 05:47.440]  Получил такой путь.
[05:47.440 --> 05:50.440]  То есть только обнаруженные вершины я помечаю просто серым цветом.
[05:51.440 --> 05:54.440]  Ну и последний тип вершины – это черные вершины.
[05:56.440 --> 06:01.440]  Черные вершины – это вершины, для которых я завершил обработку.
[06:03.440 --> 06:06.440]  Завершил обработку.
[06:08.440 --> 06:10.440]  Ну что значит завершил обработку?
[06:10.440 --> 06:15.440]  Это значит, что я, во-первых, посетил ее, а во-вторых, посетил всех ее соседей.
[06:15.440 --> 06:18.440]  То есть все возможные пути из этой вершины я уже обнаружил.
[06:18.440 --> 06:21.440]  Понятно? То есть никаких новых путей из этой вершины я уже не найду.
[06:21.440 --> 06:25.440]  Ну вот, например, смотрите, вот эта вершина не черная, потому что в данный момент я из нее ищу какой-то путь.
[06:25.440 --> 06:29.440]  Вот эта вершина тоже пока не черная, потому что из нее я в данный момент ищу какой-то путь.
[06:29.440 --> 06:31.440]  С этой вершиной то же самое.
[06:31.440 --> 06:35.440]  А вот с этой вершиной она стала серой, и я пытаюсь из нее найти какой-то новый путь.
[06:35.440 --> 06:38.440]  Но при этом я понимаю, что никуда из нее пойти не могу.
[06:38.440 --> 06:40.440]  И вот в этот момент она становится черной. Понятно?
[06:40.440 --> 06:45.440]  То есть как только для вершины я понимаю, что из нее я уже никуда не пойду, она чернеет.
[06:47.440 --> 06:49.440]  Она стала черной.
[06:49.440 --> 06:53.440]  Что делаю дальше? Откатываюсь сюда, перехожу в новую вершину сюда.
[06:53.440 --> 06:56.440]  То есть из этой вершины перехожу сюда, так что она становится серой.
[06:56.440 --> 06:59.440]  Дальше из этой вершины перехожу сюда, она становится серой.
[06:59.440 --> 07:01.440]  И снова, из нее я никуда пойти не могу.
[07:01.440 --> 07:03.440]  И в этот момент она становится черной.
[07:03.440 --> 07:06.440]  Откатываюсь сюда, она становится черной.
[07:06.440 --> 07:08.440]  Откатываюсь сюда, она становится черной.
[07:08.440 --> 07:10.440]  Сюда.
[07:10.440 --> 07:11.440]  Сюда.
[07:11.440 --> 07:14.440]  И это не чернеет, потому что из нее есть новый путь.
[07:14.440 --> 07:18.440]  Поэтому помечаю считаю ее серой, из нее, снова, никуда нельзя пойти,
[07:18.440 --> 07:20.440]  она черная, возвращаюсь обратно, и все.
[07:20.440 --> 07:22.440]  Получилось так, что все вершины черные.
[07:24.440 --> 07:26.440]  Ну вот.
[07:29.440 --> 07:31.440]  С этим понятно.
[07:32.440 --> 07:34.440]  Так, давайте дальше. Что еще?
[07:34.440 --> 07:38.440]  Какие еще характеристики мне хочется подсчитывать на график?
[07:40.440 --> 07:44.440]  Давайте я буду считать дополнительно такие характеристики.
[07:46.440 --> 07:48.440]  TimeIn
[07:50.440 --> 07:52.440]  и TimeOut.
[07:52.440 --> 07:54.440]  TimeIn
[07:54.440 --> 07:58.440]  я буду называть время обнаружения.
[08:04.440 --> 08:06.440]  TimeIn для меня — это время обнаружения вершины.
[08:10.440 --> 08:12.440]  TimeOut — это время завершения ее обработки.
[08:13.440 --> 08:15.440]  время
[08:16.440 --> 08:18.440]  обработки
[08:20.440 --> 08:22.440]  обработки
[08:27.440 --> 08:29.440]  Для чего мне это нужно, станет понятно позже.
[08:29.440 --> 08:31.440]  Давайте просто разберемся, как с этим работать.
[08:31.440 --> 08:33.440]  Давайте снова воспользуемся этим же графом.
[08:38.440 --> 08:40.440]  Берем пометки.
[08:40.440 --> 08:44.440]  И попробуем для каждой из них написать время ее входа и время выхода.
[08:44.440 --> 08:46.440]  Время, понятное дело, имеет в виду не астрономическое время.
[08:46.440 --> 08:48.440]  В первом моменте времени произошло то-то, во втором моменте — то-то и так далее.
[08:48.440 --> 08:50.440]  Сейчас станет понятно.
[09:06.440 --> 09:08.440]  В первый момент времени я пришел в эту вершину.
[09:08.440 --> 09:10.440]  Допустим, я стартую с этой вершины.
[09:10.440 --> 09:12.440]  В первый момент я ее обнаружил.
[09:12.440 --> 09:14.440]  И ее TimeIn равен единице.
[09:16.440 --> 09:18.440]  В первом момент времени я обнаружил эту вершину.
[09:18.440 --> 09:20.440]  В втором момент времени я обнаружил эту вершину.
[09:20.440 --> 09:22.440]  é
[09:23.440 --> 09:24.440]  В третьем момент времени я пришел в эту вершину.
[09:25.440 --> 09:26.440]  И в четвертом моменте — в эту вершину.
[09:30.440 --> 09:32.440]  Что произошло в пятый момент времени.
[09:34.440 --> 09:36.440]  Я завершил обработку вот этой вершины.
[09:36.440 --> 09:40.440]  Ск bar
[09:40.440 --> 09:42.440]  était черный, и я кладу значение 5 вверх.
[09:42.440 --> 09:45.440]  Я Besch They Пledge и ganz tennis.
[09:45.440 --> 09:48.220]  Дальше я перехожу сюда, из нее я могу пройти сюда.
[09:48.220 --> 09:51.360]  То есть, шестой момент времени я обнаружил вот эту вершину,
[09:51.360 --> 09:54.060]  седьмой вот эту, восьмой момент времени завершил
[09:54.060 --> 09:55.060]  ее обработку.
[09:55.060 --> 09:59.820]  В девятом момент времени завершил эту обработку.
[09:59.820 --> 10:06.700]  В десятый это одиннадцать, здесь в момент времени
[10:06.700 --> 10:10.520]  двенадцать я обнаружил вот эту вершину И в тринадцатом
[10:10.520 --> 10:30.800]  Ну и здесь 14, вот. Понятно. Ну, наверное, пока мне этого достаточно. Ну чего, напишем код.
[10:30.800 --> 10:38.040]  Давайте как формально описать тот алгоритм, который я только что продемонстрировал. Ну,
[10:38.040 --> 10:49.400]  давайте. Значит, основная процедура — это test-visit. Алгоритм у нас будет рекурсивный. Идея по
[10:49.400 --> 10:53.800]  алгоритму получается в следующем. Вот если мне нужно из этой вершины обойти все вершины,
[10:53.800 --> 10:57.720]  которые достижены из нее, то давайте я просто в цикле попробую обойти сначала все вершины,
[10:57.720 --> 11:03.040]  которые... то есть рекурсивно запущу поиск всех вершин отсюда, потом рекурсивно запущу поиск всех
[11:03.040 --> 11:07.960]  вершин отсюда, ну и так для всех соседей. Понятно, да? То есть все достаточно просто. То есть
[11:07.960 --> 11:14.640]  DFS видит от графа G и стартовые вершины S. Нет, давайте не стартовые вершины S, а просто для
[11:14.640 --> 11:32.960]  произвольной вершины S, O и V. Туда. Так, что я делаю? Ну, смотрите, в самый начальный момент времени
[11:32.960 --> 11:39.480]  когда я посетил вершину V, то есть когда я только пришел в вершину V, что я должен для нее сделать?
[11:39.480 --> 11:45.480]  Вот я только в нее пришел. Что с ней происходит? Давайте. Да, я ее должен покрасить. В какой цвет?
[11:45.480 --> 11:53.400]  В серый цвет. И установить ей время, то время, в которое я в нее пришел. То есть давайте сделаем так.
[11:53.400 --> 12:10.720]  А цвет вершины V стал серый, и время входа в эту вершину V это плюс-плюс тайм. Ну, инициализация,
[12:10.720 --> 12:25.760]  я думаю, понятна. Все цвета изначально белые, время изначально нулевое, время входа для
[12:25.760 --> 12:33.680]  всех вершин дает бесконечность. Напишем. То есть никогда мы их не обнаружили, никогда мы из них не
[12:33.680 --> 12:43.880]  вышли. Здесь тоже бесконечность. Это инициализация. Окей, ну, собственно, изначально, когда я встретил вершину,
[12:43.880 --> 12:50.360]  я ее покрасил серый цвет. Это первое, а во второе, ну, в следующее я сказал, что время входа это плюс-плюс тайм.
[12:50.360 --> 13:01.040]  Ну, и, собственно, самая ключевая часть алгоритма, это вот этот цикл. Пройдемся по всем соседям вершины V.
[13:01.040 --> 13:14.000]  То есть для каждого соседа вершины V, допустим, это вершина, вот для каждого ее соседа мы рекурсивно
[13:14.000 --> 13:21.760]  запустим обход в глубину. Точнее, не так. Не просто, ну, не безусловно будем запускать обход в глубину,
[13:21.760 --> 13:27.960]  а в каком случае мы запускаем обход в глубину от ее соседа. Да, если он еще не посещен, то есть если
[13:27.960 --> 13:33.960]  вершина белая, то есть если вот этот сосед белый, то я могу спокойно запустить из него обход в глубину.
[13:33.960 --> 13:59.400]  Да? If colors от U to white, то я рекурсивно запускаю dfs-visit ravg и вершина U. Все ясно.
[13:59.960 --> 14:04.280]  Так, ну и после того, как все вот эти вызовы завершились, после того, как я прошел по всем соседям и от каждого
[14:04.280 --> 14:09.880]  соседа вызвал dfs-visit, то в этот момент должно произойти. То есть чему это соответствует? Это соответствует
[14:09.880 --> 14:16.040]  тому, что я вот из этой вершины запустил соседа, ну, запустил dfs от этой вершины, запустил dfs от этой
[14:16.040 --> 14:23.320]  вершины и вернулся сюда. Что в этот момент я должен сделать? Да, я должен покрасить ее в черный свет, так как я
[14:23.320 --> 14:32.360]  завершил обработку. Да? И установить тайм-аут, то есть что в этот момент времени я завершил работу с этой вершиной, то есть
[14:32.360 --> 14:41.960]  colors от V, black, и
[14:46.440 --> 14:50.200]  тайм-аут от V, так оно плюс-блюс тайм.
[14:50.200 --> 15:02.680]  Вот весь алгоритм.
[15:12.760 --> 15:17.400]  Ну, давайте так на таком интуитивном уровне, мы еще ничего не доказывали, но давайте так,
[15:18.040 --> 15:22.360]  насколько вы понимаете, что происходит. Вот если я запускаю dfs-visit от какой-либо вершины,
[15:22.360 --> 15:30.040]  ну, допустим, у меня есть какая-то стартовая вершина S, вот эта вершина, и я запускаю от нее dfs-visit, какие
[15:30.040 --> 15:39.400]  вершины у меня в итоге станут черными? Да, понятно ли, что все вершины, до которых я могу добраться из этой
[15:39.400 --> 15:45.560]  вершины, они в итоге станут черными после обработки. А может у меня случиться так, что я запустил dfs-visit
[15:45.560 --> 15:52.120]  от какой-либо вершины, и у меня остались белые вершины где-то? Да, если они лежат, ну, в случае ориентирован
[15:52.120 --> 15:55.560]  граф про компонент связанности, давайте пока не говорить, ну, в общем, если я не могу до какой-то
[15:55.560 --> 16:02.920]  вершины дотянуться из моей изначальной вершины, то она останется белой. Вот. А может ли получится так,
[16:02.920 --> 16:12.600]  что у меня вот здесь остались где-то серые вершины? Почему? Да, ну смотрите, да, идея в чем? Вот я
[16:12.600 --> 16:17.400]  запустил dfs-visit от какой-либо вершины. Что значит, что вершина серая? Вершина серая это означает,
[16:17.400 --> 16:23.080]  что в данный момент над ней идет обработка. То есть как только мы выходим из dfs-visit, она
[16:23.080 --> 16:28.920]  становится черной. Да, то есть если вершина серая, то значит ее вот вызов dfs-visit не завершился. Ну,
[16:28.920 --> 16:38.440]  давайте посмотрим на самый изначальный вызов dfs-visit. Ну, то есть от вершины S. Вот dfs-visit от S
[16:38.440 --> 16:44.680]  порождает кучу рекурсивных вызовов dfs-visit. В какой-то момент я все эти рекурсивные вызовы
[16:44.680 --> 16:51.200]  завершил и завершил конечный вызов dfs-visit. Но вот этот вызов dfs-visit не мог завершиться до тех пор,
[16:51.200 --> 16:56.480]  пока каждый из этих вызовов не завершился рекурсивных. Да. Но если вершина серая осталась,
[16:56.480 --> 17:01.120]  ну какая-то, то значит ее вызов dfs-visit не завершился. Ну, а такого быть не может. Да,
[17:01.120 --> 17:05.680]  поэтому все вызовы dfs-visit завершились, если они начинались, и все вершины стали черными.
[17:05.680 --> 17:19.600]  Окей. Это да. Ну и чего? Давайте, наверное, перейдем. Да, давайте еще такой момент обсудим.
[17:19.600 --> 17:26.640]  Смотрите, а что, если мне все-таки хочется обойти все вершины графа? Ну, по какой-то причине. Мне
[17:26.640 --> 17:34.080]  необходимо, чтобы все вершины графа были посещены. Что мне для этого нужно сделать? Да, то есть давайте
[17:34.080 --> 17:42.800]  просто-напросто в цикле вызывать dfs-visit от каждой белой вершины. Давайте dfs от графа. Хочу
[17:42.800 --> 17:48.080]  посетить вообще все вершины. Что я делаю? Я просто беру, понятное дело, беру вот эту унициализацию и
[17:48.080 --> 18:05.840]  всю. Да, вставляю сюда. Ну а затем просто в цикле for в множестве вершин граф h, ну а если вершина v
[18:05.840 --> 18:22.920]  белая, я запускаю dfs-visit от v. Что здесь происходит? Я беру первую попавшуюся белую вершину,
[18:22.920 --> 18:30.000]  запускаю от нее dfs-visit. Dfs-visit мне какие-то вершины покрасит в черный цвет. Ну вот все такие вершины
[18:30.000 --> 18:38.960]  я вот в этом цикле буду пропускать. Если вершина черная, я от нее dfs-visit снова не вызываю и
[18:38.960 --> 18:44.280]  нахожу снова первую попавшуюся белую вершину и запускаю dfs-visit от нее. Ну и так далее, пока у меня все
[18:44.280 --> 18:56.280]  вершины не покрасится в черный цвет. Хорошо. Ну и давайте перейдем к доказательству корректности.
[18:56.280 --> 19:02.440]  Почему данный алгоритм действительно посетит все вершины, до которых можно дотянуться из вершины v?
[19:02.440 --> 19:06.520]  Смотрите, начнем с утверждения.
[19:06.520 --> 19:35.240]  Будем утверждать следующее. Не существует момента времени,
[19:35.240 --> 19:48.560]  момента во время работы dfs,
[19:48.560 --> 20:16.040]  который есть ребро из черной вершины в белую. То есть вот вы запустили алгоритм dfs, он там что-то
[20:16.040 --> 20:22.360]  ходит, в какой-то момент вы сделали стоп, то есть нажали на паузу, остановили время и смотрите на то,
[20:22.360 --> 20:27.040]  как вы раскрасили ваш граф. И вот я гарантирую вам, что вы не найдете вообще ни одного ребра,
[20:27.040 --> 20:33.800]  которое бы вело из черной вершины в белую вершину. Вот такого просто быть не может. То есть если вы
[20:33.800 --> 20:40.880]  правильно написали алгоритм, то такого быть не может. Давайте докажем, что я алгоритм написал
[20:40.880 --> 20:48.600]  правильно. Такого ребра действительно нет. Ну давайте докажем от противного. Допустим есть.
[20:48.600 --> 21:04.400]  То есть есть некоторая вершина v, из нее ведет ребро в белую вершину u. Давайте рассмотрим момент
[21:04.400 --> 21:15.720]  timeout v. Давайте рассмотрим тот момент времени, когда вершина v почернела. Вот именно этот
[21:15.720 --> 21:37.080]  момент. Что произошло до этого? До этого работал цикл звездочка. Перед тем, как вершина становится
[21:37.080 --> 21:51.080]  черной, отрабатывает этот цикл. А что в этом цикле происходит? Мы просмариваем всех соседей,
[21:51.080 --> 22:11.760]  и если сосед белый, то мы от него вызываем dfsvisit. Из этого следует, видели белую вершину v, вершину u.
[22:11.760 --> 22:17.880]  То есть если мы проходимся по всем соседям и проверяем их цвет, то мы должны были видеть вершину
[22:17.880 --> 22:22.560]  u, которая белая. Потому что в процессе работы алгоритма у меня вершина никогда не светлеет,
[22:22.560 --> 22:27.720]  она только темнеет. Но если она никогда не темнеет, то значит она изначально была белая.
[22:27.720 --> 22:42.120]  Значит видели вершину u, но по какой-то причине в нее не пошли.
[22:42.120 --> 22:51.400]  Ну подождите, как мы могли в нее не пойти? Здесь же вот все честно, все открыто,
[22:51.400 --> 22:58.840]  прям как в электронном голосовании. То есть все можно проверить, вот все работает. Вот вершина
[22:58.840 --> 23:04.440]  белая, мы должны были от нее запустить dfsvisit. Если мы запускали от нее dfsvisit, то она должна
[23:04.440 --> 23:09.600]  была стать серой. Но такого не произошло. Ну противоречие с алгоритмом. Вот вам математически
[23:09.600 --> 23:15.360]  доказательств того, что такое должно было бы произойти, а такого не произошло. Противоречие.
[23:15.360 --> 23:31.920]  Вот. Поэтому в какой бы вы момент не посмотрели на ваш граф, у вас вообще никогда не найдется
[23:31.920 --> 23:36.800]  такого момента, при котором у вас из черной вершины есть серебро в белую вершину. Понятно?
[23:36.800 --> 23:49.720]  Ну и давайте в качестве упражнения оставлю следующее. Показать, что любая другая ситуация возможна.
[24:01.720 --> 24:05.720]  То есть единственная запретная конфигурация это вот это. А все остальные возможности, то есть из
[24:06.140 --> 24:18.500]  черной вершины может быть серое. Из черной вершины может быть следующее. Вот. А вот упражнение.
[24:18.500 --> 24:28.480]  Так. На какой доске лучше перейти? Что лучше оставить, это или это? Давайте левое вставим.
[24:28.480 --> 24:38.480]  Так, ну и, наконец, теорема, которая, на самом деле, лемма.
[24:38.480 --> 24:46.480]  Лемма о белых путях.
[24:46.480 --> 24:58.480]  Что она утверждает? На самом деле, она утверждает следующее.
[24:58.480 --> 25:12.480]  Вершина У является потомком.
[25:12.480 --> 25:24.480]  Вершины В. Сейчас объясню, что это такое.
[25:24.480 --> 25:44.480]  Тогда и только тогда, когда существует путь из вершины В в вершину У,
[25:44.480 --> 26:04.480]  состоящий только из белых вершин.
[26:04.480 --> 26:18.480]  Давайте допишем момент вызова DFS-визит.
[26:18.480 --> 26:22.480]  Что значит, что вершина У является потомком вершины В?
[26:22.480 --> 26:28.480]  Это будет означать, что вершина У была посещена в процессе обработки вершины В.
[26:28.480 --> 26:32.480]  То есть, из вершины В я нашел путь до вершины У.
[26:32.480 --> 26:36.480]  Вот эта вершина является потомком вот этой вершины.
[26:36.480 --> 26:40.480]  Эта же вершина является потомком этой вершины и этой вершины.
[26:40.480 --> 26:44.480]  Потому что она была найдена в процессе обхода вот из этих вершин.
[26:44.480 --> 26:48.480]  Но при этом вот эта вершина не является потомком вот этой вершины.
[26:48.480 --> 26:52.480]  Потому что в процессе обработки этой вершины я до этой вершины не добрался.
[26:52.480 --> 26:56.480]  Ну и наоборот, в процессе обработки этой вершины до этой вершины я не добирался.
[26:57.480 --> 27:01.480]  То есть, является потомком, если можно построить вот такую вот последовательность вызовов,
[27:01.480 --> 27:05.480]  которая привела меня из В в вершину У.
[27:05.480 --> 27:06.480]  Понятно?
[27:06.480 --> 27:10.480]  И вот утверждается, что вот такое происходит в том и только в том случае,
[27:10.480 --> 27:14.480]  если вот когда я вызывал DFS-в, вот если в этот момент у меня существовал путь,
[27:14.480 --> 27:19.480]  состоящий из белых вершин, то это значит, обязательно из вершины В я попаду в вершину У.
[27:19.480 --> 27:21.480]  Вот обязательно, как ни крути.
[27:21.480 --> 27:22.480]  Понятно?
[27:22.480 --> 27:26.480]  Вот если белый путь существовал, то в процессе вызова DFS-в я обязательно попаду в У.
[27:27.480 --> 27:29.480]  Давайте это докажем.
[27:37.480 --> 27:39.480]  Так, ну в одну сторону просто.
[27:39.480 --> 27:41.480]  Вот сюда.
[27:45.480 --> 27:48.480]  Ну почему это просто? Потому что просто рассмотрим.
[27:53.480 --> 28:00.480]  Последовательность вызовов DFS-в,
[28:05.480 --> 28:12.480]  которая привела из В в У.
[28:13.480 --> 28:15.480]  То есть, как у меня все происходило?
[28:15.480 --> 28:17.480]  Сначала я вызвал DFS-в.
[28:17.480 --> 28:19.480]  По условию теоремы, да, я вызвал DFS-в.
[28:19.480 --> 28:24.480]  Дальше я пришел в какую-то другую вершину DFS от В'.
[28:24.480 --> 28:27.480]  Далее я перешел еще в какие-то вершины и так далее.
[28:27.480 --> 28:30.480]  И в какой-то момент, ну то есть вот первое условие, да, что говорит?
[28:30.480 --> 28:33.480]  Первое условие говорит, что в какой-то момент в процессе вот таких вот рекустированных вызовов
[28:33.480 --> 28:35.480]  я дошел до вершины У. Согласны?
[28:36.480 --> 28:38.480]  DFS от У.
[28:39.480 --> 28:41.480]  Так.
[28:41.480 --> 28:46.480]  А как у меня могло получиться так, что я вызвал DFS-в, потом вызвал DFS-в' и так далее?
[28:46.480 --> 28:48.480]  Вот от каких вершин я вызываю DFS-ы?
[28:48.480 --> 28:50.480]  Только от белых.
[28:53.480 --> 28:57.480]  Вот, то есть рекурсивный вызов DFS-в, видите, у меня происходит только в том случае, если я вижу белую вершину.
[28:57.480 --> 28:59.480]  Да?
[29:00.480 --> 29:03.480]  Ну все, следовательно, вот этот путь был белым.
[29:04.480 --> 29:05.480]  Окей?
[29:05.480 --> 29:09.480]  То есть вот это была белая вершина, вот это была белая вершина, вот тут были белые вершины, вот тут.
[29:12.480 --> 29:15.480]  Все, то есть существует путь состоящий только из белых вершин?
[29:15.480 --> 29:17.480]  Да, вот он, я его предоставил.
[29:17.480 --> 29:18.480]  Угу.
[29:29.480 --> 29:32.480]  Так, давайте продолжим здесь, в обратную сторону.
[29:36.480 --> 29:43.480]  Почему из того факта, что в момент вызова DFS от В, что если существовал путь из В в У, который состоит только из белых вершин,
[29:43.480 --> 29:47.480]  почему из этого факта сразу следует, что я вершину У обязательно посещу?
[29:47.480 --> 29:49.480]  То есть вершина У является потомком вершины В.
[29:49.480 --> 29:52.480]  Ну смотрите, давайте рассмотрим этот самый путь.
[29:53.480 --> 29:55.480]  Рассмотрим белый путь.
[29:59.480 --> 30:08.480]  Ну вот, какой-то там В, дальше идет В1, В2 и так далее.
[30:09.480 --> 30:11.480]  В итоге все пришло в У.
[30:13.480 --> 30:18.480]  Вот это то, что было в самый начальный момент времени, согласны?
[30:18.480 --> 30:23.480]  То есть я только пришел в вершину В, я покрасила в серый цвет, ну и теперь там запускаю какие-то DFS.
[30:24.480 --> 30:30.480]  По предположению второй части у меня есть белый путь, который приводит меня в У.
[30:31.480 --> 30:33.480]  Теперь давайте рассмотрим момент.
[30:33.480 --> 30:36.480]  Ну момент, когда В почернела.
[30:40.480 --> 30:42.480]  То есть есть вершина В, которая черная.
[30:43.480 --> 30:46.480]  И есть последовательность вершин.
[30:48.480 --> 30:50.480]  В1, В2 и так далее У.
[30:51.480 --> 30:55.480]  Ну пока с неизвестными, пока с неизвестными вершинами.
[30:55.480 --> 30:57.480]  Ну давайте порассуждаем, какие у них могут быть цвета.
[30:58.480 --> 31:00.480]  Ну смотрите, первый простой вопрос.
[31:00.480 --> 31:02.480]  Точнее, оба вопроса будут простыми.
[31:03.480 --> 31:07.480]  Вот может ли на этом пути где-то оказаться серая вершина?
[31:08.480 --> 31:11.480]  Вот здесь было так, а в момент завершения у меня тут серая вершина.
[31:12.480 --> 31:14.480]  Почему нет?
[31:16.480 --> 31:20.480]  Вот здесь была так, а в момент завершения у меня тут серая вершина.
[31:21.480 --> 31:23.480]  Почему нет?
[31:26.480 --> 31:31.480]  Да, об этом мы говорили минут 10-15 назад, в самом начале.
[31:32.480 --> 31:41.480]  То есть если я запустил вызов DFS от В, то она почернеет только в тот момент, когда все рекурсивные вызовы, которые она породила, завершатся.
[31:42.480 --> 31:44.480]  Ну а такая конфигурация что означает?
[31:45.480 --> 31:50.480]  Это означает, что я запустил DFS от В, завершил DFS от В, и в итоге у меня появился какой-то рекурсивный вызов, который еще не завершился.
[31:51.480 --> 31:53.480]  Но это же бред, не может быть такого.
[31:53.480 --> 32:01.480]  То есть если я запустил DFS от В, то я обязательно дождусь, пока у меня все рекурсивные вызовы, которые возможны завершаться, и только в этот момент я сам стану черным.
[32:02.480 --> 32:06.480]  Вот поэтому здесь, если раньше тут были белые вершины, то серых тут появиться не могло.
[32:07.480 --> 32:18.480]  Окей, разобрались. Давайте напишем, что серых вершин не появилось.
[32:18.480 --> 32:32.480]  Ну и второе утверждение. А могло ли получиться так, что здесь остались белые вершины?
[32:33.480 --> 32:35.480]  Почему нет?
[32:36.480 --> 32:43.480]  Да, давайте рассмотрим первую вершину, которая, по предположению, если тут нет серых вершин, значит тут все вершины либо белые, либо черные.
[32:43.480 --> 32:47.480]  Вот давайте на этом пути рассмотрим первую вершину, которая осталась белой, по какой-то причине.
[32:51.480 --> 32:53.480]  Вот, допустим, вот эта вершина осталась белой.
[32:54.480 --> 32:56.480]  Но что мы видим?
[32:57.480 --> 32:59.480]  Что мы тогда видим?
[33:00.480 --> 33:02.480]  Мы видим ребро, которое ведет из черной вершины в белую.
[33:03.480 --> 33:06.480]  Ну подождите. Такого же быть не может.
[33:10.480 --> 33:12.480]  Ну все.
[33:13.480 --> 33:15.480]  Давайте запишем.
[33:16.480 --> 33:18.480]  Серых вершин не появилось.
[33:19.480 --> 33:39.480]  Если осталось хотя бы одна белая, то нашли ребро, которое ведет из черной вершины в белую.
[33:39.480 --> 33:44.480]  Ну как нашли? Если тут есть хотя бы одна белая, то значит, вот есть какой-то префикс черный, и дальше он ведет вот в эту белую вершину.
[33:45.480 --> 33:47.480]  Ну а такого быть не может.
[33:48.480 --> 33:55.480]  Но по утверждению такого быть не может.
[34:00.480 --> 34:02.480]  Ну вот, то есть здесь серых нет?
[34:03.480 --> 34:05.480]  Во-первых, тут нет серых, во-вторых, тут нет белых.
[34:06.480 --> 34:08.480]  Ну следует, все вершины черные.
[34:09.480 --> 34:14.480]  Это означает, что в процессе посещения вершины ВМ мы посетили все вот эти вершины.
[34:15.480 --> 34:17.480]  В частности, посетили вершину УП.
[34:18.480 --> 34:20.480]  Ну все, из этого следует.
[34:21.480 --> 34:29.480]  Вершина УП черная, а значит посещенная.
[34:39.480 --> 34:41.480]  Есть вопрос по доказательству?
[34:44.480 --> 34:46.480]  Все ли понимают смысл того, что мы сейчас сделали?
[34:47.480 --> 34:49.480]  Не, смысл того, что мы сейчас доказали.
[34:50.480 --> 35:00.480]  Все ли понимают, что из этой теории следует тот факт, что если я запускаю DFS от какой-либо вершины, то я обязательно посещу все те вершины, до которых я могу из нее дотянуться.
[35:01.480 --> 35:04.480]  Ну потому что изначально у меня все вершины в графе белые.
[35:04.480 --> 35:14.480]  Если я стартую с какой-либо вершины, ну вот этой, например, то все вершины, до которых я могу дотянуться, в принципе, вот до всех вершин, до которых я могу дотянуться, у меня существует белый пункт.
[35:14.480 --> 35:20.480]  Но до этой вершины существует белый путь, до этой, до этой, до этой, до этого не существует.
[35:21.480 --> 35:26.480]  Ну и теорема как раз нам говорит, что вот те вершины, до которых я могу дотянуться, у меня существует белый путь.
[35:27.480 --> 35:32.480]  Ну и теорема как раз нам говорит, что вот те вершины, до которых я могу дотянуться, у меня существует белый путь.
[35:33.480 --> 35:39.480]  Ну и теорема как раз нам говорит, что вот те вершины, до которых я могу дотянуться, у меня существует белый путь.
[35:40.480 --> 35:45.480]  Ну и теорема как раз нам говорит, что вот те вершины, до которых я могу дотянуться, до всех них существует белый путь.
[35:46.480 --> 35:48.480]  А это значит, что до всех них я обязательно дойду, все они в итоге почернеют.
[35:49.480 --> 35:50.480]  Ну кроме вот этой вершины.
[35:51.480 --> 35:53.480]  Потому что до нее нет белого пути.
[35:54.480 --> 35:55.480]  Согласна.
[35:56.480 --> 35:57.480]  Ну вот.
[36:02.480 --> 36:03.480]  Окей.
[36:09.480 --> 36:11.480]  Данная вершина в том, что ДВУ тоже есть.
[36:12.480 --> 36:19.480]  Да, то есть если в процессе вызова ДВПС от В, мы посетили вершину У, то вершина У является потомком вершины В.
[36:20.480 --> 36:26.480]  Да, но естественно симметрично. Ну то есть как и все в, как в неориентированном графе.
[36:26.480 --> 36:33.660]  Причем если мы посетили вершину U, то вершина U является потомком вершины V
[36:34.160 --> 36:38.980]  Да, но естественно симметрично. Как и всё в неориетеранную графику
[36:42.020 --> 36:44.880]  То есть отношение быть потомком естественно симметрично
[36:44.960 --> 36:47.440]  То есть если U потомок V, то это не значит, что V потомок U
[36:48.760 --> 36:50.540]  Давайте тут пример..
[36:50.540 --> 36:55.260]  Если вы можете добраться до вершины U, то это потому, что вы можете добраться до вершины V
[36:56.480 --> 37:20.240]  Да. А в чем я соврал? Я не вру. Отлично. Ну, в смысле, из вершины, в процессе
[37:20.240 --> 37:23.280]  обхода DFS, естественно, я В больше никогда не посещу. То есть, если я из нее вступовал,
[37:23.280 --> 37:26.320]  естественно, я ее никогда не посещу. Тут вопрос в другом, что могу ли я в
[37:26.320 --> 37:31.120]  принципе как-то из вершины У посетить В. Ну, не всегда. Вот. То есть, если из вершины В
[37:31.120 --> 37:34.640]  я как-то могу добраться до У, то это не факт, что при запуске DFS от У я как-то
[37:34.640 --> 37:41.120]  смогу добраться до В. Например, такой. В таком случае. Если тут треугольник, то
[37:41.120 --> 37:46.200]  неважно, из какой вершины вы запуститесь, вы доберетесь до любой другой.
[37:46.200 --> 37:58.080]  Да. Как посетить? Отношение потомства имеет смысл только при
[37:58.080 --> 38:02.280]  разговоре алгоритма DFS. То есть, это не свойство графа. Отношение потомства
[38:02.280 --> 38:06.360]  имеет смысл, да, только для так называемых графов деревьев. Вот. И в некотором смысле,
[38:06.360 --> 38:09.520]  ну давайте к этому тогда перейдем, раз я хотел с другого начать, ну давайте к
[38:09.520 --> 38:15.640]  этому сразу перейдем. Вот. Обход DFS, он на самом деле в процессе своей работы
[38:15.640 --> 38:21.600]  строит некоторое дерево. Но что такое дерево? Давайте кончим. Давайте я введу
[38:21.600 --> 38:30.320]  определение. Дерево. Давайте в ор-графе.
[38:30.320 --> 38:57.560]  Это граф. Давайте закончим определение и, ну, первое, пойдем. Это граф, в котором две вершины, кроме одной,
[39:01.320 --> 39:03.320]  имеют
[39:06.320 --> 39:19.320]  степень захода равна единице. Все вершины, кроме одной, имеют степень захода равна
[39:19.320 --> 39:28.320]  единице. А у оставшейся, ну, то есть, вот у этой, а у оставшейся
[39:30.320 --> 39:40.320]  степень захода равна 0. Ну, что такое степень захода? Это количество вершин, которые
[39:40.320 --> 39:56.320]  входят в нее. Давайте пример дерева. Что еще раз? Хорошо. Не ошибайтесь. Вот. Это дерево в
[39:56.320 --> 40:03.320]  ориентированном графе. Смотрите, у всех вершин вот у этой, у этой, у этой, у этой, у этой, у этой, у этой
[40:03.320 --> 40:07.320]  степень захода равна 1. То есть, в них сходит ровно одно ребро. Но при этом существует
[40:07.320 --> 40:12.320]  одна выделенная вершина, в которую не входит ни одно ребро. Вот эта вершина называется корнем.
[40:12.320 --> 40:28.320]  Корнем дерева. Вот. Ну, давайте перерыв и после перерыва поговорим, что за дерево строит нам
[40:28.320 --> 40:40.320]  ДФС. Продолжаем. Значит, мы ввели понятие дерева в ориентированном графе. Ну, давайте для полноты введем
[40:40.320 --> 40:46.320]  понятие дерева в неориентированном графе, чтобы было, значит, оно там, там определение проще. Дерево
[40:46.320 --> 40:58.320]  в неориентированном графе. На самом деле, у них куча определений там, в общем, но одно из самых простых
[40:58.320 --> 41:18.320]  это связанный граф без циклов. Связанный граф без циклов. Ну, или связанный граф, в котором v-1
[41:18.320 --> 41:22.320]  ребро, в общем, куча эквивалентных определений. Вот пусть такое будет. Меня сейчас будет
[41:22.320 --> 41:27.320]  интересовать именно дерево с точки зрения ориентированного графа. Потому что, смотрите, вот
[41:27.320 --> 41:32.320]  я утверждаю, что ДФС в процессе своей работы, ну, ДФС в процессе вызова от какой-либо вершины
[41:32.320 --> 41:39.320]  строит некоторое дерево. Строит некоторое дерево. Почему? Значит, какие ребра у меня будут в этом
[41:39.320 --> 41:47.320]  дереве? Значит, ребром дерева я буду называть то ребро, то ребро, по которому я нахожу новую вершину.
[41:47.320 --> 41:52.320]  Ну, давайте посмотрим здесь. Допустим, я запустил ДФС вот от этой вершины. Что у меня в итоге
[41:52.320 --> 41:58.320]  происходит? Я перехожу в какую-то вершину в каком-то соседе. Ну, допустим, вот в этого соседа.
[41:58.320 --> 42:05.320]  Плесую ребро. Дальше из этой вершины я перехожу в какую-то другую вершину. Ну, единственная вершина
[42:05.320 --> 42:11.320]  вот эта. Обозначаю ребро. Из этой вершины я никуда пробраться не могу. Поэтому, завершая над ней
[42:11.320 --> 42:17.320]  работу, отсюда снова никуда не могу попасть. Завершаю работу. Отсюда могу попасть вот в эту вершину.
[42:17.320 --> 42:27.320]  Из этой вершины могу попасть в эту вершину. Ну, и на этом все. И вот если присмотреться, то можно
[42:27.320 --> 42:32.320]  понять, что можно увидеть, по крайней мере, вот на этой картинке, что те вершины, до которых я
[42:32.320 --> 42:38.320]  дошел, плюс те ребра, по которым я их находил, образуют дерево. Ну, вот у этой вершины степень
[42:38.320 --> 42:44.320]  захода 0, и у каждой из этих вершин степень захода 1. Что за деревом устроим? Вот та вершина,
[42:44.320 --> 42:49.320]  с которой мы изначально запускаем DFS Visit, это будет корень дерева, потому что у нее степень захода 0.
[42:49.320 --> 42:53.320]  Ни с какой другой вершины мы в эту же вершину не придем, потому что она уже изначально серая.
[42:53.320 --> 42:59.320]  Согласны? Вот. А почему у каждой другой вершины, до которой я дотянулся, у меня будет степень захода
[42:59.320 --> 43:05.320]  равна 1? Потому что каждую вершину я посещаю ровно один раз. То есть я ее посещаю, и она тут же
[43:05.320 --> 43:10.320]  становится серой. То есть никакого другого ребра в нее привести не может. Ну, точнее привести может,
[43:10.320 --> 43:16.320]  но вот по этому ребру я уже никогда не пройдусь. Согласны? Поэтому у каждой другой вершины степень захода
[43:16.320 --> 43:21.320]  равна 1. Вот ровно поэтому DFS образует дерево отхода глубину.
[43:46.320 --> 44:10.320]  Ну, смотрите, вот у нас есть граф. Вот у нас есть граф. Какие-то вершины я взял и пометил красным цветом.
[44:10.320 --> 44:15.320]  То есть сказал, что это ребра дерева. Ребра дерева, обходы в глубину. Но у меня же есть еще куча
[44:15.320 --> 44:22.320]  ребер, которые я еще никак не пометил. Вот давайте попробуем вести некоторую классификацию на ребрах.
[44:22.320 --> 44:29.320]  То есть попробуем взять и каждое ребро отнести некоторому классу.
[44:30.320 --> 44:41.320]  Классификация ребер.
[44:41.320 --> 44:53.320]  Ну, первый тип ребер мы уже обсудили, это ребра дерева. Во, отлично. Мы же асимптотику опять не обсудили.
[44:53.320 --> 45:01.320]  Да, за сколько это все добро работает? Ну, давайте проанализируем. Вот я запустил DFSVisit от какой-либо вершины.
[45:01.320 --> 45:09.320]  И что в итоге у меня произойдет? Ну, смотрите, каждую вершину, то есть от каждой вершины DFSVisit я запущу ровно один раз.
[45:09.320 --> 45:16.320]  Ну, не ровно один раз, а максимум один раз. То есть не более одного раз я запущу DFSVisit от каждой вершины.
[45:16.320 --> 45:22.320]  То есть что это такое? Это у большой от В, уже как минимум.
[45:22.320 --> 45:28.320]  Когда я вызываю DFSVisit от какой-либо вершины, что происходит? Да, я беру и перебираю все их ребра.
[45:28.320 --> 45:33.320]  Ну, то есть вот это стоит константное время, то есть все входит в единицу. Это тоже константное время единица.
[45:33.320 --> 45:38.320]  А вот самая долгая операция – это вот этот вот цикл. То есть мы перебираем всех соседей.
[45:38.320 --> 45:44.320]  За какое время мы перебираем всех соседей? Ну, на самом деле зависит от представления графа.
[45:44.320 --> 45:55.320]  Если это матрица смежности, то всех соседей мы переберем за V. То есть для каждой вершины V мы переберем V чисел.
[45:55.320 --> 46:01.320]  Вроде как V квадрат. Но если мы используем списки смежности, то за сколько мы получаем список соседей?
[46:01.320 --> 46:05.320]  За степень вершины. То есть мы, точнее, перебираем всех соседей за степень вершины.
[46:05.320 --> 46:12.320]  Если мы просумируем все степени вершин, то что мы получим? Ну, число ребер. Ну, или удвоенное число ребер в зависимости от…
[46:12.320 --> 46:14.320]  Давайте E напишем.
[46:17.320 --> 46:22.320]  Соответственно, в зависимости от того, какое представление графа вы используете, вы получите либо V квадрат, либо V плюс E.
[46:22.320 --> 46:26.320]  То есть ровно такая же асимптотика, как была в случае обходов в ширину.
[46:28.320 --> 46:31.320]  Окей. Возвращаемся сюда.
[46:32.320 --> 46:39.320]  Как говорим про классификацию ребер. Ножки и ребра у нас смогут быть в графе с точки зрения обходов в глубину.
[46:40.320 --> 46:43.320]  Допустим, запускаем DFS отсюда.
[46:44.320 --> 46:46.320]  Значит, у нас есть ребра дерева.
[46:49.320 --> 47:06.320]  Значит, это те ребра, по которым находим новые вершины.
[47:10.320 --> 47:12.320]  Давайте будем их ознать черным цветом.
[47:13.320 --> 47:15.320]  Ну, допустим, я стартую из этой вершины.
[47:17.320 --> 47:21.320]  Давайте попробуем соорудить какую-нибудь обход в глубину.
[47:21.320 --> 47:25.320]  Ну, допустим, я стартую с этой вершины, и первым делом прохожусь вот по этому ребру.
[47:29.320 --> 47:32.320]  Прошелся по этому ребру, отсюда я никуда не могу пойти.
[47:32.320 --> 47:33.320]  Возвращаюсь обратно.
[47:33.320 --> 47:38.320]  Дальше я иду вот в эту вершину.
[47:38.320 --> 47:40.320]  Дальше из этой вершины иду в эту вершину.
[47:43.320 --> 47:45.320]  Из этой вершины никуда не могу пойти.
[47:45.320 --> 47:48.320]  Возвращаюсь обратно и иду вот в эту вершину.
[47:51.320 --> 47:53.320]  Жирным цветом он означал ребра дерева.
[47:54.320 --> 47:57.320]  То есть это как раз те ребра, по которым у меня DFS проходил.
[47:57.320 --> 47:59.320]  Сначала я пошел сюда, потом сюда, сюда и сюда.
[48:00.320 --> 48:01.320]  Вот такое дерево.
[48:02.320 --> 48:04.320]  Так, какие у меня еще есть ребра?
[48:08.320 --> 48:12.320]  Так, давайте вот тут вот я направление поменяю.
[48:19.320 --> 48:21.320]  У меня еще вот такое ребро есть.
[48:22.320 --> 48:24.320]  Так, бывают обратные ребра.
[48:24.320 --> 48:42.320]  Это ребра, которые ведут предков.
[48:49.320 --> 48:50.320]  Какой ребро?
[48:54.320 --> 49:04.320]  Давайте я их лучше пронумерую.
[49:06.320 --> 49:07.320]  Так, из какой в какую?
[49:11.320 --> 49:12.320]  Очень просто.
[49:12.320 --> 49:13.320]  Вот я запустил DFS от нуля.
[49:13.320 --> 49:16.320]  У меня же порядок ребра вообще не гарантирован.
[49:16.320 --> 49:18.320]  Но сначала я пошел в первую вершину.
[49:18.320 --> 49:19.320]  И вернулся в эту вершину.
[49:19.320 --> 49:21.320]  А дальше я просто-напросто пошел во вторую вершину.
[49:22.320 --> 49:25.320]  То есть я мог пойти по этой вершине, но алгоритм выбрал по этой.
[49:28.320 --> 49:29.320]  Так, обратные ребра.
[49:29.320 --> 49:32.320]  Обратные ребра это ребра, которые ведут предков.
[49:35.320 --> 49:36.320]  От потомков.
[49:42.320 --> 49:43.320]  Вот давайте здесь.
[49:43.320 --> 49:44.320]  Где здесь есть обратные ребра?
[49:44.320 --> 49:45.320]  И есть ли они вообще?
[49:47.320 --> 49:48.320]  3.0.
[49:48.320 --> 49:49.320]  Понятно почему 3.0 это обратное ребро.
[49:49.320 --> 49:51.320]  Потому что 0 это предок вершины 3.
[49:51.320 --> 49:52.320]  Ну вот в дереве.
[49:52.320 --> 49:55.320]  Вот в дереве на самом деле очень понятно, где потомок,
[49:55.320 --> 49:56.320]  где предок.
[49:56.320 --> 49:58.320]  То есть если так смотреть по уровням.
[49:58.320 --> 50:00.320]  То есть 0 предок вообще всех вершин.
[50:00.320 --> 50:01.320]  2 это предок тройки и четверки.
[50:01.320 --> 50:03.320]  Соответственно четверка это потомок двойки и нуля.
[50:03.320 --> 50:06.320]  И вот ребро, которое ведет из 3 в 0, это ребро, которое
[50:06.320 --> 50:08.320]  ведет из потомков предка.
[50:08.320 --> 50:11.320]  Поэтому 3.0 это обратное ребро.
[50:11.320 --> 50:16.320]  Давайте его будем зеленым цветом означать.
[50:16.320 --> 50:17.320]  Обратное ребро.
[50:18.320 --> 50:20.320]  Есть ли здесь еще какие-то обратные ребра?
[50:22.320 --> 50:25.320]  Ну нет, вот это ребро, вот эта вершина 0 не является
[50:25.320 --> 50:27.320]  потомком вершины 4.
[50:27.320 --> 50:30.320]  Ровно как и вершина 1, точнее вершина 4 не является
[50:30.320 --> 50:32.320]  потомком вершины 1.
[50:32.320 --> 50:35.320]  Они вообще как бы не связаны родством прямым.
[50:38.320 --> 50:39.320]  Так, следующий пункт.
[50:39.320 --> 50:42.320]  Вот это ребро, которое ведет из 3 в 0.
[50:42.320 --> 50:44.320]  Так, следующий пункт.
[50:44.320 --> 50:46.320]  Нет, давайте еще разберем.
[50:46.320 --> 50:48.320]  А как вообще определить, какое ребро обратное?
[50:48.320 --> 50:50.320]  Ну то есть, где ребро дерева, я думаю понятно.
[50:50.320 --> 50:52.320]  То есть, если вы встретили белую вершину, перешли
[50:52.320 --> 50:54.320]  в нее, то вы перешли, значит, по ребру дерева.
[50:54.320 --> 50:57.320]  А может ли как-то в процессе обхода DFS, то есть мы же вроде
[50:57.320 --> 50:59.320]  как сказали, что DFS обходит все ребра.
[50:59.320 --> 51:01.320]  То есть он в итоге перебирает все ребра.
[51:01.320 --> 51:04.320]  Может ли как-то по виду ребра понять, что оно обратное
[51:04.320 --> 51:06.320]  вот в процессе обхода DFS?
[51:08.320 --> 51:09.320]  Серую.
[51:09.320 --> 51:10.320]  Всем понятно почему?
[51:10.320 --> 51:12.320]  Все понятно почему, если ребро ведет в серую его вершину,
[51:13.320 --> 51:14.320]  это обратное ребро.
[51:15.320 --> 51:17.320]  Потому что если эта вершина серая, то я в итоге
[51:17.320 --> 51:19.320]  из этой вершины встречаю серую вершину.
[51:19.320 --> 51:23.320]  То есть в данный момент, у меня запущен DFS вот этой
[51:23.320 --> 51:27.320]  вершины, то есть я ищу путь из этой вершины.
[51:27.320 --> 51:29.320]  То есть я искал путь и в какой-то момент вернулся обратно.
[51:30.320 --> 51:31.320]  То есть, из этой вершины я нашел своего потомка,
[51:33.320 --> 51:35.320]  а из потомка нашел серую вершину, laughter.
[51:35.320 --> 51:37.320]  которая на самом деле является ее предком
[51:37.320 --> 51:54.560]  то есть это обратные ребра ведут в серые вершины.
[51:54.560 --> 51:55.880]  Обратное ребро в черную вести не может.
[51:55.880 --> 52:00.680]  Ну вот почему?
[52:00.680 --> 52:03.040]  Ну давайте, допустим, я нашел ребро, которое ведет
[52:03.040 --> 52:04.040]  в черную вершину.
[52:04.040 --> 52:05.040]  Ну что это значит?
[52:05.040 --> 52:09.720]  Это значит, что я когда-то запускал поиск из этой вершины,
[52:09.720 --> 52:12.240]  вот из этой вершины я когда-то запускал DFSVisit, но при этом
[52:12.240 --> 52:13.520]  вот эту вершину не обнаружил.
[52:13.520 --> 52:17.080]  Следовательно, вот эта вершина не является потомком для
[52:17.080 --> 52:18.080]  этой вершины.
[52:18.080 --> 52:20.320]  Следовательно, по определению, это не обратное ребро.
[52:20.320 --> 52:21.320]  Окей?
[52:21.320 --> 52:23.920]  Такого быть не может.
[52:23.920 --> 52:29.960]  Так, следующие ребра это прямые ребра, да, прямое
[52:29.960 --> 52:32.960]  ребро.
[52:32.960 --> 52:40.280]  Это ребро, которое ведет себя наоборот.
[52:40.280 --> 52:56.200]  Оно наоборот ведет из предков потомков, но при этом не
[52:56.200 --> 52:57.200]  является ребром дерева.
[52:57.200 --> 53:13.440]  Вот, то есть ребро ведет из предков потомков, но при
[53:13.440 --> 53:15.440]  этом это такое ребро, которое ребром дерева само по себе
[53:15.440 --> 53:16.440]  не является.
[53:16.440 --> 53:20.160]  Вот какие здесь ребра являются прямыми ребрами в смысле
[53:20.160 --> 53:21.160]  вот этого определения.
[53:21.160 --> 53:24.320]  Ребро 0,4, да, все понимают.
[53:24.320 --> 53:27.080]  0,4 ведет действительно из предков потомка.
[53:27.080 --> 53:30.040]  То есть вот 0,2,4, 4 является потомком вершины 0.
[53:30.040 --> 53:32.280]  Но при этом вот это, это не ребро дерева, мы по нему
[53:32.280 --> 53:33.760]  никогда во время алгоритма не проходили.
[53:33.760 --> 53:43.120]  Да, окей, так, пусть прямые ребра будут красными.
[53:43.120 --> 53:49.840]  Вот это прямое ребро.
[53:49.840 --> 53:51.960]  Ребро 4,1 является прямым или нет?
[53:51.960 --> 53:52.960]  Нет.
[53:53.600 --> 53:57.640]  0,4, то есть 1 не является потомком вершины 0,4.
[53:57.640 --> 54:05.440]  Так, ну и последний пункт, последний тип ребр.
[54:05.440 --> 54:10.440]  Перекрестные ребра.
[54:10.440 --> 54:21.440]  Так, перекрестные ребра.
[54:21.920 --> 54:26.920]  Я могу написать все остальные, это будет правда в целом.
[54:26.920 --> 54:29.160]  Вот, можно написать все остальные, а можно написать
[54:29.160 --> 54:36.880]  эти ребра, которые ведут в различные под, как правильно
[54:36.880 --> 54:42.640]  сказать, в несвязанные под деревья, да, ну то есть
[54:42.640 --> 54:50.640]  в разные под деревья, давайте так, разные под деревья.
[54:50.840 --> 54:53.840]  Деревья, ну или все остальные.
[54:59.840 --> 55:03.840]  Ну вот что это означает?
[55:03.840 --> 55:05.840]  Что это означает?
[55:05.840 --> 55:08.840]  Ну смотрите, так или иначе все ребра, которые мы рассматривали,
[55:08.840 --> 55:10.840]  они активировали таким отношением, как родство.
[55:10.840 --> 55:14.640]  Да, то есть ребра дерева, они ведут из предков в непосредственных
[55:14.640 --> 55:15.640]  потомков.
[55:15.640 --> 55:18.240]  Обратные ребра ведут из потомков в предков, прямые
[55:18.240 --> 55:20.240]  ребра ведут из предков потомков.
[55:20.240 --> 55:23.040]  А вот перекрестные ребра, это те ребра, которые не
[55:23.040 --> 55:26.240]  связывают между собой непосредственных родственников, так скажем.
[55:26.240 --> 55:29.240]  Например, ребро 4,1.
[55:29.240 --> 55:34.240]  Да, то есть неверно, что 1 это 4, это потомок единицы,
[55:34.240 --> 55:36.240]  ровно как неверно, что наоборот.
[55:36.240 --> 55:39.240]  То есть ни 4 не является потомком единицы, ни 1 не является
[55:39.240 --> 55:40.240]  потомком четверки.
[55:40.240 --> 55:44.240]  Вот, то есть у меня есть вот это поддерево и отдельное
[55:44.240 --> 55:46.240]  поддерево, которое состоит из единицы.
[55:46.240 --> 55:49.240]  Ребро из одного поддерева, которое не связано с другим.
[55:49.240 --> 55:51.240]  Из одного поддерева в другое поддерево.
[55:52.240 --> 55:53.240]  Вот.
[55:58.240 --> 55:59.240]  Что еще можно сказать?
[56:04.240 --> 56:07.240]  Ну, наверное, на этом классификация закончена.
[56:10.240 --> 56:12.240]  Ребра дерева, по которым ведут новые вершины.
[56:12.240 --> 56:15.240]  Да, давайте напишем критерий для каждого типа ребер.
[56:17.240 --> 56:21.240]  Ребра дерева ведут
[56:26.240 --> 56:27.240]  белые
[56:30.240 --> 56:31.240]  вершины.
[56:31.240 --> 56:33.240]  Обратные ребра ведут в серые вершины.
[56:33.240 --> 56:36.240]  Прямые и перекрестные ребра ведут себя в черные вершины.
[56:41.240 --> 56:42.240]  Ведут
[56:43.240 --> 56:45.240]  в черные вершины.
[56:46.240 --> 56:49.240]  А можно ли как-то, скажем так, различить ситуацию,
[56:49.240 --> 56:52.240]  при которой у меня есть перекрестные ребра и прямые ребра?
[56:52.240 --> 56:54.240]  Вот как отличить между собой прямое и перекрестное ребро,
[56:54.240 --> 56:56.240]  если в нем ведут в черные вершины?
[56:59.240 --> 57:01.240]  Да, у нас есть еще дополнительная информация в виде таймов,
[57:01.240 --> 57:02.240]  в виде времен.
[57:02.240 --> 57:05.240]  Вот оказывается, ну, вот можете, давайте тоже в качестве упражнения.
[57:05.240 --> 57:08.240]  Вот оказывается, что прямое ребро это такое ребро,
[57:08.240 --> 57:11.240]  вот ребро, давайте, ВУ.
[57:12.240 --> 57:15.240]  Значит, ребро ВУ прямое, если
[57:18.240 --> 57:24.240]  таймин от В меньше, чем таймин от У.
[57:27.240 --> 57:29.240]  Ну а в этом случае, в случае перекрестных ребер наоборот.
[57:33.240 --> 57:39.240]  Таймин от В наоборот больше, чем таймин от У.
[57:43.240 --> 57:44.240]  Да.
[57:48.240 --> 57:49.240]  Где симметрично?
[57:50.240 --> 57:51.240]  Из В в У.
[57:52.240 --> 57:55.240]  Ну это упорядоченная пара, поэтому...
[58:02.240 --> 58:03.240]  Окей.
[58:05.240 --> 58:07.240]  Ну вот, это нам впоследствии пригодится,
[58:07.240 --> 58:10.240]  все вот эти классификации ребер
[58:10.240 --> 58:12.240]  в какой-то момент они выстрелят.
[58:12.240 --> 58:14.240]  Вот пока просто определение.
[58:17.240 --> 58:21.240]  Ну и давайте, наверное, к более интересной, к более практической части
[58:21.240 --> 58:23.240]  поговорим про применение DFS.
[58:24.240 --> 58:26.240]  Говорим про применение DFS.
[58:29.240 --> 58:32.240]  Начну первое очевидное применение, которое мы уже...
[58:32.240 --> 58:34.240]  которое мы уже обсуждали.
[58:34.240 --> 58:36.240]  Это поиск...
[58:36.240 --> 58:38.240]  Компонент связанности
[58:45.240 --> 58:47.240]  в нюрграфах
[58:50.240 --> 58:54.240]  и поиск множества
[58:55.240 --> 58:57.240]  достижимых
[58:57.240 --> 58:58.240]  вершин.
[59:01.240 --> 59:04.240]  Ну понятно, когда мы говорим про неориентированные графы,
[59:04.240 --> 59:06.240]  то все те вершины, до которых мы можем добраться,
[59:06.240 --> 59:08.240]  они на самом деле лежат в той же самой компоненте связанности,
[59:08.240 --> 59:10.240]  что и наша исходная вершина.
[59:13.240 --> 59:15.240]  Потому что если я из этой вершины могу добраться до этой
[59:15.240 --> 59:17.240]  и из этой могу добраться до этой,
[59:17.240 --> 59:19.740]  компонентисвязанности, что и наша исходная вершина.
[59:23.240 --> 59:27.240]  Потому что если я из этой вершины могу добраться до этой, и из этой могу добраться до этой,
[59:27.240 --> 59:28.740]  то значит и наоборот, я могу все сделать.
[59:29.240 --> 59:31.740]  В случае ориентированных графов, естественно, это неправда.
[59:31.740 --> 59:34.240]  Почему здесь замечание про неориентированный граф?
[59:34.240 --> 59:35.240]  Ну, потому что...
[59:35.740 --> 59:36.740]  Давайте вот так.
[59:37.240 --> 59:38.240]  Вот.
[59:40.240 --> 59:42.240]  Из этой вершины я могу добраться до этой вершины.
[59:43.740 --> 59:49.240]  Но при этом отсюда не следует, что из этой вершины я могу добраться и до...
[59:49.740 --> 59:50.740]  В общем, обратно.
[59:53.740 --> 59:56.240]  Вот. То есть я просто-напросто в случае ориентированных графов
[59:56.240 --> 59:57.740]  нахожу множество достижимых вершин.
[59:57.740 --> 01:00:00.240]  То есть все эти вершины, которые достижимы из этой, я найду.
[01:00:00.740 --> 01:00:02.740]  И я могу добраться до этой вершины.
[01:00:02.740 --> 01:00:06.740]  Но при этом, если я дошел до этой вершины, то это не значит, что из этой вершины я дойду до изначальной.
[01:00:08.740 --> 01:00:09.740]  Так.
[01:00:09.740 --> 01:00:10.740]  Первое понятно.
[01:00:10.740 --> 01:00:12.740]  Первое напрямую следует из...
[01:00:12.740 --> 01:00:13.740]  Давайте так. Следует...
[01:00:16.740 --> 01:00:17.740]  Из...
[01:00:18.240 --> 01:00:20.240]  Леммы о белых путях.
[01:00:22.740 --> 01:00:23.740]  Это понятно.
[01:00:23.740 --> 01:00:24.740]  Ну и наконец...
[01:00:25.740 --> 01:00:28.740]  Более содержательное применение — это поиск циклов.
[01:00:32.740 --> 01:00:35.740]  Нет, это не поиск циклов, а проверка от цикличности.
[01:00:35.740 --> 01:00:37.740]  Проверка на цикличность.
[01:00:46.740 --> 01:00:47.740]  Ну, вот.
[01:00:48.240 --> 01:00:49.240]  Проверка на...
[01:00:57.740 --> 01:00:59.740]  Проверка на цикличность.
[01:01:06.740 --> 01:01:07.740]  Ну и наконец...
[01:01:07.740 --> 01:01:37.500]  Теорема критерий ацикличности.
[01:01:37.500 --> 01:02:06.500]  В графе G есть цикл, когда и только тогда, в процессе обхода в глубину обнаружены
[01:02:06.500 --> 01:02:29.500]  обратные ребра, это в любом графе на самом деле, в абсолютно любом. Мы поговорим, какие там приколы
[01:02:29.500 --> 01:02:33.500]  появляются в случае неориентированного графа, но вообще для любого графа это работает.
[01:02:33.500 --> 01:02:47.500]  Так, условия понятна. Почему перекрёстные ребра не подходят? Ну потому что вот. Вот представьте, возьмите вот эту вершину.
[01:02:47.500 --> 01:03:04.500]  Ну возьмите вершину 0, 2, 4, 1. Тут перекрёстное ребро есть, но цикла нет. Ну да. А в неор графе, забегая вперёд, перекрёстных ребер в принципе не существует.
[01:03:04.500 --> 01:03:16.500]  Это я сказал семинаристам, чтобы с вами разобрали. В случае неор графов существуют только ребра дерева, обратные ребра и прямые ребра. В перекрёстных ребер в неор графах появиться в принципе не может.
[01:03:16.500 --> 01:03:34.500]  Ну это по секрету. Да. По какому моему определению, где у меня такое определение? Нет, я правда не понял, какое определение?
[01:03:34.500 --> 01:03:46.500]  В графе есть цикл. Вот. Мы найдём ребро, оно будет обратно. Оно не будет обратно. Оно будет ребром дерева.
[01:03:46.500 --> 01:04:00.500]  У меня каждое ребро принадлежит одному из четырёх классов. Вот, поэтому. То есть если у меня это ребро дерева, то оно уже ребром обратным быть не может.
[01:04:00.500 --> 01:04:25.500]  Окей. Ну давайте что-нибудь подоказываем. В какую сторону вам кажется прямо очевидно? Да, вот кажется, что достаточность она прям видна невооружённым взглядом.
[01:04:25.500 --> 01:04:35.500]  Ну действительно, давайте просто посмотрим на картину. Что значит есть обратное ребро? Вот это зелёное ребро. Это значит, что у меня есть какой-то путь, который ведёт из корня дерева, какую-то вершину.
[01:04:35.500 --> 01:04:50.500]  И из неё же я могу добраться не в корень, а в потомку. Точнее в предку. Но кажется, что это в чистом виде цикл. То есть если я из предка могу добраться в потомку, и из потомка по ребру могу добраться в предку, то это уже цикл. Всё.
[01:04:50.500 --> 01:05:15.500]  Можно я напишу очевидно? Спасибо. Давайте теперь поборемся за необходимость. Так, вот допустим у меня в графе есть цикл. Ну давайте его рассмотрим. Рассмотрим цикл.
[01:05:15.500 --> 01:05:24.500]  Вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот.
[01:05:24.500 --> 01:05:40.500]  Давайте его как-то не зовем. В1, В2, В3, В4, ну и последний ребро пусть ВН. Рассмотрим цикл В1, В2, далее ВН.
[01:05:40.500 --> 01:06:09.500]  Ну то есть если в графе у меня есть цикл, то я какой-то обязательно найду. Вот он. Так, давайте без ограничений общности будем считать, что В1 это первая вершина цикла, первая вершина цикла, которая была обнаружена.
[01:06:10.500 --> 01:06:30.500]  Вот, ну если у меня ДФПС как-то гуляет по графу, гуляет и пришел в вершину В1. Ну если он пришел не в вершину В1, то я просто нумерацию сменю и все, окей? Вот допустим я пришел в вершину В1, эта вершина серая, все остальные белые.
[01:06:30.500 --> 01:06:53.500]  Так, что дальше? Что? А почему я доберусь до ВН? Потому что существует белый путь. Вот, по лемме о белом пути во время обхода В1 я обязательно попаду в вершину ВН.
[01:06:53.500 --> 01:07:13.500]  По лемме о белом пути. То есть лемма о белом пути мне как раз говорит, что если у меня существует белый путь до какой-то вершины, то я обязательно эту вершину посещу. Все, следовательно, по лемме о белом пути посещу вершину ВН.
[01:07:13.500 --> 01:07:30.500]  Ну может я не по этому пути прошел. В общем, так или иначе у меня вершина ВН в итоге будет посещена. Так, а когда я посещаю вершину ВН, то что произойдет? Да, во время рассмотрения ВН я как раз таки найду ребро, которое ведет в серую вершину.
[01:07:30.500 --> 01:07:56.500]  То есть обнаружу ребро ВН В1, ведущее в серую вершину В1.
[01:07:56.500 --> 01:08:10.500]  Так, а что за такие ребра, которые ведут в серую вершину? Это же ровно обратные ребра, да? Обратные ребра это те ребра, которые ведут в серую вершину. Ну, кажется, доказали.
[01:08:10.500 --> 01:08:38.500]  Как из этой теории мы сконструировать алгоритм проверки на наличие цикла? Понятно?
[01:08:38.500 --> 01:08:59.500]  Давайте напишем. Не сложно. Что нам говорит теорема? Теорема нам говорит следующее. Запускай DFS, вот если есть обратное ребро, ну или если ты нашел серую вершину, то все, заканчивай все сразу.
[01:08:59.500 --> 01:09:23.500]  Как проверить, что в графе G есть цикл? Ну, изначально мы говорим, что колор тех вершин это белый, ну и там 4 ВН ЖВ.
[01:09:23.500 --> 01:09:51.500]  Если ДФС, цикл ЖВ, так нет, вот здесь, если В, если цвет вершины В белый, ну как и раньше, если цвет вершины белый, то мы из нее можем запустить DFS.
[01:09:51.500 --> 01:10:08.500]  Вот, запускаем DFS и просто проверяем, если ДФС хайс цикл вернул нам true, то возвращаем true. Если все внутренние вызовы DFS так и не нашли серого ребра, то после всего алгоритма возвращаем false.
[01:10:08.500 --> 01:10:27.500]  Ну и как выглядит ДФС хайс цикл? На самом деле ничем не отличается от того, что мы писали раньше.
[01:10:27.500 --> 01:10:46.500]  Значит, красим вершину в серый цвет, ну и дальше в цикле УН, для всех соседей вершина В. Делаем следующую вещь.
[01:10:46.500 --> 01:11:06.500]  Если цвет серый, то сразу же возвращаем true, согласны? Ну а иначе все как было раньше, давайте не буду писать.
[01:11:06.500 --> 01:11:20.500]  Алгоритм понятен, да, просто запускаю вот каждую вершину, от которой могу поиск цикла, ну и поиск цикла устроен следующим образом, просто обхожу всех соседей, и если встретил серого соседа, то сразу же возвращаю true.
[01:11:20.500 --> 01:11:34.500]  Но если я встретил серого соседа, это как раз таки означает, что я обнаружил обратное ребро. Ну и из того, что это критерик, расследую, что если у меня есть цикл, то я обязательно встречу серую вершину, и наоборот, если я встретил серую вершину, то значит точно у меня есть цикл.
[01:11:34.500 --> 01:11:54.500]  Корректность этого алгоритма понятна, да? Окей. Ну и давайте поговорим, раз затронули эту тему, какие возникают проблемы, когда мы пытаемся этот алгоритм применить к неориентированным графам.
[01:11:54.500 --> 01:12:06.500]  Ну смотрите, в чем вообще глобальная проблема? Глобальная проблема в том, как мы представляем обратные ребра, как мы представляем неориентированные графы.
[01:12:06.500 --> 01:12:25.500]  Ну давайте рассмотрим вот такой граф, и вот такой граф. Ну пусть это 0, 1, и это 0, 1. Вот давайте запишем их списки смежности. Ну, например, списки смежности, да, как они выглядят.
[01:12:25.500 --> 01:12:44.500]  Список смежности это массив длины 2, в котором здесь хранится единица, здесь хранится 0. Вот согласны ли вы, что для вот такого графа, и вот для такого графа представления в виде списков смежности они вообще не отличаются?
[01:12:44.500 --> 01:12:59.500]  И в этом проблема заключается. Почему? Потому что если вы работаете с вашим графом как с ориентированным графом, то тут у вас цикл, очевидно, есть. Если вы здесь работаете парадигмией неориентированного графа, то у вас цикла нет. Но в итоге он будет найден.
[01:12:59.500 --> 01:13:13.500]  Потому что вы прошли по этому ребру, а потом попытаетесь пройтись обратно по этому же ребру, и найдете серую вершину. Поэтому все будет плохо. В чем заключается вакцина от таких проблем?
[01:13:13.500 --> 01:13:28.500]  Как можно обойти такую проблему? Да, давайте просто-напросто во время вызова DFS headcycle будем дополнительно во время вызова DFS передавать, откуда мы пришли. Понятно?
[01:13:28.500 --> 01:13:39.500]  Ну, я сейчас не буду писать, но, в общем, идея такая. Давайте вот, когда я буду вызывать DFS от единицы, я буду дополнительно для единицы хранить, откуда мы пришли в нее. Мы пришли в нее от нуля, из нуля.
[01:13:39.500 --> 01:13:53.500]  А если мы пришли в нее из нуля, то значит обратно мы пойти не должны. То есть, когда вы перебираете в цикли, вы просто проверяете, пытаемся ли мы пройти в своего родителя. Если пытаемся пройти в родителя, то мы игнорируем это все.
[01:13:53.500 --> 01:14:11.500]  Идея ясна? Хорошо, вроде бы проблему решили, но есть еще одна беда. А что если у меня внезапно кратные ребра, да еще и неориентированные?
[01:14:11.500 --> 01:14:37.500]  Одно ребро и второе ребро. То есть тут у меня 0.1.1, 0.0.0. Есть ли в таком графе цикл? В таком графе цикл есть. Но если я буду использовать ту идею, которую мы обсудили только что, то есть не буду проходить в родителя, то я этот цикл никогда не найду.
[01:14:37.500 --> 01:15:01.500]  И снова алгоритм будет работать некорректно. Свешенные ребра. 1 в 500. Есть цикл? Не понял. Индикатор. Нет, все гораздо проще. Безумно просто. Да неприличие просто.
[01:15:07.500 --> 01:15:21.500]  Ну вообще да, можно и так. Но главный фокус стоит в том, что если у вас есть кратные ребра, то у вас уже гарантированно есть цикл. Поэтому вам в принципе этот алгоритм не нужен.
[01:15:21.500 --> 01:15:34.500]  Поэтому если вы вдруг поняли в какой-то момент, что у вас есть ребро, которое между одними теми же вершинами проходит, то сразу возвращайте труб без запуска алгоритма.
[01:15:34.500 --> 01:15:43.500]  Поэтому на самом деле никаких проблем с неориентированными графами, с мультиграфами и так далее нет. Судили, да?
[01:15:43.500 --> 01:15:54.500]  Так, осталось 5 минут. Я, наверное, ничего такого больше осмысленного не успею. Давайте я просто перекину некоторый мостик к тому, что мы будем делать на следующей неделе.
[01:15:54.500 --> 01:16:04.500]  А на следующей неделе мы будем обсуждать такое понятие, как сильная связность. В чем дело? Смотрите, мы уже с этой проблемой столкнулись.
[01:16:04.500 --> 01:16:14.500]  Когда у нас были неориентированные графы, то мы достаточно легко вводили понятие связанности графа.
[01:16:14.500 --> 01:16:21.500]  Что такое связанный граф? Связанный граф – это такой граф, который сам по себе является классом эквивалентности по свойству достижимости.
[01:16:21.500 --> 01:16:25.500]  То есть такой граф, в котором из любой вершины я могу добраться до любой другой.
[01:16:26.500 --> 01:16:29.500]  Рассмотрим теперь ориентированный граф.
[01:16:32.500 --> 01:16:37.500]  Точно такой же структуры, просто я ребра ориентировал.
[01:16:37.500 --> 01:16:42.500]  Вот вопрос – является ли такой граф связанным?
[01:16:45.500 --> 01:16:48.500]  Кто считает, что этот граф является связанным?
[01:16:48.500 --> 01:16:50.500]  Один.
[01:16:51.500 --> 01:16:56.500]  Как определить, а в каком кольце? Что значит связанность графа?
[01:16:56.500 --> 01:17:00.500]  В случае ориентированных графов существует два понятия связанности.
[01:17:00.500 --> 01:17:03.500]  Первая – это слабая связанность.
[01:17:03.500 --> 01:17:29.500]  Слабая связанность – это значит, что если убрать ориентацию ребер, то граф будет связанным.
[01:17:29.500 --> 01:17:33.500]  Слабая связанность говорит следующее.
[01:17:33.500 --> 01:17:38.500]  Давайте просто игнорируем, что у нас ориентированные ребра, и просто проверяем связанность в классическом способе.
[01:17:38.500 --> 01:17:42.500]  Этот граф в смысле слабой связанности является связанным? Да, является.
[01:17:42.500 --> 01:17:46.500]  Можно ли с помощью алгоритма DFS проверить на слабую связанность?
[01:17:46.500 --> 01:17:50.500]  Почему нельзя?
[01:17:50.500 --> 01:17:56.500]  Можно просто добавить по симметричным ребрам и запустить DFS.
[01:17:56.500 --> 01:18:01.500]  То есть слабую связанность проверять так же просто, как и обычную связанность.
[01:18:01.500 --> 01:18:04.500]  Просто по определению можем проверять.
[01:18:04.500 --> 01:18:07.500]  Ну и есть понятие сильной связанности.
[01:18:07.500 --> 01:18:17.500]  Сильная связанность.
[01:18:17.500 --> 01:18:26.500]  Ну это как раз таки классическая связанность в смысле достижимости.
[01:18:27.500 --> 01:18:40.500]  Из любой вершины можно добраться до любой другой.
[01:18:48.500 --> 01:18:51.500]  Является ли данный граф сильно связанным?
[01:18:51.500 --> 01:18:53.500]  Очевидно, нет.
[01:18:53.500 --> 01:18:55.500]  Потому что не из любой вершины можно добраться до любой другой.
[01:18:55.500 --> 01:18:58.500]  Ну вот между этими вершинами, например, пути не существует.
[01:18:58.500 --> 01:19:02.500]  И вот вопрос.
[01:19:02.500 --> 01:19:08.500]  Можно ли как-то с помощью обхода DFS проверить сильную связанность?
[01:19:08.500 --> 01:19:12.500]  То есть верно ли, что если я запустил DFS от какой-либо вершины,
[01:19:12.500 --> 01:19:17.500]  и обошел все вершины в моем графе, то у меня граф сильно связанный?
[01:19:17.500 --> 01:19:19.500]  Нет, да, еще раз возвращаемся к этому вопросу.
[01:19:19.500 --> 01:19:20.500]  Нет, нельзя.
[01:19:20.500 --> 01:19:23.500]  Потому что из этой вершины я действительно могу обойти все мои вершины.
[01:19:23.500 --> 01:19:25.500]  Но при этом граф сильно связанным не является.
[01:19:25.500 --> 01:19:26.500]  Вот контрпример.
[01:19:26.500 --> 01:19:29.500]  И вот на следующей лекции, точнее вот так,
[01:19:29.500 --> 01:19:33.500]  на самом деле с помощью DFS, ну хорошо, не с помощью одного DFS,
[01:19:33.500 --> 01:19:37.500]  с помощью двух обходов DFS можно определить, является ли граф сильно связанным или нет.
[01:19:37.500 --> 01:19:39.500]  Но это уже будет в следующий раз.
[01:19:39.500 --> 01:19:40.500]  А на сегодня все.
