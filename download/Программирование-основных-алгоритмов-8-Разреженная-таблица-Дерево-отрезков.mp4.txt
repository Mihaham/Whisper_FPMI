[00:00.000 --> 00:15.400]  Ну ладно, давайте начинать тогда потихоньку. У нас восьмая лекция. Сегодня перейдем к экватору
[00:15.400 --> 00:24.960]  нашего курса. Дальше будет только хуже. И в этот раз мы начинаем с вами новый модуль. Это будет
[00:24.960 --> 00:30.720]  модуль, посвященный структурам данных для обработки запросов на подотресках.
[00:30.720 --> 00:42.720]  Нет, у вас третий контест. Третий модуль, то есть деревья поиска. Там потрески по значению,
[00:42.720 --> 00:52.320]  тут по индексам будет иметь в виду это. Вот, это обработка запросов на подотресках.
[00:52.320 --> 01:07.640]  Вот, если вы вспомните самую-самую-самую-самую первую лекцию, там было у нас понятие задач
[01:07.640 --> 01:15.560]  RSCOO, RMCOO, ONLINE, OFFLINE, DYNAMIC, STATIC. Мы будем вести дискуссию об этом в ближайшие несколько
[01:15.560 --> 01:23.000]  лекций. И первое, что мы научимся делать с вами, это внезапно статика RMCOO.
[01:28.880 --> 01:35.640]  Ну онлайн. Как у нас задача? Статика это значит, что у нас элементы в массиве не меняются. RMCOO
[01:35.640 --> 01:40.160]  это значит, что мы хотим минимум на подотреске запросить. То есть у нас есть какой-то массив,
[01:40.160 --> 01:50.680]  постановка такая. 0, M-1, это массив A. И у нас есть запрос с вида LR,
[01:50.680 --> 02:07.680]  который мы хотим вот так узнать. Вот минимум на подотреске с LPR. Вот статика это значит,
[02:07.680 --> 02:14.080]  что мы запрещаем себе изменить массив. Онлайн это значит, что мы только ответив на этот запрос,
[02:14.080 --> 02:22.920]  получим следующий. RANCH минимум QUARY. Запрос минимум на подотреске. QUARY запрос, RANCH это
[02:22.920 --> 02:33.400]  диапазон подотрезок. Минимум это ну минимум. Вот. Если помните, у нас была задача в статик RMCOO.
[02:33.400 --> 02:39.640]  Вот, то есть запрос суммы на подотреске. Мы решали префиксными суммами. Там строили как-то
[02:39.640 --> 02:45.280]  массивчик префиксов. Мы вычитали одно из другого и побеждали. И мы говорили, что с минимумом так не
[02:45.280 --> 02:52.000]  получится, потому что он необратим. Вот теперь пришло время немножко приоткрыть завесу тайны и
[02:52.000 --> 03:02.240]  научиться делать нормально. Именно мы себе позволим следующее. Предподсчет или построение структуры
[03:02.240 --> 03:14.840]  данных. У нас будет за вот такое время работать. И ответ на запрос. За вот такое время мы хотим.
[03:14.840 --> 03:22.640]  Как оказалось, предпочет относительно долгий, но как долгий? Он нелинейный. Это уже не самоприятное,
[03:22.640 --> 03:29.360]  но запрос на то очень быстро. Вот. Как мы это будем делать? Будем делать с помощью разреженной таблицы.
[03:29.360 --> 03:47.960]  Не которая разряженная, а именно разреженная. Она сама не плотная, не мало значения относительно.
[03:47.960 --> 04:06.360]  По-английски sparse table. Вот. Что это такое? Это вот такая вот штука. Пусть есть массив А,
[04:06.360 --> 04:25.400]  что такое вот индексация 0, n-1. И еще в передаче у нас есть и бинарная операция f. То есть мы что хотим?
[04:25.400 --> 04:35.360]  Мы хотим считать какую-то бинарную операцию от кучи элементов. Вот. Заведомо сразу скажу,
[04:35.360 --> 04:47.400]  что мы будем накладывать все время. Следующее свойство — это ассоциативность. Кто помнит,
[04:47.400 --> 04:56.880]  что такое ассоциативность? Нет, коммутативность. Это как скобочки не расставляй, результат одинаковый.
[04:56.880 --> 05:14.520]  Или алгебрически это можно вот так вот записать. Вот. Мы будем все время это требовать,
[05:14.520 --> 05:20.160]  поэтому мы умеем с вами вычислять бинарную операцию от кучи аргументов, просто вот так-то
[05:20.160 --> 05:30.760]  ее расписываем по такому-то правилу. Вот. Окей. Этому задачу поставить, теперь давайте решать.
[05:30.760 --> 05:46.800]  Введем табличку st. Это двумерный массив. При этом у нас будет, у него вот такое вот
[05:46.800 --> 05:58.360]  интересное определение, что st и ты житый, это у нас будет управляться следующим образом.
[05:58.360 --> 06:17.240]  А и ты, это если ж равно нулю, иначе это у нас будет что такое? Это будет f от а и того, а и плюс 1,
[06:17.240 --> 06:34.600]  а и плюс 2 в степени g минус 1. То есть смотрите, что мы делаем. Вот наш массивчик есть,
[06:34.600 --> 06:46.520]  мы берем какую-то позицию i, это будет позиция i плюс 2 в степени g минус 1. Длина вот этого
[06:46.520 --> 06:55.360]  отрезка ровно 2 степени g. То есть мы на каждом следующем уровне, на уровне пожи имеется в виду,
[06:55.360 --> 07:01.160]  что мы делаем? Мы просто изучим в два раза длину отрезка, на которую мы считаем ответ.
[07:06.280 --> 07:17.880]  Это определение просто. Дальше мы пишем определение. Степени g минус 1. Ну чтобы у вас длина отрезка,
[07:17.880 --> 07:31.080]  то есть это и плюс 0, и плюс 1, и плюс 2 в степени g минус 1. Как с этой штукой пользоваться?
[07:31.080 --> 07:35.000]  Вообще как считать тогда тут табличку? Потому что будет очень грустно,
[07:35.000 --> 07:39.160]  если вы берете просто и каждый раз считаете ответ на отрезки.
[07:47.880 --> 08:07.480]  Ну будто бы да. То есть у вас такая горизонтальная табличка, здесь будет n элементов, тут n пополам,
[08:07.480 --> 08:22.880]  грубо говоря. Нет, вы берете f от вот этой вот кучи. Мы с вами определились, что раз у нас есть
[08:22.880 --> 08:27.000]  ответативность, можем писать винарную операцию от кучи аргументов, раскрывая вот такой вот,
[08:27.000 --> 08:36.700]  по-английски это называется fold, по-русски свертка. Вот. Собственно вопрос, если мы будем
[08:36.700 --> 08:39.980]  наивно пересчитывать за 2 в степени g, ну или просто за длину этого подотреска,
[08:39.980 --> 08:48.500]  брать функцию f и висовать сюда, это как-то очень долго звучит. Давайте применим адекватный алгоритм
[08:48.500 --> 09:02.100]  и заметим следующее. Вот ваша позиция и, и вот это вот у вас будет и плюс 2 в степени g минус 1.
[09:02.100 --> 09:11.940]  Что тогда хочется сказать? Давайте разделим отрезок пополам. Какой у него индекс будет
[09:11.940 --> 09:33.340]  в серединке? И плюс 2 в степени g минус 1, минус 1. Ну, в плане, ну, окей, хорошо,
[09:33.340 --> 09:41.820]  но мы уже все-таки не в непрерывной величине, у нас не бывает дробных индексов. Вот ваша граница,
[09:41.820 --> 09:53.700]  вот вы раз. Давайте, как разбить отрезок длины 4 на 2? Это раз, это два. Вот. То есть на самом деле,
[09:53.700 --> 10:08.820]  будто бы у вас есть такая штука. Это кто такой? Это будто бы f от st и ты g минус 1. Так,
[10:08.820 --> 10:18.740]  ну ладно, я немножко неудачно взял измерение, ну что поделать? А, 2 степени g минус 1, g минус 1.
[10:18.740 --> 10:29.660]  Вот. Просто обычно они наоборот ставятся, что, скажем так, индекс будет вторым, а степень
[10:29.660 --> 10:39.780]  доки будет первым измерением. Ну ладно, так напишу. Таким образом, у вас от единицы, ну считаем,
[10:39.780 --> 10:45.460]  что f включается за от единицы от двух элементов, за от единицы умеете заполнять одну ячейку массива.
[10:48.740 --> 11:07.860]  За от единицы одну ячейку массива. Окей, что дальше? Сколько всего ячейк будет в этой штуке?
[11:07.860 --> 11:15.060]  Ну, логично, что нам по второму измерению не особо имеет смысл много раз увеличить g.
[11:15.060 --> 11:27.940]  Ну, типа того-то, где-то либо вниз, либо вверх, как захотите. Ну да, а размеры таблицы,
[11:27.940 --> 11:48.020]  ну будет что-то порядка лог2н на n. Вот, как-то так. Потому что у вас всего логн уровней,
[11:48.020 --> 12:07.380]  и здесь там ну pn элементов. Вот. Из-за этого следует, что время построения – это наше заявленное n логн.
[12:07.380 --> 12:16.980]  Окей, как на запрос отвечать будем?
[12:30.020 --> 12:34.820]  Так у вас может быть порядка логарифма слагаемых, ну порядка логарифмов оперантов,
[12:34.820 --> 12:48.100]  которых надо выбрать f. Вот вам произвольный запрос. Ещё нет, мы сейчас напишем как и поймём,
[12:48.100 --> 12:52.980]  что ещё надо доделать. Ну да, логн на n.
[13:02.980 --> 13:10.620]  Ну, можно чуть по-другому. Возьмём сделан так, чтобы k максимально и до степени k,
[13:10.620 --> 13:21.900]  какое было у нас, не превосходило r-l. Из-за этого следует, что k просто равно
[13:21.900 --> 13:33.020]  округлённый вниз новичный логарифм от r-l. Зачем нам это надо? Тогда утверждается,
[13:33.020 --> 13:41.340]  что отрезки длины 2 в степени k, они хотя бы по одной клетке пересекутся. То есть вы не сможете
[13:41.340 --> 13:47.620]  сюда упихать два отрезка длины 2 в степени k, чтобы они при этом не то чтобы не пересеклись,
[13:47.620 --> 13:51.900]  чтобы у них было ещё что-то посередине. То есть вы захватите и эту часть, и эту часть.
[13:51.900 --> 14:04.300]  Ну нет, мы сейчас сделаем так, чтобы она не вырезала. Как это сделать? То есть запрос lr,
[14:04.300 --> 14:19.180]  ну зачем следующее? f от. Так, мы брали первым измерением индекс. OK, l ты, k ты. Ну k ты
[14:19.180 --> 14:27.300]  посчитывается по этой формуле. Да, заранее сразу скажу, что проще всего предпочитать вот на этом
[14:27.300 --> 14:34.140]  этапе, здесь, когда вы считаете разреженную таблицу, почитать сразу все логарифмы от 1 до n. Это просто
[14:34.140 --> 14:40.540]  удобно, чтобы здесь долго логарифм не брать и очень быстро отвечать. И теперь внимание,
[14:40.540 --> 14:50.460]  вот такая вот штука. Будем брать r минус 2 в k ты. Так, сейчас. Ну да, отрезка у нас так
[14:50.460 --> 15:00.100]  определяется. И k ты. То есть мы заведомо сразу берем себе, не от этой точки-то мы исчисляем,
[15:00.100 --> 15:08.900]  l плюс 2 в k ты минус 1. А сразу берем правую границу отрезка, r минус 2 в k ты. Казалось бы,
[15:08.900 --> 15:21.860]  все круто. В чем подвох? Да, потому что у вас, видите, у вас здесь есть пересечение двух отрезков.
[15:21.860 --> 15:30.860]  Вы его учитываете два раза на самом деле. Вот в этой формуле, неявно. Для суммы неприменимо,
[15:30.860 --> 15:36.020]  да. Мы же рмку решаем, а не риску все-таки. Вот, поэтому вводится следующее ограничение,
[15:36.020 --> 15:45.380]  которое мы запишем. Места мало. Ну ладно, пишем сюда. И демпатентность такое свойство.
[15:45.380 --> 15:57.940]  О чем оно? Оно гарантирует следующее, что для любого а f от аа равно а.
[16:06.020 --> 16:13.780]  Не, почему это у вас измерение? Это у вас степень блоки здесь пишется. А здесь пишется индекс
[16:13.780 --> 16:21.820]  левой границы. То есть с помощью вот этого свойства вы позволяете себе сказать, что хоть у меня
[16:21.820 --> 16:27.180]  пересечение два раза не считается, оно дает вклад лишь один раз. То есть вы можете за счет
[16:27.180 --> 16:32.340]  ассоциативности разложить вашу функцию на этом отрезке, как вычисление один раз на этом,
[16:32.340 --> 16:39.340]  вот на вот этом вот. Дальше два раза на этом и один раз на этом. Но два раза на этом это то
[16:39.340 --> 16:46.740]  же самое, что один раз на этом за счет вот этого вот свойства. Можно здесь подробно расписать,
[16:46.740 --> 16:58.620]  но я думаю, что это не нужно. Если нужно, дайте знак, распишем. Ну супер. Окей, тогда с этим
[16:58.620 --> 17:05.820]  забрались. То есть что мы хотим от операции? Мы хотим ассоциативность, но придумайте не
[17:05.820 --> 17:12.020]  ассоциативную операцию. Вот вам задачка на подумать. Часов до четырех ночи не уснете. Вот.
[17:12.020 --> 17:17.620]  И домпатентность. Но здесь гораздо проще не домпатентную операцию придумать. Это сумма банальна
[17:17.620 --> 17:28.740]  или произведения. Вот. Собственно статик здесь, потому что мы, ну давайте подумаем,
[17:28.740 --> 17:36.820]  плюс-минус, сколько ячеек затронет обновление одного элемента. Ну будто бы порядка ООТН.
[17:36.820 --> 17:42.260]  Может у вас будет одна ячейка длины 1, две ячейки длины, ну две ячейки на следующем уровне,
[17:42.260 --> 17:47.540]  четыре ячейки на следующем уровне. Тра-та-та-та-та. Порядка ООТН ячеек.
[17:47.540 --> 17:56.420]  Что такое векторное произведение от массива? Это подотреска. Вот как вы можете его определить?
[17:56.420 --> 18:09.020]  Ну это понятно, ну вы конечно молодцы придумали. Это конечно да, но взять векторное произведение,
[18:09.020 --> 18:15.540]  давайте что-нибудь в бейсболе такого числа неприменимое что ли. Вот да, это единственная операция,
[18:15.540 --> 18:18.980]  которая, которая типа башенкой делается, она действительно не ассоциативна, там вообще ничего
[18:18.980 --> 18:28.220]  непонятно, что с ней происходит. Ну ладно. Вот. Окей. Ну это все конечно круто, но заметьте,
[18:28.220 --> 18:32.220]  мы с вами говорили, что у нас есть как бы здесь две вариации, здесь две вариации,
[18:32.220 --> 18:37.740]  здесь две вариации. Ну ладно. Если мы умеем онлайн, то отлайн понятно как делать. Но у нас здесь аж
[18:37.740 --> 18:44.700]  статик динамика и рамку и раску, то есть аж четыре варианта всего лишь. Статик и раску мы умеем,
[18:44.700 --> 18:50.820]  но мы ничего про динамик не умеем. Вот пришло время раскрыть великую завесу тайны и решить одной
[18:50.820 --> 19:02.180]  штукой динамик и раску и динамик и рамку сразу. Ну понятно дело она и статик позволяет. В чем она
[19:02.180 --> 19:07.180]  будет уметь делать это онлайн, поэтому и офлайн. То есть это такая убер структура данных, которая все
[19:07.180 --> 19:24.940]  умеет вообще. Ну те кто знают, те знают, те кто не знают, представляю. Дерево отрезков.
[19:24.940 --> 19:37.300]  Как мы с вами уже привыкли делать с деревьями, у нас что куча была бинарным деревом,
[19:37.300 --> 19:44.380]  что дерево отрезков будет таким же деревом, что и куча, то есть массиве хранится. Как оно устроено?
[19:44.380 --> 20:03.940]  Давайте нарисуем массив. Вот у вас 8 элементов. Бывает конечно, но мы будем все время вжить,
[20:03.940 --> 20:08.020]  что это массивчик. Вот понятно дело, что можно указать как просто дольше будет.
[20:08.020 --> 20:15.900]  Короче говоря, есть случаи, когда нужно именно на указателях писать, но мы их скорее всего не
[20:15.900 --> 20:25.220]  будем в курсе разбирать. Персистентное. Персистентное дерево отрезков необходимо
[20:25.220 --> 20:32.460]  указать. Это которое хранится в своей версии дополнительно. Вот такой у нас массив.
[20:32.460 --> 20:59.900]  Давайте в качестве операции f возьмем плюсик. Дальше делается следующее. Вот ваше дерево.
[20:59.900 --> 21:08.180]  Передаваем бинарную кучу в гриме. У нее есть нижний слой, слой чуть повыше, чуть повыше и корень.
[21:08.180 --> 21:27.860]  Да, мы для суммы конкретно. Давайте скажем так, что f, что это плюсик в нашем случае. Можете
[21:27.860 --> 21:34.700]  рассматривать нод. Здесь есть числа отрезательности, мне не очень понятно, что делать с нодом. Не знаю,
[21:34.700 --> 21:42.140]  например, какой-нибудь побитого и. Рассмотрите, оно тоже будет подходить. Как работает построение
[21:42.140 --> 21:52.100]  этой штуки? Сразу мы будем считать, что длина массива исходного это степень двойки. Если нет,
[21:52.100 --> 21:57.780]  то добейте нулями до ближайшей степени двойки. Нули для суммы или просто нейтральными элементами.
[21:57.780 --> 22:03.780]  Вот у нас первое требование – это существование нейтрального. Давайте сюда будем требования
[22:03.780 --> 22:14.700]  выписывать. Ну первое – это ассоциативность, очевидно. Потому что если у вас нет никакой
[22:14.700 --> 22:22.180]  ассоциативности, то вы просто не можете раскрывать f от подотреска каким-то образом вообще. Второй
[22:22.180 --> 22:38.100]  случай – это второе требование – существование нейтрального. Нейтрального. Умные люди говорят,
[22:38.100 --> 22:42.340]  что это маноид. Называется такая структура с двумя множеством сведенных на миминальной
[22:42.340 --> 22:48.700]  операции. Доверяющий ассоциативности существования нейтрального – это маноид. Но я этих умных слов
[22:48.700 --> 23:06.260]  не знаю. Окей, про построение. Длина массива – два степеника, иначе добиваем нейтральными.
[23:06.260 --> 23:31.340]  Вот, это первое. Что делаем дальше? Массив Т – это массив дерева. Т – длины,
[23:31.340 --> 23:45.420]  будто бы 2 на 2 степеника минус 1. Потому что нам нужен этот массив длины 2 степеника,
[23:45.420 --> 23:57.700]  и еще вот здесь сверху степеника минус 1. Поэтому такая вот длина интересная. Ну или 2n-1,
[23:57.700 --> 24:04.500]  если у вас n была длина. Вот. В какой форме мы будем заполнять? Будем делать следующий.
[24:04.500 --> 24:26.460]  4i равный. Еще будет сложно. Видимо, n-2. Нет. Мы делим вот это n, а все, что сверху будет n-1,
[24:26.460 --> 24:32.340]  видимо, длины. Считаем, что у нас массив этот построен уже, и у него в конце записаны эти
[24:32.340 --> 24:38.660]  элементы во второй половине. То есть у вас будто бы был ваш исходный массивчик длины n,
[24:38.660 --> 24:46.660]  и ему приписали в начало еще n-1 элемент. Вот. Тогда как заполнить все верхушки дерева?
[24:46.660 --> 25:01.340]  Вот если у нас есть индекс i, чему его индексы dc равны? В куче были. 2i плюс 1, 2i плюс 2.
[25:01.340 --> 25:17.140]  Все. f от t, 2i плюс 1, t от 2i плюс 2. Все. Отвергается, что этот алгоритм заполнит вам полностью
[25:17.140 --> 25:28.220]  все дерево. Ну почему это так? Это построение. У нас есть массив. Нам обладали изначально. Все.
[25:28.220 --> 25:37.140]  Онлайн запрос в смысле приходит. В этом плане. Но еще будет запрос изменения элементов в массиве.
[25:37.140 --> 25:42.740]  Вот. Пока что мы гарантируем лишь то к себе то, что у нас длина массива меняться не будет. То есть
[25:42.740 --> 25:48.700]  мы не умеем просто взять и удалить откуда-то элементы или добавить куда-то элементы. Мы научимся все
[25:48.700 --> 25:55.340]  это делать, но не сегодня. Через 2 недели. Там мы вспомним декартовое дерево еще заодно.
[25:55.340 --> 26:04.580]  Клучайно упомянем. Вот это вот работает построение. Как вы можете заценить, оно работает за линию.
[26:04.580 --> 26:16.300]  То есть потому что у вас здесь есть фор, который докидывает нулями до, ну нейтральными до степени
[26:16.300 --> 26:23.700]  двойки. Это вот эта вот длина массива. Иначе добавляем нейтральными. Дальше у вас есть
[26:23.700 --> 26:29.420]  удвоение этой длины. Просто вы делаете новую массив, копируете вот его конец старый. И теперь
[26:29.420 --> 26:41.100]  дальше оставшийся фор добивает верхушку. Итоговое время построения линейное.
[26:46.300 --> 27:04.980]  Окей, следующий раз сделайте этот запрос. Давайте я нарисую где-нибудь одно большое дерево,
[27:04.980 --> 27:06.100]  на котором буду все показывать.
[27:36.100 --> 27:52.420]  6, минус 7, здесь 8, здесь 9. Вот наш дерево. Ну какие индексы хотите? ЛР назовите, покажу как запрос на них делать.
[27:52.420 --> 28:11.460]  0, 1, 2, L, 3, 4, 5, 6, R. Не худший выбор. Стоим в корне. Давайте еще для каждой вершины
[28:11.460 --> 28:16.700]  понимать, за какие отрезки она отвечает. То есть эта вершина, она хренится результатом всего массива,
[28:16.700 --> 28:26.060]  например. Ну плюс-минус понятно как это делать. Ну, например, вы знаете высоту там и можете
[28:26.060 --> 28:32.660]  оценить левый индекс, там правый индекс, как-нибудь так. Вот. Ну или вы можете просто передавать
[28:32.660 --> 28:39.980]  границы массива 0, что это граница запроса функции, что у вас текущий отрезок, который вы контролируете,
[28:39.980 --> 28:50.620]  это с 0 по n. Вот. Вы стоите и смотрите, у вас 3 случая будет. Случай 1. Давайте запрос LR,
[28:50.620 --> 29:01.500]  индексы контролируемого под отрезка,
[29:01.500 --> 29:18.780]  под отрезка. Пара LR. Вот. То есть, например, в нашем случае, когда мы стоим в корне,
[29:18.780 --> 29:28.060]  это LR. Если мы стоим здесь, то у нас вот под деревья это 1, 2. То есть LR здесь, R здесь.
[29:28.060 --> 29:50.900]  Что? Нет. У нас бывают 3 случая. Случай 1. Это отрезок LR в пересечении с отрезком запроса.
[29:51.060 --> 30:05.300]  Это пустое множество. Давайте я буду обзывать нейтральный элемент E. Ну, как обычно это обзывают.
[30:05.300 --> 30:16.380]  Вот. Тогда мы из этого зала возвращаем нейтральный элемент. Второй случай. Это отрезок LR у нас будет
[30:16.380 --> 30:30.540]  вложен в отрезок запроса. Например, для данной вершинки, вот для этой вот. Вот здесь вот. Вот она,
[30:30.540 --> 30:37.100]  по дереву ее. Вот LR будет здесь. Они вложены в маленькие. Что мы должны вернуть?
[30:37.100 --> 30:57.940]  Значение в узле. И третий случай. Это не то, не все. Вы как бы и пересекаетесь, и не вложены. То есть,
[30:57.940 --> 31:10.740]  остальное. Да, вы должны. То есть, вот здесь вот. Вот ваш LR. Вы вроде бы и не вложены,
[31:10.740 --> 31:21.220]  но и пересекаетесь. Значит, вы запрашиваете запросы от детей. Просто-напросто. Верни.
[31:21.220 --> 31:37.820]  Ну, все равно тут даже на псевдокод и близко не пахнет, поэтому можно и русским языком написать.
[31:37.820 --> 31:44.100]  То есть, я фод дети, вы вернули отсюда какое-то значение, отсюда какое-то значение и применили
[31:44.100 --> 31:50.620]  к ним LR. Давайте рассмотрим обработку этого запроса. Вот мы стоим в корне. Вот наш LR,
[31:50.620 --> 32:03.100]  большой такие. Это 0 и там n-1, допустим. Вы такие смотрите, ага, как проверять,
[32:03.100 --> 32:09.940]  что отрезки вложены. Но это несложно делается. Вам нужно проверить вот такую цепочку неравенств.
[32:09.940 --> 32:20.940]  Ну, это гарантировано само собой. То есть, вам нужно проверить вот эти две штучки. Это
[32:20.940 --> 32:28.420]  равносильно вложенности. Ну, как проверить отсутствие пересечения, думаю, тоже понятно. Это
[32:28.420 --> 32:35.420]  совокупность того, что либо у вас LR слева целиком от этого, либо справа целиком от этого. Ну,
[32:35.500 --> 32:43.500]  проверить понятно. Нужно сравнить соответствующие границы. Либо эти, либо вот эти две. Вот. То есть,
[32:43.500 --> 32:51.460]  когда вы спуститесь сюда, и как разбивать случай, если вы идем вниз? Вы берете просто и вызываете
[32:51.460 --> 33:06.980]  функцию запрос с индексами левой, серединка, серединка плюс один правый. Вот так вот. Тогда вы
[33:06.980 --> 33:14.580]  получите то, что вам нужно. То есть, вы будете корректно поддерживать эти вот LR. Ну, ладно.
[33:14.580 --> 33:22.860]  Вот мы стоим здесь. Ну, и текущим стейк-рекурс у нас этот и этот есть. Смотрим на этого чувака.
[33:22.860 --> 33:30.980]  У него R вот здесь вот. Отрезки пересекаются, но не вложены. Должно спуститься вниз.
[33:30.980 --> 33:43.740]  L больше, оказывается, вот тут вот. Как видим, все вложение. Возвращаем от этого чувака вот сюда
[33:43.740 --> 33:49.700]  вот минус один. Ну, так как мы здесь еще от ребенка запустились секурсивно, раз мы вниз спустились,
[33:49.700 --> 33:55.980]  да, видим, что здесь пересечение пустое с LR. Отсюда возвращаем нейтральный элемент. Ну,
[33:55.980 --> 34:03.180]  в нашем случае ноль просто, потому что у нас сумма. Тогда рекурсия выкинет сюда вам минус один.
[34:03.180 --> 34:10.060]  То есть, это результат суммы на вот этом вот части. Минус один плюс ноль.
[34:10.060 --> 34:21.180]  Окей, дальше. Вот мы здесь находимся. Смотрим, есть ли пересечения. Я перерисую границы. Теперь они
[34:21.180 --> 34:27.900]  вот здесь вот. Пересечения есть? Снова никто не вложит. Грустная история. Окей, тогда вызываем
[34:27.900 --> 34:39.020]  сеть детей. Рассматриваем отдельно для этого. У него L здесь, R здесь. Ну, вложение. Все. Поэтому
[34:39.020 --> 34:49.620]  отсюда выскочит минус один. И здесь закончилась ветка рекурсии. Вот он выскочил, идем сюда. Здесь
[34:49.620 --> 35:03.580]  запросы следующие. LR. Пересечения есть по одному элементу? Вложения нет. Что? Да, мы вниз сейчас
[35:03.580 --> 35:09.940]  пойдем. Вот мы стоим здесь, у нас запрос такой вот. Вот у нас есть пересечение равно по одному элементу,
[35:09.940 --> 35:21.820]  поэтому мы идем в дети. Да, потому что у нас здесь просто один элемент, мы от него возвращаем восьмерку.
[35:21.820 --> 35:26.380]  Отсюда мы возвращаем ноль, потому что он не входит в запрос. Поэтому сюда вернется восемь,
[35:26.380 --> 35:35.340]  тогда отсюда вернется семь. Да, отсюда вам вернется шесть. Давайте посмотрим,
[35:35.340 --> 35:43.140]  что в итоге это будет. Надо посчитать ответ. Минус один, пять, плюс восемь, тринадцать,
[35:43.140 --> 35:51.980]  минус семь, шесть. О, мы даже не ошиблись нигде при подсчетах. Вот. Так работает запрос. Но в коде
[35:51.980 --> 35:56.620]  это тоже очень легко делается на самом деле. То есть вы смотрите, если такой случай, возвращайте
[35:56.620 --> 36:01.620]  нейтральный. Если такой случай, возвращайте значение в узле. Если такой случай, вызывайте
[36:01.620 --> 36:08.300]  рекурсивно от детей. Все. Там кода, ну, пятнадцать что ли строчек будет. Нормально там поставился расписок.
[36:08.300 --> 36:17.780]  Я же сказал, что можно два неравенства проверить. Конечно, у вас же это естественно выполнено. Ну,
[36:17.780 --> 36:22.540]  если вы совсем не напортачили в коде, то оно выполнено естественно. Поэтому нужно вот эти два
[36:22.540 --> 36:28.420]  проверить, систему из двух неравенств. Здесь система из двух неравенств, здесь будет совокупность,
[36:28.740 --> 36:45.940]  если что. Вот. Окей. Что теперь? Сколько это работает? Вопрос зал. Почему за лагеритм? У меня же
[36:45.940 --> 36:49.620]  может быть много вершин на одном уровне? Видите, у меня же тут много цепочек разных спуска.
[36:56.620 --> 37:10.060]  Почему это вдруг? Нет, это неправда. Это неправда, мы здесь нигде префиксу не сводили.
[37:10.060 --> 37:18.820]  Ну, если у меня запрос будет целиком здесь находиться, то у меня не будет никакого разделения
[37:18.820 --> 37:26.980]  на префиксы. Здесь эта идея не очень работает. Вот. И так анализировать сложно достаточно,
[37:26.980 --> 37:47.100]  как вы видите. Это спорно, потому что у вас отрезок может быть совсем странным. Например,
[37:47.100 --> 37:58.180]  это будет вот такой вот подотрезок. Там придется взять отсюда, отсюда, отсюда и отсюда. Все,
[37:58.180 --> 38:07.780]  тут много разветвлений. Это как раз ревиальный случай, потому что мы просто берем, то есть мы
[38:07.780 --> 38:17.540]  в девятнадцать разбиваем на два гирна. Потом у строки мы берем лево-с, право-с, пускаемся в право-с или лево-с.
[38:17.540 --> 38:24.540]  Берем право-с на целиком. И шестнадцать мы берем лево-с на целиком и пускаемся в право-с.
[38:24.540 --> 38:46.100]  Так их может быть много. Они все маленькие, но их может быть много в этом проблема.
[38:46.100 --> 38:57.020]  Почему это они золотые единички? Друг там какие-то две, какие-то там три, какие-то четыре,
[38:57.020 --> 39:13.700]  вообще непонятно. Вот, да-да-да. Давайте докажем это утверждение. Рассмотрим уровни.
[39:16.100 --> 39:23.120]  Дерево отрезков. Утверждается следующее, что на каждом уровне мы возвращаем из результат
[39:23.120 --> 39:42.540]  из не больше, чем двух узлов. На каждом уровне результат берется из не более, чем двух узлов.
[39:42.540 --> 39:54.700]  Нейтрально здесь не подходит. Вы спустились, имеется в виду то, что вы туда вот вернетесь
[39:54.700 --> 40:09.820]  и отсюда вот выше пойдете. Ну тогда, окей, давайте. Хорошо, окей, не более четырех раз. Вот,
[40:09.820 --> 40:22.180]  эта оценка верна. Как не считай вот эту фразу. Четырех раз. Хорошо, давайте рассмотрим уровень,
[40:22.180 --> 40:39.820]  на котором берется более. Предположим противное. От противного рассмотрим уровень с больше либо
[40:39.820 --> 40:48.380]  равно 5 вершинами, из которых возвращается результат. Тогда я утверждаю, что в эти 5 вершин мы могли
[40:48.380 --> 40:59.100]  прийти как минимум из трех вершин на уровне выше. Это логично. На уровне выше
[40:59.100 --> 41:19.500]  рассматривались больше либо равно трех вершин. Очевидно, среди них есть самое левое и самое правое,
[41:19.500 --> 41:33.940]  что-то посередине. Обзовем их L, M, R. Ну левая, серединка правая. Причем серединка не в смысле
[41:33.940 --> 41:46.140]  прям всянеархметическая, что-то там где-то между ними. Вот, по-другому пустим ветку. Если L, M, R подряд
[41:46.140 --> 41:55.060]  идут, вот так скажем, то очевидно, что у хотя бы двух из них общепредок есть. Вот, то есть вы берете
[41:55.060 --> 42:05.100]  три подряд, хотя бы у двух из них, точнее так ровно у двух из них один отец. Вот, то заменяем
[42:05.100 --> 42:29.060]  запрос от детей с общим отцом на запрос от отца. Вот, давайте теперь скажем, что они не подряд стоят.
[42:29.060 --> 42:38.020]  Значит, хотя бы между какими-то из них есть дырка, хотя бы в одну вершинку. Согласны? Допустим,
[42:38.020 --> 42:52.660]  между L и M, без ограничения общности, утверждается, что у L и M есть общепредок. Вот. И что этим можно
[42:52.660 --> 42:58.380]  сказать? А, что мы не могли просто так взять? У нас нет такого запроса, который учитывает только
[42:58.380 --> 43:05.420]  эту вершину и только эту, но не учитывает то, что между ними. А это значит, что мы берем вот эту вот,
[43:05.420 --> 43:16.020]  соседа его, а значит, что мы бы спросили на уровень выше просто-напросто. Так и есть, это хорошо. Это
[43:16.020 --> 43:23.900]  значит, что мы не спустимся в M просто-напросто. То есть, нас не может считать среди на запроса. Вот,
[43:23.900 --> 43:36.660]  что хочу сказать вам на эти сотрустые доски. То есть, первый случай они подряд,
[43:36.660 --> 43:58.940]  вторых случай не подряд. Вторых случай не подряд. Без ограничения общности между L и M есть
[43:58.940 --> 44:25.860]  индекс P, хотя бы какой-то. Вот. Тогда что можно сказать следующее? Сейчас. Будем как-то сформулировать
[44:25.860 --> 44:50.220]  вместе. Вот. Если между ними есть индекс P, то что тогда? Между ними есть индекс P, то либо,
[44:50.220 --> 45:20.020]  под отрезок PM, под отрезок, то индекс P, он очевидно принадлежит LR.
[45:20.020 --> 45:30.500]  Вот. Но если мы спустились до L и M, значит, мы исключили из рассмотрения поддрева индекса P,
[45:30.500 --> 45:50.260]  чего быть не может, нас подряд под отрезок идет. Но тогда мы исключаем поддрева P из рассмотрения.
[45:50.260 --> 46:02.740]  Из этого следует, что запрос не непрерывный под отрезок.
[46:02.740 --> 46:25.740]  Вам приходит запрос обновить в индексе E элемент. Давайте постираю всякую эту лажу.
[46:25.740 --> 46:40.740]  С вами рисовали. Я оставил чистое дерево. Прижем с него лишнее. Это страшное рассуждение.
[46:40.740 --> 46:58.740]  Вот. Вы находитесь в вершине E. Вам сказали обнови элемент по индексу E. Как получить?
[46:58.740 --> 47:20.740]  Вот у вас индекс E приходит. Индекс в дерево какой? Н минус 1 плюс E. Все. Окей, хорошо. Вы меняете элемент.
[47:20.740 --> 47:30.740]  Да, просто вы должны спуститься в дерево вниз. Вот один шаг. У вас же есть индексация.
[47:30.740 --> 47:39.740]  Окей, хорошо. Допустим, минус 1 хочу на 5 поменять. Вам нужно обновить результат на пути.
[47:39.740 --> 47:48.740]  Это не очевидно, как по пути их обновлять. Короче, по пути мы будем обновлять по причине следующего раздела.
[47:48.740 --> 47:57.740]  Так скажем. Вот вы идете здесь. Дальше вы поднимаетесь вверх, пересчитываете результат.
[47:57.740 --> 48:07.740]  Да, просто F от детей. Дальше F от детей. То есть вы знаете индекс родителя и говорите, что чувак в родителе это F от двух индексов.
[48:07.740 --> 48:21.740]  Вы говорите, что на каждом этапе здесь уже корехные значения лежат внизу. Все. То есть вот у вас индекс в дереве.
[48:21.740 --> 48:35.740]  Ну индекс родителя вы помните, да, как определяется. И от этого еще берется все. Минус 1 на 2 округленный вниз. Это родитель.
[48:35.740 --> 48:43.740]  Второй уровень я не буду писать. Короче, вот вы родитель берете. Снова родитель.
[48:43.740 --> 48:52.740]  И здесь, здесь это будет просто применение F к детям.
[48:52.740 --> 48:59.740]  К родителям. От детей. Вот так скажем.
[48:59.740 --> 49:09.740]  То есть вы один раз поменяли здесь и все. И дальше у вас от родителей вызываете F рекурсивно, пока до корня не добрались.
[49:09.740 --> 49:19.740]  Ну как в куче было примерно просивания вверх. Здесь тоже только у вас. Вы останавливаетесь только когда до корня дошли и все время F применяете. Все.
[49:19.740 --> 49:24.740]  Ну здесь очевидно, что логарифмы согласны.
[49:24.740 --> 49:29.740]  Думаю, что высота дерева логарифм. Отлично. Здесь доказывать ничего не нужно.
[49:29.740 --> 49:36.740]  Окей, теперь самая пушечка от дерева отрезков.
[49:36.740 --> 49:41.740]  Это будет...
[49:41.740 --> 49:45.740]  Вот обновление в точке это конечно классно.
[49:45.740 --> 49:50.740]  Но давайте сделаем по-другому немножко. Расширим спектр возможностей.
[49:50.740 --> 49:54.740]  Да.
[49:54.740 --> 50:06.740]  Обновление на подотрезке.
[50:06.740 --> 50:17.740]  Пусть G это операция обновления.
[50:17.740 --> 50:24.740]  Вот.
[50:24.740 --> 50:29.740]  Нет. Поверь, нет. Мы сейчас сделаем только логарифмы.
[50:29.740 --> 50:33.740]  Окей, в чем главная суть этой все вещи?
[50:33.740 --> 50:39.740]  Суть следующая, что мы не будем это делать явно. Будем делать это максимально лениво.
[50:39.740 --> 50:44.740]  Максимально лениво. Что это значит лениво, я объясню.
[50:44.740 --> 50:47.740]  Пусть же операция обновления. Например.
[50:47.740 --> 50:51.740]  Взять и сказать, что все числа на подотрезке равны 3.
[50:51.740 --> 50:56.740]  Или сказать, что все числа на подотрезке умножаются на минус 37.
[50:56.740 --> 51:01.740]  Или там, не знаю, у всех чисел на подотрезке берут по битве И с чем-либо.
[51:01.740 --> 51:07.740]  Вот так и вот операция обновления имеется в виду.
[51:07.740 --> 51:11.740]  То есть никак бы с каждым элементом отдельно играют.
[51:11.740 --> 51:15.740]  Свойства операции G.
[51:15.740 --> 51:17.740]  Какие мы хотим?
[51:17.740 --> 51:20.740]  Ну, очевидно, G ассоциативно.
[51:20.740 --> 51:23.740]  Куда ж без этого?
[51:23.740 --> 51:27.740]  Случай 2.
[51:27.740 --> 51:32.740]  Существует нейтральный.
[51:32.740 --> 51:35.740]  Уже.
[51:35.740 --> 51:40.740]  Вы можете догадаться, что они нейтрального, но никаких ограничений в накладке.
[51:40.740 --> 51:46.740]  Вы можете довести эффективное значение, которое никогда не встретится, и сказать, что оно нейтральное.
[51:46.740 --> 51:49.740]  Вот, а случай 3 интересен.
[51:49.740 --> 51:53.740]  Открывается дистрибутивность по отношению к f.
[51:58.740 --> 52:03.740]  По отношению к f.
[52:03.740 --> 52:08.740]  Сейчас я подумал, как это буквками записать.
[52:08.740 --> 52:15.740]  Сейчас что-то типа G от f от a b.
[52:15.740 --> 52:20.740]  G равно f от.
[52:20.740 --> 52:25.740]  Что-то типа такого.
[52:25.740 --> 52:30.740]  Страшно, очень страшно.
[52:30.740 --> 52:34.740]  Сейчас посмотрим.
[52:34.740 --> 52:38.740]  Да, спасибо.
[52:38.740 --> 52:42.740]  Чтобы вспомнить, как это буквами пишется, я всегда вот так вот делаю.
[52:42.740 --> 52:47.740]  Вот у меня один аргумент это c на a плюс b.
[52:47.740 --> 52:52.740]  Это a c плюс b c.
[52:52.740 --> 52:56.740]  Вот что значит дистрибутивность.
[52:56.740 --> 53:03.740]  Что вы можете распылять на детей.
[53:03.740 --> 53:08.740]  С чего это надо будет. Сейчас мы посмотрим, что такое ленивая операция.
[53:17.740 --> 53:22.740]  Нам потребуется операция проталкивания.
[53:22.740 --> 53:25.740]  Сейчас мы их все обсудим.
[53:25.740 --> 53:29.740]  Давайте у нас будет запрос.
[53:29.740 --> 53:34.740]  Не знаю, запрос суммы и запрос.
[53:34.740 --> 53:39.740]  В том году я просил умножение на отрезки, и меня забулили.
[53:39.740 --> 53:43.740]  Поэтому будет запрос прибавления на отрезки.
[53:48.740 --> 53:53.740]  Вот я предложил студентам называть мне запрос, они мне просили умножить на 30 с чем-то там отрезок.
[53:53.740 --> 53:58.740]  Я был разочарован этим фактом.
[53:58.740 --> 54:03.740]  С тех пор я не доверяю людям.
[54:03.740 --> 54:08.740]  Вот дерево отрезков на сумму.
[54:08.740 --> 54:13.740]  И в каждом элементе мы еще будем хранить маленькую величину, называемую несогласованностью.
[54:13.740 --> 54:18.740]  Вот маленькая фасолинка.
[54:19.740 --> 54:24.740]  Был бы у нас цветной маркер, жизнь была бы ярче.
[54:29.740 --> 54:34.740]  Я предлагаю вам, зрители, называть запрос.
[54:34.740 --> 54:39.740]  Хорошо.
[54:39.740 --> 54:44.740]  Вот так что ли?
[54:44.740 --> 54:49.740]  Плюс равно два.
[54:49.740 --> 54:54.740]  Что происходит? Происходит следующее.
[54:54.740 --> 54:59.740]  Мы делаем все абсолютно ту же логику, что и во взятии запроса.
[54:59.740 --> 55:04.740]  Потому что мы верим в утверждение, которое я стер, что там все хорошо работает.
[55:04.740 --> 55:09.740]  Поэтому мы делаем все абсолютно так же.
[55:09.740 --> 55:14.740]  Спускаемся в детей, смотрим, дети не вложены, хорошо, идем сюда и сюда.
[55:14.740 --> 55:19.740]  Вот здесь вот два чувака лежат.
[55:19.740 --> 55:24.740]  Дальше смотрим, есть пересечения?
[55:24.740 --> 55:29.740]  Поехали.
[55:29.740 --> 55:34.740]  Пишем сюда два, несогласованность, потом такие, блин, это же лист.
[55:34.740 --> 55:39.740]  Раз то лист, мы сразу же будем избавляться от этого действия и напрямую прибавлять к листам.
[55:39.740 --> 55:44.740]  Закончилась здесь рекурсия.
[55:44.740 --> 55:49.740]  Остались здесь. Теперь мы вложены.
[55:49.740 --> 55:54.740]  Мы говорим, давайте пока приказ прибавить два, полежит здесь.
[55:54.740 --> 55:59.740]  Аналогично здесь будет ситуация.
[55:59.740 --> 56:04.740]  Здесь будет 10 просто.
[56:04.740 --> 56:09.740]  Давайте еще.
[56:09.740 --> 56:14.740]  Допрос. Кажется, у нас здесь есть несогласованность.
[56:14.740 --> 56:19.740]  Мы когда-то потом их передадим детям.
[56:19.740 --> 56:24.740]  0, 1, 2, 3, 4, плюс 3.
[56:24.740 --> 56:29.740]  Ну окей.
[56:29.740 --> 56:34.740]  Идем сюда, пересекаемся, идем сюда, перейдем сюда.
[56:34.740 --> 56:39.740]  Где?
[56:39.740 --> 56:44.740]  Вот здесь вот.
[56:44.740 --> 56:49.740]  А, да, все окей, у нас есть этот трезог.
[56:49.740 --> 56:54.740]  А здесь мы спустимся до конца, мы обновим это значение.
[56:54.740 --> 56:59.740]  А, ну да, извините, я конечно обманул вас всех.
[56:59.740 --> 57:04.740]  Я же когда изменил в листе, я должен подняться обратно вверх и обновить.
[57:04.740 --> 57:09.740]  Нет, почему?
[57:09.740 --> 57:14.740]  Так, вот запрос был плюс равно два, да?
[57:14.740 --> 57:19.740]  Вот, я изменил в этих точках и в этих точках значение.
[57:19.740 --> 57:24.740]  Причем здесь я уже увеличил. И теперь я должен от них подняться вверх.
[57:24.740 --> 57:29.740]  Ну от листьев, мы же только листья обновили.
[57:29.740 --> 57:34.740]  Но у нас же есть спуск рекурсии.
[57:34.740 --> 57:39.740]  Есть и подъем рекурсии, на каждом из которых мы обновляем значение.
[57:39.740 --> 57:44.740]  Какая разница?
[57:44.740 --> 57:49.740]  А тех узлов, с которых вы запрашивали, вы будете запрашивать апдейт у родителя.
[57:49.740 --> 57:54.740]  То есть вот вы допустим здесь там, да, вы прокинете просто все значения.
[57:54.740 --> 57:59.740]  Да.
[57:59.740 --> 58:04.740]  Даже если бы здесь делали, все равно вот сюда спустились рекурсии за логорифом, значит поднялись бы рекурсии за логорифом.
[58:04.740 --> 58:09.740]  Давайте обновлю значение.
[58:09.740 --> 58:14.740]  Здесь тоже.
[58:14.740 --> 58:19.740]  Ну что, все валидно было на подотреске.
[58:19.740 --> 58:24.740]  Да, давайте я сейчас отру заново дерево и нарисую, потому что мы тут запутались с этим.
[58:24.740 --> 58:29.740]  А, итак.
[58:29.740 --> 58:34.740]  Вот все, вот наше исходное дерево, да.
[58:34.740 --> 58:39.740]  Уже модифицированное чуть-чуть.
[58:39.740 --> 58:44.740]  Ну что, у нас все в порядке.
[58:44.740 --> 58:49.740]  Ну что, у нас все в порядке.
[58:49.740 --> 58:54.740]  Ну что, у нас все в порядке.
[58:54.740 --> 58:59.740]  Ну что, у нас все в порядке.
[58:59.740 --> 59:04.740]  Уже модифицированное чуть-чуть, но оно вроде корректное, да.
[59:04.740 --> 59:09.740]  19, минус 1, 18, 5, 6, 1, 29.
[59:09.740 --> 59:14.740]  Да, дерево корректное.
[59:14.740 --> 59:19.740]  Вот нам снова приходит запрос, вот этот плюс два.
[59:19.740 --> 59:24.740]  Мы говорили, ага, спускаемся вниз рекурсивно
[59:24.740 --> 59:29.740]  и пишем несогласованности просто везде.
[59:29.740 --> 59:34.740]  Дальше, когда мы поднимаемся вверх по рекурсии, мы спрашиваем о чистых значениях результата.
[59:34.740 --> 59:39.740]  То есть вот вы спускаетесь по рекурсии сюда, у вас здесь стала двойка.
[59:39.740 --> 59:44.740]  Так у вас здесь лист, вы сразу пишете пятерку.
[59:44.740 --> 59:49.740]  У вас сюда придет несогласованность два,
[59:49.740 --> 59:54.740]  сюда тоже два, и здесь будет просто плюс два.
[59:54.740 --> 59:59.740]  А дальше вы делаете уже запросы, когда поднимается вверх по рекурсии,
[59:59.740 --> 01:00:04.740]  также ЭП спрашиваете, но уже от элементов, которые записаны в них.
[01:00:04.740 --> 01:00:09.740]  Игнорируй вот эти вот двоечки всякие.
[01:00:09.740 --> 01:00:14.740]  Не игнорируем, мы поэтому правила собираем,
[01:00:14.740 --> 01:00:19.740]  чтобы у нас здесь стояло действительно настоящее значение.
[01:00:19.740 --> 01:00:24.740]  То есть вот здесь вы идете сюда и пишете пять плюс три, это восемь.
[01:00:24.740 --> 01:00:29.740]  Дальше, когда вы пытаетесь сравнивать здесь, что вы говорите?
[01:00:29.740 --> 01:00:34.740]  Ага, у меня здесь восемь, а здесь есть пять плюс несогласованность два.
[01:00:34.740 --> 01:00:39.740]  Несогласованность два, это значит, я должен был бы каждый элемент внизу
[01:00:39.740 --> 01:00:44.740]  себя увеличить на два, но метких элементов два.
[01:00:44.740 --> 01:00:49.740]  Два ребенка просто из отрезка суммарного.
[01:00:49.740 --> 01:00:54.740]  Поэтому два на два, и я должен вернуть сюда девять на самом деле, чтобы быть правдой.
[01:00:54.740 --> 01:00:59.740]  Вот, давайте посмотрим, что на этом отрезке действительно сумма будто бы девять,
[01:00:59.740 --> 01:01:04.740]  если мы здесь бы на два и здесь бы на два увеличили, то было бы два плюс семь.
[01:01:04.740 --> 01:01:09.740]  Сейчас, или я считать не умею.
[01:01:09.740 --> 01:01:14.740]  Да, все нормально.
[01:01:14.740 --> 01:01:19.740]  Аналогично с этим поступаем. Двенадцать плюс девять, это двадцать один.
[01:01:19.740 --> 01:01:24.740]  Дальше двадцать один, и замечаем, что мы взяли бы минус один
[01:01:24.740 --> 01:01:29.740]  плюс два на длину отрезка.
[01:01:29.740 --> 01:01:34.740]  Два на два, это четыре. Если не плюс четыре, то плюс три. На самом деле, мы все обернули бы плюс три и получили бы здесь
[01:01:34.740 --> 01:01:39.740]  двадцать один плюс три, двадцать четыре.
[01:01:39.740 --> 01:01:44.740]  Восемнадцать плюс двадцать четыре, это сколько? Это сорок один вроде бы, да?
[01:01:44.740 --> 01:01:49.740]  Сорок один минус двадцать девять, это двенадцать.
[01:01:49.740 --> 01:01:54.740]  Сорок два, да, совпало все.
[01:01:54.740 --> 01:01:59.740]  Сорок один, да.
[01:01:59.740 --> 01:02:04.740]  Это просто можно больше запроса сейчас понакидать сюда.
[01:02:04.740 --> 01:02:09.740]  Утверждается? Вот, смотрите, сейчас я покажу, как это исправляется.
[01:02:09.740 --> 01:02:14.740]  Я понимаю, да, мы сейчас это исправим.
[01:02:14.740 --> 01:02:19.740]  Предлагаю, что вы можете сделать, я вернусь.
[01:02:19.740 --> 01:02:24.740]  Не, я не вернусь.
[01:02:24.740 --> 01:02:31.500]  Я понимаю, да, да, да, мы сейчас это исправим. Предлагается сделать следующее.
[01:02:31.500 --> 01:02:37.220]  Бахнуть для вот такого вот подотреска плюс равно два.
[01:02:37.980 --> 01:02:42.900]  У меня же здесь есть несогласованность, я должен был от нее как-то избавиться. Вот.
[01:02:42.900 --> 01:02:48.820]  Что я делаю? Я иду-иду-иду, дошел сюда, отсюда вернется типа ноль, потому что это
[01:02:48.860 --> 01:02:56.020]  нейтральный элемент. Вот я пришел в этот узел. Что происходит здесь? Когда я стою в узле,
[01:02:56.020 --> 01:03:16.500]  я выполняю проталкивание, операция проталкивания. Перед разделением на детей всегда делай проталкивание.
[01:03:16.500 --> 01:03:28.260]  Ну или еще называют push. Проталкивание несогласованности. То есть смотрите,
[01:03:28.260 --> 01:03:33.500]  формально это можно представить так. Представим, что это не дерево отрезков,
[01:03:33.500 --> 01:03:39.140]  а тема чиновников. Вот есть федеральный уровень, региональный там, не знаю,
[01:03:39.620 --> 01:03:49.340]  городской и муниципально-районный, например. Что дальше происходит? Вот стоит чувак и говорит,
[01:03:49.340 --> 01:03:54.100]  давай-ка ты дашь приказ вот этим вот чувакам из этих вот всех
[01:03:54.100 --> 01:04:03.060]  фрагментов увеличить на два, не знаю, что-нибудь. Приказ там увеличить на два пенсии, например.
[01:04:03.060 --> 01:04:11.740]  Вот, если ты оказываешься, что? Ну я не знаю, на сколько, там условных единиц. Вот. Если ты
[01:04:11.740 --> 01:04:18.740]  оказался типа в листом в запросе, ты как бы сразу обновляешься. А типа чувак этот, он такой,
[01:04:18.740 --> 01:04:23.540]  блин, ну мне влом совсем сразу думать передавать. Как-то совсем не по-людски что ли. Давайте я
[01:04:23.540 --> 01:04:29.940]  попридержу у себя указ. Вот. А дальше типа потом, когда придут и спросят с меня, я протолкну приказ
[01:04:29.940 --> 01:04:36.820]  вниз и скажу, что взятки гладкие, я чист. Примерно такая здесь работа. То есть как бы вот здесь вот,
[01:04:36.820 --> 01:04:42.340]  вот когда вы зайдете сюда, у вас случится, что ага, у меня есть не согласованность два, блин,
[01:04:42.340 --> 01:04:48.220]  как бы я сейчас приду проверять что-то. А у меня должно быть ноль долгов перед родиной. Поэтому я
[01:04:48.220 --> 01:04:59.660]  что делаю? Я беру и говорю, а я девять. А сюда проталкиваю по двойчике. А все, аж это крыто. Вот.
[01:04:59.660 --> 01:05:07.180]  И говорю себе при этом, что у меня там еще плюс два, она тут спустится еще сюда и сюда. Вот эти вот
[01:05:07.180 --> 01:05:12.460]  плюс равно два, она спустится сюда, не спустится, а сюда спустится. Вот. И у вас еще придет плюс два сверху
[01:05:12.460 --> 01:05:17.740]  от запроса. Поэтому у вас на согласованность будет четыре на самом деле здесь. Потом он скажет такой,
[01:05:17.740 --> 01:05:22.540]  блин, ну я в менсипальном уровне, надо что-то делать в конце концов. До меня еще могут достучаться
[01:05:22.540 --> 01:05:28.180]  избиратели, поэтому я превращаюсь сразу. И мне долгов быть не может. Ну так же как и этот.
[01:05:28.180 --> 01:05:43.860]  Вот. Это предыдущая двойка была разве? Нет, мы ее меняли, мы не можем в листе держать
[01:05:43.860 --> 01:05:59.940]  не согласованность никогда. Да, мы забили на это, да? Короче, ладно, где-то здесь произошел баг? А,
[01:05:59.940 --> 01:06:06.460]  потому что мы сюда двойку сверху скинули, все. Ну здесь мы сразу автоматически трансформируемся,
[01:06:06.460 --> 01:06:13.220]  потому что самый ниже уровень чиновников долгов не имеет никогда. Ну и поднимаемся вверх,
[01:06:13.220 --> 01:06:30.260]  обновляя. Это правда, но эти элементы не знали об этом. До детей не дошел приказ. И вот только
[01:06:30.260 --> 01:06:35.780]  потом мы его скинули. И сказали, у нас здесь все взятки гладкие, все чисто, мы свое учли. И
[01:06:35.780 --> 01:06:43.580]  здесь мы отправили делать дальше. Ну или там, не знаю, окей, ладно, еще другая аналогия там, не знаю,
[01:06:43.580 --> 01:06:50.700]  приказ там починить дороги. Вот. Есть там, типа вот, сказал там мэр, надо починить там дороги,
[01:06:50.700 --> 01:06:57.100]  надо починить там, не знаю, треть транспортной кольцо, там яма. Мэр такой, спускает там районным
[01:06:57.100 --> 01:07:03.180]  своим чувакам. Районные такие. Там, не знаю, еще кому-то там спускают, спускают, спускают,
[01:07:03.180 --> 01:07:06.660]  пока рано или поздно не придется выполнить все свои обещания. Вот обещания выполняются вот
[01:07:06.660 --> 01:07:13.580]  этими вот рядовыми челиками. Вот причем вот этих вот чуваков вообще не волнуют, что происходит
[01:07:13.580 --> 01:07:19.620]  внизу. Они просто прокидывают свои долги вниз на детей эти, посваливают и такие все. Если ко мне
[01:07:19.620 --> 01:07:27.460]  придут спрашивать, то я чистый, у меня долгов нет. Здесь такая идея. Но абсолютно аналогично здесь,
[01:07:27.460 --> 01:07:33.540]  что у вас здесь была несогласованность 2, нам пришел, давайте вот так вот сделаем,
[01:07:33.540 --> 01:07:40.780]  вот, чтобы было интересней чуть-чуть. Пришла несогласованность 2, а он такой, ага. Адиссея не
[01:07:40.780 --> 01:07:45.180]  буду вызываться, значит меня проталкивать не нужно. Ну и плюс равно 2, значит мне несогласованность
[01:07:45.180 --> 01:07:53.740]  здесь 4 вообще становится. Ну и дальше я поднимаюсь вверх следующим образом. Я такой смотрю, ага.
[01:07:57.460 --> 01:08:05.140]  У меня здесь минус 1, плюс 4 умножить на длину отрезка. Да? Да. Минус 1 плюс 4 умножить на длину отрезка
[01:08:05.140 --> 01:08:09.740]  это минус, это 7 просто. Здесь будет 28 на самом деле.
[01:08:17.740 --> 01:08:25.660]  Где? Здесь? Ну извините, это вопрос. У вас может быть запрос суммы, тогда этот
[01:08:25.660 --> 01:08:37.820]  чувак скинет просто на детей. Например, по-разному может быть. Да, ну пуш у вас,
[01:08:37.820 --> 01:08:43.660]  смотрите, то есть всегда, когда к вам приходят, приходят за вами, да, либо вы понимаете,
[01:08:43.660 --> 01:08:53.260]  то есть либо как бы спрашивают целиком с вашего участка, а свои долги вы знаете,
[01:08:53.260 --> 01:09:01.140]  а значит вы можете как бы сказать, что вот мои долги, все прозрачно. А если пойдут еще в детей,
[01:09:01.140 --> 01:09:06.580]  то как бы надо такой, о, так это возможность скинуть, раз идут к детям, скинуть я к детям это все,
[01:09:06.580 --> 01:09:14.860]  а сам себя в нулю. Ну так сказать, да, долги по наследству передаются. И когда все-таки
[01:09:14.860 --> 01:09:18.700]  добираешься до последнего ребенка, который все еще живой, ты такой, ну блин, придется выполнять
[01:09:18.700 --> 01:09:24.900]  долги по наследству. Вот. То есть здесь такая. То есть у вас есть ленивые операции, вы явно
[01:09:24.900 --> 01:09:29.700]  никогда операции не проводите. Вы проводите операции тогда, когда время настанет. Ну или,
[01:09:29.700 --> 01:09:35.620]  например, не знаю, тут можно аналоги с студентом принести, что ему дают долги, дедлайны дают,
[01:09:35.620 --> 01:09:41.180]  дают, дают, дают, дают. И пока вот у него не спросят конкретный дедлайн, он их будет где-то копить.
[01:09:41.180 --> 01:09:49.700]  Когда он спрашивает конкретно, ты такой, ай-яй-яй-яй, быстро раскидываем. Все, эвакуация долгов срочная. Вот,
[01:09:49.700 --> 01:09:53.900]  у него спросят конкретно это, и он такой, ага, так, у меня были долги здесь, перекинуть сюда и сюда,
[01:09:53.900 --> 01:10:00.060]  этого трогать не буду, потому что его же не просит, дедлайн-то не пришел еще, здесь вот. Ага,
[01:10:00.060 --> 01:10:06.620]  спрашивают этот, придется по детям снова раскидать. Вот примерно так. И суммарно это все работает каждый
[01:10:06.620 --> 01:10:11.980]  раз за логарифом, потому что у вас запрос, по сути, такой же, как при запросе этого.
[01:10:11.980 --> 01:10:18.340]  Или запросите на отрезки просто, результаты. Вы делаете все абсолютно то же самое, только у вас
[01:10:18.340 --> 01:10:23.820]  иногда возникает этот пуш. Собственно, пуш он зачем нужен? Он нужен, чтобы сказать,
[01:10:23.820 --> 01:10:31.060]  меня взятки гладкие, и перекинуть детям их обязанность. То есть, получается, будто бы left.
[01:10:31.060 --> 01:10:39.220]  Мы здесь бух не вводили, я уже не буду. Несогласованность плюс равно, давайте,
[01:10:39.220 --> 01:10:54.060]  вот g происходит, равно g от несогласованность, запятая родитель.несогласованность. То есть,
[01:10:54.060 --> 01:10:59.860]  вы как бы аккумулируете свои несогласованности, что у вас было, и с родительской. То есть,
[01:10:59.860 --> 01:11:07.180]  у вас как бы своих долгов хватает, у вас еще родительский. Хочешь жить, уметь вертеться.
[01:11:07.180 --> 01:11:20.740]  Все то же самое. Здесь будет write, несогласованность, родительская несогласованность. Ну и как бы
[01:11:20.740 --> 01:11:35.020]  счастливый момент. Родитель, несогласованность равно нейтральный по g. Теперь смотрите внимательно,
[01:11:35.020 --> 01:11:44.740]  зачем здесь нужна дистрибутивность? Это не проталкивание от детей. Вот эта операция,
[01:11:44.740 --> 01:11:53.580]  то, что вы можете g перекинуть на детей, это и есть эта дистрибутивность, по сути. Здесь требования
[01:11:53.580 --> 01:11:57.780]  дистрибутивности возникают не просто из ниоткуда, а, наоборот, из алгоритма вытекают напрямую. Просто
[01:11:57.780 --> 01:12:12.700]  формализация. Вот. Так, у нас остается две минуты, вроде бы. Три, может. Да, ну любая операция алгоритм.
[01:12:12.700 --> 01:12:17.700]  Потому что мы делаем все так же, как с запросом. Казалось бы, если бы мы не останавливались бы
[01:12:17.700 --> 01:12:21.380]  сразу в вершине, типа вот у нас здесь несогласованность 4, мы пошли бы дальше бы ее протаскивать.
[01:12:21.380 --> 01:12:27.420]  Это понятно, что я работал бы за длину отрезка. Нет, если бы мы дальше выходили вниз проталкивать
[01:12:27.420 --> 01:12:32.820]  все время до конца, то бы обновили, по сути, весь подотрезок. А так мы остановились в какой-то момент.
[01:12:32.820 --> 01:12:49.620]  Нет, нет. Там у нас суммарно почти с не более чем 2n вершин. Нет, если вы явно будете каждый раз
[01:12:49.620 --> 01:12:58.580]  запускать по обновлению одного линтуда, это правда. Да. Вот. Ну короче, вот. Это вот подход
[01:12:58.580 --> 01:13:05.860]  таких ленивых операций. Его называют ленивые операции, отложенные операции. Они краски нужны
[01:13:05.860 --> 01:13:12.140]  для того, чтобы явно все не моделировать. Когда вас спросят, скажут, что а все готово. И неважно,
[01:13:12.140 --> 01:13:17.740]  что внутри происходит. Как мем про Гомера Симпсона, который типа вот такой вот весь красивый-красивый
[01:13:17.740 --> 01:13:26.140]  с одной стороны, с другой стороны, у него там дети в долгах. Вот. Примерно так. Ну короче, да.
[01:13:26.140 --> 01:13:38.260]  Такая вот идея. Вам понятно? Ну кому не понятно, это грустно. Кто-то поймет. Вот. Тогда все, давайте до следующей недели.
