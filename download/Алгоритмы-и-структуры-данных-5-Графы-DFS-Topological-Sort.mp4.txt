[00:00.000 --> 00:08.560]  Мы начинаем говорить про графы, наконец, формально.
[00:08.560 --> 00:16.960]  Начну сегодня, в первую очередь, DFS.
[00:16.960 --> 00:21.280]  Так, начинаем с определений.
[00:21.280 --> 00:24.760]  Я думаю, что у многих из вас это было, но все-таки
[00:24.760 --> 00:28.200]  для полной картины давайте повторим или узнаем.
[00:28.800 --> 00:30.880]  Значит, неориентированный граф.
[00:39.240 --> 00:45.480]  Это такая пара. Пара VE, где V это какое-то множество,
[00:45.480 --> 00:55.160]  а E это какое-то под множество пар внутри V. Я напишу вот так.
[00:55.160 --> 01:03.760]  E это под множество C из V по 2, имея в виду, что такое C из V по 2. Это все возможные неупорядоченные пары,
[01:03.760 --> 01:10.760]  то есть двуэлементные под множество, множество V. И E это какое-то под множество, то есть есть у меня
[01:10.760 --> 01:16.560]  все множество пар, там AB, BC и так далее, все возможные пары. Ну, E это какие-то из них.
[01:16.560 --> 01:20.880]  Значит, это мы будем называть вершинами, это будем называть рёбрами. Вот это граф, такая пара.
[01:20.880 --> 01:24.840]  Ориентированный граф.
[01:24.840 --> 01:47.920]  Это тоже пара VE, где V это множество, а E это под множество V квадрата, то есть Декартова квадрата V на V.
[01:47.920 --> 01:56.760]  Вот, значит, здесь пары у меня неупорядочные, то есть ребро это как бы две вершины неупорядочные,
[01:56.760 --> 02:01.400]  там UV или VU это одна и та же пара. А здесь, поскольку у меня фиксировано вот это вот произведение,
[02:01.400 --> 02:07.000]  то UV и VU это будут разные пары. Вот, ну, картинками это изображается там очень просто. Например,
[02:07.000 --> 02:12.520]  вот это вот, это неориентированный граф, соответственно, точки это вершины, палочки это
[02:12.520 --> 02:17.880]  рёбра между ними, неориентированные. Ориентированные рёбра это что-нибудь вот такое, например,
[02:17.880 --> 02:28.240]  это рёбра со стрелочками. Вот это ориентированный граф. Так, ну, я уже, кажется, говорил когда-то,
[02:28.240 --> 02:35.680]  что ими можно делать, ими моделируются любые какие-нибудь сети, в которых есть взаимодействие
[02:35.680 --> 02:41.640]  каких-то объектов, там, не знаю, группа друзей с отношением друга между ними или какие-нибудь
[02:42.040 --> 02:54.960]  самолётные рейсы между городами и так далее. Едем дальше, значит. Что такое путь? Ну, путь
[02:54.960 --> 02:58.560]  это просто последовательность вершин такая, что из первого есть рёбра во вторую, из второго в третью и
[02:58.560 --> 03:05.320]  так далее и так далее. Это набор вершин, V1, V2 и так далее, VK, набор вершин, ну, точнее,
[03:05.320 --> 03:18.840]  последовательность вершин. Такая, что первые две вершины образуют ребро, вторая пара вершин
[03:18.840 --> 03:28.120]  образует ребро, ну и так далее, вплоть до последней пары. Вот, здесь надо аккуратно
[03:28.120 --> 03:34.200]  обговориться. Я рисую в круглых скобочках пару из двух вершин. Вот, круглые скобки — это,
[03:34.200 --> 03:39.040]  соответственно, упорядоченная пара. Непосредственно такое определение — это для ориентированного графа.
[03:39.040 --> 03:43.000]  Но в случае неориентированного я буду писать точно так же. То есть, формально, с точки зрения
[03:43.000 --> 03:49.000]  неориентированного, я должен был бы писать что-то вот такое. Это вот в неориентированном случае.
[03:49.000 --> 03:54.960]  Ну, потому что у меня пары неупорядочные, я не могу написать круглые скобки. Если две вершины
[03:54.960 --> 03:59.320]  соединены, то порядка на них нету. Поэтому корректнее было бы писать фигурные скобки здесь, как
[03:59.320 --> 04:04.720]  быдовое элементное множество является ребром. Но я не буду сильно заморачиваться и буду неформально
[04:04.720 --> 04:10.160]  писать всегда круглые скобки, означая, что вот такое ребро. Если граф неориентированный, то имеются
[04:10.160 --> 04:18.040]  в виду тогда фигурные скобки. Вот это путь. Еще можно здесь отметить, что на самом деле вот в том
[04:18.040 --> 04:23.320]  определении, которое я дал, не бывает кратных ребер. То есть, если есть ребро из УВ, то оно не больше
[04:23.320 --> 04:27.800]  чем одно. Вот, и поэтому здесь, когда я задаю последность вершин, мне на самом деле, ну вот,
[04:27.800 --> 04:33.000]  ребра между ними однозначно определены. То есть, вот здесь вот ребро, оно не больше чем одно. Я
[04:33.000 --> 04:38.360]  просто проверю, что оно есть в графе. В случае, если бы у нас был там какой-нибудь мульти граф,
[04:38.360 --> 04:42.200]  то есть, с кратными ребрами, когда между одной и той же парой вершин может быть несколько
[04:42.200 --> 04:46.240]  стрелочек, тогда здесь в определении нужно было бы еще вставлять какие-то ребра между ними,
[04:46.240 --> 04:51.840]  потому что а какое именно ребро имеется в виду, чтобы пройти между этими вершинами. Но в нашем
[04:51.840 --> 04:59.640]  случае такого не бывает, поэтому я обхожусь только перечислениями вершин. Так, дальше,
[04:59.640 --> 05:12.880]  значит, путь называется ребер на простым, если ребра в нем не повторяются.
[05:21.840 --> 05:34.720]  Ну, примеры какие-нибудь простые, значит. Давайте я буду рисовать примеры для ориентированных
[05:34.720 --> 05:42.120]  графов. Вот что-нибудь такое, это ребер на простой путь, да, то есть, вот если мы так будем идти по
[05:42.120 --> 05:46.640]  графу, то понятно, что это путь, потому что каждая пара соседних соединяет ребром, и при этом понятно,
[05:46.640 --> 05:50.320]  что никакое ребро не используется дважды. Да, вот эта вот вершинка используется дважды, то есть,
[05:50.320 --> 05:54.840]  мы в нее раз вошли, потом еще раз вошли, но никакое ребро дважды не используется. То есть,
[05:54.840 --> 06:00.080]  это корректный, то есть, это путь, который является ребер на простым. Ну, а что-нибудь вот такое,
[06:00.080 --> 06:09.160]  например, это уже не ребер на простой, потому что вот это ребро используется дважды. Ну, понятно.
[06:09.160 --> 06:26.720]  Дальше путь называется вершина простым, если вершины в нем не повторяются.
[06:39.160 --> 06:51.280]  Так, ну я вот даже не знаю. А, ну, собственно, да, вот это вот уже будет не вершина простой,
[06:51.280 --> 06:55.560]  потому что эта вершина взялась дважды. И в случае, что мы можем сказать, это просто вот какая-то
[06:55.560 --> 07:01.720]  такая цепочка, в которой все вершины различны. Это будет вершина простой путь. Ну и вообще,
[07:01.720 --> 07:07.160]  вот эта вот вершина простой часто сокращается до просто простого. Здесь я могу просто написать
[07:07.160 --> 07:13.960]  простой. Путь называется простым, если в нем вершины не повторяются. Простое замечание,
[07:13.960 --> 07:31.040]  что из вершины простоты следует реберная простота. Потому что если вершины не повторяются,
[07:31.040 --> 07:35.320]  то ребра точно не повторяются, потому что чтобы повторить ребро, надо и левый конец,
[07:35.320 --> 07:41.040]  и если правый конец повторить, значит, он не может быть вершиной простой. Хорошо.
[07:41.040 --> 08:08.680]  Дальше цикл. Путь в один и так далее в икан называется циклом, если первые и последние вершины
[08:08.760 --> 08:21.560]  совпадают. Если в один равно в икан. Ну понятно, что-то вот такое, например. Вот такое или даже
[08:21.560 --> 08:32.000]  вот такое какое-нибудь. Тоже цикл. Здесь наследуется определение вершины простоты и реберной простоты.
[08:32.000 --> 08:37.040]  Значит, цикл реберной простой, если в нем ребра не повторяются, цикл вершины простой, если в нем все
[08:37.040 --> 08:41.640]  вершины не повторяются, ну кроме вот этой вот стартовой конечной. Понятно, что там, где начали, там же
[08:41.640 --> 08:45.720]  закончили, но вот вершинная простота, это когда нет таких вот самоперещений, когда никакая вершина
[08:45.720 --> 08:51.320]  не посещается, кроме вот, кроме стартовой, не посещается больше, чем один раз. Значит, замечание.
[08:51.320 --> 08:58.480]  Определение реберной и вершины простоты наследуется.
[09:21.320 --> 09:33.080]  Еще раз?
[09:37.080 --> 09:47.760]  Да-да-да. Ну еще раз. Тут как бы я сказал, что кроме вот этой вот вершинки, все остальные посещаются
[09:47.760 --> 09:54.040]  ровно один раз. Так, дальше, дальше, дальше. Достежимый. Да, сейчас, извините, будет просто много
[09:54.040 --> 09:59.240]  простых определений, многие из которых вы знаете, но я считаю, что должен их формально вести. Значит,
[09:59.240 --> 10:05.920]  мы говорим, что вершины, ну не так, из вершины У достижимы вершина В.
[10:05.920 --> 10:30.480]  Если существует путь из У в В. Если существует какой-то путь в 1, тогда или в К, что он начинается в У,
[10:30.480 --> 10:43.560]  а заканчивается в В. Вот. Значит, и дальше здесь, в зависимости от того, какой у нас граф ориентированный
[10:43.560 --> 10:47.120]  или неориентированный, то есть до этого момента неважно было, какой граф ориентированный или
[10:47.120 --> 10:54.160]  неориентированный, вот. А сейчас можно будет вести отношение эквивалентности по-разному, ну в общем,
[10:54.160 --> 11:00.120]  отношение достижимости по-разному в ориентированном и неориентированном графе. Значит, определение,
[11:00.120 --> 11:12.040]  если G неориентированный граф, то отношением связанности можно назвать просто наличие пути из У в В,
[11:12.040 --> 11:22.720]  то есть две вершины связаны, если есть пути из одной в другую, то вводим отношение связанности.
[11:22.720 --> 11:41.120]  У связано с В, тиличку пишу, если из У есть путь В. Ну, раз граф неориентированный, то на самом деле
[11:41.640 --> 11:46.520]  наличие пути из У в В равносильно наличию обратного пути, потому что просто если мы ревершим порядок
[11:46.520 --> 11:50.480]  следования этих вершин, то это тоже будет путь в исходном графе, да? Потому что если V1,
[11:50.480 --> 11:57.280]  V2 это ребро, V2, V3 это ребро и т.д., ВК, МК это ребро, значит, когда весь порядок обращают, то все эти
[11:57.280 --> 12:01.240]  пары, поскольку они были неупорядочены, это тоже будет все ребра, при этом первые и последние
[12:01.240 --> 12:07.360]  поменяются местами. Значит, на самом деле наличие пути из У в В равносильно наличие пути из В в У, вот.
[12:07.360 --> 12:10.440]  простое утверждение, что на самом деле вот это отношение является отношением
[12:10.440 --> 12:25.360]  эквивалентности. Утверждение, отношение связности в неориентированном графе, это
[12:25.360 --> 12:38.560]  отношение эквивалентности. Так, все знают, что такое отношение эквивалентности? Отлично.
[12:48.160 --> 12:51.960]  Ну, доказывается тривиально по определению. Значит, что нам нужно от отношения эквивалентности?
[12:51.960 --> 12:56.760]  Во-первых, нам нужна рефлексивность. То есть, если мы возьмем произвольную вершинку У, то из У есть
[12:56.760 --> 13:01.320]  путь В. Но это очевидно, да? Можно просто стоять на месте, можно рассмотреть путь из одной вершины
[13:01.320 --> 13:08.520]  без ребер. Ну, тогда мы, соответственно, из У попадаем в У. Это рефлексивность. Значит, дальше
[13:08.520 --> 13:13.880]  симметричность. Тоже тривиально, если есть путь из У в В, то, как мы уже показали, есть путь из В в У.
[13:13.880 --> 13:20.480]  Потому что тот же самый путь, если его развернуть, он будет доказывать нам связанность между В и У. Ну,
[13:20.480 --> 13:26.960]  и, наконец... Это была симметричность. И, наконец, транзитивность. Если из У есть путь в В,
[13:26.960 --> 13:34.280]  из В есть путь в В, то понятно, что у путь из У в В, просто два пути склеить. Надо просто два
[13:34.280 --> 13:39.600]  пути склеить. Сначала из У добраться до В, потом из В добраться до в В. Это транзитивность.
[13:42.080 --> 13:46.520]  Ну, все, значит, это отношение эквивалентности. А раз у меня на вершинах ведено отношение
[13:46.520 --> 13:50.520]  то значит, если я по нему факторизую, то есть, разобью все на классы эквивалентности,
[13:50.520 --> 13:55.520]  то у меня получатся какие-то кусочки вершин моего графа, ну, точнее, множество вершин моего графа,
[13:55.520 --> 13:58.520]  и эти множество будет называться компонентами связности.
[14:01.520 --> 14:05.520]  Компоненты связности.
[14:08.520 --> 14:14.520]  Ну, то есть, формально определение компонент связности – это класс эквивалентности по этому отношению.
[14:15.520 --> 14:23.520]  Давайте это запишем, класс эквивалентности по отношению вот этому тильду, по отношению связности.
[14:28.520 --> 14:32.520]  А в случае ориентированного графа у нас будет немножко другое определение,
[14:34.520 --> 14:37.520]  потому что там уже вот такая штука не будет являться отношением эквивалентности.
[14:37.520 --> 14:40.520]  В частности, например, не будет симметричности,
[14:40.520 --> 14:46.520]  потому что если мы просто оставим наличие пути слева направо, то это не обязательно значит, что есть путь справа налево,
[14:46.520 --> 14:49.520]  не обязательно будет симметричность, потому что, если у меня все ориентировано,
[14:49.520 --> 14:53.520]  то наличие пути из УВУ не означает гарантированного наличия пути из ВВУ.
[14:53.520 --> 14:57.520]  Поэтому в случае ориентированного графа будет немножко другое определение.
[14:57.520 --> 15:11.520]  Если же ориентированный граф, то вводим отношение сильной связности между вершинами.
[15:11.520 --> 15:27.520]  У состоит в отношении с В, если есть оба пути из УВ и из ВВ.
[15:27.520 --> 15:35.520]  Существует путь из УВ и существует путь из ВВ.
[15:42.520 --> 15:45.520]  То есть мы требуем, чтобы был путь в обе стороны.
[15:45.520 --> 15:49.520]  На самом деле здесь тоже самое можно было бы написать, что здесь есть путь в обе стороны, из УВ и из ВВ,
[15:49.520 --> 15:52.520]  но на самом деле для этого достаточно, конечно, только вот этого.
[15:52.520 --> 15:55.520]  Ну и то же самое, это отношение эквивалентности.
[15:55.520 --> 16:01.520]  Значит, тильдочка, это отношение эквивалентности.
[16:01.520 --> 16:10.520]  Доказательство столь же тривиально, значит, рефлексивность.
[16:10.520 --> 16:13.520]  Почему у состоит в отношении тильда с У?
[16:13.520 --> 16:16.520]  Ну потому что чтобы попасть из УВУ, надо стоять на месте.
[16:16.520 --> 16:19.520]  Почему есть симметричность?
[16:19.520 --> 16:22.520]  Почему из такого следует вот это?
[16:22.520 --> 16:26.520]  Ну просто по определению, что значит у тильдочка В, значит есть путь отсюда сюда и отсюда сюда.
[16:26.520 --> 16:29.520]  А надо доказать, что есть путь отсюда сюда и отсюда сюда.
[16:30.520 --> 16:42.520]  Последняя транзитивность, что если у в отношении с В, В в отношении с ВВ, то у в отношении с ВВ.
[16:42.520 --> 16:48.520]  Ну, то же самое. Что значит, что у в отношении с В.
[16:48.520 --> 16:50.400]  Значит есть путь из УВ, есть путь из ВВ.
[16:50.400 --> 16:55.520]  Значит есть путь из УВВ обратно, раз В в отношении СВ,
[16:55.520 --> 16:58.520]  его есть путь отсюда сюда, есть путь отсюда сюда, значит есть путь из УВУ,
[16:58.520 --> 17:05.520]  Ну короче, в общем, доказательство почти дословно повторяет доказательство в случае неориентированного графа.
[17:05.520 --> 17:09.520]  Ну вот просто нам нужно, чтобы были в обе стороны явным образом.
[17:09.520 --> 17:13.520]  Поэтому это тоже будет отношение эквивалентности на вершинах.
[17:13.520 --> 17:19.520]  И все множество вершин опять распадается на несколько классов.
[17:19.520 --> 17:25.520]  Теперь эти классы будут называться компонентами сильной связности, не просто компонент связности, а компонент сильно связанности.
[17:25.520 --> 17:35.520]  То есть вот опять есть какое-то разбиение вершин на множество, это уже компоненты сильной связности.
[17:42.520 --> 17:48.520]  Какое еще есть отличие? Отличие, например, в том, что когда вы рассматриваете компоненты сильно связанности в ориентированном графе,
[17:48.520 --> 17:52.520]  здесь могут быть какие-то ребра, лежащие вне компонента.
[17:52.520 --> 17:55.520]  Например, может быть какое-нибудь вот такое ребро спокойно.
[17:55.520 --> 17:58.520]  То есть между компонентами сильной связанности могут быть ребра.
[17:58.520 --> 18:00.520]  Это как бы ничему не противоречит.
[18:00.520 --> 18:05.520]  А в случае неориентированного графа у нас ребер между компонентами точно быть не может.
[18:05.520 --> 18:09.520]  Потому что если бы какое-нибудь ребро было, то это бы означало тогда, что между его концами есть путь.
[18:09.520 --> 18:12.520]  Значит, они на самом деле лежат в отношении.
[18:12.520 --> 18:17.520]  Потому что для отношения нам достаточно пути, ну как бы, просто пути между вершинами.
[18:17.520 --> 18:20.520]  Тогда вот эти компоненты надо было бы на самом деле склеить.
[18:20.520 --> 18:25.520]  А здесь такого не возникает, потому что наличие ориентированного ребра из одной компонента в другую
[18:25.520 --> 18:28.520]  означает лишь, что есть путь в одну сторону, отсюда-сюда.
[18:28.520 --> 18:33.520]  Но чтобы они попали в отношение, нам надо чтобы еще в обратную сторону было ребро.
[18:33.520 --> 18:35.520]  Ну понятно, что...
[18:35.520 --> 18:37.520]  То есть в принципе ребра здесь могут быть.
[18:37.520 --> 18:40.520]  Главное, чтобы не было, грубо говоря, в две стороны их.
[18:40.520 --> 18:42.520]  Вот тогда это плохо.
[18:42.520 --> 18:45.520]  Тогда вот эти компоненты были бы тоже в отношении, их пришлось бы склеить.
[18:45.520 --> 18:48.520]  Если такого нет, то никакой противоречия тоже нет.
[18:50.520 --> 18:52.520]  Отлично.
[18:52.520 --> 18:55.520]  Так, ну вот, вроде базовые определения все обсудили.
[18:55.520 --> 19:04.520]  Теперь давайте обсудим, как можно хранить эти графы в памяти компьютера.
[19:10.520 --> 19:13.520]  Давайте рассмотрим три подхода.
[19:13.520 --> 19:15.520]  У каждого есть свои удобства.
[19:15.520 --> 19:17.520]  Первая – это матрица смежности просто.
[19:21.520 --> 19:24.520]  Кажется, мы ее рассматривали пару лекций назад.
[19:24.520 --> 19:28.520]  Значит, если у меня n всего вершин, то синонта мощность множества v.
[19:28.520 --> 19:31.520]  Тогда можно завести квадратную матрицу n на n.
[19:31.520 --> 19:37.520]  И в ячейках, в этой же ячейке, писать единичку, если есть ребро из и в жи.
[19:38.520 --> 19:45.520]  Значит, на перещении и этой строки житого столбца мы ставим единичку, если есть ребро из этой вершинки в житую.
[19:45.520 --> 19:47.520]  Значит, напишу так.
[19:47.520 --> 19:55.520]  m и та жита равно единице, если пара и жит в множестве е, ну или иначе.
[19:58.520 --> 20:03.520]  Ну, здесь опять, да, вот эти круглые скобки означают либо упорядоченную пару, если граф ориентирован,
[20:03.520 --> 20:05.520]  либо неупорядоченную, то есть вот такие скобки.
[20:05.520 --> 20:07.520]  Если граф неориентированный.
[20:09.520 --> 20:11.520]  Вот. Что здесь, значит, хорошего?
[20:11.520 --> 20:16.520]  Ну, хорошего то, что мы можем за от единицы проверить наличие любого заданного ребра.
[20:16.520 --> 20:21.520]  То есть если мне сказали, скажи, пожалуйста, есть ли в данном графе ребро из у в,
[20:21.520 --> 20:27.520]  мне нужно просто посмотреть на пересечение этой строки житого столбца, ну, то есть просто м у в.
[20:27.520 --> 20:29.520]  И то, что там лежит, будет ответом.
[20:29.520 --> 20:34.520]  То есть плюс, это то, что мы за от единицы умеем проверять наличие ребра.
[20:38.520 --> 20:40.520]  Проверять наличие ребра.
[20:42.520 --> 20:45.520]  Минус, ну понятно, что жрет много памяти.
[20:46.520 --> 20:51.520]  Требует квадратичной памяти.
[20:53.520 --> 20:56.520]  И это невыгодно, если ваш граф очень разреженный.
[20:56.520 --> 20:59.520]  То есть если, скажем, м, число ребер,
[21:01.520 --> 21:04.520]  если число ребер сильно меньше, чем квадрат множества вершин,
[21:04.520 --> 21:07.520]  то такой подход будет, ну, не очень оптимальным.
[21:07.520 --> 21:10.520]  В нем хранится слишком много нулей.
[21:10.520 --> 21:14.520]  То есть для разреженных графов, для графов, где м мало, это не оптимально.
[21:18.520 --> 21:20.520]  Значит, первый подход.
[21:26.520 --> 21:30.520]  Второй подход, еще менее интеллектуальный, это просто список ребер.
[21:36.520 --> 21:38.520]  Список ребер. Ну, значит, мы смотрим на граф,
[21:38.520 --> 21:43.520]  просто перечисляем все пары вершин, которые являются ребрами.
[21:43.520 --> 21:46.520]  То есть все пары у в такие, что у в это ребро.
[21:46.520 --> 21:53.520]  Например, там у1, в1, у2, у3, у4, у5, у6, у7, у8, у9, у10.
[21:53.520 --> 21:59.520]  У1, в1, у2, в2, и так далее, ум, вм.
[21:59.520 --> 22:05.520]  Вот вы просто передаете все такие пары, как, собственно, описание вашего графа.
[22:05.520 --> 22:11.520]  Ну, здесь из плюса я могу назвать только то, что это в каком-то смысле естественное представление.
[22:11.520 --> 22:13.520]  Естественность.
[22:16.520 --> 22:20.520]  Например, так, ну, если мы хотим, как бы, описать граф,
[22:20.520 --> 22:22.520]  то, наверное, это почти что самый простой способ.
[22:22.520 --> 22:24.520]  То есть вы видите какую-нибудь картинку, вот такую.
[22:26.520 --> 22:30.520]  Чтобы описать этот граф в виде, ну, там, не картинки,
[22:30.520 --> 22:33.520]  а в виде чего-то более-менее формального, в виде списка,
[22:33.520 --> 22:38.520]  короче, чтобы как-то его представить не картинкой, а каким-то текстом, да, каким-то данными,
[22:38.520 --> 22:42.520]  то, наверное, проще всего просто перечислить, между какими парами вершин есть ребра.
[22:43.520 --> 22:47.520]  Вот, вы говорите, что есть ребра между 1, 2, 2, 3, 3, 1, есть ребра между 3 и 4.
[22:47.520 --> 22:51.520]  В частности, вам не нужно перечислять все пары вершин, между которыми нет ребра.
[22:51.520 --> 22:53.520]  Вам нужно только те, между которыми есть ребро.
[22:55.520 --> 23:01.520]  Ну, а минусы, это как бы, что, по сути, вы никакой информации быстро вытащить отсюда не можете.
[23:04.520 --> 23:08.520]  Ну, неудобность я напишу, неудобство обработки.
[23:10.520 --> 23:14.520]  То есть если так хранить граф, то мы, по сути, никакой полезной информации извлечь не сможем.
[23:14.520 --> 23:18.520]  Например, чтобы проверить, есть какое-то ребро или нет,
[23:18.520 --> 23:20.520]  мне придется по всему этому списку пройти.
[23:20.520 --> 23:24.520]  Проверить, что есть ли пара, равная данной паре УВ.
[23:24.520 --> 23:27.520]  Чтобы, например, узнать, с кем соединена данная вершина У,
[23:27.520 --> 23:32.520]  то есть вывести всех соседей У, вывести все вершинки, с которыми У соединена ребром.
[23:32.520 --> 23:34.520]  Тогда мне опять надо по всему этому списку пройти
[23:34.520 --> 23:37.520]  и вывести все пары, где есть вершинка У.
[23:37.520 --> 23:42.520]  Короче, неудобно работать, мы тут ничего за быстро извлечь отсюда не сможем,
[23:42.520 --> 23:44.520]  если будем так граф хранить.
[23:50.520 --> 23:54.520]  Ну и третья, собственно, то, чем мы будем пользоваться, это список смежности.
[23:54.520 --> 23:57.520]  Я даже напишу списки смежности.
[24:01.520 --> 24:02.520]  Начнется следующее представление.
[24:02.520 --> 24:08.520]  Давайте для каждой вершины хранить список вершин других, с которыми я нас соединяю ребром.
[24:08.520 --> 24:10.520]  У меня будет n списков,
[24:10.520 --> 24:15.520]  а у меня будет 1 список вершин других, с которыми я соединяю ребром.
[24:15.520 --> 24:19.520]  У меня будет n списков и l, скажем, УТ,
[24:19.520 --> 24:23.520]  и это все такие В, что УВ это ребро графа.
[24:29.520 --> 24:31.520]  Утый список, это список,
[24:31.520 --> 24:37.520]  ну да, Утый список, это множество тех вершин, в которые есть ребро из У.
[24:37.520 --> 24:41.520]  То есть вот есть какая-то вершинка У, мы перечисляем, по сути, просто всех ее соседей,
[24:41.520 --> 24:45.520]  куда мы можем перейти за 1 шаг, куда мы можем перейти за 1 ребро.
[24:45.520 --> 24:49.520]  Ну список, тут как бы можно воспринимать как там односвязанный список,
[24:49.520 --> 24:53.520]  но нам будет достаточно вектора. Всегда с вектором будет удобнее всего работать.
[24:53.520 --> 24:57.520]  Вектор просто номеров вершин, в которые есть ребро из данной.
[24:57.520 --> 24:59.520]  Значит, чего?
[24:59.520 --> 25:04.520]  Ну плюсы, собственно, здесь можно почти все написать.
[25:04.520 --> 25:07.520]  Во-первых, это эффективность представления в памяти,
[25:07.520 --> 25:13.520]  только линейного размера памяти, n плюс m памяти.
[25:13.520 --> 25:15.520]  То есть почему n плюс m?
[25:15.520 --> 25:17.520]  Напоминаю, n это число вершин, m это число ребер.
[25:17.520 --> 25:21.520]  Значит, n у меня всего списков, то есть у меня тратится n,
[25:21.520 --> 25:25.520]  чтобы создать вот этот вот, ну, грубо говоря, вектор векторов,
[25:25.520 --> 25:27.520]  вектор списков m.
[25:27.520 --> 25:29.520]  Ну, это суммарный размер всех списков, потому что
[25:29.520 --> 25:31.520]  у меня есть один список.
[25:31.520 --> 25:33.520]  Если, например, даже если граф неориентированный,
[25:33.520 --> 25:37.520]  то каждое ребро дает мне как бы два вхождения в списке.
[25:37.520 --> 25:40.520]  Если у меня есть ребро из u в v, точнее между u и v,
[25:40.520 --> 25:42.520]  то у меня в списке для u будет хранится v,
[25:42.520 --> 25:44.520]  и в списке для v будет хранится u.
[25:44.520 --> 25:48.520]  Поэтому суммарный размер всех списков – это на самом деле удвоенное число ребер.
[25:48.520 --> 25:51.520]  То есть если граф неориентированный, то сумма размеров всех списков – это 2m.
[25:51.520 --> 25:54.520]  Если граф ориентированный, то сумма всех списков –
[25:54.520 --> 25:56.520]  сумма длинных списков – это 2m.
[25:56.520 --> 25:59.520]  Потому что каждое ребро дает ровно одно вхождение в один из списков.
[25:59.520 --> 26:05.520]  Поэтому память линейная по представлению графа, по n плюс m.
[26:05.520 --> 26:08.520]  Так, что еще?
[26:08.520 --> 26:10.520]  Значит, с памятью все хорошо.
[26:10.520 --> 26:12.520]  Еще плюс, что мы можем...
[26:12.520 --> 26:17.520]  Ну, по сути, у меня для каждой вершины хранится множество ее соседей.
[26:17.520 --> 26:20.520]  Для каждой вершины.
[26:20.520 --> 26:25.520]  Для каждой вершины хранится множество ее соседей.
[26:25.520 --> 26:35.520]  Для каждой вершины знаем множество соседей.
[26:35.520 --> 26:37.520]  Ну, соседей – это ровно то, что мы храним.
[26:37.520 --> 26:42.520]  Это список тех вершин, в которые есть ребро.
[26:42.520 --> 26:46.520]  Если, например, нам приходит запрос «скажите, пожалуйста, всех друзей Васи»,
[26:46.520 --> 26:48.520]  мы просто смотрим на список Васи,
[26:48.520 --> 26:51.520]  печатаем все вершинки из этого списка.
[26:57.520 --> 27:00.520]  Так, ну можно здесь еще к минусу отнести то,
[27:00.520 --> 27:04.520]  что нельзя за от 1 как-то эффективно проверить,
[27:04.520 --> 27:06.520]  есть ли данное ребро в графе или нет.
[27:06.520 --> 27:10.520]  Давайте я напишу, что это минус за от 1.
[27:10.520 --> 27:15.520]  Нельзя проверить наличие ребра в графе.
[27:16.520 --> 27:26.520]  Ну, потому что если мне сообщили пару УВ,
[27:26.520 --> 27:29.520]  то мне, значит, нужно перейти в УТ и список
[27:29.520 --> 27:32.520]  и проверить, есть там числовые или нет.
[27:32.520 --> 27:36.520]  На самом деле, это можно как-нибудь решить.
[27:36.520 --> 27:39.520]  Например, можно вместе с каждым вот этим вот вектором,
[27:39.520 --> 27:42.520]  вместе с каждым списком хранить какое-нибудь дерево поиска.
[27:42.520 --> 27:44.520]  И, соответственно, тогда за логарифом проверять,
[27:44.520 --> 27:48.520]  есть такое ребро или нет, то есть есть ли В в списке для У.
[27:48.520 --> 27:51.520]  Либо, на самом деле, я вот в конце прошлой пары говорил,
[27:51.520 --> 27:53.520]  что на самом деле вот эта вот штука решается
[27:53.520 --> 27:55.520]  совершенным хэшированием.
[28:00.520 --> 28:02.520]  Потому что, по сути, что у нас есть?
[28:02.520 --> 28:05.520]  У нас есть фиксированное множество ребер, М-ребер.
[28:05.520 --> 28:08.520]  Давайте создадим вот с помощью совершенного хэширования
[28:08.520 --> 28:11.520]  хэштаблицу, которая за от 1 позволяет проверять наличие
[28:11.520 --> 28:13.520]  ребра в графе или нет.
[28:13.520 --> 28:16.520]  Ну а дальше, чтобы проверить, есть какое-то данное ребро
[28:16.520 --> 28:18.520]  в графе или нет, мы считаем его хэш.
[28:18.520 --> 28:20.520]  Ну там, как обычно, сначала внешний, потом внутренний.
[28:20.520 --> 28:23.520]  Вот в этой вот табличке размера k квадрат.
[28:23.520 --> 28:26.520]  То есть, если у меня в ячейке попало k ключей,
[28:26.520 --> 28:29.520]  то будет здесь хэштаблица внутренняя размера k квадрат.
[28:29.520 --> 28:32.520]  Я считаю внутренний хэш h и t.
[28:32.520 --> 28:34.520]  И проверяю, если на этом месте лежит правильное ребро,
[28:34.520 --> 28:36.520]  то значит, это оно.
[28:36.520 --> 28:38.520]  Если там вообще пусто или лежит какое-то другое ребро,
[28:38.520 --> 28:40.520]  значит, исходного ребра в графе нет.
[28:40.520 --> 28:43.520]  Поэтому вот эта вот штука, она как бы, ну,
[28:43.520 --> 28:46.520]  исправляется применением какого-то другого алгоритма.
[28:46.520 --> 28:50.520]  Неявным образом мы вот используем списки смежности,
[28:50.520 --> 28:54.520]  а скорее совершенное хэширование поверх нашего графа.
[28:54.520 --> 28:56.520]  Окей?
[28:56.520 --> 28:58.520]  Хорошо.
[29:00.520 --> 29:04.520]  Так, значит, со способами хранения вроде разобрались.
[29:04.520 --> 29:07.520]  Ну, теперь переходим к DFS.
[29:10.520 --> 29:13.520]  Значит, DFS – это способ обхода графа.
[29:15.520 --> 29:18.520]  Давайте я тут напишу DFS.
[29:18.520 --> 29:23.520]  Depth, First, Search.
[29:25.520 --> 29:28.520]  По-русски это поиск в глубину.
[29:29.520 --> 29:32.520]  По-русски это поиск в глубину.
[29:37.520 --> 29:39.520]  Значит, поиск в глубину работает неформально так.
[29:39.520 --> 29:42.520]  Мы стоим в какой-то вершинке, у нас есть список,
[29:42.520 --> 29:45.520]  вот мы считаем теперь, что у нас граф хранится в виде списка смежности,
[29:45.520 --> 29:47.520]  то есть для каждой вершины есть список,
[29:47.520 --> 29:49.520]  вершинку, куда можно попасть за одно ребро.
[29:49.520 --> 29:53.520]  Вот мы стоим в вершинке, есть какие-то исходящие из нее ребра.
[29:53.520 --> 29:55.520]  Есть исходящие ребра.
[29:55.520 --> 29:59.520]  Тогда просто в каждую из них попробуем перейти
[29:59.520 --> 30:01.520]  и рекурсивно запустить DFS оттуда.
[30:01.520 --> 30:03.520]  То есть наша цель – это как бы обойти весь граф
[30:03.520 --> 30:07.520]  и, например, отметить посещенными те вершины, которые достижимы, были из стартовой.
[30:07.520 --> 30:11.520]  Вот есть какая-то стартовая вершинка, я помечаю ее посещенной.
[30:11.520 --> 30:15.520]  И дальше рекурсивно, от всех вот этих вот запускаюсь,
[30:15.520 --> 30:18.520]  тоже рекурсивно прошу посетить все, что достижено из них.
[30:18.520 --> 30:22.520]  Да, и если наша цель – это очень простая, просто посетить все, что достижено из V,
[30:22.520 --> 30:24.520]  то сработает такой простой алгоритм.
[30:24.520 --> 30:28.520]  Пометь эту посещенной и запусти алгоритм для всех этих вот рекурсивных.
[30:30.520 --> 30:34.520]  Давайте сделаем это с некоторыми еще дополнительными данными.
[30:37.520 --> 30:39.520]  Во-первых, мне нужен будет вектор векторов G.
[30:44.520 --> 30:49.520]  Это, собственно, то, что у меня там L обозначено, списки смежности.
[30:49.520 --> 30:53.520]  Значит, G от V – это список вершин, в которые есть ребро из V.
[30:53.520 --> 30:56.520]  G от V – это то, куда можно попасть из V за один шаг.
[30:58.520 --> 31:01.520]  Дальше, так, я, чтобы ничего не забыть, подсмотрю.
[31:06.520 --> 31:09.520]  Мне нужны будут вектора T in, T out.
[31:11.520 --> 31:14.520]  Значит, это будет время входа и выхода в каждую вершину.
[31:15.520 --> 31:18.520]  Нужен будет какой-то таймер, чтобы мерить время.
[31:20.520 --> 31:23.520]  Нужен вектор цветов.
[31:24.520 --> 31:26.520]  String color.
[31:31.520 --> 31:34.520]  На всякий случай еще будем хранить предков, родителей.
[31:34.520 --> 31:36.520]  Vector and parent.
[31:37.520 --> 31:42.520]  Значит, сейчас напишем код, потом будем разбираться, что все эти вектора хранят.
[31:43.520 --> 31:45.520]  Значит, void DFS.
[31:46.520 --> 31:52.520]  Давайте DFS будет принимать вершинку, какую-то V, от которой мы пытаемся все обойти.
[31:53.520 --> 31:58.520]  И в качестве второго параметра передадим еще предка, которая, по умолчанию, равен минус единице.
[32:00.520 --> 32:03.520]  То есть это родительская вершина, грубо говоря, то, откуда мы пришли.
[32:03.520 --> 32:07.520]  И, например, если V – это первая вершина, которую мы обходим, то мы ниоткуда не пришли.
[32:07.520 --> 32:10.520]  Соответственно, родитель у меня минус единичка.
[32:10.520 --> 32:13.520]  Иначе мы будем передавать предыдущую вершину на пути.
[32:14.520 --> 32:18.520]  Так, ну давайте сначала сделаем следующее.
[32:19.520 --> 32:23.520]  Скажем, что мы в эту вершинку вошли, t и на t равно таймер плюс-плюс.
[32:23.520 --> 32:27.520]  То есть мы в нее вошли, в какой-то момент времени таймер, и сразу таймер увеличили.
[32:28.520 --> 32:35.520]  То есть мы считаем, что есть вот это время, таймер, который отмеряет, сколько времени прошло с начала работы программы.
[32:35.520 --> 32:39.520]  И для каждой вершинки мы меряем время входа в нее и время выхода из нее.
[32:40.520 --> 32:43.520]  Соответственно, когда мы вошли, мы сюда написали таймер и таймер увеличили.
[32:46.520 --> 32:49.520]  Далее выставляем parent.
[32:50.520 --> 32:52.520]  Parent от V равно P.
[32:53.520 --> 32:58.520]  Ну parent – это вот как раз то, что сюда перейдется в качестве второго аргумента.
[32:58.520 --> 33:01.520]  Родительская вершина, откуда мы пришли в V.
[33:01.520 --> 33:07.520]  И еще я назначу цвет этой вершинки, скажу, что она сейчас серая.
[33:08.520 --> 33:10.520]  Grey.
[33:12.520 --> 33:14.520]  Причем изначально все они были white.
[33:14.520 --> 33:17.520]  Значит у меня у вершин будет всего три цвета – белый, серый и черный.
[33:17.520 --> 33:23.520]  Вот изначально все белые. Давайте считаем, что здесь изначально лежат white для всех вершин.
[33:24.520 --> 33:26.520]  Зашел в вершину, пометил ее серой.
[33:26.520 --> 33:30.520]  То есть она раньше была белая, белая такая нетронутая, чисто не загрязненная белая.
[33:30.520 --> 33:34.520]  Захожу в нее, отмечаю ее серой, что она сейчас в обработке.
[33:35.520 --> 33:37.520]  Так, вроде все.
[33:37.520 --> 33:41.520]  Теперь давайте мы пройдем по всем соседям.
[33:41.520 --> 33:44.520]  То есть попытаемся пойти по ребру.
[33:53.520 --> 33:56.520]  Вот такой цикл позволит мне как раз проитерлироваться по всем.
[33:56.520 --> 34:02.520]  Ну вот если в это вот эта штука, то тут пробегает список всех возможных детей, куда можно перейти.
[34:04.520 --> 34:06.520]  Так, открываем скобку, переходим сюда.
[34:11.520 --> 34:17.520]  Напишу следующее. Если цвет вершины 2 не белый, тогда continue.
[34:19.520 --> 34:26.520]  Если color2 не равно white, тогда continue.
[34:26.520 --> 34:35.520]  В заявке soybeans, что если вершина не белая и по сути это значит, что в нее вошел dfs,
[34:35.520 --> 34:38.520]  когда-либо в нее вошел dfs, тогда давайте просто не будем заново запускаться
[34:38.520 --> 34:42.520]  потому что, если она не белая, то значит в нее когда-то входил dfs.
[34:44.520 --> 34:46.520]  Ну там, в какой-то другой момент времени возможно.
[34:46.520 --> 34:48.520]  И по сути мы уже обошли все, что из него можно было.
[34:50.520 --> 34:52.520]  Поэтому давайте не будем заново запускаться.
[34:52.520 --> 34:54.520]  Нет смысла пытаться обходить что-то из вершинки.
[34:54.520 --> 34:59.000]  из нее пытались что-то обходить. Поэтому в таком случае мы ее просто скипаем.
[34:59.000 --> 35:03.880]  Ну а иначе, если color of tu равно white, мы рекурсивно запускаемся с параметрами tu и v.
[35:03.880 --> 35:11.200]  То есть была вершина v, была вершина tu, тоже белая вершина, в которой мы еще ни разу не бывали.
[35:11.200 --> 35:16.480]  Тогда давайте мы рекурсивно запустимся от нее с параметром v, как родительская вершина,
[35:16.480 --> 35:27.760]  откуда мы попали в tu. Все, на этом цикл заканчивается. И перед тем как выйти, давайте еще пометим вершинку.
[35:27.760 --> 35:39.120]  Давайте скажем, что мы из нее выходим. tout от v равно timer++. И скажем, что ее цвет черный.
[35:39.120 --> 35:46.160]  То есть мы ее обработали, она теперь черная, больше в нее заходить не надо. Конец.
[35:46.160 --> 35:56.480]  Так, есть ли вопросы по тому, что мы сделали? Пока я не расшифровываю, что здесь, как бы,
[35:56.480 --> 36:01.240]  что здесь по сути происходит, но есть ли вопросы, что тут написано может быть?
[36:01.240 --> 36:14.320]  Пока нет, да, пока нет, пока для нас-то одно и то же, но чуть позже будем.
[36:14.320 --> 36:22.320]  То есть я это скорее на будущее ввел, пока нам цвета, да, действительно серый и черный,
[36:22.320 --> 36:38.480]  но мы пока не отличаем. Лемма называется лемма о белых путях. Она утверждает следующее, смотрите,
[36:38.480 --> 36:45.240]  что если мы в какой-то момент запустились DFS от вершины v, и к моменту, когда мы сюда пришли,
[36:45.240 --> 36:51.000]  то есть к моменту времени, по сути, ti над v, когда мы вошли в вершинку v, если есть какой-то путь
[36:51.000 --> 36:56.560]  целиком состоящий из белых вершин, то есть вот здесь white, вот здесь white, вот здесь white,
[36:56.560 --> 37:03.000]  вот здесь white, короче, если есть целиком белый путь, то к моменту времени выхода из v, то есть к
[37:03.000 --> 37:08.440]  моменту ti от v, мы весь вот этот путь посетим, и они все будут помещены черными. То есть мы от них
[37:08.440 --> 37:15.720]  запустимся, обойдем, то есть запустим DFS от них, посетим из них все, что можно, завершатся те DFS,
[37:15.720 --> 37:23.840]  они перекрасятся в черные, и мы вернемся в v. Формально, значит, следующее, если в момент
[37:23.840 --> 37:38.680]  ti над v, то есть в момент входа в вершинку v, есть некий путь из v по белым вершинам,
[37:38.680 --> 37:58.800]  то к моменту ti от v все эти вершинки просмотрятся и будут помещены черными. Все вершины этого пути
[37:58.800 --> 38:15.560]  будут черными. Ну а черными они могут стать только если от них DFS запустился и целиком отработал. То
[38:15.560 --> 38:22.800]  есть если я стою v, DFS сейчас стоит v, и есть какой-то путь по белым вершинкам, ну вниз, да, по ребрам,
[38:22.800 --> 38:27.280]  вот есть такой путь по белым вершинкам, тогда до того, как мы выйдем из v, до того, как мы целиком
[38:27.280 --> 38:32.160]  обработаем вершину v, у меня успеют обработаться целиком все вот эти вот вершинки по всему белому
[38:32.160 --> 38:42.080]  пути. Так, ну доказательства. Пусть не так, пусть для какой-то вершинки v был какой-то белый путь
[38:42.080 --> 39:01.480]  к моменту времени входа в нее, давайте на другой доске нарисую все-таки, к моменту времени входа v
[39:01.480 --> 39:09.560]  был некий путь по белым вершинам из нее, white, white, white, white. Пусть к моменту времени выхода из v,
[39:09.560 --> 39:18.120]  к моменту t-out от v, не все здесь черные, тогда давайте рассмотрим самую высокую не черную,
[39:18.120 --> 39:29.720]  рассмотрим самую высокую, ну то есть самую близкую к v, не черную вершину
[39:29.720 --> 39:50.560]  в момент времени t-out от v. Я предлагаю, что они не все черные к моменту времени выхода,
[39:50.560 --> 39:55.760]  давайте из этих не черных рассмотрим самую верхнюю, то есть пусть, например, это черное,
[39:55.760 --> 40:01.160]  это черное, а вот это не черное. Это перекрасилось, это перекрасилось, а это не перекрасилось,
[40:01.160 --> 40:10.720]  ну то есть по крайней мере не черное. Я назову эту вершинку u. Какая она тогда может быть? Если она
[40:10.720 --> 40:20.560]  не черная, то она либо белая, либо серая. Ну давайте рассмотрим оба случая. Пусть u белая. Если u белая,
[40:20.600 --> 40:26.640]  тогда давайте рассмотрим тот момент, когда обрабатывалась эта предыдущая вершина, раз
[40:26.640 --> 40:32.680]  она стала черной как к моменту времени выхода из v, она черная, значит, повторюсь, стать черной она
[40:32.680 --> 40:36.420]  могла, только если DFS от нее запустился. Потому что вот эта строчка есть только в момент времени выхода,
[40:36.420 --> 40:43.240]  да, в момент времени выхода из DFS. Значит, если она черная, то DFS из нее целиком работался. Но,
[40:43.240 --> 40:49.440]  извините, если от нее целиком работался DFS, а вот эта вот штука белая, тогда у нее DFS не
[40:49.440 --> 40:51.440]  и не просмотрел почему-то это ребро.
[40:51.440 --> 40:53.440]  Потому что если бы мы стояли здесь и
[40:53.440 --> 40:55.440]  прошлись по всем исходящим ребрам,
[40:55.440 --> 40:57.440]  то мы обязаны были в эту белую вершинку перейти,
[40:57.440 --> 40:59.440]  потому что белые мы не скипаем, мы в них спускаемся.
[40:59.440 --> 41:01.440]  Ну, противоречие, да?
[41:01.440 --> 41:03.440]  Потому что
[41:03.440 --> 41:05.440]  противоречие так как
[41:05.440 --> 41:07.440]  рассматривалось
[41:11.440 --> 41:13.440]  ребро
[41:13.440 --> 41:15.440]  u,
[41:15.440 --> 41:17.440]  sorry, p запятая u,
[41:17.440 --> 41:19.440]  и p это вот это вот предыдущие вершины на пути.
[41:19.440 --> 41:21.440]  Согласны, что такого не может быть?
[41:21.440 --> 41:23.440]  Вот.
[41:23.440 --> 41:25.440]  Ну и второй случай, когда она серая,
[41:25.440 --> 41:27.440]  u серая,
[41:29.440 --> 41:31.440]  что это значит?
[41:31.440 --> 41:33.440]  Это значит, что мы до нее как-то
[41:33.440 --> 41:35.440]  дошли, но не успели выйти.
[41:35.440 --> 41:37.440]  Дошли, но не успели выйти.
[41:37.440 --> 41:39.440]  Что это тогда означает?
[41:39.440 --> 41:41.440]  Ну, смотрите, я напишу такую цепочку неравенства, из которой все будет следовать.
[41:41.440 --> 41:43.440]  Значит, во-первых,
[41:43.440 --> 41:45.440]  t на тв меньше, чем
[41:45.440 --> 41:47.440]  t на тв.
[41:47.440 --> 41:49.440]  Это следует из того, что
[41:49.440 --> 41:51.440]  когда мы вошли в v,
[41:51.440 --> 41:53.440]  u еще белая.
[41:53.440 --> 41:55.440]  Значит, мы в нее только после входим,
[41:55.440 --> 41:57.440]  и она становится серой когда-то позднее.
[41:57.440 --> 41:59.440]  Поэтому t на t больше, чем t на v.
[41:59.440 --> 42:01.440]  С другой стороны, поскольку она серая
[42:01.440 --> 42:03.440]  в момент времени t от v,
[42:03.440 --> 42:05.440]  то я могу продолжить цепочку вот так.
[42:05.440 --> 42:07.440]  Значит, еще раз.
[42:07.440 --> 42:09.440]  Вот это следует из того, что
[42:09.440 --> 42:11.440]  вершинка u белая
[42:11.440 --> 42:13.440]  в момент времени t на тв.
[42:13.440 --> 42:15.440]  Дальше. Вот это следует из того, что вершинка u
[42:17.440 --> 42:19.440]  не белая в момент времени
[42:19.440 --> 42:21.440]  t от v. То есть до того, как
[42:21.440 --> 42:23.440]  выйти из v, мы успели в нее зайти.
[42:23.440 --> 42:25.440]  Поэтому t на t меньше,
[42:25.440 --> 42:27.440]  чем t от v.
[42:27.440 --> 42:29.440]  А последнее следует из того, что
[42:29.440 --> 42:31.440]  в этот момент у нас не было
[42:31.440 --> 42:33.440]  вершинки у,
[42:33.440 --> 42:35.440]  а последнее следует из того, что
[42:35.440 --> 42:37.440]  вот эта серая в момент времени t от v.
[42:37.440 --> 42:39.440]  То есть мы еще не успели выйти из u,
[42:39.440 --> 42:41.440]  потому что выйти
[42:41.440 --> 42:43.440]  значит перекрасить в черный. То есть мы не успели
[42:43.440 --> 42:45.440]  перекрасить в черный, значит это
[42:45.440 --> 42:47.440]  происходит после этого. Согласны?
[42:47.440 --> 42:49.440]  Вот. Но такого быть не может.
[42:49.440 --> 42:51.440]  Давайте я вот здесь
[42:51.440 --> 42:53.440]  нарисую эту
[42:53.440 --> 42:55.440]  пару отрезков. Есть у меня отрезок
[42:55.440 --> 42:57.440]  вот такой вот
[42:57.440 --> 42:59.440]  t на tv,
[42:59.440 --> 43:01.440]  t от v,
[43:01.440 --> 43:03.440]  есть вот такой вот отрезок
[43:03.440 --> 43:05.440]  t на t,
[43:05.440 --> 43:07.440]  t на t.
[43:09.440 --> 43:11.440]  Вот. Но, конечно, такого быть не может в рекурсии,
[43:11.440 --> 43:13.440]  потому что, если мы, значит,
[43:13.440 --> 43:15.440]  ну,
[43:15.440 --> 43:17.440]  можно, например, в терминах stack и recursive рассуждать.
[43:17.440 --> 43:19.440]  Если мы, значит, спустились в какой-то момент
[43:19.440 --> 43:21.440]  времени в вершинку v,
[43:21.440 --> 43:23.440]  значит, добавляем ее в stack recursive. Потом
[43:23.440 --> 43:25.440]  запускаемся recursive над каких-то других вершин,
[43:25.440 --> 43:27.440]  в какой-то момент добавили на stack вершину u,
[43:27.440 --> 43:29.440]  то есть запустили dfs-ом от u.
[43:29.440 --> 43:31.440]  Когда до того, как выйти из v,
[43:31.440 --> 43:33.440]  понятное дело, надо бы целиком уработать u.
[43:33.440 --> 43:35.440]  Чтобы удалить
[43:35.440 --> 43:37.440]  из stack v, надо сначала удалить из stack
[43:37.440 --> 43:39.440]  все, что было положено после нее. Поэтому
[43:39.440 --> 43:41.440]  вот эта граница всякой должна была быть раньше, чем
[43:41.440 --> 43:43.440]  вот эта квадратная скобка.
[43:43.440 --> 43:45.440]  Поэтому, на самом деле,
[43:45.440 --> 43:47.440]  попутно мы доказали следующее утверждение,
[43:47.440 --> 43:49.440]  что вот эти отрезки нахождения
[43:49.440 --> 43:51.440]  внутри каждой вершины,
[43:51.440 --> 43:53.440]  t на tv, t от v, они,
[43:53.440 --> 43:55.440]  если и пересекаются, то вложены друг в друга.
[43:55.440 --> 43:57.440]  То есть, на самом деле, эта картинка не валидна.
[43:57.440 --> 43:59.440]  Валидной была бы только какая-то такая картинка.
[43:59.440 --> 44:01.440]  То есть, если они не пересекаются,
[44:01.440 --> 44:03.440]  то один вложен в другой.
[44:03.440 --> 44:05.440]  Согласны?
[44:05.440 --> 44:07.440]  Ну вот, хорошо.
[44:07.440 --> 44:09.440]  Тогда мы доказали лему о белых путях,
[44:09.440 --> 44:11.440]  что все, что было достижимо по белым,
[44:11.440 --> 44:13.440]  будет достигнуто к моменту времени
[44:13.440 --> 44:15.440]  выхода из v.
[44:17.440 --> 44:19.440]  Чудно.
[44:27.440 --> 44:29.440]  Следствие.
[44:37.440 --> 44:39.440]  Если запустить
[44:41.440 --> 44:43.440]  DFS от s,
[44:45.440 --> 44:47.440]  то после
[44:51.440 --> 44:53.440]  его обработки
[44:53.440 --> 44:55.440]  DFS посетит ровно те вершины,
[44:55.440 --> 44:57.440]  которые были достижимы из s в исходном графе.
[45:03.440 --> 45:05.440]  Только те вершины,
[45:13.440 --> 45:15.440]  которые были достижимы из s.
[45:15.440 --> 45:17.440]  То есть, если я весь граф изначально крашу в белый,
[45:17.440 --> 45:19.440]  запускаю с DFS
[45:19.440 --> 45:21.440]  вот какой-то произвольной вершинки s,
[45:21.440 --> 45:23.440]  то к моменту времени выхода из s,
[45:23.440 --> 45:25.440]  ну то есть, когда DFS обработается,
[45:25.440 --> 45:27.440]  когда он весь выполнится,
[45:27.440 --> 45:29.440]  у меня обработается все,
[45:29.440 --> 45:31.440]  что было достижимо из s.
[45:31.440 --> 45:33.440]  То есть, по сути, посетится
[45:33.440 --> 45:35.440]  все, что из этого s достижимо.
[45:35.440 --> 45:37.440]  Все, что достижимо,
[45:37.440 --> 45:39.440]  посетится и перекрасится в черный.
[45:39.440 --> 45:41.440]  Все вот эти будут черными.
[45:41.440 --> 45:43.440]  То есть, все, что было достижимо,
[45:43.440 --> 45:45.440]  будет черным.
[45:45.440 --> 45:47.440]  Все вот эти будут черными.
[45:47.440 --> 45:49.440]  Ну а тогда, соответственно, все остальное будет белое.
[45:49.440 --> 45:51.440]  Все, что недостижимо, будет белое.
[45:51.440 --> 45:53.440]  Начнем доказательство очевидно.
[45:53.440 --> 45:55.440]  Во-первых, посетиться может действительно
[45:55.440 --> 45:57.440]  только то, что достижимо из s,
[45:57.440 --> 45:59.440]  потому что мы переходим каждый раз вниз по ребрам.
[45:59.440 --> 46:01.440]  Значит, если я оказываюсь в какой-то вершинке,
[46:01.440 --> 46:03.440]  то я ее достиг с помощью переходов по ребрам из s.
[46:03.440 --> 46:05.440]  Значит, достигнуть я могу только достижимые.
[46:05.440 --> 46:07.440]  Ну и из лемы о белых путях,
[46:07.440 --> 46:09.440]  если какая-то достижимая,
[46:09.440 --> 46:11.440]  то есть, достижимая по белым путям,
[46:11.440 --> 46:27.440] ensed by,
[46:27.440 --> 46:39.440]  следствие следующее.
[46:39.440 --> 46:50.520]  напишем следующее, пусть в мейне выполняется dfs от s, то есть вот у меня есть
[46:50.520 --> 46:53.000]  такая рекурсивная функция и из основной
[46:53.000 --> 47:01.440]  программы я ее дергаю один раз, вызываю один раз, и от какой-то стартовышинки s. Тогда в
[47:01.440 --> 47:16.240]  графе существует цикл, достижимый из s, если только если в какой-то момент времени мы найдем
[47:16.240 --> 47:40.760]  ребро в серую вершинку, dfs когда-то находит ребро в серую вершину, серую вершину. Вот, и это в
[47:40.760 --> 47:45.800]  частности объясняет, зачем мы вводили три цвета, белый, серый, черный, потому что вот здесь вот,
[47:45.800 --> 47:51.600]  если, то есть, если мы это утверждение докажем, то вот в этой строчке, когда мы проверяли, что цвет
[47:51.600 --> 47:57.480]  не белый, можно, ну, немножко по-другому написать, что если цвет черный, то continue, если цвет серый,
[47:57.480 --> 48:03.880]  то мы нашли цикл, а если белый, то запустились рекурсивно dfs. Вот в этом месте у нас играет
[48:03.880 --> 48:11.680]  покраска в серый цвет, то есть если в какой-то момент времени я стою v, пытаюсь пойти в tu и
[48:11.680 --> 48:24.760]  tu при этом серая, то я нашел цикл, используя ребро v tu. Доказательства. Так, ну, справа налево,
[48:24.760 --> 48:34.360]  давайте попробуем сначала. Наверное, я хочу сказать следующее, для доказательства мы скажем
[48:34.360 --> 48:54.240]  следующее, что в каждый момент стек рекурсии это путь из серых вершин,
[48:54.240 --> 49:08.240]  причем других серых вершин в графе нету. Причем других серых нет.
[49:08.240 --> 49:25.040]  То есть вот что такой стек рекурсии? Это, ну, например, я начал с какой-то вершинки s,
[49:25.040 --> 49:29.280]  покрасил его в серый, перешел рекурсивно в какой-то v, покрасил его в серый, перешел в какую-то
[49:29.280 --> 49:34.120]  вершинку tu и так далее. Потом, когда какую-то вершинку обработал, я ее перекрашиваю в черный,
[49:34.120 --> 49:40.760]  удаляю стек рекурсии и откатываюсь на шаг назад. Почему это верное утверждение? Ну, более-менее
[49:40.760 --> 49:45.960]  понятно. Во-первых, почему в стеке лежат только серые? Очевидно, что чтобы положить вершинку в
[49:45.960 --> 49:50.520]  стек, я ее должен сначала перекрасить, потом рекурсивно запуститься в какой-то другой. Потом,
[49:50.520 --> 49:56.440]  когда я ее хочу удалить, я ее перекрашиваю в черный и удаляю стека, потому что завершается
[49:56.440 --> 50:01.280]  рекурсивный вызов. Поэтому в стеке обязательно лежат только серые, они образуют обязательно путь,
[50:01.280 --> 50:06.160]  потому что чтобы добавить какую-то вершинку в стек, надо чтобы было ребро из перед последней
[50:06.160 --> 50:10.400]  в последнюю. Почему нет других серых? Ну, потому что, как только вершина перешет быть серой,
[50:10.400 --> 50:21.120]  она снимается со стека. Значит, все, что вне стека, оно точно не серое. Понятно? Ну и тогда справа
[50:21.120 --> 50:28.360]  налево доказываем, что если мы в какой-то момент нашли ребро в серую, значит, по сути,
[50:28.360 --> 50:34.760]  вот смотрите, у меня был вот такой стек, там С, какой-то В, какой-то Ту, какой-то там еще У и все
[50:34.760 --> 50:43.040]  они серые сейчас. Грей, грей, грей. Я нашел ребро в серую. То есть я нашел, по сути, ребро в одну из
[50:43.040 --> 50:47.840]  предыдущих вершин на стеке рекурсии. Она обязательно в стеке, потому что, повторюсь, серые лежат все в
[50:47.840 --> 50:53.000]  стеке рекурсии. Вне стека все белые и черные. Ну, значит, если я нашел такое ребро, то, пожалуйста,
[50:53.000 --> 50:58.280]  вот вам путь. Надо сначала использовать его, ребро в серую, которое я нашел, а потом спускаться
[50:58.280 --> 51:03.960]  обратно по стеку к этой последней вершине, от которой я нашел ребро. Согласны? Поэтому
[51:03.960 --> 51:12.920]  наличие ребра в серую автоматически вам означает наличие цикла. Ну, в обратную сторону. Почему,
[51:12.920 --> 51:19.240]  если цикл есть, то мы его обязательно найдем таким способом? Мы его найдем, увидев ребро из
[51:19.240 --> 51:27.640]  стекущей вершины в серую. Ну, хорошо, вот пусть есть какой-то цикл. Пусть есть какой-то цикл С. Я
[51:27.640 --> 51:35.280]  утверждаю, что мы обязательно найдем, ну, то есть мы обязательно увидим ребро в серую когда-то. Так,
[51:35.280 --> 51:46.280]  вот пусть С это стартовая, от которой мы запускаем DFS в мейне. И дальше, ну да, надо еще сказать,
[51:46.280 --> 51:52.360]  что С это цикл достижимый из С. Раз это цикл достижимый из С, то есть какой-то путь из С в,
[51:52.360 --> 51:57.320]  ну там, по крайней мере, в одну из этих вершин. Да, например, вот до сюда. Давайте тогда в качестве
[51:57.320 --> 52:12.600]  В возьмем ту вершину, у которой Tn минимальный. Значит, пусть В это вершина цикла С с минимальным
[52:12.600 --> 52:21.240]  TnV. То есть возьмем вершину цикла, в которую мы заходим раньше других. То есть мы как бы сначала
[52:21.240 --> 52:27.160]  доходим из С до В, потом обработаем этот цикл. То есть В самая первая на цикле при обработке.
[52:27.160 --> 52:37.400]  Тогда я утверждаю следующее. Смотрите, значит, вот я дошел в В. Впервые дошел до В, больше никакие
[52:37.400 --> 52:41.880]  другие вершины цикла пока не вижу. Это в частности значит следующее. Значит, когда я в нее захожу,
[52:41.880 --> 52:47.480]  я ее перекрашу в серую, а все остальные на цикле пока что еще белые. White, white, white, white, white.
[52:47.480 --> 52:52.120]  Все остальные на цикле пока что еще белые, потому что я до них не успел дойти. У них Tn больше,
[52:52.120 --> 53:00.280]  они только позже будут увидены. Поэтому, в частности, из LEM о белых путях, потому что есть вот такой
[53:00.280 --> 53:07.400]  вот белый путь, есть путь по циклу, целиком состоящий из белых вершин, к моменту времени выхода
[53:07.480 --> 53:13.880]  из В. Я точно всех вот этих вот товарищей обработаю. К моменту времени выхода из В я точно обработаю все
[53:13.880 --> 53:20.320]  вершины цикла. В частности, вот эту вот предпоследнюю. Я ее обработаю. Что это значит? Значит, что DFS
[53:20.320 --> 53:26.160]  отсюда вызовется раньше, чем DFS отсюда выйдет. Поэтому сначала эта вершинка покрасится в серый,
[53:26.160 --> 53:32.240]  я увижу это ребро в В, и тем самым увижу ребро в серую вершину. То есть до того, как я отсюда
[53:32.240 --> 53:39.760]  выйду, я увижу это ребро, и увижу ребро в серую вершину. То есть найду цикл. Давайте это запишем кратко.
[53:39.760 --> 53:58.560]  По лемме о белых путях до момента
[53:58.560 --> 54:16.480]  Таут от В, все вершины цикла посетятся. Значит, в частности, посетится вот эта вот предпоследняя
[54:16.480 --> 54:28.400]  вершина, скажем, У. В частности, У. То есть я найду ребро из УВ, где В в данный момент серое, а У обрабатывается.
[54:28.400 --> 54:42.640]  Поэтому я найду ребро как раз таки в серую вершину. Победа. Согласны? Да. Не обязательно, конечно. Я
[54:42.640 --> 54:49.720]  этого не утверждаю, но главное, я говорю, что мы найдем ребро в серую. То есть если есть цикл в исходном
[54:49.720 --> 54:54.880]  графе, то мы обязательно найдем ребро в серую. Конечно, совсем не обязательно обход устроен именно
[54:54.880 --> 54:58.960]  так, что он доходит до В, потом обходит этот цикл, и потом обратно это ребро. Потому что, например,
[54:58.960 --> 55:06.120]  может быть какой-то другой цикл, вот такой вот, по какому-то другому пути, через У и В. И тогда он,
[55:06.120 --> 55:09.840]  в принципе, мог найти не вот этот цикл, а какой-то другой. Но главное, что он что-то нашел. То есть я
[55:09.840 --> 55:14.320]  не утверждаю, что мы находим какой-то конкретный или вообще все. Главное, что если какой-то есть,
[55:14.320 --> 55:27.280]  то мы обязательно обнаружим вот это вот ребро в серую вершинку. Замечание. Мы не ищем все циклы
[55:27.280 --> 55:47.680]  или конкретный цикл С. Мы только проверяем наличие цикла. Мы лишь проверяем наличие цикла.
[55:47.680 --> 56:00.280]  Так, ну что, тогда, наверное, ДФС я это могу стереть. Мы объяснили, зачем нам нужны цвета,
[56:00.280 --> 56:16.320]  зачем Т in и Т out. Все, тогда я могу это убить. Хороший вопрос. Линейное, конечно. Симпточка этого
[56:16.320 --> 56:26.360]  всего дела, конечно, N плюс M. Это очень просто доказать, потому что от каждой вершины ДФС
[56:26.360 --> 56:31.400]  запускается максимум один раз, потому что войти в вершину, запустить в нее ДФС, я могу только,
[56:31.400 --> 56:35.560]  когда она до этого была белой, а после этого ее сразу перекрашу в серый, а потом в черный.
[56:35.560 --> 56:41.920]  Поэтому запуск от каждой вершины может быть максимум один раз. Это слагаем вот этот N. Ну а
[56:41.920 --> 56:46.160]  дальше, если я посмотрю, как у меня работает ДФС из конкретной вершины В, то я, по сути,
[56:46.160 --> 56:52.600]  просто перебираю все ребра из нее. Ну, то есть вот этот цикл 4 in 2, G out V, он работает за
[56:52.600 --> 56:58.680]  количество исходящих ребер из В. Ну а сумма количества исходящих ребер это как раз от M. В случае
[56:58.680 --> 57:03.680]  ориентированной граффы это просто M, число всех ребер. В случае неориентированной граффы это 2 М,
[57:03.680 --> 57:09.080]  потому что каждый ребро дает мне ребро и туда и туда, поэтому с точки зрения ошки это все равно М.
[57:09.080 --> 57:17.760]  Так, еще вот здесь замечание хочу сделать, чтобы найти какой-то цикл.
[57:17.760 --> 57:30.840]  Сейчас, момент. Ну да, чтобы найти сам цикл, то есть, например, мы поняли, что цикл есть,
[57:30.840 --> 57:36.920]  да, мы увидели ребро в серую, теперь мы хотим вывести этот цикл, вывести какой-то цикл. Надо
[57:36.920 --> 57:50.840]  использовать массив parent. Ну тоже, в общем, понятно как. Я рисовал стек рекурсии, вот представьте,
[57:50.840 --> 57:56.040]  что вот у меня такой стек рекурсии, и я нашел какое-то ребро в серую, то есть нашел в какую-то
[57:56.040 --> 58:02.480]  более раннюю вершину на стеке ребро. Что это значит в частности? Значит в частности, что parent от
[58:02.680 --> 58:07.160]  вот этого это вот это, parent от этого это вот это, parent от этого это вот это, parent от этого это вот это,
[58:07.160 --> 58:12.960]  потому что если я использую какое-то ребро, спускаюсь с DFS из одной вершины в другую, то я в частности
[58:12.960 --> 58:19.120]  помечаю, что родительская вершина вот этой, это вот это. Значит тогда у меня все вершины на стеке,
[58:19.120 --> 58:24.880]  которые на стеке рекурсии, они на самом деле являются сыновьями одна другой, и если я хочу
[58:24.880 --> 58:29.520]  вывести вот эту последовательность, зная, что вот этот В, а вот этот вот Т, мне достаточно просто
[58:29.520 --> 58:32.520]  просто от v брать parent до тех пор, пока я не берусь до tu.
[58:32.520 --> 58:36.520]  Тем самым я восстановлю как раз тот цикл, который у меня лежит на стеке.
[58:36.520 --> 58:41.520]  То есть это parent от v, это parent от parent от v,
[58:41.520 --> 58:45.520]  ну и так далее, пока я не дойду до tu.
[58:45.520 --> 58:47.520]  Вот такое восстановление цикла.
[58:47.520 --> 58:50.520]  То есть мы можем не только проверить, что он есть, но и вывести какой-то цикл.
[58:55.520 --> 58:58.520]  Ура! Разбрались с циклами.
[58:59.520 --> 59:13.520]  Так, хорошо.
[59:13.520 --> 59:18.520]  Дальше идет топологическая сортировка у меня.
[59:29.520 --> 59:38.520]  Топологическая сортировка.
[59:38.520 --> 59:50.520]  Значит, определение dag – это directed acyclic graph.
[59:50.520 --> 59:57.520]  Ну, соответственно, по-русски это ориентированный циклический граф.
[59:58.520 --> 01:00:01.520]  А циклический значит без циклов.
[01:00:01.520 --> 01:00:05.520]  То есть если на нем запустить вот эту штуку, то мы не найдем ни одного цикла.
[01:00:05.520 --> 01:00:08.520]  Ориентированный граф без циклов.
[01:00:08.520 --> 01:00:11.520]  А циклический.
[01:00:11.520 --> 01:00:22.520]  Топологическая сортировка – это такая перестановка вершин p1, p2 и так далее pn.
[01:00:22.520 --> 01:00:25.520]  Перестановка вершин графа.
[01:00:28.520 --> 01:00:31.520]  Перестановка вершин графа.
[01:00:31.520 --> 01:00:35.520]  Что ребра исходного графа ведут только слева направо.
[01:00:35.520 --> 01:00:40.520]  То есть ведут из вершин с меньшим номером в вершины с большим номером.
[01:00:40.520 --> 01:00:55.520]  Такая, что ребра графа ведут только слева направо.
[01:00:55.520 --> 01:01:00.520]  То есть из pi в pj только для i меньше, чем j.
[01:01:00.520 --> 01:01:04.520]  Только в порядке увеличения индекса в этой перестановке можно иметь ребра.
[01:01:04.520 --> 01:01:06.520]  Это топологическая сортировка.
[01:01:06.520 --> 01:01:09.520]  Просто какая-то перестановка вершин такая, что ребра идут только слева направо.
[01:01:09.520 --> 01:01:13.520]  Нет ребер справа налево.
[01:01:13.520 --> 01:01:17.520]  Ну, пример какой-нибудь давайте нарисуем.
[01:01:25.520 --> 01:01:37.520]  Какой-нибудь DAC и какая-нибудь у него топологическая сортировка.
[01:01:37.520 --> 01:01:40.520]  Вот я такое что-нибудь нарисую.
[01:01:44.520 --> 01:01:48.520]  Так, 0, 1, 2, 3, 4, 5, например.
[01:01:48.520 --> 01:01:51.520]  Тогда что будет являться топологической сортировкой?
[01:01:51.520 --> 01:01:54.520]  Например, можно написать что-нибудь такое.
[01:01:54.520 --> 01:02:00.520]  2, 1, 3, 4, 0, 5.
[01:02:00.520 --> 01:02:04.520]  Давайте проверим, что ребра действительно в такой перестановке идут только слева направо.
[01:02:04.520 --> 01:02:15.520]  Вот есть ребро 2, 1, слева направо идёт 1, 5, слева направо 2, 0, 0, 5, 2, 3, 3, 0, 3, 4, 4, 5.
[01:02:15.520 --> 01:02:17.520]  Ну вот действительно все идут слева направо.
[01:02:17.520 --> 01:02:18.520]  Никаких других нет.
[01:02:18.520 --> 01:02:21.520]  На ней нет ребер справа налево.
[01:02:21.520 --> 01:02:24.520]  Простое упражнение.
[01:02:24.520 --> 01:02:31.520]  Топологическая сортировка есть только у ациклических графов.
[01:02:31.520 --> 01:02:38.520]  Есть только у ациклических графов.
[01:02:38.520 --> 01:02:41.520]  То есть если в графе есть цикл, то надеюсь на топ-сорт нельзя.
[01:02:41.520 --> 01:02:42.520]  Но это совсем просто.
[01:02:42.520 --> 01:02:46.520]  Если есть цикл, то не может быть такое, что все ребра в нём идут слева направо.
[01:02:46.520 --> 01:02:50.520]  Когда-то мы обязательно должны вернуться справа налево.
[01:02:50.520 --> 01:02:56.520]  Вот, значит, если есть у меня граф какой-то ориентированный, то чтобы в нём был топ-сорт,
[01:02:56.520 --> 01:02:58.520]  надо, чтобы он был ациклическим.
[01:02:58.520 --> 01:03:05.520]  Давайте теперь найдём топ-сорт, зная, что он ациклический.
[01:03:05.520 --> 01:03:13.520]  Найдём топологическую сортировку в даге.
[01:03:13.520 --> 01:03:31.520]  В ориентируемом ациклическом графе.
[01:03:31.520 --> 01:03:34.520]  Решение будет следующее.
[01:03:34.520 --> 01:03:42.520]  Значит, мы перебираем номер вершины.
[01:03:42.520 --> 01:03:46.520]  Запускаем от неё DFS, если она белая.
[01:03:46.520 --> 01:04:00.520]  Если color от V это white, тогда DFS от V.
[01:04:00.520 --> 01:04:25.520]  И в конце, чтобы получить топ-сорт, нужно напечатать все вершины в порядке убывания Т-аута.
[01:04:25.520 --> 01:04:31.520]  То есть мой DFS, он для каждой вершины проставляет время входа в неё, время выхода из неё.
[01:04:31.520 --> 01:04:35.520]  Раз у каждой написано Т-аут, они все различны,
[01:04:35.520 --> 01:04:38.520]  давайте тогда напечатаем в порядке убывания Т-аута.
[01:04:38.520 --> 01:04:41.520]  Это будет топ-сорт.
[01:04:41.520 --> 01:04:48.520]  Это и будет топологическая сортировка.
[01:04:48.520 --> 01:04:56.520]  Наверное, это надо доказать, почему это верно.
[01:04:56.520 --> 01:04:58.520]  Почему это топологическая сортировка?
[01:04:58.520 --> 01:05:04.520]  Нам надо доказать, что ребра идут только слева направо.
[01:05:04.520 --> 01:05:07.520]  То есть каждое ребро, если оно встречается в нашем графе,
[01:05:07.520 --> 01:05:11.520]  то оно идёт из вершинки с большим Т-аутом в вершинку с меньшим Т-аутом.
[01:05:11.520 --> 01:05:14.520]  Давайте теперь переформулируем то, что нам надо доказать.
[01:05:14.520 --> 01:05:29.520]  Если УВ это ребро, то надо доказать, что У будет расположено раньше, чем В в этом нашем порядке.
[01:05:29.520 --> 01:05:32.520]  То есть у него больше Т-аут.
[01:05:32.520 --> 01:05:38.520]  Т-аут от У больше, чем Т-аут от В.
[01:05:38.520 --> 01:05:40.520]  Это надо доказать.
[01:05:40.520 --> 01:05:41.520]  Это будет достаточно.
[01:05:41.520 --> 01:06:00.520]  Тогда то, что мы напечатали в порядке убывания Т-аутов, это будет топ-сорт.
[01:06:00.520 --> 01:06:05.520]  То есть если есть ребро, то есть какое-то отношение на Т-ауты.
[01:06:05.520 --> 01:06:11.520]  Ну хорошо, давайте переберём два случая, какая из двух вершин была посещена первой.
[01:06:11.520 --> 01:06:14.520]  Сравним.
[01:06:14.520 --> 01:06:20.520]  Т и над У и Т и над В.
[01:06:20.520 --> 01:06:22.520]  Значит, случай первый.
[01:06:22.520 --> 01:06:26.520]  В У мы вошли раньше, чем в В.
[01:06:26.520 --> 01:06:28.520]  Т и над У меньше, чем Т и над В.
[01:06:28.520 --> 01:06:29.520]  Что это значит?
[01:06:29.520 --> 01:06:31.520]  Это значит, что мы вошли в У.
[01:06:31.520 --> 01:06:33.520]  В тогда была ещё белая.
[01:06:33.520 --> 01:06:35.520]  Мы до неё не дошли, то есть только позже её увидим.
[01:06:35.520 --> 01:06:39.520]  Поэтому В белая в момент, когда мы входим в У.
[01:06:39.520 --> 01:06:46.520]  Мы сюда вошли, перекрасили сразу в серый, а это ещё белая.
[01:06:46.520 --> 01:06:56.520]  Ну мы с вами знаем, например, по лемме о белых путях, что раз у меня есть целиком белый путь, ведущий вот эту вершинку, в эту белую вершинку В,
[01:06:56.520 --> 01:07:00.520]  значит до того, как я выйду из У, я успею в это целиком работать.
[01:07:00.520 --> 01:07:07.520]  То есть у меня от неё рекурсивно запустится ДФС, он целиком отработает, перекрасит её в чёрный, и только потом я выйду отсюда.
[01:07:07.520 --> 01:07:12.520]  Поэтому, в частности, по лемме о белых путях, выйду отсюда и раньше, чем отсюда.
[01:07:12.520 --> 01:07:15.520]  Ну то есть здесь лемма о белых путях это, конечно, оверкил.
[01:07:15.520 --> 01:07:17.520]  Можно что-то более простое сказать.
[01:07:17.520 --> 01:07:21.520]  Ну раз есть белый ребро, то я сначала, ну не совсем.
[01:07:21.520 --> 01:07:24.520]  Да, я, возможно, в неё как-то вот так по-другому попаду.
[01:07:24.520 --> 01:07:26.520]  Да, то есть по какому-то другому пути.
[01:07:26.520 --> 01:07:28.520]  Но неважно, окей, да.
[01:07:28.520 --> 01:07:49.520]  По лемме о белых путях, к моменту ТАУТ от У, В уже посетится, то есть ТАУТ от В меньше, чем ТАУТ от У.
[01:07:49.520 --> 01:07:51.520]  Это то, что мы хотели доказать.
[01:07:52.520 --> 01:07:56.520]  Ну а что, если есть ребро, то есть неравенство вот такое между ТАУтами.
[01:07:56.520 --> 01:08:01.520]  Ну теперь второй случай, когда, наоборот, зашли в В раньше, чем в У.
[01:08:14.520 --> 01:08:16.520]  Зашли в В раньше, чем в У.
[01:08:21.520 --> 01:08:23.520]  Зашли сюда, перекрасили её в серый.
[01:08:25.520 --> 01:08:27.520]  А это ещё, это ещё белое.
[01:08:27.520 --> 01:08:30.520]  Это белое, а это вот серое, мы в неё только что зашли.
[01:08:30.520 --> 01:08:38.520]  Ну тогда я утверждаю, что к моменту времени выхода из В к моменту ТАУТ от В, я У точно не смогу посетить.
[01:08:38.520 --> 01:08:45.520]  Потому что если я, ну то есть смотрите, у меня ДФС запустился от В, да, ДФС от В, я в неё зашёл, запускаю рекурсивный ДФС.
[01:08:45.520 --> 01:08:49.520]  И пусть, к моменту времени выхода отсюда, я посещу У.
[01:08:49.520 --> 01:08:52.520]  Но это тогда означает, что я нашёл какой-то путь из В в У.
[01:08:52.520 --> 01:08:54.520]  А это бы означало наличие цикла в исходном графе.
[01:08:54.520 --> 01:08:56.520]  А мы предполагаем, что у меня исходный граф ДАГ.
[01:08:56.520 --> 01:08:58.520]  Противоречие.
[01:08:58.520 --> 01:09:08.520]  Значит, если к моменту ТАУТ от В алгоритм В, то есть у меня ДФС.
[01:09:08.520 --> 01:09:25.520]  К моменту ТАУТ от В алгоритм посетит У, то в графе есть цикл, что противоречит условию.
[01:09:29.520 --> 01:09:36.520]  Ну потому что как мы можем, то есть мы запускаем ДФС от В, У к тому моменту времени была ещё белая.
[01:09:36.520 --> 01:09:40.520]  Как может быть такое, что мы попали из В в У?
[01:09:40.520 --> 01:09:44.520]  Ну попасть мы можем только по ребрам, только по стрелочкам.
[01:09:44.520 --> 01:09:46.520]  Мы нашли какой-то путь из В в У.
[01:09:46.520 --> 01:09:50.520]  Значит, если его замкнуть по среднему реброму, то будет цикл. Противоречие.
[01:09:54.520 --> 01:09:58.520]  Значит, к моменту времени выхода из В мы У ещё не трогали вообще.
[01:09:58.520 --> 01:10:01.520]  Значит, она белая в момент времени выхода.
[01:10:01.520 --> 01:10:07.520]  Значит, У белая в ТАУТ от В.
[01:10:07.520 --> 01:10:13.520]  Ну значит, только после этого момента я её когда-то найду, У как-то найдётся в моём обходе.
[01:10:13.520 --> 01:10:20.520]  То есть мы её либо из какой-то другой вершины посетим, либо вот здесь вот запустимся непосредственно ДФС от У в мейне.
[01:10:20.520 --> 01:10:23.520]  То есть в мейне запустим ДФС от У.
[01:10:23.520 --> 01:10:28.520]  В итоге в любом случае У мы начнём видеть только после ТАУТ от В.
[01:10:28.520 --> 01:10:31.520]  Поэтому не просто вот то неравенство выполняется, а даже вот это выполняется.
[01:10:31.520 --> 01:10:35.520]  Что ТИ на ТУ больше, чем ТАУТ от В.
[01:10:35.520 --> 01:10:40.520]  Ну значит, ТАУТ, который больше, чем ТИ на ТВ, подавно больше, чем ТАУТ от В.
[01:10:44.520 --> 01:10:50.520]  Конец. Доказали, что если ребро между У и В есть, то есть требуемое неравенство на ТАУТы.
[01:10:50.520 --> 01:10:52.520]  Поэтому то, что мы построили, это топ-сорт.
[01:10:54.520 --> 01:10:55.520]  Вопросы?
[01:10:59.520 --> 01:11:00.520]  Окей.
[01:11:04.520 --> 01:11:07.520]  Так, тогда зачем это может быть нужно, например?
[01:11:23.520 --> 01:11:24.520]  Пам-пам-пам.
[01:11:26.520 --> 01:11:27.520]  А, пример.
[01:11:28.520 --> 01:11:32.520]  Пусть, например, нам задан дак, ориентируемый на циклический граф,
[01:11:32.520 --> 01:11:35.520]  и нам нужно в нём найти число путей.
[01:11:39.520 --> 01:11:43.520]  Просто число путей в даге.
[01:11:44.520 --> 01:11:47.520]  Так, я вот, не уверен, я хотел сказать, что задача
[01:11:47.520 --> 01:11:50.520]  подсчёта числа путей в произвольном графе, она,
[01:11:50.520 --> 01:11:52.520]  заполином пока неизвестно, решается или нет.
[01:11:52.520 --> 01:11:54.520]  Но не буду говорить такого утверждения,
[01:11:54.520 --> 01:11:57.520]  короче, в произвольном графе задача сложнее.
[01:11:57.520 --> 01:11:59.520]  Проверить число путей в произвольном графе,
[01:12:01.520 --> 01:12:05.520]  найти точнее число путей в произвольном графе сильно сложнее, чем найти число п VII,
[01:12:05.520 --> 01:12:07.520]  типа, было бы VERYriers.
[01:12:07.520 --> 01:12:09.520]  Ага, хорошая такая задача для меня.
[01:12:09.520 --> 01:12:13.520]  найти точнее число путей в прерывном графе сильно сложнее, чем найти число
[01:12:13.520 --> 01:12:15.520]  путей в ориентированном ациклическом графе.
[01:12:15.520 --> 01:12:19.520]  Ну как это сделаем? Очень просто, с помощью топсорта.
[01:12:19.520 --> 01:12:23.520]  Давайте выпишем топсорт. Это какой-то порядок вершин.
[01:12:23.520 --> 01:12:31.520]  И ведем динамику. Пусть dp от v это число путей, которые начинаются в вершине v.
[01:12:31.520 --> 01:12:36.520]  Число путей, начинающихся в v.
[01:12:40.520 --> 01:12:42.520]  Начинаешься в v.
[01:12:42.520 --> 01:12:44.520]  Как такие пути могут быть устроены?
[01:12:44.520 --> 01:12:46.520]  Давайте скажем, что это топсорт.
[01:12:46.520 --> 01:12:49.520]  Давайте найдем в этой перестановке v.
[01:12:49.520 --> 01:12:52.520]  Как может быть устроен путь, начинающийся из v?
[01:12:52.520 --> 01:12:56.520]  Но есть две опции. Либо мы начались в v и сразу закончились.
[01:12:56.520 --> 01:12:59.520]  Никуда не идем, просто путь из одной вершинки.
[01:12:59.520 --> 01:13:02.520]  Либо мы пытаемся прыгнуть туда направо, используя ребро.
[01:13:02.520 --> 01:13:06.520]  Из всех этих ребер, которые ведут из v, мы выбираем какое-то одно.
[01:13:06.520 --> 01:13:11.520]  И, соответственно, пытаемся продолжить путь, начиная с какой-то этой вершинки.
[01:13:11.520 --> 01:13:14.520]  Поэтому можно писать такую простую формулу.
[01:13:14.520 --> 01:13:23.520]  dp от v это единица, плюс сумма по всем u таким, что v, u это ребро.
[01:13:23.520 --> 01:13:26.520]  dp от u.
[01:13:26.520 --> 01:13:30.520]  Потому что если я фиксировал какое-то первое ребро, скажем, из v в u,
[01:13:30.520 --> 01:13:35.520]  то чтобы найти число продолжений, мне, по сути, нужно просто узнать, сколько есть путей, и начинаешься в u.
[01:13:35.520 --> 01:13:37.520]  Это dp от u.
[01:13:37.520 --> 01:13:42.520]  Значит, вот выполняется такая формула для пересчета dp нашей.
[01:13:42.520 --> 01:13:47.520]  Ну а насчитать ее можно очень просто, пройдя справа-налево по нашему массиву топ-сорта.
[01:13:47.520 --> 01:13:52.520]  Потому что мы видим, что каждая dp зависит только от того, что расположено справа.
[01:13:52.520 --> 01:13:56.520]  Значит, если я буду идти справа-налево по моему массиву топ-сорта,
[01:13:56.520 --> 01:14:00.520]  то, зная все, что располагается справа, то есть зная все вот эти значения,
[01:14:00.520 --> 01:14:03.520]  dp от v однозначно восстановляется по этой формуле.
[01:14:05.520 --> 01:14:08.520]  Время работы, конечно, здесь будет линейное.
[01:14:08.520 --> 01:14:10.520]  n плюс m.
[01:14:10.520 --> 01:14:16.520]  Потому что, во-первых, топ-сорт строится за столько, потому что dfs работает за n плюс m.
[01:14:16.520 --> 01:14:21.520]  Ну а дальше, чтобы эту динамику насчитать, мне нужно завести n в ней ячеек,
[01:14:21.520 --> 01:14:24.520]  и потом пересчитывается она за время от m.
[01:14:24.520 --> 01:14:29.520]  Потому что каждое значение пересчитывается через размер этой суммы, количество слагаемых здесь.
[01:14:29.520 --> 01:14:31.520]  Это число ребер, исходящих из v.
[01:14:31.520 --> 01:14:36.520]  Ну и сумма размеров вот этих вот сумм, она как раз будет число ребер просто.
[01:14:36.520 --> 01:14:38.520]  Ну от m.
[01:14:42.520 --> 01:14:44.520]  Согласны?
[01:14:44.520 --> 01:14:46.520]  Кайф.
[01:14:46.520 --> 01:14:48.520]  Так, времени еще немножко есть.
[01:14:48.520 --> 01:14:51.520]  Давайте тогда мы начнем алгоритм Косараю.
[01:14:51.520 --> 01:14:55.520]  Не успеем его закончить, но по крайней мере сам алгоритм опишем.
[01:14:55.520 --> 01:15:00.520]  Так, алгоритм Косараю.
[01:15:00.520 --> 01:15:04.520]  Это алгоритм нахождения всех компонентов сильно связанных.
[01:15:04.520 --> 01:15:07.520]  Ну, по крайней мере, это алгоритм кассарая.
[01:15:07.520 --> 01:15:10.520]  Ну, вот, это алгоритм кассарая.
[01:15:11.520 --> 01:15:13.520]  Кассараю.
[01:15:13.520 --> 01:15:17.520]  Это алгоритм нахождения всех компонентов сильно связанности.
[01:15:22.520 --> 01:15:27.520]  Компонент сильно связанности.
[01:15:41.520 --> 01:15:44.520]  То есть, вот у меня есть граф.
[01:15:44.520 --> 01:15:50.520]  Мы помним, что отношение сильно связанности, когда мы можем дойти из u в v в u в обе стороны,
[01:15:50.520 --> 01:15:54.520]  значит, мы хотим разбить все вершины на классы эквивалентности по этому отношению.
[01:15:54.520 --> 01:15:57.520]  То есть, на компоненты сильно связанности такие, что внутри каждой компоненты
[01:15:57.520 --> 01:16:00.520]  между любыми двумя вершинами есть путь в обе стороны,
[01:16:00.520 --> 01:16:05.520]  а между вершинами разных компонентов нет пути хотя бы в одну из сторон.
[01:16:05.520 --> 01:16:07.520]  Значит, давайте сделаем тогда следующее.
[01:16:07.520 --> 01:16:09.520]  Начало будет такое же, как в топ-сорте.
[01:16:09.520 --> 01:16:13.520]  Мы, значит, сначала вот эту, короче, вот эту штуку, я просто сюда скопирую.
[01:16:16.520 --> 01:16:18.520]  То есть, я сначала все вершины крашу в белый,
[01:16:18.520 --> 01:16:22.520]  потом, ну, вот, в порядке от 0 до n-ой спермы, на самом деле, не важно в каком,
[01:16:22.520 --> 01:16:26.520]  в каком-то порядке запускаю DFS-ы из всех непосещенных вершин, то есть, из всех белых.
[01:16:26.520 --> 01:16:32.520]  И дальше вот пусть p, пусть p, это список вершин в порядке убывания т-аутов.
[01:16:34.520 --> 01:16:36.520]  Список вершин
[01:16:37.520 --> 01:16:41.520]  в порядке убывания т-аутов, так же, как раньше.
[01:16:47.520 --> 01:16:50.520]  То есть, например, если бы мой граф из входа был ациклическим,
[01:16:50.520 --> 01:16:52.520]  то к этому моменту я бы получил топ-сорт.
[01:16:52.520 --> 01:16:55.520]  Если в графе есть циклы, то, ну, это, понятное дело, не топ-сорт,
[01:16:55.520 --> 01:16:57.520]  топ-сорта вообще не существует для графов с циклами.
[01:16:57.520 --> 01:16:59.520]  Это просто какая-то перестановка вершин.
[01:17:00.520 --> 01:17:02.520]  Вот, а дальше делаем следующее.
[01:17:02.520 --> 01:17:04.520]  Красим опять все вершины в белый.
[01:17:05.520 --> 01:17:08.520]  Мне лень писать код, давайте я словами напишу.
[01:17:08.520 --> 01:17:11.520]  Значит, красим все опять в белый.
[01:17:15.520 --> 01:17:19.520]  А дальше проходимся по вот этому, по этой перестановке p,
[01:17:19.520 --> 01:17:22.520]  и для каждой белой вершины, которую встречаем,
[01:17:22.520 --> 01:17:24.520]  запускаем DFS по обратным ребрам.
[01:17:24.520 --> 01:17:26.520]  То есть, DFS, ну, по сути, в обратном графе.
[01:17:26.520 --> 01:17:28.520]  Если было ребро из u в v,
[01:17:28.520 --> 01:17:30.520]  то, когда я делаю обратный граф,
[01:17:30.520 --> 01:17:32.520]  ну, строю реверс к этому графу,
[01:17:32.520 --> 01:17:34.520]  то у меня будет обратный ребро из v в u.
[01:17:34.520 --> 01:17:36.520]  Короче, я, по сути, меняю направление всех ребр.
[01:17:36.520 --> 01:17:39.520]  Так вот, значит, я прохожусь по перестановке p,
[01:17:39.520 --> 01:17:42.520]  для каждой белой вершины запускаю DFS по обратным ребрам,
[01:17:42.520 --> 01:17:46.520]  и все, что я обойду вот этим обратным DFS-ом,
[01:17:46.520 --> 01:17:48.520]  это будет очередная компонента сильно связанности.
[01:17:51.520 --> 01:17:55.520]  Проходим по p,
[01:17:57.520 --> 01:17:59.520]  запускаем,
[01:18:00.520 --> 01:18:04.520]  я вот так пишу, DFS реверсанта
[01:18:05.520 --> 01:18:07.520]  от белых вершин.
[01:18:11.520 --> 01:18:14.520]  Все, что посещает очередная итерация DFS-а,
[01:18:14.520 --> 01:18:16.520]  это новая компонента сильно связанности.
[01:18:16.520 --> 01:18:19.520]  Новая компонента сильно связанности.
[01:18:23.520 --> 01:18:26.520]  Значит, доказывать корректность будем в следующий раз,
[01:18:26.520 --> 01:18:28.520]  пока давайте пример нарисуем
[01:18:28.520 --> 01:18:30.520]  того, что этот алгоритм делает.
[01:18:40.520 --> 01:18:44.520]  Ну, смотрите, первый пример, когда граф исходно был ациклический.
[01:18:45.520 --> 01:18:47.520]  Пример первый, когда граф ациклический.
[01:18:50.520 --> 01:18:52.520]  Что-нибудь вот такое нарисую.
[01:18:55.520 --> 01:18:57.520]  Значит, тогда мы знаем, что к моменту времени,
[01:18:57.520 --> 01:18:59.520]  когда построено p, когда мы посортили все вершины
[01:18:59.520 --> 01:19:01.520]  по убыванию т-аута,
[01:19:01.520 --> 01:19:03.520]  мы на самом деле построили топ-сорт.
[01:19:04.520 --> 01:19:06.520]  То есть первой, грубо говоря, будет вот эта вершина,
[01:19:06.520 --> 01:19:08.520]  потом вот эта, ну, например, в таком каком-то порядке
[01:19:08.520 --> 01:19:10.520]  может быть у меня топ-сорт.
[01:19:10.520 --> 01:19:12.520]  Тогда, смотрите, если я буду запускать DFS
[01:19:12.520 --> 01:19:14.520]  по обратным ребрам вот в том порядке,
[01:19:14.520 --> 01:19:16.520]  в котором мне адептуется эта перестановка,
[01:19:16.520 --> 01:19:18.520]  то есть, по сути, у меня есть вот такое порядочение
[01:19:18.520 --> 01:19:21.520]  всех вершин сверху вниз, в каком-то смысле сверху вниз.
[01:19:21.520 --> 01:19:23.520]  Я запускаю сначала DFS по обратным ребрам
[01:19:23.520 --> 01:19:25.520]  от самой верхней вершины.
[01:19:25.520 --> 01:19:27.520]  Понятно, что в нее нет никакого входящего ребра.
[01:19:29.520 --> 01:19:31.520]  Поэтому она будет сама по себе
[01:19:31.520 --> 01:19:33.520]  отдельной компонентой сильной связности.
[01:19:33.520 --> 01:19:35.520]  Одна вершина, больше с ней никого
[01:19:35.520 --> 01:19:37.520]  в компоненте не будет.
[01:19:37.520 --> 01:19:39.520]  Дальше, например, вот эта вершина идет у меня
[01:19:39.520 --> 01:19:41.520]  в перестановке p. Я опять от нее запускаю DFS
[01:19:41.520 --> 01:19:43.520]  по обратным ребрам, то есть, по сути, я мог бы как бы
[01:19:43.520 --> 01:19:45.520]  перейти вот сюда, но
[01:19:45.520 --> 01:19:47.520]  поскольку она уже перекрашена
[01:19:47.520 --> 01:19:49.520]  в черный, она уже использована в другой компоненте,
[01:19:49.520 --> 01:19:51.520]  я никуда не поднимаюсь, это будет
[01:19:51.520 --> 01:19:53.520]  отдельная KSS, компонент сильной связности.
[01:19:53.520 --> 01:19:55.520]  То же самое для всех остальных.
[01:19:55.520 --> 01:19:57.520]  Запускаю здесь, идти некуда, потому что там уже все занято,
[01:19:57.520 --> 01:19:59.520]  это отдельная KSS. Запускаюсь отсюда,
[01:19:59.520 --> 01:20:01.520]  идти некуда, потому что это уже занято, это уже занято,
[01:20:01.520 --> 01:20:03.520]  это уже занято, они все использованы,
[01:20:03.520 --> 01:20:05.520]  поэтому это отдельные компоненты
[01:20:05.520 --> 01:20:07.520]  сильной связности. Тоже самое здесь.
[01:20:07.520 --> 01:20:09.520]  В случае, когда GraphDuck,
[01:20:09.520 --> 01:20:11.520]  у меня все компоненты сильной связности,
[01:20:11.520 --> 01:20:13.520]  это отдельные вершинки.
[01:20:15.520 --> 01:20:17.520]  Если же это Duck,
[01:20:17.520 --> 01:20:19.520]  то все
[01:20:19.520 --> 01:20:21.520]  KSS, я буду леницей писать,
[01:20:21.520 --> 01:20:34.000]  то, что компоненты сильно связанности, это просто
[01:20:34.000 --> 01:20:35.100]  1 элемент множества.
[01:20:35.100 --> 01:20:42.000]  Ну, потому что понятно, как могут 2 вершины быть
[01:20:42.000 --> 01:20:43.560]  в одной компоненте.
[01:20:43.560 --> 01:20:46.340]  Как могут быть 2 вершины u-ve в одной компонент с saints
[01:20:46.340 --> 01:20:49.760] inator или sv3, значит, есть какой-то такой путь,
[01:20:49.760 --> 01:20:57.360]  цикл. Значит, если хотя бы какая-то ксс, хотя бы двуэлементная, значит есть цикл в графе.
[01:20:57.360 --> 01:21:02.800]  Да, поэтому если он ациклический, то значит такого не будет, все они в отдельных компонентах.
[01:21:02.800 --> 01:21:08.040]  Так, пример второй.
[01:21:19.760 --> 01:21:36.040]  Пример второй, пример второй. Ну что-нибудь, что-нибудь поинтереснее с циклами давайте граф рассмотрим,
[01:21:36.080 --> 01:21:49.400]  какой-нибудь, что-нибудь такое, такое. Вот такое. Вот смотрите, вот такой граф.
[01:21:49.400 --> 01:21:54.400]  Значит, ну здесь видно по картинке, есть писание так нарисовал, что вот это вот отдельная ксс,
[01:21:54.400 --> 01:21:59.640]  вот это отдельная ксс и вот это отдельная ксс. Потому что внутри каждой компоненты,
[01:21:59.640 --> 01:22:04.720]  ну по сути это цикл. Значит, ну ясное дело, что если у вас есть цикл, то можно между
[01:22:04.720 --> 01:22:09.480]  любыми двумя добраться в обе стороны. Если я буду добавлять другие ребра, то это будет подавна ксс,
[01:22:09.480 --> 01:22:17.440]  что-нибудь такое, тоже ксс. Вот, ну а между разными компонентами нет, ну не может быть
[01:22:17.440 --> 01:22:21.760]  идти в обе стороны. Например, вот отсюда я не могу, то есть я могу попасть сюда, но обратно уже никак
[01:22:21.760 --> 01:22:26.640]  не попаду, потому что вот отсюда нет ребер туда и никак по-другому я не смогу туда попасть. Вот в ту
[01:22:26.640 --> 01:22:32.320]  компоненту я никак попасть не смогу вот отсюда. Поэтому у меня будет три такие ксс. Значит, дальше,
[01:22:32.320 --> 01:22:39.240]  как будет работать p? Как выглядит перестановка p? Ну, например, здесь может быть что-нибудь такое.
[01:22:39.240 --> 01:22:47.520]  Сначала тут будут, сейчас. Напоминаю, p это у меня вершины в порядке убывания т-аута. То есть в начале
[01:22:47.520 --> 01:22:53.320]  идут те, у которых максимальный т-аут. Такой максимальный т-аут. Ну, скорее всего, у вот этих
[01:22:53.320 --> 01:22:59.200]  вершинок, потому что, ну, например, я запускаю с dfs изначально вот отсюда. Тогда я сначала обойду
[01:22:59.920 --> 01:23:04.260]  всю компоненту, потом, например, запущусь отсюда, потом вот отсюда, всё обойду. И чтобы выйти отсюда,
[01:23:04.260 --> 01:23:08.740]  мне, короче, придется обойти весь граф. Поэтому максимальный т-аут будет у вот, этих вот вершин.
[01:23:08.740 --> 01:23:13.900]  То есть, в начале у меня будет, как бы ну, какая-то вершинка вот отсюда. Ну, там, не знаю,
[01:23:13.900 --> 01:23:19.160]  p0 будет отсюда. Потом от сюда будет какой-то p1, отсюда будет какой-то p2. Ну так, неформально. То есть,
[01:23:19.160 --> 01:23:23.560]  понятно, что максимальный t-aut будет у вершин отсюда, потом t-aut поменьше будет у вершин отсюда,
[01:23:23.560 --> 01:23:25.880]  самый маленький будет у вершин отсюда.
[01:23:25.880 --> 01:23:29.240]  Значит, когда я запускаю DFS по обратным ребрам, скажем,
[01:23:29.240 --> 01:23:32.860]  от какого-нибудь вершины отсюда, то я могу посетить
[01:23:32.860 --> 01:23:34.780]  только вот эту компоненту связанности, потому что
[01:23:34.780 --> 01:23:38.080]  все остальные ребра идут как бы наоборот из этой
[01:23:38.080 --> 01:23:40.760]  компоненты, то есть вот это ребро, вот это ребро,
[01:23:40.760 --> 01:23:43.600]  я их не буду рассматривать, я по обратным ребрам посещу
[01:23:43.600 --> 01:23:45.280]  только вот эту компоненту связанности.
[01:23:45.280 --> 01:23:49.840]  То же самое здесь, я вот это назначу отдельно к СС,
[01:23:49.840 --> 01:23:52.280]  потом я перехожу сюда, обхожу все, что доступно
[01:23:52.280 --> 01:23:53.280]  по обратным ребрам.
[01:23:53.280 --> 01:23:56.880]  Это вся к СС и больше ничего, потому что есть вот это входящее
[01:23:56.880 --> 01:24:00.000]  ребро, оно ведет в уже посещенное, я туда не иду, ну а это из
[01:24:00.000 --> 01:24:02.560]  входящего ребра, я его игнорирую, поэтому это тоже найдется
[01:24:02.560 --> 01:24:03.560]  как отдельное к СС.
[01:24:03.560 --> 01:24:05.760]  Ну и здесь останется три вершины, я запускаю вот
[01:24:05.760 --> 01:24:09.240]  любой из них, тоже нахожу целиком всю к СС, больше
[01:24:09.240 --> 01:24:11.360]  никуда не поднимаюсь, потому что они уже посещены, значит
[01:24:11.360 --> 01:24:12.840]  это тоже отдельное к СС.
[01:24:12.840 --> 01:24:16.360]  То есть я найду все правильно, как и надо.
[01:24:16.360 --> 01:24:17.800]  Все доказательств стоят в следующий раз, спасибо.
