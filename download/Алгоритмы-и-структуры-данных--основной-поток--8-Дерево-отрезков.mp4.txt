[00:00.000 --> 00:07.640]  Сегодня рассматриваем еще одну структуру данных
[00:07.640 --> 00:12.640]  деревоотресков.
[00:12.640 --> 00:15.040]  Немножко похоже на то, что было в конце прошлой лекции
[00:15.040 --> 00:20.560]  на Спарстейбл, отличается тем, что мы умеем обрабатывать
[00:20.560 --> 00:22.360]  запросы на изменения.
[00:22.360 --> 00:25.360]  Если вы помните, Спарстейбл работал так, что у нас есть
[00:25.360 --> 00:28.560]  статический массив неизменяемый, и мы на отрезках хотели
[00:28.560 --> 00:29.560]  находить минимумы.
[00:29.560 --> 00:34.880]  Так вот здесь мы, во-первых, позволим себе обрабатывать
[00:34.880 --> 00:38.240]  запросы изменения, то есть массив будет не статическим,
[00:38.240 --> 00:39.240]  а будет как-то изменяться.
[00:39.240 --> 00:44.120]  Ну и мы можем искать, опять же, мы будем в основном все
[00:44.120 --> 00:46.560]  искать на отрезках, но мы можем искать не только
[00:46.560 --> 00:49.520]  минимум, но и всякие другие гораздо более сложные функции.
[00:49.520 --> 00:53.480]  Но мы посмотрим на простеньких примерах, начнем с суммы.
[00:53.480 --> 00:57.800]  Давайте посмотрим такую задачу классическую.
[00:57.960 --> 01:05.200]  Ставьте, что у вас есть массив чисел, и к нему поступает
[01:05.200 --> 01:06.560]  два типа запросов.
[01:06.560 --> 01:11.160]  Первый – это обновление в точке, давайте его напишу
[01:11.160 --> 01:19.360]  сначала формально, update pos и какой-нибудь x, это, ну
[01:19.360 --> 01:22.400]  я для простоты себе сделаю следующее, это увеличение
[01:22.400 --> 01:28.000]  апостова на x, причем x может быть отрицательной.
[01:28.000 --> 01:33.560]  Ну то есть это любое число, плюс равно, что прибавить
[01:33.560 --> 01:36.160]  x к тому числу, которое там было.
[01:36.160 --> 01:39.240]  Если запрос изменения – это просто присвоение в точке,
[01:39.240 --> 01:41.800]  если мы хотим не заменять, то есть не увеличивать на
[01:41.800 --> 01:44.440]  какое-то x, не прибавлять x, а просто класть какое-то
[01:44.440 --> 01:47.600]  новое значение, ну понятно, новые запросы спокойно
[01:47.600 --> 01:49.680]  выражаются через старое, потому что если мы хотим
[01:49.760 --> 01:52.280]  положить новое число, то это то же самое, что прибавить
[01:52.280 --> 01:55.320]  разность нового и старого, тогда как раз старое станет
[01:55.320 --> 01:58.760]  новым, ну в общем, я себе особенно этим условиям руки
[01:58.760 --> 02:02.320]  не связываю никак, но мне удобнее будет реализовывать
[02:02.320 --> 02:03.520]  в таком вот предположении.
[02:03.520 --> 02:07.760]  Значит, обновление в точке давайте назову, обновление
[02:07.760 --> 02:08.760]  в точке.
[02:08.760 --> 02:15.840]  Ну и второй тип запросов – это сумма на отрезке, значит
[02:15.840 --> 02:22.720]  как-нибудь я ее назову, типа get sum lr, это мне нужно просто
[02:22.720 --> 02:30.160]  найти сумму элементов с l telpa r, найти a l plus a l plus 1,
[02:30.160 --> 02:33.200]  плюс так далее вплоть до a r, значит это сумма на отрезке.
[02:33.200 --> 02:46.080]  Так, задача понятна?
[02:46.080 --> 02:49.000]  Ну вот, мы научимся сейчас на каждый запрос отвечать
[02:49.000 --> 02:51.400]  за логарифмическое время, завод логарифм.
[02:51.400 --> 02:57.360]  Значит, давайте посмотрим какой-нибудь пример, для
[02:57.360 --> 03:02.560]  небольшого n я нарисую картинку, давайте для n равно 8, мы
[03:02.560 --> 03:04.920]  будем, ну раз это дерево отрезков, мы будем строить
[03:04.920 --> 03:08.000]  дерево, причем дерево будет бинарным, так же как у нас
[03:08.000 --> 03:09.200]  было в бинарной куче.
[03:09.200 --> 03:11.600]  Значит, как это будет выглядеть?
[03:11.600 --> 03:14.440]  Вот, значит я сейчас построю полно-бинарное дерево с
[03:14.440 --> 03:18.160]  восьмию листьями, и листья у меня будут как раз отвечать
[03:18.160 --> 03:21.400]  элементам массива, значит это будет а нулевое, а первое,
[03:21.400 --> 03:25.440]  а второе, третье, четвертое, пятое, шестое, седьмое.
[03:25.440 --> 03:27.120]  Вот, все восемь элементов будут отвечать листьям
[03:27.120 --> 03:28.120]  нашего дерева.
[03:28.120 --> 03:31.600]  Дальше они объединяются парами и подвешиваются
[03:31.840 --> 03:32.840]  до одной и той же общей вершины.
[03:32.840 --> 03:36.000]  Значит, эти два будут сыновьями этой вершины, эти два сыновьями
[03:36.000 --> 03:38.540]  этой, эти два соединились, эти два соединились.
[03:38.540 --> 03:40.360]  На следующем уровне то же самое.
[03:40.360 --> 03:43.500]  Значит вот эти два объединяются в общего родителя, эти два
[03:43.500 --> 03:46.320]  объединяются в общего родителя и самая верхняя вершина
[03:46.320 --> 03:50.500]  корнем дерева будет выступать вершина такая, что внизу
[03:50.500 --> 03:54.100]  от нее все листья находятся, то есть под ней..
[03:54.100 --> 03:57.660]  Скажу так, от нее, идя по ребрам вниз, можно дойти
[03:58.800 --> 04:00.600]  до любого листа.
[04:00.600 --> 04:08.600]  Вот, значит, будет такая картинка, давай здесь не пшу, а 0, а 1, и так далее, а 7.
[04:08.600 --> 04:11.600]  Вот, мы будем строить такое дерево.
[04:11.600 --> 04:16.600]  Значит, давайте я сразу скажу, что каждая вершина на такой картинке
[04:16.600 --> 04:20.600]  контролирует некоторые подотрезок элементов нашего массива.
[04:20.600 --> 04:24.600]  Например, вот эта вершина контролирует подотрезок с нулевого по первому элементу.
[04:24.600 --> 04:29.600]  Здесь отрезок 0, 1. Здесь будет отрезок 2, 3,
[04:29.600 --> 04:34.600]  потому что здесь элементы А2, А3. Здесь, соответственно, 4, 5.
[04:35.600 --> 04:38.600]  Здесь 6, 7.
[04:39.600 --> 04:43.600]  Ну, соответственно, здесь их объединение, то есть с нулевого по третьей.
[04:43.600 --> 04:45.600]  Здесь с четвертого по седьмой.
[04:45.600 --> 04:49.600]  Ну и здесь весь отрезок, весь массив с нулевого по седьмой элемента.
[04:49.600 --> 04:54.600]  Вот, значит, тем самым каждая вершина некий отрезок нашего массива контролирует.
[04:54.600 --> 04:58.600]  И поэтому у нас дерево отрезков, потому что каждая вершина нашего дерева
[04:58.600 --> 05:00.600]  она отвечает за некоторый подотрезок исходного массива.
[05:00.600 --> 05:03.600]  Например, это подотрезок с нулевого по третьей элемента.
[05:03.600 --> 05:06.600]  Вот это вот все, это все, что находится в поддереве данной вершины.
[05:06.600 --> 05:08.600]  Да.
[05:09.600 --> 05:11.600]  Нет, нет, нет, это у меня везде квадратные скобки.
[05:11.600 --> 05:13.600]  У меня сегодня все на отрезках.
[05:14.600 --> 05:16.600]  Вот.
[05:16.600 --> 05:18.600]  Хорошо. Ну и давайте сделаем следующее.
[05:18.600 --> 05:23.600]  Давайте мы в каждую вершину положим сумму с контролируемым подотрезком.
[05:24.600 --> 05:27.600]  То есть вот здесь в листиках будут лежать сами элементы массива
[05:27.600 --> 05:29.600]  A0, A1, A2 и так далее.
[05:29.600 --> 05:32.600]  Здесь будет лежать сумма A0 плюс A1.
[05:32.600 --> 05:34.600]  Здесь будет лежать сумма A2 плюс A3.
[05:34.600 --> 05:38.600]  А, например, вот здесь будет лежать сумма всех элементов A0, A1, A2, A3.
[05:38.600 --> 05:39.600]  Ну и так далее.
[05:39.600 --> 05:42.600]  То есть вот если вершина какой-то подотрезок контролирует,
[05:42.600 --> 05:45.600]  то давайте мы в нее запишем значение суммы на этом отрезке.
[05:46.600 --> 05:50.600]  То есть скажем, здесь будет сумма A0 плюс и так далее плюс A3.
[05:50.600 --> 05:53.600]  Здесь сумма с четвертого по седьмой.
[05:53.600 --> 05:55.600]  Значит, на этих не буду писать.
[05:55.600 --> 05:58.600]  В корне будет сумма всех элементов с нулевого по седьмой.
[06:01.600 --> 06:03.600]  Просто когда вершина отвечает за некий подотрезок,
[06:03.600 --> 06:05.600]  когда вершина контролирует некоторый подотрезок,
[06:05.600 --> 06:08.600]  мы в вершине храним сумму на этом подотрезке.
[06:08.600 --> 06:10.600]  Сумму элементов с этого подотрезка.
[06:13.600 --> 06:15.600]  Ну, тут зависит от реализации.
[06:15.600 --> 06:19.600]  Давайте я скажу, что мы в вершине это явным образом не храним,
[06:19.600 --> 06:21.600]  но всегда сможем хранить все элементы.
[06:21.600 --> 06:24.600]  То есть если надо, я легко смогу в вершине понять,
[06:24.600 --> 06:26.600]  что за отрезок она контролирует.
[06:26.600 --> 06:30.600]  Но явные поля внутри вот этой вот вершинки я хранить не буду.
[06:30.600 --> 06:32.600]  Здесь будет только сумма храниться, и все.
[06:32.600 --> 06:34.600]  Мне больше ничего не надо.
[06:34.600 --> 06:37.600]  Ну хорошо, давайте представим, что у нас такая структура есть.
[06:37.600 --> 06:40.600]  Давайте вообразим себе, как можно было бы отвечать на запросы,
[06:40.600 --> 06:42.600]  которые нам поступают.
[06:42.600 --> 06:44.600]  Давайте с апдейта начнем.
[06:44.600 --> 06:47.600]  Представьте, есть такое большое дерево, все в нем хранится,
[06:47.600 --> 06:51.600]  что происходит, когда меняется значение какого-то элемента апостола.
[06:51.600 --> 06:57.600]  Ну да, нам нужно обновить все суммы, которые это самое апостое содержали.
[06:57.600 --> 07:01.600]  То есть если скажем, вот апостое было, вот это вот А4,
[07:01.600 --> 07:03.600]  то какие суммы меняются?
[07:03.600 --> 07:06.600]  Ну понятно, вот это вот поменялось, потому что здесь на х увеличилось,
[07:06.600 --> 07:08.600]  эта сумма изменилась на х.
[07:08.600 --> 07:12.600]  Это изменилось, потому что это совершенно контролировало этот,
[07:12.600 --> 07:14.240]  эта высота суммы изменился на х.
[07:14.240 --> 07:18.600]  Это изменилось, потому что эта вершина контролировала этот элемент.
[07:18.600 --> 07:21.600]  Дальше тут надо поменять и здесь надо поменять.
[07:21.600 --> 07:25.340]  Понятно. В этих, во всех вот вершинах, которые получается по факту
[07:25.340 --> 07:29.040]  подъемом от листа к корню во всех вершинах надо сделать плюс х,
[07:29.040 --> 07:31.340]  потому что только здесь сумма изменилась.
[07:31.340 --> 07:34.340]  Да? И вот здесь делаю плюс х, здесь плюс х, здесь плюс х,
[07:34.340 --> 07:38.600]  и здесь плюс х. Согласны?
[07:38.600 --> 07:41.600]  Вот, больше никакие другие вершины эту вершину не контролируют,
[07:41.600 --> 07:45.600]  Значит, в других вершинах ничего не поменялось.
[07:45.600 --> 07:48.600]  Ну вот, и вроде все, мы перестроили правильным образом наше дерево.
[07:48.600 --> 07:52.600]  То есть, если мы хотим обновить в точке, то мне нужно, в зависимости от реализации,
[07:52.600 --> 07:58.600]  либо сверху вниз, от корня до этого листа пройти и увеличить все вот эти вот суммы на х,
[07:58.600 --> 08:03.600]  либо, наоборот, от листа дойти до корня и во всех этих вершинах поставить плюс х.
[08:03.600 --> 08:07.600]  Мы будем сверху идти, от корня до этого листа, то есть мы изначально встаем в корень.
[08:07.600 --> 08:11.600]  Дальше мы знаем, куда нам нужно прийти эта вершина, которая соответствует листу АПОС.
[08:11.600 --> 08:13.600]  И дальше просто правильным образом спускаемся.
[08:13.600 --> 08:15.600]  Каждый раз мне нужно понимать, куда идти вправо или влево.
[08:15.600 --> 08:18.600]  Ну и вот во всех посещенных вершинках я увеличу сумму на х.
[08:20.600 --> 08:24.600]  Понятно, что время работы будет логарифмическим, потому что это полное бинарное дерево.
[08:24.600 --> 08:26.600]  У него, очевидно, логарифмическая глубина.
[08:26.600 --> 08:30.600]  На первом уровне одна вершина, потом две, потом четыре, потом восемь и так далее.
[08:30.600 --> 08:32.600]  Значит, не может быть больше, чем логарифм уровней.
[08:32.600 --> 08:36.600]  Ну и мы это делаем, понятное дело, просто за время пропорционально глубине дерева.
[08:36.600 --> 08:41.600]  Мы просто спускаемся сверху вниз, время работы, очевидно, равно глубине дерева в худшем случае.
[08:46.600 --> 08:47.600]  Так проще реализовывать.
[08:47.600 --> 08:52.600]  Если мы идем сверху вниз, это легко обобщается на всякие разные другие задачи.
[08:52.600 --> 08:56.600]  Помимо вот этой самой стандартной, она легко обобщается на другие задачи,
[08:56.600 --> 08:58.600]  типа отложенных операций у нас будет чуть позже.
[08:58.600 --> 09:02.600]  Ну в общем, так я бы сказал, более общо, если сверху вниз идти.
[09:02.600 --> 09:05.600]  Мы так просто большую задачу сможем решать.
[09:05.600 --> 09:09.600]  А снизу вверх тоже можно, но там некоторые ограничения возникают, я туда не полезу.
[09:10.600 --> 09:12.600]  Ну вот, понятная идея.
[09:12.600 --> 09:14.600]  Вроде все довольно элементарно.
[09:14.600 --> 09:18.600]  Теперь давайте с суммой разберемся, значит, что делать, как отвечать на запрос суммы.
[09:20.600 --> 09:25.600]  Ну, мы на самом деле будем идти довольно наивным образом,
[09:25.600 --> 09:28.600]  и просто будем идти туда, куда есть смысл.
[09:28.600 --> 09:32.600]  Вот давайте какой-нибудь пример посмотрим, пусть Элер, у меня это отрезок.
[09:33.600 --> 09:35.600]  Так, сейчас что-нибудь интеллектуальное возьму.
[09:35.600 --> 09:40.600]  Давайте 1,7 я возьму.
[09:43.600 --> 09:45.600]  Вот такой отрезок 1,7.
[09:45.600 --> 09:48.600]  Мы опять-таки, так, у меня все скобки сегодня квадратные,
[09:48.600 --> 09:51.600]  если я не четко пишу, это квадратная скобка.
[09:51.600 --> 09:54.600]  Мы давайте встанем изначально в корень.
[09:55.600 --> 09:57.600]  Встали в корень.
[09:57.600 --> 10:00.600]  И мы понимаем, что корень соответствует под отрезку 0,7.
[10:00.600 --> 10:02.600]  Нам нужна сумма с под отрезка 1,7.
[10:02.600 --> 10:05.600]  Если бы было 0,7, мы бы могли сразу завершиться,
[10:05.600 --> 10:07.600]  потому что мы знаем сумму отрезка 0,7.
[10:07.600 --> 10:09.600]  Мы бы сразу вывели ответ и бы закончились.
[10:09.600 --> 10:12.600]  Но беда. У меня этот отрезок и этот не совпадают.
[10:13.600 --> 10:15.600]  Хорошо, давайте не будем особ Emma думать.
[10:15.600 --> 10:17.600]  И давайте пойдем налево, если нужно,
[10:17.600 --> 10:19.600]  направо, если нужно.
[10:19.600 --> 10:21.600]  Если хотя бы какая-то часть отрезка,
[10:21.600 --> 10:22.600]  с которой нужна сумма,
[10:22.600 --> 10:24.600]  если хотя бы какая-то часть лежит слева,
[10:24.600 --> 10:25.600]  давайте пойдем налево.
[10:26.600 --> 10:27.600]  Если хотя бы какая-то часть справа,
[10:27.600 --> 10:28.600]  то пойдем направо.
[10:28.600 --> 10:35.920]  И так будем делать, пока это имеет смысл. Вот, например, был у меня отрезок 1,7. Ну понятно,
[10:35.920 --> 10:41.000]  что какие-то элементы из этого отрезка лежат слева, какие-то — справа. Мы знаем, что здесь все
[10:41.000 --> 10:45.620]  элементы с нулевого по третий, значит сюда есть смысл идти, какие-то элементы мне нужны. Вот эти
[10:45.620 --> 10:50.760]  вот элементы мне нужно просуммировать. Поэтому налево есть смысл идти. И то же самое — направо.
[10:50.760 --> 10:55.480]  Справа у меня элементы с четвертого по седьмой, все эти элементы мне тоже нужно просуммировать,
[10:55.480 --> 11:01.480]  значит идти направо есть смысл. Ну, давайте в обе эти вершины спустимся. То есть мы пойдем и сюда, и сюда.
[11:01.480 --> 11:07.480]  Дальше, например, смотрите, в правой ветке, вот здесь вот, идти ниже уже нет никакого смысла,
[11:07.480 --> 11:13.480]  потому что меня интересует сумма со всех вот этих вот вершин. То есть отрезок, который меня здесь интересует,
[11:13.480 --> 11:19.480]  совпадает с тем, который я контролирую. Я знаю в этой вершине сумму элементов с четвертого по седьмой.
[11:19.480 --> 11:25.480]  Мне все эти элементы нужно взять в сумму, я их просто давайте добавлю к ответу и вниз не пойду,
[11:25.480 --> 11:29.480]  потому что внизу уже никакой новой информации я не получу. Я знаю сумму со всех этих четырех вершин,
[11:29.480 --> 11:33.480]  она здесь хранится. Вниз идти нет смысла. Согласны?
[11:33.480 --> 11:39.480]  Значит, просто это добавляю к ответу и все, вниз не иду. Вот здесь вот у меня проход вниз завершается.
[11:39.480 --> 11:45.480]  Я ниже не иду. Теперь что происходит в левой ветке? Значит, смотрите, здесь опять у меня отрезок контролируемой 0.3,
[11:45.480 --> 11:51.480]  а мне нужно пересечь его с отрезком 1.7. То есть мне нужно взять сумму этих трех элементов.
[11:51.480 --> 11:55.480]  Есть ли смысл идти влево? Понятно, есть, потому что здесь есть какой-то элемент.
[11:55.480 --> 12:00.480]  Мы пойдем влево, и вправо тоже есть смысл идти, потому что здесь тоже есть какие-то элементы.
[12:00.480 --> 12:07.480]  Мы опять-таки спустимся в обе веточки. Но вновь получается, что в правой ветке вниз идти нет смысла,
[12:07.480 --> 12:13.480]  потому что мы и так находимся в вершине такой, что контролируемый ею под отрезок целиком вложен в то,
[12:13.480 --> 12:18.480]  что нам нужно. То есть все эти элементы мне нужно добавить к ответу. Так вот давайте я ее добавлю к ответу,
[12:18.480 --> 12:24.480]  а вниз не пойду. То есть здесь опять-таки мой спуск вниз прекратится. Мы уже добавили вот это и вот это.
[12:24.480 --> 12:31.480]  Теперь осталась последняя вершина, вот это вот. Здесь действие точно так же. Есть ли смысл спускаться вправо и влево?
[12:31.480 --> 12:36.480]  Понятно, вправо есть, потому что здесь есть какой-то элемент, а влево смысла идти уже нет,
[12:36.480 --> 12:40.480]  потому что здесь только нулевой элемент. Нулевой элемент в наш отрезок не входит.
[12:40.480 --> 12:45.480]  Значит, я сюда не иду, иду только сюда. Ну и просто в конце добавляю вот эту вот вершину к ответу.
[12:45.480 --> 12:47.480]  Точнее сумму, которая там написана.
[12:54.480 --> 12:58.480]  Вот я говорю, можно, но мы так не будем делать. Мы будем именно вот так вот спускаться сверху вниз,
[12:58.480 --> 13:03.480]  потому что вы предлагаете, но оно не особенно обобщается. То есть это можно заевать, конечно,
[13:03.480 --> 13:07.480]  что если бла-бла-бла, если отрезок это все без одного элемента, то вот вычесть один.
[13:07.480 --> 13:11.480]  Но в общем случае мы будем действовать именно вот так вот сверху вниз, наивным образом,
[13:11.480 --> 13:15.480]  идя в обе ветки, если нужно, а если не нужно, то обрубаться.
[13:16.480 --> 13:18.480]  Можете более нормально проговорить?
[13:18.480 --> 13:20.480]  Я же с код напишу просто.
[13:23.480 --> 13:28.480]  Вот. Ну, идейна понятно, наверное. Хорошо.
[13:28.480 --> 13:31.480]  Так, ну теперь давайте как-нибудь это реализуем.
[13:31.480 --> 13:34.480]  Давайте мне нужно будет вести нумерацию на вершинах.
[13:34.480 --> 13:37.480]  Давайте я сделаю так же, как у нас было в бинарной куче.
[13:37.480 --> 13:40.480]  Давайте я скажу, что у меня корень это вершина номер один,
[13:40.480 --> 13:44.480]  и у каждой вершины v есть два сына 2v и 2v плюс один.
[13:44.480 --> 13:50.480]  Значит, у каждой вершины есть сын 2v, есть сын 2v плюс один.
[13:52.480 --> 13:56.480]  Значит, это первая договоренность, вторая, что если здесь,
[13:56.480 --> 14:01.480]  давайте перерисую, если в вершине v у меня контролировался подотрезок
[14:01.480 --> 14:06.480]  с tl по tr, я вот так вот двумя буквами назову сейчас подотрезок,
[14:06.480 --> 14:10.480]  tltr это вот тот самый контролируемый подотрезок.
[14:10.480 --> 14:14.480]  Так вот, влево и вправо у меня уйдут такие отрезки.
[14:14.480 --> 14:19.480]  Я посчитаю полусумму tl и tr, округленную вниз,
[14:19.480 --> 14:22.480]  деление целочисленное с отбрасыванием на дробную часть.
[14:22.480 --> 14:26.480]  Я взял их полусумму и сказал, что в левую вершину,
[14:26.480 --> 14:30.480]  то есть вершина номер 2v, идет подотрезок с tl по tm,
[14:30.480 --> 14:34.480]  а вправую с tm плюс 1 по tr.
[14:38.480 --> 14:42.480]  Ну такая договоренность. Понятно, что у меня если корневая вершина
[14:42.480 --> 14:46.480]  контролирует некоторый подотрезок, то дети примерно пополам его делят.
[14:46.480 --> 14:49.480]  Ну вот я ровно это и сделал. Я взял их полусумму,
[14:49.480 --> 14:52.480]  если элементов у меня нечетное было количество, то, хочешь не хочешь,
[14:52.480 --> 14:55.480]  здесь будет родное количество элементов контролируемых.
[14:55.480 --> 14:58.480]  Давайте скажем, что там, в каком-то из них элементов больше.
[14:58.480 --> 15:02.480]  Я беру просто полусумму, говорю, что tm это граница разделения,
[15:02.480 --> 15:06.480]  и соответственно все элементы с tl по tm отправляю влево,
[15:06.480 --> 15:09.480]  а с tm плюс 1 по tr отправляю вправо.
[15:12.480 --> 15:18.480]  Ну хорошо, давайте простое утверждение,
[15:18.480 --> 15:21.480]  которое я не буду доказывать, потому что мне лень,
[15:21.480 --> 15:25.480]  заключается в следующем, что нам хватит 4n вершин.
[15:26.480 --> 15:31.480]  Значит, будет достаточно, скажу так, что все вершины
[15:34.480 --> 15:46.480]  имеют номера от 1 до, ну 4n не включительно, скажу так, не включительно.
[15:51.480 --> 15:56.480]  Ну вот на нашем примере, если n равно 8, то смотрите,
[15:56.480 --> 16:05.480]  у меня корень это единичка, дальше здесь 2, 3, тут 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.
[16:05.480 --> 16:08.480]  То есть здесь вообще мне хватило аж 15 вершин,
[16:08.480 --> 16:12.480]  это всего лишь в два раза больше, чем число элементов в массиве.
[16:12.480 --> 16:16.480]  Если n же не степень двойки, то там будет чуть более скошенное дерево,
[16:16.480 --> 16:19.480]  но и утверждается, что 4m всегда с запасом хватает.
[16:19.480 --> 16:22.480]  То есть если n была, как в этом случае, степень двойки,
[16:22.480 --> 16:25.480]  то вообще хватает 2n, как видим на этом примере.
[16:25.480 --> 16:28.480]  Если же это не степень двойки, то там будет небольшой перекос,
[16:28.480 --> 16:33.480]  и из-за этого, грубо говоря, в правой ветке может быть больше вершин,
[16:33.480 --> 16:37.480]  и у них будут больше номера, ну вот 4n утверждается всегда хватит.
[16:41.480 --> 16:45.480]  О, я не знаю. Может хватит, но мне кажется, что нет.
[16:45.480 --> 16:49.480]  Ну типа 4n минус константа уже не хватит, если большая константа.
[16:52.480 --> 16:55.480]  Окей, так, что хотел сказать дальше?
[16:57.480 --> 17:01.480]  Да, теперь давайте предположим, что вот так у меня дерево хранится.
[17:01.480 --> 17:05.480]  Давайте я скажу, что у меня есть некоторый массив t
[17:05.480 --> 17:08.480]  с индексацией одного до 4n,
[17:08.480 --> 17:11.480]  и я говорю, что t от v это как раз сумма вершин v.
[17:11.480 --> 17:14.480]  Сумма хранящейся вершин v.
[17:16.480 --> 17:19.480]  Ау? Ну да.
[17:21.480 --> 17:24.480]  Хранящаяся вершин v.
[17:28.480 --> 17:32.480]  Ну и давайте теперь напишем, как можно было бы сделать апдейт.
[17:32.480 --> 17:35.480]  Значит вот процедура апдейт.
[17:37.480 --> 17:42.480]  Я буду идти от корня к листьям, значит я начинаюсь в корне,
[17:42.480 --> 17:46.480]  и хочу спуститься до того самого листа, в котором происходят изменения.
[17:46.480 --> 17:49.480]  Значит, синдексис я обычно ввожу такой.
[17:49.480 --> 17:53.480]  Смотрите, у меня будет приниматься в качестве параметров вершина v,
[17:53.480 --> 17:56.480]  где я сейчас нахожусь, изначально корень.
[17:56.480 --> 18:00.480]  Дальше, контролируемый ею под отрезок вот эти самые границы TLTR.
[18:05.480 --> 18:09.480]  А потом уже параметры запросов, в какой точке и насколько я делаю изменения.
[18:09.480 --> 18:12.480]  Ну я хочу в точке pos прибавить x.
[18:12.480 --> 18:14.480]  Вот такой у меня будет синдексис.
[18:14.480 --> 18:18.480]  То есть как раз меня спрашивали, храним ли мы границы контролируемой под отрезкой в вершине,
[18:18.480 --> 18:22.480]  вот нет, не храним, я их каждый раз просто в рекурсию явным образом буду передавать.
[18:22.480 --> 18:26.480]  Можно было бы хранить, это особо ни на что не влияет, просто так меньше памяти будет.
[18:26.480 --> 18:31.480]  А если мы будем каждый раз по этой формуле просто высчитывать новые границы для любого из сыновей,
[18:31.480 --> 18:35.480]  то можно будет не хранить эти границы, а просто явным образом их всегда пересчитывать.
[18:35.480 --> 18:37.480]  Вот.
[18:37.480 --> 18:40.480]  Значит, что здесь будет написано?
[18:40.480 --> 18:43.480]  Ну, во-первых, давайте пропишем условия выхода из рекурсии.
[18:43.480 --> 18:46.480]  Мы выходим из рекурсии, когда мы дошли до листа.
[18:46.480 --> 18:52.480]  Лист – это вершина, которая отвечает контролируемому под отрезку размера 1.
[18:52.480 --> 18:55.480]  То есть лист – это вершина, которая контролирует только саму себя.
[18:55.480 --> 18:58.480]  И соответственно в ней можно сделать проверку TL равно TR.
[18:58.480 --> 19:02.480]  Вот если TL равно TR, то это в точности означает, что мы дошли до листа.
[19:02.480 --> 19:07.480]  Потому что у всех остальных вершин контролируемый под отрезок он какой-то большой.
[19:07.480 --> 19:11.480]  Там есть несколько сыновей в под дереве, несколько листьев в под дереве.
[19:11.480 --> 19:15.480]  Лист – это когда он один только у себя и больше никого нет.
[19:15.480 --> 19:19.480]  Значит, если мы дошли до листа, то есть если TL равно TR,
[19:19.480 --> 19:24.480]  ну тогда, видимо, нужно T в это увеличить на х.
[19:24.480 --> 19:26.480]  Давайте я вот так напишу компактно.
[19:26.480 --> 19:29.480]  T в это увеличиваю на х.
[19:29.480 --> 19:31.480]  Ретёрн.
[19:35.480 --> 19:36.480]  Сойдёт.
[19:36.480 --> 19:40.480]  То есть я дошёл до листа, всё, мне больше делать ничего не нужно, я выхожу из рекурсии.
[19:42.480 --> 19:47.480]  Иначе, если я не в листе, то мне нужно всё равно сделать эту строчку T в это плюс равно х.
[19:47.480 --> 19:51.480]  Наверное, оптимальное было бы её вынести в самое начало и не писать два раза.
[19:51.480 --> 19:53.480]  Но это опять-таки не принципиально.
[19:53.480 --> 19:58.480]  Я в любом случае в вершине увеличиваю сумму на х, потому что в ней сумма увеличилась.
[19:58.480 --> 20:02.480]  И мне нужно понять, куда мне дальше пойти влево или вправо.
[20:02.480 --> 20:04.480]  Вот как на этой картинке.
[20:04.480 --> 20:07.480]  Что мне нужно было из корны пойти направо, а здесь нужно было пойти налево.
[20:07.480 --> 20:12.480]  Но я же знаю, какие отрезки контролируются у меня детьми – левым, правым сыном.
[20:12.480 --> 20:17.480]  То есть я могу высчитать эти координаты, понять, куда попала позиция pos.
[20:17.480 --> 20:20.480]  А понятное дело, что pos попадёт ровно в один из них.
[20:20.480 --> 20:23.480]  Ну и вот пойти туда, куда она попала.
[20:23.480 --> 20:28.480]  Давайте мы посчитаем, что tm – это их полусумма, границы наших tl и tr.
[20:28.480 --> 20:33.480]  И если pos попадает в левый отрезок, то есть вот сюда вот,
[20:33.480 --> 20:38.480]  то есть если pos попала влево, то есть не превосходит наши границы,
[20:38.480 --> 20:43.480]  тогда можно просто запуститься рекурсивным апдейтом для левого сына.
[20:43.480 --> 20:45.480]  Ну а с левым сыном мы уже всё знаем, какие у него параметры.
[20:45.480 --> 20:47.480]  Это вершина номер 2v.
[20:47.480 --> 20:51.480]  И контролируемый ею под отрезок имеет координаты tl и tm.
[20:51.480 --> 20:54.480]  pos x составляю без изменений.
[20:56.480 --> 20:58.480]  Это спуск в левого сына.
[20:58.480 --> 21:04.480]  Иначе, если pos уже больше, чем tm, значит мне нужно пойти направо.
[21:04.480 --> 21:06.480]  То есть pos здесь не лежит, лежит вот здесь вот.
[21:06.480 --> 21:09.480]  Мне нужно пойти направо и обновляться в правом сыне.
[21:09.480 --> 21:12.480]  Там прочитано, что pos не больше четвертая.
[21:12.480 --> 21:15.480]  Ну типа того, да.
[21:15.480 --> 21:18.480]  Значит нужно пойти направо.
[21:19.480 --> 21:22.480]  Значит идём в правого сына.
[21:22.480 --> 21:24.480]  У него такой номер.
[21:24.480 --> 21:27.480]  Он контролирует такой под отрезок.
[21:27.480 --> 21:30.480]  Ну и pos x я оставляю без изменений.
[21:30.480 --> 21:32.480]  Кажется всё.
[21:35.480 --> 21:39.480]  Нет, x это вот то самое, на что происходит обновление.
[21:42.480 --> 21:44.480]  Давайте.
[21:45.480 --> 21:48.480]  Если что?
[21:51.480 --> 21:55.480]  Ну вот оно будет выглядеть в соответствии вот с этим вот правилом.
[21:55.480 --> 21:58.480]  Давайте нарисуем, если хочется.
[22:07.480 --> 22:09.480]  Ещё раз?
[22:09.480 --> 22:11.480]  Почему у нас либо один, либо другой обновление?
[22:11.480 --> 22:13.480]  А потому что не бывает такого, смотрите.
[22:13.480 --> 22:16.480]  Потому что у меня дети дизюктные.
[22:16.480 --> 22:19.480]  Левый стель по tm, правый стель плюс один по tr.
[22:19.480 --> 22:20.480]  Они не пересекаются.
[22:20.480 --> 22:23.480]  Не может быть такого, что pos попал одновременно и туда, и туда.
[22:23.480 --> 22:27.480]  А мы сказали, что достаточно обновить только те вершины, которые контролируют pos.
[22:27.480 --> 22:29.480]  Вот не может быть такого, что оба сына pos контролируют.
[22:29.480 --> 22:31.480]  Потому что не пересекаются просто.
[22:31.480 --> 22:33.480]  Понятно?
[22:33.480 --> 22:36.480]  Нет, pos это элемент.
[22:36.480 --> 22:39.480]  Это обновление в точке у меня.
[22:42.480 --> 22:44.480]  Так, n равно 5 меня просили нарисовать.
[22:44.480 --> 22:46.480]  Давайте нарисуем просто, как это будет выглядеть.
[22:46.480 --> 22:49.480]  У меня будет корень, который контролирует 0,4.
[22:51.480 --> 22:53.480]  Я просто по форму буду считать.
[22:53.480 --> 22:55.480]  Смотрите, 0,4 полусумма будет 2.
[22:55.480 --> 22:59.480]  Поэтому слева 0,2, справа 3,4.
[23:00.480 --> 23:05.480]  Здесь 0,2 полусумма 1, здесь 0,1, здесь 2,2.
[23:06.480 --> 23:10.480]  Здесь просто 3,3 и 4,4.
[23:12.480 --> 23:15.480]  И вот эта вершинка еще на 2 подразбивается.
[23:15.480 --> 23:19.480]  8,9, 0,0, 1,1.
[23:20.480 --> 23:22.480]  Но она будет такой немножко скошенная влево.
[23:23.480 --> 23:25.480]  И соответственно листья – это вот эти вот вершины.
[23:25.480 --> 23:31.480]  Вот это будет нулевая, первая, вторая, третья, четвертая вершина, соответствующая элементам массива.
[23:32.480 --> 23:34.480]  Просто по правилам, не думая.
[23:36.480 --> 23:38.480]  Так. Нормально?
[23:38.480 --> 23:45.480]  А будет ли лучше просто сделать дерево, чтобы у него была степень двойки вершин,
[23:45.480 --> 23:47.480]  но остальные по 0?
[23:47.480 --> 23:49.480]  Можно и так, да, можно и так. Как ходить, так и делайте.
[23:49.480 --> 23:51.480]  Можно все, можно любой из этого реализовать.
[23:51.480 --> 23:54.480]  Я думаю, что мы всегда, когда так будет называться реку,
[23:54.480 --> 23:59.480]  не попадем в клубы с массива T, которые не отмечают наши вершины,
[23:59.480 --> 24:02.480]  а просто мы с излишком выдали вот в этом излишком.
[24:03.480 --> 24:07.480]  Нет, ничего плохого не произойдет, потому что у меня всегда спуски корректные.
[24:07.480 --> 24:11.480]  Я всегда, смотрите, я всегда проверяю, вот у меня вершина V,
[24:11.480 --> 24:14.480]  она либо лист, тогда я сразу завершаю рекурсию,
[24:14.480 --> 24:17.480]  либо у него, у него есть два сына, ну потому что как раз у вершины V,
[24:17.480 --> 24:21.480]  если этот отрезок нетривиальный, то у него не пустой этот, не пустой этот.
[24:21.480 --> 24:22.480]  Значит у меня есть два сына.
[24:22.480 --> 24:26.480]  Но я просто понимаю, в каком из них лежит поз, и туда и иду.
[24:26.480 --> 24:29.480]  Я никогда не делаю чего-то запрещенного, я всегда спускаюсь только туда,
[24:29.480 --> 24:32.480]  только в такие отрезки, которые контролирует поз.
[24:32.480 --> 24:34.480]  Поэтому, поэтому это все всегда корректно.
[24:34.480 --> 24:38.480]  Вот, значит мы такой код написали, так, у меня скобка не закрылась здесь,
[24:38.480 --> 24:40.480]  ну где-то вот здесь она заканчивается.
[24:40.480 --> 24:43.480]  Вот, если мы хотим отвечать на запрос типа обновления в точке,
[24:43.480 --> 24:49.480]  я должен буду из, ну там, основного кода программы вызвать апдейт от корня.
[24:49.480 --> 24:52.480]  Да, я же говорю, что мы начинаем в корне, вот давайте напишем параметры корня.
[24:52.480 --> 24:56.480]  Значит апдейт единица, потому что это номер корня 1,
[24:56.480 --> 25:00.480]  контролируемый корнем под отрезок это 0, n-1.
[25:00.480 --> 25:06.480]  Вот, ну и поз х это параметры запроса, они остаются прямо как мы считали из инпута.
[25:06.480 --> 25:10.480]  Вот, то есть этот апдейт работает следующим образом,
[25:10.480 --> 25:14.480]  чтобы его запустить при обработке запроса надо написать такую строчку.
[25:14.480 --> 25:18.480]  Потому что мы начинаемся в корне, контролируемый корнем под отрезок это 0, n-1,
[25:18.480 --> 25:20.480]  поз х то, что мы считали.
[25:20.480 --> 25:24.480]  Окей? Кайф.
[25:25.480 --> 25:29.480]  Так, давайте я это оставлю, вот это вот сотру.
[25:29.480 --> 25:33.480]  Теперь давайте перейдем к гетсаму.
[25:33.480 --> 25:37.480]  Как сказать сумму на отрезке?
[25:37.480 --> 25:40.480]  Ну, гетсам.
[25:40.480 --> 25:42.480]  Значит, синтаксис очень похожий.
[25:42.480 --> 25:46.480]  Мы стоим в какой-то вершине,
[25:46.480 --> 25:51.480]  и у нас есть некий отрезок, с которым мы хотели бы посчитать сумму.
[25:51.480 --> 25:55.480]  Lr. Мы хотим найти эту сумму.
[25:55.480 --> 25:58.480]  Опять-таки из мейна я потом буду запускаться от корня,
[25:58.480 --> 26:01.480]  то есть у меня будет изначально v1, tl0, tr, n-1,
[26:01.480 --> 26:05.480]  то есть я стою в корне и хочу найти сумму на отрезке Lr.
[26:05.480 --> 26:08.480]  Вот, ну первая проверка такая,
[26:08.480 --> 26:11.480]  что если я попал в вершину,
[26:11.480 --> 26:15.480]  которая целиком соответствует нашему отрезку,
[26:15.480 --> 26:19.480]  тогда я могу просто вернуть то, что написано в этой вершине.
[26:21.480 --> 26:24.480]  То есть если я попал в вершину,
[26:24.480 --> 26:27.480]  которая прям абсолютно такая же,
[26:27.480 --> 26:30.480]  то есть она контролирует такой же подотрезок,
[26:30.480 --> 26:33.480]  с которым нужно найти сумму.
[26:33.480 --> 26:36.480]  Ну, значит мы просто знаем на нем сумму,
[26:36.480 --> 26:39.480]  ее можно просто вернуть и вниз не идти.
[26:39.480 --> 26:42.480]  Это вот случай обрубания, что вниз нет смысла идти,
[26:42.480 --> 26:45.480]  потому что и так отрезок, который мне нужен,
[26:45.480 --> 26:48.480]  совпадает с тем, что я храню.
[26:48.480 --> 26:51.480]  Ну, дальше давайте что-нибудь напишем,
[26:51.480 --> 26:54.480]  давайте я напишу какой-нибудь int.
[26:54.480 --> 26:57.480]  Давайте скажем, что сумма равна нулю,
[26:57.480 --> 27:00.480]  изначально найденная нами.
[27:00.480 --> 27:03.480]  Посчитаем границу разделения сыновей,
[27:03.480 --> 27:06.480]  tr плюс tr пополам, как обычно.
[27:06.480 --> 27:09.480]  И дальше та самая логика, есть ли смысл идти влево,
[27:09.480 --> 27:12.480]  есть ли смысл идти влево, есть ли смысл идти вправо.
[27:12.480 --> 27:15.480]  Обе эти проверки сделаем, если нужно запустимся вот лево-право сына.
[27:15.480 --> 27:18.480]  Значит как проверить, что есть смысл идти влево?
[27:18.480 --> 27:21.480]  Смотрите, вот у меня был большой отрезок stl по tr,
[27:21.480 --> 27:24.480]  в нем как-то был вложен отрезок lr.
[27:24.480 --> 27:27.480]  Я делю большой отрезок на 2,
[27:27.480 --> 27:30.480]  stl по tm и stm плюс 1 по tr.
[27:30.480 --> 27:33.480]  Вот вопрос, мой отрезок lr, он когда задевает левого сына?
[27:33.480 --> 27:36.480]  Когда есть смысл идти влево?
[27:36.480 --> 27:39.480]  Когда есть лево.
[27:39.480 --> 27:42.480]  До l слева еще раз.
[27:42.480 --> 27:49.480]  Да, когда левая граница не больше, чем правая граница вот этого вот левого сына.
[27:49.480 --> 27:54.480]  То есть если l меньше либо равно tm,
[27:54.480 --> 27:58.480]  это в точности условия пересекаемости интересующего отрезка
[27:58.480 --> 28:01.480]  и вот этого подрезка левого сына.
[28:01.480 --> 28:04.480]  Что левая граница его не правее, чем tm.
[28:04.480 --> 28:07.480]  В этом случае мне есть смысл идти влево.
[28:07.480 --> 28:10.480]  Ну и давайте я напишу такую штуку.
[28:10.480 --> 28:13.480]  Я к ответу прибавлю get some.
[28:13.480 --> 28:16.480]  Так я скорее всего не влезу, ну ладно.
[28:16.480 --> 28:19.480]  Параметры левого сына мы знаем.
[28:19.480 --> 28:22.480]  Это 2v, tl, tm.
[28:22.480 --> 28:25.480]  Это мы написали.
[28:25.480 --> 28:28.480]  Теперь смотрите, я мог бы оставить lr,
[28:28.480 --> 28:33.480]  но я обычно пишу так, я пересеку отрезок lr с левым сыном,
[28:33.480 --> 28:37.480]  чтобы у меня не было такого, что интересующий меня под отрезок какой-то слишком большой
[28:37.480 --> 28:39.480]  и лежит где-то вне моего отрезка.
[28:39.480 --> 28:42.480]  Чтобы не оставалось вот так вот, чтобы вот такая картинка не оставалась,
[28:42.480 --> 28:47.480]  я ограничу lr на внутренность отрезка tl, tm.
[28:47.480 --> 28:58.480]  То есть я оставлю l на месте, а вместо r напишу минимум из r и tm.
[28:58.480 --> 29:01.480]  Ну потому что понятно, если у меня был такой отрезок lr,
[29:01.480 --> 29:03.480]  с которого нужно было найти сумму,
[29:03.480 --> 29:05.480]  а я спускаюсь только в левого сына,
[29:05.480 --> 29:08.480]  то мне нужно этот отрезок сузить на область определения,
[29:08.480 --> 29:10.480]  только вот на внутренность этого отрезка.
[29:10.480 --> 29:12.480]  Поэтому левая граница остается на месте,
[29:12.480 --> 29:15.480]  а вот правая, если нужно, двигается на tm.
[29:15.480 --> 29:17.480]  То есть если r было и так внутри,
[29:17.480 --> 29:19.480]  то есть если у меня была картинка вот такая,
[29:19.480 --> 29:21.480]  то здесь минимум будет просто r,
[29:21.480 --> 29:23.480]  а если он вот так именно пересекал,
[29:23.480 --> 29:25.480]  то я r будет больше, чем tm,
[29:25.480 --> 29:28.480]  и она сдвинется вот сюда, и я буду искать сумму уже вот на таком отрезке.
[29:28.480 --> 29:30.480]  От l до tm.
[29:33.480 --> 29:35.480]  Ну все, теперь то же самое с правым сыном.
[29:36.480 --> 29:38.480]  Давайте.
[29:46.480 --> 29:48.480]  Сейчас еще раз. Вот здесь вот?
[29:49.480 --> 29:51.480]  Так, что здесь должно быть?
[29:54.480 --> 29:56.480]  Нет, вот я так не хочу делать,
[29:56.480 --> 29:59.480]  потому что вы всегда говорите, что отрезок lr вложен в контролируемый мой подотрезок.
[29:59.480 --> 30:02.480]  Именно поэтому я здесь чем-то занимаюсь таким,
[30:02.480 --> 30:05.480]  что я сдвигаю правую границу, если нужно, направо.
[30:05.480 --> 30:08.480]  То есть у меня всегда lr, это всегда под отрезок tltr.
[30:08.480 --> 30:10.480]  То есть у меня будет всегда верно такое,
[30:10.480 --> 30:14.480]  что отрезок lr – это подмножество под отрезка tltr.
[30:16.480 --> 30:18.480]  В этом случае достаточно равенства проверять.
[30:19.480 --> 30:22.480]  Но зато здесь нужно будет тогда пересекать отрезок lr
[30:22.480 --> 30:24.480]  с областью определения любого сыновей.
[30:26.480 --> 30:28.480]  Так.
[30:31.480 --> 30:33.480]  Ну все, теперь правый сын.
[30:34.480 --> 30:37.480]  То же самое, надо проверить, пересекается ли отрезок lr с правым сыном.
[30:38.480 --> 30:40.480]  Это можно сделать так, если r больше, чем tm.
[30:43.480 --> 30:46.480]  Потому что надо проверить, что правая граница лежит в правом сыне.
[30:46.480 --> 30:50.480]  Это значит, что r больше, чем tm, то есть больше, чем tm плюс один.
[30:51.480 --> 30:58.480]  В этом случае я опять-таки к ответу прибавляю get sum от правого сына.
[30:58.480 --> 31:03.480]  dwv плюс один, tm плюс один, tr.
[31:05.480 --> 31:09.480]  Ну и теперь опять мне нужно сузить lr на область определения правого сына.
[31:10.480 --> 31:16.480]  В этом случае мне придется написать максимум из l и tm плюс один, и r.
[31:20.480 --> 31:22.480]  Потому что у меня был отрезок lr,
[31:22.480 --> 31:25.480]  правая граница r и так попадает в правый сын.
[31:25.480 --> 31:27.480]  Это мы проверили, r менять не нужно.
[31:27.480 --> 31:30.480]  Но если что, мне нужно ограничить левую границу на tm плюс один.
[31:30.480 --> 31:33.480]  Если l вылезала сюда, то мне нужно l обновить
[31:33.480 --> 31:35.480]  и сказать, что вместо нее будет tm плюс один.
[31:35.480 --> 31:37.480]  То есть я буду искать сумму на вот этом отрезке.
[31:40.480 --> 31:42.480]  Ну все, это мы сделали.
[31:42.480 --> 31:44.480]  И в конце концов делаем ретюрнанс.
[31:46.480 --> 31:48.480]  То есть мы, если нужно, нашли сумму с левого сына,
[31:48.480 --> 31:50.480]  с правого сына, сложили их вместе
[31:50.480 --> 31:52.480]  и вернули в качестве ответа.
[31:55.480 --> 31:57.480]  Если мы хотим это вызвать из мейна,
[31:57.480 --> 32:01.480]  то мне нужно будет написать get sum
[32:01.480 --> 32:03.480]  опять-таки от корня.
[32:03.480 --> 32:05.480]  1, 0, n, минус 1.
[32:05.480 --> 32:08.480]  Ну и на том отрезке, который меня интересует lr.
[32:14.480 --> 32:16.480]  Вопросы?
[32:16.480 --> 32:19.480]  Почему вы номируете вершины с единички?
[32:19.480 --> 32:21.480]  Хочу.
[32:33.480 --> 32:35.480]  Так, хорошо.
[32:35.480 --> 32:37.480]  Давайте теперь о программе работы поговорим.
[32:37.480 --> 32:40.480]  Понятно, что update тривиальным образом работает за логарифм.
[32:40.480 --> 32:43.480]  Я это уже сказал, потому что мы просто за глубину дерева это делаем.
[32:43.480 --> 32:45.480]  Теперь давайте докажем, что get sum
[32:45.480 --> 32:48.480]  даже несмотря на свою такую кажущуюся наивность,
[32:48.480 --> 32:50.480]  он тоже работает за логарифмическое время.
[32:50.480 --> 32:57.480]  Давайте покажем утверждение, что get sum работает
[32:57.480 --> 33:01.480]  за от логарифма n.
[33:06.480 --> 33:08.480]  Ну давайте доказывать.
[33:09.480 --> 33:13.480]  Давайте промоделируем поведение нашего get sum.
[33:13.480 --> 33:15.480]  Что происходит?
[33:15.480 --> 33:17.480]  Смотрите, мы встаем в корень,
[33:17.480 --> 33:21.480]  и у нас есть некоторый интересующий нас подрезок lr.
[33:21.480 --> 33:25.480]  Давайте я скажу не умоляю общности, что происходит примерно следующее.
[33:25.480 --> 33:28.480]  Сначала, в течение нескольких итераций,
[33:28.480 --> 33:30.480]  мы идем только в одного из сыновей.
[33:30.480 --> 33:33.480]  Например, если наш отрезок lr достаточно маленький,
[33:33.480 --> 33:36.480]  то скорее всего несколько первых итераций я не буду раздваиваться
[33:36.480 --> 33:38.480]  и идти влево и вправо сына.
[33:38.480 --> 33:41.480]  Я сначала скорее всего пойду просто по какой-то одной ветке.
[33:41.480 --> 33:44.480]  Давайте скажем, что мы сначала идем по какой-то ветке,
[33:44.480 --> 33:47.480]  скажем влево, вправо, в общем, как-то ходим, не раздваиваясь.
[33:47.480 --> 33:50.480]  Вот давайте я скажу, что на всех этих вот спусках
[33:50.480 --> 33:53.480]  у меня из двух сыновей запускался только один.
[33:53.480 --> 33:56.480]  Ну как видите, у меня есть раздвоение влево сына, вправо сына.
[33:56.480 --> 33:59.480]  Вот давайте несколько первых шагов мы не раздваивались.
[33:59.480 --> 34:02.480]  Ну понятно, сколько таких шагов было?
[34:02.480 --> 34:06.040]  Дальше вот рассмотрим первую вершину, в которой мы сделали раздвоение.
[34:06.040 --> 34:09.740]  Ну, если таких не было, то понятно ответ уже логарифм,
[34:09.740 --> 34:14.240]  время точнее уже логарифм, потому что мы просто спускались по одной ветке, без разделения.
[34:14.240 --> 34:17.840]  Вот пусть это первая вершина, где мы произошли, где у нас было разделение.
[34:17.840 --> 34:22.340]  Так, ну первое замечание, что вот это вот по-прежнему не больше логарифма.
[34:22.340 --> 34:27.840]  Что количество итераций от корня до этой вершины максимум логарифм, потому что мы просто спускались как-то.
[34:27.840 --> 34:30.340]  Теперь что происходит здесь?
[34:30.700 --> 34:32.700]  Вот пусть мы здесь впервые раздвоились.
[34:34.700 --> 34:36.700]  Значит давайте картинка какая-нибудь.
[34:36.700 --> 34:42.700]  Что это значит? Это значит, что если эта вершина В контролировала вот такой вот подотрезок,
[34:42.700 --> 34:47.700]  соответственно ее дети разбивали большой подотрезок на два.
[34:47.700 --> 34:49.700]  Вот это левый, вот это правый.
[34:49.700 --> 34:54.200]  Значит интересующий мне отрезок LR, он был какой-то вот такой вот.
[34:54.200 --> 35:00.200]  Ну раз я пошел и влево и вправо, значит мой LR пересекал границу, пересекал середину.
[35:00.200 --> 35:02.200]  У меня что-то здесь лежит, что-то здесь лежит.
[35:02.200 --> 35:04.200]  Вот, хорошо.
[35:04.200 --> 35:12.200]  Ну тогда я утверждаю следующее, что во всей левой ветке у меня никогда не будет содержательных разветвлений.
[35:12.200 --> 35:16.200]  То есть смотрите, вот есть левая ветка, скажем, я спустился в левого сына.
[35:16.200 --> 35:20.200]  Давайте представим себе, что в этой вершине я опять иду влево и вправо.
[35:20.200 --> 35:22.200]  И влево и вправо.
[35:22.200 --> 35:26.200]  То есть у меня рекурсия вызывает и левого сына, и правого сына.
[35:26.200 --> 35:30.200]  Ну смотрите, в этом случае понятно, что в правом сыне я вниз уже никуда не пойду.
[35:30.200 --> 35:37.200]  Потому что если я запустился здесь и влево и вправо, значит контролируемый подотрезок детьми разбивается так,
[35:37.200 --> 35:43.200]  что у меня правый сын полностью вложен в мой отрезок LR, и еще что-то остается слева.
[35:43.200 --> 35:47.200]  То есть еще какие-то элементы отрезка LR уходят в левого сына.
[35:47.200 --> 35:55.200]  Ну то есть именно за счет того, что LR пересек вот эту вот границу когда-то единожды, значит все вот эти вот элементы точно нужно взять в ответ.
[35:55.200 --> 36:00.200]  И если я из какой-то вершины иду направо здесь, то ниже из нее я уже не спускаюсь.
[36:00.200 --> 36:02.200]  Потому что она полностью вложена в отрезок LR.
[36:02.200 --> 36:07.200]  Значит мне не нужно идти вниз от этой вершины, в ней так уже хранится полностью блок, который мне нужен.
[36:07.200 --> 36:12.200]  А почему она просто вложена в отрезок LR, который вообще не вложен, а равностью проверяет, почему он вызывает?
[36:12.200 --> 36:19.200]  Ну потому что мы уже пересечем, у нас был LR, когда я спускаюсь в левого сына, у меня LR становится вот таким вот.
[36:19.200 --> 36:24.200]  Потому что я R, там написано, что я вместо R передаю минимум из R и TM.
[36:24.200 --> 36:28.200]  То есть на самом деле при спуске влево у меня LR станет вот таким.
[36:28.200 --> 36:32.200]  Дальше я здесь опять раздваиваюсь, влево передаю вот эту штуку, а вправо вот эту.
[36:32.200 --> 36:34.200]  Но она в точности совпадает с контрольным подотрезком.
[36:34.200 --> 36:37.200]  Значит ниже отсюда я уже не спускаюсь.
[36:37.200 --> 36:40.200]  И то же самое верно для всех вершин вот этой вот левой цепочки.
[36:40.200 --> 36:49.200]  То есть если я внезапно как-то хожу, если я в какой-то вершине опять раздваиваюсь, то правая вершина целиком вложена в отрезок LR.
[36:49.200 --> 36:53.200]  Ну потому что какие-то интересующие у меня есть слева, раз я налево пошел.
[36:53.200 --> 36:57.200]  А справа я знаю, что все вот эти вот элементы интересуют меня.
[36:57.200 --> 37:01.200]  Значит направо, если я пошел, то дальше вниз я уже не раздваиваюсь.
[37:01.200 --> 37:05.200]  Потому что весь отрезок интересующий меня содержит...
[37:05.200 --> 37:09.200]  Ну в общем, все, что я контролирую, меня интересует. Я это добавляю к ответу сразу.
[37:11.200 --> 37:14.200]  Это значит, что по существу я здесь просто иду по левой ветке.
[37:14.200 --> 37:19.200]  То есть даже если я где-то раздваиваюсь, то в правом сыне я вниз уже рекурсов не запускаю.
[37:19.200 --> 37:22.200]  Поэтому суммарно вот здесь я перегружу максимум два логен вершин.
[37:22.200 --> 37:27.200]  То есть я зайду максимум в два логен вершин, потому что если я раздваиваюсь, то вправо не иду.
[37:27.200 --> 37:31.200]  То есть если я раздвоился, то правый сын сразу обрубаю.
[37:31.200 --> 37:37.200]  Поэтому не может быть такого, что я там длинно-длинно рекурсивно обхожу все дерево, грубо говоря.
[37:37.200 --> 37:39.200]  У меня вот эта правая ветка всегда тривиальна.
[37:39.200 --> 37:41.200]  Ну и симметрично работает то же самое вот здесь.
[37:41.200 --> 37:46.200]  Если я внезапно в какой-то момент времени раздвоился и пошел и налево, и направо,
[37:46.200 --> 37:50.200]  то это значит, что какие-то интересующие элементы были вот здесь вот.
[37:50.200 --> 37:53.200]  Значит все вот эти вот элементы были вот здесь вот.
[37:53.200 --> 37:59.200]  То есть все, что контролировался этой вершиной, целиком вложено в интересующий мне отрезок LR.
[37:59.200 --> 38:02.200]  Значит здесь я не буду спускаться рекурсивно.
[38:02.200 --> 38:04.200]  Короче, то же самое, только зеркально отраженное.
[38:04.200 --> 38:08.200]  Если я спускаюсь и влево, и вправо, то из левого сына я вниз не иду.
[38:08.200 --> 38:10.200]  Потому что он полностью вложен в LR.
[38:11.200 --> 38:14.200]  Значит здесь опять-таки тоже максимум 2 log N вершин.
[38:15.200 --> 38:19.200]  Ну все, суммарно получилось, что я обошел 5 log N вершин.
[38:19.200 --> 38:21.200]  Наверное эту константу как-нибудь можно уменьшить.
[38:21.200 --> 38:23.200]  Типа там кажется вообще на самом деле максимум 2 logarithm N.
[38:23.200 --> 38:27.200]  Ну неважно, нам на константу обычно пофигу.
[38:27.200 --> 38:29.200]  Ну вот, все.
[38:29.200 --> 38:33.200]  Значит я в процессе моего вот этого getSum'а обхожу максимум от log N вершин.
[38:33.200 --> 38:37.200]  А понятно, что время работает пропорционально на числу вершин, которые я обхожу.
[38:38.200 --> 38:43.200]  Ну все, значит суммарно это логарифма.
[38:53.200 --> 38:57.200]  Ну смотрите, не совсем, потому что раздвоения бывают довольно часто.
[38:57.200 --> 39:02.200]  Но если я и раздваиваюсь, то я не иду дальше вот здесь вот от левого сына.
[39:02.200 --> 39:05.200]  То есть смотрите, картинка может быть такой, что я раздвоился вот здесь,
[39:05.200 --> 39:07.200]  дальше постоянно раздваиваюсь вот так вот,
[39:09.200 --> 39:12.200]  но просто отсюда я ниже не иду, то есть картинка может быть такая.
[39:12.200 --> 39:16.200]  То есть раздвоений может быть много, если там отрезок какой-то вот такой вот.
[39:16.200 --> 39:20.200]  То есть я и здесь раздвоился, и здесь мне нужно пойти и направо, и налево.
[39:20.200 --> 39:22.200]  И здесь я просто не спускаюсь вниз.
[39:22.200 --> 39:29.200]  Тут раздвоился, здесь не спускаюсь.
[39:29.200 --> 39:31.200]  Существенно FitO해� is 1.
[39:31.200 --> 39:33.200]  Да, существенно 1, правильно.
[39:33.200 --> 39:35.200]  одно, а все остальные сразу обрубаются.
[39:35.200 --> 39:37.200]  Это правда.
[39:37.200 --> 39:39.200]  Откуда взялось число 2 лога?
[39:39.200 --> 39:41.200]  Откуда взялось число 2 лога? Ну, смотрите,
[39:41.200 --> 39:43.200]  глубина вот этого дерева максимум логарифом,
[39:43.200 --> 39:45.200]  на каждом шаге я в худшем случае
[39:45.200 --> 39:47.200]  как бы спускаюсь в двух детей,
[39:47.200 --> 39:49.200]  то есть на каждом слой я максимум две
[39:49.200 --> 39:51.200]  вершины посмотрю. Вот так можно сказать.
[39:51.200 --> 39:53.200]  Что на каждом уровне у меня
[39:53.200 --> 39:55.200]  максимум две вершины обработаются, левая и
[39:55.200 --> 39:57.200]  правая, потому что если у меня есть, скажем,
[39:57.200 --> 39:59.200]  две вершины, то дальше вниз я отсюда
[39:59.200 --> 40:01.200]  не пойду, у меня остается только вот эта одна.
[40:01.200 --> 40:03.200]  Дальше она может дать две вершины на следующем уровне,
[40:03.200 --> 40:05.200]  отсюда дальше не пойду,
[40:05.200 --> 40:07.200]  это даст две вершины на следующем уровне и так далее.
[40:07.200 --> 40:09.200]  Поэтому двойки на каждом уровне,
[40:09.200 --> 40:11.200]  значит 2 лога.
[40:11.200 --> 40:13.200]  Ну вот, как-то так.
[40:21.200 --> 40:23.200]  Все, победа.
[40:23.200 --> 40:25.200]  Да.
[40:25.200 --> 40:27.200]  Ну, вот, сейчас,
[40:27.200 --> 40:29.200]  видишь, одна ситуация,
[40:29.200 --> 40:31.200]  когда мы репульсивно спускаемся
[40:31.200 --> 40:33.200]  из какой-то вершины,
[40:33.200 --> 40:35.200]  и при этом от обоих ее детей
[40:35.200 --> 40:37.200]  делаем еще какие-то репульсивные...
[40:37.200 --> 40:39.200]  Все верно, все верно, все верно, да.
[40:39.200 --> 40:41.200]  Доказали, да, да.
[40:41.200 --> 40:43.200]  Значит, суммарно логарифм.
[40:43.200 --> 40:45.200]  Да.
[40:45.200 --> 40:47.200]  Вот, хорошо.
[40:47.200 --> 40:49.200]  Ну, смотрите, пафос в том, что мы действуем
[40:49.200 --> 40:51.200]  как бы довольно жадно, довольно наивно,
[40:51.200 --> 40:53.200]  и это все равно будет быстро.
[40:53.200 --> 40:55.200]  Вот как хорошо.
[40:55.200 --> 40:57.200]  Окей, значит, давайте двигаться дальше,
[40:57.200 --> 40:59.200]  давайте посмотрим еще какие-то задачи,
[40:59.200 --> 41:01.200]  которые можно было бы решать с помощью деревоотресков.
[41:01.200 --> 41:03.200]  Вот, поймем, что можно вообще,
[41:03.200 --> 41:05.200]  можно им делать.
[41:07.200 --> 41:09.200]  Так.
[41:13.200 --> 41:15.200]  Значит, ну, задача.
[41:15.200 --> 41:17.200]  Давайте я такую сделаю,
[41:17.200 --> 41:19.200]  для примера.
[41:19.200 --> 41:21.200]  Представьте, есть массив чисел.
[41:23.200 --> 41:25.200]  Давайте скажем, что они все не отрицательные всегда.
[41:27.200 --> 41:29.200]  Поступают запросы двух типов.
[41:29.200 --> 41:31.200]  Во-первых, это опять апдейт в точке.
[41:31.200 --> 41:33.200]  Значит, давайте обновление в точке.
[41:35.200 --> 41:37.200]  То есть там конкретное апостоле
[41:37.200 --> 41:39.200]  заменить на х.
[41:39.200 --> 41:41.200]  И второй, давайте я пишу такой.
[41:43.200 --> 41:45.200]  Значит,
[41:45.200 --> 41:47.200]  мне дают,
[41:49.200 --> 41:51.200]  мне дают два числа, l и x.
[41:53.200 --> 41:55.200]  Мне нужно найти самый короткий отрезок,
[41:55.200 --> 41:57.200]  начинающийся в позиции l,
[41:57.200 --> 41:59.200]  на котором сумма была бы хотя бы x.
[42:01.200 --> 42:03.200]  Значит, картинка вот такая.
[42:03.200 --> 42:05.200]  Вот есть у меня весь массив от 0 до и на минус 1.
[42:05.200 --> 42:07.200]  Мне дают левую границу,
[42:07.200 --> 42:09.200]  и говорят мне,
[42:09.200 --> 42:11.200]  набери сумму хотя бы x.
[42:11.200 --> 42:13.200]  То есть ты можешь идти направо,
[42:13.200 --> 42:15.200]  чтобы сумма была хотя бы x.
[42:15.200 --> 42:17.200]  Так вот, насколько шагов,
[42:17.200 --> 42:19.200]  то есть сколько элементов, начиная с l, нужно взять,
[42:19.200 --> 42:21.200]  чтобы впервые сумма стала хотя бы x.
[42:21.200 --> 42:23.200]  То есть формально
[42:23.200 --> 42:25.200]  это нужно найти
[42:25.200 --> 42:27.200]  минимальная r.
[42:27.200 --> 42:29.200]  Такое, что сумма элементов с a, l по a, r
[42:31.200 --> 42:33.200]  больше равна x.
[42:37.200 --> 42:39.200]  Все то же самое, а на это как отвечать?
[42:39.200 --> 42:41.200]  Аналогично.
[42:41.200 --> 42:43.200]  Мы спускаемся, и когда мы спускаемся
[42:43.200 --> 42:45.200]  вправо, мы спускаемся,
[42:45.200 --> 42:47.200]  пока мы больше не равны x.
[42:47.200 --> 42:49.200]  Потому что если на следующем спуске мы меньше равны x,
[42:49.200 --> 42:51.200]  тогда все плохо, мы не спускаемся.
[42:53.200 --> 42:55.200]  Ну вот не очень понятно.
[42:55.200 --> 42:57.200]  Мне нет.
[42:57.200 --> 42:59.200]  Ау?
[42:59.200 --> 43:01.200]  Ну бинарный спуск, да, на самом деле.
[43:03.200 --> 43:05.200]  А нельзя начать путь
[43:05.200 --> 43:07.200]  с вершины a, l, которые вы знаете,
[43:07.200 --> 43:09.200]  и подниматься, пока мы заберем
[43:09.200 --> 43:11.200]  достаточную сумму.
[43:11.200 --> 43:13.200]  Так, а потом
[43:13.200 --> 43:15.200]  спускаться в другую ветку,
[43:15.200 --> 43:17.200]  пока мы не урежем достаточно.
[43:17.200 --> 43:19.200]  Ну можно так, да,
[43:19.200 --> 43:21.200]  можно так тоже.
[43:21.200 --> 43:23.200]  Вот на самом деле много подходов,
[43:23.200 --> 43:25.200]  я согласен. Давайте расскажу
[43:25.200 --> 43:27.200]  тот, который мне кажется наиболее
[43:27.200 --> 43:29.200]  обобщающимся на всякие другие случаи.
[43:29.200 --> 43:31.200]  Ну понятно, первую штуку
[43:31.200 --> 43:33.200]  мы уже обрабатывать умеем.
[43:33.200 --> 43:35.200]  Давайте сразу скажу, что в дереве отрезков
[43:35.200 --> 43:37.200]  я опять в каждой вершине буду просто хранить сумму
[43:37.200 --> 43:39.200]  Значит, тогда первую мы уже обрабатывать умеем,
[43:39.200 --> 43:41.200]  это уже написали такой код.
[43:41.200 --> 43:43.200]  Теперь давайте поймем, что происходит вот здесь.
[43:45.200 --> 43:47.200]  Что происходит вот здесь.
[43:47.200 --> 43:49.200]  Окей.
[43:49.200 --> 43:51.200]  Давайте я виртуально в голове вызову getSum
[43:53.200 --> 43:55.200]  для, ну l равно l
[43:55.200 --> 43:57.200]  и r равно n-1.
[43:57.200 --> 43:59.200]  Давайте так я сделаю.
[43:59.200 --> 44:01.200]  Ну, потому что понятно,
[44:01.200 --> 44:03.200]  скажем, если у меня сумма на этом отрезке
[44:03.200 --> 44:05.200]  меньше, чем x, то ответ не существует.
[44:05.200 --> 44:07.200]  Ну что, нет никакого r, чтобы сумма была хотя бы x.
[44:07.200 --> 44:09.200]  Поэтому в каком-то смысле мне
[44:09.200 --> 44:11.200]  эту сумму все равно найти придется,
[44:11.200 --> 44:13.200]  вот давайте я ее типа найду.
[44:13.200 --> 44:15.200]  Значит, что произошло?
[44:15.200 --> 44:17.200]  Мы понимаем, что getSum он лениво просто встает
[44:17.200 --> 44:19.200]  в корень и дальше идет туда,
[44:19.200 --> 44:21.200]  куда имеет смысл.
[44:21.200 --> 44:23.200]  И заканчивается в тех вершинах,
[44:23.200 --> 44:25.200]  из которых вниз уже спускаться не нужно.
[44:25.200 --> 44:27.200]  Так вот, это получается, что весь мой отрезок
[44:27.200 --> 44:29.200]  с l по n-1
[44:29.200 --> 44:31.200]  в процессе вот этого рекурсивного getSum'а
[44:31.200 --> 44:33.200]  он по факту разбивается
[44:33.200 --> 44:35.200]  на какие-то подотрески,
[44:35.200 --> 44:37.200]  контролируемые конкретными вершинами.
[44:37.200 --> 44:39.200]  Вот этот getSum' он как заканчивает
[44:39.200 --> 44:41.200]  работу? Он находит какую-то вершину, контролирующую
[44:41.200 --> 44:42.000]  такой подотрезок, какую-то вершину,
[44:42.000 --> 44:43.200]  контролирующую
[44:43.200 --> 44:45.200]  такой, и что-то здесь там, как-то еще
[44:45.200 --> 44:47.200]  подразбивает. То есть по факту мы разбили
[44:47.200 --> 44:49.200]  наш отрезок интересующий outer
[44:49.200 --> 44:51.200]  на какие-то подотрески,
[44:55.200 --> 44:57.200]  которые явным образом контролируются
[44:57.200 --> 44:59.200]  вершинами, да, и мы знаем сумму здесь, сумму здесь,
[44:59.200 --> 45:01.200]  сумму здесь, сумму здесь. Значит мы можем
[45:01.200 --> 45:05.280]  всех сложить, будет ответ на сумму.
[45:05.280 --> 45:07.860]  Причем мы знаем, что таких отрезков логарифмическое количество от
[45:07.860 --> 45:12.940]  логарифма. Ну вот дальше я предлагаю сделать
[45:12.940 --> 45:17.540]  следующим образом. Вот у меня есть мой отрезок lr, то есть l-n-1,
[45:17.540 --> 45:22.540]  разбився на небольшое количество подотресков, я знаю сумму на каждом, и мне
[45:22.540 --> 45:25.700]  нужно найти, когда впервые сумма слева направо превысит x.
[45:25.700 --> 45:29.900]  Ну давайте пойдем по этим вершинам слева направо. Считаем сумму здесь, сумму
[45:29.900 --> 45:33.360]  здесь, сумму здесь, сумму здесь. Вот давайте ее наращивать, то есть прибавлять
[45:33.360 --> 45:37.840]  каждый раз сумму в текущей вершине, и дождемся, когда она впервые превысит x.
[45:37.840 --> 45:41.720]  То есть если, скажем, сумма здесь плюс сумма здесь меньше, чем x, значит мне нужно
[45:41.720 --> 45:45.640]  все еще идти направо. Вот пусть впервые сумма превышает x в этой точке.
[45:45.640 --> 45:52.280]  Ну там больше права на x в этой точке. Что это значит? Давайте картинку перерисую.
[46:00.400 --> 46:05.440]  У меня был длинный подотрезок, я его разбил на некоторое количество отрезков
[46:05.440 --> 46:12.160]  поменьше. Знаю сумму здесь, сумму здесь, сумму здесь. И, например, я понял, что сумма
[46:12.160 --> 46:16.440]  это плюс это меньше, чем x. А вот здесь уже сумма больше, чем x. Если я все вот это
[46:16.440 --> 46:22.400]  вот сложу, то сумма будет больше на x. Тогда давайте мы встанем в эту вершину.
[46:22.400 --> 46:32.340]  Так. Да. И из нее эту задачу уже решать проще. Смотрите, я могу встать в эту вершину,
[46:32.340 --> 46:36.980]  мне нужно найти такой элемент, вот здесь, в этом контролируемом ею подотрезке,
[46:36.980 --> 46:42.820]  что вот здесь вот сумма, ну вот здесь вот общая сумма будет хотя бы x. И дальше уже работает
[46:42.820 --> 46:46.660]  та же самая жадная идея, потому что я стою в каком-то смысле в корне, ну там в корне
[46:46.660 --> 46:52.020]  своего поддерева. Здесь я могу пойти влево, могу пойти вправо. Есть ли смысл идти влево?
[46:52.040 --> 46:56.360]  Но если здесь вот сумма хотя бы x, то есть если вот эта вот сумма, плюс все вот это
[46:56.360 --> 47:02.080]  вот хотя бы x, то ответ точно в левой ветке. То есть если все что я уже посчитал, плюс то,
[47:02.080 --> 47:10.180]  что мне предлагается в левом сыне, хотя бы x, значит ответ точно где-то здесь, то
[47:10.180 --> 47:15.000]  есть граница проходит где-то здесь. Если же я сумму таким образом не набираю,
[47:15.000 --> 47:20.220]  то есть если у меня левый сын, плюс все что было слева, меньше, чем x, значит�도 вот это
[47:20.220 --> 47:25.020]  в правом сыне. И он точно в правом, потому что я знаю, что граница где-то вот в этом отрезке.
[47:25.020 --> 47:30.540]  Значит, мне нужно всегда либо налево пойти, если граница слева, либо направо, если граница справа.
[47:30.540 --> 47:37.460]  Да, да. То есть, еще раз, смотрите, у меня решение распалось на два шага. Во-первых,
[47:37.460 --> 47:42.940]  я сначала разбил интересующий мне отрезок на логарифмическое количество вершин в ДО,
[47:42.940 --> 47:49.820]  в дереве отрезков. Вот у меня были какие-то вершины. Дальше я иду по ним слева направо,
[47:49.820 --> 47:55.380]  насчитываю сумму, дожидаюсь, когда впервые сумма превысила x, стала хотя бы x. Это значит,
[47:55.380 --> 48:00.980]  что ответ, точнее, вот эта вот граница разделения, вот эта вот граница, она где-то внутри вот эта
[48:00.980 --> 48:05.100]  вот контролируемая под отрезка, где-то вот здесь. Значит, здесь его искать бессмысленно,
[48:05.100 --> 48:08.900]  а мне нужно искать его где-то здесь. И тогда дальше я просто запущу отдельную процедуру,
[48:08.900 --> 48:14.380]  которая встает в корень вот этого поддерева. Значит, я знаю эту вершину. И дальше он рекурсивно
[48:14.380 --> 48:19.540]  будет идти влево или вправо в поисках этой границы. Проверка очень простая. Есть ли смысл идти влево?
[48:19.540 --> 48:23.860]  То есть, правда ли, что граница находится в левом сыне? Это проверить легко. Надо узнать,
[48:23.860 --> 48:30.060]  что сумма здесь плюс то, что было слева, хотя бы x. Если это так, то значит, граница там. Если же нет,
[48:30.060 --> 48:33.540]  то граница точно справа, и мне нужно идти вправо сына.
[48:33.540 --> 48:39.540]  Почему вы считаете, что справа идти оптимальнее? Может быть, по-среднему оптимальнее?
[48:39.540 --> 48:48.020]  Не понял. Возможно, по бокам там сумма очень маленькая, а по среднему вся сумма.
[48:48.020 --> 48:54.340]  Во-первых, у меня все элементы не отрицательные. Во-вторых, у меня сумма такая нарастающая. То есть,
[48:54.340 --> 48:58.540]  я зафиксировал левую границу, я перебираю все вот такие вот суммы и дождаюсь, когда впервые x.
[48:58.540 --> 49:12.460]  Вот такая вот идея. Мы поделили так же, как на той доске написано, жадным алгоритмом GetSum.
[49:12.460 --> 49:18.260]  То есть, вот те вот спуски, которые опять спускаются туда, куда надо, они по факту,
[49:18.260 --> 49:24.500]  вот когда вот это вот условие срабатывает, вот это вот, вот такие все вершины будут контролирующими.
[49:24.500 --> 49:28.420]  Вот то, что здесь нарисовано, это вот как раз те вершины, откуда рекурс и вниз не идет.
[49:28.420 --> 49:33.020]  Их будет логарифм, мы знаем, что логарифм здесь всегда, всего логарифм. Вот их как раз логарифмическое
[49:33.020 --> 49:38.020]  количество. И дальше по ним идем слева-направо и выбираем ту первую, где сумма превысила x,
[49:38.020 --> 49:46.660]  там уже рекурсивно запускаемся. Да. А чем тогда вот алгоритм, который я уже говорил, здесь типа спускаться влево, пока типа ну это хорошо?
[49:46.660 --> 49:54.500]  Ну мы в каком смысле то же самое делаем, только ну мы не можем, как бы тут не понятно, что такое спускаться влево.
[49:54.500 --> 49:59.700]  Потому что если мы встанем в корень и пойдем налево, то нам нужно сначала понять сумму,
[49:59.700 --> 50:06.420]  которая является пересечением левого сына, и отрезка начинается с позиции L. Нам надо сначала найти эту сумму,
[50:06.420 --> 50:11.620]  потом если что пойти вправо или пойти влево. То есть мы как бы две задачи одновременно решаем.
[50:11.620 --> 50:17.340]  Так можно сделать, в данном конкретном случае это можно сделать, но в общем случае я бы сказал так,
[50:17.340 --> 50:22.180]  вот методологически проще рассматривать именно как бы, это как две отдельные задачи. Что мы сначала
[50:22.260 --> 50:29.020]  интересующий отрезок разбиваем на маленькое количество подотресков, и дальше понимаем, где проходит граница,
[50:29.020 --> 50:34.420]  и дальше уже в вершине, где находится граница, вот здесь вот внутри, дальше уже запускаем такой простой спуск.
[50:34.420 --> 50:41.540]  То есть здесь я пользуюсь тем, что у меня вот, то есть я делаю то, что вы говорите, для вершины, у которой контролируемый подотрезок
[50:41.540 --> 50:46.980]  полностью входит в область определения. То есть потому что у вас, если мы идем влево, а L это не ноль,
[50:46.980 --> 50:53.860]  то мне нужно, ну то есть как бы, у меня было бы что-то вот такое, да? Я контролирую вот это, а L где-то вот здесь вот начинается.
[50:53.860 --> 51:00.300]  Ну и вот непонятно, как найти здесь сумму элементов вот с этого по там, по что-то. Ну типа если бы было вот здесь, было бы круто.
[51:00.300 --> 51:06.860]  Вот я ровно это и добиваюсь. А вам нужно еще как-то думать, как искать вот эту вот сумму, как вот это отбросить, ну вот не хочу об этом думать.
[51:07.620 --> 51:08.620]  Да?
[51:12.980 --> 51:13.980]  А как на два?
[51:17.540 --> 51:18.540]  А как на два-то?
[51:20.180 --> 51:26.620]  Мы не умеем на два разбивать. Если бы на два разбивали, у нас бы тогда где-то сам за единицу работал. Ну то есть можно было бы за единицу написать.
[51:26.620 --> 51:35.340]  Нет, посмотрите, потому что на самом деле у меня в дереве отрезков каждый отрезок может покрыться, ну в худшем случае, логарифмическим количеством вершин.
[51:35.340 --> 51:49.820]  Более того, бывают такие, где именно логарифму придется. Потому что, например, если у вас, ну смотрите, если у вас общий отрезок это 0, n-1, а вам нужна сумма с единицы до n-2, тогда у вас будет примерно что-то вот такое.
[51:53.020 --> 52:00.140]  Вот это будет вот сюда контролировать, это сюда, это сюда, это сюда, ну и так далее. Типа в общем случае у вас не получится двумя.
[52:01.100 --> 52:10.540]  Я утверждаю, что, ну там, короче, если вы остановите картинку, рассмотрели отрезок с первого по предпоследней, то вы его просто двумя вершинами не накроете.
[52:10.540 --> 52:18.060]  У вас нет таких двух вершин, которые бы в сумме покрывали весь отрезок. Вот, в худшем случае их будет логарифм, и где-то сам говорит, что это за логарифм вершин.
[52:18.060 --> 52:21.060]  Вот те вершины, где рекурсия вниз не идет, те самые вершины.
[52:28.060 --> 52:29.060]  Ага, секунду.
[52:31.060 --> 52:39.060]  Последствия действий. Ну, это понятно? Вот этот запрос. Это точно так же, как раньше. Значит, здесь запрос такого типа.
[52:39.060 --> 52:48.060]  Два шага. Во-первых, мы сначала представляем отрезок с l по n-1, мы, точнее, его покрываем логарифмическим числом вершин DO.
[52:48.060 --> 52:58.060]  Для этого просто запускаем алгоритм аналогичный GetSum и записываем все вершины, из которых он ниже не спускается. То есть мы запоминаем все вот эти вершины.
[52:58.980 --> 53:00.980]  Непонятно. Плохо.
[53:04.980 --> 53:07.980]  Так, давайте GetSum тогда вспомним. Смотрите, вот, что он делает?
[53:08.980 --> 53:18.980]  Он идет вниз и завершает рекурсию, то есть выполняется вот это условие, когда контролируемый отрезок полностью вложен в LER.
[53:19.980 --> 53:23.980]  Как это работает на картинке? Вот было у меня большое дерево какое-то, большое дерево отрезков.
[53:24.980 --> 53:25.980]  Мне нужна была сумма вот здесь.
[53:26.900 --> 53:34.900]  Как я хожу? Я как-то там спускаюсь, где-то там раздваиваюсь, что-то делаю, и в каких-то местах у меня появляются вершины, где вот это условие срабатывает.
[53:35.900 --> 53:39.900]  То есть это такие вершины, что сумма в этой вершине меня полностью интересует.
[53:40.900 --> 53:43.900]  Значит, вот здесь вот, вот здесь вот я посчитал, и вот здесь вот посчитал.
[53:44.900 --> 53:52.900]  То есть в каком-то смысле GetSum делает следующее. Он просто разбивает отрезок LER на несколько подотресков, каждый из которых соответствует вершине DO.
[53:53.820 --> 53:56.820]  Это вот как раз такие вершины, из которых рекурсов вниз не спускается.
[53:57.820 --> 54:03.820]  Ну как бы мы понимаем, что у меня вернется правильная сумма, то есть в каком-то смысле я просто вот это вот разбил на меньшие подотрески, каждый из которых это вершина DO.
[54:04.820 --> 54:05.820]  Отлично.
[54:06.820 --> 54:14.820]  Так вот ровно это мы и сделаем. Мы сначала наш большой отрезок LER разобьем на несколько вершинок, то есть покроем вершинами деревоотресков.
[54:15.820 --> 54:22.820]  То есть я запускаю ту же самую процедуру и сохраняю все вершины, для которых произошло вот это вот условие.
[54:23.820 --> 54:25.820]  А мы вызываем A, B, N и O?
[54:26.820 --> 54:28.820]  Да, да. Ну то есть как бы понятно, в худшем случае у меня граница где-то вот здесь вот.
[54:29.820 --> 54:32.820]  Вот я давайте полностью весь этот отрезок разобью на подотрески.
[54:33.820 --> 54:34.820]  Значит это был первый шаг.
[54:35.820 --> 54:38.820]  Второй шаг, смотрите, вот у меня есть список вершин. Первая, вторая, третья, четвертая.
[54:39.820 --> 54:40.820]  Они у меня слева-направо легко упорядочены.
[54:42.820 --> 54:45.820]  Давайте пойдем по этим вершинам, будем считать сумму, которая написана в них.
[54:46.820 --> 54:47.820]  Вот это, плюс вот это, плюс вот это, плюс вот это.
[54:48.740 --> 54:52.740]  Посмотрим, когда впервые текущая набранная сумма будет больше она, чем x.
[54:53.740 --> 54:59.740]  То есть скажем, ну там не знаю, здесь 5, здесь 7, здесь 10 и x у меня было, скажем, 15.
[55:00.740 --> 55:05.740]  Значит здесь еще не хватает 5, 5 плюс 7, 12 тоже не хватает, значит мне нужно где-то справа искать.
[55:06.740 --> 55:09.740]  А 5 плюс 7 плюс 10 уже больше, чем 15, поэтому граница где-то вот здесь проходит.
[55:10.740 --> 55:15.740]  То есть впервые 15 достигается где-то на таком отрезке и граница находится внутри вот этого отрезка.
[55:16.660 --> 55:19.660]  Хорошо, значит мы знаем, что границу нужно искать только внутри вот этой штуки.
[55:20.660 --> 55:25.660]  И дальше будем ее искать, дальше вот второй шаг, ну или там третий можно сказать.
[55:26.660 --> 55:31.660]  Что мы встаем в эту вершину и дальше будем идти, ну дальше запускаем аналогичный рекурсивный спуск.
[55:32.660 --> 55:36.660]  Что мы идем либо влево, либо вправо в поисках того момента, когда впервые сумма будет хотя бы 15.
[55:37.660 --> 55:39.660]  То есть смотрите, здесь мы знаем, сумма уже 12.
[55:40.660 --> 55:42.660]  Значит мне нужно найти, когда здесь сумма будет хотя бы 3.
[55:43.660 --> 55:44.660]  Ну 15 минус 12.
[55:45.580 --> 55:49.580]  Смотрите, если здесь сумма, скажем, хотя бы 3, то граница точно слева.
[55:50.580 --> 55:51.580]  Граница прещения точно слева.
[55:52.580 --> 55:53.580]  А если она меньше 3, то точно здесь.
[55:54.580 --> 55:55.580]  Ну и значит мы знаем просто куда идти.
[55:56.580 --> 55:59.580]  Что мы спускаемся либо влево, либо вправо, если здесь недостаточная сумма.
[56:00.580 --> 56:03.580]  Ну и так мы найдем долиста, где как раз после которой происходит сечение по х.
[56:04.500 --> 56:15.500]  Проблема, что наши искомые границы точно совпадают с самой начальной границей последнего отрезка.
[56:16.500 --> 56:18.500]  То есть после доволения которого станет больше.
[56:19.500 --> 56:20.500]  Вот здесь.
[56:22.500 --> 56:23.500]  Левая граница третьего отрезка.
[56:23.500 --> 56:24.500]  Вот это.
[56:29.500 --> 56:33.500]  Ну смотрите, это тогда было бы означало, что х равно 12, значит я бы закончился вот здесь.
[56:34.500 --> 56:35.500]  Ну еще раз.
[56:37.500 --> 56:38.500]  Что значит, что граница здесь?
[56:39.500 --> 56:41.500]  Это значит, что сумма на этих двух хотя бы х.
[56:42.500 --> 56:45.500]  Нет, граница в смысле до которой включительно придется суммировать.
[56:46.500 --> 56:47.500]  То есть сумма на этих двух меньше.
[56:48.500 --> 56:49.500]  То есть надо взять первый элемент отсюда.
[56:50.500 --> 56:51.500]  Ну а в чем проблема?
[56:52.500 --> 56:55.500]  Я спускаюсь каждый раз влево дальше, ну вот у меня был такой отрезок.
[56:56.500 --> 57:00.500]  Это всему соответствовало, это как-то вот так, это как-то вот так.
[57:01.420 --> 57:04.420]  И вот этот левый элемент здесь, это второй элемент здесь.
[57:05.420 --> 57:08.420]  Ну смотрите, я в этой вершине понимаю, что влево есть смысл пойти.
[57:09.420 --> 57:11.420]  Ну и после него у меня будет как раз граница.
[57:12.420 --> 57:14.420]  То есть я спускаюсь до какого-то листа и говорю, что после него граница.
[57:17.420 --> 57:19.420]  Так же здесь, я дохожу до такого листа.
[57:20.420 --> 57:21.420]  То есть я дохожу до последнего листа.
[57:22.420 --> 57:23.420]  Сейчас.
[57:26.420 --> 57:28.420]  Да вот даже не нужна дополнительная проверка.
[57:29.340 --> 57:31.340]  Короче, я утверждаю, что мы таким образом как раз дойдем до листа
[57:32.340 --> 57:34.340]  такого, что до него границу поставить нельзя.
[57:35.340 --> 57:37.340]  То есть до него сумма меньше, чем х, а после уже больше.
[57:38.340 --> 57:39.340]  Поэтому граница всегда будет после того листа, до которого я спустился.
[57:42.340 --> 57:44.340]  Если у нас все числа неоткрытые,
[57:45.340 --> 57:48.340]  можно просто посчитать сумму на 0 до 8 и также искать?
[57:49.340 --> 57:51.340]  Тоже можно, да, это правда.
[57:52.340 --> 57:54.340]  Можно было бы посчитать сумму от 0 до или минус 1,
[57:55.260 --> 57:59.260]  и потом запуститься просто от 0 с суммой х плюс то, что вы сказали.
[58:00.260 --> 58:01.260]  Да, так тоже можно, тоже годится.
[58:02.260 --> 58:04.260]  Но опять же, в общем случае вы не можете,
[58:05.260 --> 58:07.260]  если задача более сложная, то вы не можете учесть отрезок 0 до или минус 1,
[58:08.260 --> 58:10.260]  но в этом случае можно, да, это правда.
[58:11.260 --> 58:13.260]  Ну смотрите, предложение было такое,
[58:14.260 --> 58:16.260]  что вот эту задачу можно сделать по-другому.
[58:17.260 --> 58:19.260]  Можно сначала к х прибавить вот эту вот сумму
[58:20.260 --> 58:22.260]  и сказать, что или равно 0.
[58:23.180 --> 58:25.180]  Вот, и дальше не нужно было бы развивать,
[58:26.180 --> 58:28.180]  можно было бы вот этот алгоритм просто запустить сразу.
[58:32.180 --> 58:34.180]  Так, окей.
[58:39.180 --> 58:41.180]  Так, давайте дальше, давайте следующая задача.
[58:44.180 --> 58:46.180]  Значит, это будет провод ложной операции.
[58:53.180 --> 58:55.180]  Ну что, давайте так.
[58:56.180 --> 58:58.180]  Опять у нас есть массив,
[58:59.180 --> 59:01.180]  опять есть два типа запросов,
[59:02.180 --> 59:04.180]  только теперь обновление уже будет не в точке, а на отрезке.
[59:10.180 --> 59:12.180]  Мне дают координаты отрезка L, R
[59:13.180 --> 59:15.180]  и дают число х.
[59:16.180 --> 59:18.180]  Я хочу на отрезке с L по R все числа увеличить на х.
[59:19.180 --> 59:21.180]  То есть я хочу AL-ты увеличить на х,
[59:22.100 --> 59:24.100]  а L плюс 1 увеличить на х
[59:25.100 --> 59:27.100]  и так далее вплоть до Айротова.
[59:28.100 --> 59:30.100]  Вот такая штука.
[59:31.100 --> 59:33.100]  Ну и давайте оставим сумму на отрезке.
[59:39.100 --> 59:41.100]  Вот, то есть по сравнению с первой задачей
[59:42.100 --> 59:44.100]  у меня обновление не в точке, а на отрезке.
[59:45.100 --> 59:47.100]  Не в точке, а на отрезке.
[59:52.100 --> 59:54.100]  Так, хорошо.
[59:55.100 --> 59:57.100]  Значит, как я это буду тогда делать?
[59:58.100 --> 01:00:00.100]  Смотрите, идея следующая.
[01:00:01.100 --> 01:00:03.100]  Давайте мы ведем отложенные операции
[01:00:04.100 --> 01:00:06.100]  и в каждое решение помимо суммы с подотрезком
[01:00:07.100 --> 01:00:09.100]  будем также хранить информацию вот о том самом х,
[01:00:10.100 --> 01:00:12.100]  который нужно ко всем элементам прибавить.
[01:00:13.100 --> 01:00:15.100]  То есть помимо суммы, которая у меня будет в t лежать,
[01:00:16.100 --> 01:00:18.100]  я буду хранить еще х.
[01:00:19.100 --> 01:00:21.100]  Тот самый х, который нужно прибавить ко всем элементам
[01:00:22.100 --> 01:00:24.100]  в т.е. вершина чему-то соответствует к какому-то подотрезку.
[01:00:25.100 --> 01:00:27.100]  Вот х значит, что всем этим элементам надо сделать плюс х.
[01:00:30.100 --> 01:00:32.100]  Вместо того, чтобы явным образом по ним по всем проходиться
[01:00:33.100 --> 01:00:35.100]  и каждому в отдельности присваивать плюс х,
[01:00:36.100 --> 01:00:38.100]  я просто положу сюда х и скажу, ну, потом когда-нибудь это учту.
[01:00:39.100 --> 01:00:41.100]  Если мне нужно будет, я этот х протолкну в детей.
[01:00:42.100 --> 01:00:44.100]  То есть я откладываю на будущее себе выполнение этой операции
[01:00:45.100 --> 01:00:47.100]  в каком-то смысле
[01:00:48.100 --> 01:00:50.100]  и просто сохраняю, что вот здесь, вот в этой вершинке
[01:00:51.020 --> 01:00:53.020]  надо не забыть, что все на самом деле элементы
[01:00:54.020 --> 01:00:56.020]  в этом подделе увеличиваются на х.
[01:00:57.020 --> 01:00:59.020]  Идея такая.
[01:01:00.020 --> 01:01:02.020]  Как мы ее будем реализовывать?
[01:01:03.020 --> 01:01:05.020]  Надо договориться.
[01:01:06.020 --> 01:01:08.020]  Я буду поддерживать такой вариант.
[01:01:09.020 --> 01:01:11.020]  Следующее условие будет всегда справедливо.
[01:01:12.020 --> 01:01:14.020]  Что если я дохожу от корня, то есть от вершины номер 1
[01:01:15.020 --> 01:01:17.020]  до какой-то вершины с номером v,
[01:01:18.020 --> 01:01:20.020]  спускаюсь рекурсивно сверху вниз,
[01:01:21.020 --> 01:01:23.020]  так что мне надо сделать?
[01:01:24.020 --> 01:01:26.020]  Сейчас, одну секунду, я скажу.
[01:01:27.020 --> 01:01:29.020]  В общем, я хочу сказать следующее,
[01:01:30.020 --> 01:01:32.020]  что когда я прохожу вдоль какого-то пути,
[01:01:33.020 --> 01:01:35.020]  когда я спускаюсь от первой до в этой вершины,
[01:01:36.020 --> 01:01:38.020]  я всю информацию, которая здесь была отложена,
[01:01:39.020 --> 01:01:41.020]  то есть вот в этих вершинах были какие-то отложенные х,
[01:01:42.020 --> 01:01:44.020]  я всю эту информацию проталкиваю.
[01:01:45.020 --> 01:01:47.020]  То есть я выполняю то, что я себе когда-то в прошлом
[01:01:48.020 --> 01:01:50.020]  пообещал сделать, если у меня здесь лежал какой-то х,
[01:01:51.020 --> 01:01:53.020]  давайте картинка, вот у меня была вершина,
[01:01:54.020 --> 01:01:56.020]  здесь лежал какой-то х нетривиальный,
[01:01:57.020 --> 01:01:59.020]  и мне нужно, скажем, пойти направо.
[01:02:00.020 --> 01:02:02.020]  Так вот перед этим давайте я этот х спущу и влево и вправо,
[01:02:03.020 --> 01:02:05.020]  то есть я этот х сотру, а здесь поставлю х и х.
[01:02:06.020 --> 01:02:08.020]  Тем самым я как раз информацию протолкнул в обоих сыновей.
[01:02:09.020 --> 01:02:11.020]  Ну и понятно, что я ничего не потерял,
[01:02:12.020 --> 01:02:14.020]  потому что прибавить х на всем этом под деревя,
[01:02:15.020 --> 01:02:17.020]  то же самое, что прибавить х здесь и здесь независимо,
[01:02:18.020 --> 01:02:20.020]  потому что это объединение двух деревьев.
[01:02:21.020 --> 01:02:23.020]  А прибавляем к тому х, который там уже был.
[01:02:24.020 --> 01:02:26.020]  Во-первых, во-вторых, мы увеличиваем сумму на х
[01:02:27.020 --> 01:02:29.020]  умножено размер под дерева.
[01:02:30.020 --> 01:02:32.020]  Потому что когда у меня в под дереве происходит обновление
[01:02:33.020 --> 01:02:35.020]  на плюс х, то мне нужно еще и сумму обновить.
[01:02:36.020 --> 01:02:38.020]  Если все элементы увеличились на х,
[01:02:39.020 --> 01:02:41.020]  то сумма увеличилась на х умноженное количество элементов под дереве.
[01:02:42.020 --> 01:02:44.020]  Такой вариант, что когда я иду вдоль пути,
[01:02:45.020 --> 01:02:47.020]  я вот эту отложенную информацию проталкиваю вниз.
[01:02:48.020 --> 01:02:50.020]  То есть вместо того, чтобы ее сразу в листья проставлять,
[01:02:51.020 --> 01:02:53.020]  мне нужно, если я хочу пойти вниз,
[01:02:54.020 --> 01:02:56.020]  я ее протолкну в детей.
[01:02:57.020 --> 01:02:59.020]  Давайте напишем вот эту процедуру.
[01:03:00.020 --> 01:03:02.020]  Эта процедура типа push,
[01:03:03.020 --> 01:03:05.020]  проталкивая информации из вершин в детей.
[01:03:06.020 --> 01:03:08.020]  Давайте вот так вот ее сделаем.
[01:03:09.020 --> 01:03:11.020]  Как протолкнуть информацию,
[01:03:12.020 --> 01:03:14.020]  находящуюся в вершине В?
[01:03:17.020 --> 01:03:19.020]  Давайте просто сделаем так.
[01:03:19.940 --> 01:03:21.940]  Если здесь был какой-то х,
[01:03:22.940 --> 01:03:24.940]  значит, что все нужно здесь увеличить на х.
[01:03:25.940 --> 01:03:27.940]  То есть я х с номером 2v увеличиваю на х от v.
[01:03:28.940 --> 01:03:30.940]  Х с номером 2v плюс 1,
[01:03:31.940 --> 01:03:33.940]  то есть для правого сына тоже увеличиваю на х от v.
[01:03:34.940 --> 01:03:36.940]  То есть я этот х передал в детей.
[01:03:37.940 --> 01:03:39.940]  И дальше мне нужно еще сумму в них обновить,
[01:03:40.940 --> 01:03:42.940]  потому что пришло обновление на плюс х,
[01:03:43.940 --> 01:03:45.940]  в них соответственно нужно еще сумму обновить,
[01:03:46.940 --> 01:03:48.940]  потому что все вот эти элементы увеличились на х.
[01:03:49.940 --> 01:03:51.940]  Вот здесь хранилась правильная сумма.
[01:03:52.940 --> 01:03:54.940]  Но давайте это сделаем.
[01:03:55.940 --> 01:03:57.940]  Давайте еще раз посчитаем границу разделения детей.
[01:04:00.940 --> 01:04:02.940]  Ну и мне нужно в этой вершине сумму увеличить
[01:04:03.940 --> 01:04:05.940]  на х умноженное количество детей.
[01:04:06.940 --> 01:04:08.940]  И здесь х умноженное количество детей.
[01:04:09.940 --> 01:04:11.940]  Это пишется так.
[01:04:12.940 --> 01:04:14.940]  t от левого сына плюс равно x умножить на сколько детей слева,
[01:04:15.940 --> 01:04:17.940]  ну точнее сколько элементов слева.
[01:04:18.860 --> 01:04:20.860]  И в конце еще сделаю х от левого сына плюс 1.
[01:04:23.860 --> 01:04:25.860]  Ну и аналогично для правого сына t от 2v плюс 1
[01:04:26.860 --> 01:04:28.860]  плюс равно х от v
[01:04:32.860 --> 01:04:34.860]  умножить на размер правого под дерево.
[01:04:35.860 --> 01:04:37.860]  То есть tr минус tm.
[01:04:42.860 --> 01:04:44.860]  И в конце еще сделаю х от v равно 0.
[01:04:45.860 --> 01:04:47.860]  Чтобы...
[01:04:48.860 --> 01:04:50.860]  Да, да.
[01:04:51.860 --> 01:04:53.860]  Да, да, да.
[01:04:54.860 --> 01:04:56.860]  В этом смысле, что если я дошел до вершины,
[01:04:57.860 --> 01:04:59.860]  то в ней уже правильная информация.
[01:05:00.860 --> 01:05:02.860]  Если я от корня дошел до кудота, то в этом кудота уже правильная информация.
[01:05:03.860 --> 01:05:05.860]  Вот.
[01:05:06.860 --> 01:05:08.860]  Значит еще раз, что делает push?
[01:05:09.860 --> 01:05:11.860]  Смотрите, у меня была здесь отложенная операция.
[01:05:12.860 --> 01:05:14.860]  Тут было написано, что все элементы в под дереве надо увеличить на х.
[01:05:15.860 --> 01:05:17.860]  Окей, и я хочу при этом там пойти куда-то влево или вправо.
[01:05:18.860 --> 01:05:20.860]  УFO, просто вот эту информацию передам в детей.
[01:05:21.860 --> 01:05:23.860]  Потому, что понятно, что если все вот здесь вот элементы увеличится на х,
[01:05:24.860 --> 01:05:26.860]  это то же самое, что если просто этот х передать сюда и сюда,
[01:05:27.860 --> 01:05:29.860]  и все элементы здесь увеличится на х, и здесь увеличится на х.
[01:05:30.860 --> 01:05:32.860]  Но это одно и то же просто.
[01:05:33.860 --> 01:05:35.860]  Увеличить на х все под дерево, или сначала левая, а потом правая.
[01:05:36.860 --> 01:05:38.860]  Так вот, давайте я этот х теперь протолкну в детей.
[01:05:39.860 --> 01:05:41.860]  Для этого я увеличиваю х-ы слева и справа на тот самый х от v.
[01:05:42.860 --> 01:05:44.860]  То есть я передаю информацию об этой отложенной операции в детей.
[01:05:45.860 --> 01:05:47.860]  И также мне нужно обновить суммы в них,
[01:05:47.940 --> 01:05:52.940]  что в них пришла новая информация, они узнали, что теперь все их элементы в поддереве увеличились на x,
[01:05:52.940 --> 01:05:59.140]  значит мне нужно у них суммы обновить. Сумма увеличивается на значение x, умноженное количество
[01:05:59.140 --> 01:06:06.940]  элементов в поддереве. То есть вот здесь вот это будет количество элементов с tl по tm, их вот столько, tm-tl+.
[01:06:06.940 --> 01:06:17.140]  Здесь это все элементы с tm+, tr, их вот столько, tr-tm. Я протолкну информацию в детей, они поняли,
[01:06:17.140 --> 01:06:23.220]  что пришло новое обновление, плюс x. Правильным образом пересчитали свои суммы. Ну и теперь этот x я
[01:06:23.220 --> 01:06:30.260]  могу смело забыть, потому что эту информацию я уже передал. Ее не нужно будет еще раз потом в
[01:06:30.260 --> 01:06:36.100]  будущем учитывать, потому что она и так уже передана в детей. Да, если я здесь оставлю x, то это как
[01:06:36.100 --> 01:06:40.100]  будто бы значит, что я сначала здесь делаю плюс x, потом здесь, потом во всем еще делаю плюс x. Это
[01:06:40.100 --> 01:06:44.900]  неправильно. Мне нужно только здесь и здесь. Если я передал в детей, то здесь нужно занулить. Вот здесь
[01:06:44.900 --> 01:06:56.500]  вот уже не нужно прибавлять плюс x, потому что уже передано все. Еще раз? А так у меня просто есть
[01:06:56.500 --> 01:07:03.620]  перемены x в каждой вершине. Если она нулевая, то делать ничего не нужно. Ну то есть как бы можно
[01:07:03.620 --> 01:07:10.100]  это сделать, но ничего не произойдет. Вот, поэтому я даже не писал никакого wi-fi отдельного. Ну вот и
[01:07:10.100 --> 01:07:15.820]  все. Дальше, чтобы обрабатывать все запросы, я буду действовать так же, как всегда. То есть идти
[01:07:15.820 --> 01:07:21.380]  вниз и там как-то жадно, наивным образом идти в обе стороны, если есть смысл. Только перед этим,
[01:07:21.380 --> 01:07:27.180]  перед тем как спускаться в детей, я сначала запущу push. То есть я передам отложенную информацию
[01:07:27.180 --> 01:07:31.860]  вершине в ее детей. Тем самым я как раз все, что когда-то в прошлом себе пообещал сделать,
[01:07:31.860 --> 01:07:37.180]  выполню в этот момент. То есть, точнее, передам опять-таки, передам это поручение детям. Скажу,
[01:07:37.180 --> 01:07:41.580]  что ты, пожалуйста, всех увеличь на x, и ты, пожалуйста, увеличь на x. И если это дойдут до тебя,
[01:07:41.580 --> 01:07:45.780]  то ты уже потом опять-таки сам будешь это все протоковывать в детей. Вот в момент, когда я
[01:07:45.780 --> 01:07:50.620]  иду из вершины v куда-то, я только вершину v избавляю от ответственности. Я говорю,
[01:07:50.620 --> 01:07:54.860]  что вот она сейчас передает, и дальше дети, если надо, опять эту информацию правильно передадут.
[01:07:54.860 --> 01:08:03.220]  Ну вот как-то так. А в остальном здесь все, здесь обновления и запрос суммы такие же,
[01:08:03.220 --> 01:08:08.660]  как были раньше. Например, как работает GetSum и Ler. Ну мы просто идем сверху вниз,
[01:08:08.660 --> 01:08:14.220]  видим вершину, проталкиваем ее с помощью push. И опять-таки идем влево и вправо, если нужно.
[01:08:14.220 --> 01:08:19.220]  За счет нашего инварианта, за счет того, что всегда, если я попал в вершину из корня,
[01:08:19.220 --> 01:08:24.340]  то в ней правильная информация хранится. Я всегда, когда иду сверху вниз, я информацию проталкиваю,
[01:08:24.340 --> 01:08:28.140]  то есть в вершине всегда правильная информация. Если я до нее дошел из корня, то в ней правильный
[01:08:28.140 --> 01:08:33.700]  ответ. Ну и тогда, если я просто в GetSum напишу то же, что и раньше, то просто всегда, когда дохожу
[01:08:33.700 --> 01:08:45.820]  до вершины, там уже правильный ответ, его можно прибавить к ответу просто. Да. Ну да, да. Работает
[01:08:45.820 --> 01:08:49.500]  так же, как и GetSum, он спускается снизу вверх. Когда дошел до вершины, где нужно делать плюс х,
[01:08:49.500 --> 01:08:55.900]  он просто в ней делает плюс х вот здесь вот. И сумму тоже правильно увеличивает. Ну t увеличивает
[01:08:55.980 --> 01:09:11.320]  на х на размер. Вот. Да, да. Да, да, в ТВ всегда, если мы, как бы если мы от корня дошли до в,
[01:09:11.320 --> 01:09:16.300]  то в ТВ правильная сумма, а х — это то, что нужно еще передать детей. То есть дети еще не знают об
[01:09:16.300 --> 01:09:21.900]  Но когда надо, они об этом узнают, когда я сделаю push от v, они эту информацию получат.
[01:09:21.900 --> 01:09:36.220]  Такое бывает часто нужно, когда у меня запросы, когда все запросы на отрезках,
[01:09:36.220 --> 01:09:41.140]  то есть как мы видим, здесь у меня сумма на отрезке интересует, и здесь мне нужно обновлять тоже
[01:09:41.140 --> 01:09:45.860]  плюс равно на отрезке, увеличивать на отрезке. Если первая задача у нас была плюс в точке и
[01:09:45.860 --> 01:09:49.300]  сумма на отрезке, то здесь и то и то на отрезке, скорее всего, нужны отложенные операции.
[01:09:49.300 --> 01:09:54.220]  Если вы видите, что у вас оба типа запросов про отрезки, то скорее всего нужны отложенные операции.
[01:09:54.220 --> 01:10:01.620]  Так, хорошо, значит, ну тогда последний сюжет остался.
[01:10:01.620 --> 01:10:09.140]  Да, да, да, здесь всегда логарифмы пока что будут, да.
[01:10:09.140 --> 01:10:16.900]  Так, ну хорошо, давайте последний сюжет.
[01:10:16.900 --> 01:10:24.980]  Опять-таки есть массив.
[01:10:24.980 --> 01:10:31.980]  Давайте к нему поступает следующий запрос.
[01:10:31.980 --> 01:10:34.820]  Просто один тип запросов без изменений.
[01:10:34.820 --> 01:10:43.420]  Запрос такой, lrx, значит, это нужно сообщить, сколько элементов с l по r больше или равной чем x.
[01:10:43.420 --> 01:10:57.140]  Значит, сколько элементов из a l, a l плюс 1 и так далее, a r, больше или равной x.
[01:10:57.140 --> 01:11:01.780]  Сейчас, а или меньше я хочу сделать.
[01:11:01.780 --> 01:11:06.900]  Давайте меньше это равно, мне будет удобнее так, это неважно.
[01:11:06.900 --> 01:11:16.820]  Вот, то есть массив у меня не изменяется, запросов изменений нет, есть только запросы
[01:11:16.820 --> 01:11:21.460]  нахождения какого-то количества. Сколько элементов на отрезке не превосходит какой-то границе, не
[01:11:21.460 --> 01:11:29.060]  превосходит x. Так, может есть какие-то мысли сразу как делать?
[01:11:29.060 --> 01:11:39.100]  Ну нет, а x может быть разным, он может от запроса к запросу меняться.
[01:11:39.100 --> 01:11:44.420]  Ну, просто максимум вроде не хватит.
[01:11:44.420 --> 01:11:48.660]  Во, да, ровно так мы и сделаем.
[01:11:49.140 --> 01:11:54.700]  Значит, смотрите, вы в правильную сторону думаете, что можно в вершине хранить не только сумму.
[01:11:54.700 --> 01:11:59.860]  До этого момента у нас в вершине была всегда только сумма, понятно, что можно хранить всякие разные другие вещи.
[01:11:59.860 --> 01:12:06.900]  Давайте мы в вершине будем хранить в отсортированном виде все контролируемые значения.
[01:12:06.900 --> 01:12:13.460]  То есть, скажем, если у меня вершина v отвечает какому-то отрезку массива с tl по tr,
[01:12:13.700 --> 01:12:18.220]  давайте вот здесь будет храниться отсортированный список всех вот этих чисел.
[01:12:18.220 --> 01:12:35.820]  В вершине хранится, так и напишем, в вершине v хранится отсортированный список контролируемых значений.
[01:12:44.420 --> 01:12:48.020]  А вот не страшно на самом деле по памяти будет.
[01:12:48.020 --> 01:12:53.060]  То есть, да, вот в вершине v все вот эти вот числа, все листья, которые в этом поддереве лежат,
[01:12:53.060 --> 01:12:58.420]  я их все сюда складываю и сортирую, и это будет вот то, что хранится в вершине v.
[01:12:58.420 --> 01:13:11.700]  Значит, я утверждаю, что это по памяти всего будет n лог n суммарно, по всем вершинам это будет всего n лог n памяти.
[01:13:11.700 --> 01:13:15.940]  Ну почему? Потому что просто каждый элемент участвует в логарифмическом числе вершин.
[01:13:15.940 --> 01:13:20.260]  Вот если у вас есть какой-то x, то в каких вершинах он лежит?
[01:13:20.260 --> 01:13:24.660]  В себе, в родители, в дедушке, в прадедушке и так далее. Их логарифм всего.
[01:13:24.660 --> 01:13:29.220]  Значит, суммарно, каждое число лежит всего лишь в логарифмическом количестве списков,
[01:13:29.220 --> 01:13:34.740]  значит, суммарно памяти у нас n лог n. Это не очень страшно.
[01:13:37.460 --> 01:13:38.740]  Все классно?
[01:13:39.700 --> 01:13:44.340]  Дальше. За сколько это можно построить? Скажите, пожалуйста.
[01:13:47.620 --> 01:13:52.180]  Потому что каждый элемент x лежит всего лишь в логарифмическом количестве списков,
[01:13:52.180 --> 01:13:57.460]  потому что если у меня есть некий x, где он лежит, он лежит только там, в тех вершинах, которые его контролируют.
[01:13:57.460 --> 01:14:00.180]  А это путь до корня, а их логарифм.
[01:14:00.180 --> 01:14:05.780]  Поэтому каждое число лежит в логарифмическом количестве списков, значит, суммарный размер всех списков это n лог n.
[01:14:05.860 --> 01:14:08.660]  У меня n элементов в каждом логарифме списка, всего n лог n.
[01:14:12.660 --> 01:14:13.620]  Как?
[01:14:15.620 --> 01:14:16.420]  Да.
[01:14:17.780 --> 01:14:19.220]  Да, да, да.
[01:14:19.220 --> 01:14:23.540]  Значит, более того, это не только n лог n память, но еще и можно построить за n лог n времени.
[01:14:23.540 --> 01:14:36.260]  Потому что, как правильно сказали, что если у нас есть список для левого сына и для правого сына,
[01:14:36.260 --> 01:14:41.620]  то для родителя можно эти списки за линейное время смёрживать,
[01:14:41.620 --> 01:14:44.580]  потому что у нас здесь отсортированный список и здесь отсортированный список.
[01:14:44.580 --> 01:14:50.100]  Мы их можем за линейное время склеить и ответ положить сюда, то есть merge, как у нас было в merge-сорте.
[01:14:50.660 --> 01:14:55.860]  То же самое, по факту, я просто два списка отсортированных склею в один отсортированный и кладу его вот сюда.
[01:14:55.860 --> 01:14:57.860]  Это делается за линейное время от размеров списков.
[01:14:57.860 --> 01:14:59.860]  Поэтому сколько памяти столько времени.
[01:15:01.860 --> 01:15:05.860]  По факту я напишу так, что на самом деле то, что мы сделали, это в каком-то смысле дерево merge-сорт.
[01:15:05.860 --> 01:15:07.860]  Дерево-рекурс и merge-сорт.
[01:15:08.620 --> 01:15:23.620]  Потому что в корне у меня будет весь отсортированный массив, в левом сыне корня будет левая часть массива отсортированная, в правом правая.
[01:15:23.620 --> 01:15:29.620]  Ну и так дальше, если вы отвечаете какому-то куску массива, то слева его левая отсортированная версия, справа правая.
[01:15:29.620 --> 01:15:31.620]  Но это в точности merge-сорт, он ровно так работает.
[01:15:31.620 --> 01:15:37.620]  Весь массив бьёт на две части, сортирует лево, сортирует правую и потом их за линейное время склеивает.
[01:15:38.380 --> 01:15:40.380]  То же самое мы и сделали здесь.
[01:15:41.380 --> 01:15:43.380]  Поэтому время построения тоже N log N.
[01:15:43.380 --> 01:15:45.380]  Ну а теперь ответ на запрос остался.
[01:15:49.380 --> 01:15:53.380]  Я утверждаю, что здесь в худшем случае ответ на запрос будет log2.
[01:15:58.380 --> 01:16:00.380]  Потому что опять можно как себе это представить.
[01:16:00.380 --> 01:16:02.380]  Смотрите, нам пришёл отрезок LR.
[01:16:02.380 --> 01:16:05.380]  Мы сначала его покрыли логарифмическим числом вершин WDO.
[01:16:06.140 --> 01:16:09.140]  Мы помним, что каждый отрезок разбивается на логарифмическом количестве вершинок.
[01:16:09.140 --> 01:16:14.140]  И дальше в каждой вершине мы можем с помощью bin поиска найти количество элементов не больше, чем x.
[01:16:16.140 --> 01:16:18.140]  Поэтому log2.
[01:16:18.140 --> 01:16:20.140]  Сейчас картинка будет.
[01:16:23.140 --> 01:16:25.140]  А ещё раз, вот здесь у меня отрезок LR.
[01:16:27.140 --> 01:16:31.140]  Мы знаем, что если запустить наш обычный обход, который идёт туда, куда имеет смысл,
[01:16:31.140 --> 01:16:34.140]  он разобьёт весь наш массив на какие-то подотрезки.
[01:16:36.140 --> 01:16:39.140]  Такие, что каждый подотрезок – это на самом деле просто вершины в дереве отрезков.
[01:16:42.140 --> 01:16:44.140]  Их будет логарифмическое количество.
[01:16:49.140 --> 01:16:55.140]  И дальше в каждом из них, в каждой вершине, у нас на самом деле хранится отсортированная версия вот этого куска массива.
[01:16:55.140 --> 01:16:59.140]  То есть у меня есть посорченный этот список, посорченный этот, этот и этот.
[01:16:59.140 --> 01:17:04.140]  Значит, в каждом из них, если я просто запущу bin поиск, я узнаю, сколько элементов не больше, чем x.
[01:17:04.900 --> 01:17:07.900]  Значит, здесь bin поиск, здесь bin поиск, здесь bin поиск и здесь bin поиск.
[01:17:07.900 --> 01:17:10.900]  В каждом из них я узнаю, сколько элементов не больше, чем x.
[01:17:10.900 --> 01:17:12.900]  Всё, складываю, получаю ответ.
[01:17:12.900 --> 01:17:18.900]  Значит, по бинарному поиску в каждой вершине.
[01:17:22.900 --> 01:17:24.900]  Значит, получается как раз log2.
[01:17:26.900 --> 01:17:30.900]  Да, потому что логарифм – вершина, и в каждой ещё bin поиск, который ещё за логарифм работает.
[01:17:34.900 --> 01:17:35.900]  Согласны?
[01:17:36.900 --> 01:17:37.900]  Ну, отлично.
[01:17:43.900 --> 01:17:46.900]  Не-не, у нас как раз, мы храним отсортированные версии.
[01:17:46.900 --> 01:17:50.900]  У нас в каждой вершине хранится отсортированная версия вот этого отрезка.
[01:17:51.900 --> 01:17:54.900]  Мы так делаем. Вы же сами говорите, что мы делаем мерч с детей.
[01:17:54.900 --> 01:17:58.900]  То есть у меня в каждой вершине хранится массив, равный вот этому после сортировки.
[01:18:00.900 --> 01:18:02.900]  То есть у меня есть вот это после сортировки.
[01:18:03.660 --> 01:18:07.660]  То есть вот здесь хранится массив чисел, равный вот этому после сортировки.
[01:18:11.660 --> 01:18:16.660]  Да, то есть мы ниже этих машин не идём, и в каждом из них…
[01:18:16.660 --> 01:18:18.660]  То есть у меня здесь какой-то список чисел,
[01:18:18.660 --> 01:18:20.660]  который равен вот этому после сортировки.
[01:18:20.660 --> 01:18:22.660]  Здесь bin поиск, то есть ниже я не спускаюсь.
[01:18:22.660 --> 01:18:24.660]  Здесь bin поиск, и здесь, и здесь.
[01:18:24.660 --> 01:18:26.660]  Ниже я не спускаюсь.
[01:18:27.420 --> 01:18:31.420]  Так, ну давайте за 5 минут ещё одну идею скажу.
[01:18:31.420 --> 01:18:35.420]  Как можно здесь скостить лог квадрата до логарифма?
[01:18:36.420 --> 01:18:38.420]  Давайте на примере это сделаем.
[01:18:43.420 --> 01:18:45.420]  На примере это сделаем.
[01:18:47.420 --> 01:18:49.420]  На примере это сделаем.
[01:18:51.420 --> 01:18:53.420]  На примере это сделаем.
[01:18:54.180 --> 01:18:56.180]  Это тоже называется fractional cascading.
[01:19:01.180 --> 01:19:03.180]  Это следующая идея, смотрите.
[01:19:04.180 --> 01:19:07.180]  Вот здесь вот мы действуем в каком-то смысле неоптимально.
[01:19:07.180 --> 01:19:10.180]  Мы в каждом месте запускаем бинарный поиск.
[01:19:11.180 --> 01:19:13.180]  Давайте мы вместо этого сделаем следующее.
[01:19:13.180 --> 01:19:15.180]  Мы будем хранить доп информацию.
[01:19:15.180 --> 01:19:18.180]  Значит, а именно, давайте на примере каком-нибудь.
[01:19:18.940 --> 01:19:20.940]  Представьте, что у меня были два массива,
[01:19:20.940 --> 01:19:22.940]  которые я склеивал с помощью мерча в один большой.
[01:19:22.940 --> 01:19:26.940]  1, 2, 3, 4, 5, 6, 7, 8.
[01:19:27.940 --> 01:19:29.940]  Давайте мы для каждого числа,
[01:19:29.940 --> 01:19:31.940]  в каждом векторе, который мы вот строили,
[01:19:31.940 --> 01:19:33.940]  то есть у меня в каждой вышине хранится список чисел,
[01:19:33.940 --> 01:19:35.940]  давайте вектор я его назову.
[01:19:35.940 --> 01:19:37.940]  Для каждого вектора,
[01:19:37.940 --> 01:19:39.940]  давайте я буду хранить в обоих списках,
[01:19:39.940 --> 01:19:41.940]  то есть в обоих сыновьях,
[01:19:41.940 --> 01:19:43.940]  в каждом векторе,
[01:19:43.940 --> 01:19:45.940]  в каждом векторе,
[01:19:45.940 --> 01:19:47.940]  то есть в обоих списках,
[01:19:47.940 --> 01:19:49.940]  то есть в обоих сыновьях,
[01:19:49.940 --> 01:19:51.940]  наибольший элемент, меньше либо равный, соответствующий ему.
[01:19:51.940 --> 01:19:53.940]  То есть вот у меня есть большой список,
[01:19:53.940 --> 01:19:55.940]  1, 2 и так далее 8.
[01:19:55.940 --> 01:19:57.940]  Давайте для каждого числа будем хранить стрелочку,
[01:19:57.940 --> 01:19:59.940]  точнее две стрелочки,
[01:19:59.940 --> 01:20:01.940]  в левого и в правого сына,
[01:20:01.940 --> 01:20:03.940]  на наибольшего, меньше либо равного,
[01:20:03.940 --> 01:20:05.940]  чем мы.
[01:20:05.940 --> 01:20:07.940]  То есть 1 будет ссылаться здесь,
[01:20:07.940 --> 01:20:09.940]  сюда и сюда,
[01:20:09.940 --> 01:20:11.940]  потому что здесь нет ни одного меньше либо равного единицы,
[01:20:11.940 --> 01:20:13.940]  мы будем указывать сюда.
[01:20:13.940 --> 01:20:15.940]  2 указывает на единицу и на 2.
[01:20:15.940 --> 01:20:19.940]  3 на 3 и опять-таки на 2.
[01:20:19.940 --> 01:20:21.940]  Ну и так далее.
[01:20:21.940 --> 01:20:23.940]  То есть вот если я для каждого элемента храню две стрелочки,
[01:20:23.940 --> 01:20:25.940]  на самый большой, меньше либо равный,
[01:20:25.940 --> 01:20:27.940]  слева и справа,
[01:20:27.940 --> 01:20:29.940]  как вот здесь, давайте продолжим.
[01:20:29.940 --> 01:20:31.940]  4 ссылается на 4 и опять на 2.
[01:20:31.940 --> 01:20:33.940]  5 на 4 и на 5.
[01:20:33.940 --> 01:20:35.940]  Ну и так далее.
[01:20:35.940 --> 01:20:37.940]  То есть еще раз, х ссылается на наибольший,
[01:20:37.940 --> 01:20:39.940]  меньше либо равный х.
[01:20:39.940 --> 01:20:41.940]  В обоих сыновьях,
[01:20:41.940 --> 01:20:43.940]  здесь и здесь.
[01:20:43.940 --> 01:20:45.940]  Наибольший, меньше либо равный х.
[01:20:47.940 --> 01:20:49.940]  Это легко сделать в то же время,
[01:20:49.940 --> 01:20:51.940]  что вы делаете мердж.
[01:20:51.940 --> 01:20:53.940]  Потому что что такое мердж?
[01:20:53.940 --> 01:20:55.940]  Он у вас имеет два ассоциированных списка,
[01:20:55.940 --> 01:20:57.940]  хранит по указателю здесь и здесь,
[01:20:57.940 --> 01:20:59.940]  выбирает каждый момент меньшее из чисел,
[01:20:59.940 --> 01:21:01.940]  записывает его сюда,
[01:21:01.940 --> 01:21:03.940]  и сдвигает указатель туда.
[01:21:03.940 --> 01:21:05.940]  И вот в тот момент, когда вы одно число переносите в большой список,
[01:21:05.940 --> 01:21:07.940]  вы как раз эти стрелки можете спокойно поставить.
[01:21:07.940 --> 01:21:09.940]  Одна стрелка это тот самый элемент, который у вас только что пришел,
[01:21:09.940 --> 01:21:11.940]  ну а другая это стрелка на предыдущий элемент,
[01:21:11.940 --> 01:21:13.940]  потому что здесь содержится что-то большее,
[01:21:13.940 --> 01:21:15.940]  вам нужно предыдущее.
[01:21:15.940 --> 01:21:17.940]  То есть просто когда вы их склеиваете,
[01:21:17.940 --> 01:21:19.940]  вы эти стрелки автоматически узнаете.
[01:21:19.940 --> 01:21:21.940]  Вы знаете, скажем, вот здесь было 4 и 5,
[01:21:21.940 --> 01:21:23.940]  вы перенесли сюда 4, значит четверка сама себя меньше либо равна,
[01:21:23.940 --> 01:21:25.940]  а здесь, ну пятерка уже больше,
[01:21:25.940 --> 01:21:27.940]  поэтому стрелка нужна на предыдущий элемент.
[01:21:33.940 --> 01:21:35.940]  Ну зафайте.
[01:21:35.940 --> 01:21:37.940]  Вот.
[01:21:37.940 --> 01:21:39.940]  Понятная идея?
[01:21:39.940 --> 01:21:41.940]  Мы вот храним такие стрелочки.
[01:21:41.940 --> 01:21:43.940]  Значит в каждом векторе у меня будут стрелочки влево и вправо,
[01:21:43.940 --> 01:21:45.940]  влево и вправо сына для каждого элемента.
[01:21:45.940 --> 01:21:47.940]  И тогда,
[01:21:47.940 --> 01:21:49.940]  вместо того, чтобы упускать бинпоиски
[01:21:49.940 --> 01:21:51.940]  независимо в каждом из детей,
[01:21:51.940 --> 01:21:53.940]  я мог в то же время,
[01:21:53.940 --> 01:21:55.940]  когда я шел от корня до них, до всех,
[01:21:55.940 --> 01:21:57.940]  поддерживать, то есть я мог на самом деле
[01:21:57.940 --> 01:21:59.940]  один раз запустить вот здесь вот, я могу найти
[01:21:59.940 --> 01:22:01.940]  элемент меньше равный х,
[01:22:01.940 --> 01:22:03.940]  самый большой элемент меньше равный х,
[01:22:03.940 --> 01:22:05.940]  и дальше просто по стрелочкам идти.
[01:22:05.940 --> 01:22:07.940]  То есть дальше я всегда, когда спускаюсь в сына,
[01:22:07.940 --> 01:22:09.940]  я знаю,
[01:22:09.940 --> 01:22:11.940]  наибольший элемент меньше равный х.
[01:22:11.940 --> 01:22:13.940]  Здесь пятерка перенесла в четверку, здесь в пятерку.
[01:22:13.940 --> 01:22:15.940]  Потом опять перехожу в сына,
[01:22:15.940 --> 01:22:17.940]  я знаю,
[01:22:17.940 --> 01:22:19.940]  какой элемент наибольший меньше равный х.
[01:22:19.940 --> 01:22:21.940]  И вот во время, пока я спускаюсь
[01:22:21.940 --> 01:22:23.940]  от корня до всех этих вершин,
[01:22:23.940 --> 01:22:25.940]  из которых регура себя ниже не идет,
[01:22:25.940 --> 01:22:27.940]  я могу поддерживать сразу же указательно
[01:22:27.940 --> 01:22:29.940]  наибольшее число меньше равный х.
[01:22:29.940 --> 01:22:31.940]  И дальше стрелка мне говорит, куда идти.
[01:22:31.940 --> 01:22:33.940]  Если идешь влево, иди сюда,
[01:22:33.940 --> 01:22:35.940]  если направо, иди сюда.
[01:22:35.940 --> 01:22:37.940]  И тогда мне даже не нужно будет пускать бинпоиск
[01:22:37.940 --> 01:22:39.940]  в каждой из этих вершин. У меня уже
[01:22:39.940 --> 01:22:41.940]  сразу будет храниться указатель, то есть я
[01:22:41.940 --> 01:22:43.940]  буду поддерживать указатель на то место,
[01:22:43.940 --> 01:22:45.940]  на тот элемент, который наибольший меньше
[01:22:45.940 --> 01:22:47.940]  равный при этом х.
[01:22:47.940 --> 01:22:49.940]  Значит мне нужно всего лишь
[01:22:49.940 --> 01:22:51.940]  один раз запустить бинпоиск в корня,
[01:22:51.940 --> 01:22:53.940]  бинпоиск в корня,
[01:22:55.940 --> 01:22:57.940]  а потом вниз идти по этим
[01:22:57.940 --> 01:22:59.940]  стрелочкам, которые у меня все
[01:22:59.940 --> 01:23:01.940]  хранены.
[01:23:01.940 --> 01:23:03.940]  На наибольшее число, не больше х.
[01:23:05.940 --> 01:23:07.940]  Все, спасибо.
