[00:00.000 --> 00:11.240]  Ну, мы, напоминаю, да, мы снова живем в мире, в котором у нас основная цель решить задачу вида дан текст,
[00:11.240 --> 00:18.000]  и нам даются какие-то подстроки П, и надо для каждой П в онлайне желательно за быстро,
[00:18.000 --> 00:26.400]  за П или чуть-чуть помедленнее пытаться отвечать на всякие вопросы. Всякие вопросы будут в духе,
[00:26.400 --> 00:35.040]  входит ли это подстрока в текст, так как подстрока да или нет. Один из вариантов возникает, конечно же,
[00:35.040 --> 00:45.520]  суффиксной массив. Что же это такое? Ну, и здесь определить его очень просто. Это, пожалуй,
[00:45.520 --> 00:53.480]  самая простая такая структура, на самом деле. Вот, допустим, строим, как говорится, по классике,
[00:53.480 --> 01:03.000]  для строки АБОЦАБО. Значит, у нее, ну, какие суффиксы у нее есть? Ну, помимо пустого суффикса,
[01:03.000 --> 01:11.200]  у нее есть, значит, суффиксы, соответственно, там суффикс номер 6А, суффикс номер 5ВА,
[01:11.200 --> 01:21.960]  суффикс номер 4АБА, суффикс номер 3ЦАБА, суффикс номер 2АЦАБА, суффикс номер 1БЦАБА,
[01:21.960 --> 01:36.000]  и суффикс номер 1АЦАБА. Заведем, что эти суффиксы мы, в принципе, можем и отсортировать
[01:36.000 --> 01:46.320]  и психографически. Вот, давайте их отсортируем. Вот, при этом даже, ну, как мы их нарисуем? А давайте
[01:46.320 --> 01:56.120]  так нарисуем. Вот, если мы их отсортируем, что будет? Будет А, будет АБО. Вот, дальше что у нас там будет? АБЦАБА,
[01:56.120 --> 02:06.360]  соответственно. Так, что там дальше? АЦАБА, соответственно. Так, еще будет... Ну, дальше, вот,
[02:06.360 --> 02:13.120]  наконец, начались строчечки с буквы Б, ну, и быстро заканчиваются их тут всего две. Ну,
[02:13.120 --> 02:22.120]  а строчечек начинающих с буквы С вообще одна. Вот. Ну, и самое теперь приятное, что можно сделать,
[02:22.120 --> 02:29.440]  это не выписывать сами суффиксы, а оставить только циферки. Получился такой массив,
[02:29.440 --> 02:39.520]  такой перестановка чисел от 0 до N-1. Да, в этом мире, как вы уже поняли, мы живем в 0 аддексации.
[02:39.520 --> 02:51.920]  Вот. Ну, и получается вот такая перестановка чисел от 0 на длинной строке минус 1. И это и есть суффиксный массив.
[02:51.920 --> 02:59.520]  Суффиксный массив.
[02:59.520 --> 03:21.120]  Опа. Собственно, да. Запомните, вот здесь не сложно. 640, 25, 13, звоните. Вот. Значит, ну, вот. Чем он
[03:21.120 --> 03:32.800]  нам может помочь? Ну, на самом деле, да, помочь он может вот чем. Ну, опять, уже, как минимум,
[03:32.800 --> 03:38.520]  если вы этот суффиксный массив уже построили, то на самом деле, если вам приходит какая-нибудь строка
[03:38.520 --> 03:47.160]  фет, и вы ее где-нибудь ищете, то, ну, по крайней мере, то вы пытаетесь найти там, есть ли у нее вхождение,
[03:47.160 --> 04:01.560]  то, ну, как минимум, за время O от, допустим, P на, соответственно, log s, в принципе, ее вхождение
[04:01.560 --> 04:07.560]  или их отсутствие найти вполне себе можно банальным, без поиска по ответу. Правда? Ну, даже если у вас
[04:07.560 --> 04:11.040]  есть только сам массив, потому что, ну, понятно, что с самими суффиксами, если у вас есть сама строка,
[04:11.200 --> 04:21.520]  то для не самых больших текстов, в общем-то, этого уже хватит. На самом деле, особенно если учесть,
[04:21.520 --> 04:32.760]  что вам реально O от P, на самом деле, не в сильном многих случаях будет происходить. Ну, вот. Ну,
[04:32.760 --> 04:37.960]  на самом деле, конечно, если использовать какие-нибудь, может быть, какие-то более
[04:37.960 --> 04:45.560]  продвинутые штуки, то, может быть, у нас, вот, мы посмотрим, получится и что-то побыстрее. Что-то
[04:45.560 --> 04:58.520]  побыстрее. Вот. Что же это за более быстрые штуки? Да, пожалуй, знаете, мы пойдем немножко неожиданным
[04:58.520 --> 05:02.800]  таким путем. Мы сначала попробуем что-то с суффиксным массивом сделать, а потом в конце
[05:02.800 --> 05:08.680]  мы его попробуем построить. Ну, тем более, что алгоритм, который мы будем использовать,
[05:08.680 --> 05:16.640]  он там относительно черный ящиковый. Вот. Вот, допустим, у нас есть черный ящик, который там
[05:16.640 --> 05:27.520]  с небес по факсу присылает нам суффиксные массивы. Что с ним можно еще делать? Вот. Ну,
[05:27.560 --> 05:35.200]  еще с ним можно делать следующее. Вот у него есть такой красивый нападник. Будем его даже похожим
[05:35.200 --> 05:46.960]  делать. Значит, ну, и здесь мы ведем такое определение. Да ладно. А, ну ладно, если уж нападник,
[05:46.960 --> 05:58.240]  то нападник. Ну, нападник у синего цвета, наверное, логично. Так. Так. Вот. Определение.
[05:58.240 --> 06:05.840]  Допустим, пусть, вот я сейчас абстрактно напишу, x и y это произвольные строки.
[06:05.840 --> 06:26.760]  Тогда ведем такое понятие, как Lcp от x и y. Это будет равно максимуму такого l,
[06:26.760 --> 06:43.680]  что x от 0 до l-1 равен y от 0 до l-1. Упражнение на знание английского языка. Как расшифровывается
[06:43.680 --> 07:07.960]  аббивиатура Lcp. Да. Ну, или логист. Вот. Логист. Вот. То есть, видимо, да, такое понятие мы
[07:07.960 --> 07:20.280]  видели для произвольных двух строк. Вот. Ну, а теперь можно. Мы ведем теперь мистический массивчик
[07:20.280 --> 07:37.880]  Lcp. Будем говорить, что пусть у нас это s строка, s равно, естественно, s от 0 до l-1, допустим,
[07:37.880 --> 08:00.720]  и что-то еще. Вот. А, ну вот. Ну, допустим, а. Допустим, sa. Ее суффиксный массив.
[08:07.880 --> 08:31.360]  Тогда мы введем такое мистическое понятие, как. Тогда, значит, мы введем такой массив Lcp от 0 до l-2.
[08:31.360 --> 08:58.160]  А. Это массив чисел. Такой, что. Lcp и t. Вот. Это будет равно Lcp двух суффиксов. Каких? Ну, соответственно,
[08:58.160 --> 09:16.640]  стоящих в и-той позиции и в и-плюспе. Вот. Формальное определение может выглядеть так.
[09:16.640 --> 09:38.600]  Вот. Это называется массив Lcp. Вот. Вот такой массив там. Ну, теперь нулевой элемент. Чему равен? Ну,
[09:38.600 --> 09:42.960]  давайте посмотрим. Нам нужно посмотреть на суффиксы a и aba и найти у них наибольший общий
[09:42.960 --> 09:54.960]  префикс. Он очевидно равен единиц. Вот так мы нарисуем. Здесь он будет равен троечке.
[09:54.960 --> 10:08.480]  Здесь он будет равен единичке. Здесь ноль. Вот. Здесь два, здесь ноль. Тринадцать, десять, двадцать.
[10:08.480 --> 10:24.680]  Ну, давайте пониже чуть-чуть нарисуем. Ну, здесь все просто. Вот. То есть, ну, на самом деле сам по
[10:24.680 --> 10:30.240]  себе суффиксный массив используется крайне редко. Обычно вместо использования суффиксного массива
[10:30.240 --> 10:37.000]  подразумевают, что используют суффиксный массив плюс вот эту, ну плюс вот этот мистический
[10:37.000 --> 10:51.120]  массивчик. Вот. Что можно с ним делать? Ну, в первую очередь заметим, в первую очередь заметим,
[10:51.120 --> 10:58.400]  что если у вас есть суффиксный массив и еще есть Lcp, сам по себе этот массивчик Lcp, то на самом
[10:58.400 --> 11:07.840]  деле вы можете пытаться что сделать? Вы на самом деле можете пытаться искать Lcp у произвольных суффиксов.
[11:07.840 --> 11:16.600]  Как это делать? Ну, на самом деле оказывается, но тут важно окажется такое достаточно простое,
[11:16.600 --> 11:26.520]  но того не менее фундаментальное утверждение. Мы говорим, что пусть у меня ноль меньше либо равно,
[11:26.520 --> 11:36.000]  допустим, и меньше g меньше модуль s. Вот той самой s. Я уже не буду переписывать,
[11:36.000 --> 11:44.920]  что s там это строка, там s i и суффиксный массив. Тогда утверждаю я. Значит, Lcp,
[11:44.920 --> 11:59.080]  вот тут надо аккуратно, аккуратно. Lcp суффиксов, стоящих на итой и житой позиции,
[11:59.080 --> 12:29.000]  равен, оказывается, минимум из таких величин, как Lcp it, Lcp i plus 1 и так далее.
[12:29.000 --> 12:47.000]  Далее до Lcp g минус 1. Вот такое внезапное утверждение. Откуда же оно бегается?
[12:47.000 --> 12:55.880]  Ну, бегается оно из достаточно простого. Вот, допустим, давайте нарисуем какой-нибудь
[12:55.880 --> 13:07.960]  абстрактной суффиксной массив. Вот тут какие-то суффиксы. И между ними есть какие-то вот эти
[13:07.960 --> 13:25.280]  вот Lcp. Вот. И, допустим, там мы хотим найти Lcp между, допустим, вот каким-то, ладно,
[13:25.280 --> 13:31.960]  можно с краю, вот этим и вот этим. Вот у них есть вот этот вот минимум.
[13:31.960 --> 13:39.320]  Пришел какой-нибудь запрос, давайте извне. Ну, давайте, раз пришел извне,
[13:39.320 --> 13:49.240]  давайте еще и цвет какой-нибудь извне пробуем. Так, вот сегодня все цвета одинаковые какие-то.
[13:49.240 --> 13:59.280]  Так, смотрите. Так, то есть тогда что мы видим? Ну, мы видим, что если рассмотреть минимум,
[13:59.280 --> 14:05.520]  то мы обнаружим, что Lcp между этим и этим не меньше, чем вот этот минимум. Почему? Ну,
[14:05.520 --> 14:12.600]  потому что вот если этот минимум равен, допустим, там z, то мы видим, что первые z символы совпадают
[14:12.600 --> 14:17.320]  у этого и этого, у этого и этого, у этого и этого и так далее. То есть получается у этого и этого они
[14:17.320 --> 14:27.680]  совпадают. Вот. Что нас дальше? Ну, тогда, ну, может быть, Lcp между ними больше, вдруг следующие
[14:27.680 --> 14:33.800]  символы совпадают. Ну, тут, на самом деле, два варианта. Ну, во-первых, в первом случае может
[14:33.800 --> 14:39.080]  оказаться, что у какого-то из суффиксов на отрезке, ну, во-первых, то есть утверждение следующее,
[14:39.080 --> 14:43.960]  что заметим, что так как у нас первые z символов совпадают, то суффиксы на этом подотреске
[14:43.960 --> 14:54.880]  отсортированы по z плюс первому. Логично, да? Вот. Ну, электрографически порядок так устроен. Ну,
[14:54.880 --> 14:58.240]  тут два варианта. Во-первых, может, конечно, так случится, то есть надо взять и рассмотреть
[14:58.240 --> 15:03.440]  случаи, когда, может, на одном из этих суффиксов просто нету этого z плюс первого символа. Ну,
[15:03.440 --> 15:11.080]  тогда легко убедиться, что это вот это вот он и есть. И тогда Lcp точно ракуло z и ничему охраня. Но если
[15:11.080 --> 15:17.400]  все эти символы z плюс первые существуют, то тогда получается строки у нас откровенно отсортированы
[15:17.880 --> 15:25.480]  но раз они отсортированы и где-то вот существует ситуация, когда z плюс первые символы не равны,
[15:25.480 --> 15:33.960]  значит, получается, что в начале и в конце они тоже равны. Вот так вот примерно может выглядеть.
[15:33.960 --> 15:41.320]  Доказательства, действительно, ничего сложного тут нет. Ну, что это нам теперь дает? Это нам
[15:41.320 --> 15:49.240]  теперь дает маленькую приятную, то есть маленькую приятную возможность убедить считать Lcp для
[15:49.240 --> 15:56.000]  произвольных суффиксов. То есть вам остается только там, то есть что можно сделать? Ну, во-первых,
[15:56.000 --> 16:03.280]  нужно, ну, конечно, там надо найти, конечно, к суффиксовому массиву обратную перестановку,
[16:03.280 --> 16:07.120]  чтобы там для каждого суффикса находить, где он в суффиксном массиве находится, но это легко.
[16:07.120 --> 16:12.800]  Ну, самое интересное, конечно, что вам останется только написать какую-нибудь интересную структуру
[16:12.800 --> 16:19.240]  данных, которые на статическом массиве ищут минимум на отрезке желательно за 1. Ну,
[16:19.240 --> 16:26.600]  на практике там используют sports table, ну, вот, но чисто в теории, если мы хотим какого-то
[16:26.600 --> 16:34.240]  мистического идеала, то у нас есть всегда алгоритм фараф полтон блендера. Ну, и так,
[16:34.480 --> 16:38.800]  если мы мечтаем, что мы все, что мы тут сказали, мы построим за линию.
[16:38.800 --> 16:51.160]  Но, правда, даже если мы все это построим за линию, то вот, тогда, если какая-то вопрос, как же это
[16:51.160 --> 16:58.400]  использовать, ну, вот, например, как мы, например, могли бы с помощью суффиксного массива искать
[16:58.400 --> 17:08.320]  подстройки в строке. Вот так это сделать. Вот у нас предлагается такая не очень приятная
[17:08.320 --> 17:32.400]  асимпточка PLOGS. Можно ли ее как-то улучшить? Как бы ее улучшить? Вот, но, на самом деле,
[17:32.400 --> 17:41.640]  я утверждаю, что, действительно, ее можно улучшить до асимптотики. Вот, мы попытаемся решить за PLOGS.
[17:41.640 --> 17:55.360]  Казалось бы, а без PLOGS-а нельзя, может быть, с суффиксным массивом, с суффиксом деревья умели
[17:55.360 --> 18:05.160]  без PLOGS-а. Но есть мистический факт. На самом деле, не особо-то и умели. Потому что мы там,
[18:05.160 --> 18:11.040]  потому что тут, на самом деле, в суффиксном массиве возникает тоже, действительно, такая интересная
[18:11.040 --> 18:18.080]  мысль. Вот, действительно. Вот мы с вами, конечно, живем обычно в мире, когда у нас размер алфавита
[18:18.080 --> 18:27.840]  конечен. Ну, там, конечен, причем, сильно ограничен, типа, 1, 2, 26 константа. А теперь возникает
[18:27.840 --> 18:35.920]  вопрос. Предположим, что у вас строки состоят из тех самых камешков, которые мы умеем только на
[18:35.920 --> 18:40.760]  весах сравнивать. И при некоторой камешке эти весы могут говорить, что они, оказывается, равны.
[18:40.760 --> 18:50.120]  Вот, внимание, вопрос. За какую асимптотику мы тогда, в лучшем случае, можем построить суффиксный массив?
[18:50.120 --> 19:09.480]  Обе стройники.
[19:09.480 --> 19:21.480]  Вот, можно ли, действительно, построить тогда суффиксный массив быстрее, чем ZS log S?
[19:21.480 --> 19:32.800]  Вот, то есть, смотрите, какая интересная подлянка. Что, оказывается, что если бы у нас, действительно,
[19:33.400 --> 19:39.360]  были рандомные камешки, то, оказывается, быстрее, чем ZS log S, нельзя, потому что тогда сортировку массива
[19:39.360 --> 19:46.960]  из N различных камешков можно свести к построению суффиксного массива. Да и неразличных тоже,
[19:46.960 --> 19:50.560]  в общем-то, можно построить суффиксный массив, потом пробежаться за лигию, проверить, кто там,
[19:50.560 --> 20:00.400]  кому равен, а кто там, кому нет. Вот такая вот неожиданная мистика. Ну, с другой стороны,
[20:00.640 --> 20:08.000]  с другой стороны, погодите, погодите, суффиксный массив же очень легко строится за, на самом деле,
[20:08.000 --> 20:16.720]  линию. Смотрите, мы за линию построим, вот давайте так, возьмем эту строку S, припишем к ней диезик
[20:16.720 --> 20:24.400]  и построим суффиксное дерево. Вот мы же в прошлый раз умели его строить за линию, было дело?
[20:24.400 --> 20:34.320]  Было, да? Не, не, я помню, это мы были в прошлый раз. То есть, нет, когда там это были,
[20:34.320 --> 20:38.080]  то есть, может, это были там 5 других человек, но нет, не тот случай.
[20:38.080 --> 20:50.240]  У нас там был же этот лог Уфовита, да? Да, вот действительно, тут вот действительно очень...
[20:50.240 --> 20:56.240]  А с этой там, видимо, лого Толкувили превращается в лого ТЭЦ. Ну да, да, именно, именно. То есть,
[20:56.240 --> 21:01.120]  вот обратите внимание, да, что, а, вот тут уже не надо договаривать, каким образом бы суффиксный
[21:01.120 --> 21:08.080]  массив у собственного дерева был бы, да? Ну, я на всякий случай скажу. Да, понятно. Может быть,
[21:08.080 --> 21:15.120]  для обойти порядка. Ну, понятно, да. Ну, а зачем я вставил диезик? Ну, потому что иначе мы будем
[21:15.120 --> 21:24.120]  не очень... Ну, потому что нам это нужно для суффиксного... А зачем нам это нужно? Для удобства мы
[21:24.120 --> 21:31.240]  делали, добавляли диез в конец. Для какого? Зачем? Чтобы у нас все эти суффиксы были листьями.
[21:31.240 --> 21:36.240]  Заканчиваются листьями. Во, именно. Да, потому что идея у меня была такая, построим суффиксное
[21:36.240 --> 21:42.120]  дерево, заметим, что теперь все суффиксы будут заканчиваться в листе, ну и при этом, если диезик
[21:42.120 --> 21:47.360]  меньше, будем считать это символ, который меньше, чем все, что в строке есть, то тогда порядок конкретно
[21:47.360 --> 21:52.680]  вот этих суффиксов не поменяется никаким образом. Вот. И тогда, оказывается, после этого нам останется
[21:52.680 --> 22:01.320]  только пройтись по, действительно, нашему дереву ДФСиком и, в общем-то... Ну, понятно, мы с помощью
[22:01.320 --> 22:07.960]  на дереве можем хранить глубину строки, в которой мы находимся и, собственно, вывести. Вот. Ну, вот тут-то
[22:07.960 --> 22:13.800]  и вылезает. Оказывается, что у нас там, на самом деле, мы строили не за линию как таковую, а за линию на
[22:13.800 --> 22:23.720]  логарифму алфавита. Или, если бы вы заменили мапчик на массивчик, то это было бы за, там, линию умножить
[22:23.720 --> 22:34.280]  на алфавит по памяти. Вот. Так что здесь, получается, вот надо аккуратнее. То есть, на самом деле, логарифм там
[22:34.280 --> 22:39.640]  тоже вылезает. То есть, на самом деле, если мы строим суффиксное дерево для камешков, то, как бы, тоже
[22:39.640 --> 22:47.320]  придется смириться с тем, что это, наверное, SlogS. Ну, то есть, реальность может быть и побыстрее, но, по факту,
[22:47.320 --> 22:51.880]  ну, побыстрее, чем за SlogS не получится, потому что с помощью суффиксного дерева сортировка вполне
[22:51.880 --> 22:58.600]  возможна. А, ну и, кстати, в качестве добивочки еще заметим, что с помощью суффиксного дерева,
[22:58.840 --> 23:09.720]  в статье ЛЦПшки вас выкладываются достаточно бесплатно. Вот. Поэтому, на самом деле, P plus SlogS
[23:09.720 --> 23:17.640]  это, на самом деле, не самая плохая ассетточка. Ведь, кстати, если по этой логике вдуматься, то на камешках,
[23:17.640 --> 23:22.200]  на камешках, вообще-то, мы и в суффиксном дереве эти вхождения тоже за эту ассетточку ищем.
[23:22.200 --> 23:32.280]  Потому что в каждой вершине-то вы там лезете в маточку и за SlogS ищете соответствующий камеш.
[23:32.280 --> 23:42.520]  Вот. Так что, на самом деле, не такая уж плохая ассетточка. Вот. И вот это, что же с ней можно сделать.
[23:42.520 --> 23:50.400]  Значит, ну, как вы догадываетесь, SlogS, конечно, все еще подразумевает бинарный поезд-падвит.
[23:50.400 --> 23:57.600]  И делать мы это будем так. Значит, вот у нас есть снова какие-нибудь вот эти вот это вот штуки все.
[23:57.600 --> 24:06.040]  Ну, я не буду там предполагать, что там кто-то из них вот какие-то. И, ну, допустим, мы тут находимся,
[24:06.040 --> 24:18.720]  вот бин поезд говорит нам, что ответ где-то вот это у нас L, вот это вот L, это вот L.
[24:18.720 --> 24:29.400]  Ну, что означает L? Это означает, что L у меня меньше, чем P, а R, то есть вот этот суффикс меньше,
[24:29.400 --> 24:34.600]  чем P, а этот суффикс больше, чем P. Да. Сейчас мы для простоты будем просто отвечать на вопрос,
[24:34.600 --> 24:42.000]  существует ли такая подстрока, да или нет. Ну, понятно, что если мы хотя бы один суффикс,
[24:42.000 --> 24:46.200]  начиная сейчас с P, найдем, то есть у нас будет задача там найти все или там их количество,
[24:46.200 --> 24:51.000]  то там тоже там бин поездка с помощью вот этой вот всей черной магии, собственно, мы найдем без труда.
[24:51.000 --> 25:02.520]  Вот. Так вот. Значит, в качестве варианта еще будет важный момент, что мы будем хранить такие зелено-рыжие
[25:02.520 --> 25:14.720]  вещи, как LCP-L и LCP-R. Вот. Так вот. Догадывайте по цветовой хайме, что это такое.
[25:14.720 --> 25:35.000]  Ну, с этим суффиксом, суффиксом массива, да, LCP-L это равно, просто да, пишем, вот так и пишем прямо,
[25:35.000 --> 25:50.240]  LCP от строчи P. Ну и, соответственно, так нет, побольше. Так. Ну вот. Ну и здесь, соответственно,
[25:50.240 --> 26:06.640]  вот тут S, конечно, M-L. Вот. Ну и здесь я уже не буду переписывать, но вместо, так также есть LCP-R,
[26:06.640 --> 26:16.360]  и здесь абсолютная копия завыччена того, что вместо L тут допишем L. Да, и мы будем такие штуки поддерживать.
[26:16.360 --> 26:28.120]  Так. Ну давайте этот суффикс мы тоже подлиннее нарисуем. А перечка. Ну вот теперь что говорит
[26:28.120 --> 26:36.560]  там бинпульс? Бинпульс там говорит, ага. Так. Вот возьмите какой-нибудь мид. Вот. Вот. Возьмите
[26:36.560 --> 26:42.960]  какой-нибудь мид. Ну и в смысле захватить Смоленскую площадь, конечно, да. Вот. Ну вот. А возьмите
[26:42.960 --> 26:53.760]  суффикс посередине. Вот. И, соответственно, ну, и скажите, пожалуйста, ну во-первых, найдите LCP-MID,
[26:53.760 --> 27:00.720]  а во-вторых, скажите, пожалуйста, а в какую сторону вообще надо двигаться. То есть этот суффикс больше
[27:00.720 --> 27:12.240]  или меньше. Ну что можно сказать про LCP-MID? Ну да, давайте рассмотрим в случае, когда,
[27:12.240 --> 27:23.480]  то есть предположим, что LCP-L меньше либо равно LCP-R. Почему мы так можем предположить? Ну потому
[27:23.480 --> 27:29.480]  что если LCP-L больше, то мы будем делать то же самое, что скажем дальше, только симметрично. Вот.
[27:29.480 --> 27:36.440]  Тут, в общем-то, не принципиально. Итак, LCP-L у нас меньше либо равно LCP-R. Что мы тогда можем сказать?
[27:36.440 --> 27:43.400]  Тогда у нас сразу возникает мистическое утверждение о том, что LCP-MID, наверное,
[27:43.400 --> 28:03.880]  больше либо равен LCP-L. Нет такого ощущения. Да. Ну и в какую сторону тут тогда, естественно,
[28:03.880 --> 28:15.280]  мыслить? Мыслить, естественно, такое. А давайте-ка, начиная с LCP-L, будем насчитывать LCP-MID в тупую.
[28:15.280 --> 28:28.800]  Ну потому что будем насчитывать, насчитывать, насчитывать и насчитывать, и все. То есть насчитали,
[28:28.920 --> 28:39.600]  ну и тут соответственно за одной быстренько выяснили, куда идти налево или направо. Вот такой
[28:39.600 --> 28:46.040]  простой алгоритм. Пока не начнешь думать, за какой симметричкой он будет работать.
[28:46.040 --> 28:57.320]  Вот как бы показать, что он, ну действительно, казалось бы, работает хорошо. Потому что идея,
[28:57.320 --> 29:05.640]  он должен работать до Log S на бинпуиске и нод P на увеличение самих LCP-L или LCP-R,
[29:05.640 --> 29:10.840]  которые у нас типа не уменьшаются. И каждый шаг, казалось бы, кого-то из них доувеличивает.
[29:10.840 --> 29:34.840]  Так мы определяем, где будет сам P, то есть мы не ищем максимум LCP, мы просто пытаемся понять,
[29:34.840 --> 29:40.120]  вот с P он будет находиться от L до MID или от MID до R, а мы это понимаем, смотря на следующую
[29:40.120 --> 29:47.520]  букву, после конца LCP в MID. А если она меньше, чем то, что в P, нужно идти направо, если больше,
[29:47.520 --> 29:55.840]  то в лево. Это вроде понятно, почему работает. Ну да, почему именно работает. Почему за нормальный
[29:55.840 --> 30:06.560]  субточек. А к чему? У нас можно посмотреть на сумму LCP-L и LCP-R. Каждая такая операция увеличивается на 1,
[30:06.560 --> 30:17.040]  а не превосходно 2 LCP-R. Ну да, казалось бы. Но я утверждаю, что где-то здесь закралась одна маленькая подлянка.
[30:17.040 --> 30:39.160]  Я постарался обмануть, еще правильную картинку нарисовал. Хорошую картинку, красивую. Хотя и на этой
[30:39.160 --> 30:44.680]  каким-то уже на самом деле есть одна подлянка, уже может быть и на некую подлянку.
[31:09.160 --> 31:20.880]  Если, например, LCP-MID оказался меньше, чем LCP-R, и мы пошли налево, то у нас сумма уменьшилась. Да.
[31:20.880 --> 31:32.920]  Ну вот, действительно, первая проблема. Казалось бы, давайте предположим, что LCP-MID не дошел до LCP-R,
[31:32.920 --> 31:41.680]  и не просто не дошел, а выяснилось, что мы после этого еще и пошли влево. И тогда сумма LCP-R уменьшилась.
[31:41.680 --> 31:48.880]  Казалось бы, алгоритм обвалился. Но такого, кажется, не бывает. Да, но только замечаешь,
[31:48.880 --> 31:56.920]  что такого не бывает. По одной простой причине. Дело в том, что, смотрите, если он вот дошел
[31:56.920 --> 32:02.960]  так куда-то вот до сюда, то тогда мы обнаруживаем, что вот этот символ совпадает с очередным символ
[32:02.960 --> 32:09.360]  строки P, а этот символ меньше. И тогда получается, что мы, раз уж мы тут сдвинулись, то мы как бы
[32:09.360 --> 32:19.840]  в этот подотрезок и пошли. Получается, да, такого не бывает. То есть, если мы тут уже шли, шли, шли,
[32:19.840 --> 32:27.960]  шли и не дошли до LCP-R, то мы точно пойдем вправо, и получается, просто LCP-R на эту величину увеличивает.
[32:27.960 --> 32:34.160]  Но есть еще одна проблема все равно. Какая? Даже если MID он оказался большой, но мы пошли влево,
[32:34.160 --> 32:39.680]  то у нас сумма увеличилась на LCP-MID минус LCP-R. Да, вот смотрите, если внимательно посмотреть,
[32:39.680 --> 32:47.400]  если мы дошли до LCP-MID, который прямо далеко за LCP-R, то на этот раз могло оказаться,
[32:47.400 --> 32:54.440]  что мы все-таки пошли влево. Обратите внимание. Кажется, что нам не помешало бы, если мы могли быстро,
[32:54.440 --> 33:03.120]  но вот именно LCP-Suffix, тогда все работало бы. LCP-Suffix. Ну да, ну на самом деле, то есть идея такая. То есть,
[33:03.120 --> 33:07.760]  действительно, может так случиться, что мы пойдем вправо, и тогда заметим, что мы тут, то есть,
[33:07.760 --> 33:14.440]  мы вот эти вот LCP-R минус LCP-L, как бы в монетках не учили, можно сказать. Но идея очень простая,
[33:14.440 --> 33:19.640]  на самом деле. Вот этот вот первый шаг до LCP-R, на самом деле, мы можем сделать за О от единицы,
[33:19.640 --> 33:29.040]  если у нас есть суффиксный массив, есть LCP-шки, и на них еще этот фаров Colton Bender. Ну или там,
[33:29.040 --> 33:35.760]  я не знаю, эти ваши спорсы. То есть, тогда мы просто за, как бы, если, то есть, как бы, ну вот, то есть,
[33:35.760 --> 33:42.080]  минимум из LCP-MID и LCP-R, мы можем на самом деле теперь найти за О от единицы, банально,
[33:42.080 --> 33:47.040]  найдя LCP между этим суффиксом и этим суффиксом. Если он хотя бы LCP-R, значит и тут можно
[33:47.040 --> 33:53.360]  строктовать LCP-R. А если нет, то значит, тогда мы прям за О от единицы тут еще и понимаем, кто он.
[33:53.360 --> 34:02.400]  И у нас вариант, что сумма LCP-L и LCP-R увеличивается постоянно? Ну да. То есть, да, она увеличивается,
[34:02.400 --> 34:09.400]  причем, видите, увеличивается, в чем каждый шаг в тупую увеличивает ее. Нет, ну вот. Ну да,
[34:09.400 --> 34:13.440]  тем более, да, у нас, да, еще это отдельное дополнительное доказательство, что, да,
[34:13.440 --> 34:23.240]  эта сумма не уменьшается. Да. Совершенно верно. Так что получается красота, и вот получается,
[34:23.240 --> 34:29.800]  за P плюс лог С оказывается, строку P вполне найти можно. Ну и почему-то возникает жуткое подозрение,
[34:29.800 --> 34:37.440]  что быстрее, скорее всего, и нельзя. Ну потому что, опять же, если у нас рандомные камешки,
[34:37.440 --> 34:45.960]  то быстрее нельзя. Ну, конечно же, если нот. Ну, с другой стороны, а если бы на нот, правда,
[34:45.960 --> 34:53.040]  можно задуматься о другом. А если у нас все-таки массив константного размера? А, ну что тогда?
[34:53.040 --> 34:59.240]  Тогда можно было бы, конечно, сказать, давайте уже построим суффиксные деревья и не будем париться.
[34:59.240 --> 35:07.240]  И, на самом деле, я скажу даже, давайте. Сейчас есть ли массив константного размера? Альфавит константного
[35:07.240 --> 35:16.600]  размера. То есть можно построить суффиксное дерево. То есть, ой, это надо Этого Ука не написать, да. А теперь
[35:16.600 --> 35:23.600]  еще один мистический факт. Как, на самом деле, ищется суффиксное дерево? То есть, на самом деле,
[35:23.600 --> 35:30.560]  я утверждаю, что если у вас есть суффиксное дерево и ЛЦПшки, то суффиксная массив, то суффиксное дерево,
[35:30.560 --> 35:44.560]  вы можете построить на халяву. Ну, вообще говорят, да. То есть, по большому счету, да. То есть,
[35:44.560 --> 35:50.240]  фактически, вот если вкратце здесь пересовываем просто протокол, то есть, где от каждого суффикса
[35:50.240 --> 35:57.560]  должен затвитвиться следующий. То есть, там, коре, то есть, по идее такая. Здесь есть суффиксная массив,
[35:57.560 --> 36:05.040]  есть ЛЦПшки. Что вы делаете? Вы рисуете первый суффикс. Значит, вот в нашем случае это будет суффикс,
[36:05.040 --> 36:15.560]  допустим, вот от 6 до 7 по группе А, да. И находитесь теперь вот в этом листе. Теперь, суффикс АВА. Так, он
[36:15.560 --> 36:21.320]  должен отвитвиться от этого на глубине 1. Так, мы находимся на глубине 1. Поэтому все, что мы
[36:21.320 --> 36:30.240]  делаем, это рисуем тут по букве В, переход, значит, по, значит, 5-7. Да, мысленно подразумеваем,
[36:30.240 --> 36:37.960]  что тут буква А, а тут буква А. Так, мы находимся на глубине 3. То есть, да, полезно находиться именно
[36:37.960 --> 36:44.680]  вот на глубине, где мы только что остановились. Так, теперь нужно отвитвиться на глубине 3. Так, мы
[36:44.680 --> 36:51.960]  находимся на глубине 3. Ой, кайф какой. Так, ну отлично. Рисуем переход по букве С. Там, соответственно,
[36:51.960 --> 37:03.880]  3-7. И, в общем-то, то самое. Итак, мы находимся на глубине 7. Теперь надо отвитвиться на глубине 1. Так,
[37:03.880 --> 37:09.040]  мы находимся на глубине 7. Ой, слишком глубоко. Так, скачиваем наверх. Эта вершина находится на глубине 3.
[37:09.040 --> 37:16.800]  Так, глубоко идем. Эта вершина находится на глубине 1. О, подходит. Ура. Значит, от этой вершины мы
[37:16.800 --> 37:24.360]  отвитвляемся и строим опять, значит, букву С. Тут, соответственно, 3-7. Ну и, соответственно, тут какая-то цала.
[37:24.360 --> 37:38.760]  Так, следующий. Отвитвляется от предыдущего на высоте 0. Вот, ну здесь понятно. Так, здесь мы на глубине 5.
[37:38.760 --> 37:46.520]  Это много, здесь на глубине 1 много, здесь на глубине 0 кайф. Значит, пишем букву В. Там пишем 5-7. Радость В.
[37:46.520 --> 38:03.760]  Вот, и мы на глубине 2. Так, теперь надо отвитвиться на глубине 2. Ну вот, 3-7. Так, и теперь надо
[38:03.760 --> 38:08.600]  отвитвиться на глубине 0. Ну, подымаемся, подымаемся. Да, то есть здесь, на самом деле, не самый показательный
[38:08.600 --> 38:15.600]  пример, потому что, в принципе, конечно же, на самом деле, в других строчках могло возникнуть так,
[38:15.600 --> 38:24.000]  что вам придется посредине либра отвитвляться и ту самую новую вершину создавать. Могло быть такое. Ну,
[38:24.000 --> 38:34.080]  такой самый типичный пример. Это, на самом деле, строка, например, ААААБ. Тогда здесь будет происходить
[38:34.080 --> 38:39.600]  так. Вы сначала нарисуете вот это вот АААБ, потом говорите, так, следующий должен отвитвиться на
[38:39.600 --> 38:50.080]  глубине 6, а вы находитесь на глубине 8, поэтому тут где-то в районе двух символов придется распилить и
[38:50.080 --> 38:55.000]  собственно по букве В переход отправить. Теперь от него надо, соответственно, отвитвиться уже на
[38:55.000 --> 39:01.440]  глубине получается 5. Тогда идем так. Здесь это глубина 7 много, это глубина 6 много, вот где-то здесь
[39:01.440 --> 39:08.360]  глубина 5, строим вершину, двигаемся, ну и так далее. Понятен принцип, да? Вот, но важно, но как бы
[39:08.360 --> 39:14.360]  почему мы строим, как бы находимся именно там, где мы закончили, потому что получается, что вы это
[39:14.360 --> 39:19.480]  сделали за линию, ну там, за линию умножить на сколько вы там с мапочками работаете, естественно,
[39:19.480 --> 39:27.200]  хотя пока вы строите, можете просто push back на самом деле. Вот, и тогда, ну вот, и тогда получается,
[39:27.200 --> 39:32.480]  что вы фактически сделали такой красивый твест по этому дереву, и получается это работает за линию.
[39:32.480 --> 39:41.160]  Так что, картинка называется, как на самом деле строить стуфиксное дерево за линию. Ладно, правда,
[39:41.160 --> 39:52.720]  заговор. Для этого вам придется откуда-то взять стуфиксные массивы за линию. Ну да, в принципе,
[39:52.720 --> 39:56.840]  часть этих применений на самом деле можно так и выкинуть, да, как решать задачи с помощью
[39:56.840 --> 40:01.720]  стуфиксного массива. Так, есть стуфиксный массив, есть ЛЦП, так, строим дерево, решаем с деревом,
[40:01.720 --> 40:13.000]  все. На уровне идеи, в принципе, дальше можно не думать. Ну вот, но с другой стороны, хотя,
[40:13.000 --> 40:21.360]  как минимум, под строки в строке, может быть, где-то даже чуть-чуть быстрее. Сколько у нас там времени?
[40:26.840 --> 40:39.240]  Ну, соответственно, давайте смотреть, что же тут тогда, значит, как же это все, из какой магии
[40:39.240 --> 40:48.800]  находить. Ну да, у нас не так много времени, поэтому давайте смотреть. Ну, начнем с того,
[40:48.800 --> 41:00.800]  что как построить ЛЦП. Ну, кроме того, что, в принципе, в некоторых местах, кстати,
[41:00.800 --> 41:13.040]  так и говорят, как построить ЛЦП. Так вот, ну, начнем мы вот с чего. Мы начнем с того,
[41:13.040 --> 41:20.760]  что попробуем построить ЛЦП. Так, с конца идем. Раз мы идем с конца, то как бы, ну вот,
[41:20.760 --> 41:31.040]  то, итак, значит, предположим, что у нас есть строка С, и у нее есть суфиксный массив.
[41:31.040 --> 41:46.600]  Суфиксный массив, я скажу. Мы очень хотим построить массив ЛЦП. Да, редкий, да, очень интересный
[41:46.600 --> 41:51.680]  случай. Действительно, что этот алгоритм не привязан к построению суфиксного массива сам по себе,
[41:51.680 --> 41:56.800]  значит, он вот так и говорит, дайте мне строку С, дайте мне суфиксный массив, и после этого я
[41:56.800 --> 42:04.800]  вам построю этот ЛЦП за Лиги. Вот. Ну, алгоритм, соответственно, как называется алгоритм? Ну,
[42:04.800 --> 42:14.680]  соответственно, по авторам. То есть это называется будет у нас сейчас алгоритм Ари Кавы, Ари Муры,
[42:14.680 --> 42:35.440]  Касай, Ли и Парк. Ну, соответственно, у нас есть алгоритм четырех русских, алгоритм двух
[42:35.440 --> 42:46.040]  китайцев. В данном случае как-то, ну, как сказать, ну, тут очень сложно обратить внимание. Последние две
[42:46.040 --> 42:52.120]  фамилии не дают, возможно, сказать, что это алгоритм пяти японцев, а называется алгоритм пяти
[42:52.120 --> 43:04.520]  азиатов как-то некорректно. Поэтому алгоритм более известен как алгоритм Касай и других. Видимо,
[43:04.520 --> 43:12.120]  там Касай первым автором стоял. Причем, да, как говорят в таких случаях, да, на самом деле алгоритм,
[43:12.120 --> 43:19.840]  говорит, он проще, чем его название на самом деле. Сейчас вы в этом убедитесь. Ну, как убедитесь? Ну,
[43:19.840 --> 43:28.520]  поднимите руки, кто знает вообще этот алгоритм. Ну, скорее всего, не с таким названием. Да ладно. Не, не знаю,
[43:28.520 --> 43:35.960]  обычно олимпийские высокого уровня это здоровье. Ну, окей, ладно, в общем, в школе он мог вам и не пригодится.
[43:35.960 --> 43:47.160]  Значит, смотрите, алгоритм на самом деле очень простой. Значит, идея такая. Давайте заведем ту самую
[43:47.160 --> 43:57.160]  мистическую обратную перестановку. Заведем массив P от 0 до n-1, где для любого i будет верно,
[43:57.160 --> 44:15.160]  что P от SA, что SA от P-i-того равно i. Ну, короче, в P-i-том написано, где в суффиксном массиве
[44:15.160 --> 44:20.160]  находится i в суффиксном. Ну, построить эту обратную перестановку, понятное, труда не составлять, мы уже говорили об этом.
[44:20.160 --> 44:37.160]  Вот. Так вот, идея такая. Значит, будем строить LCP, будем насчитывать,
[44:37.160 --> 45:05.160]  значит, будем насчитывать LCP в следующем порядке. Сначала насчитаем LCP от P-0, затем LCP-P-1, LCP-P-2 и так далее.
[45:05.160 --> 45:30.160]  Вот, в таком порядке будем эти LCP-ки насчитывать. Вот. Насчитывать будем, как это у нас водится в теористров, в тупую.
[45:30.160 --> 45:53.160]  Пользуясь мистическим утверждением. Я утверждаю, что каждое следующее LCP, если оно, конечно, существует,
[45:53.160 --> 46:07.160]  это не буду совсем формально прописывать, оно больше либо равно, чем предыдущее, минус этим.
[46:07.160 --> 46:28.160]  Ну, давайте подумаем, откуда же такое? Ну, во-первых, если мы поверим в это утверждение, то тогда эти LCP-ки можно насчитывать в тупую реально за линию.
[46:28.160 --> 46:41.160]  Ну, потому что, по большому счету, мы начинаем с нуля, каждый шаг в тупую увеличивает нашу текущую штучку, и когда мы приплывем к следующей, мы как бы ее либо уменьшаем на единичку, либо не уменьшаем.
[46:41.160 --> 46:54.160]  Магия какая-то? Все нормально, да? Хорошо. Ну вот. И тогда получается, что суммальное количество этих шагов в тупую у вас будет не более чем два, там два модуля, получается.
[46:54.160 --> 47:07.160]  Логично, да? Вот. То есть код там совсем какой-то минималистический получается, остается только понять, откуда же мы взяли это утверждение.
[47:07.160 --> 47:13.160]  Ну, классическая идея. У нас есть LCP от двух суффиксов, если мы уберем от них по первому символу, то...
[47:13.160 --> 47:16.160]  То останется два суффикс.
[47:16.160 --> 47:18.160]  То LCP не более чем на один уменьшится.
[47:18.160 --> 47:22.160]  Да. Ну, давайте я сейчас нарисую и покажу то же самое.
[47:22.160 --> 47:34.160]  Да-да-да-да-да. Да-да-да-да-да. Да-да-да-да-да. Да-да-да-да-да-да. Да-да-да-да-да. Да-да-да.
[47:34.160 --> 47:48.160]  Ну, значит, ну вот, действительно, давайте вот предположим, что у нас жил-был и ты суффикс, то есть вот где-то на этой позиции, то есть S-А от какой-то позиции, поз.
[47:48.160 --> 47:55.160]  Ну вот, sA от поидитого, допустим, да, равно И, да, вот.
[47:55.160 --> 48:00.160]  Сначала был ИТ-суффикс, и было у него вот тут LCP.
[48:03.160 --> 48:06.160]  Это вот будет LCP, так сказать, поидитого.
[48:09.160 --> 48:10.160]  Теперь у нас два варианта.
[48:10.160 --> 48:16.160]  Ну, да, как говорится, что если LCP это было равно 0, то утверждение автоматически верно и неинтересно.
[48:18.160 --> 48:27.160]  Но если оно оказалось чем-то нетривиальным, то заметим, что вот у нас тут есть суффикс номер И, тут есть суффикс номер, ну, допустим, Иш-3, да.
[48:28.160 --> 48:38.160]  Тогда заметим, что если мы отпилим от них этот первый совпавший символ, то получатся суффиксы номер И плюс 1 и Иш-3 плюс 1.
[48:39.160 --> 48:47.160]  Так как ИТ был меньше Иш-3, то получается, что И плюс первый суффикс меньше, чем Иш-3 плюс 1.
[48:48.160 --> 49:03.160]  Тогда получается, что если мы возьмем вот этот вот ПИ плюс первый, то он находится где-то заведомо левее, чем Иш-3 плюс 1.
[49:04.160 --> 49:12.160]  В чем не просто левее, а LCP между ними как минимум вот это вот LCP при ИТ минус 1.
[49:13.160 --> 49:15.160]  То есть вот как минимум столько совпадающих символов у них точно есть.
[49:16.160 --> 49:23.160]  Но если у них столько совпадает символов, то тогда у этих двоих совпадает как минимум столько, то есть может столько, а может и больше.
[49:25.160 --> 49:28.160]  Вот эти суффиксы, они подсенсированы по вырастанию?
[49:29.160 --> 49:31.160]  Ну, конечно, по определению суффиксного массива.
[49:32.160 --> 49:36.160]  Да, конечно. Вот и все.
[49:39.160 --> 49:41.160]  Картинка-то немножко странная получается.
[49:42.160 --> 49:49.160]  Каким образом И плюс 1 и Иш-3 плюс 1 не достаточно стандартны?
[49:51.160 --> 49:54.160]  Нет, ну такое реально-то может быть.
[49:56.160 --> 49:58.160]  Ну, скажем так.
[50:01.160 --> 50:04.160]  Ну, во-первых, такое может быть, если они прямо во втором символе отличаются.
[50:05.160 --> 50:08.160]  Причем этот символ меньше XA, этот символ больше XA, во-первых.
[50:10.160 --> 50:11.160]  Ну вот.
[50:14.160 --> 50:23.160]  А, ну а во-вторых, тут может быть в принципе, что если тут XXXXXXX и тут XXXXXXX, а вот в месте, где они различаются, тут A, тут Z.
[50:24.160 --> 50:25.160]  Тогда вот так они расходятся.
[50:26.160 --> 50:27.160]  В принципе, такое тоже возможно.
[50:27.160 --> 50:34.160]  Ну, конечно, отметим, что рассуждение никак не привязывалось к тому, где относительно И этого суффикс находится вот этот и вот этот.
[50:35.160 --> 50:40.160]  То есть, ключевое утверждение для нас это то, что вот этот суффикс находится левее вот этого. Все.
[50:41.160 --> 50:43.160]  Мы только этим пользовались, обратите внимание.
[50:46.160 --> 50:51.160]  А то там, знаете, есть классическая задача в башне на тему того, что до нас строка S отсактируете ее циклические сдвиги.
[50:51.160 --> 50:54.160]  И найдите их, а, и найдите их в ЛЦПшке, что самое главное.
[50:55.160 --> 51:00.160]  И там вот оказывалось, что аналогичного рода алгоритм там просто так не работает.
[51:08.160 --> 51:15.160]  Ну, потому что там оказывалось, что если от двух одинаковых циклических сдвигов там отпилить типа один символ, да, ну или там перекинуть его в конец,
[51:15.160 --> 51:20.160]  то получатся абсолютно равные циклические сдвиги и в каком порядке находятся они в этом массиве непонятно.
[51:21.160 --> 51:24.160]  Вот. Ну это почему-то. Зачем я вам сапеллирую?
[51:24.160 --> 51:26.160]  Можно еще раз объяснить?
[51:27.160 --> 51:28.160]  Все.
[51:29.160 --> 51:30.160]  Еще, еще просто какого-то.
[51:31.160 --> 51:32.160]  Значит, еще. Значит, как-то, значит, смотрите.
[51:33.160 --> 51:36.160]  Рассмотрим вот ЛЦП вот этого пейнтова, да.
[51:37.160 --> 51:40.160]  То есть вот у нас есть суффикс номер и есть суффикс номер H3, который стоит с ним рядом.
[51:41.160 --> 51:43.160]  ЛЦП между ними равно вот чему-то.
[51:46.160 --> 51:51.160]  Если это, ну, если это что-то равно нулю, нам не интересно, но если это суффикс номера H3, то нам не интересно.
[51:51.160 --> 51:53.160]  Если это, ну, если это что-то равно нулю, нам не интересно.
[51:54.160 --> 51:59.160]  А если оно больше или равно одного, значит у них, у этих суффиксов как минимум первый символ совпадает.
[52:00.160 --> 52:06.160]  Если мы этот первый символ обоих отпилим, то у нас образуются суффиксы номер и плюс один и H3, номер и ширина плюс один.
[52:09.160 --> 52:15.160]  Заметим, что суффикс и плюс один, во-первых, меньше, меньше, меньше суффикса и ширина плюс один.
[52:16.160 --> 52:21.160]  И ЛЦП между ними, это как минимум вот это ЛЦП минус один.
[52:22.160 --> 52:24.160]  Ну как как минимум, просто разные на самом деле.
[52:26.160 --> 52:31.160]  Ну так как и плюс первый меньше, чем H3, значит получается P и плюс один меньше, чем P от H3 и плюс один.
[52:32.160 --> 52:36.160]  То есть и плюс первый суффикс находится в суффиксном массиве левее, ну в смысле раньше, чем H3 и плюс один.
[52:40.160 --> 52:41.160]  Ну что тогда?
[52:42.160 --> 52:50.160]  Ну тогда замечаем, что если вот между, у этих вот ЛЦП, типаELCPE минус один, то тогда у Этого и у Этого ЛЦП не меньше.
[52:53.160 --> 52:58.160]  Ну потому что, если вот у Этого и у Этого вот столько минус один символов совпадают,
[52:59.160 --> 53:06.160]  то тогда и у всех вот этих суффиксов первые, первые эти столько минус один символов тоже совпадают.
[53:06.160 --> 53:16.160]  значит ЛЦП вот между этим вот этим как минимум вот столько минусы шой требовалось шой требовалось
[53:16.160 --> 53:39.560]  ну потому что потому что смотрите потому что нас интересует и как бы где находится и плюс первый
[53:39.560 --> 53:43.040]  суффикс то есть и плюс первый суффикс в смысле тот кто начинается с и плюс первый символ на строке
[53:43.040 --> 53:46.680]  а не тот кто находится в суффиксном массиве на соответствующей позиции
[53:46.680 --> 54:09.600]  ну потому что в реальности это позиция п и т а это п и т плюс 1 здесь вот и написано то
[54:09.600 --> 54:16.800]  к сим ближе что с а от пи того равно и то есть давайте если если вас это смущает давайте по
[54:16.800 --> 54:24.400]  другому давайте скажем что это супер с номер и это суффикс из 3 и это позиция соответственно
[54:24.400 --> 54:43.960]  п и а это позиция п и плюс 1 ну да она же п из 3 вот так уже не смущает вот и все точите чем приятен
[54:43.960 --> 54:49.040]  алгоритм он приятен тем что он работает за линию чем обратить внимание никаким камешком не привязан
[54:49.040 --> 54:55.160]  да то есть не возникает эта линия ну в смысле ли не умножить на размер алфавита там такого
[54:55.160 --> 55:01.800]  тут нет тут честные то есть поэтому да то есть поэтому алгоритм даже отдельно статья по нему
[55:01.800 --> 55:08.680]  идет отдельно соответственно то есть она да но то есть как в этот алгоритм то есть это такой вот
[55:08.680 --> 55:14.240]  маленький ящичек который может быть приложен к любому алгоритму поиска суффиксного массива
[55:14.240 --> 55:23.760]  в данном году мы играем ну ищем в цлиципле в порядке то есть сначала мы ищем ну как бы
[55:23.760 --> 55:32.960]  на левой потом до первого да именно и они каждый раз до них вверх до рождения да то есть
[55:32.960 --> 55:39.520]  каждый следующий это как как минимум как предыдущий минус один из этого следует что
[55:39.520 --> 55:47.760]  оно что мы как бы проверяем да что суммарная в ту что суммарная в тупую работает за ними
[55:47.760 --> 55:57.880]  да так что дал при этом работает за вот такой вот у нас красота
[55:57.880 --> 56:12.000]  ну а теперь остается собственно финал как же нам построить собственно суффиксы массив
[56:12.000 --> 56:20.600]  ну мы сейчас предъявим такой классический алгоритм но продукция да у нас каковому
[56:20.600 --> 56:28.080]  сожалению работа будет за это но как вы поняли что в общем случае быстрее в общем-то и нельзя
[56:28.080 --> 56:45.120]  но тем не менее мы попробуем и сделать начинаем собственно строить суффиксный массив
[56:45.120 --> 56:56.760]  так вот суффиксный массив как же его строить первая идея возникает такая и так вот жил была
[56:56.880 --> 57:07.040]  желанная строчка первая значит построение суффиксного массива мы сведем к построению
[57:07.040 --> 57:19.240]  к сортировке циклических зверей то есть если допустим начать писать код то на самом деле
[57:19.240 --> 57:28.800]  я вам так сразу скажу вот допустим если у вас будет vector int допустим findSuffixArray
[57:28.800 --> 57:50.560]  то на самом деле код будет в коде будет написано буквально следующее vector int
[57:50.560 --> 58:05.560]  sA равно sortCyclicShifts только не от строти S, а от строти S плюс
[58:05.560 --> 58:17.840]  например где ездит но на самом деле чтобы совсем надежно могло бы быть можно вот так написать
[58:17.840 --> 58:33.240]  просто нулевой символ добавьте и все ну или там 96 там вот значит теперь выпиливаем
[58:33.240 --> 58:40.320]  ну теперь замечаем что там первым циклическим звегом там будет идти циклический звег начинается
[58:40.320 --> 58:47.760]  с этого нулевого символа поэтому можно сделать там скажем к сожалению вектора нету по backup
[58:47.760 --> 58:58.320]  поэтому пишем вот какое-то вот такое заклинание допустим и после этого все return sA
[59:10.320 --> 59:19.320]  откуда это берется вообще ну давайте картинку нарисуем она нам все равно пригодится
[59:19.320 --> 59:27.800]  допустим вот у нас есть строка abatsaba вот давайте вспомним у нас был тулькостный массив
[59:27.800 --> 59:44.720]  оба оба цаба цаба вот это все да баба цаба и цаба ну вот ну теперь замечаем если мы в строке приписали
[59:44.720 --> 01:00:00.800]  этот диезик но опять у нас добавился суффикс состоящий из диезика но заметим что относительный
[01:00:00.800 --> 01:00:07.480]  порядок всех этих суффиксов никак не поменялся именно потому что диезик он меньше всех символов
[01:00:07.480 --> 01:00:17.000]  строки есть это важно но также заметим что так как эти строки по парно различны да то получается
[01:00:17.000 --> 01:00:23.520]  каждая там строга меньше предыдущей и тогда получается что если мы не причем что самое
[01:00:23.520 --> 01:00:29.240]  важное ни одна из этих строк теперь когда мы добавили диезик не является префиксом следующий
[01:00:29.240 --> 01:00:35.960]  видите да то есть как бы когда мы их сравниваем то есть мы до того как достигнем конца одной строк
[01:00:35.960 --> 01:00:41.240]  мы там наткнемся на разные символы поэтому оказывается что если мы тут припишем
[01:00:41.240 --> 01:01:02.520]  соответственно еще тут строчки то получается получается оба цаба оба то получается что
[01:01:02.520 --> 01:01:07.080]  действительно можно сортировать у этой строки уже не спроте а циклический и получится ровно
[01:01:07.080 --> 01:01:19.920]  точно поэтому начиная с этого момента мы забываем о всех диезиках и строй и решаем такую задачу дана
[01:01:19.920 --> 01:01:30.720]  строка с и мы строим циклические и сортируем ее циклический а в качестве добивки вы кстати
[01:01:30.720 --> 01:01:36.080]  объявляем строку в некотором смысле бесконечной то есть такие циклические из лиги ее бесконечность
[01:01:36.080 --> 01:01:44.240]  то есть ну заметил что я тут могу еще еще тут допилить и език оба цаба вот это все но
[01:01:44.240 --> 01:02:12.560]  и так далее строчка у нас такая бесконечная будет такая зацикленная
[01:02:14.240 --> 01:02:20.360]  как мы этим будем пользоваться допоминаю да мы больше не строим суфиксный массив мы сортируем
[01:02:20.360 --> 01:02:44.960]  циклический делаем ну вот так вот ну идея такая мы будем сортировать ну можно коротко
[01:02:45.440 --> 01:02:59.440]  мы будем сортировать эти циклические сдвиги значит сортируем по первому символу сначала по первому
[01:02:59.440 --> 01:03:08.560]  символу потом по первым 2 символы
[01:03:18.560 --> 01:03:25.600]  потом по первым 4 символа
[01:03:30.320 --> 01:03:47.120]  потом по первым 8 символом потом ну 16 32 64 и так далее ну в самом конце мы
[01:03:47.120 --> 01:03:52.200]  отсортируем по первым не менее чем n символом и получается что мы тогда циклические сдвиги
[01:03:52.200 --> 01:04:01.600]  отсортировать но все что нам остается это каждый из этих шаров проделать за линию
[01:04:01.600 --> 01:04:10.760]  ну ладно каждый из этих шагов кроме первого что может так если мы по нам подсунуть камешки то
[01:04:10.760 --> 01:04:15.840]  в общем даже уже первый первый шаг быстрее чем за линию не отсортируем быстрее чем за
[01:04:16.000 --> 01:04:28.000]  но я утверждаю что переход от каждого шага к следующему мы элементарно сделаем за линию
[01:04:28.000 --> 01:04:34.760]  дело в том что предположим что значит работать это будет следующим образом вот давайте я попробую
[01:04:34.760 --> 01:04:56.040]  тут на картинке по рисовать и получается вот примерно такое
[01:05:04.760 --> 01:05:18.520]  вот значит да вот давайте предположим что мы отсортировали суффиксы то есть не суффикс
[01:05:18.520 --> 01:05:25.600]  а вот эти вот циклические сдвиги теперь бесконечным рисовать по первым и допустим символом
[01:05:34.760 --> 01:05:41.720]  тогда заметим что если я их отсортировал то у меня будет идея такая я буду их не просто
[01:05:41.720 --> 01:05:50.240]  сортировать а каждой подстроке длины l присваивать мысленно какой-нибудь красивый красненький
[01:05:50.240 --> 01:06:11.200]  0 0 1 1 2 3 3 4 ну догадывается если разным присваиваю разным разным разное порядке возрастания
[01:06:11.200 --> 01:06:26.400]  очень удобно как же теперь отсортировать по первым 2 но теперь заметим что вот эти вот подстроки
[01:06:26.400 --> 01:06:36.640]  длины они тоже перенумерованы правда то есть тоже тут конечно же сильно более рандомные числа тут
[01:06:36.640 --> 01:06:53.040]  уже начинается там 5 8 4 3 там 2 0 1 но тем не менее но то есть эти числа есть и вы теперь
[01:06:53.040 --> 01:07:01.200]  но и на самом деле вы теперь можете отсортировать просто ну как-то как-то у нас
[01:07:01.200 --> 01:07:10.960]  называлось радик сортом каким-нибудь или как у нас это называлось ну там либо радиус
[01:07:10.960 --> 01:07:15.400]  либо карзикарванная сортировка там то есть действительно то есть по большому то есть по
[01:07:15.400 --> 01:07:21.160]  большому счету каждый и каждая подстрока дыны 2 и теперь задается как пара чисел причем чисел
[01:07:21.160 --> 01:07:27.840]  от нуля до н обратите внимание до 1 а то и меньше поэтому то есть вам теперь нужна за линейное
[01:07:27.840 --> 01:07:39.440]  время отсортировать n по чисел как же это сделать ну сделать стандартным алгоритмом устойчивых
[01:07:39.440 --> 01:07:48.440]  то есть сначала отсортировать по вот этому то есть по второй части а потом устойчивым образом по
[01:07:48.440 --> 01:07:55.460]  первой помните было дело да и оба раза это легко делается за линию то есть на уровне
[01:07:55.460 --> 01:08:05.520]  понимаете да понимаете да вот ну в общем-то но на уровне идеи алгоритм на этом в общем-то
[01:08:05.520 --> 01:08:22.200]  заканчивается вот ну в принципе так ладно время у нас вроде вышло мы начали с опоздания
[01:08:22.200 --> 01:08:31.680]  ну можно да можно вот да да ну раз мы начали с опоздания можно тогда есть чуть-чуть кода подписать
[01:08:31.680 --> 01:08:39.500]  еще вот то есть вылететь код ну здесь так вот имеет смысл вот и взять что правильная его
[01:08:39.500 --> 01:08:46.320]  реализация на самом деле как бы константу тут может хорошо оптимизировать и так поехали
[01:08:46.320 --> 01:09:13.520]  вектор импс сорт так как шейт значит ну начнем с того что давайте отсортируем по первым
[01:09:14.420 --> 01:09:22.780]  ну раз уж это стрим кто обычно все-таки сортирует за линию сортирует так а ну а первых давайте
[01:09:22.780 --> 01:09:42.500]  значит создаем вектор int аж ну соответственно различных букв у нас будет бывает сколько правильно
[01:09:42.500 --> 01:09:56.280]  256 так какие нам еще рептора потребуется значит ну давайте сразу перепишем до аж аж
[01:09:56.280 --> 01:10:07.100]  нет ладно это н аж аж нам просто а также нам потребуется а на ци и н ци
[01:10:07.100 --> 01:10:24.740]  нет все правильно так смотрите как будет выглядеть сортировка по собственному символу значит ну
[01:10:24.740 --> 01:10:34.320]  во первых фор пишем все просто чар ц 2. с плюс плюс аж ц ну тут понятно ну
[01:10:34.320 --> 01:10:43.080]  дальше стандартный код фор инт и равно один и меньше все пишу и думаю а если
[01:10:43.080 --> 01:10:46.840]  сейчас быстро включу компьютер я могу просто презентацию показать и тут уже написал
[01:10:46.840 --> 01:10:56.140]  какой вариант предпочитаете можете ну вот ну можно так ну как бы тут тут как всегда
[01:10:56.140 --> 01:11:00.820]  ну показать на презентацию будет это и будет быстрее а можно написать так и тогда как бы
[01:11:00.820 --> 01:11:12.060]  это будет учили как оба варианта имеют преимущество и недостатки как вы предпочитаете ну вообще да
[01:11:12.060 --> 01:11:34.440]  или давайте демократия давайте кто за то что продолжит писать код тут и меньше ну допустим
[01:11:34.440 --> 01:11:39.720]  не скомпилизованной там где-нибудь вставить и там строчку что н равно с точкой венгста
[01:11:39.720 --> 01:11:44.240]  ладно я сам ставлю
[01:11:44.240 --> 01:12:01.480]  вот тем более что все равно тут надо 256 а лучше аж сайс но аж и т плюс равно аж от и
[01:12:01.480 --> 01:12:20.520]  вот теперь а точка ассайн на n и дальше фор значит пишем им и равно и минус один и больше
[01:12:20.520 --> 01:12:29.720]  либо равно нуля и и мы вот тут сейчас сейчас будет мистическое заклинание минус минус аж от
[01:12:29.760 --> 01:12:41.640]  немножко заклинание но есть но мы конечно прошел году уже подобного рода код писали так
[01:12:41.640 --> 01:12:51.080]  что ничего страшного пока будет не страшно так теперь бы нам номера насчитать
[01:12:51.080 --> 01:13:02.760]  теперь сделаем так смотрите ну а первым давайте с ну теперь теперь бы для для каждого
[01:13:02.760 --> 01:13:14.160]  так для каждой подстроки длиной 1 насчитать бы ее номер значит пишем ц.рисайз от ц а нулевое
[01:13:14.160 --> 01:13:30.200]  равно нулю ну и дальше фор как всегда мне хочется прям на сях писать и что бы тут пишем
[01:13:30.200 --> 01:13:43.200]  с а и т ну как уже догадываетесь чему равно да с а и минус 1 плюс верно ли что с и т равно
[01:13:43.200 --> 01:14:02.920]  но не самая оптимальная версия потому что возможно вы слишком много раз вычитаете
[01:14:02.920 --> 01:14:11.800]  вон а и т минус первое вот это хотя да тут особо никуда не денешься так дальше начинается
[01:14:11.800 --> 01:14:22.800]  самое интересное так пожалуй дальше начинается настолько самое интересное что я пожалуй это
[01:14:22.800 --> 01:14:29.240]  самое интересное буду сверху писать чтоб красиво было ну тут понятно пишем функцию
[01:14:29.240 --> 01:14:40.640]  теперь мы переходим но здесь полик закончился если что поэтому пишем пишем теперь так но
[01:14:40.640 --> 01:14:53.800]  давайте эти на и мц нам по-любому пригодятся поэтому можно сразу на точка рисайз м ц.рисайз
[01:14:53.800 --> 01:15:14.840]  дальше поехали дальше пишем фор теперь и мц и равно один и меньше и и плюс равно и
[01:15:15.840 --> 01:15:24.920]  и вот здесь мы должны эти пары отсортировать то есть смотрите что у нас есть у нас уже
[01:15:24.920 --> 01:15:32.000]  значит и вариант будет такой у нас уже есть на этот момент массив а в котором хранятся подстроки
[01:15:32.000 --> 01:15:41.160]  длины l отсортированная по первому м символу понимаете да но и ну и у каждой строки еще
[01:15:41.160 --> 01:15:49.320]  есть номер номер и он хранится в ц.рисайз казалось бы мы теперь должны сделать две
[01:15:49.320 --> 01:16:01.840]  сортировки подсчетом сначала вот этих подстрок а потом вот этих правда нам нужно похоже что
[01:16:02.000 --> 01:16:09.360]  для правых номеров насчитать сколько левых у нас есть для правого счета сколько левый
[01:16:09.360 --> 01:16:19.800]  здесь нет то есть да нет вот сам фишка в том я просто смотри сейчас как бы сейчас логика такая
[01:16:19.800 --> 01:16:27.600]  казалось бы сейчас просто два раза должны что-то насчитать то есть два раза сделать вот
[01:16:27.600 --> 01:16:32.600]  примерно эти операции. То есть насчитать массив h, пробежаться и потом перезаписать. Правда, Иван?
[01:16:34.600 --> 01:16:38.600]  Ну вот. Ну, можно было бы так написать, это будет работать, кстати.
[01:16:39.600 --> 01:16:42.600]  Но мы применим пару мистических оптимизаций.
[01:16:43.600 --> 01:16:48.600]  Во-первых, заметим, что h имеет смысл насчитывать только один раз.
[01:16:49.600 --> 01:16:57.600]  Потому что заметим, что массив h, он на самом деле и здесь, и здесь будет один и тот же, потому что набор чисел один и тот же.
[01:16:57.600 --> 01:16:58.600]  Согласны?
[01:16:59.600 --> 01:17:00.600]  Вот. Согласны?
[01:17:02.600 --> 01:17:05.600]  Вот. Поэтому давайте вот массив h насчитаем один раз.
[01:17:06.600 --> 01:17:07.600]  То есть как мы его насчитаем?
[01:17:08.600 --> 01:17:11.600]  h точка стичем. Останет смысл.
[01:17:12.600 --> 01:17:13.600]  n ноль.
[01:17:14.600 --> 01:17:20.600]  for int i равно 0 и меньше n плюс плюс i.
[01:17:21.600 --> 01:17:26.600]  h от чего там? Ну цель этого, конечно.
[01:17:27.600 --> 01:17:28.600]  плюс плюс
[01:17:30.600 --> 01:17:31.600]  for
[01:17:32.600 --> 01:17:37.600]  i равно 1 и меньше n плюс плюс i.
[01:17:38.600 --> 01:17:39.600]  Что там еще?
[01:17:40.600 --> 01:17:45.600]  Ну вот. Понятно. h i t плюс равно h i минус 1.
[01:17:47.600 --> 01:17:48.600]  Вот на h насчитали.
[01:17:49.600 --> 01:17:52.600]  Можем их куда-то даже сохранить, но мы не будем этого делать.
[01:17:53.600 --> 01:17:57.600]  Вообще-то мы много раз уже начинали с мультиклей.
[01:17:57.600 --> 01:18:03.600]  Ну да, но я имел в виду, что мы должны были насчитать это вместо двух раз внутри одной интеракции цикла, мы могли насчитать это.
[01:18:04.600 --> 01:18:06.600]  Нет, понятно, что там потом все поменяется.
[01:18:09.600 --> 01:18:10.600]  Вот.
[01:18:14.600 --> 01:18:15.600]  Вот.
[01:18:16.600 --> 01:18:22.600]  В принципе, знаете, можно на самом деле еще задуматься о геосимпатической оптимизации, что эти h насчитывать при насчете c шагов.
[01:18:25.600 --> 01:18:26.600]  Понятно, да?
[01:18:27.600 --> 01:18:28.600]  Ну да.
[01:18:29.600 --> 01:18:32.600]  Ну то есть, если они совпадают, то нет чего.
[01:18:35.600 --> 01:18:37.600]  Ну да, можно в принципе.
[01:18:38.600 --> 01:18:39.600]  Ну да.
[01:18:40.600 --> 01:18:41.600]  Ну это ладно, чуть позже подумаем.
[01:18:42.600 --> 01:18:43.600]  Мне будет немножко привычнее, но тем не менее.
[01:18:44.600 --> 01:18:45.600]  Но основная оптимизация не в этом.
[01:18:46.600 --> 01:18:50.600]  Основная оптимизация означает, что мы не только h будем насчитывать один раз.
[01:18:51.600 --> 01:18:57.600]  А фишка еще будет в том, что мы и сортировку подсчетом вот это перезаписывание a будет делать не два раза, а один.
[01:18:58.600 --> 01:18:59.600]  Потому что идея такая.
[01:19:00.600 --> 01:19:05.600]  Дело в том, что сейчас в массиве a у нас мы по первым a символам отсортировали все, правда?
[01:19:06.600 --> 01:19:07.600]  А теперь идея такая.
[01:19:08.600 --> 01:19:11.600]  А давайте из всех a-шек вычтем l.
[01:19:13.600 --> 01:19:15.600]  Ну по модулю n, конечно, обычно.
[01:19:16.600 --> 01:19:26.600]  Тогда я утверждаю, что у нас появятся циклические сдвиги, отсортированные уже не по первым a символам, а по вторым.
[01:19:27.600 --> 01:19:29.600]  Неплохо, правда?
[01:19:30.600 --> 01:19:37.600]  То есть получается, что ничего дополнительно особо делать не надо для того, чтобы отсортировать эти циклические сдвиги по вторым l символам.
[01:19:38.600 --> 01:19:41.600]  Надо просто взять вот этот уже отсортированный массив по первым и уменьшить на это все.
[01:19:42.600 --> 01:19:44.600]  Понятна логика?
[01:19:46.600 --> 01:19:55.600]  Поэтому по факту все, что мы должны сделать, это из a-шек вычесть l и эти a-шки потом уже устойчивым образом отсортировать уже по себе.
[01:19:57.600 --> 01:20:00.600]  В результате дальше будет писаться абсолютно неожиданный...
[01:20:01.600 --> 01:20:02.600]  Сейчас совсем листика будет.
[01:20:05.600 --> 01:20:09.600]  Значит, for int i равно m-1,
[01:20:10.600 --> 01:20:12.600]  i больше либо равно 0,
[01:20:12.600 --> 01:20:14.600]  0,
[01:20:15.600 --> 01:20:17.600]  и дальше будем говорить.
[01:20:18.600 --> 01:20:20.600]  Значит, n, a,
[01:20:21.600 --> 01:20:23.600]  минус, минус h
[01:20:24.600 --> 01:20:26.600]  от c,
[01:20:27.600 --> 01:20:29.600]  от аитова,
[01:20:30.600 --> 01:20:32.600]  в чем даже не от аитова,
[01:20:33.600 --> 01:20:35.600]  а от аитова плюс n,
[01:20:36.600 --> 01:20:38.600]  минус l процент n
[01:20:39.600 --> 01:20:41.600]  равно
[01:20:43.600 --> 01:20:45.600]  a-i-t плюс n,
[01:20:46.600 --> 01:20:48.600]  минус l процент n.
[01:20:55.600 --> 01:20:58.600]  Ну как бы логично, взяли очередной суффикс, ну в смысле сдвинули его на l,
[01:20:59.600 --> 01:21:01.600]  взяли его цвет,
[01:21:02.600 --> 01:21:05.600]  подсвету номер корзины, вычли из него один и записали.
[01:21:06.600 --> 01:21:08.600]  Удобно, правда?
[01:21:09.600 --> 01:21:14.600]  Зачем выдвигать на l? Почему не плюс или а?
[01:21:15.600 --> 01:21:19.600]  Изначально в массиве a они отсортированы по первому n-силу.
[01:21:20.600 --> 01:21:22.600]  Если сдвинуть на l именно в минусы,
[01:21:23.600 --> 01:21:26.600]  то тогда они отсортироваются по второму.
[01:21:27.600 --> 01:21:29.600]  Вот такая красота получается.
[01:21:32.600 --> 01:21:34.600]  Ну и теперь остается насчитать...
[01:21:34.600 --> 01:21:36.600]  А, ну во-первых,
[01:21:37.600 --> 01:21:39.600]  перенести то, что в массиве a в массив а,
[01:21:40.600 --> 01:21:42.600]  это делается за у от единицы
[01:21:43.600 --> 01:21:45.600]  простой командой a.swap of n.
[01:21:52.600 --> 01:21:54.600]  Ну и что теперь надо сделать?
[01:21:55.600 --> 01:21:57.600]  Теперь n-сшки надо насчитать,
[01:21:58.600 --> 01:22:00.600]  то есть новые цвета.
[01:22:01.600 --> 01:22:03.600]  Насчитываем абсолютно тем же образом.
[01:22:04.600 --> 01:22:07.600]  А нулевое равно нулю.
[01:22:10.600 --> 01:22:13.600]  Ну и дальше for int и равно нулю.
[01:22:14.600 --> 01:22:18.600]  1 и меньше n плюс плюс и.
[01:22:21.600 --> 01:22:23.600]  Ну и дальше можно так и написать.
[01:22:24.600 --> 01:22:29.600]  n-саит равно, соответственно, n-са и минус первое.
[01:22:30.600 --> 01:22:32.600]  Плюс...
[01:22:34.600 --> 01:22:38.600]  Ну и здесь пишем саит равно равно,
[01:22:39.600 --> 01:22:41.600]  са и минус первое.
[01:22:43.600 --> 01:22:44.600]  Ну и что дальше надо написать?
[01:22:45.600 --> 01:22:48.600]  n, n. Чего? Чего? Чего происходит?
[01:22:49.600 --> 01:22:51.600]  И ну и здесь еще придется написать
[01:22:51.600 --> 01:23:00.600]  и еще придется писать c от аит плюс l процент n равно равно
[01:23:01.600 --> 01:23:08.600]  c от аи минус аит плюс l процент n.
[01:23:15.600 --> 01:23:19.600]  c.swap от n-с
[01:23:22.600 --> 01:23:26.600]  Ну и все. Цикл на этом заканчивается.
[01:23:31.600 --> 01:23:33.600]  Вот. Ну и остается только сказать,
[01:23:34.600 --> 01:23:36.600]  корритория, соответственно, а.
[01:23:38.600 --> 01:23:40.600]  Все.
[01:23:44.600 --> 01:23:47.600]  В уконении букв было больше.
[01:23:52.600 --> 01:23:54.600]  Вот.
[01:23:55.600 --> 01:23:58.600]  Тут как бы написан год, в котором реализована основная оптимизация,
[01:23:59.600 --> 01:24:01.600]  заключаясь в том, что две сортировки подсчетов,
[01:24:02.600 --> 01:24:03.600]  то есть надо делать не два логоинсортировок подсчетов,
[01:24:04.600 --> 01:24:06.600]  а только логоинсортировки подсчетов.
[01:24:07.600 --> 01:24:11.600]  Ну то есть есть подозрение, что это не самая оптимальная реализация.
[01:24:12.600 --> 01:24:13.600]  То есть, ну я просто не стал так дописывать,
[01:24:14.600 --> 01:24:15.600]  чтоб совсем уже мобильный наводить.
[01:24:16.600 --> 01:24:17.600]  Ну основная оптимизация не помешала бы, конечно,
[01:24:18.600 --> 01:24:20.600]  вот от этих процентчиков избавиться.
[01:24:21.600 --> 01:24:23.600]  Ну вот. Ну там, то есть можно от них избавиться,
[01:24:24.600 --> 01:24:26.600]  если написать там функции вычитания по модулю и сложения
[01:24:27.600 --> 01:24:28.600]  по модулю через рефы.
[01:24:29.600 --> 01:24:30.600]  Это как минимум.
[01:24:31.600 --> 01:24:32.600]  Вот. Ну а также я бы еще скорее всего
[01:24:33.600 --> 01:24:35.600]  можно задуматься на тему того, чтоб вот в этом
[01:24:36.600 --> 01:24:38.600]  и вот в этом вот местах как-то более адекватно насчитывать h,
[01:24:39.600 --> 01:24:41.600]  потому что видите, мы тут тратим какие-то лишние коны,
[01:24:42.600 --> 01:24:43.600]  а на самом деле вот эти вот лишние фолики,
[01:24:44.600 --> 01:24:45.600]  на самом деле вот эти вот тратить не лучше.
[01:24:46.600 --> 01:24:48.600]  Потому что обратите внимание, что здесь на самом деле
[01:24:49.600 --> 01:24:50.600]  можно было сказать что-то более аккуратное,
[01:24:51.600 --> 01:24:52.600]  если вот тут произошло равенство,
[01:24:53.600 --> 01:24:56.600]  то мы просто типа h.back++ говорим.
[01:24:58.600 --> 01:25:01.600]  Просто, а если произошло, если тут вот...
[01:25:04.600 --> 01:25:05.600]  А, кстати, не правильно написал.
[01:25:07.600 --> 01:25:08.600]  Неравно, да.
[01:25:09.600 --> 01:25:10.600]  Да, кстати, неравно.
[01:25:11.600 --> 01:25:12.600]  И тут надо отклицать на значку.
[01:25:15.600 --> 01:25:17.600]  То есть тогда, если тут произошло неравенство,
[01:25:18.600 --> 01:25:20.600]  то надо просто попушбэкать предыдущее число
[01:25:21.600 --> 01:25:22.600]  и прибавить к нему идею ничего.
[01:25:23.600 --> 01:25:25.600]  И тогда, на самом деле, вот в этих вот двух фоликах
[01:25:26.600 --> 01:25:27.600]  уже необходимости не будет.
[01:25:28.600 --> 01:25:29.600]  Понятно, да?
[01:25:30.600 --> 01:25:31.600]  Ну там вопрос, конечно, за сколько у вас там будет back работать,
[01:25:32.600 --> 01:25:34.600]  но тут можно сразу h, конечно, пресайтить на n
[01:25:35.600 --> 01:25:37.600]  и хранить, где мы остановились, и назвать это callfc.
[01:25:38.600 --> 01:25:39.600]  Вот.
[01:25:40.600 --> 01:25:41.600]  То есть я думаю...
[01:25:42.600 --> 01:25:43.600]  Все эти операции работают за log n,
[01:25:44.600 --> 01:25:45.600]  поэтому, мне кажется, это оптимиза...
[01:25:46.600 --> 01:25:47.600]  То есть ускорение ощутимое должно дать.
[01:25:48.600 --> 01:25:49.600]  Так что вот это соответственно.
[01:25:49.600 --> 01:25:51.600]  Так что будете там и так писать им референс документ
[01:25:52.600 --> 01:25:53.600]  когда-нибудь, я надеюсь.
[01:25:58.600 --> 01:25:59.600]  Так, это ты что пишешь?
[01:26:00.600 --> 01:26:01.600]  Это вот это.
[01:26:02.600 --> 01:26:03.600]  Вот это?
[01:26:04.600 --> 01:26:05.600]  И что, попутно сравнивай с Emax?
[01:26:06.600 --> 01:26:07.600]  Да, потому что там больше оптимизации.
[01:26:08.600 --> 01:26:09.600]  Все в Emax-то?
[01:26:10.600 --> 01:26:11.600]  Да.
[01:26:12.600 --> 01:26:13.600]  А что в Emax-е?
[01:26:14.600 --> 01:26:15.600]  Там в меньшем сравнении процент по модерами.
[01:26:16.600 --> 01:26:17.600]  Ну я...
[01:26:17.600 --> 01:26:18.600]  Ну я сказал.
[01:26:19.600 --> 01:26:20.600]  Этих можно исправиться вообще.
[01:26:21.600 --> 01:26:22.600]  Ну просто...
[01:26:23.600 --> 01:26:24.600]  Они там прям...
[01:26:25.600 --> 01:26:26.600]  Ну как же интересно.
[01:26:27.600 --> 01:26:28.600]  У меня этим реализация чуть привычнее.
[01:26:29.600 --> 01:26:30.600]  Тут, правда, c конечно, но это можно поправить.
[01:26:31.600 --> 01:26:32.600]  Ух ты.
[01:26:33.600 --> 01:26:34.600]  А, она прям совсем минималистичная.
[01:26:35.600 --> 01:26:36.600]  Это цикл.
[01:26:37.600 --> 01:26:38.600]  А, вот это вот все.
[01:26:39.600 --> 01:26:40.600]  Один h, а...
[01:26:42.600 --> 01:26:43.600]  Ну вот да.
[01:26:44.600 --> 01:26:45.600]  А, вот это я имел в виду, да, что h.
[01:26:45.600 --> 01:26:46.600]  А, ну да, то есть h называется...
[01:26:47.600 --> 01:26:48.600]  Тут h-то центр.
[01:26:50.600 --> 01:26:51.600]  Ага.
[01:26:55.600 --> 01:26:57.600]  Нет, вот я про это и говорю, что на самом деле...
[01:26:58.600 --> 01:27:00.600]  То есть на самом деле, минус-минус h можно...
[01:27:01.600 --> 01:27:06.600]  То есть я говорю, что вот это вот h можно отдельно не насчитывать, а можно там вот при вычислении c-шек сразу считать.
[01:27:08.600 --> 01:27:09.600]  Чего?
[01:27:10.600 --> 01:27:11.600]  Ну что такое?
[01:27:12.600 --> 01:27:13.600]  Это нормально.
[01:27:13.600 --> 01:27:14.600]  Ну это над множество c-шек, все нормально.
[01:27:15.600 --> 01:27:20.600]  Нет, может там есть какие-то вещи, которые все-таки были всяко все-все отменены, но...
[01:27:21.600 --> 01:27:23.600]  Ну там типа эти же было что-то.
[01:27:24.600 --> 01:27:25.600]  Так, ну ладно.
[01:27:26.600 --> 01:27:32.600]  Да, соответственно, да, можно подоптимизировать, но как бы вот на уровне идей по камере разобраться можно.
[01:27:33.600 --> 01:27:34.600]  Ну ладно, кажется, на этом...
[01:27:35.600 --> 01:27:39.600]  Так, ну в общем, на этом, кажется, заканчивается примерно все, что я хотел сказать про сутоксный массив.
[01:27:40.600 --> 01:27:43.600]  Так что теперь можно пойти кушать и соответственно...
[01:27:44.600 --> 01:27:48.600]  И тогда после этого мы тогда перейдем к сутоксному массовому.
