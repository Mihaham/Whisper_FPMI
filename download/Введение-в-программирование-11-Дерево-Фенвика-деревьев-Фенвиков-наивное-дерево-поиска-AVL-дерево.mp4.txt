[00:00.000 --> 00:10.680]  и так значит мы в прошлый раз не до разобрались с деревом фенрика давайте сейчас мы обсудим
[00:10.680 --> 00:16.240]  дерево фенрика деревья фенрика деревьев
[00:16.240 --> 00:33.240]  значит задача будет у нас такая есть на плоскости много точек n точек
[00:33.240 --> 00:42.080]  n точек координаты которых ну скажем там целые от 0 до 10 к 9 от 0 до 10 к 9 и по х и по
[00:42.080 --> 00:47.040]  экрику причем эти точки откуда-то заранее известны они фиксированы и сами точки не
[00:47.040 --> 00:50.840]  меняются меняется только числа которые в них написан значит в каждой точке написано под
[00:50.840 --> 00:58.040]  число там 1 2 3 4 и так далее и могут меняться только эти числа соответственно запрос у нас есть
[00:58.040 --> 01:04.080]  двух типов первый запрос это изменение а этого то есть по какой-то точке по этой точке нужно
[01:04.080 --> 01:11.040]  поменять то число которое в ней написано и второе это нужно найти сумму аитох в прямоугольнике
[01:11.040 --> 01:16.560]  прямоугольник значит вам задается вот такой прямоугольник то есть вам фиксируется какой-то
[01:16.560 --> 01:23.600]  правый верхний угол его координатами там не знаю ну не знаю x и y x и y вот вам нужно смотреть все
[01:23.600 --> 01:29.800]  что находится левее и ниже то есть вот какой-то прямоугольник и сложить ну вывести сумму всех
[01:29.800 --> 01:35.320]  ашек по всем точкам которые попадают в это прямоугольник это вот задача из контеста давайте
[01:35.320 --> 01:41.360]  обсудим как вы решать значит давайте по запросу изменения в точке сумма на прямоугольник мы сразу
[01:41.360 --> 01:46.800]  скажем что какой-нибудь обычный двумерный фенвик как мы в прошлый раз делали будет работать слишком
[01:46.800 --> 01:52.600]  долго но как минимум потому что у вас тут там координаты 10 9 10 9 и фенвика строй там ну мы не
[01:52.600 --> 01:58.720]  можем построить массив 10 9 на 10 9 и даже если там сжать координаты считать что все координаты там
[01:58.720 --> 02:04.560]  до до n до 10 5 примерно то все равно будет слишком много мы не можем завести массив размера n
[02:04.560 --> 02:10.840]  это нужно что-то другое начать но первый шаг сделан таким же мы сожмем координат сожмем
[02:10.840 --> 02:19.840]  координат что это значит это значит что давайте мы сохраним все возможные иксы и все возможные
[02:19.840 --> 02:25.040]  игреки по исходным точкам вот есть у нас н точек соответственно каждый из них дает какой-то
[02:25.040 --> 02:31.440]  икс и какой-то игрек значит заводить заведем там массив сортир x заведем массив сортир y и
[02:31.440 --> 02:37.320]  соответственно здесь будет какие-то n чисел n ординат наших точек и здесь тоже n чисел n
[02:37.320 --> 02:44.080]  продам здесь значит абсцессы да в смысле координаты по их сумм по их сумм здесь ординаты координата по
[02:44.080 --> 02:49.800]  ику вот значит мы их все сваливаем в 1 в один вектор потом его сортируем юника я кажется про это
[02:49.800 --> 02:54.160]  уже рассказывал так же мать координаты когда мы обсуждали различия между онлайн подходом и
[02:54.160 --> 03:00.560]  оффлайн к решению всяких задач значит паспорт цифровали про юникари то есть удалили дубликаты
[03:00.560 --> 03:06.240]  теперь у них как бы ну все возможные уникальные иксы игреки которые встречаются в принципе в множестве
[03:06.240 --> 03:13.840]  точек и тогда каждый исходный x мы можем занять на номер этого x в массиве сортить номер в
[03:13.840 --> 03:22.080]  сортит но то же самое сыграть игрек номер в этом массиве номер сортит от игрек это значит
[03:22.080 --> 03:26.360]  сортировки всякие бин поиски дашь бы понять где число находится высортированном массиве на
[03:26.360 --> 03:37.680]  каком месте вот это все это делается зенлогом вот дальше сделаем следующее дальше мы заведем
[03:37.680 --> 03:45.120]  дерево фенвиков по дереву фенвика деревья фенвика то есть вот есть у меня моя плоскость мы
[03:45.120 --> 03:49.360]  понимаем что раз нажали координаты то по сути все координаты у нас не больше чем n не больше
[03:49.360 --> 03:54.480]  чем и здесь не больше чем и по иксу и по игреку мы нажали да что у нас все различных координат не
[03:54.480 --> 03:59.360]  больше чем n поэтому и номера в этом массиве все не больше чем n дальше вспоминаем как работает
[03:59.360 --> 04:08.080]  фенвик он для каждой точки и для каждого икса по сути считает f от и считает f от и такое число
[04:08.080 --> 04:15.480]  меньше и правное и по сути мы хотим вот создать структуру которая целиком отвечает полоске вот
[04:15.880 --> 04:22.160]  вот этой вот полоски все что внутри мы создадим для этого отдельную свою структуру то есть для
[04:22.160 --> 04:32.640]  каждого и для каждого и заведем отдельную структуру которая будет на самом деле еще
[04:32.640 --> 04:40.760]  одним деревом фенвика но пока что давайте отдельную структуру структуру которая хранит все
[04:40.760 --> 04:53.240]  точки попадающие вот эту полосу которая хранит все точки в полосе ну когда у нас икс лежит в
[04:53.240 --> 04:58.880]  отрезке от f от и до и но это вот я просто датчик честно рисовал вот это вот полоса
[04:58.880 --> 05:05.320]  это вот полоса но точнее здесь как бы будет не икс да а ну давайте я здесь напишу что-то
[05:05.320 --> 05:10.520]  номер икса номер точки потому что когда мы все посортировали потом перенумеровали
[05:10.680 --> 05:15.040]  точку давайте их перенумеруем так что они идут порядка застанем иксов и соответственно вот это
[05:15.040 --> 05:19.280]  вот и это номер точки то есть у меня сейчас координаты по иксу это тоже самое что номер
[05:19.280 --> 05:29.600]  точки вот хорошо значит мне нужно завести структуру которая хранит все точки вот в
[05:29.600 --> 05:36.960]  этой вот вот в этой полосе в этой полосе и эта структура будет дерева фенника структура тоже
[05:36.960 --> 05:42.800]  еще одна внутри дерева фенника деревом фенника и так смотрите получилось что прям garlic for
[05:42.800 --> 05:47.880]  каждого и у меня есть отрезок дерева фенника вот то есть мне есть дерево фен肥 капу иксам
[05:47.880 --> 05:53.280]  вот starting поэтому это и progressing да для каждого ей из отрезок обратно compatibility вот вся вот
[05:53.280 --> 06:00.200]  этого полоса будет храниться еще одном дирline фанды то есть не будет firing 1 дир Amendir
[06:00.200 --> 06:06.560]  для каждого и свою дереву поэтому назвать дерево фенрика деревья фенрика потому что
[06:06.560 --> 06:12.800]  каждый элемент внешнего дерева это одно внутреннее дерево фенвика. Ну а дальше, что у нас
[06:12.800 --> 06:16.360]  будет дерево фенвика вот здесь? Мы понимаем, что это какая-то полоса, что здесь есть какие-то
[06:16.360 --> 06:21.240]  точки, какие-то точки исходного множества. Ну и давайте теперь эти точки посортируем по у.
[06:21.240 --> 06:31.720]  Сорт по у. Ну и соответственно, если здесь точек, скажем, мало, здесь всего 6 точек,
[06:31.720 --> 06:39.680]  тогда понятно дело, что не нужно заводить здесь дерево фенвика на n элементов, потому что как у
[06:39.680 --> 06:46.240]  нас работал двумерный фенвик, он просто для каждого и заводил по сути дерево фенвика размера n,
[06:46.240 --> 06:51.280]  когда у меня была такая плотная кабличка, в каждой точке что-то написано. А теперь у меня в этой
[06:51.280 --> 06:55.960]  полосе может быть очень мало точек, их там может быть далеко-далеко нет, одна-две точки,
[06:55.960 --> 07:00.800]  ну может быть сколько-то мало. Вот, тогда давайте мы заведем дерево фенвика ровно такого размера,
[07:00.800 --> 07:06.040]  сколько точек в этой полосе. То есть вот здесь есть 6 точек, давай тогда их перенумеруем, скажем,
[07:06.040 --> 07:09.320]  что вот эта первая, эта вторая, эта третья, четвертая, пятая, шестая, то есть пронумеровали
[07:09.320 --> 07:15.320]  снизу вверх в порядке возрастания у. И построим дерево фенвика вот на этих 6 элементах. То есть
[07:15.320 --> 07:24.120]  дерево фенвика будет размера 6. Ну и в этом дереве мы храним как раз вашу. А ведь вот мы, когда будем
[07:24.120 --> 07:35.280]  вот новые номера давать, это же будет за отдельное время занимать. То есть мы по факту... Внутри каждой
[07:35.280 --> 07:41.280]  полосы мы будем сортировку делать, да. Ну да, но просто сейчас... Мы проанализируем еще время работы.
[07:41.280 --> 07:47.160]  Окей. Вот, значит, мы для каждого и действительно рассматриваем все вот эти вот точки, которые
[07:47.160 --> 07:52.440]  попадают в полоску, от f от i до i, сортируем их по игре по, строим на них дерево фенвика. А дерево
[07:52.440 --> 07:56.840]  фенвика обычная update с точки суммы на отрезке. Вот прям самая простая. Даже не на отрезке, а на
[07:56.840 --> 08:01.600]  префекции. Потому что раз у меня такой прямоугольник... Давайте я вернусь. Значит, у меня вот такой
[08:01.600 --> 08:06.280]  прямоугольник, который просто... Ну, по сути, вот эта вот правая верхняя граница. Тогда отвечать на
[08:06.280 --> 08:11.120]  запрос мы будем, как всегда. Мы, значит, разбиваем отрезок по иксу на вот эти вот... Ну, на такие
[08:11.120 --> 08:16.080]  блоки, да, по, собственно, как мы прыгали в дерево фенвика по иксу. Соответственно, каждый блок
[08:16.080 --> 08:21.480]  это какая-то вот такая вертикальная полоса. Значит, первая полоса, вторая полоса и вот третья полоса.
[08:21.480 --> 08:27.960]  Дальше мне нужно в каждой полосе узнать сумму значений в точках, которые находятся не выше, чем у.
[08:27.960 --> 08:33.800]  Вот мы проводим такую штуку. Соответственно, остаются какие-то точки. Остается какой-то префикс в каждой
[08:33.800 --> 08:38.040]  полосе, да, потому что мы ограничили, ну, как бы сверху все координаты. То есть остаться префикс в
[08:38.040 --> 08:42.800]  каждой полосе, но мне нужна сумма на префикс. То есть внутреннее дерево фенвика, оно обычное
[08:42.800 --> 08:47.200]  дерево, update с точки и сумма на префиксе, как вот у нас было в самом простом варианте в прошлый раз.
[08:47.200 --> 08:56.440]  Изменения в точке и сумма на префиксе. Вот. Теперь, значит, что, что с синтрофикой? Как построить такую
[08:56.440 --> 09:08.240]  структуру? Построение, построение вот этого фенвика фенвиков. Ну, мы в самом начале сказали,
[09:08.240 --> 09:12.960]  что у нас есть сортировка и потом всякие бим поиски, чтобы перенумеровать все наши точки.
[09:12.960 --> 09:20.400]  Перенумеровать все наши точки. Это NLogin. Это всякие сортировки, перенумерование и так далее.
[09:20.400 --> 09:29.320]  Дальше. Мне нужно для каждого и посмотреть, сколько есть точек в этом отрезке, да, то есть
[09:29.320 --> 09:35.760]  пройтись по всем точкам с номерами от f от i до i и их все посортировать. То есть, по сути, у меня,
[09:35.760 --> 09:39.600]  ну, как минимум, мне нужно в каждой полосе сделать такую сортировку, а потом еще построить дерево
[09:39.600 --> 09:47.600]  фенвика. Значит, за сколько, вот если здесь ка точек, если здесь ка точек, где k это и минус f от
[09:47.600 --> 09:53.200]  и плюс один, да, потому что, ну, как раз, да, если мы, если мы ограничиваемся по иксу здесь ишкой,
[09:53.200 --> 09:57.960]  а здесь f от и, то количество точек в этой полосе ровно вот такое, потому что мы вырезаем какой-то
[09:57.960 --> 10:05.440]  отрезок. Левый начало этого отрезка имеет номер f от и, правый конец имеет номер i. Тогда, соответственно,
[10:05.440 --> 10:10.080]  в этом, в этой полосе ровно столько точек, ровно ка точек. Ну и сортировку мы делаем за колобка.
[10:10.080 --> 10:19.280]  Сортировка за колобка. Значит, уточню, что это сортировка точек внутри полосы по y.
[10:19.280 --> 10:31.920]  Сейчас-то мы же еще должны будем по массиву всему пройтись и эти точки как бы выделить в
[10:31.920 --> 10:42.880]  отдельный массив или как? Смотрите, да, да, да, смотрите, еще раз, вот есть у меня, смотрите,
[10:42.880 --> 10:49.360]  у меня есть по сортированной точке p0, p1, p2 и так далее, pn-1. Они посорчены по иксу, то есть здесь
[10:49.360 --> 10:57.760]  x минимальный, здесь x следующий, x второй и так далее, xn-1. Дальше, я для каждого i смотрю на
[10:57.760 --> 11:05.280]  p0 и на p с инексом f0. Выделяю, создаю новый вектор, создаю новый массив, по сути, копирую в него
[11:05.280 --> 11:11.520]  все вот эти элементы, все вот эти точки и сортирову его по y. То есть, я вычленил какой-то отрезок из
[11:11.520 --> 11:16.320]  старого моего массива, посортил его по y и теперь на этом массиве буду строить дерево фингрика.
[11:16.320 --> 11:20.840]  Ну если, соответственно, у меня есть вот эти вот ка точек, они посортированы и на них я в этом
[11:20.840 --> 11:25.960]  порядке строю дерево фингрика. Дерево фингрика строится там, ну либо закат, мы с вами умеем строить
[11:25.960 --> 11:36.720]  дерево фингрика за к, либо за колобка. А можно вопрос? Да. А почему не может быть больше точек?
[11:38.720 --> 11:44.760]  Что значит не может быть больше точек? Здесь ка точек. Внутри отрез к, почему k это i-f, а ты плюс 1?
[11:44.760 --> 11:54.840]  Потому что мы определяем для себя, что такое полоса соответствующая i-те вершине. Вот у меня есть
[11:54.840 --> 12:06.120]  i-t точка, есть точка с индексом f, а ты. Тогда давайте мы скажем, что в полосе мы просто возьмем
[12:06.120 --> 12:12.240]  массив вот с этой точки, вот до этой и будем говорить, что в этой полосе лежит ровно вот эти
[12:12.240 --> 12:22.600]  вот точки. Мы просто так определяем. Здесь ровно ка точек, потому что мы так себе положили.
[12:22.600 --> 12:28.600]  Возможно вас смущает то, что на этих сторонах могут быть еще точки, скажем, вот здесь может
[12:28.600 --> 12:33.280]  быть и плюс первая точка, и ее как бы возможно надо бы учесть. Но так вот нет, давайте ее не будем
[12:33.280 --> 12:38.000]  учитывать, давайте не будем ее относить к этой полосе. Давайте скажем, что в полосе лежат как бы
[12:38.000 --> 12:42.880]  ну только точки во внутренности, ну и вот те, которые собственно с нужными номерами, у которых
[12:42.880 --> 12:49.040]  номер от f и до i. А если точка даже в полосе, но имеет неплохой номер, неподходящий, то мы ее к
[12:49.040 --> 12:53.440]  нашей полосе относить не будем. Не, наверное, смущает то, что у нас полоса как бы зависит чисто от i,
[12:53.440 --> 12:58.600]  но при этом в эту полосу можем сложить хоть все элементы. Ничего в этом страшного нет, да, такое
[12:58.600 --> 13:07.160]  может быть. Для каждого i у нас своя полоса, для каждого i своя полоса. Так вот, вы мне не даете
[13:07.160 --> 13:12.640]  проанализировать все. Я писал в дарит, сейчас будем мерить 8 точек, сколько у нас всего используется,
[13:13.120 --> 13:19.200]  сколько времени. Для каждого i у нас своя полоса, свое дерево на каждой полосе. Так вот,
[13:19.200 --> 13:27.200]  значит, какое время работы? Получается, что время работы такое. Время построения. Время построения.
[13:27.200 --> 13:36.480]  Это n log n, вот это вот, да, изначальная сортировка. Плюс сумма по всем i k i t log k i t,
[13:36.480 --> 13:45.360]  ну, где k i t равно i минус f at плюс 1. То есть, да, для каждого i своя полоса. Там какое-то определенное
[13:45.360 --> 13:50.000]  количество вершин. В i-той полосе k i t вершин. Ну, соответственно, чтобы все посортить и построить
[13:50.000 --> 14:01.760]  дерево, мне нужно k i t, n log k i t операции. Ольга, по определению. В полосе точек ровно столько
[14:01.760 --> 14:06.800]  по определению. Потому что в i-той полосе мы рассматриваем все точки, начиная с f i до i.
[14:06.800 --> 14:13.040]  Ну, сколько чисел в отрезке, сколько целых чисел в отрезке от f i до i? Ну, вот ровно i минус f at
[14:13.040 --> 14:20.240]  плюс 1. То есть, у нас по одной координате может быть две точки. То есть, дефиксируем их координату,
[14:20.240 --> 14:25.520]  на этой полосе может быть две точки. Вот я здесь говорил. Возможно, такое будет. Но, еще раз,
[14:25.520 --> 14:30.800]  мы тогда, мы их просто не относим к нашей полосе. То есть, смотрите, вот есть у меня, допустим, есть
[14:30.800 --> 14:36.320]  какая-то p и плюс первая точка, которая как бы формально тоже лежит в этой полосе. Но мы ее тогда не
[14:36.320 --> 14:40.960]  будем сюда относить, потому что у нее слишком большой номер. То есть, в этой полосе у нас будут
[14:40.960 --> 14:48.520]  просто формально. В этой полосе лежат все точки, у которых номер не больше, чем i и не меньше,
[14:48.520 --> 14:53.840]  чем f at. Все, вот определение. То, что здесь происходит на границе, какие-то точки, у которых формально,
[14:53.840 --> 14:59.360]  которые лежат на этих границах, но у которых номер там меньше, чем f at или больше, мы просто
[14:59.360 --> 15:03.960]  говорим, что они в этой полосе не лежат. Вот просто так по определению положили. Номер от координата x?
[15:03.960 --> 15:14.240]  Вот не совсем. Не совсем, да. Номер это после сортировки. Да, вот то, как мы их тут посортировали,
[15:14.240 --> 15:19.360]  какой номер здесь? Такой номер. Иксы могут совпадать, но, типа, у них могут различаться
[15:19.360 --> 15:26.240]  номера. И вот мы смотрим, по сути, на номера. Иксы нам нужны только для сортировки. Так вот,
[15:26.240 --> 15:33.720]  значит, как проанализировать вот такую штуку? Сейчас, одну секунду.
[15:39.600 --> 15:48.440]  Не, ну мы можем это внести, видимо, под один этот самый алгоритм. Давайте я сделаю, значит,
[15:48.440 --> 15:53.440]  можно сделать следующее. Значит, мне сейчас нужно оценить вот такую сумму. И там от 0 до
[15:53.440 --> 16:01.760]  1. Каито лог каито. Давайте я каждое каито, вот алгоритм каито, оценив сверх алгоритмом n просто.
[16:01.760 --> 16:08.840]  Каито на алгоритм m. Ну, потому что понятно, что каито не больше, чем n. В каждой полосе не больше,
[16:08.840 --> 16:13.680]  чем n вершин. Не больше, чем n точек. А дальше, значит, мне нужно, по сути, оценить сумму всех каитов.
[16:13.680 --> 16:22.040]  Ну, смотрите, сумма всех каитов. Это можно написать по-другому. Это сумма по всем жи,
[16:22.040 --> 16:30.800]  сожитых, где сожитое, это количество полос, в которые попала житая точка.
[16:30.800 --> 16:43.600]  Количество полос, в которые попала житая точка. Это такой как бы двойной подсчет. Здесь у меня
[16:43.600 --> 16:49.120]  написано, сколько суммарно есть точек во всех полосах. То есть сумма по полоскам,
[16:49.120 --> 16:54.000]  сколько точек в полоске. А здесь, наоборот, сумма по точкам, в скольких полосках лежит точка.
[16:54.000 --> 16:59.360]  Сумма по жи, сожитая. В скольких полосках лежит каждая точка. Значит, понятно, что это одно и то же.
[16:59.360 --> 17:06.280]  Вот, но это уже считается просто. Мы с вами знаем, что c житое не больше, чем лог n. Потому что что
[17:06.280 --> 17:15.080]  значит, что c житое лежит в какой-то полосе. Значит, житая точка лежит в этой полосе,
[17:19.080 --> 17:24.560]  если только если f и меньше равно ж, меньше равно и. По определению, мы с вами сказали,
[17:24.560 --> 17:30.440]  что в этой полосе лежат ровно такие точки, у которых номера больше равны, чем f и меньше равны,
[17:30.440 --> 17:36.160]  чем i. Значит, получается, что житая точка лежит в этой полосе ровно при выполнении такого условия.
[17:36.160 --> 17:42.960]  Но мы с вами в прошлый раз доказывали, что все i удовлетворяющие вот этому условию, точнее,
[17:42.960 --> 17:47.040]  наоборот, все i удовлетворяющие вот такому условию при фиксированном жи. Мы знаем,
[17:47.040 --> 17:55.800]  как они получаются. И это жи, а потом жио-джи, жио-джио-джи и так далее. Это мы доказывали в прошлый раз,
[17:55.800 --> 18:00.000]  что если у меня вот это вот фиксировано, а я хочу найти количество i таких, что выполняется вот этого
[18:00.000 --> 18:05.040]  двойного неравенства, тогда количество таких i — это максимум логарифм. И они все получатся как
[18:05.040 --> 18:11.640]  навешивание функции ж на жи несколько раз. Вот это вот жи, жио-джи, жио-джио-джи и так далее,
[18:11.640 --> 18:17.120]  несколько раз, пока мы не упрёмся до конца массива. Поэтому все вот эти вот штуки максимум логарифм,
[18:17.120 --> 18:22.680]  то есть каждая точка участвует максимум в логарифме полос. Ну, поэтому суммарно размер всех полос
[18:22.680 --> 18:36.400]  максимум н логан. Поэтому эта сумма оценится всех в н логанах. Значит, вывод. Построение работает
[18:36.400 --> 18:54.440]  за n лог квадрат времени, n лог квадрат времени и n лог n памяти. Н лог n памяти именно потому,
[18:54.440 --> 19:00.120]  что каждая точка лежит максимум в логарифме полос. Значит, суммарно, да, суммарно размер всех
[19:00.120 --> 19:05.680]  полосок, а значит и суммарно размер всех деревьев фенника, он у меня n логан. Каждая точка максимум
[19:05.680 --> 19:10.600]  логарифме полос, значит суммарный размер всех полос, а значит и вообще суммарно, суммарная
[19:10.600 --> 19:16.240]  требуемая память, это n логан. Сколько точек умножить на сколько полос в полосах они лежат.
[19:16.240 --> 19:24.520]  Максимум n логан памяти. Вот. Хорошо, значит это мы построили. Ну, а дальше как отвечать на запрос?
[19:24.520 --> 19:33.120]  Ответ на запрос. Значит, приходит запрос какой-то x и y. Значит, первое, что мы делаем, это заменяем
[19:33.120 --> 19:45.400]  x на номер в сорте над x. Ну, точнее на наибольшее число меньше равное, чем x. Да, потому что,
[19:45.400 --> 19:53.600]  вот смотрите, если есть у меня какой-то запрос, вот такой вот x и y. Вот есть запрос x и y. Мне нужно
[19:53.600 --> 19:59.440]  как бы посчитать сумму h с точек, которые лежат левее и ниже вот этой вот вершинки, ну, вот этой
[19:59.440 --> 20:05.520]  точки x и y. Тогда понятно, что x можно уменьшать до тех пор, ну, вот смотрите, я могу его вот так
[20:05.520 --> 20:12.480]  вот уменьшать, пока здесь не будет лежать первая точка. То есть вот так я его уменьшу, соответственно,
[20:12.480 --> 20:17.080]  до тех пор, пока на вот этой вот вертикальной прямой не начнется лежать одна точка. То есть я могу
[20:17.080 --> 20:23.280]  вот этот x так уменьшить, чтобы он был одним из элементов в сорте над x. Ну и так его можно уменьшить,
[20:23.280 --> 20:30.680]  то есть просто я сужаю область, вырезаю там какую-то полоску, в которой нет ни одной точки. И так дохожу
[20:30.680 --> 20:34.360]  до первой, просто точки, которые соответствуют наибольшему числу, которая не больше, чем x. Да,
[20:34.360 --> 20:40.680]  просто ближайшее слева число, вот оно будет здесь. Это тоже делается бинпоиском, тоже делается
[20:40.680 --> 20:46.000]  бинпоиском. Мне нужно массиве найти наибольшую числу, не больше, чем какой-то x. Ну и то же
[20:46.000 --> 20:54.040]  самое делаем с y. То же самое делаем с y, как-то его уменьшаем. Эту горизонтальную полоску
[20:54.040 --> 21:02.680]  превышаем вот в эту. Наша новая x вот здесь. Ну а дальше, что у меня есть? Мне нужно за логарифом,
[21:02.680 --> 21:12.680]  давайте перерисую картинку. Есть наши точки. Есть какой-то такой запрос, например. Ну конечно,
[21:12.680 --> 21:19.600]  есть там точки где-то выше и правее, и так далее. Значит, вот эта точка x, да, номер x. Тогда я
[21:19.600 --> 21:27.400]  просто опять, как всегда, разбиваю мой запрос по x. Как мы это всегда делаем в зере Феллика,
[21:27.400 --> 21:33.200]  то есть это f от x, это f от x минус 1, да, это соответственно f от f от x минус 1, ну и так далее.
[21:33.200 --> 21:40.680]  Короче, мы разбиваем по x на такие полоски. Разбиваем по x на вот такие полоски. Ну а дальше
[21:40.680 --> 21:45.800]  внутри каждой полоски у меня по сути запрос к одномерному Феллику. У меня есть текущие,
[21:45.800 --> 21:51.280]  значит, внутри каждой полоски. У меня есть список точек, которые в ней лежат. Список точек,
[21:51.280 --> 21:55.440]  которые в ней лежат. Дальше я могу опять с помощью еще одного вложенного бинпоиска внутри
[21:55.440 --> 22:01.200]  определить, как бы, какой максимальный номер точки меня интересует. То есть скажем, вот здесь я
[22:01.200 --> 22:07.480]  вижу y какое-то, да, ограничение сверху. Дальше тогда мне нужно определить первые сколько точек лежат ниже,
[22:07.480 --> 22:12.320]  чем этот y. Но это опять бинпоиск. Если у меня есть внутри вот здесь вот посортированный список
[22:12.320 --> 22:16.760]  всех точек, внутри каждой полосы, то мне нужно просто с помощью бинпоиска определить опять-таки
[22:16.760 --> 22:22.600]  ну самую высокую точку, которая лежит не выше, чем y. То есть вот она будет вот в этой полосе.
[22:22.600 --> 22:30.520]  Это будет 2y точка. Дальше в какой полосе? Вот в этой следующей. Это будет 2y точка. Да, ну короче,
[22:30.520 --> 22:35.800]  мы просто в каждой полосе определяем самую высокую точку не больше, чем y, не выше, чем y. Это
[22:35.800 --> 22:41.400]  еще один бинпоиск в каждой полосе. А потом еще за один логарифм отвечаем на запрос. То есть теперь
[22:41.400 --> 22:47.680]  мы уже понимаем, что внутри этого дерева Фенрика все точки осортированы по y, и мне нужна сумма на
[22:47.680 --> 22:55.720]  префиксе. Сумма на префиксе. Причем я понял на каком префиксе с помощью бинпоиска. Значит,
[22:55.720 --> 23:02.560]  в итоге у меня будет логарифм n полос, log n полос, в каждой полосе у меня бинпоиск плюс запрос к Фенрику.
[23:02.560 --> 23:10.960]  В каждой полосе бинпоиск, чтобы определить длину префикса, на котором мне нужно найти сумму,
[23:10.960 --> 23:20.320]  плюс запрос к Фенрику. Запрос к Фенрику. Ну и значит у меня лог раз будет выполняться что-то
[23:20.320 --> 23:25.200]  за логарифм. В итоге здесь будет лог квадрат. Лог квадрат на запрос.
[23:25.200 --> 23:36.240]  Лог квадрат на запрос. Если же приходит запрос второго типа, запрос изменения в точке, то мне в
[23:36.240 --> 23:40.800]  общем-то тоже нужно сделать что-то похожее. Мне нужно понять в каких полосках лежит данная точка.
[23:40.800 --> 23:47.080]  Вот пришла итая точка, мне нужно в ней поменять значение. Я хочу понять все такие х, что итая
[23:47.080 --> 23:53.680]  точка лежит в полоске для х, то есть и больше равной чем f от х, и меньше равной чем х. Но
[23:53.680 --> 23:57.880]  таких полосок тоже логарифм, мы их умеем с помощью Фенрика быстро находить. А потом в каждой полосе
[23:57.880 --> 24:02.480]  нужно определить, где эта точка итая находится, опять с помощью бинпоиска. У меня есть точка,
[24:02.480 --> 24:07.480]  мне нужно найти где находится в каждой полосе, какой у нее номер в каждой полосе за бинпоиск.
[24:07.480 --> 24:11.960]  И потом еще внутри для этого Фенрика сделать за логарифм update в точке. Изменение в точке.
[24:11.960 --> 24:19.600]  Получается тоже запрос за лог квадрат. У меня каждая вот эта точка, для которой происходит изменение,
[24:19.600 --> 24:24.800]  она лежит в логарифме полос. В каждой полосе нужно сначала запустить бинпоиск, чтобы понять на
[24:24.800 --> 24:30.920]  каком месте лежит эта точка итая точка. А затем нужно сделать один запрос изменения к Фенрику,
[24:30.920 --> 24:36.520]  который также обрабатывается за логарифм. В итоге логарифм полос, в каждой полосе обработка
[24:36.520 --> 24:44.200]  за логарифм. Получается запрос второго типа тоже за лог квадрат. Как мы выбираем количество полос?
[24:44.200 --> 24:52.240]  Полос мы не выбираем. Вы про то, что изменение в точке, правильно понимаю?
[24:52.240 --> 25:00.560]  Когда мы зажимаем прямоугольник справа.
[25:00.560 --> 25:13.640]  Когда мы зажимаем прямоугольник справа, как мы зажимаем или какие полосы получаются?
[25:13.640 --> 25:21.680]  Полоски. На полоске, как всегда, в Фенрике. Вот смотрите, есть у меня запрос к Фенрику.
[25:21.680 --> 25:26.840]  У меня есть точка здесь xy. Ну где xy, это уже теперь номеравку в порядке сортировки.
[25:26.840 --> 25:32.200]  Вот есть точка с номером x. Вспоминаем, как работает Фенрик. Он у меня берет, считает f от x.
[25:32.760 --> 25:46.960]  Логически это x и x плюс 1. Это первая полоса. Полоса контролирует все точки с номерами от fx до x.
[25:46.960 --> 25:52.560]  Это отдельная полоса, в ней хранится свой Фенрик. Мы делаем запрос к тому Фенрику.
[25:52.560 --> 25:59.120]  Дальше есть все остальные неучтеные точки. Самое правое из них имеет номер f от x минус 1.
[26:00.040 --> 26:06.720]  Вот эта точка имеет номер f от x минус 1. Самое правое неучтеное. Для нее тоже самое.
[26:06.720 --> 26:12.920]  Мы можем вычислить значение функции f, то есть f от f от x минус 1. И это будет еще одна очередная полоса.
[26:12.920 --> 26:20.920]  В ней тоже свой Фенрик. Делаем к нему запрос. В общем, так делаем, ровно так же, как у нас работает обычный Фенрик.
[26:21.720 --> 26:28.720]  Разбиваем вот этот вот отрезок по x на несколько отрезков, на несколько под отрезков в Фенрике.
[26:28.720 --> 26:34.720]  Каждый отрезок в этом разбиении – это будет полоса.
[26:34.720 --> 26:38.720]  Каждый из них свой Фенрик, свой запрос.
[26:38.720 --> 26:43.720]  А имеет смысл сразу же разгонять программу, то есть писать там всякие префиксные суммы и так далее?
[26:43.720 --> 26:48.720]  Или можно будет, не разгоняя ее, загнать без тайм-лимита?
[26:49.520 --> 26:55.520]  Так, префиксная сумма – это где? Где построение Фенрика за n, а не за k, а не за k?
[26:55.520 --> 26:57.520]  Ну, например.
[26:57.520 --> 26:59.520]  Это не обязательно нет.
[26:59.520 --> 27:01.520]  То есть программа зайдет?
[27:01.520 --> 27:09.520]  Должна, да. Но здесь не особо есть что разгонять, и вообще она должна заходить более-менее без проблем.
[27:09.520 --> 27:11.520]  Тут много всего надо хранить.
[27:11.520 --> 27:14.520]  Тут самое главное, что в каждой полосе вы храните две штуки.
[27:14.520 --> 27:19.520]  Вы, во-первых, храните список точек, ассортированных по Y, в этой полосе.
[27:19.520 --> 27:22.520]  А также храните дерево Фенрике на этих точках.
[27:22.520 --> 27:27.520]  Ну а дальше уже можно не особо там подмазывать, оно и так должно спокойно заходить.
[27:29.520 --> 27:37.520]  А у нас не сломается это дело, если у нас будет много точек с одной координатой X и разбросанных по Y?
[27:37.520 --> 27:39.520]  Ничего страшного не будет.
[27:39.520 --> 27:46.520]  Смотрите, наш анализ, ему было пофиг на то, какие X у этих точек.
[27:46.520 --> 27:49.520]  Главное, что мы их как-то посвященствовали.
[27:49.520 --> 27:57.520]  И понятие полосы, оно, возможно, довольно глупо будет смотреться, когда они все, грубо говоря, на одной вертикальной прямой лежат.
[27:57.520 --> 28:01.520]  Ну хорошо, тогда вместо полосы у нас будет просто какой-то отрезок точек от Итой до Фатты.
[28:01.520 --> 28:04.520]  А дальше весь анализ от этого не портится.
[28:04.520 --> 28:10.520]  То есть все равно отрезок по Иксан, опять все равно распадается на логарифм отрезков Фенрике.
[28:10.520 --> 28:14.520]  И в каждом отрезке у меня хранится свое дерево Фенрике, и там тоже логарифм.
[28:14.520 --> 28:19.520]  Я имею в виду то, что у нас в одном из деревьев Фенрика тогда будет очень много данных.
[28:19.520 --> 28:23.520]  То есть почему у нас не проходит Фенрик?
[28:23.520 --> 28:27.520]  Почему нам нужен Фенрик Фенриков, а не проходит двумерный Фенрик еще раз?
[28:27.520 --> 28:32.520]  Смотрите, мы знаем, сколько точек в каждом дереве Фенрика.
[28:32.520 --> 28:41.520]  И там дерево Фенрик, и Каи Те, точек, где Каи Те, Фатты минус 1, Фатты минус и плюс 1.
[28:41.520 --> 28:44.520]  Ну а мы анализ весь уже провели, мы знаем, сколько точек в каждой полосе,
[28:44.520 --> 28:49.520]  мы знаем, сколько суммарно у нас точек во всех полосах, н логн максимум.
[28:49.520 --> 28:51.520]  Ну поэтому, поэтому все хорошо.
[28:51.520 --> 28:55.520]  Ну допустим, Каи Те может быть 10 в пятый.
[28:55.520 --> 28:56.520]  Ну какое-то одно может.
[28:56.520 --> 29:01.520]  Ну может, например, если у вас И это там в двоечной записи 1, 1, 1, 1, 1, 2,
[29:01.520 --> 29:06.520]  тогда Фатты это видимо 0, 0, 0, 0, 0.
[29:06.520 --> 29:09.520]  И да, какое-то одно конкретное Каи Те может быть большим.
[29:09.520 --> 29:12.520]  Но суммарно сумма размеров всех полос, она не больше, н логн.
[29:12.520 --> 29:14.520]  Мы это с вами выше доказали.
[29:17.520 --> 29:24.520]  Я хотела точить, то есть у нас если мы берем максимальную корзинаку у всех точек, которые имеются,
[29:24.520 --> 29:28.520]  мы как раз так и делим эти полоски, используя Ф.
[29:31.520 --> 29:33.520]  Максимальную корзинаку, да, смотрите, мы берем максимальную корзинаку,
[29:33.520 --> 29:36.520]  которая меньше либо равна, чем параметр запроса.
[29:36.520 --> 29:42.520]  Вот если мне пришел какой-то х, ну параметр запроса, то я нахожу наибольшее число не больше, чем х.
[29:42.520 --> 29:47.520]  То есть у Каи Те есть разделение на полоски каждый раз как бы новое, то есть оно зависит от токсая.
[29:47.520 --> 29:51.520]  Конечно, для каждого запроса свое разбиение, конечно.
[29:52.520 --> 29:55.520]  Сейчас, а почему у нас все-таки квадрат?
[29:55.520 --> 30:01.520]  То есть, понятно, логан-полос, на допустим, логан-полос, каждый запрос в нем тоже логан, а бинпоиск куда девается?
[30:03.520 --> 30:08.520]  Внутри каждой полосы вы делаете бинпоиск один за логарифом и запрос к фенвику один тоже за логарифом.
[30:08.520 --> 30:10.520]  Но в итоге у вас в каждой полосе два логан.
[30:11.520 --> 30:15.520]  Полос логарифом, логарифом умножить на два логарифом, это два лог квадрата, это от лог квадрата.
[30:16.520 --> 30:21.520]  А чем хуже двумерный фенвик, чем вот фенвик фенвиков?
[30:21.520 --> 30:26.520]  Тем, что он потребляет n квадрат памяти, а эта штука потребляет n логан памяти.
[30:27.520 --> 30:29.520]  Ага, понял, спасибо.
[30:30.520 --> 30:32.520]  Окей, давайте двигаться дальше.
[30:34.520 --> 30:40.520]  Извините, если я не на все вопросы отвечаю, нам все равно нужно ехать дальше, иначе мы мало чего успеем.
[30:40.520 --> 30:43.520]  Значит, мы переходим к новой большой теме, это деревья поисков.
[30:43.520 --> 30:45.520]  Деревья поисков.
[30:45.520 --> 30:47.520]  Все, значит, мы закончили с...
[30:47.520 --> 30:53.520]  Что у нас было раньше? У нас были всякие кучи, потом дерево отрезков, дерево фенвика и спортстейбл.
[30:53.520 --> 30:55.520]  Вот это такие простые структуры.
[30:55.520 --> 30:57.520]  Значит, теперь деревья поисков.
[30:57.520 --> 31:03.520]  Дерево поиска – это такая структура, которая умеет отвечать, ну, как минимум, на следующие три запроса.
[31:03.520 --> 31:10.520]  Значит, оно должно хранить множество s в каком-то виде, хранить множество s.
[31:10.520 --> 31:15.520]  Ну, там чисел или каких-то других элементов. Я скажу, что чисел, например.
[31:16.520 --> 31:19.520]  И должно уметь отвечать на три запроса.
[31:19.520 --> 31:26.520]  Первое – это вставить какой-то x, то есть вставить x в s.
[31:27.520 --> 31:29.520]  Добавить новый элемент в наш s.
[31:29.520 --> 31:34.520]  Второе – это erase x, наоборот, удалить x из s.
[31:35.520 --> 31:37.520]  Удалить x из s.
[31:37.520 --> 31:41.520]  И третье, новое, чего у нас еще не было – это find x.
[31:41.520 --> 31:50.520]  Find x – сообщить, входит ли x в s.
[31:53.520 --> 31:55.520]  Вставить, удалить и проверить наличие.
[31:57.520 --> 32:00.520]  Ну, сразу давайте скажем, что мы храним именно множество, а не мульти множество.
[32:00.520 --> 32:03.520]  То есть у нас не будет никогда кратностей.
[32:04.520 --> 32:10.520]  И если, например, мне два раза приходит insert одного и того же, то есть insert x, insert x
[32:14.520 --> 32:18.520]  то я просто буду игнорировать дубликаты, то есть если мне два раза вставляют одно и то же число
[32:18.520 --> 32:21.520]  я буду вставлять только одно из них, а второе – буду игнорировать.
[32:22.520 --> 32:24.520]  Erase удаляет, собственно, единственное вхождение.
[32:24.520 --> 32:31.520]  То есть я, по сути, просто игнорирую дубликаты, но если мне приходит erase,
[32:31.520 --> 32:35.520]  то есть я считаю, что каждое число входит максимум один раз, и именно как бы у меня множество хранится.
[32:35.520 --> 32:42.520]  Если происходит инсерт повторный, то я его игнорирую. То есть повторный инсерт игнорируется,
[32:42.520 --> 32:46.520]  а erase работает как удаление износства, просто удаление элементов со всеми.
[32:46.520 --> 32:49.520]  Неважно, сколько у него там копии, мы считаем, что копия ровно одна.
[32:49.520 --> 32:56.520]  Давайте говорим, что работаем без повторяющихся элементов.
[32:56.520 --> 33:03.520]  Без повторяющихся элементов с. Вот что значит мы хотим от дерева.
[33:03.520 --> 33:06.520]  Еще есть опциональные запросы.
[33:09.520 --> 33:13.520]  Опционально. Можно научиться отвечать на запросы merge.
[33:13.520 --> 33:21.520]  Это как бы по двум деревьям. Давайте напишу, что есть множество s1, s2.
[33:21.520 --> 33:25.520]  Вам нужно их как бы объединить.
[33:29.520 --> 33:32.520]  S1 и S2 в одно новое множество.
[33:35.520 --> 33:39.520]  В одно новое множество. Есть у вас там одно множество чисел, другое множество чисел.
[33:39.520 --> 33:43.520]  Вам нужно их научиться объединять. У нас было такое в биномиальной куче.
[33:43.520 --> 33:47.520]  Когда у нас там есть две кучи, мы хотим их просто склеить, создать одну новую большую кучу,
[33:47.520 --> 33:50.520]  в которой лежат все элементы из двух предыдущих.
[33:50.520 --> 33:57.520]  Вот. И еще один опциональный запрос. Это запрос split.
[33:57.520 --> 34:00.520]  Split s, x.
[34:00.520 --> 34:04.520]  Это вот такое. Вам нужно множество s разбить на два.
[34:04.520 --> 34:07.520]  В первом из которых будут все числа не больше, чем x.
[34:07.520 --> 34:11.520]  А во втором все числа больше, чем x.
[34:11.520 --> 34:16.520]  Разбить s на s1. Это все y из s.
[34:16.520 --> 34:19.520]  Не больше, чем x.
[34:19.520 --> 34:22.520]  И на s2. Это все y.
[34:22.520 --> 34:24.520]  Sorry, не больше, чем x.
[34:24.520 --> 34:27.520]  И все y больше, чем x.
[34:27.520 --> 34:30.520]  Меньше либо равное и больше, чем x.
[34:30.520 --> 34:33.520]  Split одного множества на два кусочка по какому-то разделителю.
[34:33.520 --> 34:36.520]  Пришел x. Меньше либо равное влево. Больше ли встал.
[34:36.520 --> 34:38.520]  Например так.
[34:38.520 --> 34:41.520]  Вот что мы хотим на дерево поиска.
[34:42.520 --> 34:44.520]  Да, например, зачем это может быть нужно.
[34:44.520 --> 34:48.520]  Самый простой ответ какой-нибудь, это такой.
[34:48.520 --> 34:51.520]  Можно хранить какую-нибудь базу данных пользователей.
[34:51.520 --> 34:53.520]  Вот вы пишете какой-нибудь свой сайт. Вам нужно хранить там, не знаю.
[34:53.520 --> 34:56.520]  Когда каждый пользователь, в последний раз посещал ваш сайт.
[34:56.520 --> 35:00.520]  Соответственно, вам нужно для каждого.
[35:00.520 --> 35:05.520]  Не знаю. Для каждого ими пользователя хранить в последнее время, когда он посещал ваш сайт.
[35:05.520 --> 35:08.520]  Соответственно, какие у вас бывают запросы?
[35:08.520 --> 35:14.280]  то есть добавить кого-то нового пользователя, завести нового пользователя и там сказать, что он только что
[35:14.280 --> 35:18.920]  был на вашем сайте. Бывает операция RACE, когда, например, пользователь удаляет свой аккаунт и,
[35:18.920 --> 35:23.000]  соответственно, вы можете стереть всю информацию в нем и освободить память о вашем компьютере.
[35:23.000 --> 35:30.000]  И бывает операция FIND, значит, вы либо просто спрашиваете, есть ли такой пользователь у вас на сайте,
[35:30.000 --> 35:36.880]  либо там же, где и FIND, в общем-то, столь же просто вы можете понять, в какой последний момент времени он
[35:36.880 --> 35:43.720]  заходил. Если вы имя пользователя нашли в вашем дереве, в вашей структуре, то вы можете посмотреть,
[35:43.720 --> 35:47.840]  какое число с ним ассоциировано, в какое последнее время, в какой последний момент он
[35:47.840 --> 35:54.320]  заходил на ваш сайт, и вывести это число. Таким образом, вы можете знать, когда этот пользователь был
[35:54.320 --> 36:02.720]  последний раз на сайте. Почему это деревья поиска? Потому что мы будем в качестве вот этой структуры,
[36:02.720 --> 36:10.400]  которая умеет отвечать на все эти запросы, мы будем рассматривать двоичное дерево поиска.
[36:10.400 --> 36:16.240]  Двоичное дерево поиска. Значит, что такое двоичное дерево? Двоичное дерево – это когда у вас есть
[36:16.240 --> 36:24.360]  какой-то корень, root, корень, и затем у каждой решины есть максимум два сына. Есть левый сын,
[36:24.360 --> 36:29.520]  правый сын, есть левый сын, правый сын. Здесь, например, есть только левый сын, здесь есть,
[36:29.520 --> 36:33.720]  например, только правый сын, здесь есть тоже, например, только правый сын. У каждой решины,
[36:33.720 --> 36:55.480]  у каждой решины не более двух сыновей. Левый и правый. Вот. И это значит, что такое двоичное
[36:55.480 --> 37:00.040]  дерево? Потому что у каждой решины максимум два сына. Теперь, что такое дерево поиска? Дерево
[37:00.040 --> 37:06.760]  поиска – это такое дерево, которое удовлетворяет следующему условию, что если в вершине написано
[37:06.760 --> 37:13.000]  какое-то число х, то во всем левом под дереве все числа обязательно строго меньше, чем х. А во
[37:13.000 --> 37:20.240]  всем правом под дереве числа обязательно больше, чем х. Вот это дерево поиска. Дерево поиска. Еще раз,
[37:20.240 --> 37:24.480]  если в вершине написано какое-то число, то есть вершина соответствует какому-то пользу,
[37:24.480 --> 37:31.160]  именю пользователя, имени пользователя, тогда в левом под дереве, то есть все, что находится в
[37:31.160 --> 37:37.000]  левом сыне и ниже всего этого левого сына, все, что достижено из левого сына, там все имена пользователя
[37:37.000 --> 37:41.760]  или все числа меньше, чем х. Но если мы говорим про строки, то должно быть какое-то сравнение на
[37:41.760 --> 37:46.840]  строчках, например, лексик графическое. В каком-нибудь порядке строчки сравниваются. Вот слева все меньше х,
[37:46.840 --> 37:51.280]  а справа все больше х обязательно должны быть. Это дерево поиска. Ну, соответственно, если все это
[37:51.280 --> 37:55.480]  выполняется, то есть если у каждой вершины максимум два сына, а также для каждой вершины,
[37:55.480 --> 38:01.040]  если находится в ней число х, то слева должны быть только меньше х, справа только больше х.
[38:01.040 --> 38:09.600]  Если все это выполняется, то это двоичный дерево поиска. Вот, значит, ну, можно написать на основе
[38:09.600 --> 38:18.200]  такого определения наивное дерево поиска. Наивное дерево поиска. Давайте мы предложим,
[38:18.200 --> 38:23.760]  как можно реализовать все операции insert, erase и find в нашем деле. Давайте начнем
[38:23.760 --> 38:28.120]  с простого find. Вот скажите, пожалуйста, если у меня есть двоичное дерево поиска, как в нем
[38:28.120 --> 38:34.320]  проверить наличие какого-нибудь х, что есть вершина, в которой написано число х? Пускаться по веткам из корня,
[38:34.320 --> 38:39.920]  либо меньше, либо больше, в зависимости от значения корня. Да, все верно. Значит, давайте встанем в корень,
[38:39.920 --> 38:45.000]  посмотрим на то число, которое в нем написано, например, z. Ну, если z равно х, то мы сразу его
[38:45.000 --> 38:51.760]  нашли. Дальше, если z больше, чем x, то есть х меньше, чем z, тогда мне заведомо нужно идти влево,
[38:51.760 --> 38:57.880]  то есть если z больше, чем x, нужно идти влево и искать его в левом подделе, потому что справа
[38:57.880 --> 39:03.280]  лежат только еще большие числа, значит, туда идти нет смысла. И наоборот, если z меньше, чем x,
[39:03.280 --> 39:11.520]  то x, если где-то и находится, то только фраум поддели. Слева его быть не может. Вот, ну, собственно,
[39:11.520 --> 39:15.720]  поэтому их называют дерево поиска, потому что поиск здесь реализуется очень-очень просто. Нужно
[39:15.720 --> 39:22.680]  просто идти либо влево, либо вправо, в зависимости от сравнения x с текущей вершинкой z. Это работает
[39:22.680 --> 39:34.440]  за глубину. Работает за от аж, где аж глубина дерева. То есть просто длина максимального пути
[39:34.440 --> 39:43.320]  от корня до какой-то из вершин дерева. Максимальный путь сверху вниз. Теперь можно сделать инсерт,
[39:43.320 --> 39:52.920]  например. Инсерт x. А у нас же глубину можно сделать пополам, вроде бы, нет? Ну, это все равно будет
[39:52.920 --> 39:57.400]  для нас слишком плохо. У нас будет глубина логарифмическая. Когда мы сделаем хорошее дерево,
[39:57.400 --> 40:03.240]  у нас будет глубина логарифмическая. Но пока что давайте наивно дерево поиска, не задумываясь о том,
[40:03.240 --> 40:15.200]  насколько эффективно это работает. Как сделать инсерт в дерево? Ну, например. Нужно просто идти из корня и в пустое
[40:15.200 --> 40:19.720]  место вставить. Да-да-да, все верно. Значит, мы можем также вставить в корень. И давайте запустим,
[40:19.720 --> 40:25.360]  как бы, алгоритм, который мне искал бы х в дерево. Вот мы стоим в корне, тут написано число z, и мы
[40:25.360 --> 40:29.920]  понимаем, как бы, где должен лежать х. Он либо уже присутствует в дереве, ну скажем вот, не знаю,
[40:29.920 --> 40:35.640]  z больше, чем x. Он либо уже присутствует в дереве слева, либо, если его там нет, то нужно его туда
[40:35.640 --> 40:40.680]  подвесить. То есть мы переходим все равно в сына, и здесь пытаемся найти место для х. Ну и, в общем,
[40:40.680 --> 40:45.280]  так идем-идем спускаемся. И когда, например, в какой-то момент я понимаю, что мне нужно идти вправо,
[40:45.280 --> 40:50.520]  а справа никого нет, то есть нет правого сына, тогда мне нужно правого сына создать и сказать,
[40:50.520 --> 40:56.360]  что здесь написано число х. Это случается не бинарная куча с дополнительными операциями?
[40:56.360 --> 41:06.560]  Нет. Это не бинарная куча, потому что, ну, бинарная куча заполняется по слоям. У нее есть корень,
[41:06.560 --> 41:12.920]  у него, ну, то есть она обязательно имеет вот такую структуру, что там все есть вершинки на предыдущих
[41:12.920 --> 41:17.400]  уровнях, а последний заполнен может быть не полностью. А у нас такое будет совсем не всегда
[41:17.400 --> 41:21.920]  выполняться. У нас, ну, например, там может не быть правого сына вообще, то есть может быть
[41:21.920 --> 41:30.560]  какой-то такой, но это какая-то часть бинарной кучи, но, в общем, здесь аналогия не работает,
[41:30.560 --> 41:33.480]  и еще как минимум не работает, потому что в куче у нас не было вот такого соотношения,
[41:33.480 --> 41:38.120]  что слева лежат все меньше числа, справа все больше. Там было просто требование,
[41:38.120 --> 41:42.120]  что снизу все меньше-лево равны, а здесь другое требование, да, у меня есть как бы разделение
[41:42.120 --> 41:49.480]  налево и право, поэтому с кучей здесь аналогия, ну, такая, не очень работающая. Итак, значит,
[41:49.480 --> 41:56.400]  insert работает как будто бы просто find x, и если мы пытаемся пойти в несуществующего сына,
[41:56.400 --> 42:03.040]  то вот туда подвесим x в качестве листа. Значит, если x, ну, давайте скажем, что если x лежал в
[42:03.040 --> 42:13.720]  дереве, то мы ничего не делаем, лежал в дереве, то делать нечего, иначе подвешиваем x в качестве
[42:13.720 --> 42:24.400]  листа, значит, иначе x подвешиваем в качестве, ну, вот такой, да, висячей вершинки, в качестве
[42:24.400 --> 42:29.720]  листа, в качестве висячей вершинки к той вершине, откуда мы в последний раз пытались его искать,
[42:29.720 --> 42:34.760]  то есть вот мы стояли здесь, и здесь было там число меньше, чем x или меньше, чем x, то есть мы как бы
[42:34.760 --> 42:41.040]  должны пойти направо, но у этого игрока нет права сына, ну, тогда просто давайте x создадим новую
[42:41.040 --> 42:46.080]  вершинку вот здесь, и скажем, что x является новым правым сыном, подвешиваем в качестве листа.
[42:46.080 --> 42:53.640]  Ну, окей, как это реализовали. Проблема такой реализации, что если у нас будет куча инсертов,
[42:53.640 --> 43:01.600]  insert 1, insert 2, и так далее, insert n, например, вот в таком порядке, тогда дерево, которое мы построим,
[43:01.600 --> 43:09.880]  будет вот таким, просто вот такая вот ветка вправо, 1, 2, 3, и так далее, n, потому что есть у
[43:09.880 --> 43:15.360]  меня корень, 1, потом в качестве права сына я подвешу 2, потом еще 3 нужно подвесить сюда,
[43:15.360 --> 43:20.720]  4 в качестве права сына, и так далее, и так далее, у меня будет такой выраженный случай. Вот поэтому
[43:20.720 --> 43:27.760]  собственно это и есть наивное дерево поиска, оно может быть весьма неэффективным, но пока что
[43:27.760 --> 43:35.160]  мы про это не думаем. Давайте хоть как-нибудь реализуем, чтобы потом нам было проще. Хорошо,
[43:35.320 --> 43:46.400]  мы сделали insert. Дальше erase, erase x. Здесь тоже мы сначала попробуем его локализовать в дереве,
[43:46.400 --> 43:52.480]  попробуем найти. Если его нет в дереве, то делать ничего не нужно. Если x нет в дереве,
[43:52.480 --> 44:04.440]  то делать нечем. Иначе давайте мы предположим, что мы нашли наш x в дереве. Отличный случай
[44:04.440 --> 44:10.320]  был бы, когда у x нет детей, то есть нету ни левого по дерева ни правого по дереву, у него нет ни
[44:10.320 --> 44:15.400]  одного сына, ни лева ни правого. Тогда все очень просто, нужно просто забыть про существование x,
[44:15.400 --> 44:21.420]  и соответственно, если у x был какой-то родитель p, то сюда удалить вот эту стрелку. То есть если
[44:21.420 --> 44:28.080]  x был раньше левым сыном в какой-то вершинке, то теперь скажешь, что у нее нет левого сына. То
[44:28.080 --> 44:32.720]  есть идеальный случай, когда у x нет детей, у x нет graphs, x это лист, тогда нужно просто его
[44:32.720 --> 44:38.400]  и соответственно там отрезать какую-то ветку отрезать какой-то какой-то стрелку из таблиц
[44:38.400 --> 44:43.920]  вот если x лист
[44:45.920 --> 44:47.120]  то просто его отрезаем
[44:47.120 --> 44:49.960]  просто его отрезаем
[44:49.960 --> 44:59.120]  дальше если у x нет левого сына
[44:59.120 --> 45:09.320]  то мы можем сделать следующее вот смотрите был наш родитель p какой-то есть x и например у x нет
[45:09.320 --> 45:13.640]  левого сына у x есть только правое поддерево тогда мы можем просто вот это правое поддерево r
[45:13.640 --> 45:19.400]  переподвесить на место x то есть забыть про существование x и сказать что теперь картинка
[45:19.400 --> 45:26.080]  такая просто у старого p левым сыном ну то есть тем же сыном каким был x будет дерево r то есть
[45:26.520 --> 45:32.920]  все это дерево поднимаем наверх на на единичку про x забываем и переподвешиваем вот эту вот
[45:32.920 --> 45:39.560]  вершинку в качестве сына p вот это все будет хорошо да потому что здесь никаких конфликтов
[45:39.560 --> 45:45.640]  не будет здесь вот это дерево было пустой поэтому отсюда ничего торчать не будет ну и соответственно
[45:45.640 --> 45:52.320]  все все все сохранится все вершинки которые здесь были то есть ну вообще все вершины в этом
[45:52.320 --> 45:57.200]  поддереве были меньше чем п раз это был левый сын раз их был левым сыном ну тогда их можно
[45:57.200 --> 46:02.040]  подвесить чуть выше потому что они все равно меньше чем п можно подвести вот если у x нет левого сына
[46:02.040 --> 46:11.120]  можно просто правое поддерево подвесить на его место если же у x есть левый сын то давайте
[46:11.120 --> 46:25.520]  сделаем следующее теперь пусть у x есть левый сын пусть у x есть так сейчас есть
[46:27.800 --> 46:36.600]  я так хочу сейчас одну секунду ну да давайте сделаем то же самое что например если у x нет
[46:36.600 --> 46:42.160]  права сына пусть у x нет права сына тогда то же самое нужно переподвесить только левый сын есть
[46:42.160 --> 46:55.040]  только левый сын нет права в общем-то тогда картинка симметричная если у п есть какой-то
[46:55.040 --> 47:00.720]  родитель и есть у него только левый сына нет правого то здесь нет ничего просто или переподвесить
[47:01.200 --> 47:11.040]  и про x забыть самый тяжелый случай это когда у п есть оба сына и левый и правый есть оба сына
[47:11.040 --> 47:19.120]  и левый правый тогда мы не можем вот здесь проблема мы не можем просто удалить x и что-то здесь
[47:19.120 --> 47:24.240]  переподвесить мы не можем вот этот или сюда поднять да как бы потому что здесь будет правое
[47:24.240 --> 47:27.920]  поддерево и возможно здесь нарушится какие-то неравенства то есть я просто возьму какое-то
[47:27.920 --> 47:36.920]  число отсюда, помещу его сюда, то возможно оно будет... Сейчас. А, ну да, возможно у него просто и так было два сына, например,
[47:36.920 --> 47:43.920]  вот здесь было два сына, и мы как бы попытаемся к этой вершинке подвесить еще третьего сына. Но такого делать нельзя, у нас максимум два сына у каждой вершины.
[47:43.920 --> 47:51.920]  Поэтому как-то здесь просто переподвесить не получается. Решение будет таким. Давайте мы пойдем в правого сына,
[47:52.920 --> 48:09.920]  и найдем в нем самый маленький элемент, самое маленькое число. Находим Y, самое маленькое число в R.
[48:10.920 --> 48:17.920]  Это самое маленькое число находится очень просто. Нужно просто идти влево, пока есть левый сын. То есть вот мы стоим здесь.
[48:17.920 --> 48:23.920]  Если есть левый сын, пошли влево. Если есть левый сын, пошли влево. И так далее, и так далее, и так далее, пока есть левый сын.
[48:23.920 --> 48:30.920]  Легко понять, что мы таким образом действительно найдем минимальный элемент в дереве, потому что мы встали в корень этого дерева.
[48:30.920 --> 48:37.920]  Если меньшее число и существует, то оно точно лежит слева. Потому что слева лежит меньшее число, справа большее.
[48:37.920 --> 48:44.920]  То есть если число меньшее, чем вот этот корень есть, то оно слева. То же самое тут. Если меньшее число и существует, то оно слева.
[48:44.920 --> 48:50.920]  Ну и так далее, и так далее. Если мы дойдем до вершины без левого сына, то это значит, что нет ни одного числа меньше, чем вот этот.
[48:50.920 --> 48:57.920]  То есть это Y, вершина без левого сына, и соответственно меньше этого числа никого нет.
[48:57.920 --> 49:10.920]  Тогда сделаем следующее. Давайте мы вместо X запишем Y, то есть X забудем, напишем на его место Y, а удалим Y, вот это вот старое число Y, его нижнюю позицию.
[49:10.920 --> 49:17.920]  И это уже легко сделать, потому что смотрите, у Y нет левого сына. Нет левого сына.
[49:17.920 --> 49:22.920]  И его удалить уже тогда можно, потому что даже если у него есть какой-то правый сын, мы можем просто...
[49:23.920 --> 49:30.920]  То есть вот у Y, скажем, есть какой-то правый сын, тогда я могу просто это правое поддерево переподвесить на место Y, просто его сюда переподвесить.
[49:30.920 --> 49:38.920]  И тогда, соответственно, я удалил Y. Вот так будет работать наш Rx. То есть мы сначала находим X в дереве. Давайте повторю.
[49:38.920 --> 49:48.920]  Мы сначала нашли X в дереве. Потом, если одного из сыновей нет, то мы просто переподвешиваем одного из существующего детей на место X.
[49:48.920 --> 49:53.920]  Дальше, если оба сына существуют, и левый и правый, то давайте мы в правом поддереве найдем минимальный элемент.
[49:53.920 --> 50:04.920]  Находим Y, самое маленькое число R в правом поддереве. Затем Y перезаписываем вместо X.
[50:05.920 --> 50:12.920]  И, наконец, удаляем старое вхождение Y.
[50:17.920 --> 50:25.920]  Почему это все работает? Ну вот, например, почему мы можем Y перезаписать вместо X?
[50:25.920 --> 50:32.920]  Потому что Y это был минимальный элемент в правом поддереве. Поэтому, когда я заменяю X на Y, у меня, смотрите, X увеличился.
[50:32.920 --> 50:39.920]  У меня был X, а он заменился на какого-то чувака из правого поддерева. Поэтому X увеличился, и все вот эти не раз они сохранились.
[50:39.920 --> 50:45.920]  То есть вот это число с левым поддеревом, оно, конечно, по-прежнему вот это число больше, чем все, что в левом поддереве.
[50:45.920 --> 50:51.920]  Что происходит с правым поддеревом? Ну здесь мы взяли самое маленькое число оттуда и поместили его в корень.
[50:51.920 --> 50:58.920]  И потом, причем этот Y отсюда удалили? Значит, все оставшиеся здесь числа, они будут больше, чем Y.
[50:58.920 --> 51:05.920]  Все оставшиеся справа числа будут больше, чем Y. Значит, инвариант нашего дерева, что слева все меньше, справа все больше.
[51:05.920 --> 51:09.920]  Инвариант дерева сохранился, поэтому все сделали корректно. Так можно было сделать.
[51:09.920 --> 51:16.920]  Ну и здесь последнее осталось нам удалить старое вхождение Y. Я сказал, что Y уже не имеет левого сына.
[51:16.920 --> 51:19.920]  Ну предположение, что это минимальное число, значит, что у него нет левого сына.
[51:19.920 --> 51:22.920]  И значит, я либо просто его удаляю, если нету даже правого сына.
[51:22.920 --> 51:26.920]  А если правый сын есть, то я правый сын переподвешиваю, правый сына переподвешиваю на месте ледника.
[51:26.920 --> 51:33.920]  Правого сына переподвешиваю на месте ледника. Вот и все. Вот такой рейс.
[51:33.920 --> 51:38.920]  Как работает этот рейс? Хорошо.
[51:39.920 --> 51:42.920]  Нам вот этот рейс будет очень нужен.
[51:42.920 --> 51:50.920]  Ну, собственно, нам важно понимать, как это работает в наивном случае, чтобы как-то это оптимизировать.
[51:50.920 --> 51:57.920]  Итак, значит, давайте теперь тогда рассмотрим одну из вариаций того, как можно наше дерево балансировать.
[51:57.920 --> 52:05.920]  Сбалансированное дерево поиска.
[52:05.920 --> 52:12.920]  Значит, мы хотим, мы понимаем, что время работы всех наших процедур, оно в худшем случае пропорциональнее глубине дерева.
[52:12.920 --> 52:16.920]  То есть, чем глубже дерево, тем дольше мы можем спускаться от корня в пульках х.
[52:16.920 --> 52:21.920]  Значит, мы хотим, чтобы глубина была как можно меньше.
[52:21.920 --> 52:23.920]  Ну, она будет логерифмическая везде.
[52:23.920 --> 52:33.920]  Чтобы глубина была по отлоге, ну, где n это текущее количество элементов в множестве.
[52:33.920 --> 52:35.920]  N это мощность S.
[52:35.920 --> 52:38.920]  Ну, соответственно, если дерево такое, мы будем говорить, что оно сбалансированное.
[52:38.920 --> 52:40.920]  Ну, это неформальное определение.
[52:40.920 --> 52:44.920]  Сбалансированное просто значит, что оно достаточно хорошее для нас.
[52:44.920 --> 52:48.920]  И первое дерево, которое мы рассмотрим, это AVL дерево.
[52:48.920 --> 52:49.920]  AVL дерево.
[52:49.920 --> 52:54.920]  Значит, AVL это по фамилиям авторов.
[52:54.920 --> 52:56.920]  Давайте я для общего развития напишу.
[52:56.920 --> 52:59.920]  Значит, первого чувака звали Адельсон Вильский.
[53:07.920 --> 53:09.920]  Второго чувака звали Ландис.
[53:09.920 --> 53:11.920]  Вот какие цивилизации.
[53:11.920 --> 53:13.920]  Вот почему он так называется странно.
[53:13.920 --> 53:16.920]  Значит, AVL это первый, L это второй.
[53:16.920 --> 53:20.920]  Итак, значит, вот что они сказали.
[53:20.920 --> 53:22.920]  Давайте мы будем поддерживать следующий вариант.
[53:22.920 --> 53:40.920]  Что если h от v это глубина под дерево вершины v, то требуем следующего соотношения.
[53:40.920 --> 53:50.920]  Для каждой вершины v разность глубин левого под дерево и правого под дерево должна быть не больше единицы.
[53:50.920 --> 54:01.920]  То есть вот если это L, это R для любой вершинки v, то модуль разности h от L минус h от R должен быть не большим единицам.
[54:01.920 --> 54:03.920]  Ну, соответственно, это это определение.
[54:03.920 --> 54:11.920]  Если для каждой вершины выполняется вот это вот соотношение, что модуль разности глубин левого сына и правого сына не больше единицы,
[54:11.920 --> 54:17.920]  то есть они вообще либо глубины равны, либо отличаются на единицы, тогда такое дерево называется AVL дерево.
[54:18.920 --> 54:22.920]  AVL дерево.
[54:22.920 --> 54:30.920]  Если у каждой вершины модуль разности глубин двух детей левого и правого не больше единицы, тогда мы говорим, что это v дерево.
[54:30.920 --> 54:38.920]  Вот в частности, например, если там вообще правого сына нету, вот есть вершинка v, у нее есть, скажем, например, левый сын, а правого сына нету.
[54:38.920 --> 54:40.920]  Ну, тогда правый сын имеет глубину 0.
[54:40.920 --> 54:45.920]  Будем говорить, что если дерево пустое, то есть если его вообще там ничего нету, то говорим, что глубина 0.
[54:45.920 --> 54:48.920]  И тогда HL должно быть не больше единицы.
[54:50.920 --> 54:52.920]  HL не больше единицы.
[54:52.920 --> 54:54.920]  Вот что такое AVL дерево.
[54:54.920 --> 54:57.920]  Теперь наша задача состоит в следующем.
[54:57.920 --> 55:02.920]  Во-первых, показать, что у такого дерева обязательно неплохая глубина, всегда не большим логарифм.
[55:02.920 --> 55:11.920]  А во-вторых, как-то научиться переделать наши инсерты и рейсы так, чтобы всегда сохранить вот этот вариант AVL дерева.
[55:11.920 --> 55:15.920]  Что глубины всегда, ну как бы, что глубина левого сына и правого сына всегда уравновешен.
[55:15.920 --> 55:17.920]  Примерно там плюс-минус один друг от друга.
[55:20.920 --> 55:27.920]  Ну, давайте сначала сделаем первое, что поймем, какая глубина может быть у AVL дерева из n вершин.
[55:29.920 --> 55:40.920]  Какая может быть глубина у AVL дерева из n вершин.
[55:42.920 --> 56:00.920]  Давайте обозначим, наоборот, давайте обозначим S от H, это минимальное количество вершин в AVL дереве глубины H.
[56:00.920 --> 56:05.920]  То есть, наоборот, мы фиксируем глубину и ищем минимально возможное число вершин.
[56:06.920 --> 56:11.920]  Фиксировали глубину H и ищем минимально возможное количество вершин S от H.
[56:11.920 --> 56:15.920]  Тогда давайте сообразим, что такое S от 0.
[56:15.920 --> 56:20.920]  Мы поняли, что нулевая глубина означает, что дерево пустое, и там 0 вершин.
[56:20.920 --> 56:23.920]  Дальше глубина единица означает, что просто одна вершина.
[56:23.920 --> 56:26.920]  Значит, здесь давайте напишу пусто, пустое дерево.
[56:26.920 --> 56:32.920]  Глубина единицы значит, как бы, одна вершина, и соответственно, всего S от 1 это единица.
[56:32.920 --> 56:34.920]  Дальше S от 2. Что такое S от 2?
[56:34.920 --> 56:37.920]  Это значит, что мы можем нарисовать дерево глубины 2.
[56:37.920 --> 56:39.920]  Какие у нас есть деревья глубины 2?
[56:39.920 --> 56:43.920]  Есть вот такое дерево, когда у корня есть один сын, соответственно, глубина будет 2.
[56:43.920 --> 56:47.920]  Либо у корня есть оба сына, и левый и правый.
[56:47.920 --> 56:50.920]  Больше ничего быть не может, потому что иначе глубина увеличится.
[56:50.920 --> 56:57.920]  Ну и тогда понятно, что S от 2 это 2, да, потому что у меня, потому что минимальное число вершин это 2.
[56:58.920 --> 57:00.920]  Ну, это мы поняли.
[57:00.920 --> 57:10.920]  А дальше можно заметить следующее, что S от h равно 1 плюс S от h-1 плюс S от h-2.
[57:10.920 --> 57:11.920]  Вот почему.
[57:11.920 --> 57:16.920]  Потому что, смотрите, есть у меня дерево глубины h.
[57:16.920 --> 57:19.920]  Дерево глубины h.
[57:19.920 --> 57:20.920]  Как оно выглядит?
[57:20.920 --> 57:25.920]  Это корень, первая вершинка, а дальше два сына, два под деревом.
[57:25.920 --> 57:28.920]  Причем, какие могут быть глубины у этих под деревьев?
[57:28.920 --> 57:33.920]  Ну понятно, что раз глубина всего дерева это h, то обязательно есть хотя бы один сын, у которого глубина h-1.
[57:33.920 --> 57:37.920]  Вот скажем, у левого сына глубина h-1.
[57:37.920 --> 57:39.920]  Отсюда вот это слагаем.
[57:39.920 --> 57:40.920]  Да, минимальная возможность число вершин в нем.
[57:40.920 --> 57:42.920]  Это S от h-1.
[57:42.920 --> 57:43.920]  Теперь вопрос.
[57:43.920 --> 57:46.920]  Тогда какое минимальное количество вершин может быть в правом сыне?
[57:46.920 --> 57:49.920]  Ну, можем сказать, что здесь глубина h-2.
[57:49.920 --> 57:53.920]  Потому что мы знаем, что модуль разности глубин левого сына и левого сына,
[57:53.920 --> 57:57.920]  отличается максимум на единицу.
[57:57.920 --> 58:01.920]  И если мы хотим минимизировать число вершин, то понятно, где нужно минимизировать глубину.
[58:01.920 --> 58:07.920]  Поэтому минимальное число вершин справа это S от h-2.
[58:07.920 --> 58:12.920]  Значит, это левый сын, максимальный сын, это правый сын, минимальный.
[58:12.920 --> 58:19.920]  Но получили такое соотношение, что S от h-1 плюс два предыдущих значения.
[58:20.920 --> 58:23.920]  Вот, тогда я утверждаю следующее.
[58:23.920 --> 58:25.920]  Давайте я это соотношение перепишу.
[58:25.920 --> 58:32.920]  Что S от h равно единица плюс S от h-1 плюс S от h-2.
[58:32.920 --> 58:37.920]  Тогда S от h это вот такое.
[58:37.920 --> 58:41.920]  Это h плюс первое число фибоначи минус один.
[58:41.920 --> 58:44.920]  Где f это число фибоначи.
[58:44.920 --> 58:56.920]  Задающееся соотношением f0 это единица, f1 это единица и так далее.
[58:56.920 --> 59:00.920]  Причем fкт это сумма двух предыдущих.
[59:00.920 --> 59:03.920]  fk минус один плюс fk минус два.
[59:05.920 --> 59:07.920]  Сумму двух предыдущих.
[59:07.920 --> 59:09.920]  Здесь простое соотношение.
[59:09.920 --> 59:12.920]  Соотношение, доказательства просто по индукции у h.
[59:12.920 --> 59:15.920]  Индукция у h.
[59:15.920 --> 59:20.920]  Значит, база h равно 0, h равно единицы, очевидно.
[59:20.920 --> 59:22.920]  Мы же с вами уже все это разобрали.
[59:22.920 --> 59:25.920]  Мы поняли, чему равно S от 0, S от единицы на прошлом слайде.
[59:25.920 --> 59:28.920]  Мы знаем, чему равно S от h для h равно 0, 1.
[59:28.920 --> 59:31.920]  Мы понимаем, чему равно последовательность f.
[59:31.920 --> 59:34.920]  Можно написать, что f от 2 это 2, например.
[59:34.920 --> 59:36.920]  Сумму двух предыдущих это 2 получается.
[59:36.920 --> 59:40.920]  Ну и понятно будет, что это соотношение выполняется.
[59:40.920 --> 59:47.920]  Далее пусть h больше равно 2.
[59:47.920 --> 59:53.920]  Тогда с одной стороны мы знаем, что S от h это единица плюс два предыдущих S.
[59:53.920 --> 01:00:00.920]  С другой стороны, про каждое из двух предыдущих мы знаем его выражение через словебоначи.
[01:00:00.920 --> 01:00:05.920]  Это будет единица плюс f h минус 1.
[01:00:05.920 --> 01:00:08.920]  Мы взяли следующие словебоначи и вышли единичку.
[01:00:08.920 --> 01:00:12.920]  Здесь будет f h минус первая тоже минус 1.
[01:00:12.920 --> 01:00:14.920]  Следующие словебоначи минус 1.
[01:00:14.920 --> 01:00:19.920]  То есть здесь наверно 1 больше, чем у S.
[01:00:19.920 --> 01:00:24.920]  Здесь раскрываем скобки, остается f h плюс f h минус 1.
[01:00:24.920 --> 01:00:26.920]  Минус 1.
[01:00:26.920 --> 01:00:29.920]  Ну а это мы знаем, что это просто f h плюс 1.
[01:00:29.920 --> 01:00:32.920]  По определению, сумма двух предыдущих словебоначи это следующее число фибоначи.
[01:00:32.920 --> 01:00:34.920]  Получилось то, что нужно.
[01:00:34.920 --> 01:00:37.920]  Что S от h равно f от h плюс 1 минус 1.
[01:00:42.920 --> 01:00:47.920]  Таким образом, минималевозможное количество вершин в AVL-дереве DGH,
[01:00:47.920 --> 01:00:51.920]  это какое-то число фибоначи следующее, минус 1.
[01:00:51.920 --> 01:00:53.920]  Число фибоначи минус 1.
[01:00:56.920 --> 01:00:57.920]  Дальше.
[01:00:57.920 --> 01:00:59.920]  Так, вопросик.
[01:01:00.920 --> 01:01:02.920]  Сейчас, одну секунду.
[01:01:04.920 --> 01:01:08.920]  Объясните отношение для S от h.
[01:01:08.920 --> 01:01:09.920]  Вот это.
[01:01:09.920 --> 01:01:10.920]  Давайте вернемся.
[01:01:10.920 --> 01:01:13.920]  Значит, смотрите, откуда это возникает.
[01:01:13.920 --> 01:01:17.920]  Мы измеряем минималевозможное количество вершин в дереве глубины h.
[01:01:17.920 --> 01:01:19.920]  Ну хорошо, что такое дерево глубины h?
[01:01:19.920 --> 01:01:22.920]  Это какой-то корень и два сына.
[01:01:22.920 --> 01:01:26.920]  Значит, есть один сын, ну обязательно есть хотя бы один сын глубины h минус 1.
[01:01:26.920 --> 01:01:29.920]  Потому что, ну, неужно откуда-то взять путь длины h.
[01:01:29.920 --> 01:01:32.920]  Значит, соответственно, хотя бы один из сыновей имеет глубину h минус 1.
[01:01:32.920 --> 01:01:35.920]  Когда вот этот сын имеет глубину h минус 1.
[01:01:35.920 --> 01:01:38.920]  Тогда в нем вот столько вершин минимум.
[01:01:38.920 --> 01:01:40.920]  В этом сыне как минимум столько вершин по определению.
[01:01:40.920 --> 01:01:41.920]  S от h минус 1.
[01:01:41.920 --> 01:01:45.920]  Это минималевозможное количество вершин в AVL-дереве глубины h минус 1.
[01:01:45.920 --> 01:01:47.920]  Теперь смотрим на второго сына.
[01:01:47.920 --> 01:01:49.920]  Какая у него может быть глубина?
[01:01:49.920 --> 01:01:53.920]  Ну, мы с вами знаем, что если это корректный AVL-дерево,
[01:01:53.920 --> 01:01:57.920]  то глубина правого сына отличается от глубины левого сына максимум на единиц.
[01:01:57.920 --> 01:02:02.920]  Поэтому мы можем взять h минус 1 и сделать плюс минус 1 или оставить как был.
[01:02:02.920 --> 01:02:06.920]  То есть глубина вот этого дерева, давайте напишу все возможные варианты.
[01:02:06.920 --> 01:02:10.920]  Это либо h минус 1, либо h минус 2, либо h.
[01:02:10.920 --> 01:02:13.920]  То есть максимум на единичку отличается от h минус 1.
[01:02:13.920 --> 01:02:17.920]  Но смотрите, h точно быть не может, потому что иначе глубина была бы вот здесь вот h плюс 1.
[01:02:17.920 --> 01:02:20.920]  Потому что есть вершинка и по дереву глубина h.
[01:02:20.920 --> 01:02:23.920]  Поэтому суммарная глубина будет h плюс 1.
[01:02:23.920 --> 01:02:26.920]  Правый сын имеет глубину либо такую, либо такую.
[01:02:26.920 --> 01:02:30.920]  Ну, тогда, соответственно, минималевозможное число вершин это, конечно, S от h минус 2.
[01:02:30.920 --> 01:02:33.920]  Потому что глубина либо h минус 1, либо h минус 2.
[01:02:33.920 --> 01:02:35.920]  Но минимум из них это, конечно, h минус 2.
[01:02:35.920 --> 01:02:40.920]  И тем самым минималевозможное количество вершин в этом дереве это S от h минус 2.
[01:02:42.920 --> 01:02:43.920]  Вроде объясню.
[01:02:44.920 --> 01:02:48.920]  Итак, зачем нам нужно это соотношение про...
[01:02:48.920 --> 01:02:52.920]  Зачем нам нужно это соотношение про части Боначо?
[01:02:52.920 --> 01:02:55.920]  Давайте вот перехожу.
[01:02:55.920 --> 01:02:58.920]  Ну, нам на самом деле важен просто их порядок роста.
[01:02:58.920 --> 01:03:01.920]  Нам важен их порядок роста.
[01:03:01.920 --> 01:03:05.920]  Утверждение, даже упражнение без доказательства.
[01:03:05.920 --> 01:03:09.920]  Утверждение без доказательства.
[01:03:10.920 --> 01:03:13.920]  Пусть...
[01:03:13.920 --> 01:03:16.920]  Так, сейчас, одну секундочку.
[01:03:16.920 --> 01:03:19.920]  Как мы их определили там?
[01:03:19.920 --> 01:03:22.920]  Соединиться, да, их, например, с...
[01:03:25.920 --> 01:03:30.920]  Пусть phi равно 1 при скорой, в принципе, пополам.
[01:03:31.920 --> 01:03:36.920]  Тогда f...
[01:03:41.920 --> 01:03:54.920]  Видимо, k минус 1 равно phi в n-х минус phi в минус n-х делить на корень из 5.
[01:03:54.920 --> 01:03:57.920]  Sorry, здесь будет n.
[01:04:03.920 --> 01:04:06.920]  Это легко доказать просто по индукции.
[01:04:06.920 --> 01:04:10.920]  Там вы доказываете, это для n равно единиц и двойки.
[01:04:10.920 --> 01:04:13.920]  Получили соотношение для f0, f1.
[01:04:13.920 --> 01:04:19.920]  А дальше, если вы знаете, чему равно два предыдущих, то есть f от n и f от n плюс 1,
[01:04:19.920 --> 01:04:21.920]  то вы их складываете, получаете f от n плюс 2.
[01:04:21.920 --> 01:04:24.920]  И проверяете, что вот эта сумма равна в точности тому, чему нужно.
[01:04:24.920 --> 01:04:26.920]  То есть доказательство утверждения очень просто по индукции.
[01:04:26.920 --> 01:04:29.920]  Да, это как-то тяжело, возможно, доказывается, но...
[01:04:29.920 --> 01:04:33.920]  Sorry, придумывается эта формула, но доказывается просто.
[01:04:33.920 --> 01:04:35.920]  Но тем более, вы выводили на окончание.
[01:04:35.920 --> 01:04:38.920]  Нет, смотрите, делений здесь вообще нет никакого.
[01:04:38.920 --> 01:04:44.920]  Можно понять, что здесь деление само по себе будет целым.
[01:04:44.920 --> 01:04:46.920]  То есть здесь будет что-то, деляющее на корень из 5,
[01:04:46.920 --> 01:04:49.920]  когда вы сократите, останется целое число.
[01:04:49.920 --> 01:04:50.920]  Всегда целое.
[01:04:50.920 --> 01:04:54.920]  То есть так удивительно получается, что это соотношение всегда целое число.
[01:04:54.920 --> 01:04:57.920]  Прилагаю вам это доказать самостоятельно.
[01:04:57.920 --> 01:05:00.920]  Сейчас, у меня минус х и стих не минус n.
[01:05:05.920 --> 01:05:07.920]  То есть там как бы одна фита.
[01:05:09.920 --> 01:05:11.920]  Вроде так. В общем, попробуйте доказать.
[01:05:11.920 --> 01:05:14.920]  Если вы это уже доказывали, то вы и так понимаете, о чем я говорю.
[01:05:15.920 --> 01:05:16.920]  В чем здесь смысл?
[01:05:16.920 --> 01:05:19.920]  Здесь написано какое-то число больше единицы.
[01:05:19.920 --> 01:05:20.920]  1 и 6 кажется примерно.
[01:05:23.920 --> 01:05:24.920]  Вы здесь уже возводите степень n,
[01:05:24.920 --> 01:05:28.920]  а здесь вы берете минус 1 и 6, Wirtschaft использовать в степень минус n.
[01:05:28.920 --> 01:05:32.920]  Ну, а в возnutвительности в степени минус n,
[01:05:32.920 --> 01:05:34.920]  что помодли больше единицы – это бесконечно убывающая последовательность.
[01:05:34.920 --> 01:05:36.920]  То есть viktigt стремиться к нулю.
[01:05:36.920 --> 01:05:38.920]  Вы взяли какое число по модулю больше единицы
[01:05:38.920 --> 01:05:39.920]  и возводили в большую обязательно степень.
[01:05:40.920 --> 01:05:44.920]  То есть чем больше n, тем большую отрицательную степень вы ее возводите.
[01:05:45.920 --> 01:05:47.920]  Поэтому это слагаемое, как бы у вас будет стремиться к нулю.
[01:05:47.920 --> 01:05:52.920]  стремится к нулю, и понятно, что основное синтетическое слагаем будет фетен.
[01:05:52.920 --> 01:05:56.920]  Поэтому я напишу так.
[01:05:56.920 --> 01:06:02.920]  n-ное число фибоначи имеет порядок роста в тернах θ, как просто phi в степени n.
[01:06:02.920 --> 01:06:05.920]  n-ное число фибоначи – это θ от phi в степени n.
[01:06:05.920 --> 01:06:08.920]  Потому что, еще раз повторюсь, вот это слагаемое стремится к нулю,
[01:06:08.920 --> 01:06:12.920]  и оно не оказывает никакого вклада в тернах θ большого.
[01:06:12.920 --> 01:06:18.920]  Ну а это просто какой-то константный нождик, который можно игнорировать в этих наших тетобозначениях.
[01:06:18.920 --> 01:06:23.920]  Хорошо, получается, что n-ное число фибоначи растет экспоненциально,
[01:06:23.920 --> 01:06:26.920]  потому что phi – это число больше единицы.
[01:06:26.920 --> 01:06:29.920]  Растет экспоненциально быстро.
[01:06:29.920 --> 01:06:38.920]  f от n растет экспоненциально быстро.
[01:06:38.920 --> 01:06:41.920]  То есть представьте, у вас вместо phi стояло бы там 2.
[01:06:41.920 --> 01:06:44.920]  Например, там 2 в степени n. Понятно, что 2 в степени n растет очень-очень быстро.
[01:06:44.920 --> 01:06:51.920]  Так, ну и тем самым мы понимаем, что s от h значит тоже растет экспоненциально быстро.
[01:06:51.920 --> 01:06:56.920]  Тоже растет экспоненциально быстро.
[01:06:56.920 --> 01:07:02.920]  Ну и можно написать то же самое, что sht – это θ от phi в степени h.
[01:07:02.920 --> 01:07:05.920]  Что ht – это число, это θ от phi в степени h.
[01:07:05.920 --> 01:07:10.920]  Потому что мы выразили вот это число через число фибоначи.
[01:07:10.920 --> 01:07:15.920]  Мы знаем порядок роста для числа фибоначи, значит знаем порядок роста для нашего числа s от h.
[01:07:15.920 --> 01:07:24.920]  Итого, смотрите, если мы фиксировали h, то минимальное количество вершин в дереве, в ВВЛ дереве глубины h, оно экспоненциально по h.
[01:07:24.920 --> 01:07:32.920]  Но, значит, наоборот, если у вас фиксировано количество вершин n, то максимально возможные глубина – это логарифм n по основанию phi.
[01:07:33.920 --> 01:08:00.920]  Значит отсюда следует следующее, что если в дереве, если в ВВЛ дереве n вершин, если в ВВЛ дереве всего n вершин, то его глубина не превосходит, ну я напишу так, o от логарифма по основанию phi от n.
[01:08:00.920 --> 01:08:07.920]  Потому что мы понимаем, что если есть какая-то глубина h, то вершин примерно phi в степени h.
[01:08:07.920 --> 01:08:14.920]  Тогда, наоборот, если у вас есть n вершин, то глубина – это примерно логарифм n по основанию phi.
[01:08:14.920 --> 01:08:20.920]  Логарифм n по основанию phi. Ну и все, а это просто o от логарифм n.
[01:08:20.920 --> 01:08:27.920]  Да, мы с вами знаем, что в o обозначениях можно не писать основание логарифма, потому что они все равно все отличаются в консанту раз.
[01:08:27.920 --> 01:08:33.920]  Все, мы доказали, что в овл дереве на n вершинах максимум o от логн глубина.
[01:08:33.920 --> 01:08:42.920]  Глубина не больше, чем от логарифма, а это то, что мы хотели. Мы получаем дерево, которое всегда не очень глубокое и, собственно, победили.
[01:08:42.920 --> 01:08:48.920]  Нам нужно не глубокое дерево, нам нужно поддерживать этот вариант, тогда ответ на все запросы будет быстрый.
[01:08:48.920 --> 01:08:56.920]  У нас все работает за глубину, поэтому раз глубина небольшая, то время обработки каждого запроса будет логарифмическим.
[01:08:56.920 --> 01:09:00.920]  Каждый запрос будет логарифмическим.
[01:09:00.920 --> 01:09:04.920]  Так, окей.
[01:09:04.920 --> 01:09:10.920]  Ну что, тогда едем дальше.
[01:09:10.920 --> 01:09:16.920]  Едем дальше. Давайте ведем обозначение.
[01:09:16.920 --> 01:09:20.920]  Дельта от v.
[01:09:20.920 --> 01:09:24.920]  Это глубина левого сына минус правого сына.
[01:09:24.920 --> 01:09:28.920]  То есть если есть какая-то вершинка, есть у нее левый сын, есть правый сын,
[01:09:28.920 --> 01:09:32.920]  тогда через delta я буду обозначать такую разность.
[01:09:32.920 --> 01:09:38.920]  Глубина левого сына минус глубина правого сына.
[01:09:38.920 --> 01:09:40.920]  Левый минус правый.
[01:09:40.920 --> 01:09:52.920]  Тогда смотрите, нам хорошо, когда delta от v лежит во множестве минус 1, 0 или 1.
[01:09:52.920 --> 01:09:57.920]  Это как раз означает, что модуль разности глубин двух детей не больше единиц.
[01:09:57.920 --> 01:10:04.920]  И, соответственно, плохо, наоборот, когда delta выходит за эти рамки.
[01:10:04.920 --> 01:10:12.920]  Окей, давайте тогда сделаем следующее.
[01:10:12.920 --> 01:10:22.920]  Рассмотрим случай такой вершинки a, у которой delta от a равно минус 2.
[01:10:22.920 --> 01:10:25.920]  То есть мы что-нибудь сделали с нашим деревом.
[01:10:25.920 --> 01:10:27.920]  То есть представьте, у меня было корректно в льде.
[01:10:27.920 --> 01:10:31.920]  Потом я что-то в нем сделал, например, вставил какую-то вершинку просто из наивного алгоритма.
[01:10:31.920 --> 01:10:37.920]  Я ее вставил там на какое-то место, на которое говорит нам вот этот наивный алгоритм из наивного дерева поиска.
[01:10:37.920 --> 01:10:39.920]  Куда-то вставил новый элемент.
[01:10:39.920 --> 01:10:41.920]  Тогда у меня понятное дело, как-то изменились глубины.
[01:10:41.920 --> 01:10:47.920]  У меня изменились там какие-то глубины, например, если мы подрисовали x в какой-то вершинке y,
[01:10:47.920 --> 01:10:51.920]  тогда у меня у y появилось левое под дерево, значит у него выросла левая глубина.
[01:10:51.920 --> 01:10:53.920]  Вот эта htl для него увеличилась, для y.
[01:10:53.920 --> 01:10:57.920]  То есть как-то перечислялись глубины, соответственно, как-то могли перечисляться delt.
[01:10:57.920 --> 01:10:59.920]  И тогда моя цель такая.
[01:10:59.920 --> 01:11:03.920]  Если какие-то дельты стали невалидными, то есть стали вываливаться из этого множества,
[01:11:03.920 --> 01:11:07.920]  плюс-минус один или ноль, мне нужно эти дельты исправить срочно.
[01:11:07.920 --> 01:11:11.920]  Мне нужно сделать так, чтобы они опять стали плюс-минус один или ноль.
[01:11:11.920 --> 01:11:14.920]  Вот давайте посмотрим случай, когда мы дождитое какую-то вершинку,
[01:11:14.920 --> 01:11:16.920]  вот эта дельта стала минус двойкой.
[01:11:16.920 --> 01:11:21.920]  То есть раньше все было хорошо, теперь я что-то испортил, и теперь стала дельта равно минус двойкой.
[01:11:21.920 --> 01:11:23.920]  Дельта а та равно минус двойки.
[01:11:23.920 --> 01:11:27.920]  Тогда работают следующие идеи.
[01:11:27.920 --> 01:11:30.920]  Давайте поймем, что это значит.
[01:11:30.920 --> 01:11:32.920]  Что такое дельта а та равно минус двойки?
[01:11:32.920 --> 01:11:40.920]  Это значит, что правый сын глубже левого на два.
[01:11:40.920 --> 01:11:47.920]  То есть глубина левого минус глубина правого это минус двойка, значит правый глубже левого на два.
[01:11:47.920 --> 01:11:50.920]  Хорошо, давайте тогда посмотрим на вершинку а.
[01:11:50.920 --> 01:11:56.920]  Есть у нее какое-то левое подделье, возможно пустое, но неважно, давайте его все равно нарисуем.
[01:11:56.920 --> 01:11:59.920]  Есть обязательно у этой вершинки правый сын,
[01:11:59.920 --> 01:12:03.920]  потому что раз правый сын глубже левого на два, то он как минимум существует,
[01:12:03.920 --> 01:12:05.920]  то есть не может быть такого, что у него глубина ноль.
[01:12:05.920 --> 01:12:08.920]  Правый сын обязательно существует, и у него есть какие-то подделья.
[01:12:08.920 --> 01:12:12.920]  В b и c, левый и правый сын.
[01:12:12.920 --> 01:12:16.920]  Давайте рассмотрим случай, когда b равно нулю.
[01:12:16.920 --> 01:12:21.920]  Когда работает следующий поворот.
[01:12:21.920 --> 01:12:27.920]  Давайте мы повернем вот так вот это ребро справа налево.
[01:12:27.920 --> 01:12:31.920]  Можно себе это представлять, как будто у вас есть здесь какие-то гвоздики,
[01:12:31.920 --> 01:12:36.920]  скорее шарникщики, вдоль которых вы можете делать какие-то повороты,
[01:12:36.920 --> 01:12:38.920]  и ваши деревья будут как-то приподвешиваться.
[01:12:38.920 --> 01:12:42.920]  Тогда представьте, что будет, если мы сделаем такой поворот справа налево.
[01:12:42.920 --> 01:12:45.920]  У меня понятно, что b всплывет наверх.
[01:12:45.920 --> 01:12:48.920]  b станет как бы новым корнем текущего дерева.
[01:12:48.920 --> 01:12:50.920]  a станет его левым сыном.
[01:12:50.920 --> 01:12:52.920]  Здесь останется a большое.
[01:12:52.920 --> 01:12:55.920]  Ну и теперь давайте, скажем, b переподвесим вот сюда,
[01:12:55.920 --> 01:13:00.920]  а c оставим вот здесь.
[01:13:00.920 --> 01:13:02.920]  Что произошло?
[01:13:02.920 --> 01:13:04.920]  Мы как-то что-то переподвесили,
[01:13:04.920 --> 01:13:09.920]  и я утверждаю, что там как минимум сохранился вариант дерева поиска.
[01:13:10.920 --> 01:13:14.920]  То есть слева все значения меньше, чем значения в точке.
[01:13:14.920 --> 01:13:16.920]  С правой все значения больше, чем значения в точке.
[01:13:16.920 --> 01:13:19.920]  Значит, это совсем легко понять, потому что смотрите.
[01:13:19.920 --> 01:13:23.920]  Например, раньше у меня было a большое в левом под деревья a.
[01:13:23.920 --> 01:13:38.920]  Теперь a большое тоже в левом под деревья a.
[01:13:38.920 --> 01:13:44.220]  Что было? Было B маленькое, было правым сыном A, теперь A это левый сын B.
[01:13:44.220 --> 01:13:51.920]  Ну тогда здесь отношение было, что A это меньше, чем B, и здесь опять A меньше B должно выполняться, значит все выполняется.
[01:13:51.920 --> 01:13:58.720]  Ну и последнее, мне нужно проверить, что все хорошо между вершинкой B маленькой и правым подделием C.
[01:13:58.720 --> 01:14:02.620]  Здесь тоже, собственно, оно остается справа, поэтому все не раньше сохраняются.
[01:14:02.620 --> 01:14:06.020]  То есть такой поворот мне оставляет корректное дерево поиска.
[01:14:06.700 --> 01:14:13.020]  Теперь давайте посмотрим, что происходит с глубинами? Что происходит с дельтами?
[01:14:13.020 --> 01:14:15.320]  Давайте расставим глубины всех под деревьgroв.
[01:14:23.520 --> 01:14:31.120]  То есть здесь h-1, потому что глубина берется из правого сына, раз в левом сыне глубина на 2 меньше.
[01:14:31.120 --> 01:14:36.120]  То есть здесь какая-то, здесь на 2 меньше, поэтому глубина здесь равна h-1.
[01:14:36.120 --> 01:14:38.120]  В французском языке глубина h-1.
[01:14:38.120 --> 01:14:45.120]  Ну и раз delta2 равно 0, то получается, что вот эти два дерева одинаковые глубины, h-2, h-2.
[01:14:45.120 --> 01:14:48.120]  Хорошо, а теперь что происходит, когда мы так переподвесим?
[01:14:48.120 --> 01:14:55.120]  У меня у a большое, у b большое, у c большое глубины остаются, h-3, h-2, h-2.
[01:14:55.120 --> 01:14:57.120]  Теперь к чему равна глубина вот этого a маленького?
[01:14:57.120 --> 01:15:03.120]  Здесь глубина становится h-1, потому что есть вот такой путь направо, а дальше путь длины h-2.
[01:15:03.120 --> 01:15:10.120]  То есть здесь глубина h-1, а здесь глубина h просто, потому что вот есть ребро влево сына.
[01:15:10.120 --> 01:15:15.120]  Ну и вообще всегда, если у меня есть два сына, один глубины x, другой глубины y,
[01:15:15.120 --> 01:15:19.120]  то глубина родительской вершинки это максимум из x и y плюс 1.
[01:15:19.120 --> 01:15:24.120]  Мы берем максимум из двух глубин и добавляем единицу от, собственно, самого корня.
[01:15:24.120 --> 01:15:26.120]  Зато смотрите, какая здесь прелесть.
[01:15:26.120 --> 01:15:30.120]  У меня вот здесь, вот в этом дереве, все дельты стали хорошими,
[01:15:30.120 --> 01:15:38.120]  потому что у h-ки дельта стала равна минус единице, глубина левого минус глубина правого это минус 1.
[01:15:38.120 --> 01:15:41.120]  h-3 минус h-2 это минус 1.
[01:15:41.120 --> 01:15:46.120]  А у b-шки дельта стала равна единице.
[01:15:46.120 --> 01:15:51.120]  Слева, потому что h-1, справа h-2, лево минус справа это единица.
[01:15:51.120 --> 01:15:53.120]  И получается, смотрите, какая прелесть.
[01:15:53.120 --> 01:15:58.120]  Если у меня была вершина, у которой была плохая дельта, дельта от a равно минус 2,
[01:15:58.120 --> 01:16:03.120]  то я смог за один вот такой вот поворот исправить все дисбалансы.
[01:16:03.120 --> 01:16:07.120]  То есть я смог сделать так, чтобы во всех вершинах дельта встала в нормальном интервале
[01:16:07.120 --> 01:16:12.120]  плюс минус 1 или 0.
[01:16:12.120 --> 01:16:15.120]  И так мы сделаем во всех возможных случаях.
[01:16:16.120 --> 01:16:21.120]  Здесь я предположил, что дельта от a равна минус 2 и дельта от b равна нулю.
[01:16:21.120 --> 01:16:23.120]  Сделал такие предположения.
[01:16:23.120 --> 01:16:26.120]  Ну и теперь давайте рассмотрим все остальные случаи и поймем, что тоже как-то можно так хитро
[01:16:26.120 --> 01:16:33.120]  попереворачивать с сохранением им варианта дерева поиска, чтобы в результате у нас все дельты как бы сбалансировать.
[01:16:33.120 --> 01:16:37.120]  Все дельты стали плюс минус 1 или 0.
[01:16:37.120 --> 01:16:43.120]  Остается нам сейчас пара случаев, давайте я их тоже нарисую.
[01:16:43.120 --> 01:16:46.120]  Мы остаемся в предположении, что дельта от a равна минус 2.
[01:16:46.120 --> 01:16:51.120]  И теперь рассматриваем случай, когда дельта у права сына это минус 1.
[01:16:51.120 --> 01:16:56.120]  Давайте я нарисую опять картинку.
[01:16:56.120 --> 01:16:59.120]  То есть все то же самое, только мы меняем дельта от b, стал равным минус 1.
[01:16:59.120 --> 01:17:05.120]  Решение остается, мы поворачиваем вдоль этого ребра справа налево.
[01:17:05.120 --> 01:17:09.120]  Тогда у меня опять b станет новым корнем, у него есть сын a маленькая,
[01:17:09.120 --> 01:17:14.120]  у него есть сына b большая, и у корня есть также сын c.
[01:17:14.120 --> 01:17:18.120]  Теперь опять то же самое делаем с глубинами.
[01:17:18.120 --> 01:17:21.120]  Здесь была исходная глубина h.
[01:17:21.120 --> 01:17:24.120]  Здесь была глубина h минус 3, здесь h минус 1.
[01:17:24.120 --> 01:17:29.120]  Потому что раз дельта от a минус 2, то соответственно справа должно быть максимальная, а слева на 2 меньше.
[01:17:29.120 --> 01:17:30.120]  Здесь h минус 1.
[01:17:30.120 --> 01:17:35.120]  Теперь раз дельта от b минус 1, то значит у него правый сын больше, чем левый, ровно на 1.
[01:17:35.120 --> 01:17:39.120]  Поэтому здесь h минус2, здесь h минус3.
[01:17:39.120 --> 01:17:42.120]  Мы опять проставили глубину всех подделLOL.
[01:17:42.120 --> 01:17:44.120]  Копируем их сюда.
[01:17:44.120 --> 01:17:49.120]  Значит h минус3, h минус3, h минус 2.
[01:17:49.120 --> 01:17:50.120]  Теперь что такое глубина a?
[01:17:50.120 --> 01:17:52.120]  У него есть два сына, оба имеют глубину h минус 3,
[01:17:52.120 --> 01:17:55.120]  поэтому здесь глубина становится h минус 2.
[01:17:55.120 --> 01:17:59.120]  И у b-шки тоже, у него есть два одинаковых сына, одинаковой глубины.
[01:17:59.120 --> 01:18:02.120]  Поэтому глубина здесь становится h минус 1.
[01:18:02.120 --> 01:18:09.120]  И дельты в итоге обе занурились. Здесь стала дельта равна нулю, потому что левый и правый сын имеют одинаковую глубину.
[01:18:09.120 --> 01:18:16.120]  И здесь тоже дельта равна нулю, потому что левый и правый сын имеют одинаковую глубину.
[01:18:16.120 --> 01:18:21.120]  Такая магия, что просто такие вот повороты в таких-то случаях работают.
[01:18:21.120 --> 01:18:30.120]  Нам осталось разобрать кейс, когда дельта от а равно минус двойке, а дельта от b равно единице.
[01:18:30.120 --> 01:18:35.120]  Давайте сейчас разберемся с этим. И на этом в принципе разбора вея-дерева можно считать будет оконченным.
[01:18:35.120 --> 01:18:43.120]  Потому что алгоритм будет такой. Мы подвесили там, то есть когда обрабатываем инсерт какой-нибудь или рейс,
[01:18:43.120 --> 01:18:47.120]  ну подвешиваем или удаляем вершинку ровно так, как делается в наидном алгоритме.
[01:18:47.120 --> 01:18:52.120]  Потом у нас что могло испортиться? У нас могло на плюс-минус один какие-то глубины испортиться.
[01:18:52.120 --> 01:18:54.120]  Вот как раз на том пути, по которому мы шли.
[01:18:54.120 --> 01:18:58.120]  Тогда давайте просто пройдемся снизу вверх и все вот эти дисбалансы устраним.
[01:18:58.120 --> 01:19:02.120]  Устраним там нужными поворотами, устраним все дисбалансы.
[01:19:02.120 --> 01:19:09.120]  Вот как мы сейчас делаем. То есть есть какие-то повороты, которые возвращают дельту в отрезок плюс-минус один или ноль.
[01:19:09.120 --> 01:19:16.120]  Но если мы так сможем сделать всегда, то мы так пройдем снизу вверх до корня, как-то там попереворачивав дерево,
[01:19:16.120 --> 01:19:21.120]  таким образом, что опять станет корректно вея-дерево. То есть все дельточки станут хорошими.
[01:19:21.120 --> 01:19:25.120]  И у меня не будет никаких конфликтов, это будет правильно в Эльдии.
[01:19:25.120 --> 01:19:28.120]  Вот. Ну хорошо, давайте значим.
[01:19:28.120 --> 01:19:30.120]  Ссылки на родителя.
[01:19:30.120 --> 01:19:35.120]  Ссылки на родителя. На самом деле это не обязательно.
[01:19:35.120 --> 01:19:42.120]  А, сейчас. Ну окей, так удобнее. Да, согласен. То есть можно хранить ссылки на родителя, так будет удобнее, действительно.
[01:19:42.120 --> 01:19:47.120]  Чтобы подняться вот так снизу вверх, можно действительно хранить просто ссылку на родителя. Да, можно так.
[01:19:47.120 --> 01:19:52.120]  А можно, в принципе, просто...
[01:19:52.120 --> 01:19:59.120]  Ну мы же, по сути, если писать код, то мы там, возможно, напишем какую-нибудь рекурсию, в стиле спустись в левый под дерево, там все перестрой.
[01:19:59.120 --> 01:20:05.120]  И, по сути, у меня возвращение, возврат, он будет сам из рекурса делаться.
[01:20:05.120 --> 01:20:09.120]  То есть вместо того, чтобы брать родителя, я буду просто отказываться в рекурсе.
[01:20:09.120 --> 01:20:13.120]  Кажется, здесь даже это не обязательно делать.
[01:20:13.120 --> 01:20:19.120]  Итак, давайте разберем в случае, дельта равно двойке, а дельта равно единице.
[01:20:22.120 --> 01:20:26.120]  Когда здесь решение такое?
[01:20:26.120 --> 01:20:31.120]  Здесь решение такое. Так, минус двойки только.
[01:20:31.120 --> 01:20:34.120]  Ой, ой, ой, ой.
[01:20:34.120 --> 01:20:39.120]  Минус двойка, а здесь единица.
[01:20:39.120 --> 01:20:43.120]  Тогда, значит, я рисую опять левого сына, у него есть правый сын.
[01:20:43.120 --> 01:20:48.120]  Дальше, раз дельта равно единице, то у него получается левый сын глубже, чем правый, на один.
[01:20:48.120 --> 01:20:51.120]  Поэтому левый сын как минимум есть. То есть здесь есть фишенка С.
[01:20:51.120 --> 01:20:58.120]  И у нее опять тоже есть какие-то поддеревья, давайте их назову B, C и D.
[01:20:58.120 --> 01:21:03.120]  Давайте расставим где-нибудь глубины, если здесь была H.
[01:21:03.120 --> 01:21:06.120]  Так, вопрос.
[01:21:06.120 --> 01:21:10.120]  Ой, ой, ой, длинный вопрос.
[01:21:10.120 --> 01:21:15.120]  Да, конечно, мы используем, что инсерт не сделает модуль дельты больше двух.
[01:21:15.120 --> 01:21:19.120]  Но, смотрите еще раз, представьте, что у вас было изначально корректно в L дерево.
[01:21:19.120 --> 01:21:21.120]  И вы сделали один инсерт.
[01:21:21.120 --> 01:21:24.120]  Тогда что поменялось? Ну, понятно, что вы сделали один инсерт.
[01:21:25.120 --> 01:21:32.120]  Но если до этого все дельты были плюс-минус один или ноль, то теперь дельты, самое худшее, что может стать, это дельта стала плюс или минус два.
[01:21:32.120 --> 01:21:38.120]  Потому что у вас все H в худшем случае увеличились на единичку, значит дельты стали максимум плюс или минус два.
[01:21:38.120 --> 01:21:40.120]  Поэтому никакие другие случаи нам не нужны.
[01:21:40.120 --> 01:21:44.120]  Ну, еще раз, вы не забывайте, что у вас исходно было корректно в L дерево.
[01:21:44.120 --> 01:21:47.120]  То есть мы храним корректно в L дерево.
[01:21:47.120 --> 01:21:51.120]  Потом делаем инсерт и быстро, сразу же исправляем сетиз баланс.
[01:21:51.120 --> 01:21:53.120]  Сразу исправляем сетиз баланс.
[01:21:53.120 --> 01:21:55.120]  Оно станет корректным L деревом.
[01:21:55.120 --> 01:21:59.120]  И значит все, что было по дороге, это вот, ну, худший случай, когда дельта была плюс или минус два.
[01:21:59.120 --> 01:22:01.120]  Вот мы сейчас разбежаемся с минус двойкой.
[01:22:01.120 --> 01:22:05.120]  Итак, значит, если здесь было H, то слева H минус три, справа H минус один.
[01:22:05.120 --> 01:22:08.120]  Раз правой, глубже лево на два.
[01:22:08.120 --> 01:22:09.120]  Дальше.
[01:22:09.120 --> 01:22:11.120]  Ну, вот это все.
[01:22:11.120 --> 01:22:13.120]  То слева H минус три, справа H минус один.
[01:22:13.120 --> 01:22:16.120]  Раз правой, глубже лево на два.
[01:22:16.120 --> 01:22:17.120]  Дальше.
[01:22:17.120 --> 01:22:20.120]  У вершинки B левой, глубже права на один.
[01:22:20.120 --> 01:22:23.120]  Поэтому здесь H минус два, здесь H минус три.
[01:22:23.120 --> 01:22:24.120]  Ну, а здесь непонятно.
[01:22:24.120 --> 01:22:27.120]  Здесь есть какие-то два поддерева.
[01:22:27.120 --> 01:22:30.120]  У них глубины H минус три или H минус четыре.
[01:22:30.120 --> 01:22:34.120]  Потому что у этой вершинки C, ну, дельта, это плюс, плюс минус один или ноль.
[01:22:34.120 --> 01:22:36.120]  То есть C мы считаем, что сбалансировано.
[01:22:36.120 --> 01:22:38.120]  У нее дельта равна, дельта хорошая.
[01:22:38.120 --> 01:22:39.120]  Ноль или плюс минус один.
[01:22:39.120 --> 01:22:45.120]  Тогда глубина вот этих вершин B и C, деревьев B и C, это H минус три или H минус четыре.
[01:22:45.120 --> 01:22:48.120]  Тогда здесь работают следующие три подвешения.
[01:22:48.120 --> 01:22:54.120]  Можно сказать так, что мы сначала вращаем в эту сторону относительно этого ребра,
[01:22:54.120 --> 01:22:56.120]  потом в эту сторону относительно этого ребра.
[01:22:56.120 --> 01:22:59.120]  В итоге результат вращения будет такой.
[01:22:59.120 --> 01:23:02.120]  Ну, либо можно просто сказать, что мы делаем такое преобразование из дерева.
[01:23:02.120 --> 01:23:04.120]  Сейчас я все нарисую.
[01:23:04.120 --> 01:23:07.120]  И на этом мы заканчиваем.
[01:23:07.120 --> 01:23:11.120]  B, C, D.
[01:23:11.120 --> 01:23:13.120]  Короче, можно все так преподвесить.
[01:23:13.120 --> 01:23:16.120]  И легко заметить, что опять-таки вариант сохраняется.
[01:23:16.120 --> 01:23:21.120]  Вариант дерева поиска сохраняется.
[01:23:21.120 --> 01:23:25.120]  Значит, это тоже все легко проанализировать.
[01:23:25.120 --> 01:23:28.120]  Ну, либо сказать, что там каждый из этих поворотов, очевидно, сохраняет вариант.
[01:23:28.120 --> 01:23:29.120]  Мы доказали чуть выше.
[01:23:29.120 --> 01:23:31.120]  Ну и так мы, по сути, здесь делали два вот таких поворота.
[01:23:31.120 --> 01:23:35.120]  Либо просто аккуратно все рассмотреть и понять, что здесь никаких конфликтов не возникает.
[01:23:35.120 --> 01:23:39.120]  Ну вот, например, у нас теперь B, это правый сын A.
[01:23:39.120 --> 01:23:42.120]  Ну и раньше B лежало в правом под дереве А.
[01:23:42.120 --> 01:23:44.120]  Поэтому все хорошо.
[01:23:44.120 --> 01:23:46.120]  И так далее все соотношения сохранятся.
[01:23:46.120 --> 01:23:48.120]  Теперь что с глубины?
[01:23:48.120 --> 01:23:51.120]  У больших наших деревьев глубины не меняются.
[01:23:51.120 --> 01:23:54.120]  Здесь h-3, h-4.
[01:23:54.120 --> 01:23:58.120]  Вот здесь у D глубина h-3.
[01:23:58.120 --> 01:24:03.120]  Тогда смотрите, у A глубина в любом случае h-2 вне зависимости от того, какая глубина у B.
[01:24:03.120 --> 01:24:05.120]  То есть там либо h-3, либо h-4.
[01:24:05.120 --> 01:24:07.120]  Но понятно, что максимум все равно равен h-3.
[01:24:07.120 --> 01:24:09.120]  Значит, здесь глубина h-1.
[01:24:09.120 --> 01:24:10.120]  То же самое здесь.
[01:24:10.120 --> 01:24:12.120]  У нас есть глубина h-3.
[01:24:12.120 --> 01:24:14.120]  Есть глубина h-3 или h-4.
[01:24:14.120 --> 01:24:17.120]  Но тогда в любом случае здесь h-2 встает.
[01:24:17.120 --> 01:24:20.120]  И здесь h-1 встанется.
[01:24:20.120 --> 01:24:21.120]  Что с дельтами?
[01:24:21.120 --> 01:24:23.120]  С дельтами все хорошо.
[01:24:23.120 --> 01:24:28.120]  Здесь дельта это либо 0, либо 1.
[01:24:28.120 --> 01:24:30.120]  Потому что левое под дерево всегда больше, чем правое.
[01:24:30.120 --> 01:24:32.120]  Ну, либо равно, либо больше, чем правое.
[01:24:32.120 --> 01:24:35.120]  Здесь дельта это либо 0, либо минус 1.
[01:24:35.120 --> 01:24:38.120]  Потому что левое может быть меньше, чем правое.
[01:24:38.120 --> 01:24:41.120]  Ну, а здесь дельта это просто 0.
[01:24:41.120 --> 01:24:44.120]  Дельта просто 0.
[01:24:44.120 --> 01:24:49.120]  Все. То есть мы получили, что если вот это выполняется, что дельта стала равна минус 2,
[01:24:49.120 --> 01:24:53.120]  то вне зависимости от того, какой дельта у правого сына, плюс-минус 1 или 0,
[01:24:53.120 --> 01:24:56.120]  ну, потому что там все корректно, по предположению.
[01:24:56.120 --> 01:25:00.120]  Какой бы здесь ни было дельта, мы всегда можем сделать 1 или 2 поворота,
[01:25:00.120 --> 01:25:03.120]  так, чтобы во всем этом под дереве уравновесить все дельты.
[01:25:03.120 --> 01:25:06.120]  То есть так его переподвесить, чтобы это было корректно.
[01:25:06.120 --> 01:25:08.120]  Ну и дальше просто поднимаемся снизу вверх.
[01:25:08.120 --> 01:25:13.120]  Каждый раз, когда встречаем плохую дельту, делаем одно из таких преобразований,
[01:25:13.120 --> 01:25:16.120]  чтобы у меня все дельты в этом дереве перебалансировались.
[01:25:16.120 --> 01:25:21.120]  Если дельта это равно 2, то то же самое все, только оно зеркально отраженное.
[01:25:21.120 --> 01:25:25.120]  То есть когда дельта это равно 2, у меня, наоборот, левое под дерево более тяжело, чем правое.
[01:25:25.120 --> 01:25:31.120]  И поэтому мне нужно все вот эти вот картинки как бы зеркально отразить.
[01:25:31.120 --> 01:25:35.120]  То есть, наоборот, нужно поворачивать не правого сына, а левого сына.
[01:25:35.120 --> 01:25:39.120]  Не внука там такого-то и такого, а наоборот.
[01:25:39.120 --> 01:25:44.120]  В общем, это все просто делается в случае, когда у меня...
[01:25:48.120 --> 01:25:51.120]  Сейчас, торможу.
[01:25:51.120 --> 01:25:54.120]  То есть это просто зеркально отражение.
[01:25:54.120 --> 01:25:56.120]  Ну и все, мы с вами все в общем-то сделали.
[01:25:56.120 --> 01:26:00.120]  Мы разобрали все случаи, как нужно вращать, и тогда мы в общем-то любые дисбалансы можем устранить.
[01:26:00.120 --> 01:26:03.120]  И тогда инсерт и рейс, если вот так все поворачивать аккуратно,
[01:26:03.120 --> 01:26:06.120]  то получится, что мы будем сохранять агаритмическую глубину нашего дерева,
[01:26:06.120 --> 01:26:09.120]  а значит на каждый запрос мы отвечаем за логарифт.
[01:26:10.120 --> 01:26:14.120]  Все, я на этом тогда заканчиваю. Если есть вопросы, то пожалуйста, задавайте.
[01:26:14.120 --> 01:26:20.120]  Нужно будет вот эти повороты делать рекурсивно, потому что у нас типа глубина снова изменится,
[01:26:20.120 --> 01:26:24.120]  и вершины более высокой вершины могут измениться.
[01:26:24.120 --> 01:26:29.120]  Да, конечно, нам нужно будет идти вверх, понимать, как изменилась здесь аж, и идти наверх, и там делать поворот.
[01:26:29.120 --> 01:26:31.120]  Да, у нас поворотов может быть много.
[01:26:31.120 --> 01:26:39.120]  А получается, когда дельта от Б равна нулю, там у нас не менялась глубина, и тогда не нужно идти вверх.
[01:26:40.120 --> 01:26:42.120]  Сейчас, одну секунду.
[01:26:42.120 --> 01:26:46.120]  Дельта от Б равна нулю когда? Ну вот там аж и аж.
[01:26:46.120 --> 01:26:53.120]  Нет, нет, посмотрите. Надо всегда идти вверх.
[01:26:53.120 --> 01:26:56.120]  Что значит, что у вас сейчас глубина аж?
[01:26:56.120 --> 01:26:58.120]  Это в частности может означать следующее.
[01:26:58.120 --> 01:27:03.120]  У вас раньше была глубина аж минус один, но вы подвесили какую-то вершинку сюда, и стала глубина аж.
[01:27:03.120 --> 01:27:10.120]  И раз она здесь не изменилась, то она осталась на один больше, чем раньше, и значит вам нужно все равно идти вверх.
[01:27:11.120 --> 01:27:17.120]  Возможно, вот здесь вот это дерево перекособочное, у него один сценарий более глубокий, чем другой.
[01:27:17.120 --> 01:27:21.120]  И вам нужно все равно идти вверх до тех пор, пока все не устранятся.
[01:27:21.120 --> 01:27:24.120]  Из-за одного, отвечая на вопросы из чата, как быстро считать дельту?
[01:27:24.120 --> 01:27:29.120]  Можно просто в каждой вершине хранить аж от В, хранить глубину под дерево.
[01:27:29.120 --> 01:27:31.120]  И вот мы здесь описали, как все эти ажки пересчитываются.
[01:27:31.120 --> 01:27:35.120]  То есть каждый из этих поворотов мы поняли, как меняется аж в каждом под дерево.
[01:27:35.120 --> 01:27:39.120]  Но раз мы знаем аж, то мы знаем, что дельта просто разный сценарий.
[01:27:39.120 --> 01:27:42.120]  И соответственно, мы поднимаемся вверх, знаем аж слева, знаем аж справа.
[01:27:42.120 --> 01:27:44.120]  Тоже знаем, как меняется дельта в каждой вершине.
[01:27:47.120 --> 01:27:52.120]  На семинале будут разобраны случаи, как рассматривать ситуацию с листьями.
[01:27:52.120 --> 01:27:58.120]  Там же будет чуть-чуть посложнее, потому что там глубина листьев с ней посложнее будет.
[01:27:59.120 --> 01:28:06.120]  То есть мы заходим в лист, увеличиваем глубину этого дерева, этого листа, подвешивая к ему новый элемент.
[01:28:06.120 --> 01:28:12.120]  Дальше нам нужно будет от этого листа вызвать первый поворот, если там нарушилось соотношение.
[01:28:19.120 --> 01:28:21.120]  Нет, тут нет никаких особых случаев.
[01:28:21.120 --> 01:28:26.120]  Смотрите, вот была у вас вершинка какая-то, и вы подвесили сюда, например, левого сына.
[01:28:26.120 --> 01:28:28.120]  Был Y, вы подвесили X.
[01:28:28.120 --> 01:28:30.120]  Что стало?
[01:28:30.120 --> 01:28:36.120]  Здесь увеличилась аж отель, увеличилась на единицу.
[01:28:36.120 --> 01:28:40.120]  Тут нет никаких особых случаев.
[01:28:40.120 --> 01:28:46.120]  Рассмотрим вот это текущее под дерево.
[01:28:46.120 --> 01:28:50.120]  Оно как-то изменилось по сравнению с тем, что было до этого.
[01:28:50.120 --> 01:28:51.120]  Аж отель выросло.
[01:28:51.120 --> 01:28:52.120]  Смотрим на дельту здесь.
[01:28:52.120 --> 01:28:56.120]  Если дельта это плюс или минус двойка, то нужно сделать один из двух поворотов.
[01:28:56.120 --> 01:28:59.120]  Тем самым мы убьем дисбалансы все вот здесь.
[01:28:59.120 --> 01:29:01.120]  Потом поднимаемся в родитель этого дерева.
[01:29:01.120 --> 01:29:04.120]  Мы знаем, какая глубина у этого под дерева.
[01:29:04.120 --> 01:29:06.120]  Значит, знаем, какая глубина у этого под дерева.
[01:29:06.120 --> 01:29:07.120]  Знаем, какая там дельта.
[01:29:07.120 --> 01:29:10.120]  Если это плюс или минус двойка, то делаем один из двух поворотов.
[01:29:10.120 --> 01:29:12.120]  И так далее поднимаемся вверх.
[01:29:12.120 --> 01:29:14.120]  Тут нет никаких особых случаев.
[01:29:14.120 --> 01:29:17.120]  И даже для листика подвесили.
[01:29:17.120 --> 01:29:20.120]  Сразу просто запускаем одну и ту же процедуру для вот этой вершинки.
[01:29:20.120 --> 01:29:23.120]  Просто вот этот поворот, если нужно.
[01:29:23.120 --> 01:29:25.120]  Ага, спасибо, понятно.
[01:29:25.120 --> 01:29:29.120]  Доску могу скинуть, да.
[01:29:29.120 --> 01:29:32.120]  Так, вот этот слайд, кто просил?
[01:29:32.120 --> 01:29:35.120]  С другими случаями дельта 1? Нет.
[01:29:35.120 --> 01:29:37.120]  Дельта 1 у меня...
[01:29:37.120 --> 01:29:39.120]  Мы это дерево...
[01:29:39.120 --> 01:29:44.120]  Мы храним типа как указатели просто на детей.
[01:29:44.120 --> 01:29:47.120]  То есть мы как бы структуру заводим.
[01:29:47.120 --> 01:29:49.120]  И у нас там просто есть...
[01:29:49.120 --> 01:29:51.120]  Да, ссылка влево, ссылка влево.
[01:29:51.120 --> 01:29:54.120]  Так, и вот дельта 2 равно единице.
[01:30:03.120 --> 01:30:05.120]  Почему это вращение?
[01:30:05.120 --> 01:30:07.120]  Ну, это такое...
[01:30:07.120 --> 01:30:10.120]  Это не... неформальное объяснение.
[01:30:10.120 --> 01:30:13.120]  Ну, грубо говоря, вот представьте, да, значит...
[01:30:13.120 --> 01:30:15.120]  Что мы делаем?
[01:30:15.120 --> 01:30:20.120]  Есть А, есть левый сын, есть Б, есть Б большой, есть С большой.
[01:30:20.120 --> 01:30:24.120]  Я хочу вот так вот провернуть вокруг этого рябра.
[01:30:24.120 --> 01:30:29.120]  Ну, тут сложно без как бы показывания руками что-то сделать.
[01:30:29.120 --> 01:30:33.120]  Ну, вот представьте, что у вас эта штука, это какой-то шарничек, который можно двигать.
[01:30:33.120 --> 01:30:35.120]  А это там, не знаю, какие-то шарики.
[01:30:35.120 --> 01:30:37.120]  А А маленькая, Б маленькая, это какие-то шарики.
[01:30:37.120 --> 01:30:40.120]  Вот представьте, что у меня есть шарики.
[01:30:40.120 --> 01:30:43.120]  То есть вы его просто повернули, как бы подняли Б.
[01:30:43.120 --> 01:30:45.120]  А А как будто бы оставили на месте.
[01:30:45.120 --> 01:30:47.120]  Тогда шарнир у вас выглядит вот так.
[01:30:47.120 --> 01:30:49.120]  Значит, дальше что происходит?
[01:30:49.120 --> 01:30:52.120]  У вас А большое остается слева, С большое остается справа.
[01:30:52.120 --> 01:30:54.120]  Теперь только вопрос, что происходит с Б.
[01:30:54.120 --> 01:30:56.120]  Ну, вот Б мы как бы отрезаем отсюда, потому что...
[01:30:56.120 --> 01:31:00.120]  Ну, он же не может отсюда дальше расти, потому что начались будет степень 3.
[01:31:00.120 --> 01:31:06.120]  Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
[01:31:06.120 --> 01:31:10.120]  То есть, по сути, это просто вращение как бы отрезка, вращение такого шарнирчика.
[01:31:10.120 --> 01:31:12.120]  И еще переподвешение одного из подделев.
[01:31:12.120 --> 01:31:15.120]  Переподвешение Б большого к А маленькому.
