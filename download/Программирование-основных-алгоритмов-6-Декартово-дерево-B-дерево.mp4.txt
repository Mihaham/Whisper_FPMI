[00:00.000 --> 00:12.160]  Сегодня у нас с вами шестая лекция, то есть мы уже прошли с вами треть семиастра, и это была
[00:12.160 --> 00:21.240]  самая простая треть. Дальше будет только хуже, так что не расслабляйтесь. Окей, так,
[00:21.240 --> 00:31.620]  7-12, да, так, лекция 6. И мы продолжаем изучать деревья поиска. Сегодня у нас будет два
[00:31.620 --> 00:39.200]  новых дерева. Ну, если успеем, то может быть чуть третье заденем. Это будет декартовое дерево
[00:39.200 --> 01:02.840]  и Б-дерево. Вот, ну давайте начнем с первого. Давайте определение. Декартовое дерево,
[01:02.840 --> 01:26.520]  это бинарное дерево, бинарное подвешенное дерево. Оно будет хранить в себе пары внезапно. Вот,
[01:26.520 --> 01:41.640]  мы привыкли, конечно, на сток ключей, а теперь у нас будут пары, хранящие пары x и y, где x мы
[01:41.640 --> 01:53.520]  будем называть ключом, а y это приоритет. И в чем, собственно, суть этого дерева? В том,
[01:53.520 --> 02:17.480]  что по x это будет дерево поиска. Дерево поиска. А по y это будет бинарная куча,
[02:17.480 --> 02:31.360]  или бинарная пирамида. Русский язык достаточно богатый, а декартовое дерево как-то слишком
[02:31.360 --> 02:38.880]  долго, поэтому у него есть куча разных названий, которые соединяют в себе бинарная куча, то есть
[02:38.880 --> 02:46.280]  куча и дерево. Можете подумать сами названия, которых объединяют. В одно слово дерево и куча
[02:46.760 --> 02:53.960]  получите разные варианты. Вот, например, дуча. Можно по-другому их слить, вот вы получите тоже
[02:53.960 --> 03:03.680]  прикольное слово. Вот, по-английски его называют трип. Ну, не тот трип, который вы могли подумать,
[03:03.680 --> 03:18.280]  это дерево плюс кип куча. Вот. Окей, и зачем вам все это надо? Ладно, вопрос сложный, давайте сначала
[03:18.280 --> 03:25.400]  поймем вообще как это выглядит. И внезапно, почему это дерево называют декартовым,
[03:26.400 --> 03:39.880]  ну и там нарисуем какие-нибудь пары. Не знаю, какие у нас будут пары. Давайте 1-3, 2-4, 3-1, 5-7 и не знаю,
[03:39.880 --> 03:46.920]  что-нибудь такое, типа 4-6 какой-нибудь. Такой вот набор пар. То есть по х у нас будут ключи,
[03:46.920 --> 03:51.080]  по y приоритеты. Давайте отметим их на этой карандатной плоскости, чтобы посмотреть,
[03:51.080 --> 04:10.320]  как это дерево выглядит. Блин, у меня по y 7, если не влезет так много. Ну, поменяем.
[04:10.320 --> 04:34.880]  О, идеально. Так, по x1, по y3 это здесь, по x2, по y4 это где-то здесь. Так, и вот так вот. То есть
[04:34.880 --> 04:39.080]  вот наши вершинки дерева на декартовой плоскости. Давайте посмотрим, как ребра проведены.
[04:41.000 --> 04:50.960]  Так у нас по y это внезапно куча, значит у нас в корне минимум стоит. Вот. Значит этот корень,
[04:50.960 --> 04:59.840]  у него дети сюда и сюда, причем идут к минимальной y. Вот так вот, раз, два. Дальше здесь будет отсюда.
[04:59.840 --> 05:06.240]  Будет вести влево-вправо, справа никого нет больше, поэтому будет только сюда вести
[05:06.240 --> 05:17.840]  ребро. Ну, здесь вот такое у вас дерево получилось. Понятно, примерно? Вот, геометрически это выглядит
[05:17.840 --> 05:22.720]  так. Это первое дерево, растущее вверх у программистов. У нас получилось с вами, обычно они вниз растут.
[05:22.720 --> 05:33.280]  Вот. И теперь хочется понять, зачем нам это надо. Ну, замысел будет наш простой. Мы введем две
[05:33.280 --> 05:39.360]  новые операции split и merge и внезапно выясним, что они очень хорошо реализуются на этих деревьях,
[05:39.360 --> 05:53.520]  а потом через них выразим все остальное. Давайте операция split по дереву и ключу. То есть дерево
[05:53.520 --> 06:09.840]  t ключ x, она вас ведет в t1 и t2 такие, что те ключи, ну давайте здесь поставим равенство, меньше либо равно x,
[06:09.840 --> 06:17.000]  а вот t2 строго больше, чем x. То есть у вас есть два дерева, которые распилины как-то по x. Ну,
[06:17.000 --> 06:23.760]  например, что-то вот такого вот. Хочу вот так вот распилить его. То есть у меня здесь вот одно будет
[06:23.760 --> 06:29.960]  дерево, здесь другое будет дерево. И он будет корректным. Вот здесь вот 1, 2, 3, 4, это будет по
[06:29.960 --> 06:52.440]  одном дереве, здесь в другом. Ну, давайте подумаем, как будет это выглядеть. То есть как-то вот так у нас
[06:52.440 --> 07:01.400]  устроено наше дерево прекрасное. Этот корень, там его дети, и мы хотим его разбить по кому-то ключу x. Давайте подумаем,
[07:01.400 --> 07:17.840]  как будут образованы деревья. Ну, допустим, давайте мы этого чувака обозначим за r, корень это будет l. Ладно,
[07:17.840 --> 07:28.680]  давайте не r, какой-нибудь p, а это r, потому что правый, левый и primary, типа главный. Допустим,
[07:28.680 --> 07:40.080]  p.x, давайте здесь k, чтобы у нас не было путаний с этими ключами. Вот, допустим,
[07:40.080 --> 07:49.280]  что p.x окажется меньше, чем k. Ну, строго. То есть мы хотим как-то вот так вот разрезать наше
[07:49.280 --> 08:00.520]  дерево. Как-то вот так вот хотим. Ну, или там будет правее проходить эта линия разреза, это не особо важно,
[08:00.520 --> 08:12.360]  главное, что он справа от этого. Тогда куда пойдет узел p? В t1 или в t2? В t1. И кто будет левым под
[08:12.360 --> 08:27.720]  деревом в t1? Вот это вот все дело. Поэтому говорим, что t1 root равно p. А как дальше разобраться? Как
[08:27.720 --> 08:35.920]  будет устроено t2 и правый ребенок в t1? Ну, да, рекуссивно узнаем split от ребенка просто.
[08:35.920 --> 09:01.840]  t1.root.right.t2 равно split от rk. То есть вы просто рекуссивно
[09:02.000 --> 09:10.720]  сплит отсюда. Ну, понятное дело, что если у вас здесь другой знак, то есть больше либо равно, вы
[09:10.720 --> 09:16.000]  делаете все симметрично. В тонущей студии наоборот. То есть у вас однозначно определяется вот эта вот
[09:16.000 --> 09:28.200]  часть, а вот эта вот будет рассекаться на две. Итого, сколько действий мы здесь делаем? Ну да,
[09:28.200 --> 09:34.680]  от 1 на каждый узел и при этом каждый вызов сплит вызывает нас на 1 вниз рекуссивно. Поэтому от h.
[09:34.680 --> 09:55.880]  Правый ребенок в t1. Да, t1 t2. Вот видите, здесь t1, здесь t2. Вот, он как бы рекуссивно себя вызывает.
[09:55.880 --> 10:01.440]  Ну, понятное дело, что если вы вызвались от пустого дерева, то вернее два пустых дерева. Вот база рекурсии,
[10:01.440 --> 10:14.120]  так сказать. Потому что у вас вот это вот неравенство выполнено. То есть смотрите,
[10:14.120 --> 10:20.160]  еще раз. Вы поймете, допустим, что вот так вот. То есть у вас линия разреза как-то так
[10:20.160 --> 10:33.040]  проходит. Тогда вот у вас вот эта вот часть, вот этот кусочек и вот это вот все пойдет в t1.
[10:33.040 --> 10:38.040]  Поэтому про t1 вам известно, что вот эта вот будто бы левая часть, а правая образована вот
[10:38.040 --> 10:44.520]  этим вот кусочком оставшимся. И чтобы его вычинить, вам нужно разрезать r. Вот этот вот узел.
[10:44.520 --> 10:56.000]  Вот. Окей, поехали. Вторая операция. Эта операция merge. Давайте я здесь напишу.
[10:56.000 --> 11:25.280]  Она принимает два дерева и внезапно возвращает одно. При этом все ключи t1 меньше всех ключей
[11:25.280 --> 11:34.120]  t2. То есть у вас есть два дерева. В одном, грубо говоря, одно находится строго левее другого. Вот
[11:34.120 --> 11:42.800]  если у вас есть два таких дерева, вы их можете слить в одно дерево. Как это делать? Давайте посмотрим.
[11:42.800 --> 12:03.840]  Типа такого. Это будет снова p, lr. Только p1 или 1r1, потому что у нас будет здесь первое дерево и второе
[12:03.840 --> 12:26.760]  дерево будет. p2, l2, r2. Ну, давайте подумаем с вами, что есть у каждого дерева? Отлично, корень. Кто из этих
[12:26.760 --> 12:37.880]  двух чуваков может быть корнем? Ну да, потому что у нас еще должно быть куча при этом. Допустим,
[12:37.880 --> 12:49.800]  p1.y меньше, чем p2.y. Иначе будем делать симметрично. То есть допустим, вот этот
[12:49.800 --> 13:00.480]  чувак должен быть корнем. p1. Что нам известно дальше? Кто может быть в левом поддереве t1?
[13:00.480 --> 13:10.880]  Почему p2 может быть? У вас известно, что у вас вот такое вот соотношение на ключи?
[13:19.800 --> 13:28.680]  Ну да, потому что смотрите в чем прикол. Потому что у вас вот здесь вот все ключи больше, чем все вот здесь вот. То
[13:28.680 --> 13:35.800]  есть неподавна больше, чем p1. А это значит, что все они пойдут вот сюда вот. А все, кто меньше чем p1,
[13:35.800 --> 13:44.840]  они все вот здесь вот находятся. Они все пойдут вот сюда вот. Вот, эта часть нам известна. То есть мы
[13:44.840 --> 14:01.280]  говорим, что t-root равно p1. Теперь осталось определить правого ребенка. Кто будет правым ребенком?
[14:01.280 --> 14:17.720]  Да, давайте замерзим просто. Да и все. Он уже умеет делать. Давайте замерзим вот это вот и p2. И все,
[14:17.720 --> 14:23.080]  мы себя будем гарантировать. Но, понятное дело, если у вас одно из деревьев пустое передается в мерзь,
[14:23.080 --> 14:32.520]  вы должны вернуть другое. Если вы пустое, верните пустое дерево. Вот база рекурсии. Равно мерзь от
[14:32.520 --> 14:44.800]  чего будет? от r1 p2. Все. Ну, если симметрично у вас, то вы все делаете опять же. Вот здесь, если у вас не
[14:44.800 --> 14:50.680]  равенство в другую сторону, вы делаете, что у вас вот эта вот часть известна, а вот эти вот две сливаются.
[14:53.240 --> 14:59.400]  Ну, понятное дело, время работы тогда какое. Так и не разных высот у вас могут быть.
[15:01.960 --> 15:07.160]  Почему максимум? Вы можете здесь на один уровень спуститься, здесь на один уровень спуститься. Да.
[15:07.160 --> 15:26.080]  Ну, вроде бы все просто. Сплит и мерзь есть. Но вопрос, зачем они нам нужны, не очень понятен.
[15:26.080 --> 15:31.600]  Ведь мы же хотели делать другие операции изначально. Мы хотели insert и erase.
[15:31.600 --> 15:43.600]  Да, давайте выразим остальные операции через insert и erase, через сплит и мерзь.
[15:43.600 --> 15:57.800]  Так, insert. Ну, принимает дерево и ключ к. Как его сделать? Предлагается следующее.
[15:57.800 --> 16:12.600]  Первый шаг это сделать сплит по т к, получить т1 и т2. Ну, понятное дело, если у вас ключ к уже
[16:12.600 --> 16:17.200]  будет, то там не надо его вставлять, поэтому можете вызвать find перед этим. Допустим,
[16:17.360 --> 16:34.080]  ключа к нет в дереве, тогда у вас выполнено вот такое вот неравенство. Ну, я здесь немножко
[16:34.080 --> 16:37.320]  некорректно, потому что у вас типа здесь множество, здесь множество, потому что я сравниваю с каким-то
[16:37.320 --> 16:42.360]  имптом. Ну, поэтому иметь в виду, что все элементы множества меньше, чем ключ к, меньше, чем все другие
[16:42.360 --> 16:49.360]  элементы множества. Поэтому шаг второй это сделать вот такой вот мерзь интересный.
[16:49.360 --> 17:10.600]  Вроде бы все так и ускобки. То есть вы сливаете вот эти вот два дерева в одно и дальше к этому
[17:10.600 --> 17:23.400]  проливаете сюда. Что такое? Что? Вот. Это оставим вопрос открытым пока что. Потому что изначально
[17:23.400 --> 17:28.600]  для пользователя по-хорошему, когда вы пишете дерево поиска, он не должен вздумываться о том,
[17:28.600 --> 17:34.240]  как оно внутри устроено. Он должен знать, что есть find, insert и erase. То есть генерация приоритетов
[17:34.240 --> 17:39.040]  будет на вашей стороне на самом деле. Вы как-то будете по ключу генерировать приоритет,
[17:39.040 --> 17:46.280]  по тому, который вам подают. Вот. А как это правильно делать, мы обсудим сами буквально через минут 5,
[17:46.280 --> 17:53.840]  когда дойдем до этого. Вот. Окей, теперь давайте разберемся второй. Со вторым вариантом это erase.
[17:53.840 --> 18:22.600]  Как делать erase? Давайте считать, что ключка, во-первых, там есть. Получаем T1, T2.
[18:24.200 --> 18:32.960]  Так, мы определяли split, чтобы у нас ключка попадал в T1, если он есть. Окей.
[18:44.960 --> 18:51.520]  Давайте подумаем с вами. Ключка, он лежит в T1. Согласны ли вы с таким вот утверждением?
[18:51.520 --> 19:19.880]  Что? Ну вот оно описано. Что ключка совпадает с максимальным ключом в T1. Да. Ну вы создаете
[19:19.880 --> 19:27.400]  дерево по… Ну смотрите. Разумеется, что у вас есть… Я могу говорить слово конструктор? Ну я не знаю,
[19:27.400 --> 19:33.080]  вдруг вам еще не рассказали, что такое конструктор. Хорошо, вы хотите создать дерево просто по ключу K.
[19:33.080 --> 19:38.360]  Разумеется, только вот это вот здесь. То есть вы создаете единственный узел и говорите,
[19:38.360 --> 19:46.680]  что теперь это дерево из одного узла. Вот. То есть K – это максимальный ключ здесь. То есть у вас
[19:46.680 --> 20:03.240]  вот это есть дерево. T1. Вот у вас ключ K. Какой-нибудь Y, не знаю, приоритет у него. И у него правого ребенка
[20:03.240 --> 20:11.160]  быть не может. Потому что он максимальный, иначе был бы кто-то больше. Поэтому у вас есть только вот так
[20:11.320 --> 20:17.640]  вот. Левое под дерево у него. Раз у него есть только левое под дерево, ну давайте мы просто возьмем и
[20:17.640 --> 20:25.320]  выкинем этого чувака и вот это вот перестаем сюда. Ну как мы делали в наивном дереве поиска,
[20:25.320 --> 20:36.160]  удаление узла с одним ребенком. Просто брали, вырезали и ставили ребенка на место. Поэтому шаг
[20:36.160 --> 20:57.560]  второй. Делаем удаление K из T1, как в наивном дереве поиска. Вот. Так как у этого ключа будет
[20:57.560 --> 21:06.160]  лишь один ребенок. Так давайте я все-таки это сотру, чтобы оно никак тут не было похоже на X
[21:06.160 --> 21:09.920]  какой-нибудь. Вот. То есть у вас здесь нет ребенка, у вас только левый ребенок. Поэтому здесь все легко
[21:09.920 --> 21:16.280]  будет удаляться. Причем вы даже знаете, что у вас этот узел является левым сыном. То есть вообще
[21:16.280 --> 21:28.760]  все легко будет. Ну и шаг третий. Это мерч. Давайте скажем, что это переведет нас в T1 штрих,
[21:28.760 --> 21:44.680]  без элемента. Дальше вы делаете мерч в T1 штрих и T2. Это конечно классно, но есть более крутой
[21:44.680 --> 21:57.840]  способ сделать и рейс. Это целых три операции. Два сплита и мерч. У вас здесь один сплит, один мерч.
[21:57.840 --> 22:13.720]  Да, именно так. Поэтому второй вариант реализации рейс. И все-таки мне не хватило досок.
[22:13.720 --> 22:39.240]  Это смотрите. Это вот ваше прекрасное дерево. Вот вы здесь как-то дошли до пары KY. У него могут
[22:39.240 --> 22:50.360]  быть дети, может не быть детей. Нам не особо это важно. Как-то вот так вот он устроен. То есть шаг
[22:50.360 --> 23:14.840]  первый. Предлагается сделать find от дерева T, ключа K. Получите пару KY. Получим узел KY,
[23:15.720 --> 23:28.360]  то есть что у вас есть указательный этот узел. Шаг второй. Давайте обзовем L и R его детей. Делаем
[23:28.360 --> 23:49.800]  мерч от LR. Ну и шаг третий. Когда вы сделали мерч от LR, что нужно сделать? Заменить узел KY на,
[23:49.800 --> 24:04.600]  давайте это C обозначим. Результат типа child. Все. То есть вы вырезаете этот узел, вот у вас
[24:04.600 --> 24:10.840]  здесь какой-то родитель, там не знаю есть, и вот так вот P. И вы говорите, что ребенок P вместо
[24:10.840 --> 24:20.040]  вот этого узла, это мерч от двух его детей. И заметьте, здесь у вас, если здесь у вас выполняется
[24:20.040 --> 24:29.480]  одна операция за высоту. Тра-та-та, другая операция за высоту. Здесь у вас find спустился,
[24:29.480 --> 24:35.280]  а мерч дальше выполняется лишь за вот эту вот часть, за вот эту вот высоту. То есть за вот эту
[24:35.280 --> 24:42.000]  вот маленькую штуку на самом-то деле. Поэтому суммарно вы все делаете за одну высоту, а не за две или
[24:42.000 --> 24:48.040]  там если спитить пока, пока минус один и мерч, вообще за три. То есть такой вот очень быстрый вариант.
[24:48.040 --> 24:59.840]  Утверждается, есть короче теорема, которую мы доказывать не будем. Ее доказали буквально,
[24:59.840 --> 25:07.600]  ну в этом году, я не вспомню когда точно. Которая говорит, что здесь вообще очень мало будет на самом
[25:07.600 --> 25:19.320]  деле. Не, мы сейчас с вами скажем одну теорему, потом я скажу ее усиление для этого случая. Ну как,
[25:19.320 --> 25:25.120]  я попытаюсь сформулировать, но заточенность не ручаюсь. Потому что там очень сложная теорема,
[25:25.200 --> 25:37.640]  но точнее она сложно формулируется. Собственно смотрите, мы все говорим в терминах высоты,
[25:37.640 --> 25:45.200]  но кто нам вдруг вообще сказал, что у нас это дерево логарифмично по высоте? Это же вообще не
[25:45.200 --> 25:51.200]  очевидно. В ОВЛ было понятно, мы всегда там поддерживали разность высот маленькой, поэтому
[25:51.200 --> 25:55.600]  все было хорошо. А здесь почему не может быть такого, что у нас дерево бамбуком станет?
[25:55.600 --> 26:06.960]  Логично, да, но как выбрать приоритеты, чтобы при любом наборе ключей все было хорошо?
[26:06.960 --> 26:17.080]  Какую серединку? Какую высоту нет? У нас нигде не хранится высота. Вот мы не хотим ничего больше
[26:17.080 --> 26:35.080]  менять дерева. Вот можно случайно. Есть теорема о высоте. Вот был бы здесь, только второй курс мы
[26:35.080 --> 26:42.240]  бы доказывали, но здесь есть первый курс, поэтому доказывать мы не будем в курсе. Она звучит так,
[26:42.240 --> 27:00.240]  если приоритеты выбираются независимо из равномерного распределения,
[27:00.240 --> 27:24.800]  распределения, чей домен по мощности превосходит размер дерева,
[27:24.800 --> 27:51.680]  дерево, то мотождание, что? Я сейчас скажу все это, подождите. Мотождание высоты составит от
[27:51.680 --> 28:04.320]  log n. Теперь я поясню все слова, которые здесь входят. Ну, независимо, мы с вами уже говорили вроде бы,
[28:04.320 --> 28:09.680]  что имеется в виду здесь по словам независимо знать, что у вас все выборы приоритетов никак не
[28:09.680 --> 28:15.640]  зависят друг от друга. То есть, например, вы каждый раз случайно подбрасываете кубик и брать приоритет
[28:15.640 --> 28:22.440]  до 6. Вот это независимо равномерно оценивать, что у вас любой возможный приоритет равновероятен.
[28:22.440 --> 28:26.520]  Как правило, вы их выбираете из какого-то конечного множества. Обычно это 0, 1,
[28:26.520 --> 28:37.000]  не знаю, какой-нибудь там, значит, у игр большой минус 1. Вот. Это ваше множество возможных приоритетов.
[28:37.000 --> 28:44.600]  Вот если вы выбираете независимо друг от друга, причем все числа с равновероятностью из этого
[28:44.600 --> 28:50.320]  множества то, это значит, что независимо равномерного распределения. Что здесь домен? Домен
[28:50.320 --> 28:58.440]  производит краски вот это множество. Откуда вы можете выбрать приоритеты? Все. То есть домен по
[28:58.440 --> 29:06.600]  мощности превосходит, это значит, что у вас n всегда меньше либо равно, можно строго меньше, чем вот этот
[29:06.600 --> 29:17.960]  у большой. Ну, понятное дело, что это заведомо выбрать нельзя, но это очевидно плюс-минус. Но
[29:17.960 --> 29:23.640]  понятное дело, что можно там сделать какую-нибудь оценку, что у вас там, ну, явно дерево не будет
[29:23.640 --> 29:30.080]  больше чем 10.9, допустим, по размеру. Значит, у можно взять как 2 на 10.9 и все будет хорошо.
[29:30.080 --> 29:37.880]  И утверждается тогда, что в среднем высота будет от log n. Вот сейчас в последних парт тут видно,
[29:37.880 --> 29:47.360]  а то он совсем умер, этот маркер под конец. Хорошо. Вот, вот так вот это надо понимать. То есть в
[29:47.360 --> 29:50.480]  среднем здесь все за логрейвом будет делаться, но бывают случаи, когда эта штука действительно
[29:50.480 --> 29:57.480]  похожа на бамбук. Вот. Опять же, был бы только второй курс, мы бы считали бы все эти вероятности,
[29:57.480 --> 30:02.560]  когда он там станет бамбуком и так далее. Развал в контесте задача. Почитать вероятность получить
[30:02.560 --> 30:16.160]  дерево высоты h на n элементах. Но, к сожалению, такого нет. Во второкурснике вас спасает первый
[30:16.160 --> 30:26.520]  курс. Радуйтесь. Так. То есть у нас получается высота в среднем log n. Значит, все операции
[30:26.520 --> 30:35.520]  сплит, мерч insert и рейс за log n работают. Более того, есть такое утверждение, доказанное в этом году,
[30:35.520 --> 30:46.680]  что в среднем высота каждого из LR от 1 составит. На самом деле. Но это такое сильное утверждение,
[30:46.680 --> 30:51.280]  которое доказывается сложным, и там куча других условий еще допомнительно накладывается. Утверждается,
[30:51.280 --> 30:56.200]  что там вообще все будет быстро. Вот именно при таком случае. Не при том и рейзе на дальней доске,
[30:56.200 --> 31:06.560]  а вот про это вот. Поэтому пишите вот так вот. Как там не пишите. Ну, я доказать-то не могу. Это
[31:06.560 --> 31:17.520]  в среднем. Имеется в виду вероятность там берется по всем возможным приоритетам, под множеством,
[31:17.520 --> 31:22.640]  по всем возможным узлам, которые будут спрашивать у вас. Узнается, что в среднем там будет маленькая
[31:22.640 --> 31:29.240]  высота. Вот. Ну, если вы очень хотите, я вам скину ссылку на статью. Там по-моему страница 20.
[31:29.240 --> 31:38.160]  Вот. Там типа несколько разделов. Вот это теория. Мы под номером 4.7. Так что вам нужно прочитать
[31:38.160 --> 31:44.920]  много теорий до этого будет. Поэтому я не доказываю. Потому что только в этом году я доказал. Так.
[31:44.920 --> 31:56.920]  В том, что если они случайны, то у вас как-то все в среднем сбалансируется. Так нет,
[31:56.920 --> 32:03.960]  ты его выбрал один раз и все. Фиксировано. Для каждого узла. Вот. Есть задача интересная.
[32:03.960 --> 32:09.640]  Вот смотрите в мерже, который я тут стер. Вот он тут был, да. Вот там было сравнение приоритетов,
[32:09.640 --> 32:17.720]  да. Вот утверждается, что если вы замените сравнение приоритетов на подброс монетки 50 на 50,
[32:17.720 --> 32:24.640]  то вроде как здесь ничего не меняется на самом деле. То есть вы можете вместо выбора
[32:24.640 --> 32:36.720]  приоритетов подбрасывать монетку просто здесь, в каждом мерже. Вот. Ну, у вас мерж работает,
[32:36.720 --> 32:47.480]  используя приоритет, их сравнивает. Ну в смысле, ну мы так и будем делать, в этом и суть. У нас не будет
[32:47.480 --> 32:53.200]  кого-то специального алгоритма, который будет выбирать за нас. У нас будет вот подброс монетки,
[32:53.200 --> 33:02.480]  это у какого-то Y грандного кубика, который будет нам выдавать чиселку и мы будем называть ее приоритетом.
[33:02.480 --> 33:18.520]  Почему? А почему нет? Почему это? Куча было меньше либо равно всегда. Ну все. То есть у вас вот
[33:18.520 --> 33:26.360]  такого дерева, например, куча является. Поэтому одинаковый приоритет допустимый. Вот. У вас будет
[33:26.360 --> 33:32.360]  на семинарах задача про то, что если все X попарно различны и все Y попарно различны,
[33:32.360 --> 33:40.240]  то существует лишь единственное дерево на таких X-Y, на таких парах. А если Y могут быть
[33:40.240 --> 33:46.040]  одинаковые, то таких может быть много деревьев. Так. Ну про дикартовое дерево мы закончили говорить.
[33:46.040 --> 33:52.560]  Ну там еще на семинарах до конца договорите про него, уже там не очень интересно. Сейчас нас
[33:52.560 --> 34:02.280]  интересует другое. Это B дерево. Собственно, перед тем, как мы вообще поймем, зачем это нужно,
[34:02.280 --> 34:08.120]  и поймем вообще, что это такое, давайте забудемся о следующем. Вот какие у вас виды памяти есть в
[34:08.120 --> 34:18.800]  нашем компьютере, ноутбуке. Есть стековая, есть куча, да, оперативка так называемая. Есть еще
[34:18.800 --> 34:25.200]  жесткий диск. И вот есть как бы такая проблема интересная, что оперативка, она вроде бы
[34:25.200 --> 34:32.240]  быстрая, но она там не очень большая по размерам. Там несколько гигабайт, да. Допустим, даже 64 гига
[34:32.240 --> 34:37.400]  у вас оперативка. Я не знаю, зачем она такая, но допустим, она у вас такая и есть. Такая как жесткий
[34:37.400 --> 34:41.600]  диск, он там, ну, понятное дело, там до терабайта у вас может доходить, ну, чуть-чуть побольше.
[34:41.600 --> 34:49.360]  Вообще в реальной жизни такое бывает, что ваши данные не влезают в оперативку, а влезают только
[34:49.360 --> 34:58.200]  в жесткий диск. А жесткий диск, он все-таки так устроен, что это, грубо говоря, диск. Внезапно.
[34:58.200 --> 35:03.880]  То есть как бы он так устроен, что у вас здесь есть какие-то вот такие блины, насаженные на общий
[35:03.880 --> 35:14.040]  стержень. Есть там что-нибудь типа такой вот головки читающие по нему. И понятное дело,
[35:14.040 --> 35:20.040]  что скорость чтения очень ограничена. Ограничена не в плане вашим возможностям, ограничена
[35:20.040 --> 35:25.680]  физической скоростью вращения этих дисков, чтобы ваш жесткий диск не разлетался. Физики, я думаю,
[35:25.680 --> 35:30.960]  понимают, что если ее очень сильно расскрутить, то может быть очень плохо. Вот. И как бы
[35:30.960 --> 35:41.560]  и с оперативкой скорость этого доступа вообще несравнима. Вот, по некоторым замерам скорость
[35:41.560 --> 35:47.840]  доступа к оперативке несколько раз быстрее, чем к жесткому диску. И в этом мы приходим этим
[35:47.840 --> 35:51.920]  самым к идее, что нам нужно считать не только время, которое тратится в оперативке самой,
[35:51.920 --> 35:58.520]  но еще и время, которое тратится, собственно, на сами доступы к диску. Потому что это очень долгие
[35:58.520 --> 36:06.960]  операции. Вот. И поэтому от и бы дерева краски созданы для того, чтобы хранить данные на каких-то
[36:06.960 --> 36:13.440]  вот таких вот носителях, которым, скажем так, у нас есть один большой носитель, который все
[36:13.440 --> 36:20.040]  вмещает. Вот. Есть оперативка отдельная, в которой мы можем там маленький объем загрузить. Вот.
[36:20.040 --> 36:26.360]  Дерево как бы реализует эту идею, чтобы нам пришлось как можно меньше лезть в сам диск. Вот. Потому
[36:26.360 --> 36:31.360]  что если это обычные деревья поиска, то нам бы пришлось бы за логарифм вот этот спускаться,
[36:31.360 --> 36:35.640]  и каждый этот спуск, это чтение с диска было бы. Потому что мы бы сравнивали бы с вами ключ.
[36:35.640 --> 36:41.600]  То есть, помните операция Find? Она берет ключ в узле и сравнивает там что-то. Идет либо влево,
[36:41.600 --> 36:49.480]  либо вправо. Проблема в том, что с точки зрения, если расписывать это подробнее, то есть вот наша
[36:49.480 --> 37:05.480]  была Find от node, node, не знаю, intk какой-нибудь. Что мы с вами делали? У нас был какой-то там вот
[37:05.480 --> 37:32.840]  такой вот код, что if not left меньше, чем k, то делай Find at node left k.
[37:32.840 --> 37:49.600]  Иначе, делай. Иначе, если там node value. Давайте напишем самую неэффективную версию сначала.
[37:49.600 --> 38:11.040]  Если это больше k, то там Find, вот там право. Иначе, там что-нибудь типа return true не знаю.
[38:11.040 --> 38:19.440]  Как-нибудь это отметить. Считайте, что это псевдокод и не претендуют на корректность.
[38:19.440 --> 38:26.520]  Окей, то есть смотрите, что мы с вами делали. Мы с вами должны были прочитать. Вот у нас есть
[38:26.520 --> 38:33.200]  нода, она лежит в оперативке на самом деле. А node left может вообще лежать где-то на диске. Внезапно.
[38:33.200 --> 38:38.640]  Потому что у нас вообще может не влезать в оперативку много чего. У нас может лезть в оперативку
[38:38.640 --> 38:44.600]  нода и k. И допустим, у нас может влезть 3-4 ноды в оперативку. Все, больше ничего влезть не
[38:44.600 --> 38:49.920]  может. Потому что внутри лежат вот этот вот k, это не int, не знаю какой-нибудь, а что-нибудь вообще огромное.
[38:49.920 --> 38:59.280]  Какая-нибудь огромная строка или еще что-нибудь. Что вы хотите тогда? То есть,
[38:59.280 --> 39:07.480]  по идее, вот здесь, когда вы берете node left, у вас здесь происходит чтение диска.
[39:07.480 --> 39:20.560]  Здесь, понятно, find, он там рекурсивно почитает себя. Дальше здесь у вас происходит чтение с диска.
[39:20.560 --> 39:28.520]  Во-первых, эта реализация не эффективна тем, что у вас есть целых два чтения с диска.
[39:28.640 --> 39:37.840]  Можно же поменять else if node value совпало с k? Подождите, а почему здесь left и right пишу?
[39:37.840 --> 39:49.560]  Господи, а мне никто не поправил. Это все полная лажа. Что-то увлекся, извините.
[39:49.560 --> 39:56.200]  Конечно, здесь просто value надо сравнить. Зачем мне сравнивать значение в левом и в правом сыне?
[39:56.200 --> 40:11.800]  Понял. Прошлая лекция прошла для вас зря. Ну не настолько же. Ладно, все, извините.
[40:11.800 --> 40:24.680]  Все, это все обман был. Это все не нужно. Все окей. Я что-то думаю, что слишком все как-то
[40:24.680 --> 40:39.640]  красиво получается, что не может быть все так плохо. Окей, в любом случае node value это все окей,
[40:39.960 --> 40:49.800]  здесь нет проблемы никакой. Проблема в том, что на самом деле вот это вот и вот это в оригинале,
[40:49.800 --> 41:06.080]  это будет чтение с диска. Потому что вас node будет хранить номер диска, расстояние от центра диска
[41:06.080 --> 41:15.200]  до того, где этот блок лежит в памяти и угол phi от оси. Что-нибудь такое. Ну геометрически он так
[41:15.200 --> 41:20.960]  будет хранить. Фактически, конечно, нет. Фактически, я не знаю, как он хранит адресацию, но физически
[41:20.960 --> 41:31.680]  что-то такое вот. То есть вам нужно здесь читать диск, это как-то покрутить ваш читатель и диски
[41:32.320 --> 41:40.880]  подвигать. Также здесь. Короче говоря, это долго. Поэтому надо стремиться как-то уменьшать высоту
[41:40.880 --> 41:49.320]  дерева. Казалось бы, как уменьшить высоту бинарного дерева, если она у AVL так почти оптимальная. Там
[41:49.320 --> 41:57.080]  типа разность высот по деревьях плюс-минус один. То есть логарифм. То есть мы сами там имеем,
[41:57.080 --> 42:06.680]  что высота у всех этих деревьев, типа AVL дерева, константа c на лог 2n. Ну там c это,
[42:06.680 --> 42:14.120]  ее можно вывести из этих. Ну из соотношений с числом фибоначи, которое у нас было. Я его не
[42:14.120 --> 42:24.120]  хочу выводить, просто вот такая вот оценка есть. Ну или от лог n. А давайте с вами задумаемся вот о
[42:24.120 --> 42:31.600]  чем. Что можно же как-то это дело оптимизировать, что ли, если хранить не два ребенка, а больше. И
[42:31.600 --> 42:38.120]  тут мы приходим к идее, что можно не только бинарные деревья поиска делать, а на самом деле какие-то
[42:38.120 --> 42:45.120]  там экзотические деревья. Вот. И поэтому давайте сформулируем определение B дерева наконец-то.
[42:45.120 --> 43:12.320]  B дерево ранга t это такое дерево что и здесь будет несколько свойств. Существо первое это каждый
[43:12.320 --> 43:39.840]  узел, кроме корня хранит хотя бы t-1 элемент. Элемент k1
[43:43.320 --> 44:04.160]  k л ты какой-то, да. При этом k1 меньше, чем k2 меньше, чем k л ты. Вынутка вот соотношения. Второй пункт
[44:04.160 --> 44:21.760]  узел с l детьми, с l элементами, извините, элементами. Сколько, думаете, детей он умеет?
[44:21.760 --> 44:36.800]  Ну у нас же может быть хотя бы t-1, но мы же не говорим сколько конкретно, поэтому l. То есть вот у
[44:36.800 --> 44:50.360]  вас раз ребенок, два ребенок, три ребенок, четыре ребенок, пять ребенок. Да, имеет l плюс одного ребенка,
[44:50.360 --> 45:05.320]  при этом давайте обзовем здесь так, как бы это обозвать так, чтобы это было удобно. Так,
[45:05.320 --> 45:21.880]  это k1, k l ты. Давайте это обозначим c0, c1, c l. Ну c от слова ребенок. При этом c0 точка мин,
[45:21.880 --> 45:32.520]  то есть минимальный узел конкретно в этом ребенке, вот из этих вот ключей, меньше, чем k1,
[45:32.520 --> 45:52.120]  ой тут max, меньше, чем c1 точка мин, меньше, чем k2, меньше, чем c2 точка max. Сейчас c0 мин меньше,
[45:52.120 --> 46:12.200]  к1, c1 мин больше, чем k1, c1 max меньше, чем k2, меньше, чем c2 точка мин. То есть у вас вот здесь,
[46:12.200 --> 46:19.160]  вот в этом вот ребенке все ключи меньше, чем k1, все ключи находятся между k1 и k2.
[46:19.160 --> 46:36.160]  Т2 все ключи будут между k2 и k3, c l все ключи больше, чем k l будут. Третье свойство. Так,
[46:36.160 --> 46:58.400]  те узлы содержат не более 2t-1 элементов, включая корень. Вот здесь вот, кроме корня,
[46:58.400 --> 47:02.560]  то есть корень может хранить меньше, чем t-1 элемент, но больше он хранить не может.
[47:02.560 --> 47:21.680]  И четвертый пункт, самый интересный, все листья на одной высоте. То есть вы хотите себе такое
[47:21.680 --> 47:27.080]  дерево, которое вот такое вот куча свойств, и в придачу чтобы все его листья находились на одной
[47:27.080 --> 47:39.600]  высоте. Кажется, немножко неизбыточным наше желание. Еще 10 секунд на то, чтобы осознать.
[47:39.600 --> 47:51.320]  А мы сформулируем пока теорему о высоте. Если вы возьмете палочку и сделаете на ней l надрезов,
[47:51.320 --> 48:05.480]  сколько у вас кусочков будет? Окей. А теорема о высоте утверждается,
[48:05.480 --> 48:10.400]  что h меньше либо равно, чем логариф по основанию t от n плюс 1 пополам.
[48:10.400 --> 48:24.720]  Давайте доказывать что ли. Как мы доказывали с вами про AVL-дерево? Мы с вами говорили,
[48:24.720 --> 48:32.200]  что давайте посчитаем s от h, минимальное число вершин, которое может храниться дерево высоте h.
[48:32.200 --> 48:53.360]  Минимальное число элементов деревя высоты h. То есть m у нас больше либо равно, чем s от h.
[48:53.360 --> 48:57.280]  Число элементов оно больше либо равно, чем эта штука, если мы знаем высоту дерева.
[48:57.280 --> 49:06.840]  Давайте теперь s от h посчитаем. Ну это значит, что у вас не может быть вот такого вот дерева.
[49:06.840 --> 49:18.320]  И тем более, у вас такого дерева даже быть не может. Так вы можете хранить много ключей в одном узле.
[49:18.320 --> 49:25.920]  Мы с вами это еще все нарисуем, не волнуйтесь. Пока что это просто теоретический конструкт,
[49:26.240 --> 49:47.800]  которого не существует в природе. Бамбук это, конечно, сильное заявление,
[49:47.800 --> 49:58.760]  давайте считаем, что у дерева хотя бы два листа, тогда все понятно. Ну типа, ладно, все пути от корня до
[49:58.760 --> 50:05.720]  листьев имеют одинаковую длину. Он тоже будет один, то же самое. Ладно, не суть. Так, давайте s от h пока посчитаем.
[50:05.720 --> 50:11.360]  Какое минимальное количество может храниться? Сколько может быть минимум в корне, давайте.
[50:11.360 --> 50:21.760]  Один, да. Потому что корень, каждый узел кроме корня, хочет хотя бы t-1 элемент. Значит, корень может хранить один.
[50:21.760 --> 50:32.040]  Давайте здесь рисовать. Здесь один. Дальше здесь, на втором уровне, сколько у него может быть детей?
[50:32.040 --> 50:41.120]  Узла один, сколько детей? Два ребенка у него только. Раз и два. Сколько хранит каждый?
[50:41.120 --> 50:55.200]  Почему-то по три. Сколько этот чувак может хранить? t-1. Какое 2? У вас дерева порядка t.
[50:55.200 --> 51:00.240]  Еще раз.
[51:05.280 --> 51:13.080]  Может быть больше. Смотрим второе свойство. Узел с l-элементами имеет l плюс одного ребенка. Узел с одним
[51:13.080 --> 51:22.240]  элементом имеет 1 плюс 1 ребенков. Поэтому у него два ребенка, при этом они уже не корни. Значит,
[51:22.280 --> 51:29.800]  у них хотя бы t-1 элемент. Мы считаем минимальное количество, поэтому в них должно быть ровно t-1. Согласны?
[51:29.800 --> 51:55.320]  t-1, t-1. Да, в каждом. Здесь 2t минус 2. Вот на этом суммарно. Сколько у этого детей? t штук.
[51:59.800 --> 52:17.480]  Здесь будет по 2t. Согласны? Потому что у вас здесь t детей и здесь t детей. 2t детей умножить на t-1.
[52:17.480 --> 52:34.840]  Потому что в каждом из них по t минус 1 узлов. Этот узел t-1 элемент, этот узел t-1 элемент. Это один
[52:34.840 --> 52:41.720]  узел. Но суммарно все они содержат, потому что у вас здесь 2t узлов на этом уровне, по t-1 элементов.
[52:41.720 --> 52:49.520]  Короче, узел теперь это не чиселка, это вот такой вот прямоугольничек разделенный с
[52:49.520 --> 52:58.120]  такими вот. И здесь тоже дети будут прямоугольнички. И так далее. Давайте третий уровень посчитаем
[52:58.120 --> 53:08.520]  хорошо. Сколько детей у этого узла? Ну да, потому что в нем t-1 элемент. Ну понятно тогда, что у вас
[53:08.520 --> 53:22.520]  на следующем уровне будет 4t квадрат на t минус 1. Или нет? А на самом деле здесь, тогда 2 на t минус 1.
[53:27.400 --> 53:27.900]  Сейчас.
[53:31.200 --> 53:38.000]  Сейчас, подать почему. Сейчас давайте подумаем. Может не 4. Действительно, сейчас давайте посмотрим.
[53:38.000 --> 53:53.720]  Вот у каждого из этих узлов по t детей. Здесь t. Да, согласен. Потому что здесь из каждого
[53:53.720 --> 54:04.160]  узла превращается t детей, поэтому просто на t умножаем. Итого на самом деле это 1 плюс,
[54:04.160 --> 54:12.640]  то есть давайте 2 на t в нулевой, на t минус 1 2t, на t минус 1 2t квадрат, на t минус 1 и так далее.
[54:12.640 --> 54:29.860]  Плюс сумма 2t в степени i на t минус 1, где i от каких пределов меняется? Сейчас, от нуля до и
[54:29.860 --> 54:40.100]  дерева высоты h. Начнем с h уровней или h минус 1? Нет, важно, мы же хотим точную оценку вроде бы.
[54:40.100 --> 54:50.380]  Так, сейчас. Окей, здесь у нас для третьего уровня для высоты 3 h минус 2 будет. Да, h минус 2 считаем.
[54:50.380 --> 54:54.540]  Теперь надо лишь посчитать эту штуку.
[54:54.540 --> 55:07.740]  Дважды t минус 1, на сумму по i от нуля до h минус 2, t в степени i.
[55:07.740 --> 55:20.140]  Сейчас 1 плюс 2 на t минус 1 умножить на, сейчас будет сложно, вроде бы так.
[55:20.140 --> 55:35.580]  То есть 1 плюс дважды на t степени h минус 1 минус 2. Вот что тут такое вот?
[55:35.580 --> 55:49.220]  То есть n больше либо равно, чем 2t h минус 1 минус 1, t в степени h минус 1
[55:53.060 --> 55:58.580]  меньше либо равно, чем, что? n плюс 1 пополам.
[56:05.580 --> 56:13.300]  А, ну окей, хорошо. Здесь прикол получился в том, что я, когда описывал это утверждение,
[56:13.300 --> 56:18.700]  что я считал, что в ребрах, а не в вершинах. То есть я считал, сколько ребер именно.
[56:18.700 --> 56:38.340]  Поэтому давайте я здесь напишу все-таки, если высота в ребрах измеряется, а это если высота в вершинах.
[56:38.340 --> 56:46.860]  Ну, понятно, что h тогда у вас. Короче, доказано, да? Согласны, что доказано?
[56:46.860 --> 56:55.740]  Нет, одно и то же.
[56:55.740 --> 57:14.740]  А, ну, а здесь имеет, окей, хорошо, согласен. Внутренний узел. Внутренний узел, вот они лист.
[57:14.740 --> 57:23.300]  Окей, здесь право. Так, доказали высоту. Теперь давайте разбираться с тем, как с этой громоздкой
[57:23.300 --> 57:28.620]  конструкции работать. Ну и первое, это как делать файнт вообще в таком дереве.
[57:28.620 --> 57:41.620]  Ну, файнт здесь вроде бы легкий. Просто прикол в том, что вам придется не сравнивать не с одним
[57:41.620 --> 57:51.060]  элементом, а с массивчиком элементов. Давайте я нарисую.
[57:51.060 --> 58:16.820]  Что-нибудь такое. Вот такое классное дерево. Соответственно, чем оно хорошо? Да, давайте
[58:16.820 --> 58:22.660]  обсудим вообще, чем оно хорошо сначала, зачем его делали. Утверждается, что вот t подбирают так,
[58:22.660 --> 58:29.860]  чтобы у вас вот одна страничка, вот этот вот узел один, он целиком помещался в оперативку. Ну там,
[58:29.860 --> 58:35.660]  чтобы их 2-3 помещались в оперативку, потому что нам это еще пригодится для разных операций. Вот,
[58:35.660 --> 58:49.020]  и в реальности там t, они бывают разные, что-то порядка 500 выбирают. То есть, большие числа
[58:49.020 --> 58:56.340]  все-таки. Ну там от 50 до 2000 где-то больше, где-то меньше, по-разному, короче. Если мы с вами
[58:56.340 --> 59:01.460]  говорили, что здесь что-то порядка лог двоичный, ну двоичного логарифма, да, там логариф по основанию
[59:01.460 --> 59:10.780]  t. И того, какой у вас прирост производительности? Прирост производительности, что вы берете лог
[59:10.780 --> 59:22.620]  t от n делить на лог два от n, получаете что? Лог два по основанию t. То есть, вот столько раз,
[59:22.620 --> 59:33.660]  примерно, у вас меньше обращения к диску идет. Ну при t равном 500, это ну сколько? Порядка 9. То
[59:33.660 --> 59:38.700]  есть, в 9 раз меньше обращений к диску. Это сильно. Учитывая то, что у вас обращение к диску тысячу
[59:38.700 --> 59:45.940]  раз медленнее, чем обращение к оперативке, внезапно получаете огромный буст. Собственно,
[59:45.940 --> 59:53.700]  B-деревья используют для базданных всяких разных, для хранения, например. Вот. Окей, теперь как
[59:53.700 --> 01:00:06.300]  работает Find? Он принимает все дерево t и ключ k. Он берет и сравнивает, просто берет форум.
[01:00:06.300 --> 01:00:19.860]  Опять же, это псевдокод, не претендующий на работу. Сразу дисклеймер такой. Делаем следующее,
[01:00:19.860 --> 01:00:33.300]  что если и меньше, чем l, строго, потому что я хочу форум. BinPoisk компонентное дело тоже можно,
[01:00:33.300 --> 01:00:43.460]  но мне лень писать BinPoisk. Что? Хорош. Давайте я лучше форум напишу, а с BinPoisk на семинаре
[01:00:43.460 --> 01:00:57.940]  разберетесь. Что если верно следующее, k и ты меньше, чем k, меньше, чем k и плюс 1,
[01:00:57.940 --> 01:01:20.620]  то вы делаете Find от узла n, от к, от с и к. Вот, это основная часть цикла, то есть вы здесь
[01:01:20.620 --> 01:01:30.900]  вот просматриваете вот этих вот чуваков. Куда-нибудь сюда еще надо вставить if k совпало с k и ты,
[01:01:30.900 --> 01:01:46.900]  то делай типа return true, не знаю. Это узел, который вы смотрите, узел n. Это у нас будет k1,
[01:01:46.900 --> 01:02:04.940]  k и ты, но это будет c0, c1, c и ты. Да, да, return true. То есть здесь мы посмотрели вот эти вот всех
[01:02:04.940 --> 01:02:11.260]  чуваков и все возможные значения k и ты. Но племя в том, что k еще может либо здесь, либо здесь лежать,
[01:02:11.260 --> 01:02:21.260]  поэтому на самом деле надо сюда еще засунуть проверки, что если k меньше чем k1, то делай
[01:02:21.260 --> 01:02:34.340]  return, делай find от c0 к и сюда в конец надо вставить делай find, ну типа если ты его не
[01:02:34.340 --> 01:02:49.140]  нашел, рекурсивно не вызвался. Не знаю, делай find dot c, l, t, k. Что-то такое. Опять этот код не
[01:02:49.140 --> 01:02:54.540]  будет работать, потому что здесь нужно if и else понатыкать хорошим, чтобы вас эта штука не вызывалась
[01:02:54.540 --> 01:03:02.260]  всегда. Вот, но схема примерно такая работает, что вы смотрите, если ваш ключ меньше чем k1,
[01:03:02.260 --> 01:03:11.060]  вы рекурсивно называетесь от c0. Иначе, если вы пробегаетесь в форум по всем ключам, проверяйте,
[01:03:11.060 --> 01:03:19.460]  может ли у вас где-то быть ваш товарищ, если нет, то он здесь. Окей, собственно говоря, в чем
[01:03:19.460 --> 01:03:26.660]  выгода-то? Заметьте, что find хранит в едином времени только один узел и все, ему не нужны
[01:03:26.660 --> 01:03:33.380]  значения детей, ему нужны только вот эти вот каиты. Поэтому достаточно один раз прочитать узел в память,
[01:03:33.380 --> 01:03:41.140]  по нему в оперативке очень быстро бегать можно. Вот, это не проблема. Вот, а проблема лишь в том,
[01:03:41.140 --> 01:03:48.980]  что у вас здесь как бы этот. Точнее так, тут проблемы нет, у вас как бы скачок вот этот вот,
[01:03:48.980 --> 01:03:55.380]  он один делается и все хорошо. Ну скачок один раз вниз, поэтому вы делаете это от высоты. Давайте
[01:03:55.380 --> 01:04:11.260]  подумать, за сколько find вообще работает. То есть, чтение из диска у вас только на самом деле. Мы
[01:04:11.260 --> 01:04:17.140]  будем замерять в двух плоскостях в этот раз время, сколько чтения из диска, потому что это долгие
[01:04:17.140 --> 01:04:22.580]  операции. Есть быстрая операция, работа в оперативке. Сколько действий в оперативке суммарно будет сделано?
[01:04:25.380 --> 01:04:43.780]  Ну да, от t, логариф по основанию t от n. Работа в оперативке. Вот такое действие в оперативке.
[01:04:43.780 --> 01:04:52.020]  Но если у вас t порядка 500, а у вас чтение из диска порядка в тысячу раз медленнее, то вы
[01:04:52.020 --> 01:04:58.340]  получаете примерно равенство к краске здесь. Но там плюс-минус. Поэтому t подбирают скорее всего даже,
[01:04:58.340 --> 01:05:05.900]  я думаю, имперически для каждого отдельного устройства, чтобы оно было оптимальным. Вот.
[01:05:05.900 --> 01:05:16.180]  Как-то так. Работает find прекрасный. У нас время еще. Что, мы и рейс не успеем, что ли? Это грустно.
[01:05:16.180 --> 01:05:32.260]  Окей, ладно. Так, тогда поехали быстро обсудим вставку. Там сколько успеем уже.
[01:05:32.260 --> 01:05:44.380]  Так, insert. В чем проблема инсерта? Инсерт делается просто. Давайте считать, что элемента нет в
[01:05:44.380 --> 01:05:52.740]  дереве. Можно проверить find. Но проверять мы find не будем, потому что это лишний спуск по дереву,
[01:05:52.740 --> 01:05:58.020]  это куча времени. Мы будем прямо внутри инсерта проверять, правда ли, что мы нашли такой-то
[01:05:58.020 --> 01:06:02.460]  элемент. Если да, то мы заканчиваем наш алгоритм. Если нет, то мы продолжаем там спускаться.
[01:06:02.460 --> 01:06:15.900]  Окей, в чем проблема? Как делается инсерт? Он делается вставь в нужный лист, в нужную позицию.
[01:06:15.900 --> 01:06:42.860]  Все. Есть проблемы? Какие? Какое? В смысле хотя бы t-1, но я увеличил и нет проблем. Вот проблема в том,
[01:06:42.860 --> 01:06:55.140]  что у вас в узле может быть 2t-1 элементов в листе в этом. А вот нет. А вот сейчас мы скажем,
[01:06:55.140 --> 01:06:59.660]  как будет делаться на самом деле. Смотрите, в чем прикол. Вот ваш прекрасный узел,
[01:06:59.660 --> 01:07:07.900]  содержащий 2t-1 элементов. И вы хотите сюда всунуть еще один элемент. Он будет содержать
[01:07:07.900 --> 01:07:13.620]  2t-1 элементов. Это грустная история. Если мы содержим 2t-1 элементы, почему она грустная?
[01:07:13.620 --> 01:07:32.580]  Потому что так нельзя по определению. Пакты. Я не знаю, как на это ответить, если честно. Ну,
[01:07:32.580 --> 01:07:38.580]  так придумано было. На самом деле, когда мы разберем инсерт и рейс, то мы поймем,
[01:07:38.580 --> 01:07:46.020]  зачем это было придумано на самом деле. Опять же, пока что мы верим, что это просто теоретический
[01:07:46.020 --> 01:07:50.180]  конструкт, который мы еще даже не построили с вами. Мы вообще еще ничего про него не знаем. Мы знаем
[01:07:50.180 --> 01:07:56.580]  определение и знаем, что если такая штука существует, то мы умеем делать пайн в нем за столько. Но больше
[01:07:56.580 --> 01:08:02.140]  мы ничего не умеем с ним делать. Мы даже создавать не умеем. Ладно, клеить сделать легко. Это инсерт
[01:08:02.140 --> 01:08:10.780]  одного чувака. Это легко сделать. Но мы инсерт еще не знаем, как делать. Окей, вот я хочу ставить
[01:08:10.780 --> 01:08:17.620]  сюда элемент. В чем проблема? В том, что казалось бы логичным было бы превратить его вот так вот.
[01:08:17.620 --> 01:08:30.140]  Чего-то типа такого. Вот тебе твой ребенок. Минусы. Сколько пунктов определения вы нарушили,
[01:08:30.140 --> 01:08:37.420]  сделав так? Во-первых, вы нарушили четвертый, потому что у вас появился новый лист, он вообще глубже
[01:08:37.420 --> 01:08:46.860]  всех. Во-вторых, вы нарушили этот, потому что у вас узел содержит один элемент. Вот. При этих
[01:08:46.860 --> 01:08:50.860]  вы нарушили этот, потому что это был лист и у него не было детей. Теперь у него только один ребенок.
[01:08:50.860 --> 01:08:56.420]  Нарушили ли мы третий? Вроде бы нет. Вот это единственный пункт, который мы не нарушили.
[01:08:56.420 --> 01:09:09.100]  Ну да, мы вот у него и нарушим второй пункт. Третий пункт мы не нарушили. Да, вот единственный пункт,
[01:09:09.100 --> 01:09:19.820]  как отлично. Мы нарушили всего лишь три заповедей из четырех. Вот, Б дерево не прощается. Да,
[01:09:19.820 --> 01:09:25.860]  действительно, мы сейчас задаваем деревья-то, наверное. Окей, как решается эта задача? Решается
[01:09:25.860 --> 01:09:34.740]  задача операции разбиения узла на самом деле. Чем хорошо 2t-1? Это число какое? Нечетное, вау.
[01:09:34.740 --> 01:09:45.100]  Поэтому давайте посмотрим более глобальную эту конструкцию. Что-нибудь такого. Вот, не так. Давайте
[01:09:45.100 --> 01:09:56.900]  вот так, наоборот. Это должен быть меньше, чем нижний. Вот так вот, раз. Вот ваш родитель,
[01:09:56.900 --> 01:10:05.140]  вот ваш лист, который вы хотите вставить. Вот сюда элемент куда-то. Что делается? Берется серединный
[01:10:05.140 --> 01:10:16.660]  элемент и говорится, чувак, ты поднимаешься наверх. Давайте мы позначим это... Давайте я нарешу
[01:10:16.660 --> 01:10:26.180]  просто дерево реальное, и мы будем наслаждаться этим. Сейчас будет верх изобразительного искусства.
[01:10:26.180 --> 01:10:39.180]  Давайте я возьму t равно 2, чтобы было проще. Что? Не-не-не-не, ты издеваешь надо мной. Какое 3?
[01:10:39.180 --> 01:10:52.180]  Тут уже надо 3 элемента в узле рисовать. Давайте. Т больше, правда, 2. Блин, нужно английский алфавит вспомнить.
[01:10:52.180 --> 01:11:07.740]  Нет, ну дальше. G-H-E. Вот, это ваш узел, в который вы хотите... Нет, давайте J. Вот, J будет. Так,
[01:11:07.740 --> 01:11:13.380]  сейчас. Теперь у меня будет родитель, который будет содержать в себе, пускай для приличия,
[01:11:13.380 --> 01:11:25.740]  2 узла сначала. A, P. Вот. Тогда это... Вот это ребенок... Давайте здесь не знаю, что-нибудь типа D.
[01:11:25.740 --> 01:11:39.580]  А, ну P пойдет. Здесь у него там будет ребенок какой-нибудь, не знаю, ST. Здесь ребенок AB,
[01:11:39.580 --> 01:11:53.580]  что-нибудь такое. Ну давайте Z будет 3, хорошо. А, Б, С. И вот вы хотите сделать insert от E. Вставить
[01:11:53.580 --> 01:12:05.060]  букву E. Казалось бы, она должна встать сюда. То есть вы должны были превратить этот узел в G-H-E-J.
[01:12:05.060 --> 01:12:12.700]  Но это грустная история. Почему она грустная? Потому что у вас нарушается вторая заповедь. Нет,
[01:12:12.700 --> 01:12:22.180]  сейчас скажу какая. Третья заповедь. Поэтому делается следующее. Берется и делается вот так.
[01:12:22.180 --> 01:12:31.980]  Вот сюда создается новый элемент. Здесь у нас была P, да? Сюда пишется. Здесь выполняется
[01:12:31.980 --> 01:12:42.620]  разбиение узла на 2. Переносится медианный элемент вверх. Медианный, то есть серединный. Вот
[01:12:42.620 --> 01:12:47.780]  у вас два новых узла. Дерево корректное теперь, да? И теперь в нужный узел вставляют букву E.
[01:12:47.780 --> 01:13:02.940]  То есть у вас была операция. У вас был один узел, стало два. Вы их разделили буквой H,
[01:13:02.940 --> 01:13:11.340]  причем дети буквы H вот так вот располагаются. Это понятное дело. Поймем следующее, что раз у нас
[01:13:11.340 --> 01:13:19.220]  было 2t-1 элементов, то когда вы выкинули один, стало 2t-2. Вы делили пополам t-1. То есть здесь
[01:13:19.220 --> 01:13:36.300]  t-1 и здесь t-1 оказалось. Находите связь между 2t-1 и t-1, откуда они взялись? Вверх, вверх. Вы
[01:13:36.300 --> 01:13:42.180]  создаете новый корень из одного элемента, потому что корень, видите, каждый узел кроме
[01:13:42.180 --> 01:13:50.660]  корня хранит хотя бы t-1, а корень может хранить меньше. То есть если у вас, ну понятно дело,
[01:13:50.660 --> 01:13:54.340]  что это операция, здесь у вас могло быть три элемента, то есть 2t-1. Нам нужно снова вверх.
[01:13:54.340 --> 01:14:04.560]  Допустим, у вас здесь стало типа 2t в корне, тогда вы можете его тоже разделить и у вас как бы
[01:14:04.560 --> 01:14:14.460]  появится. Вот у вас ваше дерево, допустим, оно состоит из ключей A, B, D. И вы хотите
[01:14:14.460 --> 01:14:20.740]  insert A, C сделать. Вот ваш прекрасный дерево, insert A, C вы от него делаете. Что происходит? Вы
[01:14:20.740 --> 01:14:27.620]  понимаете, что у него размер 2t-1. Ну t равно 2, он опять же берется. Значит, вы должны выделить
[01:14:27.620 --> 01:14:48.540]  медианный элемент, новый корень B, A, D и вставляется C. Не больше 2t-1. Все, это все ограничения на корень.
[01:14:50.740 --> 01:15:02.420]  То есть давайте теперь проговорим с вами итоговый алгоритм. Давайте его где-нибудь пропишем. Вот мы
[01:15:02.420 --> 01:15:20.340]  вставляем в лист нужную позицию. Если лист содержит 2t-1 элементов, то выполняем разбиение
[01:15:20.340 --> 01:15:38.580]  как-то разбиение работает. Первый. Берем kθ, ну это будет краски тетой элемент, медианный, и добавляем
[01:15:38.580 --> 01:16:08.580]  в родителя разделяемого узла. Шаг 2. k1, kt-1, kt-1, k2, k3, k4, k5, k6, k7, k8, k9, k9, k10, k11, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12
[01:16:08.580 --> 01:16:38.580]  k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
[01:16:38.580 --> 01:17:08.580]  k12, k12, k12, k12, k12,
[01:17:08.580 --> 01:17:38.580]  k12, k12,
[01:17:38.580 --> 01:17:57.580]  к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
[01:17:57.580 --> 01:18:17.580]  к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
[01:18:17.580 --> 01:18:37.580]  к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
[01:18:37.580 --> 01:18:57.580]  к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
[01:18:57.580 --> 01:19:05.580]  то есть утверждается, что когда вы разделили узел и спустили сюда рекурсивный инсер делать, его уже сам делить не будет, не надо будет.
[01:19:05.580 --> 01:19:19.580]  Возможно, где-то дальше внизу вам придется делить дальше узлы, но даже если так, если вам нужно будет его ребенка какого-нибудь здесь что-нибудь поднимать наверх, один узел,
[01:19:19.580 --> 01:19:41.580]  то у вас здесь будет только t узлов, но никак не 2t-1, чтобы вам не пришлось бы его еще раз заново бить. Почему? Потому что 2t-1-t больше либо равно 1, при t больше либо равным 2.
[01:19:41.580 --> 01:19:46.580]  То есть вам нужно делать хотя бы еще один инсерт туда, чтобы его пришлось бы заново сплитить.
[01:19:46.580 --> 01:19:54.580]  Поэтому здесь так подобраны вот эти t-1, 2t-1 и так далее, чтобы вам все можно было делать за один нисходящий проход на самом деле.
[01:19:54.580 --> 01:20:09.580]  То есть примерно понятно, как делает инсерт за один проход. Потому что в любом случае, если вы находитесь в узле в каком-то, значит, что он будет либо модифицирован, либо нет.
[01:20:09.580 --> 01:20:17.580]  Вот на этом пути каком-то. А если в нем 2t-1, то он, очевидно, должен быть модифицирован, потому что вы там вставите элементы какой-то.
[01:20:17.580 --> 01:20:21.580]  Поэтому давайте их все разделять и все.
[01:20:22.580 --> 01:20:28.580]  Окей. Тогда и рейс мы обсудим на следующей лекции.
[01:20:28.580 --> 01:20:31.580]  Он раз в три сложнее, наверное.
[01:20:33.580 --> 01:20:38.580]  Вот, но короче говоря, как-то так. Есть и вопрос.
