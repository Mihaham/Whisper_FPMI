[00:00.000 --> 00:11.320]  Ура, мы начинаем. Сегодня у нас последнее занятие, мы завершаем тему блокчейнов и мы сегодня изучаем
[00:11.320 --> 00:18.440]  самый современный, самый оптимальный permission protocol, который называется Hot Stuff. Это результат
[00:18.440 --> 00:27.840]  2019 года и можно было бы подумать, что сегодня будет что-то сложное, но совсем наоборот,
[00:27.840 --> 00:33.240]  сегодня будет что-то очень простое, слишком даже простое и даже удивительно, что настолько простое
[00:33.240 --> 00:39.480]  можно придумать в 2019 году. Но конечно, чтобы придумать что-то простое в 2019 году, нужно сначала
[00:39.480 --> 00:44.880]  изучить что-то сложное, что было до этого и каким-то образом подумать и вот все это совместить.
[00:44.880 --> 00:50.760]  Так что начнем. Можно было бы этот протокол рассказать просто с чистого листа. Вы ничего
[00:50.760 --> 00:54.560]  не знаете про блокчейн, вообще ничего не знаете и можно было бы в принципе разобраться. Но я
[00:54.600 --> 01:01.000]  потрачу некоторое время и сначала напомню вам, как был устроен PBFT, как был устроен протокол
[01:01.000 --> 01:06.760]  консенсусов в биткоине. Проведу еще раз параллель, напомню о них и мы подумаем,
[01:06.760 --> 01:13.960]  как их можно склеить, чтобы получить что-то более оптимальное. Ну вот, мы с вами на последних
[01:13.960 --> 01:25.720]  двух занятиях говорили, во-первых, про practical Byzantine fault tolerance. Это первый протокол и про
[01:25.720 --> 01:38.840]  биткоин, он будет где-то здесь. Две идеи уже немолодые, то есть это 99 год, это 2008.
[01:38.840 --> 01:50.760]  И вспомним, как там решалась задача консенсуса, как в этих алгоритмах, в этих системах упорядочивались
[01:50.760 --> 02:06.600]  транзакции. В PBFT у нас был permission подход. Мы фиксировали число реплик 3f+, если мы собираемся
[02:06.600 --> 02:17.120]  пережить сбоев любых отказов византийских узлов. И один из этих узлов назначается primary. И этот
[02:17.120 --> 02:23.080]  primary отвечает за то, чтобы упорядочивать транзакции. Давайте быстро вспомним, как это происходило.
[02:23.080 --> 02:37.120]  У нас, напомню, на рисунках 4 узла, потому что 3f+, и вот этот узел является primary. Он
[02:37.120 --> 02:46.040]  получает транзакции от пользователей, но мы их называем здесь транзакциями. Получает транзакцию
[02:46.040 --> 02:52.600]  primary. Primary, конечно же, принадлежит некоторой эпохе. Она называлась в этом протоколе view.
[02:52.600 --> 02:58.720]  Primary в этом view получает транзакцию, выбирает для него порядковый номер и раздает эту транзакцию
[02:58.720 --> 03:12.520]  другим репликам. Это первое сообщение, первая фаза. Она называлась prepare. Мы отправляли сообщение
[03:12.520 --> 03:22.400]  в эпохе V с порядкомом номером S и хэшом транзакции D. Заметьте, свое сообщение подписывали. К нему
[03:22.400 --> 03:27.160]  предлагали саму транзакцию, чтобы каждый раз с собой не таскать, потому что эти сообщения,
[03:27.160 --> 03:31.160]  вообще говоря, мы собираемся пересвовать другим узлам, и чтобы не таскать с собой данные,
[03:31.160 --> 03:43.840]  мы сюда добавляем только хэш. Первая фаза. На второй фазе реплики, получая вот эту транзакцию в
[03:43.840 --> 03:48.720]  этом слоте, должны были понять, верно ли, что вообще лидер primary их не обманывает. Может быть,
[03:48.720 --> 03:54.280]  он отправил разные транзакции с разными дайджестрами, разными хэшами, но с одним и тем же порядковым
[03:54.280 --> 04:01.440]  номером. Чтобы разобраться, что лидер частный, они обменивались сообщениями. Вот такая квадратичная
[04:01.440 --> 04:16.040]  коммуникация. Все общались со всеми. Тут можно кое-что оптимальное сделать, но чуть-чуть со всем,
[04:16.040 --> 04:25.080]  так что это не очень важно сейчас. Эти сообщения назывались prepare, и смысл у них был такой. Я
[04:25.080 --> 04:33.840]  и Т-реплика говорил... Простите, здесь, конечно, не И, а здесь подпись primary. Я и Т-реплика здесь
[04:33.840 --> 04:40.840]  говорил другим, что я в эпохе В, в слоте С, получил транзакцию с дайджестом D, и свое сообщение
[04:40.840 --> 04:53.560]  также подписывал. И если какая-то реплика, ну вот скажем это, набирала достаточно одинаковых
[04:53.560 --> 05:14.960]  препареров, а именно 2F плюс 1, то мы говорили, что она подготовила вот эту транзакцию в этом
[05:14.960 --> 05:22.040]  слоте. Если она собирала такой набор подписанных сообщений, такой хворомный сертификат, который мы
[05:22.040 --> 05:33.320]  называли P-сертификатом, то реплика знала, что на большинстве честных реплик лежит одна и та же
[05:33.320 --> 05:39.080]  транзакция, про которую мы знаем. Дальше мы задавались вопросом, достаточно ли этого, чтобы
[05:39.080 --> 05:45.080]  считать, что транзакция надежно зафиксировалась в нашем логе. Обычно это было так, ну по крайней
[05:45.080 --> 05:52.920]  мере в рафте это было так, но здесь у нас ситуация сложнее, потому что у нас сложнее устроена
[05:52.920 --> 06:04.040]  смена эпохи. Вспомним, как происходила смена эпохи. Вот понятие комита, понятие фиксации транзакции
[06:04.040 --> 06:12.680]  команды в логе, оно связано с тем, понятие это означает, что при смене ридера, смене эпохи, транзакция
[06:12.680 --> 06:22.360]  всё ещё останется в логе. Вот поэтому мы сейчас поговорим, как эта смена эпохи происходила.
[06:22.360 --> 06:30.080]  Да, обращаю внимание, что вот в ПВФТ, кстати, лекстика мне кажется удачнее, чем в рафте,
[06:30.080 --> 06:35.360]  потому что в рафте мы говорим про процедуру, про фазу выбора лидера, а сложность она не в выборе
[06:35.360 --> 06:40.360]  лидера, как известно, а именно в том, чтобы лидер ничего не забыл, ничего не потерял, ничего не
[06:40.360 --> 06:49.160]  сломал. Так что смена эпохи больше подходит по смыслу. Давайте возьмём маркер поярче. Во-первых,
[06:49.160 --> 06:58.760]  в смене эпохи мы не то чтобы выбирали нового праймари, мы его назначали. У нас была цель, чтобы
[06:58.760 --> 07:08.480]  честный узел стал праймари. Мы не знаем, кто честный, но мы умеем подозревать не честный,
[07:08.480 --> 07:14.680]  если они там ничего не посылают нам, если они посылают что-то разное. И тогда мы меняем праймари,
[07:14.680 --> 07:27.080]  перебираем праймари просто по кругу. Мы говорим, что в эпохе В праймари назначается узел с индексом
[07:27.080 --> 07:37.320]  В по модулю N, где число реплик. И если какой-то узел, точнее какая-то группа узлов достаточно
[07:37.320 --> 07:45.120]  большая, решала, что праймари нужно поменять, то каждый из них отправлял новому праймари,
[07:45.120 --> 07:53.440]  следующему в очереди. Вот это был праймари в эпохе 5, это праймари будет в эпохе 6. Вот мы узел,
[07:53.440 --> 07:59.280]  который подозревает праймари в эпохе 5 в визнатистском поведении, отправляем праймари следующему
[07:59.280 --> 08:03.600]  узлу, который должен стать праймари в эпохе 6, сообщение, которое так называлось view change.
[08:03.600 --> 08:14.480]  И если новый праймари набирает достаточно много таких голосов,
[08:14.480 --> 08:23.680]  но в том числе он может сам за себя проголосовать, то эпоха меняется и этот праймари говорит всем,
[08:23.680 --> 08:31.120]  что давайте перейдем теперь в эпоху V plus 1. Это сообщение, которое называлось new view.
[08:31.120 --> 08:41.920]  Разумеется, у нас было много тонкостей, но во-первых, у нас нет повода верить одному узлу,
[08:41.920 --> 08:46.280]  который посылает new view, поэтому он должен убедить остальных, что действительно эпоха имела
[08:46.280 --> 08:52.280]  право смениться, поэтому мы в сообщении new view прикладываем quorum на сертификат.
[08:52.280 --> 09:11.880]  И вот добавляем его сюда. Кроме того, мы должны позаботиться о том, чтобы новый праймари знал
[09:11.880 --> 09:19.400]  про все транзакции, которые мы собираемся считать закромичными. У нового праймари мог быть пустой лог,
[09:19.400 --> 09:25.240]  но не то чтобы пустой, этот узел мог отставать от остальных, поэтому каждая реплика,
[09:25.240 --> 09:30.160]  которая посылает view change, вместе с этим сообщением присылает и свои транзакции.
[09:30.160 --> 09:33.880]  Разумеется, все сообщения подписаны, и они образуют quorum на сертификат.
[09:33.880 --> 09:49.200]  Но нужно быть аккуратным на месте нового праймари, потому что разные реплики могут
[09:49.200 --> 09:53.840]  посылать разные логи, и какие-то изнатильские реплики могут просто транзакции выдумывать.
[09:53.840 --> 10:02.600]  Мы повторяем PBFT, пока ничего не пропустил. Поэтому если реплика посылает view change новому
[10:02.600 --> 10:07.480]  праймари и посылает туда свои транзакции, то она должна как-то доказать этому новому
[10:07.480 --> 10:14.440]  праймари, что эти транзакции должны перейти через эпоху. Как это можно сделать?
[10:14.440 --> 10:20.080]  Хорошо, если у реплики, которая посылает view change, есть prepare-сертификат для транзакции,
[10:20.080 --> 10:25.800]  потому что понятно, что двух разных prepare-сертификатов в пределах одной эпохи для одного и того же
[10:25.800 --> 10:31.640]  упореткого номера S быть не может. Просто потому что пересечение двух вот этих вот quorumов будет,
[10:31.640 --> 10:38.040]  по крайней мере, один частный узел, который, получается, проголосовал дважды. Так что мы будем
[10:38.040 --> 10:48.440]  уверены, что транзакция переживёт смену эпохи, падёт в следующее, если в пересечении quoruma узлов,
[10:48.440 --> 10:59.240]  которые отправили в view change, и в пересечении quoruma узлов, у которых есть транзакция,
[10:59.240 --> 11:07.080]  какое-то очень маленькое пересечение получилось, оно побольше эти. Вот в этом пересечении есть,
[11:07.080 --> 11:12.720]  по крайней мере, один частный узел, который может доказать, что транзакция должна переехать в
[11:12.720 --> 11:19.400]  будущее. То есть у него должен быть prepare-сертификат у этого узла. Но как гарантировать, что он будет?
[11:19.400 --> 11:26.840]  То, что какой-то узел знает, что у него есть prepare-сертификат, если у какого-то узла есть
[11:26.840 --> 11:31.560]  prepare-сертификат, он знает, что на большинстве честных лежит одна этажа транзакции, но не факт,
[11:31.560 --> 11:38.160]  что именно вот этот узел с prepare-сертификатом попадёт в пересечение quorumов и сможет доказать
[11:38.160 --> 11:44.600]  новому primary. Так что такого определения, что транзакция лежит на большинстве честных узлов,
[11:44.600 --> 11:49.360]  недостаточно, чтобы гарантировать, что она в сменной эпохе переживёт. Чтобы доказать,
[11:49.360 --> 11:54.520]  что гарантировать, что транзакция переживёт сменной эпохи, то есть что она закоммищена,
[11:54.520 --> 12:17.560]  мы должны знать, что у большинства честных есть prepare-сертификат. Тогда кто бы из вот этих 2
[12:17.560 --> 12:22.960]  f плюс 1 узлов не попал, точнее, кто бы из этого большинства честных узлов не попал в пересечение
[12:22.960 --> 12:28.880]  множеством честных узлов quorum and viewchange, он сможет сертификат предоставить и таким
[12:28.880 --> 12:36.880]  образом докажет новому primary, что большинство честных узлов действительно получили данную
[12:36.880 --> 12:47.440]  транзакцию и записали её в лог вот в этом слоте. Но это определение глобальное, то есть если
[12:47.440 --> 12:51.840]  большинство честных узлов подготовили транзакцию, то кто-то из них пойдёт в пересечение quorumов и
[12:51.840 --> 12:58.720]  докажет следующему primary, что транзакция переживает светлое будущее. Но отдельные узлы этого пока не
[12:58.720 --> 13:03.520]  понимают. То есть действительно может быть большинство честных с подготовленной транзакцией,
[13:03.520 --> 13:07.920]  но они же не знают ничего про остальных. Вот для того, чтобы отдельная реплика поняла,
[13:07.920 --> 13:15.520]  что такое условие выполнено, мы устраиваем ещё одну дополнительную фазу, вторая, третья,
[13:15.520 --> 13:21.520]  которая называется фаза commit. Смысл этой фазы commit, чтобы отдельная реплика поняла,
[13:21.520 --> 13:26.800]  что большинство честных реплик знают, что на большинстве честных реплик транзакции. Для этого
[13:26.800 --> 13:42.000]  они обмениваются сообщениями ещё раз. Вот эти сообщения даже выглядят похожи. Сообщения называются
[13:42.000 --> 13:53.480]  commit, и у них те же аргументы. В эпохе V, в слоте S, транзакция с дайджестом D. Вот смысл
[13:53.480 --> 13:59.760]  committer в том, что реплика, которая его отправила, обладает преперсертификатом и, попав в пересечение
[13:59.760 --> 14:07.040]  quorumов, отправив Uchange, может доказать что-то новому primary. И если какая-то реплика собрала
[14:07.040 --> 14:12.400]  2F плюс один одинаковый commit, то она уверена, что большинство честных знают, что на большинстве
[14:12.400 --> 14:20.040]  честных транзакций могут доказать. После этого можно уже отправить в primary подписанный ответ,
[14:20.040 --> 14:33.120]  и он сообщит его клиенту. Такой протокол местами не очень эффективный, местами очень неэффективный.
[14:33.200 --> 14:39.000]  Во-первых, в чем он неэффективный? В том, что процедура смены эпохи очень сложная.
[14:39.000 --> 14:50.160]  В процедуре смены эпохи мы должны в Vuechange отправить лог с сертификатами, в каждом из которых
[14:50.160 --> 14:58.160]  много сообщений. Дальше отправится new Vue, и в этом new Vue будет quorumный сертификат с этими
[14:58.160 --> 15:05.920]  сообщениями в Vuechange, у которых короче. Тут появляется очень много сообщений, и сам этап
[15:05.920 --> 15:10.720]  довольно сложный, сама фаза довольно сложно устроена. Это первое место, которое мы сегодня
[15:10.720 --> 15:16.560]  оптимизируем. Второе место, которое пока не оптимизировано, это вот эта картинка с репликацией,
[15:16.560 --> 15:23.600]  с упорядочиванием репликации транзакций. Эта картинка в разрезе конкретного слота S,
[15:23.600 --> 15:29.200]  и у нас вот для каждого слота параллельно выстраиваются такие картинки. Но вот если вы
[15:29.200 --> 15:34.720]  вспомните multipaxos, то он тоже сначала состоял из отдельных паксосов, в каждом из которых было
[15:34.720 --> 15:41.080]  две фазы, а потом мы заметили, что можно из них построить некоторый конвейер. Вот здесь на самом
[15:41.080 --> 15:47.280]  деле тоже такая идея прямо просится, потому что, смотрите, давайте транзакцию перерисую здесь.
[15:47.280 --> 15:54.360]  Вот видите, сообщения prepare и commit, они написаны рядом, и смысл у них, конечно,
[15:54.360 --> 16:02.200]  разный, но при этом они структурно очень похожи. И что происходит после первой фазы? После первой
[16:02.200 --> 16:07.400]  фазы мы собираем коронный сертификат. Вот мы реплика, мы накопили коронный сертификат из
[16:07.400 --> 16:13.920]  prepare, который означает, что на большинстве честных транзакций. А потом мы совершаем еще один раунд
[16:14.040 --> 16:22.400]  коммуникации и накапливаем уже два f плюс один коммитов, и фактически мы собираем коронный
[16:22.400 --> 16:28.320]  сертификат, где каждое сообщение говорит, что у отправителя этого сообщения есть коронный
[16:28.320 --> 16:38.560]  сертификат. То есть мы собрали такой коронный сертификат, коронного сертификата. Так вот,
[16:38.560 --> 16:43.640]  если абстрагироваться от смысла этих фаз, о том, что здесь мы что-то понимаем, здесь мы
[16:43.640 --> 16:47.600]  там... Здесь мы понимаем, что на большинстве, здесь мы понимаем, что большинство понимает,
[16:47.600 --> 16:51.880]  вот если от этого абстрагироваться и просто посмотреть на формальную структуру, то вот так и
[16:51.880 --> 16:57.640]  хочется сказать, что мы возьмем для слота S такую картинку и ниже приложим картинку для слота S
[16:57.640 --> 17:04.080]  плюс один, а выше для S минус один. И когда мы проходим через вторую, через первую фазу для
[17:04.080 --> 17:10.760]  слота S и собираем коронный сертификат первый, то мы могли бы вместе с этим собрать коронный
[17:10.760 --> 17:17.120]  сертификат, кормовый сертификат для слота S-1. Ну и вот так дальше.
[17:17.120 --> 17:22.960]  Если смотреть на PBFT, можно увидеть, что здесь хочется сделать конвейер.
[17:22.960 --> 17:30.200]  А теперь вспомним про биткоин. И вот тут нам знание биткоина потребуется.
[17:30.200 --> 17:36.960]  В биткоине у нас вообще лога не было. И не было слотов. У нас вместо этого был блокчейн.
[17:40.760 --> 17:54.720]  Он начинался с некоторого джинезис блока B0. Дальше ROS, ROS, ROS. И теперь...
[17:54.720 --> 18:08.960]  Давайте нарисуем сеть сначала. Вот сеть. Реплик этого самого блокчейна.
[18:08.960 --> 18:12.200]  В эту сеть можно было свободно приходить, свободно уходить.
[18:12.200 --> 18:21.160]  Алгоритм работал в модели permission-less. Собственно, от этого все различия и появлялись.
[18:21.160 --> 18:30.040]  Каждый узел был репликой этого самого блокчейна, и каждый узел получал транзакции от пользователей.
[18:30.040 --> 18:36.600]  А дальше они распространялись гостепротоколом.
[18:36.600 --> 18:55.720]  Ну и вот какой-то блок посередине, который получал зеленую транзакцию красную, он строил из них блок
[18:55.720 --> 19:01.320]  и хотел в этот блокчейн свой новый блок с двумя транзакциями добавить.
[19:01.320 --> 19:09.560]  Вот у этого узла появлялся блок с красной и зеленой транзакцией.
[19:09.560 --> 19:19.560]  Ну а дальше, как мы решали, кто именно из вот этих вот узлов в сети добавит свой блок,
[19:19.560 --> 19:24.640]  потому что у каждого узла он мог быть свой. Для этого мы разыгрывали это право в лотерею с помощью
[19:24.640 --> 19:31.640]  proof-of-work. Мы решали пазл, который выглядел следующим образом. Мы брали хэш, криптографический
[19:31.640 --> 19:39.720]  SHA-256 от SHA-256, от заголовка блока, в который входил хэш-поинтер, то есть хэш предшествующего
[19:39.720 --> 19:50.240]  блока, которым мы цеплялись. Входил хэш корень дерева меркла всех транзакций в блоке и нонс.
[19:50.240 --> 19:58.640]  Вот лотерейный беретик, который мы ищем. И мы хотим, чтобы хэш от этой конкатинации был маленьким,
[19:58.640 --> 20:10.640]  то есть он начинался с некоторого количества нулей. Сложность этого самого пазла. И если какой-то узел,
[20:10.640 --> 20:17.280]  который заинтересован, и каждый узел, который был заинтересован в том, чтобы добавить очередной блок
[20:17.280 --> 20:21.760]  блокчейн, решал этот пазл. То есть он перебирал нонс, потому что, кроме перебора, никакой разной
[20:21.760 --> 20:29.640]  стратегии не было. И если он находил этот нонс, то он сразу распространял его по сети.
[20:29.640 --> 20:37.960]  Вот этот узел он назывался майнером, ну и сам процесс майнинга. У нас была проблема с тем,
[20:37.960 --> 20:42.600]  что два узла, два майнера могли найти разные продолжения блокчейн.
[20:42.600 --> 20:54.440]  И давайте вспомним, каким образом мы вот эту ситуацию разрешали. У нас возник форк. Два блока
[20:54.440 --> 21:02.520]  здесь абсолютно равноправны, оба из них имеют право. Оба из них принадлежат этому дереву блоков
[21:02.520 --> 21:08.960]  уже. Это перестала быть цепочка, конструкция стала деревом. Мы должны разрешить этот форк выбрать
[21:08.960 --> 21:19.080]  одну из продолжений. Для этого мы что делали? Мы продолжали майнить. Вот каждый узел, каждый
[21:19.080 --> 21:24.440]  майнер, который хотел добавить свой блок, он в текущем дереве выбирал, во-первых, самую длинную
[21:24.440 --> 21:28.680]  цепочку. Ну а если у нас несколько продолжений, одинаковые длины есть, то мы просто выбирали ту,
[21:28.680 --> 21:35.960]  про которую мы узнали раньше. И мы майнили за ней. Потому что, когда мы решаем этот пазл,
[21:35.960 --> 21:43.160]  мы цепляемся к какому-то конкретному блоку. И, с одной стороны, мы по-прежнему играем в лутерею,
[21:43.160 --> 21:48.360]  то есть мы пытаемся стать лидером в этом раунде, добавить свой блок. А, с другой стороны, продолжая
[21:48.360 --> 21:55.040]  этот майнинг, мы своим процессорным временем голосуем, своим хешрейтом голосуем либо за одну,
[21:55.040 --> 22:05.320]  либо за другую цепочку. И вот тут и нужно увидеть пайплайнинг. То есть, с одной стороны, мы играем
[22:05.320 --> 22:11.840]  в лутерею, а, с другой стороны, мы придавливаем своим перебором предшествующую историю. Если мы
[22:11.840 --> 22:18.640]  найдем нонс, то он же... Какой смысл имеет? Он доказывает, что наш новый блок следует за каким-то
[22:18.640 --> 22:24.800]  другим конкретным блоком. Вот новый блок B следует за блоком конкретным B'. А в этом конкретном блоке
[22:24.800 --> 22:32.600]  B' уже есть... У него тоже есть хешпойнт-разголовки. То есть наш нонс доказывает, что мы, на самом деле,
[22:32.920 --> 22:38.920]  прицепились вот к такой цепочке. Ну и так можно продолжить до самого основания, то есть до блока B'.
[22:38.920 --> 22:51.440]  Тот же нотис-блок. Ну вот это же форма конвейера, на самом деле. И теперь можно подумать, что если мы
[22:51.440 --> 22:58.520]  вдруг заменим в PBFT наш лог с независимыми слотами и вот протокол независимый для каждого слота
[22:58.520 --> 23:05.120]  на блокчейн с хешпойнтерами, то мы сможем эти кормные сертификаты накапливать более эффективно.
[23:05.120 --> 23:15.000]  Другая идея, которая в биткоине может быть полезна нам здесь, это процедура выбора лидера. Вот здесь у
[23:15.000 --> 23:23.600]  нас лидер есть... Слишком много маркеров накопилось. У нас здесь есть лидер, мы иногда его сбрасываем
[23:23.600 --> 23:32.240]  и меняем на нового. Но вот эта процедура смены лидера, она очень тяжелая, очень громоздкая. В биткоине,
[23:32.240 --> 23:36.880]  наоборот, эта процедура просто встроена в протокол в быстрый путь. Но этот путь не очень быстрый,
[23:36.880 --> 23:42.640]  потому что раз 10 минут. Но тем не менее, мы просто в каждом раунде выбираем нового лидера с помощью
[23:42.640 --> 23:54.240]  proof-of-work. Это еще одно место, где мы сегодня сможем PBFT ускорить. План дальше такой. Мы алгоритм
[23:54.240 --> 24:01.160]  вспомнили, теперь нужно все эти детали совместить. Смотрите, у нас есть здесь artiting primary,
[24:01.160 --> 24:06.920]  здесь у нас есть просто случайный лидер для каждого раунда. Идея отсюда можно перенести сюда. Здесь у
[24:06.920 --> 24:12.720]  нас есть накопление кормных сертификатов, здесь у нас есть для этого хэшпоинта, которые могут
[24:12.720 --> 24:19.120]  делать это более эффективно. Здесь нет вообще кормных сертификатов, но здесь есть nonce. И он сам
[24:19.120 --> 24:26.480]  по себе доказывает, что над веткой работает много узлов. Так же, как и здесь, кормный сертификат
[24:26.480 --> 24:35.320]  доказывает, что много честных узлов проголосовало за одну или другую транзакцию. Только здесь
[24:35.320 --> 24:45.880]  кормные сертификаты в пределах раунда могут быть только одним в PBFT. Потому что кормы пересекутся
[24:45.880 --> 24:54.960]  по одному честному узлу. В биткоине в пределах одного раунда, так условно, за одним блоком может
[24:54.960 --> 25:00.760]  быть два разных блока, то есть два разных nonce. И вот ровно поэтому биткоин теряет finality. То есть
[25:00.760 --> 25:10.040]  теряет возможность закометить блок. Всегда можно переманить альтернативную цепь. Мы хотим
[25:10.040 --> 25:15.600]  воспользоваться хэшпоинтами для пайплайнинга, но, конечно, мы не хотим использовать nonce в таком
[25:15.600 --> 25:22.320]  виде, потому что они нам помешали. Ну и вообще, какой из двух подходов мы выберем? Потому что
[25:22.320 --> 25:28.000]  нужно от этого вообще исходить. Мы выберем в нашем протоколе hotstuff permission подход. То есть
[25:28.000 --> 25:35.680]  мы будем фиксировать число реплик. Почему мы этого хотим? Мы хотим этого, потому что мы хотим
[25:35.680 --> 25:42.640]  иметь понятие коммита. Мы хотим, чтобы какие-то блоки фиксировались в истории. У нас будет
[25:42.640 --> 25:47.200]  блокчейн, ну точнее дерево блоков, но при этом блоки там будут фиксированы в какой-то момент.
[25:47.200 --> 25:53.280]  И перемайнить уже смысла слова это не имеет. Ну, в общем, сделать альтернативный форк уже
[25:53.280 --> 26:02.280]  будет нельзя. Казалось бы, мы получаем что-то потенциально менее децентрализованное, но с другой
[26:02.280 --> 26:09.880]  стороны, если мы сможем избавиться от этого тяжелого view changer, то мы сможем масштабировать
[26:09.880 --> 26:16.840]  наш протокол на большее количество реплик, ну там на сотни. А с другой стороны, если мы говорим про
[26:16.840 --> 26:22.600]  децентрализованный permissionless подход, где число реплик может быть вообще произвольным, то кажется
[26:22.600 --> 26:29.080]  все равно такие подходы, они скатываются в какую-то децентрализацию. Ну почему? Если вы фиксируете
[26:29.080 --> 26:33.760]  хэш-функцию, фиксируете пазл, то можно построить железку, которая будет просто на схеме его
[26:33.760 --> 26:39.480]  реализовывать. И тот, кто построит больше таких железок, купит их, получает преимущество большое.
[26:39.480 --> 26:45.160]  У него концентрируется этот хэш-рейд. Если вы замените этот пазл на какой-то более хитрый,
[26:45.160 --> 26:50.080]  но там на рендомизированный, то все равно кажется, это не сильно поможет, потому что если участников
[26:50.240 --> 26:53.520]  станет слишком много, то они станут редко выигрывать, у которых у них уменьшится, поэтому они снова
[26:53.520 --> 26:58.560]  будут организовываться в пулы, возникнет централизация в той или иной степени. Ну, тут можно разные
[26:58.560 --> 27:06.120]  юристики выдумывать, но в общем, это все довольно уязвимая конструкция. Если мы говорим про, если мы
[27:06.120 --> 27:12.440]  говорим здесь не про proof of work вообще, а скажем, proof of stake, ну это тоже форма централизации, у кого
[27:12.440 --> 27:17.680]  больше денег, тот и решает, какая история продолжится. С одной стороны, да, как бы система ведет себя
[27:17.680 --> 27:23.080]  честно, она следует за честными узлами, но при этом все равно число реплик, фактически, которые принимают решение,
[27:23.080 --> 27:28.360]  довольно невелико. Так что если мы оптимизируем эту конструкцию, то в принципе нам такого подхода
[27:28.360 --> 27:36.720]  должно хватить. Так что на то, что сейчас произойдет, можно смотреть так. Можно считать, что это PBFT,
[27:36.720 --> 27:45.960]  в который принесли дерево блоков, принесли хэш-поинтеры для пайплайнинга, и поэтому вместо лога
[27:45.960 --> 27:56.680]  получилось дерево. И принесли ротацию лидера на каждый раунд, чтобы упростить этот протокол. А можно
[27:56.680 --> 28:05.760]  смотреть иначе. Можно смотреть на протокол hotstaff, который сейчас будет как на консенсус на комото,
[28:05.760 --> 28:12.840]  то есть на консенсусе биткоина, где зафиксировали число реплик, и вот эти нонсы заменили на
[28:12.840 --> 28:19.720]  кормные сертификаты. То есть то, что мы сейчас построим и так, и так, с разных сторон выглядит по
[28:19.720 --> 28:26.800]  разному, но по сути является просто некоторой композицией идей параллельных из двух разных
[28:26.800 --> 28:32.520]  подходов. Как я обещал, чтобы рассказать про этот протокол, в принципе ничего знать не нужно,
[28:32.520 --> 28:55.200]  поэтому давайте мы сотрем что-нибудь. Почти все сотрем. Да, вьюченч нам не нравится, мы хотим от него
[28:55.200 --> 29:15.960]  избавиться, мы его точно сотрем. А определение комит у нас, конечно, тоже будет другое. Да,
[29:15.960 --> 29:25.760]  почему hotstaff, кстати, я не рассказал, кажется. Вот есть эфир, и в нем используется сейчас proof
[29:25.760 --> 29:34.720]  of work. В proof of work нет определения finality. Блоки не фиксируются навсегда. И вот есть желание у
[29:34.720 --> 29:42.160]  разработчиков этого эфира сделать эфириума сделать так, чтобы надо блокчейном построить
[29:42.360 --> 29:48.880]  протокол, который все-таки будет финализировать блоки. Идея этого протокола была предложена в
[29:48.880 --> 29:55.680]  2017 году. Кажется, что скоро собираются это внедрять, и идея называется Casper. Доброе
[29:55.680 --> 30:02.880]  привидение. Доброе, потому что оно привидение, поэтому оно отпугивает плохих людей, и оно доброе,
[30:02.880 --> 30:10.080]  а добрые люди с ним дружат. Поэтому Casper хорошим поможет, а злоумышленником помешает. Вот hotstaff
[30:10.080 --> 30:15.720]  это такой маленький чертенок из истории про Casper. То есть это некоторая альтернатива этому
[30:15.720 --> 30:24.200]  протоколу. Ну вот, мы собираемся в hotstaff строить дерево-блок. То есть у каждой реплики... Да,
[30:24.200 --> 30:37.400]  мы фиксируем число-реплик снова. У нас permission protocol. Число-реплик оптимальное. Каждый из реплик
[30:37.400 --> 30:58.720]  хранит дерево-блок. Каждый блок привязан к некоторому раунду. В каждом раунде появляется
[30:58.720 --> 31:06.880]  некоторый блок. И в каждом раунде этот блок формируется лидером этого раунда. А лидеры в каждом
[31:06.880 --> 31:16.400]  раунде свои. Вот опять мы считаем... Давайте считать, что в раунде K у нас лидер K по модулю N. И как у нас
[31:16.400 --> 31:25.840]  будет выглядеть протокол, по крайней мере общая схема его работы, пока без деталей. Какие там
[31:25.840 --> 31:31.600]  сообщения, как они вообще летают по сети. Итак, у нас жизнь этого блокчейна делится на раунды.
[31:31.600 --> 31:56.880]  В раунде K, например, лидером является вот эта реплика. Она смотрит на свой блокчейн,
[31:57.200 --> 32:05.280]  на это дерево. Каким-то образом строит там новый блок, который к чему-то цепляется. И этот блок
[32:05.280 --> 32:24.360]  рассылает другим репликам. Реплики, получая этот блок, либо голосуют за него, либо отвергают. Каковы
[32:24.440 --> 32:31.120]  именно правила голосования, поговорим позже. Пока будем считать, что реплики довольны. И они в этом
[32:31.120 --> 32:40.560]  случае голосуют за блок, отправляют сообщение vote. Но отправляют его не лидеру раунда K, а лидеру
[32:40.560 --> 33:06.880]  следующего раунда. Вот это мы отправляем сам блок в раунде K, а лидеру следующего раунда,
[33:06.880 --> 33:14.000]  когда реплика, проголосовавшаяся за этот блок, отправляет сообщение vote, где говорит, что в раунде
[33:14.000 --> 33:31.480]  K она проголосовала за блок с хэшом H. Это некоторый аналог хэшпоинтера. Итого, у нас в раунде K
[33:31.480 --> 33:44.120]  появился вот такой блок в блокчейне. И в начале следующего раунда у лидера этого раунда,
[33:44.120 --> 33:52.880]  вот второй реплик на данном рисунке, по возможности собирается кормный сертификат 2F плюс 1, одинаковый
[33:52.880 --> 34:10.240]  vote. То есть большинство честных узлов проголосовало за вот такое продолжение блокчейна. 2F плюс 1, vote
[34:10.240 --> 34:31.800]  Kh. Ну, разумеется, все голоса подписаны, как обычно. Кормный сертификат. И вот этот кормный
[34:31.800 --> 34:39.000]  сертификат будет служить тем самым нонсом. Вот в биткоине, когда мы публиковали новый блок,
[34:39.000 --> 34:43.720]  мы должны были к хэшпоинтеру приложить нонс, который доказывает, что действительно мы проделали
[34:43.720 --> 34:49.640]  работу, и вот блок пристраивается за тем блоком, на который мы ссылаемся. Вот здесь, чтобы лидер
[34:49.640 --> 34:58.120]  раунда K плюс 1 прицепился вот к этому блоку, продолжил эту ветку истории, он должен к своему
[34:58.120 --> 35:05.440]  блоку приложить вот такой вот сертификат. То есть его хэшпоинтер блока — это и есть кормный
[35:05.440 --> 35:09.360]  сертификат. Тут буквально одно и то же. Хэшпоинтер — это кормный сертификат, потому что в кормном
[35:09.360 --> 35:16.800]  сертификате есть хэш предшествующего блока в каждом vote. Рисовать это я буду так. Я буду
[35:16.800 --> 35:24.880]  рисовать черный ромик. Это кормный сертификат. И когда мы публикуем новый блок на месте лидера
[35:24.880 --> 35:37.040]  раунда K плюс 1, когда мы строим новый блок, то мы в него добавляем этот самый кормный сертификат.
[35:37.040 --> 35:54.440]  Прошу прощения. Окей, копаюсь, есть ли вопросы? Или все понятно? А он не выбирается, он вращается
[35:54.440 --> 36:01.080]  так же, как и раньше. Но он просто вращается на каждом раунде. То есть в PBFT мы выбирали лидера,
[36:01.080 --> 36:05.880]  и он там долгое время работал, если он честный. Сейчас мы это хотим немного упростить, сделать
[36:05.880 --> 36:10.520]  чуть менее эффективно в этом месте. В принципе, это можно потюнить, в конце концов. Но сейчас мы
[36:10.520 --> 36:14.440]  для простоты скажем, что у нас лидер вращается каждый раз, как в биткоине. Правда, в биткоине он
[36:14.440 --> 36:17.840]  выбирался случайным, потому что число реплик неизвестно. Здесь мы зафиксировали число реплик,
[36:17.840 --> 36:25.160]  поэтому просто назначаем следующим. Вот этот следующий лидер в раунде К плюс один накапливает
[36:25.160 --> 36:31.960]  этот сертификат и его прикладывает к своему блоку. После чего снова рассылают его всем.
[36:31.960 --> 36:44.240]  Сейчас, секунду, я картинку дорисую. Ну и тут снова происходит то же самое. Реплики голосуют за
[36:44.240 --> 36:49.880]  этот блок и отправляют свои голоса следующему лидеру. Лидеру следующего раунда.
[37:03.240 --> 37:12.680]  И у лидера следующего раунда появляется новый хэшпоинтер. Следующий сертификат, который
[37:12.680 --> 37:17.520]  подтверждает, что большинство честных узлов проголосовало за эту ветку. Ну и вот блокчейн,
[37:17.520 --> 37:30.600]  он так дальше вглубь растет. В чем проблема? Лидер раунда К плюс два, он просто византийский,
[37:30.600 --> 37:35.240]  у него накопился сертификат кормный, а ему просто не хочется эту ветку продолжать,
[37:35.240 --> 37:44.440]  и он выбрасывает этот кормный сертификат. Что делать честным узлам? Ну, если честные узлы
[37:44.440 --> 37:50.680]  не дождутся за некоторое время в текущем раунде нового блока от лидера текущего, то, видимо,
[37:50.680 --> 37:55.080]  они могут перейти в следующий раунд. Это не проблема. Ну, точнее, тут нужно делать немного
[37:55.080 --> 37:59.240]  аккуратнее, то есть нужно, чтобы все это делали более-менее синхронно. Поэтому нужно снова
[37:59.240 --> 38:05.080]  собрать кормный сертификат перехода в следующую эпоху, в следующий раунд. Но это уже сейчас,
[38:05.080 --> 38:17.640]  прямо сейчас не очень важно. Важно то, что как же они продолжат вот эту ветку. Ну вот, допустим,
[38:17.640 --> 38:25.640]  мы эту эпоху скипнули, этот раунд скипнули, потому что плохой лидер, и вот мы переместились в раунд К
[38:25.640 --> 38:33.800]  плюс 3. И как же мы собираемся прицепиться к этому блоку теперь? Чтобы к нему прицепиться,
[38:33.800 --> 38:41.640]  нужно иметь вот такой хэшпоинтер. Ты спрашивал про нонсы, где здесь нонсы, да? Здесь нет нонсов,
[38:41.640 --> 38:49.040]  потому что, еще раз, у нас была аналогия, что нонс в биткоине подтверждал хэшпоинтер. Нонс,
[38:49.040 --> 38:54.920]  он доказывал, что большинство сети работает над этой веткой. Здесь у нас вместо этого нонса
[38:54.920 --> 39:00.040]  и пруфуфворка просто кворумные сертификаты, которые доказывают, что большинство сети голосует за
[39:00.040 --> 39:07.440]  вот эту ветку. То есть у нас от биткоина остались хэшпоинтеры, но мы эти хэшпоинтеры подтверждаем
[39:07.440 --> 39:13.240]  теперь не процессором, не перебором кэшей, а просто голосами, потому что у нас число
[39:13.240 --> 39:17.240]  реплик фиксированное. В биткоине это почему мы так делали? Потому что у нас были не фиксированные
[39:17.240 --> 39:21.560]  кворумы, у нас были кворумы в процессорах. Теперь у нас кворумы обычные в голосах, и поэтому
[39:21.560 --> 39:28.920]  сертификатов достаточно. Так вот, что делать в раунде K plus 3?
[39:42.920 --> 39:50.840]  Ну нет, в K plus 3 в раунде у праймари нет. У праймари вот такой блокчейн, и пресс-сертификат
[39:50.840 --> 40:02.560]  не знает ничего. Волты ушли сюда. Можно придумывать другой протокол, но в этом протоколе узлы
[40:02.560 --> 40:09.360]  просто делают форк. Какая-то ветка заглохла, потому что очередной участник оказался
[40:09.360 --> 40:15.160]  злоумышленником. Но не беда, что мы можем сделать? Мы можем просто из опубликованного блокчейна
[40:15.160 --> 40:21.840]  изъять кворумный сертификат, уже известный, и переиспользовать его. Да, вот, кстати, в этом
[40:21.840 --> 40:27.360]  блоке теперь тоже есть кворумный сертификат, но понятно, что все это продолжалось. Так вот,
[40:27.360 --> 40:38.280]  что сделает участник лидер раунда K plus 3? Он построит новый блок и переиспользует вот этот
[40:38.280 --> 40:50.000]  кворумный сертификат. Мы попали в раунд K plus 3. Почему мы стали лидером в раунде K plus 3?
[40:50.000 --> 40:57.840]  Потому что нам большинство узлов сказало, что тайм-аут. Потому что нужно пропускать такие раунды,
[40:57.840 --> 41:02.440]  где ничего не происходит. И мы делаем форк. Но теперь форк это неплохо, форк это наша цель,
[41:02.440 --> 41:12.040]  потому что она позволяет нам обходить заглохшие ветки. Окей, значит, получилось, да? Я бы сказал,
[41:12.040 --> 41:17.440]  что это практически весь алгоритм. Осталось только разобраться, какие блоки мы считаем
[41:17.440 --> 41:24.720]  закоммитченными и каковы правила голосования. То есть когда мы отправляем голос. Вот прелесть
[41:24.720 --> 41:28.040]  протокола, что это более-менее единственное сообщение, которое у нас есть. Ну и считаем
[41:28.040 --> 41:39.000]  вот. Потому что мы не можем продолжить эту ветку, потому что мы не знаем сертификата,
[41:39.000 --> 41:43.920]  а без сертификата нельзя сослаться на этот блок. У нас ссылка это сертификат.
[41:43.920 --> 41:56.600]  Вот блок публикуется вот здесь вот. Вот он опубликован. Все за него проголосовали.
[41:56.600 --> 42:01.680]  Вот этот узел накопил к органу сертификат и теперь можно использовать его как ссылку.
[42:01.680 --> 42:07.600]  Вот да, но он его потратил, поэтому мы просто переиспользовали старый сертификат и сделали форк.
[42:07.600 --> 42:16.040]  Что теперь нужно уточнить? Как именно мы голосуем и какие именно блоки мы считаем
[42:16.040 --> 42:21.160]  закоммитченными? Ну давайте с коммитом начнем. Мы скажем, что блок закоммитчен,
[42:21.160 --> 42:35.760]  если он трижды сертифицирован в подряд идущих раундах. Вот был опубликован блок B0. Для него
[42:35.760 --> 42:44.840]  был собран сертификат, который использовался как ссылка, как хэшпоинтер в блоке B1, за который
[42:44.840 --> 42:49.560]  снова проголосовало большинство честных узлов. Был собран сертификат, который был переиспользован
[42:49.560 --> 42:58.680]  в блоке B2, для которого снова был собран сертификат. Вот трижды сертифицированный блок
[42:58.680 --> 43:13.040]  объявляется закоммитченным. Заметим, что это свойство глобальное. Вот этот сертификат может быть
[43:13.040 --> 43:22.800]  собран у византийского узла и, тем не менее, все равно это приводит к закоммитчиванию блока. То,
[43:22.800 --> 43:27.520]  что этот сертификат может не наблюдаться никем, это отдельная история. Ну как в ПАКСОСе,
[43:27.520 --> 43:31.960]  отдельные аксепторы тоже мало что понимают, но при этом определение коммита такое, что на
[43:31.960 --> 43:38.240]  большинстве аксепторов проголосовало один и тот же проползл. Тоже глобальное определение.
[43:38.240 --> 43:54.480]  Правила голосования. Правило 2. Вот мы реплика. Мы получаем в каком-то раунде K очередной блок.
[43:54.480 --> 44:04.600]  Во-первых, мы голосуем за блоки строго монотонно по раундам. То есть мы помним последний раунд,
[44:04.600 --> 44:08.640]  в котором мы голосовали за блок и голосуем только если у нового блока раунд больше.
[44:08.640 --> 44:21.680]  Ну, похоже на обычный ПАКСОС. Правда, смысл немного сложнее, но не суть. Может быть,
[44:21.680 --> 44:26.760]  на зачете поговорим с кем-нибудь. Если кому-то повезет, то сможем разобраться,
[44:26.760 --> 44:32.640]  откуда такое правило берется, какова его интуиция. Вот 2 правило, оно более сложное в определении,
[44:32.640 --> 44:44.040]  зато интуицию пояснить проще, мне кажется. Введем понятие locked round. Locked round для дерева блоков.
[44:44.040 --> 44:54.160]  Вот у каждой реплики есть дерево. И что мы сделаем? У каждого блока в этом дереве есть
[44:54.160 --> 45:09.640]  какой-то раунд, в котором блок был построен. Ну, я вот откуда-то нарисую. 7, 8, 10, 9, 11.
[45:09.640 --> 45:22.400]  Что мы сделаем? Мы возьмем все листья и отступим от каждого листа два шага вверх. Посмотрим на всех дедушек.
[45:22.400 --> 45:31.840]  Вот это не высота, это раунд, в котором блок появлялся. Они могут быть на одинаковой
[45:31.840 --> 45:37.520]  высоте с разными раундами. Вот здесь нарисована не высота блока, а раунд, в котором он появился
[45:37.520 --> 45:47.240]  в этом дереве. Так вот, мы возьмем все листы, отступим два шага вверх и выберем из этих дедушек,
[45:47.240 --> 45:56.720]  из этих блоков, блок с максимальным раундом. Вот этот раунд объявим Locked round. И мы скажем,
[45:56.720 --> 46:10.600]  что блок, мы, реплика, голосуем за блок B, если раунд блока, к которому цепляется блок B,
[46:10.600 --> 46:27.160]  не меньше, чем Locked round. Повторюсь, это раунд, в котором объявился блок.
[46:27.160 --> 46:52.800]  Вот такой сценарий был уже нарисован. Ты хочешь, чтобы я написал 11 или 12? Здесь что-нибудь будет
[46:52.800 --> 47:03.320]  написано, давай я не буду угадываться. Что? Не очень понимаю твой вопрос. Числа имеют значение,
[47:03.320 --> 47:21.200]  потому что с помощью этих чисел определяется понятие Locked round. Ты хочешь, чтобы я числа здесь
[47:21.200 --> 47:31.280]  аккуратнее подобрал? Вот здесь 8, 9, 10 пропущен, 11 какой-нибудь. Чем это продолжается? Ну хорошо,
[47:31.280 --> 47:36.800]  это справедливое замечание, не очень нужное сейчас, но справедливое. Да, я согласен с тобой.
[47:36.800 --> 47:46.720]  Мы берем дерево блоков, в этом дереве есть ссылки, хэшпоинтеры, такие сертификаты, и каждый блок
[47:46.720 --> 47:51.960]  был построен в некотором раунде. Мы взяли листья, все отступили от каждого листа два шага назад,
[47:51.960 --> 47:57.760]  получили набор блоков. Отступили отсюда два шага, получили вот узел, отступили отсюда два шага,
[47:57.760 --> 48:07.640]  получили вот узел. И говорим, что Locked round это максимальный по раунду дедушка в этом дереве.
[48:07.640 --> 48:20.840]  То есть мы из этих блоков выбрали максимальный по номеру раунда. Нет, комит пока не нужен. Это
[48:20.840 --> 48:25.040]  просто правило голосования для дерева. У нас есть дерево, и мы отступаем дважды вверх.
[48:25.040 --> 48:32.200]  Да, про закомитченность давайте я еще раз уточню, что мы говорим, что блок закомитчен,
[48:32.200 --> 48:46.800]  если он на него, он трижды сертифицирован в подряд идущих раундов. Это важно. Ну вот,
[48:46.800 --> 49:00.000]  каков физический смысл этого правила? Ясно ли это? Это round pair. Даже не знаю, как сказать. Это
[49:00.000 --> 49:04.320]  round блок, на который ссылается B. Но вот блок, он же к чему-то цепляется, у него есть какой-то
[49:04.320 --> 49:11.240]  хэшпоинтер. Вот мы смотрим на round блока родителя, к которому мы цепляемся. И вот этот round должен
[49:11.240 --> 49:27.320]  быть не меньше, чем Locked round для дерева нашего. Что? Постри, пожалуйста, я не разобрал. Вот есть
[49:27.320 --> 49:33.320]  реплика, у нее есть дерево, она получает от лидера текущего раунда очередной блок. Смотрит,
[49:33.320 --> 49:41.560]  если она не голосовала за блоки из больших раундов, больше либо равных. Сейчас. Если она
[49:41.560 --> 49:51.600]  голосовала за раунды, больше либо равные текущему раунду текущего блока полученного, то не голосует.
[49:51.600 --> 49:59.280]  Если не голосовала, то запоминает новый максимум и голосует. Но только если Locked round дерева этой
[49:59.280 --> 50:12.920]  реплики не больше, чем round родителя, к которому цепляется вот в дереве. Это блок B. В чем смысл,
[50:12.920 --> 50:19.440]  в чем интуиция второго правила? Она очень простая. Но она немного произвольная. Тут есть какая-то
[50:19.440 --> 50:23.400]  магическая константа странная. Вот мы отступаем здесь на два шага, то есть мы берем дедушку и
[50:23.400 --> 50:29.600]  требуем трех сертификатов. Похоже на какой-то произвол. Какая-то магическая константа 3 здесь.
[50:29.600 --> 50:37.400]  Но если вот об этом не думать пока, мы к этому вернемся еще, то смысл должен быть понятен. Вот
[50:37.400 --> 50:47.960]  здесь, по крайней мере. Мы запрещаем глубокие форки. Мы не можем форкнуться далеко от листьев. Мы
[50:47.960 --> 50:54.400]  какие-то ветки можем альтернативные продолжать, но не можем делать это на четыре шага вверх.
[50:54.400 --> 51:04.160]  А правило commit здесь очень естественное, потому что у нас здесь собрался коронный
[51:04.160 --> 51:15.800]  сертификат. Здесь коронный сертификат коронного сертификата. Ну и здесь тройной такой коронный
[51:15.800 --> 51:26.600]  сертификат. В общем, это вот pipeline, который был вот здесь. Ну что дальше? Мы уже здесь избавились
[51:26.600 --> 51:38.760]  от выбора лидеров, уже приятно. Осталось доказать, что определение committ вот такое разумно. Что
[51:38.760 --> 51:47.480]  значит разумно? Вообще понятие разумности в каждом алгоритме свое. Если мы говорим про
[51:47.480 --> 51:54.240]  multipax, то понятие committ означало... Мы доказывали, что если слот закоммитчен, то новый лидер
[51:54.240 --> 52:00.520]  перезаписать его не может. В RAFT мы доказывали, что если мы команду закоммитили, то она переживет
[52:00.520 --> 52:10.600]  смену эпохи. Вот здесь мы покажем, что если... Точнее, не так. Что у нас вообще нет смены
[52:10.600 --> 52:18.280]  эпохи, логов нет, перезаписи нет. Мы покажем, что два любых закоммитченных блока просто лежат
[52:18.280 --> 52:33.480]  в дереве блоков на одной цепи. Ну и сотрем VFT.
[52:33.480 --> 52:56.200]  Теорема. Мы докажем немного более сильное утверждение. Будет звучать так. Пусть у нас
[52:56.200 --> 53:11.760]  есть блок B0. Он закоммитченный. То есть для него собран сертификат C0, который был
[53:11.760 --> 53:18.560]  использован в блоке B1, который тоже был сертифицирован. И этот сертификат в качестве
[53:18.560 --> 53:26.200]  хэшпоинтера был использован в блоке B2, который тоже был сертифицирован. И у нас есть
[53:26.200 --> 53:46.040]  некоторый волнистый блок B, который просто сертифицирован. И блок, и раунд блока B с волной
[53:46.040 --> 53:58.520]  не меньше, чем раунд закоммитченного блока B0. Вот тогда мы покажем, что блок B с волной
[53:58.520 --> 54:14.400]  является потомком блока B0. Ну давайте какие-то простые случаи сначала разберем. Вот пусть раунд
[54:14.440 --> 54:27.720]  сертифицированного блока B с волной просто совпадает с раундом блока B0. Что это означает? Это один
[54:27.720 --> 54:32.360]  и тот же блок, потому что два блока сертифицированы, а сертифицированное значит, у них собрал скорбный
[54:32.360 --> 54:38.320]  сертификат размера 2F плюс один. Значит, в пересечении есть по крайней мере нечестный узел. А значит, он должен
[54:38.320 --> 54:54.320]  голосовать одинаково. Значит, это был один и тот же блок. Хорошо, второй частный случай. Раунд B с волной
[54:54.320 --> 55:13.600]  равен раунду B0 плюс один. Что мы здесь можем заметить? Ну у нас понятие закоммитченности требовало,
[55:13.600 --> 55:21.360]  чтобы раунды шли подряд. Поэтому если раунд блока B0 плюс один, это просто по определению
[55:21.360 --> 55:31.520]  commit раунд B1. Ну и снова в одном раунде, если блок B1 и блок B с волной сертифицированы оба,
[55:31.520 --> 55:41.800]  поэтому снова в этом случае мы получаем, что B с волной совпадает с B1, а B1 потомок блока B0.
[55:41.800 --> 55:54.280]  Случай r волнистого блока равен rB0 плюс 2 понятно то же самое. Поэтому давайте перейдем к
[55:54.280 --> 56:02.520]  содержательному случаю. Блок, раунд блока B с волной просто больше, чем раунд блока B2.
[56:02.520 --> 56:15.080]  Смотрите, вот эти два блока B с волной и B2 были сертифицированы. То есть за
[56:15.080 --> 56:20.320]  каждой из них проголосовало большинство частных участников. Вот нарисуем два
[56:20.320 --> 56:27.480]  quorum. Это quorum для волнистого блока, это quorum для третьего блока в цепочке комитов.
[56:27.480 --> 56:39.960]  В пересечении у нас, по крайней мере, F плюс один узел, по крайней мере один честный узел.
[56:39.960 --> 56:55.680]  И этот честный узел проголосовал и за B с волной, и за B2. Вот нарисуем его таймлайн.
[56:55.680 --> 57:04.080]  В каком порядке он мог голосовать за B с волной и за B2? По этому правилу голосования он голосует
[57:04.080 --> 57:10.760]  строго монотонно по раунду. А раунд B2 меньше, чем B с волной, поэтому он сначала должен был
[57:10.760 --> 57:22.800]  проголосовать за B2 и только потом за B с волной. Но чтобы проголосовать за B с волной, он должен
[57:22.800 --> 57:37.160]  был убедиться, что parent B с волной не меньше, чем locked round. А locked round в этот момент уж точно
[57:37.160 --> 57:43.440]  это максимум из всех дедушек, а мы знаем, что вот есть, по крайней мере, такой блок B2 и перед ним
[57:43.440 --> 57:51.560]  еще есть B1 и B0. То есть мы знаем, что locked round в этот момент уж точно не меньше, чем раунд блока B0.
[57:51.560 --> 58:15.960]  Да, получилось? Ну вот тогда из этих рассуждений мы и получаем, что round parent волнистого блока не
[58:15.960 --> 58:24.360]  меньше, чем round B0. Ну вот, собственно, и все. Теперь мы берем в нашем утверждении B с волной,
[58:24.360 --> 58:30.720]  пользуемся этими рассуждениями и переходим вот к такому же случаю, просто с раундом меньше.
[58:30.720 --> 58:37.560]  Мы уменьшаем round. Ну и в какой-то момент мы свалимся вот в эти частные случаи и получим то, что нам нужно.
[58:37.560 --> 58:53.960]  Да, прости, я не сказал этого. Конечно, да. Когда мы голосуем за блок, если он нас устраивает,
[58:53.960 --> 59:04.320]  если он вписывает свои ограничения, то мы добавляем его в наше дерево. Ну что, значит, мы можем
[59:04.320 --> 59:11.080]  подниматься от B с волной и мы не сможем перескочить блок B0. Мы находимся в его под дерево.
[59:11.080 --> 59:20.280]  Ну вот и все. То есть мы действительно показали сейчас, что закоммиченные блоки лежат на одной цепочке.
[59:20.280 --> 59:28.920]  Здорово, да? Но есть... вот алгоритм, кажется, гораздо проще, чем PBFT, но уж точно проще, чем PBFT.
[59:29.760 --> 59:38.040]  Похож на биткоин по этой структуре. Мы строим дерево из блоков, там есть хэшпоинтеры, но поскольку у нас
[59:38.040 --> 59:44.920]  теперь не proof of work и нонсе, а quorum-сертификаты, потому что есть фиксированный набор реплик и quorum
[59:44.920 --> 59:51.120]  можно собирать, взаимоисключающие, то у нас появляется определение коммита. Это прекрасно,
[59:51.120 --> 59:58.480]  но внимательный слушатель заметил бы давно уже, а где мы в этих рассуждениях использовали
[59:58.480 --> 01:00:10.360]  магическую константу 3? Ну вот давай я вот эти правила и определение коммита немного скорректирую.
[01:00:10.360 --> 01:00:16.960]  Я скажу, что locked round – это просто старший родитель, то есть я от листов отступаю только один шаг вверх,
[01:00:16.960 --> 01:00:24.440]  и скажем, в определении коммита тоже хвостик обрежу. Скажу, что у меня достаточно двух сертификатов,
[01:00:24.440 --> 01:00:32.840]  а не трех. Что же мне помешает провести те же самые рассуждения? Просто я вот длиной цепочки
[01:00:32.840 --> 01:00:39.040]  пользовался где? Ну вот я сказал, что раз мы проголосовали за B-сволной, значит locked round был не меньше,
[01:00:39.040 --> 01:00:45.400]  а locked round – это два шага назад, вот я сделал два шага назад, получил бы ноль. Если я locked round
[01:00:45.400 --> 01:00:50.720]  в определении уменьшу константу на один, то мне нужно будет сделать один шаг, поэтому я и цепочку
[01:00:50.720 --> 01:00:59.680]  коммита сокращу тоже на один. Поэтому кажется, совсем это утверждение про safety этого протокола
[01:00:59.680 --> 01:01:08.400]  от этой магической константы 3 не зависит. Можно было сделать бы и 2, и 1. Или 4, ты верно меня понял,
[01:01:08.400 --> 01:01:17.720]  или 4. Вот, давайте теперь подумаем, почему нельзя 1, 2, и 4. Это плохая идея будет. По-разному плохая,
[01:01:17.720 --> 01:01:28.640]  ну давайте с четырех начнем, начнем это самый простой вариант. Ну сейчас, это вопрос какой-то
[01:01:28.640 --> 01:01:36.120]  вкуса, но далеко и далеко. Вот 4 мы просто не можем себе позволить в таком протоколе.
[01:01:36.120 --> 01:01:47.440]  Можно. Так мы же про это и говорим сейчас. Еще раз, я же сказал, что вот safety мы доказали,
[01:01:47.440 --> 01:01:52.280]  и вот в этих рассуждениях мы нигде существенным образом 3 не использовали. Точнее, мы использовали
[01:01:52.280 --> 01:01:58.240]  то, что здесь два шага вверх, и вот эта тройка согласована. Определение коммита согласовано
[01:01:58.240 --> 01:02:05.480]  с правилом голосования. Ну подстроим и там, и там. Можно сделать 4 сертифицированный,
[01:02:05.480 --> 01:02:14.920]  единошно сертифицированный, дважды сертифицированный. Вот, смотрите, мы не можем взять 4, потому что чтобы
[01:02:14.920 --> 01:02:21.520]  блок закомитивался, нужно чтобы в четырех подряд идущих раундах за нас за цепочку проголосовала
[01:02:21.520 --> 01:02:29.560]  большинство. Вот если у нас число реплик 3, f плюс 1, то гарантированно будет 3 подряд идущих
[01:02:29.560 --> 01:02:42.920]  честных где-то. Что? Ну когда-нибудь. Вот, а 4 уже никогда не может не быть. Окей, что?
[01:02:42.920 --> 01:03:00.160]  Да, ну мы же по кругу ходим. Это, например, можно предустрелить, например, от четырех узлов и одного византийского.
[01:03:00.160 --> 01:03:12.120]  Ну вот, мы здесь забили, точнее, на продолжение блокчейна. Вот, если 4 не стоит, ну 4 может быть не
[01:03:12.120 --> 01:03:21.160]  стоило, потому что как бы и сменчивая цепочка работала, зачем как бы медленнее делать? Почему нельзя 1? Вот мы
[01:03:21.160 --> 01:03:28.840]  говорим, что блок закомитчен, если для него собрался сертификат. И мы говорим, что locked round для дерева это просто
[01:03:28.840 --> 01:03:46.160]  старший лист. Почему так нельзя делать? Кто он? Какой лидер? Тут много лидеров, они на каждом раунде свои. Вот,
[01:03:46.160 --> 01:03:54.240]  смотрите, если мы скажем, что commit block это просто сертификат, то что значит commit? Что можно новые
[01:03:54.240 --> 01:03:59.960]  блоки добавлять только в под дерево. Ну а теперь представим, вот у нас блок в раунде K плюс 1, он вроде как закомитчен,
[01:03:59.960 --> 01:04:05.600]  потому что для него сертификат собрался. Но этот сертификат, византийский узел, лидер раунда K плюс 2,
[01:04:05.600 --> 01:04:12.160]  никому не сказал. Нам нужно форкнуться, переиспользовать этот сертификат. Но мы не можем форкнуться,
[01:04:12.160 --> 01:04:23.280]  потому что здесь parent от этого раунда будет в раунде K, а locked round будет K плюс 1. Мы просто запрещаем
[01:04:23.280 --> 01:04:33.960]  себе форки. Вот мы хотим форкаться, ну хотя бы на шаг вверх. Ну и тогда давайте сделаем здесь
[01:04:33.960 --> 01:04:43.560]  вот два сертификата и locked round определим как старший родитель для всех листов.
[01:04:54.120 --> 01:05:00.360]  Ну раз три, а не два, то видимо не очень здорово. Есть какие-то проблемы.
[01:05:00.360 --> 01:05:12.520]  Но этот случай, он не простой уже, точнее он сложнее, чем два вот этих 4 и 1, они были тривиальными.
[01:05:12.520 --> 01:05:30.480]  Нарисуем такую картинку. У нас есть вот блок в раунде K, он оказался сертифицирован,
[01:05:30.480 --> 01:05:42.920]  был построен блок в раунде K плюс 1, он оказался сертифицирован, за него проголосовал большинство
[01:05:42.920 --> 01:05:50.520]  честных. Но в раунде K плюс 2 так случилось, что в раунде K плюс 2 все было тоже в общем-то хорошо,
[01:05:50.520 --> 01:06:00.640]  в смысле лидер был честного, не византийским. Он построил блок, добавил его в свой блокчейн,
[01:06:00.640 --> 01:06:08.280]  а потом, я не знаю, он перезагрузился, например, залип надолго. И он не успел до тайм-аута в этом
[01:06:08.280 --> 01:06:22.320]  раунде этот блок никому раздать. Но у него он есть. Вот нарисуем всю сеть. Вот здесь есть какое-то
[01:06:22.320 --> 01:06:27.720]  количество, не знаю, византийских или мертвых, ну пусть даже византийских, чтобы они мешали,
[01:06:27.720 --> 01:06:37.040]  вот тормозили честный узел. Вот здесь вот F византийских и есть вот этот зеленый,
[01:06:37.040 --> 01:06:52.400]  который построил этот блок. Наступает раунд K плюс 3. Что делают честные участники? Вот честные
[01:06:52.400 --> 01:06:57.800]  участники видят вот такой блокчейн. Они не могут продолжить его лист, потому что у них нет
[01:06:57.800 --> 01:07:04.240]  сертификата. Лидер раунда K плюс 3 какой-то, он не может продолжить эту ветку, поэтому он
[01:07:04.240 --> 01:07:18.800]  форкается. Он хочет форкуется от блока K. Мы в раунде K плюс 3 хотим переиспользовать вот этот
[01:07:18.880 --> 01:07:29.280]  сертификат и сослаться на вот этот блок. Отправляем его всем и у лидера раунда K плюс 4 голоса
[01:07:29.280 --> 01:07:36.560]  скапливаются. Вот для того, чтобы получился кормный сертификат, нужно, чтобы мы собрали на лидере K
[01:07:36.560 --> 01:07:45.680]  плюс 4 два F плюс 1 голос за вот этот блок. У нас F византийских, они не будут голосовать за этот
[01:07:45.680 --> 01:07:51.800]  блок. Поэтому все остальные должны проголосовать. Вот почти все проголосуют, кроме Зеленого,
[01:07:51.800 --> 01:07:59.600]  потому что если у нас локт раунд это старший parent, то у всех старший parent это K и от него
[01:07:59.600 --> 01:08:06.560]  можно форкаться. А у Зеленого старший parent это K плюс 1. И он говорит, я не буду голосовать этот
[01:08:06.560 --> 01:08:15.440]  блок, потому что что-то глубоко слишком. То есть у нас где-то застрял такой невидимый блок,
[01:08:15.440 --> 01:08:23.080]  который не продолжился и не опубликован как следует. И он мешает форкаться. На каких-то
[01:08:23.080 --> 01:08:31.080]  узлах есть такая скрытая веточка, скрытый листик, который никем не наблюдается. И вот эта магическая
[01:08:31.080 --> 01:08:46.240]  константа 3, она нужна для того, чтобы ровно форкаться на два шага вверх. Да, может и отправляют,
[01:08:46.240 --> 01:08:53.160]  но просто остальные уже проголосовали в раунде K плюс 3 и кого это волнует? Мы же голосуем монотонно
[01:08:53.160 --> 01:09:02.000]  по раундам. А зачем монотонно? Это сложный вопрос на зачете. То есть он не сможет уже сертифицировать
[01:09:02.000 --> 01:09:08.880]  этот блок, потому что уже многие проголосовали, но почти все проголосовали за K плюс 3. То есть он
[01:09:08.880 --> 01:09:15.320]  единственный, кто будет за него голосовать вообще-то. То есть вот это 3 нужно, чтобы эту скрытую ветку
[01:09:15.320 --> 01:09:20.840]  невидимую обойти и форкнуться относительно нее на два шага вверх. А больше не нужно, но и больше мы не
[01:09:20.840 --> 01:09:32.800]  можем. Вот я не знаю, довольно затеяльево устроен мир, что ровно так нужно делать. Вот ровно 3. Ну как
[01:09:32.800 --> 01:09:37.400]  бы 3 — это константа такая важная для византийских отказов, поэтому не удивительно, но все равно
[01:09:37.400 --> 01:09:49.520]  удивительно, что только так и работает. Ну что, вот такой протокол. Вращаем лидера на каждом,
[01:09:49.520 --> 01:09:56.880]  такой максимально простой симметричный протокол с одним типом сообщений, с одним типом коронного
[01:09:56.880 --> 01:10:04.640]  сертификата с блокчейном. С одной стороны, это PBFT, в котором сделали пайплайнинг через
[01:10:04.640 --> 01:10:11.240]  коронные сертификаты и в котором сделали ротацию лидера на каждом раунде. Ну или это биткоин,
[01:10:11.240 --> 01:10:18.080]  в котором заменили хэшпоинтеры, в котором вместо нонсов и майнинга сделали голосование обычное и
[01:10:18.080 --> 01:10:23.240]  коронные сертификаты, потому что зафиксировали число узлов. Но с какой стороны не смотри,
[01:10:23.240 --> 01:10:28.920]  вот получается что-то. То есть можно с разных сторон смотреть, но вот исход примерно один,
[01:10:28.920 --> 01:10:38.880]  и результат этот получен аж в 2019 году. Не знаю, почему так получилось, но кажется,
[01:10:38.880 --> 01:10:45.120]  что без понимания PBFT и биткоина выдумывать с нуля это было сложнее. Хотя, может быть и нет.
[01:10:45.120 --> 01:10:50.240]  Но по крайней мере видно, как можно было это придумать, глядя на PBFT и на биткоин вместе.
[01:10:50.240 --> 01:11:06.720]  Ну а клиент здесь довольно перпендикулярно. Это все конструкции, потому что мы здесь не про
[01:11:06.720 --> 01:11:13.800]  блокчейн, не про компьютер, говорим о транзакции, все это криптография, мы говорим просто про то,
[01:11:13.880 --> 01:11:28.320]  транзакции упорядочивать. Ну это то же самое, что и в биткоине, та же самая идея. Мы выбираем
[01:11:28.320 --> 01:11:32.800]  каждый раз какого-то случайного лидера, здесь просто перебираем их по кругу, поэтому мы
[01:11:32.800 --> 01:11:37.400]  периодически проходим через честных. Если у нас отказов византийских не больше чем F,
[01:11:37.400 --> 01:11:44.240]  то мы вот две трети раундов проводим в честных узлах, а они добавляют транзакции в блокчейн.
[01:11:44.240 --> 01:11:51.320]  Так что тут вся интуиция наследуется, тут ничего принципиально нового
[01:11:51.320 --> 01:11:59.920]  как раз и нет, здесь просто комбинация известных идей. Ну что ж, на этом наш курс заканчивается,
[01:12:00.120 --> 01:12:07.560]  мы дожили до конца, спасибо вам большое, что были с нами, и мы через 10 минут поговорим про то,
[01:12:07.560 --> 01:12:12.840]  что вообще было в течение семестра, я попытаюсь какую-то интуицию вместе собрать, но вы тоже
[01:12:12.840 --> 01:12:20.240]  можете вспомнить что-нибудь, что вам запомнилось, и завтра мы вот в 11 утра проведем зачет.
