[00:00.000 --> 00:10.680]  Кажется, на сегодня седьмая встреча, поправьтесь, или
[00:10.680 --> 00:13.680]  не так.
[00:13.680 --> 00:19.040]  Мы продолжаем говорить про теорию чисел, в моем
[00:19.040 --> 00:20.040]  понимании.
[00:20.040 --> 00:23.000]  Сначала я выпишу несколько формул, которые нам сегодня
[00:23.000 --> 00:24.000]  понадобятся.
[00:24.000 --> 00:28.760]  Терема первая.
[00:28.760 --> 00:31.560]  Пусть классическое обозначение.
[00:31.560 --> 00:49.400]  Pioten – это количество простых чисел среди первых анатуральных.
[00:49.400 --> 00:51.560]  Когда нам известен порядок роста этого числа.
[00:51.560 --> 01:00.200]  Это n делить на log n плюс, ну вот это вот второе нам
[01:00.200 --> 01:03.440]  будет не нужно в статочном члене, но я напишу для общего
[01:03.440 --> 01:06.280]  сведения, так сказать, n на log квадрат.
[01:06.280 --> 01:16.560]  То есть количество простых чисел на отрезке от 1 до n
[01:16.560 --> 01:19.120]  ведет себя, по сути, как n делить на log, натуральный
[01:19.120 --> 01:22.840]  логарифм n, плюс еще какая-то поправка, которая в логарифм
[01:22.840 --> 01:24.680]  раз меньше, чем вот это.
[01:24.680 --> 01:27.760]  Ну наверняка у вас это было, по крайней мере, упомышечную
[01:27.760 --> 01:31.000]  часть на каком-нибудь дискране или у КТЧ, что там какой-нибудь
[01:31.000 --> 01:33.300]  тетто можно написать вот здесь вот вместо точного
[01:33.300 --> 01:34.300]  равенства.
[01:34.300 --> 01:40.520]  Но оказывается, даже верно такое соотношение.
[01:40.520 --> 01:41.520]  Следующий факт.
[01:41.520 --> 01:53.560]  Если мы рассматриваем все простые, опять-таки, не
[01:53.560 --> 02:00.440]  больше, чем n, и сложим их обратно, то получим повторный
[02:00.440 --> 02:08.800]  логарифм n, плюс некоторая константа, плюс, о большое,
[02:08.800 --> 02:26.560]  то есть 1,9 логарифма n, где m это примерно 261 тысячное.
[02:26.560 --> 02:29.680]  Вот такая информация, что если мы сложим обратные
[02:29.680 --> 02:32.960]  простые на отрезке от 1 до n, обратные к простым на
[02:32.960 --> 02:35.560]  отрезке от 1 до n, то у нас будет повторный логарифм
[02:36.320 --> 02:42.280]  плюс, в пределе можно считать, что вот это повторный логарифм
[02:42.280 --> 02:45.160]  плюс константа, плюс вот эта вот функция, которая
[02:45.160 --> 02:47.240]  можно было бы написать здесь о малость единицы вместо
[02:47.240 --> 02:49.560]  о большое от одной логарифмовой, можно написать просто о
[02:49.560 --> 02:53.360]  малость единицы, если не вдаваться в детали.
[02:53.360 --> 02:55.200]  Но что значит вообще эта запись?
[02:55.200 --> 02:59.960]  Это значит, что существует такая функция f, которая
[02:59.960 --> 03:03.080]  равна о большое от одной логарифмовой, то есть модуль
[03:03.080 --> 03:07.800]  f не больше, чем, скажем, c делит на логарифм n, такая
[03:07.800 --> 03:10.680]  функция f, что вот это вот выполняется равенство.
[03:10.680 --> 03:12.120]  Сумма обратных простых – это повторный логарифм
[03:12.120 --> 03:14.600]  плюс константа, плюс функция f от n.
[03:14.600 --> 03:15.600]  Понятно?
[03:15.600 --> 03:20.960]  Ну и третий факт, тоже я его спишу с бумажки, потому
[03:20.960 --> 03:23.280]  что всякие константы есть, вот эти вот достаточно
[03:23.280 --> 03:25.000]  члены, я их не запоминал.
[03:25.000 --> 03:31.520]  Если мы просто посмотрим на обратный ко всем натуральным
[03:31.520 --> 03:36.040]  гаммам от 1 до n, не обязательно простой, а просто все натуральные
[03:36.040 --> 03:40.160]  от 1 до n, тогда это будет просто логарифм, не повторный
[03:40.160 --> 03:43.400]  обычный логарифм, плюс опять какая-то константа, в этот
[03:43.400 --> 03:49.920]  раз гамма, плюс от одной n, где гамма – это примерно
[03:49.920 --> 03:50.920]  0,577.
[03:50.920 --> 03:56.960]  Это константа Эйлера или… Да-да-да-да, Эйлера еще
[03:57.720 --> 03:58.720]  я не помню.
[03:58.720 --> 04:01.720]  Вот этот ряд называется гармоническим.
[04:01.720 --> 04:11.720]  Сумма просто обратных к натуральным – одна первая,
[04:11.720 --> 04:13.240]  одна вторая, одна третья и так далее, и все складываем
[04:13.240 --> 04:14.240]  вплоть до одной n.
[04:14.240 --> 04:17.240]  Получается натуральный логарифм плюс константа,
[04:17.240 --> 04:19.240]  плюс от одной n.
[04:19.240 --> 04:21.240]  Вот такие интересные факты.
[04:21.240 --> 04:26.040]  Это все как-то доказывается, там есть всякие способы
[04:26.040 --> 04:28.640]  это делать, но это скорее к курсу по непосредственной
[04:28.640 --> 04:32.120]  теории чисел, там один из способов – это считать
[04:32.120 --> 04:34.760]  какие-то интегралы, их оценивать аккуратно и так далее,
[04:34.760 --> 04:38.520]  применять какие-то интегралины теремо-средним, это не то,
[04:38.520 --> 04:39.960]  чем мы будем заниматься, поэтому я их просто привожу
[04:39.960 --> 04:40.960]  без доказательств.
[04:40.960 --> 04:47.880]  Так, мы будем этим пользоваться, например, в нашем первом
[04:47.880 --> 04:49.480]  сегодняшнем алгоритме, в Риштере Тосфена.
[04:49.480 --> 04:57.720]  Задача очень простая.
[04:57.720 --> 05:06.080]  Найдите все простые от нода n.
[05:06.080 --> 05:12.080]  Найдите все простые среди чисел 1, 2 и так далее n.
[05:12.080 --> 05:16.840]  Первое, что здесь нужно сказать, это что у нас есть
[05:16.840 --> 05:20.520]  довольно простой алгоритм, который проверяет простоту
[05:20.520 --> 05:21.520]  данного числа.
[05:21.520 --> 05:23.840]  Если вы даете код числа x, можно его проверить на
[05:23.840 --> 05:29.000]  простоту за от корня из x.
[05:29.000 --> 05:36.520]  Проверка x на простоту за от корня из x.
[05:36.520 --> 05:39.200]  Это простой алгоритм, я даже не буду его подробно
[05:39.200 --> 05:40.200]  писать.
[05:40.200 --> 05:43.160]  Как проверить, что x простой за от корня из x?
[05:43.160 --> 05:44.160]  Тривиальное утверждение.
[05:44.320 --> 05:48.480]  Если x не простое, то есть составное, то у него есть
[05:48.480 --> 05:50.720]  хотя бы один натуральный делитель не больше чем корень
[05:50.720 --> 05:52.080]  из x.
[05:52.080 --> 05:54.380]  Потому что если таких нет, значит все его делители
[05:54.380 --> 06:12.520]  хотя бы корень из x.
[06:12.520 --> 06:17.520]  Делитель – это такое d, что существует еще натуральное e, такое, что их произведение – это x.
[06:17.520 --> 06:20.520]  Ну, если оба больше, чем корень из x, то такой равенец невозможно.
[06:20.520 --> 06:27.520]  Значит, если нет ни одного делителя не больше, чем корень, то нет вообще ни одного простого делителя, кроме самого x.
[06:27.520 --> 06:30.520]  Значит, можно просто перебрать все натуральные числа от одного до корня,
[06:30.520 --> 06:35.520]  посмотреть, что ни одно из них не делит x, и если так, то x – простое. Это понятно?
[06:35.520 --> 06:39.520]  Ну, значит, это мы так в сторонке заметили.
[06:39.520 --> 06:46.520]  И как бы, в принципе, можно было бы это сделать здесь, для каждого числа запустить этот алгоритм за корень, но это было бы слишком долго.
[06:46.520 --> 06:51.520]  Мы сделаем лучше. Значит, мы сделаем следующий алгоритм.
[06:51.520 --> 06:55.520]  Он работает следующим образом. Сначала считаем, что все числа простые.
[06:55.520 --> 07:01.520]  Сначала считаем, что все числа простые.
[07:01.520 --> 07:05.520]  Ну, кроме единицы давайте сразу напишем.
[07:05.520 --> 07:10.520]  Простые.
[07:10.520 --> 07:13.520]  Дальше мы будем перебирать числа в порядке возрастания.
[07:13.520 --> 07:16.520]  И если мы нашли какое-то очередное простое, P, например, тройку.
[07:16.520 --> 07:23.520]  Если мы знаем, что P – это простое число, тогда мы точно можем сказать, что скажем P умножить на 2, P умножить на 3, P умножить на 4 и так далее, и так далее.
[07:23.520 --> 07:30.520]  Все они непростые, потому что у них есть в разложении какой-то нейтривиальный делитель P и вот то, что осталось.
[07:30.520 --> 07:45.520]  Так и запишем. Далее, если P – простое, то 2P, 3P, 4P и так далее непростые.
[07:45.520 --> 07:48.520]  Ну, собственно, наш алгоритм будет так работать.
[07:48.520 --> 07:54.520]  Изначально считают, что все числа простые. То есть для каждого числа хранит там булиский флаг true, что мы пока что считаем, что оно простое.
[07:54.520 --> 07:56.520]  Потом идет в порядке возрастания по всем числам.
[07:56.520 --> 08:01.520]  Если нашел число, про которое мы пока что не знаем, что оно составное, то есть которое мы пока что считаем простым,
[08:01.520 --> 08:06.520]  тогда объявляем его настоящим простым, а все вот эти вот кратные ему объявляем составными.
[08:06.520 --> 08:09.520]  Значит, код будет такой.
[08:09.520 --> 08:16.520]  Давайте я напишу вот так. Prime от 2 до n состоит из всех трушек.
[08:16.520 --> 08:21.520]  Изначально мы считаем, что они все простые.
[08:21.520 --> 08:29.520]  Затем пробегаемся в эту массиву.
[08:29.520 --> 08:40.520]  Если оно непростое, то мы его просто пропускаем.
[08:40.520 --> 08:45.520]  А если оно простое, то все кратные объявляем непростыми.
[08:45.520 --> 08:54.520]  Здесь как можно сделать? Здесь можно написать g от 2 до целой части n поделить на p.
[08:54.520 --> 09:04.520]  И все такие числа, g умножить на p, объявляем непростыми.
[09:04.520 --> 09:06.520]  Вот весь код.
[09:06.520 --> 09:08.520]  Ну, собственно, делаем ровно то, что здесь написано.
[09:08.520 --> 09:12.520]  Здесь единственно я написал, что какие именно числа мы объявляем непростыми.
[09:12.520 --> 09:16.520]  Те, которые представляются в виде g умножить на p и при этом входят в наш интервал.
[09:16.520 --> 09:19.520]  Значит, g должно не превосходить целой части n поделить на p.
[09:19.520 --> 09:21.520]  Понятно?
[09:21.520 --> 09:23.520]  Корректно здесь как бы плюс-минус очевидно.
[09:23.520 --> 09:28.520]  Любое простое число, которое по-настоящему простое, мы объявим в конце простым.
[09:28.520 --> 09:30.520]  Потому что мы его изначально считаем простым.
[09:30.520 --> 09:33.520]  И никогда точно не положим, что оно непростое.
[09:33.520 --> 09:35.520]  Потому что простое не может быть представлено в таком виде.
[09:35.520 --> 09:37.520]  Не может быть представлено в виде произведения.
[09:37.520 --> 09:39.520]  Поэтому все простые мы точно найдем.
[09:39.520 --> 09:41.520]  А любое составное...
[09:41.520 --> 09:43.520]  Поэтому мы точно поймем, что оно составное.
[09:43.520 --> 09:48.520]  Потому что если оно составное, значит оно распадает в произведении чего-нибудь простого и оставшегося.
[09:48.520 --> 09:51.520]  Значит мы когда-то раньше смогли найти это простое и вот этот остаточек.
[09:51.520 --> 09:53.520]  И тогда это число положили непростым.
[09:56.520 --> 09:59.520]  Так вот, простейшая реализация Рештарта-Сфена.
[09:59.520 --> 10:02.520]  Давайте теорему я, наверное, оставлю пока что.
[10:02.520 --> 10:06.520]  Ну и чтобы оценить асимптотику, нам нужна будет вторая теорема.
[10:09.520 --> 10:11.520]  Асимптотика.
[10:11.520 --> 10:13.520]  Здесь всякие линейные операции.
[10:13.520 --> 10:15.520]  Вот это от n занимает создание массива.
[10:15.520 --> 10:17.520]  Цикл за от n работает.
[10:17.520 --> 10:19.520]  И вот здесь, вот за сколько это работает?
[10:19.520 --> 10:21.520]  Ну это работает за n делить на p примерно.
[10:21.520 --> 10:24.520]  Асимптотика, это сумма по всем простым, не больше чем m.
[10:27.520 --> 10:29.520]  n делить на p.
[10:30.520 --> 10:32.520]  n делить на p.
[10:33.520 --> 10:36.520]  Потому что самая сложная часть, это вот этот вложенный цикл по g.
[10:36.520 --> 10:39.520]  Но он работает вот тут написано за n делить на p.
[10:39.520 --> 10:41.520]  Поэтому суммарная асимптотика ровно вот такая.
[10:41.520 --> 10:43.520]  И слагаемые берутся только по простым p.
[10:43.520 --> 10:45.520]  Здесь рассматривают только простые p.
[10:45.520 --> 10:47.520]  Ну мы знаем асимптотику такого ряда.
[10:47.520 --> 10:49.520]  Вот здесь написано, что это повторный алгорифм.
[10:49.520 --> 10:51.520]  Только здесь еще в числителе n-ка написано.
[10:51.520 --> 10:53.520]  Ну значит это, давайте я напишу так.
[10:53.520 --> 10:56.520]  Просто theta вот n делить на log log n.
[10:59.520 --> 11:02.520]  Здесь я даже игнорирую все вот эти вот остаточные члены.
[11:02.520 --> 11:04.520]  Смотрю только на первый, на повторный алгорифм.
[11:04.520 --> 11:06.520]  И то даже в терминах theta его напишу.
[11:06.520 --> 11:08.520]  Мне даже не важна константа.
[11:08.520 --> 11:10.520]  Потому что, ну да, когда мы оцениваем сложность,
[11:10.520 --> 11:12.520]  мы не следим за константой мультипликативной.
[11:13.520 --> 11:14.520]  Но получается такая асимптотика.
[11:14.520 --> 11:15.520]  Так, я где-то обманул, да?
[11:15.520 --> 11:16.520]  Наоборот, надо умножить.
[11:16.520 --> 11:18.520]  Не туда посмотрел, извините.
[11:18.520 --> 11:20.520]  Да, здесь log log обычный, поэтому там умножение.
[11:20.520 --> 11:22.520]  Извините.
[11:22.520 --> 11:24.520]  Опечатка.
[11:25.520 --> 11:27.520]  Умножить, конечно.
[11:35.520 --> 11:37.520]  Вот.
[11:37.520 --> 11:39.520]  Кстати, я не знаю, как это называется.
[11:39.520 --> 11:41.520]  Я его называю стильный решетор этого сфена.
[11:41.520 --> 11:42.520]  Ну ладно.
[11:42.520 --> 11:44.520]  Значит, вот такое решетор работает за n log log.
[11:44.520 --> 11:46.520]  В принципе, это уже довольно круто, да?
[11:46.520 --> 11:48.520]  Потому что, если у вас там, не знаю,
[11:48.520 --> 11:50.520]  ну для какого n вообще есть смысл
[11:50.520 --> 11:51.520]  писать такое решетор?
[11:51.520 --> 11:53.520]  В нашей парадигме вот этой страны,
[11:53.520 --> 11:55.520]  где программа должна работать 1 секунду примерно,
[11:55.520 --> 11:57.520]  вот там, когда мы на кудфоркс засылаем,
[11:57.520 --> 12:00.520]  нам нужно завести массив размера n.
[12:00.520 --> 12:03.520]  То есть, в принципе, там n должно быть порядка 10 в 7 максимум.
[12:03.520 --> 12:04.520]  Ну, может, чуть-чуть больше.
[12:04.520 --> 12:06.520]  И тогда вот этот множитель log log,
[12:06.520 --> 12:08.520]  он, в принципе, супер микроскопический.
[12:08.520 --> 12:10.520]  Не знаю, что это.
[12:10.520 --> 12:12.520]  Там 5 где-то или что-то такое.
[12:12.520 --> 12:13.520]  Вот.
[12:13.520 --> 12:14.520]  Поэтому, в принципе, можно сказать,
[12:14.520 --> 12:15.520]  что это то, что нужно.
[12:15.520 --> 12:16.520]  То есть, это близко к тому,
[12:16.520 --> 12:18.520]  что у нас была функция керман обратная.
[12:18.520 --> 12:19.520]  Помните, в прошлом семестре,
[12:19.520 --> 12:20.520]  там вот, когда мы с nm писали,
[12:20.520 --> 12:22.520]  что-то, что-то множит обратную функцию кермана.
[12:22.520 --> 12:23.520]  И мы говорим, что она настолько маленькая,
[12:23.520 --> 12:25.520]  что, в принципе, и так пофиг,
[12:25.520 --> 12:27.520]  что это почти вот n.
[12:27.520 --> 12:29.520]  Ну, все-таки не совсем, конечно, так.
[12:29.520 --> 12:32.520]  То есть, это может быть что-то плюс-минус существенное.
[12:32.520 --> 12:35.520]  Поэтому мы сейчас напишем, что за линейное время, за вот n.
[12:40.520 --> 12:41.520]  Что?
[12:44.520 --> 12:45.520]  Вот здесь вот?
[12:45.520 --> 12:46.520]  Почему?
[12:46.520 --> 12:47.520]  Да вроде нет.
[12:47.520 --> 12:49.520]  Ну, типа понятно же, что бывают простые больше,
[12:49.520 --> 12:50.520]  чем корень из n.
[12:50.520 --> 12:52.520]  А, да, я понял вас.
[12:52.520 --> 12:54.520]  Но, смотрите, даже если так,
[12:54.520 --> 12:56.520]  то здесь будет сумма тогда до корня из n.
[12:56.520 --> 12:57.520]  Да, и тогда здесь будет логарифм
[12:57.520 --> 12:58.520]  логарифма корня из n.
[12:58.520 --> 13:00.520]  И это все равно мелочь.
[13:00.520 --> 13:02.520]  А в числителе все равно n останется, кажется.
[13:05.520 --> 13:06.520]  Да, значит, дальше.
[13:06.520 --> 13:07.520]  Что за от и?
[13:09.520 --> 13:10.520]  Ну, я не знаю.
[13:10.520 --> 13:11.520]  Я не знаю.
[13:11.520 --> 13:12.520]  Я не знаю.
[13:12.520 --> 13:13.520]  Я не знаю.
[13:13.520 --> 13:16.520]  Здесь я, наверное, сотру эти уже штуки.
[13:30.520 --> 13:31.520]  Так.
[13:31.520 --> 13:32.520]  Это решито хорошо не только тем,
[13:32.520 --> 13:34.520]  что оно работает быстрее,
[13:34.520 --> 13:36.520]  но и тем, что позволяет посчитать больше информации.
[13:36.520 --> 13:39.520]  Значит, а именно оно для каждого натурального числа
[13:39.520 --> 13:41.520]  найдет его минимальное количество,
[13:41.520 --> 13:44.520]  каждого натурального числа найдет его минимальный простой делитель.
[13:49.520 --> 13:50.520]  Находим
[13:53.520 --> 13:55.520]  минимальный простой делитель.
[14:01.520 --> 14:04.520]  Давайте как-нибудь назовем эту функцию
[14:04.520 --> 14:08.520]  d-min от x
[14:08.520 --> 14:10.520]  для всех x от 1 до n.
[14:11.520 --> 14:14.520]  То есть мы не просто поймем
[14:14.520 --> 14:17.520]  простоту каждого числа в отрезке от 1 до n,
[14:17.520 --> 14:19.520]  но еще и найдем минимальное простое делительwow
[14:19.520 --> 14:21.020]  для всех этих чисел.
[14:21.020 --> 14:21.520]  Вот.
[14:21.520 --> 14:23.520]  Но если мы найдем эти минимальные простые делители,
[14:23.520 --> 14:25.520]  то как понять число простое или нет?
[14:25.520 --> 14:27.520]  Нужно просто сравнить его
[14:27.520 --> 14:29.520]  со своим минимальным простым делителем, да.
[14:29.520 --> 14:30.520]  Если число простое,
[14:30.520 --> 14:33.020]  то единственное простое, на котором оно делится, оно само.
[14:33.020 --> 14:35.520]  Значит, минимальный простой делитель, это оно само.
[14:35.520 --> 14:37.520]  Ну и наоборот, если минимальное...
[14:37.520 --> 14:39.520]  минимальный делитель равен числу,
[14:39.520 --> 14:40.520]  значит, нет никаких 다른 меньших.
[14:40.520 --> 14:45.280]  значит оно простое. То есть равенство d-min от x равно x это критерий того, что x
[14:45.280 --> 14:50.680]  простое. Ну кроме случая там x равно 1, который мы игнорируем.
[14:50.680 --> 14:58.440]  Так, ну давайте напишем такой код. Во-первых, мы заведем вектор простых.
[15:00.920 --> 15:06.400]  Вектор int' куда будем складывать найденные на текущий момент простые.
[15:06.400 --> 15:14.960]  Дальше заведем массив мин d. Так, ну здесь я уже пишу не код, а псевдокод.
[15:14.960 --> 15:19.480]  Мин d это какие минимальные делители я нашел в данный момент у каждого числа.
[15:19.480 --> 15:26.040]  И я в него положу числа 2, 3, 4 и так далее n. То есть изначально так же, как было
[15:26.040 --> 15:29.880]  там, я считаю, что каждое число простое, то есть его минимальные простые делители
[15:29.880 --> 15:35.440]  равен ему самому. Окей? Мин d от y равно i, мин d от x равно x. Это пока что такое
[15:35.440 --> 15:39.000]  предположение мы делаем. То есть пока мы не нашли никаких других простых, мы
[15:39.000 --> 15:42.800]  считаем, что число равно своему минимальному делителю. Минимальному
[15:42.800 --> 15:54.680]  простому делителю. Дальше мы перебираем числа от 2 до n. Во-первых, если оно
[15:54.680 --> 16:00.640]  простое, то есть если минимальный текущий найденный его простой делитель
[16:00.640 --> 16:06.400]  равен ему самому, если мин d от k равно k, тогда мы его добавим в список простых.
[16:06.400 --> 16:15.520]  Праймс пушбек к. Мы нашли число, поняли, что оно простое, ну в предположении, что мы
[16:15.520 --> 16:19.560]  мин d корректно посчитали, поняли, что оно простое, запихали его в вектор всех
[16:19.560 --> 16:31.440]  простых. Дальше следующее идет. Давайте начнем так. Мы вводим новую переменную
[16:31.440 --> 16:36.960]  p, которая пробегает по списку всех простых и при этом должны выполняться два
[16:36.960 --> 16:45.600]  условия. Во-первых, p умножить на k не больше m, потому что нам не нужно числа
[16:45.600 --> 16:52.800]  больше, чем n. Во-вторых, что тоже важно, p должно быть не больше, чем минимальный простой делитель
[16:52.800 --> 17:04.240]  найденной ука. Мы чуть позже поймем, что это все значит. Мы перебираем все простые, пытаемся
[17:04.240 --> 17:09.560]  найти мин d для такого числа, которое должно быть не больше, чем n и при этом p это не больше,
[17:09.560 --> 17:13.920]  чем минимальный простой делитель ука. Тогда скажите, пожалуйста, чему должен быть равен мин d
[17:13.920 --> 17:21.120]  у числа p умножить на k? Если я знаю, что p простое, k какое-то, при этом минимальный делитель
[17:21.120 --> 17:28.880]  вот здесь, вот хотя бы p, тогда чему равно мин d от pk? Ну, конечно, да, потому что как это число
[17:28.880 --> 17:33.000]  раскладывается на множители. Там есть простое p и еще какие-то простые, каждый из которых больше
[17:33.000 --> 17:38.400]  он очень p. Значит, минимальный делитель от точности p. Написали такую строчку. Все иное,
[17:38.400 --> 17:45.520]  наш фор закончился и вот этот большой фор тоже закончился. Алгоритм занимает совсем чуть-чуть
[17:45.520 --> 17:51.240]  строчек. Здесь самый сложный цикл, проверить два условия, что pk не больше, чем n и p не больше,
[17:51.240 --> 18:14.160]  чем мин d от k. Ну, надо доказать корректность и понять время работы. Я утверждаю, что в конце
[18:14.160 --> 18:19.560]  выполнения всего этого алгоритма мин d от x будет равно тому, чему нужно, минимальному простому
[18:19.560 --> 18:26.800]  делителю числа x. Значит, для простых это очевидно верно. Понятно, что если x простое, то мы вот если в
[18:26.800 --> 18:31.440]  конце положили мин d от x равно x, то нигде в этом цикле мин d от x не поменяется, потому что раз
[18:31.440 --> 18:36.280]  x простое, то оно точно не представимо в таком виде, а значит оно не изменится. Первая мысль это,
[18:36.280 --> 18:55.160]  что мин d от x для простых x найдется верно. Значит, в частности, в векторе primes будут точно все
[18:55.160 --> 19:05.920]  простые. Ну, возможно, какие-то еще числа, но все простые там точно будут. Точно лежат все
[19:05.920 --> 19:18.480]  простые. Хорошо, тогда давайте дальше посмотрим на какой-нибудь x непростой. Пусть x непростое.
[19:18.480 --> 19:36.360]  И q это его минимальный простой делитель. Уменьшим x. Мы поняли, что для простых все хорошо,
[19:36.360 --> 19:40.200]  теперь надо понять, что для непростых тоже все хорошо. Ну вот пусть x какой-то непростой с
[19:40.200 --> 19:45.680]  определенным минимальным простым делителем q. Тогда как мы его обработаем? Значит, я утверждаю,
[19:45.680 --> 19:56.040]  что когда k равно x девять на q и p равно q, мы выполним нужное присваивание, и вот это будет
[19:56.040 --> 20:08.120]  равно x, а вот здесь будет написано то самое q. Мы скажем, что мин d от x равно q.
[20:08.120 --> 20:20.360]  Так, ну тоже вроде все просто. Я понял, вот x какой-то непростой. Вычленил из него
[20:20.360 --> 20:25.480]  минимальный простой делитель и рассмотрел остаток x залить на q. Понятно, что когда-то
[20:25.480 --> 20:32.200]  k будет равно этому числу x залить на q. Простой оно не простое, неважно. Возможно, он добавится в
[20:32.200 --> 20:37.400]  вектор. Дальше мы начинаем перебирать все простые в этом списке. Там точно будет вот это вот наше q,
[20:37.400 --> 20:41.440]  потому что мы понимаем, что все простые точно джат в праймсе, значит, наша заветная q там точно
[20:41.440 --> 20:46.760]  будет. В какой-то момент будет p равно q. Вот это неравенство будет корректно, потому что q множество
[20:46.760 --> 20:51.800]  на k будет равно x и x все еще в нашем интервале, поэтому это неравенство будет всегда верно. Здесь
[20:51.800 --> 20:57.360]  тоже все верно, потому что здесь написано q, а здесь написано мин d от k, но понятно, что мин d от k
[20:57.360 --> 21:06.440]  больше 0, чем q. Значит, очевидно, минимальный делитель числа k больше равен q. Ну потому что,
[21:06.440 --> 21:10.680]  если меньше, значит, в x есть еще какой-то меньший простой делитель, значит, мы мин d от x неправильно
[21:10.680 --> 21:16.560]  нашли. Ну и значит, это неравенство тоже у нас будет всегда выполняться. И когда мы перебираем
[21:16.560 --> 21:21.480]  простые, там 2, 3, 5, 7 и так далее, мы в частности дойдем до нашего заветного q. Сделаем такое
[21:21.480 --> 21:28.080]  присвоение, мин d от q множество на k, то есть мин d от x равно p, то есть q. То есть вот эта строчка
[21:28.520 --> 21:36.760]  выполнится, вы сделом то, что нужно. Более того, мы не просто правильно найдем минимальный простой делитель
[21:36.760 --> 21:44.220]  для x, но и сделаем такое присвоение, такое присвоение мин d от x равно чему-то ровно один раз. Ну потому
[21:44.220 --> 21:48.560]  что, когда мы можем выполнить присвоение мин d от x равно чему-то, когда p это его минимальный простой
[21:48.560 --> 21:54.520]  делитель? А вот здесь вот, если это x, то мы говорим, что минимальный простой делитель x это p. Причем мы
[21:54.520 --> 21:57.640]  мы знаем, что здесь простых меньше p нет. Значит, каждый
[21:57.640 --> 22:00.720]  миндей от x присваивается ровно один раз. Значит,
[22:00.720 --> 22:18.360]  синтезика от n. Я напишу так. Итак, миндей от x когда-то
[22:18.360 --> 22:35.840]  верно присвоится. Верно найдется. Более того, миндей
[22:35.840 --> 22:41.400]  от x обновится, то есть мы изменим его значение ровно
[22:41.400 --> 22:53.320]  один раз. То есть в первый же раз, когда мы потрогали
[22:53.320 --> 22:55.080]  значение миндей от x, мы туда положили правильное
[22:55.080 --> 22:57.880]  число и больше этого миндей от x мы никогда не трогаем.
[22:57.880 --> 23:02.440]  Ну, значит, синтезика как раз от n. Потому что если
[23:02.440 --> 23:04.440]  мы каждое конкретное миндей от x трогаем максимум один
[23:04.440 --> 23:08.080]  раз, и как раз у нас основное время работы возникает из-за
[23:08.080 --> 23:11.000]  этого второго вложенного цикла. И суммарно он делает
[23:11.000 --> 23:12.920]  операции ровно столько, сколько делает изменения
[23:12.920 --> 23:14.800]  в массиве миндей. Ну, мы поняли, что таких изменений
[23:14.800 --> 23:17.720]  ровно не больше mn. Значит, время работы феологритма
[23:17.720 --> 23:29.920]  вот так. Вопросы? Нет вопросов. Хорошо. Ну, такая штука
[23:29.920 --> 23:32.600]  нам позволяет найти, как я сказал, уже все минимальные
[23:32.600 --> 23:35.920]  простые делители для всех чисел. Значит, мы можем
[23:35.920 --> 23:39.080]  на самом деле отсюда извлекать еще полезную информацию
[23:39.080 --> 23:42.340]  про факторизацию. Мы можем с помощью этого решета находить
[23:42.340 --> 23:53.560]  разложение всех чисел на множители. Факторизация.
[23:53.560 --> 23:56.480]  Ну вот представьте, что мы написали это решето для
[23:56.480 --> 23:59.080]  всех чисел от 1 до n, нашли минимальный простой. Теперь
[23:59.080 --> 24:01.560]  как разложить данное число x на множители? Предполагаю,
[24:01.560 --> 24:04.360]  что x лежит в отрезке от 1 до n. Но мы знаем его минимальный
[24:04.360 --> 24:09.160]  простой делитель. Давайте на него поделим. Будет x делить
[24:09.160 --> 24:13.600]  mnd от x. Это опять какое-то число? Мы у него знаем опять
[24:13.600 --> 24:15.600]  очередной минимальный простой делитель. Давайте на
[24:15.600 --> 24:18.920]  него тоже поделим. Так, ну я сейчас умру, конечно, это
[24:18.920 --> 24:26.960]  писать, но один раз не пишу. Вам, конечно, не советую
[24:26.960 --> 24:31.240]  это писать, ну ладно. Ну смысл такой, что если мы знаем
[24:32.060 --> 24:34.600]  IBM минимальный простой делитель, кife иitting今日 на него поделим,
[24:34.600 --> 24:36.600]  то нам останется разложить вот это число на множители.
[24:36.600 --> 24:39.120]  Ну, мы раскладываем точно так же. Берем минимальный
[24:39.120 --> 24:42.000]  простой, описываем его и делим. Вот этого оставшегося
[24:42.000 --> 24:45.980]  числа опять находим, mammals и делим. Пока не дойдем до
[24:45.980 --> 24:48.460]  простого числа, простое число уже понятно, как раскладывается
[24:48.460 --> 24:51.160]  на множители. Это просто ere само. Вот весь вот алгоритм.
[24:51.160 --> 24:55.680]  Вопрос к вам, насколько работает такой вот спуск.
[24:55.680 --> 25:01.000]  Сколько раз нам может понадобится поделить на minima vad,
[25:01.000 --> 25:11.040]  логарифм, да. Это работает за вот логарифм. Потому что
[25:11.040 --> 25:13.480]  каждый шаг это деление хотя бы в два раза. Минимальная
[25:13.480 --> 25:15.720]  возможная простой это у нас двойка. Ну и таких делений
[25:15.720 --> 25:21.080]  может быть тогда максимум логарифм. Вот, если мы написали
[25:21.080 --> 25:24.120]  что-то, в принципе задача факторизации у нас решается
[25:24.120 --> 25:26.960]  за логарифм. Задача разложения на простые множители решается
[25:26.960 --> 25:29.200]  на логарифм. Хорошо.
[25:57.040 --> 25:59.840]  В общем же случае, когда мы говорим про разложение
[25:59.840 --> 26:02.840]  произвольных чисел, у нас, к сожалению, такой симпатике
[26:02.840 --> 26:06.480]  хорошей не будет. И плюс-минус лучшее, что известно про
[26:06.480 --> 26:10.040]  факторизацию числа x, это вот разложение за от корня
[26:10.040 --> 26:15.280]  из x. Ну вот то, как мы проверяли на простоту в самом начале,
[26:15.280 --> 26:17.400]  просто перебирая все делители от одного до корня, точно
[26:17.400 --> 26:19.960]  так же можно не просто проверить на простоту, но и разложить
[26:19.960 --> 26:22.680]  на множители. Потому что мы по сути находим все простые
[26:22.680 --> 26:25.960]  от одного до корня, потом мы можем просто, ну простым
[26:25.960 --> 26:28.120]  образом, определить степень вхождения каждого простого
[26:28.120 --> 26:30.520]  вот этого x, просто, ну, деля столько раз, пока делится.
[26:30.520 --> 26:32.880]  Потом останется какой-то остаток, который либо простой,
[26:32.880 --> 26:35.560]  либо единица. Ну, потому что если оно там больше корня,
[26:35.560 --> 26:37.280]  может быть максимум один простой делитель. Ну,
[26:37.280 --> 26:39.200]  тогда вот то, что осталось, это тоже там простое число,
[26:39.200 --> 26:45.440]  которое надо выписать. Вот. Ну, там есть, конечно, и получу,
[26:45.440 --> 26:48.120]  наверное, алгоритмы, да, но главное, что они работают
[26:48.120 --> 26:51.800]  не за полинома длины входа. Вот как у нас там когда-то
[26:51.800 --> 26:55.840]  было, x сколько занимает запись x? Значит, она занимает
[26:55.840 --> 26:57.680]  какое-то алгоритмическое количество бит. Чтобы нам
[26:57.680 --> 26:59.960]  подать компьютеру на вход это число, нам нужно там
[26:59.960 --> 27:03.840]  обычный алгоритм x бит потратить. Значит, в идеале, если мы
[27:03.840 --> 27:07.000]  хотим, чтобы у нас все работало за там, ну, какие-то многочлены
[27:07.000 --> 27:10.080]  от длины входа, у нас здесь должно быть что-то в стиле
[27:10.080 --> 27:12.600]  алгоритм там в степени 2, в степени 3, что-то такое.
[27:12.600 --> 27:15.400]  Короче, какая-то степень алгоритма должна быть
[27:15.400 --> 27:17.400]  во времени работы, чтобы это работало за полинома
[27:17.400 --> 27:20.640]  от размера входа. Но здесь получается корень из x. Корень
[27:20.640 --> 27:27.200]  из x это что такое? Это, видимо, что-то такое. Два, ну, короче,
[27:27.200 --> 27:30.360]  в общем, экспоненты от длины входа, но не полином. А вот
[27:30.360 --> 27:32.600]  здесь все было бы хорошо, да, вот здесь было бы как
[27:32.600 --> 27:36.720]  раз просто длина входа, там был x длины лог n, здесь работает
[27:36.720 --> 27:40.320]  за лог n, но, к сожалению, это еще с линейным предподсчетом.
[27:40.320 --> 27:44.800]  То есть нам нужно запустить до этого решето за отn. Предподсчет
[27:44.800 --> 27:49.560]  за отn. Ну, что еще, еще даже хуже, чем корень из x. То
[27:49.920 --> 27:52.080]  есть это работает, да, если у вас все числа небольшие,
[27:52.080 --> 27:54.480]  вы можете запустить решето, тогда вы потом быстро можете
[27:54.480 --> 27:56.560]  факторизовать. Если вы не можете запустить решето,
[27:56.560 --> 28:00.320]  если у вас x большие, то, ну, вот лучше это можно, можно
[28:00.320 --> 28:03.760]  за корень сделать, там, ну, либо что-то еще такое подобное,
[28:03.760 --> 28:06.280]  но оно все равно будет экспоненциально долгое, ну, или там, по крайней
[28:06.280 --> 28:07.280]  мере, не полиномиальное.
[28:07.280 --> 28:24.080]  Так, окей, окей, окей, окей. Да, про решетов мы вроде
[28:24.080 --> 28:26.680]  все обсудили. Теперь давайте еще такое маленькое, что
[28:26.680 --> 28:30.080]  мне нужно сказать, это обращение по модулю. Тоже, наверное,
[28:30.080 --> 28:38.240]  многие умеют. Обращение по модулю. Значит, такое
[28:38.240 --> 28:47.000]  утверждение, пусть a и m взаимнопростые целые числа, тогда существует
[28:47.000 --> 28:55.280]  такое целое x, что ax сравнимо с единицей по модуле m. Значит,
[28:55.280 --> 28:58.200]  если a и m взаимнопросты, тогда существует такое x, что ax равно
[28:58.200 --> 29:01.480]  единицы по модуле m. Этот x будем называть как раз обратным
[29:01.480 --> 29:15.600]  к a по модуле m. Обратное число к a по модуле m. Вот, ну, чтобы
[29:15.600 --> 29:18.000]  доказать, что оно существует, мы даже не будем пользоваться
[29:18.000 --> 29:22.040]  никаким там теря-мейлера или малотеря-фирма, мы просто
[29:22.040 --> 29:26.280]  скажем, что раз они взаимнопростые, a и m, то значит, существуют
[29:26.280 --> 29:32.920]  такие целые x и y, что ax плюс my равно единицы. В прошлый раз мы
[29:32.920 --> 29:34.840]  доказывали теорему о линейном представлении наибольшего
[29:34.840 --> 29:38.520]  общего делителя. Если a и m взаимнопросты, тогда можно взять их
[29:38.520 --> 29:41.160]  линейную комбинацию с целыми коэффициентами, чтобы получить
[29:41.160 --> 29:44.320]  единичку. Наибольшего общего делителя равен единице.
[29:44.320 --> 29:46.800]  Ну и более того, мы эти x и y умеем находить за алгорифм.
[29:46.800 --> 29:53.760]  За алгорифм от a и алгорифм от m, от наших двух чисел. Получается,
[29:53.760 --> 29:56.080]  нам расширенный алгоритм Ефклида, который был в прошлый раз,
[29:56.080 --> 30:05.480]  находит то самое x, которое мы искали. x можно найти расширенным
[30:05.480 --> 30:19.440]  алгоритмом Ефклида. Ну я так напишу совсем, не стараясь,
[30:19.440 --> 30:27.040]  лог a плюс лог m. Тут можно оставить любое из двух слагаемых,
[30:27.040 --> 30:46.240]  но давайте сумму это оценим, тоже будет верно. Вот такое
[30:46.240 --> 30:50.320]  важное понятие обращения по модулю. Теперь давайте
[30:50.320 --> 30:53.600]  немножко поговорим про криптографию, такую совсем
[30:53.600 --> 30:59.000]  простую, про криптографические протоколы. Все это будет
[30:59.000 --> 31:02.120]  сильно основываться на наших простых, которые мы в реште
[31:02.120 --> 31:05.240]  ищем, и на обращениях по модуле тоже будет нужно.
[31:05.240 --> 31:19.120]  Криптографические протоколы. Нет, это не про криптографию,
[31:19.120 --> 31:26.960]  это про сжатие. Смотрите, вообще ситуация модельная
[31:26.960 --> 31:32.480]  такая, у вас есть два агента, Алиса и Боб, они хотят как-то
[31:32.480 --> 31:35.240]  обмениваться информацией. И обычно канал, по которому
[31:35.240 --> 31:41.560]  они посылают информацию друг к другу, открытый. Мы
[31:41.560 --> 31:45.760]  считаем, что он без шума, то есть не вносит никакие
[31:45.760 --> 31:48.400]  погрешности в передаваемые сообщения. Сообщения передаются
[31:48.400 --> 31:52.680]  вот в том виде, в котором они отправляются. Ну например,
[31:52.680 --> 31:55.400]  я небольшой знаток, но мне кажется, что плюс-минус
[31:55.400 --> 31:58.800]  вот так вот можно совершать какие-то транзакции в блокчейне,
[31:58.800 --> 32:01.320]  типа биткоин и все такое, потому что там же есть какая-то
[32:01.360 --> 32:03.440]  открытая база, к которой все имеют доступ. И если там
[32:03.440 --> 32:07.240]  один хочет перевести денежки другому, то это известно
[32:07.240 --> 32:09.720]  всем, но только просто информация о том, кто кому переводит
[32:09.720 --> 32:11.800]  и какую сумму и все такое, оно как бы закодировано каким-то
[32:11.800 --> 32:14.600]  образом. То есть в этом смысле канал, по которому
[32:14.600 --> 32:16.640]  они общаются между собой, он открытый, все в него
[32:16.640 --> 32:22.280]  могут смотреть. Но, тем не менее, они как-то могут
[32:22.280 --> 32:24.520]  этой информацией обменяться. Возможно, сохраняя какие-то
[32:24.520 --> 32:28.000]  приватные данные. Как именно его зовут, как именно его
[32:28.000 --> 32:32.920]  зовут и так далее. Соответственно, есть еще какие-то
[32:32.920 --> 32:39.240]  подслушиватели. В русском ее зовут Евой. Давайте подпишем,
[32:39.240 --> 32:43.840]  что это Алиса, это Боб, это Ева. От слова подслушиватель,
[32:43.840 --> 32:50.760]  кажется, так пишется. Ну короче, вот есть какой-то
[32:50.760 --> 32:52.880]  подслушиватель, который видит этот открытый канал,
[32:52.880 --> 32:57.760]  и который, пытаясь взломать то, что они друг другу
[32:57.960 --> 33:00.920]  посылают, пытается понять, что они друг другу посылают,
[33:00.920 --> 33:03.560]  используя только открытый канал. И если вот эта информация
[33:03.560 --> 33:06.520]  здесь довольно хорошо зашифрована, и мы видим только вот этот
[33:06.520 --> 33:09.000]  вот шифр от информации, то мы, скорее всего, не сможем
[33:09.000 --> 33:11.560]  понять, что они между собой говорят. То есть они отправляют
[33:11.560 --> 33:14.640]  друг другу что-то, мы это видим, само сообщение, они как
[33:14.640 --> 33:17.720]  бы там друг другу кодируют. То есть Алиса закодировала
[33:17.720 --> 33:20.400]  сообщение, отправила, потом Боб его раскодировал. Они
[33:20.400 --> 33:23.120]  это все делают, но сторонний наблюдатель ничего не понимает,
[33:23.120 --> 33:25.160]  он видит какую-то крокозябру, которая никак не может
[33:25.160 --> 33:27.840]  понимать, о чем именно они говорят, то есть они, да.
[33:30.200 --> 33:34.800]  Вот, значит, тут есть много всяких моделей. Давайте вот
[33:34.800 --> 33:37.160]  первый криптографический протокол, это гомирование так
[33:37.160 --> 33:44.960]  называемое, работает следующим образом. Изначально Алиса
[33:44.960 --> 33:48.520]  и Боб очень встречаются, приходят в одну аудиторию в
[33:48.520 --> 33:51.000]  назначенное время, и друг другом просто договариваются
[33:51.000 --> 33:53.720]  о каком-то секретном ключе. Давайте считать, что А и
[33:53.720 --> 34:02.520]  Б, так Алиса и Боб, тайна, то есть, ну не в открытом
[34:02.520 --> 34:04.280]  доступе, а просто вдвоем встретились, их никто не
[34:04.280 --> 34:06.840]  подслушивает, и вот они тайно друг с дружкой договорились
[34:06.840 --> 34:11.480]  о секретном ключе. Договариваются о секретном ключе.
[34:16.800 --> 34:20.440]  Давайте ключ, о котором они договариваются, будет каким-то
[34:20.440 --> 34:25.480]  айксом, какой-то битовой строкой длины n. Просто вот
[34:25.480 --> 34:31.480]  строчка из 0 единиц длины n. Самое простое, что они могут
[34:31.480 --> 34:33.960]  сделать, это просто прийти в одну аудиторию, запустить
[34:33.960 --> 34:36.680]  какой-нибудь компьютер, который выдает случайную битовую
[34:36.680 --> 34:38.960]  строчку длины n, то есть написать программу, которая там выводит
[34:38.960 --> 34:44.240]  рандпроцент 2 n раз, то есть случайный бит от 0 до 0, ну 0 и 1 n раз,
[34:44.240 --> 34:46.800]  и просто говорят, что вот это вот наш общий ключ тайный.
[34:46.800 --> 34:49.040]  Затем они его записывают на бумажке, расходятся по
[34:49.040 --> 34:51.760]  домам, и в момент, когда им нужно обменяться какой-то
[34:51.760 --> 34:55.520]  информацией, скажем, Алиса хочет передать Бобу какое-то
[34:55.520 --> 35:09.640]  сообщение, y, а хочет передать y из 0 и 1 в n, Бобу. Тогда Алиса
[35:09.640 --> 35:22.520]  просто отправляет побитого xor xay, xor y, xor y. То есть x1, xor y,
[35:22.520 --> 35:25.480]  1 будет первый бит, x2, xor y, 2-ой бит и так далее, просто
[35:25.480 --> 35:29.760]  побитого xor. Тогда, смотрите, мы получили, в общем-то, то,
[35:29.760 --> 35:32.560]  что мы хотели от криптографического протокола. Если этот канал
[35:32.560 --> 35:35.240]  открытый, и кто угодно сюда может иметь доступ, то есть
[35:35.240 --> 35:37.920]  они общаются, не знаю, через электронную почту с каким-нибудь
[35:38.080 --> 35:41.800]  открытым ключом или в большой компании, в общем, какой-то
[35:41.800 --> 35:45.880]  открытый канал связи. Тогда это известно всем, но из этой
[35:45.880 --> 35:48.200]  информации, в принципе, вы не можете извлечь y. То
[35:48.200 --> 35:50.720]  есть если вы знаете битовую строчку из 0 и 1, зная, что
[35:50.720 --> 35:53.240]  в ней какие-то биты пришли из x и какие-то из y, они
[35:53.240 --> 35:55.880]  поxорились, получилось какое-то сообщение, вы не можете отсюда
[35:55.880 --> 35:59.680]  извлечь y. Особенно, если x это равномерная случайная
[35:59.680 --> 36:03.120]  строка, то у вас, по сути, каждый бит случайен. Но с
[36:03.120 --> 36:05.520]  другой стороны, Алиса смогла зашифровать, а дальше Боб
[36:05.520 --> 36:09.240]  сейчас может это расшифровать, просто еще раз поxoriflecx,
[36:09.240 --> 36:16.560]  потому что xxoryxxoryx, xxoryxxoryx, это y. Поэтому Боб очень легко
[36:16.560 --> 36:18.840]  расшифровывает. Зная вот то самое секретное сообщение,
[36:18.840 --> 36:22.320]  он берет, xorik его с результатом и получает закодированное
[36:22.320 --> 36:24.800]  сообщение. И больше никто так не может сделать, потому
[36:24.800 --> 36:27.200]  что x не известно никому. И лучшее, что они могут
[36:27.200 --> 36:28.880]  сделать, но это стройки и догадки, но вообще говоря,
[36:28.880 --> 36:32.400]  эта строка выглядит абсолютно случайней. И по ней нельзя
[36:32.480 --> 36:36.760]  получить информацию про y. Давайте подпишем, это все-таки
[36:36.760 --> 36:40.640]  довольно важно, что в идеальном варианте x это просто случайная
[36:40.640 --> 36:43.760]  вот такая битовая строка. Случайно равномерная строка.
[36:43.760 --> 36:51.560]  0,1. То есть, среди всех таких строк мы выбираем случайно
[36:51.560 --> 36:54.120]  и равновероятно, тогда вот это сообщение вне зависимости
[36:54.120 --> 36:58.120]  от y тоже по распределению такое же, оно случайно
[36:58.120 --> 37:02.840]  равновероятное в этом множестве. Вот, отличный протокол, но
[37:02.840 --> 37:05.200]  к сожалению, тут два изъяна. Во-первых, им нужно сначала
[37:05.200 --> 37:08.960]  очень как-то тайно договориться. То есть, они, грубо говоря,
[37:08.960 --> 37:10.800]  должны хоть когда-то встретиться в жизни, они должны жить
[37:10.800 --> 37:16.320]  рядом или что-то такое. А во-вторых, это в каком-то
[37:16.320 --> 37:19.600]  смысле одноразовое кодирование, потому что, скажем, если
[37:19.600 --> 37:23.120]  Алиса передала один раз вот такую информацию xxory,
[37:23.120 --> 37:27.240]  потом захотела еще передать что-то и передала xxorz, когда
[37:27.240 --> 37:29.800]  два сообщения y и z хочется послать, а она передает вот
[37:29.800 --> 37:33.520]  это и вот это, то, к сожалению, здесь уже нарушается так
[37:33.520 --> 37:36.720]  называемое нулевое разглашение, потому что злоумышленник,
[37:36.720 --> 37:39.320]  если он смотрит на вот эти два сообщения, то он хоть
[37:39.320 --> 37:42.920]  и, возможно, не может узнать y и z независимо, но точно
[37:42.920 --> 37:46.280]  может узнать yxorz. То есть, какую-то частичную информацию
[37:46.280 --> 37:48.720]  о том, что Алиса послала Бобу, он точно может получить.
[37:48.720 --> 37:52.680]  И просто если вот эта вот xor и xz, эти две строчки,
[37:52.680 --> 37:56.360]  получится yxorz. И хоть мы сами y и z еще не можем восстановить,
[37:56.360 --> 37:58.400]  но какой-то кусок информации из того, что Алиса послала
[37:58.400 --> 38:05.120]  Бобу, мы уже знаем. Вот, поэтому это кодирование, эта схема,
[38:05.120 --> 38:08.520]  она такая одноразовая очень. Один раз послали и забыли,
[38:08.520 --> 38:10.640]  потом в следующий раз придется опять заново встречаться
[38:10.640 --> 38:24.400]  и договориться о новом x. Так. Второй алгоритм. Алгоритм
[38:24.480 --> 38:35.280]  Диффи Хэммана. Ну, его можно считать не самостоятельным
[38:35.280 --> 38:38.040]  протоколом, а вот заменой вот этого куска, когда они
[38:38.040 --> 38:40.720]  договариваются о секретном ключе. То есть, как можно,
[38:40.720 --> 38:42.520]  находясь на расстоянии, договориться о секретном
[38:42.520 --> 38:50.960]  ключе. Алгоритм такой. Ну, любой из двух пользователей,
[38:50.960 --> 38:54.800]  либо Алиса, либо Боб, либо кто угодно, какая-то аракул
[38:54.800 --> 39:02.320]  какой-нибудь, договариваются о двух параметрах. P и G. Давайте
[39:02.320 --> 39:13.520]  я скажу, что пусть A генерирует простое P и G, которое будет
[39:13.520 --> 39:27.320]  являться первообразным корнем по моделю P. Так, кто
[39:27.320 --> 39:31.120]  знает, что такое первообразный корень по моделю P? Так,
[39:31.120 --> 39:35.520]  почти все. Хорошо. Ну ладно, половина скажем. Для нас
[39:35.520 --> 39:38.400]  нужно будет просто следующее знание, что множество чисел
[39:38.400 --> 39:44.360]  G в нулевой, G в первой и так далее, G в середине P-2 равно
[39:44.360 --> 39:52.720]  по моделю P множество чисел 1, 2, 3 и так далее P-1. То есть,
[39:52.720 --> 39:56.160]  все различные степени G по моделю P – это все различные
[39:56.160 --> 39:59.640]  возможные остатки, кроме нулевого, по моделю P. Все
[39:59.640 --> 40:02.280]  вот эти вот степени попарно различны и в каком-то порядке
[40:02.280 --> 40:06.560]  задают нам вот эту перестановку. То есть, степенями G можно
[40:06.560 --> 40:12.920]  покрыть все ненулевые остатки. Дальше, вот Алиса их сгенерирует
[40:12.920 --> 40:32.000]  и публикует их. А публикует G и P в открытом доступе. Дальше
[40:32.000 --> 40:44.200]  происходит следующее. A генерирует случайное A маленькое, B генерирует
[40:44.200 --> 40:58.160]  случайное B маленькое. Затем, причем эти A и B друг другу
[40:58.160 --> 41:01.840]  не сообщают, у них просто приватная информация. A знает
[41:01.840 --> 41:04.400]  A маленько, B знает B маленько, и они пока что никому это
[41:04.400 --> 41:07.560]  не сообщают. Дальше происходит следующее. Алиса отправляет
[41:07.560 --> 41:16.400]  Бобу сообщение G в степени A, а Боб отправляет Алисе сообщение
[41:16.400 --> 41:21.000]  G в степени B. То есть, они просто взяли случайные степени
[41:21.000 --> 41:24.240]  G. Алиса отправляет G в степени A, а Боб отправляет G в степени
[41:25.120 --> 41:41.400]  Вот они так обменялись какими-то степенями G. Дальше, теперь
[41:41.400 --> 41:49.280]  мы получаем, что Алиса знает A и G в степени B, а Боб наоборот
[41:49.280 --> 41:58.040]  вычисляет значение G в степени A и B. Если каждый из них знает
[41:58.040 --> 42:01.800]  вот это вот, то Алиса может вывести вот это число в степень
[42:01.800 --> 42:06.280]  A, получить G в степени A-B, а Боб может вывести G в степень
[42:06.280 --> 42:09.800]  A в степень B, получить G в степени A-B. Поэтому в итоге
[42:09.800 --> 42:14.160]  они оба у себя вычисляют значение G в степени A-B.
[42:15.160 --> 42:18.560]  G в степени A-B. То есть, еще раз, Алиса просто присланное
[42:18.560 --> 42:21.160]  сообщение возводит в степень A, в который секретное сообщение
[42:21.160 --> 42:25.400]  у нее хранится тайно сгенерированное. Боб то же самое делает со
[42:25.400 --> 42:27.280]  своим присланным сообщением, возводит его в степень
[42:27.280 --> 42:30.080]  B, который он сам сгенерировал. Теперь у них у обоих есть
[42:30.080 --> 42:34.840]  вот это вот число G в степени A-B. И это G в степени A-B можно
[42:34.840 --> 42:37.880]  использовать как вот этот вот тайный ключ, секретный
[42:37.880 --> 42:44.600]  ключ. Можно использовать как секретный ключ.
[42:58.600 --> 43:04.360]  Ну типа того, да. Значит, смотрите, утверждается, если они так
[43:04.360 --> 43:06.840]  пообщались, вычислили какое-то число, понятно, что они договорились
[43:06.920 --> 43:09.280]  о какой-то конкретном вот X, да, вот то, что у меня здесь
[43:09.280 --> 43:12.600]  было X, они договорились о каком-то общем, секретном
[43:12.600 --> 43:15.040]  ключе. Теперь вопрос, насколько он, на самом деле, секретный.
[43:15.040 --> 43:18.560]  Насколько Ева, вот этот вот подслушиватель, не сможет
[43:18.560 --> 43:21.040]  его вычислить? Давайте поймем, что знает Ева.
[43:27.040 --> 43:29.080]  Потому что задача дискретного агарифмирования сложная.
[43:30.280 --> 43:33.400]  Значит, давайте перечислим все, что знает Ева. Она знает
[43:33.440 --> 43:37.480]  первообразный корень по модулю P и знает две какие-то его
[43:37.480 --> 43:40.600]  степени G в степени A, G в степени B. Больше она ничего не
[43:40.600 --> 43:42.600]  знает. Просто это все, что передавалось по каналам.
[43:43.600 --> 43:46.880]  Модуль с генератором, то есть с первообразным корнем, и
[43:46.880 --> 43:52.000]  какие-то две его степени. То есть в идеале, что хотелось бы
[43:52.000 --> 43:54.560]  сделать Еве? Ей бы хотелось вот это вот как бы
[43:54.560 --> 43:58.000]  пралагарифмировать по основанию G, получить вот тот самый
[43:58.360 --> 44:01.480]  показатель A, узнать вот отсюда A. Ну и потом вот это
[44:01.480 --> 44:03.800]  число возвести в степени A, и тогда она получит тоже
[44:03.800 --> 44:08.760]  самое G в степени B. Но, к сожалению, для Евы и, к счастью,
[44:08.760 --> 44:12.280]  для нас, к счастью, для Лисы и Боба, задача вот этого
[44:12.280 --> 44:15.480]  самого дискретного агарифмирования, то есть решение
[44:15.480 --> 44:19.400]  уравнений G в степени X равно данному числу, то есть, по
[44:19.400 --> 44:22.200]  сути, излечение вот этого A по значению G в степени A,
[44:22.560 --> 44:25.760]  это сложная задача. И пока что ее никто не умеет делать
[44:26.120 --> 44:31.320]  за полином от длины P, скажем. Давайте это запишем.
[44:31.720 --> 44:38.400]  Самое простое, что может сделать Ева, скорее, что хочет
[44:38.400 --> 44:48.480]  сделать Ева. Вот оно какое. Значит, это найти то самое
[44:48.480 --> 45:05.200]  такое, что... Сейчас, секунду. Давайте я напишу так. Она
[45:05.200 --> 45:13.480]  хочет найти A, решив уравнение вида G в степени X сравнимо
[45:13.480 --> 45:17.400]  с константой C по моделю P. То есть нам известно вот
[45:17.400 --> 45:21.360]  того, C равное G в степени A, нам известно основание G,
[45:21.520 --> 45:23.960]  и нам хочется возвести в такую степень, это самое G,
[45:24.400 --> 45:26.920]  возвести в такую степень X, чтобы было то самое нужное
[45:26.920 --> 45:31.160]  число C в степени A. По сути, нам нужно решить такую задачу.
[45:31.920 --> 45:42.360]  Ну и затем получить G в степени B в степени A. И тогда она
[45:42.360 --> 45:49.880]  узнает тот самый тайный ключ. Разумеется, это не единственный
[45:49.880 --> 45:52.320]  способ действия для Евы, но он такой самый простой, мы не
[45:52.320 --> 45:54.680]  будем целиком доказывать корректность, потому что
[45:54.680 --> 45:56.760]  здесь нужно много определений вводить, что такое надежный
[45:56.760 --> 46:01.400]  протокол. Но по сути, ей нужно как раз таки решить
[46:01.400 --> 46:04.440]  такое уравнение. Ну а вот эта задача сложная, ее никто
[46:04.440 --> 46:10.600]  не умеет решать за полином от длины P. А на канты, вы
[46:10.600 --> 46:17.840]  думаете, умеют? Ну что же вроде факторизацию просто
[46:17.840 --> 46:24.280]  делать? Ну понятно, ладно. Мы живем в мире обычных
[46:24.280 --> 46:27.720]  машин пока что, и считается, что такое уравнение пока
[46:27.720 --> 46:32.560]  что никто не умеет решать за полином от длины P. Не
[46:32.560 --> 46:44.040]  умеем быстро решать. Вот. Ну и на семинаре можно
[46:44.040 --> 46:47.120]  разобрать вариант решения этого уравнения за отхорний
[46:47.120 --> 46:53.240]  из P. То есть в идеале, если Алиса генерирует P достаточно
[46:53.240 --> 46:56.080]  большим, ну не знаю, 100 знаков примерно, P порядка 10 в
[46:56.080 --> 47:00.000]  сотой простое, тогда хотелось бы работать за полином
[47:00.040 --> 47:03.120]  от 100, то есть за полином от длины входа. Но лучшее
[47:03.120 --> 47:05.680]  как бы, ну или плюс-минус лучшее, что известно, это вот от
[47:05.680 --> 47:09.000]  корня из 10 сотой, то есть примерно за 10.50. Это очень
[47:09.000 --> 47:11.920]  долго, и как бы у Евы нет никакой надежды, что она
[47:11.920 --> 47:16.320]  сможет это X быстро найти. Ну вот такой сюжет, который
[47:16.320 --> 47:19.880]  позволяет им договориться о тайном X, Алисе и Бобу
[47:19.880 --> 47:22.240]  договорятся о тайном X, явно не встречаясь. Вот как-то
[47:22.240 --> 47:25.160]  послали сообщение, вычисляют одно и то же число, которое
[47:25.160 --> 47:29.120]  является будущим секретным ключом для их общения. Окей?
[47:29.680 --> 47:30.200]  Хорошо.
[47:43.920 --> 47:47.440]  Так, ну давайте еще третий протокол посмотрим, протокол
[47:47.440 --> 47:47.840]  RSA.
[47:53.560 --> 47:57.520]  Кажется, тоже по первым буквам фамилий, авторов.
[47:58.200 --> 47:59.080]  Значит, алгоритм такой.
[48:03.040 --> 48:06.800]  Алгоритм такой. Ну здесь тоже немножко он односторонний
[48:06.800 --> 48:13.800]  получается, значит он позволяет обеспечить одностороннее
[48:13.800 --> 48:16.480]  общение. В том смысле, что вот Боб есть какой-то там
[48:16.480 --> 48:19.600]  не знаю, какое-нибудь государственное предприятие, ну или там
[48:19.600 --> 48:22.000]  государственный орган, он публикует открытый ключ,
[48:22.000 --> 48:24.800]  по которому люди могут отправлять к нему письма. И эти
[48:24.800 --> 48:27.240]  письма будут видны всем, но они будут как бы закодированы.
[48:28.280 --> 48:30.040]  Никто не сможет понять, что в них написано, кроме
[48:30.040 --> 48:32.640]  отправителя и получателя. То есть такое одностороннее
[48:32.640 --> 48:34.600]  общение, мы предполагаем, что государственный орган
[48:34.600 --> 48:37.200]  как бы не отвечает в ответ, ну или там отвечает открытым
[48:37.200 --> 48:38.960]  текстом. Мы хотим закодировать только в одну сторону.
[48:42.280 --> 48:47.000]  Работает следующим образом. Боб публикует.
[48:47.000 --> 48:59.480]  Нет, давайте сначала, Боб генерирует различные простые ПК.
[48:59.480 --> 49:12.280]  Различные простые ПК. И публикует n большое равное ПК.
[49:12.280 --> 49:20.480]  П умножить на Q. Вот. И здесь уже такой как бы затравка на
[49:20.480 --> 49:23.520]  будущее, что он опубликовал произведение двух простых,
[49:23.520 --> 49:27.400]  и стороннему наблюдателю, если он знает только произведение
[49:27.400 --> 49:29.880]  двух простых. Уже довольно сложно разложить это число
[49:29.880 --> 49:32.200]  на множители. Вот я вам там скажу произведение каких-то
[49:32.200 --> 49:35.280]  двух простых довольно больших. Чтобы разложить на множители,
[49:35.280 --> 49:37.960]  ну опять-таки плюс-минус лучшее, что мы умеем, это
[49:37.960 --> 49:40.680]  перебирать все простые до корня и искать там минимальное
[49:40.680 --> 49:43.600]  из них. Потому что как бы не очень понятно, как найти
[49:43.600 --> 49:46.720]  это самое разложение. То есть здесь опять-таки задача
[49:46.720 --> 49:49.920]  факторизации, получение по вот этому вот числу отдельно
[49:49.920 --> 49:53.000]  P и отдельно Q. Вот потому что она сложная, мы предполагаем,
[49:53.000 --> 49:55.960]  или пока что никто не умеет это быстро решать, этот
[49:55.960 --> 49:59.080]  протокол будет надежным. Итак, ну что он опубликовал
[49:59.080 --> 50:14.600]  PN равное П в степеньку, а также число E, взаимно простое
[50:14.600 --> 50:32.440]  с P-1 на Q-1. Тогда как работает общение? Если Алиса хочет
[50:32.440 --> 50:41.760]  послать какое-то число X Бобу, хочет послать X Бобу,
[50:41.760 --> 50:46.200]  тогда Алиса отправляет Бобу X в степень E по моделю
[50:46.200 --> 50:52.080]  N. То есть если она просто хочет отправить X, то вместо
[50:52.080 --> 50:54.400]  отправки непосредственно X, потому что если мы отправим
[50:54.400 --> 50:56.960]  X, он будет всем виден, соответственно все знают, что отправила
[50:56.960 --> 51:00.720]  Алиса. Вместо этого Алиса отправляет X в степень E. Вот
[51:00.720 --> 51:04.360]  возводит это число в степень E, тем самым как бы, ну это
[51:04.360 --> 51:09.880]  уже не сам X, а какая-то функция от него. Ну а дальше Боб,
[51:09.880 --> 51:15.200]  чтобы раскодировать обратное сообщение, чтобы раскодировать
[51:15.200 --> 51:24.880]  X в степени E, делает следующее. Ему-то известно разложение
[51:24.880 --> 51:28.720]  N на простые множители по IQ. Он делает следующее. Он
[51:28.720 --> 51:44.360]  находит D, это число обратное к E, вот как раз обратное
[51:44.360 --> 51:56.680]  по модуле возникает, обратное к E по модулю P-1Q-1 и вычисляет
[51:56.680 --> 52:05.320]  X в степени E в степени D. И утверждает, что это в точности
[52:05.320 --> 52:16.240]  равно X по модулю N. Так, значит еще раз, как работает алгоритм.
[52:16.240 --> 52:19.640]  Сначала Боб, государственный орган, публикует, генерирует
[52:19.640 --> 52:22.800]  сначала два простых числа больших по IQ и публикует
[52:22.800 --> 52:26.240]  в открытом доступе их произведения N. А также публикует
[52:26.240 --> 52:34.240]  число E, которое взаимно просто вот с этим произведением
[52:34.240 --> 52:40.000]  P-1Q-1. N и E в открытом доступе. Дальше, если Алиса хочет
[52:40.000 --> 52:43.880]  послать Бобу какое-то сообщение, она просто позовет его
[52:43.880 --> 52:47.320]  в степень E и отправляет по каналу X в степени E. Теперь
[52:47.320 --> 52:50.040]  сторонний наблюдатель видит только X в степени E, но не
[52:50.040 --> 52:54.440]  видит само E, то есть не видит само X, извините, не видит
[52:54.440 --> 52:56.320]  исходного сообщения, видит только какую-то его степень.
[52:56.320 --> 53:00.360]  Ну а дальше Бобу, чтобы расходировать это сообщение,
[53:00.360 --> 53:03.520]  ему достаточно возвести его в степень D, такое, что
[53:03.520 --> 53:09.400]  D это обратный к Е по модуле Q-1Q-1. Так, чтобы понять, почему
[53:09.400 --> 53:13.400]  это работает, нужно, наверное, сказать, нужна нам все-таки
[53:13.400 --> 53:14.480]  тирема Эйлера.
[53:43.400 --> 54:08.880]  Так, вот есть такая тирема, которая говорит, что если
[54:09.880 --> 54:15.640]  числа А и М, тогда А в степени фиат М-1 это единица по модуле
[54:15.640 --> 54:17.960]  М, ну а значит, если мы обе части умножим на А, А в степени
[54:17.960 --> 54:20.600]  фиат М равно А по модуле М. Значит, фиат М это функция
[54:20.600 --> 54:29.280]  Эйлера. Фиат функция Эйлера. Вот. Нам не особо важно, как
[54:29.280 --> 54:31.520]  именно она себя ведет, нам важно только лишь, что
[54:31.520 --> 54:47.280]  фи от ПQ равно П-1 на Q-1. Что? Еще раз. Фи от П это П-1, да.
[54:47.280 --> 54:54.240]  Так, что, косяк где-то? Сейчас, сейчас, сейчас, одну секунду.
[54:54.240 --> 55:13.680]  Да, нет. Да, где-то не так. Извините. Момент. Вот здесь?
[55:13.680 --> 55:33.520]  Сейчас, sorry, sorry, sorry. Я позорно загуглю тирема Эйлера. Да,
[55:33.520 --> 55:36.480]  значит, я облажался, действительно. Тут нет, тут нету минус
[55:37.480 --> 55:43.920]  есть. Да, спасибо. Извините. Дальше. Правильно ли я посчитал
[55:43.920 --> 55:53.680]  фи от ПQ? Вроде правильно. Так, ну тогда смотрите. Да,
[55:53.680 --> 55:57.120]  тогда смотрите. Значит, что здесь происходило? Нам
[55:57.120 --> 56:01.120]  известно х в степени Е, а еще мы знаем, что D это обратное
[56:01.120 --> 56:07.440]  к Е по модулю P-1Q-1. Вот. Ну, значит, ЕD это как бы единичка
[56:07.440 --> 56:17.120]  по модулю P-1Q-1. И вот это вот это фи от Н. То есть мы
[56:17.120 --> 56:19.440]  по сути, вот здесь вот, когда возвели х в степени Е, в
[56:19.440 --> 56:24.600]  степень D еще, мы получили х в степени, и эта степень
[56:24.600 --> 56:28.440]  сравнима с единицей по модулю фи от Н. Ну, значит, как раз
[56:28.440 --> 56:32.760]  вот это вот то, что нужно. Да, если мы возводим х в степень
[56:32.760 --> 56:35.600]  что-то кратное фи от Н плюс единичка, то есть единичка
[56:35.600 --> 56:38.520]  по модулю фи от Н, то мы получим исходный х по модулю
[56:38.520 --> 56:41.320]  Н. Значит, как раз вот это вот равенство выполняется.
[56:41.320 --> 56:43.960]  Х в степени ЕD сравнимо с х по модулю Н. Вот следует
[56:43.960 --> 56:50.680]  из теремы Эйлера. Вот. Ну, отлично. Значит, Боб смог декодировать
[56:50.680 --> 56:54.000]  исходное сообщение Алисы. Просто возведением х в какую-то
[56:54.000 --> 56:58.240]  степень. Вот. Ну, значит, тут надо сказать, что задача
[56:58.240 --> 57:01.560]  возведения в степень простая. Мы в прошлом семестре учились
[57:01.560 --> 57:04.360]  возводить винарно в степень. Ну, вот здесь любой алгоритм
[57:04.360 --> 57:07.160]  быстрого возведения в степень по модулю. Там, скажем, за
[57:07.160 --> 57:11.120]  алгоритм D это можно сделать, возвести в степень. Вот.
[57:11.120 --> 57:15.640]  Но сторонний наблюдатель, что он видит? Он видит N, он
[57:15.640 --> 57:18.840]  видит E, он видит х в степени E. Больше ему ничего недоступно.
[57:18.840 --> 57:23.000]  У него есть как бы два способа действия. Первый способ
[57:23.000 --> 57:26.120]  действия — это пытаться извлечь корень этой степени
[57:26.120 --> 57:30.720]  из х в степени E. Если вдруг у него это получится, то
[57:30.720 --> 57:34.720]  он сможет декодировать исходное E. Но это тоже не очень понятно,
[57:34.720 --> 57:39.880]  как делать. Это не очень простая задача, если и решаемая
[57:39.880 --> 57:43.240]  эффективна. Второй способ — это пытаться разложить
[57:43.240 --> 57:46.840]  N-намножитель. Значит, если он запускает какой-то алгоритм
[57:46.840 --> 57:49.720]  факторизации довольно быстрый, который смог найти такие
[57:49.720 --> 57:53.240]  разложения N на PQ, тогда он сможет сделать все, что
[57:53.240 --> 57:57.440]  нужно. Он знает N как раскладываться на PQ, отсюда он сможет найти
[57:57.440 --> 58:02.920]  phi от N. Что это P-1 на Q-1 может найти просто перемножив
[58:02.920 --> 58:06.320]  вот эти вот два числа. Ну и тогда обратное к E по модулю
[58:06.320 --> 58:11.840]  phi от N он может легко узнать. Обратное к E по модулю phi
[58:11.840 --> 58:14.640]  от N он тоже может узнать. Ну, значит, он знает D, значит,
[58:14.640 --> 58:21.120]  он может смоделировать поведение Боба просто. Поэтому сторонним
[58:21.120 --> 58:23.360]  наблюдателем в итоге у него выбор — либо пытаться
[58:23.360 --> 58:25.960]  раскладывать N-намножители, либо пытаться извлекать
[58:25.960 --> 58:32.160]  корень данной степени в ZN. Решать уравнение в стиле
[58:32.160 --> 58:36.360]  X в степени E равно чему-то и искать X. По сути извлекать
[58:36.360 --> 58:41.080]  корень. Обе эти задачи не очень простые, и поэтому
[58:41.080 --> 58:43.600]  этот протокол в каком-то смысле надежный. Что даже
[58:43.600 --> 58:45.920]  если сторонний наблюдатель видит все вот это вот, то
[58:45.920 --> 58:49.040]  он не сможет, ну или по крайней мере быстро не сможет дикодировать
[58:49.040 --> 59:08.320]  исходное сообщение. Так, хорошо, хорошо. Вот, ну тогда
[59:08.320 --> 59:11.560]  мы немножко поговорили про кодирование, точнее
[59:11.560 --> 59:15.360]  про криптографию, как обеспечить какое-то надежное
[59:15.360 --> 59:18.400]  общение. Плюс-минус, то есть так, что они общаются
[59:18.400 --> 59:23.040]  по открытому каналу и сторонний наблюдатель все равно не
[59:23.040 --> 59:33.120]  может понять, о чем речь. Так, тогда, наверное, следующий
[59:33.120 --> 59:51.080]  сюжет, алгоритм Штрассена. Вот, алгоритм Штрассена,
[59:51.080 --> 59:53.000]  наверное, будет присклинаться за отравкой к следующему
[59:53.000 --> 59:56.560]  разу, когда мы перейдем наконец к алгоритму FFT. Значит, алгоритм
[59:56.560 --> 59:59.480]  FFT, напоминаю, он позволяет нам быстро перемножать
[59:59.480 --> 01:00:02.240]  многочлены. Если у нас два многочлена, скажем, N на
[01:00:02.240 --> 01:00:05.680]  N, то есть А0 плюс А1х плюс и так далее, там, вплоть
[01:00:05.680 --> 01:00:09.320]  до АН, ХВН, и второй тоже самый с Б. И вот их можно
[01:00:09.320 --> 01:00:15.840]  перемножить за N лог N. Да, ну, считая, что мы не паримся
[01:00:15.840 --> 01:00:18.400]  с точностью и считаем все с какой-то погрешностью.
[01:00:18.400 --> 01:00:21.840]  Вот, алгоритм Штрассена делает, ну, как бы, пытается
[01:00:21.840 --> 01:00:24.560]  сделать что-то похожее, но с матрицами. Итак,
[01:00:25.040 --> 01:00:36.040]  пусть есть две матрицы, две матрицы А и Б, размера,
[01:00:36.040 --> 01:00:40.600]  давайте считать, что 2 вкатый на 2 вкатый. Для простоты
[01:00:40.600 --> 01:00:44.080]  считаем, что это матрицы квадратные, и при этом у
[01:00:44.080 --> 01:00:49.320]  них число строк, размерность этой степени двойки, 2 вкатый
[01:00:49.320 --> 01:01:00.200]  на 2 вкатый. Наша цель – это найти А0хB. Наша цель – найти
[01:01:00.200 --> 01:01:03.840]  их произведение, которое мы обозначаем за С. Ну,
[01:01:03.840 --> 01:01:06.240]  есть понятное дело, очень простой алгоритм, просто
[01:01:06.240 --> 01:01:08.720]  по определению, как их перемножить. Мы перебираем
[01:01:08.720 --> 01:01:11.480]  строчку первой матрицы, столбец второй матрицы,
[01:01:11.480 --> 01:01:14.760]  скалярную умножаем, получаем очередной элемент. Значит,
[01:01:14.760 --> 01:01:20.600]  наивный алгоритм просто по определению работает
[01:01:20.600 --> 01:01:31.560]  за куб от размера матрицы, за θ от n в кубе, где n равно
[01:01:31.560 --> 01:01:35.600]  2 вкатый. Если у меня размер матрицы – это n, то перемножить
[01:01:35.600 --> 01:01:38.480]  две матрицы n на n стоит n в кубе, ну просто по определению.
[01:01:38.480 --> 01:01:44.880]  Оказывается, можно лучше, можно эффективнее, при условии,
[01:01:44.880 --> 01:01:51.000]  что у нас есть операция вычитания. Значит, давайте
[01:01:51.000 --> 01:01:55.520]  все это напишем. Можно немножко быстрее, мы сейчас это сделаем.
[01:01:55.520 --> 01:01:58.160]  Давайте для этого мы разобьем атмосферу А на 4 кусочка.
[01:01:58.160 --> 01:02:08.840]  То есть мы поделим пополам число столбцов и число
[01:02:08.840 --> 01:02:11.480]  строк и разобьем на такие 4 равные квадратика. Каждый
[01:02:11.480 --> 01:02:14.280]  квадратик будет иметь размерность 2 в степени камен с 1 на 2 в
[01:02:14.280 --> 01:02:19.960]  степени камен с 1. То же самое сделаем с B и с C. Разобьем
[01:02:19.960 --> 01:02:22.080]  все эти матрицы на 4 одинаковые квадратика.
[01:02:49.960 --> 01:02:55.240]  А дальше происходит следующая магия, которую не надо будет
[01:02:55.240 --> 01:02:59.320]  запоминать, но идея здесь довольно простая. Давайте
[01:02:59.320 --> 01:03:04.560]  посчитаем следующие 7 страшных матриц. Как это придумать
[01:03:04.560 --> 01:03:20.640]  мы обсуждать не будем, мы просто это посчитаем.
[01:04:20.640 --> 01:04:29.000]  Вот такой рандом. Вот что это мы написали. Смысл такой,
[01:04:29.000 --> 01:04:36.600]  вот у нас есть 8 под матриц, 4 отсюда, 4 отсюда. Мы хотим
[01:04:36.600 --> 01:04:41.200]  сделать 7 рекурсивных запусков умножения матрицы меньшего
[01:04:41.200 --> 01:04:43.040]  порядка. То есть если у меня исходные были 2 вкат
[01:04:43.040 --> 01:04:46.080]  на 2 вкат, то теперь я буду перемножать матрицы размера
[01:04:46.080 --> 01:04:49.600]  2 вк-1 на 2 вк-1 друг на друга. То есть это матрица в два
[01:04:49.600 --> 01:04:53.480]  раза меньшего порядка. И число умножений стало 7.
[01:04:53.480 --> 01:04:57.160]  В 7 умножений матриц в 2 меньшего порядка. Теперь если
[01:04:57.160 --> 01:04:59.800]  я с помощью этих 7 матриц смогу вычислить вот эти
[01:04:59.800 --> 01:05:03.760]  вот 4 ячейки, то я получаю исходную задачу, свел к
[01:05:03.760 --> 01:05:08.960]  7 задачам в 2 меньшего порядка. У меня будет такая рекуррента.
[01:05:08.960 --> 01:05:22.840]  ТОтн равно 7 ТОтн пополам плюс, видимо, n квадрат. Н квадрат,
[01:05:22.840 --> 01:05:26.000]  потому что здесь мне нужно будет, то есть здесь самое
[01:05:26.000 --> 01:05:27.920]  сложное это складывать и вычислять матрицы. Что
[01:05:27.920 --> 01:05:32.840]  это такое? Вот. Но мастер Терема нам позволяет, что?
[01:05:32.840 --> 01:05:38.000]  Ой, спасибо. Тета, извините. Да. Вот. Мастер Терема нам
[01:05:38.000 --> 01:05:44.000]  позволяет такое решать. Мастер Терема. Мы там находим
[01:05:44.000 --> 01:05:48.880]  что-то из этого a, что-то из этого b. Считаем логарифм
[01:05:48.880 --> 01:05:51.800]  от семерки по основанию 2. Понимаем, что это сильно
[01:05:51.800 --> 01:05:54.160]  больше, чем n в квадрате. Значит симптотика будет
[01:05:54.160 --> 01:06:01.720]  тета от n в степени лог 7 по основанию 2. Просто из
[01:06:01.720 --> 01:06:05.880]  мастер Терема напрямую получается. И смотрите, это уже лучше,
[01:06:05.880 --> 01:06:09.480]  чем n в кубе. Чем вот то наивное решение, это будет лучше,
[01:06:09.480 --> 01:06:22.680]  потому что это n примерно в степени 2.81. Ну, можно
[01:06:22.680 --> 01:06:33.280]  2 плюс 7, он даже вроде. Но теоретически, да. Нет-нет,
[01:06:33.280 --> 01:06:40.840]  больше этого нет. Ну не будем в смысле. Слабо. Но только
[01:06:40.840 --> 01:06:51.720]  если большие матрицы. Да-да-да. Ну, смотрите, все равно как
[01:06:51.720 --> 01:06:54.680]  бы здорово. Можно умножать не за куб, а за n в степени
[01:06:54.680 --> 01:06:59.240]  2.8. Отлично. Вот. Ну хорошо, мы это посчитали. Давайте
[01:06:59.240 --> 01:07:01.400]  я напишу, как выражаются конечные вот эти четыре
[01:07:01.400 --> 01:07:06.440]  подматрицы через посчитанные. Вот, что-нибудь проверим.
[01:07:06.440 --> 01:07:33.760]  У этого алгоритма есть еще, можно сказать, что он практически
[01:07:33.760 --> 01:07:36.200]  применим, потому что он очень хорошо параллелится,
[01:07:36.200 --> 01:07:39.760]  потому что вот вы, по сути, свели задачу к семи меньшим,
[01:07:39.760 --> 01:07:42.120]  да, если у вас есть там, условно говоря, бесконечно, ну, там
[01:07:42.120 --> 01:07:44.560]  достаточно много процессоров, вы каждому из них перейдете
[01:07:44.560 --> 01:07:51.320]  эту задачу на вот, ну, переножение там двух каких-то подматриц.
[01:07:51.320 --> 01:07:55.760]  Они это там вычисляют параллельно все. Вот. И тогда вы как бы
[01:07:55.760 --> 01:07:58.000]  можете эффективно, ну, быстро посчитать а умножить на
[01:07:58.000 --> 01:08:03.560]  б. Вот. А в каком-то смысле, сейчас, сейчас надо подумать.
[01:08:03.560 --> 01:08:06.400]  Короче, можно сказать, что этот алгоритм в каком-то
[01:08:06.400 --> 01:08:08.440]  смысле эффективен, потому что он хорошо параллелится
[01:08:08.440 --> 01:08:09.960]  именно вот из-за того, что он разбивается на семь
[01:08:09.960 --> 01:08:12.400]  независимых кусочков. Сначала они все считаются, потом
[01:08:12.400 --> 01:08:18.760]  из них получается ответ. Вот. Так вот, утверждается,
[01:08:18.760 --> 01:08:21.960]  что если мы посчитали те семь штук, то результатившие
[01:08:21.960 --> 01:08:24.680]  четыре блока матрицы С считаются по таким формулам.
[01:08:24.960 --> 01:08:27.400]  Так. Ну, вот это все учить не надо. Давайте просто
[01:08:27.400 --> 01:08:29.600]  какой-нибудь докажем, да, что действительно получается
[01:08:29.600 --> 01:08:33.960]  то, что нужно. Вот. И на этом, наверное, алгоритм мы оставим.
[01:08:33.960 --> 01:08:39.080]  Ну, например, давайте вот С2,2 посмотрим. С2,2 правой нижней углы.
[01:08:39.080 --> 01:08:41.680]  Значит, как он получается? Чтобы получить С2,2 мне
[01:08:41.680 --> 01:08:46.280]  нужно умножить последнюю строчку в а на последний столбец в b.
[01:08:46.280 --> 01:08:58.280]  С2,2 точно равно a2,1 умножить на b1,2 плюс a2,2 на b2,2. Вроде так.
[01:08:58.280 --> 01:09:03.360]  Да, ну, то есть тут надо еще доказать, что когда в матрице
[01:09:03.360 --> 01:09:06.360]  бьем на блоке, то по сути над блоками умножение получается
[01:09:06.360 --> 01:09:08.560]  такое же, как над обычными числами, да, по строчной
[01:09:08.560 --> 01:09:13.800]  и по столбцам. Ну, это просто. Ну, давайте проверим, что
[01:09:13.800 --> 01:09:21.200]  вот это равно вот этому. Вот. На всякий случай. Давайте
[01:09:21.200 --> 01:09:31.000]  это посчитаем. Значит, p1 минус p2 плюс p3 плюс p6. Так, интересно.
[01:09:31.000 --> 01:09:34.440]  Ну, я не вижу здесь общих множителей, поэтому предлагаю раскрыть
[01:09:34.440 --> 01:09:59.240]  скобки и умереть. Ну, давайте. Пусть веселость не сойдется,
[01:10:00.240 --> 01:10:29.040]  кайф. Так, это p1 было. Дальше p2, я считаю. Плюс p3. Плюс p6.
[01:10:29.040 --> 01:10:48.400]  Вот это? Это минус.
[01:10:48.400 --> 01:11:03.160]  Нет, нет, еще раз, смотрите. Мы знаем вот это? А сейчас я просто пишу вот это
[01:11:03.160 --> 01:11:08.080]  вот выражение, чему равно. Вот это вот равно вот этому. Да, вы про это?
[01:11:08.080 --> 01:11:16.320]  Не, мы просто подставляем, чему равно p1, p2, p3, вот в эту форму. Вот то вот
[01:11:16.320 --> 01:11:22.080]  подставляем сюда. Вот. Значит, p1, p2, p3 я подставил. Значит, осталось p6.
[01:11:46.320 --> 01:11:51.920]  Так, я вроде все выписал, теперь буду сокращать.
[01:12:16.320 --> 01:12:22.120]  Ну, я по-разному, типа, такие. Ну, в общем, чтобы было понятно, что с чем сократилось.
[01:12:22.120 --> 01:12:31.960]  Все, вроде все сократилось, осталось как раз то, что нужно. А2,2,B2,2 плюс А2,1,B1,2. Ура, победа. Вот.
[01:12:31.960 --> 01:12:36.240]  Ну, видимо, если вы посчитаете вот эти вот три штуки, то получится тоже то, что нужно. Те самые
[01:12:36.240 --> 01:12:45.680]  произведения кусочков матрицы, которые нам нужны. Симметрично, очевидно. Отлично. Нет, нет, не надо.
[01:12:45.680 --> 01:12:51.360]  То есть, тут главная идея, идея такая, что мы разбиваем наше матрице на четыре квадратика
[01:12:51.360 --> 01:12:56.240]  одинакового размера. Потом как-то считаем семь каких-то странных произведений через суммы и
[01:12:56.240 --> 01:13:01.760]  разности. Семь посчитали, получили такую симптомику. Ну, и в конце из этих семи произведений нужно
[01:13:01.760 --> 01:13:05.840]  как-то их там с плюсами и с минусами взять, чтобы получить четыре из этих квадрат. Эти формулы не
[01:13:05.840 --> 01:13:21.240]  надо запоминать. Вот они есть. Да, и получается, что вот получается такой алгоритм. Так. Окей. Вот. Ну,
[01:13:21.240 --> 01:13:34.880]  круто. Получается, можно перемножать быстрее, чем Зейн в клубе. И тогда давайте последний сюжет на
[01:13:34.880 --> 01:13:44.360]  сегодня быстренько обсудим, что успеем. Это число стиринга. Число стиринга первого и второго рода.
[01:13:44.360 --> 01:14:07.120]  Так. Сейчас, сейчас, сейчас, сейчас всё будет. Так, хорошо.
[01:14:07.120 --> 01:14:19.440]  Смотрите. Давайте на первом роде сначала сфокусируемся. Число стиринга первого рода. Их
[01:14:19.440 --> 01:14:24.520]  можно определить двумя способами. Первый способ такой. Давайте мы будем рассматривать вот такие
[01:14:24.520 --> 01:14:52.480]  вот многочлены. Х на х-1 и так далее, вплоть до х-н плюс один. Н умножители здесь. Нет. Нет, нет.
[01:14:52.480 --> 01:14:58.480]  А, ну и тогда х факториал делит на х-н факториал. Тогда уж. Если так. Ну, потому что это как раз все,
[01:14:58.480 --> 01:15:05.680]  ну, произведение всех до х, кроме произведения всех до х-н. Вот. Ну да, х здесь это не обязательно
[01:15:05.680 --> 01:15:08.920]  целое число, это просто какая-то переменная. Поэтому не обязательно продавать этому какой-то
[01:15:08.920 --> 01:15:14.920]  смысл. Вот рассмотрим на такой многочлен. И, значит, наш вопрос следующий. С какими
[01:15:14.920 --> 01:15:23.120]  коэффициентами он раскладывается по обычной системе там 1, х, х в квадрате и так далее? Давайте
[01:15:23.120 --> 01:15:29.680]  напишем так. СНК х в катах. То есть, ну понятно, какой-то многочлен в степени ровно n, значит,
[01:15:29.680 --> 01:15:35.440]  его можно представить в виде такой вот суммы х в катах с кем-то коэффициентами. И вот наш
[01:15:35.440 --> 01:15:41.120]  вопрос, как находить эти СНК? И вот эти вот СНК как раз будут являться числами стиринга первого рода.
[01:15:41.120 --> 01:15:54.520]  Число стиринга первого рода. Так. Зачем нам это может быть нужно? Зачем нам это может быть нужно?
[01:15:54.520 --> 01:16:01.440]  Ну, например, кажется, на одном из прошлых семинаров была такая задачка. Посчитать вот такую сумму.
[01:16:01.440 --> 01:16:12.480]  К квадрат на СНК по всем К от 0 до n. Вот, значит, самое простое. Что здесь можно сделать? Следующее.
[01:16:12.480 --> 01:16:25.200]  Сказать, что К в квадрате. Ну, это К на К-1 плюс К. Значит, эту сумму можно расписать как сумма по К от 0 до n,
[01:16:25.200 --> 01:16:38.160]  К на К-1 СНК плюс такая же сумма К на СНК. Вот. А дальше, когда мы степень К заменили на вот такой вот,
[01:16:38.160 --> 01:16:43.640]  как бы, ну, как это называется, такой неспадающий факториал, то есть К на К-1, ну, то есть на несколько
[01:16:43.640 --> 01:16:50.120]  множителей, вот, это будет очень удобно сокращаться с СНК, потому что СНК это там как раз произведение
[01:16:50.120 --> 01:16:58.560]  факториалов N-факториал делить на K-факториал на N-K-факториал. И там как раз вот это и К-1 сократятся с чем-то в знаменателе,
[01:16:58.560 --> 01:17:04.920]  и будет вот эта вот сумма перепишется как там какая-то, ну, какая-то другая С, в общем. И, короче,
[01:17:04.920 --> 01:17:11.040]  этот ряд считать сильно проще, чем исходный. Если мы перейдем от обычных степеней К вот этим вот
[01:17:11.040 --> 01:17:16.120]  факториальным степеням, то есть произведения нескольких К, К-1, К-2 и так далее, их очень
[01:17:16.120 --> 01:17:21.880]  просто перенажать с С-шками и складывать. То есть вот это вот посчитать проще, чем
[01:17:21.880 --> 01:17:28.880]  исходное. Ну, и это тоже самое, то есть это там в многочисленной еще меньшей степени. Вот. Такие
[01:17:28.880 --> 01:17:34.160]  задачи возникают, у вас же было распределение полосона на тервере, вот. Это возникает, например,
[01:17:34.160 --> 01:17:40.800]  распределение полосона. Ну, или там, сейчас, сейчас. В общем, похожие идеи, да, не скажу, что прям ровно
[01:17:40.800 --> 01:17:44.920]  такое, но что-то похожее возникает, когда вы считаете, скажем, вот есть у вас КСИ с распределением
[01:17:44.920 --> 01:17:51.880]  полосона, и вам нужно посчитать ее там от ожидания третьей степени, третий момент посчитать. Вот. Там
[01:17:51.880 --> 01:17:58.640]  как раз будет что-то подобное, и если вы вместо К в кубе напишите там какую-то сумму К на К-1 на К-2 с
[01:17:58.640 --> 01:18:04.320]  киминкоэффициентом плюс К на К-1 плюс К, вот. Там это точно также просто просто сложится. Ну, там
[01:18:04.320 --> 01:18:09.480]  тоже какие-то факториалы есть, и вот как раз они будут сокращаться с вот этим множителем. Вот.
[01:18:09.480 --> 01:18:17.480]  То есть задача перехода от вот такого многочлена к сумме вот таких, ну, в каком-то смысле полезна,
[01:18:17.480 --> 01:18:22.680]  что, ну, например, с ее помощью можно там просто считать моменты полосонского распределения. Ну,
[01:18:22.680 --> 01:18:27.680]  и там, похожих распределений, в которых в вероятности есть какие-то факториалы.
[01:18:27.680 --> 01:18:35.640]  Когда мы от степени переходим к произведению нескольких последовательных чисел. Вот.
[01:18:35.640 --> 01:18:39.840]  Это число стерлинга первого рода.
[01:18:39.840 --> 01:18:59.440]  Можно доказать еще. Давайте напишем утверждение. Утверждение. Модуль числа СНК. Это количество
[01:18:59.440 --> 01:19:21.120]  перестановок на N-элементах, которые в циклическом разложении имеют ровно К от циклов. В разложении
[01:19:21.120 --> 01:19:41.040]  на циклы имеют ровно К от циклов. Вот. Ну, например, если вы рассматриваете N равно тройке,
[01:19:41.040 --> 01:19:45.200]  рассматриваете все перестановки на трех элементах, то как они у вас выглядят? Значит,
[01:19:45.200 --> 01:19:48.160]  как может выглядеть такая перестановка? Давайте я все шесть нарисую быстренько.
[01:19:48.160 --> 01:19:58.080]  Есть такой цикл. Есть, скажем, просто петля на единицы, два-три переходят друг в друга. Есть,
[01:19:58.080 --> 01:20:06.840]  когда все три это отдельные петельки. Ну, перестановки. Перестановка это всегда такой
[01:20:06.840 --> 01:20:14.560]  ориентированный граф. Несколько циклов. Дальше что бывает? Дальше бывает, скажем,
[01:20:14.560 --> 01:20:22.040]  двойка это петля, а один-три друг в друга переходят. Тройка это петля, а один-два в друг
[01:20:22.040 --> 01:20:32.560]  друга переходят. Ну и, видимо, цикл обратный к этому. Все возможны шесть перестановок на
[01:20:32.560 --> 01:20:37.520]  трех элементах. И, соответственно, у каждой из них есть свой циклический тип. Здесь есть цикл длины
[01:20:37.520 --> 01:20:45.760]  1 и 3, здесь есть циклы длины 1 и 2, здесь есть циклы 1 и 1, здесь 1 и 2, здесь 1 и 2, здесь 3. Ну и,
[01:20:45.760 --> 01:20:51.680]  соответственно, если мы фиксируем количество циклов, какое число k, скажем, ну вот k равно 2. Мы
[01:20:51.680 --> 01:20:57.280]  хотим, чтобы было ровно два цикла. Тогда нам подойдет вот это, вот это и вот это. Картинка,
[01:20:57.280 --> 01:21:02.720]  где есть ровно два цикла. То есть, когда все распадается в два таких кружочка зацикленных,
[01:21:02.720 --> 01:21:08.640]  количество таких чисел, количество таких перестановок, в точность равно модулю вот
[01:21:08.640 --> 01:21:15.240]  этого числа стиленга первого рода. Ну, чтобы доказать, доказать можно самое простое,
[01:21:15.240 --> 01:21:31.800]  просто написав рекурренту для вот этого и для вот того. Доказать это можно, доказав рекурренту.
[01:21:31.800 --> 01:21:40.760]  Так, сейчас тоже едем к шуму.
[01:22:01.800 --> 01:22:22.360]  Вот, значит, с такими начальными условиями, когда у меня k равно нулю, если, если s задать вот так вот
[01:22:22.360 --> 01:22:26.000]  и потом начать этот рекуррент на вот так, то, значит, с одной стороны можно легко показать,
[01:22:26.000 --> 01:22:30.520]  что вот это вот, вот в этом выражении, просто по индукции, если мы знаем, как выражается вот
[01:22:30.520 --> 01:22:35.960]  этот n-факторный момент через степень k, то n плюс 1 легко выражается, нужно просто там написать
[01:22:35.960 --> 01:22:39.680]  еще один множитель, раскрыть фиоскопки и получается, что там каждый коэффициент получается вот так вот.
[01:22:39.680 --> 01:22:47.080]  Ну, а база такая же. Здесь же с этими циклами можно то же самое сделать, значит, можно доказать
[01:22:47.080 --> 01:22:51.480]  по индукции, что вот эта вот формула, ну, если я модуль еще везде навешу, то эта же формула будет
[01:22:51.480 --> 01:22:56.520]  отображать число перестановок на n элементах с k циклами. То же самое, значит, если у вас есть
[01:22:56.520 --> 01:23:01.520]  формула, если у вас есть, ну, чтобы посчитать вот это, нужно, скажем, понять, где лежит этот
[01:23:01.520 --> 01:23:05.080]  плюс первый элемент, либо в отдельном цикле, либо в одном из предыдущих, и получается, в общем,
[01:23:05.080 --> 01:23:10.560]  такая же формула, если модуль навесить, будет то же самое. Ну, значит, мы поняли, ну, как бы,
[01:23:10.560 --> 01:23:15.640]  постулировали, что вот это вот число одинаковое, только здесь надо еще модуль навесить, ну, и за
[01:23:15.640 --> 01:23:20.680]  одно мы вывели, точнее, даже опять-таки постулировали рекурренту, которую можно доказать, которая нам
[01:23:20.680 --> 01:23:26.280]  позволяет находить все эти числа за квадрат. То есть, если, скажем, у меня есть, если моя задача
[01:23:26.280 --> 01:23:31.320]  это найти коэффициенты разложения n-ого факториального момента, нет, n-ого факториального момента через
[01:23:31.320 --> 01:23:36.480]  обычные степени, то я могу просто за n в квадрате написать вот эту формулу, заполнить табличку
[01:23:36.480 --> 01:23:44.920]  целиком, s и g, и вот эта вот последняя строчка, где будет там s, n, все нужные мне кашки, вот эти
[01:23:44.920 --> 01:23:47.880]  коэффициенты как раз будут то, что мне нужно. Ну, эта табличка заполняется просто сверху вниз.
[01:23:47.880 --> 01:23:57.240]  Получается, за квадрат мы можем это все найти. Так, ну, давайте тогда уже, поскольку времени совсем не
[01:23:57.240 --> 01:24:02.960]  остается, я скажу, что числа второго рода, числа стерны второго рода решает обратную задачу, они
[01:24:02.960 --> 01:24:16.840]  выражают x в степени n через сумму факториальных моментов, умножить на, вот здесь будет коэффициент,
[01:24:16.840 --> 01:24:23.160]  равный числу стерны второго рода, s большое nk. Вот это вот число стерны второго рода, то есть,
[01:24:23.160 --> 01:24:30.160]  ну, обратная задача, мне нужно, наоборот, x в n выразить через вот такие вот произведения по разным
[01:24:30.160 --> 01:24:34.920]  k. И здесь коэффициент перед каждым таким слагаемым будет как раз число стерны второго рода,
[01:24:34.920 --> 01:24:39.480]  которые, в общем, тоже как-то так считаются, там есть аналогичная рекуррента, которая позволяет
[01:24:39.480 --> 01:24:45.000]  за квадрат посчитать это значение. Так, ну, на этом тогда всего спасибо.
