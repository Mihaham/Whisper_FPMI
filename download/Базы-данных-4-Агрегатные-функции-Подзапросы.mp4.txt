[00:00.000 --> 00:09.280]  Лекция 4. Основы DML, агрегатные функции, сложенные запросы. Закончим наконец сегодня с DML,
[00:09.280 --> 00:17.040]  с вами развяжемся до конца и начнем основу проектирования баз данных. Немножко повторим,
[00:17.040 --> 00:26.160]  с чего закончили прошлую лекцию. Это этап выполнения запроса Select. У нас, как я уже
[00:26.160 --> 00:33.320]  говорил, запросы Select, хоть в принципе запросы SQL у нас максимально приближены к естественному
[00:33.320 --> 00:39.120]  языку, но с другой стороны они, тем не менее, не такие простые, как хотелось бы быть, как хотелось
[00:39.120 --> 00:46.560]  бы нам как пользователям, и их порядок выполнения, вот запросов именно Select, запросов к базе данных
[00:46.560 --> 00:54.800]  на выдачу каких-то конкретных данных из базы, он порядок выполнения, он такой немножко
[00:54.800 --> 00:59.040]  инвертированный, ну перепутанный скорее, даже не инвертированный. Как вы помните, у нас все
[00:59.040 --> 01:08.520]  начинается не с собственного утверждения Select, а с from и join. Потом идет where, group by, having,
[01:08.520 --> 01:15.360]  select только на этапе после соединения, фильтрация таблиц работает, потом уже,
[01:15.360 --> 01:22.200]  ну не фильтрация, а логическая какой-то выборки по условию. Потом идет сортировка и, соответственно,
[01:22.200 --> 01:30.880]  ограничение выдачи через лимит и offset. Картинку тоже эту вы видели на слайде предыдущем,
[01:30.880 --> 01:39.440]  предыдущей лекции, но опять же в детактических материалах, в детактических, прошу прощения,
[01:39.440 --> 01:48.080]  целях повторю еще раз, ее, ну честно признаюсь, картинка, она взята из общего доступа, довольно
[01:48.080 --> 01:54.960]  очень такая наглядная, с другой стороны, удобно показывающая, что происходит. Опять же, прошу
[01:54.960 --> 02:02.320]  обратить на этап выполнения group by и having. Как вы видите, левые столбцы, левые столбцы
[02:02.320 --> 02:12.400]  результирующей таблицы, которые получаются на этом этапе, они слиплись, соединились совместно в
[02:12.400 --> 02:19.640]  две группы. То, что, собственно, у нас происходит на этапе group by, значения, эквивалентные значения
[02:19.640 --> 02:29.120]  в различных строках, они по какому-то заданному нами атрибуту соединяются в некое такое одно,
[02:29.120 --> 02:33.440]  что ли, метазначение, такая мета-ячейка скорее даже появляется, значение у нас
[02:33.440 --> 02:43.760]  остается то же самое, и вот наглядно это хорошо видно. Здесь также я приведу вам SQL запрос для
[02:43.760 --> 02:48.840]  создания тестовой таблицы, которая у нас в этой лекции будет продолжать фигурировать и которая
[02:49.800 --> 02:56.440]  появилась еще в прошлой лекции. Там ничего сложного, просто чтобы, если кто-то захочет запустить
[02:56.440 --> 03:04.080]  код у себя на машине и как-то поиграться, уличить лектора в недобросовестности формулирования
[03:04.080 --> 03:13.320]  наглядных материалов. Так, хорошо, давайте посмотрим быстренько на агрегатные функции,
[03:13.320 --> 03:18.200]  агрегатные или агрегирующие, то есть это функции, в принципе, работающие похожим образом,
[03:18.200 --> 03:27.480]  как выражение groupBy, но единственно, если groupBy у нас просто склеивает ячейки по какому-то
[03:27.480 --> 03:34.120]  атрибуту в одну ячейку, оставляя значение исходное, но одинаковое для всех склеиваемых,
[03:34.120 --> 03:41.680]  соединяемых ячейек, то агрегатные функции делают иначе, они по какому-то атрибуту выполняют некое
[03:41.680 --> 03:51.120]  действие, заложенное, собственно, в их определение. На слайде написано это буквально немножко
[03:51.120 --> 03:56.320]  иным языком, в общем-то, это цитата из документации, агрегатная функция сводит множество входных
[03:56.320 --> 04:02.480]  значений к одному выходному, а также у нас определенные особенности по обработке налозначений,
[04:02.480 --> 04:06.280]  вот большинство агрегатных функций, они налозначение игнорируют. Ну, в принципе, это
[04:06.280 --> 04:13.120]  мы тоже с вами оговаривали в прошлый раз, даже, по-моему, в позапрошлый раз, для
[04:13.120 --> 04:25.280]  при рассмотрении троичной логики, но вот повторяем, чтобы не забыть. Основные функции, перечисленные,
[04:25.280 --> 04:31.680]  ну, как основные, наиболее часто употребимые, что ли, такие вот функции на уровне каких-то
[04:31.680 --> 04:36.240]  азов, которые нужно точно знать и представлять себе, они на слайде перечислены. Опять же, в
[04:36.240 --> 04:43.880]  документации по ссылкам из прошлой лекции можете посмотреть там, ну, или просто сами, в принципе,
[04:43.880 --> 04:51.000]  найти, это довольно несложно, на сайте Postgres Pro. Можете посмотреть таблички с полным переченем
[04:51.000 --> 04:59.920]  агрегатных функций, их ощутимо больше, но мы с вами ознакомимся вот только с такими,
[05:00.040 --> 05:05.160]  более, наверное, простыми и понятными, но в принципе их, повторюсь, сильно больше, там есть отдельные
[05:05.160 --> 05:11.240]  классы статистических агрегатных функций, то есть все это можно использовать, чтобы писать какие-то
[05:11.240 --> 05:16.960]  очень интересные запросы, получать какие-то очень интересные результаты с аналитической уже
[05:16.960 --> 05:23.320]  составляющей, а не просто вычислить количество срок в таблице или общую сумму. Краткое описание
[05:23.320 --> 05:30.280]  приведено на слайде. Давайте вслух я быстренько расскажу, что и как. Каунт со звездочкой, ну,
[05:30.280 --> 05:35.720]  вы уже, очевидно, с этим сталкивались не раз. Вы считаете просто количество входных строк,
[05:35.720 --> 05:42.360]  то бишь, строк в таблице. Результат, опять же, вот обратите внимание, в каждой функции указан
[05:42.360 --> 05:53.800]  результат. И вот в функциях после каунта в скобках приведены аргументы, это не значит,
[05:53.800 --> 05:58.440]  что там какие-то конкретные аргументы или их должен быть список, а имеется в виду, что просто
[05:58.440 --> 06:06.520]  в каунт мы можем прописать звездочку, специальный указатель, да, а в сам max, min, average мы должны
[06:06.520 --> 06:13.840]  написать как минимум ими столбца, если функции еще дополнительно каких-то значений аргументов не
[06:13.840 --> 06:21.240]  принимают. За дополнительными аргументами я вас отсылаю, опять же, к документации. Там есть
[06:21.240 --> 06:26.800]  определенные ситуации, где могут потребоваться, но по умолчанию, в принципе, нам сейчас вполне
[06:26.800 --> 06:37.760]  хватит того, что есть. Опять же, обратите внимание в описание, вычисляет сумму всех входных значений,
[06:37.760 --> 06:43.880]  отличных от null для всех функций, кроме каунта. Каунт, по умолчанию, у нас выдаст все строки,
[06:43.880 --> 06:51.480]  которые, по умолчанию, имеется в виду с аргументом специальным звездочкой, выдаст все строки в
[06:51.480 --> 06:59.560]  таблице, даже если одна из строк будет заполнена одними null. Вот примеры использования. Select
[06:59.560 --> 07:06.520]  count звездочка, считаем количество рядов, прошу прощения, количество строк, конечно же, ну,
[07:06.520 --> 07:16.880]  получаем 10, да, в общем-то, все довольно просто. Если мы посмотрим, теперь в агрегатная функция
[07:16.880 --> 07:25.080]  суммирования сам просуммируем все жалования, все жалования, которые платится каждому сотруднику,
[07:25.080 --> 07:32.920]  получаем, так, 500, 560 тысяч рублей, ну, получается это месячное очевидное жалование на, там,
[07:32.920 --> 07:44.040]  какой-то, какую-то совокупность подразделений фирмы, вот такой фонд оплаты труда. Можем посчитать
[07:44.040 --> 07:57.360]  в данном случае, найти, вернее, даже дату найма, и обратите внимание, у нас Maxmin принимает не только
[07:57.360 --> 08:07.760]  числовые значения, числовые типы данных, но и, в данном случае, тип данных здесь дает, ну, как бы,
[08:07.760 --> 08:13.640]  понятно, что, в принципе, он где-то внутренне трансформируется в число, в какой-то, там,
[08:13.640 --> 08:20.480]  какой-либо из систем, в зависимости от системы счисления, в зависимости от СУБД, и, ну,
[08:20.480 --> 08:25.760]  по сути дела, да, это вот в данном случае у нас Max все равно работает как такая численная функция
[08:25.760 --> 08:34.080]  для дейт, просто вот это вот косметическое представление дейта для пользователя, в первую
[08:34.080 --> 08:39.600]  очередь, хотя, да, для каких-то операций тоже дейт имеет свою специфику, как тип данных,
[08:39.600 --> 08:47.160]  но, тем не менее, просто к чему все это? К тому, что Max может принимать не только
[08:47.160 --> 08:56.880]  нативно числовые типы, может принимать еще и иные варианты типов данных подробнее, да,
[08:56.880 --> 09:01.840]  смотрите в спецификацию, ну, или просто можете попробовать на каких-то простеньких запросах.
[09:01.840 --> 09:09.880]  То же самое с MIN, соответственно, Max Date of Employment выдает нам дату наимов самого последнего,
[09:09.880 --> 09:17.120]  самого нового сотрудника, самого нового коллеги, MIN Date of Employment выдает дату наима самого
[09:17.120 --> 09:24.160]  первого сотрудника в подразделении некоем, ну, здесь совокупность подразделений, поэтому можно
[09:24.160 --> 09:29.040]  сказать, практически в фирме, да, если бы у нас вот фирма состояла из четырех подразделений и
[09:29.040 --> 09:38.560]  десяти человек. Average, ну, понятно, считает среднее значение, поскольку, как вы помните,
[09:38.560 --> 09:44.040]  сам у нас посчитала среднюю, вернее, общую сумму жалования, общий фонд оплаты труда как 560 тысяч,
[09:44.040 --> 09:52.080]  160 тысяч мы поделили на 10, получили 56 тысяч рублей, и, опять же, да, здесь у нас выходной тип
[09:52.080 --> 10:05.920]  числовое значение Numeric, и здесь количество налей там, на самом деле, даже не влезло в картинку,
[10:05.920 --> 10:12.120]  там какое-то, что-то около десятка, если не ошибаюсь, мы можем это, конечно, привести к
[10:12.120 --> 10:21.080]  какому-то иному типу, чтобы получился покрасивее результат. Ну, напрямую получается у нас такой
[10:21.080 --> 10:27.880]  тип данных, надо иметь, наверное, это в виду для каких-то, да, вот, опять же, это тип с повышенной
[10:27.880 --> 10:34.440]  точностью, это не просто float, это именно тип, который позволяет избежать ошибок при проекции,
[10:34.440 --> 10:45.520]  связанных с проекцией, дистичной системы счисления на двоичную, и там повышенная,
[10:45.520 --> 10:50.880]  соответственно, да, повторюсь, точность обеспечивается при вычислениях. Хорошо,
[10:50.880 --> 10:57.240]  Select Group By агрегатные функции. Когда в запросе присутствует предложение Group By или какая-либо
[10:57.240 --> 11:01.060]  агрегатная функция, выражения в списке Select, по общему правилу, не могут обращаться к
[11:01.060 --> 11:04.920]  негруппируемым столбцам, так как иначе в негруппируемом столбце нужно было бы вернуть
[11:04.920 --> 11:10.200]  более одного возможного значения. Агрегатные функции, если они используются, вычисляются по всем
[11:10.200 --> 11:13.840]  строкам, составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы.
[11:13.840 --> 11:21.720]  Теперь, может быть, постараюсь более простыми словами. Опять, как мы с вами говорили, на пальцах
[11:21.720 --> 11:29.760]  у нас Group By слепляет строки, соединяет их, а вернее, даже не строки, а конкретные значения по
[11:29.760 --> 11:36.320]  атрибутам. Там понятно, что мы можем в Group By запихнуть много перечислений столбцов, но для
[11:36.320 --> 11:42.440]  простоты возьмем один столбец. Получается, что если мы Group By используем, компонуем по какому-то
[11:42.440 --> 11:48.240]  атрибуту одинаковые значения в группе, буквально, повторюсь, просто склеим одинаковые значения в
[11:48.240 --> 11:55.000]  одну ячейку, то мы, если будем обращаться к иным атрибутам, которые у нас не склеились, которые у
[11:55.000 --> 12:01.880]  нас все еще представляются в виде отдельных записей, отдельных строк таблицы, если мы к ним
[12:01.880 --> 12:07.880]  будем обращаться, у нас просто запрос не будет иметь какого-то содержательного смысла. Мы не
[12:07.880 --> 12:14.840]  сможем специфицировать для не склеенных ячеек, какую мы хотим ячеек получить в ответ. В общем-то,
[12:14.840 --> 12:21.000]  довольно, наверное, мне кажется, просто, если над этим немножко подумать, поразмышлять, как мы
[12:21.000 --> 12:32.880]  можем к множественному значению получить конкретный ответ, если мы пытаемся взять из неопределенного
[12:32.880 --> 12:44.280]  множества значений, то есть, грубо говоря, не знаю, как мы можем, ну, такой, может быть,
[12:44.280 --> 12:50.680]  немножко пример, уходящий в сторону, как мы можем выбрать конкретно элементарную частицу,
[12:50.680 --> 12:56.640]  если они ничем не отличаются. Какую-то мы можем выбрать, но она будет торжественна любой другой,
[12:56.640 --> 13:01.760]  мы как бы специфицировать ее не можем в принципе, силы физических ограничений. Вот примерно здесь
[13:01.760 --> 13:06.680]  то же самое происходит, но ограничения логические, по крайней мере. Понятно, что каждая строка,
[13:06.680 --> 13:12.560]  каждый там элемент, они на диске записаны определенным образом, каждый элемент кортежа
[13:12.560 --> 13:17.240]  в любом отношении определенным образом записан, имеет свой конкретный адрес, но логически у нас
[13:17.240 --> 13:28.200]  они становятся не конкретны для запроса. Так, и соответственно, мы к таким столбцам обращаться
[13:28.200 --> 13:33.120]  не можем, а по грубой, по сгруппированным столбцам можем использовать агрегатные функции. Давайте
[13:33.120 --> 13:42.720]  посмотрим. Давайте посмотрим пример у нас, пример использования агрегатной функции и
[13:42.720 --> 13:54.560]  группирования. Мы здесь хотим получить, ну, сгруппируем по департаментам, так, мы хотим, да, мы хотим,
[13:54.880 --> 14:05.360]  хотим из нашей таблицы с данными по нашим сотрудникам, сгруппируем эти данные по департаментам
[14:05.360 --> 14:10.480]  и смотрим, какое среднее жалование у нас для каждого департамента получается. Опять же,
[14:10.480 --> 14:17.240]  обратите внимание, кто, может быть, еще там на семинарах не знаком, вот мы можем привести число,
[14:17.240 --> 14:23.120]  наше результирующее, результат вычисления среднего значения к какому-то более, что ли,
[14:23.120 --> 14:28.280]  пристойному виду, скажем так. В данном случае мы используем функцию round, округление мы можем
[14:28.280 --> 14:34.880]  задать на количество знаков после запятой, мы могли бы сделать приведение типа для нашего значения,
[14:34.880 --> 14:41.640]  могли бы его привести, например, к типу integer, причем это тоже было бы в данном случае округлением,
[14:41.640 --> 14:50.640]  а не отбрасыванием, как, ну, не знаю, C++, такой банальный пример приведу. Будет тоже округлением
[14:50.640 --> 14:57.160]  использования приведения типа, ну, можно использовать округление, опять же, как вариант,
[14:57.160 --> 15:08.880]  а явное такое. И пример отработки груба и average опять же на слайде, ну, наверное, пояснять,
[15:08.880 --> 15:13.080]  мне кажется, здесь, в принципе, ничего не надо, ну как, давайте, давайте все-таки, окей, давайте
[15:13.080 --> 15:20.160]  чуть подробнее, вот мы склеиваем первую строку, пятую и девятую вместе, у нас получается 50,
[15:21.120 --> 15:32.200]  значение в столбце salary, мы причем salary не можем, мы причем к salary при этом не смогли бы
[15:32.200 --> 15:38.280]  обратиться, не используя агрегатную функцию, у нас был, наша СОБД выдала бы нам ошибку, чтобы
[15:38.280 --> 15:43.000]  обратиться к salary, мы используем, ну, чтобы сделать запрос логически осмысленным, каким-то
[15:43.000 --> 15:48.600]  содержательным, мы используем агрегатную функцию на столбце salary, на атрибуте, и получаем,
[15:48.600 --> 15:54.320]  соответственно, тоже склеенное такое результирующее агрегатное значение для
[15:54.320 --> 16:07.200]  нашей группы в атрибуте department. Хорошо, давайте посмотрим на подзапросы, в принципе, мы уже
[16:07.200 --> 16:14.840]  изучили, прошли все, что нужно знать о селект-запросе, как таковому подзапросу, такой же селект-запрос,
[16:14.840 --> 16:24.040]  возженный внутрь другого селект-запроса, вот так вот, грубо говоря, отделяется он скобками,
[16:24.040 --> 16:32.840]  внутри скобок пишется обычно селект-запрос. Подзапросы бывают нескольких видов, скалярные и
[16:32.840 --> 16:39.080]  нескалярные, можно их, вернее, скажем так, есть даже как минимум два основания деления для подзапросов,
[16:39.080 --> 16:51.640]  первое это скалярные и нескалярные, и второе это коррелирующие и некоррелирующие, и что это такое,
[16:51.640 --> 17:04.480]  вот скалярный подзапрос, так, прошу прощения, да, скалярный подзапрос у нас выдает, мы уже об этом
[17:04.480 --> 17:09.760]  с вами говорили, скалярный подзапрос, ну и в принципе даже запрос может быть тоже скалярным,
[17:09.760 --> 17:16.040]  он выдаёт у нас одно единственное значение, одну, по сути дела, ячейку в таблице, нескалярный
[17:16.040 --> 17:23.880]  подзапрос выдаёт множество значений, как правило, когда говорят о нескалярных запросах, их, во-первых,
[17:23.880 --> 17:28.960]  так не называют, во-вторых, просто говорят запросы, во-вторых, подразумевается, что если запрос не
[17:28.960 --> 17:34.200]  скалярный, то он, как правило, выдаёт не просто строку, одну, но строку из нескольких атрибутов,
[17:34.200 --> 17:39.320]  а именно несколько строк. И даже более того, конкретно для того, чтобы использовать некоторые
[17:39.320 --> 17:44.840]  предикаты со скалярными подзапросами, с нескалярными, прошу прощения, речь конкретно для них явно
[17:44.840 --> 17:54.320]  идёт о том, что выдаётся значение нескольких строк в одном столбце. Подзапросы не коррелирующие
[17:54.320 --> 18:01.560]  и коррелирующие, что это значит? То есть у нас подзапрос может быть связан с внешним запросом тем,
[18:01.560 --> 18:06.840]  что он ссылается внутри себя на данные внешней таблицы. Как это происходит, сейчас мы с вами
[18:06.840 --> 18:16.680]  посмотрим. Давайте ещё немножко скажем о том, что важно иметь в виду при связанном коррелированном
[18:16.680 --> 18:21.440]  или коррелирующем подзапросе. Важно понимать, что такой запрос выполняется для каждой строки,
[18:21.440 --> 18:30.920]  обрабатываемой во внешнем запросе. На практике оптимизация может быть определённой внутри
[18:31.400 --> 18:41.440]  СОБД, её средствами, но в теории, грубо говоря, по стандарту нужно иметь в виду, что у нас,
[18:41.440 --> 18:50.000]  по сути дела, получается как вложенный цикл за счёт связанного подзапроса. Ну, соответственно,
[18:50.000 --> 18:55.120]  что это значит? Это значит, как минимум, в теории, что время потенциально может приобретать
[18:55.120 --> 19:07.920]  квадратичное отклонение от нормы. Мы можем увеличить запрос, квадратично более ресурсоёмким
[19:07.920 --> 19:13.920]  его сделать. Можно использовать подзапросами определённые предикаты. Вот они на слайде
[19:13.920 --> 19:21.120]  приведены. Exists in, not in, any, some и all. Any, some сразу говорит, что это в принципе синонимичные
[19:21.280 --> 19:28.880]  конструкции. Можно any, можно сам использовать. Понятно, вот последние два, последние две части
[19:28.880 --> 19:36.800]  вот этой классификации. Это, в общем-то, аналоги логических кванторов. Существование,
[19:36.800 --> 19:45.240]  всеобщенность. Exists, хотя, казалось бы, похож на тоже, на квантор, но немножко иначе работает.
[19:45.240 --> 19:50.640]  In, not in. Вот, наверное, самое простое. То есть, когда у нас есть какой-то подзапрос,
[19:50.640 --> 19:58.120]  выдаёт он список значений, и мы просто проверяем на то, входит ли наше значение из внешнего
[19:58.120 --> 20:03.160]  запроса, из какой-то внешней таблицы, из таблицы во внешнем запросе, в тот список значений,
[20:03.160 --> 20:13.800]  который нам выдал подзапрос в итоге. Что ещё можно, наверное, сказать и важно для вас понимать.
[20:13.800 --> 20:19.920]  Некоторые вот детали, в принципе, это цитаты из документации, поэтому можете не то, что до слайда
[20:19.920 --> 20:25.960]  заучивать, можно это, в принципе, найти и в собой документация по постгрессу, но вот такие реперные
[20:25.960 --> 20:33.680]  может быть точки. На слайдах они будут, ознакомьтесь с ними, пожалуйста, имейте их в виду. Что здесь
[20:33.680 --> 20:39.760]  важного? Выполнив запрос Exists, у нас система проверяет, возвращает ли он строки в результате.
[20:39.760 --> 20:44.440]  Если он возвращает минимум одну строку, результат Exists будет true, если не возвращает ни одной, false.
[20:44.440 --> 20:51.640]  Запрос может выполняться не полностью, и как и остальные подзапросы, кстати говоря, это важный
[20:51.640 --> 21:03.000]  момент, потому что, соответственно, у нас, если вы рассчитываете на пробегание, условно, каким-то
[21:03.000 --> 21:12.440]  курсором по всем данным, которые у нас под запрос должны были бы попасть, то этого может не быть.
[21:12.440 --> 21:25.080]  Здесь аналогия такая, наверное, напрашивается с работой этих логических операторов. Когда мы там
[21:25.080 --> 21:35.040]  OR или AND используем для некого ускорения, когда мы знаем, что у нас может быть вычислено только
[21:35.040 --> 21:42.880]  в OR одно значение, если оно будет истинно, то этого будет достаточно, чтобы вычислить значение всего
[21:42.880 --> 21:51.080]  выражения. Примерно здесь то же самое. Если у нас одна строка хотя бы возвращена, то уже будет true.
[21:51.080 --> 21:56.640]  Поэтому, грубо говоря, в принципе это может быть оптимизировано внутри так, что у нас Exists
[21:56.640 --> 22:04.200]  будет возвращать просто одну строку и все. Грубо говоря, повторюсь, это не значит, что Exists
[22:04.200 --> 22:15.080]  всегда отрабатывает только по одной строке. При использовании предиката еще Exists нас не
[22:15.080 --> 22:22.880]  интересует значение, возвращаемое, как правило, не интересует. И 10 исключений, опять же. Можно указать
[22:22.880 --> 22:33.400]  после Select произвольные значения вплоть до Select false или Select null. И запрос все равно отработает,
[22:33.400 --> 22:45.520]  потому что как таковой Select не будет по сути что ли отрабатываться. Почти никогда не будет
[22:45.520 --> 22:53.120]  отрабатываться, но есть исключения, повторюсь. In, not in здесь, в принципе, все тоже, наверное,
[22:53.120 --> 23:00.240]  довольно просто. Может быть даже интуитивно просто проверка на вхождение значения во множество
[23:00.240 --> 23:05.520]  значений. При этом множество значений у нас возвращается под запросом. И вот у нас, смотрите,
[23:05.520 --> 23:11.520]  ограничение здесь уже есть явное, что в правой стороне этого выражения в скобках задается
[23:11.520 --> 23:19.240]  запрос, который должен возвращать ровно один столбец. Но именно столбец и в принципе здесь
[23:19.240 --> 23:25.040]  может быть скалярное выражение, да, но если это не скалярное выражение, не скалярный результат,
[23:25.040 --> 23:35.360]  то один столбец, но множество строк будет в столбце. И возможность возвратить одну строку с
[23:35.360 --> 23:40.920]  несколькими атрибутами не допускается. Вычисленное значение левого выражения сравнивается со
[23:40.920 --> 23:47.280]  значениями во всех строках, возвращенных под запросом. Результатом своего выражения in будет
[23:47.280 --> 23:53.920]  true, если строка с таким значением находится и false в противном случае. Not in работает зеркально,
[23:53.920 --> 24:02.840]  но наоборот, или зеркально наоборот, но здесь true будет, если находятся только несовпадающие
[24:02.840 --> 24:11.760]  строки. То есть если хотя бы одна строка совпала, то результатом уже будет false для not in. Также
[24:11.760 --> 24:18.360]  для null определенные особенности, но об этом мы тоже с вами в принципе говорили и затрагивали
[24:18.360 --> 24:25.760]  эту тему для проечной логики, когда разбирали как действуют операторы. И запрос может выполняться
[24:25.760 --> 24:41.480]  не полностью. Опять же. Да, any sum. Повторюсь, это синонимичные конструкции. Опять же, похоже это
[24:41.480 --> 24:46.400]  на кванторы всеобщенности. Вернее, существование в данном случае, на квантор существования,
[24:46.400 --> 24:54.640]  конечно же, также у нас ровно один столбец должен возвращать под запрос, и вычисленное значение
[24:54.640 --> 25:01.040]  левого выражения сравнивается со значением в каждой строке результата под запрос, с помощью заданного
[25:01.040 --> 25:08.560]  оператора. То есть у нас еще выражение any sum и под запрос, а между ними еще и дополнительно какой-то
[25:08.560 --> 25:16.080]  оператор. Например, какой-то логический оператор, который у нас true или false будет выдавать. Сейчас
[25:16.080 --> 25:22.960]  посмотрим уже на примерах. Пока немножко скучный, может быть, и уж точно сухой из теории, но,
[25:22.960 --> 25:31.960]  по крайней мере, чтобы у вас было это на слуху, я думаю, что нужно это проговорить. Опять же,
[25:31.960 --> 25:38.160]  синтаксис выражения оператора all и под запрос. То же самое, что с any sum,
[25:38.160 --> 25:43.280]  та же синтаксическая конструкция. Тоже допустим оператор между, ну, даже обязательный оператор
[25:43.280 --> 25:52.440]  между выражением и предикатом all под запрос возвращает ровно один столбец. Из интересного,
[25:52.440 --> 26:02.160]  наверное, конструкция not in равнозначно такой вот записи, когда не равно all. И тоже, опять же,
[26:02.160 --> 26:10.760]  запрос может выполняться не полностью. Хотя, да, казалось бы, all, но исходя из внутреннего устройства
[26:11.360 --> 26:15.400]  в данном случае Postgres, поскольку это именно разъяснение документации Postgres,
[26:15.400 --> 26:23.480]  получается, что нужно быть с этим аккуратным. Это не значит, что у нас будет какой-то логически
[26:23.480 --> 26:27.600]  некорректный результат. Это значит, что у нас нужно аккуратно обращаться с под запросом внутри,
[26:27.600 --> 26:36.480]  который будет ссылаться на какие-то генераторы последовательности, например. И вот с такими
[26:37.160 --> 26:41.360]  вещами более продвинутыми там могут быть определенные проблемы за счет того,
[26:41.360 --> 26:49.680]  что вычисления происходят в момент выполнения, и одни правила накладываются на другие, скажем,
[26:49.680 --> 26:56.920]  вот так вот, общего. И поэтому просто не рекомендуется закладываться на стопроцентное
[26:56.920 --> 27:02.000]  вычисление отложенных каких-то функций, которые могут фигурировать под запросе.
[27:02.000 --> 27:10.000]  Ну, это более сложные вещи, мы их касаться в принципе на курсе не будем, но вот просто имейте
[27:10.000 --> 27:17.040]  в виду, что такое может быть. Так, Select под запрос скалярный как-то вообще выглядит,
[27:17.040 --> 27:21.360]  что происходит. Результат скалярного произведения под запрос единственное значение,
[27:21.360 --> 27:25.920]  и вот будет представлена единственная запись. Здесь, конечно, это все искусственно,
[27:25.920 --> 27:30.880]  это простые примеры, и они за счет этого... Примеры на простом материале не за счет этого,
[27:30.880 --> 27:39.440]  конечно, искусственно выглядят, но зато, я надеюсь, более, может быть, наглядно будет за счет
[27:39.440 --> 27:45.520]  простоты обращения к единственной таблице. Вот под запрос у нас внутренний Select мы здесь
[27:45.520 --> 27:50.440]  однозначно установили по атрибуту имя, то у нас имя должно быть Ольга Кузнецова. У нас только
[27:50.440 --> 27:57.120]  одна запись такая в нашем отношении, поэтому у нас под запрос будет скалярным. Скалярным он
[27:57.120 --> 28:04.880]  становится, потому что мы выбираем только один атрибут с employee ID, и дальше уже по
[28:04.880 --> 28:12.800]  эквивалентности находим жалование Ольги Кузнецовой за работную плату. Конечно,
[28:12.800 --> 28:20.280]  можно было сделать проще, можно было бы просто employee ID, или можно было не employee ID поставить,
[28:20.280 --> 28:25.600]  а поставить name Ольги Кузнецовой. Ну вот, повторюсь, это намеренный искусственный запрос для
[28:25.680 --> 28:33.720]  большей наглядности, какой-то дидактичности, что здесь, по сути дела, нам главное понять,
[28:33.720 --> 28:40.920]  что вот вычисляется единственная ячейка, единственное значение. Под запрос не скалярный,
[28:40.920 --> 28:46.680]  предикат IN, результат не скалярного под запроса множество значений, и у нас вот здесь прям
[28:46.680 --> 28:55.160]  наверчено-наверчено мы рассчитываем среднюю заработную плату для тех сотрудников, у которых
[28:55.160 --> 29:03.640]  средний возраст, вернее, у которых возраст выше среднего по условной нашей компании.
[29:03.640 --> 29:12.880]  Вычисляем, опять же, я не призываю вас писать так, да, это просто для наглядности, вычисляем
[29:12.880 --> 29:18.800]  средний возраст, после этого вычисляем множество значений, которые у нас будут
[29:18.800 --> 29:25.480]  больше среднего возраста. Вот у нас показано всё это поэтапно, на слайде справа. Вычисляем
[29:25.480 --> 29:32.120]  средний возраст, это самый глубокий селект, потом селект второго уровня, ну следующего,
[29:32.120 --> 29:37.380]  до следующего уровня вычисляет у нас множество значений, которые больше 35 лет,
[29:37.380 --> 29:43.220]  и дальше мы уже просто высчитываем средние жалования для этой группы сотрудников.
[29:43.220 --> 29:50.020]  Здесь вот у нас опять же синтаксис приведения типов, обратите внимание, и на самом деле,
[29:50.020 --> 29:55.460]  если бы у нас было не приведено, тип бы не был приведен к целочисленному значению,
[29:55.460 --> 30:03.700]  у нас здесь была бы шестерка в периоде. И повторюсь, у нас приведение отрабатывает,
[30:03.700 --> 30:11.300]  по сути дела, в данном случае как округление, а не как отбрасывание чисел после разделителя,
[30:11.300 --> 30:19.940]  да, после запятой нашей. Exist, выбираем всех сотрудников, работающих в департаменте IT. Вот
[30:19.940 --> 30:25.820]  таким вот образом замысловатым мы это делаем. Что здесь, на что важно обратить, у нас запрос
[30:25.820 --> 30:37.820]  не скалярный, в чем это выражается. Вот у нас ссылки на внешнюю таблицу из конструкции WHERE,
[30:37.820 --> 30:48.060]  T1.Department равно IT. Вот T1 мы качество псевдонима использовали при объявлении таблицы,
[30:48.060 --> 30:53.900]  при указании таблицы в конструкции FROM, и T2 мы псевдоним используем для той же самой таблицы,
[30:53.900 --> 31:04.180]  но для того, чтобы явно нам делать пересыливание, явно ссылаться на таблицу хоть одну и ту же,
[31:04.180 --> 31:08.820]  но тем не менее, поскольку у нас, по сути дела, будет прохождение по одной таблице дважды,
[31:08.820 --> 31:14.580]  сначала мы проходимся во внутреннем цикле по ней, а потом еще и во внешнем цикле. Мы,
[31:14.580 --> 31:21.940]  соответственно, в разные переменные, грубо говоря, загоняем нашу таблицу. У нас во внутреннем
[31:21.940 --> 31:30.060]  подзапросе для каждой строки из внешнего запроса будет отрабатываться вот это условие
[31:30.060 --> 31:37.620]  логическое. И что здесь важно понимать? Важно, наверное, вот что. Если мы, вот здесь обратите,
[31:37.620 --> 31:45.820]  у WHERE у нас T1-департамент, из внешней таблицы департамент должен быть IT, и из внутренней
[31:45.820 --> 31:51.540]  таблицы департамент должен быть IT. Если мы уберем значение для внешней таблицы,
[31:51.540 --> 32:00.820]  вот скажем, казалось бы, зачем нам именно совпадение для того, чтобы найти всех сотрудников IT-департамента,
[32:00.820 --> 32:05.940]  давайте просто во внутреннем запросе сделаем SELECT, найдем все департаменты, где у нас будет IT,
[32:05.940 --> 32:11.100]  и замечательно. И, наверное, вот так у нас как-то отработает. Нет, ребят, не отработает,
[32:11.100 --> 32:18.620]  потому что Exist у нас возвращает true, ну, более высотачение, true или false для выражения под
[32:18.620 --> 32:23.140]  запроса. Поэтому здесь у нас, да, у нас здесь будет действительно только там три наших строки,
[32:23.140 --> 32:32.300]  первая, пятая и девятая в подзапросе, и Exist выдаст у нас true, потому что внутри под запрос
[32:32.300 --> 32:38.580]  нашлись строчки. Но поскольку у нас нет никакого ограничения внутри под запроса, у нас все,
[32:38.580 --> 32:46.740]  у нас вот это вот WHERE-условие будет всегда истинно для всех строк из таблицы new employees,
[32:46.740 --> 32:50.980]  поэтому у нас все сотрудники попадут в результирующий запрос, хотя мы, вроде бы,
[32:50.980 --> 32:59.380]  казалось, какое-то условие даже поставили. Нам нужно именно условие, что внутри под запроса
[32:59.380 --> 33:06.020]  для каждой строки из внешнего запроса будет отрабатывать логическая проверка. Если этого
[33:06.020 --> 33:21.980]  не будет, вот, повторюсь, будет такой результат. Что мы теперь делаем? Теперь мы пробуем
[33:21.980 --> 33:29.180]  нисколерный запрос с квантором существования. Что мы хотим? Мы, по сути, в данном случае
[33:29.180 --> 33:37.540]  исключаем работников с минимальным жалованием. Как это работает? Мы в подзапросе нашем Any,
[33:37.540 --> 33:46.420]  мы выводим все жалования по столбе с заработной платой по всем сотрудникам, и мы смотрим для
[33:46.420 --> 33:53.260]  каждого сотрудника, для каждого сотрудника его заработную плату, и указываем, что она должна
[33:53.260 --> 34:01.180]  быть больше любой другой зарплаты из нашего подзапроса. Поскольку у нас минимальная плата
[34:01.180 --> 34:09.580]  это 50 тысяч рублей для целого ряда сотрудников, то получается, что те сотрудники, которые ее
[34:09.580 --> 34:15.380]  получают, они не попадают в наш запрос, потому что у них вот это условие не отрабатывает. Их 50
[34:15.380 --> 34:22.740]  тысяч рублей заработной платы не является больше ни одной строки, ни одного результата,
[34:23.220 --> 34:29.540]  ни одной другой заработной платы из вот этого столбца. Поэтому у нас Any не отрабатывает для них,
[34:29.540 --> 34:36.620]  отрабатывает для 60 тысяч рублей, потому что есть строки, которые меньше 60, это вот 7, 8, 9, 10,
[34:36.620 --> 34:42.260]  отрабатывает, очевидно, для 70 тысяч рублей. Потому что для 70 тысяч рублей, да, это все остальные,
[34:42.260 --> 34:49.500]  у нас только два значения 70, это 3 и 5. Все остальные строки со 2 по 10, кроме 3 и 5, они меньше 70,
[34:49.500 --> 34:57.580]  они тоже соответственно валидируют нам вот это вот условие. Так, выберем работников с максимальной
[34:57.580 --> 35:02.420]  зарплатой. То есть здесь мы до этого откидывали с минимальным жалованием, а теперь давайте попробуем
[35:02.420 --> 35:06.900]  выбрать с максимальной зарплатой. Но вот кажется, кажется, что, наверное, мы могли бы использовать
[35:06.900 --> 35:12.900]  квантор всеобщенности, использовать All. Что бы у нас получилось? У нас бы получилось,
[35:12.900 --> 35:23.060]  что буквально, да, вот как это можно прочитать, что для всех, для всех тех результатов, для всех
[35:23.060 --> 35:28.900]  тех объемов заработной платы, размеров заработной платы, где заработная плата конкретного сотрудника
[35:28.900 --> 35:35.580]  больше любой другой заработной платы в таблице, да. Но так вот, косноязычно по-русски это звучит,
[35:35.580 --> 35:41.300]  к сожалению. Казалось бы, вроде бы, должен получиться нормальный результат, но нет,
[35:41.300 --> 35:46.700]  не получится, потому что на самом деле у нас условие вот это некорректно сформулировано,
[35:46.700 --> 35:54.420]  потому что заработная плата в 70 тысяч рублей не больше всех остальных заработных плат. То есть
[35:54.420 --> 36:01.100]  она больше 50, больше 60, но вот те же 70 тысяч, они у нас попадут в подзапрос, будут в промежуточной
[36:01.100 --> 36:08.220]  результирующей таблице, где будет все вот эти 10 значений. И на этапе сравнения 70 тысяч рублей
[36:08.220 --> 36:18.460]  с 70 тысячами рублями у нас оператор больше не выдаст нам значение истины. А если мы поставим
[36:18.460 --> 36:26.340]  больше или равно, то у нас все получится, потому что как раз по равенству у нас будет истинное
[36:26.340 --> 36:33.700]  значение при сравнении 70 с 70. Почему 50 при этом не попадет в результат, потому что у нас 50,
[36:33.700 --> 36:39.460]  конечно, равно 50, но у нас 50 не больше иных значений, не больше 60, не больше 70.
[36:39.460 --> 36:54.220]  Ну вот так. Вот на этом у нас, в принципе, все с подзапросами в общем виде, с агрегатными
[36:54.220 --> 37:07.860]  функциями. Вопрос в чате. Да, ребят, скалярды очень, смотрите, все довольно тривиально.
[37:09.860 --> 37:15.660]  Вот давайте здесь посмотрим подскалярдный запрос. То есть у нас скалярдный запрос это
[37:15.660 --> 37:22.020]  буквально одна ячейка. Если у нас на выходе одна ячейка, не одна ячейка там в каждом столбце,
[37:22.340 --> 37:30.340]  а именно одна ячейка в одном столбце, то это скалярдный запрос. Ну подзапрос, если говорить в контексте
[37:30.340 --> 37:36.140]  темы подзапросов. Вот скалярдный результат, вот скалярдный результат, вот это уже не скалярдный
[37:36.140 --> 37:48.580]  результат. Для чего это нужно? Для того, чтобы нам по классификации раскидывать, как у нас
[37:48.580 --> 37:54.460]  функционируют те или иные предикаты, которые мы можем использовать, те или иные конструкции.
[37:54.460 --> 38:01.700]  Ну если со скалярдным подзапросом здесь, наверное, нет какой-то явной сейчас подоплеки. Ну там,
[38:01.700 --> 38:08.300]  правда, есть у вас есть точно в семинарах табличка, в каких местах можно какие подзапросы использовать.
[38:08.300 --> 38:15.580]  Вот для этого классификация эффективна. А с точки зрения скалярдной и не скалярной,
[38:15.580 --> 38:24.580]  а с точки зрения того, что мы прямо сейчас здесь видим, запросы коррелирующие и некоррелирующие,
[38:24.580 --> 38:32.340]  здесь эта классификация имеет смысл для того, чтобы нам понимать, как у нас будет, по крайней
[38:32.340 --> 38:40.060]  мере, по стандарту отрабатывать SQL-запрос. По стандарту связный подзапрос, то есть ссылающийся
[38:40.060 --> 38:47.900]  на внешнюю, на таблицу из внешнего запроса, будет отрабатывать как вложенный цикл. Соответственно,
[38:47.900 --> 38:57.100]  что у нас происходит со временем выполнения? Оно возводится в квадрат. Вот цель классификации
[38:57.100 --> 39:01.580]  такова. Цель классификации скалярды и не скалярды, повторюсь, где можно использовать,
[39:01.580 --> 39:10.060]  где нельзя. У вас в семинарах есть прям большая красивая табличка. Ну давайте,
[39:10.060 --> 39:17.420]  наверное, я ее вставлю в лекциях, слайд просто добавлю, чтобы у вас тоже было для слайдов под
[39:17.420 --> 39:24.460]  рукой, все в одном месте. Но, в принципе, кажется, что это, наверное, как-то, знаете,
[39:24.460 --> 39:30.820]  так даже может быть полуинтуитивно. Просто попробуйте, потренируйтесь на различных
[39:30.820 --> 39:36.820]  подзапросах, в принципе, вариантов тренировок множества. Опять же отсылаю у вас тестовые базы
[39:36.820 --> 39:45.660]  данных на сайте PostgresPro, в их разделе «Обучение». На целый гигабайт базы данных можно поиграться,
[39:45.660 --> 39:52.220]  посмотреть, как что будет отрабатывать и построить какие-нибудь интересные, посмотреть на какие-то
[39:52.220 --> 40:01.420]  интересные поднагодные данные в виде выдачи планировщика. Макс и Мин, в последних двух
[40:01.420 --> 40:15.500]  примерах это вы имеете в виду All и Any, видимо. Или вы имеете в виду, ну да, получается,
[40:15.500 --> 40:24.300]  All и Any. Да, в принципе, можно. Единственное, смотрите, вот здесь, когда мы хотим найти
[40:24.300 --> 40:29.740]  работников с максимальной зарплатой, мы можем сказать просто salary больше и равно какой-то
[40:29.740 --> 40:39.180]  вот max и там вычислить максимальное значение. Опять же, там будет max, максимальное значение
[40:39.180 --> 40:44.660]  внутри телек запроса, внутри подзапроса. Мы можем использовать, да, безусловно. И мы получим,
[40:44.660 --> 40:50.660]  в принципе, такой же результат. Вот здесь, вот здесь нам нужно будет переделывать запрос,
[40:50.660 --> 40:58.220]  чтобы исключить работников с минимальным жалованием. Хотя нет, вы знаете, да, здесь тоже, в принципе,
[40:58.220 --> 41:07.540]  можно. Ну, повторюсь, в данном случае, наверное, вот такая избыточность SQL прям видна очень ярко,
[41:07.540 --> 41:13.180]  потому что намеренно упрощенный пример, чтобы было вот так на пальцах понятно, что происходит.
[41:13.180 --> 41:20.460]  В действительности, конечно, это не всегда верно. Просто у нас здесь числовые, по сути дела,
[41:20.460 --> 41:30.020]  сравнения. Больше-меньше. Ну, в принципе, больше-меньше и будет, да, с числами. Но, в общем случае,
[41:30.020 --> 41:38.220]  это будет все-таки не всегда equivalent. Так, хорошо. В общем, мы с вами разделались наконец-то
[41:38.220 --> 41:45.340]  в Data Manipulation Language с общими его азами и основами. Дальше посмотрим с вами сейчас на основу
[41:45.340 --> 41:50.820]  проектирования баз данных, сколько успеем. Продолжим эту тему уже, видимо, на следующем занятии.
[41:50.820 --> 41:59.580]  Ну, да, не растягиваю удовольствие. Собственно, давайте с вами продолжим. Что такое проектирование
[41:59.580 --> 42:07.540]  баз данных? Это процесс создания детализированной модели данных, базы данных, а также необходимой
[42:07.860 --> 42:15.060]  ограничении целостности. Про модели данных мы с вами, в принципе, говорили раньше. Так, вопрос в
[42:15.060 --> 42:22.220]  чате ищем. О, слушайте, но это зависит. Вопрос, как можно сооптимизировать запрос, чтобы высчитывать
[42:22.220 --> 42:26.820]  каждый раз новый подзапрос. Это зависит от конкретного запроса. Вот так вот, в общем случае,
[42:26.820 --> 42:33.100]  я бы не стал давать какой-то рекомендации. Я бы вам единственно порекомендовал попробовать
[42:33.100 --> 42:43.460]  посмотреть, что происходит через планировщик, посмотреть вот методами EXPLAIN. Ну, мы будем об
[42:43.460 --> 42:47.580]  этом еще говорить с вами чуть попозже. Можете прямо сейчас попробовать просто документацию
[42:47.580 --> 42:53.820]  почитать. Там несложно, в большом счете. Посмотреть, что происходит внутри при ваших запросах,
[42:53.820 --> 43:01.300]  в конкретных реальных запросах происходит ли реально итерация по вложенному циклу. Потому что
[43:01.300 --> 43:05.020]  может быть конкретно в вашей ситуации, если это конкретный пример, а не абстрактный вопрос,
[43:05.020 --> 43:14.900]  там не будет вычисляться по стандарту, как положено, каждая строка из внешнего запроса,
[43:14.900 --> 43:21.420]  сравниваться с каждой строкой внутреннего. Повторюсь, вообще, я бы не стал просто отвечать,
[43:21.420 --> 43:29.420]  потому что не факт, что ответ вообще можно такой общий какой-то дать. На то мы говорим с вами о
[43:29.540 --> 43:35.740]  том, что это прям выделяется отдельно связанные подзапросы, потому что вот они вот такие. Это
[43:35.740 --> 43:45.540]  стандарт, это вот так и есть. От них невозможно избавиться всегда. Если подзапрос не зависит от
[43:45.540 --> 43:54.820]  строки, то в общем случае он не будет, опять же, он не будет внутри себя... Смотрите, давайте вернемся
[43:54.820 --> 44:07.820]  с вами. Вот здесь у нас есть зависимость. Почему есть зависимость? Потому что вот здесь мы ссылаемся
[44:07.820 --> 44:14.220]  на нашу таблицу из внешнего запроса. Поэтому у нас здесь будет не скаллярный, но связанный под
[44:14.220 --> 44:22.220]  запрос с предикатом Exist. И здесь у нас будет каждая строка внешней таблицы. Внешне, да,
[44:22.220 --> 44:28.820]  это такой, может быть, жирганизм, извините меня, таблица из внешнего запроса. Каждая строка таблицы
[44:28.820 --> 44:34.460]  из внешнего запроса будет сравниваться с каждой строкой таблицы, которая у нас получилась вот в
[44:34.460 --> 44:40.700]  этом вложенном селект-запросе. Здесь у нас, когда мы убрали ссылку, у нас просто получился вложенный,
[44:40.700 --> 44:48.180]  не скаллярный и не связанный, по сути дела, подзапрос. Вот здесь пример неверного запроса,
[44:48.180 --> 44:53.100]  неверного в контексте определения, не скаллярный, связанный, Exist. Здесь получился у нас Exist,
[44:53.100 --> 44:58.820]  не скаллярный, но не связанный. Здесь у нас просто селект вычислится на этапе соответствующем,
[44:58.820 --> 45:07.460]  в соответствующем порядке. И начнется с вложенного селект-вычисления, то есть from new in place,
[45:07.460 --> 45:15.700]  where t2 department равно IT. Просто вот это вычислится и дальше пойдет вверх по восходящему стеку.
[45:15.700 --> 45:24.260]  Ну, по стеку вверх, по восходящему стеку. По стеку вверх просто пойдет и все. А вот здесь не
[45:24.260 --> 45:34.860]  получится по стеку вверх, здесь будет именно вложение. Поэтому еще раз проговорю, у нас вложенный
[45:34.860 --> 45:40.500]  цикл получается только когда у нас связанная запроска, когда у нас есть явная ссылка из
[45:40.500 --> 45:47.980]  внутреннего запроса на данные из внешнего запроса. Под внутренним запросом, да, понимается под
[45:47.980 --> 45:52.900]  запрос, соответственно, то, что в скобках написано там селект, что-то там. Хорошо,
[45:52.900 --> 45:59.580]  проектирование баз данных. Давайте быстренько с вами по каким-то наверхам пробежимся,
[45:59.580 --> 46:08.540]  потому что уже немножко не успеваем, к сожалению. Что мы делаем, по сути своей,
[46:08.540 --> 46:23.340]  простыми словами, мы пытаемся сделать... Нет, опять же, вот SQL с точки зрения функционирования
[46:23.340 --> 46:32.700]  должен каждый раз высчитывать. Конкретно СУБД занесет ваш запрос в кэш, опять же, условно,
[46:32.700 --> 46:37.700]  если он частотно повторяющийся, занесет его в кэш и с кэша достанет, посмотрит,
[46:37.740 --> 46:44.460]  как она это делала, определит вот эти вот все пути, построит дерево запроса, деревья запроса,
[46:44.460 --> 46:48.380]  определит наиболее оптимальные, наиболее оптимальные в данном конкретном случае,
[46:48.380 --> 46:53.660]  исходя из загрузки узлов и так далее и того подобное, и только потом вычислить запрос,
[46:53.660 --> 47:01.380]  и в общем виде, и в общем случае на практике, общий случай на практике, да, у вас не будет
[47:01.380 --> 47:07.340]  постоянной квадратичной, да, квадратичного возрастания времени постоянного? Нет. Все,
[47:07.340 --> 47:12.540]  к счастью, не так. Это достигается, конечно, тоже не прямыми такими методами, а скорее такими,
[47:12.540 --> 47:19.540]  которые называются эвристические, что ли, до некоторой степени. Ну, за счет, по большому счету,
[47:19.540 --> 47:23.660]  того, что, да, там какие-то данные просто будут храниться в памяти оперативной либо на диске,
[47:23.660 --> 47:35.380]  и СОБД просто к ним обратится, поэтому чистая SQL будет читать заново, постоянно. Конкретная СОБД
[47:35.380 --> 47:40.700]  имеет средство оптимизации, она ими активно пользуется, и за счет этого позволит избежать
[47:40.700 --> 47:49.620]  заново пересчета. Опять же, Exist, для примера, да, повторюсь, он у вас отработает, в принципе,
[47:49.620 --> 48:01.220]  если хотя бы какие-то строки попали в подзапрос, для каких-то строк он выдаст вам значение true,
[48:01.220 --> 48:08.100]  если у вас хоть какие-то строки вы оказались в подзапросе. Ну, это уже да, если у вас нет
[48:08.100 --> 48:17.820]  ссылки, это немножко не то, это получается несвязанный подзапрос. Скажу, наверное, уже в четвертый
[48:17.820 --> 48:23.500]  или в пятый раз, если связанный подзапрос SQL по стандарту будет отрабатывать его внутренний
[48:23.500 --> 48:30.140]  подзапрос каждый раз для каждой строки внешней таблицы внешнего запроса, СОБД может иметь
[48:30.140 --> 48:35.180]  средства оптимизации, которые позволят сэкономить время и ресурсы. Но это надо смотреть конкретно
[48:35.180 --> 48:40.060]  уже на статистику вашей базы данных, на то, как отрабатывает планировщик, какой план запрос
[48:40.060 --> 48:49.060]  фонд строит. Хорошо, проектирование. Наконец-то, мы при проектировании пытаемся наши данные
[48:49.060 --> 48:55.660]  организовать сообразно требованиям реалиционной модели. Ну, коль скоро бы в парадигме реалиционной
[48:55.660 --> 49:02.420]  базы данных проектируем. Если мы взяли Neo4j, то, конечно, там мы можем чертить красивые графы.
[49:02.420 --> 49:11.900]  По сути дела, то, что мы чертим, проектируем при работе с реалиционной моделью, тоже на самом
[49:11.900 --> 49:19.820]  деле является графом. По большому счету у нас просто в вершинах нашего графа оказываются таблички,
[49:19.820 --> 49:27.820]  а связи между ними, дуги графа, оказываются функциональными зависимостими, обеспечиваемыми за
[49:27.820 --> 49:41.220]  счет ограничений первичного и внешнего ключей. У проектирования есть определенные задачи и надо,
[49:41.220 --> 49:49.460]  наверное, самое главное понимать вот что. База данных наша, она не про хранение, не про
[49:49.460 --> 49:55.380]  использование наименьшего количества, наименьшего объема жесткого диска. Это совсем не про то. База
[49:55.420 --> 50:04.820]  данных про оптимальное хранение и работу с данными, про оптимальное манипулирование ими. В этом
[50:04.820 --> 50:09.280]  смысле, сколько реально на диске места занимает ваша база данных, вопрос вообще вторичный,
[50:09.280 --> 50:16.460]  и ваше база данных должна быть логически последовательна и подчиняться определенным
[50:16.460 --> 50:19.940]  правилам. Последовательно спроектированно подчиняться определенным правилам не для того,
[50:19.940 --> 50:24.940]  чтобы занимать, повторюсь, меньше места, для того чтобы при добавлении редактирования удалений
[50:24.940 --> 50:32.540]  данных у вас не возникали аномалии определенные, о которых мы с вами сейчас поговорим. У проектирования
[50:32.540 --> 50:42.340]  выделяют определенные шаги, ну, это такая, знаете, прям теория теория, здесь нет каких-то отражений
[50:42.340 --> 50:52.340]  в конструкции СУБД, в том, как она функционирует, но принято выделять, вот, по существу можно это выделить
[50:52.340 --> 50:57.340]  вот на такие этапы разложить, да, определение предметной области, определение взаимосвязи между различными
[50:57.340 --> 51:02.340]  элементами данных, наложение логической структуры на основе определенных соотношений, создание
[51:02.340 --> 51:08.340]  с проектированной БД с учетом особенностей используемой СУБД. А выделяют три этапа, концептуальное
[51:08.340 --> 51:12.340]  проектирование, логическое проектирование, физическое проектирование, концептуальное самое
[51:12.340 --> 51:17.340]  верхнеуровневое, ну, самое абстрактное, самое верхнеуровневое с точки зрения реализации на
[51:17.340 --> 51:25.340]  конкретном программном обеспечении. Концептуальное это когда мы берем лист бумаги и начинаем, так
[51:25.340 --> 51:30.340]  сказать, на нем, ну, уже не лист бумаги, конечно же, да, там, графические редакторы соответствующие
[51:30.340 --> 51:41.340]  и начинаем в них красивые там фигуры чертить, между ними проводить линии с специфическими маркерами,
[51:41.340 --> 51:50.340]  показывающими характер взаимоотношений. На логическом этапе мы добавляем уже ограничения какие-то,
[51:50.340 --> 51:58.340]  да, привязанные к нашей реализационной модели моменты, ограничения вот о которых мы с вами
[51:58.340 --> 52:07.340]  говорили, на типы данных, на какие-то значения, физическое проектирование тоже непосредственно
[52:07.340 --> 52:14.340]  написание SQL-команда, SQL-программ, которые будут вашей СУБД выполняться и уже внутри нее будут
[52:14.340 --> 52:28.340]  созданы корректные представления вашей модели данных. Первый шаг в определение данных,
[52:28.340 --> 52:39.340]  ну, такая история, в общем-то, да, не имеющая каких-то формализмов, просто история о том,
[52:39.340 --> 52:46.340]  что на практике необходимо какие-то вещи, какие-то вот данные, которые подчас могут даже сейчас,
[52:46.340 --> 52:51.340]  да, даже сейчас на некоторых предприятиях, каких-то фирмах, ну, небольших, конечно, скорее,
[52:51.340 --> 52:57.340]  храниться просто в Excel-овских таблицах, их нужно вообще понять, что это за данные, их как-то вот,
[52:57.340 --> 53:03.340]  может быть, очистить предварительно, может быть, там определить вообще, насколько эти данные
[53:03.340 --> 53:12.340]  сообразным образом хранятся и вникнуть в собственную предметную область, ну, хотя бы немножко,
[53:12.340 --> 53:20.340]  хотя бы выделив основные сущности, основные абстракции, погрузиться в предметную область,
[53:20.340 --> 53:29.340]  чтобы понимать, насколько, как эти данные надо разделять для оптимального хранения и последующих
[53:29.340 --> 53:37.340]  операций с ними. Давайте мы попробуем с вами на примере посмотреть вообще, да, как можно описать
[53:37.340 --> 53:43.340]  вот некую предметную область. Вот, ну, допустим, магазин Пятерочка, вот, можно выделить какие-то
[53:43.340 --> 53:49.340]  сущности, типа каталога товаров, каталога складов, характеристики наполнения склада, планы поставок
[53:49.340 --> 53:59.340]  и так далее. Для банка, например, Теньков, это сущности будут клиент, карты клиента, транзакции по
[53:59.340 --> 54:05.340]  картам и так далее. Ну, для МФТИ тоже, да, можно какие-то сущности выделять, пофантазировать,
[54:05.340 --> 54:12.340]  ну, это буквально, да, в какой-то степени, наверное, фантазия все-таки. Работа воображения,
[54:12.340 --> 54:17.340]  по крайней мере, но все-таки, да, логический анализ имеет место быть. Вот студент, группа, преподаватель,
[54:17.340 --> 54:24.340]  расписание пары экзаменов, это все как отдельные сущности можно себе выделить для начала и
[54:24.340 --> 54:31.340]  попробовать построить уже какую-то концептуальную модель, используя более строгие, что ли, методы
[54:31.340 --> 54:41.340]  и инструменты. Что мы делаем, что мы используем для того, чтобы спроектировать базу данных,
[54:41.340 --> 54:47.340]  когда мы уже хоть как-то вот допоняли, что происходит с нашей предметной областью,
[54:47.340 --> 54:53.340]  с чем нам предстоит заниматься, мы пытаемся с помощью ER-модели Entity Relationship Model
[54:53.340 --> 55:01.340]  построить модель данных, описывающую основные взаимосвязи и впоследствии ее уточнить
[55:01.340 --> 55:10.340]  необходимым образом. Нам нужны в модели две категории, это, собственно, сущности и между
[55:10.340 --> 55:16.340]  сущности и между ними связи. Сущности – это наши будут вершины графа, связи – это его дуги,
[55:16.340 --> 55:22.340]  и ER-модель выглядит, собственно, так, как показано на рисунке. Тариф, пластиковая карта,
[55:22.340 --> 55:30.340]  операция – модель для платежной системы какой-то, для банка может быть. Понятно, она привитивная,
[55:30.340 --> 55:36.340]  это исключительно в дидактических целях, реальная модель будет сложнее, будет иметь определенный
[55:36.340 --> 55:42.340]  набор технических отношений, то есть необходимые для функционирования базы данных для того, чтобы
[55:42.340 --> 55:51.340]  отслеживать какие-то изменения и так далее. На стадии концептуального проектирования это еще
[55:51.340 --> 55:56.340]  и не нужно, технические какие-то данные, отношения для технических данных, но тем не менее,
[55:56.340 --> 56:06.340]  это вообще-то примитив-примитив. Определение взаимосвязи. Нам необходимо, опять же, в нашей
[56:06.340 --> 56:13.340]  модели каким-то образом показывать не просто дуги графа между вершинами, а нужно показывать,
[56:13.340 --> 56:23.340]  что они еще имеют какую-то между собой… они между собой различаются. Для этого используется
[56:23.340 --> 56:30.340]  так называемая аннотация воронья лапка. На слайде приведены примеры использования этой
[56:30.340 --> 56:39.340]  аннотации. У нас в принципе связей между сущностями может быть несколько, но они,
[56:39.340 --> 56:46.340]  наверное, довольно простые, на мой взгляд. Во всяком случае, после того, как вы проект свой курсовой
[56:46.340 --> 56:55.340]  сделаете, я думаю, что для вас тоже это будет в целом понятная история. То есть, может быть,
[56:55.340 --> 57:05.340]  один ко многим и многие ко многим и один к одному. Здесь у нас… это вот такие, наверное, основные
[57:05.340 --> 57:11.340]  варианты связи, поскольку у нас все-таки ограничение первичного-вторичного ключей работает,
[57:11.340 --> 57:21.340]  поэтому ноль или один, ноль или много – это более редкая история. Но вариантов здесь чуть больше,
[57:21.340 --> 57:29.340]  больше выразительности, более выразительные средства предоставляет нотация. То есть, есть связь
[57:29.340 --> 57:36.340]  многие – один ко многим, один и только один, один или ноль. В общем, вы это все видите на экране,
[57:36.340 --> 57:41.340]  выглядит это вот так, стандартным образом. Концептуальная модель – ресторан, например,
[57:41.340 --> 57:47.340]  можно ее обозначить следующим образом. Вот мы выделили несколько сущностей, между ними
[57:47.340 --> 57:53.340]  графически обозначили некоторое количество связей, и, используя нашу нотацию, вороней лапки,
[57:53.340 --> 58:05.340]  эти связи не версифицировали. На что здесь можно обратить внимание? Ну вот, например,
[58:05.340 --> 58:13.340]  что значит заказ и блюдо? То есть у нас у одного заказа, вот эта дуга, что означает? Что у одного
[58:13.340 --> 58:22.340]  заказа в одном заказе может быть одно или несколько блюд, а одно блюдо, оно может, как в несколько
[58:22.340 --> 58:28.340]  заказов входить, так и ни в один заказ не входить. Ну что это значит ни в один заказ не входить?
[58:28.340 --> 58:36.340]  То есть у нас, в принципе, есть какой-то перечень блюд, и не обязательно, что они соединены
[58:36.340 --> 58:42.340]  с каждым заказом. Ну как бы понятно, у нас просто номенклатуры в меню есть, а заказ еще не сделан
[58:42.340 --> 58:49.340]  на это блюдо. Или новое блюдо добавлено в меню, а заказов по нему еще нет. Так же, в принципе,
[58:49.340 --> 58:55.340]  каждую связь здесь можно также объяснить. Ну давайте, наверно, может быть, один к одному
[58:55.340 --> 59:01.340]  заказ и оплата счета. То есть у нас в одном заказе допускается только один счет, и один счет может
[59:01.340 --> 59:05.340]  быть только в одном заказе. Ну здесь довольно понятно, наверное, хотя современные средства
[59:05.340 --> 59:10.340]  предоставляют... Средства обеспечения деятельности предприятия общественного питания
[59:10.340 --> 59:15.340]  предоставляют возможность разбивать счета и оплачивать несколько счетов в одном заказе.
