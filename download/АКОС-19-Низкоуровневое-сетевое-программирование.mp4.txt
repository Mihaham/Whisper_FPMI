[00:00.000 --> 00:15.640]  Я думаю, можно начинать. Сейчас мы немножко опять вернемся к сетям. Во-первых, у вас остается до конца
[00:15.640 --> 00:22.480]  модуля две лекции, сегодня и через неделю. Соответственно, через две недели что будет?
[00:22.480 --> 00:31.600]  Контрольная. При этом на семинарах у вас у кого-то осталась одна тема, у кого-то две темы.
[00:35.600 --> 00:46.600]  И тема это низкоуровневое сетевое программирование. Напомню, что у нас есть стэк протоколов под названием
[00:46.600 --> 00:55.920]  TCP-IP. Что этот стэк протоколов подразумевает? Что у вас есть некоторые пакеты, которые называются
[00:55.920 --> 01:03.840]  IP-пакетами. Они гуляют между разными хостами в сети, возможно, довольно сложными маршрутами. И по
[01:03.840 --> 01:11.120]  протоколу IP можно передавать самые разные данные. Например, внутрь протокол IP можно запихать
[01:11.120 --> 01:18.480]  сегменты TCP, которые подразумевают установку двустороннего соединения. И с точки зрения
[01:18.480 --> 01:25.760]  прикладного программирования у вас socket TCP-IP будет выглядеть точно так же, как двунаправленный
[01:25.760 --> 01:32.840]  канал с обычной установки соединений. Делается не бесплатно, естественно. Элементарно,
[01:32.840 --> 01:43.360]  handshake по протоколу TCP занимает несколько обменов. К сожалению, на проекторе не очень видно,
[01:43.360 --> 01:51.480]  потому что проектор не очень хороший. Что вообще подразумевается при взаимодействии по протоколу
[01:51.480 --> 01:58.880]  TCP? У вас все сегменты TCP имеют некоторый порядковый номер. Этот порядковый номер присваивается
[01:58.880 --> 02:04.040]  ядром операционной системы, и вообще говоря, он имеет сквозную номерацию. То есть у вас может
[02:04.040 --> 02:14.240]  быть запущено несколько процессов, каждый из процессов подключается к своему серверу. И ядро
[02:14.240 --> 02:21.880]  просто делает достаточно большие номера этих пакетов. И если вы запустите, например, утилиту
[02:21.880 --> 02:29.320]  Wireshark, то Wireshark уже демонстрирует вам номера пакетов, пересчитанные относительно начала
[02:29.320 --> 02:38.800]  взаимодействия. В чем заключаются задачи ядра при взаимодействии по протоколу TCP? Поскольку у вас
[02:38.800 --> 02:47.560]  по сети ходят IP пакеты самыми разными маршрутами, они могут доходить вовсе даже непоследовательно.
[02:48.040 --> 02:54.320]  Уже задача ядра, прежде чем выдать конкретному процессу, который использует взаимодействие по
[02:54.320 --> 03:02.560]  сокетам, выстраивание всех нужных пакетов с данными в правильном порядке. Если какие-то
[03:02.560 --> 03:09.920]  пакеты не дошли, то выполняется запрос к противоположной стороне с просьбой отправить повторно.
[03:09.920 --> 03:18.320]  И ядро вообще делает полное экранирование прикладного интерфейса уровня прочитать,
[03:18.320 --> 03:26.420]  записать от какой-то там магии, которая лежит с точки зрения сетевых протоколов. И этим удобен как
[03:26.420 --> 03:35.280]  раз протокол TCP, который является видом сокетов для потоков взаимодействия. На самом деле для
[03:35.360 --> 03:43.040]  потоков взаимодействия существует не только протокол TCP, когда давно существовала такая
[03:43.040 --> 03:48.240]  операционная система под названием NovelNetware, очень популярная для серверного применения,
[03:48.240 --> 03:58.680]  в частности шаринг файлов, принтеров. И там использовался вовсе не стэк TCPIP, а очень
[03:58.680 --> 04:07.480]  похожий стэк протокол IPX и SPX. Это один из примеров того, что протокол TCP вовсе не является
[04:07.480 --> 04:13.880]  единственным стриминговым протоколом. Кроме того, для поточного взаимодействия вы можете
[04:13.880 --> 04:19.280]  использовать не только сетевые соединения через сокеты с номерами портов и IP-адресом,
[04:19.280 --> 04:28.000]  но и обычные UNIX-взаимодействия, когда используется адресация по локальным именам файлов.
[04:28.000 --> 04:34.840]  И вот при создании сокета нужно явным образом как-то указать, какой протокол будет использован.
[04:34.840 --> 04:42.480]  Если вы указываете цифру 0 в качестве последнего параметра, то ядро автоматически выбирает
[04:42.480 --> 04:49.120]  семейство протоколов, которые будет использовано. Если у вас взаимодействие идет по сети интернет,
[04:49.120 --> 04:57.360]  то с очень большой вероятностью будет выбран именно протокол TCP, если укажете SOCKS3. На самом деле
[04:57.360 --> 05:05.720]  если указать цифру 6, то результат будет тот же самый, потому что цифра 6 явным образом фигурирует
[05:05.720 --> 05:13.400]  в каждом IP-пакете. Это просто номер протокола TCP для того, чтобы противоположная сторона могла
[05:13.400 --> 05:20.160]  разобраться, что дальше делать при распаковке этого IP-пакета. Кроме потоковой передачи данных,
[05:20.160 --> 05:26.400]  бывают еще и другие виды взаимодействия и соответственно типы сокетов. То есть потоковая
[05:26.400 --> 05:32.680]  передача предназначена для двунаправленной последовательной передачи данных. Кроме того,
[05:32.680 --> 05:39.760]  существует еще и достаточно популярен способ передачи данных только в одну сторону в виде
[05:39.760 --> 05:46.960]  коротких сообщений, которые называются датограммы. Для этого обычно используется протокол UDP. И можно
[05:46.960 --> 05:54.320]  взаимодействовать с сокетами на низком уровне, то есть читать данные и передавать данные,
[05:54.320 --> 06:00.520]  вручную разбираться уже с теми заголовками бинарными, которые в этих данных присутствуют,
[06:00.520 --> 06:06.640]  ну и возможно даже сделать какой-нибудь свой протокол вместо протокола TCP, вместо протокола
[06:06.640 --> 06:15.440]  UDP и даже вместо протокола IP, если вдруг вам этого захочется. Итак, начнем сверху-низ.
[06:15.440 --> 06:25.960]  Протокол UDP. Заголовок протокола UDP, в отличие от TCP, очень простой. Там всего лишь 8 байтиков,
[06:25.960 --> 06:34.560]  2 байта под номер порта отправителя, номер порта получателя. То есть точно так же, как в протоколе
[06:34.560 --> 06:41.560]  TCP, у нас есть некоторое пространство имел под названием номера портов, которые связывают с
[06:41.560 --> 06:50.160]  определенными службами, и длина сообщения плюс контрольная сумма. Все, вот очень простой заголовок,
[06:50.160 --> 06:59.240]  в отличие от протокола TCP, где есть еще номера пакетов, куча флагов, и какой размер сообщения
[06:59.240 --> 07:06.840]  вы можете передать. Здесь у вас все ограничивается размером payload, который вы можете запихать в конечном
[07:06.840 --> 07:17.880]  итоге. В IP пакет, размер IP пакета сверху у нас еще ограничен размером Ethernet кадра. Есть параметр
[07:17.880 --> 07:25.440]  при установке настройки сети, называется message transfer unit. Обычно в большинстве случаев это 1500 байтов
[07:25.440 --> 07:34.800]  для Linux Mac OS, либо 1492 байта под Windows. И вот это максимальный размер, который вы можете передавать
[07:34.800 --> 07:43.560]  внутри одного кадра Ethernet. У нас есть несколько байтов на заголовок IP, это 20 байтов. 8 байтов
[07:43.560 --> 07:49.640]  еще занимает сам заголовок UDP. Ну и вот несложно рассчитать, какой максимальный размер сообщений,
[07:49.640 --> 07:54.640]  которые вы можете отправить с помощью одной датаграммы. И датаграммы, это просто короткие
[07:54.640 --> 08:01.800]  сообщения. Вы их отправляете в произвольном порядке, опять же, они могут доходить разными
[08:01.800 --> 08:08.280]  маршрутами, и никто не гарантирует порядок, к которому не дойдут до получателя, и дойдут ли вообще.
[08:08.280 --> 08:15.080]  Вы это проконтролировать никак не сможете. Но на самом деле интернет у нас плюс-минус более-менее
[08:15.080 --> 08:22.480]  работоспособен, если не говорить про Fistech, если не говорить про общую ситуацию в стране. Но можно
[08:22.480 --> 08:28.120]  считать, что вероятность того, что у вас ничего не будет доходить, достаточно низкая, значит у вас
[08:28.120 --> 08:35.000]  просто все перестанет работать. И можно считать, что протокол UDP достаточно надежен, с точностью до
[08:35.000 --> 08:41.800]  того, что вы не знаете, в каком порядке вам пакеты могут доходить. И зачем вообще он нужен? Какие есть
[08:41.800 --> 08:48.440]  преимущества? Почему бы просто не использовать обычный протокол TCP, который гарантирует нам все,
[08:48.440 --> 08:53.960]  что только можно гарантировать? С точки зрения программного интерфейса очень удобен, поскольку
[08:53.960 --> 09:01.640]  это обычное двустороннее взаимодействие. Вся суть протокола UDP в том, что имеет заведомо более
[09:01.640 --> 09:11.080]  низкий overhead. В частности, вам нужно отправить три сегмента только для установки TCP-соединения,
[09:11.080 --> 09:19.080]  по UDP это не требуется. TCP-соединения точно также нужно еще и закрывать аккуратным образом. Для UDP,
[09:19.560 --> 09:24.440]  в принципе, это не предусмотрено, потому что никакого постоянного соединения у вас нет. У вас есть
[09:24.440 --> 09:32.360]  просто перекидывание данных в одну сторону, сервер может вам, если захочет, отправить в обратную
[09:32.360 --> 09:40.760]  сторону тоже какие-то данные. И здесь, если вам важен порядок пакетов, хорошо договоритесь уже на
[09:40.760 --> 09:46.680]  более высоком уровне, что делать с теми пакетами, которые вам в какой-то момент времени прилетели.
[09:46.680 --> 09:56.720]  Какие обычные сценарии использования протокола UDP? Когда-то он был очень популярен в то время,
[09:56.720 --> 10:04.920]  когда были распространены торренты, учитывая последние политические соображения, когда внезапно
[10:04.920 --> 10:10.720]  вдруг разрешили... пиратить, конечно, это очень плохо, но рутрекер разблокировали, торренты,
[10:10.720 --> 10:17.760]  видимо, скоро опять вернутся. Вот там протокол UDP использовался очень активно, поскольку передача
[10:17.760 --> 10:24.960]  данных производилась в первую очередь только в одну сторону к получателю торрента. Протокол UDP,
[10:24.960 --> 10:30.120]  кстати, тоже один из недостатков. Если у вас трафик направлен преимуществом в одну сторону,
[10:30.120 --> 10:36.480]  например, вы выкачиваете большие объемы данных, то в обратную сторону все равно приходится гонять
[10:36.480 --> 10:43.600]  большое количество IP пакетов просто для того, чтобы подтверждать получение каждого TCP сегмента.
[10:43.600 --> 10:50.160]  То есть протокол TCP удобен, когда у вас более-менее сбалансирован объем данных,
[10:50.160 --> 10:55.240]  который передается в разные стороны, но если у вас преимущественно идет скачивание в одну сторону,
[10:55.240 --> 11:02.280]  то он уже становится неэффективным. Из современных применений протокола UDP это
[11:02.280 --> 11:08.280]  видеостриминг, Zoom, Google Meets, все остальное, Jitsi Meet, например,
[11:08.280 --> 11:16.040]  open-source решение аналогичное. И еще одно очень очевидное применение, где использование протокола
[11:16.040 --> 11:25.640]  UDP заведомо более выгодное, чем TCP, это множество протоколов под общим названием VPN. Что такое VPN,
[11:25.640 --> 11:30.240]  я думаю, рассказать не нужно. Вы и так уже, наверное, все знаете, хотя делать вид, что не знаете.
[11:30.240 --> 11:42.080]  Почему VPN более выгодно использовать именно через UDP, а не TCP? Потому что все равно у вас VPN это
[11:42.080 --> 11:49.360]  некоторые туннели, виртуальная какая-то сетевая карта, у которой есть свой IP-адрес,
[11:49.360 --> 11:58.040]  своя маршрутизация, и фактически вам нужно эмулировать передачу езернет-кадров вместо
[11:58.040 --> 12:03.800]  езернет-проводов, вместо Wi-Fi, просто вы все это запихиваете в некоторый туннель программный.
[12:03.800 --> 12:14.200]  И здесь вам не нужно делать никакую проверку целостности, что данные доходят, что доходят в
[12:14.200 --> 12:19.520]  нужном порядке, потому что все равно поверх вот этого симулированной сетевой карты виртуальной
[12:19.520 --> 12:28.880]  этого туннеля у вас будет своя реализация TCP, поэтому просто запихиваем каждый езернет-кадр
[12:28.880 --> 12:39.400]  в UDP пакет и отправляем на VPN-сервер. И обратно тоже получаем. У нас есть некоторый способ сделать
[12:39.400 --> 12:46.080]  дополнительную прослойку в сетевой иерархии, ввести новый сетевой уровень, либо несколько сетевых
[12:46.080 --> 12:54.400]  уровней, если вы делаете огромную цепочку VPN-ов. То есть у нас на уровне канальной передачи данных
[12:54.400 --> 13:01.800]  традиционно выделяется интерфейс езернет, сетевая плата, хотя совершенно не обязательно это может
[13:01.800 --> 13:07.320]  быть езернет, это может быть какое-то виртуальное устройство, виртуальный туннель, и у каждого
[13:07.320 --> 13:14.400]  езернет-устройства тоже есть свой адрес. Причем этот адрес связан с каждым конкретным устройством,
[13:14.400 --> 13:20.720]  если вы внимательно изучите все наклейки на ваших ноутбуках. Правда, наклейки не в всех ноутбуках
[13:20.720 --> 13:28.320]  бывают, некоторые производители их просто не клеят. Одна из наклейок это MAC-адрес вашей
[13:28.320 --> 13:35.000]  Wi-Fi-карты. Как правило, считается, что MAC-адрес жестко привязан к конкретному производителю оборудования,
[13:35.000 --> 13:44.960]  конкретному экземпляру оборудования, но на самом деле это не жесткое ограничение, и MAC-адреса у
[13:44.960 --> 13:51.560]  некоторых производителей можно перенастраивать. В частности, если вы настраиваете какой-нибудь
[13:51.560 --> 13:57.320]  роутер, у большинства роутеров есть возможность присвоить какой-нибудь произвольный MAC-адрес.
[13:57.320 --> 14:02.600]  И вот этот MAC-адрес как раз используется для того, чтобы адресовать ваше устройство. Забудем пока про
[14:02.600 --> 14:10.720]  все IP-адреса. Они нам не нужны. Для чего нужны MAC-адреса? Они нужны для того, чтобы могли общаться
[14:10.720 --> 14:17.440]  между компьютерами, которые находятся близко друг к другу. То есть все устройства в пределах одной
[14:17.440 --> 14:26.160]  Wi-Fi-сети. Если вы сейчас подключили стилю сеть МИПТ, то я могу найти ваш адрес. Если через МИПТ-НГ,
[14:26.160 --> 14:32.600]  значит мне нужно переподключаться. Либо в пределах одной локальной сети соединенной
[14:32.600 --> 14:41.040]  проводами до первого маршрутизатора. Какие бывают устройства для проводной коммутации сети Ethernet?
[14:41.040 --> 14:47.560]  Есть устройства пассивные, так называемые хабы. Они уже практически все вымерли, можно найти только
[14:47.560 --> 14:55.520]  где-нибудь в барахолке у каких-нибудь дяюшек, которые делают ретро-музей с компьютерного железа.
[14:55.520 --> 15:03.600]  Фактически это просто коммутаторы кабелей с предусилителем, которые никак не смотрят на
[15:03.600 --> 15:09.480]  ваши MAC-адреса. Чуть более распространенные устройства это так называемые свечи. Они же
[15:09.480 --> 15:18.920]  коммутаторы не намного дороже, чем хабы, но они умеют перенаправлять трафик в зависимости от того,
[15:18.920 --> 15:28.280]  какой у него MAC-адрес. Чуть более осмысленная нагрузка на отдельные кабели. Более продвинутое
[15:28.280 --> 15:33.280]  устройство называется роутер. Как правило это обычный хост, обычный компьютер с обычной операционной
[15:33.280 --> 15:38.320]  системой. На самом деле с точки зрения логической организации сети это самый обычный хост. Самый
[15:38.320 --> 15:45.600]  обычный компьютер, у которого есть свой IP-адрес, и роутер может просто принимать данные из одной
[15:45.600 --> 15:53.320]  под сети, перенаправлять другую. В этом его задача. До первого роутера, то есть в пределах некоторой
[15:53.320 --> 16:00.720]  Wi-Fi сети, до выхода сеть наружу, до первого роута по проводам, все компьютеры могут общаться между
[16:00.720 --> 16:12.200]  собой, даже не имея IP-адресов. При этом все-таки IP-адреса нам нужны. Для чего они нам нужны? Для того,
[16:12.200 --> 16:22.000]  чтобы выходить куда-то за пределы нашей микросети, ну и иметь доступ до выхода в глобальную сеть.
[16:22.000 --> 16:28.160]  Естественно, если вы уже подключились к какой-то сети, то скорее всего IP-адрес вам уже присвоили,
[16:28.160 --> 16:35.880]  и между компьютерами в локальной сети и физическими MAC-адресами, которые соответствуют вашим
[16:35.880 --> 16:42.480]  устройствам, есть однозначные соответствия. Некоторая таблица соответствия IP-адресов и
[16:42.480 --> 16:52.720]  MAC-адресов, она недолго живущая, в Linux заживет 30 секунд, потом обновляется. И для назначения IP-адресов
[16:52.720 --> 17:01.720]  используется протокол ARP. Здесь мы уже говорим про назначение адресов по какому-то протоколу,
[17:01.720 --> 17:11.040]  имея в виду, что никакой IP-адресации у нас нет. То есть что у нас может передаваться в одном
[17:11.040 --> 17:17.400]  Ethernet-кадре? Идея в том, что в одном Ethernet-кадре могут передаваться не обязательно IP-пакеты,
[17:17.400 --> 17:27.120]  а все что угодно. Для этого в кадре Ethernet есть два байта, которые выделяются под тип данных,
[17:27.120 --> 17:34.920]  которые у нас расшифруются, там передаются. В частности, это может быть какой-то IP-пакет для
[17:34.920 --> 17:44.520]  протокола IPv4, либо пакет для протокола IPv6. Это совершенно разные пакеты, несмотря на то,
[17:44.520 --> 17:51.940]  что назначение протоколов одинаковое. У нас под ними тем же кабелем могут гоняться как IP-пакеты,
[17:51.940 --> 17:58.600]  так и пакеты системы NovelNetware, которые по протоколу IPv6. И это ничему не будет противоречить,
[17:58.600 --> 18:09.320]  потому что они будут иметь разные константы в поле тип Ethernet-кадров. Кроме IP, бывают еще
[18:09.320 --> 18:15.720]  некоторые другие протоколы. В частности, протокол ARP, который предназначен для того,
[18:15.720 --> 18:27.120]  чтобы выяснить IP-адрес какого-то компьютера по его MAC-адресу, либо наоборот. И для того,
[18:27.120 --> 18:38.480]  чтобы иметь возможность смотреть эту таблицу, есть утилита под названием ARP. В некоторых
[18:38.720 --> 18:46.040]  дистрибутивах она входит в штатную поставку, в некоторых дистрибутивах эта утилита не входит
[18:46.040 --> 18:54.160]  в штатную поставку и нужно ставить отдельно. Я сейчас ее запущу не в Linux, потому что это будет
[18:54.160 --> 19:08.360]  неинтересно, а под macOS, потому что это хост-система. ARP. Давайте посмотрим, кто у нас тут рядом есть.
[19:08.640 --> 19:26.400]  Сейчас я нахожусь в сети под названием MIBD. Я вижу два ноутбука, один десктоп. Видимо,
[19:26.400 --> 19:33.520]  тут кто-то есть еще кроме меня. Если я запущу эту утилиту еще через некоторое время,
[19:33.760 --> 19:41.560]  то результаты могут отличаться, потому что жизненный цикл таблицы 30 секунд периодически
[19:41.560 --> 19:49.240]  обновляется. По этой таблице, зная IP-адрес, можно выяснить его MAC-адрес и, соответственно,
[19:49.240 --> 19:55.000]  когда вы хотите отправить какой-то AP-пакет к какому-то компьютеру с вашей локальной в сети,
[19:55.000 --> 20:02.120]  не используя маршрутизатор, вы знаете, что какой-то компьютер находится рядом, то достаточно отправить
[20:02.120 --> 20:11.480]  его напрямую, завернув AP-пакет в какой-то Ethernet-кадр и направив конкретному какому-то компьютеру.
[20:11.480 --> 20:27.560]  Дальше, если мы запихиваем что-то в наш Ethernet-кадр, то есть у нас есть некоторый Payload размером до
[20:27.560 --> 20:36.200]  1500 байт, и вот туда уже можем запихать тоже, что имеет свои заголовки, свои данные. Чаще всего
[20:36.200 --> 20:47.080]  там ходят IP-пакеты, либо IPv4, либо IPv6. IPv4 более распространенный протокол, хотя у него огромное
[20:47.080 --> 20:53.560]  количество недостатков, и он уже подразумевает, что у вас должен быть назначенный IP-адрес. При этом
[20:53.560 --> 21:03.120]  пакеты могут гулять как угодно по сети. Допустим, вы хотите отправить к некоторому серверу под
[21:03.120 --> 21:10.080]  названием yandex.ru, у которого есть определенный белый IP-адрес, какие-то данные. Вы эти данные
[21:10.080 --> 21:18.040]  подготовили, завернули в AP-пакет, какому из компьютеров нужно их направлять. Если у нас есть
[21:18.040 --> 21:24.360]  Wi-Fi-роутер, то ответ, наверное, достаточно очевиден. Нужно отправить это роутеру, у которого тоже есть
[21:24.360 --> 21:29.440]  свой IP-адрес уже назначенный, который находится в той же локальной подсети, что и ваш компьютер.
[21:29.440 --> 21:37.200]  Если это локальная сеть с кучей проводов, то здесь уже все не так однозначно, роутеров может быть
[21:37.200 --> 21:46.360]  несколько, и куда именно дальше отправляются ваши Ethernet-пакеты, содержащие нужные AP-пакеты.
[21:46.360 --> 21:53.480]  Это определяется таблицами маршрутизации. Есть старинная классическая утилита по названию
[21:53.480 --> 22:03.760]  Root, которая есть как в линукс-дистрибутивах, но в некоторых последних версиях дистрибутивов ее
[22:03.760 --> 22:10.000]  нужно ставить отдельно, так и является стандартной для FreeBSD macOS, которая позволяет,
[22:10.000 --> 22:17.960]  конечно, имея права Root, модифицировать таблицу маршрутизации, назначать какие-то из компьютеров
[22:17.960 --> 22:25.700]  ответственными за то, чтобы перенаправлять дальше весь трафик. В линукс это делается универсальной
[22:25.700 --> 22:30.840]  командой под названием IP, это универсальная команда, потому что она позволяет делать все,
[22:30.840 --> 22:35.320]  что угодно, настраивать таблицу маршрутизации, настраивать сетевые интерфейсы и так далее.
[22:35.400 --> 22:42.840]  С параметром Root либо с буквкой R эта команда может отображать таблицу маршрутизации,
[22:42.840 --> 22:52.280]  либо при наличии соответствующих прав ее перенастраивать. Итак, если мы хотим выяснить,
[22:52.280 --> 23:08.240]  как достучаться до какого-нибудь сервера, например, yandex.ru, это вариант FreeBSD и macOS,
[23:08.240 --> 23:16.840]  в линукс Teletor Root тоже существует. Куда мне нужно постучаться? Мне нужно отправить пакет,
[23:16.840 --> 23:25.560]  как ни странно, в некотором гейтвейу, у которого есть адрес net120.ipoe.users.mit.ru, у которого есть свой
[23:25.560 --> 23:31.320]  IP-адрес. На самом деле все пакеты будут отправляться именно туда, дальше этот сервер под названием
[23:31.320 --> 23:39.060]  net120.ipoe.users.mit.ru будет смотреть, по какому из маршрутов выгоднее отправить во внешнюю сеть
[23:39.060 --> 23:49.260]  yandex.ru. Мой пакет его, конечно же, модифицирует. Для чего нужна модификация заголовков IP-пакетов?
[23:49.260 --> 23:57.020]  Связано это с тем, что когда я отправляю какой-то пакет, он имеет внутри себя адрес отправителя.
[23:57.020 --> 24:04.300]  Какой адрес отправителя у меня будет? Какой-то не совсем легальный для использования извне,
[24:04.300 --> 24:12.740]  начинающийся с 10, 211, чего-то там. Это серые адреса, предназначенные только для локальных сетей.
[24:12.740 --> 24:20.300]  И, соответственно, яндексу надо будет отправить куда-то обратно ответ, чтобы получил именно я,
[24:20.300 --> 24:24.860]  а не кто-то другой. Он будет отправлять ответ провайдеру, провайдер будет отправлять уже
[24:24.860 --> 24:33.660]  МИП-телекому. МИП-телеком уже будет разбираться по своей таблице маршрутизации, на какой из
[24:33.660 --> 24:39.900]  вай-фай роутеров на фистехе нужно отправить этот пакет, а дальше уже конкретный вай-фай роутер будет
[24:39.900 --> 24:50.060]  разбираться, какому устройству нужно его доставить. Под линукс примерно все то же самое. Утилита
[24:50.060 --> 25:02.140]  называется IP. Тут куча вариантов, что можно настраивать. Вот IP road, левая буковка R. Отображаю,
[25:02.140 --> 25:08.140]  что дефолтный... Да, вывод немножко другой, но он примерно совпадает. Поскольку линукс у меня
[25:08.140 --> 25:14.660]  в виртуалке, тут результат немножко другой. Есть один дефолтный маршрут через устройство с
[25:14.660 --> 25:22.100]  определенным именем и через определенный маршрутизатор, у которого есть какой-то IP адрес.
[25:22.100 --> 25:29.260]  И маршрутов может быть несколько, в том числе несколько маршрутов по умолчанию. Это относится
[25:29.260 --> 25:33.980]  к любой UNIX-системе, не только к линуксу. Для чего вам могут понадобиться несколько маршрутов?
[25:33.980 --> 25:40.700]  Например, если у вас есть несколько сетевых плат, то, во-первых, вы можете разные сетевые
[25:40.700 --> 25:48.620]  платы использовать для разных подсетей. Например, одна сеть внешняя, не очень защищенная,
[25:48.620 --> 25:55.260]  все-таки внешний мир. Другая сеть исключительно для внутреннего потребления, куда лазить особо
[25:55.260 --> 26:02.020]  не нужно, защищена фаерволом. Так и просто иметь несколько оплинков, независимых друг от друга.
[26:02.020 --> 26:10.300]  Например, у вас есть основной провайдер, плюс у вас есть, на всякий случай, дополнительный канал
[26:10.300 --> 26:16.540]  связи через мобильную сеть, на случай, если там забудете проплатить за интернет или провайдер
[26:16.540 --> 26:22.620]  какие-то проблемы возникнут, мало ли что. Эти каналы могут использоваться для резервирования,
[26:22.620 --> 26:30.100]  ну либо, если они доступны одновременно, то почему просто трафик не раскидать равномерно
[26:30.100 --> 26:37.580]  по разным маршрутам. На самом деле, в линукс можно настраивать приоритетность каждого из маршрутов,
[26:37.580 --> 26:46.860]  так называемый вес, с которым пакеты будут отправляться, с какой вероятностью по каждому
[26:46.860 --> 26:55.700]  из ваших оплинков и других маршрутов. Ну и плюс, опять же, вы можете достаточно гибко настраивать,
[26:55.700 --> 27:02.860]  какой из маршрутов у вас для каких IP-адресов используется. Зачем это бывает нужно? Ну, например,
[27:02.860 --> 27:09.100]  у вас есть основной маршрут, плюс вы подняли VPN-тунель, зачем вам весь трафик гонять через VPN?
[27:09.100 --> 27:23.020]  Ну, примерно половина интернета доступна без VPN, можно на этом сэкономить. И вот как у нас
[27:23.020 --> 27:30.260]  происходит настройка присвоения каких-то IP-адресов. То есть понятно, что без IP-адресов вы можете жить,
[27:30.860 --> 27:39.020]  поставить два компа рядом, прокинуть между ними провод. Все хорошо, все замечательно. Если компьютеров
[27:39.020 --> 27:47.460]  становится слишком много, то в принципе можно тоже вручную прописывать. В Windows это делается тем,
[27:47.460 --> 27:53.540]  что вы залазите в свойства сети, кликаете мышкой много где, вы вбиваете циферки. В линукс все делается
[27:53.540 --> 27:58.580]  с текстовыми конфиг-файлами, но так, наверное, на самом деле уже давно никто не делает. Это
[27:58.580 --> 28:06.820]  жутко неудобно. Даже для серверов настройка выполняется динамически. Для этого в локальной сети
[28:06.820 --> 28:13.180]  должен присутствовать один либо несколько специальных серверов, которые называются DHCP
[28:13.180 --> 28:24.740]  сервер. Сам протокол называется DHCP, Dynamic Host Clean Protocol. Для чего нужен протокол,
[28:24.740 --> 28:30.060]  для чего нужны эти серверы? Для того, чтобы выдавать, имея пул каких-то IP-адресов,
[28:30.060 --> 28:35.500]  IP-адрес вновь подключившимся к компьютеру. Вновь подключившимся это значит, что либо вы
[28:35.500 --> 28:41.980]  подключаетесь к Wi-Fi сети, либо втыкаете кабель, либо кабель был вотнут, вы просто включаете
[28:41.980 --> 28:50.220]  компьютер. Как происходит назначение какого-то IP-адреса от сервера к клиенту? Сначала клиент
[28:50.220 --> 28:59.580]  отправляет широковещательный запрос. Здесь уже отправляет широковещательный запрос по UDP
[28:59.580 --> 29:06.380]  протоколу. Если есть UDP, то, соответственно, у нас должен быть уже настроен IP, но IP у нас еще
[29:06.380 --> 29:17.420]  не настроенный IP-адреса нет, и поэтому отправляется запрос с ненастроенного IP-шника 4.0 на специальный
[29:17.420 --> 29:23.820]  IP-шник, у которого все биты единичные. Это так называемый широковещательный запрос,
[29:23.820 --> 29:32.380]  который отправляется всем компьютерам локальной сети, его слушают все, но не все обязаны отвечать.
[29:33.180 --> 29:40.340]  Те хосты, которые выполняют функциональность DHCP сервера, как правило это роутер, но на самом деле
[29:40.340 --> 29:48.380]  роутеров может быть несколько, они в ответ тоже широковещательным образом, поскольку пока еще
[29:48.380 --> 29:56.620]  нам не сообщили свой IP-адрес, сообщают возможные варианты, какие IP-адреса свободны, и дальше клиент
[29:56.620 --> 30:02.540]  может взять какой-то IP-адрес, есть предложение несколько, то клиент может еще подумать, что такой
[30:02.540 --> 30:07.780]  IP-шник мне нравится больше, чем другой, после чего отправляет реквест уже конкретному серверу,
[30:07.780 --> 30:13.980]  что да, я хочу забрать этот IP-адрес, все, сервер подтверждает и считается, что клиент уже настроен.
[30:13.980 --> 30:24.660]  При выключении компьютера, при перезагрузке клиент может послать серверу запрос на то, что IP-адрес
[30:24.660 --> 30:33.900]  освобождается, и сервер имеет право этот IP-адрес назначить кому-то другому. Делается в Linux
[30:33.900 --> 30:42.540]  это отдельным демоном, который называется DHClient. Что это за интересный процесс? Это тот процесс,
[30:42.540 --> 30:48.140]  который вы можете наблюдать, если вы включаете компьютер, у вас загружается Linux, что-то у вас с
[30:48.140 --> 30:53.760]  сетью не очень хорошо, в некоторых дистрибутивах вы можете долго 15 секунд наблюдать, пока там
[30:53.760 --> 31:03.580]  висит надпись starting DHClient, на самом деле, если у вас systemd-дистрибутив, то это все
[31:03.580 --> 31:12.780]  делается фоном и не тормозит загрузку системы, и если у вас сеть работает, то как минимум вы
[31:12.780 --> 31:27.620]  можете видеть, что в системе болтается один процесс, который называется сбин DHClient с
[31:27.620 --> 31:35.260]  параметрами, который запущен, если его остановить, то вы потеряете IP-адрес, если у вас несколько
[31:35.260 --> 31:41.340]  сетевых интервесий, то будет несколько таких процессов. Его задача как раз то, чтобы поддержать
[31:41.340 --> 31:49.780]  в актуальном состоянии IP-адрес, периодически его обновлять, и запускается он в момент настройки
[31:49.780 --> 32:04.180]  сети. IP-адреса это все хорошо, только кто-нибудь помнит IP-адрес Яндекса? Какие IP-адреса вы помните
[32:04.180 --> 32:13.700]  вообще? 127.01, замечательно, очень простые цифры. Какие еще IP-адреса полезно помнить? На самом деле
[32:13.700 --> 32:23.660]  достаточно помнить только IP-адрес 4.8, 8.8.4.4, ну и еще 4.1, на всякий случай. Если вы помните
[32:23.660 --> 32:29.420]  только эти IP-адреса, считайте, что вы можете найти в интернете все что угодно, потому что по
[32:29.420 --> 32:40.060]  этим IP-адресам располагаются сервера, которые содержат в себе информацию о том, как имена
[32:40.060 --> 32:47.140]  превращать в IP-адреса. И на самом деле каждый DNS-сервер не обязан хранить информацию обо всем
[32:47.140 --> 32:53.740]  интернете. Если он что-то не знает, он может отправить запрос уже вышестоящему DNS-серверу,
[32:53.740 --> 32:59.420]  это иерархическая система. Иерархическая система, с одной стороны, она не обязана
[32:59.420 --> 33:05.820]  одновременно все помнить, это достаточно экономично, но есть и некоторые недостаток. Например,
[33:05.820 --> 33:11.460]  если вы покупаете какой-нибудь домен и хотите быстро свой сервер на этот домен привязать,
[33:11.460 --> 33:18.300]  но быстро не получится, нужно подождать до 15 минут, пока по всей цепочке DNS-серверов
[33:18.300 --> 33:26.140]  это новое имя, новый IP-адрес у вас раскидается. Итак, DNS — это как раз служба, которая работает
[33:26.140 --> 33:33.900]  тоже по протоколу UDP, как и протокол DHCP, предназначена для того, чтобы отвечать на вопросы,
[33:33.900 --> 33:43.900]  как найти сервер с таким-то адресом. И что это могут быть за адреса? Да, DNS может не обязательно
[33:43.900 --> 33:49.780]  использовать тот, который присвоен вашим провайтерам. Если вы используете что-то по умолчанию,
[33:49.780 --> 33:58.380]  то в файлике IT-серии.sov.conf, скорее всего, будут прописаны строчки в момент установки соединения
[33:58.380 --> 34:05.420]  на им-сервер и какой-то IP-адрес. Обычно используется два на им-сервера, на самом деле не обязательно два,
[34:05.420 --> 34:11.660]  можно и больше, достаточно иногда всего лишь одного. Это просто для того, чтобы балансировать
[34:11.660 --> 34:19.820]  нагрузку. Вот IP-адрес 81.5.91.37 — это что-то физтеховское, автоматически присвоенное маршрутизатором,
[34:19.820 --> 34:28.620]  но никто не мешает вам с правами рута открыть наредактированный этот файл, прописать IP-адрес
[34:28.620 --> 34:35.140]  4.8, чтобы всегда гарантированно использовать гугловские DNS. Только при следующем подключении к
[34:35.140 --> 34:42.260]  сети этот файл будет перезатёрт, и лучше править немножко другой файлик — tc-network-interfaces,
[34:42.260 --> 34:52.260]  там ручками прописать DNS-name-servers, и это будет использоваться, в том числе при назначении DNS-серверов
[34:52.260 --> 35:03.060]  через DHCP. Ну и как этим сервисам пользоваться? Почти везде есть команда по названиям nslookup.
[35:03.060 --> 35:15.900]  Простая, тривиальная. Вот, например, nslookup yandex.ru — неизвестный адрес, потому что я
[35:15.900 --> 35:23.340]  опечатался. А вот если вы написали правильное имя, то получаете ответ — имя сервера yandex.ru,
[35:23.340 --> 35:27.380]  адрес такой-то, имя сервера yandex.ru, адрес такой-то. Так, а к кому из них верить?
[35:27.380 --> 35:39.060]  Какой из IP-шников правильный? На самом деле все правильные. Никто не мешает в одной
[35:39.060 --> 35:45.860]  DNS-записи держать несколько IP-адресов, связанных с одним именем. Для чего это бывает полезно? Для
[35:45.860 --> 35:52.620]  балансировки нагрузки. Если у вас сервис очень популярный, высоконагруженный, то имеет смысл
[35:53.500 --> 36:00.540]  раскидать на несколько серверов. В каком порядке будут эти сервера использоваться? На самом деле
[36:00.540 --> 36:08.980]  здесь можно использовать любой из них, и браузеры обычно просто поочередно запросы отправляют каждому
[36:08.980 --> 36:17.860]  из них. Но на самом деле это только у крупных сервисов. Если вы поищете что-нибудь поменьше,
[36:17.860 --> 36:32.380]  чаще всего у вас будет только один IP-адрес. И вот кто нам выдал? Нам выдал сервер 81.5.91.37.
[36:32.380 --> 36:40.940]  Это что-то фестиловское от провайтера. Есть еще чуть более продвинутая утилита,
[36:40.940 --> 36:49.740]  которая называется Dig. Делает примерно то же самое, что и у нас Lookup, но вывод выдает более
[36:49.740 --> 37:01.980]  подробный. Результат получаем тот же самый, точнее результаты получаете в названии,
[37:02.580 --> 37:18.380]  точку. Что это точка в конце означает? На самом деле правильное доменное имя, по всем правилам
[37:18.380 --> 37:23.340]  записанное, заканчивается на символ точки. То, что вы в браузерах эту точку в конце не вводите,
[37:23.340 --> 37:29.620]  но просто сделано для удобства, и все к этому привыкли. Но по стандарту точка должна быть в
[37:29.620 --> 37:39.340]  конце то же самое. Это полное имя. В чем особенность отличия утилиты Dig от NSLookup? Кроме того,
[37:39.340 --> 37:46.700]  что ее вывод отличается внешне. Принципиальным отличием еще является то, что я могу явным
[37:46.700 --> 37:53.900]  образом в таком виде собакой и дальше циферки указать, какой именно DNS-сервер я хочу использовать,
[37:53.900 --> 38:02.900]  чтобы получить какую-то запись. В данном случае Google нас не обманывает. Результат дает тот же
[38:02.900 --> 38:15.420]  самый. Кстати, фистеховский сервер нам дополнительно выдал еще какие-то потроха внутренние. Для чего
[38:15.420 --> 38:22.020]  бывает полезно использовать какой-то конкретный DNS-сервер, к которому вы доверяете? Банально вы в
[38:22.020 --> 38:26.660]  метро подключаетесь. В метро сейчас тоже стало непопулярно. Кто-нибудь вообще пользуется в метро
[38:26.660 --> 38:34.580]  или в электричке Wi-Fi, или вы уже не пользуетесь и правильно делаете. Если вы пользуетесь каким-то
[38:34.580 --> 38:42.660]  общедоступным бесплатным Wi-Fi, понятно, что бесплатный сервер только мишеловки. Сейчас уже не так
[38:42.660 --> 38:50.460]  популярно, как раньше, а раньше любили просто подменять контент, вставлять рекламу. Заходите на
[38:50.460 --> 38:56.980]  какой-нибудь сайт, вам внедряется какой-нибудь баннер от московского метро. Сейчас это делать
[38:56.980 --> 39:02.660]  сложнее, потому что используется практически посеместное протокол SSL, и просто взять и
[39:02.660 --> 39:10.140]  подменить что-то не получится. Один из способов как это сделать, не используя дорогостоящую
[39:10.140 --> 39:18.420]  интроспекцию трафика, это просто перенаправлять ваши запросы DNS на какой-то внутренний сервер
[39:18.420 --> 39:26.220]  рекламодателя, который будет вам выдавать какой-то свой контент, ну и использовав в качестве
[39:26.220 --> 39:32.020]  прокси, чтобы выдать какое-то настоящее содержимое. В общем-то не очень безопасно.
[39:32.020 --> 39:38.020]  Но DNS это один из способов как обезопаситься, хотя он явно далеко недостаточный.
[39:38.020 --> 39:52.820]  Что еще полезно надо знать про DNS? Записи бывают разных типов. В выводе NS Lookup вы видели только
[39:52.820 --> 40:08.380]  IP-адрес и больше ничего. Если посмотреть на тот же самый Яндекс.ру, то можно увидеть намного
[40:08.380 --> 40:18.780]  более интересное что-то. Яндекс.ру, хотя не очень интересно, здесь записи типа A, это записи,
[40:18.780 --> 40:29.540]  так точнее, видимо, я что-то у утилиты DIG не все спросил, там нужна опция, чтобы она все выдала.
[40:29.540 --> 40:46.460]  Qtype, давайте запрошу записи вида MX. Утилит DIG надо еще я указывать. В общем, бывают разные
[40:46.460 --> 40:55.940]  виды записей. Например, запись типа A, это обычная запись, которая используется, например,
[40:55.940 --> 41:02.700]  SSH сервером, telnet сервером, HTTP сервером. То есть основная запись, которая содержит IPv4 адрес.
[41:02.700 --> 41:09.860]  Куда отправить запрос? Из браузера. Куда отправить? Нужно отправить данные при попытке подключения по
[41:09.860 --> 41:19.540]  SSH. Для чего еще может использоваться имя яндекс.ру? Например, если написать символ собачки перед
[41:19.540 --> 41:26.180]  яндекс.ру, то мы что получаем? Еще какие-то буковки перед символом собачки. Мы получаем почтовый адрес.
[41:26.180 --> 41:34.780]  И для этого как раз используется другой вид записи под названием MX. Он может иметь необязательно
[41:34.780 --> 41:40.620]  IP адрес, он может иметь отсылку на какой-то другой реальный сервер. Можно выяснить его IP адрес
[41:40.620 --> 41:46.100]  точно так же обычным образом. И не факт, что он совпадает с IP адресом яндекс.ру. То есть у нас
[41:46.100 --> 41:52.220]  бывают разные типы записей. Кроме почты, есть еще отдельные типы записей, например, для протокола
[41:52.220 --> 42:00.940]  Jabber, который когда-то использовался Google Talk. Сейчас его переймали в Google Meet. Ну и так далее.
[42:00.940 --> 42:11.300]  То есть бывают сервисы, которые могут иметь свои отдельные типы записей. Адрес 4А обычно используется
[42:11.300 --> 42:20.860]  для синонима адреса А, но только для IPv6. То есть он содержит не 32-битное значение, а 128-битное.
[42:20.860 --> 42:27.300]  И еще может быть ситуация, что у вас на одном физическом сервере болтаются несколько сайтов.
[42:27.300 --> 42:33.580]  Соответственно, сервер должен иметь несколько имен. И дополнительные алиасы создаются с помощью
[42:33.580 --> 42:43.460]  записей типа Cname, которые содержат вовсе не IP адреса, а просто обычные тексты, отсылки на какие-то
[42:43.460 --> 42:54.540]  другие имена хостов. С DNS разобрались. Это то, для чего используется UDP. В реальной жизни, даже если
[42:54.540 --> 42:59.700]  вы не пользуетесь торрентами, не пользуетесь VPN и живете в каменном веке, все равно с протоколом UDP вы
[42:59.700 --> 43:10.420]  сталкиваетесь как минимум на уровне DNS и на уровне протокола DHCP. Следующий тип низкого уровня
[43:10.420 --> 43:17.380]  взаимодействия, помимо UDP, это еще более низкий уровень, когда вы целиком можете прочитать
[43:17.380 --> 43:28.180]  содержимое всего пакета, например, внутри IP пакета, включая заголовки TCP, UDP, или придумать
[43:28.180 --> 43:42.940]  свой протокол. Либо вы можете на системе Linux придумать свой протокол вместо IP. Для этого вам
[43:42.940 --> 43:53.220]  нужно будет залазить уже внутрь в кадра Ethernet. Нисколько не доступ к IP. Могут делать не все,
[43:53.220 --> 44:00.900]  либо пользователи root, либо, помните, Linux Capability, когда вы настраиваете на какой-то
[44:00.900 --> 44:08.940]  бинарный файл дополнительные атрибуты, это расширенные атрибуты файлов, которые позволяют,
[44:08.940 --> 44:13.980]  не повышая привилегий до рта, выполнять какую-то отдельную функциональность. Одна из
[44:13.980 --> 44:22.940]  функциональностей Capnetro позволяет на низком уровне открывать сокеты и дальше читать из
[44:22.940 --> 44:31.980]  этих сокетов данные, которые тупо читаете из сетевой платы, забираете целиком и смотрите
[44:31.980 --> 44:40.340]  на их заголовки, дальше с ними что-то делать. При этом они могут содержать целиком данные TCP,
[44:40.340 --> 44:47.820]  UDP, но дополнительно можно еще включить, чтобы можно было модифицировать заголовки IP.
[44:47.820 --> 44:55.700]  И еще более низкий уровень. Это уже ковыряться на уровне кадров Ethernet, то есть вытаскивать всю
[44:55.700 --> 45:02.100]  полезную нагрузку, которая затем заворачивает Ethernet пакет, но еще ниже опускаться тут уже
[45:02.100 --> 45:07.540]  на программном уровне невозможно, это требует уже аппаратных средств. Для этого используется
[45:07.540 --> 45:16.980]  пространство имен Packet. Понятно, что если вы будете из сокета читать все на самом низком
[45:16.980 --> 45:24.180]  уровне, то вы будете ловить абсолютно все, любой мусор, включая ARP. Чем это плохо? Тем,
[45:24.180 --> 45:30.300]  что у вас будет огромное количество данных, и здесь вы можете уже сильно запутаться.
[45:30.300 --> 45:37.940]  И если у вас есть какое-то отдельное пространство имен, в частности, когда вы
[45:37.940 --> 45:43.780]  используете адрес FamilyUnix, в качестве адреса вам нужно указывать имя файла. Когда пространство
[45:43.780 --> 45:50.060]  имен интернет, вам нужно указывать IP-адрес плюс номер порта, и что-то подобное есть для пространства
[45:50.060 --> 46:02.660]  имен пакетного уровня. Именно там нужно указывать номер сетевой платы. Когда у вас появляются
[46:02.660 --> 46:08.180]  некоторые сетевые платы, появляются в том числе и динамически, потому что сетевой платы вы можете
[46:08.180 --> 46:16.620]  подключить через USB. ЕДО присваивает им какой-то порядковый номер. Если вы наберете команду
[46:20.060 --> 46:33.020]  под Linux, назовем ее EF-config. Под Linux нет только команды, это только под Mac 3BSD. Точнее,
[46:33.020 --> 46:41.580]  можно поставить либо IP-L, то получите список сетевых интерфейсов, которые у вас в текущий момент
[46:41.580 --> 46:49.340]  настроены. Например, Loopback-интерфейс 127.0.1, сетевая плата. И вот у них есть порядковые номера 1,
[46:49.340 --> 46:56.980]  2 и так далее. Вот у них есть еще сетевую плату USB, либо в виртуалке, поменяйте настройки,
[46:56.980 --> 47:02.380]  появится какая-то еще другая сетевая плата. Они могут быть либо настроеными, либо не настроеными.
[47:02.380 --> 47:21.180]  У них есть порядковые номера, все это доступ к ним осуществляется. Седьмой раздел Man страницы
[47:21.180 --> 47:29.700]  NetDevice дает ссылку на системный вызов под названием IOCTL, с помощью которого можно отправлять запросы и
[47:29.700 --> 47:37.300]  по именам сетевых интерфейсов, соответственно, получать их порядковые номера, которые дальше
[47:37.300 --> 47:44.500]  можно использовать для RAV пакетов. Для чего я вам все это показываю? Для того, чтобы показать
[47:44.500 --> 48:02.700]  реализацию на низком уровне, как можно просто смотреть на происходящее в вашей сетевой плате.
[48:02.700 --> 48:14.460]  Так, создаем socket, который имеет пространство non-packet и предназначен для сырой передачи данных.
[48:14.460 --> 48:22.380]  Если указать третий параметр, который выполняет роль фильтра, что мы отловливаем все Ethernet пакеты,
[48:22.380 --> 48:29.420]  то будете ловить все. Опасненько, но ладно. На самом деле в прот такой код пускать очень хорошо.
[48:29.420 --> 48:38.540]  Затем вам нужно выполнить операцию bind, то есть связать ваш socket с каким-то адресом, и для этого
[48:38.540 --> 48:47.180]  нужно выяснить индекс, порядковый номер вашей сетевой платы, делается с помощью стен вызова IOCTL,
[48:47.180 --> 48:57.580]  то есть вы знаете имя сетевой платы. Сетевой платой номируют в Linux, которые в Wi-Fi,
[48:57.580 --> 49:05.860]  обычно именуются WLAN, какая-то циферка 0, 1, 2, чаще всего 0, сетевая плата Wi-Fi всего 1.
[49:05.860 --> 49:15.460]  Если это Ethernet, то либо ETH и циферки 0, 1, 2 и так далее, либо на некоторых устройствах,
[49:15.460 --> 49:22.220]  если у вас сетевая плата сделана на одном чипе, но при этом имеет несколько выводов,
[49:22.220 --> 49:31.740]  то может называться EMP 0, 1, 2, это порядковый номер сетевой платы, и если она имеет несколько
[49:31.740 --> 49:41.780]  разъемов, то SYNC номер 0, 1, 2, 3, 4, 5 и так далее. Вы знаете какое-то имя, дальше вы это имя
[49:41.780 --> 49:46.980]  используете для того, чтобы выяснить индекс, все, ну а дальше стандартный адрес, адрес family,
[49:46.980 --> 49:57.660]  протокол, то есть фильтр, который вы хотите навешать, индекс, связываете байном, ну а дальше
[49:57.660 --> 50:09.020]  тупо обычным реквам читаем какие-то данные, оттуда мы можем вытащить, поскольку это будут IP пакеты,
[50:09.020 --> 50:19.420]  IP адрес по определенному смещению, ну и зачем показывать код, когда можно продемонстрировать
[50:19.420 --> 50:28.420]  его работоспособность. Итак, компилируем, скомпилироваться оно скомпилировалось,
[50:28.420 --> 50:35.460]  запускаться уже не хочет. Operation node permight на стадии создания сокета, почему это происходит?
[50:35.460 --> 50:46.540]  Ну потому что я не являюсь пользователем root, зато я могу разрешить обычному неприлегированному
[50:46.540 --> 50:55.980]  пользователю создавать низкоуровневые сокеты, setcap, capnet, troll. Так, вспоминаем capabilities,
[50:55.980 --> 51:03.500]  какие права мне нужно тут навешать, какие флаги. Во-первых, флаг permissive, очевидно,
[51:03.500 --> 51:16.060]  должен быть. Что еще? Вот я про одну буквенную флаги сейчас как раз и спрашиваю. Permissive,
[51:16.060 --> 51:25.980]  чтобы разрешить, что еще нам нужно? На счет минус E, так нужно или не нужно?
[51:25.980 --> 51:40.220]  Флаг E тоже нужен. Почему? Потому что в начале нашей программы мы уже создаем сокет,
[51:40.220 --> 51:47.900]  то есть предполагаем, что права у нас должны быть проставлены. Мы тут не лазим с помощью
[51:48.900 --> 51:57.500]  на проверку флагов. Так, экзампл 1. Тут, естественно, требуются уже права врута.
[51:57.500 --> 52:08.620]  Так, главное не забывать свою пароль. Это очень грустно. Ну и после этого можно запустить
[52:08.620 --> 52:13.020]  программу. Так, ну сейчас она будет мне протоколировать все, что происходит по сети,
[52:13.020 --> 52:20.060]  на сетевом интерфейсе, который там был указан. Но для этого нужно выполнить консистенцию операцию,
[52:20.060 --> 52:32.660]  но пусть будет тот же самый DIG к адресу 4.8 для index row. А тут еще какое-то взаимодействие идет.
[52:32.660 --> 52:43.020]  Какой-то IP адрес 10.211. А, это SSH. Все. В общем, вы можете ловить все пакеты,
[52:43.020 --> 52:48.420]  лазить в их содержимое. Вот для этого требуется повышение привилегий, потому что было бы странно,
[52:48.420 --> 52:55.220]  если бы обычный пользователь мог залезть в произвольный пакет, который отправляется по сети.
[52:55.220 --> 53:07.860]  Так делать нехорошо и небезопасно. Так, зачем вообще это может понадобиться вам? Есть такая
[53:07.860 --> 53:12.980]  замечательная утилита, называется TCP dump, которая делает примерно то же самое,
[53:12.980 --> 53:24.660]  как программка, которую я вам сейчас показал. Утилита Wireshark, помните? Да, только на семинарах.
[53:24.660 --> 53:35.980]  В общем, есть такая замечательная утилита Wireshark, которая позволяет анализировать все,
[53:35.980 --> 53:41.580]  что происходит по сети. На самом деле есть еще консольный вариант утилита,
[53:41.580 --> 53:49.500]  который делает все то же самое, называется TCP dump. Вот пример. Как сделать так, чтобы ловить все,
[53:49.500 --> 54:05.780]  что происходит у вас через сетевой интерфейс TCP dump emp0s5. И удовлетворяет условиям,
[54:05.780 --> 54:14.820]  что адрес назначения это 4.8, порт назначения 53.53, это номер порта для DNS сервера. Давайте
[54:14.820 --> 54:33.580]  будем ловить все такие запросы. Конкретному IP-адресу. ДСТ порт 53. Но здесь требуется правобога.
[54:33.580 --> 54:55.980]  ДСТ 4.8. Естественно, нужно что-нибудь отправить. Видно, что отправили какой-то запрос, порта,
[54:55.980 --> 55:04.740]  номер такого-то, с запросом, который TCP dump понял, что это DNS, и смог его разобрать,
[55:04.740 --> 55:12.460]  что мы спрашиваем запись типа A на имя yandex.ru. Тоже самое вы можете писать в красивом виде
[55:12.460 --> 55:22.340]  внутри окошка утилиты Wireshark, которая с графическим интерфейсом. Вот как такую штуку сделать? Один
[55:22.340 --> 55:32.140]  из вариантов это использовать низкоуровневые пакеты. Вы тоже самое можете написать в утилите
[55:32.140 --> 55:45.180]  Wireshark, только тут есть одна маленькая тонкость. Вот Wireshark. Отвратительно, конечно, на проекторе.
[55:45.180 --> 55:52.100]  В общем, для тех, кто не видит, что происходит на проекторе, это утилита Wireshark. Я открываю
[55:52.100 --> 55:57.820]  сетевой интерфейс, тут куча всего болтается, там логи того, что болтается по CP, я могу писать
[55:57.820 --> 56:07.220]  фильтры. Да, вот этот Wireshark, он вовсе не под Linux запущен, он запущен под Mac. А если внимательно
[56:07.220 --> 56:18.420]  посмотреть седьмой раздел по пространству имен пакет, тут есть всякие Linux специфичные
[56:18.420 --> 56:27.980]  заголочные файлы. Если я тоже самое попрошу седьмой раздел по пакет, уже под macOS, ничего такого нет.
[56:27.980 --> 56:38.540]  Если я посмотрю ман по socket, то опять же есть свои пространства имен, которые могут частично
[56:38.540 --> 56:44.700]  пересекаться с Linux, могут не пересекаться, но никакого пространства имен пакет не существует.
[56:44.700 --> 56:49.860]  Тем не менее, Wireshark одинаково работает, так под Linux, так под macOS. То есть, на самом деле,
[56:49.860 --> 56:57.020]  то, что я вам рассказываю про перехват на низком уровне каких-то пакетов, я вам тут немножко обманул
[56:57.020 --> 57:06.940]  про реальный use case. И утилиты типа Wireshark и TCPDump, они работают немножко по-другому. Давайте
[57:06.940 --> 57:20.860]  посмотрим на запрос, что мы хотим к тому же утилите TCPDump. Так, destination port 4.8,
[57:20.860 --> 57:29.620]  ну хорошо. И вот если я добавлю опцию минус D, то наша программа превратится в что-то похожее на
[57:29.620 --> 57:37.460]  языке ассемблера. Пример, который приведен на слайде, примерно такой же. То есть,
[57:37.460 --> 57:46.380]  нам нужно, он немного отличается. Так, допустим, мы хотим отловить все пакеты, которые содержат
[57:46.380 --> 57:53.300]  заголовки UDP и IP. Да, вот через точки запятой, это я уже вручками написал комментарии, это не вывод
[57:53.300 --> 58:02.940]  TCPDump, что он здесь содержится. Нам нужно загрузить какое-то число 12, выполнить инструкцию jump or
[58:02.940 --> 58:14.980]  equal с каким-то числом 86DD. Что такое 86DD? Это всего лишь порядковый номер протокола по названиям IPv6,
[58:14.980 --> 58:21.380]  то есть та константа, которая фигурирует в заголовке Ethernet. Дальше мы перескакиваем к строчке либо 6,
[58:21.380 --> 58:32.140]  если истина, либо false, тогда на строчку номер 2. На строчке номер 2 мы проверяем, что если какое-то
[58:32.140 --> 58:43.940]  странное значение, где-то там, а, значение которое по смещению 12 совпадает с 0x800, это просто 16-битное
[58:43.940 --> 58:53.180]  значение, которое указывает, что в заголовке Ethernet у нас используется протокол IPv4. По поводу того,
[58:53.180 --> 59:01.540]  откуда берутся эти константы, еще раз я вернусь к слайду, вот этом, там где заголовок Ethernet.
[59:01.540 --> 59:07.260]  С глушным файлом нет Ethernet.h, как раз содержат все эти константы, он универсальный под разной
[59:07.260 --> 59:20.180]  операционной системы. Дальше мы проверяем, является он IPv4 адресом, если ОК, то идем дальше. Затем нам
[59:20.180 --> 59:25.900]  нужно проверить, что он является действительно протоколом UDP. Для этого мы загружаем 23 байт,
[59:25.900 --> 59:32.740]  вот 12 байт, 23 байт, это все относительно начала пакета. Загружаем 23 байт, смотрим на какую-то
[59:32.740 --> 59:40.820]  константу, 17 это UDP, 6 это TCP, это все можно посмотреть обычным Wireshark, тут ничего нового для вас
[59:40.820 --> 59:50.100]  нет. Ну и возвращаем уже дальше какое-то большое значение, либо число 0. Что это такое? Это некоторая
[59:50.100 --> 59:57.780]  маленькая программка. Заметьте, что это не язык ассемблера RX86, это не язык ассемблера ARM. Это
[59:57.780 --> 01:00:03.100]  какой-то свой язык, похожий на язык ассемблера, который описывает маленькую программку,
[01:00:03.100 --> 01:00:11.300]  которая называется фильтр. Классический BPF фильтр, от слова Berkeley Packet Filter, существует
[01:00:11.300 --> 01:00:19.940]  практически в любой UNIX системе. Это очень старая реализация, для чего она нужна. И вот эти
[01:00:19.940 --> 01:00:26.180]  программки выполняются достаточно быстро. Для чего это нужно? Для того, чтобы выполнять фильтрацию и
[01:00:26.180 --> 01:00:32.300]  в зависимости от того, что вам прилетело по сети, либо принимать пакет, либо не принимать, но если вы
[01:00:32.300 --> 01:00:40.100]  принимаете, вы можете с ним делать что-то дальше. Что такое? Отдельная инструкция. То есть вот каждая
[01:00:40.100 --> 01:00:46.460]  строчка от того кода, который я вам привел, она представляет, может быть транслирована в некоторую
[01:00:46.460 --> 01:00:55.380]  риск-инструкцию. Что такое риск инструкции? Чем не от сыск инструкции отличаются? Длина инструкции,
[01:00:55.380 --> 01:01:01.740]  риск это значит, что каждая инструкция имеет какой-то фиксированный размер в отличие от сыск. Каждая
[01:01:01.740 --> 01:01:07.940]  инструкция содержит некий обкод, что это представляет собой эта инструкция. Два восьми битных значений
[01:01:07.940 --> 01:01:15.500]  это номера строк в случае, если она является условием, то куда надо прыгать, если true либо false.
[01:01:15.500 --> 01:01:20.100]  Ну и возможно может иметь какое-то константное значение, например, для инструкции сравнения,
[01:01:20.100 --> 01:01:28.180]  загрузки и так далее. Не более чем тряслеубитное. Общий вид инструкции по взаимодействию с
[01:01:28.180 --> 01:01:34.220]  очень старого процессора, которого уже давно не существует. И вот такие инструкции интерпретируются
[01:01:34.220 --> 01:01:40.900]  некоторой виртуальной машиной, которая находится внутри ядра. То есть весь этот код выполняется
[01:01:41.620 --> 01:01:47.340]  сначала транслируется во что-то, потом выполняется внутри ядра. Вот чуть более сложный пример,
[01:01:47.340 --> 01:01:56.980]  как отловить все пакеты, которые отправляются на гугловский DNS, который имеет адрес 4.8. Как
[01:01:56.980 --> 01:02:02.460]  эта штука работает? По смещению в 12 байт относительно начала пакета мы смотрим,
[01:02:02.460 --> 01:02:09.580]  что это у нас за пакет такой. Если это IPv4, то продолжаем дальше. Если нет, значит не судьба,
[01:02:09.580 --> 01:02:15.860]  хотя можно обобщить на IPv6 тоже. Дальше по 23 смещению относительно начала пакета мы смотрим,
[01:02:15.860 --> 01:02:23.980]  чем он является UDP или TCP. Нас интересует только UDP. Дальше мы загружаем по очередному смещению,
[01:02:23.980 --> 01:02:32.700]  которое мы посчитали или посмотрели в аэршарке, четырех байтное значение IP адреса. Напомним,
[01:02:32.700 --> 01:02:41.100]  что в IPv4 у нас IP адрес просто какое-то 32 битное значение. Дальше сверяем с константой 8.8.8.8. Очень
[01:02:41.100 --> 01:02:48.060]  красивая константа. В случае успеха мы возвращаем значение минус 1, в случае неуспеха значение 0.
[01:02:48.060 --> 01:02:54.220]  Каждая функция, реализованная на Berkeley Packet Filter, должна возвращать количество байт,
[01:02:54.220 --> 01:03:02.380]  сколько нужно пропустить. Если это число 0, значит пакет целиком отклоняется. Значение минус 1,
[01:03:02.380 --> 01:03:10.140]  оно просто превращается в 32 битное значение по правилу обратного дополнительного кода максимально
[01:03:10.140 --> 01:03:19.420]  возможное значение, то есть 2 в 32 степени минус 1. И, значит, мы тем самым пакет пропускаем.
[01:03:19.420 --> 01:03:26.300]  Вот что с этим кодом, написанным на языке псевдо ассемблера, можно сделать? Очевидно,
[01:03:26.300 --> 01:03:33.020]  его можно во что-то транслировать. Вот эти самые структурки. Как это сделать? Открываем
[01:03:33.020 --> 01:03:40.660]  документацию, которая находится в исходниках ядра Linux. Дальше по этой документации смотрим на
[01:03:40.660 --> 01:03:48.340]  команды, смотрим их обходы, но так делать не очень удобно. Но если есть какой-то язык, пусть даже
[01:03:48.340 --> 01:03:55.180]  не совсем полноценный, то видимо есть компилятор, который выполняет транслирацию с этого языка во что-то
[01:03:55.180 --> 01:04:02.220]  более пригодное к использованию. И находится этот компилятор, как ни странно, в исходниках ядра
[01:04:02.220 --> 01:04:09.820]  Linux. И для того, чтобы его получить, вам нужно скачать исходники ядра. Эта утилита, которая
[01:04:09.820 --> 01:04:14.500]  тут требуется для компиляции, она не входит в стандартную поставку дистрибутивов. Так,
[01:04:14.500 --> 01:04:21.220]  исходники ядра Linux. Качаются достаточно легко, просто легко находятся, все open-source, ничего не
[01:04:21.220 --> 01:04:39.300]  закрыто. Ой, как это все выглядит на черном экране, отвратительно. Итак, ядро Linux,
[01:04:39.300 --> 01:04:46.100]  стабильная версия, которая была выкачана сегодня, она более свежая, чем тот Linux,
[01:04:46.100 --> 01:04:50.820]  под которым я все показываю, но это не страшно. Что вообще можно сделать с исходниками ядра Linux?
[01:04:50.820 --> 01:04:56.660]  Первым делом, когда вы скачали, вы даже не можете его скомпилировать. У нас сначала настроить,
[01:04:56.660 --> 01:05:14.400]  делается это либо команды make-default-config, создает config или dev-config, создает файл по
[01:05:14.440 --> 01:05:20.960]  названиям .config, который основывается на дефолтной конфигурации сборки. Если вам нужно собрать ядро
[01:05:20.960 --> 01:05:39.360]  под себя, делайте make-menu-config. Так, you display to small. Ну ладно, сделаем чуть побольше букву.
[01:05:39.360 --> 01:05:46.160]  Появляется такая менюшка. Ой, опять же вы ее не видите, но я надеюсь на видеозаписи это будет
[01:05:46.160 --> 01:05:52.000]  лучше видно. Тут вы можете пробежаться по всем настройкам ядра, которые включить, выключить,
[01:05:52.000 --> 01:05:57.560]  что-то собрать в виде отдельного модуля, что-то вкомпилировать внутрь ядра. В общем, огромное
[01:05:57.560 --> 01:06:05.440]  количество параметров. После этого, самое интересное, вы запускаете make и что дальше идете делать?
[01:06:05.440 --> 01:06:16.360]  Идете спать. Это долго. Либо make-j20, чтобы задействовать все 20 ядер своего ноутбука. Это будет
[01:06:16.360 --> 01:06:23.360]  уже быстрее, но я уже начинал собирать, поэтому у меня достаточно быстро соберется. В общем,
[01:06:23.360 --> 01:06:30.520]  происходит достаточно долго, но не суть важна. Более интересно, что в исходниках ядра есть разные
[01:06:30.520 --> 01:06:36.960]  тулзы, разная документация, которую кроме как в исходниках ядра вы не найдете. А именно,
[01:06:36.960 --> 01:06:47.360]  во-первых, вы можете зайти сначала в раздел documentation. Там в этом разделе documentation есть файлик,
[01:06:47.360 --> 01:07:13.160]  нет, networking, и там есть файл по названиям BPF, нет, не BPF. Фильтр,
[01:07:13.160 --> 01:07:25.720]  EMAX, фильтр, RST. Рестрактарик текст, то есть плейн текст с некоторой минимальной разметкой.
[01:07:25.720 --> 01:07:32.480]  И, пожалуйста, все очень подробно про BPF, даже с примерами, как это написать в псевдокодах.
[01:07:32.480 --> 01:07:38.600]  Псевдокод имеет в виду то, что у нас 16-битное значение команда, 2 8-битных значения,
[01:07:38.600 --> 01:07:44.440]  константорство убитное. Пишется жутко, давайте лучше это нагенерируем. Еще что интересного,
[01:07:44.440 --> 01:07:54.920]  кроме раздела documentation есть каталог под названием tools. В этом тулз у нас есть BPF,
[01:07:54.920 --> 01:08:02.840]  компилируем. Что-то собралось, что-то не собралось. Не собралось, потому что тут надо ставить еще
[01:08:02.840 --> 01:08:11.160]  дополнительные библиотеки к тулзам. Самое главное тут файлик под названием BPF, подчерканье ASM,
[01:08:11.160 --> 01:08:29.680]  который мы скопируем себе куда-нибудь поближе. Он нам еще пригодится. Теперь что мы можем с
[01:08:29.680 --> 01:08:37.280]  помощью этого файлика сделать? Мы можем написать программу filter в обычном текстовом виде. Все то
[01:08:37.280 --> 01:08:43.360]  же самое, что я вам проведал на слайде. Маленькая простая программа filter, которая применяется
[01:08:43.360 --> 01:08:49.920]  к каждому входящему визуально этот пакету, смотрит на то, что внутри него содержится,
[01:08:49.920 --> 01:08:56.080]  IP не IP, UDP не UDP, какой у нее IP адрес. Либо принимает этот пакет, либо отклоняет.
[01:08:56.080 --> 01:09:00.960]  Что мы можем сделать с этой программой на Assembler? Наверное,
[01:09:00.960 --> 01:09:12.440]  скормить этой тулзе под названием BPF, ASM. Фильтр получаем. Какие-то циферки на выходе,
[01:09:12.440 --> 01:09:17.800]  какие-то байтики. В таком виде, наверное, не очень осмыслены. Есть замечательный флаг,
[01:09:17.800 --> 01:09:30.160]  минус S или минус C. Получаем вывод немножко в другом виде. На что это похоже? Очевидно,
[01:09:30.160 --> 01:09:38.640]  это какие-то структурки с циферками, соответствующие тем командам, которые мы
[01:09:38.640 --> 01:09:46.360]  можем куда-нибудь теперь вкомпилировать, и будет нам счастье. Запишем это в какой-нибудь файл.
[01:09:46.360 --> 01:09:53.160]  Пока не записываем. Пример программы, которая теперь выполняет фильтрацию,
[01:09:53.160 --> 01:09:58.240]  мы уже используем пакетного фильтра. Точно так же, создаем сокет на низком уровне,
[01:09:58.240 --> 01:10:04.520]  присоединяем его куда-нибудь. Все то же самое, что и в предыдущем примере.
[01:10:04.520 --> 01:10:12.600]  Теперь нам нужно подготовить некоторую программу в виде последовательности инструкции.
[01:10:12.600 --> 01:10:22.500]  Сок-фильтр. Каждый элемент структуры – это код плюс 2 байта, это смещение инструкции для
[01:10:22.500 --> 01:10:31.960]  true, смещение для false либо константа. Затем мы эту программу прицепляем к нашему сокету,
[01:10:31.960 --> 01:10:39.920]  используя стейн вызов сет сок-опт. Если программа корректная, то все замечательно.
[01:10:39.920 --> 01:10:46.360]  К нашему сокету прицепился фильтр. Дальше мы читать сможем только нужные нам пакеты,
[01:10:46.360 --> 01:10:51.040]  все остальное будет отбрасываться. Либо если что-то некорректное, то сет сок-опт вернет
[01:10:51.040 --> 01:10:57.520]  какую-то ошибку. Если ошибка, значит надо как-то на это реагировать. Самое интересное,
[01:10:57.520 --> 01:11:07.800]  как теперь сделать эту программу. У нас есть транслятор из псевдосемблера в последовательности
[01:11:07.800 --> 01:11:19.400]  вот таких структур. Что делает конструкция решетка include? Что делает? Фактически это копия пасты
[01:11:19.400 --> 01:11:26.240]  control-c, control-v. Если я от кого-то из вас на комиссии услышу, что решетка include подключает
[01:11:26.240 --> 01:11:32.560]  библиотеку, это означает, что вас надо отчислять. Предупреждаю сразу. Такие перлы я уже слышал.
[01:11:32.560 --> 01:11:37.760]  На комиссии это очень странно. Решетка include просто делает тупое включение текста и все,
[01:11:37.760 --> 01:11:45.360]  больше ничего. Но и заодно там еще выполняется процессинг всех внутренних include. В оси никакой
[01:11:45.360 --> 01:11:50.400]  не подключение библиотека. То есть мы можем сделать какой-то текст. Решетка include может
[01:11:50.400 --> 01:11:56.680]  подстричаться где угодно, в любом произвольном месте. Поэтому сохраняем вывод нашего ассемблера
[01:11:56.680 --> 01:12:08.160]  в текстовый файл, который будет дальше включен в наш example2.com. Теперь можно скомпилировать
[01:12:08.160 --> 01:12:29.360]  нашу программу. Запускаем, прежде чем запустить ее. То же самое с setcap, row, example2.
[01:12:29.360 --> 01:12:52.680]  Запускаем и отправляем запрос на яндекс.ru. Мы поймали среди огромного количества пакетов,
[01:12:52.680 --> 01:13:01.560]  которые чем угодно инициируются. Поймали ровно один пакет с текущего IP-адреса на сервер 4.8.
[01:13:01.560 --> 01:13:11.480]  Делается это все внутри ядра. Что хорошего в этом пакетном фильтре и что плохого? На самом деле
[01:13:11.480 --> 01:13:17.880]  хорошего в нем то, что он работает внутри ядра и вам не приходится, потому что пакетов может
[01:13:17.880 --> 01:13:21.360]  проходить много. Не приходится копировать постоянно что-то из пространства ядра,
[01:13:21.360 --> 01:13:26.320]  в пространство пользователей, в пространство ядра. Зачем это лишнее взаимодействие? На пакет
[01:13:26.320 --> 01:13:33.480]  прилетел в ядре, ядро его отклонило и все, замечательно. Работает намного быстрее. Есть,
[01:13:33.480 --> 01:13:40.080]  конечно, некоторые ограничения. Если что-то у нас работает в ядре, что-то, что по идее может
[01:13:40.080 --> 01:13:45.520]  запустить даже обычный пользователь, даже не обязательно root. Чем это опасно? Можно написать
[01:13:45.520 --> 01:13:53.880]  какую-то программу, которая будет... что делать? API достаточно ограниченный, вы просто принимаете
[01:13:53.880 --> 01:13:57.760]  пакет или отклоняете, то есть просто возвращаете какое-то число. Но вы можете написать какую-нибудь
[01:13:57.760 --> 01:14:03.600]  программу бесконечный цикл. Чем это плохо? Прилетает какой-нибудь пакет, у вас бесконечный цикл,
[01:14:03.600 --> 01:14:12.000]  который выполняется ядром, а не в полезном пространстве. И все, хана системе. На самом деле тут
[01:14:12.000 --> 01:14:19.120]  проектировали фильтр далеко не дураки, они предусмотрели защиту. Чтобы программа не выполнялась
[01:14:19.120 --> 01:14:25.640]  бесконечно долго, циклы реализовать тут невозможно вообще никак. То есть у вас есть... допускается
[01:14:25.640 --> 01:14:32.880]  инструкции jump, но они допускают jump только вперед. Назад jump сделать невозможно. Для чего? Для того,
[01:14:32.880 --> 01:14:38.560]  чтобы нельзя было организовать циклы. Ну и размер программы у нас тоже имеет осмысленный размер,
[01:14:38.560 --> 01:14:45.200]  не более чем 4096 инструкций. Считается, что для простых фильтров сетевых это более чем достаточно.
[01:14:45.200 --> 01:14:52.800]  И как выполняется загрузка программы? Загрузка программы на самом деле достаточно тривиальная
[01:14:52.800 --> 01:14:59.120]  вещь. Вы уже что-то... иметь какой-то скомпилированный код, загружать ничего особо не нужно, у вас в памяти
[01:14:59.120 --> 01:15:05.240]  уже что-то находится. После этого в момент... все этот опыт, когда вы подключаете к программу,
[01:15:05.240 --> 01:15:12.880]  сначала выполняется верификатор BPF, который проверяет, что ваш код является безопасным.
[01:15:12.880 --> 01:15:19.080]  И верификатор имеет полное право отклонить вашу программу. В этом случае сетцокопт вам скажет
[01:15:19.080 --> 01:15:24.840]  ошибку, не очень осмысленную, конечно, инвалид-аргумент. Могли бы что-нибудь более читабельное сделать.
[01:15:24.840 --> 01:15:32.080]  Значит ваша программа, скорее всего, просто не прошла верификацию, потому что верификатор
[01:15:32.080 --> 01:15:36.800]  посчитал ее потенциально опасной. Потенциально опасной она либо слишком большая, либо содержит
[01:15:36.800 --> 01:15:45.520]  прыжки назад. После этого, уже если программа успешно прошла верификацию, она подключается к вашему
[01:15:45.520 --> 01:15:58.080]  сокету и начинает работать уже в режиме ядра. Это достаточно безопасный механизм. Но чем эта
[01:15:58.080 --> 01:16:04.800]  конструкция плохая, достаточно старая. Несмотря на то, что это простой risk-by-code, все равно
[01:16:04.800 --> 01:16:12.400]  требуется интерпретировать. И когда у вас объемы данных достаточно большие, то хочется уже выполнять
[01:16:12.400 --> 01:16:17.960]  какой-то нативный код процессора. Поэтому этот классический BPF, который существует в любой
[01:16:17.960 --> 01:16:25.600]  UNIX-системе, по-моему, даже в Windows присутствует. Разработка очень старая, но понятно, что уже
[01:16:25.600 --> 01:16:33.080]  устаревшая. Теперь мы уже забываем о том, что у нас бывают другие системы, помимо Linux. Забываем
[01:16:33.080 --> 01:16:50.280]  про FreeBSD, MacOS, все остальное. Это все детские игрушки. В Linux в 2013 году, я написал на слайде 2016,
[01:16:50.280 --> 01:16:56.000]  потому что в 2016 году включили в состав ядра эту функциональность. Появилась новая реализация,
[01:16:56.000 --> 01:17:01.040]  называется Extended Berkeley Packet Filter. Расширенная реализация, которая подразумевает, во-первых,
[01:17:01.040 --> 01:17:08.680]  just-in-time-компиляцию кода для наиболее популярных архитектур. Я не знаю, поддерживается ли архитектура
[01:17:08.680 --> 01:17:17.880]  ARM64. В следующей неделе я это выясню. Для ARM64 точно есть трансляционно-нативный код, огромный API,
[01:17:17.880 --> 01:17:24.720]  который позволяет не только фильтровать пакеты, а делать привязку фильтров не только к сокетам,
[01:17:24.720 --> 01:17:30.760]  но и к разным внутренним подсистемам ядра. До чего это бывает полезно? Например, выполнять
[01:17:30.760 --> 01:17:37.360]  логирование происходящего с вашей программой на уровне ядра, мониторинг жизнеспособности,
[01:17:37.360 --> 01:17:45.480]  очень полезные фичи — это фильтрация системных вызовов, которые нельзя вызывать и так далее.
[01:17:45.480 --> 01:17:51.240]  В общем, новый развесистый фреймворк и самое главное, что тут не обязательно писать программы на
[01:17:51.240 --> 01:17:59.160]  псевдо-ассемблере. Можно написать программы на чем-то высокоуровнем и дальше транслировать,
[01:17:59.160 --> 01:18:04.960]  что-то высокоуровнем, имеется в виду язык Си и даже Питон. Дальше транслировать в
[01:18:04.960 --> 01:18:16.240]  нативный X64 код, либо в байт-код для тех платформ, которые не поддерживают нативную компиляцию. Все
[01:18:16.240 --> 01:18:20.720]  это опять же выполняется в пространстве ядра после верификации, что программа безопасна,
[01:18:20.720 --> 01:18:30.360]  выполняется достаточно быстро. Сделано это в 2013 году товарищем с какой-то подозрительной русской
[01:18:30.360 --> 01:18:37.600]  фамилией, хотя работает он в компании Facebook, которая ведет себя не очень красиво. Если вы
[01:18:37.600 --> 01:18:42.800]  увидите какую-то картинку, то, скорее всего, эта картинка не нарисована никем, а сгенерирована
[01:18:42.800 --> 01:18:51.840]  нейросеткой. Это означает, что лекция закончилась. Напоминаю, что следующая лекция последняя в
[01:18:51.840 --> 01:18:53.320]  этом модуле, потом контрольная.
