[00:00.000 --> 00:08.040]  В прошлый раз кто помнит на чем мы остановились?
[00:08.040 --> 00:14.560]  На чем мы остановились?
[00:14.560 --> 00:23.760]  Понятно. Да, динамик каст мы с вами обсудили.
[00:23.760 --> 00:35.080]  Я вам скину список пунктов, у меня вот он есть. Возможно, вам это облегчит несколько жизней,
[00:35.080 --> 00:44.600]  к концу семестра точно облегчит. Мы поговорили в прошлый раз о виртуальных функциях,
[00:44.600 --> 00:50.000]  ну и, собственно, вот я вам вчера опубликовал задачу следующую, которая как раз наследует
[00:50.000 --> 00:53.740]  и виртуальные функции, и динамик каст вам там приведет.
[00:53.740 --> 01:04.200]  Сейчас мы обсудим, we need to go deeper, значит, как это устроено.
[01:04.200 --> 01:17.180]  Мы сейчас обсудим vTables и Virtual Functions Implementation.
[01:20.020 --> 01:23.680]  Ну, я бы сказал,
[01:23.680 --> 01:23.720]  и виртуальные функции, и динамик каст.
[01:23.720 --> 01:23.740]  Ну, я бы сказал, и виртуальные функции, и динамик каст.
[01:23.740 --> 01:25.740]  Ну, я бы сказал, и виртуальные функции, и динамик каст.
[01:25.740 --> 01:31.840]  То есть, как они, как компилятор их реализует, что это вообще такое на самом деле.
[01:32.440 --> 01:35.680]  Ну, я уже заикался про vTables, про виртуальные таблицы.
[01:37.440 --> 01:45.440]  Я уже говорил, что, значит, на самом деле, когда вы вызываете виртуальную функцию,
[01:45.640 --> 01:49.120]  это означает, что происходит двойной прыжок, так сказать.
[01:49.120 --> 01:53.560]  Сначала идет, он смотрит в некоторое место, какой тип реально у этой,
[01:53.560 --> 01:56.500]  в этой штуке, у которой вы вызываете виртуальную функцию,
[01:57.420 --> 02:01.560]  и уже потом прыгает в зависимости от этого на разные адреса.
[02:02.980 --> 02:03.200]  Вот.
[02:05.340 --> 02:08.360]  Ну, для начала можно провести эксперимент.
[02:08.620 --> 02:12.600]  Вот, если у меня есть структура какая-нибудь,
[02:13.820 --> 02:17.580]  и в ней есть обычная функция f,
[02:18.520 --> 02:21.380]  то объект такой структуры будет занимать один байт.
[02:21.380 --> 02:22.720]  Ну, если больше ничего нет.
[02:23.560 --> 02:28.920]  Вот, ну, если вы сделаете структуру, в которой есть виртуальная f,
[02:28.920 --> 02:34.000]  вот, и посмотрите сайзов такой структуры, то сколько он будет?
[02:34.000 --> 02:35.000]  Два?
[02:35.000 --> 02:36.000]  Нет, восемь.
[02:36.000 --> 02:37.000]  Два?
[02:37.000 --> 02:39.000]  Как один, как поинтер, да.
[02:39.000 --> 02:40.000]  Вот.
[02:40.000 --> 02:47.000]  Значит, если у вас полиморфный тип, то у него обязательно размер хотя бы один поинтер,
[02:47.000 --> 02:53.220]  и вот этот поинтер будет указывать на то, что у вас есть виртуальная функция.
[02:53.220 --> 02:56.820]  Указывать как раз на некоторое место в статической памяти,
[02:57.520 --> 03:03.840]  в котором будет написана, ну, некоторая информация о данном типе,
[03:03.880 --> 03:07.580]  чтобы компилятор знал, куда прыгать, чтобы процессор уже знал, куда прыгать,
[03:07.660 --> 03:09.220]  когда вызывать вашу f.
[03:10.160 --> 03:14.600]  Вот, пусть это будет база,
[03:15.200 --> 03:17.740]  а еще будет derived.
[03:18.880 --> 03:19.880]  Ну, там.
[03:23.220 --> 03:31.220]  Вот, если у меня есть, значит, base и derived, и тут есть, значит, f, у которого override,
[03:37.860 --> 03:44.960]  то как base, так и derived занимает по восемь байт, и как устроено это?
[03:44.960 --> 03:51.560]  Ну, давайте я какой-нибудь, не знаю, напишу еще что-нибудь,
[03:51.560 --> 03:52.760]  чтобы был поинтер.
[03:52.760 --> 03:54.080]  Был поинтересней пример.
[03:54.640 --> 03:58.700]  Скажем, у derived есть еще другая виртуальная функция g.
[04:01.500 --> 04:06.900]  Ну, я не пишу им никакой реализации, типа, что они там делают, ничего не делают.
[04:07.900 --> 04:10.440]  Ну, и скажем, еще у них поля есть какие-нибудь.
[04:10.540 --> 04:13.440]  Тут есть int x, тут есть int y.
[04:15.520 --> 04:18.960]  Вот, давайте поймем, как в памяти устроены все эти штуки.
[04:18.960 --> 04:19.860]  А, еще знаете что?
[04:19.980 --> 04:22.440]  Давайте здесь будет еще void h.
[04:22.760 --> 04:24.220]  Виртуальная, обычная.
[04:26.560 --> 04:28.460]  Ну, так, чтобы совсем интересно.
[04:29.880 --> 04:33.540]  Вот, чтобы понять, как это, в общем, случайно работает.
[04:34.340 --> 04:36.480]  Как будет устроен объект в памяти при таком?
[04:37.420 --> 04:41.340]  Ну, начинаться будет с поинтера.
[04:42.120 --> 04:43.760]  Все, маркером хана.
[04:45.760 --> 04:48.680]  Начинаться будет с поинтера, который называется vptr.
[04:50.020 --> 04:51.760]  Значит, ну, virtual.
[04:53.760 --> 04:56.760]  vptr, потом будет лежать int x.
[04:59.200 --> 05:03.300]  Вот, у бейза, значит, расположение в памяти будет такое.
[05:03.980 --> 05:08.140]  Ну, соответственно, сайзов будет 16, потому что еще 4 байта пейдинг, как вы уже понимаете.
[05:09.000 --> 05:10.380]  Вот, это будет бейс, так выглядит.
[05:11.740 --> 05:16.500]  Поскольку он полиморфный, у него первым делом лежит поинтер.
[05:16.960 --> 05:18.220]  Ну, скрытый от вас.
[05:18.220 --> 05:21.900]  Вы его, ну, никак легальным способом не получите.
[05:21.980 --> 05:22.540]  Только reinterpret.
[05:22.760 --> 05:25.440]  Часто можете достучаться, посмотреть, что это за поинтер.
[05:26.740 --> 05:27.740]  Ну, и дальше лежат поля.
[05:29.140 --> 05:30.680]  Вот, а как будет выглядеть Derived?
[05:32.340 --> 05:35.100]  Ну, а Derived будет выглядеть вот как.
[05:35.200 --> 05:38.280]  У вас сначала лежит, опять-таки, поинтер.
[05:43.060 --> 05:44.200]  Потом x, потом y.
[05:44.560 --> 05:45.200]  И все.
[05:48.000 --> 05:52.240]  Ну, значит, давайте я скажу, что это vptr1.
[05:52.760 --> 05:54.640]  Это разные поинтеры будут.
[05:58.320 --> 05:59.840]  О, нормально, ладно, живем.
[06:00.960 --> 06:03.540]  Вот, так выглядит объект бейс, так выглядит объект Derived.
[06:05.000 --> 06:09.160]  То есть, на самом деле, наличие невиртуальных функций никак не влияет.
[06:09.800 --> 06:14.560]  Ну, есть невиртуальная функция, но она никак на хранение объекта самого не влияет.
[06:15.420 --> 06:17.460]  Невиртуальная функция ничего в памяти не занимает.
[06:17.460 --> 06:21.460]  А вот наличие виртуальных функций означает, что у вас...
[06:22.760 --> 06:26.060]  Должен лежать поинтер в начале.
[06:28.880 --> 06:30.040]  Да, на что?
[06:30.940 --> 06:36.840]  На некоторое место, где перечислены, скажем так, адреса, куда идти, если вызвали что.
[06:37.620 --> 06:41.100]  Вот, в случае с бейсом, этот поинтер будет...
[06:41.100 --> 06:43.220]  Это все будет поинтер на статическую память.
[06:43.220 --> 06:49.740]  И в статической памяти будет так называемая таблица виртуальных функций.
[06:50.200 --> 06:52.080]  Что такое таблица виртуальных функций?
[06:52.640 --> 06:52.740]  Что это?
[06:52.760 --> 06:54.580]  Что такое таблица виртуальных функций для бейс?
[06:55.140 --> 06:56.720]  Там всего одна запись будет.
[06:57.320 --> 06:59.640]  Это куда идти, если вызвали f.
[07:00.500 --> 07:02.220]  Вот тут будет лежать адрес.
[07:03.400 --> 07:10.740]  Будет такая таблица, в которой лежит адрес бейс, двоеточие, двоеточие, f.
[07:13.900 --> 07:18.340]  Ну вот, тут будет, значит, в этой таблице написана лишь одна вещь.
[07:18.420 --> 07:20.880]  Куда идти, если позвали f из бейса.
[07:22.760 --> 07:28.800]  А vip.tr2 будет указывать на другую таблицу, в которой будет две записи уже.
[07:29.420 --> 07:31.680]  Куда идти, если позвали f из дирайвда.
[07:32.900 --> 07:35.140]  И куда идти, если позвали g из дирайвда.
[07:37.620 --> 07:38.140]  Ой.
[07:38.140 --> 07:42.800]  Это одна запись про себя и ссылка на запись на своего родителя.
[07:43.440 --> 07:43.800]  Сейчас.
[07:44.280 --> 07:48.200]  Куда идти, если позвали f из дирайвда.
[07:48.280 --> 07:50.240]  Куда идти, если позвали g из дирайвда.
[07:51.480 --> 07:52.440]  Какая запись?
[07:52.760 --> 07:53.480]  Ссылка на запись про себя.
[07:53.500 --> 07:54.640]  Это оптимизируется?
[07:54.880 --> 07:55.880]  Что оптимизируется?
[07:56.000 --> 07:58.500]  Это все три разных числа.
[07:59.020 --> 08:00.000]  Мне сейчас предложат вам.
[08:00.400 --> 08:01.300]  Какая идея?
[08:01.660 --> 08:02.840]  Плохая идея, наоборот.
[08:03.200 --> 08:04.520]  Это как раз плохая идея.
[08:04.860 --> 08:06.360]  Это все три разных числа.
[08:06.740 --> 08:10.360]  Если бы в бейсе лежало несколько виртуальных функций, а потом мы наследовали бы бейс,
[08:10.360 --> 08:18.260]  то у нас в геранте для виртуальных функций бейс был бы указатель, допустим, на школьник.
[08:18.760 --> 08:21.700]  Мы бы наследовали бейс и переопределяли в нем виртуальные функции или нет?
[08:22.760 --> 08:31.200]  Если мы переопределяем виртуальные функции, то эти адреса становятся другими.
[08:32.060 --> 08:35.340]  Что отдельно выделяется?
[08:35.340 --> 08:37.620]  Я переопределил в дирайвде f.
[08:38.500 --> 08:42.220]  Это значит, что адрес f из дирайвда другой, нежели адрес f из бейса.
[08:44.440 --> 08:49.740]  Значит, как работает вызов виртуальной функции?
[08:50.280 --> 08:52.540]  Вот у меня есть какой-то объект.
[08:52.760 --> 08:57.620]  Бейс, ну, стандартная история.
[08:57.780 --> 09:06.000]  Я возьму сейчас создам дирайвд, а потом заведу ссылку на бейс, проинициализирую ее дирайвд.
[09:10.080 --> 09:11.680]  И вызову f.
[09:13.540 --> 09:16.920]  Должна вызваться f из дирайвд, а не из бейс.
[09:17.820 --> 09:21.740]  Как мы знаем, собственно, в этом и смысл виртуальных функций.
[09:22.760 --> 09:26.040]  За счет чего это произойдет?
[09:26.780 --> 09:28.700]  Как работает вызов виртуальной f?
[09:28.760 --> 09:34.300]  Компилятор во время компиляции видит, что это виртуальная функция, а не обычная.
[09:35.020 --> 09:39.360]  Это значит, что ее вызов это не просто прыжок куда-то там, где написано код.
[09:40.140 --> 09:47.400]  А сначала нужно пойти в таблицу виртуальных функций и уже там найти адрес, куда прыгать.
[09:47.400 --> 09:52.280]  То есть вызов этой функции транслируется в следующую последовательность.
[09:52.760 --> 09:59.080]  Для процессора зайди в объект бейс, вот в этот объект зайди и посмотри на первые 8 байт.
[09:59.160 --> 10:00.140]  Увидишь там указатель.
[10:01.660 --> 10:03.040]  Пойди по этому указателю.
[10:04.820 --> 10:06.740]  Ну он хорошо говорит, пошел.
[10:06.920 --> 10:07.280]  Дальше.
[10:08.640 --> 10:13.080]  Возьми вот по тому указателю, по которому ты пришел, теперь первые 8 байт.
[10:14.500 --> 10:17.980]  И вот там ты увидишь адрес, какую функцию вызвать.
[10:19.020 --> 10:20.280]  Вот ее и вызови.
[10:20.380 --> 10:22.680]  Ну, положи на стэк нужный аргумент и пойди.
[10:22.760 --> 10:24.140]  Пойди по этому адресу исполнять.
[10:25.360 --> 10:27.040]  Ну, адрес возврата запиши этот.
[10:29.560 --> 10:33.340]  Как он понимает, что именно первые 8 байт нужно взять отсюда, а не следующие 8 байт.
[10:33.440 --> 10:39.560]  Но это в компайл тайме известно, просто компилятор же помнит порядок, в каком порядке функции в классе объявлены.
[10:39.660 --> 10:42.480]  Значит, вот это будет первые 8 байт, вот это следующие 8 байт и так далее.
[10:45.380 --> 10:52.740]  Соответственно, в рантайме процессор сначала идет смотреть на этот поинтер, прыгает сюда, попадает сюда.
[10:52.840 --> 10:57.260]  Берет этот адрес и прыгает на него, и оттуда идет функцию исполнять.
[11:02.120 --> 11:11.860]  Если бы это был настоящий бейс, то он бы, сделав все то же самое, прыгнул бы сюда, попал бы вот сюда и попал бы на fsbase.
[11:15.040 --> 11:17.900]  Вот это вот таблица виртуальных функций для бейс.
[11:18.640 --> 11:20.400]  Вот это таблица виртуальных функций для дирайв.
[11:20.400 --> 11:22.560]  Таблица виртуальных функций одна на класс.
[11:22.780 --> 11:25.460]  Она в статической памяти хранится.
[11:25.880 --> 11:34.460]  Когда я вам говорил в самом начале, рассказывал про статическую память, я говорил, ну там хранятся глобальные переменные, локальные статические переменные, константы и еще кое-что.
[11:34.820 --> 11:37.160]  Ну вот под кое-что я имел ввиду вот это.
[11:37.620 --> 11:39.500]  Вот еще и это хранится в статической памяти.
[11:40.420 --> 11:46.600]  Значит, если у вас есть полиморфные классы, то для каждого из них в статической памяти сохраняется таблица виртуальных функций.
[11:49.540 --> 11:51.460]  Так, осознайте.
[11:52.160 --> 11:52.740]  Вы осознали?
[11:52.760 --> 12:03.620]  как работает? Где? А, это бывает, это я понимаю, да. Тут написано адрес base f, тут написано
[12:03.620 --> 12:18.620]  адрес derived f, а тут написано адрес derived g. Где что написано? Да.
[12:18.620 --> 12:27.320]  А почему в этой таблице записано derived f? Так, у derived f другая, ну неважно, на самом деле, даже если бы не
[12:27.320 --> 12:36.500]  перезаписали, тут было бы тоже, тут было бы число просто такое же, как здесь. А сейчас мы перезаписали виртуальную функцию, которая будет потом для сыновей наследоваться как новая функция.
[12:36.500 --> 12:43.520]  Что? Derived f мы переопределили, поэтому в base f и в derived f разные адреса.
[12:43.520 --> 12:47.520]  Derived f это виртуальная функция тоже, да?
[12:47.520 --> 12:48.600]  Естественно,
[12:48.600 --> 12:52.320]  а как? Оверрайт написано.
[12:57.480 --> 13:09.960]  Если мы вызываем функцию h, то он... Если мы вызываем функцию h, отличный вопрос, для этого я этот пример и привел. Мы вызываем функцию h,
[13:09.960 --> 13:16.740]  компилятор такой, окей, давай компилировать. Смотрим на вызов h, что это такое? Ну это не виртуальная
[13:16.740 --> 13:18.580]  функция, но тогда ничего не надо этого.
[13:18.580 --> 13:21.320]  без моей всей этой возни просто берём
[13:21.320 --> 13:24.260]  адрес h сразу прыгаем. Никакой таблицы
[13:24.260 --> 13:25.540]  виртуальных функций не надо для этого.
[13:25.540 --> 13:29.680]  Где адрес h будет лежать? Где у
[13:29.680 --> 13:32.100]  компилятора? Ну не у компилятора,
[13:32.100 --> 13:36.400]  а у линковщика на самом деле. Компилятор
[13:36.400 --> 13:38.920]  ещё не знает в каком месте лежит
[13:38.920 --> 13:42.520]  h, а линковщик узнает. А в какой памяти
[13:42.520 --> 13:43.720]  будет лежать сама функция h? Сама функция h в тексте, сама функция, любая функция, любая функция подпись Spirit, я выбыла, она сидит у продавца SSD, она сидит у продавца SSD.
[13:43.720 --> 13:45.700]  Лидер заказывает esto. healthcare скор themed eh?
[13:45.700 --> 13:46.440]  Cienda? Cends 클� Fin c? Spiritual perLLch? La fdress relax, a $osa survivors, Billboard 899?
[13:48.580 --> 13:54.220]  лежит в секции текст. У нас есть дата, текст и стэк, я напоминаю. Код самой
[13:54.220 --> 14:00.400]  программы, как и всех функций, лежит в секции текст. Но вот эта вот информация
[14:00.400 --> 14:04.440]  об адресах, куда прыгать, лежит в статической памяти.
[14:04.440 --> 14:19.480]  Вот если мы так запустились, то он попал во вторую табличку, а не в первую.
[14:19.480 --> 14:29.560]  Нет, он от Derived должен запуститься, потому что это ссылка на Derived. Это же виртуальные
[14:29.560 --> 14:34.080]  функции, ну вы чего, все забыли что ли? Что?
[14:34.080 --> 14:34.280]  Что?
[14:34.280 --> 14:34.320]  Что?
[14:34.320 --> 14:34.360]  Что?
[14:34.360 --> 14:34.400]  Что?
[14:34.400 --> 14:34.420]  Что?
[14:34.440 --> 14:36.320]  Мы же ссылку на Base создали.
[14:36.520 --> 14:38.740]  Вот это F вызовется, конечно, от Derived.
[14:40.540 --> 14:42.440]  У нас там Base...
[14:43.420 --> 14:44.160]  Так, слушайте,
[14:44.800 --> 14:45.960]  я это...
[14:45.960 --> 14:48.340]  Вы уже начинаете меня немножко пугать.
[14:48.420 --> 14:50.700]  Вы чего? Это вопрос на тройку
[14:50.700 --> 14:51.220]  вообще-то.
[14:51.760 --> 14:54.220]  Какая функция вызовется? Это два будет,
[14:54.340 --> 14:55.660]  если вы так на экзамене ответите.
[14:56.760 --> 14:58.520]  Это базовая идея
[14:58.520 --> 15:00.300]  виртуальных функций. Почему они виртуальные?
[15:00.400 --> 15:02.160]  Потому что
[15:02.160 --> 15:04.320]  они вызываются независимо от того,
[15:04.320 --> 15:05.320]  ссылка на что.
[15:06.260 --> 15:08.240]  Ну, мы полтора часа в прошлый раз
[15:08.240 --> 15:10.660]  рассказывали, я тут распинался,
[15:10.880 --> 15:11.880]  что такое виртуальная функция.
[15:12.880 --> 15:13.980]  У нас объект Derived.
[15:14.220 --> 15:16.220]  Мы создали ссылку на Base, проинстализировали ее
[15:16.220 --> 15:18.580]  в Derived. Виртуальность в том проявляется,
[15:18.740 --> 15:20.360]  что не важно, что это ссылка на Base.
[15:20.420 --> 15:22.460]  Он увидит, что это Derived на самом деле и вызовет
[15:22.460 --> 15:24.240]  версию от Derived. В этом
[15:24.240 --> 15:25.280]  идея виртуальности.
[15:26.880 --> 15:28.200]  А как он это...
[15:28.200 --> 15:30.140]  За счет чего это произойдет? Вот я сейчас объяснил.
[15:30.920 --> 15:31.800]  Да, потому что
[15:31.800 --> 15:32.640]  это не PTR.
[15:32.640 --> 15:35.260]  А можно ли
[15:35.260 --> 15:35.820]  как-то вызвать
[15:35.820 --> 15:38.580]  F от Derived, если у нас
[15:38.580 --> 15:39.180]  объект Derived?
[15:41.280 --> 15:42.600]  Можно ли вызвать
[15:42.600 --> 15:44.040]  F из Base, если у нас
[15:44.040 --> 15:45.060]  объект Derived?
[15:45.460 --> 15:48.680]  B.Base.F. Это тоже
[15:48.680 --> 15:50.420]  в прошлый раз я рассказывал.
[15:50.860 --> 15:51.340]  А у нас?
[15:51.340 --> 15:54.580]  А в таком случае он просто заменяет сразу
[15:54.580 --> 15:56.500]  инструкцию? Если он видит, что вы явно
[15:56.500 --> 15:58.800]  квалифицировали, он игнорирует виртуальность.
[15:58.900 --> 16:00.320]  У него отдельно прописано, что
[16:00.320 --> 16:01.700]  если явно...
[16:01.700 --> 16:02.500]  Квалифицировать?
[16:02.640 --> 16:04.040]  Qualified ID, то пофиг.
[16:04.040 --> 16:06.480]  Как обычные функции.
[16:07.140 --> 16:09.820]  Вы явно попросили игнорировать виртуальность.
[16:09.900 --> 16:11.820]  Тогда он просто прыгнет сразу на адрес вот этой.
[16:12.700 --> 16:14.000]  У нас одна ссылка на класс
[16:14.000 --> 16:15.840]  хранится даже при множественном исследовании.
[16:16.600 --> 16:17.620]  На какой класс?
[16:17.820 --> 16:20.060]  Ой, ну смотри. Одна ссылка
[16:20.060 --> 16:21.980]  на Vtable хранится даже
[16:21.980 --> 16:23.800]  при множественном исследовании. Это правильный вопрос.
[16:24.420 --> 16:25.900]  Сейчас мы об этом поговорим. Нет.
[16:26.020 --> 16:28.220]  При множественном, конечно, там одной не обойдешься.
[16:29.180 --> 16:30.220]  Там все интереснее.
[16:32.640 --> 16:35.660]  Так, еще раз. Последний. Быстро.
[16:36.280 --> 16:37.040]  Вот эта штука.
[16:37.820 --> 16:39.260]  Как работает? У меня дирайв.
[16:39.380 --> 16:40.780]  Объект дирайв выглядит вот так.
[16:40.960 --> 16:42.800]  Вот этот поинтер ведет на эту таблицу.
[16:43.120 --> 16:45.100]  Поэтому, когда я делаю ссылку на этот дирайв,
[16:45.180 --> 16:47.180]  у меня получается, как бы, вот этот кусок
[16:47.180 --> 16:49.560]  объекта я рассматриваю. И он как будто бы
[16:49.560 --> 16:51.400]  бейс, но поинтер-то у него, дирайв доски
[16:51.400 --> 16:53.360]  вот этот. И поэтому, когда я вызываю F,
[16:53.680 --> 16:55.540]  я попадаю сюда. И отсюда
[16:55.540 --> 16:57.580]  беру адрес F. То есть я попадаю
[16:57.580 --> 16:58.880]  в версию дирайв все равно.
[17:01.360 --> 17:01.800]  Ладно.
[17:02.640 --> 17:05.780]  Это, что касается
[17:05.780 --> 17:15.660]  Что касается
[17:15.660 --> 17:17.060]  простых
[17:17.060 --> 17:18.780]  ситуаций. Теперь.
[17:19.420 --> 17:21.660]  Помните, я говорил, что еще RTTI есть?
[17:22.160 --> 17:23.460]  Информация о типе где-то.
[17:25.180 --> 17:27.100]  Как динамик каст работает?
[17:29.520 --> 17:31.460]  Вот я говорю, динамик каст
[17:31.460 --> 17:32.460]  B к D.
[17:32.640 --> 17:35.180]  Вот я сейчас сделаю
[17:35.180 --> 17:37.960]  допустим, динамик каст
[17:37.960 --> 17:44.440]  к D
[17:44.440 --> 17:47.760]  амперсант
[17:47.760 --> 17:49.620]  от B.
[17:50.560 --> 17:51.580]  Как это сработает?
[17:52.880 --> 17:53.960]  Ну, это нормально
[17:53.960 --> 17:55.220]  сработает. То есть это будет
[17:55.220 --> 17:57.900]  корректный вызов, и он вернет
[17:57.900 --> 17:59.160]  корректную ссылку на D.
[17:59.160 --> 18:01.080]  А как он поймет,
[18:01.800 --> 18:02.160]  что...
[18:03.140 --> 18:03.720]  А?
[18:04.760 --> 18:07.460]  Как он поймет, что это корректная ссылка на Derived?
[18:07.840 --> 18:09.920]  Но у нас же вот этот WPTR 2
[18:10.120 --> 18:13.660]  он просто явно как бы связан с классом Derived,
[18:14.180 --> 18:16.400]  то есть он вот уникален для всех.
[18:16.400 --> 18:17.300]  Он такой
[18:17.300 --> 18:18.860]  у всех объектов Derived.
[18:19.040 --> 18:19.960]  Нуу.
[18:22.280 --> 18:23.700]  А, хотя у нас еще низкий индекс.
[18:23.700 --> 18:25.780]  Там может быть множественное наследование,
[18:25.780 --> 18:26.380]  я бы так
[18:27.280 --> 18:29.000]  смело не утверждал.
[18:29.000 --> 18:30.380]  Он не очень понятный.
[18:31.180 --> 18:32.500]  Короче, не совсем он одинаковый.
[18:32.500 --> 18:41.320]  может быть там принято сейчас мы нарисуем пример похитрее но да ладно это не ну допустим даже он
[18:41.320 --> 18:45.740]  одинаковый всех объектов derived а чё он хранит какой-то мэпчик глобальный типа если тип derived
[18:45.740 --> 18:51.860]  vptr должен быть такой смотри какой у тебя то есть это что это хэш-таблицу надо хранить в рантайме
[18:51.860 --> 19:02.000]  какую-то что ли или что правильно так сделано в этом-то и смысл то есть я говорил что по
[19:02.000 --> 19:07.940]  указателю хранится некоторая информация о том какой это тип ну там она и хранится просто вот
[19:07.940 --> 19:14.300]  здесь ну это уже детали имплементации там разные компиляторы могут по-разному ну условно можно
[19:14.300 --> 19:22.860]  считать что вот вот этот поинтер ведет на начало вот этой таблицы а слева лежит другая штука ну
[19:22.860 --> 19:28.220]  можно считать что там лежит объект typeinfo для base а тут лежит объект typeinfo для derived но
[19:28.220 --> 19:31.840]  на самом деле все не совсем так а тут лежит
[19:32.000 --> 19:41.620]  адрес typeinfo потому что typeinfo длинная прямо в таблице его хранить затратно ну скорее всего
[19:41.620 --> 19:46.680]  тут лежит указатель на еще куда-то в другое место статической памяти и там лежит typeinfo для derived
[19:46.680 --> 20:01.220]  там derived typeinfo наоборот память наоборот как раз память мы исчедим
[20:02.000 --> 20:13.920]  сейчас это же статическая память что как что для каждой за refugee что для каждой ссылке
[20:13.920 --> 20:23.800]  у меня ровно одна таблица для класса base ровно одна таблица для класса derived
[20:23.800 --> 20:29.840]  кому ты подал ссылку на бейс
[20:29.840 --> 20:37.820]  если выпадал ссылку на бейс то vptr будет вести на эту таблицу и тут будет бейс type
[20:37.820 --> 20:44.720]  info он динамик каст пойдет сюда шагнет влево увидишь что написано бейс и он такой неправильный
[20:44.720 --> 21:00.900]  каст значит если пришел от derived в смысле вот здесь я это и сделал здесь так таблица то на
[21:00.900 --> 21:09.200]  derived указывает в этом то блин и суть всей истории я как раз про эти две таблицы сейчас
[21:09.200 --> 21:14.700]  рассказываю также он узнает почему он вызовет функцию от derived потому что у него по интервью
[21:14.700 --> 21:20.280]  идет на derived-овскую таблицу он видит что и версии от derived надо вызывать и что в type
[21:20.280 --> 21:32.460]  info написано derived и динамик каст такой все окей можем да и вверх и вниз можем бейс к derived
[21:32.460 --> 21:40.920]  я здесь это и делаю нет если бы был настоящий бейс то будет runtime error
[21:44.700 --> 21:54.120]  ну да
[21:54.120 --> 22:14.560]  нет конечно как они они остаются полиморфными как они могут перестать быть полиморфными
[22:14.700 --> 22:27.580]  если у них уже vptr есть да все короче я я понял момент настал значит все люди уже не
[22:27.580 --> 22:32.700]  помнят что было в прошлый раз люди задают базовые вопросы что такое виртуальная функция все хорошо
[22:32.700 --> 22:41.640]  да все нужны нужная кондиция достигнута можно проводить можно зачет проводить начинать хорошо
[22:44.700 --> 22:52.560]  хорошо ну я проведу как-нибудь да я предупрежу
[22:52.560 --> 23:01.300]  ладно
[23:01.300 --> 23:13.340]  так вот давайте вот теперь какой пример разберем а у меня есть
[23:14.700 --> 23:17.260]  еще grant based
[23:17.260 --> 23:23.800]  а у grnt based все немножко поинтересней
[23:24.340 --> 23:32.500]  grand base
[23:34.340 --> 23:36.500]  вот бэйз будет наследиться и grant based
[23:36.500 --> 23:42.840]  да ну вы же понимаете что приватность если я сейчас добавлю куда угодно ни на что и не
[23:42.840 --> 23:43.720]  повлияет
[23:44.700 --> 23:50.020]  Но это повлияет только на то, что я вот здесь не смогу сделать b равно d, например.
[23:51.080 --> 23:52.280]  А в остальном ни на что не повлияет.
[23:52.820 --> 23:54.600]  Ну да, если, допустим, приватное наследие сделаю.
[23:54.820 --> 23:57.000]  Но на то, как это в памяти хранится, конечно, никак не повлияет.
[23:57.740 --> 23:59.680]  И тут я сделаю просто обычную f.
[24:02.580 --> 24:07.260]  Void f, которая не виртуальная.
[24:09.940 --> 24:11.640]  А как тогда это будет устроено?
[24:14.700 --> 24:21.840]  Да, давайте подумаем, как это будет устроено.
[24:21.840 --> 24:24.840]  Void своим f перезапишет, ну, перекроет.
[24:25.560 --> 24:27.660]  Она никак не влияет на то, что снизу.
[24:28.040 --> 24:29.580]  Кажется, что так и есть.
[24:29.840 --> 24:32.380]  Ну, давайте, ладно.
[24:33.160 --> 24:34.800]  Меня на самом деле интересует не это.
[24:34.980 --> 24:37.520]  Меня интересует, вот есть тут еще поле есть.
[24:37.640 --> 24:38.740]  Int, не знаю.
[24:39.860 --> 24:41.420]  Какая буква перед x?
[24:41.600 --> 24:43.020]  W. Нет.
[24:43.940 --> 24:44.500]  W.
[24:44.700 --> 24:50.040]  U, V, W, X, Y, Z.
[24:50.220 --> 24:51.780]  По идее, ничего не должно меняться.
[24:52.000 --> 24:56.000]  То есть у нас как работало, так работало f.
[24:56.700 --> 24:58.100]  Как это будет в памяти храниться?
[24:58.280 --> 25:01.840]  У нас грандбэйс не виртуальный, поэтому на него не должен быть указать.
[25:02.740 --> 25:05.680]  Он вообще не должен влиять на то, как оно в памяти хранится.
[25:06.360 --> 25:06.800]  Почему?
[25:07.020 --> 25:09.960]  У нас в памяти однозначно будет перед x храниться.
[25:09.980 --> 25:12.020]  Но у нас добавится один, очень жаль.
[25:12.020 --> 25:14.020]  Но, кажется, логично сделать, чтобы...
[25:14.700 --> 25:16.700]  Он все равно лежал максимально слева.
[25:18.140 --> 25:31.140]  Ну, объект, объект бэйза, по идее, ну, когда у меня, тут, на самом деле, я даже не помню точно, как это будет.
[25:31.760 --> 25:33.700]  Но, кажется, есть два варианта, как это можно реализовать.
[25:34.600 --> 25:37.000]  Да, понятно, что это все в стандарте не написано.
[25:37.120 --> 25:38.760]  Вот это все, что я сейчас со всем рассказываю.
[25:39.000 --> 25:41.060]  Это все implementation defined компилятора.
[25:41.060 --> 25:44.660]  Мы с вами, ну, вот это прям почти 100%.
[25:44.700 --> 25:45.920]  Так устроено.
[25:46.520 --> 25:50.040]  Вот то, что я сейчас расскажу, да тоже, скорее всего, 100%.
[25:50.040 --> 25:53.040]  То есть, там особо не придумаешь больше ничего умного.
[25:54.160 --> 25:57.800]  Когда у меня есть объект бэйз, я все еще хочу, чтобы он с vptr начинался.
[25:57.920 --> 25:59.180]  Потому что бэйз-то полиморфный.
[25:59.780 --> 26:04.360]  И чтобы вот эту вот фигню работать нормально с ней, я бы хотел, чтобы начиналась с vptr.
[26:04.440 --> 26:06.780]  То есть, давайте у меня будет vptr.
[26:10.440 --> 26:10.800]  vptr.
[26:11.920 --> 26:13.780]  Ну, скажем...
[26:14.700 --> 26:16.120]  vptr какой?
[26:16.280 --> 26:18.060]  Ну, смотря что это, дерайвт или бэйз.
[26:18.120 --> 26:19.400]  Например, я создаю дерайвт.
[26:21.400 --> 26:21.840]  Теперь.
[26:24.740 --> 26:28.880]  Вот я создаю дерайвт, но уже бэйз, у него еще есть предок гранда бэйз.
[26:29.720 --> 26:32.840]  Вот, но тогда перед этим мне нужно положить, видимо, x.
[26:33.460 --> 26:34.300]  Ой, w.
[26:35.320 --> 26:36.400]  Потом только x.
[26:37.140 --> 26:38.120]  Потом только y.
[26:38.120 --> 26:38.300]  И вот так.
[26:40.420 --> 26:41.340]  Придется сливать.
[26:43.660 --> 26:44.220]  Вот.
[26:44.700 --> 26:46.000]  Но таблица для дерайвт.
[26:46.620 --> 26:50.760]  То есть, если у меня каст гранд бэйз происходит, то получается, я сдвигаюсь сюда.
[26:50.940 --> 26:53.140]  То есть, на самом деле, гранд бэйз начинается правее.
[26:53.240 --> 26:54.900]  Гранд бэйз начинается не с vptr.
[26:55.560 --> 26:57.520]  А бэйз уже начинается с vptr.
[27:02.240 --> 27:02.980]  Чего? Почему?
[27:03.620 --> 27:03.900]  Что?
[27:04.580 --> 27:06.320]  Ну, говорю, в бэйз он не очень нравится.
[27:07.580 --> 27:08.320]  Не, почему?
[27:08.420 --> 27:09.480]  Бэйз, он вот...
[27:09.480 --> 27:11.020]  Вот, бэйз, это вот что.
[27:11.860 --> 27:14.560]  В бэйз должно и поле w, и присутствие поля.
[27:14.560 --> 27:14.840]  И x.
[27:15.120 --> 27:16.200]  И vptr быть.
[27:17.400 --> 27:18.960]  А дерайвт уже с y будет.
[27:19.220 --> 27:21.020]  Гранд бэйз еще раз сразу после vptr.
[27:21.540 --> 27:24.260]  Ну, кажется, да.
[27:27.260 --> 27:27.820]  Ну...
[27:27.820 --> 27:30.700]  Тут я уже не уверен, что это так реализовано.
[27:30.780 --> 27:32.760]  Но, по идее, должно быть так реализовано.
[27:33.040 --> 27:34.740]  Потому что, ну, а как вы еще это сделаете?
[27:35.100 --> 27:37.040]  Сначала положите w, а потом vptr.
[27:37.240 --> 27:38.740]  Это именно объекты и подерайвт.
[27:38.940 --> 27:40.780]  Ну, это объекты и подерайвт, да.
[27:40.920 --> 27:42.440]  vptr ведет по-прежнему сюда.
[27:43.740 --> 27:44.400]  Для гранд бэйз...
[27:44.560 --> 27:45.940]  Для гранд бэйза никакой виртуальной таблицы нет.
[27:48.700 --> 27:49.540]  Вот.
[27:55.740 --> 27:56.840]  Ну вот.
[27:59.920 --> 28:00.760]  Так.
[28:01.860 --> 28:02.420]  Ладно.
[28:11.320 --> 28:14.100]  Ну, побуду мусатым немножко.
[28:14.100 --> 28:14.540]  Кто понял?
[28:14.560 --> 28:14.760]  Понял?
[28:19.600 --> 28:20.260]  Хорошо.
[28:25.000 --> 28:28.280]  Я тоже постарался сделать.
[28:28.600 --> 28:30.140]  Но не знаю, насколько получилось.
[28:31.160 --> 28:32.940]  Чтобы косплей мусатого был полноценный,
[28:33.020 --> 28:34.760]  нужно еще полупустую аудиторию,
[28:34.880 --> 28:36.100]  чтобы вторая половина спала.
[28:36.940 --> 28:38.120]  Только оно так и было.
[28:38.120 --> 28:38.880]  Что?
[28:38.880 --> 28:41.840]  Что нужно было понять?
[28:42.580 --> 28:43.060]  А что это?
[28:43.060 --> 28:43.180]  Что?
[28:44.560 --> 28:47.940]  Ну, механизм, как это работает.
[28:47.940 --> 28:48.940]  Я не знаю.
[28:48.940 --> 28:53.940]  Сможете ли вы объяснить другому, как это работает?
[28:53.940 --> 28:56.940]  Я все равно не буду задавать какие-то вопросы.
[28:56.940 --> 29:01.940]  Пойти вашему соседу с основного потока рассказать, да.
[29:01.940 --> 29:08.940]  Тихо, вопрос.
[29:08.940 --> 29:12.520]  У меня есть какой-то класс, у него там две ветки расследования отходят.
[29:12.520 --> 29:13.520]  Я нахожусь в одной ветке.
[29:13.520 --> 29:13.600]  Я нахожусь в одной ветке.
[29:13.600 --> 29:13.700]  Я нахожусь в одной ветке.
[29:13.700 --> 29:14.700]  Я нахожусь в одной ветке.
[29:14.700 --> 29:16.700]  Дошел, ну, по ней ссылка.
[29:16.700 --> 29:18.700]  Ну, когда я полиморфный класс.
[29:18.700 --> 29:20.700]  Соответственно, сын у тебя тоже полиморфный.
[29:20.700 --> 29:21.700]  Ну.
[29:21.700 --> 29:23.700]  Потом в статик кастом спустился туда.
[29:23.700 --> 29:25.700]  Как это в статик кастом?
[29:25.700 --> 29:27.700]  Убэ.
[29:27.700 --> 29:28.700]  Все, убэ.
[29:28.700 --> 29:32.700]  В смысле, у тебя есть сын, дочка и мама.
[29:34.700 --> 29:38.700]  И ты спрашиваешь, что будет, если ты от сына к дочке прикастуешься?
[29:38.700 --> 29:41.700]  Нет, нет, я от сына к папе.
[29:41.700 --> 29:42.700]  К маме.
[29:42.700 --> 29:43.700]  Ну, а дальше что?
[29:43.700 --> 29:45.700]  А потом к дочке.
[29:45.700 --> 29:46.700]  Перейду в статик кастом.
[29:46.700 --> 29:47.700]  Убэ.
[29:47.700 --> 29:48.700]  Все.
[29:48.700 --> 29:49.700]  До свидания.
[29:49.700 --> 29:55.700]  В статик кастом можно кастовать вниз.
[29:55.700 --> 29:56.700]  Потому что сына-то не дочка.
[29:56.700 --> 29:57.700]  Потому что несовместимые типы.
[29:57.700 --> 29:58.700]  Какого черта?
[29:58.700 --> 30:01.700]  У тебя сын, в частном случае, мама и дочка, в частном случае, мама.
[30:01.700 --> 30:05.700]  С какой стати ты от сына к маме, а потом от мамы сюда?
[30:05.700 --> 30:07.700]  Мы с сыном создали объект к маме.
[30:07.700 --> 30:11.700]  Это уже новый полноценный объект к маме.
[30:11.700 --> 30:12.700]  Нет, мы ссылку создали.
[30:12.700 --> 30:15.700]  Ссылку на маму и проанализировали сыном.
[30:15.700 --> 30:16.700]  Нет, я имею в виду...
[30:16.700 --> 30:20.700]  Кажется, к началу второй пары опять последний ряд будет занят.
[30:20.700 --> 30:21.700]  И опять будет не посидеть там.
[30:21.700 --> 30:22.700]  Ну, что ж такое?
[30:22.700 --> 30:26.700]  Вы уж, если не приходите, так не приходите целый день тогда.
[30:31.700 --> 30:36.700]  Короче, сохраните для меня там свободное место.
[30:36.700 --> 30:41.700]  Я хочу посидеть еще здесь.
[30:41.700 --> 30:43.700]  Что за вопрос был?
[30:43.700 --> 30:44.700]  Что ты говорил?
[30:44.700 --> 30:45.700]  Кто говорил?
[30:45.700 --> 30:47.700]  Все, ничего, да?
[30:47.700 --> 30:49.700]  Сейчас, мы создаем не ссылку.
[30:49.700 --> 30:55.700]  Нет, я имею в виду ситуацию, когда мы создаем ссылку на сына мамы.
[30:55.700 --> 30:57.700]  А когда мы просто создаем ссылку...
[30:57.700 --> 31:00.700]  Если ты создал копию, мам m равно s.
[31:00.700 --> 31:02.700]  Да, и потом я могу это дотер...
[31:02.700 --> 31:05.700]  Ну, может быть, у b опять.
[31:05.700 --> 31:06.700]  Нет.
[31:06.700 --> 31:07.700]  Что?
[31:07.700 --> 31:08.700]  Это будет смешно, если бы...
[31:08.700 --> 31:09.700]  У меня же уже полноценный объект мамы после этого.
[31:09.700 --> 31:11.700]  Полноценный объект мамы, но это же не ДОТОР.
[31:15.800 --> 31:18.480]  Можно, но если это неправильно, то будет УБ.
[31:26.800 --> 31:29.680]  Если он реальная мама, настоящая, и не ДОТОР,
[31:29.840 --> 31:31.960]  а ты скастуешь его к ДОТОР, то будет УБ.
[31:33.960 --> 31:34.940]  Кстати, кастом.
[31:37.760 --> 31:39.180]  Что вас так развеселило?
[31:39.700 --> 31:41.700]  Сын реальный ДОТОР.
[31:41.700 --> 31:42.160]  ДОТОР.
[31:44.380 --> 31:45.780]  Сын реальный ДОТОР.
[31:51.060 --> 31:52.520]  Сын реальный ДОТОР.
[31:52.640 --> 31:53.020]  Ну ладно.
[31:56.560 --> 31:59.480]  Так, ну ладно, а теперь повеселее.
[32:00.420 --> 32:03.880]  Чтобы не было скучно, а то слишком просто все.
[32:04.720 --> 32:07.940]  Давайте теперь то же самое, только множественное наследование.
[32:09.700 --> 32:10.800]  Ох, сейчас порезвимся.
[32:11.540 --> 32:16.420]  Смотрите-ка, вот у меня есть, значит, это будет уже параграф 5.7.
[32:19.420 --> 32:20.700]  А, значит...
[32:26.700 --> 32:30.380]  Виртуальные функции с множественным наследованием.
[32:36.020 --> 32:37.440]  Ну да.
[32:38.580 --> 32:39.480]  Так.
[32:39.700 --> 32:41.580]  Ты сказал функции, а я написал таблицы.
[32:41.660 --> 32:42.460]  Ну, таблицы.
[32:42.600 --> 32:45.780]  Потому что я про таблицы... Про функции-то и так понятно, как они работают.
[32:46.260 --> 32:47.400]  Как таблицы устроены.
[32:49.180 --> 32:51.560]  Пусть у меня есть мама-папа.
[32:54.060 --> 32:54.540]  Да.
[32:55.460 --> 32:56.660]  Нет, братьев нет.
[32:57.980 --> 32:58.280]  Так.
[33:00.280 --> 33:02.320]  Ну, короче, что будет у меня?
[33:02.440 --> 33:04.820]  Давайте я как-нибудь здесь перерисую.
[33:05.240 --> 33:05.800]  Прямо тут.
[33:06.600 --> 33:07.800]  Вот у меня будет мама.
[33:09.700 --> 33:13.660]  И у нее будет, ну, виртуальная F.
[33:14.280 --> 33:15.200]  Будет папа.
[33:17.640 --> 33:20.740]  Так, значит, вот тут будет M.
[33:21.440 --> 33:22.560]  Это поле мамы.
[33:23.220 --> 33:23.960]  Тут будет D.
[33:24.080 --> 33:24.940]  Это поле папы.
[33:29.460 --> 33:30.440]  Блин, я не знаю.
[33:30.600 --> 33:32.120]  Ну, это надо как-то по-другому рисовать.
[33:32.240 --> 33:33.220]  А еще и маркер не пишет.
[33:33.240 --> 33:33.880]  Очень плохо все.
[33:34.680 --> 33:35.480]  Блин, я не знаю.
[33:35.560 --> 33:37.040]  Ну, давайте, давайте вот.
[33:37.460 --> 33:38.320]  Короче, картинка.
[33:38.400 --> 33:38.780]  Мама.
[33:39.700 --> 33:40.300]  Папа.
[33:40.300 --> 33:43.560]  Значит, у мамы есть поле M.
[33:44.920 --> 33:47.720]  И метод F.
[33:49.020 --> 33:50.040]  Виртуальный, конечно.
[33:50.800 --> 33:52.280]  Не виртуальный нас не интересует.
[33:52.420 --> 33:53.180]  Они и так.
[33:54.100 --> 33:55.220]  Ну, с ними и так все понятно.
[33:55.700 --> 33:56.960]  У папы есть поле D.
[33:57.180 --> 33:58.960]  И метод, ну, скажем, G.
[34:05.040 --> 34:08.300]  А у меня есть поле.
[34:08.300 --> 34:08.820]  Поле.
[34:09.700 --> 34:11.360]  С и метод H.
[34:12.420 --> 34:13.560]  Да что же это такое?
[34:13.660 --> 34:14.140]  Я не могу.
[34:15.060 --> 34:15.440]  Ну, ладно.
[34:15.520 --> 34:17.080]  Я надеюсь, вечером станет получше.
[34:17.660 --> 34:18.960]  А, вечером я не буду рисовать.
[34:19.060 --> 34:20.400]  Я только проектором буду пользоваться.
[34:22.280 --> 34:24.500]  Ой, Филиппу-то сейчас я сочувствую, конечно.
[34:25.680 --> 34:28.740]  Он уже их в ТСК встал.
[34:28.820 --> 34:30.400]  А, он свои маркеры носит?
[34:30.880 --> 34:32.340]  А он их здесь оставляет?
[34:32.620 --> 34:32.880]  Нет.
[34:33.880 --> 34:34.500]  А-а.
[34:34.500 --> 34:37.860]  Я понял.
[34:38.100 --> 34:38.580]  Блин.
[34:38.580 --> 34:44.800]  Блин, слушайте, вечером у нас будет пара, конечно, а что же у вас еще может быть вечером?
[34:44.800 --> 34:47.480]  Так семинар тоже пара.
[34:48.780 --> 34:52.580]  Знаете, вот есть пара, а частный случай это лекция, семинар.
[34:53.200 --> 34:54.500]  А что будет, если там?
[34:55.960 --> 35:03.160]  А это как раз, а это как раз, да, это пара Ирховича, вот так вот так называют, это частный, это одновременно и то, и другое.
[35:03.320 --> 35:06.160]  На самом деле, мои тоже примерно так устроены, как вы могли заметить.
[35:06.180 --> 35:06.820]  А вы будете лечить?
[35:07.020 --> 35:07.460]  Я буду.
[35:08.580 --> 35:15.180]  Мы с вами опаздываем, нам надо плюсов больше пройти успеть, больше плюсов.
[35:18.960 --> 35:21.580]  Так, как будет выглядеть таблица в таком случае?
[35:21.580 --> 35:25.320]  Не таблица, как будет объект сына в памяти выглядеть?
[35:28.700 --> 35:33.580]  Сначала, а, вимпойнтер, понятное дело, какой-то.
[35:36.420 --> 35:37.780]  Потом в любом порядке, мама.
[35:38.580 --> 35:42.400]  Потом мама, потом что?
[35:45.800 --> 35:49.960]  Ну, типа, наивно хочется сказать, что будет мама, потом дед, потом эс.
[35:51.300 --> 35:51.900]  И вимпойнтер.
[35:51.900 --> 35:53.180]  Мама, эс, потом дед, эс.
[35:55.580 --> 35:56.120]  Че?
[35:56.740 --> 35:57.900]  Я бы написал мама, эс.
[35:57.900 --> 36:01.900]  А, виноват, конечно, сначала, да, их же два будет.
[36:02.040 --> 36:06.220]  Значит, сначала этот эс, потом еще дэ, потом еще раз эс.
[36:07.900 --> 36:08.300]  Стоп.
[36:08.580 --> 36:10.640]  Ему два-то раза эс, я че-то не понял.
[36:11.160 --> 36:13.060]  Стоп, стоп, стоп, стоп, че-то ерунда какая-то.
[36:13.240 --> 36:14.020]  Один эс, какой?
[36:16.660 --> 36:19.840]  Нет, все, один эс, че-то вы меня запутали, нормально все.
[36:20.300 --> 36:21.600]  Вот так, да?
[36:23.080 --> 36:23.680]  Казалось бы.
[36:24.740 --> 36:26.560]  Но нет, так не сработает.
[36:27.520 --> 36:28.540]  Должно быть сложнее.
[36:30.860 --> 36:31.260]  Вот.
[36:33.000 --> 36:38.120]  Вопрос на понимание, почему вот так, почему, короче, одним вимпойнтером мы не обойдемся?
[36:38.580 --> 36:43.960]  Потому что, может, если мы кастанемся, если мы кастанемся наверх, то почему-то у нас...
[36:43.960 --> 36:56.080]  Если мы, если мы прикастуемся к папе, то как мы будем, вот, каст к папе, он вообще на что нас приведет?
[36:56.400 --> 36:57.520]  Ну, он подвинет указатель.
[36:57.520 --> 37:00.520]  Папа вот отсюда начинается, но папа сам полиморфный.
[37:01.660 --> 37:02.900]  Интересно, там должен начинаться...
[37:02.900 --> 37:08.560]  Если мы у папы начнем вызывать какие-нибудь виртуальные методы, то как он?
[37:08.560 --> 37:10.060]  Как он узнает, откуда их вызывать-то?
[37:12.120 --> 37:14.620]  Объект папы, у него где вимпойнтер?
[37:14.680 --> 37:21.360]  Он откуда будет знать, что на самом деле на 16-байт левее лежит еще вимпойнтер от какого-то другого?
[37:21.980 --> 37:24.280]  Ну, короче, папа должен быть вот этот, полноценный.
[37:24.440 --> 37:32.500]  После того, как мы к папе скастовались, с этим папой должно быть работать как с полноценным объектом папы и вызывать у него виртуальные методы.
[37:32.500 --> 37:38.500]  Но если он будет вот так устроен, то как он поймет, как...
[37:38.560 --> 37:40.120]  Где у него виртуальная таблица?
[37:41.580 --> 37:43.640]  Поэтому папе нужна своя виртуальная таблица.
[37:44.080 --> 37:44.520]  Еще одна.
[37:44.660 --> 37:45.560]  Вот здесь должно быть...
[37:47.500 --> 37:49.260]  Здесь снова должен лежать вимпойнтер.
[37:49.460 --> 37:51.720]  Ну, то есть здесь пропущено 4 байта, как всегда.
[37:52.620 --> 37:54.120]  И опять лежит вимпойнтер.
[37:56.920 --> 37:58.560]  Потом только D, потом S.
[37:59.980 --> 38:00.540]  Так, вопрос.
[38:00.720 --> 38:03.420]  А вот здесь не должно ли быть еще одного вимпойнтера?
[38:03.840 --> 38:04.360]  Зачем?
[38:05.080 --> 38:06.280]  Да, действительно, зачем?
[38:06.280 --> 38:06.360]  Зачем?
[38:06.740 --> 38:08.280]  Потому что если мы работаем с сыном...
[38:08.560 --> 38:09.600]  То он начинается здесь.
[38:09.740 --> 38:11.420]  И у него вимпойнтер в самом начале лежит.
[38:12.320 --> 38:14.560]  На самом деле в такой ситуации ровно 2 вимпойнтера.
[38:15.300 --> 38:16.200]  Необходимо и достаточно.
[38:16.800 --> 38:20.640]  Ну, третьего не нужно, потому что у сына вимпойнтер это вот этот и есть вимпойнтер.
[38:21.140 --> 38:22.900]  И он же мамин вимпойнтер.
[38:23.080 --> 38:25.040]  Но ведут они в одно и то же место.
[38:25.820 --> 38:26.080]  Вот.
[38:26.540 --> 38:28.700]  А у папы вот этот вимпойнтер.
[38:28.860 --> 38:28.940]  Да.
[38:28.940 --> 38:35.200]  А вот если мы вызовем у сына J, то он сначала пойдет к мамину?
[38:35.280 --> 38:37.940]  Если мы вызовем у сына J, он увидит...
[38:38.560 --> 38:40.660]  В этой таблице адрес J.
[38:40.800 --> 38:43.900]  В этой таблице написаны адреса и F, и G, и H.
[38:44.000 --> 38:45.660]  Потому что это же сыновний вимпойнтер.
[38:45.940 --> 38:46.140]  А.
[38:46.920 --> 38:50.340]  Вот в этой таблице этот вимпойнтер это сам вимпойнтер.
[38:50.640 --> 38:57.240]  Он ведет на таблицу, в которой написано type info сын, адрес F, адрес J, адрес H.
[38:59.880 --> 39:00.400]  Да.
[39:00.760 --> 39:04.620]  А, у нас вот эти два вимпойнтера, они на одну и ту же?
[39:04.620 --> 39:06.940]  Это следующий вопрос, который я хотел вам задать.
[39:07.360 --> 39:08.160]  Скорее всего нет.
[39:08.560 --> 39:13.840]  Вопрос, указывают ли эти два вимпойнтера, вообще одинаковые ли вот эти два вимпойнтера численно?
[39:13.980 --> 39:16.460]  Просто они на одну и ту же таблицу указывают или на разные?
[39:17.220 --> 39:20.360]  Потому что вообще-то и то и другое сын же.
[39:21.680 --> 39:22.460]  Но это же сын.
[39:22.640 --> 39:23.560]  Они оба должны...
[39:24.080 --> 39:27.460]  Да, но вимпойнтер, но второй он же должен быть только J.
[39:29.680 --> 39:30.500]  Только J.
[39:31.060 --> 39:33.800]  В идее это одна и та же таблица, просто...
[39:33.800 --> 39:34.700]  Нет, подождите.
[39:34.700 --> 39:37.360]  У нас такие помнят предстояния разные.
[39:38.560 --> 39:41.580]  Почему TypeInfo будет принципиально разная?
[39:42.340 --> 39:44.060]  TypeInfo у них должно быть одинаковое.
[39:44.140 --> 39:45.640]  Там нужно утопить это сын.
[39:45.840 --> 39:50.320]  То есть, если я кастанулся к папе, а потом спросил, какой это тип, скажи мне, пожалуйста.
[39:50.400 --> 39:51.240]  Он должен сказать сын.
[39:51.240 --> 39:54.560]  А у нас вот папа и мама разные множества функций.
[39:55.100 --> 40:03.340]  Проблема в том, что если мы вызовемся от указателя на сына, который скастован к указателю на отца, вызовем J,
[40:03.840 --> 40:07.360]  то он прочитает первый элемент из таблицы ВПТР.
[40:08.560 --> 40:11.020]  Потому что это у Дэда, по идее, первый элемент.
[40:11.100 --> 40:11.800]  Нет, нет, нет.
[40:11.960 --> 40:13.380]  Это же сыновний ВПТР.
[40:14.440 --> 40:16.740]  Сыновний ВПТР, у него есть...
[40:16.740 --> 40:19.200]  Ну, он правильные сдвиги хранит.
[40:19.260 --> 40:23.420]  Он хранит, скажем, отступ F, G, H.
[40:23.520 --> 40:24.960]  Короче, он хранит все эти адреса.
[40:24.960 --> 40:27.960]  Ну, просто вот это будет одинаковый...
[40:28.900 --> 40:32.860]  Допустим, это будет одинаковый випойнтер с вот этим.
[40:33.640 --> 40:36.360]  Просто и тот, и другой будет хранить как F, так G, так и H.
[40:37.140 --> 40:37.960]  Нет, но у нас же компилятор.
[40:38.560 --> 40:40.560]  Вот в момент компиляции он должен...
[40:41.160 --> 40:42.560]  Вот он получил в ВПТР.
[40:43.480 --> 40:43.660]  Да.
[40:43.920 --> 40:45.600]  У какого-то объекта, пока что не знаю.
[40:45.920 --> 40:46.260]  Ага.
[40:46.580 --> 40:50.820]  Он должен на моменте компиляции знать, сколько от этого ВПТР вступить,
[40:50.920 --> 40:52.260]  чтобы найти функцию G.
[40:52.540 --> 40:52.900]  Да.
[40:54.060 --> 40:55.860]  И если у нас...
[40:55.860 --> 40:56.800]  Да, я понял проблему.
[40:56.880 --> 40:57.720]  Кстати, это хороший вопрос.
[40:57.960 --> 40:59.280]  Надо подумать, как это происходит.
[40:59.940 --> 41:00.340]  Покажешь.
[41:01.540 --> 41:06.120]  Как компилятор в compile time знает, сколько отступить байт,
[41:06.120 --> 41:08.480]  насколько, чтобы найти адрес нужный.
[41:08.560 --> 41:09.060]  Функции.
[41:09.060 --> 41:09.580]  Ага.
[41:12.220 --> 41:14.840]  Теоретически это можно же попасть?
[41:19.520 --> 41:22.060]  Это кажется, что это виппоинтер.
[41:22.660 --> 41:23.540]  Нет.
[41:23.540 --> 41:23.640]  Нет.
[41:24.240 --> 41:25.120]  Только виппоинтер.
[41:32.440 --> 41:35.820]  Ну, когда нет множественного наследования, у нас один виппоинтер,
[41:35.940 --> 41:37.200]  и там все функции лежат.
[41:37.680 --> 41:38.540]  И они просто...
[41:38.560 --> 41:39.460]  Друг друга дополняют.
[41:39.840 --> 41:40.000]  Да.
[41:40.180 --> 41:43.820]  Когда у нас множественное наследование, у нас вот такая проблема, например, есть.
[41:44.720 --> 41:46.080]  Вот если мы у папы пытаемся...
[41:46.080 --> 41:48.960]  Вот если мы скастовались к папе, пытаемся вызвать G.
[41:50.720 --> 41:55.220]  Откуда он поймет, что, значит...
[41:57.440 --> 42:01.620]  Насколько надо отступить?
[42:02.920 --> 42:04.640]  Ну, кажется, вы правы.
[42:04.640 --> 42:05.640]  Кажется...
[42:05.640 --> 42:07.640]  Кажется, это...
[42:08.560 --> 42:10.800]  Аргумент, почему это должны быть разные таблицы.
[42:11.760 --> 42:12.000]  Сейчас.
[42:12.220 --> 42:13.960]  А, мы вызвались от папы.
[42:14.400 --> 42:18.420]  На самом деле таблицы должны быть разные, просто я другую причину хотел назвать.
[42:18.480 --> 42:21.360]  Я сейчас вам другую причину назову, почему одной таблице не обойтись.
[42:21.360 --> 42:25.200]  Но, кажется, это тоже еще одна причина, почему одной таблице не обойтись, действительно.
[42:25.980 --> 42:26.820]  То есть в папиной...
[42:26.820 --> 42:28.880]  Вот в этой таблице будет лежать сначала G, потом H.
[42:29.160 --> 42:29.320]  Да.
[42:29.820 --> 42:30.600]  Мы вызвались от...
[42:30.600 --> 42:31.820]  Мы скастовались к папе.
[42:31.880 --> 42:32.100]  Да.
[42:32.360 --> 42:34.080]  Потом написали D.G.
[42:34.600 --> 42:34.780]  Да.
[42:34.940 --> 42:35.660]  Вызвали метод G.
[42:36.040 --> 42:38.360]  Компилятор в compile time должен сгенерировать какие-то инструкции,
[42:38.840 --> 42:40.060]  где найти адрес метода G.
[42:41.100 --> 42:41.960]  Где вот его найти?
[42:42.880 --> 42:44.540]  Вот мы у папы вызываем G.
[42:44.840 --> 42:47.420]  Если мы ссылка на сына.
[42:47.440 --> 42:50.060]  Мы ссылка на сына, но тип у нас статический.
[42:50.060 --> 42:50.620]  Тип это D.
[42:50.940 --> 42:56.140]  В compile time невозможно знать компилятору, что реально это.
[42:56.200 --> 42:57.980]  Настоящий это сын или папа.
[42:58.440 --> 43:00.500]  Он видит, что тип переменный D.
[43:00.840 --> 43:02.080]  И вызывается G.
[43:02.800 --> 43:03.960]  Но G виртуальная.
[43:04.080 --> 43:06.060]  Значит, ему нужно сгенерировать какую-то...
[43:07.600 --> 43:08.360]  Ну...
[43:08.360 --> 43:09.220]  Прыжок куда-то.
[43:09.380 --> 43:13.580]  Вот он в нормальной ситуации, он бы прыгнул на таблицу виртуальных...
[43:13.580 --> 43:16.460]  Может, это вовсе и не сын.
[43:16.660 --> 43:17.760]  Может, это настоящий папа.
[43:18.540 --> 43:21.220]  Он должен прыгнуть на таблицу виртуальных функций папы.
[43:21.740 --> 43:25.540]  И там найти вот как бы первую по очереди G.
[43:25.680 --> 43:25.740]  Да?
[43:26.140 --> 43:26.520]  Вот эту.
[43:27.440 --> 43:33.880]  Но может, это вообще у папы еще дочка есть внебрачная.
[43:34.340 --> 43:37.500]  И на самом деле мама у нее другая.
[43:37.500 --> 43:37.720]  Вот.
[43:37.720 --> 43:42.980]  Если так сделать, то как он будет G находить?
[43:43.080 --> 43:45.460]  Ну, про F там вообще никто не будет знать.
[43:46.020 --> 43:51.720]  Ну, короче, когда мы от D вызываем G, кажется, что она должна быть первой в таблице упомянута.
[43:53.400 --> 43:53.680]  Вот.
[43:54.180 --> 43:58.140]  То есть, это уже должна быть другая таблица, а не та же самая, что и вот эта.
[43:59.180 --> 44:00.420]  Но есть и другая проблема.
[44:00.720 --> 44:05.600]  Мне кажется, эта проблема более, так скажем, понятная.
[44:05.600 --> 44:07.600]  Представьте, что я сделал...
[44:07.720 --> 44:09.220]  Каст от сына к папе.
[44:09.860 --> 44:12.600]  А теперь хочу сделать динамик каст от папы к сыну.
[44:20.120 --> 44:21.360]  А, нет, не так.
[44:21.760 --> 44:23.700]  Хочу сделать динамик каст...
[44:23.700 --> 44:25.680]  Да, от папы к маме.
[44:25.800 --> 44:25.960]  Вот.
[44:27.160 --> 44:29.940]  Вот, смотрите, у меня был сын.
[44:30.040 --> 44:31.560]  Я сделал динамик каст к папе.
[44:32.460 --> 44:34.160]  Ну, или просто обычный каст.
[44:34.160 --> 44:36.480]  А потом хочу сделать динамик каст к маме.
[44:36.600 --> 44:37.440]  К сыну-то понятно.
[44:37.440 --> 44:39.060]  К маме хочу сделать динамик каст.
[44:41.000 --> 44:42.340]  Как он сработает?
[44:42.600 --> 44:45.160]  Мне кажется, он будет делать сначала как можно ниже.
[44:45.680 --> 44:48.260]  Ну, то есть, он смотрит, какой тип.
[44:48.400 --> 44:49.440]  Ну, изначально это был сын.
[44:49.580 --> 44:50.440]  Он делает к сыну.
[44:50.860 --> 44:52.820]  Потом, если у сына есть мать...
[44:52.820 --> 44:54.520]  Он не делает к сыну, потому что это ужасно.
[44:54.880 --> 44:56.660]  Нет, мы же папа изначально.
[44:56.820 --> 44:59.820]  Ну, точнее, мы сейчас как папа, но, предназначенно, под папой лежит сын.
[45:00.280 --> 45:00.620]  Ну, вот.
[45:00.680 --> 45:04.280]  Он сначала к сыну, а сейчас тут можно ниже опускать, а потом пытается...
[45:04.280 --> 45:05.700]  А-а-а...
[45:05.700 --> 45:07.280]  Вот, представьте, что у вас вот этот...
[45:07.280 --> 45:09.140]  Эта таблица и вот эта таблица неотличимы.
[45:12.600 --> 45:15.580]  Если вот эта таблица в точности такая же, как эта таблица.
[45:16.220 --> 45:18.480]  И вам надо сделать динамик кастов к папе и к маме.
[45:19.700 --> 45:22.180]  Ему надо проверить, корректен ли каст же.
[45:22.380 --> 45:26.600]  Ему же не просто надо сделать в тупую, как стати касту, шаги влево-вправо.
[45:27.240 --> 45:28.680]  Он видит папу.
[45:29.720 --> 45:30.980]  В таблице написано сын.
[45:32.180 --> 45:34.920]  И ему надо проверить, сделать динамик каст к маме.
[45:35.340 --> 45:35.920]  От дэда.
[45:35.920 --> 45:36.840]  Но как?
[45:37.280 --> 45:42.980]  ему вообще проверить-то, это правда, ну, в какую сторону двигаться.
[45:43.040 --> 45:48.340]  Динамик каст должен выдать ошибку, если вы на самом деле кастуете к тому, к чему нельзя.
[45:50.780 --> 45:55.500]  Ну, у нас же есть, мы же можем, по идее, через него как-то узнать,
[45:55.500 --> 46:02.500]  является ли мазер родителем, ну, где-то там выше по дереву наследованного.
[46:03.100 --> 46:07.100]  Мы же все равно, когда сам кастуем, идем по дереву и ищем мазер, нет?
[46:07.280 --> 46:23.020]  Сейчас, сейчас, сейчас, я затупил немножечко, давайте еще раз подумаем.
[46:23.020 --> 46:24.920]  Может, это и работает, то, что я сказал, да?
[46:25.500 --> 46:28.780]  То есть у меня, допустим, вот эта таблица, вот эта таблица неотличима.
[46:29.320 --> 46:36.020]  Я сделал динамик каст от типа...
[46:36.020 --> 46:41.140]  Дэд к типу мам.
[46:42.660 --> 46:45.460]  Вот, и я вот стартовал отсюда.
[46:46.680 --> 46:49.080]  Правда ли, что он всегда может проверить корректность,
[46:49.660 --> 46:53.500]  что это действительно был настоящий дэд?
[46:55.420 --> 46:57.980]  Что это действительно была мама, вот так скажем.
[46:58.100 --> 47:02.900]  Что действительно можно скастовать к маме того дэда, который я попросил.
[47:03.360 --> 47:03.480]  Да.
[47:06.020 --> 47:12.160]  Дело в том, что это может быть...
[47:12.160 --> 47:23.160]  Ну, если это какой-то другой тип, то кажется, что он может про каждый тип знать, на каком месте там лежит папа, да?
[47:25.160 --> 47:25.600]  И...
[47:25.600 --> 47:26.660]  И-и-и-и...
[47:31.660 --> 47:33.540]  Да, кажется, в этой ситуации работает.
[47:33.980 --> 47:35.560]  Кажется, в этой ситуации будет работать.
[47:36.020 --> 47:38.420]  А не будет работать вот в какой ситуации.
[47:38.540 --> 47:40.620]  Не будет работать в ситуации, когда ромбовидное наследование.
[47:41.940 --> 47:45.020]  Вот если у меня еще была Грэнни, то все, уже капец.
[47:45.300 --> 47:45.580]  Почему?
[47:46.000 --> 47:47.200]  Ну, потому что их две.
[47:48.500 --> 47:58.160]  И если я кастуюсь от бабушки к сыну, то...
[47:58.160 --> 47:58.960]  Вы вообще не можете.
[47:59.460 --> 48:00.680]  А, да, мы не знаем.
[48:01.220 --> 48:04.660]  Вы сделали переменную силу на Грэнни и сына, да?
[48:06.020 --> 48:07.620]  А-а-а...
[48:07.620 --> 48:10.220]  И хотите как? Вы хотите себя обратно?
[48:10.740 --> 48:11.280]  Да.
[48:12.540 --> 48:15.020]  Я хочу, значит...
[48:16.220 --> 48:17.020]  Ха-ха-ха-ха...
[48:17.980 --> 48:20.860]  Да, что-то я озадачился.
[48:21.760 --> 48:24.220]  Мне казалось, что динамик каст так не сможет работать.
[48:25.060 --> 48:28.020]  Сейчас посылка на Грэнни и сына, мы просто приезжаем сюда и просто посылка.
[48:28.660 --> 48:29.580]  И ничего не делаем.
[48:29.580 --> 48:30.600]  Ничего не делаем.
[48:36.020 --> 48:53.520]  Ну, в общем, я хочу, на самом деле, всем этим монологом мотивировать тот факт,
[48:53.580 --> 48:56.220]  что нужно хранить еще некоторое число в этой таблице дополнительно.
[48:57.020 --> 49:00.340]  То есть вот эта таблица и эта таблица, помимо typeInfo и адресов функций,
[49:00.340 --> 49:01.280]  хранит еще сдвиг.
[49:02.060 --> 49:05.920]  А относительно начала объекта мы как далеко.
[49:06.020 --> 49:07.160]  Вот, что она хранит.
[49:08.040 --> 49:09.720]  То есть это, в принципе, разные таблицы?
[49:09.820 --> 49:12.700]  Это разные таблицы, как минимум, потому что мы уже сказали,
[49:12.800 --> 49:14.980]  потому что у них в разном порядке функции перечислены.
[49:15.800 --> 49:16.040]  Вот.
[49:16.160 --> 49:21.260]  Но, помимо прочего, эта таблица и эта таблица хранят еще числа,
[49:21.880 --> 49:24.640]  говорящие, где мы относительно начала сына.
[49:27.460 --> 49:27.940]  Вот.
[49:28.160 --> 49:30.380]  То есть это так называемый top-offset.
[49:30.820 --> 49:30.980]  Вот.
[49:31.840 --> 49:35.740]  Я что-то сейчас забыл сценарий, когда без него нельзя.
[49:36.020 --> 49:38.740]  Вот, кажется, что при динамик касте без него было бы нельзя.
[49:39.960 --> 49:42.640]  Типа, если мы пытаемся от мамы к папе скастоваться,
[49:43.760 --> 49:50.420]  или от папы к маме наоборот,
[49:51.800 --> 49:53.740]  то, то, то, то, то.
[50:03.000 --> 50:06.000]  Ну, если мы пытаемся скастоваться от папы к сыну,
[50:06.020 --> 50:08.240]  то я вижу type-info «сын».
[50:08.240 --> 50:10.940]  Понимаю, что раз я сын, и я в нем папа,
[50:11.000 --> 50:15.000]  значит, наверное, мне нужно шагнуть влево, и сын будет там.
[50:15.780 --> 50:18.500]  Да, если я от мамы к сыну кастуюсь,
[50:18.560 --> 50:20.780]  то я просто проверяю type-info, никуда не сдвигаюсь.
[50:21.140 --> 50:24.020]  Если от мамы к папе кастуюсь, то я опять-таки проверяю.
[50:25.400 --> 50:26.020]  То есть кажется...
[50:26.980 --> 50:30.540]  Кажется, это даже работает.
[50:36.020 --> 50:39.140]  Ну, у меня переменная имеет тип «dead».
[50:39.140 --> 50:42.740]  И если я от этой переменной делаю каст к сыну,
[50:45.640 --> 50:48.680]  то динамик каст видит, что я от папы к сыну делаю каст.
[50:48.860 --> 50:50.900]  Я предполагаю, что от папы настоящий.
[50:51.800 --> 50:55.020]  Вот, и от него делаю каст, значит...
[50:56.140 --> 51:04.180]  Да, ну, кажется, что в этой ситуации можно было и без этого обойтись.
[51:06.020 --> 51:10.840]  Ммм, да, что-то я...
[51:10.840 --> 51:13.100]  Что-то я забыл.
[51:20.240 --> 51:25.400]  Да, да, да, да, кажется, что в этой ситуации у меня top-offset,
[51:25.580 --> 51:26.680]  вот это число не нужно.
[51:28.380 --> 51:30.700]  Ну, давайте я вам просто скажу, что оно там хранится.
[51:31.700 --> 51:32.560]  Хуже не будет.
[51:32.880 --> 51:33.960]  Вот зачем-то оно нужно.
[51:33.960 --> 51:35.920]  Сейчас, может быть, мы пример придумаем.
[51:36.020 --> 51:37.280]  Все-таки, когда без него не обойтись.
[51:38.000 --> 51:40.920]  Ну, как минимум, без него не обойтись, когда у нас есть грэнни общая.
[51:41.820 --> 51:48.420]  Вот, чтобы понять, какая это грэнни, мне надо, значит, вызваться...
[51:48.420 --> 51:52.280]  Ну, чтобы понять, какая это грэнни, да, мне надо будет посмотреть на этот top-offset.
[51:53.040 --> 51:58.120]  Сейчас у нас будет разница между грэнни, которая будет через папу, и грэнни, которая будет через маму?
[51:59.120 --> 52:05.780]  А, кажется, знаете, когда это будет нужно?
[52:06.020 --> 52:10.480]  Представь, что у меня есть грэнни общая, вот, есть грэнни тут, и грэнни тут.
[52:10.480 --> 52:17.000]  И я скастовался от сына к одной из двух грэнни, а потом эту грэнни пытаюсь скастовать, скажем, к папе.
[52:17.000 --> 52:21.000]  Вот как понять, эту грэнни можно скастовать к папе или нельзя?
[52:25.000 --> 52:29.000]  Это та грэнни, которая от мамы, или та грэнни, которая от папы?
[52:29.000 --> 52:32.000]  Динамик касту надо уметь это проверять.
[52:32.000 --> 52:33.000]  Быстрый вопрос.
[52:33.000 --> 52:34.000]  Когда мы пишем...
[52:34.000 --> 52:36.000]  Мы не можем написать просто грэнни с сыном.
[52:36.020 --> 52:38.020]  Грэнни с сылом равно сыну, да?
[52:38.020 --> 52:41.020]  Грэнни с сылом равно... Да, потому что их две, непонятно какую выбрать.
[52:41.020 --> 52:45.020]  Но мы скастовались сначала, допустим, к маме, потом к бабушке.
[52:45.020 --> 52:47.020]  Вот, смотрите, вот, допустим, у меня такая ситуация.
[52:47.020 --> 52:55.020]  У меня вот еще есть поле G, вот если бы у меня была еще бабушка, то ситуация бы стала такой.
[52:55.020 --> 53:05.020]  У меня здесь сначала лежит vptr, потом лежит поле G, потом лежит поле M, потом лежит снова поле G,
[53:05.020 --> 53:06.020]  потом лежит поле R.
[53:06.020 --> 53:15.020]  Вот в такой ситуации уже без дополнительного поля мне не обойтись.
[53:15.020 --> 53:22.020]  Вот, смотрите, да, я скастовался сначала к папе, потом к бабушке от папы.
[53:22.020 --> 53:32.020]  И потом я от этой бабушки пытаюсь скастоваться, ну, к папе, скажем, обратно.
[53:32.020 --> 53:35.020]  И вот динамик касту нужно...
[53:35.020 --> 53:38.020]  Динамик касту нужно уметь понимать.
[53:38.020 --> 53:41.020]  Это как? Это что значит от бабушки к папе?
[53:41.020 --> 53:45.020]  Это вообще можно? То есть эта бабушка действительно является папой или нет?
[53:45.020 --> 53:50.020]  Ну, просто если бы в этой таблице было написано лишь, что это сын,
[53:50.020 --> 53:55.020]  то динамик каст бы не понял, что эта бабушка на самом деле является папой.
[53:55.020 --> 53:58.020]  Но там написано не просто это.
[53:58.020 --> 54:01.020]  Там написано, что это папа в сыне.
[54:01.020 --> 54:04.020]  Ну, там, короче, написано, что это сын.
[54:04.020 --> 54:08.020]  Что это сын, а еще хранится сдвиг относительно начала сына.
[54:08.020 --> 54:13.020]  И таким образом динамик каст поймет, что это на самом-то деле бабушка, которая от папы, а не от мамы.
[54:13.020 --> 54:17.020]  И скастует правильно.
[54:17.020 --> 54:25.020]  Вот, короче, на самом деле, итог всех этих разговоров, это две разные таблицы.
[54:25.020 --> 54:33.020]  И различаются они не только порядком, в каком порядке функции перечислены адреса, а еще и одним числом.
[54:33.020 --> 54:38.020]  Вот в этих таблицах хранится так называемый сдвиг относительно, ну, top of set он называется.
[54:38.020 --> 54:41.020]  Сдвиг относительно начала объекта.
[54:41.020 --> 54:53.020]  И это нужно, например, для того, чтобы динамик каст, когда вы его вызываете, знал, в какую сторону сдвигаться, если у вас неоднозначность.
[54:53.020 --> 54:55.020]  Но не только для этого.
[54:55.020 --> 54:57.020]  А вот еще смотрите для чего.
[54:57.020 --> 54:59.020]  Вот представьте, что я вызываю у этой бабушки...
[54:59.020 --> 55:02.020]  Ну, вот я скастовался, да хоть к папе к тому же.
[55:03.020 --> 55:08.020]  Вот я скастовался, ну, давайте для надежности, к бабушке от папы.
[55:08.020 --> 55:10.020]  Вот я скастовался к папе, а потом к бабушке.
[55:10.020 --> 55:17.020]  А теперь я вызываю у этой бабушки метод, знаете какой?
[55:17.020 --> 55:19.020]  Метод H.
[55:19.020 --> 55:23.020]  Нет, метод не H.
[55:23.020 --> 55:26.020]  Метод, ну, метод какой-то, метод G.
[55:26.020 --> 55:27.020]  Да?
[55:27.020 --> 55:29.020]  Но у сына он переопределен.
[55:29.020 --> 55:31.020]  Вот, смотрите.
[55:31.020 --> 55:33.020]  Какая интересная ситуация.
[55:33.020 --> 55:39.020]  Допустим, я скастовался к бабушке, от папы которая.
[55:39.020 --> 55:45.020]  Ну и, допустим, у нее тоже был метод G.
[55:45.020 --> 55:48.020]  Вот этот метод, виртуальный G, он от бабушки унаследован.
[55:48.020 --> 55:50.020]  А у сына он переопределен.
[55:50.020 --> 55:56.020]  И я вызываю у этой бабушки метод, переопределенный в сыне, G.
[55:56.020 --> 56:00.020]  Но поскольку это на самом деле сын, должна выполняться версия из сына.
[56:00.020 --> 56:02.020]  Но версия из сына может обращаться к папе.
[56:02.020 --> 56:06.020]  А версия из сына может обращаться к полям уже от мамы.
[56:06.020 --> 56:08.020]  А где их искать?
[56:08.020 --> 56:15.020]  Когда я вызываю метод какой-то, переопределенный в сыне, вот от этой штуки,
[56:15.020 --> 56:18.020]  этот метод может обращаться вот к этим полям.
[56:18.020 --> 56:23.020]  А откуда он будет знать, где эти поля относительно него?
[56:23.020 --> 56:25.020]  И вот тут опять нужен Top Offset.
[56:25.020 --> 56:30.020]  То есть ему надо понимать, вот эта бабушка, которой я сейчас являюсь, я у нее вызываю G.
[56:30.020 --> 56:35.020]  Поля настоящие где начинаются, к которым обращаться мне?
[56:35.020 --> 56:40.020]  Мне нужно вот этот сдвиг хранить, чтобы знать, когда вызываются методы сына,
[56:40.020 --> 56:44.020]  где начало объекта относительно начала меня сейчас.
[56:44.020 --> 56:48.020]  Вот на этот сдвиг я смотрю, когда вызываюсь от сына.
[56:48.020 --> 56:52.020]  Ну, когда вызываю переопределенный в сыне метод от вот этой бабушки.
[56:52.020 --> 56:59.020]  Короче, сыну надо понимать в рантайме вот этот вот поинтер относительно начала объекта,
[56:59.020 --> 57:04.020]  как далеко отстоит, чтобы если я таки вызвался от переопределенного в сыне метода,
[57:04.020 --> 57:08.020]  знать правильно, где поля, чтобы если он начнет обращаться к M,
[57:08.020 --> 57:13.020]  то понимать, что M это вот отсюда надо отсчитывать, а не отсюда.
[57:13.020 --> 57:15.020]  Понимаете проблему?
[57:15.020 --> 57:17.020]  Итак, как выглядят эти две таблицы?
[57:17.020 --> 57:18.020]  Давайте нарисуем.
[57:18.020 --> 57:20.020]  Вот это WPTR1, вот это WPTR2.
[57:20.020 --> 57:24.020]  WPTR1 выглядит так.
[57:24.020 --> 57:28.020]  Сначала лежит.
[57:28.020 --> 57:35.020]  Ну, значит, сын type-info.
[57:35.020 --> 57:38.020]  Ну, тут, значит, есть еще.
[57:38.020 --> 57:41.020]  Это указывает сюда.
[57:41.020 --> 57:47.020]  Но тут еще есть число, называемое top-offset.
[57:47.020 --> 57:49.020]  Top-offset равный нулю.
[57:49.020 --> 57:52.020]  Говорящее, что мы в начале объекта.
[57:52.020 --> 57:54.020]  После чего лежат адреса.
[57:54.020 --> 57:56.020]  Адрес чего там?
[57:56.020 --> 57:57.020]  Адрес F.
[57:58.020 --> 58:00.020]  Адрес G.
[58:00.020 --> 58:02.020]  Адрес H.
[58:14.020 --> 58:17.020]  Сейчас, у нас адрес G внутри Lava лежит.
[58:17.020 --> 58:19.020]  Да, кстати, это тоже отличный вопрос.
[58:19.020 --> 58:22.020]  А как все-таки...
[58:22.020 --> 58:25.020]  Да, а адрес G вот должен там лежать или нет?
[58:25.020 --> 58:26.020]  Ну, вообще-то должен.
[58:26.020 --> 58:29.020]  Потому что это еще виртуальная таблица для сына.
[58:33.020 --> 58:36.020]  Так, кажется, все опять сломалось.
[58:46.020 --> 58:48.020]  Наверное, вот этот адрес...
[58:48.020 --> 58:50.020]  Наверное, знаете что?
[58:50.020 --> 58:52.020]  Наверное, там еще все сложнее.
[58:52.020 --> 58:54.020]  Ну, потому что да, теперь непонятно.
[58:54.020 --> 58:57.020]  Вот в таблице мамы мы должны адрес G хранить или нет?
[58:57.020 --> 59:00.020]  Видимо, придется в рантайме.
[59:00.020 --> 59:03.020]  Короче, видимо, в компайл тайме вот эти адреса не посчитать.
[59:03.020 --> 59:05.020]  Видимо, в рантайме надо считать.
[59:05.020 --> 59:07.020]  То есть смотреть, что если это сын,
[59:07.020 --> 59:13.020]  то уже считать по порядку, какой адрес где.
[59:14.020 --> 59:16.020]  Сейчас.
[59:20.020 --> 59:23.020]  Мы же сейчас должны находиться в маме.
[59:23.020 --> 59:26.020]  Ну, вот это vptr для мамы в сыне.
[59:26.020 --> 59:27.020]  Мама в сыне, да.
[59:27.020 --> 59:30.020]  И при этом в маме мы ничего про G не знаем.
[59:32.020 --> 59:35.020]  Но поскольку это сын, у него же должно быть G.
[59:35.020 --> 59:40.020]  Ну, если это сын, на самом деле, то мы перейдем по ссылке сына.
[59:40.020 --> 59:42.020]  Ну, сдвинемся на топов с этой.
[59:42.020 --> 59:44.020]  И там уже будет где-то G.
[59:44.020 --> 59:47.020]  Не-не, вот этот vptr, он общий для мамы и для сына.
[59:50.020 --> 59:52.020]  Он не общий тот минимум, потому что у них разные виртуальные...
[59:53.020 --> 59:55.020]  Нет-нет.
[59:55.020 --> 59:59.020]  Объект сына начинается с vptr.
[59:59.020 --> 01:00:03.020]  Если я скастую его к маме, то этот vptr будет тем же самым останется.
[01:00:04.020 --> 01:00:07.020]  И тут адрес G должен быть записан в том числе.
[01:00:09.020 --> 01:00:11.020]  У сына я же могу вызывать G?
[01:00:12.020 --> 01:00:14.020]  Вот адрес G где-то должен быть записан.
[01:00:14.020 --> 01:00:17.020]  Ну, видимо, он здесь все-таки должен быть записан.
[01:00:17.020 --> 01:00:20.020]  Если G только в DAD определено,
[01:00:20.020 --> 01:00:22.020]  то у нас может быть G только в DAD записано,
[01:00:22.020 --> 01:00:24.020]  но все еще его можно вызывать.
[01:00:24.020 --> 01:00:26.020]  Но в сыне-то оно должно быть, а это vptr для сына.
[01:00:26.020 --> 01:00:31.020]  Но это не полный vptr, у нас vptr 2 тоже внутри сына.
[01:00:31.020 --> 01:00:33.020]  Если я скастую...
[01:00:33.020 --> 01:00:36.020]  Если я просто возьму сына и вызову у него G,
[01:00:36.020 --> 01:00:38.020]  то как он поймет, какую вызывать?
[01:00:38.020 --> 01:00:41.020]  Сейчас, у нас в сыне лежит один из этих двух vptr.
[01:00:41.020 --> 01:00:43.020]  В сыне лежат оба эти vptr.
[01:00:43.020 --> 01:00:45.020]  Тогда можно называть G из второго.
[01:00:49.020 --> 01:00:51.020]  Типа ты хочешь сказать, что если у меня сын,
[01:00:51.020 --> 01:00:54.020]  то я беру не первый vptr и просит вызвать G,
[01:00:54.020 --> 01:00:57.020]  то я беру не первый vptr, а второй vptr,
[01:00:57.020 --> 01:01:01.020]  и из него беру G.
[01:01:01.020 --> 01:01:03.020]  Ну да.
[01:01:03.020 --> 01:01:05.020]  Это логично хотя бы.
[01:01:05.020 --> 01:01:07.020]  Сейчас, а если мы скастуемся к маме,
[01:01:07.020 --> 01:01:09.020]  то у нас скастуемся к бабушке и вызовем G,
[01:01:09.020 --> 01:01:11.020]  тогда G не будет в первом vptr,
[01:01:11.020 --> 01:01:13.020]  то есть бабушка не сможет его вызвать.
[01:01:13.020 --> 01:01:17.020]  Бабушка не может вызвать, если у нас нет уже G.
[01:01:17.020 --> 01:01:18.020]  А у нас есть.
[01:01:18.020 --> 01:01:20.020]  Если есть, то у нас нет проблем.
[01:01:20.020 --> 01:01:22.020]  Да, если есть, то нет проблем.
[01:01:22.020 --> 01:01:24.020]  Мы такую пока ситуацию рассматриваем,
[01:01:24.020 --> 01:01:27.020]  что F здесь, G здесь, H в сыне.
[01:01:27.020 --> 01:01:30.020]  Да, слушайте, ну, короче, не знаю, как это реализовано.
[01:01:30.020 --> 01:01:32.020]  Я не могу...
[01:01:32.020 --> 01:01:34.020]  Ну, возможно, возможно так, как ты говоришь.
[01:01:34.020 --> 01:01:36.020]  Возможно, просто G лежит здесь.
[01:01:36.020 --> 01:01:38.020]  Возможно, G лежит и там, и там,
[01:01:38.020 --> 01:01:40.020]  и ему в рантайме нужно вычислять эти сдвиги,
[01:01:40.020 --> 01:01:42.020]  а не в компайл тайме.
[01:01:42.020 --> 01:01:44.020]  То есть он смотрит, что это сын,
[01:01:44.020 --> 01:01:46.020]  и в зависимости от этого,
[01:01:46.020 --> 01:01:48.020]  либо на 4 там прыгает, чтобы найти F,
[01:01:48.020 --> 01:01:49.020]  либо на 8.
[01:01:49.020 --> 01:01:51.020]  Ну, короче, не знаю.
[01:01:51.020 --> 01:01:52.020]  Вот.
[01:01:52.020 --> 01:01:54.020]  Тем не менее, здесь еще лежит топ оффсет.
[01:01:54.020 --> 01:01:58.020]  Ну, а вот здесь, vptr2, тут лежит, значит,
[01:01:58.020 --> 01:02:01.020]  опять SunTypeInfo.
[01:02:01.020 --> 01:02:03.020]  Ну, TypeInfo то же самое.
[01:02:03.020 --> 01:02:05.020]  Оффсет другой.
[01:02:05.020 --> 01:02:12.020]  Ну, и, возможно, другие...
[01:02:12.020 --> 01:02:16.020]  Ну, по идее, значит, другие числа.
[01:02:16.020 --> 01:02:19.020]  Ну, возможно, здесь не упомянуто G,
[01:02:19.020 --> 01:02:21.020]  не упомянуто F, а упомянуто только G.
[01:02:21.020 --> 01:02:25.020]  Да.
[01:02:25.020 --> 01:02:28.020]  Ну, похоже, может быть, так и есть, действительно,
[01:02:28.020 --> 01:02:31.020]  что, по крайней мере, это кажется наиболее,
[01:02:31.020 --> 01:02:38.020]  сейчас кажется наиболее таким логичным способом.
[01:02:38.020 --> 01:02:42.020]  Чего?
[01:02:42.020 --> 01:02:43.020]  Здрасте, приехали.
[01:02:43.020 --> 01:02:44.020]  Мы пол...
[01:02:44.020 --> 01:02:45.020]  Мы уже минут 20 обсуждаем,
[01:02:45.020 --> 01:02:46.020]  что их две,
[01:02:46.020 --> 01:02:51.020]  и выясняем, что конкретно в какой из них лежит.
[01:02:51.020 --> 01:02:53.020]  А что?
[01:02:53.020 --> 01:02:55.020]  Что их реально две.
[01:02:55.020 --> 01:02:56.020]  Да, что их реально две.
[01:02:56.020 --> 01:02:59.020]  Вы не шутили все это время?
[01:02:59.020 --> 01:03:02.020]  Да, не шутили, так и есть.
[01:03:02.020 --> 01:03:04.020]  Так, последний пример, который надо разобрать,
[01:03:04.020 --> 01:03:11.020]  это что происходит, когда виртуальное наследование.
[01:03:11.020 --> 01:03:12.020]  При виртуальном наследовании
[01:03:12.020 --> 01:03:15.020]  там добавляется дополнительная хрень.
[01:03:15.020 --> 01:03:18.020]  Ну, представьте, что у меня виртуальная бабушка теперь,
[01:03:18.020 --> 01:03:19.020]  вот у всех этих.
[01:03:19.020 --> 01:03:22.020]  Виртуальное – это который нельзя создавать объект.
[01:03:22.020 --> 01:03:25.020]  Нет.
[01:03:25.020 --> 01:03:30.020]  Виртуальный – это который один на всех наследников.
[01:03:30.020 --> 01:03:32.020]  Да, то есть в нормальной ситуации,
[01:03:32.020 --> 01:03:34.020]  как бы выглядела эта штука при виртуальном наследовании,
[01:03:34.020 --> 01:03:36.020]  если бы не было...
[01:03:36.020 --> 01:03:38.020]  Если бы было виртуальное наследование,
[01:03:38.020 --> 01:03:40.020]  но не было бы виртуальных функций,
[01:03:40.020 --> 01:03:42.020]  как бы выглядела вот эта штука?
[01:03:42.020 --> 01:03:44.020]  У нас был бы сначала...
[01:03:45.020 --> 01:03:55.020]  vptr, потом мама, потом vptr, еще один.
[01:03:55.020 --> 01:03:58.020]  Нет виртуальных функций, но есть виртуальное наследование.
[01:03:58.020 --> 01:04:01.020]  Я напоминаю, что при виртуальном наследовании
[01:04:01.020 --> 01:04:06.020]  каждый наследник должен хранить поинтер в начале себя,
[01:04:06.020 --> 01:04:09.020]  где лежит бабушка.
[01:04:09.020 --> 01:04:12.020]  Но на самом деле этот поинтер ведет не прямо на бабушку,
[01:04:12.020 --> 01:04:14.020]  а он опять-таки ведет на таблицу,
[01:04:14.020 --> 01:04:17.020]  в которой, в числе прочего, написано, где лежит бабушка.
[01:04:17.020 --> 01:04:29.020]  Вот, vptr m, vptr d, а потом, значит, s, а потом g.
[01:04:29.020 --> 01:04:31.020]  И вот это бабушка как раз.
[01:04:31.020 --> 01:04:35.020]  И вот эти vptr, они ведут на некоторую таблицу,
[01:04:35.020 --> 01:04:38.020]  в которой написано, что бабушка тут.
[01:04:38.020 --> 01:04:42.020]  А как это теперь...
[01:04:42.020 --> 01:04:44.020]  Ну, то есть, по сути, тут написано одно число
[01:04:44.020 --> 01:04:46.020]  относительно меня, где бабушка.
[01:04:46.020 --> 01:04:49.020]  И вот это число называется virtual offset.
[01:04:49.020 --> 01:04:52.020]  Есть top offset, а есть virtual offset.
[01:04:52.020 --> 01:04:55.020]  Вот virtual offset — это где относительно меня лежит бабушка.
[01:04:55.020 --> 01:05:01.020]  Вот тут она лежит на 28 правее,
[01:05:01.020 --> 01:05:03.020]  тут она на 12.
[01:05:03.020 --> 01:05:05.020]  Но если у меня добавляются виртуальные функции,
[01:05:05.020 --> 01:05:09.020]  то все становится опять, вот вместе с этим,
[01:05:09.020 --> 01:05:11.020]  просто дополнительно хранится вот это число.
[01:05:11.020 --> 01:05:14.020]  И при этом, если бабушка сама полиморфная,
[01:05:14.020 --> 01:05:17.020]  то у нее тоже хранится вот этот vptr в начале.
[01:05:17.020 --> 01:05:19.020]  То есть, если у меня бабушка полиморфная,
[01:05:19.020 --> 01:05:26.020]  то она тоже с vptr теперь начинается.
[01:05:26.020 --> 01:05:30.020]  И у нее top offset уже большой-пребольшой.
[01:05:30.020 --> 01:05:32.020]  Ну, тут опять...
[01:05:32.020 --> 01:05:34.020]  А, нет, тут не нужен padding.
[01:05:34.020 --> 01:05:36.020]  Значит, вот в такой ситуации, когда бабушка...
[01:05:36.020 --> 01:05:38.020]  Если бабушка полиморфная,
[01:05:38.020 --> 01:05:41.020]  то получается, что у меня уже три vptr,
[01:05:41.020 --> 01:05:43.020]  у мамы vptr,
[01:05:43.020 --> 01:05:46.020]  по vptr написаны, значит, адреса вот этих всех функций,
[01:05:46.020 --> 01:05:48.020]  top offset — 0,
[01:05:48.020 --> 01:05:50.020]  сын — type info,
[01:05:50.020 --> 01:05:53.020]  и virtual offset, указывающий, где бабушка.
[01:05:53.020 --> 01:05:55.020]  У папы все то же самое,
[01:05:55.020 --> 01:05:57.020]  но еще дополнительно virtual offset, указывающий, где бабушка.
[01:05:57.020 --> 01:05:59.020]  Она уже ближе.
[01:05:59.020 --> 01:06:02.020]  А у бабушки уже нет virtual offset,
[01:06:02.020 --> 01:06:06.020]  но есть top offset — это что вот до сюда, там, 32 байта.
[01:06:06.020 --> 01:06:09.020]  Все еще сын — type info,
[01:06:09.020 --> 01:06:14.020]  и все еще там адреса, каких надо функций.
[01:06:14.020 --> 01:06:16.020]  И вот при виртуальном наследовании,
[01:06:16.020 --> 01:06:20.020]  если у вас полиморфная бабушка,
[01:06:20.020 --> 01:06:23.020]  dynamic cast все равно работает вниз.
[01:06:23.020 --> 01:06:27.020]  За счет того, что вся информация хранится в этой таблице.
[01:06:27.020 --> 01:06:30.020]  Я напоминаю, что если бы у вас был static cast,
[01:06:30.020 --> 01:06:33.020]  ну, static cast вниз при виртуальном наследовании не работает.
[01:06:33.020 --> 01:06:36.020]  А dynamic cast работает.
[01:06:36.020 --> 01:06:38.020]  Но при условии, что бабушка полиморфная.
[01:06:38.020 --> 01:06:41.020]  Source type is polymorphic.
[01:06:41.020 --> 01:06:43.020]  Если у вас полиморфная бабушка,
[01:06:43.020 --> 01:06:46.020]  то dynamic cast можно скастовать ее к тому,
[01:06:46.020 --> 01:06:49.020]  к чему хоть к маме, хоть к папе, хоть к сыну
[01:06:49.020 --> 01:06:51.020]  все нормально отработает.
[01:06:51.020 --> 01:06:54.020]  Потому что вот в этой виртуальной таблице,
[01:06:54.020 --> 01:06:56.020]  по данным из этой виртуальной таблицы,
[01:06:56.020 --> 01:06:57.020]  dynamic cast все поймет.
[01:06:57.020 --> 01:06:59.020]  Он поймет, что это виртуальная бабушка,
[01:06:59.020 --> 01:07:03.020]  что у нее top offset на самом деле такой-то,
[01:07:03.020 --> 01:07:05.020]  значит, мама вот на таком расстоянии от нее.
[01:07:05.020 --> 01:07:07.020]  А у static cast не было возможности,
[01:07:07.020 --> 01:07:09.020]  потому что не было никакого view pointer,
[01:07:09.020 --> 01:07:11.020]  на который мы могли бы пойти и посмотреть.
[01:07:15.020 --> 01:07:17.020]  Так.
[01:07:21.020 --> 01:07:23.020]  Короче, да.
[01:07:23.020 --> 01:07:26.020]  Если у нас исследование не виртуальное,
[01:07:26.020 --> 01:07:27.020]  то, чтобы сказать бабушке,
[01:07:27.020 --> 01:07:29.020]  мы сначала кастуем к маме,
[01:07:29.020 --> 01:07:33.020]  и потом берем бабушку уже из кастованного к маме.
[01:07:33.020 --> 01:07:35.020]  А тут мы просто сразу идем к маме.
[01:07:35.020 --> 01:07:36.020]  Да.
[01:07:37.020 --> 01:07:39.020]  Ну, как сразу идем?
[01:07:39.020 --> 01:07:44.020]  Тут тоже есть приколы, но я понял.
[01:07:44.020 --> 01:07:49.020]  Ты все так и пропустил, значит, наследование,
[01:07:49.020 --> 01:07:51.020]  а страдаешь теперь из-за этого.
[01:07:51.020 --> 01:07:53.020]  Значит, ну хорошо.
[01:07:53.020 --> 01:07:57.020]  А остальные вообще еще с нами?
[01:07:57.020 --> 01:07:58.020]  Да нет.
[01:07:58.020 --> 01:08:04.020]  У нас же, получается, мы храним вот такие вот view pointer,
[01:08:04.020 --> 01:08:06.020]  ну, просто эти записи в нашей таблице
[01:08:06.020 --> 01:08:34.020]  для, скажем так, каждого возможного прямого
[01:08:34.020 --> 01:08:37.020]  Мама должна начинаться с випойнтера, потому что она полиморфная.
[01:08:37.020 --> 01:08:40.020]  Папа должен начинаться с випойнтера, потому что она полиморфная.
[01:08:40.020 --> 01:08:43.020]  Сын должен начинаться с випойнтера, но это то же самое, что мама.
[01:08:43.020 --> 01:08:46.020]  И еще бабушка, поскольку полиморфная, тоже с випойнтера начинается.
[01:08:46.020 --> 01:08:48.020]  Вот и все, три випойнтера.
[01:08:54.020 --> 01:08:55.020]  Да, что?
[01:08:57.020 --> 01:08:58.020]  Что как работает?
[01:09:00.020 --> 01:09:03.020]  Top offset говорит, как далеко вы от начала объекта.
[01:09:04.020 --> 01:09:08.020]  Так, но он же разный, в зависимости от того, заполнено.
[01:09:09.020 --> 01:09:10.020]  Разный, да.
[01:09:11.020 --> 01:09:13.020]  Это три разных таблицы.
[01:09:14.020 --> 01:09:16.020]  В них разные top offsets.
[01:09:16.020 --> 01:09:18.020]  И разные virtual offsets.
[01:09:18.020 --> 01:09:19.020]  А ты что хочешь сказать?
[01:09:19.020 --> 01:09:22.020]  Вопрос, а там в конце не нужно еще четыре фиктивных?
[01:09:22.020 --> 01:09:27.020]  Ну, конечно, нужно, потому что следующий объект будет начинаться с випойнтера, поэтому четыре еще здесь.
[01:09:27.020 --> 01:09:30.020]  Просто три точки не ставите, если...
[01:09:30.020 --> 01:09:31.020]  Ну, хорошо.
[01:09:34.020 --> 01:09:42.020]  Сейчас с динамик кастом от бабушки к папе можно скастоваться, да.
[01:09:42.020 --> 01:09:46.020]  Потому что за счет top offsets и virtual offsets она все поймет.
[01:09:49.020 --> 01:09:54.020]  Так, у меня было последнее, что я вам должен рассказать.
[01:09:54.020 --> 01:09:55.020]  Вот.
[01:09:55.020 --> 01:09:59.020]  Это я вам должен был показать на ноуте.
[01:09:59.020 --> 01:10:03.020]  Ну, давайте я попробую, пока Филипп не пришел это сделать.
[01:10:04.020 --> 01:10:07.020]  Ну, я сейчас на проекторе вам кое-что покажу.
[01:10:31.020 --> 01:10:32.020]  Так.
[01:10:32.020 --> 01:10:36.020]  Значит, смотрите, какая история.
[01:10:38.020 --> 01:10:43.020]  Последний пункт, чтобы нам закончить эту несчастную тему.
[01:10:47.020 --> 01:10:49.020]  Это вот что.
[01:10:53.020 --> 01:10:59.020]  Конечно, по утрам не очень удобно заниматься таким, но попробуем.
[01:10:59.020 --> 01:11:01.020]  Надеюсь, что будет видно.
[01:11:02.020 --> 01:11:15.020]  Я назову файл таким странным названием.
[01:11:15.020 --> 01:11:17.020]  Virtual issues.
[01:11:17.020 --> 01:11:24.020]  Только нет, знаете что, я должен не в этой папке это делать, а в этой.
[01:11:24.020 --> 01:11:28.020]  Ой.
[01:11:28.020 --> 01:11:30.020]  Ой, не cp, а cd.
[01:11:30.020 --> 01:11:31.020]  Да.
[01:11:31.020 --> 01:11:33.020]  Не cp, а cd.
[01:11:38.020 --> 01:11:39.020]  Так, окей.
[01:11:39.020 --> 01:11:41.020]  Тогда это мы закроем.
[01:11:41.020 --> 01:11:46.020]  Значит, virtual issues.
[01:11:46.020 --> 01:11:48.020]  Что бы это значило?
[01:11:48.020 --> 01:11:52.020]  Ну, я не знаю, как озаглавить это.
[01:11:52.020 --> 01:11:58.020]  В общем, некоторые проблемы, некоторые неочевидные моменты, связанные с виртуальными функциями.
[01:11:58.020 --> 01:12:05.020]  Для начала рассмотрим такой сценарий.
[01:12:05.020 --> 01:12:08.020]  Вот помните, у нас были pure virtual функции.
[01:12:08.020 --> 01:12:14.020]  А как устроена виртуальная таблица в случае...
[01:12:14.020 --> 01:12:17.020]  Значит, это пункт 5.7.
[01:12:17.020 --> 01:12:20.020]  Ой, 5.8 уже.
[01:12:20.020 --> 01:12:25.020]  .
[01:12:25.020 --> 01:12:33.020]  Разные приколы с виртуальными функциями.
[01:12:33.020 --> 01:12:40.020]  Ну вот, у меня будет, значит, virtual void f равно нулю.
[01:12:40.020 --> 01:12:45.020]  Вот.
[01:12:45.020 --> 01:12:49.020]  И структура derived, наследница base, у которой, значит, все нормально.
[01:12:49.020 --> 01:12:50.020]  virtual void f.
[01:12:50.020 --> 01:12:52.020]  Извиняюсь.
[01:12:52.020 --> 01:12:53.020]  void f override.
[01:12:53.020 --> 01:13:01.020]  Значит, выводит один, скажем.
[01:13:01.020 --> 01:13:09.020]  Ну, ок, выводит.
[01:13:09.020 --> 01:13:11.020]  Вот.
[01:13:11.020 --> 01:13:18.020]  Смотрите, а как устроена таблица, если у меня, на самом деле, pure virtual функция?
[01:13:18.020 --> 01:13:22.020]  Ну, там есть...
[01:13:22.020 --> 01:13:30.020]  Там есть такая заглушка, которая говорит, что...
[01:13:30.020 --> 01:13:35.020]  Ну, вот, что находится на месте вот этого вот адреса f.
[01:13:35.020 --> 01:13:38.020]  Если я рассмотрю виртуальную таблицу для base.
[01:13:38.020 --> 01:13:40.020]  Виртуальная таблица для base существует.
[01:13:40.020 --> 01:13:48.020]  И на месте адреса f находится такая, как бы, заглушка, в которой сказано, что если ты по ней пойдешь, то убьют тебя.
[01:13:48.020 --> 01:13:50.020]  Ну, там...
[01:13:50.020 --> 01:13:56.020]  В общем, она ведет на некоторый адрес, в котором написано падение.
[01:13:56.020 --> 01:13:59.020]  Так мы же вообще не можем создать объект base.
[01:13:59.020 --> 01:14:01.020]  Мы не можем создать объект base.
[01:14:01.020 --> 01:14:06.020]  Но мы можем сделать вот что.
[01:14:06.020 --> 01:14:08.020]  Вот смотрите.
[01:14:08.020 --> 01:14:12.020]  Сейчас я вам приведу такой пример.
[01:14:12.020 --> 01:14:16.020]  Вот давайте у меня будет еще одна функция g, которая таки выводит один.
[01:14:16.020 --> 01:14:18.020]  И она в derived переопределена, которая...
[01:14:18.020 --> 01:14:25.020]  Нет, указатель сделаем, но попозже.
[01:14:25.020 --> 01:14:27.020]  Сначала вот так.
[01:14:27.020 --> 01:14:39.020]  Вот смотрите, я в main создаю derived, а в конструкторе derived у меня написано...
[01:14:39.020 --> 01:14:43.020]  Да ничего не написано, он стандартный.
[01:14:43.020 --> 01:14:46.020]  У меня в конструкторе base написано кое-что.
[01:14:46.020 --> 01:14:47.020]  Вот в конструкторе base написано кое-что.
[01:14:47.020 --> 01:14:50.020]  Вот в конструкторе base у меня написано вызвать g.
[01:14:50.020 --> 01:14:54.020]  g вызвать.
[01:14:54.020 --> 01:14:56.020]  Пока не f.
[01:14:56.020 --> 01:14:58.020]  Смотрите, я создаю derived.
[01:14:58.020 --> 01:15:00.020]  Как вы думаете, что сейчас выведется?
[01:15:00.020 --> 01:15:04.020]  Один.
[01:15:04.020 --> 01:15:06.020]  Почему один?
[01:15:06.020 --> 01:15:09.020]  Потому что мы обращаемся к base.
[01:15:09.020 --> 01:15:11.020]  Значит, я создаю derived.
[01:15:11.020 --> 01:15:14.020]  И сначала, когда создается derived, должен создаться base.
[01:15:14.020 --> 01:15:16.020]  Начинает создаваться base.
[01:15:17.020 --> 01:15:19.020]  В base вызывается функция g.
[01:15:19.020 --> 01:15:22.020]  g это метод base, но он переопределен в derived.
[01:15:22.020 --> 01:15:30.020]  Я вроде как создаю derived, но пока еще создаю base.
[01:15:30.020 --> 01:15:32.020]  Что выведется, один или два?
[01:15:32.020 --> 01:15:39.020]  В смысле, сначала я один раз g вызываю.
[01:15:39.020 --> 01:15:41.020]  Два не может вывестись.
[01:15:41.020 --> 01:15:42.020]  Смотрите, почему.
[01:15:42.020 --> 01:15:45.020]  Потому что никак нельзя...
[01:15:45.020 --> 01:15:47.020]  Ну, это было бы очень странно.
[01:15:47.020 --> 01:15:49.020]  Вот логично.
[01:15:49.020 --> 01:15:53.020]  Если я в конструкторе base, я не могу вызывать имплементацию из derived,
[01:15:53.020 --> 01:15:57.020]  потому что, вообще говоря, она же может использовать поля derived.
[01:15:57.020 --> 01:16:00.020]  А полей derived нет еще, их не существует.
[01:16:00.020 --> 01:16:08.020]  Нельзя из конструктора base, даже если у меня виртуальная...
[01:16:08.020 --> 01:16:11.020]  Даже если у меня виртуальная функция, я создаю derived.
[01:16:11.020 --> 01:16:14.020]  Пока я в конструкторе base, я должен вызывать g.
[01:16:14.020 --> 01:16:20.020]  Из derived не могу, там полей еще нет, чтобы вызывать из derived.
[01:16:20.020 --> 01:16:22.020]  Короче, выведется один.
[01:16:22.020 --> 01:16:28.020]  Тут скорее мы создаем объект именно класса base, а не как ссылку на derived.
[01:16:28.020 --> 01:16:32.020]  Нет, мы создаем объект derived, но пока для начала мы создаем base.
[01:16:32.020 --> 01:16:36.020]  Да, я имею в виду, когда мы создаем вот этот base, на основе которого мы будем строить derived,
[01:16:36.020 --> 01:16:40.020]  это уже честный base, и в нем она виртуальная внутри себя.
[01:16:40.020 --> 01:16:42.020]  Ну, можно так сказать.
[01:16:42.020 --> 01:16:46.020]  Но я бы просто сказал, что мы не можем даже теоретически вызвать из derived,
[01:16:46.020 --> 01:16:50.020]  ну, потому что полей нет derived.
[01:16:50.020 --> 01:16:52.020]  Вот.
[01:16:52.020 --> 01:16:56.020]  А как это устроено в терминах виртуальных таблиц?
[01:16:56.020 --> 01:16:58.020]  А вот как это устроено.
[01:16:58.020 --> 01:17:04.020]  На самом деле, когда у вас полиморфный объект создается, происходит следующее.
[01:17:04.020 --> 01:17:06.020]  Сначала...
[01:17:06.020 --> 01:17:09.020]  Ну, сначала создается base, как мы понимаем.
[01:17:09.020 --> 01:17:11.020]  Но что значит создается base?
[01:17:11.020 --> 01:17:13.020]  Чем инициализируется vpointer?
[01:17:13.020 --> 01:17:17.020]  Сначала vpointer инициализируется таблицей для base.
[01:17:17.020 --> 01:17:19.020]  Ну, это же виртуальный метод.
[01:17:19.020 --> 01:17:31.020]  Его вызов — это, значит, проход по vpointer и, значит, там прыжок куда-то.
[01:17:31.020 --> 01:17:33.020]  А мы в base.
[01:17:33.020 --> 01:17:35.020]  Вот.
[01:17:35.020 --> 01:17:39.020]  Как это реализуется на низком уровне?
[01:17:39.020 --> 01:17:42.020]  vpointer должен быть чем-то проинциализированным.
[01:17:42.020 --> 01:17:44.020]  Чем он проинциализирован, когда base создается?
[01:17:44.020 --> 01:17:46.020]  Он проинциализирован таблицей для base.
[01:17:46.020 --> 01:17:50.020]  Вот если у меня была бы здесь еще, допустим, функция h.
[01:17:50.020 --> 01:17:54.020]  Вот, скажем, допустим, у меня есть метод h, который не виртуальный.
[01:17:54.020 --> 01:17:57.020]  И этот метод h вызывает g.
[01:17:57.020 --> 01:18:01.020]  Вот давайте я такую конструкцию нарисую.
[01:18:01.020 --> 01:18:05.020]  Вот я из конструктора base вызываю h.
[01:18:05.020 --> 01:18:08.020]  А потом давайте я из конструктора derived вызываю h.
[01:18:08.020 --> 01:18:11.020]  У меня выведется сначала 1, потом 2.
[01:18:11.020 --> 01:18:21.020]  Это, кстати, вот даже не бесполезное знание.
[01:18:21.020 --> 01:18:24.020]  Меня на собеседовании ВК это спрашивали.
[01:18:24.020 --> 01:18:29.020]  Вот, значит, сейчас выведется сначала 1, потом 2.
[01:18:29.020 --> 01:18:35.020]  Почему?
[01:18:35.020 --> 01:18:37.020]  Потому что, когда мы в base, vpointer проинциализируется.
[01:18:37.020 --> 01:18:40.020]  В принципе, vpointer проставлен сначала на base the table.
[01:18:40.020 --> 01:18:47.020]  И сейчас вызовы g транслируются в вызовы g из base.
[01:18:47.020 --> 01:18:51.020]  Как только мы зашли в конструктор derived, как это работает?
[01:18:51.020 --> 01:18:52.020]  В каком порядке?
[01:18:52.020 --> 01:18:54.020]  То есть, на самом деле, когда мы конструируем полиморфный объект,
[01:18:54.020 --> 01:18:56.020]  еще одно дополнительное действие происходит.
[01:18:56.020 --> 01:19:01.020]  Сначала проставляется vpointer, потом начнут конструировать поля наследника.
[01:19:01.020 --> 01:19:05.020]  Значит, когда конструируется полиморфный объект, сначала конструируется его родитель.
[01:19:05.020 --> 01:19:06.020]  И начинается все с того, что vpointer.
[01:19:06.020 --> 01:19:09.020]  И начинается все с того, что vpointer проставляется на таблицу base.
[01:19:09.020 --> 01:19:11.020]  Потом конструируются поля base.
[01:19:11.020 --> 01:19:13.020]  Потом конструктор base выполняется.
[01:19:13.020 --> 01:19:16.020]  Потом vpointer проставляется на таблицу derived.
[01:19:16.020 --> 01:19:19.020]  Создаются поля derived, выполняется тело конструктора.
[01:19:19.020 --> 01:19:24.020]  В момент, когда я здесь, vpointer уже проставлен на g.
[01:19:24.020 --> 01:19:28.020]  Вот, а теперь представьте, что я вместо этого сделал вот это.
[01:19:28.020 --> 01:19:30.020]  Что будет?
[01:19:30.020 --> 01:19:32.020]  Ничего.
[01:19:32.020 --> 01:19:34.020]  Откуда 1?
[01:19:34.020 --> 01:19:37.020]  Я вызываю f. f.purevirtual здесь.
[01:19:47.020 --> 01:19:52.020]  Потому что на этапе компиляции, вообще говоря, как ты проверишь?
[01:19:52.020 --> 01:19:56.020]  Вот смотри, если я, вот смотри, тихо.
[01:19:56.020 --> 01:20:02.020]  Если я вот так сделаю, то будет ce.
[01:20:02.020 --> 01:20:10.020]  Ну, тут на самом деле кажется, ошибка линкера.
[01:20:10.020 --> 01:20:13.020]  Вот, ошибка линкера.
[01:20:13.020 --> 01:20:15.020]  Вот.
[01:20:15.020 --> 01:20:19.020]  Потому что, когда я прямо из конструктора base вызываю f,
[01:20:19.020 --> 01:20:24.020]  он понимает, что, значит, что-то пошло не так, да?
[01:20:24.020 --> 01:20:27.020]  Вот, а если я здесь заменю на вызов h?
[01:20:27.020 --> 01:20:31.020]  Давайте посмотрим.
[01:20:31.020 --> 01:20:33.020]  Это компилируется.
[01:20:33.020 --> 01:20:36.020]  Ну, то есть, если я прямо из конструктора вызываю f,
[01:20:36.020 --> 01:20:38.020]  он понимает, что что-то не так,
[01:20:38.020 --> 01:20:42.020]  и выдает мне ошибку еще на этапе линковки,
[01:20:42.020 --> 01:20:46.020]  что я из конструктора вызываю f, которая неопределена.
[01:20:46.020 --> 01:20:50.020]  Но он видит, что из конструктора вызывать f, это явно плохая идея.
[01:20:50.020 --> 01:20:52.020]  Но когда я вызываю f из другого метода,
[01:20:52.020 --> 01:20:56.020]  он уже не может так сказать.
[01:20:56.020 --> 01:21:00.020]  Потому что f, вообще-то, ну, таблица, там, на таблицу все проставлено.
[01:21:00.020 --> 01:21:04.020]  Просто у него в этой таблице для base стоит заглушка на месте f.
[01:21:04.020 --> 01:21:08.020]  Вот в адресе base.f написан адрес некоторой такой инструкции,
[01:21:08.020 --> 01:21:12.020]  которая говорит «падай» со словами «pure virtual function called».
[01:21:12.020 --> 01:21:16.020]  Вот сейчас вы увидите очень интересную RE.
[01:21:16.020 --> 01:21:18.020]  Вот такую.
[01:21:18.020 --> 01:21:21.020]  Кстати, одна из самых понятных, на самом деле.
[01:21:21.020 --> 01:21:23.020]  Вот.
[01:21:23.020 --> 01:21:27.020]  Да, это довольно необычная runtime error.
[01:21:27.020 --> 01:21:29.020]  Мы с вами такой еще не сталкивались.
[01:21:29.020 --> 01:21:31.020]  Ну, aborted core dump, понятно.
[01:21:31.020 --> 01:21:33.020]  Но что произошло?
[01:21:33.020 --> 01:21:37.020]  terminate called without an active exception.
[01:21:37.020 --> 01:21:41.020]  Ну, вызвана функция terminate, которая вызывает функцию abort.
[01:21:41.020 --> 01:21:43.020]  Но что произошло? Вот что.
[01:21:43.020 --> 01:21:45.020]  Pure virtual method called.
[01:21:45.020 --> 01:21:48.020]  То же самое произойдет, если мы в деструкторе base попробуем сделать.
[01:21:48.020 --> 01:21:52.020]  Вот если я в деструкторе попробую сделать это,
[01:21:52.020 --> 01:21:55.020]  то будет то же самое.
[01:21:55.020 --> 01:21:57.020]  То есть я могу конструктор закомментировать,
[01:21:57.020 --> 01:21:59.020]  в конструкторе ничего такого странного не делать.
[01:21:59.020 --> 01:22:01.020]  Вот.
[01:22:01.020 --> 01:22:04.020]  А сделать в деструкторе?
[01:22:04.020 --> 01:22:07.020]  Сначала вызовется O, выведется OK,
[01:22:07.020 --> 01:22:10.020]  потому что в конструкторе derived h уже нормально отработало.
[01:22:10.020 --> 01:22:13.020]  А вот из деструктора получилось pure virtual method called.
[01:22:13.020 --> 01:22:15.020]  Потому что, когда объект уничтожается,
[01:22:15.020 --> 01:22:17.020]  все происходит в обратном порядке.
[01:22:17.020 --> 01:22:19.020]  Сначала выполняется деструктор derived,
[01:22:19.020 --> 01:22:21.020]  потом уничтожаются поля derived.
[01:22:21.020 --> 01:22:26.020]  Потом viewpointer переставляется обратно на base таблицу.
[01:22:26.020 --> 01:22:28.020]  И дальше выполняется деструктор base,
[01:22:28.020 --> 01:22:29.020]  уничтожаются поля base,
[01:22:29.020 --> 01:22:31.020]  viewpointer снимается со стека.
[01:22:31.020 --> 01:22:33.020]  Но вот в момент, когда я выполняю деструктор base,
[01:22:33.020 --> 01:22:34.020]  вызываю h.
[01:22:34.020 --> 01:22:36.020]  Это приводит к тому, что я опять прыгаю в эту функцию,
[01:22:36.020 --> 01:22:38.020]  которая падение вызывает.
[01:22:38.020 --> 01:22:40.020]  Это pure virtual method called.
[01:22:40.020 --> 01:22:42.020]  Ошибка.
[01:22:42.020 --> 01:22:44.020]  Вот.
[01:22:44.020 --> 01:22:46.020]  Кстати.
[01:22:46.020 --> 01:22:48.020]  Это значит виртуальные функции в конструкторах.
[01:22:48.020 --> 01:22:50.020]  И ошибка pure virtual method called.
[01:22:52.020 --> 01:22:56.020]  Еще одна интересная ситуация.
[01:22:58.020 --> 01:23:00.020]  Кстати, вот такой вопрос.
[01:23:00.020 --> 01:23:03.020]  Можно ли вообще вот так сделать?
[01:23:03.020 --> 01:23:08.020]  Ну, давайте я сейчас вообще все уберу это все.
[01:23:08.020 --> 01:23:10.020]  Черт его матери, уберу.
[01:23:10.020 --> 01:23:12.020]  Вот скажем.
[01:23:20.020 --> 01:23:22.020]  Могу ли я вот так сделать?
[01:23:25.020 --> 01:23:26.020]  Ну, скажем.
[01:23:28.020 --> 01:23:30.020]  Ну, казалось бы, что такого я сделал?
[01:23:30.020 --> 01:23:32.020]  Просто.
[01:23:32.020 --> 01:23:34.020]  Просто объявил функцию f.
[01:23:40.020 --> 01:23:42.020]  Вот.
[01:23:42.020 --> 01:23:44.020]  Ну.
[01:23:44.020 --> 01:23:48.020]  Короче, я оставляю виртуальную функцию без определения.
[01:23:48.020 --> 01:23:50.020]  Нет и не могу.
[01:23:52.020 --> 01:23:54.020]  Это будет ошибка линкера.
[01:23:54.020 --> 01:23:56.020]  Ну.
[01:23:56.020 --> 01:24:00.020]  Ну, тут довольно интересно тоже.
[01:24:00.020 --> 01:24:03.020]  I define reference to type info for base.
[01:24:06.020 --> 01:24:08.020]  Но.
[01:24:08.020 --> 01:24:10.020]  Да.
[01:24:10.020 --> 01:24:12.020]  Но.
[01:24:12.020 --> 01:24:14.020]  Да.
[01:24:14.020 --> 01:24:16.020]  Я не написал равно нулю.
[01:24:16.020 --> 01:24:18.020]  Вот если я просто оставил без определения,
[01:24:18.020 --> 01:24:20.020]  то это вызывает ошибку линкера.
[01:24:20.020 --> 01:24:24.020]  Виртуальные методы нельзя оставлять без определения.
[01:24:24.020 --> 01:24:26.020]  Можно делать либо равно нулю,
[01:24:26.020 --> 01:24:28.020]  и тогда он генерирует заглушку.
[01:24:28.020 --> 01:24:30.020]  Либо надо определять.
[01:24:30.020 --> 01:24:32.020]  Если я оставляю виртуальный метод без определения,
[01:24:32.020 --> 01:24:34.020]  то это приводит к ошибке линкера.
[01:24:34.020 --> 01:24:36.020]  Почему?
[01:24:36.020 --> 01:24:40.020]  Да потому что ему же нужно сгенерировать таблицу виртуальных функций для base.
[01:24:40.020 --> 01:24:44.020]  А в эту таблицу надо проставить адреса этих методов.
[01:24:44.020 --> 01:24:46.020]  Ну и адрес type info.
[01:24:46.020 --> 01:24:48.020]  А если у меня f без определения,
[01:24:48.020 --> 01:24:50.020]  то он, ну, видите, короче, он говорит,
[01:24:50.020 --> 01:24:52.020]  я не могу сгенерировать,
[01:24:52.020 --> 01:24:54.020]  ну, я не могу, например,
[01:24:54.020 --> 01:24:56.020]  кстати, не знаю, почему type info для base
[01:24:56.020 --> 01:24:58.020]  у него undefined reference,
[01:24:58.020 --> 01:25:00.020]  но у него undefined reference to base f,
[01:25:00.020 --> 01:25:02.020]  по крайней мере, будет, потому что он не сможет
[01:25:02.020 --> 01:25:04.020]  таблицу создать в статической памяти,
[01:25:04.020 --> 01:25:06.020]  когда будет линковать.
[01:25:06.020 --> 01:25:08.020]  Поэтому виртуальные функции
[01:25:08.020 --> 01:25:10.020]  нельзя оставлять без определения.
[01:25:10.020 --> 01:25:12.020]  Вот. Ну и еще один интересный пример,
[01:25:12.020 --> 01:25:14.020]  вот какой.
[01:25:14.020 --> 01:25:16.020]  Представьте, что у меня есть
[01:25:16.020 --> 01:25:18.020]  такое.
[01:25:22.020 --> 01:25:28.020]  Я возьму
[01:25:28.020 --> 01:25:30.020]  и здесь напишу.
[01:25:38.020 --> 01:25:40.020]  Вот.
[01:25:40.020 --> 01:25:42.020]  Посмотрите внимательно на этот пример
[01:25:42.020 --> 01:25:44.020]  и скажите, что выведется.
[01:25:46.020 --> 01:25:48.020]  Нет, не так.
[01:25:48.020 --> 01:25:50.020]  Тут-то понятно, что выведется.
[01:25:50.020 --> 01:25:52.020]  Вот что я скажу.
[01:25:52.020 --> 01:25:54.020]  Нет. Вот пример.
[01:25:54.020 --> 01:25:56.020]  Да.
[01:26:00.020 --> 01:26:02.020]  Base абстрактный класс.
[01:26:02.020 --> 01:26:04.020]  Да.
[01:26:08.020 --> 01:26:10.020]  Потому что очень нельзя вызвать конструктор для...
[01:26:12.020 --> 01:26:14.020]  Так я не создавал объект base,
[01:26:14.020 --> 01:26:16.020]  я создавал объект derived.
[01:26:18.020 --> 01:26:20.020]  Объект derived я могу создать?
[01:26:20.020 --> 01:26:22.020]  Да.
[01:26:22.020 --> 01:26:24.020]  Посмотрите на этот код и скажите,
[01:26:24.020 --> 01:26:26.020]  что выведется, по-вашему.
[01:26:26.020 --> 01:26:28.020]  А число?
[01:26:34.020 --> 01:26:36.020]  Значит, сейчас
[01:26:36.020 --> 01:26:38.020]  я бы не задавал этот вопрос,
[01:26:38.020 --> 01:26:40.020]  если бы ответ был интуитивный.
[01:26:40.020 --> 01:26:42.020]  Да, все.
[01:26:42.020 --> 01:26:44.020]  Это последнее, что я...
[01:26:46.020 --> 01:26:48.020]  Да ты заходи сюда.
[01:26:48.020 --> 01:26:50.020]  Значит,
[01:26:50.020 --> 01:26:52.020]  выведется нечто неожиданное.
[01:26:52.020 --> 01:26:54.020]  Derived1 или base2?
[01:26:54.020 --> 01:26:56.020]  Выведется derived1.
[01:26:56.020 --> 01:26:58.020]  Как же так?
[01:26:58.020 --> 01:27:00.020]  А это как?
[01:27:00.020 --> 01:27:02.020]  А вот да, как?
[01:27:02.020 --> 01:27:04.020]  Как это возможно?
[01:27:04.020 --> 01:27:06.020]  А, возможно, потому что берутся
[01:27:06.020 --> 01:27:08.020]  типичные параметры из base.
[01:27:08.020 --> 01:27:10.020]  А почему они оттуда берутся?
[01:27:10.020 --> 01:27:12.020]  Почему они оттуда берутся?
[01:27:12.020 --> 01:27:14.020]  Чего?
[01:27:14.020 --> 01:27:16.020]  Значит, поймите, почему выводится derived1.
[01:27:16.020 --> 01:27:18.020]  Ага.
[01:27:18.020 --> 01:27:20.020]  На самом деле, тоже довольно такой
[01:27:20.020 --> 01:27:22.020]  болезненный момент,
[01:27:22.020 --> 01:27:24.020]  и это реально, ну,
[01:27:24.020 --> 01:27:26.020]  скажем так,
[01:27:26.020 --> 01:27:28.020]  бывали ситуации в реальной
[01:27:28.020 --> 01:27:30.020]  разработке, когда это знание
[01:27:30.020 --> 01:27:32.020]  помогало, так сказать, избежать проблем.
[01:27:32.020 --> 01:27:34.020]  А
[01:27:34.020 --> 01:27:36.020]  дело в том, что дефолтные
[01:27:36.020 --> 01:27:38.020]  параметры — это compile-time
[01:27:38.020 --> 01:27:40.020]  понятие
[01:27:40.020 --> 01:27:42.020]  уровня компиляции.
[01:27:42.020 --> 01:27:44.020]  Ну, потому что b.f
[01:27:44.020 --> 01:27:46.020]  компилятор
[01:27:46.020 --> 01:27:48.020]  в compile-time должен подставить, с какими параметрами
[01:27:48.020 --> 01:27:50.020]  она вызывается.
[01:27:50.020 --> 01:27:52.020]  У f должен быть параметр, а то, что он
[01:27:52.020 --> 01:27:54.020]  дефолтный, означает, что компилятор по умолчанию
[01:27:54.020 --> 01:27:56.020]  подставит один, если
[01:27:56.020 --> 01:27:58.020]  не написано, что подставить.
[01:27:58.020 --> 01:28:00.020]  Компилятор в compile — это же
[01:28:00.020 --> 01:28:02.020]  не много разных функций, которая одна
[01:28:02.020 --> 01:28:04.020]  с нулем параметров, другая с одним параметром.
[01:28:04.020 --> 01:28:06.020]  Нет, это функция для,
[01:28:06.020 --> 01:28:08.020]  с точки зрения процессора, это функция с одним параметром.
[01:28:08.020 --> 01:28:10.020]  Просто компилятор
[01:28:10.020 --> 01:28:12.020]  подставляет этот параметр сам, если мы
[01:28:12.020 --> 01:28:14.020]  его не подставили.
[01:28:14.020 --> 01:28:16.020]  И подставляет он его, конечно же,
[01:28:16.020 --> 01:28:18.020]  как и для base, потому что мы от base вызываемся.
[01:28:18.020 --> 01:28:20.020]  Но функция-то от derived,
[01:28:20.020 --> 01:28:22.020]  поэтому попадаем в версию для derived,
[01:28:22.020 --> 01:28:24.020]  но с значением 1.
[01:28:24.020 --> 01:28:26.020]  Такие дела.
[01:28:26.020 --> 01:28:28.020]  Ну, ладно.
[01:28:28.020 --> 01:28:30.020]  Все.
[01:28:30.020 --> 01:28:32.020]  Пока что.
[01:28:34.020 --> 01:28:36.020]  Вечером продолжим.
[01:28:42.020 --> 01:28:44.020]  Вот, тут у меня файлик такой появился.
[01:28:44.020 --> 01:28:46.020]  Virtual прикол.
[01:28:48.020 --> 01:28:50.020]  Да, это вот
[01:28:50.020 --> 01:28:52.020]  кто-то из вас сегодня утром
[01:28:52.020 --> 01:28:54.020]  вопрос задал вот такой, что выведется.
[01:29:00.020 --> 01:29:02.020]  Нет, ну тут главный вопрос.
[01:29:02.020 --> 01:29:04.020]  Тихо. Я, на самом деле,
[01:29:04.020 --> 01:29:06.020]  это в чат скинул. Я тут, правда,
[01:29:06.020 --> 01:29:08.020]  немножко поменял вывод, чтобы было
[01:29:08.020 --> 01:29:10.020]  понагляднее. Главный вопрос
[01:29:10.020 --> 01:29:12.020]  вот. Вот у меня есть main, в нем
[01:29:12.020 --> 01:29:14.020]  создается объект derived, а объект derived
[01:29:14.020 --> 01:29:16.020]  при создании вызывает конструктор
[01:29:16.020 --> 01:29:18.020]  base с результатом вызова n.
[01:29:18.020 --> 01:29:20.020]  А f виртуальная.
[01:29:20.020 --> 01:29:22.020]  И она переопределена
[01:29:22.020 --> 01:29:24.020]  в derived.
[01:29:24.020 --> 01:29:26.020]  Вот, что будет?
[01:29:26.020 --> 01:29:28.020]  Ну, то есть она pure virtual, на самом деле.
[01:29:28.020 --> 01:29:30.020]  То есть, когда derived
[01:29:30.020 --> 01:29:32.020]  создается, первым делом должен
[01:29:32.020 --> 01:29:34.020]  создаться base от какого-то int.
[01:29:34.020 --> 01:29:36.020]  И вот он создает base от того int, которое вернуло f.
[01:29:36.020 --> 01:29:38.020]  А f это переопределенная виртуальная
[01:29:38.020 --> 01:29:40.020]  функция, а в base она чисто
[01:29:40.020 --> 01:29:42.020]  виртуальная.
[01:29:42.020 --> 01:29:44.020]  Там еще a от f создалось.
[01:29:44.020 --> 01:29:46.020]  Да, и вывелось a.
[01:29:46.020 --> 01:29:48.020]  Ну, еще тело base отработало, вывелось g здесь.
[01:29:48.020 --> 01:29:50.020]  Не надо делать вставку.
[01:29:50.020 --> 01:29:52.020]  Вы же написали в чат.
[01:29:52.020 --> 01:29:54.020]  Да, но там было написано, что выведется.
[01:29:54.020 --> 01:29:56.020]  Сначала вызовется
[01:29:56.020 --> 01:29:58.020]  f из derived, а потом из base.
[01:29:58.020 --> 01:30:00.020]  Да, я
[01:30:00.020 --> 01:30:02.020]  написал уже в чат, значит, как это работает.
[01:30:02.020 --> 01:30:04.020]  А сначала,
[01:30:04.020 --> 01:30:06.020]  ну, тут никакой ошибки не будет, выведется
[01:30:06.020 --> 01:30:08.020]  f просто.
[01:30:08.020 --> 01:30:10.020]  Вот это f вызовется
[01:30:10.020 --> 01:30:12.020]  из derived, потому что
[01:30:12.020 --> 01:30:14.020]  в общем.
[01:30:14.020 --> 01:30:16.020]  Значит, если вы вызываете
[01:30:16.020 --> 01:30:18.020]  в списках инициализации функцию
[01:30:18.020 --> 01:30:20.020]  виртуальную, то она диспетчеризируется
[01:30:20.020 --> 01:30:22.020]  как, короче, статическая.
[01:30:22.020 --> 01:30:24.020]  Не
[01:30:24.020 --> 01:30:26.020]  применяется виртуальность.
[01:30:26.020 --> 01:30:28.020]  Виртуальность игнорируется.
[01:30:28.020 --> 01:30:30.020]  Нет, в смысле, если мы в derived хоть где f вызываем,
[01:30:30.020 --> 01:30:32.020]  она все равно вызовется из derived.
[01:30:32.020 --> 01:30:34.020]  Она же не может из base вызваться.
[01:30:34.020 --> 01:30:36.020]  Да, но
[01:30:36.020 --> 01:30:38.020]  я создаю derived.
[01:30:38.020 --> 01:30:40.020]  Пока я создаю derived, я создаю base.
[01:30:40.020 --> 01:30:42.020]  Я еще не вошел в тело derived.
[01:30:42.020 --> 01:30:44.020]  Мы же с вами обсуждали, что если штука
[01:30:44.020 --> 01:30:46.020]  в теле конструктора...
[01:30:46.020 --> 01:30:48.020]  Да, а тоже от двойки
[01:30:48.020 --> 01:30:50.020]  создастся.
[01:30:54.020 --> 01:30:56.020]  Ну, короче, да, если в списках инициализации вызываете,
[01:30:56.020 --> 01:30:58.020]  то
[01:30:58.020 --> 01:31:00.020]  виртуальность игнорируется.
[01:31:00.020 --> 01:31:02.020]  Вызывается версия, какая есть
[01:31:02.020 --> 01:31:04.020]  в этом классе.
[01:31:04.020 --> 01:31:06.020]  Такие вот дела.
[01:31:08.020 --> 01:31:10.020]  Кстати, еще пара моментиков.
[01:31:10.020 --> 01:31:12.020]  Вопрос на
[01:31:12.020 --> 01:31:14.020]  понимание. Может ли виртуальная функция
[01:31:14.020 --> 01:31:16.020]  быть static?
[01:31:16.020 --> 01:31:18.020]  Нормально.
[01:31:18.020 --> 01:31:20.020]  Статик равен
[01:31:20.020 --> 01:31:22.020]  до всех классов?
[01:31:22.020 --> 01:31:24.020]  Нет.
[01:31:24.020 --> 01:31:26.020]  В смысле, у нас вообще нет
[01:31:26.020 --> 01:31:28.020]  объектов данного класса?
[01:31:28.020 --> 01:31:30.020]  Так. Кто считает,
[01:31:30.020 --> 01:31:32.020]  что не может?
[01:31:32.020 --> 01:31:34.020]  Виртуальная...
[01:31:34.020 --> 01:31:36.020]  Значит, может ли быть static virtual?
[01:31:36.020 --> 01:31:38.020]  Кто считает,
[01:31:38.020 --> 01:31:40.020]  что может? Кто считает, что нет?
[01:31:40.020 --> 01:31:42.020]  Кто считает, что может?
[01:31:42.020 --> 01:31:44.020]  Ну, кажется, это бесплатная операция.
[01:31:44.020 --> 01:31:46.020]  А остальные считают, что нет.
[01:31:46.020 --> 01:31:48.020]  Нет.
[01:31:48.020 --> 01:31:50.020]  Кто воздержался?
[01:31:50.020 --> 01:31:52.020]  Ты уже опытный.
[01:31:52.020 --> 01:31:54.020]  Ты уже наученный.
[01:31:54.020 --> 01:31:56.020]  Ты уже знаешь, что бывает.
[01:31:56.020 --> 01:31:58.020]  Я пытаюсь понять просто и...
[01:31:58.020 --> 01:32:00.020]  Это жесть какая-то.
[01:32:00.020 --> 01:32:02.020]  Ну, нет, конечно, static virtual это CE сразу же.
[01:32:02.020 --> 01:32:04.020]  Нельзя комбинировать static и virtual.
[01:32:04.020 --> 01:32:06.020]  Это бессмыслица полная.
[01:32:06.020 --> 01:32:08.020]  Вот.
[01:32:08.020 --> 01:32:10.020]  Более интересный вопрос. Может ли
[01:32:10.020 --> 01:32:12.020]  virtual функция быть inline?
[01:32:14.020 --> 01:32:16.020]  Нет.
[01:32:16.020 --> 01:32:18.020]  Он развернет переход по указателям.
[01:32:18.020 --> 01:32:20.020]  Да, может.
[01:32:20.020 --> 01:32:22.020]  Да, может.
[01:32:22.020 --> 01:32:24.020]  Давайте голосуем.
[01:32:24.020 --> 01:32:26.020]  Давайте голосуем.
[01:32:26.020 --> 01:32:28.020]  Это же не инструкция, это рекомендация
[01:32:28.020 --> 01:32:30.020]  inline, если можешь.
[01:32:30.020 --> 01:32:32.020]  Скорее всего, он просто ее заигнорит и все.
[01:32:32.020 --> 01:32:34.020]  Ну, просто...
[01:32:34.020 --> 01:32:36.020]  Нет, есть всякие флаги типа force inline,
[01:32:36.020 --> 01:32:38.020]  которые тоже не работают.
[01:32:40.020 --> 01:32:42.020]  Нет, ну, реально.
[01:32:42.020 --> 01:32:44.020]  Нет, он либо комбинирует,
[01:32:44.020 --> 01:32:46.020]  либо заигнорирует.
[01:32:46.020 --> 01:32:48.020]  Вот.
[01:32:48.020 --> 01:32:50.020]  Вы понимаете, в чем проблема с...
[01:32:50.020 --> 01:32:52.020]  Ну, static virtual это, понятно, CE.
[01:32:52.020 --> 01:32:54.020]  Просто cannot be
[01:32:54.020 --> 01:32:56.020]  declared virtual on static.
[01:32:56.020 --> 01:32:58.020]  Вот. А если я напишу inline virtual?
[01:32:58.020 --> 01:33:00.020]  Он либо проигнорирует,
[01:33:00.020 --> 01:33:02.020]  либо в CE.
[01:33:02.020 --> 01:33:04.020]  Вот. Никакой ошибки нет.
[01:33:04.020 --> 01:33:06.020]  Но, по факту,
[01:33:06.020 --> 01:33:08.020]  ничего не заинлайнится, скорее всего.
[01:33:08.020 --> 01:33:10.020]  Ну, потому что, опять,
[01:33:10.020 --> 01:33:12.020]  как заинлайнится?
[01:33:12.020 --> 01:33:14.020]  Вот. Да.
[01:33:14.020 --> 01:33:16.020]  Понимаете, в чем проблема
[01:33:16.020 --> 01:33:18.020]  с инлайнингом виртуальных функций?
[01:33:18.020 --> 01:33:20.020]  Ну, так.
[01:33:20.020 --> 01:33:22.020]  Если вы понимаете, что такое
[01:33:22.020 --> 01:33:24.020]  виртуальная функция в голове и что такое inline,
[01:33:24.020 --> 01:33:26.020]  вы, наверное, должны понять, что inline и virtual
[01:33:26.020 --> 01:33:28.020]  это какие-то несовместимые вещи.
[01:33:28.020 --> 01:33:30.020]  Проблем даже больше, чем в том, чтобы
[01:33:30.020 --> 01:33:32.020]  инлайнить реквайсивные функции.
[01:33:34.020 --> 01:33:36.020]  Да. Inline это значит, что
[01:33:36.020 --> 01:33:38.020]  нужно прям код функции подставить
[01:33:38.020 --> 01:33:40.020]  вместо ее вызова,
[01:33:40.020 --> 01:33:42.020]  но это такая функция, для которой ты в
[01:33:42.020 --> 01:33:44.020]  compile-time еще не знаешь, какой именно код
[01:33:44.020 --> 01:33:46.020]  у нее будет в этом месте.
[01:33:46.020 --> 01:33:48.020]  Вот. Тем не менее,
[01:33:48.020 --> 01:33:50.020]  спойлер,
[01:33:50.020 --> 01:33:52.020]  иногда это возможно.
[01:33:52.020 --> 01:33:54.020]  И это когда?
[01:33:54.020 --> 01:33:56.020]  Когда нет вариантов?
[01:33:56.020 --> 01:33:58.020]  Да. Иногда
[01:33:58.020 --> 01:34:00.020]  компилятор умеет
[01:34:00.020 --> 01:34:02.020]  по коду видеть, что
[01:34:02.020 --> 01:34:04.020]  здесь точно эта версия будет.
[01:34:04.020 --> 01:34:06.020]  И, несмотря на то, что она virtual,
[01:34:06.020 --> 01:34:08.020]  он ее
[01:34:08.020 --> 01:34:10.020]  вызывает,
[01:34:10.020 --> 01:34:12.020]  напрямую,
[01:34:12.020 --> 01:34:14.020]  direct call происходит,
[01:34:14.020 --> 01:34:16.020]  то есть он через эту таблицу не прыгает.
[01:34:16.020 --> 01:34:18.020]  И такое бывает,
[01:34:18.020 --> 01:34:20.020]  например,
[01:34:20.020 --> 01:34:22.020]  если у вас написано
[01:34:22.020 --> 01:34:24.020]  в каком-то месте
[01:34:24.020 --> 01:34:26.020]  слово final.
[01:34:26.020 --> 01:34:28.020]  Вот если у вас написано
[01:34:28.020 --> 01:34:30.020]  final,
[01:34:30.020 --> 01:34:32.020]  то для всех наследников этого класса
[01:34:32.020 --> 01:34:34.020]  можно
[01:34:36.020 --> 01:34:38.020]  сразу знать, что
[01:34:38.020 --> 01:34:40.020]  если у вас, допустим, тип base
[01:34:40.020 --> 01:34:42.020]  а вы сделали из него derived,
[01:34:42.020 --> 01:34:44.020]  но в base эта штука была final,
[01:34:44.020 --> 01:34:46.020]  то компилятор, используя этот факт,
[01:34:46.020 --> 01:34:48.020]  может не
[01:34:48.020 --> 01:34:50.020]  делать динамический
[01:34:50.020 --> 01:34:52.020]  dispatch, он может сразу
[01:34:52.020 --> 01:34:54.020]  вызов делать прямым.
[01:34:54.020 --> 01:34:56.020]  Это такая оптимизация, которая
[01:34:56.020 --> 01:34:58.020]  называется девиртуализация.
[01:35:00.020 --> 01:35:02.020]  Значит, при некоторых условиях,
[01:35:02.020 --> 01:35:04.020]  это один из примеров, когда компилятором
[01:35:04.020 --> 01:35:06.020]  это может делать,
[01:35:06.020 --> 01:35:08.020]  при некоторых условиях компилятор может
[01:35:08.020 --> 01:35:10.020]  девиртуализировать вызовы виртуальных функций
[01:35:10.020 --> 01:35:12.020]  и сделать их прямыми,
[01:35:12.020 --> 01:35:14.020]  а не через два прыжка.
[01:35:14.020 --> 01:35:16.020]  И тогда их еще и заинлайнить
[01:35:16.020 --> 01:35:18.020]  иногда бывает можно.
[01:35:18.020 --> 01:35:20.020]  Во втором семестре
[01:35:20.020 --> 01:35:22.020]  мы с вами вернемся
[01:35:22.020 --> 01:35:24.020]  к этому вопросу и, вероятно,
[01:35:24.020 --> 01:35:26.020]  рассмотрим поподробнее.
[01:35:26.020 --> 01:35:28.020]  Что?
[01:35:28.020 --> 01:35:30.020]  Не знаю.
[01:35:30.020 --> 01:35:32.020]  Вот вообще тварь вставляет
[01:35:32.020 --> 01:35:34.020]  прям даже не думая.
[01:35:34.020 --> 01:35:36.020]  Ну не знаю.
[01:35:36.020 --> 01:35:38.020]  А ну вставил.
[01:35:38.020 --> 01:35:40.020]  Вот.
[01:35:40.020 --> 01:35:42.020]  На самом деле, к сожалению,
[01:35:42.020 --> 01:35:44.020]  это все еще не все, что я собирался вам
[01:35:44.020 --> 01:35:46.020]  рассказать про виртуальные функции.
[01:35:46.020 --> 01:35:48.020]  Я хочу еще последнюю вещь рассказать.
[01:35:48.020 --> 01:35:50.020]  Это все еще относится к пункту
[01:35:50.020 --> 01:35:52.020]  5.8.
[01:35:56.020 --> 01:35:58.020]  Сейчас вы по названию поймете,
[01:35:58.020 --> 01:36:00.020]  что нас ждет.
[01:36:02.020 --> 01:36:04.020]  Ой, не G++, а Vim.
[01:36:06.020 --> 01:36:08.020]  Смотрите, как я
[01:36:08.020 --> 01:36:10.020]  уже однажды заикался об этом.
[01:36:10.020 --> 01:36:12.020]  Вот, допустим, у меня есть
[01:36:12.020 --> 01:36:14.020]  void-f,
[01:36:14.020 --> 01:36:16.020]  который void-1,
[01:36:16.020 --> 01:36:18.020]  и, значит, struct-derived,
[01:36:18.020 --> 01:36:20.020]  которая наследница base,
[01:36:20.020 --> 01:36:22.020]  которая выводит...
[01:36:22.020 --> 01:36:24.020]  Это шестой параграф?
[01:36:24.020 --> 01:36:26.020]  Нет, это...
[01:36:26.020 --> 01:36:28.020]  Нет, какой шестой?
[01:36:28.020 --> 01:36:30.020]  Ты что, это все еще...
[01:36:30.020 --> 01:36:32.020]  Предыдущий пункт.
[01:36:32.020 --> 01:36:34.020]  Нет, это шестой параграф.
[01:36:34.020 --> 01:36:36.020]  Нет, это...
[01:36:36.020 --> 01:36:38.020]  Предыдущий пункт.
[01:36:38.020 --> 01:36:40.020]  Это все еще
[01:36:40.020 --> 01:36:42.020]  приколы с виртуальными функциями.
[01:36:42.020 --> 01:36:44.020]  Вот, которая void-2.
[01:36:46.020 --> 01:36:48.020]  Ну и давайте тут будет x, тут будет y.
[01:36:48.020 --> 01:36:50.020]  Сейчас еще один прикольчик покажу,
[01:36:50.020 --> 01:36:52.020]  но это последний.
[01:36:52.020 --> 01:36:54.020]  Я вам обещал...
[01:36:54.020 --> 01:36:56.020]  Ну, как обещал? Я вам говорил, что...
[01:36:56.020 --> 01:36:58.020]  Вот, допустим,
[01:36:58.020 --> 01:37:00.020]  я заведу
[01:37:00.020 --> 01:37:02.020]  указатель на метод.
[01:37:04.020 --> 01:37:06.020]  Ну, даже...
[01:37:06.020 --> 01:37:08.020]  Даже, наверное, не так.
[01:37:08.020 --> 01:37:10.020]  Давайте я здесь...
[01:37:10.020 --> 01:37:12.020]  Вот, заведу-ка я указатель на метод.
[01:37:12.020 --> 01:37:14.020]  Как, кстати, завести указатель на метод?
[01:37:14.020 --> 01:37:16.020]  void, скобочка открывается,
[01:37:16.020 --> 01:37:18.020]  derived,
[01:37:18.020 --> 01:37:20.020]  двоеточие, двоеточие, звездочка,
[01:37:20.020 --> 01:37:22.020]  p,
[01:37:22.020 --> 01:37:24.020]  вот,
[01:37:24.020 --> 01:37:26.020]  без параметров,
[01:37:26.020 --> 01:37:28.020]  равно
[01:37:28.020 --> 01:37:30.020]  адрес
[01:37:30.020 --> 01:37:32.020]  derived,
[01:37:32.020 --> 01:37:34.020]  двоеточие, двоеточие, g.
[01:37:34.020 --> 01:37:36.020]  Это я завел указатель на метод.
[01:37:36.020 --> 01:37:38.020]  Вот.
[01:37:38.020 --> 01:37:40.020]  И что я хочу сделать?
[01:37:40.020 --> 01:37:42.020]  А я хочу спросить, какой размер у него.
[01:37:44.020 --> 01:37:46.020]  Помните, я вам говорил, что указатели на методы,
[01:37:46.020 --> 01:37:48.020]  они хитрые, у них размер
[01:37:48.020 --> 01:37:50.020]  не такой, как у обычных указателей.
[01:37:54.020 --> 01:37:56.020]  Шестнадцать.
[01:38:00.020 --> 01:38:02.020]  Как это ничего не увиделось? Вот шестнадцать.
[01:38:04.020 --> 01:38:06.020]  Почему?
[01:38:06.020 --> 01:38:08.020]  Указатель на метод имеет размер шестнадцать,
[01:38:08.020 --> 01:38:10.020]  а не восемь, как обычный указатель.
[01:38:18.020 --> 01:38:20.020]  Ну, хранить откуда?
[01:38:24.020 --> 01:38:26.020]  Может, адрес возврата?
[01:38:26.020 --> 01:38:28.020]  Может, это, типа, указатель на
[01:38:28.020 --> 01:38:30.020]  vtable плюс сдвиг по vtable?
[01:38:32.020 --> 01:38:34.020]  Никакой vtable нет, это просто, пока тут
[01:38:34.020 --> 01:38:36.020]  не виртуальные методы.
[01:38:40.020 --> 01:38:42.020]  Давайте-ка я вот что сделаю.
[01:38:42.020 --> 01:38:44.020]  Давайте-ка я посмотрю,
[01:38:44.020 --> 01:38:46.020]  что там написано.
[01:38:50.020 --> 01:38:52.020]  Вы понимаете, да, мы любим эти занятия.
[01:38:58.020 --> 01:39:00.020]  Гениально.
[01:39:04.020 --> 01:39:06.020]  Так, давайте попробуем
[01:39:06.020 --> 01:39:08.020]  вывести теперь, собственно, что там
[01:39:08.020 --> 01:39:10.020]  за числа в этом.
[01:39:12.020 --> 01:39:14.020]  Ну что, размер совпадает, шестнадцать.
[01:39:16.020 --> 01:39:18.020]  Давайте выведем.
[01:39:18.020 --> 01:39:20.020]  С точка А.
[01:39:20.020 --> 01:39:22.020]  Что вы так вздыхаете?
[01:39:22.020 --> 01:39:24.020]  Вы уже, пора привыкнуть.
[01:39:24.020 --> 01:39:26.020]  Так, давайте-ка посмотрим.
[01:39:26.020 --> 01:39:28.020]  Чтобы понять, как устроены
[01:39:28.020 --> 01:39:30.020]  указатели на методы.
[01:39:30.020 --> 01:39:32.020]  Шестнадцать.
[01:39:32.020 --> 01:39:34.020]  Какая-то длинная штука
[01:39:34.020 --> 01:39:36.020]  и ноль.
[01:39:38.020 --> 01:39:40.020]  Угу.
[01:39:40.020 --> 01:39:42.020]  Интересно.
[01:39:42.020 --> 01:39:44.020]  Сейчас ничего не произошло, ты не вывел.
[01:39:44.020 --> 01:39:46.020]  Как не вывел?
[01:39:46.020 --> 01:39:48.020]  Ну да.
[01:39:48.020 --> 01:39:50.020]  Шестнадцать, собственно.
[01:39:50.020 --> 01:39:52.020]  И вот какие там два числа.
[01:39:52.020 --> 01:39:54.020]  Ну, вот это и ноль.
[01:39:54.020 --> 01:39:56.020]  Почему второй ноль?
[01:39:58.020 --> 01:40:00.020]  А ты хорош.
[01:40:00.020 --> 01:40:02.020]  Человек научился
[01:40:02.020 --> 01:40:04.020]  правильно отвечать на вопросы.
[01:40:06.020 --> 01:40:08.020]  Чего?
[01:40:08.020 --> 01:40:10.020]  А первое число было MaxLongLong или показалось?
[01:40:10.020 --> 01:40:12.020]  Нет, нет. Там какое-то.
[01:40:12.020 --> 01:40:14.020]  Причем оно не разное еще.
[01:40:14.020 --> 01:40:16.020]  А...
[01:40:16.020 --> 01:40:18.020]  А что если взять
[01:40:18.020 --> 01:40:20.020]  все-таки и интерпретировать это как
[01:40:20.020 --> 01:40:22.020]  указатель и посмотреть на, ну там,
[01:40:22.020 --> 01:40:24.020]  на HEX-запись, может, так что-то.
[01:40:24.020 --> 01:40:26.020]  Давайте-ка я вот что сделаю теперь еще.
[01:40:26.020 --> 01:40:28.020]  Я сейчас сделаю...
[01:40:28.020 --> 01:40:30.020]  А мы не можем просто
[01:40:30.020 --> 01:40:32.020]  вывести этот указатель.
[01:40:34.020 --> 01:40:36.020]  Нет.
[01:40:36.020 --> 01:40:38.020]  Ну, он сконвертится в true или false,
[01:40:38.020 --> 01:40:40.020]  по-моему.
[01:40:40.020 --> 01:40:42.020]  Но мы же можем выводить указатель, допустим,
[01:40:42.020 --> 01:40:44.020]  на int.
[01:40:44.020 --> 01:40:46.020]  Но указатель на метод, скорее всего,
[01:40:46.020 --> 01:40:48.020]  вы не сможете вывести именно по той причине,
[01:40:48.020 --> 01:40:50.020]  что он
[01:40:50.020 --> 01:40:52.020]  состоит не только из указателя.
[01:40:52.020 --> 01:40:54.020]  Он состоит из двух частей, на самом деле.
[01:40:54.020 --> 01:40:56.020]  Указатель и еще кое-что.
[01:40:56.020 --> 01:40:58.020]  Сейчас я попробую вам
[01:41:00.020 --> 01:41:02.020]  такой мотивирующий пример
[01:41:02.020 --> 01:41:04.020]  написать. Вот у меня есть, значит,
[01:41:04.020 --> 01:41:06.020]  давайте я здесь буду выводить x,
[01:41:06.020 --> 01:41:08.020]  тут я буду выводить y, тут я буду выводить z,
[01:41:08.020 --> 01:41:10.020]  вот это будет называться z.
[01:41:10.020 --> 01:41:12.020]  И это будет
[01:41:12.020 --> 01:41:14.020]  называться функция h.
[01:41:14.020 --> 01:41:16.020]  И это будет структура
[01:41:16.020 --> 01:41:18.020]  сын, которая наследница мамы и папы.
[01:41:20.020 --> 01:41:22.020]  Вот.
[01:41:22.020 --> 01:41:24.020]  Значит,
[01:41:24.020 --> 01:41:26.020]  вот у сына
[01:41:26.020 --> 01:41:28.020]  есть как
[01:41:28.020 --> 01:41:30.020]  метод
[01:41:30.020 --> 01:41:32.020]  f, так и метод z,
[01:41:32.020 --> 01:41:34.020]  так и метод h.
[01:41:34.020 --> 01:41:36.020]  Давайте я теперь возьму у сына
[01:41:38.020 --> 01:41:40.020]  сделаю
[01:41:40.020 --> 01:41:42.020]  вот возьму адрес z у сына, короче.
[01:41:44.020 --> 01:41:46.020]  Сейчас проверим, надеюсь, что я все сделал правильно.
[01:41:46.020 --> 01:41:48.020]  О!
[01:41:50.020 --> 01:41:52.020]  Вот. Вот я сейчас беру
[01:41:52.020 --> 01:41:54.020]  метод
[01:41:54.020 --> 01:41:56.020]  f у сына,
[01:41:56.020 --> 01:41:58.020]  компилирую,
[01:41:58.020 --> 01:42:00.020]  число ноль.
[01:42:00.020 --> 01:42:02.020]  Беру метод h у сына,
[01:42:02.020 --> 01:42:04.020]  какое-то число, и опять ноль сейчас будет.
[01:42:04.020 --> 01:42:06.020]  А вот если я
[01:42:06.020 --> 01:42:08.020]  метод z у сына возьму,
[01:42:08.020 --> 01:42:10.020]  то там будет какое-то число и четыре.
[01:42:10.020 --> 01:42:12.020]  z это от папы.
[01:42:16.020 --> 01:42:18.020]  Да, на самом деле указательный метод
[01:42:18.020 --> 01:42:20.020]  состоит из двух.
[01:42:20.020 --> 01:42:22.020]  То есть он устроен хитро.
[01:42:22.020 --> 01:42:24.020]  В нем сначала идет нормальный указатель,
[01:42:24.020 --> 01:42:26.020]  а потом еще size.t, offset.
[01:42:26.020 --> 01:42:28.020]  Зачем нужно
[01:42:28.020 --> 01:42:30.020]  это? Да потому что,
[01:42:30.020 --> 01:42:32.020]  когда вы по указателю на метод вызываете
[01:42:32.020 --> 01:42:34.020]  метод от объекта,
[01:42:34.020 --> 01:42:36.020]  объект должен понимать
[01:42:36.020 --> 01:42:38.020]  начало его относительно
[01:42:40.020 --> 01:42:42.020]  того метода, который вы вызываете.
[01:42:42.020 --> 01:42:44.020]  Метод z ожидает, что
[01:42:46.020 --> 01:42:48.020]  его
[01:42:48.020 --> 01:42:50.020]  поля начинаются
[01:42:50.020 --> 01:42:52.020]  с y.
[01:42:52.020 --> 01:42:54.020]  z это же папин метод.
[01:42:54.020 --> 01:42:56.020]  Каждый метод неявно принимает
[01:42:56.020 --> 01:42:58.020]  this первым параметром.
[01:42:58.020 --> 01:43:00.020]  Вот если вы у сына вызываете z,
[01:43:00.020 --> 01:43:02.020]  то он неявно первым параметром
[01:43:02.020 --> 01:43:04.020]  принимает указатель на папу.
[01:43:04.020 --> 01:43:06.020]  Потому что он работает с папой.
[01:43:06.020 --> 01:43:08.020]  Он берет y,
[01:43:08.020 --> 01:43:10.020]  ему надо, чтобы поле лежало
[01:43:10.020 --> 01:43:12.020]  там, где он ожидает, что оно лежит.
[01:43:12.020 --> 01:43:14.020]  viz начинается с y.
[01:43:14.020 --> 01:43:16.020]  Но если вы у сына вызываете z,
[01:43:16.020 --> 01:43:18.020]  папа сдвинут относительно начала сына.
[01:43:18.020 --> 01:43:20.020]  Поэтому
[01:43:20.020 --> 01:43:22.020]  методу z нужно дополнительно
[01:43:22.020 --> 01:43:24.020]  как-то сообщить,
[01:43:24.020 --> 01:43:26.020]  что начало объекта находится
[01:43:26.020 --> 01:43:28.020]  не там, откуда мы вызвались.
[01:43:28.020 --> 01:43:30.020]  Вот тот viz, который тебе передали,
[01:43:30.020 --> 01:43:32.020]  на самом деле на 4 нужно сдвинуть,
[01:43:32.020 --> 01:43:34.020]  чтобы увидеть начало объекта,
[01:43:34.020 --> 01:43:36.020]  от которого ты хочешь работать.
[01:43:36.020 --> 01:43:38.020]  Поэтому в указателях на метод хранится
[01:43:38.020 --> 01:43:40.020]  дополнительно еще сдвиг.
[01:43:40.020 --> 01:43:42.020]  И вот при множественном наследовании
[01:43:42.020 --> 01:43:44.020]  это становится нужно,
[01:43:44.020 --> 01:43:46.020]  когда у вас начало объекта,
[01:43:46.020 --> 01:43:48.020]  относительно которого метод,
[01:43:48.020 --> 01:43:50.020]  сдвинуто относительно
[01:43:50.020 --> 01:43:52.020]  начала вашего объекта,
[01:43:52.020 --> 01:43:54.020]  от которого вы берете pointer.
[01:43:54.020 --> 01:43:56.020]  Если я беру фазер,
[01:43:56.020 --> 01:43:58.020]  то, конечно, там было бы 0.
[01:43:58.020 --> 01:44:00.020]  Но если я беру указатель на метод сына,
[01:44:00.020 --> 01:44:02.020]  то этот указатель имеет сдвиг 4.
[01:44:04.020 --> 01:44:06.020]  Вот.
[01:44:06.020 --> 01:44:08.020]  А могу ли я, скажем,
[01:44:08.020 --> 01:44:10.020]  сказать...
[01:44:10.020 --> 01:44:12.020]  Вопрос
[01:44:12.020 --> 01:44:14.020]  разрешите.
[01:44:14.020 --> 01:44:16.020]  Вы говорите, что
[01:44:16.020 --> 01:44:18.020]  когда метод вызывается,
[01:44:18.020 --> 01:44:20.020]  там неявным аргументом передается
[01:44:20.020 --> 01:44:22.020]  фазер. А почему
[01:44:22.020 --> 01:44:24.020]  у нас, когда сын фазера
[01:44:24.020 --> 01:44:26.020]  вызывается, почему он в этот момент
[01:44:26.020 --> 01:44:28.020]  не может сдвигать указатель?
[01:44:30.020 --> 01:44:32.020]  Сейчас. У меня есть
[01:44:32.020 --> 01:44:34.020]  указатель.
[01:44:36.020 --> 01:44:38.020]  Я беру объект сына
[01:44:38.020 --> 01:44:40.020]  и говорю
[01:44:40.020 --> 01:44:42.020]  сын точка звездочка
[01:44:42.020 --> 01:44:44.020]  p от...
[01:44:44.020 --> 01:44:46.020]  Ну, неважно, от чего-то.
[01:44:46.020 --> 01:44:48.020]  Как в этот момент
[01:44:48.020 --> 01:44:50.020]  понять, что на самом деле
[01:44:50.020 --> 01:44:52.020]  вот этот p
[01:44:52.020 --> 01:44:54.020]  это не настоящий сыновний p,
[01:44:54.020 --> 01:44:56.020]  а папин, и начало нужно
[01:44:56.020 --> 01:44:58.020]  сдвинуть на 4. Это же
[01:44:58.020 --> 01:45:00.020]  указатель на метод.
[01:45:00.020 --> 01:45:02.020]  А вот в момент
[01:45:02.020 --> 01:45:04.020]  вызова ведь уже теряется информация
[01:45:04.020 --> 01:45:06.020]  о том, чей это метод на самом деле.
[01:45:12.020 --> 01:45:14.020]  Так, сейчас это не
[01:45:14.020 --> 01:45:16.020]  скомпилируется, наверное.
[01:45:16.020 --> 01:45:18.020]  Да, значит, я не могу конвертировать
[01:45:18.020 --> 01:45:20.020]  вот это в это. Но вот я могу
[01:45:20.020 --> 01:45:22.020]  сказать...
[01:45:22.020 --> 01:45:24.020]  Нет, ну да, но мы могли
[01:45:24.020 --> 01:45:26.020]  запихнуть в указатель что-то
[01:45:26.020 --> 01:45:28.020]  злище, там, в ходу.
[01:45:28.020 --> 01:45:30.020]  У нас непонятно теперь, какое это.
[01:45:30.020 --> 01:45:32.020]  Вот я беру и говорю
[01:45:32.020 --> 01:45:34.020]  p это сначала
[01:45:34.020 --> 01:45:36.020]  адрес g, а потом p это адрес h.
[01:45:36.020 --> 01:45:38.020]  А вызов метода по указателю
[01:45:38.020 --> 01:45:40.020]  вот так работает.
[01:45:40.020 --> 01:45:42.020]  В момент вызова метода по указателю
[01:45:42.020 --> 01:45:44.020]  уже нет никакой информации о том,
[01:45:44.020 --> 01:45:46.020]  откуда был взят этот метод.
[01:45:46.020 --> 01:45:48.020]  Поэтому нужно где-то
[01:45:48.020 --> 01:45:50.020]  дополнительно хранить информацию о том, что
[01:45:50.020 --> 01:45:52.020]  метод этот на самом деле ожидает
[01:45:52.020 --> 01:45:54.020]  вис.
[01:45:54.020 --> 01:45:56.020]  Вот там она и хранится,
[01:45:56.020 --> 01:45:58.020]  в самом указателе.
[01:45:58.020 --> 01:46:00.020]  По сути, это такая структура, указательный метод
[01:46:00.020 --> 01:46:02.020]  из двух полей, собственно, указатель и число.
[01:46:06.020 --> 01:46:08.020]  Что я сделал?
[01:46:08.020 --> 01:46:10.020]  А, ну я вывел z, потому что
[01:46:10.020 --> 01:46:12.020]  вывел число.
[01:46:14.020 --> 01:46:16.020]  Так, хорошо.
[01:46:18.020 --> 01:46:20.020]  Теперь сделаем
[01:46:20.020 --> 01:46:22.020]  вот так.
[01:46:22.020 --> 01:46:24.020]  Я у мамы сделал виртуальный метод f,
[01:46:24.020 --> 01:46:26.020]  а у сына сделал переопределенный метод f.
[01:46:26.020 --> 01:46:28.020]  Давайте тут будет 2,
[01:46:28.020 --> 01:46:30.020]  тут будет 0,
[01:46:30.020 --> 01:46:32.020]  тут будет 1.
[01:46:32.020 --> 01:46:34.020]  Я сейчас заставил cpp
[01:46:34.020 --> 01:46:36.020]  г плюс плюс 20
[01:46:36.020 --> 01:46:38.020]  стандарта
[01:46:38.020 --> 01:46:40.020]  инлайнить прям нормально.
[01:46:40.020 --> 01:46:42.020]  Кого, виртуальную функцию?
[01:46:42.020 --> 01:46:44.020]  Нет, просто функции.
[01:46:44.020 --> 01:46:46.020]  Нуууу.
[01:46:46.020 --> 01:46:48.020]  Ха-ха-ха-ха.
[01:46:48.020 --> 01:46:50.020]  Ха-ха-ха.
[01:46:50.020 --> 01:46:52.020]  Ха-ха-ха.
[01:46:52.020 --> 01:46:54.020]  Он это сделал не по собственному желанию,
[01:46:54.020 --> 01:46:56.020]  а после флага
[01:46:56.020 --> 01:46:58.020]  квадратные скобки двойные
[01:46:58.020 --> 01:47:00.020]  always in line.
[01:47:02.020 --> 01:47:04.020]  Я с 550 миллисекунд
[01:47:04.020 --> 01:47:06.020]  150 менял.
[01:47:08.020 --> 01:47:10.020]  Ну, я не уверен,
[01:47:10.020 --> 01:47:12.020]  что этот флаг
[01:47:12.020 --> 01:47:14.020]  работает для всех.
[01:47:14.020 --> 01:47:16.020]  Ну, короче, не знаю, давайте
[01:47:16.020 --> 01:47:18.020]  в чате потом подискутируем.
[01:47:18.020 --> 01:47:20.020]  Так, теперь про виртуальные. Вот смотрите,
[01:47:20.020 --> 01:47:22.020]  у меня есть virtual,
[01:47:22.020 --> 01:47:24.020]  виртуальный метод у мамы.
[01:47:24.020 --> 01:47:26.020]  И я у сына его переопределил.
[01:47:26.020 --> 01:47:28.020]  Я возьму
[01:47:28.020 --> 01:47:30.020]  указатель на этот виртуальный метод.
[01:47:34.020 --> 01:47:36.020]  Не, не так. Я вот так
[01:47:36.020 --> 01:47:38.020]  сделаю. Mother
[01:47:38.020 --> 01:47:40.020]  p.
[01:47:40.020 --> 01:47:42.020]  Это будет указатель на мамин f.
[01:47:44.020 --> 01:47:46.020]  Вот это все обойду, я
[01:47:46.020 --> 01:47:48.020]  отодвину куда-нибудь там, напишу return 0.
[01:47:48.020 --> 01:47:50.020]  Вот.
[01:47:50.020 --> 01:47:52.020]  И сделаю так.
[01:47:52.020 --> 01:47:54.020]  Сделаю
[01:47:54.020 --> 01:47:56.020]  сын
[01:47:56.020 --> 01:47:58.020]  s, ой,
[01:47:58.020 --> 01:48:00.020]  сын, son,
[01:48:00.020 --> 01:48:02.020]  а теперь
[01:48:02.020 --> 01:48:04.020]  сын точка звездочка
[01:48:04.020 --> 01:48:06.020]  p,
[01:48:06.020 --> 01:48:08.020]  ну, просто.
[01:48:08.020 --> 01:48:10.020]  Вот что выведется?
[01:48:12.020 --> 01:48:14.020]  0 или
[01:48:14.020 --> 01:48:16.020]  2?
[01:48:18.020 --> 01:48:20.020]  Ну, у мамы
[01:48:20.020 --> 01:48:22.020]  реализован виртуальный метод f.
[01:48:22.020 --> 01:48:24.020]  Он выводит 0.
[01:48:24.020 --> 01:48:26.020]  У сына реализован переопределенный
[01:48:26.020 --> 01:48:28.020]  виртуальный метод, он выводит 2. Я взял
[01:48:28.020 --> 01:48:30.020]  адрес виртуального метода
[01:48:30.020 --> 01:48:32.020]  мамы
[01:48:32.020 --> 01:48:34.020]  и вызвал
[01:48:34.020 --> 01:48:36.020]  по адресу этот метод у сына.
[01:48:40.020 --> 01:48:42.020]  Ну как, я же взял адрес
[01:48:42.020 --> 01:48:44.020]  маминого f.
[01:48:44.020 --> 01:48:46.020]  Так он посмотрит.
[01:48:46.020 --> 01:48:48.020]  Виртуальный.
[01:48:48.020 --> 01:48:50.020]  Почему?
[01:48:50.020 --> 01:48:52.020]  Да, сейчас надо посмотреть, как будет
[01:48:52.020 --> 01:48:54.020]  задан вопрос.
[01:48:54.020 --> 01:48:56.020]  Ну что выведется?
[01:48:56.020 --> 01:48:58.020]  Так, кто считает, что выведется 0?
[01:48:58.020 --> 01:49:00.020]  0 это мамин, да?
[01:49:00.020 --> 01:49:02.020]  Мамин выведется.
[01:49:02.020 --> 01:49:04.020]  Кто считает, что выведется 2?
[01:49:04.020 --> 01:49:06.020]  А остальные?
[01:49:10.020 --> 01:49:12.020]  Обожаю.
[01:49:12.020 --> 01:49:14.020]  Кто считает, что выведется 1?
[01:49:14.020 --> 01:49:16.020]  Кто считает, что у b?
[01:49:16.020 --> 01:49:18.020]  Я 6.
[01:49:18.020 --> 01:49:20.020]  Я 6.
[01:49:20.020 --> 01:49:22.020]  Да, ну 2.
[01:49:22.020 --> 01:49:24.020]  А как это работает-то тогда?
[01:49:24.020 --> 01:49:26.020]  Ну, очевидно.
[01:49:26.020 --> 01:49:28.020]  Очевидно?
[01:49:28.020 --> 01:49:30.020]  Ну давайте уберем.
[01:49:30.020 --> 01:49:32.020]  Ну давайте уберем
[01:49:32.020 --> 01:49:34.020]  sizeof.
[01:49:34.020 --> 01:49:36.020]  Давайте, короче, уберем и вернем
[01:49:36.020 --> 01:49:38.020]  и посмотрим, что там написано в этом
[01:49:38.020 --> 01:49:40.020]  в этом поинтере.
[01:49:46.020 --> 01:49:48.020]  Что понятно?
[01:49:48.020 --> 01:49:52.020]  Все.
[01:49:52.020 --> 01:49:54.020]  Вывелось 2.
[01:49:54.020 --> 01:49:56.020]  Потом написано 16.
[01:49:56.020 --> 01:49:58.020]  То есть размер этого поинтера
[01:49:58.020 --> 01:50:00.020]  все еще 16.
[01:50:00.020 --> 01:50:02.020]  Размер структуры тоже 16.
[01:50:02.020 --> 01:50:04.020]  И на самом деле
[01:50:04.020 --> 01:50:06.020]  там два числа 1 и 0.
[01:50:06.020 --> 01:50:08.020]  Это как?
[01:50:08.020 --> 01:50:10.020]  А почему 1?
[01:50:10.020 --> 01:50:12.020]  Да, почему 1?
[01:50:12.020 --> 01:50:14.020]  Указатель.
[01:50:14.020 --> 01:50:16.020]  Нет, указатель.
[01:50:16.020 --> 01:50:18.020]  Какое-то большое число.
[01:50:18.020 --> 01:50:20.020]  Ну хорошо.
[01:50:20.020 --> 01:50:22.020]  А если я сделаю
[01:50:22.020 --> 01:50:24.020]  вот этот метод виртуальным?
[01:50:24.020 --> 01:50:26.020]  Папин.
[01:50:26.020 --> 01:50:28.020]  Вот. И у сына
[01:50:28.020 --> 01:50:30.020]  теперь возьму
[01:50:30.020 --> 01:50:32.020]  вызову его.
[01:50:32.020 --> 01:50:34.020]  Father же.
[01:50:40.020 --> 01:50:42.020]  Ну выведется-то понятно 1.
[01:50:42.020 --> 01:50:44.020]  Меня больше интересует
[01:50:44.020 --> 01:50:46.020]  теперь, какие числа будут.
[01:50:46.020 --> 01:50:48.020]  Опять 1 и 0.
[01:50:48.020 --> 01:50:52.020]  Сейчас.
[01:50:52.020 --> 01:50:54.020]  Я пытаюсь только
[01:50:54.020 --> 01:50:56.020]  Ага.
[01:51:00.020 --> 01:51:02.020]  Тоже 1 и 0.
[01:51:02.020 --> 01:51:04.020]  Сейчас, я пытаюсь сделать, чтобы был не 0
[01:51:04.020 --> 01:51:06.020]  в конце. Давайте я сделаю здесь
[01:51:06.020 --> 01:51:08.020]  g, например.
[01:51:08.020 --> 01:51:10.020]  Чего?
[01:51:10.020 --> 01:51:12.020]  Когда она еще у нас не виртуальная была.
[01:51:16.020 --> 01:51:18.020]  Кто? f была виртуальная.
[01:51:18.020 --> 01:51:20.020]  А раньше это на сколько раньше?
[01:51:20.020 --> 01:51:22.020]  Когда еще их не было.
[01:51:22.020 --> 01:51:24.020]  Там было pointer,
[01:51:24.020 --> 01:51:26.020]  а потом 0.
[01:51:28.020 --> 01:51:30.020]  Вот. Что
[01:51:30.020 --> 01:51:32.020]  на самом деле хранят эти числа?
[01:51:32.020 --> 01:51:34.020]  Что такое 1?
[01:51:36.020 --> 01:51:38.020]  И что такое 0?
[01:51:40.020 --> 01:51:42.020]  Ну вот, утверждается, что
[01:51:42.020 --> 01:51:44.020]  одно из этих чисел это сдвиг
[01:51:44.020 --> 01:51:46.020]  относительно... короче, где
[01:51:46.020 --> 01:51:48.020]  виртуальные таблицы искать?
[01:51:48.020 --> 01:51:50.020]  Поскольку у нас syn это
[01:51:50.020 --> 01:51:52.020]  виртуальный
[01:51:56.020 --> 01:51:58.020]  Сейчас.
[01:52:02.020 --> 01:52:04.020]  Ну, когда мы вызываем
[01:52:04.020 --> 01:52:06.020]  значит
[01:52:08.020 --> 01:52:10.020]  указатель
[01:52:10.020 --> 01:52:12.020]  метод по указателю на метод
[01:52:12.020 --> 01:52:14.020]  Компилятору нужно как-то научиться
[01:52:14.020 --> 01:52:16.020]  различать ситуацию, мы
[01:52:16.020 --> 01:52:18.020]  по указателю на виртуальный метод его вызываем, или нет?
[01:52:18.020 --> 01:52:20.020]  Вот. То есть
[01:52:20.020 --> 01:52:22.020]  на самом деле компилятор вынужден
[01:52:22.020 --> 01:52:24.020]  сохранять что-то иное,
[01:52:24.020 --> 01:52:26.020]  не просто pointer,
[01:52:26.020 --> 01:52:28.020]  а он какое-то число сохраняет,
[01:52:28.020 --> 01:52:30.020]  которое говорит
[01:52:30.020 --> 01:52:32.020]  в рантайме
[01:52:32.020 --> 01:52:34.020]  исполнителю, что
[01:52:34.020 --> 01:52:36.020]  это виртуальный метод, вызывай его
[01:52:36.020 --> 01:52:38.020]  особенным образом. То есть указатель
[01:52:38.020 --> 01:52:40.020]  ищи не
[01:52:40.020 --> 01:52:42.020]  тут прям, где написано,
[01:52:42.020 --> 01:52:44.020]  а прыгай в таблицу. Вот эта вот
[01:52:44.020 --> 01:52:46.020]  единица кажется,
[01:52:46.020 --> 01:52:48.020]  если мне не изменяет память,
[01:52:48.020 --> 01:52:50.020]  это заглушка, ну то есть
[01:52:50.020 --> 01:52:52.020]  это, компилятор хранит
[01:52:52.020 --> 01:52:54.020]  просто какое-то фейковое число,
[01:52:54.020 --> 01:52:56.020]  сохраняет, которое говорит
[01:52:56.020 --> 01:52:58.020]  в рантайме, что по этому указателю
[01:52:58.020 --> 01:53:00.020]  на метод лежит виртуальный метод
[01:53:00.020 --> 01:53:02.020]  и не считай меня указателем,
[01:53:02.020 --> 01:53:04.020]  а иди в таблицу тогда и там ищи.
[01:53:04.020 --> 01:53:06.020]  Вот.
[01:53:06.020 --> 01:53:08.020]  А сдвиг,
[01:53:08.020 --> 01:53:10.020]  ну это кажется
[01:53:10.020 --> 01:53:12.020]  это должен быть сдвиг
[01:53:12.020 --> 01:53:14.020]  где в таблице собственно искать, насколько
[01:53:14.020 --> 01:53:16.020]  далеко от таблицы его искать, только
[01:53:16.020 --> 01:53:18.020]  почему-то он ноль у меня и во втором случае тоже.
[01:53:18.020 --> 01:53:24.020]  Сейчас может быть я сделаю
[01:53:24.020 --> 01:53:26.020]  сын же и тогда он
[01:53:26.020 --> 01:53:28.020]  изменится.
[01:53:40.020 --> 01:53:42.020]  Заглушка не сломалась.
[01:53:42.020 --> 01:53:44.020]  Знаете, вот как это работает.
[01:53:44.020 --> 01:53:46.020]  Он, короче,
[01:53:46.020 --> 01:53:48.020]  очень хитро.
[01:53:48.020 --> 01:53:50.020]  Число 9.
[01:53:50.020 --> 01:53:52.020]  Ну, кажется,
[01:53:52.020 --> 01:53:54.020]  да, это полный квадрат.
[01:53:56.020 --> 01:53:58.020]  Я подыграл.
[01:53:58.020 --> 01:54:00.020]  Нет, это конечно ничего не значит.
[01:54:04.020 --> 01:54:06.020]  Значит,
[01:54:06.020 --> 01:54:08.020]  это такой, вообще,
[01:54:08.020 --> 01:54:10.020]  это просто хак, по-моему,
[01:54:10.020 --> 01:54:12.020]  который я не уверен,
[01:54:12.020 --> 01:54:14.020]  может быть я вас сейчас обманываю, но по-моему
[01:54:14.020 --> 01:54:16.020]  я в свое время
[01:54:16.020 --> 01:54:18.020]  читал
[01:54:18.020 --> 01:54:20.020]  про то, что, ну, понятно, что
[01:54:20.020 --> 01:54:22.020]  компиляторы по-разному это реализовывают,
[01:54:22.020 --> 01:54:24.020]  вот, но идея
[01:54:24.020 --> 01:54:26.020]  в следующем. Если бы там был
[01:54:26.020 --> 01:54:28.020]  настоящий указатель,
[01:54:28.020 --> 01:54:30.020]  то он бы, у него
[01:54:30.020 --> 01:54:32.020]  старший, младший бит был бы ноль.
[01:54:34.020 --> 01:54:36.020]  Вот тот факт, что здесь то один,
[01:54:36.020 --> 01:54:38.020]  то девять говорит о том, что это
[01:54:38.020 --> 01:54:40.020]  не настоящий указатель.
[01:54:40.020 --> 01:54:42.020]  Короче, хак.
[01:54:42.020 --> 01:54:44.020]  Вот там хранится последним битом
[01:54:44.020 --> 01:54:46.020]  ноль, это не ноль,
[01:54:46.020 --> 01:54:48.020]  это нечетное число.
[01:54:48.020 --> 01:54:50.020]  И вот потому что это нечетное число,
[01:54:50.020 --> 01:54:52.020]  runtime понимает, что это не настоящий указатель.
[01:54:52.020 --> 01:54:54.020]  А можно пролистать наверх?
[01:54:54.020 --> 01:54:56.020]  Нет.
[01:54:56.020 --> 01:54:58.020]  Кажется, это так работает, я не уверен,
[01:54:58.020 --> 01:55:00.020]  но, по-моему, это так работает.
[01:55:00.020 --> 01:55:02.020]  А как он вообще находит?
[01:55:02.020 --> 01:55:04.020]  Ну, конечно, указатель это вообще
[01:55:04.020 --> 01:55:06.020]  кратное восьми число.
[01:55:06.020 --> 01:55:08.020]  Ну не, не кратное восьми, ладно,
[01:55:08.020 --> 01:55:10.020]  кратное восьми, да.
[01:55:10.020 --> 01:55:12.020]  Указатель это кратное восьми число должно быть.
[01:55:12.020 --> 01:55:15.020]  886, так хорошо делится на 8?
[01:55:15.020 --> 01:55:21.020]  886, ну да, нет что ли?
[01:55:25.020 --> 01:55:28.020]  Ну это вопрос о том, делится ли 114 на 8.
[01:55:28.020 --> 01:55:30.020]  Нет, 114 не делится на 8.
[01:55:30.020 --> 01:55:34.020]  Слушайте, 888 делится на 8, делится ли 886?
[01:55:34.020 --> 01:55:35.020]  Да, не делится, да.
[01:55:35.020 --> 01:55:38.020]  888, я к 100 добавлял 12, ну ладно.
[01:55:38.020 --> 01:55:42.020]  Ну короче, да, не кратное 8, ну кратное 4, по крайней мере, всегда.
[01:55:42.020 --> 01:55:44.020]  Ну это тоже неправда.
[01:55:44.020 --> 01:55:47.020]  Потому что 888 делится на 4.
[01:55:47.020 --> 01:55:50.020]  Ого, интересно.
[01:55:50.020 --> 01:55:56.020]  Возможно, когда оно кастится в int, оно по-другому читается,
[01:55:56.020 --> 01:55:59.020]  потому что, возможно, у него там старшие биты записаны первыми.
[01:55:59.020 --> 01:56:02.020]  Вот, но, короче...
[01:56:02.020 --> 01:56:04.020]  Может, оно больше, чем max.long.com.
[01:56:04.020 --> 01:56:07.020]  Короче, хак.
[01:56:07.020 --> 01:56:08.020]  А, нет.
[01:56:08.020 --> 01:56:10.020]  Вообще, удивительная штука.
[01:56:10.020 --> 01:56:16.020]  Вот это число, вот по этому числу компилятор должен понять,
[01:56:16.020 --> 01:56:18.020]  не компилятор, а runtime должен понять,
[01:56:18.020 --> 01:56:21.020]  это настоящий указатель или это заглушка,
[01:56:21.020 --> 01:56:23.020]  означающая, что метод виртуальный,
[01:56:23.020 --> 01:56:26.020]  и нужно прыгать в таблицу и там искать по сдвигу.
[01:56:26.020 --> 01:56:29.020]  И вот, если он видит, что это настоящий указатель,
[01:56:29.020 --> 01:56:34.020]  то он идет, значит, смотрит, ну, прыгает по этому адресу.
[01:56:34.020 --> 01:56:37.020]  А если он видит здесь, что это какое-то странное число,
[01:56:37.020 --> 01:56:38.020]  которое не указатель,
[01:56:38.020 --> 01:56:42.020]  то он, видимо, по младшему биту понимает,
[01:56:42.020 --> 01:56:44.020]  что это на самом деле был виртуальный метод.
[01:56:44.020 --> 01:56:48.020]  Ну, ведь я же, типа, я же могу присвоить этому поинтеру
[01:56:48.020 --> 01:56:50.020]  указатель теперь на невиртуальный метод.
[01:56:50.020 --> 01:56:54.020]  И по-прежнему продолжать вызывать через точку-звездочку этот метод.
[01:56:54.020 --> 01:56:55.020]  Как он будет различать?
[01:56:55.020 --> 01:56:56.020]  А вот как.
[01:56:56.020 --> 01:56:59.020]  Он просто в runtime, глядя на первое число,
[01:56:59.020 --> 01:57:01.020]  должен как-то понимать, это настоящий указатель или нет.
[01:57:01.020 --> 01:57:03.020]  И вот, видимо, так он и понимает.
[01:57:03.020 --> 01:57:06.020]  Это вообще магия.
[01:57:06.020 --> 01:57:08.020]  Не, ну вот он понял, что это не настоящий указатель.
[01:57:08.020 --> 01:57:10.020]  А где метод-то искать, типа, сам?
[01:57:10.020 --> 01:57:13.020]  А вот он теперь идет, раз это не настоящий указатель,
[01:57:13.020 --> 01:57:15.020]  это значит, был виртуальный метод.
[01:57:15.020 --> 01:57:16.020]  Значит, у меня есть только один вариант.
[01:57:16.020 --> 01:57:17.020]  Нужно идти в таблицу.
[01:57:17.020 --> 01:57:19.020]  В таблицу виртуальных функций для объекта sun.
[01:57:19.020 --> 01:57:21.020]  Ну, это же объект sun.
[01:57:21.020 --> 01:57:23.020]  Я иду к нему в таблицу виртуальных функций.
[01:57:23.020 --> 01:57:25.020]  А вот это число, видимо, показывает мне,
[01:57:25.020 --> 01:57:29.020]  насколько мне нужно сдвинуться относительно начала этой таблицы,
[01:57:29.020 --> 01:57:31.020]  чтобы там найти настоящий указатель.
[01:57:31.020 --> 01:57:33.020]  Ну, игнорируя единицу.
[01:57:33.020 --> 01:57:35.020]  То есть вот здесь был пока ноль.
[01:57:35.020 --> 01:57:37.020]  Я в начале таблицы нахожу.
[01:57:37.020 --> 01:57:40.020]  А этот девять, это значит, что это не настоящий метод.
[01:57:40.020 --> 01:57:44.020]  Прыгай в таблицу и там сдвигайся на восемь.
[01:57:44.020 --> 01:57:46.020]  А, и ты доказываешь, что таблица...
[01:57:46.020 --> 01:57:52.020]  То, что у нас f и g лежат в разных таблицах.
[01:57:52.020 --> 01:57:54.020]  Это правда?
[01:57:54.020 --> 01:57:55.020]  Нет, почему?
[01:57:55.020 --> 01:57:56.020]  Одна таблица для sun.
[01:57:56.020 --> 01:57:57.020]  У меня есть...
[01:57:57.020 --> 01:58:00.020]  Я в sun переопределил и f, и g.
[01:58:05.020 --> 01:58:12.020]  Если мы у мамин f берем, то там единица будет, да?
[01:58:12.020 --> 01:58:13.020]  Выведется единица.
[01:58:13.020 --> 01:58:14.020]  Да.
[01:58:14.020 --> 01:58:16.020]  Если папин g, это тоже единица.
[01:58:16.020 --> 01:58:17.020]  Что?
[01:58:17.020 --> 01:58:22.020]  А если наш f и наш g, тогда девять выводится.
[01:58:22.020 --> 01:58:24.020]  Это странно, нет?
[01:58:24.020 --> 01:58:26.020]  Это же одинаково.
[01:58:35.020 --> 01:58:45.020]  Да, это я не понимаю, почему так.
[01:58:45.020 --> 01:58:56.020]  Сейчас, если я возьму папин g...
[01:58:56.020 --> 01:58:59.020]  Да.
[01:58:59.020 --> 01:59:02.020]  И посмотрю, что он из себя представляет.
[01:59:02.020 --> 01:59:03.020]  Папин g.
[01:59:03.020 --> 01:59:04.020]  Да.
[01:59:04.020 --> 01:59:05.020]  То...
[01:59:05.020 --> 01:59:06.020]  О, шестнадцать, откуда?
[01:59:06.020 --> 01:59:07.020]  Полный квадрат.
[01:59:07.020 --> 01:59:08.020]  Ну, это понятно.
[01:59:08.020 --> 01:59:09.020]  Это сдвиг, опять-таки.
[01:59:09.020 --> 01:59:10.020]  Это относительно начала объекта сдвиг.
[01:59:10.020 --> 01:59:27.020]  Я взял указатель на метод сына, а присвоил ему адрес
[01:59:27.020 --> 01:59:28.020]  метода отца.
[01:59:28.020 --> 01:59:33.020]  И вот этот указатель, он запоминает, насколько отец
[01:59:33.020 --> 01:59:36.020]  сдвинут относительно начала сына, опять-таки.
[01:59:36.020 --> 01:59:37.020]  Вот.
[01:59:37.020 --> 01:59:46.020]  А когда у меня было вот так, наверное, это вот что
[01:59:46.020 --> 01:59:47.020]  означало.
[01:59:47.020 --> 01:59:50.020]  Это означало, что мне нужно идти в таблицу не сына,
[01:59:50.020 --> 01:59:51.020]  а отца.
[01:59:51.020 --> 01:59:52.020]  Просто.
[01:59:52.020 --> 01:59:53.020]  Запустите так.
[01:59:53.020 --> 01:59:54.020]  Улица одинокая.
[01:59:54.020 --> 01:59:55.020]  Да.
[01:59:55.020 --> 01:59:58.020]  Он, поскольку метод фазера, то, видимо, он, зная, что
[01:59:58.020 --> 02:00:01.020]  он будет делать, он будет делать.
[02:00:01.020 --> 02:00:04.020]  То, видимо, он, зная, что это указатель на метод
[02:00:04.020 --> 02:00:07.020]  отца, он понимает, что ему надо идти в таблицу не сына,
[02:00:07.020 --> 02:00:08.020]  а отца.
[02:00:08.020 --> 02:00:11.020]  Ну, то есть, которая вот вторая в сыне.
[02:00:11.020 --> 02:00:13.020]  И в нее идет, видимо.
[02:00:13.020 --> 02:00:16.020]  И относительно нее уже сдвиг ноль.
[02:00:16.020 --> 02:00:20.020]  И сдвиг же относительно начала при этом ноль, потому
[02:00:20.020 --> 02:00:22.020]  что там фазер и там фазер.
[02:00:22.020 --> 02:00:28.020]  Ну, опять же, остается странным то, что у нас мамина функция.
[02:00:28.020 --> 02:00:29.020]  Это...
[02:00:29.020 --> 02:00:33.020]  Мамин метод это один ноль, а наш это девять ноль.
[02:00:33.020 --> 02:00:35.020]  Какой еще раз метод?
[02:00:35.020 --> 02:00:38.020]  Мамин это...
[02:00:38.020 --> 02:00:39.020]  Если мы...
[02:00:39.020 --> 02:00:40.020]  Сейчас, вот сейчас.
[02:00:40.020 --> 02:00:42.020]  Ну, хорошо.
[02:00:42.020 --> 02:00:47.020]  Вот я говорю вот такая штука и говорю мамин метод g.
[02:00:47.020 --> 02:00:49.020]  Мамин f.
[02:00:49.020 --> 02:00:50.020]  Мамин f.
[02:00:50.020 --> 02:00:51.020]  Р.
[02:00:51.020 --> 02:00:52.020]  Р.
[02:00:52.020 --> 02:00:53.020]  Р.
[02:00:53.020 --> 02:00:54.020]  Р.
[02:00:54.020 --> 02:00:55.020]  Р.
[02:00:55.020 --> 02:00:56.020]  Р.
[02:00:56.020 --> 02:00:57.020]  Р.
[02:00:57.020 --> 02:00:58.020]  Р.
[02:00:58.020 --> 02:00:59.020]  Р.
[02:00:59.020 --> 02:01:00.020]  Р.
[02:01:00.020 --> 02:01:05.020]  Ну сейчас будет все то же самое, будет один ноль.
[02:01:05.020 --> 02:01:07.020]  Просто он идет в начальную таблицу нашего объекта,
[02:01:07.020 --> 02:01:12.020]  от нее ничего не отступает и сама эта таблица от начала
[02:01:12.020 --> 02:01:15.020]  объекта никак, никакого отступа не имеет.
[02:01:15.020 --> 02:01:21.020]  Если я сделаю вот так, то теперь он понимает, что
[02:01:21.020 --> 02:01:24.020]  объект фазер, то есть...
[02:01:24.020 --> 02:01:25.020]  C.
[02:01:25.020 --> 02:01:26.020]  C.
[02:01:26.020 --> 02:01:29.060]  он идет в таблицу сына по-прежнему
[02:01:29.060 --> 02:01:31.240]  и уже
[02:01:31.240 --> 02:01:33.440]  берет из нее не первый метод, а второй.
[02:01:37.880 --> 02:01:38.780]  Господи, Ж.
[02:01:46.680 --> 02:01:49.180]  Он идет в таблицу свою
[02:01:49.180 --> 02:01:56.140]  вызывает из нее
[02:01:56.140 --> 02:01:57.480]  метод
[02:01:57.480 --> 02:02:08.000]  Блин, я запутался.
[02:02:08.140 --> 02:02:09.800]  Ну, короче, одно из этих чисел показывает,
[02:02:09.980 --> 02:02:12.420]  насколько мы от начала объекта сдвинуты,
[02:02:12.420 --> 02:02:14.120]  а другое показывает, насколько нужно
[02:02:14.120 --> 02:02:15.740]  от начала виртуальной таблицы прыгнуть.
[02:02:19.180 --> 02:02:23.040]  А, от начала текущего указателя.
[02:02:25.460 --> 02:02:27.280]  Так, ну давайте разберем все-таки еще раз.
[02:02:27.620 --> 02:02:29.080]  Вот, когда у меня
[02:02:29.080 --> 02:02:30.620]  mother f, все понятно.
[02:02:31.220 --> 02:02:32.920]  Когда у меня father g,
[02:02:34.140 --> 02:02:35.820]  он говорит 1 и 16.
[02:02:36.000 --> 02:02:37.220]  Это значит, что он от начала
[02:02:37.220 --> 02:02:39.000]  виртуальной таблицы не сдвигается вообще.
[02:02:40.940 --> 02:02:41.700]  Типа, да.
[02:02:41.700 --> 02:02:43.180]  Но при этом
[02:02:43.180 --> 02:02:45.860]  он
[02:02:45.860 --> 02:02:47.700]  указывает
[02:02:49.180 --> 02:02:54.820]  Но при этом он говорит, что надо
[02:02:54.820 --> 02:02:56.620]  на 16
[02:02:56.620 --> 02:03:02.960]  Это как раз означает
[02:03:02.960 --> 02:03:04.920]  видимо,
[02:03:05.140 --> 02:03:07.460]  что ему нужно посмотреть не на таблицу,
[02:03:07.680 --> 02:03:07.980]  которая
[02:03:07.980 --> 02:03:10.660]  в начале объекта лежит, а на таблицу,
[02:03:10.660 --> 02:03:13.100]  которая спустя 16 байт от начала объекта лежит.
[02:03:13.540 --> 02:03:14.800]  Но от начала этой таблицы
[02:03:14.800 --> 02:03:16.700]  уже не сдвигаться, потому что там сразу лежит g.
[02:03:17.460 --> 02:03:19.160]  И падя, соответственно, который надо использовать.
[02:03:19.180 --> 02:03:19.960]  Вот.
[02:03:19.960 --> 02:03:22.160]  То есть вот это 16 означает, что он
[02:03:22.160 --> 02:03:24.060]  просто смотрит не в первую таблицу,
[02:03:24.060 --> 02:03:26.360]  а в ту, которая на 16 сдвинута от начала объекта,
[02:03:26.360 --> 02:03:28.360]  но от начала этой таблицы уже не сдвигается.
[02:03:28.360 --> 02:03:30.360]  Хорошо, с этим все ясно. Что если sun?
[02:03:30.360 --> 02:03:32.360]  Вот. Если здесь написано sun g,
[02:03:33.960 --> 02:03:35.960]  то значит он смотрит
[02:03:38.000 --> 02:03:40.620]  на таблицу, которая в начале объекта,
[02:03:40.620 --> 02:03:43.500]  но относительно этой таблицы сдвигается на 8
[02:03:43.500 --> 02:03:45.320]  от начала этой таблицы, потому что в этой таблице
[02:03:45.320 --> 02:03:47.320]  перечислено как f, так и g, по всей видимости.
[02:03:47.320 --> 02:03:48.320]  I think this is sun f,
[02:03:49.180 --> 02:03:51.180]  тогда будет один ноль.
[02:03:51.180 --> 02:03:53.180]  А если sun f, то один ноль, да.
[02:03:53.180 --> 02:03:55.180]  Ну, как и mother f, потому что
[02:03:55.180 --> 02:03:57.180]  это то же самое, один ноль.
[02:03:57.180 --> 02:03:59.180]  Кажется, разобрались. Чего?
[02:03:59.180 --> 02:04:01.180]  Почему он на 8 сдвигается?
[02:04:01.180 --> 02:04:03.180]  Потому что в сыновьей таблице, которая в начале объекта,
[02:04:03.180 --> 02:04:05.180]  там лежит как адрес f, так и адрес g.
[02:04:05.180 --> 02:04:07.180]  Да, это понятно.
[02:04:07.180 --> 02:04:09.180]  Ну, сначала адрес f записан, потом адрес g.
[02:04:09.180 --> 02:04:11.180]  Он, вот этот ноль
[02:04:11.180 --> 02:04:13.180]  означает, что он берет таблицу с самого
[02:04:13.180 --> 02:04:15.180]  начала объекта, а вот
[02:04:15.180 --> 02:04:17.180]  это 9 означает, ну мы забиваем
[02:04:17.180 --> 02:04:19.080]  на младший бит, там 8 на самом деле.
[02:04:19.080 --> 02:04:21.080]  Что мы берем не первый
[02:04:21.080 --> 02:04:23.080]  entry в этой таблице, а следующий.
[02:04:23.080 --> 02:04:25.080]  То есть первый пропускаем, берем второй.
[02:04:25.080 --> 02:04:27.080]  Адрес g берем оттуда.
[02:04:27.080 --> 02:04:29.080]  То есть мы доказали,
[02:04:29.080 --> 02:04:31.080]  что у нас в маминой таблице
[02:04:31.080 --> 02:04:33.080]  будет лежать...
[02:04:33.080 --> 02:04:35.080]  Да, мы такие, кажется, доказали, что в маминой таблице будет лежать
[02:04:35.080 --> 02:04:37.080]  g в том числе.
[02:04:43.080 --> 02:04:45.080]  Так, ну, слушайте,
[02:04:45.080 --> 02:04:47.080]  это вообще, по-моему, круто очень.
[02:04:47.080 --> 02:04:49.080]  Это вообще, это же красота.
[02:04:49.080 --> 02:04:51.080]  Сейчас, а еще раз.
[02:04:51.080 --> 02:04:53.080]  Кто испытал катарсис? Это вообще очень круто.
[02:04:53.080 --> 02:04:55.080]  Еще раз, реинтерпрет каст это
[02:04:55.080 --> 02:04:57.080]  вот эти все-таки убы или нет?
[02:04:57.080 --> 02:04:59.080]  Ну,
[02:04:59.080 --> 02:05:01.080]  да что, ах, ничего не понял.
[02:05:01.080 --> 02:05:03.080]  Ну как, мы тут такие красивые вещи
[02:05:03.080 --> 02:05:05.080]  делаем, а ты какую-то
[02:05:05.080 --> 02:05:07.080]  спрашиваешь. А ты про какое-то убы.
[02:05:07.080 --> 02:05:09.080]  Да, а ты про какое-то убы тут спрашиваешь.
[02:05:09.080 --> 02:05:11.080]  Ну, реинтерпрет каст это убы, конечно, сейчас.
[02:05:15.080 --> 02:05:17.080]  Нет, ну что, ну я увидел настоящее число.
[02:05:17.080 --> 02:05:19.080]  Вот, но эта идея
[02:05:19.080 --> 02:05:21.080]  о том, что за счет фейкового
[02:05:21.080 --> 02:05:23.080]  бита мы отличаем
[02:05:23.080 --> 02:05:25.080]  настоящий указатель от ненастоящего
[02:05:25.080 --> 02:05:27.080]  указателя, это вообще просто.
[02:05:27.080 --> 02:05:29.080]  Это, конечно, знатный костыль. Это просто
[02:05:29.080 --> 02:05:31.080]  трешак.
[02:05:31.080 --> 02:05:33.080]  Ну,
[02:05:33.080 --> 02:05:35.080]  можно так сказать.
[02:05:37.080 --> 02:05:39.080]  Так, ну, ладно.
[02:05:39.080 --> 02:05:41.080]  Ну, это было, короче, очень классно, но
[02:05:41.080 --> 02:05:43.080]  все, хорошему понемножку.
[02:05:43.080 --> 02:05:45.080]  Давайте теперь
[02:05:45.080 --> 02:05:47.080]  перейдем наконец-то к шестой главе.
[02:05:47.080 --> 02:05:49.080]  Он идет
[02:05:49.080 --> 02:05:51.080]  в таблицу объектов.
[02:05:51.080 --> 02:05:53.080]  А кто понял вообще из того, о чем
[02:05:53.080 --> 02:05:55.080]  мы сейчас говорили, что мы выяснили вообще?
[02:05:55.080 --> 02:05:57.080]  Кто вообще понял?
[02:05:57.080 --> 02:05:59.080]  Ну, ладно.
[02:05:59.080 --> 02:06:01.080]  А потом?
[02:06:01.080 --> 02:06:03.080]  Блин, надо
[02:06:03.080 --> 02:06:05.080]  конспект написать и вам прислать.
[02:06:05.080 --> 02:06:07.080]  Было больше не плохо.
[02:06:07.080 --> 02:06:09.080]  Хотя бы было
[02:06:09.080 --> 02:06:11.080]  хотя бы
[02:06:11.080 --> 02:06:13.080]  что-нибудь
[02:06:13.080 --> 02:06:15.080]  из вышедшего числа.
[02:06:15.080 --> 02:06:17.080]  Ну,
[02:06:17.080 --> 02:06:19.080]  так, шестая глава.
[02:06:19.080 --> 02:06:21.080]  Итак, мы
[02:06:21.080 --> 02:06:23.080]  переходим к шестой
[02:06:23.080 --> 02:06:25.080]  главе.
[02:06:25.080 --> 02:06:27.080]  Еще не последней в этом
[02:06:27.080 --> 02:06:29.080]  семестре для вас. Она будет последней для
[02:06:29.080 --> 02:06:31.080]  основного потока, но не для вас.
[02:06:31.080 --> 02:06:33.080]  Глава называется «Шаблоны».
[02:06:33.080 --> 02:06:35.080]  А мы обгоняем основной?
[02:06:35.080 --> 02:06:37.080]  Я на шаблонах на любую сдавал.
[02:06:37.080 --> 02:06:39.080]  Но вы обгоняете, и у вас
[02:06:39.080 --> 02:06:41.080]  еще есть пункты, которых у них нет.
[02:06:41.080 --> 02:06:43.080]  Например, вот то, что я сейчас рассказывал, у них, конечно, не будет.
[02:06:43.080 --> 02:06:45.080]  А седьмая — «Итератор»?
[02:06:45.080 --> 02:06:47.080]  Нет, седьмая исключение,
[02:06:47.080 --> 02:06:49.080]  а потом уже «Итераторы»
[02:06:49.080 --> 02:06:51.080]  с контейнерами.
[02:06:51.080 --> 02:06:53.080]  А все, что ты рассказывал,
[02:06:53.080 --> 02:06:55.080]  то, чем мы сейчас занимаемся,
[02:06:55.080 --> 02:06:57.080]  оно есть в лекциях два года назад?
[02:06:57.080 --> 02:06:59.080]  V-тейблы
[02:06:59.080 --> 02:07:01.080]  есть, вот это то, что
[02:07:01.080 --> 02:07:03.080]  V-пойнтеры нет,
[02:07:03.080 --> 02:07:05.080]  ну, в смысле virtual pointer to member
[02:07:05.080 --> 02:07:07.080]  нет. Я уже не помню
[02:07:07.080 --> 02:07:09.080]  два года назад, что есть. Нет, лучше
[02:07:09.080 --> 02:07:11.080]  год назад смотреть, а не два года, потому что
[02:07:11.080 --> 02:07:13.080]  два года назад там было хуже
[02:07:13.080 --> 02:07:15.080]  и меньше, и больше ошибок.
[02:07:15.080 --> 02:07:17.080]  Так.
[02:07:17.080 --> 02:07:19.080]  Там год назад про два
[02:07:19.080 --> 02:07:21.080]  было тоже записано. Да, да.
[02:07:21.080 --> 02:07:23.080]  Но они там частично записаны.
[02:07:23.080 --> 02:07:25.080]  Тоже.
[02:07:25.080 --> 02:07:27.080]  Так, шаблоны.
[02:07:27.080 --> 02:07:29.080]  Ну, вы все,
[02:07:29.080 --> 02:07:31.080]  наверное, знаете, что такое шаблоны.
[02:07:31.080 --> 02:07:33.080]  Что я вам рассказывать буду? Я тоже не знаю.
[02:07:33.080 --> 02:07:35.080]  Это не ROFL.
[02:07:35.080 --> 02:07:37.080]  А, хорошо, ладно.
[02:07:37.080 --> 02:07:39.080]  То есть, серьезно, я, блин, думал,
[02:07:39.080 --> 02:07:41.080]  что я сейчас буду опять тоже,
[02:07:41.080 --> 02:07:43.080]  сейчас все будут подшучивать надо мной,
[02:07:43.080 --> 02:07:45.080]  что я какую-то фигню рассказываю.
[02:07:45.080 --> 02:07:47.080]  Хе-хе-хе.
[02:07:49.080 --> 02:07:51.080]  Так, уважаемые господа,
[02:07:51.080 --> 02:07:53.080]  если вы сейчас последний час
[02:07:53.080 --> 02:07:55.080]  ничего не понимали,
[02:07:55.080 --> 02:07:57.080]  самое время взять себя в руки
[02:07:57.080 --> 02:07:59.080]  заново и начать пытаться понимать
[02:07:59.080 --> 02:08:01.080]  снова, вот. Потому что сейчас
[02:08:01.080 --> 02:08:03.080]  можно, якобы, на время забыть
[02:08:03.080 --> 02:08:05.080]  про виртуальные функции, про все то, что я рассказывал
[02:08:05.080 --> 02:08:07.080]  до этого. У нас...
[02:08:07.080 --> 02:08:09.080]  Да, новая тема, не связанная
[02:08:09.080 --> 02:08:11.080]  с предыдущими. Да, да, да.
[02:08:11.080 --> 02:08:13.080]  Но...
[02:08:13.080 --> 02:08:15.080]  Но на зачете я вам какие-нибудь вопросики про витейблы
[02:08:15.080 --> 02:08:17.080]  все-таки спрошу.
[02:08:17.080 --> 02:08:19.080]  Меньше, чем витейблы,
[02:08:19.080 --> 02:08:21.080]  чем виртуальные. В смысле, меньше?
[02:08:21.080 --> 02:08:23.080]  По объему
[02:08:23.080 --> 02:08:25.080]  это такой же, примерно.
[02:08:25.080 --> 02:08:27.080]  Даже побольше, может.
[02:08:27.080 --> 02:08:29.080]  Так, эээ...
[02:08:29.080 --> 02:08:31.080]  Смотрите.
[02:08:31.080 --> 02:08:33.080]  Давайте я напишу функцию,
[02:08:33.080 --> 02:08:35.080]  которая мне возвращает максимум из двух чисел.
[02:08:35.080 --> 02:08:37.080]  Хе-хе-хе-хе.
[02:08:37.080 --> 02:08:39.080]  Хе-хе-хе-хе.
[02:08:39.080 --> 02:08:41.080]  Вот это можно почувствовать.
[02:08:41.080 --> 02:08:43.080]  Хе-хе-хе-хе.
[02:08:43.080 --> 02:08:45.080]  Но у нас 6.1, ты не будешь помечать?
[02:08:45.080 --> 02:08:47.080]  Да, да. Значит, 6.1...
[02:08:47.080 --> 02:08:49.080]  Значит, параграф 6.1
[02:08:49.080 --> 02:08:51.080]  называется
[02:08:51.080 --> 02:08:53.080]  идея шаблонов
[02:08:55.080 --> 02:08:57.080]  и
[02:08:57.080 --> 02:08:59.080]  простые
[02:08:59.080 --> 02:09:01.080]  примеры.
[02:09:01.080 --> 02:09:03.080]  Ну, мотивировка какая? Вот у меня есть
[02:09:03.080 --> 02:09:05.080]  функция, которая возвращает максимум из двух чисел.
[02:09:05.080 --> 02:09:07.080]  Вот.
[02:09:07.080 --> 02:09:09.080]  А еще я мог бы захотеть
[02:09:09.080 --> 02:09:11.080]  иметь функцию, которая возвращает максимум
[02:09:11.080 --> 02:09:13.080]  из двух... Ну, не знаю,
[02:09:13.080 --> 02:09:15.080]  строк.
[02:09:15.080 --> 02:09:17.080]  Или вообще
[02:09:17.080 --> 02:09:19.080]  максимум из двух.
[02:09:19.080 --> 02:09:21.080]  Точка.
[02:09:21.080 --> 02:09:23.080]  Хе-хе-хе. Я не знаю, что это значит.
[02:09:23.080 --> 02:09:25.080]  Ну, тут, конечно, надо по константной
[02:09:25.080 --> 02:09:27.080]  ссылке принимать.
[02:09:27.080 --> 02:09:29.080]  ...
[02:09:29.080 --> 02:09:31.080]  ...
[02:09:31.080 --> 02:09:33.080]  ...
[02:09:33.080 --> 02:09:35.080]  Вот.
[02:09:35.080 --> 02:09:37.080]  И, возможно, надо и возвращать
[02:09:37.080 --> 02:09:39.080]  константную ссылку.
[02:09:39.080 --> 02:09:41.080]  Ну, давайте будем считать все-таки, что максимум копию возвращает.
[02:09:41.080 --> 02:09:43.080]  Я тоже самое делаю.
[02:09:43.080 --> 02:09:45.080]  return, там, a больше b, тогда
[02:09:45.080 --> 02:09:47.080]  a, иначе b.
[02:09:47.080 --> 02:09:49.080]  ...
[02:09:49.080 --> 02:09:51.080]  ...
[02:09:51.080 --> 02:09:53.080]  Мы уже обсуждали, почему, да.
[02:09:53.080 --> 02:09:55.080]  Это неэффективно для int.
[02:09:55.080 --> 02:09:57.080]  ...
[02:09:57.080 --> 02:09:59.080]  Ну, я могу таких функций
[02:09:59.080 --> 02:10:01.080]  еще много очень написать,
[02:10:01.080 --> 02:10:03.080]  но кажется, что...
[02:10:03.080 --> 02:10:05.080]  Понятно, что мне
[02:10:05.080 --> 02:10:07.080]  хотелось бы некоторые функции иметь общими
[02:10:07.080 --> 02:10:09.080]  для всех типов. Ну, то есть, например,
[02:10:09.080 --> 02:10:11.080]  тот же
[02:10:11.080 --> 02:10:13.080]  максимум для любых
[02:10:13.080 --> 02:10:15.080]  двух типов, которые поддерживают сравнение,
[02:10:15.080 --> 02:10:17.080]  кажется, что нет смысла
[02:10:17.080 --> 02:10:19.080]  реализовывать отдельно. Я могу сказать
[02:10:19.080 --> 02:10:21.080]  что-то типа, ну, что-то в духе такого
[02:10:21.080 --> 02:10:23.080]  для всех типов t.
[02:10:23.080 --> 02:10:25.080]  Определи, пожалуйста, функцию максимум
[02:10:25.080 --> 02:10:27.080]  следующим образом, которая принимает два
[02:10:27.080 --> 02:10:29.080]  объекта типа t и работает
[02:10:29.080 --> 02:10:31.080]  вот так просто. Вот это выражение вычисляет
[02:10:31.080 --> 02:10:33.080]  и возвращает t.
[02:10:33.080 --> 02:10:35.080]  Ну, или, например, функция swap,
[02:10:35.080 --> 02:10:37.080]  которая берет две
[02:10:37.080 --> 02:10:39.080]  ссылки на объекты
[02:10:39.080 --> 02:10:41.080]  и меняет местами.
[02:10:41.080 --> 02:10:43.080]  Создает новый, присваивает
[02:10:43.080 --> 02:10:45.080]  там t равно...
[02:10:45.080 --> 02:10:47.080]  Ну, то есть, я могу
[02:10:47.080 --> 02:10:49.080]  написать void swap,
[02:10:49.080 --> 02:10:51.080]  которая принимает два int по ссылке,
[02:10:53.080 --> 02:10:55.080]  которая создает новый int.
[02:10:59.080 --> 02:11:01.080]  Вот.
[02:11:01.080 --> 02:11:03.080]  Ну, кажется, что
[02:11:03.080 --> 02:11:05.080]  для многих функций
[02:11:05.080 --> 02:11:07.080]  хотелось бы иметь
[02:11:07.080 --> 02:11:09.080]  такой обобщенный
[02:11:09.080 --> 02:11:11.080]  определение, то есть не говорить
[02:11:11.080 --> 02:11:13.080]  для каждого типа заново,
[02:11:13.080 --> 02:11:15.080]  а для всех типов сразу сказать, что
[02:11:15.080 --> 02:11:17.080]  максимум для данных двух
[02:11:17.080 --> 02:11:19.080]  типов означает вот это.
[02:11:19.080 --> 02:11:21.080]  Ну, собственно, шаблон это как раз
[02:11:21.080 --> 02:11:23.080]  и есть способ сказать,
[02:11:23.080 --> 02:11:25.080]  что я определяю нечто для всех типов
[02:11:25.080 --> 02:11:27.080]  t одинаково.
[02:11:27.080 --> 02:11:29.080]  Я говорю...
[02:11:29.080 --> 02:11:31.080]  Я говорю,
[02:11:31.080 --> 02:11:33.080]  для всех типов t
[02:11:33.080 --> 02:11:35.080]  вот у вас, возможно,
[02:11:35.080 --> 02:11:37.080]  была
[02:11:37.080 --> 02:11:39.080]  уже вы что-то знаете про логику первого
[02:11:39.080 --> 02:11:41.080]  порядка.
[02:11:41.080 --> 02:11:43.080]  Можно относиться к шаблонам как
[02:11:43.080 --> 02:11:45.080]  в каком-то смысле такой вот...
[02:11:45.080 --> 02:11:47.080]  Ну, я вот так вижу это.
[02:11:47.080 --> 02:11:49.080]  Представьте, что до этого мы занимались
[02:11:49.080 --> 02:11:51.080]  только пропозициональной.
[02:11:51.080 --> 02:11:53.080]  Вот теперь у нас появляются квантеры.
[02:11:53.080 --> 02:11:55.080]  Шаблоны это в некотором смысле квантеры.
[02:11:55.080 --> 02:11:57.080]  То есть я сейчас скажу.
[02:11:57.080 --> 02:11:59.080]  Для всех типов t, а дальше буду определять
[02:11:59.080 --> 02:12:01.080]  вот типа нечто,
[02:12:01.080 --> 02:12:03.080]  где t это будет такая метапеременная.
[02:12:03.080 --> 02:12:05.080]  А t по кодестайлу называется?
[02:12:05.080 --> 02:12:07.080]  А?
[02:12:07.080 --> 02:12:09.080]  Для всех типов t называют t.
[02:12:09.080 --> 02:12:11.080]  Значит, пишется это следующим образом.
[02:12:11.080 --> 02:12:13.080]  Template, шаблон, это, собственно, префикс.
[02:12:13.080 --> 02:12:15.080]  Это как бы...
[02:12:15.080 --> 02:12:17.080]  Это как квантер такой типа.
[02:12:17.080 --> 02:12:19.080]  Для всех, а дальше в угловых скобочках чего?
[02:12:19.080 --> 02:12:21.080]  Type name t.
[02:12:21.080 --> 02:12:23.080]  А дальше
[02:12:23.080 --> 02:12:25.080]  я определяю функцию.
[02:12:25.080 --> 02:12:27.080]  Ну, или объявляю функцию.
[02:12:27.080 --> 02:12:29.080]  Я говорю t max tx ty.
[02:12:33.080 --> 02:12:35.080]  Теперь мне это уже не нужно.
[02:12:35.080 --> 02:12:37.080]  Для одного типа, наверное, лучше по ссылке принимать.
[02:12:37.080 --> 02:12:39.080]  Да.
[02:12:39.080 --> 02:12:41.080]  Сейчас я для всех типов t определил функцию,
[02:12:41.080 --> 02:12:43.080]  которая вот так работает
[02:12:43.080 --> 02:12:45.080]  и по значению принимает два типа.
[02:12:45.080 --> 02:12:47.080]  Я могу то же самое
[02:12:47.080 --> 02:12:49.080]  написать
[02:12:49.080 --> 02:12:51.080]  здесь.
[02:12:51.080 --> 02:12:53.080]  Template type name t.
[02:12:53.080 --> 02:12:55.080]  Type name t.
[02:12:55.080 --> 02:12:57.080]  Да что ж такое.
[02:12:57.080 --> 02:12:59.080]  И
[02:12:59.080 --> 02:13:01.080]  вот
[02:13:01.080 --> 02:13:03.080]  когда я написал этот шаблонный префикс
[02:13:03.080 --> 02:13:05.080]  И внутри t тогда.
[02:13:05.080 --> 02:13:07.080]  На объявлении определения этой функции
[02:13:07.080 --> 02:13:09.080]  распространяется, что t
[02:13:09.080 --> 02:13:11.080]  это некоторый произвольный тип.
[02:13:11.080 --> 02:13:13.080]  Для каждой функции нужно отдельно писать?
[02:13:13.080 --> 02:13:15.080]  Конечно.
[02:13:15.080 --> 02:13:17.080]  А на сколько произвольный?
[02:13:17.080 --> 02:13:19.080]  Произвольный вообще.
[02:13:19.080 --> 02:13:21.080]  То есть я могу туда подать, например
[02:13:21.080 --> 02:13:23.080]  Вектор мапов из сетов
[02:13:23.080 --> 02:13:25.080]  Что угодно.
[02:13:25.080 --> 02:13:27.080]  Воспринимайте это вот опять
[02:13:27.080 --> 02:13:29.080]  Я вам аналогии с математикой
[02:13:29.080 --> 02:13:31.080]  Мапки мне на чем угодно определенно?
[02:13:31.080 --> 02:13:33.080]  Да, воспринимайте
[02:13:33.080 --> 02:13:35.080]  Да, воспринимайте это как
[02:13:35.080 --> 02:13:37.080]  Как такой типа
[02:13:37.080 --> 02:13:39.080]  Квантор. Я говорю для всех типов t
[02:13:39.080 --> 02:13:41.080]  А дальше определяю.
[02:13:41.080 --> 02:13:43.080]  Но разумеется я могу
[02:13:45.080 --> 02:13:47.080]  Существуют типы для которых не определено сравнение
[02:13:47.080 --> 02:13:49.080]  Например давайте я заведу
[02:13:49.080 --> 02:13:51.080]  Структуру s
[02:13:51.080 --> 02:13:53.080]  Для которой вообще ничего не определено
[02:13:53.080 --> 02:13:55.080]  И заведу
[02:13:55.080 --> 02:13:57.080]  Там
[02:13:57.080 --> 02:13:59.080]  Два объекта этой структуры
[02:13:59.080 --> 02:14:01.080]  И попытаюсь вызвать максимум от s1
[02:14:01.080 --> 02:14:03.080]  С2
[02:14:03.080 --> 02:14:05.080]  Конечно же это будет ce
[02:14:05.080 --> 02:14:07.080]  А как это произойдет?
[02:14:07.080 --> 02:14:09.080]  А компилятор
[02:14:09.080 --> 02:14:11.080]  Когда я вызываю шаблонную функцию
[02:14:11.080 --> 02:14:13.080]  Да, вот это называется шаблон
[02:14:13.080 --> 02:14:15.080]  То есть это не определение функции
[02:14:15.080 --> 02:14:17.080]  Это определение шаблона
[02:14:17.080 --> 02:14:19.080]  Когда я вызываю в коде шаблонную функцию
[02:14:19.080 --> 02:14:21.080]  Компилятор
[02:14:21.080 --> 02:14:23.080]  Делает подстановку шаблонную
[02:14:25.080 --> 02:14:27.080]  Это еще называется
[02:14:27.080 --> 02:14:29.080]  Инстанцирование
[02:14:29.080 --> 02:14:31.080]  Судя по номеру
[02:14:31.080 --> 02:14:33.080]  Мне пытаются опять что-то предложить
[02:14:33.080 --> 02:14:35.080]  В кредит
[02:14:35.080 --> 02:14:37.080]  Звонят мошенники
[02:14:47.080 --> 02:14:49.080]  Так
[02:14:49.080 --> 02:14:51.080]  Спокойно
[02:14:51.080 --> 02:14:53.080]  Чего?
[02:14:55.080 --> 02:14:57.080]  Конечно можешь
[02:14:57.080 --> 02:14:59.080]  Но это долгий разговор
[02:14:59.080 --> 02:15:01.080]  Это мы будем во втором семестре обсуждать
[02:15:01.080 --> 02:15:03.080]  Пока не будем этим заниматься
[02:15:03.080 --> 02:15:05.080]  Илья, ты микрофон не надел, да?
[02:15:05.080 --> 02:15:07.080]  Не надел, да
[02:15:11.080 --> 02:15:13.080]  Так
[02:15:13.080 --> 02:15:15.080]  Тихо, что за вопрос?
[02:15:19.080 --> 02:15:21.080]  Это мы сейчас
[02:15:21.080 --> 02:15:23.080]  Обсудим в пункте 6.2
[02:15:23.080 --> 02:15:25.080]  Пока что я базовые примеры показываю
[02:15:25.080 --> 02:15:27.080]  Сейчас мы обсудим
[02:15:27.080 --> 02:15:29.080]  Как работает перегрузка при наличии шаблонов
[02:15:29.080 --> 02:15:31.080]  Но пока что вот
[02:15:31.080 --> 02:15:33.080]  Я вызываю шаблонную функцию
[02:15:33.080 --> 02:15:35.080]  От двух аргументов
[02:15:35.080 --> 02:15:37.080]  Компилятор делает так называемую шаблонную подстановку
[02:15:37.080 --> 02:15:39.080]  И он
[02:15:39.080 --> 02:15:41.080]  По переданным аргументам
[02:15:41.080 --> 02:15:43.080]  Делает
[02:15:43.080 --> 02:15:45.080]  Так называемый
[02:15:45.080 --> 02:15:47.080]  Type deduction
[02:15:51.080 --> 02:15:53.080]  Вывод типа
[02:15:53.080 --> 02:15:55.080]  Разных типов могут конечно
[02:15:55.080 --> 02:15:57.080]  Вот
[02:15:57.080 --> 02:15:59.080]  Он делает вывод типа
[02:15:59.080 --> 02:16:01.080]  Что такое вывод типа?
[02:16:01.080 --> 02:16:03.080]  Он просто смотрит, какой тип я передал
[02:16:03.080 --> 02:16:05.080]  И подставляет t такой
[02:16:05.080 --> 02:16:07.080]  Вот
[02:16:07.080 --> 02:16:09.080]  А если мы ему передадим
[02:16:09.080 --> 02:16:11.080]  Допустим, int и long-long
[02:16:11.080 --> 02:16:13.080]  Вот, если мы ему передадим два разных типа
[02:16:13.080 --> 02:16:15.080]  То он не сможет понять, какой подставить
[02:16:15.080 --> 02:16:17.080]  И будет ce
[02:16:17.080 --> 02:16:19.080]  Значит, ну давайте я
[02:16:19.080 --> 02:16:21.080]  Для начала, что будет
[02:16:21.080 --> 02:16:23.080]  Если не определен этот оператор
[02:16:23.080 --> 02:16:25.080]  Ну сейчас будет просто ce
[02:16:25.080 --> 02:16:27.080]  Не то я скомпилировал
[02:16:27.080 --> 02:16:29.080]  Template
[02:16:29.080 --> 02:16:31.080]  Cpp
[02:16:31.080 --> 02:16:33.080]  Вот
[02:16:33.080 --> 02:16:35.080]  Ну
[02:16:35.080 --> 02:16:37.080]  Вот
[02:16:37.080 --> 02:16:39.080]  Ошибки компиляции в шаблонах начинаются
[02:16:39.080 --> 02:16:41.080]  О, как вы это полюбите
[02:16:41.080 --> 02:16:43.080]  Больше, чем discards qualifiers
[02:16:43.080 --> 02:16:45.080]  Значит
[02:16:45.080 --> 02:16:47.080]  Вот это вот начало
[02:16:47.080 --> 02:16:49.080]  Обычно с этих слов начинаются
[02:16:49.080 --> 02:16:51.080]  Очень длинные и сложные
[02:16:51.080 --> 02:16:53.080]  Неприятные
[02:16:53.080 --> 02:16:55.080]  Тексты
[02:16:55.080 --> 02:16:57.080]  Значит
[02:16:57.080 --> 02:16:59.080]  Что-то required from here
[02:16:59.080 --> 02:17:01.080]  Ну это означает, что
[02:17:01.080 --> 02:17:03.080]  Да
[02:17:03.080 --> 02:17:05.080]  In instantiation
[02:17:05.080 --> 02:17:07.080]  То есть в инстанцировании
[02:17:07.080 --> 02:17:09.080]  Инстанцирование это, когда
[02:17:09.080 --> 02:17:11.080]  В шаблонную функцию подставляются конкретные типы
[02:17:11.080 --> 02:17:13.080]  Инстанцирование шаблона
[02:17:13.080 --> 02:17:15.080]  Это как раз процесс подстановки конкретных типов
[02:17:15.080 --> 02:17:17.080]  В шаблонную функцию
[02:17:17.080 --> 02:17:19.080]  В инстанцировании
[02:17:19.080 --> 02:17:21.080]  Вот этого вот
[02:17:21.080 --> 02:17:23.080]  С t равным c
[02:17:23.080 --> 02:17:25.080]  Required from here
[02:17:25.080 --> 02:17:27.080]  Востребованным здесь
[02:17:27.080 --> 02:17:29.080]  Показано где? В строке такой-то
[02:17:29.080 --> 02:17:31.080]  Вот отсюда запрошено
[02:17:31.080 --> 02:17:33.080]  Возникла ошибка
[02:17:33.080 --> 02:17:35.080]  Но match for operator больше
[02:17:35.080 --> 02:17:37.080]  Вот
[02:17:37.080 --> 02:17:39.080]  И это первое, что может произойти
[02:17:39.080 --> 02:17:41.080]  Второе, что может произойти
[02:17:41.080 --> 02:17:43.080]  Давайте я передам
[02:17:43.080 --> 02:17:45.080]  Допустим int и double
[02:17:45.080 --> 02:17:47.080]  А сейчас уже строки подписаны там
[02:17:47.080 --> 02:17:49.080]  Нет
[02:17:49.080 --> 02:17:51.080]  У меня не включена нумерация строк
[02:17:51.080 --> 02:17:53.080]  К сожалению
[02:17:53.080 --> 02:17:55.080]  Другая
[02:17:55.080 --> 02:17:57.080]  Другая ошибка
[02:17:57.080 --> 02:17:59.080]  Я передал int и double
[02:17:59.080 --> 02:18:01.080]  Компилятор озадачен
[02:18:01.080 --> 02:18:03.080]  Он сказал
[02:18:03.080 --> 02:18:05.080]  No matching function for call
[02:18:05.080 --> 02:18:07.080]  Потому что
[02:18:07.080 --> 02:18:09.080]  Вот этот кандидат не подошел
[02:18:09.080 --> 02:18:11.080]  Потому что
[02:18:11.080 --> 02:18:13.080]  Template argument deduction substitution failed
[02:18:13.080 --> 02:18:15.080]  Did use conflicting types for parameter t
[02:18:15.080 --> 02:18:17.080]  Вот он не смог понять
[02:18:17.080 --> 02:18:19.080]  Какой tab отставить
[02:18:19.080 --> 02:18:21.080]  Поэтому возникла ошибка
[02:18:21.080 --> 02:18:23.080]  Конечно я могу
[02:18:23.080 --> 02:18:25.080]  Разные сделать
[02:18:25.080 --> 02:18:27.080]  Типы
[02:18:27.080 --> 02:18:29.080]  Ну например я могу сказать
[02:18:29.080 --> 02:18:31.080]  t, x, u, y
[02:18:31.080 --> 02:18:33.080]  И тогда мне нужен здесь
[02:18:33.080 --> 02:18:35.080]  Второй шаблонный параметр
[02:18:35.080 --> 02:18:37.080]  Правда вопрос что я тогда должен
[02:18:37.080 --> 02:18:39.080]  Возвращать хороший
[02:18:39.080 --> 02:18:41.080]  Можно писать auto
[02:18:41.080 --> 02:18:43.080]  Но формально говоря мы с вами еще не проходили
[02:18:43.080 --> 02:18:45.080]  Auto
[02:18:45.080 --> 02:18:47.080]  Нельзя же в конструкции писать
[02:18:47.080 --> 02:18:49.080]  Конструкцию которая возвращает разные типы
[02:18:49.080 --> 02:18:51.080]  Можно если типы
[02:18:51.080 --> 02:18:53.080]  Мы с вами уже так делали
[02:18:53.080 --> 02:18:55.080]  Когда у нас был base и derived
[02:18:55.080 --> 02:18:57.080]  Можно если общий тип
[02:18:57.080 --> 02:18:59.080]  Для них однозначно выводится
[02:18:59.080 --> 02:19:01.080]  Например для int и double
[02:19:01.080 --> 02:19:03.080]  Общим будет double
[02:19:03.080 --> 02:19:05.080]  А для base и derived
[02:19:05.080 --> 02:19:07.080]  Общим будет base
[02:19:07.080 --> 02:19:09.080]  Как передать общий тип
[02:19:09.080 --> 02:19:11.080]  Или как вот у меня есть int
[02:19:11.080 --> 02:19:13.080]  И есть double
[02:19:13.080 --> 02:19:15.080]  Я не буду пока auto
[02:19:15.080 --> 02:19:17.080]  Чтобы лишних не создавать вопросов
[02:19:17.080 --> 02:19:19.080]  Сейчас у меня будет
[02:19:19.080 --> 02:19:21.080]  t равно int
[02:19:21.080 --> 02:19:23.080]  u равно double
[02:19:23.080 --> 02:19:25.080]  И это выражение будет пытаться
[02:19:25.080 --> 02:19:27.080]  Привестись к double
[02:19:27.080 --> 02:19:29.080]  Но это получится
[02:19:29.080 --> 02:19:31.080]  Все нормально сработает
[02:19:31.080 --> 02:19:33.080]  Что?
[02:19:33.080 --> 02:19:35.080]  Сейчас вот это
[02:19:35.080 --> 02:19:37.080]  Привелось к double
[02:19:37.080 --> 02:19:39.080]  Но оно и так бы привелось к double
[02:19:39.080 --> 02:19:41.080]  Типа то выражение и так double
[02:19:41.080 --> 02:19:43.080]  t равно int
[02:19:43.080 --> 02:19:45.080]  u равно double
[02:19:45.080 --> 02:19:47.080]  Так
[02:19:47.080 --> 02:19:49.080]  Следующий вопрос
[02:19:49.080 --> 02:19:51.080]  Я не могу определить
[02:19:51.080 --> 02:19:53.080]  Что принимаешь по копии
[02:19:53.080 --> 02:19:55.080]  А для строк
[02:19:55.080 --> 02:19:57.080]  Можешь
[02:19:57.080 --> 02:19:59.080]  Можешь
[02:19:59.080 --> 02:20:01.080]  Все ты можешь
[02:20:01.080 --> 02:20:03.080]  Надо только
[02:20:03.080 --> 02:20:05.080]  Дождаться
[02:20:05.080 --> 02:20:07.080]  Второго семестра
[02:20:07.080 --> 02:20:09.080]  Ну значит на самом деле
[02:20:09.080 --> 02:20:11.080]  Шаблоны
[02:20:11.080 --> 02:20:13.080]  Давайте я вам такой тоже небольшой спойлер кину
[02:20:13.080 --> 02:20:15.080]  Есть такая
[02:20:15.080 --> 02:20:17.080]  Вот знаете есть такая огромная толстая книжка
[02:20:17.080 --> 02:20:19.080]  Язык программирования C++
[02:20:19.080 --> 02:20:21.080]  Да авторство
[02:20:21.080 --> 02:20:23.080]  Бьерн Страус
[02:20:23.080 --> 02:20:25.080]  1500 страниц
[02:20:25.080 --> 02:20:27.080]  Есть другая замечательная книжка
[02:20:27.080 --> 02:20:29.080]  Называется шаблоны C++
[02:20:29.080 --> 02:20:31.080]  Она примерно такая же по толщине
[02:20:31.080 --> 02:20:33.080]  Ну короче шаблоны
[02:20:33.080 --> 02:20:35.080]  Это настолько огромная тема
[02:20:35.080 --> 02:20:37.080]  Что примерно можно
[02:20:37.080 --> 02:20:39.080]  Изучать ее
[02:20:39.080 --> 02:20:41.080]  Полгода и даже год
[02:20:41.080 --> 02:20:43.080]  И
[02:20:43.080 --> 02:20:45.080]  На самом деле шаблоны
[02:20:45.080 --> 02:20:47.080]  Это отдельный язык в языке
[02:20:47.080 --> 02:20:49.080]  Мы с вами в этом семестре
[02:20:49.080 --> 02:20:51.080]  Только за хвостик слона трогаем
[02:20:51.080 --> 02:20:53.080]  И в следующем семестре
[02:20:53.080 --> 02:20:55.080]  У нас будет много веселых интересных приключений
[02:20:55.080 --> 02:20:57.080]  Связанных с шаблонами
[02:20:57.080 --> 02:20:59.080]  Вот пока что
[02:20:59.080 --> 02:21:01.080]  Мы только только с ними знакомимся
[02:21:01.080 --> 02:21:03.080]  Шаблоны вы меня спрашивали какая тема шире
[02:21:03.080 --> 02:21:05.080]  Шаблоны или виртуальные функции
[02:21:05.080 --> 02:21:07.080]  Шаблоны раз в сто шире темы чем виртуальные функции
[02:21:07.080 --> 02:21:09.080]  Вы вскоре осознаете
[02:21:09.080 --> 02:21:11.080]  Бездну которая нам предстоит
[02:21:11.080 --> 02:21:13.080]  Вот
[02:21:13.080 --> 02:21:15.080]  Но пока мы только только начинаем
[02:21:15.080 --> 02:21:17.080]  Вы страшное слово вспоминаете
[02:21:17.080 --> 02:21:19.080]  Разумеется
[02:21:19.080 --> 02:21:21.080]  И концепты будут
[02:21:21.080 --> 02:21:23.080]  И констрейнты
[02:21:23.080 --> 02:21:25.080]  И в общем да
[02:21:25.080 --> 02:21:27.080]  Если мы функцию max передадим double int
[02:21:27.080 --> 02:21:29.080]  То он попробует вернуть int
[02:21:29.080 --> 02:21:31.080]  Да и у него тоже получится
[02:21:31.080 --> 02:21:33.080]  Потому что double же конвертируется в int не явно
[02:21:33.080 --> 02:21:35.080]  Мы потеряем после запятой
[02:21:35.080 --> 02:21:37.080]  Да потеряем
[02:21:37.080 --> 02:21:39.080]  Вот дальше
[02:21:43.080 --> 02:21:45.080]  Я показал шаблоны функции
[02:21:45.080 --> 02:21:47.080]  Еще бывают шаблоны
[02:21:47.080 --> 02:21:49.080]  Ну бывают шаблоны не только функции
[02:21:49.080 --> 02:21:51.080]  Я на самом деле почти любое объявление
[02:21:51.080 --> 02:21:53.080]  Бывают шаблоны классов
[02:21:53.080 --> 02:21:55.080]  Например
[02:21:55.080 --> 02:21:57.080]  Template
[02:21:57.080 --> 02:21:59.080]  Type name
[02:21:59.080 --> 02:22:01.080]  T
[02:22:01.080 --> 02:22:03.080]  Class
[02:22:03.080 --> 02:22:05.080]  Вектор
[02:22:05.080 --> 02:22:07.080]  Как вам такое
[02:22:07.080 --> 02:22:09.080]  Ну вектор
[02:22:09.080 --> 02:22:11.080]  Это же на самом деле шаблон
[02:22:11.080 --> 02:22:13.080]  Правда
[02:22:13.080 --> 02:22:15.080]  У него какие поля
[02:22:15.080 --> 02:22:17.080]  У вектора
[02:22:17.080 --> 02:22:19.080]  У него указатель на вот этот массив
[02:22:19.080 --> 02:22:21.080]  У него указатель на вот этот массив
[02:22:21.080 --> 02:22:23.080]  Что такое вектор
[02:22:23.080 --> 02:22:25.080]  Ну это в каком то смысле обобщенная строка же
[02:22:25.080 --> 02:22:27.080]  Осознайте это
[02:22:27.080 --> 02:22:29.080]  У нас с вами строка
[02:22:29.080 --> 02:22:31.080]  Эта штука которая хранит массив чаров
[02:22:31.080 --> 02:22:33.080]  Сайз и капейсити
[02:22:33.080 --> 02:22:35.080]  Ну вектор это же в каком то смысле обобщенная строка
[02:22:35.080 --> 02:22:37.080]  Он хранит указатель на T
[02:22:37.080 --> 02:22:39.080]  Массив
[02:22:39.080 --> 02:22:47.080]  Ну и сайз ç Z и c
[02:22:47.080 --> 02:22:48.920]  Вот КОНЕЧНО
[02:22:48.920 --> 02:22:50.920]  Я могу на мытке d навешивать
[02:22:50.920 --> 02:22:55.080]  модификаторы, то есть если я хочу, чтобы у меня не по значению, а по ссылке
[02:22:55.080 --> 02:23:00.320]  принималось, я могу вот так писать, конечно. Вот здесь я принимаю по обычной ссылке,
[02:23:00.320 --> 02:23:05.360]  вот сюда я могу принимать по константной ссылке. Конечно же, это все сохраняется, то есть
[02:23:05.360 --> 02:23:08.480]  если вы хотите в шаблонную функцию что-то принимать по константной ссылке, то
[02:23:08.480 --> 02:23:12.540]  пожалуйста, пишите const . Вот здесь я пишу t звездочка, и это будет
[02:23:12.540 --> 02:23:16.700]  указатель на t. Так выглядят, собственно, поля класса вектор. Ну, на самом деле, там
[02:23:16.700 --> 02:23:23.060]  есть еще кое-что, но пока мы об этом умалчиваем. Вот. Ну, по сути, все
[02:23:23.060 --> 02:23:30.320]  контейнеры, вектор, дек, мэп, анортерт мэп, это шаблоны. Если вы вспомните, есть такая
[02:23:30.320 --> 02:23:38.020]  аббревиатура STL. Standard Template Library.
[02:23:38.020 --> 02:23:43.280]  Это вот как раз все то, вся та библиотека, в которой включен вектор, вот это
[02:23:43.280 --> 02:23:46.480]  все. Почему он называется так? Ну, потому что это стандартная библиотека шаблонов.
[02:23:46.480 --> 02:23:53.320]  Это библиотека не классов, а шаблонов классов. Все ваши контейнеры на самом
[02:23:53.320 --> 02:23:58.360]  деле шаблоны. И надо понимать, что как всякий раз, когда вы в своей программе
[02:23:58.360 --> 02:24:02.660]  выбираете вектор int, происходит шаблонная подстановка. Компилятор
[02:24:02.660 --> 02:24:12.080]  генерирует полностью определение вектор int из шаблона вектора. Вектор int и
[02:24:12.080 --> 02:24:15.360]  вектор double это два разных класса абсолютно, никак друг с другом не
[02:24:15.360 --> 02:24:15.880]  связанных.
[02:24:16.480 --> 02:24:23.300]  У вас в одном случае происходит подстановка int, t равного int, в другом случае
[02:24:23.300 --> 02:24:27.860]  подстановка t равного double. И это абсолютно два разных типа, с полностью
[02:24:27.860 --> 02:24:32.360]  разным кодом. С точки зрения компилятора он разный. Компилятор просто генерирует
[02:24:32.360 --> 02:24:36.240]  этот код, когда вы подставляете. Компилятор на самом деле совершает
[02:24:36.240 --> 02:24:40.580]  генерацию кода, когда вы используете шаблоны. Когда вы упоминаете шаблон с
[02:24:40.580 --> 02:24:44.120]  конкретным типом, происходит инстанцирование или type deduction,
[02:24:46.480 --> 02:24:52.980]  получается настоящий код, и у вас возникает реальный экземпляр класса с
[02:24:52.980 --> 02:25:00.200]  подставленным t. Если подставить и другой, то это будет другой класс. Вот. Что еще
[02:25:00.200 --> 02:25:10.540]  может быть шаблонным? Может быть шаблонный псевдоним. Я могу написать
[02:25:10.540 --> 02:25:16.340]  ну скажем
[02:25:16.480 --> 02:25:28.420]  не знаю, mymap. Это будет std map от t, запятая t. Ну, то есть я могу, допустим, мне
[02:25:28.420 --> 02:25:34.620]  лень каждый раз какую-то длинную шаблонную конструкцию с упоминанием t
[02:25:34.620 --> 02:25:45.180]  писать. О, я знаю. Давайте я скажу так. Это будет std вектор t итератор.
[02:25:45.180 --> 02:25:46.180]  Как?
[02:25:46.480 --> 02:25:55.200]  Что именно? Ну, тип из большой буквы надо писать, но так можно вообще, да.
[02:25:55.200 --> 02:26:04.460]  Можно, да. Вот. Я сейчас объявил шаблонный тип итер и сказал, что он равен
[02:26:04.460 --> 02:26:11.900]  итератору вектора. Теперь я могу писать итер с шаблонным параметром int, и это
[02:26:11.900 --> 02:26:16.320]  будет означать вектор int, двоеточие, дветочие, итератор.
[02:26:16.480 --> 02:26:18.740]  Что среди приоритетов вы заинклюзили?
[02:26:18.740 --> 02:26:21.200]  Чего?
[02:26:21.200 --> 02:26:25.160]  Что среди приоритетов вы заинклюзили, чтобы итератор был?
[02:26:25.160 --> 02:26:26.160]  А можно...
[02:26:26.160 --> 02:26:31.080]  я ничего не заинклюзил, итератор внутри вектора определён. Мне нужно вектор заинклюзить на самом
[02:26:31.080 --> 02:26:32.480]  деле, чтобы это работало.
[02:26:32.480 --> 02:26:45.400]  Сейчас, Илья, а можно сделать так, что он... мы, допустим писали итератор и тип, и он нам по этому... ну, итер и тип, и поэтому он возвращал нам итератор?
[02:26:45.400 --> 02:26:46.520]  итератор
[02:26:46.520 --> 02:26:47.520]  конкретного типа
[02:26:47.520 --> 02:26:50.080]  что такое итератор конкретного типа
[02:26:50.080 --> 02:26:52.820]  допустим, у нас же есть map, set, вектор
[02:26:52.820 --> 02:26:55.540]  так, нет, нет, нет, нет, все, ты сейчас меня
[02:26:55.540 --> 02:26:57.080]  заставишь рассказывать тебе, как устроены
[02:26:57.080 --> 02:26:58.800]  итераторы, это я сейчас не буду делать
[02:26:58.800 --> 02:27:00.660]  пока что я просто рассказал, как писать
[02:27:00.660 --> 02:27:01.760]  шаблонные юзинги
[02:27:01.760 --> 02:27:04.120]  вот я могу написать template type name t
[02:27:04.120 --> 02:27:05.980]  юзинг какой-то тип равно и дальше что-то
[02:27:05.980 --> 02:27:07.360]  содержащее t
[02:27:07.360 --> 02:27:09.360]  и теперь я могу писать в любом месте
[02:27:09.360 --> 02:27:11.900]  итер, допустим, вот int
[02:27:11.900 --> 02:27:13.640]  ну не знаю, it
[02:27:13.640 --> 02:27:14.740]  вот я объявил
[02:27:14.740 --> 02:27:16.940]  и это будет означать, это просто сокращенное
[02:27:16.940 --> 02:27:18.420]  название типа придумал
[02:27:18.420 --> 02:27:20.460]  с упоминанием t, понятно?
[02:27:20.720 --> 02:27:23.260]  да, почему ты в скобочках таких пишешь?
[02:27:23.420 --> 02:27:25.160]  потому что t это шаблонный
[02:27:25.160 --> 02:27:26.740]  параметр типа итер теперь
[02:27:26.740 --> 02:27:28.540]  просто итер
[02:27:28.540 --> 02:27:31.020]  это шаблонный тип, мне нужно уточнить
[02:27:31.020 --> 02:27:31.980]  от чего итер
[02:27:31.980 --> 02:27:35.780]  непонятно?
[02:27:37.060 --> 02:27:38.900]  ну потому что итератор
[02:27:38.900 --> 02:27:40.620]  вектор по умолчанию не умеет создаваться
[02:27:40.620 --> 02:27:42.860]  о, если ты еще вот в тот template
[02:27:42.860 --> 02:27:47.180]  вот если я скажу вот так, то это будет нормально
[02:27:47.180 --> 02:27:55.880]  ой, господи, ну
[02:27:55.880 --> 02:28:01.460]  с вектором
[02:28:01.460 --> 02:28:03.460]  плохой пример
[02:28:03.460 --> 02:28:07.180]  надо написать type name здесь
[02:28:07.180 --> 02:28:09.220]  не спрашивайте почему, потом расскажу
[02:28:09.220 --> 02:28:11.640]  теперь заработает
[02:28:12.860 --> 02:28:17.380]  ну, короче
[02:28:17.380 --> 02:28:20.180]  ну плохой пример
[02:28:20.180 --> 02:28:21.740]  в общем, ну давайте я
[02:28:21.740 --> 02:28:23.340]  другой пример, вот не знаю, просто
[02:28:23.340 --> 02:28:26.060]  ну, не знаю, my map
[02:28:26.060 --> 02:28:27.800]  вот у меня был пример, это из td map
[02:28:27.800 --> 02:28:29.800]  из tft, вот так будет нормально работать
[02:28:29.800 --> 02:28:36.440]  ну я могу сказать, да, my map
[02:28:36.440 --> 02:28:37.260]  там
[02:28:37.260 --> 02:28:40.180]  там от t
[02:28:40.180 --> 02:28:42.360]  m, и это будет означать, ой, от int
[02:28:42.360 --> 02:28:42.840]  t тут, да, и это будет означать, ой, от t
[02:28:42.860 --> 02:28:44.100]  уже непонятно, что такое
[02:28:44.100 --> 02:28:46.100]  вот, и это будет означать, значит
[02:28:46.100 --> 02:28:49.620]  map из int в int
[02:28:49.620 --> 02:28:52.020]  ну это шаблонный псевдоним, короче
[02:28:52.020 --> 02:28:54.540]  вот, ну и еще можно делать шаблонные
[02:28:54.540 --> 02:28:58.540]  переменные, начиная с c++14
[02:28:58.540 --> 02:29:01.140]  сейчас, Илья, если ты еще в этот template
[02:29:01.140 --> 02:29:03.100]  допишешь еще какой-нибудь
[02:29:03.100 --> 02:29:03.980]  type name
[02:29:03.980 --> 02:29:06.280]  u, допустим, то тебе теперь нужно
[02:29:06.280 --> 02:29:07.740]  указывать два параметра, если что
[02:29:07.740 --> 02:29:10.740]  да, потому что u-то я не сказал, чему равно
[02:29:12.860 --> 02:29:14.340]  так, шаблонные переменные теперь
[02:29:14.340 --> 02:29:16.060]  что такое шаблонные переменные
[02:29:16.060 --> 02:29:18.300]  порядок совершенно не важен
[02:29:18.300 --> 02:29:20.180]  да, то есть, там можно type name
[02:29:20.180 --> 02:29:21.620]  у, именно с точки зрения
[02:29:21.620 --> 02:29:22.640]  компеллятора
[02:29:22.640 --> 02:29:24.000]  там можно type name
[02:29:24.000 --> 02:29:25.100]  в любом порядке писать
[02:29:25.100 --> 02:29:26.340]  и использовать их совершенно
[02:29:26.340 --> 02:29:27.640]  в другом тому
[02:29:27.640 --> 02:29:28.440]  ну да, конечно
[02:29:28.440 --> 02:29:30.300]  но это как и параметры
[02:29:30.300 --> 02:29:32.160]  прямо по позиции
[02:29:32.160 --> 02:29:34.980]  как и обычные параметры функции
[02:29:36.260 --> 02:29:37.700]  нет, причем тут обычные параметры
[02:29:37.700 --> 02:29:40.360]  ну, шаблонные параметры
[02:29:40.360 --> 02:29:42.100]  тебе важно в корм порядке в параметры функций
[02:29:42.100 --> 02:29:46.240]  функцию принимать. Их можно использовать в функции не в том порядке, в каком ты их
[02:29:46.240 --> 02:29:51.860]  передал. Я же говорю, как они объявлены в тимплейте, а не в функции.
[02:29:51.860 --> 02:29:55.840]  Что значит объявлены в тимплейте? В каком порядке в тимплейте их прописать?
[02:29:55.840 --> 02:30:02.680]  Кого прописать? Тимплейт typeName t, typeName u, typeName v. Это то же самое, как ты
[02:30:02.680 --> 02:30:06.700]  написал void f от int x, int y, int z. И ты меня спрашиваешь, важно ли в каком порядке
[02:30:06.700 --> 02:30:11.560]  использовать x, y, z после этого? Это абсолютно аналогичный вопрос. Это просто
[02:30:11.560 --> 02:30:16.120]  мета-вопрос. Это типа, а что ты имел ввиду? Ну неважно, ладно, в любом порядке
[02:30:16.120 --> 02:30:19.300]  можно использовать. Шаблонные переменные. Я могу, например,
[02:30:19.300 --> 02:30:21.900]  сказать
[02:30:30.920 --> 02:30:39.760]  ну, не знаю, const double p.
[02:30:41.560 --> 02:30:48.420]  Число, оно равно... Ну, тут, видите ли, в чем проблема, тут трудно объяснить.
[02:30:48.440 --> 02:30:53.400]  Пример, когда это может быть нужно. Ну, я могу, например, сказать так, это, допустим.
[02:30:53.400 --> 02:30:57.620]  Я могу, например сказать так, это, допустим, какая-нибудь функция
[02:30:57.620 --> 02:30:58.600]  с шаблонным параметром
[02:30:58.600 --> 02:31:02.160]  вызванная от чего-нибудь.
[02:31:02.160 --> 02:31:05.840]  Мне трудно вообще привести практический пример, просто запомните, что можно
[02:31:05.840 --> 02:31:11.300]  Параметризавать... um... просто параметризовать шаблонный... Просто можно параметризовать... 516 00R rapports,
[02:31:11.300 --> 02:31:15.960]  проинвестировать типами переменные. Можно сказать const double p, и когда вы потом
[02:31:15.960 --> 02:31:21.900]  будете использовать ее, вы можете сказать p от чего-то, например. И в зависимости от
[02:31:21.900 --> 02:31:26.600]  того, какой тип, она будет равна разному. Но я лучше сейчас не буду вам примеры
[02:31:26.600 --> 02:31:29.300]  показывать, это пока трудно мотивировать.
[02:31:29.300 --> 02:31:31.300]  Сейчас оно фактически как будет? Как функция работает?
[02:31:31.300 --> 02:31:35.300]  Нет, это будет переменная. Константная просто.
[02:31:35.300 --> 02:31:42.300]  Можно написать const double p, а справа равно и какой-то, в зависимости от t, что-то разное.
[02:31:42.300 --> 02:31:44.300]  Именно констант.
[02:31:44.300 --> 02:31:54.300]  Ну, обычно это для констант делается, но это нельзя сделать для неконстант, потому что
[02:31:54.300 --> 02:31:59.300]  не константу, потому что должно быть в compile-time уже понятно, чему равно.
[02:31:59.300 --> 02:32:01.300]  Да, поэтому константы только, да.
[02:32:01.300 --> 02:32:03.300]  Сейчас это как глобальная переменная?
[02:32:03.300 --> 02:32:05.300]  Ну, это будет глобальная в моем случае переменная.
[02:32:05.300 --> 02:32:08.300]  А если в мейне нельзя это написать?
[02:32:08.300 --> 02:32:11.300]  В мейне нет, нельзя внутри функции объявлять шаблоны.
[02:32:11.300 --> 02:32:16.300]  А я могу функции приписывать с треугольной скобки?
[02:32:16.300 --> 02:32:18.300]  Можешь, сейчас про это поговорим.
[02:32:18.300 --> 02:32:27.300]  Так, шаблоны, итого, шаблонами могут быть классы, функции, юзинги, переменные и еще
[02:32:27.300 --> 02:32:31.300]  концепты, но это совсем сложно, и об этом мы поговорим только в мае.
[02:32:31.300 --> 02:32:33.300]  Сейчас, еще раз, почему мы в мейне не можем что-то делать?
[02:32:33.300 --> 02:32:35.300]  Потому что так решается.
[02:32:35.300 --> 02:32:37.300]  Это решил комитет по стандартизации.
[02:32:37.300 --> 02:32:38.300]  Только мейн.
[02:32:38.300 --> 02:32:44.300]  Нет, мейн, ты можешь шаблонизировать мейн, но я, кстати, не знаю, можно ли шаблонизировать мейн.
[02:32:44.300 --> 02:32:52.300]  Я никогда не пробовал, я говорил не об этом, я говорил, что шаблоны, может, только, нельзя шаблоны внутри функции объявлять.
[02:32:52.300 --> 02:32:54.300]  Саму мейн, может, и можно.
[02:32:54.300 --> 02:32:55.300]  Почему нужно мейн шаблонизировать?
[02:32:55.300 --> 02:32:57.300]  Я не знаю, попробуйте.
[02:32:57.300 --> 02:32:58.300]  Что шаблоны?
[02:32:58.300 --> 02:32:59.300]  Ну, мы же возвращаем...
[02:32:59.300 --> 02:33:04.300]  Шаблоны можно объявлять только в области глобальной, внутри функции.
[02:33:04.300 --> 02:33:12.300]  Можно, кстати, в классе объявить шаблонный метод, параметризованный другим типом.
[02:33:12.300 --> 02:33:21.300]  Например, template typeName u void f от какого-нибудь u.
[02:33:21.300 --> 02:33:23.300]  Ну и что-то он будет делать.
[02:33:23.300 --> 02:33:25.300]  Мейн нельзя объявить шаблонным.
[02:33:25.300 --> 02:33:28.300]  Мейн нельзя? Ну, я не удивлен.
[02:33:28.300 --> 02:33:29.300]  Вот.
[02:33:29.300 --> 02:33:32.300]  Посмотрите, пожалуйста.
[02:33:32.300 --> 02:33:34.300]  Я внутри класса вектор.
[02:33:34.300 --> 02:33:36.300]  Ну, это, конечно, не вектор.
[02:33:36.300 --> 02:33:43.300]  Я внутри класса вектор, который сам шаблонный объявил шаблонный метод f.
[02:33:43.300 --> 02:33:46.300]  Это шаблонный метод внутри шаблонного класса.
[02:33:46.300 --> 02:33:51.300]  Если я теперь захочу этот метод вызвать...
[02:33:51.300 --> 02:33:52.300]  О, виноват.
[02:33:52.300 --> 02:33:59.300]  Если я хочу этот метод определить, я его объявил только, мне придется два раза написать шаблонный префикс.
[02:33:59.300 --> 02:34:01.300]  Мне придется писать template typeName t.
[02:34:02.300 --> 02:34:05.300]  А потом template typeName u.
[02:34:05.300 --> 02:34:10.300]  Потом вектор от t, двоеточие, двоеточие, f.
[02:34:10.300 --> 02:34:12.300]  Ну и после этого определять его.
[02:34:12.300 --> 02:34:13.300]  От u.
[02:34:13.300 --> 02:34:14.300]  Да.
[02:34:14.300 --> 02:34:17.300]  Нет, f уже не надо писать от чего.
[02:34:17.300 --> 02:34:20.300]  Там, не знаю, std, cout.
[02:34:20.300 --> 02:34:23.300]  Чего-нибудь один.
[02:34:23.300 --> 02:34:26.300]  Блин, а почему тогда template от тобой писан?
[02:34:26.300 --> 02:34:28.300]  Потому что это шаблон внутри шаблона.
[02:34:28.300 --> 02:34:31.300]  Это совсем не то же самое, что шаблон с двумя параметрами.
[02:34:31.300 --> 02:34:35.300]  Это шаблон с одним параметром, внутри шаблона с одним параметром.
[02:34:36.300 --> 02:34:40.300]  У меня внутри шаблонного класса есть шаблонный метод.
[02:34:40.300 --> 02:34:43.300]  У них разные параметры.
[02:34:44.300 --> 02:34:53.300]  И мне нужно, когда я определяю этот метод, написать шаблонный префикс класса отдельно, шаблонный префикс метода отдельно.
[02:34:53.300 --> 02:34:55.300]  Так дело в том, что у них области действия разные.
[02:34:55.300 --> 02:34:56.300]  Да.
[02:34:56.300 --> 02:35:00.300]  t распространяется на весь вектор, а u распространяется только на этот метод.
[02:35:01.300 --> 02:35:03.300]  Можешь уже скомпилировать это.
[02:35:04.240 --> 02:35:10.160]  Нет, это скорее всего не скомпилируется, потому что я там кучу всего где-то налажал. Ну вот, например, по этому.
[02:35:13.040 --> 02:35:18.740]  Да, да, например, потому что я void забыл вот здесь. Здесь надо было написать void.
[02:35:23.320 --> 02:35:25.320]  Ну, только с мэпом проблемы остались.
