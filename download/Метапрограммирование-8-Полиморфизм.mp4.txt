[00:00.000 --> 00:05.000]  Поднимите руку, кто ассоциирует полиморфизм с одним из китов ООП.
[00:05.000 --> 00:08.000]  Ну так вот, говорят в вакууме, полиморфизм. Первая мысль.
[00:08.000 --> 00:12.000]  Есть большой вопрос, что вы будете взяли под ООП.
[00:12.000 --> 00:15.000]  Вот серьезно, потому что если вы видите РАС,
[00:15.000 --> 00:19.000]  можно сказать, что там ООП есть, но при этом можно сказать, что он там нет.
[00:19.000 --> 00:24.000]  Это чисто, как бы, скромное мнение о том, что ООП, а не тема того, что есть в РАСе.
[00:24.000 --> 00:28.000]  Ну тогда у кого первая ассоциация с полиморфизмом, это Джава?
[00:28.000 --> 00:31.000]  Нет? Ну ладно.
[00:31.000 --> 00:38.000]  Короче, сегодня будет не про ООП-полиморфизм,
[00:38.000 --> 00:43.000]  но вернее, не только про него, а про то, что слово полиморфизм,
[00:43.000 --> 00:47.000]  оно вообще там тянет свои корни из зарождения компьютеров,
[00:47.000 --> 00:50.000]  и вообще-то это слово о том, что есть в РАСе.
[00:50.000 --> 00:54.000]  В общем, давайте поедем. Вперед. Вот определение вам. Прям из книжки.
[00:54.000 --> 00:58.000]  Умный дядя. Вандервурд вроде.
[00:58.000 --> 01:00.000]  Могу путать авторов.
[01:00.000 --> 01:02.000]  Ну вот полиморфизм в целом, это...
[01:02.000 --> 01:06.000]  Мы написали кусок кода, вот он выглядит как-то.
[01:06.000 --> 01:08.000]  Буковки написаны.
[01:08.000 --> 01:12.000]  А дальше он по-разному работает в зависимости от чего-то.
[01:12.000 --> 01:15.000]  Либо вам принадлежит, либо не.
[01:15.000 --> 01:19.000]  Он по-разному работает в зависимости от чего-то.
[01:19.000 --> 01:22.000]  Либо вам прилетел разный объект в рантайме,
[01:22.000 --> 01:24.000]  и один и тот же код работает по-разному.
[01:24.000 --> 01:29.000]  Либо вам шаблон инстанцировали с разным аргументом,
[01:29.000 --> 01:33.000]  и в итоге разные функции вызвались, и все по-разному работает.
[01:33.000 --> 01:37.000]  То есть полиморфизм это максимально общее понятие в компьютерсиансе, в принципе.
[01:37.000 --> 01:42.000]  Если вы, так сказать, полиглот и знаете много разных языков,
[01:42.000 --> 01:46.000]  то у вас, возможно, такое чувство уже начинает закрадываться в вас.
[01:46.000 --> 01:48.000]  Ну, наверное, на четвертом курсе должно.
[01:48.000 --> 01:51.000]  Что, в принципе, полиморфизм это мега-общая тема,
[01:51.000 --> 01:54.000]  и везде его делают по-разному, очень по-разному.
[01:54.000 --> 01:57.000]  Я уже там что-то спылилил, по-моему, на каких-то прошлых занятиях,
[01:57.000 --> 02:00.000]  но сейчас вот будет в полную меру.
[02:00.000 --> 02:03.000]  Ну и вообще полиморфизм это там многоформенность,
[02:03.000 --> 02:06.000]  в переводе с какого-то, наверное, с греческого.
[02:07.000 --> 02:14.000]  Ну, примеров, полиморфизму вы, наверное, много уже видели,
[02:14.000 --> 02:16.000]  и сами можете там миллион привести,
[02:16.000 --> 02:21.000]  но если самое тупое, для скидки, это, конечно же, всякие виртуальные штуки.
[02:21.000 --> 02:24.000]  Ну, очевидно, это полиморфизм.
[02:24.000 --> 02:27.000]  Вот эти вещи это тоже полиморфизм.
[02:27.000 --> 02:30.000]  В каком смысле своп полиморфный?
[02:30.000 --> 02:35.000]  Ну, понимаете, любые, и работать с ними как бы по-разному, при этом...
[02:35.000 --> 02:36.000]  Ну да.
[02:36.000 --> 02:38.000]  Да, то есть как бы мы один тот же своп написали,
[02:38.000 --> 02:41.000]  а дальше аргументы могут быть любые, и все работает.
[02:41.000 --> 02:43.000]  Ну, как бы не только.
[02:43.000 --> 02:45.000]  Мы про ADL говорили.
[02:45.000 --> 02:48.000]  Вот это тоже как бы аспект полиморфизма.
[02:48.000 --> 02:50.000]  Некоторые, да.
[02:50.000 --> 02:53.000]  Ну, sort и exchange, понятно, по такому же принципу,
[02:53.000 --> 02:55.000]  что угодно пихаем, все работает.
[02:55.000 --> 02:59.000]  Но тут есть некоторая разница между своп exchange и sort,
[02:59.000 --> 03:03.000]  потому что класс, на котором работает exchange,
[03:03.000 --> 03:06.000]  на нем не обязательно сработает sort.
[03:06.000 --> 03:09.000]  Но при этом как бы извне кажется, что все одинаковое,
[03:09.000 --> 03:13.000]  и, в принципе, и то, и другое, и третье такое, статический полиморфизм.
[03:13.000 --> 03:18.000]  Ну, давайте чуть поглубже в такую терминологию того,
[03:18.000 --> 03:22.000]  что я вообще сейчас буду говорить.
[03:22.000 --> 03:26.000]  Ну, вот поведение, которое у нас определяется нашей обобщенной нотацией,
[03:26.000 --> 03:28.000]  оно может определяться разными вещами.
[03:28.000 --> 03:30.000]  Это может определяться значениями,
[03:30.000 --> 03:33.000]  такой первый уровень иерархии условной,
[03:33.000 --> 03:37.000]  а может определяться семействами значений, то есть типами.
[03:37.000 --> 03:41.000]  Причем это там происходит на этап раньше, в момент компиляции.
[03:41.000 --> 03:43.000]  Обычно.
[03:43.000 --> 03:45.000]  Но на самом деле нет.
[03:45.000 --> 03:48.000]  Ну, не всегда в смысле.
[03:48.000 --> 03:50.000]  Можно дальше пойти по этой иерархии.
[03:50.000 --> 03:53.000]  Вот у нас есть значение, группа значений, типы.
[03:53.000 --> 03:55.000]  Есть группа типов.
[03:55.000 --> 03:57.000]  Это группа называется kind,
[03:57.000 --> 04:00.000]  и в некоторых языках с этим прям явно можно работать.
[04:00.000 --> 04:04.000]  Ну, вот про что это вообще?
[04:04.000 --> 04:09.000]  Чувствуете ли вы отличия между значением какого-то int
[04:09.000 --> 04:12.000]  и какой-то лямбой?
[04:12.000 --> 04:14.000]  Они принципиально разные.
[04:14.000 --> 04:16.000]  Разные какие-то категории мыслительные.
[04:16.000 --> 04:18.000]  Лямбда это что-то, что можно запустить,
[04:18.000 --> 04:22.000]  а int это какие-то данные, которые надо использовать.
[04:22.000 --> 04:24.000]  Такое же различие есть в шаблонах.
[04:24.000 --> 04:26.000]  Вот у нас есть тип, который...
[04:26.000 --> 04:28.000]  Ну, просто тип.
[04:28.000 --> 04:30.000]  Какие-то данные в нем лежат.
[04:30.000 --> 04:32.000]  А есть тип, который шаблон.
[04:32.000 --> 04:36.000]  То есть когда мы шаблонные шаблонные аргументы пишем...
[04:36.000 --> 04:38.000]  Писали там сколько-то пар назад.
[04:38.000 --> 04:41.000]  Я там говорил, что шаблонный шаблонный аргумент
[04:41.000 --> 04:44.000]  это как будто передать указатель на функцию.
[04:44.000 --> 04:47.000]  Ну, и вот пишем мы класс
[04:47.000 --> 04:50.000]  или мы пишем template class class.
[04:50.000 --> 04:52.000]  Вот просто шаблонный типовой аргумент
[04:52.000 --> 04:54.000]  и шаблонный шаблонный аргумент.
[04:54.000 --> 04:57.000]  И то, и другое с какой-то точки зрения можно сказать типы.
[04:57.000 --> 05:00.000]  Но вот у них разные kind.
[05:00.000 --> 05:02.000]  Потому что одно работает как функция на типах,
[05:02.000 --> 05:05.000]  а другое работает как просто тип.
[05:12.000 --> 05:14.000]  На уровне системы типов лямбды?
[05:16.000 --> 05:17.000]  Вот, вот.
[05:22.000 --> 05:26.000]  Вот это люди зашли далеко в познание бытия.
[05:28.000 --> 05:30.000]  Ну, это здорово, да.
[05:34.000 --> 05:36.000]  Ну, в общем, если вы хотите красоты
[05:36.000 --> 05:38.000]  и наслаждения от жизни,
[05:38.000 --> 05:40.000]  и системы типов крутой,
[05:40.000 --> 05:42.000]  наверное вам либо в скалы, либо в хаскель.
[05:42.000 --> 05:44.000]  В хаскеле тоже подобные приколы есть.
[05:44.000 --> 05:46.000]  Ну, там в хаскеле можно прям явно
[05:46.000 --> 05:48.000]  оперировать над kind.
[05:48.000 --> 05:50.000]  Вы можете сказать, мой шаблон,
[05:50.000 --> 05:52.000]  на самом деле не шаблон, конечно же, да, там,
[05:52.000 --> 05:58.000]  принимает тип, у которого kind это звездочка.
[05:58.000 --> 06:00.000]  И это значит, типа, не функция.
[06:00.000 --> 06:02.000]  Ну, то есть, просто какой-то тип данных.
[06:02.000 --> 06:04.000]  А можете сказать, звездочка,
[06:04.000 --> 06:06.000]  стрелочка, звездочка.
[06:06.000 --> 06:08.000]  Вот это уже будет как бы мой...
[06:08.000 --> 06:10.000]  Моя штука принимает метафункцию.
[06:10.000 --> 06:12.000]  И сама внутри себя туда запихивает
[06:12.000 --> 06:14.000]  какой-то тип,
[06:14.000 --> 06:16.000]  и уже получает другой тип,
[06:16.000 --> 06:18.000]  и вот, ну, такие вещи.
[06:18.000 --> 06:20.000]  Ну и на самом деле эту иерархию можно дальше продолжать.
[06:20.000 --> 06:22.000]  Про это есть целая наука там
[06:22.000 --> 06:24.000]  в теории типов.
[06:24.000 --> 06:26.000]  Может кто-то слышал всякие гомотопные типы,
[06:26.000 --> 06:28.000]  вот такие какие-то странные вещи.
[06:28.000 --> 06:30.000]  Они, кажется, в этом...
[06:30.000 --> 06:32.000]  Чего?
[06:32.000 --> 06:34.000]  Такого умного слова я не слышал.
[06:34.000 --> 06:36.000]  А, dependent types
[06:36.000 --> 06:38.000]  это немножко не про это.
[06:38.000 --> 06:40.000]  Тут вот в другую сторону обобщение,
[06:40.000 --> 06:42.000]  про то, что вот мы там вот эту штуку продолжаем,
[06:42.000 --> 06:44.000]  потому что kind это как группы
[06:44.000 --> 06:46.000]  типов, а давайте группы kind и так далее.
[06:46.000 --> 06:48.000]  Ну, это так, для общего развития,
[06:48.000 --> 06:50.000]  в других языках это есть,
[06:50.000 --> 06:52.000]  и поэтому тоже бывает полиморфизм.
[06:52.000 --> 06:54.000]  Но в плюсах у нас этого все нет.
[06:54.000 --> 06:56.000]  У нас только либо по типам,
[06:56.000 --> 06:58.000]  либо по значениям.
[06:58.000 --> 07:00.000]  Выбора не очень много.
[07:00.000 --> 07:02.000]  И вот пошла такая таксономия,
[07:02.000 --> 07:04.000]  что есть некоторые свойства
[07:04.000 --> 07:06.000]  различных видов полиморфизма.
[07:06.000 --> 07:08.000]  Вот эти вот слова вы можете
[07:08.000 --> 07:10.000]  увидеть в ответах на stackoverflow,
[07:10.000 --> 07:12.000]  во всяких книжках там,
[07:12.000 --> 07:14.000]  во всяких обсуждениях в интернете.
[07:14.000 --> 07:16.000]  Очень пламенных обсуждениях
[07:16.000 --> 07:18.000]  на реддите.
[07:18.000 --> 07:20.000]  Поэтому давайте проговорим про них,
[07:20.000 --> 07:22.000]  чтобы примерно иметь представление,
[07:22.000 --> 07:24.000]  что это за слова.
[07:24.000 --> 07:26.000]  Первое очевидное разделение это на статический динамический полиморфизм.
[07:26.000 --> 07:28.000]  У нас поведение может
[07:28.000 --> 07:30.000]  определиться в разные моменты времени.
[07:30.000 --> 07:32.000]  Либо на этапе компиляции, либо в рентайме.
[07:32.000 --> 07:34.000]  Ну, на самом деле тут немножко
[07:34.000 --> 07:36.000]  сложнее все.
[07:36.000 --> 07:38.000]  На этапе компиляции.
[07:38.000 --> 07:40.000]  А вот на какой части этапа компиляции?
[07:40.000 --> 07:42.000]  Вообще-то, вообще-то.
[07:42.000 --> 07:44.000]  При процессоре тоже можно себе
[07:44.000 --> 07:46.000]  устроить полиморфизм.
[07:46.000 --> 07:48.000]  Если постараться.
[07:48.000 --> 07:50.000]  То есть что-то, что напоминает полиморфизм.
[07:50.000 --> 07:52.000]  Ну, раз уж мы говорим,
[07:52.000 --> 07:54.000]  что и шаблоны это полиморфизм,
[07:54.000 --> 07:56.000]  то в принципе все полиморфизм.
[07:56.000 --> 07:58.000]  И определение выше оно все подходит.
[07:58.000 --> 08:00.000]  Ну и в линковщике можно устроить полиморфизм.
[08:00.000 --> 08:02.000]  Это, кажется, на самой первой паре.
[08:02.000 --> 08:04.000]  Нет, на второй.
[08:04.000 --> 08:06.000]  На второй паре, кажется, или на первой.
[08:06.000 --> 08:08.000]  Ну, какой-то из них вам говорил про
[08:08.000 --> 08:10.000]  линковку.
[08:10.000 --> 08:12.000]  Я бы упоминал, что там
[08:12.000 --> 08:14.000]  подменяем целый cpp-шник
[08:14.000 --> 08:16.000]  на другой cpp-шник, где все функции такие же.
[08:16.000 --> 08:18.000]  Но при этом реализация у них там
[08:18.000 --> 08:20.000]  пустая, либо просто ассерт стоит.
[08:20.000 --> 08:22.000]  Ассерт ноль.
[08:22.000 --> 08:24.000]  Но вот это тоже своего рода полиморфизм.
[08:24.000 --> 08:26.000]  Мы как бы в других
[08:26.000 --> 08:28.000]  модулях кода пишем просто
[08:28.000 --> 08:30.000]  вызовы функций,
[08:30.000 --> 08:32.000]  а потом подменяем поведение
[08:32.000 --> 08:34.000]  просто другим флагом компиляции.
[08:36.000 --> 08:38.000]  Да, на этот слайд, наверное, надо добавить,
[08:38.000 --> 08:40.000]  что бывает, что еще все зависит
[08:40.000 --> 08:42.000]  от флагов компиляции.
[08:42.000 --> 08:44.000]  Такие вещи тоже бывают.
[08:44.000 --> 08:46.000]  Ну вот.
[08:46.000 --> 08:48.000]  Ну, кстати, я сам вот это вернулся.
[08:48.000 --> 08:50.000]  Можно ли концепты
[08:50.000 --> 08:52.000]  в каком-то смысле считать в подобном
[08:52.000 --> 08:54.000]  плане, типа в наедине концепты
[08:54.000 --> 08:56.000]  и требования для типов?
[08:58.000 --> 09:00.000]  Ну, как бы формально
[09:00.000 --> 09:02.000]  в какой-то
[09:02.000 --> 09:04.000]  степени кажется
[09:04.000 --> 09:06.000]  да, но это скорее
[09:06.000 --> 09:08.000]  некоторая такая шняга,
[09:08.000 --> 09:10.000]  которая позволяет закодировать
[09:10.000 --> 09:12.000]  одно в другом, мне кажется.
[09:14.000 --> 09:16.000]  Потому что как бы
[09:18.000 --> 09:20.000]  ну вот есть у вас множество.
[09:22.000 --> 09:24.000]  И в этом множестве в том числе есть функции.
[09:24.000 --> 09:26.000]  Ну, на самом деле, да, там
[09:26.000 --> 09:28.000]  говорим не множество, говорим какая-нибудь категория
[09:28.000 --> 09:30.000]  дурацкая или еще что-нибудь вот такое, да.
[09:30.000 --> 09:32.000]  Но как закодировать
[09:32.000 --> 09:34.000]  вообще вот какой-то
[09:34.000 --> 09:36.000]  набор множеств?
[09:36.000 --> 09:38.000]  Набор значений?
[09:38.000 --> 09:40.000]  Ну, типом мы умеем, да, а как еще можно
[09:40.000 --> 09:42.000]  закодировать набор значений?
[09:42.000 --> 09:44.000]  Тупо. Чтобы в коде можно было
[09:44.000 --> 09:46.000]  проверить, принадлежит значение нашему набору
[09:46.000 --> 09:48.000]  или нет?
[09:50.000 --> 09:52.000]  Кажется, я вас
[09:52.000 --> 09:54.000]  сломал, но это тупой вопрос.
[09:54.000 --> 09:56.000]  У вас есть набор значений каких-то?
[09:56.000 --> 09:58.000]  И вы хотите
[09:58.000 --> 10:00.000]  уметь понимать по новому значению?
[10:00.000 --> 10:02.000]  Лежит оно в наборе или нет?
[10:02.000 --> 10:04.000]  Просто в рантайме?
[10:04.000 --> 10:06.000]  Просто в рантайме, да.
[10:06.000 --> 10:08.000]  Можно предикат написать, можно векторочек
[10:08.000 --> 10:10.000]  завести, по нему искать, можно сетик.
[10:10.000 --> 10:12.000]  Много способов, да, но фактически
[10:12.000 --> 10:14.000]  все к функции сводится, что давайте
[10:14.000 --> 10:16.000]  заведем предикат. Вот он будет нам
[10:16.000 --> 10:18.000]  говорить по значению,
[10:18.000 --> 10:20.000]  являемся мы
[10:20.000 --> 10:22.000]  элементом множества или не являемся.
[10:22.000 --> 10:24.000]  Казалось бы, тогда ну давайте
[10:24.000 --> 10:26.000]  как бы вместо типов использовать функции
[10:26.000 --> 10:28.000]  предикаты на значениях.
[10:28.000 --> 10:30.000]  Почему это в плюсах не работает?
[10:32.000 --> 10:34.000]  Вот если вы хотите закодировать тип,
[10:34.000 --> 10:36.000]  в котором может лежать либо
[10:36.000 --> 10:38.000]  int, либо пара флотов.
[10:38.000 --> 10:40.000]  Можете ли вы написать
[10:40.000 --> 10:42.000]  предикат, который как бы в рантайме,
[10:42.000 --> 10:44.000]  которому в рантайме и то, и другое
[10:44.000 --> 10:46.000]  можно передать,
[10:46.000 --> 10:48.000]  ну и как бы, и на то, и другое он скажет
[10:48.000 --> 10:50.000]  да. Или там что угодно,
[10:50.000 --> 10:52.000]  любое значение, да, нам нужен предикат, которому
[10:52.000 --> 10:54.000]  любое значение можно передать.
[10:54.000 --> 10:56.000]  И он скажет да
[10:56.000 --> 10:58.000]  только если нам передали int или там пару
[10:58.000 --> 11:00.000]  флотов. Шаблоны?
[11:00.000 --> 11:04.760]  не читаются. Но как бы в JavaScript вы можете, вам передают любую фигню и вы
[11:04.760 --> 11:08.520]  спрашиваете, а что это за фигня? Или в Java можете, вам передают любой
[11:08.520 --> 11:13.320]  object и ну ладно, не совсем можете, там вот эти вот примитивные типы, с ними
[11:13.320 --> 11:18.880]  проблемы, но в Python можете, у вас просто функция, ей передали что угодно, это
[11:18.880 --> 11:23.400]  любое значение и вы можете посмотреть, что это за значение, какой у него тип,
[11:24.240 --> 11:28.680]  ну и как бы вот мы закодировали типы в Python без типов.
[11:28.680 --> 11:39.880]  Ну нет, это не особо, тут надо почувствовать, что требуется все в runtime делать,
[11:39.880 --> 11:45.480]  вот как бы на уровне, нет, он делает в runtime, если у тебя RTTI включен и
[11:45.480 --> 11:50.640]  polymorph на иерархии и там ну нет, нам с любыми значениями, в первую очередь int,
[11:50.800 --> 11:57.240]  всякими парами и так далее, структурками, вот, то есть в Python мы можем
[11:57.240 --> 12:01.520]  закодировать множество, ну тип закодировать как просто функцию, это функция, которая
[12:01.520 --> 12:06.160]  возвращает true или false для любого значения, если оно лежит в типе, то true или true,
[12:06.160 --> 12:13.320]  нет, false. Так вот, концепты, это та же самая идея, но на уровне ниже, это кстати
[12:13.320 --> 12:18.960]  еще одно важное наблюдение про плюсы, вот если мы на этом уровне работаем, то
[12:18.960 --> 12:23.920]  плюсы строго типизированы, а если мы спускаемся на уровень ниже и работаем на уровне типов,
[12:23.920 --> 12:34.040]  то строгой типизации в плюсах, грубо говоря, нету. Вы когда пишете в шаблоне класс T, значит туда
[12:34.040 --> 12:42.160]  можно передать любой класс, вообще любой, это то же самое, как когда вы в Python пишете dfu от x,
[12:42.160 --> 12:45.800]  вот туда можно передать любой x, любого типа, любое вообще что угодно.
[12:45.800 --> 12:55.760]  Да, это предикаты на типах, то есть как бы тут у нас сделано нормально в плюсах на уровне значений,
[12:55.760 --> 13:00.360]  вот мы строго решили, что мы не будем страдать фигней, какую-то динамическую типизацию вводить,
[13:00.360 --> 13:05.200]  потом какими-то функциями пытаться понять, что это есть на самом деле, да, как в TypeScript,
[13:05.200 --> 13:10.080]  мы сделали нормально, прямо на уровне языка семейства типов, а для типов нормально делать,
[13:10.080 --> 13:17.120]  мы решили, что не особо надо, и тут у нас Python на уровне типов происходит, у нас все не типизированные
[13:17.120 --> 13:24.640]  на уровне типов, ну или bash даже, да, ну в bash тоже по-моему не все строка, там как-то еще
[13:24.640 --> 13:33.360]  что-то бывает вроде, а может и нет. Ну почувствовали, о чем я говорю, что вот концепты, это костыль на вот
[13:33.360 --> 13:39.760]  этом уровне типов вместо kind, как бы нормальные kind в плюсы впилить невозможно, потому что
[13:40.240 --> 13:45.280]  по-другому язык вообще строить надо изначально было, смотрите Haskell, или наверное Scull,
[13:45.280 --> 13:49.560]  мне кажется, там тоже таким занимаются люди, но я не уверен, но Haskell-и точно этим занимаются.
[13:49.560 --> 13:55.120]  Можно пример какой-то функциональности, которые есть в Haskell, в Scull, но нет в плюсах с того,
[13:55.120 --> 13:58.520]  что у нас это концепты и все криво, косо не работает.
[13:58.520 --> 14:04.800]  Ну вот TypeKind, да, есть такой extension, называется TypeKind, вот про него можно почитать, нет,
[14:04.800 --> 14:10.640]  ну TypeKlasse это немножко про другое, мне кажется. В общем вот, да, TypeKind, вот про них если почитать,
[14:10.640 --> 14:15.440]  да и в принципе TypeKlasse тоже как-то в ту же что ли стезю, вот тут я свои мысли еще не организовал,
[14:15.440 --> 14:22.680]  если честно, но TypeKind, кажется, ровно про это. Про них надо почитать, потому что я сам наизусть
[14:22.680 --> 14:27.080]  не помню, в какой-то момент Haskell-ом очень интересовался и прям все гуглил, смотрел,
[14:27.080 --> 14:32.560]  где используется, там офигевал от того, чем люди занимаются, пока мы тут байтики перекладываем,
[14:32.560 --> 14:38.640]  вот, но потом забыл, потому что было это все давно, вот, соответственно, более глубоко я в это не смогу
[14:38.640 --> 14:44.960]  углубиться, но аналогия, по-моему, тут прекрасная, да, что мы как бы, также как в TypeScript, фиксит
[14:44.960 --> 14:51.040]  отсутствие типизации функциями, которые возвращают true-false по значению, грубо говоря, да, вот это
[14:51.040 --> 14:56.520]  на уровне значений происходит, также мы в плюсах на уровне типов фиксим отсутствие типизации,
[14:56.520 --> 15:04.640]  добавляя предикаты на уровне типов, то есть концепта, ну, то есть такой дизайн нельзя назвать
[15:04.640 --> 15:11.640]  плохим, но он с математической точки зрения не вызывает вот трепета в сердце, вам так не кажется,
[15:11.640 --> 15:19.880]  вот если вся иерархия тут с высшими типами была выстроена, и все по красоте, тогда вот
[15:19.880 --> 15:26.280]  прям трепет, красиво, а мы решили нет, ну и выбора-то особо не было, в общем, ладно, давайте дальше идти,
[15:26.280 --> 15:32.320]  мы уже слишком долго говорим про это, давайте дальше про вот эту таксономию дурацкую, ну, не дурацкую,
[15:32.320 --> 15:40.080]  если ей все пользуются, то она не может быть дурацкой, правда ведь? Да, тут вот есть еще такая вот
[15:40.080 --> 15:47.360]  шняга, открытый и закрытый полиморфизм, или bounded, intrusive, или unbounded, non intrusive, и вот тут очень
[15:47.360 --> 15:52.880]  сложно сказать, что конкретно имеется в виду, и вот эта строчка, наверное, у вас может вызывать
[15:52.880 --> 15:58.720]  вопросы, у меня она тоже, конечно же, вызывает, вот умеет ли система типов проверять, определено ли
[15:58.720 --> 16:11.480]  поведение, ну, по факту это наилучшая формулировка, которую тут можно привести, а что это по факту
[16:11.680 --> 16:17.760]  значит? Это некоторый способ отличить ООП, в котором вам нужно наследоваться от интерфейса и менять
[16:17.760 --> 16:24.440]  свой тип, чтобы войти в какое-то полиморфное семейство, от шаблонов, где с типом делать ничего не нужно,
[16:24.440 --> 16:31.320]  вы просто подставляете этот тип и все работает, да, то есть если вы там вспоминаем вот этот пример
[16:31.320 --> 16:39.200]  с бинпоиском, который когда-то я тут сидел кодил, что когда вы делаете интерфейс для обобщенного
[16:39.200 --> 16:44.240]  бинпоиска на ООП, вам нужен интерфейс iCompareable, и новый класс нужно садиться и наследовать,
[16:44.240 --> 16:49.640]  и там руками вписывать что-то, чтобы работало, когда вы пишете шаблоны, вы можете где угодно
[16:49.640 --> 16:56.240]  оператор сравнения передать, а то и компаратор какой-нибудь, и все, будет работать, ну, тут вот
[16:56.240 --> 17:00.960]  про это речь, да, нужно ли вам как-то менять ваш старый код, чтобы вписаться в полиморфизм,
[17:00.960 --> 17:07.200]  или можно вписать кого-нибудь просто так, на самом деле очень мутная тема действительно, причем
[17:07.200 --> 17:12.080]  слова эти, ну, давайте так, поднимите руку, если вы уже слышали где-то про там открытый-закрытый
[17:12.080 --> 17:19.600]  полиморфизм, bounded, unbounded, на удивление мало людей, ну, вот, чуть плюс-минус, да, где-то оно встречается,
[17:19.600 --> 17:27.080]  вот, вот, вот в этом проблема, потому что все используют эти слова, но никто не может толком объяснить,
[17:27.080 --> 17:37.160]  что они значат. Да, ну, или даже просто в рамках плюсов, вот шаблонные концепты,
[17:37.160 --> 17:44.520]  сравнивать с классами и интерфейсами, да, ну, вот в Расте там ОП устроено, оно как бы, вот,
[17:44.520 --> 17:50.280]  интерфейсы ОПшные, они как бы интегрированы с концептами, грубо говоря, и это одна и та же
[17:50.280 --> 17:58.600]  сущность, и как бы имплементацию методов для какого-то интерфейса вы пишете вне класса, и оно
[17:58.600 --> 18:06.800]  такое открытое, типа, ну, надеюсь, основную мысль поняли, и последняя, у нас бывает single
[18:06.800 --> 18:14.240]  dispatch, бывает multiple, все, о чем мы до сих пор говорили, это в целом single dispatch, да, так, я не
[18:14.240 --> 18:20.000]  сказал, что это значит, сколько таких абстрактных сущностей определяет наше конкретное поведение,
[18:20.000 --> 18:33.320]  ну, вот в джаве, какой dispatch, везде, single, да, там вот есть текущий объект, вот он определяет,
[18:33.320 --> 18:38.680]  его настоящий рентайм-тип определяет поведение, вот иначе никак, ну, можно руками что-то
[18:38.680 --> 18:47.480]  кастылять, но вот ОП классически это single dispatch, а вот шаблоны, ну да, у нас может быть несколько
[18:47.480 --> 18:54.160]  шаблонных аргументов и будет вполне себе multiple dispatch, ну ладно, давайте на этом с примерами
[18:54.160 --> 19:10.000]  закончим, пойдем вот, да, но когда ты пишешь код там указатель на интерфейс.foo, сколько сущностей
[19:10.000 --> 19:21.320]  определяют, какая конкретная фу, в каком файле будет вызвана, нет, ну, у тебя есть один объект в коде, вот
[19:21.320 --> 19:26.560]  этот объект, указатель на который ты использовал, чтобы позвать функцию, вот этот один объект, он
[19:26.560 --> 19:31.960]  полностью определяет, вот его рентайм-тип полностью определяет твое поведение, да, вот про это речь
[19:31.960 --> 19:41.400]  здесь, то есть в случае с ОП подразумевают, что поведение определяется значением в рентайме и
[19:41.400 --> 19:47.040]  только одним, вот один объект, ты на нем метод зовешь, вот только его значением определяется,
[19:47.040 --> 19:57.160]  какой метод конкретно у кого вызовется, вот, да, тобла токсинамии, это еще какая-то классификация,
[19:57.760 --> 20:02.000]  которая тоже постоянно используется, вот слова от Хогг-полиморфизма, я думаю, вы вообще это,
[20:02.000 --> 20:13.360]  ну, все должны были слышать когда-нибудь, правда? Теперь еще раз услышите, ну, я нашел такое
[20:13.360 --> 20:18.640]  определение, некоторые общая нотация, работающая для вообще каких-то типов и никакого адекватного
[20:18.640 --> 20:23.840]  способа понять с работы для нашего конкретного типа или нет, нам не предоставлена, вот он всегда
[20:23.840 --> 20:30.400]  задумано, что он баундед, да, то есть мы, если бы мы в типе явно указывали, что мы там вписываемся в
[20:30.400 --> 20:39.920]  какой-то полиморфную тему, то тут было бы легко понять, сработает ли наша нотация или нет,
[20:39.920 --> 20:43.560]  ну, посмотри на тип, там написано сработает, значит сработает, то есть вот эта штука,
[20:43.560 --> 20:48.360]  она всегда unbounded, ну и тут куча примеров накидана, потому что давайте уже от конкретики,
[20:48.360 --> 20:56.160]  а вот перейдем вот от всех этих абстрактных рассуждений, супер конкретно, внезапно перегруженные
[20:56.160 --> 21:05.120]  функции оператора это такой ad hoc полиморфизм статический, ну еще в хаскеле он по-моему есть,
[21:05.120 --> 21:13.280]  вроде да, да, перегруженный оператор конечно есть в хаскеле или нет, я забыл, ну в плюсах точно есть,
[21:13.280 --> 21:18.960]  то есть вы пишете а плюс б и вы не знаете, что происходит, то есть а может быть вектор, может быть
[21:18.960 --> 21:23.960]  тинг, может быть float, может быть это какая-то монада и там плюс вообще бог знает, что делает,
[21:23.960 --> 21:31.560]  ну верите мне, да, что это такой unbounded, статик, полиморфизм, общая нотация работает для непонятной
[21:31.560 --> 21:37.120]  чего, ну какого-то способа адекватного проверить, что она работает, кроме как написать и посмотреть, нету.
[21:37.120 --> 21:49.040]  Ну да, это такой способ проверять рабозаспособность ad hoc полиморфизма, что-то вот такое, ну и концепты
[21:49.040 --> 21:54.760]  толком-то вот requires expression это именно про это, а давайте просто ad hoc проверять работает ли какие-то ad hoc
[21:54.760 --> 22:03.520]  нотации, да, но с точки зрения человека, который занимается какими-нибудь теориями типов и с
[22:03.520 --> 22:11.200]  тонкими материями, это все такая гадость, мерзость и вообще это, ну это грех в общем, полная ересь, а на
[22:11.200 --> 22:16.400]  практике ну внезапно оказывается, что вполне достаточно и работает и все довольны, что бы хотеть-то значит.
[22:16.400 --> 22:24.640]  Давайте дальше побежим, там еще три слайдика у нас буквально, а специализация это тоже такой, ну в
[22:24.640 --> 22:30.160]  каком-то смысле ad hoc полиморфизм, мы можем в любом месте взять и специализировать любой шаблон для
[22:30.160 --> 22:36.960]  любого типа и внезапно поменять поведение и теперь мы используем этот шаблон с конкретным типом, понятия
[22:36.960 --> 22:46.920]  не имеем, какую специализацию мы получим. Смотрите, std vector bool. Linktime полиморфизма, про которую я говорил, да, вот
[22:46.920 --> 22:53.440]  это вот подмена одного cппшника на другой, но оно такое тоже ad hoc, конечно никакого способа ничего проверить
[22:53.440 --> 23:00.040]  тут нет, это вот вообще максимальный ad hoc, ну при процессор всякий тоже ad hoc, сюда же, а в го еще есть
[23:00.040 --> 23:05.440]  интерфейсы забавные, да, вот это все было статик, пример статического ad hoc полиморфизма, вот
[23:05.440 --> 23:11.680]  интерфейсы в го, кто знает го? Расскажите нам кто-нибудь из вас, троих, как там работают интерфейсы.
[23:11.680 --> 23:19.680]  В одном месте пишешь интерфейс, в другом структуру, потом op и они магическим образом подходят друг к другу.
[23:19.680 --> 23:21.680]  А почему они подходят?
[23:21.680 --> 23:38.680]  Потому что проверяется в ронтайме, в ронтайме проверяется список методов, нужные методы есть, давай дальше, ну вот по-моему это максимально ad hoc, что только можно вообще сделать, то есть
[23:38.680 --> 23:50.680]  ну не будем осуждать, го прекрасный язык, чтобы писать микросервисы, да, type erager, знаете что это такое?
[23:50.680 --> 24:14.680]  В джаве, то что в джаве называют type erager, там просто был чувак, который вот как вы помнит умное слово type erager, но не особо помнит что оно значит, и когда вот джаву писал и вот придумал что, а давайте мы
[24:14.680 --> 24:28.680]  дженерики сделаем вот так, вот будем заменять все дженерик аргументы на объект и все, вот он это придумал и такой нужно название, ой type erager умное слово, но я же как бы тут типы убрал, на объект заменил, назову тоже type erager.
[24:28.680 --> 24:34.680]  Мне кажется такова история могла быть, появление этого термина в джаве, но нет это не про это.
[24:34.680 --> 24:42.680]  Да, нет, ну я, проф деформация.
[24:42.680 --> 24:50.680]  У вас есть какой-то объект, какие-нибудь методы.
[24:50.680 --> 24:54.680]  Окей, ты сейчас будешь правильный ответ говорить, и ты собрался правильный ответ говорить.
[24:54.680 --> 25:04.680]  Ну, да и тогда я не правильный, давайте вы не будете говорить правильный ответ, потому что вторая половина нашего сегодняшнего занятия посвящена тому, чтобы руками писать type erager с нуля.
[25:04.680 --> 25:10.680]  Я могу предположить, это может быть неправильно.
[25:10.680 --> 25:14.680]  Не надо, это не так важно, в общем это сегодня мы будем вот вот мусолить до последнего.
[25:14.680 --> 25:24.680]  Ты знаешь толку о возвращениях, но сегодня не дойдем, я думаю.
[25:24.680 --> 25:28.680]  Ну да, вот еще бывает всякая эзотерика.
[25:28.680 --> 25:38.680]  В плане отхог такого динамического полиморфизма, там можно всякие извращения делать в языках, где сильные рефлексии, там каком-нибудь питоне, например.
[25:38.680 --> 25:44.680]  Можете посмотреть и значение, какой у тебя тип, и тип, а какие у тебя поля, а какие у тебя методы.
[25:44.680 --> 25:52.680]  Ну и отсюда можно много накуролесить всякого жуткого, но тут конкретных примеров, кажется, не будет.
[25:52.680 --> 26:04.680]  А да, smalltalk есть очень современные точки зрения лютая эзотерика, но на самом деле все ОП оно пошло же из smalltalk.
[26:04.680 --> 26:12.680]  Если вы хотите углубиться в корне того, откуда было есть пошло ОП, вам вот про этот язык надо почитать, и это безумно интересно, если честно.
[26:12.680 --> 26:16.680]  И фотообъект.
[26:16.680 --> 26:21.680]  Ну любое, в принципе, слово в твоей программе, это должен быть объект, да?
[26:21.680 --> 26:26.680]  А где ты программу пишешь? Ну в каком-то окне, там текстовом, это тоже объект.
[26:26.680 --> 26:29.680]  Ну и весь твой редактор, он тоже объект.
[26:29.680 --> 26:38.680]  Поэтому если ты хочешь, то в своей программе можешь отправить объекту редактора сообщение, удалить мою программу, и так, ну, smalltalk это безумная вещь.
[26:38.680 --> 26:41.680]  Очень рекомендую почитать, но out of scope, к сожалению, для нас.
[26:41.680 --> 26:44.680]  Я правильно понимаю, что if это функтор получается?
[26:44.680 --> 26:45.680]  If?
[26:45.680 --> 26:47.680]  Ну, smalltalk.
[26:47.680 --> 26:50.680]  Smalltalk есть объект.
[26:50.680 --> 26:51.680]  If это объект.
[26:51.680 --> 26:55.680]  Все, что ты умеешь делать в smalltalk, все-таки отступление сделаю.
[26:55.680 --> 26:59.680]  Все, что в smalltalk можно делать, это делать объекты.
[26:59.680 --> 27:05.680]  Объекты единственное, что умеют делать, это обрабатывать сообщение и слать сообщение другим объектам.
[27:05.680 --> 27:08.680]  Вот это все, что есть в smalltalk, грубо говоря.
[27:08.680 --> 27:11.680]  То есть весь язык основан на таком message passing между объектами.
[27:11.680 --> 27:15.680]  И вот это было изначальное понимание того, что такое объектно-ориентированное программирование.
[27:15.680 --> 27:18.680]  Причем, ну, все ронтаймовое, да?
[27:18.680 --> 27:22.680]  Потому что никаких классов не было, никакого наследования не было.
[27:22.680 --> 27:24.680]  Были только объекты и message passing между ними.
[27:24.680 --> 27:29.680]  Список хендлеров различных месседжей у объекта динамически хранится в ронтайме.
[27:29.680 --> 27:32.680]  Можно новый добавить в любой момент, можно убрать.
[27:32.680 --> 27:35.680]  Сами объекты тоже создаются в ронтайме в любой момент.
[27:35.680 --> 27:39.680]  Ну, и там была IDE, вся тоже сама написана на smalltalk,
[27:39.680 --> 27:43.680]  поэтому прямо из своей программы можно было слать сообщение своему редактору.
[27:43.680 --> 27:46.680]  И там какие-то безумные вещи происходят.
[27:46.680 --> 27:50.680]  Я надеюсь, вас заинтриговал немножко и для общего развития вы почитаете.
[27:50.680 --> 27:54.680]  Но мы должны ехать дальше, потому что есть более хорошие виды полиморфизма.
[27:54.680 --> 27:57.680]  Вот это, кажется, православный полиморфизм такой самый.
[27:57.680 --> 28:02.680]  Вот если вы пообщаетесь с человеком, который занимается теорией типов,
[28:02.680 --> 28:06.680]  он вам что такое полиморфизм, ответит, что вот это полиморфизм,
[28:06.680 --> 28:09.680]  а все остальное это ересь и надо сжечь.
[28:09.680 --> 28:14.680]  Ну, тут какое-то определение есть, что мол, однородно обобщенное по типу значению код.
[28:14.680 --> 28:19.680]  Ну, имеется в виду, что вы прям явно пишете некоторые параметрические конструкции,
[28:19.680 --> 28:23.680]  которые работают для любого типа.
[28:26.680 --> 28:29.680]  Причем гарантированно работают.
[28:29.680 --> 28:34.680]  Ну, как бы шаблоны в плюсах, они не особо параметрический полиморфизм,
[28:34.680 --> 28:38.680]  но в принципе да, потому что они unbounded.
[28:38.680 --> 28:42.680]  Как бы в идеале параметрический полиморфизм должен быть bounded,
[28:42.680 --> 28:49.680]  и, так я не подключил, нет, и в принципе должен выглядеть как в хаскеле, и все.
[28:49.680 --> 28:54.680]  Вот как бы это архетип всего параметрического полиморфизма.
[28:54.680 --> 28:58.680]  Вы пишете код, в нем вы говорите, что у вас есть там значения,
[28:58.680 --> 29:01.680]  ну, на вход аргументы приходят, да, функции какие-то,
[29:01.680 --> 29:03.680]  и у них должны быть вот такие типы.
[29:03.680 --> 29:05.680]  Типы могут быть обобщенными.
[29:05.680 --> 29:12.680]  Я не уверен, что это там не конкретные типы, а какие-то типы из каких-то семейств.
[29:12.680 --> 29:17.680]  Семейств там задаваемых разными хитрыми образами.
[29:17.680 --> 29:23.680]  И оно все очень фиксированное, очень математичное.
[29:23.680 --> 29:26.680]  Ну, я не уверен, насколько легко почувствовать отличия
[29:26.680 --> 29:31.680]  между шаблонами как ad hoc штукой и шаблонами как parametric штукой.
[29:31.680 --> 29:34.680]  Ну, в каком-то смысле шаблоны параметричные.
[29:34.680 --> 29:37.680]  И вот с концептами они как бы совсем хорошими становятся,
[29:37.680 --> 29:39.680]  прям параметричные и параметричные.
[29:44.680 --> 29:47.680]  Так, я теряю мысль.
[29:49.680 --> 29:51.680]  Вот, Generic и Rust, давайте лучше к ним.
[29:51.680 --> 29:54.680]  Про плюсы это вся как грязное.
[29:54.680 --> 29:58.680]  Вот Generic и Rust это прям честный-честный параметрический полиморфизм.
[29:58.680 --> 30:00.680]  Вот самый, что ни на есть.
[30:00.680 --> 30:07.680]  И там у вас строгая конструкция.
[30:07.680 --> 30:10.680]  Вы строго говорите, что вот такие методы должны быть,
[30:10.680 --> 30:13.680]  и это значит такой type class, что называется.
[30:13.680 --> 30:15.680]  Некоторое семейство типов.
[30:15.680 --> 30:20.680]  Дальше говорите, функция принимает на вход тип из семейства.
[30:20.680 --> 30:26.680]  Может принимать просто, а может принимать как бы динамически.
[30:26.680 --> 30:29.680]  И вот просто это значит, что у вас будет что-то вроде шаблона,
[30:29.680 --> 30:32.680]  а динамически значит, что у вас будет что-то вроде ОП
[30:32.680 --> 30:34.680]  и виртуальных функций.
[30:34.680 --> 30:37.680]  И в самой функции вы имеете право на этом значение
[30:37.680 --> 30:40.680]  использовать только тот функционал, который описан в этом семействе.
[30:40.680 --> 30:42.680]  И ничего больше.
[30:42.680 --> 30:44.680]  Вот это вот прям самый такой православный,
[30:44.680 --> 30:46.680]  строгий параметрический полиморфизм.
[30:46.680 --> 30:49.680]  Ну вот на концептах в плюсах можно сделать что-то похожее
[30:49.680 --> 30:50.680]  и будет неплохо.
[30:50.680 --> 30:52.680]  С шаблонами ну так, плюс-минус.
[30:52.680 --> 30:55.680]  Какой-то вопрос был или нет?
[30:55.680 --> 30:57.680]  Значит, мне показалось.
[30:57.680 --> 31:02.680]  А вот в принципе, дженерики в Java и Scala они тоже нормальный полиморфизм,
[31:02.680 --> 31:05.680]  но в них есть большой недостаток.
[31:05.680 --> 31:12.680]  А вот в параметрическом полиморфизме есть такое понятие, как мономорфизация.
[31:12.680 --> 31:17.680]  Полиморфизм это обычно про функции вот в этом контексте.
[31:17.680 --> 31:22.680]  И полиморфная функция это функция, которая умеет работать с многими видами данных.
[31:22.680 --> 31:28.680]  И вот мономорфизация это получить из полиморфной функции мономорфную,
[31:28.680 --> 31:31.680]  которая работает с одним конкретным типом данных.
[31:31.680 --> 31:34.680]  Вот эту мономорфизацию можно делать по-разному.
[31:34.680 --> 31:40.680]  Можно делать ее путем копипасты всего кода функции много раз для каждого типа.
[31:40.680 --> 31:41.680]  Какой язык так делает?
[31:41.680 --> 31:45.680]  В какой ситуации?
[31:45.680 --> 31:47.680]  Ну раз ты так и сяк делает.
[31:47.680 --> 31:48.680]  Плюсы.
[31:48.680 --> 31:53.680]  Шаблоны в плюсах каждый раз, когда вы подставляете в полиморфную статическую функцию шаблонную
[31:53.680 --> 31:57.680]  что-то конкретное, она генерит новую специализацию вам.
[31:57.680 --> 31:59.680]  И вот отдельные, отдельные, отдельные функции.
[31:59.680 --> 32:01.680]  А Java поступает наоборот.
[32:01.680 --> 32:08.680]  Она как бы в дженериках при мономорфизации берет и говорит,
[32:08.680 --> 32:11.680]  что все типы у меня будут одним единственным типом.
[32:11.680 --> 32:14.680]  Такой void звездочка.
[32:14.680 --> 32:17.680]  А какие конкретные методы мы хотим вызывать?
[32:17.680 --> 32:20.680]  Она там как-то хитро запоминает через что-то рантаймовое.
[32:20.680 --> 32:22.680]  Вот тут не уверен в деталях.
[32:22.680 --> 32:23.680]  Вот.
[32:23.680 --> 32:25.680]  И вот Rast он умеет и так, и так.
[32:25.680 --> 32:28.680]  Вот я сказал DIN есть, не DIN.
[32:28.680 --> 32:31.680]  Я деталей Rast не знаю, если что, ни строчки на нем в жизни не написал,
[32:31.680 --> 32:32.680]  только статьи читал.
[32:32.680 --> 32:35.680]  Но насколько я знаю, поправьте меня, если не прав,
[32:35.680 --> 32:40.680]  можно писать в дженерик функцию как с мономорфизацией,
[32:40.680 --> 32:43.680]  как у шаблонов, где будет просто копипаститься код,
[32:43.680 --> 32:45.680]  так и с мономорфизацией рантаймовой,
[32:45.680 --> 32:47.680]  где будет одна функция, один код,
[32:47.680 --> 32:50.680]  но будет рантайм-полиморфизм,
[32:50.680 --> 32:53.680]  и виртуальные вызовы это дороже стоят по первому.
[32:53.680 --> 32:55.680]  Ну это похоже будет не дженерик, но да.
[32:55.680 --> 32:57.680]  Просто инциклы принимают.
[32:57.680 --> 33:00.680]  Ну внешний вид, кажется, не отличается у них, да?
[33:00.680 --> 33:01.680]  Отличается.
[33:01.680 --> 33:02.680]  Отличается, да?
[33:02.680 --> 33:04.680]  То есть там не является дженерик параллельным.
[33:04.680 --> 33:06.680]  А, окей, там треугольные скобочки.
[33:06.680 --> 33:07.680]  Ну окей.
[33:07.680 --> 33:09.680]  Ладно, наверное, тогда я не очень корректно сказал,
[33:09.680 --> 33:12.680]  что в Rast и так, и так примерно одинаково.
[33:12.680 --> 33:14.680]  Ну вы поняли меня, я надеюсь.
[33:14.680 --> 33:17.680]  Вот, ну и в конце концов есть вот эти вот прекрасные языки.
[33:17.680 --> 33:19.680]  Haskell, OCaml, вот там вот все хорошо.
[33:19.680 --> 33:21.680]  Есть еще ML?
[33:21.680 --> 33:23.680]  А, ну...
[33:23.680 --> 33:25.680]  OCaml это есть ML, ладно.
[33:25.680 --> 33:27.680]  В ГО есть дженерики.
[33:27.680 --> 33:28.680]  Чего?
[33:28.680 --> 33:30.680]  В ГО есть дженерики.
[33:30.680 --> 33:32.680]  Откуда в ГО появились дженерики?
[33:32.680 --> 33:34.680]  Они очень плохие там.
[33:34.680 --> 33:35.680]  Да.
[33:35.680 --> 33:37.680]  Это было очень грустно, когда я с ними работал.
[33:37.680 --> 33:40.680]  Ну давайте тогда не говорите плохом, пойдем дальше.
[33:40.680 --> 33:43.680]  Еще есть некоторая такая штука под названием subtyping.
[33:43.680 --> 33:46.680]  Она тоже пересекается со всем предыдущим,
[33:46.680 --> 33:48.680]  и тоже очень мутное разделение.
[33:48.680 --> 33:50.680]  Ну...
[33:50.680 --> 33:53.680]  По факту речь идет о том,
[33:53.680 --> 33:57.680]  что мы умеем типы как бы наследовать как бы друг от друга.
[33:57.680 --> 33:59.680]  Один тип является другим,
[33:59.680 --> 34:01.680]  но не обязательно наследовать.
[34:03.680 --> 34:05.680]  Ну, любое OP...
[34:05.680 --> 34:07.680]  Да, вот любое наследование считается,
[34:07.680 --> 34:09.680]  что у нас у типа есть подтип.
[34:09.680 --> 34:11.680]  У вас есть какие-то общины,
[34:11.680 --> 34:13.680]  по которым раз-то многие не читают OP,
[34:13.680 --> 34:15.680]  потому что там нет наследования?
[34:15.680 --> 34:17.680]  Ну и дураки они.
[34:17.680 --> 34:19.680]  Потому что я вот напоминаю,
[34:19.680 --> 34:21.680]  OP пошло со Smalltalk,
[34:21.680 --> 34:23.680]  в Smalltalk не было наследования,
[34:23.680 --> 34:25.680]  и это было OP,
[34:25.680 --> 34:27.680]  и никого это не смущало.
[34:27.680 --> 34:29.680]  Отсюда не OP, наследования нет.
[34:29.680 --> 34:31.680]  Трех китов OP придумали PostFactum.
[34:31.680 --> 34:33.680]  Когда уже было OP,
[34:33.680 --> 34:35.680]  и когда его решили популяризировать
[34:35.680 --> 34:37.680]  там всякие ребята из...
[34:37.680 --> 34:39.680]  Да?
[34:39.680 --> 34:41.680]  Тут просто проблема в том,
[34:41.680 --> 34:43.680]  что самый известный язык,
[34:43.680 --> 34:45.680]  в котором молятся на OP,
[34:45.680 --> 34:47.680]  это Java.
[34:47.680 --> 34:49.680]  Тут проблема в целенаправленной компании
[34:49.680 --> 34:51.680]  по пропагандированию вот этого взгляда
[34:51.680 --> 34:53.680]  трех китов, курсов по обучению Java,
[34:53.680 --> 34:55.680]  где вот этому все расскажут,
[34:55.680 --> 34:57.680]  тебе там паттерн...
[34:57.680 --> 34:59.680]  Это тоже, кстати, интересная история.
[34:59.680 --> 35:01.680]  Уже OP,
[35:01.680 --> 35:03.680]  как слово, ассоциируется с OP в виде Java.
[35:03.680 --> 35:05.680]  Ну да, да.
[35:05.680 --> 35:07.680]  Если мы говорим, что в Расте OP,
[35:07.680 --> 35:09.680]  в Хаске или OP,
[35:09.680 --> 35:11.680]  я все сделаю.
[35:11.680 --> 35:13.680]  Да.
[35:13.680 --> 35:15.680]  OP уже смысла не имеет.
[35:15.680 --> 35:17.680]  Поэтому предлагаю читать
[35:17.680 --> 35:19.680]  историю происхождения всех этих смешных
[35:19.680 --> 35:21.680]  терминов и языков.
[35:21.680 --> 35:23.680]  Вот про то, почему Java когда стала популярной
[35:23.680 --> 35:25.680]  и какими шишами,
[35:25.680 --> 35:27.680]  бесплатно такими популярными не становятся,
[35:27.680 --> 35:29.680]  вот про это тоже рекомендую почитать прикольно.
[35:29.680 --> 35:31.680]  ЦРТП тоже можно называть саптайпингом.
[35:31.680 --> 35:33.680]  Мы там тоже делаем наследование,
[35:33.680 --> 35:35.680]  поэтому очевидно, что это саптайпинг.
[35:35.680 --> 35:37.680]  Просто он немножко странный.
[35:37.680 --> 35:39.680]  У нас как бы
[35:39.680 --> 35:41.680]  базовый тип, он зависит от
[35:41.680 --> 35:43.680]  родительского, ну что-то вот такое
[35:43.680 --> 35:45.680]  извращенное немножко.
[35:45.680 --> 35:47.680]  И конец сюрприз.
[35:47.680 --> 35:49.680]  Все неявные касты, согласно
[35:49.680 --> 35:51.680]  некоторым источникам, тоже считаются
[35:51.680 --> 35:53.680]  таким саптайпингом. То есть то,
[35:53.680 --> 35:55.680]  что вы неявно можете сконвертировать bool
[35:55.680 --> 35:57.680]  к int, это почему?
[35:57.680 --> 35:59.680]  Потому что bool является под
[35:59.680 --> 36:01.680]  типом int.
[36:01.680 --> 36:03.680]  То есть или 0 или 1, согласно языку C.
[36:03.680 --> 36:05.680]  В int можно положить и 0 и 1,
[36:05.680 --> 36:07.680]  значит под тип.
[36:07.680 --> 36:09.680]  Еще тут кто-то кажется был со
[36:09.680 --> 36:11.680]  скалой знакомый.
[36:11.680 --> 36:13.680]  Там же есть вот эта вот прекрасная
[36:13.680 --> 36:15.680]  возможность объявлять под типы
[36:15.680 --> 36:17.680]  явно. Которая не ООП,
[36:17.680 --> 36:19.680]  но что-то такое извращенное.
[36:27.680 --> 36:29.680]  Когда вот
[36:29.680 --> 36:31.680]  всяка вариантность всякая начинается с
[36:31.680 --> 36:33.680]  наследованием, вот там кажется можно
[36:33.680 --> 36:35.680]  как-то явно сказать, что один тип
[36:35.680 --> 36:37.680]  является под типом другого.
[36:43.680 --> 36:45.680]  Во!
[36:45.680 --> 36:47.680]  Вектор животных будет под типом
[36:47.680 --> 36:49.680]  вектора собак. Вот это еще один классный
[36:49.680 --> 36:51.680]  пример, которого здесь нету.
[36:51.680 --> 36:53.680]  Вектор
[36:53.680 --> 36:55.680]  животных будет родителем
[36:55.680 --> 36:57.680]  вектора собак. Вектор собак
[36:57.680 --> 36:59.680]  является под типом вектора животных.
[37:01.680 --> 37:03.680]  Но наследований нет,
[37:03.680 --> 37:05.680]  но подтипы как бы есть.
[37:11.680 --> 37:13.680]  Ну да, там интересные всякие начинаются.
[37:17.680 --> 37:19.680]  В GWM что угодно
[37:19.680 --> 37:21.680]  можно запихнуть, коли он полный по
[37:21.680 --> 37:23.680]  тюрингу. Чего стесняться-то?
[37:23.680 --> 37:25.680]  Вот, по-моему, скалы это единственный
[37:25.680 --> 37:27.680]  язык, где такими укротасами занимаются,
[37:27.680 --> 37:29.680]  но в целом да.
[37:31.680 --> 37:33.680]  Наверное, на этом все.
[37:33.680 --> 37:35.680]  Вот с этими примерами.
[37:35.680 --> 37:37.680]  Итак, давайте
[37:37.680 --> 37:39.680]  про C++. Вот у нас есть
[37:39.680 --> 37:41.680]  vtable полиморфизм,
[37:41.680 --> 37:43.680]  runtime, ну самый такой
[37:43.680 --> 37:45.680]  единственный расово верный
[37:45.680 --> 37:47.680]  runtime полиморфизм.
[37:47.680 --> 37:49.680]  Мы там
[37:49.680 --> 37:51.680]  неоднородные коллекции умеем создавать.
[37:51.680 --> 37:53.680]  Вектор животных.
[37:53.680 --> 37:55.680]  Круто, круто.
[37:55.680 --> 37:57.680]  Мы можем сурсы не дистрибьютить своим
[37:57.680 --> 37:59.680]  пользователям. То есть есть библиотеки,
[37:59.680 --> 38:01.680]  которые дистрибьютят хедеры
[38:01.680 --> 38:03.680]  и какую-то библиотеку
[38:03.680 --> 38:05.680]  скомпилированную, DLL-ку.
[38:05.680 --> 38:07.680]  Этого достаточно. Все, у вас там
[38:07.680 --> 38:09.680]  все полиморфные ваши поведения будут работать.
[38:09.680 --> 38:11.680]  Вы в саму эту DLL-ку можете скармливать
[38:11.680 --> 38:13.680]  свои классы по интерфейсам
[38:13.680 --> 38:15.680]  библиотеки, и все будет работать.
[38:15.680 --> 38:17.680]  Это же вообще магия.
[38:17.680 --> 38:19.680]  И не вам не нужно свои сурсы отдавать другим
[38:19.680 --> 38:21.680]  людям. Не другим людям ваши сурсы
[38:21.680 --> 38:23.680]  свои сурсы вам показывать не
[38:23.680 --> 38:25.680]  надо.
[38:25.680 --> 38:27.680]  Экономия кода в бинаре.
[38:27.680 --> 38:29.680]  Это относительно, но там
[38:29.680 --> 38:31.680]  камень в огород расто.
[38:31.680 --> 38:33.680]  Да и не только расто.
[38:33.680 --> 38:35.680]  Всегда, когда вы делаете статический полиморфизм,
[38:35.680 --> 38:37.680]  вы раздуваете количество памяти.
[38:37.680 --> 38:39.680]  Мы там говорили
[38:39.680 --> 38:41.680]  про iCache и вот это все.
[38:43.680 --> 38:45.680]  И то, что у нас
[38:45.680 --> 38:47.680]  культ джавы был,
[38:47.680 --> 38:49.680]  нам тоже дает преимущество. При использовании вот этого
[38:49.680 --> 38:51.680]  у нас очень много опыта.
[38:51.680 --> 38:53.680]  Мы знаем всякие паттерны, мы там умеем
[38:53.680 --> 38:55.680]  делать хорошо, знаем, как делать плохо
[38:55.680 --> 38:57.680]  не надо, но все равно делаем.
[38:59.680 --> 39:01.680]  То есть, ну, витейбл-полиморфизм
[39:01.680 --> 39:03.680]  в принципе всем хорош, кроме одного
[39:03.680 --> 39:05.680]  он медленный.
[39:05.680 --> 39:07.680]  Ну и нифига неудобный.
[39:07.680 --> 39:09.680]  Потому что, если вы там колбэк какой-нибудь
[39:09.680 --> 39:11.680]  передаете по интерфейсу,
[39:11.680 --> 39:13.680]  ну очень неудобно каждый раз, когда вам надо
[39:13.680 --> 39:15.680]  какое-нибудь продолжение
[39:15.680 --> 39:17.680]  фьюча навесить, брать и создавать
[39:17.680 --> 39:19.680]  новый класс. Ну это же дичь.
[39:19.680 --> 39:21.680]  Не хотим так делать. А вот есть статический
[39:21.680 --> 39:23.680]  полиморфизм, который на шаблонах.
[39:23.680 --> 39:25.680]  Он супер быстрый, супер классный.
[39:25.680 --> 39:27.680]  Там все за inline, force inline
[39:27.680 --> 39:29.680]  и везде пропишем. Кайф.
[39:29.680 --> 39:31.680]  Ну, сурсы придется показать
[39:31.680 --> 39:33.680]  конечно всем, ну, что поделать.
[39:35.680 --> 39:37.680]  Вот эта вот параметричность
[39:37.680 --> 39:39.680]  и кастомизация поведения, это кажется про специализацию,
[39:39.680 --> 39:41.680]  я хотел сказать, но не суть важна.
[39:41.680 --> 39:43.680]  Кодом меньше можно
[39:43.680 --> 39:45.680]  написать, да. Когда ВОП обычно пишете,
[39:45.680 --> 39:47.680]  там начинается чехарда с иерархией
[39:47.680 --> 39:49.680]  на 100 классов и какие-то факторы,
[39:49.680 --> 39:51.680]  менеджеры, адаптеры, чтобы
[39:51.680 --> 39:53.680]  нормально все было.
[39:55.680 --> 39:57.680]  А с шаблонами можно просто взять и
[39:57.680 --> 39:59.680]  ну просто написать код, там как-то
[39:59.680 --> 40:01.680]  компактнее дженерали получается.
[40:01.680 --> 40:03.680]  Да, типа безопасность, это очень
[40:03.680 --> 40:05.680]  здорово. Вы там не можете какой-нибудь...
[40:07.680 --> 40:09.680]  Ладно, у меня нет хорошего
[40:09.680 --> 40:11.680]  примера, ну там всякие вот
[40:11.680 --> 40:13.680]  по указателям что-то не то
[40:13.680 --> 40:15.680]  такое бывает в джайве.
[40:15.680 --> 40:17.680]  Наверное, нет.
[40:21.680 --> 40:23.680]  Ну, короче, в джайве за затирание типов
[40:23.680 --> 40:25.680]  там нужно ставить как-то аннотацию,
[40:25.680 --> 40:27.680]  что типа ты не будешь
[40:27.680 --> 40:29.680]  очень
[40:29.680 --> 40:31.680]  плохо кастить
[40:31.680 --> 40:33.680]  массив листа винтовка,
[40:33.680 --> 40:35.680]  массива листа каких-то
[40:35.680 --> 40:37.680]  других объектов. Ну, что-то там есть,
[40:37.680 --> 40:39.680]  какие-то приколы, да, даже с
[40:39.680 --> 40:41.680]  динамик кастами или как они в джаве,
[40:41.680 --> 40:43.680]  инстансов и вот эти вот вещи,
[40:43.680 --> 40:45.680]  там с ними какие-то проблемы могут возникнуть
[40:45.680 --> 40:47.680]  в рантайме, где вы пойдете в обход
[40:47.680 --> 40:49.680]  системы типов и все поломаете.
[40:49.680 --> 40:51.680]  Ну, с шаблонами мы как бы все в компелтайме
[40:51.680 --> 40:53.680]  делаем, поэтому не сломаем.
[40:53.680 --> 40:55.680]  Ну, и наконец у нас быстро все работает.
[40:55.680 --> 40:57.680]  Что хорошо.
[41:03.680 --> 41:05.680]  Мы хотим взять лучше от обоих миров
[41:05.680 --> 41:07.680]  в каком-то смысле, в каком,
[41:07.680 --> 41:09.680]  ну, поймем позже,
[41:09.680 --> 41:11.680]  потому что сейчас время кодить,
[41:11.680 --> 41:13.680]  а точнее, думаю,
[41:13.680 --> 41:15.680]  перерыв.
