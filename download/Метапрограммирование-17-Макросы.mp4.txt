[00:00.000 --> 00:11.380]  Ну что, молодые люди, по запросам трудящихся будет
[00:11.380 --> 00:15.640]  рассказ у нас про макросы, просто отвратительные.
[00:15.640 --> 00:18.600]  Все эти макросы тоже просто отвратительные.
[00:18.600 --> 00:26.560]  Это как Некрономикон прочитать, обратно уже не вернуться.
[00:26.560 --> 00:28.520]  Если вы готовы, то мы пойдём.
[00:28.520 --> 00:33.280]  Наверное, все мы должны знать, что такое препроцессор.
[00:33.280 --> 00:35.680]  Но это не так.
[00:35.680 --> 00:39.280]  Мы вообще не знаем ничего про препроцессор.
[00:39.280 --> 00:43.640]  Вам только кажется, что подставляем, и всё работает.
[00:43.640 --> 00:47.840]  Сейчас будет слайдов 20 про то, как он работает.
[00:47.840 --> 00:52.880]  Ну, значит, define есть.
[00:52.880 --> 00:57.040]  Define macros, вот такие макросы без круглых скобок.
[00:57.040 --> 00:58.840]  О, четвёртый человек пришёл.
[00:58.840 --> 00:59.280]  Ура!
[00:59.280 --> 01:05.840]  Макрос без скобок называется объектным, а со скобочками функциональным.
[01:05.840 --> 01:08.880]  Сначала с объектными макросами разберёмся.
[01:08.880 --> 01:12.400]  Начинаем идти слева направо.
[01:12.400 --> 01:15.520]  Понятно, что он по строкам идёт, отдельно и независимо.
[01:15.520 --> 01:16.880]  Это препроцессор.
[01:16.880 --> 01:22.040]  Каждую строку он начинает идти слева направо, под токеном.
[01:22.040 --> 01:25.960]  Токены, я думаю, примерно представляем, что такое.
[01:25.960 --> 01:28.080]  Тут детали не так важные.
[01:28.080 --> 01:32.280]  Всё, что не идентификатор, мы тупо пропускаем.
[01:32.280 --> 01:35.720]  Знак плюс, а это знак плюс, и не идентификатор пропустили.
[01:35.720 --> 01:37.640]  X, он идентификатор.
[01:37.640 --> 01:40.840]  Дальше начинается что-то странное.
[01:40.840 --> 01:42.520]  Вот он не синий здесь.
[01:42.520 --> 01:45.560]  Я думаю, вы согласны, что вот это красное не синий,
[01:45.560 --> 01:47.880]  поэтому мы просто идём дальше.
[01:47.880 --> 01:51.160]  Но это также не макрос.
[01:51.160 --> 01:54.880]  Вот нету никакого макроса, который типа define X.
[01:55.360 --> 01:58.080]  Поэтому мы просто его пропускаем.
[01:58.080 --> 02:02.880]  А вот на токене объект мы уже увидим, что он таки макрос.
[02:02.880 --> 02:07.680]  А дальше есть условие, что нет некоторого дизайблинг-контекста.
[02:07.680 --> 02:10.400]  Это вот DC будем называть дальше.
[02:10.400 --> 02:14.400]  Тоже пока непонятно, что такое, но вот две важные мысли.
[02:14.400 --> 02:17.080]  Чтобы всё у нас шло дальше хорошо,
[02:17.080 --> 02:20.880]  и подстановка произошла, нужно, чтобы не было синего цвета,
[02:20.880 --> 02:24.800]  где его сейчас нет, не было дизайблинг-контекстов.
[02:25.120 --> 02:28.240]  А макрос объектный, поэтому там простые правила.
[02:28.240 --> 02:30.240]  Просто берём и подставляем.
[02:30.240 --> 02:35.280]  Ну, тут ещё есть кое-что, всякие решётка токен в макросах.
[02:35.280 --> 02:37.280]  Знаете про такое?
[02:37.280 --> 02:38.000]  Остальные.
[02:38.000 --> 02:39.760]  Ну, сейчас увидим во всяком случае.
[02:39.760 --> 02:42.720]  Там две решётки ещё есть, чтобы конкатонацию делать.
[02:42.720 --> 02:45.440]  Но тут всего этого нет, поэтому мы просто подставляем.
[02:45.440 --> 02:47.440]  1, 2, 3.
[02:48.480 --> 02:50.480]  И никуда дальше не идём.
[02:50.480 --> 02:52.480]  Вот это ключевое.
[02:52.480 --> 02:54.480]  Мы остаёмся на том же токене,
[02:55.840 --> 02:58.720]  но при этом создали object-DC,
[02:58.720 --> 03:01.760]  то есть дизайблинг-контекст для макроса-обжекта.
[03:02.480 --> 03:06.240]  Ну, я думаю, по названию уже понятно, что эта шняга говорит о том,
[03:06.240 --> 03:11.360]  что больше в рамках вот этого вот интервала токенов
[03:11.360 --> 03:13.760]  раскрывать макрос-обжекта нельзя.
[03:15.520 --> 03:18.240]  Ну, понятно, что это нужно, чтобы не было рекурсии, правда?
[03:18.240 --> 03:20.880]  То есть если мы определили object-object?
[03:20.880 --> 03:21.680]  Да.
[03:21.680 --> 03:25.360]  То вот этот дизайблинг-контекст бы сказал, второй раз раскрывать уже не надо.
[03:26.000 --> 03:26.880]  Поэтому мы...
[03:26.880 --> 03:29.600]  Ну, у нас тут не object-object, у нас тут 1, 2, 3.
[03:29.600 --> 03:31.120]  Это не идентификатор.
[03:31.120 --> 03:34.080]  Соответственно, вот теперь мы можем идти дальше.
[03:34.080 --> 03:37.760]  И так как мы вышли за рамки дизайблинг-контекста полностью,
[03:37.760 --> 03:40.160]  и больше нам ничего не интересно, что раньше было,
[03:40.160 --> 03:42.160]  мы его выкидываем.
[03:42.160 --> 03:44.800]  Ну и последнее, тоже не идентификатор, скипаем.
[03:44.800 --> 03:46.240]  Окей.
[03:46.240 --> 03:48.240]  Пока не очень сложно.
[03:48.960 --> 03:50.640]  Сейчас будет чуть сложнее.
[03:50.640 --> 03:54.960]  Вот как object-object, только, ну, object-object, очевидно уже, что не работает.
[03:54.960 --> 03:57.520]  Давайте вот define-им A как B, а B как A.
[03:57.520 --> 03:59.520]  Вдруг сейчас получится?
[04:00.960 --> 04:03.120]  Ну, вот такая последовательствия, звездочка.
[04:03.120 --> 04:05.440]  А это объектный макрос, ничего там нету,
[04:05.440 --> 04:08.400]  что мы проговаривали не синий, не дизайлинг-контекстов.
[04:08.400 --> 04:09.200]  Ой.
[04:10.880 --> 04:12.080]  Уберись.
[04:15.520 --> 04:16.480]  Иди.
[04:17.840 --> 04:20.560]  Так, поэтому мы просто его подставляем.
[04:21.280 --> 04:23.280]  Подставляем, получили B.
[04:23.280 --> 04:25.280]  Дизайблинг-контекст на A висит.
[04:28.000 --> 04:30.000]  Ну, мы все еще здесь.
[04:30.000 --> 04:32.400]  Видим B, это объектный макрос.
[04:32.400 --> 04:34.400]  Надо его подставить.
[04:34.400 --> 04:36.400]  Получили вот такую конструкцию,
[04:36.400 --> 04:39.200]  где теперь A лежит внутри.
[04:39.200 --> 04:44.320]  Да, у нас только A, и оно вокруг обернуто в дизайблинг-контексте для B,
[04:44.320 --> 04:47.040]  и все вокруг в дизайблинг-контексте для A.
[04:48.000 --> 04:54.720]  И вот когда мы обнаружили A внутри дизайблинг-контекста для самого же A,
[04:54.720 --> 04:58.800]  мы покрасим в синий этот токен A,
[04:58.800 --> 05:01.760]  а все синие токены мы просто пропускаем.
[05:01.760 --> 05:04.400]  То есть, тут такая конструкция будет.
[05:06.400 --> 05:07.920]  Вот.
[05:08.640 --> 05:12.880]  И вот эта синяя краска достаточно долго на самом деле живет.
[05:12.880 --> 05:16.080]  Она просто никогда не исчезает, насколько я помню.
[05:16.400 --> 05:20.160]  И вот тут был простой кейс, что покрасили в синий, и уже сразу ушли.
[05:20.160 --> 05:26.720]  Но могло быть хуже, могло быть, что мы там заново это пройдемся по всей этой последовательности по тем или иным причинам.
[05:26.720 --> 05:28.720]  Эта синяя краска, она останется.
[05:28.720 --> 05:31.280]  И больше не позволит нам этот A раскрывать.
[05:32.400 --> 05:34.960]  Вот. Какая-то такая процедура.
[05:34.960 --> 05:36.960]  Теперь с функциональными макросами надо.
[05:39.520 --> 05:41.520]  Функциональный макрос.
[05:41.520 --> 05:44.480]  Следующий токен — это его инвокация,
[05:44.480 --> 05:49.360]  потому что если токена открывающей скобки нет, то мы его оставим, как есть.
[05:51.360 --> 05:57.120]  Видим в некоторой табличке, которая в компиляторе хранится, информацию про макросы.
[05:57.120 --> 06:02.000]  Что вот был такой макрос функциональный объявлен, и у него нету аргументов.
[06:02.000 --> 06:06.560]  Он нулярный, так что мы смотрим, чтобы дальше была закрывающая круглая скобка.
[06:06.560 --> 06:09.760]  Если ее не найдется, мы идем дальше без изменений.
[06:09.760 --> 06:11.760]  По-моему, так.
[06:11.760 --> 06:13.760]  Или могу соврать.
[06:14.240 --> 06:16.240]  Забудьте, что я сейчас сказал.
[06:17.760 --> 06:19.040]  Раскрываем.
[06:19.040 --> 06:22.960]  Но вот тут раскрытие уже идет с вот этими вот приколами.
[06:24.960 --> 06:31.040]  Раскрываются все конкотинации внутри этого макроса.
[06:31.760 --> 06:35.920]  То есть вы могли просто даже, несмотря на то, что у вас нет аргументов,
[06:35.920 --> 06:38.400]  взять и написать конкотинацию каких-то токенов,
[06:38.400 --> 06:42.240]  и вам плюсы слепят эти токены вместе, и будет один токен.
[06:42.720 --> 06:44.240]  И вот как только...
[06:44.240 --> 06:48.240]  Да, и причем это раскрытие, оно происходит до подстановки.
[06:48.240 --> 06:51.920]  То есть мы как бы отдельно, виртуально смотрим вот в эту часть,
[06:51.920 --> 06:55.920]  и вот здесь все сконкотинируем, и только потом уже подставляем на место.
[06:55.920 --> 06:57.920]  И получится вот это.
[06:59.920 --> 07:01.920]  Давайте еще раз поупражняемся.
[07:01.920 --> 07:06.720]  Тот же самый прикол с А и Б, но функциональные макросы теперь.
[07:06.720 --> 07:10.240]  Ну да, слайдов нету.
[07:10.240 --> 07:14.240]  Но я думаю понятно, что работать будет примерно так же.
[07:14.240 --> 07:18.240]  Все просто будет полностью подставляться, и все будет работать.
[07:18.240 --> 07:20.240]  А вот интереснее вот так.
[07:24.240 --> 07:26.240]  Видите, что происходит?
[07:30.240 --> 07:36.240]  Ну вот мы подставляем вместо А Б, и получаем вот такую штуку.
[07:36.240 --> 07:42.240]  Одну скобку сожрали вместе с А, и получили дизейблинг-контекст на А.
[07:42.240 --> 07:48.240]  Казалось бы, ну окей, теперь есть вот такой вот вызов Б.
[07:48.240 --> 07:50.240]  Его тоже надо подставить.
[07:50.240 --> 07:52.240]  Но мы возьмем и подставим.
[07:54.240 --> 07:58.240]  Но после этого пропадет дизейблинг-контекст на А.
[07:58.240 --> 08:00.240]  К чему-то.
[08:00.240 --> 08:04.240]  Ну, строгой причиной я объяснить не могу.
[08:04.240 --> 08:06.240]  Потому что тут происходит магия.
[08:06.240 --> 08:12.240]  Но интуитивная причина в том, что новый вызов инвокации, так называемая макрос,
[08:12.240 --> 08:18.240]  Б, круглые скобки, она не полностью лежала внутри дизейблинг-контекста А.
[08:18.240 --> 08:26.240]  Так как мы не полностью были внутри ДЦА, мы старые ДЦ просто выкидываем,
[08:26.240 --> 08:28.240]  стоимся только с ДЦ на Б.
[08:28.240 --> 08:30.240]  Ну и можно опять А раскрыть.
[08:30.240 --> 08:32.240]  И опять раскроем.
[08:32.240 --> 08:36.240]  И в конце-то, когда идем до Б, уже без скобок.
[08:36.240 --> 08:38.240]  И вот он уже будет покрашен синий.
[08:38.240 --> 08:40.240]  Какая мораль?
[08:46.240 --> 08:48.240]  Вот А круглые скобки.
[08:48.240 --> 08:52.240]  А Б все покрашен синий и больше нечего раскрывать.
[08:52.240 --> 08:56.240]  Вот мы его не можем раскрыть, потому что скобок нет, действительно.
[09:02.240 --> 09:04.240]  Давай считать, что да.
[09:04.240 --> 09:06.240]  Я не помню.
[09:06.240 --> 09:13.240]  Можно открыть сейчас подробное объяснение с почтовой рассылки какого-то 90-го года,
[09:13.240 --> 09:19.240]  где мужик, который пишет при процессе РС, все это объясняет в деталях.
[09:19.240 --> 09:24.240]  Ну судя по тому, что я на слайдах сделал вот так, наверное, все-таки действительно получается так,
[09:24.240 --> 09:29.240]  что если мы увидели макрос, скобок нет, но он в дизейблинг-контексте,
[09:29.240 --> 09:31.240]  то мы покрасим его синий.
[09:31.240 --> 09:33.240]  Он в дизейблинг-контексте А, нет?
[09:35.240 --> 09:37.240]  Значит, я немного соврал.
[09:37.240 --> 09:41.240]  Значит, дизейблинг-контекст Б он как-то остается.
[09:41.240 --> 09:45.240]  Да, ну вот, видимо, я в этом месте соврал, что дизейблинг-контекст А выкидывается.
[09:45.240 --> 09:51.240]  Он не то чтобы выкидывается, он просто не влияет на это.
[09:53.240 --> 09:55.240]  Или дизейблинг-контекст А со скобочек.
[09:55.240 --> 09:59.240]  Ну да, дизейблинг-контекст был у нас на первом токене.
[09:59.240 --> 10:03.240]  И как бы после того, как такая подстановка произошла...
[10:03.240 --> 10:07.240]  В смысле, неправильно описано А, Д, С, а можно А, скобочки, Д, С?
[10:07.240 --> 10:09.240]  Нет, нет.
[10:09.240 --> 10:11.240]  Дизейблинг-контекста это типа...
[10:12.240 --> 10:14.240]  Фактически что это такое?
[10:14.240 --> 10:18.240]  Это два индекса, начиная с какого токена и по какой.
[10:18.240 --> 10:22.240]  И макрос, прямо вот его название.
[10:22.240 --> 10:24.240]  Вот либо А, либо Б.
[10:24.240 --> 10:28.240]  То есть тут вот именно так, и видимо смысл в том, что у нас при подстановке Б
[10:28.240 --> 10:33.240]  как бы вот этот дизейблинг-контекст на А, он остается только на вот эту А.
[10:33.240 --> 10:38.240]  Но инвокация вся вместе, она там не влазит в дизейблинг-контекст.
[10:40.240 --> 10:42.240]  Ну, что-то такое.
[10:42.240 --> 10:45.240]  Они могут быть функциональными объектами?
[10:45.240 --> 10:47.240]  Нет.
[10:47.240 --> 10:50.240]  Каждый макрос он один, уникальный, никакой перегрузки.
[10:50.240 --> 10:52.240]  Нет, ничего такого нет.
[10:52.240 --> 10:54.240]  Ну вот, тут происходит какая-то...
[10:54.240 --> 10:56.240]  Они перезаписывают, да?
[10:57.240 --> 11:00.240]  Нет, если ты два раза Defina сделаешь, то у тебя будет ошибка.
[11:00.240 --> 11:04.240]  Нужно сначала Undef сделать, чтобы старые объявления убрать.
[11:04.240 --> 11:06.240]  Потом новое можно уже сделать.
[11:10.240 --> 11:12.240]  Но тут мутно все.
[11:12.240 --> 11:13.240]  Мутно.
[11:13.240 --> 11:17.240]  Я не смогу сейчас вот за эту одну лекцию полностью вам рассказать.
[11:17.240 --> 11:22.240]  Так, чтобы у вас в голове модель была, и которую вы могли в голове раскрывать эти макросы.
[11:22.240 --> 11:23.240]  Отлично.
[11:23.240 --> 11:27.240]  Поэтому я вас мотивирую прочитать про это смостоятельно.
[11:27.240 --> 11:32.240]  Если то, что будет дальше, вам покажется полезным хоть сколько-то в вашей практике.
[11:32.240 --> 11:37.240]  Но вот как факт, здесь есть вот эти лютые механизмы с дизейблинг-контекстами и синей краской.
[11:37.240 --> 11:43.240]  Вот они нужны, чтобы не было рекурсии, и мы при процессоре не зацикливались навечно.
[11:43.240 --> 11:48.240]  Ну и опять же, как факт с неба, вот такая конструкция работает.
[11:48.240 --> 11:54.240]  Все эти синие краски, дизейблинг-контексты, они не запрещают этого.
[11:54.240 --> 11:56.240]  Просто оно так получается.
[11:56.240 --> 12:03.240]  В частности, объяснение на сайтике и в почтовой рассылке, которое плотно читал,
[12:03.240 --> 12:10.240]  оно вот про это очень акцентировало внимание, что вот эта вот инвокация, она не вложена в это.
[12:10.240 --> 12:13.240]  Там есть понятие географикали-нестинг.
[12:13.240 --> 12:15.240]  Не знаю, где здесь географию они нашли.
[12:15.240 --> 12:19.240]  Но когда вот такое происходит, у нас как бы дизейблинг-контексты перестают работать.
[12:19.240 --> 12:24.240]  Ну и можно поверить, что в целом вся вот эта конструкция работает и не вырубается
[12:24.240 --> 12:29.240]  после первых двух раскрытий, ровно из-за того, что вот этого и это не вложено.
[12:29.240 --> 12:34.240]  А может, я и на самом деле соврал, что здесь синие красится,
[12:34.240 --> 12:38.240]  и в этом все проблемы, и на самом деле все просто.
[12:38.240 --> 12:43.240]  Предлагаю это пропустить, можно потом вернуться в конце и посмотреть этот mailing list.
[12:43.240 --> 12:48.240]  Внутри defi надо добавляться скобки?
[12:48.240 --> 12:53.240]  Внутри defi надо добавляться скобки.
[12:53.240 --> 13:00.240]  Написать сюда сами скобки мы можем, да.
[13:00.240 --> 13:03.240]  И они будут раскрываться или...
[13:03.240 --> 13:08.240]  Если там очень скобки, то они не раскроются, потому что они будут полностью лежать в децентре.
[13:08.240 --> 13:10.240]  Отличное замечание делаешь.
[13:10.240 --> 13:12.240]  Предлагаю это проверить.
[13:21.240 --> 13:23.240]  Как мы будем эту фигню проверять?
[13:23.240 --> 13:24.240]  Мы будем...
[13:26.240 --> 13:30.240]  Да нет, ну можно с минус E, я сейчас попроще сделаю.
[13:30.240 --> 13:33.240]  Не спрашивайте, что я сейчас пишу, надо.
[13:34.240 --> 13:35.240]  Ну вот и пошли.
[13:35.240 --> 13:46.240]  Define A, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E.
[13:46.240 --> 14:08.540]  так, ну вот и пошли defineA,B, defineB,A и попробуем сделать
[14:08.540 --> 14:24.980]  спаут, принт, от, что мы хотим, вот интересно, что получится. Вообще не стал раскрываться, да?
[14:24.980 --> 14:37.580]  Давайте вот так для олидации, что у меня вот эта вот херня правильно работает. А, ну вот, видите,
[14:37.580 --> 14:42.580]  вот это какая-то магия, я ее написал, она работает. Когда мы просто вот такие штуки делаем,
[14:42.580 --> 14:50.300]  кучу круглых скобок, то да, вот она полностью раскрылась, да, а вот если вот так, если AB впихнуть,
[14:50.300 --> 14:58.780]  то мы сколько скобок сожрали? Тут было раз, два, три, четыре, пять, шесть, а осталось пять. То есть один
[14:58.780 --> 15:12.580]  раз мы раскрыли вот эту всю фигню в B, две круглые скобки, да, сейчас А, их должно было быть на столько
[15:12.580 --> 15:22.780]  же остаться, да, ровно шесть осталось. Потом мы один раз раскрыли B, получилось А и пять круглых
[15:22.780 --> 15:28.940]  скобок. Ну и, видимо, действительно, вот этот disabling-контекст, он как бы получился длиннее. Когда
[15:28.940 --> 15:34.540]  мы вот эту штуку раскрывали, она раскрылась вот в это, и вся эта шняга попала в disabling-контекст,
[15:34.540 --> 15:41.700]  и типа и длина его было три символа, и тут она осталась три символа. Вот, то есть, видимо,
[15:41.700 --> 15:53.940]  в этом дело. Экспериментально выяснено. А если и Y? Тут уже есть скобки, еще скобки.
[15:53.940 --> 16:05.340]  Сколько у нас уявилось? Шесть, нет, семь. То есть на первом раскрытии у нас получилось семь скобок,
[16:05.340 --> 16:11.460]  потому что мы два раза подставили, да. После этого мы решили раскрывать B и раскрыли в А,
[16:11.460 --> 16:25.940]  ну и есть то же самое. На какой? Вот одни скобки пропали, ну потому что вот так подставилось. Но это
[16:25.940 --> 16:32.300]  все неважно, потому что disabling-контекст, типа вот такой получился, видимо, пять символов. Все это
[16:32.300 --> 16:45.300]  в нем, поэтому macros не получилось раскрыть. Вот, ну хорошо, подразобрались. Но это все очень круто,
[16:45.300 --> 16:57.300]  на самом деле, потому что это позволит нам делать последовательности в при процессоре. Последовательность
[16:57.300 --> 17:06.500]  это вот такая шняга. Куча скобок друг за другом написаны. Внутри каждых скобок по чему-то. Можно
[17:06.500 --> 17:14.100]  букву, можно цифру, можно какой-то код на плюсах. А дальше с этими последовательностями можно
[17:14.100 --> 17:20.060]  творить непотребство. Можно взять и свернуть эту последовательность вот ровно таким алгоритмом,
[17:20.060 --> 17:26.340]  с как бы A и B, вот такими вот. Тут теперь параметр появился. Мы пока еще не сказали, как эти
[17:26.340 --> 17:34.140]  параметры работают, но тут, очевидно, они работают. И когда мы вот элементарно напишем A и my macrosec,
[17:34.140 --> 17:44.420]  вот это вот все, оно как бы тоже начнет раскрываться волшебным образом. Ну, с некоторой оговоркой,
[17:44.420 --> 17:50.380]  вот просто так, по-моему, не сработает, оговорка будет позже. Ну, пока интуитивно можно представить,
[17:50.380 --> 17:57.660]  что мы macrosec заменили на вот эти скобки и начали сворачивать. Ну, мы пока так не умеем,
[17:57.660 --> 18:02.340]  но скоро научимся, чтобы сначала второй подставить, потом первый. Потому что если в тупую начать эта
[18:02.340 --> 18:07.340]  парсия, то мы пойдем слева направо, увидим функциональный macros A, увидим, что справа токен,
[18:07.340 --> 18:12.980]  это не скобка, и пропустим, и ничего не произойдет. То есть представим, что мы два раза запустили при
[18:12.980 --> 18:17.860]  процессорной этой строке просто. Первый раз мой macrosec подставится, а второй раз у нас уже будет A
[18:17.860 --> 18:24.900]  и куча скобок. И мы вот эти скобки начнем просто раскрывать, раскрывать, раскрывать. Каждый раз вот эти
[18:24.900 --> 18:32.300]  вот A и B, такая рекурсивная функция, она дописывает то, что пришло в аргументы, в начало, и получается
[18:32.300 --> 18:44.260]  через пробел A, B, C, D, E. А можно не через пробел, можно через знак плюсика. О, просто написал его сюда.
[18:44.260 --> 18:53.060]  Прикольно, да? Можно просто взять и какой-то список чего-то взять и вот так вот через запятую написать,
[18:53.060 --> 19:00.340]  через плюсик. Чем-то фолды напоминает. Но это не единственный способ задавать в каком-то смысле
[19:00.340 --> 19:22.140]  последовательности при процессоре. Поэтому в конце нужно дописать ноль. Ну, значит, так просто не
[19:22.140 --> 19:33.300]  прокатывает, да? Тут надо, короче, колдовать. Вот так просто не будет, но давайте пока мне поверим,
[19:33.300 --> 19:43.340]  что можно вот эту проблему побороть кое-как. Большая буква не исчезнет. Ну, можно с этим...
[19:43.340 --> 19:53.740]  Можно как-то закостылять, очень легко это. Одновременно объектный и функциональный
[19:53.740 --> 20:04.420]  макрос нельзя у нас объявить. Просто от буквы избавиться. Короче, ладно, без хитрых фокусов не выйдет,
[20:04.420 --> 20:10.820]  но вы можете в той точке, где этот код написали, просто взять и написать типа int A равно нулю,
[20:10.820 --> 20:16.900]  оно тоже сработает, потому что осталось A, ну и осталось. Теперь это не какой-то токен при процессоре,
[20:16.900 --> 20:23.180]  это перебедное, которое там значение есть. Ну, вот такие штуки можно делать. Конечно,
[20:23.180 --> 20:32.380]  вот да, правильное замечание про лишнее в конце. Скоро поборем. Вот, теперь надо с аргументами. Тут
[20:32.380 --> 20:39.620]  есть маленькая деталь, но из которой вытекает масса следствий. Ну, первых, аргументы у нас
[20:39.620 --> 20:45.300]  разделены только запятыми, и вложенность проверяется только через круглые скобки.
[20:45.300 --> 20:53.780]  То есть, если вы когда-нибудь пробовали в макрос запихивать стд пейр от int и char через
[20:53.780 --> 21:00.820]  запятую, то у вас макрос все это распарсит, как стд пейр меньше int, это первый аргумент,
[21:00.820 --> 21:08.420]  а второй аргумент это char больше, и вот. Это немножко неприятно, но вот такова наша жизнь,
[21:08.420 --> 21:17.180]  и это надо помнить и иметь в виду. Можешь все в круглые скобки дополнительно обложить. То есть,
[21:17.180 --> 21:22.300]  вот оно уважает только круглые скобки, поэтому если ты напишешь макрос и два раза круглые скобки,
[21:22.300 --> 21:29.660]  то это будет один аргумент насильно, а не два аргумента или там больше даже. Теперь вот про
[21:29.660 --> 21:34.420]  подстановку. Когда у нас функциональный макрос есть аргументы, и происходит подстановка.
[21:34.420 --> 21:48.820]  Происходит она хитро. Мы сначала раскрываем вот эти вот решеточки с тем, что пришло к нам. То есть,
[21:48.820 --> 21:53.740]  это конконтанция. Пришел один токен, пришел другой, мы их конконтанировали, получили один.
[21:53.740 --> 22:00.660]  Потом происходит конверсия в строке. Решетка ARC это взять токен ARC и вот как его препроцессор
[22:00.660 --> 22:05.620]  видит как последовательность символов. Вот так сделать строковый литерал, то есть в кавычках
[22:05.620 --> 22:16.380]  написать. А дальше аргументы без всяких решеточек раскрываются. Но раскрываются они хитро.
[22:16.380 --> 22:31.980]  Да, сейчас тут есть некий прикол. Я вот тут сказал, что они не раскрываются пока. Ни конгодонации,
[22:31.980 --> 22:38.780]  ни подстановка строк не происходит. Мы только подставляем в текст макроса, в сам текст макроса,
[22:38.780 --> 22:45.380]  токены, которые снаружи пришли. Вот вы макрос запустили от каких-то строчек токенов, они пришли к
[22:45.380 --> 22:52.140]  вам внутрь и вы их подставляете сюда-сюда, сначала подставляете и туда, где нет решеток, тоже
[22:52.140 --> 22:58.180]  подставляете. Прям в тексте макроса, пока обратно не вернулись. И вот этот арг без решеточек,
[22:58.180 --> 23:06.980]  он рекурсивно сканируется еще раз. То есть заново запускается препроцессор на как бы тексте макроса.
[23:06.980 --> 23:14.900]  Только самом тексте макроса в изоляции от внешнего мира. Это очень смешной факт. Это,
[23:14.900 --> 23:21.820]  например, вам подставляет, пусть у вас есть макрос ассерт, знаете же, что ассерт это макрос,
[23:21.820 --> 23:35.780]  и вы туда подставили m, p. На самом деле, в какой момент m, p раскроется в 3,14? Оно раскроется вот
[23:35.780 --> 23:44.020]  в этот момент, потому что вы там где-то в ассерте, у вас какой-то код и там где-то вот эти вот аргументы
[23:44.020 --> 23:49.100]  использованы, которые прислали извне. И так как тут рекурсивное сканирование будет запущено,
[23:49.100 --> 23:56.660]  у вас это m, p еще до подстановки макрос ассерт обратно заменится на его значение. Сейчас
[23:56.660 --> 24:00.420]  увидим, какие еще последствия у этого есть. Вот, и только после того, как вот эти рекурсивные
[24:00.420 --> 24:07.740]  сканирования замечательные произошли, мы конкатенируем и превращаем в строки,
[24:07.740 --> 24:22.060]  причем с неопределенным порядком. Не уверен, что будет, если ты два раза решетку применишь.
[24:22.060 --> 24:36.460]  Наверное, оно два раза в кавычке возьмется. А, потому что пробела нет. Две решетки подряд это один токен,
[24:36.460 --> 24:44.140]  а одна решетка это другой токен. Вот. Прямо на уровне грамматики языка. То есть, если здесь
[24:44.140 --> 24:51.580]  пробел вляпнуть, то же самое, что равно пробел равно. Вот два равно это вместе. Вот. И только после
[24:51.580 --> 24:57.780]  всей вот этой вот чехарды, мы вот то, что у нас там наколдовалось внутри макроса, подставляем
[24:57.780 --> 25:06.180]  обратно в код программы. Вот здесь вот. И создаем дизайвлинг-контекст на этот макрос. Прошу прощения.
[25:06.180 --> 25:20.220]  Так, надо за временем следить. Ну вот. Да, оно раскрывает дефайны, которые были внутри аргументов,
[25:20.220 --> 25:28.260]  которые ты передал в этот макрос. Да. Потому что в функциональных есть аргументы. Вот если ты
[25:28.260 --> 25:36.300]  в эти аргументы передал какие-то другие макросы, то они еще внутри обработки этой подстановки будут
[25:36.300 --> 26:03.020]  раскрыты. Где? Вот здесь? Нет, смотри, в наших примерах нету никаких аргументов. Наверное,
[26:03.020 --> 26:14.660]  немножко мутно говорю, поэтому скажу более явно. Вот если есть аргумент х, вот здесь х, и мы как бы
[26:14.660 --> 26:27.180]  напечатаем там а, круглые скобки, ноль. То вот этот ноль, он как бы просто подставился сейчас, да.
[26:27.180 --> 26:38.100]  А может это быть другой а. Вот. И вообще-то такое не должно работать, правда? Казалось бы. Потому что
[26:38.100 --> 26:45.820]  что будет происходить? Мы раскроем а как х, и будет а от нуля. И у нас как бы уже дизайвлинг-контекст.
[26:45.820 --> 26:51.980]  То есть вот было такое, мы раскрыли первый слой а, и уже дизайвлинг-контекст, и все, мы умерли. Да?
[26:51.980 --> 26:59.260]  Но это работает, потому что ты не сразу в текст программы подставляешь обратно, а сначала такую
[26:59.260 --> 27:05.180]  виртуальную программу отдельную компилируешь. Эта виртуальная программа, это как бы вот эта строчка,
[27:05.180 --> 27:13.820]  вот то, что в Define а написано. Но и там было написано х. Запустили это у нас с х равным вот такой
[27:13.820 --> 27:20.660]  последовательности токенов. А скобка ноль скобка. Поэтому мы подставляем а скобка ноль скобка еще
[27:20.660 --> 27:34.260]  внутри как бы макроса. Давайте это. Внутри макроса происходит. И раскрываем, пока без дизайвлинг-контекста.
[27:34.260 --> 27:40.060]  То есть заново вся эта процедура начинается, и после этого уже мы там подставим в качестве х0.
[27:40.060 --> 27:48.020]  А после этого мы вот в эту строчку, которую мы обрабатывали на данный момент, результат всей
[27:48.020 --> 27:54.500]  тысячи хорды, подставим вот этот результат, подставим вместо всего вызова а.
[27:54.500 --> 27:58.500]  А если в том случае не х, а, а скобка, а скобка и х?
[27:58.500 --> 28:00.260]  А скобка.
[28:00.260 --> 28:05.060]  Кинули а скобка и х. Типа еще раз обернусь в а скобка.
[28:05.060 --> 28:07.540]  Что еще раз?
[28:07.540 --> 28:08.900]  Еще раз обернусь в а скобка.
[28:08.900 --> 28:10.900]  Да.
[28:10.900 --> 28:14.420]  Там же без ка еще остается?
[28:14.820 --> 28:18.420]  Нет. Потому что дизайвлинг-контекста в какой-то момент появится.
[28:18.420 --> 28:20.420]  Внутри все поставляется, да?
[28:20.420 --> 28:25.420]  Ну внутри тоже дизайвлинг-контекста появляется. То есть мы просто рекурсивно запускаем
[28:25.420 --> 28:30.420]  препроцессор на более маленькой программе. С нуля как бы запускаем препроцессор.
[28:30.420 --> 28:34.420]  Ну не совсем с нуля, ладно. Но давай попробуем понять, что здесь происходит.
[28:34.420 --> 28:38.420]  Когда мы первый раз попали внутрь а?
[28:38.420 --> 28:42.420]  У нас там такой код написан, да?
[28:42.420 --> 28:46.420]  Но нам в качестве аргумента х выдали что?
[28:46.420 --> 28:48.420]  А от нуля.
[28:48.420 --> 28:50.420]  Давай подставим, а от нуля.
[28:50.420 --> 28:54.420]  Теперь надо вот это вот заново запропроцессить.
[28:54.420 --> 28:58.420]  Нет, вот нам а от нуля. Вот х был, а от нуля.
[28:58.420 --> 29:02.420]  Мы его подставили, и теперь заново запускаем препроцессор.
[29:02.420 --> 29:06.420]  Давайте я буду говорить правильное слово, сканирование.
[29:07.420 --> 29:11.420]  Ну вот сканирование, это мы сканируем всю строку токенов
[29:11.420 --> 29:13.420]  и выполняем подстановки препроцессора.
[29:13.420 --> 29:18.420]  Вот после того, как мы подставили вместо ха вот здесь то, что на самом деле нам прислали,
[29:18.420 --> 29:22.420]  мы еще как бы внутри вот этого кода а начинаем заново сканировать.
[29:22.420 --> 29:24.420]  Идем сканируем.
[29:24.420 --> 29:26.420]  Ну вот у нас вызов а.
[29:26.420 --> 29:30.420]  Только х, кажется ты прав.
[29:30.420 --> 29:34.420]  Кажется ты прав, мы сканируем только х.
[29:36.420 --> 29:38.420]  Ну да, было бы...
[29:38.420 --> 29:42.420]  Нет, даже если бы мы полностью сканировали, там бы все было хорошо.
[29:42.420 --> 29:44.420]  Ну вот...
[29:44.420 --> 29:48.420]  Мне кажется, мне интересно просто сканировать как аргумент.
[29:48.420 --> 29:50.420]  Очень-очень...
[29:53.420 --> 29:57.420]  Очень тяжело, конечно. Давай будем подглядывать.
[29:57.420 --> 30:01.420]  То есть вчера оно открывалось, а сегодня и не открывается, да?
[30:07.420 --> 30:11.420]  Или это MFTI-пишник забанен?
[30:12.420 --> 30:14.420]  Давайте-то я не знаю.
[30:14.420 --> 30:16.420]  Прокси откроем.
[30:23.420 --> 30:28.420]  Ну слушайте, это крайне печально, надо выгрузить эту цепочку писем,
[30:28.420 --> 30:32.420]  потому что без нее невозможно заниматься препроцессором.
[30:36.420 --> 30:42.420]  Может так найдется...
[30:42.420 --> 30:46.420]  Что?
[30:46.420 --> 30:52.420]  Ну давай поверим, что я правильно составил слайды.
[30:52.420 --> 30:56.420]  И предположим, что действительно только вот это сканируется заново.
[30:56.420 --> 30:58.420]  А, ну это и будет...
[30:58.420 --> 31:02.420]  Да, это действительно будет совпадать с тем, что у нас в итоге получилось.
[31:02.420 --> 31:07.420]  Потому что если бы полностью рисканировалось, чуть-чуть другой результат был бы, по-моему.
[31:07.420 --> 31:10.420]  Ладно, окей, вот это рисканируем.
[31:10.420 --> 31:12.420]  Ну и надо подстановку выполнить.
[31:12.420 --> 31:14.420]  А от нуля.
[31:14.420 --> 31:18.420]  А это что такое? Это АА и опять Х.
[31:18.420 --> 31:20.420]  И вот так.
[31:20.420 --> 31:22.420]  Правда? Правда.
[31:22.420 --> 31:25.420]  Все, мы подставили Х, рисканировали.
[31:25.420 --> 31:29.420]  И больше ничего делать не надо.
[31:29.420 --> 31:37.420]  Мы подставляем все вот это вот мясо, которое мы там наворотили обратно туда, где был принт.
[31:37.420 --> 31:45.420]  В частности, вот эта магия, которую я здесь написал, она же ровно так и работает.
[31:45.420 --> 31:50.420]  Зачем я завел два макроса принт?
[31:50.420 --> 31:57.420]  Давайте, чтобы вас немного не смущать, мы там заменим вот эти вот три точки, которые там на всякий случай стоят.
[31:57.420 --> 32:00.420]  На просто Х.
[32:06.420 --> 32:08.420]  Ничего не изменилось.
[32:08.420 --> 32:12.420]  Ну почему вот принт и принт нижнее подчеркивание?
[32:12.420 --> 32:18.420]  Давайте принт нижнее подчеркивание здесь напишу, который просто аргументы превращает в Х.
[32:18.420 --> 32:20.420]  В результат изменился.
[32:20.420 --> 32:22.420]  А что нам выдали?
[32:22.420 --> 32:24.420]  Нам выдали только вот эту штуку.
[32:24.420 --> 32:27.420]  Вот ровно то, что мы сюда вписали, нам и выдали.
[32:27.420 --> 32:29.420]  А почему?
[32:29.420 --> 32:36.420]  А потому что вот эта шняга, она подстанавливается, но рискан на нее не происходит.
[32:36.420 --> 32:43.420]  Вот, поэтому вот такой макрос принт, он просто выводит то, что вы в круглые скобки ему передали.
[32:46.420 --> 32:48.420]  Понятно?
[32:48.420 --> 32:50.420]  Давай.
[33:00.420 --> 33:05.420]  Да, сейчас мы это будем обузить.
[33:05.420 --> 33:08.420]  Так можно сделать. При желании можно.
[33:11.420 --> 33:13.420]  Вот.
[33:13.420 --> 33:15.420]  Чего?
[33:18.420 --> 33:21.420]  Что не будет раскроется само по себе?
[33:26.420 --> 33:29.420]  Я не могу понять, в чем вопрос.
[33:29.420 --> 33:35.420]  Ну вот, короче, вот так не работает, потому что это просто подставит вам вот сюда вот эти токены и ни разу их не просканирует.
[33:35.420 --> 33:38.420]  Они не были просканированы вообще эти токены.
[33:38.420 --> 33:47.420]  А если я сделаю вот так, то у меня при подстановке вот в этот макрос принт, вот эта вся шняга, она будет подстанавливаться как просто Х.
[33:47.420 --> 33:51.420]  И мы только что разобрали, что в таком случае рисканы запускаются.
[33:53.420 --> 33:57.420]  Что если написать принт2, который делает принт1?
[34:00.420 --> 34:04.420]  Ну, кстати, ничего не изменилось, на удивление. Видимо, у нас действительно такой макрос.
[34:04.420 --> 34:09.420]  Но не будем забегать вперед. Продолжим послайдовать, там все это будет.
[34:10.420 --> 34:12.420]  Окей. Так.
[34:12.420 --> 34:24.420]  Прошу прощения, я вчера пел весь вечер, был корпоратив, почувствовал себя певцом и тяжело говорить.
[34:24.420 --> 34:29.420]  Так, ну и из той же области примерчик.
[34:29.420 --> 34:32.420]  Только что принт я вам показывал на годбалте.
[34:32.420 --> 34:38.420]  Вот это конкат. Вы его можете, привет, вы его можете увидеть, ну, примерно везде.
[34:38.420 --> 34:45.420]  Ну, это очень частый макрос, вот куда ни плюнь, в любой кодовой базе он раза три хотя бы заново переизобретен.
[34:45.420 --> 34:47.420]  Точно.
[34:47.420 --> 34:50.420]  Ну и вы понимаете, почему он так работает, да?
[34:50.420 --> 34:56.420]  Потому что если просто конкат нижнее подчеркивание использовать, у вас вот эти аргументы ни разу не просканируются.
[34:56.420 --> 35:04.420]  И вот такой бы код вам бы просто вывел вот эту часть, первый аргумент, и второй аргумент, прилепленный к нему.
[35:04.420 --> 35:06.420]  И была бы фигня какая-то.
[35:06.420 --> 35:10.420]  А вот если вот так сделать, то у нас на аргументы рискан делается.
[35:10.420 --> 35:14.420]  И вот этот вот, вот этот аргумент весь зарисканится.
[35:14.420 --> 35:17.420]  И это хорошо.
[35:17.420 --> 35:23.420]  Ну, коли оно делает рискан, народ придумал магию.
[35:23.420 --> 35:27.420]  Он объявляет макроскан.
[35:27.420 --> 35:32.420]  Ну, народ, наверное, это вот типа много раз независимо было открыто разными людьми.
[35:32.420 --> 35:34.420]  Вот макроскан.
[35:34.420 --> 35:36.420]  Вот правоаргзы я еще не сказал, да?
[35:36.420 --> 35:38.420]  Но что это на самом деле?
[35:38.420 --> 35:42.420]  Вы можете сказать, что мне пофиг сколько мне прислали аргументов.
[35:42.420 --> 35:50.420]  Я их хочу воспринимать как просто последовательность токенов, некоторые из которых это запята.
[35:50.420 --> 35:55.420]  То есть вот это говорит, я принимаю любую последовательность токенов, включая запятые.
[35:55.420 --> 35:57.420]  Пофиг сколько их.
[35:57.420 --> 36:06.420]  А вот это говорит, подставь мне, пожалуйста, всю мою последовательность токенов вот сюда, включая запятые.
[36:06.420 --> 36:11.420]  Вот так об этом правильно думать, если я не путаю ничего.
[36:11.420 --> 36:13.420]  Ну и что это за макрос будет?
[36:13.420 --> 36:17.420]  Ну, вы ему любую последовательность токенов прислали в этот скан.
[36:17.420 --> 36:21.420]  А он их просто взял и как бы подставил как есть, ничего не поменяв.
[36:21.420 --> 36:24.420]  Но потом произойдет рискан.
[36:24.420 --> 36:32.420]  Это макрос, который еще раз раскрывает все макросы, которые были в этой последовательности токенов на один уровень.
[36:32.420 --> 36:34.420]  В чем понт?
[36:34.420 --> 36:39.420]  В том, что это на самом деле нам позволяет добиться в какой-то степени рекурсии.
[36:39.420 --> 36:44.420]  Потому что если мы там какой-то код написали там с какими-то A круглые скобки, B круглые скобки,
[36:44.420 --> 36:50.420]  и напоролись на то, что дизейблинг, контекст нам вырубает нашу рекурсию,
[36:50.420 --> 36:53.420]  то мы можем обойти это.
[36:53.420 --> 36:57.420]  Мы запустим скан два раза.
[36:57.420 --> 37:00.420]  Можно три раза, четыре раза.
[37:00.420 --> 37:09.420]  Каждый скан, то есть скан два это скан, и соответственно при этой подстановке один раз рискан произойдет.
[37:09.420 --> 37:11.420]  И при этой еще один раз.
[37:11.420 --> 37:16.420]  И мы просто заново будем эту последовательность токенов рисканировать.
[37:16.420 --> 37:19.420]  Каждый раз сбрасывая дизейблинг контексты.
[37:19.420 --> 37:24.420]  И мы просто увиливаем от этого и заново раскрываем, раскрываем, раскрываем.
[37:24.420 --> 37:26.420]  Ну и вот тут есть пример.
[37:26.420 --> 37:29.420]  Вот какой-то макрос, который в строку что-то превращает.
[37:29.420 --> 37:33.420]  Вот там A и B, они просто складывают X.
[37:33.420 --> 37:36.420]  И мы написали вот такой смешной код.
[37:36.420 --> 37:38.420]  str пробел A от единиц.
[37:38.420 --> 37:42.420]  Но это как бы не вызов функционального макроса.
[37:42.420 --> 37:45.420]  А вот это вызов.
[37:45.420 --> 37:48.420]  И если мы это запустим, то нам, например, процесс это вот так.
[37:48.420 --> 37:53.420]  str останется как есть, а вот эта фигня раскроется в 1 плюс 1.
[37:55.420 --> 37:58.420]  Но мы видим, что это можно еще раскрыть.
[37:58.420 --> 38:01.420]  Просто нужно просканировать еще раз.
[38:01.420 --> 38:04.420]  Давайте напишем scan.
[38:04.420 --> 38:08.420]  И он просканирует еще раз.
[38:08.420 --> 38:15.420]  И таки превратит, но каким-то немножко странным образом я подозреваю, что у меня здесь и печатка может быть.
[38:18.420 --> 38:20.420]  Значит, я себя как-то путаю.
[38:20.420 --> 38:23.420]  Потому что A...
[38:26.420 --> 38:28.420]  Что будет происходить?
[38:28.420 --> 38:31.420]  Мы подставляем scan, вот эту последовательность токенов.
[38:31.420 --> 38:32.420]  Вот туда.
[38:32.420 --> 38:34.420]  Или сканируем ее.
[38:34.420 --> 38:36.420]  str мы здесь не засканируем.
[38:36.420 --> 38:39.420]  Мы только A от единицы раскрываем.
[38:39.420 --> 38:41.420]  Scan принимает как?
[38:41.420 --> 38:44.420]  Это не через запятую принимает?
[38:44.420 --> 38:45.420]  Смотри.
[38:45.420 --> 38:47.420]  Scan – это вариадик макрос.
[38:47.420 --> 38:50.420]  Он принимает любую последовательность токенов.
[38:50.420 --> 38:51.420]  Любую.
[38:51.420 --> 38:53.420]  Раз токен, два токен, три, четыре, пять.
[38:53.420 --> 38:56.420]  Последовательность токенов – последовательность.
[38:56.420 --> 38:57.420]  Все.
[38:57.420 --> 38:59.420]  Тут запятые никак не влияют.
[38:59.420 --> 39:04.420]  То есть об этом не нужно думать в каких-то вариадиках C++ или C.
[39:04.420 --> 39:06.420]  Это просто любая последовательность токенов.
[39:06.420 --> 39:09.420]  То есть пробелы, можно через запятые, они ни на что не повлияют.
[39:12.420 --> 39:15.420]  В ARX просто всю последовательность токенов вот сюда впасчивает.
[39:15.420 --> 39:18.420]  Вот как она была, так ее и ляпает.
[39:20.420 --> 39:22.420]  Пробелы разделяют токены.
[39:23.420 --> 39:25.420]  Нет, это разделитель токенов.
[39:31.420 --> 39:33.420]  Ну да, пробелы вообще ни на что не влияют.
[39:33.420 --> 39:35.420]  Они просто разделитель токенов.
[39:35.420 --> 39:40.420]  В ARX подставится вот этот токен, потом вот этот, потом вот этот и этот.
[39:40.420 --> 39:42.420]  Короче, у меня какие-то сомнения.
[39:42.420 --> 39:46.420]  В сомнениях всегда надо вбивать good bolt, чтобы сомнений не было.
[39:50.420 --> 39:51.420]  Так.
[39:51.420 --> 39:53.420]  Принт вот этот мы оставим.
[39:53.420 --> 39:55.420]  Он нам там пригодится.
[39:57.420 --> 39:58.420]  Ну вот.
[39:58.420 --> 40:00.420]  И мы хотели посмотреть вот эти штуки.
[40:05.420 --> 40:07.420]  Здесь их где-нибудь вот так вот.
[40:11.420 --> 40:12.420]  Так.
[40:12.420 --> 40:16.420]  Принтить будем str a от единицы.
[40:20.420 --> 40:21.420]  Ну вот.
[40:21.420 --> 40:23.420]  Оно один раз просканировалось и один раз раскрылось.
[40:24.420 --> 40:26.420]  А, ну я понял, почему я так написал.
[40:27.420 --> 40:29.420]  Потому что если я сейчас скан дописываю сюда,
[40:29.420 --> 40:31.420]  то оно действительно вот так раскроется.
[40:31.420 --> 40:33.420]  Но это не совсем честно.
[40:34.420 --> 40:35.420]  А, ну ладно.
[40:35.420 --> 40:37.420]  Это все абсолютно честно.
[40:37.420 --> 40:39.420]  Это все абсолютно честно.
[40:39.420 --> 40:42.420]  Потому что, ну действительно, мы вот...
[40:43.420 --> 40:45.420]  Как же легко запутаться.
[40:45.420 --> 40:47.420]  Сейчас все, говорю как есть.
[40:47.420 --> 40:51.420]  При подстановке в скан вот эту фигню мы раскроем a от единицы.
[40:51.420 --> 40:52.420]  Так?
[40:52.420 --> 40:53.420]  Раскроем.
[40:53.420 --> 40:55.420]  Все остальное не раскроем.
[40:55.420 --> 40:57.420]  Это вот одна штука.
[40:57.420 --> 40:58.420]  Все остальное не раскроем.
[40:58.420 --> 41:00.420]  Это вот одно сканирование было.
[41:00.420 --> 41:01.420]  И потом вот это вот...
[41:01.420 --> 41:03.420]  Вот такое выражение получится, по сути, да?
[41:03.420 --> 41:04.420]  Внутри скана.
[41:04.420 --> 41:06.420]  Внутри скана будет вот это.
[41:06.420 --> 41:08.420]  Но потом вот это мы подставим обратно вот сюда.
[41:08.420 --> 41:10.420]  Где мы это написали.
[41:10.420 --> 41:12.420]  И продолжим сканирование.
[41:12.420 --> 41:16.420]  И увидим str от 1 плюс 1 ну и...
[41:18.420 --> 41:20.420]  В общем, один раз раскрывается макрос,
[41:20.420 --> 41:22.420]  а потом раскрывается то, что получились.
[41:22.420 --> 41:24.420]  Ну ты пропустил момент,
[41:24.420 --> 41:26.420]  где я все это объяснял подробнее.
[41:26.420 --> 41:30.420]  При подстановке аргументов в функциональный макрос
[41:30.420 --> 41:33.420]  аргументы сами по себе сканируются еще раз.
[41:33.420 --> 41:35.420]  Вот тут об этом речь.
[41:35.420 --> 41:37.420]  Ваарксы это как один аргумент или как много аргументов?
[41:37.420 --> 41:39.420]  Это один аргумент,
[41:39.420 --> 41:42.420]  но в котором могут быть запятые как просто полноценные токены.
[41:42.420 --> 41:45.420]  Так нет, вчера он два раза раскрывается.
[41:45.420 --> 41:48.420]  Первый раз оно раскрывается, когда мы вот здесь парсим ваарксы.
[41:48.420 --> 41:50.420]  Привет.
[41:51.420 --> 41:53.420]  Да, ну вот как мы принт смотрели.
[41:53.420 --> 41:55.420]  Да, или...
[41:56.420 --> 41:58.420]  Точно так же, как вот здесь раскрывались.
[41:58.420 --> 42:01.420]  Вот при подстановке сюда A и B раскрывались.
[42:01.420 --> 42:03.420]  Рискан происходил.
[42:03.420 --> 42:06.420]  Вот точно так же здесь ваарксы рисканятся.
[42:08.420 --> 42:10.420]  Это первый раз.
[42:10.420 --> 42:14.420]  Потом мы как бы завершили запускать вот этот вот макросскан.
[42:14.420 --> 42:16.420]  И весь результат... А результат вот такой получится.
[42:16.420 --> 42:19.420]  При первом сканировании вот этой строки
[42:19.420 --> 42:21.420]  результат будет вот такой.
[42:21.420 --> 42:23.420]  И вот этот результат мы подставим обратно туда,
[42:23.420 --> 42:25.420]  где скан запустили.
[42:25.420 --> 42:27.420]  То есть вот сюда.
[42:27.420 --> 42:29.420]  И продолжим сканирование.
[42:29.420 --> 42:31.420]  Потому что мы помним, да,
[42:31.420 --> 42:33.420]  после того как подстановка макроса произошла,
[42:33.420 --> 42:35.420]  мы не сдвигаемся вперед, мы продолжаем с той же точки.
[42:35.420 --> 42:37.420]  И сканируем еще раз.
[42:37.420 --> 42:39.420]  Поэтому уже получим вот такое.
[42:41.420 --> 42:43.420]  Жутко.
[42:43.420 --> 42:46.420]  То есть мы второе получаем вне скана уже, да?
[42:47.420 --> 42:49.420]  Чего?
[42:49.420 --> 42:51.420]  То есть у нас вне скана вы еще раз сканируете, да?
[42:51.420 --> 42:53.420]  Да-да-да, вне скана, просто потому что мы вот это при процессе
[42:53.420 --> 42:55.420]  еще одно сканирование.
[42:55.420 --> 42:57.420]  Но можно вот так написать еще.
[43:00.420 --> 43:02.420]  Будет вот такая забавная шняга.
[43:02.420 --> 43:04.420]  Почему, конечно, надо задуматься.
[43:07.420 --> 43:09.420]  Сколько раз здесь можно раскрыть?
[43:09.420 --> 43:13.420]  Первый раз раскроется от единицы при подстановке в скан.
[43:13.420 --> 43:15.420]  Так?
[43:15.420 --> 43:17.420]  Вот это вот внутри скана раскроется.
[43:17.420 --> 43:19.420]  Второй скан произойдет...
[43:19.420 --> 43:21.420]  Второй рескан произойдет,
[43:21.420 --> 43:23.420]  когда мы уже результат обратно сюда подставим,
[43:23.420 --> 43:27.420]  и здесь мы увидим b от вот этой фигни.
[43:27.420 --> 43:29.420]  То есть b от 1 плюс 1.
[43:29.420 --> 43:31.420]  Его тоже раскроем.
[43:31.420 --> 43:33.420]  И останется последовательность токенов str
[43:33.420 --> 43:37.420]  от того, что нам b от 1 плюс 1 вернуло.
[43:37.420 --> 43:39.420]  Но если в b подставить 1 плюс 1 в качестве x,
[43:39.420 --> 43:41.420]  то мы получим вот ровно это.
[43:45.420 --> 43:47.420]  Скобочков не должно быть?
[43:47.420 --> 43:49.420]  Где?
[43:49.420 --> 43:51.420]  Скобочка 1 от 1 плюс скобочка 1?
[43:51.420 --> 43:53.420]  Нет, нет.
[43:53.420 --> 43:55.420]  Потому что мы...
[43:55.420 --> 43:57.420]  Очень сложно, я понимаю.
[43:57.420 --> 44:01.420]  Препроцессор это мозголомательная штука,
[44:01.420 --> 44:03.420]  которой нужно привыкнуть правильно о ней думать.
[44:03.420 --> 44:05.420]  Это прям очень грустно.
[44:07.420 --> 44:09.420]  Ну, будем верить,
[44:09.420 --> 44:11.420]  что вот этот мой макроспринт ничего не ломает здесь.
[44:11.420 --> 44:13.420]  Скобочки...
[44:13.420 --> 44:15.420]  Там на слайде была ошибка.
[44:15.420 --> 44:17.420]  Да, вот эти скобочки это ошибка,
[44:17.420 --> 44:19.420]  и вот эти скобочки это ошибка.
[44:19.420 --> 44:21.420]  Давайте я исправлю,
[44:21.420 --> 44:23.420]  чтобы меня это не смущало.
[44:29.420 --> 44:31.420]  Да, по идее все вот ровно так.
[44:33.420 --> 44:35.420]  После этого он превращает всю эту шнягу
[44:35.420 --> 44:37.420]  просто в строку,
[44:37.420 --> 44:39.420]  и она уже сканироваться не будет.
[44:39.420 --> 44:41.420]  Поэтому дополнительный скан
[44:41.420 --> 44:43.420]  после того, как сам принт раскрылся,
[44:43.420 --> 44:45.420]  мы как бы подавили.
[44:45.420 --> 44:47.420]  Вот так в биле.
[44:47.420 --> 44:49.420]  Давайте вот так.
[44:49.420 --> 44:51.420]  Подробно, что происходит.
[44:51.420 --> 44:53.420]  Внутри скана
[44:55.420 --> 44:57.420]  мы подставим
[44:57.420 --> 44:59.420]  вместо вот этого варкса
[44:59.420 --> 45:01.420]  всю последовательность токенов,
[45:01.420 --> 45:03.420]  которые внутрь прислали.
[45:03.420 --> 45:05.420]  Прислали вот эту.
[45:05.420 --> 45:07.420]  Теперь ее надо просканировать заново.
[45:07.420 --> 45:09.420]  Мы просканируем А
[45:09.420 --> 45:11.420]  и подставим вместо нее 1+,1.
[45:11.420 --> 45:13.420]  Ну видите, что А объявлено от единицы,
[45:13.420 --> 45:15.420]  1,1.
[45:15.420 --> 45:17.420]  Ну теперь мы это подставим
[45:17.420 --> 45:19.420]  обратно за место скана.
[45:21.420 --> 45:23.420]  И получим выражение
[45:23.420 --> 45:25.420]  снаружи
[45:25.420 --> 45:27.420]  str b 1+,1.
[45:27.420 --> 45:29.420]  Но его тоже надо просканировать.
[45:29.420 --> 45:31.420]  Мы его просканируем.
[45:31.420 --> 45:33.420]  B вызвано
[45:33.420 --> 45:35.420]  от выражения 1+,1.
[45:35.420 --> 45:37.420]  Поэтому
[45:37.420 --> 45:39.420]  будет 1+,1
[45:39.420 --> 45:41.420]  плюс 1+,1.
[45:41.420 --> 45:43.420]  Вот так вот.
[45:43.420 --> 45:45.420]  Теперь понятно, почему
[45:45.420 --> 45:47.420]  скобочек не будет вот в этой шняге.
[45:47.420 --> 45:49.420]  Тут надо очень
[45:49.420 --> 45:51.420]  чувствовать, что это не вызовы функций,
[45:51.420 --> 45:53.420]  а какие-то лютые механизмы с подстановкой,
[45:53.420 --> 45:55.420]  где у вас аргументы сначала сканируются,
[45:55.420 --> 45:57.420]  потом все возвращается,
[45:57.420 --> 45:59.420]  и потом заново сканируется.
[45:59.420 --> 46:01.420]  Это сложно и неинтуитивно,
[46:01.420 --> 46:03.420]  и противокак-то естественно человеку.
[46:03.420 --> 46:05.420]  Но надо понять.
[46:07.420 --> 46:09.420]  И вот мораль.
[46:09.420 --> 46:11.420]  Скан 2, он еще один лишний раз
[46:11.420 --> 46:13.420]  просканирует результат.
[46:13.420 --> 46:15.420]  То есть то, что скан
[46:15.420 --> 46:17.420]  такое выражение вернуло нам,
[46:17.420 --> 46:19.420]  вот это вот,
[46:19.420 --> 46:21.420]  если рей сканировать еще раз,
[46:21.420 --> 46:23.420]  то понятно, что получится ровно это.
[46:23.420 --> 46:25.420]  Но скан 2 это и делает.
[46:25.420 --> 46:27.420]  Но теперь задумайтесь,
[46:27.420 --> 46:29.420]  что если сделать скан 100-500?
[46:29.420 --> 46:31.420]  Можно геометрической прогрессии
[46:31.420 --> 46:33.420]  вообще их растить,
[46:33.420 --> 46:35.420]  потому что вам никто не мешает здесь написать два раза скан.
[46:35.420 --> 46:37.420]  Можем просто скан
[46:37.420 --> 46:39.420]  для n написать?
[46:39.420 --> 46:41.420]  Для конкретного фиксированного n,
[46:41.420 --> 46:43.420]  который ты заранее у себя в голове представил
[46:43.420 --> 46:45.420]  во время припроцессинга?
[46:45.420 --> 46:47.420]  Да.
[46:47.420 --> 46:49.420]  Нет, если у меня есть какой-то скан
[46:49.420 --> 46:51.420]  не очень большой,
[46:51.420 --> 46:53.420]  то я... Нет, по-моему это невозможно,
[46:53.420 --> 46:55.420]  иначе мы бы были полны по тюрингу.
[46:55.420 --> 46:57.420]  А макросы...
[46:59.420 --> 47:01.420]  Не уверен.
[47:01.420 --> 47:03.420]  Я таким не особо страдаю.
[47:03.420 --> 47:05.420]  Вы не слышали, что какая-то курсия,
[47:05.420 --> 47:07.420]  которая есть в шаблонах припроцессинга
[47:07.420 --> 47:09.420]  делается через икру самого себя,
[47:09.420 --> 47:11.420]  среди глобального стейта?
[47:11.420 --> 47:13.420]  Нет, про инклуды мы поговорим
[47:13.420 --> 47:15.420]  в самом конце. Я не уверен,
[47:15.420 --> 47:17.420]  что они позволят действительно сделать скан
[47:17.420 --> 47:19.420]  для произвольного количества. Не уверен.
[47:19.420 --> 47:21.420]  Надо пробовать. Может, кто-то это умеет.
[47:21.420 --> 47:23.420]  Но обычно
[47:23.420 --> 47:25.420]  просто фигарят скан,
[47:25.420 --> 47:27.420]  скан 2 это скан два раза,
[47:27.420 --> 47:29.420]  скан 4 это два раза скан два,
[47:29.420 --> 47:31.420]  и оно в геометрической прогрессии растет.
[47:31.420 --> 47:33.420]  Сколько вам нужно рисканов, столько и...
[47:33.420 --> 47:35.420]  А еще,
[47:35.420 --> 47:37.420]  вот это вот похоже на композицию функции,
[47:37.420 --> 47:39.420]  правда?
[47:39.420 --> 47:41.420]  Или что-нибудь из Хаскеля.
[47:41.420 --> 47:43.420]  Мы взяли композицию СТР,
[47:43.420 --> 47:45.420]  Б, А, и к этой композиции применили 1.
[47:45.420 --> 47:47.420]  Просто
[47:47.420 --> 47:49.420]  единственная проблема, что надо вызвать
[47:49.420 --> 47:51.420]  скан еще от всего этого столько раз,
[47:51.420 --> 47:53.420]  сколько вы закомпозировали тут.
[47:53.420 --> 47:55.420]  Это немножко мозговзрывательно,
[47:55.420 --> 47:57.420]  но пойдем дальше.
[47:57.420 --> 47:59.420]  Сейчас будет совсем...
[47:59.420 --> 48:01.420]  Сейчас не совсем убойно, сейчас будет полезно.
[48:01.420 --> 48:03.420]  Хитрый трюк,
[48:03.420 --> 48:05.420]  который у нас
[48:05.420 --> 48:07.420]  используется, пожалуй, сильно
[48:07.420 --> 48:09.420]  чаще в продакшене,
[48:09.420 --> 48:11.420]  чем хотелось бы.
[48:11.420 --> 48:13.420]  Хмакрос называется.
[48:13.420 --> 48:15.420]  Хмакрос — это вот этот вот макрос.
[48:15.420 --> 48:17.420]  Лист.
[48:17.420 --> 48:19.420]  Как видите, он представляет собой
[48:19.420 --> 48:21.420]  последовательность токенов,
[48:21.420 --> 48:23.420]  в которой
[48:23.420 --> 48:25.420]  какой-то другой f используется,
[48:25.420 --> 48:27.420]  который может быть, функция может быть
[48:27.420 --> 48:29.420]  макросом, спокойно может быть макросом,
[48:29.420 --> 48:31.420]  но он пока не определенно нигде выше.
[48:31.420 --> 48:33.420]  Но он используется,
[48:33.420 --> 48:35.420]  ему в аргументы передают
[48:35.420 --> 48:37.420]  A, B и C.
[48:37.420 --> 48:39.420]  То есть это тоже в каком-то смысле такой список
[48:39.420 --> 48:41.420]  или последовательность.
[48:41.420 --> 48:43.420]  Просто список или последовательность заранее написано
[48:43.420 --> 48:45.420]  с применением какого-то
[48:45.420 --> 48:47.420]  f наперед неизвестного.
[48:47.420 --> 48:49.420]  Вот.
[48:49.420 --> 48:51.420]  Еще про вот этот бэкслэш надо сказать.
[48:51.420 --> 48:53.420]  Знаете, что делает
[48:53.420 --> 48:55.420]  бэкслэш в конце строки?
[48:55.420 --> 48:57.420]  Не совсем.
[48:57.420 --> 48:59.420]  Он делает следующий символ токеном,
[48:59.420 --> 49:01.420]  если я правильно помню.
[49:01.420 --> 49:03.420]  Следующий символ токеном.
[49:03.420 --> 49:05.420]  То есть ньюлайн станет
[49:05.420 --> 49:07.420]  токеном, и когда вы подставите...
[49:07.420 --> 49:09.420]  Ну короче, сейчас, идем дальше.
[49:09.420 --> 49:11.420]  Кажется, бэкслэш, пробелы
[49:11.420 --> 49:13.420]  совершенно не выпиливают целиком.
[49:13.420 --> 49:15.420]  Это второй этап.
[49:15.420 --> 49:17.420]  Ладно, неважно.
[49:17.420 --> 49:19.420]  Ну короче, да, оно продлевает макросы на следующие строки.
[49:19.420 --> 49:21.420]  Нам это даже не так важно.
[49:21.420 --> 49:23.420]  Но даже тут какие-то.
[49:23.420 --> 49:25.420]  Коментарий может продлевать.
[49:25.420 --> 49:27.420]  Ну все продлевает. Короче, конкатонируют
[49:27.420 --> 49:29.420]  строки типа без новой строки.
[49:29.420 --> 49:31.420]  Подавляет ньюлайн как
[49:31.420 --> 49:33.420]  сущность языка,
[49:33.420 --> 49:35.420]  в том числе при процессоре.
[49:35.420 --> 49:37.420]  А вот теперь как использовать этот
[49:37.420 --> 49:39.420]  x-макрос? Мы дефиним
[49:39.420 --> 49:41.420]  f от x как
[49:41.420 --> 49:43.420]  какую-то фигню.
[49:43.420 --> 49:45.420]  Ну взяли,
[49:45.420 --> 49:47.420]  прилепили к x подчеркивая id
[49:47.420 --> 49:49.420]  и сделали, вызвали какую-то
[49:49.420 --> 49:51.420]  функцию глобальную. Get id
[49:51.420 --> 49:53.420]  от строкового представления x.
[49:55.420 --> 49:57.420]  Вот сdefine или f.
[49:57.420 --> 49:59.420]  А теперь напишем просто
[49:59.420 --> 50:01.420]  сам лист, объектный макрос
[50:01.420 --> 50:03.420]  напишем и
[50:03.420 --> 50:05.420]  undefine f.
[50:05.420 --> 50:07.420]  Вот этот объектный макрос лист
[50:07.420 --> 50:09.420]  раскроется вот в следующую фигню.
[50:11.420 --> 50:13.420]  Понятно почему.
[50:13.420 --> 50:15.420]  Потому что просто мы
[50:15.420 --> 50:17.420]  ну да, f объявлена
[50:17.420 --> 50:19.420]  позже, но она есть, и когда мы будем
[50:19.420 --> 50:21.420]  это раскрывать, мы спокойно f применим
[50:21.420 --> 50:23.420]  и все будет работать.
[50:23.420 --> 50:25.420]  Вот.
[50:25.420 --> 50:27.420]  Это очень полезно, когда вам нужно
[50:27.420 --> 50:29.420]  какой-нибудь вот такой дурацкий
[50:29.420 --> 50:31.420]  boilerplate писать, чтобы какие-то строки
[50:31.420 --> 50:33.420]  в какие-то idшники
[50:33.420 --> 50:35.420]  превращать там
[50:35.420 --> 50:37.420]  где-нибудь, в что-нибудь
[50:37.420 --> 50:39.420]  статическом. Ну вот такое
[50:39.420 --> 50:41.420]  бывает, что у вас какая-то система, она там
[50:41.420 --> 50:43.420]  работает со строками очень часто.
[50:45.420 --> 50:47.420]  Какие-нибудь строковые названия каких-нибудь
[50:47.420 --> 50:49.420]  ресурсов, там
[50:51.420 --> 50:53.420]  биндингов, еще чего-нибудь такого.
[50:53.420 --> 50:55.420]  Ну вот вы их все забиваете
[50:55.420 --> 50:57.420]  в такую шнягу,
[50:57.420 --> 50:59.420]  и idшники, ну тут
[50:59.420 --> 51:01.420]  статик-то писать еще, да, и
[51:01.420 --> 51:03.420]  idшники просто в какой-то
[51:03.420 --> 51:05.420]  хэшмапчик засовываете
[51:05.420 --> 51:07.420]  строки, получаете idшники,
[51:07.420 --> 51:09.420]  один раз их сохранили, и вот.
[51:09.420 --> 51:11.420]  Дальше у вас всегда можно
[51:11.420 --> 51:13.420]  писать там название
[51:13.420 --> 51:15.420]  строковое какой-нибудь шняге,
[51:15.420 --> 51:17.420]  и вам его дадут.
[51:17.420 --> 51:19.420]  Ну, способ
[51:19.420 --> 51:21.420]  подавлять boilerplate, не очень хороший.
[51:21.420 --> 51:23.420]  Лучше просто не иметь таких функций getid,
[51:23.420 --> 51:25.420]  и как-то по-другому эту проблему решать.
[51:25.420 --> 51:27.420]  Ну ладно, пошли дальше.
[51:27.420 --> 51:29.420]  Теперь
[51:29.420 --> 51:31.420]  начнется убойная.
[51:31.420 --> 51:33.420]  Ну давайте как-то это парсить
[51:33.420 --> 51:35.420]  с конца. И че
[51:35.420 --> 51:37.420]  я написал?
[51:37.420 --> 51:39.420]  Case export1, case export2,
[51:39.420 --> 51:41.420]  case пустые скобки,
[51:41.420 --> 51:43.420]  и
[51:43.420 --> 51:45.420]  как бы default
[51:45.420 --> 51:47.420]  автоматом получать. Ну зачем это нужно?
[51:47.420 --> 51:49.420]  Затем, что я не хочу
[51:49.420 --> 51:51.420]  брейки писать, но я хочу
[51:51.420 --> 51:53.420]  нормальный синтаксис,
[51:53.420 --> 51:55.420]  что просто кейс, фигурные скобки,
[51:55.420 --> 51:57.420]  все.
[51:57.420 --> 51:59.420]  Ну я хитро поступил, я в начале
[51:59.420 --> 52:01.420]  каждого следующего кейса делаю брейк
[52:01.420 --> 52:03.420]  для предыдущего кейса.
[52:03.420 --> 52:05.420]  Ну switch так работает, c++,
[52:05.420 --> 52:07.420]  fc, что можно так сделать?
[52:07.420 --> 52:09.420]  И получается
[52:09.420 --> 52:11.420]  вот такая шняга.
[52:11.420 --> 52:13.420]  Единственная проблема
[52:13.420 --> 52:15.420]  это че такое
[52:15.420 --> 52:17.420]  вообще?
[52:17.420 --> 52:19.420]  Вот как вот это вот все работает?
[52:19.420 --> 52:21.420]  Почему мы
[52:21.420 --> 52:23.420]  же не можем перегружать макросы?
[52:23.420 --> 52:25.420]  Вы в курсе? Не вообще не можем.
[52:25.420 --> 52:27.420]  То есть нельзя сделать два макроса
[52:27.420 --> 52:29.420]  кейс, один от одного аргумента,
[52:29.420 --> 52:31.420]  а другой от другого.
[52:31.420 --> 52:33.420]  Кейс это один макрос,
[52:33.420 --> 52:35.420]  который принимает, ну как бы в ряде
[52:35.420 --> 52:37.420]  к просто любую последовательность токенов.
[52:37.420 --> 52:39.420]  И при этом мы каким-то
[52:39.420 --> 52:41.420]  образом, когда эта последовательность
[52:41.420 --> 52:43.420]  пустая, умудрились
[52:43.420 --> 52:45.420]  вместо кейса
[52:45.420 --> 52:47.420]  написать дефолт.
[52:47.420 --> 52:49.420]  Как?
[52:49.420 --> 52:51.420]  Написано, но распарсить
[52:51.420 --> 52:53.420]  это невозможно.
[52:53.420 --> 52:55.420]  Во-первых,
[52:55.420 --> 52:57.420]  cat и pcat.
[52:57.420 --> 52:59.420]  Ну мы их видели уже, да?
[52:59.420 --> 53:01.420]  Cat это просто конконтонация,
[53:01.420 --> 53:03.420]  а pcat это конконтонация с ресканом.
[53:03.420 --> 53:05.420]  Ну то есть чтобы можно было
[53:05.420 --> 53:07.420]  в pcat еще какие-то макросы передать.
[53:07.420 --> 53:09.420]  И оно работало.
[53:09.420 --> 53:11.420]  Ну вот здесь мы собственно и передаем.
[53:11.420 --> 53:13.420]  В pcat еще какие-то макросы,
[53:13.420 --> 53:15.420]  потом произойдет рескан.
[53:15.420 --> 53:17.420]  Внимание, какие макросы мы передаем?
[53:17.420 --> 53:19.420]  Ну мы передаем
[53:19.420 --> 53:21.420]  кейс
[53:21.420 --> 53:23.420]  и некоторые изэмпти.
[53:23.420 --> 53:25.420]  Изэмпти раскрывается в ноль,
[53:25.420 --> 53:27.420]  когда вот в этой
[53:27.420 --> 53:29.420]  последовательности токенов
[53:29.420 --> 53:31.420]  есть хоть один токен
[53:31.420 --> 53:33.420]  и в единицу иначе.
[53:33.420 --> 53:35.420]  Изэмпти в единицу.
[53:35.420 --> 53:37.420]  Изэмпти в единицу,
[53:37.420 --> 53:39.420]  если это пустая последовательность токенов,
[53:39.420 --> 53:41.420]  иначе в ноль.
[53:41.420 --> 53:43.420]  И мы конконтонируем кейс
[53:43.420 --> 53:45.420]  с вот этим нулем или единицей.
[53:47.420 --> 53:49.420]  А кейс 0 и кейс 1 они вот тут задефайнены.
[53:51.420 --> 53:53.420]  Дальше еще раз круглые скобки,
[53:53.420 --> 53:55.420]  видите?
[53:55.420 --> 53:57.420]  То есть результат этой конконтонации
[53:57.420 --> 53:59.420]  это название другого макроса.
[53:59.420 --> 54:01.420]  Либо кейс 0, либо кейс 1,
[54:01.420 --> 54:03.420]  который потом сразу запускается
[54:03.420 --> 54:05.420]  в токенов.
[54:05.420 --> 54:07.420]  Вот к вопросу Петя, можно ли?
[54:07.420 --> 54:09.420]  Да, можно.
[54:09.420 --> 54:11.420]  Тут очень хрупкая конструкция.
[54:11.420 --> 54:13.420]  Вы должны следить за ресканами.
[54:13.420 --> 54:15.420]  Потому что может быть такое,
[54:15.420 --> 54:17.420]  что вы вот этот ПКат прекрасно
[54:17.420 --> 54:19.420]  раскроете и у вас типа все круто,
[54:19.420 --> 54:21.420]  но после этого
[54:21.420 --> 54:23.420]  внезапно окажется,
[54:23.420 --> 54:25.420]  что не хватило лишнего скана,
[54:25.420 --> 54:27.420]  чтобы раскрыть все это вместе.
[54:27.420 --> 54:29.420]  Вот такое может быть.
[54:29.420 --> 54:31.420]  Благо здесь хватает,
[54:31.420 --> 54:33.420]  потому что мы на самом деле,
[54:33.420 --> 54:35.420]  вот сам кейс,
[54:35.420 --> 54:37.420]  он никак ресканы аргументов не использует.
[54:37.420 --> 54:39.420]  Тут они не интересны.
[54:39.420 --> 54:41.420]  Поэтому просто считаем,
[54:41.420 --> 54:43.420]  что сразу все подставилось сюда
[54:43.420 --> 54:45.420]  и начало дальше раскрываться.
[54:45.420 --> 54:47.420]  И вот как бы ПКат, он как-то там раскроется,
[54:47.420 --> 54:49.420]  все будет, будет кейс 0.
[54:49.420 --> 54:51.420]  Ну и дальше рескан просто напрямую идет.
[54:51.420 --> 54:53.420]  Ну как бы, то есть не рескан,
[54:53.420 --> 54:55.420]  окей, скан просто продолжается.
[54:55.420 --> 54:57.420]  Вот ПКат весь раскрылся
[54:57.420 --> 54:59.420]  в кейс 0 или кейс 1, и просто отсюда же
[54:59.420 --> 55:01.420]  рескан продолжается, и как бы
[55:01.420 --> 55:03.420]  все нормально, и все цветочки.
[55:03.420 --> 55:05.420]  Но как только вы такое пытаетесь в рекурсивном
[55:05.420 --> 55:07.420]  чем-то писать, там всякие DC
[55:07.420 --> 55:09.420]  возникают, синие краски и прочее.
[55:09.420 --> 55:11.420]  Поэтому надо быть аккуратным.
[55:11.420 --> 55:13.420]  Но тут вроде очевидно, почему работает.
[55:13.420 --> 55:15.420]  Правда?
[55:15.420 --> 55:17.420]  Все прекрасно.
[55:17.420 --> 55:19.420]  Нет, из empty это наш следующий вопрос.
[55:19.420 --> 55:21.420]  А как это написать вообще?
[55:23.420 --> 55:25.420]  Давай.
[55:29.420 --> 55:31.420]  Это неважно.
[55:33.420 --> 55:35.420]  Да.
[55:37.420 --> 55:39.420]  Вот эти? Да ничего не будет.
[55:43.420 --> 55:45.420]  Ну,
[55:45.420 --> 55:47.420]  это тоже ничего не будет.
[55:47.420 --> 55:49.420]  Ну то есть свитч, он работает
[55:49.420 --> 55:51.420]  совсем не так, как вы думаете.
[55:51.420 --> 55:53.420]  Если у вас есть интуиция про то, что свитч
[55:53.420 --> 55:55.420]  это как такой ИФ с несколькими этими,
[55:55.420 --> 55:57.420]  то это вообще неправда.
[55:57.420 --> 55:59.420]  Свитч это, да,
[55:59.420 --> 56:01.420]  такие гоуту, по сути.
[56:01.420 --> 56:03.420]  Типа структурированный
[56:03.420 --> 56:05.420]  гоуту.
[56:05.420 --> 56:07.420]  Давай посмотрим на Х, и
[56:07.420 --> 56:09.420]  в зависимости от того, что в Х написано,
[56:09.420 --> 56:11.420]  пойдем сделаем гоуту
[56:11.420 --> 56:13.420]  на какую-то из строчек внутри
[56:13.420 --> 56:15.420]  моих фигурных скобок.
[56:15.420 --> 56:17.420]  И вот эти кейсы это просто метки, куда делать
[56:17.420 --> 56:19.420]  гоуту. А брейк это гоуту-конец.
[56:19.420 --> 56:21.420]  Все.
[56:21.420 --> 56:23.420]  Больше из себя свитч ничего не представляет.
[56:23.420 --> 56:25.420]  Поэтому если вы в конце брейк пропустите,
[56:25.420 --> 56:27.420]  вот, заметьте, в дефолт, и там дальше
[56:27.420 --> 56:29.420]  нету брейка. А ему пофиг.
[56:29.420 --> 56:31.420]  Потому что какая разница в конце
[56:31.420 --> 56:33.420]  дефолта, в конце последнего этого сделать
[56:33.420 --> 56:35.420]  гоуту-конец или просто вывалиться за конец?
[56:35.420 --> 56:37.420]  Ну вывалились и вывалились.
[56:37.420 --> 56:39.420]  Да?
[56:39.420 --> 56:41.420]  Я делал на Си стэклу струтину
[56:41.420 --> 56:43.420]  с помощью
[56:43.420 --> 56:45.420]  девайса и да.
[56:45.420 --> 56:47.420]  И я делал сеспент внутри файла
[56:47.420 --> 56:49.420]  или внутри флора. Да.
[56:49.420 --> 56:51.420]  Более того, можно свитч
[56:51.420 --> 56:53.420]  можно
[56:53.420 --> 56:55.420]  можно внутри свитча
[56:55.420 --> 56:57.420]  просто вот
[56:57.420 --> 56:59.420]  втупую внутри свитча написать
[56:59.420 --> 57:01.420]  абсолютно любой код. Вот без всяких
[57:01.420 --> 57:03.420]  кейсов брейков. Любой код внутри свитча
[57:03.420 --> 57:05.420]  пишете вообще любой.
[57:05.420 --> 57:07.420]  Ифы, вайлы, что угодно.
[57:07.420 --> 57:09.420]  А потом рандомно в этот код
[57:09.420 --> 57:11.420]  натыкиваете кейсы куда хотите.
[57:11.420 --> 57:13.420]  И это будет работать.
[57:15.420 --> 57:17.420]  Вы не слышали про это?
[57:17.420 --> 57:19.420]  Какие вы молодые, наивные.
[57:21.420 --> 57:23.420]  В первом семестре
[57:23.420 --> 57:25.420]  кидали в профи цифров.
[57:25.420 --> 57:27.420]  Что оно выведет?
[57:27.420 --> 57:29.420]  Там что-то совсем не очевидно было.
[57:31.420 --> 57:33.420]  Так, знакомьтесь.
[57:33.420 --> 57:35.420]  Устройство Дафа.
[57:35.420 --> 57:37.420]  Даф.
[57:37.420 --> 57:39.420]  Мужик такой.
[57:39.420 --> 57:41.420]  Что здесь интересно?
[57:41.420 --> 57:43.420]  Вот свитч идет.
[57:43.420 --> 57:45.420]  Дальше идет кейс ноль.
[57:45.420 --> 57:47.420]  И прямо внутри него,
[57:47.420 --> 57:49.420]  внутри этого кейса ноль открывается
[57:49.420 --> 57:51.420]  вайл цикл.
[57:51.420 --> 57:53.420]  Посреди этого дуайл цикла
[57:53.420 --> 57:55.420]  на пендюре на кейсов.
[57:55.420 --> 57:57.420]  А потом этот
[57:57.420 --> 57:59.420]  дуайл цикл закрывается.
[57:59.420 --> 58:01.420]  Итак, когда мы придем
[58:01.420 --> 58:03.420]  в это место впервые,
[58:05.420 --> 58:07.420]  хватит мне писать, я занят.
[58:09.420 --> 58:11.420]  Когда мы придем в это место впервые,
[58:11.420 --> 58:13.420]  мы возьмем этот каунт по модуле 8
[58:13.420 --> 58:15.420]  и прыгнем туда, куда надо.
[58:15.420 --> 58:17.420]  Ну, предположим, получилось
[58:17.420 --> 58:19.420]  там 5. Прыгнем сюда
[58:19.420 --> 58:21.420]  и прямо отсюда начнем идти дальше.
[58:21.420 --> 58:23.420]  Пыры-пыры-пыры идем.
[58:23.420 --> 58:25.420]  Дошли до... Все кейсы игнорятся.
[58:25.420 --> 58:27.420]  Это просто метки.
[58:27.420 --> 58:29.420]  Дошли до вайла.
[58:29.420 --> 58:31.420]  О, n еще великоват. Пойдем в начало.
[58:33.420 --> 58:35.420]  И опять просто идем подряд, игнория все метки.
[58:35.420 --> 58:37.420]  Ну, это просто обычный цикл.
[58:37.420 --> 58:39.420]  Метки уже ни на что не влияют.
[58:39.420 --> 58:41.420]  А потом мы из этого цикла просто вывалимся
[58:41.420 --> 58:43.420]  и свитча вывалимся, и все.
[58:43.420 --> 58:45.420]  То есть вот этот свитч — это просто
[58:45.420 --> 58:47.420]  гоуту-нужная строчка.
[58:49.420 --> 58:51.420]  Компилятору норм.
[59:01.420 --> 59:03.420]  Я не умею отвечать на такие вопросы.
[59:05.420 --> 59:07.420]  Обратите внимание на то, как объявлены параметры этой функции.
[59:09.420 --> 59:11.420]  Да. Вы такое видели когда-нибудь вообще?
[59:11.420 --> 59:13.420]  Ну, это...
[59:15.420 --> 59:17.420]  Кернигенричи диклорейшнс.
[59:21.420 --> 59:23.420]  Да. Когда-то...
[59:23.420 --> 59:25.420]  Когда-то в языке C не было сигнатур.
[59:25.420 --> 59:27.420]  Вообще.
[59:27.420 --> 59:29.420]  Вот ничего не было.
[59:29.420 --> 59:31.420]  Вы просто писали там send.
[59:33.420 --> 59:35.420]  Это объявление функции.
[59:41.420 --> 59:43.420]  Как будет линковаться?
[59:43.420 --> 59:45.420]  Ну, по строковому имени.
[59:45.420 --> 59:47.420]  Как и всегда в C.
[59:49.420 --> 59:51.420]  Ну, просто в языке C
[59:51.420 --> 59:53.420]  линковка, она...
[59:53.420 --> 59:55.420]  Ну, нет перегрузок, нет никаких приколов.
[59:55.420 --> 59:57.420]  Линковка работает тупо по названиям функции.
[59:59.420 --> 01:00:01.420]  Все, сигнатуры им не нужны.
[01:00:01.420 --> 01:00:03.420]  И когда-то давно в языке C сигнатуры выглядели вот так.
[01:00:05.420 --> 01:00:07.420]  Что говорить, ну, у меня функция принимает два аргумента.
[01:00:07.420 --> 01:00:09.420]  И все, в принципе.
[01:00:09.420 --> 01:00:11.420]  Вот это вот ваша диклорация функция.
[01:00:11.420 --> 01:00:13.420]  По дефолту возвращает int.
[01:00:15.420 --> 01:00:17.420]  А потом вы
[01:00:17.420 --> 01:00:19.420]  в теле функции,
[01:00:19.420 --> 01:00:21.420]  уже в definition, да?
[01:00:21.420 --> 01:00:23.420]  Эта вот часть definition.
[01:00:23.420 --> 01:00:25.420]  Берете и говорите, ну, а теперь я решил,
[01:00:25.420 --> 01:00:27.420]  что первый аргумент я интерпретирую как int,
[01:00:27.420 --> 01:00:29.420]  а второй аргумент как чарт две звездочки.
[01:00:31.420 --> 01:00:33.420]  Че?
[01:00:39.420 --> 01:00:41.420]  Нет, ну, прикол в том, что
[01:00:41.420 --> 01:00:43.420]  тебе все это не важно.
[01:00:45.420 --> 01:00:47.420]  Ты думаешь, что тебя это очень волнует,
[01:00:47.420 --> 01:00:49.420]  тебе это очень важно, но тебе это не важно.
[01:00:59.420 --> 01:01:01.420]  Так, смотри, это теперь не main, это теперь foo.
[01:01:01.420 --> 01:01:03.420]  Это foo.c,
[01:01:03.420 --> 01:01:05.420]  это foo.h,
[01:01:05.420 --> 01:01:07.420]  foo.h объявлено.
[01:01:07.420 --> 01:01:09.420]  Есть foo.
[01:01:09.420 --> 01:01:11.420]  Все.
[01:01:13.420 --> 01:01:15.420]  Че? Зачем?
[01:01:15.420 --> 01:01:17.420]  Ну, и ты в точке вызова,
[01:01:17.420 --> 01:01:19.420]  где ты заинклюдил вот этот foo.h.
[01:01:21.420 --> 01:01:23.420]  Если ты вот там заинклюдил foo.h,
[01:01:23.420 --> 01:01:25.420]  ты такое делаешь.
[01:01:25.420 --> 01:01:27.420]  Если ты вот там заинклюдил foo.h,
[01:01:27.420 --> 01:01:29.420]  ты такое делаешь.
[01:01:31.420 --> 01:01:33.420]  foo от там
[01:01:33.420 --> 01:01:35.420]  3
[01:01:35.420 --> 01:01:37.420]  и там какой-то указатель.
[01:01:37.420 --> 01:01:39.420]  Ну, смотри,
[01:01:39.420 --> 01:01:41.420]  смотри.
[01:01:41.420 --> 01:01:43.420]  Смотри, вот ты видишь,
[01:01:43.420 --> 01:01:45.420]  у тебя вызвано от int,
[01:01:45.420 --> 01:01:47.420]  это же int,
[01:01:47.420 --> 01:01:49.420]  и вызвано от чарт две звездочки.
[01:01:49.420 --> 01:01:51.420]  Ну, ты же знаешь, как int
[01:01:51.420 --> 01:01:53.420]  и чарт две звездочки укладывать
[01:01:53.420 --> 01:01:55.420]  на stack или в регистры,
[01:01:55.420 --> 01:01:57.420]  чтобы вызвать функцию такую?
[01:01:57.420 --> 01:01:59.420]  Знаешь. Ну, так здесь и уложи.
[01:01:59.420 --> 01:02:01.420]  Уложил? Ну, прекрасно.
[01:02:01.420 --> 01:02:03.420]  Потом этот вызов через линковщик
[01:02:03.420 --> 01:02:05.420]  и вот эту вот хренотень придет сюда,
[01:02:05.420 --> 01:02:07.420]  а здесь в определении функции
[01:02:07.420 --> 01:02:09.420]  написано,
[01:02:09.420 --> 01:02:11.420]  ну, ты же знаешь, как доставать
[01:02:11.420 --> 01:02:13.420]  аргументы со stack из регистров,
[01:02:13.420 --> 01:02:15.420]  если они были типа int и чарт две звездочки?
[01:02:15.420 --> 01:02:17.420]  Ну, так и достанье.
[01:02:17.420 --> 01:02:19.420]  Вопрос, что происходит,
[01:02:19.420 --> 01:02:21.420]  если здесь на самом деле был не int?
[01:02:21.420 --> 01:02:23.420]  Или если здесь было три аргумента,
[01:02:23.420 --> 01:02:25.420]  а вот это вот
[01:02:25.420 --> 01:02:27.420]  вообще int, а не чарт две звездочки,
[01:02:27.420 --> 01:02:29.420]  у него там размер 32 бита,
[01:02:29.420 --> 01:02:31.420]  а чарт две звездочки
[01:02:31.420 --> 01:02:33.420]  64. Ну, происходит
[01:02:33.420 --> 01:02:35.420]  бум. Программа
[01:02:35.420 --> 01:02:37.420]  крашится, если он повезет, если не повезет,
[01:02:37.420 --> 01:02:39.420]  продолжает работать, как ни в чем не бывало,
[01:02:39.420 --> 01:02:41.420]  какой-то мусор, просто читая, непонятный.
[01:02:41.420 --> 01:02:43.420]  По стандарту это просто нарушение
[01:02:43.420 --> 01:02:45.420]  ODR. Отлично.
[01:02:45.420 --> 01:02:47.420]  Вот эти финиши уже нет
[01:02:47.420 --> 01:02:49.420]  для такой сигнатуры? Нет.
[01:02:49.420 --> 01:02:51.420]  Ух, прекрасно.
[01:02:51.420 --> 01:02:53.420]  Ну вот, когда-то люди на C писали
[01:02:53.420 --> 01:02:55.420]  так, а потом в последний день
[01:02:55.420 --> 01:02:57.420]  перед стандартизацией ANSI C,
[01:02:57.420 --> 01:02:59.420]  вот C89 стандартизировали
[01:02:59.420 --> 01:03:01.420]  первый раз, когда,
[01:03:01.420 --> 01:03:03.420]  по-моему, Ричи Деннис прибежал
[01:03:03.420 --> 01:03:05.420]  и сказал, это невозможно,
[01:03:05.420 --> 01:03:07.420]  мы это выпиливаем, и вот, ну, типа
[01:03:07.420 --> 01:03:09.420]  за один день пропихнул стандарт
[01:03:09.420 --> 01:03:11.420]  современной синтаксис объявления определения
[01:03:11.420 --> 01:03:13.420]  функций. Вот.
[01:03:13.420 --> 01:03:15.420]  Без всякого опыта предыдущего,
[01:03:15.420 --> 01:03:17.420]  без там, какие-то проверки,
[01:03:17.420 --> 01:03:19.420]  как оно вообще будет работать,
[01:03:19.420 --> 01:03:21.420]  просто человек понимал, что вот это хрень,
[01:03:21.420 --> 01:03:23.420]  а вот то, что он новое взял,
[01:03:23.420 --> 01:03:25.420]  придумал за один день, оно отлично,
[01:03:25.420 --> 01:03:27.420]  и до сих пор мы с этим отлично живем,
[01:03:27.420 --> 01:03:29.420]  и в принципе не жалуемся.
[01:03:29.420 --> 01:03:31.420]  А потом, когда в C17
[01:03:31.420 --> 01:03:33.420]  смеют добавить
[01:03:33.420 --> 01:03:35.420]  какую-то новую фичу,
[01:03:35.420 --> 01:03:37.420]  набегают люди и говорят, стандарт
[01:03:37.420 --> 01:03:39.420]  призван стандартизовывать существующие
[01:03:39.420 --> 01:03:41.420]  практики, вы что, это не существующая
[01:03:41.420 --> 01:03:43.420]  практика, вы тут сами что-то себе
[01:03:43.420 --> 01:03:45.420]  придумали, это никому не надо.
[01:03:45.420 --> 01:03:47.420]  Вот, лично Денис Рича
[01:03:47.420 --> 01:03:49.420]  добавлял стандарт, не существующую
[01:03:49.420 --> 01:03:51.420]  практику, которая никому не нужна, и все
[01:03:51.420 --> 01:03:53.420]  и так прекрасно жили.
[01:03:53.420 --> 01:03:55.420]  Можно вкинуть. Вкинь.
[01:03:55.420 --> 01:03:57.420]  В C17 это фу от
[01:03:57.420 --> 01:03:59.420]  просто слезковочек.
[01:03:59.420 --> 01:04:01.420]  Вы знаете, что она не может понимать
[01:04:01.420 --> 01:04:03.420]  любой рэп. Да.
[01:04:03.420 --> 01:04:05.420]  Это легаси как раз с этих времен.
[01:04:05.420 --> 01:04:07.420]  В флюшах по-другому.
[01:04:07.420 --> 01:04:09.420]  В флюшах по-другому.
[01:04:09.420 --> 01:04:11.420]  Я наконец-то понял, зачем
[01:04:11.420 --> 01:04:13.420]  это тут. Да, это не было
[01:04:13.420 --> 01:04:15.420]  сделано, а это так сложилось,
[01:04:15.420 --> 01:04:17.420]  так было изначально.
[01:04:17.420 --> 01:04:19.420]  Ну ладно, уже закрыл.
[01:04:19.420 --> 01:04:21.420]  Да.
[01:04:21.420 --> 01:04:23.420]  Мейн просто две круглые
[01:04:23.420 --> 01:04:25.420]  скобки. Это мейн от произвольного количества
[01:04:25.420 --> 01:04:27.420]  аргументов. Ну и на самом деле
[01:04:27.420 --> 01:04:29.420]  тебе покинут туда инт и
[01:04:29.420 --> 01:04:31.420]  чар для звездочки.
[01:04:31.420 --> 01:04:33.420]  Ну короче, да.
[01:04:39.420 --> 01:04:41.420]  Керниган и Ричи, вот это два мужика,
[01:04:41.420 --> 01:04:43.420]  которые оригинально разработали
[01:04:43.420 --> 01:04:45.420]  язык C, еще там
[01:04:45.420 --> 01:04:47.420]  в 70-е.
[01:04:47.420 --> 01:04:49.420]  Ну, видимо,
[01:04:49.420 --> 01:04:51.420]  я не уверен. Я вот эту вот
[01:04:51.420 --> 01:04:53.420]  историю плохо помню.
[01:04:53.420 --> 01:04:55.420]  В общем, Ричи главный.
[01:04:55.420 --> 01:04:57.420]  Ну да, вот они там
[01:04:57.420 --> 01:04:59.420]  придумали язык C в Bell Labs работая,
[01:04:59.420 --> 01:05:01.420]  по-моему.
[01:05:01.420 --> 01:05:03.420]  Ну и язык C выглядел вот так.
[01:05:03.420 --> 01:05:05.420]  А потом он стал популярным,
[01:05:05.420 --> 01:05:07.420]  и его решили стандартизовывать
[01:05:07.420 --> 01:05:09.420]  международный комитет стандартизации
[01:05:09.420 --> 01:05:11.420]  и Iso,
[01:05:11.420 --> 01:05:13.420]  который там диаметры гаяк
[01:05:13.420 --> 01:05:15.420]  и болтов тоже стандартизирует.
[01:05:15.420 --> 01:05:17.420]  И вот, ну, там буквально
[01:05:17.420 --> 01:05:19.420]  за, грубо говоря, день до
[01:05:19.420 --> 01:05:21.420]  стандартизации Ричи понял, что вот
[01:05:21.420 --> 01:05:23.420]  это хрень это надо выпилить. И выпилил.
[01:05:23.420 --> 01:05:25.420]  Но деприкейтнуть и совсем удалить
[01:05:25.420 --> 01:05:27.420]  это получилось только
[01:05:27.420 --> 01:05:29.420]  40 лет спустя? 30?
[01:05:29.420 --> 01:05:31.420]  30 лет спустя.
[01:05:31.420 --> 01:05:33.420]  Вот, очень-очень сильно отвлеклись
[01:05:33.420 --> 01:05:35.420]  от нашего любимого этого
[01:05:35.420 --> 01:05:37.420]  препроцессора.
[01:05:37.420 --> 01:05:39.420]  Ну ладно, мистерическую справку навели.
[01:05:45.420 --> 01:05:47.420]  Продолжим. Разобрались мы
[01:05:47.420 --> 01:05:49.420]  с этим, правда?
[01:05:49.420 --> 01:05:51.420]  Вот по модулю из-эмпти
[01:05:51.420 --> 01:05:53.420]  понятно, что происходит.
[01:05:53.420 --> 01:05:55.420]  Из-эмпти
[01:05:55.420 --> 01:05:57.420]  ключевая идея.
[01:05:59.420 --> 01:06:01.420]  Есть такой макрос из-эмпти-экспант.
[01:06:01.420 --> 01:06:03.420]  Он во что-то
[01:06:03.420 --> 01:06:05.420]  экспандится, да? Ну, запятая
[01:06:05.420 --> 01:06:07.420]  ткань. Это на самом деле абсолютно
[01:06:07.420 --> 01:06:09.420]  неважно. Сравним
[01:06:09.420 --> 01:06:11.420]  вот две такие записи.
[01:06:11.420 --> 01:06:13.420]  Вот это, если просканировать,
[01:06:13.420 --> 01:06:15.420]  раскроется что-нибудь?
[01:06:15.420 --> 01:06:17.420]  Нет.
[01:06:17.420 --> 01:06:19.420]  Тут нету вызова этого функционального
[01:06:19.420 --> 01:06:21.420]  макроса. Потому что здесь
[01:06:21.420 --> 01:06:23.420]  какая-то аркс, какой-то токен, непонятный
[01:06:23.420 --> 01:06:25.420]  влез. А вот это
[01:06:25.420 --> 01:06:27.420]  раскроется.
[01:06:31.420 --> 01:06:33.420]  Ну, они останутся просто висеть.
[01:06:35.420 --> 01:06:37.420]  Ну,
[01:06:37.420 --> 01:06:39.420]  останутся висеть.
[01:06:39.420 --> 01:06:41.420]  Да, они просто останутся висеть,
[01:06:41.420 --> 01:06:43.420]  они ни на что не влияют, эти скобочки.
[01:06:43.420 --> 01:06:45.420]  Ну, короче, так работает.
[01:06:45.420 --> 01:06:47.420]  Я напоминаю, мы хотели понять
[01:06:47.420 --> 01:06:49.420]  последовательность токенов, она
[01:06:49.420 --> 01:06:51.420]  пустая или не пустая. И вот
[01:06:51.420 --> 01:06:53.420]  мы обнаружили такой смешной факт,
[01:06:53.420 --> 01:06:55.420]  что вот этот вот код
[01:06:55.420 --> 01:06:57.420]  раскрывается в
[01:06:57.420 --> 01:06:59.420]  ничего, а вот этот раскрывается
[01:06:59.420 --> 01:07:01.420]  в запятая 1.
[01:07:01.420 --> 01:07:03.420]  То есть, если мы напишем
[01:07:03.420 --> 01:07:05.420]  как бы вместо аркс сюда в аркс,
[01:07:05.420 --> 01:07:07.420]  когда оно было пустое, мы превратимся
[01:07:07.420 --> 01:07:09.420]  в этот кейс, иначе в этот.
[01:07:09.420 --> 01:07:11.420]  Давайте так и сделаем.
[01:07:11.420 --> 01:07:13.420]  Вот он
[01:07:13.420 --> 01:07:15.420]  наш прекрасный изэмпти.
[01:07:15.420 --> 01:07:17.420]  Понять бы ток,
[01:07:17.420 --> 01:07:19.420]  что происходит.
[01:07:19.420 --> 01:07:21.420]  Здесь есть еще функция f от x,
[01:07:21.420 --> 01:07:23.420]  макрос f от x.
[01:07:23.420 --> 01:07:25.420]  Макрос f от x применяет f ко
[01:07:25.420 --> 01:07:27.420]  всему остальном, с ресканом.
[01:07:29.420 --> 01:07:31.420]  Ну, такое просто вы можете встретить,
[01:07:31.420 --> 01:07:33.420]  если будете читать про boost pp
[01:07:33.420 --> 01:07:35.420]  или еще какие-то библиотеки
[01:07:35.420 --> 01:07:37.420]  припроцессорные. Популярный, модный
[01:07:37.420 --> 01:07:39.420]  макрос. Везде есть.
[01:07:41.420 --> 01:07:43.420]  Ну и что мы делаем? Мы применяем
[01:07:43.420 --> 01:07:45.420]  tuple add 2 к какой-то фигне.
[01:07:45.420 --> 01:07:47.420]  Что такое tuple add 2?
[01:07:47.420 --> 01:07:49.420]  Вообще, что такое tuple?
[01:07:49.420 --> 01:07:51.420]  Про tuple пока не было слайда.
[01:07:51.420 --> 01:07:53.420]  Странно, что в такой последовательности.
[01:07:53.420 --> 01:07:55.420]  Ну ладно. Но tuple это просто
[01:07:55.420 --> 01:07:57.420]  через запятую написаны какие-то
[01:07:57.420 --> 01:07:59.420]  токены.
[01:08:01.420 --> 01:08:03.420]  Нет, то же самое.
[01:08:03.420 --> 01:08:05.420]  Мы говорим, что мы принимаем два аргумента
[01:08:05.420 --> 01:08:07.420]  и последовательность любых
[01:08:07.420 --> 01:08:09.420]  токенов.
[01:08:09.420 --> 01:08:11.420]  Два аргумента, в смысле, разделенные запятыми.
[01:08:11.420 --> 01:08:13.420]  А вот дальше, что там есть, вообще пофиг.
[01:08:13.420 --> 01:08:15.420]  Вот так тоже можно.
[01:08:17.420 --> 01:08:19.420]  И что а, что вот эту произвольную
[01:08:19.420 --> 01:08:21.420]  последовательность токенов мы выкидываем нафиг,
[01:08:21.420 --> 01:08:23.420]  и оставляем только второй элемент.
[01:08:23.420 --> 01:08:25.420]  То есть это как tuple считается,
[01:08:25.420 --> 01:08:27.420]  второй элемент из него достали.
[01:08:27.420 --> 01:08:29.420]  О!
[01:08:31.420 --> 01:08:33.420]  То есть тут как бы через какой-то
[01:08:33.420 --> 01:08:35.420]  f от x странный, но написано
[01:08:35.420 --> 01:08:37.420]  tuple от всего, что справа.
[01:08:37.420 --> 01:08:39.420]  Так.
[01:08:39.420 --> 01:08:41.420]  Ну вот тут.
[01:08:43.420 --> 01:08:45.420]  Вот.
[01:08:45.420 --> 01:08:47.420]  Да, f от x
[01:08:47.420 --> 01:08:49.420]  rescan делает, неважно, запомнили.
[01:08:49.420 --> 01:08:51.420]  Надо распарсить все остальное.
[01:08:51.420 --> 01:08:53.420]  То есть вот это
[01:08:53.420 --> 01:08:55.420]  ровно та идея, которую я только что сказал.
[01:08:55.420 --> 01:08:57.420]  Видите, вот из empty expand
[01:08:57.420 --> 01:08:59.420]  дальше в args подставлен.
[01:08:59.420 --> 01:09:01.420]  И круглые скобочки.
[01:09:01.420 --> 01:09:03.420]  А потом еще какое-то колдовство.
[01:09:03.420 --> 01:09:05.420]  Запятая, ноль запятая.
[01:09:05.420 --> 01:09:07.420]  Видите, из empty
[01:09:07.420 --> 01:09:09.420]  expand, правда?
[01:09:09.420 --> 01:09:11.420]  Вот он просто в запятая 1 раскрывается.
[01:09:11.420 --> 01:09:13.420]  Скажите мне, во что
[01:09:13.420 --> 01:09:15.420]  вот эта вот вся фигня раскроется,
[01:09:15.420 --> 01:09:17.420]  на что я указываю,
[01:09:17.420 --> 01:09:19.420]  если в args пустой?
[01:09:23.420 --> 01:09:25.420]  Продикцуйте последовательность токенов, кто смелый.
[01:09:25.420 --> 01:09:27.420]  Ноль запятая.
[01:09:27.420 --> 01:09:29.420]  Нет, ну в args пустой был.
[01:09:31.420 --> 01:09:33.420]  Что?
[01:09:33.420 --> 01:09:35.420]  Ну я tuple закрыл, вот это все неинтересно.
[01:09:35.420 --> 01:09:37.420]  Ну в запятая
[01:09:37.420 --> 01:09:39.420]  неважно.
[01:09:41.420 --> 01:09:43.420]  Это все внутри аргументы.
[01:09:43.420 --> 01:09:45.420]  Ну без tuple, да.
[01:09:45.420 --> 01:09:47.420]  Без tuple.
[01:09:47.420 --> 01:09:49.420]  Так, еще раз.
[01:09:53.420 --> 01:09:55.420]  Да, запятая 1,
[01:09:55.420 --> 01:09:57.420]  запятая 0, запятая.
[01:09:57.420 --> 01:09:59.420]  Просто из empty expand раскроется в запятая 1,
[01:09:59.420 --> 01:10:01.420]  а дальше запятая 0, запятая останется.
[01:10:01.420 --> 01:10:03.420]  А если в args
[01:10:03.420 --> 01:10:05.420]  не пустой, во что это раскроется?
[01:10:09.420 --> 01:10:11.420]  Ну непонятный вопрос,
[01:10:11.420 --> 01:10:13.420]  но по факту просто в args раскроется как-то.
[01:10:13.420 --> 01:10:15.420]  Правда?
[01:10:15.420 --> 01:10:17.420]  Все остальное нам не особо важно.
[01:10:17.420 --> 01:10:19.420]  Ну будет в args написана какая-то лютая
[01:10:19.420 --> 01:10:21.420]  последовательность токенов,
[01:10:21.420 --> 01:10:23.420]  но нам особо и неважно.
[01:10:25.420 --> 01:10:27.420]  А теперь,
[01:10:27.420 --> 01:10:29.420]  что на самом деле произойдет?
[01:10:35.420 --> 01:10:37.420]  tuple это 2.
[01:10:37.420 --> 01:10:39.420]  Будет брать второй элемент.
[01:10:39.420 --> 01:10:41.420]  В args?
[01:10:41.420 --> 01:10:43.420]  Если в args есть запятые,
[01:10:43.420 --> 01:10:45.420]  то все немножко сломается, это правда.
[01:10:45.420 --> 01:10:47.420]  Но не факт,
[01:10:47.420 --> 01:10:49.420]  потому что здесь ресканы,
[01:10:49.420 --> 01:10:51.420]  хитрое число раз запускается, и может быть,
[01:10:51.420 --> 01:10:53.420]  но не факт.
[01:10:53.420 --> 01:10:55.420]  Надо попробовать, сейчас попробуем.
[01:10:55.420 --> 01:10:57.420]  Но если вот предположить,
[01:10:57.420 --> 01:10:59.420]  что в smt не пихают запятых,
[01:10:59.420 --> 01:11:01.420]  а мы где его использовали?
[01:11:01.420 --> 01:11:03.420]  Мы его использовали вот здесь.
[01:11:03.420 --> 01:11:05.420]  И тут как бы
[01:11:05.420 --> 01:11:07.420]  ну могут пихнуть запятую.
[01:11:07.420 --> 01:11:09.420]  Ну не должны.
[01:11:09.420 --> 01:11:11.420]  Кажется там
[01:11:11.420 --> 01:11:13.420]  синтоксический максимум
[01:11:13.420 --> 01:11:15.420]  cast expression в кейсе разрешен.
[01:11:15.420 --> 01:11:17.420]  А, а у нас в кейсе скупки опять.
[01:11:17.420 --> 01:11:19.420]  Ну да,
[01:11:19.420 --> 01:11:21.420]  как бы считаем, что нет
[01:11:21.420 --> 01:11:23.420]  запятых. Потом их тоже можно
[01:11:23.420 --> 01:11:25.420]  побороть, но давайте хотя бы так справимся.
[01:11:25.420 --> 01:11:27.420]  Если запятых нет,
[01:11:27.420 --> 01:11:29.420]  то вот эта все последовательность
[01:11:29.420 --> 01:11:31.420]  докинов без запятых,
[01:11:31.420 --> 01:11:33.420]  а вот это второй аргумент
[01:11:33.420 --> 01:11:35.420]  для tuple add 2.
[01:11:35.420 --> 01:11:37.420]  То есть tuple add 2
[01:11:37.420 --> 01:11:39.420]  вернет нам ноль, если вот этот
[01:11:39.420 --> 01:11:41.420]  из mt-expand не заэкспандился.
[01:11:41.420 --> 01:11:43.420]  А если
[01:11:43.420 --> 01:11:45.420]  в args был пустой и он заэкспандился,
[01:11:45.420 --> 01:11:47.420]  то вот это вот запятая
[01:11:47.420 --> 01:11:49.420]  1, это и будет
[01:11:49.420 --> 01:11:51.420]  второй аргумент для tuple add 2.
[01:11:51.420 --> 01:11:53.420]  Да?
[01:11:53.420 --> 01:11:55.420]  Потому что первый аргумент, он между вот этой
[01:11:55.420 --> 01:11:57.420]  запятой и вот этой, и он пустой.
[01:11:57.420 --> 01:11:59.420]  Ничего.
[01:11:59.420 --> 01:12:01.420]  Вы поняли,
[01:12:01.420 --> 01:12:03.420]  как это работает?
[01:12:07.420 --> 01:12:09.420]  Это жутко просто.
[01:12:09.420 --> 01:12:11.420]  Этот фокус постоянно
[01:12:11.420 --> 01:12:13.420]  нас будет преследовать.
[01:12:13.420 --> 01:12:15.420]  Вот этот фокус, что типа подставим в args
[01:12:15.420 --> 01:12:17.420]  и куда-нибудь, потом там типа если
[01:12:17.420 --> 01:12:19.420]  он раскроется, то раскроется, если не раскроется, то нет.
[01:12:23.420 --> 01:12:25.420]  Tuple add 2 вернет вам
[01:12:25.420 --> 01:12:27.420]  либо ноль, либо один.
[01:12:33.420 --> 01:12:35.420]  Типа того. Нет, из mt-expand
[01:12:35.420 --> 01:12:37.420]  оно раскроется.
[01:12:37.420 --> 01:12:39.420]  Вот сейчас вот это вот от из mt-expand
[01:12:39.420 --> 01:12:41.420]  до вот этих вот круглых скобок в конце.
[01:12:43.420 --> 01:12:45.420]  Вернись назад. А это нет, наоборот,
[01:12:45.420 --> 01:12:47.420]  это не раскроет.
[01:12:47.420 --> 01:12:49.420]  Назад. Да. Вот.
[01:12:49.420 --> 01:12:51.420]  От из mt-expand до круглых скобок оно раскроется
[01:12:51.420 --> 01:12:53.420]  либо в один,
[01:12:53.420 --> 01:12:55.420]  либо в выражение
[01:12:55.420 --> 01:12:57.420]  без запятых, либо в выражение с одной запятой.
[01:12:57.420 --> 01:12:59.420]  Тем самым поменяв,
[01:12:59.420 --> 01:13:01.420]  кто здесь будет второй по номеру.
[01:13:01.420 --> 01:13:03.420]  Вот. В этом вся идея.
[01:13:05.420 --> 01:13:07.420]  Давайте так. Поднимите руку, если эта идея
[01:13:07.420 --> 01:13:09.420]  до вас дошла.
[01:13:09.420 --> 01:13:11.420]  Ну вот. Плюс-минус.
[01:13:11.420 --> 01:13:13.420]  Ну хорошо.
[01:13:13.420 --> 01:13:15.420]  Да. Может,
[01:13:15.420 --> 01:13:17.420]  вопросы какие-то.
[01:13:17.420 --> 01:13:19.420]  Потому что дальше оно будет...
[01:13:19.420 --> 01:13:21.420]  Что?
[01:13:25.420 --> 01:13:27.420]  Функциональный макрос не варарганный
[01:13:27.420 --> 01:13:29.420]  нам тупо выдадут ошибку.
[01:13:29.420 --> 01:13:31.420]  Да, тупо при процессоре
[01:13:31.420 --> 01:13:33.420]  выдадут ошибку. Вы не столько, сколько я ожидал
[01:13:33.420 --> 01:13:35.420]  аргументов дали.
[01:13:35.420 --> 01:13:37.420]  Вот так вот.
[01:13:39.420 --> 01:13:41.420]  Плохо старался, значит.
[01:13:41.420 --> 01:13:43.420]  Нет, еще есть УБФ при процессоре.
[01:13:45.420 --> 01:13:47.420]  Ну, с этим борется
[01:13:47.420 --> 01:13:48.420]  активно один из разработчиков
[01:13:48.420 --> 01:13:50.420]  к вам, которому не нравится
[01:13:50.420 --> 01:13:52.420]  всю УБФ за седьмой фазотрансляцией.
[01:13:54.420 --> 01:13:56.420]  Да.
[01:13:56.420 --> 01:13:58.420]  Не пусто.
[01:13:58.420 --> 01:14:00.420]  Вот этот из mt-expand
[01:14:00.420 --> 01:14:02.420]  не раскроется.
[01:14:02.420 --> 01:14:04.420]  А в арксах мы предположим, что
[01:14:04.420 --> 01:14:06.420]  запятых нет.
[01:14:06.420 --> 01:14:08.420]  Значит, посчитаем, ну вот, что
[01:14:08.420 --> 01:14:10.420]  2 делает.
[01:14:10.420 --> 01:14:12.420]  Возвращает второй аргумент.
[01:14:12.420 --> 01:14:14.420]  Вернее,
[01:14:14.420 --> 01:14:16.420]  в последовательности разделенные запятыми
[01:14:16.420 --> 01:14:18.420]  возвращает все, что после
[01:14:18.420 --> 01:14:20.420]  первой запятой.
[01:14:20.420 --> 01:14:22.420]  Если вот эта
[01:14:22.420 --> 01:14:24.420]  вся херня не раскрылась...
[01:14:24.420 --> 01:14:26.420]  Прошу прощения.
[01:14:26.420 --> 01:14:28.420]  Тут хочется ругаться.
[01:14:28.420 --> 01:14:30.420]  Если все это не раскрылось,
[01:14:30.420 --> 01:14:32.420]  то первая запятая будет вот эта.
[01:14:32.420 --> 01:14:34.420]  Вот она.
[01:14:34.420 --> 01:14:36.420]  Иначе вот она.
[01:14:38.420 --> 01:14:40.420]  И из mt-expand.
[01:14:40.420 --> 01:14:42.420]  У нас вот пришел из mt-expand.
[01:14:42.420 --> 01:14:44.420]  Ну, напиши сюда еще
[01:14:44.420 --> 01:14:46.420]  хэш какой-нибудь, чтобы никто не догадался,
[01:14:46.420 --> 01:14:48.420]  как это называется.
[01:14:48.420 --> 01:14:50.420]  Из mt, от mt-expand
[01:14:50.420 --> 01:14:52.420]  и без скобок.
[01:14:52.420 --> 01:14:54.420]  Мне кажется, что вместо
[01:14:54.420 --> 01:14:56.420]  вареж поставится еще раз из mt-expand
[01:14:56.420 --> 01:14:58.420]  и там придется один respawn.
[01:14:58.420 --> 01:15:00.420]  А, на походу уже два respawn.
[01:15:00.420 --> 01:15:02.420]  Ну, просто сделайте так, чтобы ваш пользователь
[01:15:02.420 --> 01:15:04.420]  не мог вот эту фигню куда-то
[01:15:04.420 --> 01:15:06.420]  вписать. Хэш впишите длинно.
[01:15:06.420 --> 01:15:08.420]  Не совсем.
[01:15:08.420 --> 01:15:10.420]  Там, по-моему, уже в таковый скан.
[01:15:10.420 --> 01:15:12.420]  Ну, короче, вот еще...
[01:15:12.420 --> 01:15:14.420]  Хэш это плохо, потому что пользователь
[01:15:14.420 --> 01:15:16.420]  в какой-то момент решит, а я хочу хэш
[01:15:16.420 --> 01:15:18.420]  и он случайно выберет его.
[01:15:18.420 --> 01:15:20.420]  Ну, окей.
[01:15:20.420 --> 01:15:22.420]  Есть нижнее подчеркивание
[01:15:22.420 --> 01:15:24.420]  каунтера. Ну, короче, сейчас будет
[01:15:24.420 --> 01:15:26.420]  как можно уникальные имена для этих штук
[01:15:26.420 --> 01:15:28.420]  сделать. Окей.
[01:15:28.420 --> 01:15:30.420]  Трюк лютейший,
[01:15:30.420 --> 01:15:32.420]  но полезный.
[01:15:32.420 --> 01:15:34.420]  Теперь
[01:15:34.420 --> 01:15:36.420]  немножко опять вот сейчас
[01:15:36.420 --> 01:15:38.420]  погрузились в какую-то лютую дичь.
[01:15:38.420 --> 01:15:40.420]  Сейчас будет немножко простого и полезного.
[01:15:40.420 --> 01:15:42.420]  Вы пишете свой
[01:15:42.420 --> 01:15:44.420]  macros for each.
[01:15:44.420 --> 01:15:46.420]  Ну, захотелось вам.
[01:15:46.420 --> 01:15:48.420]  Или вы можете писать свой macros
[01:15:48.420 --> 01:15:50.420]  assert once. Видели когда-нибудь
[01:15:50.420 --> 01:15:52.420]  такое?
[01:15:52.420 --> 01:15:54.420]  Ну, типа assert, но который
[01:15:54.420 --> 01:15:56.420]  срабатывает только один раз.
[01:15:56.420 --> 01:15:58.420]  Ну, assert не обязательно убивает программу.
[01:15:58.420 --> 01:16:00.420]  Можно сделать assert, который
[01:16:00.420 --> 01:16:02.420]  типа выскакивает окошко и такое.
[01:16:02.420 --> 01:16:04.420]  Окошко сломался. Хотите попробовать продолжить?
[01:16:04.420 --> 01:16:06.420]  Да. Фигарь дальше.
[01:16:06.420 --> 01:16:08.420]  Ну, вот в геймдеве они постоянно
[01:16:08.420 --> 01:16:10.420]  используются.
[01:16:10.420 --> 01:16:12.420]  И можно... Ну, если это каждый кадр
[01:16:12.420 --> 01:16:14.420]  происходит, то не очень вы поиграете,
[01:16:14.420 --> 01:16:16.420]  что у вас каждый кадр окошко сломался.
[01:16:16.420 --> 01:16:18.420]  Ну, вот можно сделать кнопку
[01:16:18.420 --> 01:16:20.420]  пропустить насовсем и больше не показывать.
[01:16:20.420 --> 01:16:22.420]  Ну, и чтобы эта кнопка работала,
[01:16:22.420 --> 01:16:24.420]  нужна там какая-нибудь статическая bool
[01:16:24.420 --> 01:16:26.420]  меня пропустили.
[01:16:26.420 --> 01:16:28.420]  Внутри macros assert объявляйте static bool
[01:16:28.420 --> 01:16:30.420]  меня пропустили и дальше уже пишете
[01:16:30.420 --> 01:16:32.420]  и если условие не прошло,
[01:16:32.420 --> 01:16:34.420]  то там показывай плашку, что я
[01:16:34.420 --> 01:16:36.420]  сломался.
[01:16:36.420 --> 01:16:38.420]  Ну, тут попроще. Ну, просто цикл
[01:16:38.420 --> 01:16:40.420]  и цикл. Вот вы так написали код.
[01:16:40.420 --> 01:16:42.420]  И все сломалось.
[01:16:42.420 --> 01:16:44.420]  Ну, с каким-то macros
[01:16:44.420 --> 01:16:46.420]  foreach еще очевидно, что оно может сломаться.
[01:16:48.420 --> 01:16:50.420]  Но если это
[01:16:50.420 --> 01:16:52.420]  assert или assert
[01:16:52.420 --> 01:16:54.420]  once, то не очевидно.
[01:16:54.420 --> 01:16:56.420]  Оно может выглядеть как обычный вызов функции.
[01:16:56.420 --> 01:16:58.420]  И на самом деле ничего
[01:16:58.420 --> 01:17:00.420]  не работает. Почему сломано? Видите?
[01:17:00.420 --> 01:17:02.420]  Да.
[01:17:02.420 --> 01:17:04.420]  Что только первая строчка будет внутри цикла,
[01:17:04.420 --> 01:17:06.420]  а все остальное наружу вылетит и все.
[01:17:06.420 --> 01:17:08.420]  Конец.
[01:17:08.420 --> 01:17:10.420]  Как это фиксить?
[01:17:10.420 --> 01:17:12.420]  Просто фигурные скобочки
[01:17:12.420 --> 01:17:14.420]  обернуть плохо.
[01:17:14.420 --> 01:17:16.420]  Там начнутся еще проблемы с else.
[01:17:16.420 --> 01:17:18.420]  Потому что если вы напишете
[01:17:18.420 --> 01:17:20.420]  два if без фигурных
[01:17:20.420 --> 01:17:22.420]  скобок внутри свой macros,
[01:17:22.420 --> 01:17:24.420]  а потом else, то в зависимости от того,
[01:17:24.420 --> 01:17:26.420]  есть ли сейчас или что-то такое было.
[01:17:26.420 --> 01:17:28.420]  Да,
[01:17:28.420 --> 01:17:30.420]  только фигурные скобочки
[01:17:30.420 --> 01:17:32.420]  тоже ломаются в каком-то случае.
[01:17:32.420 --> 01:17:34.420]  Предлагаю об этом вам самостоятельно подумать.
[01:17:34.420 --> 01:17:36.420]  Может вопрос?
[01:17:36.420 --> 01:17:38.420]  Да.
[01:17:38.420 --> 01:17:40.420]  В принципе,
[01:17:40.420 --> 01:17:42.420]  на отдельной строчке является
[01:17:42.420 --> 01:17:44.420]  foreach.
[01:17:44.420 --> 01:17:46.420]  Я привел пример, где такое реально может пригодиться.
[01:17:46.420 --> 01:17:48.420]  Здесь это
[01:17:48.420 --> 01:17:50.420]  бесполезно.
[01:17:50.420 --> 01:17:52.420]  Это лучше, конечно,
[01:17:52.420 --> 01:17:54.420]  как-то делать.
[01:17:54.420 --> 01:17:56.420]  Не, он не вытаскивается.
[01:18:00.420 --> 01:18:02.420]  Тут шедуинг как бы происходит.
[01:18:02.420 --> 01:18:04.420]  Это еще случайно получилось.
[01:18:04.420 --> 01:18:06.420]  Короче, нормальный пример
[01:18:06.420 --> 01:18:08.420]  это assert once.
[01:18:08.420 --> 01:18:10.420]  Реальный пацанский пример,
[01:18:10.420 --> 01:18:12.420]  где нужно сначала объявить статик-применную,
[01:18:12.420 --> 01:18:14.420]  уже произошел ли ассерт,
[01:18:14.420 --> 01:18:16.420]  а дальше какой-то код написать.
[01:18:16.420 --> 01:18:18.420]  Здесь игрушечный пример.
[01:18:20.420 --> 01:18:22.420]  Чтобы это сломалось.
[01:18:22.420 --> 01:18:24.420]  Это искусственный пример.
[01:18:26.420 --> 01:18:28.420]  Давайте придумаем кейс,
[01:18:28.420 --> 01:18:30.420]  когда фигурные скобочки ломаются.
[01:18:32.420 --> 01:18:34.420]  Давайте реально придумаем
[01:18:34.420 --> 01:18:36.420]  или мы можем загуглить
[01:18:36.420 --> 01:18:38.420]  подумать интереснее.
[01:18:38.420 --> 01:18:40.420]  Давайте мы задефинили
[01:18:42.420 --> 01:18:44.420]  какой-нибудь assert once
[01:18:46.420 --> 01:18:48.420]  и задефинили его как
[01:18:48.420 --> 01:18:50.420]  статик,
[01:18:50.420 --> 01:18:52.420]  бул,
[01:18:52.420 --> 01:18:54.420]  кек
[01:18:54.420 --> 01:18:56.420]  и еще.
[01:18:56.420 --> 01:18:58.420]  Вот так считаем.
[01:18:58.420 --> 01:19:00.420]  В какой момент это сломает?
[01:19:00.420 --> 01:19:02.420]  Бул равно нулю.
[01:19:02.420 --> 01:19:04.420]  Я, конечно, C-программист.
[01:19:04.420 --> 01:19:06.420]  В какой момент сломается
[01:19:06.420 --> 01:19:08.420]  assert once?
[01:19:10.420 --> 01:19:12.420]  В какой момент он будет вести себя не так,
[01:19:12.420 --> 01:19:14.420]  как вызов функции?
[01:19:14.420 --> 01:19:16.420]  Что будет, если
[01:19:16.420 --> 01:19:18.420]  с if сделать?
[01:19:22.420 --> 01:19:24.420]  2if, а вот это шняга.
[01:19:26.420 --> 01:19:28.420]  else
[01:19:28.420 --> 01:19:30.420]  по дефолту он куда?
[01:19:30.420 --> 01:19:32.420]  Сюда пойдет?
[01:19:32.420 --> 01:19:34.420]  К последнему.
[01:19:34.420 --> 01:19:36.420]  Кажется, к последнему, но это
[01:19:36.420 --> 01:19:38.420]  не повлияет.
[01:19:40.420 --> 01:19:42.420]  Плохо.
[01:19:44.420 --> 01:19:46.420]  Что-то я
[01:19:46.420 --> 01:19:48.420]  не могу вспомнить.
[01:19:48.420 --> 01:19:50.420]  Давайте это найдем.
[01:19:52.420 --> 01:19:54.420]  Но это тоже
[01:19:54.420 --> 01:19:56.420]  странно.
[01:19:56.420 --> 01:19:58.420]  Почему
[01:19:58.420 --> 01:20:00.420]  фигурные скобки не работают?
[01:20:00.420 --> 01:20:02.420]  Где-то должен быть пример точно
[01:20:02.420 --> 01:20:04.420]  на...
[01:20:08.420 --> 01:20:10.420]  Где-нибудь...
[01:20:10.420 --> 01:20:12.420]  О!
[01:20:14.420 --> 01:20:16.420]  О, во!
[01:20:16.420 --> 01:20:18.420]  Все.
[01:20:18.420 --> 01:20:20.420]  Я вспомнил.
[01:20:20.420 --> 01:20:22.420]  Вернее, я подсмотрел.
[01:20:22.420 --> 01:20:24.420]  Давайте, да.
[01:20:24.420 --> 01:20:26.420]  if условия
[01:20:26.420 --> 01:20:28.420]  assert once.
[01:20:28.420 --> 01:20:30.420]  else, что-то там.
[01:20:34.420 --> 01:20:36.420]  Что-то не работает, да?
[01:20:36.420 --> 01:20:38.420]  Видите, где оно сломалось?
[01:20:42.420 --> 01:20:44.420]  Точка
[01:20:44.420 --> 01:20:46.420]  запятой.
[01:20:46.420 --> 01:20:48.420]  Противно как-то, да?
[01:20:48.420 --> 01:20:50.420]  Вот если вы функцию вызываете
[01:20:50.420 --> 01:20:52.420]  вот так пишете, вот с этим макросом
[01:20:52.420 --> 01:20:54.420]  надо так писать.
[01:20:54.420 --> 01:20:56.420]  Вот.
[01:20:56.420 --> 01:20:58.420]  То есть вот объективная причина,
[01:20:58.420 --> 01:21:00.420]  почему просто фигурные скобки,
[01:21:00.420 --> 01:21:02.420]  это ну как-то да.
[01:21:02.420 --> 01:21:04.420]  Ну и это
[01:21:04.420 --> 01:21:06.420]  бывает, что вызывает
[01:21:06.420 --> 01:21:08.420]  реальные баги.
[01:21:08.420 --> 01:21:10.420]  Да, опять же,
[01:21:10.420 --> 01:21:12.420]  я правильно начал думать про ifelse,
[01:21:12.420 --> 01:21:14.420]  потому что если мы еще один
[01:21:14.420 --> 01:21:16.420]  с dc добавим, скажем, что вот это все
[01:21:16.420 --> 01:21:18.420]  у нас было вот так, и тут еще один
[01:21:18.420 --> 01:21:20.420]  if был.
[01:21:22.420 --> 01:21:24.420]  У тебя точка запятой
[01:21:24.420 --> 01:21:26.420]  перегрывает все вложенные
[01:21:26.420 --> 01:21:28.420]  стейтменты. Все вложенные.
[01:21:28.420 --> 01:21:30.420]  Типа это простой стейтмент, который идет
[01:21:30.420 --> 01:21:32.420]  после всех ifов. Блин, ну ладно.
[01:21:32.420 --> 01:21:34.420]  Ну по-моему там еще что-то такое
[01:21:34.420 --> 01:21:36.420]  происходило в каких-то ситуациях.
[01:21:36.420 --> 01:21:38.420]  Короче, это может быть очень опасно.
[01:21:38.420 --> 01:21:40.420]  И ну были всякие истории
[01:21:40.420 --> 01:21:42.420]  ужасов про то, как это взрывалось,
[01:21:42.420 --> 01:21:44.420]  настолько не очевидно, что
[01:21:44.420 --> 01:21:46.420]  ой-ой-ой. Поэтому
[01:21:46.420 --> 01:21:48.420]  просто не надо пытаться
[01:21:48.420 --> 01:21:50.420]  выпендриваться, что-то придумывать.
[01:21:50.420 --> 01:21:52.420]  Вот этот дедовский метод, который
[01:21:52.420 --> 01:21:54.420]  просто всегда работает.
[01:21:54.420 --> 01:21:56.420]  Do while 0.
[01:21:56.420 --> 01:21:58.420]  Оно ведет себя как блок,
[01:21:58.420 --> 01:22:00.420]  первое, но второе, после
[01:22:00.420 --> 01:22:02.420]  этого нужно ставить точку запятой.
[01:22:02.420 --> 01:22:04.420]  Все.
[01:22:06.420 --> 01:22:08.420]  Если не поставить, то вам скажут не хватает
[01:22:08.420 --> 01:22:10.420]  точки запятой, как и при вызове функции.
[01:22:12.420 --> 01:22:14.420]  Вот. Оно
[01:22:14.420 --> 01:22:16.420]  просто работает. Я рекомендую вам все
[01:22:16.420 --> 01:22:18.420]  такие многострочные макросы обращивать
[01:22:18.420 --> 01:22:20.420]  в Do while 0 вообще всегда
[01:22:20.420 --> 01:22:22.420]  и не рисковать
[01:22:22.420 --> 01:22:24.420]  с этой жуткой наукой
[01:22:24.420 --> 01:22:26.420]  припроцессорной.
[01:22:26.420 --> 01:22:28.420]  Вот тут
[01:22:28.420 --> 01:22:30.420]  еще есть такие странные выражения,
[01:22:30.420 --> 01:22:32.420]  где скобочки вокруг аргументов.
[01:22:32.420 --> 01:22:34.420]  Понимаете, зачем это?
[01:22:36.420 --> 01:22:38.420]  Что?
[01:22:38.420 --> 01:22:40.420]  Да.
[01:22:40.420 --> 01:22:42.420]  Что-то вроде SQL injection
[01:22:42.420 --> 01:22:44.420]  можно устроить, потому что никто же
[01:22:44.420 --> 01:22:46.420]  не мешает вместо f здесь написать
[01:22:46.420 --> 01:22:48.420]  какую-нибудь хрень,
[01:22:48.420 --> 01:22:50.420]  точка запятая, и потом уже нормальное
[01:22:50.420 --> 01:22:52.420]  название функции.
[01:22:54.420 --> 01:22:56.420]  Смотрите, если вместо, если вот здесь
[01:22:56.420 --> 01:22:58.420]  круглые скобки убрать вокруг f и просто
[01:22:58.420 --> 01:23:00.420]  f оставить,
[01:23:00.420 --> 01:23:02.420]  может кто-то ваш forage
[01:23:02.420 --> 01:23:04.420]  вызвать, вписав вот сюда
[01:23:04.420 --> 01:23:06.420]  вот внутрь,
[01:23:06.420 --> 01:23:08.420]  вызов чего-то вообще другого.
[01:23:10.420 --> 01:23:12.420]  Точка запятая и название функции.
[01:23:12.420 --> 01:23:14.420]  Оно сюда подставится, и как бы будет
[01:23:14.420 --> 01:23:16.420]  cout handle, а потом
[01:23:16.420 --> 01:23:18.420]  название функции, и оно вот к этому идет.
[01:23:18.420 --> 01:23:20.420]  И вот тут, ну как бы, такая SQL
[01:23:20.420 --> 01:23:22.420]  инъекция.
[01:23:22.420 --> 01:23:26.420]  Короче,
[01:23:26.420 --> 01:23:28.420]  подставить мусор можно всякий,
[01:23:28.420 --> 01:23:30.420]  который поверх этого всего идет.
[01:23:32.420 --> 01:23:34.420]  Я вижу в глазах непонимание, неужто
[01:23:34.420 --> 01:23:36.420]  вы этого никогда не видели, молодые люди?
[01:23:40.420 --> 01:23:42.420]  Скобочки предотвращают
[01:23:42.420 --> 01:23:44.420]  влияние
[01:23:44.420 --> 01:23:46.420]  ваших аргументов
[01:23:46.420 --> 01:23:48.420]  на окружение
[01:23:48.420 --> 01:23:50.420]  того, что происходит.
[01:23:52.420 --> 01:23:54.420]  Ммм,
[01:23:54.420 --> 01:23:56.420]  что нам нужно?
[01:24:00.420 --> 01:24:02.420]  Ммм,
[01:24:02.420 --> 01:24:04.420]  да.
[01:24:06.420 --> 01:24:08.420]  Это хорошая идея, но
[01:24:08.420 --> 01:24:10.420]  нету.
[01:24:10.420 --> 01:24:12.420]  Ну,
[01:24:12.420 --> 01:24:14.420]  ну,
[01:24:14.420 --> 01:24:16.420]  ну,
[01:24:16.420 --> 01:24:18.420]  ну,
[01:24:18.420 --> 01:24:20.420]  ну,
[01:24:20.420 --> 01:24:22.420]  ну,
[01:24:24.420 --> 01:24:26.420]  так,
[01:24:26.420 --> 01:24:28.420]  что там у нас сругается?
[01:24:30.420 --> 01:24:32.420]  Точка запятой.
[01:24:34.420 --> 01:24:38.420]  Да.
[01:24:38.420 --> 01:24:40.420]  Я не знаю зачем.
[01:24:40.420 --> 01:24:42.420]  Ну,
[01:24:42.420 --> 01:24:44.420]  точку запятой нельзя, но я могу по-другому,
[01:24:44.420 --> 01:24:46.420]  у меня есть оператор запятая.
[01:24:46.420 --> 01:24:48.420]  Мм,
[01:24:48.420 --> 01:24:54.420]  Ладно, нет, ну плохо. Как привести пример, когда это совсем ломается?
[01:24:54.420 --> 01:24:58.420]  Можно строгу стереть строгую литералу.
[01:24:58.420 --> 01:25:03.420]  О, вот. Вот так действительно очень странно ломается.
[01:25:03.420 --> 01:25:09.420]  Вот с текущей нашей реализации, где в круглые скобки заключено, получается бред.
[01:25:09.420 --> 01:25:15.420]  Мы подставили САУДФУ, и получилось САУДФУ в скобках, и какая-то хрень.
[01:25:15.420 --> 01:25:22.420]  Правда? Если эти скобки убрать, то получится вполне нормальный код.
[01:25:22.420 --> 01:25:29.420]  Ну потому что мы... ну хлам вывелся, потому что я здесь рандомную память просто накидал.
[01:25:29.420 --> 01:25:34.420]  Но подставилась вот такая шняга вместо F.
[01:25:34.420 --> 01:25:38.420]  И это уже интерпретируется совсем не так, как вы думали.
[01:25:38.420 --> 01:25:42.420]  Теперь вот только этот хвост это как бы вызов функции,
[01:25:42.420 --> 01:25:47.420]  а вот это еще как бы сделать инъекцию какой-то хрени непонятной,
[01:25:47.420 --> 01:25:50.420]  которая меняет синтоксический смысл происходящего.
[01:25:50.420 --> 01:25:55.420]  А вот теперь мы можем точку запятой вкинуть в аргумент макроса? Верни обратно.
[01:25:55.420 --> 01:25:57.420]  Какую?
[01:25:57.420 --> 01:26:00.420]  Вот сейчас верни макрос обратно туда, как был.
[01:26:00.420 --> 01:26:04.420]  И вот теперь вот мы вот на DCA, интересно, D&L хотели сделать.
[01:26:04.420 --> 01:26:07.420]  А, да, подожди, может там это...
[01:26:07.420 --> 01:26:11.420]  Еще вот так бахну.
[01:26:11.420 --> 01:26:15.420]  Ну вообще, кажется, точка запятой от нее...
[01:26:15.420 --> 01:26:19.420]  Прекрасно. А точка запятой обычный токен, как бы всем рекомендую.
[01:26:19.420 --> 01:26:21.420]  Видите, какой бред произошел?
[01:26:21.420 --> 01:26:23.420]  Ну типа...
[01:26:23.420 --> 01:26:27.420]  На какой стороне это может быть?
[01:26:31.420 --> 01:26:34.420]  Ну то есть... это же бред какой-то.
[01:26:34.420 --> 01:26:39.420]  Вот вы, наверное, не хотите все-таки, чтобы пользователи вашего макроса такую дичь писали.
[01:26:39.420 --> 01:26:43.420]  Прекрасно.
[01:26:43.420 --> 01:26:49.420]  Короче, поэтому всегда все же все аргументы, которые вы используете в плюсовом коде внутри макроса,
[01:26:49.420 --> 01:26:53.420]  их надо в скобке заключать, чтобы вот эту дичь избежать,
[01:26:53.420 --> 01:26:57.420]  когда неправильно интерпретируется, типа, что произошло.
[01:26:57.420 --> 01:27:02.420]  Да, ну, короче, вот с скейл-инъекциями кто имел опыт, вот это вот примерно из той же области.
[01:27:02.420 --> 01:27:06.420]  Когда не сонетаясь данные, вот все ломается.
[01:27:07.420 --> 01:27:09.420]  Давайте возвращаться и ехать дальше.
[01:27:09.420 --> 01:27:11.420]  Так что вот рекомендации.
[01:27:11.420 --> 01:27:18.420]  Если вы пишите макросы, которые вставляют всякий обычный плюсовый код в программу,
[01:27:18.420 --> 01:27:25.420]  заключайте их в do while 0 и аргументы в круглой скобке, везде где их используете.
[01:27:25.420 --> 01:27:31.420]  А если вы делаете там макрос, который скрывается в укрытии скобки, и там что-то потом...
[01:27:31.420 --> 01:27:35.420]  Тогда вас просто уволят или на код-ревью как бы забанят.
[01:27:35.420 --> 01:27:39.420]  Ну, всегда можно обойти, поэтому препроцессор – это зло.
[01:27:39.420 --> 01:27:43.420]  Вот мы только что занимались как бы извращениями со скобками и всяким прочим.
[01:27:43.420 --> 01:27:48.420]  Это все неадекватно сложно и обычному программисту нафиг не нужно.
[01:27:48.420 --> 01:27:55.420]  Да, как бы все, что я тут рассказываю, кроме маленького процента, лучше никогда в жизни не использовать.
[01:27:56.420 --> 01:28:01.420]  Перерыв? Ну ты действительно прав, что пора перерыв, потому что у меня горло уже болит.
[01:28:01.420 --> 01:28:05.420]  Давайте тогда перерыв на 9 минут до 50.
[01:28:09.420 --> 01:28:15.420]  Шоу должно продолжаться. Избиение продолжится, пока настрой не улучшится.
[01:28:19.420 --> 01:28:22.420]  Так, ну пока еще нормально. Парочка встроенных макросов.
[01:28:22.420 --> 01:28:27.420]  Они просто прикольные. Вы некоторые из них уже видели. Вот есть Pretty Function, мы его знаем, любим.
[01:28:27.420 --> 01:28:32.420]  Там файл и лайн есть. Ну, очевидно, что они выводят, правда?
[01:28:32.420 --> 01:28:36.420]  Файл заменяется на название текущего файла, лайн – на текущую строку.
[01:28:36.420 --> 01:28:40.420]  И вот из-за них как раз ассерт макрос, про это вроде тоже уже говорили.
[01:28:40.420 --> 01:28:53.420]  Ну да, потому что ты как бы сначала подставляешь макрос ассерт, а потом раскрываешь этих ребят.
[01:28:53.420 --> 01:28:59.420]  Ну там хитро, короче, да. Вот, но чего вы, скорее всего, не знали?
[01:28:59.420 --> 01:29:08.420]  Текущую строку, текущий файл можно менять. Можно писать line 42, и я теперь капитан.
[01:29:08.420 --> 01:29:18.420]  Ну да, пользуется. И как бы… Зачем?
[01:29:18.420 --> 01:29:27.420]  Ну, когда ты как бы раскрываешь кучу каких-то лютых макросов, ты, возможно, сам хочешь проконтролировать,
[01:29:27.420 --> 01:29:34.420]  что тебе, например, в дебажных символах или там вот в этих же файлах и линах будут показывать
[01:29:34.420 --> 01:29:40.420]  о этих строчках. Вот ты, возможно, хочешь, чтобы у тебя там дополнительная какая-то дебажная информация
[01:29:40.420 --> 01:29:45.420]  была про то, кто где и что происходит. Вот через это можно сделать.
[01:29:45.420 --> 01:29:57.420]  Текущая строка новая. Не знаю, мне кажется, только цифры. Если можно что-то другое, то это будет…
[01:29:57.420 --> 01:30:07.420]  В смысле? Ну, компиляторы, например, используют. Когда он macros.assert подставляет, он говорит,
[01:30:07.420 --> 01:30:16.420]  ну типа macros.assert, где-то вот этот файл align написан, и он как бы, ну вот, окей, по-другому.
[01:30:16.420 --> 01:30:23.420]  Вот ты запропроцессил весь свой файл, и дальше хочешь дебажную информацию сгенерировать.
[01:30:23.420 --> 01:30:29.420]  Ну, после того, как вот такой файл с несколькими там macros-ами запропроцессился, может получиться вот такая шняга.
[01:30:29.420 --> 01:30:36.420]  Тебе нужно знать маппинг из вот этой огромной шняги, какие здесь строчки соответствуют каким строчкам в изначальной программе.
[01:30:36.420 --> 01:30:41.420]  Вот ровно через это оно и делается.
[01:30:41.420 --> 01:30:48.420]  Ну, у тебя припроцессится при каждой компиляции файл заново. Да?
[01:30:48.420 --> 01:30:56.420]  Ну да, в твоем коде просто так line писать не надо.
[01:30:56.420 --> 01:31:24.420]  Ну вот, мы видим, что тут оно припроцессировалось, нам тут все STD впихнули.
[01:31:24.420 --> 01:31:30.420]  А вот наш сам мейн, и тут...
[01:31:30.420 --> 01:31:34.420]  Вот эти приколы как слайны.
[01:31:34.420 --> 01:31:36.420]  Какие приколы?
[01:31:36.420 --> 01:31:40.420]  Ну вот, видишь, там просто решетка, по-моему, были когда-то.
[01:31:40.420 --> 01:31:43.420]  Да, это они есть, это они есть.
[01:31:43.420 --> 01:31:53.420]  Если мы сейчас clang...
[01:31:53.420 --> 01:31:57.420]  Вот этот, например.
[01:31:57.420 --> 01:32:00.420]  Ну и тут не через line.
[01:32:00.420 --> 01:32:08.420]  Ну, короче, видимо, оно по-разному работает для того, что вы сами пишете, для того, что компилятор генерирует.
[01:32:08.420 --> 01:32:14.420]  Ну вот как бы, вот на это если посмотреть, то...
[01:32:14.420 --> 01:32:16.420]  Если вот так написать...
[01:32:16.420 --> 01:32:19.420]  Ладно, не могу. Ну, представьте, что это line.
[01:32:19.420 --> 01:32:29.420]  По сути, вот в этом припроцесснутом файле мы говорим компилятору, что вот отныне мы на самом деле идем по коду, который вот в этом файле входном, который слева,
[01:32:29.420 --> 01:32:35.420]  начиная с 21 строки. Вот на 21 строка этого нашего входного файла.
[01:32:35.420 --> 01:32:38.420]  Ну и дальше подряд идет этот код.
[01:32:38.420 --> 01:32:41.420]  Вот, а все остальное как бы уже выкинулось.
[01:32:41.420 --> 01:32:48.420]  Ну вот, зачем это нужно? Как бы компилятор это использует, и вы тоже можете использовать, если у вас какая-то хитрая макросная магия.
[01:32:48.420 --> 01:32:51.420]  Ну, вряд ли вам когда-то доведется.
[01:32:52.420 --> 01:32:54.420]  Там только ее стрим.
[01:32:54.420 --> 01:32:59.420]  Вот этот огромный ее стрим, вот он там прям прилетел, журнющий.
[01:33:03.420 --> 01:33:05.420]  Да.
[01:33:05.420 --> 01:33:08.420]  Мне кажется, что да.
[01:33:08.420 --> 01:33:22.420]  Ну вот, есть, что вот мы сейчас на каком-то билтыне, потом обратно это и обратно сюда.
[01:33:22.420 --> 01:33:24.420]  Ну, что-то такое происходит.
[01:33:28.420 --> 01:33:30.420]  Ну, в общем...
[01:33:30.420 --> 01:33:32.420]  А кто их добавляет?
[01:33:32.420 --> 01:33:34.420]  Припроцессор.
[01:33:34.420 --> 01:33:37.420]  Как, где, когда?
[01:33:37.420 --> 01:33:39.420]  Ну, неважно.
[01:33:39.420 --> 01:33:41.420]  Я не знаю.
[01:33:41.420 --> 01:33:45.420]  Ну плюс-минус, когда ты что-то инклюдишь или какие-то штуки происходят.
[01:33:45.420 --> 01:33:47.420]  Ну, это вот настолько нерелевантно.
[01:33:47.420 --> 01:33:53.420]  Я предлагаю тебе загуглить самостоятельно, если тебе интересно дальше узнать про эти лайны.
[01:33:53.420 --> 01:33:55.420]  Тут слишком много информации.
[01:33:55.420 --> 01:33:58.420]  Мы еще сейчас не успеем что-нибудь, будет обидно.
[01:33:58.420 --> 01:33:59.420]  Давайте побыстрее.
[01:33:59.420 --> 01:34:01.420]  Дейта-тайм есть, вы не поверите.
[01:34:01.420 --> 01:34:03.420]  Можно текущую дату и время смотреть.
[01:34:03.420 --> 01:34:05.420]  Что, их практически было в курке, да?
[01:34:05.420 --> 01:34:07.420]  Прямо в припроцессоре.
[01:34:07.420 --> 01:34:09.420]  И еще каунтер.
[01:34:09.420 --> 01:34:12.420]  Каунтер вам каждый раз новое число выдает.
[01:34:12.420 --> 01:34:17.420]  К вопросу, как получить уникальное имя для вашего нового макросса.
[01:34:17.420 --> 01:34:22.420]  Слепите каунтер с каким-нибудь там майфу.
[01:34:22.420 --> 01:34:31.420]  Если кто-то решит еще раз майфу использовать, но тоже с каунтером, то у вас каунтер уникальный будет.
[01:34:31.420 --> 01:34:35.420]  Но обычно это все-таки используется не для этого, а для объявления переменных.
[01:34:35.420 --> 01:34:39.420]  Если вы в макроссе какую-нибудь глобальную переменную или функцию объявляете,
[01:34:39.420 --> 01:34:46.420]  прилепите через две решетки каунтер к ней, чтобы не возникало конфликтов, когда этот макросс несколько раз использован был.
[01:34:46.420 --> 01:34:48.420]  Еще есть такие штуки.
[01:34:48.420 --> 01:34:51.420]  Про них, я надеюсь, вы слышали, хотя может и нет.
[01:34:51.420 --> 01:34:53.420]  В-первых, hasInclude.
[01:34:53.420 --> 01:34:56.420]  Вы можете проверить, есть ли у вас Include какой-то прямо.
[01:34:56.420 --> 01:34:58.420]  Найдется он или нет.
[01:34:58.420 --> 01:35:03.420]  То есть можно писать, типа if hasInclude, Include.
[01:35:03.420 --> 01:35:09.420]  Иначе вы дай ошибку, что вы не установили такую библиотеку, как ее установить.
[01:35:09.420 --> 01:35:14.420]  Решетка Error, такое тоже есть.
[01:35:14.420 --> 01:35:18.420]  Оно просто выведет то, что вы дальше напишете, как ошибку при процессинге.
[01:35:18.420 --> 01:35:20.420]  И ворнинг еще.
[01:35:20.420 --> 01:35:22.420]  Есть еще Defined.
[01:35:23.420 --> 01:35:28.420]  Вот Defined проверяет, определен ли макросс, который справа написан.
[01:35:28.420 --> 01:35:30.420]  А он не со скобками работает?
[01:35:30.420 --> 01:35:35.420]  Нет, это префиксный оператор, как и Сайзов.
[01:35:35.420 --> 01:35:41.420]  Да, ну обычно пишут Defined и в скобках что-то, но на самом деле он префиксный, без скобок работает.
[01:35:41.420 --> 01:35:42.420]  Проверяет на что?
[01:35:42.420 --> 01:35:44.420]  Ну, объявлен ли такой макросс?
[01:35:44.420 --> 01:35:46.420]  Был ли Defined для него?
[01:35:46.420 --> 01:35:48.420]  А есть же IfDef и IfOnDef?
[01:35:48.420 --> 01:35:50.420]  Ну да, есть отдельно Defined.
[01:35:50.420 --> 01:35:54.420]  IfDef это аббревиатура для...
[01:35:59.420 --> 01:36:01.420]  IfDefined...
[01:36:03.420 --> 01:36:06.420]  Какой прикольный макросс у нас есть? Scan.
[01:36:09.420 --> 01:36:13.420]  Вот это полный спеллинг IfDef.
[01:36:13.420 --> 01:36:15.420]  Чем он круче?
[01:36:17.420 --> 01:36:19.420]  Можно вот так делать.
[01:36:20.420 --> 01:36:22.420]  То есть здесь вообще произвольные болевые выражения.
[01:36:22.420 --> 01:36:24.420]  Можно писать и при процессорах вам их вычислят.
[01:36:24.420 --> 01:36:27.420]  Это что? А какие ограничения?
[01:36:27.420 --> 01:36:29.420]  Какие ограничения? Ну, арифметика...
[01:36:29.420 --> 01:36:31.420]  Арифметика...
[01:36:31.420 --> 01:36:32.420]  Отсутствует скорее всего.
[01:36:32.420 --> 01:36:33.420]  Присутствует.
[01:36:33.420 --> 01:36:34.420]  Что, не может?
[01:36:34.420 --> 01:36:35.420]  Да.
[01:36:37.420 --> 01:36:41.420]  Можно писать if 1, 2, plus 2.
[01:36:41.420 --> 01:36:43.420]  По-моему, так работает.
[01:36:43.420 --> 01:36:46.420]  Вот она просто вырезала нам I, T, I, S, D, F.
[01:36:46.420 --> 01:36:49.420]  А если бы я был писать, то будет ошибка к белярцам.
[01:36:55.420 --> 01:36:57.420]  Она умеет делать арифметику.
[01:36:57.420 --> 01:36:58.420]  Она умеет с булями работать.
[01:36:58.420 --> 01:37:00.420]  Она что угодно умеет.
[01:37:00.420 --> 01:37:03.420]  Важная такая штука, но и вот тут обычный HasInclude.
[01:37:03.420 --> 01:37:04.420]  А если бы в этот раз была белярция?
[01:37:04.420 --> 01:37:07.420]  Белярция, да.
[01:37:07.420 --> 01:37:12.420]  он очень угодно умеет. Важная такая штука. Ну и вот тут обычный hasInclude.
[01:37:12.420 --> 01:37:25.420]  Вот такой, например. Вот ялстрим у нас есть. Вот такие штуки встроенные есть. Иногда они
[01:37:25.420 --> 01:37:31.420]  полезны. Иногда вы их просто на работе встретите. Ну, не иногда, часто. Всякие hasInclude и defined
[01:37:31.420 --> 01:37:48.420]  это очень частая штука. Поехали дальше. О, пришло время жести. Ну вот есть тут такой прикол.
[01:37:48.420 --> 01:37:57.020]  Ради чего я это все показываю? Ради вот этого трюка. Ну давайте как-то сначала. Вот loop
[01:37:57.020 --> 01:38:04.420]  это какой-то macros. Он объявлен как x. Какой-то loop indirection. Какие-то там костыли. Но в конце еще
[01:38:04.420 --> 01:38:11.020]  раз от x запускается. Да, вот что такое loop indirection empty? Двое скобок. Но loop indirection
[01:38:11.020 --> 01:38:17.900]  это просто loop. То есть если empty закрыть, то будет просто loop indirection заново запущенный,
[01:38:17.900 --> 01:38:24.340]  который заново сделает loop. Вот те круглые скобки x заново этот loop запустят. И мы как бы пойдем
[01:38:24.340 --> 01:38:30.980]  рекурсивно, да? Но вот как бы понятно, что мы никуда рекурсивно не пойдем на самом деле. Потому
[01:38:30.980 --> 01:38:36.940]  что будут disabling контексты и будут всякие синие краски. И вот трюк заключается вот в этом empty.
[01:38:36.940 --> 01:38:45.420]  Он откладывает вот defer про это. Он откладывает раскрытие вот этого loop indirection на следующий
[01:38:45.420 --> 01:38:54.420]  скан. Тем самым выкидывая все синие краски и disabling контексты. То есть если мы так напишем,
[01:38:54.420 --> 01:39:01.020]  то у нас раскроется вот так. 1 loop indirection. Если мы скан напишем loop 1 и тиры-пыры,
[01:39:01.020 --> 01:39:10.500]  у нас два раза рекурсия пройдет. И две единички допишется. Ну и можно сделать eval много, сделать много
[01:39:10.500 --> 01:39:21.060]  единичек. Вот эту рекурсию ровно на n шагов. Как это отпилить? Вас это так интересует. Вы
[01:39:21.060 --> 01:39:42.820]  действительно хотите это посмотреть? Это можно. Ну где он? Вот он. Ну давайте смотреть. Значит смотрим.
[01:39:42.820 --> 01:39:48.940]  Вообще это и дальше и сам расскажу. Вот у них ровно такой eval defer как у нас. Может отсюда
[01:39:48.940 --> 01:39:57.580]  взято. Тут начинаются трюки. Да, трюк состоит тут в этом чеке. Хотим мы его сейчас разобрать или,
[01:39:57.580 --> 01:40:04.820]  ну наверное давайте сейчас, потому что дальше все равно я про него скажу. Что здесь происходит? Вот
[01:40:04.820 --> 01:40:13.060]  этот самый наш loop, который был. Он просто делает f от x, ну применяет к первому аргументу f. Дальше
[01:40:13.060 --> 01:40:21.060]  делает loop indirection. Да, а что мы в итоге хотим сделать? Мы хотим f применить к списку элементов и
[01:40:21.060 --> 01:40:32.900]  закончится и получить вот это вот. Цикл такой сделали. По теплу. Я напоминаю, что через запятую
[01:40:32.900 --> 01:40:40.860]  написанные штуки называются теплами. И вот мы тут сделали цикл по теплу. Loop 0 делает то, что мы уже
[01:40:40.860 --> 01:40:49.060]  видели. Ну тут он как бы отщипывает первый x, а все остальные x хвосту рекурсии передает. Но при этом
[01:40:49.060 --> 01:40:53.780]  вот запуск этой рекурсии отложен до следующего рескана через вот этот вот empty, который просто
[01:40:53.780 --> 01:41:00.700]  пустой define. А loop 1 в свою очередь, ну это пустая фигня. Соответственно нам надо сделать так,
[01:41:00.700 --> 01:41:08.780]  чтобы у нас куча раз ресканился loop 0, а потом в какой-то момент стал loop 1 и он уже вот бы
[01:41:08.780 --> 01:41:15.100]  стер вот эти вот лишние штуки в конце. Как это делается? Ну опять, по названиям можно догадаться,
[01:41:15.100 --> 01:41:20.460]  что сейчас будет трюк с конкатенцией. Вот есть loop 0, есть loop 1. Мы хотим что-то поконкатенировать
[01:41:20.460 --> 01:41:32.060]  и понять, что у нас получится. Плюс-минус. Смотреть теперь надо сюда. Чек чего-то там и просто запуск
[01:41:32.060 --> 01:41:37.940]  того, что получилось в результате. Что этот человек может в итоге выдать после сканирования?
[01:41:37.940 --> 01:41:45.700]  Либо он loop 0 выдадет, ну как-то, идейно должен, либо он должен выдать некоторые loop end-end,
[01:41:45.700 --> 01:41:51.660]  которые раскроются в loop 1. То есть вот задача. Сделать так, чтобы здесь был либо loop 0, либо loop
[01:41:51.660 --> 01:41:58.540]  1. Потом мы пошли ну сюда, потом loop indirection раскрыли в loop и заново пошли проверять,
[01:41:58.540 --> 01:42:03.500]  дошли ли мы до конца или нет. И так далее, и так далее. То есть нас интересует чисто вот этот
[01:42:03.500 --> 01:42:10.540]  чек, как понять, дошли ли мы до конца или нет. Здесь можно было из empty заюзать на warx, но вот
[01:42:10.540 --> 01:42:18.620]  автор кода сделал не так. Он заюзал вот такой token end. Ну вот token end просто берется и лепится к,
[01:42:18.620 --> 01:42:26.660]  вернее не так. Текущий элемент, который мы обрабатываем тупо лепится к loop end. Для большинства
[01:42:26.660 --> 01:42:34.940]  элементов это будет loop end 0, loop end 1, loop end 2, и это ни во что не раскроется. А дальше это все пихается
[01:42:34.940 --> 01:42:45.540]  в чек. Чек возвращает первый элемент тепла. Причем тепла странного. То есть нам передали x
[01:42:45.540 --> 01:42:55.900]  еще что-то, мы это что-то в начало ставим, а x в конец. Вот такой прикол странный. Но tuple-end-1 при
[01:42:55.900 --> 01:43:05.700]  этом это типа первый, в смысле с нулевой индексацией. Да, ну вот так странно тут написано. Да, из empty мне
[01:43:05.700 --> 01:43:12.820]  кажется понятнее, чем вот это вот написано. Но суть здесь абсолютно одинаковая. Если loop end, сюда
[01:43:12.820 --> 01:43:21.660]  пришел x end, и вот эта хрень получилась loop end end, она раскрылась, запятая loop 1, то при
[01:43:21.660 --> 01:43:31.860]  подстановке сюда у нас здесь будет три аргумента, как бы в кавычках. Loop 0, вот эта запятая, еще одна
[01:43:31.860 --> 01:43:40.020]  запятая, и loop 1. И тогда вот эта шняга loop 0 поставит в конец, а здесь останутся две запяты,
[01:43:40.020 --> 01:43:47.740]  одна запятая и один. Вот так вот. Одна запятая и один, и тогда первый элемент это будет loop 1.
[01:43:47.740 --> 01:43:53.860]  То есть если мы дошли до end, то вот эта вся шняга раскрывается в loop 1, иначе раскрывается в loop 0.
[01:43:53.860 --> 01:44:10.700]  Зря. Зря. Ну короче, тут всегда трюки примерно одинаковые делаются. Ты делаешь вот такой check,
[01:44:10.700 --> 01:44:18.620]  который аналогичен из empty, а свою рекурсию как-то еще разбиваешь при помощи какого-то
[01:44:18.620 --> 01:44:24.660]  промежуточного макроса, который там либо действительно продолжает, либо идет и это,
[01:44:24.660 --> 01:44:31.860]  либо останавливается, не оставляя за собой вот этого всего мусора.
[01:44:31.860 --> 01:44:50.980]  Хороший вопрос. Наверное, сейчас я не могу на него ответить. Ну тут такие магии происходят,
[01:44:50.980 --> 01:44:58.660]  все можно. Весь мир в труху, но потом. Ну и не сегодня вообще, самостоятельно. Вот айсберг,
[01:44:58.660 --> 01:45:03.940]  вы главное что запомните, это что есть вот айсберг макросов C++, вот заходите туда,
[01:45:03.940 --> 01:45:10.220]  и там по всем ссылкам, там еще больше, чем я тут рассказываю. Так, в общем, можно подавление,
[01:45:10.220 --> 01:45:17.300]  да, вот. Дефер — это подавление запуска рекурсии на следующий рескан, а Ивал — это форсирование
[01:45:17.300 --> 01:45:24.140]  вот этого подавленного запуска рекурсии. Вот такая техника. Постоянно используются всякие
[01:45:24.140 --> 01:45:30.620]  перепроцессоры буста на этом основу. Ой, теплы. Мы уже видели, ну просто скажу, что вот такие
[01:45:30.620 --> 01:45:36.140]  штуки через запятые — это теплы. И с ними можно работать, ну примерно как типа с чем-то в хаскеле,
[01:45:36.140 --> 01:45:40.500]  что ли. Потому что просто в начале дописываете название функции, достающий элемент, и вы как бы
[01:45:40.500 --> 01:45:45.540]  вот достали из теплый элемент. Просто вот такая последовательность токенов считается теплом.
[01:45:45.540 --> 01:45:53.420]  Вот. Ну и их там можно как нервыть, если очень там извернувся, наверное, всякие другие штуки
[01:45:53.420 --> 01:45:59.700]  делать. Мы этим заниматься не будем. Мы вместо этого еще накинем сущность такую, типа контейнер
[01:45:59.700 --> 01:46:06.780]  времени при процессинга. Контейнер называется «листы». Наша любимая. Head и tail. Вот эти,
[01:46:06.780 --> 01:46:12.380]  это tuple, да, из двух элементов пара. Только есть пара из двух элементов, у нас с автоматом есть
[01:46:12.380 --> 01:46:19.500]  листы. Head — это первый элемент, tail — это второй. Вот какие-то листы тут написаны. Прикольно?
[01:46:19.500 --> 01:46:27.820]  Прикольно. Ну, еще надо, конечно, научиться проверять, что мы в конце листа. Опять,
[01:46:27.820 --> 01:46:33.540]  чтобы вот эти рекурсии прерывать и тыры-пыры. Ну, тут примерчик точно такой же, как мы только что
[01:46:33.540 --> 01:46:53.500]  видели с чеком. Что тут происходит? X дописывается к лист-энду. Видите? То есть там какой был трюк.
[01:46:53.500 --> 01:47:00.060]  Мы к... что-то там, что-то там добавляли двумя решетками токен. Если он был end, то у нас
[01:47:00.060 --> 01:47:06.820]  слопалось. Здесь вместо этого мы после лист-энда пишем справа X. А дальше зададемся вопросом,
[01:47:06.820 --> 01:47:12.620]  а что это будет, когда X подставится? Либо это будет вызов макроса, который принимает
[01:47:12.620 --> 01:47:20.580]  что угодно, вот этого лист-энда, либо это ничего не будет. Ну и, соответственно, что такое хвост у
[01:47:20.580 --> 01:47:30.340]  такого списка из одного элемента? Это пустая последовательность токенов. Соответственно,
[01:47:30.340 --> 01:47:35.820]  если х это была пустая последовательность токенов, то ничего не произойдет. А любой не пустой список,
[01:47:35.820 --> 01:47:43.180]  это как минимум круглые скобки. И когда мы их допишем к лист-энду, это будет инвокация вот
[01:47:43.180 --> 01:47:48.980]  этого макроса функционального, и у нас раскроется в запятая ноль. Ну и опять старые фокусы. Берем
[01:47:48.980 --> 01:47:54.140]  второй элемент теплее, вот если запятая лишнее вписалось, то там он меняется, и вот мы научились
[01:47:54.140 --> 01:48:00.460]  проверять. Вот, еще пример вот этой техники. Есть вопросы по этому?
[01:48:00.460 --> 01:48:18.900]  Что? Ну тут никогда не будет лист-энда с пустыми скобками. Ну, тоже запятая ноль.
[01:48:18.900 --> 01:48:33.140]  Вот этот вот. Да, тоже запятая ноль. А лист-из-энд. Ну, выдаст true. А нет,
[01:48:33.140 --> 01:48:37.780]  это не будет запускаться даже. Здесь же не врядик, здесь токен нужен.
[01:48:37.780 --> 01:48:50.500]  Это не является корректным списком, вот ответ. Эта штука работает корректно только на корректных
[01:48:50.500 --> 01:48:59.020]  списках. Корректный список это либо голова запятая хвост в скобках написанная, либо пустая последовательность
[01:48:59.020 --> 01:49:02.340]  токена, в которую здесь можно получить только как хвост для вот этого.
[01:49:02.340 --> 01:49:17.980]  А в этом смысл. Не чувствуешь, да? Вот tuple это разделенные запятыми последовательность в скобках.
[01:49:17.980 --> 01:49:24.060]  Почему она в скобках? Чтобы можно было запускать макросы и функции на этом тюпле, тупо дописывая
[01:49:24.060 --> 01:49:32.060]  слева название этого макроса. Мы тупо дописали. Вот эта вот вся последовательность это tuple. Все,
[01:49:32.100 --> 01:49:38.420]  что в скобках, грубо говоря. Мы тупо дописали слева название и запустились. То же самое тут.
[01:49:38.420 --> 01:49:44.820]  Мы хотим тупо дописать к листу. Вот есть лист. X это лист. Мы тупо к нему дописали слева название
[01:49:44.820 --> 01:49:52.580]  макроса и запустились от этого листа. Тут другое соглашение о том, как оно работает.
[01:49:52.580 --> 01:49:58.980]  Ну можно было сделать так, можно было сяк. Ну вот так получилось. Другого ответа нет.
[01:49:58.980 --> 01:50:05.620]  Ну идея, надеюсь, понятна. Я просто крикаю, пустой лист как записывается?
[01:50:05.620 --> 01:50:12.380]  Пустой лист никак не записывается. Нельзя записать. Вот лист tail 9 и пустое. Ну вот так только.
[01:50:12.380 --> 01:50:22.700]  По-моему нету такого способа пустую последовательность. Ну короче, никак. Да, никак не записывается.
[01:50:22.700 --> 01:50:33.220]  Окей. Ну это еще не последний контейнер времени, компиляция. Ну вот про листы времени при
[01:50:33.220 --> 01:50:38.420]  процессинге. Да, про листы я тут не особо много чего написал, но с ними тоже всякие операции
[01:50:38.420 --> 01:50:42.860]  можно делать. С теплами не только эти можно, и с листами тоже не только эти. Если постараться,
[01:50:42.860 --> 01:50:48.860]  там можно очень-очень разные штуки делать, но каждый алгоритм на вот таких вот структурах,
[01:50:48.860 --> 01:50:52.860]  это нужно сидеть и минут 30 втупливать, чтобы понять, что происходит, и потом
[01:50:53.300 --> 01:51:00.180]  я понял, но у нас нету столько времени. О, я забыл, да, потому что это невозможно просто.
[01:51:00.180 --> 01:51:11.260]  Домашнее задание на отл 20. Ну вот последний контейнер, давайте уже дотянем, это гайды.
[01:51:11.260 --> 01:51:21.060]  Гайды. Знакомьтесь, вот эта маленькая шняга, это гайд. То есть это последовательность чего-то,
[01:51:21.060 --> 01:51:28.900]  разделенное скобочками, улыбочками. Вы понимаете, что мы собрались делать, да? Вот как бы теплые листы
[01:51:28.900 --> 01:51:35.980]  были так сделаны, чтобы можно было слева дописать имя и запуститься. Ну вот как бы теплый, это всегда
[01:51:35.980 --> 01:51:41.300]  уже со скобками, значит просто слева дописываем название макросса и запускаемся. Гайды сделаны
[01:51:41.300 --> 01:51:48.700]  так, чтобы слева надо было дописать название макросса, открывающую скобку, и все, оно дальше запустится.
[01:51:48.700 --> 01:51:56.100]  Если вот к этой гайде, если к нему слева дописать там фу и открывающую круглую скобку, то мы запустимся
[01:51:56.100 --> 01:52:03.100]  в первого элемента гайда. Ну и давайте как бы перед тем, как перейти к вот этой вот жесте,
[01:52:03.100 --> 01:52:07.740]  которая будет на следующем слайде, посмотрим, как нам последовательность, я помню, у нас был
[01:52:07.740 --> 01:52:15.700]  sequence, вот этот вот, это sequence был, как его конвертировать в гайд в качестве такого упражнения работы над
[01:52:15.700 --> 01:52:25.380]  sequence и чтобы не оставалось сзади хвоста, да, вот к этому же. Что тут происходит? Нас интересует
[01:52:25.380 --> 01:52:33.580]  to-guide, to-guide берет sequence, ну вернее берет, ну да, берет прям весь sequence и пихает в некоторую
[01:52:33.580 --> 01:52:40.980]  рекруссивную шнягу. Sec term, ну это рискан по сути, что там еще за RM, вообще неважно,
[01:52:40.980 --> 01:52:49.740]  а to-guide-a применяется к секу, да, к секунсам функции, так же как к спискам или к тюплам,
[01:52:49.740 --> 01:52:58.740]  применяется дописыванием слева. To-guide-a что делает? Берет и все, что в первых круглых скобках этого
[01:52:58.740 --> 01:53:07.700]  секунса просто имитит, пишет, да, правую закрывающую скобку пишет, ну через macros,
[01:53:07.700 --> 01:53:13.780]  чтобы оно отложено происходило на самом последнем рискане, тут в это надо поверить, просто что вот так
[01:53:13.780 --> 01:53:19.980]  работает, если сразу написать круглую скобку, то не работает. Потом empty, чтобы еще вот этот вот rparen
[01:53:19.980 --> 01:53:25.100]  отложить совсем на давний, на поздний рискан, да, если бы не хватило вот этого empty, можно было бы
[01:53:25.100 --> 01:53:30.540]  еще один empty написать, и тогда бы мы там на три рискана отложили подстановку скобок, чтобы в
[01:53:30.540 --> 01:53:38.580]  самом последнем моменте, и дальше идет to-guide-b, но так как мы как бы вот это вот to-guide-a заменяем на всю
[01:53:38.580 --> 01:53:46.740]  вот эту шнягу, то мы как бы, да, откусили первый элемент, когда запустили вот это вот все, заменили
[01:53:46.740 --> 01:53:53.460]  его на один закрывающую скобку, а дальше написали to-guide-b, и он применяется к секу, ну и дальше мы как бы
[01:53:53.460 --> 01:53:59.340]  идем, идем, идем, идем, применяемся, применяемся, применяемся, и в какой-то момент дойдем до вот
[01:53:59.340 --> 01:54:06.380]  этой вот оставшейся скобочки, которая нас волновала, ну, до чего оставшегося, to-guide-a останется
[01:54:06.380 --> 01:54:13.620]  какой-нибудь, да, когда вот этот вот sequence весь исчерпается, останется to-guide-a, был вопрос, как от него
[01:54:13.620 --> 01:54:22.860]  избавиться, вот здесь ответ, вот эта вся шняга завернута вот в этот вот сектер, который конкатенирует
[01:54:22.860 --> 01:54:31.980]  воаркс с нижнее подчеркивание рм, что это значит? Это значит конкатенируем вот это, to-guide-a, последний
[01:54:31.980 --> 01:54:37.420]  токен из этого воаркса, да, потому что вот это вот все, to-guide-a сек, он же развернется в куче кучи
[01:54:37.420 --> 01:54:46.340]  токенов, и в конце будет какая-то to-guide-a, наверное, да, вот последний токен воаркса, он будет
[01:54:46.340 --> 01:54:51.820]  сконкатенирован с рм, ну, потому что воарксы раньше вот этих двух решеток, оказывается, раскрываются,
[01:54:51.820 --> 01:54:56.340]  соответственно, это распарсятся как кучу кучу токенов, потом последний токен, вот же он,
[01:54:56.340 --> 01:55:04.020]  to-guide-a, конкатенируем с рм, получили to-guide-a рм, который задефайнен на пустую эту, вот мы
[01:55:04.020 --> 01:55:16.140]  избавились от последнего элемента в рекурсии на секунсах. Это похоже на лютую жесть, но тем не
[01:55:16.140 --> 01:55:23.100]  менее, мы конвертировали вот такую последовательность с открывающими скобками в секунс, в последовательность
[01:55:23.100 --> 01:55:42.580]  только с закрывающими скобками. Вы помните, как работает прохождение по такому секунсу?
[01:55:42.580 --> 01:55:51.660]  Как бы define-a от чего-то b, define-b от чего-то a, они так сжирают, сжирают, сжирают,
[01:55:51.660 --> 01:55:58.980]  имите перед собой то, что было, и в конце концов, вот этот вот a или b, оно как бы до конца доехало,
[01:55:58.980 --> 01:56:06.820]  осталось последним. В самом начале про это говорили, отсылочка. Так, два человека, кажется,
[01:56:06.820 --> 01:56:18.300]  поняли, возможно, три или четыре, ну вот такая шняга. Окей, а нафига нам гайды нужны? По ним можно
[01:56:18.300 --> 01:56:31.380]  делать fold, накапливать контекст по дороге с этим сворачиванием всем. Надо морально собраться,
[01:56:31.380 --> 01:56:39.860]  да? Это вот последний рывок. А нет, подождите, у меня еще полчаса. Вообще нормально. Ну сейчас,
[01:56:39.860 --> 01:56:49.580]  сейчас тогда все успеем, получается. Вот куча кода. Знакомые нам tuple.at1 и checking. Мы уже запомнили
[01:56:49.580 --> 01:56:56.900]  примерно, как этот алгоритм работает. Ну читать, наверное, надо с конца. Я хочу написать конкатенацию
[01:56:56.900 --> 01:57:02.260]  последовательности. Через последовательности это особо не пишется. Непонятно, как какой-то контекст
[01:57:02.260 --> 01:57:08.380]  протаскивать, что там накапливать. Не получится. А по сути, что надо сделать? Пройтись по этой
[01:57:08.380 --> 01:57:15.660]  последовательности и накапливать уже сконкатенированные префиксы. Просто так это не
[01:57:15.660 --> 01:57:27.740]  получается. Поэтому cat.seq определен как cat.guide, tu.guide от sec от end. Зачем здесь end? Ну пока непонятно,
[01:57:27.740 --> 01:57:33.580]  да и неважно. Но главная идея, что мы будем по гайду идти, а потом... Это теперь последний элемент
[01:57:33.580 --> 01:57:42.060]  последовательности. Окей, да. То есть sec от end, это мы как бы к sec дописали еще один, вот к этому,
[01:57:42.060 --> 01:57:51.540]  еще один элемент, end. И вот tu.guide он... Ну зачем-то ему нужно, короче. Вот tu.guide он с этим справится,
[01:57:51.540 --> 01:57:56.980]  и cat.guide уже сможет сконкатенировать. Окей, tu.guide мы видели, поверили, что вот эта вся
[01:57:56.980 --> 01:58:02.460]  последовательность превратилась в правильный гайд. Ну вот такой вот, да. Но в конце еще end
[01:58:02.460 --> 01:58:17.140]  написан. И теперь начинается интересное cat.guide. Где он? Я потерял. Вот он. Да, мы опять имеем пару cat.guide
[01:58:17.140 --> 01:58:23.660]  A, cat.guide B, будем их чередовать. Но cat.guide A уже запускается каким-то вообще невероятным образом.
[01:58:23.660 --> 01:58:31.900]  Он запускается открывающая скобка запятая и гайд. Да? Что произойдет? Ну вот cat.guide A и cat.guide B они
[01:58:31.940 --> 01:58:42.460]  принимают внутрь контекст и один элемент гайда. Один элемент. Тут пустой контекст, и первый элемент
[01:58:42.460 --> 01:58:48.060]  гайда это будет, ну вот эта единичка, потому что гайд состоит из один закрывающая скобка, и это будет
[01:58:48.060 --> 01:58:58.940]  вполне себе легальная инвокация вот этого макрос, cat.guide A от контекста пустого единички. Ну и понятно,
[01:58:58.940 --> 01:59:05.660]  что дальше мы собираемся cat.guide A сделать так, чтобы он раскрылся в примерно такую же конструкцию,
[01:59:05.660 --> 01:59:12.260]  только здесь B должно быть. Будет cat.guide B, открывающая скобка запятая, и остаток гайда,
[01:59:12.260 --> 01:59:18.300]  он как бы снаружи от всего этого. То есть вся вот эта вот чехарда, с которой мы будем разбирать,
[01:59:18.300 --> 01:59:25.100]  с cat.guide A к cat.guide B, она происходит со всем, что до второго элемента. То есть только вот эта
[01:59:25.100 --> 01:59:30.300]  закрывающая скобочка и единичка. Все остальное остается нетронутым. И когда вот этот cat.guide A
[01:59:30.300 --> 01:59:36.620]  полностью отработает, он сюда допишет cat.guide B, но он уже схавал вот эту один закрывающую скобку.
[01:59:36.620 --> 01:59:44.700]  И мы, ну когда cat.guide B будем раскрывать, мы будем использовать уже двойку и закрывающую скобку.
[01:59:44.700 --> 01:59:50.300]  Потом опять cat.guide A получится и три закрывающие скобки. И вот так пойдем сжирать-жирать эти циферки
[01:59:50.300 --> 01:59:58.460]  и закрывающие скобки. Контекст? Да, сейчас увидим. Ну во-первых, что здесь происходит? Тут опять
[01:59:58.460 --> 02:00:04.700]  какие-то чеки лютые. Чек проверяет, пришел ли нам вот этот end. Мы уже там представим,
[02:00:04.700 --> 02:00:09.140]  что мы понимаем, как этот чек работает. Кажется, это действительно правда. Вот x пришел,
[02:00:09.140 --> 02:00:17.580]  мы присоединяем. И того, что? Зачем нам этот чек? Чтобы если получилось, что мы в конце,
[02:00:17.580 --> 02:00:25.980]  то мы сюда бы вписали cat.guide end и в общем мы выбираем, куда пойти. Это if при процессоре,
[02:00:25.980 --> 02:00:32.780]  да, по сути. Либо в cat.guide next идем, если еще не конец, либо в end. В next что мы делаем?
[02:00:32.780 --> 02:00:39.580]  Мы прокидываем, во-первых, контексты x, а в третьих, что дальше запустить? A говорит дальше запустить B,
[02:00:39.580 --> 02:00:47.820]  B говорит дальше запустить A в самом вот там конце. И cat.guide next просто берет cat.guide,
[02:00:47.820 --> 02:00:55.140]  прилепленное next, контекст и к нему элемент прилеплен. То есть весь алгоритм конкатенации
[02:00:55.140 --> 02:01:01.140]  он на самом деле вот в этой строчке содержится. cat.guide next. Все остальное это инфраструктура,
[02:01:01.140 --> 02:01:09.700]  чтобы дойти до конца, а потом в конце мусора не оставить и вот это вот все. Вот, ну и вот
[02:01:09.700 --> 02:01:17.260]  она главная идея, что когда у вас вот эта шняга раскроется с первым элементом гайда, у вас останется
[02:01:17.260 --> 02:01:26.220]  cat.guide B с контекстом, к которому приконкатенирован первый элемент, накоплен, да, как бы вот фолт он
[02:01:26.220 --> 02:01:32.260]  вот ровно здесь происходит. И запятая. А дальше уже второй элемент гайда остался. Вот он идет там,
[02:01:32.260 --> 02:01:39.540]  ну есть. Ну и нужно дальше идти сканировать, и оно будет раскрывать, раскрывать, раскрывать. И в итоге
[02:01:39.540 --> 02:01:45.180]  вот в этом контексте постепенно каждый элемент гайда будет к нему приконкатенирован. И, соответственно,
[02:01:45.180 --> 02:01:50.860]  в самом конце в cat.guide end мы выйдем от контекста, будет 1, 2, 3, 4, 5.
[02:01:50.860 --> 02:02:06.900]  Ну, видимо. Ну, на секунсах непонятно, как контекст где накапливать. Если просто в аргументы,
[02:02:06.900 --> 02:02:21.820]  то оно получится, что да. Нет, если слева мы пишем, то мы ничего не рисканим. Ну, когда мы просто
[02:02:21.820 --> 02:02:28.420]  слева дописываем это, то тут без рисканов можно обойтись. То есть Ewaldifer, которые позволяют
[02:02:28.420 --> 02:02:35.460]  рисканить много раз, тут не нужны. Просто мы как бы слева пишем, вот да, когда проходимся по секунсу,
[02:02:35.460 --> 02:02:43.820]  мы слева дописываем то, что там осталось. А контекст куда пихать? Ну, непонятно. Мы как бы к тому,
[02:02:43.820 --> 02:02:50.380]  что уже было раньше, не вернемся, когда по секунсу идем. Потому что мы свою рекурсивную инвокацию,
[02:02:50.380 --> 02:02:57.340]  мы ее пишем после ответа. Вот мы обработали что-то, элемент, выдали ответ, и после него пишем
[02:02:57.340 --> 02:03:07.260]  следующий вызов, то Гайд Б. Да, вот это легко трансформировать, то есть мап делать,
[02:03:07.260 --> 02:03:15.980]  поэтому. А вот это легко фолдить Гайды. Вот мы Гайды сфолдили. Поднимите руку, кто понял,
[02:03:15.980 --> 02:03:24.540]  как фолдить Гайды. Ну так, плюс-минус, да? Ну нормально, нормально. Лотыш, конечно,
[02:03:24.540 --> 02:03:36.060]  таким не заниматься, да. Особенно на публику. Ну, жертвую собой. Да нет, ну лучше дома запереться,
[02:03:36.060 --> 02:03:44.340]  в ванной, чтобы никто не видел таким заниматься, стыдно же. Кто-то хочет переспросить и попытаться
[02:03:44.340 --> 02:03:56.220]  все-таки доразобраться, как работает этот фолд по Гайду. Как он работает, понятно. Все, все ясно. Все,
[02:03:56.220 --> 02:04:09.700]  совсем все. С теплами так непонятно. Ну, ни с теплами, ни с секунсами, ни с листами непонятно,
[02:04:09.700 --> 02:04:15.460]  как накапливать какой-то контекст, идя по дороге. Потому что, когда ты секунс, проходишься по нему,
[02:04:15.460 --> 02:04:21.300]  да, ты какой-то результат обработки одного элемента, ты его пишешь слева от рекурсивного
[02:04:21.300 --> 02:04:29.220]  запуска. Вот слева ты написал ответ, вот он. А рекурсивный запуск у тебя дальше, правее. Это
[02:04:29.220 --> 02:04:35.180]  кардинально отличается от Гайдов, потому что с Гайдами ты следующий запуск пишешь левее, чем
[02:04:35.180 --> 02:04:50.900]  свой ответ. Вот твой ответ, а запуск он как бы слева. Понимаешь? В тюплах, нет, в секунсах. В тюплах,
[02:04:50.900 --> 02:04:57.940]  и вообще не знаю как, а вот тут, если попробовать, может получиться, но вот, я говорю, это невозможно
[02:04:57.940 --> 02:05:03.980]  в голове представлять никогда. У тебя сто процентов будут проблемы с окраской, с рисканами и вот этим
[02:05:03.980 --> 02:05:11.580]  всем. Ну вот, скорее всего, можно. Если ты готов Эвал Дефер использовать вот этот вот рискан запускать
[02:05:11.580 --> 02:05:19.820]  300 тысяч раз, то, конечно, все можно. Но если ты не готов, то как бы приходится вот так извращаться.
[02:05:19.820 --> 02:05:27.940]  То есть, да, формально тут можно протащить еще один аргумент и как-то его там делать. Ну вот,
[02:05:27.940 --> 02:05:31.540]  я говорю, в рисканы уткнешься. Вот Андрей изначально правильно сказал, получается.
[02:05:31.540 --> 02:05:40.940]  Можно спросить, почему этот улыбающийся хрень называется Гайд? Понятия не имею. Ну вот,
[02:05:40.940 --> 02:05:49.700]  тем не менее, такое есть. Кто-то это даже использует, наверное, в проде. Я за них боюсь. Вот. Давайте
[02:05:49.700 --> 02:05:56.620]  последний прикол, убойный. Андрей, ты же был на этой лекции в прошлом году или нет? Не особо что-то
[02:05:56.620 --> 02:06:02.540]  помнешней. Эта лекция не очень хорошо напоминается. Да? Ну ладно. Ну да. Каждый год как в новый,
[02:06:02.540 --> 02:06:13.340]  потому что это, конечно, все мда. Читаем сверху вниз. Читаем сверху вниз. Объявили слот. 2 умножить на 3
[02:06:13.340 --> 02:06:25.340]  плюс 1. Заинклюдили какой-то волшебный слот.с, магический. И у нас теперь в макросевал посчитан
[02:06:25.340 --> 02:06:34.260]  результат. Вот это вот выражение. Перемножили, прибавили. Вот он посчитан. Теперь undef-нули слот.
[02:06:34.260 --> 02:06:45.900]  Выкинули. И задефинили заново, как старый вал на минус 1. Слот заинклюдили. Декрементнулся. Вал
[02:06:45.900 --> 02:06:53.980]  превратился в вал минус 1. Еще раз заинклюдили, еще раз декремент произошел. Как это? Что это такое?
[02:06:53.980 --> 02:07:02.740]  Ну хорошо, undef-нули задефинили. И там вообще какие-то там ксоры, оры побитые, знак больше.
[02:07:02.740 --> 02:07:11.340]  Чего только не впихнули. Заинклюдили слот. Вычислилась. Как это работает? Почему это работает?
[02:07:11.340 --> 02:07:25.740]  Это вообще возможно. Но сейчас будет магия. Ну как ты напишешь, такие ограничения и будут. Давайте
[02:07:25.740 --> 02:07:37.620]  смотреть. Приоткроем завесу тайное. Мы задефиним все комбинации бит. По количеству бит, которые нам
[02:07:37.620 --> 02:07:44.340]  по факту нужны в наших числах. Ну тут как бы я, вот здесь немножко лукавлю, потому что там более
[02:07:44.340 --> 02:07:52.860]  сложный код. Вот здесь я как бы за три бита не выпрыгивал по факту в размере ответа. Ну вот мы
[02:07:52.860 --> 02:08:02.780]  задефиним. Если вам нужно 16 бит, ну делайте побольше их. Побольше строчек. Какие проблемы. Вот задефинили,
[02:08:02.780 --> 02:08:09.740]  а дальше задефиним вот такой вал ц. Прикольный. Ну он опять на два разбит, чтобы рискан был. Вал
[02:08:09.740 --> 02:08:19.260]  ц берет и квал нижнее подчеркивание дописывает а и б и ц. Тем самым вызвав вал ц от там последовательности
[02:08:19.260 --> 02:08:29.500]  нулей единиц, мы получим одно из вот этого всего. Так, а дальше вот этот слот точкой h, но он был
[02:08:29.500 --> 02:08:41.420]  c, теперь h, не важно. Дальше мы если у нас нет какого-то a0, инклюдим a, если есть, то инклюдим b. Зачем
[02:08:41.420 --> 02:08:48.220]  это? Ну чередоваться. На четных инклюдах слота мы будем инклюдить a, на нечетных инклюдах слота
[02:08:48.220 --> 02:08:58.540]  мы будем инклюдить b. Ну, я думаю, вы можете представить, да, как это. В секундах тоже самое было,
[02:08:58.540 --> 02:09:07.660]  да, мы чередовали a, b, а тут мы будем файл, который инклюдим, чередовать. Что? Пока непонятно. Сейчас
[02:09:07.660 --> 02:09:13.020]  увидим. Ну вот как факт, оно чередуется. И код там будет примерно одинаковый с точностью до симметрии.
[02:09:13.020 --> 02:09:20.780]  Какой код в a? Берем, что у нас в этом слоте написано, да, вот это выражение наше. И с помощью вот этого
[02:09:20.780 --> 02:09:27.700]  решетка if, помните, я говорил, что он все выражения умеет считать, да, и с помощью вот этого ifa любое
[02:09:27.700 --> 02:09:37.300]  выражение мы во время припроцессинга посчитаем, возьмем первый бит и объявим a0 в единицу, ну иначе в 0.
[02:09:37.300 --> 02:09:47.740]  Ну и дальше идем. Если второй бит выставлен, то а1 будет либо 1, либо 0, если там третий бит
[02:09:47.740 --> 02:09:53.660]  выставлен, и вот так, сколько надо, столько и напишите. Теперь через вот этот макрос вал c,
[02:09:53.660 --> 02:10:01.700]  который мы только что определяли, да, вот он вал c, задефиним вал как комбинацию всех вот этих
[02:10:01.700 --> 02:10:14.300]  вот штук и получим нужное нам число. Работает. Ну и вот тут какие-то b0, b1, b2, они дефинятся,
[02:10:14.300 --> 02:10:20.420]  но это на самом деле что такое? Это вот симметричные вот этим вот a0, a1, a2 в b-шке
[02:10:20.420 --> 02:10:27.780]  дефинятся b0, b1, b2. Ну и вот просто абсолютные симметрии, они чередуются и друг друга они
[02:10:27.780 --> 02:10:36.340]  дефинят. Вот. Теперь зачем такое чередование? Надо почувствовать, что когда мы дефиним слот как вал
[02:10:36.340 --> 02:10:45.100]  минус 1, нам нужно старый вал не побить как бы. Старый вал, он на самом деле является там каким-то
[02:10:45.100 --> 02:10:54.220]  вал a, чем таким или еще, ну не совсем, ну короче ладно, старый вал нужно не поломать и вот ровно
[02:10:54.220 --> 02:11:01.300]  чтобы вот такое вот использование вал внутри слота работало, нужно четное и нечетное. Вот. То есть
[02:11:01.300 --> 02:11:11.180]  это сохраняет старые там v-шки до момента, когда мы уже определили новые. Понять, почему это так
[02:11:11.180 --> 02:11:17.740]  работает и по-другому не работает, сложно да и не нужно, но почувствуйте силу, что мы типа научили
[02:11:17.740 --> 02:11:26.780]  препроцессор быть калькулятором. Но зачем? Но научили. Вот и на этом в целом.
[02:11:41.180 --> 02:11:48.620]  Ну потому что у тебя, если ты раздефинишь v-шки, то вот этот вал, он мог быть задефинен на не
[02:11:48.620 --> 02:11:55.700]  просканированное что-то. То есть вал-то у нас как определяется? Как вал c и вот это вот нужно
[02:11:55.700 --> 02:12:00.780]  рисканить. То есть когда ты просто пишешь вал, у тебя на самом деле не сразу подставляется число,
[02:12:00.780 --> 02:12:05.780]  у тебя подставляется вот это выражение, которое дальше продолжает сканироваться, еще сканироваться
[02:12:05.780 --> 02:12:12.620]  и только там через несколько раскрытий получаешь число. А в процессе этих раскрытий ты к чему
[02:12:12.620 --> 02:12:21.180]  придешь? К 2, 1, 0. И если ты уже старые а-шки раздефинишь вот здесь, то новые типа ну короче вот так.
[02:12:21.180 --> 02:12:35.740]  Ну ладно. Что? Что значит материализовать? А вычислить нет, потому что ну
[02:12:35.740 --> 02:12:40.980]  хорошо, ты можешь написать наверное 3 скана от вал и нет, все равно не получится.
[02:12:40.980 --> 02:12:51.580]  Ты же не можешь зафорсировать. Да, то есть ты когда дефинишь новые макросы, ты не можешь
[02:12:51.580 --> 02:12:58.980]  форсировать раскрытие чего-то старого. Поэтому приходится вот такие вещи делать. Все раскрытия
[02:12:58.980 --> 02:13:04.700]  все равно отложены на момент, когда твой макрос уже будет посчитан. Здесь никаких раскрытий не
[02:13:04.700 --> 02:13:09.380]  будет происходить, кроме как аргументов. Но аргументы тут тоже нам не очень подходят. Вот,
[02:13:09.380 --> 02:13:18.260]  ну вот такая шняга есть. Слоты. Память в припроцессинг тайме с калькулятором.
[02:13:18.260 --> 02:13:29.940]  Это было очень опасно. Мы уложились, поэтому мы можем посмотреть на бонус. Зачем я рассказывал про
[02:13:29.940 --> 02:13:44.100]  эти слоты? Ну, с ними можно наломать дров. Так, это все нам не нужно. Мы сейчас... ну, кстати,
[02:13:44.100 --> 02:14:01.420]  к вопросу гайдов, это вот здесь. Ну, давайте посмотрим. Ну, в общем, include date. Сейчас,
[02:14:01.420 --> 02:14:09.620]  так, история. Когда я вот это увидел, я тоже такой, что? И, в общем, мне понадобилось где-то час сидеть
[02:14:09.620 --> 02:14:16.260]  и вдуплять в эти там пару строчек, чтобы понять, что имеется в виду. И с тех пор я уже забыл. Ну,
[02:14:16.260 --> 02:14:23.180]  вот, кстати, chaos pp есть. Вот ровно слоты происходят. Вот наш... ну, pp — это припроцесс.
[02:14:23.180 --> 02:14:34.540]  Да, boost pp ket. Обычное название какого-то макроса из буста.
[02:14:34.540 --> 02:14:49.300]  Вот, ну, в общем, что-то тут происходит невероятное какое-то. Include chaos pp assigned slot file function
[02:14:49.300 --> 02:14:58.540]  table indexed as slot number 0. Хотим попробовать понять, что тут написано? Вот я боюсь,
[02:14:58.540 --> 02:15:09.780]  что опять долго понадобится думать. Ну, вот тут ссылка какая-то есть. Может,
[02:15:09.780 --> 02:15:25.540]  нам там еще сразу картинку покажут? Что? Так, я не понял, куда смотреть, чтобы смеяться.
[02:15:28.540 --> 02:15:49.060]  Ну, pp map dd. Ладно, тогда не надо. Да, короче, что они делают? Они в compile time умудряются
[02:15:49.060 --> 02:16:02.140]  выяснить, что лежит в таймедейте. А, распарсить таймедейт. Я забыл, честно. Вот я в прошлом году
[02:16:02.140 --> 02:16:15.500]  про это показывал, потому что это было прикольно, но сейчас мне уже стало так грустно. А, ну, вот они
[02:16:15.500 --> 02:16:31.060]  парсят типа дейты тайм на... О, полезно. Ну, типа если 2036 год или больше, то они компилируют.
[02:16:31.060 --> 02:16:53.980]  А, все, господа, я вспомнил. Короче, зачем это нужно и что это делает? Дея следующая и проблема
[02:16:53.980 --> 02:17:04.300]  следующая. Вот, вот идея. Вы создаете 3 мегабайта пустых файлов, у каждого из которых название
[02:17:04.300 --> 02:17:15.220]  соответствует какой-либо дате. Вот, а дальше include соответствующий файл через include date. Вот. Ну,
[02:17:15.220 --> 02:17:20.980]  то есть вот про что это. То есть это буквально include date и в зависимости от сегодняшней даты
[02:17:20.980 --> 02:17:38.740]  будет include разный файл. Чувствую сарказм, но... Да, вот как... Ну, это же жесть, ну просто жесть.
[02:17:38.740 --> 02:17:42.420]  Ну, давай все, закроем это, не будем дальше. Просто отвратительно.
[02:17:42.420 --> 02:17:58.740]  Я хотел показать прикольную штуку, но мы еще отвлекаемся. Прикольная штука, а где она была?
[02:17:58.740 --> 02:18:05.260]  Наверное, как раз в слотах. Вот, слоты нас интересуют. Ну, тут тот самый пример,
[02:18:05.740 --> 02:18:23.340]  откуда он сперт, вот ровно отсюда. Ну, где она? Видимо, вот внимание. Вот тут интересно. Вот,
[02:18:23.340 --> 02:18:34.740]  можно с помощью слотов сделать нечто невообразимое. И вот тут как бы некоторое... Да, рекурсивный
[02:18:34.740 --> 02:18:42.340]  include как бы. И мы... Вот как бы проблема в чем? Мы делаем слот, который value уменьшает. А дальше
[02:18:42.340 --> 02:18:48.340]  мы смотрим. Вот value оно не ноль. Если не ноль, то include себя. А мы что делаем? Мы define слот как
[02:18:48.340 --> 02:18:54.620]  value-1, вычисляем его. И если не ноль, то include себя. Ну, вот мы так по сути include себя столько
[02:18:54.620 --> 02:19:06.020]  раз, сколько надо, и дойдем от 7 до единицы, и вот как бы вот. Понятия не имею. Наверное,
[02:19:06.020 --> 02:19:13.500]  есть. Ну, любые вещи есть ограничения. То есть вот как бы изначально инициализация с семерочкой,
[02:19:13.500 --> 02:19:20.500]  вал вывели и дальше пошли рекурсивно include себя. Вот. То есть можно как бы в слотах хранить
[02:19:20.500 --> 02:19:27.660]  какие-то данные персистентные и даже это модифицированные данные. Ну, слот значения
[02:19:27.660 --> 02:19:35.380]  value можно менять. Это прям read, write, память. А дальше мы можем идти в рекурсии через вот include
[02:19:35.380 --> 02:19:43.020]  самого себя. И как бы в слотах можно закодировать состояние машины тюринга, а шаг машины тюринга
[02:19:43.020 --> 02:19:50.220]  сделать через вот эту рекурсию. Соответственно мы получаем такую хитренькую полноту по тюрингу.
[02:19:50.220 --> 02:19:56.420]  Мы можем выполнить любую программу полную по тюрингу с наперед заданным количеством
[02:19:56.420 --> 02:20:02.700]  итераций. Вот если ограничиться там десятью итерациями, то мы можем взять вот десять
[02:20:02.700 --> 02:20:09.060]  вписать за хардкодить программный код, и вот мы как бы в какой-то степени полны по тюрингу. Ну,
[02:20:09.060 --> 02:20:19.260]  и что это позволяет делать? Ну, вот тут есть примерчик жуткий. Вот. Define attrition file. Такой-то
[02:20:19.260 --> 02:20:28.220]  радиус берут. Какие-то константы. Начинают творить какие-то непотребства с каким-то языком
[02:20:28.220 --> 02:20:35.460]  вычислений в припроцессоре. То есть вот это совсем что-то убойное. Вот этот ордер pp,
[02:20:35.460 --> 02:20:42.700]  это там некоторое ответвление chaos pp, видимо, или какой-то бонус к нему. И вот этот ордер pp
[02:20:42.700 --> 02:20:48.420]  он интерпретирует некоторый простой язык, который с виду похож на lisp. То есть, ну, я вот сейчас не
[02:20:48.420 --> 02:20:53.820]  удивлюсь, если они типа интерпретатор lisp'а написали на макроссах. Ну, давайте выясним.
[02:20:53.820 --> 02:21:15.820]  Нет, ну, не знаю. Нету документации, да? Вот, doc есть.
[02:21:15.820 --> 02:21:29.380]  Ну, это прям какой-то интерпретируемый язык, с виду похожий на lisp. Наверное, не совсем lisp.
[02:21:29.380 --> 02:21:38.220]  Который интерпретируется в момент припроцессинга. И вот они на этом смешном языке написали
[02:21:38.220 --> 02:21:47.460]  какой-то небольшой типа скрипт, да? И типа что-то такое тут написано, но, по сути,
[02:21:47.460 --> 02:21:55.140]  здесь написано уравнение сферы окружности. Не знаю. Что-то происходит жуткое. Возможно,
[02:21:55.140 --> 02:21:58.980]  это объявление функции. Наверное, это объявление функции, это у нее аргументы,
[02:21:58.980 --> 02:22:13.980]  радиус x и y. А тут дальше даже принт какой-то. Ну, видимо, да. И, типа, вот,
[02:22:13.980 --> 02:22:24.020]  какой-то equation проверяют по чему-то. Видимо, это x и y. И печатают пробел. А, нет, стоп. Это символы
[02:22:24.020 --> 02:22:41.060]  просто. Да, кажется так. Типа, если у нас уравнение окружности, которая... Наверное,
[02:22:41.060 --> 02:22:50.100]  ниже. А, вот оно. Во-во-во. Вот, заодно, уравнение окружности, x в квадрате плюс y в квадрате меньше
[02:22:50.100 --> 02:22:57.420]  радиуса в квадрате. И если вот это уравнение верно, мы печатаем процент. Иначе там тильду и
[02:22:57.420 --> 02:23:04.660]  пробел и еще что-то такое. Ну вот, а потом начинаются какие-то абсолютные непотребства.
[02:23:04.660 --> 02:23:13.940]  Вот задаются какие-то параметры итерации. И дальше вот в этом скриптовом языке как раз
[02:23:13.940 --> 02:23:20.260]  какой-то forage делается. Вообще убойно. Ну и forage, как вы можете догадаться,
[02:23:20.260 --> 02:23:28.820]  он делается ровно через include самого себя с новыми значениями в слотах. Вот. И, типа,
[02:23:28.820 --> 02:23:38.420]  йота. О, прекрасно. Наш любимый yotaview только в припроцессоре. Вот как бы для каждого значения
[02:23:38.420 --> 02:23:46.900]  в радиусе, видимо. И для этого это, видимо, вложенные циклы. Ну, короче, по x и по y пробегаются
[02:23:46.900 --> 02:23:53.300]  в рамках квадрата по всем координатам. И, в общем, когда вы припроцессор запускаете на этом файле,
[02:23:53.300 --> 02:24:08.380]  вы получаете круг. Видите круг? Вот круг. Что? Ну да, если
[02:24:08.380 --> 02:24:12.380]  вы просто припроцессинг запустите на этом файле, вы получите вот такой круг. Ну, вы же видите круг?
[02:24:12.380 --> 02:24:22.700]  Я вижу. Вот. То есть просто на припроцессоре написали скрипт, который выдают круг. Вопрос,
[02:24:22.700 --> 02:24:36.620]  можно ли написать на этом raytracer простенький? Я думаю, что да. Ну вот. Если вам скучно и нечем
[02:24:36.620 --> 02:24:46.180]  заняться, напишите raymarsher на припроцессоре через вот это вот. Собственно, у меня на это все. Вот
[02:24:46.180 --> 02:25:10.980]  это самое убойное, что только можно представить. Да, процент двоеточий — это диграф, который
[02:25:10.980 --> 02:25:20.500]  превращается в решетку. Зачем? Не спрашивайте. Есть европейские клавиатуры на раскладке? Нет,
[02:25:20.500 --> 02:25:26.500]  это да. Зачем они изначально были нужны? Это понятно, но это, конечно, идиотская идея,
[02:25:26.500 --> 02:25:33.860]  абсолютно. Ну как бы поменять раскладку? Нет. Ну вот, их включили в язык. Вопрос в том, почему
[02:25:33.860 --> 02:25:40.500]  вот эти строчки с решеткой, а вот эти с диграфом? Это явно влияет. Это явно имеет прям какой-то
[02:25:40.500 --> 02:26:00.620]  смысл жесткий, чтобы не решетку, а диграф использовать. Но я не понимаю, какой. Ну да. Ну вот. Я
[02:26:00.620 --> 02:26:06.220]  надеюсь, вы разочарованы в жизни в языке C, макросах и вообще всем на свете. Больше никогда не будете
[02:26:06.220 --> 02:26:20.540]  писать макросы. Вот. Но, видимо, нет, да. Черт. У меня в ходовой классе есть несколько макросов, которые пользуются вести. Ну такой у всех есть,
[02:26:20.540 --> 02:26:26.420]  и, к сожалению, пока такого не избавится. Но это, мне кажется, прям... Но хорошие макросы, они более
[02:26:27.420 --> 02:26:41.140]  Ну окей, но вот это, это прям застрелится. И хорошо. Так, наверное, надо заканчивать. Вряд ли
[02:26:41.140 --> 02:26:48.940]  какие-то вопросы есть по вот этому. Поэтому давайте останавливать запись и расходиться.
