[00:00.000 --> 00:10.680]  всем доброго дня мы с вами продолжаем курс курс называется у нас технологии настройки
[00:10.680 --> 00:16.640]  проекторов вот потому что мы тут пытались настроить проектор в итоге вроде привели его
[00:16.640 --> 00:21.680]  в исходное состояние но даже это нам сильно не помогло потому что мне придется видимо некоторое
[00:21.680 --> 00:27.400]  время потратить на то чтобы потом этот проектор выключать вот значит сегодня у нас последняя
[00:27.400 --> 00:34.360]  лекция перед контрольной и значит уже есть пробный вариант контрольной контрольной будет
[00:34.360 --> 00:39.480]  находиться напомню в одной из трех аудиторий да потому что сейчас вы все прекрасно вмещаетесь
[00:39.480 --> 00:44.680]  в одно аудиторию но на контрольной вы точно в одного аудитории не вместитесь по понятным причинам
[00:44.680 --> 00:51.440]  вот распределение людей по контрольным будет чуть позже и сегодня мы с вами начать будем говорить
[00:51.440 --> 00:57.360]  закать закончим тему тестирования дополнительно значить я принес тех книги которые я планировал
[00:57.360 --> 01:03.560]  принести их можно взять посмотреть вот ну а сегодня мы продолжим говорить про методики
[01:03.560 --> 01:08.600]  тестирования и дополнить по говорим еще про патор значит напомню на чем мы с вами в прошлый
[01:08.600 --> 01:13.640]  раз остановились к сожалению на проекторе не очень сильно видно поэтому я буду некоторые вещи
[01:13.640 --> 01:18.820]  переписывать значит мы с вами начали говорить по мутационное тестирование это методика
[01:18.820 --> 01:23.820]  которая позволяет производить над исходным кодом некоторые мутации.
[01:23.820 --> 01:36.820]  У нас есть с вами функция, которая является public a plus b,
[01:36.820 --> 01:43.820]  и она возвращает a plus b.
[01:43.820 --> 01:45.820]  Вот такая у нас функция.
[01:45.820 --> 01:49.820]  Каким образом мы ее можем мутировать? Мы ее можем мутировать одним из трех способов.
[01:49.820 --> 01:59.820]  Первый способ – это написать то же самое, только написать a plus b и return.
[01:59.820 --> 02:07.820]  Такая конструкция, допустим, корректна в питоне,
[02:07.820 --> 02:10.820]  когда вы можете вернуть произвольный динамический тип из функции.
[02:10.820 --> 02:12.820]  То есть вы можете вернуть return.
[02:12.820 --> 02:20.820]  Второй вариант – это вот эту же функцию поменять на protected,
[02:20.820 --> 02:24.820]  то есть изменить ее модификатор области видимости.
[02:24.820 --> 02:29.820]  И третий вариант – это у нас с вами функция будет такая.
[02:29.820 --> 02:33.820]  У нас будет функция a minus b.
[02:34.820 --> 02:43.820]  И наша цель будет придумать как можно больше таких тестов, чтобы она сломала эти варианты.
[02:43.820 --> 02:50.820]  Если у нас ни один из вариантов не ломается при прохождении наших всех тестов,
[02:50.820 --> 02:54.820]  это означает, что у нас тесты достаточно слабые. Почему?
[02:54.820 --> 02:59.820]  Потому что мы предоставили с вами некорректный код, и у нас эта проверка не проходит.
[02:59.820 --> 03:02.820]  Как вы думаете, какого мутанта будет сложнее всего победить?
[03:02.820 --> 03:09.820]  Который возвращает на объект, который делает protected или который делает a minus b?
[03:09.820 --> 03:11.820]  Который делает protected.
[03:11.820 --> 03:13.820]  Да, конечно, который делает protected.
[03:13.820 --> 03:17.820]  Потому что вдруг этот метод оказывается не публичным, а приватным.
[03:17.820 --> 03:22.820]  Ой, не публичным, а protected, и мы его вызываем в наследники какого-то класса.
[03:22.820 --> 03:27.820]  В принципе, мы его сможем вызвать, но из нее вызвать не можем.
[03:28.820 --> 03:33.820]  Особенно представьте себе, что эта функция с модификатором видимости, она...
[03:33.820 --> 03:36.820]  Да, кстати, код неверный.
[03:36.820 --> 03:42.820]  Эта функция с модификатором видимости где-то вызывается еще дополнительно.
[03:42.820 --> 03:50.820]  Так, сейчас я буквально одну момента сделаю, чтобы мне не мешала вкладочка.
[03:50.820 --> 03:54.820]  Так, значит, в чем заключается цель мутационного тестирования?
[03:54.820 --> 03:58.820]  Цель тестирования, во-первых, это найти слабо протестированные участки,
[03:58.820 --> 04:03.820]  которые проходят мутанты, то есть у нас некоторые мутанты остаются.
[04:03.820 --> 04:09.820]  Дальше понятно, что слабые тесты, просто как сам факт тестов, они пропускают мутантов.
[04:09.820 --> 04:14.820]  И мы понимаем с вами какие ошибки в целом могут внести в программу.
[04:14.820 --> 04:19.820]  Самый главный кейс, который бывает, вы берете знак меньше, меняете на знак меньше или равно.
[04:19.820 --> 04:22.820]  Но это сложно тестируемый мутант. Почему?
[04:22.820 --> 04:27.820]  Потому что вам как раз нужно явно указать граничные значения.
[04:27.820 --> 04:29.820]  Логично?
[04:29.820 --> 04:33.820]  Для того, чтобы как раз проверить переход через границу.
[04:33.820 --> 04:37.820]  Или еще какой-нибудь слабый мутант у нас меньше на меньше или равно,
[04:37.820 --> 04:39.820]  а потом L вставится на условия равенства.
[04:39.820 --> 04:45.820]  То есть у нас получается unreachable код, код, который мы не можем достигнуть.
[04:45.820 --> 04:49.820]  Вот. То есть вот в этом цели как раз мутационного тестирования.
[04:49.820 --> 04:55.820]  То есть как он замеряется mutation coverage, мы замеряем количество.
[04:55.820 --> 04:59.820]  Получается у нас формула такая.
[04:59.820 --> 05:10.820]  Единичка минус количество мутаций, которые сбежали, на общее количество мутаций.
[05:15.820 --> 05:23.820]  То есть если у нас количество мутаций и не сбежавших равняется нулю, то у нас coverage 100%.
[05:23.820 --> 05:26.820]  Логично?
[05:26.820 --> 05:30.820]  Так. Вот такая вот интересная методика.
[05:30.820 --> 05:33.820]  Так. Она понятна?
[05:33.820 --> 05:37.820]  Только, как вы думаете, удобно ее проводить или нет?
[05:37.820 --> 05:45.820]  Нет. Совсем ее неудобно и к ней прибегают уже в тех случаях, когда нужно вызвать случайные претурбации.
[05:45.820 --> 05:49.820]  Вот. Это что касается mutation testing.
[05:49.820 --> 05:52.820]  Значит еще раз мы с вами поговорим про статическое тестирование.
[05:52.820 --> 05:59.820]  Суть в том, что в статическом тестировании мы с вами не запускаем код, но изучаем структуру дерева нашего проекта.
[05:59.820 --> 06:03.820]  Собственно здесь есть некоторые примеры, которые мы можем привести.
[06:03.820 --> 06:05.820]  Первый пример это код review.
[06:05.820 --> 06:10.820]  Второй пример это статические анализаторы кода. Они же еще называются линтерами.
[06:10.820 --> 06:13.820]  Про них мы с вами уже говорили.
[06:13.820 --> 06:18.820]  И есть инструменты замера качества кода. Одним из таких классических инструментов является Sonor Cube.
[06:24.820 --> 06:31.820]  Его можно использовать тоже в своих задачах. Мы про него детально говорить не будем, но в целом оно показывает примеры.
[06:31.820 --> 06:36.820]  В чем суть код review? Он выявляет антипаторные.
[06:36.820 --> 06:39.820]  Что мы здесь видим?
[06:39.820 --> 06:44.820]  Этот антипатор называется Hadouken code style.
[06:44.820 --> 06:48.820]  Или иначе callback hell.
[06:48.820 --> 06:52.820]  Это именно Hadouken code style.
[06:52.820 --> 06:57.820]  У нас функция, внутри нее проверка условий, внутри нее еще одна проверка условий, еще одна и еще одна.
[06:57.820 --> 07:02.820]  В итоге что у нас получается? У нас получается достаточно большой уровень вложенности кода.
[07:02.820 --> 07:06.820]  И с таким кодом разбираться, конечно, сложно.
[07:06.820 --> 07:11.820]  Как обычно такое решается? У кого-нибудь есть мысли?
[07:11.820 --> 07:13.820]  Ретернами.
[07:13.820 --> 07:16.820]  Во-первых, ретернами, а во-вторых, инвертированием условий.
[07:16.820 --> 07:22.820]  То есть, если вы заходите внутрь условия, здесь говорится, если условие выполнено, мы прыгаем внутрь.
[07:22.820 --> 07:29.820]  А надо сделать так, что если у вас не выполнено условие, то вы выходите из этой функции.
[07:29.820 --> 07:34.820]  Да, то есть, инвертирование условий позволяет нам решать нашу задачу.
[07:34.820 --> 07:39.820]  Да, тут сразу скажу, что еще бывает один антипатор, но это callback hell.
[07:39.820 --> 07:43.820]  То есть, когда мы вызываем функцию асинхронно, что это означает?
[07:43.820 --> 07:49.820]  Это означает, что вы не дожидаетесь результатов исполнения, но вам нужно каким-то образом будет просигнализировать, что эта функция выполнена.
[07:49.820 --> 07:54.820]  Тогда вы передаете в качестве результата еще одну функцию.
[07:54.820 --> 07:57.820]  И вы получаете как раз тот результат.
[07:57.820 --> 08:02.820]  Если у нас время останется, я вам покажу, собственно, как работают асинхронные функции.
[08:02.820 --> 08:05.820]  Так, вот у нас статический анализатор кода.
[08:05.820 --> 08:08.820]  Значит, мы его, наверное, все так или иначе видели.
[08:08.820 --> 08:13.820]  Откройте любую среду разработки, и вы увидите вот такой интересный код.
[08:13.820 --> 08:16.820]  То, что у вас там, допустим, объект возвращает не то, что надо.
[08:16.820 --> 08:20.820]  Или там подсветит, что у вас строка слишком длинная.
[08:20.820 --> 08:23.820]  Это тоже явно можно увидеть в любых инструментах.
[08:23.820 --> 08:27.820]  То есть, любая интегрированная среда разработки, она же IDE, вам покажет.
[08:27.820 --> 08:30.820]  Либо любой текстовый редактор с подключенным набором плагинов.
[08:30.820 --> 08:33.820]  Это код, кстати, на языке Objective-C.
[08:33.820 --> 08:38.820]  То есть, у нас он очень интересный, так сказать.
[08:38.820 --> 08:40.820]  Значит, линтеры какие бывают?
[08:40.820 --> 08:42.820]  Их на самом деле бывает очень много.
[08:42.820 --> 08:47.820]  Еще раз, в C++ зачастую используется Selang Format или Selang Tidy.
[08:47.820 --> 08:51.820]  Собственно, Selang Format форматирует ваш код, Selang Tidy проверяет ваш код.
[08:51.820 --> 08:55.820]  Дальше, в Python есть очень большое количество линтеров.
[08:55.820 --> 08:57.820]  Это Flake 8, PyLint.
[08:57.820 --> 08:59.820]  Это именно анализаторы кода.
[08:59.820 --> 09:04.820]  Если мы говорим про MyPy, то это анализатор кода, который проверяет типы.
[09:04.820 --> 09:08.820]  То есть, type annotations, которые есть в Python.
[09:09.820 --> 09:12.820]  И в Java зачастую используют либо CheckStyle,
[09:12.820 --> 09:14.820]  либо, по-моему, еще одна библиотека Humcrest называется.
[09:14.820 --> 09:17.820]  Но я точно тут могу ошибиться.
[09:17.820 --> 09:19.820]  CheckStyle зачастую используется.
[09:19.820 --> 09:26.820]  Так, теперь давайте поговорим про метрики качества кода, которые у нас есть.
[09:26.820 --> 09:29.820]  Их на самом деле большое количество.
[09:29.820 --> 09:32.820]  Их реально можно перечислять в этот основные.
[09:32.820 --> 09:35.820]  То есть, количество строчек кода, lines of code.
[09:35.820 --> 09:37.820]  То есть, мы говорим про качество кода.
[09:37.820 --> 09:42.820]  Вот представьте себе, что у вас есть один файл, в котором 10 тысяч строк кода.
[09:42.820 --> 09:46.820]  Как вы думаете, такой код читать просто или нет?
[09:46.820 --> 09:49.820]  Максимально просто.
[09:49.820 --> 09:52.820]  Максимально просто, потому что все в одном файле, да?
[09:52.820 --> 09:56.820]  Но на самом деле никакой структуры явно не видно за этим.
[09:56.820 --> 10:01.820]  Если у вас уже проверили первые итерации проектов, вам на это должны были намекнуть.
[10:01.820 --> 10:10.820]  Если вы пишете много классов в одном файле, вы что-то делаете не так.
[10:10.820 --> 10:13.820]  То есть, это нужно максимально разносить по разным классам.
[10:13.820 --> 10:20.820]  Ладно, давайте подумаем, почему метрика lines of code per file не очень хорошая.
[10:20.820 --> 10:23.820]  В чем у нее есть изъян?
[10:23.820 --> 10:27.820]  Именно строчек кода.
[10:27.820 --> 10:37.820]  Можно написать одну строчку и 99 строк комментариев к этому коду.
[10:37.820 --> 10:43.820]  Ну и в принципе такой код будет вполне читаемый, потому что у нас есть какие-то комментарии, которые дают важную сущность.
[10:43.820 --> 10:50.820]  Более того, комментарии зачастую используют для того, чтобы генерировать документацию к нашему проекту.
[10:51.820 --> 11:00.820]  Из таких интересных библиотек, которые позволяют генерировать документацию, в C++...
[11:00.820 --> 11:04.820]  Кстати, надо будет поговорить про документирование кода.
[11:04.820 --> 11:13.820]  В C++ зачастую используют инструмент Doxygen для генерации документации, а в Python зачастую используют пакет под названием Sphinx.
[11:13.820 --> 11:18.820]  Ну либо сервисы a la Read the Docs.
[11:18.820 --> 11:22.820]  То есть они позволяют вам оформить документацию в явном виде.
[11:22.820 --> 11:27.820]  А если мы говорим про Java, собственно там есть специальная опция в Systems Work.
[11:27.820 --> 11:31.820]  Вопрос, если здесь кто-то из 311 группы...
[11:31.820 --> 11:34.820]  Да, про Mavin говорили?
[11:34.820 --> 11:40.820]  Ну вот, у Mavin есть опция NV Onside, которая генерирует документацию.
[11:40.820 --> 11:45.820]  Для проекта.
[11:45.820 --> 11:48.820]  Вот, то есть это вот такая вещь.
[11:48.820 --> 11:54.820]  Поэтому с документацией очень важно, поэтому есть другая метрика, называется source lines of code.
[11:54.820 --> 11:57.820]  То есть количество строчек кода, которые содержат определенные стейтменты.
[11:57.820 --> 12:03.820]  И как раз statement coverage, мы говорим, что statement coverage у нас равняется...
[12:11.820 --> 12:15.820]  Ну обычно, если мы говорим именно, что каждый statement у нас в одной строке,
[12:15.820 --> 12:21.820]  у нас получается, что это coverage равняется количеству statement coverage
[12:21.820 --> 12:26.820]  к количеству source lines of code.
[12:26.820 --> 12:28.820]  Да, не к количеству локов.
[12:28.820 --> 12:34.820]  Да, потому что понятно, что если вот так вот мы сделаем, то мы никогда coverage не добьемся.
[12:40.820 --> 12:45.820]  Да, именно количество source lines of code.
[12:45.820 --> 12:50.820]  Ну да, важный строк кода.
[12:50.820 --> 12:52.820]  Дальше.
[12:52.820 --> 12:57.820]  Значит, метрики качества, которые можно отследить рефлексивным образом.
[12:57.820 --> 13:01.820]  То есть, грубо говоря, отследить их в прошлом.
[13:01.820 --> 13:04.820]  Значит, это количество строк на код.
[13:04.820 --> 13:09.820]  Да, то есть вы просто идете ретроспективно по всем комитам, которые у вас имеются,
[13:09.820 --> 13:13.820]  и отслеживаете все изменения, которые у вас произошли в коде.
[13:13.820 --> 13:15.820]  Их даже можно отследить по названию комитов.
[13:15.820 --> 13:19.820]  Вы берете и указываете изменения, которые у вас есть.
[13:19.820 --> 13:20.820]  Ретроспективно.
[13:20.820 --> 13:24.820]  Ретроспективно это означает, что мы смотрим на историю.
[13:24.820 --> 13:27.820]  То есть мы понимаем, что в какой-то момент времени мы внесли баг,
[13:27.820 --> 13:33.820]  мы в названии комитов указали fix и смотрим, какие строки у нас были изменены.
[13:33.820 --> 13:36.820]  Кстати, для этого есть специальная команда.
[13:36.820 --> 13:39.820]  Давайте я покажу ее.
[13:39.820 --> 13:48.820]  Откроем какой-нибудь проект, допустим.
[13:48.820 --> 13:51.820]  Откроем проект Linux Mint.
[13:51.820 --> 13:57.820]  Вот, есть, кстати, графическая оболочка для этого всего.
[13:57.820 --> 14:01.820]  Давайте это все увеличить, чтобы было видно.
[14:01.820 --> 14:04.820]  И дальше смотрите, идем в произвольный файл.
[14:07.820 --> 14:11.820]  Ридми, допустим.
[14:11.820 --> 14:18.820]  И смотрите, здесь есть складка под названием blame.
[14:18.820 --> 14:26.820]  Собственно, по каждой строке кода она показывает, кто внес изменения в эту конкретную строку кода.
[14:26.820 --> 14:35.820]  То есть вы можете в принципе отмотаться по истории изменений для этих действий.
[14:35.820 --> 14:37.820]  То есть назад, назад, назад.
[14:37.820 --> 14:42.820]  И, собственно, посчитать комиты, которые у вас имеют статус fix.
[14:42.820 --> 14:45.820]  То есть это именно ретроспективная метрика.
[14:45.820 --> 14:49.820]  Следующая метрика, которая является очень важной, это цикломатическая сложность программы.
[14:49.820 --> 14:51.820]  Сейчас про нее поговорим.
[14:51.820 --> 14:58.820]  И более того, помните первые лекции, когда у нас были cohesion и coupling?
[14:58.820 --> 15:04.820]  На самом деле cohesion и coupling это математические термины, их можно четко сформулировать.
[15:04.820 --> 15:06.820]  Я этого делать не буду и на контроль на этого не буду.
[15:06.820 --> 15:11.820]  Прямо сказать, что вот у нас cohesion такой, то у него качество не очень хорошее.
[15:11.820 --> 15:13.820]  Так, окей.
[15:13.820 --> 15:15.820]  Это что касается метрики качества.
[15:15.820 --> 15:17.820]  Сейчас мы поговорим про цикломатическую сложность.
[15:17.820 --> 15:19.820]  Да, метрик очень много.
[15:19.820 --> 15:21.820]  Соответственно, чем больше метрик, тем лучше.
[15:21.820 --> 15:23.820]  Ну, опять же до определенного момента.
[15:23.820 --> 15:28.820]  Потому что некоторые метрики могут гаррелировать между собой.
[15:28.820 --> 15:32.820]  То есть они будут вести себя ровно одинаково.
[15:32.820 --> 15:34.820]  Так, двигаемся дальше.
[15:36.820 --> 15:38.820]  Хорошо.
[15:38.820 --> 15:40.820]  Значит, цикломатическая сложность.
[15:40.820 --> 15:43.820]  Формула для цикломатической сложности.
[15:43.820 --> 15:46.820]  Значит, у вас у всех были графы?
[15:46.820 --> 15:48.820]  Все знают, что такое граф?
[15:48.820 --> 15:53.820]  Ровно говоря, цикломатическая сложность нашей функции или нашей программы
[15:53.820 --> 15:55.820]  замеряется по формуле.
[15:56.820 --> 16:02.820]  E-V плюс удвоенное количество компонент связности.
[16:04.820 --> 16:06.820]  То есть что мы делаем?
[16:06.820 --> 16:09.820]  Мы код нашей программы представляем в виде графа.
[16:09.820 --> 16:13.820]  Неориентированного на самом деле графа.
[16:13.820 --> 16:16.820]  Рисуем все условия веток перехода.
[16:16.820 --> 16:19.820]  И замеряем вот эту величину.
[16:19.820 --> 16:22.820]  Давайте представим, что у нас есть линия.
[16:22.820 --> 16:27.820]  Скажите, пожалуйста, чему равняется цикломатическая сложность линии?
[16:27.820 --> 16:29.820]  Линия это у нас что?
[16:30.820 --> 16:32.820]  Это дерево.
[16:35.820 --> 16:38.820]  Ну, в дереве что мы знаем? Чему равняется E?
[16:39.820 --> 16:41.820]  В-1.
[16:41.820 --> 16:50.820]  То есть для вот этой штуки мы получаем, что M равно E-E-1 плюс 2.
[16:51.820 --> 16:53.820]  Получаем 1.
[16:53.820 --> 16:55.820]  Сложность вот такой штуки 1.
[16:55.820 --> 16:59.820]  Теперь представьте себе, что у нас в ходе есть 1 if.
[17:05.820 --> 17:07.820]  Да, да, согласен.
[17:08.820 --> 17:12.820]  Ага, теперь представим себе, что у нас есть цикл.
[17:21.820 --> 17:23.820]  Нет, 1.
[17:24.820 --> 17:26.820]  Что такое компонента связанности?
[17:26.820 --> 17:32.820]  Это класс эквалидности по тому, как мы можем достичь объекта.
[17:32.820 --> 17:35.820]  Если мы от любой вершины можем дойти до любой другой.
[17:35.820 --> 17:38.820]  То есть граф у нас связанный, значит компонент связанности у нас 1.
[17:42.820 --> 17:44.820]  Здесь у нас сколько?
[17:44.820 --> 17:47.820]  Цикломатическая сложность. Давайте посчитаем.
[17:48.820 --> 17:52.820]  Раз, два, три, четыре, пять, шесть.
[17:52.820 --> 17:57.820]  В равняется шести, E равняется раз, два, три, четыре, пять.
[17:57.820 --> 17:59.820]  Господи.
[17:59.820 --> 18:02.820]  Раз, два, три, четыре, пять, шесть.
[18:04.820 --> 18:06.820]  M равняется двойке.
[18:06.820 --> 18:09.820]  То есть мы с вами видим, что каждая нелинейность по факту,
[18:09.820 --> 18:14.820]  каждое условие добавляет количество цикломатической сложности единицы.
[18:15.820 --> 18:18.820]  На примере, который на слайде.
[18:18.820 --> 18:21.820]  Здесь на самом деле что-то типа Дувайла.
[18:22.820 --> 18:24.820]  Давайте я тоже это перерисую.
[18:29.820 --> 18:32.820]  Здесь как раз все возвращается извне.
[18:32.820 --> 18:34.820]  Вот такой у нас граф.
[18:34.820 --> 18:37.820]  Что у нас в нем есть?
[18:37.820 --> 18:40.820]  Раз, два, три, четыре, пять, шесть, семь, восемь.
[18:41.820 --> 18:44.820]  B равняется восьми.
[18:44.820 --> 18:48.820]  А E равняется раз, два, три, четыре, пять, шесть, семь, восемь.
[18:48.820 --> 18:51.820]  B в десять.
[18:51.820 --> 18:55.820]  Да, кажется, по-моему, тут баг сейчас формуле будет.
[18:55.820 --> 18:58.820]  Да, четыре.
[18:58.820 --> 19:02.820]  Так. Раз, два, раз, два.
[19:02.820 --> 19:05.820]  Да, тут баг формуле M равняется четырем.
[19:05.820 --> 19:08.820]  Надо будет поправить.
[19:08.820 --> 19:11.820]  Опять же, просто есть некоторые замеры.
[19:11.820 --> 19:14.820]  Есть обычно две версии цикломатической сложности,
[19:14.820 --> 19:17.820]  когда у нас есть возврат начала и когда у нас нет возврат начала.
[19:17.820 --> 19:20.820]  Но давайте считать, что здесь у нас общая формула.
[19:20.820 --> 19:23.820]  И цикломатическая сложность равняется четыре.
[19:23.820 --> 19:27.820]  Сразу скажу, что автором вот этой метрики является МакКейп.
[19:27.820 --> 19:35.820]  И как раз вы можете пойти и вбить как раз Кейп цикломатик комплексити.
[19:35.820 --> 19:38.820]  А вот она, кстати, книга.
[19:38.820 --> 19:41.820]  Вот это оригинальная статья.
[19:41.820 --> 19:45.820]  Вы когда-нибудь читали научные статьи?
[19:49.820 --> 19:52.820]  Давайте посмотрим на это.
[19:52.820 --> 19:54.820]  Познакомлю.
[19:54.820 --> 19:57.820]  Значит, статья комплексити межер.
[19:57.820 --> 20:00.820]  Обращу внимание на год.
[20:00.820 --> 20:03.820]  1976.
[20:03.820 --> 20:06.820]  Вот она.
[20:06.820 --> 20:09.820]  Уже к этому году задумывались о качестве кода.
[20:09.820 --> 20:14.820]  И здесь вводится как раз вот эта формула.
[20:14.820 --> 20:18.820]  И, смотрите, давайте рассмотрим некоторые примеры.
[20:18.820 --> 20:21.820]  Сейчас будут примеры разности цикломатической сложности.
[20:21.820 --> 20:24.820]  Опять же, тут есть некоторые разные нотации о том,
[20:24.820 --> 20:26.820]  как это заменить.
[20:26.820 --> 20:30.820]  Я хочу здесь показать пример того, как эта сложность растет.
[20:30.820 --> 20:33.820]  Вот это код сложности 2.
[20:33.820 --> 20:36.820]  Тут, скорее всего, печатка.
[20:36.820 --> 20:39.820]  Вот эти штуки сложности 1.
[20:39.820 --> 20:43.820]  У следующего кода сложность 2.
[20:43.820 --> 20:48.820]  У вот этого кода уже сложность 5.
[20:48.820 --> 20:51.820]  Сложность 6.
[20:51.820 --> 20:54.820]  8.
[20:54.820 --> 20:57.820]  9.
[20:57.820 --> 21:00.820]  10.
[21:00.820 --> 21:03.820]  10.
[21:03.820 --> 21:06.820]  11.
[21:06.820 --> 21:09.820]  Мы поняли.
[21:09.820 --> 21:12.820]  Это незначное число мы не достигли никогда.
[21:12.820 --> 21:15.820]  Нет.
[21:15.820 --> 21:18.820]  Мы поняли.
[21:18.820 --> 21:21.820]  Нет.
[21:21.820 --> 21:24.820]  Скорее нужно сказать так же.
[21:24.820 --> 21:27.820]  Если вы достигаете двузначенного числа, значит у вас есть проблемы в коде.
[21:27.820 --> 21:30.820]  И как раз, если внимательно почитать эту статью,
[21:30.820 --> 21:35.820]  то евреистически как раз выяснилось, что если у вас цикломатическая сложность больше, чем 10,
[21:35.820 --> 21:38.820]  то вам надо переписывать ваш код.
[21:38.820 --> 21:42.820]  Но потому что тут, смотрите, явно даже видно, что, грубо говоря,
[21:42.820 --> 21:46.820]  на десяти вершинах, на цикломатической сложности 10,
[21:46.820 --> 21:50.820]  если как-то граф можно сделать планарным, то есть его можно нарисовать на плоскости,
[21:50.820 --> 21:53.820]  то когда цикломатическая сложность у вас 11,
[21:53.820 --> 21:56.820]  ну это уже все.
[21:56.820 --> 21:59.820]  Как говорится, сложно такой граф сделать планарным,
[21:59.820 --> 22:02.820]  то есть чтобы нарисовать на плоскости без пересечений.
[22:02.820 --> 22:05.820]  Вот.
[22:05.820 --> 22:08.820]  История развития этого всего на самом деле пошла еще в далеком прошлом,
[22:08.820 --> 22:13.820]  когда сказали, что не надо использовать конструкции вида Go2.
[22:13.820 --> 22:17.820]  Кто-нибудь хоть раз в жизни использовал Go2?
[22:17.820 --> 22:22.820]  Ну да, единственное, если вы используете их в Assembler либо в Asyah.
[22:22.820 --> 22:25.820]  Да, Go2 это просто инструкция вида Jump.
[22:25.820 --> 22:28.820]  Она просто есть в Assembler, как факт.
[22:28.820 --> 22:31.820]  А вот если мы говорим про сишный код,
[22:31.820 --> 22:36.820]  то в Go2 инструкцию можно использовать только как инструкцию Finally.
[22:36.820 --> 22:40.820]  То есть если вы посмотрите, как работают исключения,
[22:40.820 --> 22:42.820]  то там есть вот такое свойство.
[22:42.820 --> 22:48.820]  Там try, catch и finally.
[22:48.820 --> 22:51.820]  Что делает finally?
[22:51.820 --> 22:55.820]  По факту, она вне зависимости от того,
[22:55.820 --> 22:58.820]  закончили ли вы здесь в trial и поймали исключение,
[22:58.820 --> 23:04.820]  вы очищаете те ресурсы, которые у вас имеются.
[23:04.820 --> 23:06.820]  Вот такая вот вещь.
[23:06.820 --> 23:09.820]  Это сложность очень важная.
[23:09.820 --> 23:12.820]  И здесь как раз...
[23:12.820 --> 23:16.820]  Тут уже говорит статья, я ее перешлю.
[23:16.820 --> 23:18.820]  Вот, пожалуйста, посмотрите.
[23:23.820 --> 23:25.820]  Примеры.
[23:25.820 --> 23:29.820]  Даже невооруженным глазом видно, что слева код достаточно простой,
[23:29.820 --> 23:31.820]  а справа код сложный.
[23:31.820 --> 23:35.820]  А теперь представьте, что вы с этим кодом еще и работаете в виде кода.
[23:35.820 --> 23:39.820]  А, то есть у вас, грубо говоря, здесь у нас картинка двумерная,
[23:39.820 --> 23:42.820]  а в коде у нас картинка одномерная.
[23:42.820 --> 23:46.820]  Будет неприятно использовать вот такой код.
[23:46.820 --> 23:50.820]  Так, хорошо, давайте про цикломатическую сложность вопрос.
[23:50.820 --> 23:55.820]  Вы видели, наверное, в варианте пробном, что есть такая задача.
[23:55.820 --> 23:59.820]  Условные, да, или конструкция-фор.
[23:59.820 --> 24:04.820]  То есть если у нас есть фор, какое-нибудь,
[24:04.820 --> 24:07.820]  то как он у нас будет выглядеть?
[24:13.820 --> 24:16.820]  И мы выполняем некоторые действия.
[24:16.820 --> 24:19.820]  То есть если у нас есть фор,
[24:19.820 --> 24:22.820]  то как он у нас будет выглядеть?
[24:22.820 --> 24:26.820]  И мы выполняем некоторые действия.
[24:35.820 --> 24:38.820]  Где тряпка? А, во.
[24:44.820 --> 24:48.820]  То есть как эта конструкция у нас будет выглядеть?
[24:48.820 --> 24:51.820]  Ну, первое, что у нас есть.
[24:51.820 --> 24:55.820]  Мы ставим i равное нулю.
[24:55.820 --> 24:59.820]  Дальше мы делаем условие i меньше 10.
[24:59.820 --> 25:04.820]  Если у нас i меньше 10, то мы двигаемся и выполняем action.
[25:05.820 --> 25:08.820]  И возвращаемся в наш цикл.
[25:08.820 --> 25:10.820]  Иначе выходим из цикла.
[25:10.820 --> 25:14.820]  То есть, да, у нас тут получается, просто явно цикл появляется.
[25:14.820 --> 25:19.820]  Поэтому, так или иначе, она называется цикломатической сложностью.
[25:19.820 --> 25:20.820]  То есть вот раз.
[25:20.820 --> 25:23.820]  А во-вторых, мы можем посмотреть на количество циклов в нашем графе
[25:23.820 --> 25:25.820]  и получить конкретные выводы.
[25:25.820 --> 25:30.820]  О том, какое количество нелинейности у нас с вами в коде возникает.
[25:32.820 --> 25:37.820]  То есть у такого кода, если мы с вами больше ничего добавлять не будем,
[25:37.820 --> 25:40.820]  то у нас цикломатическая сложность будет 2.
[25:43.820 --> 25:46.820]  Так, это понятно?
[25:47.820 --> 25:50.820]  На контроль не сможете решить?
[25:54.820 --> 25:56.820]  Ладно, давайте тогда...
[25:56.820 --> 25:58.820]  Если что, задавайте вопрос.
[25:58.820 --> 26:00.820]  Так, теперь мы переходим еще к одной методике.
[26:00.820 --> 26:03.820]  То есть, то, что у нас было, это было тестирование белого ящика.
[26:03.820 --> 26:06.820]  Сейчас мы с вами говорим про тестирование черного ящика.
[26:06.820 --> 26:07.820]  То есть, что такое черный ящик?
[26:07.820 --> 26:09.820]  Мы с вами не видим код.
[26:09.820 --> 26:12.820]  У нас мы имеем только некоторый вход и некоторый выход.
[26:12.820 --> 26:15.820]  И по входу мы пытаемся получить определенный выход.
[26:15.820 --> 26:18.820]  То есть, мы можем подать вход и проверить только выхода.
[26:18.820 --> 26:21.820]  Значит, какие методики здесь есть?
[26:21.820 --> 26:24.820]  У нас с вами есть метод классов эквалентности.
[26:24.820 --> 26:25.820]  Это типичные методы.
[26:25.820 --> 26:27.820]  Метод граничных значений.
[26:27.820 --> 26:29.820]  Метод, основанный на моделях.
[26:29.820 --> 26:31.820]  Я бы сказал, на предметной области.
[26:31.820 --> 26:34.820]  То есть, образно говоря, вы знаете область, в которой вы работаете.
[26:34.820 --> 26:39.820]  И знаете, каким образом должны выписываться результаты.
[26:39.820 --> 26:43.820]  И последняя методика, которую часто используется, это парное тестирование.
[26:43.820 --> 26:45.820]  Значит, классы эквалентности.
[26:45.820 --> 26:48.820]  Здесь, на самом деле, все достаточно просто.
[26:48.820 --> 26:51.820]  Нам нужно по...
[26:51.820 --> 26:53.820]  Мы с вами бьем наш код.
[26:53.820 --> 26:58.820]  Бьем наши значения на определенные классы эквалентности.
[26:58.820 --> 27:00.820]  По именно ответам.
[27:00.820 --> 27:07.820]  И пытаемся продемонстрировать из условий задач все тесты,
[27:07.820 --> 27:13.820]  которые попадают, как минимум, по одному объекту в каждой из классов эквалентности,
[27:13.820 --> 27:16.820]  которым мы определяем по условиям задачи.
[27:16.820 --> 27:18.820]  Вот это важно.
[27:18.820 --> 27:22.820]  Давайте тоже, чтобы было понимание, возьмем какой-нибудь пример.
[27:27.820 --> 27:29.820]  Пример достаточно простой.
[27:29.820 --> 27:34.820]  Представим себе, что у нас в зависимости от квартала...
[27:34.820 --> 27:37.820]  От квартала, точнее.
[27:40.820 --> 27:46.820]  Выплачивается, ну, разное количество, разная сумма взносов.
[27:46.820 --> 27:49.820]  Значит, здесь у нас выплачивается 5 рублей.
[27:49.820 --> 27:51.820]  Здесь у нас выплачивается 7.
[27:51.820 --> 27:53.820]  Здесь у нас выплачивается 10.
[27:53.820 --> 27:55.820]  А здесь выплачивается 8.
[27:55.820 --> 28:03.820]  В квартале, извините, важен именно месяц поступления платежа.
[28:03.820 --> 28:09.820]  То есть нам нужно в каждый из месяцев нашего квартала платить определенную сумму.
[28:09.820 --> 28:13.820]  Здесь у нас 5, здесь у нас 7, здесь у нас 10, здесь у нас 8.
[28:13.820 --> 28:20.820]  Нам нужно предъявить по одному из примеров для каждого класса эквалентности.
[28:20.820 --> 28:22.820]  Значит, какие примеры мы можем предъявить?
[28:22.820 --> 28:26.820]  Мы можем сказать, что в месяце 2 у нас ответ 5.
[28:26.820 --> 28:30.820]  То есть в качестве входных тестов мы предъявляем месяц 2.
[28:30.820 --> 28:36.820]  Дальше мы предъявляем тест для пятого месяца, это май, получаем ответ 7.
[28:36.820 --> 28:41.820]  Для восьмого месяца, это у нас август, получаем ответ 10.
[28:41.820 --> 28:43.820]  И одиннадцатый тест.
[28:43.820 --> 28:45.820]  Одиннадцатый тест.
[28:45.820 --> 28:50.820]  То есть мы взяли по одному объекту из каждого класса эквалентности и получили ответ.
[28:50.820 --> 28:55.820]  Понятно, что здесь можно добавлять дополнительные тесты, образно говоря.
[28:55.820 --> 29:02.820]  Если нам говорят, что если мы, допустим, укажем месяц неудовлетворяющим условиям,
[29:02.820 --> 29:05.820]  то мы должны получить ошибку.
[29:05.820 --> 29:09.820]  Ну, собственно говоря, мы получаем ответ 8.
[29:09.820 --> 29:16.820]  Если мы укажем месяц неудовлетворяющим условиям, то мы должны получить ошибку.
[29:16.820 --> 29:20.820]  Ну, собственно, здесь зависит от того, как именно условия определяются.
[29:20.820 --> 29:26.820]  Если мы говорим, что у нас четких требований нет, мы можем взять месяц номер 15.
[29:26.820 --> 29:32.820]  И это по факту будет класс эквалентности, связанный с тем, что мы не попадаем в наш диапазон.
[29:32.820 --> 29:37.820]  То есть на объект вида 15 мы должны кидать exception.
[29:39.820 --> 29:42.820]  Вот такой пример.
[29:42.820 --> 29:47.820]  То есть метод тестирования методом класса эквалентности говорит нам о том,
[29:47.820 --> 29:52.820]  что нам нужно привести по примеру тестов из каждого класса эквалентности.
[29:57.820 --> 30:02.820]  Вот. Желательно брать объекты внутри класса эквалентности, одни на их границе.
[30:02.820 --> 30:06.820]  Так, давайте вопрос по этой методике.
[30:06.820 --> 30:09.820]  Вы говорите там сложно-простого.
[30:13.820 --> 30:16.820]  Да, это реально просто.
[30:16.820 --> 30:24.820]  Хорошо, тогда следующий тест, и он интереснее, он отличается тем, каким образом проводить варианты.
[30:25.820 --> 30:28.820]  Метод граничных значений.
[30:28.820 --> 30:34.820]  Нам нужно для каждого теста предъявить некоторые граничные значения.
[30:34.820 --> 30:39.820]  То есть по одному тесту из каждой из сторон.
[30:39.820 --> 30:43.820]  Тут очень важно понять, очень важный момент заключается в том,
[30:43.820 --> 30:45.820]  какой вид тестирования нас просят.
[30:45.820 --> 30:50.820]  Потому что у метода граничных значений обычно есть два варианта.
[30:50.820 --> 30:55.820]  Первый вариант это two-way, двусторонний.
[30:55.820 --> 30:59.820]  И второй это free-way, трёсторонний.
[30:59.820 --> 31:01.820]  Что означает?
[31:01.820 --> 31:07.820]  Если мы с вами рассмотрим какой-то флот-диапазон
[31:07.820 --> 31:16.820]  и говорим следующее, что вот здесь вот, допустим, при варианте не больше чем 50 ответ х,
[31:16.820 --> 31:19.820]  а при варианте больше чем 50 ответ у,
[31:19.820 --> 31:26.820]  то нам нужно будет провести, в два-way тестирования нам нужно будет сказать два теста только.
[31:26.820 --> 31:33.820]  То есть нам нужно будет сказать вариант 50, входных варианты 50 и 50 плюс эпсилом.
[31:33.820 --> 31:35.820]  То есть двух границ.
[31:35.820 --> 31:41.820]  А если мы говорим free-way тестирования, то нам нужно будет не только взять точку внутри нашего объекта
[31:41.820 --> 31:49.820]  и вне нашего объекта, но и ещё объект, который является по факту объектом уже внутри нашего множества.
[31:49.820 --> 31:53.820]  То есть у нас 50 минус эпсилом будет 50 и 50 плюс эпсилом.
[31:53.820 --> 31:56.820]  То есть у нас будет три варианта тестов.
[31:56.820 --> 32:00.820]  То есть мы должны, грубо говоря, давайте я выражусь так.
[32:00.820 --> 32:05.820]  В two-way мы можем взять только граничную точку и точку вне множества,
[32:05.820 --> 32:10.820]  а во free-way мы ещё должны взять точку внутри нашего множества.
[32:10.820 --> 32:15.820]  Просто бывают различные варианты этого кейса.
[32:15.820 --> 32:19.820]  Обычно это касается именно флотов.
[32:19.820 --> 32:26.820]  Сентами здесь будет такая вещь, что у нас в two-way будут варианты 50 и 51,
[32:26.820 --> 32:31.820]  а в free-way у нас будут варианты 50 и 51.
[32:31.820 --> 32:35.820]  Собственно, когда мы будем говорить про контрольную, мы будем уточнять,
[32:35.820 --> 32:39.820]  какой из вариантов граничных значений мы можем использовать.
[32:39.820 --> 32:43.820]  Нужно будет сделать.
[32:43.820 --> 32:50.820]  Как вы думаете, что именно логичнее проверять, two-way тестирование или free-way тестирование?
[32:50.820 --> 32:55.820]  Да, логичнее всегда проверять free-way тестирование, потому что у нас знак меньше,
[32:55.820 --> 33:00.820]  всегда может легко превратиться в знак меньше или равно.
[33:00.820 --> 33:03.820]  Любой тест это нужно по-хорошему выявлять.
[33:03.820 --> 33:08.820]  Так, это метод граничных значений.
[33:08.820 --> 33:11.820]  Понятен ли он? Хорошо.
[33:11.820 --> 33:14.820]  Следующие парные тестирования.
[33:14.820 --> 33:19.820]  Составляем тесты, чтобы все пары признаков были протестированы.
[33:19.820 --> 33:22.820]  Кейс очень стандартный.
[33:22.820 --> 33:26.820]  Мы с вами уже смотрели тестирование наших мобильных приложений
[33:26.820 --> 33:33.820]  и представим себе, что надо протестировать наш сайт на следующих вариантах.
[33:33.820 --> 33:40.820]  Представим себе, что у нас есть с вами, я не знаю,
[33:40.820 --> 33:45.820]  три варианта телефонов.
[33:45.820 --> 33:49.820]  Первый это айфон.
[33:49.820 --> 33:52.820]  Второй это, я не знаю,
[33:52.820 --> 33:55.820]  операционную систему берем,
[33:55.820 --> 33:57.820]  андроид.
[33:57.820 --> 34:00.820]  Третий это, не знаю,
[34:00.820 --> 34:02.820]  пусть Windows Phone будет.
[34:02.820 --> 34:05.820]  Который у нас будет, я не знаю,
[34:05.820 --> 34:07.820]  айфон.
[34:08.820 --> 34:10.820]  Андроид.
[34:10.820 --> 34:13.820]  Третий это, не знаю,
[34:13.820 --> 34:15.820]  пусть Windows Phone будет.
[34:15.820 --> 34:19.820]  Которого, кстати, уже нет, но пусть он живет.
[34:19.820 --> 34:23.820]  Дальше. У нас с вами есть три вида браузеров.
[34:23.820 --> 34:25.820]  Образно говоря.
[34:25.820 --> 34:28.820]  Chrome,
[34:28.820 --> 34:33.820]  Firefox и Opera.
[34:33.820 --> 34:38.820]  И есть, давайте скажем, три расширения экрана.
[34:38.820 --> 34:44.820]  То есть у нас есть горизонтальная, есть вертикальная и есть fullscreen.
[34:44.820 --> 34:51.820]  И нам нужно проверить, как работает наше приложение на вот этих комбинациях.
[34:51.820 --> 34:54.820]  Сколько всего вариантов будет?
[34:54.820 --> 34:57.820]  27.
[34:57.820 --> 35:02.820]  Как вы думаете, 27 вариантов тестировать, особенно вручную, это приятно?
[35:02.820 --> 35:05.820]  Это очень много.
[35:05.820 --> 35:08.820]  Поэтому основная методика заключается в том,
[35:08.820 --> 35:13.820]  почему бы нам не протестировать все возможные пары комбинаций.
[35:13.820 --> 35:17.820]  То есть не все возможные тройки, а именно все возможные пары.
[35:17.820 --> 35:20.820]  То есть образно говоря, нам нужно получить тест,
[35:20.820 --> 35:22.820]  в котором есть пара iPhone Chrome.
[35:22.820 --> 35:26.820]  Нам нужно получить тест, в котором есть пара Android
[35:26.820 --> 35:28.820]  на вертикальном лэскейпе.
[35:28.820 --> 35:31.820]  И предоставить такой минимальный набор тестов.
[35:32.820 --> 35:37.820]  Да, их будет два раза меньше.
[35:37.820 --> 35:41.820]  Тут мы займемся немного комбинаторикой.
[35:41.820 --> 35:47.820]  Ну и особенно представьте себе, когда у нас вариантов 4 будет.
[35:47.820 --> 35:50.820]  То есть у нас группа будет не 3, а группа будет 4.
[35:50.820 --> 35:54.820]  То есть у нас получается количество вариантов будет порядка квадрата.
[35:54.820 --> 35:58.820]  От количества действий, а не четвертой степени.
[35:58.820 --> 36:01.820]  То есть добавляем четвертую размерность, мы получаем 81,
[36:01.820 --> 36:03.820]  а так у нас будет порядка 9-10 тестов.
[36:03.820 --> 36:06.820]  Ну что, давайте составлять варианты.
[36:06.820 --> 36:13.820]  Значит, давайте iPhone, Android в Windows Phone.
[36:13.820 --> 36:16.820]  И дальше мы их перечислим.
[36:16.820 --> 36:19.820]  То есть как минимум нам нужно будет перечислить тройки вариантов.
[36:22.820 --> 36:24.820]  Windows Phone.
[36:24.820 --> 36:29.820]  И дальше перечисляем тройки браузеров таким образом,
[36:29.820 --> 36:31.820]  чтобы они не пересекались.
[36:31.820 --> 36:34.820]  Ну понятно, что здесь мы можем сделать циклический звик.
[36:34.820 --> 36:37.820]  C, F, O.
[36:37.820 --> 36:39.820]  Так, O, C, F.
[36:39.820 --> 36:42.820]  Дальше что у нас получается?
[36:42.820 --> 36:45.820]  O, C, F.
[36:45.820 --> 36:49.820]  То есть у нас получается вот такие тройки вариантов.
[36:49.820 --> 36:52.820]  А теперь нам нужно протестировать пару.
[36:52.820 --> 36:57.820]  Допустим Android Horizontal.
[36:57.820 --> 37:01.820]  Точнее iPhone Horizontal.
[37:01.820 --> 37:06.820]  Смотрите, здесь мы покрываем сразу пару iPhone Horizontal.
[37:06.820 --> 37:11.820]  Следующим тестом мы хотим покрыть iPhone Vertical.
[37:11.820 --> 37:13.820]  iPhone Vertical.
[37:13.820 --> 37:18.820]  А третьим вариантом у нас закрывается iPhone FFF.
[37:18.820 --> 37:19.820]  Это кто у нас?
[37:19.820 --> 37:20.820]  Fullscreen.
[37:20.820 --> 37:21.820]  Fullscreen, да.
[37:21.820 --> 37:23.820]  Так, то есть мы перебрали с вами варианты.
[37:23.820 --> 37:27.820]  Дальше значит iPhone Android.
[37:27.820 --> 37:30.820]  Ой, Android получается Horizontal.
[37:35.820 --> 37:37.820]  Сейчас я подумаю.
[37:40.820 --> 37:42.820]  Можно ли их прямо так же перечислить?
[37:42.820 --> 37:45.820]  Кажется, их можно прямо так же перечислить.
[37:45.820 --> 37:49.820]  Так, тем образом смотрите.
[37:49.820 --> 37:53.820]  Horizontal у нас перекрывает все варианты телефонов, все варианты браузеров.
[37:53.820 --> 37:57.820]  Vertical перекрывает тоже здесь.
[37:57.820 --> 38:01.820]  И Fullscreen, кажется, у нас тоже все перекрывает.
[38:01.820 --> 38:08.820]  То есть если сейчас какую пару комбинаций мы не возьмем из трех групп,
[38:08.820 --> 38:11.820]  они у нас все будут покрыты этими тестами.
[38:11.820 --> 38:15.820]  То есть это сильно сокращает количество тестов.
[38:15.820 --> 38:21.820]  Смотрите, у нас было тестов 27 штук, теперь стало их 9.
[38:21.820 --> 38:32.820]  Но при этом скорее всего утверждение такое, что парное тестирование сможет там 90% случаев точно выявить.
[38:32.820 --> 38:38.820]  Наверное, это будет намного проще.
[38:38.820 --> 38:43.820]  То есть сказать, грубо говоря, поставьте себе...
[38:43.820 --> 38:49.820]  Один человек берет iPhone, второй человек берет Android, третий человек берет Windows Phone
[38:49.820 --> 38:53.820]  и проверяет те варианты, которые у нас здесь есть.
[38:53.820 --> 38:57.820]  Понятно, что вариации могут отличаться.
[38:57.820 --> 39:00.820]  Так, этот вариант понятен?
[39:00.820 --> 39:02.820]  Эта методика.
[39:02.820 --> 39:04.820]  Хорошо.
[39:04.820 --> 39:08.820]  Пример мы с вами уже разобрали, пример был на доске.
[39:08.820 --> 39:11.820]  Теперь decision table testing.
[39:11.820 --> 39:16.820]  Особенность здесь заключается в том, что вы берете, читаете требования
[39:16.820 --> 39:22.820]  и понимаете, образно говоря, что если вы потратили 5 рублей,
[39:22.820 --> 39:25.820]  то у вас скидка 0%.
[39:25.820 --> 39:28.820]  Если у вас, грубо говоря...
[39:28.820 --> 39:32.820]  То есть читаете какой-нибудь пресс-лист и читаете условия, которые у вас есть по варианту.
[39:32.820 --> 39:36.820]  Просто с кисточком перечисляете их и просто выписываете их в таблицу.
[39:36.820 --> 39:41.820]  Образно говоря, что если вы, грубо говоря, потратили 1000 рублей,
[39:41.820 --> 39:46.820]  дальше совершили выкуп по 50% деятельности, это 11 столбец,
[39:46.820 --> 39:52.820]  то вам дается скидка 10% на 15 вещей.
[39:52.820 --> 39:57.820]  Вопрос, как эту таблицу превратить в теста?
[39:57.820 --> 40:00.820]  Таблица это и есть входные варианты для тестов.
[40:00.820 --> 40:03.820]  То есть вы просто выписываете все требования в виде таблицы,
[40:03.820 --> 40:06.820]  а дальше переводите их в тест.
[40:06.820 --> 40:09.820]  Все, поменяли слово, получили тест.
[40:09.820 --> 40:12.820]  То есть иногда полезно выписать все варианты в виде таблички,
[40:12.820 --> 40:15.820]  чтобы они у вас были видны как тест.
[40:15.820 --> 40:18.820]  Так, это что касается decision table testing.
[40:18.820 --> 40:22.820]  Вот такие у нас методики тестирования черного ящика базовые существуют.
[40:22.820 --> 40:27.820]  Их вполне достаточно для базовых реализаций.
[40:27.820 --> 40:31.820]  Так, это понятно?
[40:31.820 --> 40:33.820]  Хорошо.
[40:33.820 --> 40:36.820]  Теперь переходим к тестированию gray box.
[40:36.820 --> 40:38.820]  Что такое серый ящик?
[40:38.820 --> 40:41.820]  Это значит, что у нас к нему нет полного доступа.
[40:41.820 --> 40:44.820]  То есть у нас открыт только частичный доступ к нашему проекту.
[40:44.820 --> 40:47.820]  И у нас есть частичные знания об архитектуре проекта.
[40:47.820 --> 40:51.820]  Давайте приведем примеры тестирования серого ящика.
[40:51.820 --> 40:54.820]  Первый пример это, как ни странно, UML.
[40:54.820 --> 40:57.820]  Сейчас мы не видим с вами реализацию нашего кода,
[40:57.820 --> 41:00.820]  но у нас есть реализация видеорхитектуры нашего проекта.
[41:00.820 --> 41:03.820]  То есть мы можем понять, где может прорвать.
[41:03.820 --> 41:08.820]  То, про что мы говорили на первых лекциях с точки зрения тестирования,
[41:08.820 --> 41:11.820]  это как раз тестирование серого ящика.
[41:11.820 --> 41:14.820]  Дополнительный вариант на самом деле это техподдержка.
[41:14.820 --> 41:18.820]  То есть первая линия техподдержки, которая сидит,
[41:18.820 --> 41:21.820]  она умеет отвечать на какие-то базовые вопросы.
[41:21.820 --> 41:24.820]  Что она переадресует это все разработчикам,
[41:24.820 --> 41:27.820]  которые уже разгребают отдельные вопросы.
[41:27.820 --> 41:30.820]  То есть в UML мы не вдаемся в детали,
[41:30.820 --> 41:33.820]  видим ошибки при этом в архитектуре.
[41:33.820 --> 41:36.820]  Есть еще примеры, основанные на опыте.
[41:36.820 --> 41:39.820]  Это, так сказать, experience-based testing.
[41:39.820 --> 41:42.820]  То есть образно говоря, представьте себе ситуацию,
[41:42.820 --> 41:45.820]  что у вас есть какая-то проблема в коде.
[41:45.820 --> 41:48.820]  И не только в коде, в какой-то сфере.
[41:48.820 --> 41:52.820]  Вы провели эксперимент, у нас должен получиться такой-то результат.
[41:52.820 --> 41:55.820]  Вы тогда можете обратиться к человеку,
[41:55.820 --> 41:58.820]  который проводит этот эксперимент не в первый раз,
[41:58.820 --> 42:01.820]  а, допустим, раз в десятый.
[42:01.820 --> 42:04.820]  Заплатите ему какую-то сумму, образно говоря,
[42:04.820 --> 42:07.820]  для того, чтобы он провел вам экспертизу
[42:07.820 --> 42:10.820]  и сказал, что вы делаете не так.
[42:10.820 --> 42:13.820]  И тогда вы получаете уже итоговый результат.
[42:13.820 --> 42:16.820]  То есть вы по факту здесь получите потенциальное место
[42:17.820 --> 42:21.820]  Если мы говорим вообще, из какой сферы это приходит,
[42:21.820 --> 42:24.820]  то если кто-то интересовался машинным обучением,
[42:24.820 --> 42:27.820]  я не знаю, есть ли среди вас такие,
[42:27.820 --> 42:30.820]  то есть методика как раз, называется active learning.
[42:30.820 --> 42:33.820]  То есть представьте себе, что у вас есть
[42:33.820 --> 42:36.820]  какой-то неизведанный мир,
[42:36.820 --> 42:39.820]  и вы можете у эксперта, грубо говоря, спросить,
[42:39.820 --> 42:42.820]  что это перед нами.
[42:42.820 --> 42:45.820]  Для того, чтобы как можно больше раскрыть всю картину,
[42:45.820 --> 42:48.820]  которую у нас имеется.
[42:48.820 --> 42:51.820]  Вот это примеры тестирования серого ящика.
[42:51.820 --> 42:54.820]  Кстати, важный аспект, который заключается здесь,
[42:54.820 --> 42:57.820]  он состоит в том, что время эксперта ценно.
[42:57.820 --> 43:00.820]  Грубо говоря, вы не можете его нанять на полную ставку,
[43:00.820 --> 43:03.820]  потому что это вам будет стоить дорого, очень дорого.
[43:03.820 --> 43:06.820]  Но вы можете спросить советы за иную сумму,
[43:06.820 --> 43:09.820]  провести рецензию вашего продукта.
[43:09.820 --> 43:12.820]  Так, это что касается примеров тестирования.
[43:12.820 --> 43:15.820]  И если вопросов нет?
[43:15.820 --> 43:18.820]  Есть ли здесь вопросы?
[43:18.820 --> 43:21.820]  Окей, тогда мы переходим к следующей теме.
[43:21.820 --> 43:24.820]  Это автоматические методики тестирования.
[43:24.820 --> 43:27.820]  И здесь как раз мы посмотрим, как переходить
[43:27.820 --> 43:30.820]  на более высокий уровень.
[43:30.820 --> 43:33.820]  С кем-то из вас мы уже эту тему проходили
[43:33.820 --> 43:36.820]  и на семинарах.
[43:36.820 --> 43:39.820]  Нам нужно говорить про заглушки.
[43:39.820 --> 43:42.820]  Это называется test doubles.
[43:42.820 --> 43:45.820]  Что нам помогают делать заглушки?
[43:45.820 --> 43:48.820]  Заглушки позволяют не проводить запрос
[43:48.820 --> 43:51.820]  определенного сервиса, а получать конкретный результат.
[43:51.820 --> 43:54.820]  Если у нас есть соединение по интернету,
[43:54.820 --> 43:57.820]  то мы его прирубаем и возвращаем ответ.
[43:57.820 --> 44:00.820]  И в данном случае у нас с вами есть
[44:00.820 --> 44:03.820]  несколько примеров.
[44:03.820 --> 44:06.820]  У нас есть два вида тест-даблов.
[44:06.820 --> 44:09.820]  Первый называют стаб,
[44:09.820 --> 44:12.820]  второй называют мог.
[44:12.820 --> 44:15.820]  И они отличаются между собой.
[44:15.820 --> 44:18.820]  В чем заключается став?
[44:18.820 --> 44:21.820]  Он заключается в том, что когда вы вызываете
[44:21.820 --> 44:24.820]  какой-то метод, вам просто возвращается какой-то результат.
[44:24.820 --> 44:27.820]  Образно говоря, вы вызываете метод add
[44:27.820 --> 44:30.820]  с определенными параметрами A и B,
[44:30.820 --> 44:33.820]  он вам всегда вернет значение 9.
[44:33.820 --> 44:36.820]  Вы вызываете метод add,
[44:36.820 --> 44:39.820]  и при вызове метода add вы вернете 42.
[44:39.820 --> 44:42.820]  То есть оно не влияет на результат теста.
[44:42.820 --> 44:45.820]  Другой вариант тест-даблов
[44:45.820 --> 44:48.820]  это MOKI.
[44:48.820 --> 44:51.820]  Они проверяют дополнительно, что некоторые действия
[44:51.820 --> 44:54.820]  действительно произошло,
[44:54.820 --> 44:57.820]  что у вас функция add действительно была вызвана,
[44:57.820 --> 45:00.820]  и она может поменять результат теста.
[45:00.820 --> 45:03.820]  Образно говоря, вы делаете 2 плюс 2,
[45:03.820 --> 45:06.820]  вы заменяете вызов функции add 2 плюс 2
[45:06.820 --> 45:09.820]  на результат 2 плюс 2 умножить на 2.
[45:09.820 --> 45:12.820]  И получаете результат.
[45:12.820 --> 45:15.820]  То есть вы проверите, что вы функцию вызвали,
[45:15.820 --> 45:18.820]  и при этом вы можете еще вызвать внешнюю функцию.
[45:18.820 --> 45:21.820]  Допустим, проверить работу базы данных.
[45:21.820 --> 45:24.820]  И есть другое различие, что MOKI
[45:24.820 --> 45:27.820]  это на самом деле стаб плюс ожидание некоторых выходов.
[45:27.820 --> 45:30.820]  То есть ожидание это как раз, что вы проверяете результат работы.
[45:30.820 --> 45:33.820]  А кто на семинарах Google MOKI уже прошел?
[45:36.820 --> 45:39.820]  Да, что-то немного.
[45:39.820 --> 45:42.820]  Хорошо, там в Google MOKI, когда вы будете работать,
[45:42.820 --> 45:45.820]  есть два варианта.
[45:45.820 --> 45:48.820]  Первый вариант on call,
[45:48.820 --> 45:51.820]  а второй вариант это expect call.
[45:51.820 --> 45:54.820]  Вопрос.
[45:54.820 --> 45:57.820]  Где MOKI, где Staba?
[46:03.820 --> 46:06.820]  Да, MOKI это expect call,
[46:06.820 --> 46:09.820]  потому что мы ожидаем, что при вызове функции
[46:09.820 --> 46:12.820]  у нас произойдет какие-то проверки.
[46:12.820 --> 46:15.820]  А on call мы говорим, что при вызове функции
[46:15.820 --> 46:18.820]  возвращает такой-то объект.
[46:21.820 --> 46:24.820]  Кстати, если вы запустите пример
[46:24.820 --> 46:27.820]  без проверки,
[46:27.820 --> 46:30.820]  то Google MOKI выдаст предупреждение о том,
[46:30.820 --> 46:33.820]  что вы не повесили никакие проверки на MOKI объект,
[46:33.820 --> 46:36.820]  на Stab объект.
[46:36.820 --> 46:39.820]  Это вот такая классификация.
[46:39.820 --> 46:42.820]  Если мы говорим дополнительно,
[46:42.820 --> 46:45.820]  то пример, который у нас есть, их обычно различают.
[46:45.820 --> 46:48.820]  Если мы говорим про объекты,
[46:48.820 --> 46:51.820]  которые мы обычно умеем контролировать,
[46:51.820 --> 46:54.820]  то обычно это называют Staba,
[46:54.820 --> 46:57.820]  потому что мы можем подменить объекты,
[46:57.820 --> 47:00.820]  допустим, указать другой вариант базы данных,
[47:00.820 --> 47:03.820]  к которым мы подключаемся.
[47:03.820 --> 47:06.820]  Допустим, вот как раз те, кто пишут проект
[47:06.820 --> 47:09.820]  связанный с базой данных,
[47:09.820 --> 47:12.820]  сначала мы говорили в первый этаж,
[47:12.820 --> 47:15.820]  что вам нужно взять просто in-memory базу данных,
[47:15.820 --> 47:18.820]  и вы можете использовать систему под тестирование.
[47:18.820 --> 47:21.820]  А дальше вы отправляете почту.
[47:21.820 --> 47:24.820]  Как проверить, что результат будет корректный?
[47:24.820 --> 47:27.820]  Если вы проводите ручное тестирование,
[47:27.820 --> 47:30.820]  вы пойдете посмотрите на почту,
[47:30.820 --> 47:33.820]  увидите вашу почту, можете кликнуть по ссылке.
[47:33.820 --> 47:36.820]  В автоматическом случае, конечно, вы не можете пойти
[47:36.820 --> 47:39.820]  в почтовый браузер, потому что, более того,
[47:39.820 --> 47:42.820]  вы даже автоматически сможете сэмулировать браузер.
[47:42.820 --> 47:45.820]  Во-вторых, как вы пройдете к капчу автоматически?
[47:52.820 --> 47:55.820]  Ну сложно.
[47:58.820 --> 48:01.820]  Капчи, если были бы не такими умными,
[48:01.820 --> 48:04.820]  было бы все хорошо. Но на самом деле,
[48:04.820 --> 48:07.820]  я видел несколько вариантов капчи, когда показывают картинки,
[48:07.820 --> 48:10.820]  и они специально заблюрины таким образом,
[48:10.820 --> 48:13.820]  и не смогли их разгадать.
[48:14.820 --> 48:17.820]  Ну да, как говорится,
[48:17.820 --> 48:20.820]  опять же, кейсы, все пробиваемые пушки
[48:20.820 --> 48:23.820]  и непробиваемые брони.
[48:23.820 --> 48:26.820]  Да, резистентность к антибиотикам тоже.
[48:26.820 --> 48:29.820]  Согласен. Хороший пример.
[48:29.820 --> 48:32.820]  То есть, по факту, мы можем создать свой mock-объект,
[48:32.820 --> 48:35.820]  который будет проверять, что мы действительно
[48:35.820 --> 48:38.820]  отправили письмо.
[48:38.820 --> 48:41.820]  Но письмо отправлять не будет.
[48:44.820 --> 48:47.820]  Проверяет выходы.
[48:47.820 --> 48:50.820]  Какие фреймворки для mock-тестирования существуют?
[48:50.820 --> 48:53.820]  В Python есть unit-test-mock.
[48:53.820 --> 48:56.820]  В S++ есть Google-mock.
[48:56.820 --> 48:59.820]  В Java, те, кто работает по Java,
[48:59.820 --> 49:02.820]  скорее всего будут использовать библиотеку Makita.
[49:02.820 --> 49:05.820]  И если мы говорим про JavaScript, есть библиотека Jest.
[49:05.820 --> 49:08.820]  Как раз детально, как эти тесты работают,
[49:08.820 --> 49:11.820]  мы как раз будем говорить на семинарах.
[49:11.820 --> 49:14.820]  Собственно, если вам не говорили про mock-тестирование,
[49:14.820 --> 49:17.820]  пините ваших семинаристов.
[49:17.820 --> 49:20.820]  Вот, они вам должны это рассказать.
[49:20.820 --> 49:23.820]  Так,
[49:23.820 --> 49:26.820]  вижемся дальше.
[49:26.820 --> 49:29.820]  То есть, еще раз, моки позволяют заглушить объект.
[49:29.820 --> 49:32.820]  Да, про свою группу я знаю.
[49:32.820 --> 49:35.820]  Я это на следующем семинаре планирую рассказывать.
[49:38.820 --> 49:41.820]  Так, вижемся дальше.
[49:41.820 --> 49:44.820]  Вопрос, как это реализовать?
[49:44.820 --> 49:47.820]  Как реализовать моки?
[49:56.820 --> 49:59.820]  Да, почитать библиотеку,
[49:59.820 --> 50:02.820]  в которой реализована Google-mock.
[50:02.820 --> 50:05.820]  Или почитать библиотеку,
[50:05.820 --> 50:08.820]  в которой реализованы какие-то другие функции.
[50:08.820 --> 50:11.820]  И вот здесь оказывается интересная вещь,
[50:11.820 --> 50:14.820]  что мы сейчас с вами рассмотрим два паттерна,
[50:14.820 --> 50:17.820]  при помощи которых это можно реализовывать.
[50:17.820 --> 50:20.820]  Нужен механизм подмена.
[50:20.820 --> 50:23.820]  Нам нужно реализовать механизм подмена.
[50:23.820 --> 50:26.820]  И здесь важно следующее.
[50:26.820 --> 50:29.820]  А подменять наш объект?
[50:29.820 --> 50:32.820]  Или подменять объект в каких-то случаях
[50:32.820 --> 50:35.820]  и обращаться к действительному реальному объекту?
[50:35.820 --> 50:38.820]  То есть, у нас по факту будет два сценария этих вариантов.
[50:38.820 --> 50:41.820]  И первый паттерн, который мы с вами здесь рассмотрим,
[50:41.820 --> 50:44.820]  это паттерн прокси.
[50:44.820 --> 50:47.820]  Паттерн прокси является структурным паттерном.
[50:47.820 --> 50:50.820]  Напоминаю, что у нас есть поведенческие паттерны,
[50:50.820 --> 50:53.820]  у нас есть порождающие паттерны структурные.
[50:53.820 --> 50:56.820]  А также есть доступ к объекту-заменителю
[50:56.820 --> 50:59.820]  до и после вызова функций с целью получения
[50:59.820 --> 51:02.820]  или ограничения некоторого функционала.
[51:02.820 --> 51:05.820]  Классический пример,
[51:05.820 --> 51:08.820]  который есть.
[51:08.820 --> 51:11.820]  Вот представьте себе,
[51:11.820 --> 51:14.820]  что вам нужно
[51:14.820 --> 51:17.820]  делать следующее.
[51:17.820 --> 51:20.820]  У вас есть банкомат.
[51:20.820 --> 51:23.820]  У вас есть деньги.
[51:26.820 --> 51:29.820]  Банкомат.
[51:33.820 --> 51:36.820]  Что нужно ему для работы?
[51:39.820 --> 51:42.820]  Доступ к банковской системе.
[51:42.820 --> 51:45.820]  Хорошо.
[51:45.820 --> 51:48.820]  Приходит человек,
[51:48.820 --> 51:51.820]  хочет снять деньги.
[51:54.820 --> 51:57.820]  Если есть банковская система,
[51:57.820 --> 52:00.820]  он достает карточку,
[52:00.820 --> 52:03.820]  отправляет запрос, получает информацию
[52:03.820 --> 52:06.820]  и уходит.
[52:06.820 --> 52:09.820]  Что делает он, если нет интернета?
[52:12.820 --> 52:15.820]  Вариант первый,
[52:15.820 --> 52:18.820]  кинуть exception.
[52:18.820 --> 52:21.820]  Но на самом деле такой вариант не подходит.
[52:21.820 --> 52:24.820]  Почему?
[52:24.820 --> 52:27.820]  Вдруг банковская система
[52:27.820 --> 52:30.820]  действительно отказала?
[52:30.820 --> 52:33.820]  На самом деле здесь возникает
[52:33.820 --> 52:36.820]  объект-рослойка,
[52:36.820 --> 52:39.820]  в которую мы идем и спрашиваем,
[52:39.820 --> 52:42.820]  есть ли у тебя доступ к интернету.
[52:42.820 --> 52:45.820]  Если у тебя есть доступ к интернету,
[52:45.820 --> 52:48.820]  мы общаемся к банковской системе.
[52:48.820 --> 52:51.820]  Если у нас с вами доступа к интернету нет,
[52:51.820 --> 52:54.820]  то по факту мы можем сказать,
[52:54.820 --> 52:57.820]  что у нас в банкомате есть определенная сумма денег
[52:57.820 --> 53:00.820]  и записывать ее в определенный журнал действий.
[53:00.820 --> 53:03.820]  Этот пользователь снял xxx рублей
[53:03.820 --> 53:06.820]  или снял 100 рублей.
[53:06.820 --> 53:09.820]  Пришел Петя,
[53:09.820 --> 53:12.820]  снял 100 рублей.
[53:12.820 --> 53:15.820]  Пришел Коля,
[53:15.820 --> 53:18.820]  снял 200 рублей.
[53:18.820 --> 53:21.820]  Понятно, что количество денег ограничено
[53:21.820 --> 53:24.820]  суммой в банкомате.
[53:24.820 --> 53:27.820]  В банкомате большие суммы не лежат.
[53:27.820 --> 53:30.820]  Тут есть еще одна вещь,
[53:30.820 --> 53:33.820]  что если у нас даже денег
[53:33.820 --> 53:36.820]  в банкомате нет,
[53:36.820 --> 53:39.820]  это один из немногих случаев,
[53:39.820 --> 53:42.820]  когда по девятовой карте можно выйти в минус.
[53:42.820 --> 53:45.820]  То есть у вас не запрашивается информация
[53:45.820 --> 53:48.820]  в интернете,
[53:48.820 --> 53:51.820]  вы идете и снимаете определенную сумму действий.
[53:51.820 --> 53:54.820]  Потом, когда у вас интернет появляется,
[53:54.820 --> 53:57.820]  вы берете и накатываете все действия, которые есть.
[53:57.820 --> 54:00.820]  Как раз это и делает pattern proxy.
[54:00.820 --> 54:03.820]  Чтобы записать некоторые функциональность действий
[54:03.820 --> 54:06.820]  перед тем, как мы отправим ее
[54:06.820 --> 54:09.820]  в реальную систему.
[54:09.820 --> 54:12.820]  Что можно повесить в качестве proxy?
[54:12.820 --> 54:15.820]  Примеров proxy на самом деле большое количество.
[54:15.820 --> 54:18.820]  И это реализация паттерна.
[54:18.820 --> 54:21.820]  Давайте я побольше сделаю.
[54:21.820 --> 54:24.820]  Вот так вот она выглядит.
[54:24.820 --> 54:27.820]  То есть у нас, смотрите,
[54:27.820 --> 54:30.820]  есть клиент.
[54:33.820 --> 54:36.820]  Смотрите, у нас есть с вами клиент.
[54:36.820 --> 54:39.820]  Он обращается к сервис-интерфейсу пользователя.
[54:39.820 --> 54:42.820]  И он может обращаться либо к действительному объекту,
[54:42.820 --> 54:45.820]  либо к сервису.
[54:45.820 --> 54:48.820]  То есть у нас есть некоторая операция,
[54:48.820 --> 54:51.820]  либо к объекту proxy,
[54:51.820 --> 54:54.820]  который перенаправляет все запросы на реальное действие.
[54:54.820 --> 54:57.820]  В этом реализована страница авторизации.
[54:57.820 --> 55:00.820]  Образно говоря, если у вас есть доступ к авторизации,
[55:00.820 --> 55:03.820]  то вы перенаправляетесь к реальному сервису.
[55:03.820 --> 55:06.820]  Если у вас нету доступа,
[55:06.820 --> 55:09.820]  вас перенаправляет в какое-то другое действие.
[55:09.820 --> 55:12.820]  Авторизация пользователя.
[55:12.820 --> 55:15.820]  Классический пример.
[55:15.820 --> 55:18.820]  Вы берете и заходите в систему. В любую.
[55:18.820 --> 55:21.820]  У вас запрашивается информация.
[55:21.820 --> 55:24.820]  Если у вас доступа к этому объекту нет,
[55:24.820 --> 55:27.820]  у вас идет перенаправление.
[55:27.820 --> 55:30.820]  Наверное, сталкивались всегда с таким,
[55:30.820 --> 55:33.820]  что у авторизованных пользователей, не авторизованных,
[55:33.820 --> 55:36.820]  есть разные механизмы действий.
[55:36.820 --> 55:39.820]  Или в зависимости от языка у вас происходит разная реализация.
[55:39.820 --> 55:42.820]  То есть, грубо говоря, тут всегда есть
[55:42.820 --> 55:45.820]  разная функциональность.
[55:45.820 --> 55:48.820]  Ну и по факту, давайте подумаем,
[55:49.820 --> 55:52.820]  у вас в качестве прокси объекта
[55:52.820 --> 55:55.820]  будет МОК, и вы будете вызывать как раз МОК-объект.
[55:55.820 --> 55:58.820]  А дальше он будет решать
[55:58.820 --> 56:01.820]  следующую вещь.
[56:01.820 --> 56:04.820]  То есть, вы будете считать количество вызовов
[56:04.820 --> 56:07.820]  вашей функции.
[56:07.820 --> 56:10.820]  И с какими аргументами он вызвался.
[56:10.820 --> 56:13.820]  То есть, вы введете журнал действий.
[56:13.820 --> 56:16.820]  И после этого вы можете либо передать
[56:16.820 --> 56:19.820]  ответы за функции реальному объекту.
[56:19.820 --> 56:22.820]  Это называется SPY.
[56:22.820 --> 56:25.820]  Либо вернуть результат работы вашей функции.
[56:25.820 --> 56:28.820]  То есть, тот ответ, который у вас был заложен до этого.
[56:28.820 --> 56:31.820]  Вот она реализация.
[56:31.820 --> 56:34.820]  Кажется, замечательный объект.
[56:34.820 --> 56:37.820]  И, так или иначе, прокси у вас находятся везде.
[56:37.820 --> 56:40.820]  В любой системе.
[56:40.820 --> 56:43.820]  Все, перенаправление настроено
[56:43.820 --> 56:46.820]  больше прокси.
[56:46.820 --> 56:49.820]  Вот.
[56:49.820 --> 56:52.820]  Так, какие примеры использования прокси?
[56:52.820 --> 56:55.820]  Их, на самом деле, достаточно больших много.
[56:55.820 --> 56:58.820]  Значит, это ленивая инициализация данных.
[56:58.820 --> 57:01.820]  То есть, грубо говоря, все ленивые вычисления
[57:01.820 --> 57:04.820]  по факту происходят так, что вы объявляете объект.
[57:04.820 --> 57:07.820]  И когда вам действительно нужно получить результат этого объекта,
[57:07.820 --> 57:10.820]  вы запускаете какую-то операцию.
[57:10.820 --> 57:13.820]  То есть, есть, так сказать, лейзи.
[57:13.820 --> 57:16.820]  Есть игр.
[57:16.820 --> 57:19.820]  Игр, это вы сразу вычисляете результат.
[57:19.820 --> 57:22.820]  Защита доступа. Мы видели с вами.
[57:22.820 --> 57:25.820]  Локальный запуск сервера.
[57:25.820 --> 57:28.820]  То есть, вы делаете локальный прокси объект, который общается к реальному сервису.
[57:31.820 --> 57:34.820]  Дальше, логирование запросов.
[57:34.820 --> 57:37.820]  То есть, вы заходите на любой сервис.
[57:37.820 --> 57:40.820]  И любая активность у вас записывается в отдельный журнал.
[57:40.820 --> 57:43.820]  Кэширование.
[57:43.820 --> 57:46.820]  То есть, по факту вы идете и делаете доступ локально, а не к интернету.
[57:46.820 --> 57:49.820]  И дополнительно можно экономить на результатах запуска тестов.
[57:52.820 --> 57:55.820]  То есть, это такой паттерн, который так или иначе используется.
[57:55.820 --> 57:58.820]  Более того, скорее всего, вероятно, кто-нибудь из вас сейчас прямо пользуется этим паттерном.
[58:08.820 --> 58:11.820]  Что, есть такие?
[58:13.820 --> 58:16.820]  Кто сейчас в соцсетях сидит?
[58:20.820 --> 58:23.820]  На букву Ф или на букву И?
[58:23.820 --> 58:26.820]  Нет таких?
[58:26.820 --> 58:29.820]  Которые запрещены на территории Российской Федерации.
[58:32.820 --> 58:35.820]  Я надеюсь, вы намек поняли.
[58:37.820 --> 58:40.820]  Молодцы.
[58:40.820 --> 58:43.820]  Значит, плюсы и минусы.
[58:43.820 --> 58:46.820]  У нас может быть разделение сервиса и нашего клиента.
[58:46.820 --> 58:49.820]  Плюс, работа при отсутствии сервиса или подключения к сервису.
[58:49.820 --> 58:52.820]  То есть, когда у нас есть пример.
[58:52.820 --> 58:55.820]  Дальше, мы можем делать контроль за сервисом.
[58:55.820 --> 58:58.820]  И минус задержка от сервиса.
[58:58.820 --> 59:01.820]  То есть, наверное, вы видели все примеры, которые я запускал.
[59:01.820 --> 59:04.820]  Я запускал их на домашнем компьютере.
[59:04.820 --> 59:07.820]  Который по факту Secure Shell.
[59:07.820 --> 59:10.820]  Он позволяет нам авторизовываться.
[59:10.820 --> 59:13.820]  И на семинарах вы про СССР поговорите детально.
[59:13.820 --> 59:16.820]  Но при этом могут быть задержки.
[59:16.820 --> 59:19.820]  Дичайше из-за того, что я ввожу какую-то комбинацию.
[59:19.820 --> 59:22.820]  Она, собственно, доходит с запозданием.
[59:22.820 --> 59:25.820]  Это минус использования прокси паттернов и прокси объектов.
[59:27.820 --> 59:30.820]  Так, хорошо.
[59:30.820 --> 59:33.820]  Есть ли вопросы по этому паттерну?
[59:35.820 --> 59:38.820]  То есть, примеров достаточно большое количество.
[59:38.820 --> 59:41.820]  И есть паттерн-антипод ему.
[59:41.820 --> 59:44.820]  И, кстати, он является реализован в большом числе языков.
[59:44.820 --> 59:47.820]  Ну, в той или иной степени.
[59:47.820 --> 59:50.820]  Смотрите, здесь мы ограничивали доступ к определенному объекту.
[59:50.820 --> 59:53.820]  То есть, у нас прокси был.
[59:53.820 --> 59:56.820]  Это у нас объект и его заместитель.
[59:56.820 --> 59:59.820]  Который его может подменить.
[59:59.820 --> 01:00:02.820]  Но есть другой подход.
[01:00:02.820 --> 01:00:05.820]  Давайте попробуем как раз расширить наш объект.
[01:00:05.820 --> 01:00:08.820]  То есть, у нас есть объект.
[01:00:08.820 --> 01:00:11.820]  И нам динамически нужно дополнить его поведение.
[01:00:11.820 --> 01:00:14.820]  Я не знаю.
[01:00:14.820 --> 01:00:17.820]  Возможно, что если у вас есть питон, то вы это уже прошли.
[01:00:17.820 --> 01:00:20.820]  Это паттерн-декоратор.
[01:00:20.820 --> 01:00:23.820]  У кого сейчас есть питоны, кто уже прошел декораторы?
[01:00:23.820 --> 01:00:26.820]  Угу.
[01:00:26.820 --> 01:00:29.820]  Хорошо.
[01:00:29.820 --> 01:00:32.820]  Ну, вот.
[01:00:32.820 --> 01:00:35.820]  Реализация паттерн-декоратора это в питоне декораторы.
[01:00:35.820 --> 01:00:38.820]  А что позволяет этот паттерн сделать?
[01:00:38.820 --> 01:00:41.820]  Он позволит добавить функциональность некоторым динамическим образом.
[01:00:41.820 --> 01:00:44.820]  То есть, у нас, например, отправка нотификаций.
[01:00:44.820 --> 01:00:47.820]  Установка тайм-аутов на определенную задачу.
[01:00:47.820 --> 01:00:50.820]  То есть, у нас задача управляется не более, чем какое-то количество времени.
[01:00:50.820 --> 01:00:53.820]  И сервер на Python.
[01:00:53.820 --> 01:00:56.820]  Тоже, в принципе, можно это сделать.
[01:00:56.820 --> 01:00:59.820]  То есть, у вас обработка запросов идет.
[01:00:59.820 --> 01:01:02.820]  И представим себе кейс.
[01:01:02.820 --> 01:01:05.820]  Что нам необходимо предоставить общий интерфейс для отправки нотификаций.
[01:01:05.820 --> 01:01:08.820]  Сначала в Telegram, потом по почте, потом в Вконтакте.
[01:01:08.820 --> 01:01:11.820]  При этом для разных групп пользователи это делают по-разному.
[01:01:11.820 --> 01:01:14.820]  В итоге, значит, делается следующее.
[01:01:14.820 --> 01:01:17.820]  Что у нас идет семь вариантов отправки на три варианта нотификаций.
[01:01:17.820 --> 01:01:20.820]  Потому что два в кубе, минус один вариант.
[01:01:20.820 --> 01:01:23.820]  Когда мы ничего не отправляем.
[01:01:23.820 --> 01:01:26.820]  Каким образом решать эту задачу?
[01:01:26.820 --> 01:01:29.820]  Каким образом решать эту задачу?
[01:01:29.820 --> 01:01:32.820]  У кого есть мысли?
[01:01:42.820 --> 01:01:45.820]  Ну да.
[01:01:45.820 --> 01:01:48.820]  Нам нужно создать переходничок, который для каждого варианта будет решать, как его вызывать.
[01:01:48.820 --> 01:01:51.820]  Не поверите, в России придумали замечательный вариант.
[01:01:51.820 --> 01:01:54.820]  Какая есть русская народная игрушка?
[01:01:54.820 --> 01:01:57.820]  Матрешка.
[01:01:57.820 --> 01:02:00.820]  То есть, мы берем и обалакиваем один объект внутри другого.
[01:02:00.820 --> 01:02:03.820]  Вот.
[01:02:03.820 --> 01:02:06.820]  Давайте как раз посмотрим эту вещь.
[01:02:06.820 --> 01:02:09.820]  И цель декоратора как раз стоит в том, чтобы динамически добавить функциональность таким образом,
[01:02:09.820 --> 01:02:12.820]  чтобы не зависеть от внутренней реализации.
[01:02:12.820 --> 01:02:15.820]  То есть, у нас будет обертка как в матрешке.
[01:02:16.820 --> 01:02:19.820]  Давайте посмотрим реализацию этого паттерна.
[01:02:19.820 --> 01:02:22.820]  Опять надо картинку увеличить.
[01:02:22.820 --> 01:02:25.820]  Вот она.
[01:02:25.820 --> 01:02:28.820]  То есть, смотрите, у нас есть клиент и у нас компонент есть.
[01:02:28.820 --> 01:02:31.820]  У нас с вами есть конкретный компонент, который пишет наши сообщения.
[01:02:31.820 --> 01:02:34.820]  Есть декоратор, который оборачивает наш объект.
[01:02:34.820 --> 01:02:37.820]  И потом мы поверх этого декоратора можем добавлять какие-то функциональности.
[01:02:37.820 --> 01:02:40.820]  То есть, у нас не будет это делать, наука будет продолжать.
[01:02:40.820 --> 01:02:43.820]  Потому что это очень 쉬е.
[01:02:43.820 --> 01:02:46.640]  какие-то функциональности. То есть у нас есть декоратор
[01:02:46.640 --> 01:02:50.180]  A, который добавляет объекты, и декоратор B, который объявляет
[01:02:50.180 --> 01:02:52.100]  объект. Дайте я тебе как раз пример покажу.
[01:02:52.100 --> 01:03:10.140]  Ой, я не ту ссылку вбил. Итак, значит, паттерн декоратор
[01:03:10.140 --> 01:03:12.900]  он на самом деле самый сложный. Без точки зрения кодовой
[01:03:12.900 --> 01:03:17.700]  реализации. Как раз он будет отправлять нам эти уведомления.
[01:03:17.700 --> 01:03:28.660]  Смотрите код main. Значит, у нас с вами будет нотификатор,
[01:03:28.660 --> 01:03:31.540]  и он будет у нас трех разных типов. То есть у нас есть
[01:03:31.540 --> 01:03:37.980]  natifier, у нас есть tg-notifier, и у нас email-notifier есть.
[01:03:38.820 --> 01:03:43.620]  И я обращу внимание, смотрите, видите, natifier есть один,
[01:03:43.620 --> 01:03:47.620]  дальше второй natifier принимает на вход себе natifier первого
[01:03:47.620 --> 01:03:51.060]  объекта. То есть у нас получается с вами следующее, что у нас
[01:03:51.060 --> 01:04:19.420]  один natifier вложен в другой. То есть у нас lock-notifier, tg-notifier,
[01:04:19.420 --> 01:04:30.460]  и третий объект это email-notifier. То есть они вложены у нас друг
[01:04:30.460 --> 01:04:40.980]  в друга. А дальше делается следующее. Мы email-notifier-у передаем аргумент hello-tp.
[01:04:40.980 --> 01:04:48.580]  Даже видите, даже есть реализация. Видно, что natify у нас есть как раз в
[01:04:48.580 --> 01:04:55.780]  декоратор natifier-е, есть email-notifier-е, есть в tg-notifier-е. То есть во всех типах
[01:04:55.780 --> 01:05:02.380]  объектов у нас есть метод natify. Хорошо, давайте посмотрим, как он реализован у нас.
[01:05:02.380 --> 01:05:10.260]  Мы идем в cpp-source и посмотрим нотификатор. Давайте начнем сначала с декоратора natifier.
[01:05:10.260 --> 01:05:15.740]  Собственно, он делает следующее. У него у natifier-а хранится объект на другой
[01:05:15.740 --> 01:05:25.380]  natifier и мы вызываем natify-месседж. Давайте посмотрим, как выглядит lock-notifier. Все
[01:05:25.380 --> 01:05:36.980]  очень просто. Мы просто пишем в выходной поток наше сообщение. В email-notifier-е... Сразу говорю,
[01:05:36.980 --> 01:05:51.140]  тут сейчас жесть будет. email-notifier. Ну и что тут сделается? Мы вызываем конструктор родительского
[01:05:51.140 --> 01:06:06.380]  класса и отправляем письмо на почту. Через гугловскую почту мы отправляем письмо определенному
[01:06:06.380 --> 01:06:20.820]  человеку. Вот так вот письма по почте отправляются. Это в c++, если что. А вот так tg-notifier у нас
[01:06:20.820 --> 01:06:29.340]  выглядит. То есть мы должны отправить сообщение в какой-то чат. Мы получаем бота, токены для
[01:06:29.340 --> 01:06:36.540]  авторизации и отправляем сообщение. Мы его цилизируем и дальше отправляем сообщение в определенный
[01:06:36.540 --> 01:06:41.860]  чат. В итоге у нас по цепочке они вызовутся. Сначала email-notifier отправит письмо по почте,
[01:06:41.860 --> 01:06:48.780]  потом он передает это все tg-notifier, а после этого lock-notifier. И как раз это в диаграмме будет видно.
[01:06:48.780 --> 01:07:06.100]  Вот она диаграмма по следовательности. Вот так она будет выглядеть. То есть у нас есть клиент,
[01:07:06.100 --> 01:07:11.820]  он вызывает у декоратора b method-execute, в нашем случае notify, потом декоратор b вызовет у
[01:07:11.820 --> 01:07:18.740]  объекта a method-execute, и дальше декоратор a у конкретного компонента вызовет method-execute.
[01:07:18.740 --> 01:07:28.580]  Матрешка получается. Как вы думаете, в чем минус этой матрешки?
[01:07:28.580 --> 01:07:48.100]  Да, это раз. Если в какой-то месте у нас будет ошибка, то дальше в матрешку мы не поедем.
[01:07:48.100 --> 01:07:55.520]  Да, это важно. Но в целом, смотрите, здесь появляется возможность динамически добавлять
[01:07:55.520 --> 01:08:01.760]  объекта. Если мы хотим получить, допустим, сначала отправить уведомления в tg, потом в почту,
[01:08:01.760 --> 01:08:06.960]  мы просто меняем порядок вызова конструкторов. Потому что наш декоратор принимает объект
[01:08:06.960 --> 01:08:12.360]  определенного типа. И, кстати, при помощи декораторов, вот это важно,
[01:08:12.360 --> 01:08:21.080]  реализован мог тестирование в питоне. Именно при помощи декоратора, а не при помощи проксе
[01:08:21.080 --> 01:08:29.960]  объекта. Необходимо учитывать. Ну и в случае применения, когда нам нужно добавлять функциональность
[01:08:29.960 --> 01:08:38.440]  на лету, не меняя код. Или еще бывает такой кейс, очень конкретный, если вам нужно для объекта сделать
[01:08:38.440 --> 01:08:44.360]  наследование, а объект уже final, то есть от него нельзя наследоваться. Тогда вы можете по факту
[01:08:44.360 --> 01:08:49.880]  перейти от статического наследования к динамическому наследованию этих объектов.
[01:08:49.880 --> 01:08:54.320]  Вот, значит, плюс и минус этого паттерна — это большая гибкость, чем у наследования.
[01:08:54.320 --> 01:09:00.280]  Можно добавлять несколько обязанностей сразу. У нас есть, если есть много мелких объектов,
[01:09:00.280 --> 01:09:06.120]  то оно работает как матрешка. Ну и если у нас крайне много объектов, то сложно отслеживать,
[01:09:06.120 --> 01:09:11.680]  в каком порядке они вызываются, для этого нужна трассировка. И сложность дебага последствий
[01:09:11.680 --> 01:09:17.440]  операции. Ну, в целом, это тоже можно решать. Проблемы вы берете и создаете маленькие матрешки.
[01:09:17.440 --> 01:09:26.800]  Значит, это что касается паттерн и декоратор. Так, и давайте поймем главное отличие прокси от
[01:09:26.800 --> 01:09:44.240]  декоратора. Вот два похожих паттерна между собой. Да, именно так. То есть различие этих паттернов — чисто
[01:09:44.240 --> 01:09:51.400]  логическое. То есть прокси обычно ограничивает некоторый доступ, либо отделяет доступ. А декоратор,
[01:09:51.400 --> 01:09:58.920]  наоборот, расширяет эту функциональность. Так, и, наверное, сейчас я покажу еще одну интересную вещь.
[01:09:58.920 --> 01:10:07.560]  Это в качестве демонстрации. Помните, у нас был пример, связанный с тем, что у нас было системное
[01:10:07.560 --> 01:10:16.560]  тестирование, и мы показали некоторый пример. Помните, там, при нажатии на сайт MIP-TRUE мы можем
[01:10:16.560 --> 01:10:32.840]  кликнуть по вкладке «Расписание». В общем, есть у меня такой пример. Давайте посмотрим. Вот он пример.
[01:10:32.840 --> 01:10:39.280]  Значит, здесь использовался библиотека Selenium. Она у меня уже настроена. Единственное, что...
[01:10:39.280 --> 01:10:47.400]  Вы у нас первый курс, да? Да, видите, я тут для пятого курса. Давайте будем считать,
[01:10:47.400 --> 01:10:58.800]  что вы стали первыми курсами магистратуры. Да, сразу так, авансом. Смотрите, что здесь происходит.
[01:10:58.800 --> 01:11:06.920]  Здесь библиотека на питоне. Ничего не видно, да? Пайтест, и вот здесь как раз у нас будет браузер.
[01:11:06.920 --> 01:11:12.920]  То есть мы прямо позволим сделать виртуальный браузер, в котором мы инициализируем его таким
[01:11:12.920 --> 01:11:19.840]  образом. И по факту мы делаем виртуальный браузер, и дальше мы его сейчас запустим. И мы можем
[01:11:19.840 --> 01:11:27.680]  передавать явно команды нашему браузеру. То есть браузер Get MIP-TRUE, дальше, то есть прямо можно найти
[01:11:27.680 --> 01:11:33.840]  элемент по определенной ссылке, по определенному названию, нажать на кнопку расписания. Дальше
[01:11:33.840 --> 01:11:40.040]  расписание занятий, найти эту вкладку именно конкретно. Тут нужно будет сидеть с элементом.
[01:11:40.040 --> 01:11:47.720]  Дальше вы находите элемент, скролитесь на него и скачиваете файл. Нажимаете на кнопку. Что, запустим?
[01:11:47.720 --> 01:12:05.160]  Смотрите. То есть у нас открывается браузер,
[01:12:05.160 --> 01:12:22.920]  и он здесь ничего не поломается. Открывается сайт MIP-TRUE, первое действие. Дальше кликается
[01:12:22.920 --> 01:12:30.080]  на кнопку студента. Это все в автоматическом режиме. Расписание занятий, видите вкладка
[01:12:30.080 --> 01:12:39.960]  расписания занятий. Он на нее кликает. Он на нее кликнул. Видите, он перемотался, скачал файл.
[01:12:48.680 --> 01:12:54.080]  Все, тест закончился. Да, но расписание я не могу открыть, потому что у меня Mac.
[01:12:54.080 --> 01:13:02.440]  Он не умеет Excel файлы открывать. Но в целом, вот такая демонстрация. Это реально можно
[01:13:02.440 --> 01:13:10.760]  делать в автоматическом режиме. Так, наверное, на этом все. Если есть вопросы, то задавайте.
