[00:00.000 --> 00:10.360]  Всем доброго дня! Мы с вами продолжаем наш курс после некоторого перерыва. У нас снова будет
[00:10.360 --> 00:16.720]  еще один перерыв на следующей неделе. Мне кажется, как раз за это время перерыва могло появиться
[00:16.720 --> 00:21.680]  большое количество вопросов по выполнению домашних заданий, и мы их сегодня будем как раз,
[00:21.680 --> 00:27.520]  наверное, разбирать на семинаре. Сразу скажу, что это первый блок, в котором тема лекций и
[00:27.520 --> 00:33.840]  тема семинаров будут кардинально различаться. Потому что на лекциях мы с вами будем рассматривать
[00:33.840 --> 00:39.720]  семантический анализ, а на практике мы с вами будем рассматривать уже конвертацию VR для того,
[00:39.720 --> 00:44.680]  чтобы в базовом интерпретаторе, который по факту мы пишем, мы могли сразу весь код
[00:44.680 --> 00:53.080]  сконвертировать в VR. Напомню еще раз, где мы с вами находимся. Мы с вами находимся на
[00:53.080 --> 00:59.360]  стадии elaboration, то есть у нас уже с вами есть дерево в разборах, но пока что это просто дерево
[00:59.360 --> 01:04.920]  выводов в какой-то грамматике. То есть пока что оно не обладает никакой семантической сущностью.
[01:04.920 --> 01:10.280]  Наша цель будет сегодня как раз это добавить. Давайте это краткое напоминание с прошлого
[01:10.280 --> 01:20.240]  раза. Что нам нужно знать о токене? Вот когда мы распарсили его. Тип, значение, если это функция,
[01:20.240 --> 01:29.320]  то какое количество аргументов она принимает, сигнатуру. И в дальнейшем было бы неплохо понимать,
[01:29.320 --> 01:33.480]  что если это переменная, куда мы ее кладем? На стэк или в кучу? Ну это совсем уже...
[01:59.320 --> 02:03.760]  Нет, там уже есть поинтеры в расте.
[02:03.760 --> 02:25.640]  Да, если мы говорим про garbage collector, то нам нужно было понимать, как долго мы можем хранить
[02:25.640 --> 02:31.400]  значение нашей переменной. Для этого нужно как раз область видимости определить. Ну и последняя
[02:31.400 --> 02:43.560]  вещь, это кто ответственный за локацию объектов и за удаление объектов? Либо нормальные аллокаторы
[02:43.560 --> 02:50.360]  можно использовать, которые удаляются в конце использования, как раз pattern-ray. Опять же еще
[02:50.360 --> 02:55.800]  раз напомню стадии симматического анализа. Мы будем их проходить. Первая стадия симматического
[02:55.800 --> 03:01.400]  анализа — это создание таблицы символов. И сегодня мы с вами разберем два подхода к созданию
[03:01.400 --> 03:09.000]  таблицы символов. Вторая — это проверка типов. Третья — это подготовка фреймов для вызова функции,
[03:09.000 --> 03:15.400]  потому что конвертировать в VR мы будем на самом деле по фреймово. То есть у нас есть тело функции,
[03:15.400 --> 03:21.840]  мы будем конвертировать именно тело функции. И дальше мы рассмотрим с вами трансляцию Intermediate
[03:21.840 --> 03:29.160]  Representation. Это язык, который напоминает что-то промежуточное между ассемблером и классическим
[03:29.160 --> 03:35.560]  исходным кодом, в который можно писать разные инструкции. Воле того, он выполняет эти инструкции
[03:35.560 --> 03:39.640]  линейно, и там в нем будут некоторые свойства, которые позволят его прямо интерпретировать по ходу.
[03:39.640 --> 03:49.720]  Вот. И теперь нам нужно сделать следующее. Неплохо было бы сделать так, чтобы для каждого
[03:49.720 --> 03:54.680]  не терминала мы могли бы создать некоторую осмысленную сущность. При этом для каждой
[03:54.680 --> 04:01.280]  сущности необходимо определить некоторый набор атрибутов, которые ему привязаны. То есть
[04:01.280 --> 04:06.240]  каждому не терминалу не терминалу нам нужно отнести некоторые... Ну смотрите, тут про атрибуты нужно
[04:06.240 --> 04:12.840]  быть аккуратным. Это может быть некоторый класс, это может быть некоторое, так сказать,
[04:12.840 --> 04:21.120]  там набор переменных, которые с ним связаны. Да, потому что это важно. Давайте как раз рассмотрим
[04:21.120 --> 04:30.400]  пример, связанный с парсингом числа. Вот, если у нас есть какое-то число... Так, а мел у нас есть?
[04:30.400 --> 04:40.040]  Или с наступлением весна? Вот, тут тоже есть. Что у нас есть? У нас... А, тут плохо,
[04:40.040 --> 04:49.240]  чтобы в Zoom не будет показываться доска. Ну да ладно. Да, есть что в записи. А может,
[04:49.240 --> 04:58.920]  у меня есть этот пример? Давайте гляну. Да, есть у меня этот слайд. Давайте я его покажу как раз.
[04:58.920 --> 05:04.400]  То есть, смотрите, представьте себе, что у нас есть грамматика для разбора чисел. То есть,
[05:04.400 --> 05:09.960]  это у нас достаточно какое-то простое число. Значит, как мы можем с вами зашифровать число
[05:09.960 --> 05:16.200]  произвольное в записи? Это у нас либо знак, и дальше у нас есть какая-то последовательность бит,
[05:16.200 --> 05:24.080]  которая нам нужна. И, значит, что мы должны сделать? Мы должны при встрече нашего числа при парсинге
[05:24.080 --> 05:31.400]  этого правила сделать следующее. Указать, грубо говоря, список бит, которые у нас есть. Тут у нас
[05:31.400 --> 05:37.840]  есть как раз операция для аппенда бита. И видно, что в данном контексте, если у нас с вами есть
[05:37.840 --> 05:43.640]  лист 0, лист 1 и бит. Кстати, вам видно или мне кажется, тут какая-то засветка идет дичайшая?
[05:43.640 --> 05:58.160]  Да, да, да. Мне вот кажется, что он тоже как... Я, конечно, понимаю. Так, можем ли мы это как-то поправить?
[06:07.840 --> 06:17.560]  Это максимум, на что я способен.
[06:17.560 --> 06:34.000]  А? Введем порядок в ручном режиме. Когда они закрывали же, шторы в ручном режиме. Вроде должно
[06:34.000 --> 06:39.400]  быть лучше видно. Вот, то есть у нас, смотрите, что есть. У нас есть какой-то элемент лист 0,
[06:39.400 --> 06:47.320]  да, и дальше мы парсим. Опять же, это объект-лист, но тут видите 1. Это означает, что когда мы парсим
[06:47.320 --> 06:53.280]  некоторую атрибутную грамматику, мы с вами на самом деле можем обратиться к этой переменной. То есть
[06:53.280 --> 06:59.320]  мы говорим лист 0, это лист 1 и бит. И дальше мы делаем некоторые операции при встрече, при выводе
[06:59.320 --> 07:06.520]  этого правила. Опять же, нужно здесь сказать, что атрибутные правила будут хорошо работать в
[07:06.520 --> 07:13.520]  случае восходящих парсеров, как только мы разбираем правила какое-то. Да, то есть мы поднимаемся по
[07:13.520 --> 07:20.560]  дереву, вывода вверх. А в случае, если у нас парсер идет сверху вниз, когда мы должны выводить это
[07:20.560 --> 07:36.760]  правило? Еще раз, смотрите, когда мы парсим снизу вверх, да, когда мы можем произвести вычисления
[07:36.760 --> 07:52.440]  в большем количестве случаев. Наверное, когда мы распарсили это правило, мы сделали вывод этого
[07:52.440 --> 07:59.160]  правила, написали код. Да, то есть у нас, грубо говоря, если у нас есть алгоритм перенос сверткам,
[07:59.160 --> 08:04.160]  то после свертки мы сразу можем применять это, выводить последствия действия, которые мы должны с
[08:04.160 --> 08:09.600]  вами делать. А, то есть генерирует какой-то дополнительный код и его выполнять. А в случае,
[08:09.600 --> 08:16.240]  если у нас парсер идет сверху вниз, то мы должны закрыть это правило снизу, то есть мы как бы,
[08:16.240 --> 08:25.120]  да, да, да, нам нужно распарсить все под дерево, только потом подняться вверх. Вот, и вот она атрибутная
[08:25.120 --> 08:32.960]  грамматика. Но давайте подумаем, в чем плохо работает атрибутная грамматика на лету, то есть сразу
[08:32.960 --> 08:59.600]  выводить какое-то правило. Особенно в восходящих парсерах. А? Что-что? Ну да, то есть у нас может
[08:59.600 --> 09:05.680]  быть какой-то условный результат, в зависимости от того, куда мы с вами пойдем. Да, то есть те же
[09:05.680 --> 09:13.440]  самые IFs работать не будут нормально. Как бы, вы должны сначала распарсить первую часть выражения,
[09:13.440 --> 09:22.560]  а после этого парсить только последнюю. Да, и получается, смотрите, интересная операция. Та же самая
[09:22.560 --> 09:30.800]  инструкция do while. Как бы, с ней могут быть проблемы, потому что, не, с do while, наверное, даже
[09:30.800 --> 09:36.080]  проблем не будет. Вы сначала как минимум один раз должны будете выполнить последний пациент с действием,
[09:36.080 --> 09:42.440]  который ждет после do, потом проверять условия. Да, то есть вам нужно будет аккуратно заходить
[09:42.440 --> 09:49.560]  во все под деревья, которые у вас были, и на выводе грамматики как раз применять эти правила не очень
[09:49.560 --> 09:56.800]  хорошо. То есть нам нужна какая-то отложенная структура атрибутов, к которой мы после этого можем
[09:56.800 --> 10:02.200]  обратиться и выполнить какие-то действия. Понятна ли мысль про отложенную структуру атрибутов,
[10:02.200 --> 10:11.640]  что на лету мы можем парсить только какие-то простейшие конструкции. Хорошо, значит атрибутная
[10:11.640 --> 10:17.760]  грамматика для числа числа. Так, собственно, знак мы можем определить это bool значение негатив,
[10:17.760 --> 10:26.360]  число это int, некоторое value. Список бит это может быть там набор типа позиция и значение бита для
[10:26.360 --> 10:33.960]  того, чтобы допустим не хранить все значения напрямую. И тут как раз если мы говорим про числа,
[10:33.960 --> 10:39.880]  то такая интересная особенность про формат хранения чисел. Какие форматы хранения чисел вы знаете?
[10:39.880 --> 10:52.520]  Как обычно хранятся числа int? Не-не, ну давайте это с теми понятным. Имеется в виду big
[10:52.520 --> 11:03.040]  and then little and then. Да, и у нас сразу хранится 32 бита для int. Вот, но есть интересная структура,
[11:03.040 --> 11:11.520]  интересная библиотека. Нет, есть библиотека для серилизации, десерилизации, protobuf называется.
[11:11.520 --> 11:20.760]  Вы, который формат хранения чисел совсем другой, то есть они записываются в бинарном формате,
[11:20.760 --> 11:28.480]  вот, и там число имеет переменное количество byte int. То есть int может кодироваться переменным
[11:28.480 --> 11:46.200]  числом byte от 1 до 4. Смотрите, там интересная запись, число вьется на 4 актета.
[11:58.480 --> 12:22.680]  Да, да, я согласен, что если мы говорим про компиляторы, нам это неважно. Допустим,
[12:22.680 --> 12:27.280]  если мы пишем какой-нибудь парсер для серилизации, десерилизации и каких-то данных,
[12:27.280 --> 12:32.040]  но нам тоже нужно парсить грамматику, которую она задает, и тоже давать какие-то атрибуты.
[12:32.040 --> 12:36.920]  Так вот, в protobuf интересная возможность, интересная особенность. Вы храните 4 байта,
[12:36.920 --> 12:45.080]  и первый бит этого байта означает на самом деле следующее. Будет ли у вас активирован следующий
[12:45.080 --> 12:51.240]  байт? То есть если у вас первый бит 0 в записи, то вот эти записи вам не нужны.
[12:51.240 --> 13:09.240]  Вот, то есть в зависимости от этого, а? Вот, но там правда идет интересное кодирование. 0 превращается
[13:09.240 --> 13:18.160]  в 0. Дальше минус 1 превращается в 1. Я не помню порядок. Единичка превращается в 2 и так далее.
[13:18.160 --> 13:24.360]  То есть это называется зигзак кодирования. То есть если вы хотите прочитать значение 2,
[13:24.360 --> 13:31.320]  то оно будет кодироваться в единицу. Если единица, то в минус единицы. Да, то есть вы пишете байты,
[13:31.320 --> 13:41.400]  вот они. И идем до определенного контекста. Ничего он не напоминает. Тут, собственно, вот эта
[13:41.400 --> 13:47.520]  абстракция. Это называется зигзак кодирования, но мы с вами прекрасно понимаем, ну, зигзак,
[13:47.520 --> 14:00.040]  типа получается. Вот такое кодирование. Но на самом деле, поскольку вы уже не просто программисты,
[14:00.040 --> 14:04.680]  а, собственно, проходите там курс по мотону и про всякие по всякой дискретной математике, то что
[14:04.680 --> 14:12.520]  это напоминает? Вот эта конструкция. А? Нумерация целых чисел. То есть мы так показываем, что множество
[14:12.520 --> 14:19.800]  целых чисел равномощно множество натуральных чисел. Вот. И это в пользу для эффективного кодирования информации.
[14:19.800 --> 14:46.760]  Ну, это я рассказал про кодирование интов, на самом деле. А, нет, ну там просто еще строки используют
[14:46.760 --> 14:52.680]  в этом формате. Я просто не весь формат рассказываю, потому что это не сильно нам нужно. То есть смотрите,
[14:52.680 --> 14:57.720]  как бы есть атрибуто, которое мы можем считать на лету, и здесь, в принципе, формат парсинга данных
[14:57.720 --> 15:05.560]  такой, что по первому биту мы сразу понимаем, какие у нас идут числа. Вот. Но, собственно, дерево разбора
[15:05.560 --> 15:11.200]  будет вот такое вот. И грав, в зависимости для разбора числа, будет вот такое. Блин, мне точно надо
[15:11.200 --> 15:17.440]  тебе переделать презентацию. Суть в том, что если у нас есть дерево разбора, то как бы нам все равно
[15:17.440 --> 15:25.480]  придется заходить, как бы парсить сначала первое значение, подниматься по нему. Да, то есть видите,
[15:25.480 --> 15:31.880]  тут такой рекурсивный обход идет. То есть мы получаем значения снизу, а как бы парсить мы должны
[15:31.880 --> 15:39.280]  их сверху. Вот. То есть нам нужно взаимодействие так как вверх, так и вниз. Даже для такого простого
[15:39.280 --> 15:45.680]  примера. Для того, чтобы вычислять грав зависимости. Вот. Но, на самом деле, мы с вами уже поняли,
[15:45.680 --> 15:52.800]  что грав зависимости не всегда можно построить на лету. Хотелось бы какую-то другую абстракцию
[15:52.800 --> 16:00.560]  иметь. Вот как раз про эфе. Собственно, допустим, мы когда доходим, у нас, допустим, представьте,
[16:00.560 --> 16:05.080]  уже разобрано statement1 и statement2, то нам не понятно, что именно выбрать. То есть как бы нам
[16:05.080 --> 16:10.280]  приходится использовать и то и другое условие. Да, понятно, что в этом примере мы сначала можем
[16:10.280 --> 16:16.600]  попробовать распарсить condition, а потом собрать правила. Но все равно, если мы поменяем порядок
[16:16.600 --> 16:26.720]  операции, то напрямую мы это делать уже не сможем. Ну и, собственно, дальше есть следующие методы
[16:26.720 --> 16:32.240]  обработки атрибутных грамматик. Их выделяют обычно три. Первый метод динамический. То есть
[16:32.240 --> 16:38.800]  обрабатываем вершину, как только под дерево уже обработано. Вот все узлы под дерево уже обработаны.
[16:38.800 --> 16:44.640]  Мы с вами как раз должны хранить очередь вершин, в которые у нас зависимость, и мы должны хранить
[16:44.640 --> 16:49.280]  ципологическую тратировку графа. Ну в какой-то степени для того, чтобы строить граф зависимости.
[16:49.280 --> 16:56.600]  Это сложно. Следующая вещь — это до победного, а-ля, знаете, эвристический подход. Мы пытаемся
[16:56.600 --> 17:02.800]  разобрать правила. Как только у нас правило какое-то не разбирается, мы ждем, пока какие-то другие правила
[17:02.800 --> 17:10.280]  у нас разберутся. И последний подход — это подход, основанных на правилах грамматики. То есть на каждое
[17:10.280 --> 17:15.960]  правило генерируется некоторый код, который его разбирает. Главное, что код этих атрибутов должен
[17:15.960 --> 17:23.560]  работать нормально. И как мы с вами понимаем уже на самом деле, как и FlexBizone позволяет генерировать
[17:23.560 --> 17:31.000]  код определенный, так и Ante-Ler на самом деле позволяет даже четко задавать атрибуты для грамматика.
[17:31.000 --> 17:36.840]  Как это делается? Когда у нас есть некоторые правила, мы пишем фигурные скобки после обработки
[17:36.840 --> 17:45.760]  какого-то правила для того, чтобы поставить какое-то свойство в наш контекст. Это вот такая вот интересная
[17:45.760 --> 17:52.080]  вещь, связанная с контекстом, и на самом деле она зачастую используется на практике. Опять же,
[17:52.080 --> 18:02.000]  контекст — это хорошо, но чем может быть плохо использование вот классических атрибутов? То есть,
[18:02.000 --> 18:09.400]  грубо говоря, мы построили грамматику, задали атрибуты, всё типа работает. Что нам придется
[18:09.400 --> 18:19.520]  делать, если нам придется сильно изменять структуру нашей грамматики? Да, заново всё строить,
[18:19.520 --> 18:24.920]  заново определять все атрибуты, которые у нас имеются. То есть, у нас нет никакой эфемерной
[18:24.920 --> 18:30.120]  структуры, мы как бы явно привязываемся к виду грамматики нашей. Это не очень хорошо,
[18:30.120 --> 18:36.040]  поэтому вот атрибутных грамматик обычно выделяют некоторые частные случаи атрибутной грамматики,
[18:36.040 --> 18:44.000]  и оно называется абстрактно-синтактическое дерево разбора. То есть, мы говорим, что каждому
[18:44.000 --> 18:52.320]  не терминалу мы задаем некоторый атрибут, который отвечает за хранение этого не терминала,
[18:52.320 --> 18:58.200]  за хранение сематической структуры, хранение этого не терминала. Сейчас давайте посмотрю буквально
[18:58.200 --> 19:08.800]  по слайдам. Тут у меня про интерпретатор написано, давайте всё-таки расскажу, что такое абстрактно-
[19:08.800 --> 19:17.920]  синтактическое дерево. Вот представьте себе, что у нас было какое-то правило. Давайте опять,
[19:17.920 --> 19:31.840]  а на какой доске лучше писать? Любой? Нет, вам какой? На левый, на правый? Давайте, давайте
[19:31.840 --> 19:56.200]  смотрим формулу ВВП. Итак. Бедный стул. Итак, что мы с вами делаем? У нас есть,
[19:56.200 --> 20:17.680]  представьте себе, конструкция. СТМТ. Так. Экспор выводит, значит, что экспор звёздочка звёздочка,
[20:17.680 --> 20:34.280]  экспор. Минус экспор. Ну и что-нибудь ещё нам. Нам это токен. Понятно, что экспор это у нас
[20:34.280 --> 20:42.040]  должен быть объект одного и того же класса. Потому что это у нас некоторая сущность отвечает за
[20:42.040 --> 20:49.080]  выражение. Причём выражение может быть числом, а может быть минус экспор, то есть унарный минус,
[20:49.080 --> 20:56.040]  негативная экспрессия. Получается негатив экспрессия. И вот это что у нас? Что это за оператор?
[20:56.040 --> 21:04.280]  Возведение в степени. Умножить-умножить. Вот. Тогда смотрите, что мы можем сделать в этом месте?
[21:04.280 --> 21:10.520]  Мы на самом деле в этом месте можем трансформировать всю нашу структуру в следующие объекты. У нас с вами
[21:10.520 --> 21:17.200]  будет expression, который будет представлять собой некоторый абстрактный класс, возможно интерфейс.
[21:17.200 --> 21:25.800]  А в наследниках этого класса у нас будет три наследника. Первый это нам экспор,
[21:25.800 --> 21:42.200]  второе это не гейт экспорт, а третье это кто? Кого я забыл? PowerExport.
[21:42.200 --> 21:54.640]  Какие методы у них могут быть? Здесь опять же мы можем сказать с вами, что у expression будет
[21:54.680 --> 22:01.560]  некоторое значение вида посчитать, функция, метод. Мы вызываем метод calc и пытаемся посчитать выражение.
[22:01.560 --> 22:11.800]  Но реализация метода calc, она у каждого метода будет другой, разной. Да, потому что здесь у нас
[22:11.800 --> 22:18.120]  calc вернет просто число, которое хранится. Здесь calc вызовет calc от выражения, которое лежит под
[22:18.120 --> 22:23.280]  капотом, а здесь calc у нас вычислит возведение в степень для двух выражений. То есть оно вызовет
[22:23.280 --> 22:31.200]  у каждого из них функцию calc и в конце вызовет еще один calc. Да, то есть у нас прямо видно
[22:31.200 --> 22:40.520]  древовидную структуру. Мы с вами за счет исследований и полиморфизма по факту можем работать с этим
[22:40.520 --> 22:48.840]  объектом как с единым целым. И это те, кто проходил курс по технологиям программирования, здесь кажется
[22:48.840 --> 23:06.720]  такой всего один коллега. Какой это паттерн? Да, обработка дерева. То есть вычисление значения
[23:06.720 --> 23:16.920]  дерева в зависимости от детей. Нет, это пока еще не визитер. Нет, мы к визитеру хотим перейти,
[23:16.920 --> 23:30.160]  это пока паттерн-композит, который хранит дерево как один объект. То есть он хранит сложный
[23:30.160 --> 23:46.720]  объект как единое целое. Вот в чем суть. Ну да. Ну в чем особенность паттерна-композит?
[23:46.720 --> 23:52.200]  Особенность паттерна-композит состоит в том, что это всего лишь структурный паттерн. То есть для того,
[23:52.200 --> 23:59.320]  чтобы с ним работать, в поведении будет очень неприятно, как обвязывать. То есть нам, как бы
[23:59.320 --> 24:03.400]  представьте себе, вот у нас есть два стейтмата и для каждого из стейтматов нужно будет вызывать
[24:03.400 --> 24:11.120]  метод calc. То есть стейтматы экспро и дальше вы должны будете проверять тип значений, которые у вас есть.
[24:11.120 --> 24:14.920]  Хотелось бы отвязаться от этой типа и иметь какую-то общую структуру объектов.
[24:14.920 --> 24:26.960]  Тут, кстати, говорится про интерпретатор. Что делать, если мы хотим справляться с циклами?
[24:26.960 --> 24:36.920]  Первое это анролить и пытаться использовать только константы или те значения, для которых мы уже
[24:36.920 --> 24:44.320]  знаем какую-то величину. Либо пытаться проходить несколько раз по циклической конструкции,
[24:44.320 --> 24:48.080]  попытаться все-таки проставить корневый узел, относительно которого мы с вами дальше можем
[24:48.080 --> 25:02.160]  размотаться. Понятно, что это неприятно и хотелось бы это обложить как можно на дальний момент времени.
[25:02.160 --> 25:13.920]  Не, обработка циклов имеется в виду не в дереве в зависимости, а в коде в нашем. Мы же хотим циклические
[25:13.920 --> 25:31.880]  инструкции писать. Ну а как интерпретировать? Ну вот да. Ну да, то есть нам каждый раз нужно
[25:31.880 --> 25:37.360]  вычислять условия, посмотреть доступны ли это переменные или нет. Ну да, мы пока наивный
[25:37.360 --> 25:45.800]  интерпретатор пишем, поэтому с этим проблем у нас никаких не будет. Хорошо. Так, это разобрались.
[25:45.800 --> 25:52.160]  Мы видим с вами, что с этой структурой объектов работает достаточно сложно, потому что statement
[25:52.160 --> 25:58.320]  потом он будет вызывать expression. Вам нужно просто помнить сигнатуру всех методов, которые у вас
[25:58.320 --> 26:04.440]  хранятся в абстрактном синтетическом дереве. Причем смотрите, чем особенность в абстрактном
[26:04.440 --> 26:11.400]  синтетическом дереве. Он заключается в следующем, что по факту как ни странно, вот оператор умножить
[26:11.400 --> 26:17.480]  умножить здесь нам уже не нужен. Вот этот вот. Потому что он будет храниться по факту в информации об
[26:17.480 --> 26:23.520]  узле этого дерева. Это power expression, это означает, что оператор звездочка-звездочка находится там.
[26:23.520 --> 26:32.000]  Вот, то есть как бы говорится. И более того, не факт, что у нас каждое правило будет соотносить
[26:32.000 --> 26:39.720]  один к одному. То есть, возможно, какие-то у нас могут быть интересные вещи. Допустим, смотрите.
[26:39.720 --> 26:57.960]  Statematys. Допустим, это у нас Statematys на Statematys. То есть, что такое STMTS? Это у нас statement.
[26:57.960 --> 27:04.600]  То есть, statement это что? Либо это пустой элемент, либо statement и набор других statement. Тогда
[27:04.600 --> 27:17.400]  какой код мы должны сгенерировать? Нет. То есть, смотрите, здесь не будет как раз для этого
[27:17.400 --> 27:23.480]  STMTS создаваться новый объект абстрактного синтетического дерева. Не на каждое правило у нас
[27:23.480 --> 27:29.040]  будет создаваться объект новый. Какая инструкция будет генерироваться на вот эту вот вещь?
[27:29.040 --> 27:49.800]  Не, на самом деле у нас будет хранить некоторый список стейтментов. Это да. Ну как оптимизирующие?
[27:49.800 --> 27:53.720]  Если бы он был оптимизирующий, он, возможно, бы там еще что-то сделал.
[27:53.720 --> 28:16.080]  Ну интересно. Буду знать. На самом деле, что произойдет? Значит, за STMTS будет создана
[28:16.080 --> 28:21.760]  отдельный на самом деле объект, типа список стейтментов. Это будет некоторая сигнатура,
[28:21.760 --> 28:27.120]  так сказать, в которой мы будем хранить что-то. И когда мы это вызываем, то мы в список стейтментов
[28:27.120 --> 28:34.680]  будем добавлять просто еще один стейтмент. Да, то есть у нас типа сначала 3, 4, 5 и так далее. То есть,
[28:34.680 --> 28:39.560]  все, что так или иначе подразумевает под собой итерацию к линии, какое-то повторение,
[28:39.560 --> 28:46.720]  скорее всего, будет обработаться некоторыми списками под капотом. Но мы здесь понимаем,
[28:46.720 --> 28:53.560]  что с этим будет работать достаточно сложно. И если мы будем рассматривать чистый подход,
[28:53.560 --> 28:59.080]  классический, связанный с деревьями, то нам непонятно, где у нас находится скоп у переменных.
[28:59.080 --> 29:04.080]  То есть, представьте нам атрибуты, писать для каждой переменной, писать атрибут,
[29:04.080 --> 29:10.680]  в каком скопе он находится. Это долбаться можно. Дальше создать хранилища переменных в отдельном
[29:10.680 --> 29:17.160]  месте тоже было бы неплохо. Да, мы его и так или иначе будем создавать. Но все же, значит,
[29:17.160 --> 29:22.880]  инициировать дерево разбора, ну, за нас это уже сделали, значит, в этом проблеме нет. Вот,
[29:22.880 --> 29:31.280]  и дальше у нас есть такая вещь, как нелокальность получения метаданных дерева. То есть, как бы нам
[29:31.280 --> 29:36.960]  объект, который нужен в дереве, находится где-то в другом месте, совсем в другом месте. И последняя
[29:36.960 --> 29:44.080]  вещь, кстати, крайне неприятная, и тут любители функционального языка могут сказать, что вы
[29:44.080 --> 29:49.880]  делаете, вы ломаете нам функциональную парадигму от слова совсем. То есть, как бы у нас абстрактная
[29:49.880 --> 29:57.800]  синтоксическое дерево, ну или даже атрибутная грамматика, и мы не понимаем, как обрабатывать это
[29:57.800 --> 30:14.400]  в функциональном стиле. Вот, в пигене это делается, как сказал Гера. Да? Ну да, там как раз из-за
[30:14.400 --> 30:41.200]  счет звездочки делается. Ну, умный, значит. Ну, это да. Ну да, тут я хочу сказать, что на самом деле
[30:41.200 --> 30:46.240]  существует другой подход в функциональной парадигме программирования. Вот, и, возможно, мы его
[30:46.240 --> 30:52.200]  с вами посмотрим. То есть, там даже ИАР, промежуточное представление, будет выглядеть по-другому относительно
[30:52.200 --> 31:02.120]  классического ООП, ну классической императивной парадигмы. Не, ну для функциональных языков не
[31:02.120 --> 31:21.520]  хотелось бы, чтобы ИАР был императивный. Не, ну смотрите, где это может быть полезно, когда у вас есть
[31:21.520 --> 31:27.600]  какая-то функция, которая должна работать до определенного момента времени. То есть, если она не
[31:27.600 --> 31:34.560]  сработает по определенному моменту времени, все, система глохнет. Ну, real-time OS. У них, скорее всего, вполне
[31:34.560 --> 31:39.480]  возможно понадобится как раз функциональная парадигма. Ну, тут надо опять же...
[31:39.480 --> 32:06.240]  Все это хорошо, если бы в базе данных планирование, вычисление веса для плана, было бы хорошо работало.
[32:06.240 --> 32:14.560]  Но в базных данных это тоже не так. То есть, план выполнения запроса есть, он даже считает
[32:14.560 --> 32:30.480]  сложность выполнения этого запроса, но потом... Ну вот, да. Поэтому такая вот вещь. Поэтому,
[32:30.480 --> 32:39.680]  значит, как обрабатывают деревья, и здесь возникает паттерн под названием visitor. В чем его суть
[32:39.680 --> 32:46.000]  состоит? У нас с вами строятся две структуры. Значит, первое, у нас с вами есть базовые элементы. По
[32:46.000 --> 32:51.680]  факту, в нашем случае это будут элементы абстрактного синтоксического дерева. Вот, и на них строится
[32:51.680 --> 32:59.760]  вызов структуры, подструктура объектов. То есть, опять же, все элементы, они будут иметь конкретного
[32:59.760 --> 33:07.760]  наследника. Что есть у наследников? У наследников есть метод visitAccept, который позволяет
[33:07.760 --> 33:16.560]  реализовать себе какой-то элемент объект. То есть, он принимает объект типа visitor и по факту
[33:16.560 --> 33:22.680]  запускает рекурсивный механизм. При этом у нас с вами появляется еще один объект под названием
[33:22.680 --> 33:30.360]  visitor, у которого есть метод visit от конкретного элемента. То есть, он умеет... Смотрите, я хочу
[33:30.360 --> 33:36.880]  подчеркнуть внимательно ваше внимание, что visit он вызывается не от элемента, а от конкретного
[33:36.880 --> 33:43.960]  элемента. Почему это важно? Потому что здесь будет на самом деле работать механизм двойной
[33:43.960 --> 33:50.320]  диспетчеризации. То есть, как все это будет обрабатываться? У нас с вами будет какой-то
[33:50.320 --> 33:57.040]  visitor. Мы с вами на самом деле будем все запускать от элемента. То есть, представьте себе, мы находимся
[33:57.040 --> 34:04.760]  в корне, и мы говорим про следующую концепцию. Вместо того, чтобы посетитель обошел, допустим, дом,
[34:04.760 --> 34:12.680]  мы делаем следующее. Мы говорим обратную вещь. Пусть дом впустит от себя визитера,
[34:12.680 --> 34:21.560]  посетителя. То есть, первая реализация, которая у вас будет, это... Так, может быть, какой-нибудь код
[34:21.560 --> 34:34.440]  напишем? Какой код написать? Не, я сейчас это... Я сейчас какой-нибудь текст-эдитер открою.
[34:34.440 --> 34:41.560]  Ладно, ладно, сейчас подождите, тогда я вижу Studio Code, вырублю.
[34:41.560 --> 34:59.400]  Не, не, не. Так, ладно, давайте new files, ну, какой-нибудь. Да, у меня просто тут какие-то
[34:59.400 --> 35:14.280]  примеры, типа... Так, давайте open folder. Чего у нас с интернетом беда? А? Да я понимаю, что...
[35:14.280 --> 35:28.600]  Я знаю, так. Так, конечно, есть. Мне питона достаточно будет. Ну да, на питоне парадик...
[35:28.600 --> 35:32.760]  Ладно, давайте, короче, откроем текст в редактор, как бы...
[35:58.600 --> 36:15.880]  Сделаем проще. Так, давайте тогда... На каком языке напишем? Господи, ну, ладно. Ладно, давайте тогда...
[36:15.880 --> 36:32.520]  Да, давайте, значит, сначала напишем... О, проснулся, блин. Ну, все, adios. Давайте мы с вами даже
[36:32.520 --> 36:39.480]  напишем class main cpp, сначала file. И я просто опишу, собственно, последность действий,
[36:39.480 --> 36:45.080]  которые у нас есть. Допустим, мы с вами делаем какой-нибудь home. У нас будет с вами какой-то дом,
[36:45.080 --> 37:06.440]  у нас с вами будут к нему комнаты. Ага. Нет, периметр, визитер...
[37:15.960 --> 37:25.760]  Ну, для этого композита достаточно. Давайте, ладно, давайте как раз мы с классическим
[37:25.760 --> 37:38.680]  примером... home. Вы смотрите, мы создаем home. Да, кстати, home равно new. Да.
[37:45.080 --> 37:59.320]  Вот так вот сделаем. Так, давайте я здесь... Я напишу все в одном файле, простите меня. Значит,
[37:59.320 --> 38:06.920]  class element, собственно, он будет абстрактным. Давайте мы его так и обозначим. У него будет
[38:06.920 --> 38:18.520]  virtual void, void accept. Он будет принимать объект вида visitor. Соответственно, нам нужен этот
[38:18.520 --> 38:25.720]  class visitor сначала объявить, точнее, определить. Соответственно, у нас будет сначала class visitor.
[38:25.720 --> 38:42.760]  Нет, это объявление. Вот так вот, да, получается. Так, ладно, теперь смотрите, значит,
[38:42.760 --> 38:56.520]  у нас будет class home, public element. Значит, в нем будет у нас void accept. Так, что там?
[38:56.520 --> 39:05.200]  Это ассигнатура. Ну, собственно, здесь может быть разная вещь в зависимости от нашего элемента,
[39:05.200 --> 39:10.840]  допустим. То есть мы можем хранить какую-нибудь структуру, да, образно говоря.
[39:10.840 --> 39:23.880]  Да, и базовая реализация, на самом деле, нам нужно вызвать у этого visitor method-visit. Вот тебя.
[39:23.880 --> 39:35.200]  Внутрь visitor мы закладываем. То есть, если у нас теперь будет какой-то class visitor...
[39:35.200 --> 40:02.480]  Ну да, по факту, видите, accept нужно только для того, чтобы правильный экземпляр класса
[40:02.480 --> 40:14.720]  все переадресовать. Да, именно так. Значит, смотрите. А, я точку запятой забываю оставить.
[40:14.720 --> 40:20.720]  Значит, class visitor. Какие у него будут методы? А, блин, я всегда забываю, что эти методы публичными
[40:20.720 --> 40:36.320]  должны быть. Нет. Так, все, публичный. Значит, public. У него будет visit следующий, void visit,
[40:36.320 --> 40:45.800]  собственно. И тут мы определяем уже как раз от конкретного дома void visit, допустим, room.
[40:45.800 --> 41:00.800]  Значит, нам нужно еще classroom объявить. А мы его forward declare-нули. А, точно, точно,
[41:00.800 --> 41:28.600]  точно. Сейчас, собственно, да, согласен. Так, да.
[41:30.800 --> 41:46.800]  Да, да, конечно же. Я просто пишу в этом одном файле. По факту нам нужно делать forward declaration
[41:46.800 --> 42:00.720]  всех объектов, которые здесь есть. Да, да, да, конечно же. Конечно же мы понимаем,
[42:00.720 --> 42:05.720]  что нам нужен как раз кодогенератор здесь для того, чтобы не городить большое количество
[42:05.720 --> 42:19.520]  элементов. Так, значит, void accept visitor overwrite. О, господи, какой openCL? У нас курс не про это.
[42:19.520 --> 42:47.520]  А, да. Visit add this. Вот. Собственно, а теперь это, смотрите, значит, что мы можем сделать?
[42:47.520 --> 43:02.120]  Так, смотрите. Я, конечно, понимаю, что тут интересно. Так, у нас теперь появляется
[43:02.120 --> 43:21.320]  клад fillInVisitor. Собственно, у него теперь появляются два метода. Да, кстати, мы... Кто? Да.
[43:32.120 --> 43:47.320]  Ну, во-первых, да, во-вторых, мы можем его переиспользовать потом. Да, они вообще ничего не должны знать.
[43:47.320 --> 44:12.520]  Нет, методы добавлять это плохо. Опять же, если мы говорим про тот же самый swole, то у нас есть openClosePrinciple,
[44:12.520 --> 44:18.720]  который говорит, что неплохо... плохо будет добавлять методы, лучше наследоваться и переопределять убедение.
[44:18.720 --> 44:39.720]  Так, значит, смотрите, давайте мы напишем нашего, наконец-таки, homeVisitor, studentVisitor. Так, смотрите, overwrite.
[44:39.720 --> 44:51.920]  Представьте себе, что, образно говоря, student, он заходит в какое-то место. Да? Нет, он не должен прийти по комнатам.
[44:51.920 --> 44:59.920]  Так, ладно, давайте, короче, мы сделаем немножко другой кейс. Назовем наш класс не этот.
[45:09.920 --> 45:36.920]  Нет, все нормально. Да. Блин. Это да, это я согласен. Старенький я уже. Вот, вот так.
[45:37.120 --> 45:40.120]  Так, смотрите, а что означает, что у нас studentVisitor?
[45:44.120 --> 45:49.320]  Смотрите, значит, давайте у student я пока что сделаю следующую вещь.
[45:49.720 --> 46:00.720]  Собственно, у dormitory будет храниться какой-нибудь std-вектор. От чего? Chrome.
[46:02.720 --> 46:10.720]  Вот так вот. То есть, получается, у нас вот так должно быть. А, нет, у нас же forward declaration, нам ничего не надо это делать.
[46:10.720 --> 46:15.720]  Вот, то есть, видите, у нас есть список комнат. Так.
[46:19.720 --> 46:24.720]  Где? Room. Это Room.
[46:25.720 --> 46:33.720]  Собственно, смотрите, получается, у нас в доме есть общежитие. В нашей квартире есть общежитие.
[46:33.720 --> 46:39.720]  Ту-ту, блин, в нашем общежитии есть комнаты. Заговариваюсь.
[46:39.720 --> 46:45.720]  Вот. И дальше у нас с вами есть studentVisitor. Да?
[46:46.120 --> 46:50.120]  Ну, кажется, по-хорошему, надо вообще, говорим, делать не вектор комнаты, а вектор элементов.
[46:50.120 --> 46:53.120]  Потому что комнаты, наверное, будут работать у вектора типов.
[46:56.120 --> 47:00.120]  Да, ну, понятно, что мы поверх комнаты можем свое дерево наследование тоже потом сделать.
[47:00.120 --> 47:03.120]  Ну, по-хорошему говоря, да, вектор элементов.
[47:05.120 --> 47:08.120]  Ну, по крайней мере, если мы потом универили studentVisitor...
[47:08.120 --> 47:09.120]  Да.
[47:09.120 --> 47:12.120]  ...вот там у нас будет кодевой асколь класс.
[47:12.520 --> 47:15.520]  Согласен. Да, согласен.
[47:15.520 --> 47:18.520]  Вот, смотрите, то есть у нас получается вектор элемент rooms.
[47:18.520 --> 47:24.520]  А дальше, смотрите, studentVisitor. Что у него будет в атрибутах?
[47:24.520 --> 47:29.520]  У него, наверное, будет в атрибутах какой-нибудь, так, introom.
[47:32.520 --> 47:35.520]  То есть в какой комнате он живет?
[47:35.520 --> 47:40.520]  Нужно будет объявить сейчас какой-нибудь explicitInstructor.
[47:40.920 --> 47:47.920]  Explicit получается studentVisitor at introom.
[47:50.920 --> 47:51.920]  Вот так вот.
[47:51.920 --> 47:54.920]  Да, то есть у нас получается с вами studentVisitor, и он умеет комнату.
[47:54.920 --> 47:57.920]  Ну, и, соответственно, тогда что нам нужно сделать?
[47:57.920 --> 48:04.920]  Опять же, тут нам нужно будет dormitory rooms.
[48:05.320 --> 48:08.320]  At, получается, что?
[48:08.320 --> 48:10.320]  At нашу комнату.
[48:10.320 --> 48:12.320]  Accept.
[48:12.320 --> 48:15.320]  What's this?
[48:15.320 --> 48:17.320]  Так.
[48:17.320 --> 48:19.320]  Rooms at.
[48:19.320 --> 48:21.320]  Не room, а room.
[48:21.320 --> 48:24.320]  То есть он умеет заходить только в текущую...
[48:24.320 --> 48:27.320]  заходить только в свою комнату.
[48:27.720 --> 48:30.720]  Ну и давайте мы с вами
[48:30.720 --> 48:35.720]  в комнату напишем какой-нибудь std-out.
[48:35.720 --> 48:38.720]  Hooray from room.
[48:41.720 --> 48:43.720]  Как называется комната у нас?
[48:43.720 --> 48:45.720]  У нас что в комнате есть?
[48:45.720 --> 48:50.720]  А у нас ничего нет.
[48:50.720 --> 48:53.720]  Давайте назовем ее.
[48:54.120 --> 48:56.120]  Description.
[48:56.120 --> 48:59.120]  Вот, то есть мы создаем описание комнаты.
[49:03.120 --> 49:04.120]  Так.
[49:04.120 --> 49:07.120]  Которое мы можем даже с вами потом сделать.
[49:10.120 --> 49:13.120]  А, в комнате может быть интернет.
[49:13.120 --> 49:16.120]  Это я согласен, что в комнате может быть интернет.
[49:16.120 --> 49:19.120]  Но, как бы, это не может быть.
[49:19.120 --> 49:20.120]  Так.
[49:20.120 --> 49:22.120]  Explicit.
[49:22.120 --> 49:24.120]  Господи.
[49:24.120 --> 49:26.120]  Room.
[49:36.120 --> 49:39.120]  Вызываем конструктор копирования.
[49:41.120 --> 49:42.120]  Так.
[49:42.120 --> 49:44.120]  Вот, у нас комната есть.
[49:45.120 --> 49:47.120]  Так, вот, у нас комната есть.
[49:47.120 --> 49:50.120]  Давайте наконец-таки мы ClassMain напишем.
[49:56.120 --> 49:57.120]  Так, а что...
[49:57.120 --> 49:59.120]  А, я у стрима подключу.
[50:04.120 --> 50:07.120]  Так, вот смотрите, значит...
[50:07.120 --> 50:09.120]  Вот что у нас происходит.
[50:09.120 --> 50:11.120]  Значит, у нас есть HelloFromRoom.
[50:11.120 --> 50:13.120]  Значит, у нас есть HelloFromRoom.
[50:13.120 --> 50:16.120]  Собственно, теперь мы можем с вами сделать следующее.
[50:16.120 --> 50:17.120]  Элемент.
[50:17.120 --> 50:20.120]  Это у нас теперь dormitory.
[50:30.120 --> 50:31.120]  А, вот это?
[50:31.120 --> 50:33.120]  Да, без проблем.
[50:33.120 --> 50:35.120]  Вот, смотрите, то есть у нас dormitory.
[50:35.120 --> 50:38.120]  Дальше у нас dormitory...
[50:41.120 --> 50:42.120]  Не, подождите.
[50:42.120 --> 50:45.120]  Нам же нужно комнату вне сделать.
[51:03.120 --> 51:05.120]  Да, у нас vector.
[51:06.120 --> 51:08.120]  Так, dormitory.
[51:08.120 --> 51:10.120]  Что у нас?
[51:10.120 --> 51:14.120]  А, смотрите, нам домокастить нужно будет.
[51:18.120 --> 51:19.120]  Да.
[51:19.120 --> 51:23.120]  Да, здесь, к сожалению, нам нужно будет это...
[51:23.120 --> 51:24.120]  Вызвать вот так.
[51:24.120 --> 51:26.120]  А, все.
[51:27.120 --> 51:30.120]  Rooms, да, понятно, что мы как бы в конструкторе класса dormitory
[51:30.120 --> 51:33.120]  должны были передать элемент класса ClassMain.
[51:33.120 --> 51:34.120]  Что тут?
[51:34.120 --> 51:36.120]  Давайте...
[51:37.120 --> 51:38.120]  А?
[51:44.120 --> 51:45.120]  Да.
[51:48.120 --> 51:49.120]  Да.
[51:51.120 --> 51:53.120]  Room 1.
[51:53.120 --> 51:55.120]  А, description 1.
[51:55.120 --> 51:58.120]  NewRoom 2.
[51:58.120 --> 52:01.120]  NewRoom 3.
[52:02.120 --> 52:05.120]  NewRoom 3.
[52:05.120 --> 52:07.120]  Так, давайте их по номерам сделаем.
[52:07.120 --> 52:11.120]  То есть вот у нас, собственно, вот они комнаты у нас.
[52:15.120 --> 52:18.120]  Блин, это же а-ля джейсон, да.
[52:18.120 --> 52:21.120]  Значит, и теперь смотрите, что мы должны?
[52:21.120 --> 52:24.120]  Создать нашего StudentVisitor.
[52:24.120 --> 52:26.120]  Visitor.
[52:26.120 --> 52:36.120]  Верно, StudentVisitor равно NewStudentVisitor.
[52:36.120 --> 52:39.120]  Вот, давайте от первой комнаты.
[52:39.120 --> 52:41.120]  Чего ты ругаешься?
[52:41.120 --> 52:43.120]  Inaccessible.
[52:43.120 --> 52:45.120]  О, господи.
[52:45.120 --> 52:47.120]  Public.
[52:47.120 --> 52:49.120]  Вот мы его оставляем.
[52:49.120 --> 52:50.120]  Все.
[52:50.120 --> 52:52.120]  Ну и что, давайте посмотрим, как это работает.
[52:52.120 --> 52:55.120]  Значит, у нас с вами теперь dormitory.
[52:56.120 --> 52:59.120]  Должна принять нашего визитора.
[53:01.120 --> 53:03.120]  Все, давайте теперь запустим.
[53:03.120 --> 53:04.120]  Все.
[53:04.120 --> 53:06.120]  Через атлантчик запускать?
[53:09.120 --> 53:11.120]  Понятно, что можно сразу запустить.
[53:15.120 --> 53:16.120]  О, господи.
[53:16.120 --> 53:18.120]  Так, сейчас, секунду.
[53:18.120 --> 53:21.120]  У меня еще дебаггер неправильно стоит.
[53:21.120 --> 53:23.120]  Да, можно, на самом деле, сразу запустить.
[53:23.120 --> 53:25.120]  Опа, так.
[53:25.120 --> 53:27.120]  Что он говорит?
[53:28.120 --> 53:30.120]  Two Errors.
[53:37.120 --> 53:39.120]  Что он говорит?
[53:39.120 --> 53:42.120]  Ох, е-мое.
[53:42.120 --> 53:44.120]  Понятно.
[53:44.120 --> 53:46.120]  Так, ладно.
[53:46.120 --> 53:48.120]  Там с VS Code что-то.
[53:48.120 --> 53:50.120]  Да-да-да.
[53:54.120 --> 53:55.120]  О, господи.
[53:55.120 --> 53:57.120]  Так, а что он?
[53:57.120 --> 53:59.120]  Не забудьте функцию Main.
[53:59.120 --> 54:01.120]  Нет, я не забыл функцию Main.
[54:01.120 --> 54:03.120]  А, выкат передний был правильный.
[54:07.120 --> 54:09.120]  Все.
[54:09.120 --> 54:11.120]  Во, е.
[54:11.120 --> 54:13.120]  О, господи.
[54:14.120 --> 54:15.120]  Все.
[54:15.120 --> 54:16.120]  Во, е.
[54:16.120 --> 54:18.120]  Кажется, получилось.
[54:18.120 --> 54:20.120]  То есть у нас студент зашел только в свою комнату.
[54:23.120 --> 54:25.120]  Вот, то есть он...
[54:39.120 --> 54:40.120]  Да, вот, смотрите.
[54:40.120 --> 54:41.120]  Теперь вот второй студент.
[54:41.120 --> 54:43.120]  Он заходит во вторую комнату.
[54:53.120 --> 54:55.120]  Вот он.
[54:55.120 --> 54:57.120]  Two Errors.
[55:03.120 --> 55:04.120]  Во, все.
[55:04.120 --> 55:06.120]  Теперь зашел в вторую комнату.
[55:06.120 --> 55:08.120]  А теперь мы сделаем другого визитера.
[55:12.120 --> 55:15.120]  Я вам расскажу секретную тайну.
[55:21.120 --> 55:23.120]  До какого-то года это работало.
[55:29.120 --> 55:31.120]  Я скопировал.
[55:41.120 --> 55:43.120]  Во.
[55:51.120 --> 55:56.120]  То есть мы с вами создали титчер визитера, который теперь ходит по всем комнатам.
[55:56.120 --> 55:58.120]  С обходом.
[55:58.120 --> 56:00.120]  С каким-нибудь.
[56:00.120 --> 56:02.120]  Его можно как угодно назвать.
[56:02.120 --> 56:04.120]  Вот, и собственно...
[56:06.120 --> 56:08.120]  Типа того.
[56:08.120 --> 56:10.120]  Типа того.
[56:18.120 --> 56:20.120]  Это только на фистихе работает.
[56:22.120 --> 56:23.120]  Так.
[56:23.120 --> 56:25.120]  Dormitory.
[56:25.120 --> 56:31.120]  Да, кстати, я сразу скажу, что лучше вызывать именно от конкретного элемента Accept,
[56:31.120 --> 56:33.120]  а не визит от чего-то.
[56:33.120 --> 56:37.120]  Потому что мы с вами, допустим, когда построим синтоксическое дерево,
[56:37.120 --> 56:45.120]  на уровне языка промежуточного представления нам придется заходить не во всю программу целиком,
[56:45.120 --> 56:47.120]  а в каждый из фреймов по отдельности.
[56:47.120 --> 56:49.120]  Ну да.
[56:49.120 --> 56:51.120]  Так, teacher-vizitor.
[56:51.120 --> 56:53.120]  Вот, мы с вами запускаем teacher-vizitor.
[56:53.120 --> 56:55.120]  Надеюсь, компинируется это все.
[56:55.120 --> 56:56.120]  Вот.
[56:56.120 --> 56:58.120]  И вот, что делает teacher.
[56:58.120 --> 57:00.120]  Он зашел во все комнаты.
[57:00.120 --> 57:03.120]  В ответственно, если нам нужен какой-нибудь дополнительный еще визитер,
[57:03.120 --> 57:05.120]  то мы его купим.
[57:05.120 --> 57:07.120]  Вот.
[57:07.120 --> 57:09.120]  И вот.
[57:09.120 --> 57:11.120]  И вот.
[57:11.120 --> 57:13.120]  И вот.
[57:13.120 --> 57:16.120]  В ответственно, если нам нужен какой-нибудь дополнительный еще визитер,
[57:16.120 --> 57:18.120]  то мы его просто добавляем.
[57:18.120 --> 57:23.120]  Единственный недостаток этого подхода заключается в том,
[57:23.120 --> 57:28.120]  что если внезапно у вас происходит какой-то капитальный ремонт в общежитии,
[57:28.120 --> 57:32.120]  и у вас внезапно в общежитие добавляется какая-нибудь игровая комната,
[57:32.120 --> 57:35.120]  то что нужно будет переделывать?
[57:35.120 --> 57:38.120]  Надо переделать все визитеры.
[57:38.120 --> 57:41.120]  Да, нужно будет в визитерах добавить.
[57:41.120 --> 57:45.120]  У квадрона визитер...
[57:45.120 --> 57:48.120]  ...постоянно...
[57:48.120 --> 57:51.120]  ...переделывали всех визитеров.
[57:51.120 --> 57:53.120]  Да.
[57:53.120 --> 57:55.120]  Вот.
[57:55.120 --> 57:58.120]  И на самом деле есть еще одна вещь, которую я хочу сказать.
[57:58.120 --> 58:01.120]  Про это, наверное, мы с вами будем уже говорить на семинарах.
[58:01.120 --> 58:05.120]  Что визитер можно сделать тимплейтным пластом
[58:05.120 --> 58:07.120]  с помощью некоторого колхака.
[58:07.120 --> 58:09.120]  Но это лучше не делать.
[58:09.120 --> 58:12.120]  Это можно делать, но делается это неприятно,
[58:12.120 --> 58:17.120]  потому что нам все равно нужно будет возвращать некоторые элементы из дочернего узла.
[58:23.120 --> 58:25.120]  Да.
[58:25.120 --> 58:28.120]  Но это делать через костыли.
[58:39.120 --> 58:43.120]  ...помогает приезжать игроками...
[58:43.120 --> 58:46.120]  ...висели иконские иконские элементы...
[58:46.120 --> 58:48.120]  ...и они не двигаются.
[58:48.120 --> 58:50.120]  Да, а в предотвлении...
[58:50.120 --> 58:54.120]  ...когда едет новая шаблона, у тебя цикл включится до последнего шаблона.
[58:57.120 --> 59:00.120]  ...выбрали иконский цикл...
[59:00.120 --> 59:03.120]  ...выбрали иконский цикл...
[59:03.120 --> 59:06.120]  ...выбрали иконский цикл...
[59:06.120 --> 59:08.120]  Так, что?
[59:08.120 --> 59:11.120]  ...выбрали иконский цикл...
[59:11.120 --> 59:14.120]  ...выбрали иконский цикл...
[59:14.120 --> 59:17.120]  ...выбрали иконский цикл...
[59:17.120 --> 59:20.120]  Так, ну я думаю, что это мы пройдем дальше.
[59:20.120 --> 59:23.120]  Давайте я спрошу, понятен ли суть паттерна визитер?
[59:25.120 --> 59:27.120]  Хорошо.
[59:27.120 --> 59:29.120]  Итак, смотрите.
[59:29.120 --> 59:31.120]  И здесь мы начинаем наконец-таки...
[59:31.120 --> 59:34.120]  У нас теперь есть некоторая сущность, которая нам позволяет
[59:34.120 --> 59:37.120]  обходить абстрактное синтоксическое дерево разбора.
[59:37.120 --> 59:38.120]  Да?
[59:38.120 --> 59:41.120]  Подчеркну. То есть дальше, на самом деле, мы будем с вами
[59:41.120 --> 59:44.120]  работать с такими понятиями, как...
[59:47.120 --> 59:50.120]  ...таблицы символов, нам нужно будет хранить
[59:50.120 --> 59:53.120]  систему выводов типов и так далее.
[59:53.120 --> 59:56.120]  И для каждой из этих вещей как раз нам нужно будет делать
[59:56.120 --> 59:59.120]  свои собственные визитеры, объекты типа визитера.
[59:59.120 --> 01:00:02.120]  Первое, что мы с вами можем сделать поверх этого визитера,
[01:00:02.120 --> 01:00:05.120]  это, допустим, само абстрактное синтоксическое дерево распечатать.
[01:00:05.120 --> 01:00:09.120]  А, собственно, суть второго задания, которое у нас есть.
[01:00:11.120 --> 01:00:14.120]  А теперь нам нужны таблицы символов.
[01:00:14.120 --> 01:00:17.120]  Эта структура данных, которая позволяет отслеживать
[01:00:17.120 --> 01:00:20.120]  набор атрибута по имени токена.
[01:00:20.120 --> 01:00:23.120]  Давайте поймем, что нам нужно от таблицы символов.
[01:00:23.120 --> 01:00:26.120]  Ну, да, каким-то образом держать скопы.
[01:00:26.120 --> 01:00:29.120]  Что такое скопы? Это область видимости.
[01:00:29.120 --> 01:00:32.120]  То есть у нас есть переменные, допустим, А, и в внутреннем скопе
[01:00:32.120 --> 01:00:35.120]  мы еще раз объявили переменную А.
[01:00:35.120 --> 01:00:38.120]  Это мы должны с вами поддерживать.
[01:00:38.120 --> 01:00:41.120]  Да, пока что, если мы храним это в общем месте,
[01:00:41.120 --> 01:00:44.120]  то это будет не очень...
[01:00:44.120 --> 01:00:47.120]  ...выгодно.
[01:00:47.120 --> 01:00:50.120]  Ну, да.
[01:00:50.120 --> 01:00:53.120]  То есть, смотрите, здесь как раз надо будет уметь,
[01:00:53.120 --> 01:00:56.120]  значит, во-первых, строить эту таблицу.
[01:00:56.120 --> 01:00:59.120]  Опять же, сразу скажу, что таблица символов не воспринимает
[01:00:59.120 --> 01:01:02.120]  ее чисто как таблицу.
[01:01:02.120 --> 01:01:05.120]  Вот это вот такое есть важное отличие.
[01:01:08.120 --> 01:01:11.120]  Смотрите, здесь есть два подхода к построению.
[01:01:11.120 --> 01:01:14.120]  Один подход – это дерево таблиц.
[01:01:14.120 --> 01:01:17.120]  А второй подход – это дерево таблиц.
[01:01:17.120 --> 01:01:20.120]  А второй подход, который есть, это на самом деле
[01:01:20.120 --> 01:01:23.120]  хешмап от стеков.
[01:01:27.120 --> 01:01:30.120]  Стеков.
[01:01:30.120 --> 01:01:33.120]  Как только мы заходим в какой-то скоп,
[01:01:33.120 --> 01:01:36.120]  мы по факту этот новый скоп умулируем тем,
[01:01:36.120 --> 01:01:39.120]  что мы будем на стек добавлять определенные элементы.
[01:01:39.120 --> 01:01:42.120]  В самом деле это стек,
[01:01:42.120 --> 01:01:45.120]  который будет еще в этом скопе,
[01:01:45.120 --> 01:01:48.120]  а стек, который будет еще в этом хешмапе,
[01:01:48.120 --> 01:01:51.120]  значит, от строки в дюкте.
[01:01:51.120 --> 01:01:54.120]  Да, давайте как раз
[01:01:54.120 --> 01:01:57.120]  тоже это все рассмотрим.
[01:02:02.120 --> 01:02:05.120]  Давайте я сразу в код тогда
[01:02:05.120 --> 01:02:08.120]  прыгну. Вот, смотрите, вот она функция,
[01:02:08.120 --> 01:02:11.120]  допустим, у нас.
[01:02:11.120 --> 01:02:14.120]  Вот у нас, смотрите, есть класс на джаве,
[01:02:14.120 --> 01:02:17.120]  блин, мне надо переделать.
[01:02:17.120 --> 01:02:20.120]  Да.
[01:02:20.120 --> 01:02:23.120]  И у нас есть функция тестов n от переменной b.
[01:02:23.120 --> 01:02:26.120]  Значит, что у нас с вами
[01:02:26.120 --> 01:02:29.120]  здесь должно быть? У нас с вами, собственно,
[01:02:29.120 --> 01:02:32.120]  есть несколько скопов. Первый скоп – это
[01:02:32.120 --> 01:02:35.120]  глобальный скоп, в котором
[01:02:35.120 --> 01:02:38.120]  у нас доступны списки всех классов.
[01:02:38.120 --> 01:02:41.120]  Дальше у нас внутри скопов, связанных с классом,
[01:02:41.120 --> 01:02:44.120]  какой скоп следующий будет?
[01:02:48.120 --> 01:02:51.120]  Функции и методов нашего класса.
[01:02:51.120 --> 01:02:54.120]  Ой, методов и полей нашего
[01:02:54.120 --> 01:02:57.120]  класса. Дальше мы с вами,
[01:02:57.120 --> 01:03:00.120]  когда заходим еще в один скоп, то что у нас
[01:03:00.120 --> 01:03:03.120]  с вами получается? У нас с вами появляются
[01:03:03.120 --> 01:03:06.120]  значения переменных. Во-первых, b переменная,
[01:03:06.120 --> 01:03:09.120]  и во-вторых, у нас дальше идут еще
[01:03:09.120 --> 01:03:12.120]  именованные, то есть у нас могут быть именованные
[01:03:12.120 --> 01:03:15.120]  скопы, которые обозначаются явными методами,
[01:03:15.120 --> 01:03:18.120]  а есть у нас занумерованные скопы. Что такое
[01:03:18.120 --> 01:03:21.120]  занумерованные скопы? Это мы включаем какие-то
[01:03:21.120 --> 01:03:24.120]  блокчные инструкции, дальше мы их с вами можем
[01:03:24.120 --> 01:03:27.120]  набирать. У нас внутри одной функции может большое быть количество
[01:03:27.120 --> 01:03:30.120]  EFOP или каких-то больших и больших структур. То есть мы с вами
[01:03:30.120 --> 01:03:33.120]  должны уметь с ними работать для того, чтобы
[01:03:33.120 --> 01:03:36.120]  переменную b. Значит, что нам нужно отслеживать
[01:03:36.120 --> 01:03:39.120]  в скопе? Чтобы мы в текущем скопе не объявили
[01:03:39.120 --> 01:03:42.120]  ту же самую переменную,
[01:03:42.120 --> 01:03:45.120]  это раз. Во-вторых, если мы используем
[01:03:45.120 --> 01:03:48.120]  какую-то переменную, то она у нас вообще
[01:03:48.120 --> 01:03:51.120]  где-то объявлена была.
[01:03:51.120 --> 01:03:54.120]  И здесь мы как раз можем написать подобный код.
[01:03:54.120 --> 01:03:57.120]  Давайте я его тоже сейчас
[01:03:57.120 --> 01:04:00.120]  быстро накидаю. Здесь
[01:04:00.120 --> 01:04:03.120]  scopes.cpp.
[01:04:03.120 --> 01:04:06.120]  Смотрите. Допустим, у нас есть int x
[01:04:06.120 --> 01:04:09.120]  равно нулю, x1.
[01:04:09.120 --> 01:04:12.120]  Дальше у нас есть функция main. x равно двойке.
[01:04:12.120 --> 01:04:15.120]  If x больше пятерки,
[01:04:15.120 --> 01:04:18.120]  int y равно
[01:04:18.120 --> 01:04:21.120]  тройке. Там int x равно
[01:04:21.120 --> 01:04:24.120]  четверть.
[01:04:24.120 --> 01:04:27.120]  Else
[01:04:27.120 --> 01:04:30.120]  int x равно пятерке.
[01:04:30.120 --> 01:04:33.120]  Вот давайте так. x равно пятерке,
[01:04:33.120 --> 01:04:36.120]  y равно тройке.
[01:04:36.120 --> 01:04:39.120]  Этот код
[01:04:39.120 --> 01:04:42.120]  скомпилируется.
[01:04:42.120 --> 01:04:45.120]  Если я не допустил никаких синтоксических ошибок.
[01:04:45.120 --> 01:04:48.120]  Я надеюсь, что я не допустил.
[01:04:48.120 --> 01:04:51.120]  А я его не допустил, да?
[01:04:51.120 --> 01:04:54.120]  Но в чем проблема этого кода?
[01:04:54.120 --> 01:04:57.120]  Проблема в коде
[01:04:57.120 --> 01:05:00.120]  с точки зрения компилятора.
[01:05:00.120 --> 01:05:03.120]  Да, куча шейдувингов
[01:05:03.120 --> 01:05:06.120]  переменных.
[01:05:06.120 --> 01:05:09.120]  И смотрите, как мы это можем хранить.
[01:05:09.120 --> 01:05:12.120]  На самом деле мы можем
[01:05:12.120 --> 01:05:15.120]  создать некоторую структуру,
[01:05:15.120 --> 01:05:18.120]  в которой будем хранить наши переменные.
[01:05:18.120 --> 01:05:21.120]  Это си получится.
[01:05:21.120 --> 01:05:24.120]  Поэтому в си на самом деле переменные
[01:05:24.120 --> 01:05:27.120]  объявляются вначале функция.
[01:05:27.120 --> 01:05:30.120]  Ну 89 стандарта.
[01:05:30.120 --> 01:05:33.120]  В 99 уже можно в любом месте объявлять.
[01:05:33.120 --> 01:05:36.120]  Да.
[01:05:36.120 --> 01:05:39.120]  Вот.
[01:05:39.120 --> 01:05:42.120]  Вот.
[01:05:42.120 --> 01:05:45.120]  Вот.
[01:05:45.120 --> 01:05:48.120]  Да.
[01:05:51.120 --> 01:05:54.120]  Ну, можем на паскале писать.
[01:05:54.120 --> 01:05:57.120]  А?
[01:05:57.120 --> 01:06:00.120]  Или на фортране.
[01:06:00.120 --> 01:06:03.120]  Давайте расскажу ту структуру,
[01:06:03.120 --> 01:06:06.120]  которую мы зачастую будем пользоваться.
[01:06:06.120 --> 01:06:09.120]  Чтобы было уже для практики.
[01:06:09.120 --> 01:06:12.120]  Мы заводим специальный стэк.
[01:06:12.120 --> 01:06:15.120]  Определенных символов.
[01:06:15.120 --> 01:06:18.120]  В которых мы будем хранить некоторые значения.
[01:06:18.120 --> 01:06:21.120]  Фиксированные значения.
[01:06:21.120 --> 01:06:24.120]  И дополнительно мы с вами будем обходить
[01:06:24.120 --> 01:06:27.120]  это все дело в общем.
[01:06:27.120 --> 01:06:30.120]  Смотрите, какие у нас скопы будут здесь.
[01:06:30.120 --> 01:06:33.120]  У нас будет скоп глобальный,
[01:06:33.120 --> 01:06:36.120]  в котором будет переменная х,
[01:06:36.120 --> 01:06:39.120]  равная нулю.
[01:06:39.120 --> 01:06:42.120]  Дальше у нас будет скоп под названием main.
[01:06:42.120 --> 01:06:45.120]  Внутри которого...
[01:06:45.120 --> 01:06:48.120]  Что у нас будет с вами?
[01:06:48.120 --> 01:06:51.120]  Какие переменные у нас объявляются
[01:06:51.120 --> 01:06:54.120]  в скопе внутри функции main?
[01:06:54.120 --> 01:06:57.120]  А?
[01:06:57.120 --> 01:07:00.120]  Никакие, да.
[01:07:00.120 --> 01:07:03.120]  А дальше мы объявляем два скопа.
[01:07:03.120 --> 01:07:06.120]  Значит скоп решетка 0.
[01:07:06.120 --> 01:07:09.120]  Вот.
[01:07:09.120 --> 01:07:12.120]  А в скопе решетка 1
[01:07:12.120 --> 01:07:15.120]  у нас будет объявляться переменная какая?
[01:07:15.120 --> 01:07:18.120]  У.
[01:07:18.120 --> 01:07:21.120]  Вот такая вот вещь.
[01:07:21.120 --> 01:07:24.120]  И соответственно нам нужно в этой структуре
[01:07:24.120 --> 01:07:27.120]  в каждый момент времени
[01:07:27.120 --> 01:07:30.120]  понимать следующее, что если мы обращаемся
[01:07:30.120 --> 01:07:33.120]  к переменной х, то к какой из переменных х
[01:07:33.120 --> 01:07:36.120]  мы с вами обращаемся.
[01:07:36.120 --> 01:07:39.120]  Для этого... А?
[01:07:39.120 --> 01:07:42.120]  А что такое последнее?
[01:07:42.120 --> 01:07:45.120]  Да, та, которая выше на стэке.
[01:07:45.120 --> 01:07:48.120]  Поэтому, чтобы это сэмулировать,
[01:07:48.120 --> 01:07:51.120]  мы с вами будем создавать общий массив
[01:07:51.120 --> 01:07:54.120]  hashMap из элементов.
[01:07:54.120 --> 01:07:57.120]  Это на самом деле
[01:07:57.120 --> 01:08:00.120]  обход для интерпретатора и для построения
[01:08:00.120 --> 01:08:03.120]  любой структуры.
[01:08:03.120 --> 01:08:06.120]  У нас появляются три объекта в видах main.xy.
[01:08:06.120 --> 01:08:09.120]  И дальше мы делаем следующее.
[01:08:09.120 --> 01:08:12.120]  У нас будет общий стэк,
[01:08:12.120 --> 01:08:15.120]  который объявляет. У нас первое объявление
[01:08:15.120 --> 01:08:18.120]  идет переменная х.
[01:08:18.120 --> 01:08:21.120]  Давайте я буду звездочка 1,
[01:08:21.120 --> 01:08:24.120]  звездочка 2,
[01:08:24.120 --> 01:08:27.120]  звездочка 3, звездочка 4, звездочка 5.
[01:08:27.120 --> 01:08:30.120]  Я их буду писать.
[01:08:30.120 --> 01:08:33.120]  Когда у нас появляется х равно 1,
[01:08:33.120 --> 01:08:36.120]  мы кладем сюда звездочку 1.
[01:08:36.120 --> 01:08:39.120]  И этот х тоже звездочка 1.
[01:08:39.120 --> 01:08:42.120]  Дальше у нас встречается функция main.
[01:08:42.120 --> 01:08:45.120]  Это будет решетка звездочка 2.
[01:08:45.120 --> 01:08:48.120]  А дальше мы делаем хитрое.
[01:08:48.120 --> 01:08:51.120]  Мы пишем, что вот у нас main.
[01:08:51.120 --> 01:08:54.120]  Он ссылается на звездочку 2.
[01:08:54.120 --> 01:08:57.120]  И в этом времени мы делаем следующее.
[01:08:57.120 --> 01:09:00.120]  У нас открывается новый скоп
[01:09:00.120 --> 01:09:03.120]  при анализе нашего кода.
[01:09:03.120 --> 01:09:06.120]  Поэтому давайте мы добавим специальный символ,
[01:09:06.120 --> 01:09:09.120]  открывающийся в кнопке,
[01:09:09.120 --> 01:09:12.120]  который по факту будет храниться на стэке
[01:09:12.120 --> 01:09:15.120]  чисто для того, чтобы отсигнализироваться,
[01:09:15.120 --> 01:09:18.120]  когда нам нужно отсоединить этот скоп.
[01:09:18.120 --> 01:09:21.120]  Дальше у нас скоп-решетка 0 идет.
[01:09:22.120 --> 01:09:25.120]  Вот смотрите, мы дошли до сюда
[01:09:25.120 --> 01:09:28.120]  и парсим программу.
[01:09:28.120 --> 01:09:31.120]  И тогда каким образом получить значение переменной х?
[01:09:31.120 --> 01:09:34.120]  Нам нужно посмотреть на вершину стэка
[01:09:34.120 --> 01:09:37.120]  соответствующей данной переменной.
[01:09:52.120 --> 01:09:55.120]  Вот так, допустим.
[01:10:16.120 --> 01:10:19.120]  Пока мы про функции.
[01:10:22.120 --> 01:10:25.120]  Ну смотрите, мы можем для каждого фрейма
[01:10:25.120 --> 01:10:28.120]  по отдельности тоже соотносить эти объекты.
[01:10:28.120 --> 01:10:31.120]  То есть мы запрыгиваем...
[01:10:31.120 --> 01:10:34.120]  Эта структура является в смысле динамической структурой.
[01:10:34.120 --> 01:10:37.120]  То есть когда мы обходим код этих объектов,
[01:10:37.120 --> 01:10:40.120]  мы их можем хранить в отдельной сущности
[01:10:40.120 --> 01:10:43.120]  и их использовать.
[01:10:43.120 --> 01:10:46.120]  Я согласен, что здесь не будет общей древовидной структуры,
[01:10:46.120 --> 01:10:49.120]  потому что у нас тут объекты тоже будут выкидываться
[01:10:49.120 --> 01:10:52.120]  из этой структуры.
[01:10:52.120 --> 01:10:55.120]  Так, смотрите, дальше у нас идет решетка 0,
[01:10:55.120 --> 01:10:58.120]  мы добавляем элемент.
[01:10:58.120 --> 01:11:01.120]  После этого у нас встречается переменная х
[01:11:01.120 --> 01:11:04.120]  с решеткой 3
[01:11:04.120 --> 01:11:07.120]  и переменная у с решеткой 4.
[01:11:14.120 --> 01:11:17.120]  А потом у нас происходит следующее.
[01:11:17.120 --> 01:11:20.120]  Закрыть скоп.
[01:11:20.120 --> 01:11:23.120]  Каким образом мы с вами закрываем скоп?
[01:11:23.120 --> 01:11:26.120]  Есть у кого и мысли?
[01:11:26.120 --> 01:11:29.120]  Да, снимаем все, что идет с токена скопка
[01:11:29.120 --> 01:11:32.120]  и снимаем эти объекты.
[01:11:32.120 --> 01:11:35.120]  Опять же, если мы говорим про объекты каких-то классов,
[01:11:35.120 --> 01:11:38.120]  то, грубо говоря, когда мы будем транслировать
[01:11:38.120 --> 01:11:41.120]  в промежуточное представление,
[01:11:41.120 --> 01:11:44.120]  нам нужно будет вызвать деструкторы этих классов.
[01:11:44.120 --> 01:11:47.120]  То есть все, что у нас есть,
[01:11:47.120 --> 01:11:50.120]  вы деструкторы конкретных классов.
[01:11:50.120 --> 01:11:53.120]  Опять же, на уровне кодегена что у нас происходит.
[01:11:53.120 --> 01:11:56.120]  Опять же, когда мы генерируем код для определенного фрейма,
[01:11:56.120 --> 01:11:59.120]  то мы можем зайти именно в конкретный скоп конкретного фрейма
[01:11:59.120 --> 01:12:02.120]  и это все проанализировать.
[01:12:02.120 --> 01:12:05.120]  Естественно, здесь мы говорим, что наша структура
[01:12:05.120 --> 01:12:08.120]  является динамической,
[01:12:08.120 --> 01:12:11.120]  она не будет являться статической.
[01:12:11.120 --> 01:12:14.120]  И если у нас структура является вот такой,
[01:12:14.120 --> 01:12:17.120]  то в принципе этого хватает.
[01:12:17.120 --> 01:12:20.120]  И на самом деле, на практике, скажу честно,
[01:12:20.120 --> 01:12:23.120]  что вот такая вот самая простенькая структура,
[01:12:23.120 --> 01:12:26.120]  ее вполне хватает для того, чтобы полностью проанализировать наш код.
[01:12:26.120 --> 01:12:29.120]  Вторая вещь, которая здесь есть,
[01:12:29.120 --> 01:12:32.120]  которую мы можем использовать,
[01:12:32.120 --> 01:12:35.120]  это использовать немного другой подход,
[01:12:35.120 --> 01:12:38.120]  который у нас имеется,
[01:12:38.120 --> 01:12:41.120]  то есть у нас получается,
[01:12:41.120 --> 01:12:44.120]  есть глобальный скоп, в нем будет функция ScopeExample,
[01:12:44.120 --> 01:12:47.120]  и дальше мы делаем следующее.
[01:12:47.120 --> 01:12:50.120]  Вот у нас появляется класс определенный под названием ScopeExample,
[01:12:50.120 --> 01:12:53.120]  а потом внутри скопа GlobalExample
[01:12:53.120 --> 01:12:56.120]  у нас появляется TestFN.
[01:12:56.120 --> 01:12:59.120]  Соответственно, нам иногда полезно хранить полные модификаторы,
[01:12:59.120 --> 01:13:02.120]  которые у нас есть,
[01:13:02.120 --> 01:13:05.120]  то есть для того, чтобы мы глобальному модификатору с вами могли обратиться,
[01:13:05.120 --> 01:13:08.120]  у нас появляется TestFN.
[01:13:08.120 --> 01:13:11.120]  Дальше, внутри этого у нас в Scope,
[01:13:11.120 --> 01:13:14.120]  под названием ScopeExampleTestFN,
[01:13:14.120 --> 01:13:17.120]  появляется переменная B,
[01:13:17.120 --> 01:13:20.120]  и у нас появляется как раз у метода,
[01:13:20.120 --> 01:13:23.120]  собственно, в самой таблице всего,
[01:13:23.120 --> 01:13:26.120]  у нас появляется intB и returnInt.
[01:13:26.120 --> 01:13:29.120]  И вот в такой структуре, если вам нужно обращаться
[01:13:29.120 --> 01:13:32.120]  к какому-то объекту,
[01:13:32.120 --> 01:13:35.120]  мы с вами вполне можем получить,
[01:13:35.120 --> 01:13:38.120]  когда мы к нему обращаемся.
[01:13:38.120 --> 01:13:41.120]  Если вам нужно хранить, допустим, что-то за пределами этого скопа.
[01:13:41.120 --> 01:13:44.120]  То есть у этого X будет полный модификатор,
[01:13:44.120 --> 01:13:47.120]  Main$0,
[01:13:47.120 --> 01:13:50.120]  решетка 0, X.
[01:13:50.120 --> 01:13:53.120]  Все, да. А главное,
[01:13:53.120 --> 01:13:56.120]  после этого код не перестраивать,
[01:13:56.120 --> 01:13:59.120]  потому что иначе индексация вся полетит.
[01:13:59.120 --> 01:14:02.120]  Мы пока здесь не говорим про оптимизацию,
[01:14:02.120 --> 01:14:05.120]  поэтому, в принципе, здесь нам...
[01:14:14.120 --> 01:14:17.120]  Нет, это будет плохо.
[01:14:17.120 --> 01:14:20.120]  Ну, это да.
[01:14:20.120 --> 01:14:23.120]  Главное только понимать для каждой переменной,
[01:14:23.120 --> 01:14:26.120]  какой именно переменной мы обращаемся.
[01:14:26.120 --> 01:14:29.120]  А, да.
[01:14:29.120 --> 01:14:32.120]  Ну, в целом, да.
[01:14:32.120 --> 01:14:35.120]  А это как раз потом и происходит,
[01:14:35.120 --> 01:14:38.120]  когда мы переходим в VR,
[01:14:38.120 --> 01:14:41.120]  когда говорим, что у нас аналог SSA,
[01:14:41.120 --> 01:14:44.120]  стандартный аналог,
[01:14:44.120 --> 01:14:47.120]  когда по факту каждый виртуальный регистр
[01:14:47.120 --> 01:14:50.120]  будет назначаться с новому значению.
[01:14:53.120 --> 01:14:56.120]  Любой.
[01:14:56.120 --> 01:14:59.120]  То есть там есть инты, флоты.
[01:14:59.120 --> 01:15:02.120]  Там прям четкий тип.
[01:15:02.120 --> 01:15:05.120]  Если есть инт, то там инт есть 32,
[01:15:05.120 --> 01:15:08.120]  есть инт 64, есть инт 17, 33 и так далее.
[01:15:08.120 --> 01:15:11.120]  Если мы...
[01:15:11.120 --> 01:15:14.120]  Да, инт-1, это бул.
[01:15:14.120 --> 01:15:17.120]  Там есть структура, там есть массивы,
[01:15:17.120 --> 01:15:20.120]  там есть структура.
[01:15:20.120 --> 01:15:23.120]  Да, про LV мы говорим.
[01:15:26.120 --> 01:15:29.120]  Вот, собственно, а здесь мы как раз получаем
[01:15:29.120 --> 01:15:32.120]  полный идентификатор имени,
[01:15:32.120 --> 01:15:35.120]  про который мы с вами говорили.
[01:15:35.120 --> 01:15:38.120]  Значит, тут, в принципе,
[01:15:38.120 --> 01:15:41.120]  это как раз пример презентации нашей.
[01:15:41.120 --> 01:15:44.120]  Собственно, что мы с вами успели посмотреть?
[01:15:44.120 --> 01:15:47.120]  Мы с вами сегодня посмотрели таблицу символов,
[01:15:47.120 --> 01:15:50.120]  как строить в первом варианте.
[01:15:50.120 --> 01:15:53.120]  Значит, пока что это именно, так сказать,
[01:15:53.120 --> 01:15:56.120]  свежая история, которая нам полезна.
[01:15:56.120 --> 01:15:59.120]  На семинарах мы сегодня с вами будем говорить
[01:15:59.120 --> 01:16:02.120]  про именно ER и посмотрим как раз
[01:16:02.120 --> 01:16:05.120]  визитор, как можно строить.
[01:16:05.120 --> 01:16:08.120]  Мы пишем простой пример нашего кода на ER,
[01:16:08.120 --> 01:16:11.120]  то есть на языке ER.
[01:16:11.120 --> 01:16:14.120]  Посмотрим, как он пишется, код ER,
[01:16:14.120 --> 01:16:17.120]  а дальше попытаемся его встроить в конкретный визитор.
[01:16:17.120 --> 01:16:20.120]  Вот это план на наш сегодняшний семинар.
[01:16:20.120 --> 01:16:23.120]  Так, давайте вопросу.
[01:16:26.120 --> 01:16:29.120]  Ну и тут как раз у нас логично получится,
[01:16:29.120 --> 01:16:32.120]  что когда мы код напишем на ER, у вас будет как раз время
[01:16:32.120 --> 01:16:35.120]  порядка двух недель, чтобы освоиться вопрос, поздавать и так далее.
[01:16:51.120 --> 01:16:53.120]  Все тогда, спасибо.
