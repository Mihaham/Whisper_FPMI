[00:00.000 --> 00:15.600]  Ну, раз уж у нас, блин, нет, мне все-таки как-то вот,
[00:15.600 --> 00:17.320]  вот эта доска больше нравится.
[00:17.320 --> 00:21.440]  Раз уж у нас разговор про связанные списки идет,
[00:21.440 --> 00:27.840]  было бы грех не упомянуть пару популярных задач про
[00:27.840 --> 00:28.840]  связанные списки.
[00:28.840 --> 00:31.800]  Потому что, насколько я знаю, в курсе алгоритмов вам про
[00:31.800 --> 00:32.800]  их не рассказывают.
[00:32.800 --> 00:38.680]  Филипп, во всяком случае, никогда не упоминает.
[00:38.680 --> 00:39.680]  Полезного.
[00:39.680 --> 00:40.680]  Полезного.
[00:40.680 --> 00:47.680]  Что у тебя полезная вероятность алгоритма в процентные числа?
[00:47.680 --> 00:50.680]  Очень полезно, Старк.
[00:50.680 --> 00:52.800]  Ну вот и сети там стоят.
[00:52.800 --> 00:53.800]  Это какая вероятность?
[00:53.800 --> 00:54.800]  Которая Милера Рабина?
[00:54.800 --> 00:55.800]  Нет.
[00:55.800 --> 00:56.800]  Которая Роболла, да.
[00:56.800 --> 00:57.800]  А-а.
[00:58.760 --> 01:01.760]  Он вероятностный, разве?
[01:01.760 --> 01:04.680]  Нет, Роболла, да, это по сути тоже.
[01:04.680 --> 01:05.680]  Ну, сейчас.
[01:05.680 --> 01:08.680]  Тоже вероятностный, тоже связан с процентными числами,
[01:08.680 --> 01:11.680]  поэтому мой мозг сказал мне, что я трак.
[01:11.680 --> 01:12.680]  Извини.
[01:12.680 --> 01:13.680]  А, да, точно.
[01:13.680 --> 01:16.680]  Я забыл, что он вероятностный.
[01:16.680 --> 01:22.360]  Так, короче, есть такие две очень популярные задачи.
[01:22.360 --> 01:24.240]  Я не знаю, что делать с этой тряпкой, потому что мне
[01:24.240 --> 01:25.240]  ее не хватит.
[01:25.240 --> 01:32.080]  На самом деле, вот это отвратительно.
[01:32.080 --> 01:34.680]  Вот такие люди, которые рисуют это, маркер же садится
[01:34.680 --> 01:35.680]  из-за этого.
[01:35.680 --> 01:36.960]  Вот надо же было столько маркера и стратить вот на
[01:36.960 --> 01:37.960]  такую ерунду.
[01:37.960 --> 01:38.960]  Ну безобразно.
[01:38.960 --> 01:45.720]  Есть такая известная задача, называется найдите цикл
[01:45.720 --> 01:46.720]  в списке.
[01:46.720 --> 01:50.360]  Вот, кстати, Ро Поларда алгоритм связан с ней, наверное,
[01:50.360 --> 01:51.360]  вы знаете.
[01:51.360 --> 01:55.160]  Да, вот как такое делать?
[01:56.080 --> 02:01.400]  Да, у вас есть односвязанный список.
[02:01.400 --> 02:11.320]  Ну, вам дана голова, да, и в нодах хранится int-value
[02:11.320 --> 02:13.800]  и нод-звездочка next.
[02:13.800 --> 02:17.040]  Кто знает молчать?
[02:17.040 --> 02:20.480]  Ну ты знаешь, по всей видимости.
[02:21.480 --> 02:28.360]  Вот, ну нужно понять, зациклен ли этот список и если зациклен,
[02:28.360 --> 02:30.560]  то с какого места начинается цикл.
[02:30.560 --> 02:33.080]  Такая очень известная задача.
[02:33.080 --> 02:36.480]  Я бы сказал, что ее часто дают на собеседованиях,
[02:36.480 --> 02:38.680]  но на самом деле даже это неправда, потому что она
[02:38.680 --> 02:40.240]  настолько известная, что ее даже на собеседованиях
[02:40.240 --> 02:41.240]  уже не дают.
[02:41.240 --> 02:44.640]  Ну потому что если ее дать на собеседования, то любой
[02:44.640 --> 02:47.640]  нормальный человек должен сразу сказать, как она решается.
[02:47.640 --> 02:48.640]  Ну типа это.
[02:49.640 --> 02:53.640]  Ну а кто уже знает, как это делать?
[02:53.640 --> 02:56.640]  Ну без допамяти.
[02:56.640 --> 02:58.640]  Ну, тогда начинать.
[02:58.640 --> 02:59.640]  Отъединить цикл.
[02:59.640 --> 03:01.640]  О, отъединить с допамяти, да.
[03:01.640 --> 03:06.640]  Понятно проблема, но очевидно, что не хочется там вот,
[03:06.640 --> 03:08.640]  скажем так, не за квадрат, чтобы было.
[03:08.640 --> 03:09.640]  И не за n-log.
[03:09.640 --> 03:11.640]  И не за n-log, да.
[03:12.640 --> 03:13.640]  Че?
[03:18.640 --> 03:19.640]  Да.
[03:19.640 --> 03:23.640]  Ну давайте, кто знает, расскажите, не хочется на этом застревать,
[03:23.640 --> 03:25.640]  просто чтоб все знали.
[03:25.640 --> 03:26.640]  В какую?
[03:26.640 --> 03:28.640]  В начальную, да.
[03:28.640 --> 03:29.640]  Да, вот.
[03:31.640 --> 03:32.640]  Ну я…
[03:36.640 --> 03:38.640]  Чего пройдем n?
[03:39.640 --> 03:41.640]  Ну количество вообще не дано.
[03:45.640 --> 03:46.640]  Да.
[03:49.640 --> 03:50.640]  Да.
[03:51.640 --> 03:52.640]  Да, значит…
[03:54.640 --> 03:55.640]  Мы…
[03:58.640 --> 04:03.640]  Да, мы делаем цикл, другой, сфорк делаем, короче, цикл.
[04:03.640 --> 04:07.640]  И там каждый шаг, этот задвигаем на один, а этот на два.
[04:08.640 --> 04:14.640]  И когда мы дойдем до цикла, мы…
[04:15.640 --> 04:19.640]  Ну либо кто-то из них дойдет до конца,
[04:21.640 --> 04:22.640]  либо мы…
[04:22.640 --> 04:26.640]  Давайте рассмотрим момент, когда медленный указатель дойдет до начала цикла.
[04:27.640 --> 04:28.640]  Рассматриваем.
[04:28.640 --> 04:29.640]  Рассмотрели.
[04:29.640 --> 04:32.640]  Нарисовали стрелочку медленного указателя до начала цикла.
[04:32.640 --> 04:33.640]  Хорошо.
[04:33.640 --> 04:35.640]  А быстрый указатель где-то на цикле, обязательно.
[04:35.640 --> 04:36.640]  Да.
[04:36.640 --> 04:40.640]  Ну значит, еще не более чем задвинут цикл, а быстрый указатель дойдет медленным.
[04:40.640 --> 04:41.640]  Да.
[04:43.640 --> 04:45.640]  Ну в какой-то момент они снова встретятся, короче.
[04:45.640 --> 04:47.640]  Хорошо, но теперь вопрос.
[04:47.640 --> 04:49.640]  А как найти вершину, в которой цикл начинался?
[04:51.640 --> 04:52.640]  Собственно.
[04:54.640 --> 04:55.640]  Задача-то была в этом.
[04:56.640 --> 05:00.640]  Вроде ставят указатель опять в голову.
[05:01.640 --> 05:04.640]  И там можно представить, что они встречаются в точке минус r,
[05:04.640 --> 05:09.640]  где r – это остаток определения длины хвоста на длину цикла.
[05:10.640 --> 05:13.640]  И по идее, когда мы…
[05:13.640 --> 05:18.640]  Ну теперь с шагом 1,1 они по идее встретятся когда-то в начале точки.
[05:18.640 --> 05:21.640]  Оба пройдут остаток r.
[05:22.640 --> 05:24.640]  По-моему, длины цикла.
[05:24.640 --> 05:27.640]  Ну кажется, можно два счетчика типа завести на…
[05:27.640 --> 05:30.640]  Хотя достаточно просто итерации посчитать.
[05:31.640 --> 05:36.640]  Число итерации и как через родину длину одним-другим вычислить.
[05:41.640 --> 05:42.640]  Еще раз.
[05:42.640 --> 05:43.640]  Что?
[05:43.640 --> 05:45.640]  Поставь какие счетчики.
[05:45.640 --> 05:49.640]  Ну типа просто давайте заведем счетчика, который считает число итерации, который у нас в участии.
[05:49.640 --> 05:50.640]  Так.
[05:50.640 --> 05:51.640]  Да.
[05:51.640 --> 05:53.640]  Или формально говоря, сколько раз медленный указатель перешел.
[05:53.640 --> 05:54.640]  Да.
[05:54.640 --> 05:55.640]  Вот.
[05:55.640 --> 05:59.640]  И тогда если кажется, что это число, как раз их сразу и будет давать нам длину цикла.
[06:00.640 --> 06:02.640]  А длина цикла, видать, мы знаем…
[06:03.640 --> 06:05.640]  Почему он будет давать вообще ничего?
[06:05.640 --> 06:06.640]  Ну длину требует.
[06:06.640 --> 06:07.640]  Почему?
[06:07.640 --> 06:08.640]  Потому что у тебя…
[06:08.640 --> 06:12.640]  Если у тебя быстро указатель догнал медленный, то он должен был пройти полностью круг цикла.
[06:13.640 --> 06:14.640]  Это правда?
[06:15.640 --> 06:20.640]  Ну, наверное, можно пройти до момента, когда они встретятся еще раз.
[06:21.640 --> 06:22.640]  И так понять длину цикла.
[06:22.640 --> 06:23.640]  Просто сохранить вершину.
[06:24.640 --> 06:27.640]  Пройти еще, пока опять не вернемся.
[06:27.640 --> 06:28.640]  Найти длину цикла без проблем вообще.
[06:29.640 --> 06:35.640]  Ну, короче, найти длину цикла – это как минимум можно еще раз пройти, пока они снова не встретятся.
[06:36.640 --> 06:37.640]  Так.
[06:37.640 --> 06:42.640]  И после этого мы будем знать длину цикла, а также мы будем знать общее количество шагов, которые было проделано.
[06:43.640 --> 06:44.640]  И…
[06:44.640 --> 06:47.640]  Вы сказали, что медленный указатель прошел не больше одного цикла.
[06:52.640 --> 06:53.640]  Нет, я не понял.
[06:53.640 --> 06:54.640]  А как найти все-таки…
[06:54.640 --> 06:55.640]  Смотри, если у нас медленный указатель…
[06:55.640 --> 06:56.640]  Да.
[06:56.640 --> 06:57.640]  Если мы, то есть, делаем…
[06:58.640 --> 07:01.640]  Сначала один раз прошли, а потом еще специально, чтобы посчитать длину цикла второе.
[07:01.640 --> 07:02.640]  Да.
[07:02.640 --> 07:05.640]  Утверждаешь, что медленный указатель пройдет от силы один цикл.
[07:06.640 --> 07:07.640]  Что?
[07:08.640 --> 07:14.640]  Ну, ты можешь найти длину цикла, и ты знаешь, что у тебя медленно прошел всего лишь максимум одну…
[07:14.640 --> 07:15.640]  Так, а начало-то где?
[07:15.640 --> 07:16.640]  Как его найти?
[07:16.640 --> 07:17.640]  Длину мы и так уже нашли.
[07:17.640 --> 07:20.640]  Ну, так теперь обычный из пути, который медленно прошел.
[07:20.640 --> 07:23.640]  Так, а медленный мы же не знаем, что в начале он стоит где-то в середине стоит.
[07:23.640 --> 07:25.640]  Мы не знаем, сколько вы читаете.
[07:32.640 --> 07:33.640]  А ты чем предлагал?
[07:34.640 --> 07:35.640]  Математику.
[07:35.640 --> 07:36.640]  Вроде рабочую.
[07:36.640 --> 07:37.640]  Ну, да.
[07:37.640 --> 07:39.640]  Там просто надо считать отстаток.
[07:39.640 --> 07:42.640]  Ну, мы, короче, сказали, что достаток это делается.
[07:45.640 --> 07:46.640]  Ну, давай, как?
[07:46.640 --> 07:47.640]  Потому что я забыл.
[07:48.640 --> 07:51.640]  Думаю, мы говорим T – это длина вот этого хвостика.
[07:51.640 --> 07:52.640]  C – это длина цикла.
[07:53.640 --> 07:55.640]  T – это длина хвоста, C – это длина цикла.
[07:55.640 --> 07:56.640]  Так.
[07:56.640 --> 07:59.640]  Делим с остатком T на все.
[07:59.640 --> 08:01.640]  Получаем какой-то отстаток R.
[08:01.640 --> 08:06.640]  Допустим, оказывается, что там какой-то то ли в точке R, то ли в точке и минус R.
[08:06.640 --> 08:08.640]  Они как-то здесь перейдутся.
[08:08.640 --> 08:20.640]  Если мы пройдем еще раз, то у нас указатель, который мы оставили в вершине, который у него не встретится, пройдет как раз R шагов, покажется, ну, за T операции.
[08:20.640 --> 08:22.640]  Ну, да, значит, минус R.
[08:22.640 --> 08:29.640]  Парни встретились в точке и минус R, за T шагов указатель, который остался на цикле, придет к ноль.
[08:29.640 --> 08:35.640]  А указатель, который мы поставили в голову, тоже будет в начале цикла.
[08:36.640 --> 08:43.640]  Сейчас, вот у нас здесь, у нас получается в данном случае T – это 2, C – это 5, R – это тоже 2.
[08:43.640 --> 08:46.640]  T по моделю C, не C по моделю T, а T по моделю C.
[08:47.640 --> 08:50.640]  Ага, значит, что ты утверждаешь, где они встретятся?
[08:50.640 --> 08:52.640]  В точке и минус 2.
[08:52.640 --> 08:54.640]  Минус 2 относительно чего?
[08:55.640 --> 08:58.640]  То есть вот здесь, вот тут, что ли?
[08:59.640 --> 09:03.640]  Ага, ну, хорошо, когда медленный здесь, быстрый тут.
[09:03.640 --> 09:05.640]  Потом…
[09:07.640 --> 09:09.640]  Сколько шагов надо, чтобы…
[09:09.640 --> 09:11.640]  А, ну да, собственно, он стоит на 3.
[09:11.640 --> 09:13.640]  Ага, ему как раз потребуется…
[09:13.640 --> 09:14.640]  Ну да, кажется, это правда.
[09:14.640 --> 09:17.640]  То есть они встретятся в точке и минус R от начала цикла.
[09:17.640 --> 09:21.640]  И после этого мы… Что мы дальше сделаем?
[09:21.640 --> 09:24.640]  Ставим указатель 1 в начало…
[09:24.640 --> 09:27.640]  В начало… А, вот в это начало.
[09:27.640 --> 09:29.640]  И ведем шагом 1.
[09:29.640 --> 09:30.640]  Так.
[09:30.640 --> 09:33.640]  Ну, а второй в эту точку минус R, в которой они встретились.
[09:33.640 --> 09:34.640]  Да, так.
[09:34.640 --> 09:36.640]  Ну, я не тесть, мы в начале это делаем.
[09:37.640 --> 09:41.640]  Потому что одному нам пройти… Сколько, чтобы на C плюс R, а второму надо пройти R.
[09:42.640 --> 09:44.640]  Ну и тоже по циклу еще сколько хочешь намотать?
[09:45.640 --> 09:46.640]  Что?
[09:46.640 --> 09:47.640]  Дальше мы просто идем…
[09:47.640 --> 09:51.640]  А, ну этот, возможно, обойдет цикл сколько-то раз и еще R шагов сделает.
[09:51.640 --> 09:52.640]  А этот сделает…
[09:53.640 --> 09:54.640]  Ну, то же самое, да.
[09:55.640 --> 09:57.640]  Ну, кажется, работает, да.
[09:57.640 --> 09:58.640]  Кажется, работает.
[09:58.640 --> 10:00.640]  А что, все поняли?
[10:00.640 --> 10:01.640]  Нет, из C плюс.
[10:03.640 --> 10:04.640]  Да, в общем…
[10:05.640 --> 10:06.640]  Шляпа полная.
[10:07.640 --> 10:08.640]  Шляпа полная.
[10:09.640 --> 10:12.640]  Да, в архиве…
[10:13.640 --> 10:15.640]  А, мы на камеру снимаем, да?
[10:15.640 --> 10:16.640]  Ну, типа, да.
[10:16.640 --> 10:17.640]  Тогда я не буду говорить, ладно.
[10:20.640 --> 10:22.640]  Если камеры выключите, когда я потом…
[10:24.640 --> 10:26.640]  Не знаю, в перерыве скажу.
[10:27.640 --> 10:28.640]  Да, но не забудь.
[10:28.640 --> 10:29.640]  Так, хорошо.
[10:29.640 --> 10:30.640]  Ну ладно, вот.
[10:30.640 --> 10:33.640]  Это первая очень боенистая задача про связанные списки.
[10:33.640 --> 10:35.640]  Ну, которую так сходу-то и…
[10:36.640 --> 10:37.640]  Разворачивают список?
[10:38.640 --> 10:40.640]  Разворачивают список – это нулевая задача.
[10:40.640 --> 10:43.640]  Я это даже не стал упоминать, но потому что это вообще не серьезно.
[10:43.640 --> 10:44.640]  Односвязный список.
[10:44.640 --> 10:45.640]  Односвязный, конечно, список.
[10:46.640 --> 10:49.640]  Да, значит, задача номер ноль – развернуть односвязный список.
[10:49.640 --> 10:52.640]  Это, не знаю, самая популярная задача.
[10:52.640 --> 10:54.640]  Вот эта, мне кажется, вторая по популярности.
[10:54.640 --> 10:55.640]  А почему она вторая по популярности?
[10:55.640 --> 10:58.640]  Она же нигде больше не применяется.
[10:58.640 --> 11:01.640]  Как будто остальные задачи собеседования нигде-то применяются.
[11:01.640 --> 11:04.640]  Не знаю, просто идея даже нигде в этом не применяется.
[11:04.640 --> 11:08.640]  Идея вот эта вот как раз применяется в твоем любимом алгоритме RO.
[11:08.640 --> 11:09.640]  Хорошо.
[11:09.640 --> 11:11.640]  Правда, вот это вот не что иное, как буква RO.
[11:11.640 --> 11:12.640]  Я знаю.
[11:12.640 --> 11:13.640]  Да.
[11:13.640 --> 11:16.640]  Собственно, там происходит примерно то же самое, только там с остатками.
[11:16.640 --> 11:17.640]  Правда, я уже…
[11:20.640 --> 11:24.640]  Ну, вот это скорее штука на знание.
[11:24.640 --> 11:30.640]  Но вот эта вот докрутка, что там, где цикл начинается, это такое…
[11:31.640 --> 11:32.640]  Ну да.
[11:33.640 --> 11:36.640]  Не, ну лично я не встречал, чтоб меня спрашивали на собеседовании разом.
[11:36.640 --> 11:38.640]  Но я знаю, что…
[11:38.640 --> 11:42.640]  Но я говорю, это, наверное, не спрашивать, потому что это уже настолько баян, что даже и…
[11:42.640 --> 11:45.640]  Вот развернуть список по-прежнему очень популярно.
[11:45.640 --> 11:46.640]  Вот.
[11:46.640 --> 11:48.640]  А другая задача популярная…
[11:50.640 --> 11:52.640]  Это, которая…
[11:52.640 --> 11:55.640]  Вот про которую ты тоже говорил, это вот такая.
[11:55.640 --> 12:00.640]  Вот у тебя есть список опять односвязный.
[12:00.640 --> 12:02.640]  Ну или двусвязный.
[12:02.640 --> 12:04.640]  Нет, односвязный, наверное.
[12:04.640 --> 12:10.640]  И у каждой вершины, помимо указателя на следующего, есть еще рандомный указатель какой-то, который ведет…
[12:10.640 --> 12:13.640]  Ну, может вести в любое место там.
[12:13.640 --> 12:16.640]  А может вообще на себя.
[12:18.640 --> 12:20.640]  И нужно скопировать…
[12:21.640 --> 12:25.640]  В общем, нужно повторить эту штуку, сделав такую же структуру…
[12:25.640 --> 12:27.640]  Так, я отсюда еще никого никуда не повел.
[12:27.640 --> 12:29.640]  Пусть будет этот вот сюда.
[12:30.640 --> 12:31.640]  Вот.
[12:31.640 --> 12:33.640]  А знаешь, какой следующий такой рандомный?
[12:33.640 --> 12:34.640]  Да.
[12:35.640 --> 12:36.640]  Вот.
[12:36.640 --> 12:38.640]  Есть next, а есть other.
[12:38.640 --> 12:42.640]  И вот нужно сделать…
[12:43.640 --> 12:45.640]  В общем, нужно создать копию такой штуки.
[12:45.640 --> 12:47.640]  Ну опять вам данный указатель на head.
[12:48.640 --> 12:49.640]  И…
[12:50.640 --> 12:51.640]  Вот.
[12:51.640 --> 12:52.640]  Как сделать?
[12:52.640 --> 12:56.640]  Ну, кто-то уже точно знает, потому что еще в прошлый раз обсуждали.
[12:56.640 --> 12:58.640]  Ну, а как ты other инициализировать?
[12:58.640 --> 13:02.640]  Тебе, чтобы проинциализировать очередной other, может линейное время потребоваться.
[13:04.640 --> 13:06.640]  Мы это в прошлый раз обсуждали?
[13:06.640 --> 13:15.640]  Ну, в прошлый раз там вот господин Жильцов подошел и вот спросил, правильно ли его понимание о том, как эту задачу решать.
[13:15.640 --> 13:17.640]  А блефессом она не решается?
[13:17.640 --> 13:19.640]  Ну, хочется это все решать.
[13:19.640 --> 13:21.640]  Ну, я не знаю.
[13:22.640 --> 13:24.640]  А блефессом она не решается?
[13:24.640 --> 13:29.640]  Ну, хочется это все сделать за время, типа…
[13:30.640 --> 13:32.640]  Ну, типа блефесса это будет в выпуске.
[13:32.640 --> 13:34.640]  Да, я понял, но…
[13:34.640 --> 13:35.640]  Ну, нормально.
[13:35.640 --> 13:36.640]  И как?
[13:36.640 --> 13:38.640]  Если что-то значит, то блефесса не решается, типа как?
[13:38.640 --> 13:40.640]  Нет, да, что такое, как это?
[13:40.640 --> 13:45.640]  Ну, в плане типа просто при помощи блефесса копируем.
[13:46.640 --> 13:52.640]  Создавая новый Жильцам, заполняем массивчик какой-нибудь условный, по которому мы так идем спокойно.
[13:55.640 --> 13:57.640]  Честно говоря, ничего не понятно.
[13:57.640 --> 13:59.640]  Что значит оп-оп-оп?
[13:59.640 --> 14:05.640]  Если создать хашмапу отдельную, да, это можно записать для каждого указателя ее номер от единицы.
[14:05.640 --> 14:16.640]  Ну, вообще, да, в решении, которое в итоге получится, памяти кроме как на исходный список и на новый список никакой не должно быть.
[14:16.640 --> 14:18.640]  Ну, от единицы дополнительной.
[14:21.640 --> 14:26.640]  Вот, ну, ладно, тут я могу рассказать решение, потому что я его не забыл.
[14:26.640 --> 14:36.640]  Вот, решение такое, что надо просто раздвоить ноды, то есть после каждой сделать ее дубликат.
[14:39.640 --> 14:41.640]  Между каждыми двумя вставить по одной.
[14:41.640 --> 14:47.640]  И тогда понятно, как за вот единицы проставить указатели азр.
[14:49.640 --> 14:54.640]  Ну, понятно, что, например, как проставить азр вот для этой.
[14:55.640 --> 14:59.640]  Но нужно, нет, кстати, не до конца понятно как, сейчас.
[15:02.640 --> 15:03.640]  А, нет, все понятно.
[15:03.640 --> 15:08.640]  Нужно посмотреть на азр для этой и следующий, который за ней, это и будет азр для нашей.
[15:08.640 --> 15:09.640]  Ну, и так для всех.
[15:12.640 --> 15:18.640]  Я в каждом, да, я спланировал каждую вершину, вставил между любыми двумя новую.
[15:18.640 --> 15:24.640]  Вот, и теперь, чтобы понять, как проставить азр для этой вершины,
[15:24.640 --> 15:27.640]  мне нужно посмотреть, куда вел азр для этой вершины,
[15:27.640 --> 15:31.640]  и поставить азр на следующего после того, куда он вел, то есть вот сюда.
[15:33.640 --> 15:37.640]  А потом обратно разъединить, то есть потом расцепить эти два списка.
[15:39.640 --> 15:41.640]  Это через один, да.
[15:42.640 --> 15:43.640]  Вот такая штука.
[15:43.640 --> 15:47.640]  Нет, ну в итоге мы его оставим, как есть, да, ну в смысле,
[15:47.640 --> 15:50.640]  константный ли он был, ну, видимо, нет, не константный.
[15:55.640 --> 15:56.640]  Ну да, понятно.
[15:58.640 --> 16:00.640]  Нет, понятно, ну можно было...
[16:06.640 --> 16:07.640]  Ну, да, понятно.
[16:08.640 --> 16:09.640]  Его в итоге не меняем.
[16:09.640 --> 16:11.640]  Нет, понятно, ну можно было...
[16:13.640 --> 16:16.640]  Подожди, ты же можешь создать оболочку, которая...
[16:16.640 --> 16:20.640]  Ну все, понятно, ну короче, вопрос правильный, да, ну да, можно было менять.
[16:21.640 --> 16:25.640]  Вот, ну вот теперь вы знаете там три самых баянистых задачи на связанной списке.
[16:26.640 --> 16:28.640]  Ну, еще развернуть список еще. Чего?
[16:28.640 --> 16:29.640]  Я не шарю.
[16:29.640 --> 16:30.640]  В смысле не шарю?
[16:30.640 --> 16:31.640]  Как перевращать список?
[16:32.640 --> 16:33.640]  Проверять список.
[16:36.640 --> 16:40.640]  Так подожди, а там же... Там как раз нет ничего алгоритмического, там просто надо это, написать.
[16:40.640 --> 16:43.640]  Ну развернуть список — это задача на аккуратность.
[16:43.640 --> 16:51.640]  Ее очень часто спрашивают, чтобы, там, проверить, сколько вам потребуется времени чтобы не запутаться.
[16:51.640 --> 16:55.640]  Ну, это, как я не знаю, это, как бинг-поиск написать примерно, такого же уровня задача.
[16:55.640 --> 16:59.640]  Вот, за сколько времени вы можете написать бинг-поиск?
[16:59.640 --> 17:03.640]  какой он работает будет, а сколько времени в минутах вам надо, чтобы мент-поиск написать.
[17:03.640 --> 17:08.640]  Ну так же примерно и со списком связанным, что его развернуть.
[17:08.640 --> 17:13.640]  У него есть копия, чтобы у него, ну, копию перевернуть или исходный список перевернуть?
[17:13.640 --> 17:15.640]  Нет, исходный список перевернуть.
[17:15.640 --> 17:19.640]  Может поддерживать один указатель или там дополнительный?
[17:19.640 --> 17:24.640]  Ну да, надо просто там, в момент, когда вы вот вы тут стрелочки эти разворачиваете,
[17:24.640 --> 17:26.640]  и вам нужно там дополнительно что-то хранить.
[17:26.640 --> 17:31.640]  И, ну, я не хочу, я устал уже, я в своей жизни это много раз делал.
[17:31.640 --> 17:34.640]  Ну, в смысле, мне надоело список переворачивать.
[17:34.640 --> 17:39.640]  Ну, надо просто там правильно запоминать, хранить чуть-чуть на одну больше,
[17:39.640 --> 17:45.640]  чтобы вот, ну, вот эту штуку вы заменили вот на эту, это стерлось.
[17:45.640 --> 17:50.640]  А теперь вам надо еще помнить вот эту, чтобы на нее потом перейти, чтобы у нее тоже...
[17:50.640 --> 17:53.640]  Ну, типа да.
[17:53.640 --> 17:57.640]  Ну да, ну, это несложно совершенно, алцилогрепнической точки зрения.
[17:57.640 --> 18:02.640]  Это именно с точки зрения написания говнокода может там быть проблемно.
[18:02.640 --> 18:03.640]  Можно просто обвести шляпу, что ей происходит.
[18:03.640 --> 18:04.640]  Какую шляпу?
[18:04.640 --> 18:05.640]  Которую вот эта вот...
[18:05.640 --> 18:06.640]  Вот эта?
[18:06.640 --> 18:07.640]  Да, с двумя видами.
[18:07.640 --> 18:08.640]  А ты не понял?
[18:08.640 --> 18:11.640]  Нет, типа что это вообще за лол?
[18:11.640 --> 18:14.640]  Ты все еще считаешь, что БФС-ом надо, да?
[18:14.640 --> 18:16.640]  Я вообще ничего не считаю.
[18:16.640 --> 18:21.640]  Нет, я просто, просто, возможно, если ты не понял проблему, то ты и решения не понял.
[18:21.640 --> 18:26.640]  Но проблема, как его скопировать, чтобы это не за квадрат было?
[18:26.640 --> 18:30.640]  Ну, собственно, с допамятью это будет работать.
[18:30.640 --> 18:36.640]  Допамять не только на хранении нового, но туда это можно сделать БФС.
[18:36.640 --> 18:38.640]  Почему это может быть за квадрат?
[18:38.640 --> 18:41.640]  Ну, если делать совсем в тупую, типа...
[18:41.640 --> 18:43.640]  Как совсем в тупую делать?
[18:43.640 --> 18:46.640]  Я пройдусь слева-направо...
[18:46.640 --> 18:47.640]  Скопирую?
[18:47.640 --> 18:49.640]  Да, скопирую стрелочки вправо.
[18:49.640 --> 18:50.640]  А потом?
[18:50.640 --> 18:51.640]  А потом?
[18:51.640 --> 18:52.640]  То же самое, то же самое.
[18:52.640 --> 18:57.640]  Как ты будешь понимать, какую, когда это возьмешь и скажешь, на кого нужно поставить?
[18:57.640 --> 18:58.640]  Топ-сок.
[18:58.640 --> 19:07.640]  Ну, вот тебе надо поставить, тебе надо поставить вот в вершине своей копии аналогичную стрелку там, через К.
[19:07.640 --> 19:08.640]  Ну, просто.
[19:08.640 --> 19:09.640]  Да.
[19:09.640 --> 19:10.640]  В смысле, да.
[19:10.640 --> 19:11.640]  Смотрю куда она смотрит, скопирую.
[19:11.640 --> 19:12.640]  Что ты скопируешь?
[19:12.640 --> 19:13.640]  Ты должен взять ее копию.
[19:13.640 --> 19:16.640]  У тебя ей уже какая-то соответствует.
[19:16.640 --> 19:18.640]  А, уже в нее перейти.
[19:18.640 --> 19:20.640]  Можно, наверное, в хэшмапы положить.
[19:20.640 --> 19:22.640]  Ладно, отлично, памяти много.
[19:22.640 --> 19:23.640]  Даня.
[19:23.640 --> 19:30.640]  Ну, с хэшмапой, наверное, да, но это лишняя память, и все, некрасиво вот это.
[19:30.640 --> 19:36.640]  Вот смотри, чем-то мне не понравилась идея вставить новую вершину посередине между каждыми двумя.
[19:36.640 --> 19:37.640]  Нормально?
[19:37.640 --> 19:40.640]  Как минимум, потому что у тебя тогда вершина получится над уменьшим чем надо.
[19:40.640 --> 19:43.640]  Вставь еще одну после всего списка красного.
[19:43.640 --> 19:45.640]  Ну, это я забыл сделать, да.
[19:45.640 --> 19:48.640]  А, то есть в этом была проблема.
[19:48.640 --> 19:50.640]  Отлично, нормально вставили.
[19:50.640 --> 19:57.640]  Мы будем добиваться того, чтобы красная вершина, которая идет за какой-то черный, стала, в конце концов, ее копией.
[19:57.640 --> 19:59.640]  Окей?
[19:59.640 --> 20:11.640]  Вот в таком графе понятно, как провести аналогичные ребра, чтобы у красных вершин были правильно проставлены, ну, не next, а вот эти вот случайные ребра.
[20:11.640 --> 20:15.640]  Ну, вот эти вот второе дополнительное ребро.
[20:15.640 --> 20:17.640]  Ну, в плане, у тебя все, ну, я понял.
[20:17.640 --> 20:19.640]  Понимаешь, на кого проставить?
[20:19.640 --> 20:21.640]  Ну, золотой единицы.
[20:21.640 --> 20:28.640]  Вот мы идем по списку, у нас есть черное и красное, мы переходим по черной, и красный добавляем next от того, куда мы делали.
[20:28.640 --> 20:33.640]  Дима, ты пиши пока, чтобы в цикле подходить, ну, по одновременно по красной и по черной.
[20:33.640 --> 20:35.640]  Да, просто, Дима, два подряд.
[20:35.640 --> 20:37.640]  Все.
[20:37.640 --> 20:39.640]  После этого нужно разогнить два списка.
[20:39.640 --> 20:41.640]  Так, ну ладно.
[20:41.640 --> 20:50.640]  Нам дальше пора переходить к более приземленным вещам, к более прикладным.
[20:50.640 --> 20:52.640]  Опять эти ваши присутствия?
[20:52.640 --> 20:54.640]  Да, да, да.
[20:54.640 --> 20:58.640]  Ну, хорошо.
[20:59.640 --> 21:10.640]  Я вас, я вам, я вам уже сказал, да, что вот цель этого семестра это вот убедить вас никогда не писать больше на плюсах.
[21:15.640 --> 21:17.640]  Так.
[21:19.640 --> 21:21.640]  Да я, честно говоря, не знаю.
[21:21.640 --> 21:25.640]  На бетончике, на бетончике все будет хорошо.
[21:27.640 --> 21:33.640]  Да не, на плюсах тоже есть что-то в этом, знаете, я вот писал, мне нравилось.
[21:33.640 --> 21:41.640]  Так, следующий, о чем нам надо поговорить, следующая вещь, это мэп, как можно было догадаться.
[21:41.640 --> 21:43.640]  STD-мэп.
[21:43.640 --> 21:46.640]  Это пункт 8.8, да?
[21:46.640 --> 21:48.640]  А какая разница?
[21:48.640 --> 21:54.640]  Ну, я хочу поддерживать все-таки программу курса, значит пункт 8.8 STD-мэп.
[21:54.640 --> 21:57.640]  В проекте слишком много легозекунд.
[21:57.640 --> 22:06.640]  Так, ну я уже говорил еще раз скажу, что мне кажется важно какую-то структуру в голове держать.
[22:06.640 --> 22:15.640]  Какая у нас сейчас тема и какой подраздел ее, потому что иначе потом, когда будете это все ботать, там к экзамену к тому же, вы запутаете будет каша в голове.
[22:15.640 --> 22:18.640]  Полезно все-таки структуру поддерживать в материале.
[22:18.640 --> 22:20.640]  Так вот STD-мэп.
[22:20.640 --> 22:25.640]  Ну что такое мэп, все наверное знают, это красно-черное дерево внутри.
[22:25.640 --> 22:26.640]  Вот.
[22:26.640 --> 22:31.640]  Кстати, понятно ли почему красно-черное именно, а почему никакое другое?
[22:31.640 --> 22:33.640]  Меньше всего памяти дополнительной.
[22:33.640 --> 22:35.640]  Вот, памяти дополнительной.
[22:35.640 --> 22:37.640]  Стабильнее.
[22:37.640 --> 22:39.640]  Меньше всего разворотов.
[22:39.640 --> 22:44.640]  Да, ну кажется, что поворачивать надо немного.
[22:44.640 --> 22:46.640]  Больше всего случаев.
[22:46.640 --> 22:53.640]  Больше всего случаев разбирать, но для разработчиков STL-а, как известно, это никогда их не пугало.
[22:53.640 --> 22:54.640]  Вот.
[22:54.640 --> 22:56.640]  Поэтому да.
[22:56.640 --> 22:57.640]  Хорошо.
[22:57.640 --> 22:59.640]  Ну окей, STD-мэп.
[22:59.640 --> 23:03.640]  Ну теперь мы понимаем уже, что там, наверное, внутри.
[23:03.640 --> 23:09.640]  Мы в принципе по аналогии с листом понимаем, что там есть опять-таки ноут.
[23:09.640 --> 23:15.640]  Ну вот если взять мэп, там внутри тоже есть ноут.
[23:15.640 --> 23:17.640]  И в этой ноут есть что?
[23:17.640 --> 23:25.640]  Ну там, понятно, есть left, right parent, там есть left, левый сын.
[23:25.640 --> 23:29.640]  Parent-а нет?
[23:29.640 --> 23:34.640]  А как вы будете ходить по дереву, если нужно обход делать?
[23:34.640 --> 23:36.640]  Деды, бабушки.
[23:36.640 --> 23:38.640]  Ну подожди, всегда эффективнее.
[23:38.640 --> 23:42.640]  Удаляем алгоритм, поэтому всегда можно по ним стэк хранить.
[23:42.640 --> 23:45.640]  А, то есть помимо всех вершин еще стэк хранить.
[23:45.640 --> 23:49.640]  Ну этот стэк будет глубины алгоритма не больше, чем глубину алгоритма всегда.
[23:49.640 --> 23:52.640]  Это прикольнее, по-моему.
[23:52.640 --> 23:58.640]  Есть некоторая трудность в реализации, которую я сразу вижу.
[23:58.640 --> 24:02.640]  А как будет память под него выделяться и в какой момент?
[24:02.640 --> 24:04.640]  А можно выделить заранее?
[24:04.640 --> 24:06.640]  Заранее насколько?
[24:06.640 --> 24:11.640]  Ну, на алгоритм от того, сколько у вас вершин, а когда новая вершина добавляется, еще чуть-чуть выделять.
[24:11.640 --> 24:14.640]  Это в смысле чуть-чуть еще?
[24:14.640 --> 24:17.640]  Это типа вот...
[24:17.640 --> 24:22.640]  Массивчик константный можно считать, который всегда размер алгоритма.
[24:22.640 --> 24:24.640]  Алгоритм от чего? А он же меняется.
[24:24.640 --> 24:26.640]  Ну вот, алгоритм от текущего.
[24:26.640 --> 24:28.640]  Вектор просто.
[24:28.640 --> 24:32.640]  Да, ну то есть просто еще вместе с деревом хранить вектор.
[24:32.640 --> 24:36.640]  Да, но он всегда очень маленького размера.
[24:36.640 --> 24:39.640]  Ну что значит маленького? Его же реалацировать все равно придется иногда.
[24:39.640 --> 24:42.640]  Нет, это все равно лучше, чем ноут звездочка Parent.
[24:42.640 --> 24:44.640]  Да кто тебе сказал лучше, что это лучше?
[24:44.640 --> 24:46.640]  Ну по памяти оно точно лучше.
[24:46.640 --> 24:49.640]  Ну мы же не память экономим все-таки.
[24:49.640 --> 24:55.640]  Нет, ну мы... Не-не-не, я уверен, что так не сделано, как вы говорите.
[24:55.640 --> 24:58.640]  Потому что, ну просто это было бы очень странно.
[24:58.640 --> 25:00.640]  Что?
[25:02.640 --> 25:06.640]  Короче, Parent...
[25:08.640 --> 25:12.640]  Все-таки, я думаю, надо хранить.
[25:12.640 --> 25:15.640]  Вот, ну и там понятно, что есть.
[25:15.640 --> 25:18.640]  А что еще-то там, кстати, есть? Вот хороший вопрос.
[25:18.640 --> 25:20.640]  Ну понятно, с этими деревьями.
[25:20.640 --> 25:23.640]  Ну еще должно быть K и Value.
[25:28.640 --> 25:30.640]  И это можно хранить где угодно.
[25:30.640 --> 25:32.640]  Лишний бетон.
[25:32.640 --> 25:34.640]  Я думаю, они как-то заморочились.
[25:34.640 --> 25:35.640]  Бетон?
[25:35.640 --> 25:37.640]  Ну типа, я думаю, один бетон.
[25:37.640 --> 25:40.640]  Можно запихать в какое-нибудь случайное место.
[25:40.640 --> 25:42.640]  Что значит случайное место?
[25:42.640 --> 25:44.640]  А что такое K и Value?
[25:44.640 --> 25:46.640]  А вот, ну так это же мэп?
[25:46.640 --> 25:51.640]  Да, мэп из чего-то во что-то.
[25:51.640 --> 25:54.640]  На самом деле, я только написал, оно не совсем так.
[25:54.640 --> 25:56.640]  А именно...
[25:56.640 --> 25:58.640]  Вот сейчас мы как раз поговорим...
[26:01.640 --> 26:03.640]  Да нет, можно и так. Почему?
[26:03.640 --> 26:05.640]  Это прилагательное.
[26:05.640 --> 26:07.640]  Булевский фун, empty, например.
[26:07.640 --> 26:08.640]  Работает так.
[26:08.640 --> 26:10.640]  Просто отвечает на вопрос, да или нет.
[26:10.640 --> 26:16.640]  Ну вот, насчет буля, я не знаю, извратились ли они там, чтобы его одним битом хранить или нет.
[26:16.640 --> 26:19.640]  Ну, давайте будем считать, что нет.
[26:19.640 --> 26:21.640]  А как вариант?
[26:21.640 --> 26:23.640]  Придется к нему обращаться?
[26:23.640 --> 26:25.640]  Уже как структура, а это уже там опять бай.
[26:25.640 --> 26:30.640]  Ну да, в общем, мне кажется, что...
[26:30.640 --> 26:33.640]  Давайте считать, что просто буль хранится и все.
[26:33.640 --> 26:37.640]  Так, окей, вот такая вот структура node.
[26:37.640 --> 26:40.640]  А теперь, какие у нас есть методы?
[26:40.640 --> 26:42.640]  У нас есть...
[26:42.640 --> 26:48.640]  Сейчас поговорим про то, как работают квадратные скобочки, add, insert, erase и прочее.
[26:48.640 --> 26:53.640]  Ну давайте начнем, наверное, с...
[26:53.640 --> 26:54.640]  С чего мы начнем?
[26:54.640 --> 26:56.640]  Ну мы начнем с...
[26:56.640 --> 26:59.640]  Ну как квадратные скобочки работают для начала?
[26:59.640 --> 27:01.640]  Спускаемся по дереву, ищем вершину.
[27:01.640 --> 27:05.640]  Да, ну понятно, с точки зрения алгоритмов не интересно, как они работают.
[27:05.640 --> 27:08.640]  Вы и так знаете, что мы пошли из корня.
[27:08.640 --> 27:16.640]  А, ну да, а в самом классе map хранится указатель на корень.
[27:16.640 --> 27:20.640]  Вот, и возможно еще какой-то указатель, сейчас мы поймем куда.
[27:20.640 --> 27:25.640]  Я так думаю, что нужно будет еще какой-нибудь.
[27:25.640 --> 27:30.640]  Вопрос к занавтокам, потому что я кочей дерева успешно не ботал.
[27:30.640 --> 27:31.640]  Так.
[27:31.640 --> 27:35.640]  А ну дерево почему подключу?
[27:35.640 --> 27:38.640]  Подключу, конечно.
[27:38.640 --> 27:40.640]  Не подключу.
[27:40.640 --> 27:54.640]  Да, map это упорядоченный двоечное дерево поиска, подключу, а well это просто значение в соответствующих вершинах.
[27:54.640 --> 27:56.640]  Вот.
[27:56.640 --> 28:05.640]  Ну так вот, у нас хранится указатель на root, да, в мэпе там.
[28:05.640 --> 28:11.640]  И мы спускаемся лево-право, лево-право, идем, ищем место, куда вставить.
[28:11.640 --> 28:14.640]  Понимаем, куда вставить.
[28:18.640 --> 28:21.640]  И что дальше?
[28:21.640 --> 28:25.640]  Ну дальше начинаются вот эти свистопляски с поворотами дерева.
[28:25.640 --> 28:30.640]  Там вот это вот если дедушка черный, а дядя серый, а этот серый мурмалин.
[28:30.640 --> 28:38.640]  Ну вот эти все случаи, понятно, что они там, в общем опустим эту часть.
[28:38.640 --> 28:44.640]  Но что по существу с точки зрения плюсов происходит, когда квадратные скобочки работают?
[28:44.640 --> 28:48.640]  Квадратные скобочки, они вообще какую сигнатуру имеют?
[28:48.640 --> 28:56.640]  Оператор квадратной скобочки принимает value, const value.
[29:08.640 --> 29:12.640]  Ну в квадратной скобочке мы принимаем, ой, ключ.
[29:12.640 --> 29:15.640]  Да-да, мы принимаем, принимаем мы ключ, сорян.
[29:15.640 --> 29:22.640]  Да, принимаем мы ключ, конечно, а возвращаем ссылку на value как раз.
[29:22.640 --> 29:24.640]  Я их перепутал.
[29:24.640 --> 29:28.640]  Значит, принимаем мы ключ, а возвращаем ссылку на value.
[29:28.640 --> 29:32.640]  Причем это не константный оператор.
[29:32.640 --> 29:39.640]  И в константном мэпе нельзя вызвать квадратные скобочки, соответственно.
[29:39.640 --> 29:43.640]  Вот, квадратные скобочки это не константный оператор.
[29:43.640 --> 29:50.640]  Если у вас константный мэп, то вы ошибку попробуете квадратными скобочками к нему, это будет CE.
[29:50.640 --> 30:01.640]  А? CE просто потому что value амперсант не получится сделать из.
[30:01.640 --> 30:05.640]  Вот, да, ну как я уже сказал, тут это не совсем так там выглядит.
[30:05.640 --> 30:08.640]  Сейчас вот как работают квадратные скобочки?
[30:08.640 --> 30:14.640]  Ну, понятно, как они работают, если ключ такой был, а вот если его нет, как они работают?
[30:14.640 --> 30:20.640]  Ну, мне же надо value амперсант вернуть на что-то.
[30:20.640 --> 30:25.640]  А, нам нужно, чтобы мы...
[30:25.640 --> 30:28.640]  Должен ли у нашего типа быть конструктор по умолчанию?
[30:28.640 --> 30:30.640]  Вот это и вопрос.
[30:30.640 --> 30:36.640]  Вот да, именно, что если вы квадратными скобочками обратитесь к ключу, которого не было,
[30:36.640 --> 30:42.640]  то создастся соответствующая вершина под него и value там будет проинциализирована по умолчанию.
[30:42.640 --> 30:48.640]  То есть value должен иметь конструктор по умолчанию в случае, если вы квадратными скобочками хотите присваивать по нему.
[30:48.640 --> 30:53.640]  Ну, нет, понятно, если вы обратитесь к квадратным скобочкам, он там был, хорошо, вам повезло.
[30:53.640 --> 31:02.640]  Но если вы обратитесь к квадратным скобочкам, а его там не было, то он вызовет конструктор по умолчанию.
[31:02.640 --> 31:05.640]  Да, а стало быть, поскольку это в compile-time все должно происходить,
[31:05.640 --> 31:09.640]  конструктор по умолчанию должен быть в любом случае, если вы квадратными скобочками пользуетесь.
[31:09.640 --> 31:11.640]  Ну, не может же от рантайма зависеть.
[31:11.640 --> 31:14.640]  Случилось ли у вас обращение такое, что ключа не нашлось?
[31:14.640 --> 31:16.640]  А если им не пользуются, то почему...
[31:16.640 --> 31:17.640]  Чего?
[31:17.640 --> 31:20.640]  Если им вообще не пользуются скобочками, то проблема не будет.
[31:20.640 --> 31:26.640]  Квадратными скобочками, потому что оно может не инстанцироваться, это же шаблонный код.
[31:27.640 --> 31:37.640]  Кстати, я не знаю, но я не помню, пробовал ли я пользоваться мэпом, у которого value было без конструктора по умолчанию.
[31:37.640 --> 31:42.640]  Но я не уверен, гарантируется ли, что это скомпилируется, что оно не синстанцируется.
[31:42.640 --> 31:47.640]  Скорее всего, не синстанцируется, но нафиг его знает.
[31:47.640 --> 31:51.640]  Вот, но есть... А как, если константный мэп, тогда что делать?
[31:51.640 --> 31:53.640]  Во-первых, это только для неконстантных мэпов.
[31:53.640 --> 31:56.640]  Во-вторых, должен быть конструктор по умолчанию value, если им пользоваться этим.
[31:56.640 --> 32:02.640]  А если не константный... Если константный мэп, то как обращаться?
[32:02.640 --> 32:04.640]  Там есть... Что?
[32:04.640 --> 32:06.640]  Да, там есть этот add.
[32:06.640 --> 32:11.640]  Вот аналог квадратных скобочек мы... Ой, почему оператор?
[32:11.640 --> 32:15.640]  Ну, как в векторе у нас были квадратные скобочки, а был add.
[32:16.640 --> 32:21.640]  Также в мэпе у нас есть add, но он тут играет уже другую...
[32:21.640 --> 32:27.640]  Это более важно, тут у него функция не только в том, чтобы проверять выход за границы.
[32:27.640 --> 32:33.640]  Вот тут оператор add, как и в векторе, кидает исключение в случае исключения, нашлось.
[32:33.640 --> 32:35.640]  Но при этом...
[32:37.640 --> 32:40.640]  Господи, да почему я пишу оператор?
[32:40.640 --> 32:42.640]  Оператор add.
[32:42.640 --> 32:46.640]  А возвращает он что? Ну, value амперсант также возвращает.
[32:46.640 --> 32:48.640]  Но может быть и константным, да.
[32:48.640 --> 32:52.640]  Если, соответственно, если мэпа константная, то...
[32:52.640 --> 32:56.640]  Ну, короче, оператор add есть как константная, так и неконстантная версия.
[32:56.640 --> 32:59.640]  Соответственно, может быть здесь конст.
[32:59.640 --> 33:03.640]  Что происходит, если вы add, от ключа которого нет вызвали?
[33:03.640 --> 33:06.640]  Ну, будет исключение, бросится.
[33:06.640 --> 33:13.640]  Будет стд что-то, не помню, out of range в векторе, а в мэпе не помню что.
[33:13.640 --> 33:16.640]  Какое-то исключение будет.
[33:16.640 --> 33:18.640]  Вот, ну хорошо.
[33:18.640 --> 33:22.640]  Так, хорошо.
[33:24.640 --> 33:29.640]  Есть еще такая штука, insert, такой метод.
[33:29.640 --> 33:32.640]  И race есть еще метод.
[33:33.640 --> 33:36.640]  А что делает insert?
[33:36.640 --> 33:40.640]  Я не знаю, какой тип данных он принимает, потому что я всегда фигурно скоплю.
[33:40.640 --> 33:43.640]  Да, он принимает пару ключ значения.
[33:43.640 --> 33:48.640]  Std pair. Соответственно, на самом деле вот для мэпа еще есть такой вспомогательный тип.
[33:48.640 --> 33:50.640]  В общем-то он...
[33:50.640 --> 33:52.640]  Ну, по сути...
[33:52.640 --> 33:55.640]  Ладно, это слишком громкое заявление, что он ради мэпа был создан.
[33:55.640 --> 34:00.640]  В общем, есть такой еще тип, std pair, ключ значения.
[34:00.640 --> 34:04.640]  И вы можете в insert передать...
[34:04.640 --> 34:07.640]  Std pair, необычный pair, которым мы пользуемся.
[34:07.640 --> 34:10.640]  Не, ну это обычный тот самый pair, да, std pair.
[34:10.640 --> 34:13.640]  Почему он вообще может быть создан для мапа?
[34:13.640 --> 34:18.640]  Ну, кажется, что вот где в STL он нужен, это именно в мэпе впервые.
[34:18.640 --> 34:21.640]  Ну, что значит впервые, непонятно, но в общем...
[34:21.640 --> 34:24.640]  Да, insert, и принимает он пару...
[34:27.640 --> 34:29.640]  Потому что ты так передаешь.
[34:29.640 --> 34:31.640]  Ну, в смысле, почему так не сделали?
[34:31.640 --> 34:35.640]  Почему отдельно не принимает ключи отдельно значения?
[34:38.640 --> 34:41.640]  Конечно, мы подходим к этой поводу, почему структура нода не совсем такая.
[34:41.640 --> 34:44.640]  Да, вот именно здесь мы к этому и подходим.
[34:44.640 --> 34:47.640]  Это просто какой-то кондроиндуитивный момент.
[34:47.640 --> 34:49.640]  Смотри, я хочу принять два аргумента, мне зачем-то надо...
[34:49.640 --> 34:55.640]  Сейчас расскажу. Наверное, нужно было сначала не про это сказать, а про то, как итераторы устроены.
[34:55.640 --> 34:57.640]  Давайте подумаем, как итераторы устроены.
[34:57.640 --> 34:59.640]  Вы же, когда по мэпу ходите...
[35:01.640 --> 35:03.640]  Да, давайте пока insert отложим.
[35:03.640 --> 35:05.640]  Вот итератор, это что такое по мэпу?
[35:05.640 --> 35:07.640]  Вот если вы разыменовываете итератор, вы что получаете?
[35:09.640 --> 35:11.640]  Вы получаете как раз пару.
[35:11.640 --> 35:20.640]  То есть вам надо, чтобы, обходя мэп итератором, вы могли, разыменовав его, получить как ключ, так и значение в соответствующей вершине.
[35:20.640 --> 35:23.640]  А, стало быть, вы не можете хранить отдельно.
[35:23.640 --> 35:28.640]  Вам нужна структура, чтобы там и ключ и значение лежали рядом одновременно.
[35:28.640 --> 35:30.640]  Поэтому, на самом деле, в ноде лежит это не так.
[35:30.640 --> 35:33.640]  В ноде, на самом деле, лежит пара из ключа и значения.
[35:34.640 --> 35:35.640]  Вот.
[35:35.640 --> 35:38.640]  И я это сейчас перепишу.
[35:40.640 --> 35:42.640]  Тут, значит, лежит пара.
[35:44.640 --> 35:47.640]  Но даже то, что я сейчас напишу, будет не совсем правдой.
[35:51.640 --> 35:54.640]  Указатели должны быть.
[35:55.640 --> 36:01.640]  Значит, так, PR key value, а называется она, не знаю как.
[36:02.640 --> 36:05.640]  Ну, PR, PR.
[36:05.640 --> 36:07.640]  Не знаю.
[36:07.640 --> 36:10.640]  Давайте я назову ее V. Нет, value плохо ей называть.
[36:10.640 --> 36:13.640]  Ну, давайте KV нижнепочетки PR.
[36:13.640 --> 36:15.640]  KV PR.
[36:15.640 --> 36:17.640]  Ладно, допустим.
[36:17.640 --> 36:18.640]  Значит, key value PR.
[36:18.640 --> 36:20.640]  Давайте просто KV.
[36:20.640 --> 36:22.640]  Давайте просто KV.
[36:22.640 --> 36:23.640]  Так.
[36:23.640 --> 36:25.640]  Но это тоже не совсем правильно.
[36:25.640 --> 36:28.640]  Потому что вот представьте, вы идете итератором по мэпе.
[36:28.640 --> 36:30.640]  И говорите for.
[36:32.640 --> 36:35.640]  Да, ну тут надо написать там.
[36:36.640 --> 36:42.640]  Ладно, давайте я вот первый последний раз в этой жизни, в этом курсе, точнее, напишу.
[36:44.640 --> 36:47.640]  Так как уже нормальные люди не пишут.
[36:47.640 --> 36:50.640]  Значит, я говорю for, auto.
[36:52.640 --> 36:54.640]  It равно.
[36:55.640 --> 36:57.640]  Там у меня есть мэп.
[36:57.640 --> 36:59.640]  Я говорю begin.
[37:00.640 --> 37:02.640]  It не равно.
[37:04.640 --> 37:06.640]  m.end.
[37:06.640 --> 37:12.640]  Нет, я к тому, что обычно range-based for, когда вам мэп надо обойти.
[37:17.640 --> 37:19.640]  KV, 2.
[37:19.640 --> 37:21.640]  Мэп и все.
[37:21.640 --> 37:23.640]  Ага, логично, все хорошо.
[37:23.640 --> 37:25.640]  Plus plus it.
[37:26.640 --> 37:28.640]  Ну да, так, наверное, нормальные люди пишут.
[37:28.640 --> 37:30.640]  Уж точно они не пишут вот так.
[37:30.640 --> 37:32.640]  STD, мэп.
[37:38.640 --> 37:40.640]  Можно авто я напишу, ладно?
[37:40.640 --> 37:44.640]  Мы формально с вами слово авто не проходили, но вы же знаете, как оно работает, правда?
[37:45.640 --> 37:50.640]  STD, мэп в угловых скобочках KV, 2.
[37:50.640 --> 37:52.640]  Это читератор.
[37:52.640 --> 37:59.640]  Теперь представьте, что я такой хулиган, что взял и написал.
[37:59.640 --> 38:05.640]  Под итератором, как мы знаем, у нас лежит пара.
[38:05.640 --> 38:14.640]  Например, если я хочу вывести ключ значения, то мне надо сделать it, стрелочка, first.
[38:14.640 --> 38:16.640]  Это будет ключ.
[38:16.640 --> 38:19.640]  It, стрелочка, second – это будет значение.
[38:21.640 --> 38:25.640]  Стиль именования полей, конечно, оставляет желать лучшего.
[38:25.640 --> 38:29.640]  Поэтому пары не очень любят использовать в продакшн коде.
[38:29.640 --> 38:31.640]  Пишут обычно какие-нибудь свои структуры.
[38:32.640 --> 38:34.640]  Очень понятно.
[38:34.640 --> 38:36.640]  Очень понятно, yes, first и second.
[38:36.640 --> 38:38.640]  Особенно когда it, first, first, second.
[38:38.640 --> 38:40.640]  Вот это вообще...
[38:44.640 --> 38:46.640]  Ну хорошо.
[38:46.640 --> 38:48.640]  У меня вопрос.
[38:48.640 --> 38:51.640]  У меня есть итератор, и этот итератор не константный.
[38:51.640 --> 38:53.640]  Но мэпа не константная.
[38:53.640 --> 38:55.640]  А могу ли я вот так сделать?
[38:56.640 --> 39:02.640]  It, стрелочка, second равно что-нибудь другое.
[39:02.640 --> 39:05.640]  Пяти. Ну мэпа, например, из стринга вы...
[39:07.640 --> 39:09.640]  Об этом и разговор.
[39:11.640 --> 39:16.640]  Вот так я сделать должен мощь, если я итератором иду.
[39:16.640 --> 39:21.640]  Но если я попробую it, стрелочка, first присвоить что-то, это не должно работать.
[39:23.640 --> 39:24.640]  Понятно почему.
[39:24.640 --> 39:30.640]  Ну потому что если бы это работало, если бы такое присваивание было разрешено, то...
[39:34.640 --> 39:35.640]  Вообще все бы сломалось.
[39:35.640 --> 39:37.640]  То дерево бы сломалось, да.
[39:38.640 --> 39:41.640]  Нарушила бы структура мэпа.
[39:41.640 --> 39:43.640]  Это было бы нормально, можно сказать.
[39:43.640 --> 39:45.640]  Ну сделаем за логарифм.
[39:45.640 --> 39:48.640]  Проблема в том, что у нас такой цикл не прокатится.
[39:48.640 --> 39:49.640]  В смысле сделаем за логарифм?
[39:49.640 --> 39:50.640]  Это key.
[39:50.640 --> 39:52.640]  Как ты будешь...
[39:52.640 --> 39:59.640]  Когда ты присваиваешь, делаешь это присваивание, уже никто не знает, что это какой-то элемент дерева.
[40:00.640 --> 40:01.640]  Вот.
[40:01.640 --> 40:05.640]  Поэтому на самом деле тут пара не такая, пара исконский в value.
[40:05.640 --> 40:10.640]  И вот это доставляет особенный бад херд в некоторых ситуациях.
[40:10.640 --> 40:13.640]  Сейчас я вам покажу ситуацию, когда это доставляет бад херд.
[40:15.640 --> 40:19.640]  Представьте, что вы решили вот написать такие умные range-based for.
[40:20.640 --> 40:22.640]  По мэпу.
[40:22.640 --> 40:25.640]  И такие написали for.
[40:25.640 --> 40:27.640]  Ну вы же знаете, что в мэпе лежит?
[40:27.640 --> 40:28.640]  Правильно такие говорите.
[40:28.640 --> 40:30.640]  For std pair.
[40:30.640 --> 40:33.640]  Нет, вот представьте, вы умные, но не настолько.
[40:33.640 --> 40:37.640]  Написали std pair, там key-value.
[40:37.640 --> 40:41.640]  Причем вы же умные, вы такие понимаете, что вы не хотите копировать.
[40:41.640 --> 40:44.640]  Написали const std pair, key-value, ampersand.
[40:44.640 --> 40:47.640]  Кв 2.m.
[40:47.640 --> 40:50.640]  Ну типа для всех пар в мэпе что-то сделать.
[40:50.640 --> 40:55.640]  И такие сидите и думаете наивно, что вы такие умные, молодцы.
[40:55.640 --> 40:57.640]  Избавились от копирования.
[40:57.640 --> 40:59.640]  Красиво range-based for написали.
[40:59.640 --> 41:01.640]  Значит const, ampersand поставили.
[41:01.640 --> 41:02.640]  Вообще все классно.
[41:02.640 --> 41:05.640]  Но нет, на самом деле.
[41:05.640 --> 41:09.640]  Здесь вы все равно копируете при каждом заходе в вершину.
[41:09.640 --> 41:11.640]  Вот если у вас мэп из стринга в int.
[41:11.640 --> 41:13.640]  И вы здесь напишите вот так.
[41:13.640 --> 41:18.640]  const std pair st strings int ampersand kv 2.m.
[41:18.640 --> 41:21.640]  Вы const тут забыли, потому что.
[41:21.640 --> 41:22.640]  Понятно.
[41:22.640 --> 41:27.640]  То есть он должен создать константную ссылку на пару из стринга int.
[41:27.640 --> 41:31.640]  А у него есть пара из const стринга int.
[41:31.640 --> 41:32.640]  Что ему приходится сделать?
[41:32.640 --> 41:35.640]  Ему приходится создать временную пару из обычного стринга int.
[41:35.640 --> 41:37.640]  И вам дать ссылку на нее.
[41:37.640 --> 41:41.640]  То есть вот если вы при таком цикле напишете здесь без конста.
[41:41.640 --> 41:43.640]  У вас будет лишний копирование.
[41:43.640 --> 41:46.640]  Несмотря на то, что казалось бы вы написали и конст, амперсанд здесь.
[41:46.640 --> 41:48.640]  Вот.
[41:48.640 --> 41:50.640]  Поэтому мораль писать авто надо.
[41:50.640 --> 41:52.640]  В таких ситуациях.
[41:52.640 --> 41:53.640]  Вот.
[41:53.640 --> 41:55.640]  Это пример из книжки Скотта Мэйерса.
[41:55.640 --> 41:58.640]  Почему авто обязательно надо писать.
[41:58.640 --> 42:00.640]  Даже когда вам иногда хочется выпендриться.
[42:00.640 --> 42:03.640]  И вы думаете, что знаете тип лучше компилятора.
[42:03.640 --> 42:05.640]  В общем, вы не знаете.
[42:05.640 --> 42:07.640]  Книга называется «Почему не надо писать на C++».
[42:07.640 --> 42:08.640]  Чего-чего?
[42:08.640 --> 42:11.640]  Почему эта книга не называется «Почему не надо писать на C++»?
[42:11.640 --> 42:13.640]  Ну...
[42:13.640 --> 42:15.640]  Да, реально.
[42:15.640 --> 42:18.640]  Книга называется «Эффективный современный C++».
[42:18.640 --> 42:20.640]  Эффективнее.
[42:20.640 --> 42:22.640]  Современнее.
[42:25.640 --> 42:26.640]  Вот. Окей.
[42:26.640 --> 42:27.640]  Так, ладно.
[42:27.640 --> 42:29.640]  Мы поняли, что у нас вот такая вот штука здесь лежит.
[42:29.640 --> 42:31.640]  И еще флажочек буль.
[42:31.640 --> 42:33.640]  Так вот.
[42:33.640 --> 42:35.640]  Конечно, конста...
[42:35.640 --> 42:37.640]  Да, разумеется, если вы пишете авто,
[42:37.640 --> 42:39.640]  то никто вам...
[42:39.640 --> 42:41.640]  Никто не избавляет вас от необходимости писать конст
[42:41.640 --> 42:43.640]  в начале и амперсант в конце.
[42:43.640 --> 42:45.640]  Если вы просто напишите forAutoKv,
[42:45.640 --> 42:47.640]  это будет ничем не лучше, что вы будете просто копировать.
[42:47.640 --> 42:49.640]  Вы можете не писать?
[42:49.640 --> 42:53.640]  Ну, если вы хотите разрешить себе изменения, то да.
[42:53.640 --> 42:56.640]  Ну, вы можете писать forAutoAmpersandKv, да.
[42:56.640 --> 42:58.640]  Но тогда эта пара будет не константной.
[42:58.640 --> 43:00.640]  И для автоамперсанта он копируется будет или нет?
[43:00.640 --> 43:02.640]  Нет, конечно, он не будет.
[43:02.640 --> 43:04.640]  Вы можете писать, потому что по ссылке.
[43:06.640 --> 43:08.640]  Вот так.
[43:08.640 --> 43:10.640]  Так вот, возвращаемся к функции insert.
[43:10.640 --> 43:12.640]  Так вот, insert, соответственно, принимает пару.
[43:14.640 --> 43:16.640]  Insert принимает const pair
[43:16.640 --> 43:18.640]  от const k,
[43:18.640 --> 43:20.640]  запятая value.
[43:25.640 --> 43:27.640]  Кстати, начиная с 7 плюс плюс 20 можно.
[43:27.640 --> 43:29.640]  Что?
[43:29.640 --> 43:31.640]  Что вы не знали об этом?
[43:31.640 --> 43:33.640]  Здрасьте.
[43:33.640 --> 43:35.640]  Отдельный уголь музыки.
[43:35.640 --> 43:37.640]  Да почему?
[43:37.640 --> 43:39.640]  Это действительно.
[43:39.640 --> 43:41.640]  Будем считать, что авто-авто-авто-авто.
[43:41.640 --> 43:43.640]  Так когда выходил C++14,
[43:43.640 --> 43:45.640]  по-моему, или 17,
[43:45.640 --> 43:47.640]  по-моему, когда выходил C++14,
[43:47.640 --> 43:49.640]  уже были мемы о том, что
[43:49.640 --> 43:51.640]  в C++, не знаю, 40
[43:51.640 --> 43:53.640]  можно будет писать авто-авто-авто-авто-авто,
[43:53.640 --> 43:55.640]  и компилятор сам догадается,
[43:55.640 --> 43:57.640]  что вы хотели
[43:57.640 --> 43:59.640]  записать.
[43:59.640 --> 44:01.640]  Ой, а кстати,
[44:01.640 --> 44:03.640]  как вчера? Вчера же был первый контест
[44:03.640 --> 44:05.640]  в истории кэфа, в котором участвовал
[44:05.640 --> 44:07.640]  искусственный интеллект.
[44:07.640 --> 44:09.640]  Нет? А что они делали?
[44:13.640 --> 44:15.640]  А, то есть это был такой
[44:15.640 --> 44:17.640]  clickbait, но...
[44:21.640 --> 44:23.640]  Ну, потому что, да,
[44:23.640 --> 44:25.640]  мне надоело писать STD.
[44:25.640 --> 44:27.640]  Знакомое чувство.
[44:31.640 --> 44:33.640]  Ну, я же на доске пишу, если бы.
[44:33.640 --> 44:35.640]  Ну, на самом деле, слушайте,
[44:35.640 --> 44:37.640]  на самом деле, поскольку
[44:37.640 --> 44:39.640]  я могу оправдаться тем, что я
[44:39.640 --> 44:41.640]  пишу код самого мэпа,
[44:41.640 --> 44:43.640]  а там уж точно STD не написан,
[44:43.640 --> 44:45.640]  потому что мы унухавнимся уже в пространстве STD,
[44:45.640 --> 44:47.640]  когда пишем код мэпа.
[44:47.640 --> 44:49.640]  Поэтому, когда мы
[44:49.640 --> 44:51.640]  функции мэпа описываем, не надо
[44:51.640 --> 44:53.640]  STD упоминать.
[44:53.640 --> 44:55.640]  Вот. Ну, короче, чтобы вот
[44:55.640 --> 44:57.640]  это все не повторять, у этого есть
[44:57.640 --> 44:59.640]  специальное название. Это называется value type.
[45:01.640 --> 45:03.640]  Вот, да.
[45:03.640 --> 45:05.640]  В мэпе есть
[45:05.640 --> 45:07.640]  внутренний тип, который называется
[45:07.640 --> 45:09.640]  value type. И это
[45:09.640 --> 45:11.640]  как раз вот это.
[45:11.640 --> 45:13.640]  Это pair из const k,
[45:13.640 --> 45:15.640]  запятая value. То есть здесь на самом деле
[45:15.640 --> 45:17.640]  можно написать value type просто.
[45:17.640 --> 45:19.640]  Ну, вот это не называется
[45:19.640 --> 45:21.640]  value. Это мы его так называем.
[45:21.640 --> 45:23.640]  А у них называется...
[45:23.640 --> 45:25.640]  Ну, слушай, я не знаю,
[45:25.640 --> 45:27.640]  как оно называется. Ну, это дело
[45:27.640 --> 45:29.640]  их. Ну, вот это просто
[45:29.640 --> 45:31.640]  value type.
[45:31.640 --> 45:33.640]  Value type.
[45:35.640 --> 45:37.640]  Вообще, если
[45:37.640 --> 45:39.640]  вы были
[45:39.640 --> 45:41.640]  внимательными, то
[45:41.640 --> 45:43.640]  в каждом контейнере есть value type,
[45:43.640 --> 45:45.640]  и в векторе есть value type, и в листе
[45:45.640 --> 45:47.640]  есть value type.
[45:47.640 --> 45:49.640]  Но...
[45:51.640 --> 45:53.640]  Да, просто
[45:53.640 --> 45:55.640]  пара, но из const ключа в значении.
[45:55.640 --> 45:57.640]  Соответственно, здесь можно
[45:57.640 --> 45:59.640]  тоже написать, что мы принимаем const
[45:59.640 --> 46:01.640]  value type ampersand.
[46:01.640 --> 46:03.640]  Вот.
[46:03.640 --> 46:05.640]  Ну, и что происходит?
[46:05.640 --> 46:07.640]  Ну, просто
[46:07.640 --> 46:09.640]  там
[46:09.640 --> 46:11.640]  спускаемся по дереву до нужного места,
[46:11.640 --> 46:13.640]  вставляем сразу вот...
[46:13.640 --> 46:15.640]  Да. Ну, в общем,
[46:15.640 --> 46:17.640]  вы прекрасно знаете, что происходит.
[46:17.640 --> 46:19.640]  Вот. С Филиппом обсуждали,
[46:19.640 --> 46:21.640]  я думаю.
[46:21.640 --> 46:23.640]  Вот. Что, если уже такой ключ
[46:23.640 --> 46:25.640]  был? Тогда
[46:25.640 --> 46:27.640]  вы не... Нет, конечно.
[46:27.640 --> 46:29.640]  Конечно, нет. Так это не происходит.
[46:29.640 --> 46:31.640]  Нет.
[46:31.640 --> 46:33.640]  Если у вас был уже такой ключ, то
[46:33.640 --> 46:35.640]  ничего не произойдет.
[46:35.640 --> 46:37.640]  Потому что map хранит
[46:37.640 --> 46:39.640]  только один ключ с каждым value.
[46:39.640 --> 46:41.640]  И если вы insert сделали
[46:41.640 --> 46:43.640]  в мэпе, в котором уже был такой ключ, считается, что
[46:43.640 --> 46:45.640]  ну, типа, нет.
[46:45.640 --> 46:47.640]  Значит, не надо вставлять.
[46:47.640 --> 46:49.640]  Раньше уже было лучше.
[46:49.640 --> 46:51.640]  Поэтому insert имеет
[46:51.640 --> 46:53.640]  довольно странный возвращаемый тип.
[46:53.640 --> 46:55.640]  И опять же, если вы были внимательными...
[46:55.640 --> 46:57.640]  А, может, я это не упоминал.
[46:57.640 --> 46:59.640]  Короче,
[46:59.640 --> 47:01.640]  insert, он же должен вам вернуть
[47:01.640 --> 47:03.640]  что? Он должен вам одновременно
[47:03.640 --> 47:05.640]  вернуть информацию о том,
[47:05.640 --> 47:07.640]  вставил ли, а еще если вставился, то
[47:07.640 --> 47:09.640]  куда.
[47:09.640 --> 47:11.640]  Да, он возвращает пару.
[47:11.640 --> 47:13.640]  Значит, insert он возвращает
[47:13.640 --> 47:15.640]  по этой причине пару из
[47:15.640 --> 47:17.640]  буля
[47:17.640 --> 47:19.640]  и итератора.
[47:21.640 --> 47:23.640]  То есть, если он вставил,
[47:23.640 --> 47:25.640]  то там будет true,
[47:25.640 --> 47:27.640]  по-моему, и итератор будет
[47:27.640 --> 47:29.640]  показывать на место, куда он вставил.
[47:29.640 --> 47:31.640]  Утоги.
[47:31.640 --> 47:33.640]  А? Что?
[47:35.640 --> 47:37.640]  Для итератора есть end.
[47:37.640 --> 47:39.640]  Ну, наверное, да.
[47:39.640 --> 47:41.640]  Можно ли проинцелизировать
[47:41.640 --> 47:43.640]  итератор на ОПТР? Думаю, нельзя.
[47:45.640 --> 47:47.640]  Вот, такие дела. Это insert.
[47:47.640 --> 47:49.640]  Теперь вопрос.
[47:49.640 --> 47:51.640]  А зачем вообще нужен insert?
[47:51.640 --> 47:53.640]  Если, казалось бы,
[47:53.640 --> 47:55.640]  всегда... А, еще есть find.
[47:55.640 --> 47:57.640]  Вот еще вопрос. Вот еще штука. Есть еще find.
[47:57.640 --> 47:59.640]  Find
[47:59.640 --> 48:01.640]  он принимает ключ тоже.
[48:03.640 --> 48:05.640]  И по ключу
[48:05.640 --> 48:07.640]  вам возвращает не value,
[48:07.640 --> 48:09.640]  а итератор.
[48:11.640 --> 48:13.640]  И если он ничего
[48:13.640 --> 48:15.640]  не нашел, то он вернет вам end.
[48:17.640 --> 48:19.640]  Ну, есть еще и raise.
[48:19.640 --> 48:21.640]  Который тоже принимает
[48:21.640 --> 48:23.640]  там ключ
[48:23.640 --> 48:25.640]  по ссылке и возвращает
[48:25.640 --> 48:27.640]  просто буль, да.
[48:27.640 --> 48:29.640]  Так вот.
[48:29.640 --> 48:31.640]  Вопрос. Зачем нужно
[48:31.640 --> 48:33.640]  find, insert?
[48:33.640 --> 48:35.640]  Зачем вот это нужно?
[48:35.640 --> 48:37.640]  Если, казалось бы...
[48:37.640 --> 48:39.640]  Нет, insert, ладно. Insert, понятно, зачем.
[48:39.640 --> 48:41.640]  А зачем find?
[48:41.640 --> 48:43.640]  Можно же просто, там, не знаю,
[48:43.640 --> 48:45.640]  квадратными скобочками
[48:45.640 --> 48:47.640]  пользоваться.
[48:47.640 --> 48:49.640]  А, еще есть метод count.
[48:49.640 --> 48:51.640]  Еще есть метод count по ключу,
[48:51.640 --> 48:53.640]  который говорит, сколько
[48:53.640 --> 48:55.640]  вершин с таким ключом.
[48:55.640 --> 48:57.640]  Почему он возвращает только либо 0, либо 1?
[48:57.640 --> 48:59.640]  Почему он называется count?
[48:59.640 --> 49:01.640]  Да потому что есть еще multimap
[49:01.640 --> 49:03.640]  с аналогичным абсолютно интерфейсом.
[49:05.640 --> 49:07.640]  Не, почему? Multimap вполне себе полезно.
[49:07.640 --> 49:09.640]  Multiset.
[49:09.640 --> 49:11.640]  А нету там вращения по ключу.
[49:11.640 --> 49:13.640]  Но есть count.
[49:17.640 --> 49:19.640]  Ну, как? Нет, есть find.
[49:19.640 --> 49:21.640]  Который возвращает тебе
[49:21.640 --> 49:23.640]  первые, там, первые вхождения.
[49:23.640 --> 49:25.640]  Сейчас про multimap
[49:25.640 --> 49:27.640]  поговорим. Так вот, короче, есть
[49:27.640 --> 49:29.640]  count, который, он
[49:29.640 --> 49:31.640]  так называется, потому что он общий для
[49:31.640 --> 49:33.640]  мэпа и multimapa, чтобы вам
[49:33.640 --> 49:35.640]  ну, чтобы интерфейс был одинаковый.
[49:35.640 --> 49:37.640]  Но в случае мэпа,
[49:37.640 --> 49:39.640]  в случае мэпа он возвращает только 0, либо 1.
[49:39.640 --> 49:41.640]  Так вот вопрос, зачем нужен
[49:41.640 --> 49:43.640]  find в мэпе?
[49:43.640 --> 49:45.640]  Если, нет, ну, в multimap
[49:45.640 --> 49:47.640]  ну, вот, для мэпа вообще find.
[49:47.640 --> 49:49.640]  Хорошо.
[49:49.640 --> 49:51.640]  А его вообще
[49:51.640 --> 49:53.640]  надо использовать? Почему нельзя пользоваться
[49:53.640 --> 49:55.640]  count и квадратными скобочками? Это же проще.
[49:59.640 --> 50:01.640]  Потому что set реализовывал на мэп.
[50:01.640 --> 50:03.640]  Чё?
[50:03.640 --> 50:05.640]  Может count и квадратные скобочки надо проверять?
[50:05.640 --> 50:07.640]  А?
[50:09.640 --> 50:11.640]  Значит, правильный ответ, потому что
[50:11.640 --> 50:13.640]  find эффективнее.
[50:13.640 --> 50:15.640]  Вот.
[50:15.640 --> 50:17.640]  Есть просто
[50:17.640 --> 50:19.640]  такое, не знаю, упражнение.
[50:19.640 --> 50:21.640]  Можно там где-нибудь,
[50:21.640 --> 50:23.640]  может где-нибудь встретиться, например, на экзамене.
[50:23.640 --> 50:25.640]  Такую задачу. Вот у вас будет обход
[50:25.640 --> 50:27.640]  мэпа, и там будет делаться что-нибудь в таком
[50:27.640 --> 50:29.640]  духе. Если мэп.count
[50:29.640 --> 50:31.640]  такой-то ключ, то по этому ключу
[50:31.640 --> 50:33.640]  что-нибудь изменить.
[50:33.640 --> 50:35.640]  Нельзя ли это как-то оптимизировать? Ну, можно.
[50:35.640 --> 50:37.640]  Надо просто find-ом пользоваться вместо
[50:37.640 --> 50:39.640]  count и квадратными скобочками. Потому что
[50:39.640 --> 50:41.640]  если вы пользуетесь count-ом,
[50:41.640 --> 50:43.640]  каждый вызов count-а
[50:43.640 --> 50:45.640]  это логарифом операции, проход
[50:45.640 --> 50:47.640]  по дереву. И квадратные скобочки
[50:47.640 --> 50:49.640]  это ещё один проход по дереву. То есть, если для
[50:49.640 --> 50:51.640]  того, чтобы положить элемент в мэп,
[50:51.640 --> 50:53.640]  в зависимости того, лежал ли там элемент,
[50:53.640 --> 50:55.640]  вы делаете сначала count, потом квадратные
[50:55.640 --> 50:57.640]  скобочки, вы два раза спускаетесь по
[50:57.640 --> 50:59.640]  дереву, хотя могли бы всего один раз спускаться
[50:59.640 --> 51:01.640]  find-ом.
[51:01.640 --> 51:03.640]  Это лишний проход по дереву просто.
[51:03.640 --> 51:05.640]  Вот как раз за счёт того, что итератор
[51:05.640 --> 51:07.640]  это очень такой C++
[51:07.640 --> 51:09.640]  стайл настоящий. Настоящие плюсовики
[51:09.640 --> 51:11.640]  они вот, которые топят за
[51:11.640 --> 51:13.640]  оптимизацию, они вот скорее этим пользуются.
[51:13.640 --> 51:15.640]  Потому что, ну, понятно.
[51:15.640 --> 51:17.640]  Вы экономите.
[51:17.640 --> 51:19.640]  Ну, потому что если ты хочешь
[51:19.640 --> 51:21.640]  сделать, если у тебя в дереве
[51:21.640 --> 51:23.640]  лежит эта штука, то там заменить её
[51:23.640 --> 51:25.640]  на такую-то, а иначе ничего не делать, допустим.
[51:25.640 --> 51:27.640]  Ты хочешь там,
[51:27.640 --> 51:29.640]  если у меня в дереве есть ключ 1,
[51:29.640 --> 51:31.640]  то по ключу 1 сделаю значение 10.
[51:31.640 --> 51:33.640]  Ну, а если нет, значит ничего
[51:33.640 --> 51:35.640]  не делать. Вот такое действие
[51:35.640 --> 51:37.640]  тебе хочется совершить. И мог бы написать
[51:37.640 --> 51:39.640]  if count 1,
[51:39.640 --> 51:41.640]  значит, квадратные скобочки по единице
[51:41.640 --> 51:43.640]  присвоить 10. Но это два прохода
[51:43.640 --> 51:45.640]  по дереву, потому что и count занимает логарифом,
[51:45.640 --> 51:47.640]  и квадратные скобочки занимают логарифом.
[51:47.640 --> 51:49.640]  А find
[51:49.640 --> 51:51.640]  один раз только прошёл, получил итератор,
[51:51.640 --> 51:53.640]  посмотрел end ли это,
[51:53.640 --> 51:55.640]  и если не end, то по нему бы
[51:55.640 --> 51:57.640]  поменял значение.
[51:57.640 --> 51:59.640]  Вот, это разговор про эффективность.
[51:59.640 --> 52:01.640]  Ну, а теперь про...
[52:01.640 --> 52:03.640]  Да.
[52:11.640 --> 52:13.640]  Insert.
[52:13.640 --> 52:15.640]  В смысле, ну он вернёт false
[52:15.640 --> 52:17.640]  и какой-то итератор.
[52:21.640 --> 52:23.640]  Да, куда он мог бы вставить. Итератор
[52:23.640 --> 52:25.640]  уже находящийся в дереве
[52:25.640 --> 52:27.640]  вершину, скорее всего.
[52:29.640 --> 52:31.640]  А, типа, почему...
[52:31.640 --> 52:33.640]  Почему бы не возвращать просто end?
[52:33.640 --> 52:35.640]  Если что.
[52:35.640 --> 52:37.640]  Хороший вопрос.
[52:37.640 --> 52:39.640]  Нет, если нашёл наоборот.
[52:39.640 --> 52:41.640]  Да, если так, если нашёл...
[52:41.640 --> 52:43.640]  Видимо, потому что он хочет возвращать...
[52:43.640 --> 52:45.640]  Вопрос, что он возвращает на самом деле.
[52:45.640 --> 52:47.640]  Скорее всего, он возвращает итератор
[52:47.640 --> 52:49.640]  на ту вершину, которую он нашёл с таким же ключом.
[52:49.640 --> 52:51.640]  Скорее всего, когда писали ключи.
[52:51.640 --> 52:53.640]  А, ну да.
[52:53.640 --> 52:55.640]  Наверное, да. Наверное, правильно. Наверное, так и есть.
[52:55.640 --> 52:57.640]  Логично, что он возвращает
[52:57.640 --> 52:59.640]  не end, потому что если ты сделал
[52:59.640 --> 53:01.640]  insert, значит, логично, что хочешь сразу понять,
[53:01.640 --> 53:03.640]  где оно. Если оно там было, то тебе
[53:03.640 --> 53:05.640]  на него сразу и покажут.
[53:05.640 --> 53:07.640]  А bullet, чтобы понять, произошла вставка реально сейчас
[53:07.640 --> 53:09.640]  или нет. Да, вот поэтому.
[53:09.640 --> 53:11.640]  Кажется, поэтому.
[53:11.640 --> 53:13.640]  Так, ну давайте, раз
[53:13.640 --> 53:15.640]  уже зашёл разговор, сейчас про мульти мы ещё
[53:15.640 --> 53:17.640]  обсудим, чем он отличается, и
[53:17.640 --> 53:19.640]  потом...
[53:19.640 --> 53:21.640]  Неважно, что потом.
[53:21.640 --> 53:23.640]  В общем, мульти-мэп.
[53:23.640 --> 53:25.640]  Когда у вас много
[53:25.640 --> 53:27.640]  вершин с одинаковым ключом, может быть.
[53:27.640 --> 53:29.640]  А там
[53:29.640 --> 53:31.640]  отсутствуют квадратные скобки
[53:31.640 --> 53:33.640]  и add тоже отсутствует,
[53:33.640 --> 53:35.640]  потому что ссылку не на что возвращать.
[53:35.640 --> 53:37.640]  А как в мульти-мэпе искать?
[53:37.640 --> 53:39.640]  Ну вот с помощью файнда, а ещё есть
[53:39.640 --> 53:41.640]  очень полезные методы, которые
[53:41.640 --> 53:43.640]  в самом мэпе тоже есть.
[53:43.640 --> 53:45.640]  Но для мульти-мэпа они гораздо более актуальны.
[53:45.640 --> 53:47.640]  Где-то lower bound и upper bound.
[53:49.640 --> 53:51.640]  Lower bound
[53:51.640 --> 53:53.640]  и upper bound.
[53:55.640 --> 53:57.640]  Ну да, они полезны, если вам
[53:57.640 --> 53:59.640]  надо...
[53:59.640 --> 54:01.640]  Ну понятно, зачем они нужны.
[54:01.640 --> 54:03.640]  Lower bound возвращает вам
[54:03.640 --> 54:05.640]  первое из значений с таким ключом,
[54:05.640 --> 54:07.640]  а upper bound возвращает вам
[54:07.640 --> 54:09.640]  итератор, да, конечно, на него.
[54:09.640 --> 54:11.640]  Не само значение.
[54:11.640 --> 54:13.640]  А upper bound возвращает
[54:13.640 --> 54:15.640]  вам первое из значений,
[54:15.640 --> 54:17.640]  в котором ключ больше данного.
[54:21.640 --> 54:23.640]  Не помню.
[54:25.640 --> 54:27.640]  Думаю, что
[54:27.640 --> 54:29.640]  значение он не сортирует,
[54:29.640 --> 54:31.640]  потому что
[54:31.640 --> 54:33.640]  компараторы для них
[54:33.640 --> 54:35.640]  не обязаны существовать.
[54:35.640 --> 54:37.640]  Я думаю, что рандомно.
[54:37.640 --> 54:39.640]  Не гарантируется порядок.
[54:39.640 --> 54:41.640]  Вот.
[54:41.640 --> 54:43.640]  Еще есть значение,
[54:43.640 --> 54:45.640]  еще есть функция equal range.
[54:49.640 --> 54:51.640]  Это
[54:51.640 --> 54:53.640]  штука
[54:53.640 --> 54:55.640]  возвращает вам
[54:55.640 --> 54:57.640]  пару итераторов.
[54:57.640 --> 54:59.640]  Ну, то есть, если вы хотите lower bound
[54:59.640 --> 55:01.640]  и upper bound одновременно, может, если это equal range.
[55:01.640 --> 55:03.640]  Возвращает вам, типа,
[55:03.640 --> 55:05.640]  начало и конец под диапазоном
[55:05.640 --> 55:07.640]  мэпа, в котором...
[55:07.640 --> 55:09.640]  Ну,
[55:09.640 --> 55:11.640]  думаю, да.
[55:11.640 --> 55:13.640]  Ну, правильно, потому что когда ты пришел,
[55:13.640 --> 55:15.640]  ты уже видел, что ключ одинаковый,
[55:15.640 --> 55:17.640]  ты не будешь спускаться заново сверху с корня,
[55:17.640 --> 55:19.640]  ты поймешь, что вот тут у тебя уже...
[55:21.640 --> 55:23.640]  Вот, окей.
[55:23.640 --> 55:25.640]  Соответственно, с помощью этого по мультимэпу
[55:25.640 --> 55:27.640]  можно ходить,
[55:27.640 --> 55:29.640]  мультимэпу пользоваться.
[55:29.640 --> 55:31.640]  То есть, да, для успешного использования
[55:31.640 --> 55:33.640]  всей этой машинерии нужно хорошо
[55:33.640 --> 55:35.640]  понимать, что такое итераторы.
[55:35.640 --> 55:37.640]  Но давайте еще поговорим теперь про итераторы.
[55:39.640 --> 55:41.640]  Как работает обход
[55:41.640 --> 55:43.640]  итератором? Во-первых, какие
[55:43.640 --> 55:45.640]  итераторы вообще в мэпе?
[55:45.640 --> 55:47.640]  Веселые.
[55:47.640 --> 55:49.640]  Веселые, нет таких,
[55:49.640 --> 55:51.640]  нет такой разной истины итераторов.
[55:51.640 --> 55:53.640]  Bidirectional итераторы в мэпе, конечно.
[55:53.640 --> 55:55.640]  Можешь ходить вперед-назад.
[55:55.640 --> 55:57.640]  В частности,
[55:57.640 --> 55:59.640]  понимаете ли вы, вот,
[55:59.640 --> 56:01.640]  не все понимают, ну, из вас может и все,
[56:01.640 --> 56:03.640]  вы же понимаете, что нельзя написать
[56:03.640 --> 56:05.640]  вот так, там.
[56:05.640 --> 56:07.640]  Ну, вообще,
[56:07.640 --> 56:09.640]  кайф.
[56:09.640 --> 56:11.640]  СЕ.
[56:11.640 --> 56:13.640]  СЕ,
[56:13.640 --> 56:15.640]  СЕ, ошибка в компиляции,
[56:15.640 --> 56:17.640]  потому что Bidirectional итераторы
[56:17.640 --> 56:19.640]  нет такого оператора для них.
[56:19.640 --> 56:21.640]  У кого?
[56:21.640 --> 56:23.640]  Как это нет?
[56:23.640 --> 56:25.640]  Он, в частный случай,
[56:25.640 --> 56:27.640]  рандомакс из итератора.
[56:31.640 --> 56:33.640]  У Вектора такие итераторы.
[56:37.640 --> 56:39.640]  Ну, вот.
[56:39.640 --> 56:41.640]  И еще, например, нельзя написать вот так.
[56:45.640 --> 56:47.640]  Ну, просто не всем может быть очевидно,
[56:47.640 --> 56:49.640]  я на всякий случай уточняю.
[56:49.640 --> 56:51.640]  Это СЕ.
[56:51.640 --> 56:53.640]  Так вот.
[56:53.640 --> 56:55.640]  Как работает обход итератором?
[56:55.640 --> 56:57.640]  Ну, во-первых, с чего начинается?
[56:57.640 --> 56:59.640]  Вот если вас спросили Begin,
[56:59.640 --> 57:01.640]  то это как работает?
[57:03.640 --> 57:05.640]  Возвращаем, сохраняем на ссылку.
[57:05.640 --> 57:07.640]  Вот поэтому нам, вероятно,
[57:07.640 --> 57:09.640]  надо еще хранить
[57:09.640 --> 57:11.640]  указатель на вершину,
[57:11.640 --> 57:13.640]  которая...
[57:13.640 --> 57:15.640]  Крайняя левая.
[57:15.640 --> 57:17.640]  Крайняя левая.
[57:17.640 --> 57:19.640]  Ну, вот Begin
[57:19.640 --> 57:21.640]  все-таки хочется, чтобы за единицу
[57:21.640 --> 57:23.640]  работал, наверное.
[57:23.640 --> 57:25.640]  Потому что, ну, как-то...
[57:27.640 --> 57:29.640]  Мы же миллионеры.
[57:29.640 --> 57:31.640]  Хотя, это память...
[57:31.640 --> 57:33.640]  Мы же себе позволили три...
[57:33.640 --> 57:35.640]  Да, мы же позволили себе по три в каждой вершине.
[57:35.640 --> 57:37.640]  А это одна и все дерево.
[57:37.640 --> 57:39.640]  Так.
[57:39.640 --> 57:41.640]  Дальше.
[57:41.640 --> 57:43.640]  Я написал Beg, чтобы не было коллизий
[57:43.640 --> 57:45.640]  с словом Begin.
[57:45.640 --> 57:47.640]  Вот. Хорошо.
[57:47.640 --> 57:49.640]  Теперь.
[57:49.640 --> 57:51.640]  Как, значит, работают шаги итератора?
[57:51.640 --> 57:53.640]  Ну, понятно, что...
[57:53.640 --> 57:55.640]  Если вам нужно инкрементировать,
[57:55.640 --> 57:57.640]  вы...
[57:57.640 --> 57:59.640]  Ну, понятно, что вы делаете.
[57:59.640 --> 58:01.640]  Вы идете вверх, возможно, какое-то количество времени,
[58:01.640 --> 58:03.640]  пока вы правый сын.
[58:03.640 --> 58:05.640]  Нет, вы сначала проверяете, нет ли у вас правого сына.
[58:05.640 --> 58:07.640]  Если есть правый сын, то вы идете в него.
[58:07.640 --> 58:09.640]  Да.
[58:09.640 --> 58:11.640]  Если у вас нет правого сына, то вы идете вверх, пока вы левый сын.
[58:11.640 --> 58:13.640]  Господи.
[58:13.640 --> 58:15.640]  Да.
[58:15.640 --> 58:17.640]  Было бы смешнее, если бы
[58:17.640 --> 58:19.640]  ты говорила первого лица.
[58:19.640 --> 58:21.640]  Я иду на левый сын.
[58:21.640 --> 58:23.640]  Так.
[58:23.640 --> 58:25.640]  Вопрос.
[58:25.640 --> 58:27.640]  За сколько работает инкремент
[58:27.640 --> 58:29.640]  итератора в мэпе?
[58:29.640 --> 58:31.640]  За амортизированную тени?
[58:31.640 --> 58:33.640]  Нет.
[58:33.640 --> 58:35.640]  И это тоже правда?
[58:35.640 --> 58:37.640]  Нет, это неправда.
[58:37.640 --> 58:39.640]  Это гораздо более слабое утверждение.
[58:39.640 --> 58:41.640]  Ну, сейчас.
[58:41.640 --> 58:43.640]  Если несколько раз подряд прибавить,
[58:43.640 --> 58:45.640]  то там будет зологариф плюс количество...
[58:45.640 --> 58:47.640]  Да, это верно, к сожалению.
[58:47.640 --> 58:49.640]  Хорошо.
[58:49.640 --> 58:51.640]  Я хотел сказать другое утверждение,
[58:51.640 --> 58:53.640]  что если вы проходите весь мэп,
[58:53.640 --> 58:55.640]  то это суммарно работает за вот
[58:55.640 --> 58:57.640]  количество элементов в мэпе.
[58:57.640 --> 58:59.640]  Это не то же самое, что
[58:59.640 --> 59:01.640]  амортизированного от единицы.
[59:01.640 --> 59:03.640]  Потому что если вы возьмете
[59:03.640 --> 59:05.640]  подотрезок, то там на подотрезке
[59:05.640 --> 59:07.640]  на каком-то может быть не так.
[59:07.640 --> 59:09.640]  Что такое амортизированного от единицы?
[59:09.640 --> 59:11.640]  По определению, это когда
[59:11.640 --> 59:13.640]  если сделать каких-то
[59:13.640 --> 59:15.640]  операций в плюс-плюс н штук,
[59:15.640 --> 59:17.640]  должно суммарно отработать за вот н.
[59:17.640 --> 59:19.640]  Ну, я могу привести пример.
[59:19.640 --> 59:21.640]  Над одним и тем же контейнером?
[59:21.640 --> 59:23.640]  Да.
[59:23.640 --> 59:25.640]  Но не обязательно инкремент одного и того же итератора?
[59:25.640 --> 59:27.640]  А, ну все, тогда понятно.
[59:27.640 --> 59:29.640]  Просто у меня много итераторов,
[59:29.640 --> 59:31.640]  и ты будешь один и тот же инкрементировать
[59:31.640 --> 59:33.640]  многократно.
[59:33.640 --> 59:35.640]  Да, хорошо, ладно, я понял.
[59:35.640 --> 59:37.640]  Но
[59:37.640 --> 59:39.640]  более важно, что
[59:39.640 --> 59:41.640]  обход всего мэпа работает за вот н,
[59:41.640 --> 59:43.640]  несмотря на то, что отдельные шаги могут быть
[59:43.640 --> 59:45.640]  за логорифом. Почему обход
[59:45.640 --> 59:47.640]  всего мэпа работает за вот н?
[59:47.640 --> 59:49.640]  Потому что вы каждую
[59:49.640 --> 59:51.640]  вершину там посещаете в общей
[59:51.640 --> 59:53.640]  сложности.
[59:53.640 --> 59:55.640]  Ну, вы в нее один раз войдете, один раз
[59:55.640 --> 59:57.640]  выйдете по каждому из направлений.
[59:57.640 --> 59:59.640]  Суммарно у вас будет там, типа,
[59:59.640 --> 01:00:01.640]  что-то типа шесть н, что ли,
[01:00:01.640 --> 01:00:03.640]  операции на вершину.
[01:00:03.640 --> 01:00:05.640]  Шесть операций на каждую вершину.
[01:00:05.640 --> 01:00:07.640]  И, то есть, весь обход
[01:00:07.640 --> 01:00:09.640]  работает за количество элементов.
[01:00:09.640 --> 01:00:11.640]  Вот, это
[01:00:11.640 --> 01:00:13.640]  важное замечание. Вот в
[01:00:13.640 --> 01:00:15.640]  onward death map'е
[01:00:15.640 --> 01:00:17.640]  будет интересней с этим.
[01:00:17.640 --> 01:00:19.640]  Ну ладно, теперь вопрос.
[01:00:19.640 --> 01:00:21.640]  Что такое н?
[01:00:21.640 --> 01:00:23.640]  Так просто взяли, создаем
[01:00:23.640 --> 01:00:25.640]  эффективную штуку.
[01:00:27.640 --> 01:00:29.640]  Крайний правый и там какой-нибудь...
[01:00:29.640 --> 01:00:31.640]  А минус?
[01:00:31.640 --> 01:00:33.640]  Да, надо, чтобы минус-минус н давал
[01:00:33.640 --> 01:00:35.640]  крайнего правого... крайнюю правую
[01:00:35.640 --> 01:00:37.640]  вершину в дереве.
[01:00:37.640 --> 01:00:39.640]  Крайнего правого плюс-плюс делаем, и все.
[01:00:39.640 --> 01:00:41.640]  Что получилось?
[01:00:41.640 --> 01:00:43.640]  Мы берем
[01:00:43.640 --> 01:00:45.640]  спускаемся с самого правого сына и делаем
[01:00:45.640 --> 01:00:47.640]  эффективного правого сына у него.
[01:00:47.640 --> 01:00:49.640]  Или на минус-минус, да?
[01:00:49.640 --> 01:00:51.640]  Мы берем дерево, эффективный саб, супербольшой элемент.
[01:00:51.640 --> 01:00:53.640]  Нет, можно просто эффективную вершину создать,
[01:00:53.640 --> 01:00:55.640]  типа, у крайнего правого.
[01:00:55.640 --> 01:00:57.640]  Если ты...
[01:00:57.640 --> 01:00:59.640]  Ну, может, я не знаю.
[01:00:59.640 --> 01:01:01.640]  Если ему идет эффективная вершина...
[01:01:01.640 --> 01:01:03.640]  Это будет наибольшая вершина.
[01:01:03.640 --> 01:01:05.640]  Да, по-моему.
[01:01:05.640 --> 01:01:07.640]  Сейчас, вы хотите сделать
[01:01:07.640 --> 01:01:09.640]  эффективного правого сына у самой правой
[01:01:09.640 --> 01:01:11.640]  вершины?
[01:01:11.640 --> 01:01:13.640]  Так, и минус-минус тогда
[01:01:13.640 --> 01:01:15.640]  от него будет...
[01:01:15.640 --> 01:01:17.640]  Ага.
[01:01:17.640 --> 01:01:19.640]  Что вам надо?
[01:01:19.640 --> 01:01:21.640]  Этим эффективным элементом.
[01:01:21.640 --> 01:01:23.640]  Ну...
[01:01:23.640 --> 01:01:25.640]  Еще раз.
[01:01:25.640 --> 01:01:27.640]  Вам придется и впасть,
[01:01:27.640 --> 01:01:29.640]  все.
[01:01:29.640 --> 01:01:31.640]  Нет, нет, нет.
[01:01:31.640 --> 01:01:33.640]  Подожди.
[01:01:33.640 --> 01:01:35.640]  Я хочу добавить...
[01:01:35.640 --> 01:01:37.640]  Минус-минус, да?
[01:01:37.640 --> 01:01:39.640]  А lower bound ты как будешь делать?
[01:01:39.640 --> 01:01:41.640]  Стой, подожди. Ты хочешь добавить вершину
[01:01:41.640 --> 01:01:43.640]  в дерево прямо?
[01:01:43.640 --> 01:01:45.640]  Ну да.
[01:01:45.640 --> 01:01:47.640]  Я бы помогал подвлечь ее самым правым сыном.
[01:01:47.640 --> 01:01:49.640]  Это совсем бредово.
[01:01:49.640 --> 01:01:51.640]  Ну, окей, есть вариант.
[01:01:51.640 --> 01:01:53.640]  Есть вариант.
[01:01:57.640 --> 01:01:59.640]  Значит, короче, давайте я...
[01:01:59.640 --> 01:02:01.640]  Я, честно признаюсь,
[01:02:01.640 --> 01:02:03.640]  что я не читал кота СТЛя в этом отношении.
[01:02:03.640 --> 01:02:05.640]  Ну...
[01:02:05.640 --> 01:02:07.640]  Не...
[01:02:07.640 --> 01:02:09.640]  Именно по этому поводу
[01:02:09.640 --> 01:02:11.640]  я его не читал. Вообще-то я, конечно, читал.
[01:02:11.640 --> 01:02:13.640]  Вот. Но есть другая идея.
[01:02:13.640 --> 01:02:15.640]  Я читал, что на Stack Overflow про это пишут.
[01:02:15.640 --> 01:02:17.640]  Значит...
[01:02:17.640 --> 01:02:19.640]  Нет. Предлагается сделать
[01:02:19.640 --> 01:02:21.640]  не эффективного правого сына,
[01:02:21.640 --> 01:02:23.640]  а эффективный корень.
[01:02:23.640 --> 01:02:25.640]  Так, чтобы все наше дерево было его левым под деревом.
[01:02:31.640 --> 01:02:33.640]  То есть, на самом деле,
[01:02:33.640 --> 01:02:35.640]  у нас есть root, а у нас есть еще...
[01:02:35.640 --> 01:02:37.640]  Ну, то есть, все наше дерево выглядит вот так.
[01:02:37.640 --> 01:02:39.640]  И вот это настоящий root.
[01:02:39.640 --> 01:02:41.640]  А это end.
[01:02:43.640 --> 01:02:45.640]  А это тоже, как бы,
[01:02:45.640 --> 01:02:47.640]  вершинка node, да?
[01:02:47.640 --> 01:02:49.640]  Да. И тут мы опять приходим к той же
[01:02:49.640 --> 01:02:51.640]  проблеме, а что это за
[01:02:51.640 --> 01:02:53.640]  вершинка? Ну, и опять, видимо, надо
[01:02:53.640 --> 01:02:55.640]  сделать base node. То есть, вот это будет base node,
[01:02:55.640 --> 01:02:57.640]  а это нормальный node.
[01:02:57.640 --> 01:02:59.640]  Не, ну, типа, он будет просто хонить, и когда
[01:02:59.640 --> 01:03:01.640]  он будет запросить, он сразу влево.
[01:03:01.640 --> 01:03:03.640]  А? Что?
[01:03:03.640 --> 01:03:05.640]  Когда он будет запросить, он сразу влево
[01:03:05.640 --> 01:03:07.640]  уходить от нее. Может же, как бы...
[01:03:07.640 --> 01:03:09.640]  Ну, да.
[01:03:09.640 --> 01:03:11.640]  Ну, да.
[01:03:11.640 --> 01:03:13.640]  Ну, вот. Кажется...
[01:03:15.640 --> 01:03:17.640]  Ну, потому что здесь же у тебя...
[01:03:17.640 --> 01:03:19.640]  Какой ты ключ из значения будешь хонить? Опять,
[01:03:19.640 --> 01:03:21.640]  что ты там положишь? Вот.
[01:03:23.640 --> 01:03:25.640]  Причем тут можно игнорировать вообще.
[01:03:25.640 --> 01:03:27.640]  То есть, вот для этой вершины можно
[01:03:27.640 --> 01:03:29.640]  игнорировать, не поддерживать все эти вот
[01:03:29.640 --> 01:03:31.640]  свистопляски с красным-черным,
[01:03:31.640 --> 01:03:33.640]  потому что, ну,
[01:03:33.640 --> 01:03:35.640]  там, неважно, корень должен быть
[01:03:35.640 --> 01:03:37.640]  обязательно там черный, да?
[01:03:37.640 --> 01:03:39.640]  Ну, у нас будет такой, а когда мы будем
[01:03:39.640 --> 01:03:41.640]  провериваться, ну, у нас император,
[01:03:41.640 --> 01:03:43.640]  вот мы, значит, император у нас на корне.
[01:03:43.640 --> 01:03:45.640]  Вопрос, как он дальше там будет делать,
[01:03:45.640 --> 01:03:47.640]  условно, плюс-плюс?
[01:03:47.640 --> 01:03:49.640]  Чего так нормальный? У тебя
[01:03:49.640 --> 01:03:51.640]  бигинт тут, бигинт, ты помнишь,
[01:03:51.640 --> 01:03:53.640]  где, а энд?
[01:03:53.640 --> 01:03:55.640]  Плюс-плюс от энда, то уберем всегда.
[01:03:55.640 --> 01:03:57.640]  Плюс-плюс от корня.
[01:03:57.640 --> 01:03:59.640]  Он пойдет в правое под дерево его.
[01:03:59.640 --> 01:04:01.640]  Просто вопрос, как же у нас указатель в корень?
[01:04:01.640 --> 01:04:03.640]  Ну, не в корень, который... Просто пойдет в правое
[01:04:03.640 --> 01:04:05.640]  под дерево. Который не в это,
[01:04:05.640 --> 01:04:07.640]  который реально в корень дерева.
[01:04:07.640 --> 01:04:09.640]  Это энд, это энд, плюс-плюс от энда?
[01:04:09.640 --> 01:04:11.640]  Это не энд, это тот, который выше него.
[01:04:11.640 --> 01:04:13.640]  Стой, стой, стой, стой.
[01:04:13.640 --> 01:04:15.640]  Ты помнишь, что я там
[01:04:15.640 --> 01:04:17.640]  полторы минуты рассказывал,
[01:04:17.640 --> 01:04:19.640]  как мы делаем плюс-плюс?
[01:04:19.640 --> 01:04:21.640]  Вот, я вершина, как мне сделать
[01:04:21.640 --> 01:04:23.640]  плюс-плюс?
[01:04:23.640 --> 01:04:25.640]  Ну как, спускаешь там...
[01:04:25.640 --> 01:04:27.640]  Я проверяю, есть ли у меня правый сын.
[01:04:27.640 --> 01:04:29.640]  Если у меня есть правый сын, я иду в него
[01:04:29.640 --> 01:04:31.640]  и в его самого левого-левого сына.
[01:04:31.640 --> 01:04:33.640]  У меня есть правый сын?
[01:04:37.640 --> 01:04:39.640]  Окей, с отераторами разобрались.
[01:04:39.640 --> 01:04:41.640]  Теперь компараторы.
[01:04:43.640 --> 01:04:45.640]  У мэпа, помимо
[01:04:45.640 --> 01:04:47.640]  всего прочего, еще есть кастомный
[01:04:47.640 --> 01:04:49.640]  компаратор. Тут, на самом деле, есть третий шаблонный
[01:04:49.640 --> 01:04:51.640]  параметр, над которым вы обычно
[01:04:51.640 --> 01:04:53.640]  не думаете, потому что он
[01:04:53.640 --> 01:04:55.640]  по умолчанию равен...
[01:04:55.640 --> 01:04:57.640]  А чему он, кстати, по умолчанию равен?
[01:04:57.640 --> 01:04:59.640]  СТДЛС от K.
[01:05:01.640 --> 01:05:03.640]  Вот. Значит, компеер
[01:05:03.640 --> 01:05:05.640]  равно СТДЛС от K.
[01:05:07.640 --> 01:05:09.640]  Я думаю, что
[01:05:09.640 --> 01:05:11.640]  есть еще четвертый локатор.
[01:05:11.640 --> 01:05:13.640]  Про локаторы мы пока
[01:05:13.640 --> 01:05:15.640]  не будем говорить.
[01:05:15.640 --> 01:05:17.640]  Про...
[01:05:17.640 --> 01:05:19.640]  Про БДС пошел в чат.
[01:05:19.640 --> 01:05:21.640]  Про локаторы мы поговорим,
[01:05:21.640 --> 01:05:23.640]  я надеюсь, на следующей неделе уже.
[01:05:25.640 --> 01:05:27.640]  Вот.
[01:05:27.640 --> 01:05:29.640]  Ну, про них, конечно, обязательно
[01:05:29.640 --> 01:05:31.640]  поговорим. Так вот, компаратор.
[01:05:33.640 --> 01:05:35.640]  Да, значит, СТДЛС
[01:05:35.640 --> 01:05:37.640]  от ключа.
[01:05:37.640 --> 01:05:39.640]  Хорошо.
[01:05:39.640 --> 01:05:41.640]  Но вы можете, конечно, передать свой.
[01:05:41.640 --> 01:05:43.640]  В частном, например, вы можете
[01:05:43.640 --> 01:05:45.640]  свой функциональный класс написать.
[01:05:45.640 --> 01:05:47.640]  Там...
[01:05:47.640 --> 01:05:49.640]  Ну, или лямбда функции. Ну, давайте пока
[01:05:49.640 --> 01:05:51.640]  говорить про функциональный класс.
[01:05:51.640 --> 01:05:53.640]  Какой-то класс, у которого есть
[01:05:53.640 --> 01:05:55.640]  оператор круглые скобочки
[01:05:55.640 --> 01:05:57.640]  от двух ключей, который возвращает
[01:05:57.640 --> 01:05:59.640]  то, что вы называете
[01:05:59.640 --> 01:06:01.640]  меньшим. То, что вы называете
[01:06:01.640 --> 01:06:03.640]  результат сравнения, который
[01:06:03.640 --> 01:06:05.640]  вы хотите, чтобы работало логично меньше.
[01:06:05.640 --> 01:06:07.640]  Что будет, если сюда
[01:06:07.640 --> 01:06:09.640]  передать
[01:06:09.640 --> 01:06:11.640]  вещь,
[01:06:11.640 --> 01:06:13.640]  которая не удовлетворяет отношению
[01:06:13.640 --> 01:06:15.640]  порядка? Ну, будет УБ.
[01:06:15.640 --> 01:06:17.640]  Ну, как и в случае с сортировкой,
[01:06:17.640 --> 01:06:19.640]  если вы передадите компаратор там, который
[01:06:19.640 --> 01:06:21.640]  на самом деле
[01:06:21.640 --> 01:06:23.640]  не транзитивен. Ну, будет УБ,
[01:06:23.640 --> 01:06:25.640]  а все сломается.
[01:06:25.640 --> 01:06:27.640]  Кто-то, по-моему...
[01:06:27.640 --> 01:06:29.640]  Я помню, кто-то в Яндексе
[01:06:29.640 --> 01:06:31.640]  из народа рассказывал, что он
[01:06:31.640 --> 01:06:33.640]  как-то так развлекался и смотрел, как
[01:06:33.640 --> 01:06:35.640]  все торжественно падает.
[01:06:35.640 --> 01:06:37.640]  Если вместо оператора меньше
[01:06:37.640 --> 01:06:39.640]  передать меньше либо равно,
[01:06:39.640 --> 01:06:41.640]  то там иногда падает сортировка, иногда
[01:06:41.640 --> 01:06:43.640]  не падает, иногда падает мапа, иногда
[01:06:43.640 --> 01:06:45.640]  не падает. Ну,
[01:06:45.640 --> 01:06:47.640]  таки УБ, да.
[01:06:47.640 --> 01:06:49.640]  Вот, хорошо.
[01:06:51.640 --> 01:06:53.640]  Ну, а собственно, что?
[01:06:53.640 --> 01:06:55.640]  Все, в общем-то, про компаратора больше говорить
[01:06:55.640 --> 01:06:57.640]  нечего.
[01:06:57.640 --> 01:06:59.640]  И про что осталось поговорить?
[01:06:59.640 --> 01:07:01.640]  Сейчас я посмотрю, потому что у меня есть список,
[01:07:01.640 --> 01:07:03.640]  про что надо поговорить.
[01:07:05.640 --> 01:07:07.640]  И у нас, кажется, как раз первая пара
[01:07:07.640 --> 01:07:09.640]  закончилась.
[01:07:09.640 --> 01:07:11.640]  И еще сейчас будет вторая.
[01:07:13.640 --> 01:07:15.640]  Да.
[01:07:15.640 --> 01:07:17.640]  Нет, сначала перерыв, потом вторая.
[01:07:23.640 --> 01:07:25.640]  Так.
[01:07:25.640 --> 01:07:27.640]  Я еще
[01:07:29.640 --> 01:07:31.640]  Осталось...
[01:07:31.640 --> 01:07:33.640]  Нет-нет, еще
[01:07:33.640 --> 01:07:35.640]  две вещи скажу, сейчас про мэп
[01:07:35.640 --> 01:07:37.640]  закончим и дальше перерыв сделаем.
[01:07:37.640 --> 01:07:39.640]  Потом оно ордер, мы будем обсуждать.
[01:07:39.640 --> 01:07:41.640]  Две вещи,
[01:07:41.640 --> 01:07:43.640]  которые я хочу сказать. Первая вещь.
[01:07:43.640 --> 01:07:45.640]  Еще
[01:07:45.640 --> 01:07:47.640]  я забыл упомянуть такие методы,
[01:07:47.640 --> 01:07:49.640]  а на мой взгляд важно, вот,
[01:07:49.640 --> 01:07:51.640]  к разговору про итераторы. Есть такой метод
[01:07:53.640 --> 01:07:55.640]  insert,
[01:07:55.640 --> 01:07:57.640]  который принимает еще
[01:07:57.640 --> 01:07:59.640]  итератор, помимо пары.
[01:08:01.640 --> 01:08:03.640]  Нет.
[01:08:03.640 --> 01:08:05.640]  Insert с параметрами
[01:08:05.640 --> 01:08:07.640]  итератор и еще value type.
[01:08:07.640 --> 01:08:09.640]  Да, insert с подсказкой.
[01:08:09.640 --> 01:08:11.640]  Insert с подсказкой.
[01:08:11.640 --> 01:08:13.640]  Знаете ли вы что.
[01:08:13.640 --> 01:08:15.640]  Да.
[01:08:15.640 --> 01:08:17.640]  То есть...
[01:08:19.640 --> 01:08:21.640]  Ну, вы
[01:08:21.640 --> 01:08:23.640]  допустим...
[01:08:27.640 --> 01:08:29.640]  Ну.
[01:08:33.640 --> 01:08:35.640]  Нет, гарантировать ничего
[01:08:35.640 --> 01:08:37.640]  не нужно.
[01:08:37.640 --> 01:08:39.640]  Нет, ты можешь передать любой
[01:08:39.640 --> 01:08:41.640]  какой угодный итератор, просто если он
[01:08:41.640 --> 01:08:43.640]  окажется неподходящим, то он обычно insert
[01:08:43.640 --> 01:08:45.640]  сделает. Insert с
[01:08:45.640 --> 01:08:47.640]  подсказкой он просто...
[01:08:47.640 --> 01:08:49.640]  Он первым делом пытается
[01:08:49.640 --> 01:08:51.640]  посмотреть, ну, грубо говоря,
[01:08:51.640 --> 01:08:53.640]  он обход от этого итератора начинает.
[01:08:53.640 --> 01:08:55.640]  Вот так, я думаю. То есть он пытается
[01:08:55.640 --> 01:08:57.640]  взять место в дереве не от корня
[01:08:57.640 --> 01:08:59.640]  идя, а от того, что ты ему дал.
[01:08:59.640 --> 01:09:01.640]  Потому что, может быть, ты уже и так знаешь,
[01:09:01.640 --> 01:09:03.640]  куда вставить надо это будет.
[01:09:03.640 --> 01:09:05.640]  Вот этого я не знаю.
[01:09:07.640 --> 01:09:09.640]  И мне кажется, этого не написано даже в
[01:09:09.640 --> 01:09:11.640]  стандарте, то есть
[01:09:11.640 --> 01:09:13.640]  компилятор как-то делает.
[01:09:13.640 --> 01:09:15.640]  Компилятор
[01:09:15.640 --> 01:09:17.640]  как хочет
[01:09:17.640 --> 01:09:19.640]  использует информацию, но если уж вы
[01:09:19.640 --> 01:09:21.640]  передадите ему итератор прямо вот на то место,
[01:09:21.640 --> 01:09:23.640]  после которого
[01:09:23.640 --> 01:09:25.640]  я думаю, что он
[01:09:25.640 --> 01:09:27.640]  и в другую сторону попробует.
[01:09:27.640 --> 01:09:53.640]  В общем, я не
[01:09:53.640 --> 01:09:55.640]  могу сказать точно, как именно он
[01:09:55.640 --> 01:09:57.640]  использует эту подсказку, но
[01:09:57.640 --> 01:09:59.640]  в общем, она есть.
[01:10:01.640 --> 01:10:03.640]  Можно использовать
[01:10:03.640 --> 01:10:05.640]  такой метод.
[01:10:05.640 --> 01:10:07.640]  Для мэпа это ускоряет иногда.
[01:10:07.640 --> 01:10:09.640]  Если вы
[01:10:09.640 --> 01:10:11.640]  бьетесь за производительность.
[01:10:11.640 --> 01:10:13.640]  Ну и последняя вещь, про которую надо сказать,
[01:10:13.640 --> 01:10:15.640]  про которую мы забыли
[01:10:15.640 --> 01:10:17.640]  поговорить про лист, но в листе
[01:10:17.640 --> 01:10:19.640]  там особо нечего про это говорить.
[01:10:19.640 --> 01:10:21.640]  Давайте поговорим про
[01:10:21.640 --> 01:10:23.640]  такую вещь, которая называется Exception Safety.
[01:10:23.640 --> 01:10:25.640]  Вы же помните, что в мэпе,
[01:10:25.640 --> 01:10:27.640]  как, впрочем, во всех контейнерах,
[01:10:27.640 --> 01:10:29.640]  методы должны быть строго
[01:10:29.640 --> 01:10:31.640]  безопасны относительно
[01:10:31.640 --> 01:10:33.640]  исключений. Strong Exception
[01:10:33.640 --> 01:10:35.640]  Guarantee.
[01:10:35.640 --> 01:10:37.640]  И давайте
[01:10:37.640 --> 01:10:39.640]  подумаем, какие могут быть проблемы.
[01:10:41.640 --> 01:10:43.640]  Ну, с вектором это понятно, там у нас
[01:10:43.640 --> 01:10:45.640]  был тот еще
[01:10:45.640 --> 01:10:47.640]  геморрой, там перекладывать надо иногда, релоцировать.
[01:10:47.640 --> 01:10:49.640]  С листом
[01:10:49.640 --> 01:10:51.640]  особо нет проблем.
[01:10:51.640 --> 01:10:53.640]  Случилось исключение, ну просто
[01:10:53.640 --> 01:10:55.640]  вершину надо...
[01:10:55.640 --> 01:10:57.640]  Ну, просто у тебя
[01:10:57.640 --> 01:10:59.640]  если там конструктор
[01:10:59.640 --> 01:11:01.640]  ключа или конструктор
[01:11:01.640 --> 01:11:03.640]  Value кинул исключение,
[01:11:03.640 --> 01:11:05.640]  ну надо диалоцировать вершину,
[01:11:05.640 --> 01:11:07.640]  вот эту, которую ты создал.
[01:11:07.640 --> 01:11:09.640]  И все.
[01:11:09.640 --> 01:11:11.640]  А не забыть.
[01:11:11.640 --> 01:11:13.640]  А в мэпе что может не так пойти?
[01:11:15.640 --> 01:11:17.640]  Вот если у меня...
[01:11:17.640 --> 01:11:19.640]  Вот если я, например,
[01:11:19.640 --> 01:11:21.640]  делаю какой-нибудь оператор квадратной скобочки
[01:11:21.640 --> 01:11:23.640]  или add или insert,
[01:11:23.640 --> 01:11:25.640]  и у меня какой-нибудь конструктор
[01:11:25.640 --> 01:11:27.640]  key или value
[01:11:27.640 --> 01:11:29.640]  кидает исключение,
[01:11:29.640 --> 01:11:31.640]  что я тогда делаю?
[01:11:31.640 --> 01:11:33.640]  Ничего страшного, потому что в каком случае это происходит?
[01:11:33.640 --> 01:11:35.640]  Когда мы дошли до низа дерева,
[01:11:35.640 --> 01:11:37.640]  мы еще ничего не переграсили,
[01:11:37.640 --> 01:11:39.640]  ничего не повернули.
[01:11:39.640 --> 01:11:41.640]  Мы просто дошли, вставили вершину,
[01:11:41.640 --> 01:11:43.640]  создали значение помолчания, скажем,
[01:11:43.640 --> 01:11:45.640]  все упало, и мы такие, ну ладно,
[01:11:45.640 --> 01:11:47.640]  не делаем.
[01:11:47.640 --> 01:11:49.640]  Просто мы не...
[01:11:49.640 --> 01:11:51.640]  То есть мы создаем ноду до того,
[01:11:51.640 --> 01:11:53.640]  мы создаем ноду до того,
[01:11:53.640 --> 01:11:55.640]  как начали дерево перестраивать.
[01:11:55.640 --> 01:11:57.640]  Просто так мы ее создали,
[01:11:57.640 --> 01:11:59.640]  и мы такие, окей,
[01:11:59.640 --> 01:12:01.640]  если не получилось создать,
[01:12:01.640 --> 01:12:03.640]  просто диалоцируем,
[01:12:03.640 --> 01:12:05.640]  и дерево не пострадало.
[01:12:05.640 --> 01:12:07.640]  Вопрос. Чего мы забыли учесть?
[01:12:09.640 --> 01:12:11.640]  Что еще может
[01:12:11.640 --> 01:12:13.640]  кинуть исключение?
[01:12:13.640 --> 01:12:15.640]  Вряд ли обращение и сравнение
[01:12:15.640 --> 01:12:17.640]  не может кинуть исключение, или может?
[01:12:17.640 --> 01:12:19.640]  В смысле, вряд ли?
[01:12:19.640 --> 01:12:21.640]  В смысле, с вероятностью
[01:12:21.640 --> 01:12:23.640]  ноль или как?
[01:12:23.640 --> 01:12:25.640]  Что значит вряд ли?
[01:12:25.640 --> 01:12:27.640]  Мало вероятно, давайте считать,
[01:12:27.640 --> 01:12:29.640]  что не кидает.
[01:12:29.640 --> 01:12:31.640]  У нас еще есть такая замечательная вещь,
[01:12:31.640 --> 01:12:33.640]  про которую я вот упоминал, вот это вот.
[01:12:33.640 --> 01:12:35.640]  Вот может не надо.
[01:12:35.640 --> 01:12:37.640]  Что если во время сравнения
[01:12:37.640 --> 01:12:39.640]  ключей вылетело исключение?
[01:12:39.640 --> 01:12:41.640]  Поминки, все.
[01:12:41.640 --> 01:12:43.640]  Мы ключи сравниваем тоже.
[01:12:45.640 --> 01:12:47.640]  Чего?
[01:12:49.640 --> 01:12:51.640]  Ну правильно.
[01:12:51.640 --> 01:12:53.640]  На самом деле, да.
[01:12:53.640 --> 01:12:55.640]  Давайте вспомним,
[01:12:55.640 --> 01:12:57.640]  а как происходит вставка в красно-черный?
[01:12:57.640 --> 01:12:59.640]  Самое время сейчас про это вспомнить.
[01:13:01.640 --> 01:13:03.640]  Когда мы вставляем что-то в красно-черный?
[01:13:03.640 --> 01:13:05.640]  Когда вообще компаратор нужен?
[01:13:05.640 --> 01:13:07.640]  Когда мы идем по дереву, чтобы найти место?
[01:13:07.640 --> 01:13:09.640]  После того, как мы нашли место, куда вставлять,
[01:13:09.640 --> 01:13:11.640]  создали вершину, подцепили ее к этим,
[01:13:11.640 --> 01:13:13.640]  и сейчас будем выяснять,
[01:13:13.640 --> 01:13:15.640]  не нарушился ли баланс и делать
[01:13:15.640 --> 01:13:17.640]  повороты, вот эти, перестраения,
[01:13:17.640 --> 01:13:19.640]  вот эти долбанные.
[01:13:19.640 --> 01:13:21.640]  Мы в этот момент
[01:13:21.640 --> 01:13:23.640]  используем компаратор, когда повороты делаем,
[01:13:23.640 --> 01:13:25.640]  или нет? На самом деле, нет.
[01:13:25.640 --> 01:13:27.640]  Потому что, да, у нас уже
[01:13:27.640 --> 01:13:29.640]  все соблюдено, и нам
[01:13:29.640 --> 01:13:31.640]  надо только смотреть на
[01:13:31.640 --> 01:13:33.640]  ключи в вершинах
[01:13:33.640 --> 01:13:35.640]  и перестраивать в зависимости от них.
[01:13:35.640 --> 01:13:37.640]  Но сам компаратор мы уже не вызываем,
[01:13:37.640 --> 01:13:39.640]  после того, как вставили вершину
[01:13:39.640 --> 01:13:41.640]  и начали делать повороты.
[01:13:41.640 --> 01:13:43.640]  Вот. А когда еще мы...
[01:13:43.640 --> 01:13:45.640]  Когда мы делаем эрейс,
[01:13:47.640 --> 01:13:49.640]  мы тоже...
[01:13:49.640 --> 01:13:51.640]  Вот с эрейсом поаккуратней
[01:13:51.640 --> 01:13:53.640]  надо быть. Когда мы дошли
[01:13:53.640 --> 01:13:55.640]  до места, где лежит вершина,
[01:13:55.640 --> 01:13:57.640]  уничтожили ее, если мы
[01:13:57.640 --> 01:13:59.640]  забудем...
[01:13:59.640 --> 01:14:01.640]  Если мы, короче, сделаем удаление
[01:14:01.640 --> 01:14:03.640]  вершины до того, как поймем,
[01:14:03.640 --> 01:14:05.640]  куда подцепить там,
[01:14:05.640 --> 01:14:07.640]  кого из предков подцепить на ее место
[01:14:07.640 --> 01:14:09.640]  теперь, то это будет фейл.
[01:14:09.640 --> 01:14:11.640]  То есть нам нужно сначала
[01:14:11.640 --> 01:14:13.640]  отцепить вершину
[01:14:13.640 --> 01:14:15.640]  и встроить этих
[01:14:15.640 --> 01:14:17.640]  ребят в дерево.
[01:14:17.640 --> 01:14:19.640]  Только потом удалить. То есть
[01:14:19.640 --> 01:14:21.640]  надо, чтобы ни один вызов компаратора
[01:14:21.640 --> 01:14:23.640]  не случился после того, как мы уже поработали
[01:14:23.640 --> 01:14:25.640]  с этой самой вершиной, чтобы мы ее отцепили
[01:14:25.640 --> 01:14:27.640]  или наоборот прицепили.
[01:14:27.640 --> 01:14:29.640]  Вот. Но да, компаратор может
[01:14:29.640 --> 01:14:31.640]  кинуть исключения, и это тоже
[01:14:31.640 --> 01:14:33.640]  учитывается в реализации мэпа.
[01:14:33.640 --> 01:14:35.640]  Вот.
[01:14:35.640 --> 01:14:37.640]  Такие дела.
[01:14:37.640 --> 01:14:39.640]  Ну, наверное, все, что я хотел сказать
[01:14:39.640 --> 01:14:41.640]  про мэп.
[01:14:41.640 --> 01:14:43.640]  Давайте сделаем перерыв.
