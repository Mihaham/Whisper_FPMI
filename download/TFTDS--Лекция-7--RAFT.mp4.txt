[00:00.000 --> 00:07.000]  Итак, поехали.
[00:07.000 --> 00:10.000]  В прошлый раз мы с вами говорили про multi-type access.
[00:10.000 --> 00:14.000]  Мы взяли алгоритм консенсуса, который помогает Nuslam выбрать общее значение,
[00:14.000 --> 00:16.000]  и с помощью него строили RSM.
[00:16.000 --> 00:20.000]  Ну, точнее, мы реплицировали логи, которые помогали,
[00:20.000 --> 00:25.000]  эти реплицированные логи помогали дальше уже репликам реплицировать состояние автомата.
[00:25.000 --> 00:29.000]  Они читали эти логи и применяли все закомично зафиксированные надежные команды
[00:29.000 --> 00:37.000]  к своему состоянию локальному, и отвечали клиенту, когда это случается.
[00:37.000 --> 00:39.000]  Как наш алгоритм в прошлый раз был устроен?
[00:39.000 --> 00:43.000]  Ну, вот мы взяли single decreed access, там были две фазы, prepare, accept.
[00:43.000 --> 00:49.000]  С помощью фазы prepare каждый пропозер сначала захватывал внимание accept,
[00:49.000 --> 00:53.000]  а с помощью фазы accept он дальше предлагал им какое-то значение.
[00:53.000 --> 00:55.000]  Ну, месяц им был вот номер.
[00:55.000 --> 00:58.000]  А дальше мы хотели все это уложить в слоты лога.
[00:58.000 --> 01:04.000]  Ну, начали мы с такого наивного алгоритма, где каждая реплика, получая очередную команду,
[01:04.000 --> 01:08.000]  выбирает первую свободную позицию в логе и становится пропозером для данного слота,
[01:08.000 --> 01:11.000]  то есть в этом слоте запускает свой собственный экземпляр Paxos,
[01:11.000 --> 01:13.000]  становится там пропозером.
[01:13.000 --> 01:18.000]  Вот, так мы получили какую-то наивную реализацию реплицированного лога,
[01:18.000 --> 01:22.000]  наивную реализацию RSM, а дальше мы сделали две важные оптимизации,
[01:22.000 --> 01:26.000]  которые, собственно, и сделали то, что мы получили multipaxos.
[01:26.000 --> 01:30.000]  Во-первых, мы заметили, что зачем репликам конкурировать в одних и тех же слотах.
[01:30.000 --> 01:35.000]  Каждый из них является пропозером, но, а может быть, стоит выделить среди них какую-то одну,
[01:35.000 --> 01:38.000]  которая будет являться выделенным пропозером или лидером,
[01:38.000 --> 01:41.000]  и вот только эта реплика будет предлагать команды.
[01:41.000 --> 01:48.000]  А дальше мы заметили следующее, что фаза prepare алгоритм Paxos кажется нужна на случай конкуренции,
[01:48.000 --> 01:52.000]  когда пропозеры конкурируют друг с другом, а мы конкуренцию убрали.
[01:52.000 --> 01:56.000]  Поэтому очень странно, что мы на быстром пути, точнее лидер на быстром пути,
[01:56.000 --> 01:58.000]  постоянно проходит через первую фазу.
[01:58.000 --> 02:02.000]  Он вроде бы один, он ни с кем не конкурирует, но чаще всего ни с кем не конкурирует,
[02:02.000 --> 02:06.000]  если сеть работает стабильно, и при этом он все равно выполняет фазу prepare.
[02:06.000 --> 02:10.000]  Ну и мы избавились от этой фазы, но не навсегда, конечно, она необходима алгоритму,
[02:10.000 --> 02:16.000]  мы избавились от нее в сценарии, когда сеть работает стабильно, когда лидер у нас стабильный, не меняется.
[02:16.000 --> 02:20.000]  Мы заметили, что в фазе prepare не участвует команда,
[02:20.000 --> 02:28.000]  и мы выбрали для... мы виртуально проходили через фазу prepare
[02:28.000 --> 02:32.000]  сразу для большого количества слотов, для всего суффикса.
[02:32.000 --> 02:37.000]  Мы использовали там один и тот же n и говорили prepare, а acceptor смотрел на свой лог,
[02:37.000 --> 02:41.000]  другие реплики смотрели на свои логи, и если они видели, что вот начиная с некоторого слота,
[02:41.000 --> 02:48.000]  никаких больше команд в этих логах нет, никакие другие пропозеры не предлагают какие-то свои команды,
[02:48.000 --> 02:53.000]  то acceptor давал обещание, отвечал промессом не на один слот, а сразу на весь суффикс.
[02:53.000 --> 02:58.000]  И после этого выделенный этот пропозер, лидер, получая команды от клиентов,
[02:58.000 --> 03:04.000]  сразу проходил через вторую фазу паксиса, через репликацию, минуя первую фазу.
[03:04.000 --> 03:09.000]  Ну, конечно, этот конвейер мог сбиться, если вдруг появится другой лидер, такое могло бы быть.
[03:09.000 --> 03:14.000]  Но в этом случае конвейер сбрасывается, видимо, лидер опять откатывается на первую фазу.
[03:14.000 --> 03:19.000]  Но на быстром пути у нас только одна фаза остается, один раунд три.
[03:19.000 --> 03:22.000]  Так мы получили довольно эффективный алгоритм.
[03:22.000 --> 03:27.000]  Он гораздо эффективнее, конечно же, относительно нашей наивной реализации,
[03:27.000 --> 03:31.000]  где был просто синглут крипакса в каждом слоте.
[03:31.000 --> 03:37.000]  Но все же это еще не вся история, потому что вроде бы мы все понимаем,
[03:37.000 --> 03:43.000]  и вы даже задавали вопросы после лекции, что в алгоритме осталось много белых пятен.
[03:43.000 --> 03:50.000]  Вроде бы лидер должен предлагать, захватывать суффикс лога с помощью некоторого n.
[03:50.000 --> 03:53.000]  А как выбрать это n, мы не говорили.
[03:53.000 --> 03:57.000]  Понятно, что, видимо, у нового лидера должен быть какое-то больше n.
[03:57.000 --> 04:02.000]  В результате должны быть связаны выборы лидера и выборы нового n, переход в новую эпоху.
[04:02.000 --> 04:04.000]  Но мы не сказали, как именно.
[04:04.000 --> 04:08.000]  Мы не сказали, как именно реплики понимают, что команды надежно зафиксированы в логе,
[04:08.000 --> 04:10.000]  что они закомничаны.
[04:10.000 --> 04:12.000]  Разумеется, это лидер понимает, если он получил команду,
[04:12.000 --> 04:15.000]  прошел сразу через вторую фазу, ему ответили подтверждением,
[04:15.000 --> 04:17.000]  хвором собрался.
[04:17.000 --> 04:19.000]  И лидер, наверное, мог бы об этом говорить другим репликам.
[04:19.000 --> 04:23.000]  Но с другой стороны, лидер может отказать, и реплики об этом не узнают.
[04:23.000 --> 04:26.000]  То есть нужен какой-то протокол, который поможет им все-таки узнать,
[04:26.000 --> 04:30.000]  что команды закомничаны, их можно применять к своему локальному состоянию.
[04:30.000 --> 04:35.000]  Какие-то другие нюансы, у нас не было хорошего протокола выбора лидера.
[04:35.000 --> 04:38.000]  Выбирали реплику с максимальным идентификатором,
[04:38.000 --> 04:41.000]  может быть, у нее пустая логика, это не всегда будет эффективно.
[04:41.000 --> 04:44.000]  В общем, очень многие вещи можно было бы потюнить,
[04:44.000 --> 04:47.000]  или можно было бы дорассказать.
[04:47.000 --> 04:51.000]  Интуитивно понятно, что, наверное, базовый алгоритм у нас есть,
[04:51.000 --> 04:53.000]  корректность его доказана.
[04:53.000 --> 04:57.000]  Так что нам ничего в принципе не угрожает, можно как-нибудь докрутить.
[04:57.000 --> 04:59.000]  Но можно и ошибиться.
[04:59.000 --> 05:02.000]  Ну и просто такая дополнительная когнитивная нагрузка на нас,
[05:02.000 --> 05:05.000]  и на любого разработчика, который хочет этот multipax использовать.
[05:05.000 --> 05:09.000]  Поэтому сегодня мы поговорим про альтернативный алгоритм,
[05:09.000 --> 05:11.000]  который называется RAFT.
[05:11.000 --> 05:15.000]  Ну и давайте перейдем на проектор.
[05:15.000 --> 05:18.000]  Итак, статья про RAFT, она называется не RAFT,
[05:18.000 --> 05:21.000]  она называется в поисках понятного алгоритма консенсуса,
[05:21.000 --> 05:25.000]  и, видимо, она своим названием в чем-то упрекает алгоритм баксов.
[05:25.000 --> 05:29.000]  Начинается все с такого заявления, что вот авторы алгоритма RAFT
[05:29.000 --> 05:34.000]  придумали алгоритм, который позволяет реплицировать лог
[05:34.000 --> 05:39.000]  и их алгоритм эквивалентен multipax в том смысле,
[05:39.000 --> 05:43.000]  что он также реплицирует лог в асинхронной системе,
[05:43.000 --> 05:48.000]  также сохраняет доступность при отказе менее чем...
[05:48.000 --> 05:52.000]  сохраняет доступность, если жив кворум, большинство узлов,
[05:52.000 --> 05:56.000]  также не теряет свою согласованность с сейфти свойства в асинхронной модели,
[05:56.000 --> 05:59.000]  даже если количество отказов произвольное.
[05:59.000 --> 06:05.000]  В общем, решает ту же самую задачу с теми же самыми свойствами.
[06:05.000 --> 06:08.000]  Но в чем же достоинство этого алгоритма?
[06:08.000 --> 06:14.000]  Вот авторы утверждают, что он лучше паксуса, если коротко совсем.
[06:14.000 --> 06:19.000]  Ну и в чем-то они правы, потому что если посмотреть, что случилось после этой статьи,
[06:19.000 --> 06:25.000]  эта статья была написана в 2013 году, вот после этой статьи более-менее каждая
[06:25.000 --> 06:30.000]  Open Source база данных использует в качестве алгоритма консенсуса именно паксус.
[06:30.000 --> 06:33.000]  Именно, простите, RAFT.
[06:33.000 --> 06:38.000]  Так что им удалось добиться того, чего они хотели.
[06:38.000 --> 06:43.000]  Они, видимо, убедили людей, что их алгоритм проще или лучше подходит для того,
[06:43.000 --> 06:46.000]  чтобы реализовать RSM.
[06:46.000 --> 06:51.000]  Ну а чтобы понять, почему так получилось, нужно, собственно, объяснить их аргументацию.
[06:51.000 --> 06:53.000]  Они, конечно, говорят, что алгоритм паксус...
[06:53.000 --> 06:57.000]  Они пишут, что это буквально синоним консенсуса был долгое время.
[06:57.000 --> 07:03.000]  Действительно, но они все-таки утверждают, что алгоритм паксуса что-то не так.
[07:03.000 --> 07:06.000]  И вот они про это целый параграф в статье пишут.
[07:06.000 --> 07:08.000]  Что они говорят?
[07:08.000 --> 07:16.000]  Во-первых, они говорят, что в алгоритме паксус просто выбрана неудачная декомпозиция.
[07:16.000 --> 07:18.000]  В чем здесь смысл?
[07:18.000 --> 07:20.000]  У вас есть задача репликации лога.
[07:20.000 --> 07:22.000]  Вот есть этот самый лог, последовательность слотов.
[07:22.000 --> 07:24.000]  Что делает Lamport?
[07:24.000 --> 07:27.000]  Lamport этот самый лог берет и делит на слоты.
[07:27.000 --> 07:31.000]  И внутри каждого слота решает независимую задачу консенсуса.
[07:31.000 --> 07:33.000]  Вот разные слоты друг с другом никак не связаны.
[07:33.000 --> 07:35.000]  Можно думать о них в изоляции.
[07:35.000 --> 07:38.000]  Мы в прошлый раз так и начали строить multipaxis.
[07:38.000 --> 07:40.000]  С одной стороны, вот так задача очень локализуется,
[07:40.000 --> 07:42.000]  и сводится к задаче консенсуса.
[07:42.000 --> 07:45.000]  Мы не думаем про всяких лидеров, про какие-то эпохи.
[07:45.000 --> 07:48.000]  Мы решаем одну такую изолированную простую задачу.
[07:48.000 --> 07:52.000]  С другой стороны, у Lamport получается решение single-decree-paxis,
[07:52.000 --> 07:55.000]  которое хоть и короткое, то есть описывается в 20 строчек псевдокода.
[07:55.000 --> 08:01.000]  Но с другой стороны, никакого самостоятельного смысла у этих фаз и у переменных в этом алгоритме нет.
[08:01.000 --> 08:05.000]  В прошлый раз мы увидели, что N...
[08:05.000 --> 08:09.000]  В прошлый раз, когда мы перешли от single-decree-paxis к multipaxis,
[08:09.000 --> 08:12.000]  от отдельной задачи консенсуса к логам и репликам,
[08:12.000 --> 08:15.000]  только тогда мы поняли, что N — это эпоха,
[08:15.000 --> 08:23.000]  что сравнение NP и N — это блокировка старых лидеров или переход в новую эпоху за новым лидером,
[08:23.000 --> 08:27.000]  что фаза prepare — это голосование за лидера, а accept — это репликация.
[08:27.000 --> 08:31.000]  Но вот такого смысла внутри single-decree-paxis нет.
[08:31.000 --> 08:34.000]  И ровно поэтому его трудно понять.
[08:34.000 --> 08:36.000]  Он неинтуитивен просто-напросто.
[08:36.000 --> 08:38.000]  Там есть две фазы, они крепко зацеплены друг за друга,
[08:38.000 --> 08:42.000]  и у них нет понятного собственного смысла в контексте такой маленькой задачи.
[08:42.000 --> 08:45.000]  RAFT делает по-другому.
[08:45.000 --> 08:48.000]  RAFT делает, можно сказать, что разумнее.
[08:48.000 --> 08:53.000]  Он декомпозирует задачу не горизонтально по слотам, а вертикально по фазам.
[08:53.000 --> 08:57.000]  RAFT говорит, что в жизни вашего RSM есть периоды.
[08:57.000 --> 09:02.000]  Вот есть период, когда система стабильна, и если один лидер, он реплицирует команду.
[09:02.000 --> 09:06.000]  А потом лидер вдруг умирает, ну или, не знаю, какая-то турбулентная сети начинается,
[09:06.000 --> 09:09.000]  и нужно выбирать нового лидера.
[09:09.000 --> 09:12.000]  И вот у вас фазы со стабильным лидером и репликацией сменяются фазами,
[09:12.000 --> 09:14.000]  где у вас выбирается новый лидер.
[09:14.000 --> 09:16.000]  Происходит смена эпохи.
[09:16.000 --> 09:21.000]  Потом снова новый лидер долго работает, потом он снова, не знаю, умирает или перезагружается,
[09:21.000 --> 09:26.000]  или просто начинается асинхронность репартишн, убирается новый лидер и так далее.
[09:26.000 --> 09:34.000]  И эти вот такие стадии, фазы, они рассматриваются поначалу в изоляции.
[09:34.000 --> 09:36.000]  То есть авторы говорят, что их можно рассматривать отдельно.
[09:36.000 --> 09:38.000]  Это не совсем правда, мы увидим сегодня.
[09:38.000 --> 09:44.000]  Но все же, вот такой взгляд на задачу, он просто больше соответствует происходящему в реальности.
[09:44.000 --> 09:47.000]  Это про декомпозицию.
[09:47.000 --> 09:51.000]  То есть в принципе структура алгоритма будет такой же.
[09:51.000 --> 09:56.000]  Ну и вообще у меня сегодня есть план убедить вас, что несмотря на заявления авторов,
[09:56.000 --> 09:59.000]  что алгоритм проще, это тот же самый алгоритм.
[09:59.000 --> 10:03.000]  Но тем не менее, вот тот же самый алгоритм структурирован иначе.
[10:03.000 --> 10:13.000]  А второй аргумент против Паксуса и Zaraft у авторов состоит в том, что Паксус, по их мнению,
[10:13.000 --> 10:17.000]  сейчас найду это место, что Паксус, по их мнению,
[10:17.000 --> 10:21.000]  плохо подходит в качестве фундамента для построения распределенных систем.
[10:21.000 --> 10:25.000]  Это довольно странное утверждение, потому что я показывал ему статью про Spanner,
[10:25.000 --> 10:30.000]  ну и кажется, писал недавно в чат, кидал ссылку на Twitter,
[10:30.000 --> 10:34.000]  где говорили, что сколько запросов в секунду Spanner обрабатывает.
[10:34.000 --> 10:39.000]  Это самая большая база данных на свете, больше не бывает ни у кого нигде.
[10:39.000 --> 10:43.000]  И этот Spanner использует Paxus для репликации.
[10:43.000 --> 10:47.000]  Поэтому кажется, что подходит он все-таки для построения промышленных систем,
[10:47.000 --> 10:49.000]  слегка нагруженных.
[10:49.000 --> 10:51.000]  Но речь здесь не о том, что с помощью Paxus нельзя построить.
[10:51.000 --> 10:58.000]  С помощью Paxus можно построить, замечательно можно построить, но неудобно.
[10:58.000 --> 11:02.000]  Во-первых, у алгоритма Paxus нет какого-то канонического описания,
[11:02.000 --> 11:05.000]  где были бы четко расписаны, какие там сообщения,
[11:05.000 --> 11:07.000]  как обрабатывать эти сообщения, как на них реагировать,
[11:07.000 --> 11:09.000]  в какое состояние реплик.
[11:09.000 --> 11:12.000]  То есть есть статья Lampard про парламент, но она все-таки про греков,
[11:12.000 --> 11:15.000]  про парламент, про дощечки, про песочные часы, про овец.
[11:15.000 --> 11:19.000]  Все это неудобно.
[11:19.000 --> 11:23.000]  И начал эту лекцию из того, что просто в алгоритме,
[11:23.000 --> 11:26.000]  даже если мы придумываем все без греков,
[11:26.000 --> 11:28.000]  все равно остаются какие-то свободные места
[11:28.000 --> 11:30.000]  и нужно чем-то заполнять.
[11:30.000 --> 11:32.000]  Это требует усилий разработчика,
[11:32.000 --> 11:34.000]  это требует некоторой квалификации разработчика,
[11:34.000 --> 11:36.000]  в смысле он должен понимать хорошо, что происходит,
[11:36.000 --> 11:38.000]  что он может сделать, а что ему нельзя делать,
[11:38.000 --> 11:40.000]  потому что он поломает сейфти, скажем.
[11:40.000 --> 11:42.000]  В RAFT все не так.
[11:42.000 --> 11:45.000]  В RAFT в статье есть просто страница одна,
[11:45.000 --> 11:48.000]  на которую авторы уместили весь протокол.
[11:48.000 --> 11:51.000]  То есть тут написано состояние каждой реплики,
[11:51.000 --> 11:54.000]  причем даже разделено, что мы храним на диске,
[11:54.000 --> 11:56.000]  что мы храним в памяти, что можно хранить в памяти.
[11:56.000 --> 12:00.000]  Тут описаны роли возможные, кандидаты, фолловеры, лидеры,
[12:00.000 --> 12:02.000]  но про это чуть позже.
[12:02.000 --> 12:04.000]  Тут описаны два типа сообщений, которые отправляются,
[12:04.000 --> 12:08.000]  и вот все поля в этих сообщениях.
[12:08.000 --> 12:10.000]  В принципе думать не нужно,
[12:10.000 --> 12:13.000]  то есть вам не нужно понимать, почему алгоритм корректен,
[12:13.000 --> 12:16.000]  точнее как, это всегда полезно.
[12:16.000 --> 12:19.000]  Но в то же время, если вы напишете аккуратно то,
[12:19.000 --> 12:21.000]  что вот выписана эта страница,
[12:21.000 --> 12:23.000]  то вы получите видимо реализацию,
[12:23.000 --> 12:26.000]  то вы получите реплицированный лог.
[12:26.000 --> 12:31.000]  Вам не нужно будет добавлять к нему какие-то,
[12:31.000 --> 12:35.000]  заполнять какие-то темные места, потому что просто их нет.
[12:35.000 --> 12:37.000]  Все описано.
[12:37.000 --> 12:39.000]  Каждая реакция в каждом состоянии на каждое сообщение.
[12:39.000 --> 12:41.000]  Сообщения описаны.
[12:41.000 --> 12:44.000]  Вам не нужно придумывать их самостоятельно.
[12:44.000 --> 12:49.000]  Это с одной стороны здорово, то есть это проще, понятно.
[12:49.000 --> 12:51.000]  Это больше отвечает у как бы задачи,
[12:51.000 --> 12:54.000]  которые инженером стоит, который пишет определенную систему.
[12:54.000 --> 12:57.000]  Но с другой стороны, я бы сказал, что в алгоритме RAFT
[12:57.000 --> 13:00.000]  все очень жестко подогнуло друг к другу,
[13:00.000 --> 13:03.000]  и у вас очень мало свободы.
[13:03.000 --> 13:07.000]  А в алгоритме Multipax с одной стороны очень много белых пятен,
[13:07.000 --> 13:11.000]  а с другой стороны вы можете, ну какие-то вот эти,
[13:11.000 --> 13:13.000]  у вас большое количество степеней свободы есть,
[13:13.000 --> 13:15.000]  вы можете иметь реализацию выбора лидера,
[13:15.000 --> 13:17.000]  вы можете там что-то еще настраивать,
[13:17.000 --> 13:20.000]  и в итоге вы можете комбинировать разные идеи,
[13:20.000 --> 13:22.000]  довольно свободно.
[13:22.000 --> 13:24.000]  И если вы умеете доказать, почему это корректно,
[13:24.000 --> 13:28.000]  то вы можете получить алгоритм, который будет эффективнее, чем RAFT.
[13:28.000 --> 13:31.000]  Так что тут с одной стороны минус,
[13:31.000 --> 13:34.000]  но с другой стороны плюс есть у Multipax, разумеется.
[13:34.000 --> 13:37.000]  Но тем не менее, вот авторы говорят, что канонического описания нет,
[13:37.000 --> 13:40.000]  а вот в RAFT есть эта страница.
[13:40.000 --> 13:42.000]  Но мало того, что страница есть.
[13:42.000 --> 13:45.000]  Они говорят, что у Multipax еще нет хороших опенсорс реализаций,
[13:45.000 --> 13:47.000]  что, наверное, важно.
[13:47.000 --> 13:49.000]  Потому что даже если вы пишете свою базу данных,
[13:49.000 --> 13:51.000]  то вы не пишете свое собственное локальное хранилище,
[13:51.000 --> 13:53.000]  вы берете LevelDB или RocksDB.
[13:53.000 --> 13:56.000]  Но точно так же вы можете не брать консенсус,
[13:56.000 --> 13:58.000]  в смысле не писать консенсус сами,
[13:58.000 --> 14:00.000]  вы можете взять готовый консенсус,
[14:00.000 --> 14:03.000]  готовую библиотеку, которая реализует репликацию лога.
[14:03.000 --> 14:05.000]  И с Multipax самых хороших нет,
[14:05.000 --> 14:09.000]  просто потому что Google свой код не выкладывал в опенсорс.
[14:09.000 --> 14:13.000]  А авторы RAFT, они сразу вместе с статьей и вот вместе с этой страницей,
[14:13.000 --> 14:16.000]  они написали, во-первых, PhD,
[14:16.000 --> 14:22.000]  который все детали реализации промышленной системы обсудили
[14:22.000 --> 14:25.000]  на основе Paxos и RSM.
[14:25.000 --> 14:27.000]  То есть как делать exec nuance,
[14:27.000 --> 14:29.000]  как устраивать переконфигурацию.
[14:29.000 --> 14:32.000]  Такой целый учебник на 260 страниц.
[14:32.000 --> 14:36.000]  Это тема второго нашего занятия сегодня.
[14:36.000 --> 14:43.000]  И плюс к этому автор написал просто референсную реализацию
[14:43.000 --> 14:45.000]  алгоритма RAFT.
[14:45.000 --> 14:48.000]  Реализация даже не RAFT, а RSM поверх RAFT.
[14:48.000 --> 14:52.000]  То есть если вдруг вы читаете статью на английском,
[14:52.000 --> 14:56.000]  и вы чего-то не понимаете в ней, какая-то бессмысленность остается,
[14:56.000 --> 15:00.000]  если вам чего-то не хватает вот на этой страничке,
[15:00.000 --> 15:05.000]  то вы просто идете открываете код на C++, кстати.
[15:05.000 --> 15:07.000]  Ну и его там читаете.
[15:07.000 --> 15:10.000]  И у вас уже не остается никаких сомнений о том, что происходит.
[15:15.000 --> 15:19.000]  Вот, пожалуйста, у вас есть два типа сообщений в RAFT.
[15:19.000 --> 15:23.000]  Append Entries для репликации и RequestWall для выбора лидера.
[15:23.000 --> 15:25.000]  И вот открываете репозиторий LookAbin
[15:25.000 --> 15:27.000]  и смотрите обработчик Append Entries.
[15:27.000 --> 15:32.000]  Вот как реплика реагирует на это сообщение.
[15:32.000 --> 15:33.000]  Пожалуйста, читайте код,
[15:33.000 --> 15:36.000]  и никаких сомнений у вас уже не остается в том, что происходит.
[15:36.000 --> 15:38.000]  Довольно мелко.
[15:38.000 --> 15:40.000]  Можно разглядеть что-то.
[15:40.000 --> 15:42.000]  Вот у вас есть request, вот у вас есть response.
[15:42.000 --> 15:44.000]  Читаете request, заполните response.
[15:48.000 --> 15:50.000]  Ну и да, тут можно посмотреть на протокол.
[15:50.000 --> 15:53.000]  Вот протоописание всех сообщений опять.
[15:53.000 --> 15:57.000]  Можно посмотреть, что именно RAFT с каждым сообщением отправляет.
[16:03.000 --> 16:06.000]  Вот все поля, которые есть в описании статьи, они тут будут.
[16:06.000 --> 16:11.000]  Ну, может быть, будет еще что-то, если какую-то юристику можно дополнительно придумать.
[16:11.000 --> 16:15.000]  Замечательно. Есть референсная реализация.
[16:15.000 --> 16:22.000]  Кроме того, у RAFT есть собственный сайт, где есть список промышленных реализаций RAFT.
[16:22.000 --> 16:25.000]  Ну, точнее, список всех реализаций RAFT open-source.
[16:25.000 --> 16:28.000]  Но вот наверху, в топе, где больше всего звездочек,
[16:28.000 --> 16:30.000]  это реализации, которые используются в промышленных системах.
[16:30.000 --> 16:36.000]  TCD – это Key Value хранилища сервисной переконфигурации.
[16:36.000 --> 16:40.000]  TKW – это Key Value хранилища.
[16:40.000 --> 16:44.000]  Ну, в общем, разные промышленные системы используют для себя RAFT.
[16:44.000 --> 16:46.000]  Написано на разных языках.
[16:46.000 --> 16:48.000]  И вот, пожалуйста, есть ссылки на репозитории.
[16:48.000 --> 16:51.000]  И есть описание, какой функциональности они обладают.
[16:51.000 --> 16:55.000]  Ну, видимо, популярные умеют все, что угодно.
[16:56.000 --> 17:00.000]  Вот, опять же, если вы пишете, не знаю, на ГО, приходите и используете вот эту реализацию.
[17:00.000 --> 17:09.000]  Рокс DB – это локальное хранилище.
[17:09.000 --> 17:11.000]  Ему не нужен консенсус.
[17:11.000 --> 17:14.000]  Ну, то есть это более низкий уровень архитектуры,
[17:14.000 --> 17:17.000]  который отвечает за хранение данных на одной машине.
[17:17.000 --> 17:20.000]  А дальше, если ты хочешь, чтобы эти данные хранились не только на одной машине,
[17:20.000 --> 17:23.000]  на трех машинах, то ты должен поверхне сделать консенсус.
[17:23.000 --> 17:25.000]  И вот уже консенсус делаешь с помощью RAFT.
[17:25.000 --> 17:27.000]  Ну, или с помощью мультипаксиса.
[17:27.000 --> 17:32.000]  То есть это такие дополняющие друг друга части, отдельные слои архитектуры.
[17:32.000 --> 17:37.000]  Вот, ну, да, я говорю о том, что и то, и другое можно не писать своими руками.
[17:37.000 --> 17:42.000]  Каждый раз можно взять реализацию Open Source RAFT, реализацию Open Source,
[17:42.000 --> 17:48.000]  реализацию библиотека у Рокс DB и вот скомбинировать из них свое решение.
[17:48.000 --> 17:53.000]  Ну и вообще, помимо того, что я сказал, есть полное описание в статье,
[17:53.000 --> 17:57.000]  есть референсная реализация, есть Open Source реализация.
[17:57.000 --> 18:03.000]  Еще одна сильная сторона RAFT в том, что авторы постарались сделать его понятным.
[18:03.000 --> 18:05.000]  Ну, то есть это было их дополнительное усилие,
[18:05.000 --> 18:10.000]  помимо того, что они придумали более разумный алгоритм консенсуса,
[18:10.000 --> 18:16.000]  они более подходящие для промышленной реализации, они постарались еще доступно донести его.
[18:16.000 --> 18:19.000]  Вот они сделали слайды, которые мы как раз будем смотреть сейчас.
[18:19.000 --> 18:24.000]  Они прочитали про него лекцию, они сделали слайд с анимацией.
[18:24.000 --> 18:30.000]  Ну, короче, они сделали все, чтобы вы полюбили RAFT.
[18:30.000 --> 18:32.000]  Ну, а Лэмпорт написал про Грегов смешную статью.
[18:32.000 --> 18:38.000]  Я не знаю, что вам ближе, но если перед вами задача через 3 месяца запуститься в продакшн или через год,
[18:38.000 --> 18:43.000]  то, наверное, понятно, что вы выберете.
[18:43.000 --> 18:51.000]  Ну что, вот так авторы аргументируют, что RAFT лучше, чем Paxos.
[18:51.000 --> 18:54.000]  RAFT больше подходит вам как инженеру, чем Paxos.
[18:54.000 --> 19:01.000]  Ну и, наверное, можно послушать теперь про сам алгоритм, как он устроен.
[19:01.000 --> 19:16.000]  Для этого мы будем смотреть слайды AfterFRAFT.
[19:16.000 --> 19:20.000]  Ну что, поехали. RAFT решает задачу репликации лога.
[19:20.000 --> 19:24.000]  Как обычно, у нас есть клиенты, у нас есть, допустим, 3 реплики.
[19:24.000 --> 19:30.000]  Каждый из них хранит копию лога и хранит свою копию автомата.
[19:30.000 --> 19:36.000]  Когда клиент посылает команду какой-то реплики, она видимо лидеру об этом чуть позже,
[19:36.000 --> 19:43.000]  он помещает ее в какой-то слот и реплицирует с помощью некоторого модуля консенсуса,
[19:43.000 --> 19:48.000]  это такая очень условная картинка, больше про RSM, чем про RAFT, в логе других реплик.
[19:48.000 --> 19:54.000]  Ну и после того, как реплика зафиксировала команду в своем логе и зафиксировала все команды в логе перед ней,
[19:54.000 --> 19:57.000]  она может применить ее к своей копии автомата.
[19:57.000 --> 19:59.000]  Вот здесь все, в общем, как обычно.
[19:59.000 --> 20:06.000]  Да, мы работаем в модели с отказами или стартами узлов, сообщения в сети могут задерживаться или теряться,
[20:06.000 --> 20:11.000]  но мы не допускаем византийских отказов, то есть мы не ожидаем, что реплика может потерять свой диск
[20:11.000 --> 20:15.000]  и мы не ожидаем, что реплика может нарушать протокол, разумеется.
[20:16.000 --> 20:22.000]  И мы должны обслуживать клиентов, когда доступно большинство узлов в кластере.
[20:23.000 --> 20:28.000]  RAFT использует подход с выбором лидера.
[20:28.000 --> 20:33.000]  Вот в прошлый раз мы отталкивались от мультипакс наивного, где у нас лидера не было, где все реплики конкурировали.
[20:33.000 --> 20:38.000]  В RAFT лидер выбирается, и более того, RAFT без лидера не работает.
[20:38.000 --> 20:44.000]  Для того, чтобы реплицировать команду, для того, чтобы обслуживать клиентов, RAFT-у необходим лидер.
[20:45.000 --> 20:54.000]  Ну и я уже сказал, что RAFT декомпозирует стадии, где лидер выбирается, потому что предыдущий умер,
[20:54.000 --> 20:59.000]  и стадию, где лидер стабильный, он просто реплицирует команды.
[20:59.000 --> 21:03.000]  Вот мы рассматриваем эти случаи в изоляции.
[21:03.000 --> 21:05.000]  По крайней мере, начнем.
[21:05.000 --> 21:09.000]  Итак, наш план. Сначала мы обсудим, как выбирать лидера, потом мы обсудим, как работает репликация,
[21:09.000 --> 21:12.000]  потом мы докажем, что все корректно.
[21:16.000 --> 21:24.000]  Во-первых, в RAFT, как и в алгоритме мультипакс, как и во всех наших алгоритмах, есть роли.
[21:24.000 --> 21:29.000]  Есть роль лидера, который реплицирует, который получает запросы клиентов,
[21:29.000 --> 21:32.000]  выкладывает их в лог и реплицирует их.
[21:32.000 --> 21:36.000]  Есть роль фолловера, который слушает лидера, принимает от него команды и подтверждает,
[21:36.000 --> 21:38.000]  что он их надежно сохранил у себя.
[21:38.000 --> 21:41.000]  И есть кандидат. Это такое промежуточное состояние.
[21:41.000 --> 21:45.000]  При переходе от, когда фолловер понимает, что старый лидер умер,
[21:45.000 --> 21:49.000]  он становится кандидатом и, возможно, избирается новым лидером после этого.
[21:49.000 --> 21:55.000]  Ну и вот тут есть автомат переходов между этими ролями. Его мы разберем чуть позже.
[21:55.000 --> 22:01.000]  Сейчас важно отметить, что эти роли, в отличие от ролей алгоритмы мультипакса,
[22:02.000 --> 22:08.000]  совзаимо исключающие. То есть каждая реплика или лидер, или фолловер, или кандидат.
[22:08.000 --> 22:15.000]  Можно сказать, что это еще одно преимущество RAF, потому что об этом думать проще.
[22:15.000 --> 22:20.000]  В мультипаксасе у нас реплика и acceptor, и proposer совмещает в себе разные поведения,
[22:20.000 --> 22:28.000]  а вот в RAF-те поведение одно, и мы фиксируем его в переменной состоянии реплики.
[22:28.000 --> 22:35.000]  Каждая реплика проходит, время для нее делится на термы,
[22:35.000 --> 22:40.000]  пронумерованные подряд натуральными числами.
[22:40.000 --> 22:46.000]  Каждый терм состоит из двух фаз. В каждом терме сначала выбирается лидер,
[22:46.000 --> 22:52.000]  а потом этот лидер реплицирует команды. Если лидер умирает, то, видимо,
[22:52.000 --> 22:55.000]  начинается новый терм, в нем выбирается новый лидер,
[22:55.000 --> 23:01.000]  и дальше он реплицирует команду, пока с ним что-то не случится.
[23:01.000 --> 23:07.000]  RAF гарантирует, что в каждом терме может быть выбран не более одного лидера,
[23:07.000 --> 23:10.000]  но бывают термы, в которых лидер вообще не выбран.
[23:10.000 --> 23:15.000]  Здесь третий терм, в нем лидера вообще не будет.
[23:15.000 --> 23:19.000]  Эта картинка у каждой реплики своя.
[23:19.000 --> 23:23.000]  То есть, скажем, реплика могла надолго заснуть и какие-то термы вообще пропустить,
[23:23.000 --> 23:27.000]  ничего о них не знать. Или она просто лежала выключенная, потом поднялась и узнала,
[23:27.000 --> 23:31.000]  что сейчас уже какой-то сотый терм идет. Это нормально.
[23:31.000 --> 23:35.000]  Ну и границы термов могут немного совпадать, потому что у каждой реплики
[23:35.000 --> 23:40.000]  свое локальное знание. В начале каждого терма выбирается лидер,
[23:40.000 --> 23:47.000]  потом он реплицирует команды. Во всем протоколе используется всего два сообщения.
[23:47.000 --> 23:56.000]  На фазе выбора лидера используется сообщение, оно называется request-vote.
[23:56.000 --> 24:03.000]  На фазе репликации используется сообщение append-endress.
[24:03.000 --> 24:10.000]  Всего лишь два сообщения. Request-vote отправляет кандидат, когда он хочет выбраться лидером.
[24:10.000 --> 24:15.000]  Append-endress отправляет лидер-фолловером, когда он реплицирует команды.
[24:15.000 --> 24:21.000]  И как обычно, нужно каким-то образом понимать, что есть лидеры из старых эпох и из новых эпох.
[24:21.000 --> 24:28.000]  Точно так же, как в мультипаксисе. В мультипаксисе у нас реплика, получая команду от лидера,
[24:28.000 --> 24:34.000]  от другой реплики смотрела на n этой команды и сравнивала с своим n.
[24:34.000 --> 24:39.000]  В RAFT происходит та же самая история. Каждая реплика помнит, в каком терме она находится.
[24:39.000 --> 24:43.000]  И каждый лидер, когда он реплицирует команды с помощью сообщения append-endress,
[24:43.000 --> 24:49.000]  перекладывает к этому сообщению свой терм.
[24:49.000 --> 24:57.000]  Если оказывается, что терм лидера меньше, чем терм узла, который получает от него сообщение,
[24:57.000 --> 25:03.000]  то этот узел считает, что лидер уже устарел, услышать его не надо. Он из прошлого терма, из прошлой эпохи.
[25:03.000 --> 25:07.000]  Терм здесь это эквивалентная эпоха в мультипаксисе.
[25:07.000 --> 25:11.000]  Этот терм, конечно же, хранится надежно на узле. То есть узел запоминает его на жесткий диск,
[25:11.000 --> 25:15.000]  если он перезагрузится, то должен его вспомнить.
[25:15.000 --> 25:25.000]  Ну точно так же, как у нас accept-multipaxis надежно запоминает n и отданный голос.
[25:25.000 --> 25:29.000]  Ну по крайней мере, наш терм будет не ниже, чем коронтерм, который мы помнили.
[25:29.000 --> 25:32.000]  Тут речь не о том, что мы не знаем. Мы, конечно, можем пропустить какие-то термы.
[25:32.000 --> 25:36.000]  Но мы не окажемся в терме из прошлого, который мы уже точно прошли.
[25:44.000 --> 25:50.000]  Что? Пока это не протокол, пока это просто идея.
[25:50.000 --> 25:58.000]  Роли мы обсудили, то, что время делится на термы, на эпохи мы обсудили.
[25:58.000 --> 26:03.000]  И теперь давайте поговорим в сторону выбора лидера.
[26:03.000 --> 26:07.000]  Лидер выбирается в начале терма и реплицирует команды.
[26:07.000 --> 26:11.000]  И реплики должны его слушать и как-то понимать, что он все еще жив.
[26:11.000 --> 26:18.000]  Для этого каждый лидер посылает фоллверам, репликам, которые его слушают, специальные сообщения, хардбиты.
[26:18.000 --> 26:20.000]  На самом деле, здесь нет выделенного сообщения хардбит.
[26:20.000 --> 26:24.000]  В RAFT все так потюнино, что сообщений минимум, типа сообщений минимум.
[26:24.000 --> 26:27.000]  Для хардбитов используется append-entries.
[26:27.000 --> 26:31.000]  Если у лидера есть команды, то реплика получает append-entries и понимает, что лидер жив.
[26:31.000 --> 26:37.000]  Если у лидера нет команд, то он посылает просто пустой append-entries, говорит, что я просто жив, но команды у меня пока нет.
[26:37.000 --> 26:42.000]  Каждая реплика, каждый фоллвер заводит себе election-timeout.
[26:42.000 --> 26:45.000]  Заводит таймер величиной election-timeout.
[26:45.000 --> 26:53.000]  И если за вот этот timeout от лидера не приходит ни одного хардбита, ни одного append-entries, пустого лидера с командами,
[26:53.000 --> 26:59.000]  то реплика фоллвер справедливо считает, что, видимо, лидер умер и нужно выбрать нового.
[26:59.000 --> 27:03.000]  И вот мы переходим к процедуре выбора лидера.
[27:03.000 --> 27:10.000]  Для начала реплика, у которой истек этот самый таймер, увеличивает себе терм и становится кандидатом.
[27:10.000 --> 27:13.000]  Ее план – стать лидером.
[27:13.000 --> 27:18.000]  Для этого она посылает сообщение request-vote всем остальным репликам.
[27:18.000 --> 27:21.000]  Говорит, проголосуйте за меня.
[27:21.000 --> 27:26.000]  Ее цель – собрать большинство голосов, собрать quorum.
[27:26.000 --> 27:32.000]  Вот она посылает на все другие реплики сообщение request-vote и ждет.
[27:32.000 --> 27:34.000]  Что случится раньше?
[27:34.000 --> 27:37.000]  Может быть, большинство реплик проголосуют за нее.
[27:37.000 --> 27:40.000]  По какому принципу они будут голосовать?
[27:40.000 --> 27:44.000]  Они будут голосовать пока что за первого кандидата.
[27:44.000 --> 27:50.000]  Вот если вы фоллвер в терме 3, и вам приходит сообщение от кандидата в терме 4,
[27:50.000 --> 27:54.000]  потому что он уже перешел в новый терм, потому что он считает, что лидер старый умер,
[27:54.000 --> 27:56.000]  то вы смотрите, голосовали ли вы за кого-то.
[27:56.000 --> 27:59.000]  Видимо, у вас еще третий терм, у вас уже просто в четвертом проголосовать,
[27:59.000 --> 28:04.000]  вы еще ни за кого не голосовали, вы отдаете голос за этого кандидата и запоминаете его.
[28:04.000 --> 28:08.000]  И больше в терме 4 не голосуете.
[28:08.000 --> 28:14.000]  Так что если вы кандидат, вы либо получите большинство quorum,
[28:14.000 --> 28:18.000]  вернее, таких вот подтверждений на свой request-vote,
[28:18.000 --> 28:24.000]  либо у вас исечет таймер, потому что вы, когда стали кандидатом,
[28:24.000 --> 28:27.000]  снова завели этот таймер на election-timeout,
[28:27.000 --> 28:30.000]  либо выберут вообще не вас.
[28:30.000 --> 28:33.000]  Как вы узнаете, что выбрали не вас?
[28:33.000 --> 28:39.000]  Ну, можно отказы считать, а можно смотреть на сообщения, которые вам приходят.
[28:39.000 --> 28:43.000]  Если вы перешли в четвертый терм и стали там кандидатом,
[28:43.000 --> 28:49.000]  отправили request-vote, а потом получили от кого-то append-entries в терме 4,
[28:49.000 --> 28:54.000]  то это означает, что лидера выбрали, но это не вы, к сожалению.
[28:54.000 --> 28:58.000]  Вы просто знаете, что только лидер может отправлять append-entries,
[28:58.000 --> 29:03.000]  поэтому если вы его получили в терме 4, то значит, что лидер выбран просто это не вы.
[29:03.000 --> 29:06.000]  Так что вы либо получаете большинство подтверждений,
[29:06.000 --> 29:09.000]  либо вы получаете append-entries от нового лидера,
[29:09.000 --> 29:14.000]  либо у вас истекает таймер election-timeout,
[29:14.000 --> 29:17.000]  и вы снова инкриментируете счетчик терма,
[29:17.000 --> 29:20.000]  переходите в новый терм и снова становитесь кандидатом.
[29:23.000 --> 29:25.000]  Понятная идея.
[29:25.000 --> 29:28.000]  Вроде бы очень тривиально все.
[29:31.000 --> 29:35.000]  И вот из такого протокола следует очевидно, что в каждом терме
[29:35.000 --> 29:38.000]  не может быть более одного лидера.
[29:39.000 --> 29:45.000]  Просто потому, что в каждом терме каждая реплика голосует не более одного раза,
[29:45.000 --> 29:52.000]  так что невозможно собрать два разных quorum'а за разных кандидатов.
[29:52.000 --> 29:55.000]  В пересечении будет реплика, которая обязана проголосовать дважды,
[29:55.000 --> 29:57.000]  и это запрещается делать.
[29:57.000 --> 30:02.000]  Но внимание, это не означает, что у вас не может быть двух лидеров в кластере.
[30:02.000 --> 30:07.000]  У вас не может быть двух лидеров в одном терме, а в разных могут.
[30:07.000 --> 30:11.000]  Ну и вот такой процедурой есть недостатки.
[30:11.000 --> 30:17.000]  Вот один из них большой и маленький, простой и сложный.
[30:17.000 --> 30:24.000]  Вот простой недостаток в том, что откуда возьмется LiveNas в таком решении.
[30:24.000 --> 30:30.000]  Представьте, что у вас есть реплики, ну и вообще в RAFT'е кластер начинает жить в состоянии follower.
[30:30.000 --> 30:32.000]  То есть каждая реплика является follower.
[30:32.000 --> 30:36.000]  Они все заводят себе тайм-аут, заводят один и тот же таймер,
[30:36.000 --> 30:39.000]  он в одно и то же время истекает на всех репликах.
[30:39.000 --> 30:42.000]  Они все становятся кандидатами и пытаются голосовать.
[30:42.000 --> 30:45.000]  И в итоге, я не знаю, каждый голосует за себя.
[30:45.000 --> 30:51.000]  Или у вас 5 реплик, и первые две проголосовали за одного кандидата,
[30:51.000 --> 30:55.000]  третий проголосовал за второго, четвертый и пятый проголосовал за третьего.
[30:55.000 --> 30:57.000]  Никто большинства не набрал.
[30:57.000 --> 31:02.000]  В итоге у всех истек таймер election-тайм-аута, они все перешли в новую эпоху
[31:02.000 --> 31:06.000]  и пытаются друг за друга поголосовать, ну за себя в первую очередь.
[31:06.000 --> 31:10.000]  Никакого прогресса не будет, какой-то lifelock получается бесполезный.
[31:10.000 --> 31:18.000]  Поэтому, чтобы как-то, чтобы добиться прогресса, мы хотим рандомизировать тайм-ауты,
[31:18.000 --> 31:24.000]  которые заводит реплика на случай, когда хорбиты заканчиваются.
[31:24.000 --> 31:27.000]  Рандомизация помогает по очень простой причине.
[31:27.000 --> 31:33.000]  Какая-то реплика, на какой-то реплике тайм-аут протухнет раньше, чем на других,
[31:33.000 --> 31:37.000]  и она первой станет кандидатом, и в одиночестве запросит голоса у других.
[31:37.000 --> 31:41.000]  И, видимо, выиграет. Понятна идея?
[31:44.000 --> 31:46.000]  Голосы дают реплики.
[31:47.000 --> 31:51.000]  Смотри.
[31:51.000 --> 31:57.000]  Во-первых, если ты, любая реплика, и ты получаешь сообщение, любое,
[31:57.000 --> 32:01.000]  ты сравниваешь терм свой локальный и терм сообщения.
[32:01.000 --> 32:05.000]  Если он меньше, ты его просто игнорируешь. Он не актуален для тебя.
[32:05.000 --> 32:09.000]  А если он больше, то ты голосуешь или нет.
[32:09.000 --> 32:15.000]  Потому что тебя переводит в будущую эпоху, про которую ты раньше не знал.
[32:21.000 --> 32:25.000]  Про это все на стадии RAF есть анимация. Можно посмотреть на анимацию.
[32:25.000 --> 32:30.000]  Смотрите. Что здесь происходит? Здесь есть лидер, S1,
[32:30.000 --> 32:35.000]  и он периодически рассылает append-endress пустые, то есть хорбиты,
[32:35.000 --> 32:40.000]  напоминая репликам, что он все еще жив, что он все еще лидер.
[32:40.000 --> 32:44.000]  Давайте замедлим время.
[32:49.000 --> 32:53.000]  Видите, у каждой реплики такой бар ползет вниз.
[32:53.000 --> 32:57.000]  Это reaction-timeout. Он истекает, истекает, истекает.
[32:57.000 --> 33:02.000]  Если он истечет, а реплика не получит хорбита, то она решит, что лидер умер.
[33:02.000 --> 33:07.000]  И когда реплика получает хорбит, ну вот ждем, смотрим на это,
[33:07.000 --> 33:11.000]  вот хорбит летит, бабах, и таймер сбросился.
[33:11.000 --> 33:16.000]  Ну вот полный круг, это 2t, 2 reaction-timeout.
[33:16.000 --> 33:21.000]  Но когда мы получаем хорбит, мы сбрасываем на какое-то,
[33:21.000 --> 33:26.000]  на случайное значение в диапазоне от t до 2t.
[33:26.000 --> 33:31.000]  Ну а теперь, видимо, остановим лидера.
[33:31.000 --> 33:36.000]  И ускорим время. Кто должен выиграть?
[33:36.000 --> 33:41.000]  S3, видимо, должен выиграть.
[33:41.000 --> 33:47.000]  За счет рандомизации тайм-аутов этот S3 станет первым кандидатом.
[33:47.000 --> 33:51.000]  И вот он отправляет request-vote.
[33:51.000 --> 33:58.000]  Он перешел в терм 3, отправил request-vote, и сейчас собирается получить кворум подтверждения, видимо.
[33:58.000 --> 34:05.000]  Да, ну потому что такова процедура. Вот мы говорили об этом сейчас.
[34:05.000 --> 34:11.000]  Вот, если истекает reaction-timeout, если мы не получаем долгое время хорбитов,
[34:11.000 --> 34:16.000]  то мы увеличиваем терм и становимся кандидатом в новом терме.
[34:16.000 --> 34:23.000]  Ну и вот мы получили большинство подтверждений, и теперь мы новый лидер в новом терме.
[34:23.000 --> 34:34.000]  Они перешли в новый терм, потому что они получили сообщение с термом 3.
[34:34.000 --> 34:39.000]  Ну и они стали фолловером, потому что теперь у нас есть новый лидер.
[34:39.000 --> 34:45.000]  Ну вот такой простой протокол выбора лидера.
[34:45.000 --> 34:54.000]  Про safety все очевидно, про liveness тоже понятно, что мы рандомизируем timeout,
[34:54.000 --> 34:59.000]  что это помогает нам избежать конкуренции среди кандидат.
[34:59.000 --> 35:03.000]  Ну а дальше лидер, если он выбран, начинает реплицировать лог.
[35:03.000 --> 35:07.000]  Что такое лог? Ну опять, это последовательство слотов.
[35:07.000 --> 35:14.000]  В каждом слоте лежит команда и терм, в котором ее туда положили.
[35:14.000 --> 35:20.000]  Судя по этой картинке, у нас есть 3 терма, лидер прямо сейчас в терме 3 находится,
[35:20.000 --> 35:27.000]  а команда red попала в лог в терме 1. Ее туда положил лидер из терма 1.
[35:27.000 --> 35:34.000]  Ну и как обычно, у нас логи есть, но не факт, что все команды этого лога можно применить,
[35:34.000 --> 35:37.000]  потому что не все из них надежно зафиксированы.
[35:37.000 --> 35:41.000]  Так что у каждого лога есть некоторый языкомичный префикс,
[35:41.000 --> 35:45.000]  у каждой реплики языкомичный префикс, про который реплика знает,
[35:45.000 --> 35:49.000]  что его можно безопасно применять.
[35:49.000 --> 35:55.000]  RAFT пытается и здесь быть проще мультипаксиса.
[35:55.000 --> 36:00.000]  Ну вот он был проще, потому что, во-первых, мы в процедуре выбора лидера
[36:00.000 --> 36:06.000]  связали n и лидеров. Теперь лидеры и эпохи связаны друг с другом
[36:06.000 --> 36:14.000]  вот этими, через переменную карантеру. Мы упростили протокол репликации за счет того,
[36:14.000 --> 36:19.000]  что теперь реплика бывает только в одном состоянии, она играет ровно одну роль всегда.
[36:19.000 --> 36:27.000]  И дальше RAFT упрощает задачу репликации лога еще и тем, что состояние лога меньше,
[36:27.000 --> 36:32.000]  чем в мультипаксисе. В мультипаксисе мы видели, что в каждом слоте написано
[36:32.000 --> 36:37.000]  предложение аксептора изрированного инстанца паксиса. Там написано nA, va, nP.
[36:37.000 --> 36:41.000]  И вот это va может меняться, потому что аксептор может голосовать сначала за одно,
[36:41.000 --> 36:44.000]  предложение потом за другое, и команда может меняться в слоте.
[36:44.000 --> 36:50.000]  Так что логи, вообще говоря, могут быть совершенно разные, и в них еще и дырки могут быть.
[36:50.000 --> 36:53.000]  В RAFT все проще, потому что, во-первых, дырок не бывает.
[36:53.000 --> 36:59.000]  Все операции с логом, они меняют его суффикс, либо добавляют в конец лога что-то,
[36:59.000 --> 37:04.000]  либо стирают из конца лога что-то. Делать что-то с середины лога нельзя.
[37:04.000 --> 37:11.000]  RAFT так не делает. И есть очень простое свойство, согласно которому лидер
[37:11.000 --> 37:16.000]  никогда из своего лога ничего не стирает. Он только в него добавляет.
[37:16.000 --> 37:22.000]  То есть вы стали лидером, вы получаете команды, вы добавляете их в лог,
[37:22.000 --> 37:37.000]  и вы их реплицируете. Что значит реплицировать? Смотрите по-другому.
[37:37.000 --> 37:42.000]  Логи на разных репликах, конечно, могут расходиться, потому что лидеры меняются,
[37:42.000 --> 37:48.000]  они реплицируют какие-то команды в разном порядке, но RAFT поддерживает такой простой вариант,
[37:48.000 --> 37:53.000]  простой и очень мощный. Возьмем две произвольные реплики, возьмем их логи,
[37:53.000 --> 37:59.000]  посмотрим в некоторые слоты на этих двух логах. Например, слот 4.
[37:59.000 --> 38:06.000]  Если в этом слоте лежит запись с одним и тем же термом, например, 2,
[38:06.000 --> 38:13.000]  то это означает, что во-первых, и команда в этом слоте совпадает на двух репликах,
[38:13.000 --> 38:21.000]  а во-вторых, что совпадают и префикс этих логов целиком до данного слота включительного.
[38:21.000 --> 38:31.000]  Понятно? Вот ровно поэтому дальше в слайдах про RAFT нигде не пишут команды.
[38:31.000 --> 38:38.000]  Если у вас есть третий слот в двух логах, и там написана одна и та же цифра, одно и то же число,
[38:38.000 --> 38:45.000]  один и тот же терм, то команды совпадают в этих слотах и совпадают оба префикса.
[38:45.000 --> 38:53.000]  Как мы гарантируем такое свойство? Индуктивной проверкой простой.
[38:53.000 --> 39:00.000]  Вы лидер, вы получили от клиента команду jump и положили ее в пятый слот.
[39:00.000 --> 39:05.000]  И хотите реплицировать ее на другой лог, на другую реплику.
[39:05.000 --> 39:09.000]  Вы посылаете сообщение append-entries для этого.
[39:09.000 --> 39:15.000]  Прикладываете к нему свой терм, чтобы реплика могла понять, нужно вас слушать или нет.
[39:15.000 --> 39:22.000]  Но вместе с этим вы еще хотите убедиться, что префиксы ваших логов совпадают.
[39:22.000 --> 39:33.000]  Предполагаем по индукции, что это свойство уже имеет место, и нам нужно просто его продлить дальше.
[39:33.000 --> 39:43.000]  А вместе с append-entries и с командой запись, которую мы положили в float5, нужно отправить еще позицию,
[39:43.000 --> 39:52.000]  от которой мы добавляем эту команду, и номер терма в этой позиции в логе лидера, в нашем логе.
[39:52.000 --> 40:01.000]  То есть мы говорим реплике фоллуверу, что мы хотим записать команду jump после индекса 4,
[40:01.000 --> 40:06.000]  и у нас в логе в индексе 4 находится команда с термом 2.
[40:06.000 --> 40:10.000]  Что делает фоллувер, который получает такой append-entries?
[40:10.000 --> 40:19.000]  Он берет свой четвертый слот и сравнивает содержимое терма в своей записи.
[40:19.000 --> 40:22.000]  Если он видит, что терма совпадает, то он команду jump себе добавляет.
[40:22.000 --> 40:33.000]  Если логи расходятся в предыдущей позиции, то, видимо, команду добавлять нельзя, потому что мы нарушим это свойство.
[40:33.000 --> 40:39.000]  Что делать?
[40:39.000 --> 40:43.000]  Ну, видимо, нужно чужие логи чинить.
[40:43.000 --> 40:49.000]  Вот мы лидер в терме 7, мы хотим положить команду в слот 11.
[40:49.000 --> 40:56.000]  Мы отправляем другим фоллуверам вместе с этой командой информацию, что у нас последний слот это 10,
[40:56.000 --> 41:01.000]  и в нем лежит команда из терма 6.
[41:01.000 --> 41:04.000]  Ну, если у фоллувера совпадает все, то он просто добавляет новую запись.
[41:04.000 --> 41:07.000]  А если не совпадает, то по двум причинам не совпадает.
[41:07.000 --> 41:16.000]  Либо этот слот у фоллувера вообще пустой, либо он отличается.
[41:16.000 --> 41:20.000]  Ну, если пустой, то нужно просто откатиться на какую-то позицию раньше.
[41:20.000 --> 41:26.000]  Видимо, реплика отстает, и на нее нужно дореплицировать наш лог.
[41:26.000 --> 41:32.000]  Если же содержимое расходится, то есть здесь лежит запись с другим термом,
[41:32.000 --> 41:35.000]  то мы должны лог у этой реплики стереть.
[41:35.000 --> 41:38.000]  Вот стереть до тех пор, пока префикс не начнет совпадать.
[41:38.000 --> 41:42.000]  Видимо, до позиции 3.
[41:42.000 --> 41:45.000]  Ну, и тут просится какие-то простые оптимизации.
[41:45.000 --> 41:51.000]  Скажем, если вы отправили append-entries на реплику с позиции 10,
[41:51.000 --> 41:57.000]  а на реплике лог короткий, то что нам должно ответить?
[41:57.000 --> 42:02.000]  Во-первых, что не получилось, а во-вторых, что у меня лог сейчас длины 4,
[42:02.000 --> 42:06.000]  чтобы лидер мог откатиться сразу на эту позицию.
[42:06.000 --> 42:11.000]  А что делать в реплике, у которой лог разошелся с лидером?
[42:11.000 --> 42:13.000]  А что он отвечает?
[42:13.000 --> 42:15.000]  Ну, она говорит, разошлось.
[42:15.000 --> 42:17.000]  Что вы делаете на месте лидера?
[42:17.000 --> 42:19.000]  Ну, сначала откатываетесь на одну позицию назад.
[42:19.000 --> 42:22.000]  Пробуйте еще раз. Не сошлось снова.
[42:22.000 --> 42:25.000]  Откатываетесь на две позиции назад. На 4, на 8 и так далее.
[42:25.000 --> 42:28.000]  Ну, в общем, тут нужно как-то чуть быстрее откатываться, чем по одной позиции.
[42:28.000 --> 42:30.000]  По одной будет не эффективно, конечно.
[42:35.000 --> 42:38.000]  Стираем логи. Ну, в смысле, мы говорим, мы лидер,
[42:38.000 --> 42:41.000]  мы должны реплицировать свой лог на каждого фоллувера.
[42:41.000 --> 42:46.000]  Вот ты для каждого фоллувера берешь и пытаешься в него писать свой лог.
[42:46.000 --> 42:48.000]  А он тебе говорит, не сходится.
[42:48.000 --> 42:53.000]  Ну, значит, ты пробуешь писать в него свой лог с позиции раньше.
[42:53.000 --> 42:58.000]  Вот. Когда я говорю, что лидер стирает лог на фоллувере, я говорю,
[42:58.000 --> 43:02.000]  что вот если здесь не сошлось, например, в восьмой позиции,
[43:02.000 --> 43:07.000]  то на фоллувере дропается весь суффикс этого лога с восьмой позиции.
[43:08.000 --> 43:25.000]  В смысле, он посылает с каждым сообщением свой терм.
[43:25.000 --> 43:28.000]  Если фоллувер этот терм устраивает, значит, все нормально.
[43:37.000 --> 44:02.000]  Да вообще может по-разному случаться.
[44:02.000 --> 44:07.000]  Вот тут изображена какая-то картинка, как образовались какие-то логи.
[44:07.000 --> 44:11.000]  Какое-то странное исполнение, в нем логи получились такими.
[44:11.000 --> 44:15.000]  Я сейчас к ней перейду, но мне важно еще что сказать.
[44:15.000 --> 44:22.000]  Смотрите, лидер всегда верит в свой лог, никогда в нем не сомневается
[44:22.000 --> 44:27.000]  и стирает логи других. Поэтому лидера нужно выбирать аккуратно.
[44:27.000 --> 44:31.000]  В мультипаксисе можно было не аккуратно выбирать лидера,
[44:31.000 --> 44:34.000]  потому что, помните, мы выбирали лидера с пустым логом,
[44:34.000 --> 44:39.000]  и тем не менее он через первую фазу Prepr через Promises узнавал про закоммичные команды.
[44:39.000 --> 44:45.000]  Здесь лидера так не делает. Он получает лог и приводит все остальные логи к своему виду.
[44:45.000 --> 44:48.000]  Поэтому если мы выберем лидера с пустым логом, например,
[44:48.000 --> 44:51.000]  то он просто сотрет все, что было записано на репликах,
[44:51.000 --> 44:54.000]  и кажется наш RSM пострадает от этого.
[44:54.000 --> 45:00.000]  Поэтому процедура голосования, которая описана в начале слайдов, неправильная, конечно.
[45:00.000 --> 45:08.000]  По крайней мере, я перестаю авторам Рафта верить, что у них все просто и декомпозированно.
[45:08.000 --> 45:11.000]  Вот они говорят, у них есть фаза выбора лидера и фаза репликации,
[45:11.000 --> 45:15.000]  но при этом фаза выбора лидера сначала неправильно описывается, а потом мы ее чиним,
[45:15.000 --> 45:17.000]  потому что в таком виде она не годится.
[45:17.000 --> 45:23.000]  Она не годилась, потому что фолловеры голосовали за первого кандидата, которого они видели.
[45:24.000 --> 45:33.000]  Так нельзя, конечно. Они должны голосовать тогда, когда у нового кандидата какой-то разумный лог.
[45:36.000 --> 45:38.000]  А что значит разумный? Давайте подумаем.
[45:43.000 --> 45:48.000]  Вот за какого кандидата вы стали бы голосовать? На что бы вы смотрели?
[45:48.000 --> 45:52.000]  Ну, что значит на лог? На что именно в логе ты бы смотрел?
[45:54.000 --> 46:06.000]  На размер лога смотреть не стоит, потому что у вас может быть лидер в маленьком терме,
[46:06.000 --> 46:11.000]  на которого пришло 150 команд, положил их к себе в лог, а потом с ним что-то случилось,
[46:11.000 --> 46:15.000]  эпоха поменялась, что там произошло полезно, а потом вернулись вы с этим длинным логом,
[46:15.000 --> 46:20.000]  и в итоге почему-то у вас все должны верить. Нет, нужно выбирать лидера, который много повидал,
[46:20.000 --> 46:26.000]  у которого последняя запись в логе с большим термом, который прошел через много эпох.
[46:27.000 --> 46:32.000]  Так что правила голосования, сейчас мы их найдем, выглядят следующим образом.
[46:35.000 --> 46:40.000]  Мы голосуем за кандидата, если, во-первых, в текущем терме мы еще не голосовали,
[46:40.000 --> 46:48.000]  а во-вторых, если у него последний терм в логе больше нашего, или он равен, но лог длиннее.
[46:50.000 --> 46:53.000]  Вот так мы тюнем правила голосования.
[46:56.000 --> 47:01.000]  Автор RAF так говорит, что алгоритм Paxos не очевиден, мне кажется, что алгоритм RAF тоже не очевиден,
[47:01.000 --> 47:07.000]  потому что, ну я не знаю, почему бы он был очевиден, почему должно быть очевидно,
[47:07.000 --> 47:11.000]  что мы выбирая лидера таким образом стирать чужие логи, никогда ничего не поломаем.
[47:13.000 --> 47:17.000]  Но к этому мы сейчас вернемся еще, а пока посмотрим на картинку, вот какая-то картинка,
[47:17.000 --> 47:20.000]  давайте подумаем, как такое могло получиться вообще.
[47:27.000 --> 47:33.000]  Сначала лидером в первом терме был кто-то, не важно кто, ну, допустим, S1.
[47:34.000 --> 47:36.000]  Во втором терме лидером стал кто?
[47:37.000 --> 47:42.000]  S5, он положил в себе в лог две команды, одну из них успел реплицировать на S4,
[47:42.000 --> 47:44.000]  а потом что-то случилось.
[47:44.000 --> 47:49.000]  Начался третий терм и лидером стал 100 у S5, он положил в себе еще три команды в лог,
[47:49.000 --> 47:55.000]  не успел ничего сделать, перезагрузился и лидером стал S4.
[47:56.000 --> 48:01.000]  Почему? Ну, вообще-то у него терм последний меньше, чем у S5,
[48:02.000 --> 48:08.000]  но с другой стороны, он мог собрать хвором из первых трех, первых четырех реплик.
[48:09.000 --> 48:12.000]  То есть, пятый он проигрывает в этом правиле голосования,
[48:12.000 --> 48:15.000]  но с другой стороны, хвором у него собирается.
[48:15.000 --> 48:19.000]  Поэтому S4 становится лидером в четвертом терме, кладет в свой лог одну команду от клиента,
[48:19.000 --> 48:26.000]  после этого снова перезагружается, наступает пятый терм, в нем лидером выбирается, видимо, S3.
[48:27.000 --> 48:33.000]  S3 кладет две команды себе в лог, одну из них пишет на первые три реплики.
[48:34.000 --> 48:36.000]  Да, вот почему выбрали лидером S3?
[48:36.000 --> 48:39.000]  Хотя у него лог заканчивается на единицу, а здесь S4, а здесь С3.
[48:39.000 --> 48:44.000]  Ну опять, потому что собирается вот такой вот хвором из первых трех.
[48:47.000 --> 48:59.000]  Мы кладем сюда три команды эти, перезагружаемся, лидером выбирается S1,
[48:59.000 --> 49:03.000]  потому что она набирает хвором, она не может собрать в хвороме S3, например,
[49:03.000 --> 49:07.000]  потому что S3 лог длиннее. Последний терм такой же, а лог длиннее.
[49:07.000 --> 49:13.000]  Но она может собрать хвором из S1, S2 и, скажем, S4 и S5 тоже туда могут войти.
[49:14.000 --> 49:21.000]  Пишем сюда шестерки, опять что-то случается, ну и потом лидером в седьмом терме становится S2.
[49:21.000 --> 49:25.000]  В общем, понятно, что логи как-то странно расходятся.
[49:28.000 --> 49:32.000]  Ну и что? А что остается? Ну расходятся и расходятся.
[49:33.000 --> 49:39.000]  При этом, вроде бы, неприятно, конечно, но вроде бы они не в паксис, они всегда сходились.
[49:42.000 --> 49:48.000]  Что нам остается сделать? Вот мы вроде бы проговорили, как работает процедура выбора лидера.
[49:50.000 --> 49:56.000]  Мы заводим election timer, ждем heartbeats, append entries. Если мы их не получаем и таймер протухает,
[49:56.000 --> 50:00.000]  то мы переходим в новую эпоху, становимся кандидатом, отправляемся им в request-votes,
[50:00.000 --> 50:06.000]  в которых указываем свой терм, свою последнюю запись в логе, терм последней записи в логе и длину лога.
[50:06.000 --> 50:10.000]  И если мы собираем большинство голосов, то мы становимся лидером.
[50:11.000 --> 50:20.000]  А дальше мы введем свой лог, реплицируем его и сводим логи всех фолверов к своему
[50:20.000 --> 50:25.000]  с помощью такой индуктивной проверки, сравнивая последнюю предшествующую запись.
[50:26.000 --> 50:29.000]  В принципе, это весь RAFT.
[50:34.000 --> 50:41.000]  Но что остается-то, чтобы он стал нам полезен? То есть правила репликации я рассказал.
[50:41.000 --> 50:44.000]  Вот они.
[50:44.000 --> 51:03.000]  Вот так мы логи реплицируем, стираем и добавляем в них, и вот так мы выбираем голосуем за лидера.
[51:03.000 --> 51:08.000]  Это есть протокол репликации. Что нам не хватает?
[51:08.000 --> 51:10.000]  Что?
[51:10.000 --> 51:15.000]  Ну да, мы не поговорили о том, когда команду можно применять из лога.
[51:15.000 --> 51:18.000]  Когда мы считаем, что она надежно зафиксирована.
[51:20.000 --> 51:30.000]  Вот давайте я у вас спрошу, глядя на эту картинку. Можно ли считать, что команда 5 надежно зафиксирована или нет?
[51:30.000 --> 51:41.000]  Ну или давайте просто придумаем какое-то определение, какая запись является закоммиченной.
[51:46.000 --> 51:53.000]  Сейчас, делать даже не в том, как все узнают о том, что она закоммично зафиксирована, а про то, какую запись мы считаем зафиксированной.
[51:53.000 --> 52:06.000]  Ну то есть, если у нас в одном и том же слоте на Quorum лежит одна и та же команда, то она является надежно зафиксированной и не сотрется уже. Мы в это верим.
[52:06.000 --> 52:17.000]  Вот опыт Paxos вас ничему не научил. Там я тоже спрашивал, верно ли, что если у нас значение лежит на Quorum acceptors, то оно будет выбрано.
[52:17.000 --> 52:29.000]  Вот в Paxos это было не так. Я как-то утверждал, что RAF то тот же самый multipaxos, хоть и называется иначе.
[52:29.000 --> 52:35.000]  Ну, я потому так и говорю, потому что там сценарий такой же есть проблемный. Смотрите.
[52:35.000 --> 52:47.000]  Смотрим в статью. Это не статья. Спасибо.
[52:47.000 --> 53:01.000]  Итак, у нас есть 5 реплик. Сначала лидером выбирается, ну не знаю, кто-то в первом терме, неважно.
[53:01.000 --> 53:08.000]  Потом во втором терме лидером выбирается S1, пишет команду 2 на себя и на S2.
[53:08.000 --> 53:16.000]  Потом что-то случается и лидером в третьем терме выбирается S5, потому что собирает вот такой Quorum.
[53:16.000 --> 53:24.000]  S1 и S2 не проголосуют за S5, а вот эти три проголосуют. S5 стала лидером, получила команду от клиента,
[53:24.000 --> 53:35.000]  положила ее в свой лог в терме 3 и перезагрузилась. Наступил четвертый терм, в нем лидером был выбран S1,
[53:35.000 --> 53:41.000]  потому что он собрал вот такой вот Quorum, допустим. И он получил команду от клиента,
[53:41.000 --> 53:49.000]  какую-то розовую, положил ее в свой лог и хочет ее реплицировать. Он пытается реплицировать ее на реплику S3,
[53:49.000 --> 53:57.000]  и у него не получается, потому что он посылает ей информацию, что у него предшествующий слот был равен 2,
[53:57.000 --> 54:06.000]  и в нем была команда из терма 2, а у реплики S3 там пусто, поэтому она откатывается и дореплицирует туда 2.
[54:06.000 --> 54:16.000]  И вот желтая команда лежит на Quorum, на большинстве реплик. Ну а дальше эпоха снова сменяется,
[54:16.000 --> 54:27.000]  почему-то наступают новые выборы в новом терме, и лидером в терме 5 уже становится реплика S5.
[54:27.000 --> 54:35.000]  Почему бы и нет? За нее могли проголосовать S4, ну сама S5, разумеется, S4, ну и S3 тоже мог проголосовать,
[54:35.000 --> 54:43.000]  потому что у реплики старший терм 3, а здесь старший терм 2. S5 становится лидером в терме 5,
[54:43.000 --> 54:51.000]  ну и благополучно намазывает свой лог на остальных, стирая все, что там было написано.
[54:51.000 --> 54:58.000]  Ну а могло иначе случиться. Могло бы случиться так, что в пятом терме вместо того, чтобы лидером было выбрано S5,
[54:58.000 --> 55:07.000]  лидером мог бы стать снова S1, и тогда он бы дореплицировал там свою команду сверху еще.
[55:07.000 --> 55:16.000]  Вру, конечно, альтернативная картинка, она не про S5, она про S4, ой, про терм 4.
[55:16.000 --> 55:27.000]  Итак, у нас был терм 4, реплика S1, лидер, намазала на реплику S3 запись желтую из слота 2,
[55:27.000 --> 55:33.000]  а дальше либо терм сменился и реплика стала S5, а она стерла эту запись,
[55:33.000 --> 55:41.000]  либо S1 продолжила в четвертом терме и дореплицировала вот эту запись.
[55:41.000 --> 55:45.000]  Вот две такие альтернативные реальности, альтернативные ветки истории.
[55:45.000 --> 55:56.000]  И вот заметим, что здесь S5 могла стать лидером, а здесь уже не могла.
[55:56.000 --> 56:01.000]  Чем-то эти две картинки друг от друга сильно отличаются.
[56:01.000 --> 56:05.000]  Ну, картинки отличаются, разумеется, еще бы, они разные.
[56:05.000 --> 56:11.000]  Речь о том, что, видимо, в одном случае, здесь мы точно не можем считать,
[56:11.000 --> 56:16.000]  что желтая команда закомично зафиксирована, она сотрется.
[56:16.000 --> 56:22.000]  А вот здесь почему-то желтую команду уже довольно сложно стереть,
[56:22.000 --> 56:25.000]  потому что лидером кто здесь может стать?
[56:25.000 --> 56:27.000]  Либо S1, либо S2, либо S3.
[56:27.000 --> 56:38.000]  А по свойству RAF-та лидер никогда не стирает свой лог.
[56:38.000 --> 56:43.000]  Ну что, если у вас какая-то интуиция, когда же команда все-таки зафиксирована в логе надежно?
[56:43.000 --> 56:48.000]  Когда мы можем так сказать?
[56:48.000 --> 56:52.000]  Это максимальный.
[56:52.000 --> 56:54.000]  Дважды стал лидером.
[56:54.000 --> 57:04.000]  Но я боюсь, что я для такого могу продеть новую картинку, где просто больше шагов будет.
[57:04.000 --> 57:10.000]  Вот смотрите, здесь четверка придавила команду 2, и вот все, ее теперь уже не скинуть с Quorum.
[57:10.000 --> 57:17.000]  В RAF-те говорится следующее.
[57:17.000 --> 57:30.000]  Давайте найдем слайд.
[57:30.000 --> 57:40.000]  Мы скажем, что если лидер в термика получил от клиента команду и положил ее на Quorum,
[57:40.000 --> 57:45.000]  то она закоммичена.
[57:45.000 --> 57:59.000]  А поскольку, если команда закоммичена, если лидер в термика положил ее на Quorum,
[57:59.000 --> 58:03.000]  получил ее от клиента и положил на Quorum,
[58:03.000 --> 58:12.000]  то в этой картинке определение коммита не работает, потому что здесь лидер в терме 4
[58:12.000 --> 58:17.000]  положил команду из терма 2 на Quorum, дописал ее на Quorum.
[58:17.000 --> 58:22.000]  А я говорю, что лидер должен получить команду в терме 4 и положить ее в терме 4.
[58:22.000 --> 58:26.000]  В RAF-те эта команда является закоммиченной.
[58:26.000 --> 58:35.000]  А по свойству согласованности логов, то есть она закоммичена, в смысле ее, видимо, нельзя стереть оттуда уже.
[58:35.000 --> 58:42.000]  А по свойству согласованности логов RAF-та, если у нас на Quorum совпадает команда в одном слоте,
[58:42.000 --> 58:48.000]  то совпадают и префиксы. Так что и весь префикс можно считать закоммиченным.
[58:48.000 --> 58:54.000]  Так что отдельная команда закоммичена, если она написана на Quorum лидером текущего терма,
[58:54.500 --> 58:58.000]  если она добавлена в текущем терме в лог и записана на Quorum текущем терме,
[58:58.000 --> 59:07.000]  либо ее сверху придавливает такая команда, то есть либо команда 4 закоммичена,
[59:07.000 --> 59:12.000]  команда розовая закоммичена, потому что она была написана на Quorum и получен в терме 4,
[59:12.000 --> 59:15.000]  а команда 2 закоммичена, потому что она придавливает сверху такой командой.
[59:15.000 --> 59:32.000]  Ну а теперь что остается? Теперь остается доказать. В смысле доказать, что действительно такое определение безопасно использовать в протоколе репликации.
[59:32.000 --> 59:38.000]  То есть команды, зафиксированные по такому определению, действительно из логов не стираются.
[59:38.000 --> 59:50.000]  Вообще у RAF-то все эти утверждения как-то называются. Ну скажем, там есть свойство election safety.
[59:50.000 --> 59:55.000]  Но оно было тривиально, мы про него уже поговорили, что в каждом терме может быть не более одного лидера.
[59:55.000 --> 01:00:00.000]  Просто потому что пересечение кворумов и каждый реплик голосуют только один раз в терме.
[01:00:00.000 --> 01:00:07.000]  Лидер append only означает, что лидер только добавляет в свой лог, никогда из него ничего не стирает.
[01:00:07.000 --> 01:00:17.000]  Свойство log matching означает, что если в двух логах в каком-то слоте лежит запись с одинаковым термом, то значит, совпадают и префиксы.
[01:00:17.000 --> 01:00:29.000]  Ну вот это свойство, это следствие процедуры выбора лидера. Это свойство, это просто по построению алгоритма оно у нас есть.
[01:00:29.000 --> 01:00:40.000]  Это свойство, это простая индукция, которая следует из правила append entries, что мы отвергаем его, если у нас предыдущая команда не матчится в логе.
[01:00:40.000 --> 01:00:46.000]  И из всего этого мы хотим вывести свойство, которое называется leader completeness.
[01:00:46.000 --> 01:00:58.000]  Звучит так, если запись в логе закоммичена, согласно нашему определению, что она была получена и записана на большинство узлов лидером текущего терма,
[01:00:58.000 --> 01:01:11.000]  то эта запись сохранится в логах всех будущих лидеров, то есть в логах лидеров всех больших термов.
[01:01:11.000 --> 01:01:13.000]  Ну вот давайте этой докажем.
[01:01:41.000 --> 01:02:08.000]  Итак, у нас есть лидер и в его логе, лидер в терме N, он пишет в лог какую-то команду C и реплицирует ее на хвору.
[01:02:08.000 --> 01:02:14.000]  Вот эта команда по нашему определению является зафиксированной в логе.
[01:02:14.000 --> 01:02:18.000]  Это просто определение, оно никого ни к чему не обязывает.
[01:02:18.000 --> 01:02:34.000]  Мы хотим показать, что для любого N' не меньше N, в логе лидера терма N', эта команда по-прежнему должна находиться.
[01:02:34.000 --> 01:02:42.000]  Команда является закоммиченной либо когда ее в текущем терме пишут на большинство, либо когда ее придавливают сверху такой командой.
[01:02:42.000 --> 01:02:51.000]  Но вот второй случай нам не интересен, потому что если придавила, то давайте доказывать теорему про будущую команду, которая придавила.
[01:02:51.000 --> 01:02:58.000]  Так что мы говорим сейчас про команду C, которая была получена в терме K и записана на хвором в терме K.
[01:02:58.000 --> 01:03:02.000]  Мы хотим показать, что она переживет смену лидеров, смену эпох.
[01:03:02.000 --> 01:03:09.000]  Ну а по свойству logmatching и все предшествующие ей команды тоже в логах лидеров новых останутся.
[01:03:09.000 --> 01:03:15.000]  Итак, команда была закоммичена. Что это означает?
[01:03:15.000 --> 01:03:23.000]  Что лидер терма N записал ее на некоторый хвором.
[01:03:23.000 --> 01:03:43.000]  Что означает, что в терме N' был выбран новый лидер?
[01:03:43.000 --> 01:03:47.000]  Ну сейчас я не сказал. Так же, как в паксосе.
[01:03:47.000 --> 01:03:51.000]  Но вообще-то формулировка примерно такая же, как в паксосе, что должна уже наладить на какие-то мысли.
[01:03:51.000 --> 01:03:53.000]  И доказываем мы точно так же по индукции.
[01:03:53.000 --> 01:04:00.000]  Вот база вроде бы очевидна. Мы сейчас смотрим на какое-то N' большее, чем N.
[01:04:00.000 --> 01:04:04.000]  И считаем, что утверждение верно для всех промежуточных N.
[01:04:04.000 --> 01:04:12.000]  То есть для всех N' меньше, чем N' и больше либо равных, чем N в логах лидеров этих термов закоммиченная команда все еще оставалась.
[01:04:12.000 --> 01:04:17.000]  И вот мы смотрим на какой-то новый терм N'.
[01:04:17.000 --> 01:04:22.000]  Команда была закоммичена в терме N, то есть реплицирована на большинство узлов.
[01:04:22.000 --> 01:04:27.000]  А в терме N' был выбран новый лидер какой-то.
[01:04:27.000 --> 01:04:43.000]  Это означает, что за него проголосовал Quorum.
[01:04:43.000 --> 01:04:52.000]  Ну и, как обычно, в пересечении у нас есть какая-то реплика.
[01:04:52.000 --> 01:04:56.000]  Смотрим на нее.
[01:04:56.000 --> 01:05:02.000]  Как-то я размахнулся очень, чем дальше.
[01:05:02.000 --> 01:05:08.000]  Скажи, где мне лучше писать, справа или слева?
[01:05:08.000 --> 01:05:13.000]  Хорошо.
[01:05:13.000 --> 01:05:17.000]  Посмотрим на реплику R.
[01:05:17.000 --> 01:05:19.000]  Вот она жила, жила, жила.
[01:05:19.000 --> 01:05:22.000]  Она получила с одной стороны AppendEntry, с другой стороны RequestVote.
[01:05:22.000 --> 01:05:27.000]  В каком порядке она их получила?
[01:05:27.000 --> 01:05:33.000]  Она получила RequestVote N'.
[01:05:33.000 --> 01:05:39.000]  И он ей понравился.
[01:05:39.000 --> 01:05:41.000]  Но еще жена AppendEntry получала.
[01:05:41.000 --> 01:05:45.000]  Могла ли она получить AppendEntry после RequestVote термы N'?
[01:05:45.000 --> 01:05:52.000]  Не могла, потому что кажется, что тут после этого сообщения
[01:05:52.000 --> 01:05:56.000]  она обязана находиться в терме не меньше, чем N'.
[01:05:56.000 --> 01:06:00.000]  Ну и так же по тем же соображениям, что и в терме ProPaxos.
[01:06:00.000 --> 01:06:02.000]  Мы говорим, что это случилось раньше.
[01:06:15.000 --> 01:06:24.000]  Хорошо.
[01:06:24.000 --> 01:06:27.000]  Как мы дальше рассуждаем?
[01:06:27.000 --> 01:06:36.000]  Посмотрим на лог реплики R в момент получения RequestVote.
[01:06:36.000 --> 01:06:40.000]  Что мы можем сказать про команду, закоммиченную в терме N' в этом логе?
[01:06:40.000 --> 01:06:47.000]  Она жила до этого времени или нет?
[01:06:47.000 --> 01:06:50.000]  Вот смотрите, что мы хотим показать, что когда лидер,
[01:06:50.000 --> 01:06:52.000]  если он собрал RequestVote в терме N',
[01:06:52.000 --> 01:06:54.000]  ну вот новый лидер зеленый,
[01:06:54.000 --> 01:07:00.000]  если он собрал RequestVote, то в его логе обязана быть команда C.
[01:07:00.000 --> 01:07:06.000]  Но вот сейчас я говорю про лог не вот этого зеленого кандидата пока еще,
[01:07:06.000 --> 01:07:09.000]  а говорю про лог реплики R.
[01:07:09.000 --> 01:07:14.000]  Вот здесь в нем оказалась команда C.
[01:07:14.000 --> 01:07:18.000]  Она была закоммичена, записана на целый quorum.
[01:07:18.000 --> 01:07:27.000]  Вот доживет ли в этом логе, в логе этой реплики эта команда до этого момента или нет?
[01:07:27.000 --> 01:07:36.000]  По предположению индукции в лидерах всех промежуточных термов эта команда все еще оставалась.
[01:07:36.000 --> 01:07:45.000]  По свойству лидера Pent Only все промежуточные лидеры никогда не стирали логи, которые у них были.
[01:07:45.000 --> 01:07:52.000]  Конечно же промежуточные лидеры могли стирать лог реплики R, ну какой-то хвостик его.
[01:07:52.000 --> 01:07:59.000]  Но по предположению индукции у них у всех есть в своем логе эта же команда,
[01:07:59.000 --> 01:08:05.000]  а это означает, что стереть они ее не могли ни у кого.
[01:08:05.000 --> 01:08:08.000]  Просто по правилу поведения лидера.
[01:08:08.000 --> 01:08:18.000]  Поэтому в логе реплики R к этому моменту команда, закоммиченная в терме N, обязана все еще оставаться.
[01:08:18.000 --> 01:08:23.000]  Ну а теперь посмотрим на зеленого кандидата.
[01:08:23.000 --> 01:08:27.000]  Вот реплика R за него проголосовала.
[01:08:27.000 --> 01:08:33.000]  Почему она за него проголосовала? Возможно и два варианта.
[01:08:33.000 --> 01:08:51.000]  Может быть, последний терм в логе реплики R был равен последнему терму в логе зеленого кандидата.
[01:08:52.000 --> 01:09:16.000]  И вместе с этим, видимо, длина лога реплики R был не длиннее, чем лог зеленого кандидата.
[01:09:16.000 --> 01:09:21.000]  И второй случай, может быть, реплика проголосовала за кандидата зеленого,
[01:09:21.000 --> 01:09:43.000]  потому что у него last терм был просто больше.
[01:09:43.000 --> 01:09:46.000]  Ну вот давайте про два этих случая подумаем.
[01:09:46.000 --> 01:09:52.000]  Первый случай, последние термы в логах равны.
[01:09:52.000 --> 01:10:04.000]  О чем это говорит? Ну вот у зеленого кандидата и у реплики R к этому моменту.
[01:10:04.000 --> 01:10:08.000]  Ну смотрите, у нас было свойство log-matching.
[01:10:08.000 --> 01:10:14.000]  Что она означала? Что если в одном и том же слоте, ну точнее не так,
[01:10:14.000 --> 01:10:20.000]  про один и тот же слот нельзя говорить.
[01:10:20.000 --> 01:10:28.000]  Тут нужно сказать, что в этом случае просто две реплики R и этот самый зеленый кандидат,
[01:10:28.000 --> 01:10:32.000]  у них логи являются префиксами друг друга.
[01:10:32.000 --> 01:10:35.000]  Один из них является префиксом другого.
[01:10:35.000 --> 01:10:40.000]  И очевидно, что судя по этому неравенству, лог R является префиксом зеленого кандидата.
[01:10:40.000 --> 01:10:46.000]  И при этом в логе R, как мы уже выяснили, есть все еще наша закомиченная команда.
[01:10:46.000 --> 01:10:50.000]  Они являются префиксами друг друга, потому что у них последний общий терм,
[01:10:50.000 --> 01:10:53.000]  видимо, в них писал один и тот же лидер в последнюю очередь.
[01:10:53.000 --> 01:10:56.000]  Значит, у них логи совпадают с какого-то момента.
[01:10:56.000 --> 01:11:00.000]  Ну до какого-то момента, до какой-то записи этого терма.
[01:11:00.000 --> 01:11:04.000]  Лог зеленого кандидата больше, чем лог этой реплики.
[01:11:04.000 --> 01:11:09.000]  Поэтому у зеленого кандидата есть продолжение этого лога,
[01:11:09.000 --> 01:11:13.000]  а в этом логе у реплики R есть закомиченная команда.
[01:11:13.000 --> 01:11:20.000]  Поэтому мы ее сохранили, перенесли в наш терм n-штрих. Все хорошо.
[01:11:20.000 --> 01:11:23.000]  Ну а в этом случае что мы можем сказать?
[01:11:23.000 --> 01:11:33.000]  Тут уже про префиксы сказать нельзя, что один является префиксом другого.
[01:11:33.000 --> 01:11:36.000]  Термы разные, непонятно, что это означает.
[01:11:36.000 --> 01:11:42.000]  Ну вот посмотрим на лидера, который записал в лог зеленого кандидата
[01:11:42.000 --> 01:11:45.000]  последнюю запись.
[01:11:45.000 --> 01:11:50.000]  Вот этот last term c, он же меньше, чем n-штрих, да?
[01:11:50.000 --> 01:11:58.000]  Вот, а эта штука last term r, он же не меньше, чем n.
[01:11:58.000 --> 01:12:02.000]  Ну потому что у реплики R все еще есть закомиченная команда.
[01:12:02.000 --> 01:12:09.000]  Ну это означает, что лидер, который записал в зеленого кандидата
[01:12:09.000 --> 01:12:14.000]  последнюю запись, находился вот в этом диапазоне,
[01:12:14.000 --> 01:12:16.000]  значит, у него действует предположение индукции,
[01:12:16.000 --> 01:12:21.000]  значит, у него запись из терма n, закомиченная наша, была.
[01:12:21.000 --> 01:12:24.000]  И он еще что-то сверху записал туда.
[01:12:24.000 --> 01:12:29.000]  Ну значит, она все еще есть из зеленого кандидата.
[01:12:29.000 --> 01:12:32.000]  Ну вот и все, случаи закончились.
[01:12:32.000 --> 01:12:42.000]  Предположение индукции, самоутверждение предположения индукции,
[01:12:42.000 --> 01:12:46.000]  оно говорит о том, что у промежуточных лидеров,
[01:12:46.000 --> 01:12:50.000]  утверждение говорит о том, что у лидера в терме n-штрих,
[01:12:50.000 --> 01:12:53.000]  в логе обязательно будет закомиченная команда.
[01:12:53.000 --> 01:12:56.000]  Но поскольку лидеры не стирают никогда свои логи,
[01:12:56.000 --> 01:12:59.000]  они замечают, что эта команда будет переживать сменную эпоху.
[01:13:06.000 --> 01:13:08.000]  Все, получилось.
[01:13:08.000 --> 01:13:11.000]  Ну вообще утверждение, оно доказывается ровно так же, как в мульте,
[01:13:11.000 --> 01:13:13.000]  как в сингл декрип аксессии.
[01:13:13.000 --> 01:13:17.000]  Я бы сказал, что это то же самое утверждение.
[01:13:17.000 --> 01:13:20.000]  Ну то есть там мы точно так же говорили, что если у нас значение выбранное,
[01:13:20.000 --> 01:13:22.000]  то оно прошло через вторую фазу.
[01:13:22.000 --> 01:13:26.000]  Если значение кто-то предлагает с новым n-штрих,
[01:13:26.000 --> 01:13:29.000]  то он прошел через первую фазу по аксессу.
[01:13:29.000 --> 01:13:31.000]  Они пересекаются, в пересечении есть acceptor.
[01:13:31.000 --> 01:13:36.000]  Этот acceptor получил сначала сообщение с более ранней мэн,
[01:13:36.000 --> 01:13:38.000]  потом с более поздней мэн,
[01:13:38.000 --> 01:13:42.000]  потому что иначе был отверг первое сообщение.
[01:13:42.000 --> 01:13:45.000]  Ну и дальше там точно такие же суждения про этот отрезок
[01:13:45.000 --> 01:13:49.000]  и про то, что здесь мы получим...
[01:13:49.000 --> 01:13:54.000]  Ну в случае аксесса мы через prepare получим нужное значение с большим n-а,
[01:13:54.000 --> 01:13:57.000]  а в случае RAF-та мы это все переносим на лог и говорим,
[01:13:57.000 --> 01:14:00.000]  что в логе этого кандидата будет нужная команда.
[01:14:00.000 --> 01:14:04.000]  Но смысл-то одинаковый.
[01:14:04.000 --> 01:14:06.000]  Это одна и та же теория, потому что...
[01:14:06.000 --> 01:14:09.000]  Поэтому когда вам авторы говорят, что RAF проще паксуса,
[01:14:09.000 --> 01:14:11.000]  ну я бы сомневался, что это так,
[01:14:11.000 --> 01:14:14.000]  потому что мне кажется, что судя по теориям, это одно и то же абсолютно.
[01:14:14.000 --> 01:14:16.000]  Разве что немного другие обозначения,
[01:14:16.000 --> 01:14:19.000]  но просто потому что мы говорим теперь не про отдельный слот,
[01:14:19.000 --> 01:14:22.000]  а про целый лог, и вот он чуть сложнее устроен.
[01:14:22.000 --> 01:14:28.000]  Ну так или иначе, мы получаем то, что называется leader completeness,
[01:14:28.000 --> 01:14:32.000]  а это дает нам то, что называется street machine-safe.
[01:14:32.000 --> 01:14:36.000]  То есть если каждая реплика применяет только за камечные команды...
[01:14:36.000 --> 01:14:38.000]  Что?
[01:14:38.000 --> 01:14:41.000]  Да, спасибо.
[01:14:41.000 --> 01:14:44.000]  И нужно, наверное, вернуть...
[01:14:45.000 --> 01:14:48.000]  Ну нет, плохо видно.
[01:15:08.000 --> 01:15:11.000]  Ну вот, мы доказали leader completeness,
[01:15:11.000 --> 01:15:15.000]  а с него следует последнее свойство,
[01:15:17.000 --> 01:15:20.000]  про то, что мы коллектно реплицируем наш автомат.
[01:15:24.000 --> 01:15:26.000]  Небольшой вопрос на понимание,
[01:15:26.000 --> 01:15:33.000]  а где рассуждения теоремы ломаются вот в этом примере?
[01:15:35.000 --> 01:15:39.000]  Ну просто вроде бы мы доказали, что если команда написана...
[01:15:39.000 --> 01:15:42.000]  Короче, как этот пример не сходится с теоремой?
[01:15:42.000 --> 01:15:44.000]  Всегда же полезно это понимать, да?
[01:15:55.000 --> 01:15:58.000]  Это тут не очень очевидно, но смотрите, у нас теорема говорит,
[01:15:58.000 --> 01:16:01.000]  что если команда закоммичена в терме N,
[01:16:01.000 --> 01:16:04.000]  то она будет в логах всех последующих лидеров.
[01:16:05.000 --> 01:16:10.000]  А здесь у нас, смотрите, у нас команда из термы 2 закоммичена в терме 4.
[01:16:10.000 --> 01:16:13.000]  В итоге у нас эта N раздваивается на 2N.
[01:16:13.000 --> 01:16:16.000]  У нас есть N равное 2, N равное 4.
[01:16:16.000 --> 01:16:19.000]  И вот непонятно, про что теорема говорит.
[01:16:19.000 --> 01:16:22.000]  Вот теорема говорит про терм номер 4.
[01:16:22.000 --> 01:16:25.000]  Вот если здесь команда получена в терме 4 и записана на большинство,
[01:16:25.000 --> 01:16:28.000]  то она здесь надежно закоммичена.
[01:16:28.000 --> 01:16:31.000]  А что происходит на этой картинке?
[01:16:31.000 --> 01:16:34.000]  Смотрите, у нас как будто бы команда из термы 2 закоммичена,
[01:16:34.000 --> 01:16:36.000]  как будто бы N равно 2.
[01:16:36.000 --> 01:16:41.000]  А вот для N' равного 3 почему-то у лидера нет этой команды.
[01:16:41.000 --> 01:16:43.000]  В чем же обман?
[01:16:43.000 --> 01:16:47.000]  А в том, что, смотрите, мы говорим, пересечение кворумов.
[01:16:47.000 --> 01:16:51.000]  Вот действительно, кворум, на котором была реплицирована команда 2,
[01:16:51.000 --> 01:16:54.000]  пересекается с кворумом, который выбрал реплику 3.
[01:16:56.000 --> 01:16:58.000]  Но что не так?
[01:16:58.000 --> 01:17:02.000]  А не так то, что у нас больше не работает рассуждение о том,
[01:17:02.000 --> 01:17:05.000]  что append-entries был получен до request-vote.
[01:17:05.000 --> 01:17:10.000]  Вот здесь append-entries был получен после request-vote.
[01:17:10.000 --> 01:17:16.000]  Потому что append-entries терм 4, а у request-vote терм 3.
[01:17:16.000 --> 01:17:18.000]  Потому что здесь N не 4, а 2.
[01:17:18.000 --> 01:17:21.000]  Ну, короче, если вы следите, то понимаете, что произошло.
[01:17:21.000 --> 01:17:24.000]  Тут N разошлось.
[01:17:24.000 --> 01:17:27.000]  В этом примере команда вроде бы из термы 2 закомичена,
[01:17:27.000 --> 01:17:29.000]  но закомичена в терме 4.
[01:17:29.000 --> 01:17:32.000]  Вот чтобы такого не было, терема говорит про один и тот же терм,
[01:17:32.000 --> 01:17:34.000]  и тогда уже там все четко получается.
[01:17:34.000 --> 01:17:37.000]  То есть вот здесь вот команда из термы 4 закомичена в терме 4,
[01:17:37.000 --> 01:17:39.000]  и все хорошо с ней.
[01:17:44.000 --> 01:17:46.000]  Ну что?
[01:17:46.000 --> 01:17:50.000]  Мы убедились, что RAFT обеспечивает safety.
[01:17:51.000 --> 01:17:53.000]  Да?
[01:17:53.000 --> 01:17:57.000]  Обеспечивает ли RAFT LiveNas?
[01:17:57.000 --> 01:18:02.000]  Разумно. Мы говорили, кажется, про алгоритм консенсуса,
[01:18:02.000 --> 01:18:04.000]  доказывали какие-то теоремы,
[01:18:04.000 --> 01:18:07.000]  и выяснили, что safety мы должны обеспечивать всегда,
[01:18:07.000 --> 01:18:10.000]  даже в синхронной модели, даже с произвольным числом отказов.
[01:18:10.000 --> 01:18:13.000]  И RAFT с этим справляется.
[01:18:13.000 --> 01:18:17.000]  А LiveNas мы гарантировать не можем, потому что есть FTP-теорема.
[01:18:17.000 --> 01:18:20.000]  И мы должны что-то делать, чтобы все-таки прогресс был.
[01:18:20.000 --> 01:18:22.000]  Ну что мы делаем?
[01:18:22.000 --> 01:18:26.000]  В RAFT для LiveNas мы это делали в самом начале нашего рассказа.
[01:18:26.000 --> 01:18:30.000]  Мы рандомизируем тайм-ауты.
[01:18:30.000 --> 01:18:33.000]  Достаточно ли этого для LiveNas?
[01:18:42.000 --> 01:18:46.000]  Это не очень страшно, потому что если у реплики,
[01:18:46.000 --> 01:18:49.000]  у которой короткий лог будет самый маленький тайм-аут,
[01:18:49.000 --> 01:18:52.000]  ну просто за нее не проголосуют.
[01:18:52.000 --> 01:18:55.000]  То есть если вдруг ты реплика, у которой нулевой лог,
[01:18:55.000 --> 01:18:57.000]  и ты стал первым кандидатом почему-то,
[01:18:57.000 --> 01:19:00.000]  то слушать тебя просто никто не станет.
[01:19:00.000 --> 01:19:04.000]  И другие реплики не израсходуют свой голос в терме.
[01:19:04.000 --> 01:19:06.000]  Поэтому это само по себе не страшно.
[01:19:06.000 --> 01:19:09.000]  Но у RAFT есть одна неприятная особенность.
[01:19:09.000 --> 01:19:15.000]  В нем выбор лидера, они дизраптив, они ломают терм.
[01:19:15.000 --> 01:19:19.000]  Вот представьте, что у вас есть, ну не знаю, 5 реплик,
[01:19:19.000 --> 01:19:22.000]  и возникает partition.
[01:19:22.000 --> 01:19:26.000]  Вот в большей части partition где, допустим, осталось 3 реплики,
[01:19:26.000 --> 01:19:28.000]  ну есть хвором, его можно собрать,
[01:19:28.000 --> 01:19:32.000]  значит эти 3 реплики выбирают лидера и живут дальше.
[01:19:32.000 --> 01:19:34.000]  Там, не знаю, наступает у них там пятый терм,
[01:19:34.000 --> 01:19:36.000]  в пятом терме выбирается лидер,
[01:19:36.000 --> 01:19:38.000]  и он дальше спокойно реплицирует команду, обслуживает клиент.
[01:19:38.000 --> 01:19:41.000]  А что происходит в меньшей части partition?
[01:19:41.000 --> 01:19:43.000]  Ну это не правда, что ничего не происходит,
[01:19:43.000 --> 01:19:45.000]  что происходит все же.
[01:19:45.000 --> 01:19:48.000]  Там каждая реплика заводит себе таймер, reaction timer,
[01:19:48.000 --> 01:19:51.000]  и ждет хардбитов от лидера.
[01:19:51.000 --> 01:19:55.000]  Не дождется, потому что лидер в другой половине выбран partition,
[01:19:55.000 --> 01:19:59.000]  а в этой половине лидер выбран не может, потому что их слишком мало.
[01:19:59.000 --> 01:20:03.000]  В итоге рано или поздно таймер протухает,
[01:20:03.000 --> 01:20:06.000]  и эта реплика уничивает себе терм.
[01:20:06.000 --> 01:20:09.000]  Заводит таймер заново, посылает request vote,
[01:20:09.000 --> 01:20:12.000]  и снова ждет, и снова ничего не происходит.
[01:20:12.000 --> 01:20:14.000]  Таймер снова истекает,
[01:20:14.000 --> 01:20:16.000]  мы снова увеличиваем терм,
[01:20:16.000 --> 01:20:18.000]  и снова заводим таймер, посылаем request vote,
[01:20:18.000 --> 01:20:20.000]  и снова заводим таймер.
[01:20:36.000 --> 01:20:38.000]  У него есть reaction timeout, еще раз,
[01:20:38.000 --> 01:20:41.000]  ты когда становишься кандидатом, смотри вот здесь,
[01:20:41.000 --> 01:20:43.000]  ты посылаешь свой request vote и ждешь,
[01:20:43.000 --> 01:20:45.000]  что либо у тебя соберется quorum,
[01:20:45.000 --> 01:20:47.000]  либо ты получишь append entry с нового лидера,
[01:20:47.000 --> 01:20:49.000]  потому что ты проиграл,
[01:20:49.000 --> 01:20:52.000]  либо таймер протухнет, потому что эпоха провалена,
[01:20:52.000 --> 01:20:55.000]  терм провален, split vote получился.
[01:20:55.000 --> 01:20:59.000]  И здесь всегда будет таймер,
[01:20:59.000 --> 01:21:01.000]  потому что ты и quorum собрать не можешь,
[01:21:01.000 --> 01:21:03.000]  и никто другой не может собрать quorum.
[01:21:06.000 --> 01:21:09.000]  Ну и к чему это приведет, когда partition вылечится?
[01:21:09.000 --> 01:21:11.000]  Смотрите, в большей части partition все стабильно,
[01:21:11.000 --> 01:21:13.000]  там эпоха, там терм 5,
[01:21:13.000 --> 01:21:15.000]  там лидер живет спокойно себе,
[01:21:15.000 --> 01:21:20.000]  а в другой половине реплики себе растят этот quorum-терм,
[01:21:20.000 --> 01:21:22.000]  partition исчезает,
[01:21:22.000 --> 01:21:24.000]  и наконец их request vote и приходит.
[01:21:24.000 --> 01:21:27.000]  И вот там терм 5, а там терм 100-500 уже,
[01:21:27.000 --> 01:21:29.000]  потому что их долго не было.
[01:21:29.000 --> 01:21:31.000]  И вроде бы ничего полезного не происходит,
[01:21:31.000 --> 01:21:33.000]  в смысле все хорошо и так,
[01:21:33.000 --> 01:21:35.000]  но они приходят со своим большим термом,
[01:21:35.000 --> 01:21:41.000]  и те реплики, которые жили себя в большей части partition,
[01:21:41.000 --> 01:21:43.000]  переходят за ними в этот терм,
[01:21:43.000 --> 01:21:45.000]  и происходит процедура выбора лидера.
[01:21:45.000 --> 01:21:47.000]  То есть терм сбивается,
[01:21:47.000 --> 01:21:49.000]  проходит фаза выбора лидера,
[01:21:49.000 --> 01:21:51.000]  и в конце концов все сходится,
[01:21:51.000 --> 01:21:55.000]  но тем не менее алгоритм немножко прервался,
[01:21:55.000 --> 01:21:57.000]  прервал ход своей работы нормальный.
[01:21:59.000 --> 01:22:01.000]  Но это само по себе не страшно,
[01:22:01.000 --> 01:22:03.000]  это просто неприятно.
[01:22:03.000 --> 01:22:05.000]  Страшно становится тогда,
[01:22:05.000 --> 01:22:07.000]  когда у вас возникают сбои в сети.
[01:22:11.000 --> 01:22:13.000]  Смотрите, есть такая компания Cloudflare.
[01:22:13.000 --> 01:22:15.000]  Слышали про нее?
[01:22:15.000 --> 01:22:17.000]  Вот.
[01:22:17.000 --> 01:22:19.000]  Вот у них, кажется, был шестичасовой downtime
[01:22:19.000 --> 01:22:21.000]  из-за рафта.
[01:22:21.000 --> 01:22:23.000]  И он был, смотрите, по каким причинам.
[01:22:23.000 --> 01:22:25.000]  Он был потому, что они называются византийским сбоем,
[01:22:25.000 --> 01:22:27.000]  это не византийский сбой.
[01:22:27.000 --> 01:22:29.000]  Им в твиттере это доступно написали много раз,
[01:22:29.000 --> 01:22:31.000]  когда они опубликовали эту статью,
[01:22:31.000 --> 01:22:33.000]  не разбирайтесь.
[01:22:33.000 --> 01:22:35.000]  Они сделали об этом занятку вместо того,
[01:22:35.000 --> 01:22:37.000]  чтобы статью исправить.
[01:22:37.000 --> 01:22:39.000]  Смотрите, что может произойти.
[01:22:39.000 --> 01:22:41.000]  Вот представьте,
[01:22:41.000 --> 01:22:43.000]  что у вас пять узлов,
[01:22:43.000 --> 01:22:45.000]  и по задумке алгоритмы консенсуса
[01:22:45.000 --> 01:22:47.000]  эти пять узлов должны уметь друг с другом взаимодействовать.
[01:22:47.000 --> 01:22:49.000]  Но так получилось,
[01:22:49.000 --> 01:22:51.000]  что у вас поломалась какая-то сетевая коробка,
[01:22:51.000 --> 01:22:53.000]  и теперь не все пары узлов
[01:22:53.000 --> 01:22:55.000]  могут напрямую друг с другом общаться.
[01:22:55.000 --> 01:22:57.000]  Вот скажем, второй с пятым не может общаться.
[01:23:01.000 --> 01:23:03.000]  Как это влияет на рафт?
[01:23:03.000 --> 01:23:05.000]  На лайвность рафта?
[01:23:05.000 --> 01:23:07.000]  Ну вот, с одной стороны,
[01:23:07.000 --> 01:23:09.000]  вот у вас здесь есть три реплики,
[01:23:09.000 --> 01:23:11.000]  и они бы могли
[01:23:11.000 --> 01:23:13.000]  сформировать кворум, выбрать лидера и дальше работать.
[01:23:15.000 --> 01:23:17.000]  Ну вот, давайте выберем соединительных лидеров.
[01:23:17.000 --> 01:23:19.000]  Кто это будет? Один, два или три?
[01:23:21.000 --> 01:23:23.000]  Один.
[01:23:23.000 --> 01:23:25.000]  Выбрал самый неинтересный вариант.
[01:23:25.000 --> 01:23:27.000]  Ну хорошо, пусть будет один.
[01:23:27.000 --> 01:23:29.000]  Вот он может общаться только с
[01:23:29.000 --> 01:23:31.000]  два и три, но они собирают вместе кворум.
[01:23:31.000 --> 01:23:33.000]  Он становится лидером.
[01:23:33.000 --> 01:23:35.000]  Он начинает сломать им хардбиты.
[01:23:35.000 --> 01:23:37.000]  При этом ни четыре, ни пять их не получают,
[01:23:37.000 --> 01:23:39.000]  потому что прямой провод сломался.
[01:23:39.000 --> 01:23:41.000]  То есть маршруты, пакеты
[01:23:41.000 --> 01:23:43.000]  не достигают
[01:23:43.000 --> 01:23:45.000]  ни четыре, ни пять
[01:23:45.000 --> 01:23:47.000]  отправленные соединительные.
[01:23:47.000 --> 01:23:49.000]  Что происходит с четыре и пять тогда?
[01:23:49.000 --> 01:23:51.000]  На них протухает эрекшн тайм аут.
[01:23:51.000 --> 01:23:53.000]  Они становятся кандидатами,
[01:23:53.000 --> 01:23:55.000]  посылают свой реквест в отэ,
[01:23:55.000 --> 01:23:57.000]  и вот здесь
[01:23:57.000 --> 01:23:59.000]  кажется стабильность нарушается.
[01:23:59.000 --> 01:24:01.000]  И начинаются новые выборы.
[01:24:01.000 --> 01:24:03.000]  Кто выбирается дальше?
[01:24:05.000 --> 01:24:07.000]  Два выбирается.
[01:24:07.000 --> 01:24:09.000]  Он становится лидером,
[01:24:09.000 --> 01:24:11.000]  но тут у него получше дела.
[01:24:11.000 --> 01:24:13.000]  То есть он может посылать хардбиты и один, и три, и четыре.
[01:24:13.000 --> 01:24:15.000]  Но пять все равно не может.
[01:24:15.000 --> 01:24:17.000]  И в итоге теперь пять будет недоволен.
[01:24:17.000 --> 01:24:19.000]  То есть кто бы не был выбран,
[01:24:19.000 --> 01:24:21.000]  один, два или три будут недовольны
[01:24:21.000 --> 01:24:23.000]  либо оба, либо
[01:24:23.000 --> 01:24:25.000]  четыре, либо пять.
[01:24:25.000 --> 01:24:27.000]  Но кто-то из них обязательно будет.
[01:24:27.000 --> 01:24:29.000]  И вот он будет у себя растить терм
[01:24:29.000 --> 01:24:31.000]  и сбивать всех остальных.
[01:24:31.000 --> 01:24:33.000]  И лидер будет постоянно сбиваться.
[01:24:33.000 --> 01:24:35.000]  И рафт не сможет перейти в стабильное состояние.
[01:24:35.000 --> 01:24:37.000]  Нужно ему для работы.
[01:24:39.000 --> 01:24:41.000]  Неприятная ситуация, но вот так можно продакшн положить.
[01:24:43.000 --> 01:24:45.000]  Поэтому одного лишь
[01:24:45.000 --> 01:24:47.000]  протокола, описанного
[01:24:47.000 --> 01:24:49.000]  в статье, оказывается недостаточно.
[01:24:51.000 --> 01:24:53.000]  Вот этого мало.
[01:24:53.000 --> 01:24:55.000]  То есть этого достаточно, если у вас
[01:24:55.000 --> 01:24:57.000]  не бывают таких сбоев в сети.
[01:24:57.000 --> 01:24:59.000]  Как вы это гарантируете?
[01:24:59.000 --> 01:25:01.000]  Поэтому
[01:25:01.000 --> 01:25:03.000]  нужно чинить.
[01:25:03.000 --> 01:25:05.000]  Предлагается добавить рафт...
[01:25:05.000 --> 01:25:07.000]  В чем беда?
[01:25:07.000 --> 01:25:09.000]  В том, что
[01:25:09.000 --> 01:25:11.000]  реплика четыре или реплика пять
[01:25:11.000 --> 01:25:13.000]  становятся кандидатами и сбивают
[01:25:13.000 --> 01:25:15.000]  нормальный кворум.
[01:25:15.000 --> 01:25:17.000]  Но с другой стороны,
[01:25:17.000 --> 01:25:19.000]  на этой картинке же ни у четыре, ни у пять
[01:25:19.000 --> 01:25:21.000]  нет шансов никаких.
[01:25:21.000 --> 01:25:23.000]  Потому что они не могут кворум собрать, в принципе.
[01:25:23.000 --> 01:25:25.000]  Так что давайте,
[01:25:25.000 --> 01:25:27.000]  перед тем, как они будут становиться кандидатами
[01:25:27.000 --> 01:25:29.000]  и собирать много кворума, и посылать request-vote,
[01:25:29.000 --> 01:25:31.000]  избивать остальных, они попробуют узнать,
[01:25:31.000 --> 01:25:33.000]  а вообще способны ли они стать лидерами.
[01:25:33.000 --> 01:25:35.000]  То есть они
[01:25:35.000 --> 01:25:37.000]  запустят фазу pre-vote,
[01:25:37.000 --> 01:25:39.000]  в которой...
[01:25:39.000 --> 01:25:41.000]  Это такая фаза request-vote, просто виртуальная.
[01:25:41.000 --> 01:25:43.000]  Они пробуют,
[01:25:43.000 --> 01:25:45.000]  говорят, а что, если я отправлю тебе
[01:25:45.000 --> 01:25:47.000]  request-vote? Как ты мне ответишь?
[01:25:47.000 --> 01:25:49.000]  Вот. И если...
[01:25:49.000 --> 01:25:51.000]  Что делает реплика два?
[01:25:51.000 --> 01:25:53.000]  Она отвечает на этот pre-vote
[01:25:53.000 --> 01:25:55.000]  положительно,
[01:25:55.000 --> 01:25:57.000]  если лог реплики четыре
[01:25:57.000 --> 01:25:59.000]  ее устраивает,
[01:25:59.000 --> 01:26:01.000]  и если она сама
[01:26:01.000 --> 01:26:03.000]  не получает хардбиты от лидера.
[01:26:03.000 --> 01:26:05.000]  А если она получает хардбиты от лидера,
[01:26:05.000 --> 01:26:07.000]  то, видимо, она всем довольна, и ну зачем
[01:26:07.000 --> 01:26:09.000]  реагировать на эти request-vote?
[01:26:09.000 --> 01:26:11.000]  Ну вот такой
[01:26:11.000 --> 01:26:13.000]  изящный костыль.
[01:26:13.000 --> 01:26:15.000]  Ну, как у любого костыля,
[01:26:15.000 --> 01:26:17.000]  есть здесь нюансы некоторые.
[01:26:17.000 --> 01:26:19.000]  Оказывается, что
[01:26:19.000 --> 01:26:21.000]  это чинит лайв на таком сценарии,
[01:26:21.000 --> 01:26:23.000]  но ломает в таком сценарии.
[01:26:23.000 --> 01:26:25.000]  Вот мы оторвали еще один провод.
[01:26:25.000 --> 01:26:27.000]  Лидером у нас
[01:26:27.000 --> 01:26:29.000]  была реплика четыре,
[01:26:29.000 --> 01:26:31.000]  когда провода порвались.
[01:26:31.000 --> 01:26:33.000]  Она шлют хардбиты два.
[01:26:33.000 --> 01:26:35.000]  Вот этих двух все устраивает.
[01:26:35.000 --> 01:26:37.000]  И если она не получает хардбиты,
[01:26:37.000 --> 01:26:39.000]  вот этих двух все устраивает.
[01:26:41.000 --> 01:26:43.000]  Вот, 1 на 3 не получает хардбиты.
[01:26:43.000 --> 01:26:45.000]  Ну, 5 там не важно, она никому не навредит уже.
[01:26:45.000 --> 01:26:47.000]  1 на 3 недовольны,
[01:26:47.000 --> 01:26:49.000]  они хардбитов не получают.
[01:26:49.000 --> 01:26:51.000]  Они становятся кандидатами.
[01:26:51.000 --> 01:26:53.000]  Они могли бы собрать
[01:26:53.000 --> 01:26:55.000]  хорум.
[01:26:55.000 --> 01:26:57.000]  Но как бы связи достаточно.
[01:26:57.000 --> 01:26:59.000]  Но при этом
[01:26:59.000 --> 01:27:01.000]  2-то все устраивает,
[01:27:01.000 --> 01:27:03.000]  потому что от лидера она получает голоса.
[01:27:03.000 --> 01:27:05.000]  В итоге 4 лидер,
[01:27:05.000 --> 01:27:07.000]  он реплицирует свой голос на 2,
[01:27:07.000 --> 01:27:09.000]  хорум не собирает при этом.
[01:27:09.000 --> 01:27:11.000]  То есть команда не коммитит.
[01:27:11.000 --> 01:27:13.000]  А 1 на 3 не могут пройти через преволут,
[01:27:13.000 --> 01:27:15.000]  потому что 2 все устраивает.
[01:27:15.000 --> 01:27:17.000]  Поэтому
[01:27:17.000 --> 01:27:19.000]  нужен второй костырь, а именно
[01:27:19.000 --> 01:27:21.000]  проверка чек хорум,
[01:27:21.000 --> 01:27:23.000]  которая на лидеры проверяет,
[01:27:23.000 --> 01:27:25.000]  что вообще-то он сам собирает хорум.
[01:27:25.000 --> 01:27:27.000]  То есть он не бесполезен сейчас.
[01:27:29.000 --> 01:27:31.000]  Что?
[01:27:31.000 --> 01:27:33.000]  Вот из костырей, да.
[01:27:33.000 --> 01:27:35.000]  Хорошее замечание.
[01:27:35.000 --> 01:27:37.000]  Ну вот, это две эвристики, которые нужно в продакшене использовать.
[01:27:45.000 --> 01:27:47.000]  Нет, а если
[01:27:47.000 --> 01:27:49.000]  всех соединить в цепочку, то ничего хорошего случиться
[01:27:49.000 --> 01:27:51.000]  не может.
[01:27:55.000 --> 01:27:57.000]  В этот случай он довольно странный.
[01:27:57.000 --> 01:27:59.000]  Вероятность его невелика.
[01:27:59.000 --> 01:28:01.000]  Но ты видишь, что люди 6 часов не работали.
[01:28:03.000 --> 01:28:05.000]  С одной стороны, да,
[01:28:05.000 --> 01:28:07.000]  а с другой стороны люди пострадали.
[01:28:07.000 --> 01:28:09.000]  Поэтому ты можешь в это не верить,
[01:28:09.000 --> 01:28:11.000]  а можешь сделать
[01:28:11.000 --> 01:28:13.000]  две эти эвристики у себя.
[01:28:13.000 --> 01:28:15.000]  И, конечно, все хорошие реализации рафта
[01:28:15.000 --> 01:28:17.000]  эти эвристики используют, иначе...
[01:28:19.000 --> 01:28:21.000]  Что?
[01:28:21.000 --> 01:28:23.000]  Можно придумывать
[01:28:23.000 --> 01:28:25.000]  много разных эвристик,
[01:28:25.000 --> 01:28:27.000]  а можно остановиться.
[01:28:29.000 --> 01:28:31.000]  Я, кстати, не видел строгих
[01:28:31.000 --> 01:28:33.000]  рассуждений, что этого прямо достаточно,
[01:28:33.000 --> 01:28:35.000]  и что там ничего другого случиться не может.
[01:28:35.000 --> 01:28:37.000]  Но кажется, что сейчас
[01:28:37.000 --> 01:28:39.000]  промышленная реализация
[01:28:39.000 --> 01:28:41.000]  работает вот так.
[01:28:41.000 --> 01:28:43.000]  Но без привода, конечно, никто не работает,
[01:28:43.000 --> 01:28:45.000]  потому что у рафта есть такой дурацкий сценарий,
[01:28:45.000 --> 01:28:47.000]  что реплика,
[01:28:47.000 --> 01:28:49.000]  которая долго где-то
[01:28:49.000 --> 01:28:51.000]  была в маленькой части партишена,
[01:28:51.000 --> 01:28:53.000]  она прерывает
[01:28:53.000 --> 01:28:55.000]  нормальный ход рафта.
[01:28:57.000 --> 01:28:59.000]  Итак, значит,
[01:28:59.000 --> 01:29:01.000]  сейфти у нас есть,
[01:29:01.000 --> 01:29:03.000]  лайвнес у нас, кажется, есть
[01:29:03.000 --> 01:29:05.000]  с этими всеми приключениями.
[01:29:05.000 --> 01:29:07.000]  Последнее, что я скажу про рафт.
[01:29:07.000 --> 01:29:09.000]  Про то, что алгоритм проще.
[01:29:09.000 --> 01:29:11.000]  Автор говорит, что он проще и понятнее.
[01:29:13.000 --> 01:29:15.000]  Что вы думаете по этому поводу?
[01:29:19.000 --> 01:29:21.000]  Какая-то красивая картина.
[01:29:21.000 --> 01:29:23.000]  Сейчас я...
[01:29:37.000 --> 01:29:39.000]  Сейчас я найду что-то забавное.
[01:29:41.000 --> 01:29:43.000]  Покажу вам.
[01:29:43.000 --> 01:29:45.000]  Ну, во-первых,
[01:29:45.000 --> 01:29:47.000]  авторы рафта,
[01:29:47.000 --> 01:29:49.000]  они разумные вещи говорят.
[01:29:49.000 --> 01:29:51.000]  Действительно, у них протокол описан,
[01:29:51.000 --> 01:29:53.000]  есть референсная реализация,
[01:29:53.000 --> 01:29:55.000]  есть какие-то промышленные реализации.
[01:29:55.000 --> 01:29:57.000]  Промышленные реализации появились
[01:29:57.000 --> 01:29:59.000]  после, потому что была референсная реализация,
[01:29:59.000 --> 01:30:01.000]  потому что была статья,
[01:30:01.000 --> 01:30:03.000]  то есть всех все устраивает, это удобно.
[01:30:03.000 --> 01:30:05.000]  В этом смысле, конечно,
[01:30:05.000 --> 01:30:07.000]  рафт удобнее писать.
[01:30:07.000 --> 01:30:09.000]  Рафт проще написать, но не потому,
[01:30:09.000 --> 01:30:11.000]  что алгоритм проще, а потому, что
[01:30:11.000 --> 01:30:13.000]  больше деталей описано.
[01:30:15.000 --> 01:30:17.000]  Ну, авторы рафта, они не поленились,
[01:30:17.000 --> 01:30:19.000]  они даже...
[01:30:19.000 --> 01:30:21.000]  Они сделали две лекции про мультипаксис
[01:30:21.000 --> 01:30:23.000]  и про рафт,
[01:30:23.000 --> 01:30:25.000]  заставляли их студентов проходить в произвольном порядке,
[01:30:25.000 --> 01:30:27.000]  чтобы...
[01:30:27.000 --> 01:30:29.000]  Ну, короче, у них есть прямо в PhD
[01:30:29.000 --> 01:30:31.000]  глава,
[01:30:31.000 --> 01:30:33.000]  который называется
[01:30:35.000 --> 01:30:37.000]  Рафт Езерстадия,
[01:30:37.000 --> 01:30:39.000]  где они прямо на студентах испытывают,
[01:30:39.000 --> 01:30:41.000]  что рафт на самом деле проще.
[01:30:41.000 --> 01:30:43.000]  Ну, и получают, конечно, правильные результаты,
[01:30:43.000 --> 01:30:45.000]  что рафт проще.
[01:30:45.000 --> 01:30:47.000]  Мое мнение, что это одно и то же просто,
[01:30:47.000 --> 01:30:49.000]  ну, то есть теорема о
[01:30:49.000 --> 01:30:51.000]  рафта, те же самые частные случаи,
[01:30:51.000 --> 01:30:53.000]  такое же утверждение про корректность,
[01:30:53.000 --> 01:30:55.000]  ну, в самом деле, смотрите, утверждение про корректность
[01:30:55.000 --> 01:30:57.000]  рафта, а теперь вспомните, что было
[01:30:57.000 --> 01:30:59.000]  в паксосе. Значит, если
[01:30:59.000 --> 01:31:01.000]  пара N, V выбрана chosen
[01:31:01.000 --> 01:31:03.000]  в смысле консенсуса, то для любого
[01:31:03.000 --> 01:31:05.000]  bellot number N3 не меньше,
[01:31:05.000 --> 01:31:07.000]  чем N, ничего другого
[01:31:07.000 --> 01:31:09.000]  может быть, не может. Вот
[01:31:09.000 --> 01:31:11.000]  переложим это утверждение на
[01:31:11.000 --> 01:31:13.000]  multipaxis. Там у нас была N это эпоха,
[01:31:13.000 --> 01:31:15.000]  а аксепт
[01:31:15.000 --> 01:31:17.000]  делал только лидер.
[01:31:17.000 --> 01:31:19.000]  И вот утверждение звучит так, если
[01:31:19.000 --> 01:31:21.000]  лидер
[01:31:21.000 --> 01:31:23.000]  с эпохой N
[01:31:23.000 --> 01:31:25.000]  зафиксировал команду в логе,
[01:31:25.000 --> 01:31:27.000]  то все аксепты
[01:31:27.000 --> 01:31:29.000]  лидеров из больших эпох
[01:31:29.000 --> 01:31:31.000]  не могут
[01:31:31.000 --> 01:31:33.000]  эту команду стереть.
[01:31:33.000 --> 01:31:35.000]  Вот то же самое утверждение,
[01:31:35.000 --> 01:31:37.000]  что оказывается точно так же.
[01:31:41.000 --> 01:31:43.000]  Ну, как бы, те же самые N
[01:31:43.000 --> 01:31:45.000]  с тем же самым смыслом, чтобы ограничивать
[01:31:45.000 --> 01:31:47.000]  старых лидеров и переходить в новую эпоху.
[01:31:47.000 --> 01:31:49.000]  Этот N также хранится
[01:31:49.000 --> 01:31:51.000]  на диске. Ну, короче, тут
[01:31:51.000 --> 01:31:53.000]  буквально все то же самое,
[01:31:53.000 --> 01:31:55.000]  разве что все подогдано и все понятно,
[01:31:55.000 --> 01:31:57.000]  все детали описаны.
[01:31:57.000 --> 01:31:59.000]  А алгоритм, мне кажется, точно такой же,
[01:31:59.000 --> 01:32:01.000]  в смысле, raft это, кажется, вариация multipaxis,
[01:32:01.000 --> 01:32:03.000]  потому что multipaxis это вообще не алгоритм, а
[01:32:03.000 --> 01:32:05.000]  work. Вот в нем можно построить raft,
[01:32:05.000 --> 01:32:07.000]  подогнав аккуратно все детали.
[01:32:11.000 --> 01:32:13.000]  Ну, как бы, есть
[01:32:13.000 --> 01:32:15.000]  независимые исследования. Ну, как бы, не то, что
[01:32:15.000 --> 01:32:17.000]  исследования. Мы с вами независимые исследования проведем,
[01:32:17.000 --> 01:32:19.000]  потому что у нас будет multipaxis и raft.
[01:32:19.000 --> 01:32:21.000]  Можно будет написать одно, потом другое, а потом подумать, что же вам
[01:32:21.000 --> 01:32:23.000]  оказалось проще.
[01:32:23.000 --> 01:32:25.000]  Есть еще опыт MIT.
[01:32:25.000 --> 01:32:27.000]  Вот они до 2013 года рассказывали
[01:32:27.000 --> 01:32:29.000]  paxis, а потом стали рассказывать raft.
[01:32:29.000 --> 01:32:31.000]  Вот. И есть
[01:32:31.000 --> 01:32:33.000]  тут, как бы, такая длинная рефлексия
[01:32:33.000 --> 01:32:35.000]  по поводу того, что с этим,
[01:32:35.000 --> 01:32:37.000]  что случилось в итоге.
[01:32:37.000 --> 01:32:39.000]  И вот они здесь пишут, что
[01:32:39.000 --> 01:32:41.000]  raft проще
[01:32:41.000 --> 01:32:43.000]  написать, ну, то есть
[01:32:43.000 --> 01:32:45.000]  трансформировать его в какой-то рабочий код.
[01:32:45.000 --> 01:32:47.000]  Но абсолютно
[01:32:47.000 --> 01:32:49.000]  непроще понять, почему же он работает.
[01:32:49.000 --> 01:32:51.000]  Вот даже сами авторы
[01:32:51.000 --> 01:32:53.000]  raft в своем слайде вас обманывают.
[01:32:53.000 --> 01:32:55.000]  Они говорят, вот мы декомпозируем
[01:32:55.000 --> 01:32:57.000]  задачу на фазу выбора лидера
[01:32:57.000 --> 01:32:59.000]  и фазу репликации. И сначала рассказывают
[01:32:59.000 --> 01:33:01.000]  фазу выбора лидера, а потом фазу репликации.
[01:33:01.000 --> 01:33:03.000]  А потом оказывается, что в фазе выбора лидера
[01:33:03.000 --> 01:33:05.000]  нужно подправить что-то. Потому что без репликации,
[01:33:05.000 --> 01:33:07.000]  но без учета репликации это не работает.
[01:33:07.000 --> 01:33:09.000]  Вот. Ну, как бы, это не похоже
[01:33:09.000 --> 01:33:11.000]  на артагональность. Вот в multipaxis
[01:33:11.000 --> 01:33:13.000]  артагонально. Как бы вы лидеры не выбирали,
[01:33:13.000 --> 01:33:15.000]  ничего плохого не произойдет.
[01:33:15.000 --> 01:33:17.000]  А тут нужно быть аккуратны.
[01:33:17.000 --> 01:33:19.000]  Короче, мне кажется, что нужно
[01:33:19.000 --> 01:33:21.000]  трезво оценивать
[01:33:21.000 --> 01:33:23.000]  все происходящее.
[01:33:23.000 --> 01:33:25.000]  И, конечно же, если вы пишете новую продакшн
[01:33:25.000 --> 01:33:27.000]  систему, то вам нужно брать, видимо, raft.
[01:33:27.000 --> 01:33:29.000]  Если вы не суперспециалист, который знает
[01:33:29.000 --> 01:33:31.000]  все про эти консенсы,
[01:33:31.000 --> 01:33:33.000]  то вы берете open source реализацию raft точно так же,
[01:33:33.000 --> 01:33:35.000]  как вы берете open source реализацию хранилища
[01:33:35.000 --> 01:33:37.000]  локального, типа RocksDB.
[01:33:37.000 --> 01:33:39.000]  Но при этом
[01:33:39.000 --> 01:33:41.000]  под капотом у вас все равно
[01:33:41.000 --> 01:33:43.000]  те же самые две фазы,
[01:33:43.000 --> 01:33:45.000]  те же самые n, те же самые правила,
[01:33:45.000 --> 01:33:47.000]  те же самые теоремы.
[01:33:47.000 --> 01:33:49.000]  Так что в каком-то смысле это одно и то же.
[01:33:49.000 --> 01:33:51.000]  Вот. А дальше вы решаете,
[01:33:51.000 --> 01:33:53.000]  потратили ли мы время сегодня
[01:33:53.000 --> 01:33:55.000]  или узнали что-то новое.
[01:33:55.000 --> 01:33:57.000]  Ну вот, про raft
[01:33:57.000 --> 01:33:59.000]  наверное сейчас
[01:33:59.000 --> 01:34:01.000]  все.
[01:34:01.000 --> 01:34:03.000]  Если есть вопросы, то
[01:34:03.000 --> 01:34:05.000]  спрашивайте.
[01:34:11.000 --> 01:34:13.000]  Ну, смотрите, raft мы успели за одну пару всего.
[01:34:17.000 --> 01:34:19.000]  Что?
[01:34:19.000 --> 01:34:21.000]  Нет, так и планировалось.
[01:34:21.000 --> 01:34:23.000]  Нет, потому что это
[01:34:23.000 --> 01:34:25.000]  еще один аргумент в копилку raft.
[01:34:25.000 --> 01:34:27.000]  В пользу raft.
[01:34:41.000 --> 01:34:43.000]  Ну, и смотри, есть
[01:34:43.000 --> 01:34:45.000]  зукипер, который
[01:34:45.000 --> 01:34:47.000]  использует собственный протокол.
[01:34:47.000 --> 01:34:49.000]  И про зукипер мы сейчас поговорим,
[01:34:49.000 --> 01:34:51.000]  но не только про зукипер,
[01:34:51.000 --> 01:34:53.000]  но и про него тоже поговорим сейчас
[01:34:53.000 --> 01:34:55.000]  на второй половине.
[01:34:55.000 --> 01:34:57.000]  Вот.
[01:34:57.000 --> 01:34:59.000]  А все остальное это либо Paxos, либо raft.
[01:35:01.000 --> 01:35:03.000]  Ну вот, например, AVS,
[01:35:05.000 --> 01:35:07.000]  облака Амазона, они используют
[01:35:07.000 --> 01:35:09.000]  Paxos у себя.
[01:35:11.000 --> 01:35:13.000]  Google использует Paxos.
[01:35:13.000 --> 01:35:15.000]  Ну, Google использует Paxos, понятно, по каким причинам.
[01:35:15.000 --> 01:35:17.000]  Это не потому что сознательные выборы,
[01:35:17.000 --> 01:35:19.000]  потому что они давно уже Paxos написали,
[01:35:19.000 --> 01:35:21.000]  и как-то глупо все стирать без raft теперь,
[01:35:21.000 --> 01:35:23.000]  с теми же самыми свойствами.
[01:35:23.000 --> 01:35:25.000]  Если вы не Google,
[01:35:25.000 --> 01:35:27.000]  практически никто не Google,
[01:35:27.000 --> 01:35:29.000]  никто не Google кроме Google,
[01:35:29.000 --> 01:35:31.000]  то вы берете raft.
[01:35:31.000 --> 01:35:33.000]  Ну, пишете свой raft
[01:35:33.000 --> 01:35:35.000]  или берете опенсорсный raft?
[01:35:35.000 --> 01:35:37.000]  А, в Яндексе,
[01:35:37.000 --> 01:35:39.000]  у IT там писали
[01:35:39.000 --> 01:35:41.000]  консенсус примерно тогда,
[01:35:41.000 --> 01:35:43.000]  когда raft публиковал статью,
[01:35:43.000 --> 01:35:45.000]  то есть там в 2013-2012 году,
[01:35:45.000 --> 01:35:47.000]  так что там...
[01:35:47.000 --> 01:35:49.000]  Ну, он...
[01:35:49.000 --> 01:35:51.000]  Это не raft,
[01:35:51.000 --> 01:35:53.000]  это какой-то протокол консенсуса,
[01:35:53.000 --> 01:35:55.000]  который, ну,
[01:35:55.000 --> 01:35:57.000]  в каком-то смысле все одно и то же,
[01:35:57.000 --> 01:35:59.000]  поэтому...
[01:35:59.000 --> 01:36:01.000]  Ну, у него есть внутреннее название,
[01:36:01.000 --> 01:36:03.000]  но это все равно
[01:36:03.000 --> 01:36:05.000]  некоторая вариация на тему
[01:36:05.000 --> 01:36:07.000]  в конце концов.
[01:36:07.000 --> 01:36:09.000]  То есть там тоже должны быть
[01:36:09.000 --> 01:36:11.000]  вот эти эпохи, эти правила про то,
[01:36:11.000 --> 01:36:13.000]  чтобы заблокировать или перейти в эпоху,
[01:36:13.000 --> 01:36:15.000]  ну и так далее.
[01:36:15.000 --> 01:36:17.000]  Ну, кажется,
[01:36:17.000 --> 01:36:19.000]  что и вот невозможно
[01:36:19.000 --> 01:36:21.000]  ничего другого придумать,
[01:36:21.000 --> 01:36:23.000]  и что лэмпард, он вот захватил самую суть.
[01:36:23.000 --> 01:36:25.000]  Поэтому
[01:36:25.000 --> 01:36:27.000]  лэмпард так и хорош.
[01:36:27.000 --> 01:36:29.000]  Греки уже все придумали.
[01:36:29.000 --> 01:36:31.000]  Греки, да, вот...
[01:36:31.000 --> 01:36:33.000]  Греки действительно все придумали для нас.
[01:36:35.000 --> 01:36:37.000]  Ладно, давайте перерыв 10 минут,
[01:36:37.000 --> 01:36:39.000]  а потом...
[01:36:39.000 --> 01:36:41.000]  Потом продолжим.
