[00:00.000 --> 00:11.200]  сегодня мы поговорим про локаторы да значит моя цель сегодня успеть вам
[00:11.200 --> 00:21.200]  рассказать все что нужно и выдать вам первую задачу да я понимаю ваши опасения
[00:30.000 --> 00:38.400]  полгосом то да у основы у основы тоже первая задача этой недели должна появиться
[00:38.400 --> 00:42.360]  но она будет другая вот эта задача которая у вас будет первая она будет
[00:42.360 --> 00:50.480]  второй у них да еще дек вас мы уж так и быть решили избавить от дека и но зато
[00:50.480 --> 00:58.360]  добавить кое-что другое конец вот так сказать поп-фронт pushback сделали да
[00:58.360 --> 01:10.320]  с фейковой вершиной с одной не ну получилось бы но это было бы криво
[01:10.320 --> 01:18.800]  неприятно так окей смотрите значит начнем по пунктам что сначала что такое
[01:18.800 --> 01:31.320]  локатор даже идея локаторов ну давайте вспомним что мы знаем уже к
[01:31.320 --> 01:38.240]  текущему моменту про память и про управление памятью ну мы наверное
[01:38.240 --> 01:47.600]  знаем из первого семестра возможно и со школы даже что вот бывает стек ну что
[01:47.600 --> 01:52.880]  вот есть я напоминаю вот это статическая память да тут которая дата потом есть
[01:52.880 --> 01:58.040]  код текст и стек вот это то что выделяется вашей программе изначально
[01:58.040 --> 02:05.040]  фиксированного размера а есть еще динамическая память называется хип и у
[02:05.040 --> 02:10.400]  нас есть оператор нею который которым мы иногда можем обращаться если мы
[02:10.400 --> 02:15.920]  понимаем что по какой-то причине вот стэк мы не хотим класть но то что мы
[02:15.920 --> 02:20.880]  значит по умолчанию локальные перемены заводим они кладутся в стэк статические
[02:20.880 --> 02:24.680]  перемены кладутся сюда и глобальные а если мы понимаем что в стэк мы не
[02:24.680 --> 02:28.960]  помещаемся ну или просто если мы заводим какой-нибудь вектор стринг мы
[02:28.960 --> 02:33.320]  же не обязательно в стэк не помещаемся когда заводим стринг просто стринга и
[02:33.320 --> 02:39.720]  вектор так устроена что они внутри себя выделяют память на кучу и вот
[02:39.720 --> 02:45.000]  происходит фактические обращение к оператору нею который в свою очередь а
[02:45.040 --> 02:51.280]  вот что делает оператор нею кто понимает что он делает примерно ну да это
[02:51.280 --> 03:04.040]  понятно а как да на самом деле там есть еще один уровень вот оператор нею он сам
[03:04.040 --> 03:11.280]  по себе ну понятно что он как-то реализован компилятором да оператор
[03:11.280 --> 03:17.880]  нею ее правда можно переопределить и этим мы вскоре займемся это правильное
[03:17.880 --> 03:24.680]  замечание обычно действительно не стоит так делать но стоит хотя бы
[03:24.680 --> 03:32.160]  посмотреть как это делается так вот оператор нею он вызывает функцию malloc
[03:32.160 --> 03:37.160]  скорее всего ну то есть если мы будем писать свой оператор нею то скорее
[03:37.160 --> 03:40.480]  всего мы будем обращаться к сишной функции выделения памяти оператор нею это
[03:40.480 --> 03:44.200]  по сути такая чуть более высокоуровневая отстройка но malloc но что делает оператор
[03:44.200 --> 03:50.640]  нею он на самом деле выделяет памяти вызывает еще конструктор ну еще всякие
[03:50.640 --> 03:55.360]  разные вещи делать например бросает исключение если памяти не хватило вот
[03:55.360 --> 04:03.720]  еще разные вещи там делает например поддерживает кастомную функцию обработки
[04:03.720 --> 04:07.360]  ситуации когда памяти не хватило new handler так называемый ну это примерно как
[04:07.360 --> 04:13.120]  вот terminate по сравнению с abort вот мы уже с вами обсуждали что есть плюсовая
[04:13.120 --> 04:18.000]  функция terminate которая чуть более умная обертка над сишной функцией abort когда
[04:18.000 --> 04:23.400]  программу надо завершить экстренно но вот это вот как бы вот это вот уровень вот
[04:23.400 --> 04:31.400]  это вот мир c++ вот это вот c ну функция malloc в свою очередь она тоже не просто
[04:31.400 --> 04:39.920]  так устроена она на самом деле там скрыта довольно сложная логика в ней и она
[04:39.920 --> 04:44.200]  пытается как-то вот по умному что-то делать как-то вот распоряжаться с
[04:44.200 --> 04:52.160]  памятью но сама по себе функция malloc это еще не уровень операционной системы то
[04:52.160 --> 04:56.920]  есть функции malloc можно еще написать самому вот можно самому написать аналог
[04:56.920 --> 05:03.520]  malloc правда это очень сложно будет вы поймете наверное скоро почему но сама
[05:03.520 --> 05:08.680]  по себе функция malloc еще можно на c реализовать а вот дальше начинает есть
[05:08.680 --> 05:20.520]  еще один уровень это уровень os kernel но это тоже c правда но я даже не буду
[05:20.520 --> 05:27.800]  стирать но вот дальше есть такая функция mmap называется это так называемый системный
[05:27.800 --> 05:33.080]  вызов что такое системный вызов это функция которая передает управление ядру
[05:33.080 --> 05:37.200]  операционной системы функция malloc это еще не системный вызов это еще функция из
[05:37.200 --> 05:42.200]  библиотеки сишной а вот ммэп это функция которой malloc обращается в конечном счете
[05:42.200 --> 05:45.680]  когда он понимает что сам не справляется то есть malloc там поддержит какой-то пул
[05:45.680 --> 05:53.240]  свой он что-то делает неважно ну в конечном счете все опирается в функцию ммэп ну или там ее аналог
[05:53.240 --> 05:58.840]  неважно там какой и вот ммэп это уже непонятно как устроено ну то есть может быть и понятно
[05:58.840 --> 06:06.440]  может вам там на втором курсе расскажут про это но я вот уже не знаю как это устроено да но это вот
[06:06.440 --> 06:11.120]  ядро операционной системы делает там как-то вот уже непосредственно вот прям вот с оперативной
[06:11.120 --> 06:20.720]  памяти что делает но окей это вот все оно так выглядит вниз но мы с вами знаем что вызов
[06:20.720 --> 06:27.640]  оператора new это вещь которую вообще мы обычно хотим избегать не правда ли но то есть мы с
[06:27.640 --> 06:33.960]  вами понимаешь что вызов оператора new вот в нашем мире в мире c++ это достаточно такое дорогое
[06:33.960 --> 06:39.480]  действие которое приводит аж вот к такому и там передается управление ядро операционной системы
[06:39.840 --> 06:46.440]  наша программа замирает планировщик переключает выполнение там на ядро и начинается что вот мы
[06:46.440 --> 06:54.640]  хотим мы подумаем а вот нельзя ли нам как-нибудь взять управление памятью в свои руки почему бы
[06:54.640 --> 07:03.080]  нам не написать какой-нибудь класс который бы сам решал как памятью распоряжаться ну как бы он
[07:03.080 --> 07:10.920]  это делал ну понятно что разочек все-таки оператор new вызвать бы пришлось ну разочек в самом
[07:10.920 --> 07:19.160]  начале допустим вызовем оператора new на гигабайт сразу а потом мы будем просто класс поддерживать
[07:19.160 --> 07:26.400]  который сам будет ну вот по какой-то причине мы можем лучше знать как нам памятью распорядиться
[07:26.400 --> 07:32.280]  чем системный вот этот вот молок или кто-то там есть и просто теми кто память распоряжается
[07:32.280 --> 07:45.720]  да это это это это первое во первых нет
[07:45.720 --> 08:07.680]  а ладно я просто хорошо ладно нет я я если что сегодня на одну только пришел да я я если что
[08:07.680 --> 08:13.920]  был даже морально готов к тому что и на вторую не приедешь но ну просто вдруг ну хорошо что
[08:14.040 --> 08:23.200]  были готовы обе стороны хорошо ладно так вот да есть две причины во первых мы хотим
[08:23.200 --> 08:28.920]  минимизировать обращение вот сюда это долго очень а во вторых мы можем просто сами лучше знать как
[08:28.920 --> 08:35.160]  нам распоряжаться ну потому что например мы можем знать что все наши выделение памяти будут одного
[08:35.160 --> 08:42.560]  размера и маленькими но скажем мы знаем что мы вот нам предстоит порядка миллион раз вызвать
[08:42.560 --> 08:47.840]  оператор нею на 4 байта планировщик ну менеджер памяти операционной системы не может делать
[08:47.840 --> 08:53.200]  таких предположений он старается угодить всем вы можете выбирать разные алгоритмы memory
[08:53.200 --> 08:58.360]  менеджмента смотря по тому какие скорее всего как вы предполагаете у вас выделение памяти
[08:58.360 --> 09:02.960]  будут какого размера и сколько и в каком порядке в ком количестве там понятно что вот вот этим
[09:02.960 --> 09:07.560]  вот пулом можно распорядить вот этим вот пулом можно распоряжаться по-разному смотря что вам
[09:07.560 --> 09:13.680]  предстоит выделять и насколько много вот поэтому зачастую бывает так ну не зачастую но иногда
[09:13.680 --> 09:22.760]  бывает так что вы лучше сможете вы лучше знаете как распорядиться пулом памяти чем операционная
[09:22.760 --> 09:26.640]  система просто потому что операционная система не может сделать предположение о том сколько вы
[09:26.640 --> 09:34.360]  впредь и каких запросов ей дадите вот поэтому мы приходим к идее того чтобы неплохо иметь
[09:34.360 --> 09:44.640]  свой класс еще вот над ним уровнем выше который называется allocator на уровне плюсов то есть
[09:44.640 --> 09:53.400]  вот allocator это еще одна абстракция над оператором new которая позволяет вам самому один раз допустим
[09:53.400 --> 09:57.440]  обратившись к new а может быть и вообще не обращаясь к new сейчас мы обсудим варианты
[09:57.440 --> 10:13.240]  написать свой менеджер памяти вот ну и на самом деле если теперь еще раз глянуть на контейнеры вот
[10:13.240 --> 10:18.480]  например на вектор можно наконец открыть глаза на реальность и заметить что там у них у всех
[10:18.480 --> 10:24.080]  был еще один шаблонный параметр мы обходили стороной старались про него не упоминать но
[10:24.080 --> 10:29.920]  теперь самое время на самом деле у всех контейнеров вектор листа есть еще один шаблонный
[10:29.920 --> 10:39.440]  параметр allocator то есть на самом деле вектор но он выглядит так значит там есть template type
[10:39.440 --> 10:47.480]  name t вот конечно из-за доски у меня есть искушение начать писать класс t вместо type name t type name
[10:47.480 --> 10:55.400]  alloc вот но он это шаблонный параметр по умолчанию поэтому его вы никогда скорее
[10:55.400 --> 11:02.000]  всего не упоминаете и не думаете о нем потому что он по умолчанию подставляется равным чему
[11:02.000 --> 11:18.480]  std allocator от t у него шаблонный параметр тоже есть да на самом деле спойлер вот вот это это
[11:18.480 --> 11:23.440]  была огромная ошибка комитета по стандартизации когда они добавили а локатору шаблонный параметр
[11:23.440 --> 11:29.280]  но осознали они это слишком поздно и все плюс плюс в общем дальше был долгий путь страданий как
[11:29.280 --> 11:38.720]  они пытались от стандарта к стандарту сделать а локаторы более удобоваримой концепции языка
[11:38.720 --> 11:45.960]  но в конце концов c++17 они ввели std polymorphic allocator который избавил от необходимости писать
[11:45.960 --> 11:55.280]  шаблонный параметр t но это длинный спойлер это далекий спойлер вот на там пару занятий вперед
[11:55.280 --> 12:01.960]  наверное ну нет ладно на одно следующий раз мы уже мы до этого дойдем вот но пока идея в том
[12:01.960 --> 12:14.760]  что мы пишем шаблон параметр t но оно так вот и используется ну вот и теперь давайте посмотрим
[12:14.760 --> 12:24.640]  как на самом деле должен выглядеть ну скажем резерв вот когда у нас был резерв там мы на
[12:24.640 --> 12:32.160]  самом деле но эти вообще подумаем что нам надо это локатор какие методы мы хотим чтобы обращение
[12:32.160 --> 12:39.880]  к нью заменять ну и дилит что логично заменялись вызовами каких-то методов локатора а локатор
[12:39.880 --> 12:45.800]  должен себя инкапсулировать логику либо обратиться к нью либо сделать что-то более умное что
[12:45.800 --> 12:53.720]  возможно мы сами напишем если подставим сюда вместо стд локатор свой локатор по сути нам
[12:53.720 --> 13:05.120]  нужно от локатора два метода а локейт идея локейт да и вместо чего мы будем писать а локейт
[13:05.120 --> 13:19.120]  вот там где мы пишем нью нью от там п ты вот чего-то там вместо этого мы будем писать
[13:19.120 --> 13:26.400]  а локатор точка локейт ну у нас на самом деле здесь будет поле еще у нас будет поле
[13:26.400 --> 13:34.320]  который просто а лог это некоторый объект он живет как поле в векторе то есть на самом
[13:34.320 --> 13:47.480]  деле у вектора еще на одно поле больше я не сказал что он большой он очень маленький на самом
[13:47.480 --> 13:54.880]  деле это правда но это же не означает что он сам должен быть большим маленький но даленький
[13:54.880 --> 14:03.920]  но сейчас увидишь но он нет сам по себе объекта лог маленький он там указатель хранит и пармчисел
[14:03.920 --> 14:13.280]  обычно сам ну сейчас сейчас увидим вот ну короче это некоторый объект и он должен храниться где-то
[14:13.280 --> 14:24.080]  в полях поэтому на самом деле у вектора не три поля а 4 то есть помимо указателя на массив самого
[14:24.080 --> 14:34.160]  сайза и кп 100 еще есть а локатор вот но стандартный а локатор он вообще очень маленький у него
[14:34.160 --> 14:40.600]  ща полей нет ну сейчас увидите в общем чего на себя представляет что такое вот это будет
[14:41.240 --> 14:44.600]  вместо этого мы будем теперь писатьanner.alocate
[14:44.600 --> 14:46.820]  а log с точка аллокить так нет
[14:52.960 --> 14:57.100]  минуточку минуточку минуточка минуточках мы как раз так то не хотим дело это будет как раз
[14:57.100 --> 15:03.780]  неправильный написал вот мне вместо этого будем а лока локейт писать это же как раз не прил액ает
[15:03.780 --> 15:09.360]  операции а Лакита мы должны писать в те моменты когда мы алоцируем а и Conスト рейн уже алоцируем
[15:09.360 --> 15:18.060]  как раз все наоборот вот как раз то что я хотел а правильно мы там писали жуть
[15:18.060 --> 15:30.360]  в виде что-то типа newr ну там мы писали там t звездочка newr равно ну там где-то
[15:30.360 --> 15:34.720]  мы там делали резерв когда мы там реалацировали мы что писали новый
[15:34.720 --> 15:50.240]  массив это это там reinterpret cast t звездочки от на самом деле new char в
[15:50.240 --> 15:59.320]  квадратных скобочках там сколько-то n умножено size of t вот это жесть вот как
[15:59.320 --> 16:06.680]  раз вместо этого мы нет это как раз нетипичный код на c++ в современном c++
[16:06.680 --> 16:11.640]  так не пишут так не принято принято писать вот даже на самом деле не так
[16:11.640 --> 16:19.160]  принято еще чуть по-другому но сейчас вот пока будем так писать а лог точка
[16:19.160 --> 16:32.240]  локеть и локеть один параметр сколько да кто ху вот сколько n да вот поэтому
[16:32.240 --> 16:41.320]  он и от т потому что он знает да вот то что на т как раз говорит о том что ему
[16:41.320 --> 16:44.880]  мы передаем только сколько штук а он выделит байт столько сколько надо
[16:44.880 --> 16:59.800]  под столько штук на кучу он их выделит но зависит от него это локатора конечно он
[16:59.800 --> 17:06.800]  возвращает указатель то есть вот мы вместо там вместо вот этого мы пишем теперь вот вот
[17:06.800 --> 17:15.120]  вот короче пишем вот это вот теперь а дело а еще есть делокейт а как работает делокейт
[17:15.120 --> 17:25.560]  да мы должны вот вместо того чтобы писать там ночем не буду мы там писали до дилит
[17:25.560 --> 17:30.800]  квадратной скобочки опять три интерпрет каст к чар звездочки вот это всего вы писать
[17:31.660 --> 17:44.260]  локейт вот что нужно передавать передавать нужно указатель и число зачем передавать число
[17:44.260 --> 17:55.480]  ну ответ математика абсолютно точно абсолютно бесполезно drastically требует стандарт почему
[17:55.480 --> 18:00.040]  на самом деле нужно передавать число но на самом деле стандартному а локатору как раз не нужно
[18:00.040 --> 18:08.920]  число, но вот вашему аллокатору может быть нужно. И в общем приняли соглашение, что надо
[18:08.920 --> 18:21.600]  передавать число то самое, которое вы передавали, когда просили allocate это. Из-за какого? Полимортный
[18:21.600 --> 18:26.440]  появился только в C++17, а это еще в C++03 было, тогда еще никто не подозревал о том, что.
[18:26.440 --> 18:37.040]  Нет, полиморфный аллокатор это вообще не аллокатор в старом понимании, это вообще
[18:37.040 --> 18:43.480]  другая вещь. Ну, точнее, нет, это аллокатор, но, короче, он с этим аллокатором никак не связан.
[18:43.480 --> 18:58.560]  Да, ну, короче, вот просто так вот надо передавать. Потом, возможно, поймем почему, а, возможно,
[18:58.560 --> 19:03.520]  нет. Ну, возможно, вам это понадобится когда-нибудь, а, возможно, не понадобится. Вот, но есть еще два
[19:03.520 --> 19:13.520]  метода аллокатора. Почти, ну, то есть, на самом деле в C++20 они признаны устаревшими и их убрали,
[19:13.520 --> 19:21.520]  но я про них все-таки расскажу. А именно, у них еще есть метод construct и destroy. Сейчас я объясню,
[19:21.520 --> 19:26.520]  почему они стали deprecated и что вместо них, но сначала я все-таки расскажу, как было до этого.
[19:26.520 --> 19:37.440]  Еще есть метод construct. Вот construct — это как раз замена вызову placement new. Как вы пишете construct?
[19:37.440 --> 19:47.280]  Вы пишете construct ptr, а дальше args, и он вам ничего не возвращает. Значит, construct — это то,
[19:47.280 --> 19:58.760]  что как раз надо писать вместо new от ptr, t от args. Так, вот вы по указателю хотите создать объект типа t
[19:58.760 --> 20:05.520]  от таких аргументов. Аргументов тут может быть много. Обычно это параметр шаблоны с переменным
[20:05.520 --> 20:10.160]  количеством аргументов, и тут многоточие, просто распаковка пакета. Вот, еще есть destroy.
[20:10.160 --> 20:22.880]  Construct и destroy. destroy — вы ему просто передаете ptr, ну и он по факту вызывает destructor t
[20:22.880 --> 20:35.320]  по этому адресу. Нет, он пишет ptr, стрелочка, тильда t. Да, конечно, только одиночного объекта.
[20:35.320 --> 20:44.120]  Вот. Ну по сути нам вот эти четыре вещи-то и надо будут. То есть вот все то, что мы там свистоплязка
[20:44.120 --> 20:48.480]  вот с этим вот new и непонятными какими-то заклинаниями писали, теперь у нас есть просто
[20:48.480 --> 20:53.640]  четыре метода, которые за нас там что-то делают. Возможно, делают это, возможно, делают что более умное.
[20:53.640 --> 20:58.840]  Теперь давайте поймем, а как они реализованы на самом деле в std-аллокаторе.
[20:58.840 --> 21:17.640]  Отличный вопрос. Очень правильный, но он преждевременно задан. То есть действительно,
[21:17.640 --> 21:25.200]  почти никогда не нужно делать что-то иное, чем placement new просто. Как и в случае destroy,
[21:25.200 --> 21:32.240]  почти никогда не нужно делать нечто отличное от вызова destructor явного. Но бывают случаи.
[21:32.240 --> 21:41.280]  И сегодня не будет их. Но вот в следующий раз, завтра, я думаю, тоже не будет,
[21:41.280 --> 21:52.040]  а вот через неделю я думаю, что расскажу. Вам так не хочется? Слушайте, ну вы как-то рано
[21:52.040 --> 21:59.720]  сдаете, семестер только начался, нам еще гораздо более интересные вещи предстоит. Слушайте,
[21:59.720 --> 22:05.280]  с вами как-то невозможно работать. То вам скучно, потому что слишком банальные вещи рассказываются,
[22:05.280 --> 22:10.280]  то когда начинаются не банальные вещи, а можно, не надо, мы не хотим это знать. И как вообще,
[22:10.280 --> 22:15.320]  как отгадать вообще, что вам надо рассказывать тогда, я не очень понимаю. Как-то очень сложно
[22:15.320 --> 22:21.240]  балансировать, слишком капризные какие-то люди пошли. Так, короче, вот четыре метода.
[22:21.240 --> 22:27.000]  Construct и destroy действительно почти всегда делают одно и то же, но иногда все-таки нет, и поэтому
[22:27.000 --> 22:34.080]  у некоторых аллокаторов, у них там хитрая реализация, ну про это мы потом поговорим,
[22:34.080 --> 22:39.680]  пока еще не понятно совершенно, что это могло быть такое. Аргументы, которые в constructor.t
[22:39.680 --> 22:46.280]  надо передать, new от ptr, t от args нужно же написать. Так, хорошо, ну теперь, что из себя представляет
[22:46.280 --> 22:52.480]  вот этот std-аллокатор на самом деле? Вот как он реализован? Ну вот тут бы, конечно, мне не
[22:52.480 --> 22:58.320]  помешал проектор и просто код на экран вывести, но раз уж у меня нет проектора, давайте я потрачу
[22:58.320 --> 23:04.880]  лишние пять минут и напишу реализацию на доске. Но я причем не буду даже, наверное, писать там
[23:05.200 --> 23:20.840]  что такое вообще, как выглядит? Хорошо, template. Ну ладно, нормально, успеем. TypeNameT. Я напишу,
[23:20.840 --> 23:29.960]  что это структура, а не класс, потому что там все публичное будет. Вопреки ожиданиям, возможно,
[23:29.960 --> 23:36.160]  которые у кого-то были. Аллокатор это максимально простая и очень тупая структура. Написать
[23:36.160 --> 23:44.800]  реализацию std-аллокатор это упражнение там, не знаю, для семиклассника, да. Я хотел сказать на
[23:44.800 --> 23:49.960]  троечку, ну типа, ну очень просто. Стандартный аллокатор, он очень примитивный. Во-первых,
[23:49.960 --> 23:56.760]  там нет полей ни одного. А что делают методы стандартного аллокатора? Так просто они должны
[23:56.760 --> 24:04.880]  делать то, что раньше было написано вместо этого. То есть, как, например, работает allocate? Он
[24:04.880 --> 24:29.560]  возвращает t звездочка, allocate. Да, принимает он что? Size tn. Да. Так, ну и что он делает? Ну тут
[24:29.560 --> 24:39.080]  возможно написать const. Я не знаю, ну я даже не знаю, правильно ли писать тут const. Ну вообще
[24:39.080 --> 24:45.000]  можно написать, потому что аллокатору пофигу, конечно, на этот allocate. В случае стандарт,
[24:45.000 --> 24:51.200]  вообще говоря, аллокатору не пофиг, когда allocate происходит, потому что аллокатор может
[24:51.200 --> 24:55.620]  от этого поменяться. Ну потому что если это какой-то умный аллокатор, у него может хранить
[24:55.620 --> 25:00.180]  состояние, он может как-то вот менять что-то в себе в зависимости от того, какой allocate сделали.
[25:00.180 --> 25:06.420]  Но стандартный аллокатор, ему без разницы, ему вообще менять нечего. Просто стандартные у него
[25:06.420 --> 25:19.140]  полей нету. Ну константный аллокатор довольно странная сущность. Я вообще не знаю, где такое
[25:19.140 --> 25:27.540]  бывает или нет. Не буду писать const на всякий случай, потому что как-то это неправильно. Вообще,
[25:27.540 --> 25:33.180]  наверное, это не идеоматично allocate, чтобы было константным. Ну и что тут? Тут надо написать
[25:33.180 --> 25:41.260]  return. Ну вот надо примерно вот это и написать, вот это вот, return, вот это вот, return, бла-бла-бла-бла-бла-бла,
[25:41.260 --> 25:52.220]  интерпет, касты. Вот. Ну на самом деле не совсем это опять-таки, но тут можно бесконечно улучшать,
[25:52.220 --> 25:57.660]  понимаете. Есть очень много уровней, глубины, до которых можно это все оптимизировать. Ну
[25:57.660 --> 26:02.980]  идеи, например, на это надо написать. На самом деле там обращение к new чуть по-другому выглядит,
[26:02.980 --> 26:08.620]  там не написано new char, а там чуть-чуть другая форма new используется, но по смыслу все вот
[26:08.620 --> 26:16.060]  примерно это там написано. Просто вот вернуть это надо. Понятно, что дело deal locate. Нужно просто
[26:16.060 --> 26:25.860]  вызвать, ну опять же, нужно вызвать delete к чару опять приведенный и там надо на самом деле ничего
[26:25.860 --> 26:36.380]  не возвращать даже. Там вот что делать construct? construct вызывает оператор new, как раз placement
[26:36.380 --> 26:50.060]  new, construct. Что делает construct? t звездочка ptr и еще аргументы, переменное число. Да,
[26:50.060 --> 27:02.900]  у него должно быть переменное число шаблонных аргументов. Type name многоточие args. Вот. Ну и тут
[27:02.900 --> 27:13.460]  надо написать что-то типа const args ampersand многоточие args. Опять же, на самом деле не совсем это,
[27:13.460 --> 27:28.620]  но к этому вопросу вернемся еще позже. Что если ут нет конструктора этих ваших пакетов? В смысле от
[27:28.620 --> 27:41.580]  пакетов. Не бывает конструктора от пакетов. Бывает конструктор от некоторого количества
[27:41.580 --> 27:49.980]  аргументов. Пакет это сущность, которая существует только в сознании компилятора. В момент генерации
[27:49.980 --> 27:56.540]  шаблонного кода она превращается в нормальный список параметров. Без вот этого уже. Ну и тут
[27:56.540 --> 28:09.300]  просто происходит new от ptr, t от args. Вот. Ну и destroy я не буду писать, что происходит. Очевидно,
[28:09.300 --> 28:19.060]  что происходит. Просто делается ptr стрелочка tilde t. Вот. Так выглядит аллокатор. То есть на
[28:19.060 --> 28:33.860]  самом деле вот этот объект он один байт всего занимает. Все один байт. Вот. Почему один, а не
[28:33.860 --> 28:40.500]  ноль? Ну потому что не бывает объектов размера ноль байт. Но вот один байт больше не надо. Как
[28:40.500 --> 28:47.460]  выглядят конструкторы копирования, оператор присваивания этого аллокатора? Move конструк...
[28:47.460 --> 28:55.900]  Ой, извините, вы не знаете. Ладно, destructor. Ну в общем, они тривиальные. Они, ну можно писать
[28:55.900 --> 29:00.020]  равно default, но это вообще без разницы, потому что они ничего не делают. Можно написать,
[29:00.020 --> 29:06.740]  что они пустые просто. Можно их не писать, не будут по умолчанию. Ну они просто ничего не
[29:06.740 --> 29:11.060]  делают, потому что копировать нечего. Этот аллокатор он stateless, у него нет состояния,
[29:11.060 --> 29:23.860]  он ничего не хранит. Это просто обертка над вызовами new и delete. Вот. Зачем нам, почему,
[29:23.860 --> 29:35.860]  что еще раз? Вот сейчас как раз вот сейчас понятно, что если бы все аллокаторы были
[29:35.860 --> 29:41.620]  такими, то не нужно было бы объектов создавать. Но давайте подумаем, какие могут быть другие
[29:41.620 --> 29:49.820]  аллокаторы. Вот например, ну то, о чем я говорил, вот что если я хочу завести большой пул в самом
[29:49.820 --> 30:05.260]  начале и им распоряжаться самостоятельно? Ну такое, потому что, а что делать,
[30:05.260 --> 30:17.700]  если он исчерпается? Нет, перекладывать ничего нельзя. Аллокатор, нет, аллокатор не может
[30:17.700 --> 30:24.460]  перекладывать, он должен, это уже не то. Ну на самом деле придется поддерживать что-то типа там
[30:24.460 --> 30:31.620]  связанный список этих пулов, ну этих блоков, да. Но можно работать в предположении, что пул
[30:31.620 --> 30:39.500]  никогда не исчерпывается. Потому что, смотрите, ну можно, например, кидать исключение, если пул
[30:39.500 --> 30:47.700]  исчерпался. Нет, ну смотрите, вы обычно же чего, вы для чего используете свой аллокатор? Вы используете
[30:47.700 --> 30:53.860]  свой аллокатор как раз потому, что вы это знаете лучше, чем вот операционная система, как будет
[30:53.860 --> 30:58.260]  и сколько памяти у вас выделено. Вы допустим понимаете, что вы ни за что, ни когда в жизни
[30:58.260 --> 31:05.300]  выделите больше гигабайта. Поэтому ваш аллокатор, он в самом начале выделяет гигабайт и дальше
[31:05.300 --> 31:12.900]  работает в предположении, что он никогда не исчерпается. Нет, можно, конечно, там считать,
[31:12.900 --> 31:17.340]  что возможна ситуация, что оно исчерпается, ну и поддерживает там действительно какое-то вот несколько
[31:17.340 --> 31:26.540]  этих блоков. Вот, ну то есть как теоретически мог бы быть устроен нестандартный аллокатор? Вот
[31:26.540 --> 31:41.980]  типичный пример такого аллокатора это пул-аллокатор. Пул, не тот маркер, пул-аллокатор. Нет, это вам написать
[31:41.980 --> 31:46.820]  надо будет. Ну нет, на самом деле не совсем это вам написать надо будет. Сейчас я вам расскажу. Да.
[31:46.820 --> 32:03.820]  Нет, не хотим, потому что аллокатор должен копироваться уметь. Что должно происходить,
[32:03.820 --> 32:10.940]  когда ты вектор конструируешь от другого вектора? Представь, что у тебя аллокатор синглтон и ты
[32:10.940 --> 32:17.340]  решил написать вектор равно другой вектор. У вектора есть поле аллокатор, он должен быть как-то
[32:17.340 --> 32:28.820]  создан из аллокатора, который был там. Как это должно произойти? Если аллокатор... Нет, вот как раз
[32:28.820 --> 32:35.260]  нет. Мы храним в поле сам аллокатор, а не указательный аллокатор. Идея в том, что сам по себе аллокатор
[32:35.260 --> 32:43.100]  это легковесный объект. Это правильный вопрос. Да, у вас может быть несколько аллокаторов,
[32:44.500 --> 32:50.260]  аллокатор это средство управления некоторым блоком памяти. Сам по себе аллокатор должен быть
[32:50.260 --> 32:56.500]  маленьким и легковесным. Аллокатор в себе не должен хранить какую-то огромную вещь. Он содержит
[32:56.500 --> 33:02.020]  себе обычно правильный и диаматически использованный аллокатор. Аллокатор себе содержит пару указателей,
[33:02.620 --> 33:09.900]  и у вас может быть несколько аллокаторов на один и тот же блок памяти ссылающихся, на один и тот
[33:09.900 --> 33:19.780]  же пул. И когда вы копируете вектор, вы можете получить копию того аллокатора,
[33:19.780 --> 33:26.260]  которая будет вам позволять использовать тот же блок памяти, что и тот вектор использовал.
[33:26.260 --> 33:52.380]  У них может быть как раз класс Singleton, который хранит в себе состояние глобальное для данного
[33:52.380 --> 34:15.420]  блока памяти. У вас должен быть класс пул, в котором и выделен этот пул, и он хранит вектор из каких-то
[34:15.420 --> 34:27.780]  чисел, которые говорят о том, как этот пул хранится в этом классе. Аллокатор – это лишь средство
[34:27.780 --> 34:37.820]  обращения к этому пулу. То есть пулы-аллокаторы, их может быть несколько, ссылающихся на один и тот
[34:37.820 --> 34:48.660]  же пул. И возникает правильный вопрос, когда я создаю пул-аллокатор, что я должен делать,
[34:48.660 --> 34:59.020]  когда я создаю новый пул-аллокатор? Я должен, наверное, создать новый пул. У меня несколько
[34:59.020 --> 35:07.620]  пул-аллокаторов может заведовать одним пулом, но я же могу иметь несколько пулов в одной программе.
[35:07.620 --> 35:14.100]  То есть у меня есть большой пул, и сколько-то пул-аллокаторов им распоряжается. Есть другой
[35:14.100 --> 35:19.220]  большой пул для других нужд, и сколько-то пул-аллокаторов им распоряжается. То есть,
[35:19.220 --> 35:23.140]  если я создаю новый аллокатор с какими-то определенными параметрами, допустим, я хочу
[35:23.140 --> 35:28.220]  сказать, пул-аллокатор нам вот 100 тысяч. Это означает, что я должен новый пул создать,
[35:28.220 --> 35:36.100]  то есть я создаю новый инстанс класса пул и запоминаю указатель на него, допустим. А дальше,
[35:36.100 --> 35:43.500]  когда я создаю пул-аллокатор от другого пул-аллокатора, я лишь копирую этот указатель,
[35:43.500 --> 35:49.460]  и у меня получается, что несколько пул-аллокаторов на один тот же пул указывают, да?
[35:49.460 --> 36:07.740]  Да, ну да. Нет, сейчас, при чем тут вектор? Почему нам не хватит одного большого пула?
[36:07.740 --> 36:19.620]  Потому что у тебя может быть, ну как, смотри, например, в одном пуле ты хочешь выделять только
[36:19.620 --> 36:27.020]  по одному байту всегда, а в другом по 5 байт всегда. Ну, например, тебе нужно поддерживать там
[36:27.020 --> 36:35.340]  большие хранилища объектов разного типа. Вот в одном пуле ты точно знаешь, что у тебя будет
[36:35.340 --> 36:47.660]  постоянно выделение памяти по, не знаю, по 10 байт, а в другом всегда по 25 байт. Так вот,
[36:47.660 --> 36:55.380]  вот у тебя и два пула получилось. А, ты хочешь сказать пул-аллокатор от шаблонного параметра N?
[36:55.380 --> 37:02.420]  В смысле, ты хочешь сделать пул-аллокатор от размера? Так тоже можно. Нет, ты сказал,
[37:02.420 --> 37:08.660]  сейчас давай сделаем, шаблонизируем пул. Параметром T и все. Что такое T? Какая разница тебе,
[37:08.660 --> 37:14.740]  какой тип тебе, размер лишь важен. Вот N шаблонного параметра тогда, а не от T. Размер не в смысле
[37:14.740 --> 37:21.820]  количество байтов, а в смысле размер блока, который мы собираемся выделять. Да, 10 или 25, да. Вот N, он, да.
[37:21.820 --> 37:40.780]  Ну, слушай, я не очень понимаю, что тебя смущает. Ну, типа даже если у меня есть, хорошо, ну даже
[37:40.780 --> 37:46.260]  если ты хочешь шаблонизировать пул и сказать, что у меня есть пул для 10 пул для 25 байтных кусков,
[37:46.260 --> 37:53.140]  почему я не могу захотеть два разных пула для 25 байтных кусков? Ну, то есть у меня там есть, не знаю.
[37:53.140 --> 38:04.580]  Как вы поймете, что это что нужно? Все что угодно можно написать. Можно написать с 2000 кубов.
[38:04.580 --> 38:08.940]  Как я отличу ситуацию, когда мне нужен второй пул от ситуации, когда…
[38:08.940 --> 38:19.820]  Ну, это какой-то очень общий вопрос, я не знаю, как на него ответить. Ну, кажется, что это должно
[38:19.820 --> 38:23.780]  быть понятно из контекста, когда тебе нужно новый, лучше новый пул завести, когда лучше старый
[38:23.780 --> 38:28.140]  доиспользовать. Это зависит от того, какой у тебя алгоритм управления памяти в этом пуле, например.
[38:28.140 --> 38:34.620]  Например, у тебя пул может быть таким, что ты вообще не освобождаешь, когда ты просто на Нью
[38:34.620 --> 38:40.260]  ты сдвигаешь право указатель, а на дилит ты ничего не делаешь. И ты просто пул заполняешь,
[38:40.260 --> 38:43.700]  зная, что он не привыкнет 100 тысяч никогда, а потом грохаешь, когда закончил он пользоваться.
[38:43.700 --> 38:51.020]  Когда тебе нужно, ты создаешь новый пул. Да, не удаляющий дилит. Именно такое вам надо написать,
[38:51.020 --> 39:00.540]  кстати. Вот, тебе такой пример устроит. То есть ты хочешь экономить время на вызовах New
[39:00.540 --> 39:09.260]  дилит. Ты делаешь этот пул таким, что ты просто как стэк его используешь. Ты выделил пул на миллион
[39:09.260 --> 39:14.460]  или миллиард и просто не освобождаешь никогда. Когда тебе говорят New, ты такой хоп, сдвинул на
[39:14.460 --> 39:19.460]  один. Когда дилит, ничего не делаешь. И когда у тебя все заканчивается, используешь, просто грохаешь
[39:19.460 --> 39:23.980]  весь пул. Очень быстро, очень эффективно. Потом ты в какой-то момент заводишь новый пул и еще раз его
[39:23.980 --> 39:39.700]  переиспользуешь. Пожалуйста. Два пула тебе нужного, одного и того же типа. Так, давайте я закончу то,
[39:39.700 --> 39:45.700]  что хотел рассказать здесь, потому что сейчас мы начинаем здесь дебри, который вообще уже немножечко
[39:45.700 --> 39:56.940]  не по порядку. Ну вот, пул и локатор. Вот, а вот еще пример локатора очень интересный. Ну, что такое
[39:56.940 --> 40:08.100]  пул? Ну, это такой большой-большой массив, ну или указательно большой массив, динамический. И, ну скажем,
[40:08.100 --> 40:12.740]  еще дополнительно к нему какой-нибудь там вектор, ну или какая угодно структура, которая описывает
[40:12.740 --> 40:18.460]  состояние пула. Может быть, это просто одно число, если ваш пул просто описывается местом последней
[40:18.460 --> 40:36.460]  локации. Ну, например, да, хорошо. Ну, я не хочу думать. Да, вот стеклокатор еще. Знаете, что такое
[40:36.460 --> 40:42.620]  стеклокатор? Вот смотрите, вот вы, я вам тут в самом начале говорил, что вот вы когда стринг
[40:42.620 --> 40:50.780]  заводите или вектор, у вас может даже и не быть такой ситуации, что вам не хватает стека, но все
[40:50.780 --> 40:57.100]  равно будет обращение к динамической памяти. А что если я точно знаю, что мой вектор, он не
[40:57.100 --> 41:02.940]  превзойдет, скажем, 100 тысяч элементов? И мне надо очень быстро, чтобы этот вектор работал. Я не хочу
[41:02.940 --> 41:09.340]  вызывать нью. Я не хочу делать реаллокации, я не хочу делать вот это все. Я хочу просто сделать
[41:09.340 --> 41:21.580]  вектор на стеке. Резерв мне сделает обращение к нью, а я хочу вектор на стеке, чтобы не обращаться
[41:21.580 --> 41:34.980]  к нью. Да, я хочу, чтобы это все было, вот как мне сделать, чтобы контейнер хранился на стеке. Ну ладно,
[41:34.980 --> 41:38.540]  вектор. Вектор не очень хороший пример. Вектор действительно один раз к нью можно сделать резерв
[41:38.540 --> 41:49.300]  и все. А давайте лист возьмем. Вот если я использую лист, стд-лист, на каждый пушбек там создается
[41:49.300 --> 41:56.380]  новый, там происходит новый вызов нью. И я никак не могу листу сказать резерв на 100 тысяч, правда же?
[41:56.380 --> 42:09.300]  Потому что так написано в стандарте. Ну нет, ну в смысле лист не приспособлен для этого. Для этого
[42:09.300 --> 42:15.740]  тебе нужно вообще пересмотреть свое отношение, свое понимание листа. Да, как раз аллокатор
[42:15.740 --> 42:20.820]  позволит это сделать. Как раз мы за счет того, что мы добавляем новый уровень абстракции, это аллокатор,
[42:20.820 --> 42:27.540]  мы теперь и лист можем сделать на стеке. Потому что с вектором это не так актуально, там действительно
[42:27.540 --> 42:32.140]  всего один вызов нью можно сделать, и один вызов дилит, если резерв написать. А вот с листом это очень
[42:32.140 --> 42:36.700]  даже актуально. Потому что стандартный лист, он работает медленно, там константа большая. Почему?
[42:36.700 --> 42:42.020]  Как раз потому что на каждый пушбек, у вас хоть оно и зовут единицы, но это каждый пушбек, это вызов
[42:42.020 --> 42:47.900]  нью новый. А это, в свою очередь, обращение к операционке, что-то там какое-то дело нет. Так почему вам,
[42:47.900 --> 42:52.860]  например, если вы знаете, что у вас лист будет всего на 100 тысяч интов, скажем, вы понимаете,
[42:52.860 --> 42:58.500]  что это точно уместится в 8 мегабайт стека вашего. Так давайте сделаем лист на стеке, и никакого
[42:58.500 --> 43:06.020]  нью, и вся память у вас просто вот тут прям вот в шаговой доступности. Тогда вам можно написать
[43:06.020 --> 43:12.900]  стек-аллокатор. Как добиться этого? Давайте напишем такой аллокатор, который будет, вот как сделать
[43:12.900 --> 43:23.220]  стек-аллокатор? Как мне сделать, чтобы лист на стеке выделялся? Да, я просто заведу локальный
[43:23.220 --> 43:29.020]  массив, то есть я в полях буду хранить массив, не динамический, а статистический, ну обычный массив.
[43:29.020 --> 43:35.900]  В полях кого? Хороший вопрос. Ну, очевидно, не самого аллокатора, потому что тогда у меня опять будет
[43:35.900 --> 43:41.380]  проблема, как его копировать. Если я напишу лист 1 равно лист 2, мне нужно просто завести класс,
[43:41.380 --> 43:58.780]  который я назову storage, и он будет некопируемым, но он не будет синглтоном, потому что я могу
[43:58.780 --> 44:05.340]  создать несколько стек-стораджей разных, но скопировать будет нельзя. Можно будет создать новый,
[44:05.340 --> 44:09.220]  это будет происходить тогда, когда я хочу создать новое семейство, скажем так, стек-аллокаторов.
[44:09.220 --> 44:17.980]  Вот копирование присваивания будет запрещено, в нем будет один массив в полях хранится огромный,
[44:17.980 --> 44:23.620]  там на миллион чаров, а эти, ну он допустим будет шаблонизирован параметром n, вот сколько там
[44:23.620 --> 44:30.860]  байт, скажем. А эти аллокаторы, когда я создаю новый стек-аллокатор, они такие, окей, если это новый
[44:30.860 --> 44:37.620]  аллокатор, то я заведу новый стек-сторадж, а если я копируюсь от старого аллокатора, то я, скажем,
[44:37.620 --> 44:45.820]  буду разделять с ним тот же самый стек-сторадж. Пожалуйста, и все. Ну а дальше allocate,
[44:46.340 --> 44:53.340]  ну как-то сделайте здесь. Например, простейший, тупейший пример, как я сказал, вы просто на allocate
[44:53.340 --> 44:58.660]  сдвигаете pointer здесь, а на allocate ничего не делаете. Таким образом вы максимально эффективно
[44:58.660 --> 45:02.820]  управляете памятью в предположении, что вы никогда не превзойдете суммарный качество памяти,
[45:02.820 --> 45:20.100]  используя вот такой констант. Вот. Ну и вот. Отличный вопрос, можно и новый создавать.
[45:20.100 --> 45:38.900]  Так тоже можно. Это зависит от твоих намерений. Можно делать указательно тот же, можно новый
[45:38.900 --> 45:49.660]  создавать. В STL есть средства, позволяющие правильно… Неважно, сейчас увидите, что там есть. Окей. Все
[45:49.660 --> 46:00.460]  по идее. Я рассказал про аллокатор, про то, какие в принципе могут быть нестандартные аллокаторы.
[46:00.460 --> 46:09.700]  Теперь давайте поговорим про аллокатор trades. Наверное, это будет короткий пункт. Вот смотрите.
[46:09.700 --> 46:19.700]  Слушайте, нет, я передумал. Давайте не так сделаем. Давайте сначала поговорим про
[46:19.700 --> 46:36.060]  аллокатор aware containers. Мне кажется, это более важно обсудить. Аллокатор aware containers. Так,
[46:36.060 --> 46:44.980]  что такое… Вот есть аллокаторы. Теперь надо подумать, как правильно использовать аллокаторы
[46:44.980 --> 46:51.340]  в разных контейнерах. Какие тут есть проблемы? Вот сейчас как раз давайте обсудим, во-первых,
[46:51.340 --> 47:02.740]  как правильно копировать аллокаторы. Первый вопрос. Когда копируется вектор, скажем, нужно ли
[47:02.740 --> 47:16.180]  копировать аллокатор? Или нужно просто создать новый инстанс, аллокатор такого же типа? Да,
[47:16.180 --> 47:23.620]  вопрос на понимание. Вы же понимаете, что вектор от T, STD-аллокатор и вектор от T,
[47:23.620 --> 47:32.860]  pull-аллокатор. Вопрос не стоит о том, как одному другое прислоить. Потому что это не CE, это разные
[47:32.860 --> 47:45.180]  типы. Ну а что вы хотели? Ну вот как раз для этого и придумали polymorphic allocator tag,
[47:45.180 --> 47:57.780]  если что, чтобы векторы от разных аллокаторов не были несовместимыми типами. BDS-STL. Но пока это
[47:57.780 --> 48:04.180]  разные типы для нас. То есть, если у вас контейнер типа аллокатора, это разные типы контейнера,
[48:04.180 --> 48:08.060]  вы не можете один другому присвоить. Поэтому мы не задаемся вопросом, что делать, если у нас
[48:08.060 --> 48:14.260]  вопрос CE будет. А вот если у нас есть вектор от T и какой-то аллокатор, и мы хотим пронициализировать
[48:14.300 --> 48:21.220]  его вектором от такого же T, но другого, такого же аллокатора, то есть тип такой же, но объект
[48:21.220 --> 48:28.180]  аллокатора там уже какой-то есть другой. Есть два варианта. Вот кто, ты да, говорил или кто-то из
[48:28.180 --> 48:33.980]  вас говорил, что можно пронициализировать аллокатор копией того аллокатора, наш аллокатор,
[48:33.980 --> 48:43.140]  а можно проинitiциализировать аллокатор новым аллокатором такого типа как там.
[48:43.140 --> 48:58.900]  Да, но есть еще более, короче, в STL все еще несколько хитрее.
[48:58.900 --> 49:08.940]  Можно в аллокаторе, в реализации самого аллокатора указать, что должен делать
[49:08.940 --> 49:16.780]  контейнер, когда копируется аллокатор. Вот, и для этого в аллокаторе можно определить метод,
[49:16.780 --> 49:21.100]  который называется SELECT ON CONTAINER COPY CONSTRUCTION.
[49:21.100 --> 49:38.060]  SELECT ON CONTAINER COPY CONSTRUCTION.
[49:38.060 --> 49:50.060]  Ну, в зависимости от того, какой у вас аллокатор, вы можете хотеть, чтобы вектор при копировании
[49:50.060 --> 50:05.260]  себя либо копировал аллокатор, либо создавал новый. Нет, почему? Новый аллокатор – это считайте,
[50:05.260 --> 50:16.580]  вы новый пул завели и все отдельно работает. Нет, аллокатор об этом не забудь. Новый аллокатор – это
[50:16.580 --> 50:24.180]  с чистого листа все пул начался строить. А вот дальше уже, когда сам вектор будет
[50:24.180 --> 50:29.900]  непосредственно копировать, поле аллокатор, чем-то надо проинциализировать. Мы проинциализировали
[50:29.900 --> 50:35.940]  не копии того аллокатора, а новым таким же аллокатором. А дальше началось, собственно,
[50:35.940 --> 50:40.900]  поэлементное копирование вектора. А оно из себя представляет поэлементный allocate и construct.
[50:40.900 --> 50:45.980]  Но вот этот аллокатор новый уже будет делать allocate-construct на новом пуле тех элементов
[50:45.980 --> 51:05.180]  вектора, который он себя начнет копировать. В общем, честно говоря, выглядит как-то стрёмно.
[51:05.180 --> 51:13.020]  Я даже не могу сходу сказать, чем это плохо, но просто, не знаю, какое-то вот житейское чутье
[51:13.020 --> 51:17.740]  подсказывает, что так лучше не делать. То есть ты хочешь оператору присваивания дать какую-то
[51:17.740 --> 51:38.540]  нестандартную семантику. Хорошо, давайте я вам задам такой вопрос. Ничего она не принимает,
[51:38.540 --> 51:55.940]  возвращает аллокатор. Ну, она либо возвращает этот аллокатор, то есть тут варианты какие,
[51:55.940 --> 52:02.780]  вы можете написать либо return this, либо return, пустой просто аллок, без параметров,
[52:02.780 --> 52:10.620]  ну или с какими-то там параметрами. Внутри аллокатора, да, это метод аллокатора,
[52:10.620 --> 52:18.140]  который может у него быть, а может и не быть. Как и construct и destroy, они могут как присутствовать,
[52:18.140 --> 52:21.820]  так и отсутствовать в аллокаторе. Вот в ваших аллокаторах вам не надо будет, скорее всего,
[52:21.820 --> 52:32.140]  определять construct и destroy. Ну да ладно, следующий вопрос. Вот смотрите,
[52:32.140 --> 52:46.740]  аллокаторы иногда можно сравнивать на равенство.
[52:46.740 --> 53:01.260]  А вот зачем. Потому что контейнер, когда копируется, он как раз проверяет, равны ли
[53:01.260 --> 53:06.060]  аллокаторы. Дело в том, что если аллокаторы уже равны, то не надо копировать и новый создать
[53:06.060 --> 53:13.580]  тоже не надо. Нет, ну хорошо, если там selected-container, copy-construction возвращает новый аллокатор,
[53:13.580 --> 53:21.020]  то нужно все равно создать новый аллокатор. Но если selected-container, copy-construction возвращает
[53:21.020 --> 53:27.500]  тот же самый аллокатор, возвращает аллокатор, равный тому, а наш аллокатор уже равен тому,
[53:27.500 --> 53:35.940]  то кажется, что наш аллокатор можно не копировать. Ну тебе не обязательно копировать аллокатор,
[53:35.940 --> 53:42.700]  если твой аллокатор уже равен тому. Ты копируешь контейнер. Если твой аллокатор уже равен тому
[53:42.700 --> 53:55.740]  аллокатору, ты присваиваешь. Надо ли тебе подменить аллокатор, вот вопрос. Да, виноват.
[53:55.740 --> 54:00.740]  Когда вы конструируете новый вектор из другого вектора, этот вопрос не стоит. У вас есть функция
[54:00.740 --> 54:04.100]  container-copy-construction, которая говорит вам новый аллокатор создать или тот, который вы используете.
[54:04.100 --> 54:08.860]  Допустим, вы присваиваете один вектор другому, и вам нужно решить, вам нужно подменять ваш
[54:08.860 --> 54:15.740]  аллокатор на тот или не нужно. Как вам это понять? А вам можно проверить, а равны ли эти аллокаторы
[54:15.740 --> 54:25.300]  уже или нет? То есть у аллокаторов вообще должен быть оператор равно-равной еще, чтобы контейнер,
[54:25.300 --> 54:34.180]  контейнеру иногда нужно понимать, равны ли аллокаторы. А что вообще, ну например, когда они равны как раз,
[54:34.180 --> 54:43.180]  а что значит, что они равны? Это вот что такое для аллокаторов? Все стандартные аллокаторы равны,
[54:43.180 --> 54:54.540]  но некоторые более равны, чем другие. Да, правильно. Вот это как раз важная мысль. Давайте назовем наши
[54:54.540 --> 55:09.980]  аллокаторы равными, если как раз они общий пул разделяют. То есть если у нас, что значит, что наш
[55:09.980 --> 55:18.140]  аллокатор равен какому-то другому аллокатору? Это значит, что можно, вообще говоря, ну, наверное,
[55:18.140 --> 55:24.740]  можно даже не в терминах контейнеров. Вы же можете, не обязательно внутри контейнера это делать. Вы
[55:24.740 --> 55:30.020]  просто можете, ну е-мое, вы можете какую-нибудь функцию написать свою, которая с аллокатором работает
[55:30.020 --> 55:34.820]  без контейнера, без всякого. Вот вы передали аллокатор функцию, и там, я не знаю, что-то поделали,
[55:34.820 --> 55:41.380]  создали новый локальный аллокатор из того, ну и так далее. Вы иногда хотите понять, вот этот аллокатор
[55:41.380 --> 55:47.620]  это то же самое, что другой аллокатор или нет? А что означает то же самое? А это означает, что то,
[55:47.780 --> 55:51.580]  что было выделено первым аллокатором, можно освободить вторым аллокатором. Вот что это означает на
[55:51.580 --> 55:58.900]  самом деле. Вот эта важная мысль. Надо понять это, два аллокатора считаются равными, если то, что
[55:58.900 --> 56:06.060]  выделено одним из них, можно освободить другим. Это как раз в наших терминах означает, что они общий
[56:06.060 --> 56:13.820]  пул, например, разделяют. Два аллокатора равными считаются, если то, что выделено одним из них,
[56:13.820 --> 56:22.140]  можно освободить с помощью другого из них нет если как раз они могут быть вот
[56:22.140 --> 56:28.900]  астд локаторы всегда равны друг другу что кто не делает пределите они делают
[56:28.900 --> 56:33.460]  что-то они не вызывают дилет честный они не освобождают править с мыслью что ее нельзя
[56:33.460 --> 56:37.180]  будет еще раз занять как это называется локатор который ничего не делает
[56:37.180 --> 56:43.420]  пределить вот всего ничего прямого ничего может например счетчик плюс один сделать
[56:43.420 --> 56:59.940]  ну нет пул локатор это не тот который ничего делать при удалении это тот
[56:59.940 --> 57:04.700]  который большой пул заводит им распоряжается стека локатор это ну наверное
[57:04.700 --> 57:08.900]  можно сказать что частный случай пул локатора когда у вас пул на стеке вот
[57:09.080 --> 57:14.920]  пул локатор не название пул локатор ничего не говорит о том какой у вас
[57:14.920 --> 57:18.020]  алгоритм менеджмента памяти тул просто говорит о том что вы большим
[57:18.020 --> 57:21.260]  полом распоряжаетесь вы можете как ничего не делать пределите и тогда
[57:21.260 --> 57:26.360]  возможно и правда у вас все локаторы можно считать равными я не уверен может
[57:26.360 --> 57:29.880]  есть кое-что случая который меня забыло может лучше все-таки так не делать но
[57:29.880 --> 57:33.900]  логично их все-таки не считать равными если там пулы разные ну просто по логике
[57:33.900 --> 57:38.340]  вещей вот но возможно если у вас что-то делается там какая-то машинеть и
[57:38.340 --> 57:43.140]  происходит, когда вы освобождаете, то, конечно, нужно считать их неравными, если на разные полы указывают.
[57:51.700 --> 57:57.800]  Любому другому аллокатору такого же типа. Нет, нельзя сравнивать аллокаторы разных типов.
[57:58.980 --> 58:00.980]  Неопределенная операция.
[58:01.620 --> 58:08.060]  Конечно. Нет, ты можешь сравнить аллокатор, ты можешь сравнить std аллокатор от t и std аллокатор от u,
[58:08.340 --> 58:10.340]  вот так, скорее всего, можно сделать.
[58:16.100 --> 58:20.020]  Нет, я думаю, вы получите true, но это это неважно.
[58:20.220 --> 58:27.780]  Вы можете, наверное, если у вас аллокаторы одинаковые, но разных шаблон-типов, тут еще можно как-то, если у вас std аллокатор и std аллокатор,
[58:27.780 --> 58:30.580]  то их нельзя сравнивать просто потому, что это разные типы.
[58:31.460 --> 58:34.420]  Нет, ну, может быть, можно определить оператор сравнений так, что они будут...
[58:35.380 --> 58:40.180]  Может быть, можно определить оператор сравнений для них так, чтобы они были разными, но я не знаю, кто в здравом уме должен
[58:40.460 --> 58:45.460]  захотеть сравнивать аллокаторы разных типов. Это, кажется, просто должна быть неопределенная операция.
[58:46.900 --> 58:52.740]  Но если вы сравните два аллокатора одного типа, например, два стека аллокатора, то как раз вот их сравнение, должны говорить, это у вас
[58:53.620 --> 58:55.620]  один и тот же пул или нет.
[58:55.620 --> 58:57.620]  Это должно быть, просто логично.
[58:57.620 --> 58:59.620]  Ну, это логично, да.
[58:59.620 --> 59:01.620]  Зачем сравните аллокаторы?
[59:01.620 --> 59:07.620]  Когда мы копируем вектор, мы хотим избежать как-то от любого копирования, если они уже равны.
[59:09.620 --> 59:11.620]  Если аллокаторы равны.
[59:11.620 --> 59:15.620]  Если два аллокатора пользуются одним и тем же аллокатором, то нет смысла копировать.
[59:15.620 --> 59:17.620]  Это лучше идея, когда у нас лист все-таки...
[59:17.620 --> 59:21.620]  Но все равно, если мы скажем, вектор A равен вектор B,
[59:21.620 --> 59:25.620]  аллокатор будет составиться таким же, то есть надо его посмотреть.
[59:25.620 --> 59:27.620]  Но все равно элементы копируются.
[59:27.620 --> 59:29.620]  Да.
[59:29.620 --> 59:33.620]  Сейчас, а нам же лучше предоставить контейнер, как контракт называть, или не придется?
[59:33.620 --> 59:35.620]  Нет, при присваивании не придется.
[59:35.620 --> 59:37.620]  А если он говорит, что мы всегда...
[59:37.620 --> 59:39.620]  В смысле, не придется?
[59:39.620 --> 59:41.620]  Это только констракшн.
[59:41.620 --> 59:43.620]  Да, точно.
[59:47.620 --> 59:51.620]  Это когда мы создаем контейнер копированием другого контейнера.
[59:51.620 --> 59:57.620]  Когда мы говорим, новый вектор равно старый вектор, создаем новый вектор.
[59:57.620 --> 01:00:03.620]  Нам нужно решить, для нового вектора позаимствовать аллокатор из того вектора или создать новый.
[01:00:03.620 --> 01:00:09.620]  Вот эта функция у аллокатора помогает понять, что из этого делать.
[01:00:09.620 --> 01:00:13.620]  Если она есть, то он вызовет ее.
[01:00:13.620 --> 01:00:19.620]  А если ее нет, то он стандартным способом себя поведет и скопирует аллокатор.
[01:00:19.620 --> 01:00:25.620]  А вот когда мы присваиваем вектор другому, и пусть мы поняли, что это неравный, мы все равно туда поделимся, как контейнер.
[01:00:25.620 --> 01:00:27.620]  Кто? Аллокаторы неравны?
[01:00:27.620 --> 01:00:33.620]  Нет, если аллокаторы неравны, то мы такого не вызовем.
[01:00:33.620 --> 01:00:37.620]  Нет, мы скопируем аллокаторы, я думаю.
[01:00:37.620 --> 01:00:39.620]  При присваивании.
[01:00:39.620 --> 01:00:41.620]  При присваивании.
[01:00:41.620 --> 01:00:43.620]  Это не совсем правда, потому что есть еще одна функция.
[01:00:43.620 --> 01:00:45.620]  Правда, она уже не у аллокатора.
[01:00:45.620 --> 01:00:49.620]  Есть такая функция, пропагейтон контейнер копи ассайнмент.
[01:00:55.620 --> 01:00:57.620]  Сейчас я расскажу.
[01:00:57.620 --> 01:00:59.620]  Но не в этом пункте.
[01:00:59.620 --> 01:01:07.620]  Пока давайте считать, что при присваивании контейнеров мы всегда копируем аллокаторы, если только у них аллокаторы неравны уже.
[01:01:07.620 --> 01:01:11.620]  У меня есть еще один важный вопрос.
[01:01:11.620 --> 01:01:17.620]  Смотрите, мы с вами пишем лист на аллокаторе.
[01:01:17.620 --> 01:01:23.620]  А, да, я забыл сказать, что такое аллокаторы веер контейнерства.
[01:01:23.620 --> 01:01:31.620]  Аллокаторы веер контейнер – это такой контейнер, который правильно использует все эти методы аллокатора.
[01:01:31.620 --> 01:01:37.620]  Это контейнер, заботящийся об аллокаторе, уважающий аллокатор.
[01:01:37.620 --> 01:01:43.620]  Если контейнер считается аллокатором веер, все стандартные контейнеры, разумеется, такие.
[01:01:43.620 --> 01:01:49.620]  Если они не просто тупо копируют аллокатор, а смотрят на соответствующие методы аллокатора,
[01:01:49.620 --> 01:01:55.620]  на соответствующие свойства аллокатора, и либо копируют его, либо не копируют, в зависимости от того, что там написано.
[01:01:55.620 --> 01:02:03.620]  Вы можете открыть на CVP Reference статью, если бы у меня был проектор, я бы вам сейчас открыл ее и мы бы на нее посмотрели.
[01:02:04.620 --> 01:02:10.620]  Вы можете открыть статью C++NamedRequirements Allocator-Aware-Container.
[01:02:10.620 --> 01:02:24.620]  И там написано, какие требования накладываются на контейнер, чтобы он считался Allocator-Aware-Container.
[01:02:24.620 --> 01:02:36.620]  Разумеется, как раз главная суть вашей задачи и будет заключаться в том, чтобы написать Allocator-Aware-Container, да еще и который бы правильно работал с вашим аллокатором.
[01:02:36.620 --> 01:02:39.620]  Ровность до аллокатора готова.
[01:02:39.620 --> 01:02:42.620]  Нет, в смысле равн...
[01:02:42.620 --> 01:02:46.620]  Значит, в чем будет заключаться ваша задача первая?
[01:02:46.620 --> 01:02:52.620]  У вас будет задача написать лист и стек аллокатор.
[01:02:52.620 --> 01:03:00.620]  При этом как лист должен быть совместим с любым аллокатором правильно написанным, то есть лист должен быть Allocator-Aware.
[01:03:00.620 --> 01:03:05.620]  Я могу подсунуть туда любой корректный аллокатор, и все должно правильно работать.
[01:03:05.620 --> 01:03:11.620]  Так и аллокатор должен быть STL совместим, то есть удовлетворять требованиям Allocator.
[01:03:11.620 --> 01:03:15.620]  Кстати, Allocator это тоже понятие из C++NamedRequirements.
[01:03:15.620 --> 01:03:20.620]  Там перечислено, что должен уметь аллокатор, чтобы считаться полноправным аллокатором.
[01:03:20.620 --> 01:03:25.620]  То есть в тестах я буду делать следующие вещи.
[01:03:25.620 --> 01:03:31.620]  Я буду брать стандартный контейнер с вашим аллокатором, разные стандартные контейнеры с вашим аллокатором, проверять, что все правильно,
[01:03:31.620 --> 01:03:35.660]  А ещё я буду брать ваш контейнер с разными аллокаторами, с вашим.
[01:03:35.660 --> 01:03:38.620]  Ну, с вашим и с стандартным, и возможно еще с каким нибудь.
[01:03:38.620 --> 01:03:40.620]  И тоже проверять, что все правильно.
[01:03:40.620 --> 01:03:42.620]  С South event-илист Harrison Ex inspect?
[01:03:42.620 --> 01:03:44.620]  С давших прошлые годы, например.
[01:03:44.620 --> 01:03:56.620]  Так вот, у меня к вам вопрос такой очень важный, о котором вы возможно сейчас не задумались, но вы неизбежно столкнетесь с этой проблемой, когда будете писать лист.
[01:03:57.620 --> 01:04:09.620]  Смотрите, лист, он же тоже имеет такую… Ну, что такое лист? У него есть шаблонные параметры.
[01:04:09.620 --> 01:04:26.620]  TypeName t, TypeName alloc, я не полюнюсь даже еще раз написать, равно std allocator, пока я пишу, вы возможно уже сейчас заподозрите подвох, проблему.
[01:04:26.620 --> 01:04:43.620]  std allocator от t. Класс, лист. Вас ничего не смущает здесь? Вот в этом вот месте вас ничего не смущает.
[01:04:43.620 --> 01:05:03.620]  А как вы будете в листе пользоваться allocator? Нет, минуточку. А как лист устроен, напомните? Там нужно node, да. А как вы будете node выделять?
[01:05:03.620 --> 01:05:21.620]  У вас же allocator от t, а не от node. А про node пользователи ничего не знают, он вам передает allocator от t.
[01:05:21.620 --> 01:05:37.620]  Значит, на самом деле лист хранит в себе allocator тоже как поле, но не такого типа. Да, он должен создать allocator, но не такой. А он должен создать allocator как этот, но не от t, а от того, чему надо.
[01:05:37.620 --> 01:05:55.620]  И вот это, скажем так, еще одна из причин, по которым комитет понял, что что-то пошло не так, когда вот это случилось.
[01:05:55.620 --> 01:06:14.620]  А можно написать aloc равно st allocator, а потом aloc и фигурка с кубочек от чего-то создать? Что, где написать что? А, в смысле сделать aloc шаблонным-шаблонным параметром?
[01:06:14.620 --> 01:06:31.620]  В смысле aloc равно st allocator около st или как? Ну, то есть ты хочешь делать aloc шаблонным параметром, который сам шаблон. То есть ты хочешь написать typename t, запитать template с кубочках typename aloc равно st allocator.
[01:06:31.620 --> 01:06:44.620]  Да, это очень классный вопрос на самом деле. Это вообще очень классный вопрос. Очень умный вопрос, и ответ на него нельзя, и вот нужно понять почему.
[01:06:44.620 --> 01:06:54.620]  То есть это классная очень мысль, это гениальная мысль вообще. Ты молодец. Но нельзя, к сожалению. Это могло бы быть выходом из положения, но нет, это не работает.
[01:06:54.620 --> 01:07:04.620]  Ты знаешь почему? Потому что тогда не получалось бы создавать aloc от большего чем один числа шаблонных параметров.
[01:07:04.620 --> 01:07:14.620]  Ну, например, st allocator у него, наверное, должно быть два шаблонных параметра t, а еще n, который вот это вот n обозначает здесь.
[01:07:14.620 --> 01:07:26.620]  Если у меня aloc принимает два шаблонных параметра, этот вопрос на stackoverflow я читал все время, потому что пару лет назад тоже я сам задумался, а почему бы так не сделать?
[01:07:26.620 --> 01:07:37.620]  Ну вот нельзя, потому что тогда вы бы тем самым сразу запретили, у вас просто синтоксически бы получился template typename, фигурная угловая скобка закрылась, и вот это вот.
[01:07:37.620 --> 01:07:47.620]  Оно бы позволяло вам передавать в качестве alocator в этот контейнер только alocators с одним шаблонным параметром, а если у вас был alocator с двумя шаблонным параметром, его бы сюда не отдали.
[01:07:47.620 --> 01:08:01.620]  Впрочем, конечно, бывают же шаблоны с переменным количеством шаблонных аргументов, но тогда их еще не было.
[01:08:01.620 --> 01:08:07.620]  А теперь уже все, это не переделали, и в общем оно так и осталось.
[01:08:07.620 --> 01:08:12.620]  Казалось бы, действительно, это самое место применить, а лучше делать шаблонный параметр, но нет.
[01:08:12.620 --> 01:08:22.620]  Так вот, так что я должен сделать здесь? Я должен здесь, давайте я сотру и здесь напишу, что я должен сделать полем моего листа.
[01:08:22.620 --> 01:08:40.620]  Я должен какой-то магией своим полем сделать не вот этот вот aloc, а alocator такого же типа как этот, но с другим подставленным типом t, node вместо.
[01:08:40.620 --> 01:08:47.620]  То есть у меня есть внутренняя структура node, тут вот что-то в ней есть.
[01:08:52.620 --> 01:09:18.620]  Как мне сказать, как мне объявить alocator? Ну, тут ничего лучше нельзя предложить, просто у alocator еще есть метод, должен быть, метод, точнее meta-метод rebind.
[01:09:18.620 --> 01:09:25.620]  Значит alocator предоставляет такую метафункцию rebind.
[01:09:25.620 --> 01:09:48.620]  Значит внутри alocator, внутри alocator вот тут, вот тут вот еще есть template type name struct rebind,
[01:09:48.620 --> 01:10:05.620]  в которой написано using other равно, ну да, std alocator от u.
[01:10:05.620 --> 01:10:25.620]  И на самом деле в листе написано примерно следующее, тут написано using, а node aloc равно type name, потому что у нас dependent name сейчас будет,
[01:10:25.620 --> 01:10:47.620]  aloc rebind от u, rebind от node other и заводим мы здесь node aloc, node aloc мы храним.
[01:10:47.620 --> 01:11:09.620]  Разумеется. Вот, а теперь, отвечая на все эти вопросы, я как раз последний, видимо, пункт, который мы сегодня успеем следить, это 9.3, как раз вот теперь я расскажу, что такое alocator traits.
[01:11:09.620 --> 01:11:29.620]  Как вы могли заметить, мы уже много всего напридумывали методов alocator, в том числе meta-методов, которые, к чему это, как будто что-то плохое, это норма, привыкай к этому.
[01:11:29.620 --> 01:11:43.620]  Ну, не хочешь, заставим. Значит, ладно, alocator traits. Что такое alocator traits? Вы, наверное, можете догадаться по аналогии с итератор traits.
[01:11:43.620 --> 01:11:50.620]  Это такая структура, которая доопределяет за alocator все то, что он забыл или не захотел определять сам.
[01:11:50.620 --> 01:12:01.620]  В частности, construct, destroy, rebind, select-on-container, copy-construction, еще много чего. Это работает также как итератор traits.
[01:12:01.620 --> 01:12:16.620]  То есть на самом деле методы construct, destroy, вот эту вот структуру rebind можно не реализовывать в своем alocator, потому что alocator traits за вас доопределит.
[01:12:16.620 --> 01:12:28.620]  Вот так. Что? construct, да, определит вот именно так. rebind определит именно так, только здесь вместо std alocator будет ваш alocator написан.
[01:12:28.620 --> 01:12:41.620]  Что именно сделает? Так он же с шаблонным параметром alocator, как и итератор traits, с шаблонным параметром итератор.
[01:12:41.620 --> 01:12:53.620]  Значит, есть такая структура std alocator traits, объект этой структуры никогда не создается, и все, что в ней есть, это много разных юзингов.
[01:12:53.620 --> 01:13:00.620]  Ну нет, хорошо, неправда, в ней есть много юзингов, а еще много методов, но это все статические методы.
[01:13:00.620 --> 01:13:27.620]  Например, в ней есть метод construct. Он выглядит так, template, type name, многоточие args, void construct, static void, уже он статический, потому что объекты alocator traits не создаются никогда.
[01:13:27.620 --> 01:13:46.620]  Статик void construct. И он принимает, а что он принимает? Он принимает alocator, а еще аргументы, ну ptr и аргументы.
[01:13:46.620 --> 01:14:09.620]  Ну вот здесь мы принимаем только ptr и аргументы, а в traits мы должны принимать alocator, ptr и аргументы. Причем alocator мы принимаем как? По ссылке, по константной или нет? Нет, не по константной, потому что alocator вообще говоря мог бы поменяться от того, что вызвали construct.
[01:14:09.620 --> 01:14:36.620]  Вот aloc, t, звездочка, ptr. Правильный вопрос. Сейчас скажу, что такое t звездочка. t звездочка на самом деле это type name aloc, . . . value type. А вот value type уже обязан быть определен.
[01:14:36.620 --> 01:14:59.620]  Значит в alocator еще должен быть, я вижу вот выражение лица. Звездочка, ptr.
[01:14:59.620 --> 01:15:25.620]  Ну, Андрей Михайлович ждет вас на кафедре DM в таком случае. Вы думали, а вы думали, зачем я тут работаю? Я сам кафедру DM заканчиваю между прочим. Тайная агента на самом деле. Я же говорил, я же вам в самом начале совместно сказал, в чем цель этого курса. Вы еще не до конца поняли, сейчас поймете до конца.
[01:15:29.620 --> 01:15:41.620]  Вот так. Что делает этот метод? А что он делать должен? Что делает эта функция?
[01:15:41.620 --> 01:15:56.620]  Она должна понять, есть ли у alocator то, что она знает. Точно. Значит здесь нужно написать следующее. Надо написать, если у alocator есть метод construct с такими вот параметрами, то вызвать его, а иначе сделать вот это.
[01:15:56.620 --> 01:16:15.620]  Как мы пишем их? Авто-авто-авто компилятор сам догадается. Вот. Ну как это реализовать мы пока не понимаем и поймем мы это ближе к концу семестра, когда изучим шаблонный метод программирования чуть поглубже.
[01:16:15.620 --> 01:16:27.620]  Да-да-да. Ну там проверка по сочетанию метода. Ну то есть вот здесь фактически написано именно это. Тут на шаблонах написано проверка существует ли метод у такого-то класса с такими-то аргументами.
[01:16:27.620 --> 01:16:35.620]  Точно так же как и в Iterator Trades. Iterator Trades определяет за вас категории итератора в зависимости от того, какие методы у вас определены, от каких типов. То же самое здесь.
[01:16:35.620 --> 01:16:46.620]  Но Iterator Trades гораздо сложнее, чем здесь. Здесь просто один if условно, говоря, надо написать. Как его написать мы пока не понимаем. Сейчас я вам этого не расскажу, но потом мы скоро мы поймем когда-то.
[01:16:46.620 --> 01:16:54.620]  Вот пока вот тут вот написана какая-то магия, которая вызывает construct у allocator, если он есть, от нужных аргументов. Если нет, делает сама вот это.
[01:16:54.620 --> 01:17:14.620]  Аналогично destroy. Она либо вызывает у allocator метод destroy, если он был, либо сама вызывает destructor t. Дальше, что делает destructor t еще не всегда надо вызывать, потому что value type может быть не классом, а int.
[01:17:14.620 --> 01:17:22.620]  И вызвать destructor int будет ce. Поэтому нужно еще сделать дополнительно проверку, а классовый или тип, тот t, который у нас.
[01:17:22.620 --> 01:17:38.620]  Вот. Дальше. SelectionContainerCopyConstruction. То же самое. Она проверяет, есть ли у allocator метод SelectionContainerCopyConstruction. Если есть, то возвращает то, что он возвращает, а иначе просто возвращает allocator, который сюда дали в параметры без изменений.
[01:17:38.620 --> 01:17:46.620]  А когда мы пишем какой-то контейнер, мы должны не вызывать метод construct?
[01:17:46.620 --> 01:18:03.620]  Совершенно верно. Совершенно верно. И именно поэтому я вам говорил, когда писал здесь, что не совсем это там написано. Помните, когда я написал, что там было alloc.allocate, я сказал, ну там не совсем это, скоро поймем почему. Вот сейчас мы поняли почему.
[01:18:03.620 --> 01:18:18.620]  Все методы, все методы вызываются через allocator trades.
[01:18:18.620 --> 01:18:32.620]  Нет, нет, нет, нет. allocator trades, метод allocate у allocator trades просто вызывает метод allocate у allocator. Но в целях унификации считается правильным все методы вызывать через allocator trades.
[01:18:32.620 --> 01:18:38.620]  Но в случае allocator trades без разницы, действительно. В случае allocate без разницы. Allocator обязан иметь метод allocate.
[01:18:38.620 --> 01:18:47.620]  Allocator trades ничего не добавляет allocate, он просто, так сказать, прослойкой служит для его вызова. Но вот construct и destroy так явно не вызывают allocator.
[01:18:47.620 --> 01:18:58.620]  Если вы их вызовете, вообще это будет CE, начиная с C++20. Потому что на самом деле этих методов уже нет в стандартном allocator, начиная с C++20. Вот этого всего нет в std allocator, начиная с C++20.
[01:18:58.620 --> 01:19:06.620]  Они теперь allocator trades, потому что никто напрямую к allocator эти методы не вызывает.
[01:19:06.620 --> 01:19:17.620]  Все так, все так.
[01:19:17.620 --> 01:19:29.620]  Все правильно, да. Нет, ну скорее всего вы пишете using alloc trades равно std allocator trades от node alloc.
[01:19:29.620 --> 01:19:41.620]  Вот, и да. Теперь, что вместо rebind? В allocator trades есть внутренняя структура, которая называется rebind alloc.
[01:19:41.620 --> 01:19:47.620]  rebind alloc. Значит структура rebind alloc.
[01:19:47.620 --> 01:19:49.620]  Почему это звали rebind?
[01:19:49.620 --> 01:19:51.620]  Ну не знаю, почему-то вот...
[01:19:51.620 --> 01:19:53.620]  Analyzer allocator trades.
[01:19:53.620 --> 01:20:01.620]  Потому что Analyzer allocator trades, да. rebind alloc от U. Да, ну, template type name понятно тут.
[01:20:01.620 --> 01:20:03.620]  И тут написано using...
[01:20:03.620 --> 01:20:07.620]  Нет, на самом деле это не структура даже, извините. Вот как раз почему это не структура.
[01:20:07.620 --> 01:20:09.620]  Потому что это using.
[01:20:09.620 --> 01:20:15.620]  Это using rebind alloc.
[01:20:15.620 --> 01:20:17.620]  Там U.
[01:20:17.620 --> 01:20:21.620]  Это просто вот та самая вещь.
[01:20:21.620 --> 01:20:23.620]  Ну как?
[01:20:23.620 --> 01:20:25.620]  Так же.
[01:20:25.620 --> 01:20:27.620]  Если в allocator есть rebind, то...
[01:20:27.620 --> 01:20:29.620]  Ну тут шаблонная магия.
[01:20:29.620 --> 01:20:31.620]  Типа в allocator есть rebind.
[01:20:31.620 --> 01:20:35.620]  Ну тут типа std conditional, грубо говоря.
[01:20:35.620 --> 01:20:39.620]  Если в allocator есть rebind и в нем есть other, то это он.
[01:20:39.620 --> 01:20:47.620]  А иначе это вот этот allocator от U.
[01:20:47.620 --> 01:20:51.620]  Ну просто вот этот allocator, от которого мы сейчас, allocator trades.
[01:20:51.620 --> 01:20:53.620]  От U.
[01:20:53.620 --> 01:20:55.620]  Вот.
[01:20:55.620 --> 01:20:57.620]  Сейчас, почему один параметр?
[01:20:57.620 --> 01:21:01.620]  Так, один параметр, другой тип.
[01:21:01.620 --> 01:21:03.620]  Сейчас, не-не-не.
[01:21:03.620 --> 01:21:07.620]  Ребайн alloc он где определяет?
[01:21:07.620 --> 01:21:09.620]  А...
[01:21:09.620 --> 01:21:11.620]  Возможно...
[01:21:11.620 --> 01:21:13.620]  Он понимает alloc, значит он после alloc должен быть.
[01:21:13.620 --> 01:21:15.620]  Он понимает...
[01:21:15.620 --> 01:21:19.620]  Ты прав. Здесь должно быть U и еще arcs.
[01:21:19.620 --> 01:21:21.620]  Что?
[01:21:21.620 --> 01:21:23.620]  Но allocator может быть от многих параметров.
[01:21:23.620 --> 01:21:25.620]  Потому что...
[01:21:25.620 --> 01:21:29.620]  Первый из них это тип, а еще могут быть сколько угодно дополнительных параметров.
[01:21:29.620 --> 01:21:31.620]  Уже с типом или шаблонный тип?
[01:21:31.620 --> 01:21:33.620]  Или шаблонный allocator?
[01:21:33.620 --> 01:21:35.620]  В смысле?
[01:21:35.620 --> 01:21:39.620]  Я согласен с allocator.
[01:21:39.620 --> 01:21:41.620]  Чего?
[01:21:41.620 --> 01:21:45.620]  То есть allocator это alloc, alloc это что?
[01:21:45.620 --> 01:21:47.620]  Alloc это, конечно, определенный allocator.
[01:21:47.620 --> 01:21:49.620]  А как мы тогда...
[01:21:49.620 --> 01:21:53.620]  Условно, я не знаю, развиваются тип и другой тип?
[01:21:53.620 --> 01:21:55.620]  Шаблонные магии, друг!
[01:21:55.620 --> 01:21:57.620]  Я не очень понял.
[01:21:57.620 --> 01:21:59.620]  Что именно мы делаем?
[01:21:59.620 --> 01:22:01.620]  Что мы там можем написать? Мы можем написать alloc?
[01:22:01.620 --> 01:22:03.620]  А, я понял, да, я понял. Проблему.
[01:22:03.620 --> 01:22:07.620]  Шаблонные магии, два этих принимают.
[01:22:07.620 --> 01:22:09.620]  Два типа.
[01:22:11.620 --> 01:22:15.620]  А он не может дать без подставы?
[01:22:15.620 --> 01:22:17.620]  Но он может дать через arcs.
[01:22:17.620 --> 01:22:23.620]  Ладно, передать ему типу allocator, который ты даешь, и тип, который ты создалешь allocator?
[01:22:23.620 --> 01:22:25.620]  Нет.
[01:22:25.620 --> 01:22:29.620]  Не можешь передать ему шаблонный allocator без шаблонных параметров?
[01:22:29.620 --> 01:22:33.620]  Без подставных шаблонных параметров?
[01:22:33.620 --> 01:22:35.620]  Да, слушайте, я не знаю.
[01:22:35.620 --> 01:22:37.620]  Я не знаю, я забыл.
[01:22:37.620 --> 01:22:39.620]  Я не помню.
[01:22:39.620 --> 01:22:41.620]  Ну, короче, не знаю.
[01:22:43.620 --> 01:22:45.620]  Ну, я не помню какие там параметры.
[01:22:51.620 --> 01:22:53.620]  Да-да-да-да, allocator trades вот этого allocator.
[01:22:53.620 --> 01:22:55.620]  Это да, это точно так.
[01:22:55.620 --> 01:22:57.620]  А вот что в rebind-алог написано, я забыл, да.
[01:22:57.620 --> 01:22:59.620]  Но, к сожалению, сейчас бы открылся.
[01:22:59.620 --> 01:23:03.620]  Переференции мы бы посмотрели, но вот без проектора я так не могу сказать.
[01:23:03.620 --> 01:23:07.620]  Ну, слушайте, вы посмотрите, откроете и используйте правильно.
[01:23:07.620 --> 01:23:09.620]  Вот.
[01:23:09.620 --> 01:23:11.620]  Еще там есть такие вещи.
[01:23:11.620 --> 01:23:13.620]  Propagate on container, copy assignment.
[01:23:13.620 --> 01:23:15.620]  Propagate on container, swap.
[01:23:15.620 --> 01:23:17.620]  Propagate on container, move assignment.
[01:23:17.620 --> 01:23:19.620]  Значит, это как раз...
[01:23:21.620 --> 01:23:23.620]  Это usings.
[01:23:23.620 --> 01:23:25.620]  Точнее, это не usings, это булевские константы просто.
[01:23:25.620 --> 01:23:27.620]  Значит, есть булевская такая константа.
[01:23:27.620 --> 01:23:29.620]  Propagate on container, copy assignment.
[01:23:29.620 --> 01:23:31.620]  Propagate on container, copy assignment.
[01:23:33.620 --> 01:23:35.620]  В allocator trades.
[01:23:35.620 --> 01:23:37.620]  Вот allocator. Что она говорит?
[01:23:37.620 --> 01:23:45.620]  Если она true, то это значит, что при присваивании одного контейнера другому с этим allocator нужно подменить allocator.
[01:23:45.620 --> 01:23:47.620]  Если false, значит, не нужно.
[01:23:47.620 --> 01:23:49.620]  Да?
[01:23:49.620 --> 01:23:51.620]  Ну, присвоить один allocator к другому.
[01:23:51.620 --> 01:23:55.620]  Надо присваивать allocator к allocator, когда ты контейнер присваиваешь или не нужно.
[01:23:55.620 --> 01:23:57.620]  Или оставить то, что было, да.
[01:23:59.620 --> 01:24:01.620]  Нет.
[01:24:01.620 --> 01:24:03.620]  А allocator trades, да?
[01:24:03.620 --> 01:24:05.620]  Да, allocator trades.
[01:24:05.620 --> 01:24:07.620]  Что?
[01:24:07.620 --> 01:24:09.620]  И по умолчанию...
[01:24:09.620 --> 01:24:11.620]  Я вижу, я не понимаю.
[01:24:11.620 --> 01:24:13.620]  Ну, по умолчанию, по-моему, true.
[01:24:13.620 --> 01:24:15.620]  То есть, по умолчанию...
[01:24:15.620 --> 01:24:17.620]  По умолчанию, я просто не знаю...
[01:24:17.620 --> 01:24:19.620]  Ну, я не помню там...
[01:24:19.620 --> 01:24:21.620]  Скажите, что там себе переференс написан, по умолчанию.
[01:24:21.620 --> 01:24:23.620]  Я не понимаю.
[01:24:23.620 --> 01:24:25.620]  Что это такое?
[01:24:25.620 --> 01:24:27.620]  Просто открыла и ничего не понимаю.
[01:24:27.620 --> 01:24:29.620]  Вот.
[01:24:29.620 --> 01:24:31.620]  Так, что-то я еще забыл.
[01:24:31.620 --> 01:24:33.620]  Важное, мне кажется, напоследок сказать.
[01:24:33.620 --> 01:24:35.620]  Сейчас я подумаю.
[01:24:35.620 --> 01:24:37.620]  Так, сейчас давайте я быстренько
[01:24:37.620 --> 01:24:39.620]  открою список того,
[01:24:39.620 --> 01:24:41.620]  что я должен был вам сегодня рассказать.
[01:24:41.620 --> 01:24:43.620]  Да, точно.
[01:24:43.620 --> 01:24:45.620]  Вот последнее, что я должен был вам рассказать.
[01:24:45.620 --> 01:24:47.620]  Смотрите.
[01:24:47.620 --> 01:24:49.620]  Да.
[01:24:49.620 --> 01:24:51.620]  Значит, финалочка.
[01:24:51.620 --> 01:24:53.620]  Смотрите. Возвращаясь к теме allocator
[01:24:53.620 --> 01:24:55.620]  aware-container.
[01:24:55.620 --> 01:24:57.620]  А...
[01:24:57.620 --> 01:24:59.620]  Давайте еще раз вспомним.
[01:24:59.620 --> 01:25:01.620]  Вот опять.
[01:25:01.620 --> 01:25:03.620]  Мне нужен был бы проектор, нужно было открыть код pushback,
[01:25:03.620 --> 01:25:05.620]  скажем, вектор.
[01:25:05.620 --> 01:25:07.620]  Или... А.
[01:25:07.620 --> 01:25:09.620]  Какого pushback?
[01:25:09.620 --> 01:25:11.620]  Давайте вспомним, что такое
[01:25:13.620 --> 01:25:15.620]  присваивание одного вектора другому.
[01:25:15.620 --> 01:25:17.620]  Вот.
[01:25:17.620 --> 01:25:19.620]  Как работает... Вот.
[01:25:19.620 --> 01:25:21.620]  Нужно вообразить сейчас то, что у меня нет проектора.
[01:25:21.620 --> 01:25:23.620]  Но вот давайте представим, что мы
[01:25:23.620 --> 01:25:25.620]  сейчас исследуем тело метода
[01:25:25.620 --> 01:25:27.620]  присваивания одного вектора другому.
[01:25:27.620 --> 01:25:29.620]  И допустим, мы поняли,
[01:25:29.620 --> 01:25:31.620]  что propagate-on-container-copy-assign
[01:25:31.620 --> 01:25:33.620]  это true, то есть нужно присвоить один allocator
[01:25:33.620 --> 01:25:35.620]  другому.
[01:25:35.620 --> 01:25:37.620]  А что это значит? Это значит, что нам надо...
[01:25:37.620 --> 01:25:39.620]  Ну, нам надо сначала на старом allocator
[01:25:39.620 --> 01:25:41.620]  уничтожить все старые элементы.
[01:25:41.620 --> 01:25:43.620]  Необязательно. Нет, необязательно.
[01:25:43.620 --> 01:25:45.620]  Сказать пулу, что мы уничтожаем
[01:25:45.620 --> 01:25:47.620]  один элемент.
[01:25:47.620 --> 01:25:49.620]  Что значит сказать пулу?
[01:25:49.620 --> 01:25:51.620]  Какому пулу?
[01:25:51.620 --> 01:25:53.620]  Да, об этом сейчас и разговор.
[01:25:53.620 --> 01:25:55.620]  У нас есть
[01:25:55.620 --> 01:25:57.620]  что...
[01:25:57.620 --> 01:25:59.620]  У нас есть какой-то allocator.
[01:25:59.620 --> 01:26:01.620]  Да.
[01:26:01.620 --> 01:26:03.620]  Произвольный allocator, разумеется, да.
[01:26:05.620 --> 01:26:07.620]  У него есть методы construct,
[01:26:07.620 --> 01:26:09.620]  destroy, allocate, allocate.
[01:26:09.620 --> 01:26:11.620]  Ну, да.
[01:26:11.620 --> 01:26:13.620]  Ну, то есть
[01:26:13.620 --> 01:26:15.620]  я хочу сказать, что
[01:26:15.620 --> 01:26:17.620]  мне неизбежно придется
[01:26:17.620 --> 01:26:19.620]  сделать присваивание одного allocator
[01:26:19.620 --> 01:26:21.620]  другому
[01:26:21.620 --> 01:26:23.620]  уже после того,
[01:26:23.620 --> 01:26:25.620]  как были уничтожены объекты
[01:26:25.620 --> 01:26:27.620]  с старым allocator.
[01:26:27.620 --> 01:26:29.620]  Даже если я создам локально
[01:26:29.620 --> 01:26:31.620]  новый allocator
[01:26:31.620 --> 01:26:33.620]  из старого allocator, потом я с старым
[01:26:33.620 --> 01:26:35.620]  allocator уничтожу объекты, мне же нужно
[01:26:35.620 --> 01:26:37.620]  в итоге мое-то поле сделать
[01:26:37.620 --> 01:26:39.620]  нужному allocator как-то.
[01:26:41.620 --> 01:26:43.620]  Что если оператор
[01:26:43.620 --> 01:26:45.620]  присваивания allocator кидает исключение?
[01:26:45.620 --> 01:26:47.620]  Выкинуть его дальше
[01:26:47.620 --> 01:26:49.620]  и забыть про это, как страшная игра.
[01:26:49.620 --> 01:26:51.620]  Я уже удалил объекты.
[01:26:51.620 --> 01:26:53.620]  Векторист. Мне нравится, как люди
[01:26:53.620 --> 01:26:55.620]  на лицо берутся.
[01:26:59.620 --> 01:27:01.620]  Так, еще раз, смотрите.
[01:27:01.620 --> 01:27:03.620]  Проблема. Я присваиваю
[01:27:03.620 --> 01:27:05.620]  один vector другому vector'у.
[01:27:05.620 --> 01:27:07.620]  И у меня разные allocator'ы.
[01:27:07.620 --> 01:27:09.620]  И мне нужно propagating container copy assignment
[01:27:09.620 --> 01:27:11.620]  сделать для allocator. То есть заменить allocator.
[01:27:11.620 --> 01:27:13.620]  Но старые-то объекты
[01:27:13.620 --> 01:27:15.620]  мне нужно удалить старым allocator. У меня в векторе лежали
[01:27:15.620 --> 01:27:17.620]  какие-то объекты. Мне нужно их удалить
[01:27:17.620 --> 01:27:19.620]  старым allocator'ом. Сделать
[01:27:19.620 --> 01:27:21.620]  deallocate.
[01:27:21.620 --> 01:27:23.620]  Потом заменить allocator, сделать
[01:27:23.620 --> 01:27:25.620]  снова allocate и положить новые объекты.
[01:27:25.620 --> 01:27:27.620]  Откуда вы возьмете новые объекты и удалили?
[01:27:27.620 --> 01:27:29.620]  Новые объекты возьму из vector'а,
[01:27:29.620 --> 01:27:31.620]  из которого я копируюсь.
[01:27:31.620 --> 01:27:33.620]  Я присваиваю одному vector'у другой vector.
[01:27:35.620 --> 01:27:37.620]  У меня в моем vector'е лежат какие-то объекты.
[01:27:37.620 --> 01:27:39.620]  В моем vector'е лежат, там a1, так далее,
[01:27:39.620 --> 01:27:41.620]  an. В другом b1, так далее, bn.
[01:27:43.620 --> 01:27:45.620]  Вы поделяете память, потом перекладываете объекты.
[01:27:45.620 --> 01:27:47.620]  Что значит перекладываю объекты?
[01:27:47.620 --> 01:27:49.620]  Мне нужно создать объекты новым allocator'ом,
[01:27:49.620 --> 01:27:51.620]  удалив их старым allocator.
[01:27:51.620 --> 01:27:53.620]  Где я возьму новый allocator?
[01:27:53.620 --> 01:27:55.620]  Как я его
[01:27:55.620 --> 01:27:57.620]  создам?
[01:27:57.620 --> 01:27:59.620]  Я создаю новый allocator.
[01:27:59.620 --> 01:28:01.620]  Так, еще раз.
[01:28:01.620 --> 01:28:03.620]  У меня есть... Ну вот проблема в том, что у меня
[01:28:03.620 --> 01:28:05.620]  нету... У вас есть смартфон, который можно нарисовать,
[01:28:05.620 --> 01:28:07.620]  стереть что-то уже.
[01:28:07.620 --> 01:28:09.620]  Хорошо, давайте,
[01:28:09.620 --> 01:28:11.620]  хорошо.
[01:28:11.620 --> 01:28:13.620]  У меня есть мой allocator.
[01:28:13.620 --> 01:28:15.620]  Вот я пишу...
[01:28:15.620 --> 01:28:17.620]  Можно назвать только два vector'а и bn, чтобы было понятно,
[01:28:17.620 --> 01:28:19.620]  а как он здесь?
[01:28:19.620 --> 01:28:21.620]  Оператор равно...
[01:28:21.620 --> 01:28:23.620]  Оператор равно...
[01:28:23.620 --> 01:28:25.620]  От const
[01:28:25.620 --> 01:28:27.620]  vector
[01:28:29.620 --> 01:28:31.620]  t alloc
[01:28:31.620 --> 01:28:33.620]  &other
[01:28:37.620 --> 01:28:39.620]  Что я делаю здесь?
[01:28:39.620 --> 01:28:41.620]  Понятно, там авто будет.
[01:28:41.620 --> 01:28:43.620]  Нет, не будет так делать.
[01:28:43.620 --> 01:28:45.620]  Короче, понятно, какой возвращаемый тип.
[01:28:45.620 --> 01:28:47.620]  У меня в полях лежит allocator
[01:28:51.620 --> 01:28:53.620]  и там t звездочка
[01:28:53.620 --> 01:28:55.620]  array
[01:28:55.620 --> 01:28:57.620]  cz, kp, st, все понятно.
[01:28:57.620 --> 01:28:59.620]  Что я должен сделать, в первую очередь?
[01:28:59.620 --> 01:29:01.620]  Ну, я должен проверить.
[01:29:01.620 --> 01:29:03.620]  If allocator trades allocator
[01:29:03.620 --> 01:29:05.620]  propagator, container, copy, assignment,
[01:29:05.620 --> 01:29:07.620]  то вот это, допустим, я написал,
[01:29:07.620 --> 01:29:09.620]  что это выполнено.
[01:29:09.620 --> 01:29:11.620]  Что дальше я должен сделать?
[01:29:11.620 --> 01:29:13.620]  Я могу идти обедать?
[01:29:13.620 --> 01:29:15.620]  Нет, все, я сейчас уйду.
[01:29:15.620 --> 01:29:17.620]  У меня просто вопросы задают, я не могу никак остановиться.
[01:29:17.620 --> 01:29:19.620]  Что я должен сделать?
[01:29:21.620 --> 01:29:23.620]  Люди жалуются, говорят, что хотят на DM
[01:29:23.620 --> 01:29:25.620]  к райгору, они не могут больше
[01:29:25.620 --> 01:29:27.620]  это терпеть.
[01:29:31.620 --> 01:29:33.620]  Мне нужно сделать
[01:29:33.620 --> 01:29:35.620]  destroy того, что у меня лежало в vector'е
[01:29:35.620 --> 01:29:37.620]  старым allocator'ом
[01:29:37.620 --> 01:29:39.620]  а потом
[01:29:39.620 --> 01:29:41.620]  я никак не могу
[01:29:41.620 --> 01:29:43.620]  старый allocator вот этот allocator
[01:29:43.620 --> 01:29:45.620]  вот этим allocator
[01:29:45.620 --> 01:29:47.620]  мне нужно сделать destroy всего того, что лежало
[01:29:47.620 --> 01:29:49.620]  в vector'е и deallocate
[01:29:49.620 --> 01:29:51.620]  а потом
[01:29:51.620 --> 01:29:53.620]  ну или до этого
[01:29:53.620 --> 01:29:55.620]  мне нужно создать
[01:29:55.620 --> 01:29:57.620]  новый allocator
[01:29:57.620 --> 01:29:59.620]  мне нужно вот это
[01:29:59.620 --> 01:30:01.620]  поле подменить на тот allocator,
[01:30:01.620 --> 01:30:03.620]  который тут был.
[01:30:03.620 --> 01:30:05.620]  Да, я не могу
[01:30:05.620 --> 01:30:07.620]  я никак не могу избежать присваивания
[01:30:07.620 --> 01:30:09.620]  allocator'а после того, как я
[01:30:09.620 --> 01:30:11.620]  освободил старый объект, потому что
[01:30:11.620 --> 01:30:13.620]  даже если я скопирую
[01:30:13.620 --> 01:30:15.620]  этот allocator, присвою
[01:30:17.620 --> 01:30:19.620]  или могу, сейчас давайте подумаем, может
[01:30:19.620 --> 01:30:21.620]  могу, если я
[01:30:21.620 --> 01:30:23.620]  сначала создам новый allocator
[01:30:23.620 --> 01:30:25.620]  из того allocator'а
[01:30:25.620 --> 01:30:27.620]  а мы все равно потом присвоим
[01:30:27.620 --> 01:30:29.620]  или сейчас теперь
[01:30:29.620 --> 01:30:31.620]  с опытом копирования
[01:30:31.620 --> 01:30:33.620]  хорошо, я могу, наверное, сначала
[01:30:33.620 --> 01:30:35.620]  создать копию этого allocator'а
[01:30:35.620 --> 01:30:37.620]  вот так. Я создаю копию
[01:30:37.620 --> 01:30:39.620]  этого allocator'а
[01:30:41.620 --> 01:30:43.620]  этому allocator'у присваиваю
[01:30:43.620 --> 01:30:45.620]  тот allocator
[01:30:45.620 --> 01:30:47.620]  на копии уничтожаю
[01:30:47.620 --> 01:30:49.620]  весь pool и все объекты
[01:30:49.620 --> 01:30:51.620]  как раз
[01:30:51.620 --> 01:30:53.620]  потом
[01:30:53.620 --> 01:30:55.620]  пока уничтожаю объекты
[01:30:55.620 --> 01:30:57.620]  исключения не может быть. Это
[01:30:57.620 --> 01:30:59.620]  новый accept штука. Потом
[01:30:59.620 --> 01:31:01.620]  уничтожаю allocator
[01:31:01.620 --> 01:31:03.620]  локальный копию
[01:31:03.620 --> 01:31:05.620]  destroy всегда no accept
[01:31:05.620 --> 01:31:07.620]  destroy уничтожение всегда no accept
[01:31:07.620 --> 01:31:09.620]  а вот копирование не no accept. Уничтожаю
[01:31:09.620 --> 01:31:11.620]  этот копию локального allocator'а
[01:31:11.620 --> 01:31:13.620]  теперь у меня этот allocator
[01:31:13.620 --> 01:31:15.620]  уже новый allocator
[01:31:15.620 --> 01:31:17.620]  а теперь я выделяю новую память
[01:31:17.620 --> 01:31:19.620]  и создаю новый объект
[01:31:19.620 --> 01:31:21.620]  а что если тут будет исключение
[01:31:21.620 --> 01:31:23.620]  если тут будет исключение, то мне надо
[01:31:23.620 --> 01:31:25.620]  все вернуть обратно
[01:31:25.620 --> 01:31:27.620]  и новый allocator вернуть обратно
[01:31:27.620 --> 01:31:29.620]  то есть вернуть allocator как было
[01:31:29.620 --> 01:31:31.620]  короче, в любом случае
[01:31:31.620 --> 01:31:33.620]  как бы я не изгалялся с копированием allocator
[01:31:33.620 --> 01:31:35.620]  у меня неизбежно возникнет ситуация
[01:31:35.620 --> 01:31:37.620]  что мне нужно вернуть allocator как был
[01:31:37.620 --> 01:31:39.620]  скопировать allocator обратно
[01:31:39.620 --> 01:31:41.620]  или туда или обратно
[01:31:41.620 --> 01:31:43.620]  а у меня уже исключение кидать нельзя
[01:31:43.620 --> 01:31:45.620]  как же мне поддержать exception safety
[01:31:45.620 --> 01:31:47.620]  с allocator'ами
[01:31:47.620 --> 01:31:49.620]  если мне нужно в какой-то момент присвоить
[01:31:49.620 --> 01:31:51.620]  одному allocator'у другой
[01:31:51.620 --> 01:31:53.620]  и вот никак я не могу
[01:31:53.620 --> 01:31:55.620]  на самом деле
[01:31:55.620 --> 01:31:57.620]  в требованиях allocator
[01:31:57.620 --> 01:31:59.620]  написано, что присваивание allocator
[01:31:59.620 --> 01:32:01.620]  должно быть noexcept и все
[01:32:01.620 --> 01:32:03.620]  ну то есть если вы
[01:32:03.620 --> 01:32:05.620]  никак не получается
[01:32:05.620 --> 01:32:07.620]  избежать, чтобы allocator
[01:32:07.620 --> 01:32:09.620]  копировался с сохранением
[01:32:09.620 --> 01:32:11.620]  безопасности исключения
[01:32:11.620 --> 01:32:13.620]  просто по требованию allocator должен
[01:32:13.620 --> 01:32:15.620]  копироваться без исключения и все
[01:32:15.620 --> 01:32:17.620]  присваивание allocator
[01:32:17.620 --> 01:32:19.620]  ну да, присваивание allocator и noexcept
[01:32:19.620 --> 01:32:21.620]  ну возможно не все там
[01:32:21.620 --> 01:32:23.620]  копии или мув присваивания, какой-то из них
[01:32:23.620 --> 01:32:25.620]  все на этом
