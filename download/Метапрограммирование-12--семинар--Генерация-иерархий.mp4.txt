[00:00.000 --> 00:08.520]  Все, не рация иерархии, это такая смешная маленькая
[00:08.520 --> 00:09.520]  тема.
[00:09.520 --> 00:13.400]  Ну, по сути, она ровно про то, о чем ему и кажется.
[00:13.400 --> 00:19.000]  Задача тупая, просто вот, чисто механическая на
[00:19.000 --> 00:20.000]  C++.
[00:20.000 --> 00:25.600]  Есть у вас список типов, вот такой, какие-то базы,
[00:25.600 --> 00:29.880]  есть какой-то child, ну, шаблон тоже, наверное.
[00:29.880 --> 00:34.160]  Необходимо как-то сгенерировать вот такую шнягу, иерархию,
[00:34.160 --> 00:37.920]  то есть сделать, чтобы child наследовался от баз.
[00:37.920 --> 00:39.920]  Звучит по-идиотски, правда?
[00:39.920 --> 00:41.960]  Ну, как-то очень легко.
[00:41.960 --> 00:45.520]  Вы делаете child шаблонным с паком, и все наследуете
[00:45.520 --> 00:47.200]  и круто.
[00:47.200 --> 00:50.720]  Но паков-то не было раньше, до 11-х плюсов.
[00:50.720 --> 00:53.840]  Но есть еще одна задача.
[00:53.840 --> 00:57.840]  Линейная иерархия, да, вот эта вот с, ой, скатер-ирархия
[00:57.840 --> 01:01.800]  называется, ну, как бы скатер, а вот эта называется
[01:01.800 --> 01:04.520]  линейная, потому что, ну, в линию.
[01:04.520 --> 01:08.680]  И дан тип лист каких-то типов, нужно их друг за друга
[01:08.680 --> 01:09.680]  наследовать.
[01:09.680 --> 01:12.280]  То есть по цепочке один, другой, третий, четвертый,
[01:12.280 --> 01:13.280]  пятый наследуют.
[01:13.280 --> 01:18.720]  Ну, тоже пока не очень понятно, в каком виде, ну, что там,
[01:18.720 --> 01:23.200]  просто как-то это заводим, как-то тоже шаблонный, ну,
[01:23.200 --> 01:25.200]  CRTP какой-нибудь, вот что-нибудь такое.
[01:25.200 --> 01:31.040]  Ну, да-да-да, от него наследуя, и все работает.
[01:31.040 --> 01:36.600]  Казалось бы, детские задачи, но до C++11 самым таким модным
[01:36.600 --> 01:41.160]  частным способом и единственным, пожалуй, генерировать скатер-ирархию
[01:41.160 --> 01:42.160]  было следующее.
[01:42.160 --> 01:51.320]  Все понятно, да, тривиально, как бы, тут, ну, элементарно.
[01:51.320 --> 01:54.900]  Ну, тут, по сути, примерно так, как вы в третьей домашке
[01:54.900 --> 01:58.100]  практиковались рекурсивные типо-спискам типов, которые
[01:58.100 --> 02:01.780]  как пара хвост-голова, вот тут так по такому списку
[02:01.780 --> 02:05.300]  типов рекурсивно идут, и какое-то вот это вот рекурсивные
[02:05.300 --> 02:09.060]  ноды что-то делают, и в итоге наследуются от каких-то
[02:09.060 --> 02:12.420]  холдеров, которые вот как раз и есть те базовые классы,
[02:12.420 --> 02:13.420]  которые мы хотели.
[02:13.420 --> 02:14.420]  А вот это ребенок.
[02:14.420 --> 02:17.140]  Ну, и как бы, получилась скатер-ирархия.
[02:17.140 --> 02:22.060]  Линейную тоже тут очень весело делали, как-то вот промежуточные
[02:22.060 --> 02:23.060]  что-то.
[02:23.060 --> 02:26.100]  Ну, в общем, как-то делали.
[02:26.100 --> 02:27.100]  Зачем только?
[02:27.100 --> 02:32.420]  Ну, можно уже догадаться, в принципе, но неважно.
[02:32.420 --> 02:34.860]  Мы просто закодим это, и будет предельно понятно.
[02:34.860 --> 02:39.180]  А что мы закодим, и зачем вообще все это, вот эта вот
[02:39.180 --> 02:41.860]  абстрактная задача в вакууме, что-то от кого-то наследовать
[02:41.860 --> 02:44.340]  линейно, там вот так вот распластать.
[02:44.340 --> 02:48.820]  Вариантический селект, отличная мысль.
[02:48.980 --> 02:49.980]  Нет.
[02:52.980 --> 02:55.580]  Да, main driven, что нет, был policy driven.
[02:55.580 --> 02:58.580]  Не открывался сайты, правда?
[02:58.580 --> 02:59.580]  Окей.
[03:01.580 --> 03:04.580]  Он на китайском открылся.
[03:04.580 --> 03:05.580]  Я не знаю китайского.
[03:09.580 --> 03:10.580]  По японскому.
[03:10.580 --> 03:13.580]  Это другое, вы не понимаете.
[03:14.340 --> 03:18.340]  Ну ладно, как хорошо, что я успел все выгрузить.
[03:27.340 --> 03:30.340]  Вот она, наша любимая абстрактная фабрика.
[03:33.340 --> 03:34.340]  А мы будем ее писать.
[03:34.340 --> 03:38.340]  Ну как, генерировать ее, вот то, о чем я говорил.
[03:38.340 --> 03:41.020]  Никто дома, скорее всего, не попытался ручками
[03:41.020 --> 03:42.020]  погенерить.
[03:42.460 --> 03:44.460]  Нет, отлично.
[03:45.460 --> 03:46.460]  Внимание.
[03:47.460 --> 03:50.460]  Вот есть тут какие-то интерфейсы.
[03:51.460 --> 03:53.460]  Кошки, собаки, коровы.
[03:54.460 --> 03:57.460]  Наверное, лучше сделать их абстрактными, да, в смысле
[03:57.460 --> 03:59.460]  I дописать.
[04:06.460 --> 04:09.460]  Ладно, пусть такие будут, мне так проще.
[04:12.460 --> 04:20.460]  Да, вызов метода, издай звук, он как бы сразу, сразу
[04:20.460 --> 04:21.460]  Copy&Write запускает.
[04:22.460 --> 04:25.460]  Короче, вот это наши интерфейсы, cat, dog, cow.
[04:25.460 --> 04:28.460]  А вот это у нас конкретные продукты, наследники этих
[04:28.460 --> 04:29.460]  интерфейсов.
[04:29.460 --> 04:31.460]  Мы хотим сгенерировать два класса.
[04:31.460 --> 04:37.460]  Во-первых, абстрактную фабрику, вот эту, как тут
[04:37.460 --> 04:40.460]  была GUI-фактория, вот у нее там должны быть методы.
[04:40.900 --> 04:42.900]  CreateButton, CreateCheckBox.
[04:43.900 --> 04:46.900]  Такие же у нас должны быть методы createCow, createDog,
[04:46.900 --> 04:47.900]  createCat.
[04:49.900 --> 04:51.900]  Ну и, в принципе, это все, что здесь требуется.
[04:51.900 --> 04:54.900]  Вот тут нужно как-то каким-то образом сгенерировать
[04:54.900 --> 04:58.900]  метод create для каждого элемента в этом паке интерфейсов.
[05:00.900 --> 05:02.900]  Ну и на вход, мы там в тесте.
[05:04.900 --> 05:05.900]  Test, test, test.
[05:06.340 --> 05:09.340]  Вот, делается абстракт-фактория от cat, dog, cow.
[05:10.340 --> 05:14.340]  Ожидается, что у них будут какие-то виртуальные методы.
[05:15.340 --> 05:16.340]  Как мы это будем делать?
[05:19.340 --> 05:20.340]  Давайте думать.
[05:23.340 --> 05:27.340]  Сгенерировать для каждого типа в этом паке виртуальный
[05:27.340 --> 05:29.340]  метод create что-то там.
[05:29.780 --> 05:33.780]  Мы создадим сначала класс, который,
[05:33.780 --> 05:36.780]  которого шаблонный параметр это тип.
[05:40.780 --> 05:42.780]  Ну, мы интерфейс мы узнаем.
[05:42.780 --> 05:44.780]  То есть, нулевой шаг.
[05:45.220 --> 05:51.220]  To plate class interface, astract, overload.
[05:58.220 --> 05:59.220]  Я его вот так назову.
[06:01.220 --> 06:03.220]  Ну какая-то там нужная сигнатура.
[06:03.220 --> 06:04.220]  А какая?
[06:05.220 --> 06:08.220]  Ну, в целом, кажется, что мы пишем в факторе, да?
[06:09.220 --> 06:11.220]  Интерфейс, наверное, надо возвращать.
[06:11.220 --> 06:14.220]  Наверное, uniquePTR, хорошо бы.
[06:14.660 --> 06:16.660]  Мы сейчас создавать объекты.
[06:16.660 --> 06:19.660]  Создавать объекты, это просто factory, да?
[06:19.660 --> 06:20.660]  Вот.
[06:21.660 --> 06:26.660]  А здесь мы наследуемся от абстракт-продюсер многоточия.
[06:28.660 --> 06:29.660]  Ну, точнее, interfaces.
[06:29.660 --> 06:30.660]  Да.
[06:31.660 --> 06:33.660]  И затем, ну, в идеале, наверное,
[06:33.660 --> 06:35.660]  нужно наследоваться, типа,
[06:35.660 --> 06:37.660]  приватным юзингом вытащить.
[06:40.660 --> 06:41.660]  Окей.
[06:42.100 --> 06:44.100]  Ну, даже без приватного.
[06:44.100 --> 06:45.100]  Вопрос.
[06:45.100 --> 06:47.100]  Можно ли делать вариатически?
[06:47.100 --> 06:48.100]  Да, можно.
[06:48.100 --> 06:49.100]  Можно.
[06:49.100 --> 06:50.100]  Вопрос.
[06:50.100 --> 06:53.100]  Как теперь из этой шняги вытащить нужный нам create?
[06:53.100 --> 06:56.100]  Точка абстракт-продюсер, тип.
[06:56.100 --> 06:59.100]  Как-то неудобно, да?
[06:59.100 --> 07:00.100]  Ну, как есть.
[07:00.100 --> 07:03.100]  А можно просто create в треугольных скобочках указать,
[07:03.100 --> 07:05.100]  что мы хотим create-ить?
[07:05.100 --> 07:09.100]  Можно написать внутри шаблонный метод.
[07:09.540 --> 07:15.540]  To play a class interface.
[07:15.540 --> 07:18.540]  Ну, наверное, и.
[07:18.540 --> 07:19.540]  И, да.
[07:19.540 --> 07:20.540]  Чтобы не было...
[07:20.540 --> 07:21.540]  И.
[07:21.540 --> 07:26.540]  И, unique-ptr-e-create.
[07:26.540 --> 07:28.540]  Вот так мне нравится.
[07:28.540 --> 07:30.540]  Только что сюда вписать теперь?
[07:34.540 --> 07:36.540]  Блин, ну слишком легко.
[07:36.540 --> 07:38.540]  Что слишком легко?
[07:38.980 --> 07:39.980]  Есть.
[07:43.980 --> 07:44.980]  Ладно.
[07:47.980 --> 07:50.980]  Не знаю, зачем я в прошлом году здесь жизнь усложнял.
[07:50.980 --> 07:51.980]  Вы молодцы.
[07:51.980 --> 07:53.980]  Будем дальше себе жизнь усложнять.
[07:53.980 --> 07:55.980]  Окей, так работает, в принципе.
[07:55.980 --> 07:57.980]  Для факта лучше даже делать не надо,
[07:57.980 --> 08:00.980]  но если бы это была, например, tuple или select,
[08:00.980 --> 08:02.980]  то могла бы возникнуть...
[08:02.980 --> 08:03.980]  Тю-тю-тю-тю.
[08:03.980 --> 08:05.980]  Tuple дальше будем писать.
[08:05.980 --> 08:06.980]  Всю беду увидим.
[08:06.980 --> 08:07.980]  Можешь не говорить.
[08:08.420 --> 08:09.420]  Tuple дальше напишем.
[08:09.420 --> 08:10.420]  Небольшой.
[08:10.420 --> 08:11.420]  Маленький.
[08:11.420 --> 08:12.420]  И все увидим.
[08:12.420 --> 08:13.420]  Не надо спейлерить.
[08:13.420 --> 08:14.420]  Тихо.
[08:18.420 --> 08:20.420]  Ты тоже собрался спейлерить.
[08:20.420 --> 08:21.420]  Я услышал.
[08:21.420 --> 08:22.420]  Не надо спейлерить.
[08:25.420 --> 08:26.420]  Так.
[08:26.420 --> 08:28.420]  Ну, кажется, мы написали, да?
[08:28.420 --> 08:30.420]  Ну, то есть если сравнить по сложности,
[08:30.420 --> 08:33.420]  что вот Александреску в свое время пришлось
[08:33.420 --> 08:37.420]  вот такую штуку городить с какими-то макросами,
[08:37.860 --> 08:39.860]  типа TypeList 1, TypeList 2,
[08:39.860 --> 08:41.860]  ну, тут просто ужас.
[08:41.860 --> 08:43.860]  А у нас все работает.
[08:43.860 --> 08:46.860]  Ну, внимание, мы только что сгенерили
[08:46.860 --> 08:50.860]  функцию, в которой сгенерили класс,
[08:50.860 --> 08:52.860]  в котором много виртуальных методов,
[08:52.860 --> 08:55.860]  причем, ну как бы, виртуальные методы
[08:55.860 --> 08:57.860]  генерируются по запросу.
[08:57.860 --> 08:58.860]  Да.
[08:58.860 --> 09:00.860]  Я что-то видимо не понимаю.
[09:00.860 --> 09:02.860]  У нас есть structure, abstract producer
[09:02.860 --> 09:04.860]  и виртуальный метод.
[09:04.860 --> 09:05.860]  Значит, мы видимо хотим,
[09:05.860 --> 09:06.860]  чтобы от нас наследовались.
[09:06.860 --> 09:11.860]  Да, это абстрактная фабрика. Это интерфейс такой, типа.
[09:17.860 --> 09:21.860]  Давай не будем про кавариантность, это больная тема для плюсов, ничего хорошего не будет.
[09:22.860 --> 09:25.860]  Ну, согласно, что мы сгенерировали интерфейс фабрики.
[09:25.860 --> 09:30.860]  Вот как ровно на этой картинке? GUI factory create button, create checkbox.
[09:30.860 --> 09:32.860]  Виртуальные функции.
[09:32.860 --> 09:34.860]  Сейчас.
[09:35.860 --> 09:37.860]  Непонятно, да, ничего?
[09:37.860 --> 09:42.860]  А у нас есть интерфейс, который для...
[09:42.860 --> 09:45.860]  Вот можем, наверное, сходу нажать?
[09:45.860 --> 09:48.860]  Вот у нас передается...
[09:48.860 --> 09:51.860]  Сейчас у нас есть интерфейс, интерфейс...
[09:51.860 --> 09:54.860]  Так, я забыл. Вот так.
[09:54.860 --> 09:56.860]  Какой интерфейс интерфейса?
[09:56.860 --> 09:57.860]  Вирчер, конечно.
[09:57.860 --> 10:01.860]  Да, на первый вирчер. Ну, абстракт-фактор это интерфейс.
[10:03.860 --> 10:06.860]  Interfactory interface.
[10:06.860 --> 10:11.860]  Ну, это интерфейс для фабрики, которая умеет производить набор каких-то продуктов.
[10:11.860 --> 10:13.860]  Create button, create checkbox.
[10:13.860 --> 10:19.860]  А можешь какой-то небольшой для мячиков списать, как можно реализовать интерфейс?
[10:19.860 --> 10:21.860]  А, так это следующий шаг.
[10:21.860 --> 10:25.860]  Ну, согласен, что интерфейс мы сделали.
[10:25.860 --> 10:29.860]  А дальше есть вот эти вот twin factory и mac factory, конкретные.
[10:30.860 --> 10:32.860]  Их мы тоже хотим генерить.
[10:32.860 --> 10:36.860]  Потому что там код, как мы упоминали, неоднократно абсолютно однообразный.
[10:36.860 --> 10:39.860]  Нужно написать new и какой-то конкретный класс.
[10:39.860 --> 10:43.860]  Ну, в нашем случае там будет типа new...
[10:43.860 --> 10:49.860]  Вот интерфейс у нас такие, а new будут new Sphinx, new Spaniel, new Black Angus.
[10:54.860 --> 10:56.860]  Вот она, concrete factory.
[10:57.860 --> 11:02.860]  Ей на вход уже вот к вопросу о type тепла, type листах и прочем.
[11:02.860 --> 11:04.860]  Уже приходят два type тепла.
[11:04.860 --> 11:06.860]  Ну, потому что два пака нельзя.
[11:06.860 --> 11:10.860]  А нам нужны интерфейсы, чтобы понять, какие методы оверрайдить.
[11:10.860 --> 11:16.860]  И имплементация, чтобы понять, а что вписывать в...
[11:16.860 --> 11:19.860]  Ну, как бы что new делать, да?
[11:21.860 --> 11:25.860]  Итак, ну, первый шаг, надо распаковать эти паки, согласны.
[11:27.860 --> 11:30.860]  Вот это вот наша традиционная техника.
[11:30.860 --> 11:36.860]  Type tuple, interfaces.
[11:40.860 --> 11:43.860]  Теперь ворядик будет, это специализация.
[11:45.860 --> 11:50.860]  Тут implementations, и мы сделали специализацию.
[11:50.860 --> 11:52.860]  И уже можно какой-то код писать.
[11:56.860 --> 12:03.860]  Абстракт-продюсер в тревольскомчике interfaces,
[12:03.860 --> 12:07.860]  разве триточки должны быть внутри?
[12:07.860 --> 12:10.860]  Или я не понял, что мы делаем?
[12:10.860 --> 12:14.860]  Тебе не хватает практики с ворядиками.
[12:14.860 --> 12:18.860]  Триточки можно написать внутри, тогда это будет значить...
[12:18.860 --> 12:21.860]  Ну, давай скажем, что interfaces, это было A, B, C.
[12:21.860 --> 12:26.860]  Если мы пишем вот так, это значит A, B, C.
[12:26.860 --> 12:30.860]  Но тут же один аргумент, фигня.
[12:30.860 --> 12:34.860]  А вот если мы пишем вот так вот,
[12:34.860 --> 12:38.860]  это значит все вот это вот выражение разверни.
[12:38.860 --> 12:45.860]  То есть будет A, B, C.
[12:45.860 --> 12:49.860]  То есть мы отнаследовались от всех таких выражений с подставленным паком.
[12:51.860 --> 12:55.860]  Ага, вот.
[12:55.860 --> 13:00.860]  Давайте вы будете придумывать, как писать конкретную фабрику.
[13:00.860 --> 13:03.860]  Собственно, презентация, это была подсказка.
[13:03.860 --> 13:06.860]  Скатер-ерархия, чтобы нагенерить виртуальных методов.
[13:06.860 --> 13:09.860]  Была линейная иерархия.
[13:09.860 --> 13:11.860]  Ну, скатер-ерархию мы только что сделали.
[13:11.860 --> 13:13.860]  Наверное, нужна линейная.
[13:13.860 --> 13:19.860]  Кто выскажет идею, что делать?
[13:19.860 --> 13:27.860]  Вот этот класс в итоге должен стать самым дочерним классом
[13:27.860 --> 13:31.860]  в некоторой цепочке наследования,
[13:31.860 --> 13:35.860]  где самый родительский будет наш интерфейс.
[13:46.860 --> 13:48.860]  Не знаю, я хочу заубирать все методы.
[13:48.860 --> 13:50.860]  Ну, окей, давайте так.
[14:00.860 --> 14:02.860]  С точности до того, что мы делаем.
[14:02.860 --> 14:07.860]  Давайте напишем конкретную специализацию руками для этого шаблона.
[14:07.860 --> 14:09.860]  Тогда должно стать понятнее.
[14:09.860 --> 14:13.860]  От частного переходим к общему.
[14:13.860 --> 14:15.860]  Кет, дог.
[14:15.860 --> 14:17.860]  Так, сейчас.
[14:17.860 --> 14:18.860]  Как мы это будем писать?
[14:18.860 --> 14:19.860]  Вот так.
[14:19.860 --> 14:23.860]  Type list, ket, dog, cow.
[14:23.860 --> 14:25.860]  Type tuple.
[14:28.860 --> 14:38.860]  Type tuple, sphinx, spaniel, black angus.
[14:38.860 --> 14:40.860]  Так.
[14:43.860 --> 14:45.860]  Ну, конечно, они все определены.
[14:45.860 --> 14:46.860]  Фиг знает где.
[14:46.860 --> 14:48.860]  Давайте перенесем пониже.
[14:50.860 --> 14:52.860]  Почему tuple и type tuple?
[14:55.860 --> 14:59.860]  Потому что этот tuple это будет прям std tuple.
[14:59.860 --> 15:01.860]  Мы будем писать std tuple потом.
[15:04.860 --> 15:09.860]  Так, что я ожидаю, что вот этот шаблон мне сгенерит вот в такой специализации?
[15:09.860 --> 15:13.860]  Так, что я ожидаю, что вот этот шаблон мне сгенерит вот в такой специализации?
[15:13.860 --> 15:26.860]  Я ожидаю, во-первых, отнаследоваться от публичного abstract factory ket, dog, cow.
[15:29.860 --> 15:33.860]  Во-вторых, я ожидаю, что все виртуальные функции будут имплеменчаны.
[15:33.860 --> 15:35.860]  Какие здесь виртуальные функции?
[15:35.860 --> 15:37.860]  Три create.
[15:37.860 --> 15:39.860]  Три create.
[15:46.860 --> 15:54.860]  Нам нужен какой-то класс, который берет пару интерфейса и конкрет-тайпер.
[15:54.860 --> 15:56.860]  New sphinx.
[15:56.860 --> 16:01.860]  Но сейчас мы пока притормозим коней.
[16:01.860 --> 16:06.860]  А сейчас overwrite different return type.
[16:06.860 --> 16:09.860]  Ну, смотрите, все сломалось.
[16:09.860 --> 16:12.860]  Мы не можем понять, какую функцию мы overriding.
[16:12.860 --> 16:15.860]  У нас множественное наследование.
[16:15.860 --> 16:17.860]  Да?
[16:17.860 --> 16:20.860]  Как сейчас иерархия выглядит, вы представляете?
[16:20.860 --> 16:23.860]  Ну, вот можно руками.
[16:24.860 --> 16:29.860]  А почему у нас нет anima, от которого был ket, dog, and cow у нас следует?
[16:29.860 --> 16:33.860]  Это три совершенно отдельных иерархии.
[16:33.860 --> 16:41.860]  Да, потому что весь смысл в этой GUI-факторе в том, что она две разные иерархии, умеет для них генерировать объекты.
[16:41.860 --> 16:44.860]  Просто потому что это название не было контр-интерфейсировано?
[16:44.860 --> 16:46.860]  Ну, да.
[16:46.860 --> 16:50.860]  Если домашню что-то делал, это уже потому что там anima есть.
[16:50.860 --> 16:53.860]  Да, тут другая ситуация. Тут независимых три иерархии.
[16:53.860 --> 16:56.860]  Наверное, что в GUI пришло.
[16:56.860 --> 17:00.860]  А не работает вот такой create, как мне нашептал Аркадий.
[17:00.860 --> 17:03.860]  Его неудобно overriding.
[17:03.860 --> 17:08.860]  Ну, то есть можно явно указать, что мы...
[17:12.860 --> 17:15.860]  Да, ну вот можно.
[17:16.860 --> 17:19.860]  По-моему так, да?
[17:21.860 --> 17:24.860]  А, слушайте, какой private?
[17:24.860 --> 17:27.860]  Конечно же protective должно быть.
[17:34.860 --> 17:37.860]  Все равно не работает.
[17:37.860 --> 17:40.860]  Ну, а что, как?
[17:40.860 --> 17:45.860]  Ну, тут предложили, что можно указать явно, из какого parent мы overriding.
[17:45.860 --> 17:48.860]  Так ведь по типу...
[17:48.860 --> 17:51.860]  Ну, вот сейчас не видно. Почему?
[17:51.860 --> 17:54.860]  Они только return type.
[17:54.860 --> 17:58.860]  Да, они даже перегрузками друг друга не являются.
[17:58.860 --> 18:03.860]  И все это наводит на какие-то стрёмные мысли, что неудобно.
[18:03.860 --> 18:07.860]  Я категорически не рекомендую себя в такую ситуацию загонять никогда.
[18:07.860 --> 18:11.860]  Давайте придумаем, как сделать эти штуки перегрузками друг друга.
[18:11.860 --> 18:14.860]  Было предложение tag добавить в аргумент.
[18:14.860 --> 18:17.860]  Вот tag, да. Ну, Данила все запылирил.
[18:17.860 --> 18:20.860]  Какое еще предложение было?
[18:28.860 --> 18:32.860]  Мы хотим три разных виртуальных функции.
[18:32.860 --> 18:35.860]  Чистых виртуальных.
[18:35.860 --> 18:42.860]  Давайте и для abstract-факторе напишем явную специализацию для CatDog, чтобы увидеть,
[18:42.860 --> 18:45.860]  что мы хотим в итоге.
[18:49.860 --> 18:53.860]  Сейчас где CatDog cow?
[19:00.860 --> 19:03.860]  Ну, посмотрим. Сейчас так.
[19:12.860 --> 19:16.860]  Сейчас. Что-то я закодился уже, да?
[19:16.860 --> 19:19.860]  Вот здесь я хочу.
[19:24.860 --> 19:29.860]  А если бы у нас...
[19:29.860 --> 19:34.860]  Ну, просто кажется...
[19:34.860 --> 19:38.860]  Наверное, была бы такая, что бы мы не делали.
[19:39.860 --> 19:43.860]  Наверное, у нас была бы проблема, если бы у нас было бы сложнее,
[19:43.860 --> 19:46.860]  были бы какие-нибудь аргументы конструктора.
[19:46.860 --> 19:49.860]  Да, да, да.
[19:49.860 --> 19:53.860]  Нет, подожди, нет. Можно, знаешь, как сделать, чтобы не торчало тегов никаких.
[19:53.860 --> 19:56.860]  Можно написать...
[19:56.860 --> 19:59.860]  Нет, нет, без тегов вообще.
[19:59.860 --> 20:03.860]  Можно написать концепт STD из ConstructibleFrom.
[20:03.860 --> 20:06.860]  И тип явно указать.
[20:06.860 --> 20:10.860]  И это будет частью сигнатуры.
[20:10.860 --> 20:13.860]  И она даст нам возможность...
[20:13.860 --> 20:18.860]  Давай попроще. Что-то придумал лютое, закоди-то сам.
[20:18.860 --> 20:21.860]  Давайте к остальной аудитории вернемся.
[20:21.860 --> 20:26.860]  Я написал явно специализацию для CatDog-cow abstract-factor.
[20:26.860 --> 20:31.860]  Должен получаться класс, который принципиальный и квалентен вот этому вот.
[20:31.860 --> 20:35.860]  Но даже вот в таком виде какой-то бред получается. Согласны?
[20:35.860 --> 20:40.860]  Как-то у нас три одинаковых функции Create, которые разные значения возвращают.
[20:40.860 --> 20:43.860]  Это фигня. И вызывать...
[20:43.860 --> 20:46.860]  Такого можно добиться, но неудобно.
[20:46.860 --> 20:51.860]  Короче, надо как-то их разделить, чтобы они были перегрузками друг друга, но...
[20:51.860 --> 20:54.860]  Но в целом одинаково.
[20:54.860 --> 20:57.860]  Вот да, и непонятно, как вызывать.
[20:57.860 --> 21:02.860]  То есть можно... Вот здесь у нас какая-то деталь имплементации на самом деле протекла.
[21:02.860 --> 21:05.860]  Тут как-то странно позвали.
[21:05.860 --> 21:07.860]  Я предлагаю другой подход.
[21:07.860 --> 21:12.860]  Я предлагаю завести класс Tag.
[21:15.860 --> 21:20.860]  Видели ли вы где-то Tag-based dispatching?
[21:20.860 --> 21:21.860]  Да.
[21:21.860 --> 21:22.860]  Да.
[21:22.860 --> 21:24.860]  Как-то что-то слышал, но...
[21:26.860 --> 21:27.860]  Сейчас.
[21:29.860 --> 21:30.860]  Я забыл.
[21:30.860 --> 21:32.860]  Да, в Uniclock точно есть.
[21:32.860 --> 21:36.860]  Еще в Tuple, кажется, или где-то там Construct and Place.
[21:38.860 --> 21:40.860]  Конструктор.
[21:40.860 --> 21:42.860]  Внимание на экран.
[21:42.860 --> 21:45.860]  У Uniclock есть три конструктора.
[21:45.860 --> 21:48.860]  Всегда принимается mutex на вход.
[21:48.860 --> 21:53.860]  Еще есть дополнительный аргумент deferlockt, trytolockt и adoptlockt.
[21:53.860 --> 21:55.860]  Что это такое?
[21:55.860 --> 21:59.860]  Adoptlockt не блокирует мир.
[21:59.860 --> 22:01.860]  Ну да, считай, что он уже заблокирует.
[22:01.860 --> 22:02.860]  Не суть важна.
[22:02.860 --> 22:07.860]  Главное, что это просто пустые классы, в которых нет никаких данных, структурки,
[22:07.860 --> 22:12.860]  которые используются чисто чтобы выбрать какое из поведений конструктора мы хотим.
[22:12.860 --> 22:14.860]  Почему так делается?
[22:14.860 --> 22:18.860]  Потому что конструкторы в C++ безымянные.
[22:18.860 --> 22:20.860]  В Rasty он говорят с именами.
[22:20.860 --> 22:22.860]  Но у нас тут такая же ситуация.
[22:22.860 --> 22:28.860]  У нас три одинаковых имени, мы хотим как-то их разделить.
[22:28.860 --> 22:38.860]  Ведем теги и будем по тегам в соответствии с тем, кого мы хотим создавать.
[22:43.860 --> 22:45.860]  Вот так вот.
[22:45.860 --> 22:47.860]  Теперь это три честных перегрузки друг друга.
[22:47.860 --> 22:50.860]  И мы даже знаем, как вызвать одну из них.
[22:52.860 --> 22:54.860]  Написать.
[22:58.860 --> 23:00.860]  Create, tag, get.
[23:00.860 --> 23:02.860]  Вот так вот.
[23:02.860 --> 23:04.860]  Ага.
[23:04.860 --> 23:10.860]  У меня есть желание сделать так, чтобы мы не передавали тегу get,
[23:10.860 --> 23:14.860]  а чтобы get оно в часть крейта переместилось.
[23:14.860 --> 23:16.860]  Нет.
[23:16.860 --> 23:19.860]  Подавив себе такие желания, при процессоре зло.
[23:23.860 --> 23:27.860]  Давай, Аркадий, без выпендрежных решений сегодня,
[23:27.860 --> 23:30.860]  потому что хочется успеть и разойтись.
[23:39.860 --> 23:42.860]  Поэтому тег мы сюда вбахиваем.
[23:44.860 --> 23:46.860]  Это раз.
[23:46.860 --> 23:48.860]  А два.
[23:48.860 --> 23:50.860]  Внимание, смешная техника.
[23:50.860 --> 23:56.860]  Вот сейчас все эти сигнатуры create находятся в разных областях видимости.
[23:56.860 --> 24:00.860]  И поэтому, строго говоря, перегрузками друг друга не являются.
[24:00.860 --> 24:06.860]  То есть никогда при лукапе имен мы не сможем одновременно
[24:06.860 --> 24:11.860]  в области видимости найти все крейта, которые есть в этих родителях.
[24:13.860 --> 24:15.860]  Понятную фразу сказал?
[24:15.860 --> 24:17.860]  Давайте сделаем вот так.
[24:20.860 --> 24:24.860]  Using родителей create.
[24:26.860 --> 24:30.860]  Да, есть специальный синтаксис, чтобы из всех родителей
[24:30.860 --> 24:37.860]  собрать все функции с вот таким именем, или переменные, или using, что угодно.
[24:37.860 --> 24:41.860]  В общем, собрать все такие имена create из всех родителей
[24:41.860 --> 24:45.860]  и затянуть их в текущую область видимости.
[24:45.860 --> 24:47.860]  Вот такая тема.
[24:47.860 --> 24:50.860]  Теперь, когда у нас эти имена есть в области видимости,
[24:50.860 --> 24:54.860]  мы можем звать просто create от тега.
[24:54.860 --> 24:58.860]  И все.
[24:58.860 --> 25:04.860]  Нужная перегрузка будет выбрана среди вот этих вот, которые мы явно вытащили из-за...
[25:04.860 --> 25:08.860]  Что-что? Что так лица скорчили?
[25:12.860 --> 25:15.860]  Да, теперь если извне мы используем abstract factory,
[25:15.860 --> 25:18.860]  можно create в треугольных скобочках указать.
[25:18.860 --> 25:22.860]  А тут из-за протек тогда через тега не получится.
[25:22.860 --> 25:24.860]  Ну окей, теги отлично.
[25:24.860 --> 25:29.860]  Это нам сильно упростит ситуацию с concrete factory,
[25:29.860 --> 25:33.860]  с которым мы в ступор встали, не понимая, что делать хотим.
[25:39.860 --> 25:43.860]  Да, потому что ты не знаешь, какие у тебя будут интерфейсы в этом списке.
[25:43.860 --> 25:45.860]  Их сколько годно много может быть.
[25:45.860 --> 25:47.860]  Ну можно янами сделать?
[25:47.860 --> 25:49.860]  Какой янам?
[25:51.860 --> 25:56.860]  Нет, это тебе на вход дают, черт знает, какой набор интерфейсов.
[25:56.860 --> 25:58.860]  Ты не знаешь, какой.
[25:58.860 --> 26:02.860]  Сколько элементов янами делать, какие у них имена давать.
[26:02.860 --> 26:06.860]  Более того, это тебе не поможет, потому что...
[26:06.860 --> 26:08.860]  В чем смысл тегов?
[26:08.860 --> 26:12.860]  В том, что это разные структуры
[26:12.860 --> 26:15.860]  для каждого типа, что ты сюда подставляешь.
[26:15.860 --> 26:20.860]  А соответственно, вот эти функции create с разным интерфейсом в треугольных скобках
[26:20.860 --> 26:22.860]  будут перегрузками друг друга.
[26:22.860 --> 26:25.860]  И можно выбрать конкретную перегрузку,
[26:25.860 --> 26:30.860]  дернув create, но указав конкретный объект типа тега.
[26:30.860 --> 26:32.860]  Вот точно так же, как вот здесь.
[26:32.860 --> 26:35.860]  Можно выбрать конкретный конструктор mutex, который хочется,
[26:35.860 --> 26:40.860]  указав, перекинув туда объект конкретного тега.
[26:40.860 --> 26:43.860]  Дефер-лог-т, фигурные скобки.
[26:43.860 --> 26:45.860]  Это одинаковая техника.
[26:45.860 --> 26:48.860]  Она частая и полезная.
[26:51.860 --> 26:53.860]  Итак.
[26:57.860 --> 26:59.860]  Да нет, так вышло.
[27:00.860 --> 27:02.860]  Кстати, тег еще...
[27:02.860 --> 27:04.860]  Ну, это уже будет не совсем тег,
[27:04.860 --> 27:07.860]  но в него можно передавать какие-нибудь аргументы для паблики,
[27:07.860 --> 27:09.860]  чтобы она их могла обработать.
[27:09.860 --> 27:11.860]  Можно, если...
[27:11.860 --> 27:13.860]  Можно, если хочется.
[27:13.860 --> 27:17.860]  Давайте лучше с конкретной факторой пытаемся ее побороть.
[27:17.860 --> 27:20.860]  Пока что про...
[27:22.860 --> 27:23.860]  Make unique.
[27:23.860 --> 27:26.860]  Сработает? Сработало. Ура.
[27:30.860 --> 27:33.860]  ConcreteFactory.
[27:33.860 --> 27:37.860]  Для случая cat, dog, cow
[27:37.860 --> 27:40.860]  я ожидаю следующее поведение.
[27:40.860 --> 27:43.860]  Сгенерить три функции,
[27:43.860 --> 27:47.860]  которые оверрайдят то, что было в интерфейсе,
[27:47.860 --> 27:50.860]  и вернуть кого?
[27:50.860 --> 27:55.860]  Сфинкса Спаниеля и Блэк-Энгуса.
[27:55.860 --> 27:57.860]  Вот.
[27:57.860 --> 28:03.860]  Для таких двух-тайп теплов я ожидаю такой результат увидеть принципиально.
[28:03.860 --> 28:08.860]  А вот у нас в данном примере сейчас cat только один наследник.
[28:08.860 --> 28:10.860]  Соответственно, у друга тоже только один,
[28:10.860 --> 28:13.860]  но потенциально подразумеваем, что у нас катов, там,
[28:13.860 --> 28:15.860]  всего на десяток,
[28:15.860 --> 28:20.860]  и мы хотим, чтобы для всех этих десятков свой крейс создался.
[28:20.860 --> 28:22.860]  Правильно принимать?
[28:22.860 --> 28:25.860]  Для всех этих десятков свой крейс? Ну да.
[28:25.860 --> 28:28.860]  Хоть тысячу, хоть миллион.
[28:28.860 --> 28:32.860]  В этом суть того, чем мы занимаемся. Мы генерируем иерархию.
[28:32.860 --> 28:36.860]  Итак, вот так должно быть на маленьком примере.
[28:36.860 --> 28:40.860]  Общий случай. Как мы будем действовать?
[28:40.860 --> 28:45.860]  Мы наследуемся публичного Abstract Factory Interfaces.
[28:45.860 --> 28:49.860]  Если мы прямо сейчас, прямо здесь наследуемся от Publick,
[28:49.860 --> 28:54.860]  типа от Abstract Factory, то как мы зауверрайдим?
[28:54.860 --> 29:00.860]  Вот здесь же мы не можем как-то взять и магическим образом написать все эти методы.
[29:00.860 --> 29:02.860]  А, в этом дело. Сейчас.
[29:02.860 --> 29:07.860]  Видимо, нужно раскручиваться по регурсии и имплимитировать это одно.
[29:07.860 --> 29:08.860]  Да.
[29:08.860 --> 29:13.860]  Пишем специализацию, отрезаем Implementation по куску.
[29:13.860 --> 29:15.860]  Зачем?
[29:15.860 --> 29:20.860]  И имплимитируем здесь Mekaray и наследуемся от Beset Handler.
[29:20.860 --> 29:28.860]  Сейчас. Зачем нам по регурсии что-то раскручивать здесь?
[29:28.860 --> 29:31.860]  Потому что это сработает.
[29:31.860 --> 29:33.860]  Нужно определить виртуальные методы.
[29:33.860 --> 29:36.860]  А мы можем определить виртуальные методы только не шаблонно.
[29:36.860 --> 29:39.860]  То есть мы можем делать внутри шаблонного класса, но сам Mekaray не может быть шаблоном.
[29:39.860 --> 29:43.860]  Не-не-не. Это я понимаю. Я пока не понял, зачем.
[29:43.860 --> 29:47.860]  Нет, мы, конечно, можем, как в прошлый раз, делать прослойбы между виртуальным методом и...
[29:47.860 --> 29:49.860]  Да.
[29:49.860 --> 29:51.860]  Но...
[29:51.860 --> 29:53.860]  Ну теперь здесь у нас некрасиво.
[29:53.860 --> 29:57.860]  Здесь какой-то один факт, первый, по названию непонятно.
[29:57.860 --> 30:01.860]  Да сейчас оберток навернем каких-нибудь и все будет нормально.
[30:01.860 --> 30:03.860]  Это первое, что пришло в голову.
[30:03.860 --> 30:08.860]  Но в общем и целом пользователь с Concrete Factory вообще никак не взаимодействует, кроме как создать его.
[30:08.860 --> 30:10.860]  И все.
[30:10.860 --> 30:16.860]  Да, но у нас здесь, кажется, сразу есть небольшая проблема.
[30:16.860 --> 30:26.860]  В Concrete Factory, допустим, у нас есть почка и иерархия наследования, скажем, ну не знаю, A, B, C, D.
[30:26.860 --> 30:32.860]  И Concrete Factory, она же может...
[30:32.860 --> 30:35.860]  Ну сейчас нет, наверное, она даже на более раннем этапе была.
[30:35.860 --> 30:40.860]  Может ли у нас такое быть, что у нас есть одинаковые шаблонные документы?
[30:40.860 --> 30:41.860]  В этом списке?
[30:41.860 --> 30:42.860]  Да.
[30:42.860 --> 30:43.860]  Нет.
[30:43.860 --> 30:45.860]  Не может.
[30:45.860 --> 30:47.860]  Ну ты тамашку какую-нибудь решаешь.
[30:47.860 --> 30:51.860]  Вот там есть задача, где там надо поюникать, посортить списки.
[30:51.860 --> 30:53.860]  Ну вот если надо...
[30:53.860 --> 31:00.860]  Я не понимаю, что можно. Я говорю, что может ли юзер, в смысле не по ошибке, намерен передать...
[31:00.860 --> 31:02.860]  Это бессмысленно.
[31:02.860 --> 31:06.860]  Нет, не может. Все, давай считать, что не может, и таких глупостей не думать.
[31:06.860 --> 31:08.860]  Да, задавите каратора.
[31:08.860 --> 31:10.860]  Давайте не думать о таких глупостях.
[31:10.860 --> 31:12.860]  Что тут не хватает?
[31:12.860 --> 31:16.860]  От наследовательного Crypt Factory с отрезанными глупами.
[31:26.860 --> 31:31.860]  У нас получается, что мы явно никогда не наследуемся от Abstract Factory.
[31:31.860 --> 31:36.860]  Нет, надо. Ну сейчас мы ничего не оверрайдим, вот эта ошибка компиляции будет так-то.
[31:36.860 --> 31:41.860]  А если наследоваться еще одной только Abstract Factory, которая...
[31:41.860 --> 31:43.860]  Нет, нам нужно сначала...
[31:47.860 --> 31:48.860]  Вот здесь...
[31:48.860 --> 31:51.860]  Да, вот здесь мы наследуемся от Abstract Factory только одной.
[31:51.860 --> 31:55.860]  Ну так это не то, что мы ожидаем.
[31:55.860 --> 31:57.860]  Это не то, что мы ожидаем, да.
[31:57.860 --> 32:02.860]  Мы хотим уметь скастить Concrete Factory от всех параметров сразу.
[32:02.860 --> 32:05.860]  Мы хотим, чтобы работал вот такой код.
[32:05.860 --> 32:09.860]  Ну, короче, можно такой костыль навернуть.
[32:09.860 --> 32:11.860]  Давайте внимательно на этот код посмотрим.
[32:11.860 --> 32:14.860]  Уже мы с тегом разобрались, пришла пора.
[32:16.860 --> 32:20.860]  Вот видите, это Unique PTR на Abstract Factory.
[32:20.860 --> 32:24.860]  А туда мы засовываем что-то через Make Unique Concrete Factory.
[32:28.860 --> 32:29.860]  Что?
[32:29.860 --> 32:31.860]  Ну это смысл...
[32:31.860 --> 32:33.860]  Это смысл паттерна Abstract Factory.
[32:33.860 --> 32:35.860]  У тебя где-то написан какой-то код.
[32:36.860 --> 32:41.860]  Minecraft Spawner Spawn Mobs.
[32:41.860 --> 32:44.860]  Если бы Minecraft был написан на C.
[32:50.860 --> 32:53.860]  Ну там плюсы добавили, этим все испортили.
[32:53.860 --> 32:57.860]  И тут мы хотим сделать switch, create.
[32:59.860 --> 33:01.860]  Там по интерфейсу, cut.
[33:01.860 --> 33:05.860]  Ну глупый пример получается, но давайте считать, что там...
[33:08.860 --> 33:12.860]  Ну какой-нибудь интерфейс моб был, или энимул, или еще что-нибудь.
[33:12.860 --> 33:15.860]  Ну план вот такой, да, вообще использование Abstract Factory.
[33:15.860 --> 33:17.860]  Вы где-то создаете конкретную factory,
[33:17.860 --> 33:19.860]  где вы знаете, какие вы хотите наследники.
[33:19.860 --> 33:21.860]  Cat, dog и cow.
[33:21.860 --> 33:23.860]  Потом это передаете в какой-то код,
[33:23.860 --> 33:26.860]  который уже не знает, каких вы наследников используете.
[33:26.860 --> 33:28.860]  И происходит OP.
[33:28.860 --> 33:31.860]  Наследование полиморфизма, инкапсуляция.
[33:31.860 --> 33:35.860]  Вы сокрыли детали того, кого вы там спауните в этом спаунере.
[33:35.860 --> 33:37.860]  Каких именно котов.
[33:37.860 --> 33:39.860]  Ну в этом смысл.
[33:39.860 --> 33:41.860]  Поэтому наша общая Concrete Factory
[33:41.860 --> 33:46.860]  вся целиком должна наследовать Abstract Factory.
[33:46.860 --> 33:50.860]  Нельзя на каждом уровне иерархии наследовать ее кусочек.
[33:50.860 --> 33:52.860]  Итак.
[33:53.860 --> 33:55.860]  Что?
[34:05.860 --> 34:08.860]  Давайте так и сделаем.
[34:08.860 --> 34:10.860]  Это хороший вариант.
[34:10.860 --> 34:13.860]  Потому что все то же самое, что здесь написано сейчас у нас,
[34:13.860 --> 34:16.860]  можно сделать через виртуальное наследование.
[34:17.860 --> 34:22.860]  Что мы хотели сюда написать?
[34:41.860 --> 34:45.860]  Знаете, это зашло достаточно далеко.
[34:45.860 --> 34:48.860]  Давайте, ладно, продолжим без врапера.
[34:52.860 --> 34:56.860]  Нет, виртуальное наследование делает все дороже.
[35:04.860 --> 35:07.860]  Нет, тут виртуальных вызовов ровно столько же,
[35:07.860 --> 35:10.860]  сколько бы если бы вы их руками написали.
[35:11.860 --> 35:12.860]  Zero Cost.
[35:12.860 --> 35:14.860]  Если виртуальное наследование бахнуть,
[35:14.860 --> 35:16.860]  уже не Zero Cost.
[35:19.860 --> 35:21.860]  Ой, ну да.
[35:21.860 --> 35:23.860]  All Interfaces вот так надо.
[35:26.860 --> 35:28.860]  Type to Pal.
[35:28.860 --> 35:30.860]  Вот так, вот так.
[35:32.860 --> 35:33.860]  Вот так.
[35:33.860 --> 35:35.860]  И кажется мы в шоколаде, да?
[35:35.860 --> 35:37.860]  Внимание, мы написали...
[35:37.860 --> 35:41.860]  Вы не передали, нужно передать человеку о наследовании.
[35:42.860 --> 35:45.860]  Да, конечно.
[36:00.860 --> 36:02.860]  Здесь нужно прокинуть.
[36:02.860 --> 36:04.860]  А вот я прокинул All Interfaces.
[36:04.860 --> 36:07.860]  И при наследовании нужно прокинуть наследника.
[36:08.860 --> 36:11.860]  Наследник, ну вот этот торт мы наследуемся.
[36:11.860 --> 36:13.860]  Да.
[36:19.860 --> 36:21.860]  Любите шаблоны?
[36:21.860 --> 36:23.860]  Я их люблю.
[36:23.860 --> 36:27.860]  Ну вот с такие моменты я начинаю делать вот это вот мое любимое.
[36:27.860 --> 36:31.860]  Потому что я не могу читать, что тут написано, если честно.
[36:31.860 --> 36:34.860]  Вот так стало чуть полегче.
[36:37.860 --> 36:39.860]  Да, есть у нас на работе...
[36:43.860 --> 36:46.860]  Есть у нас на работе люди, которые вот так мне отвечают на вопрос,
[36:46.860 --> 36:50.860]  почему у нас лимит 135 символов в Clang-формате.
[36:51.860 --> 36:53.860]  Ну что тебе, просто купи монитор побольше.
[36:53.860 --> 36:55.860]  Что, какие проблемы?
[36:59.860 --> 37:01.860]  Да.
[37:03.860 --> 37:06.860]  Окей, сейчас примерно понятно, что происходит.
[37:07.860 --> 37:09.860]  Паки отщипываем, All Interfaces прокидываем.
[37:09.860 --> 37:13.860]  Надеюсь, тем, кто сидит молча, тоже хоть чуть-чуть понятно.
[37:22.860 --> 37:24.860]  По-моему, не квадрат.
[37:24.860 --> 37:27.860]  Потому что мы сделали по сути ровно то, что на этом слайде.
[37:29.860 --> 37:32.860]  Тут предлагали это с какими-то там промежуточными типами,
[37:32.860 --> 37:35.860]  но мы вот просто в лоб пошли и сделали.
[37:38.860 --> 37:41.860]  Вот, линейная иерархия.
[37:41.860 --> 37:47.860]  В конце наша абстракт-факторе, в корне там что-то.
[37:50.860 --> 37:52.860]  Знаете, единственное, что...
[37:52.860 --> 37:54.860]  В принципе, да, давайте запустим.
[37:54.860 --> 37:57.860]  Вот тут закомментируем про Tupel.
[37:58.860 --> 38:01.860]  И попробуем запустить.
[38:03.860 --> 38:05.860]  Во-первых, оно скомпилировалось,
[38:05.860 --> 38:08.860]  во-вторых, написало Sphinx.
[38:08.860 --> 38:10.860]  А что я тут пишу?
[38:12.860 --> 38:14.860]  Видите?
[38:15.860 --> 38:17.860]  Работает.
[38:18.860 --> 38:20.860]  Меняем на Kao.
[38:20.860 --> 38:22.860]  Какой TypeID напишет?
[38:22.860 --> 38:24.860]  Black Angle?
[38:26.860 --> 38:29.860]  Не знаю. TypeID это...
[38:31.860 --> 38:34.860]  Implementation Define какая-то штука.
[38:34.860 --> 38:36.860]  Не интересно.
[38:37.860 --> 38:41.860]  Стандарт не может требовать, что у тебя TypeID.name выводит.
[38:42.860 --> 38:45.860]  Вас не смущает, да? TypeID.name печатает,
[38:45.860 --> 38:49.860]  какой на самом деле тип в runtime лежит под этой штукой.
[38:49.860 --> 38:52.860]  Мне просто было лень писать метод MakeSound
[38:52.860 --> 38:56.860]  и вписывать там Meow и Moo всякие, как обычно делают.
[38:56.860 --> 38:59.860]  Но по сути, это ровно то, что ожидали, то и получили.
[38:59.860 --> 39:02.860]  Мы чисто по интерфейсу абстракт-факторе
[39:02.860 --> 39:05.860]  и вернули Create для коровы и получили Black Angle,
[39:05.860 --> 39:08.860]  не зная, что на самом деле будет.
[39:08.860 --> 39:10.860]  Теперь в чем понт?
[39:10.860 --> 39:12.860]  Мы добавляем какой-то новый интерфейс
[39:12.860 --> 39:15.860]  в всю эту иерархию, наш прекрасный класс.
[39:15.860 --> 39:18.860]  Просто ее сюда дописываем, сюда дописываем то, что нужно,
[39:18.860 --> 39:21.860]  и дальше весь код продолжает работать.
[39:24.860 --> 39:27.860]  Прекрасная идея. Давайте удалим собаку.
[39:27.860 --> 39:30.860]  А, тут не было лукавства.
[39:30.860 --> 39:33.860]  А, тут было лукавство, смотрите.
[39:33.860 --> 39:36.860]  Мы забыли удалить эту штуку.
[39:36.860 --> 39:39.860]  Ой, обманка, но вы повелись, ха-ха.
[39:39.860 --> 39:42.860]  Ну, все равно работает.
[39:47.860 --> 39:50.860]  Можно обернуть кучу оберток, и все будет нормально.
[39:50.860 --> 39:53.860]  Обертки.
[39:53.860 --> 39:56.860]  Ну, юзинги, обертки и там всякие.
[39:56.860 --> 39:59.860]  Все сделайте, если захотите.
[39:59.860 --> 40:01.860]  Ну, так давайте вырежем собаку.
[40:01.860 --> 40:04.860]  Время к концу. Давайте вырежем собаку.
[40:04.860 --> 40:07.860]  Почему бы и нет.
[40:10.860 --> 40:13.860]  Ну, сбилделось.
[40:13.860 --> 40:16.860]  И она написала. Sphinx.
[40:16.860 --> 40:19.860]  А может Create по-другому вызвать?
[40:19.860 --> 40:22.860]  Да, сейчас мы его явно через этот Black Angle.
[40:22.860 --> 40:25.860]  Да, давайте вернемся к той идее классной,
[40:25.860 --> 40:28.860]  что вообще-то мы хотим вот так вызывать.
[40:28.860 --> 40:31.860]  Будет ли это работать?
[40:31.860 --> 40:34.860]  Нифига, работает.
[40:34.860 --> 40:37.860]  А?
[40:39.860 --> 40:42.860]  А, неудачный кет.
[40:42.860 --> 40:49.860]  Ну, потому что мы везде публичное наследование бахнули.
[40:49.860 --> 40:52.860]  Ну, вот тут вопрос, почему это сработало?
[40:52.860 --> 40:55.860]  Почему?
[40:55.860 --> 40:58.860]  У нас в самой Abstract Factory еще вот эта штука была.
[40:58.860 --> 41:01.860]  А, ну нет, окей, здесь понятно, почему работает.
[41:01.860 --> 41:04.860]  Просто вот работает и все.
[41:09.860 --> 41:12.860]  Да.
[41:12.860 --> 41:15.860]  Private, public.
[41:15.860 --> 41:18.860]  Тыры-пыры. Ну, тут можно еще много чего запрятать.
[41:18.860 --> 41:21.860]  Давайте считать...
[41:21.860 --> 41:26.860]  У нас остается беда еще, что мы публично наследуемся
[41:26.860 --> 41:35.860]  от кусков имплементации, хотя бы private.
[41:35.860 --> 41:38.860]  Но при этом нам нужно все еще публично...
[41:38.860 --> 41:41.860]  Но при этом кускок один нашей имплементации
[41:41.860 --> 41:44.860]  наследуется Abstract Factory и он уже...
[41:44.860 --> 41:49.860]  Смотри, да, мы не можем здесь сделать не публичное наследование,
[41:49.860 --> 41:53.860]  потому что тогда мы не сможем прикастить вот в этой строчке
[41:53.860 --> 41:56.860]  Concrete Factory, Abstract Factory.
[41:56.860 --> 41:59.860]  Не можем, не мы...
[42:06.860 --> 42:09.860]  Чего?
[42:09.860 --> 42:13.860]  А, явно оператор каста можно написать, но это, конечно, дичь.
[42:13.860 --> 42:16.860]  Ну, например.
[42:16.860 --> 42:19.860]  Ну, это все равно неудобно.
[42:19.860 --> 42:22.860]  Короче, основной идею вы поняли, правда?
[42:22.860 --> 42:25.860]  А дальше ее можно крутить в очень много разных направлений.
[42:25.860 --> 42:28.860]  Давайте сейчас не будем вот это вот докручивать,
[42:28.860 --> 42:31.860]  потому что на практике вы такой не встретите,
[42:31.860 --> 42:34.860]  если вы не будете его крутить.
[42:34.860 --> 42:37.860]  И мы уже все это уже мыслим,
[42:37.860 --> 42:40.860]  потому что мы все это уже мыслим,
[42:40.860 --> 42:43.860]  и мы не будем вот это вот докручивать,
[42:43.860 --> 42:46.860]  потому что на практике вы такой не встретите нигде,
[42:46.860 --> 42:49.860]  только в книжке Александреско.
[42:49.860 --> 42:52.860]  А зато покрутим тюпл. Я хочу написать стд тюпл.
[42:52.860 --> 42:55.860]  Мне скучно этим прекрасным вечером, субботним.
[42:55.860 --> 42:58.860]  Хочу вот такой тюпл, чтобы он работал.
[42:58.860 --> 43:01.860]  Сможете придумать?
[43:01.860 --> 43:04.860]  Короче, сначала мы создаем тип tuple-leaf,
[43:04.860 --> 43:07.860]  у которого два шаблонных параметра
[43:07.860 --> 43:10.860]  и size t index.
[43:10.860 --> 43:13.860]  Индекс нужен для того, чтобы можно было
[43:13.860 --> 43:16.860]  иметь в себе одинаковый тип,
[43:16.860 --> 43:19.860]  и при этом можно было заделюсить,
[43:19.860 --> 43:22.860]  какое имя, хотя бы по индексу.
[43:22.860 --> 43:25.860]  Вот. Ну там, не знаю, какой-нибудь метод
[43:25.860 --> 43:28.860]  фигу написать, фигу.
[43:28.860 --> 43:31.860]  Затем мы задаем
[43:31.860 --> 43:34.860]  template class t tuple-base
[43:34.860 --> 43:37.860]  просто форму декларации,
[43:37.860 --> 43:40.860]  просто декларация без
[43:40.860 --> 43:43.860]  struct tuple-base.
[43:43.860 --> 43:46.860]  Дальше значим. Затем template class многоточие ats,
[43:50.860 --> 43:53.860]  еще size t многоточие indexes,
[43:59.860 --> 44:02.860]  tuple-base под
[44:04.860 --> 44:07.860]  сейчас.
[44:07.860 --> 44:10.860]  Наверное, нужно все-таки,
[44:10.860 --> 44:13.860]  чтобы это нормально работало,
[44:13.860 --> 44:16.860]  нужно в декларации
[44:16.860 --> 44:19.860]  class t и class...
[44:19.860 --> 44:22.860]  ну еще оставить pack в декларации.
[44:22.860 --> 44:25.860]  Просто class многоточие, кажется.
[44:25.860 --> 44:28.860]  Давайте просто вот так сделаем.
[44:28.860 --> 44:31.860]  Теперь мы...
[44:31.860 --> 44:34.860]  ОК.
[44:34.860 --> 44:37.860]  Да, хорошая мысль.
[44:37.860 --> 44:40.860]  Integer sequences от...
[44:40.860 --> 44:43.860]  Сначала integer sequences,
[44:43.860 --> 44:46.860]  потом...
[44:53.860 --> 44:56.860]  Давай просто index sequences.
[44:56.860 --> 44:59.860]  Ну да, index sequences.
[44:59.860 --> 45:02.860]  Из...
[45:02.860 --> 45:05.860]  Да.
[45:05.860 --> 45:08.860]  И эта штука публично
[45:08.860 --> 45:11.860]  наследуется от...
[45:11.860 --> 45:14.860]  Нужно вывести по голове.
[45:14.860 --> 45:17.860]  Зачем по голове выводить?
[45:17.860 --> 45:20.860]  Все готово.
[45:20.860 --> 45:23.860]  Мы можем теперь публично наследоваться
[45:23.860 --> 45:26.860]  от tuple-leaf,
[45:26.860 --> 45:29.860]  s и s многоточие.
[45:29.860 --> 45:32.860]  Скатер иерархия.
[45:32.860 --> 45:35.860]  Тут неважно, как наследоваться.
[45:38.860 --> 45:41.860]  Вот.
[45:41.860 --> 45:44.860]  И теперь мы в tuple
[45:44.860 --> 45:47.860]  наследуемся от
[45:47.860 --> 45:50.860]  tuple-base ts...
[45:50.860 --> 45:53.860]  Нет, первой sequence нет.
[45:53.860 --> 45:56.860]  Ура!
[45:56.860 --> 45:59.860]  Что мы наколдовали!
[46:02.860 --> 46:05.860]  По обоим одновременно.
[46:05.860 --> 46:08.860]  Если вы не знали, что так можно делать,
[46:08.860 --> 46:11.860]  то сегодня узнали.
[46:11.860 --> 46:14.860]  Можно в любом выражении,
[46:14.860 --> 46:17.860]  в любом вообще выражении,
[46:17.860 --> 46:20.860]  написать сколько угодно паков много,
[46:20.860 --> 46:23.860]  но все одинаковые длины.
[46:23.860 --> 46:26.860]  Потом, после этого выражения,
[46:26.860 --> 46:29.860]  написать троиточие, и оно все у вас развернется.
[46:29.860 --> 46:32.860]  Линея.
[46:32.860 --> 46:35.860]  Не каждая с каждой, а как зип.
[46:35.860 --> 46:38.860]  Зип в питоне.
[46:38.860 --> 46:41.860]  Да.
[46:41.860 --> 46:44.860]  Это так работает.
[46:44.860 --> 46:47.860]  А?
[46:47.860 --> 46:50.860]  Проверка на одинаковую длину.
[46:50.860 --> 46:53.860]  Отлично.
[46:53.860 --> 46:56.860]  В tuple-leaf у нас будет еще значение храниться.
[46:56.860 --> 46:59.860]  В tuple-leaf будет храниться значение, да.
[46:59.860 --> 47:02.860]  Теперь.
[47:02.860 --> 47:05.860]  Теперь я хочу гетать по типу
[47:05.860 --> 47:08.860]  и гетать по индексу.
[47:08.860 --> 47:11.860]  А нужно, наверное,
[47:11.860 --> 47:14.860]  сделать один класс,
[47:14.860 --> 47:17.860]  который касается tuple-leaf.
[47:17.860 --> 47:20.860]  А, нельзя специализация.
[47:20.860 --> 47:23.860]  Тут придется
[47:23.860 --> 47:26.860]  мучиться линейным поиском.
[47:26.860 --> 47:29.860]  Можно просто перегрузку.
[47:29.860 --> 47:32.860]  Тогда Даня-то знает все.
[47:32.860 --> 47:35.860]  Слышали идею
[47:35.860 --> 47:38.860]  кто-нибудь?
[47:38.860 --> 47:41.860]  Что ты сделал тегом?
[47:41.860 --> 47:44.860]  Мы хотим гет сделать от типа и от индекса.
[47:44.860 --> 47:47.860]  И то, и другое?
[47:47.860 --> 47:50.860]  Нет.
[47:50.860 --> 47:53.860]  Смотри.
[47:53.860 --> 47:56.860]  Это тоже самое хочется.
[47:56.860 --> 47:59.860]  Можно просто завести две перегрузки.
[47:59.860 --> 48:02.860]  Перегрузка тега от индекса.
[48:02.860 --> 48:05.860]  Пока сделаем по индексу, потом подумаем.
[48:05.860 --> 48:08.860]  Ладно, давайте писать.
[48:08.860 --> 48:11.860]  Type.
[48:18.860 --> 48:21.860]  Одновременно.
[48:24.860 --> 48:27.860]  Нет, типы могут быть одинаковыми,
[48:27.860 --> 48:30.860]  но для этого мы сделали индекс.
[48:30.860 --> 48:33.860]  Если ожидание такое, что если мы написали tuple
[48:33.860 --> 48:36.860]  с несколькими разными типами,
[48:36.860 --> 48:39.860]  то у нас будет ошибка.
[48:42.860 --> 48:45.860]  Это стандартный tuple так работает,
[48:45.860 --> 48:48.860]  если кто-то не знал.
[48:48.860 --> 48:51.860]  Итак.
[48:51.860 --> 48:54.860]  Есть раз, есть два.
[48:54.860 --> 48:57.860]  Нет, конечно.
[48:57.860 --> 49:00.860]  Сейчас идея, тема всего происходящего,
[49:00.860 --> 49:03.860]  это генерация иерархий.
[49:03.860 --> 49:06.860]  Тепла во многих стандартных библиотеках,
[49:06.860 --> 49:09.860]  она выглядит ровно так же, как Александреску
[49:09.860 --> 49:12.860]  20 лет назад предложил генерировать.
[49:12.860 --> 49:15.860]  Мы с каторой иерархию сейчас сделали.
[49:15.860 --> 49:18.860]  А теперь нам нужно диспетчеризироваться.
[49:18.860 --> 49:21.860]  Опять же, такая же проблема,
[49:21.860 --> 49:24.860]  как с create.
[49:24.860 --> 49:27.860]  Есть метод byType, который вернет нам value.
[49:27.860 --> 49:30.860]  Но вопрос, какую конкретную value мы хотим получить?
[49:30.860 --> 49:33.860]  Чувствуете аналогию с create?
[49:33.860 --> 49:36.860]  Tag. Просто по тегу делаем так,
[49:36.860 --> 49:39.860]  что они все друг к другу к перегрузке.
[49:39.860 --> 49:42.860]  И с каким тегом вызвали, то и получим.
[49:42.860 --> 49:45.860]  Я подумал, мне лучше совсем чуть-чуть
[49:45.860 --> 49:48.860]  сделать вместо этого один метод.
[49:48.860 --> 49:51.860]  Гет лип,
[49:51.860 --> 49:54.860]  у которого return type
[49:54.860 --> 49:57.860]  найдет
[49:57.860 --> 50:00.860]  тип листка,
[50:00.860 --> 50:03.860]  полный.
[50:03.860 --> 50:06.860]  Зачем?
[50:06.860 --> 50:09.860]  Если мы тюпл протокол делаем,
[50:09.860 --> 50:12.860]  тогда так будет чуть-чуть попроще, наверное.
[50:12.860 --> 50:15.860]  Не думая о сложном, думая о простом.
[50:15.860 --> 50:18.860]  Усложнить всегда в себе жизнь можно.
[50:18.860 --> 50:21.860]  Как вы могли уже понять по нашим домашкам,
[50:21.860 --> 50:24.860]  там всегда можно сделать легко, просто и быстро,
[50:24.860 --> 50:27.860]  а можно начать усложнять себе жизнь
[50:27.860 --> 50:30.860]  и растягивать с часа до 2-3-8 часов время решения.
[50:30.860 --> 50:33.860]  И его тоже.
[50:33.860 --> 50:36.860]  Давайте сейчас не будем,
[50:36.860 --> 50:39.860]  у нас осталось буквально 10 минут.
[50:39.860 --> 50:42.860]  Ну что,
[50:42.860 --> 50:45.860]  у нас осталось, чтобы Get работал.
[50:45.860 --> 50:48.860]  Но я думаю, вам очевидно. Или нет?
[50:48.860 --> 50:51.860]  Да.
[51:01.860 --> 51:04.860]  Только это там
[51:04.860 --> 51:07.860]  классный
[51:07.860 --> 51:10.860]  test, туда-сюда,
[51:10.860 --> 51:13.860]  sound,
[51:13.860 --> 51:16.860]  тюп и
[51:21.860 --> 51:24.860]  так, да?
[51:24.860 --> 51:27.860]  И значит за фронтаем.
[51:30.860 --> 51:33.860]  Шедует название пака.
[51:33.860 --> 51:36.860]  У-у-у-у.
[51:36.860 --> 51:39.860]  Сейчас вообще тогда это будет по шаблонам определять.
[51:39.860 --> 51:42.860]  Нет, так не работает.
[51:45.860 --> 51:48.860]  Ладно, у нас же тут ADL.
[51:48.860 --> 51:51.860]  Ребят, у нас тут ADL сегодня, да?
[51:51.860 --> 51:54.860]  Давайте прямо здесь и объявим.
[51:54.860 --> 51:57.860]  Пусть ADL нам ее находит.
[51:57.860 --> 52:00.860]  Не нужен теперь, да.
[52:00.860 --> 52:03.860]  Просто себя принимаем.
[52:03.860 --> 52:06.860]  Видите, да?
[52:06.860 --> 52:09.860]  Нишен прямо в классе.
[52:09.860 --> 52:12.860]  И такой же для
[52:12.860 --> 52:15.860]  AST.
[52:15.860 --> 52:18.860]  Только непонятно, какой тип мы вернем.
[52:18.860 --> 52:21.860]  Но я говорю, что мы вернем автоамперсант
[52:21.860 --> 52:24.860]  и всем становится сразу спокойно.
[52:31.860 --> 52:34.860]  Неважно.
[52:34.860 --> 52:37.860]  Я сейчас полностью забил на перфект форвардинг.
[52:37.860 --> 52:40.860]  Это...
[52:40.860 --> 52:43.860]  Кажется, вообще во всем курсе метапроги
[52:43.860 --> 52:46.860]  сейчас нигде ни разу не расписывается подробно,
[52:46.860 --> 52:49.860]  как правильно перфект форвардить все.
[52:49.860 --> 52:52.860]  Возможно, стоит один раз это разобрать, но явно не сегодня.
[52:52.860 --> 52:55.860]  Ну, это раз, во-вторых, везде форвард,
[52:55.860 --> 52:58.860]  еще noexept от noexept от весь код функций,
[52:58.860 --> 53:01.860]  ну и еще там пару деталей.
[53:01.860 --> 53:04.860]  А requires requires весь код функции
[53:04.860 --> 53:07.860]  тоже надо написать.
[53:07.860 --> 53:10.860]  Итак, смотрите, оно компилируется.
[53:10.860 --> 53:13.860]  Если в факторе...
[53:18.860 --> 53:21.860]  Нет, это нужно не для чтения ошибок,
[53:21.860 --> 53:24.860]  а для...
[53:24.860 --> 53:27.860]  Да, SFINAE friendly overload resolution.
[53:27.860 --> 53:30.860]  Ну вот, работает. Записали по
[53:30.860 --> 53:33.860]  типу, достали по индексу.
[53:33.860 --> 53:36.860]  Внезапно. Ларчик просто открывался.
[53:36.860 --> 53:39.860]  На этом предлагаю закончить...
