[00:00.000 --> 00:08.880]  Окей, быстрая сортировка. Что это такое? Почему она называется быстрая? Откуда взялась вот эта
[00:08.880 --> 00:14.520]  то самая быстрота? И все считают, что, блин, она такая классная, такая хорошая, или же, наоборот,
[00:14.520 --> 00:23.320]  есть какие-то проблемы. А в чем вообще смысл быстрой сортировки? Ну, на самом деле идеи достаточно
[00:23.320 --> 00:27.920]  просты. У каждой сортировок достаточно простые идеи, как, я думаю, вы все поняли. Вот вы уже
[00:27.920 --> 00:36.160]  смотрели сортировки, которые там были. Быстрая сортировка не исключение. У нее просто идея следующего
[00:36.160 --> 00:43.920]  характера. Если merge sort сначала разбивал все до мелких кусочков, потом их соединял, то quick
[00:43.920 --> 00:51.560]  sort предлагает делать следующее. Давайте возьмем какой-то из элементов, скажем, что он будет нашим
[00:51.560 --> 00:59.960]  опорным в данный момент. Опорный, от которого мы как раз-таки сейчас отталкиваемся. И просто поместим
[00:59.960 --> 01:08.320]  его так и поменяем наш массив так, что слева от опорного элемента будут лежать все элементы,
[01:08.320 --> 01:15.200]  которые меньше него, а справа от опорного все больше либо равные. Как-то мы должны это сделать. И
[01:15.200 --> 01:24.360]  вот если мы как-то это сделаем, то повторим эту операцию для левой и правой куска и еще раз там
[01:24.360 --> 01:29.560]  отсортируем таким образом. И таким образом наши опорные элементы выстроятся в необходимую нам
[01:29.560 --> 01:36.040]  последовательность. Суть примерно такая. Ну, это логично взять что-то посерединке и сказать, ну типа,
[01:36.040 --> 01:41.880]  давайте мы свопаем все вокруг. Вот как бы он хотя бы на своем месте. А вот там уже дальше мы разберемся.
[01:41.880 --> 01:51.200]  Здесь ровно такой же смысл, который у нас есть. На всякий случай напомню вам, что такое сортировка и
[01:51.200 --> 01:59.840]  зачем мы ее делаем. Задачу сортировки, наверное, вы уже видите третью лекцию подряд. Вот это то,
[01:59.840 --> 02:06.160]  что касается самой быстрой сортировки. Что касается самого алгоритма, алгоритм достаточно простой.
[02:06.160 --> 02:14.440]  Мы все еще выбираем тот самый опорный элемент и делаем так, что все элементы левее меньше,
[02:14.440 --> 02:21.160]  все элементы правее не меньше. То, что могут быть равные, например. Ну или как-то их там распределяем.
[02:21.160 --> 02:28.320]  Может быть слева у нас будет не больше, а справа больше. Здесь на ваше усмотрение. И повторяем этот
[02:28.320 --> 02:32.320]  алгоритм для всех остальных частей. Почему мы осознаем, что эта сортировка должна быть хоть
[02:32.320 --> 02:39.840]  сколько-то быстрой? А потому что мы разбиваем наш массив на два таких кусочка и в голове предполагаем,
[02:39.840 --> 02:47.080]  что типа, блин, а в этом случае-то логично, что у нас может получиться так, что у нас два кусочка этих
[02:47.080 --> 02:54.280]  равных, значит мы уменьшили размеры массивов вдвое. Получили тот самый алгоритм и такие, ну все,
[02:54.280 --> 03:02.920]  мы получили что-то за НЛГ. Это грубое объяснение того, почему ее так назвали первоначально. Более
[03:02.920 --> 03:07.960]  качественное мы сейчас с вами будем рассматривать. Вообще, если рассмотреть быструю сортировку,
[03:07.960 --> 03:17.480]  у нее всего лишь вот такая реализация. А вот. И в этой реализации самое главное это partition.
[03:17.480 --> 03:25.080]  Partition, который непонятен, что он там вообще делает и как он правильно разбивает здесь. Что же
[03:25.080 --> 03:32.280]  здесь происходит? То есть, еще раз, мы берем тот самый pivot. Pivot — это опорный элемент. У него
[03:32.280 --> 03:39.560]  такие, так называют его, это так перевод работает. И он выбирается с помощью того самого partition.
[03:39.560 --> 03:44.960]  Partition как-то переставляет элементы, а дальше мы запускаем нашу быструю сортировку от двух
[03:44.960 --> 03:54.600]  кусочков слева и справа. Согласны? Есть какие-то пока в этот момент вопросы? Нет. А теперь вопрос
[03:54.600 --> 04:02.000]  у меня к вам. А вот для partition, в вашем представлении, как это можно делать?
[04:02.000 --> 04:13.960]  Существует несколько видов разбиений того, как это можно делать. А то, что сейчас рассказала
[04:13.960 --> 04:20.820]  Дель, плюс-минус похоже на одно из разбиений. Там на самом деле реализации много разных. А вас там
[04:20.820 --> 04:32.360]  истерика у еще одних. Как это работает? Ладно. В общем-то, когда мы с вами говорим про разбиения,
[04:32.360 --> 04:40.920]  выделяет несколько разбиений между собой. Это разбиение ламуто, разбиение хара и разбиение
[04:40.920 --> 04:50.160]  на три части. Его никто конкретно не придумал. Во всяком случае, я честно не видел. Что касается
[04:50.160 --> 04:59.200]  разбиения ламуто, это одно из разбиений, которое было придумано в момент примерно этой сортировки,
[04:59.200 --> 05:06.160]  когда ее придумали. И она использует там всего лишь один указатель. Указатель не в плане того,
[05:06.160 --> 05:13.960]  как вы представляете это в плюсах, не звездочку. А указатель в плане индексов. Разбиение хара
[05:13.960 --> 05:22.800]  же использует два таких указателя. И в этом случае мы можем сказать о следующем, что вообще
[05:22.800 --> 05:33.400]  быструю сортировку называют сортировкой хара. У него все началось. Так что с ней как-то нужно будет
[05:33.400 --> 05:38.400]  взаимодействовать. Ну и разбиение на три части, одно из самых хардкорных, которое есть, и вам придется
[05:38.400 --> 05:47.440]  с ним попробовать встретиться. Иначе у вас будет грустно все в контесте. Но начнем с разбиения
[05:47.440 --> 05:56.160]  ламуто. Разбиение ламуто достаточно простое. Возьмем опорный элемент, самый левый или самый
[05:56.160 --> 06:02.720]  правый элемент. Все просто. Так как у нас массив, мы не знаем ни о его структуре ничего,
[06:02.720 --> 06:10.440]  все элементы между собой как-то рандомизировано имеют вот тот самый знак отношения. Кто-то меньше,
[06:10.440 --> 06:17.120]  кто-то больше. И поэтому неважно, что возьмем мы первый или последний, или серединку, или третий,
[06:17.120 --> 06:25.360]  или пятый, или восьмой. Не суть важна. Здесь именно такой же смысл. Поэтому давайте возьмем
[06:25.360 --> 06:34.760]  первый, так как данные приходят к нам специально разные. Возьмем его и сделаем примерно следующее.
[06:34.760 --> 06:40.860]  Вот здесь я буду уже рисовать на доске, поэтому уж, извините, в презентацию попозже вам все это
[06:40.860 --> 06:49.120]  добавлю. Если мы говорим с вами о разбиении хара, то работает примерно по следующему образу. Вот у нас
[06:49.120 --> 06:58.160]  есть нулевой какой-то элемент, и мы начинаем с ним работу. Для этого нам нужно будет несколько
[06:58.160 --> 07:08.840]  один указатель, который будет показывать, а куда нам встать тем или иным элементом. Я сейчас
[07:08.840 --> 07:15.360]  покажу промежуточный шаг, и от него вы поймете, что у нас происходит дальше. Смотрите, я хочу
[07:15.360 --> 07:19.920]  разделить массив так. Вот предположим, что вот эта часть еще не обработанная.
[07:25.920 --> 07:32.880]  Не обработанная. Вот. А вот это уже обработанная. И в этой обработанной части мы скажем, что вот эти
[07:32.880 --> 07:37.920]  все элементы, вот здесь вот давайте я напишу какое-нибудь значение вал, вот здесь вот меньше
[07:37.920 --> 07:44.400]  этого значения вал, а здесь больше этого значения вал. Я не рассматриваю больше либо равно, но можно
[07:44.400 --> 07:50.880]  их сюда там отнести, это не суть важная. И тогда в этом случае скажите мне, куда должен стать мой
[07:50.880 --> 08:06.560]  пивод? Между чем? Ну по вот этой линии, правда? Ну я говорю, я предполагаю, что это не важно для
[08:06.560 --> 08:15.520]  меня. Вот, можно сделать так. Вы можете сюда равно отнести. Не суть важная. А по-хорошему, если я буду
[08:15.520 --> 08:19.960]  говорить, что мне необходимо вставить элемент топорный, то я его должен вставить в ту самую
[08:19.960 --> 08:26.600]  водораздельную линию. Как я это могу сделать? Очень просто, смотрите. Возьму элемент, который
[08:26.600 --> 08:34.080]  лежит левее вот этой линии. Согласны ли вы с тем, что вот этот элемент, ну х? Что х меньше,
[08:34.080 --> 08:47.360]  чем это значение? А если я поменяю х и value, то что в этом случае произойдет? А? Ничего не
[08:47.360 --> 08:54.200]  нарушится, потому что value станет здесь, х станет здесь, все элементы от вот этого кусочка теперь
[08:54.200 --> 09:02.760]  будут лежать здесь, и они будут меньше, а все элементы здесь больше. Окей? Это понятно пока?
[09:02.760 --> 09:10.840]  Хорошо. Это первое, что нужно будет делать в самом конце, когда мы обработаем весь массив. И мы
[09:10.840 --> 09:18.760]  сегодня позовем каких-нибудь шесть смелых людей побыть тем самым массивом. Вот. И попробуем с вами
[09:18.760 --> 09:25.160]  эту самую сортировку. Так вот, предположим, что у нас есть уже вот такой вот обработанный кусочек,
[09:25.160 --> 09:31.560]  и есть вот какая-то необработанная его часть. Что в этом случае я делаю? Я смотрю на следующий
[09:31.560 --> 09:42.320]  элемент. Какой-нибудь у? Если у больше, то мне что-то нужно тут делать? Нет. То есть я могу
[09:42.320 --> 09:48.240]  просто дальше взять и продолжить эту линию, и у меня не нарушится вот это состояние. Согласны?
[09:48.240 --> 10:01.320]  А потом возьму z, и z будет меньше. То в этом случае z куда я должен поместить? Куда-то влево. Правда?
[10:01.320 --> 10:08.720]  А теперь давайте вот с той же хитростью, которую мы поставили вот это вот сюда, мы сделаем просто это
[10:08.720 --> 10:18.840]  вот сюда. Вот здесь вот t какой-нибудь. И я поменяю этот t с z. Скажите мне, вот я эту линию сдвинул,
[10:18.840 --> 10:29.080]  получается. И когда я z сюда помещу, а t сюда, у меня будет продолжаться то самое состояние, которое мне
[10:29.080 --> 10:40.720]  было необходимо? Все поняли, что я сейчас сделал или нет? А какая разница? Мне же главное,
[10:40.720 --> 10:48.320]  чтобы pivot был там, где слева от него все меньше, справа от него все больше. Мы не знаем отношения
[10:48.320 --> 10:57.360]  между этими в левой части, какие там элементы между собой. Мне не суть важна. Да? Value только в самом
[10:57.360 --> 11:03.440]  конце, когда мы закончим со всем этим. То есть смотрите, с точки зрения реализации, что мы должны
[11:03.440 --> 11:09.080]  делать? Мы должны делать следующее. Мы смотрим на элементы, если встречаем больше, то просто забиваем,
[11:09.080 --> 11:16.680]  а вот если встречаем меньше, то в этом случае эти элементы меньше. Мы должны взять и поместить вот
[11:16.680 --> 11:23.680]  ровно на край справа от той стороны, где мы говорим, что у нас вот это разделение на большее,
[11:23.680 --> 11:30.000]  меньшее value. И просто меняем их местами. Согласны ли вы, что в самом начале, когда у меня все не
[11:30.000 --> 11:37.680]  обработано, я могу сказать, что я просто нахожусь вот здесь? У меня просто нету. У меня нулевая
[11:37.680 --> 11:45.360]  часть меньше, а нулевая часть больше. Я ничего не обработал, поэтому я нахожусь здесь. А дальше
[11:45.360 --> 11:55.920]  начинаете. Понятно, что я сейчас сделал. А теперь давайте. Мне нужно семь добровольцев, а из вас шесть
[11:55.920 --> 12:04.400]  будет сортировкой, а один тем самым партишнам. Кто хочет попробовать? Отлично. Выходите, выходите. Не
[12:04.400 --> 12:13.520]  бойтесь. Вы даже в камеру упадете. Давайте вот куда-нибудь сюда. Раз, два, три. А что? Нет, я на вас буду
[12:13.520 --> 12:23.080]  показывать. Да нет. Все, отлично, отлично, отлично. Нужен еще один, и ты будешь той самой сортировкой.
[12:23.080 --> 12:34.360]  Только давайте, чтобы было хоть как-то интересно, давай вот тебя вот сюда поставим. А теперь смотрите,
[12:34.360 --> 12:43.160]  а вы вот как-нибудь свопнитесь с ними, а то вы... Вот так уже хоть немного лучше. Отлично. Вот
[12:43.200 --> 12:51.560]  теперь смотри, а ты тот самый партишн, который должен выполнять всю эту функцию. Ты должен взять себе
[12:51.560 --> 12:59.320]  опорный элемент. Правильно. Как тебя зовут, скажи? Саша. Отлично. Вот Саша, опорный элемент. Давай
[12:59.320 --> 13:07.560]  по росту. Ну типа по росту адекватнее всего здесь будет. Как это делать? Отлично. И мы начинаем идти. В самом
[13:07.560 --> 13:13.800]  начале мы находимся, ну грубо говоря, вот здесь. Правда? А вот. И мы смотрим, у нас появляется,
[13:13.800 --> 13:23.520]  как тебе? Катя, Катя, у нас элемент поменьше. Вот. И что мы в этом случае должны сделать? А в
[13:23.520 --> 13:31.720]  общем случае? Что в общем случае? Если мы встречаем элемент меньше. Правильно, но граница разделов
[13:31.720 --> 13:42.960]  находится вот здесь. Ну и справа от нее она. То есть она должна свопнуться сама с собой. Давайте не надо.
[13:42.960 --> 13:53.640]  Остановитесь. Вот. Поэтому она остается на месте. Как тебя зовут, подскажешь? Никита. Что с Никитой делать?
[13:53.640 --> 14:11.640]  Больше. Отлично. А теперь мы встречаем элемент. Да, смотрите, у нас границы находятся уже здесь. Вот в
[14:11.640 --> 14:17.400]  этом моменте. А если мы находимся в этом моменте, то мы должны поставить элемент направо. Согласны?
[14:17.400 --> 14:25.560]  Поэтому мы должны поменять местами. Видите, как чудесно. А дальше мы пойдем дальше. А дальше вас сложно.
[14:25.560 --> 14:36.000]  Ну есть предположение, что вы больше. Давайте так. Хорошо. Вот. Окей. Мы как-то выстроились.
[14:36.000 --> 14:41.760]  В самом начале уже так. И вот таким вот образом работает partition. Мы можем попробовать их засвопать
[14:41.760 --> 14:49.680]  еще раз. Кто-то хочет попробовать представлять людей. Такая. Ладно. Хорошо. Но в действительности как бы
[14:49.680 --> 14:54.720]  мы будем делать так. И смотрите, когда у нас оканчивается сортировка, мы понимаем, что у нас
[14:54.720 --> 15:00.600]  раздел находится вот в этой части. Правда? Вот мы один и два раза его сдвинули, потому что у нас
[15:00.600 --> 15:12.160]  было два элемента меньше. И тогда в этом случае, куда должен стать? С кем? С Сашей. Сашей.
[15:12.160 --> 15:20.800]  Меняйтесь. Символично. И вот тогда мы получаем следующее, что у нас есть элемент в середине,
[15:20.800 --> 15:28.160]  а здесь и слева от него все элементы меньше, справа от него все элементы больше. Так получилось
[15:28.160 --> 15:35.120]  первая сортировка. Дальше, что мы должны сделать? Мы должны сделать аналогично для этой части и для
[15:35.120 --> 15:46.680]  этой части. Давай. Пивот остается в левой части нашего кусочка. То есть здесь... Можно еще раз?
[15:46.680 --> 15:56.600]  Саш. Господи, сложно. Ладно. Саша и Никита. Отлично. Вот. Они становятся пивотом в каждой части,
[15:56.760 --> 16:03.400]  так как ты, грубо говоря, такой компилятор, который преобразует все, ты идешь в рекурсии. И ты идешь
[16:03.400 --> 16:10.440]  и там, и там. Поэтому ты скорее начнешь отсюда, потом приступишь к той части. Вот. Что здесь?
[16:10.440 --> 16:26.240]  Катя. Чуть-чуть, да, предположим. И у нас получается сортированный сам по себе кусочек.
[16:26.240 --> 16:35.480]  Его уже не трогают, он уже стоит на месте. У него же все элементы справа больше,
[16:35.480 --> 16:42.880]  слева меньше, а значит он на месте. Вот. Его не трогаем. И у нас есть вот этот кусочек.
[16:42.880 --> 16:52.160]  Но здесь пивот побольше, предположим, да? Ну вот теперь мы предположим обратную часть,
[16:52.160 --> 17:05.600]  типа не как в начале. Предположим, что пивот больше. Правильно.
[17:05.600 --> 17:20.680]  Должны посвопать между собой вас. Вообще вы сами должны посвопаться просто. Вот. Ну типа на одном
[17:20.760 --> 17:29.920]  месте. Ну вот так, да? Правильно. Да. А раздел у нас находится в самом конце,
[17:29.920 --> 17:37.320]  поэтому ты должен стать в конец. Да. Вот нет, смотрите. Ты должен поменяться с ним местами,
[17:37.320 --> 17:42.240]  а ты должен остаться на месте. Вот в чем суть. То есть смотрите, важно осознавать,
[17:42.240 --> 17:48.320]  как между собой становятся элементики. Это не просто типа, ну как бы мы взяли, сдвинули,
[17:48.320 --> 17:53.720]  и все получилось. Нет. Сдвигайтесь слишком долго, это не интересно. Ну и как-то так.
[17:53.720 --> 17:58.640]  Ну предположим, что вы уже тоже отсортированы, и мы получим отсортированный массив сам по себе.
[17:58.640 --> 18:09.560]  Понятно ли, что сейчас было? А вы поняли? Наверное. Надеюсь, что да. Короче, давайте,
[18:09.560 --> 18:16.400]  все, можете присесть. Спасибо вам большое. В действительности, да, похлопайте им.
[18:16.400 --> 18:25.440]  Действительно. Я подумаю в следующий раз, как вам про Хифу рассказать так,
[18:25.440 --> 18:32.920]  чтобы это было еще забавнее. Вот. В общем-то, в действительности разбиение Ла-Муто работает
[18:32.920 --> 18:37.960]  именно таким вот образом, что вы просто берете и двигаете элементы между собой,
[18:37.960 --> 18:45.480]  свопаете их, как получается. Его реализация достаточно простая. Как вы видите, здесь у нас есть
[18:45.480 --> 18:53.680]  pivot value и pivot ptr. Pivot value – это то, что находится в пивоте. Pivot ptr – это то, что у нас,
[18:53.680 --> 19:15.040]  где у нас является… Сейчас, момент. Давайте еще раз. Pivot value – это то,
[19:15.040 --> 19:21.240]  что находится у нас, то самое значение, которое есть. Вот тут я вал писал. А pivot ptr – это указатель
[19:21.240 --> 19:29.880]  на него. И давайте сейчас посмотрим еще раз на чем-нибудь это. Потому что это важно понять и осознать.
[19:29.880 --> 19:37.000]  И тогда вам будет гораздо проще жить. И вы скажете, что вы знаете сортировку быструю. Потому что,
[19:37.000 --> 19:43.880]  поверьте мне, разбиение Ла-Муто – одно из самых простых, которое есть, и его понять проще. А когда
[19:43.880 --> 19:51.480]  мы перейдем к разбиению Хара, если вы попросите написать quicksort, не знаю, почти любого разработчика,
[19:51.480 --> 19:58.080]  то если он давно уже встречался с алгоритмами, он понимает, как это работает. Прекрасно понимает.
[19:58.080 --> 20:05.080]  Прекрасно это знает. Но написать его без багов – это чудесно. Нужно постараться. На самом деле,
[20:05.080 --> 20:12.320]  это не всегда тривиально. Из-за того, что здесь как раз с индексами бывает разное. Вот здесь вот мы
[20:12.320 --> 20:23.320]  с вами говорим, что это value, pivot value. И сюда указывает pivot point. Почему оно указывает именно сюда?
[20:23.320 --> 20:29.600]  А он указывает именно сюда, потому что у нас пока предположение, что все элементы предположим,
[20:29.600 --> 20:35.080]  что большее. Но у нас все не обработано. Вот. Поэтому мы не можем с вами точно сказать.
[20:35.080 --> 20:38.880]  Если вы решаете контест или что-то обсуждаете, можете выйти и там обсудить.
[20:38.880 --> 20:49.600]  У нас есть этот pivot point. И дальше мы начинаем обработку тех самых элементов. Мы смотрим на
[20:49.600 --> 20:56.160]  первый элемент. И если вдруг этот элемент, то есть вот видите, я иду от left plus 1 до right.
[20:56.160 --> 21:02.880]  Я начинаю идти вот с этого элемента. И я смотрю, что если этот элемент меньше,
[21:02.880 --> 21:07.680]  меня не интересует больше или ровно, меня интересует меньше. Если он меньше, тогда я
[21:07.680 --> 21:14.400]  увеличиваю свой pivot point, что у меня должен pivot встать вот на это уже место.
[21:14.400 --> 21:25.680]  И swap элемент, который я сейчас свижу, с тем элементом, который у меня должен идти. Так как
[21:25.680 --> 21:30.800]  здесь элемент сам по себе повторяется, где я сейчас нахожусь, с тем, который меньше,
[21:30.800 --> 21:37.560]  то он swap-ится сам собой. Вот то, когда крутилась Катя или Саша, я уже не помню. Кто-то из вас. Вот
[21:37.560 --> 21:44.600]  это и означает именно swap сам собой. Это мы должны уметь обеспечить. А дальше мы смотрим элементы.
[21:44.600 --> 21:52.200]  Предположим, ну давайте, давайте на чиселках. Мне кажется, так будет проще. 5, ну тут 3. Теперь
[21:52.200 --> 21:58.160]  мы смотрим на 7. Если мы видим 7, мы просто ничего не делаем. Вот у нас этот if есть,
[21:58.160 --> 22:05.920]  мы сравнили и ничего не сделали. Всё, хорошо. И pivot point никак не меняется. А дальше я найду
[22:05.920 --> 22:14.920]  2, к примеру. Что в этом случае будет происходить? В этом случае я смотрю на нее, она меньше,
[22:14.920 --> 22:21.600]  чем мой pivot, а значит, я должен ее поменять местами. И с чем я меняю местами? А с тем,
[22:21.600 --> 22:29.240]  что находится справа от моего pivot point. Я сначала увеличиваю pivot point, показываю его на 7 и делаю
[22:29.240 --> 22:39.320]  swap семерки и двойки. И получаю здесь 2 и 7. Вот, и pivot point уже указывает вот сюда. И у нас вот
[22:39.320 --> 22:44.920]  такой раздел между собой. После этого я могу еще рассмотреть какие-нибудь элементы. Например,
[22:44.920 --> 22:53.040]  там 8, я его просто пропущу. 9, я его тоже просто пропущу. Ну и, например, 0 и там ну и все. Давайте
[22:53.040 --> 23:01.840]  сделаем так, просто проще будет. 7 я уже не смотрю, потому что я уже там был на этом месте. 8 я
[23:01.840 --> 23:07.400]  пропускаю, потому что оно больше. 9 я пропускаю, потому что оно больше. Когда встречаю 0, я опять
[23:07.400 --> 23:18.720]  увеличиваю pivot point вот сюда и меняю 7 с нулем. И получаю 0, 7. То есть, смотрите, этот элемент
[23:18.720 --> 23:25.320]  встает именно в конец этого кусочка. Вы не просто так меняетесь, не просто сдвигаетесь, а именно меняете
[23:25.320 --> 23:31.360]  элементики. Остальное нам не важно. И теперь я получаю, что у меня вот раздел pivot point указывает
[23:31.360 --> 23:40.040]  сюда, то есть это дом, где должен стоять pivot. Справа от этого раздела все меньше, слева, ой,
[23:40.040 --> 23:47.040]  справа все больше, слева все меньше. И теперь все, что мне осталось, это 5 и 0 поменять местами.
[23:47.040 --> 23:57.560]  Поэтому в этом случае я получу вот такой вот массивчик. И получу здесь 0, 3, 2, 5, 8, 9, 7. Эти куски
[23:57.560 --> 24:02.320]  не отсортированы, я не отрицаю. Но для того, чтобы их отсортировать, мне достаточно здесь и здесь
[24:02.320 --> 24:12.160]  запустить еще quick sort, что и делает сам по себе быстрая сортировка. Понятно, что произошло. Дальше,
[24:12.160 --> 24:17.120]  когда я начну сортировать эти кусочки, я тоже каждый из элементов, каждый из пивотов, то есть 8 и 0
[24:17.120 --> 24:31.680]  подставлю на свои места. 0 останется здесь, 8 станет вот сюда и будет 9, 8, 7. Вот и так далее.
[24:31.680 --> 24:48.360]  Итак, я получу все мне необходимое. Нет, ой, pivot.ptr. Он возвращает индекс, потому что он
[24:48.360 --> 24:56.720]  необходим, чтобы мы запустили другие quick sort. Сейчас понятно, что было, как произошло. В общем-то,
[24:56.720 --> 25:02.720]  а мы с вами все это получили, все это сделали. Вопрос, а за сколько это работает? Почему быстрая? Мы
[25:02.720 --> 25:06.600]  говорим, что да, она скорее всего работает за логарифт. Но согласны ли вы с тем, что тут можно
[25:06.600 --> 25:17.680]  привести контрпример, где она работает за квадрат? Да. Если у нас pivot будет всегда каждый раз именно
[25:17.680 --> 25:27.040]  меньше или больше. В этом случае что мы делаем? Мы все время проходимся по массиву и согласны,
[25:27.040 --> 25:32.760]  что у нас вот этот водораздел, он всегда стоит на месте. А значит, мы уменьшаемся всего на чуть-чуть.
[25:32.760 --> 25:37.280]  То есть у нас один quick sort просто вызываться не будет, потому что там ничего не будет.
[25:38.280 --> 25:51.680]  Там он будет сразу возвращаться. А другой quick sort будет вызываться сколько раз? Ну вот n. И для того,
[25:51.680 --> 25:58.920]  чтобы сравнить каждый раз элементики, он сколько раз должен пройтись? Н раз по всему массиву, по всей
[25:58.920 --> 26:06.600]  своей части. Поэтому это будет вот n квадрат. Так почему же quick sort называется быстрый? Как
[26:06.600 --> 26:11.040]  вы думаете? Можно. А какая разница? А вдруг ты перемешаешь так, что будет опять n квадрат?
[26:11.040 --> 26:26.280]  Ну вероятность всегда одинаковая. Где? А как? Не бывает. А как ты хочешь сделать? Самый лучший
[26:26.280 --> 26:32.920]  случай для quick sort это случай, когда у нас будет здесь половина элементов и здесь половина
[26:32.920 --> 26:39.360]  элемента. Ты максимально их разделишь. Это будет логарифм. Это будет n лог квадрата? Ой,
[26:39.360 --> 26:50.480]  n лог два n. Вот это уже правда. И давайте это покажем. Вам, возможно, в мёртв сорте не показывали
[26:50.480 --> 27:02.320]  константы. Вообще, в принципе, да, константы это не самое быстрое, что может произойти. И в общем-то,
[27:02.440 --> 27:10.960]  как доказывается время работы? Не поверите, но здесь у вас тоже будет вопрос на домашнюю
[27:10.960 --> 27:17.920]  работу. Скажу так. Вам нужно будет самим подумать, как это доказывается. Почему? По очень простой причине.
[27:17.920 --> 27:23.280]  Потому что я вам частично это рассказывал. Я дойду до одного момента, а дальше вы сами должны будете
[27:23.280 --> 27:35.000]  подумать. Смотрите. А предположим, что у нас пивот п, а пивот оказался на месте п. Тогда вот он
[27:35.000 --> 27:45.240]  оказался на этом месте. Тогда здесь находится п-1 элемент. Правильно? А здесь находится n-p элементов.
[27:45.240 --> 27:54.240]  У нас есть такое разбиение. Согласны ли вы, что у нас все случаи равновероятные между собой? Поэтому
[27:54.240 --> 28:00.840]  вот это p могло оказаться, что в начале, что в конце, что где-то ещё. Это первое, что нужно понять. Второе.
[28:00.840 --> 28:08.920]  Если у меня количество действий для массива из n элементов, это a от n, то здесь, когда он станет
[28:08.920 --> 28:20.320]  на место p, здесь у меня количество действий будет a от p-1, здесь a от n-p. Согласны? Вот. Значит,
[28:20.320 --> 28:27.840]  но кроме того, когда я выбираю пивот, я ещё начинаю все элементы сравнивать с ним. Правильно?
[28:27.840 --> 28:35.520]  Поэтому у меня есть ещё n-1 действие. То есть я сначала n-1 действие делаю, потом ставлю пивот
[28:35.520 --> 28:42.120]  в нужное мне место. Я вот этот поп не считаю. Ну типа не суть важна на самом деле. А потом я
[28:42.120 --> 28:51.680]  начинаю вызывать рекурсивно тут и тут. Правда? Вот. Поэтому здесь мы можем сказать, что у нас a от n
[28:51.680 --> 28:57.760]  равно n-1. Это то количество действий, которое мы выполняем, когда мы проходимся по всему массиву.
[28:57.760 --> 29:05.880]  n-1 сравнение. А плюс 1 делить на n, потому что у нас равно вероятно, он может стать на место от 0
[29:05.880 --> 29:15.960]  там до n-1. А дальше я говорю, что это сумма от i единички до n, а от i-1. Ну вот это. Вот это самое.
[29:15.960 --> 29:24.680]  Почему сумма? Ну потому что я вероятно считаю. Я говорю, что вероятность умножить на количество
[29:24.680 --> 29:34.200]  действий. Я получу среднее количество действий. Согласны? Да. Вот. Я это получаю. Плюс у меня есть
[29:34.200 --> 29:49.680]  сумма вот этого n-p. Я тоже считаю его для всех i. Согласны ли вы с тем, что a от i-1 и a от n-i
[29:49.680 --> 30:00.600]  принимают не те же значения? Понимаете это или нет? Ну то есть, если там i равно 1,
[30:00.600 --> 30:11.880]  если i равно 1, то у нас будет a0 и a от n-1. А если у нас n равно, а нет, для 1 плохо. Давайте
[30:11.880 --> 30:25.760]  что-нибудь другое. Давайте скажем для... хотя, почему для 1 плохо? Да нет, для 1 неплохо. Вот. Для
[30:25.760 --> 30:37.720]  единички это будет то же самое, что у нас будет... я просто считать не умею. Это будет a0 и a от n. Если
[30:37.720 --> 30:44.320]  я поменяю n и 0 местами, то получу то же самое. Если у меня i равно... правильно. Это правда. Ладно,
[30:44.320 --> 30:55.240]  я где-то залагал. Хорошо. Здесь нужно их вычеркнуть просто. Все, я понял. Сорян, немного неправильно
[30:55.240 --> 31:02.200]  писал, что я имел в виду. Нам нужно вычеркнуть будет от единички от нуля. Там количество действий
[31:02.200 --> 31:11.160]  0. Вот. А дальше рассмотреть, ну не знаю, давайте для i равно 2. Это уже должно точно быть похоже.
[31:11.160 --> 31:22.120]  Вот a от единички и a от n-2. А дальше я могу сказать, что у меня есть i равно n-2. Я получу
[31:22.120 --> 31:29.440]  здесь n-1, который я бы получил в другом случае. С одной стороны, правда? А с другой стороны я
[31:29.440 --> 31:42.880]  получу, если сюда поставлю, a2. А? Где? Да, это правда. Для того, чтобы сопоставить,
[31:42.880 --> 31:59.320]  это правда. Давайте a от n... Господи, я все, я запутался. Тут будет a от n-2. В общем случае,
[31:59.320 --> 32:03.480]  на самом деле, вот если мы рассматриваем вот ту часть и вот ту часть, мы получаем вот такую
[32:03.480 --> 32:10.240]  вот штуку. А значит, мы можем слопать эти суммы. То есть это двойная сумма. А где я беру a ты от i
[32:10.240 --> 32:22.920]  равного 0 до n-1? Окей? Смотрите, мы с вами говорим, что в разбиении ломуто можно взять и упростить то,
[32:22.920 --> 32:30.000]  что у нас есть с вами. И как-то с этим вообще жить, работать. И нужно как-то это взять и оценить.
[32:30.000 --> 32:34.680]  Есть какие-то предположения, как это можно сделать, когда мы вот пришли к такому виду?
[32:40.240 --> 32:52.840]  Нет. Ну, смотрите, нам нужна рекуррента. Мы умеем решать рекурренты, правда? Вопрос
[32:52.840 --> 33:00.800]  следующий. Как можно вот упростить вот это a n-2? Видите, оно зависит от суммы аитых. Это не классно.
[33:00.800 --> 33:16.800]  Ну, типа это не оценить нормально, правда? Правильно. Это правда. Смотрите, у нас есть a n-2 и есть a n-1.
[33:16.800 --> 33:22.920]  Сумма у них плюс-минус одинаковая, кроме последнего элементика. Значит, мы можем
[33:23.920 --> 33:34.920]  вот a n-1 на n-1, а a n-2 на n и вычесть друг из друга. И тогда у нас останется только a n-2
[33:34.920 --> 33:41.880]  и зависимость его от a n-1. Если все привести, то мы получим вот это выражение a n равно n плюс
[33:41.880 --> 33:51.800]  1 делить на n, n на a от n-1 плюс 2 n-2 делить на n. Согласны? Ну, что так можно сделать? Проверьте,
[33:51.800 --> 33:56.160]  что у нас действительно результат именно такой. Можете проверить. Дома посидеть,
[33:56.160 --> 34:06.280]  потыкаться. Хорошо? Но это несложно, это просто механическая операция неинтересная. Так вот,
[34:06.280 --> 34:14.040]  а в действительности, если решать эту рекурренту с помощью какого-нибудь разложения в ряды,
[34:14.040 --> 34:22.960]  то можно получить, что это 1 четвертое n плюс 1 на логарифм двоечный n. Это очень маленькая
[34:22.960 --> 34:29.280]  константа на самом деле, то есть оно максимально близко к этому. Но на экзамене и в принципе дальше
[34:29.280 --> 34:37.040]  вам необходимо будет взять и это a n-2 доказать, что оно хотя бы n лог n. Помните, мы с вами решали
[34:37.040 --> 34:47.840]  рекуррент. А? Это как-то неуверенно. Вам очень не понравилось, видимо. Так вот, в действительности
[34:47.840 --> 34:54.640]  ваша задача будет применить те знания, которые мы с вами делали вот к этой рекурренте и посмотреть,
[34:54.640 --> 35:00.080]  что она действительно будет n лог n. Оценить ее сверху. И в действительности в среднем
[35:00.080 --> 35:10.480]  случае мы с вами получим, что у нас будет как раз таки n лог n и значит эта сортировка работает
[35:10.480 --> 35:17.120]  достаточно быстро и хорошо. Она работает в среднем за n лог n. В лучшем случае мы с вами уже показали,
[35:17.120 --> 35:34.600]  что у нас n квадрат. Да? А? Больше n квадрат? Каким образом ты хочешь здесь n квадрат? Больше.
[35:34.600 --> 35:45.320]  Ну смотрите, если у меня есть разбиение, я точно знаю, что на каждом шаге у меня делается уаттен
[35:45.320 --> 35:52.200]  действия, да? Дальше у меня всегда идет разбитие на две части этого массива, то есть меньше пивота,
[35:52.200 --> 36:02.520]  больше пивота. Больше пивота. Ну там больше либо равно, не суть важна. Если я буду вызывать quick
[36:02.520 --> 36:12.000]  sort для этих частей, то тут сколько будет действий? Но также уатт какой-то там х и n-х. Это с одной
[36:12.000 --> 36:24.840]  стороны, но с другой стороны. А то, что мы с вами будем делать, мы говорим, что у нас в этом случае мы
[36:24.840 --> 36:35.120]  спускаемся сколько раз? В два таких ответвления. Так вот, когда мы дойдем до конца, что самое
[36:35.120 --> 36:42.320]  большое здесь может получиться? Если мы с вами будем строить вот это дерево, то у нас будет здесь
[36:42.320 --> 36:56.600]  n х n-х, потом еще, еще и так далее. Как максимум удлинить эту штуку? То есть мы точно знаем,
[36:56.600 --> 37:11.640]  что на каждом из этих будет уаттен, правильно? Какая максимальная длина у дерева? То есть вот такой
[37:11.640 --> 37:31.160]  вот бамбук. Максимальная длина у нас n. Вот n квадрат. Это то, что касается разбиения ламутом. Я
[37:31.160 --> 37:36.720]  сейчас кратко расскажу вам про разбиение хара. У меня нет доказательств, я вам не даю доказательства о
[37:36.720 --> 37:42.000]  том, что сколько оно работает. Оно в среднем работает чуть даже лучше, но вам необходимо
[37:42.000 --> 37:49.320]  математическое ожидание. Вот. А я не хочу вам его вводить, вам ведут это на Тиарвере на втором году.
[37:49.320 --> 38:01.520]  Нет, не сегодня. Поэтому давайте, давайте так. А что касается разбиения хара? Разбиение хара
[38:01.520 --> 38:13.960]  действует достаточно просто. А у нас, давайте я смотрю, я буду показывать. Элементы. И мы говорим,
[38:13.960 --> 38:21.360]  что у нас вот здесь вот есть какой-то элемент пивота. Я хочу все также сделать, что тут меньше,
[38:21.360 --> 38:28.760]  что тут больше. Да? Что мне с этим делать вообще? Как мне с этим жить? Ну, смотрите,
[38:28.920 --> 38:36.040]  здесь все очень просто. Давайте подмыслим другой логик. Предположим, что мы идем вот здесь вот по
[38:36.040 --> 38:42.320]  элементам, и здесь идем по элементам другого края. И мы встречаем вот здесь вот элемент y,
[38:42.320 --> 38:51.960]  который больше x, а здесь элемент z, который меньше. Какой самый логичный шаг? Поменять их местами.
[38:51.960 --> 39:02.960]  Вот. Меняем их местами и получаем, что у нас опять сохраняется необходимый нам баланс.
[39:02.960 --> 39:18.520]  Получается, что здесь будет z, вот здесь вот будет y, а здесь x. И я пойду дальше. Я буду так
[39:18.520 --> 39:31.400]  постоянно их менять местами. Согласны, что это выглядит непонятно. А теперь ваша задача на подумать
[39:31.400 --> 39:42.280]  большая. Я всегда заставляю вас думать. Надеюсь, что вы подумаете. Вопрос в следующем. Если у нас
[39:42.280 --> 39:47.240]  есть здесь элемент, представьте, что я дойду вот до сюда, а здесь я все время меняю элементы.
[39:47.240 --> 39:55.080]  То есть у меня количество элементов, не знаю, меньше. Предположим, что у меня массив из десяти
[39:55.080 --> 40:04.520]  элементов. Всего два элемента меньше пивота, а семь элементов больше x. В какой момент пивот туда
[40:04.520 --> 40:17.040]  перейдет? Так. Значит, начнут свопаться сам. То есть сам пивот начнет свопаться. То есть не думайте
[40:17.040 --> 40:22.120]  только, что мы идем вот только сбоку. Это самое первое представление этого. Дальше, в момент,
[40:22.120 --> 40:27.520]  когда мы перейдем к x, никогда не бывает четкого разделения пополам. Не бывает черного и белого.
[40:27.520 --> 40:33.700]  Я думаю, вы знаете, бывает серое. Всегда об этом учат. Нельзя четко судить о чем-то одном. Вот здесь
[40:33.700 --> 40:41.060]  ровно такая же суть. И на самом деле реализация выглядит ровно так же. Смотрите, я говорю, что пока
[40:41.060 --> 40:48.460]  и меньше, либо равно же. Что мы делаем? Мы с вами берем и говорим, что если у нас аи меньше пивота,
[40:48.460 --> 40:56.580]  то я ищу элемент, который больше, либо равен. Если у нас элемент мы ищем больше, то я ищу момент,
[40:56.580 --> 41:02.780]  когда у нас будет, мы найдем, меньше элемент, меньше, либо равный. Почему ставить больше и меньше? А
[41:02.860 --> 41:14.420]  потому, что вот тот самый пивот сам надо менять еще будет. Окей? Я это делаю до того момента,
[41:14.420 --> 41:25.220]  пока и меньше же. То есть пока эти указатели не столкнутся. Согласны? Все. Вот смысл сортировки.
[41:25.220 --> 41:31.820]  И вот это чаще всего воспринимают как быструю сортировку. Это и есть быстрая сортировка Хаара.
[41:31.820 --> 41:50.100]  Сортировка Хаара, по факту. Это то самое разбиение Хаара. Вам понятна ее суть? Да. А дальше,
[41:50.100 --> 41:56.140]  смотрите, видите, он while аито меньше пивота. В какой момент у нас становится? В моменте,
[41:56.140 --> 42:12.700]  когда найдет сам пивот. И поменяет его. Вот. И пойдет куда-нибудь. Все. А? Перекидываться.
[42:12.700 --> 42:23.620]  На примере нужно посмотреть. Согласны? Ну давайте попробуем. Что у нас там?
[42:23.620 --> 42:47.580]  Давайте сделаем так. 9, 9, не знаю там. Нарисуем. 1, 2, 3, 4, 5, 6, 7, 8, 9. Ну давайте 9 элементов возьмем.
[42:48.220 --> 42:59.340]  А вот здесь серединка у меня. Давайте я здесь возьму там не знаю 2. Нет, 3. Вот. Покажу,
[42:59.340 --> 43:12.420]  что у меня один здесь, два здесь. И что-то дальше буду делать здесь. Здесь будет 8, 7, 6, 5, 4. Логично.
[43:12.420 --> 43:18.860]  Давайте смотреть, что будет происходить. Я иду отсюда, я иду отсюда. Здесь мы находим первый больше,
[43:18.860 --> 43:35.820]  правильно? Меняю его с первым меньше. Получаю 2, 9. У меня указатель вот сюда. Я иду дальше. Я встречаю
[43:35.820 --> 44:01.060]  3 и 8. Да? Правильно или неправильно? Или нет? И как? И как жить? Согласны с тем,
[44:01.060 --> 44:29.380]  что сделал или нет. 8 и 3. Следующий. Ну после двойки ставил какой? А? Валь. Так Вайл,
[44:29.380 --> 44:47.580]  в какой момент становится? Еще раз, Вайл, в какой момент становится? Почему? Подождите. Вайл что
[44:47.580 --> 45:05.580]  делает? Ну 3 меньше 3, правда или нет? Так Вайл выполнится. 3 меньше 3. Так, Вайл выполнится.
[45:17.580 --> 45:46.060]  Ну получается пока как-то так, правда? А? Ну мы поменяли. Нет. Нет, нет, нет.
[45:48.420 --> 46:03.820]  Согласны с тем, что я там сделал? Ну я правильно сделал или нет? А? Я еще не дошел до нее. А дальше
[46:03.820 --> 46:10.100]  я смотрю единичка и семерка. Да? Что делать? Меняем их.
[46:17.580 --> 46:30.180]  Получилось что-то хорошее? Чего не хватает? Не хватает вот этого? Согласны? Это вам нужно подумать,
[46:30.180 --> 46:37.260]  как это сделать. Это специально и было для того, чтобы типа все понятно? Все понятно. Получили. Да?
[46:37.260 --> 46:54.140]  Чего? Где с двойки? А потому что все остальные элементы больше, они находятся правее. Все правильно.
[46:54.140 --> 47:10.620]  Ну они больше, я прохожу их Вайлом просто. Задумайтесь. Да, в начале да. А потом тройку с восьмеркой.
[47:10.620 --> 47:22.100]  А потом почему? Единичку с семеркой. Видите, какие вопросы порождает сортировка? Я говорю,
[47:22.100 --> 47:30.740]  именно поэтому быструю сортировку никто быстро не пишет. Это ее типа проклятие такое. Задумайтесь
[47:30.740 --> 47:36.380]  на тем, что можно здесь делать и что возвращается здесь пивотом. Куда становится, что происходит.
[47:36.380 --> 47:43.380]  Это один из примеров. Но важный момент. Вы должны понимать, что из-за О от Н квадрат эта
[47:43.380 --> 47:48.540]  сортировка тоже умеет работать. Почему? Потому что она также может перекинуть их. Ну если вы
[47:48.540 --> 47:53.820]  правильно напишете, вот подумайте, что с ним сделать. Из-за того, что вас сегодня задержал,
[47:53.820 --> 48:02.860]  я вам напишу этот код. Но не сразу. К выходным, хорошо? Вот. А вопрос следующим, что в какой-то
[48:02.860 --> 48:09.100]  момент вам могут предоставить такой массив, что у вас будет пивот стоять вот здесь и опять вот здесь
[48:09.100 --> 48:16.180]  будет полностью остаток. И вы опять получите этот вызов рекурсии. Понимаете? И в этом будет вся
[48:16.180 --> 48:22.340]  проблема, что быстрая сортировка периодически работает за Н квадрат. Но она настолько быстрая
[48:22.340 --> 48:33.780]  с ее константой, что именно ее все используют. Окей? Ну смотрите, мы с партийшном что должны получить?
[48:33.780 --> 48:46.820]  Вот. Окей. Это то, что касается этого момента. Что это еще разбиение на три части? Честно скажу
[48:46.820 --> 48:51.580]  об этом чуть-чуть, потому что это скорее такой материал на самоизучение. Я попрошу семинаристов
[48:51.580 --> 49:04.260]  с вами разобрать это. Хорошо? Отдельно. Суть с разбиением на три части следующая. Нам необходимо,
[49:04.260 --> 49:13.420]  вот мы также будем смотреть пивот, но мы будем смотреть пивот слева, к примеру. И что мы будем
[49:13.420 --> 49:21.660]  пытаться делать? Мы будем делать здесь элементы. Будем делать равные пивоту. Здесь элементы будем
[49:21.660 --> 49:30.220]  меньше пивоту. Здесь необработана его часть. Мы будем идти все так же справа и слева. И здесь
[49:30.220 --> 49:42.900]  будут элементы равные пивоту, а здесь большие пивоту. Для чего я это делаю? Я это делаю
[49:42.900 --> 49:54.100]  для следующего, чтобы были здесь меньше пивота, равные пивота, больше пивота. Я хочу получить вот
[49:54.100 --> 49:59.940]  такой массив. Почему это важно? Потому что если у меня одинаковые элементы, то зачем мне их много
[49:59.940 --> 50:09.580]  раз между собой свопать? Согласны? Вот. Ну и все. Вот у вас раз, вот у вас два, вот у вас три. И тогда
[50:09.580 --> 50:14.860]  все будет хорошо. Это делается именно в такой стезе, что здесь у нас будет указатель, здесь
[50:14.860 --> 50:19.180]  будет указатель, здесь будет указатель, здесь будет указатель. Вы можете почитать здесь побольше.
[50:19.180 --> 50:25.060]  Если вам нужно, в следующий раз я проведу это так типа на 20 минут, разберу это, если вы захотите
[50:25.060 --> 50:30.820]  это. Только напишите мне об этом, я вам побольше скажу. Вот здесь будет реализация. Ну и последнее,
[50:30.820 --> 50:37.660]  на самом деле, что еще хотел я с вами сказать. Возможно ли сортировки быстрее? Быстрее,
[50:37.660 --> 50:48.620]  чем НЛГН? На самом деле нет. Что это так называемый барьер Омега НЛГН? И он связан как раз
[50:48.620 --> 50:56.460]  таки с тем, что любая сортировка завязана на сравнение. Но без сравнения очень сложно
[50:56.460 --> 51:00.900]  придумать сортировку, кроме как быть может подсчетом. Потому что подсчетом она просто
[51:00.900 --> 51:08.340]  берет конкретные числа, там нет сравнений. Так вот здесь вот барьер заключается в следующем,
[51:08.340 --> 51:18.060]  что если мы рассмотрим дерево, все возможных вариантов. Причем дерево будет, к примеру,
[51:18.060 --> 51:29.020]  следующее, что оно будет показывать аито, аито меньше, чем ожито или нет. Если да, то он перейдет
[51:29.020 --> 51:36.220]  сюда, если нет, то сюда. И будет сравнивать все элементы попарно. Абсолютно все. Скажите,
[51:36.220 --> 51:47.900]  сколько снизу будет элементов? Сколько всего возможных вариантов сортировки массива? N
[51:47.900 --> 51:52.860]  факториал, количество перестановок. Вот максимум все переставляем. То есть снизу у нас N факториал.
[51:52.860 --> 51:58.460]  Это дерево будет полное, потому что оно больше-меньше, больше-меньше. Все элементы
[51:58.460 --> 52:06.700]  можно сравнить, правда? Да или нет? Мы смотрим какую-то рандомную пару аито-ожито. Мы должны
[52:06.700 --> 52:13.740]  по всем парам пройтись. Какой-то механизм себе в голове придумали. Сначала а0а1, потом а0а2,
[52:13.740 --> 52:21.220]  а0а3 и так далее. Вот все элементы возможные просматриваем. И в зависимости от этого свопы
[52:21.220 --> 52:34.380]  зависит, правда? Вот. А это у нас N факториал. Если дерево полное, скажите мне, какая высота
[52:34.380 --> 52:41.420]  дерева? Ну вот как дерево связано с количеством листов? Как вы думаете, сколько листов у полного
[52:41.420 --> 52:53.780]  дерева снизу? 2 в степень h. Ну там минус 1, но не суть важна. 2 в степень h. Чудесно. Вот. Вот у
[52:53.780 --> 52:58.700]  нас будет 2 в степень h. И мы должны сказать, что у нас N факториал меньше, чем 2 в степень h.
[52:58.700 --> 53:13.820]  Меньше либо равно, да? Значит h, он будет меньше, ой, больше либо равен, чем логарифм. Ну сейчас,
[53:13.820 --> 53:22.500]  давайте по-другому скажем. Тут логарифм N факториал меньше либо равен, чем h, логарифм 2.
[53:22.500 --> 53:32.980]  Согласны? Вот так вот. h больше либо равно, ну вот этот логарифм можно выкинуть, не важно,
[53:32.980 --> 53:43.860]  но логарифм N факториал. Так вот, по формуле стирлинга, вот это N логен.
[53:43.860 --> 53:56.340]  У вас аж высота этого дерева вот такая, значит вы можете сделать количество действий не более,
[53:56.340 --> 54:03.820]  не менее, чем это количество. Потому что вы должны получить все возможные варианты массива. Потому
[54:03.820 --> 54:09.060]  что я могу подобрать любые варианты, чтобы у нас была нужная нам перестановка. Согласны? Так
[54:09.060 --> 54:15.020]  что вот такое вот решение. Это все, что я хотел вам сегодня рассказать. Если у вас будут какие-то
[54:15.020 --> 54:23.380]  вопросы, говорите. Я прошу прощения, что сегодня было так разорвано, непонятно, я опоздал. Тори,
[54:23.380 --> 54:33.300]  никто не знал, что в Москве я буду ехать два часа, а не час. Но всем большое спасибо. Я
[54:33.300 --> 54:38.780]  жду вас в следующий раз. Пишите, звоните, так сказать. Если у вас есть какие-то проблемы с,
[54:38.780 --> 54:44.980]  не знаю, с чем угодно связанным с курсом, подходите, говорите или пишите мне об этом.
[54:44.980 --> 54:46.980]  Все, хорошего всем вечера.
