[00:00.000 --> 00:15.640]  Мы закончили на обсуждении того, какие есть основные
[00:15.640 --> 00:17.680]  типы операции над ними.
[00:17.680 --> 00:22.280]  Это был параграф 1.2, ну и сейчас будет продолжение
[00:22.280 --> 00:25.280]  параграфа 1.2.
[00:25.280 --> 00:52.080]  А, значит, нет, параграфы это моя личная нумерация
[00:52.080 --> 00:55.040]  тем и под тем, чтобы было удобнее.
[00:55.040 --> 01:00.480]  В конце года у вас будет, ну я вам скину программу
[01:00.480 --> 01:04.440]  целиком с этими параграфами, возможно, когда-нибудь
[01:04.440 --> 01:05.960]  будет книжка, но пока ее нет.
[01:05.960 --> 01:10.640]  Я год от года собираюсь ее написать, но что-то пока
[01:10.640 --> 01:11.640]  не получается.
[01:11.640 --> 01:17.920]  Так вот, ну мы с вами обсудили целочистный тип, и тип
[01:17.920 --> 01:23.320]  с плавающей точкой, и на семинарах вы должны были
[01:23.320 --> 01:27.120]  на самом деле обсудить такие еще полезные типы, уже
[01:27.120 --> 01:31.120]  не встроенные в язык, а относящиеся к стандартной библиотеке
[01:31.120 --> 01:33.000]  как вектор и стринг.
[01:33.000 --> 01:36.800]  Давайте я вкратце про них напомню, потому что они
[01:36.800 --> 01:41.800]  важные, полезные, но они полезные с практической
[01:41.800 --> 01:44.560]  точки зрения, потому что, скорее всего, вы когда будете
[01:44.560 --> 01:46.320]  прикладные программой писать, вы им будете постоянно
[01:46.320 --> 01:49.920]  пользоваться, в том числе на алгоритмах, а еще они
[01:49.920 --> 01:54.200]  очень важные с точки зрения дальнейшего, нам самим они
[01:54.200 --> 01:59.320]  пригодятся потом, чтобы на их примерах что-то показывать,
[01:59.320 --> 02:01.880]  но они уже не являются базовыми, то есть не являются фундаментальными
[02:01.880 --> 02:04.240]  встроенными, они относятся к стандартной библиотеке.
[02:04.240 --> 02:09.280]  Значит есть и STD-стринг, ну или расскажу, кому не успели
[02:09.280 --> 02:12.400]  на семинарах рассказать, а кто на семинарах прошел
[02:12.400 --> 02:13.400]  уже их.
[02:14.400 --> 02:15.400]  Что-то мало.
[02:17.400 --> 02:18.400]  Ну да ладно.
[02:18.400 --> 02:19.400]  Вот.
[02:19.400 --> 02:22.880]  Ну STD-стринг, что это такое, это тип, которому можно
[02:22.880 --> 02:27.640]  хранить строки, да, вот, например, так, что можно делать
[02:27.640 --> 02:28.640]  со строками?
[02:28.640 --> 02:31.800]  Можно, ну, наверное, самое полезное, что можно со строками
[02:31.800 --> 02:35.160]  делать, это обращаться по индексу, да, ну, то есть
[02:35.160 --> 02:40.480]  вы можете спросить, какой там первый элемент этой
[02:40.480 --> 02:41.480]  строки.
[02:41.960 --> 02:44.760]  Ну, например, вот я могу там, если у меня есть сиаут,
[02:44.760 --> 02:50.760]  ну опять STD-сиаут, я могу вывести, эээ, там, СТР, первое.
[02:50.760 --> 02:53.960]  И вот тут все понимают, что первый элемент это
[02:53.960 --> 02:55.960]  B, а не A.
[02:55.960 --> 02:58.520]  Значит, нумерация идет всегда с нуля.
[02:58.520 --> 03:01.520]  Всегда нумерация во всех массивах, во всех строках
[03:01.520 --> 03:03.280]  у нас будет идти с нуля.
[03:03.280 --> 03:05.320]  Вот, никогда не путайтесь.
[03:05.320 --> 03:07.200]  И вообще рекомендую вам в своих программах тоже
[03:07.200 --> 03:09.800]  по возможности поддерживать нумерацию с нуля, ну, за редким
[03:09.800 --> 03:12.720]  исключением, где, там, особенно удобно в некоторых местах
[03:12.720 --> 03:15.400]  алгоритм делать наоборот, но в подавляющем большинстве
[03:15.400 --> 03:20.080]  случаев лучше делать нумерацию с нуля, это, в общем, меньше
[03:20.080 --> 03:23.080]  путаниться будет.
[03:23.080 --> 03:26.680]  Ну, элементы строки можно менять таким образом, например,
[03:26.680 --> 03:30.920]  можно сказать, СТР нулевое присвоить там B, тогда строка
[03:30.920 --> 03:33.520]  станет равна bbc.
[03:33.520 --> 03:36.240]  Можно у строки спросить ее размер.
[03:36.440 --> 03:39.440]  str.size.
[03:39.440 --> 03:45.440]  Это, значит, функция, которая вам вернет количество символов
[03:45.440 --> 03:46.440]  в строке.
[03:46.440 --> 03:53.040]  Вот, в данном случае, размер этой строки равен 3.
[03:53.040 --> 03:54.040]  Не 2.
[03:54.040 --> 03:59.960]  Размер это количество символов 0,1,2, а всего 3, значит, но
[03:59.960 --> 04:03.440]  индексы этих символов 0,1,2.
[04:04.440 --> 04:09.440]  Хорошо, что еще можно делать со строкой?
[04:09.440 --> 04:14.440]  Ну, вот тут, наверное, надо сказать, что будет, если вы
[04:14.440 --> 04:19.440]  обратитесь по индексу, который выходит за рамки допустимого.
[04:19.440 --> 04:22.440]  Например, если я попробую что-нибудь СТР четвертому
[04:22.440 --> 04:25.440]  присвоить, что произойдет?
[04:25.440 --> 04:30.440]  Не знаю, СТР четвертая присвоить, не знаю, х.
[04:31.440 --> 04:36.440]  Вот, строго говоря, в этой ситуации может произойти
[04:36.440 --> 04:37.440]  все что угодно.
[04:37.440 --> 04:41.440]  Это так называемое неопределенное поведение или undefined behavior.
[04:41.440 --> 04:44.440]  В языке C++, если вы обращаетесь по индексу за границу строки
[04:44.440 --> 04:49.440]  или массива, то не обязательно происходит ошибка.
[04:49.440 --> 04:53.440]  Возможно, вы просто по СТР четвертому получите случайный
[04:53.440 --> 04:56.440]  символ и поменяете какой-то символ случайный в какой-то
[04:56.440 --> 04:59.440]  памяти, лежащий рядом со строкой.
[04:59.440 --> 05:02.440]  Ну, конечно же, так делать нельзя.
[05:02.440 --> 05:04.440]  Если вы в своих программах так делаете, то вы очень
[05:04.440 --> 05:07.440]  рискуете, особенно вы рискуете, если это вы делаете не
[05:07.440 --> 05:10.440]  в своих программах домашних, а где-то там в промышленном
[05:10.440 --> 05:13.440]  коде, потому что это может упасть в любой момент.
[05:13.440 --> 05:15.440]  Но упасть это еще ладно, не самое плохое.
[05:15.440 --> 05:18.440]  Самое плохое, что это может случайно поменять какую-нибудь
[05:18.440 --> 05:21.440]  другую ячейку памяти, которая относится к какой-то другой
[05:21.440 --> 05:23.440]  переменной и будет поведение от этого совершенно
[05:23.440 --> 05:25.440]  непредсказуемо.
[05:25.440 --> 05:27.440]  Ну, главное, что надо запомнить, если вы обращаетесь
[05:27.440 --> 05:31.440]  по индексу за пределы строки, за пределы того, что вы
[05:31.440 --> 05:34.440]  можете 0.1.2, вы не обязательно падаете.
[05:34.440 --> 05:37.440]  Вы можете как упасть, то есть программа может крешнуться,
[05:37.440 --> 05:40.440]  а может и случайный символ там оказаться.
[05:40.440 --> 05:43.440]  Вот. Мы с вами в какой-то момент начнем подробно
[05:43.440 --> 05:48.440]  говорить о том, в какой ситуации, что конкретно будет,
[05:48.440 --> 05:50.440]  ну, от чего это зависит.
[05:50.440 --> 05:52.440]  Вот. И даже скорее на втором, наверное, курсе вы будете
[05:52.440 --> 05:54.440]  подробнее говорить о чем это зависит.
[05:54.440 --> 05:56.440]  Но пока надо просто понимать, что может произойти что
[05:56.440 --> 06:00.440]  угодно, можно словить рандомное значение.
[06:00.440 --> 06:04.440]  Вот. И есть такая полезная функция, если вы хотите
[06:04.440 --> 06:07.440]  обратиться по индексу, но при этом убедиться, что вы
[06:07.440 --> 06:09.440]  не выходите за границы.
[06:09.440 --> 06:12.440]  Есть такая функция add.
[06:12.440 --> 06:15.440]  Add2, например.
[06:15.440 --> 06:18.440]  Вот. Эта функция, она делает абсолютно то же самое,
[06:18.440 --> 06:21.440]  что квадратные скобки, с единственной разницей она
[06:21.440 --> 06:24.440]  проверяет, не вышли ли вы за границу.
[06:24.440 --> 06:27.440]  Вот. И если вышли, то вы гарантированно получите ошибку.
[06:27.440 --> 06:29.440]  Времени выполнения вы упадете.
[06:29.440 --> 06:34.440]  Это иногда полезно для того, чтобы отлавливать,
[06:34.440 --> 06:36.440]  вдруг вы случайно обратились за границу,
[06:36.440 --> 06:41.440]  и тем самым у вас что-то странное в программе происходит.
[06:41.440 --> 06:43.440]  Вот. Когда вы пишете add, вы гарантированно получите
[06:43.440 --> 06:46.440]  ошибку, и программа упадет, если вы обратитесь за
[06:46.440 --> 06:48.440]  пределы допустимого.
[06:48.440 --> 06:53.440]  Да. Можно писать str add, присвоить что-то другое.
[06:53.440 --> 06:55.440]  И это нормально будет работать.
[06:55.440 --> 06:57.440]  Вот. И разница между квадратными скобками в том,
[06:57.440 --> 07:01.440]  что вот метод add, он гарантированно упадет,
[07:01.440 --> 07:05.440]  если вы обращаетесь за пределы допустимого.
[07:05.440 --> 07:08.440]  Вот. Ну давайте, наверное, еще несколько функций у
[07:08.440 --> 07:10.440]  строк мы обсудим.
[07:10.440 --> 07:14.440]  Значит, какие есть еще полезные вещи?
[07:14.440 --> 07:17.440]  Ну, во-первых, можно сказать resize.
[07:17.440 --> 07:20.440]  Вот. Есть size, а есть resize.
[07:20.440 --> 07:22.440]  Что такое resize?
[07:22.440 --> 07:24.440]  Это значит изменить размер на такой,
[07:24.440 --> 07:26.440]  какой сказали.
[07:26.440 --> 07:28.440]  Вот. str.resize.
[07:28.440 --> 07:32.440]  Это значит сделать размер строки, ну, например, 5,
[07:32.440 --> 07:36.440]  и вторым аргументом можно передать символ,
[07:36.440 --> 07:40.440]  которым нужно заполнить оставшиеся элементы.
[07:40.440 --> 07:42.440]  Ну, например, не знаю, е.
[07:42.440 --> 07:47.440]  Вот. Ну, давайте, значит, вот так делать нельзя, да?
[07:47.440 --> 07:51.440]  Вот после этого действия строка моя будет равна чему?
[07:51.440 --> 07:53.440]  ABD.
[07:53.440 --> 07:57.440]  Ну, точнее, вот после этого действия она будет равна BBD.
[07:57.440 --> 07:59.440]  BBC.
[07:59.440 --> 08:02.440]  После этого действия она станет равна BBD.
[08:02.440 --> 08:06.440]  А после str.resize, вот такого, она станет равна...
[08:09.440 --> 08:13.440]  Она станет равна BBD.
[08:13.440 --> 08:18.440]  Вот. А после такого действия она станет равна BBDE.
[08:18.440 --> 08:20.440]  Потому что я сделал размер 5,
[08:20.440 --> 08:25.440]  и вот лишние элементы заполнено символом е.
[08:25.440 --> 08:27.440]  Вот.
[08:27.440 --> 08:31.440]  Я могу сделать resize и на меньше размер, чем у меня было изначально.
[08:31.440 --> 08:35.440]  Тогда просто, ну, дропнутся те элементы, которые лишние были.
[08:35.440 --> 08:37.440]  То есть я могу сказать, например, str.resize2,
[08:37.440 --> 08:39.440]  и строка превратится просто в BB.
[08:42.440 --> 08:44.440]  Вот. Хорошо.
[08:44.440 --> 08:46.440]  Что еще можно делать со строкой?
[08:46.440 --> 08:49.440]  Ну, со строкой можно делать всякие...
[08:49.440 --> 08:53.440]  Можно, например, делать такую операцию pushback.
[08:53.440 --> 08:55.440]  Тоже полезная операция.
[08:55.440 --> 08:58.440]  Это значит дописать в конец какой-то символ.
[08:58.440 --> 09:00.440]  str.pushback,
[09:01.440 --> 09:05.440]  например, ну, не знаю, f.
[09:07.440 --> 09:11.440]  И тогда строка станет равна BBDEF.
[09:11.440 --> 09:12.440]  Ну, понятно.
[09:12.440 --> 09:17.440]  Вот. А также можно делать popback.
[09:19.440 --> 09:21.440]  Так, что-то у меня место закончилось.
[09:21.440 --> 09:23.440]  Ну, давайте я здесь начну писать.
[09:23.440 --> 09:25.440]  Можно делать еще popback.
[09:25.440 --> 09:27.440]  Popback это значит наоборот.
[09:27.440 --> 09:31.440]  Выкинуть последний символ, тем самым размер уменьшится на единицу.
[09:32.440 --> 09:35.440]  Вот. Таким образом размер строки можно менять в рентайме,
[09:35.440 --> 09:37.440]  вот, динамически по ходу программы.
[09:38.440 --> 09:42.440]  А можно складывать строки, можно дописывать к строкам другие строки.
[09:42.440 --> 09:48.440]  То есть можно делать str1 plus str2,
[09:49.440 --> 09:51.440]  str, ну, вот тут у вас есть,
[09:51.440 --> 09:53.440]  допустим, у меня есть еще одна строка,
[09:53.440 --> 09:57.440]  тогда я могу сказать str plus str2,
[09:57.440 --> 09:59.440]  ну, допустим, если у меня была бы еще строка str2,
[09:59.440 --> 10:01.440]  тогда это была бы конкатинация.
[10:01.440 --> 10:03.440]  То есть я приписал справа вторую строку к первой.
[10:03.440 --> 10:06.440]  И я могу также делать plus равно.
[10:06.440 --> 10:08.440]  То есть я могу к строке...
[10:09.440 --> 10:13.440]  Вот в чем разница? str plus str2 это просто новая строка,
[10:13.440 --> 10:15.440]  но при этом исходные строки не поменялись,
[10:15.440 --> 10:17.440]  а str plus равно str2.
[10:17.440 --> 10:19.440]  Это значит, что строка str поменяется,
[10:19.440 --> 10:21.440]  я к str дописал справа строку str2,
[10:21.440 --> 10:24.440]  и то, что получилось, это теперь строка str.
[10:25.440 --> 10:27.440]  Могу также символы дописывать к строке,
[10:27.440 --> 10:32.440]  str plus равно, не знаю, j.
[10:35.440 --> 10:38.440]  Могу строки дописывать к строке str plus равно,
[10:38.440 --> 10:40.440]  и в кавычках какая-то строка, все это будет работать.
[10:40.440 --> 10:42.440]  Minus равно делать нельзя.
[10:43.440 --> 10:46.440]  И умножить делать нельзя, вот, умножать строки нельзя.
[10:48.440 --> 10:50.440]  Так.
[10:50.440 --> 10:52.440]  Ну, есть еще несколько полезных функций,
[10:52.440 --> 10:53.440]  связанных со строками.
[10:53.440 --> 10:56.440]  Например, можно делать поиск под строки,
[10:56.440 --> 10:58.440]  там есть функция subster,
[10:58.440 --> 11:01.440]  есть функция какой-нибудь там...
[11:02.440 --> 11:05.440]  Господи, что еще там есть полезного?
[11:07.440 --> 11:09.440]  Ладно, я даже не хочу вспоминать,
[11:09.440 --> 11:11.440]  но я не буду про них рассказывать,
[11:11.440 --> 11:14.440]  вы про них можете почитать на cpp-референс,
[11:14.440 --> 11:17.440]  открыть и почитать, что еще строки умеют,
[11:17.440 --> 11:19.440]  но самая базовая операция я перечислил.
[11:24.440 --> 11:25.440]  Так.
[11:26.440 --> 11:27.440]  Что-то я еще хотел сказать.
[11:27.440 --> 11:28.440]  А, вот еще что.
[11:28.440 --> 11:33.440]  Можно делать приведение строки к числу,
[11:33.440 --> 11:36.440]  ну, есть функция для преобразования int в строку и обратно.
[11:36.440 --> 11:38.440]  То есть вы можете, например,
[11:38.440 --> 11:41.440]  если у вас есть число int,
[11:41.440 --> 11:44.440]  да, int x равно, не знаю, 55,
[11:44.440 --> 11:47.440]  то вы можете захотеть сделать из него строку,
[11:47.440 --> 11:49.440]  для этого есть функция std to string.
[11:51.440 --> 11:54.440]  Вот, std to string от int,
[11:54.440 --> 11:59.440]  она берет этот int и превращает его в std string.
[11:59.440 --> 12:03.440]  Ну, соответственно, как будто это строка 55-5.
[12:04.440 --> 12:05.440]  Вот.
[12:06.440 --> 12:08.440]  Обратное преобразование...
[12:08.440 --> 12:14.440]  Ну, не так тривиально, я бы сказал.
[12:14.440 --> 12:17.440]  Такой прям функции, чтобы из строки сделать число.
[12:17.440 --> 12:21.440]  Но она есть, но там в силу некоторых причин
[12:21.440 --> 12:23.440]  мы лучше попозже про это поговорим.
[12:23.440 --> 12:25.440]  Но вот из числа сделать строку вот так.
[12:25.440 --> 12:26.440]  Можно.
[12:26.440 --> 12:28.440]  Это c++-ный способ так сделать.
[12:28.440 --> 12:31.440]  Есть еще функции из библиотеки C,
[12:31.440 --> 12:32.440]  которые это позволяют делать,
[12:32.440 --> 12:34.440]  но про них мы тоже попозже поговорим,
[12:34.440 --> 12:35.440]  пока вот только об этом поговорим.
[12:35.440 --> 12:38.440]  Ну и второй тип, который мы будем постоянно,
[12:38.440 --> 12:41.440]  всегда везде использовать, это вектор.
[12:41.440 --> 12:44.440]  Значит, вектор – это динамический массив,
[12:44.440 --> 12:46.440]  то есть расширяющийся по ходу дела.
[12:46.440 --> 12:49.440]  Значит, std-вектор...
[12:50.440 --> 12:55.440]  он в угловых скобочках имеет параметр от какого типа,
[12:55.440 --> 12:56.440]  ну, например, от int.
[12:56.440 --> 12:59.440]  Вот я могу написать std-вектор int v.
[12:59.440 --> 13:01.440]  Это динамический массив,
[13:01.440 --> 13:04.440]  то есть массив, меняющий свой размер по ходу программы.
[13:04.440 --> 13:05.440]  Вот.
[13:05.440 --> 13:08.440]  Ну, что можно делать с вектором?
[13:08.440 --> 13:12.440]  Да на самом деле с вектором можно делать все то же, что и со строкой.
[13:12.440 --> 13:15.440]  Сейчас я проверю, что я вас не обманул нигде.
[13:15.440 --> 13:16.440]  Ну кроме...
[13:16.440 --> 13:19.440]  Вот на самом деле все операции, которые я перечислил для строки,
[13:19.440 --> 13:21.440]  я не буду их даже заново перечислять.
[13:21.440 --> 13:26.440]  Ну вот все кроме этого актуально и для вектора.
[13:26.440 --> 13:29.440]  Вот все то, что перечислено на этой странице, актуально для вектора.
[13:29.440 --> 13:33.440]  То есть я могу вектор делать resize
[13:33.440 --> 13:39.440]  и говорить, заполни вектор каким-то количеством элементов с таким-то значением.
[13:39.440 --> 13:40.440]  Вот.
[13:40.440 --> 13:44.440]  Кстати, я могу сказать resize без уточнения каким значением,
[13:44.440 --> 13:48.440]  и тогда он будет заполниться значениями по умолчанию, в данном случае нулями.
[13:48.440 --> 13:49.440]  Вот.
[13:49.440 --> 13:51.440]  Для int-ов это будут нули.
[13:53.440 --> 13:58.440]  resize 5 это значит вектор станет из 5 нулей.
[13:58.440 --> 13:59.440]  Вот.
[13:59.440 --> 14:02.440]  А могу сказать resize, не знаю, 5 запятая 1,
[14:02.440 --> 14:05.440]  это значит вектор станет из 5 единиц.
[14:06.440 --> 14:07.440]  Дальше.
[14:07.440 --> 14:11.440]  Я могу обращаться по индексу к элементам вектора и менять их.
[14:11.440 --> 14:13.440]  v3 равно 2.
[14:13.440 --> 14:16.440]  Теперь мой вектор это будет значит...
[14:16.440 --> 14:17.440]  Что?
[14:17.440 --> 14:21.440]  Мой вектор сейчас будет 1, 1, 1, 2, 1.
[14:21.440 --> 14:24.440]  Потому что третий элемент это вот этот.
[14:24.440 --> 14:26.440]  Индексация с нуля, разумеется.
[14:26.440 --> 14:29.440]  То же самое у меня есть функция add,
[14:29.440 --> 14:33.440]  чтобы обратиться по индексу с гарантией проверки, что я не вышел за пределы.
[14:33.440 --> 14:36.440]  Если я выхожу обращать по индексу за пределы вектора,
[14:36.440 --> 14:38.440]  опять это неопределенное поведение,
[14:38.440 --> 14:40.440]  может случиться что угодно,
[14:40.440 --> 14:43.440]  может я получу случайное значение, может я упаду.
[14:45.440 --> 14:49.440]  Я могу делать pushback, могу делать popback.
[14:49.440 --> 14:51.440]  То есть могу докладывать элементы в конец вектора,
[14:51.440 --> 14:53.440]  могу вынимать элементы с конца вектора.
[14:53.440 --> 14:57.440]  Кстати, да, что будет, если я сделаю popback от пустого вектора?
[14:57.440 --> 14:59.440]  Неопределенное поведение.
[14:59.440 --> 15:02.440]  Ну, скорее всего, тут я упаду,
[15:02.440 --> 15:05.440]  ну, программа упадет, но может и не упадет.
[15:05.440 --> 15:07.440]  Непонятно.
[15:07.440 --> 15:09.440]  Может что угодно произойти.
[15:10.440 --> 15:12.440]  Хорошо.
[15:12.440 --> 15:14.440]  Ну, наверное, это все, что я расскажу про вектор сейчас.
[15:14.440 --> 15:16.440]  Больше пока ничего не буду рассказывать,
[15:16.440 --> 15:19.440]  но, возможно, вы на семинарах уже больше успели поделать.
[15:19.440 --> 15:22.440]  Для нашей цели больше ничего не надо будет знать про него пока, в ближайшее время.
[15:22.440 --> 15:25.440]  Потом мы, конечно,
[15:25.440 --> 15:28.440]  со временем мы изучим подробно, как он устроен изнутри
[15:28.440 --> 15:31.440]  и даже почти напишем его сами,
[15:31.440 --> 15:33.440]  но пока нам достаточно.
[15:33.440 --> 15:34.440]  Можно вопрос?
[15:34.440 --> 15:35.440]  Да, конечно.
[15:35.440 --> 15:38.440]  Вектор – это то же самое, что лист в питоне?
[15:39.440 --> 15:41.440]  Ну, идеологически да.
[15:42.440 --> 15:45.440]  Понятно, что там есть много нюансов,
[15:45.440 --> 15:47.440]  как они устроены чуть-чуть по-разному,
[15:47.440 --> 15:49.440]  но по смыслу да.
[15:49.440 --> 15:51.440]  Вектор в плюсах – это, по сути, лист в питоне.
[15:52.440 --> 15:54.440]  Но не путайте, пожалуйста, лист в плюсах.
[15:55.440 --> 15:57.440]  То, что в плюсах называется лист,
[15:57.440 --> 15:59.440]  это совсем не то же самое, что в питоне лист.
[16:00.440 --> 16:02.440]  То, что в плюсах называется лист,
[16:02.440 --> 16:03.440]  это на самом деле линк к лист,
[16:03.440 --> 16:06.440]  и это совсем другая по смыслу структура данных, чем вектор.
[16:07.440 --> 16:11.440]  Поэтому, соответственно, такой вектор из плюсов – это лист из питона,
[16:11.440 --> 16:13.440]  а лист из плюсов – я даже не знаю,
[16:13.440 --> 16:15.440]  в питоне есть аналогичный тип или нет.
[16:15.440 --> 16:18.440]  Кто знает, может, скажет, линк к листу питоне.
[16:18.440 --> 16:19.440]  Я не помню.
[16:20.440 --> 16:21.440]  Ну ладно.
[16:21.440 --> 16:22.440]  Хорошо.
[16:23.440 --> 16:24.440]  Так.
[16:24.440 --> 16:28.440]  Ну, еще я вам должен рассказать про литеральные суффиксы.
[16:32.440 --> 16:36.440]  Значит, что такое литеральные суффиксы?
[16:36.440 --> 16:38.440]  Что вообще такое литералы?
[16:39.440 --> 16:43.440]  Литералами называются последовательности символов,
[16:43.440 --> 16:47.440]  которые кодируют некоторое фиксированное значение какого-то типа.
[16:47.440 --> 16:50.440]  Например, я могу написать, не знаю,
[16:50.440 --> 16:52.440]  один – это литерал,
[16:52.440 --> 16:54.440]  5.0 – это литерал,
[16:54.440 --> 16:56.440]  ABC – это литерал.
[16:56.440 --> 16:59.440]  Вот такие последовательности символов называются литералами.
[16:59.440 --> 17:01.440]  True – это литерал.
[17:03.440 --> 17:07.440]  А у литералов предопределен тип.
[17:07.440 --> 17:12.440]  Вот если вы пишете литерал просто в последовательстве цифр,
[17:12.440 --> 17:14.440]  то это int.
[17:14.440 --> 17:16.440]  Вот у такого литерала тип double.
[17:16.440 --> 17:18.440]  Вот у такого литерала тип...
[17:18.440 --> 17:22.440]  Ну, тип такого литерала называется const char звездочка,
[17:22.440 --> 17:24.440]  или даже точнее const char массив,
[17:24.440 --> 17:26.440]  но забьем...
[17:26.440 --> 17:27.440]  Ну, это строка.
[17:27.440 --> 17:30.440]  Потом поговорим о том, что это значит.
[17:30.440 --> 17:32.440]  Вот у такого литерала тип bool.
[17:32.440 --> 17:34.440]  У такого литерала тип double, как я уже сказал,
[17:34.440 --> 17:36.440]  у такого литерала тип int.
[17:36.440 --> 17:40.440]  Вам иногда бывает, может, хотеться сделать,
[17:40.440 --> 17:43.440]  чтобы типом литерала считался float, например, а не double.
[17:43.440 --> 17:45.440]  Вот для этого есть литеральные суффиксы.
[17:45.440 --> 17:48.440]  Когда вы пишете дробное число вот так, через точку,
[17:48.440 --> 17:50.440]  оно по умолчанию считается типом double,
[17:50.440 --> 17:54.440]  но вы можете написать post fix f, ну, суффикс,
[17:54.440 --> 17:56.440]  и это будет означать float.
[17:56.440 --> 17:59.440]  То есть вот такой литерал будет тип float, считаться, а не double.
[17:59.440 --> 18:05.440]  Вот. Еще полезно, например, иногда делать так,
[18:05.440 --> 18:12.440]  чтобы литерал считался типом unsigned.
[18:12.440 --> 18:15.440]  Вот вам, возможно, хотелось бы, чтобы литерал считался не тип int,
[18:15.440 --> 18:16.440]  а тип unsigned.
[18:16.440 --> 18:19.440]  То есть тогда у вас есть суффикс u.
[18:21.440 --> 18:23.440]  Что еще скажу я про литералы?
[18:23.440 --> 18:28.440]  Еще можно в плюсах записывать целые числа
[18:28.440 --> 18:31.440]  в 16-ричной или в 8-ричной системе.
[18:31.440 --> 18:34.440]  И даже, по-моему, начиная с какой-то версии, можно в 2-ричной,
[18:34.440 --> 18:36.440]  но я все время забываю, с какой и можно ли.
[18:36.440 --> 18:38.440]  Но точно можно в 16-ричной.
[18:38.440 --> 18:41.440]  Вот если вам почему-то нужно записать целое число в 16-ричной системе,
[18:41.440 --> 18:43.440]  то вы просто начинаете его с 0x.
[18:43.440 --> 18:47.440]  Например, вы пишете 0xff, и это означает 255.
[18:47.440 --> 18:50.440]  Если вам надо записать число в 8-ричной системе,
[18:50.440 --> 18:52.440]  вы пишете, например, 0123.
[18:52.440 --> 18:54.440]  Значит, в 8-ричной системе, чтобы записать число,
[18:54.440 --> 18:56.440]  надо просто его с нуля начать.
[18:56.440 --> 18:58.440]  Вот если у вас литерал целое число начинается с нуля,
[18:58.440 --> 19:02.440]  значит он как будто компилятором в 8-ричной системе считается записанным.
[19:02.440 --> 19:07.440]  0123 это, соответственно, 64 плюс 16 плюс 3.
[19:07.440 --> 19:09.440]  Да, это 83 будет десятично.
[19:10.440 --> 19:16.440]  Еще полезное знание, что можно использовать
[19:16.440 --> 19:18.440]  одинарную кавычку или апостров
[19:18.440 --> 19:22.440]  для того, чтобы отделять разряды.
[19:22.440 --> 19:26.440]  Вот, например, если у вас есть длинное число там,
[19:26.440 --> 19:30.440]  ну, не знаю, миллион сорок восемь тысяч пятьсот семьдесят шесть,
[19:30.440 --> 19:33.440]  то вы можете, начиная си плюс плюс четырнадцать, правда,
[19:33.440 --> 19:35.440]  вот так писать,
[19:35.440 --> 19:40.440]  ну, то есть ставить апостров между как бы цифрами
[19:40.440 --> 19:42.440]  для удобства чтения.
[19:42.440 --> 19:44.440]  И это будет компилятором правильно читаться,
[19:44.440 --> 19:48.440]  как целочисленный литерал просто удобнее читать стать.
[19:56.440 --> 20:00.440]  Ну, 16-ричная система FF это сколько?
[20:00.440 --> 20:05.440]  Это получается 16 умножить на 15 плюс еще 15.
[20:05.440 --> 20:09.440]  240 плюс 15, 255.
[20:09.440 --> 20:13.440]  Ну, это максимальное значение, которое в один байт влезает, FF.
[20:13.440 --> 20:15.440]  Это полезно помнить, что это 255.
[20:18.440 --> 20:23.440]  Ну, и здесь же давайте я вкратце скажу про стандартные приведения типов.
[20:23.440 --> 20:27.440]  Ну, я, возможно, уже говорил в прошлый раз,
[20:27.440 --> 20:29.440]  так, очень скользко,
[20:29.440 --> 20:32.440]  но давайте еще раз проговорим это на всякий случай.
[20:32.440 --> 20:37.440]  Что происходит, если вы складываете или там вы читаете два числа,
[20:37.440 --> 20:40.440]  ну, или две переменных чуть-чуть разных типов.
[20:40.440 --> 20:42.440]  Если они оба целочисленных типов,
[20:42.440 --> 20:47.440]  то у вас происходит поднятие до того, который больше по охвату.
[20:47.440 --> 20:50.440]  Вот, это называется integer promotion.
[20:50.440 --> 20:52.440]  Это стандартное преобразование,
[20:52.440 --> 20:56.440]  то есть когда вы, например, складываете чар с интом,
[20:56.440 --> 20:58.440]  то результат получается инт.
[20:58.440 --> 21:00.440]  Если вы складываете инт с лонг-лонгом,
[21:00.440 --> 21:02.440]  то результат получается лонг-лонг.
[21:02.440 --> 21:04.440]  Ну, логично.
[21:04.440 --> 21:07.440]  Да, кстати, если вы хотите литеральный суффикс для лонг-лонга,
[21:07.440 --> 21:09.440]  то пишите ll в конце.
[21:09.440 --> 21:11.440]  Ну, и можно еще написать ull.
[21:11.440 --> 21:13.440]  Это будет означать unsigned long-long.
[21:13.440 --> 21:16.440]  Вот, это называется integer promotion.
[21:16.440 --> 21:19.440]  Или integral promotion.
[21:19.440 --> 21:21.440]  Значит, поднятие до...
[21:21.440 --> 21:27.440]  Это преобразование, которое расширяет тип до более широкого.
[21:27.440 --> 21:29.440]  Дальше есть floating-point promotion.
[21:29.440 --> 21:33.440]  Это когда вы складываете float с double.
[21:33.440 --> 21:36.440]  Float поднимается до double.
[21:36.440 --> 21:38.440]  Ну, если вам нужно сделать float и double,
[21:38.440 --> 21:40.440]  то float неявно приводится к double,
[21:40.440 --> 21:44.440]  и происходит так называемый floating-point promotion.
[21:44.440 --> 21:46.440]  Кроме того, есть стандартная конверсия.
[21:46.440 --> 21:48.440]  Если вы, допустим, складываете инт с double,
[21:48.440 --> 21:52.440]  то инт превращается, перекодируется в double на лету.
[21:52.440 --> 21:54.440]  И это называется стандартная конверсия.
[21:54.440 --> 21:57.440]  Ну, стандартная конверсия есть между многими типами.
[21:57.440 --> 21:59.440]  Например, между int и bool есть стандартная конверсия,
[21:59.440 --> 22:01.440]  как мы вроде уже обсуждали.
[22:01.440 --> 22:04.440]  То есть, если вы там по default пишете int,
[22:04.440 --> 22:07.440]  то он неявно приводится к bool.
[22:07.440 --> 22:13.440]  Да, ну, понятно, что можно из int получить bool,
[22:13.440 --> 22:16.440]  а из bool int, по неявному правилу, что...
[22:16.440 --> 22:18.440]  Ну, я говорил уже в прошлый раз, по какому.
[22:21.440 --> 22:23.440]  Ну, наверное, это все,
[22:23.440 --> 22:26.440]  что я хочу сказать вам про стандартные типы
[22:26.440 --> 22:29.440]  и про операции над ними на текущий момент.
[22:29.440 --> 22:32.440]  Пока что нам этого хватит.
[22:33.440 --> 22:35.440]  Вопросики.
[22:39.440 --> 22:41.440]  В каких случаях используются эти суффиксы?
[22:41.440 --> 22:43.440]  Ну, я вам могу привести такой пример.
[22:43.440 --> 22:45.440]  Представьте, что у вас...
[22:49.440 --> 22:52.440]  Ну, я вам даже два примера приведу.
[22:52.440 --> 22:55.440]  Скажем, представьте, вы складываете double,
[22:55.440 --> 22:57.440]  вы складываете float,
[22:57.440 --> 22:59.440]  вот у вас переменная типа float,
[22:59.440 --> 23:02.440]  и вы хотите ее сложить с пятеркой.
[23:02.440 --> 23:06.440]  Если вы так напишете, то произойдет floating point promotion,
[23:06.440 --> 23:08.440]  как я уже сказал, потому что тип double
[23:08.440 --> 23:10.440]  нужно поднять это double, сделать,
[23:10.440 --> 23:11.440]  а потом обратно во float.
[23:11.440 --> 23:13.440]  То есть тип вот этого выражения double.
[23:13.440 --> 23:16.440]  И если вы его присваиваете float,
[23:16.440 --> 23:19.440]  то у вас получится преобразование сначала вверх до double,
[23:19.440 --> 23:21.440]  а потом обратно обрезание до float.
[23:21.440 --> 23:23.440]  Если вы хотите оставаться внутри float'ов,
[23:23.440 --> 23:25.440]  не подниматься до double,
[23:25.440 --> 23:27.440]  то вам нужно писать вот здесь f,
[23:27.440 --> 23:30.440]  тогда у вас не произойдет конверсии в double при сложении.
[23:30.440 --> 23:33.440]  Другой пример, если у вас есть две функции,
[23:33.440 --> 23:35.440]  не знаю там, функция, которая принимает double
[23:35.440 --> 23:37.440]  и функция, которая принимает float
[23:37.440 --> 23:39.440]  с одинаковыми именами,
[23:39.440 --> 23:42.440]  то когда вы вызываетесь от вот такого параметра,
[23:42.440 --> 23:44.440]  вы попадете в версию, которая double принимает.
[23:44.440 --> 23:46.440]  А когда вы вызываетесь от такого параметра,
[23:46.440 --> 23:48.440]  вы попадете в версию, которая float принимает.
[23:48.440 --> 23:51.440]  Ну и банально, например...
[23:51.440 --> 23:54.440]  зачем может быть нужен суффикс u?
[23:54.440 --> 23:56.440]  суффикс u очень полезен
[23:56.440 --> 23:58.440]  когда вы делаете операции с целыми числами.
[23:58.440 --> 24:01.440]  Ладно, суффикс у, наверно, мой пример не актуален.
[24:01.440 --> 24:03.440]  Ну вот если вы складываете знаковое целое число
[24:03.440 --> 24:04.440]  и беззнаковое целое число,
[24:04.440 --> 24:05.440]  то у вас происходит
[24:05.440 --> 24:07.440]  неявное преобразование их беззнаковому.
[24:07.440 --> 24:12.980]  Вам, возможно, нужны суффиксы для того, чтобы явно сказать, какой вы хотите тип
[24:12.980 --> 24:16.220]  результатов. То есть, просто когда вы не хотите, чтобы у вас неявно происходило
[24:16.220 --> 24:21.280]  преобразование между разными видами целых чисел, вы пишете суффикс, чтобы типы
[24:21.280 --> 24:24.240]  были точно одинаковые, и тогда у вас никаких неявных преобразований не
[24:24.240 --> 24:27.120]  происходит. Но обычного для этого не нужно.
[24:27.120 --> 24:29.120]  Почему в одном месте 0x, а потом просто 0?
[24:29.120 --> 24:34.480]  Еще раз, 0x это если вы хотите в 16-ричной системе записать, а просто 0 это если в 8-ричной.
[24:34.480 --> 24:36.480]  Спасибо.
[24:38.480 --> 24:40.480]  Это все ИН.
[24:40.480 --> 24:42.480]  Да.
[24:42.480 --> 24:44.480]  А лонг-лог можно?
[24:44.480 --> 24:46.480]  Не знаю, кстати.
[24:46.480 --> 24:50.480]  Не знаю, можно ли в 16-ричной системе записать лонг-логи.
[24:50.480 --> 24:52.480]  То есть, можно ли писать 0xffll?
[24:52.480 --> 24:54.480]  Не знаю, можете попробовать.
[24:56.480 --> 25:02.480]  А можно суффиксы для лонг-лога использовать для ИНТ и написать?
[25:02.480 --> 25:06.480]  Да, по-моему нет суффикса, потому что литерал и так имеет тип ИНТ,
[25:06.480 --> 25:08.480]  если вы его написали без каких-либо суффиксов.
[25:08.480 --> 25:12.480]  Но для разных, но для других типов есть свои суффиксы,
[25:12.480 --> 25:16.480]  можете посмотреть на cp-reference, там их достаточно много.
[25:16.480 --> 25:20.480]  Но для ИНТа не нужен суффикс, потому что он и так ИНТ в умолчании.
[25:20.480 --> 25:22.480]  Получается, если мы сложим ИНТ и unsigned, то получится...
[25:22.480 --> 25:28.480]  Да, если вы складываете ИНТ и unsigned-ИНТ, то происходит приведение consigned-ИНТ.
[25:28.480 --> 25:31.480]  Это приводит иногда к неприятным последствиям,
[25:31.480 --> 25:34.480]  потому что если вы складываете, например,
[25:34.480 --> 25:38.480]  минус один с unsigned-ИНТ, то минус один превращается в 4 миллиарда,
[25:38.480 --> 25:41.480]  происходит переполнение, прыжок через максимум,
[25:41.480 --> 25:43.480]  и это приводит к неприятным последствиям.
[25:43.480 --> 25:47.480]  Будьте аккуратны, когда складываете значения разных типов, не совпадающих.
[25:47.480 --> 25:51.480]  Компилятор вам, возможно, даже предупреждения выдаст, если вы так делаете.
[25:52.480 --> 25:55.480]  Так, ладно, давайте пойдем дальше.
[25:55.480 --> 26:03.480]  Дальше параграф 1.3, и тут я, наверное, перейду к кодированию.
[26:03.480 --> 26:09.480]  Следующий параграф будет называться объявления, определения и области видимости.
[26:16.480 --> 26:23.480]  Ну, я буду стандартно начинать свои изыскания с вот таких заготовочек программ.
[26:23.480 --> 26:27.480]  По-английски это называется declarations, definitions and scopes.
[26:32.480 --> 26:37.480]  Ну, смотрите, давайте, после того, как мы обсудили,
[26:37.480 --> 26:41.480]  какие бывают переменные в программе, поговорим о том,
[26:41.480 --> 26:43.480]  и что вообще состоит программа на плюсах.
[26:43.480 --> 26:47.480]  Программа на самом деле состоит из объявлений, как ни странно.
[26:47.480 --> 26:52.480]  Ну, когда вы пишете программу на плюсах, вы на самом деле,
[26:52.480 --> 26:57.480]  все, что вы делаете, это на глобальном уровне, на верхнем уровне,
[26:57.480 --> 26:59.480]  вы просто объявляете сущности раз за разом.
[27:00.480 --> 27:04.480]  Ну, вы можете что-то заинклудить, но если вы что-то инклудите,
[27:04.480 --> 27:07.480]  то по факту вы же все равно, извините.
[27:09.480 --> 27:11.480]  Ну, что такое include.io stream?
[27:11.480 --> 27:15.480]  Это какой-то файл, в котором тоже что-то объявлено, там нет ничего,
[27:15.480 --> 27:18.480]  в котором тоже что-то объявлено, там namespace какой-то,
[27:18.480 --> 27:20.480]  и внутри него что-то там объявлено.
[27:22.480 --> 27:24.480]  По сути, когда вы делаете include,
[27:24.480 --> 27:29.480]  это значит, что вы просто вставляете в код вашей программы содержимое этого файла.
[27:30.480 --> 27:36.480]  Но если забить на include, то все, что вы делаете в дальнейшем,
[27:36.480 --> 27:38.480]  это просто вы объявляете какие-то штуки подряд.
[27:38.480 --> 27:42.480]  Вы можете объявлять переменные, вы можете объявлять функции,
[27:42.480 --> 27:45.480]  вы можете объявлять классы, вы можете объявлять namespaces,
[27:45.480 --> 27:47.480]  ну, еще разные вещи вы можете объявлять,
[27:47.480 --> 27:51.480]  и по сути на верхнем уровне ваша программа не состоит из этих объявлений.
[27:52.480 --> 27:56.480]  Но вот то, что у нас сейчас написано, это просто объявление функции main,
[27:56.480 --> 27:59.480]  но можно кроме функции main еще что-нибудь пообъявлять.
[27:59.480 --> 28:01.480]  Я могу объявлять переменные.
[28:02.480 --> 28:07.480]  Я могу, например, сказать int x вот глобально, вот здесь, вот на верхнем уровне.
[28:09.480 --> 28:11.480]  Я могу объявлять и другие вещи.
[28:12.480 --> 28:16.480]  Ну, кроме переменных и функций, я еще могу объявлять, как я уже сказал, классы,
[28:16.480 --> 28:17.480]  чтобы это не значило.
[28:17.480 --> 28:19.480]  Вот я могу написать классы, c.
[28:19.480 --> 28:21.480]  Это я объявил class сейчас.
[28:22.480 --> 28:24.480]  Я могу объявлять структуры, struct s.
[28:24.480 --> 28:26.480]  Это я объявил некоторую структуру s.
[28:26.480 --> 28:30.480]  Не важно, что это такое вообще, это нас сейчас даже не интересует.
[28:30.480 --> 28:36.480]  Важно, что пассивность ссо, что я делаю, это я просто объявляю сущности подряд раз за разом.
[28:37.480 --> 28:38.480]  Вот.
[28:40.480 --> 28:46.480]  Ну, какие еще бывают виды сущностей, классы, структуры там и прочее, это мы потом пообсуждаем.
[28:46.480 --> 28:52.480]  Сейчас суть в том, чтобы понять, что на самом деле программа это пассивность объявлений.
[28:52.480 --> 28:58.480]  И давайте поподробнее поговорим про объявление переменных и про объявление функций.
[28:58.480 --> 29:02.480]  Ну, про объявление переменных, в общем-то, особо нечего, наверное, говорить.
[29:02.480 --> 29:04.480]  Что такое объявление переменной?
[29:04.480 --> 29:09.480]  Это просто тип, а потом имя переменной и точка запятой.
[29:09.480 --> 29:16.480]  Возможно, имя переменной делается с инициализацией.
[29:16.480 --> 29:18.480]  Например, вот так я могу написать.
[29:18.480 --> 29:20.480]  Тип, имя равно чему-то.
[29:20.480 --> 29:24.480]  Это не просто объявление, это инициализация еще.
[29:25.480 --> 29:32.480]  Вот если я в глобальной области, вот эта вот область, которая вне всех функций, вне всяких там фигурных скобочек, называется глобальной.
[29:32.480 --> 29:34.480]  Вот это называется global scope.
[29:34.480 --> 29:37.480]  Scope переводится как область видимости.
[29:37.480 --> 29:40.480]  Вот то, что здесь находится, это глобальная область видимости.
[29:40.480 --> 29:46.480]  Если я в глобальной области видимости объявляю переменную, то она по умолчанию инициализируется нулем.
[29:46.480 --> 29:48.480]  Ну, in, я имею в виду.
[29:48.480 --> 29:50.480]  Если bool, то false.
[29:50.480 --> 29:58.480]  Ну, в общем, если я какую-то переменную стандартного типа объявляю встроенного, то она инициализируется нулевым значением для себя в глобальной области.
[29:58.480 --> 30:02.480]  Если я так делаю внутри мейна, то это уже неверно.
[30:02.480 --> 30:05.480]  Вот здесь уже неверно, что будет ноль обязательно.
[30:05.480 --> 30:08.480]  Вот здесь может быть рандомное значение.
[30:08.480 --> 30:10.480]  Но здесь обязательно ноль.
[30:10.480 --> 30:23.480]  Ну, если я объявляю строку или вектор, то она инициализируется пустой строкой, соответственно, пустым вектором.
[30:23.480 --> 30:28.480]  Причем это уже не зависит от того, где я объявляю глобально или вот здесь, локально.
[30:28.480 --> 30:34.480]  Значит, вот эта область, которая внутри функции называется local scope, локальная область видимости.
[30:34.480 --> 30:36.480]  А это глобальная область видимости.
[30:37.480 --> 30:42.480]  Хорошо. Ну, про объявление переменных, наверное, все понятно.
[30:42.480 --> 30:44.480]  Тип и название.
[30:44.480 --> 30:46.480]  Но я могу еще через запятую несколько объявить за раз.
[30:46.480 --> 30:48.480]  Я могу сказать там x запятая y.
[30:48.480 --> 30:50.480]  Это я, значит, объявил сразу две.
[30:50.480 --> 30:53.480]  Причем я могу вот так сделать, разное значение придать.
[30:53.480 --> 30:56.480]  Но по кодстайлу не рекомендуется так делать.
[30:56.480 --> 31:01.480]  Я вас буду отучать объявлять несколько переменных на одной строке, потому что это затрудняет читаемость.
[31:01.480 --> 31:06.480]  И лучше, ну, в общем, современный кодстайл обычно рекомендует так не писать.
[31:06.480 --> 31:08.480]  Мы тоже будем стараться так не писать.
[31:08.480 --> 31:10.480]  За редким исключением.
[31:10.480 --> 31:13.480]  Вот. Давайте поговорим об объявлении функций.
[31:13.480 --> 31:16.480]  Ну, что такое функция, думаю, вы все знаете.
[31:16.480 --> 31:19.480]  Это школьная программа.
[31:19.480 --> 31:24.480]  Вот. Мы с вами пока знаем только одну функцию main, но я могу объявлять другие функции.
[31:24.480 --> 31:27.480]  Ну вот, давайте я объявлю какую-нибудь функцию f.
[31:28.480 --> 31:31.480]  Функция точно так же начинается с возвращаемого типа.
[31:31.480 --> 31:35.480]  Потом идет имя функции и в скобочках типа аргументов.
[31:35.480 --> 31:38.480]  Функция может ничего не возвращать.
[31:38.480 --> 31:41.480]  И тогда типа ее возвращаемого значения void.
[31:41.480 --> 31:45.480]  Вот void это специальный такой тип, который означает, что функция не возвращает ничего.
[31:45.480 --> 31:49.480]  Void, собственно, переводится как пустота или вакуум.
[31:49.480 --> 31:51.480]  С английского, если кто не знал.
[31:51.480 --> 31:53.480]  Ну вот, я могу написать void f.
[31:53.480 --> 31:55.480]  Дальше я открываю скобочку и перечитаю аргументы.
[31:55.480 --> 31:59.480]  Например, void f от int, запятая double.
[31:59.480 --> 32:03.480]  Ну, я могу этим аргументам имена придать.
[32:03.480 --> 32:07.480]  Например, могу сказать вот так int a, double b.
[32:07.480 --> 32:14.480]  Но если я объявляю функцию, я могу имена переменных и не называть.
[32:14.480 --> 32:17.480]  Я могу просто типа указать, а не обязательно называть имена.
[32:17.480 --> 32:21.480]  Имена мне нужны только если я пользуюсь этими именами.
[32:21.480 --> 32:23.480]  Если я определяю функцию.
[32:23.480 --> 32:29.480]  А если я просто вот так объявил, сказал, что есть какая-то еще функция f, которая принимает int и double,
[32:29.480 --> 32:31.480]  то имена не обязательно писать.
[32:31.480 --> 32:33.480]  Я буду часто так делать.
[32:33.480 --> 32:35.480]  Пропускать имена, если они не нужны.
[32:35.480 --> 32:37.480]  Имена переменных я имею в виду.
[32:37.480 --> 32:39.480]  А как тогда обращаться к аргументам внутри функции?
[32:39.480 --> 32:41.480]  Так, если я не собираюсь...
[32:41.480 --> 32:45.480]  Вот сейчас я просто объявил функцию и не собираюсь ни к чему обращаться.
[32:45.480 --> 32:50.480]  А если я в дальнейшем ее буду определять и уже использовать аргументы,
[32:50.480 --> 32:52.480]  то тогда я начну.
[32:52.480 --> 32:54.480]  Тогда я дам имена.
[32:54.480 --> 32:56.480]  И это ничему не мешает.
[32:56.480 --> 33:00.480]  Вот, здесь как раз мы приходим к разнице между объявлением и определением.
[33:00.480 --> 33:02.480]  Вот то, что я сейчас сделал, это просто объявление функции.
[33:02.480 --> 33:06.480]  Я просто сказал, что есть такая функция, но еще не объяснил, что она делает.
[33:06.480 --> 33:10.480]  Тем не менее, компилятор с этого момента уже значит, что такая функция есть.
[33:10.480 --> 33:14.480]  Но я могу потом определить эту функцию.
[33:14.480 --> 33:20.480]  Определить функцию, это значит написать ее тело.
[33:20.480 --> 33:26.480]  То есть после сигнатуры, вот это называется сигнатурой, набор аргументов принимаемых и имя,
[33:26.480 --> 33:28.480]  я пишу фигурную скобочку и определяю тело.
[33:28.480 --> 33:30.480]  То есть, что делает эта функция?
[33:30.480 --> 33:40.480]  Ну, например, выводит все аут, не знаю, hello, а потом говорит a плюс b.
[33:40.480 --> 33:42.480]  И еще перевоз шаги.
[33:42.480 --> 33:46.480]  Тут происходит неявная конверсия типов, как вы понимаете, int double.
[33:46.480 --> 33:54.480]  И я могу вызвать эту функцию f от 1 запятая 3,5.
[34:02.480 --> 34:06.480]  Получилось 4,5.
[34:06.480 --> 34:10.480]  Ну, понятно, сложился int с double, получился double.
[34:10.480 --> 34:16.480]  Вот. Заметьте, что когда я определяю функцию, я уже аргументы использую.
[34:16.480 --> 34:20.480]  А пока я ее объявлял, аргументы мне были не нужны.
[34:20.480 --> 34:24.480]  Я мог, вообще говоря, даже не использовать и здесь какой-то из аргументов,
[34:24.480 --> 34:26.480]  просто сказать вот так.
[34:26.480 --> 34:30.480]  То есть я функцию аргументов передал, но в реальности его не использовал.
[34:30.480 --> 34:32.480]  Ну, бывает.
[34:32.480 --> 34:36.480]  Просто функция принимает два аргумента, но в реальности использует только один.
[34:36.480 --> 34:40.480]  Такое тоже вполне себе легально, и так можно делать.
[34:40.480 --> 34:44.480]  И на самом деле такое даже бывает иногда нужно делать,
[34:44.480 --> 34:46.480]  когда-нибудь у вас такие ситуации возникнут.
[34:46.480 --> 34:50.480]  А можно не писать int double во втором?
[34:50.480 --> 34:52.480]  Нет, нельзя.
[34:52.480 --> 34:54.480]  Вот типы аргументов обязательно надо перечислить заново,
[34:54.480 --> 34:58.480]  а имена можно уже... можно другие имена вообще дать.
[34:58.480 --> 35:04.480]  Например, у меня здесь был int c double d, а тут я сказал int a double b.
[35:04.480 --> 35:06.480]  И ничего страшного.
[35:06.480 --> 35:10.480]  При повторных объявлениях я могу имена менять,
[35:10.480 --> 35:12.480]  но типы должны быть такими же.
[35:14.480 --> 35:16.480]  Хорошо.
[35:18.480 --> 35:22.480]  Да, я сказал, типы должны быть такими же.
[35:22.480 --> 35:26.480]  Но на самом деле я могу объявить функцию и с другими типами, но с таким же именем.
[35:26.480 --> 35:30.480]  Например, я могу сказать voidev от int float.
[35:30.480 --> 35:32.480]  Но это будет уже другая функция.
[35:32.480 --> 35:36.480]  Я могу объявить разные функции, у которых одинаковые имена,
[35:36.480 --> 35:38.480]  просто типы аргументов разные.
[35:38.480 --> 35:42.480]  Вот в данном случае вот это f, и вот это f — это разные функции.
[35:42.480 --> 35:44.480]  И они могут делать разные вещи.
[35:44.480 --> 35:46.480]  Это называется перегрузка функций.
[35:46.480 --> 35:48.480]  Это очень важная возможность,
[35:48.480 --> 35:54.480]  это одна из важнейших возможностей языка C++ и всех C подобных языков,
[35:54.480 --> 35:58.480]  что можно иметь несколько функций, у которых одинаковые названия,
[35:58.480 --> 36:00.480]  но разные типы принимаемых аргументов.
[36:00.480 --> 36:04.480]  И на самом деле это то, чем вы постоянно пользуетесь, даже не думая об этом.
[36:04.480 --> 36:08.480]  Этим мы будем постоянно пользоваться, и это очень удобно.
[36:08.480 --> 36:12.480]  А когда вы делаете какую-нибудь операцию над чем-то,
[36:12.480 --> 36:16.480]  ну я не знаю, там sort, сортировка,
[36:16.480 --> 36:20.480]  или банально, господи, не знаю, two string, приведение к строке,
[36:20.480 --> 36:24.480]  вы же не называете операцию по-разному в зависимости от того,
[36:24.480 --> 36:28.480]  вы же не называете операцию по-разному в зависимости от того,
[36:28.480 --> 36:29.480]  что вы передали.
[36:29.480 --> 36:32.480]  Например, представьте, что у вас функция перевода int в строку
[36:32.480 --> 36:36.480]  называлась бы одним способом, а double в строку другим способом.
[36:36.480 --> 36:38.480]  Ну нет, они обе называются two strings.
[36:38.480 --> 36:42.480]  Логично, что вы, наверное, хотите, чтобы функция называлась одинаково,
[36:42.480 --> 36:44.480]  а работать умела с разными типами.
[36:44.480 --> 36:48.480]  Совсем дикий пример.
[36:48.480 --> 36:52.480]  Например, вы умеете складывать объекты, вы умеете сделать плюс.
[36:52.480 --> 36:58.480]  Вы же не хотите, чтобы плюс для int это был плюс одного вида,
[36:58.480 --> 37:01.480]  а плюс для doubles это плюс как-то по-другому выглядящий.
[37:01.480 --> 37:03.480]  Нет, они оба называются одинаково,
[37:03.480 --> 37:05.480]  просто работают с разными типами.
[37:05.480 --> 37:07.480]  Это две разных операции, на самом деле.
[37:07.480 --> 37:09.480]  То же самое и здесь.
[37:09.480 --> 37:12.480]  Мы всегда будем, и часто это очень удобно,
[37:12.480 --> 37:16.480]  делать функции, которые называются одинаково, но принимают разные аргументы.
[37:16.480 --> 37:18.480]  Это нормально, абсолютно.
[37:18.480 --> 37:22.480]  Это называется function overloading.
[37:30.480 --> 37:33.480]  Допустим, эта функция у меня будет выводить high.
[37:33.480 --> 37:37.480]  Та функция выводила hello, а эта функция будет выводить high.
[37:39.480 --> 37:42.480]  Здесь а непонятно, что такое, потому что я не передал значение.
[37:42.480 --> 37:44.480]  Пусть здесь тоже будет а.
[37:44.480 --> 37:46.480]  И вот смотрите, что происходит.
[37:46.480 --> 37:51.480]  Если я вызвался от int и double, то я попал в первую функцию.
[37:51.480 --> 37:55.480]  А если я напишу так, 1.3.5f,
[37:55.480 --> 37:58.480]  вы меня спрашивали, на что могут влиять литеральные суффиксы.
[37:58.480 --> 38:00.480]  А вот на что.
[38:00.480 --> 38:02.480]  Теперь я попаду во вторую функцию.
[38:03.480 --> 38:05.480]  Вам видно, я надеюсь?
[38:09.480 --> 38:11.480]  В первом случае я вызвался от int и double,
[38:11.480 --> 38:14.480]  во втором случае я вызвался от int и float.
[38:14.480 --> 38:17.480]  Это две разных функции, которые делают разные вещи.
[38:21.480 --> 38:22.480]  Хорошо.
[38:26.480 --> 38:30.480]  Мы с вами еще поподробнее поговорим о перегрузке функции попозже.
[38:31.480 --> 38:35.480]  На самом деле, здесь есть много подводных камней.
[38:35.480 --> 38:36.480]  Я даже...
[38:36.480 --> 38:38.480]  Сейчас я...
[38:38.480 --> 38:40.480]  Сейчас задать один вопрос.
[38:40.480 --> 38:41.480]  Есть много подводных камней.
[38:41.480 --> 38:45.480]  Например, что если у меня функции, которые...
[38:45.480 --> 38:46.480]  Ну вот скажем...
[38:46.480 --> 38:50.480]  Представьте, у меня есть функция, которая от double и от long double.
[38:50.480 --> 38:52.480]  А я от float вызвался.
[38:52.480 --> 38:53.480]  Что будет?
[38:53.480 --> 38:54.480]  Какая выберется?
[38:54.480 --> 38:57.480]  Вот тут начинаются так называемые...
[38:57.480 --> 39:00.480]  Вступают в действие правила перегрузки функций.
[39:00.480 --> 39:01.480]  Правила выбора версии.
[39:01.480 --> 39:04.480]  Если я вызываюсь от аргументов,
[39:04.480 --> 39:07.480]  и у меня нет точного соответствия типов аргументов типом того,
[39:07.480 --> 39:09.480]  от чего я вызвался,
[39:09.480 --> 39:13.480]  то начинает компилятор делать так называемую...
[39:14.480 --> 39:16.480]  Overloading Resolution.
[39:16.480 --> 39:17.480]  Разрешение перегрузки.
[39:17.480 --> 39:20.480]  То есть он смотрит на имеющиеся версии
[39:20.480 --> 39:23.480]  и решает, какая из них наиболее подходящая.
[39:24.480 --> 39:27.480]  Ну вот в данном случае наиболее подходящая будет первая,
[39:27.480 --> 39:30.480]  потому что конверсия от float в double
[39:30.480 --> 39:33.480]  это как бы меньше зло, чем конверсия от float в long double.
[39:33.480 --> 39:36.480]  То есть там есть очень длинный и сложный список правил.
[39:36.480 --> 39:38.480]  Вы можете открыть на себе переференцию статью
[39:38.480 --> 39:40.480]  Overloading Resolution Rules
[39:40.480 --> 39:42.480]  правила, по которым компилятор решает,
[39:42.480 --> 39:45.480]  что является более легким преобразованием.
[39:45.480 --> 39:48.480]  От float до double поднять это меньшее преобразование,
[39:48.480 --> 39:50.480]  чем от float до long double.
[39:50.480 --> 39:53.480]  Поэтому в данном случае он выберет
[39:53.480 --> 39:55.480]  от float до double поднять.
[39:56.480 --> 39:58.480]  Но если я например...
[39:58.480 --> 40:02.480]  Если у меня есть функция от int и float,
[40:03.480 --> 40:06.480]  и значит, ну я не знаю...
[40:07.480 --> 40:09.480]  Ну хорошо, вот представьте, у меня вот такие две функции.
[40:09.480 --> 40:11.480]  У меня есть функция от int и char
[40:11.480 --> 40:14.480]  и функция от int и float.
[40:14.480 --> 40:17.480]  И я решил вызваться от int и double.
[40:17.480 --> 40:20.480]  То в данном случае у меня будет ошибка компиляции вообще.
[40:21.480 --> 40:24.480]  Потому что преобразовать double к float
[40:24.480 --> 40:26.480]  и преобразовать double к char
[40:26.480 --> 40:29.480]  считается одинакового ранга плохими преобразованиями.
[40:29.480 --> 40:31.480]  То есть и то и другое это стандартная конверсия,
[40:31.480 --> 40:34.480]  и у них одинаковый ранг, так называемый.
[40:34.480 --> 40:39.480]  Они оба находятся в числе стандартных конверсий,
[40:39.480 --> 40:41.480]  сужающих диапазон.
[40:41.480 --> 40:44.480]  Поэтому выбор между ними сделать не получится.
[40:44.480 --> 40:47.480]  А, нет. Ух ты, я вас обманул.
[40:49.480 --> 40:51.480]  А, нет. Извините.
[40:51.480 --> 40:53.480]  Сейчас объясню, что произошло.
[40:53.480 --> 40:56.480]  Мне нужно еще вот эту версию документировать.
[40:56.480 --> 40:58.480]  Вот, выбор между ними сделать не получится.
[40:58.480 --> 40:59.480]  И видите, какая ошибка.
[40:59.480 --> 41:02.480]  Call of overloaded effort and double is ambiguous.
[41:02.480 --> 41:05.480]  Вызов функции неоднозначен.
[41:05.480 --> 41:08.480]  Непонятно, какую функцию вызвать.
[41:08.480 --> 41:11.480]  Вы на самом деле будете сталкиваться с этой ошибкой очень часто.
[41:11.480 --> 41:13.480]  Вы будете...
[41:13.480 --> 41:15.480]  Что там, беды какие-то?
[41:15.480 --> 41:17.480]  Да не то, что все хорошо.
[41:21.480 --> 41:23.480]  Вы будете часто сталкиваться с ситуацией,
[41:23.480 --> 41:26.480]  что вы вызываете какую-то функцию,
[41:26.480 --> 41:31.480]  и у вас ошибка со словами это ambiguous call
[41:31.480 --> 41:35.480]  и дальше длинный-длинный список кандидатов.
[41:35.480 --> 41:37.480]  Кандидат такой, кандидат такой.
[41:37.480 --> 41:41.480]  Значит, это означает, что у вас было много разных версий
[41:41.480 --> 41:43.480]  от хитипов вызваться.
[41:43.480 --> 41:45.480]  И то, от чего вы попросили вызваться, неоднозначно
[41:45.480 --> 41:47.480]  можно тактовать как вызов от того или от всего.
[41:47.480 --> 41:49.480]  Вот. Запомните эту ошибку,
[41:49.480 --> 41:51.480]  вы с ней много раз в жизни встретитесь, скорее всего.
[41:51.480 --> 41:53.480]  Какой был вопрос? Подождите, да.
[41:54.480 --> 41:56.480]  Вы сказали, что можно объявлять функцию несколько раз,
[41:56.480 --> 41:58.480]  а какое тогда trio определение будет staggering?
[41:58.480 --> 42:02.480]  Нет. Я сказал, что можно объявлять функцию несколько раз.
[42:02.480 --> 42:07.480]  А также можно объявлять функцию с разными типами аргументов.
[42:07.480 --> 42:09.480]  Но нельзя определять одну и ту же функцию,
[42:09.480 --> 42:11.480]  несколько раз.
[42:11.480 --> 42:15.480]  Значит, вот если я попробую определить
[42:15.480 --> 42:17.480]  функцию с такими же типами аргументов еще раз,
[42:17.480 --> 42:19.480]  это будет ошибка компиляции.
[42:19.480 --> 42:22.480]  Я не могу переопределить функцию с такими же типами.
[42:22.480 --> 42:24.720]  Но с другими типами я ее могу переопределить.
[42:24.720 --> 42:27.320]  Просто это будет другая функция уже на самом деле.
[42:27.320 --> 42:28.960]  Ну и что, что она называется так же?
[42:28.960 --> 42:29.960]  Функция это другая.
[42:29.960 --> 42:32.280]  Она другая, потому что тип аргументов другие.
[42:32.280 --> 42:33.280]  Это другая функция.
[42:33.280 --> 42:35.200]  Объявлять с теми же аргументами?
[42:35.200 --> 42:36.200]  Вот.
[42:36.200 --> 42:38.200]  Объявлять с теми же аргументами можно.
[42:38.200 --> 42:41.280]  А если мы уже определили и после этого объявлять все еще можно?
[42:41.280 --> 42:42.280]  Все еще можно.
[42:42.280 --> 42:43.280]  А что за теги?
[42:43.280 --> 42:44.280]  Что?
[42:44.280 --> 42:45.280]  А что она делает на теги?
[42:45.280 --> 42:46.280]  Не на что.
[42:46.280 --> 42:47.280]  Вот.
[42:47.280 --> 42:51.180]  Давайте сейчас как раз об этом поговорим.
[42:51.180 --> 42:52.180]  Это хороший вопрос.
[42:52.180 --> 42:55.180]  Хороший следующий пункт для обсуждения.
[42:55.180 --> 43:00.180]  Сейчас мы поговорим о разнице между объявлением и определением.
[43:00.180 --> 43:05.180]  Вот я вам сказал, что есть понятие declaration и есть понятие definition.
[43:05.180 --> 43:15.180]  Вот то, что я написал здесь, это declaration, not definition.
[43:15.180 --> 43:20.180]  Я объявил функцию от Intdouble, но не определил ее.
[43:20.180 --> 43:23.180]  А вот это определение.
[43:29.180 --> 43:32.180]  Любое определение является объявлением.
[43:32.180 --> 43:36.180]  Значит, если я что-то определяю, я тем самым его и объявляю.
[43:36.180 --> 43:37.180]  Но обратное неверно.
[43:37.180 --> 43:40.180]  Вот, например, я могу объявить, но не определить.
[43:40.180 --> 43:44.180]  Вот в данном случае у меня объявлено три разных функции.
[43:44.180 --> 43:48.180]  f от Intdouble, f от Intfloat и f от Intchar.
[43:48.180 --> 43:51.180]  Определены только две из них.
[43:51.180 --> 43:57.180]  Вот в данном случае, вот сейчас я поясню, какая ошибка произошла,
[43:57.180 --> 44:00.180]  на самом деле, когда я вот так сделал вот эту вот ошибку.
[44:00.180 --> 44:03.180]  Видите, что произошло?
[44:03.180 --> 44:07.180]  Я просто забыл, что у меня есть еще вот эта функция.
[44:07.180 --> 44:09.180]  И я вызвался от Intdouble.
[44:09.180 --> 44:14.180]  У меня на самом деле есть функция от Intdouble, просто она не определена.
[44:14.180 --> 44:16.180]  И у меня не случилась ошибка неоднозначности.
[44:16.180 --> 44:20.180]  У меня все однозначно, потому что компилятор выбирает версию от Intdouble.
[44:20.180 --> 44:21.180]  Она же есть.
[44:21.180 --> 44:22.180]  Но у нее нет определения.
[44:22.180 --> 44:26.180]  И поэтому я сталкиваюсь не с ошибкой того, что вызов неоднозначен,
[44:26.180 --> 44:32.180]  а с тем, что, ну, так называемая undefinedReference, то есть неопределенная ссылка.
[44:32.180 --> 44:36.180]  У меня функция эта есть, но определения у нее нет.
[44:36.180 --> 44:38.180]  И поэтому вызывать нечего.
[44:38.180 --> 44:42.180]  Вот эта ошибка undefinedReference2 и дальше написано что?
[44:42.180 --> 44:46.180]  Означает, что вы попробовали вызвать функцию, которая была объявлена, но не определена.
[44:46.180 --> 44:50.180]  С такой ошибкой вы тоже будете наверняка часто сталкиваться.
[44:50.180 --> 44:55.180]  И это на самом деле ошибка, которая относится к ошибкам лимковки, а не компиляции.
[44:55.180 --> 44:57.180]  Но я сейчас не буду пояснять разницу.
[44:57.180 --> 45:00.180]  Просто запомните, что вот есть еще такая ошибка.
[45:00.180 --> 45:04.180]  Она означает, что вы функцию объявили, но не определили и пытаетесь использовать.
[45:04.180 --> 45:10.180]  Я могу сколько угодно раз объявлять одну и ту же функцию, но определить только один раз могу.
[45:10.180 --> 45:19.180]  Я могу хоть 100 раз подряд написать voidef at endouble и все будет нормально работать.
[45:19.180 --> 45:27.180]  А если один раз написать от endouble, только объявить ее, а другой от initial?
[45:27.180 --> 45:30.180]  Пожалуйста, я объявил две разных функции.
[45:30.180 --> 45:31.180]  От вопроса.
[45:31.180 --> 45:34.180]  Значит, вот я сейчас сделал и, пожалуйста, все работает.
[45:34.180 --> 45:38.180]  Ну, то есть ошибка осталась та же самая, что я вызываю функцию, которая не определена.
[45:38.180 --> 45:41.180]  Я ее сто раз объявил, но ни разу не определил.
[45:41.180 --> 45:42.180]  Это не страшно.
[45:42.180 --> 45:44.180]  Объявлять я могу сколько угодно раз одной и той же.
[45:44.180 --> 45:46.180]  Определить только один раз могу.
[45:46.180 --> 45:47.180]  Да?
[45:47.180 --> 45:48.180]  Вопрос?
[45:48.180 --> 45:50.180]  Обычно после программы функции определяют их.
[45:50.180 --> 45:54.180]  И допустим там, ну, штук десять функций разными аргументами.
[45:54.180 --> 45:55.180]  Да.
[45:55.180 --> 45:56.180]  Но что про это?
[45:56.180 --> 45:59.180]  Нам сначала надо сказать, что они есть в самом начале.
[45:59.180 --> 46:00.180]  И как сделать?
[46:00.180 --> 46:04.180]  Вы же любом на каждый аргумент заново писать и определить.
[46:04.180 --> 46:05.180]  Что вы имеете в виду?
[46:05.180 --> 46:07.180]  В смысле, откуда у вас определения возьмутся?
[46:09.180 --> 46:12.180]  Ну, у вас есть определение где-то внизу или как?
[46:12.180 --> 46:16.180]  Просто в конце он пишет функции, а в начале вы только заголовки получаете.
[46:16.180 --> 46:18.180]  Ну, короче, ну нет.
[46:18.180 --> 46:21.180]  Вы должны все объявления перечислить до использования.
[46:22.180 --> 46:23.180]  Вот.
[46:23.180 --> 46:26.180]  Вы должны объявить функцию до ее использования обязательно.
[46:26.180 --> 46:27.180]  Вот, смотрите.
[46:27.180 --> 46:32.180]  Если я попытаюсь вызвать какую-то функцию до того, как она была объявлена,
[46:32.180 --> 46:33.180]  это ошибка компиляции.
[46:33.180 --> 46:34.180]  Вот.
[46:34.180 --> 46:36.180]  Давайте я это все удалю.
[46:38.180 --> 46:42.180]  Ну, вот представьте, я не знаю, вот у меня еще какая-нибудь функция G сейчас будет.
[46:45.180 --> 46:47.180]  Которая вообще ничего не делает.
[46:47.180 --> 46:51.180]  Вот я сейчас не могу вызвать отсюда функцию G.
[46:51.180 --> 46:55.180]  Вызывать функцию я могу только до, только после их объявления.
[46:56.180 --> 46:58.180]  Смотрите, какая ошибка.
[46:58.180 --> 47:00.180]  G was not declared in this scope.
[47:00.180 --> 47:01.180]  Именно declared.
[47:01.180 --> 47:06.180]  Здесь сказано, G была не объявлена в этом scope.
[47:06.180 --> 47:08.180]  И scope это область видимости.
[47:08.180 --> 47:11.180]  В этом scope не была объявлена функции G.
[47:14.180 --> 47:17.180]  Но вот после того, как она была объявлена, я ее уже могу вызывать.
[47:17.180 --> 47:24.180]  И если бы я ее объявил вот здесь, я бы ее тоже мог вызывать, несмотря на то, что она определена потом.
[47:24.180 --> 47:29.180]  То есть вызвать функцию я могу после того, как она объявлена, а определение когда-нибудь потом написать.
[47:29.180 --> 47:30.180]  Зачем это нужно?
[47:30.180 --> 47:35.180]  Это нужно для того, чтобы вы могли, например, делать перекрестную рекурсию.
[47:35.180 --> 47:40.180]  Вот, смотрите, представьте, что у вас есть две функции, и вам нужно из F вызывать G, а из G вызывать F.
[47:40.180 --> 47:48.180]  Если бы нельзя было объявлять до определения заранее, то это бы никак не получилось сделать.
[47:48.180 --> 47:50.180]  Вот, поймите этот пример.
[47:50.180 --> 47:55.180]  Но он будет, если я определил ее после вызовов, все равно искать до определения.
[47:55.180 --> 47:57.180]  То есть, я бы еще и после, но...
[47:57.180 --> 48:00.180]  Да, вы можете из функции F вызывать G, а из G вызывать F.
[48:00.180 --> 48:07.180]  Для этого вам надо одну из этих функций сначала объявить, но не определить, потом определить вторую, а потом определить первую.
[48:07.180 --> 48:12.180]  Тогда у вас и будет корректно работать, несмотря на то, что определение написано после объявления,
[48:12.180 --> 48:17.180]  но вызывать вы уже можете тогда, когда было объявление, а определение потом найдется.
[48:17.180 --> 48:18.180]  Вот так это работает.
[48:18.180 --> 48:26.180]  Функции в конце определены, ну допустим fint double или fint for, она сначала их объявить получается, да?
[48:26.180 --> 48:31.180]  Да, перед тем, как вы их будете использовать, они должны быть объявлены, а определены могут быть где-нибудь потом.
[48:31.180 --> 48:37.180]  А можно допустим fint 2 объявить, а она будет только, только после того, что она будет сразу идти к ним, получается?
[48:37.180 --> 48:40.180]  Вопрос, что это существует?
[48:40.180 --> 48:44.180]  Тогда у вас будет считаться, что только она существует, а та не найдется.
[48:44.180 --> 48:46.180]  То есть, наверное, каждый будет существовать?
[48:46.180 --> 48:48.180]  Все нужно объявить до использования.
[48:52.180 --> 48:56.180]  Окей, давайте дальше.
[49:02.180 --> 49:06.180]  Так, что-то еще хотел сказать, наверное, и забыл.
[49:06.180 --> 49:16.180]  Да не, ничего больше хотел сказать.
[49:16.180 --> 49:18.180]  А, вот что хотел сказать.
[49:18.180 --> 49:22.180]  Нельзя функции определять внутри других функций.
[49:22.180 --> 49:26.180]  Формально можно объявлять, но это бессмысленно.
[49:26.180 --> 49:31.180]  Ну, короче, считайте, что, в общем, я не могу внутри функции другую функцию определить.
[49:31.180 --> 49:32.180]  Вот так нельзя.
[49:32.180 --> 49:34.180]  C++ и C тоже.
[49:34.180 --> 49:43.180]  Вот в каком-нибудь Паскале, прости господи, можно было там, вы могли функцию объявить внутри другой функции и там же определить.
[49:43.180 --> 49:45.180]  Тогда она была бы локальней для этой функции.
[49:45.180 --> 49:47.180]  В C, в C++ нет.
[49:47.180 --> 49:51.180]  Функции можно объявлять только снаружи функций, не внутри.
[49:51.180 --> 49:57.180]  Соответственно, внутри мейна определить новую функцию, которая мне только для мейна нужна, я не могу.
[49:58.180 --> 50:07.180]  Вот, следующая вещь, это затмение имен.
[50:07.180 --> 50:09.180]  Вот это я, наверное, сопру.
[50:09.180 --> 50:13.180]  Все, чтобы мне не мешало дальше примеры рассматривать.
[50:13.180 --> 50:16.180]  Сейчас еще немного поговорим про переменные.
[50:16.180 --> 50:20.180]  Вот смотрите, у меня есть переменная X, глобальная.
[50:20.180 --> 50:24.180]  Я могу локально объявить снова X.
[50:27.180 --> 50:33.180]  И вот здесь X будет означать тот X, который я объявил последним.
[50:34.180 --> 50:36.180]  Это не ошибка.
[50:36.180 --> 50:42.180]  Я могу в разных областях видимости объявлять переменные с одинаковыми именами, и ничего страшного.
[50:43.180 --> 50:45.180]  Будет один.
[50:49.180 --> 50:55.180]  Более того, я могу внутри локальной области видимости начать новую область видимости.
[50:55.180 --> 50:57.180]  И там снова повторить имя.
[50:57.180 --> 51:00.180]  Я могу просто вот так сделать.
[51:02.180 --> 51:05.180]  И тут объявить еще один X.
[51:06.180 --> 51:08.180]  И теперь этот X будет два.
[51:08.180 --> 51:11.180]  А если я здесь выведу X, это будет один.
[51:17.180 --> 51:19.180]  И это все не ошибки.
[51:20.180 --> 51:25.180]  То есть я могу повторять имена переменных в новых областях видимости.
[51:25.180 --> 51:28.180]  И они будут затмевать предыдущие имена переменных.
[51:28.180 --> 51:33.180]  Но вот если я здесь выведу X, то выведется один.
[51:33.180 --> 51:37.180]  То есть до того, как я объявил вот этот X, у меня действует предыдущий X.
[51:37.180 --> 51:40.180]  Как только я объявил новый X, начинает он действовать.
[51:40.180 --> 51:42.180]  А здесь снова один.
[51:44.180 --> 51:48.180]  Вот тут один, вот тут два, вот тут один.
[51:48.180 --> 51:53.180]  Но это немножко кринж, возможно, но вот как уж есть.
[51:54.180 --> 51:57.180]  В джаве так нельзя делать, а в плюсах можно.
[52:04.180 --> 52:06.180]  Да, это все три разных переменных.
[52:07.180 --> 52:10.180]  Это разные переменные, ну и что они называются одинаково?
[52:10.180 --> 52:14.180]  Называются они одинаково, но в памяти они разные места занимают.
[52:14.180 --> 52:16.180]  И у них даже типы разные могут быть.
[52:16.180 --> 52:19.180]  Я могу запросто здесь сказать, что это вообще double, а не X.
[52:19.180 --> 52:24.180]  А не им. Double равно два с половиной, тогда это будет вполне два с половиной.
[52:24.180 --> 52:26.180]  Все нормально.
[52:34.180 --> 52:38.180]  Бывает так, что я хочу из локальной области видимости обратиться к имени,
[52:38.180 --> 52:41.180]  которая взята из глобального скопа, а не из локального.
[52:42.180 --> 52:48.180]  Тогда я могу написать двоеточие двоеточие перед именем переменной.
[52:49.180 --> 52:50.180]  Вот так.
[52:51.180 --> 52:52.180]  Это будет ноль.
[52:54.180 --> 53:01.180]  То есть, где бы я ни находился, я могу достать из глобальной области видимости X, который был глобальным.
[53:01.180 --> 53:06.180]  Двоеточие двоеточие перед именем переменной означает, что я хочу взять ее из глобального скопа.
[53:06.180 --> 53:11.180]  Ну так можно не только с переменными делать, так можно и с функциями делать, и с классами,
[53:11.180 --> 53:15.180]  но с функциями у нас пока нет такого примера.
[53:15.180 --> 53:17.180]  В общем, так можно делать с переменными.
[53:19.180 --> 53:21.180]  А промежуточную никак нельзя достать.
[53:22.180 --> 53:26.180]  Вот глобальную можно достать и самую последнюю, а промежуточную нет способа достать.
[53:26.180 --> 53:33.180]  Вот, ну и еще одна вещь, про которую я сейчас поговорю, это юзинги и пространство имен.
[53:33.180 --> 53:35.180]  Ну я вкратце про них поговорю.
[53:36.180 --> 53:38.180]  Я могу объявлять пространство имен.
[53:40.180 --> 53:41.180]  Вот зачем это нужно?
[53:41.180 --> 53:45.180]  Дело в том, что когда у меня большая программа, большой там какой-то проект,
[53:45.180 --> 53:48.180]  у меня часто бывает так, что пересекаются имена разные.
[53:49.180 --> 53:52.180]  Ну то есть у меня в проекте может быть много фонариков,
[53:52.180 --> 53:56.180]  которые называются одинаково, они просто разные вещи делают по смыслу.
[53:56.180 --> 54:01.180]  Ну у меня там или классы, которые называются одинаково, они разные,
[54:01.180 --> 54:05.180]  но они называются одинаково просто потому что, ну не знаю,
[54:06.180 --> 54:09.180]  у меня может быть там какой-нибудь point, структура point,
[54:09.180 --> 54:11.180]  которая обозначает точку на плоскости.
[54:12.180 --> 54:16.180]  У меня может быть в проекте, в моей кодовой базе, может быть очень много классов,
[54:16.180 --> 54:17.180]  называющихся point.
[54:17.180 --> 54:21.180]  в моей кодовой базе может быть очень много классов,
[54:21.180 --> 54:24.180]  называющихся point. Или у меня может быть много
[54:24.180 --> 54:27.180]  переменных, которые называются там, много функций,
[54:27.180 --> 54:31.180]  которые называются, я не знаю, distance, расстояние.
[54:31.180 --> 54:34.180]  Не то, что они от разных типов, они могут быть
[54:34.180 --> 54:37.180]  и от одинаковых типов, и все равно делать разные вещи.
[54:37.180 --> 54:40.180]  Просто они как бы из разных частей проекта,
[54:40.180 --> 54:42.180]  и так совпало, что у них одинаковые имена.
[54:42.180 --> 54:45.180]  Они просто для разных мест, для разных кусков кода нужны.
[54:45.180 --> 54:48.180]  Извините, а ты одинаковый? Ведь нельзя две разные?
[54:48.180 --> 54:51.180]  Нельзя, в том-то и дело. Я говорю, мне может хотеться,
[54:51.180 --> 54:55.180]  поскольку у меня очень большой проект, и он существует 5 лет,
[54:55.180 --> 54:58.180]  у меня может быть два разных функций distance,
[54:58.180 --> 55:01.180]  мне может хотеться делать две разных функции с одинаковым названием,
[55:01.180 --> 55:04.180]  с одинаковыми типами, но делающих разные вещи.
[55:04.180 --> 55:07.180]  Просто они из разных мест приходят.
[55:07.180 --> 55:10.180]  Ну, например, у меня может быть, или у меня может быть string,
[55:10.180 --> 55:13.180]  например, строка, у меня может быть std string,
[55:13.180 --> 55:16.180]  а не обе, я хочу, чтобы назывались string,
[55:16.180 --> 55:19.180]  но они были чуть-чуть с разными свойствами, это нормально.
[55:19.180 --> 55:22.180]  Когда проект большой, когда кодовая база большая,
[55:22.180 --> 55:25.180]  в ней много может быть разных имен совпадающих.
[55:25.180 --> 55:28.180]  И как раз для того, чтобы разделять эти имена,
[55:28.180 --> 55:32.180]  чтобы они не образовывали коллизии, чтобы не было вот этих вот
[55:32.180 --> 55:35.180]  конфликтов имен, что нельзя повторять имена,
[55:35.180 --> 55:38.180]  у меня существует пространство имен.
[55:38.180 --> 55:42.180]  Я могу объявить namespace, ну, допустим, n,
[55:42.180 --> 55:46.180]  допустим, n большое, и в нем объявлять какие-то имена.
[55:46.180 --> 55:49.180]  И вот имена, которые внутри этого namespace не будут
[55:49.180 --> 55:52.180]  конфликтовать с именами, которые в другом namespace.
[55:52.180 --> 55:55.180]  То есть я могу здесь объявить какую-нибудь функцию,
[55:55.180 --> 55:59.180]  не знаю, но вот я могу здесь объявить voidf от int,
[55:59.180 --> 56:05.180]  которая говорит std cout, ну, вот этот int, допустим,
[56:05.180 --> 56:08.180]  она выводит на экран.
[56:08.180 --> 56:13.180]  Вот, и у меня может быть другой namespace,
[56:13.180 --> 56:19.180]  и в нем будет другая f, тоже от int,
[56:19.180 --> 56:24.180]  которая выводит на экран не от int, а его на 1 увеличено.
[56:24.180 --> 56:28.180]  Вот это не ошибка, потому что я эти функции как раз
[56:28.180 --> 56:31.180]  якобы разнес их по пространству имен.
[56:31.180 --> 56:35.180]  Пространство имен — это вот такой набор имен,
[56:35.180 --> 56:39.180]  которые живут отдельно вот от других.
[56:39.180 --> 56:42.180]  Вот эта f, вот с этой f не конфликтует.
[56:42.180 --> 56:45.180]  Это не является ошибкой повторного определения,
[56:45.180 --> 56:48.180]  потому что это функции из разных scope'ов.
[56:48.180 --> 56:52.180]  Вот scope, который здесь, называется namespace scope.
[56:56.180 --> 57:00.180]  Вот это вот global scope, то, что вообще вне всех
[57:00.180 --> 57:03.180]  фигурных скобок, вот это namespace scope, а вот это
[57:03.180 --> 57:06.180]  уже local scope, то, что внутри функции.
[57:06.180 --> 57:09.180]  И это тоже local scope.
[57:09.180 --> 57:11.180]  Понятно про пространство имен?
[57:11.180 --> 57:14.180]  Ну, идея, зачем надо, чтобы имена не конфликтовали,
[57:14.180 --> 57:16.180]  не пересекались. Таким образом, у меня может быть
[57:16.180 --> 57:18.180]  очень много сущностей, называющихся одинаково,
[57:18.180 --> 57:21.180]  но они как бы из разных подмножеств взяты,
[57:21.180 --> 57:25.180]  из разных множеств имен, и поэтому они не конфликтуют.
[57:25.180 --> 57:29.180]  А можно ли использовать функцию f, которая задана
[57:29.180 --> 57:32.180]  в namespace n, например, за пределами…
[57:32.180 --> 57:35.180]  Да, конечно, разумеется.
[57:35.180 --> 57:41.180]  Иначе, как бы вы к стандартной библиотеке обращались.
[57:41.180 --> 57:45.180]  Ну, вы всегда это и делаете, разумеется.
[57:45.180 --> 57:49.180]  Что такое std? Это и есть пространство имен.
[57:49.180 --> 57:54.180]  Давайте я вам еще раз покажу iostream, как выглядит.
[57:54.180 --> 58:01.180]  Файл iostream, он в себе содержит объявление namespace std.
[58:01.180 --> 58:04.180]  Вот это вот macros, который для компилятора говорит,
[58:04.180 --> 58:06.180]  что у этого стандартная видимость,
[58:06.180 --> 58:08.180]  то есть, что имена отсюда должны быть видны.
[58:08.180 --> 58:10.180]  Ну, в общем, забейте на этот macros,
[58:10.180 --> 58:12.180]  это просто некоторая подсказка компилятора.
[58:12.180 --> 58:15.180]  Вот namespace std, фигурная скобка открылась,
[58:15.180 --> 58:18.180]  и вот все эти штуки здесь объявлены.
[58:18.180 --> 58:22.180]  То есть, на самом деле, когда вы используете cout,
[58:22.180 --> 58:24.180]  или когда вы используете string,
[58:24.180 --> 58:26.180]  или когда вы используете любую штуку,
[58:26.180 --> 58:28.180]  вы берете ее из namespace std.
[58:28.180 --> 58:31.180]  И вы говорите всем самым, что пишет std.
[58:31.180 --> 58:34.180]  Как раз для того, чтобы вот эти имена не пересекали.
[58:34.180 --> 58:37.180]  Если я захочу в своей программе создать какую-то переменную
[58:37.180 --> 58:39.180]  и назвать ее cout, это не будет ошибкой,
[58:39.180 --> 58:41.180]  потому что переменная с названием cout,
[58:41.180 --> 58:44.180]  объявленная в namespace std, она не будет конфликтовать с моей.
[58:48.180 --> 58:51.180]  Откуда вы берете список на namespace?
[58:51.180 --> 58:53.180]  Что значит список на namespace?
[58:53.180 --> 58:55.180]  Ну, вот std он знает.
[58:55.180 --> 58:57.180]  Нет, он не знает.
[58:57.180 --> 58:59.180]  Что значит знает?
[58:59.180 --> 59:02.180]  У меня вверху написано include eostream.
[59:02.180 --> 59:04.180]  Include означает буквально следующее.
[59:04.180 --> 59:06.180]  Возьми файл eostream.
[59:06.180 --> 59:10.180]  Eostream это прям файл, который на моем компле находится вот по такому адресу.
[59:10.180 --> 59:12.180]  В такой папке он лежит.
[59:12.180 --> 59:16.180]  В этом файле написано namespace std, фигурная скобка открылась,
[59:16.180 --> 59:18.180]  и что-то объявлено.
[59:18.180 --> 59:20.180]  Когда я пишу include eostream,
[59:20.180 --> 59:24.180]  он берет файл eostream и копипастит его содержимое мне в программу.
[59:24.180 --> 59:28.180]  После расшифровки этого include у меня в программе прямо написано
[59:28.180 --> 59:30.180]  namespace std, фигурная скобка открылась,
[59:30.180 --> 59:32.180]  и объявлено какие-то вещи.
[59:32.180 --> 59:34.180]  Никто заранее ничего не знает.
[59:34.180 --> 59:36.180]  И namespace std тоже заранее не знает.
[59:36.180 --> 59:38.180]  Просто за счет того, что я написал include eostream,
[59:38.180 --> 59:40.180]  у меня как бы добавилось объявление namespace std,
[59:40.180 --> 59:42.180]  и в нем что-то наобявлено.
[59:42.180 --> 59:46.180]  Поэтому он знает, что cout был объявлен на namespace std.
[59:46.180 --> 59:48.180]  Точно также я могу написать namespace n,
[59:48.180 --> 59:51.180]  и в нем что-то объявить, а потом это использовать.
[59:51.180 --> 59:53.180]  Но заранее никаких namespace он не знает.
[59:53.180 --> 59:55.180]  Понятно?
[59:55.180 --> 59:57.180]  Вот.
[59:57.180 --> 59:59.180]  Хорошо.
[59:59.180 --> 01:00:01.180]  Да.
[01:00:01.180 --> 01:00:04.180]  Можно ли просто объявить функцию в namespace,
[01:00:04.180 --> 01:00:06.180]  а потом определить ее в name?
[01:00:06.180 --> 01:00:09.180]  Да, но тебе для этого придется уточнить,
[01:00:09.180 --> 01:00:11.180]  что ты определяешь функцию из того самого namespace.
[01:00:11.180 --> 01:00:13.180]  Смотрите.
[01:00:13.180 --> 01:00:15.180]  Да, смотрите.
[01:00:15.180 --> 01:00:17.180]  Я могу.
[01:00:17.180 --> 01:00:19.180]  Вот если я хочу использовать функцию из другого namespace,
[01:00:19.180 --> 01:00:21.180]  мне надо явно указать из какого.
[01:00:21.180 --> 01:00:23.180]  То есть если я в этом namespace, допустим,
[01:00:23.180 --> 01:00:25.180]  буду говорить g,
[01:00:25.180 --> 01:00:27.180]  и тут буду говорить,
[01:00:27.180 --> 01:00:29.180]  вызови ко мне f,
[01:00:29.180 --> 01:00:31.180]  то будет понятно иметь в виду вот это f.
[01:00:35.180 --> 01:00:37.180]  Но если я хочу взять функцию f
[01:00:37.180 --> 01:00:39.180]  из другого namespace,
[01:00:39.180 --> 01:00:41.180]  мне нужно явно сказать из какого.
[01:00:41.180 --> 01:00:43.180]  Как это сделать?
[01:00:43.180 --> 01:00:45.180]  Ну вот так.
[01:00:45.180 --> 01:00:47.180]  Название namespace и название функции.
[01:00:47.180 --> 01:00:49.180]  Ну или переменной.
[01:00:49.180 --> 01:00:51.180]  Так я разве объявил?
[01:00:51.180 --> 01:00:53.180]  Я вызываю его сейчас.
[01:00:53.180 --> 01:00:55.180]  Я использую ее.
[01:00:55.180 --> 01:00:57.180]  Какое же это объявление?
[01:00:57.180 --> 01:00:59.180]  Да.
[01:00:59.180 --> 01:01:01.180]  А.
[01:01:01.180 --> 01:01:03.180]  Так это я внутри namespace,
[01:01:03.180 --> 01:01:05.180]  а не внутри функции.
[01:01:05.180 --> 01:01:07.180]  У меня функция f,
[01:01:07.180 --> 01:01:09.180]  которая делает вот это.
[01:01:09.180 --> 01:01:11.180]  Я продолжаю оставаться в namespace,
[01:01:11.180 --> 01:01:13.180]  но уже не внутри функции f.
[01:01:13.180 --> 01:01:15.180]  Я сейчас нахожусь в namespace,
[01:01:15.180 --> 01:01:17.180]  но не внутри никакой функции.
[01:01:17.180 --> 01:01:19.180]  Вот.
[01:01:19.180 --> 01:01:21.180]  А здесь я использую функцию f.
[01:01:21.180 --> 01:01:23.180]  Если я просто напишу f,
[01:01:23.180 --> 01:01:25.180]  то это будет браться, конечно,
[01:01:25.180 --> 01:01:27.180]  из того namespace, в котором я сейчас.
[01:01:27.180 --> 01:01:29.180]  Но я могу сказать, возьми из другого.
[01:01:29.180 --> 01:01:31.180]  Для этого мне нужно явно сказать из какого.
[01:01:31.180 --> 01:01:33.180]  Это делается вот так.
[01:01:33.180 --> 01:01:35.180]  Где?
[01:01:37.180 --> 01:01:39.180]  Могу ли я в namespace n
[01:01:39.180 --> 01:01:41.180]  определить функцию
[01:01:41.180 --> 01:01:43.180]  из другого namespace,
[01:01:43.180 --> 01:01:45.180]  не выходя из этого?
[01:01:45.180 --> 01:01:47.180]  Ну это довольно криво так делать.
[01:01:47.180 --> 01:01:49.180]  Честно говоря,
[01:01:49.180 --> 01:01:51.180]  я не уверен точно,
[01:01:51.180 --> 01:01:53.180]  но не знаю, давайте я даже не буду думать.
[01:01:53.180 --> 01:01:55.180]  Не хочу так делать.
[01:01:59.180 --> 01:02:01.180]  Кто не нулевой?
[01:02:05.180 --> 01:02:07.180]  f это аргумент функции, его принять надо.
[01:02:09.180 --> 01:02:11.180]  А!
[01:02:11.180 --> 01:02:13.180]  Это ошибка компиляции, конечно.
[01:02:13.180 --> 01:02:15.180]  Это я ошибся.
[01:02:15.180 --> 01:02:17.180]  Я не могу вызывать f без аргументов,
[01:02:17.180 --> 01:02:19.180]  если я понимаю, что это аргумент, разумеется.
[01:02:19.180 --> 01:02:21.180]  Мне нужно от аргумента вызываться, это просто ошибка.
[01:02:21.180 --> 01:02:23.180]  Да.
[01:02:25.180 --> 01:02:27.180]  Отличный вопрос.
[01:02:27.180 --> 01:02:29.180]  Сейчас про это поговорим.
[01:02:33.180 --> 01:02:35.180]  Ну,
[01:02:35.180 --> 01:02:37.180]  он берет из того, в котором мы сейчас находимся,
[01:02:37.180 --> 01:02:39.180]  а если мы хотим из другого, то значит он берет из другого.
[01:02:39.180 --> 01:02:41.180]  На самом деле, комбинации
[01:02:41.180 --> 01:02:43.180]  namespace правила очень сложные,
[01:02:43.180 --> 01:02:45.180]  и мы их,
[01:02:45.180 --> 01:02:47.180]  они настолько сложные,
[01:02:47.180 --> 01:02:49.180]  что можно
[01:02:49.180 --> 01:02:51.180]  три лекции читать только об этом,
[01:02:51.180 --> 01:02:53.180]  надо просто вовремя остановиться.
[01:02:53.180 --> 01:02:55.180]  Мне нужно вовремя остановиться, иначе мы так до конца лекции
[01:02:55.180 --> 01:02:57.180]  про это будем разговаривать.
[01:02:59.180 --> 01:03:01.180]  Смотрите,
[01:03:03.180 --> 01:03:05.180]  я могу,
[01:03:05.180 --> 01:03:07.180]  да, вы спрашивали сейчас,
[01:03:07.180 --> 01:03:09.180]  вот вы спрашивали, богу ли я
[01:03:09.180 --> 01:03:11.180]  функцию
[01:03:11.180 --> 01:03:13.180]  объявить внутри namespace,
[01:03:13.180 --> 01:03:15.180]  а
[01:03:15.180 --> 01:03:17.180]  определить внутри него. Да, могу.
[01:03:17.180 --> 01:03:19.180]  Для этого я должен
[01:03:21.180 --> 01:03:23.180]  значит
[01:03:25.180 --> 01:03:27.180]  Господи, ты боже мой.
[01:03:31.180 --> 01:03:33.180]  Так, ладно, я не умею удалять до конца строки,
[01:03:33.180 --> 01:03:35.180]  к сожалению.
[01:03:35.180 --> 01:03:37.180]  Ну, для этого я должен написать так, void,
[01:03:37.180 --> 01:03:39.180]  а дальше уточнить,
[01:03:39.180 --> 01:03:41.180]  из какого namespace, и вот тут я могу ее определить уже.
[01:03:43.180 --> 01:03:45.180]  Обратите внимание,
[01:03:45.180 --> 01:03:47.180]  что я,
[01:03:47.180 --> 01:03:49.180]  что имя full, что вот это вот,
[01:03:49.180 --> 01:03:51.180]  вот это n2.2. это часть имени.
[01:03:51.180 --> 01:03:53.180]  То есть, как бы вот, я говорю,
[01:03:53.180 --> 01:03:55.180]  что я определяю f из n.
[01:03:55.180 --> 01:03:57.180]  Я не пишу n2.2,
[01:03:57.180 --> 01:03:59.180]  а потом тип.
[01:03:59.180 --> 01:04:01.180]  Тип всегда идет первым, а дальше я имя называю.
[01:04:01.180 --> 01:04:03.180]  Вот это вот часть имени.
[01:04:07.180 --> 01:04:09.180]  Хорошо.
[01:04:09.180 --> 01:04:11.180]  Последнее,
[01:04:11.180 --> 01:04:13.180]  что я скажу, это юзинги.
[01:04:13.180 --> 01:04:15.180]  Вот, мы можем объявлять,
[01:04:15.180 --> 01:04:17.180]  определять namespace,
[01:04:19.180 --> 01:04:21.180]  и еще есть юзинги.
[01:04:23.180 --> 01:04:25.180]  Да.
[01:04:31.180 --> 01:04:33.180]  Да, я вот сейчас определяю эту функцию.
[01:04:33.180 --> 01:04:35.180]  Объявил я ее вот здесь, а потом решил
[01:04:35.180 --> 01:04:37.180]  определить вот здесь.
[01:04:39.180 --> 01:04:41.180]  Она считается, что все еще
[01:04:41.180 --> 01:04:43.180]  принадлежит namespace,
[01:04:43.180 --> 01:04:45.180]  для нее все те же правила.
[01:04:51.180 --> 01:04:53.180]  Будет вызываться.
[01:04:53.180 --> 01:04:55.180]  Конечно.
[01:04:55.180 --> 01:04:57.180]  Определение может быть после объявления.
[01:04:57.180 --> 01:04:59.180]  Главное, что она объявлена в namespace.
[01:04:59.180 --> 01:05:01.180]  Я уже сказал, не важно, где она определена.
[01:05:01.180 --> 01:05:03.180]  Объявлена в namespace, значит все,
[01:05:03.180 --> 01:05:05.180]  что будет находиться.
[01:05:05.180 --> 01:05:07.180]  Хорошо.
[01:05:07.180 --> 01:05:09.180]  Последнее, что я скажу, это юзинги.
[01:05:11.180 --> 01:05:13.180]  Я могу
[01:05:13.180 --> 01:05:15.180]  делать объявление
[01:05:17.180 --> 01:05:19.180]  юзинг.
[01:05:19.180 --> 01:05:21.180]  Есть три вида юзингов.
[01:05:21.180 --> 01:05:23.180]  Я могу сказать
[01:05:23.180 --> 01:05:25.180]  юзинг какое-то имя,
[01:05:25.180 --> 01:05:27.180]  я могу сказать юзинг какой-то тип,
[01:05:27.180 --> 01:05:29.180]  и могу сказать юзинг namespace.
[01:05:29.180 --> 01:05:31.180]  Давайте сначала поговорю про юзинг имя.
[01:05:31.180 --> 01:05:33.180]  Я, например, могу сказать
[01:05:33.180 --> 01:05:35.180]  юзинг n 2.2.f.
[01:05:39.180 --> 01:05:41.180]  Что это означает?
[01:05:41.180 --> 01:05:43.180]  Это означает, что теперь я
[01:05:45.180 --> 01:05:47.180]  в глобальную область видимости
[01:05:47.180 --> 01:05:49.180]  добавил f из namespace an.
[01:05:49.180 --> 01:05:51.180]  Теперь, если я
[01:05:51.180 --> 01:05:53.180]  вызываю глобально f
[01:05:53.180 --> 01:05:55.180]  без уточнения, откуда она,
[01:05:55.180 --> 01:05:57.180]  или даже локально,
[01:05:57.180 --> 01:05:59.180]  после того, как я это написал,
[01:05:59.180 --> 01:06:01.180]  все, что ниже идет, поскольку глобально
[01:06:01.180 --> 01:06:03.180]  я это написал,
[01:06:03.180 --> 01:06:05.180]  на все, что ниже идет, распространяется вот это слово
[01:06:05.180 --> 01:06:07.180]  юзинг n f.
[01:06:07.180 --> 01:06:09.180]  Это значит, что теперь, если я вызываю f,
[01:06:09.180 --> 01:06:11.180]  то все будет работать.
[01:06:11.180 --> 01:06:13.180]  Вот это давайте я опять сотру.
[01:06:13.180 --> 01:06:15.180]  Это мне уже не нужно.
[01:06:19.180 --> 01:06:21.180]  Вот, сейчас.
[01:06:21.180 --> 01:06:23.180]  Вот, смотрите, ноль.
[01:06:23.180 --> 01:06:25.180]  Я вызвал f от нуля,
[01:06:25.180 --> 01:06:27.180]  хотя вообще-то f
[01:06:27.180 --> 01:06:29.180]  была из namespace.
[01:06:29.180 --> 01:06:31.180]  Если бы я не написал
[01:06:31.180 --> 01:06:33.180]  юзинг n 2.2.f,
[01:06:33.180 --> 01:06:35.180]  это была бы ошибкой,
[01:06:35.180 --> 01:06:37.180]  потому что нет глобальной такой f.
[01:06:37.180 --> 01:06:39.180]  f was not declared in this scope.
[01:06:39.180 --> 01:06:41.180]  Она была объявлена
[01:06:41.180 --> 01:06:43.180]  в scope внутри namespace,
[01:06:43.180 --> 01:06:45.180]  но не глобально, поэтому я не могу
[01:06:45.180 --> 01:06:47.180]  вызывать ее без уточнения, откуда я ее взял.
[01:06:47.180 --> 01:06:49.180]  А если бы мы написали юзинг выше,
[01:06:49.180 --> 01:06:51.180]  чем определение f?
[01:06:51.180 --> 01:06:53.180]  Но если я написал бы вот так,
[01:06:53.180 --> 01:06:55.180]  то это работает.
[01:06:55.180 --> 01:06:57.180]  Юзинг выше, чем f,
[01:06:57.180 --> 01:06:59.180]  не знаю, думаю, что не сработает.
[01:06:59.180 --> 01:07:01.180]  Не хочу проверять, некогда.
[01:07:01.180 --> 01:07:03.180]  Не знаю, если честно.
[01:07:03.180 --> 01:07:05.180]  Ну, это какая-то тонкость.
[01:07:09.180 --> 01:07:11.180]  Юзинг n f, это значит, что в дальнейшем,
[01:07:11.180 --> 01:07:13.180]  если я пишу f без уточнения,
[01:07:13.180 --> 01:07:15.180]  какую я имею в виду,
[01:07:15.180 --> 01:07:17.180]  то берется из n.
[01:07:17.180 --> 01:07:19.180]  Вот, дальше начинается
[01:07:21.180 --> 01:07:23.180]  в общем, стандартная
[01:07:23.180 --> 01:07:25.180]  история, а что если?
[01:07:25.180 --> 01:07:27.180]  А что если бы у меня
[01:07:27.180 --> 01:07:29.180]  при этом еще была f глобальная,
[01:07:29.180 --> 01:07:31.180]  то что бы было?
[01:07:31.180 --> 01:07:33.180]  Ну, тогда бы они...
[01:07:33.180 --> 01:07:35.180]  Вот если бы у меня еще была, допустим,
[01:07:35.180 --> 01:07:37.180]  здесь f, например, от double,
[01:07:37.180 --> 01:07:39.180]  то тогда
[01:07:39.180 --> 01:07:41.180]  у меня как бы теперь глобально есть
[01:07:41.180 --> 01:07:43.180]  if от double, f от int.
[01:07:43.180 --> 01:07:45.180]  И если я вызываю ее без уточнения,
[01:07:45.180 --> 01:07:47.180]  откуда, то они конкурируют,
[01:07:47.180 --> 01:07:49.180]  как будто между ними есть
[01:07:49.180 --> 01:07:51.180]  перегрузка.
[01:07:51.180 --> 01:07:53.180]  Вот.
[01:07:53.180 --> 01:07:55.180]  Что если я теперь
[01:07:55.180 --> 01:07:57.180]  еще напишу using n n
[01:07:57.180 --> 01:07:59.180]  f?
[01:07:59.180 --> 01:08:01.180]  А теперь у меня
[01:08:01.180 --> 01:08:03.180]  как бы я привнес
[01:08:03.180 --> 01:08:05.180]  в глобальную область if от туда,
[01:08:05.180 --> 01:08:07.180]  f отсюда. И теперь, если я буду
[01:08:07.180 --> 01:08:09.180]  пытаться так делать, это будет ошибка.
[01:08:09.180 --> 01:08:11.180]  Потому что теперь я как бы
[01:08:11.180 --> 01:08:13.180]  добавил f и оттуда и отсюда,
[01:08:13.180 --> 01:08:15.180]  это разные f,
[01:08:15.180 --> 01:08:17.180]  но они,
[01:08:17.180 --> 01:08:19.180]  когда я обращаюсь к f,
[01:08:19.180 --> 01:08:21.180]  я не понимаю, какой. Они равноценны,
[01:08:21.180 --> 01:08:23.180]  и теперь вызов
[01:08:23.180 --> 01:08:25.180]  неоднозначен. Я сделал дважды using,
[01:08:25.180 --> 01:08:27.180]  и теперь у меня вызов неоднозначен,
[01:08:27.180 --> 01:08:29.180]  когда я это делаю.
[01:08:29.180 --> 01:08:31.180]  Вот.
[01:08:31.180 --> 01:08:33.180]  Забавно, кстати, что так можно сделать
[01:08:33.180 --> 01:08:35.180]  и с переменными. Представьте, что у меня
[01:08:35.180 --> 01:08:37.180]  есть
[01:08:37.180 --> 01:08:39.180]  глобальная
[01:08:39.180 --> 01:08:41.180]  x,
[01:08:41.180 --> 01:08:43.180]  а еще есть вот здесь
[01:08:43.180 --> 01:08:45.180]  x.
[01:08:45.180 --> 01:08:47.180]  И я написал using
[01:08:47.180 --> 01:08:49.180]  using n.
[01:08:49.180 --> 01:08:51.180]  Так, наверное, кстати, нельзя делать.
[01:08:53.180 --> 01:08:55.180]  nn 2.2x
[01:08:55.180 --> 01:08:57.180]  Так нельзя, наверное, делать, потому что
[01:08:57.180 --> 01:08:59.180]  он скажет, что это повторное
[01:08:59.180 --> 01:09:01.180]  объявление. Да, с переменными
[01:09:01.180 --> 01:09:03.180]  так нельзя делать,
[01:09:03.180 --> 01:09:05.180]  а только с функциями можно.
[01:09:05.180 --> 01:09:07.180]  Redeclaration.
[01:09:07.180 --> 01:09:09.180]  Если я пытаюсь using переменную
[01:09:09.180 --> 01:09:11.180]  сделать, которая уже есть
[01:09:11.180 --> 01:09:13.180]  в этой области видимости с таким же названием,
[01:09:13.180 --> 01:09:15.180]  это ошибка. Вот с функциями так можно,
[01:09:15.180 --> 01:09:17.180]  потому что у меня в функции перегрузка есть,
[01:09:17.180 --> 01:09:19.180]  а с переменными нельзя.
[01:09:19.180 --> 01:09:21.180]  Но
[01:09:21.180 --> 01:09:23.180]  я могу сделать using namespace.
[01:09:23.180 --> 01:09:25.180]  Это второе, что я могу писать using.
[01:09:25.180 --> 01:09:27.180]  Я могу сделать using
[01:09:27.180 --> 01:09:29.180]  namespace, и это означает, что
[01:09:29.180 --> 01:09:31.180]  все, что есть в namespace
[01:09:31.180 --> 01:09:33.180]  таком-то, теперь я делаю видимым
[01:09:33.180 --> 01:09:35.180]  на этом уровне, глобально.
[01:09:35.180 --> 01:09:37.180]  То есть теперь и функция
[01:09:37.180 --> 01:09:39.180]  f, и функция g,
[01:09:39.180 --> 01:09:41.180]  и переменная x глобально
[01:09:41.180 --> 01:09:43.180]  берутся из namespace.
[01:09:43.180 --> 01:09:45.180]  Когда я говорю using namespace,
[01:09:45.180 --> 01:09:47.180]  это значит, что все, что есть в этом namespace
[01:09:47.180 --> 01:09:49.180]  я добавляю в свою область видимости.
[01:09:49.180 --> 01:09:51.180]  И теперь,
[01:09:51.180 --> 01:09:53.180]  если я вот здесь обращусь к x,
[01:09:53.180 --> 01:09:55.180]  это будет ошибка
[01:09:55.180 --> 01:09:57.180]  неоднозначное обращение к переменной,
[01:09:57.180 --> 01:09:59.180]  потому что у меня есть
[01:09:59.180 --> 01:10:01.180]  глобальный x, а еще я привнес
[01:10:01.180 --> 01:10:03.180]  в глобальную область видимости x из namespace
[01:10:03.180 --> 01:10:05.180]  n. И
[01:10:05.180 --> 01:10:07.180]  когда я теперь обращаюсь к x, непонятно
[01:10:07.180 --> 01:10:09.180]  к какому, их два в глобальной области
[01:10:09.180 --> 01:10:11.180]  видимости теперь, один реально глобальный,
[01:10:11.180 --> 01:10:13.180]  а другой добавлен туда из namespace.
[01:10:13.180 --> 01:10:15.180]  И вот у меня ошибка,
[01:10:15.180 --> 01:10:17.180]  когда...
[01:10:31.180 --> 01:10:33.180]  А, Господи,
[01:10:33.180 --> 01:10:35.180]  у меня x уже в глобальной области, вот здесь
[01:10:35.180 --> 01:10:37.180]  объявлен. Да, вот у меня есть
[01:10:37.180 --> 01:10:39.180]  x глобальный и есть
[01:10:39.180 --> 01:10:41.180]  using namespace, да, и
[01:10:41.180 --> 01:10:43.180]  reference to x из ambiguous,
[01:10:43.180 --> 01:10:45.180]  неоднозначное обращение к переменной.
[01:10:47.180 --> 01:10:49.180]  Вот.
[01:10:51.180 --> 01:10:53.180]  Namespace можно объявить, да,
[01:10:53.180 --> 01:10:55.180]  внутри другого namespace.
[01:10:55.180 --> 01:10:57.180]  Внутри функции нельзя,
[01:10:57.180 --> 01:10:59.180]  и внутри класса тоже нельзя.
[01:10:59.180 --> 01:11:01.180]  Namespace, внутри других namespace
[01:11:01.180 --> 01:11:03.180]  можно, и тогда, чтобы
[01:11:03.180 --> 01:11:05.180]  обращаться к местам из этого namespace,
[01:11:05.180 --> 01:11:07.180]  будет писать n...
[01:11:07.180 --> 01:11:09.180]  еще n, n2,
[01:11:09.180 --> 01:11:11.180]  2.2, и так далее.
[01:11:11.180 --> 01:11:13.180]  Можно ли использовать using
[01:11:13.180 --> 01:11:15.180]  внутри чего-либо? Да, using
[01:11:15.180 --> 01:11:17.180]  можно использовать локально, разумеется,
[01:11:17.180 --> 01:11:19.180]  и это даже рекомендуется.
[01:11:19.180 --> 01:11:21.180]  Вот глобально писать using плохо,
[01:11:21.180 --> 01:11:23.180]  потому что когда вы глобально пишете using,
[01:11:23.180 --> 01:11:25.180]  вы как бы сразу глобально делаете
[01:11:25.180 --> 01:11:27.180]  видимым это все, много чего.
[01:11:27.180 --> 01:11:29.180]  Хорошо писать using локально,
[01:11:29.180 --> 01:11:31.180]  тогда вы сделаете, как бы, привнесете
[01:11:31.180 --> 01:11:33.180]  только в локальную область видимости это имя.
[01:11:33.180 --> 01:11:35.180]  Например, можно писать using
[01:11:35.180 --> 01:11:37.180]  std seout,
[01:11:37.180 --> 01:11:39.180]  и теперь мне не надо перед
[01:11:39.180 --> 01:11:41.180]  seout писать std,
[01:11:41.180 --> 01:11:43.180]  потому что теперь я беру seout
[01:11:43.180 --> 01:11:45.180]  из namespace std.
[01:11:45.180 --> 01:11:47.180]  Вот если бы я просто писал seout x,
[01:11:47.180 --> 01:11:49.180]  он бы сказал, я не знаю, что такое seout,
[01:11:49.180 --> 01:11:51.180]  не было его в этом скопе.
[01:11:51.180 --> 01:11:53.180]  Но я сказал using std seout,
[01:11:53.180 --> 01:11:55.180]  и это означает, компиляр теперь понимает, что
[01:11:55.180 --> 01:11:57.180]  seout я собираюсь брать из std.
[01:11:59.180 --> 01:12:01.180]  Я могу также написать using
[01:12:01.180 --> 01:12:03.180]  namespace std,
[01:12:03.180 --> 01:12:05.180]  кто в своей жизни хоть раз так писал?
[01:12:07.180 --> 01:12:09.180]  Теперь вы понимаете, что это значит.
[01:12:09.180 --> 01:12:11.180]  Using namespace std
[01:12:11.180 --> 01:12:13.180]  означает, что все сущности из namespace
[01:12:13.180 --> 01:12:15.180]  std вы привносите в ту область видимости,
[01:12:15.180 --> 01:12:17.180]  в которой это написали. Так не рекомендуется делать
[01:12:17.180 --> 01:12:19.180]  и мы будем вам запрещать это писать
[01:12:19.180 --> 01:12:21.180]  в своих программах, потому что
[01:12:21.180 --> 01:12:23.180]  это на самом деле опасно, когда вы привносите
[01:12:23.180 --> 01:12:25.180]  в свою область видимости все, что есть
[01:12:25.180 --> 01:12:27.180]  на namespace std, вы
[01:12:27.180 --> 01:12:29.180]  рискуете тем, что у вас случатся конфликты
[01:12:29.180 --> 01:12:31.180]  имен с тем, что было кроме
[01:12:31.180 --> 01:12:33.180]  этого объявлено.
[01:12:33.180 --> 01:12:35.180]  Namespace std очень большое, и в нем есть очень много
[01:12:35.180 --> 01:12:37.180]  имен, о которых вы не подозреваете.
[01:12:37.180 --> 01:12:39.180]  Случайно это может в какой-то момент привести вас
[01:12:39.180 --> 01:12:41.180]  к тому, что вот у вас была функция
[01:12:41.180 --> 01:12:43.180]  с каким-то названием, ну например, та же
[01:12:43.180 --> 01:12:45.180]  самая присловутая distance, а в
[01:12:45.180 --> 01:12:47.180]  namespace std есть еще куча функций distance
[01:12:47.180 --> 01:12:49.180]  от разных типов. И вот представьте, вы объявили
[01:12:49.180 --> 01:12:51.180]  свою функцию distance, и еще у вас написано
[01:12:51.180 --> 01:12:53.180]  using namespace std. В итоге
[01:12:53.180 --> 01:12:55.180]  у вас есть функция distance,
[01:12:55.180 --> 01:12:57.180]  и вы ее вызываете, но вызывается
[01:12:57.180 --> 01:12:59.180]  не она, а вызывается та, которую из
[01:12:59.180 --> 01:13:01.180]  namespace std привнесли, потому что она предпочтительнее
[01:13:01.180 --> 01:13:03.180]  по типам, и вы никак
[01:13:03.180 --> 01:13:05.180]  это не одебажите, вы никак не поймете,
[01:13:05.180 --> 01:13:07.180]  что происходит, потому что вы думаете, почему
[01:13:07.180 --> 01:13:09.180]  ваш код делает не то, что вы написали,
[01:13:09.180 --> 01:13:11.180]  а потому что вы привнесли другую функцию, и даже
[01:13:11.180 --> 01:13:13.180]  не подозреваете об этом, и вызывается вообще не она,
[01:13:13.180 --> 01:13:15.180]  а какая-то другая, написанная не вами.
[01:13:15.180 --> 01:13:17.180]  Поэтому писать using namespace std не
[01:13:17.180 --> 01:13:19.180]  рекомендуется особенно глобально.
[01:13:19.180 --> 01:13:21.180]  Локально еще ладно, если
[01:13:21.180 --> 01:13:23.180]  у вас маленькая функция, и вам хочется там
[01:13:23.180 --> 01:13:25.180]  в ней маленькой, чуть-чуть
[01:13:25.180 --> 01:13:27.180]  этим пользоваться, но не глобально, пожалуйста.
[01:13:27.180 --> 01:13:29.180]  Вот.
[01:13:29.180 --> 01:13:31.180]  Про namespace
[01:13:31.180 --> 01:13:33.180]  есть еще такой прикол, что
[01:13:35.180 --> 01:13:37.180]  можно
[01:13:37.180 --> 01:13:39.180]  доопределять namespace, то есть
[01:13:39.180 --> 01:13:41.180]  если я сейчас напишу снова namespace n
[01:13:41.180 --> 01:13:43.180]  и в нем что-то допишу,
[01:13:43.180 --> 01:13:45.180]  то это я, значит, не переопределил
[01:13:45.180 --> 01:13:47.180]  namespace, а доопределил.
[01:13:47.180 --> 01:13:49.180]  Вот для namespace
[01:13:49.180 --> 01:13:51.180]  не распространяется правило, что только один раз
[01:13:51.180 --> 01:13:53.180]  можно определить. Я
[01:13:53.180 --> 01:13:55.180]  сделал namespace n, что-то в нем написал,
[01:13:55.180 --> 01:13:57.180]  закрыл, потом
[01:13:57.180 --> 01:13:59.180]  снова написал namespace n, что-то еще написал,
[01:13:59.180 --> 01:14:01.180]  закрыл. Теперь в namespace n есть E,
[01:14:01.180 --> 01:14:03.180]  F и G. Это нормально, так можно,
[01:14:03.180 --> 01:14:05.180]  и так нужно.
[01:14:05.180 --> 01:14:07.180]  Даже.
[01:14:07.180 --> 01:14:09.180]  Да, ну и
[01:14:09.180 --> 01:14:11.180]  самое последнее, это using
[01:14:11.180 --> 01:14:13.180]  для типов. Я могу
[01:14:13.180 --> 01:14:15.180]  сделать using на
[01:14:15.180 --> 01:14:17.180]  тип. Я могу
[01:14:17.180 --> 01:14:19.180]  сделать using на переменную, на функцию, как я уже
[01:14:19.180 --> 01:14:21.180]  говорил, а могу на тип. Что это значит?
[01:14:21.180 --> 01:14:23.180]  Я, например, могу сказать такое,
[01:14:23.180 --> 01:14:25.180]  что using
[01:14:27.180 --> 01:14:29.180]  v и
[01:14:29.180 --> 01:14:31.180]  равно std vector int.
[01:14:33.180 --> 01:14:35.180]  Ну, мне надо заинклудить вектор.
[01:14:35.180 --> 01:14:37.180]  Да, я забыл сказать, да,
[01:14:37.180 --> 01:14:39.180]  ну, я думаю, вы и так понимаете. Чтобы пользоваться
[01:14:39.180 --> 01:14:41.180]  вектором, надо написать include vector,
[01:14:41.180 --> 01:14:43.180]  чтобы пользоваться string, надо написать include string.
[01:14:43.180 --> 01:14:45.180]  Вот сейчас
[01:14:45.180 --> 01:14:47.180]  я написал
[01:14:47.180 --> 01:14:49.180]  так называемый alias для
[01:14:49.180 --> 01:14:51.180]  типа.
[01:14:53.180 --> 01:14:55.180]  Теперь v и это тот же
[01:14:55.180 --> 01:14:57.180]  самый тип, что и vector int.
[01:14:57.180 --> 01:14:59.180]  В рамках этой области видимости.
[01:14:59.180 --> 01:15:01.180]  Надо понимать,
[01:15:01.180 --> 01:15:03.180]  что я не новый тип сейчас создал,
[01:15:03.180 --> 01:15:05.180]  а просто другое название для уже существующего
[01:15:05.180 --> 01:15:07.180]  типа создал.
[01:15:07.180 --> 01:15:09.180]  Ну, просто если мне почему-то тип
[01:15:09.180 --> 01:15:11.180]  слишком длинно называется, я хочу называть его
[01:15:11.180 --> 01:15:13.180]  короче, я могу вот так делать.
[01:15:13.180 --> 01:15:15.180]  Это иногда удобно.
[01:15:15.180 --> 01:15:17.180]  Да.
[01:15:17.180 --> 01:15:19.180]  От macros это
[01:15:19.180 --> 01:15:21.180]  отличается много. Чем?
[01:15:21.180 --> 01:15:23.180]  Macros очень тупой.
[01:15:23.180 --> 01:15:25.180]  Macros он делает
[01:15:25.180 --> 01:15:27.180]  потекстовую подстановку.
[01:15:27.180 --> 01:15:29.180]  Ну,
[01:15:29.180 --> 01:15:31.180]  macros
[01:15:31.180 --> 01:15:33.180]  это тупая
[01:15:33.180 --> 01:15:35.180]  потекстовая подстановка.
[01:15:35.180 --> 01:15:37.180]  Замени одну подстроку в коде
[01:15:37.180 --> 01:15:39.180]  на другую подстроку в коде.
[01:15:39.180 --> 01:15:41.180]  То есть, если я распишу переменную int v,
[01:15:41.180 --> 01:15:43.180]  то он при любви заменяет на...
[01:15:43.180 --> 01:15:45.180]  Да.
[01:15:45.180 --> 01:15:47.180]  Если ты напишешь переменную там...
[01:15:47.180 --> 01:15:49.180]  Ну, в общем, да.
[01:15:49.180 --> 01:15:51.180]  Macros делаются до компиляции define.
[01:15:51.180 --> 01:15:53.180]  И вам на семинаре
[01:15:53.180 --> 01:15:55.180]  на каком-нибудь про macros расскажут.
[01:15:55.180 --> 01:15:57.180]  А это гораздо более углая подстановка,
[01:15:57.180 --> 01:15:59.180]  она симматическая, то есть она осмысленная.
[01:15:59.180 --> 01:16:01.180]  Компилятор просто понимает, что v,
[01:16:01.180 --> 01:16:03.180]  v, это то же самое, что vector int.
[01:16:03.180 --> 01:16:05.180]  И может выдавать вам осмысленное предупреждение,
[01:16:05.180 --> 01:16:07.180]  что вы там, например,
[01:16:07.180 --> 01:16:09.180]  v,
[01:16:09.180 --> 01:16:11.180]  потом переопределяетесь каким-то другим названием.
[01:16:11.180 --> 01:16:13.180]  Вот, например,
[01:16:13.180 --> 01:16:15.180]  вот вам, кстати, пример. Представьте,
[01:16:15.180 --> 01:16:17.180]  что я так написал, а потом написал так.
[01:16:17.180 --> 01:16:19.180]  Пример, чем это от macros отличается.
[01:16:19.180 --> 01:16:21.180]  Сейчас будет ошибка,
[01:16:21.180 --> 01:16:23.180]  потому что я пытаюсь
[01:16:23.180 --> 01:16:25.180]  переопределить v.i.,
[01:16:25.180 --> 01:16:27.180]  которое уже было объявлено как тип.
[01:16:27.180 --> 01:16:29.180]  v.i. redeclared as different kind of entity.
[01:16:29.180 --> 01:16:31.180]  До этого v.i. было vector,
[01:16:31.180 --> 01:16:33.180]  а теперь я пытаюсь сказать, что это int.
[01:16:33.180 --> 01:16:35.180]  Так нельзя. Если бы я сделал macros define
[01:16:35.180 --> 01:16:37.180]  v.i. vector int, то он бы и вообще
[01:16:37.180 --> 01:16:39.180]  не подавился, он бы посчитал,
[01:16:39.180 --> 01:16:41.180]  что если бы написал int std vector int.
[01:16:41.180 --> 01:16:43.180]  И ошибка была бы другой.
[01:16:43.180 --> 01:16:45.180]  То есть macros это тупая
[01:16:45.180 --> 01:16:47.180]  постановка без задумывания о смысле.
[01:16:47.180 --> 01:16:49.180]  Понятно?
[01:16:49.180 --> 01:16:51.180]  Вот.
[01:16:51.180 --> 01:16:53.180]  Все. Это конец
[01:16:53.180 --> 01:16:55.180]  параграфа 1.3.
[01:16:59.180 --> 01:17:01.180]  Еще раз, а если там int,
[01:17:01.180 --> 01:17:03.180]  что будет в игре?
[01:17:03.180 --> 01:17:05.180]  Если не написали int v.i.,
[01:17:05.180 --> 01:17:07.180]  то что-то это что?
[01:17:07.180 --> 01:17:09.180]  С macros или сейчас?
[01:17:09.180 --> 01:17:11.180]  Ну вообще, если бы не написали int v.i.
[01:17:11.180 --> 01:17:13.180]  Ну я написал, вот, произошло.
[01:17:13.180 --> 01:17:15.180]  Я хотел переобъединить v.i.
[01:17:15.180 --> 01:17:17.180]  Уже v.i. определено как vector int,
[01:17:17.180 --> 01:17:19.180]  а я теперь пытаюсь переменнуть с таким
[01:17:19.180 --> 01:17:21.180]  именем, как нельзя.
[01:17:21.180 --> 01:17:23.180]  Ну, у нас осталось еще немного
[01:17:23.180 --> 01:17:25.180]  времени, давайте начнем следующий
[01:17:25.180 --> 01:17:27.180]  параграф.
[01:17:27.180 --> 01:17:29.180]  Он будет называться
[01:17:29.180 --> 01:17:31.180]  выражение и операторы.
[01:17:33.180 --> 01:17:35.180]  На самом деле,
[01:17:37.180 --> 01:17:39.180]  вот, я вам сказал,
[01:17:39.180 --> 01:17:41.180]  что ваша программа это
[01:17:41.180 --> 01:17:43.180]  из объявлений
[01:17:43.180 --> 01:17:45.180]  и
[01:17:45.180 --> 01:17:47.180]  на верхнем уровне это так.
[01:17:47.180 --> 01:17:49.180]  То есть, на глобальном уровне,
[01:17:49.180 --> 01:17:51.180]  в глобальном скопе, все, что вы делаете,
[01:17:51.180 --> 01:17:53.180]  это объявляете сущности.
[01:17:53.180 --> 01:17:55.180]  Переменные, функции, пространство имен,
[01:17:55.180 --> 01:17:57.180]  классы и так далее.
[01:17:57.180 --> 01:17:59.180]  Но, когда вы заходите в функцию,
[01:17:59.180 --> 01:18:01.180]  то есть, когда вы находитесь в local scope,
[01:18:01.180 --> 01:18:03.180]  вы уже
[01:18:03.180 --> 01:18:05.180]  помимо объявлений
[01:18:05.180 --> 01:18:07.180]  можете писать и другие вещи,
[01:18:07.180 --> 01:18:09.180]  а именно вы можете писать еще
[01:18:09.180 --> 01:18:11.180]  выражения, expression и
[01:18:11.180 --> 01:18:13.180]  control statements,
[01:18:13.180 --> 01:18:15.180]  так называемые.
[01:18:15.180 --> 01:18:17.180]  Значит,
[01:18:17.180 --> 01:18:19.180]  ну, вот то, что вы можете писать
[01:18:19.180 --> 01:18:21.180]  внутри функции,
[01:18:23.180 --> 01:18:25.180]  давайте я, наверное,
[01:18:25.180 --> 01:18:27.180]  снова перейду рисовать на доске,
[01:18:31.180 --> 01:18:33.180]  в отличие от глобальной области
[01:18:33.180 --> 01:18:35.180]  и namespace области,
[01:18:35.180 --> 01:18:37.180]  внутри функции вы можете писать
[01:18:37.180 --> 01:18:39.180]  statements.
[01:18:41.180 --> 01:18:43.180]  Да, значит, параграф 1.4
[01:18:43.180 --> 01:18:45.180]  называется
[01:18:47.180 --> 01:18:49.180]  expressions and operators.
[01:18:49.180 --> 01:18:51.180]  И, видимо, мы его сейчас начнем,
[01:18:51.180 --> 01:18:53.180]  а закончим в следующий раз.
[01:18:59.180 --> 01:19:01.180]  Statements.
[01:19:01.180 --> 01:19:03.180]  Statements бывают
[01:19:03.180 --> 01:19:05.180]  declarations, бывают
[01:19:05.180 --> 01:19:07.180]  expressions, а бывают
[01:19:07.180 --> 01:19:09.180]  control statements.
[01:19:11.180 --> 01:19:13.180]  Declaration уже, вы знаете,
[01:19:13.180 --> 01:19:15.180]  переводится как объявление,
[01:19:15.180 --> 01:19:17.180]  expression означает выражение,
[01:19:17.180 --> 01:19:19.180]  а control statement это,
[01:19:19.180 --> 01:19:21.180]  ну, вы, возможно, догадываетесь,
[01:19:21.180 --> 01:19:23.180]  что такое control statement,
[01:19:23.180 --> 01:19:25.180]  это либо if, либо for, либо while,
[01:19:25.180 --> 01:19:27.180]  в общем, это инструкция, которая
[01:19:27.180 --> 01:19:29.180]  меняет ход выполнения каким-то образом.
[01:19:29.180 --> 01:19:31.180]  Мы с вами в прошлом параграфе
[01:19:31.180 --> 01:19:33.180]  обсудили подробно что такое declaration,
[01:19:33.180 --> 01:19:35.180]  что называют expressions.
[01:19:35.180 --> 01:19:37.180]  Что такое expressions?
[01:19:37.180 --> 01:19:39.180]  Это,
[01:19:39.180 --> 01:19:41.180]  ну, формальное определение
[01:19:41.180 --> 01:19:43.180]  очень сложное, и оно занимает
[01:19:43.180 --> 01:19:45.180]  страницы две, наверное.
[01:19:45.180 --> 01:19:47.180]  Вот у вас на мат-логике
[01:19:47.180 --> 01:19:49.180]  возможно было определение
[01:19:49.180 --> 01:19:51.180]  или будет скоро определение того,
[01:19:51.180 --> 01:19:53.180]  что такое формула синтоксическая,
[01:19:53.180 --> 01:19:55.180]  корректная. Вот expression определяется
[01:19:55.180 --> 01:19:57.180]  также, это длинное синтоксическое
[01:19:57.180 --> 01:19:59.180]  определение, из чего может состоять
[01:19:59.180 --> 01:20:01.180]  expression. Но не формальная expression,
[01:20:01.180 --> 01:20:03.180]  набор переменных и литералов,
[01:20:03.180 --> 01:20:05.180]  соединенных между собой операторами
[01:20:05.180 --> 01:20:07.180]  и скобками по синтоксическим правилам.
[01:20:07.180 --> 01:20:09.180]  Ну, например,
[01:20:09.180 --> 01:20:11.180]  что я имею в виду? Вот, например, там, я не знаю,
[01:20:11.180 --> 01:20:13.180]  x плюс 5 это expression,
[01:20:15.180 --> 01:20:17.180]  x плюс-плюс это expression,
[01:20:19.180 --> 01:20:21.180]  cout x это expression,
[01:20:23.180 --> 01:20:25.180]  вот это все expression,
[01:20:25.180 --> 01:20:27.180]  вызов функция,
[01:20:27.180 --> 01:20:29.180]  это все expression.
[01:20:31.180 --> 01:20:33.180]  А в данном случае
[01:20:33.180 --> 01:20:35.180]  у вас есть
[01:20:35.180 --> 01:20:37.180]  оператор плюс
[01:20:37.180 --> 01:20:39.180]  и два оператора, x и 5.
[01:20:39.180 --> 01:20:41.180]  В данном случае у вас есть оператор плюс-плюс
[01:20:41.180 --> 01:20:43.180]  и один оператор, x.
[01:20:43.180 --> 01:20:45.180]  В данном случае у вас есть
[01:20:45.180 --> 01:20:47.180]  оператор вот этот,
[01:20:47.180 --> 01:20:49.180]  два оператора, cout и x,
[01:20:49.180 --> 01:20:51.180]  это на самом деле тоже expression.
[01:20:51.180 --> 01:20:53.180]  Это вызов оператора влево-влево
[01:20:53.180 --> 01:20:55.180]  от переменных
[01:20:55.180 --> 01:20:59.180]  xout и xout это тоже переменная, просто у нее тип странный.
[01:20:59.180 --> 01:21:02.180]  Вызов функции это тоже expression.
[01:21:02.180 --> 01:21:06.180]  Это особый вид expression, который называется function call expression.
[01:21:08.180 --> 01:21:12.180]  Функция дальше круглые скобочки, которые формально являются оператором.
[01:21:12.180 --> 01:21:14.180]  И дальше перечтение аргументов.
[01:21:16.180 --> 01:21:22.180]  Наша с вами задача это вкратце рассмотреть какие есть виды expression и какие у них особенности.
[01:21:25.180 --> 01:21:30.180]  Давайте мы начнем рассматривать, а продолжим в следующий раз.
[01:21:35.180 --> 01:21:38.180]  Я буду рассматривать не expression как таковые, а операторы.
[01:21:38.180 --> 01:21:43.180]  Выражение состоит из операторов, поэтому я буду рассматривать операторы.
[01:21:46.180 --> 01:21:52.180]  Сначала, наверное, самые простые, всем известные, это арифметические операторы.
[01:21:56.180 --> 01:22:08.180]  Да, это плюс, минус, умножить, разделить, процент, да и все вроде.
[01:22:08.180 --> 01:22:10.180]  Это арифметические операторы.
[01:22:16.180 --> 01:22:18.180]  Побитовые операторы.
[01:22:18.180 --> 01:22:22.180]  Еще к арифметическим, наверное, можно отнести вот эти операторы побитого сдвига.
[01:22:22.180 --> 01:22:28.180]  Но вот, заметьте, что вот эти операторы, они ведут себя по-разному, смотря каких типов они вызываются.
[01:22:28.180 --> 01:22:33.180]  Для целых чисел побитого сдвига означает, ну, означает побитовый сдвиг, вы понимаете, что такое побитовый сдвиг, да?
[01:22:33.180 --> 01:22:39.180]  Например, 1, вот так вот, 3, это будет 8.
[01:22:39.180 --> 01:22:42.180]  Я сдвинул и минус на 3 влево побитого.
[01:22:42.180 --> 01:22:49.180]  Но если этот оператор применяется к истриму, к остриму, то он означает вывод в поток.
[01:22:49.180 --> 01:22:53.180]  А этот оператор, примененный к истриму, означает ввод из потока.
[01:22:53.180 --> 01:22:58.180]  То есть, это тот же самый оператор, просто для других типов он по-другому себя ведет.
[01:22:58.180 --> 01:23:00.180]  Вот так работает перегрузка оператора.
[01:23:02.180 --> 01:23:07.180]  Ну, можно еще, например, упомянуть операторы сравнения.
[01:23:07.180 --> 01:23:09.180]  Давайте я их упомяну и на этом мы закончим.
[01:23:09.180 --> 01:23:11.180]  Операторы сравнения.
[01:23:13.180 --> 01:23:15.180]  Это что за операторы?
[01:23:15.180 --> 01:23:25.180]  Ну, это операторы равно, неравно, меньше или равно, больше или равно, меньше, больше.
[01:23:25.180 --> 01:23:29.180]  Ну, еще есть вот такой оператор, но он появился только в C++20.
[01:23:29.180 --> 01:23:33.180]  Он довольно сложен для понимания, мы его пока не будем обсуждать.
[01:23:33.180 --> 01:23:42.180]  Ну, это операторы, которые позволяют вам сравнивать переменные и другие выражения, проверять на равенство или на меньше.
[01:23:42.180 --> 01:23:46.180]  Они принимают разные типы, а возвращают булевское значение.
[01:23:51.180 --> 01:23:57.180]  Ну, наверное, на этом мы закончим сегодня.
[01:23:58.180 --> 01:24:02.180]  В следующий раз, я напоминаю, мы проведем онлайн.
