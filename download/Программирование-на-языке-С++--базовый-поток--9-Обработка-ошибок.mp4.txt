[00:00.000 --> 00:11.280]  Всем добрый день, давайте начнем. В прошлый раз мы с вами начали обсуждать тему обработки
[00:11.280 --> 00:19.080]  ошибок в C++ и рассмотрели несколько способов, как это можно было бы сделать уже с существующими метами,
[00:19.080 --> 00:24.040]  то есть теми метами, которые мы уже знаем. Давайте кратко по ним пройдемся. Первый метод это
[00:24.040 --> 00:29.920]  просто добить. Мы просто-напросто говорим о том, что ошибки существуют, соответственно,
[00:29.920 --> 00:33.440]  если происходит какая-то ошибка, то ничего с этим делать поделать не можно, программа просто падает.
[00:33.440 --> 00:38.320]  Понятное дело, чем плохо это способ, это способ плохо тем, что если мы пишем какое-то приложение,
[00:38.320 --> 00:41.720]  отдаем его конечному пользователю, то пользователю возникает какая-то ошибка,
[00:41.720 --> 00:45.600]  ему нужно либо программу перезапускать, либо обращаться в соответствующий справочник,
[00:45.600 --> 00:52.880]  обращаться в компанию, которая предоставила ему это приложение, и спрашивать, а что за ошибка,
[00:52.880 --> 00:57.920]  как мне с ней справляться. Поэтому хотелось бы иметь некоторую возможность справляться с ошибкой
[00:57.920 --> 01:04.600]  изнутри самого кода. Грубо говоря, если у меня в коде при вызове библиотечной функции возникла
[01:04.600 --> 01:09.520]  ошибка, я бы хотел иметь какую-то возможность продолжить нормальную работу, например, либо
[01:09.520 --> 01:13.160]  постараться воспользоваться какой-то другой функцией, либо напечатать какое-то осмысленное
[01:13.160 --> 01:19.800]  сообщение на экран, что скажем, на системе не хватает памяти, сходить купить новую плашку и так далее.
[01:19.800 --> 01:26.760]  Или просто справиться с проблемой, изменить входные данные, как-то еще раз их проверить и так далее.
[01:26.760 --> 01:33.320]  Соответственно, какие есть для этого способы? Первый способ это использовать некоторую глобальную
[01:33.320 --> 01:37.080]  переменную, в которой мы будем записывать код ошибки. Соответственно, функция отработала,
[01:37.080 --> 01:40.920]  дальше в эту глобальную переменную она записывает, что вот функция завершилась кодом ошибки 0,
[01:40.920 --> 01:45.480]  или с кодом ошибки 1, 2 и так далее. В чем проблема? Понятно. Для каждой функции у меня
[01:45.480 --> 01:51.100]  будет свои коды ошибки, то есть для каждой функции будет своя интерпретация того, что такое код
[01:51.100 --> 01:55.960]  ошибки 1, 2 и так далее. Плюс необходимо проверять эту самую глобальную переменную. И плюс если
[01:55.960 --> 02:00.520]  мы пишем какую-то многопоточную программу, или программу, в которую используют несколько потоков,
[02:00.520 --> 02:04.160]  несколько процессов, которые используют одну и ту же глобальную переменную, то соответственно
[02:04.160 --> 02:09.720]  у нас мы теряем возможность узнать, а какая функция записала, условно, эту переменную. Вообще все
[02:09.720 --> 02:14.680]  проблемы с синхронизацией, нескольких потоков и так далее у нас в этой программе будут присутствовать.
[02:14.680 --> 02:21.680]  Следующий подход, который очень часто используется, по сути, де-факто является основным способом обработки ошибок в языке C.
[02:21.680 --> 02:24.680]  Это, соответственно, способ, при котором мы из функции возвращаем код ошибки.
[02:24.680 --> 02:28.680]  У нас есть функция, и каждая функция, которая потенциально может завершиться неуспешно,
[02:28.680 --> 02:35.680]  она возвращает некоторые код ошибки, некоторые сигналы того, что программа, точнее, функция завершилась успешно или неуспешно.
[02:35.680 --> 02:42.680]  Но опять же недостатками такого подхода, естественно, преимущественно, является то, что все ошибки видны сразу явно.
[02:42.680 --> 02:46.680]  То есть у нас код состоит из кучи ифов, мы видим, что вот эта функция может теоретически завершиться неуспешно,
[02:46.680 --> 02:50.680]  вот эта функция всегда завершается успешно и так далее.
[02:50.680 --> 02:54.680]  Но недостаток, понятное дело, мы должны теперь проверять возвращаемые значения каждой функции.
[02:54.680 --> 02:59.680]  Это, во-первых, фавор, во-вторых, соответственно, у нас теряется привычная нами семантика возвращаемого значения.
[02:59.680 --> 03:03.680]  Все-таки мы привыкли, что если мы взываем какую-то функцию, то эта функция возвращает результат.
[03:03.680 --> 03:09.680]  Странно предполагать, что какая-то математическая функция или вообще функция в широком смысле, она возвращает код ошибки.
[03:09.680 --> 03:14.680]  Результат мы должны получать каким-то отдельным способом, либо с помощью ссылки, либо с помощью указателя.
[03:14.680 --> 03:18.680]  Ну, соответственно, у каждого способа есть свои преимущественные досадки.
[03:18.680 --> 03:23.680]  Мы к ним еще вернемся, когда обсудим то, что я запланировал на сегодня.
[03:23.680 --> 03:29.680]  Но сейчас давайте поговорим про то, какой способ обработки ошибок привнес язык C++.
[03:29.680 --> 03:34.680]  Ну и какой способ обработки ошибок существует во многих объектно-ориентированных языках программирования.
[03:34.680 --> 03:36.680]  Я говорю про исключение.
[03:36.680 --> 03:39.680]  Соответственно, давайте посмотрим на пример, который разбирали в прошлый раз.
[03:39.680 --> 03:44.680]  Значит, я напомню, что мы хотим написать функцию divide, которая принимает на вход два значения и пытается разделить одно на другое.
[03:44.680 --> 03:49.680]  Ну и соответственно, мы с вами понимаем, что деление допустимо только если, во многих множествах,
[03:49.680 --> 03:52.680]  то деление допустимо только в случае, если y не равен нулю.
[03:52.680 --> 03:56.680]  Соответственно, мы должны каким-то образом проверять, что если y равен нулю,
[03:56.680 --> 04:00.680]  то мы должны каким-то образом сообщить об ошибке, что функция не может корректно завершиться.
[04:00.680 --> 04:08.680]  А во всех остальных ситуациях мы сообщаем, что возвращаем верный ответ.
[04:08.680 --> 04:15.680]  Соответственно, чтобы сообщить об ошибке в C++, используется специальный оператор, специальное ключевое слово throw.
[04:15.680 --> 04:17.680]  Что делает throw?
[04:17.680 --> 04:27.680]  throw аварийно завершает функцию, при этом считается, что функция не возвращает никакого значения, а просто завершается.
[04:27.680 --> 04:32.680]  И это каскадно приводит к тому, что программа просто-напросто аварийно завершает работу.
[04:32.680 --> 04:36.680]  Давайте подробно поговорим про то, как устроен throw.
[04:36.680 --> 04:42.680]  Следующий пример. Представьте себе, что у меня есть функция main, которая вызывает курение, курение вызывает рак,
[04:42.680 --> 04:44.680]  рак бросает исключение единицы.
[04:44.680 --> 04:50.680]  Ну и соответственно, каждая функция делает какую-то работу, в частности, печатает что-то в консуле вывода.
[04:50.680 --> 04:52.680]  Что у меня тут происходит?
[04:52.680 --> 04:57.680]  От этой последовательности вызовов, смокинг, канцер и так далее, значит, канцер доходит до строчки throw1.
[04:57.680 --> 04:59.680]  Чему приводит throw1?
[04:59.680 --> 05:06.680]  throw1 приводит к тому, что все следующие операторы этой функции, если я встретил оператора throw,
[05:06.680 --> 05:11.680]  то все остальные операторы, которые идут после throw, они просто-напросто не выполняются.
[05:11.680 --> 05:14.680]  То есть вызов оператора throw приводит к тому, что функция завершается.
[05:14.680 --> 05:18.680]  Но при этом завершение функции, естественно, приводит к тому, что все локальные перемены тоже уничтожаются,
[05:18.680 --> 05:20.680]  для них вызываются деструкторы и так далее.
[05:20.680 --> 05:22.680]  То есть с этим все хорошо.
[05:22.680 --> 05:26.680]  Если будет вызвано оператор throw, то все локальные переменные будут корректно очищены, будут корректно удалены.
[05:26.680 --> 05:28.680]  Что происходит дальше?
[05:28.680 --> 05:31.680]  Дальше мы возвращаемся в функцию смокинг, который вызывал канцер.
[05:31.680 --> 05:38.680]  Так как функция канцер завершилась неуспешно, то считается, что в той строчке, в которой был вызван канцер,
[05:38.680 --> 05:45.680]  считается, что в этой строчке тоже вылетело исключение.
[05:45.680 --> 05:49.680]  То есть смотрите, канцер сгенерировал некоторые исключение, я сгенерировал некоторую ошибку.
[05:49.680 --> 05:53.680]  Соответственно, ошибка дошла до функции смокинг.
[05:53.680 --> 05:56.680]  То есть считается, что если канцер завершился не успешно, значит канцер завершился с ошибкой.
[05:56.680 --> 05:58.680]  И ошибка теперь вылетает отсюда.
[05:58.680 --> 06:01.680]  Соответственно, это приводит к тому, что смокинг тоже аварийно завершается,
[06:01.680 --> 06:06.680]  все операторы, которые находится дальше него, тоже не выполняются.
[06:06.680 --> 06:08.680]  Соответственно, смокинг аварийно завершает работу.
[06:08.680 --> 06:12.680]  Опять же, тоже корректно уничтожая все локальные перемения и так далее.
[06:12.680 --> 06:21.680]  Дальше исключение попадает в функцию main. Трочку с вызовом. Функции smoking.
[06:21.680 --> 06:26.680]  Исключение вылетает из этой функции. Ну и так как main это исключение никак не обрабатывает,
[06:26.680 --> 06:31.680]  про обработку исключения чуть позже. Так как main никак ничего не делает с этой ошибкой,
[06:31.680 --> 06:35.680]  то main тоже аварийно завершается, и никакие операторы дальше не будут выполнены.
[06:35.680 --> 06:39.680]  Соответственно, в итоге вызова этой программы мы с вами увидим на экране сообщение об ошибке,
[06:39.680 --> 06:44.680]  что программа аварийно завершилась, но завершилась с помощью вызова функции terminate.
[06:44.680 --> 06:50.680]  Ну и соответственно, программа завершилась после того, как было выброшено исключение типа int.
[06:50.680 --> 06:54.680]  Соответственно, мы видим такое сообщение об ошибке, и ни одного сообщения, которое написано выше,
[06:54.680 --> 06:58.680]  типа cout.cancers, cout.smoking и так далее, мы не увидим. В общем чертах понятно?
[06:58.680 --> 07:05.680]  То есть, вызов оператора throw, если никакие исключения, если я ошибку никак не обрабатывать,
[07:05.680 --> 07:08.680]  то это приводит к тому, что программа просто каскадно завершается.
[07:08.680 --> 07:13.680]  То есть, завершается функция, которая вызвала оператор throw, дальше завершается функция,
[07:13.680 --> 07:17.680]  которая вызвала функцию, которая привела к ошибке, и так далее, и пока не завершится вся программа.
[07:17.680 --> 07:22.680]  То есть, на таком примитивном первом уровне кажется, что все понятно.
[07:22.680 --> 07:29.680]  Давайте поговорим про то, для чего нужен вот этот аргумент, которому мы указываем оператор throw.
[07:29.680 --> 07:33.680]  На самом деле, тут аналогия довольно-таки простая. Можно привести аналогию с оператором return.
[07:33.680 --> 07:37.680]  То есть, если оператор return возвращает значение e, которое у нас получилось в результате
[07:37.680 --> 07:42.680]  корректного выполнения программы, то throw принимает аргумент, который должен быть условно,
[07:42.680 --> 07:47.680]  опять же, это не совсем корректно, но типа возвращает в результате некорректного завершения программы.
[07:47.680 --> 07:55.680]  То есть, если я пишу что-то наподобие throw a, то у меня создается исключение e, новое понятие.
[07:55.680 --> 08:00.680]  Исключение – это некоторый объект, который по сути должен хранить себе информацию о том,
[08:00.680 --> 08:04.680]  какая ошибка произошла. То есть, если произошла какая-то ошибка, то значит, что в программе
[08:05.680 --> 08:09.680]  существует некоторое исключение, некоторая исключительная ситуация, вот.
[08:09.680 --> 08:12.680]  И в целом, назначение вот этого самого исключения, вот этого самого объекта,
[08:12.680 --> 08:18.680]  заключается в том, чтобы хранить Некоторую информацию о том из-за чего ошибка произошла,
[08:18.680 --> 08:23.680]  в целом какую-то общую информацию об ошибке. То есть, в целом, если вы пишете throw a,
[08:23.680 --> 08:29.680]  то это означает, что с помощью вот этого объекта a или с помощью вот этого типа а вы хотите
[08:29.680 --> 08:33.680]  Соответственно, если я пишу throwA, то состается исключение A,
[08:33.680 --> 08:36.680]  и при этом вот эта переменная A копируется в специальное место в программе.
[08:36.680 --> 08:43.680]  Есть специальное место в программе, есть глобальная память, есть стэковая память, и так далее.
[08:43.680 --> 08:52.680]  Соответственно, где-то в глобальной памяти создается объект исключения,
[08:52.680 --> 08:57.900]  и вот эта вот переменная, переменная a, она копируется, она копируется в этот специальный объект
[08:57.900 --> 09:02.900]  исключения, и программа, ну мы поговорим о том, как она может обращаться к этому
[09:02.900 --> 09:07.740]  объекту и кем-то образом узнавать о том, что за ошибка произошла, вот. Ну естественно, если
[09:07.740 --> 09:13.980]  я напишу throw sdmuffat a, то этот объект a, точнее переменная a, переместится вот в этот
[09:13.980 --> 09:19.380]  объект исключения, который будет создан при вызове оператора throw, вот.
[09:19.380 --> 09:25.040]  Окей? Вот, ну то есть аналогия опять же тут такая же, как и с оператором return, да, то есть
[09:25.040 --> 09:29.560]  если я пишу там return a, то вообще говоря там объект может там скопироваться, да, если я
[09:29.560 --> 09:35.120]  пишу return там какой-то временный объект, да, то это временный объект, он перемещается и так
[09:35.120 --> 09:41.500]  далее, то есть в целом тут аналогия такая, вот. Теперь давайте поговорим про то, как
[09:41.500 --> 09:45.880]  исключение обрабатывать. Ну окей, мы поняли, да, что если мы вызываем оператор throw, то все,
[09:45.880 --> 09:50.140]  кирдык, программа завершается, все плохо и так далее, но кажется, что это не совсем то, что нам
[09:50.140 --> 09:53.800]  нужно, да, потому что когда мы говорили про обработку ошибок, ну когда я в начале говорил
[09:53.800 --> 09:58.000]  про обработку ошибок, я говорил, что вообще говоря это про то, как бы восстановить нормальную
[09:58.000 --> 10:01.620]  работу программы, да, если какая-то исключительная ситуация произошла, но, допустим, я понимаю, что
[10:01.620 --> 10:05.100]  вот эту функцию вызвать нельзя, ну по какой-то причине, да, допустим, сервера недоступны, да, то есть
[10:05.100 --> 10:09.220]  я вызываю там функцию, да, например, я открываю какое-то соединение по СТ, допустим, ну хочу там
[10:09.220 --> 10:14.780]  сделать какой-то запрос Гуглу, вот, а Гугл говорит, там не отвечает, все, вот. Дальше, соответственно, я
[10:14.780 --> 10:18.400]  понимаю, что если Гугл не отвечает, то я могу там, не знаю, обратиться в Яндекс, или какие-то другие
[10:18.400 --> 10:23.840]  поисковики. Вот, соответственно, я получил какое-то некорректное сообщение, какое-то некорректное
[10:23.840 --> 10:27.160]  обращение, ну, соответственно, в результате я могу восстановить корректную работу программы, просто
[10:27.160 --> 10:32.280]  переключившись, допустим, на другой сервер или что-то наподобие этого. Значит, давайте посмотрим,
[10:32.280 --> 10:36.920]  как можно продолжить нормальное течение программы в случае, если произошла какая-то
[10:36.920 --> 10:43.720]  нештатная ситуация, какая-то исключительная ситуация. Значит, для этого используется так называемый
[10:43.720 --> 11:01.280]  try-catch-блок. Что делает try-catch-блок? Давайте по порядку. В блоке try мы помещаем вызовы,
[11:01.280 --> 11:06.280]  ну и вообще те операторы, операторы, операции и вызовы функций, которые потенциально могут
[11:06.280 --> 11:10.520]  привести к проблемам. Например, вот в этой простой программе мы с вами понимаем, что теоретически
[11:10.520 --> 11:16.000]  функция деления может привести к тому, что она завершится неуспешно, она выбросит исключение. Но при
[11:16.000 --> 11:20.040]  этом, если функция divide завершится неуспешно, мы не хотим аварийно завершать программу. Мы хотим
[11:20.040 --> 11:24.160]  просто напечатать какое-то сообщение на экран и продолжить корректное исполнение программы.
[11:24.160 --> 11:30.360]  Что для этого мы делаем? Мы для этого помещаем вызов функции divide в блок try. Значит, смотрите,
[11:30.360 --> 11:35.080]  в блок try можно помещать произвольное количество функций, и все эти функции будут вызываться
[11:35.080 --> 11:38.880]  трога друг за другом по порядку. В общем, все нормально. В общем, блок try это просто отдельный
[11:38.880 --> 11:46.680]  вид блока исполняемого кода C++. Значит, я пишу try divide. И что это означает? Это означает,
[11:46.680 --> 11:54.800]  что если в divide возникнет какое-то исключение, если в divide выскочит какая-то ошибка, то эту ошибку
[11:54.800 --> 12:02.760]  можно будет поймать в последующем за try блоком catch. Соответственно, блок try просто говорит
[12:02.760 --> 12:06.360]  компилятору, что вот с этим блоком будь поаккуратней. Если из него вылетит исключение,
[12:06.360 --> 12:14.080]  то попытаюсь его поймать одним из последующих блоков catch. Что такое catch блок? Catch блок
[12:14.080 --> 12:21.760]  позволяет вам поймать исключение какого-то конкретного типа. Ну, в частности, допустим,
[12:21.760 --> 12:31.160]  я знаю, что функция divide бросает исключение типа int. Видим, что в функции divide написано throw1.
[12:31.160 --> 12:36.520]  Это означает, что вот этот вот исключение, вот этот объект исключения имеет тип int. Соответственно,
[12:36.520 --> 12:41.160]  я пишу, что в блоке catch я должен поймать исключение типа int и записать его в переменную r.
[12:41.160 --> 12:46.120]  Окей? Вот. Я поймал, то есть, после того, как в divide возникло исключение, значит,
[12:46.120 --> 12:50.760]  это исключение вылетело из divide. Но так как оно вылетело в блоке try, то блок try автоматически
[12:50.760 --> 12:54.600]  начнет искать соответствующий этому исключению блок catch. И он этот блок найдет, то есть он видит,
[12:54.600 --> 12:58.800]  что вот этот вот catch, который написан здесь, принимает исключение типа int, а у меня действительно
[12:58.800 --> 13:04.400]  исключение типа int. Вот. Он сохраняет значение этого исключения в переменную r, ну, путем копирования.
[13:04.400 --> 13:07.920]  Ну и, соответственно, после этого выполняется вот этот блок. То есть выполняется выводный
[13:07.920 --> 13:11.840]  экран division error, error-код, ну и, соответственно, печатает с кода ошибки. Вот. После того,
[13:11.840 --> 13:16.720]  как блок catch завершится, программа продолжит нормальную работу. И вот в этом принципиальное
[13:16.720 --> 13:21.240]  отличие, наличие try-catch-блока от отсутствия. То есть, если бы тут try-catch-блок отсутствовал,
[13:21.240 --> 13:24.800]  то исключение вылетело из divide и программа бы завершилась. Ну, потому что завершилась функция
[13:24.800 --> 13:30.360]  main. Здесь же так у меня есть block try-catch-блок. После того, как catch-блок отработал, считается,
[13:30.360 --> 13:35.040]  что программа должна продолжить работу в нормальном режиме. То есть, она продолжит работу с первого
[13:35.040 --> 13:38.640]  оператора, который находится за catch-блоком. Ну, то есть, естественно, я не буду возвращаться обратно
[13:38.640 --> 13:41.960]  в функцию divide и продолжать работу. То есть, если функция divide завершилась неуспешно, то ее продолжать
[13:41.960 --> 13:47.680]  не имеет смысла. Продолжить работу я буду после первого отработанного блока catch. Ну, вот в данном
[13:47.680 --> 13:51.360]  случае следующим оператором будет return 0. То есть, у меня после блока catch отработает return 0 и
[13:51.360 --> 14:11.520]  программа нормально завершит работу. Любой блок сужает область видимости. Да, спасибо. Хороший
[14:11.520 --> 14:15.680]  вопрос. Действительно стоит обратить внимание. Смотрите, то, что написано в try-блоке, то есть,
[14:15.680 --> 14:21.320]  если я в try-блоке создал переменную index, то эта переменная будет видна только в этом try-catch-блоке.
[14:21.320 --> 14:26.160]  Окей? Вне этого блока эта переменная видна не будет. Но, аналогично, если я в catch-блоке
[14:26.160 --> 14:31.080]  тоже создам какую-то переменную, то эта переменная будет видна только вот в этом блоке. Понятно? В
[14:31.080 --> 14:35.480]  других блоках ее видно не будет. Точнее, вот вне этого блока ее видно не будет. Окей? То есть,
[14:35.480 --> 14:39.480]  любой блок, который ограничен фигурной скопкой, он, естественно, создает свой скоп, то есть свою область
[14:39.480 --> 14:56.640]  видимости. Прошу прощения. Еще вопросы. Как только try-блок завершится, то все локальные
[14:56.640 --> 15:06.880]  переменные будут уничтожены, естественно. Так, еще? Окей. Ну, соответственно, да, как я сказал...
[15:06.880 --> 15:16.560]  А, ну вот, да, тут все нормально, про это я все сказал. Вот, смотрите, а что если у меня из одной
[15:16.560 --> 15:23.120]  функции может вылетать сразу несколько исключений, ну, исключений нескольких типов? Ну, допустим,
[15:23.120 --> 15:28.320]  представьте себе, что я ожидаю, что функция divide может бросать исключения типа int и бросать
[15:28.320 --> 15:34.360]  исключения типа double. Вот, значит, вот в этом принципиально отличие блока оператора throw от
[15:34.360 --> 15:39.320]  оператора return. Return всегда должен содержать объект одного и того же типа. То есть, если я
[15:39.320 --> 15:43.400]  прописал, что возвращаем я значение int, то я могу возвращать только int. Ну, или то, что приводится
[15:43.400 --> 15:52.680]  к int. Оператор throw, вообще говоря, если я написал throw 1, то где-то в другом месте функции я могу
[15:52.680 --> 16:01.480]  написать вполне спокойно throw полтора. То есть, типа бросаемых исключений не обязано совпадать,
[16:01.480 --> 16:06.440]  окей? То есть, из одной и той же функции я могу бросать несколько видов исключений. Ну, вот в частности
[16:06.440 --> 16:12.240]  пример. Допустим, функция divide по какой-то причине может бросать либо исключения типа int,
[16:12.240 --> 16:17.200]  либо исключения типа double. Вот, соответственно, чтобы корректно обработать ситуацию, я могу
[16:17.200 --> 16:22.320]  написать несколько блоков catch. То есть, я могу написать отдельный catch-блок для int и отдельный
[16:22.320 --> 16:29.680]  catch-блок для double. В этом случае, если у меня будет брошенное исключение типа int, то я попаду в
[16:29.680 --> 16:34.280]  catch-блок, который соответствует int, и на экране появится int. Если у меня исключение будет типа
[16:34.280 --> 16:40.960]  double, то я попаду в блок catch, который относится к double и, соответственно, выполнится оператор,
[16:40.960 --> 16:44.280]  который находится внутри этого catch-блока. Опять же, если какой-то из catch-блоков отработал,
[16:44.280 --> 16:50.440]  то программа корректно продолжит работу за последним catch-блоком, который был перечислен, окей? То
[16:50.440 --> 16:57.120]  есть, catch может выбирать по типу исключения, который был выбран. Ну, естественно, логичный
[16:57.120 --> 17:02.080]  вопрос заключается в том, что а что произойдет, если я вдруг бросил исключение, но при этом ни одного
[17:02.080 --> 17:06.080]  catch-блока не соответствует? Ну, тут, я думаю, очевидно, что произойдет. В этом случае будет
[17:06.080 --> 17:09.640]  считаться, что исключение не будет обработано. То есть, исключение обработано будет, в общем,
[17:09.640 --> 17:14.320]  все будет работать точно так, как если бы вы вообще тройблока не написали. То есть, если бы я в своей
[17:14.320 --> 17:22.280]  программе, точнее, функция devite, написал бы еще какую-нибудь строчку, не знаю, true, true имеет тип
[17:22.280 --> 17:29.960]  bool, поэтому он не подходит ни под int, ни по double, и, соответственно, исключение не будет обработано.
[17:29.960 --> 17:45.440]  Все нормально, смотрите, если вы написали, если вы написали true 1 или 2, то 1 и 2 это тип int, то есть
[17:45.440 --> 17:50.680]  и 1 и 2 попадут в catch-блок, связанный с int. То есть, как бы тут важен тип, смотрите, тут есть тип,
[17:50.680 --> 17:57.720]  и плюс есть еще переменная, давайте назад вернемся, и плюс есть еще переменная, в которую сохраняется
[17:57.720 --> 18:02.680]  значение исключения. То есть, вот что 1, что 2 попадут в блок int, но при этом в переменную r будет
[18:02.680 --> 18:12.040]  сохранено значение либо 1, либо 2. Нет, а, ну, в смысле, можно, ну, в смысле, вы можете написать так,
[18:12.040 --> 18:21.400]  вы можете написать catch int r, вот, и допустим, по какой-то причине вы ненавидите цифру 2, вот,
[18:21.400 --> 18:29.680]  ну, вы можете написать, что если r равно 2, да, то снова написать throw. Ну, типа throw, ну,
[18:29.680 --> 18:35.320]  давайте напишем throw 1, ну, просто throw, вот. Короче, из китча тоже можно бросать исключение,
[18:35.320 --> 18:40.400]  в этом случае, ну, тоже будет считаться, что данная функция завершится аварийно и полетит исключение
[18:40.400 --> 18:54.200]  дальше. Да, как понять, из какой функции вылетело? Ну, смотрите, короткий ответ, никак?
[18:54.200 --> 19:07.440]  Короче, смотрите, если у вас есть несколько функций, давайте так, у вас есть try, допустим,
[19:07.440 --> 19:17.040]  функция f, функция g, вот, и, допустим, и функция f, и функция g бросают исключение типа int, вот.
[19:17.040 --> 19:21.280]  Можно ли как-то понять, из какой функции вылетело исключение? Ну, по самому исключению понять
[19:21.280 --> 19:25.760]  нельзя, вот, ну, то есть, как бы int, он и в Африке int, да, то есть, не важно, там, int брошен из f,
[19:25.760 --> 19:30.720]  из g, то есть, как бы int останется int. Вот, можно узнать двумя способами, то есть, либо сделать так,
[19:30.720 --> 19:35.680]  чтобы функция f, функция g бросала разные значения int, ну, либо, действительно, бросала pr, чтобы,
[19:35.680 --> 19:40.840]  может, было понять, в какой функции, либо воспользоваться специальным, в общем, есть специальный класс,
[19:40.840 --> 19:55.360]  так-так-так-так, как он называется? std traceback, что ли? В общем, есть специальный объект traceback,
[19:55.360 --> 19:58.800]  который позволяет узнать, соответственно, последовательность вызовов, которая привела
[19:58.800 --> 20:03.600]  к исключению, вот. Соответственно, в исключении можно сохранить вот эту информацию, и тогда вот
[20:03.600 --> 20:07.040]  будет полная информация, какая последовательность вызовов функции привела к тому, что исключение было
[20:07.040 --> 20:22.920]  брошено. Не помню, то есть traceback, то ли backtrace. Нужно будет посмотреть. Окей? Окей. Так, ну да,
[20:22.920 --> 20:28.400]  как я уже сказал, если ни одного кетчблока не подходит, то, ну, исключение считается непойманным.
[20:28.400 --> 20:35.760]  Дальше. Во, да, хороший слайд, смотрите. Вообще говоря, смотрите, вот тут у меня, давайте вот на этот
[20:35.760 --> 20:40.600]  пример посмотрим, вот у меня есть тут блок trie, ну, допустим, позываю какую-то функцию f, вот, и у меня
[20:40.600 --> 20:48.080]  блок trie ловит либо int, либо double, вот. И я сказал, что если я бросаю true, то true имеет type bool, да, ну,
[20:48.080 --> 20:52.400]  и, соответственно, он не будет пойманным ни одним кетчблоком. Ну, тут могло возникнуть следующее
[20:52.400 --> 20:59.240]  сомнение. Ну, погодите. Смотрите, мы же знаем, что в C++ существует неявное переобразование типов, да, ну,
[20:59.240 --> 21:03.520]  например, bool спокойно может приводиться к int, int спокойно может приводиться к bool, double к int,
[21:03.520 --> 21:10.800]  int w и так далее. Вот. Почему бы здесь не сказать, что, ну, смотрите, раз у меня тут true, bool, да, и bool
[21:10.800 --> 21:16.400]  осуществляет неявное, как это называется, promotion к int, то, ну, казалось бы, bool должен выбрать int
[21:16.400 --> 21:22.640]  и, соответственно, отработать этот кетчблок. Вот. Значит, важно, что важно отметить, так это то, что блок
[21:22.640 --> 21:30.320]  catch выбирается не согласно правилам перегрузки. Вот правила выбора для блока кетча, ну, к счастью,
[21:30.320 --> 21:36.320]  очень просты. Значит, блок catch выбирается строго по точному соответствию. Вот, если бросается тип
[21:36.320 --> 21:41.920]  A, то ищется кетчблок, который соответствует строгу типа A. Вот. Если тип A может быть переобразован
[21:41.920 --> 21:47.040]  к типу B, то блок, который относится к типу B, выбран не будет. Кетчблок выбирается строго по
[21:47.040 --> 21:51.840]  точному соответствию. Вот, в частности, я пишу try divide, то есть пытаюсь вызвать функцию divide,
[21:51.840 --> 21:55.920]  вызываю функцию divide, divide бросает int, и, соответственно, я принимаю unsigned int и char.
[21:55.920 --> 22:00.920]  Несмотря на то, что int может быть переобразован как в unsigned int, так и в char, ни одним блоком он
[22:00.920 --> 22:05.400]  пойман не будет. Просто потому, что кетчблок выбирается строго по точному соответствию. Окей?
[22:05.400 --> 22:11.680]  Константность. Не учитывая константность. То есть, если вы ловите constant, то это то же
[22:11.680 --> 22:16.920]  самое, что и int. Вот. Ну и по ссылке то же самое. Можете поймать по int ссылке,
[22:16.920 --> 22:35.800]  и так далее, то же будет int. Окей? Да. Да. Да, да, это правильно. Потому что вот этот row вы
[22:35.800 --> 22:44.160]  написали не внутри tryblock, вы написали внутри, короче, вы написали его вне tryblock. Да, собственно,
[22:44.640 --> 22:48.680]  я говорю, что нужно завершить вот эту функцию, вот эту функцию нужно целиком завершить и передать
[22:48.680 --> 22:56.000]  управление другой функции. Ну, как то, которая вызывала, ну, допустим, вот это я пишу функцию f,
[22:56.000 --> 23:04.440]  вот. А функцию f вызывала функцию g. Ну, вот есть функция g, которая вызывает функцию f. Вот.
[23:04.440 --> 23:10.120]  Соответственно, если функция f находится в tryblock, то вот этот tryblock будет обрабатывать уже вот это
[23:10.120 --> 23:18.400]  исключение. Окей? То есть, ну, естественно, смотрите, давайте так. Вот тут сверху написан try,
[23:18.400 --> 23:25.480]  и вот этот row написан вне tryblock. Поэтому, естественно, он обрабатывать его не будет,
[23:26.320 --> 23:45.520]  ну все. Давай, до свидания. Типа, функцию завершаем, выходим туда. Вот. Да, да, да. То есть,
[23:45.520 --> 23:50.680]  ну, точно так же, как с f. Да, то есть, если я внутри вложеного f'а напишу else, он будет
[23:50.680 --> 23:54.480]  относиться только к нему. То есть, да, я могу строить иерархию try'ов. Я могу написать try,
[23:54.480 --> 24:10.720]  там не знаю, потом try. Там что-то, что-то. Catch, допустим, a. Вот. И тут catch b. Вот. А вот этот
[24:10.720 --> 24:21.640]  catch относится к вот этому try? А вот этот try относится к вот этому catch? То во внешне он не попадет,
[24:21.640 --> 24:29.120]  да. Да, да. Вот. То есть, ну, правило просто, ну, правило простое. Вот я нахожусь тут, я смотрю
[24:29.120 --> 24:32.880]  самый ближайший tryblock, это вот этот. Вот. Дальше смотрю, смогу ли я обработать ему еще эти
[24:32.880 --> 24:36.680]  catch'и. Нет, не могу, поэтому исключение вот из этого блока вылетает наружу. Но что значит
[24:36.680 --> 24:40.360]  наружу? Вот во внешний tryblock. Вот этот tryblock пытается обработать исключение. Смотрю вот эти
[24:40.360 --> 24:45.920]  catch'и. Если это не отработали, то снова вылетаю наружу. Значит, если tryblock и нет, соответственно,
[24:45.920 --> 25:01.520]  то я вылетаю вообще из функции. Ну и так далее. Так, еще вопросы? Хорошо. Так. Да, вот я сказал,
[25:01.520 --> 25:14.120]  что, я сказал, что, да, можно. Если там не будет второго try, то как это будет? В смысле, если внешнего не будет,
[25:14.120 --> 25:19.640]  если вот этого try не будет, то, ну, будет работать как один try. То есть, если тут исключение, то есть,
[25:19.640 --> 25:22.640]  если вот это исключение не обрабатывается вот этим catch'ем блоком, то исключение просто
[25:22.640 --> 25:30.520]  вылетает из функции. То есть, tryblock нужно для того, чтобы погасить, не буду произвести слово, из ГТА.
[25:30.520 --> 25:38.640]  В общем, если tryblock не смог обработать исключение, то значит, что это исключение вылетает из функции
[25:38.640 --> 25:51.840]  ровно так, как мы показывали на первых слайдах. Вот, да. Сейчас не совсем понимаю, ну, как бы, давайте так,
[25:51.840 --> 25:59.480]  давайте такой пример. Блок try, внутри блока try я вызываю функцию f. Вот. Ну, допустим, функция, ну,
[25:59.480 --> 26:06.680]  то есть, я предполагаю, что функция f может бросить исключение, пишу catch, допустим int. Вот. Допустим,
[26:06.680 --> 26:10.440]  для обработки этого исключения мне нужно вызвать какую-то другую функцию. Ну, допустим, я вызываю тут g.
[26:10.440 --> 26:16.000]  Но, в свою очередь, я понимаю, что функция g тоже может брать исключение. Вот. Что я могу сделать?
[26:16.000 --> 26:28.920]  Я могу тут внутри catch'а тоже написать try функция g, catch какой-то тип, и так далее. Вот. Ну,
[26:28.920 --> 26:31.760]  тогда вот этот try catch' блок будет относиться только к тому, что написано вот тут.
[26:31.760 --> 27:00.520]  Не, не, не. То есть, просто написать catch дальше try нельзя. Вот. Только так. То есть, catch имеет
[27:00.520 --> 27:04.680]  вот такой синдексис. Идут фигурные скобки, а дальше последователь операторов. Вот. В свою очередь,
[27:04.680 --> 27:12.120]  это последователь операторов может быть обернут в свой блок try. Ну, короче, это прям синдекс
[27:12.120 --> 27:29.320]  sketch. Без фигурных скобок написать нельзя. Да. Да, ну да, да, да. Вполне. Вот можно, ну, то есть,
[27:29.320 --> 27:34.000]  можно написать try f, дальше catch int. И дальше, ну, короче, если у вас есть две функции,
[27:34.000 --> 27:39.760]  которые возвращают, которые бросают в станциали один тот же тип, то, да, можно написать try f,
[27:39.760 --> 27:54.360]  catch int. Там что-то. И потом снова написать try g, catch int. Ну, да, вы можете try блок
[27:54.360 --> 27:59.400]  на несколько try блоков. Все нормально. Тут будет try catch отвечать за это, вот это try catch block за это.
[27:59.400 --> 28:11.680]  Так, еще вопросы. Окей. Так, значит, несколько минут назад я сказал про то, что catch блок
[28:11.680 --> 28:19.560]  выбирается согласно абсолютно точному соответствию. Вот. Из этого правила есть буквально пара
[28:19.560 --> 28:25.040]  исключений. Значит, первое исключение, да, первое исключение из этого правила заключается в том,
[28:25.040 --> 28:35.280]  что если вы ловите, то есть, если вы пытаетесь поймать void указатель, то с помощью void указателя
[28:35.280 --> 28:43.360]  вы можете поймать вообще абсолютно произвольный указатель. То есть, если вы где-то выше написали,
[28:43.360 --> 28:49.920]  точнее, пункт написали, там, не знаю, throw, там, адрес x, ну, где x это int, то void с отрездой
[28:49.920 --> 28:54.360]  поймает этот указатель. То есть, void с отрездой ловит вообще произвольный указатель. Окей. То есть, если в
[28:54.360 --> 28:58.560]  качестве исключения, в качестве типа исключения у вас летит указатель, то void с отрездой его
[28:58.560 --> 29:04.800]  поймает в любом случае. Окей. Это первое исключение. Второе исключение из этого правила заключается в
[29:04.800 --> 29:13.400]  наследовании. Если у вас есть класс A, от которого унаследован класс B, ну, естественно, публичным образом,
[29:13.400 --> 29:29.040]  вот, то, такой пример, если вы напишете throw B, ловить будете A, то с помощью объекта типа A
[29:29.040 --> 29:37.920]  вы сможете поймать B. Окей. То есть, с помощью указания, с помощью, в общем, с помощью класса родителя
[29:37.920 --> 29:44.840]  можно ловить классы наследников. Почему? Потому что если B публично наследовал от A, то B является A, да.
[29:44.840 --> 29:49.360]  Ну и по принципу установки Барбар Лиска везде, где можно поставить A, там же можно поставить B.
[29:49.360 --> 29:54.800]  Соответственно, если catch ловит объекты типа A, то он значит, он ловит и объекты типа B. Окей. Да.
[29:54.800 --> 30:03.520]  Да, и к ссылкам и указателями тоже относятся. То есть, я, например, могу поймать A по ссылке,
[30:03.520 --> 30:17.400]  соответственно, эта ссылка может поймать и объект типа B. Окей. Хорошо. Так. Теперь,
[30:17.400 --> 30:23.720]  про выбор блока try. Смотрите, среди того, что я сказал ранее, теперь может возникнуть следующая
[30:23.720 --> 30:29.320]  ситуация. Теперь может возникнуть такая ситуация, при которой у меня одному и тому же исключению может
[30:29.320 --> 30:34.280]  соответствовать сразу несколько блоков catch. Ну, например, вот я нахожусь в функции f и, значит, в try
[30:34.280 --> 30:38.840]  блоке пишу throw adress x. Значит, в блоке try можно писать throw, но это будет считаться, что исключение
[30:38.840 --> 30:42.440]  возникло в блоке try, и, соответственно, оно будет обработано в соответствующем блоке catch. Вот. Я пишу
[30:42.440 --> 30:48.560]  try throw adress x. Ну, adress x имеет тип int со звездой, да. После него идут catch void со звездой и catch int
[30:48.560 --> 30:52.800]  со звездой. То есть, с одной стороны подходит int со звездой, с другой стороны подходит void со звездой,
[30:52.800 --> 30:57.480]  потому что void со звездой может поймать произвольный указатель. Какой блок catch будет выбран? Так вот,
[30:57.480 --> 31:01.800]  значит, еще одно отличие блока catch от выбора перегрузки заключается в том, что блок catch выбирается
[31:01.800 --> 31:08.480]  не по самому точному соответствию, если подходит несколько, а выбирается самый первый подходящий. То
[31:08.480 --> 31:12.760]  есть, блоки catch проверяются последовательно друг за другом. То есть, грубо говоря, я тут бросил исключение
[31:12.760 --> 31:17.200]  типа int со звездой, дальше проверяю, подходит ли блок catch void со звездой. Да, блок catch void со звездой
[31:17.200 --> 31:24.600]  подходит, поэтому он будет обработан вот в этом catch-блоке. Окей? Вот, значит, второй пример. Вот у меня
[31:24.600 --> 31:29.640]  есть класс B, который публичным образом наследован от класса A. Вот, я пишу функцию F, в которой
[31:29.640 --> 31:35.840]  бросаю исключение B. Пишу try throw B. Вот, соответственно, есть два catch-блока, catch A, catch B. Значит, объект типа B
[31:35.840 --> 31:39.880]  подходит под оба catch-блока, и под catch A, и под catch B. Почему? Потому что B точное соответствие
[31:39.880 --> 31:45.360]  типов, а потому что B публичным образом наследован от A. Вот. Но при этом, так как catch-блоки расположены вот
[31:45.360 --> 31:49.960]  в таком порядке, у меня всегда будет всегда будет срабатывать только первый catch-блок. То есть, второй
[31:49.960 --> 31:54.160]  блок тут, по сути, бесполезен. Потому что если я брошу исключение типа A, то будет отрабатывать блок
[31:54.160 --> 31:59.280]  catch A. Если я буду брошать исключение типа B, то будет отрабатывать тоже блок catch A. До catch B никогда
[31:59.280 --> 32:05.040]  дело не дойдет. Окей? То есть, об этом стоит помнить. То есть, как бы catch-блок выбирается не по самому
[32:05.040 --> 32:11.040]  точному соответствию, если подходит несколько, а выбирается самый первый подходящий catch-блок. Вот.
[32:11.040 --> 32:19.720]  Да. Ну, соответственно, тут замечание про то, что если я, соответственно, если я ловлю исключение по
[32:19.720 --> 32:26.800]  значению, вот как тут catch A, catch B, catch int, и так далее, то когда я ловлю исключение по значению,
[32:26.800 --> 32:32.720]  то, значит, вот этот объект исключения, который сгенерирован компилятором, он будет копироваться
[32:32.720 --> 32:40.000]  вот в данную переменную. Вот. Тут я создал переменную int. Вот. И вот это исключение, оно будет скопировано
[32:40.000 --> 32:45.160]  вот в эту переменную. Чтобы избежать лишних копирований, стоит ловить исключение по... То есть, стоит
[32:45.160 --> 32:48.800]  рассмотреть возможность, ловлю ли исключение по ссылке. Ну, например, я, допустим, я по какой-то причине
[32:48.800 --> 32:54.040]  хочу бросить в качестве исключения вектор из миллиона элементов. Ну, типа вот кирпич на голову летит, вот
[32:54.040 --> 32:58.160]  тебе вектор. Вот. Соответственно, catch может этот вектор поймать, но если я буду вектор ловить по значению,
[32:58.160 --> 33:03.520]  то тогда при ловле исключения у меня вектор будет полностью скопирован. Вот. Чтобы избежать копирования
[33:03.520 --> 33:07.880]  большого вектора, ну, потенциально, да, я тут могу исключение принять по константной ссылке, и тогда эта
[33:07.880 --> 33:12.440]  ссылка будет ссылаться вот на тот самый объект исключения, который был ранее сгенерирован. Никакой копии
[33:12.440 --> 33:22.840]  происходить не будет. Окей? Ну, это классический способ оптимизации копирования. Вот. Окей. Так, ну и,
[33:22.840 --> 33:29.720]  кажется, последний пункт, который связан с синтаксисом, состоит в том, что существует особая форма catch.
[33:29.720 --> 33:36.680]  Catch с многоточием. Ну, смотрите, чего это нужно. Вот, представь себе, что у меня есть какая-то функция f,
[33:36.680 --> 33:43.560]  ну, которая потенциально может бросить исключения. Вот. При этом она может бросить исключения, ну,
[33:43.560 --> 33:49.320]  либо разных типов, типа int, типа double, типа float, типа vector и так далее и так далее. Но при этом
[33:49.320 --> 33:54.160]  обработка всех этих видов исключения, она работает абсолютно одинаково. Ну, например,
[33:54.160 --> 33:58.160]  какое бы исключение не бросило f, мне всегда нужно просто напечатать сообщение на экране,
[33:58.160 --> 34:02.920]  что произошла ошибка. Вот. Соответственно, к чему это приведет? Ну, это приведет к тому,
[34:02.920 --> 34:09.200]  что мне нужно будет написать там catch, int, написать там cout что-то что-то, а потом написать catch,
[34:09.200 --> 34:17.840]  double, вот, написать что-то что-то, ну и так далее. Ну, как бы, понятное дело, что это дублирование
[34:17.840 --> 34:22.560]  кода, ну и плюс вот эти блоки catch, они вообще, говоря, никак не добавляют читаемости кода. Да,
[34:22.560 --> 34:26.480]  потому что если в каждом catch блоке нужно сделать одно и то же, то ну как бы зачем писать сразу
[34:26.480 --> 34:32.760]  несколько catch? Так вот, поэтому в C++ существует способ поймать вообще произвольные исключения.
[34:32.760 --> 34:38.560]  Чтобы сказать, что мне не важно какое исключение я ловлю, главное, чтобы исключение было поймано,
[34:38.560 --> 34:48.080]  можно написать catch многоточие. Вот. Catch многоточие ловит абсолютно произвольные исключения. То есть,
[34:48.080 --> 34:52.400]  какое бы исключение не было брошено в функции f, catch многоточие его поймает и обработает.
[34:52.400 --> 34:57.000]  Соответственно, точнее, выполнится то, что написано внутри блока catch. Вот. В чем преимущество?
[34:57.000 --> 35:00.600]  Ну, преимущество в том, что я могу единообразно обработать вообще произвольные исключения,
[35:00.600 --> 35:04.640]  не выдавая из деталей какого типа оно было брошено. Вот. Плохая новость заключается в том,
[35:04.640 --> 35:10.480]  что если я написал catch многоточие, то у меня нет доступа к самому объекту исключения. Вот.
[35:10.480 --> 35:15.000]  Ну, точнее, нет переменной, в которую, нет переменной, в которую я могу обратиться. Вот. Ну, на самом деле,
[35:15.000 --> 35:20.840]  давайте так, на самом деле можно, вот, там, какими-то, в общем, окольными способами, там, по-моему, есть
[35:20.840 --> 35:28.640]  все плюс-плюс. Опять же, стандартная функция, блин, как она, типа current exception, ну, или типа
[35:28.640 --> 35:33.280]  active exception, очень можно в документации посмотреть. Но, так или иначе, вот такого простого способа
[35:33.280 --> 35:39.680]  к объекту исключения с помощью объекта получить не получится. Вот. То есть, если хочется поймать
[35:39.680 --> 35:44.280]  произвольные исключения, ну, или в целом, в целом, обработка исключения не зависит от его вида,
[35:44.280 --> 35:51.600]  не зависит от его типа, то можно воспользоваться catch многоточием. Да. Авто, кстати, хороший вопрос,
[35:51.600 --> 35:58.880]  ну, наверное, нет все-таки. Наверное, все-таки нет. Ну, потому что, нет, нет, точно нет. Потому что
[35:58.880 --> 36:03.320]  авто, ну, потому что авто — это концепция этап компиляции. Ну, на этапе компиляции мы же не
[36:03.320 --> 36:07.120]  знаем, что у нас может пойти не так. Вот. То есть, как бы, представьте, у вас есть функция, которая
[36:07.120 --> 36:11.000]  может бросить исключение как типа int, так и типа double. Вот. Если вы написали речь, которая принимает
[36:11.000 --> 36:15.760]  double, ну, тогда вы, по сути, говорите, что, ну, типа компилятор на этапе компиляции способен понять,
[36:15.760 --> 36:21.320]  а какой тип исключения пойдет в этот catch. Ну, естественно, исключение — это концепция
[36:21.320 --> 36:25.520]  рантайма, концепция времени исполнения, поэтому автор разрешен на этапе компиляции быть не может.
[36:25.520 --> 36:35.200]  Вот. Так. Есть ли вопросы? Да.
[36:35.920 --> 36:36.280]  — Да.
[36:37.080 --> 36:43.000]  — Если тип не может копироваться, то, ну, стандартная история, то есть, если тип не может
[36:43.000 --> 36:46.200]  быть копирован, то... а, тут у вас, нет, у вас тогда просто возник ошибка компиляции.
[36:46.240 --> 36:51.120]  Потому что, компилятор, если, ну, смотрите, тут все хорошо. Ну, то есть, как бы, как бы, не будь там
[36:51.120 --> 36:55.520]  ошибки в ошибке. Понимаете, если у вас есть, то есть, если у вас есть какой-то catch-блок
[36:55.520 --> 36:58.560]  и вы написали вот так. Но при этом тип А не может быть скопирован,
[36:58.600 --> 37:02.600]  то компилятор, ну, он это заметит. Ну, то есть, компилятор же понимает, что если отработает этот
[37:02.600 --> 37:06.600]  Компилятор же понимает, что если отработать этот блок кэч, ему нужно будет вызвать копирование и так далее.
[37:06.600 --> 37:09.600]  Но компилятор понимает, что если ему нужно будет вызвать копирование, то он это сделать не сможет.
[37:09.600 --> 37:14.600]  Поэтому выдаст вам ошибку, что типа вы ловите по значению тип, который нельзя скопировать.
[37:14.600 --> 37:16.600]  Ошибка империации просто будет.
[37:16.600 --> 37:21.600]  Когда он даст?
[37:21.600 --> 37:25.600]  Ну, кстати, по этому поводу надо узнать.
[37:25.600 --> 37:29.600]  Скорее всего, да, скорее всего исключение будет храниться на хипе.
[37:29.600 --> 37:32.600]  Ну да, скорее всего на хипе.
[37:32.600 --> 37:34.600]  Хотя я в этом не уверен, может и на стеке.
[37:34.600 --> 37:37.600]  Надо посмотреть, я не буду врать.
[37:43.600 --> 37:45.600]  Да, обычно так и делают.
[37:45.600 --> 37:52.600]  Я обычно обрабатываю какие-то специфические исключения, кэч-инт, кэч-дабл.
[37:52.600 --> 37:57.600]  А потом в самом конце пишу кэч-многоточие.
[37:57.600 --> 37:59.600]  Но идут правила абсолютно такое же, как и в прошлый раз.
[37:59.600 --> 38:02.600]  То есть отрабатывают первый подходящий кэч.
[38:02.600 --> 38:04.600]  То есть сначала проверяется кэч-инт.
[38:04.600 --> 38:06.600]  Инт не подходит, подхожу кэч-дабл, не подходит.
[38:06.600 --> 38:08.600]  Перехожу в кэч-многоточие, он все ловит.
[38:08.600 --> 38:13.600]  И поэтому, допустим, если я напишу кэч-многоточие в самом начале,
[38:13.600 --> 38:15.600]  то, естественно, во всех остальных кэчах никого смысла не будет.
[38:15.600 --> 38:18.600]  Потому что кэч-многоточие все поймает, и остальные ничего не достанется.
[38:23.600 --> 38:26.600]  Есть ли еще вопросы?
[38:26.600 --> 38:28.600]  Ну, давайте тогда сделаем перерыв.
[38:29.600 --> 38:31.600]  Где шаблоны?
[38:45.600 --> 38:47.600]  Да, я понял.
[38:50.600 --> 38:53.600]  Вопрос, видимо, про это.
[38:53.600 --> 38:55.600]  Если у меня есть какая-то шаблонная функция,
[38:55.600 --> 38:57.600]  класс T,
[38:57.600 --> 39:00.600]  не знаю, там void F от T,
[39:00.600 --> 39:03.600]  вот, это F вызывает какую-то функцию G.
[39:03.600 --> 39:05.600]  Я пишу try,
[39:05.600 --> 39:07.600]  вот, я могу написать
[39:07.600 --> 39:09.600]  кэч TX.
[39:09.600 --> 39:11.600]  Параметр шаблона я могу использовать в кэче,
[39:11.600 --> 39:13.600]  потому что после того, как функция будет приинстанцирована,
[39:13.600 --> 39:15.600]  вместо типа T подставляется конкретный тип,
[39:15.600 --> 39:17.600]  тут будет стоять конкретный тип.
[39:17.600 --> 39:19.600]  То есть тут проблем нет.
[39:19.600 --> 39:21.600]  Давай теперь предметно поговорим про то,
[39:21.600 --> 39:23.600]  зачем вам
[39:23.600 --> 39:25.600]  или вообще кому-либо
[39:25.600 --> 39:27.600]  может прийти в голову написать
[39:27.600 --> 39:29.600]  try-catch-блок.
[39:29.600 --> 39:31.600]  До этого мы рассмотрели какие-то игрушечные примеры,
[39:31.600 --> 39:33.600]  когда говорили о том, что
[39:33.600 --> 39:35.600]  если в функции возникло исключение,
[39:35.600 --> 39:37.600]  то давайте обернем в этот самый блок try,
[39:37.600 --> 39:39.600]  а в кэч-блоке просто напечатаем.
[39:39.600 --> 39:41.600]  Произошла ошибка.
[39:41.600 --> 39:43.600]  Спасибо, Кэп, понятно.
[39:43.600 --> 39:45.600]  Для чего все-таки,
[39:45.600 --> 39:47.600]  с какой практической целью можно использовать try-catch-блок?
[39:47.600 --> 39:49.600]  Давайте посмотрим на следующий
[39:49.600 --> 39:51.600]  очень простой пример.
[39:51.600 --> 39:53.600]  Представьте, что у меня есть функция f,
[39:53.600 --> 39:55.600]  и функция f внутри себя выделяет
[39:55.600 --> 39:57.600]  динамическую память.
[39:57.600 --> 39:59.600]  А дальше я потенциально вызываю
[39:59.600 --> 40:01.600]  опасную функцию g.
[40:01.600 --> 40:03.600]  Давайте я сначала
[40:03.600 --> 40:05.600]  напишу функцию f
[40:05.600 --> 40:07.600]  без обработки ошибок.
[40:07.600 --> 40:09.600]  Представьте, что у меня тут
[40:09.600 --> 40:11.600]  есть на авто
[40:11.600 --> 40:13.600]  ptr равно
[40:13.600 --> 40:15.600]  newint.
[40:15.600 --> 40:17.600]  Здесь я вызываю функцию g,
[40:17.600 --> 40:19.600]  и дальше
[40:19.600 --> 40:21.600]  что-то делаю, и в конце, естественно,
[40:21.600 --> 40:23.600]  не забываю делать delete.
[40:23.600 --> 40:25.600]  Казалось бы, прекрасная функция.
[40:25.600 --> 40:27.600]  Она вначале выделяет память,
[40:27.600 --> 40:29.600]  дальше использует функцию g,
[40:29.600 --> 40:31.600]  ну, допустим, туда передает ptr,
[40:31.600 --> 40:33.600]  как-то работает, и в конце выделяет delete,
[40:33.600 --> 40:35.600]  то есть освобождает память.
[40:35.600 --> 40:37.600]  Все прекрасно, утечек не должно быть и так далее.
[40:37.600 --> 40:39.600]  Но теперь мы понимаем, что у нас
[40:39.600 --> 40:41.600]  в принципе в теории может возникнуть ситуация,
[40:41.600 --> 40:43.600]  при которой функция g завершится неуспешно.
[40:43.600 --> 40:45.600]  То есть из функции g вылетит исключение.
[40:45.600 --> 40:47.600]  Это произойдет, если из функции g вылетит исключение,
[40:47.600 --> 40:49.600]  но при этом мы его не обработаем.
[40:49.600 --> 40:51.600]  Сработает функция f,
[40:51.600 --> 40:53.600]  функция f выделяет динамическую память,
[40:53.600 --> 40:55.600]  дальше начнет работать функция g,
[40:55.600 --> 40:57.600]  функция g завершится неуспешно, и из нее вылетит исключение.
[40:57.600 --> 40:59.600]  Но так как мы функцию f исключения не обрабатываем,
[40:59.600 --> 41:01.600]  что произойдет?
[41:01.600 --> 41:03.600]  Ну, переменная ptr просто-напросто исчезнет,
[41:03.600 --> 41:05.600]  но delete-то, естественно, никто не вызовет,
[41:05.600 --> 41:07.600]  ну, компилятор за нас delete вызывать не будет.
[41:07.600 --> 41:09.600]  Это не его забота.
[41:09.600 --> 41:11.600]  То есть из функции g вылетает исключение,
[41:11.600 --> 41:13.600]  ну, дальше, допустим, где-то снаружи,
[41:13.600 --> 41:15.600]  ну, допустим, есть функция main,
[41:15.600 --> 41:17.600]  функция main,
[41:17.600 --> 41:19.600]  функции main я написал try f,
[41:19.600 --> 41:21.600]  тут его как-то обработал,
[41:21.600 --> 41:23.600]  вот, и как ни в чем не бывало,
[41:23.600 --> 41:25.600]  продолжил работу.
[41:25.600 --> 41:27.600]  Что произошло?
[41:27.600 --> 41:29.600]  Окей, ошибки вроде как нет,
[41:29.600 --> 41:31.600]  ну, то есть main сделала все, чтобы ошибки не допустить, да?
[41:31.600 --> 41:33.600]  Main сделала все, чтобы программа продолжила корректную работу.
[41:33.600 --> 41:35.600]  Программа корректно продолжила работу,
[41:35.600 --> 41:37.600]  но вот эту память у нее уже никто не вернет.
[41:37.600 --> 41:39.600]  Она бесследно утекла.
[41:39.600 --> 41:41.600]  Понятно?
[41:41.600 --> 41:43.600]  Поэтому что нужно сделать?
[41:43.600 --> 41:45.600]  Необходимо, ну, то есть так как мы понимаем,
[41:45.600 --> 41:47.600]  что функция g потенциально опасная,
[41:47.600 --> 41:49.600]  нам нужно перед тем, как, ну, нам нужно обработать эту ошибку,
[41:49.600 --> 41:51.600]  и перед тем, как ошибку пробросить дальше,
[41:51.600 --> 41:53.600]  да, то есть прежде чем сказать, что
[41:53.600 --> 41:55.600]  пусть ошибка летит дальше,
[41:55.600 --> 41:57.600]  перед этим мне нужно очистить ту память, которую я выдел до этого.
[41:57.600 --> 41:59.600]  Давайте посмотрим, как нужно было бы
[41:59.600 --> 42:01.600]  справиться с этой проблемой.
[42:01.600 --> 42:03.600]  Вот у меня есть функция f, я выделяю динамическую память,
[42:03.600 --> 42:05.600]  ptr равно new int,
[42:05.600 --> 42:07.600]  дальше в блоке try вызываю функцию g.
[42:07.600 --> 42:09.600]  Почему в блоке try? Потому что я понимаю, что g потенциально может привести к проблемам.
[42:09.600 --> 42:11.600]  Вызываю в блоке try функцию g,
[42:11.600 --> 42:13.600]  g бросает исключение,
[42:13.600 --> 42:15.600]  я его принимаю в блоке catch,
[42:15.600 --> 42:17.600]  делаю delete ptr,
[42:17.600 --> 42:19.600]  и, соответственно,
[42:19.600 --> 42:21.600]  ну, допустим, ptr равно new ptr, да, то есть говорю, что
[42:21.600 --> 42:23.600]  все, после того, как исключение возникло,
[42:23.600 --> 42:25.600]  этим указать им нельзя пользоваться, я его за нуляю
[42:25.600 --> 42:27.600]  и иду дальше, допустим.
[42:27.600 --> 42:29.600]  Вот, соответственно,
[42:29.600 --> 42:31.600]  то, каким образом можно использовать блок catch.
[42:31.600 --> 42:33.600]  Окей?
[42:33.600 --> 42:35.600]  Вот.
[42:35.600 --> 42:37.600]  Хорошо.
[42:37.600 --> 42:39.600]  Другой вопрос.
[42:39.600 --> 42:41.600]  Опять же, по этому коду.
[42:41.600 --> 42:43.600]  Вот этот код, на самом деле, несколько странный.
[42:43.600 --> 42:45.600]  Почему? Потому что, ну, смотрите,
[42:45.600 --> 42:47.600]  если функция g завершилась неуспешно,
[42:47.600 --> 42:49.600]  если функция g завершилась неуспешно,
[42:49.600 --> 42:51.600]  то, вообще говоря, кажется, что продолжать функцию f
[42:51.600 --> 42:53.600]  не имеет смысла.
[42:53.600 --> 42:55.600]  На самом деле, чего бы мне хотелось?
[42:55.600 --> 42:57.600]  Мне бы хотелось поймать исключение, которое летит
[42:57.600 --> 42:59.600]  из функции g,
[42:59.600 --> 43:01.600]  сделать там все дела по очистке, допустим,
[43:01.600 --> 43:03.600]  ну, очистить это само указать ptr,
[43:03.600 --> 43:05.600]  а потом сказать, что вот это исключение я поймал,
[43:05.600 --> 43:07.600]  но пусть летит дальше, да?
[43:07.600 --> 43:09.600]  И, на самом деле, это сделать можно
[43:09.600 --> 43:11.600]  например, вот так.
[43:11.600 --> 43:13.600]  Вот. То есть, более правильно,
[43:13.600 --> 43:15.600]  наверное, было бы поступить вот так.
[43:15.600 --> 43:17.600]  То есть, я вызываю, то есть,
[43:17.600 --> 43:19.600]  try блок, я вызываю функцию g, ловлю его
[43:19.600 --> 43:21.600]  в блоке catch, в блоке catch удаляю
[43:21.600 --> 43:23.600]  нужный мне указатель, а дальше говорю, что
[43:23.600 --> 43:25.600]  ну все, я все необходимые действия перед завершением
[43:25.600 --> 43:27.600]  функции сделал, теперь исключение пусть
[43:27.600 --> 43:29.600]  летит дальше. То есть, снова пишу throw a.
[43:29.600 --> 43:31.600]  Вот. То есть, я как бы говорю, что давай бросим то же самое
[43:31.600 --> 43:33.600]  исключение, пусть оно летит дальше.
[43:33.600 --> 43:35.600]  Вот.
[43:35.600 --> 43:37.600]  Понятно, что мы хотели сделать.
[43:37.600 --> 43:39.600]  Вот.
[43:39.600 --> 43:41.600]  Но, какие тут есть проблемы?
[43:41.600 --> 43:43.600]  Проблемы тут две.
[43:43.600 --> 43:45.600]  Первая проблема заключается в следующем.
[43:45.600 --> 43:47.600]  Смотрите. Когда я пишу throw a,
[43:47.600 --> 43:49.600]  когда я пишу throw a,
[43:49.600 --> 43:51.600]  вот это вот throw a, как мы говорили,
[43:51.600 --> 43:53.600]  создаст новое исключение.
[43:53.600 --> 43:55.600]  Вы смотрите, у меня где-то
[43:55.600 --> 43:57.600]  в этом особом месте
[43:57.600 --> 43:59.600]  в памяти хранится исключение
[43:59.600 --> 44:01.600]  типа a. Вот.
[44:01.600 --> 44:03.600]  Когда я поймал это исключение по ссылке,
[44:03.600 --> 44:05.600]  ну, я, по сути, в переменную a
[44:05.600 --> 44:07.600]  давайте так, в переменную a,
[44:07.600 --> 44:09.600]  сохранил ссылку на вот это самое исключение.
[44:09.600 --> 44:11.600]  А дальше, когда снова пишу throw a,
[44:11.600 --> 44:13.600]  что происходит? Ну, throw a обязан
[44:13.600 --> 44:15.600]  создать новое исключение. И тогда он
[44:15.600 --> 44:17.600]  в этом месте программы, вот в этом месте
[44:17.600 --> 44:19.600]  создает объект с помощью копирования самого себя.
[44:19.600 --> 44:21.600]  То есть, по сути, я выполняю там лишние действия.
[44:21.600 --> 44:23.600]  То есть, создаю новый объект
[44:23.600 --> 44:25.600]  путем его копирования. Вот.
[44:25.600 --> 44:27.600]  А что если я бросал вектор? То есть, что если я взял
[44:27.600 --> 44:29.600]  и бросил вектор большой длины? В этом случае
[44:29.600 --> 44:31.600]  я бы создал еще одну копию вектора, который бы бросил дальше.
[44:31.600 --> 44:33.600]  Ну, вообще говоря, согласитесь, было бы
[44:33.600 --> 44:35.600]  довольно-таки разумно
[44:35.600 --> 44:37.600]  не создавать новое исключение, то есть, не пересадовать новое исключение,
[44:37.600 --> 44:39.600]  а бросать то самое исключение, которое
[44:39.600 --> 44:41.600]  летело изначально. Да?
[44:41.600 --> 44:43.600]  Ну как? Потрать от единицы времени, сказать, что вот исключение
[44:43.600 --> 44:45.600]  там уже лежит, пусть оно уже летит дальше.
[44:45.600 --> 44:47.600]  Вот. Это первая проблема. Вторая проблема
[44:47.600 --> 44:49.600]  заключается в следующем. Смотрите, давайте мысленно,
[44:49.600 --> 44:51.600]  мысленно вот здесь,
[44:53.600 --> 44:55.600]  вот здесь,
[44:55.600 --> 44:57.600]  подставим кетч в ноготочке.
[44:57.600 --> 44:59.600]  Ну, действительно, смотрите, допустим, я говорю, что
[44:59.600 --> 45:01.600]  мне не важно, что вылетело из функции g,
[45:01.600 --> 45:03.600]  вот если функция g как-то аварийно завершилась,
[45:03.600 --> 45:05.600]  если из нее вылетело какое-то исключение,
[45:05.600 --> 45:07.600]  то в любом случае я должен удалить указатель
[45:07.600 --> 45:09.600]  и перебросить исключение дальше.
[45:09.600 --> 45:11.600]  Но вот в чем проблема.
[45:11.600 --> 45:13.600]  Если я пишу кетч многоточия,
[45:15.600 --> 45:17.600]  если я пишу кетч многоточия, то
[45:17.600 --> 45:19.600]  как я уже говорил, я не могу
[45:19.600 --> 45:21.600]  получить доступа к самому объекту исключения, согласны?
[45:21.600 --> 45:23.600]  Вот.
[45:23.600 --> 45:25.600]  А это означает, что если я хочу сбросить исключение
[45:25.600 --> 45:27.600]  и попить niemand нового avocado там,
[45:27.600 --> 45:29.600]  кто Aussie будет,
[45:29.600 --> 45:31.600]  то я не не знаю,
[45:31.600 --> 45:33.600]  что мне написать вот тут, но у меня же нет переменной,
[45:33.600 --> 45:35.600]  которая хранится в исключении, и что написать вот тут, я не знаю.
[45:37.600 --> 45:39.600]  То есть две проблемы,
[45:39.600 --> 45:41.600]  первое, если я пишу throw Representative Qi,
[45:41.600 --> 45:43.600]  если с такой конфигурации, я напишу throw A,
[45:43.600 --> 45:45.600]  то будет создано копирование, точно, будет создано копия
[45:45.600 --> 45:47.600]  с Bakupenkkuchy в исключении. А вторая проблема,
[45:47.600 --> 45:49.600]  если бы я там написал вместо a многоточия,
[45:49.600 --> 45:51.600]  я бы не смог написать throw A,
[45:51.600 --> 45:53.600]  потому что у меня, по сути, нет переменной,
[45:53.600 --> 46:04.080]  Понятна проблема? Что делать? Вот специально для этого случая есть специальная форма оператора throw,
[46:04.080 --> 46:14.200]  который не принимает аргументов. Просто throw. запятой. Что означает оператор throw без аргументов?
[46:14.200 --> 46:19.600]  Оператор throw без аргументов означает брось исключения заново. То есть как бы есть текущие
[46:19.600 --> 46:25.680]  исключения, которые мы сейчас обрабатываем. И вот брось его заново. То есть throw без аргументов
[46:25.680 --> 46:30.600]  имеет смысл писать только внутри кетчблока. То есть если вы находитесь внутри кетчблока,
[46:30.600 --> 46:35.040]  это означает, что вы обрабатываете сейчас какое-то исключение. И если вы хотите это же исключение
[46:35.040 --> 46:39.800]  пробросить дальше, то сказать, что я все сделал на этой моей полномочии, все, дальше не могу ничего
[46:39.800 --> 46:45.280]  обработать, пусть это исключение летит дальше, то вы можете написать просто throw, и тогда у вас
[46:45.280 --> 46:51.040]  будет брошено ровно это же самое исключение, без создания копии. Более того, даже если вы напишете
[46:51.040 --> 46:55.240]  кетчблоготочие, то есть если у вас нет доступа напрямую к исходному исключению, вы можете все
[46:55.240 --> 46:59.040]  равно написать throw, и тогда будет брошено ровно то же самое исключение, без создания его копии и так
[46:59.040 --> 47:11.680]  далее. Понятно? Смотрите еще раз. В чем пример? Вот у меня есть функция f. Внутри функции f я
[47:11.680 --> 47:15.800]  выделяю динамическую память и дальше вызываю потенциально опасную функцию g. Если функция g
[47:15.800 --> 47:21.120]  завершилась неуспешно, ну вот представьте, что функция g завершилась неуспешно, и в этом случае я
[47:21.120 --> 47:25.000]  не знаю, что мне дальше делать. Но в этом случае я говорю, что функция f тогда тоже должна варьерно
[47:25.000 --> 47:29.360]  завершиться. Ну какие у меня есть варианты? Первый вариант, ну просто не писать throw кетчблок,
[47:29.360 --> 47:33.760]  тогда если я вызову функцию g, вот как здесь, просто после исключения вылетит наружу, функция f завершится.
[47:33.760 --> 47:41.120]  Но если функция f завершится досрочно, вот тут, то я не смогу вызвать delete. Поэтому, чтобы вызвать
[47:41.120 --> 47:46.160]  delete перед тем, как функция f завершится, я пишу try кетчблок. То есть я пишу try g, дальше ловлю
[47:46.160 --> 47:49.720]  произвольное исключение, мне плевать какое там исключение, мне главное его поймать. Я ловлю
[47:49.720 --> 47:53.520]  исключение, и дальше говорю, что я очищаю память, которую я ранее выделил, а дальше говорю, ну все, пусть
[47:53.520 --> 47:58.280]  исключение летит дальше. То есть я перехватываю исключение только для того, чтобы выполнить
[47:58.280 --> 48:04.200]  очистку памяти в текущей функции. А дальше говорю, что ну все, как бы ошибка все еще есть, я эту ошибку кидаю дальше.
[48:04.200 --> 48:25.080]  Смотрите, я могу на какой-то переменной обратиться. То есть, допустим, я написал try f, catch int. Ну то есть я могу не писать имя переменной, тогда, ну просто,
[48:25.080 --> 48:30.480]  я говорю, что я ловлю исключение типа int. Но если я напишу имя переменной, допустим int r, то тогда,
[48:30.480 --> 48:39.120]  я, допустим, могу написать stdout r. Ну и тогда я выведу значение вот этой самой исключения. Вот, например,
[48:39.120 --> 48:44.480]  для этого, чтобы узнать, чему оно равно. То есть не только какого оно типа, но и чему равно его значение.
[48:44.480 --> 48:59.040]  Так, еще вопросы? Да. Да, давайте разберем. Давайте вот на этом примере.
[48:59.040 --> 49:07.040]  Значит, вопрос был такой. Вот если я поймал исключение,
[49:07.040 --> 49:17.200]  и дальше написал r равно 2, и дальше снова throw. Что произойдет? Ну то есть, допустим, тут изначально летело исключение 1.
[49:17.200 --> 49:25.360]  Что произойдет? Опять ничего, потому что вот этот r является копией вот этого значения. То есть вот этот r,
[49:25.360 --> 49:28.360]  это отдельная переменная, которая не как-то связана с этим. Но когда вы пишете r равно 2,
[49:28.360 --> 49:32.760]  вы изменили вот эту локальную переменную. Вот тут по-прежнему осталось единица, поэтому будет
[49:32.760 --> 49:40.720]  лететь дальше единица. Но если вы напишете int&r, и дальше r равно 2, тогда вот эта вот ссылка
[49:40.720 --> 49:44.920]  будет ссылаться на вот этот исходный объект исключения. Если напишете r равно 2, то вот это
[49:44.920 --> 49:52.040]  исключение изменится, и по сути у вас дальше будет лететь исключение равное 2. То есть если вы хотите
[49:52.040 --> 49:56.840]  иметь возможность их менять, исключение, которое в данный момент находится в программе, то принимаем
[49:56.840 --> 50:01.400]  по ссылке. А если вы принимаете по значению, то это просто будет копия того же самого исключения
[50:01.400 --> 50:13.720]  здесь.
[50:13.720 --> 50:20.480]  Да, ну потому что, смотрите, потому что, ну, не знаю, допустим, вот вы просто так вот, вы пишете
[50:20.480 --> 50:27.560]  программу и тут, о, напишу kind of throw. Что это означает? Как бы исключения нет, но вы навели суету,
[50:27.560 --> 50:31.560]  ну, типа, все нормально, вы говорите, давайте бросим исключение, которого нет. Ну, как бы,
[50:31.560 --> 50:39.160]  короче, исключения есть только вот в блоке catch, по сути. То есть когда вы находитесь в блоке catch,
[50:39.160 --> 50:42.760]  вы обрабатываете какое-то исключение, и в нем оно гарантированно есть, поэтому в этом случае
[50:42.760 --> 50:51.360]  вы можете написать throw. А просто так написать throw без аргументов, ну, нельзя. Да. Нет, она вызывает
[50:51.360 --> 50:56.800]  функцию terminate, вот. Ну, а terminate там, я не помню, что она называет, в общем, terminate просто
[50:56.800 --> 51:04.680]  завершает программу. Возможно, кстати, abort тоже вызывает. Ну, можем, но зачем? Ну, то есть,
[51:04.680 --> 51:11.560]  мы в любой момент можем вызвать terminate. Вот. Ну, тут мы про другое говорим, про то, как, ну, все-таки
[51:11.560 --> 51:16.800]  продолжить нормальные течения программы без аварийного ее завершения. Вот. Ну, вообще, как бы
[51:16.800 --> 51:21.520]  аварийно завершить программу можно в любой момент, либо с помощью там terminate, exit, abort и так далее.
[51:21.520 --> 51:35.160]  Так. Еще вопросы? Окей. Так. Вот. Значит, в контексте того, что я сказал до этого,
[51:35.160 --> 51:41.360]  еще более остро встает вопрос про рай. Ну, я надеюсь, вы не забыли четыре буквы,
[51:41.360 --> 51:46.520]  которые означают resource acquisition и centralization. Смотрите, вот мы с вами говорили про то,
[51:46.520 --> 51:53.120]  что вот идиом рай, она позволяет нам писать более безопасный код, при этом не задумываясь на тем,
[51:53.120 --> 51:58.520]  чтобы там освобождать вовремя память, освобождать вовремя мютексы и так далее и так далее. Вот.
[51:58.520 --> 52:01.240]  То есть, например, если мы используем SD-вектор, то вообще говоря, мы не задумываясь на тем,
[52:01.240 --> 52:05.760]  как устроены динамические массивы, то есть new-derit нам не нужны. Если мы используем unique-ptr,
[52:05.760 --> 52:11.840]  то тоже new-derit нам не нужны. Вот. Значит, в контексте разговора про исключения эти классы становятся
[52:11.840 --> 52:15.600]  еще более актуальными. Почему? Значит, еще раз обратим внимание вот на тот пример, который был
[52:15.600 --> 52:23.520]  в течение нескольких слайдов. Смотрите, если я использую сырую память, то мне необходимо
[52:23.520 --> 52:29.520]  помнить о том, что потенциально каждая функция может бросить исключение, а если функция может
[52:29.520 --> 52:37.480]  бросить исключение, то, соответственно, у меня память утечет потенциально. Но если бы я вместо
[52:37.480 --> 52:42.560]  сырых указателей, вместо динамической памяти использовал бы встроенные методы, типа unique-ptr
[52:42.560 --> 52:48.640]  или std-вектор, то смотрите, что бы получилось. Я бы написал... Смотрите, вот что произошло бы,
[52:48.640 --> 53:02.160]  если бы я тут вместо обычного указателя написал unique-ptr. Ну, допустим, auto p равно makeunique int
[53:02.160 --> 53:08.800]  что-то там. Вот. Тут бы вызвал функцию g. Вот. И delete мне тут писать не нужно. Смотрите,
[53:08.800 --> 53:13.880]  если я использую makeunique, то вообще говоря, мне не нужно делать никаких приколов strike edge.
[53:13.880 --> 53:21.040]  Почему? Потому что если g вылетит какое-то исключение, то что произойдет? Функция g вызовет
[53:21.040 --> 53:26.360]  исключение. Это исключение я тут не обрабатываю. Это означает, что функция просто завершается. А что
[53:26.360 --> 53:33.080]  происходит при завершении функции? Да, при завершении функции сработают деструкторы всех
[53:33.080 --> 53:41.560]  переменных. Ну а деструктора unique-ptr что сделает? Очистит динамическую память. Понятно? Вот. То есть
[53:41.560 --> 53:45.680]  идея в чем? Если я использую стандартные классы, которые работают, которые управляют ресурсами,
[53:45.680 --> 53:51.080]  то и заботиться об отчечении в strike edge блоке мне тоже не приходится. То есть, например, код,
[53:51.080 --> 53:56.960]  который написан выше, то есть абсолютно аналогичный код будет получен, если я просто-напросто обычный
[53:56.960 --> 54:00.920]  указатель, который получен с помощью new, заменю на указатель, который получен с помощью unique-ptr.
[54:00.920 --> 54:16.040]  Вот. Окей? Вот. То есть, мораль? Активно используйте рай-классы типа vector, unique-ptr,
[54:16.040 --> 54:26.520]  sharp-ptr, ну и так далее. Вот. Есть ли вопросы? Нет. Ну да, в общем, давайте поясню. Во многих языках
[54:26.520 --> 54:34.040]  программирования, во многих языках программирования есть исключения. Есть аналоги
[54:34.040 --> 54:38.720]  strike-edge блоков. И во многих языках программирования, помимо ключевых слов типа strike-edge,
[54:38.720 --> 54:42.680]  есть еще блок final, который выполняется в любом случае. То есть блок final, который выполняется
[54:42.680 --> 54:46.080]  в случае, если исключение произошло или исключение не произошло. Все плюсы такого блока нет.
[54:46.080 --> 54:55.800]  Окей. Давайте пойдем дальше и поговорим про статическую спецификацию исключений.
[54:55.800 --> 55:02.040]  Смотрите, вот. Вообще говоря, ситуация стала довольно-таки печальная. Почему? Потому что,
[55:02.040 --> 55:05.920]  ну вот, до этого мы не знали исключения, но и на самом ли горе не знали. То есть как бы мы
[55:05.920 --> 55:10.040]  программировали и думали, что, ну вот, как бы все функции завершаются успешно, все прекрасно,
[55:10.040 --> 55:13.960]  в общем, никаких обработок исключения делать не нужно и так далее. Сейчас же я привел вас
[55:13.960 --> 55:17.720]  за руку в мир полный ужасов, в котором каждая функция может сбросить исключения, в каждой
[55:17.720 --> 55:21.080]  функции может пойти что-то не так. Соответственно, для каждой функции, скорее всего, нужно вызывать,
[55:21.080 --> 55:26.360]  нужно делать try, очищать память, следить, вызвали мы new, если мы вызвали new,
[55:26.360 --> 55:31.000]  после этого вызываем другие функции, нужно убедиться, что эти пункты не образуются
[55:31.000 --> 55:34.840]  исключений и, соответственно, что мы, если вдруг исключение возникло, освободим память и так далее.
[55:34.840 --> 55:39.160]  Ужас, кошмар, что делать? Вот. Как жить в мире, когда каждая функция потенциально может сбросить
[55:39.160 --> 55:44.920]  исключения? Ну, давайте я немного смягчу пилилю и расскажу про статическую спецификацию исключений.
[55:44.920 --> 55:50.400]  То есть как сказать, что функция, в принципе, безопасная? Вообще говоря, не все функции опасные.
[55:50.400 --> 55:57.200]  Главное, в общем, правильными им пользоваться и правильно обращать внимание на те функции,
[55:57.200 --> 56:03.440]  которые потенциально опасны или потенциально безопасны. Смотрите, чтобы подсказать компилятору,
[56:03.440 --> 56:08.880]  ну или чтобы подсказать читающему ваш код, что функция безопасная, ну безопасная в том смысле,
[56:08.880 --> 56:12.560]  что она не бросает исключений, в том, что она там все делает корректно, она никогда не завершается
[56:12.560 --> 56:17.600]  неуспешно. Вот. Значит, для этих целей существует ключевое слово noexcept. Значит, к любой функции,
[56:17.600 --> 56:23.360]  после ее прототипа вы можете приписать слово noexcept, и это будет означать, что, собственно,
[56:23.360 --> 56:27.800]  эта функция не бросает исключений. Ну или, более того, это является обещанием для компилятора,
[56:27.800 --> 56:34.640]  что эта функция исключений не бросает. Соответственно, к чему это приводит? Это не приводит к тому,
[56:34.640 --> 56:42.560]  что, как бы, к сожалению, не знаю почему, но если вы в функции, которая является noexcept, будете
[56:42.560 --> 56:46.520]  вызывать опасные функции или будете писать операторы throw, компилятор на это ругаться не будет.
[56:46.520 --> 56:50.640]  Ну, точнее, он, наверное, скажет что-то типа warning, что типа, ну, погоди, ты же сказал,
[56:50.640 --> 56:54.960]  что noexcept, но вообще там делает throw, но как бы компилирует программу не откажется. Вот. Но
[56:54.960 --> 57:01.000]  что произойдет? Если вы вдруг попытаетесь нарушить свое обещание и функции, которые пометили noexcept,
[57:01.000 --> 57:05.800]  бросите исключения, вот в этот момент программа просто возьмет и завершится автоматически. Вот.
[57:05.800 --> 57:12.200]  То есть функция noexcept говорит следующее, что функция либо ничего не бросает, либо если бросает,
[57:12.200 --> 57:15.960]  то все-таки рдыка совсем. Все, вот никак нельзя эту ситуацию разрешить. В общем,
[57:15.960 --> 57:20.160]  если вы нарушили свое обещание и бросаете что-то из noexcept функции, то программа завершается без
[57:20.160 --> 57:28.480]  возможности ее, как бы, нормального продолжения работы. Окей? Вот. Поэтому слою noexcept оно,
[57:28.480 --> 57:35.200]  оно железное. Вот. То есть оно либо, то есть она либо не бросает ничего, либо бросает,
[57:35.200 --> 57:40.320]  но от этого всем плохо. Вот. Окей? Вот. Поэтому вы можете обращать внимание на те функции,
[57:40.320 --> 57:44.800]  которые помещены noexcept. Если вы видите, что функция помещена noexcept, то в принципе обрабатывать,
[57:44.800 --> 57:48.680]  обрабатывать ее ошибку не имеет смысла. Почему? Потому что, ну, она либо не бросает ошибок,
[57:48.680 --> 57:53.560]  либо если она бросает ошибку, то обработать эту ошибку не получится никак. Вот. Поэтому noexcept
[57:53.560 --> 58:00.080]  функции — это те функции, которые не требуют никаких обработок, никаких трай-кэтчблоков. Вот. Окей? Да.
[58:00.080 --> 58:15.880]  Да. Можно мы про это, кажется, мы про это поговорим, я не помню сегодня или на какой-то
[58:15.880 --> 58:19.280]  лекции, но вообще давайте скажу сейчас. В общем, если у вас есть какая-то функция, вы хотите проверить,
[58:19.280 --> 58:25.800]  является она noexcept или нет, то есть специальная операция noexcept? Да, кажется, у меня на слайдах это есть,
[58:25.800 --> 58:32.880]  давайте поясню. Чтобы проверить, является ли функция noexcept или нет, я могу написать вот так,
[58:32.880 --> 58:41.480]  noexcept от f. Noexcept от f возвращает true, если функция является noexcept и false, если функция
[58:41.480 --> 58:49.440]  не помещена как noexcept. Окей? Вот. Специальная операция noexcept. Вот. То есть еще раз повторю,
[58:49.440 --> 59:04.640]  noexcept — это такое, ну, не знаю, слово пацана, исключение на стеке. Вот. Окей? Да. Смотрите, то, что
[59:04.640 --> 59:09.720]  функция noexcept не означает, что внутри этой функции не могут возникать ошибки. То есть, естественно,
[59:09.720 --> 59:14.720]  если функция noexcept, то внутри нее могут потенциально возникать ошибки, самое главное, чтобы эти ошибки
[59:14.720 --> 59:19.680]  не покидали эту функцию. То есть, вот этот код вполне себе нормальный. То есть, если я пишу функцию f,
[59:19.680 --> 59:24.280]  которая является noexcept, внутри нее вызываю функцию g, и при этом потенциальные ошибки функции g гашу
[59:24.280 --> 59:31.960]  сразу же внутри функции f, то все окей. Самое главное, чтобы ошибки не покидали саму функцию f. Окей? Нормально?
[59:31.960 --> 59:42.640]  Вот. Дальше. А теперь, да, значит, про noexcept все есть. Значит, смотрите, у noexcept, у ключевого
[59:42.640 --> 59:46.760]  слова noexcept есть три смысла. Значит, первым смыслом мы познакомились, и это спецификатор.
[59:46.760 --> 59:57.360]  Спецификатор. Значит, спецификатор, который говорит том, является ли функция безопасной или нет. Вот.
[59:57.360 --> 01:00:01.760]  Значит, второй смысл ключевого слова noexcept — это условный спецификатор. Про него на слайде.
[01:00:01.760 --> 01:00:12.240]  Условный спецификатор. Смотрите, вообще говоря, в общем случае, когда вы пишете либо какую-то
[01:00:12.240 --> 01:00:17.720]  функцию, либо, на самом деле, еще более часто, когда пишете какую-то шаблонную функцию, вы, на самом
[01:00:17.720 --> 01:00:22.360]  деле, не всегда можете понять, действительно ли все операции, которые вы используете внутри шаблонной
[01:00:22.360 --> 01:00:26.600]  функции, безопасны или нет. Ну, самый яркий пример — это, например, функция, которая выполняет
[01:00:26.600 --> 01:00:30.880]  сложение. Например, если я выполняю сложение целых чисел, то, вообще говоря, исключение в этом
[01:00:30.880 --> 01:00:34.480]  случае никогда происходить не будет. То есть сложение целых чисел никогда не переводит к исключительной
[01:00:34.480 --> 01:00:39.200]  ситуации. А если я, допустим, складываю две строки, то уже непонятно, потому что сложение двух
[01:00:39.200 --> 01:00:42.440]  строк приводит к тому, что я выделяю динамическую память, а выделение динамической памяти в теории
[01:00:42.440 --> 01:00:46.320]  может привести к тому, что у меня закончится память, соответственно, исключение. Поэтому сложение двух
[01:00:46.320 --> 01:00:51.600]  строк не является безопасным, то есть не является noexcept по сравнению с сложением двух целых чисел.
[01:00:51.600 --> 01:00:59.360]  Вот. Поэтому в языке plus plus был введен так называемый условный спецификатор noexcept. Смотрите,
[01:00:59.360 --> 01:01:04.280]  помимо того, что я могу писать слово noexcept, вот, например, voidf noexcept, я могу еще написать voidf
[01:01:04.280 --> 01:01:10.320]  noexcept true. Вот noexcept true это то же самое, что просто noexcept. То есть noexcept, внутри которого
[01:01:10.320 --> 01:01:16.760]  написано буллевское выражение true или false, означает, что функция либо является noexcept, либо
[01:01:16.760 --> 01:01:20.760]  не является noexcept. Или, например, если я напишу voidje, это по сути то же самое, как если бы я написал
[01:01:20.760 --> 01:01:25.440]  voidje noexcept false. Ну, понятное дело, что писать noexcept true или noexcept false не имеет смысла,
[01:01:25.440 --> 01:01:29.400]  потому что noexcept true можно заменить на noexcept, а noexcept false можно заменить на
[01:01:29.400 --> 01:01:34.160]  отсутствие noexcept. Вот. Более осмысленное следующее применение. Ну вот, представь себе, что у меня
[01:01:34.160 --> 01:01:41.240]  есть шаблонная функция h, которая, ну, по какой-то причине, может теоретически бросить исключение,
[01:01:41.240 --> 01:01:45.160]  если у меня size of t больше единицы, и ни в коем случае не может бросить исключение, если у меня size of t
[01:01:45.160 --> 01:01:51.040]  равен единице. Вот. Ну, какая-то вот такая функция. Вот. Что я могу тогда написать? Я могу написать
[01:01:51.040 --> 01:01:56.520]  noexcept и в скобках size of t больше единицы. В этом случае, если у меня шаблонная функция h будет
[01:01:56.520 --> 01:02:02.680]  инстанцирована с типом t, размер которого больше единицы, у меня функция будет noexcept. Вот. Если у меня
[01:02:02.680 --> 01:02:07.720]  h будет инстанцирован с помощью типа t, у которого размер равен единице, то в этом случае функция не
[01:02:07.720 --> 01:02:14.320]  будет noexcept. Окей? То есть, условный спецификатор позволяет в зависимости от того или иного условия,
[01:02:14.320 --> 01:02:19.440]  ну, который, естественно, проверяется на этапе компиляции, пометить функцию как noexcept либо
[01:02:19.440 --> 01:02:28.520]  как не noexcept. Вот. Ну и, наконец, операция noexcept. Кстати, в том примере я ошибся, там вот тут
[01:02:28.520 --> 01:02:39.240]  были правильные синксис. Операция. Ну, операция просто. Значит, операция noexcept. Да, вопрос.
[01:02:39.240 --> 01:02:59.520]  Нормально. Не-не-не. Вот давайте сейчас про это поговорю и дальше приведу примеры. Смотрите,
[01:02:59.520 --> 01:03:04.280]  значит, вот мы познакомились с тем, что noexcept может быть спецификатором, может быть условным
[01:03:04.280 --> 01:03:10.440]  спецификатором, и еще noexcept, еще ключевое слово noexcept отвечает за операцию. Значит, операция
[01:03:10.440 --> 01:03:16.600]  noexcept принимает на вход некоторое выражение, но при этом его не вычисляет, а лишь его анализирует
[01:03:16.600 --> 01:03:23.080]  на предмет того, является ли оно noexcept или нет. Ну, как sizeof, например. Например, если я напишу
[01:03:23.080 --> 01:03:32.840]  sizeof uint, ну, я надеюсь, все помнят, что вот эта вот строчка не приведет к тому, что у меня будет
[01:03:32.840 --> 01:03:38.720]  выделено память, да. Потому что sizeof, он лишь анализирует это выражение, то есть он его не
[01:03:38.720 --> 01:03:44.360]  вызывает, он анализирует это выражение и говорит не то, а какого размера будет результат вот этого
[01:03:44.360 --> 01:03:48.680]  new. Ну, результатом вызова new является указатель, указатель как раз занимает 8 байт, поэтому вот
[01:03:48.680 --> 01:03:54.280]  это sizeof будет равен 8. То есть sizeof, оператор, он не вычисляет это выражение, он лишь его
[01:03:54.280 --> 01:03:59.920]  анализирует. Вот точно так же поступает и операция noexcept. Noexcept лишь анализирует то, что мы передали
[01:03:59.920 --> 01:04:04.880]  ей в круглые скобки, не вычисляя при этом, и просто выдает мне вердикт. Вот эта штука является
[01:04:04.880 --> 01:04:11.960]  noexcept или вот эта штука не является noexcept. Вот. Так. Ну, вот пример. Вот у меня есть функция f,
[01:04:11.960 --> 01:04:16.920]  которая помещена как noexcept, и есть функция g, которая не помещена как noexcept. Я спрашиваю, верно ли,
[01:04:16.920 --> 01:04:22.800]  что вызов функции f будет noexcept, то есть верно ли, что вызов функции f не бросает исключений. И в
[01:04:22.800 --> 01:04:28.160]  качестве ответа мне вернется true. Вот. Если я спрашиваю, верно ли, что функция g не бросает
[01:04:28.160 --> 01:04:31.520]  исключений, то есть верно ли, что функция g является noexcept, то есть вызов функции g является
[01:04:31.520 --> 01:04:36.080]  noexcept, в этом случае будет возвращен false. Почему? Потому что функция g не помещена как noexcept.
[01:04:36.080 --> 01:04:44.040]  Вот. Еще примеры. Вот я написал вектор, я создал вектор v и дальше пишу noexcept 1 делить на 0. Давайте
[01:04:44.040 --> 01:04:55.000]  про это поговорим. Вот. В некоторых это вводит в шок, но noexcept 1 делить на 0 это true. Почему?
[01:04:55.000 --> 01:05:01.760]  По одной очень простой причине. noexcept лишь проверяет то, может ли данное выражение
[01:05:01.760 --> 01:05:07.640]  бросить исключения. Смотрите, деление int, ну так как int это примитивные типы, ну и плюс,
[01:05:07.640 --> 01:05:11.680]  так как у нас есть совместимость с языком c, работает примитивными типами, никогда не
[01:05:11.680 --> 01:05:16.840]  бросает исключений. То есть деление двух int никогда не приводит к тому, что будет брошено исключения.
[01:05:16.840 --> 01:05:22.680]  Поэтому noexcept на вот такую вот штуку говорит true. То есть вот эта штука безопасна с точки
[01:05:22.680 --> 01:05:26.960]  зрения исключения, в том смысле, что она не будет приводить к выбросу исключения. Вот. Ну при этом
[01:05:26.960 --> 01:05:32.400]  значит никакого undefined behavior тоже нет, потому что, как я уже сказал, операция noexcept, как и
[01:05:32.400 --> 01:05:36.680]  операция sizeof не вычисляет то, что написано в кругу скоб канала, лишь его анализирует. Анализирует,
[01:05:36.680 --> 01:05:41.560]  она анализирует это выражение, видит, что тут стоит int, тут стоит int, то есть определение int на int,
[01:05:41.560 --> 01:05:55.520]  исключения не возникает. Поэтому true. Окей? Нормально? Да. Да, вот если вы пишете noexcept,
[01:05:55.520 --> 01:06:04.000]  ну и даже какое-то выражение, то вот это выражение, оно анализируется на этапе компиляции. То есть оно
[01:06:04.000 --> 01:06:10.120]  никогда не вычисляется, noexcept что-то что-то, оно вычисляется на этапе компиляции. Вот. Так,
[01:06:10.120 --> 01:06:19.400]  вопрос какие-то. Но не исключение. Он может быть ошибкой runtime error, ну типа, не знаю, короче,
[01:06:19.400 --> 01:06:24.280]  это может быть ошибкой операционной системы, это может быть ошибкой процессора, по-моему floating
[01:06:24.280 --> 01:06:31.520]  division и так далее, но это не исключение. Исключение — это вот то, что бросается с помощью throw. Тут нет
[01:06:31.520 --> 01:06:36.640]  throw. Потому что, ну смотрите, работа с int она реализована в языке C, в языке C никаких исключений
[01:06:36.640 --> 01:06:44.720]  нет. Поэтому я точно знаю, что деление int на int не приведет к выбросу исключения. Окей? Так, еще вопросы.
[01:06:44.720 --> 01:06:56.440]  Нет, имя функции проверить нельзя. То есть написать, то есть если вы напишете noexcept просто f,
[01:06:56.440 --> 01:07:04.440]  то это всегда будет true. Почему? Потому что, ну f — это просто имя функции. Ну имя функции,
[01:07:04.440 --> 01:07:08.680]  как выражение, всегда, как бы, никогда не бросается исключение. Потому что, когда вы обращаетесь к
[01:07:08.680 --> 01:07:13.880]  переменной, обращение к переменной всегда безопасно. То есть, по сути, вы тут спрашиваете, а безопасно ли
[01:07:13.880 --> 01:07:19.240]  обратиться к имени f? Да, безопасно. То есть это то же самое, как если вы написали f.zapitoj. Ну просто
[01:07:19.240 --> 01:07:34.040]  написать f.zapitoj можно и абсолютно безопасно. Еще вопросы. Окей. И последняя строчка. Последняя
[01:07:34.040 --> 01:07:41.000]  строчка. А noexcept v.pushback 1 делить на 0. Вот это false по следующей причине. Смотрите. 1 делить на 0.
[01:07:41.000 --> 01:07:47.000]  Что делает операция noexcept? Операция noexcept снова берет вот это все выражение и анализирует его,
[01:07:47.000 --> 01:07:50.640]  например, на предмет того, может ли что-то произойти не так или нет. Значит, как noexcept
[01:07:50.640 --> 01:07:55.880]  анализирует это выражение? Ну он просто пошагово пытается понять, а что тут будет происходить.
[01:07:55.880 --> 01:07:59.960]  Значит, первым делом компилятор понимает, что тут будет происходить деление int на int. Как мы с
[01:07:59.960 --> 01:08:03.480]  вами поняли, деление int на int никогда не приводит к исключению. Окей. В результате деление
[01:08:03.480 --> 01:08:09.400]  int на int получается int. То есть в итоге в pushback будет передан int. Вот. Дальше анализирует, верно ли,
[01:08:09.400 --> 01:08:14.600]  что вызов pushback от int является безопасным. И ответ нет. Почему? Потому что pushback теоретически
[01:08:14.600 --> 01:08:18.760]  может бросить исключение. То есть точнее по следующей причине. Pushback в векторе не помещен
[01:08:18.760 --> 01:08:23.720]  как noexcept. А если pushback в векторе не помещен как noexcept, значит noexcept от этого выражения будет
[01:08:23.720 --> 01:08:38.280]  false. Понятно? Вот. Да. Да. Деление любого int на любой int никогда не бросает исключений.
[01:08:38.280 --> 01:08:47.120]  Так. Ну и вот, собственно, пример, про который я говорил. Смотрите, представьте себе следующую
[01:08:47.120 --> 01:08:53.000]  ситуацию. Вот я пишу шаблонную функцию сам. По сути, вот тут элементы метапрограммирования.
[01:08:53.000 --> 01:08:57.000]  Смотрите, по сути, то есть что я тут хочу. Я хочу написать функцию сам, которая принимает два
[01:08:57.000 --> 01:09:02.760]  произвольных значения и складывает их между собой. Ну, понятное дело, что если бы я не знал,
[01:09:02.760 --> 01:09:09.520]  проключусь слова noexcept, я просто написал там сам const x, const y и return x plus y. Теперь, так как я
[01:09:09.520 --> 01:09:14.200]  знаю, проключусь слова noexcept, я хочу пометить мою функцию либо как noexcept, либо как не noexcept.
[01:09:14.200 --> 01:09:20.320]  Вот. Но при этом я понимаю, что в зависимости от того, какого типа t мне будет передан на вход,
[01:09:20.320 --> 01:09:25.000]  у меня функция будет noexcept, либо не будет noexcept. Ну, собственно, пример я уже приводил.
[01:09:25.000 --> 01:09:30.440]  Если функцию сам передаду два int, то сложение двух int всегда безопасно. Согласны? Вот. Если
[01:09:30.440 --> 01:09:34.080]  функцию сам я передам строчки, то сложение двух строчек уже потенциально может привести к
[01:09:34.080 --> 01:09:37.600]  проблемам. Потому что сложение двух строчек — это потенциальное выделение памяти, а выделение
[01:09:37.600 --> 01:09:45.560]  памяти — это потенциальная ошибка, беда лог, то есть не хватает памяти. Поэтому чтобы компилятор
[01:09:45.560 --> 01:09:50.800]  сам определил, является ли моя функция noexcept или нет, я пишу следующий код. Я пишу noexcept
[01:09:50.800 --> 01:10:00.360]  в круглых скобках noexcept от x и plus y. Все не понимают, что это означает. Давайте разберем поэтапно.
[01:10:00.360 --> 01:10:23.480]  Вот я написал t сам, давайте так, tx, ty, noexcept, x plus y. Давайте разбираться. Значит, как я уже
[01:10:23.480 --> 01:10:29.480]  сказал, у ключевых слов noexcept может быть один из трех разных смыслов. Давайте разберем
[01:10:29.480 --> 01:10:35.440]  каждый смысл. Давайте разберем вот этот noexcept. Каким из этих трех смыслов обладает вот этот
[01:10:35.440 --> 01:10:44.240]  внешний noexcept? Да, условный спецификатор два. То есть это условный спецификатор, то есть он в зависимости
[01:10:44.240 --> 01:10:50.200]  от условия, которые я подал на вход в круглые скобки, будет выставлять noexcept флаг для суммы,
[01:10:50.200 --> 01:10:56.400]  либо не будет выставлять noexcept для суммы. Понятно? То есть в зависимости того, вернет ли вот
[01:10:56.400 --> 01:11:00.480]  эта штука true или false, он либо добавит noexcept к функции sum, либо не добавит noexcept к sum.
[01:11:00.480 --> 01:11:07.840]  Окей, теперь вот это. Какой смысл вот этого слова noexcept? Операция, да, то есть третий смысл. То есть
[01:11:07.840 --> 01:11:15.480]  вот этот внутренний noexcept, он проверяет верно ли, что выражение x plus y безопасно. И вот тут
[01:11:15.480 --> 01:11:20.320]  компилятор за нас проверяет, он за нас смотрит, ага, если x и y это int, то есть если вдруг я функцию
[01:11:20.320 --> 01:11:25.440]  сам передал int, то он смотрит, ага, сложение двух int, сложение двух int, это безопасно, поэтому возвращает
[01:11:25.440 --> 01:11:31.880]  true, и тут мне стоит noexcept true, то есть функция sum будет noexcept. Если же на вход я передал две строки,
[01:11:31.880 --> 01:11:36.680]  то тогда компилятор анализирует, ага, noexcept x plus y, x plus y это две строки, сложение двух строк
[01:11:36.680 --> 01:11:41.000]  не помещено как noexcept, когда вы реализовывали свою строку, вы не помечали, естественно,
[01:11:41.000 --> 01:11:46.440]  оператора сложения как noexcept, операцию сложения как noexcept, поэтому он тут вернет false, и тогда у
[01:11:46.440 --> 01:11:50.960]  меня тут в качестве условного спецификатора будет noexcept false, а noexcept false это отсутствие noexcept.
[01:11:50.960 --> 01:11:56.680]  Все, понятно? То есть таким образом в зависимости от какого-то условия я либо выставляю
[01:11:56.680 --> 01:12:12.080]  flag noexcept, либо не выставляю flag noexcept. Да. Потому что компилятор понимает, ага, смотрите,
[01:12:12.080 --> 01:12:16.160]  вот тут написан прототип функции, если тут написан прототип функции, значит,
[01:12:17.120 --> 01:12:22.640]  последующий с ним слово noexcept может иметь только либо первый, либо второй смысл. То есть компилятор
[01:12:22.640 --> 01:12:28.960]  понимает, что noexcept, который написан после прототипа функций, может иметь один из двух смыслов. Дальше,
[01:12:28.960 --> 01:12:33.840]  он видит, что этот noexcept не одинок, у него есть круглые скобки, значит, это условный
[01:12:33.840 --> 01:12:37.680]  спецификатор. Ну а дальше, когда компилятор заходит в эти круглые скобки, он понимает,
[01:12:37.680 --> 01:12:41.640]  что в эти круглые скобки может быть написано только выражение, но раз это выражение, то ничего кроме
[01:12:41.640 --> 01:12:45.800]  операций там быть не может, потому что выражение это комбинация операций и их аргументов.
[01:12:45.800 --> 01:13:14.600]  Нет, не, погодите, сейчас вы про что? Я не снимаю. Вот вы про то, что если я написал
[01:13:14.600 --> 01:13:27.360]  типа auto, sum, tx, ty, дальше, ну, понятное дело, потому что там noexcept, ну там что-то что-то,
[01:13:27.360 --> 01:13:37.080]  а дальше стрелочка t, да? Вы про это? Нет, тут все нормально, потому что вот этот вот это прототип
[01:13:37.080 --> 01:13:43.680]  функции, точнее, тип функции, ой, ну да, в общем, вот этот прототип функции, после прототипа функции
[01:13:43.680 --> 01:13:52.320]  пишется noexcept, вот, ну а дальше через стрелочку я указываю возвращаемое значение. Да, да, да. Сначала
[01:13:52.320 --> 01:13:56.920]  все, что относится к прототип функции, а потом возвращаемое значение. Так, звонок, давайте посмотрим,
[01:13:56.920 --> 01:14:04.160]  что у нас там осталось. А, ну по сути все, финальный пример. Ага, так, есть вопросы? Так, а не бросающий
[01:14:04.160 --> 01:14:09.040]  new, ну про не бросающий мы с вами поговорили, давайте еще раз повторю, что, значит, как я уже сказал,
[01:14:09.040 --> 01:14:12.760]  new потенциально может брось исключение, подолог, да, то есть, в случае, если вдруг память не хватает
[01:14:12.760 --> 01:14:18.520]  по какой-то причине, то new может завершиться с ошибкой, да, то есть, new может брось исключение
[01:14:18.520 --> 01:14:22.760]  подолог, вот, если вы не хотите, чтобы new бросало исключение, то есть, если вы не хотите париться с
[01:14:22.760 --> 01:14:28.800]  обработкой исключения, то мы пишем new с параметром sdno throw, в этом случае эта версия new будет
[01:14:28.800 --> 01:14:36.640]  возвращать nullptr, если память не удалось выделить, вот, ну, на этом в целом все, ну да, все, спасибо,
[01:14:36.640 --> 01:14:37.440]  до встречи на следующей неделе.
