[00:00.000 --> 00:07.880]  Но, действительно, тема у нас, оказывается, сложная.
[00:07.880 --> 00:12.240]  Но сложная, потому что в прошлый раз мы изучили,
[00:12.240 --> 00:17.800]  как искать мосты, как искать точки сочинения, и что
[00:17.800 --> 00:21.240]  самое страшное – компоненты рёберной и вершинной двусвязности.
[00:21.240 --> 00:26.080]  Вот, да, технология оказалась нетривиальной, но сегодня
[00:26.080 --> 00:28.320]  мы попробуем её ещё и апгрейдить.
[00:28.320 --> 00:34.360]  Но потому что давайте вспомним, как мы искали компоненты
[00:34.360 --> 00:35.360]  рёберной двусвязности.
[00:35.360 --> 00:38.440]  Искали мы их очень просто.
[00:38.440 --> 00:40.480]  Мы запустили ДФС.
[00:40.480 --> 00:44.400]  ДФС привёл нас к тому, что у нас теперь появилось
[00:44.400 --> 00:45.400]  дерево ДФС.
[00:45.400 --> 00:51.680]  У нас есть вот такие рёбра дерева ДФС, а также все остальные.
[00:51.680 --> 00:56.320]  Но самое главное для нас, что выяснилось, что все
[00:56.400 --> 00:59.480]  компоненты рёберной двусвязности, как множество вершин, они
[00:59.480 --> 01:03.560]  образуют какие-то, ну, то, что мы называем, связанные
[01:03.560 --> 01:04.560]  под деревья.
[01:04.560 --> 01:07.640]  Вот, ну, как-то вот так это устроено.
[01:07.640 --> 01:11.160]  Да, я ещё не рисовал там всех рёбер, то есть вот как-то
[01:11.160 --> 01:15.120]  вот так, вот где-то, точно, вот, ну, может быть, как-то
[01:15.120 --> 01:18.120]  вот так и вот так.
[01:18.120 --> 01:19.120]  Вот.
[01:19.120 --> 01:22.640]  И задача у нас сводилась к тому, чтобы научиться
[01:22.720 --> 01:27.240]  понимать, какая вершина является корнем своей компоненты
[01:27.240 --> 01:28.240]  рёберной двусвязности.
[01:28.240 --> 01:30.520]  Помните, было такое, да?
[01:30.520 --> 01:34.480]  То есть, если в это поверить, то, в общем-то, всё, что нам
[01:34.480 --> 01:38.680]  оставалось – это, действительно, добавлять эти вершины в
[01:38.680 --> 01:42.040]  стэк, а потом на выходе из ДФС говорить, если вершина
[01:42.040 --> 01:45.080]  первая в своей компоненте, то давайте из стэка всё
[01:45.080 --> 01:48.160]  до неё включительно достанем.
[01:48.160 --> 01:49.160]  Ой.
[01:49.160 --> 01:52.440]  Вот, было дело, помните?
[01:52.440 --> 01:53.440]  Вот.
[01:53.440 --> 01:54.440]  Что такое?
[01:54.440 --> 01:55.440]  Вот.
[01:55.440 --> 01:56.440]  Соответственно.
[01:56.440 --> 02:04.080]  Вот, ну, в принципе, более того, компоненты вершины
[02:04.080 --> 02:05.480]  двусвязности мы нашли также.
[02:05.480 --> 02:08.840]  Только с той оговоркой, что компонент вершины двусвязности
[02:08.840 --> 02:09.840]  – это множество рёбер.
[02:09.840 --> 02:14.600]  И надо было определять уже в своей компоненте не первую
[02:14.600 --> 02:15.760]  вершину, а первое ребро.
[02:15.760 --> 02:22.360]  Ну вот, значит, сегодня мы попробуем, ну, даже не
[02:22.360 --> 02:26.960]  попробуем, а просто найдём компоненты сильной связности
[02:26.960 --> 02:28.920]  и найдём их внезапно абсолютно тем же методом.
[02:28.920 --> 02:33.320]  Хотя, казалось бы, так, ладно, киловечку мы всё-таки
[02:33.320 --> 02:35.560]  уберём, а то прыгнет ещё.
[02:35.560 --> 02:36.560]  Так.
[02:36.560 --> 02:37.560]  Вот.
[02:37.560 --> 02:42.560]  Значит, давайте вспомним.
[02:42.560 --> 02:45.480]  Потому что, конечно, чем у нас отличаются ДФС в
[02:45.480 --> 02:48.240]  ориентированном графе от ДФС в неориентированном
[02:48.240 --> 02:49.240]  графе.
[02:49.240 --> 02:56.480]  Так, что такое лишние ребра?
[02:56.480 --> 02:57.480]  Да.
[02:57.480 --> 03:00.760]  Потому что мы помним, что какие у нас ребра бывают.
[03:00.760 --> 03:05.560]  У нас теоретически бывают, помимо ребер дерева ДФС,
[03:05.560 --> 03:06.560]  будут обратные ребра.
[03:06.560 --> 03:10.040]  То есть, ребра, которые соединяют предка с потомком.
[03:10.040 --> 03:15.320]  У нас бывают прямые ребра, которые соединяют потомка
[03:15.320 --> 03:16.320]  с предком.
[03:16.320 --> 03:19.240]  Но мы знаем, что в неориентированном графе это одно и то же.
[03:19.240 --> 03:21.960]  Поэтому обычно мы считаем только, что у нас есть обратные
[03:21.960 --> 03:22.960]  ребра.
[03:22.960 --> 03:27.720]  И есть перекрёстные ребра.
[03:27.720 --> 03:28.720]  Так.
[03:28.720 --> 03:34.480]  Да, у нас есть снова перекрёстные ребра, которые не ведут
[03:34.480 --> 03:36.520]  ни в предка, ни в потомка, ни наоборот.
[03:36.520 --> 03:39.160]  Но только маленькая проблема, что в неориентированном
[03:39.160 --> 03:41.320]  графе их не существует.
[03:41.320 --> 03:42.320]  Оказывается.
[03:43.320 --> 03:44.760]  Не будем сейчас передоказывать.
[03:44.760 --> 03:47.960]  Скажем лишь другую проблему.
[03:47.960 --> 03:50.600]  Проблема в том, что в ориентированном графе всё это есть.
[03:50.600 --> 03:57.600]  И более того, обратные ребра и прямые ребра – это уже
[03:57.600 --> 03:58.960]  теперь принципиальная разница.
[03:58.960 --> 04:03.080]  То есть, теперь у нас эти ребра есть.
[04:03.080 --> 04:09.520]  Единственная оговорочка, конечно, что у нас не совсем
[04:09.520 --> 04:11.360]  произвольная ребра.
[04:11.360 --> 04:17.520]  А есть, собственно, какой-нибудь маленький приятный факт,
[04:17.520 --> 04:20.360]  который говорит нам о том, что в перекрёстном ребре
[04:20.360 --> 04:29.880]  УВ оказывается, что тайм-ин от У заведомо больше, чем
[04:29.880 --> 04:32.480]  тайм-ин от В.
[04:32.480 --> 04:40.000]  Для интуиции напоминаю, что ДФС мы обычно запускаем
[04:40.000 --> 04:42.800]  так, что мы как будто всех детей обходим именно в порядке
[04:42.800 --> 04:43.800]  слева-направо.
[04:43.800 --> 04:47.240]  Но это просто кисть обозначения.
[04:47.240 --> 04:52.360]  Итак, ну теперь посмотрим, как же нам искать компоненты
[04:52.360 --> 04:53.360]  сильной связности.
[04:53.360 --> 04:55.760]  Ну, чтобы найти компоненты сильной связности, надо,
[04:55.760 --> 04:58.480]  конечно, узнать, а что это такое вообще?
[04:58.480 --> 05:01.040]  Что такое сильная связность?
[05:01.040 --> 05:06.440]  Да, ну здесь действительно просто, ну давайте уже там
[05:06.440 --> 05:09.880]  формально напишем, что пришло время изучать, что мы говорим,
[05:09.880 --> 05:13.080]  что в ориентированном графе, значит, мы сегодня живём
[05:13.080 --> 05:17.360]  в ориентированном графе, то есть в ориентированном
[05:17.360 --> 05:28.200]  графе говорим, что У, там что вершины У и В сильно связаны,
[05:29.200 --> 05:39.520]  если что, если что, ну да, если, ну или можно по-другому
[05:39.520 --> 05:51.160]  написать, от У до В есть путь и от В до У есть путь.
[05:51.160 --> 05:59.040]  И тут, в чём первые шаги, которые тут надо сделать,
[05:59.040 --> 06:04.520]  становятся лёгкими, потому что первая, конечно, теорема,
[06:04.520 --> 06:07.120]  можно даже её теоремой назвать, хотя по сложности это, конечно,
[06:07.120 --> 06:09.640]  не теорема, но по важности соответственно.
[06:09.640 --> 06:12.760]  Значит, теорема звучит так, что сильная связанность
[06:12.760 --> 06:16.080]  отношений и эквивалентности, то есть такое у нас третий
[06:16.080 --> 06:17.480]  из наших великих лозунгов.
[06:18.000 --> 06:23.040]  Вот, значит, сильная связанность, отношение, эквивалентность.
[06:23.040 --> 06:36.160]  В чём, в отличие от предыдущих случаев, доказательство
[06:36.160 --> 06:38.800]  этого факта практически самоочевидно.
[06:38.800 --> 06:42.520]  Потому что в прошлый раз, да, в прошлый раз мы немножко
[06:42.520 --> 06:46.600]  страдали от транзитивности, но в этот раз транзитивность
[06:46.600 --> 06:47.680]  тоже сама очевидна.
[06:47.680 --> 06:50.280]  Вот, радость, радость.
[06:50.280 --> 06:55.560]  Вот, ну, собственно, халява, в общем, на этом и заканчивается.
[06:55.560 --> 06:58.840]  Ну, значит, и так.
[06:58.840 --> 07:00.920]  Ладно, общая технология, конечно, можно написать и
[07:00.920 --> 07:03.960]  так, потому что как у нас работает общая технология.
[07:03.960 --> 07:08.280]  Давайте так, кодик тут напишем, как он тут выглядит.
[07:08.280 --> 07:14.840]  Значит, пишем void, там, как всегда, dfs от викшины v.
[07:14.840 --> 07:18.200]  Так, ну, давайте вспоминать, что мы должны сделать.
[07:18.200 --> 07:23.520]  Так, ну, во-первых, конечно, покрасить вершину v в серый
[07:23.520 --> 07:31.240]  цвет, который мы называем гордым именем edfs-gray.
[07:31.240 --> 07:35.600]  Ой, надо было рыжим, а, нет, не надо.
[07:35.600 --> 07:37.280]  Так, что мы ещё должны сделать?
[07:37.280 --> 07:42.200]  Конечно, конечно.
[07:42.200 --> 07:54.440]  Да, таймы на v равно, ну, вот, ну, да, current time++, да, current
[07:54.440 --> 07:55.440]  time++.
[07:55.440 --> 08:00.160]  Так, ну, и, конечно, не забыть функцию uptime, которая у нас
[08:00.160 --> 08:02.280]  тоже в каком-то виде будет.
[08:02.280 --> 08:06.640]  Uptime равно, ну, нет.
[08:06.640 --> 08:09.760]  А вот здесь мы живём немножко по-другому.
[08:09.800 --> 08:11.920]  Ну, согласно тому, как мы определяли uptime в прошлый
[08:11.920 --> 08:14.800]  раз, uptime у нас здесь оказался плюс бесконечностью.
[08:14.800 --> 08:18.880]  Ну, потому что, да, напомним, у нас что такое uptime?
[08:18.880 --> 08:22.960]  То есть обычно uptime в неориентированном графе говорилось так.
[08:22.960 --> 08:25.560]  Мы хотим взять вершину, спуститься в какую-то вершину
[08:25.560 --> 08:28.960]  в её поддереве, там, среди выбрития потомка, и из этого
[08:28.960 --> 08:32.960]  потомка подняться вверх по обратному ребру.
[08:33.040 --> 08:40.600]  Нас заинтересовало, в насколько меньше таймы мы таким образом
[08:40.600 --> 08:41.600]  можем попасть.
[08:41.600 --> 08:45.280]  Поэтому, по умолчанию, то есть, оказывается, что
[08:45.280 --> 08:47.920]  если из вашего поддерева не торчат обратных ребер,
[08:47.920 --> 08:50.600]  то тогда у вас это может быть просто плюс бесконечности.
[08:50.600 --> 08:54.120]  Вот, да, ну, да, для наших целей, конечно, можно было
[08:54.120 --> 08:57.800]  и таймы нам инициализировать, но определение у нас было
[08:57.800 --> 08:58.800]  такое.
[08:58.800 --> 09:11.440]  Ну вот, так, значит, uptime сделали, ну, а теперь пришло
[09:11.440 --> 09:12.840]  время побегать по детям.
[09:12.840 --> 09:16.400]  Так, как мы бегаем по детям?
[09:16.400 --> 09:19.240]  Так, как мы называем детей?
[09:19.240 --> 09:22.680]  Нет, как мы называем детей?
[09:22.680 --> 09:26.600]  Так, сейчас, нет, просто, как вы, нет, я их вообще
[09:26.600 --> 09:30.040]  люблю называть, но как бы, как вы в прошлый раз их
[09:30.040 --> 09:31.040]  называли?
[09:31.040 --> 09:32.040]  Чего?
[09:32.040 --> 09:33.040]  Ту?
[09:33.040 --> 09:36.040]  Мы реально их ту называли?
[09:36.040 --> 09:42.240]  Нет, по-моему, нет, главное, кто-то смотрел, потому
[09:42.240 --> 09:44.480]  что, дайте, что меня приятно удивило, как что в предыдущей
[09:44.480 --> 09:46.040]  лекции было 380 просмотров.
[09:46.040 --> 09:52.080]  Сам в шоке, нет, да, весь потоп, причем каждый посмотрел
[09:52.080 --> 09:53.640]  где-то там раз по десять.
[09:53.640 --> 10:04.000]  Ну, мне тоже понравилось, так, а в этом дело, нет,
[10:04.000 --> 10:09.520]  я два или один, нет, я только один, я вот сегодня посмотрел
[10:09.520 --> 10:10.520]  только вот.
[10:10.520 --> 10:17.960]  Так, ладно, поехали, перебираем, ну ладно, давайте, ну ладно,
[10:18.960 --> 10:23.800]  перебираем, так сказать, потенциальных детей, но
[10:23.800 --> 10:24.800]  это еще не дети.
[10:24.800 --> 10:28.360]  Так, ну здесь уже, наверное, придется различать уже
[10:28.360 --> 10:31.680]  все возможные случаи, там прямые ребра, обратные
[10:31.680 --> 10:34.920]  ребра, перекрестные ребра и, конечно, их величество
[10:34.920 --> 10:36.920]  ребра дерева DFS.
[10:36.920 --> 10:37.920]  Чего?
[10:37.920 --> 10:43.280]  Так, вот, кстати, теперь еще одна маленькая приятность,
[10:43.280 --> 10:47.880]  у нас теперь не надо рассматривать ребр в предках.
[10:47.880 --> 10:51.040]  Да, ребра ориентированы, поэтому если ребро ведет
[10:51.040 --> 10:53.440]  в предках, то это не то ребро, к которому мы пришли, его
[10:53.440 --> 10:54.440]  надо отдельно рассмотреть.
[10:54.440 --> 11:02.400]  Да, поэтому, ура, пока все халявно, прям все дорога
[11:02.400 --> 11:05.480]  устилается розами и лилиями.
[11:05.480 --> 11:10.640]  Так, значит, что же у нас, поэтому пишем, ну вот как
[11:10.640 --> 11:15.400]  всегда, ну давайте, ладно, не будем свечки, так, ой,
[11:15.400 --> 11:30.200]  а может, свечки из-за моего, без, ну да, так, так, что
[11:30.200 --> 11:31.200]  напишем?
[11:31.200 --> 11:39.400]  Врасти, о господи, не, ну мы не настолько, это того,
[11:39.400 --> 11:40.400]  да.
[11:41.400 --> 11:47.160]  Ну, да, да, да, когда-нибудь, да, да, да, да, значит, свеч
[11:47.160 --> 11:54.040]  от coloratoo, давайте, coloratoo, значит, пишем, так, ну давайте
[11:54.040 --> 12:02.200]  черноработчий вариант, значит, case edfs white, так, есть у нас
[12:02.200 --> 12:09.280]  цвет белый, то, что мы делаем, так, ну начинаем с того,
[12:09.280 --> 12:13.720]  что dfs, конечно, активно запускается от вершины
[12:13.720 --> 12:18.560]  u, так, конечно же, так, uptime, наверное, надо проапдейтить,
[12:18.560 --> 12:27.960]  так, так, uptime, ну тут мы надеемся, что тоже когда-нибудь
[12:27.960 --> 12:38.280]  в будущем будет оператор min равно, да, uptime от v, uptime
[12:38.280 --> 12:43.000]  от u, радость, так, ой, мы что-то самое главное забыли, мы
[12:43.000 --> 12:54.200]  забыли добавить вершину в stack, это самое важное,
[12:54.200 --> 12:59.480]  значит, смотрите, так, так, uptime вроде про апдейтили,
[12:59.480 --> 13:04.080]  чтобы это не было, и что мы теперь делаем, так, а, ну
[13:04.080 --> 13:06.520]  и все, в общем-то, в общем-то, в этом месте вроде как больше
[13:06.520 --> 13:10.520]  ничего не делаем, так, да, не забываем написать
[13:10.520 --> 13:20.400]  бряк, так, дальше, так, нет, следующий номер нашей
[13:20.400 --> 13:27.720]  программы мы будем писать рыженьким, так, потому что
[13:27.720 --> 13:31.520]  дальше у нас идет обратное ребро, обратное ребро идентифицируется
[13:31.520 --> 13:36.480]  очень просто, потому что если вершина, как несложно
[13:36.480 --> 13:42.360]  догадаться по маркеру, у нас серая, ну как всегда,
[13:42.360 --> 13:44.160]  ну у нас в прошлый раз уже было, что мы серый режим
[13:44.160 --> 13:53.200]  обозначали, да, ну да, да, о господи, а в геоме есть
[13:53.200 --> 13:59.520]  серые вершины, ладно, так, значит, dfs grey, так, что в
[13:59.520 --> 14:07.120]  случае делать, ну, наверное, конечно, написать, что, да,
[14:07.120 --> 14:09.520]  крайне логично, на самом деле было бы, наверное,
[14:09.520 --> 14:17.080]  uptime от v, min равно uptime, да, на этот раз только не uptime,
[14:17.080 --> 14:22.240]  а, конечно, time in, да, совершенно верно, совершенно верно,
[14:22.240 --> 14:28.640]  time in от u, ой, что-то не помещается, что, маркер толстый, что
[14:29.400 --> 14:38.320]  так, давайте, вот так вот сделаем, так, min равно time in,
[14:38.320 --> 14:45.120]  time in от u, вот, вот теперь хорошо, и, конечно, не забыть
[14:45.120 --> 14:56.520]  бряк, вот, бряк, так, какие у нас еще есть варианты, а у нас,
[14:56.520 --> 15:02.000]  собственно, вариантов, ну, как сказать, вариантов-то,
[15:02.000 --> 15:05.800]  в общем-то, по цветам-то вариантов, в общем-то, и нет
[15:05.800 --> 15:10.600]  особо, но по типу ребер есть, у нас есть прямые ребра
[15:10.600 --> 15:15.480]  и есть перекрестные ребра, ну, давайте напишем эти
[15:15.520 --> 15:27.360]  варианты, значит, case, что делать, если у нас, да, e dfs black,
[15:27.360 --> 15:35.560]  да, а у нас нет зеленого цвета, нет, погодите, а вот нет,
[15:35.560 --> 15:39.960]  проблема в том, что, проблема в том, что, как бы, если ребро
[15:39.960 --> 15:43.200]  идет уже в черную вершину, то это может быть как зеленое
[15:43.200 --> 15:48.200]  ребро, так и синее ребро, ну, то есть, прямое-то, в прямом
[15:48.200 --> 15:53.040]  ребре тоже это будет черная вершина, вот, и это тыт мы
[15:53.040 --> 16:03.400]  напишем, собственно, внутри этого кейса, да, нет, пока
[16:03.400 --> 16:05.920]  нет проблем, пока проблема в том, что мы хотим отличить
[16:05.920 --> 16:10.480]  прямое ребро от перекрестного, они, это вот, оба этих типа
[16:10.480 --> 16:15.160]  ребра подходят под вот этот вот цвет, поэтому, кстати,
[16:15.160 --> 16:17.440]  теперь вопрос, как в этом предположении отличить,
[16:17.440 --> 16:32.040]  кстати, прямое ребро от перекрестного, да, да, значит, если, ну да,
[16:32.040 --> 16:35.440]  давай так, если таймин или наоборот, если таймин
[16:35.440 --> 16:41.440]  от У оказался меньше нас, а мы-то В, да, это не тривиально,
[16:41.440 --> 16:53.920]  но мы-то В, так, то, то мы должны что-то сделать, вот.
[16:53.920 --> 17:14.520]  Нет, нет, почему, смотрите, синий, синий это означает,
[17:14.520 --> 17:16.760]  что эта вершина оказалась нашим потомком деревья
[17:16.760 --> 17:22.240]  DFS, это означает, что мы в нее вошли, как бы, ну, вошли
[17:22.240 --> 17:26.320]  и вышли, но значит, вошли мы в нее позже, чем в себя,
[17:26.320 --> 17:31.840]  да, то есть, да, вот этот случай, да, то есть, так,
[17:31.840 --> 17:34.640]  поэтому, да, это у нас синий будет случай, и мы его обозначим
[17:34.640 --> 17:37.960]  вот так, то есть, вот тут что-то надо сделать, и тут
[17:37.960 --> 17:43.880]  надо что-то сделать, вот так, ладно, давайте даже
[17:43.880 --> 17:51.320]  я вот так сделаю, вот так, и вот так, вот, то есть, тут
[17:51.320 --> 17:55.480]  придется делать, так, и что-то еще надо сделать,
[17:55.480 --> 17:58.320]  так, да, свитч на этом заканчивается, и, в общем-то, кажется, вся
[17:58.320 --> 18:04.160]  обработка на этом тоже заканчивается, так, давайте,
[18:04.160 --> 18:08.720]  вот где-то вот здесь, ой, сколько скобочек красиво,
[18:08.720 --> 18:13.760]  так, не поместилось, ну, ничего, значит, делается
[18:13.760 --> 18:16.520]  тогда это так, значит, это мы, значит, переносим вот
[18:16.520 --> 18:19.280]  сюда, потому что, что мы, вот, что мы по окончании
[18:19.280 --> 18:26.760]  делаем, ну, во-первых, мы говорим, что color от v равно
[18:26.760 --> 18:35.680]  ze dfs black, и, в конце, конечно, говорим, что, если у нас
[18:35.680 --> 18:48.880]  оказалось, что v корень своей компоненты сильной связности,
[18:48.880 --> 18:54.240]  то тогда, что мы делаем, тогда мы, соответственно,
[18:54.240 --> 19:05.000]  говорим, что у нас есть вектор int comp, значит, ну, и делаем
[19:05.000 --> 19:11.240]  наш его величество do while, то есть, do, соответственно,
[19:11.240 --> 19:24.360]  comp.pushback от st.top, st.pop, ну, и все, ну, вот, и делаем
[19:24.360 --> 19:35.080]  мы это пока не окажется, что у нас comp.back равен v,
[19:36.080 --> 19:40.000]  вот, ну, и остается только сказать, там, сохранить
[19:40.000 --> 20:04.440]  comp.css, ну, и все, давай, почему, как раз-то, нет, именно
[20:04.440 --> 20:07.320]  поэтому мы делаем do while, то есть, мы достаем вершину,
[20:07.320 --> 20:10.800]  а потом смотрим, а потом после этого выясняем, что,
[20:10.800 --> 20:18.680]  ой, она равна v, все, на этом do while заканчивается, да,
[20:18.680 --> 20:26.040]  comp, не st.bar, да, вот, то есть, вот такую технологию примерно
[20:26.040 --> 20:39.760]  хочется применить, так вот, да, вот, ну, формально говоря,
[20:39.760 --> 20:42.880]  да, совершенно верно, значит, да, но для начала, конечно,
[20:42.880 --> 20:47.960]  для этого надо доказать, что можно говорить о понятии
[20:47.960 --> 20:52.120]  корня ксс, то есть, что нам для этого нужно, то есть,
[20:52.120 --> 20:56.120]  нам нужно, чтобы, действительно, каждая компонента сильной
[20:56.120 --> 21:00.440]  связности, с точки зрения dfs, образовывала бы что-то
[21:00.440 --> 21:05.400]  подобное, но как в этом, ну, вот, но, на самом деле, в
[21:05.400 --> 21:09.400]  этом не очень сложно убедиться, господи, зачем у нас доску
[21:09.400 --> 21:15.480]  свистнули, ну, ладно, так, так, значит, смотрите, то
[21:15.480 --> 21:19.200]  есть, в общем-то, тут ничего такого нету, ну, давайте
[21:19.200 --> 21:20.440]  просто себе это представим.
[21:20.440 --> 21:27.880]  Что для этого, что нужно доказать, ну, то есть, что
[21:27.880 --> 21:33.200]  нужно доказать, хочется доказать, что когда dfs каким-то
[21:33.200 --> 21:37.480]  образом, значит, войдет в компоненту сильной связности,
[21:37.480 --> 21:44.120]  то есть, он ее обойдет так, что внутри дерева dfs, такие,
[21:44.120 --> 21:48.000]  внутри этой компоненты, то есть, дерево dfs индуцирует
[21:48.000 --> 21:50.560]  такое связанное, просто подвешенное дерево с корнем
[21:50.560 --> 21:54.880]  вот в этой вершине, в которую мы первые вошли, ровно это
[21:54.880 --> 21:55.880]  мы и хотим, правда.
[21:55.880 --> 22:02.840]  Так, ну, как же это доказать, вот, ну, и здесь, на самом
[22:02.840 --> 22:06.080]  деле, доказывается достаточно просто, потому что начнем
[22:06.080 --> 22:08.920]  с маленького приятного факта, начнем с того, что, вот, пусть
[22:08.920 --> 22:13.280]  вот эта вот вершина, это, назовем ее root, это первая
[22:13.280 --> 22:17.640]  вершина компонентной сильной связности какой-то, в которую
[22:17.640 --> 22:19.040]  dfs вообще зашел.
[22:19.040 --> 22:24.480]  Тогда, в тот момент, когда мы ее посетили, замерно,
[22:24.480 --> 22:28.000]  вот, значит, все остальные вершины еще белые, и более
[22:28.000 --> 22:32.720]  того, по ним дойти, и более того, чисто по белым вершинам
[22:32.720 --> 22:34.360]  до них из этой вершины дойти можно.
[22:34.360 --> 22:38.880]  Следовательно, по лемме о белых путях, мы понимаем,
[22:38.880 --> 22:42.120]  что эти вершины будут как минимум потомками этой
[22:42.120 --> 22:47.200]  вершины в дереве dfs, понятно, да?
[22:47.480 --> 22:51.360]  Ну вот, остается только одно.
[22:51.360 --> 22:54.640]  Остается только показать, что они будут образовывать
[22:54.640 --> 22:57.220]  именно связанное под дерево, а не просто они там какие-то
[22:57.220 --> 22:58.220]  потомки.
[22:58.220 --> 23:01.520]  Но доказать это тоже достаточно легко, потому что предположим,
[23:01.520 --> 23:03.800]  что у нас действительно тут оказалось, что мы тут
[23:03.800 --> 23:07.320]  походили, потом как-то там вышли-вышли-вышли-вышли,
[23:07.320 --> 23:14.120]  и, то есть, оказался какой-то несвязанный именно под деревом,
[23:14.120 --> 23:17.560]  то же потомок, который тоже у нас из этой компоненты.
[23:17.560 --> 23:21.560]  Но с другой стороны, тогда получается странная вещь.
[23:21.560 --> 23:25.440]  Смотрите, мы знаем, что мы из этой вершины можем
[23:25.440 --> 23:28.200]  дойти до всех вот этих и прийти вот в эту с одной
[23:28.200 --> 23:32.080]  стороны, а с другой стороны мы знаем, что из этой вершины
[23:32.080 --> 23:34.440]  мы каким-то образом можем и сюда прийти, потому что
[23:34.440 --> 23:36.680]  они тут в одной компоненте сильной связости лежат.
[23:36.680 --> 23:42.120]  Но на самом деле из этого очевидно, что тогда получается,
[23:42.120 --> 23:46.400]  что из этих вершин тоже можно до корня добраться.
[23:46.400 --> 23:51.320]  То есть вывод, что эти вершины тоже в той же самой компоненте
[23:51.320 --> 23:52.640]  сильной связности лежат.
[23:52.640 --> 23:55.640]  Понятно, да?
[23:55.640 --> 23:59.760]  Ну, можно в принципе сформулировать теорему мистическую о
[23:59.760 --> 24:02.960]  том, что если у вас есть две вершины из одной компоненты
[24:02.960 --> 24:06.480]  сильной связности и есть какой-то путь между ними
[24:06.480 --> 24:10.640]  простой, да даже не простой, неважно, то все эти вершины
[24:10.640 --> 24:12.960]  тоже лежат в этой компоненте сильной связности.
[24:12.960 --> 24:17.320]  Ну, а тут все просто.
[24:17.320 --> 24:25.280]  Так что даже тут уже никаких проблем не было, кажется,
[24:25.280 --> 24:27.240]  в прошлый раз с вершиной двух связностей нам пришлось
[24:27.240 --> 24:28.440]  повозиться сильно больше.
[24:28.440 --> 24:45.400]  Нет, ну зачем обратное, ну потому что еще раз, потому
[24:45.400 --> 24:48.200]  что вот рассмотрим первую вершину, все эти вершины
[24:48.200 --> 24:52.760]  являются именно потомками в дереве DFS, именно потомками.
[24:52.760 --> 25:00.320]  Ну вот, то есть дальше все остальное, надо только
[25:00.320 --> 25:02.600]  доказать, что они тут, что это будет все связано.
[25:02.600 --> 25:06.920]  Но это следует из того, что если какая-то вершина
[25:06.920 --> 25:09.800]  в компоненте, то и весь путь по дереву DFS тоже в ней
[25:09.800 --> 25:11.880]  будет в этой же компоненте, поэтому дерево связано.
[25:11.880 --> 25:19.760]  Вот, казалось бы, да, казалось бы, все в наших руках, казалось
[25:19.760 --> 25:22.080]  бы, там все препятствия, которые должны быть вроде
[25:22.080 --> 25:23.080]  как рассыпаются.
[25:23.080 --> 25:27.080]  Пока мы не начинаем додумывать вот этот интеллектуальный
[25:27.080 --> 25:28.080]  момент.
[25:28.080 --> 25:32.200]  А как же нам определить и высчитывать uptime?
[25:32.200 --> 25:39.320]  Ну, хотя, казалось бы, давайте подумаем, что такое uptime?
[25:39.320 --> 25:43.280]  Так, по определению, ну давайте вот напишем, помните,
[25:43.280 --> 25:46.920]  мы uptime, мы даже его рыженьким писали, помните?
[25:46.920 --> 25:51.880]  Давайте вспомним, определение, да, что uptime от V.
[25:52.680 --> 26:05.000]  Это по определению, это минимальный такой time in от U, от U, ладно,
[26:05.000 --> 26:16.760]  пусть будет от U, такой что, значит, WU это обратное,
[26:16.760 --> 26:29.720]  обратное ребро и W потомок V, так, так, тут нормально
[26:29.720 --> 26:34.760]  видно, что я пишу, кстати, а то тогда маркер не идеальный,
[26:34.760 --> 26:35.760]  вот.
[26:35.760 --> 26:41.880]  Так, ну в принципе, да, если вот с перекрестными прямыми
[26:41.880 --> 26:46.080]  ничего не делать, то в общем-то uptime мы ровно в таком виде
[26:46.080 --> 26:47.080]  и делаем.
[26:47.080 --> 26:55.200]  Вот, остается только самая малость, остается только
[26:55.200 --> 26:59.080]  теперь доказать, что, ну нет, теперь вот возникает вопрос,
[26:59.080 --> 27:01.560]  а как же нам идентифицировать, хорошо, вот тогда uptime мы
[27:01.560 --> 27:05.080]  вычисляем правильно, ну очевидно, то есть вот, по
[27:05.080 --> 27:07.280]  крайней мере, по такому определению мы его вычисляем
[27:07.280 --> 27:08.280]  правильно.
[27:08.280 --> 27:13.040]  Вот, так, тогда возникает вопрос, как вычислять корень
[27:13.040 --> 27:19.600]  своей КСС, как понимать, как нам понимать, является
[27:19.600 --> 27:21.880]  ли В, корнем своей КСС или не является.
[27:21.880 --> 27:22.880]  Согласен.
[27:22.880 --> 27:39.120]  Да, в принципе, вот такое ребро никто не отменял.
[27:39.120 --> 27:42.040]  Более того, на самом деле какая-нибудь типичная компонента
[27:42.040 --> 27:45.800]  сильной связности вполне может выглядеть и вот таким
[27:45.800 --> 27:47.080]  вот нехитрым образом.
[27:47.080 --> 27:58.000]  Вот, вот так вот и давайте, и еще вот куда-нибудь вот
[27:58.000 --> 27:59.000]  сюда давайте.
[27:59.000 --> 28:00.000]  Ну вот.
[28:00.000 --> 28:01.000]  Ну вот.
[28:01.000 --> 28:02.000]  Ну вот.
[28:02.000 --> 28:03.000]  Да.
[28:03.000 --> 28:32.760]  Так, ну в редком смысле, обратное ребро мы уже идентифицировали.
[28:32.760 --> 28:36.680]  Ну хотелось.
[28:36.680 --> 28:42.280]  Так, ну хотелось, да.
[28:42.280 --> 28:58.080]  Только, только тут, тогда тут может быть все еще страшнее,
[28:58.080 --> 29:00.920]  потому что может она это ведет в перекресты ребро,
[29:01.360 --> 29:04.880]  в потомках есть еще перекрестное ребро, из которого есть обратное,
[29:04.880 --> 29:07.520]  из которого там можно ниже пойти в перекресты, из которого
[29:07.520 --> 29:08.520]  попасть.
[29:08.520 --> 29:09.520]  Вот желательно.
[29:09.520 --> 29:12.800]  Ну давайте, смотрите, что хочется, например, хочется
[29:12.800 --> 29:13.800]  линейный алгоритм.
[29:13.800 --> 29:16.440]  Да, ну во-первых, так, давайте так, для начала вот это.
[29:16.440 --> 29:17.440]  Что мы тут хотим?
[29:17.440 --> 29:19.480]  Как определить, что В является корнем?
[29:19.480 --> 29:22.520]  Ну конечно, голубая мечта у нас все-таки так и написать,
[29:22.520 --> 29:28.760]  что если оказалось, что там uptime от В оказался меньше,
[29:28.760 --> 29:39.440]  чем time in от В, да, ну как бы, как раньше мы говорили,
[29:39.440 --> 29:42.760]  да, ладно, нет, наоборот, да, вро, вро, вро, да, конечно,
[29:42.760 --> 29:45.520]  конечно, то есть если он оказался больше либо равен,
[29:45.520 --> 29:46.520]  тогда мы корнем.
[29:46.520 --> 29:51.760]  Вот, то есть, ну в принципе, вот, можно написать вот уже
[29:51.760 --> 29:52.760]  этот алгоритм.
[29:52.760 --> 29:56.800]  Ну написать-то все что угодно можем, как это она, как это
[29:57.240 --> 30:02.400]  у нас на заборе и не такое пишут, вот, но теперь давайте
[30:02.400 --> 30:05.000]  смотреть, попробуем доказать, почему это работает.
[30:05.000 --> 30:17.000]  Ну, действительно, в смысле, ну вот, и что, ну давайте
[30:17.000 --> 30:25.600]  я точки сотру, хорошо, все, вот все, ну как бы, это я
[30:25.600 --> 30:30.800]  просто типа, типа, да, так, то есть, можно написать
[30:30.800 --> 30:35.200]  кодки, типа, там принц, ребро, перекросное, там, ну возопить,
[30:35.200 --> 30:38.600]  там типа, ну в CR куда-нибудь, ну, как всегда, если вам
[30:38.600 --> 30:41.200]  нужно в коде куда-нибудь возопить, то вы это можете
[30:41.200 --> 30:44.400]  делать в CR и как бы это все нормально будет, ну, то есть,
[30:44.400 --> 30:46.400]  вы там на это ТЛ, конечно, потратите, но это уже другой
[30:46.400 --> 30:51.200]  вопрос, вот, ну, собственно, ладно, я думаю, это я, так,
[30:51.200 --> 30:53.800]  ну, на всякий случай, все ж помнят, да, что если там
[30:54.200 --> 30:56.200]  написать что-нибудь в CR, то тестирующая система этого
[30:56.200 --> 31:02.200]  не заметит, да, ну, это дебагал будет очень полезно, потому
[31:02.200 --> 31:03.800]  что, как бы, тестирующая система, она проверяет
[31:03.800 --> 31:06.200]  только то, что вы, как бы, в STD out вывели, поэтому,
[31:06.200 --> 31:11.800]  что вы вывели в STD ER, она не проверяет, поэтому, ну,
[31:11.800 --> 31:14.400]  это значит, надо ее побить канделябром, если она это
[31:14.400 --> 31:17.000]  делает, потому что нормальная тестирующая система этого
[31:17.000 --> 31:23.200]  не делает, вот, это очень удобно, так вот, давайте,
[31:23.200 --> 31:27.200]  давайте смотреть, почему же это работает, ну, действительно,
[31:27.200 --> 31:31.200]  давайте посмотрим, что, во-первых, если вершина, ну,
[31:31.200 --> 31:35.200]  давайте так, ну, во-первых, если uptime оказался меньше
[31:35.200 --> 31:40.200]  таймына, что это означает, да, то есть, это означает,
[31:40.200 --> 31:44.200]  что у нас жила была вершина, мы тут могли тут пойти куда-то
[31:44.200 --> 31:48.200]  вниз и неожиданно подняться по обратному либу в какую-то
[31:48.200 --> 31:54.200]  вершину V, вот, то есть, в какого-то предочка, в принципе,
[31:54.200 --> 31:58.200]  да, это означает, что со всеми вот этими предками эта
[31:58.200 --> 32:00.200]  вершина, очевидно, лежит в одной компоненте сильной
[32:00.200 --> 32:05.200]  связности, следовательно, вершина V не корень, то есть,
[32:05.200 --> 32:08.200]  если uptime оказался, то есть, если условие не сработало,
[32:08.200 --> 32:17.200]  то вершина V действительно не корень, так, а если это
[32:17.200 --> 32:22.200]  условие сработало, обязательно ли эта вершина корень?
[32:22.200 --> 32:27.200]  Да, ну, к сожалению, нет и пример, в общем-то, вот,
[32:27.200 --> 32:32.200]  потому что, то есть, он, то есть, ну, вот, то есть, в принципе,
[32:32.200 --> 32:36.200]  как бы, ну, как вы доказали, то есть, корень будет
[32:36.200 --> 32:40.200]  идентифицирован правильно, да, то есть, как бы корень,
[32:40.200 --> 32:42.200]  действительно, то есть, эта вершина будет идентифицирована
[32:42.200 --> 32:46.200]  как корень своей компоненты, но проблема в том, что помимо
[32:46.200 --> 32:49.200]  нее, как корень будет идентифицирован еще кто-то,
[32:49.200 --> 32:54.200]  например, вот эта вершина, вот, то есть, вполне вероятно,
[32:54.200 --> 32:57.200]  потому что, видите, у нас, потому что, а как он, в чем
[32:57.200 --> 33:00.200]  разница, видите, раньше у нас доказательства, да, там
[33:00.200 --> 33:03.200]  всякие там прореберные двухсвязались, было основано
[33:03.200 --> 33:07.200]  на том, что из-под дерева вершины мы можем выйти только
[33:07.200 --> 33:11.200]  через обратное ребро, теперь это неверно, потому что
[33:11.200 --> 33:15.200]  у нас теперь появились перекресты, вот, то есть,
[33:15.200 --> 33:21.200]  получается, у нас есть ложное срабатывание, то есть,
[33:21.200 --> 33:27.200]  ну, вот, то есть, у нас есть ошибка вот в одну сторону,
[33:27.200 --> 33:34.200]  то есть, есть ошибка, что, то есть, мы не пропустим корни,
[33:34.200 --> 33:39.200]  но у нас могут быть лишние, что же делать, как же решить
[33:39.200 --> 33:41.200]  эту проблему?
[33:41.200 --> 33:49.200]  Мы обтайм определяли, как мы обтаям определяли,
[33:49.200 --> 33:52.200]  как мы имейшие таймы, которые достигли из-за одного
[33:52.200 --> 33:56.200]  дерева, заметим, что мы его неправильно считаем,
[33:56.200 --> 34:00.200]  так, то, как мы его считаем, не соответствует его
[34:00.200 --> 34:03.200]  определению, сейчас, так, стоп-стоп-стоп, почему,
[34:03.200 --> 34:06.200]  нет, в этом я не понял, я ничего не понял, обтайм,
[34:06.200 --> 34:08.200]  по-моему, мы считаем сейчас абсолютно соответствующим
[34:08.200 --> 34:16.200]  его определению, вот так, ну, а теперь давайте думать,
[34:16.200 --> 34:18.200]  а как вы его хотим определять?
[34:18.200 --> 34:23.200]  Вот как минимальная машина с минимальным таймином,
[34:23.200 --> 34:32.200]  в котором мы можем попасть из данного под дерево?
[34:32.200 --> 34:41.200]  Так, так, так, так, так, так, так, так, так, так,
[34:41.200 --> 34:44.200]  то есть, вероятно, сейчас повернемся, с минимальным
[34:44.200 --> 34:51.200]  таймином, в котором мы можем попасть.
[34:51.200 --> 34:54.200]  Ну, как сказать, ну, на самом деле, я боюсь, что уже
[34:54.200 --> 34:58.200]  это, ну, вот, что это тоже завалится, потому что тут
[34:58.200 --> 35:01.200]  еще есть такая мелкая проблема, потому что я рассмотрю
[35:01.200 --> 35:04.200]  другой пример, такой тупой пример, который легко
[35:04.200 --> 35:07.200]  реализовать, давайте я скажу, что у меня будет обратное
[35:07.200 --> 35:19.200]  ребро или перекрестное, хотя бы, так, ну, вот, тогда
[35:19.200 --> 35:22.200]  тут вот тоже можно тут написать, что давайте аптайм
[35:22.200 --> 35:29.200]  от В, там мин равно можно написать, да, таймин от
[35:29.200 --> 35:38.200]  В, ну, вот, вот, так, нет, смотрите, а что такое?
[35:38.200 --> 35:42.200]  А в чем, собственно, проблема?
[35:42.200 --> 36:04.200]  Ну, да, может оказаться, что у нас тут есть какая-то
[36:04.200 --> 36:11.200]  вот соседняя компонента, вот как-то так это будет,
[36:11.200 --> 36:13.200]  в которую тоже ведет обратное ребро.
[36:13.200 --> 36:21.200]  Так, то есть, да, действительно, то есть, это, то есть, тут
[36:21.200 --> 36:24.200]  оказывается, то есть, конечно, то есть, вот такой случай
[36:24.200 --> 36:28.200]  мы убрали, то есть, вот такой случай мы убрали, но тогда
[36:28.200 --> 36:31.200]  оказывается, что и сам корень может уже перестать быть
[36:31.200 --> 36:34.200]  идентифицирован как корень, потому что у нас, как бы,
[36:34.200 --> 36:38.200]  из этой компоненты можно выйти, собственно, в какую-нибудь
[36:38.200 --> 36:41.200]  соседнюю компонент.
[36:41.200 --> 36:42.200]  Так.
[36:42.200 --> 36:47.200]  Кажется, что достаточно изменить условия проверки,
[36:47.200 --> 36:51.200]  что аптаймат, короче, нужно хранить не таймин минимальной
[36:51.200 --> 36:54.200]  вершины, а, собственно, вершину с минимальным таймином,
[36:54.200 --> 36:58.200]  вот, и тогда надо бы проверить, что она наша предка просто.
[36:58.200 --> 37:00.200]  Ну, а если мы предкой перепишем?
[37:00.200 --> 37:03.200]  Так, если, чтобы проверять, что она предка нам не достаточно,
[37:03.200 --> 37:06.200]  тогда разве это не старое определение аптайма?
[37:06.200 --> 37:09.200]  То есть, давайте проверять только предков.
[37:09.200 --> 37:11.200]  Да, потому что мы будем по пути читать.
[37:11.200 --> 37:13.200]  По какому пути?
[37:13.200 --> 37:16.200]  Мы будем пересчитывать таймин, как бы-то мы и прыгаем не по одному левру,
[37:16.200 --> 37:18.200]  а по, сколько хотим ребер.
[37:18.200 --> 37:20.200]  Да, только мою нод.
[37:20.200 --> 37:21.200]  Сейчас.
[37:21.200 --> 37:24.200]  Мне кажется, мы можем его пересчитывать, потому что у нас ребра зеленые идут справа-налево,
[37:24.200 --> 37:26.200]  поэтому у нас лево будет сочетано в жизни такое.
[37:26.200 --> 37:27.200]  Так.
[37:29.200 --> 37:31.200]  Так, так, так, так, так.
[37:31.200 --> 37:33.200]  Остала нод.
[37:33.200 --> 37:35.200]  Нода.
[37:36.200 --> 37:42.200]  А, проблема в том, что мы пересчитываешься через себя, когда считаем трипратные ребра.
[37:42.200 --> 37:43.200]  Угу.
[37:43.200 --> 37:45.200]  Но есть такая проблема, да.
[37:45.200 --> 37:48.200]  Поэтому просто так не получится.
[37:48.200 --> 37:50.200]  Так, ну здесь, по крайней мере, да.
[37:50.200 --> 37:53.200]  Нет, то здесь просто хотелось обратить внимание, что здесь, кажется, наоборот.
[37:53.200 --> 38:00.200]  Что здесь у нас, может, наоборот, все некорни будут идти, идентифицированы как некорни.
[38:00.200 --> 38:03.200]  Ну, потому что из любого поддерева внутри компоненты,
[38:03.200 --> 38:08.200]  как бы, можно уж либо через обратное, либо через перекрестное точно выйти, причем в рамках этой же компоненты.
[38:08.200 --> 38:10.200]  Правда?
[38:10.200 --> 38:12.200]  То есть, некорни будут...
[38:12.200 --> 38:13.200]  То есть, теперь обратно все...
[38:13.200 --> 38:16.200]  То есть, раньше у нас было все корни идентифицированы как корни,
[38:16.200 --> 38:17.200]  только могут...
[38:17.200 --> 38:19.200]  Ну вот, а некорни могут случайно сработать.
[38:19.200 --> 38:20.200]  Теперь наоборот.
[38:20.200 --> 38:24.200]  То есть, теперь у нас некорни точно некорни, а вот корни могут сработать, могут нет.
[38:24.200 --> 38:26.200]  Давайте сделаем бы то и то.
[38:26.200 --> 38:27.200]  А.
[38:27.200 --> 38:28.200]  А.
[38:28.200 --> 38:30.200]  Чего?
[38:30.200 --> 38:31.200]  Чего можно?
[38:31.200 --> 38:33.200]  Я говорю, надо.
[38:33.200 --> 38:38.200]  Пускай у нас есть Uv, вот зеленый, по которому мы сейчас хотим обновиться.
[38:38.200 --> 38:39.200]  Так.
[38:39.200 --> 38:44.200]  Тогда давайте посмотрим, у Uv есть какой-то uptime.
[38:44.200 --> 38:46.200]  Посмотрим на него.
[38:46.200 --> 38:52.200]  Мы можем как-нибудь записывать вершину, на которую она ссылается, с таким таймином.
[38:52.200 --> 38:55.200]  Например, в таймин записывать вершину.
[38:55.200 --> 38:56.200]  Это нужно определить.
[38:56.200 --> 39:01.200]  Является ли uptime от v, то есть w, является ли w пред... предком...
[39:01.200 --> 39:08.200]  Если является, то мы обновляем, если не является, то мы ничего не делаем.
[39:08.200 --> 39:09.200]  У-у-у...
[39:09.200 --> 39:10.200]  Сейчас.
[39:10.200 --> 39:11.200]  То есть, мы для каждого...
[39:11.200 --> 39:18.200]  У нас и вариант, собственно, обновляем, если не является, то мы ничего не делаем.
[39:18.200 --> 39:19.200]  У-у-у...
[39:19.200 --> 39:20.200]  Сейчас.
[39:21.200 --> 39:22.200]  Сейчас.
[39:22.200 --> 39:23.200]  То есть, мы для каждого...
[39:23.200 --> 39:30.200]  У нас и вариант, собственно, uptime, это наименьшая по тайминам вершина, в которую мы можем
[39:30.200 --> 39:33.200]  попасть из данного потеря.
[39:33.200 --> 39:34.200]  Так.
[39:34.200 --> 39:35.200]  Но для этого...
[39:35.200 --> 39:38.200]  Нет, если мы хотим, чтобы uptime, это была наименьшая вершина, в которую мы вообще
[39:38.200 --> 39:40.200]  можем попасть, то возникает вопрос, как ее пересчитывать.
[39:40.200 --> 39:43.200]  Ну, вот я предупреждаю, что...
[39:43.200 --> 39:44.200]  Что не хватает...
[39:44.200 --> 39:45.200]  Что оставшийся...
[39:45.200 --> 39:48.200]  Ну, все предыдущее оставить, а зеленое обрабатывать вот так.
[39:48.200 --> 39:49.200]  Нет, там просто...
[39:49.200 --> 39:50.200]  Насчет...
[39:50.200 --> 39:51.200]  Сейчас.
[39:51.200 --> 39:52.200]  Не, ну как обрабатывать?
[39:52.200 --> 39:54.200]  Для этой вершины не очень понятно, как это насчитать.
[39:54.200 --> 39:58.200]  Потому что минимальная вершина по тайминам, куда мы можем попасть, это вот эта вершина.
[39:58.200 --> 40:03.200]  Только попасть ее надо скакнуть по обратному ребру, прийти вот сюда и пойти сюда.
[40:03.200 --> 40:06.200]  То есть, как бы пересчет через то, что мы еще не могли не досчитать.
[40:06.200 --> 40:07.200]  Потому что это обратно...
[40:07.200 --> 40:11.200]  Это ребро могло, кстати, вести не из этой вершины, а, например, из этой.
[40:11.200 --> 40:12.200]  То есть...
[40:12.200 --> 40:15.200]  То есть, вот такая коллизия.
[40:15.200 --> 40:17.200]  В общем, не работает, правда.
[40:17.200 --> 40:18.200]  Насчитают первые таймы.
[40:18.200 --> 40:20.200]  То есть, первый оттайм, второй оттайм, и...
[40:20.200 --> 40:22.200]  Что такое первый оттайм и второй оттайм?
[40:22.200 --> 40:25.200]  Первый без зеленой дописки, второй с зеленой допиской.
[40:25.200 --> 40:26.200]  Так.
[40:26.200 --> 40:27.200]  Хорошо.
[40:27.200 --> 40:31.200]  И тогда мы все корни определяем, и все некорни тоже определяем.
[40:33.200 --> 40:34.200]  Так.
[40:38.200 --> 40:39.200]  Так.
[40:42.200 --> 40:43.200]  Не, слушай.
[40:43.200 --> 40:44.200]  Так, да.
[40:44.200 --> 40:45.200]  Нет.
[40:45.200 --> 40:46.200]  Не, слушай, нет.
[40:46.200 --> 40:47.200]  Даже интересно.
[40:47.200 --> 40:48.200]  Да, действительно.
[40:48.200 --> 40:49.200]  Давайте сфотографируем.
[40:49.200 --> 40:50.200]  Хорошо.
[40:52.200 --> 40:53.200]  Нет, ну, нет.
[40:53.200 --> 40:54.200]  Давайте смотреть.
[40:54.200 --> 40:55.200]  Потому что мало.
[40:55.200 --> 40:57.200]  Вдруг мы сейчас придумаем алгоритм круче, чем у Тарьяна.
[40:57.200 --> 40:58.200]  Вот.
[40:58.200 --> 40:59.200]  Ладно.
[40:59.200 --> 41:00.200]  Хорошо.
[41:00.200 --> 41:01.200]  У нас есть рыжий оттайм.
[41:01.200 --> 41:02.200]  А есть?
[41:02.200 --> 41:05.200]  Ну, давайте зеленый оттайм.
[41:05.200 --> 41:06.200]  Оттайм два.
[41:07.200 --> 41:09.200]  То есть, то же самое.
[41:09.200 --> 41:10.200]  То же самое.
[41:10.200 --> 41:11.200]  То же самое.
[41:11.200 --> 41:13.200]  То же самое или перекрестное.
[41:13.200 --> 41:14.200]  То же самое.
[41:14.200 --> 41:15.200]  То же самое.
[41:16.200 --> 41:17.200]  Так.
[41:20.200 --> 41:21.200]  Так.
[41:21.200 --> 41:22.200]  Насчитать его.
[41:22.200 --> 41:24.200]  Насчитать такой оттайм достаточно понятно.
[41:24.200 --> 41:25.200]  Насчитываем легко.
[41:25.200 --> 41:26.200]  Так.
[41:26.200 --> 41:28.200]  Теперь будет какая-то вопрос.
[41:28.200 --> 41:30.200]  И что нам предлагается?
[41:30.200 --> 41:34.200]  Предлагается поставить условие, если рыжий оттайм больше,
[41:34.200 --> 41:39.200]  чем наш таймин, и зеленый оттайм.
[41:39.200 --> 41:40.200]  Что?
[41:40.200 --> 41:48.440]  и зеленый оптайм больше, нет ну тут так тут как бы да то есть заметим что оптайм 2
[41:48.440 --> 41:52.280]  он заметно кстати более сильный чем оптайм от В, потому что он включает в себя все то же
[41:52.280 --> 42:03.200]  самое и что-то еще, нет тут как-то да пока проблемы, первый и не второй, и не второй,
[42:03.200 --> 42:10.680]  то есть если оптайм да ну просто проблема то что то есть любая век, то есть как бы
[42:10.680 --> 42:16.960]  по обратным ребрам выйти выше нельзя, а по перекрестным можно, ну вот этот случай,
[42:16.960 --> 42:29.960]  а нет почему куда-то попали, нет мы пытаемся, у нас была технология, мы пытаемся подогнать,
[42:29.960 --> 42:44.920]  так чтобы остался алгоритм СОВЫ плюс Е, ну да, причем правда, но вот да хочется когда тем
[42:44.920 --> 42:49.800]  более что тут проблема что может быть перекрестная обратно, там причем не просто перекрестная спуск,
[42:49.800 --> 42:56.960]  обратная спуск, перекрестная спуск обратно, нет вот нет на самом деле хотеть, хотя на самом деле
[42:56.960 --> 43:06.560]  можно заметить что все гораздо проще, ну потому что смотрите, заметим что у нас, ну тут на самом
[43:06.560 --> 43:12.680]  деле замечание тут оказывается более тонкое, значит смотрите на самом деле куда ведут
[43:12.680 --> 43:21.360]  перекрестные ребра, перекрест, ну да, но смотрите они ведут либо в соседнее поддерево внутри одной
[43:21.360 --> 43:31.160]  и той же компоненты сильной связности, видно да, либо они ведут в какую-то другую компоненту
[43:31.160 --> 43:40.960]  сильной связности, пока очевидно, согласен пока К, ну потому что ребро всегда ведет либо в ту же
[43:40.960 --> 44:06.000]  компоненту сильной связости, либо в другую, да, другой вопрос, что мы не определили, да, понятно,
[44:06.000 --> 44:11.920]  что мы не определили, мы как бы хотим, но как бы да, но опять смотрите, но фишка такая, да, пока
[44:11.920 --> 44:19.760]  ничего не сказал, но фишка такая, смотрите, а что это за компоненты сильной связности, другая в
[44:19.760 --> 44:26.920]  которой может вести перекрестное ребро, ну смотрите, это может быть, ну может быть, смотрите,
[44:26.920 --> 44:31.520]  что это может быть, это может быть, например потомок, смотрите, вот может быть в принципе вполне
[44:31.720 --> 44:43.680]  вот такая ситуация, вот например вот как-то так, да, да, нет, так вполне может быть, вот, то есть это
[44:43.680 --> 44:49.520]  может быть потомок нашей компоненты просто из другой веточки, а может быть даже не потомок,
[44:49.520 --> 44:57.760]  а какая-то вот видите ранее рассмотренная компонент, но идея оказывается такая, что в идеальном мире,
[44:58.160 --> 45:04.680]  если бы до этого момента, до момента входа в эту, то есть там скажем до окончания обработки этой
[45:04.680 --> 45:10.480]  компоненты правильно обрабатываем все вершины, понимаем кто корень и кто нет, то эти компоненты
[45:10.480 --> 45:18.400]  были бы уже обработаны, то есть мы как бы уже должны были уже и сюда и сюда уже сходить,
[45:18.400 --> 45:25.800]  идентифицировать и достать их из стек, правда, то есть просто идея такая, да, что, то есть идея будет
[45:25.800 --> 45:33.520]  такая, что мы сохраняем оптайм, но при этом нам надо отличать, что это вершину мы уже достали из стека,
[45:33.520 --> 45:40.680]  вот как это какие как наиболее удобным способом это значит пометить,
[45:40.680 --> 45:54.880]  нет, нет, но да, нет, нет, но да, super black удобнее, да, да, то есть тарьян называет этот цвет фиолетовым,
[45:54.880 --> 46:03.120]  да, то есть теперь у нас в DFS будет 4 света белый, серый, черный и фиолетовый, логично,
[46:03.120 --> 46:17.520]  вот значит значит смотрите поэтому пишем значит теперь update значит color от st точка топ
[46:17.520 --> 46:23.640]  значит теперь у нас равен e dfs purple
[46:23.640 --> 46:27.720]  вот
[46:27.720 --> 46:37.040]  да нет нет на полном серьезе в статье такое написано вот
[46:37.040 --> 46:48.440]  вот значит теперь и теперь оптим надо определить значит и оптим теперь предлагается значит
[46:48.440 --> 46:54.640]  значит он сохраняется так оптим 2 убираем так что смотрите там у себя если написал кто случайно
[46:54.640 --> 47:04.320]  вот вот значит поэтому пишем так обратное ребро или перекрестное
[47:04.320 --> 47:23.920]  ребро ведущие вне фиолетовую вершину
[47:23.920 --> 47:42.160]  ну перекрестная перекрестная будет вести в черную обратная в серую вот ну можете этот
[47:42.160 --> 47:47.320]  дипричастный оборот или как-то называется вот соответственно относить именно к перекрестному
[47:47.320 --> 47:59.320]  ребро так одни причастный оборот да причастный просто причастный господи не я как давно это было
[47:59.320 --> 48:08.920]  да вот вне фиолетового давно это было как говорится по-русскому там 82 поэтому поэтому
[48:08.920 --> 48:24.840]  ну ну я утверждаю что да я утверждаю что вот то есть да как теперь это сделать значит ну значит
[48:24.840 --> 48:32.280]  вот в этом эфе тогда про перекрестное ребро надо еще теперь написать надо вот сюда написать что
[48:32.280 --> 48:44.160]  есть а нет уже а смотрите дал да обратите внимание уже ничего не надо писать да то есть продал но
[48:44.160 --> 48:49.040]  правда единственное только что мы фиолетов с фиолетовой вершины не делаем ничего хорошо давайте
[48:49.040 --> 48:55.160]  давайте да то есть давайте чтобы отметить что теперь этот случай есть да это мы так значит да
[48:55.160 --> 49:06.440]  мы не забываем так сейчас нет это зря сделал да значит смотрите во-первых надо брякнуться как-то
[49:06.440 --> 49:12.680]  черная как раз и нужно потому что у нас как раз такие прекрасно и вы ведущих черную вершину
[49:12.680 --> 49:33.040]  нас интересует так значит теперь дальше пишем кейс едф с перпл ну короче пум-пум все так и
[49:33.040 --> 49:50.600]  соответственно такой а вот эту скопочку и надо убрать вот а то оставить вот так вот вот да то
[49:50.600 --> 49:59.960]  есть вот утверждается что в таком экзотическом виде это будет работать значит за 3 но на самом
[50:00.120 --> 50:03.280]  деле доказательства будет по индукции причем по таймыну
[50:03.280 --> 50:25.960]  хотя нет по таймин не получил и значит что мы еще можем в него пойти я ну по индукса индукса
[50:25.960 --> 50:31.160]  нам потребуется чтобы предполагать что там все вот эти компоненты мы уже правильно идентифицированы
[50:31.160 --> 50:38.760]  эти вершины уже фиолетовая да только индукция даже я попав не по таймыну а по таймалту да мы
[50:38.760 --> 50:46.960]  его не считаем но как бы понятно он есть то есть тогда смотрите какая действительно идея будет
[50:46.960 --> 50:55.400]  то есть тогда доказательства звучит так то есть вот у нас есть вот эти вершины тогда но вот то
[50:55.400 --> 51:01.720]  есть надо показать что эта вершина будет идентифицирована как корень компоненты а все
[51:01.720 --> 51:12.560]  вот эти вершины как корень компоненты идентифицированы не будут понятно да как же мы это будем доказывать вот
[51:12.560 --> 51:19.480]  но доказывать так но первых заметим что мы из этой вершины выйдем последними правда то есть мы
[51:19.840 --> 51:28.440]  в этом дереве мы в нее первый войдем последний выйдем правда но теперь заметим что в нот что
[51:28.440 --> 51:37.600]  внутри у каждой вершины из вот у каждой по вершины которые не корень внутри ее под дерево то есть
[51:37.600 --> 51:43.400]  изнутри ее под дерево есть выход по перекрестному ребру или по обратному ребру внука который но
[51:43.400 --> 51:50.560]  который ведет нас внутрь этой же компоненты правда но если мы предполагаем по индукции что
[51:50.560 --> 51:56.320]  в чем ведет она нас тут тут важно тут важный момент что перекрестное ребро ну как бы обратное
[51:56.320 --> 52:02.240]  ребро ведет нас предка вот то есть как бы если из этого под дерево есть обратное ребро ведущие
[52:02.240 --> 52:09.400]  выше то понятно что уже об тайм будет меньше и будет все в порядке правда вот а если тут вывод
[52:09.400 --> 52:15.960]  перекрестная то тут важный момент что перекрестное ребро ведет нас в ребро который у которого не
[52:15.960 --> 52:21.760]  просто таймы меньше но у него таймы и даже таймаут по идее меньше чем все вот это под дерево правда
[52:21.760 --> 52:30.240]  вот раз уж мы вышли из этого под дерево вот то есть это означает что мы из этой вершины уже
[52:30.240 --> 52:35.760]  вышли и по предположении индукции уже корректно определили что эта вершина корнем не является
[52:35.760 --> 52:42.800]  следовать на наутекущий момент является черной ибо но да более того тут никто тут черным не
[52:42.800 --> 52:48.000]  является поэтому то есть никто тут корнем не был идентифицирован поэтому она пока еще черная
[52:48.000 --> 52:59.040]  следовательно никто лишний корнем не будет так остается только убедиться в том что корень
[52:59.040 --> 53:06.160]  компоненты окажется корнем то есть ее об тайм никуда не выйдет но как это доказать ну заметим
[53:06.160 --> 53:13.000]  что и самой вот этой компоненты у нас все перекрестные ребра могут видеть там перекрестные обратные
[53:13.000 --> 53:19.720]  ребра там выше не выше никуда то есть они выше никуда не поведут но с другой стороны из этой
[53:19.720 --> 53:25.720]  компоненты обратные ребра будут вести в какие-то уже ранее обойденные компоненты которые по тому
[53:25.720 --> 53:35.080]  же предположению индукции уже были идентифицированы вот казалось бы быть все в порядке то есть уже то
[53:35.080 --> 53:43.440]  есть они то есть то есть они как бы они на момент рассмотрения ребер они были уже фиолетовая да вот
[53:43.440 --> 53:48.080]  но отсюда собственно и следует что корень будет корректно идентифицирован как корень и собственно
[53:49.080 --> 53:57.360]  так что вот так что вот оказывается на самом деле вот таким вот образом можно искать компоненты
[53:57.360 --> 54:11.400]  сильной связности пока пока мы сейчас не сядем его доказывать да мы сейчас посмотрим вот хотя
[54:11.400 --> 54:16.480]  вот и не за хотя иногда нет иногда бывает кс я вот люблю вот нет нета написать вот так
[54:16.480 --> 54:28.440]  да потому что видим кстати код в общем-то оказался не сильно сложный ну типа да ой ну
[54:28.440 --> 54:33.720]  по этой локе да кто-то там предлагал вообще когда-то там просто надо ваше супер шаблонный
[54:33.720 --> 54:46.680]  дфс написать так от дерева это не дерево это граф в котором мы запустили дфс ну вот так
[54:46.680 --> 55:02.640]  что вот такая красота так ну что есть ли еще тут какие-то вопросы да нет наверное
[55:04.600 --> 55:09.920]  чего бесполезно вопрос создавать бесполезно
[55:09.920 --> 55:20.960]  нет тут все понятно хорошо да но тут конечно да нельзя не упомянуть что конечно да в олимпиады
[55:20.960 --> 55:28.040]  среде более популярен почему-то другой алгоритм ну там ну как всегда пуши ну как всегда и отчасти
[55:28.040 --> 55:36.440]  это называется возможно по историческим причинам может быть нет узнаете тут как бывает то
[55:36.440 --> 56:00.440]  есть иногда иногда бывает так как в моду вошло потому что как бы нет ну не знаю тут не но это
[56:00.440 --> 56:04.120]  интересно может да нет может действительно когда-то да может когда кто-то прочитал статью
[56:04.120 --> 56:08.680]  рассказывал это потом кто-то узнал что существует алгоритм двумя дфс ами он рассказ все стали
[56:08.680 --> 56:26.320]  рассказывать потом с тех пор об этом алгоритме забыли нет у графа нет ну как бы граф и граф есть
[56:26.320 --> 56:43.240]  граф тут ничего не поделаешь он всегда есть нет ну да нет понятно да но давайте разбираться
[56:43.240 --> 56:50.480]  потому что да тут то есть это вот назывался алгоритм тарьяна да как вы догадались вот есть
[56:50.480 --> 57:00.320]  конечно вот то есть выясняется что есть конечно алгоритм косарая да вот то есть он предлагает
[57:00.320 --> 57:07.760]  я но то есть не что более тривиальная то есть он предлагает запустить из всех вершин дфс
[57:07.760 --> 57:18.880]  один который будет работать примитивным образом да но вот так и как он будет работать так ну а
[57:18.880 --> 57:31.480]  первых давайте так он скажет л ст точку push front нет push front нет неправда не так рано рано рано
[57:31.480 --> 57:41.480]  согласен да значит то есть пишем тут юзет от в равно труда никаких этих цветов этих ваших на
[57:41.480 --> 57:54.960]  этот раз просто так for int у пум пум граф от в да вот и тут предлагается значит понятно
[57:54.960 --> 58:07.920]  что если не юзет от у то дфс 1 от у и в конце добавить в какой эту вершину в какой-то список
[58:07.920 --> 58:25.120]  только добавить ее в начало то есть push front от в вот вот но потом соответственно
[58:25.120 --> 58:32.560]  а потом неожиданно появляется дфс 2 в котором уже просто видим вершину записываю в компонент
[58:32.560 --> 58:47.720]  то есть юзет от в равно тру соответственно значит комп точка push back уже по барабану
[58:47.720 --> 58:57.880]  от в и да но дальше правда тут начинается фишка потому что потому что у мы теперь берем в
[58:57.880 --> 59:19.320]  реверсинг графе ну тут по классике не юзет от у то дфс 2 так и конечно самое важное как мы эти
[59:19.320 --> 59:33.720]  дфс запускаем запускаем мы оказывается теперь так то есть во первых юзет точка ассайн как
[59:33.720 --> 59:49.440]  всегда там на n и false вот значит тут перебираем тупо там for int там в равно от нуля dn-1 значит если
[59:49.440 --> 01:00:04.800]  не юзет от в то дфс 1 вот результате такого дфс у нас образовался список лст какой-то
[01:00:04.800 --> 01:00:12.600]  глобальный то есть ну как как у нас называется список в которой можно делать push front ну например
[01:00:12.600 --> 01:00:21.420]  дэк да ну можно но как бы зачем когда у нас есть да потому что давайте что давайте будем считать
[01:00:21.420 --> 01:00:37.120]  что у нас есть вектор вектор int во первых граф и реверсент граф это мы должны вектор графы
[01:00:37.120 --> 01:00:48.440]  реверсент граф и что-то еще ну во первых да и давайте вот вектор int юзет ну можно можно
[01:00:48.440 --> 01:01:00.200]  был но не хочется марачиваться и конечно его величество дэк дэк int лст вот
[01:01:00.200 --> 01:01:24.320]  нет чего чего бы ну летники а ну может не оно по разному можно колор но ладно раз уж мы компоненты
[01:01:24.320 --> 01:01:31.640]  там там по векторам пихом пишем поэтому давайте так нет понятно что да понятно что там олимпиадом
[01:01:31.640 --> 01:01:41.040]  коди чаще там просто как там легче калор и там писать это да ну вот но соответственно если кто-то
[01:01:41.040 --> 01:01:50.000]  да осталось только чтоб ныряли олимпиаде это вообще пригодилось а было все прям ныряли олимпиаде
[01:01:50.000 --> 01:02:02.880]  они там на сборах каких-нибудь гурма о господи ладно так вот значит поехали значит продолжим
[01:02:02.880 --> 01:02:11.960]  значит юзет точка значит опять ассайн ладно там н 0 по барабану и тут давайте 0 тогда писать
[01:02:12.560 --> 01:02:30.440]  так теперь пишем for int в 2.л ст значит берем вершину и говорим что если она не юзет то что
[01:02:30.440 --> 01:02:44.400]  мы делаем то мы говорим что комп точка clear dfs 2 от в и что-то еще а ну и как всегда сохранить
[01:02:44.400 --> 01:03:03.840]  комп как сс вот да ну да вот такой вот датчик такая вот интерпретация лг и да здесь конечно
[01:03:03.840 --> 01:03:07.560]  важно отметить что здесь мы запускаем на прозвернутому графу что такое развернутый
[01:03:07.560 --> 01:03:13.600]  граф это граф в котором это мы взяли исходный граф и внезапно развернули в нем все
[01:03:13.600 --> 01:03:28.560]  рёбра под совершенно внезапно развернули в нем все рёбра вот так знаете что вот уже такой
[01:03:28.560 --> 01:03:32.200]  простой алгоритм действительно на самом деле спокойно ищет компоненты заморачиваться не надо
[01:03:32.200 --> 01:03:40.520]  единственное у него недостаток единственный что он делает 2 dfs а не один нет ну как бы рекурсия
[01:03:40.520 --> 01:03:48.520]  все-таки да но правда что страшнее константа от рекурсии или звать константа от рекурсии или
[01:03:48.520 --> 01:03:53.120]  там подсчеты которые там вторяне это еще вопрос хотя автор я не на самом деле ничего страшного
[01:03:53.120 --> 01:04:01.200]  не считается но то есть как часто в динамике бывает страшно бывает идейно но там нагрузочно
[01:04:01.200 --> 01:04:08.400]  там ничего нет вот то есть там то ли то только там таймы на аптайм а тут этого нет просто что
[01:04:08.440 --> 01:04:13.640]  покрасили то покрасили но теперь стоит столько разобраться а почему это вообще работает
[01:04:13.640 --> 01:04:25.480]  до до а до ася на экзамене спрашивал да что так что без проблем без проблем скажешь слово
[01:04:25.480 --> 01:04:35.400]  тривиально ну ну там аки не значит итак ну давайте смотреть как же это доказывать так ну заметим
[01:04:35.400 --> 01:04:42.320]  что ну дерево да ну в общем-то такая вот структура дфс общем-то никуда не делась вот первые на
[01:04:42.320 --> 01:04:47.560]  самом деле так если рассмотреть первый дфс то в общем-то относительно деревьев дфс вот эти
[01:04:47.560 --> 01:05:05.360]  компоненты все еще те же самые деревья образуют ну да нет ну да вот видите что-то второе
[01:05:05.800 --> 01:05:12.240]  обращаем я что второй дфс мы запускаем запускаем в порядке ну в порядке л ст но в ст мы добавляем
[01:05:12.240 --> 01:05:17.640]  в начало обычно конечно это рассказывается заклинанием вида что мы во втором дфс и мы
[01:05:17.640 --> 01:05:27.000]  запускаемся в порядке выхода первого дфс а вот причем не не в обратном чем в обратном порядке
[01:05:27.000 --> 01:05:35.760]  поэтому и в начало запихивает но с другой стороны теперь заметим что приятно во первых заметим
[01:05:35.760 --> 01:05:42.200]  маленькую приятную вещь начнем вот у каждой компоненты есть корень теперь заметим маленькую
[01:05:42.200 --> 01:05:50.920]  приятную вещь что в каждой компоненте корень это такая вершина в которую дфс первым вошел и
[01:05:50.920 --> 01:05:59.000]  последним вышел поэтому поэтому во первых заметим что когда мы будем бежать потом по этому л ст мы
[01:05:59.000 --> 01:06:06.640]  у каждой компоненты увидим сначала корень а потом все остальное следовательно то есть получается
[01:06:06.640 --> 01:06:14.440]  мы гарантируем что когда мы идем по л ст мы увидели корень и запустили его дфс и по обратным
[01:06:14.440 --> 01:06:22.560]  ребрам уж его компоненту точно обошли правда вот правда единственная недостатка единственная
[01:06:22.560 --> 01:06:28.360]  проблема что помимо этого мы могли обойти что-то еще но с другой стороны верно но утверждается что
[01:06:28.360 --> 01:06:36.080]  то есть очевидным является такое утверждение что каждый запуск дфс а2 он как бы обошел несколько
[01:06:36.080 --> 01:06:46.640]  компонент одну или несколько компонент целиком но пока теоретически мог как мы чуть позже докажем
[01:06:46.640 --> 01:06:53.000]  не мог но утверждается такое ну давайте так рассмотрим самый первый дфс 2 я отражаю следующий
[01:06:53.000 --> 01:07:03.320]  зашел в какую-то компоненту просто зашел да то он обошел ее всю да нет не очевидно что только ее
[01:07:06.080 --> 01:07:14.080]  да ну то нет вопроса тут что именно очевидно просто вот же так если дфс 2 обошел в какую-то
[01:07:14.080 --> 01:07:18.760]  компоненту впервые то этот же дфс 2 обошел ее это полемия белых путях просто очевидно
[01:07:18.760 --> 01:07:24.960]  другой вопрос что это из этого не следует что дфс 2 не мог там за один присест обойти несколько
[01:07:24.960 --> 01:07:35.000]  компонент и тут уже придется немножко подумать то есть такие заметить тут тут надо заметить более
[01:07:35.000 --> 01:07:47.400]  тонкие вещи какие тонкие вещи а вот какие то есть дело в том что но вот какие что какие
[01:07:47.400 --> 01:07:53.880]  же более тонкие вещи придется заметить но первых заметим конечно что если сжать все компоненты
[01:07:53.880 --> 01:08:03.680]  сильно связаны в одну вершину то у нас получится ациклический граф логично да вот но теперь
[01:08:03.680 --> 01:08:09.520]  соответственно очень хочется показать маленькую приятную вещь очень хочется показать то есть на
[01:08:09.520 --> 01:08:16.680]  самом деле все что нам нужно показать это то что если у нас допустим у нас была какая-то были
[01:08:16.680 --> 01:08:23.440]  какие-то две компоненты сильной связности тут был корень и тут бы там тут какая-то компонента
[01:08:24.440 --> 01:08:46.000]  и допустим выяснилось что между ними есть какое-то ребро вот ну просто нет но это не важно нет это по
[01:08:46.360 --> 01:08:50.600]  не важно то есть хочется пока достаточно что если между двумя компонентами есть
[01:08:50.600 --> 01:08:58.840]  ребро то тогда очень хочется сказать что тогда и из этой вершины то есть из этого
[01:08:58.840 --> 01:09:12.000]  корня мы вышли позже чем из этого очень хочется такое сказать если мы вышли из
[01:09:12.000 --> 01:09:16.600]  из этого корня, то мы уже обошли все вершины, достиженные из него.
[01:09:16.600 --> 01:09:19.600]  Ребро между компонентами может быть только перекрёстным, нет?
[01:09:19.600 --> 01:09:21.600]  А нет, оно ещё может быть...
[01:09:21.600 --> 01:09:23.600]  Оно прямым ещё может быть.
[01:09:23.600 --> 01:09:25.600]  Давайте пронумеруем корни.
[01:09:25.600 --> 01:09:27.600]  Ну да.
[01:09:27.600 --> 01:09:30.600]  Если мы вышли из первого, то мы точно уже обошли второй.
[01:09:30.600 --> 01:09:34.600]  Нет, ну в принципе да.
[01:09:34.600 --> 01:09:38.600]  Нет, ну заметим следующее.
[01:09:39.200 --> 01:09:41.200]  Ну давайте так попробуем.
[01:09:41.200 --> 01:09:43.200]  По-разному можно рассуждать.
[01:09:43.200 --> 01:09:47.200]  Рассмотрим момент времени, когда мы вошли в root 1.
[01:09:49.200 --> 01:09:55.200]  Тогда что у нас могло быть с вот этой компонентой?
[01:09:58.200 --> 01:10:01.200]  Тут надо аккуратно, потому что очень хочется сказать,
[01:10:01.200 --> 01:10:05.200]  что она либо была полностью обойдена, либо полностью не обойдена.
[01:10:05.800 --> 01:10:07.800]  Ну вот.
[01:10:07.800 --> 01:10:10.800]  Но это, конечно, может быть не совсем аккуратно.
[01:10:10.800 --> 01:10:12.800]  Там всякое такое могло быть.
[01:10:12.800 --> 01:10:18.800]  Но на самом деле так.
[01:10:18.800 --> 01:10:20.800]  Смотрите.
[01:10:20.800 --> 01:10:22.800]  То есть на самом деле так.
[01:10:22.800 --> 01:10:24.800]  Допустим, мы вошли в эту компоненту.
[01:10:24.800 --> 01:10:26.800]  DFS тут ходил-ходил.
[01:10:26.800 --> 01:10:30.800]  И в какой-то момент захотел пойти по вот этому ребру.
[01:10:32.800 --> 01:10:34.800]  Что могло произойти?
[01:10:35.400 --> 01:10:39.400]  Так, какой эта вершина могла оказаться?
[01:10:39.400 --> 01:10:43.400]  Она могла оказаться в этот момент белой, серой и черной.
[01:10:43.400 --> 01:10:45.400]  Правда?
[01:10:45.400 --> 01:10:47.400]  Так, ну давайте посмотрим.
[01:10:47.400 --> 01:10:49.400]  Если она оказалась белой.
[01:10:51.400 --> 01:10:53.400]  То что тогда?
[01:10:53.400 --> 01:10:59.400]  Ну тогда я утверждаю, что все эти вершины сейчас белые.
[01:11:02.400 --> 01:11:04.400]  Очевидно.
[01:11:05.000 --> 01:11:07.000]  Ну действительно.
[01:11:07.000 --> 01:11:11.000]  Потому что дело в том, что заметим, что из этой вершины до всех этих вершин дойти можно.
[01:11:13.000 --> 01:11:15.000]  Вот.
[01:11:15.000 --> 01:11:19.000]  Нет, а самое главное и наоборот.
[01:11:21.000 --> 01:11:23.000]  Тогда что?
[01:11:23.000 --> 01:11:25.000]  Ну что тут тогда могло произойти?
[01:11:25.000 --> 01:11:27.000]  То есть тогда если вот так вот.
[01:11:27.000 --> 01:11:29.000]  Ну можно идти тогда до корня.
[01:11:29.000 --> 01:11:31.000]  Утверждается, что как минимум корень белый.
[01:11:31.000 --> 01:11:33.000]  Почему?
[01:11:33.000 --> 01:11:35.000]  Ну давайте смотреть.
[01:11:35.000 --> 01:11:37.000]  Хотя давайте посмотрим.
[01:11:37.000 --> 01:11:39.000]  Что вообще могло тут произойти?
[01:11:39.000 --> 01:11:41.000]  Ну могло произойти, что мы идем по этому пути до корня.
[01:11:41.000 --> 01:11:45.000]  И где-то у нас тут неожиданно обнаружилась черная вершина.
[01:11:45.000 --> 01:11:47.000]  А что такое корень?
[01:11:47.000 --> 01:11:49.000]  Если мы попали в первый раз в вершину.
[01:11:51.000 --> 01:11:55.000]  Нет, в смысле корень дерева ДФС.
[01:11:55.000 --> 01:11:57.000]  Может быть он определится в будущем, что это будет корень?
[01:11:59.000 --> 01:12:01.000]  Ну как бы, да.
[01:12:01.000 --> 01:12:03.000]  Если вот полностью рассмотреть ДФС.
[01:12:03.000 --> 01:12:07.000]  То в каждой компоненте он индуцировал такой корень на ребрах дерева ДФС.
[01:12:07.000 --> 01:12:09.000]  Так.
[01:12:09.000 --> 01:12:11.000]  Ну значит если у нас эта вершина белая.
[01:12:11.000 --> 01:12:13.000]  Ну смотрим.
[01:12:13.000 --> 01:12:15.000]  Тогда на этом пути до корня.
[01:12:15.000 --> 01:12:17.000]  И вот допустим образовалась не белая.
[01:12:17.000 --> 01:12:19.000]  Черная она быть не могла.
[01:12:19.000 --> 01:12:21.000]  Ну у нас не бывает такого.
[01:12:21.000 --> 01:12:25.000]  Что у нас в какой-то момент из черной вершины ведет ребро в белую.
[01:12:25.000 --> 01:12:27.000]  Ну просто не бывает такого. Правда?
[01:12:27.000 --> 01:12:29.000]  Ну что могло быть?
[01:12:29.000 --> 01:12:31.000]  Ну вот.
[01:12:31.000 --> 01:12:33.000]  Она конечно могла случайно оказаться серой.
[01:12:35.000 --> 01:12:37.000]  Да.
[01:12:37.000 --> 01:12:39.000]  Но что это означает?
[01:12:39.000 --> 01:12:41.000]  Серая это означает, что она
[01:12:41.000 --> 01:12:43.000]  во-первых, что она просто предок вот этой вершины.
[01:12:43.000 --> 01:12:45.000]  А на самом деле просто предок вот всего этого.
[01:12:45.000 --> 01:12:47.000]  Что такое серая вершина?
[01:12:47.000 --> 01:12:49.000]  Помните, да?
[01:12:49.000 --> 01:12:51.000]  То есть серая это то, что у нас сейчас в стеке лежит.
[01:12:51.000 --> 01:12:53.000]  То есть получается из этой вершины,
[01:12:53.000 --> 01:12:55.000]  на самом деле,
[01:12:55.000 --> 01:12:57.000]  то есть тут как будто вот куда-то ниже,
[01:12:57.000 --> 01:12:59.000]  на самом деле мы вот сюда и придем.
[01:13:03.000 --> 01:13:05.000]  А почему так не бывает?
[01:13:05.000 --> 01:13:07.000]  Ну да.
[01:13:07.000 --> 01:13:09.000]  Нет, тогда это, ну да, то есть это,
[01:13:09.000 --> 01:13:11.000]  отсюда на самом деле автоматически следует,
[01:13:11.000 --> 01:13:13.000]  что вот этот как минимум пути
[01:13:13.000 --> 01:13:15.000]  следует и все это тоже должно быть в одной компоненте.
[01:13:15.000 --> 01:13:17.000]  А почему, кстати?
[01:13:17.000 --> 01:13:19.000]  А, ну потому что, ну вот.
[01:13:21.000 --> 01:13:23.000]  Ну да, потому что мы из корня можем дойти
[01:13:23.000 --> 01:13:25.000]  до сюда и отсюда можем добраться до корня.
[01:13:25.000 --> 01:13:27.000]  Ну там скажем, сюда и так далее.
[01:13:27.000 --> 01:13:29.000]  Да. То есть серая вершина у нас тут
[01:13:29.000 --> 01:13:31.000]  тоже на пути не будет.
[01:13:31.000 --> 01:13:33.000]  Ну следовательно, действительно
[01:13:33.000 --> 01:13:35.000]  все у нас эти, то есть
[01:13:35.000 --> 01:13:37.000]  все у нас тут белое получается.
[01:13:37.000 --> 01:13:39.000]  Ну белое, белое, белое и вообще
[01:13:39.000 --> 01:13:41.000]  в принципе оказывает, даже можно не до корня
[01:13:41.000 --> 01:13:43.000]  идти, а просто тут все вершины белые,
[01:13:43.000 --> 01:13:45.000]  потому что, соответственно, ни серых, ни черных
[01:13:45.000 --> 01:13:47.000]  тут нет. По
[01:13:47.000 --> 01:13:49.000]  абсолютно тем же причинам мы
[01:13:49.000 --> 01:13:51.000]  в общем-то особо не пользовались тем, что это
[01:13:51.000 --> 01:13:53.000]  путь до корня. Вот.
[01:13:53.000 --> 01:13:55.000]  Да. То есть если эта вершина
[01:13:55.000 --> 01:13:57.000]  белая, то тут все белое.
[01:13:57.000 --> 01:13:59.000]  И это означает, что мы прямо сейчас
[01:13:59.000 --> 01:14:01.000]  обойдем эту компоненту.
[01:14:01.000 --> 01:14:03.000]  Да. Ну правда, вот эта вершина
[01:14:03.000 --> 01:14:05.000]  должна оказаться корнем. Но это вполне
[01:14:05.000 --> 01:14:07.000]  может быть такое. То есть это будет скорее вот
[01:14:07.000 --> 01:14:09.000]  какой-то вот такой случай.
[01:14:09.000 --> 01:14:11.000]  То есть мы ее обойдем. И тогда
[01:14:11.000 --> 01:14:13.000]  из этого корня мы выйдем действительно
[01:14:13.000 --> 01:14:15.000]  раньше, чем из этой. Потому что мы ее
[01:14:15.000 --> 01:14:17.000]  обработаем, а из этой мы еще не вышли.
[01:14:17.000 --> 01:14:19.000]  Да. То есть если
[01:14:19.000 --> 01:14:21.000]  она белая, то все в порядке.
[01:14:21.000 --> 01:14:23.000]  То есть действительно все в порядке.
[01:14:23.000 --> 01:14:25.000]  Так. Что еще может быть?
[01:14:27.000 --> 01:14:29.000]  Следующий случай говорит нам о том,
[01:14:29.000 --> 01:14:31.000]  что у нас эта вершина серая.
[01:14:33.000 --> 01:14:35.000]  Ну здесь все гораздо проще. Да,
[01:14:35.000 --> 01:14:37.000]  серая. Ну да. То есть
[01:14:37.000 --> 01:14:39.000]  серая это означает, что действительно
[01:14:39.000 --> 01:14:41.000]  все вот это вот в одной компоненте связности
[01:14:41.000 --> 01:14:43.000]  противоречит.
[01:14:43.000 --> 01:14:45.000]  Ну и если она черная.
[01:14:47.000 --> 01:14:49.000]  Но заметим, что
[01:14:51.000 --> 01:14:53.000]  ну
[01:14:55.000 --> 01:14:57.000]  почему перекрестные теоретически может быть и
[01:14:57.000 --> 01:14:59.000]  прямое какое-нибудь.
[01:15:01.000 --> 01:15:03.000]  Ну вот. Нет, да,
[01:15:03.000 --> 01:15:05.000]  теоретически такое вполне может быть, кстати.
[01:15:05.000 --> 01:15:07.000]  Вот пример.
[01:15:07.000 --> 01:15:09.000]  Вот. Но это даже не важно.
[01:15:09.000 --> 01:15:11.000]  Так. Если она черная.
[01:15:11.000 --> 01:15:13.000]  Так. Если эта вершина черная.
[01:15:15.000 --> 01:15:17.000]  Ну давайте смотреть.
[01:15:17.000 --> 01:15:19.000]  Так.
[01:15:19.000 --> 01:15:21.000]  Ну тогда утверждается, что
[01:15:21.000 --> 01:15:23.000]  вся эта компонента тоже черная.
[01:15:23.000 --> 01:15:25.000]  Ну потому что
[01:15:25.000 --> 01:15:27.000]  мы уже просто выяснили, что
[01:15:27.000 --> 01:15:29.000]  ну потому что, во-первых, да, мы
[01:15:29.000 --> 01:15:31.000]  из этой вершины можем обойти,
[01:15:31.000 --> 01:15:33.000]  просто пройти до всех вершин. Вот как-то вот так,
[01:15:33.000 --> 01:15:35.000]  вот так, вот так. Ну как-то там.
[01:15:35.000 --> 01:15:37.000]  Но заметим, что все тогда вот эти вершины
[01:15:37.000 --> 01:15:39.000]  они белыми быть уже право не имеют.
[01:15:39.000 --> 01:15:41.000]  Следовательно они все
[01:15:41.000 --> 01:15:43.000]  либо серые, либо черные.
[01:15:43.000 --> 01:15:45.000]  Но если у нас тут кто-то серый, значит это опять
[01:15:45.000 --> 01:15:47.000]  одна компонента. Правда?
[01:15:47.000 --> 01:15:49.000]  То есть значит эти все вершины черные,
[01:15:49.000 --> 01:15:51.000]  значит мы эту же компоненту уже когда-то
[01:15:51.000 --> 01:15:53.000]  обошли, и этот корень уже тоже
[01:15:53.000 --> 01:15:55.000]  ну вот и вышли из нее раньше,
[01:15:55.000 --> 01:15:57.000]  чем из этой.
[01:15:57.000 --> 01:15:59.000]  Вот.
[01:15:59.000 --> 01:16:01.000]  То есть смотрите, то есть оказалось следующее.
[01:16:01.000 --> 01:16:03.000]  То есть убедились
[01:16:03.000 --> 01:16:05.000]  мы теперь в следующем.
[01:16:05.000 --> 01:16:07.000]  То есть это означает такое,
[01:16:07.000 --> 01:16:09.000]  что если между двумя компонентами
[01:16:09.000 --> 01:16:11.000]  сильной связности есть ребро,
[01:16:11.000 --> 01:16:13.000]  ведущий из одной компоненты
[01:16:13.000 --> 01:16:15.000]  в другую, то корень
[01:16:15.000 --> 01:16:17.000]  этой компоненты мы встретим
[01:16:17.000 --> 01:16:19.000]  в листе раньше,
[01:16:19.000 --> 01:16:21.000]  чем корень вот этой.
[01:16:21.000 --> 01:16:23.000]  То есть если рассмотреть
[01:16:23.000 --> 01:16:25.000]  именно корни в листе,
[01:16:25.000 --> 01:16:27.000]  то они будут идти в порядке топологической
[01:16:27.000 --> 01:16:29.000]  сортировки конденсации.
[01:16:29.000 --> 01:16:31.000]  Вот.
[01:16:31.000 --> 01:16:33.000]  Какое пафосное словосочетание.
[01:16:33.000 --> 01:16:35.000]  Вот.
[01:16:35.000 --> 01:16:37.000]  Вот.
[01:16:37.000 --> 01:16:39.000]  Ну и вот.
[01:16:39.000 --> 01:16:41.000]  Ну и в общем-то все.
[01:16:41.000 --> 01:16:43.000]  Ну вот.
[01:16:43.000 --> 01:16:45.000]  То есть такое, да, то есть пришлось немножко пострадать.
[01:16:45.000 --> 01:16:47.000]  Но тем не менее.
[01:16:47.000 --> 01:16:49.000]  То есть такое, конечно алгоритм...
[01:16:49.000 --> 01:16:51.000]  То есть такое алгоритм
[01:16:51.000 --> 01:16:53.000]  конечно получился немножко.
[01:16:53.000 --> 01:16:55.000]  То есть просто пишется, но может быть сложно
[01:16:55.000 --> 01:16:57.000]  доказывается.
[01:16:57.000 --> 01:16:59.000]  Предыдущий алгоритм, правда, не скажешь, что он
[01:16:59.000 --> 01:17:01.000]  просто доказывается совсем.
[01:17:01.000 --> 01:17:03.000]  Ну я бы сказал, по уровню
[01:17:03.000 --> 01:17:05.000]  примерно то же самое.
[01:17:05.000 --> 01:17:07.000]  Ну вот.
[01:17:07.000 --> 01:17:09.000]  Но тем не менее вот такой вот
[01:17:09.000 --> 01:17:11.000]  фокус. Так это у нас
[01:17:11.000 --> 01:17:24.880]  касается компонент сильной связности для кого для вот этого нет почему не надо ну а ну хотя ну как
[01:17:24.880 --> 01:17:30.240]  так но на каком-то уровне надо потому что понятия на тему того черные белые что там каких-то ребер
[01:17:30.240 --> 01:17:40.800]  не бывает надо то есть да нам тут не нужно знать что такое обратные перекрестные ребра да
[01:17:40.800 --> 01:17:44.800]  ну то есть такую базу надо то есть да тут не надо знать что черные белые перекрестные как их
[01:17:44.800 --> 01:17:51.600]  обходить вот дай тем более но фиолетовая честно говоря водится только чисто для
[01:17:51.600 --> 01:17:57.400]  чисто в компонентах сильной связности больше их нигде не видел вот нет но просто с другой
[01:17:57.400 --> 01:18:01.960]  стороны тоже конечно интересно что это технология которая но с другой стороны проблема такая к
[01:18:01.960 --> 01:18:06.400]  сожалению для компонент вершины двух связностей мне какого-то там алгоритма который основан
[01:18:06.400 --> 01:18:11.520]  в чем-то подобном неизвестно нет мне кто-то сказал что там по-моему кто-то там рассказывает что
[01:18:11.520 --> 01:18:15.400]  там компоненты вершины двух связностей можно искать там как-то типа найдем точнее сочленение
[01:18:15.400 --> 01:18:21.960]  потом будем там что-то там смотреть то есть это там рассказывает но утверждал что там выизвать
[01:18:21.960 --> 01:18:26.080]  получается какая-то черная магия нет ну-ка ну кто сказал что наоборот там
[01:18:26.080 --> 01:18:33.160]  правда а
[01:18:34.080 --> 01:18:35.760]  LAUGHTER
[01:18:40.240 --> 01:18:42.560]  может но
[01:18:45.440 --> 01:18:50.240]  это sleeper на первых ежеджит вванедь 있을 earliest а во captures не есть некоторые
[01:18:50.240 --> 01:18:56.240]  но дочерние компоненты разбиваются на отрезки по тейнтаутам.
[01:18:56.240 --> 01:19:02.240]  Разбиваются на отрезки по тейнтаутам?
[01:19:02.240 --> 01:19:04.240]  Нет, почему?
[01:19:04.240 --> 01:19:07.240]  По-моему, что вот так? По-моему, нет.
[01:19:07.240 --> 01:19:09.240]  Потому что компоненты никак встроены.
[01:19:09.240 --> 01:19:14.240]  Вот допустим одно дерево компоненты, и тут на нем висит второе.
[01:19:14.240 --> 01:19:17.240]  Ну ладно, вот висит вот так второе.
[01:19:17.240 --> 01:19:20.240]  Хорошо, и как бы понятно.
[01:19:20.240 --> 01:19:24.240]  И тут тейну тайм-аута будет 1, 2, 3, 4.
[01:19:24.240 --> 01:19:26.240]  И тут будет 5, 6, 7, 8, 9, 10.
[01:19:26.240 --> 01:19:28.240]  А потом тут продолжится 11, 12, 13.
[01:19:28.240 --> 01:19:30.240]  Что значит разбивается?
[01:19:30.240 --> 01:19:34.240]  Если у нас на одной точке висит несколько деревьев,
[01:19:34.240 --> 01:19:40.240]  то можно сопоставить эти деревья в некоторые отрезки.
[01:19:44.240 --> 01:19:46.240]  Нет, но в каждой компоненте так не сопоставишь.
[01:19:46.240 --> 01:19:49.240]  Нет, по дереву, конечно, да.
[01:19:49.240 --> 01:19:53.240]  Но не знаю, там не легче ли окажется просто стэком это идентифицировать потом.
[01:19:53.240 --> 01:19:56.240]  Потому что тоже тут...
[01:20:00.240 --> 01:20:05.240]  Нет, ну просто компоненты можно там пройти тем же стэком найти, на самом деле.
[01:20:05.240 --> 01:20:07.240]  Вот, это уже да.
[01:20:07.240 --> 01:20:12.240]  Так, ну ладно, с Тарьяном мы на эту тему не прощаемся.
[01:20:12.240 --> 01:20:16.240]  Потому что дальше у нас возникает такая вещь, как дерево доминаторов.
[01:20:16.240 --> 01:20:18.240]  Так, ладно.
[01:20:18.240 --> 01:20:20.240]  Сейчас.
[01:20:20.240 --> 01:20:22.240]  Нет, только напомните еще раз.
[01:20:22.240 --> 01:20:24.240]  Кто знает, что такое дерево доминаторов?
[01:20:24.240 --> 01:20:26.240]  Ага.
[01:20:26.240 --> 01:20:28.240]  Примерно, да.
[01:20:28.240 --> 01:20:30.240]  Окей, стало чуть больше.
[01:20:30.240 --> 01:20:32.240]  С прошлого раза стало чуть больше, да.
[01:20:32.240 --> 01:20:34.240]  Видел, что это такое дерево доминаторов?
[01:20:34.240 --> 01:20:36.240]  Ага.
[01:20:36.240 --> 01:20:38.240]  Примерно, да.
[01:20:38.240 --> 01:20:40.240]  Окей.
[01:20:40.240 --> 01:20:42.240]  Чуть больше, да.
[01:20:42.240 --> 01:20:44.240]  Видимо, кто-то приехал из Петрозаводска, да.
[01:20:44.240 --> 01:20:46.240]  А у вас там нет?
[01:20:46.240 --> 01:20:48.240]  А может, у вас там были задачи на дерево доминаторов?
[01:20:48.240 --> 01:20:50.240]  Если были, то мы их не знали.
[01:20:50.240 --> 01:20:52.240]  А, а вы на разбор не ходили, да?
[01:20:52.240 --> 01:20:54.240]  Нет, ходили.
[01:20:54.240 --> 01:20:56.240]  Я ходил, не знал.
[01:20:56.240 --> 01:20:58.240]  А, понятно.
[01:20:58.240 --> 01:21:01.240]  Ну да, потому что у тебя все время вот он знает, что дерево доминаторов, а ты нет, да.
[01:21:01.240 --> 01:21:05.240]  Наверное, там на разборе что-то рассказывали, да.
[01:21:05.240 --> 01:21:07.240]  Ну не сейчас, а после перерыва.
[01:21:07.240 --> 01:21:09.240]  А тогда.
[01:21:09.240 --> 01:21:11.240]  Ладно, все, давайте перерыв.
[01:21:11.240 --> 01:21:13.240]  Потому что дерево доминаторов вещь хорошая.
[01:21:13.240 --> 01:21:15.240]  Так, итак, дерево доминаторов.
[01:21:17.240 --> 01:21:19.240]  Как это, да.
[01:21:19.240 --> 01:21:21.240]  Чем оно приятно, что это одна из тех структур данных,
[01:21:21.240 --> 01:21:23.240]  для которых не сложно ответить,
[01:21:23.240 --> 01:21:25.240]  а зачем это вообще надо?
[01:21:25.240 --> 01:21:27.240]  Потому что конкретно в это нот.
[01:21:27.240 --> 01:21:29.240]  Потому что, честно говоря, я впервые
[01:21:29.240 --> 01:21:34.240]  на эту структуру данных наткнулся в книжке про компиляторы.
[01:21:34.240 --> 01:21:36.240]  Да.
[01:21:36.240 --> 01:21:38.240]  То есть там возникло, потому что
[01:21:38.240 --> 01:21:40.240]  что?
[01:21:40.240 --> 01:21:42.240]  Ну вот.
[01:21:42.240 --> 01:21:44.240]  Ну, то есть более эту вольту там.
[01:21:44.240 --> 01:21:46.240]  То есть, потому что там есть там
[01:21:46.240 --> 01:21:48.240]  какие-то, ну там много книжек про компиляторы.
[01:21:48.240 --> 01:21:50.240]  Сейчас какая у меня была конкретно.
[01:21:50.240 --> 01:21:52.240]  Сейчас у меня тут даже записано вроде.
[01:21:52.240 --> 01:21:54.240]  Так.
[01:21:54.240 --> 01:21:56.240]  Так, так, так. Не Таха Уильямс.
[01:21:56.240 --> 01:21:58.240]  Нет, это не то.
[01:21:58.240 --> 01:22:00.240]  О боже, я забыл какая книжка была.
[01:22:00.240 --> 01:22:02.240]  Так.
[01:22:04.240 --> 01:22:06.240]  Ну ладно.
[01:22:08.240 --> 01:22:10.240]  Так.
[01:22:10.240 --> 01:22:12.240]  А, нет, у меня, ну вот.
[01:22:12.240 --> 01:22:14.240]  А, какие стороны? Нет, у меня тут даже записано, да.
[01:22:14.240 --> 01:22:16.240]  То есть, в принципе, да.
[01:22:16.240 --> 01:22:18.240]  В принципе, есть такая вот
[01:22:18.240 --> 01:22:20.240]  книжка внезапно.
[01:22:20.240 --> 01:22:22.240]  Хотя, интересно, это книжка
[01:22:22.240 --> 01:22:24.240]  или, ну Ахо, да.
[01:22:24.240 --> 01:22:26.240]  А, фу, нет, неправильно.
[01:22:26.240 --> 01:22:28.240]  Нет, не та фамилия.
[01:22:28.240 --> 01:22:30.240]  Ульман.
[01:22:30.240 --> 01:22:32.240]  Но там разные есть.
[01:22:32.240 --> 01:22:34.240]  Вот у меня
[01:22:34.240 --> 01:22:36.240]  утверждается, по крайней мере, у меня здесь, что
[01:22:36.240 --> 01:22:38.240]  есть вот такая книжка.
[01:22:38.240 --> 01:22:40.240]  Ахо Ульман. Принципл сомп компайлер дизайн.
[01:22:40.240 --> 01:22:42.240]  Нет, сразу скажу.
[01:22:42.240 --> 01:22:44.240]  Нет, это не ссылка на то. Там
[01:22:44.240 --> 01:22:46.240]  ничего не написано о том, как искать дерево доминаторов.
[01:22:48.240 --> 01:22:50.240]  Там сказано, что оно есть.
[01:22:52.240 --> 01:22:54.240]  Ну вот.
[01:22:54.240 --> 01:22:56.240]  И нужно оно по оптимизации.
[01:22:56.240 --> 01:22:58.240]  Софта по части оптимизации.
[01:22:58.240 --> 01:23:00.240]  Ну, потому что
[01:23:00.240 --> 01:23:02.240]  часто для оптимизации
[01:23:02.240 --> 01:23:04.240]  в компиляторе нужно.
[01:23:04.240 --> 01:23:06.240]  То есть, компиляторе еще желательно понимать,
[01:23:06.240 --> 01:23:08.240]  что, допустим, программа оказалась
[01:23:08.240 --> 01:23:10.240]  вот в этой точке.
[01:23:10.240 --> 01:23:12.240]  Внимание, вопрос.
[01:23:12.240 --> 01:23:14.240]  А вот в этой точке
[01:23:14.240 --> 01:23:16.240]  была ли она
[01:23:16.240 --> 01:23:18.240]  перед этим в этой точке?
[01:23:18.240 --> 01:23:20.240]  Ну, иногда бывает. Могла быть, могла не быть.
[01:23:20.240 --> 01:23:22.240]  Но хочется иногда понимать, что в этой точке
[01:23:22.240 --> 01:23:24.240]  она точно была.
[01:23:24.240 --> 01:23:26.240]  Например.
[01:23:26.240 --> 01:23:28.240]  Или что-нибудь еще
[01:23:28.240 --> 01:23:30.240]  в этом роде.
[01:23:30.240 --> 01:23:32.240]  Ну, это иногда нот.
[01:23:32.240 --> 01:23:34.240]  Но, допустим, очень помогает, что
[01:23:34.240 --> 01:23:36.240]  если вы тут делаете, допустим,
[01:23:36.240 --> 01:23:38.240]  а плюс равно х, и выясняется,
[01:23:38.240 --> 01:23:40.240]  что у вас тут в этой точке написано
[01:23:40.240 --> 01:23:42.240]  х равно 5, то, в принципе,
[01:23:42.240 --> 01:23:44.240]  можно сразу оптимизировать, что вы там здесь,
[01:23:44.240 --> 01:23:46.240]  допустим, а плюс равно 5. Это такой самый тупой пример,
[01:23:46.240 --> 01:23:48.240]  который возникает.
[01:23:48.240 --> 01:23:50.240]  Вот.
[01:23:50.240 --> 01:23:52.240]  То есть, нот.
[01:23:52.240 --> 01:23:54.240]  То есть, иногда такое хочется.
[01:23:54.240 --> 01:23:56.240]  Поэтому в результате нот.
[01:23:56.240 --> 01:23:58.240]  Можете сначала описать, что имеет эта структура
[01:23:58.240 --> 01:24:00.240]  для тех, кто не знает,
[01:24:00.240 --> 01:24:02.240]  чтобы вы понимали примеры?
[01:24:02.240 --> 01:24:04.240]  Нет, это я просто подвожу.
[01:24:04.240 --> 01:24:06.240]  Нет, это я подвожу.
[01:24:06.240 --> 01:24:08.240]  Естественно, я понимаю, что я еще ничего не сказал.
[01:24:08.240 --> 01:24:10.240]  Да. То есть, нам
[01:24:10.240 --> 01:24:12.240]  хочется, но нам хочется ориентироваться,
[01:24:12.240 --> 01:24:14.240]  что если мы пришли в какую-то, что если ваша программа
[01:24:14.240 --> 01:24:16.240]  пришла в какую-то точку, то она там
[01:24:16.240 --> 01:24:18.240]  перед этим заведомо была в какой-то там,
[01:24:18.240 --> 01:24:20.240]  в какой-то точке. А в какой-то могла быть,
[01:24:20.240 --> 01:24:22.240]  а могла не быть.
[01:24:22.240 --> 01:24:24.240]  Приводит нас
[01:24:24.240 --> 01:24:26.240]  к следующему.
[01:24:26.240 --> 01:24:28.240]  Во-первых, мы вводим понятие,
[01:24:28.240 --> 01:24:30.240]  ссылка,
[01:24:30.240 --> 01:24:32.240]  как бы доминатор 3,
[01:24:32.240 --> 01:24:34.240]  то есть статья Тарьяна сразу.
[01:24:34.240 --> 01:24:36.240]  Там Тарьяна и еще одного товарища.
[01:24:36.240 --> 01:24:38.240]  Точнее, наоборот, еще одного товарища и Тарьяна.
[01:24:38.240 --> 01:24:40.240]  Вот.
[01:24:40.240 --> 01:24:42.240]  Ну там по фамилии в другом порядке идут.
[01:24:42.240 --> 01:24:44.240]  Вот.
[01:24:44.240 --> 01:24:46.240]  Как всегда.
[01:24:46.240 --> 01:24:48.240]  Смотрите.
[01:24:48.240 --> 01:24:50.240]  Ну, во-первых, начнем мы с простого определения.
[01:24:50.240 --> 01:24:52.240]  Так.
[01:24:52.240 --> 01:24:54.240]  Смотрите, определение.
[01:24:56.240 --> 01:24:58.240]  Значит,
[01:24:58.240 --> 01:25:00.240]  пусть у нас,
[01:25:00.240 --> 01:25:02.240]  значит, смотрите,
[01:25:02.240 --> 01:25:04.240]  мы будем говорить, что В, Е и Р,
[01:25:04.240 --> 01:25:06.240]  такая тройка,
[01:25:06.240 --> 01:25:08.240]  это граф потока управления.
[01:25:10.240 --> 01:25:12.240]  Ну,
[01:25:12.240 --> 01:25:14.240]  так, я не помню.
[01:25:14.240 --> 01:25:18.240]  Флоу, внезапно флоу граф.
[01:25:18.240 --> 01:25:20.240]  Причем этот флоу, собственно,
[01:25:20.240 --> 01:25:22.240]  к нашим любимым потокам отношения
[01:25:22.240 --> 01:25:24.240]  не имеет.
[01:25:24.240 --> 01:25:26.240]  Вот.
[01:25:26.240 --> 01:25:28.240]  Значит,
[01:25:28.240 --> 01:25:30.240]  если,
[01:25:30.240 --> 01:25:32.240]  значит, смотрите,
[01:25:32.240 --> 01:25:34.240]  во-первых,
[01:25:34.240 --> 01:25:36.240]  ну, В, Е,
[01:25:36.240 --> 01:25:38.240]  это просто ориентированный граф.
[01:25:40.240 --> 01:25:42.240]  Значит,
[01:25:42.240 --> 01:25:44.240]  Р это просто, это какая-то
[01:25:44.240 --> 01:25:46.240]  вершина.
[01:25:46.240 --> 01:25:48.240]  Смотрите,
[01:25:48.240 --> 01:25:50.240]  из Р доступны все вершины.
[01:25:52.240 --> 01:25:54.240]  Тут, знаете,
[01:25:54.240 --> 01:25:56.240]  так иногда этого не хватает во всяких задачах,
[01:25:56.240 --> 01:25:58.240]  что в ориентированном графе нельзя запустить,
[01:25:58.240 --> 01:26:00.240]  не всегда можно запустить ДФС из одной вершины
[01:26:00.240 --> 01:26:02.240]  и обойти все.
[01:26:02.240 --> 01:26:04.240]  Да, вот в ней ориентирован можно,
[01:26:04.240 --> 01:26:06.240]  в ориентированном не всегда.
[01:26:06.240 --> 01:26:08.240]  Ну, вот.
[01:26:08.240 --> 01:26:10.240]  Ну, у нас мы будем рассматривать граф,
[01:26:10.240 --> 01:26:12.240]  в котором можно.
[01:26:12.240 --> 01:26:14.240]  Вот такая красота.
[01:26:14.240 --> 01:26:16.240]  Значит, доступны все вершины.
[01:26:16.240 --> 01:26:18.240]  Что же делать?
[01:26:18.240 --> 01:26:20.240]  А, ну, пока ничего не делать.
[01:26:20.240 --> 01:26:22.240]  Это пока просто определение.
[01:26:24.240 --> 01:26:26.240]  Так вот.
[01:26:26.240 --> 01:26:28.240]  И вот теперь определение.
[01:26:28.240 --> 01:26:30.240]  Значит, вот у нас
[01:26:30.240 --> 01:26:32.240]  в таком графе,
[01:26:32.240 --> 01:26:34.240]  то есть пусть у нас,
[01:26:34.240 --> 01:26:36.240]  значит, В, Е, Р,
[01:26:36.240 --> 01:26:38.240]  это, допустим,
[01:26:38.240 --> 01:26:40.240]  господи, вот, хочется написать
[01:26:40.240 --> 01:26:42.240]  ГПУ, но веська ощущение, что это аббревиатура
[01:26:42.240 --> 01:26:44.240]  по-другому расшифровывается.
[01:26:48.240 --> 01:26:50.240]  А как?
[01:26:50.240 --> 01:26:52.240]  А по-украински да, что ли, или шо?
[01:26:52.240 --> 01:26:54.240]  Ну, мало ли.
[01:26:54.240 --> 01:26:56.240]  Ну, короче, ладно, граф ПУ.
[01:26:56.240 --> 01:26:58.240]  Давайте так.
[01:27:00.240 --> 01:27:02.240]  Вот.
[01:27:04.240 --> 01:27:06.240]  Нет.
[01:27:06.240 --> 01:27:08.240]  Вот.
[01:27:08.240 --> 01:27:10.240]  Так вот.
[01:27:10.240 --> 01:27:12.240]  Значит, будем говорить, что
[01:27:12.240 --> 01:27:14.240]  вершина У
[01:27:14.240 --> 01:27:16.240]  доминирует над В.
[01:27:16.240 --> 01:27:18.240]  Во.
[01:27:18.240 --> 01:27:20.240]  Ну, естественно,
[01:27:20.240 --> 01:27:22.240]  там В, вершина У
[01:27:22.240 --> 01:27:24.240]  доминирует над вершиной В.
[01:27:26.240 --> 01:27:28.240]  Если
[01:27:28.240 --> 01:27:30.240]  любой путь
[01:27:34.240 --> 01:27:36.240]  из
[01:27:36.240 --> 01:27:38.240]  Р, вот того самого Р,
[01:27:38.240 --> 01:27:40.240]  В, В
[01:27:40.240 --> 01:27:42.240]  содержит
[01:27:46.240 --> 01:27:48.240]  Во.
[01:27:48.240 --> 01:27:50.240]  Да, сразу обозначение.
[01:27:52.240 --> 01:27:54.240]  Обозначение
[01:27:54.240 --> 01:27:56.240]  это будет называться У дом В.
[01:27:58.240 --> 01:28:00.240]  Вот. Дом, ну, от слова
[01:28:00.240 --> 01:28:02.240]  dominate.
[01:28:02.240 --> 01:28:04.240]  И здесь все просто.
[01:28:04.240 --> 01:28:06.240]  Вот.
[01:28:06.240 --> 01:28:08.240]  Вот.
[01:28:08.240 --> 01:28:10.240]  Так.
[01:28:10.240 --> 01:28:12.240]  Ну, возникает вопрос.
[01:28:12.240 --> 01:28:14.240]  А может ли быть так, что
[01:28:14.240 --> 01:28:16.240]  на вершине В не доминирует никто?
[01:28:16.240 --> 01:28:18.240]  Р никто не доминирует.
[01:28:18.240 --> 01:28:20.240]  Чего?
[01:28:20.240 --> 01:28:22.240]  Р доминирует самым самым.
[01:28:22.240 --> 01:28:24.240]  Да, ну,
[01:28:24.240 --> 01:28:26.240]  во-первых, да, тут как
[01:28:26.240 --> 01:28:28.240]  кто-то упоминал уже простое число,
[01:28:28.240 --> 01:28:30.240]  так вот, то же самое.
[01:28:30.240 --> 01:28:32.240]  У каждой вершины В есть
[01:28:32.240 --> 01:28:34.240]  две вершины, которые над ней точно доминируют.
[01:28:34.240 --> 01:28:36.240]  Во-первых, она сама, во-вторых,
[01:28:36.240 --> 01:28:38.240]  Р.
[01:28:38.240 --> 01:28:40.240]  Но, в принципе, да, других может
[01:28:40.240 --> 01:28:42.240]  не быть.
[01:28:44.240 --> 01:28:46.240]  А могут...
[01:28:46.240 --> 01:28:48.240]  Чего?
[01:28:48.240 --> 01:28:50.240]  Да, ну, в принципе, да,
[01:28:50.240 --> 01:28:52.240]  но есть тривиальный случай, он же единица,
[01:28:52.240 --> 01:28:54.240]  это когда сам Р.
[01:28:54.240 --> 01:28:56.240]  Но это не очень интересный случай.
[01:28:56.240 --> 01:28:58.240]  Вот.
[01:28:58.240 --> 01:29:00.240]  Значит, лемма, почему-то она у меня
[01:29:00.240 --> 01:29:02.240]  значена как один штрих. Интересно, почему.
[01:29:06.240 --> 01:29:08.240]  Ладно. Ну, давайте, тут написано
[01:29:08.240 --> 01:29:10.240]  почему-то. Наверное, автор думал, писал,
[01:29:10.240 --> 01:29:12.240]  наверное, почему-то. Вот.
[01:29:14.240 --> 01:29:16.240]  Значит, утверждение такое.
[01:29:16.240 --> 01:29:18.240]  Если
[01:29:18.240 --> 01:29:20.240]  У
[01:29:20.240 --> 01:29:22.240]  дом В
[01:29:22.240 --> 01:29:24.240]  и В дом В,
[01:29:26.240 --> 01:29:28.240]  то
[01:29:30.240 --> 01:29:32.240]  ну, короче говоря,
[01:29:32.240 --> 01:29:34.240]  У дом В.
[01:29:34.240 --> 01:29:36.240]  Ну, или В дом У.
[01:29:40.240 --> 01:29:42.240]  Во.
[01:29:42.240 --> 01:29:44.240]  Ну, короче говоря,
[01:29:44.240 --> 01:29:46.240]  то есть если над одной вершины
[01:29:46.240 --> 01:29:48.240]  доминируют сразу две,
[01:29:48.240 --> 01:29:50.240]  то из этих двух вершин
[01:29:50.240 --> 01:29:52.240]  кто-то над кем-то тоже
[01:29:52.240 --> 01:29:54.240]  доминирует.
[01:29:54.240 --> 01:29:56.240]  Ну,
[01:29:56.240 --> 01:29:58.240]  доказательства
[01:29:58.240 --> 01:30:00.240]  на самом деле очень простое.
[01:30:00.240 --> 01:30:02.240]  Рассмотрим
[01:30:02.240 --> 01:30:04.240]  какой-нибудь путь
[01:30:04.240 --> 01:30:06.240]  от Р
[01:30:06.240 --> 01:30:08.240]  до В.
[01:30:10.240 --> 01:30:12.240]  На этом пути
[01:30:12.240 --> 01:30:14.240]  лежат вершины У и В
[01:30:14.240 --> 01:30:16.240]  в каком-то порядке.
[01:30:16.240 --> 01:30:18.240]  Ну, допустим, сначала У, потом В.
[01:30:18.240 --> 01:30:20.240]  Понятно, да?
[01:30:20.240 --> 01:30:22.240]  Тогда
[01:30:22.240 --> 01:30:24.240]  тогда я утверждаю,
[01:30:24.240 --> 01:30:26.240]  что если У
[01:30:26.240 --> 01:30:28.240]  в этом случае У доминирует
[01:30:28.240 --> 01:30:30.240]  над В.
[01:30:30.240 --> 01:30:32.240]  Почему я такое утверждаю?
[01:30:40.240 --> 01:30:42.240]  Да. То есть она не доминирует.
[01:30:42.240 --> 01:30:44.240]  Знаете, что мы тут каким-то вот обходным путем
[01:30:44.240 --> 01:30:46.240]  каким-то вот таким,
[01:30:46.240 --> 01:30:48.240]  понятно, что он может быть, конечно, вот
[01:30:48.240 --> 01:30:50.240]  такой вот, да, но
[01:30:52.240 --> 01:30:54.240]  нет, как мы убедимся, что на самом деле
[01:30:54.240 --> 01:30:56.240]  найдется обходной путь и вот такой
[01:30:56.240 --> 01:30:58.240]  на самом деле, вот прям буквально такой.
[01:30:58.240 --> 01:31:00.240]  Вот.
[01:31:00.240 --> 01:31:02.240]  Ну, суть такая, да,
[01:31:02.240 --> 01:31:04.240]  но в любом случае, если мы каким-то образом в обход
[01:31:04.240 --> 01:31:06.240]  вершины У можем дойти до В,
[01:31:06.240 --> 01:31:08.240]  то мы в обход вершины У тогда можем и до В
[01:31:08.240 --> 01:31:10.240]  дойти противоречия.
[01:31:12.240 --> 01:31:14.240]  Вот. То есть более того,
[01:31:14.240 --> 01:31:16.240]  на самом деле
[01:31:18.240 --> 01:31:20.240]  то есть на самом деле
[01:31:20.240 --> 01:31:22.240]  то есть эту лему
[01:31:22.240 --> 01:31:24.240]  на самом деле можно было бы
[01:31:24.240 --> 01:31:26.240]  на самом деле сформулировать
[01:31:26.240 --> 01:31:28.240]  и даже в более продвинутом
[01:31:28.240 --> 01:31:30.240]  виде. То есть рассмотрим все
[01:31:30.240 --> 01:31:32.240]  доминаторы вершины В.
[01:31:38.240 --> 01:31:40.240]  Вот.
[01:31:40.240 --> 01:31:42.240]  Допустим, все у меня тут доминаторы
[01:31:42.240 --> 01:31:44.240]  У1, У2, У3,
[01:31:44.240 --> 01:31:46.240]  У4 и так далее.
[01:31:46.240 --> 01:31:48.240]  И какой-нибудь там У,
[01:31:48.240 --> 01:31:50.240]  ну, допустим, там К.
[01:31:50.240 --> 01:31:52.240]  Вот.
[01:31:52.240 --> 01:31:54.240]  Тогда, если они идут вот в таком
[01:31:54.240 --> 01:31:56.240]  порядке,
[01:31:56.240 --> 01:31:58.240]  то тогда получается,
[01:31:58.240 --> 01:32:00.240]  что каждый предыдущий доминирует
[01:32:00.240 --> 01:32:02.240]  над всеми следующими.
[01:32:02.240 --> 01:32:04.240]  Логично, да?
[01:32:04.240 --> 01:32:06.240]  То есть более того,
[01:32:06.240 --> 01:32:08.240]  более того,
[01:32:08.240 --> 01:32:10.240]  на самом деле оказывается, что
[01:32:10.240 --> 01:32:12.240]  в принципе получается,
[01:32:12.240 --> 01:32:14.240]  что у У есть такой ближайший
[01:32:14.240 --> 01:32:16.240]  доминатор. То есть это вот тот
[01:32:16.240 --> 01:32:18.240]  доминатор,
[01:32:18.240 --> 01:32:20.240]  который доминирует над В
[01:32:20.240 --> 01:32:22.240]  и над которым доминирует все,
[01:32:22.240 --> 01:32:24.240]  что доминирует над В.
[01:32:24.240 --> 01:32:26.240]  То есть в принципе
[01:32:26.240 --> 01:32:28.240]  тут-то и появляется новое
[01:32:28.240 --> 01:32:30.240]  определение важное.
[01:32:30.240 --> 01:32:32.240]  То есть вот это вот, на самом деле, это равно
[01:32:32.240 --> 01:32:34.240]  аидом от В.
[01:32:34.240 --> 01:32:36.240]  Аидом.
[01:32:36.240 --> 01:32:38.240]  Или непосредственный доминатор.
[01:32:38.240 --> 01:32:40.240]  Сейчас запишу. Смотрите.
[01:32:40.240 --> 01:32:42.240]  Определение.
[01:32:42.240 --> 01:32:44.240]  Пусть у нас вершина В
[01:32:44.240 --> 01:32:46.240]  но корню. Это важно.
[01:32:46.240 --> 01:32:48.240]  Тогда
[01:32:50.240 --> 01:32:52.240]  значит, вершина У
[01:32:54.240 --> 01:32:56.240]  это непосредственный
[01:32:56.240 --> 01:32:58.240]  доминатор.
[01:33:00.240 --> 01:33:02.240]  Сотовенный
[01:33:02.240 --> 01:33:04.240]  непосредственный
[01:33:04.240 --> 01:33:06.240]  доминатор
[01:33:08.240 --> 01:33:10.240]  В.
[01:33:10.240 --> 01:33:12.240]  Если
[01:33:14.240 --> 01:33:16.240]  во-первых, первое, У
[01:33:16.240 --> 01:33:18.240]  доминирует над В.
[01:33:18.240 --> 01:33:20.240]  Второе,
[01:33:20.240 --> 01:33:22.240]  значит, У
[01:33:22.240 --> 01:33:24.240]  не равно В.
[01:33:26.240 --> 01:33:28.240]  И третье, что для любой вершины В
[01:33:30.240 --> 01:33:32.240]  не равный В,
[01:33:32.240 --> 01:33:34.240]  но доминирующий над ним,
[01:33:38.240 --> 01:33:40.240]  оказывается, что В
[01:33:40.240 --> 01:33:42.240]  доминирует и над У тоже.
[01:33:44.240 --> 01:33:46.240]  Обозначение.
[01:33:50.240 --> 01:33:52.240]  Обозначение аидом
[01:33:52.240 --> 01:33:54.240]  от W.
[01:33:54.240 --> 01:33:56.240]  Почему аидом?
[01:33:56.240 --> 01:33:58.240]  Я.
[01:33:58.240 --> 01:34:00.240]  Шо я?
[01:34:00.240 --> 01:34:02.240]  Понятно, аид
[01:34:02.240 --> 01:34:04.240]  непосредственный
[01:34:04.240 --> 01:34:06.240]  доминатор.
[01:34:10.240 --> 01:34:12.240]  Да, I would say that
[01:34:12.240 --> 01:34:14.240]  I means immediate.
[01:34:14.240 --> 01:34:16.240]  Immediate.
[01:34:16.240 --> 01:34:18.240]  Yeah.
[01:34:18.240 --> 01:34:20.240]  Yeah.
[01:34:20.240 --> 01:34:22.240]  I'm not sure, but
[01:34:22.240 --> 01:34:24.240]  something says means that
[01:34:24.240 --> 01:34:26.240]  it is something
[01:34:26.240 --> 01:34:28.240]  about it.
[01:34:28.240 --> 01:34:30.240]  Да.
[01:34:30.240 --> 01:34:32.240]  Нет, С там спокойно.
[01:34:32.240 --> 01:34:34.240]  Ага, там будет
[01:34:34.240 --> 01:34:36.240]  self-dominating there.
[01:34:36.240 --> 01:34:38.240]  Но до этого
[01:34:38.240 --> 01:34:40.240]  мы доживем.
[01:34:40.240 --> 01:34:42.240]  Так это вот у нас аидом.
[01:34:44.240 --> 01:34:46.240]  Мистическое утверждение,
[01:34:46.240 --> 01:34:48.240]  которое мы
[01:34:48.240 --> 01:34:50.240]  будем называть, гордо будем называть
[01:34:50.240 --> 01:34:52.240]  Ремо-1.
[01:34:52.240 --> 01:34:54.240]  Ну ладно, не мы, а итальян, соответственно.
[01:34:54.240 --> 01:34:56.240]  Точнее,
[01:34:56.240 --> 01:34:58.240]  кто-то итальян.
[01:34:58.240 --> 01:35:00.240]  Нет, ну кто-то вы там можете гуглануть там
[01:35:00.240 --> 01:35:02.240]  помылингауэр там фамилии или что-то вот.
[01:35:02.240 --> 01:35:04.240]  Чего?
[01:35:04.240 --> 01:35:06.240]  Лонганьер.
[01:35:06.240 --> 01:35:08.240]  Okay.
[01:35:08.240 --> 01:35:10.240]  Ну вот.
[01:35:10.240 --> 01:35:12.240]  Значит, и так первая
[01:35:12.240 --> 01:35:14.240]  тиремма Лонганьер-Тарьяна
[01:35:14.240 --> 01:35:16.240]  говорит о том, что
[01:35:16.240 --> 01:35:18.240]  для любой
[01:35:18.240 --> 01:35:20.240]  вершины
[01:35:20.240 --> 01:35:22.240]  неравной корню
[01:35:22.240 --> 01:35:24.240]  существует
[01:35:24.240 --> 01:35:26.240]  и единственен
[01:35:26.240 --> 01:35:28.240]  аидом от W.
[01:35:34.240 --> 01:35:36.240]  Вот.
[01:35:36.240 --> 01:35:38.240]  Почему?
[01:35:42.240 --> 01:35:44.240]  Заметим так,
[01:35:44.240 --> 01:35:46.240]  что
[01:35:46.240 --> 01:35:48.240]  существует кто-то,
[01:35:48.240 --> 01:35:50.240]  кто доминирует на W и не она сама.
[01:35:50.240 --> 01:35:52.240]  Это как минимум корень.
[01:36:00.240 --> 01:36:02.240]  А можно даже без этой леммы,
[01:36:02.240 --> 01:36:04.240]  это была такая разминочка.
[01:36:04.240 --> 01:36:06.240]  Среди всех доминаторов W
[01:36:06.240 --> 01:36:08.240]  рассмотрим последнего из них.
[01:36:08.240 --> 01:36:10.240]  Утверждение. Это он.
[01:36:10.240 --> 01:36:12.240]  Во-первых, это он. Во-вторых, очевидно,
[01:36:12.240 --> 01:36:14.240]  никто другой не подходит.
[01:36:18.240 --> 01:36:20.240]  Лемма.
[01:36:20.240 --> 01:36:22.240]  А также, как и тиремма.
[01:36:22.240 --> 01:36:24.240]  Рассмотрим все вершины,
[01:36:24.240 --> 01:36:26.240]  рассмотрим
[01:36:26.240 --> 01:36:28.240]  все вершины, которые доминируют
[01:36:28.240 --> 01:36:30.240]  над W, а во-вторых, рассмотрим
[01:36:30.240 --> 01:36:32.240]  какой-нибудь путь из R до W.
[01:36:32.240 --> 01:36:34.240]  На этом пути лежат, очевидно,
[01:36:34.240 --> 01:36:36.240]  все доминаторы W.
[01:36:36.240 --> 01:36:38.240]  Вот.
[01:36:38.240 --> 01:36:40.240]  Рассмотрим последнего на этом пути.
[01:36:40.240 --> 01:36:42.240]  Очевидно, что
[01:36:42.240 --> 01:36:44.240]  над ним все доминируют.
[01:36:44.240 --> 01:36:46.240]  Значит, он, как аидом,
[01:36:46.240 --> 01:36:48.240]  под аидома подходит, а во-вторых, заметим, что
[01:36:48.240 --> 01:36:50.240]  больше никто не подойдет, как минимум,
[01:36:50.240 --> 01:36:52.240]  потому что вот этот товарищ ни над кем не доминирует.
[01:36:52.240 --> 01:36:54.240]  Ну, просто вот.
[01:36:54.240 --> 01:36:56.240]  Вот.
[01:36:56.240 --> 01:36:58.240]  Поэтому аидом
[01:36:58.240 --> 01:37:00.240]  существует и единственен.
[01:37:02.240 --> 01:37:04.240]  Так вот.
[01:37:04.240 --> 01:37:06.240]  Тогда, соответственно, можно...
[01:37:06.240 --> 01:37:08.240]  Ну, тогда заметим, что если я
[01:37:08.240 --> 01:37:10.240]  введу такое понятие, как
[01:37:10.240 --> 01:37:12.240]  такой граф, как с теми же вершинами,
[01:37:12.240 --> 01:37:14.240]  но с ребрами
[01:37:14.240 --> 01:37:16.240]  вида аидом
[01:37:16.240 --> 01:37:18.240]  от W
[01:37:18.240 --> 01:37:20.240]  до W, да?
[01:37:20.240 --> 01:37:22.240]  То есть там W – это
[01:37:22.240 --> 01:37:24.240]  V без корня.
[01:37:26.240 --> 01:37:28.240]  Ну, вот. То есть я напишу такое следствие.
[01:37:28.240 --> 01:37:30.240]  Это следствие, что
[01:37:30.240 --> 01:37:32.240]  не теорема 2, я надеюсь.
[01:37:32.240 --> 01:37:34.240]  Вот.
[01:37:34.240 --> 01:37:36.240]  Тогда отсюда следует, что
[01:37:36.240 --> 01:37:38.240]  вот это вот,
[01:37:38.240 --> 01:37:40.240]  это дерево.
[01:37:42.240 --> 01:37:44.240]  Я бы сказал даже подвешенное дерево.
[01:37:46.240 --> 01:37:48.240]  Что такое дерево?
[01:37:48.240 --> 01:37:50.240]  Ой, а что это такое-то вообще?
[01:37:50.240 --> 01:37:52.240]  Подвешенное дерево
[01:37:52.240 --> 01:37:54.240]  с корнем в R.
[01:37:54.240 --> 01:37:56.240]  Да.
[01:37:56.240 --> 01:37:58.240]  Ой, начинается.
[01:37:58.240 --> 01:38:00.240]  Нет, это на физике у нас такое.
[01:38:00.240 --> 01:38:02.240]  Что такое волна?
[01:38:02.240 --> 01:38:04.240]  Ну, что такое волна – и так понятно, мы не будем
[01:38:04.240 --> 01:38:06.240]  вводить точного определения, поэтому вместо этого давайте
[01:38:06.240 --> 01:38:08.240]  изучать ее свойства.
[01:38:08.240 --> 01:38:10.240]  Да, да, да.
[01:38:10.240 --> 01:38:12.240]  Ну, волна.
[01:38:12.240 --> 01:38:14.240]  Нет, просто
[01:38:14.240 --> 01:38:16.240]  я на полном серьезе
[01:38:16.240 --> 01:38:18.240]  на некоторые занятия по физике так объясняю.
[01:38:18.240 --> 01:38:20.240]  Волна.
[01:38:20.240 --> 01:38:22.240]  Так вот.
[01:38:22.240 --> 01:38:24.240]  Подвешенное дерево.
[01:38:24.240 --> 01:38:26.240]  Вот.
[01:38:26.240 --> 01:38:28.240]  Но тут все гораздо проще.
[01:38:28.240 --> 01:38:30.240]  Ну, просто говорим, что
[01:38:30.240 --> 01:38:32.240]  ну, скажем так, давайте
[01:38:32.240 --> 01:38:34.240]  в данном случае можно ввести
[01:38:34.240 --> 01:38:36.240]  понятие ориентированное подвешенное дерево.
[01:38:36.240 --> 01:38:38.240]  Это
[01:38:38.240 --> 01:38:40.240]  во-первых так, что если
[01:38:40.240 --> 01:38:42.240]  отменить ориентацию, то получится дерево.
[01:38:42.240 --> 01:38:44.240]  А во-вторых,
[01:38:44.240 --> 01:38:46.240]  а во-вторых,
[01:38:46.240 --> 01:38:48.240]  ребра ориентированы так, что из корня
[01:38:48.240 --> 01:38:50.240]  до всех вершин по этому дереву, по этому графу
[01:38:50.240 --> 01:38:52.240]  можно дойти.
[01:38:52.240 --> 01:38:54.240]  Вот, например, вот так определить дерево.
[01:38:54.240 --> 01:38:56.240]  Нет, в принципе,
[01:38:56.240 --> 01:38:58.240]  в каких-то википедиях там бывало вообще какое-то
[01:38:58.240 --> 01:39:00.240]  жуткое определение, когда там
[01:39:00.240 --> 01:39:02.240]  для каждой вершины объявлялись,
[01:39:02.240 --> 01:39:04.240]  объявлялся там список детей,
[01:39:04.240 --> 01:39:06.240]  гарантировалось отсутствие какой-то зацикленности.
[01:39:06.240 --> 01:39:08.240]  Ну, может быть,
[01:39:08.240 --> 01:39:10.240]  это совсем ближе к истине какой-нибудь
[01:39:10.240 --> 01:39:12.240]  конкретной модели, но не важно.
[01:39:12.240 --> 01:39:14.240]  Вот.
[01:39:14.240 --> 01:39:16.240]  Соответственно,
[01:39:16.240 --> 01:39:18.240]  но здесь у нас получается, что это
[01:39:18.240 --> 01:39:20.240]  подвешенное дерево.
[01:39:20.240 --> 01:39:22.240]  Так, ну, хотя, конечно, чтобы убедиться в том,
[01:39:22.240 --> 01:39:24.240]  что это подвешенное, так, с корнем,
[01:39:24.240 --> 01:39:26.240]  во-первых, вер,
[01:39:26.240 --> 01:39:28.240]  а во-вторых, ну, чтобы убедиться, что дерево,
[01:39:28.240 --> 01:39:30.240]  надо, конечно, желательно убедиться, что это
[01:39:30.240 --> 01:39:32.240]  не зацикливается.
[01:39:32.240 --> 01:39:34.240]  Вот.
[01:39:34.240 --> 01:39:36.240]  Ну, у нас, очевидно, не бывает такого, что там
[01:39:36.240 --> 01:39:38.240]  Вася доминирует над Петей, Петя доминирует над
[01:39:38.240 --> 01:39:40.240]  Колей, а Коля неожиданно доминирует над
[01:39:40.240 --> 01:39:42.240]  Васей, правда?
[01:39:42.240 --> 01:39:44.240]  Ну, это просто отношение частичного корня.
[01:39:44.240 --> 01:39:46.240]  Ну, вот.
[01:39:46.240 --> 01:39:48.240]  Нет, это да, но
[01:39:48.240 --> 01:39:50.240]  для этого надо доказать, что это не так.
[01:39:50.240 --> 01:39:52.240]  Вот.
[01:39:52.240 --> 01:39:54.240]  Нет, ну, как бы в идеале.
[01:40:00.240 --> 01:40:02.240]  Антисимметричность?
[01:40:02.240 --> 01:40:04.240]  Нет, если вдуматься, то очевидно,
[01:40:04.240 --> 01:40:06.240]  потому что если У доминирует над В,
[01:40:06.240 --> 01:40:08.240]  то есть любой путь до В
[01:40:08.240 --> 01:40:10.240]  проходит через У, то рассмотрим этот путь и
[01:40:10.240 --> 01:40:12.240]  обнаружим, что этот путь от
[01:40:12.240 --> 01:40:14.240]  Р до У не проходит через В.
[01:40:14.240 --> 01:40:16.240]  То есть, получается, мораль.
[01:40:16.240 --> 01:40:18.240]  Если У доминирует над В, то В над У
[01:40:18.240 --> 01:40:20.240]  не доминирует. Ну, либо они равны, конечно.
[01:40:22.240 --> 01:40:24.240]  Да, но транзитивность, да, тоже очевидна.
[01:40:38.240 --> 01:40:40.240]  Какой анод?
[01:40:40.240 --> 01:40:42.240]  Три следствия.
[01:40:42.240 --> 01:40:44.240]  Нет, в смысле?
[01:40:44.240 --> 01:40:46.240]  Так мы это следствие доказываем, в смысле.
[01:40:52.240 --> 01:40:54.240]  Ну, зациклов нет.
[01:40:54.240 --> 01:40:56.240]  Но с другой стороны, в каждую вершину
[01:40:56.240 --> 01:40:58.240]  ведет какое-то ребро.
[01:40:58.240 --> 01:41:00.240]  Кроме корня.
[01:41:00.240 --> 01:41:02.240]  Ну, следом от. Ну, отсюда, в принципе,
[01:41:02.240 --> 01:41:04.240]  следует, что из корня мы до любой дойдем,
[01:41:04.240 --> 01:41:06.240]  потому что просто будем идти по айдему.
[01:41:06.240 --> 01:41:08.240]  Зацикла не будет, значит упрёмся в В.
[01:41:08.240 --> 01:41:10.240]  Ну, например, так.
[01:41:10.240 --> 01:41:12.240]  Так, у нас остается только ввести
[01:41:12.240 --> 01:41:14.240]  определение.
[01:41:14.240 --> 01:41:16.240]  Как вы думаете, как же называется
[01:41:18.240 --> 01:41:20.240]  как же называется это дерево?
[01:41:20.240 --> 01:41:22.240]  Да, оно так и называется.
[01:41:22.240 --> 01:41:24.240]  Дерево доминаторов.
[01:41:24.240 --> 01:41:26.240]  Да.
[01:41:28.240 --> 01:41:30.240]  Субдоминаторов.
[01:41:30.240 --> 01:41:32.240]  Ну, во-первых, скорее селфдоминаторов, а во-вторых,
[01:41:32.240 --> 01:41:34.240]  во-вторых, нет дерева полудоминаторов.
[01:41:34.240 --> 01:41:36.240]  Нет, но это как бы нам
[01:41:36.240 --> 01:41:38.240]  чуть позже понадобится.
[01:41:38.240 --> 01:41:40.240]  Так. Ну, пока давайте поймём,
[01:41:40.240 --> 01:41:42.240]  в чём вообще...
[01:41:42.240 --> 01:41:44.240]  Во-первых, да, что с ним вообще можно делать?
[01:41:46.240 --> 01:41:48.240]  Да.
[01:41:48.240 --> 01:41:50.240]  Ну, на самом деле, да, его...
[01:41:50.240 --> 01:41:52.240]  Ну, действительно, да,
[01:41:52.240 --> 01:41:54.240]  его можно построить.
[01:41:54.240 --> 01:41:56.240]  Это во-первых. Во-вторых,
[01:41:56.240 --> 01:41:58.240]  конечно, утверждается, что если это дерево
[01:41:58.240 --> 01:42:00.240]  как-нибудь построить, то
[01:42:00.240 --> 01:42:02.240]  можно тогда определять, какие вершины
[01:42:02.240 --> 01:42:04.240]  на кем доминируют.
[01:42:04.240 --> 01:42:06.240]  Ну, вот задачи, например, нам дали.
[01:42:06.240 --> 01:42:08.240]  Там есть вершины, допустим, A и B.
[01:42:08.240 --> 01:42:10.240]  Верно ли...
[01:42:10.240 --> 01:42:12.240]  То есть доминирует ли A над B?
[01:42:12.240 --> 01:42:14.240]  Да или нет?
[01:42:14.240 --> 01:42:16.240]  Спрашивается, как это понять?
[01:42:18.240 --> 01:42:20.240]  Да. Ну, утверждается, что да,
[01:42:20.240 --> 01:42:22.240]  для этого надо проверить, верно ли, что A это
[01:42:22.240 --> 01:42:24.240]  предок B. Так, а почему?
[01:42:26.240 --> 01:42:28.240]  Очевидно, да, ладно.
[01:42:28.240 --> 01:42:30.240]  Можно показать, что
[01:42:30.240 --> 01:42:32.240]  путь до корня костелят собой, на самом деле,
[01:42:32.240 --> 01:42:34.240]  список наших доминаторов
[01:42:34.240 --> 01:42:36.240]  в порядке.
[01:42:36.240 --> 01:42:38.240]  Так, ну, в принципе, да.
[01:42:38.240 --> 01:42:40.240]  Да, можно прямо на картинку. Да, действительно.
[01:42:40.240 --> 01:42:42.240]  Рассмотрим действительно всех доминаторов
[01:42:42.240 --> 01:42:44.240]  от R до W.
[01:42:44.240 --> 01:42:46.240]  Но теперь легко убедиться, что
[01:42:46.240 --> 01:42:48.240]  действительно, что
[01:42:48.240 --> 01:42:50.240]  в дереве доминаторов будет
[01:42:50.240 --> 01:42:52.240]  вот такой замечательный путь.
[01:42:52.240 --> 01:42:54.240]  Из R в U1, из U1 в U2,
[01:42:54.240 --> 01:42:56.240]  из U2 в U3 и так далее.
[01:42:56.240 --> 01:42:58.240]  Прям вот...
[01:42:58.240 --> 01:43:00.240]  То есть в дереве доминаторов будет вот такой
[01:43:00.240 --> 01:43:02.240]  путь.
[01:43:02.240 --> 01:43:04.240]  Вот. Да, все действительно автоматически.
[01:43:04.240 --> 01:43:06.240]  То есть просто получается, является ли A предком
[01:43:06.240 --> 01:43:08.240]  B в дереве доминаторов, да или нет.
[01:43:08.240 --> 01:43:10.240]  Да.
[01:43:10.240 --> 01:43:12.240]  Так, давайте, что не так,
[01:43:12.240 --> 01:43:14.240]  давайте сразу разбираться.
[01:43:26.240 --> 01:43:28.240]  Ну, потому что... Так, ну, значит, смотрите, начнем с W.
[01:43:28.240 --> 01:43:30.240]  Ну, во-первых, у нас вот есть ребро
[01:43:30.240 --> 01:43:32.240]  из УК в W, да?
[01:43:32.240 --> 01:43:34.240]  А теперь давайте думать,
[01:43:34.240 --> 01:43:36.240]  кто доминирует над УК?
[01:43:36.240 --> 01:43:38.240]  Я утверждаю, что ровно те же,
[01:43:38.240 --> 01:43:40.240]  кто доминировал над W.
[01:43:40.240 --> 01:43:42.240]  Потому что если над ним, например, доминирует еще
[01:43:42.240 --> 01:43:44.240]  кто-то, то этот кто-то будет и на W.
[01:43:44.240 --> 01:43:46.240]  Да. И более того,
[01:43:46.240 --> 01:43:48.240]  да, все те же над ним доминируют,
[01:43:48.240 --> 01:43:50.240]  и больше никого нет. Поэтому тут берем
[01:43:50.240 --> 01:43:52.240]  предыдущий ребро, повторяем рассуждение.
[01:43:52.240 --> 01:43:54.240]  Вот.
[01:43:54.240 --> 01:43:56.240]  Так что вот такую задачу мы
[01:43:56.240 --> 01:43:58.240]  неожиданно будем решать.
[01:43:58.240 --> 01:44:00.240]  Вот. Но спрашивается, как
[01:44:00.240 --> 01:44:02.240]  ее решать?
[01:44:02.240 --> 01:44:04.240]  Ну, здесь на самом деле, то есть по-разному,
[01:44:04.240 --> 01:44:06.240]  потому что на самом деле в компиляторах тут
[01:44:06.240 --> 01:44:08.240]  неожиданно заявляют, что в общем-то там
[01:44:08.240 --> 01:44:10.240]  лазить к тагьяну не всегда нужно.
[01:44:12.240 --> 01:44:14.240]  Потому что у нас есть
[01:44:14.240 --> 01:44:16.240]  упихон за...
[01:44:16.240 --> 01:44:18.240]  Так.
[01:44:18.240 --> 01:44:20.240]  Называется даже
[01:44:20.240 --> 01:44:22.240]  за N квадрат M.
[01:44:22.240 --> 01:44:24.240]  Как он работает?
[01:44:24.240 --> 01:44:26.240]  Ну, потому что в Олимпиадах обычно такие
[01:44:26.240 --> 01:44:28.240]  алгоритмы называют N квадрат M на 32.
[01:44:30.240 --> 01:44:32.240]  Сталкивались с таким заклинанием?
[01:44:34.240 --> 01:44:36.240]  Ну, конечно, да, потому что...
[01:44:36.240 --> 01:44:38.240]  Ну, то есть да, идея будет
[01:44:38.240 --> 01:44:40.240]  такая. То есть давайте
[01:44:40.240 --> 01:44:42.240]  в каждой вершине
[01:44:42.240 --> 01:44:44.240]  будем хранить просто битмассочку
[01:44:44.240 --> 01:44:46.240]  у тех вершин, которые может
[01:44:46.240 --> 01:44:48.240]  быть над ней доминируют.
[01:44:50.240 --> 01:44:52.240]  Ну, вот.
[01:44:52.240 --> 01:44:54.240]  А, ну, давай, нет, ну, давайте
[01:44:54.240 --> 01:44:56.240]  посмотреть. Что мы хотим? Давайте в каждой
[01:44:56.240 --> 01:44:58.240]  вершине храним битмасску.
[01:44:58.240 --> 01:45:00.240]  Вот. Которая там...
[01:45:00.240 --> 01:45:02.240]  В каждой вершине, которая
[01:45:02.240 --> 01:45:04.240]  изначально полная маска, но
[01:45:04.240 --> 01:45:06.240]  в корне, соответственно, маска состоит только
[01:45:06.240 --> 01:45:08.240]  из себя любимой.
[01:45:08.240 --> 01:45:10.240]  Вот. Ну, и давайте теперь
[01:45:10.240 --> 01:45:12.240]  на каждом нот.
[01:45:12.240 --> 01:45:14.240]  Нам нужно пытаться много-много раз делать
[01:45:14.240 --> 01:45:16.240]  операцию, что рассмотрим какое-нибудь
[01:45:16.240 --> 01:45:18.240]  серебро УВ.
[01:45:18.240 --> 01:45:20.240]  Да.
[01:45:20.240 --> 01:45:22.240]  И скажем, что маска от У,
[01:45:22.240 --> 01:45:24.240]  то есть маска от В,
[01:45:24.240 --> 01:45:26.240]  допустим,
[01:45:26.240 --> 01:45:28.240]  ну, вот
[01:45:28.240 --> 01:45:30.240]  n равно там маска от У, условно.
[01:45:32.240 --> 01:45:34.240]  Ладно, вот так, только маска от У
[01:45:34.240 --> 01:45:36.240]  или один хресь-хресь В.
[01:45:40.240 --> 01:45:42.240]  Вот так.
[01:45:42.240 --> 01:45:44.240]  Вот, мы хотим пробираться
[01:45:44.240 --> 01:45:46.240]  много-много раз по ребрам
[01:45:46.240 --> 01:45:48.240]  и добиться
[01:45:48.240 --> 01:45:50.240]  того, что в какой-то момент
[01:45:50.240 --> 01:45:52.240]  изначально,
[01:45:52.240 --> 01:45:54.240]  как я уже сказал, что
[01:45:54.240 --> 01:45:56.240]  маска от Р
[01:45:56.240 --> 01:45:58.240]  просто равно 1 хресь-хресь
[01:45:58.240 --> 01:46:00.240]  Р,
[01:46:00.240 --> 01:46:02.240]  а все остальные маски
[01:46:02.240 --> 01:46:04.240]  от В, если вы не равно
[01:46:04.240 --> 01:46:06.240]  Р, должны быть равны
[01:46:06.240 --> 01:46:08.240]  к чему?
[01:46:08.240 --> 01:46:10.240]  Ну, 1 хресь-хресь
[01:46:10.240 --> 01:46:12.240]  n минус 1, на самом деле.
[01:46:12.240 --> 01:46:14.240]  Но это
[01:46:14.240 --> 01:46:16.240]  маска на полный n-битм.
[01:46:16.240 --> 01:46:18.240]  Вот.
[01:46:18.240 --> 01:46:20.240]  А потом, после этого, делаем
[01:46:20.240 --> 01:46:22.240]  там много-много раз, допустим,
[01:46:22.240 --> 01:46:24.240]  то есть делаем вот эту штуку много-много раз
[01:46:24.240 --> 01:46:26.240]  по всем ребрам, до тех пор, пока
[01:46:26.240 --> 01:46:28.240]  эта штука что-то
[01:46:28.240 --> 01:46:30.240]  апдейтит.
[01:46:34.240 --> 01:46:36.240]  Чего она еще раз?
[01:46:36.240 --> 01:46:38.240]  Ну, вопрос, как бы, правда,
[01:46:38.240 --> 01:46:40.240]  в каком порядке
[01:46:40.240 --> 01:46:42.240]  это делать?
[01:46:48.240 --> 01:46:50.240]  Ну, типа того.
[01:46:50.240 --> 01:46:52.240]  Да, можно устроить DFS.
[01:46:52.240 --> 01:46:54.240]  То есть,
[01:46:54.240 --> 01:46:56.240]  можно написать что-нибудь тупое.
[01:46:56.240 --> 01:46:58.240]  Тупое, смотрите,
[01:46:58.240 --> 01:47:00.240]  например, DFS от R,
[01:47:00.240 --> 01:47:02.240]  то есть void,
[01:47:02.240 --> 01:47:04.240]  там DFS от V
[01:47:04.240 --> 01:47:06.240]  может звучать так.
[01:47:06.240 --> 01:47:08.240]  For. Нет, ладно, давай DFS от U давайте.
[01:47:08.240 --> 01:47:10.240]  А?
[01:47:10.240 --> 01:47:12.240]  Можно мы разве просто удалить
[01:47:12.240 --> 01:47:14.240]  вершину U, все, что
[01:47:14.240 --> 01:47:16.240]  запустить DFS из R и все, что мы не посетили,
[01:47:16.240 --> 01:47:18.240]  то есть,
[01:47:18.240 --> 01:47:20.240]  почему мы не можем удалить вершину,
[01:47:20.240 --> 01:47:22.240]  запустить DFS и сделать U?
[01:47:22.240 --> 01:47:24.240]  Нет, ну, как бы,
[01:47:24.240 --> 01:47:26.240]  если надо сделать обык какой алгоритм, то да, пожалуйста.
[01:47:28.240 --> 01:47:30.240]  Это будет, да, но
[01:47:30.240 --> 01:47:32.240]  скажем так, скажу почему.
[01:47:32.240 --> 01:47:34.240]  Вот, ну, дело в том, что
[01:47:34.240 --> 01:47:36.240]  на самом деле так, потому что
[01:47:36.240 --> 01:47:38.240]  в кишке по комбинатору предлагается именно такой алгоритм,
[01:47:38.240 --> 01:47:40.240]  мотивируя тем, что
[01:47:40.240 --> 01:47:42.240]  во многих практических случаях он работает
[01:47:42.240 --> 01:47:44.240]  гораздо быстрее.
[01:47:46.240 --> 01:47:48.240]  Не только, но там есть такой, есть еще случай.
[01:47:48.240 --> 01:47:50.240]  Ну, потому что,
[01:47:50.240 --> 01:47:52.240]  как бы, если применять там компиля,
[01:47:52.240 --> 01:47:54.240]  там часто может оказаться, что там
[01:47:54.240 --> 01:47:56.240]  граф иногда ациклический, или почти ациклический,
[01:47:56.240 --> 01:47:58.240]  что-то такое.
[01:47:58.240 --> 01:48:00.240]  Там просто вот действительно.
[01:48:00.240 --> 01:48:02.240]  Нет, ну,
[01:48:02.240 --> 01:48:04.240]  вот. Чего?
[01:48:04.240 --> 01:48:06.240]  Нет, ну, на ациклическом
[01:48:06.240 --> 01:48:08.240]  вот этот алгоритм будет за NM на 32
[01:48:08.240 --> 01:48:10.240]  работать.
[01:48:10.240 --> 01:48:12.240]  Вот.
[01:48:12.240 --> 01:48:14.240]  Ну, давайте смотреть.
[01:48:14.240 --> 01:48:16.240]  Хотя...
[01:48:16.240 --> 01:48:18.240]  Ну, давайте смотреть.
[01:48:20.240 --> 01:48:22.240]  Так, там
[01:48:22.240 --> 01:48:24.240]  пишем NMASK
[01:48:26.240 --> 01:48:28.240]  равно маск.
[01:48:28.240 --> 01:48:30.240]  Там, значит...
[01:48:44.240 --> 01:48:46.240]  Вот.
[01:49:00.240 --> 01:49:02.240]  Вот. Ну, вот можно, например, вот написать вот...
[01:49:02.240 --> 01:49:04.240]  То есть, какое-то вот такое
[01:49:04.240 --> 01:49:06.240]  заклинание.
[01:49:06.240 --> 01:49:08.240]  Нет, ну, в самом начале
[01:49:08.240 --> 01:49:10.240]  мы запускаем все только,
[01:49:10.240 --> 01:49:12.240]  делаем только DFS-R.
[01:49:12.240 --> 01:49:14.240]  Что?
[01:49:16.240 --> 01:49:18.240]  Ой, ой, ой, ой.
[01:49:18.240 --> 01:49:20.240]  А, в этом плане, да, DFS-R, конечно.
[01:49:20.240 --> 01:49:22.240]  Вот.
[01:49:22.240 --> 01:49:24.240]  Да.
[01:49:24.240 --> 01:49:26.240]  Так что вот можно, например, такое.
[01:49:26.240 --> 01:49:28.240]  Ну, давайте смотреть.
[01:49:28.240 --> 01:49:30.240]  Да, в худшем случае...
[01:49:30.240 --> 01:49:32.240]  Так, ну, за сколько это может работать?
[01:49:32.240 --> 01:49:34.240]  Ну, давайте посмотрим.
[01:49:34.240 --> 01:49:36.240]  Сколько раз
[01:49:36.240 --> 01:49:38.240]  мы можем запуститься из одной вершины
[01:49:38.240 --> 01:49:40.240]  DFS может запуститься из одной вершины
[01:49:40.240 --> 01:49:42.240]  DFS может запуститься из одной вершины.
[01:49:42.240 --> 01:49:44.240]  Каждый раз, когда мы обновляем маску...
[01:49:44.240 --> 01:49:46.240]  Да, маску мы обновляем, да.
[01:49:46.240 --> 01:49:48.240]  То есть, как бы, каждый раз у нас количество
[01:49:48.240 --> 01:49:50.240]  бит, то есть, DFS из вершины
[01:49:50.240 --> 01:49:52.240]  запускается, когда количество бит в маске
[01:49:52.240 --> 01:49:54.240]  не уменьшилось. Их изначально
[01:49:54.240 --> 01:49:56.240]  N уменьшится оно может только до нуля,
[01:49:56.240 --> 01:49:58.240]  поэтому, значит, не более чем N раз.
[01:49:58.240 --> 01:50:00.240]  Следовательно, DFS запускается
[01:50:00.240 --> 01:50:02.240]  не более чем M раз, значит, соответственно,
[01:50:02.240 --> 01:50:04.240]  мы...
[01:50:04.240 --> 01:50:06.240]  Получается, каждое ребро мы рассматриваем
[01:50:06.240 --> 01:50:08.240]  не... Значит, каждое ребро
[01:50:08.240 --> 01:50:10.240]  M мы рассматриваем не более чем
[01:50:10.240 --> 01:50:12.240]  N раз.
[01:50:12.240 --> 01:50:14.240]  Вот. И обрабатывая, значит, получается
[01:50:14.240 --> 01:50:16.240]  ассимточка NM умножить на
[01:50:16.240 --> 01:50:18.240]  за какое время мы обрабатываем это ребро.
[01:50:18.240 --> 01:50:20.240]  Но мы его обрабатываем как раз
[01:50:20.240 --> 01:50:22.240]  за те самые N на 32.
[01:50:24.240 --> 01:50:26.240]  Вот. То есть отсюда такая ассимточка получается.
[01:50:26.240 --> 01:50:28.240]  Вот.
[01:50:28.240 --> 01:50:30.240]  Так. Правда, по-хорошему, конечно,
[01:50:30.240 --> 01:50:32.240]  неплохо было убедиться, а почему этот алгоритм вообще
[01:50:32.240 --> 01:50:34.240]  работает?
[01:50:38.240 --> 01:50:40.240]  Да.
[01:50:40.240 --> 01:50:42.240]  То есть, на самом деле, давайте так немножко
[01:50:42.240 --> 01:50:44.240]  поразминаемся, почему он вообще работает.
[01:50:48.240 --> 01:50:50.240]  Ну, верно, на самом деле,
[01:50:50.240 --> 01:50:52.240]  следующее, что если какая-то вершина
[01:50:52.240 --> 01:50:54.240]  в итоге не вошла
[01:50:54.240 --> 01:50:56.240]  в маску, то она
[01:50:56.240 --> 01:50:58.240]  в маску вершины V, то она над
[01:50:58.240 --> 01:51:00.240]  вершиной V, очевидно, не доминирует.
[01:51:00.240 --> 01:51:02.240]  Да.
[01:51:02.240 --> 01:51:04.240]  Ну, просто по индукции.
[01:51:04.240 --> 01:51:06.240]  Вот.
[01:51:06.240 --> 01:51:08.240]  Это очевидно, но с другой стороны,
[01:51:08.240 --> 01:51:10.240]  может быть, там в результате
[01:51:10.240 --> 01:51:12.240]  этого DFS, там какие-то вершины
[01:51:12.240 --> 01:51:14.240]  в маске окажутся все доминаторы
[01:51:14.240 --> 01:51:16.240]  V и еще
[01:51:16.240 --> 01:51:18.240]  какие-то пара лишних вершин.
[01:51:18.240 --> 01:51:20.240]  Может такое быть?
[01:51:22.240 --> 01:51:24.240]  Ну, рассмотрим путь, который содержит
[01:51:24.240 --> 01:51:26.240]  одну таких вершин.
[01:51:26.240 --> 01:51:28.240]  Ну, да.
[01:51:28.240 --> 01:51:30.240]  Ну, понятно, что у корни
[01:51:30.240 --> 01:51:32.240]  этой штуки нет, начинает
[01:51:32.240 --> 01:51:34.240]  быть дискретно неприятность.
[01:51:34.240 --> 01:51:36.240]  Здесь какая-то маска, которая не содержит
[01:51:36.240 --> 01:51:38.240]  эту вершину.
[01:51:38.240 --> 01:51:40.240]  Ну, в принципе, да.
[01:51:40.240 --> 01:51:42.240]  И у нас есть предварительное, что мы через нее
[01:51:42.240 --> 01:51:44.240]  не обдавили маску.
[01:51:44.240 --> 01:51:46.240]  Нет, ну да.
[01:51:46.240 --> 01:51:48.240]  Да, действительно, заметим, что можно рассмотреть,
[01:51:48.240 --> 01:51:50.240]  если вершина U не доминирует на V,
[01:51:50.240 --> 01:51:52.240]  то можно рассмотреть любой путь от R до V
[01:51:52.240 --> 01:51:54.240]  и аккуратненько тоже по индукции
[01:51:54.240 --> 01:51:56.240]  доказать, что в итоге в маске
[01:51:56.240 --> 01:51:58.240]  каждой из этих вершин ушечки
[01:51:58.240 --> 01:52:00.240]  не будет.
[01:52:00.240 --> 01:52:02.240]  Ну, просто потому что,
[01:52:02.240 --> 01:52:04.240]  как минимум, потому что, когда мы запускались из R,
[01:52:04.240 --> 01:52:06.240]  мы уже сразу там, пробежимся
[01:52:06.240 --> 01:52:08.240]  по этому ребру и попытаемся
[01:52:08.240 --> 01:52:10.240]  обновить эту вершину маской без U.
[01:52:10.240 --> 01:52:12.240]  Значит, мы забываем ее нот.
[01:52:12.240 --> 01:52:14.240]  Вот.
[01:52:14.240 --> 01:52:16.240]  То есть, либо она обновится,
[01:52:16.240 --> 01:52:18.240]  и мы прямо сейчас тогда запустимся без U,
[01:52:18.240 --> 01:52:20.240]  либо она уже без U, значит, мы из нее запускались раньше,
[01:52:20.240 --> 01:52:22.240]  причем когда она уже становилась без U.
[01:52:22.240 --> 01:52:24.240]  Но когда мы из нее запускались,
[01:52:24.240 --> 01:52:26.240]  мы тогда пытались сделать вот эту вершину без U,
[01:52:26.240 --> 01:52:28.240]  ну и так далее.
[01:52:28.240 --> 01:52:30.240]  Вот. Поэтому, да, здесь
[01:52:30.240 --> 01:52:32.240]  доказательство получается простое.
[01:52:32.240 --> 01:52:34.240]  Другой вопрос, действительно, что тут NM...
[01:52:34.240 --> 01:52:36.240]  Ну, здорово стоит, что еще тут может быть?
[01:52:36.240 --> 01:52:38.240]  Но, кстати, давайте посмотрим.
[01:52:38.240 --> 01:52:40.240]  Да, ну тут вот, если какая-то вопрос, действительно,
[01:52:40.240 --> 01:52:42.240]  да, как интересно, о авоциклическом графе
[01:52:42.240 --> 01:52:44.240]  действительно это
[01:52:44.240 --> 01:52:46.240]  можно улучшить симптотику?
[01:52:48.240 --> 01:52:50.240]  Ну, в порядке обратного топсорта, наверное.
[01:52:50.240 --> 01:52:52.240]  Нет, ну, в принципе, да, на самом деле, да, если...
[01:52:52.240 --> 01:52:54.240]  Нет, ну, тут так, да.
[01:52:54.240 --> 01:52:56.240]  Ну, на самом деле, так.
[01:52:56.240 --> 01:52:58.240]  К сожалению, я боюсь улучшить вот эту вот симптотику,
[01:52:58.240 --> 01:53:00.240]  наверное, получится не очень.
[01:53:02.240 --> 01:53:04.240]  Чего?
[01:53:04.240 --> 01:53:06.240]  Ну, разве что, да, потому что
[01:53:06.240 --> 01:53:08.240]  проблема в том, что мы можем
[01:53:08.240 --> 01:53:10.240]  как бы пройти по этому ребру, а потом
[01:53:10.240 --> 01:53:12.240]  пройти еще, допустим, вот по этому
[01:53:12.240 --> 01:53:14.240]  какому-то.
[01:53:14.240 --> 01:53:16.240]  Вот.
[01:53:16.240 --> 01:53:18.240]  Вот.
[01:53:18.240 --> 01:53:20.240]  Ну, вот.
[01:53:20.240 --> 01:53:22.240]  Допустим, тут пройти, хотя...
[01:53:22.240 --> 01:53:24.240]  Хотя...
[01:53:24.240 --> 01:53:26.240]  Да, потому что кажется, мы можем просто рассматривать
[01:53:26.240 --> 01:53:28.240]  совершенно несколько вариантов, чтобы запускать
[01:53:28.240 --> 01:53:30.240]  дфс только один раз.
[01:53:30.240 --> 01:53:32.240]  Сейчас, чего еще раз только? Чего запускать?
[01:53:32.240 --> 01:53:34.240]  Кажется, мы можем идти в такой порядок,
[01:53:34.240 --> 01:53:36.240]  яшим, но так и...
[01:53:36.240 --> 01:53:38.240]  Ну, да, потому что... Ну, да, можно, в принципе, да.
[01:53:38.240 --> 01:53:40.240]  Ну, да, просто ациклический граф
[01:53:40.240 --> 01:53:42.240]  можно допилить так. Ну, можно допилить, да,
[01:53:42.240 --> 01:53:44.240]  то есть, на самом деле, это будет правда не дфс, а
[01:53:44.240 --> 01:53:46.240]  просто проход по топсорту, да.
[01:53:48.240 --> 01:53:50.240]  Нет, то это другое.
[01:53:50.240 --> 01:53:52.240]  То есть, топсорта надо сначала запустить
[01:53:52.240 --> 01:53:54.240]  чтобы найти топсорта, в порядке топсорта
[01:53:54.240 --> 01:53:56.240]  пропихивать масочки.
[01:53:56.240 --> 01:53:58.240]  Есть такая классика.
[01:53:58.240 --> 01:54:00.240]  Но, на самом деле, тут... Красивое
[01:54:00.240 --> 01:54:02.240]  определение тут немножко другое, потому что тут
[01:54:02.240 --> 01:54:04.240]  значит...
[01:54:04.240 --> 01:54:06.240]  То, что говорят тут немножко другое.
[01:54:06.240 --> 01:54:08.240]  Сейчас вот тут мне даже
[01:54:08.240 --> 01:54:10.240]  написано, что... Потому что
[01:54:10.240 --> 01:54:12.240]  там в теории компиляторов рассматриваются
[01:54:12.240 --> 01:54:14.240]  такие графы, но не буду сейчас писать,
[01:54:14.240 --> 01:54:16.240]  как такие сводимые графы
[01:54:16.240 --> 01:54:18.240]  или reducible графы.
[01:54:18.240 --> 01:54:20.240]  И говорят они...
[01:54:20.240 --> 01:54:22.240]  И говорят они, предположим, что
[01:54:22.240 --> 01:54:24.240]  помимо...
[01:54:24.240 --> 01:54:26.240]  И предположим,
[01:54:26.240 --> 01:54:28.240]  что у нас есть...
[01:54:28.240 --> 01:54:30.240]  То есть, предположим, что у нас
[01:54:30.240 --> 01:54:32.240]  допустим, совершенно случайно оказалось,
[01:54:32.240 --> 01:54:34.240]  что на самом деле
[01:54:34.240 --> 01:54:36.240]  не все ребра есть, а есть только
[01:54:36.240 --> 01:54:38.240]  ребра, допустим, прямые,
[01:54:38.240 --> 01:54:40.240]  причем прямыми тут называются
[01:54:40.240 --> 01:54:42.240]  ребра, которые формируют, собственно,
[01:54:42.240 --> 01:54:44.240]  так сказать, дерево дфс,
[01:54:44.240 --> 01:54:46.240]  допустим, да, и обратные
[01:54:46.240 --> 01:54:48.240]  ребра.
[01:54:48.240 --> 01:54:50.240]  И вот. То есть, предположим, что у нас оказалось
[01:54:50.240 --> 01:54:52.240]  только такое.
[01:54:52.240 --> 01:54:54.240]  Тогда утверждается, что в этом случае
[01:54:54.240 --> 01:54:56.240]  тогда этот алгоритм тоже за nm на 32
[01:54:56.240 --> 01:54:58.240]  вполне себе будет работать.
[01:55:00.240 --> 01:55:02.240]  Причем так в построении
[01:55:02.240 --> 01:55:04.240]  компиляторов утверждается, что
[01:55:04.240 --> 01:55:06.240]  такие графы как раз встречаются часто.
[01:55:06.240 --> 01:55:08.240]  Ну, там действительно надо это...
[01:55:08.240 --> 01:55:10.240]  То есть, как должен быть устроен код,
[01:55:10.240 --> 01:55:12.240]  чтобы у нас там в...
[01:55:12.240 --> 01:55:14.240]  Там, собственно, образовалось
[01:55:14.240 --> 01:55:16.240]  перекрестное ребро.
[01:55:16.240 --> 01:55:18.240]  Go to.
[01:55:18.240 --> 01:55:20.240]  О, да.
[01:55:20.240 --> 01:55:22.240]  Нет, ну да.
[01:55:22.240 --> 01:55:24.240]  Вот.
[01:55:24.240 --> 01:55:26.240]  А, ну ладно, правда, хорошо, ладно, еще могут
[01:55:26.240 --> 01:55:28.240]  образоваться реально прямые ребра,
[01:55:28.240 --> 01:55:30.240]  которые у нас просто перескакивают, потому что у нас же может быть вот этот
[01:55:30.240 --> 01:55:32.240]  if-чик, правда?
[01:55:32.240 --> 01:55:34.240]  То есть, if что-то, то мы тут делаем...
[01:55:34.240 --> 01:55:36.240]  То есть, вот эта вот типичная вот эта ситуация, да.
[01:55:36.240 --> 01:55:38.240]  То есть, вот такая вот эта. Ну вот.
[01:55:38.240 --> 01:55:40.240]  Ну вот, соответственно, там утверждается, что
[01:55:40.240 --> 01:55:42.240]  если у нас есть только такие...
[01:55:42.240 --> 01:55:44.240]  Ну вот.
[01:55:44.240 --> 01:55:46.240]  То есть, если у нас есть действительно только такое,
[01:55:46.240 --> 01:55:48.240]  то тогда у нас оказывается, что
[01:55:48.240 --> 01:55:50.240]  почему... Утверждается, что
[01:55:50.240 --> 01:55:52.240]  граф тогда за там нормальный
[01:55:52.240 --> 01:55:54.240]  nm на 32 вполне себе работать будет.
[01:55:54.240 --> 01:55:56.240]  То есть, такие вот
[01:55:56.240 --> 01:55:58.240]  утверждения возникли.
[01:55:58.240 --> 01:56:00.240]  Вот.
[01:56:00.240 --> 01:56:02.240]  Соответственно, странная она вот.
[01:56:02.240 --> 01:56:04.240]  То есть, немножко, конечно, странная, потому что
[01:56:04.240 --> 01:56:06.240]  кажется, что у нас здесь действительно в эту вершину
[01:56:06.240 --> 01:56:08.240]  мы все равно можем зайти много-много раз.
[01:56:08.240 --> 01:56:10.240]  На самом деле.
[01:56:10.240 --> 01:56:12.240]  Потому что хочется... Потому что nm на 32
[01:56:12.240 --> 01:56:14.240]  намекает, конечно, что мы должны
[01:56:14.240 --> 01:56:16.240]  каждую вершину
[01:56:16.240 --> 01:56:18.240]  рассмотреть только один раз.
[01:56:18.240 --> 01:56:20.240]  Ну или, по крайней мере, от единицы.
[01:56:22.240 --> 01:56:24.240]  Но как-то получается, что не ухи.
[01:56:24.240 --> 01:56:26.240]  Впрочем... Хотя, с другой стороны,
[01:56:26.240 --> 01:56:28.240]  заметим, что если мы тут прошли по этому ребро,
[01:56:28.240 --> 01:56:30.240]  а потом прошли по этому, то как-то
[01:56:30.240 --> 01:56:32.240]  есть... То как-то там по этим вот,
[01:56:32.240 --> 01:56:34.240]  то есть подозрение, что мы...
[01:56:36.240 --> 01:56:38.240]  Что мы, возможно... Если это
[01:56:38.240 --> 01:56:40.240]  было дерево DFS, то мы, по-моему, из этой
[01:56:40.240 --> 01:56:42.240]  вершины могли ничего нового не узнать.
[01:56:46.240 --> 01:56:48.240]  Да.
[01:56:48.240 --> 01:56:50.240]  Ну если это реально дерево DFS такое.
[01:56:52.240 --> 01:56:54.240]  Вот.
[01:56:54.240 --> 01:56:56.240]  Но, впрочем, не суть.
[01:56:56.240 --> 01:56:58.240]  Ладно, не будем
[01:56:58.240 --> 01:57:00.240]  сейчас на эту тему заморачиваться.
[01:57:00.240 --> 01:57:02.240]  То есть, здесь это для интересующихся, соответственно,
[01:57:02.240 --> 01:57:04.240]  просто отсылаю, просто вот, соответственно,
[01:57:04.240 --> 01:57:06.240]  к этой книжке и, соответственно, к статьям, которые там
[01:57:06.240 --> 01:57:08.240]  дальше есть. Но тем более,
[01:57:08.240 --> 01:57:10.240]  что нам это не особо принципиально,
[01:57:10.240 --> 01:57:12.240]  потому что, как вы уже догадываетесь, мы тут себе...
[01:57:12.240 --> 01:57:14.240]  У нас тут ставки на более серьезные симптомики,
[01:57:14.240 --> 01:57:16.240]  в любом случае.
[01:57:16.240 --> 01:57:18.240]  Чего?
[01:57:18.240 --> 01:57:20.240]  N-куп?
[01:57:20.240 --> 01:57:22.240]  Ага, нет, зачем нам это? Нет, хуже,
[01:57:22.240 --> 01:57:24.240]  нет. Ну сформируем так.
[01:57:24.240 --> 01:57:26.240]  Нет, наша ставка, как уже было
[01:57:26.240 --> 01:57:28.240]  сказано, наша ставка
[01:57:28.240 --> 01:57:30.240]  называется E, она там в идеале
[01:57:30.240 --> 01:57:32.240]  обратную функцию какую-то там вот эту вот.
[01:57:34.240 --> 01:57:36.240]  Да. Это будет ближе к
[01:57:36.240 --> 01:57:38.240]  СНМ, но не то.
[01:57:40.240 --> 01:57:42.240]  Со ссылкой на структуру.
[01:57:44.240 --> 01:57:46.240]  Вот, со ссылкой на структуру, но
[01:57:46.240 --> 01:57:48.240]  это уже просто тема, возможно, отдельного занятия,
[01:57:48.240 --> 01:57:50.240]  изучать, к чему СНМ за обратную функцию
[01:57:50.240 --> 01:57:52.240]  от Ермана работает. Чего?
[01:57:52.240 --> 01:57:54.240]  Нет, это
[01:57:54.240 --> 01:57:56.240]  будет что-то близкое.
[01:57:56.240 --> 01:57:58.240]  То есть, на самом деле, это будет такая структура
[01:57:58.240 --> 01:58:00.240]  данных, которая будет
[01:58:00.240 --> 01:58:02.240]  делать сжатие путей.
[01:58:02.240 --> 01:58:04.240]  Вот.
[01:58:04.240 --> 01:58:06.240]  Но там просто она будет хотеть не совсем
[01:58:06.240 --> 01:58:08.240]  СНМ.
[01:58:08.240 --> 01:58:10.240]  То есть, она будет, ну ладно, давайте я скажу,
[01:58:10.240 --> 01:58:12.240]  что она будет. То есть,
[01:58:12.240 --> 01:58:14.240]  будет такая мистическая, ну в идеале хочется
[01:58:14.240 --> 01:58:16.240]  так. Потому что
[01:58:16.240 --> 01:58:18.240]  значит, хочется, чтобы у нас были подвешенные
[01:58:18.240 --> 01:58:20.240]  деревья,
[01:58:20.240 --> 01:58:22.240]  с которыми хочется поступать
[01:58:22.240 --> 01:58:24.240]  следующим образом.
[01:58:24.240 --> 01:58:26.240]  Ну, во-первых, хочется
[01:58:26.240 --> 01:58:28.240]  учиться одно дерево подвешивать
[01:58:28.240 --> 01:58:30.240]  другому.
[01:58:30.240 --> 01:58:32.240]  Ну, там, допустим, вот куда-нибудь
[01:58:32.240 --> 01:58:34.240]  хотя бы.
[01:58:34.240 --> 01:58:36.240]  Хотя, по факту,
[01:58:36.240 --> 01:58:38.240]  на самом деле, нет. Мы, хотя нам
[01:58:38.240 --> 01:58:40.240]  сейчас достаточно будет, чтобы мы только корень
[01:58:40.240 --> 01:58:42.240]  к корню подвешивали.
[01:58:42.240 --> 01:58:44.240]  Вот, понимаете, да?
[01:58:48.240 --> 01:58:50.240]  Но нам будет хотеться
[01:58:50.240 --> 01:58:52.240]  еще кое-чего.
[01:58:52.240 --> 01:58:54.240]  То есть,
[01:58:54.240 --> 01:58:56.240]  нам еще будет хотеться, чтобы
[01:58:56.240 --> 01:58:58.240]  на каждой
[01:58:58.240 --> 01:59:00.240]  на каждой вершине написаны какие-то
[01:59:00.240 --> 01:59:02.240]  числа.
[01:59:02.240 --> 01:59:04.240]  Там, типа, пять, семь, два, там, четыре,
[01:59:04.240 --> 01:59:06.240]  восемь, там, шесть, там, семь,
[01:59:06.240 --> 01:59:08.240]  два. Ну, там от балды.
[01:59:08.240 --> 01:59:10.240]  И на них
[01:59:10.240 --> 01:59:12.240]  хочется делать еще какую-то
[01:59:12.240 --> 01:59:14.240]  и хочется делать какие-то операции.
[01:59:14.240 --> 01:59:16.240]  То есть, операции такие. То есть, даны деревья
[01:59:16.240 --> 01:59:18.240]  объединив, то есть, подвесь один
[01:59:18.240 --> 01:59:20.240]  корень к другому.
[01:59:20.240 --> 01:59:22.240]  И захочется после этого
[01:59:22.240 --> 01:59:24.240]  еще сказать что-нибудь вроде
[01:59:24.240 --> 01:59:26.240]  возьми-ка ты, пожалуйста, какую-нибудь вершину
[01:59:26.240 --> 01:59:28.240]  и верни мне, а к чему равен, допустим,
[01:59:28.240 --> 01:59:30.240]  максимум на пути
[01:59:30.240 --> 01:59:32.240]  от этой вершины до этой.
[01:59:36.240 --> 01:59:38.240]  Да, кайф. Я согласен, да, линкат.
[01:59:38.240 --> 01:59:40.240]  Но на самом деле
[01:59:40.240 --> 01:59:42.240]  нет, линкат не нужен.
[01:59:42.240 --> 01:59:44.240]  А, потому что, ладно,
[01:59:44.240 --> 01:59:46.240]  давайте-ка я еще тут, значит, тогда
[01:59:46.240 --> 01:59:48.240]  сейчас я еще тут поглядю, потому что
[01:59:48.240 --> 01:59:50.240]  мало того, что эти чиселки будут хотеться.
[01:59:50.240 --> 01:59:52.240]  Потому что, значит,
[01:59:52.240 --> 01:59:54.240]  это я уже сказал, потому что операции
[01:59:54.240 --> 01:59:56.240]  действительно будут у нас линк УВ,
[01:59:56.240 --> 01:59:58.240]  то есть, там подвесь какой там.
[01:59:58.240 --> 02:00:00.240]  Есть операция
[02:00:00.240 --> 02:00:02.240]  ЭВАЛ, то есть, это вот, типа
[02:00:02.240 --> 02:00:04.240]  найди максимум от У до
[02:00:04.240 --> 02:00:06.240]  корня. И кое-что еще.
[02:00:06.240 --> 02:00:08.240]  Потому что структура называется
[02:00:08.240 --> 02:00:10.240]  ЭВАЛ линк апдейт, на самом деле.
[02:00:12.240 --> 02:00:14.240]  Значит, что это такое?
[02:00:16.240 --> 02:00:18.240]  Значит,
[02:00:18.240 --> 02:00:20.240]  что это у нас такое?
[02:00:20.240 --> 02:00:22.240]  Так, так,
[02:00:22.240 --> 02:00:24.240]  ой, у меня тут записано, что это такое,
[02:00:24.240 --> 02:00:26.240]  или нам это тоже не нужно.
[02:00:26.240 --> 02:00:28.240]  Ну, потому что
[02:00:28.240 --> 02:00:30.240]  в идеале там начинается какая догадка,
[02:00:30.240 --> 02:00:32.240]  то есть, в данном случае, то есть, в нашем случае
[02:00:32.240 --> 02:00:34.240]  это получится, что апдейт нужен что-то там, типа
[02:00:34.240 --> 02:00:36.240]  что там
[02:00:36.240 --> 02:00:38.240]  вал от У, там должно быть
[02:00:38.240 --> 02:00:40.240]  максимум равно х, по-моему, или что-то в этом
[02:00:40.240 --> 02:00:42.240]  роде.
[02:00:42.240 --> 02:00:44.240]  Вот.
[02:00:44.240 --> 02:00:46.240]  Вот.
[02:00:46.240 --> 02:00:48.240]  То есть, ладно, в нашем случае
[02:00:48.240 --> 02:00:50.240]  этого не потребуется, на самом деле.
[02:00:52.240 --> 02:00:54.240]  А это вот, ну, смотри,
[02:00:54.240 --> 02:00:56.240]  на каждой вершинке написаны
[02:00:56.240 --> 02:00:58.240]  чиселки У, да?
[02:00:58.240 --> 02:01:00.240]  И нам очень захочется, ну вот,
[02:01:00.240 --> 02:01:02.240]  то есть, вал от У. То есть, ЭВАЛ от У
[02:01:02.240 --> 02:01:04.240]  говорит так, я хочу пройти
[02:01:04.240 --> 02:01:06.240]  по пути от У до корня,
[02:01:06.240 --> 02:01:08.240]  взять все эти валы и вернуть из них
[02:01:08.240 --> 02:01:10.240]  максимум.
[02:01:10.240 --> 02:01:12.240]  Да, давайте
[02:01:12.240 --> 02:01:14.240]  сразу подумаем, как такое решать?
[02:01:14.240 --> 02:01:16.240]  Ну, во-первых, да, у нас, конечно, есть линк ап,
[02:01:16.240 --> 02:01:18.240]  который прекрасно это умеет.
[02:01:18.240 --> 02:01:20.240]  Нет, вот, ладно, с апдейтом.
[02:01:20.240 --> 02:01:22.240]  Хотя нет,
[02:01:22.240 --> 02:01:24.240]  вал от У тут максимум равно х,
[02:01:24.240 --> 02:01:26.240]  и при этом тоже гарантируется, что у корень.
[02:01:26.240 --> 02:01:28.240]  Да, там.
[02:01:28.240 --> 02:01:30.240]  Ну, как халява, да.
[02:01:30.240 --> 02:01:32.240]  То есть, заметим, что в таком варианте
[02:01:32.240 --> 02:01:34.240]  линк ап не нужен.
[02:01:34.240 --> 02:01:36.240]  Потому что, да, мы это в какой-то момент докажем,
[02:01:36.240 --> 02:01:38.240]  но пока есть просто знание, что
[02:01:38.240 --> 02:01:40.240]  на самом деле, если мы просто это будем делать,
[02:01:40.240 --> 02:01:42.240]  как в СНМ, и применять тупо
[02:01:42.240 --> 02:01:44.240]  только эвристику сжатия путей,
[02:01:44.240 --> 02:01:46.240]  ну вот,
[02:01:46.240 --> 02:01:48.240]  то, в принципе,
[02:01:48.240 --> 02:01:50.240]  уже гарантируется, что там
[02:01:50.240 --> 02:01:52.240]  можно показать, что
[02:01:52.240 --> 02:01:54.240]  учетная стоимость будет логарифом.
[02:01:54.240 --> 02:01:56.240]  Но там даже есть более,
[02:01:56.240 --> 02:01:58.240]  на самом деле, жесткое утверждение,
[02:01:58.240 --> 02:02:00.240]  которое там говорит, что
[02:02:00.240 --> 02:02:02.240]  чем ближе m будет к n квадрату,
[02:02:02.240 --> 02:02:04.240]  тем больше эта учетная стоимость будет похожа
[02:02:04.240 --> 02:02:06.240]  на единицу, на самом деле.
[02:02:06.240 --> 02:02:08.240]  То есть, она будет всегда не больше, чем
[02:02:08.240 --> 02:02:10.240]  лог n, но
[02:02:10.240 --> 02:02:12.240]  приближаться к единице она будет,
[02:02:12.240 --> 02:02:14.240]  что-то такое.
[02:02:14.240 --> 02:02:16.240]  Есть там более общая теорема
[02:02:16.240 --> 02:02:18.240]  говорит о том, что в общем случае все будет учетно
[02:02:18.240 --> 02:02:20.240]  за логарифом, но
[02:02:20.240 --> 02:02:22.240]  если гарантируется, что это дерево хоть
[02:02:22.240 --> 02:02:24.240]  насколько-то сбалансировано,
[02:02:24.240 --> 02:02:26.240]  ну там, сбалансированность
[02:02:26.240 --> 02:02:28.240]  гарантируется, что там
[02:02:28.240 --> 02:02:30.240]  типа, что
[02:02:30.240 --> 02:02:32.240]  допустим, что на каждой глубине
[02:02:32.240 --> 02:02:34.240]  находится вершина не более, чем там,
[02:02:34.240 --> 02:02:36.240]  по-моему, что-то типа там, а в какой-то степени,
[02:02:36.240 --> 02:02:38.240]  где, а там еще и там
[02:02:38.240 --> 02:02:40.240]  в какой-то момент.
[02:02:40.240 --> 02:02:42.240]  Ну, то есть, это не сильно так расширяется
[02:02:42.240 --> 02:02:44.240]  аккуратненько, то тогда кажется, что все
[02:02:44.240 --> 02:02:46.240]  действительно работает за вот этого вот
[02:02:46.240 --> 02:02:48.240]  кирмана. Ну вот,
[02:02:48.240 --> 02:02:50.240]  и там дальше начинается то, что для
[02:02:50.240 --> 02:02:52.240]  вот этого максимума, на самом деле, дерево можно
[02:02:52.240 --> 02:02:54.240]  модифицировать так, чтобы какие запросы не были,
[02:02:54.240 --> 02:02:56.240]  а на самом деле можно сделать так, чтобы там
[02:02:56.240 --> 02:02:58.240]  дерево было вот это вот сбалансировано.
[02:02:58.240 --> 02:03:00.240]  Так, да,
[02:03:00.240 --> 02:03:02.240]  это называется краткое, да, это краткое
[02:03:02.240 --> 02:03:04.240]  содержание соседней статьи Торьяна.
[02:03:04.240 --> 02:03:06.240]  Вот.
[02:03:06.240 --> 02:03:08.240]  Просто это вот на отдельную структуру
[02:03:08.240 --> 02:03:10.240]  данных, вот.
[02:03:10.240 --> 02:03:12.240]  То есть, для нас в принципе, то есть, для Олимпиады
[02:03:12.240 --> 02:03:14.240]  к цели можно просто хватать, что сжатие путей
[02:03:14.240 --> 02:03:16.240]  дает логарифм, поэтому в принципе
[02:03:16.240 --> 02:03:18.240]  там и отсюда и получится там алгоритм за
[02:03:18.240 --> 02:03:20.240]  е лог в. Вот.
[02:03:20.240 --> 02:03:22.240]  Хотя, на самом деле отсылаемся на,
[02:03:22.240 --> 02:03:24.240]  имеем в виду, что отсылаемся на более
[02:03:24.240 --> 02:03:26.240]  продвинутую структуру данных и
[02:03:26.240 --> 02:03:28.240]  может быть там на каком-то отдельном занятии
[02:03:28.240 --> 02:03:30.240]  мы это даже и рассмотрим. По крайней мере,
[02:03:30.240 --> 02:03:32.240]  мне бы этого очень хотелось, но я это уже
[02:03:32.240 --> 02:03:34.240]  говорил. Вот.
[02:03:34.240 --> 02:03:36.240]  Нет, ну, в прочем, в принципе,
[02:03:36.240 --> 02:03:38.240]  в прочем, как-то раз нам, по-моему,
[02:03:38.240 --> 02:03:40.240]  нам на самом деле удалось доказать, что СНМ работает
[02:03:40.240 --> 02:03:42.240]  за Акермана. Вот. Там, хотя первая
[02:03:42.240 --> 02:03:44.240]  сложность, понятие, что это за Акерман вообще
[02:03:44.240 --> 02:03:46.240]  такой.
[02:03:46.240 --> 02:03:48.240]  Вот.
[02:03:48.240 --> 02:03:50.240]  Да, тем более... Нет,
[02:03:50.240 --> 02:03:52.240]  там определение уже не самое простое
[02:03:52.240 --> 02:03:54.240]  и, во-первых, под всеми этими альфами
[02:03:54.240 --> 02:03:56.240]  часто появляются разные функции, на самом деле.
[02:03:56.240 --> 02:03:58.240]  То есть, скажем, как я уже
[02:03:58.240 --> 02:04:00.240]  говорил, что, например, помните, в софтхипе,
[02:04:00.240 --> 02:04:02.240]  как я уже говорил, там возникнет другая функция.
[02:04:02.240 --> 02:04:04.240]  Там возникнет функция
[02:04:04.240 --> 02:04:06.240]  бета, про которую только в конце докажут, что
[02:04:06.240 --> 02:04:08.240]  там не более чем альфа умножить на 9.
[02:04:10.240 --> 02:04:12.240]  На самом деле. Поэтому, типа,
[02:04:12.240 --> 02:04:14.240]  это одна и та же функция, но там просто она другая.
[02:04:14.240 --> 02:04:16.240]  Но там просто зависит от того, что в алгоритме
[02:04:16.240 --> 02:04:18.240]  откуда-то рекурренты возьмутся какие-то.
[02:04:18.240 --> 02:04:20.240]  Так вот, ладно. Значит,
[02:04:20.240 --> 02:04:22.240]  это у нас скорее небольшой анонс был.
[02:04:22.240 --> 02:04:24.240]  Вот. Так что
[02:04:24.240 --> 02:04:26.240]  теперь давайте приступим. Значит, как же нам искать хотя бы
[02:04:26.240 --> 02:04:28.240]  за Е лог В? Это дерево
[02:04:28.240 --> 02:04:30.240]  доминаторов.
[02:04:30.240 --> 02:04:32.240]  Но нам поможет одна маленькая
[02:04:32.240 --> 02:04:34.240]  техническая лемма, которую тоже можно было, наверное,
[02:04:34.240 --> 02:04:36.240]  вставить в теорию ДФСа.
[02:04:36.240 --> 02:04:38.240]  Хотя, в принципе, сейчас
[02:04:38.240 --> 02:04:40.240]  она не будет... Сейчас то, что я
[02:04:40.240 --> 02:04:42.240]  сформулирую, лемма не будет иметь никакого
[02:04:42.240 --> 02:04:44.240]  отношения, значит, к
[02:04:44.240 --> 02:04:46.240]  теории ДФСа.
[02:04:46.240 --> 02:04:48.240]  Наоборот, к теории доминаторов.
[02:04:50.240 --> 02:04:52.240]  Как бы мысль правильно сформулировать?
[02:04:52.240 --> 02:04:54.240]  Больше нет. Она будет
[02:04:54.240 --> 02:04:56.240]  иметь отношение к теории доминаторов, просто ее
[02:04:56.240 --> 02:04:58.240]  формулировка к доминации не будет иметь отношения.
[02:05:00.240 --> 02:05:02.240]  Вот почему у меня была лемма один штрих.
[02:05:04.240 --> 02:05:06.240]  Да.
[02:05:06.240 --> 02:05:08.240]  Потому что она будет называться лемма один.
[02:05:08.240 --> 02:05:10.240]  Да. Вот.
[02:05:10.240 --> 02:05:12.240]  Истинная лемма один.
[02:05:14.240 --> 02:05:16.240]  Значит, запустим ДФС.
[02:05:18.240 --> 02:05:20.240]  Там ДФС из R.
[02:05:20.240 --> 02:05:22.240]  Пусть
[02:05:22.240 --> 02:05:24.240]  значит таймы над
[02:05:24.240 --> 02:05:26.240]  U оказался
[02:05:26.240 --> 02:05:28.240]  таймы над U оказался
[02:05:28.240 --> 02:05:30.240]  меньше, чем таймы над
[02:05:30.240 --> 02:05:32.240]  V.
[02:05:34.240 --> 02:05:36.240]  Тогда
[02:05:36.240 --> 02:05:38.240]  любой путь
[02:05:40.240 --> 02:05:42.240]  из
[02:05:42.240 --> 02:05:44.240]  U в
[02:05:44.240 --> 02:05:46.240]  V
[02:05:46.240 --> 02:05:48.240]  содержит
[02:05:54.240 --> 02:05:56.240]  что?
[02:05:56.240 --> 02:05:58.240]  Содержит U и V.
[02:05:58.240 --> 02:06:00.240]  Замечательно.
[02:06:00.240 --> 02:06:02.240]  Что потенциал?
[02:06:02.240 --> 02:06:04.240]  LCA.
[02:06:04.240 --> 02:06:06.240]  Но
[02:06:06.240 --> 02:06:08.240]  это неправда.
[02:06:08.240 --> 02:06:10.240]  Нет, LCA.
[02:06:10.240 --> 02:06:12.240]  Нет, я вам сразу скажу нет.
[02:06:12.240 --> 02:06:14.240]  Нет, LCA это просто заведомая
[02:06:14.240 --> 02:06:16.240]  неправда, потому что
[02:06:16.240 --> 02:06:18.240]  вполне вероятно, что
[02:06:18.240 --> 02:06:20.240]  во-первых, существует прямое ребро сюда,
[02:06:20.240 --> 02:06:22.240]  а во-вторых, обратное ребро сюда.
[02:06:24.240 --> 02:06:26.240]  Вот. А вот
[02:06:26.240 --> 02:06:28.240]  верно от вещей, что содержит
[02:06:28.240 --> 02:06:30.240]  некоторого
[02:06:30.240 --> 02:06:32.240]  общего предка.
[02:06:36.240 --> 02:06:38.240]  То есть как бы
[02:06:38.240 --> 02:06:40.240]  CA, но не обязательно
[02:06:40.240 --> 02:06:42.240]  LCA.
[02:06:46.240 --> 02:06:48.240]  Нет.
[02:06:48.240 --> 02:06:50.240]  Не обязательно.
[02:06:52.240 --> 02:06:54.240]  Потому что я на любом
[02:06:54.240 --> 02:06:56.240]  предке вот
[02:06:56.240 --> 02:06:58.240]  такую картинку нарисовать.
[02:07:00.240 --> 02:07:02.240]  Ну,
[02:07:02.240 --> 02:07:04.240]  предок, естественно, имеется в виду
[02:07:04.240 --> 02:07:06.240]  в дереве DFS.
[02:07:08.240 --> 02:07:10.240]  Да.
[02:07:10.240 --> 02:07:12.240]  Теперь у нас действительно актуально понятие
[02:07:12.240 --> 02:07:14.240]  именно дерева DFS.
[02:07:14.240 --> 02:07:16.240]  Потому что мы в главе играет в поток
[02:07:16.240 --> 02:07:18.240]  управления зердость режима, все, поэтому ура.
[02:07:18.240 --> 02:07:20.240]  Так что вот такая
[02:07:20.240 --> 02:07:22.240]  лемма нам должна пригодиться
[02:07:22.240 --> 02:07:24.240]  по идее.
[02:07:24.240 --> 02:07:26.240]  Так, ну давайте поймем.
[02:07:26.240 --> 02:07:28.240]  Так, ну давайте думать,
[02:07:28.240 --> 02:07:30.240]  почему, собственно, это так.
[02:07:34.240 --> 02:07:36.240]  Да, равно, как и если вы
[02:07:36.240 --> 02:07:38.240]  предоку, да.
[02:07:38.240 --> 02:07:40.240]  Завечательно.
[02:07:44.240 --> 02:07:46.240]  Так, супер.
[02:07:58.240 --> 02:08:00.240]  Увеличивать, простите, да, я запутался.
[02:08:00.240 --> 02:08:02.240]  Вот, потому что у нас
[02:08:02.240 --> 02:08:04.240]  в начале, ну так, у нас
[02:08:04.240 --> 02:08:06.240]  между ВИНКО есть определенное
[02:08:06.240 --> 02:08:08.240]  соотношение, нам нужно посмотреть,
[02:08:08.240 --> 02:08:10.240]  есть вершины, которые также
[02:08:10.240 --> 02:08:12.240]  увеличивают это.
[02:08:12.240 --> 02:08:14.240]  Увеличивают такие
[02:08:14.240 --> 02:08:16.240]  ребра, такие ребра
[02:08:16.240 --> 02:08:18.240]  называются у нас вроде как обратными, только такие.
[02:08:18.240 --> 02:08:20.240]  Сейчас, нет, обратные ребра что увеличивают?
[02:08:20.240 --> 02:08:22.240]  Обратные ребра тайминг как раз уменьшают.
[02:08:22.240 --> 02:08:24.240]  Уменьшают. Да.
[02:08:24.240 --> 02:08:26.240]  Да, у нас нет перекрестных
[02:08:26.240 --> 02:08:28.240]  ребр. То есть, замечу так,
[02:08:28.240 --> 02:08:30.240]  что, как и да, что увеличивают ребра
[02:08:30.240 --> 02:08:32.240]  тайминг, у нас только ребра дерева
[02:08:32.240 --> 02:08:34.240]  ДФС и прямые ребра.
[02:08:36.240 --> 02:08:38.240]  Да, даже перекрестные ребра
[02:08:38.240 --> 02:08:40.240]  они тайминг уменьшают, напоминаю.
[02:08:40.240 --> 02:08:42.240]  Ладно, тогда у нас
[02:08:42.240 --> 02:08:44.240]  есть...
[02:08:46.240 --> 02:08:48.240]  Вот, теперь, если В
[02:08:48.240 --> 02:08:50.240]  не потомокуб, то
[02:08:50.240 --> 02:08:52.240]  получается, что они в разных деревьях
[02:08:52.240 --> 02:08:54.240]  населены какого-то общего предка. Да.
[02:08:54.240 --> 02:08:56.240]  Давайте, поехали.
[02:09:00.240 --> 02:09:02.240]  Почему это?
[02:09:04.240 --> 02:09:06.240]  Так, и что?
[02:09:06.240 --> 02:09:08.240]  Ну, мало ли.
[02:09:10.240 --> 02:09:12.240]  Как-то вообще, но
[02:09:12.240 --> 02:09:14.240]  вообще пока не понятно, мало ли, как мы там
[02:09:14.240 --> 02:09:16.240]  в В попали.
[02:09:24.240 --> 02:09:26.240]  По прямым ребрам и по ребрам ДФС
[02:09:26.240 --> 02:09:28.240]  мы смотрим на последний момент,
[02:09:28.240 --> 02:09:30.240]  когда мы пошли под кому ребру.
[02:09:30.240 --> 02:09:32.240]  Ну.
[02:09:32.240 --> 02:09:34.240]  Тогда очевидно, что если он не заходил
[02:09:34.240 --> 02:09:36.240]  в предков,
[02:09:36.240 --> 02:09:38.240]  тогда получается, что мы находимся где-то
[02:09:38.240 --> 02:09:40.240]  над В, но не над У.
[02:09:40.240 --> 02:09:42.240]  Тогда мы должны сейчас...
[02:09:44.240 --> 02:09:46.240]  Нет, логично уже все, да?
[02:09:46.240 --> 02:09:48.240]  Пока нет.
[02:09:48.240 --> 02:09:50.240]  Пока нет, потому что я пока ничего не понял.
[02:09:50.240 --> 02:09:52.240]  Нет, почему нет?
[02:09:52.240 --> 02:09:54.240]  Смысл может быть...
[02:09:54.240 --> 02:09:56.240]  Смысл может и есть, но пока его очень сложно
[02:09:56.240 --> 02:09:58.240]  понять. Вот так, скажем.
[02:10:00.240 --> 02:10:02.240]  Да, ну давайте смотреть.
[02:10:06.240 --> 02:10:08.240]  Не надо. Хочется, ну как минимум
[02:10:08.240 --> 02:10:10.240]  да, хочется, наверное, индукция, хочется
[02:10:10.240 --> 02:10:12.240]  запустить, конечно, индукцию по длине этого пути хотя бы.
[02:10:14.240 --> 02:10:16.240]  Да, да, во-первых, да, сейчас.
[02:10:16.240 --> 02:10:18.240]  Ну, во-первых, так с тем, что если путь состоит из одного
[02:10:18.240 --> 02:10:20.240]  ребра, то, как мы уже увидели,
[02:10:20.240 --> 02:10:22.240]  то это ребро у нас как бы либо ребро
[02:10:22.240 --> 02:10:24.240]  дерева ДФС, либо прямое, и все автоматически
[02:10:24.240 --> 02:10:26.240]  верно.
[02:10:26.240 --> 02:10:28.240]  Да, то есть это означает, что
[02:10:28.240 --> 02:10:30.240]  У и есть предок В.
[02:10:30.240 --> 02:10:32.240]  Так, отлично.
[02:10:32.240 --> 02:10:34.240]  Ну вот, хорошо.
[02:10:34.240 --> 02:10:36.240]  Ну теперь предположим, что путь больше
[02:10:36.240 --> 02:10:38.240]  чем один, но для меньших путей мы, допустим,
[02:10:38.240 --> 02:10:40.240]  что-то доказали.
[02:10:40.240 --> 02:10:42.240]  Что?
[02:10:42.240 --> 02:10:44.240]  Что-что?
[02:10:50.240 --> 02:10:52.240]  Так.
[02:10:52.240 --> 02:10:54.240]  Ну давайте посмотрим, да.
[02:10:54.240 --> 02:10:56.240]  Ну, во-первых, да, хочется сказать, что
[02:10:56.240 --> 02:10:58.240]  если на этом пути дальше встретится
[02:10:58.240 --> 02:11:00.240]  какой-то предок У,
[02:11:00.240 --> 02:11:02.240]  то в принципе этот предок либо уже сам общий
[02:11:02.240 --> 02:11:04.240]  предок, либо это какой-то этот предок, и дальше
[02:11:04.240 --> 02:11:06.240]  доказываем просто по индукции.
[02:11:06.240 --> 02:11:08.240]  Потому что получился более короткий
[02:11:08.240 --> 02:11:10.240]  путь из предка У, который будет проходить
[02:11:10.240 --> 02:11:12.240]  через общего предка это и это, и значит
[02:11:12.240 --> 02:11:14.240]  общего предка У и В.
[02:11:14.240 --> 02:11:16.240]  Так, и что?
[02:11:16.240 --> 02:11:18.240]  Но это если мы через
[02:11:18.240 --> 02:11:20.240]  предка как-нибудь пройдем.
[02:11:20.240 --> 02:11:22.240]  Так, да, чего?
[02:11:22.240 --> 02:11:24.240]  Все про то же. Мы можем смотреть.
[02:11:24.240 --> 02:11:26.240]  Давайте скажем, что у нас В и У
[02:11:26.240 --> 02:11:28.240]  не дадут друг друга предками, да?
[02:11:28.240 --> 02:11:30.240]  Да.
[02:11:30.240 --> 02:11:32.240]  Тогда можно сказать, что их отрезки тайминов
[02:11:32.240 --> 02:11:34.240]  ну типа от таймин до тайм-аута
[02:11:34.240 --> 02:11:36.240]  не пересекаются, и нет.
[02:11:36.240 --> 02:11:38.240]  Ну и не вложены. Да.
[02:11:38.240 --> 02:11:40.240]  Поэтому как относится у нас
[02:11:40.240 --> 02:11:42.240]  таймин, так и относится у нас тайм-аут.
[02:11:42.240 --> 02:11:44.240]  Да. Теперь мы говорим.
[02:11:44.240 --> 02:11:46.240]  Отлично. Вот теперь про тайм-ауты верно,
[02:11:46.240 --> 02:11:48.240]  потому что увеличиваются они
[02:11:48.240 --> 02:11:50.240]  только при обратных ребрах.
[02:11:54.240 --> 02:11:56.240]  Но при перекрестах уменьшаются,
[02:11:56.240 --> 02:11:58.240]  при прямых и
[02:11:58.240 --> 02:12:00.240]  ДФС уменьшаются.
[02:12:00.240 --> 02:12:02.240]  Так. Поэтому у нас должны быть
[02:12:02.240 --> 02:12:04.240]  обратные ребра, причем обратные ребра
[02:12:04.240 --> 02:12:06.240]  если мы прошли, давайте
[02:12:06.240 --> 02:12:08.240]  посмотрим последние обратные ребра,
[02:12:08.240 --> 02:12:10.240]  которые мы прошли.
[02:12:10.240 --> 02:12:12.240]  Оно утверждает, что оно должно вести
[02:12:12.240 --> 02:12:14.240]  в какую-то вершину, которой тайм-аут
[02:12:14.240 --> 02:12:16.240]  больше, чем у вершины В.
[02:12:18.240 --> 02:12:20.240]  Но оно должно вести в предка,
[02:12:20.240 --> 02:12:22.240]  потому что после этого нет обратных ребра.
[02:12:32.240 --> 02:12:34.240]  Так. Значит обратное
[02:12:34.240 --> 02:12:36.240]  ребро.
[02:12:36.240 --> 02:12:38.240]  Ага. Слушайте.
[02:12:38.240 --> 02:12:40.240]  Так. А ну-ка давайте попробуем.
[02:12:40.240 --> 02:12:42.240]  Ну-ка еще раз.
[02:12:42.240 --> 02:12:44.240]  Так.
[02:12:44.240 --> 02:12:46.240]  Так, так, так.
[02:12:46.240 --> 02:12:48.240]  Сейчас, сейчас.
[02:12:48.240 --> 02:12:50.240]  А как это будет связано потом с таймином?
[02:12:50.240 --> 02:12:52.240]  Как мы это сведем к тайминам потом?
[02:12:52.240 --> 02:12:54.240]  Мы же говорим, что у нас отрезки
[02:12:54.240 --> 02:12:56.240]  от тайминов, тайм-аутов не перетекаются.
[02:12:56.240 --> 02:12:58.240]  Ну и что?
[02:12:58.240 --> 02:13:00.240]  Значит у нас тайм-ыны относятся так же,
[02:13:00.240 --> 02:13:02.240]  как тайм-ауты.
[02:13:02.240 --> 02:13:04.240]  Значит нам нужно увеличивать
[02:13:04.240 --> 02:13:06.240]  нам придется увеличить тайм-аут.
[02:13:06.240 --> 02:13:08.240]  Оно увеличивается при проходе
[02:13:08.240 --> 02:13:10.240]  по обратному ребру.
[02:13:10.240 --> 02:13:12.240]  Значит у нас
[02:13:12.240 --> 02:13:14.240]  в моменты похода по нему
[02:13:14.240 --> 02:13:16.240]  после того, как мы пройдем,
[02:13:16.240 --> 02:13:18.240]  у нас тайм-аут должен быть больше,
[02:13:18.240 --> 02:13:20.240]  чем у тайм-аут В.
[02:13:20.240 --> 02:13:22.240]  Значит это предок В.
[02:13:22.240 --> 02:13:24.240]  Сейчас.
[02:13:26.240 --> 02:13:28.240]  Не.
[02:13:28.240 --> 02:13:30.240]  Это может быть тупо неправда.
[02:13:30.240 --> 02:13:32.240]  Потому что мы пришли
[02:13:32.240 --> 02:13:34.240]  В по перекрестному ребру из соседнего дерева,
[02:13:34.240 --> 02:13:36.240]  в котором мы...
[02:13:40.240 --> 02:13:42.240]  В обратной.
[02:13:42.240 --> 02:13:44.240]  Мы могли идти
[02:13:44.240 --> 02:13:46.240]  по тому ребру,
[02:13:46.240 --> 02:13:48.240]  который еще и тайм-аут,
[02:13:48.240 --> 02:13:50.240]  в дерево, которое где-то правее,
[02:13:50.240 --> 02:13:52.240]  потом в дерево правее.
[02:13:52.240 --> 02:13:54.240]  Вполне могли, да.
[02:13:54.240 --> 02:13:56.240]  Так что да, тут конечно надо...
[02:13:56.240 --> 02:13:58.240]  Так, ну да, тут надо конечно
[02:13:58.240 --> 02:14:00.240]  смотреть.
[02:14:00.240 --> 02:14:02.240]  Вот, потому что, ну вот.
[02:14:04.240 --> 02:14:06.240]  Ну вот.
[02:14:06.240 --> 02:14:08.240]  Так, поэтому да.
[02:14:08.240 --> 02:14:10.240]  Присекает вопрос, хорошо, какие еще идеи могут быть?
[02:14:10.240 --> 02:14:12.240]  Так.
[02:14:12.240 --> 02:14:14.240]  Нет, ну да, просто на уровне картинки
[02:14:14.240 --> 02:14:16.240]  доказательства может быть на самом деле такое.
[02:14:16.240 --> 02:14:18.240]  Смотрите, вот раз у нас у и В не предки друг друга,
[02:14:18.240 --> 02:14:20.240]  смотрите, то вот, допустим,
[02:14:20.240 --> 02:14:22.240]  вот у нас эта лсажка образовалась, да?
[02:14:22.240 --> 02:14:24.240]  Смотрите.
[02:14:24.240 --> 02:14:26.240]  Теперь вот возникает вопрос.
[02:14:26.240 --> 02:14:28.240]  Что как-то у нас
[02:14:28.240 --> 02:14:30.240]  этот путь будет идти
[02:14:30.240 --> 02:14:32.240]  и рано или поздно выйдет
[02:14:32.240 --> 02:14:34.240]  из вот этого под дерево, правда?
[02:14:34.240 --> 02:14:36.240]  Вот, рано или поздно выйдет.
[02:14:36.240 --> 02:14:38.240]  Ну, куда он выйдет?
[02:14:38.240 --> 02:14:40.240]  Либо он выйдет по обратному ребру
[02:14:40.240 --> 02:14:42.240]  в какого-то общего предка, и все доказано.
[02:14:42.240 --> 02:14:44.240]  Либо...
[02:14:44.240 --> 02:14:46.240]  То есть либо
[02:14:46.240 --> 02:14:48.240]  он выйдет в какое-то соседнее под дерево.
[02:14:48.240 --> 02:14:50.240]  Вот, давайте я сейчас возьму зелененький.
[02:14:50.240 --> 02:14:52.240]  Потому что, в принципе,
[02:14:52.240 --> 02:14:54.240]  смотрите, вот у нас есть этот путь,
[02:14:54.240 --> 02:14:56.240]  и у нас есть
[02:14:56.240 --> 02:14:58.240]  значит, ну вот,
[02:14:58.240 --> 02:15:00.240]  и у нас есть вот куча деревьев,
[02:15:00.240 --> 02:15:02.240]  то есть тут вот этих вот под деревьев,
[02:15:02.240 --> 02:15:04.240]  где как-то вот так вот,
[02:15:04.240 --> 02:15:06.240]  но давайте вот так.
[02:15:06.240 --> 02:15:08.240]  То есть вот так, допустим, вот так вот,
[02:15:08.240 --> 02:15:10.240]  то есть вот так вот,
[02:15:10.240 --> 02:15:12.240]  и так далее.
[02:15:14.240 --> 02:15:16.240]  Вот,
[02:15:16.240 --> 02:15:18.240]  давай нот.
[02:15:20.240 --> 02:15:22.240]  То есть, давайте тогда уже смотреть.
[02:15:22.240 --> 02:15:25.240]  пл 봤ы
[02:15:26.240 --> 02:15:28.240]  Допустим мы по перекрестному ребру
[02:15:28.240 --> 02:15:30.240]  вышли в какое-то,
[02:15:30.240 --> 02:15:33.600]  по перекрестному ребру, там вот, то есть тут шли-шли-шли-шли, и вот по перекрестному
[02:15:33.600 --> 02:15:42.680]  ребру вышли в какое-то из этих деревьев. Вот. Ну, утверждается следующее, что, ну, утверждается,
[02:15:42.680 --> 02:15:49.440]  что таймыны у всех этих вершин должны быть, очевидно, меньше, чем таймыны у этого дерева.
[02:15:49.440 --> 02:15:58.560]  Должно быть такое? Нет, оно перекресты, из этого гарантируется, что там мы тут походили, то, что,
[02:15:58.560 --> 02:16:05.480]  допустим, у этой вершины, из которой это дерево, торчит таймын больше, чем здесь. Вот. Но, то есть,
[02:16:05.480 --> 02:16:10.520]  но само по себе из этого не следует, что, скажем, таймына ту не окажется меньше, чем таймыны этой
[02:16:10.520 --> 02:16:22.160]  вершины. Ну, само по себе из этого еще ничего не следует. Нет. Перекрестный ребро, да, то есть,
[02:16:22.160 --> 02:16:26.560]  гарантируется следующее, что, если у вас есть перекрестный ребро АВ, то таймына А больше,
[02:16:26.560 --> 02:16:33.400]  чем таймына Б. Но из этого не следует, что, если у нас есть там какой-то путь от У, который идет
[02:16:33.400 --> 02:16:37.120]  там по какому-то там, по дереву, и потом проходит по перекрестным грузам, из этого не следует,
[02:16:37.120 --> 02:16:43.720]  что таймына У, там, на самом деле, обязательно больше, чем таймына эта вершина. То есть, само по себе.
[02:16:43.720 --> 02:16:51.160]  Короче, отрезок от таймына по дереву это отрезок, и такие отрезки для разных деревьев не присекаются?
[02:16:51.160 --> 02:16:56.040]  Нет. Ну, в принципе, да. Да, на самом деле, да, заметим, что, да, самый тупой доказатель,
[02:16:56.040 --> 02:17:00.240]  что, заметим, что по таймынам у нас вот это все под дерево образует отрезок, поэтому,
[02:17:00.240 --> 02:17:06.240]  если какой-то перекрестное ребро выходит за пределы этого под дерево, то оно нас точно
[02:17:06.240 --> 02:17:15.240]  ведет в вершину по таймыну меньше. Логично, да? Ну, теперь очень хочется сказать, вот, ну, теперь
[02:17:15.240 --> 02:17:20.080]  очень хочется сказать, что рассмотрим вот эту вершину, да, по предположению индукции, путь,
[02:17:20.080 --> 02:17:25.400]  остаток пути от этой вершины до этой будет проходить через общего предка вот этой
[02:17:25.400 --> 02:17:34.080]  вершины и вершины В. Ну, давайте вот у штрихов ее назовем. Ну, вот, индукция по длине пути.
[02:17:34.080 --> 02:17:48.640]  Почему тогда мы перешли, почему там будет играть король? Какой-то путь там? Сейчас, в смысле? Нет,
[02:17:48.640 --> 02:17:52.720]  не понял. Нет, логика должна быть такая же. Ну, хочется сказать так, что рассмотрим путь оттуда,
[02:17:53.360 --> 02:17:58.440]  рассмотрим путь оттуда В. Вот из этого под дерево мы рано или поздно впервые в жизни выйдем, правда?
[02:17:58.440 --> 02:18:07.200]  Вот, мы, ну, вот, то есть мы выйдем в какую-то вершину у штрихов. Вот, нам очень, ну, вот, через,
[02:18:07.200 --> 02:18:14.680]  ну, вот, то есть остался путь, кусочек пути от у штрихов В, он короче. Поэтому мы теперь говорим,
[02:18:14.680 --> 02:18:18.880]  что по предположению индукции этот путь, оставшийся, будет проходить через общего
[02:18:18.880 --> 02:18:27.240]  предка вершин у штрих и В. Другой вопрос, конечно, остается теперь выяснить. Остается только
[02:18:27.240 --> 02:18:33.480]  один вопрос. Почему этот общий предок является еще и предком У? Ну, то есть из картинки вот это
[02:18:33.480 --> 02:18:45.360]  вроде самочи, там, кажется очевидным, но это всего лишь картинка. Чего? Ну, почему-то. Ну,
[02:18:45.360 --> 02:18:53.360]  кажется, вполне себе картинка. ДФС у нас как-то вот так устроен, потому что, ну, вот. Вот, ну,
[02:18:53.360 --> 02:19:01.160]  ладно, полная картинка будет, конечно, если я вот тут еще дорисую, но это тоже не то. Так вот,
[02:19:01.160 --> 02:19:06.600]  спрашивается теперь, почему общий предок, ну, вот, почему у нас общий предок У штрих и В
[02:19:06.600 --> 02:19:21.160]  действительно окажется еще и предком У. Ну, вот, ну, идея, на самом деле, очень простая. Ну, вот, да.
[02:19:21.160 --> 02:19:42.320]  Что-что? Сейчас еще раз. Минимум на общем отрезке, не понял. Нет, ну, не совсем так. Нет, можно,
[02:19:42.320 --> 02:19:48.360]  например, сказать так. Этот общий предок У штрих и В, он является предком В, да, и он находится либо
[02:19:48.360 --> 02:19:58.280]  там выше ЛСА, включительно, либо ниже. Логично, да? Но с другой стороны, очевидно, просто, если он
[02:19:58.280 --> 02:20:03.760]  находится ниже этого, ну, вот. Ну, вот, теперь вот утверждается, что если он находится ниже ЛСА,
[02:20:03.760 --> 02:20:13.160]  то он просто на самом деле не может быть предком У штрих. Он не может быть предком У штрих по,
[02:20:13.160 --> 02:20:22.360]  ну, вот, по, на самом деле, весьма банальной причине. Нет, ну, вот, ну, почти, потому что скорее,
[02:20:22.360 --> 02:20:26.960]  ну, вот, потому что скорее всего этот У штрих на самом деле по таймыну меньше, чем вот эта ЛСА.
[02:20:26.960 --> 02:20:35.800]  Вот. А тут как бы, а вот эта вершина по таймыну, она больше, чем вот эта ЛСА. То есть единственное,
[02:20:35.800 --> 02:20:41.000]  что теперь надо тогда рассмотреть, а что делать, если это соседнее ребро висит просто на той же
[02:20:41.000 --> 02:20:53.320]  самой ЛСАшке? Да, но правда это тоже работает, потому что тогда вот эти вот, если объединить тут все
[02:20:53.320 --> 02:20:58.000]  поддеревья, которые тут висят на этой вершине до вот этого включительно, то они тоже образуют
[02:20:58.000 --> 02:21:07.200]  подотрезок и все в порядке. Если оно висит под дереве какой-то вершины на пути от ЛСА до В. Так,
[02:21:07.600 --> 02:21:17.760]  но тогда, тогда идея такая. Значит, рассмотрим все, значит, вершины, рассмотрим все поддеревья,
[02:21:17.760 --> 02:21:22.880]  которые висят на этой ЛСАшке, но которые были обойдены ДФСом до вот нашего поддерева с
[02:21:22.880 --> 02:21:31.720]  вершиной У включительно. Тогда рано или поздно мы из этого множества вершин выйдем. Но некоторое
[02:21:31.720 --> 02:21:36.040]  время мы тут будем ходить, но рано или поздно мы из них выйдем. Но если мы выйдем по обратному
[02:21:36.040 --> 02:21:41.920]  ребру, то, значит, мы пойдем в ЛСА или его предка и автоматически победа. Если мы выйдем по
[02:21:41.920 --> 02:21:49.800]  перекрестному ребру, то мы выйдем по ребру у штрих, и у штрих будет по таймыну меньше, чем даже ЛСА.
[02:21:49.800 --> 02:22:01.040]  Вот, поэтому так. То есть вот такое доказательство может, например, иметь место. Или может быть,
[02:22:01.040 --> 02:22:04.640]  на самом деле, доказательство про тайм-ауты и, кстати, про обратные ребра на самом деле вполне
[02:22:04.640 --> 02:22:11.760]  себе может и доводиться. Потому что вот другое доказательство могло быть, что действительно кто
[02:22:11.760 --> 02:22:21.800]  у нас увеличивает. Значит, у нас тайм-эн увеличивает только прямые ребра и ребра дерева ДФС. Поэтому
[02:22:21.800 --> 02:22:26.960]  возможно можно было бы рассмотреть последние ребра на пути, которые там увеличивает тайм-эн,
[02:22:26.960 --> 02:22:32.440]  и мы там про него тоже еще не докажем. Ну, например, ну, во-первых, там,
[02:22:32.440 --> 02:22:42.280]  ну да, там, скажем, рассмотрим там последнее прямое ребро или ребро ДФС на пути. А вот, кстати,
[02:22:42.280 --> 02:22:46.800]  давайте, интересно, пять минут подумаем. Вот другое, смотрите, другое доказательство, которое
[02:22:46.800 --> 02:22:59.000]  предлагалось. Рассмотрим последнее прямое ребро на этом пути, в какой-нибудь. Так, ну, пусть оно прямое.
[02:22:59.000 --> 02:23:04.560]  Нет, в смысле, нет, смотрите, хотя бы одно прямое ребро или ребро дерева ДФС на этом пути точно есть,
[02:23:04.560 --> 02:23:10.880]  потому что обратные ребра и перекрестные, они уменьшают тайм-эн. Так, вот рассмотрим. Тогда
[02:23:10.880 --> 02:23:19.280]  после него мы как-то попали в вершину В чисто по прямым и обратным ребрам. То есть по обратным
[02:23:19.280 --> 02:23:27.440]  и перекрестным ребрам. То есть мы там чисто действительно что-то уменьшали. Вот, соответственно.
[02:23:27.440 --> 02:23:31.520]  Так, спрашивает, а что? Ну вот, так, теперь вот возникает вопрос, что нам это дает?
[02:23:31.520 --> 02:23:53.320]  Перекресток прям ломает, да? Но это да. Ну да. Ну да. Ну правда, нет, там, видимо,
[02:23:53.320 --> 02:23:58.800]  доказывать, пришлось бы доказывать по принципу, что путь оттуда, так как вот у этой вершины тайм-эн
[02:23:58.800 --> 02:24:03.680]  заведомо больше, чем у В, значит, и у У тоже, значит, получается, что мы через общего предка
[02:24:03.680 --> 02:24:08.720]  у этой вершины прошли. Стоит только доказать, что это общий предок является и предком вершины В.
[02:24:08.720 --> 02:24:14.040]  То есть тут, видимо, как-то так это будет работать, но это, видимо, что-то похожее вот на это получится.
[02:24:14.040 --> 02:24:23.760]  Окей, ладно, с лем мы разобрались. Значит, тогда давайте переходить ближе к, собственно, так,
[02:24:24.520 --> 02:24:29.880]  давайте попробуем ближе переходить к, собственно, какой-нибудь доминации. Но правда, для этого нам
[02:24:29.880 --> 02:24:36.080]  сразу понадобится, конечно, немножко, то есть, видимо, придется ввести всякие эздомы. Ладно,
[02:24:36.080 --> 02:24:46.400]  значит, лемочку мы убираем. Такие так, ну, доказательства лемочки убираем. Вот. Но,
[02:24:46.400 --> 02:24:50.760]  по-принципе, кстати, само по себе на самом деле очень интересное замечание, на самом деле.
[02:24:50.760 --> 02:25:06.520]  Так, значит, далее. Давайте смотреть, смотреть, смотреть, что у нас тут будет. Вот. Так. Ну,
[02:25:06.520 --> 02:25:11.880]  а первое, да, придется ввести тут действительно еще какое-нибудь веселое понятие. Такое весьма
[02:25:11.880 --> 02:25:24.120]  экзотическое. Так, смотрите, то есть, определение. Значит, пусть у нас, как всегда, значит, w не
[02:25:24.120 --> 02:25:39.640]  равно r. Тогда, значит, давайте, значит, полудоминатор w, полудоминатор w, или я сразу введу обозначение
[02:25:39.640 --> 02:25:51.320]  esdom, то есть, честно говоря, в своей речи даже редко использую понятие полудоминатор. Вот. А, даже
[02:25:51.320 --> 02:26:02.920]  не self-domination, а semi-domination. Вот. Значит, берем, значит, вводим такой вот этот esdom от w. Это,
[02:26:03.000 --> 02:26:12.880]  значит, что это такое? Значит, это, ну, скажем так, знаете, вот в статье Тарьяна немножко по-другому
[02:26:12.880 --> 02:26:23.760]  написано, но я напишу так. Значит, argmin, значит, таймын от w. Значит, минимальная по таймыну такая
[02:26:23.760 --> 02:26:43.680]  вершина v, что, внимание, существует путь, значит, такой, значит, v, значит, v0, v1, v2 и так далее, vk, w.
[02:26:43.680 --> 02:26:59.240]  Ну, и там в конце будет vk равно w. Такой, что, ну вот, для любого i, для любого i,
[02:26:59.240 --> 02:27:12.400]  лежащего на отрезке от 1 до k-1, оказывается, что таймын от w строго больше, чем таймын
[02:27:12.400 --> 02:27:29.000]  от w. Вот. Вот такую неожиданную штуку мы введем. То есть еще, что это означает? То есть это
[02:27:29.000 --> 02:27:35.640]  означает, то есть это означает, что мы можем дойти из вершины v до вершины w, но в качестве
[02:27:35.640 --> 02:27:43.240]  промежуточных вершин используем только, соответственно, вершины по таймыну больше. Да,
[02:27:43.240 --> 02:27:47.640]  вот мы будем писать так, хотя сразу предупреждаю, если будете читать статью Тарьяна, сразу обратите
[02:27:47.640 --> 02:27:54.120]  внимание, что он первое, что делает, перенумеровывает вершины. Он говорит, что давайте запустим DFS и
[02:27:54.120 --> 02:27:59.760]  перенумеруем вершины в порядке входа DFS в них. То есть подобные леммы там начинают формулироваться
[02:27:59.760 --> 02:28:09.760]  сильно проще. Вот. Но мы тем не менее, почему-то будем делать так. Да, почему? Потому что мне так
[02:28:09.760 --> 02:28:15.520]  почему-то больше нравится. Ну, потому что мне как-то ощущение, что вершина w это все-таки какая-то
[02:28:15.520 --> 02:28:23.520]  такая сущность типа камешка, а таймын это какая-то чиселка. Вот. Так, ну давайте смотреть.
[02:28:29.760 --> 02:28:36.360]  Так, ну давайте думать. Значит, соответственно, теперь придется, значит, подоказываем пару
[02:28:36.360 --> 02:28:52.200]  леммочек. Так, что можно про этого издамо сказать? Да, он не просто существует, а просто я даже еще
[02:28:52.200 --> 02:29:00.080]  и сразу, даже пропущу это нулевое утверждение, просто сразу перейду ко второму. Нет, он, конечно,
[02:29:00.080 --> 02:29:07.160]  единственный, потому что мы из всех подходящих вершин выбираем минимум по таймыну. Да, то есть не
[02:29:07.160 --> 02:29:17.120]  просто какая-нибудь вершина, но вот. Так-то, ну вот, значит, s дам от w, она заведомо меньше, чем таймын от w.
[02:29:17.120 --> 02:29:29.360]  Вот начнем с такого простого утверждения. То есть, обратите внимание, видите, я вот в этом
[02:29:29.360 --> 02:29:36.000]  вот условии про саму вершину w ничего не говорил. То есть, сама вершина w может быть меньше таймына.
[02:29:36.000 --> 02:29:46.200]  И это действительно помогает. Так, ну, кстати, почему это лемма, верно? Ну да, просто потому,
[02:29:46.200 --> 02:29:53.640]  что в качестве кандидата в полудоминаторе вполне пойдет родитель в дереве dfs. Потому что,
[02:29:53.640 --> 02:30:01.160]  по идее, этот путь может состоять из одного ребра вполне. Понимаете, да? Более того, то есть,
[02:30:01.160 --> 02:30:06.160]  на самом деле, если мы это ищем, то первое, что мы должны сделать, это просмотреть все прямые
[02:30:06.160 --> 02:30:13.080]  ребра, ведущие в w. И это прямое ребро, то есть, какие-то прямое ребро, которые видят из более
[02:30:13.080 --> 02:30:21.840]  высокой вершины, это вот тоже один из кандидатов в полудоминаторе. Вот. То есть, это мы начинаем с этого.
[02:30:21.840 --> 02:30:33.600]  Так, что у нас еще? Вот. Так. Ну, можно, на самом деле, развить эту идею и сказать сразу, что
[02:30:33.600 --> 02:30:48.400]  w это собственный предок w. Что такое собственный? Да, не совпадающий с самим w совершенно верно.
[02:30:48.400 --> 02:31:01.120]  Вот. Да, казалось бы, почему? Да, потому что ровно для этого мы тут доказывали эту мистическую лему.
[02:31:01.120 --> 02:31:09.520]  Потому что рассмотрим этого эздома. Из этого эздома есть путь в w, и этот эздом по таймыну меньше.
[02:31:09.520 --> 02:31:20.720]  Следовательно, на этом пути встретится общий предок эздома w и w. Но предок, но так как общий
[02:31:20.720 --> 02:31:26.920]  предок это в том числе и предок w, то по таймыну он должен быть, очевидно, меньше, чем w, правда?
[02:31:26.920 --> 02:31:32.360]  В чем строго меньше, потому что, соответственно, сам эздом меньше, значит, его предок тоже меньше.
[02:31:32.360 --> 02:31:39.640]  Но у нас на этом пути есть только одна вершина, которая по таймыну меньше, чем w. Это, собственно,
[02:31:39.640 --> 02:31:55.800]  эздом от w. Вывод, это и есть предок. Вот. Так же такая вот приятная вещь. Понимаете, да? Вот.
[02:31:55.800 --> 02:32:09.480]  Вот. Но, на самом деле, да. Зачем нам эти эздомы вообще нужны? А, ну давайте еще. Так,
[02:32:09.480 --> 02:32:13.520]  ну давайте вообще подумаем. Так, прежде чем я буду формулировать лему, давайте подумаем. А как
[02:32:13.520 --> 02:32:19.480]  эти эздомы вообще связаны с айдомами, как вы думаете? Все, смотрите, ведь как они связаны?
[02:32:19.480 --> 02:32:27.200]  Заметим, что эздом – это предок w, собственный предок w. Но очевидно, что айдом – это тоже
[02:32:27.200 --> 02:32:33.040]  собственный предок w, правда? Но очевидно, наверное, что на пути в дереве DFS, очевидно,
[02:32:33.040 --> 02:32:42.680]  лежат все доминаторы, в том числе айдом. Так. А теперь внимание, вопрос. Как вы думаете, кто
[02:32:42.680 --> 02:32:59.080]  выше? Айдом? Или эздом? Да. То есть пишем айдом, айдом от w. Давайте так писать, ладно. Значит,
[02:32:59.080 --> 02:33:05.960]  предок на этот раз не обязательно, кстати, собственный. Я это даже подпишу. Не обязательно
[02:33:05.960 --> 02:33:20.080]  собственный. Собственный. То есть это не обязательно собственный предок эздома. Вот. То есть не может
[02:33:20.080 --> 02:33:29.800]  быть так, что эздом выше айдома. Почему? Ну да, потому что на самом деле да. Потому что пусть это
[02:33:29.800 --> 02:33:40.880]  не так. И там эздом, допустим, оказался выше. Тогда у нас существует путь вот какого-то такого
[02:33:40.880 --> 02:33:46.440]  вот рода. Вот видите, я его именно через право рисую, потому что он идет через все вершины
[02:33:46.440 --> 02:33:53.560]  большие w. Вот. Ну, точнее так, вот это w. Ладно, он приходит вот либо сюда, либо вот куда-то
[02:33:53.560 --> 02:34:01.720]  в под дерево w и тут еще как-то шатается. Вот так скажем. Вот. Но факт остается фактом, что этот
[02:34:01.720 --> 02:34:06.120]  путь, по идее, если айдом лежит ниже эздома, значит этот путь позволяет обойти айдом,
[02:34:06.120 --> 02:34:13.800]  противоречие с определением айдома. Вот. То есть получается, да, такого не бывает. И айдом это
[02:34:13.800 --> 02:34:24.920]  обязательно предок. То есть более того, то есть более того, так ух ты, какие у меня тут леммы веселые,
[02:34:24.920 --> 02:34:32.400]  да. То есть более того, на самом деле, можно даже поставить более веселую штуку. То есть смотрите,
[02:34:32.400 --> 02:34:39.760]  то есть да, по идее эздом это действительно у нас позволяет делать такие обходы. То есть более того,
[02:34:39.760 --> 02:34:46.760]  на самом деле, в некотором смысле, если какая-то вершина не является доминатором, то есть подозрение,
[02:34:46.760 --> 02:34:57.760]  что ее всегда можно обойти вот каким-то вот таким вот образом. Логично, да? Ну, потому что,
[02:34:57.760 --> 02:35:04.480]  смотрите, давайте я посмотрю, вот прежде чем формулировать. Ну, потому что да, ладно. Хочется
[02:35:04.480 --> 02:35:17.320]  сформулировать на самом деле вот такое. Вот лемма 5. Хочется сформулировать так. Если заменить
[02:35:17.320 --> 02:35:46.840]  в графе все ребра не из дерева, не из дерева DFS. То есть, ну вот, на, на что? На
[02:35:46.840 --> 02:36:00.480]  ребра вида. Ну, на ребра вот эти вот эздом от W и W. Ну, мы, ну, скажем так, то, что у нас был граф,
[02:36:00.480 --> 02:36:11.560]  наш граф, да. Мы запустили DFS из R. Он образовал дерево DFS. Логично, да? Нет, нет, нет, не ребра
[02:36:11.560 --> 02:36:19.840]  дерева DFS. Напоминаю, у нас в классификации прямые ребра и ребра дерева DFS, это разные вещи. Да,
[02:36:19.840 --> 02:36:23.720]  то есть, напоминаю, у нас есть ребра дерева DFS, то есть, ребра, по которым DFS непосредственно
[02:36:23.720 --> 02:36:30.680]  прошел. Есть все остальные ребра. Они бывают прямые, обратные и перекрестные. То есть,
[02:36:30.680 --> 02:36:35.440]  прямые те, которые соединяют предка с потомком, значит, обратные, которые потомка с предком,
[02:36:35.440 --> 02:36:47.280]  перекрестные все остальные. Да, напоминаю. Вот. То есть, если, то есть, заменить вот на все такие
[02:36:47.280 --> 02:36:58.280]  ребра, такие, что W лежит, просто пробегается по всем вершинам, кроме корня, то дерево доминаторов
[02:36:58.280 --> 02:37:04.760]  не изменится. Я так напишу. Ну или просто можно было, да, может быть, более прямее сказать,
[02:37:04.760 --> 02:37:20.200]  отношения доминации не поменяются. Не изменится. То есть, это, в общем-то, обыставание того, а зачем мы
[02:37:20.200 --> 02:37:33.880]  эту полудоминацию вообще ввели. Вот. Ну, давайте думать. Ну, давайте вот, соответственно, думать.
[02:37:33.880 --> 02:37:44.080]  То есть, давайте вот такие вот ребра забабахаем. То есть, ну, во-первых, давайте хотя бы в одну
[02:37:44.160 --> 02:37:51.200]  сторону поймем. Давайте поймем, что почему, если вершина В, то есть, допустим, у нас есть какая-нибудь
[02:37:51.200 --> 02:37:59.440]  вершина В. То есть, допустим, у нас есть, то есть, рассмотрим какой-нибудь путь. Ну, во-первых, вот у
[02:37:59.440 --> 02:38:06.000]  нас дерево ДФС-то у нас остается, да. То есть, дерево ДФС остается, как мы уже убедились, что, в общем-то,
[02:38:06.000 --> 02:38:10.440]  в новом графе можно запустить ДФС так, чтобы дерево ДФС было абсолютно таким же, правда?
[02:38:10.440 --> 02:38:17.720]  Потому что относительно его есть только вот эти прямые ребра. Так вот, рассмотрим какую-нибудь вершину В
[02:38:17.720 --> 02:38:28.320]  на вот этом дереве ДФС. То есть, хочется показать, то есть, действительно, хочется показать, что вершина В
[02:38:28.320 --> 02:38:35.000]  не будет доминировать W, тогда, на W, тогда и только там в исходном графе, тогда и только тогда,
[02:38:35.000 --> 02:38:43.920]  когда и в новом графе она не будет над ним доминировать. Почему? А вот почему, кстати?
[02:38:43.920 --> 02:38:53.360]  Так, ну да, заметим следующее. Во-первых, заметим следующее, что, то есть, давайте себе представим,
[02:38:53.360 --> 02:38:59.480]  что мы сначе, давайте вот в одну сторону, да. Так, хорошо, докажем, что если была доминация в
[02:38:59.480 --> 02:39:06.280]  исходном графе, то будет и в новом графе. Как мы это докажем? А очень просто. Давайте сначала
[02:39:06.280 --> 02:39:12.680]  добавим вот эти ребра, а потом поудаляем старые. Потому что фишка следующая. Заметим, что когда
[02:39:12.680 --> 02:39:20.360]  мы удаляем ребро, то старые доминации никуда не деваются, правда? Но от того, что мы удалили
[02:39:20.360 --> 02:39:25.360]  ребро, удалили ребро не из дерева ДФС, то старые доминации никуда не деваются. То есть, может,
[02:39:25.360 --> 02:39:31.680]  появляется новое. Это с одной стороны. Но с другой стороны, заметим, что я утверждаю,
[02:39:31.680 --> 02:39:40.040]  что если мы в дереве, то есть, с другой стороны, заметим, что добавляем мы теперь в граф только
[02:39:40.040 --> 02:39:48.440]  прямые ребра. Только прямые ребра. Но с другой стороны, заметим, что пусть у меня В доминирует
[02:39:48.440 --> 02:39:57.440]  над W. То есть, пусть у меня В неожиданно доминирует над W, и мы неожиданно решили добавить какое-то
[02:39:57.440 --> 02:40:05.640]  прямое ребро, благодаря которому оно неожиданно, то есть, оно доминировать перестает. Ну что это?
[02:40:05.640 --> 02:40:14.920]  Ну вот. Ну с другой стороны, да. Хочется сказать, что это прямое ребро ведет из предко-вершины В
[02:40:14.920 --> 02:40:27.100]  в потомко-вершины В. Ну вот. Сейчас, чего такого не бывает. Да, но нет, конкретно обхода, обхода
[02:40:27.100 --> 02:40:32.480]  вершины В, конечно, но это ребро не может вести действительно из предко-вершины В в потомко-вершины В.
[02:40:32.480 --> 02:40:40.240]  Действительно, нет. Ну нет, ЛЕМА-4 еще напрямую ничего не говорит, потому что это вершина
[02:40:41.240 --> 02:40:51.000]  В. Поэтому более аккуратное рассуждение звучит так, что раз такое ребро существует, да, кстати,
[02:40:51.000 --> 02:40:55.200]  этот потомок может быть как выше вершины В, так в принципе и ниже, но я пока нарисую выше,
[02:40:55.200 --> 02:41:03.320]  там суть одинаковая. Значит, то есть, идея такая, то есть, если нашлось такое ребро, по которому мы
[02:41:03.320 --> 02:41:09.600]  еще и В, то значит, что в исходном графе можно было пройти из этой вершины вот в эту вершину,
[02:41:10.120 --> 02:41:17.520]  потому что что это такое, если это вершина КА, то это вершина в исходном графе С, да, мата. И это в
[02:41:17.520 --> 02:41:25.640]  принципе означает, что у нас можно было из этой вершины В как-то попасть, причем по вершинам,
[02:41:25.640 --> 02:41:31.840]  которые по таймы ну больше, чем А, а следовательно и больше вершины В. Но если потом из вершины А можно
[02:41:31.840 --> 02:41:37.640]  попасть в В, ну либо потому что она предок, либо потому что она тут еще где-то там в поддереве,
[02:41:38.120 --> 02:41:43.720]  или где-то там она вот под дереве W, вот такое тоже могло быть там вот. Вот, допустим, вершина А тоже
[02:41:43.720 --> 02:41:53.720]  могло быть вот так еще. Вот, но суть одна. Но тогда из этого следует, что эта вот вершина В не доминировала
[02:41:53.720 --> 02:42:07.160]  на W, потому что мы ее обошли. Понятно, да? Ну вот, то есть, противоречие. То есть,
[02:42:07.160 --> 02:42:14.960]  если вершина В. То есть, таким образом у нас получается, ну вот, то есть у нас получается,
[02:42:14.960 --> 02:42:21.560]  что это может быть, то есть, если у нас добавилось ребро, благодаря которому у нас вершина В перестала
[02:42:21.560 --> 02:42:27.920]  доминировать на W, то это не ребро, которое ведет из родителя, из какого-то предка вершины В,
[02:42:27.920 --> 02:42:29.520]  в какого-то потопка вершины В.
[02:42:29.520 --> 02:42:33.680]  На самом деле, мы можем сказать, что у нас все доминаторы лежат на пути до корня,
[02:42:33.680 --> 02:42:42.120]  а на пути именно по ребрам ДФС. Ну, тогда любой полудоминатор означает, что у нас существует путь
[02:42:42.120 --> 02:42:52.480]  по ребрам, ну не только ребрам ДФС, который из А в В буквально. Если мы добавим такое же ребро,
[02:42:52.480 --> 02:43:04.480]  а можно было проще сказать, что рассмотрим вот это ребро. Ну, по-разному можно. Ладно,
[02:43:04.480 --> 02:43:11.080]  я повторяю просто предыдущие. Можно было сказать так, что заметим, что раз вершина В доминировала
[02:43:11.080 --> 02:43:24.400]  W, то есть рассмотрим какое-то ребро. Давайте подумаем, рассмотрим всех доминаторов W,
[02:43:24.400 --> 02:43:32.960]  давайте, вот они, все доминаторы. Теперь выскакивает вопрос, где это ребро, то есть рассмотрим какое-нибудь
[02:43:32.960 --> 02:43:42.800]  новое ребро, такое вот ребро, которое мы добавляем из А в С дома от А. Внимание, вопрос. Где оно может
[02:43:42.800 --> 02:43:49.760]  лежать? Где оно может лежать? Заверяй нот. Хотя нет, не очевидно. Пока, по-моему, легче не стало.
[02:43:49.760 --> 02:43:59.280]  Да, поэтому приходится доказывать, что утверждается, что эти вот А и С дома от А, то есть это ребро не
[02:43:59.280 --> 02:44:07.040]  может как бы вести из родителей какого-то доминатора В в А, не обязательно там непосредственно,
[02:44:07.040 --> 02:44:14.060]  потому что мы только что это обсудили. То есть спрашиваешь, что это тогда может быть? Тогда
[02:44:14.060 --> 02:44:23.800]  это может быть. Давайте это хоть доказать доведем, потому что, по-моему, те, кто сейчас не мыслит вперед,
[02:44:23.800 --> 02:44:33.120]  они, по-моему, уже там должны были уже умереть. Вот, согласаются. Если такого обгона нет,
[02:44:33.120 --> 02:44:43.280]  значит это либо ребро какое-то выше, очевидно, тогда на доминацию В оно никак не влияет. И тогда
[02:44:43.280 --> 02:44:50.000]  либо нот. То есть либо тут вообще что еще может быть? Может быть оно ведет из предка вершины В
[02:44:50.000 --> 02:44:58.880]  в какое-то тут под дерево отдельное, куда-нибудь вот сюда или там куда-нибудь вот сюда. Вот. И что-то
[02:44:58.880 --> 02:45:05.120]  еще. Ну вот. Ну либо она вообще там, действительно, либо там полностью в потомках вершины В и так далее,
[02:45:05.120 --> 02:45:15.720]  но во всех этих случаях это ребро не дает нового пути, который не проходит через вершину В. Почему?
[02:45:15.720 --> 02:45:22.160]  Потому что во всех остальных случаях, если мы можем это ребро в пути заменить на, собственно,
[02:45:22.160 --> 02:45:28.320]  путь по дереву ДФС, который не содержит В. То есть единственная проблема может быть, что из-за чего,
[02:45:28.320 --> 02:45:38.200]  когда мы добавили новое ребро, В перестало доминировать В. Потому что мы прошли нот. То есть
[02:45:38.200 --> 02:45:43.840]  мы прошли по этому ребру, обошли В. То есть путь от этой вершины до этой по дереву ДФС В должен
[02:45:43.840 --> 02:45:51.480]  был содержать. Ну а так как это прямое ребро, то, соответственно, вот. Так что вот у меня было
[02:45:51.480 --> 02:45:57.400]  такая дот. То есть у меня появилось вот такое доказательство. То есть получается, так, ну что
[02:45:57.400 --> 02:46:02.880]  это мы, так значит еще, что мы доказали? То есть мы доказали, что, то есть мы доказали, что,
[02:46:02.880 --> 02:46:09.240]  соответственно, если В доминировало В в старом дереве, то и в новом доминировать будет. Теперь
[02:46:09.240 --> 02:46:16.200]  стоит только доказать, что если В не доминирует В в старом дереве, то и в новом дереве оно
[02:46:16.200 --> 02:46:26.360]  доминировать не будет. Почему так? Значит еще раз, видите, то есть наоборот. То есть пусть теперь В в старом
[02:46:26.360 --> 02:46:37.720]  дереве не доминировала. Вот оно, да. Что это в принципе означает? Вот, давайте. То есть это значит,
[02:46:37.720 --> 02:46:47.680]  что да, существует. Да, то есть вот, соответственно, да. То есть вот у нас W. Значит, смотрите. Тогда
[02:46:47.680 --> 02:46:56.880]  смотрите. Ладно, вершины В у нас на этом пути нет. Но какие-то предки вершины В на этом пути
[02:46:56.880 --> 02:47:07.640]  обязательно существуют. Правда? Давайте рассмотрим. Значит, смотрите. Рассмотрим самый последний из них,
[02:47:07.640 --> 02:47:13.280]  который у вас, у нас на пути встретился. То есть рассмотрим последнего предка на пути, который,
[02:47:13.280 --> 02:47:21.120]  последнего предка В на этом пути, который у нас вообще встретился. Вот, допустим, он. Как путь пойдет
[02:47:21.120 --> 02:47:42.040]  дальше? Вот. Что-что? Погоди, погоди, спокойно. Значит, смотрите. Тут идти такая. Просто как этот
[02:47:42.040 --> 02:47:48.640]  путь пойдет? То есть этот путь как-то пойдет дальше. Но мне как-то вот, но мне как-то очень хочется
[02:47:48.640 --> 02:47:55.760]  сказать, что этот путь... Ну, во-первых, заметим, что этот путь можно, там, по началу пути можно
[02:47:55.760 --> 02:48:07.640]  просто заменить на вот это вот. Вот. Ну вот. А во-вторых, теперь идея такая. Давайте рассмотрим какую-нибудь
[02:48:07.640 --> 02:48:15.520]  следующую вершину. То есть, раз это последний предок, давайте рассмотрим какую-нибудь следующую
[02:48:15.520 --> 02:48:25.760]  вершину, соответственно, следующую вершину на пути. Нет, давайте рассмотрим следующую вершину на
[02:48:25.760 --> 02:48:36.440]  этом пути, которая по таймыну не больше W. Поняли, да? Это, ну, это может быть сама вершина W. Вот. А
[02:48:36.440 --> 02:48:45.480]  может быть кто-то еще. Ну вот. То есть, рассмотрим какую-нибудь следующую. Кем могла быть это
[02:48:45.480 --> 02:48:59.360]  следующая? Ну, во-первых, я утверждаю, что эта следующая вершина должна быть предком W. Почему?
[02:48:59.360 --> 02:49:08.720]  Ну, потому что, хочется сказать следующее, что если она, ну вот, что если она не является предком W,
[02:49:08.720 --> 02:49:15.920]  то в дальнейшем пути какой-то общий предок у этой вершины W найдется. Правда? Пока это
[02:49:15.920 --> 02:49:24.440]  ничему не противоречит. Ну вот. Ну, хотя, но вот, то есть, да, но вот, пока есть, но вот. То есть,
[02:49:24.440 --> 02:49:30.200]  если зашла какая-то меньше, то найдется, то дальше какой-то общий предок с W обязательно
[02:49:30.200 --> 02:49:37.920]  найдется. То есть, тут вот как-то вот так вот пошло. Оп. И там вот, вот как-то так. Вот. Ну,
[02:49:37.920 --> 02:49:43.800]  теперь давайте смотреть, что на этих путях было. То есть, если, в принципе, ну вот, то есть, если у
[02:49:43.800 --> 02:49:50.480]  нас, да, давайте смотреть, да, то есть, если у нас, так, наоборот, вот так и тут, соответственно,
[02:49:50.480 --> 02:49:59.360]  вот так. Так, что у нас тогда здесь появится? Какой из этого вывод можно вывести? Ну, во-первых,
[02:49:59.360 --> 02:50:05.600]  где находится этот общий предок? Ну, во-первых, этот общий предок не может быть предком вершины
[02:50:05.600 --> 02:50:13.160]  W, согласны? Вот. Ну, потому что, да, иначе противоречие с определением вот этого вот,
[02:50:13.160 --> 02:50:21.880]  там, действительно, последнего предка, которого мы встретили. Вот. То есть, значит, получается,
[02:50:21.880 --> 02:50:30.120]  что мы нашли путь, который ведет из предка вершины W в потомка вершины W, который как-то эту саму
[02:50:30.120 --> 02:50:38.720]  вершину W обходит. Видно, да? Но теперь вытекает вопрос. Только, есть ли на этом путь нот? Ну,
[02:50:38.720 --> 02:50:44.720]  заметим, что если бы на этом пути все вершины были больше по таймыну, чем вот хотя бы вот эта
[02:50:44.720 --> 02:50:51.640]  вершина, да, то тогда эта вершина была бы кандидатом W, правда? И получается, что в будущем дереве мы
[02:50:51.640 --> 02:50:59.360]  ее обойдем. А теперь вытекает вопрос, а что, да вот, а что у нас тогда, действительно, делать,
[02:50:59.360 --> 02:51:09.520]  если у нас на этом пути меньше вершина нашлась? Ну, могло ж так теоретически такое случиться.
[02:51:09.520 --> 02:51:20.360]  Что-что? Так. Ну, можем, и что нам это даст?
[02:51:29.360 --> 02:51:34.360]  Ну да, там на самом деле это следующее. В принципе, это означает, что раз у нас есть вот эта вершина
[02:51:34.360 --> 02:51:40.240]  эта, то на пути между ними, очевидно, есть еще какой-то общий предок этой вершины, этой вершины, правда?
[02:51:40.240 --> 02:51:50.600]  Вот. Поэтому можно сказать так, давайте на этом пути, когда вот дальше идем-идем-идем-идем, и рассмотрим
[02:51:50.600 --> 02:51:56.080]  следующую, просто первую-первую же вершину, то есть рассмотрим первую вершину, которая является
[02:51:56.080 --> 02:52:02.400]  предком W. Как вы уже сказали, эта вершина, она не является, то есть она не является выше, она
[02:52:02.400 --> 02:52:09.320]  является ниже W. Но с другой стороны, если на этом пути была вершина по таймыну меньше, чем вот эта
[02:52:09.320 --> 02:52:14.640]  вершина, то тогда между ними был бы еще какой-то предок, причем не совпадающий с этой вершиной.
[02:52:14.640 --> 02:52:24.280]  Логично, да? Но потому что все потомки этой вершины по таймыну больше. Получается противоречие.
[02:52:24.280 --> 02:52:35.120]  То есть еще раз. То есть давайте, если собрать эти мысли воедино, получается следующее. Вот у нас есть
[02:52:35.120 --> 02:52:42.920]  какой-то путь, который идет из R в W и обходит W. Давайте мы этот путь сейчас будем упрощать.
[02:52:42.920 --> 02:52:51.040]  То есть смотрите, упрощение номер раз. Рассмотрим последнего предка вершины W, который встретился на
[02:52:51.040 --> 02:52:58.960]  этом пути. И часть, и первую часть пути заменим вот на вот эту цепочку по дереву DFS. Но это не важно,
[02:52:58.960 --> 02:53:10.160]  на самом деле. Теперь дальше. После этого пойдем по пути и дойдем до первого на этом пути предка W.
[02:53:10.160 --> 02:53:19.600]  Нет, ну сама W тоже является своим предком. Я не сказал, что собственной. Вот. Утверждение.
[02:53:19.760 --> 02:53:28.080]  Назовем эту вершину там, допустим, U. Так вот, я утверждаю, что вот все эти вершины вот на этом пути имеют таймын.
[02:53:28.080 --> 02:53:40.400]  То есть если вот назвать их там UIT, то я утверждаю, что таймын от UIT больше, чем таймын от U. Вот это я утверждаю.
[02:53:40.400 --> 02:53:46.200]  Почему я это утверждаю? Потому что если какая-то нашлась промежуточная вершина по таймыну меньше,
[02:53:46.200 --> 02:53:57.360]  то тогда на пути от нее до U есть общий предок, как мы уже выяснили. Вот. Значит, получается,
[02:53:57.360 --> 02:54:04.440]  он является и предком W. Значит, либо эта вершина является потомком U, что невозможно,
[02:54:04.440 --> 02:54:13.520]  либо мы где-то раньше должны были этого предка встретить. Вот. То есть получается, тогда отсюда
[02:54:13.520 --> 02:54:20.160]  следует, что путь, во-первых, устроен как-то вот так. Понимаете, да? Да, кстати, вполне вероятно,
[02:54:20.160 --> 02:54:24.960]  что этот путь проходит и через под дерево U, на самом деле. Да, и сам этот путь мог проходить,
[02:54:24.960 --> 02:54:32.080]  войти в под дерево W, а потом как-то через обратные ребра высвисеть в W. Но это и неважно. Важно для нас
[02:54:32.080 --> 02:54:37.000]  другое. Потому что вот эта картинка уже нам напоминает определение полудоминаторов, правда?
[02:54:37.000 --> 02:54:44.400]  То есть я бы сказал даже так, что вот эта вершина, это еще не S-dom, но это кандидат.
[02:54:44.400 --> 02:54:58.920]  То есть это кандидат в S-dom от U. То есть это означает, что в новом графе у нас в ребро,
[02:54:58.920 --> 02:55:04.280]  то есть S-dom будет лежать либо здесь, либо выше, у нас тут появится вот такое красивое прямое
[02:55:04.280 --> 02:55:16.520]  ребро, которое обойдет W. И W не будет доминировать на W. Что? Ну, значит, еще раз, смотрите,
[02:55:16.520 --> 02:55:24.920]  был у нас исходный путь от R до W. Мы рассмотрели на нем последнего предка вершины W. Начиная с
[02:55:24.920 --> 02:55:35.560]  этого последнего предка, мы рассматриваем путь. И рассматриваем не весь путь, а только путь до
[02:55:35.560 --> 02:55:41.000]  предка W. То есть после этой вершины мы ищем первую вершину, которая является предком W,
[02:55:41.000 --> 02:55:48.160]  назовем ее U. Сначала предок W, а потом предок W. Потом мы быстро убеждаемся, что U, во-первых,
[02:55:48.160 --> 02:55:55.760]  не является предком W. А потом мы также быстро убеждаемся, что все промежуточные вершины на
[02:55:55.760 --> 02:56:01.800]  этом пути тайпотаймыну больше, чем U. Почему? Потому что у нас там лемма есть, из которой бы следовало,
[02:56:01.800 --> 02:56:09.640]  что там еще какой-то предок был. Тогда из этого следует, что мы получили какую-то вершину U
[02:56:09.640 --> 02:56:18.000]  между W. Такую, что S-dom от U лежит выше, чем W. Почему выше? Потому что он, как минимум,
[02:56:18.000 --> 02:56:34.240]  здесь вот кандидат. Что? Нет, у нас уже есть лемма, что S-dom это предок. Вот. Мы уже в это поверили.
[02:56:34.240 --> 02:56:45.480]  Нет, ну давайте можем даже вспомнить, почему это обязательно именно предок. Ну да, потому что на
[02:56:45.480 --> 02:56:52.960]  пути найдется общий предок, а он по тайпотаймыну будет меньше. Так что получается, что вот уже такой
[02:56:52.960 --> 02:57:00.520]  кандидат. И получается, на самом деле, то есть видите, какая идея получается. Если мы нашли S-dom,
[02:57:00.520 --> 02:57:09.400]  то если мы S-dom и нашли, то в принципе, то получается, что мы можем только оставить,
[02:57:09.400 --> 02:57:15.080]  получается, 2n, то есть оставить только ребра из S-dom, то есть у нас там 2n-2 ребра останется. И
[02:57:15.080 --> 02:57:32.680]  уже на этом графе вполне себе искать айдомы. Что-что? Да, граф теперь железобетонно-оциклический.
[02:57:32.680 --> 02:57:42.120]  Это правда. Да, получается, да. Что у нас получается? 1 квадрат на 32, да? Нет, больше. А, но если это тупо
[02:57:42.120 --> 02:57:50.000]  ДП, если честно, в оциклическом видео, то да. Но на самом деле этого делать не нужно. Но это,
[02:57:50.000 --> 02:57:55.800]  нет, не волнуйтесь. Ну, потому что давайте, нет, тут надо просто действительно подумать. Давайте,
[02:57:55.800 --> 02:58:01.600]  может быть, да, у меня тут, конечно, формально записано. Ой, у меня тут CRM есть, ой-ой-ой-ой. Ну ладно,
[02:58:01.600 --> 02:58:10.120]  давайте, нет, хотя вот, то есть как сказать, да, то есть да, мне обычно нравится проводить, конечно,
[02:58:10.120 --> 02:58:16.120]  эти лекции, да, что лекции в формате, что вот есть идея, давайте с вами все придумаем. Ну вот,
[02:58:16.120 --> 02:58:20.360]  но иногда бывает так, а иногда бывает все, давайте честно пройдем по леммам, и так глядишь и понять
[02:58:20.360 --> 02:58:26.200]  не будет. Вот. Но, впрочем, по-разному бывает. Но давайте вообще думать. Нет, ну, давайте,
[02:58:26.200 --> 02:58:30.880]  вот сейчас, давайте, может быть, чуть-чуть подумаем. Подумаем, вот над чем. Вот идейно,
[02:58:30.880 --> 02:58:35.760]  пока имеется, подумаем. Вот, допустим, нам С-домы известны, допустим, что у нас, ну да,
[02:58:35.760 --> 02:58:41.000]  допустим, у нас С-домы известны. Как нам теперь хотя бы чисто теоретически найти,
[02:58:43.000 --> 02:58:56.320]  найти айдом? Вот давайте подумаем. А я тут пока сотру. Так, ну я надеюсь, вот это уже можно стирать,
[02:58:56.320 --> 02:59:13.600]  я надеюсь. Вот, вот давайте. Так, ну вот кажется, действительно, вот уже начинает, то есть начинает
[02:59:13.600 --> 02:59:20.480]  быть что-то такое вот очень интересное на тему вот чего. Так, ой, что я тетрадку-то держу? Мы ж
[02:59:20.480 --> 02:59:35.040]  думаем, зачем нам тетрадка, да. Так, вот. Значит, что мы имеем? Допустим, у нас есть такое вот прямое
[02:59:35.040 --> 02:59:44.200]  ребро вот в С-дом, да. Можно, но, кстати, кратно даже ребро дерева ДФС, а может и нет. Но мы будем
[02:59:44.200 --> 02:59:54.880]  считать, ну для удобно считать, что скорее нет. Ну просто промежуточных ребер нет. Вот, нет. Вот да,
[02:59:54.880 --> 03:00:02.640]  потому что нет. У нас пока задача такая, предположим, что нам эти С-домы с небес по факсу прислали. Вот,
[03:00:02.640 --> 03:00:10.080]  теперь возникает вопрос, как бы нам теперь найти айдомы? Ну тогда идея тогда, то есть у нас,
[03:00:10.920 --> 03:00:17.640]  то есть у нас вот это вот есть прямое ребро. Значит, теперь мы говорим, так вот все эти вершины
[03:00:17.640 --> 03:00:26.400]  обойти можно, да. Теперь возникает вопрос. Да, кстати, все ребра теперь идут вниз, поэтому ребра,
[03:00:26.400 --> 03:00:32.120]  идущие откуда там, то есть как-нибудь идучие вот как-то вот так, они нас уже не интересуют,
[03:00:32.120 --> 03:00:43.400]  что мы оттуда в W уже не выгребем. Вот, поэтому вывод такой. Так что, ладно, давай скажи.
[03:01:02.120 --> 03:01:10.840]  Нет, ну это может быть точка сочленения, но при этом не доминатор, потому что вот какие-нибудь
[03:01:10.840 --> 03:01:21.800]  вот такие ребра есть еще. Полнейшая точка сочленения, просто отвалится не эта компонента, а вот это.
[03:01:21.800 --> 03:01:50.600]  Ой, мясо. Нет, ну, кстати, нет, может это и правда, но, как бы, честно скажу,
[03:01:50.600 --> 03:01:53.640]  не очень хочется сейчас вспоминать о существовании точек сочленения.
[03:01:53.640 --> 03:02:19.320]  Так, да, идем. Нет, ну не совсем.
[03:02:19.320 --> 03:02:24.080]  Нет, ну там, может быть, идея такая. Допустим, вот дошли до этого. Значит,
[03:02:24.080 --> 03:02:32.760]  удержение такое, если из этих вершин ни одно ребро не идет выше, то есть выше эта вершина,
[03:02:32.760 --> 03:02:38.760]  то очевидно это и есть доминатор, правда. В противном случае тут нашлось какое-то вот такое ребро.
[03:02:38.760 --> 03:02:46.040]  Возьмем из них самое высокое, тогда очевидно вот эти все промежуточные вершины, то есть это мы
[03:02:46.040 --> 03:02:54.280]  тут нашли какую-то вершину w1 и у нее нашли вершину w1. Очевидно, все вот эти вершины,
[03:02:54.280 --> 03:03:01.280]  да, уже доминаторами не являются. А является ли эта вершина доминатором? Ну что, тогда надо
[03:03:01.280 --> 03:03:07.120]  перебрать опять все эти вершины, а точнее все только вот эти вот, и проверить, а нельзя ли из
[03:03:07.120 --> 03:03:13.960]  нее скакнуть куда-то еще выше. Значит, пусть можно, тогда у нас w2, тут получается это, и так,
[03:03:13.960 --> 03:03:18.720]  короче, скачем. Скачем до тех пор, пока не выяснится, что очередной шаг сделать нельзя. Как
[03:03:18.720 --> 03:03:28.480]  только его сделать нельзя, тогда появится радость. Вот, тогда, ну вот, но смотрите,
[03:03:28.480 --> 03:03:33.440]  как интересно, то есть на самом деле это даже похоже на скачки какие-то по деревьям, на самом
[03:03:33.440 --> 03:03:40.840]  деле. Потому что, смотрите, потому что на самом деле приводит таскета к тому, что у меня даже
[03:03:40.840 --> 03:03:52.480]  тут в теореме сформулировано. Да. Так, так, так, так, так. О, даже круче, у меня тут даже две теоремы,
[03:03:52.480 --> 03:04:05.320]  на самом деле. Значит, две теоремы на эту тему звучат так. Так, во-первых, давайте формально
[03:04:05.320 --> 03:04:20.000]  введем такое понятие. Будем говорить, что у стрелочка вот так вот, точка в, если у...
[03:04:20.000 --> 03:04:32.200]  Черт, зачем мы это выводим-то вообще? Нет, ладно, для краткости, по факту это если у предок В,
[03:04:32.200 --> 03:04:48.280]  и у с плюсиком В, если значит у собственной предок В. Да, да, да, да, да, да, да, да. Ну,
[03:04:48.280 --> 03:04:54.560]  такие вот, да, но я не понял, но вот. Ну, как вы и хотим оптимизации надо было еще там DFS запустить
[03:04:54.560 --> 03:05:02.880]  и от таймынов еще избавляться. Так вот, значит, теорема два. Значит, смотрите.
[03:05:02.880 --> 03:05:23.520]  Значит, смотрите, пусть у меня W не равно R, и для любой вершины U такой, что значит у нас из этого
[03:05:23.520 --> 03:05:38.000]  sдома от W можно дойти до U, причем U не равна sдому, вот. А из U можно дойти до W, вот. Пусть для любой
[03:05:38.000 --> 03:06:00.520]  такой вершины U оказалось, что таймын от ее sдома больше либо равен таймын от, соответственно,
[03:06:00.520 --> 03:06:20.080]  sдом от W. Тогда я не ожидаю, что я утверждаю. Да, тогда я утверждаю, что действительно, нет,
[03:06:20.080 --> 03:06:27.040]  никакой, нет, не про предка я ничего не говорю. Тогда я утверждаю, что idom от W это тупо sdom от W.
[03:06:27.040 --> 03:06:39.120]  Это теорема два. Доказательства, ну, вот оно, собственно. Чего?
[03:06:39.120 --> 03:06:55.360]  Ну, смотрите. Ну, как всегда, может, я там опять это больше на меньше поменял, я не знаю. Поэтому
[03:06:55.360 --> 03:07:04.160]  смотрите. Нет, написано там следующее. Смотрите, сейчас я просто покажу. Рассмотрим sdom. Пусть
[03:07:04.160 --> 03:07:09.600]  неожиданно выяснилось, что у всех вот этих вот вершин, которые тут между ними, выяснилось,
[03:07:09.600 --> 03:07:19.520]  что их sдомы лежат не выше этого. То есть как-то вот так вот, вот так и так далее. Вот. Тогда
[03:07:19.520 --> 03:07:26.240]  утверждаю я, что полудоминатор W это есть sдом. Да, проверять это можно, ну, тупой вариант,
[03:07:27.120 --> 03:07:39.800]  знаете, как проверять. Это, ну, например, двоичными подъемами. Нет. Нет. Ну, тут так вряд ли,
[03:07:39.800 --> 03:07:44.840]  потому что тут, тут же еще, пока вы тут dfs-ом ходите, вы даете дожды. Ну ладно, если вы sдомы
[03:07:44.840 --> 03:07:52.440]  уже знаете, то... Нет, погодите, погодите, погодите. Нет, 4 русских вам говорили, куда вы быстро
[03:07:52.440 --> 03:07:59.760]  поднимитесь. А вот минимум на вот этом отрезке пути вам 4 русских не обещали, помнится. Да. Нет,
[03:07:59.760 --> 03:08:08.000]  4 русских вам обещали минимум на пути, минимум на массиве, на этот отрезке, они вам обещали
[03:08:08.000 --> 03:08:14.280]  там за за единицу подняться на любую высоту h. Но, боюсь, вот этот вот минимум даже статистически
[03:08:14.280 --> 03:08:21.280]  они вам сразу не обещали. Нет, сейчас, подойдите, подойдите. Нет, подойдите. Так, давайте внимательно.
[03:08:21.280 --> 03:08:27.100]  Фарах, Колтон, Беддер, что умели? Они умели решать задачу за n единицу a, искать минимум на любом
[03:08:27.100 --> 03:08:33.680]  подотреске массива, во-первых. Ну вот, причем в полном оффлайне, да. И, во-вторых, они вам умели искать
[03:08:33.680 --> 03:08:40.720]  lsa. Здесь нам нужно немножко другое. Здесь нам нужно, надо рассмотреть отрезок пути, и на нем,
[03:08:40.720 --> 03:08:45.440]  то есть на нем тут написаны какие-то числа, и надо на этих числах найти минимум. По-моему,
[03:08:45.440 --> 03:09:00.320]  у нас не было четырех русских, которые обещали вам это. Думаете? Нет, это, конечно, да, но, если
[03:09:00.320 --> 03:09:08.920]  честно, мне не очень очевидно, что тут это. Но, с другой стороны, нет, ну как сказать, нет, если четыре русских,
[03:09:08.920 --> 03:09:13.680]  сейчас эта приплитуция получится за линию, будет неплохо на самом деле. Потому что может вообще выяснить,
[03:09:13.680 --> 03:09:17.600]  что мы сейчас с вами изобретем метод четырех русских, которые дерево-доминатор вообще за линию ищут.
[03:09:17.600 --> 03:09:24.720]  Правда, причем я, честно говоря, да, может и можно написать, потому что мне лично не известно,
[03:09:24.720 --> 03:09:30.520]  что так можно вообще. Нет, там понятно, есть еще sdm, который еще надо искать. Нет, ну тут, смотрите,
[03:09:30.520 --> 03:09:35.880]  в принципе, у меня первая идея, которая тут возникает, смотрите, раз мы запускаем тут,
[03:09:35.880 --> 03:09:40.000]  можно запускать dfs и строить на этих штуках вообще деревоотресков для удобства.
[03:09:40.000 --> 03:09:49.640]  Ну да, а в деревоотресков тоже пушбэрить. А ну, пожалуйста, да, можно фенвик. Нет, стоп,
[03:09:49.640 --> 03:09:58.280]  стоп, стоп, фенвик на минимум, стоп. Нет, погоди, хуже. Да, нет, тебе нужен минимум на суффиксе.
[03:09:58.280 --> 03:10:05.200]  Кажется, фенвик у нас имеет минимум на префиксе, а не минимум на суффиксе. Так что лучше так,
[03:10:05.200 --> 03:10:11.960]  может деревоотресков, а можно двоичный подъем, и суть одна. То есть, как бы, хотя бы n лог n.
[03:10:11.960 --> 03:10:18.200]  То есть, мы чуть позже, но на самом деле, да, но это как бы вот эту проверку поможет сделать,
[03:10:18.200 --> 03:10:25.280]  то есть, если такая проверка выплылась, то idum вот он, но есть, на самом деле, соседняя теремма.
[03:10:25.280 --> 03:10:40.320]  То есть, пусть у меня, ну да, то есть, по сути, пусть вот это вот, и действительно окажется,
[03:10:40.320 --> 03:10:48.120]  что пусть у меня, допустим, w штрих равно, как всегда, так, как это будет,
[03:10:48.120 --> 03:11:10.800]  так, как это будет. Аргмин от таймын от esdom от u, вот мясо, да. Такое, что esdom от w,
[03:11:10.800 --> 03:11:26.640]  стрелочка плюсик u, стрелочка точка w. Что? Это w штрих, да. Значит, пусть совершенно случайно
[03:11:26.640 --> 03:11:40.360]  оказалось, что w штрих не равен esdom от w. Точнее, так, пусть оказалось совершенно случайно,
[03:11:40.360 --> 03:11:49.840]  что действительно этот esdom от w, то есть, esdom от этого w штрих не равен вот этому esdom от w.
[03:11:49.840 --> 03:12:12.640]  Тогда утверждаю я idum от w равен tupa idum от w штрих. То есть, на самом деле, да, эти две тереммы
[03:12:12.640 --> 03:12:16.440]  можно было, конечно, в едино сформулировать, то есть, рассмотрим вот такую версию w. Есть у
[03:12:16.440 --> 03:12:21.320]  нее esdom. То есть, получается, мы в любом случае делаем так, ищем минимум на полуинтервале,
[03:12:21.320 --> 03:12:29.760]  так сказать. Ну вот, смотрим, ну вот, у него esdom. Если esdom у него, если esdom у него совпал с esdom
[03:12:29.760 --> 03:12:36.720]  от w, то, ну, значит, тогда мы idum пишем как esdom. В противном случае мы берем эту вершину и от нее
[03:12:36.720 --> 03:12:50.040]  запускаемся типа рекурсивно. Ну да, потому что, по сути, тут написано следующее. Я беру вершину,
[03:12:50.040 --> 03:12:56.800]  с которой можно подняться как можно выше. Вот, ну и замечаем, что, как бы, ее обходить мы можем
[03:12:56.800 --> 03:13:04.240]  только выше, поэтому там можно, по сути, рекурсивно запускаться от нее. Вот, поэтому,
[03:13:04.240 --> 03:13:09.560]  в принципе, то есть, можно, то есть, на самом деле, действительно, то есть, уже мысленно можно
[03:13:09.560 --> 03:13:15.520]  задуматься о том, что если у вас esdom есть, то idum вы найдете, то есть, idum вы, в принципе,
[03:13:15.520 --> 03:13:24.040]  за n log n, получается, найдете. Можно, ну вот, можно еще чуть позже подумать, а как бы обойтись,
[03:13:24.040 --> 03:13:29.720]  то есть, как бы обойтись без двоичных подъемов, а какими структурами типа everlink update.
[03:13:29.720 --> 03:13:43.400]  Очередь с минимумом, да, ага, только она какая-то персистентная очередь с минимумом,
[03:13:43.400 --> 03:13:48.400]  это не очень хорошо. Нет, ну там вопрос просто, как это все будет, то есть, как еще будет находиться,
[03:13:48.400 --> 03:13:53.560]  как будет esdom, потому что они там тоже все не совсем с потолка сваливаются. Вот, хотя,
[03:13:53.960 --> 03:14:00.000]  но да, но с другой стороны, ладно, в любом случае, так, не пришло время перерыва?
[03:14:00.000 --> 03:14:06.280]  Вот, пришло, ну ладно, ну, до какой-то точки мы дошли, поэтому, да, давайте перерыв.
[03:14:06.280 --> 03:14:14.160]  Так, смотрите, ну, во-первых, да, мы тут задачу практически свели к esdom, но единственное,
[03:14:14.160 --> 03:14:18.720]  мы все-таки поговорим, как свести, ну, то есть, мы решали эту задачу, пусть у нас есть esdom,
[03:14:18.720 --> 03:14:31.440]  как найти idem. Вот, так, ну, вот, ну, значит, соответственно, значит, будет, значит,
[03:14:31.440 --> 03:14:35.800]  хочется все сразу обсудить, значит, задачу, как тогда, как находить по esdom idem, но хочется
[03:14:35.800 --> 03:14:40.680]  свести это к структуре данных, которая как минимум в принципе умеет решать это быстрее,
[03:14:40.680 --> 03:14:47.680]  чем этими вашими двоичными подъемами. Значит, делать мы это будем так, так, ну ладно,
[03:14:47.680 --> 03:14:54.400]  это мы все уже можем брать. Значит, смотрите, допоминаю, у нас есть мистическая структура данных,
[03:14:54.400 --> 03:15:05.080]  значит, у нас есть мистическая структура данных, everlink и, возможно, update, но в нашем случае
[03:15:05.080 --> 03:15:11.200]  потребуется только структура данных everlink, значит, она нам потребуется, ну, то есть,
[03:15:11.200 --> 03:15:16.040]  она там вводится на самом деле тоже там с операциями там вида it, которая там ассоциативна,
[03:15:16.040 --> 03:15:21.880]  там что-то еще в этом роде, там еще там какие-то допусловия могут быть, вот, значит,
[03:15:21.880 --> 03:15:29.400]  но everlink в нашем виде будет такая, смотрите, то есть, у нас есть вершины, они организованы
[03:15:29.400 --> 03:15:40.880]  в какие-то подвешенные деревья и нам потребуется, и на каждой вершине написано число, которое в
[03:15:40.880 --> 03:15:46.960]  процессе еще не меняется, ну, кроме корня, то есть, может меняться только корень,
[03:15:46.960 --> 03:15:59.920]  ну, вот, значит, хочется уметь делать следующую операцию, во-первых, хочется уметь делать
[03:15:59.920 --> 03:16:15.040]  операцию link uv, это означает подвесить корень к, соответственно, вершине v,
[03:16:15.040 --> 03:16:23.600]  ну, естественно, не буду прописывать, но очевидно, подразумевает, что вершина v в под дереве u не
[03:16:23.600 --> 03:16:43.480]  лежит, и хочется еще сделать такое eval от u, это значит найти argmin от вот этого вот,
[03:16:43.560 --> 03:17:01.560]  val от, допустим, v на пути от u включительно до, сейчас будет немножко внезапно,
[03:17:01.560 --> 03:17:05.960]  но это может иметь смысл, до корня не включительно,
[03:17:13.480 --> 03:17:25.200]  так вот, допустим, мы, обратите внимание, нам очень важно, что мы ищем не просто минимум,
[03:17:25.200 --> 03:17:38.440]  а где он находится, так вот, я утверждаю, что мы можем, по идее, свести, что мы можем решать,
[03:17:38.440 --> 03:17:44.880]  если у нас s дымы есть, то я утверждаю, что i дымы мы с помощью этой структуры данных можем
[03:17:44.880 --> 03:17:54.520]  найти за o от n плюс m плюс какое-то линейное количество вот этих вот операций, понятно, да?
[03:17:54.520 --> 03:18:06.600]  m не менее чем n-1, поэтому по сути по m, то есть можно сказать, что асимптотика у нас будет
[03:18:06.600 --> 03:18:15.360]  o от n умножить на там link плюс eval, можно там точнее сказать, сколько у нас там будет линков,
[03:18:15.360 --> 03:18:21.880]  линков, понятно, будет там n минус 1 не более, а eval будет, наверное, чуть побольше, как мы это
[03:18:21.880 --> 03:18:28.360]  будем делать, значит, смотрите, как мы будем именно сводить, будьте здоровы, спокойно, вот,
[03:18:28.360 --> 03:18:35.800]  ну тут как раз ничего страшного нет, так, то есть, в общем-то, то есть половину страшного, на самом
[03:18:35.800 --> 03:18:43.360]  деле, мы уже сделали, вот, да и ничего тут страшного нет, значит, смотрите, идея будет такая, я буду,
[03:18:43.360 --> 03:18:50.160]  пусть у меня s дымы есть, да, по большому счету, смотрите, как у меня устроены запросы, то есть у меня
[03:18:50.160 --> 03:18:58.440]  все запросы, которые я хочу сделать, это запрос, найди мне минимум от w до s дыма от w, правда,
[03:18:58.440 --> 03:19:07.640]  логично, да, вот, то есть, причем напоминаю, все с дыма уже есть, надо найти минимальный s дым,
[03:19:07.640 --> 03:19:14.920]  в чем по большому счету, вот эта теорема говорит мне следующее, что для каждой вершины w надо
[03:19:14.920 --> 03:19:21.600]  найти, так сказать, вот этот минимум и, так сказать, найти вот этого вот предочка, правда,
[03:19:21.600 --> 03:19:29.960]  нет, мы не ищем минимум под дерево, мы ищем минимум на пути,
[03:19:29.960 --> 03:19:58.440]  нет, у нас вот идея, какая будет идея заранее, заранее будет идея такая, что, то есть,
[03:19:58.440 --> 03:20:03.840]  для каждого w нужно найти вот эту штуку, правда, то есть, если мы вот эту штуку w эти найдем, то есть,
[03:20:03.840 --> 03:20:08.440]  тут два варианта, либо w и стрелочка перейдет сама в себя, то есть, сама в себя это будет
[03:20:08.440 --> 03:20:15.200]  в случае теоремы 2, либо это будет стрелочка вот, либо стрелочка в другую вершину, и тогда,
[03:20:15.200 --> 03:20:21.160]  на самом деле, у нас появится вот такое дерево, даже лес, если быть точнее, и для каждой вершины
[03:20:21.160 --> 03:20:27.760]  надо просто пойти тут просто до корня, потом в конце, и этот корень будет окажется доминатором,
[03:20:27.760 --> 03:20:36.520]  понятно, да, это мы будем называть там дом от w, давайте эту вершину будем называть, нет,
[03:20:36.520 --> 03:20:41.760]  просто практически так он, просто дом, это вот просто тариан так предлагает ее называть, то есть,
[03:20:41.760 --> 03:20:46.080]  реально дерево мы так строить не будем, а просто для каждой вершины, на самом деле, просто там,
[03:20:46.080 --> 03:20:51.640]  типа, если дом от нее равен ее, то значит и тут доминатор такой же, а в противном случае,
[03:20:51.640 --> 03:21:01.400]  просто пойди в ее дом и, собственно, запустись к нему, какие-то ассоциации, что ли, вызывают?
[03:21:01.400 --> 03:21:15.800]  Дом, смешное слово, да, так, ладно, страшные ассоциации, да, да, да, да, да, да, да, да,
[03:21:15.800 --> 03:21:23.000]  то смешные шутки не заходят, то неожиданно начинается, ну ладно, не, ну знаете, иногда,
[03:21:23.000 --> 03:21:26.720]  знаете, скажете, знаете, что это там типа, знаете, близкую грушу воробей не укусит,
[03:21:26.720 --> 03:21:34.880]  а потом как, как вы сказали, и все, и все, там уроки в соседних колоссах парализованы, да, потому
[03:21:34.880 --> 03:21:48.920]  что как близкую грушу чего, не так, да, это была не смешная шутка, да, ну нет, ну все говорят,
[03:21:48.920 --> 03:21:56.400]  большую грушу вовремя не укусит, да, вот, да, правильно, а кто это говорит, да, никто, я только
[03:21:56.400 --> 03:22:04.920]  что придумал, но вот этот вот загон, вот, вот, вот загона, кстати, действующий чемпион высшей
[03:22:04.920 --> 03:22:11.520]  лидии КВН, между прочим, вот, ладно, так, значит, хорошо, значит, хорошо, это теперь вопрос,
[03:22:11.520 --> 03:22:18.920]  как этот дом найти, потому что после того, как найти этот дом, получается, то проталкиванием
[03:22:18.920 --> 03:22:27.480]  домов мы все айдомы найдем, вот, значит, вот такая красота, в чем там у Тарьяна даже красивая структура,
[03:22:27.480 --> 03:22:32.120]  как это там потом в процессе, там все вообще там в одном ДФСе вообще будет, ну или практически,
[03:22:32.120 --> 03:22:39.240]  нет, ладно, в одном ДФСе не будет, потому что дело в том, что айдомы мы будем искать в порядке убывания
[03:22:39.240 --> 03:22:49.760]  таймына, внимание, именно убывание, обратите внимание, да, потому что идея будет такая,
[03:22:49.760 --> 03:22:58.960]  потому что давайте так, во-первых, если мы знаем айдомы, то мы для каждой вершины можем записать
[03:22:58.960 --> 03:23:07.880]  просто список всех вершин таких, что айдом это я, вот, про прям список, Тарьяна это называет
[03:23:07.880 --> 03:23:16.800]  бакет, кстати, вот, поэтому идея будет такая, смотрите, вот у меня было тут такое, значит,
[03:23:16.800 --> 03:23:26.640]  было у меня тут дерево ДФСа, изначально, да, вот оно, оно тут есть, вот так вот, как-то вот так,
[03:23:26.640 --> 03:23:36.040]  вот так вот, так вот, так вот, так вот, теперь я буду собирать эти вершины в порядке убывания,
[03:23:36.040 --> 03:23:43.320]  что значит буду собирать, это значит, что у меня изначально все эти вершины будут отдельные, да,
[03:23:43.360 --> 03:23:52.600]  то есть я на них буду строить вот это вот, значит, я буду строить на них вот это вот, вот, то есть вот,
[03:23:52.600 --> 03:23:57.280]  но изначально все эти вершины будут как бы висеть по отдельности, вот я сейчас просто перерисовываю
[03:23:57.280 --> 03:24:06.560]  примерно вот так, как они тут были, вот, а дальше буду собирать их примерно так,
[03:24:06.700 --> 03:24:14.200]  значит, я буду сначала обрабатывать эти вершины в порядке убывания таймин, то есть поработаю с
[03:24:14.200 --> 03:24:18.640]  этой, поработаю с этой, поработаю с этой, потом поработаю с этой, в процессе работы,
[03:24:18.640 --> 03:24:28.000]  подвешу к ней всех ее детей, потом поработаю с этой вершины, потом поработаю с вот этой,
[03:24:28.000 --> 03:24:36.800]  повешу там всех ее детей подвешу не повешу вот да значит это это это да потом это это это потом
[03:24:36.800 --> 03:24:42.280]  но потом вот так и так далее но смотрите что я могу теперь делать в процессе зачем я все это
[03:24:42.280 --> 03:24:50.320]  делаю потому что дело в том что в процессе то есть у меня от каждой вершины есть из дома и поэтому
[03:24:50.320 --> 03:24:59.400]  у меня идея такая для вот этой вот вершины теперь я могу перебрать все вершины значит все
[03:24:59.400 --> 03:25:05.000]  вершины для кого она является с домом то есть вот все тут у нее потомки были какие-то но не
[03:25:05.000 --> 03:25:10.960]  все по не всех потомков конечно просто кто есть да и для каждого из них теперь я в этом
[03:25:10.960 --> 03:25:22.880]  дереве могу просто вызвать операцию ивал вот вот то есть просто я вот так вот под ладон подлавливаю
[03:25:22.880 --> 03:25:30.720]  момент и вычисляю вот это вот дом но потом этот дом я соответственно доупихиваю вот так что вот
[03:25:30.720 --> 03:25:38.200]  такая вот красота дом напоминаю вот что садри как мы ищем вообще вот согласно этим двум теоремам
[03:25:38.200 --> 03:25:45.240]  полудо айдам то есть мы рассматриваем путь от с дома не включить на до дабл и включить на и
[03:25:45.240 --> 03:25:55.360]  находим здесь вершину с самым высоким с домом вот вот ее я называю дом от дабл ее потому что
[03:25:55.360 --> 03:26:00.520]  потом теорема то есть она либо оказывается самим дабл юй и мы тогда просто говорим что полудомина
[03:26:00.520 --> 03:26:07.440]  то есть просто айдам это она есть либо она оказывается выше и тогда мы как бы не отсылает то
[03:26:07.440 --> 03:26:13.080]  есть это мы называем дом то есть получается мы должны получается такое строим этот дом и
[03:26:13.080 --> 03:26:18.920]  потом мы тогда то есть должны дойти теперь до корня и у этого корня взять эстом и это будет
[03:26:18.920 --> 03:26:29.040]  айдам вот так вот я уже начал говорить на каком-то китам языке непонятно что какой из
[03:26:29.040 --> 03:26:40.760]  который вот это вот сюжет и ну похоже да но учитывая что это тоже алгоритм тарья в общем-то
[03:26:40.760 --> 03:26:47.440]  да как бы технологии одинаковые да так вот значит садрить то есть таким образом видите то есть
[03:26:47.440 --> 03:26:54.320]  подвешиваем мы естественно с помощью линка вот ну и соответственно и вал мы вычисляем да тоже
[03:26:54.320 --> 03:27:00.760]  в общем-то да даже не м получается нет конкретно эту часть мы вообще получается делаем за едва
[03:27:00.760 --> 03:27:07.400]  ли не н потому что видите евалов то мы тоже в общем-то n-1 даже я бы сказал можно даже так
[03:27:07.400 --> 03:27:15.720]  это конечно неправильно асимпатически писать но это получается n-1 линк плюс евал да но от
[03:27:15.720 --> 03:27:24.040]  евала мы получили но если мы на каждой вершине пишем таймы его из дома да то получается что то
[03:27:24.040 --> 03:27:30.120]  как бы евалом мы как раз вычисляем вот этот вот дом вот но после которого мы том за линию уже
[03:27:30.120 --> 03:27:36.200]  собственно все айдам и найдем так что остается так что это мы запомнили а теперь остается самое
[03:27:36.200 --> 03:27:45.480]  интересное как собственно найти из дома пока нам их сожалению просто присылали пока нам ну
[03:27:45.480 --> 03:27:54.480]  просто присылали короче давайте разбираться значит как же нам найти из дома но как вы думаете
[03:27:54.480 --> 03:28:02.840]  какая теория мы нам поможет сделать теория мы четыре совершенно верно да ну естественно да ну а
[03:28:02.840 --> 03:28:12.760]  какая еще но по я не тут все теория мы это линга уэр тарьян или как он там ланшет как она ланша
[03:28:12.760 --> 03:28:20.520]  что кто лан пусть будет линга уэр да ну ладно как вы эти да не обидится он на нас так а то знаете
[03:28:20.520 --> 03:28:26.080]  как неловко будет прийти на конференцию он вполне себе живой и разговаривает да я думаю так я
[03:28:26.080 --> 03:28:30.560]  пошел с тарьяном по ходу еще же там вполне себе можно встретиться с этим товарищем я думаю
[03:28:30.560 --> 03:28:35.440]  подавно это иногда у меня полное ощущение что все потом все подобные родно парки вполне могли
[03:28:35.440 --> 03:28:40.120]  быть учениками тарьяна это могла быть какая-нибудь там я из отчасти кандидат часть какой-нибудь пизди на
[03:28:40.120 --> 03:28:47.320]  самом деле ну не обязательно конечно но вот нет умалее я почти уверен что скажем там строгая
[03:28:47.320 --> 03:28:58.000]  куча фибоначи это точно была какая-нибудь пиздишка вот но мне так кажется хотя вот так но я не буду
[03:28:58.000 --> 03:29:03.520]  повторять про строгую кучу фибоначи это мы с вами посуждали значит теория звучит так для любого
[03:29:03.520 --> 03:29:16.920]  в дабл ю не равного эру не равного эру верно что значит шейт такое ух ты у ладно нет все нормально
[03:29:16.920 --> 03:29:35.880]  с дом от дабл ю равен арк минимуму арк минимуму таймына от у где у лежит в объединении множеств
[03:29:35.880 --> 03:29:53.200]  с1 от дабл ю и с2 от дабл ю где да ну естественно вот нет хочется конечно сказать что с1 это там
[03:29:53.200 --> 03:30:00.120]  с2 это какой-нибудь там множество перестановок там на одном элементе но вот у вас еще нет там
[03:30:00.120 --> 03:30:13.160]  теория группа какой-нибудь по всю как это да ладно у вас там должно быть эфем но
[03:30:13.160 --> 03:30:20.680]  но что перестанут но это нет ладно нет если вы нет если вы там знаете теорию
[03:30:20.680 --> 03:30:28.800]  глотвы это хорошо может вы мне даже расскажете так не знаете господи что ж вы там изучали так
[03:30:28.800 --> 03:30:34.840]  я хотя ладно у меня что же была теория группе что тоже что-то изучал в чем хорошие что-то изучал
[03:30:34.840 --> 03:30:43.080]  причем дай я в чем судя потому что у меня там стоял там какой-то отл 8 или отл 9 значит
[03:30:43.080 --> 03:30:54.120]  наверное я ее хорошо изучал вот да чего не не не не ну на самом деле нет там там просто как это
[03:30:54.120 --> 03:30:59.400]  такой теории не было но там там другой там все-таки вот это был такой курс когда 8 9 10
[03:30:59.400 --> 03:31:04.200]  отличается на тем насколько там то есть совсем все ли задачи включая сложные вы там решите или
[03:31:04.200 --> 03:31:11.480]  все-таки что-то для вас останется рабом вот поэтому там вот нет но собственно ладно кто
[03:31:11.480 --> 03:31:20.720]  учился у богданова знаете что у него обычно всегда так да чего а лектор но у нас электросеминарист
[03:31:20.720 --> 03:31:32.280]  все так вот значит с1 короче пока я тут значит да вот значит с1 это что так множество с1 это
[03:31:32.280 --> 03:31:43.840]  такое что это такое множество в что ну просто короче w это ребро ну вот и давайте так напишу
[03:31:43.840 --> 03:32:01.360]  таймы на тв меньше чем таймы от в ну логично да потому что есть потому что среди скажем так
[03:32:01.360 --> 03:32:06.880]  среди кандидатов вездом и наверное есть просто вершины с меньшим таймином с которых просто
[03:32:06.880 --> 03:32:13.600]  ведет ребро в нас но обычно эти ребра называются как они называют как таки ребра обычно
[03:32:13.600 --> 03:32:23.080]  называются но обычно прямые или ну или ребро дерева dfs да но это просто они но логично их
[03:32:23.080 --> 03:32:37.960]  учесть а вот что такое с2 значит с2 это множество таких вершин у таких что а нет вру вру вру вру
[03:32:37.960 --> 03:32:52.200]  нет тут уже мы пойдем по-другому тут не у а тут с да мату нет не у а есть да мату в общем
[03:32:52.200 --> 03:33:01.000]  смотрите у кого мы берем из общем короче так ну давайте уж напишу вообще во первых у дабл ю это
[03:33:01.000 --> 03:33:12.960]  ребро но на этот раз таймин от в оказался то есть таймы но ой как тут все сложно
[03:33:12.960 --> 03:33:28.360]  ой ой ой нет неправда смотрите значит есть ребро в вот так ладно так ладно по-моему
[03:33:28.520 --> 03:33:36.040]  лучше написать как есть надежнее будет там это автор думал слова подбирал это называется во
[03:33:36.040 --> 03:33:47.480]  первых смотрите начнем начнем с другого начнем с того что таймы на ту значит больше чем таймы
[03:33:48.080 --> 03:34:02.440]  и значит существует такая вершина в что во первых из в в в ведет просто ребро
[03:34:02.440 --> 03:34:13.080]  так и при этом еще что важно из у мы можем попасть в по дереву dfs
[03:34:17.480 --> 03:34:33.160]  вот теперь хорошо так попробуем расшифровать да значит череза множество из 2 значит множество
[03:34:33.160 --> 03:34:38.000]  из ну то есть по сути теория мы четыре говорить что алгоритм должен звучать так рассмотрим
[03:34:38.000 --> 03:34:45.760]  вершину дабл ю рассмотрим все входящие в нее ребра если это входящее ребро ведет из вершины
[03:34:45.760 --> 03:34:52.480]  с меньшим таймы нам то самую эту вершину и рассматриваем но если оказалось что это вершина
[03:34:52.480 --> 03:35:03.760]  ведет не из предка в том числе родителя а откуда-то справа оба но вот откуда-то справа или снизу
[03:35:03.760 --> 03:35:11.960]  да снизу тоже вариант то оказывается работает что-то такое смотрите вот давайте то есть работает
[03:35:11.960 --> 03:35:17.120]  примерно так то есть вот жила была допустим вершина дабл и мы тут неожиданно откуда-то
[03:35:17.120 --> 03:35:26.400]  пришли тогда идея такая давайте то есть предлагается нам тогда сделать так давайте
[03:35:26.400 --> 03:35:32.480]  пойдем от этой вершины в так статида это ребро в таком случае окажется либо перекрестным либо
[03:35:32.480 --> 03:35:39.120]  еще будет случай когда оно обратное но основной случай крышка данного перекреста тогда суть
[03:35:39.120 --> 03:35:44.480]  такая предлагает нам этот алгоритм так давайте от этой вершины в честно пойдем
[03:35:44.480 --> 03:35:54.120]  прям пора дите по предкам до тех пор пока не упрёмся в общего предка с дабл ю но очень
[03:35:54.120 --> 03:35:58.920]  просто есть или что тоже самое рассмотрим тут все вершины на этом пути которые потаймы но
[03:35:58.920 --> 03:36:05.280]  больше чем дабл ю но очевидно что это как раз вот до этого предка не включительно да и у всех
[03:36:05.280 --> 03:36:13.680]  этих вершин мы рассмотрим что если мы да в том числе и у нас самой то есть там с дом тут вот
[03:36:13.680 --> 03:36:19.640]  то есть рассмотрим как-то вот так то есть тут еще что-то такое тут куда-нибудь он может совсем
[03:36:19.640 --> 03:36:34.920]  высь пошел там тут наоборот сюда но и так далее вот да только по сути да да правда не
[03:36:34.920 --> 03:36:44.400]  включительно самолца вот то есть по сути утверждается что ровно это мы должны рассмотреть
[03:36:44.400 --> 03:36:59.960]  понимаете да вот более того кстати обратите внимание на маленький приятный момент если мы
[03:36:59.960 --> 03:37:05.600]  сейчас в это поверим то оказывается что ровно вон тем же вал линком на самом деле ищутся и
[03:37:06.160 --> 03:37:15.880]  ищутся за счет маленькой приятной вещи потому что заметим что для того чтобы найти с дабл ю нам
[03:37:15.880 --> 03:37:25.200]  нужно знать только с дамы вершин у которых таймын заведомо больше видно да то есть идея будет
[03:37:25.200 --> 03:37:33.480]  такая то есть но то есть как бы то есть обратите внимание то есть все вот это вот оно вот если мы
[03:37:33.480 --> 03:37:41.320]  применяем вот эту вот веселую технологию да то когда мы рассматриваем дабл ю вот когда мы
[03:37:41.320 --> 03:37:46.760]  рассматриваем какую-то дабл ю то все вершины то в тот момент когда мы начинаем ее рассматривать
[03:37:46.760 --> 03:37:55.320]  все вершины больше по таймыну на самом деле уже объединены в какие-то деревья так ладно у нас
[03:37:55.960 --> 03:38:03.520]  понимаете да то есть поэтому вот эти вот минимумы на путях мы в принципе вполне можем
[03:38:03.520 --> 03:38:04.280]  рассматривать spr scra guys
[03:38:04.280 --> 03:38:08.600]  рассматривать то надо тот же самый минимум из дома который нужен был там понимаете да
[03:38:08.600 --> 03:38:17.240]  то есть нам даже ничего тот есть не надо две функции поддержив었어 одну то есть получается
[03:38:17.240 --> 03:38:21.520]  то есть на самом деле тут был n минус 1 и на самом деле тогда получается
[03:38:21.520 --> 03:38:29.520]  что то есть на самом деле вот то есть ну то есть если мы поверим в эту теорему то на самом деле
[03:38:29.520 --> 03:38:37.240]  нам потребуется то есть потребуется в эту технологию просто добавить не более чем м е валов
[03:38:37.240 --> 03:38:47.360]  потому что абсолютно те же минимум вот потому что мы перебираем для каждой вершины все входящие
[03:38:47.360 --> 03:38:53.600]  в нее ребра и как бы если она по таймену меньше то считаем ее если она больше то
[03:38:53.600 --> 03:39:00.080]  берем минимум на этом пути понимаете да то есть вот получается если мы сейчас поверим в эту
[03:39:00.080 --> 03:39:04.800]  теорию то есть поверивший в эту теорему мы получили алгоритм который ищет который сводит
[03:39:04.800 --> 03:39:14.000]  задачу к эволинку понятно да так но теперь давайте собственно самое интригующее а почему же
[03:39:14.360 --> 03:39:35.040]  вообще верно откуда же у нас такое счастье так да ну да да ну вот ну да заметим дистиле да
[03:39:35.120 --> 03:39:42.240]  заметим маленькоб да то есть первое что очевидно это то что но то то что следующие еще что
[03:39:43.520 --> 03:39:48.680]  что каждая вершина из этого мнfficial является кандидатом в полудоминатор до того теперь
[03:39:48.680 --> 03:39:52.120]  увы твоей давайте вспомнить что такое полудоминатор и что когда кандидат вершины
[03:39:52.120 --> 03:39:57.420]  является кандидатом полудоминаторы если из такое можно дойти до дабл и скольз Azk Kyoto
[03:39:57.420 --> 03:40:04.320]  перемежуточных только вершины стоимы нам больше чем даamel и полудоминатор это кандидат в
[03:40:04.320 --> 03:40:12.140]  полудоминаторы с минимальным таймином. Понимаем, да? Вот. Очевидно, что все эти
[03:40:12.140 --> 03:40:19.400]  вершины действительно являются кандидатами в полудоминаторы. Очевидно?
[03:40:19.400 --> 03:40:23.800]  Ну, действительно, да. Потому что, скажем, если взять какую-нибудь вершину
[03:40:23.800 --> 03:40:29.840]  Эсдома от нее, то как бы из Эсдома от нее до нее мы доходим по тайминам
[03:40:29.840 --> 03:40:34.400]  большим, чем она, но у нее таймин уже больше, чем здесь. И оставшийся этот путь
[03:40:34.400 --> 03:40:38.720]  тоже по тайминам больше, чем здесь. Ну, а то, что есть один кандидат в полудоминаторе,
[03:40:38.720 --> 03:40:45.760]  это очевидно. Остается доказать только одно. Остается только доказать, что истинный
[03:40:45.760 --> 03:40:55.240]  полудоминатор действительно тут найдется. Но давайте разбираться. Но давайте рассмотрим.
[03:40:55.240 --> 03:41:10.160]  Действительно. Так. Ой. Что ж такое? Так. Так. Ой. Так. Стоп. А, это он и есть, да? Ну ладно.
[03:41:10.160 --> 03:41:17.320]  Ладно, давайте так попробуем. Так. Значит, смотрите. Жил-был. Значит, наш путь жил-был W.
[03:41:17.320 --> 03:41:27.400]  Спрашивается. И был у него полудоминатор. Был у него тут полудоминатор. Почему зеленый? Да,
[03:41:27.400 --> 03:41:36.200]  в принципе, почему бы и нет, но тем не менее. Так. Значит, был у него полудоминатор. И как-то мы из
[03:41:36.200 --> 03:41:42.920]  этого полудоминатора в W дошли, причем еще и через вершины больше, чем W, правда? Ну, давайте
[03:41:43.160 --> 03:41:49.680]  во-первых, если этот путь состоял из одного ребра, то очевидно, тогда эта вершина попала в S1.
[03:41:49.680 --> 03:42:05.480]  Но если она тут шла как-то еще, то у нее была предыдущая вершина. Предпоследняя. Вот это вот W.
[03:42:05.480 --> 03:42:20.800]  А у этой, ну вот. А у этой вершины, что было у этой вершины? А у этой вершины был, соответственно,
[03:42:20.800 --> 03:42:35.400]  какой-то вот этот вот путь. Логично, да? Вот. Значит, какой путь? Ну, давайте вот что. Смотрите
[03:42:35.400 --> 03:42:42.280]  давайте от этой вершины W. Ну, что логично. Рассмотрим. Давайте черный коричневый заменим,
[03:42:42.280 --> 03:42:52.400]  а то писать невозможно. Так. Вот. Значит, вот давайте пусть. Это типа черный такой. Вот. Вот.
[03:42:52.400 --> 03:43:00.840]  Значит, смотрите. У нас тут был вот этот вот путь от вершины W до там какой-нибудь LCA, да? Так,
[03:43:00.840 --> 03:43:06.120]  куда-то это LCA ведет. Я не знаю пока куда. В общем, где-то тут S. В общем, жила была вершина W.
[03:43:06.120 --> 03:43:18.240]  Значит, из S. В общем, был какой-то вот такой путь в LCA. Если брать вот этот путь от S. Я уж не знаю,
[03:43:18.240 --> 03:43:25.280]  где он. Ну, где лежит S. Сам по себе. Ну, S. очевидно, лежит либо здесь, либо выше. Правда?
[03:43:25.360 --> 03:43:37.360]  Согласны? Вот. Поэтому давайте вот тут. То есть, S. Допустим. Чего? Ну, заметил, что это вершина.
[03:43:37.360 --> 03:43:43.480]  Ну, вот. Ну, скажем так. Эта вершина сама по себе кандидат в S. Поэтому реально S. лежит либо
[03:43:43.480 --> 03:43:51.560]  здесь, либо выше. Да? Вот. Поэтому давайте для общего случая нарисую, что она выше. Так вот.
[03:43:51.560 --> 03:44:02.040]  Так вот. Теперь идея такая. Значит, давайте. То есть, смотрите. Рано или поздно этот путь от S.
[03:44:02.040 --> 03:44:09.000]  нам от W до W. Раз он проходил через вершину W. Раз у него последняя вершина W, то рано или поздно
[03:44:09.000 --> 03:44:21.360]  этот путь окажется на этом вот пути. Правда? То есть, рано или поздно мы сюда придем. Так вот.
[03:44:21.360 --> 03:44:26.720]  Давайте вот скажем, что мы тут ходили, бродили, ходили, ходили, ходили, ходили, бродили. И вот,
[03:44:26.720 --> 03:44:32.200]  неожиданно, впервые оказались на этом пути. И это оказалась вот эта вот вершина. Давайте Uka
[03:44:32.200 --> 03:44:37.360]  ее и назовем. Ну, заметим, что остальной путь, в принципе, можно не рассматривать, потому что
[03:44:37.360 --> 03:44:48.760]  можно его просто заменить на вот этот вот спуск W. Правда? Ну, идейно. Вот. Но тогда заметим следующее.
[03:44:48.760 --> 03:44:56.520]  То есть, заметим следующее. Тогда я утверждаю, вот мне почему-то жутко хочется утверждать,
[03:44:56.520 --> 03:45:09.760]  что S нам от W. Ну, вот что, то есть, хочется тогда сказать, что не окажется ли S нам от W
[03:45:09.760 --> 03:45:23.440]  случайно S нам еще от этого Uka. Ну, потому что вот хочется мне почему-то сказать такую жуткую вещь.
[03:45:23.440 --> 03:45:36.600]  Вот, не кажется ли вам, что вот эти все вершины, они по таймыну больше, чем Uka? Да, это так. Вот
[03:45:36.600 --> 03:45:41.720]  почему. Потому что пусть вот на этом пути где-нибудь образовалась неожиданно вершина,
[03:45:41.720 --> 03:45:48.960]  у которой таймын меньше, чем таймын от Uka. Тогда у нас есть мистическая теория о том,
[03:45:48.960 --> 03:45:57.000]  что где-то между ними найдется общий предок этой вершины и Uka. И этот предок, как всегда,
[03:45:57.000 --> 03:46:04.760]  не совпадает с Uka. Понимаете, да? Ну, не может быть Uka предком вершины с меньшим таймына. Но тогда,
[03:46:04.880 --> 03:46:10.480]  либо это. Но тогда мы вынуждены заключить. Что либо вот. То есть,
[03:46:10.480 --> 03:46:14.280]  мы вынуждены заключить, что эта вершина либо попадет на… То есть,
[03:46:14.280 --> 03:46:17.200]  она окажется предком Uka, то есть, либо она попадет на эту часть пути.
[03:46:17.200 --> 03:46:20.640]  Но этого не может быть, потому что вот эта вершина такая первая по определению.
[03:46:20.640 --> 03:46:32.960]  Либо, либо тогда окажется что, либо тогда окажется, что эта вершина у нас окажется где-то
[03:46:32.960 --> 03:46:39.960]  это вот на вот этой вот части пути. Понятно, да? Что?
[03:46:39.960 --> 03:46:46.960]  Вершина, которая с которой ты меньше, чем...
[03:46:46.960 --> 03:46:51.960]  Сейчас, что?
[03:46:51.960 --> 03:46:55.960]  Значит, вот это? Так, давайте лучше с нуля тогда.
[03:46:55.960 --> 03:47:00.960]  У нас есть путь от w до w. Напоминаю, по определению
[03:47:00.960 --> 03:47:05.960]  все вершины этого пути были по таймину больше, чем w.
[03:47:05.960 --> 03:47:07.960]  W была последней из этих вершин.
[03:47:07.960 --> 03:47:12.960]  W – это просто вершина, из которой мы просто сюда пришли.
[03:47:12.960 --> 03:47:15.960]  Вот. Значит, тогда у нас идея такая.
[03:47:15.960 --> 03:47:18.960]  Мы пока предположили, правда, еще и так не явно,
[03:47:18.960 --> 03:47:22.960]  что W не является потомком w.
[03:47:22.960 --> 03:47:25.960]  А в принципе такое могло быть, кстати.
[03:47:25.960 --> 03:47:28.960]  Вот. Ну, мы ж могли там спуститься в потомка,
[03:47:28.960 --> 03:47:30.960]  а потом по обратным ребрам подскакать.
[03:47:30.960 --> 03:47:32.960]  Вот. Значит, смотрите.
[03:47:32.960 --> 03:47:34.960]  Но пусть она потомком w не является,
[03:47:34.960 --> 03:47:36.960]  этот случай мы потом отдельно разберем.
[03:47:36.960 --> 03:47:39.960]  Тогда, смотрите, рассмотрим этот путь.
[03:47:39.960 --> 03:47:44.960]  Смотрите. Рассмотрим на этом пути первую вершину,
[03:47:44.960 --> 03:47:51.960]  которая является предком v, но не является предком w.
[03:47:51.960 --> 03:47:53.960]  Вот. Понятно, да?
[03:47:55.960 --> 03:47:59.960]  Нет, первая вершина – это не она, это вот эта она.
[03:47:59.960 --> 03:48:02.960]  Вот. Ну, типа мы говорим, что после нее путь мы даже
[03:48:02.960 --> 03:48:06.960]  для удобства заменим на просто спуск от ука до ве.
[03:48:06.960 --> 03:48:09.960]  Утверждение.
[03:48:09.960 --> 03:48:15.960]  Тогда вытекает утверждение, что все вот эти вот вершины,
[03:48:15.960 --> 03:48:18.960]  все вершины на пути от этого s до w до ука
[03:48:18.960 --> 03:48:22.960]  по таймыну больше, чем ука.
[03:48:26.960 --> 03:48:28.960]  Почему так?
[03:48:28.960 --> 03:48:31.960]  Потому что предположим, что найдется меньше.
[03:48:31.960 --> 03:48:39.960]  Тогда на этом пути найдется собственный предок вершины ука.
[03:48:39.960 --> 03:48:42.960]  Ну, если вот там промотать чуть-чуть.
[03:48:42.960 --> 03:48:45.960]  Ну, во-первых, у них найдется общий предок на этом пути.
[03:48:45.960 --> 03:48:50.960]  Ну, вот, во-первых, а этот общий предок будет автоматически
[03:48:50.960 --> 03:48:52.960]  собственным предком ука.
[03:48:52.960 --> 03:48:54.960]  Но кто это может быть?
[03:48:54.960 --> 03:48:57.960]  Вот на этой части, из этой части предков, из этого пути
[03:48:57.960 --> 03:48:59.960]  он быть не может по определению ука.
[03:48:59.960 --> 03:49:01.960]  Потому что ука – это первая такая.
[03:49:01.960 --> 03:49:06.960]  Но из этой части он тоже быть не может. Почему?
[03:49:06.960 --> 03:49:09.960]  Потому что все эти вершины являются предками w, как следствие,
[03:49:09.960 --> 03:49:12.960]  по таймыну они тоже меньше, чем w.
[03:49:12.960 --> 03:49:16.960]  А у нас таких вершин на синем пути не было, в принципе.
[03:49:16.960 --> 03:49:18.960]  Вот, да.
[03:49:18.960 --> 03:49:21.960]  То есть, вывод.
[03:49:21.960 --> 03:49:24.960]  То есть, вывод очень простой.
[03:49:24.960 --> 03:49:28.960]  То есть, это означает...
[03:49:28.960 --> 03:49:30.960]  Ну, вот.
[03:49:30.960 --> 03:49:34.960]  То есть, это означает, что s до w является кандидатом
[03:49:34.960 --> 03:49:38.960]  в полудоминаторы для ука.
[03:49:38.960 --> 03:49:40.960]  Это что означает?
[03:49:40.960 --> 03:49:46.960]  Это означает, что полудоминатор ука находится либо в s-доме,
[03:49:46.960 --> 03:49:49.960]  либо выше.
[03:49:49.960 --> 03:49:53.960]  Но если бы у него полудоминатор был выше,
[03:49:53.960 --> 03:49:57.960]  то тогда я утверждаю, что и полудоминатор от w оказался бы выше,
[03:49:57.960 --> 03:50:01.960]  потому что мы бы из этой вершины уже тут обошли бы...
[03:50:01.960 --> 03:50:03.960]  То есть, нашли бы вот этот вот путь
[03:50:03.960 --> 03:50:06.960]  по вершинам, у которых таймин больше, чем w.
[03:50:06.960 --> 03:50:08.960]  Понятно, да?
[03:50:08.960 --> 03:50:11.960]  Так, еще не совсем еще умерли?
[03:50:11.960 --> 03:50:12.960]  Нет, нет.
[03:50:12.960 --> 03:50:13.960]  Точно?
[03:50:13.960 --> 03:50:14.960]  Да.
[03:50:14.960 --> 03:50:15.960]  Вот.
[03:50:15.960 --> 03:50:17.960]  Не совсем еще умерли.
[03:50:17.960 --> 03:50:20.960]  Я вообще говорил, есть еще один случай, когда у нас w находится по дереве w,
[03:50:20.960 --> 03:50:23.960]  но он рассматривается очень так же, там все рубожит тоже.
[03:50:23.960 --> 03:50:25.960]  Сейчас, чего, чего, чего?
[03:50:25.960 --> 03:50:27.960]  У нас формально w может быть по дереве w.
[03:50:27.960 --> 03:50:32.960]  Да, единственное только минус в этом доказательстве,
[03:50:32.960 --> 03:50:36.960]  что w может оказаться, в принципе, и в под дереве w.
[03:50:37.960 --> 03:50:38.960]  Да?
[03:50:38.960 --> 03:50:41.960]  Нет, ну, на самом деле, да, картинка будет то же самое,
[03:50:41.960 --> 03:50:44.960]  просто эта лцашка окажется w.
[03:50:44.960 --> 03:50:46.960]  Ну, давайте я просто то же самое...
[03:50:46.960 --> 03:50:50.960]  Я сейчас просто нарисую то же самое, давайте, чтоб просто сомнений не было.
[03:50:50.960 --> 03:50:54.960]  То есть, вот как-то вот так вот это тогда окажется.
[03:51:00.960 --> 03:51:05.960]  Да, вот тот прикол, вроде больше нигде не пользовались, да.
[03:51:05.960 --> 03:51:08.960]  Да, на самом деле, ладно, давайте в качестве упражнения, да.
[03:51:08.960 --> 03:51:11.960]  Можно проследить предыдущие доказательства
[03:51:11.960 --> 03:51:14.960]  и убедиться, что если этим лца оказался, собственно, w,
[03:51:14.960 --> 03:51:16.960]  то ничего не меняется.
[03:51:16.960 --> 03:51:17.960]  Да.
[03:51:17.960 --> 03:51:19.960]  Кто-то это уже сделал, да.
[03:51:19.960 --> 03:51:21.960]  Вот.
[03:51:21.960 --> 03:51:23.960]  Ну, да.
[03:51:23.960 --> 03:51:27.960]  Так что, да, можно соответственно проследить.
[03:51:27.960 --> 03:51:31.960]  Так что, в общем-то, тирема оказалась несложная.
[03:51:31.960 --> 03:51:33.960]  Тирема оказалась несложная.
[03:51:33.960 --> 03:51:36.960]  И это означает маленькую приятную веру.
[03:51:36.960 --> 03:51:37.960]  Ну, вот.
[03:51:37.960 --> 03:51:39.960]  Ну, то есть, это означает, что тирема доказана
[03:51:39.960 --> 03:51:43.960]  и, как следствие, алгоритм, который сводит нас к чисто линк эвалом,
[03:51:43.960 --> 03:51:45.960]  на лицо.
[03:51:47.960 --> 03:51:49.960]  Вот.
[03:51:49.960 --> 03:51:51.960]  Так, сколько у нас времени осталось?
[03:51:51.960 --> 03:51:53.960]  Сколько?
[03:51:53.960 --> 03:51:54.960]  Десять.
[03:51:54.960 --> 03:51:55.960]  Десять?
[03:51:55.960 --> 03:51:57.960]  Да, двадцать минут. Сколько? Десять.
[03:51:57.960 --> 03:51:58.960]  Пятнадцать.
[03:51:58.960 --> 03:52:01.960]  А, пятнадцать. Ну, в общем-то, как тот же, на самом деле, да.
[03:52:01.960 --> 03:52:03.960]  Вот.
[03:52:03.960 --> 03:52:05.960]  Нет, тут вопрос как бы отдельный.
[03:52:05.960 --> 03:52:07.960]  Просто, да, что тогда из этого...
[03:52:07.960 --> 03:52:09.960]  Что тогда за оставшееся время рассказать?
[03:52:13.960 --> 03:52:15.960]  Нет, смотрите, нет, просто...
[03:52:15.960 --> 03:52:16.960]  Ну, да.
[03:52:16.960 --> 03:52:17.960]  Ну, ладно.
[03:52:17.960 --> 03:52:19.960]  Нет, выбор у меня простой.
[03:52:19.960 --> 03:52:21.960]  Либо сейчас добить, на самом деле, двасатые...
[03:52:21.960 --> 03:52:23.960]  Значит, двасатые эллеровые.
[03:52:23.960 --> 03:52:25.960]  Либо...
[03:52:25.960 --> 03:52:28.960]  Ну, просто за оставшееся время можно проговорить про линк эвал
[03:52:28.960 --> 03:52:30.960]  и, собственно, доказать тирема о том,
[03:52:30.960 --> 03:52:33.960]  что если вы делаете это просто тупо сжатием путей,
[03:52:33.960 --> 03:52:35.960]  то это как бы суммарно будет работать
[03:52:35.960 --> 03:52:37.960]  за n плюс m на логарифум n.
[03:52:38.960 --> 03:52:39.960]  Вот.
[03:52:39.960 --> 03:52:40.960]  Ну, второе...
[03:52:40.960 --> 03:52:42.960]  Вот почему-то соблазнительно сделать именно второе,
[03:52:42.960 --> 03:52:44.960]  но я, пожалуй, не буду этого делать,
[03:52:44.960 --> 03:52:48.960]  потому что с СНМ-ом нам все равно придется еще разговаривать.
[03:52:49.960 --> 03:52:50.960]  Нет.
[03:52:50.960 --> 03:52:52.960]  Ну, как минимум... Нет, смотрите.
[03:52:52.960 --> 03:52:53.960]  Что мы заведомо сделаем?
[03:52:53.960 --> 03:52:55.960]  Это докажем, что СНМ работает,
[03:52:55.960 --> 03:52:56.960]  а, за логарифом,
[03:52:56.960 --> 03:52:58.960]  б, за лог-звездочка.
[03:52:58.960 --> 03:52:59.960]  Вот.
[03:52:59.960 --> 03:53:01.960]  Это относительно простые доказательства, да.
[03:53:01.960 --> 03:53:03.960]  Что мне хотелось бы сделать дальше,
[03:53:03.960 --> 03:53:06.960]  это, конечно, доказать про обратную функцию от тирмана.
[03:53:06.960 --> 03:53:07.960]  Вот.
[03:53:08.960 --> 03:53:10.960]  Вот так как эта единая работа большая,
[03:53:10.960 --> 03:53:12.960]  то, пожалуй, не будем это делать,
[03:53:12.960 --> 03:53:14.960]  а лучше, действительно, сейчас...
[03:53:14.960 --> 03:53:16.960]  Соответственно, скажем так, в принципе,
[03:53:16.960 --> 03:53:18.960]  про дерево доминатора, в общем-то, мы обсудили все.
[03:53:18.960 --> 03:53:20.960]  Единственное, я только обсужу, что вот эти вот объединения,
[03:53:20.960 --> 03:53:22.960]  как я уже сказал, то есть делаются...
[03:53:22.960 --> 03:53:24.960]  То есть фактически алгоритм строится в два DFS-а.
[03:53:24.960 --> 03:53:26.960]  Причем первый DFS вам нужен фактически
[03:53:26.960 --> 03:53:29.960]  только для того, чтобы определить порядок таймынов.
[03:53:29.960 --> 03:53:31.960]  То есть определить порядок таймынов,
[03:53:31.960 --> 03:53:33.960]  и там, может быть, для каждой вершины
[03:53:33.960 --> 03:53:35.960]  еще и там описать все входящие ребра.
[03:53:35.960 --> 03:53:37.960]  Вот.
[03:53:37.960 --> 03:53:38.960]  А дальше...
[03:53:38.960 --> 03:53:40.960]  Ну ладно, второй DFS даже не нужен,
[03:53:40.960 --> 03:53:42.960]  потому что дальше вы просто перебираете вершины
[03:53:42.960 --> 03:53:44.960]  в порядке убывания таймына
[03:53:44.960 --> 03:53:45.960]  и насчитываете...
[03:53:45.960 --> 03:53:47.960]  И с одной стороны насчитываете айдомы,
[03:53:47.960 --> 03:53:49.960]  используя бакеты.
[03:53:49.960 --> 03:53:51.960]  А с другой стороны...
[03:53:51.960 --> 03:53:55.960]  А с другой стороны перебираете кандидаты вездомы на будущее.
[03:53:55.960 --> 03:53:57.960]  Вот.
[03:53:57.960 --> 03:53:59.960]  Ну, точнее так, прямо сейчас
[03:53:59.960 --> 03:54:01.960]  насчитываете айдомы,
[03:54:01.960 --> 03:54:03.960]  и прямо в процессе, значит, соответственно,
[03:54:03.960 --> 03:54:05.960]  в бакет этого айдома W
[03:54:05.960 --> 03:54:07.960]  перекидываете W.
[03:54:07.960 --> 03:54:09.960]  То есть таким образом,
[03:54:09.960 --> 03:54:11.960]  когда вы дойдете до конца этой вершины,
[03:54:11.960 --> 03:54:13.960]  то, в общем-то, там уже все в порядке будет.
[03:54:13.960 --> 03:54:15.960]  То есть дойдет до этой вершины,
[03:54:15.960 --> 03:54:17.960]  там уже полный бакет сформирован будет.
[03:54:17.960 --> 03:54:19.960]  Получается такой там красивый алгоритм,
[03:54:19.960 --> 03:54:21.960]  сводящий все вот к этому.
[03:54:21.960 --> 03:54:23.960]  Ну, в реальности понятно.
[03:54:23.960 --> 03:54:25.960]  В олимпиадном коде понятно, что легче там написать
[03:54:25.960 --> 03:54:27.960]  дерево, отрезка, все это за N-логенчик.
[03:54:27.960 --> 03:54:29.960]  Потому что вот этот линк Yawal,
[03:54:29.960 --> 03:54:31.960]  там это не самая тривиальная структура.
[03:54:31.960 --> 03:54:33.960]  Ну, вы, конечно, можете
[03:54:33.960 --> 03:54:35.960]  ее написать тривиально, сожжать им путей,
[03:54:35.960 --> 03:54:37.960]  это уже будет адекватно работать.
[03:54:37.960 --> 03:54:39.960]  Но если вы там чуть-чуть пошаманите,
[03:54:39.960 --> 03:54:41.960]  но это мы отдельно поговорим как.
[03:54:41.960 --> 03:54:43.960]  Вот, соответственно, то там можно
[03:54:43.960 --> 03:54:45.960]  и обратную функцию кирмана получить.
[03:54:45.960 --> 03:54:47.960]  Вот. Никогда не слышал,
[03:54:47.960 --> 03:54:49.960]  честно говоря, чтобы в олимпиадах от вас
[03:54:49.960 --> 03:54:51.960]  требовали прям реально за кирма написать.
[03:54:51.960 --> 03:54:53.960]  Ну, скажи так, я на Кодфорсе
[03:54:53.960 --> 03:54:55.960]  видел пару задач на дерево доминаторов,
[03:54:55.960 --> 03:54:57.960]  но там, по-моему, везде там,
[03:54:57.960 --> 03:54:59.960]  собственно, там от вас там
[03:54:59.960 --> 03:55:01.960]  быстрее, чем за N-логен
[03:55:01.960 --> 03:55:03.960]  от вас не хотели.
[03:55:05.960 --> 03:55:07.960]  Вот. Теперь.
[03:55:11.960 --> 03:55:13.960]  Да?
[03:55:13.960 --> 03:55:15.960]  Ну, так-то да. Так-то да.
[03:55:15.960 --> 03:55:17.960]  Ну, обычно, да. Обычно мы с ним точка основного решения,
[03:55:17.960 --> 03:55:19.960]  в общем-то, не в кирман укладывается.
[03:55:19.960 --> 03:55:21.960]  В кирманы не укладывается, поэтому не глобально.
[03:55:21.960 --> 03:55:23.960]  Вот.
[03:55:23.960 --> 03:55:25.960]  Значит, оставшие все время
[03:55:25.960 --> 03:55:27.960]  поговорим. Ну, во-первых, давайте поговорим
[03:55:27.960 --> 03:55:29.960]  о задаче 2-сад быстренько.
[03:55:29.960 --> 03:55:31.960]  Ну, конечно, быстренько поговорим, но
[03:55:31.960 --> 03:55:33.960]  об чем у нас задача?
[03:55:33.960 --> 03:55:35.960]  Ну, задача формулируется так.
[03:55:35.960 --> 03:55:37.960]  Это задача из бот-логики.
[03:55:37.960 --> 03:55:39.960]  То есть задача вида.
[03:55:39.960 --> 03:55:41.960]  Дано N-переменных
[03:55:41.960 --> 03:55:43.960]  и дана на них какая-то вот такая
[03:55:43.960 --> 03:55:45.960]  булева формула.
[03:55:45.960 --> 03:55:47.960]  В каждой скобочке находится
[03:55:47.960 --> 03:55:49.960]  ровно две переменные
[03:55:49.960 --> 03:55:51.960]  или их отрицание.
[03:55:51.960 --> 03:55:53.960]  Вот. Как-то вот так вот это.
[03:55:53.960 --> 03:55:55.960]  Там х2 или не х3.
[03:55:55.960 --> 03:55:57.960]  Ну, вот что-нибудь такое.
[03:55:57.960 --> 03:55:59.960]  Или там не х1
[03:55:59.960 --> 03:56:01.960]  или не х4.
[03:56:01.960 --> 03:56:03.960]  Ну и так далее.
[03:56:03.960 --> 03:56:05.960]  Всего таких там, допустим,
[03:56:05.960 --> 03:56:07.960]  N-переменных и на них там
[03:56:07.960 --> 03:56:09.960]  M-скобочек.
[03:56:09.960 --> 03:56:11.960]  Внимание, вопрос.
[03:56:11.960 --> 03:56:13.960]  Выполнима ли
[03:56:13.960 --> 03:56:15.960]  эта формула?
[03:56:15.960 --> 03:56:17.960]  Ну, конкретно это, скорее всего,
[03:56:17.960 --> 03:56:19.960]  да, действительно. Хотя все зависит
[03:56:19.960 --> 03:56:21.960]  от того, что там за многоточием.
[03:56:21.960 --> 03:56:23.960]  Да, если да.
[03:56:23.960 --> 03:56:25.960]  Но вообще общая задача.
[03:56:25.960 --> 03:56:27.960]  Выполнима ли формула? То есть существует ли
[03:56:27.960 --> 03:56:29.960]  такие, можно ли подставить такие
[03:56:29.960 --> 03:56:31.960]  булевые значения по всем переменам, чтобы
[03:56:31.960 --> 03:56:33.960]  это было true?
[03:56:33.960 --> 03:56:35.960]  Да или нет?
[03:56:37.960 --> 03:56:39.960]  Сейчас.
[03:56:39.960 --> 03:56:41.960]  Это называется два сад.
[03:56:41.960 --> 03:56:43.960]  Почему это называется два сад?
[03:56:43.960 --> 03:56:45.960]  Сад от слова
[03:56:45.960 --> 03:56:47.960]  satisfiable.
[03:56:51.960 --> 03:56:53.960]  Ну, в принципе, да,
[03:56:53.960 --> 03:56:55.960]  удовлетворение, satisfaction.
[03:56:55.960 --> 03:56:57.960]  Это от него.
[03:56:57.960 --> 03:56:59.960]  Но почему надо это упомянуть?
[03:56:59.960 --> 03:57:01.960]  Потому что эта задача является на самом деле
[03:57:01.960 --> 03:57:03.960]  младшим братом,
[03:57:03.960 --> 03:57:05.960]  или младшей сестрой, не знаю,
[03:57:05.960 --> 03:57:07.960]  знаменитой задачей три сад.
[03:57:07.960 --> 03:57:09.960]  Три сад.
[03:57:09.960 --> 03:57:11.960]  Тоже самое,
[03:57:11.960 --> 03:57:13.960]  только тут
[03:57:13.960 --> 03:57:15.960]  в скобочках находится
[03:57:15.960 --> 03:57:17.960]  по три.
[03:57:17.960 --> 03:57:19.960]  Просто в чем фишка? Фишка заключает
[03:57:19.960 --> 03:57:21.960]  в том, что эта задача
[03:57:21.960 --> 03:57:23.960]  в теории
[03:57:23.960 --> 03:57:25.960]  сложности вычислений занимает просто центральное место.
[03:57:25.960 --> 03:57:27.960]  Потому что
[03:57:27.960 --> 03:57:29.960]  это просто едва ли не главная
[03:57:29.960 --> 03:57:31.960]  и полная задача.
[03:57:31.960 --> 03:57:33.960]  Вот.
[03:57:33.960 --> 03:57:35.960]  Ну, вкратце,
[03:57:35.960 --> 03:57:37.960]  есть знаменитая проблема,
[03:57:37.960 --> 03:57:39.960]  верно, лишь что P не равно NP.
[03:57:39.960 --> 03:57:41.960]  Ну, что такое PNP?
[03:57:41.960 --> 03:57:43.960]  Ну, ладно,
[03:57:43.960 --> 03:57:45.960]  если не вдаваться
[03:57:45.960 --> 03:57:47.960]  во всякие совсем тонкости про машинчуринга
[03:57:47.960 --> 03:57:49.960]  и так далее, то суть такая.
[03:57:49.960 --> 03:57:51.960]  Мы говорим, что
[03:57:51.960 --> 03:57:53.960]  есть задачи, которые решаются
[03:57:53.960 --> 03:57:55.960]  за полиномиальное время.
[03:57:55.960 --> 03:57:57.960]  А есть задачи,
[03:57:57.960 --> 03:57:59.960]  например, которые
[03:57:59.960 --> 03:58:01.960]  теряются за полиномиальное время.
[03:58:01.960 --> 03:58:03.960]  Типичный пример,
[03:58:03.960 --> 03:58:05.960]  например, это задача о раскраске графа
[03:58:05.960 --> 03:58:07.960]  в три цвета. То есть данный ориентированный граф.
[03:58:07.960 --> 03:58:09.960]  Можно ли его раскрасить в три цвета,
[03:58:09.960 --> 03:58:11.960]  так чтобы любой ребро
[03:58:11.960 --> 03:58:13.960]  соединяло вершины разных цветов?
[03:58:13.960 --> 03:58:15.960]  Просто да или нет.
[03:58:15.960 --> 03:58:17.960]  Эта задача принадлежит классу
[03:58:17.960 --> 03:58:19.960]  NP.
[03:58:19.960 --> 03:58:21.960]  По определению,
[03:58:21.960 --> 03:58:23.960]  это означает следующее, что если ответ
[03:58:23.960 --> 03:58:25.960]  да, то существует
[03:58:25.960 --> 03:58:27.960]  сертификат,
[03:58:27.960 --> 03:58:29.960]  который
[03:58:29.960 --> 03:58:31.960]  доказывает, что ответ на эту задачу
[03:58:31.960 --> 03:58:33.960]  да. В данном случае просто раскраска.
[03:58:33.960 --> 03:58:35.960]  Если вам дана раскраска,
[03:58:35.960 --> 03:58:37.960]  вы можете проверить, хороша ли эта раскраска
[03:58:37.960 --> 03:58:39.960]  или плохая.
[03:58:39.960 --> 03:58:41.960]  Или
[03:58:41.960 --> 03:58:43.960]  соответственно задача 3-сад.
[03:58:43.960 --> 03:58:45.960]  Это задача,
[03:58:45.960 --> 03:58:47.960]  если да, то вам существует
[03:58:47.960 --> 03:58:49.960]  просто набор из 0 и 1,
[03:58:49.960 --> 03:58:51.960]  который вы можете тупо проверить за полиномиальное время.
[03:58:53.960 --> 03:58:55.960]  Обратите внимание, в этой теории, кстати,
[03:58:55.960 --> 03:58:57.960]  если это полиномиальное, то сплевать за какое конкретно.
[03:58:57.960 --> 03:58:59.960]  Оно может быть там n в пятой,
[03:58:59.960 --> 03:59:01.960]  n в сотой, n в миллионной, какое угодно.
[03:59:01.960 --> 03:59:03.960]  Главное, чтобы
[03:59:03.960 --> 03:59:05.960]  n в степени константа.
[03:59:05.960 --> 03:59:07.960]  Если константа там 57 в степени 179,
[03:59:07.960 --> 03:59:09.960]  никого не волнует.
[03:59:09.960 --> 03:59:11.960]  Потому что это все равно быстрее,
[03:59:11.960 --> 03:59:13.960]  чем 2 в степени n.
[03:59:13.960 --> 03:59:15.960]  Да, на практике нет,
[03:59:15.960 --> 03:59:17.960]  реально, но теоретически да.
[03:59:19.960 --> 03:59:21.960]  И соответственно ключевой вопрос,
[03:59:21.960 --> 03:59:23.960]  они являются,
[03:59:23.960 --> 03:59:25.960]  являются ли эти классы задач
[03:59:25.960 --> 03:59:27.960]  одинаковыми?
[03:59:29.960 --> 03:59:31.960]  То есть существуют ли задачи,
[03:59:31.960 --> 03:59:33.960]  которые
[03:59:33.960 --> 03:59:35.960]  являются,
[03:59:35.960 --> 03:59:37.960]  которые лежат в классе mp,
[03:59:37.960 --> 03:59:39.960]  но при этом не решаются за полиномиальное время?
[03:59:43.960 --> 03:59:45.960]  Нет, так вот, наука, проблема
[03:59:45.960 --> 03:59:47.960]  пока стоит, она открыта.
[03:59:47.960 --> 03:59:49.960]  А вы
[03:59:49.960 --> 03:59:51.960]  уже говорили об этом?
[03:59:51.960 --> 03:59:53.960]  А, господи,
[03:59:53.960 --> 03:59:55.960]  что вы здесь?
[03:59:55.960 --> 03:59:57.960]  Нет,
[03:59:57.960 --> 03:59:59.960]  если я то, что говорю, вам уже рассказывали,
[03:59:59.960 --> 04:00:01.960]  то не будем тратить время.
[04:00:01.960 --> 04:00:03.960]  Обычно просто рассказывается
[04:00:03.960 --> 04:00:05.960]  на сложности вычисления.
[04:00:05.960 --> 04:00:07.960]  Вам ведут более аккуратно,
[04:00:07.960 --> 04:00:09.960]  что там конкретно
[04:00:09.960 --> 04:00:11.960]  машину тюринга и так далее.
[04:00:11.960 --> 04:00:13.960]  Но
[04:00:13.960 --> 04:00:15.960]  теория там дошла до следующего.
[04:00:15.960 --> 04:00:17.960]  Потому что там существует в классе mp
[04:00:17.960 --> 04:00:19.960]  самые сложные задачи.
[04:00:19.960 --> 04:00:21.960]  Они называются, по-моему, mp трудные.
[04:00:21.960 --> 04:00:23.960]  Но нет, есть понятие mp трудное,
[04:00:23.960 --> 04:00:25.960]  есть понятие mp полное,
[04:00:25.960 --> 04:00:27.960]  это не совсем одно и то же.
[04:00:27.960 --> 04:00:29.960]  Но суть там говорится такое, что
[04:00:29.960 --> 04:00:31.960]  если p не равно mp,
[04:00:31.960 --> 04:00:33.960]  то тогда в mp без p лежат
[04:00:33.960 --> 04:00:35.960]  вот эти mp трудные задачи.
[04:00:35.960 --> 04:00:37.960]  Потому что любая mp задача
[04:00:37.960 --> 04:00:39.960]  сводится к mp трудной.
[04:00:39.960 --> 04:00:41.960]  Так вот, одной из таких задач
[04:00:41.960 --> 04:00:43.960]  является задача 3.sat, а также про раскраски
[04:00:43.960 --> 04:00:45.960]  и так далее.
[04:00:45.960 --> 04:00:47.960]  Но там несколько таких задач.
[04:00:47.960 --> 04:00:49.960]  Поэтому вот эту задачу, если вы научитесь
[04:00:49.960 --> 04:00:51.960]  решать хотя бы за m в миллионной,
[04:00:51.960 --> 04:00:53.960]  то как бы человечество будет
[04:00:53.960 --> 04:00:55.960]  очень-очень-очень сильно благодарно.
[04:00:57.960 --> 04:00:59.960]  И это тоже,
[04:00:59.960 --> 04:01:01.960]  потому что какую-то премию тюринга
[04:01:01.960 --> 04:01:03.960]  вам обязательно выручат.
[04:01:05.960 --> 04:01:07.960]  Другой вопрос у человека,
[04:01:07.960 --> 04:01:09.960]  что пока ничего в этом смысле не умеет.
[04:01:09.960 --> 04:01:11.960]  А вот 2sat, это ее младший брат,
[04:01:11.960 --> 04:01:13.960]  и он решается
[04:01:13.960 --> 04:01:15.960]  не просто за полюном,
[04:01:15.960 --> 04:01:17.960]  а тупо за линию.
[04:01:19.960 --> 04:01:21.960]  Но я не знаю, алгоритм это Тарьяна
[04:01:21.960 --> 04:01:23.960]  или нет, но решение
[04:01:23.960 --> 04:01:25.960]  оказывается неожиданным.
[04:01:25.960 --> 04:01:27.960]  Но давайте его проговорим аккуратненько,
[04:01:27.960 --> 04:01:29.960]  потому что там мало ли
[04:01:29.960 --> 04:01:31.960]  технических деталей. Идея такая,
[04:01:31.960 --> 04:01:33.960]  заведем 2n переменных,
[04:01:33.960 --> 04:01:35.960]  каждый из которых соответствует своей переменной
[04:01:35.960 --> 04:01:37.960]  или ее отрицанию.
[04:01:39.960 --> 04:01:41.960]  Вот 2n переменных всего.
[04:01:41.960 --> 04:01:43.960]  И дальше
[04:01:43.960 --> 04:01:45.960]  аккуратная идея такая.
[04:01:45.960 --> 04:01:47.960]  Мы теперь замечаем,
[04:01:47.960 --> 04:01:49.960]  что на самом деле x1
[04:01:49.960 --> 04:01:51.960]  или x2 это эквивалентно
[04:01:51.960 --> 04:01:53.960]  такой формуле,
[04:01:53.960 --> 04:01:55.960]  как что из не x1 следует x2.
[04:01:59.960 --> 04:02:01.960]  На самом деле да, это
[04:02:01.960 --> 04:02:03.960]  эквивалентно еще вот этому. Из не x2
[04:02:03.960 --> 04:02:05.960]  следует x1.
[04:02:07.960 --> 04:02:09.960]  Предлагается сделать так.
[04:02:09.960 --> 04:02:11.960]  Для такой скобочки мы просто добавим
[04:02:11.960 --> 04:02:13.960]  вот такие 2 ребра, ориентированных в граф.
[04:02:15.960 --> 04:02:17.960]  Вот, x3 и x4.
[04:02:17.960 --> 04:02:19.960]  Но тут соответственно значит,
[04:02:19.960 --> 04:02:21.960]  из не x3 будет следовать не x4,
[04:02:21.960 --> 04:02:23.960]  а из x4 следовать x3.
[04:02:23.960 --> 04:02:25.960]  Так, x2 не x3,
[04:02:25.960 --> 04:02:27.960]  но то же самое.
[04:02:29.960 --> 04:02:31.960]  Дальше там что будет? Из x1
[04:02:31.960 --> 04:02:33.960]  у нас теперь будет следовать не x4,
[04:02:33.960 --> 04:02:35.960]  а из x4 следует вот.
[04:02:35.960 --> 04:02:37.960]  Вот по такому принципу рисуем ребра.
[04:02:39.960 --> 04:02:41.960]  Теперь идея такая.
[04:02:41.960 --> 04:02:43.960]  Не получилось ли у нас в процессе,
[04:02:43.960 --> 04:02:45.960]  что, ну потому что заметим,
[04:02:45.960 --> 04:02:47.960]  что если из вершины в вершину есть путь,
[04:02:47.960 --> 04:02:49.960]  значит имеет место следствия,
[04:02:49.960 --> 04:02:51.960]  по цепочке.
[04:02:51.960 --> 04:02:53.960]  Поэтому если оказалось,
[04:02:53.960 --> 04:02:55.960]  что случайно из x1 следует
[04:02:55.960 --> 04:02:57.960]  допустим отрицание и наоборот,
[04:02:57.960 --> 04:02:59.960]  то тогда из этого следует,
[04:02:59.960 --> 04:03:01.960]  что формула невыполнима уже заведомо.
[04:03:01.960 --> 04:03:03.960]  Как это выяснить? А очень просто.
[04:03:03.960 --> 04:03:05.960]  Ну, по крайней мере сделать такую проверку очень просто.
[04:03:05.960 --> 04:03:07.960]  Давайте в этом графе найдем компоненты
[04:03:07.960 --> 04:03:09.960]  сильной связности и проверим,
[04:03:09.960 --> 04:03:11.960]  не оказались ли какая-то вершина
[04:03:11.960 --> 04:03:13.960]  в своем отрицании в одной компоненте.
[04:03:13.960 --> 04:03:15.960]  Если оказалось, значит фейл сразу.
[04:03:15.960 --> 04:03:17.960]  Более продвинутая утверждение
[04:03:17.960 --> 04:03:19.960]  говорит о том, что если не оказалось,
[04:03:19.960 --> 04:03:21.960]  то тогда, значит,
[04:03:21.960 --> 04:03:23.960]  формула выполнима
[04:03:23.960 --> 04:03:25.960]  и более того достаточно легко
[04:03:25.960 --> 04:03:27.960]  привести, даже построить
[04:03:27.960 --> 04:03:29.960]  конкретный пример.
[04:03:29.960 --> 04:03:31.960]  Пример строится так.
[04:03:31.960 --> 04:03:33.960]  Ну, во-первых,
[04:03:33.960 --> 04:03:35.960]  эти компоненты
[04:03:35.960 --> 04:03:37.960]  с сильной связностью можно, как мы уже помним,
[04:03:37.960 --> 04:03:39.960]  топологически отсаксировать.
[04:03:39.960 --> 04:03:41.960]  Логично, да?
[04:03:41.960 --> 04:03:43.960]  Так вот, рассмотрим
[04:03:43.960 --> 04:03:45.960]  самую, допустим, правую половину.
[04:03:45.960 --> 04:03:47.960]  То есть правую часть.
[04:03:47.960 --> 04:03:49.960]  Смотрите.
[04:03:49.960 --> 04:03:51.960]  Значит, смотрите,
[04:03:51.960 --> 04:03:53.960]  в этом множестве нету
[04:03:53.960 --> 04:03:55.960]  ни одной переменной
[04:03:55.960 --> 04:03:57.960]  вместе со своим отрицанием.
[04:03:57.960 --> 04:03:59.960]  Тогда идея такая. А давайте-ка
[04:03:59.960 --> 04:04:01.960]  всем этим вершинкам
[04:04:01.960 --> 04:04:03.960]  присвоим true.
[04:04:05.960 --> 04:04:07.960]  Тогда автоматически найдется
[04:04:07.960 --> 04:04:09.960]  еще одна компонента
[04:04:09.960 --> 04:04:11.960]  сильной связности, которая содержит
[04:04:11.960 --> 04:04:13.960]  в точности отрицание всего вот этого.
[04:04:13.960 --> 04:04:15.960]  Логично, да?
[04:04:15.960 --> 04:04:17.960]  Прям в точности отрицания.
[04:04:17.960 --> 04:04:19.960]  И более того, из этой вершины
[04:04:19.960 --> 04:04:21.960]  ничего не выходит, а в эту вершину
[04:04:21.960 --> 04:04:23.960]  ничего не входит.
[04:04:23.960 --> 04:04:25.960]  Да, тут автоматически тут тоже
[04:04:25.960 --> 04:04:27.960]  нули, вот это все синхронно.
[04:04:27.960 --> 04:04:29.960]  Тогда я утверждаю, что все стрелочки,
[04:04:29.960 --> 04:04:31.960]  связанные с этими вершинами,
[04:04:31.960 --> 04:04:33.960]  они автоматически удовлетворены.
[04:04:33.960 --> 04:04:35.960]  Потому что либо это внутренние стрелочки,
[04:04:35.960 --> 04:04:37.960]  из один следует один, из ноль
[04:04:37.960 --> 04:04:39.960]  следует ноль.
[04:04:39.960 --> 04:04:41.960]  Либо это исходящие из нуля,
[04:04:41.960 --> 04:04:43.960]  все исходящие из нуля true
[04:04:43.960 --> 04:04:45.960]  и все входящие в один true.
[04:04:45.960 --> 04:04:47.960]  То есть получается мы
[04:04:47.960 --> 04:04:49.960]  выкидываем эти компоненты,
[04:04:49.960 --> 04:04:51.960]  из рассматривших они уже удовлетворены.
[04:04:51.960 --> 04:04:53.960]  Чтобы мы там дальше не ставили.
[04:04:53.960 --> 04:04:55.960]  Но теперь дальше что мы делаем?
[04:04:55.960 --> 04:04:57.960]  Идем дальше, идем здесь, идем в следующую
[04:04:57.960 --> 04:04:59.960]  вершину, которая тут свободна,
[04:04:59.960 --> 04:05:01.960]  тоже тут рисуем один, тут рисуем ноль,
[04:05:01.960 --> 04:05:03.960]  потом идем в следующую, тут рисуем один, тут рисуем ноль.
[04:05:03.960 --> 04:05:05.960]  Получается,
[04:05:05.960 --> 04:05:07.960]  короче, за линию мы победили.
[04:05:09.960 --> 04:05:11.960]  То есть так решается задача 20.
[04:05:13.960 --> 04:05:15.960]  Ну, тут в общем-то несложно.
[04:05:17.960 --> 04:05:19.960]  Так, есть ли тут какие-то вопросы?
[04:05:19.960 --> 04:05:21.960]  Так, ну тут нет.
[04:05:21.960 --> 04:05:23.960]  Наверное, подробнее рассматривать нет смысла,
[04:05:23.960 --> 04:05:25.960]  сколько у нас там времени.
[04:05:25.960 --> 04:05:27.960]  Ну, пока нас не выгоняют.
[04:05:27.960 --> 04:05:29.960]  Ну, давайте так.
[04:05:29.960 --> 04:05:31.960]  Нет, вот дальнейшее все будет зависеть
[04:05:31.960 --> 04:05:33.960]  от другого. Скажите, пожалуйста,
[04:05:33.960 --> 04:05:35.960]  а что такое Эллеров цикл, и когда он существует,
[04:05:35.960 --> 04:05:37.960]  вы изучали на какой-нибудь дискретке?
[04:05:37.960 --> 04:05:39.960]  Или там тачешки?
[04:05:41.960 --> 04:05:43.960]  Нет, ну в школе-то было.
[04:05:43.960 --> 04:05:45.960]  Ну, давайте так.
[04:05:45.960 --> 04:05:47.960]  Так, давайте, кто знает, что такое Эллеров цикл
[04:05:47.960 --> 04:05:49.960]  в графе?
[04:05:49.960 --> 04:05:51.960]  Ага, так, то логично, да?
[04:05:51.960 --> 04:05:53.960]  Так, что такое Эллеров цикл?
[04:05:53.960 --> 04:05:55.960]  Да, нет, ну в том плане, ладно,
[04:05:55.960 --> 04:05:57.960]  давайте быстренько 5 минут потратим,
[04:05:57.960 --> 04:05:59.960]  просто чтобы потом к этому не возвращаться.
[04:05:59.960 --> 04:06:01.960]  Ну, давайте так.
[04:06:01.960 --> 04:06:03.960]  В чем у нас заключается задача?
[04:06:03.960 --> 04:06:05.960]  Задача заключается в том, что дан, допустим,
[04:06:05.960 --> 04:06:07.960]  неориентированный граф,
[04:06:07.960 --> 04:06:09.960]  и хочется найти путь,
[04:06:09.960 --> 04:06:11.960]  который по каждому ребру
[04:06:11.960 --> 04:06:13.960]  проходит ровно один раз.
[04:06:13.960 --> 04:06:15.960]  А лучше цикл.
[04:06:15.960 --> 04:06:17.960]  Ну, возникает простая теорема.
[04:06:17.960 --> 04:06:19.960]  Теорема заключается в том,
[04:06:19.960 --> 04:06:21.960]  что в неориентированном графе,
[04:06:21.960 --> 04:06:23.960]  например, Эллеров цикл
[04:06:23.960 --> 04:06:25.960]  существует тогда и только тогда,
[04:06:25.960 --> 04:06:27.960]  когда...
[04:06:27.960 --> 04:06:29.960]  Да, хочется сказать, что степень
[04:06:29.960 --> 04:06:31.960]  каждой вершины четная?
[04:06:31.960 --> 04:06:33.960]  Нет, не верно.
[04:06:33.960 --> 04:06:35.960]  Нет, тоже не верно.
[04:06:35.960 --> 04:06:37.960]  Да, нет, точная формулевка такая.
[04:06:37.960 --> 04:06:39.960]  Эллеров цикл
[04:06:39.960 --> 04:06:41.960]  в неориентированном графе существует тогда
[04:06:41.960 --> 04:06:43.960]  и только тогда, когда А, все степени
[04:06:43.960 --> 04:06:45.960]  вершины четные,
[04:06:45.960 --> 04:06:47.960]  и Б, все ребра лежат в одной компоненте
[04:06:47.960 --> 04:06:49.960]  связанности.
[04:06:49.960 --> 04:06:51.960]  Ну, потому что изолированная вершина есть.
[04:06:51.960 --> 04:06:53.960]  Вот такая мелкая формальная подлятка.
[04:06:53.960 --> 04:06:55.960]  Вот.
[04:06:55.960 --> 04:06:57.960]  Ну, там, мало ли, просто там на экзамене
[04:06:57.960 --> 04:06:59.960]  встретитесь с каким-нибудь вредным формалистом.
[04:06:59.960 --> 04:07:01.960]  Ну, вот он вас из-за этого
[04:07:01.960 --> 04:07:03.960]  наперездачу отправит.
[04:07:05.960 --> 04:07:07.960]  Ну, в зависимости от настроения,
[04:07:07.960 --> 04:07:09.960]  честно, да.
[04:07:09.960 --> 04:07:11.960]  Ну, скажем так, ладно, обычно
[04:07:11.960 --> 04:07:13.960]  таких проблем не возникает.
[04:07:13.960 --> 04:07:15.960]  Но теперь возникает вопрос.
[04:07:15.960 --> 04:07:17.960]  И мы знаем, что Эллеров цикл существует.
[04:07:17.960 --> 04:07:19.960]  Но тут, как бы у нас...
[04:07:19.960 --> 04:07:21.960]  Да, понятно, в школе, где-нибудь в седьмом классе
[04:07:21.960 --> 04:07:23.960]  вы могли это доказать, там вида...
[04:07:23.960 --> 04:07:25.960]  доказательства, там могло быть вида, что давайте
[04:07:25.960 --> 04:07:27.960]  стартуем из какой-нибудь вершины и будем
[04:07:27.960 --> 04:07:29.960]  просто жадно набирать ребра, пока не упремся.
[04:07:29.960 --> 04:07:31.960]  И мы знаем, что мы, как бы,
[04:07:31.960 --> 04:07:33.960]  упремся куда?
[04:07:33.960 --> 04:07:35.960]  Ну, упремся мы только в стартовую вершину.
[04:07:35.960 --> 04:07:37.960]  И то еще из нее тут походим,
[04:07:37.960 --> 04:07:39.960]  походим, да. Ну, и там подсчетность
[04:07:39.960 --> 04:07:41.960]  очевидна, что в каждой вершине, кроме нее,
[04:07:41.960 --> 04:07:43.960]  следующее ребро обязательно найдется.
[04:07:43.960 --> 04:07:45.960]  Там окажется, что найдем цикл,
[04:07:45.960 --> 04:07:47.960]  если он покрыл не все ребра, то там
[04:07:47.960 --> 04:07:49.960]  выходим, выходим еще тут цикл
[04:07:49.960 --> 04:07:51.960]  этот вешаем и так далее.
[04:07:51.960 --> 04:07:53.960]  Но тут просто важно знать, как это сделать так,
[04:07:53.960 --> 04:07:55.960]  чтобы это все красиво работало
[04:07:55.960 --> 04:07:57.960]  за линию.
[04:07:57.960 --> 04:07:59.960]  Значит, за линию это работает
[04:07:59.960 --> 04:08:01.960]  примерно так. Запускаем
[04:08:01.960 --> 04:08:03.960]  DFS.
[04:08:03.960 --> 04:08:05.960]  Значит, смотрите, то есть запускаем DFS,
[04:08:05.960 --> 04:08:07.960]  но DFS будет хитренький.
[04:08:07.960 --> 04:08:09.960]  Значит, он не будет в вершине
[04:08:09.960 --> 04:08:11.960]  хранить юзид, то есть мы в одну вершину можем
[04:08:11.960 --> 04:08:13.960]  ходить несколько раз.
[04:08:13.960 --> 04:08:15.960]  Но при этом мы следим,
[04:08:15.960 --> 04:08:17.960]  что мы не по одному ребру
[04:08:17.960 --> 04:08:19.960]  не прошли
[04:08:19.960 --> 04:08:21.960]  много раз.
[04:08:21.960 --> 04:08:23.960]  То есть юзиды у нас
[04:08:23.960 --> 04:08:25.960]  помечаются не по...
[04:08:25.960 --> 04:08:27.960]  То есть юзиды у нас помечаются
[04:08:27.960 --> 04:08:29.960]  не на вершины, а на ребра
[04:08:29.960 --> 04:08:31.960]  в обе стороны.
[04:08:31.960 --> 04:08:33.960]  Понятно, да?
[04:08:33.960 --> 04:08:35.960]  И более того, в каждой вершине еще и
[04:08:35.960 --> 04:08:37.960]  на самом деле стоит указатель,
[04:08:37.960 --> 04:08:39.960]  типа до какого ребра
[04:08:39.960 --> 04:08:41.960]  мы уже дошли.
[04:08:41.960 --> 04:08:43.960]  Ну, потому что мы же обычные списки смертности перебираем,
[04:08:43.960 --> 04:08:45.960]  правда?
[04:08:45.960 --> 04:08:47.960]  Так вот.
[04:08:47.960 --> 04:08:49.960]  И тогда идея алгоритма
[04:08:49.960 --> 04:08:51.960]  оказывается такой.
[04:08:51.960 --> 04:08:53.960]  Значит, мы запускаем DFS, который
[04:08:53.960 --> 04:08:55.960]  выходит
[04:08:55.960 --> 04:08:57.960]  из вершины только если...
[04:08:57.960 --> 04:08:59.960]  То есть DFS
[04:08:59.960 --> 04:09:01.960]  всегда входит в любую вершину, которую надо,
[04:09:01.960 --> 04:09:03.960]  но если он выяснил, что ребра закончились,
[04:09:03.960 --> 04:09:05.960]  тогда он из нее выбрасывается.
[04:09:05.960 --> 04:09:07.960]  А если выяснится, что
[04:09:07.960 --> 04:09:09.960]  ребра еще не закончились, значит он
[04:09:09.960 --> 04:09:11.960]  по этому ребру обязательно
[04:09:11.960 --> 04:09:13.960]  выбирает указатель и по этому ребру
[04:09:13.960 --> 04:09:15.960]  вызывается.
[04:09:15.960 --> 04:09:17.960]  Ну, если, конечно, это ребро не было
[04:09:17.960 --> 04:09:19.960]  обойдено в другую сторону.
[04:09:19.960 --> 04:09:21.960]  Да, это важно.
[04:09:21.960 --> 04:09:23.960]  Да, в неориентированном такой случае есть.
[04:09:23.960 --> 04:09:25.960]  Так вот, идея такая.
[04:09:25.960 --> 04:09:27.960]  DFS так обходит ребра.
[04:09:27.960 --> 04:09:29.960]  Ребра эти добавляются в стэк, в стэк, в стэк,
[04:09:29.960 --> 04:09:31.960]  в стэк, в стэк, в стэк, ходили-ходили,
[04:09:31.960 --> 04:09:33.960]  бродили-бродили, бом, ходили-бродили,
[04:09:33.960 --> 04:09:35.960]  ходили-бродили, и вот мы
[04:09:35.960 --> 04:09:37.960]  наконец там
[04:09:37.960 --> 04:09:39.960]  уткнулись в это ребро. И дальше хода нет.
[04:09:39.960 --> 04:09:41.960]  Тогда мы выходим, наконец,
[04:09:41.960 --> 04:09:43.960]  рекурсивно из этого ребра.
[04:09:43.960 --> 04:09:45.960]  И, внимание, это ребро
[04:09:47.960 --> 04:09:49.960]  торжественно
[04:09:49.960 --> 04:09:51.960]  добавляем
[04:09:51.960 --> 04:09:53.960]  уже в ответ.
[04:09:53.960 --> 04:09:55.960]  Что будет происходить дальше?
[04:09:55.960 --> 04:09:57.960]  Ну, то есть идея такая. То есть каждый раз,
[04:09:57.960 --> 04:09:59.960]  когда мы из ребра выходим
[04:09:59.960 --> 04:10:01.960]  из рекурсии, значит мы его добавляем в ответ.
[04:10:01.960 --> 04:10:03.960]  Ну, тогда будет что
[04:10:03.960 --> 04:10:05.960]  происходить? Он тут еще походит, походит,
[04:10:05.960 --> 04:10:07.960]  походит, походит, походит.
[04:10:07.960 --> 04:10:09.960]  На этот раз выяснится, что
[04:10:09.960 --> 04:10:11.960]  он уже уткнется именно в эту вершину.
[04:10:11.960 --> 04:10:13.960]  Ну,
[04:10:13.960 --> 04:10:15.960]  потому что только в ней
[04:10:15.960 --> 04:10:17.960]  на момент втыкания будет
[04:10:17.960 --> 04:10:19.960]  четное число ребр незадействованных.
[04:10:19.960 --> 04:10:21.960]  И тогда, когда из ребра выходим,
[04:10:21.960 --> 04:10:23.960]  тогда добавляем это ребро.
[04:10:23.960 --> 04:10:25.960]  Остается только несложно показать,
[04:10:25.960 --> 04:10:27.960]  что, во-первых, все ребра
[04:10:27.960 --> 04:10:29.960]  в этот цикл войдут, а во-вторых,
[04:10:29.960 --> 04:10:31.960]  что самое важное – это будет действительно цикл.
[04:10:33.960 --> 04:10:35.960]  То есть таким образом,
[04:10:35.960 --> 04:10:37.960]  то есть как это не парадоксально, несмотря на отсутствие
[04:10:37.960 --> 04:10:39.960]  юзеров по вершинам, алгоритм
[04:10:39.960 --> 04:10:41.960]  будет работать за отъем.
[04:10:43.960 --> 04:10:45.960]  Чего?
[04:10:45.960 --> 04:10:47.960]  Не совсем правда, что у нас указатели
[04:10:47.960 --> 04:10:49.960]  именно по спискам смежности, потому что нам
[04:10:49.960 --> 04:10:51.960]  нужно пометить не только то, что мы
[04:10:51.960 --> 04:10:53.960]  ударили. Ну, короче, нужно
[04:10:53.960 --> 04:10:55.960]  ввести массив юз для ребра.
[04:10:55.960 --> 04:10:57.960]  Ну, нужно ввести массив юз для ребра, да.
[04:10:57.960 --> 04:10:59.960]  Да, то есть понятно, что мы здесь
[04:10:59.960 --> 04:11:01.960]  не только указатель помечаем, но и для каждого
[04:11:01.960 --> 04:11:03.960]  ребра помечаем, ходили мы по нему или нет.
[04:11:03.960 --> 04:11:05.960]  Да, в ориентированном графе
[04:11:05.960 --> 04:11:07.960]  будет чуть проще, потому что
[04:11:07.960 --> 04:11:09.960]  если у нас
[04:11:09.960 --> 04:11:11.960]  здесь вот такое ребро, то по нему в обратном
[04:11:11.960 --> 04:11:13.960]  направлении мы пройти не могли.
[04:11:13.960 --> 04:11:15.960]  Но, кстати, в ориентированном графе
[04:11:15.960 --> 04:11:17.960]  конечно все было сложнее.
[04:11:17.960 --> 04:11:19.960]  Потому что в ориентированном графе
[04:11:19.960 --> 04:11:21.960]  эллеров цикл существует, если
[04:11:21.960 --> 04:11:23.960]  во-первых, все ребра
[04:11:23.960 --> 04:11:25.960]  принадлежат одной компоненте сильной связности,
[04:11:25.960 --> 04:11:27.960]  во-вторых, у каждой вершины
[04:11:27.960 --> 04:11:29.960]  входящая степь
[04:11:29.960 --> 04:11:31.960]  равна исходящей.
[04:11:31.960 --> 04:11:33.960]  Ну и тогда доказательства алгоритм
[04:11:33.960 --> 04:11:35.960]  такой же, только единственное, что цикл
[04:11:35.960 --> 04:11:37.960]  будет в обратном порядке, потому что мы ребра
[04:11:37.960 --> 04:11:39.960]  в порядке такой ориентации добавляем.
[04:11:41.960 --> 04:11:43.960]  Вот. Так что вот это просто хотелось
[04:11:43.960 --> 04:11:45.960]  быстро упомянуть, чтобы к этому не возвращаться.
[04:11:45.960 --> 04:11:47.960]  Надеюсь, у вас там, если вам
[04:11:47.960 --> 04:11:49.960]  потребуется найти эллеров цикл, то проблем у вас
[04:11:49.960 --> 04:11:51.960]  не будет.
[04:11:51.960 --> 04:11:53.960]  Так, ну что ж, тогда на этом все.
[04:11:53.960 --> 04:11:55.960]  Ладно, в следующий раз займемся чем-то кроме DFS.
[04:11:55.960 --> 04:11:57.960]  Да.
