[00:00.000 --> 00:10.680]  всем доброго дня мы с вами продолжаем изучать наш курс и некоторое добавление мы запустили форму
[00:10.680 --> 00:16.080]  обратной связи прочитали ее и поэтому некоторые моменты будем внедрять практику значит одним из
[00:16.080 --> 00:21.840]  требований одной из претензий было того что мы вообще не разбираем примеры кодов паттернов
[00:21.840 --> 00:27.560]  которые были рассказаны на лекциях наверное те паттерны которые рассказываются на семинарах
[00:27.560 --> 00:34.640]  вы их смотрите с примерами но вот те паттерны которые рассматриваются на лекции обычно идут
[00:34.640 --> 00:40.800]  без примеров поэтому давайте исправим этот момент и посмотрим реализацию паттерна состояния мы с
[00:40.800 --> 00:46.320]  вами в прошлый раз когда говорили про активные классы и диаграмма состояния поняли что у нас
[00:46.320 --> 00:52.520]  существует такой паттерн как состояние где у нас собственно есть активный объект внутри которого
[00:53.520 --> 01:00.880]  вот и здесь у нас как раз есть пример значит когда можно понять всю элегантность паттернов
[01:00.880 --> 01:06.800]  элегантность паттернов можно понять тогда когда вы смотрите мэйн файл который показывает
[01:06.800 --> 01:18.480]  взаимодействие с этим объектом что мы здесь видим с вами давайте попробуем прокомментировать
[01:18.480 --> 01:30.120]  этот код да мы видим светофор в котором какие методы что что это светофор делает
[01:30.120 --> 01:40.000]  да смотрите он меняет цвета и он умеет печатать свое собственное состояние хорошо давайте
[01:40.000 --> 01:47.480]  посмотрим на реализацию traffic light точнее пойдем на посмотрю реализацию методи change color и что
[01:47.480 --> 01:53.680]  мы здесь видим мы с вами видим что здесь у нас давайте параллельно буду рисовать диаграмму
[01:53.680 --> 02:12.240]  traffic light у нас есть метод change color он возвращает void но что у нас есть у этого
[02:12.240 --> 02:22.880]  светофора у нас у этого светофора есть указатель на так да да да да да тут такое тоже бывает
[02:22.880 --> 02:31.080]  шофс на что мы получаем вот у нас есть state который указатель на state pointer то есть у нас
[02:31.080 --> 02:47.120]  вами есть некоторый объект state pointer и у нас он его содержит при этом здесь связь один к
[02:47.120 --> 02:56.480]  одному значит это у нас вами получается объект вида state я прямо перерисовываю код vml диаграмму
[02:56.480 --> 03:04.760]  значит в чем реализация заключается метода change color у стейта есть метод switch
[03:04.760 --> 03:21.560]  который при этом принимает объект вида traffic light вот значит как это возможно давайте
[03:21.560 --> 03:29.680]  сразу обсудим почему это возможно потому что у нас указатель на this есть и нам не
[03:29.680 --> 03:36.240]  нужно переоперировать класс то есть получается у нас с вами у state pointer есть реализация метода
[03:36.240 --> 03:42.400]  switch а теперь давайте посмотрим что это за switch и мы видим с вами поскольку работает здесь
[03:42.400 --> 03:48.080]  visual studio code то у нас с вами есть три реализации этого метода то есть если мы с вами откроем
[03:48.080 --> 03:56.840]  наш стейт стейт вот он класс стейт а стейт поинтер это у нас с вами этот указатель на стейт
[03:56.840 --> 04:07.880]  звездой со звездой давайте покажу вот это уник птр на стейт и смотрите что дальше у нас с
[04:07.880 --> 04:13.120]  вами происходит у стейта все методы виртуальные то есть по факту может считать что это интерфейс
[04:13.120 --> 04:22.760]  либо абстрактный класс в зависимости от того это у нас роль либо это у нас объект классической
[04:22.760 --> 04:29.400]  реализации паттерна у нас идет как раз это абстрактный класс значит и дополнительно здесь
[04:29.400 --> 04:35.600]  стоят forward declaration чтобы мы с вами могли правильно указывать реализации цветов потому почему
[04:35.920 --> 04:41.120]  почему важна реализация цветов потому что когда мы с вами запустим реализацию метода
[04:41.120 --> 04:50.600]  свой метода switch то давайте рассмотрим вот такой метод то есть нам все равно нужно будет с вами
[04:50.600 --> 04:59.840]  указ создавать объекты классов то есть у нас с вами будет три наследника этого класса это ело
[04:59.840 --> 05:14.560]  это ред и это грин то есть у нас с вами создаются вот такие объекты значит и у объекта ело есть
[05:14.560 --> 05:25.040]  метод значит реализация метода switch который делает следующее он берет и устанавливает нашему
[05:25.040 --> 05:32.480]  светофору который здесь есть состояние на красный то есть получается каждое состояние при
[05:32.480 --> 05:42.760]  определенном триггере переходит в другое состояние устанавливает светофору это состояние вот мы
[05:42.760 --> 05:49.480]  вызываем 13 строке конструктор класса а дальше мы устанавливаем это состояние то есть как бы
[05:49.480 --> 05:54.960]  по факту можно считать что после того как это состояние у нас отработала она у нас уничтожается
[05:54.960 --> 06:01.000]  да потому что мы работаем с уникптерами после выхода из этого после того как у нас количество
[06:01.000 --> 06:06.880]  ссылок на объект становится равно нулю у нас объект уничтожается вот и в итоге у нас получается
[06:06.880 --> 06:13.600]  наша цель будет следующим вызывать метод change color change color у так это класс у нас состояние не
[06:13.600 --> 06:19.320]  стоит pointer у класса состояния будет вызываться метод switch а метод switch будет переставлять
[06:19.320 --> 06:31.520]  конкретное состояние вот вот в итоге получается элегантным и давайте как раз его запустим значит
[06:31.520 --> 06:38.200]  у меня как раз тут есть и мэйк так вопрос разом на семинарах рассмотрелись и мэйк
[06:38.200 --> 06:53.480]  хорошо все мы компилируем стоит и давайте мы его запустим вот смотрите вот у нас метод
[06:53.480 --> 07:01.720]  принц стейт он нас выводит просто состояние direction и калор мы начинаем с вами с красного
[07:01.720 --> 07:08.440]  потом переходим на желтый потом переходим на зеленый и печатаем при этом direction у желтого
[07:08.440 --> 07:15.200]  цвета значит у когда мы ставим с вами зеленый цвет то у нас direction стоит на красный направление
[07:15.200 --> 07:22.840]  цвета стоит на красный и мы с вами указываем direction 1 и в итоге мы с вами поменяли код как
[07:22.840 --> 07:30.680]  раз 10 раз поменяли светофор каким образом можно усложнять эту динамику процессов вы наверное
[07:30.680 --> 07:39.960]  большое количество раз переходите светофор который из рядом сынка стоит в чем его особенность
[07:39.960 --> 07:50.400]  смотрите у этого светофора на самом деле было несколько поколений вы не застали когда он по
[07:50.400 --> 07:56.280]  кнопке активировался раньше он активировался по кнопке то есть был внешний триггер который
[07:56.280 --> 08:02.480]  давал тайм-аут на то что у вас изменится состояние этого светофора то есть мы можем
[08:02.480 --> 08:10.400]  ставить триггер по времени ну ладно это еще не пол беды большее количество светофоров сейчас
[08:10.400 --> 08:23.080]  адаптированы под какой момент времени под какой момент зависит ли время желтого время зеленого
[08:23.080 --> 08:31.440]  и красного цвета от времени суток да зависит причем на некоторые некоторые светофоры делаются
[08:31.440 --> 08:37.960]  именно такими для того чтобы оптимизировать трафик допустим если вы посмотрите на светофор
[08:37.960 --> 08:44.080]  который идет на пересечение как называется институтского переулка и первомайской то в
[08:44.080 --> 08:49.560]  зависимости от соответственно времени суток он показывает разные интервалы на красный зеленый
[08:49.560 --> 08:56.200]  цвет нам по моему в какие-то моменты 50 секунд в какие-то моменты это 80 секунд то есть как бы
[08:56.200 --> 09:01.400]  мы можем менять состояние в зависимости еще от момента времени то есть в принципе можем
[09:01.400 --> 09:11.120]  передавать момент времени для этого состояния вот то есть вот такая реализация паттерна стоит
[09:11.120 --> 09:19.000]  просили вы просили реализации паттерна мы с вами их будем смотреть как раз так хорошо давайте
[09:19.080 --> 09:31.120]  тогда вопросы по этой по этой части понятно ли реализация если непонятно спрос спрашивайте
[09:31.120 --> 09:45.400]  глупые вопросы тоже можно задавать мы говорили что как раз паттерн состоит в том что мы скрываем
[09:45.400 --> 09:51.720]  детали перехода из одного состояния в другое то есть у нас получается как раз есть светофор значит
[09:51.720 --> 09:57.880]  это активный класс внутри него есть набор состояний мы могли бы писать вот эту всю логику так что вот
[09:57.880 --> 10:03.480]  у нас есть объект типа калор а дальше писать значит если калор красный переходим в желтый
[10:03.480 --> 10:10.360]  если цвет желтый переходим зеленый а здесь мы по факту логику изменения цветов делегируем
[10:10.360 --> 10:16.120]  от самого светофора к объекту который отвечает за состояние за состояние и в зависимости от того
[10:16.120 --> 10:21.560]  объекта состояние которое у нас стоит красный желтый и зеленый сам объект определяет логику куда
[10:21.560 --> 10:28.720]  ему переходить вот в этом особенность паттерн то есть у нас не получается большое число ифов то есть
[10:28.720 --> 10:37.800]  если мы перейдем в реализацию красного цвета там все достаточно просто все останавливаем
[10:37.800 --> 10:42.640]  состояние желтый устанавливаем направление на зеленый цвет то есть именно красный говорит типа
[10:42.640 --> 10:53.520]  куда желтому двигаться мы допустим можем поставить ограничения в какие состояния не надо переходить
[10:53.520 --> 11:02.240]  или через какое время переходить так хорошо еще вопросы
[11:07.800 --> 11:14.360]  состояние стоит мы как раз в прошлый раз говорили про диаграмму состояний
[11:14.360 --> 11:21.560]  поняли что нам нужно использовать диаграмма состояния тогда когда у нас есть активный класс в
[11:21.560 --> 11:25.200]  котором должны переключать состояние и вот это реализация того как это можно сделать
[11:25.200 --> 11:39.360]  так еще вопросы если вопрос нет давайте мы с вами продолжим сейчас мы начнем точнее продолжим
[11:39.360 --> 11:47.240]  новую тему которая называется тестирование и в прошлый раз мы детально с вами что-то мне
[11:47.840 --> 12:02.280]  тут кажется проблем с цветпередачей у этого проектора да будут цвета так давайте тогда
[12:02.280 --> 12:08.520]  вот этот грамм чуть побольше сделаю значит смотрите мы сегодня будем говорить про тестирование по
[12:08.520 --> 12:14.520]  и большую часть времени мы как раз будем посвящать некоторым практикам тестирование по сразу скажу
[12:14.520 --> 12:20.000]  что сейчас будут начинать семинары по тестированию параллельно с лекциями но некоторые моменты я
[12:20.000 --> 12:24.240]  тоже буду рассказывать на лекции чтобы было именно интересно с точки зрения практической
[12:24.240 --> 12:30.680]  составляющей значит давайте мы с вами в прошлый раз поговорили про объекты тестирования то есть
[12:30.680 --> 12:35.160]  у нас будет функциональный не функциональный тестирование дальше мы можем с вами сказать
[12:35.160 --> 12:40.920]  следующую вещь мы можем с вами это виды тестирования по доступности кода какие бывают
[12:41.680 --> 12:47.280]  первая вид тестирования который на самом деле очень сильно вам знаком это тестирование черного
[12:47.280 --> 12:53.320]  ящика это означает что у вас есть код какой-то функции выпадает у вас есть какие-то входные
[12:53.320 --> 12:59.060]  данные вы запускаете функцию получаете результат у вас результат функции сверяйте с готовым
[12:59.060 --> 13:06.240]  ответом то есть то как обычно происходит тестирование во всяких задачах по алгоритму это
[13:06.240 --> 13:11.880]  черный ящик. Если мы говорим про тестирование белого ящика, это интересный момент, вы видите
[13:11.880 --> 13:20.360]  весь код, который у вас есть, у вас есть структура кода, вы прямо смотрите и пытаетесь понять, что в
[13:20.360 --> 13:28.720]  вашем коде не так. И как раз метод тестирования белого ящика заключается в том, что вы проходите
[13:28.720 --> 13:33.240]  специальными инструментами, возможно запуская код, возможно не запуская код и смотрите его
[13:33.240 --> 13:42.520]  качество. Значит, если понятие, которое позволяет нам это сделать, это статический анализатор кода,
[13:42.520 --> 13:49.400]  они у нас существуют. И давайте я спрошу, знакома ли вам такая аббревиатура, как PEP8?
[13:49.400 --> 13:57.680]  Наверное, если вы сейчас проходите курс по Python, то вас заставляет все писать по PEP8,
[13:57.680 --> 14:05.840]  ну по крайней мере должны. Вот, есть инструмент, который называется Flake 8, который позволяет вам
[14:05.840 --> 14:13.160]  запустить как раз код и проверить его на консистентность. Давайте в качестве эксперимента
[14:13.160 --> 14:25.280]  мы это с вами попробуем сделать. Так, давайте я какой-нибудь это, возьму какой-нибудь virtual
[14:25.280 --> 14:50.720]  length, я использую, вот, и прогоним инструмент Flake 8, допустим на... Так, он ничего не вывел,
[14:50.720 --> 15:05.320]  значит у нас все хорошо. Если бы мы... Давайте сделаем вот так. Вот, он выдает вот такие вот
[15:05.320 --> 15:11.320]  ошибки, в котором говорят, что код у нас неверный. То есть, смотрите, вот у нас, допустим, есть импорт,
[15:11.320 --> 15:18.520]  который не используется. То есть, они у нас явно подсвечиваются и это считается не очень хорошим
[15:18.520 --> 15:24.840]  тоном, потому что это может привнести к какие-то ошибки. Значит, здесь есть фатальные ошибки,
[15:24.840 --> 15:30.760]  которые говорят, допустим, что у вас код не запустится, потому что у вас есть синтактическая
[15:30.760 --> 15:38.040]  ошибка. Да, то есть, это в принципе тоже можно проверять. То есть, если мы здесь напишем импорт-тест
[15:38.040 --> 15:48.320]  внезапно, вот такой модуль, то, видите, у нас эта ошибка, что вот этот объект импорт-тест,
[15:48.320 --> 15:55.800]  but not used. Если мы запустим, то, скорее всего, у нас даже ничего не запустится. Вот. Еще классическая
[15:55.800 --> 16:02.520]  вещь есть, если мы говорим про переносы в конце строки. Видите, даже синтактический анализатор
[16:02.520 --> 16:11.520]  подсветил. Вот. Видите, мне выдает warning. No new at end of the line. То есть, таким образом вы можете явно
[16:11.520 --> 16:17.800]  предотвратить какой-то не очень хороший код. Допустим, есть переменные, которые не используются.
[16:17.800 --> 16:23.240]  Есть переменные, если мы говорим про компилируемые языки программирования, у нас может быть
[16:23.240 --> 16:30.640]  переменная, которая, так сказать, создана, но не идеализирована никаким значением. И это статические
[16:30.640 --> 16:36.280]  анализаторы кода четко отлаживают. Значит, в качестве инструментов, которые можно использовать,
[16:36.280 --> 16:56.080]  значит, есть PEP8. Если мы говорим про C++, то это пара C langtide и C langt format. Не знаю, кто-нибудь
[16:56.080 --> 17:12.400]  пользовался имя. Да, тоже удобная вещь. Если мы, значит, говорим про джаву, то это инструмент чекстайл.
[17:12.400 --> 17:18.640]  То есть, во всех языках, так или иначе, есть либо внутренние библиотеки, либо сторонние библиотеки,
[17:18.640 --> 17:25.640]  скорее всего, да, сторонние библиотеки, которые позволяют вам проверять статический анализ кода.
[17:25.640 --> 17:35.080]  Анализировать ваш код. Значит, это что касается по доступности. Следующий метод серого ящика.
[17:35.080 --> 17:40.120]  Значит, мы про него тоже будем говорить. Он заключается в том, что как бы вы видите часть
[17:40.120 --> 17:46.520]  системы, а часть системы у вас закрыта. То есть, допустим, для вас, вот смотрите, YouTube это черный
[17:46.520 --> 17:53.720]  ящик. Вы что-то заходите, в нем делаете. Но если вы обратитесь в техподдержку, то для техподдержки
[17:53.720 --> 17:59.600]  YouTube это уже серый ящик. Потому что они видят часть прослойки, но при этом внутренний код могут не
[17:59.600 --> 18:06.520]  видеть всю реализацию. Тоже про это поговорим. Так, следующий момент по позитивности сценариев.
[18:06.520 --> 18:11.920]  Иногда делят видотестирование. Есть позитивные сценарии, есть негативные сценарии. Как вы думаете,
[18:11.920 --> 18:16.360]  какое приблизительное соотношение между позитивными сценариями и негативными сценариями?
[18:16.360 --> 18:36.640]  Так, 50 на 50, 1 к 99. 30-70. Ну вот, 1 на 99 это слишком экстремально, 50 на 50 на самом деле это не так.
[18:36.640 --> 18:48.320]  Я бы сказал, от 20 на 80 до 10 на 90. То есть, ваша цель как разработчиков ПО сделает так, чтобы
[18:48.320 --> 18:58.760]  пользователи не смогли ткнуть не в то место. Чтобы все сломалось. Дальше говорят следующее,
[18:58.760 --> 19:06.600]  что есть разделение по времени проведения тестирования. И здесь на самом деле на диаграмме
[19:06.600 --> 19:11.240]  намешана куча мала, но в целом она показывает именно время проведения тестирования. То есть,
[19:11.240 --> 19:15.680]  у нас есть альфа-тестирование. Что такое альфа-тестирование? Это вид тестирования,
[19:15.680 --> 19:25.880]  в котором, который проводится внутри компании перед первичной публикацией. Что такое бета-тестирование?
[19:25.880 --> 19:32.520]  Бета-тестирование – это вид тестирования, когда мы приглашаем либо проведём закрытое
[19:32.520 --> 19:36.280]  бета-тестирование, то есть мы приглашаем внешних пользователей протестировать наш функционал,
[19:36.280 --> 19:40.280]  либо открытое бета-тестирование . Когда мы говорим, что вот, пожалуйста, мы
[19:40.280 --> 19:45.500]  проводим с вами тестирование – пожалуйста, смотрите на наш функциональность,
[19:45.500 --> 19:54.880]  пишите нам обзывы, мы будем их исправлять. Третий вариант – это дымовое тестирование.
[19:54.880 --> 20:06.960]  Значит, в чем оно заключается, если здесь тело, у кого есть физика? Хорошо, у вас есть физика.
[20:06.960 --> 20:14.080]  Представьте себе, что вы клепаете механизм какой-то и запускаете его в какую-нибудь
[20:14.080 --> 20:20.500]  электрическую схему. Что у вас происходит, если эта схема не будет работать?
[20:20.500 --> 20:38.500]  Средний случай. В худшем случае сгорит все. Что означает, что сгорит все? Что является предвестником
[20:38.500 --> 20:47.700]  того, что все сгорит? Дым пойдет. Что означает смог тестирования? Вы запускаете ваш продукт,
[20:47.700 --> 20:57.540]  начинаете делать основные проверки. Пойдет ли дым или не пойдет. Если дым пройдет, то все грустно.
[20:57.540 --> 21:04.020]  Значит, если мы когда мы запускаем нашу программу, если у нас идет дым, это означает, что у нас какие-нибудь
[21:04.020 --> 21:11.140]  ошибки начинают сыпаться или у нас какие-то запросы по сети не проходят, значит наш код не работает.
[21:11.140 --> 21:19.940]  Все, останавливаем. Это такая вот чистая проверка, которая нам нужна для того, что работает или нет.
[21:19.940 --> 21:27.100]  Следующий это санити-тестинг. Есть специальные инструменты, которые называются санитайзерами,
[21:27.100 --> 21:35.100]  которые обеспечивают проверку именно внутреннего функционала. Классический пример санитайзеров,
[21:35.100 --> 21:43.260]  вы проверяете, что вы не выходите за пределы массивов, у вас память всегда очищается,
[21:43.260 --> 21:49.540]  потому что в чем проблема того, что вы не очищаете память? Память течет.
[21:49.540 --> 22:01.580]  Да, то есть у нас в какой-то момент времени количество оперативной памяти,
[22:01.580 --> 22:06.980]  которая выделяется нашей программой растет, растет, растет, растет, и в какой-то момент времени это достигает
[22:06.980 --> 22:13.540]  критического эффекта и возникает два варианта. Первый вариант, у вас компьютер зависнет, потому что
[22:13.540 --> 22:20.540]  количество оперативной памяти слишком большое, либо это в худшем случае. В среднем случае мы можем
[22:20.540 --> 22:28.460]  сказать следующее, что у нас с вами настроен такой механизм как out of memory killer, что это такое?
[22:28.780 --> 22:34.980]  В процессе операционной системы вы можете для каждого процесса настроить максимальное количество оперативной памяти,
[22:34.980 --> 22:38.780]  которое он может использовать. Если у вас количество оперативной памяти превышает
[22:38.780 --> 22:46.860]  дозволенное, то у вас процесс автоматически останавливается. Следующая вещь, это тестирование
[22:46.860 --> 22:52.860]  новой функциональности. Для этого вы как раз можете использовать такое понятие как фичу флаги.
[22:52.860 --> 22:57.620]  Наверное, я сейчас детальнее не буду раскрывать, но вы по факту вводите новую функциональность и
[22:57.620 --> 23:04.620]  проверяете, работает она или нет, как заложено. Дальше есть такое понятие как регрессионное
[23:04.620 --> 23:10.500]  тестирование, в чем оно заключается. Представьте себе, что у нас кто-то нашел баг, причем это был
[23:10.500 --> 23:17.740]  конечный клиент, и ваша цель заключается в том, чтобы проверить, исправили ли вы баг или нет. И в
[23:17.740 --> 23:23.540]  зависимости от того, насколько вам важно исправление этого бага, вы проверяете допустим,
[23:23.540 --> 23:31.660]  сломался ли. То есть вы проверяете чисто функциональность того, что новый тест вводит эти баги
[23:31.660 --> 23:40.380]  или не вводит эти баги. Сейчас еще попробую переформулировать. Новый тест, который у нас появляется,
[23:40.380 --> 23:45.500]  типа закрывает он эту функциональность или нет. Более того, вы можете распространить это. Допустим,
[23:45.500 --> 23:50.580]  вы нашли баг в каком-то модуле, в нем есть еще какие-то связанные с ним классы. Проверяете
[23:50.740 --> 23:57.180]  допустим на тесты те классы, которые связаны именно с текущим. Регрессионное тестирование тоже
[23:57.180 --> 24:03.180]  закрывать не будем, их всего там 7 типов есть. И последняя вещь, которая здесь есть, сразу скажу,
[24:03.180 --> 24:11.860]  это приемочное тестирование. Оно называется Acceptance или Certification Test. Прежде чем вы в
[24:11.860 --> 24:19.500]  реальной жизни попытаетесь сдать какой-то проект, именно реальный проект с заключением договоров,
[24:19.500 --> 24:28.060]  всяких подобных вещей, то есть серьезный проект, вам придется проверить его на сертификат соответствия.
[24:28.060 --> 24:32.300]  То есть запускается ли он на определенной операционной системе, запускается ли он с определенными
[24:32.300 --> 24:36.900]  всеми требованиями, выполнены ли требования по техническому заданию и так далее. Потому что
[24:36.900 --> 24:42.980]  если это не будет выполнено, то условия договора нарушены и придется платить большие неустойки. Но
[24:42.980 --> 24:47.900]  сразу скажу, что приемочное тестирование, помимо того, что оно находится здесь, мы его можем еще и
[24:47.900 --> 24:56.060]  закинуть в уровни тестирования. И вот самое важное на самом деле, если мы говорим в рамках тестирования,
[24:56.060 --> 25:03.100]  очень хорошо стоит понимать про уровни тестирования. Всего их выделяют четыре. Первое это компонентное
[25:03.100 --> 25:08.740]  тестирование или unit-тестирование, второе это интеграционное тестирование, третье это системное
[25:08.740 --> 25:14.700]  тестирование, а четвертое, самое верхнее, это приемочное тестирование. Если вы сейчас не поняли,
[25:14.700 --> 25:21.060]  что это означает, не бойтесь, про уровни тестирования мы посвятим прямо полулекции.
[25:21.060 --> 25:33.580]  Вот, и смотрите последний момент. Очень важный, а не последний, господи, почти. Значит последний
[25:33.580 --> 25:39.780]  из основных именно видов тестирования, категорий видов тестирования, это тестирование по степени
[25:39.780 --> 25:47.300]  автоматизированности. Вы можете сделать следующее, у вас может быть ручное тестирование, и не поверите,
[25:47.300 --> 25:55.580]  сфера ручного тестирования до сих пор занимает большую часть в тестировании ПО. То есть это вы,
[25:55.580 --> 26:03.540]  когда вводите какие-то поля, проверяете результаты, хорошо-нехорошо, значит наша цель будет приблизиться
[26:03.540 --> 26:07.780]  как раз с точки зрения технологии программирования именно к автоматизированному тестированию.
[26:07.780 --> 26:14.140]  Для того, чтобы тесты могли запускаться автоматическим образом. Почему, как вы думаете,
[26:14.140 --> 26:29.940]  лучше автоматизировать тесты? Как вы думаете, какой вид тестирования дольше проводить? Конечно
[26:29.940 --> 26:35.940]  ручное, потому что нам нужно кнопочки протыкивать, действия проводить и так далее. То есть это очень
[26:35.940 --> 26:42.540]  неприятно. Но бывают полуавтоматизированные тестирования. То есть образно говоря, такой пример,
[26:42.540 --> 26:48.300]  вам нужно отправить, зарегистрировать пользователя в системе, и когда вы регистрируете пользователи
[26:48.300 --> 26:53.860]  в системе, вам нужно активировать письмо на почте. То есть письмо с активацией. Вы получаете ссылку,
[26:53.860 --> 27:01.980]  вы проверяете, допустим, что письмо у вас пришло на почту, и после того, вводите, там ссылку обычно
[27:01.980 --> 27:07.340]  приходит, вводите эту ссылку и продолжаете тест именно с этого момента. То есть остальные все
[27:07.340 --> 27:13.340]  сценарии будут автоматизированы. Вот. И как раз наша цель будет именно тестировать на более
[27:13.340 --> 27:18.300]  высоком уровне, тестировать как раз те варианты использования, которые мы описываем в наших
[27:18.300 --> 27:24.460]  проектах. Еще две категории, которые здесь есть, это по степени подготовки. То есть у нас с вами
[27:24.460 --> 27:34.020]  либо этот тест был заранее задокументирован, либо он появился, так сказать, прямо при
[27:34.020 --> 27:40.820]  разработке. Это ad hoc тест, ну и по субъекту тестирования. Здесь у нас показывается,
[27:40.820 --> 27:45.820]  чем отличаются альфа- и бета-тестировщики. То есть альфа-тестировщики это обычно штатные
[27:45.820 --> 27:50.540]  сотрудники, бета-тестировщики это внешние сотрудники. То есть это конечные пользователи.
[27:50.540 --> 27:59.740]  Так, это такая большая картина, которую мы с вами должны понимать для того, чтобы с ней не бояться
[27:59.740 --> 28:08.340]  работать. Так, движемся дальше. Это такая вот самая большая категоризация всего этого. Что есть,
[28:08.340 --> 28:18.140]  мы конечно не все это будем смотреть. Я предлагаю двигаться дальше и попытаться проверить,
[28:18.140 --> 28:27.140]  а насколько вы тестировщики. Тест. Значит, тест заключается в следующем. Смотрите, нам надо
[28:27.140 --> 28:33.580]  протестировать функцию, которая будет проверять следующее. Она принимает на вход числа,
[28:33.580 --> 28:42.900]  а на выход проверяет, являются ли эти числа сторонами треугольника. То есть у нас есть
[28:42.900 --> 29:05.700]  какая-нибудь функция из триангл. Пусть она бул возвращает. Вот у нас есть функция, эфемерная
[29:05.700 --> 29:14.460]  функция. Наша цель будет ее не реализовать, а протестировать ее. То есть вам нужно будет
[29:14.460 --> 29:21.100]  придумать как можно больше входных и выходных данных, на которых можно проверить результат
[29:21.100 --> 29:31.020]  работы этой функции. То есть вам нужно сгенерировать входы и вам нужно сгенерировать выходы. Поехали.
[29:35.700 --> 29:51.660]  В данном случае мы пишем именно тесты, поэтому нам нужно конкретные входные данные и конкретные
[29:51.660 --> 30:02.100]  выходные данные. Так, хорошо, поехали. Ну давайте одну отрицательную. Минус один, два два. Какой
[30:02.100 --> 30:23.780]  ответ должен быть? Ну тут говорит следующее, либо false, либо кидаем exception. Что-что-что? Да, можно. Ну да.
[30:23.780 --> 30:49.980]  3, 4, 5. Да, так это exception. 2, 3, 4 exception. Ну и допустим 1, 2. Еще раз. 6,
[30:49.980 --> 31:03.020]  ну на самом деле смотрите, сразу скажу, что здесь можно сделать перестановки всех элементов. Ну ладно,
[31:03.020 --> 31:21.100]  хорошо. Что? Вот это? Ну я конечно понимаю все, но это для математиков возможно прямоугольный
[31:21.100 --> 31:26.460]  треугольник. Вот для обычных людей это как-то не сильно на треугольник похоже.
[31:33.020 --> 31:51.380]  Да. Да, давайте нормальный треугольник приведем наконец-таки. Да, это называется метод граничного
[31:51.380 --> 32:14.860]  тестирования. Так, 5, 8. Это ответ true. Так, хорошо. Что еще? Наверное граничность. Да, номерик лимитс.
[32:21.380 --> 32:41.660]  Так, еще варианты. На самом деле есть вариант, когда это все в прямую вырождается. Ну да, граничный
[32:41.660 --> 33:05.060]  элемент. Здесь есть еще некоторые фундаментальные тесты. Максинф-1 можно взять в принципе. Я обозначу
[33:06.060 --> 33:20.340]  Так, еще. 0, 0, 0. Важный вариант. Почему? Это точка. Если мы говорим про математиков, то это
[33:20.340 --> 33:26.140]  предельный треугольник, к которому мы можем сместиться. Ну и еще один вариант возникает,
[33:26.140 --> 33:37.100]  допустим, 0, 2, 2. Так, сколько мы сценариев перечислили? 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. В принципе
[33:37.100 --> 33:48.420]  много. А теперь смотрите, есть один тест, который мы с вами упустили. Не-не-не. Реализация такая.
[33:56.140 --> 34:04.580]  Да, переставлять аргументы тоже надо. Потому что, видите, мы говорим, что сумма любых
[34:04.580 --> 34:10.020]  тессуаров должна быть больше, чем третья. И тут как раз в тестах, которые я передавал,
[34:10.020 --> 34:17.300]  эти аргументы, они встают в неверном порядке. В принципе наш тест может легко сломаться на
[34:17.300 --> 34:23.060]  варианте 8, 5, 3. А ответ должен быть false, несмотря на то, что здесь у нас ответ true.
[34:23.060 --> 34:35.220]  Хорошо. То есть мы перечисли с вами большое количество примеров, вот, посчитали результаты,
[34:35.220 --> 34:41.660]  и вот мы с вами достаточно хорошие ребята, потому что классический разработчик покрывает не больше,
[34:41.660 --> 34:45.500]  чем половину тестов. А мы придумали даже намного большее количество тестов,
[34:45.500 --> 34:52.580]  которые у нас могут быть. Теперь давайте, наверное, поговорим, прежде чем мы перейдем
[34:52.580 --> 34:59.260]  с вами к тестированию, каким образом можно проводить тестирование. Вот давайте подумаем,
[34:59.260 --> 35:06.860]  можем ли мы просто написать ассерты? То есть написать функцию triangle и дальше внутри них
[35:06.860 --> 35:25.060]  написать ассерты. Давайте какой-нибудь текстовый редактор возьму. Да, мы можем try-catch,
[35:25.060 --> 35:34.340]  логировать результаты. Нам важно сделать следующее, что если у нас есть какие-то тесты,
[35:34.420 --> 35:43.460]  нам нужно запускать именно все тесты, а не падать на первом. Поэтому, чтобы не делать лишних
[35:43.460 --> 35:48.260]  try-catch, для этого как раз существуют специальные фреймворки для тестирования, которые как раз
[35:48.260 --> 35:54.020]  позволят нам этого избежать. Потому что если мы возьмем с вами какой-нибудь stack trace,
[35:54.020 --> 36:02.740]  давайте где-нибудь пока напишу примеры. Вот тут есть, о господи, здесь есть таймер. Давайте куда-нибудь
[36:02.740 --> 36:26.220]  сюда. Тестер. Мы с вами напишем, я буду писать на питоне. Напишем ассерт
[36:32.740 --> 36:58.820]  так ассерт допустим triangle 5 вот то вот как обработать исключение. Ну да, хочется сказать,
[36:58.820 --> 37:19.700]  что нам нужен try-catch. И вот что-то нужно генерировать вот такое. Образно говоря,
[37:19.700 --> 37:38.100]  какое-то исключение, которое называется test failed error. Ну да, желательно еще бы записывать
[37:38.100 --> 37:52.260]  результаты нашего тестирования. То есть смотрите, main, ну и запускаем. Значит test correct, test not correct.
[37:52.260 --> 37:59.380]  То есть если мы сейчас с вами запустим это все, то у нас, не поверите, все кажется отработает. А нет,
[37:59.380 --> 38:06.260]  вы видите, то есть как бы у нас выскачивает исключение. Если мы следующий раз напишем с
[38:06.260 --> 38:16.580]  вами correct, то будет проблема. Потому что мы не перехватили с вами исключение. Соответственно,
[38:16.580 --> 38:27.060]  здесь придется делать следующее. For test in test correct. Да, видите, здесь прямо функциональный
[38:27.060 --> 38:52.060]  стиль нужен будет. Я к чему и веду, что не надо самопальное писать. Ну да, мы приводим к тому,
[38:52.060 --> 39:07.540]  что нужны фрейворки для тестирования. Чтобы обработать все эти варианты. Вот. Это вот простой
[39:07.540 --> 39:14.860]  вариант. То есть наша цель, чтобы оно запускалось на всех тестах. О, test failed. Ну и дальше нам нужно
[39:14.860 --> 39:21.660]  будет с вами допустим обратиться к имени нашего теста. Вот такой самопальный фреймворк мы с вами
[39:21.660 --> 39:28.740]  написали. Ну и с этим работать очень неудобно. Да, потому что нам приходится делать обвязки.
[39:28.740 --> 39:36.180]  Как раз за счет этого для нас придумали как раз фреймворки тестирования, которые позволяют обеспечить
[39:36.180 --> 39:42.980]  этот функционал. Значит как раз про фреймворки тестирования буду говорить на семинарах. Вот.
[39:42.980 --> 39:49.180]  На лекциях мы все-таки перейдем с вами к часть, так сказать, теоретической составляющей. Так.
[39:49.180 --> 39:55.420]  Теперь давайте немного про литературу. Значит по теме тестирования на самом деле есть достаточно
[39:55.420 --> 40:03.300]  большое количество литературы. И я посоветую как раз посмотреть книги, которые очень полезные.
[40:03.300 --> 40:10.060]  Значит сразу скажу, что это книги можно начинать, если вы хотите прям получить целую фундаментальную
[40:10.060 --> 40:17.340]  базу по тестированию. Это книга Art of Software Testing, Глен Фортмайерс. У нее есть русскоязычный вариант,
[40:17.340 --> 40:21.660]  к сожалению я ее с собой не взял. Я могу в принципе на следующую лекцию принести все эти три книги,
[40:21.660 --> 40:27.700]  которые я посоветую. Значит в нем прямо написано теоретические основы тестирования. Последняя
[40:27.700 --> 40:36.460]  версия, по-моему, вышла в 2011 году, в которой можно явно прям прочитать, там даже есть адаптация к
[40:36.460 --> 40:42.540]  мобильному тестированию мобильных приложений. Значит вторая книжка, это Харри Персеваль,
[40:42.540 --> 40:47.660]  о базе тестинг год. Значит она, не помню как на русский язык, по-моему называется как раз что-то
[40:47.660 --> 40:52.500]  Test Driven Developed with Python. Она рассказывает про методологию Test Driven Developed. В чем она
[40:52.500 --> 41:00.020]  заключается? Она заключается в том, что вы сначала пишете тест, потом пишете код. То есть вы пишете
[41:00.020 --> 41:06.700]  минимальный тест, который не проходит, дальше адаптируете код к тому, чтобы у вас этот тест
[41:06.700 --> 41:13.180]  проходил. Методика интересная. Причем здесь покрываются все уровни тестирования. И третья
[41:13.180 --> 41:17.860]  книга, кстати, от авторов экстремального программирования, про который мы с вами в прошлый раз
[41:17.860 --> 41:27.020]  говорили, про методологию. И ее написал Кен Бэк, один основатель Agila. И в нем как раз рассказывается,
[41:27.020 --> 41:33.140]  как можно внедрять тоже методологию Test Driven Developed через методологию экстремального программирования.
[41:33.140 --> 41:40.540]  Почему полезно именно смотреть на Test Driven Developed? Потому что он как раз раскрывает всю суть
[41:40.540 --> 41:46.700]  тестирования. То есть легче намного писать код тестов не по имеющемуся коду, а как бы делать
[41:46.700 --> 41:51.820]  заранее заготовки перед тем, как писать тест. Потому что если у вас будет какой-то сложный продукт,
[41:51.820 --> 42:00.580]  да, вот такие смотрите. Стена, гора. Нам нужно эту гору перейти. Да, непонятно,
[42:00.580 --> 42:05.380]  как эту гору перейти. Поэтому лучше маленькими шашками приближаться к тому, чтобы проводить
[42:05.380 --> 42:14.300]  тестирование. Вот. Значит, теперь это чтобы почитать. В следующий раз я попробую принести книги,
[42:14.300 --> 42:19.940]  чтобы вы могли их изучить. Значит, теперь давайте поговорим про интересный момент. Вообще,
[42:19.940 --> 42:26.940]  сфера тестирования это отдельная, так сказать, препендикулярная ветка по сравнению с классической
[42:26.940 --> 42:33.020]  разработкой. То есть здесь нужно мыслить по-другому, и здесь идет спецификация по-другому. И вот как раз
[42:33.020 --> 42:39.140]  первое, что стоит знать про тестирование, что по тестированию есть международный стандарт и
[42:39.140 --> 42:48.620]  есть международная сертификация. И как раз этим занимается сервис Aistocube. Значит, у него есть
[42:48.620 --> 42:55.620]  как раз сайт, в котором можно открыть прямо все силобусы. Что такое силобусы? Это программы курсов,
[42:55.620 --> 43:02.820]  которые нам нужно пройти для сертификации. Вот. И как раз здесь видно, что на самом деле в сфере
[43:02.820 --> 43:09.020]  тестирования можно очень сильно развиваться. То есть первый самый уровень это Certified Tester.
[43:09.020 --> 43:20.860]  Если вы откроете вот это вот силобус, давайте мы его откроем. Тест какой-нибудь. Вот Certified Tester.
[43:20.860 --> 43:28.220]  Давайте почитаем условия задач, которые предлагаются решить на экзамене. Давайте
[43:28.220 --> 43:46.380]  поймем, где здесь, есть ли здесь что-то про код. Здесь ничего нету про кодирование. Здесь какие-то
[43:46.380 --> 43:54.700]  соответствия уровней. Вот. И первое, что здесь есть, это допустим вот у вас есть задача, у вас
[43:54.700 --> 44:01.940]  есть численные значения, и вам нужно это. Есть тестовый сценарий. Вот. И вы пытаетесь понять,
[44:01.940 --> 44:11.380]  типа, какой у вас процент покрытия кода теста. То есть какой процент тестовых сценариев вы покрыли.
[44:11.380 --> 44:18.380]  Вот такие задачи на уровне Certified Tester. Здесь не надо писать код. Здесь нужно больше соображать.
[44:18.380 --> 44:26.580]  И тестирование это больше про навык критического мышления. Вот еще один. Вот даже есть диаграмма.
[44:26.580 --> 44:34.940]  Типа, вот у вас есть диаграмма состояний. Какое количество тестовых сценариев необходимо для
[44:34.940 --> 44:40.740]  того, чтобы проверить все переходы. Ну и понятно, написайте эти тестовые сценарии. Здесь тестовый
[44:40.740 --> 44:45.900]  вариант. По факту неплохо было бы написать тестовые сценарии. Вот. То есть вот то, что касается
[44:45.900 --> 44:51.500]  Certified Tester. Если вы, допустим, захотите развиваться в специалистов сферой Quality Assurance,
[44:51.500 --> 44:57.020]  это сфера, в которой находится тестирование, то есть далеко не все из вас станут разработчиками.
[44:57.020 --> 45:03.260]  Но я не знаю. Может быть, кто-то пойдет в менеджеры, кому-то нужно будет управлять. Кому-то нужно будет,
[45:03.260 --> 45:08.980]  кто-то будет писать код. Кто-то будет работать тестировщиком. То есть это вполне возможно.
[45:08.980 --> 45:14.340]  Тогда вы можете идти в разные сферы. То есть если вы идете по кор ветке, то вы начинаете как раз
[45:14.340 --> 45:19.700]  быть управленцем в сфере QA. Если вы идете специалистом, вы можете развиться, допустим,
[45:19.700 --> 45:28.500]  в Automation Testing и в разные индустрии. Как раз вот в правой части Foundation Level'а как раз
[45:28.500 --> 45:35.180]  особенность стоит в том, что вы под определенную сферу пишете разные тесты. Кстати, к слову,
[45:35.180 --> 45:41.100]  вопрос. Почему тестирование зависит от сферы? Как вы думаете, каким тестировщикам на свете жить
[45:41.100 --> 45:44.340]  проще? Android-тестировщиком или iOS-тестировщиком?
[45:52.340 --> 45:59.140]  Так, хорошо. Давайте проведем соц-сопрос. У кого Android? Называйте марку своего телефона.
[45:59.140 --> 46:22.140]  Pixel, Xiaomi, Samsung. А что, все остальные с айфонами? Ничего себе. Ну там, там Poco есть еще, Realme.
[46:22.140 --> 46:28.100]  В общем, количество телефонов на самом деле большое. Вот, и под каждый из телефонов тестировать,
[46:28.100 --> 46:33.140]  это проблема. Особенно с разными марками. То есть, когда мы, допустим, в компании провели
[46:33.140 --> 46:40.300]  тестирование, у нас там просто 10 разных телефонов. Лежит просто в разных уровнях мощности. И мы на них
[46:40.300 --> 46:49.940]  тестируем. С айфонами намного проще. Почему? У вас есть айфон 7, 8, 9, 10, 11, 12, 13, 14, 15. Все.
[46:49.940 --> 46:58.900]  Девания по безопасности, конечно же, больше, но в целом, как бы, протестировать нужно меньшее
[46:58.900 --> 47:18.020]  количество версий. Под чем? Нет, а вдруг какие-нибудь конфликты, допустим, у вас есть какие-то
[47:18.020 --> 47:25.340]  сторонние приложения, которые отжирают какое-то место, графическая оболочка, и так далее. То есть,
[47:25.340 --> 47:30.820]  здесь тоже можно развиваться на разных уровнях. Вот, если мы говорим про Foundation Level Certified
[47:30.820 --> 47:34.980]  Tester, то здесь как раз важно говорить про основы тестирования. Во-первых, понять, что такое
[47:34.980 --> 47:42.100]  тестирование, почему оно необходимо, про 7 принципов обсудить, рассказать, что это за принципы,
[47:42.100 --> 47:48.380]  и дальше рассказать про психологию тестирования. То есть, что для тестирования нужно перестраивать
[47:48.380 --> 47:55.740]  психологию. Дальше здесь, как говорится, про тестирование в рамках software development. Здесь
[47:55.740 --> 48:00.420]  мы можем говорить как раз про уровни тестирования. Вот, и про виды тестирования. Про виды тестирования
[48:00.420 --> 48:07.620]  мы с вами уже рассмотрели один момент. Да, и, кстати, смотрите, здесь как раз важный момент,
[48:07.820 --> 48:15.740]  что для того, чтобы сдать экзамен по тестированию, нужно понимать то, какие методологи разработки
[48:15.740 --> 48:20.940]  существуют. Но мы с вами это как раз уже на предыдущих лекциях рассмотрели. Вот, дальше здесь
[48:20.940 --> 48:24.940]  есть как раз техники тестирования, то есть тестирование черного ящика, белого ящика.
[48:24.940 --> 48:32.620]  Experian-based это в какой-то степени тестирование серого ящика. Вот, и уделяется еще очень важный
[48:32.620 --> 48:37.020]  аспект, посвященный именно статическому тестированию. То есть, тестированию,
[48:37.700 --> 48:45.860]  которое проводится без запуска кода. Вот, это самом деле очень важный процесс тестирования. Так,
[48:45.860 --> 48:52.220]  давайте теперь перейдем к задачам тестирования. К задачам тестирования относятся следующие. Это
[48:52.220 --> 49:00.020]  оценка артефактов нашего продукта. Значит, что может быть в качестве оценки артефактов? Первое,
[49:00.020 --> 49:06.100]  это user story. То есть, это фича, которую мы с вами внедряем. Новая функциональность. Дальше,
[49:06.100 --> 49:10.060]  требования к продукту. То есть, насколько наш продукт относится с требованиями,
[49:10.060 --> 49:16.500]  которые мы прописали. Дальше, оценка дизайна. То есть, вы открываете какой-нибудь сайт в интернет
[49:16.500 --> 49:24.740]  магазине и понимаете, типа, хороший дизайн или нет. Сразу спрошу, не знаю, сейчас актуально это
[49:24.740 --> 49:35.620]  или нет. Кто-нибудь заходил на японские сайты? Вот. Для нас это вообще неадекватный дизайн. Для
[49:35.620 --> 49:43.300]  японцев нормально. То есть, опять же, артефакты могут зависеть от того, в какой реальности мы живем.
[49:43.300 --> 49:52.100]  Вот. И последнее, это оценка кода. Ну, качество кода. То есть, работает он или не работает.
[49:52.100 --> 49:57.740]  Либо оцениваем какие-то не функциональные требования. Значит, следующий момент это верификации того,
[49:57.740 --> 50:04.100]  что требование выполнено. Здесь есть, так сказать, момент, который я хочу обсудить,
[50:04.100 --> 50:11.500]  что существует два аспекта. Первый называется валидацией, второй верификацией. Смотрите,
[50:11.500 --> 50:24.340]  как бы отметить отличие. Представьте себе, что вам нужно набрать текст количеством символов
[50:24.340 --> 50:37.860]  15 тысяч. Вам нужно набрать текст 15 тысяч символов на тему. Что вы можете сделать?
[50:37.860 --> 50:46.980]  Запросить УГПД. Написать текст на 15 тысяч символов. Можете попробовать сами написать текст на
[50:46.980 --> 50:54.980]  тему. Ну, у вас есть тема, допустим, тема весна. Ну, хорошо. Что мы делаем? Мы берем и пишем. Сколько
[50:54.980 --> 51:04.260]  получается? 3000 раз слово весна. Ну, текст на тему весна. То есть, мы с вами провалидировали наш
[51:04.260 --> 51:10.460]  процесс, что у нас текст на тему весна. А дальше процесс верификации заключается в том, что вы
[51:10.460 --> 51:17.860]  оцениваете, насколько адекватно вы все это сделали. Понятно, что текст из трех тысяч слов весна,
[51:17.860 --> 51:23.820]  он вообще неадекватен и, понятно, никуда не пойдет. А вот с точки зрения именно верификации
[51:23.820 --> 51:30.860]  требований мы читаем этот текст, делаем какие-то правки и говорим, как именно подкорректировать.
[51:30.860 --> 51:38.300]  В той же степени, если мы говорим про сдачу технических заданий, то валидация – это выполнение
[51:38.300 --> 51:43.380]  технического задания, заслать его в систему, получить полный балл. Верификация – это пройти
[51:43.380 --> 51:49.980]  процесс код ревью и пройти процесс устной сдачи. Для того, что мы проверифицировали то, что
[51:49.980 --> 52:03.180]  вы освоили эту тему. Третье – это избегание сбоев. Здесь важно разграничить, что такое
[52:03.180 --> 52:15.420]  сбой и что такое дефект. Что такое дефект? Дефект обнаруживается разработчиками. Вы начали
[52:15.420 --> 52:22.500]  локально тестировать ваш процесс, у вас находятся какие-то ошибки. Если вы находите это в процессе
[52:22.500 --> 52:31.300]  разработки или в процессе тестирования вашего ОПО, то это дефект. Если конечный пользователь
[52:31.300 --> 52:38.660]  находят это и сообщает вам, это уже сбой. То есть система работает не так, как предназначено.
[52:38.660 --> 52:45.500]  И обычно, если мы говорим про англоязычную литературу, то дефект пишется как дефект,
[52:45.500 --> 52:59.700]  а сбои пишутся как фейла. И важно различать эти вещи. Наша цель – избегать сбоев. Дальше,
[52:59.700 --> 53:04.940]  естественно, задача тестирования – находить как можно больше сбоев и дефектов. Тестирование как
[53:04.940 --> 53:12.500]  раз заточено под то, чтобы в первую очередь находить сбои и дефектов. Дополнительно еще нам нужно
[53:12.500 --> 53:16.980]  давать какие-то степени уверенности о том, что наш продукт будет работать в каком-то проценте
[53:16.980 --> 53:24.540]  случаев. То есть какие-то рамки выдавать. Предоставлять информацию основателям. Что такое
[53:24.540 --> 53:29.580]  основатели? Это продукт универа или заказчики, которые мы делали. Что у нас вот такой уровень
[53:29.580 --> 53:35.380]  тестирования в таком-то проценте случаев? Кстати, важный момент – не называть никогда число.
[53:35.380 --> 53:45.140]  Число чего? Процент уверенности. Точное число. То есть вы, когда говорите по срокам,
[53:45.140 --> 53:51.420]  вы никогда не должны называть именно точное число. Почему?
[53:51.420 --> 54:05.980]  Допустим, он говорит, что проект будет готов через две недели. Почему так не надо делать?
[54:05.980 --> 54:13.180]  Да, конечно, что-то может пойти не по плану. Соответственно, лучше называть диапазон.
[54:13.180 --> 54:20.100]  От 2 до 3 недель, от 2 до 4 недель. Понятно, что чем ближе мы к стадии завершения проекта,
[54:20.340 --> 54:26.580]  тем уже у нас диапазон. То и так же степень уверенности мы говорим от такого-то до такого-то процента.
[54:26.580 --> 54:37.620]  Потому что иначе потом ожидания могут не совпасть с реальностью. И последнее – это
[54:37.620 --> 54:44.260]  согласование с утвержденными стандартами качества. Ваш продукт нужно будет сертифицировать в конце
[54:44.260 --> 54:52.180]  сдачи. Поэтому важно понимать, какие стандарты качества существуют. И здесь мы как раз должны
[54:52.180 --> 54:58.620]  перейти к тому, какие стандарты качества существуют. Давайте вопросы по задачам тестирования.
[54:58.620 --> 55:14.100]  Есть ли они? Это основное то, что мы с вами должны зафиксировать. Давайте перейдем к
[55:14.100 --> 55:20.900]  следующей части. Эта часть посвящена тому, что на самом деле тестирование – это большая отрасль.
[55:20.900 --> 55:28.020]  И на самом деле тестировщики не любят, когда их называют тестировщиками. Они любят себя
[55:28.020 --> 55:33.980]  величать QA-инженерами. И это действительно так. Если мы говорим про качество нашего продукта,
[55:33.980 --> 55:40.380]  то здесь выделяют три основных вещи. Первая – это Quality Assurance. Это QA. Это достаточно большой
[55:40.380 --> 55:49.540]  процесс. После этого у нас есть QC – Quality Control. Есть тестирование. И они отличаются по целям.
[55:49.540 --> 55:57.140]  Давайте пройдемся. В качестве тестирования, если мы говорим про тестирование, то наша цель – находить
[55:57.140 --> 56:05.780]  и решать сбои и дефекты. На чем мы фокусируемся при этом? Мы с вами фокусируемся на нижнем уровне.
[56:05.780 --> 56:13.100]  Мы фокусируемся с вами на коде. Тестируем больше код. И дизайн нашей системы. Смотрите,
[56:13.100 --> 56:17.380]  аккуратнее. Дизайн – это не только то, как окна нарисованы, но это еще и архитектурные
[56:17.380 --> 56:25.060]  какие-то решения. Это называется System Design. Дальше, что тестируем? Что мы делаем? Наша цель – находить
[56:25.060 --> 56:33.860]  дефекты и сбои. Кто обычно за это отвечает? Обычно за это отвечают тест-инженеры и разработчики.
[56:34.020 --> 56:39.620]  Их цель – находить как можно больше дефектов и сбоев. А когда проходят? Это происходит на
[56:39.620 --> 56:47.020]  стадии тестирования, параллельно со стадией разработки. Как раз в металлогии Agile мы как
[56:47.020 --> 56:53.820]  раз во время спринта в Scrum проводим тестирование. Дальше у нас следующий уровень – Quality Control. В чем
[56:53.820 --> 57:01.140]  заключается Quality Control? Мы пытаемся убедиться, что наш продукт отвечает всем требованиям и
[57:01.140 --> 57:06.180]  спецификациям перед тем, как мы его выпускаем. На чем мы фокусируемся? Мы с вами фокусируемся не
[57:06.180 --> 57:12.540]  только на исходном коде, но на всем проекте целиком, всем продуктам. Потому что у нас может быть
[57:12.540 --> 57:18.940]  допустим система сопровождения какая-то, у нас может быть какие-то агитационные рекламы и так
[57:18.940 --> 57:25.300]  далее. При этом именно на стадии Quality Control у нас осуществляется верификация, про которую мы с
[57:25.300 --> 57:30.700]  вами говорим. Кто ответственен за этот весь процесс контроля за качеством? Вся команда.
[57:31.620 --> 57:38.540]  Вся команда проекта. Когда это обычно происходит? Обычно все эти стадии осуществляются на уровне
[57:38.540 --> 57:47.220]  приемочного тестирования либо перед выкаткой новой версии продукта. А дальше у нас есть сам
[57:47.220 --> 57:54.060]  большой момент – Quality Assurance. То есть нам нужно настроить с вами правильные процессы, указать
[57:54.060 --> 58:01.420]  стандарты качества для того, чтобы как раз цель того, что если вы правильно настроите ваши
[58:01.420 --> 58:08.140]  процессы, то скорее всего у вас будет меньше сбоев. Такая причина связи. И здесь как раз мы
[58:08.140 --> 58:12.940]  фокусируемся на процессах взаимодействия в нашей команде. То есть опять же от методологии разработки
[58:12.940 --> 58:18.940]  будет сильно зависеть то, какое количество багов у нас будет и какая будет их критичность. Потому
[58:19.020 --> 58:25.780]  что водопадные модели у нас, если прилетит какой-нибудь баг на стадии тестирования, то это все. Можно
[58:25.780 --> 58:31.660]  там проект закрывать. То в гибких методологиях можно адаптироваться к этому и двигаться дальше.
[58:31.660 --> 58:40.100]  Значит цель как раз предотвращение наступления багов. То есть образно говоря, если у нас возникают
[58:40.100 --> 58:46.660]  какие-то переработки, то понятно люди, допустим, меньше начинают фокусироваться на самом коде и
[58:46.660 --> 58:52.060]  просто усталый человек может допустить намного больше ошибок. Особенно это критично, если мы
[58:52.060 --> 58:58.420]  работаем на каком-нибудь драмоопасном или опасном для жизни производстве. Кто за это ответственный?
[58:58.420 --> 59:05.860]  Ответственный за это вся команда и заказчики. То есть заказчики, именно основные заказчики,
[59:05.860 --> 59:12.540]  если мы идем продавать это какому-то другому бизнесу. То есть они нам говорят, какие процессы
[59:12.540 --> 59:19.180]  они могут сделать, какие процессы мы можем сделать. И важно, когда это происходит, это происходит во все
[59:19.180 --> 59:25.500]  время разработки нашего продукта. То есть это весь цикл софтвердевелопмента, про который мы с вами
[59:25.500 --> 59:36.420]  говорили. Поэтому все-таки ищут обычно не тестировщиков, а кьюе инженеров для того, чтобы еще и настраивать
[59:36.420 --> 59:47.940]  качество нашего процесса. Давайте вопросы по этой табличке. Опять же некоторые теоретические
[59:47.940 --> 01:00:00.500]  сведения, просто чтобы вы понимали, почему QA это не только про тестирование. И зачастую, если вы...
[01:00:00.500 --> 01:00:08.620]  Давайте я лучше вам вопрос задам. Что из этого можно автоматизировать? Из этих трех столбцов?
[01:00:08.620 --> 01:00:21.660]  Да, только тестинг. Quality Control и Quality Assurance это право взаимодействия. Вот, значит теперь давайте
[01:00:21.660 --> 01:00:27.660]  еще раз проговорим про стандарты качества. Их на самом деле очень много. И есть специальный
[01:00:27.660 --> 01:00:33.100]  стандарт. Это старая версия стандарта. Так, давайте опущу экран, чтобы видно нижнюю часть слайдов.
[01:00:33.100 --> 01:00:43.380]  Это стандарт качества ISO 9126. То есть это сертификация про качество программного продукта. И вот наша
[01:00:43.380 --> 01:00:52.460]  цель в данный аспект рассмотреть как раз особенно связанные с поддерживаемостью программного кода.
[01:00:52.460 --> 01:01:00.340]  То есть что такое поддерживаемость программного кода? То есть вы приходите в компанию, и как вы
[01:01:00.340 --> 01:01:03.980]  думаете, вы каждый раз будете делать кит и нит и писать проект с нуля?
[01:01:03.980 --> 01:01:26.660]  Да, по большей части вам придется в 80 процентов времени читать код и, дай бог, в 20 процентов писать
[01:01:26.660 --> 01:01:31.420]  новый код. То есть вам придется разбираться в старом коде. А для того, чтобы старый код был
[01:01:31.420 --> 01:01:37.420]  удобен, нам нужен как раз поддерживаемость этого кода. Это как раз верхняя ветка, связанная с
[01:01:37.420 --> 01:01:43.020]  им мейнтенабилити. И, собственно, здесь у нас как раз есть некоторые составные части, заключающиеся в
[01:01:43.020 --> 01:01:49.340]  том, что у нас в им мейнтенабилити входят changeability, то есть возможность изменения нашего кода. Про это
[01:01:49.340 --> 01:01:55.060]  как раз мы говорим, что у нас наша архитектура должна быть гибкой. Дальше мы должны уметь
[01:01:55.060 --> 01:01:59.660]  анализировать нашу архитектуру, анализировать наш продукт, то есть считать какие-то метрики
[01:01:59.780 --> 01:02:05.740]  качества. Потому что если вы метрики не можете замерить, увы, сложно куда-то двигаться дальше.
[01:02:05.740 --> 01:02:11.020]  Потому что если у вас какое-то есть число, на которое вы можете опираться, с этим жить намного
[01:02:11.020 --> 01:02:18.660]  проще, а не про какие-то эфемерные знания. Дальше, значит, следующая вещь, тут очень важно,
[01:02:18.660 --> 01:02:27.060]  это аспект, это testability. То есть вы проверяете, насколько ваш код способен к тестированию,
[01:02:27.060 --> 01:02:32.740]  насколько вы его можете протестировать. И последняя вещь, это стабильность, то есть насколько ваш
[01:02:32.740 --> 01:02:42.620]  код ведет себя стабильно от изменения к изменению. Здесь есть еще другие стандарты качества. Я думаю,
[01:02:42.620 --> 01:02:51.460]  мы про них поговорим чуть позже. Наша цель — обратить то, где здесь находится тестируемость,
[01:02:51.460 --> 01:03:04.100]  в какой ветке? На вот этом круге. Давайте даже преувеличу.
[01:03:04.100 --> 01:03:23.460]  Ну да, они немножко съехали. И, собственно, если мы говорим про testability, то он на самом деле
[01:03:23.460 --> 01:03:29.820]  заключает в себе большое количество составных частей. Значит, первое — это testability, возможность
[01:03:29.820 --> 01:03:36.820]  к тестированию кода. Дальше, analyzability, вы можете проанализировать ваш код. И modifability,
[01:03:36.820 --> 01:03:41.660]  то есть насколько ваш код может быть модифицирован. И вот здесь как раз на этой
[01:03:41.660 --> 01:03:47.820]  диаграмме показывается, к чему это скатывается. То есть смотрите, от чего зависит тестированность
[01:03:47.820 --> 01:03:56.500]  кода. Оно зависит от, собственно, устойчивость к сбоям и от сложности. То есть смотрите,
[01:03:56.500 --> 01:04:02.580]  что получается. Если наш код сложный, то его сложно протестировать. А если код сложно
[01:04:02.580 --> 01:04:10.900]  протестировать, то его сложно поддерживать. Поэтому как раз если мы говорим про метрики качества,
[01:04:10.900 --> 01:04:17.380]  то их как раз можно отслеживать. Важная метрика качества — это logical lines of code. То есть сколько
[01:04:17.380 --> 01:04:24.580]  у вас логических операций есть в вашем проекте. То есть вот такая диаграмма. Главный вывод из нее
[01:04:24.580 --> 01:04:30.500]  такой, чтобы код был поддержан, он должен быть тестирован. И в разных сферах на самом деле
[01:04:30.500 --> 01:04:35.980]  тестируемость кода проверяется по-разному. То есть в классической разработке тестировать код достаточно
[01:04:35.980 --> 01:04:40.900]  просто. Если мы переходим там, допустим, в front-end, там тестировать код намного сложнее,
[01:04:40.900 --> 01:04:51.620]  потому что мы поднимаемся на более высокие уровни. Так, хорошо. Есть ли вопросы по этому тезису?
[01:04:54.580 --> 01:05:04.460]  Так что можете открыть какой-нибудь свой код по алгоритмам и попробуйте его протестировать. Не
[01:05:04.460 --> 01:05:10.220]  так, как вы обычно тестируете, а именно выделив функции, и тогда вы поймете, что вы можете
[01:05:10.220 --> 01:05:15.100]  локальные функции тоже протестировать. Так, давайте мы с вами перейдем к семи принципам
[01:05:15.100 --> 01:05:22.100]  тестирования. Они достаточно фундаментальные, и их тоже стоит разобрать. Первый из семи
[01:05:22.100 --> 01:05:26.260]  принципов тестирования заключается в том, что тестирование показывает наличие дефектов,
[01:05:26.260 --> 01:05:35.540]  а не их отсутствие. Значит, есть классический пример. Вы идете к врачу, врач ничего не обнаружит,
[01:05:35.540 --> 01:05:46.220]  говорит, что вы здоровы. А вы чихаете, у вас температура и так далее. Просто врач решил
[01:05:46.220 --> 01:05:55.340]  не смотреть на этот аспект. Бывает. Да, грубо говоря, тестирование именно старается показать
[01:05:55.340 --> 01:06:09.980]  дефекты. Если у вас все тесты прошли, это не значит, что у вас нету сбоя. Они, в принципе,
[01:06:10.060 --> 01:06:16.820]  могут быть. И нужно чаще отслеживать. Второй момент, очень важный, заключается в том,
[01:06:16.820 --> 01:06:24.220]  что избыточное тестирование невозможно. Невозможно протестировать все и все. Классический
[01:06:24.220 --> 01:06:38.820]  пример. Представьте себе, что у вас есть код с 10 ИФами подряд. И ВЗН-ЭЛС. Потом вы выходит,
[01:06:38.820 --> 01:06:49.300]  делаете еще раз ИВЗН-ЭЛС, потом еще раз выходит ИВЗН-ЭЛС. Делаете. Сколько у вас возможных
[01:06:49.300 --> 01:07:02.300]  вариантов действий? 2 в десятый. Здесь 2, здесь 2, здесь 2, здесь 2. Получаем 1024 возможных вариантов.
[01:07:02.300 --> 01:07:10.860]  Если у вас еще десяток ИФов добавится, то сколько возможных вариантов уже будет? Уже много.
[01:07:10.860 --> 01:07:18.340]  Понятно, что все это тестировать это перебор. То есть у нас получается 2 в 20-ый вариант,
[01:07:18.340 --> 01:07:23.100]  2 в 30-ый вариант. А теперь, если вы посмотрите в возможное количество сценарий в реальной
[01:07:23.100 --> 01:07:27.980]  программе, в реальном продукте, их может быть реально большое количество. И понятно,
[01:07:28.060 --> 01:07:32.260]  что все это невозможно протестировать. Поэтому нам нужно будет выделять аспекты,
[01:07:32.260 --> 01:07:39.580]  которые мы с вами будем тестировать. И дальше, из-за того, что избыточное тестирование невозможно,
[01:07:39.580 --> 01:07:46.620]  оно может возникнуть тогда, когда вы неверно определили, что именно тестировать. А когда
[01:07:46.620 --> 01:07:55.060]  мы могли определить неверно, что нам тестировать? Когда мы принялись за это слишком поздно. У нас
[01:07:55.180 --> 01:08:00.820]  сложные продукты, мы не понимаем, что именно тестировать. Поэтому раннее начало тестирования
[01:08:00.820 --> 01:08:10.300]  экономит время и деньги, и даже нервы. В чем это заключается? Вы берете и смотрите, какое количество
[01:08:10.300 --> 01:08:17.860]  времени вы тратите на тестирование в зависимости от запуска вашего продукта. Можете провести
[01:08:17.860 --> 01:08:25.380]  мысленный эксперимент. А даже не мысленный, а практический. Построим график зависимости
[01:08:25.380 --> 01:08:31.660]  количества нервов, которые вы тратите в зависимости от времени, от старта продукта.
[01:08:31.660 --> 01:08:40.140]  Представьте себе, что вы пишете код. Очень просто код. Думаете, 2 плюс 2 написал. Написал какие-то
[01:08:40.140 --> 01:08:45.340]  простые вещи. А потом начинаете писать какие-то сложные вещи, начинаете интегрировать такие,
[01:08:45.340 --> 01:08:51.460]  вы читаете. Этот код невозможно тестировать. У вас зависимость количества потраченных нервов на
[01:08:51.460 --> 01:08:58.300]  единицу времени, в зависимости от времени, будет расти по экспоненте. Сначала код кажется просто,
[01:08:58.300 --> 01:09:05.140]  простым. Потом вы понимаете, что через месяц, через два вы не можете прочитать код, и вы даже
[01:09:05.140 --> 01:09:11.340]  не можете подступиться к нему тестом. У вас есть первые задачи по алгоритмам, которые вы сдавали?
[01:09:11.460 --> 01:09:19.580]  В первом семестре. Причем попробуйте открыть код, который вы писали ближе к началу семестра первого,
[01:09:19.580 --> 01:09:31.540]  и попробуйте его прочитать, его протестировать. Я думаю, что, может быть, вы мало чего поймете.
[01:09:31.540 --> 01:09:39.500]  Да, много изменилось в то время. Но если вы начнете внедрять тестирование раньше,
[01:09:39.980 --> 01:09:48.940]  вы не поверите, у вас произойдет следующий эффект. Знаете, по опыту своего преподавания я скажу,
[01:09:48.940 --> 01:09:56.100]  что люди не любят писать теста. Точнее, не понимают, как к ним приступиться. Поэтому количество нервов,
[01:09:56.100 --> 01:10:03.900]  которое тратится на единицу времени, вначале оно будет какое-то такое. Но потом со временем,
[01:10:03.900 --> 01:10:12.060]  как только вы начинаете осваиваться, либо вы начинаете материть эти тесты, и у вас линия идет
[01:10:12.060 --> 01:10:20.020]  уже по меньшей экспоненте, либо вы, наоборот, свыкаетесь со временем, и у вас эта линия идет вот
[01:10:20.020 --> 01:10:27.020]  таким образом. То есть реально большой проект может быть хорошо протестирован. То есть вы
[01:10:27.020 --> 01:10:32.140]  спускаетесь до какого-то уровня и начинаете комфорт себя чувствовать. В итоге, вместо того,
[01:10:32.140 --> 01:10:45.780]  когда у вас горит дедлайн, вы спокойно спите. Выбор вот такой. Вот. Значит, смотрите,
[01:10:45.780 --> 01:10:50.940]  еще один важный аспект протестирования. Он касается именно классической разработки.
[01:10:50.940 --> 01:10:58.060]  Вот смотрите, давайте представим, что у нас есть график. Количество рублей,
[01:10:58.060 --> 01:11:04.300]  которые мы тратим за единицу времени в зависимости от времени. Значит,
[01:11:04.300 --> 01:11:11.220]  представим себе, что мы тратим количество рублей на разработку. Вот это у нас график разработки.
[01:11:11.220 --> 01:11:19.060]  Как вы думаете, количество денег на тестирование, как будет относиться?
[01:11:19.060 --> 01:11:32.700]  Да, проект должен развиваться, но при этом важно, чтобы он не заходил за разработку. То есть все-таки
[01:11:32.700 --> 01:11:38.420]  наша цель именно двигать наш проект вперед, а не поддерживать текущую статус-кво. Если мы не
[01:11:38.420 --> 01:11:46.460]  начинаем делать раннее тестирование, то у нас, опять же, графика затрата ресурсов на тестирование
[01:11:46.460 --> 01:11:52.060]  будет расти намного больше. Да, но смотрите, все, опять же, зависит от того, какой у нас проект.
[01:11:52.060 --> 01:11:59.940]  Если нам нужно дяде Вася склепать простой магазин, возможно, его и не нужно тестировать. То есть вам
[01:11:59.940 --> 01:12:06.500]  нужно отдать просто проект под заказ, держи, все готово, пожалуйста. Тогда можно еще хоть как-то
[01:12:06.500 --> 01:12:12.220]  избежать тестирования, но если мы дальше развиваем наш продукт, то все-таки лучше закладывать базу
[01:12:12.220 --> 01:12:23.620]  для тестирования. Хорошо, следующий. Правила Парета или правила 80 на 20. В 20 процентах кода
[01:12:23.620 --> 01:12:32.180]  содержится 80 процентов дефектов. То есть обычно дефекты находятся в основной части вашего
[01:12:32.180 --> 01:12:39.140]  программного кода. Допустим, как раз вы не поверите, большая часть багов и дефектов
[01:12:39.140 --> 01:12:45.780]  фахчека находятся вот как раз в ядре этого кода. Вы, наверное, уже могли находить дефекты.
[01:12:45.780 --> 01:12:52.900]  В большом количестве они завязаны как раз под то, что проблемы есть в ядре, которое нужно править.
[01:12:52.900 --> 01:13:00.860]  Допустим, нам приходится снимать посылки. Да, то есть это просто возможность, там условие if стоит,
[01:13:00.860 --> 01:13:08.260]  что если условие такое, то все, мы не позволяем делать проверку. То есть это какая-то или, допустим,
[01:13:08.260 --> 01:13:13.180]  кнопка отправить на ревью, которая, по идее, должна работать только тогда, когда у вас определенные
[01:13:13.180 --> 01:13:19.660]  статусы и там показываются тогда, когда у вас там появляется день до дедлайна. Просто этой логики
[01:13:19.660 --> 01:13:28.460]  еще нету. Вот, это как раз все находится в ядре. Значит, следующий принцип — это парантокс пестицида,
[01:13:28.460 --> 01:13:34.820]  он и называется. Старые тесты не помогают находить новые дефекты. Образно говоря, оно говорит
[01:13:34.820 --> 01:13:41.300]  следующее — не пишите теста, что 2 плюс 2 равно 4. Не проверяйте этого. Лучше ищите новые тесты,
[01:13:41.300 --> 01:13:49.140]  которые будут проверять ваш функциональность. То есть по факту кодовая база тестов развивается
[01:13:49.140 --> 01:13:58.540]  параллельно с кодовой базой вашего продукта. Так, это был пятый принцип. Шестой принцип очень важный,
[01:13:58.540 --> 01:14:03.180]  про него мы тоже сказали. Тестирование зависит от контекста, зависит от методологии разработки и
[01:14:03.180 --> 01:14:08.340]  от сферы разработки. То есть, образно говоря, если мы работаем с вами в сфере мобильной разработки,
[01:14:08.340 --> 01:14:13.100]  мы поняли, что у нас тестирование под Android и под iOS разные. Если мы находимся в игровой сфере,
[01:14:13.100 --> 01:14:18.620]  то у нас появляется альфа- и бета-тестирование, в котором мы собираем огромное количество разных
[01:14:18.620 --> 01:14:26.060]  отзывов. Более того, сейчас в игровой индустрии возник лайфхак под названием Early Access.
[01:14:26.060 --> 01:14:36.300]  Если мы говорим про искусственный интеллект, то нам нужно сферы этического использовать. То есть нам
[01:14:36.300 --> 01:14:42.060]  нужно будет проверять лицензионные требования. И там бывают забавные моменты. Если мы говорим про
[01:14:42.060 --> 01:14:48.580]  современные нерастевые модели, они по факту запоминают тот контекст, который есть. И вы пишете
[01:14:48.580 --> 01:14:53.620]  «хочу сгенерировать картинку по описанию», а дальше у вас в правом нижнем углу выплывает
[01:14:53.620 --> 01:15:01.580]  этот водяной знак какой-нибудь компании. То есть вы использовали для обучения нейросети как раз
[01:15:01.580 --> 01:15:08.860]  картинки из этого сайта, хотя не уведомили о компании. Такие кейсы реально бывают,
[01:15:08.860 --> 01:15:16.860]  и они уже разбираются в судебном порядке. И последний принцип заключается в следующее.
[01:15:16.860 --> 01:15:26.660]  Отсутствие ошибок не панацея. Значит, смотрите, здесь что сказано. Если переводить с английского
[01:15:26.660 --> 01:15:36.380]  языка, это говорит следующее. Error absence is fallacy. То есть неверное рассуждение. Я перевел его по
[01:15:36.380 --> 01:15:43.060]  другому. Отсутствие ошибок – это не панацея от всех болезней. Что это означает? Если у вас код
[01:15:43.060 --> 01:15:49.500]  максимально протестирован, в нем нет ошибок, вам кажется все. То есть вы избрали 99% багов,
[01:15:49.500 --> 01:15:56.180]  но при этом вы так спроектировали ваш проект, что им пользоваться просто невозможно. То есть вы
[01:15:56.180 --> 01:16:01.540]  говорите «все, у нас есть», но при этом кривой графический интерфейс, кривая логика действий,
[01:16:01.540 --> 01:16:08.180]  ничего не работает. То есть чисто над тестировать и чисто на том, затачиваться на основном аспекте,
[01:16:08.180 --> 01:16:16.180]  что тестирование должно ходить как можно больше ошибок, не надо. То есть нужно гарбонично развивать
[01:16:16.180 --> 01:16:28.220]  наш проект. Так, хорошо. Есть ли вопрос по принципам тестирования? Надо закладывать именно
[01:16:28.220 --> 01:16:36.420]  эти принципы в свой аспект. Так, следующий момент. Давайте подумаем, почему Colteo Assurance
[01:16:36.420 --> 01:16:52.740]  инженера и разработчики должны быть разными людьми. Да, абсолютно верно. Разработчики
[01:16:52.740 --> 01:16:59.300]  акцентируют на том, чтобы делать новый продукт, развивать это все. А Colteo Assurance инженеры выступают
[01:16:59.300 --> 01:17:05.940]  некоторыми критиками, которые это делают. И поэтому разработчики считают, что их код работает
[01:17:05.940 --> 01:17:10.980]  корректно. Тут можно вспомнить любой пример, который у вас есть. Вы можете вспомнить школьные
[01:17:10.980 --> 01:17:14.740]  сочинения, можете вспомнить рефераты, которые вы сдавали. Кстати, вы сдавали рефераты?
[01:17:14.740 --> 01:17:26.340]  Не доводилось? Счастливые люди. Поэтому, как бы, вы сдаете, а потом вам кажется, что это шедевр,
[01:17:26.340 --> 01:17:33.380]  вы написали, сдали, все замечательно. Приходите, а там оценка не очень приятная. Поэтому, слушайте,
[01:17:33.380 --> 01:17:38.340]  важный момент. Если мы говорим про стадию тестирования, важно не критиковать друг друга и
[01:17:38.340 --> 01:17:45.380]  понимать, что, зачастую, если вы сами проводите ревью, вам нужно критиковать именно код,
[01:17:45.380 --> 01:17:52.020]  не переходить на личность. И постараться содействовать в нейтральном ключе, потому что процесс
[01:17:52.020 --> 01:17:58.820]  ревью, он достаточно нервный. Очень нервный. Потому что в некоторых моментах читаешь код и
[01:17:58.940 --> 01:18:07.140]  сразу подчеркну, что когда мы читаем код, мы стараемся все-таки проводить именно аспекты,
[01:18:07.140 --> 01:18:14.900]  связанные с тем, как это все написано. Большая часть это именование переменных, выделение функций и так
[01:18:14.900 --> 01:18:22.940]  далее. Ну, читаем мы. Давайте классический пример, который я видел в некоторых аспектах.
[01:18:29.140 --> 01:18:32.700]  Я видел вот такую вот переменную в какой-то момент.
[01:18:44.260 --> 01:18:47.940]  А, давайте где-нибудь это. Давайте я код напишу лучше.
[01:18:55.300 --> 01:18:57.340]  Вот такая переменная у нас появляется в коде.
[01:18:58.820 --> 01:19:24.020]  Ну, это да, про ядро линкса согласен. Я понимаю следующее, что человек, который это писал,
[01:19:24.140 --> 01:19:35.500]  он сказал следующее, что это текущие иксы. Текущие координаты иксов. Возможно. Но возможно,
[01:19:35.500 --> 01:19:51.940]  что это футболка для курицы размером XS. Ну, курица. Ну да, мы можем зайти в какой-нибудь Google
[01:19:51.940 --> 01:20:19.100]  Translate и посмотреть. Ну, маленькая дворняшка. Все. Ну, поэтому нужно, вот. И, собственно,
[01:20:19.100 --> 01:20:24.980]  здесь важно сказать, что, допустим, я не понимаю названия этой переменной. Пожалуйста,
[01:20:24.980 --> 01:20:32.740]  можете использовать более полное название. То есть стараться как раз содействовать в нейтральном
[01:20:32.740 --> 01:20:37.700]  ключе. Я как раз про это и говорю. Так, у нас осталось сколько минут? У нас, кажется, осталось
[01:20:37.700 --> 01:20:48.620]  три минуты, да, где-то. Поэтому давайте я покажу вот эту картинку, и мы с вами, а? Да. Собственно,
[01:20:48.620 --> 01:20:54.380]  познакомимся с вами с пирамидой тестирования. Вот она. Значит, юнит-тестирование, интеграционное
[01:20:54.380 --> 01:20:59.780]  тестирование, системное тестирование и приемочное тестирование. Значит, на нижнем мы тестируем с
[01:20:59.780 --> 01:21:03.740]  вами маленькие модули компонента класса. Интеграционное тестирование как раз позволяет
[01:21:03.740 --> 01:21:08.340]  проводить взаимодействие между несколькими классами. В системном тестировании, смотрите,
[01:21:08.340 --> 01:21:13.740]  мы тестируем всю программу целиком. Но важно, смотрите, важный аспект соиска в том, что в
[01:21:13.740 --> 01:21:21.660]  системном тестировании мы тестируем программу в виде сферический конь в вакууме. Что это означает?
[01:21:21.660 --> 01:21:28.700]  Это означает, что мы не выпускаем в реальную, в реальную систему. К примеру, вы запустили вашу
[01:21:28.700 --> 01:21:36.380]  программу, вы написали ваш проект на линуксе. А запускаться он должен под Windows. Тогда
[01:21:36.380 --> 01:21:41.620]  системное тестирование позволяет в принципе запустить его под линуксом. А вот приемочное
[01:21:41.620 --> 01:21:55.220]  тестирование будет проверять, запускается ли ваш код под Windows. Да, именно точно. Именно так,
[01:21:55.220 --> 01:22:00.100]  что система тестирования просто запускается на Windows, а в приемочном тестировании запускается ли
[01:22:00.100 --> 01:22:07.700]  он на Windows определенной версии с поддержкой вот таких браузеров. И дополнительно как раз мы
[01:22:07.700 --> 01:22:12.620]  будем говорить про эти уровни тестирования и практически посмотрим, как работает с
[01:22:12.620 --> 01:22:17.340]  юнитестированием. На семинарах будут рассказывать, как работает с юнитестированием, с интеграционным
[01:22:17.340 --> 01:22:22.700]  тестированием. Я постараюсь тогда на лекцию принести пример с системным тестированием и покажу,
[01:22:22.780 --> 01:22:30.460]  как можно тестировать приложение в браузере. Что есть эмуляторы браузеров, которые можно
[01:22:30.460 --> 01:22:39.140]  запускать. И проводить антическое тестирование. Так, давайте вопросы по сегодняшнему занятию.
[01:22:39.140 --> 01:22:56.380]  Хорошо, если нет вопросов, тогда всем спасибо за внимание и тогда в следующий раз будем продолжать
[01:22:56.380 --> 01:22:56.900]  тему.
