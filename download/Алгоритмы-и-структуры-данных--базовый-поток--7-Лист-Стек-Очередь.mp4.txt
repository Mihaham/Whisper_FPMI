[00:00.000 --> 00:13.520]  Сегодня у нас тема с вами. Она такая, находится между алгоритмами и плюсами. Почему? Потому что
[00:13.520 --> 00:22.400]  мы с вами наконец-то уходим от сортировок и приходим к новым вещам, которые помогут нам
[00:22.400 --> 00:31.640]  вообще понять некоторые механизмы того, как работать с данными. Сортировки это были первые
[00:31.640 --> 00:37.360]  такие наши попытки как-то характеризовать массивы данных, как-то их упорядочить,
[00:37.360 --> 00:42.360]  что-то с ними сделать для того, чтобы вообще работать с ними далее. То есть сортировка сама
[00:42.360 --> 00:48.320]  в своем представлении не то чтобы сильно много ролей и сильно важности вам не давало, но в случае
[00:48.320 --> 00:53.800]  если вы отсортируете какой-то конкретный массив и дальше уже сделаете какие-то с ним действия,
[00:53.800 --> 00:58.240]  это будет гораздо быстрее, чем вы искали какие-то там элементы и что-то с ним пытались сделать.
[00:58.240 --> 01:05.240]  И существуют различные подходы к данным, к тому, что нам вообще в принципе необходимо,
[01:05.240 --> 01:15.400]  и это радует. И мы с вами пройдем достаточно много еще как минимум в этом семестре различных
[01:15.400 --> 01:24.760]  структур данных, которые нам помогут в той или иной мере, в тот или иной момент. Но сегодня мы с
[01:24.760 --> 01:42.720]  вами будем говорить про достаточно простые вещи. Это листы, стек и очередь. Лист, стек и очередь.
[01:42.720 --> 01:48.920]  Ну в какой-то степени можно сказать, что мы еще поговорим про дек, если у нас останется время. Но
[01:48.920 --> 01:55.240]  сразу скажу, дек существует не в таком виде в плюсах, поэтому все, что вы могли знать до этого,
[01:55.240 --> 02:10.440]  это не совсем правда. Вот, начнем с простого. Смотрите, у нас есть массив. Что такое массив?
[02:10.440 --> 02:19.280]  Это порядочные элементы в памяти, которые являются еще однотиповыми. То есть, если у нас
[02:19.280 --> 02:25.000]  массив n-тов, то мы храним только n-ты, а если у нас там массив doppelhoff, мы храним только doppelhoff.
[02:25.000 --> 02:33.240]  Но главное, что они подряд в памяти. Что это нам вообще позволяет делать с ними? Как вы думаете,
[02:33.240 --> 02:42.400]  что хорошо в массиве? Ну это уже относится к типу данных. Меня интересует сам массив. Ну
[02:42.400 --> 02:54.280]  давайте напишем какие-нибудь чиселки, не знаю. 3, 2, 2, 4, 7, 9, 3. Как вы думаете, такой человек учится
[02:54.280 --> 03:03.000]  в стихе или нет? Кто знает, вдруг это чей-то прогноз или мой. Все бывает. В общем-то, смотрите,
[03:03.000 --> 03:11.000]  вот у нас есть какой-то массив данных, оценок, не важно чего. Что мы умеем быстро с ними делать?
[03:11.000 --> 03:19.080]  Брать по индексу. А что такое взять по индексу какой-то элемент? Это же то же самое,
[03:19.080 --> 03:29.800]  что разыменовать А-плюсы. Согласны? Помните такой из плюсов? Вот, это мы умеем делать быстро. Это
[03:29.800 --> 03:38.320]  делается за О от единички. Согласны? То есть мы можем обратиться к n-тому элементу, к i-тому
[03:38.320 --> 03:45.920]  элементу за О от единицы. Это то, что позволяет нам использовать массивы как оптимальную структуру
[03:46.320 --> 03:55.480]  данных в случае, если мы обращаемся постоянно к элементам. Но существуют проблемы другого
[03:55.480 --> 04:02.840]  характера. Предположим, что мне нужно взять и удалить какой-то элемент из массива. Как я это буду
[04:02.840 --> 04:13.480]  делать? Я должен сдвинуть абсолютно все элементы на один. То есть, если я хочу с вами удалить
[04:13.480 --> 04:29.400]  какой-нибудь элемент и получить, к примеру, 3, 2, 4, 7, 9, 3, то за сколько это будет работать?
[04:29.400 --> 04:45.480]  О от н. То есть удаление элемента это О от н. А если я захочу вставить? Тоже будет О от н. Классно это? Нет.
[04:45.480 --> 04:54.040]  Вот здесь начинается дилемма. На самом деле всегда так в жизни с любыми вещами, которые вы захотите
[04:54.040 --> 05:01.040]  сделать. Если где-то хорошо, значит где-то плохо. То есть, вы не можете сделать настолько идеальную
[05:01.040 --> 05:08.680]  структуру данных и сказать, что она все делает за О от единицы. К сожалению, это невозможно,
[05:08.680 --> 05:16.600]  иначе бы мы все учили только ее и не смотрели на все остальное. Поэтому всегда приходится выбирать,
[05:16.600 --> 05:23.160]  что нам необходимо в тот или иной момент. Может быть, нам нужно быстрое обращение к элементам,
[05:23.160 --> 05:29.320]  тогда массив — идеальная структура, и мы постоянно берем и обращаемся к элементам. Может быть,
[05:29.320 --> 05:36.920]  нам нужно будет удалять элементы или как-то вставлять их периодически. Это другой уровень,
[05:36.920 --> 05:43.760]  и это другая структура данных, о которых мы сегодня с вами и поговорим. То есть, здесь важно
[05:43.760 --> 05:50.360]  осознавать, что любая структура данных применяется в конкретной ситуации, и вы самостоятельно должны
[05:50.360 --> 05:59.560]  научиться принимать эти самые решения. А что же мне делать здесь? Понятно? Вот. И первое,
[05:59.560 --> 06:06.280]  с чем мы с вами познакомимся, и на самом деле, на чем мы сегодня будем строить всю лекцию — это листы.
[06:06.280 --> 06:16.320]  Те, кто учил питон, знают, что такое лист в питоне. Но лист в питоне — это то же самое,
[06:16.400 --> 06:22.880]  что массив. Лист — это немного другая вещь, на самом деле, с точки зрения плюсов. С точки зрения
[06:22.880 --> 06:29.720]  плюсов лист бывает односвязный и двухсвязный. Это первое, что вы должны понять. То есть,
[06:29.920 --> 06:48.520]  бывает два таких вида. Односвязный и двухсвязный. Что это вообще такое? Что за связи? Одна и две.
[06:48.520 --> 06:55.880]  Что здесь происходит? Давайте с вами рассмотрим следующую структуру данных. У нас есть некоторые
[06:55.880 --> 07:08.840]  ячейки, где мы будем хранить какое-то значение, так называемый ключ, а вторая ячейка будет
[07:08.840 --> 07:16.160]  указывать на следующий элемент. И мы будем так делать сколько нам необходимо раз. То есть,
[07:16.160 --> 07:23.520]  к примеру, я беру и говорю, что давайте тот же самый массив перепишем. Вот у меня есть 3, а нижняя
[07:23.520 --> 07:51.440]  ячейка указывает на ячейку другую. Три, два, четыре, семь, девять и три. Похоже на массив? Похоже.
[07:51.440 --> 07:58.280]  А теперь давайте поговорим вообще, как структура выглядит, что мы с ней будем делать. На самом деле,
[07:58.280 --> 08:07.200]  вот каждая эта часть называется нодой. Ну, в английском нода, по факту узел, я не знаю,
[08:07.200 --> 08:14.600]  как хотите назовите. Но я буду всегда называть это нодами. И ноды, они формируются не постоянно
[08:14.600 --> 08:24.360]  как массивы в памяти компьютера, а они формируются так, что они просто создаются и друг на друга
[08:24.360 --> 08:29.920]  указывают. Здесь очень важна роль тех самых указателей, которые у нас есть. То есть,
[08:29.920 --> 08:38.800]  если рассмотреть эту ноду и взять динамическую память, то они вот где-то вот тут вот существуют,
[08:38.800 --> 08:50.480]  в некоторых рандомных моментах, куда запихнул их компиляторы и друг друга указывают. Вот так. Вот это
[08:50.480 --> 08:59.840]  и будет лист. То есть, лист на каждом из этапов будет брать, и это односвязанный лист, у него одна
[08:59.840 --> 09:08.200]  всего лишь связь. Он будет на каждом этапе брать и создавать какие-то элементики и вставлять их
[09:08.200 --> 09:21.560]  куда-то. Давайте подумаем, чем хорош лист. Для того, чтобы вставить какой-то элемент или удалить,
[09:21.560 --> 09:34.200]  нам достаточно просто переподвязать этот элемент сюда, а отсюда сюда, а эту связь удалить. Так
[09:34.200 --> 09:53.160]  мы вставляем новый элемент. Нет, почему? Одна связь. Ага. Да. Но если мы знаем, действительно,
[09:53.160 --> 09:58.480]  указатель у нас есть, куда вставить, то все хорошо. Не поверите, для того, чтобы удалить какой-то
[09:58.480 --> 10:07.640]  элемент из массива, вы тоже вряд ли знаете, у вас есть индекс. Вы говорите, я удалю и ты элемент,
[10:07.640 --> 10:13.280]  а если он соотносится, ну грубо говоря, не знаю, вы должны удалить минимум, то что вы должны? Взять
[10:13.280 --> 10:20.280]  и пройтись по всему массиву, а потом еще сдвинуть все на n. Поэтому здесь все зависит от того, знаете,
[10:20.280 --> 10:27.120]  вы указатели или нет. Грубо говоря, за счет чего вы находите этот самый указатель. Давай я пишу с
[10:27.120 --> 10:33.600]  вами ту самую структурку ноды, которая у нас будет. У нас есть восхитительное слово
[10:33.600 --> 10:42.120]  стракт, с которым вы сегодня познакомились, правда? Вот. Давайте опишем эту ноду. Что это за нода-то
[10:42.120 --> 10:54.320]  такая? Смотрите, в ней хранится какое-то значение или какой-то ключ. Но я буду писать ключ. Вот у меня
[10:54.320 --> 11:03.360]  есть тот самый ключ. И что в ней еще хранится? В ней хранится указатель на следующую ноду. То есть
[11:03.360 --> 11:20.040]  какой тип имеет это? А, нод-звездочка, да. Нод-звездочка. Ну здесь можно назвать это просто next.
[11:20.040 --> 11:36.800]  Давайте так назовем. Да. 3, 2, 6, 4. Это все. Это все значение. И вот это является нодой в нашем
[11:36.800 --> 11:45.720]  понимании. Теперь смотрите, что важно понимать об односвязанных списках вообще в принципе. Ну
[11:45.720 --> 11:55.240]  как бы нода-то есть. Это хорошо. Но главное в односвязанном списке что? Откуда мы еще пойдем? То есть
[11:55.240 --> 12:04.200]  любой лист односвязанный, к примеру, нам необходимо взять и понять откуда мы идем. То есть что является,
[12:04.200 --> 12:17.040]  так сказать, головой этого листа. Согласны? Вот поэтому на самом деле к этому всему добавляется
[12:17.040 --> 12:29.560]  еще одна структурка. Давайте я тут буду писать. Да. Какое-то значение, которое хранится. Вот массиве
[12:29.560 --> 12:42.200]  в ячейке у вас хранится чиселка. Вот здесь тоже чиселка. Вторая ячейка это тот самый указатель.
[12:42.200 --> 12:48.840]  Вот это и есть указатель. Смотрите, вот отсюда я указываю сюда, отсюда сюда, отсюда сюда. Понятно?
[12:48.840 --> 13:01.200]  Конечно можем. Или плохо другой вопрос, но конечно можем. Нам никто не мешает этого делать.
[13:01.200 --> 13:09.480]  Да, конечно. То есть последний элемент, для того чтобы понять, что он последний,
[13:09.480 --> 13:14.160]  он должен указывать, что его next это nullptr. Это правда.
[13:19.320 --> 13:27.480]  Вот. Теперь смотрите, как выглядит этот лист. Ну, если рассмотреть прям как лист-лист,
[13:27.480 --> 13:38.760]  взять написать некоторую структуру. Давайте не тут. Давайте вот тут. Структ. Ну, forward-лист.
[13:38.760 --> 13:51.200]  Forward-лист. То, что в этом листе хранится, да на самом деле всего лишь один указатель.
[13:51.200 --> 14:00.440]  Как вы думаете, как я его назову?
[14:00.440 --> 14:23.240]  Вот это и есть лист в нашем понимании. Но что важно здесь всегда осознавать,
[14:23.240 --> 14:27.640]  что предположим-то такие структурки-то у нас есть, надо научиться с ними работать.
[14:27.640 --> 14:35.000]  Что нам нужно научиться делать? Для начала лист создается, и создается он со значением,
[14:35.000 --> 14:42.360]  что у него главной элемент nullptr. Лист пустой. Согласны? Вот. Можно по умолчанию здесь написать
[14:42.360 --> 14:49.040]  равно nullptr, но я так делать не буду. Можно это сделать, но типа вот здесь, как в вашей
[14:49.040 --> 14:56.080]  душе угодно. Это не будет ни ошибкой, ни чем. Вот. Я лишь скажу просто в самом начале,
[14:56.080 --> 15:03.440]  что это будет nullptr. А дальше мы должны начать добавлять эти ноды. То есть мне нужна по-хорошему,
[15:03.440 --> 15:12.080]  давайте сюда напишу. Мне нужна какая-то функция add, которая скорее всего будет voidовская,
[15:12.080 --> 15:22.880]  но это не сто процентов. Которая будет принимать тебя. Что? Лист? Правильно?
[15:22.880 --> 15:35.720]  Ну, я буду добавлять элемент в конец пока что. Или мы сразу захотим в сериал.
[15:35.720 --> 15:50.240]  Хорошо. Тогда нам нужен, тогда нам лист особо-то не нужен на самом деле. По какой причине? Потому
[15:50.240 --> 15:56.840]  что у листа есть только одно head. Конечно, сюда можно добавить size, сколько у нас элементик
[15:56.840 --> 16:03.400]  в группах хранится и так далее. Вы здесь можете модифицировать, как вам удобнее. Вот. Но окей,
[16:03.400 --> 16:12.640]  если мы будем с вами просто добавлять элементы, то нам что нужно? Нам нужен указатель просто на
[16:12.640 --> 16:19.640]  некоторую ноду. Правильно? Чтобы понять, в какое место мы будем вставлять. Из-за этой
[16:19.640 --> 16:30.080]  ноды будем что-то делать. Правильно? Вот здесь мы делаем с вами ноду звездочка. Какой-то указатель.
[16:30.080 --> 16:45.440]  Правильно? Которая будет указывать на что? На какую-то из нод. Ага. Вот. И, например, какое-то
[16:45.440 --> 16:55.880]  значение D я буду вставлять. Не ноду, а D. Чиселка. Согласны? Что в этом случае я с вами должен
[16:55.880 --> 17:04.200]  делать здесь? Я пишу это специально на плюсах, не потому что я стал к вам... Я начал вам рассказывать
[17:04.200 --> 17:12.360]  все про плюсы, а потому что указатели есть в плюсах. Вот. С псевдокодом немного сложнее. Там нет их так
[17:12.360 --> 17:20.200]  таковой. Вот. Поэтому я пишу именно так, как есть. В начале что мы должны сделать? Мы должны сказать,
[17:20.200 --> 17:27.960]  что у нас должна появиться новая нода. Правильно? Поэтому я пишу нод звездочка,
[17:27.960 --> 17:44.400]  new, нода равна new, нода. Согласны? Даю это в динамическую память. Дальше у этой новой ноды
[17:44.400 --> 18:05.200]  что я должен сделать? Я должен сказать, что у нее значение ключа чему равно. Д. И пока кажется все,
[18:05.200 --> 18:10.840]  потому что следующий мы не понимаем какой. Но мы с вами договариваемся, что если я указываю на
[18:10.840 --> 18:22.840]  какую-то ноду, то я вставляю после нее. Правильно? Согласны? Тогда я должен сказать, что у нее нода.
[18:28.560 --> 18:31.840]  Next. Чему она равна?
[18:40.840 --> 19:00.520]  Ссылку на ПТР? Правда? ПТР, next, нода, звездочка.
[19:00.520 --> 19:15.600]  Стрелочка для вас равносильна следующему, что я делаю звездочку от какого-то от ню нода,
[19:15.600 --> 19:21.960]  например. Это я смотрю элементы, которые находятся в структурке. Правильно? Ну,
[19:21.960 --> 19:43.560]  разыми новую структуру. Точка. Точка next. Пока все понятно. Окей. Вот. Мы начинаем указывать на
[19:43.560 --> 19:50.280]  следующую часть. Что нам осталось сделать? Нам осталось, смотрите, у меня появилась вот эта стрелочка.
[19:50.280 --> 20:01.480]  Согласны? Да? Мне осталось просто поменять вот эту стрелочку. Правда? Ну, давайте это сделаем.
[20:01.480 --> 20:21.520]  То есть мы скажем, что ПТР, next, это новая нода. Согласны? Это и есть оставка.
[20:21.520 --> 20:35.560]  Он указывал на четверку. Теперь я взял и поменял на шестерку. Ну, то есть у меня была вот такая
[20:35.560 --> 20:45.160]  стрелочка, я ее сразу поменял. Вот. То есть я не удалял эту связь, я просто взял и заменил. Да.
[20:45.160 --> 20:59.200]  И вот к вам вопрос. Ставить элемент я вставлю. Я даже представляю, куда мне вставить этот элемент.
[20:59.200 --> 21:11.360]  Да? Но. А когда у меня лист пустой? Куда вставлять? К ПТР я обратиться не могу. У
[21:11.360 --> 21:21.560]  на ЛПТР ничего не существует. Согласны? То есть здесь должно быть что-то, что создает новый элементик,
[21:21.560 --> 21:31.440]  новую очередь, грубо говоря. Новый лист, прошу прощения. Новый лист. Согласны? Что-то должно
[21:31.440 --> 21:49.240]  да произойти. Интрига. Как назовем такую функцию? Create list. Ну хорошо. Так. Куда?
[21:49.240 --> 22:16.480]  То что? А тогда как вы будете обращаться к этому листу? Так. Нам нужно, смотрите, во-первых,
[22:16.480 --> 22:23.480]  вам нужно как-то эту структуру впихнуть туда. Согласны? Потому что иначе он не будет понимать,
[22:23.480 --> 22:31.520]  что происходит. Может, я просто сумасшедший, у которого там ПТР и НалПТР, я просто в рандомные
[22:31.520 --> 22:39.160]  места что-то пихаю. Такое тоже возможно. А вот. Вот такое. Тестирование, грубо говоря, у нас не
[22:39.160 --> 22:44.960]  проходит. Тестирование на дурачка. Что поделать? Ну как бы мы будем считать, что мы все-таки умные
[22:44.960 --> 22:55.400]  люди и будем туда НалПТР пихать. Согласны? Вот. Что же касается Create? Ну давайте хорошо.
[22:55.400 --> 23:03.600]  Create, Create. Мы с вами по чуть-чуть должны описать эту всю очередь, а потом найти ее применение
[23:03.600 --> 23:12.240]  вообще. Очередь-то очередь, ой, лист-то листом. Но какое применение-то в итоге у нас будет? Мы
[23:12.240 --> 23:25.120]  будем с вами от этого отталкиваться. Давайте сделаем Void, Create, List. Ну вообще Forward, List,
[23:25.120 --> 23:39.360]  но давайте Ablist. Хорошо. В одну сторону смотрит. Вот. Поэтому и Forward. Что он делает? Он принимает
[23:39.360 --> 24:03.520]  к себе лист. Ну скорее он даже принимает его по ссылке. Ага. Ну и когда мы его будем создавать,
[24:03.520 --> 24:10.160]  наверное, мы будем создавать с каким-то значением первым, правда? Поэтому я здесь
[24:10.160 --> 24:20.800]  делаю int D также. Окей. Ну заходите пустой создавать, ну создайте с нулем. Менять всегда можно.
[24:20.800 --> 24:32.360]  Хорошо. Мы создаем этот листик. И что мы делаем? В этот момент мы должны сказать, что у него
[24:32.360 --> 24:39.680]  должен появиться новое 2 у этого листа, потому что пока у нас он безголовый. Это не очень хорошо.
[24:39.680 --> 24:53.960]  А? F нижнее подчеркиваемое. Что я в этом случае делаю? Я говорю следующее, что мне нужно создать ноду,
[24:53.960 --> 25:04.680]  и первая нода, когда она будет одна единственная, куда будет ptr next смотреть? 0 ptr. Поэтому здесь я
[25:04.680 --> 25:25.040]  просто говорю, что f лист точка, потому что он по ссылке, ага, head равняется. Почему? New нода,
[25:25.040 --> 25:35.920]  да? Спойлер, вот там вот я так писал через равно. Неприкольно, так не пишут. Я пишу здесь D и
[25:35.920 --> 26:04.240]  на lptr. Красиво. Мы создаем лист. Да. Лист и D. D это вот тот самый первый элементик,
[26:04.240 --> 26:20.080]  здесь это троечка, грубо говоря. Ещё вопросы? Можно. Другой вопрос. Можем, конечно.
[26:20.080 --> 26:35.600]  Это правда, но нам нужно просто head будет двигать и всё. То есть это отдельный add должен быть. Мы
[26:35.600 --> 26:39.080]  договорились, что мы вставляем с вами за элемент. Просто если бы мы договорились,
[26:39.080 --> 26:43.280]  что мы вставляем перед элементом, то мы последний элемент никогда бы не поменяли.
[26:43.280 --> 26:51.520]  Вот. То есть я рассуждаю здесь в таких вот вещах. Вы можете написать там forward add и не знаю там,
[26:51.520 --> 27:01.120]  ой, не forward, не... pref add и post add. Ну типа перед вставить, после вставить. Можете так
[27:01.120 --> 27:08.760]  расписать. Это не сильно важно, но они будут похожи между собой. Вот. Я создал этот f лист.
[27:08.760 --> 27:30.720]  Красиво? Или не очень? Или не нравится? Почему forward list? Давайте ещё раз. Forward
[27:30.720 --> 27:49.200]  list. Чего не так? Какой пустой перемен. Ну смотрите. До этого вызова функции head считалось пустой.
[27:49.200 --> 28:09.320]  Ну на lptr он указывал. Не то чтобы сильно пустой, но да. Да. Да. Ну вот f list.head.
[28:09.320 --> 28:22.960]  Ещё раз. f list.head. Я обращаюсь именно к этой ноде. Я говорю, что этот указатель равен new
[28:22.960 --> 28:42.880]  ноде. Это уже указатель, куда передают d и lptr. Да. Так я образую первую ноду ту самую. Да. Ну то есть
[28:42.880 --> 28:47.640]  представьте, что у меня всех элементов нет. Вот куда эта тройка должна указать? На lptr,
[28:47.640 --> 28:59.160]  если всех элементов нет. Вот всё. И смотрите, как бы это я сделал. Delete делается аналогично. Но
[28:59.160 --> 29:08.600]  давайте его напишем. Если мне нужно удалить какую-то определённую ноду. То есть создавать
[29:08.600 --> 29:18.560]  теперь я могу. Добавлять могу. Осталось удалять. Согласны? Вот. Тогда чё я с этим делаю? Я пишу,
[29:18.560 --> 29:26.480]  что это тоже void-овская функция. CandleLit. Здесь благо нам не нужно договариваться,
[29:26.480 --> 29:32.760]  мы удаляем перед или после. Поэтому просто удаляем. Мне нужна только лишь нода,
[29:32.760 --> 29:49.320]  которую я удаляю. Как мне удалить это? Как вы думаете? А теперь вопрос. Как мы обратимся к предыдущему?
[29:49.320 --> 30:10.120]  Ой. А? А функция обращения к предыдущему будет за сколько работать? За вуатен? Некруто.
[30:10.120 --> 30:21.160]  Это не работает же. Они же в рандомных моментах существуют. У тебя же динамика,
[30:21.160 --> 30:26.480]  динамическая, ну выделяет динамическую память в каких-то случайных местах. Что делать? Да.
[30:26.480 --> 30:48.800]  Не бывает индексов? Это уже двухсъязанный список. То есть мы так решаем проблемы, правда?
[30:48.800 --> 31:01.520]  Удалять элемент, который после идет? Хорошо. Будем удалять элемент, который идет после этого
[31:01.520 --> 31:08.120]  ПТР. Решение? Ну решение в принципе. Вопрос следующий. А что если идет после NALPTR?
[31:08.120 --> 31:20.600]  Если идет, то... Ну мы же можем удалить сам этот элемент, если у нас дальше идет NALPTR. Мы понимаем,
[31:20.600 --> 31:27.320]  что он где? В конце. Но вопрос. А другой элемент, который... Вот тут мы удалим,
[31:27.320 --> 31:34.560]  предположим. Да, вот этот будет указывать на удаленную память. Плохо. Это нельзя.
[31:38.120 --> 31:47.480]  Видите, как много интересного здесь происходит? Кажется, что просто. Что делать? Хорошо, давайте
[31:47.480 --> 31:52.240]  типа... Смотрите, сегодня лекция больше такая, импровизация у меня. Я все понимаю,
[31:52.240 --> 31:56.640]  как это работает, я все это знаю, я все это рассказать могу, но мне интересно послушать вас и получим
[31:56.640 --> 32:01.800]  что-нибудь. Вот. Так что давайте отталкиваться от этого. Давайте будем действительно удалять ноду
[32:01.800 --> 32:23.120]  после. Какую? Как? Ровно так же, как крейтли сдалить. А как? Как к ним обратиться?
[32:23.120 --> 32:34.120]  То есть, да, но мы же должны будем удалить оттуда. То есть, если мы переложим,
[32:34.120 --> 32:41.200]  к примеру, вот здесь вот, вот это мы пытаемся удалить. Что в этом случае должно произойти?
[32:41.200 --> 32:55.560]  Тогда мы вот этот элемент должны вот сюда перенести, правильно? Элемент, и на следующий элемент уже много.
[32:55.560 --> 33:07.760]  Нет, почему? Числа не связаны между собой, ПТР между собой связаны.
[33:12.200 --> 33:19.240]  Давайте, мы предыдущий элемент. Смотрите, правильно ли я понимаю. Вот я хочу удалить
[33:19.240 --> 33:27.240]  эту семерку, да? Что вы мне предлагаете? Хорошо, давайте эту четверку удаляем. Что мы хотим?
[33:27.240 --> 33:42.320]  Семерку передвинули. А теперь мы ничего не передвинули. Мы не умеем передвигать. Еще раз,
[33:42.320 --> 33:52.240]  мне нужно удалить ноду. Если я не сделаю дилит, у меня будет утечка памяти. Когда у меня есть дилит,
[33:52.240 --> 34:07.120]  у меня утечка памяти. Что делать? Ну, то есть, идея здесь, ну, в какой-то степени жизнеспособная.
[34:07.120 --> 34:18.280]  С тем, что давайте вот эту семерку сюда переложим. У меня будет 7 и 7, да? А потом вот эту вот мы возьмем
[34:18.280 --> 34:26.000]  и перенесем сюда. А другого варианта у тебя не будет. А какая разница? Ты удалишь эту или эту? Тут один и тот же кей.
[34:26.000 --> 34:42.040]  Почему он перестанет быть связанным? Почему? Не станет. Единственное, в чем будет проблема,
[34:42.040 --> 34:56.000]  что типа последний элемент мы так уже не удалим. Ну, то есть, давайте еще раз. Если вы мне говорите,
[34:56.000 --> 35:02.640]  вот просто переложить кей сюда и удалить вот эту штуку, тогда я не могу последний элемент удалить.
[35:02.640 --> 35:08.040]  Если я буду удалять next, тогда я не смогу удалить.
[35:08.040 --> 35:26.760]  Вот, то есть, давайте здесь мы как бы сделаем что? Как вы хотите удалять элементы? Смотрите,
[35:26.760 --> 35:31.840]  перекладывая что-то, это гораздо дольше, потому что, мало ли, эта структура занимает
[35:31.840 --> 35:39.280]  очень много времени. Понимаете? То есть, мало ли, эта структура состоит из массива из тысячи элементов,
[35:39.280 --> 35:45.120]  к примеру. Для того, чтобы их перевести друг от дружки, когда вы будете работать именно с рэями,
[35:45.120 --> 35:50.600]  не с симассивами, а с рэами. Ну или какие-то вот структуры данных. Представьте, у меня там тысячи
[35:50.600 --> 35:57.520]  полей. Вы все должны копировать между собой. Это плохо. Это нельзя так делать. Поэтому,
[35:57.880 --> 36:04.320]  давайте договорились, что буду удалять следующий элемент после моей ноды. Странно? Странно,
[36:04.320 --> 36:15.120]  правда? Но как это работает? А в конце удалим, типа final delete будет для хеда. Ну либо delete
[36:15.120 --> 36:22.320]  хед. И в случае дилита хед, мы что сделаем? Мы просто передвинем хед на следующий элемент.
[36:22.600 --> 36:28.280]  Будет он NullPTR или NullPTR, это нас уже не будет интересовать. Понятно?
[36:28.280 --> 36:45.200]  А? Ну я могу написать хед равно NullPTR? Могу. В чем проблема? Короче, давайте с вами все-таки
[36:45.200 --> 37:08.680]  напишем? Вот так. Его еще раз. Ну а в чем проблема? Нет, подождите, типа я напишу хед равно, а хед next.
[37:08.680 --> 37:18.440]  Будет либо NullPTR, либо не NullPTR. Тут меня не интересует уже. Вот, то есть, смотрите,
[37:18.440 --> 37:23.960]  мне приходится как-то выкручиваться. Вообще, типа не прикольно, не классно. Но давайте,
[37:23.960 --> 37:28.920]  сейчас что-нибудь да напишем, там что-нибудь да заработает, и вы примерно так и решаете контест.
[37:28.920 --> 37:46.920]  Вот, так что я все знаю. Копировать данные нельзя. Как ты их поменяешь? Никак. Еще раз.
[37:46.920 --> 37:56.280]  Указатель указывает на всю ноду. На всю ноду. И указатель мало занимает, это факт. Но ты не
[37:56.280 --> 38:08.760]  можешь взять и переложить что-то. У кого? И толку. Но эту семерку-то я должен переложить?
[38:08.760 --> 38:24.720]  Нет, потому что вот этот будет все еще указывать сюда. Давайте это. Соберитесь. Понимаешь,
[38:24.720 --> 38:30.680]  что уже не тривиально? Кажется, очень простой структур данных, правда? Простейше тебе вообще.
[38:30.680 --> 38:36.680]  Вот столько вопросов возникает. Это всегда так, на самом деле. А если кажется, что просто,
[38:36.680 --> 38:43.120]  значит, что-то вы сделали не так. Такое бывает. Короче, если мы будем удалять следующую ноду,
[38:43.120 --> 38:50.760]  то это все достаточно просто. Как это сделать? Мы говорим, что мне для начала нужно сохранить
[38:50.760 --> 38:59.840]  указатель на ту ноду, которую мы будем удалять. И предполагать, что это не... Ну, то есть,
[38:59.840 --> 39:05.360]  мы должны будем указывать на следующий элемент. То есть, когда мы удаляем следующую ноду,
[39:05.360 --> 39:10.680]  мне нужно указывать на следующий элемент. То есть, если я удаляю девятку, то мне нужно указать
[39:10.680 --> 39:17.320]  вот сюда, к примеру, в тройку и так далее. Предположим, что такой элемент существует,
[39:17.320 --> 39:22.000]  либо мне без разницы, если даже NullPtr, потому что удаление NullPtr к чему приводит?
[39:22.000 --> 39:31.720]  Ни к чему. Его можно удалять. Поэтому я говорю, что нода звездочка newNext, не знаю, или как-нибудь так,
[39:31.720 --> 40:00.480]  next равняется ptrNext. Вот так. Я раз перешел к следующему элементу и два перешел. Или, понятно,
[40:00.480 --> 40:09.040]  что я сделаю? Смотрите, хорошо, давайте я поступлю по-другому. Да, окей, я понял, я вас сломаю.
[40:09.040 --> 40:25.120]  Давайте я здесь сделаю newNode, а deleteNode. Она равняется ptrNext. Согласны, что я буду удалять,
[40:25.120 --> 40:36.280]  ну ноды, вот это буду удалять. Правда? Теперь смотрите, я говорю, что ptrNext он чему равен?
[40:36.280 --> 40:58.720]  Он равен deleteNode. Согласны? Вот я удаляю еще ноду, я должен взять newNext. Правда? Согласны?
[40:58.720 --> 41:23.120]  Вот я это и делаю здесь. Ну а после этого что делаю? Вот я это удалил. DeleteNode показывает на ноду,
[41:23.120 --> 41:27.760]  которую я должен удалить. Поэтому я должен на самом деле здесь просто написать с вами delete,
[41:27.760 --> 41:46.400]  delete, deleteNode. Ну, вам не понравилось nextNext со стрелочками, поэтому я.
[41:46.400 --> 42:01.920]  Вот мы можем сохранить либо указатель на следующий элемент от удаляемого,
[42:01.920 --> 42:12.920]  либо мы можем сохранить указатель на удаляемый. Да, вот дальше вам придется вот типа вот у нас
[42:12.920 --> 42:19.240]  был createList, вот у вас нужно удалить лист и так далее. Согласны ли вы с тем, что это ну какой-то
[42:19.240 --> 42:33.840]  неприятный способ? Господи, стойте, вы чего? Вы куда? Я надеялся, что вы все понимаете. Смотрите,
[42:34.040 --> 42:43.520]  у меня есть нода PTR. Вот это PTR. Она указывает дальше на какую-то еще ноду, да?
[42:43.520 --> 43:09.320]  Это удаляемая нода deleteNode. Согласны? А вот это у нее следующая нода. Что я сохраняю? Я сначала
[43:09.320 --> 43:16.400]  говорю, что deleteNode равна PTRnext, то есть вот она удаляемая нода. Согласны? Что я должен дальше
[43:16.400 --> 43:26.520]  сделать? Я должен у PTR своего взять и пересечь его вот сюда. Согласны? А, и то есть я вот эту
[43:26.520 --> 43:32.920]  связь нарушил. Теперь я просто так от deleteNode не могу подобраться. И для того, чтобы к ней
[43:32.920 --> 43:54.400]  подобраться, я убил здесь. И после этого удаляю ноду. Ну, удаляю указатель, который был выделен
[43:54.400 --> 44:05.600]  через NU. Я удаляю ноду. Я удаляю то, что хранится в этой ноде. Как вы писали deleteRay? Вы удаляли
[44:05.600 --> 44:26.200]  указатель или вы удаляли весь массив? Вот ровно суть такая же. Да? Красиво? Не может. Вот,
[44:26.200 --> 44:32.200]  но на самом деле вот односвязанные списки очень полезны. Давайте поговорим с вами немного про
[44:32.200 --> 44:43.600]  другие структуры данных. Почему они не работают? Это нужно удалить, это правда. Но на самом деле
[44:43.600 --> 44:49.800]  не хед, а вот этот кусочек, вот типа такого, когда у нас NullPTR в конце. Когда из одного элемента
[44:49.800 --> 44:56.120]  состоит, грубо говоря. Вот эта часть, она неприятная. И хед тоже как-то неприятно удаляется. Все это в
[44:56.120 --> 45:02.520]  принципе не очень приятно. Для нас выглядит так, что типа кощунство какое-то. Мы столько ИФов делаем.
[45:02.520 --> 45:13.240]  Вы над этим поразвлекаетесь дома побольше. На самом деле достаточно писать ИФы здесь. Но я объясню,
[45:13.240 --> 45:20.200]  зачем я сейчас вот это все рассказывал вам. Вот это все дает вам понимание следующего, что у нас
[45:20.200 --> 45:25.080]  есть такая структура данных, и на самом деле она описываемая. Кажется, что здесь много строк,
[45:25.080 --> 45:30.680]  на самом деле не так много. Ну типа тут чуть-чуть. Посидеть да потыкаться в них. Правильно ИФы
[45:30.680 --> 45:37.480]  настроить еще на самом деле. То есть крайние случаи рассмотреть. Что же касается, то есть вот сюда я
[45:37.480 --> 45:47.320]  могу написать там if ptrNext равен NullPTR, тогда я удаляю просто вот эту. Но мне нужно как-то там
[45:47.320 --> 45:54.280]  понять, как мне сделать предыдущие элементы и так далее. Здесь я могу искать find какие-то
[45:54.280 --> 46:00.040]  элементы, удалять за OATN и так далее. Существуют более разумные вещи на самом деле с этим всегда.
[46:00.040 --> 46:11.040]  Но смотрите, мы с вами должны сегодня познакомиться с двумя еще очень важными вещами,
[46:11.040 --> 46:20.280]  которые используются просто в неистовом количестве. Первое это stack. Кому знаком stack?
[46:20.280 --> 46:32.240]  У вас много? Что такое stack? Давайте знаком и знаком, но не знаю. Вот такое может быть. Тарелка.
[46:32.240 --> 46:46.800]  Да, stack реализован по принципу, а лифо. Кто понимает, как это расшифровывается?
[46:46.800 --> 46:58.080]  Last in, first out. Тот, кто пришел последний, всегда будет выбывать первым. И в этом плане очень
[46:58.080 --> 47:06.920]  интересно смотреть, чего нам тут делать. И вот этот stack по принципу лифо, мы будем смотреть,
[47:06.920 --> 47:14.880]  как его реализовать. И stack сама по себе полезная структура данных. Например, для скобочных
[47:14.880 --> 47:23.160]  последовательностей очень хорошо подходят. Правильных и так далее. И работает это именно
[47:23.160 --> 47:32.440]  со stack. Stack можно представлять тарелочками, мусорным ведром, чем хотите. Где в действительности
[47:32.440 --> 47:39.560]  элементы вот так наслаиваются, а потом они кладутся сверху, убираются сверху. Вот это и есть stack.
[47:39.560 --> 47:49.920]  И stack может быть реализован на односвязанном списке. Кто представляет, как?
[47:49.920 --> 48:11.880]  Можно добавлять только в конец и убирать только из конца, да? А? Какой? Как их связывать
[48:11.880 --> 48:18.520]  между собой? Вот эти элементики. Вот смотрите, у меня есть элементики вот такой stack. Какую
[48:18.520 --> 48:39.960]  сторону, во-первых, они будут все связаны? Вниз? А? В любую? А как удалять? Вот. Вопрос,
[48:39.960 --> 48:47.720]  для какого варианта, чтобы я мог легко удалять элементы и легко их класть и
[48:47.880 --> 48:56.920]  понимал куда? Смотрите, если я организую это вот таким вот образом, то в чем у меня будет проблема?
[48:56.920 --> 49:04.200]  В том, что у меня есть голова, а класть мне надо в конец. Это плохо. Я должен так весь пройти. И
[49:04.200 --> 49:12.200]  что делать? Как с этим жить? Конечно, есть вариант, что я буду указывать просто на этот элементик
[49:12.200 --> 49:20.360]  еще. То есть у меня будет помимо head tail еще конец. Но это некрасиво. Здесь легче все элементики
[49:20.360 --> 49:29.360]  связать вот так. И потом нужно подумать, как здесь удалять тогда все. То есть смотрите,
[49:29.360 --> 49:35.840]  у меня есть два варианта. Первый я иду вот так, второй я иду вот так. В этом случае мне нужно
[49:35.840 --> 49:46.480]  удалять верхний элемент. Согласны? Как удалять верхний элемент? Вот. Например. Но в действительности
[49:46.480 --> 49:54.560]  удалить этот элемент это не очень сложно. Почему? Потому что если это является head,
[49:54.560 --> 50:02.240]  то я просто должен переподвесить head сюда, а этот элемент удалить. Согласны? И вот оно будет
[50:02.240 --> 50:09.000]  всегда так удаляться. То есть вот мне тут самое удаление head здесь и понадобится. Когда я буду
[50:09.000 --> 50:16.160]  добавлять элементы, то что я буду делать? Я буду создавать здесь элементик и писать,
[50:16.160 --> 50:22.880]  что он указывает на head, а потом head переподвешу сюда. Согласны? То есть вот тут stack есть так
[50:22.880 --> 50:36.560]  называемый push и pop. Ага. Давайте их опишем, это интереснее. Поговорим про них. То есть вы уже
[50:36.560 --> 50:43.640]  поняли, что с листом дела не очень, но вам придется с ним что-то делать. На самом деле со
[50:43.640 --> 51:02.120]  stack. Что будет храниться в stack? Внутри stack само по себе будет что? Вообще по-хорошему там
[51:02.120 --> 51:09.640]  односвязанный список, но вам можно сделать здесь просто, грубо говоря, голову ту самую. И сказать
[51:09.640 --> 51:27.840]  следующее, что у меня есть нода. Ну, ноды у нас сохранились ровно такие же. После этого мне
[51:27.840 --> 51:41.480]  нужно к примеру wait push. Я должен вставить элемент каким-то значением там x. Да? Как я вставляю
[51:41.480 --> 51:47.600]  элемент? Я беру этот элемент, сначала его создаю, показываю, что он указывает на тот самый head,
[51:47.600 --> 51:55.400]  а потом head переподвешу. Согласны? Поэтому здесь кроме index, прошу прощения, но я нужен еще и stack.
[51:55.400 --> 52:05.000]  Вы можете дальше его просто написать. Вторым аргументом, но вообще лучше первым. Что я в этом
[52:05.000 --> 52:17.800]  случае получаю? Что я делаю-то вообще? Все просто. Я говорю, что нод-звездочка. Не знаю, пусть будет
[52:17.800 --> 52:27.360]  нода просто с маленькой буквы. Равно new. Ну да? Какие значения должны быть у этой нью ноды?
[52:27.360 --> 52:48.080]  x и s точка head. Согласны? Ну, x это число, которое оставляю, push уже его. Push это положить сверху.
[52:49.080 --> 52:57.640]  x и head. То есть теперь вот это вот мой созданный элемент вот здесь вот. Он уже указывает на ту самую
[52:57.640 --> 53:07.600]  голову. Что осталось сделать? Поменять голову. Согласны? Написать, что x равняется ноде.
[53:07.600 --> 53:31.480]  Согласны? Когда у нас пустой stack, это обрабатывается корректно? Да, обрабатывается
[53:31.480 --> 53:39.040]  корректно. Потому что что у нас здесь? Здесь будет на lptr. Согласны? Все будет хорошо.
[53:39.040 --> 54:01.000]  Указательно ноду. Мы не удаляем push вставить. Push закинуть что-то. Вот. Потому что у меня вниз
[54:01.000 --> 54:13.760]  идет. У меня head сверху. Следующий момент. Связанным попом это удаление. Pop удаляет верхний
[54:13.760 --> 54:24.480]  элемент. Я должен удалить. Иногда поп должен возвращать элемент, который удаляет и так далее.
[54:24.480 --> 54:29.640]  Здесь сами решайте, как хотите реализовывать. Я буду удалять без возвращения этого элемента.
[54:30.320 --> 54:40.960]  Я делаю поп. Как мне удалить верхний элемент? Мне нужно сначала найти вот эту новую head,
[54:40.960 --> 54:53.200]  которая будет. А потом удалить head и переподвести. Согласны? Я сначала нахожу это новое и так далее.
[54:53.200 --> 55:00.400]  Согласны? Какая здесь может быть проблема? Из-за того, что я нахожу следующий элемент,
[55:00.400 --> 55:12.480]  что будет у меня, когда стэк пустой? Грустно будет, правда? Вот. Поэтому в этом плане лучше
[55:12.480 --> 55:25.960]  написать что-то вроде if s.head не равно nullptr. То есть только в этом случае мы что-то делаем.
[55:25.960 --> 55:32.840]  Если там nullptr, то мы ничего не делаем. Потому что стэк так пустой. Зачем мне еще поп? Бывают
[55:32.840 --> 55:39.200]  такие задачи, где гарантируется, что стэк никогда не будет пустой. Вот. Там разные бывают условия,
[55:39.200 --> 55:45.240]  поэтому просто смотрите на это. If этот нужен будет или нет. А дальше я говорю, что нода
[55:45.240 --> 56:07.960]  звездочка new head равняется s.head, стрелочка next. Понятно, почему так? С, смотрите, вот я
[56:07.960 --> 56:15.240]  эту ставку сейчас уберу. Вот у меня сейчас так находится. Head указывает сюда. Новая голова будет
[56:15.240 --> 56:25.160]  указывать на следующий элемент. Согласны? Я говорю, что s.head, вот этот элемент, стрелочка next.
[56:25.160 --> 56:33.200]  Понятно? Вот. Я говорю, что новая голова равна этому. Следующее, что я делаю, я делаю delete.
[56:33.200 --> 56:58.000]  s.head удаляю эту голову и говорю, что s.head равняется new head. Красиво?
[56:58.000 --> 57:21.600]  Все, что нужно. Да. Как мы что? Указатель на следующий. Да. Указатель, ну вот через один.
[57:21.600 --> 57:41.160]  s.head был тут, я на следующий смотрю. Next head. Head next. Ну вот он. Следующий элемент. Вопросы есть?
[57:41.160 --> 57:52.920]  Согласны, что stack писать проще? Реализовано тоже на односвязанном списке. Это указатель на
[57:52.920 --> 58:07.520]  ноду. Ноду. Тоже указатель на ноду. На следующую ноду после head. А head мне нужно удалить.
[58:07.520 --> 58:20.320]  s.head не указатель на следующую ноду. s.head это указатель на самую главную первую ноду. Вот.
[58:20.320 --> 58:30.760]  То есть если смотреть здесь, это вот это вот. Вот это с точки head. Да. Указатель на эту ноду. Я
[58:30.760 --> 58:45.320]  должен буду переподвесить на следующую. Да. Какое я push? Ну то есть stack для чего предназначен?
[58:45.320 --> 58:58.920]  Для push каких-то значений. 7, 3, 8, минус 1. Чиселки? Часть всего. Бывают не чиселки? Бывают чары
[58:58.920 --> 59:11.360]  какие-нибудь. Есть вопросы еще? Ноду, в которой хранится ключ и то, что следующий элемент равен
[59:11.360 --> 59:21.160]  хеду. И хед переподвешиваю. Ну то есть у меня в начале, когда я делаю push. Давайте еще раз. Всем
[59:21.160 --> 59:30.000]  остальным понятно или нет? Так на всякий случай. Давайте еще раз. Вот я должен вставить элемент. Я
[59:30.000 --> 59:39.600]  создаю вот эту ноду. Хед у меня указывает вот сюда. Да. Согласен? Отлично. Теперь я делаю. А я что
[59:39.600 --> 59:46.800]  должен сделать? Я создал вот этот элемент, новую ноду. Эту новую ноду я связываю с хедом. То есть вот
[59:46.800 --> 59:55.040]  это вот с хед, это оттуда. И теперь я должен хед переподвесить сюда. Вот теперь встал такие.
[59:55.040 --> 01:00:10.880]  Хорошо. Вот это все в стэке. Есть вопросы к стэку? Понятный стэк. Посмотрю на вас тогда дальше. Вот.
[01:00:10.880 --> 01:00:18.160]  Окей. Это то, что касается стэка. То есть last in first out это очень полезная штука. Существует еще
[01:00:18.160 --> 01:00:27.880]  другая вещь. Очередь. Представьте, что вы идете в поликлинику МФТИ. Вот. Не самое приятное чудо и там
[01:00:27.880 --> 01:00:37.240]  очередь часто бывает. Вот. Вы приходите в эту очередь и становитесь в нее. По какому принципу оно работает?
[01:00:37.240 --> 01:00:49.840]  По принципу FIFO. First in first out. Тот, кто первый пришел, тот и получил. Ну или в мир, о чем вы стоите,
[01:00:49.840 --> 01:00:59.600]  не знаю. Может в поликлинику вы не ходили уже. Вот. Этот человек старый. Все. Сыплюсь. Короче. Да.
[01:00:59.600 --> 01:01:10.480]  Очередь работает немного по другому принципу. Давайте я все это буду стирать. Давайте думать,
[01:01:10.480 --> 01:01:18.720]  как эту очередь вообще можно реализовывать и можно ли как-нибудь просто это делать.
[01:01:18.720 --> 01:01:30.520]  Смотрите. Что касается очереди. Очередь выглядит так, что у нас есть эти элементики.
[01:01:30.520 --> 01:01:46.520]  И, ну, предположим, очередь идет туда. То есть я должен удалять элементы какие? Вот отсюда.
[01:01:46.880 --> 01:02:01.120]  А добавлять? Вот сюда. Как жить? Ну, то есть смотрите, мне нужно как-то удалять с конца,
[01:02:01.120 --> 01:02:17.080]  вставлять в начало. Так. Два указателя каких? Да. Вот именно поэтому я вам специально не рассказывал
[01:02:17.080 --> 01:02:21.120]  двухсвязный список, потому что как только двухсвязный список вы узнаете, вы считаете,
[01:02:21.120 --> 01:02:27.760]  что очередь нужно делать через двухсвязный список. Нет. Достаточно через одна связка.
[01:02:27.760 --> 01:02:34.840]  В какую сторону здесь стоит направить все? Влево или вправо? То есть, да, у меня будет
[01:02:34.840 --> 01:02:55.400]  указатель действительно на tail и на head. Что делать? Как жить? Направо? Направо. Вопрос
[01:02:55.400 --> 01:03:02.920]  следующий. Как не удалять элементы? Ну, я буду удалять этот элемент, а как я вот tail
[01:03:02.920 --> 01:03:22.040]  возьму и передвину сюда? Зову от единицы. Ладно. Направляю в другую сторону. Как добавлять
[01:03:22.040 --> 01:03:36.240]  элементы? Правильно. В этом плане правда. То есть, смотрите, хоть моя очередь смотрит в ту сторону,
[01:03:36.240 --> 01:03:42.480]  направлять очередь необходимо в другую. Для корректной здесь реализации. Почему это просто?
[01:03:42.480 --> 01:03:46.360]  Потому что здесь tail, когда будет удалять, он будет в действительности удалять элементы,
[01:03:46.360 --> 01:03:55.480]  переходить просто к следующему. Когда он будет добавлять сюда элементы, то что мне достаточно?
[01:03:55.480 --> 01:04:04.400]  Мне достаточно head связать с ним. Правильно? Вот. И перенести head вот сюда. Все просто?
[01:04:04.400 --> 01:04:27.960]  Просто. Догласна? Да. Sorry. Давайте сделаем вот так. А нет, стоп, удаление. А удаление сначала,
[01:04:28.080 --> 01:04:42.760]  все правильно, головы в очереди. Добавление в конец. Прошу прощения. Вот в эту сторону.
[01:04:42.760 --> 01:04:59.000]  Право налево. Еще куда? Как вам еще это объяснить? Давайте еще раз отру. Вот. С head до tail.
[01:04:59.000 --> 01:05:07.600]  Tail вставляется, в head удаляется. Да, я прошу прощения. Что-то я неправильно сказал.
[01:05:07.600 --> 01:05:16.480]  А пишем такую очередь. А потом чуть-чуть расскажу еще про двухсвязанные списки.
[01:05:16.480 --> 01:05:21.280]  С ними все проще, вы там легко сможете все, что хотите удалять, делать и так далее.
[01:05:21.280 --> 01:05:30.080]  Но если мы говорим с вами про очередь, то в этой структуре, кто знает,
[01:05:30.080 --> 01:05:47.480]  как правильно читается очередь по-английски? Просто кью, друзья. Вот. В этой структуре лежит
[01:05:47.480 --> 01:06:04.160]  следующее. Лежит указатель на tail и указатель на head. На самом деле, на самом деле в стэк
[01:06:04.160 --> 01:06:10.960]  периодически добавляют size, в кью добавляют периодически size. Зачем это нужно? Иногда
[01:06:10.960 --> 01:06:14.920]  нужно выяснить, сколько элементов в стэке находится. И либо мы будем перебирать все
[01:06:14.920 --> 01:06:21.960]  элементы. Либо просто хранить здесь size при push, увеличивать size на 1, при pop уменьшать.
[01:06:21.960 --> 01:06:28.000]  Понятно? Аналогично здесь можно сделать. Пока я вам без size делаю, без всего, но вы это можете
[01:06:28.000 --> 01:06:35.880]  делать самостоятельно. Я думаю, добавить строчку вы умеете, правда? Вроде несложно. Вот. У нас есть кью.
[01:06:35.880 --> 01:06:52.560]  Еще раз. Вопрос снят. Все. Если вопрос снят, то все хорошо. Окей. Давайте с вами описывать все это.
[01:06:52.560 --> 01:07:09.480]  В очереди все называется не pop и push. А кто знает как? А? Нет. Еще раз.
[01:07:09.480 --> 01:07:30.520]  Декью. Это удаление, но не инкью. Ну давайте с вами скажем, что у нас есть insert, есть delete. Хорошо?
[01:07:30.520 --> 01:07:38.200]  Дальше, если вас попросят как-то по-другому называть, то называем по-другому. Окей. Если я говорю с вами
[01:07:38.200 --> 01:07:56.880]  о вставке, а в мою очередь q какого-то элемента x, что в этом случае я с вами делаю? Я делаю
[01:07:56.880 --> 01:08:10.960]  следующее. Я вначале создаю ноду. А нода куда будет указывать? А? Нет. Нод tail. Я же вот это...
[01:08:10.960 --> 01:08:24.600]  А. Прошу прощения, да, на NLPTR. Туда. Да. На NLPTR. Все верно. То есть я делаю нода, звездочка,
[01:08:24.600 --> 01:08:48.840]  а new-noda равняется new-noda с x и NLPTR. Правильно? Согласны? Отлично. Теперь я говорю, что tail
[01:08:48.840 --> 01:09:13.960]  next, а q tail. Правильно. q tail next равно new-noda. А после этого, что я должен сказать? Что tail, q tail,
[01:09:14.040 --> 01:09:37.920]  q tail равен new-noda. Все. Какая здесь есть проблемка? О том, что q tail, если NLPTR, то это все плохо,
[01:09:38.600 --> 01:09:46.400]  то вот этой строчки не нужно. Мне достаточно будет просто создать элементик и сказать,
[01:09:46.400 --> 01:09:52.440]  что tail теперь new-noda. Согласны? При добавлении. То есть вот это должно работать только в одном случае,
[01:09:52.440 --> 01:10:07.200]  если tail не равен NLPTR. Да? Да. Ну то есть если пусто, тогда tail будет NLPTR. Поэтому вот здесь вы
[01:10:07.200 --> 01:10:21.800]  должны написать if q tail не равен NLPTR. Вот так и вот так. То есть вот эта строчка, она только в
[01:10:21.800 --> 01:10:27.320]  этом случае работает. В остальных все то же самое. То есть если у нас, к примеру, пустая очередь,
[01:10:27.320 --> 01:10:36.160]  тогда я создаю ноду и говорю, что q tail равно new-node. Правильно? Правильно. Все просто. Единственное,
[01:10:36.240 --> 01:10:55.240]  что если у нас был NLPTR, то куда должен head указывать? Вот. То есть у нас есть проблема в том,
[01:10:55.240 --> 01:11:04.080]  что если очередь была пустая, то head был NLPTR. Но я добавил элемент. Хедом что должно произойти?
[01:11:04.080 --> 01:11:29.880]  Да. Поэтому здесь я должен написать с вами еще кое-что. Что если q head равен NLPTR. Да? А здесь не
[01:11:29.880 --> 01:11:44.320]  равен. Здесь не равен. Можно в else идти. Хорошо. Можно в else тут написать else там что-то еще. Ну,
[01:11:44.320 --> 01:11:55.920]  как хотите. Действительно. Но если q head равен NLPTR, тогда q head равен new-node. То есть не забывайте
[01:11:55.920 --> 01:12:02.960]  об этих вещах. То есть смотрите на те самые крайние случаи, которые существуют. Вот. Это
[01:12:02.960 --> 01:12:23.160]  просто всего лишь ставка. Что будет с удалением? Почти, да? Вот. А сделаем здесь void delete.
[01:12:25.920 --> 01:12:38.720]  Из очереди. Просто из очереди. Ничего больше не надо. Я беру и удаляю эти элементики. Все нормально,
[01:12:38.720 --> 01:12:47.760]  все хорошо. Теперь следующий момент. Я удаляю элемент из q. А может ли очередь быть пустая? Может
[01:12:47.760 --> 01:12:56.640]  быть. В каком случае очередь пустая? Если head равен NLPTR, ну или если tail равен NLPTR,
[01:12:56.640 --> 01:13:03.800]  правильно? Ну, или если бы мы добавили size, если бы size был равен нулю. Можно написать любую
[01:13:03.800 --> 01:13:18.720]  здесь. Давайте напишем. Если head не равен NLPTR. Если head не равен NLPTR, то я должен удалить этот
[01:13:18.720 --> 01:13:31.040]  элемент. Правильно? А я его удаляю. И на что мне будет указывать head? На следующий после этого
[01:13:31.040 --> 01:13:41.120]  элемент. Правильно? Согласны? Поэтому здесь я говорю следующее. Все так же, нода, звездочка.
[01:13:41.120 --> 01:14:00.160]  Делить нода равняется q.head. Я удаляю тот самый head, который у меня есть. После этого я говорю,
[01:14:00.160 --> 01:14:21.200]  что q.head равен q.head next. Все правильно. Согласны? Согласны. Переношу. И дальше я делаю delete.
[01:14:21.200 --> 01:14:39.360]  Delete нода. Согласны? Ну удаляю. То есть я head переподвесил и удаляю этот элементик. Вопрос,
[01:14:39.360 --> 01:14:53.880]  это все я должен тут написать или нет? Правильно. Если у меня после этого q.head стал равен NLPTR,
[01:14:53.880 --> 01:15:04.840]  то я должен сказать, что q.tail тоже должен стать NLPTR. Согласны?
[01:15:04.840 --> 01:15:27.480]  Нет. Да, мы уже удалили, поэтому оно все изменилось.
[01:15:34.840 --> 01:15:49.480]  Так, хвост. Смотрите, q.tail равно нью ноде. Это нью нода, она может быть NLPTR и NLPTR,
[01:15:49.480 --> 01:15:58.840]  поэтому мне тут без разницы. Оно всегда равно нью ноде. Мы же вставляем элементы,
[01:15:58.840 --> 01:16:13.480]  элемент хоть один всегда да есть. Вопросы. Понятно, как работает очередь? Вопросы есть
[01:16:13.480 --> 01:16:25.560]  к этому всему? Все понятно. А смысл? Тогда для полного вашего познания и чтобы ваше
[01:16:25.560 --> 01:16:32.320]  мировоззрение было полностью знакомо со всем, что существует в мире, на данный момент к вам
[01:16:32.320 --> 01:16:45.960]  применимое. Мы с вами чуть-чуть, вот пять минуток нам будет достаточно, существует другой двунаправленный
[01:16:45.960 --> 01:16:54.080]  лист. Что это такое? Смотрите, когда мы с вами говорили про лист, мы говорили, что мы его
[01:16:54.080 --> 01:17:03.240]  направляем в одну сторону, правильно? Двунаправленный лист управляется в две стороны. То есть у него
[01:17:03.240 --> 01:17:10.920]  один указатель смотрит на предыдущий, другой на следующий, а этот будет смотреть сюда, а этот сюда,
[01:17:10.920 --> 01:17:24.520]  это сюда, это сюда. Можете его самостоятельно реализовать? Я думаю да. Вот, то есть ключ будет
[01:17:24.520 --> 01:17:30.280]  храниться сверху и так далее. Тем хороша такая очередь, тем что мы также можем вставлять элементы
[01:17:30.280 --> 01:17:38.320]  в любое рандомное место. Мы можем с вами удалять элементы из любого рандомного места. И причем
[01:17:38.320 --> 01:17:44.760]  здесь delete будет работать ровно так, как мы планируем, что если мы удаляем конкретный элемент,
[01:17:44.760 --> 01:17:49.840]  то мы очень легко его удалим, потому что у нас есть указатель и на предыдущий, и на следующий.
[01:17:49.840 --> 01:18:00.560]  Правильно? Все становится гораздо проще. И вот на таком вот двухсвязном списке работает
[01:18:00.560 --> 01:18:08.880]  так называемый дек. Пишется он декью. Что это такое? Никогда не пишите, Господи, дек как доску.
[01:18:08.880 --> 01:18:17.720]  Меня один раз убили, когда мне написали вот так. Я сломался. Я вначале не понял, что это значит. А дек
[01:18:17.720 --> 01:18:31.840]  это двунаправленная очередь, поэтому она декью. Ну вот кью есть? Напишите декью. Декью и е, хорошо.
[01:18:31.840 --> 01:18:47.920]  Ну на самом деле дек это такая структура данных, которая позволяет нам добавлять
[01:18:47.920 --> 01:18:59.080]  элементы в начало и в конец и удалять элементы из начала и из конца. То есть она работает,
[01:18:59.080 --> 01:19:03.080]  ну вот она не просто так называется двунаправленная очередь, потому что и в одну сторону как очередь,
[01:19:03.080 --> 01:19:08.680]  и в другую сторону как очередь. И вот этот дек, он позволяет как раз-таки вставлять вот эти
[01:19:08.680 --> 01:19:14.480]  элементики туда-сюда и удалять туда-сюда. Это первое ваше знакомство с деком. В действительности
[01:19:14.480 --> 01:19:23.520]  дек реализован в плюсах вообще по-другому. Вот кто там спрашивал, можно ли зациклить лист,
[01:19:23.520 --> 01:19:30.840]  вот это оно. Оно сделано с помощью такого циклического буфера, где каждый элементик это
[01:19:30.840 --> 01:19:36.920]  лист отдельный, направленный в одну из сторон. Там много всего интересного на самом деле благодаря
[01:19:36.920 --> 01:19:47.600]  этому. А сделано это было только для одной причины, для того чтобы можно было обращаться по индексу
[01:19:47.600 --> 01:19:54.080]  в деке. Зову от единички. И всё. Вот, на сегодня лекция закончена. Всем большое спасибо.
