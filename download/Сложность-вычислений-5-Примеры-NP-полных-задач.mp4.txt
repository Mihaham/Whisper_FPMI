[00:00.000 --> 00:13.920]  Здесь возникает целое семейство задач, которые в каком-то порядке решаются. В общем, возникает то, что
[00:13.920 --> 00:23.200]  называется сеть сводимостей на Web of Reductions. Сначала мы в прошлый раз доказали NP полноту задачу
[00:23.200 --> 00:31.480]  3SAT. Выполним 3KNF. Дальше мы ее к одной сведем, дальше задачу к другой, другую к третьей и так
[00:31.480 --> 00:44.920]  далее. В общем, картина, которую я планирую расписать, вот такая. Есть 3SAT. Дальше она
[00:44.920 --> 01:04.120]  сводится к... Это я назову D HMPath. То есть D особый directed, ориентированный гамильтонов
[01:04.120 --> 01:11.640]  цикл. То есть гамильтонов цикл, не цикл, извините, а путь. Значит, гамильтонов путь, path в ориентированном
[01:11.640 --> 01:19.560]  графе. Дальше, а вот дальше этот самый путь можно в две стороны сводить. Во-первых, можно делать
[01:19.560 --> 01:32.920]  внеориентированную графию. Это называется U HMPath. Значит, гамильтонов цикл в неориентированном
[01:32.920 --> 01:39.480]  графе. Извините, опять заговорю. Значит, гамильтонов путь в неориентированном графе,
[01:39.800 --> 01:56.120]  а может быть гамильтонов цикл в ориентированном. Вот и дальше. Значит, каждая из них может быть
[01:56.120 --> 02:09.880]  сведена к U HMPath cycle, то есть к гамильтонов циклу в неориентированном графе. Но это
[02:09.880 --> 02:14.680]  самое неинтересное. Значит, вот эта сводимость точно такая же, как вот эта вот, а вот эта вот
[02:14.680 --> 02:20.200]  точно такая же, как вот эта вот. То есть это такое бесплатное приложение получается. Ну и в принципе
[02:20.200 --> 02:31.080]  можно еще продолжить это свести к задачкам уважора. Значит, это traveling salesperson problem.
[02:31.080 --> 02:39.800]  Вот. Ну и в принципе могут быть еще вот у задачек уважора есть очень много разных вариаций,
[02:39.800 --> 02:49.320]  и многие из них НФ полные. Соответственно, вот дальше этот принцип можно продолжать. Так,
[02:49.320 --> 02:59.240]  теперь давайте я еще здесь выпишу, что это за задача. Ну, давайте я в общем выпишу HMPath. Ну,
[02:59.240 --> 03:15.000]  а тут соответственно есть варианты DEU. Тут есть на вход дается тройка. Значит, тройка GST. Значит,
[03:15.000 --> 03:39.000]  такая, что в графе G существует гамильтонов путь из S в TA. Вот. Значит, гамильтонов путь означает,
[03:39.000 --> 03:47.400]  что он один раз проходит через каждую вершину, но и при этом тут фиксированы начало и конец. То есть
[03:47.400 --> 03:54.000]  он обязательно должен начинать в S и заканчиваться в T. Вот. Кстати, тут еще одна вариация возникает,
[03:54.000 --> 03:59.520]  а что если не фиксировать, а спрашивать, есть ли хоть какой-то путь, который проходит через все
[03:59.520 --> 04:04.520]  вершины, да, и где-то начинается, где-то заканчивается. Вот. Ну, обсудим тоже какой-то
[04:04.520 --> 04:13.640]  момент. Можно обсудить почему та задача тоже NP полная. Вот. Ну, а соответственно HMPcycle,
[04:13.640 --> 04:23.480]  то есть гамильтонов цикл, но тут только грав да, но уже без выделенных вершин. Да, соответственно,
[04:23.480 --> 04:31.760]  тут точно так же, но гамильтонов цикл, то есть замкнутый маршрут, который ровно один раз
[04:31.760 --> 04:42.480]  проходит через каждую вершину. Вот. Ну, а TSP тоже можно по-разному формулировать. Но
[04:42.480 --> 04:58.120]  я давайте так. Формулирую, значит, TSP. Это множество троек, где есть граф, функция весов w и еще
[04:58.120 --> 05:15.880]  некоторый порог. Ну, можно дать и D от слова distance. Значит, граф, веса и расстояние. Значит,
[05:15.880 --> 05:24.000]  такое, что существует цикл, проходящий через каждую, да, веса, это что такое веса, это функция
[05:24.000 --> 05:29.960]  из ребер графа в числа. То есть на каждом левре есть число. Это ввешенный граф называется.
[05:29.960 --> 05:45.000]  Значит, существует цикл, проходящий хотя бы один раз, не меньше одного раза через каждую вершину.
[05:45.000 --> 06:05.400]  Соответственно, суммарным весом не больше, чем D. Значит, вот это уже задача оптимизации. То есть
[06:05.400 --> 06:11.760]  задача такая, что коми в Эжор ездят по разным городам и должен в каждом городе побывать хоть
[06:11.760 --> 06:23.680]  один раз, чтобы там что-нибудь продать. И, соответственно, вопрос, сможет ли он это
[06:23.680 --> 06:30.640]  сделать, затратив, да, там проехав суммарное расстояние не больше D. А вот это w — это
[06:30.640 --> 06:36.520]  кросс-функция, которая говорит, сколько времени или там сколько по расстоянию ехать из одного
[06:36.520 --> 06:44.080]  города в другой. Вот. Соответственно, тут бывают самые разные вариации. Например, можно требовать,
[06:44.080 --> 06:51.800]  но простейшие задачи — это так называемый ефклидовый коми в Эжор, когда вот эти веса возникают
[06:51.800 --> 06:58.800]  просто из-за обычного расстояния геометрического, ну в каком-то пространстве. Вот. Бывает метрический
[06:58.800 --> 07:05.200]  коми в Эжор, когда веса какие угодно, но выполняют соединенность треугольника. То есть это все-таки
[07:05.200 --> 07:11.680]  смысл именно в том, чтобы там как-то ехать. И, соответственно, всегда можно из города A в город
[07:11.680 --> 07:19.960]  B поехать через город C, и поэтому расстояние напрямую будет уж не больше, чем если заезжать в город C.
[07:19.960 --> 07:27.400]  Поэтому выполняется, наверное, с треугольника. Но можно, в принципе, и это ослабить, да, говорить,
[07:27.400 --> 07:35.080]  что это не расстояние, а просто какие-то числа, и что если я иду из города там A в город C,
[07:35.080 --> 07:47.480]  то тогда там вниз может быть очень большое расстояние. Вот. Ну а дальше там может быть,
[07:47.480 --> 07:56.840]  например, может быть, например, такая постановка, что надо просто в каком-то
[07:56.840 --> 08:03.880]  порядке их посетить ровно один раз. Например, это полный граф, веса какие угодно, нужно посетить
[08:03.880 --> 08:11.400]  ровно один раз каждый город, ну и чтобы сумма этих затрат была как можно меньше. Вот. Ну,
[08:11.400 --> 08:18.760]  соответственно, вот это можно и рассмотреть так практически. Может это быть, на самом деле,
[08:18.760 --> 08:22.840]  например, не комивая Azure, а какой-то такой автоматический тестировщик программ,
[08:22.840 --> 08:27.920]  который должен там все ситуации, которые в программе могут быть, проверить. И он их в каком-то
[08:27.920 --> 08:32.800]  порядке что-то где-то переключает, какие-то характеристики, и, соответственно, должен
[08:32.800 --> 08:39.680]  что-то вот так переключить, чтобы все ситуации проверить. Вот это вот пример, пример задач,
[08:39.680 --> 08:46.000]  которые не связаны с поездками, но при этом собуются задачками Azure. Вот. Ну и так далее.
[08:46.000 --> 09:00.440]  Значит, и так далее. В общем, кучу разных, кучу разных вариантов можно рассмотреть. Так. Ну,
[09:00.440 --> 09:06.840]  давайте я начну показывать все эти сводимости. Значит, самое главное будет первое. Значит,
[09:06.920 --> 09:13.000]  самое главное будет первое, значит, когда мы вообще как бы совершаем прыжок из мира
[09:13.000 --> 09:21.840]  бульевых формулов в мир графов. Так. Значит, смотрите. Вообще общая идея, когда мы трясат
[09:21.840 --> 09:31.320]  куда-то сводим, то что нужно сказать? У нас в этих формулах есть какие-то переменные и какие-то
[09:31.320 --> 09:39.480]  скобки, дизъюнкты тремя литералами. И, соответственно, нужно внутри той конструкции,
[09:39.480 --> 09:44.720]  которую мы строим, в данном случае внутри графа, иметь некоторые фрагменты, так называемые гаджеты.
[09:44.720 --> 09:54.600]  Значит, гаджеты для переменных и гаджеты для скобок. Как-то нужно их описать. При этом гаджет
[09:54.600 --> 09:58.400]  для переменной должен быть таким, что там есть какие-то два варианта. Один вариант соответствует
[09:58.400 --> 10:04.520]  истине, другой соответствует лжи. Ну а гаджет для скобки каким-то образом соответствует тому,
[10:04.520 --> 10:14.320]  истинен один из составовечек литералов или нет. Ну вот, значит, гаджет для переменной выглядит
[10:14.320 --> 10:35.000]  вот так вот. Гаджет для переменной выглядит вот так, такой ромбик. Сейчас я сначала вершинки
[10:35.000 --> 10:48.080]  нарисую, чем он идет вот сюда, вот так вот, потом вот так вот, так, потом вот так вот. Так, и при этом
[10:48.080 --> 11:04.240]  здесь все туда-сюда. Вот эти все ребра двухсторонние. Вот такая вот штука соответствует переменной.
[11:04.240 --> 11:14.800]  Соответственно, ее нужно проходить сверху вниз. И, значит, можно сказать так, что можно обходить
[11:14.800 --> 11:26.800]  двумя способами. Есть зигзаг, вот такой вот нормальный, и есть, наоборот, загзиг. Загзиг вот такой вот
[11:26.800 --> 11:35.680]  симметричный. Соответственно, если нужно пройти сверху вниз, да и вообще, если нужно все вершины
[11:35.680 --> 11:42.320]  обойти, то вообще никаких других способов нет. Из-за односторонности вот этих ребер нужно начинать
[11:42.320 --> 11:48.480]  сверху, заканчивать снизу. Дальше здесь выбор один из двух, а дальше, если он сделан, то автоматически,
[11:48.480 --> 11:53.800]  если мы сюда пройдем, то вот эти мы никогда не посетим. Дальше, собственно, никаких других
[11:53.800 --> 12:02.560]  вариантов нет. Соответственно, должны проходить вот так вот. Вот, значит, и дальше мы из таких
[12:02.560 --> 12:10.480]  гаджетов, значит, такие гаджеты делаем для каждой переменной и строим такую гирлянду. Значит,
[12:10.480 --> 12:23.640]  это вот для переменной P, дальше такая же гирлянда, такой же гаджет для переменной Q,
[12:23.640 --> 12:41.960]  и тоже все туда-сюда. Вот, можно сцеплять их вот так вот, да, можно делать отдельную
[12:41.960 --> 12:50.040]  перемычку, это неважно. Значит, дальше для R, и так для всех переменных, которые у нас тут есть.
[13:11.960 --> 13:19.280]  Так, я пока не сказал, насколько длинны вот эти цепочки внутри гаджетов должны быть, но это сейчас
[13:19.280 --> 13:26.760]  станет понятно. Значит, заведомо хватит 3 умножить на число скобок, ну, еще плюс один. В общем,
[13:26.760 --> 13:35.360]  реально надо следующее. Реально нужно, чтобы для каждой скобки была выделена пара вершин,
[13:35.360 --> 13:42.000]  которая как-бы была совершенно отдельна. Вот, значит, вот эта вот часть гирлянды для переменных,
[13:42.000 --> 13:56.000]  и дальше она дополняется так. Значит, пусть у нас будет P, например, или не Q, или R. Тогда
[13:56.000 --> 14:05.880]  смотреть, что мы делаем. Вот у нас P, как раз гаджеты PQR, и переменные PQR входят. Если у нас
[14:05.880 --> 14:11.920]  входит сама переменная без отрицания, то, значит, мы выбираем вот эти вот, отступаем,
[14:11.920 --> 14:21.920]  пропускаем одну вершину, выбираем вот эти вот две. И дальше говорим так, что вот из левой из них
[14:21.920 --> 14:31.920]  отправляем ребро сюда, а потом возвращаем в правую. Вот, а если не Q, значит, если с отрицанием,
[14:31.920 --> 14:45.280]  то наоборот. Из правой вершины отправляем ребро сюда, и возвращаем в левую. Вот, ну и последняя
[14:45.280 --> 15:13.400]  тоже тут из левой, соответственно, из левой сюда. Возвращаем в правую. Вот. Хорошо. Зачем так
[15:13.400 --> 15:20.600]  сделали? В чем идея? Ну, идея такая, что, смотрите, если у нас, если мы идем зигзагом, то мы можем в этот
[15:20.600 --> 15:29.720]  момент пойти вот в эту вершину, вернуться в соседнюю и продолжать идти зигзагом. Вот. А вот если
[15:29.720 --> 15:35.320]  мы шли загзигом, то мы не могли бы вот отсюда пойти сюда и вернуться сюда же, потому что эта
[15:35.320 --> 15:40.720]  вершина мы уже прошли. А с отрицанием, наоборот, если мы идем загзигом, то мы можем пройти вот
[15:40.720 --> 15:46.800]  этой правой вершины, прийти сюда, вернуться сюда и пойти дальше. А наоборот, с зигзагом бы не
[15:46.800 --> 16:00.480]  смогли, ушли бы сюда, надо было бы возвращаться туда, где мы уже были. Вот. Значит, вот получается
[16:00.480 --> 16:12.120]  такая картина. И, соответственно, понятно, что делать, если у нас форма выполнима. Значит,
[16:12.120 --> 16:22.600]  если форма выполнима. Да. Значит, тут дальше, если перенена входит в много разных скобок, то для нее
[16:22.600 --> 16:27.200]  тут нужно отдельные другие еще пары выбрать. Вот эту одну пропустить, следующую пару для
[16:27.200 --> 16:31.760]  другой скобки, одну пропустить, следующую пару для другой скобки. И, соответственно, в цепочке
[16:31.760 --> 16:38.600]  должно быть столько вершин, чтобы на все скобки хватило. Вот. За этим достаточно в каждом гаджете
[16:38.600 --> 16:47.840]  выделить достаточно вершин для всех скобок. Вот. Так вот, если форма выполнима, тогда есть такой
[16:47.840 --> 17:06.080]  канонический путь. Есть канонический путь. Значит, идем по гаджетам. Идем по гаджетам.
[17:06.080 --> 17:21.320]  Соответственно, если P i t равно 1, то обходим вот так вот. Если P i t равно 0, то обходим вот так вот.
[17:21.320 --> 17:28.400]  И, соответственно, при первой возможности посещаем вершины, соответствующие скобкам.
[17:28.400 --> 17:54.840]  Значит, при первой возможности посещаем вершины, соответствующие скобкам. Вот. А возможности это
[17:54.840 --> 17:59.520]  обязательно наступит, потому что в каждой скобке естественный литерал. И в тот момент,
[17:59.520 --> 18:07.720]  когда мы проходим по соответствующей переменной, мы сможем эту скобку посетить. Так. Понятно?
[18:07.720 --> 18:19.520]  Хорошо. Но этого недостаточно. Нужно еще обратно доказать, что если есть путь, то форма выполнима.
[18:19.520 --> 18:43.440]  Обратно. Пусть есть путь. Вот. Значит, тогда смотрите. На самом деле, если он канонический,
[18:43.440 --> 18:56.320]  то более-менее точно так же можно обратную сторону провести. Если он канонический, то тогда все обратимо.
[18:56.320 --> 19:08.480]  Значит, можно обратить рассуждение. Да, то есть как обратить, что, соответственно, если мы
[19:08.480 --> 19:14.880]  обходим зиг-загом, то переменная равна единице. Если обходим заг-зигом, то переменная равна нулю.
[19:14.880 --> 19:24.800]  И поскольку мы смогли посетить вершину и вернуться туда же, то, значит, соответствующий литерал,
[19:24.800 --> 19:30.920]  входящий в скобку, будет истинным. И так со всеми скобками, раз мы все вершины посетили, значит,
[19:31.480 --> 19:39.720]  форма истины. Вот. И проблема только в том, что нужно исключить не канонические пути.
[19:39.720 --> 19:53.160]  Когда путь идет, например, вот так вот, но тем не менее уходит вот по этому ребру, уходит туда, но сюда он
[19:53.160 --> 19:58.600]  вернуться не может, он возвращается еще куда-то. И там как-то еще ходит, куда-то перескакивает, что-то такое
[19:58.600 --> 20:05.000]  делает. Нужно показать, что такого быть не может, что он все вершины посетить не сможет.
[20:05.000 --> 20:11.880]  Но в данном случае в такой ситуации это очевидно, потому что если он уйдет вот отсюда, вот тогда вот
[20:11.880 --> 20:20.520]  эта вот вершина останется заведомо непосещенной. Потому что она останется висячей, да, нам нужно...
[20:20.520 --> 20:27.320]  Да, кстати, я что-то говорил, что вот есть S и T, начальник, конечно, вершина, я тут их не указал,
[20:27.320 --> 20:38.160]  но имеется ввиду так, что вот эта самая верхняя, это S, самая нижняя, это T. Вот. Ну вот, и нам нужно
[20:38.160 --> 20:43.040]  прийти сюда, а у нас осталась висячая вершина, мы в нее, может, не сможем прийти, а вот выйти из нее
[20:43.040 --> 20:51.080]  точно не сможем, поэтому продолжить долгомельтонного пути не получится. Вот. Ну и так как раз вот если мы
[20:51.080 --> 20:58.680]  оставляем вот эти вот пробелы между парами, которые отводятся на посещение туда, то такое заведомо будет
[20:58.680 --> 21:11.000]  работать. Значит, такое заведомо будет работать, заведомо будут висячие вершины. Такое рассуждение,
[21:11.000 --> 21:15.400]  в смысле, будет работать, что у нас остается висячая вершина, которая точно не будет посещена,
[21:15.400 --> 21:23.520]  если мы пошли как-то не в том направлении. Так, ну да, значит, дайте это я отдельно напишу,
[21:23.520 --> 21:50.560]  значит, не канонического не может быть. Значит, так как при сходя с гаджета и возвратив другой гаджет,
[21:50.560 --> 22:12.000]  и возвратив другой гаджет остается висячая вершина.
[22:12.000 --> 22:34.560]  Вот. Которую уже потом нельзя посетить. Да? Ну вот. Вот. Поэтому все нормально. Какие-нибудь вопросы?
[22:42.560 --> 22:53.720]  Нет, по гаджету мы не можем вернуться наверх, потому что у нас все ребра сверху вниз. А неважно,
[22:53.720 --> 22:59.160]  да, в принципе, мы можем еще пройти вот так вот и сразу пойти сюда, но тут точно так же,
[22:59.160 --> 23:08.840]  точно так же останется висячая вершина. Нет, мы в принципе, мы сможем вернуться сюда, но посетить
[23:08.840 --> 23:19.400]  вот эту оставшуюся висячую вершину и из нее потом уйти мы уже не сможем. А потому что нельзя
[23:19.400 --> 23:26.680]  второй раз посещать. Это же гаметонов цикл, путь, точнее. То есть тут как раз специально вот эти вот
[23:26.680 --> 23:32.480]  перемычки, их уже нельзя второй раз посещать, поэтому так. Вообще, насколько я понимаю,
[23:32.480 --> 23:36.280]  даже если эти пробелы не делать, все равно будет верно, но там будет какое-то сложное рассуждение.
[23:36.920 --> 23:43.800]  Почему, если вот здесь будет вплотную, и дальше вплотную, то почему все равно все нельзя обойти.
[23:43.800 --> 23:49.680]  Там, на всякий понявший, если мы сходим, там как-то все разваливается и не должно
[23:49.680 --> 24:04.320]  получиться и везде все исправить. Вот, так. Ну, дальше, давайте я покажу, как путь к циклу сводить.
[24:04.320 --> 24:20.520]  Так, значит, вот пусть у меня какой-то граф есть, на самом деле неважно, ориентированный,
[24:20.520 --> 24:30.600]  не ориентированный. В нем есть S и в нем есть T. Вот. Ну и первая идея такая. Давайте мы просто
[24:30.680 --> 24:39.720]  возьмем и вот такое вот ребро добавим наоборот из T в S. Тогда, если есть путь из S в T,
[24:39.720 --> 24:47.040]  то вместе с этим ребром будет цикл. Видите ли вы ошибку в этом рассуждении?
[24:47.040 --> 24:59.080]  Но да, да, дело в том, что нужно и в обратную сторону. Значит, в принципе, конечно, вот эта
[24:59.080 --> 25:05.680]  часть верна. Если был путь, то с добавлением вот этого ребра будет цикл. Но, в принципе,
[25:05.680 --> 25:13.760]  может быть цикл в новом графе, который это новое ребро не затрагивает и в котором S и T не подряд.
[25:13.760 --> 25:25.400]  И тогда может быть так, что есть цикл, где S и T не подряд, но при этом пути из S в T в
[25:25.400 --> 25:29.480]  исходном графе не было. Ну, например, если в играх это просто такой цикл,
[25:29.480 --> 25:37.880]  там S и T с разных сторон, тогда там ясно, что нет пути из S в T. Вот. Но когда мы добавим такое,
[25:37.880 --> 25:48.000]  то появится как бы цикл, никуда не денется, если уж он был. Вот. Ну а чтобы от этого избавиться,
[25:48.000 --> 25:56.560]  нужно тут еще посередине добавить еще одну вершину, какую-то новую W, хранением ориентации.
[25:56.560 --> 26:03.760]  И вот тогда-то в ту сторону все точно так же был путь. Мы добавили два ребра,
[26:03.760 --> 26:10.320]  получился цикл. А в обратную сторону, смотрите, если тут есть гамильтонов цикл, то он обязан
[26:10.320 --> 26:17.880]  проходить через новую вершину W. А у W вообще всего два ребра, одно входящее, одно исходящее,
[26:17.880 --> 26:23.600]  значит они на этом цикле должны быть. Вот. Значит, на этом цикле есть цепочка T, потом W,
[26:23.600 --> 26:31.640]  а потом S. Ну а весь остаток этого цикла будет как раз путем из S в T в исходном графе без вот
[26:31.640 --> 26:53.680]  этой добавки. Вот. Ну ничего, понятно? Так, отлично. Отлично. Так, теперь давайте поговорим,
[26:53.680 --> 27:01.400]  как ориентацию снимать. Значит, переходить... Да, вот это рассуждение, но годится и без ориентации
[27:01.400 --> 27:08.240]  тоже. Да, если тут просто это ребра, то все равно должны быть эти два ребра подряд, и тогда есть путь
[27:08.240 --> 27:30.160]  вот там. Так. Хорошо. Значит, теперь, как сводить ориентированный путь к неориентированному. Так. Ну,
[27:30.160 --> 27:37.200]  смотрите, опять же, первая идея, а мы просто вообще забудем ориентацию. Тогда, если был там путь,
[27:37.200 --> 27:45.120]  то и он и останется. Но, конечно, та же самая ошибка. Может быть так, что за снятие ориентации путь
[27:45.120 --> 27:51.160]  есть, а до снятия его не было. Нужно не только чтобы старый сохранился, но и чтобы нового не
[27:51.160 --> 28:04.480]  появилось. Вот. И для этого идея такая, что мы каким-то образом попробуем записать, закодировать
[28:04.480 --> 28:15.320]  ту ориентацию, которая была, через неориентированные ребра. Так. Ну, это делается вот так вот. У нас
[28:15.320 --> 28:37.360]  какая-то вершина X превращается в такую тройную вершину. X in, X mid и X out. Так, что средняя соединена
[28:37.520 --> 28:45.600]  входной и выходной. И больше вообще ни с кем. Ну, то есть получается, что если у нас была какая-то
[28:45.600 --> 28:53.280]  вершина, да, у нее было, были какие-то входящие ребра, были какие-то исходящие. На то дальше
[28:53.280 --> 29:02.680]  получается такая штука, да, она получается тройкой. И у тех всех тоже тройки. И, соответственно,
[29:02.680 --> 29:09.760]  дальше мы делаем следующее. Если у нас было ребро из одной вершины в другую, то мы теперь
[29:09.760 --> 29:17.080]  соединяем входную, наоборот, выходную вершину, которая из первой тройки, со входной из второй
[29:17.080 --> 29:30.440]  тройки. Соответственно, здесь тоже вот так вот. Ну и дальше более-менее понятно,
[29:30.440 --> 29:39.280]  почему сохранится, да, например, если вот мы прошли вот по этому ребру, потом по этому ребру,
[29:39.280 --> 29:44.480]  на то здесь мы соответственно идем вот так вот, потом вот так вот, потом вот так вот,
[29:44.480 --> 29:55.160]  потом вот так вот, потом
[29:55.160 --> 29:56.920]  в выходную. Дальше проходим через
[29:56.920 --> 29:57.260]  vi,
[29:57.260 --> 30:02.700]  оказываемся в выходной, идем в следующую входную, и так далее, все проходим.
[30:02.700 --> 30:10.700]  И опять же нужно доказать, что не получится нового пути или цикла
[30:10.700 --> 30:15.920]  паразитного. Потому что, в принципе, мы что могли сделать? Мы могли пройти вот так,
[30:15.920 --> 30:19.580]  вот пройти сюда, дальше вместо того, чтобы пойти сюда, пойти куда-то вот сюда,
[30:19.580 --> 30:24.600]  как бы по ребру, как бы обратно. Но опять, в принципе, то же самое, ровно за этим
[30:24.600 --> 30:28.720]  нам и нужна средняя вершина. Если мы здесь пошли не в том направлении, то у нас
[30:28.720 --> 30:35.440]  средняя вершина останется висячей, и мы ее потом не сможем посетить. Вот, поэтому мы
[30:35.440 --> 30:44.160]  обязаны вот так вот проходить и никак иначе. Вопрос какие-нибудь?
[30:44.200 --> 30:53.640]  Так, ну ладно, это сейчас перерыв, 5 минут. Чуть-чуть поговорим про коммивоежора,
[30:53.640 --> 31:04.040]  и потом еще пару тем, я хочу затронуть. Значит, вот осталась последняя задача в этой
[31:04.040 --> 31:15.120]  сети, это задача о коммивоежоре. Вот, ну на самом деле очень легко, скажем,
[31:15.120 --> 31:30.920]  Гамильтонов цикл сводится к коммивоежору, как там написано. Ну, самое простое,
[31:31.040 --> 31:45.320]  например, что просто граф тот же самый, веса всеединичная, а порог D это просто
[31:45.320 --> 31:57.600]  число вершин. То есть, можно ли обойти все вершины, затратив расстояние n? Но это как раз
[31:57.600 --> 32:09.520]  тогда и только тогда, когда есть Гамильтонов цикл. Да пусть даже можно, тут это совершенно
[32:09.520 --> 32:18.000]  неважно. Но если еще и нельзя, то там получится не просто Гамильтонов цикл, а еще короткий Гамильтонов
[32:18.000 --> 32:25.720]  цикл. Вот, а тут можно, но все равно, если у вас цикл и все вершины посещены, то никакая повторяться
[32:25.720 --> 32:33.480]  не может по принципу дирехля. Если цикл влит на n и n-вершина посещена, то значит ничего другого быть
[32:33.480 --> 32:45.840]  не может. Вот, можно рассматривать разные другие варианты. Например, если требовать, что это полный
[32:45.840 --> 32:52.920]  граф, то, например, можно сказать так, пусть те ребра, которые были в исходном графе, будут веса
[32:52.920 --> 33:01.400]  1, а те, которых не было, будут веса 2. И тогда, если мы заянно обошли, то все равно мы прошли
[33:01.400 --> 33:14.000]  приорванным веса 1. Вот, и поэтому, кстати, поэтому получается, что уже за дачками воежора, где веса
[33:14.000 --> 33:32.800]  либо 1, либо 2, уже будет NP полной. Вот отсюда же, на самом деле, возникает вот такой задач куми воежора,
[33:32.800 --> 33:42.440]  где нельзя как раз повторять вершины, но зато все ребра есть какими-то весами. Вот с такой задачей
[33:42.440 --> 33:55.720]  получится, что трудно не только точно решить, но и приблизить. Потому что, в принципе, можно
[33:55.720 --> 34:13.720]  ставить задачу так. Ну хорошо, допустим, мы не сумели найти точное оптимум, точный минимум, но
[34:13.720 --> 34:22.280]  может, ну хоть приближенно его сможем найти. Вот, но в такой вариации даже
[34:22.280 --> 34:30.640]  приближенно нельзя. Значит, вариация, что полный граф с весами, полный граф с весами,
[34:30.640 --> 34:54.960]  и нельзя повторять вершины. Повторять вершины нельзя. Значит, тогда можно сводить так. Может,
[34:54.960 --> 35:08.480]  что точно был граф, и, соответственно, если было ребро, то вес равен единице. А если не было,
[35:08.480 --> 35:18.160]  то тогда вес равен какому-то большому числу m. Вот, тогда, соответственно, если был,
[35:18.160 --> 35:37.720]  значит, если был гамильтонов цикл, то тогда тут есть цикл веса m, цикл веса m. Вот, а если не было,
[35:37.720 --> 35:58.640]  то тогда только веса, ну может быть, больше либо равно m. Ну, тут можно даже плюс или минус 1 написать,
[35:58.640 --> 36:04.720]  это всё не очень важно уже. Значит, больше либо равно m. Ну, вот это я могу каким угодно выбирать,
[36:04.720 --> 36:09.960]  и тогда получается, что как бы вот это вот оптимальное значение вот в этом случае может быть
[36:09.960 --> 36:17.440]  сколь угодно больше оптимального значения в этом случае. Значит, вот это m поделить на n
[36:17.440 --> 36:30.760]  сколь угодно велико. И отсюда очень легко получается, что уже приближение с любой
[36:30.760 --> 36:54.160]  точностью будет NP трудным. Ну, то есть что значит приближение NP трудно? Ну, это означает,
[36:54.160 --> 37:01.080]  что представьте, что у вас есть какая-то программа, которая умеет находить ответ,
[37:01.080 --> 37:09.480]  который не больше, чем в k раз, больше, чем минимальный. Но тогда, если это k будет меньше,
[37:09.480 --> 37:21.680]  чем вот это отношение, тогда уже такая программа позволит решить задачу гамильтонов цикля. Потому
[37:21.680 --> 37:25.520]  что, соответственно, если получилось меньше, чем вот столько, значит, если меньше, чем m,
[37:25.520 --> 37:30.760]  значит уже гамильтонов цикл был обязательно. А если не получилось, то не получилось.
[37:30.760 --> 37:40.280]  Ещё раз. Значит, ещё раз. Пусть у вас есть какая-то программа, которая умеет говорить
[37:40.280 --> 37:46.080]  следующее. Она умеет, например, говорить число, которое больше либо равно оптимального значения,
[37:46.560 --> 37:53.080]  но меньше, чем какое-то k умножить на оптимальное значение. Вот она с точностью k умеет решать
[37:53.080 --> 38:00.000]  задачу минимизации. Вот тогда, если k меньше, чем вот столько, то тогда такая программа позволит
[38:00.000 --> 38:06.600]  решить задачу гамильтонов цикля. Что мы по гамильтонову циклу построим вот такую задачу
[38:06.600 --> 38:14.000]  Комиевого и Жора, и дальше либо ответ ровно n, и тогда нам приближающая программа даст не больше,
[38:14.000 --> 38:22.000]  чем каен, и каен будет меньше, чем m большое, и любое число меньше, чем m большое сообщит нам,
[38:22.000 --> 38:27.760]  что гамильтонов цикл был. Ну либо, соответственно, она сказала больше, чем m, и это значит,
[38:27.760 --> 38:32.760]  что цикла не было. То есть даже такое приближённое решение уже позволит решать
[38:33.760 --> 38:45.320]  гамильтонову цикле. Вот, и вот тут поведение совершенно разное для разных задач. То есть вот тут
[38:45.320 --> 38:54.200]  вот такая вот вариация задач Комиева и Жора получается сложна для приближения с любой точностью.
[38:54.640 --> 39:03.800]  Вот, а вот разные другие, например, наоборот, будут решаться приближенно. Например, задача в рюкзаке
[39:03.800 --> 39:12.080]  может быть решена приближенно. Или, например, тот же Комиевый и Жор, но для Евклидова расстояние тоже
[39:12.080 --> 39:21.880]  может быть решён приближенно. Это Орора придумал в своё время. Там не такое уж простое рассуждение,
[39:21.880 --> 39:29.200]  но, в общем, можно решить. А вот, например, если задача метрическая, да, это получается не метрическое,
[39:29.200 --> 39:36.800]  потому что если мы можем пройти, то как-то в обход. В обход будет сколько-то ребер, а тут прям m большое.
[39:36.800 --> 39:45.000]  Соответственно, это не метрическая задача. А для метрического Комиева и Жора известен ещё в 70-х
[39:45.000 --> 39:54.440]  годов алгоритм приближения с точностью 1,5. Да, значит, он долгое время был известен под именем
[39:54.440 --> 40:00.160]  алгоритм Кристофидуса, но недавно откопали, что новосибирский учёный Сердюков одновременно и
[40:00.160 --> 40:05.640]  независимо тоже его придумал, и теперь его называют алгоритм Кристофидуса Сердюкова.
[40:05.640 --> 40:16.280]  Вот. И там ещё недавно было какое-то совершенно миниатюрное улучшение, которое ещё и вероятностное,
[40:16.280 --> 40:21.840]  что, в общем, там что-то в среднем получалось, вместо 3 вторых, там получалось 3 вторых минус
[40:21.840 --> 40:29.480]  какое-то совершенно миниатюрное число, типа 10 в минус 36, там что-то такое. Ну, вот это в теории
[40:29.480 --> 40:36.400]  часто бывают такие достижения, что изменения в каком-то там восьмом знаке, ну а тут вообще в 36-м знаке.
[40:36.400 --> 40:49.560]  Вот. И это, тем не менее, все изучают. Вот. А есть также оценки с другой стороны, что там с какой-то
[40:49.560 --> 40:59.440]  точностью, типа там 122-121, уже НП трудно приближать. Вот. И соответственно, вот есть зазор. Есть зазор,
[40:59.440 --> 41:09.880]  между 3 вторыми и 2-мя 121-мя, между которыми непонятно, насколько сложны задачи о приближении. Вот.
[41:09.880 --> 41:16.440]  И это тоже очень хорошая область, трудность приближённых вычислений. Значит, в этом курсе мы это изучать не будем,
[41:16.440 --> 41:24.000]  чуть-чуть поговорим в топ-главах. А потом, может быть, если будет желание, через год прочту спецкурс.
[41:24.200 --> 41:33.000]  Эти темы, это называется PCP, варианта проверяемой доказательства. Вот. И там, удивительно образом,
[41:33.000 --> 41:39.520]  совершенно разные, на первый взгляд, вещи друг с другом связаны. Вот. И это, в принципе, тоже вполне
[41:39.520 --> 41:48.320]  местами передние краи науки. Значит, там были очень большие продвижения в начале 2000-х годов, 15-20
[41:48.320 --> 41:54.720]  лет назад. Сейчас немножко это приутихло, но, тем не менее, там многие задачи остались открытыми.
[41:54.720 --> 42:01.680]  И можно про... С одной стороны, можно пытаться придумывать более эффективные алгоритмы, которые
[42:01.680 --> 42:09.040]  решают те или иные задачи. С другой стороны, можно пытаться более сильные оценки доказывать,
[42:09.040 --> 42:19.560]  что с какой-то меньшей степенью приближения будет МП трудно задачи приблизить. Вот. Так, хорошо.
[42:19.560 --> 42:34.040]  Значит, про что еще я хочу поговорить? Да. Кто, Perfect Matching? Нет, парсочетание,
[42:34.040 --> 42:42.120]  как раз, полиномиальная задача. Ну, конечно, да. Не, вот это совершенно полиномиальная,
[42:42.120 --> 42:49.440]  а вот если максимизировать, там, максимальная, вроде тоже полиномиальная. Ну, совершенно что такое,
[42:49.440 --> 43:00.000]  что мы находим набор ребер, которые попарно не пересекаются. Вот. Это не просто полиномиальная,
[43:00.000 --> 43:07.400]  а это именно при решении этой задачи Эдманс придумал класс П. Он сначала придумал алгоритм
[43:07.400 --> 43:17.640]  с тягиваниями лепестков, а потом сказал, что вот он полиномиальный, и как раз полиномиальным
[43:17.640 --> 43:26.240]  и нужно считать... Ну, как полиномиальным, нужно определять все эффективное. Вот. А вот если у вас
[43:26.240 --> 43:32.640]  не парсочетание, а сочетание по тройкам, да, например, у вас есть какой-нибудь там гиперграф из
[43:32.640 --> 43:41.320]  треугольников, и нужно найти не пересекающие треугольники, как можно в большем числе. Вот такая
[43:41.320 --> 43:57.880]  задача уже Энп-полная. Вот. Так, хорошо, значит, про что я еще хочу сказать. Но есть еще вот несколько
[43:57.880 --> 44:05.360]  важных Энп-полных задач, которые такие архетипические, одна из них CLP. Значит,
[44:05.360 --> 44:16.680]  CLP — это целочисленное линейное программирование. Вот. Но это можно формулировать по-разному. Вот.
[44:16.680 --> 44:24.720]  Но, например, можно спрашивать так. Вот у вас есть какая-то целочисленная матрица и какой-то
[44:24.720 --> 44:37.440]  целочисленный вектор, и вопрос... Ну, например, вот так вот. Да, какое-то неравенство, и вопрос
[44:37.440 --> 44:55.680]  имеет ли решение в целых числах. То есть A — целочисленная матрица, B — целочисленный
[44:55.680 --> 45:02.080]  вектор. И спрашивается, есть ли у системы неравенств, которые заданы этой матрице, целочисленное
[45:02.080 --> 45:10.760]  решение. О, значит, если вопрос о целочисленности не станет, то это просто обычное линейное
[45:10.760 --> 45:17.600]  программирование. И, соответственно, там на самом деле есть полиномиальное решение, хотя на
[45:17.600 --> 45:21.880]  практике как раз используется экспедиционный симплекс метод. Экспедиционный, в худшем случае,
[45:21.880 --> 45:30.000]  симплекс метод. Вот. Значит, на самом деле очень многие задачи удобно формулировать в таких
[45:30.000 --> 45:39.640]  терминах. Вот. Ну, например, например, вершинное покрытие можно так сформулировать. Да,
[45:39.640 --> 45:49.920]  для каждой вершины ввести там переменную xv, написать, что это xv больше либо равно нуля, xv меньше
[45:49.920 --> 45:57.760]  либо равно единице. Соответственно, единица значит, что мы вершину берем, ноль что не берем. Значит,
[45:57.760 --> 46:05.000]  дальше сумма всех xv будет меньше либо равно, чем k. Это означает, что мы не больше k вершин взяли.
[46:05.000 --> 46:19.200]  И при этом для любого ребра, для любого vw из ребра, получится, что xv плюс xw будет больше либо
[46:19.200 --> 46:27.080]  равно единице. Да, то есть из двух концов каждого ребра хотя бы один мы взяли. Вот. Ну, вот как раз
[46:27.080 --> 46:33.760]  получается большая система линейных равнений, линейных, извините, неравенств с целыми
[46:33.760 --> 46:42.560]  коэффициентами. И более того, даже значение либо ноль, либо единица. А решить, да, понять, есть ли у
[46:42.560 --> 46:50.600]  этой системы решение, то же самое, что решить задачу о вершинном покрытии. Вот. Ну и так, на самом
[46:50.600 --> 46:57.400]  деле, ну, в принципе, уже из этого можно сказать, что про вершинное покрытие мы доказали, что оно
[46:57.400 --> 47:06.600]  mp-полное. Значит, мы его вот так вот свели, и это тоже будет mp-полное. Вот. Но реально там очень много
[47:06.600 --> 47:15.320]  разных задач, так удобно формулировать. Но на самом деле, я так сказал, я кое-что запрятал. На самом
[47:15.320 --> 47:21.000]  деле, когда мы так свели, мы доказали только mp-трудность. А чтобы сказать mp-полноту, нужно
[47:21.000 --> 47:29.160]  еще отдельно сказать, что эта задача лежит в mp. И это, на первый взгляд, очевидно. Ну как, если
[47:29.160 --> 47:34.840]  решение есть, то мы его предъявим и проверим. Но на второй взгляд, совсем не очевидно, потому что
[47:34.840 --> 47:44.280]  нужно не просто чтобы решение было, а чтобы оно еще было не слишком большое. Понятно, да? Нужно
[47:44.280 --> 47:50.680]  не просто число переменных должно быть маленьким, но и сам размер решения должен быть не больше
[47:50.680 --> 47:57.160]  чем экспоненциальным, чтобы по линомерным числам битов можно было эти числа записать. Вот.
[47:57.160 --> 48:01.800]  Ну, это, на самом деле, можно доказать. Я думаю, я сейчас подробно не буду на этом останавливаться,
[48:01.800 --> 48:09.240]  но идея на конструкцию такая, что мы доказываем, что если есть какое-то решение, то есть не слишком
[48:09.880 --> 48:15.640]  большое решение. А как мы это доказываем? Мы предполагаем, что там все решения слишком большие,
[48:15.640 --> 48:22.680]  берем из этих слишком больших самое маленькое и показываем, что его можно еще уменьшить, если оно
[48:22.680 --> 48:31.160]  все-таки действительно слишком большое. Но потому что там идея такая, что... Ну, смотрите, если у
[48:31.160 --> 48:38.280]  нас х это решение системы а на х равно нулю, целочистое решение системы а на х равно нулю,
[48:38.280 --> 48:47.680]  то тогда можно его просто добавлять и вычитать как угодно. Ну и, грубо говоря, там, в общем,
[48:47.680 --> 48:57.920]  в общем, так подстраивается, чтобы как бы то решение, которое есть, как-то все-таки сдвинуть,
[48:57.920 --> 49:05.960]  чтобы все компоненты были не слишком большими. В общем, интуиция примерно такая, конкретика там,
[49:05.960 --> 49:13.040]  в общем, такая линейная алгебра. Я думаю, что я сейчас пропущу, потому что я еще хочу про другие
[49:13.040 --> 49:28.080]  вещи успеть поговорить. Вот. Ну, значит, вот это CLP вполне на практике часто используется. Есть даже
[49:28.080 --> 49:35.480]  специальные там программные комплексы, решатели такие, солдеры, которые решают особо эффективно,
[49:35.480 --> 49:39.640]  но они все равно не могут точно решить, потому что это полная задача, но они, в общем, все
[49:39.640 --> 49:46.240]  оптимизации, которые могут, делают. И есть такой специальный рынок этих решателей. У IBM есть
[49:46.240 --> 49:51.880]  программа CPLEX, а есть еще там группа товарищей, которые оттуда вышли и свою сделали, называется
[49:51.880 --> 50:04.200]  Гуроби по их соответствующим фамилиям. Есть, в общем, еще несколько. В общем, тут мы прям с такой,
[50:04.200 --> 50:11.040]  с индустрией сталкиваемся, потому что действительно такие задачи решать надо,
[50:11.040 --> 50:17.480]  и, соответственно, фирмы готовы за это платить, а некоторые IT-компании, которые обслуживают
[50:17.480 --> 50:22.240]  меня, маленьких пользователей, а большие фирмы, они как раз в том числе решением таких вещей
[50:22.240 --> 50:36.000]  занимаются. Вот, хорошо, значит, и еще одна вещь, которую хочу сказать, это, ну, можно рассмотреть,
[50:36.000 --> 50:44.920]  можно сказать, что это язык теорем. Значит, можно сказать, что theorem set – это множество
[50:44.920 --> 50:54.960]  записей в какой-то формальной системе, доказуемых теорем. И, соответственно, если мы просто
[50:54.960 --> 50:59.320]  спрашиваем, доказуемы теоремы или нет, то это вообще неразрешимая задача, как нас там Геодали учат,
[50:59.320 --> 51:10.200]  Юринг и все остальное. Вот, но, значит, если мы ограничим длину записи, скажем, что тут пара из
[51:10.200 --> 51:33.200]  фи и к единиц, значит так, что у фи есть доказательства длины не больше к. Вот, вот эта задача уже лежит в НП.
[51:33.200 --> 51:45.720]  Ну и является НП полной более-менее для любой разумной формальной системы, в которой вы записываетесь
[51:45.720 --> 52:00.080]  эти доказательства. Но если, например, речь идет о формальной арифметике, то нужно просто, ну, не знаю,
[52:00.080 --> 52:04.760]  если вот это вот, например, CLP записывать, то это просто, да, это же и есть арифметика с натуральными
[52:04.760 --> 52:12.960]  числами, ну или там с целыми, да, это все-таки целое число, но все равно, значит, целочисленную
[52:12.960 --> 52:19.680]  арифметику можно выразить через натуральные числа и просто все вот это вот записать как бы,
[52:19.680 --> 52:26.720]  как формулировка теоремы. Вот, ну а тут как бы, ну, теоремы, что существует х, да, такое, что вот это
[52:26.720 --> 52:34.080]  верно. Ну а такие теоремы, в принципе, можно доказывать через предъявление этого х и, соответственно,
[52:34.080 --> 52:41.040]  проверку. Но если это там что-нибудь другое, мы хотим записывать какие-нибудь логические формулы,
[52:41.040 --> 52:46.440]  ну тоже, у нас формальная система должна уметь каким-то образом кодировать були в алгебру и,
[52:46.440 --> 52:54.400]  соответственно, доказательства будут, что вот есть такое значение, если мы его подставим,
[52:54.400 --> 53:05.320]  то там будет единица, да, будет формула выполнима. Вот, хорошо, вот это вот связь, наоборот,
[53:05.320 --> 53:19.760]  с основанием математики. Ну что, есть какие-нибудь еще вопросы? Так, я хочу еще про одну вещь рассказать.
[53:19.760 --> 53:30.720]  Значит, еще одна вещь, это сложность задач поиска.
[53:49.760 --> 54:12.440]  Значит, потому что на самом деле, как правило, нас интересует не вопрос есть или нет что-то,
[54:12.440 --> 54:18.440]  ну, бывает так, что на самом деле интересует вопрос есть или нет, да, например, когда нас
[54:18.440 --> 54:23.240]  интересует простое число или нет, то если оно составное, то обычно нас не интересуют,
[54:23.240 --> 54:29.880]  какие множители, да, потому что мы хотим простое найти. Вот, но чаще, когда вот мы решаем задачи
[54:29.880 --> 54:39.520]  там CLP, там задачками Вежиора, что-то ищем, то желательно не просто понять есть этот объект или
[54:39.520 --> 54:49.520]  нет, а прям таки его найти, если он есть. Вот, и вот это вот называется задача поиска. Задача поиска.
[54:49.520 --> 55:10.480]  Тут V от XY, V от XY, какой-то предикат, и нужно, соответственно, по X, значит, по X нужно сделать
[55:10.480 --> 55:26.760]  одно из двух. Либо, значит, либо найти Y такой, что V от XY равно единице, либо написать какой-нибудь
[55:26.760 --> 55:44.360]  ответ нет, да, если не существует такого Y, что V от XY равно единице. Вот, вот это задача поиска. Вот, и
[55:44.360 --> 55:57.080]  оказывается, что для NP-полных задач задача поиска и задача распознавания эквивалентная. Теорема
[55:57.080 --> 56:16.080]  для NP-полных задач. Так, давайте я еще напишу покрасивее. Значит, для NP-полных языков, для NP-полных
[56:16.080 --> 56:44.080]  языков задача поиска эквивалентна задаче распознавания, что, значит, эквивалентна, но эквивалентна
[56:44.080 --> 56:58.080]  можно сказать, что эквивалентна по куку, но в том смысле, что если мы научились решать одну задачу, то мы сможем решать и другую,
[56:58.080 --> 57:08.080]  обращаясь к первой полинейное число раз. Это в одну сторону это очевидно, потому что задача поиска более сложная.
[57:08.080 --> 57:17.080]  Дальше задача распознавания, что нам нужно просто в первом случае сказать 1, в втором случае 0. А тут нам просто больше информации, да, ну и мы можем
[57:17.080 --> 57:28.080]  забыть, какой именно Y найден, если он найден и говорить да. Вот, если не найден и говорить нет. Вот, поэтому задача поиска получается сложнее.
[57:28.080 --> 57:49.080]  В общем, случая. Вот. Ну, доказательства такое. Так, дать я, опять же, немножко неформально основную идею расскажу. В общем, я расскажу,
[57:49.080 --> 58:09.080]  на примере задачи Акликия. На примере задачи Акликия. Вот. А в общем случае, то в принципе нужно доказывать сводимость,
[58:09.080 --> 58:19.080]  то, что называется Полевину, которая еще и позвалила задачу поиска, сводить задачу поиска. В общем, про это я на лекции не буду подробно говорить.
[58:19.080 --> 58:33.080]  Так, значит, например, задача Акликия. Ну, смотрите, пусть у нас есть вершина, да, у нас задача, значит, по графу G и K нужно найти клику,
[58:33.080 --> 59:00.080]  найти клику, то есть полный под граф на K вершинах. Так. Ну, понятно, а мы умеем понимать есть клика или нет.
[59:00.080 --> 59:12.080]  Ну, ясно, что первый шаг будет просто как раз спросить, есть она или нет. Да, если нет, то сразу сказать, что ее нет. Если есть, то начать ее искать.
[59:12.080 --> 59:32.080]  Да, то есть первое, это есть ли клика, значит, на графе G, в графе G размера K. Еще дальше, если нет, то тогда и на нет и суда нет, как говорится.
[59:32.080 --> 59:46.080]  Тогда сразу ответ, что Y нет. Вот, если да, если да, то мы начнем ее искать и начнем искать следующим образом.
[59:46.080 --> 01:00:14.080]  Выберем вершину V. Значит, выберем вершину V и спросим, есть ли клика в G без вершины V и размера K.
[01:00:14.080 --> 01:00:29.080]  Да, то есть вот нам сказали, да, что вот клика есть, а вот если вот эту убрать, то она все еще есть или уже нет? Значит, если есть, то, соответственно, ищем рекурсивно.
[01:00:29.080 --> 01:00:49.080]  Значит, ищем рекурсивно, у нас теперь получилось, что граф содержит на одну вершину меньше. Ну, понятно, что уже можем не спрашивать изначально, да, рекурсивно сразу вот сюда. Следующую вершину набираем и так далее.
[01:00:49.080 --> 01:01:06.080]  Вот, если нет, тогда какой вывод? Да, вот у нас граф G, вот вершина V. Вывод такой, что эта вершина точно есть в любой клике.
[01:01:06.080 --> 01:01:16.080]  Да, то есть в принципе, когда мы тут сказали, да, то, может быть, там есть одна клика, которая содержит V, а другая, которая не содержит V, и мы найдем ту, которая не содержит.
[01:01:16.080 --> 01:01:29.080]  Вот, но раз уж без V нету клики, то, значит, она точно есть, а все остальные K-1 должны быть вот среди ее окрестности.
[01:01:29.080 --> 01:01:42.080]  А все остальные K-1 должны быть не просто где-то, а должны быть именно с ней соединены. Вот, тогда мы тоже ищем рекурсивно, но уже другой подставляем.
[01:01:42.080 --> 01:02:01.080]  Ищем рекурсивно, а тут получается как бы в окрестности. Давайте я так напишу, neighbor от V, и уже K-1.
[01:02:01.080 --> 01:02:20.080]  Ищем-ыщем, находим и добавляем ту самую K. Не ту самую K, а ту самую V. У нас клик размера K-1, мы добавляем вершину V, получаем клик размера K.
[01:02:20.080 --> 01:02:38.080]  Ну вот, аналогично, можно для любой по полной задачи, но чтобы доказать, нужно доказать, что там все сводится к клике не абы как, а еще и как бы сохраняя сертификаты.
[01:02:38.080 --> 01:02:44.080]  Так что, по этой клике можно было найти то, что нам нужно было найти в той задачи, которую мы сводили.
[01:02:44.080 --> 01:02:51.080]  На самом деле, если аккуратно проанализировать ремку Клевина, то там как раз сводимость именно такая.
[01:02:51.080 --> 01:02:59.080]  Исходя из выполняющего набора, можно найти прям Y, который в исходной задаче был.
[01:02:59.080 --> 01:03:04.080]  Можно аналогичную процедуру сделать для формулы.
[01:03:04.080 --> 01:03:12.080]  Например, мы ищем выполняющий набор, умеем определять выполнимость формулы.
[01:03:12.080 --> 01:03:18.080]  Можешь делать так. Если мы первую переноску поставим равную нулю, то тогда форму будет выполнима?
[01:03:18.080 --> 01:03:27.080]  Если будет, то мы ищем дальше выполняющий набор. Если не будет, тогда, значит, поставим единицу и до нее ищем.
[01:03:27.080 --> 01:03:34.080]  В принципе, такое же можно для выполнимости и много для чего.
[01:03:34.080 --> 01:03:39.080]  Вот, какие-нибудь вопросы?
[01:03:39.080 --> 01:04:06.080]  Ну, типа того, да.
[01:04:06.080 --> 01:04:18.080]  Нет, смотрите, в любом случае тут, конечно, ситуация несимметричная.
[01:04:18.080 --> 01:04:24.080]  То есть, если в одну сторону мы один раз запускаем задачу поиска и непосредственно ее результат используем.
[01:04:24.080 --> 01:04:27.080]  То есть, это что-то похожее на сводимость по карпу.
[01:04:27.080 --> 01:04:32.080]  А в другую сторону нам действительно нужно много раз запускать.
[01:04:32.080 --> 01:04:46.080]  То есть, только это утверждается, что все-таки запуская много раз, мы сможем решить задачу поиска, запустив N раз задача распознавания.
[01:04:46.080 --> 01:04:53.080]  Вот. Да, тут, конечно, еще нужно что-то сказать про то, что это все быстро закончится, но тут это легко.
[01:04:53.080 --> 01:05:01.080]  У нас каждый раз либо граф уменьшается, либо и граф уменьшается, и число уменьшается.
[01:05:01.080 --> 01:05:07.080]  То есть, суммарное число шагов будет точно не больше, чем число вершин в графе плюс K.
[01:05:07.080 --> 01:05:10.080]  Ну, даже просто не больше, чем число вершин в графе.
[01:05:10.080 --> 01:05:13.080]  То есть, это будет полинвайльное число запусков.
[01:05:13.080 --> 01:05:18.080]  Вот, значит, в принципе есть еще ненаполонные задачи, для которых тоже такая эквивалентность есть.
[01:05:18.080 --> 01:05:21.080]  Например, задача об изоморфизме графов.
[01:05:21.080 --> 01:05:30.080]  Оказывается, что если вы умеете проверять, есть ли изоморфизм графов, то вы умеете и находить этот изоморфизм.
[01:05:30.080 --> 01:05:35.080]  Вот. Но сейчас я уж не успею рассказать, может, на семинарах будет.
[01:05:35.080 --> 01:05:42.080]  Вот. Но есть задачи, для которых заведомо задача рассматривания проще, потому что у нее ответ тривиальный.
[01:05:42.080 --> 01:05:48.080]  Например, есть задача поиска найти у числа простой делитель.
[01:05:48.080 --> 01:05:51.080]  Соответствующая задача с бинарным ответом тривиальная.
[01:05:51.080 --> 01:05:55.080]  Но вопрос, есть ли у числа простой делитель? Думать не нужно.
[01:05:55.080 --> 01:05:59.080]  Нужно сразу отвечать, что да, есть. Мы все это прекрасно знаем.
[01:05:59.080 --> 01:06:04.080]  Но это нас не спасает, а может даже наоборот. Усложняет задачу.
[01:06:07.080 --> 01:06:15.080]  В общем, все знают, что простой делитель есть, но тем не менее искать его не получается.
[01:06:15.080 --> 01:06:19.080]  Вот. Ну и вот есть такой целый класс задач, называется TFNP.
[01:06:20.080 --> 01:06:23.080]  Я даже напишу. TFNP.
[01:06:24.080 --> 01:06:29.080]  Расшифровывается Total, Functional, NP.
[01:06:29.080 --> 01:06:36.080]  Functional означает, что задача поиска, там как бы ответ, это не да или нет какой-то объект.
[01:06:36.080 --> 01:06:39.080]  А Total означает, что всегда ответ есть.
[01:06:39.080 --> 01:06:46.080]  То есть вот этот нижний вариант просто исчезает, остается только верхний.
[01:06:47.080 --> 01:06:58.080]  Но тем не менее, для ряда задач, TFNP, задача поиска сложная, предположительно.
[01:06:58.080 --> 01:07:01.080]  И для кучи задач никто не умеет решать.
[01:07:01.080 --> 01:07:04.080]  И вообще там очень интересная теория.
[01:07:04.080 --> 01:07:11.080]  Опять же, может быть мы ее изучим на доп. главах, теми кто будет ходить.
[01:07:11.080 --> 01:07:14.080]  Так, ну все, на этом все на сегодня.
[01:07:14.080 --> 01:07:17.080]  И на самом деле все с NP полнотой.
[01:07:17.080 --> 01:07:22.080]  В следующий раз я уже планирую что-нибудь другое.
[01:07:22.080 --> 01:07:26.080]  Либо про полинальную память, либо про полинальную иерархию.
[01:07:26.080 --> 01:07:28.080]  Подумаю, в каком порядке.
[01:07:30.080 --> 01:07:32.080]  Ну все, спасибо.
