[00:00.000 --> 00:13.640]  Значит, мы сегодня начинаем вторую большую тему курса, это теория числимости.
[00:30.000 --> 00:39.000]  Собственно, вот эта часть курса оправдывает слова теории алгоритмов в названии курса.
[00:39.000 --> 00:50.000]  До этого теории алгоритмов почти не было. Можно было, конечно, на самом деле резолюцию немножко связать с алгоритмами.
[00:50.000 --> 00:54.000]  Это такой алгоритмический метод. Но сейчас общая теория.
[00:54.000 --> 01:03.000]  Общая теория, что вообще такой алгоритм, что такое алгоритмическая задача, какие задачи решали мы и так далее.
[01:03.000 --> 01:09.000]  Начнем с того, что такое алгоритмическая задача.
[01:09.000 --> 01:31.000]  Алгоритмическая задача, это любая постановка, где есть вход и выход, и вход и выход записываются в конечном счете в речные стола.
[01:31.000 --> 01:52.000]  То есть нужно преобразовать вход в выход, и совместные вход и выход записываются двоичными словами.
[01:52.000 --> 01:59.000]  Соответственно, можно этими двоичными словами кодировать разные-другие объекты.
[01:59.000 --> 02:05.000]  То есть слова могут кодировать по-другому.
[02:05.000 --> 02:29.000]  То есть слова могут кодировать натуральные числа, графы, матрицы натуральных чисел, рациональные числа,
[02:29.000 --> 02:38.000]  может быть через мантицию порядка, может быть через числитель-взаменатель, может быть как-то еще.
[02:38.000 --> 02:48.000]  Можно какие-то более сложные структуры, какая-нибудь там группа, или что-нибудь там еще более сложные наборы таких структур.
[02:48.000 --> 02:55.000]  Что такое граф? Это тоже простейшая структура, что есть список вершин и список ревербер.
[02:55.000 --> 03:00.000]  А может быть, например, взвешенный граф, когда у каждого ревебра еще есть вес.
[03:00.000 --> 03:03.000]  Может быть, еще что-то такое хитрое.
[03:03.000 --> 03:08.000]  В конечном счете это все перекодируется в бита и получается двоичное слово.
[03:08.000 --> 03:14.000]  Вот это называется конструктивные объекты.
[03:14.000 --> 03:31.000]  Конструктивные объекты – это то, что можно закодировать лавами, кодируемые лавами.
[03:31.000 --> 03:51.000]  То есть натуральные числа, рациональные числа, матрицы, графы, прочие конечные структуры.
[04:01.000 --> 04:07.000]  Про это кодирование мы в явном виде говорить не будем.
[04:07.000 --> 04:11.000]  То есть мы будем считать, что какое-то кодирование есть.
[04:11.000 --> 04:16.000]  Но если оно задача очень нужна будет, то мы внимательно на него посмотрим.
[04:16.000 --> 04:19.000]  А так, чтобы просто как-то все записано.
[04:19.000 --> 04:24.000]  То есть нам здесь не нужно будет какие-то конкретные программы написать.
[04:24.000 --> 04:27.000]  Нужно будет просто обсуждать, что они есть.
[04:28.000 --> 04:29.000]  Хорошо.
[04:29.000 --> 04:36.000]  Я вот так написал, что нужно проявлять вход-выход не очень четко.
[04:36.000 --> 04:41.000]  Это потому что бывают разные конкретные постановки.
[04:51.000 --> 04:53.000]  Конкретные постановки.
[04:58.000 --> 05:03.000]  Значит, ну могут быть вычисления функция.
[05:05.000 --> 05:10.000]  Это означает, что и вход, и выход – это конечное двоичное слово.
[05:10.000 --> 05:17.000]  Ну и соответственно есть какая-то функция f, которая двоичные слова, отображает двоичные слова.
[05:17.000 --> 05:19.000]  Второй вариант.
[05:24.000 --> 05:28.000]  Второй вариант – это распознавание множества.
[05:35.000 --> 05:42.000]  Значит, распознавание множества означает, что там два возможных ответа.
[05:42.000 --> 05:47.000]  То есть распознавание множества – это то же самое, что вычисление предикад.
[05:54.000 --> 06:07.000]  То есть можно писать, что есть какой-то предикад, который получает ново и соответственно возвращает 0,1.
[06:07.000 --> 06:09.000]  И вот его нужно вычислить.
[06:09.000 --> 06:16.000]  Ну и распознавание множества означает, что нужно установить – лежит x в a или не лежит.
[06:18.000 --> 06:37.000]  Значит, или по входу x установить верно ли, что x лежит в a.
[06:39.000 --> 06:48.000]  Третье еще бывает. Задача поиска.
[06:48.000 --> 06:58.000]  Задача поиска означает, что есть некоторые отношения.
[06:58.000 --> 07:14.000]  Значит, дано отношение бинарное r, которое под множество 0,1 со звездочкой в квадрате.
[07:14.000 --> 07:33.000]  И нужно по входу x установить верно ли решение уравнения или установить, что решения нет.
[07:33.000 --> 07:37.000]  Обычно говорят, что решить уравнение значит найти все корни.
[07:37.000 --> 07:39.000]  Вот здесь будет ссылка, что найти один корень.
[07:39.000 --> 07:46.000]  Потому что если все корни, то это, на самом деле, первая постановка, что есть конкретное значение список корней, которые нужно установить.
[07:46.000 --> 08:05.000]  Вот, значит, а здесь вход x, значит, а выход, значит, либо y такой, что r от x и y равно 1.
[08:05.000 --> 08:10.000]  Так, сейчас, если он пропадет, то не так можно, да?
[08:10.000 --> 08:32.000]  Если не существует, значит, если для любого y, значит, пара x и y не лежит в r.
[08:32.000 --> 08:51.000]  Ну, тут соответственно отличие в том, что нет какого-то приписанного ответа.
[08:51.000 --> 08:55.000]  Конечно, на самом деле, вот эта специальная сила, еще тоже как нам закодировать.
[08:55.000 --> 09:13.000]  Ну, можно, например, сказать, что если ответ, что такого y нету, то мы выводим 0, а если такое y есть, то мы выводим 1, а потом, соответственно, вот какой-то подходящий y.
[09:13.000 --> 09:27.000]  Вот, и все еще это будет не то же самое, что первоначальное вычленение функции, потому что нет конкретного значения, а есть много подходящих.
[09:27.000 --> 09:53.000]  Так, хорошо, значит, теперь еще на самом деле бывают постановки, в которых мы вредим как какой-то алгоритм, но там какие-то непрерывные аспекты возникают, значит, это мы будем игнорировать.
[09:53.000 --> 09:58.000]  Давайте я один раз напишу, что бывает, а потом мы их проходить не будем.
[09:58.000 --> 10:11.000]  Значит, не рассматриваем непрерывные постановки.
[10:11.000 --> 10:28.000]  Может быть, как бы непрерывные точки и дискретное время, значит, тут пример метод Мьютона.
[10:28.000 --> 10:34.000]  Значит, метод Мьютона численного поиска корень уравнения.
[10:34.000 --> 10:42.000]  Знаете, что это за метод? Я думаю, что вы в каком-то виде его проходили, но даже если нет, то это очень легко понять.
[10:42.000 --> 10:53.000]  Значит, есть вот какой-то график, и мы хотим найти корень, где график пересекает весь обстыз.
[10:53.000 --> 11:03.000]  Момент такой, набираем какую-нибудь точку и из нее проводим касательно.
[11:03.000 --> 11:12.000]  Дальше в этой точке поднимаемся назад на эту кривую и из нее проводим касательно.
[11:12.000 --> 11:19.000]  Потом снова поднимаемся и еще раз проводим касательно и так далее.
[11:19.000 --> 11:27.000]  Соответственно, здесь происходит работа с какими-то непрерывными штуками.
[11:27.000 --> 11:35.000]  Здесь проводим касательную, ищем пересечения.
[11:35.000 --> 11:41.000]  Главное, что вещь-то производная в произвольной точке, да, произвольная функция.
[11:41.000 --> 11:52.000]  Конечно, если это функция какая-то хорошей формулы задана, то можно как-то симулина посчитать.
[11:52.000 --> 11:57.000]  Хотя рисуют непрерывные картинки, на самом деле это будет работать с какими-то конечными выражениями.
[11:57.000 --> 12:04.000]  Но метод всегда работает, но не всегда, если условия соблюдены, какая-нибудь гладкость нужна и так далее.
[12:04.000 --> 12:08.000]  Такой процесс всегда сойдется корню.
[12:08.000 --> 12:18.000]  То есть, смотрите, тут, во-первых, у нас непрерывные точки, дискретное время, но еще и ответ получается через бесконечное число шагов в пределе.
[12:18.000 --> 12:27.000]  В общем, такое мы не рассматриваем, потому что в реальности, чтобы это использовать, нужно это как-то приблизить.
[12:27.000 --> 12:33.000]  Мы приближенно проводим касательную, какое-то число утратцы делаем, потом останавливаемся и так далее.
[12:33.000 --> 12:36.000]  А если эти оговорки сделаются, это будет алгоритм, как мы рассматриваем.
[12:36.000 --> 12:41.000]  А в таком идеальном виде это будет за рамками теории.
[12:41.000 --> 12:53.000]  Еще есть такая тема, протоколы справедливого дележа.
[12:53.000 --> 13:03.000]  Протоколы справедливого дележа.
[13:03.000 --> 13:06.000]  Там даже какие-то еще более сложные штуки.
[13:06.000 --> 13:23.000]  Есть протоколы, которые работают в непрерывном времени.
[13:23.000 --> 13:28.000]  Например, есть вот такая история.
[13:28.000 --> 13:33.000]  Этот отрезок называется пирог.
[13:33.000 --> 13:41.000]  Есть два человека, которые его делают, и у каждого из них разные ценности.
[13:41.000 --> 13:46.000]  То есть нельзя отмерить общую рулетку и поделить ее пополам.
[13:46.000 --> 13:53.000]  Одному нравится какие-то одни кусочки, другому какие-то другие.
[13:53.000 --> 13:56.000]  Но есть вот такой метод ежа.
[13:56.000 --> 14:00.000]  Иногда это еще рассказывают про пиратов и сокровища.
[14:00.000 --> 14:06.000]  Что было пиратов такое телесокровище, оно очень разнообразное, можно поделить.
[14:06.000 --> 14:08.000]  Но один метод вот такой.
[14:08.000 --> 14:11.000]  Это я нож нарисовал для пирога.
[14:11.000 --> 14:19.000]  Этот нож движется лево-направо в непрерывном времени.
[14:19.000 --> 14:25.000]  И, соответственно, каждый игрок может сказать стоп в любой момент, тоже непрерывный.
[14:25.000 --> 14:36.000]  И получить кусок лево от ножа.
[14:41.000 --> 14:48.000]  Но имеется в виду, что у каждой меры есть медиана.
[14:48.000 --> 14:53.000]  Такая, что слева от медиана и справа от медиана одинаковая ценность.
[14:53.000 --> 15:00.000]  Но и до чей медиан этот нож раньше дойдет, тот и крикнет и получит кусок слева от ножа.
[15:00.000 --> 15:08.000]  Это тоже выглядит как алгоритм, но в строгом смысле алгоритм не является, потому что здесь вот такое непрерывное время.
[15:08.000 --> 15:13.000]  Это слайд единственный, где я такие штуки рассматриваю.
[15:13.000 --> 15:16.000]  Дальше у нас все будет дискретное.
[15:16.000 --> 15:26.000]  И время, и объекты, и получение ответа все будет конечное.
[15:26.000 --> 15:40.000]  Хорошо. Следующее, про что мы поговорим, это вычислительные модели.
[15:40.000 --> 15:45.000]  Это тоже в нашем курсе в большей степени семинарская тема.
[15:45.000 --> 15:55.000]  На семинарах какие-то группы уже были, в каких-то не было, но будет семинар про машины тюринга в подробностях.
[15:55.000 --> 15:57.000]  Здесь я скажу кратце.
[15:57.000 --> 16:06.000]  В принципе, существенную часть теории можно изучать вообще без какой-то конкретной модели,
[16:06.000 --> 16:13.000]  ну а просто на базе такого обыденного опыта, что мы пишем программы, как-то программировать умеем,
[16:13.000 --> 16:16.000]  и примерно понимаем, что компьютер делает.
[16:16.000 --> 16:21.000]  То есть можно представить себе, что алгоритм – это программа на вашем языке.
[16:21.000 --> 16:28.000]  И для существенной части теории не нужны какие-то мелкие детали.
[16:28.000 --> 16:32.000]  Что именно это за программа, как она работает и так далее.
[16:32.000 --> 16:38.000]  Но кое-где все-таки нужно.
[16:38.000 --> 16:53.000]  Когда доказывается, что программы нужны не существуют, то все-таки желательно понимать, что именно не существует.
[16:53.000 --> 16:59.000]  То есть про что именно мы доказываем, что такой штуки нет.
[16:59.000 --> 17:11.000]  И особенно это нам пригодится, когда мы будем вычисления на программах кодировать через арифметические формулы.
[17:11.000 --> 17:18.000]  Вот здесь уж без точной модели трудно обойтись, чтобы прям полностью доказать.
[17:18.000 --> 17:24.000]  То есть мы будем доказывать, что для любой программы есть арифметическая формула,
[17:24.000 --> 17:31.000]  которая, скажем, верна тогда и только тогда, когда программа на этом входе возвращает ноль.
[17:31.000 --> 17:36.000]  Или тогда и только тогда, когда программа на этом входе останавливается.
[17:36.000 --> 17:39.000]  А вход будет параметром арифметической формулы.
[17:39.000 --> 17:45.000]  И, конечно, наши по-разному единицы можно перекодировать числа натуральные,
[17:45.000 --> 17:50.000]  и тем самым, соответственно, иметь дело с арифметикой.
[17:50.000 --> 17:57.000]  Хорошо. Так, значит, базовая модель – это машина Тьюринга.
[18:02.000 --> 18:08.000]  На самом деле, в 30-х, 50-х годах было очень много разных моделей.
[18:08.000 --> 18:15.000]  Но некоторые из них буквально уже остались только в истории.
[18:15.000 --> 18:21.000]  Другие там где-то изучаются, но вот машина Тьюринга выдержала проверку временем
[18:21.000 --> 18:25.000]  и входит во все учебники.
[18:25.000 --> 18:30.000]  С одной стороны, достаточно проста, чтобы ее можно анализировать.
[18:30.000 --> 18:37.000]  С другой стороны, достаточно сложна, чтобы довольно легко все программы писать.
[18:37.000 --> 18:41.000]  Хорошо. А что такое машина Тьюринга?
[18:41.000 --> 18:47.000]  Если я формальное определение как математический объект оставлю для семинаров,
[18:47.000 --> 18:52.000]  значит, а здесь нарисую неформально.
[18:52.000 --> 18:58.000]  Значит, у машины Тьюринга есть лента.
[19:04.000 --> 19:07.000]  Давайте я там так напишу – лента.
[19:11.000 --> 19:13.000]  И есть указатель.
[19:16.000 --> 19:26.000]  Там есть указатель и есть процессор, можно сказать, управляющий блок.
[19:31.000 --> 19:39.000]  Управляющий блок в состоянии электронку.
[19:41.000 --> 19:45.000]  А о чем здесь есть программа?
[19:45.000 --> 19:48.000]  Значит, программа стоит из команд.
[19:52.000 --> 19:58.000]  Программа машины Тьюринга стоит из команд
[19:59.000 --> 20:03.000]  Вида.
[20:03.000 --> 20:06.000]  Значит, какое-то Q.
[20:06.000 --> 20:14.000]  И T, а J T переходит в Q, R, T, A, S, T и еще направление.
[20:14.000 --> 20:19.000]  Соответственно, что у нас тут получается?
[20:19.000 --> 20:25.000]  Получается, что Q, R, T – это состояние.
[20:26.000 --> 20:30.000]  Состояние из некоторого множества Q.
[20:30.000 --> 20:41.000]  Значит, A IT, A J T и A S T – это символы из некоторого алфавита.
[20:41.000 --> 20:44.000]  Конечного Q – конечный множество состояний.
[20:44.000 --> 20:49.000]  Здесь гамма – это конечный алфавит.
[20:49.000 --> 20:53.000]  А вот это D – это сдвиг.
[21:00.000 --> 21:03.000]  Значит, налево, направо или на месте.
[21:10.000 --> 21:13.000]  Соответственно, команда выполняется.
[21:13.000 --> 21:18.000]  Но D находится в каком-то состоянии и указывает на какой-то символ.
[21:19.000 --> 21:24.000]  И он в списке команд смотрит нужную команду.
[21:24.000 --> 21:28.000]  Где Q IT – это нужные состояния, A J T – это нужный символ.
[21:28.000 --> 21:31.000]  После этого смотрит, что там дальше написано.
[21:31.000 --> 21:36.000]  И заменяет A J T на A S T.
[21:36.000 --> 21:40.000]  Переходит из Q IT в Q R T.
[21:40.000 --> 21:42.000]  И еще указатель сдвигает.
[21:42.000 --> 21:46.000]  Значит, налево, направо либо оставляет на месте.
[21:46.000 --> 21:58.000]  После этого есть новое состояние, новый символ и новая команда.
[21:58.000 --> 22:00.000]  И она тоже исполняется.
[22:00.000 --> 22:03.000]  И так пока не будет выполнено условие остановки.
[22:03.000 --> 22:06.000]  Для условия остановки есть два варианта.
[22:06.000 --> 22:17.000]  В зависимости от того, какую задачу мы решаем из предыдущих.
[22:17.000 --> 22:32.000]  Если у нас первая или третья задача, то есть много разных ответов.
[22:32.000 --> 22:37.000]  Тогда есть одно завершающее состояние.
[22:37.000 --> 22:44.000]  Значит, есть специальное завершающее состояние.
[22:44.000 --> 22:57.000]  Может быть, Q HALT.
[22:57.000 --> 23:00.000]  И тогда означает, что если машина пришла в завершающее состояние,
[23:00.000 --> 23:07.000]  то дальше из содержимого ленты по каким-то правилам довлекается ответ.
[23:07.000 --> 23:15.000]  Значит, Q HALT – ответ на ленте.
[23:15.000 --> 23:19.000]  Либо, может быть, два варианта.
[23:19.000 --> 23:27.000]  Q ACCEPT – ответ да.
[23:27.000 --> 23:35.000]  Q REJECT – ответ нет.
[23:35.000 --> 23:42.000]  Если ответов тоничное число, то можно для каждого завести специальное состояние.
[23:42.000 --> 23:46.000]  Кстати, что касается задачи поиска.
[23:46.000 --> 23:51.000]  В принципе, можно сделать специальное состояние, что ответа нет.
[23:51.000 --> 23:54.000]  А другое состояние, что ответ написан.
[23:54.000 --> 24:04.000]  И если он уже написан, тогда мы его читаем с ленты.
[24:04.000 --> 24:06.000]  Ну хорошо.
[24:06.000 --> 24:18.000]  Чтобы модель замкнуть, нужно еще сказать, с чего начинается.
[24:18.000 --> 24:21.000]  С чего начинается вычисление.
[24:21.000 --> 24:24.000]  Там должно быть еще начальное состояние.
[24:24.000 --> 24:43.000]  Ну и в самом начале машина находится в состоянии Q START.
[24:43.000 --> 24:52.000]  На ленте написан вход, ну и потом она начинает работу.
[24:52.000 --> 24:58.000]  Хорошо, есть еще другие модели.
[24:58.000 --> 25:06.000]  Тоже я про них сейчас вкратце скажу, а подробно в нашем курсе не будет.
[25:06.000 --> 25:08.000]  Значит, такие есть другие модели.
[25:08.000 --> 25:13.000]  Ну быть вариация с лентой и ячейками.
[25:13.000 --> 25:28.000]  Значит, вариация с лентой и ячейками.
[25:28.000 --> 25:42.000]  Значит, это, например, машина просто.
[25:42.000 --> 25:54.000]  Вот, могут быть машины с регистрами.
[25:54.000 --> 26:09.000]  Машина с регистрами, где в регистре может храниться натуральное число.
[26:09.000 --> 26:13.000]  Есть там несколько регистров, и в каждом прямо произволе натуральное число хранится.
[26:13.000 --> 26:18.000]  И дальше какие-то операции, что может быть аризметические, там что-нибудь уменьшать,
[26:18.000 --> 26:21.000]  увеличивать какие-нибудь условные переходы и так далее.
[26:21.000 --> 26:25.000]  Есть там куча разных вариаций.
[26:25.000 --> 26:50.000]  Значит, здесь в регистрах хранятся натуральные числа.
[26:50.000 --> 26:58.000]  Значит, есть рам-машина.
[26:58.000 --> 27:08.000]  Я слышал, что состояние машины описывается набором натуральных чисел.
[27:08.000 --> 27:12.000]  Регистр можно сказать просто индекс, что есть первое натуральное число такое,
[27:12.000 --> 27:15.000]  второе такое, третье такое и так далее.
[27:15.000 --> 27:19.000]  То есть есть команда типа того, что если там в первом регистре ноль,
[27:19.000 --> 27:25.000]  то мы там к третьим прибавляем четвертый, грубо говоря, и записываем в третий.
[27:25.000 --> 27:26.000]  Ну и так далее.
[27:26.000 --> 27:28.000]  И дальше там есть куча вариаций.
[27:28.000 --> 27:36.000]  Например, есть программа, и скажем каждый раз мы там ее проходим сначала
[27:36.000 --> 27:38.000]  и смотрим, какую команду можно исполнить.
[27:38.000 --> 27:45.000]  Какую первую можно исполнять, то исполняем, потом снова смотрим.
[27:45.000 --> 27:53.000]  А, ну изначально, например, что в первом регистре вход, а в остальных нули.
[27:53.000 --> 27:54.000]  Вот.
[27:54.000 --> 27:58.000]  Но в варианте есть очень много разных вариантов.
[27:58.000 --> 28:06.000]  Так, дальше есть машины с произвольным доступом.
[28:06.000 --> 28:09.000]  Рендом аксесс.
[28:09.000 --> 28:14.000]  Машины с предвольным доступом.
[28:14.000 --> 28:17.000]  Это рам.
[28:21.000 --> 28:24.000]  Рам-машины.
[28:26.000 --> 28:30.000]  Собственно, рам это есть рендом аксесс-машин.
[28:30.000 --> 28:32.000]  И это, на самом деле, похоже на реальные компьютеры.
[28:33.000 --> 28:39.000]  Вот смотрите, вот машина тюринга, она может только сдвинуться в соседнюю ячейку.
[28:39.000 --> 28:42.000]  Там налево или направо.
[28:42.000 --> 28:50.000]  А рам-машина может где-то отдельно напечатать номер
[28:50.000 --> 28:54.000]  и дальше перейти в ячейку с таким номером в задний шаг.
[28:55.000 --> 28:57.000]  Вот.
[28:57.000 --> 29:02.000]  Ну, это как, бывает, там указатель, перейти по адресу, в памяти и так далее.
[29:05.000 --> 29:06.000]  Вот.
[29:08.000 --> 29:10.000]  Что еще бывает?
[29:12.000 --> 29:18.000]  Ну, дальше бывают всякие исторические интересные штуки.
[29:18.000 --> 29:21.000]  Значит, есть общерекурсивная функция.
[29:22.000 --> 29:26.000]  Общерекурсивная функция, которую Чордж придумал.
[29:29.000 --> 29:32.000]  Значит, есть алгорифмы Маркова.
[29:35.000 --> 29:40.000]  Алгорифмы, именно через f, Маркова.
[29:43.000 --> 29:45.000]  Вот, ну и так далее.
[29:52.000 --> 29:58.000]  Очень интересно, когда слово алгоритм проникало в русский язык.
[30:00.000 --> 30:03.000]  Вообще, вы знаете, откуда слово алгоритм произошло?
[30:03.000 --> 30:06.000]  Это искаженное имя альхаризми.
[30:06.000 --> 30:13.000]  Альхаризми – это персидский или среднеазиатский ученый, который, собственно, изобрел позиционную систему
[30:13.000 --> 30:16.000]  счислений, всякое там сложение столбок и так далее.
[30:16.000 --> 30:17.000]  Вот.
[30:17.000 --> 30:22.000]  И соответственно, когда эти трубы были приведены на латинский,
[30:22.000 --> 30:30.000]  то там вот эта альхаризми, она преобразовалась в алхаризмы или там как-то так.
[30:31.000 --> 30:33.000]  И был прям в заграве.
[30:33.000 --> 30:34.000]  Вот.
[30:34.000 --> 30:38.000]  Ну и, соответственно, довольно долго алгоритмы не называли именно альхметические алгоритмы,
[30:38.000 --> 30:42.000]  там сложение столбок, там деление уголков и так далее.
[30:42.000 --> 30:44.000]  Вот это только для алгоритма.
[30:44.000 --> 30:49.000]  Но потом, уже в 18 веке, начиная с Леги Цейлера,
[30:49.000 --> 30:54.000]  уже там были сложные числовые процедуры, назывались алгоритмами.
[30:54.000 --> 30:57.000]  И уже почти как мы сейчас называем.
[30:57.000 --> 30:58.000]  Вот.
[30:58.000 --> 31:01.000]  А в русском языке это долго было в старом названии,
[31:01.000 --> 31:05.000]  и это писалось алгоритм через букву «фита».
[31:05.000 --> 31:09.000]  Знаете, была революция буквы «фита», которая как «т», пишется.
[31:09.000 --> 31:11.000]  Вот, начиналась как «ф».
[31:11.000 --> 31:13.000]  Вот через «т» букву это писалось.
[31:13.000 --> 31:14.000]  Вот.
[31:14.000 --> 31:19.000]  И дальше как-то Марков, который это придумал,
[31:19.000 --> 31:21.000]  он был такой историолежимный товарищ,
[31:21.000 --> 31:24.000]  и он говорил, что нужно вот по-старому написать,
[31:24.000 --> 31:25.000]  в общем, через «ф».
[31:25.000 --> 31:29.000]  Ну, через «фита» уже нельзя, а через «ф» надо.
[31:29.000 --> 31:33.000]  А дальше это как-то видимо повторично помекало там из немецкого,
[31:33.000 --> 31:35.000]  там или откуда-то с буквы «т».
[31:35.000 --> 31:40.000]  Ну и в итоге вот так сложилось, что в русском языке алгоритм пишут через «т»,
[31:40.000 --> 31:46.000]  а алгоритм – это означает конкретную совершенно вещь у Маркова.
[31:46.000 --> 31:47.000]  Вот.
[31:47.000 --> 31:51.000]  Это более-менее так, что там есть некоторая строка из сил,
[31:51.000 --> 31:53.000]  есть некоторые правила преобразования,
[31:53.000 --> 31:56.000]  ну и тоже мы там смотрим, какое правило можно применить,
[31:56.000 --> 31:59.000]  и смотрим там, куда это в итоге перейдет.
[31:59.000 --> 32:01.000]  Если вкратце, то вот.
[32:01.000 --> 32:02.000]  Вот.
[32:02.000 --> 32:03.000]  Хорошо.
[32:03.000 --> 32:06.000]  Ну, опять-таки, значит, мы вот все заглянули,
[32:06.000 --> 32:12.000]  значит, если интересно, то там поищите в интернете или в книжках.
[32:12.000 --> 32:15.000]  Не, может, почитать, что это такое.
[32:15.000 --> 32:16.000]  Так.
[32:16.000 --> 32:17.000]  Хорошо.
[32:17.000 --> 32:19.000]  Значит, мы ждем все дальше.
[32:19.000 --> 32:26.000]  Ну, наверное, уже, можно сказать, что-то учли мы функция.
[32:31.000 --> 32:33.000]  Значит, это очень важное определение.
[32:33.000 --> 32:49.000]  Значит, мы рассматриваем частично определенная функция,
[32:49.000 --> 33:00.000]  соответственно, из 0,1 со звездочкой в 0,1 со звездочкой.
[33:03.000 --> 33:04.000]  Вот.
[33:07.000 --> 33:09.000]  Соответственно, может быть, что функция определена,
[33:09.000 --> 33:11.000]  и у нее есть какое-то значение,
[33:11.000 --> 33:14.000]  а может быть, что функция не определена вообще.
[33:14.000 --> 33:15.000]  Вот.
[33:15.000 --> 33:19.000]  Так вот, что же значит, что алгоритм, да, или там машина тюринга
[33:19.000 --> 33:23.000]  вычисляет данную функцию?
[33:23.000 --> 33:26.000]  Значит, определение.
[33:26.000 --> 33:33.000]  Функция f, значит, из 0,1 со звездочкой в 0,1 со звездочкой,
[33:33.000 --> 33:43.000]  частично определенная, вычислима, если, значит, если верно следующее,
[33:43.000 --> 34:00.000]  если существует алгоритм, да, или там программа машины тюринга,
[34:00.000 --> 34:06.000]  я тебе через машину тюринга напишу, значит, существует машина тюринга
[34:06.000 --> 34:13.000]  М, это что?
[34:13.000 --> 34:21.000]  Для любого х, для любого х из 0,1 со звездочкой верно следующее,
[34:21.000 --> 34:29.000]  если f от х определена, если f от х определена,
[34:29.000 --> 34:41.000]  то тогда М от х останавливается и возвращает f от х.
[34:41.000 --> 34:45.000]  Ну, то есть, в случае машины тюринга означает, что она приходит в вывышающее состояние
[34:45.000 --> 34:51.000]  и на ленте у нее написано f от х, если она не начинала со входа х.
[34:51.000 --> 34:59.000]  Вот, а если f от х не определена, значит, f от х не определена,
[34:59.000 --> 35:12.000]  то это означает, что М от х вообще не останавливается.
[35:12.000 --> 35:18.000]  То есть, смотрите, у вас, значит, в каждой конфигурации у нас есть следующий шаг,
[35:18.000 --> 35:22.000]  то есть не машина его делает, а потом еще один делает, еще один, еще один,
[35:22.000 --> 35:27.000]  и ни в какой момент у своей остановки не выполняется.
[35:27.000 --> 35:34.000]  Вот, значит, это очень важно, что она именно вот так не останавливается.
[35:34.000 --> 35:37.000]  И в этом, кстати, отличие от задачи поиска, как я отформулировал.
[35:37.000 --> 35:40.000]  Значит, задача поиска, как я отформулировал, если ответа нету,
[35:40.000 --> 35:43.000]  то нужно остановиться и сказать, что ответа нету.
[35:43.000 --> 35:48.000]  Вот, а здесь очень важно, что именно так.
[35:48.000 --> 36:07.000]  Значит, не нужно требовать, не нужно требовать,
[36:07.000 --> 36:26.000]  то М от х сообщает, то f от х не определена.
[36:26.000 --> 36:34.000]  Так, хорошо, но да, кстати, возникает вопрос,
[36:34.000 --> 36:38.000]  мы бы взяли одну модель машины Тьюринга, значит, а почему,
[36:38.000 --> 36:42.000]  если мы возьмем другую модель, то не получится какое-то другое определение?
[36:42.000 --> 36:45.000]  Ну, вообще-то для некоторых моделей получится другое определение,
[36:45.000 --> 36:52.000]  например, если взять конечные автоматы, не знаю, там не рассказывали нигде что такое,
[36:52.000 --> 36:56.000]  конечные автоматы, но это будет в этом следующем семе... да,
[36:56.000 --> 37:00.000]  в осеннем следующем семестре на фаранах языках.
[37:00.000 --> 37:04.000]  Ну, не важно, что это такое, значит, некоторая довольно ограниченная модель.
[37:04.000 --> 37:09.000]  Вот, и в ограниченной модели как бы не все можно сделать.
[37:09.000 --> 37:13.000]  Вот, но от машины Тьюринга можно все сделать.
[37:13.000 --> 37:28.000]  Такой тезис, значит, тезис Чорча, ну и сейчас называют Чорча Тьюринга,
[37:28.000 --> 37:38.000]  тезис Чорча Тьюринга, что любая функция вычислима на реальном устройстве,
[37:38.000 --> 37:42.000]  так и вычислима на машине Тьюринга.
[37:42.000 --> 37:47.000]  Это не математическое утверждение, это некоторые утверждения про реальный мир.
[37:47.000 --> 38:03.000]  Значит, любая функция вычислима на физическом устройстве также вычислима на машине Тьюринга.
[38:03.000 --> 38:14.000]  Так же вычислима на машине Тьюринга.
[38:14.000 --> 38:23.000]  Вот, ну а пока, если мы в это поверили, ну в это можно только поверить, да,
[38:23.000 --> 38:30.000]  то есть пока, так сказать, ни у кого не получилось собрать компьютер,
[38:30.000 --> 38:40.000]  никто не вычислял что-то неучислимое, но теоретически можно помыслить там такой физический мир,
[38:40.000 --> 38:44.000]  в котором это было бы неверно.
[38:44.000 --> 38:51.000]  Так что в это можно либо поверить, ну либо считать, что это основанный факт в рамках физики,
[38:51.000 --> 38:56.000]  что все эксперименты показывают, что это верно.
[38:56.000 --> 39:02.000]  Вот, и это просто теоремой, если мы вместо производа на физическое устройство
[39:02.000 --> 39:08.000]  поставим какое-то конкретное или какую-то другую модель.
[39:08.000 --> 39:12.000]  То есть вот для всех тех моделей, которые были на предыдущем слайде,
[39:12.000 --> 39:17.000]  и еще для кучи других, ну в общем, мы любим для всех других,
[39:17.000 --> 39:22.000]  это может доказать как теорему, что все, что вычислимо в такой-то модели,
[39:22.000 --> 39:26.000]  будет вычислим на машине тюринга.
[39:26.000 --> 39:32.000]  Интересно, обратные модели, все предыдущие к ним относятся,
[39:32.000 --> 39:37.000]  что если что вычислим на машине тюринга, то они вычислим здесь.
[39:37.000 --> 39:42.000]  Это называется тюринг-полная модель или тюринг-полный язык.
[39:42.000 --> 39:49.000]  Это вообще, что на нем можно вычислить все, что на машине тюринга, то есть просто все.
[39:49.000 --> 39:53.000]  И, значит, моделя, собственно, гораздо больше, чем я перечислил.
[39:53.000 --> 39:58.000]  Есть, например, игра-жизнь, конвейер. Слышали такое?
[39:58.000 --> 40:03.000]  Хорошо, многие слышали. Значит, это такой простой клетчатный автомат,
[40:03.000 --> 40:06.000]  по простым правилам, эволюционирующая система,
[40:06.000 --> 40:10.000]  где лечитая плоскость у каждой клетки 8 соседей,
[40:10.000 --> 40:13.000]  каждая клетка живая или мертвая.
[40:13.000 --> 40:21.000]  И, значит, если мертвую клетку окружает ровно 3 живых, то там зарождается жизнь.
[40:21.000 --> 40:29.000]  А дальше, на крайней мере, если она живая, то если 2 или 3 живых соседа, то остается живой,
[40:29.000 --> 40:33.000]  а если меньше 2 или больше 3, то, соответственно, становится мертвой.
[40:33.000 --> 40:35.000]  И так все одновременно по всей плоскости.
[40:35.000 --> 40:38.000]  И там очень интересно эволюционирует система.
[40:38.000 --> 40:46.000]  Ну и, в частности, можно составить такой ряд конфигураций,
[40:46.000 --> 40:52.000]  что есть одна часть конфигурация и есть переменная часть.
[40:52.000 --> 40:57.000]  И, соответственно, переменная часть как-то зависит от чисел.
[40:57.000 --> 41:01.000]  Ну а дальше там какой-то исход зависит...
[41:01.000 --> 41:04.000]  В общем, вот эта часть фиксируется как программа,
[41:04.000 --> 41:06.000]  переменной как аргумент программы.
[41:06.000 --> 41:10.000]  Ну а исходы там бывают всякие, что, например, она полностью аннигилирует,
[41:10.000 --> 41:17.000]  то есть все сведется в пустую плоскость.
[41:17.000 --> 41:21.000]  Или, наоборот, будет расти бесконечно, и так далее.
[41:22.000 --> 41:24.000]  Ну вот так, хорошо.
[41:28.000 --> 41:34.000]  Значит, в общем, этот тезис обосновывает то, что это определение разумно,
[41:34.000 --> 41:36.000]  что его можно применять.
[41:37.000 --> 41:39.000]  Хорошо, теперь что можно сказать?
[41:42.000 --> 41:44.000]  Что можно сказать про вычислимые функции?
[41:47.000 --> 41:49.000]  Так, ну вот есть такая простая теорема.
[41:49.000 --> 41:52.000]  Простая, но важная теорема.
[41:52.000 --> 41:55.000]  Композиция вычислимых функций вычислима.
[41:55.000 --> 42:00.000]  Значит, композиция вычислимых функций вычислима.
[42:03.000 --> 42:09.000]  То есть если f вычислима и g вычислима, то там f от g от x...
[42:11.000 --> 42:18.000]  Значит, это f композиции g от x, то есть f от g от x тоже вычислима.
[42:18.000 --> 42:21.000]  Такая-то более-менее элементарная, если на пальцах,
[42:21.000 --> 42:24.000]  но и даже в модели тоже довольно элементарная,
[42:24.000 --> 42:27.000]  что мы сначала вычисляем функцию g,
[42:27.000 --> 42:31.000]  и когда она закончилась, то то, что получилось, мы поцелуем на вход функцию f.
[42:32.000 --> 42:35.000]  Используем это как под программу.
[42:36.000 --> 42:37.000]  Ну и это покрывает...
[42:37.000 --> 42:41.000]  Да, мы, конечно, считаем, что ежедневно вычислимые функции вычислимые,
[42:41.000 --> 42:43.000]  но это не так.
[42:43.000 --> 42:45.000]  Это как под программу.
[42:46.000 --> 42:47.000]  Ну и это покрывает...
[42:47.000 --> 42:49.000]  Да, мы, конечно, считаем, что если одна из функций не определена,
[42:49.000 --> 42:51.000]  то тогда и композиция тоже не определена.
[42:52.000 --> 42:54.000]  Да, получается, что если же не определена,
[42:54.000 --> 42:59.000]  то тогда даже внутренняя часть будет работать бесконечно долго,
[42:59.000 --> 43:01.000]  иначе композиция тоже будет не определена.
[43:02.000 --> 43:05.000]  Если же это из определённого f не определённо, то то же самое.
[43:07.000 --> 43:09.000]  Вот, хорошо.
[43:13.000 --> 43:15.000]  Ну, в частный случай это теория,
[43:15.000 --> 43:19.000]  что, например, если мы там, скажем, единицу прибавим ко всем значениям,
[43:19.000 --> 43:22.000]  или множим две вычислимые функции,
[43:22.000 --> 43:25.000]  перемножим и так далее, всё это будут вычислимые функции.
[43:27.000 --> 43:28.000]  Так, хорошо.
[43:29.000 --> 43:32.000]  Значит, дальше давайте поговорим про разрешимые множества.
[43:35.000 --> 43:37.000]  Разрешимые множества.
[43:37.000 --> 43:41.000]  Ну, то, что я вначале назвал задачей распознавания,
[43:41.000 --> 43:44.000]  можно ещё назвать задачей разрешения.
[43:45.000 --> 43:48.000]  Ну, разрешимые множества означают, что для этого множества
[43:48.000 --> 43:51.000]  задача разрешения вычислима.
[43:52.000 --> 43:54.000]  Ну, иными словами.
[43:54.000 --> 43:57.000]  А, вычислимо,
[43:57.000 --> 44:00.000]  если существует машина Тьюринга m,
[44:03.000 --> 44:05.000]  то есть что?
[44:06.000 --> 44:08.000]  Если x лежит в a,
[44:09.000 --> 44:11.000]  то тогда m от x...
[44:12.000 --> 44:14.000]  Ну, давайте я вам пишу равно единица.
[44:15.000 --> 44:17.000]  То есть, нам надо сказать,
[44:17.000 --> 44:19.000]  прекратить, что x лежит в a,
[44:20.000 --> 44:22.000]  то тогда m от x...
[44:23.000 --> 44:25.000]  Ну, давайте я вам пишу равно единица.
[44:25.000 --> 44:27.000]  То есть, можно сказать, приходит
[44:28.000 --> 44:30.000]  принимающий состояние.
[44:31.000 --> 44:33.000]  На уровне состояния получается, что приходит
[44:35.000 --> 44:37.000]  q accept.
[44:38.000 --> 44:40.000]  А если x не лежит в a,
[44:41.000 --> 44:43.000]  то тогда m от x равно mu.
[44:45.000 --> 44:47.000]  То есть, приходит
[44:50.000 --> 44:52.000]  q reject.
[44:53.000 --> 44:55.000]  В частности, для любого x,
[44:55.000 --> 44:57.000]  m от x определено, то есть, останавливается.
[44:58.000 --> 45:01.000]  Но здесь нет никакой границы
[45:01.000 --> 45:03.000]  на время работы.
[45:04.000 --> 45:06.000]  Вот есть еще теория сложности вычислений,
[45:07.000 --> 45:10.000]  которые, я надеюсь, мы еще будем изучать
[45:12.000 --> 45:15.000]  информатиками на втором, а состоянием в рейтинг-курсе.
[45:17.000 --> 45:19.000]  Вот, соответственно, теория сложности вычислений,
[45:19.000 --> 45:21.000]  важно, сколько шагов
[45:21.000 --> 45:23.000]  еще делает машина тюринга,
[45:23.000 --> 45:25.000]  прежде чем даст ответ.
[45:25.000 --> 45:27.000]  Здесь неважно.
[45:27.000 --> 45:29.000]  Значит, здесь любое конечное число подойдет.
[45:32.000 --> 45:34.000]  Можно сказать,
[45:34.000 --> 45:36.000]  что решимость множества
[45:36.000 --> 45:38.000]  то же самое, что вычислимость его
[45:38.000 --> 45:40.000]  характеристической функции.
[45:41.000 --> 45:43.000]  Получается, что a
[45:43.000 --> 45:45.000]  вычислимо
[45:46.000 --> 45:48.000]  тогда и только тогда, когда
[45:48.000 --> 45:50.000]  вот эта вот
[45:50.000 --> 45:52.000]  характеристическая функция, значит, ха
[45:52.000 --> 45:54.000]  от x,
[45:54.000 --> 45:56.000]  который есть единица,
[45:56.000 --> 45:58.000]  если х лежит ва,
[45:58.000 --> 46:00.000]  и ноль, если х не лежит ва,
[46:00.000 --> 46:02.000]  вычислимо.
[46:07.000 --> 46:09.000]  Ой, тут разрешимо надо.
[46:20.000 --> 46:22.000]  А разрешимо
[46:26.000 --> 46:28.000]  тогда и только тогда,
[46:28.000 --> 46:30.000]  когда характеристическая функция
[46:30.000 --> 46:32.000]  вычислима.
[46:32.000 --> 46:34.000]  Вот очевидно, это практически то же самое
[46:34.000 --> 46:36.000]  определение, просто по-другому сказанное.
[46:38.000 --> 46:40.000]  Так, хорошо.
[46:42.000 --> 46:44.000]  А теперь, что еще важно?
[46:44.000 --> 46:46.000]  Важно, что
[46:46.000 --> 46:48.000]  разрешимое множество
[46:48.000 --> 46:50.000]  множество можно
[46:50.000 --> 46:52.000]  перечислить
[46:52.000 --> 46:54.000]  по возрастанию.
[46:54.000 --> 46:56.000]  Мы рассматриваем
[46:56.000 --> 46:58.000]  алгоритмы
[46:58.000 --> 47:00.000]  еще одного специального вида,
[47:00.000 --> 47:02.000]  такие перечисляющие алгоритмы.
[47:06.000 --> 47:08.000]  Значит, перечисляющие
[47:08.000 --> 47:10.000]  алгоритмы
[47:12.000 --> 47:14.000]  перечисляющие алгоритмы устроены так,
[47:14.000 --> 47:16.000]  что у них есть вход
[47:16.000 --> 47:18.000]  или даже нет входа.
[47:18.000 --> 47:20.000]  Есть как-то поток вывода.
[47:20.000 --> 47:22.000]  Поток вывода,
[47:22.000 --> 47:24.000]  то есть есть
[47:24.000 --> 47:26.000]  можно сказать, что
[47:26.000 --> 47:28.000]  время от времени
[47:28.000 --> 47:30.000]  машины приходят в состояние
[47:30.000 --> 47:32.000]  напечатать новый символ.
[47:32.000 --> 47:34.000]  Ну и новый символ может быть
[47:34.000 --> 47:36.000]  скажем нулевым, может быть единицей
[47:36.000 --> 47:38.000]  или может быть концом слова.
[47:38.000 --> 47:40.000]  Значит, что слово закончилось,
[47:40.000 --> 47:42.000]  печатает следующее.
[47:42.000 --> 47:44.000]  Значит, есть
[47:44.000 --> 47:48.000]  поток вывода,
[47:50.000 --> 47:52.000]  поток вывода, в который
[47:56.000 --> 47:58.000]  направляются
[48:00.000 --> 48:02.000]  какие-то биты,
[48:02.000 --> 48:04.000]  печатаемых слов.
[48:04.000 --> 48:06.000]  Соответственно,
[48:06.000 --> 48:08.000]  вот тут в качестве выхода
[48:08.000 --> 48:10.000]  получается не какая-то конечная,
[48:10.000 --> 48:12.000]  не конечный объект,
[48:12.000 --> 48:14.000]  а бесконечная последовательность.
[48:14.000 --> 48:16.000]  То есть получается выход
[48:18.000 --> 48:20.000]  это бесконечная
[48:20.000 --> 48:22.000]  последовательность.
[48:24.000 --> 48:26.000]  Вот,
[48:28.000 --> 48:30.000] 
[48:30.000 --> 48:40.720]  Ну, может быть, конечная, может быть, и конечная.
[48:40.720 --> 48:51.840]  Соответственно, утверждение такое, что а разрешима тогда
[48:51.840 --> 49:06.040]  только тогда, когда можно напечатать по возрастанию.
[49:06.040 --> 49:11.840]  Вот, а здесь слева направо это очень простая программа.
[49:11.840 --> 49:19.480]  Слева направо можно просто написать цикл, на конец там,
[49:19.480 --> 49:28.320]  for each. Давайте я буду сейчас считать, что аргумент это число.
[49:28.320 --> 49:38.480]  Значит, для каждого n 0, 1, 2 и так далее, значит,
[49:38.480 --> 49:50.120]  я в строчку напишу, тут места нету. Значит, if n лежит в а, напечатать n.
[49:50.120 --> 50:01.680]  Вот, соответственно, если не прижит, то просто к следующему n переходит.
[50:01.680 --> 50:11.000]  Вот, вот то, что лежит в а, мы можем проверить вот этим алгоритмом.
[50:11.000 --> 50:14.080]  Да, мы его используем как подпрограмму.
[50:14.080 --> 50:32.400]  Так, да, нет, может быть, конечная. Так, хорошо, дайте примеры.
[50:32.400 --> 50:35.840]  Примеры разрешимых множеств.
[50:35.840 --> 50:45.280]  Значит, первый пример – это любое конечное множество.
[50:45.280 --> 50:54.720]  Любое конечное множество – разрешима. Почему?
[50:54.720 --> 50:57.440]  Потому что можно прямо в текст программы записать полный список.
[50:57.800 --> 51:17.680]  Можно список его элементов записать в текст программы.
[51:17.680 --> 51:26.080]  Вот, ну и как бы каждый раз, когда есть текст, просто сравнивать по списку, да,
[51:26.080 --> 51:31.520]  и сказать, лежит в списке или нет. Вот, второй пример.
[51:31.520 --> 51:37.760]  Значит, второй пример для множества четких чисел.
[51:37.760 --> 51:48.440]  Ну, конечно, если у нас что в двоичной записи, то нужно посмотреть,
[51:48.440 --> 51:51.000]  просто там ноль в конце или единица в конце.
[51:51.000 --> 51:57.120]  А если в десятичной, то там будет пять вариантов, когда да, пять вариантов, когда нет.
[51:57.120 --> 52:01.480]  Вот, если даже в троичной, то все равно нужно написать алгоритм,
[52:01.480 --> 52:09.840]  и это будет очень-очень сложный. Ну вот, теперь смотрите, что будет происходить,
[52:09.840 --> 52:13.480]  если мы вот такую программу будем применять.
[52:13.480 --> 52:17.440]  Давайте, смотрите, есть у нас, конечно, множество.
[52:17.440 --> 52:22.920]  В этом идем, там ноль лежит, не лежит, да, скажем, если лежит, то печатаем.
[52:22.920 --> 52:25.440]  Да, один лежит, не лежит, два лежит, не лежит.
[52:25.440 --> 52:29.480]  Вот, на какой-то момент мы дойдем до последнего слова, который лежит,
[52:29.480 --> 52:34.040]  и дальше будет бесконечное число шагов, и на них на всех будет ответ «нет»,
[52:34.040 --> 52:38.360]  и мы больше ничего не напечатаем. Вот. Ну, конечно, и так, конечно,
[52:38.360 --> 52:44.760]  можно по возрастанию напечатать. Вот. А что с четными? Ну вот, а ноль лежит,
[52:44.760 --> 52:49.960]  лежит, да, значит, мы его печатаем. Единица лежит, нет, не лежит, пропускаем.
[52:49.960 --> 52:55.160]  Двойка лежит, лежит, печатаем. Тройку пропускаем, четверку печатаем, и так далее.
[52:56.000 --> 52:58.480]  Вот. И вот здесь получается бесконечная последовательность.
[52:58.480 --> 53:01.640]  То есть, в целом, смотрите, здесь вообще нет условий остановки.
[53:01.640 --> 53:05.840]  Здесь нет условий остановки, то есть, заведомо бесконечно долго это будет работать.
[53:05.840 --> 53:13.640]  Но вывод может быть конечен. Так. Ну, я в 40 минут, давайте попробуем закончить.
[53:13.640 --> 53:28.120]  Да, то есть, работа всегда будет бесконечна, а вот вывод может быть конечен.
[53:28.120 --> 53:31.800]  Ну, если в нём что-то самое бесконечное, то конечно, вывод тоже будет бесконечным.
[53:31.800 --> 53:37.960]  Вот. Хорошо. Так, какие ещё примеры? Ну, собственно, всё, что угодно,
[53:37.960 --> 53:46.160]  для чего может программа написать. А она всё будет перебирать. Она всё будет перебирать
[53:46.160 --> 53:52.760]  бесконечным долгом. Вот эта машина будет работать. Потому что она всё будет, она никак не узнает,
[53:52.760 --> 53:56.240]  что она уже дошла до конца. Она так и будет перебирать, перебирать, перебирать,
[53:56.240 --> 54:10.600]  и работать бесконечно долго. Нет, смотрите, прошлое спрашивайте, можно конечно для того же множества,
[54:10.600 --> 54:15.160]  если что-то конечное, то можно писать программу, которая у напечаток и расстания остановится.
[54:15.160 --> 54:21.520]  Вот. Но она будет выглядеть не так. Вот эта программа будет работать бесконечно долго,
[54:21.520 --> 54:25.240]  потому что она бесконечно много, она никак не узнает, что она уже дошла до конца множества,
[54:25.640 --> 54:31.480]  и будет бесконечно много. Числа, которые убирать лежат, они не лежат каждый раз. Получается,
[54:31.480 --> 54:45.440]  что нет, ничего не печатать, но и вот так вот бесконечности работать. Вот. Так. Ну да. Да-да-да.
[54:45.440 --> 54:56.760]  Более того, даже для конечного множества может быть программа не такая. Например,
[54:56.760 --> 55:07.560]  давайте я сюда напишу. Множество совершенных чисел. Знаете, что это за числа? Это числа,
[55:07.560 --> 55:22.800]  которых сумма делителей, меньше их, равна самому числу. Вот. Первые 3, 6, 28 и 496. Вот. Но конечное
[55:22.800 --> 55:28.680]  множество или нет, никто не знает, это открытая проблема. Значит, есть одна открытая проблема
[55:28.680 --> 55:34.760]  конечного множества совершенных чисел или нет. Такая открытая проблема, существует ли нечетное
[55:34.760 --> 55:42.200]  совершенное число? Да, тоже никто не знает. Вот. Но неважно, конечное множество или нет,
[55:42.200 --> 55:48.480]  оно в любом случае разрешимое. Потому что можно разложить на множители. Если у нас не держит
[55:48.480 --> 55:53.960]  время работы, то можно просто перебрать все делители, разложить на множители. Перебрать все
[55:53.960 --> 55:58.600]  простые делители, разложить на множители, взять все комбинации, просуммировать и проверить,
[55:58.600 --> 56:13.440]  совпало или не совпало. Ну вот. И, соответственно, получается, что тут как бы даже премионист не
[56:13.440 --> 56:20.720]  будут знать, до какого М нужно перебирать. Даже если это множество конечное, то мы пока не знаем,
[56:20.720 --> 56:25.800]  какое там максимальное М. Вот. А просто, кстати, такую программу, да, перебирать по очереди,
[56:25.800 --> 56:37.920]  проверять совершенно или нет, это мы, конечно, можем. Вот так. Хорошо. Сейчас. Я тут в одну сторону
[56:37.920 --> 56:44.400]  написал, в другую сторону эти для семинаров оставим. Теперь еще простого надо сказать про
[56:44.400 --> 56:59.120]  разрешимое множество. Простые утверждения. Значит, если А разрешимо, то тогда А с чертой тоже
[56:59.120 --> 57:08.680]  разрешимо. Здесь, конечно, есть некоторый универсум, да, либо универсум, это все были двоичные слова,
[57:08.680 --> 57:16.880]  либо все натуральные числа, но и в этом универсум берем дополнение. Как это доказывается? Ну,
[57:16.880 --> 57:34.480]  нужно просто взять отрицание от ответа. Тут нужно взять отрицание от ответа. Вот. Конечно,
[57:34.480 --> 57:43.760]  получается, что х лежит во, тогда и только тогда, когда х не лежит во с чертой. То есть ответ для
[57:43.760 --> 57:55.080]  А и ответ для А с чертой противоположен. Так. Ну и также утверждение, то если А и Д разрешимы,
[57:55.080 --> 58:09.120]  то тогда, скажем, пересечение, объединение, или, скажем, дикартовое произведение,
[58:09.120 --> 58:23.880]  в этом калкотинация, вот и так далее. Все такие штуки тоже разрешимы. Вот. Ну, например,
[58:23.880 --> 58:30.080]  значит, калкотинация, конечно, для слов, но, в принципе, эту запись можно и для множеств чисел
[58:30.080 --> 58:35.560]  понимать, что мы берем все возможные произведения числа из первого множества и числа из второго
[58:35.560 --> 58:46.840]  множества. Это тоже логично так обозначать. Вот. Ну, значит, для калкотинации, ну, давайте,
[58:46.840 --> 58:56.880]  для калкотинации А на Б, ну, как понять у нас слово является калкотинацией или нет? Ну,
[58:56.880 --> 59:10.400]  нужно перебрать все возможные разбиения. Значит, перебираем все представления. Перебираем
[59:10.400 --> 59:28.240]  представления слова W калкотинации У на В. Вот. И проверяем, что одновременно У лежит А и В
[59:28.240 --> 59:36.200]  лежит В. Значит, вот если для какого-то разбиения и то, и то выполнено, то, значит, ответ да.
[59:36.200 --> 59:43.520]  Это такая ДНФ получается. Дизьюнция по всем разбиениям, коньюнция вот этого и вот этого. И тут,
[59:43.520 --> 01:00:02.200]  конечно, поскольку А и В разрешимы, то мы можем проверить одно и другое. Так. Ну, хорошо. Следующее
[01:00:02.440 --> 01:00:06.640]  понятие, которое мы будем подробно изучать в следующий раз, это перечислимое множество.
[01:00:06.640 --> 01:00:15.640]  Но, по крайней мере, определение и самые простые свойства давайте изучим сейчас. Значит,
[01:00:15.640 --> 01:00:19.480]  перечислимое множество это те, которые тоже можно перечислить, но не обязательно по
[01:00:19.480 --> 01:00:36.440]  возрастанию. Значит, определение А перечислимо, если существует вот такая перечисляющая машина,
[01:00:36.440 --> 01:01:03.880]  перечисляющая машина множество слов, в выводе которых совпадает С. Но важно,
[01:01:03.960 --> 01:01:08.280]  что они не обязаны идти по возрастанию. Если они идут по возрастанию, значит, мы это пропустили,
[01:01:08.280 --> 01:01:15.280]  но это верно, что если они идут по возрастанию, то тогда это разрешимое множество. Значит,
[01:01:15.280 --> 01:01:38.080]  здесь важно, что слова не обязательно идут по возрастанию. Это будет в следующий раз. Но,
[01:01:38.680 --> 01:01:48.600]  смотрите, давайте пока поймем для начала, почему не все функции вычислимые, не все множества
[01:01:48.600 --> 01:02:01.160]  разрешимые и так далее. Просто из-за мощности. Не все множества разрешимые, потому что всех под
[01:02:01.160 --> 01:02:19.280]  множество континуум, под множество реальных чисел, а разрешимых не больше, чем алгоритмов.
[01:02:31.160 --> 01:02:42.160]  Я, кстати, не предварил в начале. У алгоритма обязательно конечное описание. Я вспоминал,
[01:02:42.160 --> 01:02:46.440]  но не застрял внимание, что у машины-тиринга обязательно конечное число состояний,
[01:02:46.440 --> 01:02:54.000]  конечное число симфофавита и, как следствие, конечная программа. То есть она описывается
[01:02:54.000 --> 01:03:00.760]  какой-то конечной строкой. Ну и, конечно, любая программа, которую вы напишете,
[01:03:00.760 --> 01:03:13.400]  тоже будет конечная. Значит, алгоритм определяется конечной программой, значит,
[01:03:13.400 --> 01:03:36.760]  следовательно, множество алгоритмов счетно. Ну вот, значит, революционных нож тоже счетно.
[01:03:36.760 --> 01:03:42.120]  Ну и счетных все-таки будет, потому что любая конечная разрешимая уже конечных счетна.
[01:03:42.120 --> 01:03:47.360]  Вот, всех разрешимых тоже счетно. Ну вот, значит, если разрешимых счетно, а всего континуум,
[01:03:47.360 --> 01:03:53.800]  значит, есть неразрешимые. Вот, но доказать, что есть разрешимые, неразрешимые перечислимые,
[01:03:53.800 --> 01:03:58.280]  так не получится, потому что перечислимых тоже счетно. Да, разрешимых, счетных перечислимых,
[01:03:58.280 --> 01:04:08.520]  счетно, значит, то, что есть перечислимые, неразрешимые, это посложнее. Не, ну на самом деле
[01:04:08.520 --> 01:04:24.880]  определить такое множество несложно. Например, явный пример, явный пример перечислимого,
[01:04:24.880 --> 01:04:36.000]  неразрешимого множества, это из первого семестра общезначимые формулы с числением
[01:04:36.000 --> 01:04:43.280]  предикатов. Ну, то есть, легкие предикаты. Общезначимые формулы первого порядка.
[01:04:43.280 --> 01:04:52.520]  Значит, они перечислимы, потому что есть теорияма о полноте. Они перечислимые,
[01:04:52.520 --> 01:04:59.640]  очень-очень выводимые, и мы можем просто написать вообще всевозможные выводы и все,
[01:04:59.640 --> 01:05:05.840]  что там получается. И поскольку у любой общезначимый формулы есть вывод, то мы рано или поздно напишем.
[01:05:05.840 --> 01:05:18.040]  То есть, перечисление – это просто перебор всевозможных выводов,
[01:05:18.040 --> 01:05:31.600]  значит, перебор выводов из числений предикатов. Ну и, соответственно, печатание выведенных формул.
[01:05:31.600 --> 01:05:36.840]  Конечно, чтобы это было нормально определено, нужно еще определить, в каком образом все
[01:05:36.840 --> 01:05:41.080]  происходит, в какой сигнатуре, какие переменные и так далее. Но это мы так не договоримся,
[01:05:41.080 --> 01:05:51.360]  значит, печатание выведенных. Значит, по теории о корректности печатаются только общезначимые,
[01:05:51.360 --> 01:05:58.320]  а по теории о полноте все общезначимые будут напечатаны. Но то, что неразрешимо, то, что
[01:05:58.320 --> 01:06:04.040]  нельзя по формули понять навсегда, истинно или нет. И это не простая вещь на теремы Чорча,
[01:06:04.040 --> 01:06:08.560]  и это даже мы не будем в основном курсе доказывать, наверное. Ну и посмотрим,
[01:06:08.560 --> 01:06:13.520]  может, докажем, но так это вообще будет в дополнительном билете для желающих в экзамене.
[01:06:13.520 --> 01:06:26.360]  Ну вот, так, что еще надо сказать. Я, верно, напоследок, сейчас, может, на пару минут еще
[01:06:26.400 --> 01:06:33.400]  задержимся. Напоследок я хочу тоже несложно, но очень важную терему доказать. В этой тереме
[01:06:33.400 --> 01:06:47.240]  Поста. Значит, терема Поста. Значит, заключается в том, что множество А разрешимо тогда и только
[01:06:47.240 --> 01:07:03.920]  тогда, когда и А перечислимо, и А с чертой перечислимо. Вот, значит, слева направо.
[01:07:03.920 --> 01:07:15.360]  Значит, слева направо. Ну, фактически, может, доказали. Значит, если А разрешимо,
[01:07:15.360 --> 01:07:23.360]  то тогда и А с чертой разрешимо. Это у нас было. А то, если разрешимо, то и перечислимо,
[01:07:23.360 --> 01:07:33.560]  потому что можно перечислить по возрастанию. Отсюда получается, что А перечислимо. Отсюда
[01:07:33.560 --> 01:07:50.160]  получается, что А с чертой перечислимо. Советственно, если мы начнем отсюда, то мы перешли сюда и вот
[01:07:50.160 --> 01:08:13.800]  такой штука сюда. Но обратную сторону нужно немножко схитрить. Если, может, это конечная,
[01:08:13.800 --> 01:08:27.320]  то мы и так знаем, что она разрешима. Значит, если А конечная, то тогда она разрешима. Если А с чертой
[01:08:27.320 --> 01:08:35.360]  конечная, то тоже разрешима по той же причине. Если А с чертой конечная, то тоже разрешима.
[01:08:35.360 --> 01:08:51.120]  Если же и А с чертой бесконечная, то тогда делаем так. Начинаем чередовать. Значит,
[01:08:51.120 --> 01:09:02.920]  слово из А, слово из А с чертой, слово из А, слово из А с чертой. Значит, чередуем выводы,
[01:09:02.920 --> 01:09:22.960]  не выводы, а слова. Значит, слова из выводов, а А с чертой. Опять-таки мы ждем встречи Х. Ждем,
[01:09:22.960 --> 01:09:32.160]  когда встретится Х. Ну и, соответственно, если он встретился в А, то значит, он лежит в А,
[01:09:32.160 --> 01:09:37.440]  если он встретился в А с чертой, то значит, он не лежит в А. А встретиться он заветно,
[01:09:37.440 --> 01:09:43.960]  потому что он все-таки либо в А, либо в А с чертой есть. Поэтому точно все езда перечислены здесь,
[01:09:44.960 --> 01:09:54.840]  значит, где-то он перечислится. Вот такое рассуждение. Следующий раз мы посмотрим
[01:09:54.840 --> 01:10:06.880]  несколько взглядов на причинимые множества. Мы, наверное, двигаемся к доказательству,
[01:10:06.880 --> 01:10:11.640]  что есть причинимые множества. Может, докажем. На этом спасибо за внимание.
