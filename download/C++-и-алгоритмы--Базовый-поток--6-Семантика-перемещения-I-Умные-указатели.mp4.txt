[00:00.000 --> 00:11.000]  Сегодня мы пройдем две такие базовые темы, которые вам нужны будут для решения второго задания.
[00:11.000 --> 00:15.000]  Собственно, мы, наверное, сегодня закончим всю базовую часть, которая относится к второму заданию.
[00:15.000 --> 00:21.000]  Вот двумя довольно важными и, на мой взгляд, интересными темами.
[00:21.000 --> 00:27.000]  И первое, с чего мы начнем, мы начнем разговор про семантику перемещения.
[00:28.000 --> 00:33.000]  Семантика перемещения – это то, без чего, вообще говоря, не обходятся современные плюсы.
[00:33.000 --> 00:42.000]  Ну и, на самом деле, то, что зачастую делает ваши программы более эффективными, чем они, возможно, были до этого.
[00:42.000 --> 00:44.000]  Но во всем по порядку.
[00:44.000 --> 00:50.000]  Чтобы начать разговор о семантике перемещения, необходимо вернуться довольно сильно назад,
[00:50.000 --> 00:54.000]  возможно, даже на одну из первых лекций по языку вашего первого семестра.
[00:54.000 --> 01:00.000]  И необходимо поговорить про выражение и вообще про структуру программы на C++.
[01:00.000 --> 01:05.000]  Наверняка, когда вы только начинаете обсуждать язык C++, вы говорили про какие-то конструкции,
[01:05.000 --> 01:10.000]  про то, какие операторы в языке существуют, как строится программа на языке C++.
[01:10.000 --> 01:14.000]  И вы говорили, что программа на языке C++ стоит из стейфментов,
[01:14.000 --> 01:19.000]  и большинство из стейфментов представляют собой так называемое выражение или экспрешены.
[01:19.000 --> 01:21.000]  То есть, вообще говоря, что такое выражение?
[01:21.000 --> 01:24.000]  В общем, у меня просто некоторая последовательность символов,
[01:24.000 --> 01:27.000]  которая задает некоторые вычисления.
[01:27.000 --> 01:30.000]  Ну или формально это последовательность некоторых операций, операндов,
[01:30.000 --> 01:32.000]  ну и, собственно, вот эта вот последовательность операций-операндов
[01:32.000 --> 01:34.000]  задает некоторые вычисления.
[01:34.000 --> 01:38.000]  То есть, это та вещь, которая, собственно, производит некоторые математические вычисления
[01:38.000 --> 01:42.000]  или какие-то другие штуки, которые представляют собой непосредственно исполняемый код,
[01:42.000 --> 01:45.000]  то есть, то, что делает программа.
[01:45.000 --> 01:49.000]  Ну и соответственно, результат любого выражения на языке C++ представляет собой
[01:49.000 --> 01:54.840]  в результате выполнения выражения мы получаем либо некоторое возвращаемое
[01:54.840 --> 01:58.580]  значение, например, результат выражения х плюс у
[01:58.580 --> 02:01.420]  результат выражения х плюс у возвращает вам результат сложения
[02:01.420 --> 02:07.720]  результат вызова какой-то функции口т аргумента возвращает результат этой функции
[02:07.720 --> 02:11.100]  результат выполнения выражения может вам приходить в виде некоторого побочного эффекта
[02:11.100 --> 02:11.680]  например если вы делаете плюс плюс х или х плюс плюс кач
[02:11.680 --> 02:18.680]  попочного эффекта вы дополнительно получать еще увеличенный х
[02:18.680 --> 02:24.820]  Если вы вызываете какую-то функцию, например, функцию printf,
[02:24.820 --> 02:29.320]  эта функция печатает что-то на экран, то есть это побочный эффект.
[02:29.320 --> 02:33.560]  Любое выражение задает некоторое вычление, и результаты этого вычления
[02:33.560 --> 02:37.560]  мы получаем либо в виде возвращаемого значения, либо в виде некоторого побочного эффекта.
[02:37.560 --> 02:40.520]  Причем возвращаемое значение у вас есть всегда, побочный эффект не всегда,
[02:40.520 --> 02:43.560]  как, например, у результата сложения.
[02:43.640 --> 02:48.360]  И о чем вы, наверное, не говорили, так это про то, что каждое выражение,
[02:48.360 --> 02:51.160]  оно обязательно характеризуется двумя вещами.
[02:51.160 --> 02:53.640]  Вот у любого выражения всегда есть две характеристики.
[02:53.640 --> 02:56.920]  Первое — это тип возвращаемого значения, то есть, как я сказал,
[02:56.920 --> 02:58.440]  выражение всегда что-то возвращает.
[02:58.440 --> 03:01.960]  А второе — это некоторая такая штука, про которую вы точно не говорили,
[03:01.960 --> 03:03.320]  это категория значения.
[03:03.320 --> 03:08.520]  И вот, собственно, с разговора про категории значения мы и начнем сегодняшнюю лекцию.
[03:08.520 --> 03:11.960]  Ну, давайте для начала просто пройдемся по примерам и просто поймем,
[03:11.960 --> 03:14.280]  потому что мы с вами на одном языке разговариваем.
[03:14.280 --> 03:18.760]  Ну, допустим, у вас есть переменная типа int, это x, и другая переменная типа int — это y.
[03:18.760 --> 03:22.600]  Вот результат выражения x плюс y, то есть x плюс y — это некоторое выражение,
[03:22.600 --> 03:25.880]  и его возвращаемый тип — это int, да, все согласны.
[03:25.880 --> 03:29.560]  Вот, побочного эффекта у этой операции нет, ну, то есть, кроме того,
[03:29.560 --> 03:32.520]  что оно возвращает вам результат сложения, ничего не происходит.
[03:32.520 --> 03:35.240]  Вот, ну и есть, ну и также у этого выражения есть некоторая характеристь,
[03:35.240 --> 03:38.520]  которая называется категорией значения, при нем мы пока ничего не знаем.
[03:38.600 --> 03:42.600]  Окей, есть выражение плюс плюс x, он возвращает вам тоже int.
[03:42.600 --> 03:46.300]  И при этом увеличивает x на единицу. Тоже самое с x плюс плюс.
[03:46.300 --> 03:49.560]  Тоже возвращает int и увеличивает x на единицу.
[03:49.560 --> 03:52.520]  И здесь уже, наверное, должно стать понятно, потому что, с одной стороны,
[03:52.520 --> 03:57.760]  мы понимаем, что плюс плюс x и x плюс плюс — это, вобще говоря, разные операции, да.
[03:57.760 --> 04:00.040]  Ну, то есть, во-первых, мы понимаем, что они возвращают разные вещи.
[04:00.040 --> 04:05.720]  То есть, первая штука возвращает вам измененный x, вторая штука возвращает вам x старый.
[04:05.720 --> 04:09.720]  Но при этом, что еще мы знаем про плюс плюс x и x плюс плюс, в чем их разница?
[04:15.720 --> 04:16.720]  Что еще раз?
[04:19.720 --> 04:24.720]  Ну да, вы уже говорили про l-value и l-value, но если грубо говоря, то результату плюс плюс x можно что-то присвоить, в частности.
[04:25.720 --> 04:32.720]  А результату x плюс плюс ничего присвоить нельзя, то есть вы не можете написать x, вы не можете написать x плюс плюс, допустим, равно единице.
[04:32.720 --> 04:37.720]  А написать плюс плюс x равно единице можете, то есть это ce, а это ok.
[04:38.720 --> 04:40.720]  То есть в этом смысле они уже различаются.
[04:41.720 --> 04:45.720]  Собственно, забегая заранее вперед, скажу, что как раз эта разница заключается в так называемой категории значений.
[04:46.720 --> 04:48.720]  Ну окей, давайте пойдем дальше. New int.
[04:49.720 --> 04:52.720]  New int – это тоже выражение, которое возвращает вам некоторый указатель.
[04:53.720 --> 04:55.720]  Ну и в качестве побочного эффекта происходит некоторое выделение ресурса.
[04:55.720 --> 05:03.720]  То есть у операционной системы запрашивается некоторая область памяти в оперативной памяти и так далее.
[05:04.720 --> 05:11.720]  Ну и delete p – это тоже выражение, данное выражение возвращает void, ну и соответственно в качестве побочного эффекта у вас ресурс возвращается операционной системе.
[05:14.720 --> 05:15.720]  Ну такие примеры.
[05:16.720 --> 05:19.720]  Ну и теперь давайте поговорим про категории значений. Что же это вообще говоря такое?
[05:19.720 --> 05:28.720]  Категория значения, значит самый главный вопрос, на который отвечает категория значения – это материален ли тот объект, который вам вернулся или нет.
[05:29.720 --> 05:33.720]  То есть возвращаемся к вопросу о plus plus x, x plus plus.
[05:34.720 --> 05:38.720]  Вот когда вы возвращаете результат, допустим, сложение, давайте сначала поговорим про x plus y.
[05:41.720 --> 05:47.720]  Когда возвращается результат значения x plus y, то этот результат, грубо говоря, нематериален, то есть вы его не можете пощупать.
[05:47.720 --> 05:49.720]  Вам возвращается результат и все.
[05:50.720 --> 05:53.720]  Если я вас спрошу, чему равен результат выражения 2 plus 3?
[05:54.720 --> 05:58.720]  5. А где это 5? Можно его пощупать? Нет, нельзя.
[05:59.720 --> 06:03.720]  Не знаю, вопрос. Что является средством общения?
[06:04.720 --> 06:06.720]  Телефон. Какой телефон? Ну непонятно.
[06:07.720 --> 06:09.720]  А если я спрошу, что сейчас лежит на столе? Вот телефон, вот он.
[06:10.720 --> 06:12.720]  Это объект материален, то есть я могу конкретно указать на него.
[06:13.720 --> 06:14.720]  И в этом разница.
[06:14.720 --> 06:15.720]  То есть есть результаты, которые нематериальные.
[06:16.720 --> 06:18.720]  Мы просто грубо говоря их произносим, и все.
[06:19.720 --> 06:21.720]  А есть результаты матери wszystkie, то есть конкретные объекты.
[06:22.720 --> 06:24.720]  Если я спрошу, кто присутствует сейчас на лекции?
[06:25.720 --> 06:26.720]  Я скажу, человек.
[06:27.720 --> 06:28.180] evп MDB
[06:28.180 --> 06:29.720]  И они просто студенты. Или какой-то студент.
[06:30.720 --> 06:31.720]  Если я скажу, что студент присутствует на лекции, то это правда.
[06:32.720 --> 06:35.720]  Если я скажу, что этот конкретный студент присутствует на лекции, то это он сидит здесь.
[06:36.720 --> 06:39.720]  Я могу его пощупать, я могу с ним что-то сделать, я могу его изменять.
[06:40.720 --> 06:41.720]  В этом разница. Понятно?
[06:41.720 --> 06:45.720]  то есть есть материальные объекты, у которых есть реальное представление в памяти,
[06:45.720 --> 06:49.720]  которое присутствует реально в виде объектов, а есть просто так называемые временные значения,
[06:49.720 --> 06:53.720]  которые буквально здесь появляются и сразу же исчезают.
[06:53.720 --> 06:57.720]  И вот эту разницу создает как раз категория значений.
[06:57.720 --> 07:00.720]  Давайте снова вернемся к примеру.
[07:00.720 --> 07:04.720]  Понятное дело, что во всех выражениях, кроме одного, объекты здесь не материальные,
[07:04.720 --> 07:08.720]  в частности x и y. Здесь и сейчас создается результат,
[07:08.720 --> 07:11.720]  когда aparecerал результат, но при этом он нигде не сохраняется, который нигде не присутствует явно,
[07:11.720 --> 07:14.720]  то есть результат подставляется в данном конкретном месте и все,
[07:14.720 --> 07:17.720]  после этого он сразу исчезает.
[07:17.720 --> 07:21.720]  x++ тоже. Вам возвращается старое значение, но при этом оно нигде в явном виде в памяти
[07:21.720 --> 07:25.720]  не присутствует. В том месте, где лежит x, там уже лежит не старое значение, а новое,
[07:25.720 --> 07:29.720]  поэтому у старого значения нет никакого явного представления в памяти.
[07:29.720 --> 07:33.720]  newInT baseline — результат возвращается в виде указателя, то есть указатель просто возвращается,
[07:33.720 --> 07:37.720]  и он нигде не хранится на самом деле.
[07:37.720 --> 07:40.720]  в принципе, не полный тип, он нигде храниться не может.
[07:40.720 --> 07:43.720]  Единственное выражение в данных примерах, которое
[07:43.720 --> 07:46.720]  обладает свойством материальности,
[07:46.720 --> 07:49.720]  то есть результат выражения представляет в себе реальный объект памяти,
[07:49.720 --> 07:52.720]  это plus plus x. Понятно?
[07:52.720 --> 07:55.720]  То есть plus plus x возвращает int, и мы можем конкретно сказать,
[07:55.720 --> 07:58.720]  какой int. Вот int, который лежит
[07:58.720 --> 08:01.720]  по месту в памяти x.
[08:01.720 --> 08:04.720]  Данный конкретный x.
[08:04.720 --> 08:07.720]  Все понятно?
[08:07.720 --> 08:10.720]  И вот такие категории значений, которые представляют из себя
[08:10.720 --> 08:13.720]  реально материальные объекты в памяти,
[08:13.720 --> 08:16.720]  называются L-value.
[08:16.720 --> 08:19.720]  Л-value это категория значений, которая обладает идентичностью.
[08:19.720 --> 08:22.720]  Ну и дополнительно она еще обладает тем свойством,
[08:22.720 --> 08:25.720]  что она неперемещаема, но об этом позже поговорим.
[08:25.720 --> 08:28.720]  Пока для нас главное, что L-value это категория значений,
[08:28.720 --> 08:31.720]  которая обладает идентичностью.
[08:32.720 --> 08:35.720]  Вот. Как отличить L-value от...
[08:35.720 --> 08:38.720]  Не L-value. Ну, очень просто.
[08:38.720 --> 08:41.720]  Если у результатов выражения вы можете взять адрес,
[08:41.720 --> 08:44.720]  то есть вы можете спросить где это вот...
[08:44.720 --> 08:47.720]  Вот вам вернулся результат, вы можете спросить где он,
[08:47.720 --> 08:50.720]  где он расположен. Тогда это L-value.
[08:50.720 --> 08:53.720]  Если у результатов выражения вы не можете спросить адрес, то это не L-value.
[08:53.720 --> 08:57.220]  Это не критерия, на самом деле, не свойство, но и может пользоваться как критерия.
[08:57.220 --> 09:00.220]  Вот, значит. Что относится к L-value?
[09:00.220 --> 09:04.220]  что обладает идентичностью, что обладает некоторым материальным представлением.
[09:04.220 --> 09:06.220]  Во-первых, переменная.
[09:06.220 --> 09:09.220]  Первый пункт на самом деле самый важный.
[09:09.220 --> 09:11.220]  Переменная это всегда lvalue.
[09:11.220 --> 09:13.220]  Всегда, нет никаких исключений.
[09:13.220 --> 09:17.220]  Переменная это всегда lvalue.
[09:17.220 --> 09:20.220]  Если вы в коде встречаете переменную, то сразу говорите,
[09:20.220 --> 09:25.220]  что выражение, которое представляет себе переменную, возвращает вам lvalue.
[09:25.220 --> 09:26.220]  Дальше.
[09:26.220 --> 09:30.220]  Если у вас функция или операция возвращает ссылку,
[09:30.220 --> 09:34.220]  например, вы написали вот такую функцию.
[09:34.220 --> 09:36.220]  Бла-бла.
[09:36.220 --> 09:40.220]  И вот если в качестве возвращаемого значения вы указываете int амперсант,
[09:40.220 --> 09:42.220]  double амперсант или что угодно амперсант,
[09:42.220 --> 09:45.220]  то результат этого выражения – это lvalue.
[09:45.220 --> 09:48.220]  И тут стоит отдельно поговорить о том,
[09:48.220 --> 09:51.220]  что на самом деле такого типа возвращаемого значения как ссылка
[09:51.220 --> 09:53.220]  на самом деле формально.
[09:54.220 --> 09:57.220]  Потому что когда вы что-то возвращаете из функции,
[09:57.220 --> 10:00.220]  вы на самом деле что говорите в конкретном случае?
[10:00.220 --> 10:03.220]  Вы говорите, что вы возвращаете int, что результат выражения f,
[10:03.220 --> 10:05.220]  то есть когда вы будете писать просто f,
[10:05.220 --> 10:07.220]  что результат этого выражения будет int,
[10:07.220 --> 10:10.220]  и при этом категория значения – это lvalue.
[10:10.220 --> 10:14.220]  Вот как раз эта ссылка говорит не о том, что вы возвращаете ссылку как тип,
[10:14.220 --> 10:18.220]  а говорит о том, что вы возвращаете int, и при этом этот int является lvalue.
[10:18.220 --> 10:20.220]  Понятно?
[10:20.220 --> 10:24.220]  То есть тип ссылки может называть только переменные,
[10:24.220 --> 10:26.220]  которые вы объявляете вот таким образом.
[10:26.220 --> 10:28.220]  Если у вас есть некоторая функция,
[10:28.220 --> 10:31.220]  которая возвращает, допустим, int амперсант,
[10:31.220 --> 10:34.220]  то правильно говорить, что функция f возвращает int
[10:34.220 --> 10:36.220]  с категорией значения lvalue.
[10:36.220 --> 10:39.220]  Для краткости обычно принято говорить, что f возвращает ссылку.
[10:39.220 --> 10:42.220]  В формальной точке зрения это не совсем корректно.
[10:42.220 --> 10:44.220]  Понятно, что я хотел сказать?
[10:44.220 --> 10:47.220]  То есть когда вы из функции или из операции
[10:47.220 --> 10:50.220]  делаете что-то по ссылке с амперсантом,
[10:50.220 --> 10:53.220]  то это означает, что вы возвращаете объект, то есть lvalue.
[10:53.220 --> 10:56.220]  Тоже самое касается любых операций, которые вы перегружаете
[10:56.220 --> 10:58.220]  или которые есть в языке.
[10:58.220 --> 11:01.220]  Сейчас если plus-plus-x, то понятно, что возвращает ссылку.
[11:01.220 --> 11:03.220]  Что еще возвращает ссылку?
[11:03.220 --> 11:06.220]  Всякие присваивающие версии – x плюс равно, x делить равно и так далее.
[11:06.220 --> 11:09.220]  Все, они возвращают ссылку, они возвращают lvalue.
[11:09.220 --> 11:13.220]  Третий пример lvalue – это строковые литералы.
[11:13.220 --> 11:16.220]  На первой лекции я, кажется, пытался что-то сказать,
[11:16.220 --> 11:18.220]  поэтому даже в камеру говорил.
[11:18.220 --> 11:21.220]  Сейчас говорю, что строковые литералы – это lvalue.
[11:21.220 --> 11:24.220]  К строковым литералам можно относиться так,
[11:24.220 --> 11:27.220]  что это просто некоторое специальное имя переменной,
[11:27.220 --> 11:30.220]  которое представляет себе ссылку куда.
[11:30.220 --> 11:33.220]  Куда идет ссылка строковых литералов?
[11:33.220 --> 11:36.220]  На первой лекции говорили.
[11:36.220 --> 11:39.220]  Где хранятся строковые литералы, строки?
[11:39.220 --> 11:42.220]  В таблице строковых литералов.
[11:42.220 --> 11:45.220]  То есть когда вы пишете ABC,
[11:45.220 --> 11:48.220]  можно считать, что это некоторая специфичная переменная,
[11:48.220 --> 11:52.220]  которая просто представляет на себя область памяти,
[11:52.220 --> 11:56.220]  которая расположена в таблице строковых литералов.
[11:56.220 --> 11:59.220]  Соответственно, все эти примеры, первые три,
[11:59.220 --> 12:04.220]  x плюс плюс x, ABC – это все выражение, которое представляет себе lvalue.
[12:04.220 --> 12:08.220]  x плюс плюс один не является lvalue.
[12:08.220 --> 12:11.220]  Это понятно, потому что возвращается временный объект,
[12:11.220 --> 12:14.220]  у которого нельзя спросить адрес,
[12:14.220 --> 12:17.220]  только здесь появился и сразу же исчез.
[12:17.220 --> 12:20.220]  Пока все понятно.
[12:20.220 --> 12:23.220]  Почему lvalue называются именно lvalue?
[12:23.220 --> 12:26.220]  Это пошло еще из древнего, даже еще, по-моему,
[12:26.220 --> 12:29.220]  до языка C, когда говорили,
[12:29.220 --> 12:32.220]  что lvalue выражениям назывались те выражения,
[12:32.220 --> 12:36.220]  которые можно ставить в левой части операции присваивания.
[12:36.220 --> 12:43.220]  Сейчас это не так, но просто откуда пошло само название l?
[12:43.220 --> 12:46.220]  L отвечает за left, то есть левое значение.
[12:46.220 --> 12:49.220]  Но сейчас, вообще говоря, это неправда.
[12:49.220 --> 12:52.220]  Можете привести пример, когда что-то является lvalue,
[12:52.220 --> 12:55.220]  но при этом не может стоять в левой части присваивания.
[12:55.220 --> 12:58.220]  Что еще раз?
[12:58.220 --> 13:01.220]  Ну, строковый литерал в левой части операции присваивания.
[13:01.220 --> 13:04.220]  То есть нельзя написать ABC равно что-то.
[13:04.220 --> 13:07.220]  Ну или константы, на самом деле.
[13:07.220 --> 13:10.220]  Если вы объявили const int x,
[13:10.220 --> 13:13.220]  мы говорили, что переменная это всегда lvalue,
[13:13.220 --> 13:16.220]  но при этом в левой части присваивания x стоять не может.
[13:16.220 --> 13:19.220]  Все понятно?
[13:19.220 --> 13:22.220]  Окей.
[13:22.220 --> 13:25.220]  Здесь я, видимо, оставлял место для того, чтобы что-то присваивать.
[13:25.220 --> 13:28.220]  Короче говоря, чтобы понимать такое lvalue,
[13:28.220 --> 13:31.220]  lvalue это те значения, у которых есть место жительства,
[13:31.220 --> 13:34.220]  у которых есть постоянный дом.
[13:34.220 --> 13:37.220]  То есть если вы пишете x, то x на самом деле отвечает
[13:37.220 --> 13:40.220]  на какое-то конкретное место в памяти.
[13:40.220 --> 13:43.220]  Вот у вас есть memory.
[13:43.220 --> 13:46.220]  Если вы пишете что-то наподобие такого,
[13:46.220 --> 13:49.220]  вот представьте, что вы взяли адрес x,
[13:49.220 --> 13:52.220]  увеличили адрес x на единицу,
[13:52.220 --> 13:55.220]  и потом его разоминовали.
[13:55.220 --> 13:58.220]  Вот результат этого выражения это lvalue или не lvalue?
[13:58.220 --> 14:01.220]  Давайте так. Разберем вот это выражение.
[14:01.220 --> 14:04.220]  Что возвращает это выражение?
[14:04.220 --> 14:07.220]  Это характеризуется двумя свойствами.
[14:07.220 --> 14:10.220]  Первый — это тип. Какой тип имеет результат такого выражения?
[14:13.220 --> 14:16.220]  Ну какой тип?
[14:16.220 --> 14:19.220]  Если x — это int,
[14:19.220 --> 14:22.220]  тогда результат этого разоминования действительно int.
[14:22.220 --> 14:25.220]  Тип — это int. Вы взяли адрес int, прибавили к нему единицу,
[14:25.220 --> 14:28.220]  то есть взяли следующий по адресу int,
[14:28.220 --> 14:31.220]  и разоминовали это значение, получили результат int.
[14:31.220 --> 14:34.220]  Вот у результата разоминования у него есть какое-то место в памяти?
[14:34.220 --> 14:37.220]  Да, вот он, адрес x плюс 1.
[14:37.220 --> 14:40.220]  Грубо говоря, у вас есть улица, в которой стоят всякие дома.
[14:40.220 --> 14:43.220]  В домах эти хранятся всякие значения.
[14:43.220 --> 14:46.220]  Вы сказали, что вот есть дом пятерки, находится по адресу x.
[14:46.220 --> 14:49.220]  А теперь мы взяли адрес x на единицу вперед,
[14:49.220 --> 14:52.220]  то есть вот здесь.
[14:52.220 --> 14:55.220]  Здесь непонятно, что хранится, но при этом мы можем сказать,
[14:55.220 --> 14:58.220]  что тот результат, который вернулся,
[14:58.220 --> 15:01.220]  у него есть конкретное место в памяти.
[15:01.220 --> 15:04.220]  И мы вот это конкретное место в памяти и возвращаем.
[15:04.220 --> 15:07.220]  Понятно?
[15:07.220 --> 15:10.220]  То есть lvalue — это те объекты, у которых есть реальное представление в памяти,
[15:10.220 --> 15:13.220]  у которых есть адрес и тому подобное.
[15:13.220 --> 15:16.220]  Естественно, у результата разоминования какого-то адреса есть адрес,
[15:16.220 --> 15:19.220]  потому что мы этот адрес разоминовали.
[15:19.220 --> 15:22.220]  Давайте примеры посмотрим.
[15:22.220 --> 15:25.220]  Пробуем разобраться, какие выражения здесь являются lvalue и не являются lvalue.
[15:25.220 --> 15:28.220]  Что у меня тут есть?
[15:28.220 --> 15:31.220]  У меня тут есть переменная x,
[15:31.220 --> 15:34.220]  у меня тут есть ссылка на x, которая называется rx,
[15:34.220 --> 15:37.220]  есть константная ссылка на x, crx,
[15:37.220 --> 15:40.220]  есть константная ссылка tmp, которая связана с некоторым временным значением 11.
[15:40.220 --> 15:43.220]  Есть функция f, которая возвращает int,
[15:43.220 --> 15:46.220]  есть функция g, которая возвращает lvalue int, то есть int по ссылке.
[15:46.220 --> 15:49.220]  Ну и давайте по порядку.
[15:49.220 --> 15:52.220]  Если я пишу просто x, что это lvalue или не lvalue?
[15:52.220 --> 15:55.220]  Да, это lvalue, во-первых, возвращается int,
[15:55.220 --> 15:58.220]  во-вторых, тут lvalue.
[15:58.220 --> 16:01.220]  Если я пишу 5,
[16:01.220 --> 16:04.220]  5 — это, понятное дело, int,
[16:04.220 --> 16:07.220]  это lvalue или не lvalue?
[16:07.220 --> 16:10.220]  Не lvalue, да, 5 — это просто временное значение,
[16:10.220 --> 16:13.220]  у него нет никакого представления в памяти,
[16:13.220 --> 16:16.220]  то есть, грубо говоря, пятерка будет просто захардкожена в ассемблерный код.
[16:16.220 --> 16:19.220]  Это давайте писать не lvalue.
[16:19.220 --> 16:22.220]  Адрес x.
[16:25.220 --> 16:28.220]  Не lvalue.
[16:28.220 --> 16:31.220]  Потому что адрес x нигде не хранится.
[16:31.220 --> 16:34.220]  То есть, вопросы просили, где находится x,
[16:34.220 --> 16:37.220]  вот вам на бумажке вернули, вы бумажку потом сожгли.
[16:37.220 --> 16:40.220]  rx. lvalue. Почему это lvalue?
[16:40.220 --> 16:43.220]  Потому что переменная всегда lvalue.
[16:44.220 --> 16:47.220]  CRX.
[16:47.220 --> 16:50.220]  Абсолютно то же самое. CRX — переменная,
[16:50.220 --> 16:53.220]  переменная всегда lvalue. Tmp — тоже переменная, всегда lvalue.
[16:53.220 --> 16:56.220]  Результат вызова f.
[16:56.220 --> 16:59.220]  Не lvalue, потому что мы возвращаем
[16:59.220 --> 17:02.220]  результат по значению, то есть, просто int.
[17:02.220 --> 17:05.220]  Поэтому это не lvalue.
[17:05.220 --> 17:08.220]  f плюс f, понятно, тоже не lvalue.
[17:08.220 --> 17:11.220]  Во-первых, сами результаты f — это не lvalue,
[17:11.220 --> 17:14.220]  тоже это просто некоторое временное значение.
[17:14.220 --> 17:17.220]  Так, если я просто напишу g.
[17:17.220 --> 17:20.220]  g — это функция.
[17:20.220 --> 17:23.220]  Я ее не вызываю, я просто написал g.
[17:23.220 --> 17:26.220]  Я же могу так сделать.
[17:26.220 --> 17:29.220]  Что, это lvalue или не lvalue?
[17:29.220 --> 17:32.220]  Давайте уверенно кто-нибудь скажите да, или кто-то скажет нет.
[17:32.220 --> 17:35.220]  Нет, не lvalue, окей.
[17:35.220 --> 17:38.220]  Давайте кто-нибудь скажет уверенно да.
[17:39.220 --> 17:42.220]  G — это lvalue.
[17:42.220 --> 17:45.220]  G — это некоторый идентификатор, это имя, то есть, имя функции.
[17:45.220 --> 17:48.220]  Имя функции на самом деле можно считать тоже переменой,
[17:48.220 --> 17:51.220]  потому что у функции тоже есть некоторое место в памяти.
[17:51.220 --> 17:54.220]  Это когда вы обращаете к имени функции, вы на самом деле обращаетесь
[17:54.220 --> 17:57.220]  в то место в памяти, где расположена эта функция.
[17:57.220 --> 18:00.220]  Поэтому имена функции, ровно как и переменные, это тоже lvalue.
[18:00.220 --> 18:03.220]  Вы же можете взять адрес функции?
[18:03.220 --> 18:06.220]  Вы знаете такое понятие, как адрес функции?
[18:06.220 --> 18:09.220]  У функции можно взять адрес?
[18:09.220 --> 18:12.220]  Можно, поэтому это lvalue по критерию.
[18:12.220 --> 18:15.220]  Адрес f, понятное дело, тоже не является lvalue, это обсудили до этого.
[18:15.220 --> 18:18.220]  Результат вызова функции g.
[18:18.220 --> 18:21.220]  lvalue, потому что он возвращает, грубо говоря,
[18:21.220 --> 18:23.220]  int%
[18:23.220 --> 18:26.220]  Когда мы возвращаем с имперсанду, мы говорим, что мы хотим вернуть lvalue,
[18:26.220 --> 18:29.220]  то есть, какой-то объект. Поэтому результат вызова lvalue.
[18:29.220 --> 18:32.220]  Plus-plus-x обсуждали это lvalue,
[18:32.220 --> 18:35.220]  x-plus-plus — не lvalue.
[18:35.220 --> 18:38.220]  Адрес x-plus-1 — это некоторый адрес,
[18:38.220 --> 18:41.220]  и мы как раз по этому адресу и берем некоторый объект.
[18:41.220 --> 18:44.220]  Соответственно, объект, который возвращается,
[18:44.220 --> 18:47.220]  действительно имеет некоторые места в памяти, его можно как-то изменять и так далее.
[18:47.220 --> 18:50.220]  Строковый литерал lvalue.
[18:50.220 --> 18:53.220]  Что? Ой, да.
[18:53.220 --> 18:56.220]  Здесь все правильно.
[18:56.220 --> 18:59.220]  Строковый литерал тоже lvalue, а результат g-plus-g?
[18:59.220 --> 19:02.220]  Не lvalue.
[19:02.220 --> 19:05.220]  Несмотря на то, что у вас операнды lvalue,
[19:05.220 --> 19:08.220]  результат операции будет не lvalue.
[19:12.220 --> 19:15.220]  Ну и действительно все так.
[19:15.220 --> 19:18.220]  На досуге можете посмотреть, если что-то осталось непонятно.
[19:18.220 --> 19:21.220]  Хорошо.
[19:21.220 --> 19:24.220]  Ну и теперь я все это время говорил lvalue и не lvalue.
[19:24.220 --> 19:27.220]  На самом деле не lvalue — это rvalue.
[19:27.220 --> 19:30.220]  Не lvalue.
[19:30.220 --> 19:33.220]  Ну да, все так.
[19:33.220 --> 19:36.220]  Что такое rvalue?
[19:36.220 --> 19:39.220]  Можно считать неформально, что rvalue — это все то, что не относится к lvalue.
[19:39.220 --> 19:42.220]  Rvalue — это временные объекты,
[19:42.220 --> 19:45.220]  у которых нет определенного места в памяти.
[19:45.220 --> 19:48.220]  Строго говоря, это неправда, потому что rvalue в свою очередь разделяется
[19:48.220 --> 19:51.220]  на так называемый prvalue и xvalue.
[19:51.220 --> 19:54.220]  Но давайте пока считать, что мы работаем только с prvalue,
[19:54.220 --> 19:57.220]  то есть так называемые чистые временные значения,
[19:57.220 --> 20:00.220]  про xvalue мы поговорим отдельно, когда до этого дойдет время.
[20:00.220 --> 20:03.220]  Пока давайте считать, что rvalue — это временные значения,
[20:03.220 --> 20:06.220]  у которых нет места в памяти.
[20:06.220 --> 20:09.220]  Ну и соответственно, как тут написано,
[20:09.220 --> 20:12.220]  что rvalue относится все, что не относится к lvalue,
[20:12.220 --> 20:15.220]  а именно это всякие литералы, типа 5, 0, u и так далее.
[20:15.220 --> 20:18.220]  Ну кроме, естественно, строковых литералов.
[20:18.220 --> 20:21.220]  Результат функции операции,
[20:21.220 --> 20:24.220]  которая возвращает просто значения без амперсандов,
[20:24.220 --> 20:27.220]  то есть когда вы пишете this,
[20:27.220 --> 20:30.220]  он на самом деле возвращает адрес объекта,
[20:30.220 --> 20:33.220]  и this не хранится в памяти, он просто вычисляется
[20:33.220 --> 20:36.220]  непосредственно в процессе или просто подставляется на этапе компиляции.
[20:36.220 --> 20:39.220]  То есть это rvalue.
[20:39.220 --> 20:42.220]  Ну вот всякие енамы, то есть результаты енамов,
[20:42.220 --> 20:45.220]  то есть когда вы сохраняете константы в енамы и их используете,
[20:45.220 --> 20:48.220]  это на самом деле не rvalue.
[20:48.220 --> 20:51.220]  То есть, грубо говоря, когда вы пишете енам, не знаю там что, a, b,
[20:51.220 --> 20:54.220]  то есть а и b не считаются переменными.
[20:54.220 --> 20:57.220]  А и b это просто некоторые значения, которые подставляются на этапе компиляции.
[20:57.220 --> 21:00.220]  Соответственно, являются rvalue.
[21:00.220 --> 21:03.220]  Значение енамов это не lvalue, потому что не переменные.
[21:03.220 --> 21:06.220]  Ну и параметры шаблона, не являющиеся типом, это тоже не lvalue,
[21:06.220 --> 21:09.220]  потому что не переменные.
[21:09.220 --> 21:12.220]  Ну что это означает? Это означает, что когда вы пишете
[21:12.220 --> 21:15.220]  template, ну давайте там, когда вы писали array,
[21:15.220 --> 21:18.220]  class t int n, там size t,
[21:18.220 --> 21:21.220]  class array.
[21:21.220 --> 21:24.220]  Вот когда вы внутри array обращаетесь к n,
[21:24.220 --> 21:27.220]  вот это n это не переменное, соответственно, это не lvalue.
[21:27.220 --> 21:30.220]  Это просто некоторые значения, которые подставляются на этапе компиляции.
[21:30.220 --> 21:33.220]  То есть, можно считать, что компилятор вам на этапе компиляции вместо этого n
[21:33.220 --> 21:36.220]  подставит конкретное значение, и это будет просто считаться
[21:36.220 --> 21:39.220]  грубо говоря, литералом.
[21:39.220 --> 21:42.220]  То есть вот адрес вот этого n взять нельзя,
[21:42.220 --> 21:45.220]  ровно как взять адрес значения енама тоже нельзя.
[21:45.220 --> 21:48.220]  Понятно?
[21:48.220 --> 21:51.220]  Все, дальше можем идти.
[21:52.220 --> 21:55.220]  Хорошо.
[21:55.220 --> 21:58.220]  Ну вот, соответственно, коротко поговорили
[21:58.220 --> 22:01.220]  про какое-то какое-ли значение, сказали, что такое lvalue,
[22:01.220 --> 22:04.220]  что такое lvalue, ну и теперь самое время перейти
[22:04.220 --> 22:07.220]  к видам ссылок.
[22:07.220 --> 22:10.220]  Значит, поговорим про lvalue ссылки.
[22:10.220 --> 22:13.220]  Ну на самом деле про них разговор короткий, вы их все прекрасно знаете.
[22:13.220 --> 22:16.220]  Когда вы объявляете переменную с таким синтезисом,
[22:16.220 --> 22:19.220]  то есть пишете тип, а потом мерсант,
[22:19.220 --> 22:22.220]  вы объявляете ссылку.
[22:22.220 --> 22:25.220]  Что такое ссылка? Ссылкой это на самом деле просто-напросто
[22:25.220 --> 22:28.220]  некоторый псевдоним объектов памяти.
[22:28.220 --> 22:31.220]  Почему ссылки, которые вам уже давно знакомы,
[22:31.220 --> 22:34.220]  я называю lvalue ссылками?
[22:34.220 --> 22:37.220]  Потому что lvalue ссылки имеют право связываться
[22:37.220 --> 22:40.220]  только со значениями lvalue выражений.
[22:40.220 --> 22:43.220]  Ну и действительно, чтобы создать псевдоним
[22:43.220 --> 22:46.220]  какого-то объекта в памяти, вам нужно этот объект в памяти получить.
[22:46.220 --> 22:49.220]  Понятно? А в каком случае мы получаем некоторый объект в памяти?
[22:49.220 --> 22:52.220]  Только в результате вычислений некоторого lvalue выражения.
[22:52.220 --> 22:55.220]  Согласны?
[22:55.220 --> 22:58.220]  То есть x, x это переменная, переменная всегда lvalue,
[22:58.220 --> 23:01.220]  поэтому я могу создать на нее ссылку.
[23:01.220 --> 23:04.220]  То есть rx, то есть у меня есть где-то в памяти домик,
[23:04.220 --> 23:07.220]  который называется x, в нем находится 5.
[23:07.220 --> 23:10.220]  6 равно x по ссылке.
[23:10.220 --> 23:13.220]  Это означает, что я у этого адреса
[23:13.220 --> 23:16.220]  звожу некоторое альтернативное имя.
[23:16.220 --> 23:19.220]  Вот.
[23:19.220 --> 23:22.220]  Есть имя переменной первомайской 32.
[23:22.220 --> 23:25.220]  А есть двойка. Согласны, что это одинаковые названия одного и того же.
[23:25.220 --> 23:28.220]  У меня есть один адрес,
[23:28.220 --> 23:31.220]  и я могу его назвать несколькими разными способами.
[23:31.220 --> 23:34.220]  В данном случае могу сказать x, могу сказать rx.
[23:34.220 --> 23:37.220]  Вот.
[23:37.220 --> 23:40.220]  Соответственно, могу создавать константные ссылки.
[23:40.220 --> 23:43.220]  Понятно дело, это тоже самая ссылка.
[23:43.220 --> 23:46.220]  То есть я тоже ссылаюсь на ту же самую область памяти, что и x,
[23:46.220 --> 23:49.220]  но при этом по этой ссылке я не могу этот объект изменить.
[23:49.220 --> 23:52.220]  Я могу связывать ссылку с результатом функции,
[23:52.220 --> 23:55.220]  то есть с результатом выражения, который выращает lvalue.
[23:55.220 --> 23:58.220]  В данном случае f возвращает некоторый конкретный объект,
[23:58.220 --> 24:01.220]  и я на этот объект создаю ссылку.
[24:01.220 --> 24:04.220]  Все нормально.
[24:04.220 --> 24:07.220]  При этом я не могу создать ссылку на lvalue.
[24:07.220 --> 24:10.220]  То есть я не могу создавать ссылке на rvalue, в частности на 0.
[24:10.220 --> 24:13.220]  Потому что 0 нет никакого представления в памяти,
[24:13.220 --> 24:16.220]  поэтому ссылаться мне не на что.
[24:16.220 --> 24:19.220]  Поэтому lvalue ссылки тут создать нельзя.
[24:19.220 --> 24:22.220]  Аналогичный результат, например, x++ я не смог создать ссылку тоже.
[24:22.220 --> 24:25.220]  Потому что у этого объекта нет никакого представления в памяти,
[24:25.220 --> 24:28.220]  ссылаться мне не на что.
[24:28.220 --> 24:34.220]  Для LVLU ссылок это временные объекты.
[24:34.220 --> 24:38.220]  Единственное исключение для временных объектов это константные левые ссылки.
[24:38.220 --> 24:42.220]  Константные левые ссылки я могу связывать с временными объектами.
[24:42.220 --> 24:47.220]  Как это работает? Это некоторая магия, которая продлевает жизнь временного объекта.
[24:47.220 --> 24:51.220]  Грубо говоря, для этого объекта создается некоторое временное убежище,
[24:52.220 --> 24:58.220]  в котором сохраняется 11, и на этот временный шалаш и ссылается эта ссылка.
[24:58.220 --> 25:02.220]  Когда вы ставите константную ссылку на временный объект,
[25:02.220 --> 25:06.220]  для этого временного объекта создается некоторое временное хранилище, на которое мы ссылаемся.
[25:06.220 --> 25:10.220]  Как только эта константная ссылка на это временное хранилище умирает,
[25:10.220 --> 25:13.220]  то и этот шалаш тоже умирает.
[25:13.220 --> 25:18.220]  Константные левые ссылки имеют право продлевать жизнь временных объектов.
[25:18.220 --> 25:22.220]  Я думаю, со всем этим мы знакомы, просто как бы повторили.
[25:22.220 --> 25:24.220]  С этим все понятно.
[25:24.220 --> 25:27.220]  А вот теперь поговорим про R-value ссылки.
[25:27.220 --> 25:32.220]  Соответственно, если у нас есть категория значений L-value, есть категория значений R-value,
[25:32.220 --> 25:35.220]  и есть L-value ссылки, то, наверное, должны быть R-value ссылки.
[25:35.220 --> 25:40.220]  И это действительно так. В языке C++, начиная с 11 стандарта, появились R-value ссылки.
[25:40.220 --> 25:45.220]  R-value ссылки обладают той же самой семантикой, что и обычные ссылки,
[25:45.220 --> 25:50.220]  поэтому, в отличие от L-value ссылок, они имеют право связываться только с R-value объектами.
[25:50.220 --> 25:53.220]  То есть L-value ссылки связываются только с L-value объектами,
[25:53.220 --> 25:57.220]  R-value ссылки имеют право связываться только с результатом R-value выражений.
[25:57.220 --> 25:59.220]  Что это означает?
[25:59.220 --> 26:04.220]  Это означает то, что вы, например, можете создать R-value ссылку на временное значение 11.
[26:04.220 --> 26:09.220]  И работать это будет ровно так, как я рассказал про константные ссылки.
[26:09.220 --> 26:14.220]  И когда это сделано, для этого значения 11 создаться некоторое временное убежище,
[26:14.220 --> 26:20.220]  создается некоторое время место в памяти, на которое будет ссылаться RRy.
[26:20.220 --> 26:28.220]  Есть некоторое временное значение 11, и когда вы создаете на него правую ссылку,
[26:28.220 --> 26:33.220]  для него создается некоторое временное хранилище, на которое это ссылкой ссылается.
[26:33.220 --> 26:37.220]  И это хранилище живет до тех пор, пока на него ссылается эта ссылка.
[26:37.220 --> 26:43.220]  И здесь пример, что по этой ссылке вы можете это временное значение как-то изменять.
[26:43.220 --> 26:51.220]  В этой области памяти вы сохранили 11, потом можете спокойно изменить значение 11 на 12.
[26:51.220 --> 26:57.220]  Далее R-value ссылку можно связать с результатом R-value выражения.
[26:57.220 --> 27:02.220]  У вас есть функция f, которая возвращает R-value int, и вы на него можете тоже сослаться.
[27:02.220 --> 27:09.220]  Ссылаться можно на результат x++, но при этом нельзя сослаться на невременные значения.
[27:10.220 --> 27:17.220]  То есть нельзя сослаться на невременный объект с помощью временной ссылки.
[27:17.220 --> 27:22.220]  Вот так сослаться нельзя, и вот так сослаться тоже нельзя.
[27:22.220 --> 27:28.220]  И здесь вопрос. Рассмотрим последний пример. Я создаю R-value ссылку ref на RRY.
[27:28.220 --> 27:36.220]  RRY представляет из себя правую ссылку. Как вы думаете, последняя строка сработает или нет?
[27:39.220 --> 27:42.220]  Кто считает, что нет?
[27:45.220 --> 27:49.220]  Я вас запомнил. А кто считает, что да?
[27:50.220 --> 27:53.220]  А почему нет?
[27:59.220 --> 28:02.220]  А кто считал, что да? Ещё раз.
[28:03.220 --> 28:05.220]  Почему да?
[28:06.220 --> 28:09.220]  Супер. Что такое RRY?
[28:11.220 --> 28:18.220]  RRY – это переменная. Возвращаемся в самое начало. Есть одно незыблемое правило.
[28:20.220 --> 28:26.220]  Переменная – это всегда L-value. Не важно, какого типа это переменная.
[28:26.220 --> 28:30.220]  Переменная – это всегда априори L-value.
[28:30.220 --> 28:36.220]  Ну а раз RRY – это переменная, можно в неё создать левую ссылку?
[28:37.220 --> 28:39.220]  Ну да, можно.
[28:40.220 --> 28:47.220]  То есть как это работает? Вы в этой строке, в самой первой строке, создали правую ссылку на 11.
[28:47.220 --> 28:54.220]  Что это означает? Это означает, что сначала компилятор выделяет некоторую память на стеке,
[28:54.220 --> 28:59.220]  в которую будет сохранено вот это временное значение. В частности, 11.
[28:59.220 --> 29:05.220]  Всё. То есть у этого объекта, точнее не у этого объекта, а вот RRY, он ссылается на некоторую область памяти.
[29:06.220 --> 29:09.220]  Любая переменная всегда ссылается на некоторую область памяти.
[29:09.220 --> 29:15.220]  И когда вы создаёте ссылку на RRY, на самом деле RRF, вот этому RRF, уже понятно, куда ссылаться.
[29:15.220 --> 29:21.220]  То есть RRY указывает на эту область памяти. Ну значит RRF тоже будет указывать вот на эту область памяти. Всё нормально.
[29:23.220 --> 29:25.220]  Понятно?
[29:25.220 --> 29:30.220]  То есть правые ссылки, они продлевают время жизни объектов, давая им некоторое убежище,
[29:30.220 --> 29:34.220]  давая им некоторое специальное выделенное место в памяти на стеке.
[29:37.220 --> 29:39.220]  Всё понятно?
[29:41.220 --> 29:43.220]  Хорошо.
[29:45.220 --> 29:48.220]  Да, соответственно, ответ здесь.
[29:49.220 --> 29:52.220]  Ну и смотрите, может возникнуть такой вопрос.
[29:52.220 --> 29:56.220]  Если мы посмотрим на предыдущие примеры, то что мы по сути делали?
[29:56.220 --> 30:05.220]  Мы писали int &&rx, писали 11. int &&rx равно f.
[30:06.220 --> 30:11.220]  И что мы говорили? Мы говорили, что мы временные значения присваиваем R-value ссылкам,
[30:11.220 --> 30:16.220]  и эти R-value ссылки создают некоторую область памяти, в которой эти значения хранятся.
[30:16.220 --> 30:21.220]  И тут может возникнуть естественный вопрос. А чем это отличается от объявлений обычно переменной?
[30:21.220 --> 30:25.220]  Согласитесь, что когда вы просто объявляете переменную int x,
[30:25.220 --> 30:28.220]  по большому счёту происходит то же самое.
[30:28.220 --> 30:32.220]  Заводится некоторая область памяти, которая называется x, и в нём сохраняется 11.
[30:32.220 --> 30:36.220]  И вы тоже самое 11 можете в этой области памяти изменять и так далее.
[30:36.220 --> 30:40.220]  Возникает естественный вопрос, для чего тогда вообще нужны R-value ссылки?
[30:40.220 --> 30:46.220]  Ответ такой. В этом контексте, во всех примерах, R-value ссылки не особо не нужны.
[30:46.220 --> 30:48.220]  И они так не используются.
[30:48.220 --> 30:52.220]  А используются они для решения другой проблемы.
[30:52.220 --> 30:54.220]  Давайте к ней перейдём.
[30:54.220 --> 31:02.220]  На самом деле оказывается, что по типу ссылки L-value или R-value можно делать перегрузку.
[31:05.220 --> 31:07.220]  Понятно эта фраза?
[31:07.220 --> 31:09.220]  По типу ссылки можно делать перегрузку.
[31:09.220 --> 31:14.220]  То есть в зависимости от того, что вы передали, у вас может быть вызана одна функция или другая функция.
[31:14.220 --> 31:16.220]  Давайте какой-нибудь жизненный пример.
[31:16.220 --> 31:20.220]  Практические жизни, практические стандартные библиотеки выглядят так.
[31:20.220 --> 31:24.220]  Представьте себе, что мы хотим написать функцию addressOf.
[31:24.220 --> 31:32.220]  Хотим написать функцию addressOf, которая возвращает адрес некоторого объекта.
[31:32.220 --> 31:34.220]  Сразу скажу, что здесь неправильная реализация.
[31:34.220 --> 31:42.220]  В стандартной библиотеке есть специальная функция std addressOf,
[31:42.220 --> 31:44.220]  которая возвращает адрес объекта x.
[31:44.220 --> 31:50.220]  Вы можете спросить, зачем нам нужна функция addressOf, если можно просто взять амперсанд от x.
[31:50.220 --> 31:52.220]  Ответ такой.
[31:52.220 --> 31:54.220]  Амперсанд может быть перегружен.
[31:54.220 --> 31:56.220]  Амперсанд можно перегружать.
[31:56.220 --> 32:02.220]  Если вы для своего класса перегрузили операцию амперсанды,
[32:02.220 --> 32:05.220]  то уже амперсанд для вашего объекта не будет возвращать вам адрес.
[32:05.220 --> 32:08.220]  Единственный способ получить адрес, это вызвать функцию addressOf.
[32:08.220 --> 32:12.220]  Он выполняет некоторую магию на низком уровне, которая возвращает вам адрес.
[32:12.220 --> 32:14.220]  Мы сейчас не будем в это углубляться.
[32:14.220 --> 32:18.220]  Давайте просто рассмотрим примитивную реализацию адресов.
[32:18.220 --> 32:20.220]  Вы хотите просто завести функцию addressOf,
[32:20.220 --> 32:24.220]  которая принимает некоторый объект и возвращает его адрес.
[32:24.220 --> 32:30.220]  Мы принимаем константный объект и возвращаем указатель на константу.
[32:30.220 --> 32:32.220]  Вот таким образом.
[32:32.220 --> 32:35.220]  Я утверждаю, что у этой реализации есть большая проблема.
[32:35.220 --> 32:37.220]  Какая? Давайте по порядку.
[32:37.220 --> 32:41.220]  У меня есть переменная x, и у меня есть динамический массив array.
[32:41.220 --> 32:43.220]  Что я делаю?
[32:43.220 --> 32:46.220]  Когда я прошу addressOf x, все работает нормально.
[32:46.220 --> 32:50.220]  То есть я передаю x, и у этого x возвращается адрес этого x.
[32:50.220 --> 32:52.220]  Когда я делаю plus-plus-x, то же самое.
[32:52.220 --> 32:57.220]  Plus-plus-x возвращает мне lvalue, то есть ссылку на x, то есть сам объект x.
[32:57.220 --> 32:59.220]  И я опять же у этого x беру адрес.
[32:59.220 --> 33:01.220]  То же все нормально.
[33:01.220 --> 33:04.220]  Если я беру адрес от array 5, то тоже все нормально.
[33:04.220 --> 33:08.220]  Всем очевидно, что array от 5 возвращает вам lvalue.
[33:08.220 --> 33:14.220]  Потому что array от 5 дословно переводится как array plus 5.
[33:14.220 --> 33:16.220]  То есть разыменование array plus 5.
[33:16.220 --> 33:20.220]  То есть мы взяли объект, который расположен по адресу array plus 5.
[33:20.220 --> 33:24.220]  У этого объекта, естественно, есть адрес, и это array plus 5.
[33:24.220 --> 33:27.220]  А вот теперь вопрос в последней строке.
[33:27.220 --> 33:30.220]  Как вы думаете, что случится в последней строке?
[33:30.220 --> 33:33.220]  Корректно она отработает или что-то пойдет не так?
[33:43.220 --> 33:45.220]  А что пойдет не так?
[33:45.220 --> 33:48.220]  Будет ли ошибка компиляции здесь?
[33:48.220 --> 33:50.220]  Будет ли тут ошибка компиляции?
[33:50.220 --> 33:53.220]  На каком этапе возникнут проблемы?
[33:53.220 --> 33:56.220]  Сначала вы написали вот такой код.
[33:56.220 --> 34:00.220]  И думаете, ну сейчас отправлю в тестирующую систему.
[34:00.220 --> 34:03.220]  Нажимаете собрать программу.
[34:03.220 --> 34:06.220]  Вот у вас происходит компиляция.
[34:09.220 --> 34:12.220]  В момент компиляции все будет окей.
[34:12.220 --> 34:15.220]  Теперь вы решили запускать вашу программу.
[34:15.220 --> 34:18.220]  Что пойдет не так? Или все будет нормально?
[34:18.220 --> 34:22.220]  В данном конкретном случае все будет нормально на самом деле.
[34:22.220 --> 34:25.220]  Ну как это работает? Давайте по порядку.
[34:25.220 --> 34:27.220]  Вы взяли адресов 10.
[34:27.220 --> 34:31.220]  Это 10 сохранилось в константную ссылку value.
[34:31.220 --> 34:35.220]  Константные ссылки могут связываться со временными объектами.
[34:35.220 --> 34:37.220]  Это мы говорили.
[34:37.220 --> 34:40.220]  Здесь внутри этой функции создается некоторый шалаш,
[34:40.220 --> 34:43.220]  в котором сохранится значение 10.
[34:43.220 --> 34:46.220]  Дальше. Вы берете адрес этого шалаша.
[34:46.220 --> 34:49.220]  Не знаю, там улица Пушкина, дом Кулатушкина.
[34:49.220 --> 34:52.220]  Вы берете этот адрес.
[34:52.220 --> 34:55.220]  И этот адрес вам возвращается.
[34:55.220 --> 34:58.220]  И вы его здесь, представь себе, куда-то сохранили.
[34:58.220 --> 35:01.220]  Что вы можете делать с этим адресом?
[35:01.220 --> 35:05.220]  Что из себя представляет вот этот адрес, который вам вернулся?
[35:05.220 --> 35:08.220]  Что вы можете сделать с этим адресом?
[35:08.220 --> 35:12.220]  Что из себя представляет вот этот адрес, который вам вернулся?
[35:14.220 --> 35:17.220]  Можно ли его разыменовать и получить 10?
[35:21.220 --> 35:24.220]  Был у вас вообще разговор когда-нибудь про провисшие ссылки,
[35:24.220 --> 35:27.220]  про провисшие указатели, вот это вот все?
[35:27.220 --> 35:30.220]  Кто-то говорит было, кто-то говорит не было.
[35:30.220 --> 35:33.220]  Ну окей, в общем, это классическая проблема провисшего указателя
[35:33.220 --> 35:36.220]  или провисшей ссылки.
[35:36.220 --> 35:39.220]  Давайте не будем подробно на этом остановиться.
[35:39.220 --> 35:42.220]  В общем, главная мораль всего этого,
[35:42.220 --> 35:45.220]  нельзя возвращать ссылки на локальные объекты.
[35:45.220 --> 35:48.220]  И нельзя возвращать адрес локальных объектов. Почему?
[35:48.220 --> 35:51.220]  Потому что когда вы выходите из этой функции,
[35:51.220 --> 35:54.220]  когда вычисление этой функции завершается,
[35:54.220 --> 35:57.220]  что происходит?
[35:57.220 --> 36:00.220]  Все переменные внутри этой функции уничтожаются.
[36:00.220 --> 36:03.220]  Когда вы выходите из этой функции,
[36:03.220 --> 36:06.220]  то эти объекты, в частности объект Value, они будут уничтожены.
[36:06.220 --> 36:09.220]  Стэк просто затрет это все.
[36:09.220 --> 36:12.220]  Указатель стэка сместится ниже,
[36:12.220 --> 36:15.220]  и этими объектами уже нельзя пользоваться,
[36:15.220 --> 36:18.220]  потому что они, грубо говоря, не принадлежат вашей программе.
[36:18.220 --> 36:21.220]  И поэтому, когда вы попытаетесь воспользоваться вот здесь
[36:21.220 --> 36:24.220]  результатом выражения адресов,
[36:24.220 --> 36:27.220]  адрес, куда будет вести результат этого выражения,
[36:27.220 --> 36:30.220]  он будет уже вести в некоторую область памяти,
[36:30.220 --> 36:33.220]  и в лучшем случае вы получите
[36:33.220 --> 36:36.220]  какой-нибудь StackBufferOverflow ошибку,
[36:36.220 --> 36:39.220]  которая говорит о том, что вы лезете в память,
[36:39.220 --> 36:42.220]  которая вам в данном момент не принадлежит.
[36:42.220 --> 36:45.220]  А в худшем случае получите undefinedBehaviour.
[36:48.220 --> 36:51.220]  Возникла проблема.
[36:51.220 --> 36:54.220]  Возникла проблема с тем, что мы предполагаем,
[36:54.220 --> 36:57.220]  что адресов off будет работать всегда корректно,
[36:57.220 --> 37:00.220]  и у всех этих адресов вроде как завершается корректно,
[37:00.220 --> 37:03.220]  но при этом этим результатом пользоваться нельзя.
[37:03.220 --> 37:06.220]  Наверное, хотелось бы нам запретить использовать адрес off
[37:06.220 --> 37:09.220]  от временных объектов. Согласитесь, это логично.
[37:09.220 --> 37:12.220]  Согласитесь, нелогично брать адрес у временных объектов.
[37:12.220 --> 37:15.220]  И нам хочется вот такое запретить.
[37:18.220 --> 37:21.220]  Как такое запретить?
[37:21.220 --> 37:24.220]  На самом деле очень просто.
[37:24.220 --> 37:27.220]  Все поняли, в чем проблема с адресом off.
[37:27.220 --> 37:30.220]  В той реализации адресов, которые мы написали,
[37:30.220 --> 37:33.220]  мы можем брать адреса временных объектов.
[37:33.220 --> 37:36.220]  Точнее, мы берем не адрес временного объекта здесь,
[37:36.220 --> 37:39.220]  а мы берем адрес локального объекта,
[37:39.220 --> 37:42.220]  который по выходу из функции будет уничтожен.
[37:42.220 --> 37:45.220]  То есть никакой пользы адресов здесь нам не принесет.
[37:45.220 --> 37:48.220]  Еще одна проблема более сложная.
[37:48.220 --> 37:51.220]  Смотрите, у меня есть класс A.
[37:51.220 --> 37:54.220]  И у него в качестве поля выступает
[37:54.220 --> 37:57.220]  константная ссылка на int.
[37:57.220 --> 38:00.220]  Просто некоторый класс A, который сохраняет ссылку
[38:00.220 --> 38:03.220]  на какую-то внешнюю переменную.
[38:03.220 --> 38:06.220]  Естественно, мне как любой другой ссылочной боли
[38:06.220 --> 38:09.220]  нужно инициализировать в конструкторе, а именно
[38:09.220 --> 38:12.220]  в списке инициализации. Что я делаю?
[38:12.220 --> 38:15.220]  Я в конструкторе принимаю константную ссылку на объект,
[38:15.220 --> 38:18.220]  на который мне нужно сохранить ссылку, и в списке инициализации
[38:18.220 --> 38:21.220]  Интерфейс этого класса такой. Я могу в любой момент
[38:21.220 --> 38:24.220]  получить ссылку на объект, и в любой момент могу получить указатель
[38:24.220 --> 38:27.220]  на объект. Вот такой простой класс.
[38:27.220 --> 38:30.220]  То есть я сохраняю ссылку на объект, и в любой момент
[38:30.220 --> 38:33.220]  могу с помощью getref получить на него ссылку,
[38:33.220 --> 38:36.220]  и getptr получить на него указатель.
[38:36.220 --> 38:39.220]  Ну и как это работает? Если я создаю
[38:39.220 --> 38:42.220]  этот объект A с помощью XA, то все нормально.
[38:42.220 --> 38:45.220]  У меня внутри вот этого класса A сохраняется
[38:45.220 --> 38:48.220]  ссылка на X. Все отлично.
[38:48.220 --> 38:51.220]  Если я передаю туда array от 5, то тоже все нормально.
[38:51.220 --> 38:54.220]  У меня туда сохраняется ссылка на 5-й элемент array,
[38:54.220 --> 38:57.220]  5-й элемент массива. А что произойдет,
[38:57.220 --> 39:00.220]  если я передам туда 0?
[39:00.220 --> 39:03.220]  Что произойдет, если я вызову
[39:03.220 --> 39:06.220]  если я вызову c.getref?
[39:11.220 --> 39:14.220]  Что пойдет не так?
[39:15.220 --> 39:18.220]  Ну опять, практически то же самое.
[39:18.220 --> 39:21.220]  Смотрите, что у меня тут происходит по порядку.
[39:21.220 --> 39:24.220]  Value
[39:24.220 --> 39:27.220]  создает некоторое временное убежище для 0.
[39:27.220 --> 39:30.220]  Потому что константные ссылки могут
[39:30.220 --> 39:33.220]  связываться со временными объектами.
[39:33.220 --> 39:36.220]  Соответственно, будет константная ссылка связываться со временным объектом,
[39:36.220 --> 39:39.220]  предоставляя ему некоторую временную ячейку памяти.
[39:39.220 --> 39:42.220]  Дальше у меня
[39:42.220 --> 39:45.220]  у меня выполняется cref в скобочках value.
[39:45.220 --> 39:48.220]  То есть я создаю ссылку cref на value.
[39:48.220 --> 39:51.220]  В частности, я пишу cref.
[39:51.220 --> 39:54.220]  И этот cref указывает на то же место, что и 0.
[39:54.220 --> 39:57.220]  А что происходит дальше на третьем шаге?
[40:04.220 --> 40:07.220]  Ну что происходит, когда у меня завершается конструктор?
[40:07.220 --> 40:10.220]  У меня уничтожается value, согласны?
[40:10.220 --> 40:13.220]  Value – это локальная переменная конструктора.
[40:13.220 --> 40:16.220]  После того, как я вышел из конструктора, у меня уничтожается value.
[40:16.220 --> 40:19.220]  А так как внутри value хранилась вот эта переменная,
[40:19.220 --> 40:22.220]  вот этот объект 0, то
[40:22.220 --> 40:25.220]  все это целиком тоже уничтожается.
[40:25.220 --> 40:28.220]  И куда мне теперь ссылается cref?
[40:28.220 --> 40:31.220]  Cref теперь у меня ссылается на удаленную область памяти.
[40:31.220 --> 40:34.220]  То есть cref теперь у меня ссылается на область памяти,
[40:34.220 --> 40:37.220]  которая моей программе сейчас не принадлежит.
[40:37.220 --> 40:40.220]  Окей?
[40:40.220 --> 40:43.220]  Поэтому в лучшем случае вы получите, вот здесь при попытке вызова getref,
[40:43.220 --> 40:46.220]  вы получите какую-нибудь ошибку типа stack-buffer overflow,
[40:46.220 --> 40:49.220]  а в худшем случае компилятор это просто пропустит,
[40:49.220 --> 40:52.220]  и вы будете постоянно работать с областью памяти, которая вам не принадлежит.
[40:52.220 --> 40:55.220]  А это undefined behavior, то есть в вашей программе может произойти что угодно.
[40:55.220 --> 40:58.220]  То есть непредсказуемое поведение,
[40:58.220 --> 41:01.220]  которое очень сложно отлавливать.
[41:01.220 --> 41:04.220]  Понятна проблема?
[41:04.220 --> 41:07.220]  Короче говоря, главная проблема,
[41:07.220 --> 41:10.220]  давайте с этим слайдером разберемся.
[41:10.220 --> 41:13.220]  Здесь главная проблема состоит в том,
[41:13.220 --> 41:16.220]  что
[41:16.220 --> 41:19.220]  здесь наш конструктор,
[41:19.220 --> 41:22.220]  ровно как и адресов,
[41:22.220 --> 41:25.220]  не умеет отличать временные объекты от невременных объектов.
[41:25.220 --> 41:28.220]  То есть когда мы передаём невременные объекты,
[41:28.220 --> 41:31.220]  у нас всё ок.
[41:31.220 --> 41:37.620]  временный объект, у нас резко начинает все ломаться. И в этом проблема. И вот здесь нам как раз
[41:37.620 --> 41:46.620]  таки поможет разделение, то есть нам поможет, собственно, короче, нам надо как-то научиться,
[41:46.620 --> 41:52.020]  научить наши функции, ну в частности конструктор того класса A и функцию адресов, нужно как-то
[41:52.020 --> 41:58.060]  их научить отличать l-value объекта от r-value объекта. А какой механизм в языке C++, который мы
[41:58.060 --> 42:01.980]  недавно изучили, какой механизм позволяет нам отличать l-value объекты от r-value объектов?
[42:09.980 --> 42:15.220]  r-value ссылки. То есть у нас есть l-value ссылки, есть r-value ссылки. И вот l-value и r-value ссылки,
[42:15.220 --> 42:20.460]  они умеют отличать временные объекты от невременных объектов. Окей? И вот как раз таки решение
[42:20.460 --> 42:24.780]  состоит в этом. Давайте сделаем следующую вещь. Давайте помимо обычной функции адресов,
[42:24.780 --> 42:33.820]  которые мы до этого написали, напишем перегрузку. Напишем перегрузку, которая будет принимать объекты
[42:33.820 --> 42:43.420]  по r-value ссылке. То есть напишем const t и t, ну и объявим ее удаленной. Для чего? Ну потому что
[42:43.420 --> 42:49.260]  мы понимаем, что не имеет смысла вызывать адресов для временных объектов. Окей? И теперь внезапно
[42:49.260 --> 42:53.900]  все будет работать так, как мы хотим. А как мы хотим? Мы хотим, чтобы когда мы просили адресов от
[42:53.900 --> 42:58.700]  x, нам возвращался адрес x. Мы хотим, чтобы когда мы просили адресов от r и от 5, нам возвращался
[42:58.700 --> 43:05.180]  адрес пятого элемента массива. И мы хотим, чтобы когда мы вызываем адресов временного объекта,
[43:05.180 --> 43:11.020]  мы хотим, чтобы в этот момент у нас ошибка возникала на этапе компиляции, а не потенциальная
[43:11.020 --> 43:17.580]  ошибка на этапе выполнения. Ошибка на этапе компиляции — это благо, понятно? Потому что
[43:17.580 --> 43:22.420]  ошибка на этапе компиляции вам не дает написать некорректный код. И в данном случае ровно этого мы
[43:22.420 --> 43:28.380]  и добились. Когда мы вызываем адресов от 10, что происходит? У нас происходит выбор перегрузки.
[43:28.380 --> 43:33.580]  То есть компилятор видит, что есть функция адресов, которая может принимать константную левую ссылку. И
[43:33.580 --> 43:39.620]  в принципе туда десятку можно засунуть. Но при этом в тот же момент у меня существует функция,
[43:39.620 --> 43:43.460]  которая принимает правую ссылку. И правая ссылка для временных объектов, естественно, подходит лучше,
[43:43.460 --> 43:49.460]  чем левая. Понятно? И поэтому именно вот эта функция в последней строке будет выигрывать перегрузку.
[43:49.460 --> 43:59.460]  Всё понятно? То есть мы перегрузили нашу функцию адресов по типу ссылки. То есть теперь все lvalue
[43:59.460 --> 44:04.260]  объекты будут идти в первую версию адресов, все временные объекты будут идти во вторую версию
[44:04.260 --> 44:12.220]  адресов. Круто? Ну и то же самое для класса A. То есть мы теперь хотим, чтобы класс A работал,
[44:12.220 --> 44:19.540]  в смысле конструктор для класса A работал только для lvalue объектов, то есть только для lvalue int'ов.
[44:19.540 --> 44:25.020]  А для не lvalue int'ов мы хотим, чтобы он не работал, чтобы возникал ошибка комбиляции. Добиваемся мы
[44:25.020 --> 44:33.300]  этого ровно тем же самым. Значит, невременные объекты будут попадать в первую версию функции или
[44:33.300 --> 44:37.900]  конструктора, а временные объекты будут попадать во вторую версию конструктора. Но сейчас, когда вы
[44:37.900 --> 44:42.140]  будете вызывать AC от нуля, что будет происходить? Комбилятор будет выбирать между двумя
[44:42.140 --> 44:47.980]  перегрузками, то есть он будет думать, куда мне послать вот этот ноль? Функцию const int'& или
[44:47.980 --> 44:55.100]  функцию const int'&. Понятное дело, что и та, и та подходят, но лучше подходит конструктор,
[44:55.100 --> 45:01.540]  который принимает двойной % потому что ноль это rvalue. rvalue для двойной ссылки подходит лучше. Понятно?
[45:01.540 --> 45:13.900]  То есть тут есть, грубо говоря, точное соответствие, если хотите. Все понятно? Отлично. Вот, то есть мы
[45:13.900 --> 45:18.380]  разобрались с категориями значений lvalue, rvalue, разобрались тем, что существуют lvalue ссылки,
[45:18.380 --> 45:21.860]  которые связываются только с lvalue, разобрались, что есть rvalue ссылки, которые связываются только
[45:21.860 --> 45:27.060]  с rvalue и наконец-то поняли, для чего они нужны. Для чего нужны lvalue, для чего нужно отличие
[45:27.060 --> 45:31.380]  lvalue ссылок от rvalue ссылок. По ним можно делать перегрузку. В зависимости от этого у нас будет
[45:31.380 --> 45:34.940]  вызываться та или иная версия функции, в зависимости от того, что вы передали, временный объект или не
[45:34.940 --> 45:40.380]  временный объект. Вот, да, соответственно по виду ссылки можно перегружать функции,
[45:40.380 --> 45:44.140]  результат lvalue выражения будет вызывать версию слева ссылки, а результат rvalue выражения будет вызывать
[45:44.140 --> 45:50.660]  функцию с правой. Ну и давайте короткие упражнения, короткие примеры, давайте для каждой строки
[45:50.660 --> 45:57.140]  пробуем указать, какая версия функции будет вызываться, первая или вторая. Давайте f от x. Ну первое,
[45:57.140 --> 46:02.860]  понятное дело, x это lvalue, поэтому будет вызываться функция f, которая принимает обычную левую ссылку. f от 0.
[46:02.860 --> 46:09.140]  Вторая, да, потому что 0 вообще никак не может быть связан с lvalue ссылкой, ну с обычной,
[46:09.140 --> 46:15.140]  без константы, поэтому, естественно, 0 идет во вторую версию. Так, f от g. Вторая, да, результат
[46:15.140 --> 46:20.500]  выполнения g это rvalue, поэтому результат выполнения g пойдет во вторую версию функции f. Так, ну и
[46:20.500 --> 46:28.900]  последние две строки? Первая и вторая соответственно, да, отлично, все понятно, окей, ну да.
[46:28.900 --> 46:39.940]  Так, ну смотрите, мы сделали разницу, я рассказал, в чем разница между lvalue и rvalue, мы поняли,
[46:39.940 --> 46:45.100]  что существуют левые ссылки и правые ссылки, мы поняли, что по виду ссылки можно перегружать,
[46:45.100 --> 46:51.420]  и, на самом деле, вот особо, не знаю, под левым слушателем может показаться, что, ну окей, вот то,
[46:51.420 --> 46:56.020]  что мы сделали, ну как бы, ну это какое-то слабое применение, да, не особо убеждает, что это на
[46:56.020 --> 47:00.700]  самом деле действительно что-то стоящее, ну вряд ли там кто-то будет активно использовать функцию
[47:00.700 --> 47:04.020]  адресов, вряд ли кто-то активно будет, не знаю, сохранить какое-то ссылочное поле в класс, и так далее.
[47:04.020 --> 47:09.780]  Вот сейчас мы перейдем к настоящему применению lvalue и rvalue ссылок, для чего они на самом деле нужны,
[47:09.780 --> 47:18.540]  для чего они вам нужны конкретно, вот. И это, на самом деле, конструкторы перемещения и
[47:18.540 --> 47:24.820]  перемещающие присваивания. То, про что мы говорили на лекции про конструкторы, но говорили, что поговорим
[47:24.820 --> 47:30.740]  когда-нибудь, и вот сейчас это когда-нибудь. Значит, смотрите, давайте просто вспомним, что у нас есть,
[47:30.740 --> 47:35.740]  что мы писали класс stack, ну для класса stack мы говорили, что существует правило трех, которое нам
[47:35.740 --> 47:39.380]  говорит, что если мы управляем как-то ресурсами, ну или там в принципе нам потребовалось написать
[47:39.380 --> 47:44.900]  деструктор или копирование, то нам необходимо написать сразу все три метода. То есть это деструктор,
[47:44.900 --> 47:48.900]  конструктор копирования и копирующее присваивание. Но, соответственно, здесь напоминание, как мы это все
[47:48.900 --> 47:57.180]  реализовывали. То есть принимаем другой stack, значит копируем, создаваем новый буфер, копируем его сайсы,
[47:57.180 --> 48:01.180]  копируем содержимое одного буфера в другой буфер. Значит, в присваивании все то же самое, но только
[48:01.180 --> 48:06.580]  перед этим проверяем на самом присваивании и удаляем старый буфер. То есть тут это все рассматриваем,
[48:06.580 --> 48:14.420]  никаких проблем нет. Вот я утверждаю, что вот этих копирующих версий нам недостаточно, чтобы написать
[48:14.420 --> 48:23.100]  эффективные программы. Почему? Смотрите, допустим, я создаю stack, у меня есть некоторый stack, я его как-то
[48:23.100 --> 48:29.700]  заполняю. Ну вот здесь вот, не знаю, stack.push, единицы, ну и так далее. В общем, как-то работаю со stack.
[48:29.700 --> 48:36.220]  Ну и теперь в какой-то момент у меня возникла потребность создать копию stack. Вот здесь я
[48:36.220 --> 48:42.620]  создаю копию stack, то есть создаю lcopy и говорю, что этот lcopy должен являться копией stack. За сколько
[48:42.620 --> 48:48.580]  это все работает? За линию? Можем ли как-то сделать это быстрее? Ну вряд ли. То есть если вам нужно
[48:48.580 --> 48:52.260]  скопировать один stack в другой, то, наверное, вам все-таки нужно скопировать все содержимое. А копировать
[48:52.260 --> 48:58.700]  все содержимое — это все-таки линейное время. Поэтому тут все нормально. Мы соглашаемся на то, что мы
[48:58.700 --> 49:02.820]  копируем все-таки за линейное время. Потому что иного способа скопировать один объект в другой у нас нет.
[49:02.820 --> 49:09.300]  Ну скопировать один массив в другой у нас нет. Согласны? Хорошо. А теперь представьте другой пример
[49:09.300 --> 49:15.700]  использования. Что если я говорю, что я хочу скопировать stack из некоторого временного объекта?
[49:15.700 --> 49:20.860]  Ну, стараюсь скажу, что здесь на самом деле все будет окей, здесь все будет работать достаточно быстро по причинам,
[49:20.860 --> 49:26.580]  которые мы будем обсуждать, видимо, в следующий раз. Но в старых плюсах вот это все работало долго. И работало
[49:26.580 --> 49:33.060]  долго почему? Смотрите, что здесь происходит в этой строке. Я создаю некоторый временный stack в правой
[49:33.060 --> 49:42.140]  части. В правой части я создаю stack из ста элементов. Согласны? Здесь stack размера 100. Это какой-то
[49:42.140 --> 49:50.860]  временный stack. И теперь я создаю rcopy с помощью копирования того временного stack. То есть что я
[49:50.860 --> 49:59.860]  делаю? Тоже создаю тут свой буфер. И по элементу накопирую временный stack сюда. И что происходит потом?
[49:59.860 --> 50:09.860]  Я уничтожаю временный stack. Не кажется ли вам, что тут есть немного совсем неэффективности?
[50:09.860 --> 50:20.980]  Вряд ли вы когда списываете... Вряд ли когда кто-то списывает задание, он пишет сначала полностью
[50:20.980 --> 50:26.260]  задание, а потом у себя же берет и вот списывает в другую тетрадь. Вряд ли происходит так на
[50:26.260 --> 50:33.620]  практике. Чтобы что-то списать, чтобы скопировать что-то временное, то есть если у вас есть что-то
[50:33.620 --> 50:41.980]  ненужное, то вряд ли вам нужно полностью это все копировать. Согласны? Здесь происходит нечто странное.
[50:41.980 --> 50:48.180]  Вы хотите создать stack и при этом создаете временный stack. Потом из этого временного stack копируете,
[50:48.180 --> 50:53.060]  а потом вот этот вот временный stack, который вы создали только для того, чтобы оттуда что-то
[50:53.060 --> 51:00.500]  скопировать, его уничтожаете. Какой-то бред. То же самое касается присваивания. То есть если вы
[51:00.500 --> 51:07.700]  копируете один stack в другой, то быстрее чем за линию априори это сделать нельзя.
[51:07.700 --> 51:12.540]  Ну по понятным причинам. То есть если у вас есть объект, который нельзя портить и вы хотите его
[51:12.540 --> 51:17.780]  скопировать, то нужно скопировать. А представьте себе, что вы хотите присвоить временный stack
[51:17.780 --> 51:24.700]  себе. Что здесь происходит в последней строке? Снова то же самое. Вы создаете временный stack,
[51:24.700 --> 51:32.580]  у вас есть какой-то другой stack rcopy. Что происходит? Вы уничтожаете свой stack,
[51:32.580 --> 51:37.580]  потом берете и копируете временный stack к себе и уничтожаете временный stack.
[51:37.580 --> 51:44.360]  Ну вопрос, а нафига мы создавали временный stack? Неужели нельзя просто взять и вот все
[51:44.360 --> 51:48.020]  то содержимое временного stack забрать себе? Согласитесь, это было бы эффективней.
[51:48.020 --> 51:57.140]  Проблема понятна? Понятно почему вот эти строки на самом деле работают, грубо говоря,
[51:57.140 --> 52:04.060]  за 2n, а не за один проход. Потому что вот в этих помеченных строках мы сначала создаем временный
[52:04.060 --> 52:10.340]  stack, потом из временного stack копируем. То есть сначала создаем stack, а потом из него же копируем.
[52:10.340 --> 52:17.140]  Это странно. Но это именно то, что происходит у нас в программах в данный момент. Вот вы писали
[52:17.380 --> 52:22.020]  стрингу, вы писали свой класс строки, и вот ровно это у вас и происходит, когда вы пишете примерно
[52:22.020 --> 52:32.180]  вот такой код. Ерунда. Соответственно, здесь мы приходим к следующему выводу, что вот эти
[52:32.180 --> 52:37.260]  конструкторы копирования, которые мы написали и копирующие присваивания, они работают неэффективно
[52:37.260 --> 52:44.500]  в случае, если мы присваиваем или копируем из временных объектов. Согласны? Поэтому возникает
[52:44.500 --> 52:50.340]  естественная идея. А давайте просто возьмем и напишем специальные версии конструктора и
[52:50.340 --> 52:56.420]  присваивания, которые принимают временный stack. Ну как мы это делаем? Мы просто говорим, что в качестве
[52:56.420 --> 53:02.100]  аргумента конструктора мы будем принимать stack по правой ссылке, и в качестве аргумента присваивания
[53:02.100 --> 53:06.460]  тоже будем принимать stack по правой ссылке. Соответственно, в этом случае мы должны делать что-то
[53:06.460 --> 53:12.780]  иное. Теперь вопрос в зал. А что мы должны сделать со временным stack, чтобы это было эффективно?
[53:12.780 --> 53:17.260]  А что такое переместить?
[53:17.260 --> 53:30.340]  Нет, здесь у нас нет возможности обойтись без временного. Если мы приняли, смотрите, у нас есть
[53:30.340 --> 53:35.620]  аргумент, и мы знаем, что в нем априори лежит временный объект. То есть мы не можем обойтись
[53:35.620 --> 53:40.420]  без создания временного объекта. То есть здесь мы предполагаем, что в этом конструкторе и перемещении
[53:40.420 --> 53:43.980]  нам дали временный объект. Что значит временный объект? Это значит, что этот объект никому не будет
[53:43.980 --> 54:01.860]  нужен больше. Что в этом случае мы должны сделать? Сделать его нужным. Давайте так. Экологичное
[54:01.860 --> 54:11.460]  потребление или recycling и так далее. Если у вас есть что-то, что уже не нужно, что уже точно никому не
[54:11.460 --> 54:17.860]  понадобится. Естественно, вы хотите его как-то переиспользовать, использовать повторно. Говорят,
[54:17.860 --> 54:24.900]  что это скоро уже всем пригодится. Понятно, да? Если у вас есть что-то не нужное, никому оно не
[54:24.900 --> 54:30.140]  нужно. Вот есть что-то, оно не вам, не вам, не вам, не вам не нужно. И я хочу это все скопировать себе.
[54:30.140 --> 54:36.380]  Что мне нужно сделать, если оно никому не нужно? Просто забрать себе, естественно. Сцарапнуть,
[54:36.380 --> 54:45.100]  то есть как угодно называйте. Смотрите, содержимое вот этого стека, оно никому не будет нужно. Об этом
[54:45.100 --> 54:49.380]  говорит R-value ссылка. Если я попал в этот конструктор, то это означает, что я связался
[54:49.380 --> 54:53.700]  с временным объектом. Что такое временный объект? Временный объект, который создался здесь и сейчас,
[54:53.700 --> 54:58.820]  и больше никому не будет нужен. Ровно как и здесь. Смотрите, я здесь создал стек от 100 и здесь стек
[54:58.820 --> 55:02.940]  от 100. И помимо вот этой строки, помимо вот этого выражения, он нигде больше использоваться не
[55:02.940 --> 55:09.740]  будет. Поэтому я могу спокойно взять и забрать его содержимое. Понятно? А что значит забрать
[55:09.740 --> 55:27.460]  содержимое стека? Смотрите, у меня есть other, у меня есть мой стек. Что значит забрать
[55:27.460 --> 55:35.940]  содержимое стека? Давайте так. Что хранит стек? Давайте по порядку. Стек хранит внутри себя
[55:35.940 --> 55:54.180]  условно указатель на буфер и хранит size. То есть то есть. У меня есть временный стек other,
[55:54.180 --> 56:02.060]  в котором хранится указатель на буфер и в котором хранится size, допустим, 100. И вот у меня есть
[56:02.060 --> 56:12.620]  мой стек, который пока ничем не заполнен. Научите меня забирать содержимое другого объекта. Что
[56:12.620 --> 56:18.740]  мне нужно сделать? Отлично. Смотрите, если вот этот стек other никому не будет нужен, то значит
[56:18.740 --> 56:23.940]  вот этот буфер тоже не будет никому нужен. Давайте я вопрос заберу себе. Возьму и буду указывать,
[56:23.940 --> 56:30.580]  вот на этот буфер. То есть я не буду создавать свой, а просто заберу чужой, окей? Так, а с size
[56:30.580 --> 56:41.420]  что мне сделать? Ну а с size я просто копирую. То есть это просто 4 байта. Окей? Все. Ну почти все.
[56:41.420 --> 56:46.300]  Еще нужно вот этот вот указатель сказать, что нужно все-таки поуважительный савер, нужно ему
[56:46.300 --> 56:52.900]  сказать, что мы все-таки у него что-то забрали и сказать, что у него no ptr. То есть не просто без
[56:52.900 --> 57:00.500]  предупреждений. Нужно еще other предупредить, что у тебя мы что-то забрали, окей? Об этом мы поговорим сейчас.
[57:00.500 --> 57:09.700]  Вот, то есть ровно то, про что я сказал, написано здесь. Как должен выглядеть конструктор, такой
[57:09.700 --> 57:14.380]  конструктор называется конструктором перемещения. Почему перемещение? Потому что мы все содержимое
[57:14.380 --> 57:20.380]  другого стека или другого объекта перемещаем себе. Здесь происходит ровно то, что я написал. Мы просто
[57:20.380 --> 57:28.820]  берем и забираем буфер другого объекта. То есть мы просто забираем, точнее мы указываем на буфер
[57:28.820 --> 57:40.060]  другого объекта. Вот это был чужой и теперь мы ссылаемся на чужой. Вот. И копируем size. Понятно? За
[57:40.060 --> 57:46.460]  сколько это все работает теперь? За единицу. То есть теперь мы не копируем содержимое временного
[57:46.460 --> 57:51.340]  объекта себе, а мы просто забираем все то, что было у него. Это ему больше не пригодится. Все, теперь
[57:51.340 --> 57:59.620]  это наше. Ну и дальше мы зануляем буфер и зануляем size. Теперь вопрос. Смотрите, помните, когда мы
[57:59.620 --> 58:05.740]  говорили про деструкторы, мы говорили, что когда мы деструктурируем объект, нам не обязательно его
[58:05.740 --> 58:10.700]  занулять. Ну потому что он больше никому не пригодится. Да? Смотрите, казалось бы other тоже больше
[58:10.700 --> 58:16.140]  никому не пригодится. Зачем тогда ему занулять буфер, занулять size? Вообще нужно это делать или
[58:16.140 --> 58:28.700]  нет? Еще раз. Да, смотрите, действительно. Вот это делать, вот здесь это делать необходимо. То есть все
[58:28.700 --> 58:32.060]  таки, если вы что-то забрали у другого объекта, то вы обязаны этот другой объект привести в
[58:32.060 --> 58:37.660]  какое-то нормальное состояние. Ну почему? Потому что когда у вас выполнится вот эта строка, что вас
[58:37.660 --> 58:43.700]  произойдет? Вот допустим, вы эти строки не написали. Что у вас тогда произойдет? Давайте нарисуем.
[58:43.700 --> 58:56.180]  У вас есть other. Он указывает на какой-то буфер. У вас есть ваш stack, rcopy называется,
[58:56.180 --> 59:03.460]  который ссылается на ту же самый буфер. Ну и смотрите, если вы у other, то есть если вы у other
[59:03.460 --> 59:10.060]  не изменили буфер, то есть если вы не сделали его указывающим в nullptr, то у вас произойдет неприятность.
[59:10.060 --> 59:14.660]  То есть вы как бы тот старый буфер забрали, но при уничтожении вот этого временного объекта,
[59:14.660 --> 59:20.580]  когда other будет уничтожаться, это же временный объект, он вот создался и потом после этого
[59:20.580 --> 59:23.980]  выражения будет уничтожен. Вот когда у вас other будет уничтожаться, для него будет вызван
[59:23.980 --> 59:30.100]  деструктор. И вот этот буфер будет просто-напросто удален. Понятно? И вот чтобы этого не произошло,
[59:30.100 --> 59:35.820]  мы дополнительно делаем следующую вещь. Мы говорим, что other теперь указывает в null.
[59:35.820 --> 59:42.140]  И теперь, когда будет удаляться other, other будет удалять нулевой указатель. Удаление нулевого
[59:42.140 --> 59:52.820]  указателя ни к чему плохого не приводит. Поэтому все необходимые действия здесь описаны.
[59:52.820 --> 01:00:08.820]  Общая философия. Чтобы корректно отработал деструктор, у вас объект должен находиться
[01:00:08.820 --> 01:00:15.060]  в так называемом согласованном состоянии, ну в хорошем состоянии. Если у вас stack другой
[01:00:15.060 --> 01:00:19.340]  указывает на нулевой указатель, а его size равен 10, то это не согласованное состояние явно.
[01:00:19.340 --> 01:00:24.140]  Поэтому так. Ну это общая рекомендация. Ну и плюс на самом деле... Ладно, не буду об этом говорить.
[01:00:24.140 --> 01:00:29.580]  В общем, достаточно вам этого объяснения. Все, хорошо. То есть после того, как вы что-то забрали у
[01:00:29.580 --> 01:00:35.180]  другого объекта, вы этот другой объект должны оставить в хорошем состоянии. Это общая мораль.
[01:00:35.180 --> 01:00:45.980]  Ну и операция пресваивания выглядит точно таким же образом. Вы удаляете старый буфер и просто-напросто
[01:00:45.980 --> 01:00:53.420]  не копируете, а забираете буфер у временного объекта. Все. Ну а потом другой объект оставляете в
[01:00:53.420 --> 01:01:02.460]  правильном состоянии. С нулевым размером и с нулевым буфером. Все понятно, что произошло.
[01:01:02.460 --> 01:01:10.020]  И этот конструктор перемещения и перемещающий пресваивания теперь работают за вот единицы. То
[01:01:10.020 --> 01:01:14.980]  есть теперь, когда вы присваиваете или перемещаете из временного объекта, у вас теперь все вот эти
[01:01:15.060 --> 01:01:23.540]  конструкторы работают за единицу, а не за линию, как раньше. Ровно здесь это написано. Все ясно.
[01:01:23.540 --> 01:01:33.100]  Ну и соответственно, вот эти методы, которые мы написали, они называются соответственно
[01:01:33.100 --> 01:01:38.420]  перемещающим конструктором и перемещающим пресваиванием. То есть это конструктор перемещения,
[01:01:38.420 --> 01:01:56.820]  конструктор перемещения, а это перемещающее пресваивание. Это тоже особенные конструкторы,
[01:01:56.820 --> 01:02:00.900]  то есть мы говорили, помните, про конструктор копирования, про конструктор по умолчанию,
[01:02:00.900 --> 01:02:06.020]  у них там были специальные правила. Вот у этих конструкторов и у этой операции тоже есть
[01:02:06.020 --> 01:02:14.180]  особенное поведение. Правило такое, если вы в своей программе, точнее в своем классе,
[01:02:14.180 --> 01:02:21.980]  не написали копирование и деструктора, то конструктор перемещения и перемещающего
[01:02:21.980 --> 01:02:26.260]  пресваивания создается за вас. То есть если вы не написали конструктора копирования,
[01:02:26.260 --> 01:02:31.260]  а копирующего пресваивания и деструктора, то вот эти вот две функции компилятор напишет за вас.
[01:02:31.260 --> 01:02:37.980]  Что компилятор будет в них делать? А компилятор просто-напросто возьмет и переместит каждое поле
[01:02:37.980 --> 01:02:44.820]  по отдельности. Ну давайте так, будем говорить, просто-напросто возьмет и, неправильно, хорошо,
[01:02:44.820 --> 01:02:49.100]  неправильно говорить, скопирует, он просто возьмет и переместит все остальное. Давайте пример.
[01:02:49.100 --> 01:03:01.060]  Пример такой. Вот у вас есть класс A, там как-то реализован, и у вас есть класс B, у которого в
[01:03:01.060 --> 01:03:09.180]  качестве поля выступает int x и A. И, допустим, вы в этом классе B не написали ни деструктора,
[01:03:09.180 --> 01:03:15.620]  ни копирования, ничего. Тогда, когда у вас будет объект B перемещаться, то есть компилятор за
[01:03:15.620 --> 01:03:22.500]  вас создаст конструктор перемещения, который будет работать следующим образом. Здесь пока не понятно,
[01:03:22.500 --> 01:03:32.700]  что написано. Короче, он просто-напросто возьмет и скопирует other x, то есть все поля примитивных
[01:03:32.700 --> 01:03:40.060]  типов он скопирует, а поля небазовых типов он просто-напросто переместит. Давайте я пока напишу
[01:03:40.060 --> 01:03:53.180]  вот так. other.a. Стрелочка вот это означает, что в содержимое поля A я перемещу в A. То есть тут,
[01:03:53.180 --> 01:04:02.300]  грубо говоря, будет вызван конструктор перемещения для A. Понятно объяснил? То есть, короче говоря,
[01:04:02.820 --> 01:04:10.320]  для каждого поля будет вызвано конструктор перемещения. Ну, если это примитивные типы,
[01:04:10.320 --> 01:04:14.460]  то для перемитивных типов, естественно, перемещение нет. Не понятно, как байты переместить.
[01:04:14.460 --> 01:04:20.200]  Для примитивного типа перемещение работает просто как копирование, вот. А если у вас в качестве поля
[01:04:20.200 --> 01:04:25.620]  выступает какой-то класс, то для него будет вызван конструктор перемещения. Это так работает
[01:04:25.620 --> 01:04:29.260]  дефолдное перемещение, которое будет за вас написано компилятором. coronaPy ti.f. sometimes.
[01:04:29.260 --> 01:04:32.260]  Для перемещающего присваивания то же самое.
[01:04:32.260 --> 01:04:40.260]  Если вы не хотите писать самостоятельно вот эти вот самые конструкторы перемещения или оператор или перемещающий присваивания,
[01:04:40.260 --> 01:04:43.260]  то вы можете написать равно default.
[01:04:43.260 --> 01:04:45.260]  Ну, собственно, как и раньше.
[01:04:45.260 --> 01:04:48.260]  И еще одно важное правило.
[01:04:48.260 --> 01:04:54.260]  Когда вы будете реализовывать свой перемещающий конструктор или свое перемещающее присваивание,
[01:04:54.260 --> 01:04:58.260]  не забудьте здесь дополнительно указать такое специальное слово noexcept.
[01:04:58.260 --> 01:05:00.260]  Для чего оно нужно, мы поговорим позже.
[01:05:00.260 --> 01:05:02.260]  В общем, поверьте, оно тут нужно.
[01:05:02.260 --> 01:05:08.260]  Глобально ничего плохого не произойдет, если вы его не напишете, если вы его забудете.
[01:05:08.260 --> 01:05:10.260]  Глобально все будет нормально.
[01:05:10.260 --> 01:05:12.260]  Ошибками пляться не будет, все будет работать и так далее.
[01:05:12.260 --> 01:05:16.260]  Но о том, какие проблемы могут возникнуть, мы поговорим позже.
[01:05:16.260 --> 01:05:19.260]  Все, договорились?
[01:05:19.260 --> 01:05:23.260]  Отлично.
[01:05:23.260 --> 01:05:26.260]  Ну и теперь самое время расширить правила трех до правила пяти.
[01:05:26.260 --> 01:05:28.260]  Помните, мы говорили, когда обсуждали конструкторы,
[01:05:28.260 --> 01:05:29.260]  у нас было правило пяти?
[01:05:29.260 --> 01:05:31.260]  Что если вам нужно реализовать
[01:05:31.260 --> 01:05:34.260]  конструктор копирования, копирующего присваивания или деструктор,
[01:05:34.260 --> 01:05:35.260]  хотя бы одно из этого,
[01:05:35.260 --> 01:05:37.180]  то на самом деле нужно реализовывать все три.
[01:05:39.260 --> 01:05:43.260]  Теперь мы изучили перемещающий конструктор и перемещающее присваивание.
[01:05:43.260 --> 01:05:45.260]  И теперь мы это правило расширяем до правила пяти.
[01:05:45.260 --> 01:05:47.260]  Если вам нужно реализовать конструктор копирования
[01:05:47.260 --> 01:05:49.260]  или конструктор перемещения
[01:05:49.260 --> 01:05:51.260]  или копирующий присваивание, или перемещающий присваивания,
[01:05:51.260 --> 01:05:53.260]  то есть если вам нужно реализовать
[01:05:53.260 --> 01:05:55.260]  какое-нибудь копирование,
[01:05:55.260 --> 01:06:00.180]  какое-нибудь перемещение или деструктор, то нужно реализовывать все вот эти вот 5 штук,
[01:06:00.180 --> 01:06:07.140]  все вот эти вот 5 сущностей. Ну и снова понятно, почему. Для чего нам нужно было правило трех,
[01:06:07.140 --> 01:06:11.460]  чтобы мы корректно работали с памятью. Здесь то же самое, если у вас есть какая-то работа с
[01:06:11.460 --> 01:06:17.580]  памятью, то перемещение тоже должно работать как-то, мы должны забрать другой указатель и так далее.
[01:06:17.580 --> 01:06:32.420]  Понятно? Вот, поэтому те, кто писали string, можете потренироваться и для своей строки,
[01:06:32.420 --> 01:06:38.460]  то есть в задании для строки вам нужно было написать только копирование и деструктор. Соответственно,
[01:06:38.460 --> 01:06:43.220]  можете потренироваться, написать для своей строки перемещение и операцию перемещения.
[01:06:43.220 --> 01:06:47.300]  Вот, ну чтобы соблюсти правила пяти, чтобы все корректно работало.
[01:06:47.300 --> 01:07:00.340]  Так, ну и еще один пункт, который касается перемещения, это функция std move. Ну давайте сразу
[01:07:00.340 --> 01:07:08.620]  начнем с проблемы. Функция swap внезапно. Казалось бы, что есть более священная, чем swap. Вроде как
[01:07:08.620 --> 01:07:15.740]  все писали swap, для всех он работал. Кто писал swap? Поднимите руки. Все писали swap. У всех он работал,
[01:07:15.740 --> 01:07:20.660]  все хорошо. Так вот, я утверждаю, что вы swap писали неправильно. Прям совсем неправильно.
[01:07:20.660 --> 01:07:25.660]  Давайте пока посмотрим на то, как вы скорее всего реализовывали swap. Ну вы принимали один объект
[01:07:25.660 --> 01:07:29.180]  по ссылке, второй объект по ссылке, ну понятно почему по ссылке, потому что должны поменять свои
[01:07:29.180 --> 01:07:34.180]  значения. Ну и дальше с помощью третьей переменной записывали x во временную переменную, записывали
[01:07:34.180 --> 01:07:43.580]  y в x, а потом в y сохраняли вот это временное значение. И вот, ну короче, в чем тут проблема,
[01:07:43.580 --> 01:08:01.340]  без стакана не разобраться. Благо, у меня стаканы есть. Так, мне нужен доброволец.
[01:08:04.180 --> 01:08:14.220]  Кто-нибудь. Отлично. Пить не надо.
[01:08:14.220 --> 01:08:34.420]  Достаточно. Так, это x, это y. Сделайте swap.
[01:08:44.220 --> 01:09:04.740]  Так. Нет. Это x, это y. В y все нормально. Вот, отлично. Браво, все.
[01:09:04.740 --> 01:09:16.420]  Это то, как должен работать нормальный swap. Я утверждаю, что вот этот swap работает вообще не так. Вот вообще.
[01:09:16.420 --> 01:09:25.620]  Как работает вот этот swap? Сейчас, в общем, я сам это сделаю. Почти смертельно. Что происходит
[01:09:25.620 --> 01:09:37.500]  в первой строке? tmp равно x. Что здесь происходит? Создается переменная tmp. И x сюда перемещается,
[01:09:37.500 --> 01:09:51.820]  то есть переливается x, правда? Нет, x сюда копируется. Вот что произошло. Это x, это y, это tmp.
[01:09:51.860 --> 01:10:19.820]  Что происходит дальше? Содержимое y записывается в x. Снова произошло копирование. Содержимое x удалилось,
[01:10:19.820 --> 01:10:25.700]  и туда скопировалось содержимое y. То есть я уже произвел две операции создания новых объектов.
[01:10:25.700 --> 01:10:47.860]  Ну и в конце, содержимое tmp вот этого перемещается наконец в x. Копируется, да. Вот так отработал
[01:10:47.860 --> 01:11:01.180]  ваш swap. Сколько лишних действий, сколько выпитого произошло? Проблема ясна? Вряд ли это то,
[01:11:01.180 --> 01:11:11.580]  чего мы хотели. То, чего мы хотели, продемонстрировали нам пять минут назад. Вопрос. Ну и на самом деле,
[01:11:11.580 --> 01:11:20.980]  понятное дело, что это все для базовых типов, то есть если это все инты, например, то ничего
[01:11:20.980 --> 01:11:26.820]  страшного не происходит. То есть копирование интов довольно быстро происходит. А что если в качестве
[01:11:26.820 --> 01:11:34.180]  a и b у нас выступают какие-нибудь массивы или, например, стэки? Стэк размера 100 миллионов,
[01:11:34.180 --> 01:11:40.700]  и второй стэк размера 100 миллионов. И я должен их поменять местами. Что у меня происходит? У меня x,
[01:11:40.700 --> 01:11:47.660]  первый стэк, копируется в tmp. То есть все 100 миллионов объектов копируются в tmp. Происходит
[01:11:47.660 --> 01:11:55.300]  копирование. Дальше. Во-первых, вызывается содержимое x удаляется, и все содержимое y копируется
[01:11:55.300 --> 01:12:01.100]  в x. Второе копирование. Дальше берется содержимое tmp и тоже целиком копируется в y. То есть три
[01:12:01.100 --> 01:12:07.540]  копирования и два удаления ресурсов. Если вы думаете, что вот этот swap работает за единицу,
[01:12:07.540 --> 01:12:17.940]  то нет. Вот этот swap работает за линию. За линию от размеров стэков. Понятно? Ну а естественное
[01:12:17.940 --> 01:12:24.540]  желание это иметь стэк, который бы работал за единицу. Как решить эту проблему? Да, swap.
[01:12:24.540 --> 01:12:35.420]  То есть чего на самом деле тут нужно? Чего на самом деле нам тут хочется? Нам тут хочется не копирование,
[01:12:35.420 --> 01:12:41.100]  от чего? Перемещение. Да, мы хотим не создавать новый объект, а мы хотим перемещать один объект
[01:12:41.100 --> 01:12:49.700]  в другой. Мы хотим x переместить в tmp, y переместить в x и потом tmp переместить в y. Понятно? Вот.
[01:12:49.700 --> 01:12:58.620]  Да, соответственно, вот тут идея. Нужно не копировать, а перемещать. Смотрите, какая проблема. Дело в том,
[01:12:58.620 --> 01:13:04.140]  что на текущий момент мы вряд ли можем заставить компилятор тут что-то перемещать. Почему? Потому
[01:13:04.140 --> 01:13:09.420]  что мы знаем, что тут во всех выражениях x, y и tmp это переменные. А переменные это всегда lvalue.
[01:13:09.420 --> 01:13:14.140]  Если мы работаем с lvalue, то у нас всегда вызывается конструктор копирования или
[01:13:14.140 --> 01:13:19.020]  копирующая операция присваивания. Согласны? То есть конструктор перемещения и перемещающая
[01:13:19.020 --> 01:13:26.980]  присваивания у нас работает только со временными объектами. Проблема понятна? То есть теперь, чтобы
[01:13:26.980 --> 01:13:32.980]  решить этот проблем, нам нужно научиться как-то, ну не знаю, обманывать компилятор. То есть нам нужно
[01:13:33.860 --> 01:13:37.220]  говорить компилятору, что вот эти не временные объекты нужно воспринимать как временные.
[01:13:37.220 --> 01:13:42.060]  Ну понятно, что если я тут заставлю компилятор думать, что x на самом деле временный,
[01:13:42.060 --> 01:13:46.900]  у меня тут возникнет перемещение. Если я тут заставлю компилятор думать, что y временный,
[01:13:46.900 --> 01:13:50.740]  то тут будет вызвано перемещение. Ну и то же самое здесь. Если я заставлю компилятор думать,
[01:13:50.740 --> 01:13:59.300]  что tmp временный, у меня будет вызвано перемещение. Понятна идея? И вот, чтобы это сделать,
[01:13:59.300 --> 01:14:09.300]  есть специальная функция std-move. std-move от x или от любой другой переменной, от любой другой сущности
[01:14:09.300 --> 01:14:17.020]  работает следующим образом. std-move от x заставляет этот объект временно притвориться временным.
[01:14:17.020 --> 01:14:28.300]  Понятно? То есть, грубо говоря, std-move это преобразование из lvalue в rvalue,
[01:14:28.300 --> 01:14:34.740]  временное преобразование, не навсегда. Это преобразование осуществляется с помощью std-move.
[01:14:34.740 --> 01:14:40.060]  Важно понимать, что std-move, вообще говоря, никак не меняет объект. То есть, если я скажу,
[01:14:40.060 --> 01:14:45.780]  что вот эта штука временная, от этого она менее материально не станет. std-move для объекта просто
[01:14:45.780 --> 01:14:53.140]  говорит, что в данном контексте, в данном выражении, считай этот объект временным и все. std-move
[01:14:53.140 --> 01:14:57.340]  вообще никак не меняет объекта, вот вообще. То есть, можно считать, что это просто некоторое,
[01:14:57.340 --> 01:15:04.780]  ну вот, просто притвориться чем-то вот в данном конкретном контексте. Ok? То есть, std-move позволяет
[01:15:04.780 --> 01:15:13.940]  невременным объектам притворяться временными. Вот. И вот, собственно, то, про что мы говорили в начале.
[01:15:13.940 --> 01:15:19.460]  Помните, мы говорили, что rvalue, там на самом деле это prvalue, xvalue. Так вот, xvalue это как раз
[01:15:19.460 --> 01:15:26.780]  результат std-move. Давайте подробно. У нас был rvalue. Это все то, что не является lvalue. И вот,
[01:15:26.780 --> 01:15:32.860]  rvalue разделяется на prvalue. Это то, про что мы говорили все это время до этого. То есть, prvalue
[01:15:32.860 --> 01:15:38.420]  это вот реальные временные объекты. Прям вот чистые временные объекты. Ну, как раз те слова
[01:15:38.420 --> 01:15:47.860]  pure, pure rvalue. А есть xvalue? Вот xvalue можно считать, вот xvalue называются, ну, опять же грубо,
[01:15:47.860 --> 01:15:53.520]  те объекты, которые притворяются временными. Вот если объект не является временным, но им
[01:15:53.520 --> 01:16:03.460]  притворяется, это xvalue. И вот результат std-move является, ну, является как раз xvalue. Ok? Вот.
[01:16:03.460 --> 01:16:08.900]  Значит, ну, опять же, как я уже сказал, std-move на самом деле ничего не делает. Он просто-напросто
[01:16:08.900 --> 01:16:18.460]  выполняет некоторое преобразование, ну, просто преобразование из lvalue в ссылке в... из lvalue в
[01:16:18.460 --> 01:16:28.260]  ссылке в rvalue в ссылку. Ну, давайте пройдемся по примерам. Значит, у меня есть x, в котором сейчас
[01:16:28.260 --> 01:16:36.420]  лежит 11. Когда я вызываю std-move от x, ничего не происходит. То есть, x просто куда-то там в
[01:16:36.420 --> 01:16:41.740]  окно крикнул, что я временный, и все. С x ничего не произошло. То есть, просто тут x притворился
[01:16:41.740 --> 01:16:50.540]  временным, теперь он снова нормальный. Ok? Здесь. Я пытаюсь создать ссылку rx на результат std-move от x.
[01:16:50.540 --> 01:16:55.940]  Вот здесь у меня ничего не получится. Почему? Потому что std-move от x говорит, что x в данном контексте
[01:16:55.940 --> 01:17:04.420]  притворяется временным, а я не могу создать левую ссылку на... на временный объект. Константную ссылку
[01:17:04.420 --> 01:17:17.260]  получится. Да. То есть, если бы тут был constant, то все было нормально. constant rx равно std-move от x. Вот.
[01:17:17.260 --> 01:17:27.020]  Значит, ну, вторая строка работает тоже нормально. В общем, здесь просто в y скопируется x. Вот. Теперь
[01:17:27.020 --> 01:17:33.260]  я могу... да, более того, с помощью std-move я могу создавать правые ссылки на невременные объекты. То
[01:17:33.260 --> 01:17:37.100]  есть, смотрите, допустим, я хочу создать правую ссылку. Ну, непонятно зачем, но, допустим, хочу. Хочу, чтобы
[01:17:37.100 --> 01:17:44.220]  у меня rx, правая ссылка, ссылалась на x. Просто так написать rx равно x мне нельзя. Но я могу
[01:17:44.220 --> 01:17:49.980]  написать rx равно std-move от x. Что делает std-move от x? std-move от x говорит, что x должен притвориться
[01:17:49.980 --> 01:17:55.020]  временным. В данном случае x притворяется временным, и теперь rx ссылается на временный объект x.
[01:17:55.020 --> 01:18:02.620]  Okay? Вот. Ну, rx теперь это полноценная, ну, прям нормальная полноценная ссылка на x. То есть,
[01:18:02.620 --> 01:18:09.300]  если я изменяю rx, то у меня x сам тоже изменится. То есть, это просто некоторый способ, то есть,
[01:18:09.300 --> 01:18:16.780]  некоторый способ связать правые ссылки с невременными объектами. Это std-move. Понятно?
[01:18:25.020 --> 01:18:32.420]  Нет, он ссылается именно на то место, где расположен x. Ну, смотрите, std-move от x, ну, как это работает?
[01:18:32.420 --> 01:18:38.860]  Смотрите, вот тут написано. std-move от x это, на самом деле, просто, это просто некоторое
[01:18:38.860 --> 01:18:44.860]  преобразование. То есть, std-move от x возвращает вам правую ссылку на x, ну, грубо говоря. Ну, а так как
[01:18:44.860 --> 01:18:48.980]  это ссылка, то ссылка, она ссылается опять же на какую-то область памяти. Поэтому здесь все нормально.
[01:18:48.980 --> 01:18:59.540]  Здесь константная ссылка, ссылается на область памяти, где находится x. Да, нет, если вы делаете
[01:18:59.540 --> 01:19:07.540]  плюс-плюс x, то rx тоже изменится, естественно. То есть, здесь вот этот rx и вот этот вот rrx, они
[01:19:07.540 --> 01:19:13.820]  ссылаются именно на x. Именно то место, где расположен x. Ну, давайте два слайда осталось, потом перерыв
[01:19:13.820 --> 01:19:30.180]  и все сделаем. Все понятно здесь? Да. В последнем примере, да, да. Да, все так. Ну, вы объявили ее как правую,
[01:19:30.180 --> 01:19:37.940]  но работает как левая. То есть, на самом деле, вот эта вот ссылочка, она лишь говорит о том, с какими
[01:19:37.940 --> 01:19:42.140]  объектами можно связывать rrx. В данном случае вы сказали, что ссылку rrx можно связывать только
[01:19:42.140 --> 01:19:46.900]  со временными объектами. Ну, а x притворился временным. Ну, поэтому я смог таким образом обойти
[01:19:46.900 --> 01:19:56.460]  это требование. То есть, я смог связать правую ссылку rrx с невременным объектом. То есть, на самом
[01:19:56.460 --> 01:20:02.220]  деле, везде вместо std move вы могли спокойно писать что-то наподобие такого. Ну, там, давайте в c style,
[01:20:02.220 --> 01:20:08.620]  int двойной амперсант x. То есть, это поработало точно так же, как std move. Ну, или вы могли написать
[01:20:08.620 --> 01:20:18.060]  static cast от int двойной амперсант скобках x. То есть, вы могли это делать вручную. То есть, вы могли
[01:20:18.060 --> 01:20:25.460]  вручную просто привести x к правой ссылке. Ну, недостаток понятия. Вам нужно самостоятельно указывать
[01:20:25.460 --> 01:20:32.300]  тут тип. std move позволяет вам тип не указывать, а просто передавать ему аргумент. Возможно, в следующий раз мы
[01:20:32.300 --> 01:20:36.860]  поговорим, как std move реализован внутри. Но в общем и целом, можно считать, что это просто
[01:20:37.180 --> 01:20:50.220]  static cast или просто преобразование в правой ссылке. И все, больше ничего. Ну, и теперь со стеком.
[01:20:50.220 --> 01:20:57.940]  Ну, и как работает std move со стеком? Ну, ровно точно так же. Если я пишу stack x равно y, то тут
[01:20:57.940 --> 01:21:04.900]  происходит копирование. Ну, как и раньше. Если я пишу y равно x, то тут происходит тоже копирующее
[01:21:04.900 --> 01:21:13.500]  присваивание. Ну, тоже никаких вопросов нет. Что произойдет, если я позову std move от y? Что произойдет
[01:21:13.500 --> 01:21:25.340]  с y? Что произойдет? Ну, ничего с y не произойдет. std move ничего не делает. Сам по себе std move,
[01:21:25.340 --> 01:21:29.420]  он с объектом ничего не делает. Он его никак не изменяет. Поэтому, если вы вызвали std move от y,
[01:21:29.580 --> 01:21:36.980]  компилятор это просто строку проигнорирует. То есть, она ничего не делает. Но все становится по
[01:21:36.980 --> 01:21:41.260]  другому, если вы используете std move вот в таком контексте. Ну, например, в таком контексте.
[01:21:41.260 --> 01:21:48.460]  Вы пишете stack z равно std move от y. И вот в этот момент происходит магия. Смотрите,
[01:21:48.460 --> 01:21:54.780]  какой конструктор у меня тут вызывается? Ну, есть два варианта. То есть, я хочу создать stack z
[01:21:54.780 --> 01:22:01.020]  с помощью stack y. Я могу вызвать конструктор копирования или конструктор перемещения. Вот здесь
[01:22:01.020 --> 01:22:08.340]  вызывается конструктор перемещения. Почему? Потому что y претворился временным. А мы договорились,
[01:22:08.340 --> 01:22:13.460]  что если я какой-то объект создаю с помощью временного значения, то у меня вызывается
[01:22:13.460 --> 01:22:21.420]  конструктор перемещения. И вот здесь ровно это и происходит. То есть, у меня содержимое y
[01:22:21.420 --> 01:22:28.420]  перемещается в z. И вот как раз-таки ответ на ваш вопрос. Вы спрашивали, зачем нужно еще и size
[01:22:28.420 --> 01:22:36.260]  занулять? Вот если бы я size не занулял, то у меня получился stack y, в котором бы буфер был нулевой,
[01:22:36.260 --> 01:22:44.180]  а size был бы не нулевой. Понятно? Понятно, что этим y я, в принципе, теоретически могу дальше
[01:22:44.180 --> 01:22:51.020]  воспользоваться. Ну а тут у меня как бы в плохом состоянии stack находится. Вот. То есть, что у меня
[01:22:51.020 --> 01:23:00.900]  тут произошло? Давайте снова порисуем. Значит, у меня есть stack x, у которого есть свой буфер. Давайте
[01:23:00.900 --> 01:23:05.900]  вот так будем держать. Есть stack y, у которого есть свой буфер. И есть stack z, который я создаю вот
[01:23:05.900 --> 01:23:14.060]  в этой строке. Когда я вызываю z равно stdmove от y, что происходит? Содержимое y перемещается в z.
[01:23:14.060 --> 01:23:21.260]  То есть z, на самом деле, просто берет и крадет содержимое y к себе, а y остается ни с чем. То есть
[01:23:21.260 --> 01:23:28.140]  y теперь указывает никуда. Вот что произошло. Понятно? То есть stdmove позволяет забрать
[01:23:28.140 --> 01:23:34.540]  содержимое другого stack, ну или другого объекта себе. Ну и дальше в следующей строке y равно stdmove
[01:23:34.540 --> 01:23:43.260]  от x. Что происходит? У меня теперь y забирает содержимое x. Вот так. А x остается ни с чем.
[01:23:43.260 --> 01:23:52.300]  Вот. Важно понимать, что вот эту всю магию с тем, что у кого-то что-то украли и так далее,
[01:23:52.300 --> 01:23:56.820]  это все делает не stdmove. stdmove ничего не делает. Всю вот эту магию сделал мне конструктор
[01:23:56.820 --> 01:24:02.220]  перемещения и перемещающее присваивание. Понятно? То есть вот эту логику с забиранием,
[01:24:02.220 --> 01:24:08.780]  с отъемом вот этих вот самых указателей. Вот эта логика, она у меня реализована в конструктор
[01:24:08.780 --> 01:24:15.500]  перемещения и перемещающем присваивание. Понятно? Вот. То есть теперь после выполнения
[01:24:15.500 --> 01:24:19.780]  этого кода у меня, ну во-первых, понятное дело, что я не создавал ни одного нового буфера. Вот здесь,
[01:24:19.780 --> 01:24:24.780]  при манипуляции x, y и z, я не создал ни одного нового буфера. То есть никакого new и delete у меня
[01:24:24.780 --> 01:24:31.540]  вызван не было. Я просто перемещал между ними вот эти самые указатели. x теперь пустой,
[01:24:31.540 --> 01:24:40.820]  ну потому что я у x в последней строке забрал содержимое и сохранил его в y. Понятно? Вот.
[01:24:40.820 --> 01:24:48.860]  Да, ну и собственно пустым x сделал не stdmove, а перемещающий оператор присваивания. Все понятно?
[01:24:48.860 --> 01:24:55.180]  Все. Ну и наконец, как правильно написать swap? Правильный swap выглядит следующим образом.
[01:24:55.180 --> 01:25:02.380]  Чтобы поменять местами x и y, нужно сделать следующую вещь. Нужно x переместить во временное
[01:25:02.380 --> 01:25:08.620]  значение. А как x переместить во временное значение? Нужно у tmp вызвать конструктор перемещения.
[01:25:08.620 --> 01:25:13.300]  А как у tmp вызвать конструктор перемещения? Нужно, чтобы x претворился временным. Чтобы x
[01:25:13.300 --> 01:25:22.180]  претворился временным, мы делаем stdmove от x. Понятно? Все. Т.е. tmp равно stdmove от x. Вот. Дальше.
[01:25:22.180 --> 01:25:26.460]  В следующей строке мы перемещаем содержимое y, ну то есть просто перемещаем содержимое y в x.
[01:25:26.460 --> 01:25:33.900]  Делаем это с помощью стдmove. x равно stdmove от y. Ну и в конце мы перемещаем содержимое временного
[01:25:33.900 --> 01:25:41.060]  хранилища в y. y равно stdmove от tmp. И так как у меня все перемещения, ну то есть мы говорили,
[01:25:41.060 --> 01:25:45.300]  что перемещающие конструкторы и перемещающие присваивания работают за единицу, теперь у меня
[01:25:45.300 --> 01:25:50.740]  каждый из этих трех строк работает за единицу всегда. Неважно, какого размера у меня объекты. Все,
[01:25:50.740 --> 01:25:56.700]  что я делаю, это просто меняю указатели местами. И все. И вот теперь у меня есть прекрасный сваб,
[01:25:56.700 --> 01:26:04.180]  который работает за три перемещения и всегда работает за единицу. Так, значит, на второй части мы
[01:26:04.180 --> 01:26:16.460]  поговорим про, ну мы продолжим говорить про c++, но с некоторой другой точки зрения мы поговорим,
[01:26:16.460 --> 01:26:21.820]  наверное, больше про стандартную библиотеку, ну и бонусом разберем одну из задач вашего задания
[01:26:21.820 --> 01:26:31.580]  текущего. Поговорим мы про умные указатели. Ну смотрите, в первом задании вы писали, должны были
[01:26:31.580 --> 01:26:37.100]  писать, по крайней мере, класс строки. Вот что он из себя представлял? Он представлял динамическую
[01:26:37.100 --> 01:26:40.860]  строку, которая хранила свои данные в динамической области памяти и могла по мере необходимости
[01:26:40.860 --> 01:26:45.980]  расширяться при запросе, могла уменьшать свой размер и так далее. Ну вообще в принципе представлял
[01:26:45.980 --> 01:26:50.500]  из себя удобный интерфейс для работы со строками. То есть можно было конкатинировать строки и так далее,
[01:26:50.500 --> 01:26:55.620]  и в принципе можно было не париться о работе с памятью, о том, какие внутри алгоритмы использованы. То
[01:26:55.620 --> 01:27:00.580]  есть в конструкторе она там память выделяет и в деструкторе все освобождает, все отлично. И
[01:27:00.580 --> 01:27:07.660]  собственно вопрос вам, как уйдем мы реализуем с помощью вот такого подхода, когда мы выделяем все в
[01:27:07.660 --> 01:27:18.580]  конструкторе, а уничтожаем в деструкторе. Да, рай. Ресурс acquisition из initialization. То есть захват
[01:27:18.580 --> 01:27:25.140]  ресурса, есть initialization. Ну и вообще говоря, современный T++, он изобилует такими большим
[01:27:25.140 --> 01:27:31.140]  количеством классов, которые реализуют семантику рай, но в частности вам не нужно писать там свои
[01:27:31.140 --> 01:27:37.100]  динамические массивы, потому что у вас есть класс std-вектор, который, кстати, во втором задании уже
[01:27:37.100 --> 01:27:41.380]  использовать можно. То есть я надеюсь, вы на семинарах поговорили о том, как они устроены, как они
[01:27:41.380 --> 01:27:45.740]  работают и так далее. Ну у нас будет отдельный лекции по этому, но в принципе уже можно начинать
[01:27:45.740 --> 01:27:53.580]  пользоваться. Но при этом смотрите, у нас есть std-string, у нас есть std-vector, и они реализуют так
[01:27:53.580 --> 01:27:57.580]  называемые динамические массивы. То есть мы в динамической области памяти выделяем массивы и
[01:27:57.580 --> 01:28:01.700]  дальше с ними как- то работаем. Но на практике мы же не всегда работаем именно с массивами,
[01:28:01.700 --> 01:28:07.340]  согласитесь, что иногда нам необходимо выделять объект, так скажем, по одному. То есть вряд ли
[01:28:07.340 --> 01:28:13.260]  вы будете использовать std-вектор, чтобы выделять объект там по одной штучке, то есть взяли один
[01:28:13.260 --> 01:28:17.180]  объект, один объект, один объект и так далее. Но в частности если вы реализуете связанный список.
[01:28:17.180 --> 01:28:21.840]  Связанный список вы реализуете так вы выделяете при необходимости новый узел, ну и дальше этот узел
[01:28:21.840 --> 01:28:26.240]  провязываете с остальными и так далее. То есть, при необходимости вы делаете new node и так далее, и так далее.
[01:28:26.840 --> 01:28:33.080]  Понятное дело, что писать new в своем коде это не раи безопасно. То есть, это не безопасно с точки зрения
[01:28:33.800 --> 01:28:37.520]  утечек памяти, с точки зрения того, что вам нужно постоянно там думать, где написать delete.
[01:28:38.160 --> 01:28:44.640]  Ну и более того, вы не всегда на самом деле можете написать delete самостоятельно. Классический пример такой.
[01:28:46.160 --> 01:28:48.160]  Давайте у вас есть какая-нибудь структура
[01:28:48.760 --> 01:28:50.760]  node, которая представляет из себя
[01:28:51.160 --> 01:28:55.400]  узел односвязанного списка, в котором хранится, допустим, интовое поле value и
[01:28:55.920 --> 01:28:57.920]  указатель на следующий узел nodeNext.
[01:29:00.000 --> 01:29:04.040]  Ну и допустим, вы пишете свою функцию, которая называется allocateNode.
[01:29:08.400 --> 01:29:13.600]  Int x пусть будет. Ну и все, что эта функция делает, она просто инкапсюлирует внутри себя
[01:29:15.280 --> 01:29:17.280]  вызов newNode.
[01:29:17.520 --> 01:29:20.880]  То есть allocateNode внутри себя создает новую вершину и возвращает вам
[01:29:21.800 --> 01:29:23.800]  новый узел.
[01:29:25.440 --> 01:29:30.080]  Смотрите, функция allocateNode, она выделила некоторые новые ресурсы с помощью new.
[01:29:31.320 --> 01:29:35.000]  Ну и теперь вопрос, а кто ответственный за то, чтобы вызвать delete соответствующий?
[01:29:36.840 --> 01:29:41.720]  То есть, согласитесь, что allocateNode в этом смысле, она очень не безопасна. Но дело в том, что она подразумевает, что
[01:29:42.240 --> 01:29:46.400]  пользователь, он достаточно самостоятельный, достаточно ответственный для того, чтобы самостоятельно вызвать delete.
[01:29:46.720 --> 01:29:51.760]  То есть, мы как бы вызвали new, а дальше отдали внешнему коду на откуп node. Дальше ты делаешь с этим
[01:29:52.360 --> 01:29:57.880]  указателем все, что угодно, главное не забыть потом вызвать delete. Но это как-то какое-то слишком сильное требование к пользователю, чтобы он там не забыл
[01:29:58.040 --> 01:30:00.200]  почистить ресурсы, которые выделены, тем более не он.
[01:30:00.400 --> 01:30:05.840]  То есть, пользователь как бы читает свой код, он не видит ни одного new, поэтому, наверное, он думает, что не нужно вызывать delete и так далее.
[01:30:05.840 --> 01:30:10.920]  То есть, в данном случае это классический пример функции, которая сама вызывает new, но при этом сама вызвать delete не может.
[01:30:11.920 --> 01:30:12.800]  Понятно?
[01:30:12.800 --> 01:30:16.360]  Ну и, в принципе, наверное, как-то работать с new и delete, то есть, постоянно для каждого new
[01:30:16.520 --> 01:30:19.720]  думать, как вызвать delete и так далее, это не очень удобно. И вот для таких целей
[01:30:20.600 --> 01:30:24.000]  существуют так называемые умные указатели. И давайте мы, собственно, попробуем,
[01:30:24.480 --> 01:30:30.000]  ну, во-первых, посмотрим, какие указатели, какие умные указатели есть в стандартной библиотеке C++, а во-вторых, попробуем написать их
[01:30:30.520 --> 01:30:35.080]  некоторых аналоги самостоятельно. Ну, давайте сделаем что-то наподобие такого.
[01:30:35.880 --> 01:30:37.480]  Напишем
[01:30:37.480 --> 01:30:39.480]  некоторый класс
[01:30:39.600 --> 01:30:41.600]  smart-ptr.
[01:30:43.800 --> 01:30:48.200]  Вот, который внутри себя в приватной области будет хранить единственное поле,
[01:30:49.880 --> 01:30:51.880]  которое представляет из себя указатель.
[01:30:53.600 --> 01:30:58.320]  Значит, ну давайте так, цель. Я хочу написать класс, который будет являться оберткой над
[01:30:59.360 --> 01:31:05.280]  обычным сырым указателем, который будет, собственно, захватывать ресурсы в конструкторе и освобождать его в деструкторе.
[01:31:06.080 --> 01:31:09.840]  Соответственно, что я делаю? Ну, давайте напишу какой-нибудь конструктор. Допустим, конструктор
[01:31:10.760 --> 01:31:12.760]  explicit
[01:31:12.800 --> 01:31:14.800]  smart-ptr, который будет принимать
[01:31:15.200 --> 01:31:21.160]  обычный указатель. Ну, то есть я передаю в этот умный указатель, собственно, выделенный уже заранее указатель,
[01:31:22.600 --> 01:31:24.600]  и сохраняю его в себе в поле.
[01:31:27.760 --> 01:31:29.760]  Ну и дальше в деструкторе
[01:31:30.400 --> 01:31:35.880]  smart-ptr. Я этот ресурс освобождаю. То есть я просто беру и
[01:31:37.400 --> 01:31:39.400]  делаю delete-ptr.
[01:31:40.400 --> 01:31:46.720]  Ну, используя, например, например, такой int-main и дальше smart-ptr.
[01:31:48.760 --> 01:31:50.760]  Давайте add-note.
[01:31:51.960 --> 01:31:53.960]  ptr-new-note.
[01:31:57.040 --> 01:31:59.400]  Там, не знаю, ну пусть так.
[01:32:07.120 --> 01:32:09.120]  Ну, казалось бы, все нормально, да?
[01:32:09.960 --> 01:32:12.440]  То есть вот я написал класс smart-ptr.
[01:32:13.000 --> 01:32:16.680]  Что происходит в конструкторе? В конструкторе я просто-напросто беру указатель, который мне передали,
[01:32:16.960 --> 01:32:22.880]  сохраняю его в поле, а дальше, собственно, вот здесь смотрите в мейне, несмотря на то, что я написал там new, мне не нужно самостоятельно думать о том, что вызвать delete.
[01:32:23.200 --> 01:32:26.320]  Почему? Потому что delete у меня будет вызвано автоматически в деструкторе smart-ptr.
[01:32:27.640 --> 01:32:29.640]  Окей?
[01:32:29.640 --> 01:32:31.120]  Согласны?
[01:32:31.120 --> 01:32:37.840]  Ну окей, ну хорошо, смотрите, я написал такой замечательный класс ptr, который умеет создаваться и умеет удаляться, и больше ничего не умеет.
[01:32:38.840 --> 01:32:42.480]  Ну как-то странно, как-то странно. То есть если мы говорим про умный указатель, мы, наверное,
[01:32:43.040 --> 01:32:50.400]  в самом названии умный указатель, содержится слово указатель. Наверное, мы хотим вот этим классом или объектами этого класса пользоваться как и обычными указателями.
[01:32:50.760 --> 01:32:52.760]  А что мы обычно хотим от указателей?
[01:32:53.920 --> 01:33:00.240]  Умение их разыменовывать. Да, отлично. Давайте попробуем реализовать операцию разыменования. То есть благо мы проходили
[01:33:01.760 --> 01:33:07.000]  перегрузку операций. Вопрос. Что возвращает разыменование указателя?
[01:33:07.840 --> 01:33:20.480]  Вот если у меня есть указатель на объект типа t, я разыменовываю указатель. Что мне возвращается?
[01:33:21.280 --> 01:33:23.280]  t, а если более точно?
[01:33:24.720 --> 01:33:30.800]  Ну ссылка на t или lvalue на t, да? То есть я тут должен вернуть t&, и дальше я перегружаю
[01:33:31.640 --> 01:33:37.040]  оператор звездочка, оператор разыменования. Значит, оператор звездочка это унарная операция, поэтому я туда ничего не передаю.
[01:33:37.880 --> 01:33:39.880]  Вопрос. Эта операция константная или неконстантная?
[01:33:42.280 --> 01:33:45.040]  Неконстантная. Почему неконстантная?
[01:33:49.200 --> 01:33:52.960]  Да, ну смотри, то, что мы разыменовываем, меняем. А сам указатель-то от этого меняется или нет?
[01:33:53.800 --> 01:33:58.080]  Да, ну то есть весь прикол в том, что сам указатель-то от этого не меняется. То есть согласитесь, что если бы тут написали
[01:33:58.720 --> 01:34:02.160]  const smartptr, то мы бы все равно хотели разыменовывать сам ptr.
[01:34:03.000 --> 01:34:05.600]  Странно как-то не разыменовывать константный указатель.
[01:34:06.440 --> 01:34:08.440]  Да?
[01:34:09.280 --> 01:34:11.280]  То есть смотрите, если бы я тут написал,
[01:34:14.520 --> 01:34:16.520]  то есть у меня,
[01:34:18.000 --> 01:34:22.080]  короче, когда я пишу тут const, у меня константом становится сам указатель.
[01:34:22.480 --> 01:34:25.960]  То есть я сам указатель менять не могу, но то, что лежит под указателем, я менять могу.
[01:34:26.400 --> 01:34:31.720]  Понятно? Если бы я не хотел менять сам объект, я бы написал smartptr от const node.
[01:34:31.720 --> 01:34:37.480]  Ну, при разыменовании указателя, сам указатель, естественно, не меняется, поэтому этот метод является константным.
[01:34:37.480 --> 01:34:41.000]  Ну и все, что он делает, это возвращает разыменованный ptr.
[01:34:41.880 --> 01:34:44.920]  Вот, отлично. Ну давайте проверим, что
[01:34:47.360 --> 01:34:49.360]  проверим, что все работает, например.
[01:34:54.080 --> 01:34:56.080]  Да, тут кавлик, конечно.
[01:34:56.600 --> 01:35:05.440]  Ну ладно, и тут мы можем, например, проверить что-то типа, я не знаю, какой-нибудь ассерт.
[01:35:09.920 --> 01:35:14.280]  ptr.value равно равно единице. Вот как-то так.
[01:35:18.920 --> 01:35:21.640]  Вот, окей. То есть разыменование написали.
[01:35:22.480 --> 01:35:26.440]  Что дальше? Что еще мы ожидаем от указателя? Что еще входит в интерфейс указателя?
[01:35:30.960 --> 01:35:37.280]  Ну, смотрите, вот я тут использовал ptr.value, а еще я могу, наверное, использовать ptr.next.
[01:35:39.080 --> 01:35:41.640]  Какой есть альтернативный синтаксис, чтобы делать вот такую штуку?
[01:35:45.320 --> 01:35:47.320]  Да, то есть, наверное, хотелось бы уметь
[01:35:48.080 --> 01:35:50.080]  делать что-то такое.
[01:35:50.320 --> 01:35:52.080]  Обращаться через стрелочку.
[01:35:52.080 --> 01:35:55.720]  То есть не разыменовывать и потом ставить точку, а именно обращаться через стрелочку.
[01:35:56.720 --> 01:36:00.080]  Давайте попробуем перегрузить операцию стрелочкой. Благо ее тоже можно перегружать.
[01:36:03.120 --> 01:36:05.120]  Оператор
[01:36:06.000 --> 01:36:11.080]  стрелки. Она тоже константная, потому что операция стрелочка, она, естественно, сам указатель не меняет.
[01:36:11.920 --> 01:36:16.400]  И вот тут возникает вопрос, а что должно вернуть операция стрелочки? Вообще, в принципе, как она работает?
[01:36:17.240 --> 01:36:24.960]  И вот ответ такой. Операция стрелочкой это особенная операция, которая работает следующим образом.
[01:36:26.840 --> 01:36:28.840]  Если операция стрелочка
[01:36:29.040 --> 01:36:35.440]  применяется к обычному указателю, ну, не знаю, допустим, у вас есть pointer, и это обычный указатель. Вот если вы к нему
[01:36:36.280 --> 01:36:40.400]  принимаете стрелочку, то компилятор дословно это все переводит в следующий код.
[01:36:40.400 --> 01:36:42.400]  pointer.x
[01:36:45.400 --> 01:36:49.840]  То есть, если компилятор вот здесь,
[01:36:51.480 --> 01:36:58.640]  слева, слева стрелочки, видит обычный указатель, он просто это все переводит вот в такой код. То есть, он разыменует указатель и берет x.
[01:37:00.040 --> 01:37:05.240]  А что происходит, если компилятор в качестве pointer, вот в качестве вот этого pointer? Давайте так, класс.
[01:37:05.240 --> 01:37:07.240]  class pointer.
[01:37:08.560 --> 01:37:16.320]  Если он в качестве левого операнда, в качестве операнда, который стоит слева от стрелочки, он встречает объект какого-то класса. Вот тут происходит магия.
[01:37:17.240 --> 01:37:19.600]  Компилятор подставляет следующий код.
[01:37:20.400 --> 01:37:22.400]  Он пишет
[01:37:23.520 --> 01:37:25.280]  class pointer.
[01:37:25.280 --> 01:37:31.240]  точка, оператор, стрелочка. То есть, он вызывает операцию стрелочкой, которая определена внутри вашего класса, и
[01:37:32.840 --> 01:37:34.840]  у результата вызывает стрелочку.
[01:37:36.240 --> 01:37:45.560]  То есть, компилятор, если вы применяете стрелочку к вашему классу, то он вызывает операцию стрелочка до тех пор рекурсивно.
[01:37:45.840 --> 01:37:48.280]  То есть, в этом смысле он настойчивый. Он
[01:37:49.040 --> 01:37:52.680]  рекурсивно вызывает стрелочку до тех пор, пока вы не вернете обычный указатель.
[01:37:53.880 --> 01:38:00.040]  То есть, компилятор не умеет работать ни с чем другим, кроме как с обычными указателями, и он от вас настойчиво просит обычный указатель.
[01:38:00.440 --> 01:38:07.080]  Вот если у вас операция стрелочка возвращает необычный указатель, то есть, если у вас операция стрелочка возвращает снова какой-то класс,
[01:38:07.660 --> 01:38:09.900]  то компилятор продолжает. Он снова пишет точка,
[01:38:10.960 --> 01:38:13.600]  оператор, стрелочка... ну и так далее.
[01:38:14.560 --> 01:38:18.420]  И если, в какой-то момент, ну elephants вызывают двух операций стрелочек...
[01:38:19.320 --> 01:38:25.680]  ваш метод вернул обычный указатель, то тут все нормально. Как handmade с обычными указателями, компилятор знает.
[01:38:27.820 --> 01:38:29.820]  Понятно?
[01:38:30.040 --> 01:38:35.960]  то есть стрелочка, то есть операция стрелочка применяется рекурсивно до тех пор, пока вы не вернете нормальный указатель.
[01:38:37.440 --> 01:38:41.520]  Если вы нормальный указатель так и не вернете, то у вас на самом деле будет ошибка компиляции.
[01:38:41.520 --> 01:38:44.760]  Компилятор умеет такие штуки проверять на этапе компиляции, то есть если вы тут напишете
[01:38:46.200 --> 01:38:50.200]  smart ptr от, что тут, t,
[01:38:51.800 --> 01:38:59.240]  и потом напишете return list, тут возникает ошибка компиляции. Почему? Потому что у вас тут бесконечные рекурсии.
[01:39:00.040 --> 01:39:05.320]  Компилятор бесконечно будет вызывать операцию стрелочкой и, ну, собственно,
[01:39:05.800 --> 01:39:09.760]  ну, короче, компилятор вам скажет, что вы делаете рекурсию, в общем, вы не правы.
[01:39:10.760 --> 01:39:15.840]  Поэтому правильный способ реализовывать операцию стрелочкой, это просто вернуть обычный указатель, то есть t звездочка.
[01:39:16.960 --> 01:39:19.280]  Соответственно, вы возвращаете ptr.
[01:39:20.920 --> 01:39:22.920]  Понятно?
[01:39:22.920 --> 01:39:27.040]  Как это работает? Когда вы вызываете ptr стрелочка value,
[01:39:27.040 --> 01:39:30.880]  вот эта штука разворачивается в следующую вещь.
[01:39:32.160 --> 01:39:38.440]  Компилятор понимает, что слева от стрелочки стоит объект класса, поэтому он через точку вызывает оператора стрелочка.
[01:39:39.360 --> 01:39:45.320]  И дальше к этому всему применяет обычную стрелочку. Это работает именно так, дословно.
[01:39:45.920 --> 01:39:53.480]  То есть сначала он вызывает операцию стрелочка через точку, дальше вот эта ваша операция стрелочка возвращает обычный указатель.
[01:39:54.000 --> 01:40:00.280]  Ну, а как применить стрелочку к обычному указателю, компилятор уже спокойно знает и все нормально. Понятно?
[01:40:02.000 --> 01:40:08.200]  Поэтому операция стрелочка реализовывается таким образом. В качестве ответа к операции стрелочек вы должны вернуть некоторый объект,
[01:40:08.440 --> 01:40:11.000]  к которому снова можно применить операцию стрелочек.
[01:40:11.960 --> 01:40:14.520]  В самом простом случае, вы возвращаете просто обычный указатель.
[01:40:15.680 --> 01:40:17.680]  Вот и все.
[01:40:18.600 --> 01:40:20.600]  Ну вот.
[01:40:20.600 --> 01:40:26.520]  В принципе этих двух операций достаточно, чтобы поддержать 99 процентов функционала всех указателей.
[01:40:27.920 --> 01:40:29.920]  Теперь вопрос следующий.
[01:40:30.040 --> 01:40:36.800]  Что вам еще не нравится вот в этом классе? Смотрите, снова. Я написал класс умного указателя,
[01:40:38.240 --> 01:40:41.680]  который в конструкторе принимает некоторый указатель,
[01:40:42.680 --> 01:40:46.960]  то есть указатель на выделенную память, в деструкторе ее освобождают, то есть не нужно самостоятельно вызывать delete.
[01:40:47.040 --> 01:40:49.160]  Вот я могу вызвать стрелочку, могу
[01:40:50.960 --> 01:40:54.520]  разыминовывать этот указатель и все работает корректно. Что не так?
[01:40:58.400 --> 01:41:07.400]  Арифметики. Ну на самом деле арифметику с умными указателями, наверное, это такой момент, при котором хорошо, что нет арифметики.
[01:41:08.240 --> 01:41:10.240]  Согласитесь, странно, что вы
[01:41:11.240 --> 01:41:16.040]  выделили память. Не знаю, давайте какой-нибудь. ptr равно newint.
[01:41:17.000 --> 01:41:20.160]  А потом делаете plus plus ptr. Ну это странно.
[01:41:20.680 --> 01:41:24.560]  Если выделили какую-то память динамическую, то вы ее, то вы вряд ли выполняете с ней арифметику.
[01:41:25.360 --> 01:41:27.160]  Потому что непонятно потом,
[01:41:27.160 --> 01:41:31.960]  как делать delete ptr. Потому что вы уже ссылаетесь не на тот объект, который выделяли. Согласны?
[01:41:34.080 --> 01:41:36.080]  Поэтому то, что арифметики нет, это нормально.
[01:41:36.080 --> 01:41:38.400]  Хороший вопрос. Действительно, если мы,
[01:41:39.760 --> 01:41:46.920]  смотрите, если мы здесь, допустим, попытаемся вызвать new не от одной ноды, а попытаемся выделить сразу массив нод, то
[01:41:47.480 --> 01:41:51.400]  этот умный указатель работать не будет. Но у меня есть контраргумент.
[01:41:52.200 --> 01:41:56.600]  Смотрите, если вам нужен динамический массив, зачем вы используете умный указатель? У вас же есть вектор.
[01:41:58.000 --> 01:42:04.720]  Это первый ответ. А второй ответ, если вы используете арифметику с умными указателями, то у вас же есть арифметик.
[01:42:04.720 --> 01:42:08.480]  Это первый ответ. А второй ответ, мы эту проблему поборем чуть позже.
[01:42:08.960 --> 01:42:13.480]  Вообще да. Но, короче говоря, умные указатели, как правило, используются только с одним объектом. То есть, когда вы выделяете только один объект.
[01:42:13.720 --> 01:42:19.400]  Поэтому все нормально. Если вам нужен динамический массив, то используйте вектор или строку динамическую.
[01:42:22.200 --> 01:42:28.800]  Давайте буквально, на прошлый, только сегодня обсуждали, в чем проблема этого класса.
[01:42:35.720 --> 01:42:37.720]  Нет.
[01:42:42.680 --> 01:42:44.400]  Правило пяти.
[01:42:44.400 --> 01:42:48.160]  Смотрите, у меня этот класс, он заведомо работает с ресурсами.
[01:42:48.520 --> 01:42:51.320]  Мало того, что он работает с ресурсами, так мы еще и деструкторы реализовали.
[01:42:51.560 --> 01:42:58.320]  И у вас должен сразу работать триггер. Если мы реализовали деструктор, то значит нам дает еще кучу всего реализовывать. То есть деструктор это только начало
[01:42:58.840 --> 01:43:00.840]  пути большого.
[01:43:02.240 --> 01:43:04.240]  Что еще нужно реализовать?
[01:43:04.720 --> 01:43:06.720]  Два копирования, два перемещения.
[01:43:07.480 --> 01:43:09.480]  Короче, два копирования, два перемещения.
[01:43:10.200 --> 01:43:12.200]  Хорошо, давайте попробуем написать копирование.
[01:43:14.400 --> 01:43:19.160]  Smart PTR от const smart ptr по ссылке other.
[01:43:23.000 --> 01:43:26.360]  А как должен работать копирование для умных указателей?
[01:43:28.160 --> 01:43:30.160]  Вот смотрите.
[01:43:30.480 --> 01:43:32.160]  Вот у меня есть PTR.
[01:43:32.160 --> 01:43:34.160]  Я хочу создать копию.
[01:43:34.320 --> 01:43:36.320]  Прямо как-то вот так.
[01:43:36.320 --> 01:43:38.320]  Что должно произойти?
[01:43:45.840 --> 01:43:47.840]  Давайте.
[01:44:04.160 --> 01:44:07.800]  Правда ли, что когда вы пишете вот так, вы ожидаете, что создастся
[01:44:08.800 --> 01:44:11.000]  какой-то новый указатель, который будет указывать на
[01:44:11.720 --> 01:44:13.720]  такой же объект.
[01:44:16.320 --> 01:44:19.040]  Ожидаете ли вы такого поведения? Да.
[01:44:20.360 --> 01:44:24.720]  То есть при копировании одного, то есть когда вы пишете, то есть если отсвечите, то есть если у вас есть
[01:44:26.120 --> 01:44:29.080]  int ptr равно чему-то и
[01:44:30.320 --> 01:44:32.320]  вы пишете
[01:44:34.160 --> 01:44:39.760]  равно ptr, вы ожидаете, что у вас этот указатель будет указывать на некоторые новые объекты?
[01:44:42.280 --> 01:44:44.280]  Ну то есть
[01:44:46.360 --> 01:44:48.360]  вы ожидаете какого-то такого поведения?
[01:44:49.640 --> 01:44:53.440]  А с умными указателя вы ожидаете такого? Но это как странно, несимметрично.
[01:44:54.400 --> 01:44:56.400]  То есть наверное хочется чтобы...
[01:44:58.280 --> 01:45:00.280]  То есть вы ожидаете, что у вас будет вот так?
[01:45:05.160 --> 01:45:10.720]  А кому нравится такое поведение? То есть когда вы создаете копию указателя, вы указываете на тот же самый объект.
[01:45:12.200 --> 01:45:14.200]  Ну то возникает сразу куча проблем.
[01:45:15.640 --> 01:45:21.840]  А кто из них должен удалять? Ну хорошо, двойное удаление. Понятное дело, что когда мы будем писать своему наказателю, мы не будем двойного удаления допускать.
[01:45:21.840 --> 01:45:23.840]  Но возникает вопрос, а...
[01:45:25.200 --> 01:45:29.960]  Хорошо, если нет двойного удаления, то кто обязан удалять этот объект x? Он или он?
[01:45:30.960 --> 01:45:32.960]  Вот непонятно.
[01:45:33.520 --> 01:45:39.240]  То есть с копированием в умных указателях на самом деле все сложно. То есть если у вас есть какой-то ресурс, то
[01:45:39.920 --> 01:45:43.640]  владение несколькими указателями одним и тем же ресурсом приводит к проблемам.
[01:45:45.240 --> 01:45:47.720]  Какой самый простой способ решить любую проблему?
[01:45:49.600 --> 01:45:51.600]  Забить.
[01:45:53.120 --> 01:45:55.120]  Давайте просто-напросто возьмем и запретим копирование.
[01:45:59.960 --> 01:46:04.480]  Давайте скажем, что если у меня умный указатель, то я просто запрещаю копирование. Копировать умные указатели нельзя.
[01:46:06.120 --> 01:46:08.120]  Ну и соответственно
[01:46:10.480 --> 01:46:12.480]  операцию копирования тоже нужно запретить.
[01:46:17.960 --> 01:46:24.320]  Берем равно delete. Все, я реализовал копирование.
[01:46:26.040 --> 01:46:28.040]  Просто запретив его.
[01:46:29.040 --> 01:46:36.560]  Окей, а что с перемещением? Нужно ли мне запрещать перемещение?
[01:46:43.200 --> 01:46:46.720]  Да, а вот с перемещением все нормально. То есть как вы ожидаете,
[01:46:47.920 --> 01:46:53.480]  вот что вы ожидаете от перемещения? То есть что если я тут напишу, например, std
[01:46:53.480 --> 01:46:58.120]  std move от ptr, что вы ожидаете?
[01:46:58.680 --> 01:47:03.720]  Вы ожидаете, что копия будет ссылаться на тот же самый объект, что и ptr, а ptr теперь
[01:47:05.520 --> 01:47:07.520]  ничем владеть не будет.
[01:47:08.320 --> 01:47:10.400]  То есть с помощью перемещения я просто передал
[01:47:11.200 --> 01:47:14.600]  владение ресурсом от ptr к его копии.
[01:47:16.080 --> 01:47:18.080]  То есть с перемещением действительно все нормально.
[01:47:19.960 --> 01:47:21.960]  Ну давайте как-нибудь реализуем.
[01:47:21.960 --> 01:47:25.200]  Вот ptr у меня теперь должен быть тем же самым, что и
[01:47:26.880 --> 01:47:31.000]  addr ptr. Что еще я должен сделать?
[01:47:34.160 --> 01:47:36.160]  Да, у addr ptr
[01:47:36.560 --> 01:47:43.360]  должен его занулить. Но опять же понятно, почему занулить, чтобы не было двойного удаления, чтобы не было такого, что у меня два указателя
[01:47:43.640 --> 01:47:45.640]  указывают на одну и ту же область памяти.
[01:47:46.200 --> 01:47:48.200]  Отлично.
[01:47:48.360 --> 01:47:50.360]  Ну и примерно то же самое.
[01:47:50.640 --> 01:47:55.720]  Я делаю в операторе присваивания smart ptr addr.
[01:47:59.600 --> 01:48:01.960]  Проверяю, присваиваю я самому себе или нет.
[01:48:05.760 --> 01:48:09.360]  Если это не так, то что-то делаю, иначе сразу возвращаю.
[01:48:11.640 --> 01:48:13.640]  Ну и что тут происходит?
[01:48:14.680 --> 01:48:19.720]  Ну то же самое. ptr равно addr ptr. То есть я забираю ресурс у другого объекта,
[01:48:20.400 --> 01:48:22.680]  а о другом объекту говорю, что ты остаешься ни с чем.
[01:48:30.120 --> 01:48:32.120]  Все или что-то еще?
[01:48:37.320 --> 01:48:39.320]  Все устраивает?
[01:48:42.880 --> 01:48:44.880]  Все подвох ищут, да?
[01:48:45.320 --> 01:48:47.600]  Нет, все нормально. Вот все, тут все ок.
[01:48:48.160 --> 01:48:54.160]  Вот, вот таким образом мы реализовали умный указатель, который нельзя копировать, но можно спокойно перемещать.
[01:48:54.600 --> 01:48:59.040]  И вот такие указатели, аналогом такого указателя, который мы сейчас написали, является
[01:49:00.560 --> 01:49:02.560]  стандартный класс std.unique.ptr.
[01:49:04.920 --> 01:49:08.680]  Умные указатели, все умные указатели стандартной библиотеки расположены в
[01:49:12.120 --> 01:49:15.720]  расположен в заголовочном файле memory.
[01:49:17.600 --> 01:49:24.040]  Вот здесь расположены все умные указатели.
[01:49:35.280 --> 01:49:37.440]  Ну вот и все. Ну короче говоря, я утверждаю, что
[01:49:38.920 --> 01:49:40.920]  только что мы сделали одну задачу из задания.
[01:49:42.320 --> 01:49:44.400]  В качестве одной из задач из задания вам нужно писать свой
[01:49:44.600 --> 01:49:50.840]  умный указатель, который является аналогом unique.ptr. Ну, мы реализовали его не полностью, там нужно еще кое-какие методы писать, но
[01:49:51.840 --> 01:49:53.840]  я не думаю, что будут большие проблемы.
[01:49:54.920 --> 01:49:56.920]  Все ли понятно?
[01:49:57.920 --> 01:49:59.920]  То есть unique.ptr
[01:50:00.000 --> 01:50:04.400]  unique.ptr это умный указатель, который есть стандартный университет, который реализует семантику
[01:50:04.840 --> 01:50:06.560]  уникального владения.
[01:50:06.560 --> 01:50:11.600]  То есть каждым ресурсом, на который указывает unique.ptr, может отводеть только один объект и никто иной.
[01:50:11.760 --> 01:50:17.400]  За счет чего это достигается? Это достигается за счет того, что я запрещаю копирование и
[01:50:19.160 --> 01:50:25.800]  разрешаю перемещение. При перемещении у меня владение передается другому объекту, то есть никакого двойного владения не происходит. Понятно?
[01:50:28.280 --> 01:50:34.160]  Вот. Какие есть еще интересные методы у unique.ptr? Ну и вообще у любого другого умного указателя. Классические методы это get.
[01:50:35.600 --> 01:50:37.880]  Get просто берет и возвращает
[01:50:37.880 --> 01:50:44.520]  указатель, ну да, просто возвращает сырой указатель.
[01:50:47.040 --> 01:50:51.720]  То есть с помощью функции get, с помощью методы get, вы можете получить указатель, который лежит
[01:50:52.240 --> 01:50:55.320]  внутри умного указателя. Вот этот самый ptr.
[01:50:56.800 --> 01:51:00.560]  Есть еще полезные методы. Наверное, полезный метод release.
[01:51:03.680 --> 01:51:05.680]  Он тоже возвращает
[01:51:06.680 --> 01:51:14.240]  сырой указатель и перестает им владеть.
[01:51:18.360 --> 01:51:23.280]  То есть если вы хотите сказать, что вот этим ресурсом все, больше не надо владеть, короче,
[01:51:23.480 --> 01:51:28.600]  unique.ptr, ты больше не ответственно за него, теперь отдавай это на откупне. Тогда вы просто вызываете release.
[01:51:28.920 --> 01:51:32.160]  Вот после того, как вызвали release, вам вернулся тот самый указатель, на который
[01:51:32.680 --> 01:51:37.880]  ссылался вот этот unique.ptr, и дальше unique.ptr ссылается на null.ptr, окей?
[01:51:41.200 --> 01:51:46.200]  Ну, когда вы делаете перемещение, вы перемещаете его в другой умный указатель. Когда вы делаете release, вы забираете его себе.
[01:51:46.960 --> 01:51:48.800]  То есть, грубо говоря,
[01:51:48.800 --> 01:51:50.800]  если у вас есть
[01:51:52.400 --> 01:51:54.400]  std
[01:51:54.400 --> 01:52:00.840]  unique.ptr, давайте p, и вы пишете new inc,
[01:52:01.720 --> 01:52:03.720]  ну, допустим, от единицы,
[01:52:04.360 --> 01:52:06.360]  то когда вы делаете
[01:52:10.960 --> 01:52:12.960]  std
[01:52:14.200 --> 01:52:16.800]  move от p, вы вот этот указатель
[01:52:17.680 --> 01:52:19.680]  переносите в новый умный указатель.
[01:52:19.680 --> 01:52:21.840]  То есть, вы говорите, что теперь этим указателем владеет
[01:52:22.120 --> 01:52:24.560]  новый умный указатель. А когда вы делаете release,
[01:52:26.800 --> 01:52:29.400]  давайте так напишем int, звездочка,
[01:52:31.320 --> 01:52:35.560]  x пусть будет равно copy.release,
[01:52:39.120 --> 01:52:44.080]  а когда вы делаете release, вы говорите, что копий теперь не владеет этим указателем,
[01:52:45.240 --> 01:52:50.040]  а указателем, то есть теперь вот этим указателем управляете вы, а не какой другой умный указатель, понятно?
[01:52:51.880 --> 01:52:53.880]  То есть, в release вы просто отлучаете
[01:52:54.120 --> 01:52:56.120]  указатель от владения этим ресурсом.
[01:52:57.240 --> 01:52:59.240]  Ну и есть еще метод
[01:53:01.080 --> 01:53:03.080]  reset,
[01:53:03.560 --> 01:53:09.360]  который принимает другой указатель, и который, давайте adder,
[01:53:12.000 --> 01:53:15.440]  меняет владение на adder.
[01:53:22.520 --> 01:53:30.840]  Если вы хотите, что ваш умный указатель теперь указывал не на x, а, скажем, на какой-то другой ресурс y, то вы звайте reset.
[01:53:31.720 --> 01:53:33.720]  Да, при этом
[01:53:33.720 --> 01:53:35.720]  старый
[01:53:37.240 --> 01:53:40.200]  ресурс удаляется.
[01:53:42.400 --> 01:53:45.480]  То есть, reset вы просто меняете один ресурс на другой.
[01:53:48.480 --> 01:53:50.480]  Ну все, и теперь у вас
[01:53:52.640 --> 01:53:57.240]  pipeline выглядит как-то так. std.unique.ptr от
[01:54:02.040 --> 01:54:05.760]  node.ptr, и вы сюда передаете new
[01:54:06.600 --> 01:54:13.680]  node. Как-то заполняете. Все, и дальше пользуетесь этим указателем через ptr, через ptr-стрелочка,
[01:54:16.240 --> 01:54:18.240]  и так далее.
[01:54:18.480 --> 01:54:24.360]  Все, ну и после того, как вам ptr больше там не нужно, после того, как вы вышли из функции main или из какой-то другой функции, то
[01:54:24.560 --> 01:54:31.600]  ptr автоматически освободится. Вот, более того, помните, когда мы писали allocate node, теперь мы решаем эту проблему.
[01:54:33.960 --> 01:54:39.960]  allocate node in x. Теперь мы можем сделать следующую вещь.
[01:54:42.000 --> 01:54:45.760]  return std.unique.ptr от node.
[01:54:48.920 --> 01:54:50.920]  new node x.
[01:54:53.040 --> 01:54:57.920]  Все, и теперь вы спокойно можете возвращать умный указатель из любой функции,
[01:54:58.920 --> 01:55:01.560]  и можете не беспокоиться о том, что там как-то
[01:55:02.280 --> 01:55:06.880]  в общем, можете не беспокоиться над тем, что для этого объекта не будет вызван delete.
[01:55:07.120 --> 01:55:11.040]  Для этого объекта в любом случае будет вызван delete. То есть, как бы вы не написали, вы можете написать тут
[01:55:11.400 --> 01:55:18.400]  after ptr равно allocate node 5 и спокойно пользоваться этим ptr-ом как обычной переменной,
[01:55:18.400 --> 01:55:22.200]  не задумываясь о том, что нужно там для него вызвать delete, что-то освободить и так далее.
[01:55:22.800 --> 01:55:25.680]  Сейчас несколько глубже погрузимся в Unique Ptr,
[01:55:27.840 --> 01:55:32.920]  и затем, я надеюсь, успеем перейти к другому умному указателю. Смотрите,
[01:55:34.320 --> 01:55:38.200]  Unique Ptr на самом деле более универсален, чем там может показаться на первый взгляд.
[01:55:38.800 --> 01:55:42.480]  Дело в том, что Unique Ptr может работать не только с памятью,
[01:55:42.880 --> 01:55:47.640]  но и вообще с любым другим ресурсом, с которым нужно что-то делать в конце.
[01:55:48.240 --> 01:55:51.040]  Давайте классический пример. Когда вы открываете файл,
[01:55:51.960 --> 01:55:57.120]  его нужно обязательно закрыть, потому что количество открытых файлов в операционной системе ограничено.
[01:55:57.760 --> 01:56:04.120]  Так вот, на самом деле Unique Ptr можно настроить по-своему, то есть, вы можете сделать так, чтобы Unique Ptr делал в конце,
[01:56:04.360 --> 01:56:07.600]  в деструкторе делал то, что вы хотите, и для этого
[01:56:08.360 --> 01:56:16.040]  у Unique Ptr есть специальный параметр, который называется Deleter. На самом деле, вот здесь в качестве второго параметра у него выступает еще один тип,
[01:56:16.960 --> 01:56:18.960]  который называется Deleter.
[01:56:19.360 --> 01:56:21.360]  У этого типа Deleter
[01:56:21.520 --> 01:56:26.000]  должны быть перегружены круглые скобки. То есть, у этого типа, который вы сюда передаете,
[01:56:26.880 --> 01:56:32.040]  у этого чего-то нужно уметь брать круглые скобки. Давайте по порядку, что я имею ввиду.
[01:56:32.440 --> 01:56:34.440]  Допустим, у вас есть...
[01:56:35.080 --> 01:56:38.600]  Давайте сразу в терминах Unique Ptr буду писать, Unique Ptr, и
[01:56:41.920 --> 01:56:43.920]  в общем,
[01:56:44.040 --> 01:56:46.040]  ну, классический способ,
[01:56:46.520 --> 01:56:52.240]  классический способ работать с файлами, там языки C, C++, это использовать так называемые функции,
[01:56:53.120 --> 01:56:55.960]  давайте файл назовем, использовать функции fopen и fclose.
[01:56:57.320 --> 01:56:59.320]  std
[01:56:59.840 --> 01:57:03.960]  fopen, ну, и вы сюда передаете какой-нибудь файл, там a.txt,
[01:57:04.440 --> 01:57:06.880]  ну, и дальше там вы открываете от файлночтения read.
[01:57:08.920 --> 01:57:13.600]  Понятное дело, что для файла, ну, да, при этом fopen, вот этот fopen возвращает
[01:57:15.520 --> 01:57:21.760]  возвращает специальный тип, который называется файл-звездочка. То есть, файл это тип файла, а звездочка это указатель на файл. То есть,
[01:57:21.960 --> 01:57:23.960]  fopen возвращает вам указатель на файл.
[01:57:24.480 --> 01:57:27.200]  Ну, понятное дело, что для файла не имеет смысла вызывать delete.
[01:57:27.920 --> 01:57:30.200]  Если вы сделаете delete от указатель на файл, то,
[01:57:30.680 --> 01:57:34.320]  во-первых, будет ошибка, потому что вы удаляете там то, что не было выделено в памяти,
[01:57:34.960 --> 01:57:40.760]  хотя нет, скорее всего выделено в памяти, но не судит. Главное, что delete не приведет к закрытию файла.
[01:57:40.920 --> 01:57:45.080]  Чтобы закрыть файл, вам нужно вызвать специальную функцию fclose.
[01:57:47.360 --> 01:57:52.480]  Ну, и передать сюда указатель на файл. Так вот, как мне заставить UniquePtr сделать так, чтобы он при
[01:57:53.360 --> 01:57:57.040]  вызове деструктора вызывал не delete, а вызывал stdf close.
[01:57:57.800 --> 01:57:59.800]  Значит, делайте это следующим образом.
[01:57:59.800 --> 01:58:01.800]  Вы пишете специальную функцию,
[01:58:02.400 --> 01:58:04.400]  ну, например, называете ее delete file.
[01:58:05.640 --> 01:58:07.640]  Это один из способов,
[01:58:07.720 --> 01:58:09.720]  который принимает
[01:58:09.960 --> 01:58:11.960]  указатель на файл.
[01:58:13.040 --> 01:58:18.080]  И даже вы в этой функции пишете, что нужно сделать. Ну, в данном случае нужно вызвать stdf close
[01:58:19.040 --> 01:58:21.040]  от файла.
[01:58:23.440 --> 01:58:28.840]  И что нужно сделать дальше? А дальше нужно STD UniquePtr сказать, что нужно использовать нестандартный удалитель,
[01:58:28.840 --> 01:58:30.840]  то есть нужно использовать необычный delete, а
[01:58:31.520 --> 01:58:33.520]  нужно использовать нечто иное.
[01:58:34.640 --> 01:58:38.360]  Ну, в частности, в качестве нечто иного должна выступать функция delete file.
[01:58:39.560 --> 01:58:41.560]  Вопрос. Какой тип имеет
[01:58:42.120 --> 01:58:44.120]  delete file?
[01:58:52.520 --> 01:58:56.080]  Вот когда вы передаете функцию в другую функцию, что вы на самом деле передаете?
[01:58:57.080 --> 01:59:03.240]  Выбираете указатель на функцию, поэтому тут нужно указать тип указатель на функцию, то есть который возвращает void и
[01:59:03.960 --> 01:59:05.960]  принимает
[01:59:05.960 --> 01:59:07.960]  указатель на файл.
[01:59:10.040 --> 01:59:16.840]  Все, и теперь что происходит? Когда вы открываете файл, здесь FOPEN, у вас возвращается указатель на файл, и вы передаете его в умный указатель.
[01:59:17.840 --> 01:59:22.800]  И дальше вторым аргументом еще передаете дополнительную функцию, которую нужно вызвать вместо обычного delete.
[01:59:22.800 --> 01:59:26.480]  И в данном случае это функция delete file.
[01:59:31.160 --> 01:59:37.920]  Вообще говоря, это не очень удобно, согласитесь, ну то есть тут нужно, то есть, во-первых, вам нужно написать отдельную функцию, ну то есть это ладно, как бы
[01:59:37.920 --> 01:59:39.920]  отдельная функция, это пойдет.
[01:59:41.000 --> 01:59:47.240]  Так вам дополнительно нужно вот здесь прописывать полный тип функции, что на самом деле не всегда довольно удобно.
[01:59:48.400 --> 01:59:51.920]  То есть это еще нужно помнить, как написать указатель на функцию и так далее.
[01:59:52.920 --> 01:59:54.920]  Поэтому классическим подходом здесь является
[01:59:56.640 --> 02:00:02.480]  использование следующего синтаксиса. Давайте я возьму и напишу отдельную структуру fileDeleter.
[02:00:09.200 --> 02:00:14.960]  Специальный класс FileDeleter, и у которого возьму и перегружу операцию круглые скобки.
[02:00:16.080 --> 02:00:21.200]  Вот, к вопросу о том, зачем нам нужно вообще перегружать круглые скобки. Вот пример.
[02:00:22.440 --> 02:00:26.440]  Ну и здесь делаю то же самое.
[02:00:28.240 --> 02:00:30.240]  std
[02:00:30.560 --> 02:00:32.560]  close
[02:00:34.720 --> 02:00:36.720]  И теперь что я делаю? Теперь я просто беру
[02:00:42.240 --> 02:00:48.640]  и в качестве второго шаблонного параметра придаю вот этот тип FileDeleter. И все.
[02:00:48.640 --> 02:00:50.640]  Как это работает?
[02:00:50.640 --> 02:00:52.640]  Работает следующим образом.
[02:00:52.640 --> 02:00:56.640]  Вот здесь есть класс Deleter. Ну давайте так, как это работает грубо.
[02:00:58.640 --> 02:01:02.640]  Тут у UniquePtr в качестве второго параметра выступает Deleter.
[02:01:03.640 --> 02:01:09.640]  Что делает UniquePtr? UniquePtr берет и в деструкторе создает объект типа Deleter.
[02:01:11.640 --> 02:01:13.640]  И дальше у этого объекта Deleter
[02:01:14.640 --> 02:01:16.640]  и дальше у этого объекта Deleter
[02:01:17.640 --> 02:01:19.640]  вызывает операцию круглые скобки.
[02:01:23.640 --> 02:01:25.640]  Понятно?
[02:01:27.640 --> 02:01:29.640]  Вот и вся магия.
[02:01:29.640 --> 02:01:31.640]  У вас может возникнуть вопрос.
[02:01:31.640 --> 02:01:35.640]  Ну смотрите, я же могу еще UniquePtr вызывать и без этого Deleter.
[02:01:35.640 --> 02:01:37.640]  Тогда мне будет вызываться Delet.
[02:01:37.640 --> 02:01:38.640]  Как это работает?
[02:01:38.640 --> 02:01:40.640]  А работает следующим образом.
[02:01:40.640 --> 02:01:47.640]  В стандарт-библиотеке вместо класса Deleter стоит класс под названием DefaultDelete.
[02:01:49.640 --> 02:01:52.640]  И вот этот класс DefaultDelete у себя в круглых скобках,
[02:01:52.640 --> 02:01:54.640]  то есть он где-то определен тоже в стандарт-библиотеке,
[02:01:54.640 --> 02:01:58.640]  и он у себя в круглых скобках просто-напросто берет и вызывает Delet.
[02:02:00.640 --> 02:02:02.640]  То есть круглые скобки для обычного Deleter,
[02:02:02.640 --> 02:02:06.640]  то есть для std DefaultDelete,
[02:02:06.640 --> 02:02:08.640]  вызывают просто Delet.
[02:02:14.640 --> 02:02:16.640]  Тут, на самом деле, еще T.
[02:02:19.640 --> 02:02:21.640]  Поэтому стандартный способ,
[02:02:21.640 --> 02:02:24.640]  то есть если вы хотите владеть ресурсом,
[02:02:24.640 --> 02:02:26.640]  который отличен от памяти,
[02:02:26.640 --> 02:02:28.640]  то есть если вы хотите управлять не памятью,
[02:02:28.640 --> 02:02:30.640]  а, скажем, какими-то другими ресурсами,
[02:02:30.640 --> 02:02:32.640]  ну сейчас эти файлами, Mutex,
[02:02:32.640 --> 02:02:34.640]  для Mutex есть другие вещи, в общем,
[02:02:34.640 --> 02:02:36.640]  для которых нет никакой обертки,
[02:02:36.640 --> 02:02:38.640]  то вы вполне можете использовать Unique PTR,
[02:02:38.640 --> 02:02:40.640]  но для этого вы должны позаботиться о том,
[02:02:40.640 --> 02:02:44.640]  чтобы вас сюда передался как корректный Deleter.
[02:02:58.640 --> 02:03:00.640]  Давайте еще пару вопросов судим.
[02:03:00.640 --> 02:03:03.640]  Тут был вопрос про то, смотрите, Unique PTR,
[02:03:03.640 --> 02:03:06.640]  а что если у меня есть Unique PTR,
[02:03:06.640 --> 02:03:10.640]  и я хочу, чтобы он ссылался не просто на один объект,
[02:03:10.640 --> 02:03:12.640]  как я писал до этого,
[02:03:12.640 --> 02:03:14.640]  а на целый массив?
[02:03:17.640 --> 02:03:20.640]  Ну, допустим, меня не устраивает вектор,
[02:03:20.640 --> 02:03:22.640]  я хочу указатель, который просто указывает
[02:03:22.640 --> 02:03:25.640]  на выделенный кусок памяти в качестве массива.
[02:03:25.640 --> 02:03:27.640]  Вот таким образом.
[02:03:29.640 --> 02:03:31.640]  Понятное дело, что это будет работать плохо,
[02:03:31.640 --> 02:03:33.640]  точнее это не будет работать,
[02:03:33.640 --> 02:03:35.640]  тут будет UndefinedBehaviour, почему?
[02:03:36.640 --> 02:03:38.640]  Потому что здесь DefaultDelete
[02:03:38.640 --> 02:03:41.640]  вызывает обычный delete без квадратных скобок.
[02:03:41.640 --> 02:03:43.640]  Понятно?
[02:03:44.640 --> 02:03:46.640]  То есть нельзя применять обычный delete
[02:03:46.640 --> 02:03:48.640]  к указателю,
[02:03:48.640 --> 02:03:51.640]  который был выделен с помощью
[02:03:51.640 --> 02:03:53.640]  new с квадратными скобками.
[02:03:53.640 --> 02:03:55.640]  То есть тут обязательно нужно вызвать delete
[02:03:55.640 --> 02:03:57.640]  с квадратными скобками.
[02:03:57.640 --> 02:03:59.640]  Как заставить это работать?
[02:03:59.640 --> 02:04:01.640]  Ну, вы можете сказать, что
[02:04:01.640 --> 02:04:03.640]  тут нужно просто прописать свой
[02:04:03.640 --> 02:04:05.640]  кастомный deletor,
[02:04:05.640 --> 02:04:07.640]  то есть написать класс deletor,
[02:04:07.640 --> 02:04:09.640]  передать его, который будет вызывать delete
[02:04:09.640 --> 02:04:11.640]  с квадратными скобками.
[02:04:11.640 --> 02:04:13.640]  Но на самом деле все сделано за вас.
[02:04:13.640 --> 02:04:15.640]  Все, что нужно сделать, чтобы это заработало,
[02:04:15.640 --> 02:04:17.640]  вам нужно тут вместо int прописать int
[02:04:17.640 --> 02:04:19.640]  квадратные скобки и все.
[02:04:19.640 --> 02:04:21.640]  То есть int квадратные скобки
[02:04:21.640 --> 02:04:23.640]  это такой специальный тип,
[02:04:23.640 --> 02:04:25.640]  который называется UnboundedArray
[02:04:25.640 --> 02:04:27.640]  или неограниченный массив.
[02:04:27.640 --> 02:04:29.640]  И как он работает?
[02:04:29.640 --> 02:04:31.640]  У default delete
[02:04:31.640 --> 02:04:33.640]  есть специализация
[02:04:33.640 --> 02:04:35.640]  на случай, когда у вас в качестве t
[02:04:35.640 --> 02:04:37.640]  выступает как раз-таки массив.
[02:04:37.640 --> 02:04:39.640]  И этот самый default delete, если у вас в качестве t
[02:04:39.640 --> 02:04:41.640]  выступает массив, он вызывает delete
[02:04:41.640 --> 02:04:43.640]  с квадратными скобками. И все прекрасно работает.
[02:04:45.640 --> 02:04:47.640]  Понятно?
[02:04:47.640 --> 02:04:49.640]  То есть мораль
[02:04:49.640 --> 02:04:51.640]  состоит в том, что если вам все-таки
[02:04:51.640 --> 02:04:53.640]  кровь из носу зачем-то нужно
[02:04:53.640 --> 02:04:55.640]  создать UniquePtr на массив,
[02:04:55.640 --> 02:04:57.640]  тогда вы в качестве параметра обязаны
[02:04:57.640 --> 02:04:59.640]  указать тип и квадратные скобки.
[02:04:59.640 --> 02:05:01.640]  И дальше вызываете new с помощью квадратных скобок.
[02:05:03.640 --> 02:05:05.640]  Если вам нужен обычный выказатель
[02:05:05.640 --> 02:05:07.640]  без массива,
[02:05:07.640 --> 02:05:09.640]  то пишите вот так.
[02:05:11.640 --> 02:05:13.640]  Понятно?
[02:05:15.640 --> 02:05:17.640]  Окей.
[02:05:19.640 --> 02:05:21.640]  Ну ладно, еще один пример.
[02:05:21.640 --> 02:05:23.640]  Давайте.
[02:05:23.640 --> 02:05:25.640]  Указать.
[02:05:29.640 --> 02:05:31.640]  Давайте
[02:05:31.640 --> 02:05:33.640]  без файлов, давайте
[02:05:33.640 --> 02:05:35.640]  сделаем так.
[02:05:35.640 --> 02:05:37.640]  Давайте я напишу функцию deliter,
[02:05:37.640 --> 02:05:39.640]  которая будет принимать int
[02:05:39.640 --> 02:05:41.640]  указатель
[02:05:41.640 --> 02:05:43.640]  и будет внутри себя делать
[02:05:45.640 --> 02:05:47.640]  deletePtr.
[02:05:49.640 --> 02:05:51.640]  Так, здесь будет обычная
[02:05:51.640 --> 02:05:53.640]  штука, здесь будет
[02:05:53.640 --> 02:05:55.640]  то же самое, но только буду сюда
[02:05:55.640 --> 02:05:57.640]  передавать void
[02:06:03.640 --> 02:06:05.640]  ptr2
[02:06:05.640 --> 02:06:07.640]  new int.
[02:06:07.640 --> 02:06:09.640]  И сделаю следующую вещь.
[02:06:09.640 --> 02:06:11.640]  Сделаю stdout
[02:06:11.640 --> 02:06:13.640]  sizeof ptr
[02:06:13.640 --> 02:06:15.640]  ptr
[02:06:19.640 --> 02:06:21.640]  и sizeof
[02:06:23.640 --> 02:06:25.640]  ptr2.
[02:06:33.640 --> 02:06:35.640]  Давайте уберем.
[02:06:43.640 --> 02:06:45.640]  Вот. И делаем химик.
[02:06:45.640 --> 02:06:47.640]  То есть смотрите, я создал uniquePtr
[02:06:47.640 --> 02:06:49.640]  и здесь в качестве deliter
[02:06:49.640 --> 02:06:51.640]  использую обычный deliter.
[02:06:51.640 --> 02:06:53.640]  То есть class deliter.
[02:06:53.640 --> 02:06:55.640]  Давайте пропишем.
[02:06:55.640 --> 02:06:57.640]  struct
[02:06:57.640 --> 02:06:59.640]  delete
[02:06:59.640 --> 02:07:01.640]  class
[02:07:01.640 --> 02:07:03.640]  Здесь я сделаю
[02:07:03.640 --> 02:07:05.640]  то, что делали до этого.
[02:07:05.640 --> 02:07:07.640]  Операторы круглые скобки
[02:07:07.640 --> 02:07:09.640]  принимают указатель на int
[02:07:09.640 --> 02:07:11.640]  const
[02:07:11.640 --> 02:07:13.640]  и делаю delete
[02:07:13.640 --> 02:07:15.640]  от ptr.
[02:07:15.640 --> 02:07:17.640]  И здесь я
[02:07:19.640 --> 02:07:21.640]  принимаю delete class, а здесь в качестве
[02:07:21.640 --> 02:07:23.640]  row параметра, да, я еще должен передать deliter.
[02:07:25.640 --> 02:07:27.640]  Здесь я хочу показать разницу между
[02:07:27.640 --> 02:07:29.640]  этими двумя способами и продемонстрировать
[02:07:29.640 --> 02:07:31.640]  еще одну проблему, которую мы касались ранее,
[02:07:31.640 --> 02:07:33.640]  но вы были еще
[02:07:33.640 --> 02:07:35.640]  маленькие, чтобы ее понять.
[02:07:35.640 --> 02:07:37.640]  Смотрите, значит,
[02:07:37.640 --> 02:07:39.640]  я написал custom deliter
[02:07:39.640 --> 02:07:41.640]  и передал его в виде класса.
[02:07:41.640 --> 02:07:43.640]  Вот.
[02:07:43.640 --> 02:07:45.640]  А здесь я написал тоже custom deliter, но передал его
[02:07:45.640 --> 02:07:47.640]  в виде функции.
[02:07:47.640 --> 02:07:49.640]  Вопрос.
[02:07:49.640 --> 02:07:51.640]  Отличаются ли как-то размеры
[02:07:51.640 --> 02:07:53.640]  ptr и ptr2?
[02:07:53.640 --> 02:07:55.640]  Кажется странно, то есть у меня есть как бы два класса,
[02:07:55.640 --> 02:07:57.640]  но они вроде как одинаковые.
[02:07:57.640 --> 02:07:59.640]  Да, то есть и
[02:07:59.640 --> 02:08:01.640]  первый хранительный указатель, и второй хранительный указатель.
[02:08:01.640 --> 02:08:03.640]  Могут ли они
[02:08:03.640 --> 02:08:05.640]  как-то отличаться по размеру?
[02:08:05.640 --> 02:08:07.640]  Ну, давайте посмотрим.
[02:08:09.640 --> 02:08:11.640]  Пу-пу-пу.
[02:08:25.640 --> 02:08:27.640]  27.
[02:08:39.640 --> 02:08:51.800]  Один умный указатель весит 8 байт, а другой умный указатель весит 16 байт. Почему так? Как вы думаете?
[02:08:51.800 --> 02:09:16.280]  Всё, на самом деле, довольно просто. Дело в том, что ответ кроется здесь. Смотрите,
[02:09:16.280 --> 02:09:21.880]  вот представьте, что должно произойти, в случае, если у меня тут в качестве дилитера выступает
[02:09:21.880 --> 02:09:33.240]  указатель на функцию. Могу ли я просто так взять и создать указатель на функцию? Нет, не могу. Но
[02:09:33.240 --> 02:09:42.080]  смотрите, в чём дело. Когда я использую обычный класс, я объект этого класса могу создать сразу в
[02:09:42.080 --> 02:09:47.000]  деструкторе и сразу же его вызвать. То есть, мне нет необходимости хранить объект этого класса.
[02:09:47.000 --> 02:10:02.680]  Понятно? То есть, я могу здесь же его создать и сразу же его вызвать. Понятно? Понятно? Нет. А что
[02:10:02.680 --> 02:10:07.600]  происходит, когда я передаю указатель на функцию? Смотрите, я обязан этот указатель на функцию где-то
[02:10:07.600 --> 02:10:14.640]  сохранить. Согласны? Если я его передаю в конструктор, то я же не могу просто так взять и по указатель
[02:10:14.640 --> 02:10:19.760]  на функцию понять, что она делает. Вот здесь, по типу класса, я сразу понимаю, что должны делать
[02:10:19.760 --> 02:10:24.080]  объект этого класса, потому что это всё находится внутри метода. Когда я передаю указатель на
[02:10:24.080 --> 02:10:28.880]  функцию, по указатель на функцию у меня нет никакого шанса понять, что делает эта функция. Но я понимаю,
[02:10:28.880 --> 02:10:35.080]  что эта функция возвращает void и принимает int указатель. Всё. Чтобы понять, что она делает,
[02:10:35.080 --> 02:10:41.120]  я должен передать ей второй аргумент. То есть, я должен передать саму функцию. А где хранится эта
[02:10:41.120 --> 02:10:51.960]  функция? Понятно дело, что эта функция или этот указатель на функцию должен храниться непосредственно
[02:10:51.960 --> 02:10:56.120]  в поле этого класса. То есть, я должен дополнительно в конструкторе, вот здесь,
[02:10:56.120 --> 02:11:04.600]  то есть, я должен уникptr, то есть, я должен тут сохранить сам указатель и более того,
[02:11:04.600 --> 02:11:13.320]  должен сохранить сам deliter. То есть, я должен сохранить в поле ptr и ещё должен в отдельное поле deliter
[02:11:13.320 --> 02:11:22.240]  сохранить переданный deliter. Понятно? То есть, когда я передаю указатель на функцию, я обязан самому
[02:11:22.240 --> 02:11:26.920]  эту функцию, точнее, сам вот этот указатель, сам адрес этой функции, должен ещё дополнительно хранить.
[02:11:26.920 --> 02:11:35.640]  Если я использую обычный класс, то я объект класса хранить не должен. То есть, я могу просто создать
[02:11:35.640 --> 02:11:41.920]  его внутри деструктора и сразу его вызвать. Всё. И поэтому в первом случае, когда я передаю класс,
[02:11:41.920 --> 02:11:46.760]  у меня сам указатель весит 8 байт, ну, собственно, сколько весит обычный указатель. А в втором случае
[02:11:46.760 --> 02:11:51.800]  у меня объект указателя весит 16 байт, потому что 8 байт у меня отводится под сам ресурс и
[02:11:51.800 --> 02:11:58.280]  ещё 8 байт я храню функцию, которая меня что-то удаляет. И вот в этом, собственно, и заключается
[02:11:58.280 --> 02:12:01.880]  преимущество использования вот таких вот классов, которые перегружают круглые скобки.
[02:12:01.880 --> 02:12:16.040]  Окей? Всё понятно? Ну вот. Ну ладно, это такой, в общем, офтоп про правильно использование. В общем,
[02:12:16.040 --> 02:12:21.560]  правильнее, если вам нужен кастомный deliter, то пишите свой класс, а не функцию. Ну и свой deliter
[02:12:21.560 --> 02:12:28.680]  вам в задании, кажется, не надо будет реализовывать, поэтому можете расслабиться. Вот. Хорошо. Есть ещё
[02:12:28.680 --> 02:12:42.840]  вопросы по уникальному указателю, по UniquePTR? Хорошо. Ну и теперь давайте перейдём к, ну попробуем
[02:12:42.840 --> 02:12:51.000]  кратко хотя бы обсудить другой указатель, который называется sharedPTR. Значит, смотрите,
[02:12:51.000 --> 02:12:55.240]  у нас был UniquePTR. UniquePTR — это умный указатель, который реализует семантику уникального
[02:12:55.240 --> 02:12:59.680]  владения. Ну, от слова Unique. То есть, грубо говоря, вот это слово Unique, оно отвечает на вопрос,
[02:12:59.680 --> 02:13:06.240]  что нужно делать в перекопировании. Давайте вспомним. Вот у меня есть умный указатель PTR,
[02:13:06.240 --> 02:13:17.760]  и он указывает на некоторый ресурс. Я создаю копию этого указателя, и умный указатель,
[02:13:17.760 --> 02:13:23.160]  точнее, уникальный указатель UniquePTR, мне вот это дело запрещает. А давайте теперь вернёмся к
[02:13:23.160 --> 02:13:27.560]  изначальной идее, которая у нас была. Мы вроде как говорили о том, что когда мы копируем один
[02:13:27.560 --> 02:13:33.920]  указатель в другой, у нас должен создаться другой умный указатель copy, который ссылается на тот же
[02:13:33.920 --> 02:13:42.400]  самый ресурс. Да. Но мы говорили, что у нас есть проблема, которая состоит в том, что если у меня
[02:13:42.400 --> 02:13:46.200]  несколько указателей, несколько умных указателей указывают на один и тот же ресурс, то возможно
[02:13:46.200 --> 02:13:50.960]  проблема двойного удаления. То есть непонятно, кто должен удалить этот ресурс, вот этот PTR или вот этот
[02:13:50.960 --> 02:13:58.840]  copy. Но теперь всё-таки давайте не будем закрывать глаза на эту проблему, а пробуем её решить. Вот эту
[02:13:58.840 --> 02:14:04.440]  проблему решает класс SharedPTR, устройство которого мы сейчас обсудим и которое вам тоже нужно будет
[02:14:04.440 --> 02:14:11.760]  реализовать в задании. Сейчас мы поговорим просто про алгоритм, про то, как там всё устроено. Ну,
[02:14:11.760 --> 02:14:21.880]  смотрите, вопрос. Вот, допустим, в какой-то момент у меня вызывается деструктор для PTR. Должен ли я
[02:14:21.880 --> 02:14:32.400]  удалять этот ресурс? Вот, да, смотрите, на данной картинке. Если у меня удаляется PTR, то есть я вызвал
[02:14:32.400 --> 02:14:36.800]  деструктор для PTR, то в данном случае delete я вызывать не должен. Почему? Потому что на него
[02:14:36.800 --> 02:14:41.760]  кто-то другой указывает. То есть если кто-то другой на него указывает, то значит этот ресурс кому-то
[02:14:41.760 --> 02:14:48.760]  ещё нужен. Раз он кому-то ещё нужен, то удалять его рано. Окей, а теперь я удаляю copy. Нужно ли удалять
[02:14:48.760 --> 02:14:54.280]  этот ресурс? Да, после удаления, то есть мы видим, что после удаления вот этого указателя на этот
[02:14:54.280 --> 02:14:59.680]  ресурс больше никто не указывает. А раз на него больше никто не указывает, я могу спокойно вот эту
[02:14:59.680 --> 02:15:06.320]  штуку взять и удалить. Остаётся, собственно, глобальный вопрос. Как внутри деструктора понять,
[02:15:06.320 --> 02:15:19.920]  сколько объектов, точнее сколько указателей указывает на данный ресурс? Отлично. Давайте это обсудим.
[02:15:19.920 --> 02:15:30.440]  Shared PTR. Значит, предлагается следующая вещь. Предлагается завести некоторое статическое поле static
[02:15:30.440 --> 02:15:47.760]  size t к nt, которое будет хранить... что будет хранить? Количество указателей, которые указывают на объект,
[02:15:47.760 --> 02:16:03.120]  ну по идее. Смотрите, в чём проблема. Дело в том, что со статик не прокатят. И вот почему. Допустим,
[02:16:03.120 --> 02:16:14.760]  я объявляю Shared PTR, туда что-то передаю, создаю новый ресурс. То есть у меня есть PTR, который указывает
[02:16:14.760 --> 02:16:20.840]  на некоторый ресурс. Так как я этот ресурс создал, то предполагается, что в конструкторе я сделаю
[02:16:20.840 --> 02:16:29.640]  плюс-плюс к nt. В конструкторе. Такая идея. Ну хорошо, сделал плюс-плюс к nt, и у меня в статическом поле теперь хранится
[02:16:29.640 --> 02:16:48.600]  единица. Хорошо? Как скажете. А теперь я создаю другой Shared PTR. B, который указывает на другой ресурс.
[02:16:59.640 --> 02:17:24.160]  Ответьте ему, напишите, что вы думаете по этому поводу. Отлично. Ответьте за меня, пожалуйста. Так,
[02:17:24.200 --> 02:17:37.120]  возвращаемся сюда. Я создал объект A. При создании объекта, я увеличиваю счётчик на единицу. Создаю
[02:17:37.120 --> 02:17:47.960]  другой объект B, ну совсем другой. То есть тут свой, тут один new, тут другой new. Что у меня происходит при
[02:17:47.960 --> 02:17:57.520]  создании второго объекта? knt увеличивается на 1. 2. А теперь что происходит дальше? Ну вот,
[02:17:57.520 --> 02:18:03.320]  смотри, допустим, я написал это всё внутри одной функции. Что происходит дальше? У меня вызывается
[02:18:03.320 --> 02:18:11.880]  деструктор для B. Так, хорошо, вызывается деструктор для B, и что я должен сделать со счётчиком? Уменьшаю
[02:18:11.880 --> 02:18:21.720]  на единицу. Один. Потом меня вызывается деструктор для A. Счётчик уменьшается на нуля, и в этот
[02:18:21.720 --> 02:18:29.800]  момент я удаляю объект. А с этим объектом что делать? Ну то есть, я так понимаю, ваша идея звучала
[02:18:29.800 --> 02:18:38.160]  следующим. Деструктор должен выглядеть так. Вы делаете –- knt, и if knt равно равно нулю, вот в
[02:18:38.160 --> 02:18:51.760]  этот момент вы должны сделать delete ptr. Кажется, я показал, что это не работает. Да, потому что если
[02:18:51.760 --> 02:18:57.480]  вы храните статическое поле, то вот этот knt, он хранит общее количество умных указателей в мире.
[02:18:57.480 --> 02:19:02.960]  Но при этом для каждого конкретного объекта вы не можете отслеживать. То есть мы же хотим
[02:19:02.960 --> 02:19:06.240]  всё-таки для каждого объекта понять, что вот на этот объект указывает один, на этот объект
[02:19:06.240 --> 02:19:11.920]  указывает один. Если вы храните общее количество объектов с shardptr, то у вас удалится только один
[02:19:11.920 --> 02:19:16.840]  ресурс. То есть, когда у вас все shardptr закончится, у вас удалится только один последний ресурс, и всё.
[02:19:16.840 --> 02:19:24.360]  А вот эти остальные, они останутся. Поэтому вы со статическим полем не угадали. Ну хорошо,
[02:19:24.360 --> 02:19:39.040]  давайте не статическое поле. Ну, можно так, давайте попробуем вот так. Давайте попробуем избавиться от
[02:19:39.040 --> 02:19:47.840]  статичности. Давайте я заведу обычное поле knt. Ну, которое будет хранить не общее количество shardptr,
[02:19:47.840 --> 02:19:55.720]  а, скажем, внутри каждого shardptr будет хранить свой счётчик. Давайте так попробуем. Будет ли тут проблема?
[02:19:55.720 --> 02:20:12.880]  Именно. Ну, смотрите, что происходит. Вот, допустим, у меня есть A. Изначально, когда я создавал A,
[02:20:12.880 --> 02:20:20.080]  у меня счётчик A стал равным единице. Дальше я создал B с помощью копирования от A. Ну, смотрите,
[02:20:20.080 --> 02:20:24.280]  если я копирую B от A, то, наверное, я понимаю, что раз тут единица, то я должен поставить двойку.
[02:20:24.280 --> 02:20:32.080]  Ну и плюс я у A тоже могу поставить двойку. Согласны? Окей. А теперь я создаю C. Как я создаю C?
[02:20:32.080 --> 02:20:39.200]  Ну, допустим, я создаю C от B. Что у меня происходит? Ну, я вижу, что в B хранится двойка, поэтому тут
[02:20:40.160 --> 02:20:46.280]  хранится тройка, и у B тоже могу обновить двойку на тройку. А кто будет исправлять счётчик для A?
[02:20:46.280 --> 02:20:57.680]  Ну, более того, если у меня на один ресурс указывает много-много E, F, G, H, если у меня на один объект
[02:20:57.680 --> 02:21:04.760]  указывает много умных указателей, то при добавлении нового умного указателя мне нужно у всех них
[02:21:04.760 --> 02:21:14.960]  увеличить счётчик на единицу. То есть мне нужно как-то по объекту уметь понимать, уметь находить
[02:21:14.960 --> 02:21:19.400]  вообще все умные указатели, которые на него указывают. Но, кажется, это не решаемая проблема.
[02:21:19.400 --> 02:21:26.000]  Возможно, решаемая, но кажется, что это слишком сложно. Согласны? Понятна проблема. Понятно,
[02:21:26.000 --> 02:21:42.960]  почему вот так тоже нельзя. Беда. Ну, а оказывается, что правильное решение уже прозвучало. Повторите.
[02:21:42.960 --> 02:22:02.840]  Ну, например. Да, давайте делать следующую вещь. Давайте внутри sharedPTR хранить... ну, давайте упрости.
[02:22:02.840 --> 02:22:17.400]  Давайте будем хранить указатель на данные PTR и дополнительно будем хранить указатель на счётчик.
[02:22:17.400 --> 02:22:28.200]  То есть давайте делать так. Для каждого объекта будем создавать свой счётчик. И будем хранить не
[02:22:28.800 --> 02:22:35.400]  только указатель на сам объект, но ещё указатель на его счётчик. То есть смотрите, что я предлагаю.
[02:22:35.400 --> 02:22:52.400]  Есть sharedPTR х, который создается с помощью newInt. Значит, внутри a мы храним указатель на сам
[02:22:52.400 --> 02:23:16.640]  int, то есть на сам ресурс. И плюс дополнительно храним указатель на счётчик. Окей? Теперь, если я захочу
[02:23:16.880 --> 02:23:30.880]  создать копию, копию это умный указатель, то что я должен сделать? Да, во-первых, этот указатель copy тоже хранит
[02:23:30.880 --> 02:23:40.080]  внутри себя два указателя. Указатель на данные и плюс указатель на счётчик. То есть я беру и указываю на те
[02:23:40.080 --> 02:23:44.960]  же самые данные. И плюс здесь указываю на тот же самый счётчик. То есть теперь у меня все объекты
[02:23:44.960 --> 02:23:50.240]  ссылаются на один и тот же счётчик для каждого объекта. Да, ну и плюс, понятное дело, я тут должен увеличить на два.
[02:23:50.240 --> 02:23:58.240]  И всё, и все проблемы решены. Когда я копирую a в копе, копе сохраняет указатель на этот счётчик и плюс этот счётчик
[02:23:58.240 --> 02:24:06.240]  я увеличиваю на единицу. И теперь изменение этого счётчика видят вообще все объекты. Понятно?
[02:24:06.240 --> 02:24:25.520]  А вот так делать нельзя. Сейчас мы это обсудим, да, но давайте пока просто, чтобы все понимали, что происходит.
[02:24:25.520 --> 02:24:33.520]  Значит, если у меня a, b и c, a, b, c, d указывают на один и тот же ресурс, то картинка выглядит следующим образом.
[02:24:34.320 --> 02:24:40.800]  Во-первых, они все указывают на один и тот же ресурс, а во-вторых, у них внутри хранится указатель на один и тот же счётчик.
[02:24:40.800 --> 02:24:50.800]  То есть они дополнительно ещё хранят указатели вот сюда. И все они видят одно и то же значение.
[02:24:50.800 --> 02:25:04.080]  Окей? То есть теперь давайте напишем хотя бы деструктор. Как должен работать деструктор? Ну, очень просто.
[02:25:04.080 --> 02:25:14.080]  Ну, тут у меня называется кнт поле, давайте так его будем обозначать. Я делаю минус-минус разыминованный кнт.
[02:25:14.080 --> 02:25:23.360]  Чтобы удалить указатель, я должен сказать, что всё, я пошёл пока уменьшить счётчик.
[02:25:23.360 --> 02:25:37.360]  А дальше что я делаю? Да, смотрите, если счётчик не обнулился, то в принципе всё. Я заканчиваю работу и ничего не делаю.
[02:25:37.360 --> 02:25:48.640]  То есть вот эти ресурсы должен удалить за меня кто-то другой. А если счётчик обнулился, то есть если кнт стал равен нулю, то в этот момент я должен выполнить некоторую работу.
[02:25:48.640 --> 02:26:04.640]  Ну, в частности, я должен сделать delete от ptr и более того, я должен сделать delete от кнт. То есть я должен удалить не только ресурс, но и счётчик. Понятно?
[02:26:07.360 --> 02:26:18.640]  Ну, вот, собственно, примерный алгоритм того, как должен работать shared ptr. То есть помимо того, что мы выделяем ресурс для самого объекта, мы ещё должны...
[02:26:18.640 --> 02:26:26.640]  Да, ещё надо не забыть, что в конструкторе shared ptr, если мы создаёмся от нового указателя, то нужно ещё дополнительно выделить память под указатель.
[02:26:26.640 --> 02:26:33.920]  Счётчик, точнее. Понятно?
[02:26:34.240 --> 02:26:36.240]  Так.
[02:26:48.240 --> 02:27:00.960]  Да, да. Да, то есть вопрос из зала был ещё вот такой. Ну, смотрите, мы же, ну, понятное дело, что можем делать так.
[02:27:01.040 --> 02:27:20.240]  То есть ещё раз, shared ptr a, допустим, new int. Ну, и понятное дело, что, скажем, кошерным способом создавать новый указатель на тот же объект является вот такой.
[02:27:20.720 --> 02:27:34.640]  Ну, а вы можете возить вопрос. Ну, смотрите, ну, я же могу сделать вот так. shared ptr c, ну, нет, b, и передать сюда, например, a точкой get.
[02:27:34.640 --> 02:27:43.680]  Ну, get возвращает указатель, который лежит. То есть вот этот самый указатель вот на этот ресурс. Что в этот момент произойдёт?
[02:27:43.760 --> 02:27:55.280]  Ну, вот так, короче, делать нельзя. Если вы сделали вот так, то есть если вы создали shared ptr на сурой указатель, который уже лежит в каком-то умном указателе, то вы как бы сам дурак.
[02:27:55.280 --> 02:28:05.280]  В общем, вот так делать нельзя. Единственный способ, с помощью которого может создавать shared ptr, это вот так. new что-то что-то.
[02:28:05.280 --> 02:28:16.320]  Ну, или где-то сделать, ну, короче, давайте так, давайте договоримся вот так. Что-то нужно делать вот так, а передавать сюда уже какой-то другой указатель нельзя.
[02:28:16.320 --> 02:28:23.840]  То есть вы создаете shared ptr только от нового указателя, либо от какого-то уже существующего shared ptr.
[02:28:24.720 --> 02:28:34.720]  У unique ptr, кстати, тоже такая проблема есть. Мы этого не обсуждали, но вообще говоря, вам никто не запрещает сделать, например, вот так.
[02:28:35.600 --> 02:29:03.600]  After p равно new int и сделать вот так. std unique ptr от int ptr от p и std unique ptr от int ptr2 от p.
[02:29:04.480 --> 02:29:08.480]  То есть в принципе никто вам так не запрещает сделать, но проблемы вы видите.
[02:29:08.480 --> 02:29:18.480]  У вас и вот этот unique ptr, и вот этот unique ptr указывают на один тот же ресурс. Ну и тут уже как бы двойной delete неизбежен, поэтому вот так делать нельзя.
[02:29:22.480 --> 02:29:30.480]  То есть умные указатели, то есть мораль в чем? Умные указатели вы можете создавать только от выражения new, либо от других умных указателей.
[02:29:31.360 --> 02:29:41.360]  Все остальное вот в таком духе приводит к undefined behavior. То есть вот так пользоваться умным указателям нельзя.
[02:29:45.360 --> 02:29:51.360]  Так, ну и осталось 5 минут, ну давайте еще один момент связанный с shared ptr обсудим.
[02:29:51.360 --> 02:29:57.360]  Все остальное обсудите на семинарах, ну и там в задании кажется довольно подробно.
[02:29:58.240 --> 02:30:04.240]  Все остальное описано. У shared ptr есть одна проблема.
[02:30:08.240 --> 02:30:10.240]  И вот какая.
[02:30:11.120 --> 02:30:31.120]  Представьте себе, что у вас есть объект a, и у него в качестве поля есть shared ptr.
[02:30:31.120 --> 02:30:35.120]  Ну а здесь допустим хранится какое-то значение int.
[02:30:36.000 --> 02:30:38.000]  Ну допустим вы пишете, не знаю, двусвязанный список.
[02:30:38.000 --> 02:30:44.000]  Ну давайте так, ну неважно вообще какой список, ну просто у вас есть умный указатель и int.
[02:30:46.000 --> 02:30:52.000]  Есть другой объект a, в котором тоже есть shared ptr и int.
[02:30:54.000 --> 02:30:56.000]  Ну и представьте себе, я сделал следующую вещь.
[02:30:58.000 --> 02:31:04.000]  Здесь я вот этот shared ptr указываю сюда, а вот этот shared ptr указываю сюда.
[02:31:06.000 --> 02:31:10.000]  Ну вы можете спросить, как такое может вообще произойти?
[02:31:10.000 --> 02:31:12.000]  Ну на самом деле очень просто.
[02:31:12.000 --> 02:31:14.000]  Если вы пишете двусвязанный список,
[02:31:16.000 --> 02:31:18.000]  у вас же тут есть next,
[02:31:18.000 --> 02:31:20.000]  у вас тут есть prev,
[02:31:20.000 --> 02:31:22.000]  тоже next,
[02:31:22.000 --> 02:31:24.000]  есть prev,
[02:31:24.000 --> 02:31:26.000]  ну и тут value.
[02:31:26.000 --> 02:31:30.000]  Если вы пишете двусвязанный список, допустим на умных указателях,
[02:31:30.000 --> 02:31:32.000]  у вас может возникнуть соблазн и написать его на shared ptr.
[02:31:32.880 --> 02:31:34.880]  Ну и что делаете?
[02:31:34.880 --> 02:31:36.880]  Вы next указываете сюда, а prev указываете вот сюда.
[02:31:40.880 --> 02:31:42.880]  И у вас возникает вот такой вот цикл.
[02:31:42.880 --> 02:31:46.880]  Один узел указывает на другой узел, а второй узел указывает на первый.
[02:31:46.880 --> 02:31:48.880]  В чем тут проблема?
[02:31:48.880 --> 02:31:50.880]  Ну давайте вот на этой картинке.
[02:31:50.880 --> 02:31:52.880]  Что тут не так?
[02:31:53.760 --> 02:31:55.760]  Ну да, смотрите.
[02:32:03.760 --> 02:32:05.760]  Вот допустим я храню...
[02:32:05.760 --> 02:32:07.760]  Во-первых, понятное дело, что вот такая вот картинка,
[02:32:07.760 --> 02:32:09.760]  она никогда не удалится.
[02:32:09.760 --> 02:32:11.760]  Почему?
[02:32:11.760 --> 02:32:13.760]  Потому что количество указателей, которые указывают на этот объект,
[02:32:13.760 --> 02:32:15.760]  равно единице.
[02:32:15.760 --> 02:32:17.760]  Количество указателей, которые указывают на этот объект,
[02:32:17.760 --> 02:32:19.760]  тоже равно единице.
[02:32:19.760 --> 02:32:21.760]  То есть у вас получается...
[02:32:22.640 --> 02:32:24.640]  То есть у вас получились такие циклические ссылки.
[02:32:24.640 --> 02:32:26.640]  То есть один объект ссылается на другой,
[02:32:26.640 --> 02:32:28.640]  но при этом внешних указателей на них нет.
[02:32:28.640 --> 02:32:30.640]  То есть такая самостоятельная структура,
[02:32:30.640 --> 02:32:32.640]  которая будет вечно висеть в памяти.
[02:32:32.640 --> 02:32:34.640]  Понятно?
[02:32:34.640 --> 02:32:36.640]  Так вот, чтобы решать такие проблемы,
[02:32:38.640 --> 02:32:40.640]  в стандартной библиотеке C++ есть,
[02:32:42.640 --> 02:32:44.640]  помимо shared ptr,
[02:32:48.640 --> 02:32:50.640]  есть еще и слабый указатель,
[02:32:51.520 --> 02:32:53.520]  Vicptr.
[02:32:57.520 --> 02:32:59.520]  Vicptr, это умный указатель,
[02:33:09.520 --> 02:33:11.520]  который
[02:33:15.520 --> 02:33:17.520]  не учитывается
[02:33:21.520 --> 02:33:23.520]  при подсчете ссылок.
[02:33:27.520 --> 02:33:29.520]  Короче говоря,
[02:33:29.520 --> 02:33:31.520]  если вы реализуете...
[02:33:31.520 --> 02:33:33.520]  Давайте тут нарисую
[02:33:37.520 --> 02:33:39.520]  досвязный список.
[02:33:43.520 --> 02:33:45.520]  Ну, у вас тут есть указатель head,
[02:33:45.520 --> 02:33:47.520]  то есть голова списка.
[02:33:47.520 --> 02:33:49.520]  Есть tail, хвост списка.
[02:33:50.400 --> 02:33:52.400]  И тут у вас есть указатель на next.
[02:33:56.400 --> 02:33:58.400]  Вот если вы заведете shared ptr в обратную сторону,
[02:34:00.400 --> 02:34:02.400]  то у вас возникнет вот такая проблема
[02:34:02.400 --> 02:34:04.400]  циклических ссылок.
[02:34:04.400 --> 02:34:06.400]  Так вот, чтобы такой проблемы не возникало,
[02:34:06.400 --> 02:34:08.400]  предлагается вот здесь
[02:34:12.400 --> 02:34:14.400]  вместо shared ptr использовать Vicptr.
[02:34:15.280 --> 02:34:17.280]  Vicptr, как тут написано,
[02:34:17.280 --> 02:34:19.280]  они не учитываются при подсчете ссылок.
[02:34:23.280 --> 02:34:25.280]  То есть вот на этот объект указывает
[02:34:25.280 --> 02:34:27.280]  две ссылки,
[02:34:27.280 --> 02:34:29.280]  вот на этот объект указывает
[02:34:29.280 --> 02:34:31.280]  одна ссылка,
[02:34:31.280 --> 02:34:33.280]  вот на этот объект одна ссылка,
[02:34:33.280 --> 02:34:35.200]  на этот объект указывает две ссылки.
[02:34:35.200 --> 02:34:37.200]  Вот эти ссылки не учитываются.
[02:34:37.200 --> 02:34:39.200]  Теперь все работает нормально.
[02:34:39.200 --> 02:34:41.200]  Теперь когда у вас будет вызван
[02:34:41.200 --> 02:34:43.200]  деструктор для списка,
[02:34:43.200 --> 02:34:45.700]  Удалите вот этот указатель и удалите вот этот указатель.
[02:34:45.700 --> 02:34:52.320]  Когда удалится вот этот указатель, число ссылок на этот объект
[02:34:52.400 --> 02:34:54.000]  станет равно мяде.
[02:34:54.000 --> 02:34:56.200]  При että число ссылок на этот объект стало равным нулю,
[02:34:56.200 --> 02:34:57.440]  что для него будет вызовано?
[02:34:57.440 --> 02:34:58.360]  Деструктор.
[02:34:58.360 --> 02:35:00.260]  Для него вызвали деструктор.
[02:35:00.260 --> 02:35:02.440]  Так как для него вызван деструктор, то число ссылок на» этот объект
[02:35:02.440 --> 02:35:03.680]  станет равным нулю.
[02:35:03.680 --> 02:35:06.140]  Ну и так далее.
[02:35:10.140 --> 02:35:10.640]  Все.
[02:35:10.640 --> 02:35:10.920]  И никакой проблемы.
[02:35:10.920 --> 02:35:22.920]  проблемы. Понятно? Вот. Тут есть еще одна проблема
[02:35:22.920 --> 02:35:34.200]  связанная с wik.ptr. Дело в том, что если у вас есть
[02:35:34.200 --> 02:35:39.000]  какой-то ресурс, и представь себе, что на этот объект
[02:35:39.000 --> 02:35:47.000]  есть сильная ссылка shard, и еще есть wik-ссылка.
[02:35:47.000 --> 02:35:53.000]  Вот здесь есть проблема, которая заключается в том, что если вдруг вот эта сильная ссылка умерла,
[02:35:53.000 --> 02:35:59.000]  то она за собой дополнительно удаляет как ресурс, так и счетчик.
[02:35:59.000 --> 02:36:03.000]  И теперь, когда вы попытаетесь использовать вот этот wik.ptr,
[02:36:03.000 --> 02:36:07.000]  вы будете ссылаться на уже удаленные выказатели и на удаленные счетчики.
[02:36:07.000 --> 02:36:11.000]  И в этом проблема. Но эту проблему, видимо, обсудите на семинарах,
[02:36:11.000 --> 02:36:15.000]  или на следующей лекции начнем с этого и перейдем к следующей теме.
[02:36:15.000 --> 02:36:17.000]  На сегодня все. Спасибо.
