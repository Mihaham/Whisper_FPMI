[00:00.000 --> 00:10.000]  Ну, до сего момента мы говорили о уровне изи – поиска подспечной строки.
[00:10.000 --> 00:15.000]  Дана одна строка, один шаблон, один текст. Найдите все картинки шаблонов текста.
[00:15.000 --> 00:20.000]  Сейчас мы попытаемся повысить планочку.
[00:21.000 --> 00:28.000]  Теперь мы представим, что у нас этих шаблонов много.
[00:28.000 --> 00:33.000]  А именно, к штуку.
[00:33.000 --> 00:38.000]  И один текст D.
[00:38.000 --> 00:45.000]  Вот строчки тут самые разные.
[00:45.000 --> 00:49.000]  Нам очень хочется найти...
[00:49.000 --> 00:52.000]  Ну, например, давайте будем решать задачу в такой постановке.
[00:52.000 --> 00:59.000]  Все обхождения всех этих строчек в тексте.
[00:59.000 --> 01:08.000]  Ну, давайте подумаем, за какую идеальную асимптотику можно было бы это сделать.
[01:08.000 --> 01:11.000]  Ну, идеальная асимптотика, конечно, трачет.
[01:11.000 --> 01:16.000]  Ну, конечно, в идеале было бы, что сумма всех асимптов плюс модуль T.
[01:16.000 --> 01:18.000]  В идеале.
[01:18.000 --> 01:22.000]  Но это исключительно в идеале.
[01:22.000 --> 01:25.000]  Потому что, заметим, иногда это невозможно в принципе.
[01:25.000 --> 01:27.000]  Почему?
[01:27.000 --> 01:33.000]  Потому что, возможно, у нас в хождении этих строчек будет больше.
[01:33.000 --> 01:36.000]  Ну, например, если строчки будут там одинаковые, например.
[01:37.000 --> 01:46.000]  Или даже, если не одинаковые, но, например, если это будут строчки A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A.
[01:46.000 --> 01:50.000]  И текст T такой, состоит естественно из ничь той перезбуковой A.
[01:50.000 --> 01:55.000]  Тогда и хождение тут дошешать даже больше.
[01:55.000 --> 02:14.000]  Поэтому да, то есть это их всегда достижило, но можно сделать так, можно сделать так, написать такую идеальную ассимпточку, размер ответа.
[02:14.000 --> 02:29.000]  Ну, например, мы говорим, что размер ответа может быть сильно большой, поэтому мы говорим, что идеально, но меньше, что мы точно не сможем обойти.
[02:29.000 --> 02:38.000]  Это точно нам потребуется от стока времени, чтобы хотя бы считать данные, и от ответа для того, чтобы их хотя бы куда-то там написать или вернуть.
[02:38.000 --> 02:47.000]  Ну, дальше, конечно, это может зависеть от формата ответа, потому что иногда, на самом деле, размер ответа можно ограничить.
[02:47.000 --> 03:04.000]  В худшем случае размер ответа это, конечно, t умножить на k, правда? Но это в совсем худшем случае, это когда все строчки из одной буквы состоят, а тут тексты из этой буквы тоже состоят, правда?
[03:04.000 --> 03:19.000]  Вот. А теперь давайте себе представим. Ну, то есть, на самом деле, без ограничения особого общности, но с большим приятностью мы будем считать, что все эти строчки попарно, допустим, различны.
[03:19.000 --> 03:49.000]  Ну, действительно, если там выяснилось, если там, например, в процессе выяснилось, что какие-то строчки две там совпадают, то для них вхождения будут одни и те же, тогда мы можем сказать, что когда будем выводить ответ, что для вот этой, вот этой, вот этой они одинаковы, поэтому вхождения для них вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-
[03:49.000 --> 04:18.000]  оказывается, что, на самом деле, с помощью этого, на самом деле, можно лучше оценить, на самом деле, даже ответ, то есть ответ уже даже не совсем t умножить на k, хотя, конечно, ну, то есть, те теоретически может быть, что тут все эти строчки с одной буквы только теперь разные, а в t там поровну всех примеров, как керс писается, но правда, тогда это будет означать, что суммарное число вхождений всех строчек не более чем t, правда?
[04:19.000 --> 04:25.000]  Это может быть t плюс, ну, типа t плюс t, 72 плюс t, да, и плюс t минус k плюс 1.
[04:25.000 --> 04:27.000]  Ну, можно.
[04:27.000 --> 04:33.000]  Ну, если это a, a, a, a, a, a, ну, в общем, то призашек все разные.
[04:33.000 --> 04:37.000]  Да, может, может. Но тут, да.
[04:37.000 --> 04:39.000]  И это все равно t от...
[04:39.000 --> 04:47.000]  Да, то есть t у нас на k все еще может быть, но, тем не менее, с другой стороны, тогда мы обнаружим, что при этом k не может быть сильно большим.
[04:48.000 --> 04:57.000]  Потому что, например, если мы 100 тысяч таких строчек, мы сделать не можем, потому что тогда у нас количество символов будет там 100 тысяч в квадрате, ладно, пополам, но все равно многовато.
[05:02.000 --> 05:08.000]  Но, на самом деле, оказывается, количество вхождений можно оценить и лучшим способом.
[05:08.000 --> 05:10.000]  Смотрите.
[05:10.000 --> 05:18.000]  Давайте начнем с того, что давайте рассмотрим случаи, когда длины всех s и t одинаковые и равны a.
[05:18.000 --> 05:27.000]  Вот давайте себе представим, что у нас все эти строчки абсолютно одинаковые длины и при этом поопарно различны.
[05:34.000 --> 05:36.000]  Что тогда?
[05:36.000 --> 05:39.000]  Тогда ответ не больше, чем длина t.
[05:39.000 --> 05:43.000]  Тогда заметим, что вхождений не более, чем даже...
[05:43.000 --> 05:52.000]  То есть размер ответа не более, чем, я бы даже сказал, длина t минус l плюс 1, даже, если уж совсем дирократизироваться.
[05:52.000 --> 06:00.000]  Потому что любая у нас ровно столько вхождений, то есть ровно столько подстрок длины l, и каждая из них может совпадать не более, чем с одной из них.
[06:00.000 --> 06:02.000]  Понимаете, да?
[06:04.000 --> 06:06.000]  Понимаете?
[06:06.000 --> 06:08.000]  Вот, понимаете?
[06:09.000 --> 06:11.000]  Вот.
[06:11.000 --> 06:22.000]  И тогда получается, да, то есть если бы у нас был этот черный ящик, который для любых подстрок, любых заданных строк говорил, нам совпадают эти подстроки или нет, то мы, в принципе, за линию бы все и нашли, правда?
[06:22.000 --> 06:31.000]  То есть вычислили бы, то есть запихнули бы эти строки в какой-нибудь там, их хэши, например, в анорберет мап какой-нибудь.
[06:31.000 --> 06:37.000]  И, соответственно, в том, для каждой подстроки вычитали бы хэш, лазили бы в анорберет мап, мы, условно, как-то так бы делали.
[06:37.000 --> 06:43.000]  Да, вот, мы не знаем, что такое хэши, но виктуально, как-то есть у нас это мистическое число.
[06:43.000 --> 06:50.000]  Вот, но получается, да, если все строки одинаковые, то вхождений от t.
[06:54.000 --> 06:59.000]  Вхождений действительно, то размер ответа не более чем t минус l плюс 1.
[07:00.000 --> 07:03.000]  Но отсюда, на самом деле, возникает естественный момент.
[07:04.000 --> 07:09.000]  Смотрите, если у нас все строки разные, то давайте сделаем вот что.
[07:09.000 --> 07:16.000]  Давайте эти строки разделим на блоки, состоящие из строчек одинаковой длины.
[07:20.000 --> 07:24.000]  l1, l2 и так далее.
[07:24.000 --> 07:30.000]  Ну, допустим, l, и тут вот какой-нибудь там.
[07:30.000 --> 07:36.000]  То есть тут длина, ладно, тут будет l1 длина, тут будет l2 длина, вот так вообще.
[07:36.000 --> 07:39.000]  И тут будет длина lb.
[07:39.000 --> 07:41.000]  Чуть не написал Бубин, но не важно.
[07:41.000 --> 07:45.000]  Да, Бубин не надо, мы его предъявлять сейчас не будем, поэтому лучше b.
[07:45.000 --> 07:48.000]  Вправивается.
[07:48.000 --> 07:52.000]  То есть, заметим, что для каждого блока у нас размер ответа не превосходит t.
[07:52.000 --> 07:59.000]  Следовательно, размер ответа суммальный не превосходит t на количество блоков.
[07:59.000 --> 08:04.000]  То есть, сколько различных длин среди этого множества строк s может быть?
[08:08.000 --> 08:12.000]  Ну, конечно, теоретически их сколько различных длин может быть?
[08:12.000 --> 08:15.000]  До вплоть до k, логично, да?
[08:16.000 --> 08:19.000]  Но есть еще один важный параметр.
[08:20.000 --> 08:24.000]  Давайте введем такой параметр, как len.
[08:25.000 --> 08:27.000]  Давайте так, даже sum len.
[08:29.000 --> 08:32.000]  Это будет просто сумма длин всех строк.
[08:39.000 --> 08:43.000]  И тогда возникает мистическая утверждение,
[08:43.000 --> 08:50.000]  что количество различных длин вот этих вот строчек не превосходит...
[08:53.000 --> 08:55.000]  чего?
[08:57.000 --> 09:02.000]  Вот как можно было бы количество блоков оценить, исходя из суммлена?
[09:08.000 --> 09:10.000]  Словно корень.
[09:11.000 --> 09:17.000]  Но у нас, если у нас b разных длин, то сумма хотя бы b на b кустынь пополам.
[09:20.000 --> 09:22.000]  Ну, на самом деле, да.
[09:22.000 --> 09:24.000]  Здесь как урагин из двух суммлен.
[09:24.000 --> 09:28.000]  Да, то есть, на самом деле, действительно, просто доказательства.
[09:28.000 --> 09:36.000]  То есть, sum len, оно равно, оно больше либо равно l1 плюс l2 плюс и так далее, плюс lb.
[09:36.000 --> 09:40.000]  Ну, я просто, давайте предположим, что есть каждого блока, только одну строчку оставлю, да?
[09:41.000 --> 09:48.000]  Это больше либо равно, если мы, например, скажем, что l1 меньше, l2 меньше, l3 меньше и так далее,
[09:48.000 --> 09:54.000]  то тогда это, можно сказать, что это больше либо равно, чем 1 плюс 2 плюс 3 плюс и так далее, плюс b.
[09:57.000 --> 10:01.000]  Это равно, как известно, b на b плюс 1 пополам.
[10:02.000 --> 10:08.000]  И это даже добьем больше либо равно b квадрата.
[10:10.000 --> 10:13.000]  Поэтому здесь я могу даже практически точную оценку написать.
[10:13.000 --> 10:19.000]  b меньше либо равно корень из 2 умножить на суммлен.
[10:28.000 --> 10:30.000]  Вообще говоря, это уже неплохие новости.
[10:32.000 --> 10:38.000]  Потому что ведь у нас же всегда в задачах в важном ограничении объявляется не только, что строчек может быть много,
[10:38.000 --> 10:40.000]  но мы знаем, что их суммарная длина не сильно большая.
[10:41.000 --> 10:47.000]  У нас не просто строчек не больше миллиона, но и суммарная длина не превосходится даже миллиона, а то и меньше бывает.
[10:48.000 --> 10:55.000]  А теперь у нас получается гарантия, что на самом деле количество блоков у нас не превосходит, оказывается, корни из этого миллиона.
[10:55.000 --> 10:57.000]  Ну ладно, корни из двух миллионов.
[10:57.000 --> 11:02.000]  И размер ответа получается, то есть из этого следует автоматически.
[11:05.000 --> 11:14.000]  То есть размер ответа получается не превосходит модуль t на корень из суммлен, из этой суммарной длины.
[11:14.000 --> 11:30.000]  Между прочим, если ваша задача найти все обхождения всех строчек и там ограничения какие-то поменьше, по 100 тысяч,
[11:30.000 --> 11:34.000]  то, между прочим, у вас теперь получается хешами Anode Red Map.
[11:37.000 --> 11:38.000]  Нет, на полном серьезе.
[11:38.000 --> 11:45.000]  Более того, то есть на самом деле часто бывают там задачи, где требуется найти всех обхождений всех строк, а потом там подвянка.
[11:45.000 --> 11:48.000]  Более того, еще бывает подвянка, даже дело не в кое-как.
[11:48.000 --> 11:54.000]  Просто длинны всех строк s не превосходят 80 или даже хуже 30.
[11:55.000 --> 11:59.000]  И тогда оказывается, что никаких умных алгоритмов писать не надо.
[11:59.000 --> 12:03.000]  А надо просто 30 раз побегать с Anode Red Map, ну в общем-то все.
[12:08.000 --> 12:14.000]  Вы знаете, что самое смешное? Если строки Биларды, то это решение будет еще и точным.
[12:16.000 --> 12:20.000]  Ну, в том плане, что хеши будут однозначно определять строчку.
[12:23.000 --> 12:25.000]  Вот, это самое смешное.
[12:27.000 --> 12:32.000]  Да, 26-30 уже там, наверное, в лог-в-лог не влезет, поэтому там уже будет хеши.
[12:32.000 --> 12:34.000]  Но там уже фар-фар-фар.
[12:34.000 --> 12:35.000]  Вот.
[12:36.000 --> 12:42.000]  Ну, тем не менее, вы знаете, что количество обхождений в целом не такое большое, как казалось бы,
[12:42.000 --> 12:47.000]  но, конечно, хотелось бы как-то его успешно искать.
[12:49.000 --> 12:51.000]  Как же это дело?
[12:56.000 --> 13:01.000]  Но для того, чтобы сделать что-то продвинутое и все-таки от хешей избавиться,
[13:01.000 --> 13:05.000]  нам потребуется умная структура данных BOR.
[13:08.000 --> 13:11.000]  Что такое BOR? Ну, как я уже сказал.
[13:11.000 --> 13:14.000]  Значит, BOR, то есть вот так и будем писать.
[13:14.000 --> 13:19.000]  BOR от строчек S1, S2, и так далее, SK.
[13:19.000 --> 13:23.000]  Ну, или по-английски она вот так вот называется.
[13:24.000 --> 13:26.000]  Вы спрашиваете, почему?
[13:27.000 --> 13:28.000]  Вот.
[13:29.000 --> 13:31.000]  Что это такое?
[13:31.000 --> 13:36.000]  Ну, я мог бы тут написать формальный текст, что BOR от CUT строчек
[13:36.000 --> 13:41.000]  это минимальный по количеству вершин детерминированный конечный автомат,
[13:41.000 --> 13:44.000]  в каждую вершину которого входит ровно одно ребро.
[13:49.000 --> 13:53.000]  Ну, вот ровно одно ребро, а в стартовую вершину не входит никто.
[13:53.000 --> 13:55.000]  И который принимает эти строки по парик.
[13:56.000 --> 14:00.000]  Вот. Я мог бы сказать такое формальное определение, но я не буду этого делать.
[14:01.000 --> 14:05.000]  Потому что вместо этого я просто продемонстрирую, что это такое, как с этим работать.
[14:05.000 --> 14:17.000]  Вот, например, допустим, у меня строчки там A-A-A, A-B-A, B, B-B-B-B, A-B.
[14:20.000 --> 14:22.000]  Ну, можно еще.
[14:23.000 --> 14:25.000]  А в ад какой-нибудь.
[14:30.000 --> 14:33.000]  Ну, ладно. Если еще будут строки, потом придумаем.
[14:34.000 --> 14:36.000]  Значит, идея будет такая.
[14:36.000 --> 14:38.000]  Мы добавляем эти строчки в BOR по очереди.
[14:38.000 --> 14:41.000]  BOR это будет такое дерево, вот у него есть стартовая вершина.
[14:43.000 --> 14:46.000]  Чтобы добавить в строчку A-A-A, все, что мы сделаем,
[14:46.000 --> 14:50.000]  это вот построим три таких новых вершины и на каждом ребре напишем по букве A.
[14:50.000 --> 14:52.000]  Да, BOR это у нас автомат.
[14:52.000 --> 14:56.000]  И тут, конечно, поставим крестик вздав того, что да, вершины терминальные.
[14:58.000 --> 15:00.000]  Что еще можно сделать?
[15:00.000 --> 15:02.000]  Если мы говорим A-B-A,
[15:03.000 --> 15:07.000]  тогда замечаем следующее. Мы пытаемся также добавить, но видим, что по первой букве мы проходимся.
[15:09.000 --> 15:12.000]  А вот по букве B перехода нет, поэтому мы его дополнительно строим.
[15:12.000 --> 15:14.000]  И тут уже тоже достраиваем.
[15:15.000 --> 15:19.000]  Да, теперь если мы хотим добавить строку B-B-B-B,
[15:19.000 --> 15:22.000]  допустим, вот B-B-B-B, давайте вот эту добавили,
[15:22.000 --> 15:24.000]  давайте теперь вот эту вот будем, с этой начнем.
[15:24.000 --> 15:28.000]  Тогда действительно мы тут просто ответляемся, строим вот так, вот так, вот так.
[15:32.000 --> 15:36.000]  А если мы хотим добавить строку B, то мы пытаемся пройти по символу B.
[15:37.000 --> 15:41.000]  Видим, что, ой, он уже был, и крестик.
[15:42.000 --> 15:45.000]  То есть видим так, что крестик не обязан быть листом,
[15:45.000 --> 15:49.000]  ну и как бы у нас есть крестик, который является листом, тогда и только тогда,
[15:49.000 --> 15:53.000]  когда какая-то из строк является префиксом какой-то быстрый писем.
[15:54.000 --> 15:57.000]  Ну и если мы хотим добавить A-B, то получается, видим,
[15:57.000 --> 16:00.000]  по букве A есть проход, по букве B есть проход,
[16:00.000 --> 16:03.000]  тут по букве B нет прохода, поэтому A ответ линейцы.
[16:05.000 --> 16:09.000]  А если мы хотим A-B-B-A, то A-B-B-A по букве T нет прохода,
[16:09.000 --> 16:11.000]  добавляем и ставим крестик.
[16:12.000 --> 16:14.000]  Вот что такое B.
[16:16.000 --> 16:17.000]  Понятная технология.
[16:18.000 --> 16:23.000]  Ну и здесь отметим, то есть реализовать это несложно,
[16:24.000 --> 16:29.000]  но единственное, оговоримся, что в зависимости от ситуации применяются две разные статистики.
[16:29.000 --> 16:32.000]  То есть есть одна вот маленькая деталь в реализации,
[16:32.000 --> 16:36.000]  которая может в зависимости от алфавита быть по-разному.
[16:36.000 --> 16:38.000]  Потому что как хранить вершины перехода?
[16:39.000 --> 16:41.000]  Ну и как вы вставаете, собственно, как хранить переходы?
[16:42.000 --> 16:44.000]  Ну точнее мапы либо массивы.
[16:45.000 --> 16:49.000]  Да, то есть вы можете хранить либо, то есть как бы переходы вы храните,
[16:50.000 --> 16:59.000]  то есть либо в мапе, тогда время работы называется будет O от логарифа,
[17:00.000 --> 17:02.000]  собственно, количество переходов, да?
[17:02.000 --> 17:04.000]  То есть каждый переход вы будете искать за логарифом.
[17:04.000 --> 17:06.000]  То есть каждый переход вы будете искать за логарифом.
[17:07.000 --> 17:13.000]  Ну по памяти, там память, получается, что в каждой вершине на этих переходах
[17:13.000 --> 17:17.000]  они памяти O от, собственно, этого размера, ну O до плюса B.
[17:18.000 --> 17:24.000]  Ну потому что если это будет пустота, то память на то, что типа этот мап вообще есть, вам придется хранить.
[17:25.000 --> 17:27.000]  Вот, но это если вы переходы храните в мапе.
[17:28.000 --> 17:31.000]  Можно их хранить в массивчике.
[17:31.000 --> 17:34.000]  Какая-то странная оценка, в смысле, вот, то, что мы сейчас сказали.
[17:35.000 --> 17:38.000]  Мне кажется, полезно сказать, что тогда суммарная память это O от сумма длинн строк,
[17:39.000 --> 17:41.000]  а время работы можно оценить как логариф сигма.
[17:42.000 --> 17:46.000]  Ну, можно, но мы сейчас точно, мы сейчас тут как бы точность напишем,
[17:47.000 --> 17:49.000]  а потом скажем, почему это равно в сумме.
[17:50.000 --> 17:57.000]  Значит, для массива тогда в каждой вершине придется время работы с каждым переходом честно O от 1,
[17:58.000 --> 18:04.000]  но зато памяти нам потребуется в точности O от размера алфавита,
[18:05.000 --> 18:08.000]  потому что для каждого флита нам придется хранить в объятном виде ячейку памяти,
[18:09.000 --> 18:12.000]  который будет хранить, куда ведет переход или там прикрестик, если это у перехода нет.
[18:14.000 --> 18:17.000]  Вот, ну, что, значит, что тут приоритетнее?
[18:18.000 --> 18:20.000]  То есть выбор на самом деле неоднозначен. Почему?
[18:21.000 --> 18:25.000]  Потому что, с одной стороны, здесь вы будете с каждым переходом работать O от 1,
[18:25.000 --> 18:29.000]  извините, но зато по памяти вам придется в каждой вершине хранить O от альфа-памяти.
[18:30.000 --> 18:35.000]  И при инициализации, кстати, вам придется O от альфа-времени тратить на то, чтобы там весь массив заполнить, чем надо.
[18:37.000 --> 18:38.000]  Вот.
[18:41.000 --> 18:45.000]  Вот. Но к чему это нас приводит? Приводит нас это вот к чему.
[18:46.000 --> 18:47.000]  Но с другой стороны, если мы будем использовать мапчик,
[18:48.000 --> 18:50.000]  то тогда суммарный размер памяти, который у нас будет,
[18:50.000 --> 18:55.000]  он будет в точности O от количества вершин плюс количество переходов между ими.
[18:56.000 --> 18:58.000]  А количество переходов, кстати, равно количеству вершин минус 1.
[18:59.000 --> 19:04.000]  То есть получится, что по памяти вот в такой версии она от алфавита зависеть не будет.
[19:05.000 --> 19:13.000]  Но за то, когда в каждой вершине искать переход, вы будете за логарифом реально сколько там любит.
[19:14.000 --> 19:16.000]  То есть поэтому тут надо всегда выбирать.
[19:16.000 --> 19:22.000]  То есть, конечно же, если алфавит мелкий, у вас там, скажем, 2, 4, 5, ну 2 там бинарные алфавиты или что-нибудь еще в этом роде,
[19:23.000 --> 19:25.000]  то, конечно, вот это однозначно лучше становится.
[19:26.000 --> 19:33.000]  Но если у вас строчки тоже там состоят из чисел на 10 в 9, то, конечно, придется делать мапчик тут уже без вариантов.
[19:34.000 --> 19:37.000]  Ну а если а равно 26, ну на самом деле там по ситуации.
[19:38.000 --> 19:41.000]  И так и так бывает, это будет там плюс-минус одинаково работать.
[19:42.000 --> 19:46.000]  Ну дальше, конечно, от того, что вы конкретно делаете с этим двором.
[19:47.000 --> 19:49.000]  То есть, да, есть вот такая маленькая действительно деталь.
[19:50.000 --> 19:53.000]  Ну в целом, я думаю, как это реализовывать, думаю, вопросов не вызывает.
[19:54.000 --> 19:55.000]  Ну можете реализовать там.
[19:56.000 --> 19:57.000]  Ну тоже, как всегда, там есть деталь.
[19:58.000 --> 20:04.000]  Вы там залодите массив вершин или там новую вершину через new указатель вызываете.
[20:05.000 --> 20:07.000]  Ну, скорее всего, да, правильный вариант.
[20:07.000 --> 20:10.000]  Это называется, да, вы делаете, вызываете через указатель new,
[20:11.000 --> 20:15.000]  ну можете подсовывать свой аллокатор, в котором этот огромный буфер вы там себе заранее прописали, да.
[20:24.000 --> 20:27.000]  Ну, такие же детали мы прописывать не будем, они тут слишком просты.
[20:28.000 --> 20:29.000]  Вот.
[20:30.000 --> 20:40.000]  Значит, значит, действительно, мы очень легко за линейное время можем действительно из строчек S такой бор составить.
[20:45.000 --> 20:52.000]  Как же мы теперь с помощью этого бора будем искать подстроки стратегии?
[20:53.000 --> 20:54.000]  Как же мы это будем делать?
[20:57.000 --> 20:58.000]  А вот как же.
[20:59.000 --> 21:04.000]  Но дело в том, что то, что я сейчас опишу, это на самом деле будет обобщение алгоритма кнута-мориса-правда.
[21:12.000 --> 21:15.000]  То есть на самом деле, да, по большому счету мы сейчас возьмем алгоритм кнута-мориса-правда,
[21:16.000 --> 21:18.000]  чипу из префикс-функции, просто обобщим его навод.
[21:19.000 --> 21:20.000]  Казалось бы, как?
[21:21.000 --> 21:26.000]  А вот не случайно мы пытались, мы в прошлый раз, в прошлый раз.
[21:28.000 --> 21:29.000]  В позапрошлый момент.
[21:32.000 --> 21:33.000]  Сейчас, стоп.
[21:38.000 --> 21:45.000]  А, в позапрошлый, потому что мы в позапрошлый раз префикс-функцию обсуждали в конце, после последней геометрической темы.
[21:46.000 --> 21:47.000]  В позапрошлый раз.
[21:48.000 --> 21:54.000]  Значит, мы с вами обсуждали префикс-функцию и пытались избегать этого понятия, что давайте P$T и посчитаем префикс-функцию.
[21:55.000 --> 21:59.000]  Мы вместо этого говорили другое. Давайте я кратко напомню, что конкретно.
[22:00.000 --> 22:02.000]  А мы, собственно, сегодня эту схему, собственно, упоминали.
[22:03.000 --> 22:04.000]  Значит, смотрите.
[22:05.000 --> 22:07.000]  То есть жила была строка P.
[22:08.000 --> 22:13.000]  И мы пытаемся с помощью ее пройти по тексту T.
[22:16.000 --> 22:17.000]  Как мы это делаем?
[22:18.000 --> 22:19.000]  Как мы это делаем?
[22:21.000 --> 22:22.000]  Делаем это вот как.
[22:23.000 --> 22:25.000]  Мы пытаемся, смотрите, что мы делаем.
[22:26.000 --> 22:30.000]  Мы пытаемся сначала, начать сначала P, T и пройти.
[22:31.000 --> 22:36.000]  Так, давайте я, опять, коричневый маркер возьму и скажу.
[22:37.000 --> 22:43.000]  Я пытаюсь тут найти какой-то вот префикс, который совпадает с префиксом строки P.
[22:44.000 --> 22:45.000]  Искали, искали, искали.
[22:46.000 --> 22:47.000]  Опа, остановились.
[22:48.000 --> 22:51.000]  Ну, в идеале, потому что строка P закончилась, но чаще всего скорее потому, что у нас тут.
[22:52.000 --> 22:54.000]  Чим было не совпадает.
[22:55.000 --> 22:57.000]  Что мы в этом случае делаем?
[22:59.000 --> 23:11.000]  Мы пытаемся найти максимальный, так мы и собственный суффикс у этой строки, который также является еще префиксом строки P.
[23:13.000 --> 23:14.000]  Понимаете, да?
[23:16.000 --> 23:19.000]  Вот, находим его и пытаемся тоже его продлять, продлять, продлять, продлять.
[23:19.000 --> 23:21.000]  Вот, может быть, нам даже и повезло.
[23:22.000 --> 23:24.000]  Здесь мы тоже его берем и так пытаемся продлять.
[23:25.000 --> 23:27.000]  То есть вот так был устроен у нас алгоритм, помните, да?
[23:28.000 --> 23:38.000]  Все для того, чтобы определить, насколько конкретно тут, как тут вот этот суффикс заберем-заберем, мы фактически применяли примерно то же самое, только там P, так сказать, против самого себя.
[23:39.000 --> 23:41.000]  Это у нас называлась префикс-функция, помните, да?
[23:43.000 --> 23:44.000]  Было дело.
[23:44.000 --> 23:45.000]  Было дело.
[23:48.000 --> 23:56.000]  Так вот, мы попытаемся, попытаемся проделать абсолютно ту же самую процедуру.
[23:59.000 --> 24:09.000]  Только разница будет в том, что у нас теперь не одна строка P, обратите внимание, а несколько строк P.
[24:09.000 --> 24:11.000]  У нас теперь несколько строк.
[24:12.000 --> 24:17.000]  Вот у нас есть P1, есть, допустим, P2, есть, как они еще, P3, короче.
[24:18.000 --> 24:22.000]  Есть вообще супер длинное P4, что-нибудь средненькое P5, ну и так далее.
[24:24.000 --> 24:26.000]  И нам сейчас будет интересно вот что.
[24:26.000 --> 24:31.000]  Мы будем на уровне прохода, смотрите, пытаться сделать следующее.
[24:32.000 --> 24:33.000]  Смотрите, уровень идеи.
[24:34.000 --> 24:47.000]  Я хочу идти-идти-идти-идти и искать максимальный префикс строки T, который по совместительству является префиксом хотя бы одной из строчек.
[24:47.000 --> 24:48.000]  Понимаете, да?
[24:49.000 --> 24:50.000]  Хотя бы одной.
[24:52.000 --> 24:59.000]  Легче всего, конечно, это делать, вот сам по себе этот первый проход делать, конечно же вборе из этих строчек.
[25:01.000 --> 25:09.000]  Потому что нам не нужно теперь перебирать все строчки, а просто, когда у нас почти все строки есть, то мы их будем вбирать.
[25:09.000 --> 25:12.000]  Конечно же вборе из этих строчек.
[25:13.000 --> 25:22.000]  Потому что нам не нужно теперь перебирать все строчки, а просто, когда у нас идем по буквам и каждый момент времени проверяем, мы из очередной вершины можем по этой букве пройти?
[25:23.000 --> 25:24.000]  И типа если да, то вот типа проходим.
[25:25.000 --> 25:26.000]  Каждое время находимся в какой-то вершине вбора.
[25:27.000 --> 25:33.000]  Ну, кстати, заметим, что вбор еще на самом деле можно неофициально называть префиксное дерево.
[25:34.000 --> 25:36.000]  Или дерево префиксов.
[25:37.000 --> 25:48.000]  Ибо по большому счету, да, легко заметить, что здесь каждая вершина в точности соответствует префикс какой-нибудь строте, который является префиксом хотя бы кого-нибудь из них.
[25:49.000 --> 25:50.000]  Может даже нескольких.
[25:51.000 --> 25:52.000]  Вот.
[25:53.000 --> 25:58.000]  То есть с помощью бора это было бы действительно такой проход легко делать.
[25:59.000 --> 26:00.000]  Ну вот мы остановились.
[26:01.000 --> 26:02.000]  Что дальше делать?
[26:03.000 --> 26:09.000]  Ну дальше технология у нас могла бы звучать так.
[26:10.000 --> 26:19.000]  Ну то есть теперь нам хочется найти минимальный собственный суффикс, вообще максимальный собственный суффикс, который все еще является чьим-то префиксом.
[26:20.000 --> 26:21.000]  Может уже другой строки, правда.
[26:22.000 --> 26:23.000]  Или несколько.
[26:24.000 --> 26:26.000]  И пытаемся его произвести.
[26:29.000 --> 26:31.000]  То есть вот такой вот процесс.
[26:33.000 --> 26:35.000]  То есть пока, да, немножко абстрактный процесс.
[26:36.000 --> 26:40.000]  То есть мы пытаемся находить в некотором роде такие вот самые длинные вхождения.
[26:41.000 --> 26:42.000]  То есть в переводе бора получается так.
[26:43.000 --> 26:46.000]  Мы для каждой позиции T, вот другая интерпретация.
[26:47.000 --> 26:59.000]  Смотрите, мы для каждой позиции T пытаемся найти самую длинную подстроку, которая заканчивается в этой позиции и которая совпадает с префиксом хоть кого-нибудь.
[27:00.000 --> 27:01.000]  Понятно, да?
[27:02.000 --> 27:09.000]  То есть заметим, что вот этот процесс на самом деле именно этим по большому счету и занимается, правда?
[27:12.000 --> 27:13.000]  Потому что...
[27:14.000 --> 27:17.000]  Ну потому что заметим, что тут достаточно очевидно, что...
[27:18.000 --> 27:19.000]  Ну да, тут...
[27:20.000 --> 27:32.000]  Достаточно очевидно, что когда мы впервые достигли позиции И, то, собственно, то, с чем мы ее достигли, собственно, вот этим вот максимально возможным префиксом, который в этой позиции заканчивается, и является. Согласны?
[27:34.000 --> 27:35.000]  Да нет, наверное.
[27:36.000 --> 27:37.000]  Понятно, о чем я говорю.
[27:38.000 --> 27:39.000]  Хорошо.
[27:40.000 --> 27:41.000]  Вот, отлично.
[27:43.000 --> 27:44.000]  Как же это реализовать?
[27:45.000 --> 27:46.000]  Как минимум сам проход.
[27:47.000 --> 28:03.000]  Но я утверждаю, что, если мы опять верим в хэшмапы, то я утверждаю, что мы это легко сделаем за... ну, сначала за построение хэшмапов за отсумвлена, а потом вот этим проходом за отты.
[28:06.000 --> 28:07.000]  Почему так?
[28:07.000 --> 28:17.000]  Потому что давайте построим массив из... называется сумлен хэшмапов.
[28:20.000 --> 28:21.000]  Ну вот.
[28:22.000 --> 28:23.000]  Прямо так и пишем.
[28:23.000 --> 28:24.000]  Прямо так и пишем.
[28:35.000 --> 28:38.000]  Так сказать, из хэша в вершину.
[28:40.000 --> 28:41.000]  Я даже так неформально допишу.
[28:54.000 --> 28:58.000]  Ладно, тут даже не сумлен уже, а максимально.
[29:00.000 --> 29:09.000]  Где в maps.it для хэша...
[29:10.000 --> 29:14.000]  Да ладно, я что-то незаметно предположил, что все верят, все знают, что такое хэш.
[29:18.000 --> 29:19.000]  Ну да, пусть знают.
[29:19.000 --> 29:22.000]  Ну ладно, чем их оттаить? Большинство слушателей, видимо, это знают.
[29:23.000 --> 29:36.000]  А если не знаете, то просто поверим, что мы можем по каждой страте и по каждому ее префиксованию, по каждой пазике вычислять какое-то мистическое число, про которое верить, что для двух строк числа совпадает тогда и только тогда, когда у них сами числа совпадают.
[29:38.000 --> 29:40.000]  Ну почти так оно и есть, да.
[29:41.000 --> 29:47.000]  Дальше начинается вероятность на анализ, поэтому ровно поэтому мы конкретное обсуждение этого откладываем на потом.
[29:49.000 --> 30:10.000]  Ну вот, для хэша, для хэшей префиксов строк, там, s1, s2 и так далее, sk длины и...
[30:11.000 --> 30:22.000]  ...сохраним соответствующие вершины в Боре.
[30:26.000 --> 30:38.000]  Ну, например, можно хранить вершину в Боре, можно хранить, конечно, там координату, то есть типа из какой строки это взялось, ну вот это все, пожалуйста, на ваш...
[30:38.000 --> 30:53.000]  Ну там, из какой строки тут сложно, там надо выбирать, потому что, скорее всего, как несложно видеть из сбора, там, например, конфетный префикс, там может оказаться префиксом нескольких строчек, и какую из них выбирать не всегда понятно.
[30:54.000 --> 31:02.000]  Ну, дальше ладно, это уже технический вопрос, на самом деле, в зависимости от того, что вам там конфетного алгоритма надо. Ну, например, вот мы будем говорить про вершину в Боре.
[31:02.000 --> 31:14.000]  Вот. И тогда идея эта окажется очень проста. То есть как этот алгоритм забабахает? Ну, очень просто. Сначала мы смотрим вот этот префикс и говорим, что вот максимальный префикс.
[31:15.000 --> 31:24.000]  Тогда мы знаем, что ответы, то есть вот эти суффиксы тут мы нашли. Дальше не получается. Тогда получается, раз правый указатель сдвинуть нельзя, надо сдвинуть левой.
[31:25.000 --> 31:34.000]  Мы проверяем. Вот эта строчка является чьим-нибудь префиксом. Если да, то именно ее мы и пытаемся продолжать. Если нет, то, собственно, бесполезно.
[31:35.000 --> 31:46.000]  Проверяем, проверяем, то есть двигаем этот указатель, и получается, что давайте нашли максимальный, максимальный собственный суффикс, который еще чьим-то префиксом является, и пытаемся двигать этот указатель.
[31:47.000 --> 31:55.000]  Да, может не получиться. Тогда мы продолжаем двигать левый указатель, и так двигаем до тех пор, пока, наконец, не получится.
[31:56.000 --> 32:06.000]  И тогда, когда у нас получится, мы двигаем, двигаем, двигаем. Вот. И тогда для каждого из этого блока мы тоже нашли вот этот вот максимальную подстройку заражения этой позиции, имеющую чьим-то префикс.
[32:07.000 --> 32:18.000]  То есть сам по себе этот проход, очевидно, работает за О от модуль Т, потому что два указатель, правда? Понимаете, да?
[32:19.000 --> 32:25.000]  Ну и, конечно же, построение вот этих мапов будет работать за О от суммеля.
[32:25.000 --> 32:32.000]  Вот. Ну, как вы можете заметить, пока этот проход является, конечно же, абстрактным, просто сферическим проходом вакуума.
[32:33.000 --> 32:39.000]  Потому что, да, мы это сделали, мы это сделали за линию. Зачем? Пока непонятно.
[32:39.000 --> 32:44.000]  Ну, давайте попробуем. Опять же, зачем? Потому что мы это придумали из префикс-функции.
[32:45.000 --> 32:52.000]  Потому что, когда... Вы что, смотрите, мы изначально, когда искали подстройку П в скротете АБДУ, мы делали ровно то же самое. Почему?
[32:53.000 --> 33:01.000]  Потому что мы надеялись на то, что если в какой-то позиции вот эта строка софтует, то это будет работать, то это будет работать.
[33:01.000 --> 33:10.000]  Ну вот, при этом более того, там оказывалось очень круто, что если мы нашли тут, если это строка П в скротете АБДУ, мы делали ровно то же самое.
[33:11.000 --> 33:20.000]  Почему? Потому что мы надеялись на то, что если в какой-то позиции вот эта строка совпала прям со всей строкой П, то это означает, что ура, мы нашли вхождение строки П, правда?
[33:21.000 --> 33:27.000]  Вот, согласны? Вот прям взяли и нашли прям всю строку П.
[33:27.000 --> 33:38.000]  Потому что вот там оказывалось очень круто, что если мы нашли тут, если эта строка совпала с строкой П, значит это и есть вхождение, а если тут нашлось не... П не нашлось, значит тут вхождение не заканчивается.
[33:39.000 --> 33:43.000]  И это давало нам возможность найти все вхождения. Было дело.
[33:44.000 --> 33:48.000]  Но в чем тут тогда? Тогда, раз вы знаете, тогда скажите мне, в чем проблема?
[33:48.000 --> 34:02.000]  Ведь казалось бы, а что нам сейчас мешает просто сказать, что если мы нашли вот префикс, который совпадает со строчкой, то мы тогда торжественно заявляем, что мы в этом месте нашли вхождение, нашли вхождение, короче, этой строке.
[34:03.000 --> 34:10.000]  А если это не какая-то строчка, ну и не судьба. Ну, значит мы не нашли тут никакого вхождения.
[34:11.000 --> 34:16.000]  И тогда получается, вот мы, по крайней мере хоть с мапчиками, но нашли прям за линиями, прям за линию, все хорошо.
[34:16.000 --> 34:34.000]  Вот что нам мешает тогда вместо того, чтобы там эти какие-то там суффиксные ссылки изобретать, там какие-то, какой-то мексис, вот эту всю, вместо этого так честно и сказать, что вот давайте вот лучше хлешами сделаем вот такой очень простой проход и найдем все вхождение. Что нам мешает?
[34:35.000 --> 34:36.000]  Значит мы не найдем все вхождение. А чего?
[34:37.000 --> 34:39.000]  Может бы попустить просто вхождение какой-то мелкой строки.
[34:40.000 --> 34:42.000]  Ну, понятно, а вот пусть Александр скажет.
[34:42.000 --> 34:43.000]  Александр скажет.
[34:44.000 --> 34:54.000]  Когда мы возвращаемся к второму вхождению, вот мы нашли, получается, ну, все-все?
[34:55.000 --> 34:56.000]  Да.
[34:57.000 --> 35:00.000]  И дальше мы двигаемся вновь вправо, поэтому у нас были какие-то до него...
[35:01.000 --> 35:02.000]  Нет.
[35:03.000 --> 35:13.000]  Но если мы тут двигали левым указателем и нашли какую-то строчку, которая являлась чьим-то, то есть которая совпадала с одной из строчек, то мы бы тут остановились.
[35:14.000 --> 35:17.000]  То есть мы бы тут остановились и увидели бы, что в вхождении есть.
[35:17.000 --> 35:23.000]  Здравствуйте. Мы же в втором указателе двигаемся тоже вновь вправо.
[35:24.000 --> 35:28.000]  Двигаемся. Но у нас же был момент, когда эти два указателя вот тут стояли.
[35:31.000 --> 35:33.000]  У нас был внутричный вовсю строчный путь.
[35:34.000 --> 35:36.000]  Внутри. Что значит внутричный?
[35:37.000 --> 35:42.000]  То есть на пути в Вольне от начала, ну, было несколько моментов.
[35:43.000 --> 35:44.000]  Да.
[35:44.000 --> 35:45.000]  Да, действительно.
[35:46.000 --> 35:56.000]  Условно говоря, может произойти ситуация, когда строчка, которая здесь в воле находится как ABB, но по факту мы заметим, что мы говорим ABB и ничего не произошло.
[35:57.000 --> 35:58.000]  Она даже в этом воле.
[35:59.000 --> 36:02.000]  Мы заметим, что в этот момент у нас есть вхождение строки B, который заканчивается, а мы его пропустили.
[36:04.000 --> 36:06.000]  Да, вот такая подлянка, оказывается.
[36:07.000 --> 36:18.000]  То есть заключается она в том, что, оказывается, что да, раньше мы могли утверждать, что либо у нас префикс длины P, и тогда он совпадается с такой претехождением, а если он меньше, значит тут никаких вхождений нет.
[36:19.000 --> 36:27.000]  А тут, оказывается, что мы гарантировать пока можем только одно, что у нас в этой позиции не заканчиваются вхождения строчек, у которых длина больше, чем вот это.
[36:29.000 --> 36:31.000]  А вот может ли быть, что она меньше?
[36:32.000 --> 36:33.000]  Ну, вполне может.
[36:36.000 --> 36:37.000]  Да.
[36:41.000 --> 36:43.000]  Но есть и небольшие хорошие новости.
[36:44.000 --> 36:50.000]  Хорошие новости заключаются в том, что, на самом деле, заметим, что это не во всех случаях происходит.
[36:51.000 --> 36:59.000]  А есть на самом деле один широкий такой случай, когда мы ищем подстройки в строке, когда на самом деле вот такого не бывает.
[37:01.000 --> 37:03.000]  Этот случай очень простой.
[37:03.000 --> 37:09.000]  Когда никакое P i не под строка P j.
[37:17.000 --> 37:18.000]  Вот, заметим следующее.
[37:20.000 --> 37:30.000]  То есть, если мы хотим, чтобы никакая подстрока не была собственным суффиксом какого-то префикса какой-то другой строки,
[37:30.000 --> 37:40.000]  то по большому счету мы практически требуем, чтобы никакая строка не была под строкой P j.
[37:41.000 --> 37:50.000]  Ну ладно, здесь, конечно, мы еще, чтобы вот этого избежать, мы, конечно, еще требуем, чтобы она была не просто под строкой, а там еще, чтобы она была под строкой, но не префиксом.
[37:51.000 --> 37:53.000]  Но это уже, до таких деталей мы копать не будем.
[37:54.000 --> 38:06.000]  Пока заметим следующее, что если ни одна строка P не является под строкой чего-нибудь еще, то вот этот алгоритм прекрасно работает.
[38:07.000 --> 38:15.000]  То есть, если у вас там откуда-то взялась гарантия, что никто ни чьи под строкой не является, то поздравляю вот весь алгоритм.
[38:15.000 --> 38:24.000]  Кстати, с попутным доказательством того, что если ни одна строка не является под строкой другой, то суммарное количество обхождений у вас не более чем P.
[38:25.000 --> 38:26.000]  Обратите внимание.
[38:30.000 --> 38:36.000]  То есть маленькая приятная лена, то есть доказательство практически следует из вот этого алгоритма.
[38:37.000 --> 38:38.000]  Понятно, да?
[38:40.000 --> 38:43.000]  Вот так вот, очень приятно получается.
[38:46.000 --> 38:47.000]  Вот.
[38:49.000 --> 38:52.000]  Но что же все-таки делать?
[38:53.000 --> 38:59.000]  Вот как вы думаете, что же нам все-таки делать, если все-таки это условие не выполняется?
[39:00.000 --> 39:03.000]  Обхождение хочется находить все еще все.
[39:03.000 --> 39:11.000]  Ну, хотелось бы, чтобы для каждого префикса какой-то строк мы могли понять, какие строки заканчиваются.
[39:12.000 --> 39:13.000]  Ну, и версию шубка сами.
[39:14.000 --> 39:15.000]  Ну да.
[39:16.000 --> 39:17.000]  Ну, идея действительно очень проста.
[39:18.000 --> 39:27.000]  Ну, во-первых, да, просто хочется для каждого префикса каждой строки, или что-то то же самое для каждой вершины в горе, хочется просто понимать.
[39:27.000 --> 39:33.000]  Как бы, какие суффиксы этой строки являются еще и какими-то P-шками.
[39:37.000 --> 39:38.000]  Понятная идея, да?
[39:40.000 --> 39:44.000]  То есть давайте введем мистическую функцию.
[39:46.000 --> 39:49.000]  Так, господа, сейчас я введу мистическую функцию.
[39:50.000 --> 39:51.000]  Мистическая функция.
[39:51.000 --> 39:53.000]  Так, как бы ее назвать, пока ее лог-суф не назвал?
[40:00.000 --> 40:02.000]  Я слышал супер-суф, но я не знаю нормально.
[40:03.000 --> 40:05.000]  Да нет, но у нас же пока нет понятия суффиксы этой строки.
[40:06.000 --> 40:16.000]  Так, смотри, задача, у нас есть функция, которая по каждому префиксу, ну или по каждой вершине города, если хотите, ставит нам в соответствии, ну, субтитры.
[40:16.000 --> 40:25.000]  По каждому префиксу, ну или по каждой вершине города, если хотите, ставит нам в соответствии максимальный суффикс этого префикса, который является строкой.
[40:26.000 --> 40:27.000]  Ну, в лице номера, например, этой строки.
[40:36.000 --> 40:37.000]  Так и назовется.
[40:38.000 --> 40:39.000]  Макс.
[40:41.000 --> 40:42.000]  Макс-суффикс.
[40:44.000 --> 40:45.000]  Ин-пэ.
[40:49.000 --> 40:55.000]  Будет у нас такая функция из множества вершин в горе в числа от одного дока.
[40:55.000 --> 41:02.000]  Ну, во-первых, смотрите, ладно, давайте, во-первых, давайте пришло время, наверное, ввести так в горе, даже в горе.
[41:04.000 --> 41:06.000]  Значит, давайте введем понятие пэс.
[41:07.000 --> 41:10.000]  От в и, соответственно, там альфа звездочка.
[41:11.000 --> 41:14.000]  Это будет так, это строчка, это будет называться путевая метка.
[41:16.000 --> 41:18.000]  Да, это не определение, это название.
[41:18.000 --> 41:19.000]  А определение следующее.
[41:20.000 --> 41:23.000]  То есть, по какой строке мы должны пойти с горе, чтобы перейти в вершину.
[41:25.000 --> 41:37.000]  Ну, то есть, например, путевая метка этой вершины пустая, путевая метка этой вершины а, путевая метка этой вершины аб, путевая метка этой вершины Kentucky, у этой a, у этой ab.
[41:39.000 --> 41:45.000]  Давайте будем называть это путевой меткой, то есть при dioxide ,we ghost-б 녘ат值.
[41:45.000 --> 41:50.000]  Давайте будем называть это путевой меткой, но это достаточно стандартное определение.
[41:50.000 --> 41:56.000]  А вот нам еще и в суффиксных деревьях тоже предъявится. Давайте называть это путевой
[41:56.000 --> 42:04.000]  меткой и будем называть это PS от V. Так вот. Так вот. Максимальный суффикс...
[42:04.000 --> 42:16.000]  PS, так вот, значит, максимальный суффикс PS от V. Это, смотрите, это такое число и...
[42:16.000 --> 42:29.000]  Смотрите, что, значит, пишем. На этот раз к черным пишем. PIT, суффикс, не собственный, а просто, значит...
[42:30.000 --> 42:41.000]  Ну вот. Соответственно, суффикс PS от V. Понятно, да?
[42:44.000 --> 42:49.000]  То есть, суффикс PS от V, и при этом, ну, варианта, что может быть есть, как-то правильно.
[42:49.000 --> 43:01.000]  И модуль PIT равен максимум. То есть, как можно больше.
[43:05.000 --> 43:10.000]  У нас же строки были S и T, кажется. Когда они стали PIT?
[43:10.000 --> 43:27.000]  Ну да. Классика. Ну да, правильно. Это называется, ты приходишь, ты написал детективный роман,
[43:27.000 --> 43:32.000]  приходишь давать издательство, и на редакторе тебе говорят, у вас как главного героя зовут?
[43:32.000 --> 43:33.000]  Герои?
[43:33.000 --> 43:36.000]  О чем в середине романовой нюры откликается?
[43:51.000 --> 43:54.000]  Ну вот. Ладно, давайте тут тоже.
[43:54.000 --> 44:04.000]  Хорошо. Вот. Ладно. Ну тут, на самом деле, еще сюда придется прибавить.
[44:04.000 --> 44:17.000]  Ну вот. Или, ну, допустим, я не знаю, ну там, либо 0, либо минус 1, давайте. Есть ли такого ангела?
[44:24.000 --> 44:30.000]  Ну, потому что может же так случиться, что у претикса нету суффиксов, которые совпадают со всей строкой, правда?
[44:39.000 --> 44:43.000]  Так, хотя, хотя не знаю, может сейчас, да, просто кажется, что еще много работы,
[44:43.000 --> 44:47.000]  а может сейчас такими вот мотивациями сейчас раз-раз и неожиданно победим.
[44:47.000 --> 44:53.000]  Потому что, что нам надо? Предположим, мы вот с небес по факсу откуда-то это выкопали.
[44:53.000 --> 44:55.000]  Я не знаю, с небес по факсу.
[44:58.000 --> 45:01.000]  Тогда чего нам не хватает до полного счастья?
[45:02.000 --> 45:08.000]  Тогда, получается, в каждой позиции мы, ну, тогда мы, конечно, у нас получится лучше в том плане,
[45:08.000 --> 45:16.000]  что в каждой позиции мы с помощью этой функции получим возможность находить, вот это вот теперь синеньким будем назначать,
[45:16.000 --> 45:27.000]  еще самую дно, получается самую длинную строчку, которая заканчивается в этой позиции и является, и совпадает с какой-то строчкой.
[45:28.000 --> 45:30.000]  И прыгая по таким исходкам?
[45:31.000 --> 45:33.000]  По каким? Куда прыгать?
[45:34.000 --> 45:38.000]  Обратите внимание, нам пока не по чему прыгать. Вот чем проблема.
[45:38.000 --> 45:46.000]  Видите, мы пока эту функцию так определили, что пока не по чему прыгать.
[45:46.000 --> 45:48.000]  Неприятно, конечно.
[45:48.000 --> 45:55.000]  То есть, но, конечно, заметим, что все следующие строки по длине 2, 3, 4, 5, они зависят только от самой первой, правда?
[45:56.000 --> 45:58.000]  Понимаете, да?
[46:00.000 --> 46:03.000]  Поэтому здесь можно ввести другую функцию.
[46:04.000 --> 46:08.000]  Здесь можно ввести функцию max another.
[46:12.000 --> 46:13.000]  P
[46:15.000 --> 46:16.000]  S
[46:16.000 --> 46:17.000]  суффикс
[46:21.000 --> 46:22.000]  Max another.
[46:22.000 --> 46:23.000]  Суффикс от чего?
[46:24.000 --> 46:25.000]  От эсфитова.
[46:26.000 --> 46:31.000]  Эта функция у нас будет уже от 1, 2 и так далее к.
[46:32.000 --> 46:34.000]  Вот здесь нам придется еще минус 1 добавить.
[46:36.000 --> 46:40.000]  А лучше дайте, раз уж мы так пишем, лучше еще будет у нас слово out.
[46:43.000 --> 46:44.000]  И тут тоже будет.
[46:45.000 --> 46:47.000]  Out и 1, 2, 3, 4.
[46:48.000 --> 46:55.000]  Значит так, начало-то нормальное, то есть каждое это сопоставляем либо out, либо 1, 2 и так далее.
[46:57.000 --> 46:58.000]  Понятно, да?
[47:05.000 --> 47:08.000]  И тогда определение из него будет такое.
[47:09.000 --> 47:10.000]  Ну вот.
[47:11.000 --> 47:17.000]  Даже правильный на самом деле, max правильный на самом деле черный мы будем вводить, потому что это чисто черная функция на самом деле.
[47:21.000 --> 47:22.000]  Да, правильно вот так писать.
[47:28.000 --> 47:29.000]  Так.
[47:29.000 --> 47:30.000]  И это такое.
[47:31.000 --> 47:32.000]  J
[47:32.000 --> 47:33.000]  что, ну соответственно.
[47:34.000 --> 47:35.000]  Значит QJ
[47:36.000 --> 47:37.000]  собственный.
[47:39.000 --> 47:41.000]  Так, слово собственный не пугает.
[47:46.000 --> 47:47.000]  Ну да, согласен, согласен.
[47:48.000 --> 47:50.000]  Ой, тогда тут надо S ставить.
[47:55.000 --> 47:56.000]  И тут, кстати.
[47:59.000 --> 48:00.000]  Господи.
[48:01.000 --> 48:03.000]  Ну п же, ну паттерны же мы ищем.
[48:04.000 --> 48:05.000]  Господи, ну ладно.
[48:06.000 --> 48:09.000]  Ой, вот так вот пик кто-то ввел, а теперь везде двойки.
[48:10.000 --> 48:11.000]  Ну вот тут тоже самое.
[48:13.000 --> 48:15.000]  Ладно, слово собственный это пугает?
[48:16.000 --> 48:17.000]  Нет?
[48:18.000 --> 48:21.000]  На всякий случай, собственный это означает не совпадать с самой строкой.
[48:23.000 --> 48:26.000]  И соответственно, модуль без житого, конечно, должен быть максимальным.
[48:26.000 --> 48:29.000]  Ну или, или alt.
[48:30.000 --> 48:32.000]  Ну понятно, если там бла-бла-бла, я уже допишу это не буду.
[48:37.000 --> 48:38.000]  Так, заметим следующее.
[48:39.000 --> 48:46.000]  Что если у нас помимо вот этих мапчиков, если мы верим в эти мапчики и у нас откуда-то взялись вот эти строки.
[48:47.000 --> 48:48.000]  Откуда-то.
[48:50.000 --> 48:51.000]  То что мы делаем?
[48:51.000 --> 48:52.000]  То что мы делаем?
[48:53.000 --> 49:00.000]  То тогда получается, что мы, я тогда утверждаю, что мы умеем решать задачу за о от сумлен плюс т плюс размер ответа.
[49:02.000 --> 49:15.000]  Потому что мы теперь умеем, получается самую, в каждой позиции мы теперь по префиксу вот этому умеем найти самую длинную строчку, самую длинную эску, которая тут заканчивается.
[49:15.000 --> 49:20.000]  По ней найти самую длинную вторую, по второй самую длинную третью, четвертую, пятую и так далее.
[49:21.000 --> 49:25.000]  Просто уже прибираемся в айли компаунт, max, another, s, a supers.
[49:26.000 --> 49:33.000]  И вот этот перебор делается за суммарно о от ans, так сказать, it.
[49:34.000 --> 49:39.000]  То есть сколько, от размера, количества вхождений, которые заканчиваются в it позиции.
[49:39.000 --> 49:41.000]  Вот, но для этого, правда, нам нужна маленькая вещь.
[49:42.000 --> 49:47.000]  Нам нужна, чтобы эти функции у нас откуда-то здесь.
[49:48.000 --> 49:49.000]  Откуда нам их взять?
[49:52.000 --> 49:55.000]  Ну давайте, ну откуда нам их взять?
[49:56.000 --> 49:57.000]  Не считай себя.
[49:57.000 --> 49:59.000]  Ну, на все, ладно, начнем с халявы.
[50:00.000 --> 50:04.000]  На самом деле, вот эту функцию очень легко посчитать, причем вообще без хешей.
[50:04.000 --> 50:17.000]  Ну, ее, собственно, через max suffix можно считать, если найти, какову позицию ворзера,
[50:17.000 --> 50:18.000]  строка a, s.
[50:18.000 --> 50:21.000]  Не совсем, понимаете, тут не совсем.
[50:21.000 --> 50:24.000]  Тут есть реальность, через max suffix ее посчитать нельзя,
[50:24.000 --> 50:28.000]  потому что, если вы будете вызывать max suffix, а для шины, которые соответствуют всей строке,
[50:28.000 --> 50:30.000]  то max suffix перелет саму себя.
[50:30.000 --> 50:35.000]  Так что нет, если у вас тут можно было сказать, что давайте напишем max second suffix ns,
[50:35.000 --> 50:36.000]  тогда пожалуйста.
[50:39.000 --> 50:42.000]  Поэтому пока здесь, то на самом деле, заметим, что эту функцию вообще легко считать.
[50:42.000 --> 50:43.000]  Знаете почему?
[50:43.000 --> 50:48.000]  Потому что, на самом деле, очень легко, во-первых, тут построить борт на развернутой строчке.
[50:49.000 --> 50:53.000]  Потому что, если мы развернем строчку, то, как бы, то, кто был с суффиксом, станет префиксом.
[50:54.000 --> 50:56.000]  Поэтому, по большому счету, вы развернете строчки,
[50:56.000 --> 51:00.000]  и для каждой строки вам нужно будет найти там самую длинную строчку,
[51:00.000 --> 51:05.000]  то есть самый глубокий, самый близкий к концу, но не совпадающий с ним крестик, по большому счету.
[51:06.000 --> 51:08.000]  Не сильно страшно будет, правда?
[51:09.000 --> 51:10.000]  Или страшно будет.
[51:11.000 --> 51:16.000]  Так что получается, max ns suffix вы, конечно, найдете.
[51:17.000 --> 51:21.000]  А вот max suffix ns, вот тут уже сложнее.
[51:21.000 --> 51:26.000]  Но с другой стороны, на самом деле, но на самом деле, это не все функции, которые нам потребуются.
[51:28.000 --> 51:31.000]  Потому что у нас параллель, да, возникнет.
[51:32.000 --> 51:33.000]  Ну, хотя вот можно подумать.
[51:33.000 --> 51:35.000]  Хотя нет, давайте подумаем.
[51:35.000 --> 51:37.000]  Если мы верим в хэши.
[51:43.000 --> 51:44.000]  Вот.
[51:44.000 --> 51:45.000]  Вот.
[51:45.000 --> 51:46.000]  Если мы верим в хэши.
[51:46.000 --> 51:50.000]  Как вы думаете, нельзя ли с помощью ситровых хэшей насчитать вот эту функцию?
[52:05.000 --> 52:08.000]  Ну, сходу непонятно, почему можно.
[52:09.000 --> 52:11.000]  А на самом деле, аналогичный притикс функции.
[52:13.000 --> 52:15.000]  Смотрите, ведь идея такая.
[52:16.000 --> 52:20.000]  Вбор можно покрыть практически к путями.
[52:20.000 --> 52:21.000]  Согласны?
[52:23.000 --> 52:27.000]  Давайте рассмотрим в каждой из этих путей.
[52:28.000 --> 52:30.000]  В каждой из этих путей.
[52:31.000 --> 52:33.000]  В каждой из этих путей.
[52:33.000 --> 52:36.000]  Давайте рассмотрим в каждой из этих путей.
[52:38.000 --> 52:42.000]  Пусть вот этот путь соответствует строке print.
[52:45.000 --> 52:48.000]  Тогда я утверждаю, как мы тогда будем искать.
[52:50.000 --> 52:51.000]  Ну вот.
[52:51.000 --> 52:52.000]  Вот.
[52:56.000 --> 53:00.000]  Казалось бы, как мы хотели бы искать все...
[53:00.000 --> 53:07.000]  Вот для каждого префикса у нее мы хотим найти как бы в каждой позиции как бы самую длинную заканчивающуюся, да?
[53:08.000 --> 53:09.000]  Как нам это сделать?
[53:10.000 --> 53:11.000]  А сделать?
[53:11.000 --> 53:12.000]  Ну там же.
[53:12.000 --> 53:16.000]  Давайте просто, опять же, идти и набирать префикс, префикс, префикс, префикс.
[53:17.000 --> 53:18.000]  Вот.
[53:18.000 --> 53:24.000]  Потом там двумя указателями с помощью хэшей понимать, находить префикс, который можно продлить, ну и так далее, и так далее.
[53:24.000 --> 53:26.000]  Ну, ту же самую схему предъявлять.
[53:26.000 --> 53:31.000]  Помните, мы в префикс пункции то же самое делали, когда вместо текста подставляли там саму же самую строчку и то же самое делали.
[53:33.000 --> 53:34.000]  Что нам помешает?
[53:36.000 --> 53:42.000]  Вот просто аккуратно так проделать и для каждой позиции в каждой строке P прям честно все вхождения других строк и найти.
[53:42.000 --> 53:43.000]  Что нам помешает?
[53:46.000 --> 53:58.000]  Так у нас же каждый раз, собственно, ну в общем, левая касса будет нулем, потому что вот на этой путь есть строка одна из эссетов.
[54:00.000 --> 54:02.000]  Или мы типа без нее как бы рассматриваем.
[54:02.000 --> 54:03.000]  Без чего?
[54:03.000 --> 54:06.000]  Ну у нас же путь в боре это строка одна из эссетов.
[54:07.000 --> 54:08.000]  Да.
[54:08.000 --> 54:12.000]  А мы как бы говорили, что мы ищем в ней все остальные, кроме нее.
[54:12.000 --> 54:17.000]  Ну это не важно, потому что мы ее саму только в самом конце найдем, это не проблема.
[54:18.000 --> 54:20.000]  Так что мы тут автоматически ищем другие строки.
[54:20.000 --> 54:28.000]  Но у нас все равно может быть проблема, что мы сейчас сняли префикс какой-то, который является префисом другой строки, но за этим у него будет еще одна строка.
[54:28.000 --> 54:31.000]  Да, да, да. Действительно.
[54:31.000 --> 54:38.000]  Да, самый длинный префикс, который является, то есть самую длинную подстроку, которая является префисом другой строки мы найти можем.
[54:38.000 --> 54:42.000]  Но опять же, саму по себе это нам не помогает.
[54:44.000 --> 54:55.000]  Но с другой стороны заметим, что приятно, заметим, что тогда получается, когда мы проверяем вот этот префикс, мы замечаем, что этот префикс короче.
[54:56.000 --> 54:59.000]  Поэтому оказывается неожиданная читерская идея.
[55:00.000 --> 55:12.000]  Давайте это делать все-таки не для каждой строки s отдельно, а давайте пытаться насчитывать этот max-суффикс в порядке bfs.
[55:12.000 --> 55:29.000]  Вот. То есть смотрите, давайте насчитывать max-суффикс в порядке bfs. То есть сначала здесь, потом здесь, потом здесь, потом здесь, потом здесь, потом здесь, ну и так далее.
[55:29.000 --> 55:31.000]  Просто bfs, bfs, bfs.
[55:31.000 --> 55:49.000]  И тогда получается примерно следующая идея. Предположим, мы дошли до какой-то вершины. Мы дошли до какой-то вершины.
[55:49.000 --> 55:58.000]  Она является, и эта вершина является префиксом какой-то вот строки s. Я тут ее даже вот напишу. Вот.
[56:00.000 --> 56:03.000]  Вот допустим, вот в этой вершине.
[56:04.000 --> 56:08.000]  Тогда как мы будем искать самый длинный суффикс?
[56:09.000 --> 56:12.000]  Как мы будем искать самый длинный суффикс?
[56:12.000 --> 56:17.000]  Но для этого у нас идея такая. Мы как будто у нас два указателя закончились здесь.
[56:17.000 --> 56:20.000]  Вот допустим, мы тут самый длинный суффикс вот такой вот нашли. Ну допустим.
[56:25.000 --> 56:30.000]  То есть самый длинный суффикс, который является еще как бы...
[56:30.000 --> 56:41.000]  Ну хотя как бы чем он является?
[56:47.000 --> 56:54.000]  Да, на самом деле да, искать самый длинный префикс, который является префиксом хоть кого-то, нас действительно тут не устраивает.
[56:54.000 --> 57:01.000]  То есть нам действительно было бы, да, нам было бы интересно немножко другое.
[57:03.000 --> 57:11.000]  То есть в идеале бы конечно хотелось бы по каждой строке s. и т. прогуливаться и как бы игнорировать и префиксы там соответственно игнорировать другие строки.
[57:14.000 --> 57:15.000]  Ну вот.
[57:17.000 --> 57:19.000]  Но конечно получится.
[57:19.000 --> 57:20.000]  Получится.
[57:24.000 --> 57:26.000]  Придется официально суффиксные ссылки выводить.
[57:30.000 --> 57:32.000]  Ну ладно. Жалко.
[57:33.000 --> 57:35.000]  Нет, это все-таки получится.
[57:35.000 --> 58:03.000]  Ну ладно, в общем короче говоря, ладно, придется на это все действительно забить, а вместо этого на самом деле пойти, имея в виду все это, вспомнить, что нам для того, чтобы бегать по тексту t, нам потребуется еще кое-что.
[58:04.000 --> 58:05.000]  А потребуется нам еще вот что.
[58:06.000 --> 58:13.000]  Когда мы тут бегаем двумя указателями, у нас как бы два варианта. Мы либо правые указатели сдвигаем сюда, либо мы левые указатели куда-то сдвигаем, правда?
[58:14.000 --> 58:24.000]  А как мы его сдвигаем? Сдвигаем мы его так. То есть вот у нас есть префикс и мы хотим найти следующий, то есть как бы собственный суффикс этого префикса, который тоже каким-то суффиксом является, правда?
[58:25.000 --> 58:40.000]  И поэтому предлагается собственно честные ввести. То есть на самом деле вместо синих функций мы введем одну красивую рыжую. Мы введем понятие суфф отвалили.
[58:41.000 --> 58:43.000]  И будем называть это суффиксные ссылки.
[58:54.000 --> 58:56.000]  Так хотелось так выжить.
[58:57.000 --> 59:00.000]  И получается тогда следующее. Суфф от v.
[59:02.000 --> 59:04.000]  Значит да, v не равно root, я сразу скажу.
[59:05.000 --> 59:27.000]  Это такая вершина u, тоже вершина, такая что ps от u это собственный суффикс, собственный суффикс ps от v.
[59:28.000 --> 59:33.000]  И соответственно модуль ps от u максимально возможен.
[59:34.000 --> 59:47.000]  Сразу обращаем внимание на маленькую приятную вещь.
[59:47.000 --> 59:57.000]  Почему я тут написал, что v не равно root? Потому что для любой вершины эта суффиксная ссылка определена абсолютно корректно.
[59:58.000 --> 01:00:06.000]  Как минимум потому что у нас всегда есть корень, потому что пустая строка является собственным суффиксом чьего угодно.
[01:00:06.000 --> 01:00:08.000]  Осторожно.
[01:00:15.000 --> 01:00:26.000]  И тогда получается следующее, что если мы эти собственные ноты, то есть предположим что у нас вот эти суффиксные ссылки в море откуда-то с небес по факсу нам пришли.
[01:00:27.000 --> 01:00:38.000]  Тогда, ну во-первых, вот этот вот процесс, вот этот вот выставказатель, тогда прекрасно делается без мапов.
[01:00:38.000 --> 01:00:56.000]  Но при этом, что нам еще надо? Нам еще нужно max another s суффикс и max, самое главное, max суффикс nss.
[01:00:56.000 --> 01:01:06.000]  Но что такое max суффикс nss по большому счету? Что нам позволяет сделать суффиксная ссылка? Каждому потенциальному префиксу вот этому, да?
[01:01:07.000 --> 01:01:22.000]  Какой-нибудь строки s, то есть что такое суффиксная ссылка? То есть как бы если этот префикс соответствует вершине v, то как бы вот, то тогда второй подлине суффикс в этой позиции, он у нас будет тогда суфот v.
[01:01:23.000 --> 01:01:27.000]  Как найти третье подлине?
[01:01:27.000 --> 01:01:46.000]  Ну да, если мы в этой позиции хотим не тот самый длинный суффикс, который префиксом является, но все.
[01:01:46.000 --> 01:01:58.000]  То есть второй тогда находится как суфф от него, третий как суфф от суфф от него, ну и так далее.
[01:01:59.000 --> 01:02:07.000]  То есть, соответственно, третий мы находим как суфф от суфф и так далее.
[01:02:07.000 --> 01:02:25.000]  И так далее. То есть получается, то есть в море на самом деле тут поиграть вот даже тут можно. Вот например давайте, а вот из вот этой строки ABBA куда у нас отправится суффиксная ссылка? Вот давайте примерно смотрим.
[01:02:37.000 --> 01:02:52.000]  Ну да, потому что смотрите ABBA, BBA в море не представлено, там собственно BA в море не представлено, A в море представлено, ну значит тут суффиксная ссылка вот сюда и отправляется.
[01:02:52.000 --> 01:03:00.000]  А у ABBA куда ссылка проявляется?
[01:03:00.000 --> 01:03:10.000]  Веселее всех у BBA, потому что тут суффиксные ссылки вообще вот так вот все красивенько идут.
[01:03:10.000 --> 01:03:19.000]  Но вообще говоря, легко заметить, что суффиксные ссылки образуют соответственно дерево.
[01:03:19.000 --> 01:03:26.000]  Ну такое дерево суффиксных ссылок с корнем стартовой вершины бора.
[01:03:26.000 --> 01:03:36.000]  Отсюда суффиксная ссылка куда идет?
[01:03:36.000 --> 01:03:47.000]  И что приятно, то есть получается если вы нашли самый длинный, как я сказал, префикс, то вы прогуливаетесь по этому пути в дереве, по предочкам деревя и находите собственно все вершины.
[01:03:48.000 --> 01:04:00.000]  Если у вас этот дерево вам с небес по факсу прислали, то на самом деле max-suffix-nss после этого насчитать становится очень просто.
[01:04:00.000 --> 01:04:07.000]  Ну потому что по большому счету вам вы просто должны скакать по суффиксным ссылкам до тех пор, пока не упретесь в крестик.
[01:04:07.000 --> 01:04:13.000]  А когда вы упретесь в крестик, ну вы сможете просто простой динамик признания посчитать.
[01:04:13.000 --> 01:04:25.000]  Ну просто если у вас суффиксные ссылки есть, то вот это вы теперь тоже за линию от размера бора посчитаете.
[01:04:25.000 --> 01:04:27.000]  Ну да.
[01:04:27.000 --> 01:04:36.000]  Ну что такое max-suffix-nss? То есть вы идете из вершины В по суффиксным ссылкам до тех пор, пока не упретесь либо в корень, либо в крестик, правда?
[01:04:37.000 --> 01:04:41.000]  Остается только насчитать, где этот крестик будет.
[01:04:41.000 --> 01:04:47.000]  Ну тогда у вас два варианта. Либо у вас вершина уже сама крестик, и тогда max-suffix-nss равно V, правда?
[01:04:47.000 --> 01:04:55.000]  Либо она не крестик, тогда вы скачете по суффиксным ссылкам и берете значение уже от нее, правда?
[01:04:55.000 --> 01:05:06.000]  То есть получается такая линиевая динамика, с помощью которой вы для каждой вершины бора, собственно, легко насчитаете max-suffix-ns.
[01:05:06.000 --> 01:05:13.000]  То есть вы по сути продумали рекурсивную формулу для max-suffix-ns?
[01:05:13.000 --> 01:05:15.000]  По сути, да.
[01:05:15.000 --> 01:05:32.000]  То есть давайте я ее даже в этом видео напишу, что max-suffix-nss от V равно, ну, во-первых, alt, если V равно root.
[01:05:32.000 --> 01:05:34.000]  Понятно, да?
[01:05:35.000 --> 01:05:44.000]  Ну, соответственно, сама по всей вершине V, если так сказать, из n от V равно root.
[01:05:46.000 --> 01:05:53.000]  Ну, из n, то есть там понятно, в каждой вершине флажок, типа, да, является ли это, то есть это концом прям целой строки, да или нет?
[01:05:54.000 --> 01:06:06.000]  И max-suffix-nss от, соответственно, теперь suff от V.
[01:06:06.000 --> 01:06:23.000]  Если там V равно root и из n равно false.
[01:06:23.000 --> 01:06:38.000]  То есть намекаем, что, как я сказал, если суффиксные ссылки вам прислали с небес по факсу, то, в общем-то, max-suffix-nss вы теперь элементарно насчитываете, правда?
[01:06:42.000 --> 01:06:44.000]  Ну, а теперь самое интересное. Ну вот.
[01:06:44.000 --> 01:06:51.000]  Ну и более того, на самом деле, практически, после этого вы практически бесплатно вычисляете вот эту черную функцию.
[01:06:53.000 --> 01:07:03.000]  Потому что max-another, вот как теперь по строке, по крестику, посчитать следующий крестик на суффиксном пути, да, по большому счету?
[01:07:03.000 --> 01:07:06.000]  s-suffix
[01:07:10.000 --> 01:07:14.000]  от, допустим, какого-нибудь i равно.
[01:07:16.000 --> 01:07:19.000]  Ну, элементарно. Вы должны взять вершину.
[01:07:20.000 --> 01:07:24.000]  Ну, на самом деле, я вот, сейчас я вот магическую форму достаточно напишу.
[01:07:25.000 --> 01:07:30.000]  То есть она равна, это max-suffix-ns от suffix от V. Ну да.
[01:07:31.000 --> 01:07:33.000]  Да, тут даже случаев нет.
[01:07:33.000 --> 01:07:39.000]  max-suffix-nss от V, так сказать, от s-i.
[01:07:39.000 --> 01:07:44.000]  Где V от s-i это вершина соответствующая этой строке Вора.
[01:07:49.000 --> 01:07:52.000]  Ну ладно, это не совсем правда.
[01:07:56.000 --> 01:08:01.000]  Вот так напишу num-s от этого, потому что вот эта вот вершина, она нам нужен много.
[01:08:02.000 --> 01:08:04.000]  Это есть так, формально придраться.
[01:08:06.000 --> 01:08:11.000]  А, ой, еще наврал. Нам не просто надо эту вершину взять, а еще суффиксную ссылку эти.
[01:08:12.000 --> 01:08:14.000]  Совсем заклинание.
[01:08:20.000 --> 01:08:22.000]  Вот, приятен, в принципе.
[01:08:25.000 --> 01:08:28.000]  Так, я понимаю, это понятно, что это откуда мы это заклинание берем.
[01:08:29.000 --> 01:08:33.000]  Ну, у нас какие-то обозначения вот такие взяли, что...
[01:08:34.000 --> 01:08:37.000]  Ну, тут самое главное, чтобы понимать, откуда они берутся.
[01:08:38.000 --> 01:08:41.000]  Если вы понимаете, откуда они берутся, то там это не проблема.
[01:08:41.000 --> 01:08:44.000]  Вы еще сами ориентируйтесь, что я еще тут забыл.
[01:08:44.000 --> 01:08:51.000]  Ну, то есть, по большому счету, я беру строку s-i-t, я беру, в какой вершине Вора она заканчивается.
[01:08:52.000 --> 01:08:55.000]  Я хочу найти собственный суффикс ее, который тоже какая-то строка.
[01:08:56.000 --> 01:08:57.000]  Что я для этого делаю?
[01:08:57.000 --> 01:09:02.000]  Я беру самый большой собственный суффикс, который является хоть кем-то этой вот по суффиксной ссылке.
[01:09:02.000 --> 01:09:04.000]  То есть, вот это вот V от s-i.
[01:09:05.000 --> 01:09:07.000]  Я прогуливаюсь по суффиксной ссылке.
[01:09:07.000 --> 01:09:10.000]  А потом теперь у нее надо найти ближайший крестик.
[01:09:11.000 --> 01:09:13.000]  Ближайший крестик.
[01:09:13.000 --> 01:09:15.000]  То есть, я иду, иду.
[01:09:15.000 --> 01:09:16.000]  То есть, вот картинка такая.
[01:09:16.000 --> 01:09:18.000]  Иду, иду, вот насажу крестик.
[01:09:18.000 --> 01:09:21.000]  И вот эта вот ссылка maxsuffixnss.
[01:09:27.000 --> 01:09:28.000]  Это она и есть.
[01:09:29.000 --> 01:09:31.000]  Вот ближайший крестик.
[01:09:32.000 --> 01:09:33.000]  Вот.
[01:09:33.000 --> 01:09:37.000]  И, соответственно, потом после этого я беру numessage.
[01:09:37.000 --> 01:09:38.000]  Почему я беру numessage?
[01:09:38.000 --> 01:09:39.000]  Потому что это вершина.
[01:09:39.000 --> 01:09:42.000]  От этой вершины надо понять, какая строка в ней заканчивается.
[01:09:44.000 --> 01:09:46.000]  То есть, таким образом все.
[01:09:46.000 --> 01:09:53.000]  То есть, на самом деле краеугольным камнем теперь становится вопрос, как насчитать суффиксные ссылки.
[01:09:54.000 --> 01:09:59.000]  То есть, если мы научимся насчитывать суффиксные ссылки, то все остальное мы насчитываем практически бесплатно.
[01:10:02.000 --> 01:10:03.000]  Понятно?
[01:10:03.000 --> 01:10:04.000]  Вот.
[01:10:04.000 --> 01:10:08.000]  То есть, насчитываем бесплатно, и там все, собственно, все подходы делаем.
[01:10:08.000 --> 01:10:09.000]  Так.
[01:10:09.000 --> 01:10:10.000]  Вычеркиваем.
[01:10:11.000 --> 01:10:13.000]  Ну, в принципе, у вас есть теоретический выбор.
[01:10:14.000 --> 01:10:18.000]  Как говорится, добьем этот алгоритм и оставим на следующий раз.
[01:10:18.000 --> 01:10:21.000]  Ну, в принципе да.
[01:10:21.000 --> 01:10:23.000]  В общем-то, на самом деле да.
[01:10:24.000 --> 01:10:27.000]  На самом деле к концу мы близки как никогда.
[01:10:28.000 --> 01:10:29.000]  Так.
[01:10:29.000 --> 01:10:31.000]  Ладно, до этого момента вопросы есть?
[01:10:34.000 --> 01:10:41.000]  То есть, я, потому что я сейчас хочу это все стереть и сказать, у меня есть блог, я хочу, наверное, насчитать суффиксные ссылки и все, что я хочу сделать.
[01:10:42.000 --> 01:10:43.000]  Да.
[01:10:47.000 --> 01:10:48.000]  Да.
[01:10:48.000 --> 01:11:03.000]  Ну, ответ простой.
[01:11:03.000 --> 01:11:08.000]  Мы в каждый момент времени говорим, если мы можем сдвинуть правый, мы его двигаем.
[01:11:08.000 --> 01:11:15.000]  В чем не только двигаем, но в этот момент у нас, как бы, получается новая граница, и мы здесь перебираем, собственно, все эти строчки, которые тут нашлись.
[01:11:16.000 --> 01:11:21.000]  Как только мы сдвинули правый указатель, мы тут же по этой позиции перебираем.
[01:11:25.000 --> 01:11:28.000]  Ну, правый указатель у нас по одной позиции.
[01:11:28.000 --> 01:11:30.000]  Как только мы его сдвинули...
[01:11:34.000 --> 01:11:37.000]  Ну, левый... Смотрите, в каждый момент времени у нас происходит следующее.
[01:11:38.000 --> 01:11:41.000]  Ну, смотрите, изначально было так.
[01:11:42.000 --> 01:11:51.000]  То есть у нас изначально, допустим, было так, что вот у нас этот правый указатель стоял здесь, а левый указатель стоял так, что они задавали самый длинный префикс, который оканчивается в этой позиции.
[01:11:51.000 --> 01:11:57.000]  В этот момент мы у этого префикса перебрали все суффиксы и нашли среди них все подстроки.
[01:11:58.000 --> 01:12:00.000]  Теперь мы пытаемся двигать указатели.
[01:12:00.000 --> 01:12:04.000]  Теперь мы говорим, верно ли, что вот этот суффикс можно прямо вот и продлить?
[01:12:05.000 --> 01:12:10.000]  Если можно, то мы бы его и продляли, это был бы самый длинный суффикс, очевидно.
[01:12:10.000 --> 01:12:12.000]  Если нет, значит придется продлить какой-то меньший суффикс.
[01:12:12.000 --> 01:12:14.000]  Берем второй, то есть вот суффиксный суффикс, да?
[01:12:14.000 --> 01:12:16.000]  Можно ли его продлить? Нельзя.
[01:12:16.000 --> 01:12:19.000]  Берем следующий, следующий, до тех пор пока очередной не продлится.
[01:12:19.000 --> 01:12:25.000]  И как только продлится, значит мы нашли самый длинный суффикс, заканчивается здесь, и уже у него мы уже перебираем вот это все.
[01:12:26.000 --> 01:12:27.000]  Вот так это работает.
[01:12:27.000 --> 01:12:38.000]  Причем заметим, что сами все два указателя работают все еще за ОАТ, и, соответственно, а вот эти переборы мы делаем за ОАТАНС, потому что у нас есть уже более продвинутая относительность суффиксов.
[01:12:41.000 --> 01:12:59.000]  Так что все у нас уперлось в то, чтобы надо теперь вместо вот этих мапов, убить эти мапы, и надо теперь по вот этим строчкам для каждой вершины найти ее суффиксную ссылку и сделать это за, ну, хотя бы, ну, тут разные вещи.
[01:12:59.000 --> 01:13:02.000]  Либо за размер бора, либо за суммар длинных строчек.
[01:13:02.000 --> 01:13:04.000]  Дайте мне одно и то же.
[01:13:05.000 --> 01:13:06.000]  Сидел?
[01:13:07.000 --> 01:13:08.000]  Как же это делать?
[01:13:08.000 --> 01:13:10.000]  Так, вот до этого момента вопрос есть, могу стирать?
[01:13:11.000 --> 01:13:12.000]  Хорошо.
[01:13:13.000 --> 01:13:14.000]  И теперь финалочка.
[01:13:16.000 --> 01:13:17.000]  Итак, насчитываем суффиксную ссылку.
[01:13:17.000 --> 01:13:22.000]  Кстати, о тексте Т мы в этом месте вообще забыли.
[01:13:25.000 --> 01:13:26.000]  Итак, как же это делать?
[01:13:28.000 --> 01:13:31.000]  Ну, идея, на самом деле, была, как я уже сказал.
[01:13:31.000 --> 01:13:33.000]  То есть рассмотрим строчку СИ.
[01:13:33.000 --> 01:13:39.000]  Вот нам, например, очень хочется насчитать суффиксные ссылки для всех вершин, которые соответствуют ей.
[01:13:42.000 --> 01:13:43.000]  Понятно, да?
[01:13:47.000 --> 01:13:49.000]  Ну, здесь идея-то будет та же самая.
[01:13:54.000 --> 01:13:56.000]  И получается примерно следующее.
[01:13:56.000 --> 01:14:00.000]  Вот давайте перебирать все эти вершины, и будем их рассмотреть.
[01:14:00.000 --> 01:14:05.000]  Вот давайте перебирать все эти вершины, и в их порядке суффиксную ссылку находить.
[01:14:06.000 --> 01:14:07.000]  То есть находить вот самые длинные.
[01:14:07.000 --> 01:14:10.000]  Вот, допустим, мы для этой вершины нашли самый длинный суффикс.
[01:14:11.000 --> 01:14:14.000]  Собственный суффикс, который является еще и чьим-то префиксом.
[01:14:16.000 --> 01:14:17.000]  Дальше...
[01:14:18.000 --> 01:14:22.000]  Ну, логика-то, в общем-то, дальше тоже те самые два указателя.
[01:14:22.000 --> 01:14:27.000]  То есть мы пытаемся сдвинуть этот указатель и говорить, так, вот это является чьим-то префиксом.
[01:14:27.000 --> 01:14:29.000]  Ну, мы помним, что длиннее тут не будет.
[01:14:29.000 --> 01:14:33.000]  Потому что если у нас вот тут какой-то был суффикс, то и тут был бы суффикс.
[01:14:33.000 --> 01:14:34.000]  Это невозможно, правда?
[01:14:35.000 --> 01:14:38.000]  Поэтому, значит, пытаемся тут, как всегда, двигать указатель.
[01:14:40.000 --> 01:14:43.000]  Если, ну, допустим, пока с помощью хэшей.
[01:14:43.000 --> 01:14:45.000]  Ладно, так и быть, поверим хэши еще пока.
[01:14:46.000 --> 01:14:51.000]  Если у нас есть хэши сообщать, что такого префикса нет, значит, мы сдвигаем этот указатель.
[01:14:51.000 --> 01:14:54.000]  Если такого префикса нет, то сдвигаем.
[01:14:54.000 --> 01:14:55.000]  Сдвигаем.
[01:14:55.000 --> 01:14:57.000]  Ну и так, пока очередной префикс не найдется.
[01:14:57.000 --> 01:15:00.000]  Как только найдется, вот он, суффиксную ссылку есть.
[01:15:02.000 --> 01:15:03.000]  Обратите внимание.
[01:15:03.000 --> 01:15:04.000]  Кстати, с помощью...
[01:15:04.000 --> 01:15:10.000]  Если бы мы еще верили в хэши, то эту суффиксную ссылку получается для каждой стротии сытая.
[01:15:10.000 --> 01:15:15.000]  Мы бы легко за О от ее ины насчитали сбой.
[01:15:15.000 --> 01:15:16.000]  Согласны?
[01:15:18.000 --> 01:15:23.000]  То есть просто по каждой независимой два указателя прибежали и получили себе сбой.
[01:15:24.000 --> 01:15:26.000]  Почему хэши еще раз?
[01:15:26.000 --> 01:15:27.000]  Пока...
[01:15:27.000 --> 01:15:31.000]  Ну, потому что классические два указателя говорят, что мы говорим, так, вот этого префикса нет.
[01:15:31.000 --> 01:15:32.000]  Выпиливаем один символ.
[01:15:32.000 --> 01:15:33.000]  Вот этот префикс есть.
[01:15:35.000 --> 01:15:37.000]  А потом вот этот, вот этот и вот этот.
[01:15:38.000 --> 01:15:39.000]  А теперь...
[01:15:41.000 --> 01:15:42.000]  А теперь стандарт.
[01:15:42.000 --> 01:15:47.000]  Чтобы удалить хэши, мы говорим, что для того, чтобы...
[01:15:47.000 --> 01:15:48.000]  То есть, как всегда, для того, чтобы...
[01:15:48.000 --> 01:15:54.000]  Заметим, что если от этого суффикса отпилить вот этот символ, то получится один из суффиксов, который был в этой позиции.
[01:15:54.000 --> 01:15:55.000]  Правда?
[01:15:56.000 --> 01:16:00.000]  Поэтому получается, что надо перебрать, по большому счету, опять.
[01:16:00.000 --> 01:16:04.000]  Взять не самый длинный, не только самый длинный суффикс в этой вершине, а еще и вот...
[01:16:05.000 --> 01:16:12.000]  Все вот эти вот и перебрать их просто в порядке убывания до тех пор, пока и не найдется один...
[01:16:13.000 --> 01:16:16.000]  Герой, которого можно на этот символ продать.
[01:16:16.000 --> 01:16:17.000]  А как их перебрать?
[01:16:18.000 --> 01:16:19.000]  Суффиксами?
[01:16:19.000 --> 01:16:20.000]  Конечно.
[01:16:20.000 --> 01:16:23.000]  То есть, вместо того, чтобы перебрать лапчиком, мы берем...
[01:16:23.000 --> 01:16:27.000]  Говорим, так, если этот можно продлить на этот символ, значит его и продлеваем.
[01:16:27.000 --> 01:16:31.000]  Если нет, скачем из него, из его вершины по суффиксной ссылке.
[01:16:31.000 --> 01:16:33.000]  Примеряем, можно ли там ее предложить.
[01:16:33.000 --> 01:16:34.000]  Это в более делается.
[01:16:34.000 --> 01:16:36.000]  Итак, скачем, скачем, скачем, ну и так далее.
[01:16:36.000 --> 01:16:51.000]  И тогда получается, ну правда, для этого получается нужно, чтобы мы уже насчитали суффиксные ссылки для всех вот этих вот вершин.
[01:16:55.000 --> 01:17:01.000]  Но заметим, что вот проблема тут маленькая техническая заключается в том, что вот эти вот строки, если брать их как префиксы в поре,
[01:17:01.000 --> 01:17:05.000]  то они не обязательно являются префиксами строки СИТ.
[01:17:06.000 --> 01:17:08.000]  Понимаете, да?
[01:17:08.000 --> 01:17:10.000]  Понимаете?
[01:17:12.000 --> 01:17:14.000]  Понятно, Александр?
[01:17:14.000 --> 01:17:16.000]  Поэтому, то есть, нужно, чтобы они были насчитаны.
[01:17:16.000 --> 01:17:18.000]  Поэтому идея такая.
[01:17:18.000 --> 01:17:26.000]  Вот тут-то мы включаем идею, что, а давайте для всех вершин прям в поре насчитывать суффиксную ссылку, честно, в порядке BFS.
[01:17:27.000 --> 01:17:31.000]  Тогда, конечно, не очень слету понятно, почему это работает за линию, да.
[01:17:31.000 --> 01:17:35.000]  Бывает тогда ошибка, что это работает от размера поры.
[01:17:36.000 --> 01:17:38.000]  Я бы был бы аккуратен.
[01:17:38.000 --> 01:17:40.000]  Я не уверен, что это так.
[01:17:40.000 --> 01:17:45.000]  Потому что я и не уверен, что этот алгоритм реально работает за О от количества вершин в поре.
[01:17:45.000 --> 01:17:54.000]  Но то, что я могу гарантировать, так это то, что этот алгоритм работает за О от суммы всех исследований.
[01:17:54.000 --> 01:18:01.000]  Потому что я могу просто вот этим вот методом просто продемонстрировать, что этот, если рассмотреть прям путь строки СИ,
[01:18:01.000 --> 01:18:06.000]  то тогда она будет обработана за О от длины этой строки.
[01:18:08.000 --> 01:18:10.000]  Но О от размера поры это, кстати, неправда.
[01:18:10.000 --> 01:18:16.000]  Потому что размер поры может быть синтетически меньше, чем все-таки сумма всех строчек,
[01:18:16.000 --> 01:18:19.000]  потому что у них там префиксы могут сильно накладываться.
[01:18:22.000 --> 01:18:24.000]  Понятная идея, да?
[01:18:26.000 --> 01:18:30.000]  Особенно, если там была куча строчек, играются префиксами друг друга.
[01:18:31.000 --> 01:18:37.000]  Хотя, на другой стороне, если одна строка является префиксом другой, то, в общем-то, она тут в этой синтотике ее можно не учитывать.
[01:18:38.000 --> 01:18:41.000]  Потому что она считала для одной строки, и мы, собственно, даем ее префиксам.
[01:18:41.000 --> 01:18:46.000]  Ну, все равно мы же делали, что никакая не будет являться по строкой никакой, но все равно там будет...
[01:18:46.000 --> 01:18:50.000]  У них будет больше-больше общий префикс, из которого они все так же...
[01:18:50.000 --> 01:18:54.000]  Ну да, да, да. И то, правда. Поэтому лучше не надо.
[01:18:54.000 --> 01:18:56.000]  Вот. Но здесь два варианта у нас.
[01:18:56.000 --> 01:18:59.000]  Но здесь, на самом деле, тоже есть два варианта, как реализовывать.
[01:18:59.000 --> 01:19:00.000]  Смотрите.
[01:19:00.000 --> 01:19:03.000]  Вот если реализовать вот так в порядке BFS,
[01:19:05.000 --> 01:19:06.000]  то смотрите, что у вас получится.
[01:19:06.000 --> 01:19:09.000]  С одной стороны, у вас получится все красиво за сумму S,
[01:19:09.000 --> 01:19:15.000]  но недостаток алгоритма будет в том, что когда вы все-таки вспомните про текст T и будете по нему ходить,
[01:19:15.000 --> 01:19:18.000]  у вас, при добавлении каждого символа, что получится?
[01:19:18.000 --> 01:19:21.000]  Получится от единицы амортизированной, правда?
[01:19:21.000 --> 01:19:24.000]  Потому что вам придется по этим суффиксным ссылкам реально скакать, правда?
[01:19:26.000 --> 01:19:29.000]  Но заметим, что и там вам придется скакать по суффиксным ссылкам,
[01:19:29.000 --> 01:19:32.000]  и тут вам, по сути, придется скакать по суффиксным ссылкам, да?
[01:19:33.000 --> 01:19:34.000]  А ведь по большому счету...
[01:19:34.000 --> 01:19:35.000]  Я просто почему не иду?
[01:19:35.000 --> 01:19:43.000]  То есть по большому счету и в этом проходе, и в том проходе у вас опять возникает функция go от vchar,
[01:19:43.000 --> 01:19:44.000]  аналогичная префиксия.
[01:19:44.000 --> 01:19:45.000]  Помните?
[01:19:46.000 --> 01:19:50.000]  Которая говорит, что вы находитесь в вершине и пытаетесь пройти по символу ch.
[01:19:50.000 --> 01:19:56.000]  И вы говорите там, пишем, while v не равно root, да?
[01:19:59.000 --> 01:20:05.000]  While там v не равно root.
[01:20:07.000 --> 01:20:15.000]  Ну, давайте end-end не can go vch,
[01:20:16.000 --> 01:20:18.000]  то, собственно, v равно суфф от v.
[01:20:21.000 --> 01:20:26.000]  И говорим, что, значит, если can go,
[01:20:29.000 --> 01:20:34.000]  то, собственно, vturn go vch,
[01:20:35.000 --> 01:20:36.000]  lza.
[01:20:40.000 --> 01:20:47.000]  Ладно, только аккуратно, тут не go, а go and work, конечно.
[01:20:50.000 --> 01:20:53.000]  И тут, конечно, can go, имеется в виду and work.
[01:20:59.000 --> 01:21:01.000]  Да, надо было и правильно писать, а то...
[01:21:03.000 --> 01:21:07.000]  Ну, это физтех, как у нас говорят, if you want to be ok,
[01:21:08.000 --> 01:21:10.000]  вот аимби шевридей, соответственно, да?
[01:21:11.000 --> 01:21:12.000]  Так известно.
[01:21:13.000 --> 01:21:17.000]  Вот, да, у нас тут немножко и на этом цикле получилось, но что делать?
[01:21:21.000 --> 01:21:28.000]  Ну, иначе можно создать v, на самом деле можно написать...
[01:21:29.000 --> 01:21:34.000]  Вот, то есть, по большому счету, через go можно и вычисления суффиксных ссылок забавахать,
[01:21:35.000 --> 01:21:38.000]  и потом проход по тексту t.
[01:21:40.000 --> 01:21:44.000]  Но по большому счету заметим, что аналогично префикс функции,
[01:21:45.000 --> 01:21:49.000]  это можно привести просто в go от vch.
[01:21:50.000 --> 01:21:51.000]  Правда?
[01:21:53.000 --> 01:21:56.000]  И получится, я сейчас не буду расписывать, но получается...
[01:21:57.000 --> 01:22:00.000]  То есть, здесь вводится то, что я называю автомат аха караси,
[01:22:01.000 --> 01:22:03.000]  по аналогии с автоматом префикс функции.
[01:22:04.000 --> 01:22:05.000]  То есть, у вас будет два варианта.
[01:22:06.000 --> 01:22:09.000]  Если у вас алфавит маленький, то вы можете на самом деле суффиксные ссылки насчитывать тоже,
[01:22:10.000 --> 01:22:12.000]  насчитать их прям как в виде автомата,
[01:22:13.000 --> 01:22:18.000]  и после этого по тексту t хотите, чтобы каждый новый символ будет обрабатываться прям жестко,
[01:22:18.000 --> 01:22:21.000]  прям жестко за о от единицы, ну плюс сколько вхождения вы там даете.
[01:22:23.000 --> 01:22:26.000]  Ну, честно скажем, дальше все зависит от того, какие у вас задачи.
[01:22:27.000 --> 01:22:28.000]  Потому что, например, самое...
[01:22:29.000 --> 01:22:33.000]  Да, у нас получается, что алкаритм работает за линию ввода плюс о от ответа,
[01:22:34.000 --> 01:22:37.000]  но дальше все зависит от того, какие задачи мы решаем.
[01:22:39.000 --> 01:22:41.000]  Ну, например, вот самая тупая задача, например, как тут можно привести,
[01:22:42.000 --> 01:22:44.000]  а давайте мы не будем требовать, например, всех вхождений,
[01:22:45.000 --> 01:22:47.000]  а вместо этого просто вам попроще сказать,
[01:22:48.000 --> 01:22:51.000]  есть ли у вас девочка s, вы сходите, входит ли она в текст t как под строка.
[01:22:52.000 --> 01:22:53.000]  Да или нет?
[01:22:56.000 --> 01:22:58.000]  Вот давайте, вот вам задача.
[01:23:05.000 --> 01:23:08.000]  Ну, можно такое сделать, мы проходим все по строке t, да,
[01:23:09.000 --> 01:23:11.000]  и запоминаем все, в которых мы побывали.
[01:23:12.000 --> 01:23:16.000]  И тогда нужно для каждой s и t проверить, что хотя бы одна вершина ее по дереве была посещена.
[01:23:16.000 --> 01:23:17.000]  Ну, привет, да.
[01:23:18.000 --> 01:23:20.000]  Ну, там, ее по дереве, по суффиксным ссылкам.
[01:23:21.000 --> 01:23:22.000]  Ну, можно так проверить, можно по-другому,
[01:23:23.000 --> 01:23:25.000]  потому что по большому счету мы говорим, что мы как бы,
[01:23:26.000 --> 01:23:28.000]  по идее, для каждой вершины, когда мы прогуливаемся в тексте t,
[01:23:29.000 --> 01:23:31.000]  должны были прогуляться по вот этим вот синим ссылкам,
[01:23:32.000 --> 01:23:33.000]  которые max.suffix.ns, да?
[01:23:34.000 --> 01:23:35.000]  Ну, например.
[01:23:36.000 --> 01:23:39.000]  Или просто прогуляться по всем суффиксным ссылкам и пометить там все крестики, правда?
[01:23:40.000 --> 01:23:41.000]  Так давайте это делать, ну, в конце.
[01:23:42.000 --> 01:23:44.000]  То есть для начала пометим все вершины, в которых мы вообще были,
[01:23:44.000 --> 01:23:47.000]  а потом от листьев коги пойдем, что если мы были в вершине, значит,
[01:23:48.000 --> 01:23:49.000]  и мы в ее родители тоже выйдем, например.
[01:23:50.000 --> 01:23:53.000]  Можно так, можно там про по дереве что-то говорить, в суть одна.
[01:23:55.000 --> 01:23:57.000]  Ну, просто не очень удобно реально строить дерево
[01:23:58.000 --> 01:23:59.000]  и потом тут dfs запускать под дерево.
[01:24:00.000 --> 01:24:02.000]  Но как бы для каждой вершины говорить, что в ней есть пометка,
[01:24:03.000 --> 01:24:04.000]  значит, в родителя тоже есть пометка.
[01:24:05.000 --> 01:24:08.000]  И честно так проходимся, и все помещенные крестики, соответственно,
[01:24:09.000 --> 01:24:10.000]  говорим, что ура, такое вхождение.
[01:24:11.000 --> 01:24:12.000]  Если нет, то...
[01:24:12.000 --> 01:24:13.000]  Ну вот.
[01:24:14.000 --> 01:24:16.000]  То есть и здесь уже никакого от ответа нет.
[01:24:17.000 --> 01:24:18.000]  Все честно за нее.
[01:24:19.000 --> 01:24:21.000]  Но напоследок, последняя,
[01:24:22.000 --> 01:24:24.000]  вот одна из самых красивых задач на это дело,
[01:24:25.000 --> 01:24:26.000]  на самом деле, знаете какая?
[01:24:27.000 --> 01:24:28.000]  Дано множество строк s.
[01:24:29.000 --> 01:24:31.000]  Мы их называем запрещенными.
[01:24:32.000 --> 01:24:34.000]  Вот мы хотим создать великую строчку,
[01:24:35.000 --> 01:24:36.000]  у которой ни одна из этих...
[01:24:37.000 --> 01:24:40.000]  Ну, точнее так, у нас только это ограниченная алфавит сразу скажем, да?
[01:24:40.000 --> 01:24:42.000]  И мы хотим создать великую строчку,
[01:24:43.000 --> 01:24:46.000]  у которой ни одна из этих строк не является подсказанной.
[01:24:47.000 --> 01:24:49.000]  Внимание, вопрос.
[01:24:50.000 --> 01:24:54.000]  Какой максимальной длины она может быть?
[01:24:59.000 --> 01:25:00.000]  Может быть бесконечной.
[01:25:01.000 --> 01:25:02.000]  Ну, мы просто проходимся по нашему бору,
[01:25:03.000 --> 01:25:04.000]  и это такая динамика получается.
[01:25:05.000 --> 01:25:07.000]  Если, например, из рута есть ассоцииус символ,
[01:25:07.000 --> 01:25:08.000]  то, ну, бесконечно.
[01:25:09.000 --> 01:25:12.000]  Если нет, то динамику от каждой вершины...
[01:25:13.000 --> 01:25:15.000]  Ну, можно динамику,
[01:25:16.000 --> 01:25:17.000]  а можно на самом деле так сделать.
[01:25:18.000 --> 01:25:19.000]  Рассмотрим.
[01:25:20.000 --> 01:25:22.000]  Ну, во-первых, заметим, что когда мы ходим по любой строке,
[01:25:23.000 --> 01:25:24.000]  мы ходим по бору, да?
[01:25:25.000 --> 01:25:27.000]  И, конечно, по вот этим вот, можно сказать, по автомату, да?
[01:25:28.000 --> 01:25:30.000]  Но заметим, что некоторые вершины в этом боре
[01:25:31.000 --> 01:25:32.000]  из серийской автоматы являются запрещенными.
[01:25:33.000 --> 01:25:34.000]  Потому что в крестике нам ходить нельзя,
[01:25:35.000 --> 01:25:36.000]  более того, нам нельзя даже ходить в вершины,
[01:25:37.000 --> 01:25:39.000]  потому что по суффиксным ссылкам можно попасть в крестик, правда?
[01:25:40.000 --> 01:25:44.000]  То есть, ну, мы заранее из этого автомата можем посчитать,
[01:25:45.000 --> 01:25:47.000]  найти все запрещенные вершины и их удалить, правда?
[01:25:48.000 --> 01:25:49.000]  Ну, можно просто записать ДФС.
[01:25:50.000 --> 01:25:51.000]  Как бы, когда мы доходим к запрещенной вершине,
[01:25:52.000 --> 01:25:53.000]  мы возвращаем ноль.
[01:25:54.000 --> 01:25:55.000]  И возвращаем максимум из вершинок.
[01:25:56.000 --> 01:25:57.000]  Ну, по-разному.
[01:25:58.000 --> 01:25:59.000]  Ну, можно так...
[01:26:00.000 --> 01:26:01.000]  Ну, я просто сказал, что после того, как мы удалим,
[01:26:02.000 --> 01:26:03.000]  можно сказать, что мы мысленно удалим все запрещенные,
[01:26:04.000 --> 01:26:05.000]  и тогда после этого из корня у нас, значит, есть какой-то доступный крафт, да?
[01:26:06.000 --> 01:26:07.000]  И получается вопрос только,
[01:26:08.000 --> 01:26:10.000]  какое количество шагов мы можем по нему сделать?
[01:26:11.000 --> 01:26:12.000]  И тут у вас два варианта.
[01:26:13.000 --> 01:26:17.000]  Либо вы уситритесь наткнуться на какой-то цикл,
[01:26:18.000 --> 01:26:20.000]  и тогда это будет означать, что вы тут можете по нему ходить бесконечно.
[01:26:21.000 --> 01:26:22.000]  Ответ плюс бесконечность, такое бывает.
[01:26:23.000 --> 01:26:25.000]  Либо доступная часть графа...
[01:26:26.000 --> 01:26:29.000]  Либо выяснится, что да, доступная часть графа у вас на самом деле
[01:26:30.000 --> 01:26:31.000]  является ациклическим графом.
[01:26:32.000 --> 01:26:34.000]  Да, кстати,
[01:26:35.000 --> 01:26:38.000]  ну так, кстати, вполне вероятно, что вот таким образом это будет, да?
[01:26:39.000 --> 01:26:40.000]  То есть не путать автомат с городом, да?
[01:26:41.000 --> 01:26:42.000]  То есть может быть.
[01:26:43.000 --> 01:26:45.000]  Ациклическим графом, и вам там остается только динамичкой
[01:26:46.000 --> 01:26:48.000]  действительно найти самый длинный путь, который вы тут можете.
[01:26:49.000 --> 01:26:51.000]  То есть, как, например, как правильно сказала Антон,
[01:26:52.000 --> 01:26:55.000]  просто запустить там, скажем, запустить DFS и честно вычислять эту функцию.
[01:26:56.000 --> 01:26:58.000]  При этом DFS, если я попал в вершину, которая у меня сейчас еще в стеке,
[01:26:59.000 --> 01:27:01.000]  то я рад с тобой возвращаюсь, плюс бесконечности радуюсь.
[01:27:02.000 --> 01:27:05.000]  То есть начинаю просто выбрасываться с криком, плюс бесконечности.
[01:27:06.000 --> 01:27:08.000]  Вот, как мы всегда делаем.
[01:27:09.000 --> 01:27:11.000]  Да, то есть это вот действительно такая очень красивая монахия.
[01:27:12.000 --> 01:27:15.000]  Вот, собственно, это все, что я хотел сказать про алгоритм Ахакараси.
[01:27:16.000 --> 01:27:19.000]  Ну, значит, в следующий раз будем просматривать что-нибудь более веселое,
[01:27:20.000 --> 01:27:21.000]  например, Патриархович.
[01:27:22.000 --> 01:27:24.000]  Ну ладно, предварительно, как бы, я думаю, тема следующей лекции такая.
[01:27:25.000 --> 01:27:28.000]  На первой пале мы рассмотрим алгоритм монахера и дерева календронов,
[01:27:28.000 --> 01:27:34.000]  а на второй, в третьих бухпарах мы рассмотрим, видимо, алгоритм монахера.
[01:27:35.000 --> 01:27:38.000]  Да, пожалуй, даже раньше суперстол массива.
