[00:00.000 --> 00:15.920]  Так можно начинать? Напомните номер лекции, пожалуйста, я не помню. Восемь, наверное. Спасибо.
[00:15.920 --> 00:28.920]  Так, я хочу сделать небольшое дополнение к лекции про кратчайшие пути. Важная идея,
[00:28.920 --> 00:41.600]  я сейчас ее быстренько освещу. Двусторонний BFS расскажу. Ну раз BFS, то, значит, граф невзвешенный.
[00:41.600 --> 00:57.840]  Вот. И задача найти кратчайший путь из S в T. Ну то есть и начало, и конец фиксировано. То есть
[00:57.840 --> 01:06.080]  это как во звездочке, да только невзвешенный граф. Вот. Смотрите какая идея. Простая очень. Давайте
[01:06.080 --> 01:11.360]  мы запустим параллельный такой BFS с обеих сторон. И из S, и из T. То есть вот мы знаем какой-то
[01:11.360 --> 01:18.840]  начало и конец S и T. Давайте мы потихонечку запустим вот эти вот две очереди наши. Одна
[01:18.840 --> 01:24.440]  будет находиться в расстоянии из S, другая из T. И вот когда они, то есть они как-то вот так
[01:24.440 --> 01:30.520]  будут по слоям обрабатывать наш граф. Да, вершины расстояния 1, 2, 3 и так далее. И вот когда они
[01:30.520 --> 01:36.280]  впервые пересекутся, тогда мы завершимся и скажем, что ну грубо говоря, вот это вот, то есть отсюда
[01:36.280 --> 01:41.720]  до сюда, плюс отсюда до сюда, это кратчайшее расстояние. Вот такая простая идея. Давайте я
[01:41.720 --> 01:57.200]  сейчас формализую. Ну, до какой-то степени. Значит запускаем BFS из S по прямым ребрам,
[01:57.200 --> 02:13.480]  и из T по обратным. Ну, потому что из S мы как бы идем вперед, используя обычную ориентацию ребер,
[02:13.480 --> 02:17.680]  а в T мы, наоборот, хотим прийти. То есть мы используем, то есть как бы у нас стрелочки такие.
[02:17.680 --> 02:22.360]  Значит, чтобы нам идти из T, мне нужно сначала инвертировать направление всех ребер, ну как
[02:22.360 --> 02:26.920]  обычно, обратные ребра построить, то есть не вот такое, а такое его сделать, и соответственно идти
[02:26.920 --> 02:41.080]  справа налево. Вот по итерациям. Идем по итерациям. Ну, итерация это вот как раз вот эти облачка. Сначала
[02:41.080 --> 02:45.920]  нашел совершенно расстояние 1 отсюда, потом нашел совершенно расстояние 1 отсюда, на расстоянии 2,
[02:45.920 --> 02:58.360]  на расстоянии 3, извините, 2 опять, да, 3, 3, 4, 4 и так далее. Значит, пусть после D этой итерации
[02:58.360 --> 03:09.400]  облачка пересеклись. То есть мы нашли какую-то вершину, которая находится на расстоянии не
[03:09.400 --> 03:20.960]  больше, чем D от S и не больше, чем D от T. Ну я напишу, слои пересеклись, пересеклись. Вот. Тогда ответ,
[03:20.960 --> 03:38.160]  это минимум по всем вершинам. DIST SV плюс DIST VT. Вот это мы для многих вершин знаем, это мы для
[03:38.160 --> 03:45.400]  многих вершин знаем. Ну и соответственно вот для тех вершин, где мы знаем и то и то, мы складываем
[03:45.400 --> 03:51.080]  вот эти две суммы и получаем, ну как бы ответ. То есть мы можем дойти вот S до куда-то, потом отсюда
[03:51.080 --> 03:58.520]  до T. Вот. Значит, почему это верно? Почему это верно? Ну смотрите, очевидно, что вот эта штука не
[03:58.520 --> 04:05.920]  больше, чем 2D. Эта штука не больше, чем 2D, потому что у меня D-T слои пересеклись. Значит, есть вершина,
[04:05.920 --> 04:10.960]  находящаяся на расстоянии не больше, чем D от S и на расстоянии не больше, чем D от T. Ну значит,
[04:10.960 --> 04:18.520]  просто сумма вот этих двух величин будет не больше, чем 2D. Значит, давайте тогда покажем,
[04:18.520 --> 04:23.680]  что если есть какой-то более короткий путь длины меньше, чем 2D, то мы его тоже увидим на самом
[04:23.680 --> 04:41.280]  деле. Пусть есть какой-то путь длины меньше, чем 2D. Вот есть S, вот есть T, вот какой-то такой путь.
[04:41.280 --> 04:54.200]  Давайте рассмотрим на нем D-ту вершину. То есть давайте отступим от S, D-рёбер, а в конце останется,
[04:54.200 --> 05:02.040]  что получается, меньше, чем D-рёбер, рассуммарная длина меньше, чем 2D. Ну и все, смотрите, раз эта
[05:02.040 --> 05:07.320]  вершина находится на расстоянии D от S-ки, значит она лежит, ну то есть она лежит где-то вот здесь. То
[05:07.320 --> 05:11.800]  есть мы до нее посчитали правильное расстояние из S. И раз здесь меньше, чем D, то мы, наоборот,
[05:11.800 --> 05:16.640]  от T до нее тоже нашли правильное расстояние, ну потому что BFS правильно все находит. Значит,
[05:16.640 --> 05:24.200]  в ответе мы учтем вот этот путь, потому что мы от S до XA умеем добираться и от XA до T. Значит,
[05:24.200 --> 05:31.120]  все такие пути мы разберем, ну и поэтому этот минимум будет равен тому, чему нужно. Вот,
[05:31.120 --> 05:41.080]  профит. Понятно? Хорошо. Ну и соответственно, на самом деле, эту же штуку можно обобщить на алгоритм
[05:41.080 --> 05:49.360]  D-экстры и на звездочку тоже. Значит, ну в D-экстре более-менее что-то похожее происходит. Если у
[05:49.360 --> 05:54.600]  вас есть выделенные начальные и конечные вершины, давайте мы запустим опять параллельно D-экстру здесь,
[05:54.600 --> 06:00.000]  ну как бы из S и в T, то есть на графе по обратным ребрам, там у нас будут две кучи храниться,
[06:00.000 --> 06:05.960]  ну и давайте извлекать короче элементы, извлекать вершины из куч параллельно в каком-то смысле. И
[06:05.960 --> 06:10.200]  когда какая-то вершина удалится из обеих куч, мы считаем, что мы нашли кратчайший путь. То есть там,
[06:10.200 --> 06:15.320]  ну как-то примерно так же граф обходится, у меня расширяется множество вершин, до которых известны
[06:15.320 --> 06:21.400]  ответы. Когда они пересеклись, мы считаем, что вот как раз, в общем, когда что-то пересеклось,
[06:21.400 --> 06:26.160]  мы перебираем все такие пути, выбираем из них минимальный. То же самое в азвездочке. Ну,
[06:26.160 --> 06:30.440]  азвездочка это какая-то надстройка на D-экстре, то же самое, можно пустить азвездочку из S в T и из
[06:30.440 --> 06:35.640]  T в S, они там в каком-то порядке все обрабатывают, и когда они состыкуются, когда они пересекутся в
[06:35.640 --> 06:42.880]  какое-то вершине, можно сказать, что ответ найден. Вот. Значит, это все полезно в случае, когда у вас граф
[06:42.880 --> 06:54.160]  очень связный, да, вот я хочу сказать слово expander, наверное это будет громко здесь сказано, давайте на
[06:54.160 --> 06:59.080]  примере каком-нибудь, когда вы решаете какую-нибудь головоломку типа там кубик рубика, ну, может быть,
[06:59.080 --> 07:04.960]  не 3 на 3 на 3, но хотя бы 2 на 2 на 2, и у вас, если вершины вы кодируете в состояние, то есть
[07:04.960 --> 07:09.040]  конфигурацию вашей головоломки, то понятно, что у вас из каждого состояния довольно много переходов,
[07:09.040 --> 07:14.000]  ну там в кубике можно двенадцатью способами повернуть какую-то грань, то есть выбираете какую
[07:14.000 --> 07:19.440]  грань и в двух сторон вращаете, почасовой или противчасовой. Поэтому у вас каждая вершина как бы
[07:19.440 --> 07:24.120]  имеет двенадцать исходящих ребер, и так для каждой работы, да, у вас граф регулярный, у каждой вершины
[07:24.120 --> 07:28.920]  одинаковой степени, поэтому понятно, что если вы пускаете какой-то обычный BFS, как он работает, вот
[07:28.920 --> 07:32.760]  сначала у вас есть, ну то есть у вас есть там стартовая конфигурация, есть конечная, например,
[07:32.760 --> 07:39.600]  собранный кубик, то есть желаемая вами конфигурация головоломки, вот. Вы берете и каждый раз от каждой
[07:39.600 --> 07:42.520]  вершины добавляете в очередь по двенадцать вершин, то есть на первом условии у вас будет
[07:42.520 --> 07:47.800]  двенадцать вершин, давайте я А это назову, на втором будет А квадрат, потому что каждый из них даст еще
[07:47.800 --> 07:52.480]  по двенадцать, ну там по одиннадцать, ну неважно, вот, и так далее. У вас, короче, так экспоненциально
[07:52.480 --> 08:00.320]  растет размер того, что вы перебираете, вот. И если вы так делаете, то чтобы найти вершину T,
[08:00.320 --> 08:05.760]  которая находится там на каком-то X там слое, у вас вот здесь вот переберется а в степени X вершин,
[08:05.760 --> 08:14.080]  вот. А если бы вышли с двух сторон параллельно, да, вот здесь нашли облачка размера А, здесь А,
[08:14.080 --> 08:21.680]  а тут А квадрат, тут А квадрат, вот, то пересеклись вы бы примерно на X пополам-то слоя, и здесь,
[08:21.680 --> 08:28.200]  соответственно, было бы только А в степени X пополам вершин, что, ну, все-таки сильно лучше, да. Все-таки
[08:28.200 --> 08:34.080]  А в степени X сильно больше, а в степени X пополам, вот. Поэтому, как бы довольно годная идея, именно
[08:34.080 --> 08:37.920]  когда у вас вот так экспоненциально взрывается граф, то есть когда у каждой вершины большая степень,
[08:37.920 --> 08:42.080]  и она поражает много новых вершин, тогда вот лучше с двух сторон идти, вы просто меньше вершин
[08:42.080 --> 08:56.480]  обойдете. Такая идея. Ау, ой, там прекрасная задача в контесте есть, удачи вам. Так, хорошо, значит,
[08:56.480 --> 09:10.680]  теперь непосредственно к сегодняшней теме про минимальные остовы. Давайте пару определений,
[09:10.680 --> 09:17.400]  сегодня давайте только неориентированные графы. Давайте напишу, что сегодня неориентированные
[09:17.400 --> 09:24.680]  графы. Мне будет лень писать слово неориентированный постоянно, у меня сегодня всегда все неориентировано.
[09:24.680 --> 09:41.880]  Значит, если G это граф, и H это тоже граф, то H называется под графом G, если V штрих
[09:41.880 --> 09:59.440]  это подносит V, а E штрих подносит E. То есть вы оставили какие-то вершинки, какие-то ребра,
[09:59.440 --> 10:16.400]  произвольное подношество. Значит, дальше, если при этом, если при этом V штрих равно V, то H
[10:16.400 --> 10:29.120]  называется остовным под графом, то H остовный под граф G. То есть если вы вершины не удаляете,
[10:29.120 --> 10:35.760]  то это остовный под граф называется. Вот, и если еще при этом H это дерево, то есть связанный граф
[10:35.760 --> 10:57.040]  без циклов, тогда это остовное дерево. Дерево, то есть связанный граф без циклов, то H это остовное дерево.
[11:05.760 --> 11:27.320]  Ну, например, давайте какой-нибудь нарисую. Вот есть такой большой граф, что-нибудь вот такое. Я
[11:27.320 --> 11:36.400]  могу здесь выбрать следующий остов, точнее, остовное дерево. Вот, ну, это ребро я обязан взять,
[11:36.400 --> 11:41.880]  потому что без него, потому что это мост на самом деле, мосты нельзя не брать. Вот, ну, а здесь
[11:41.880 --> 11:47.400]  могу взять, например, что-нибудь вот такое. Вот, выделенные ребра образуют как раз остовное дерево.
[11:47.400 --> 11:57.080]  Потому что я взял все вершины, взял какие-то ребра, и если рассматривать только красные
[11:57.080 --> 12:02.200]  ребра, то граф очевидно связан и не имеет циклов. Получается дерево. Вот, ну, наша цель будет на
[12:02.200 --> 12:07.240]  сегодня такая. Вот, если у вас еще граф не просто такой, а еще и взвешенный, то есть на каждом
[12:07.240 --> 12:12.240]  ребре написан какой-то вес, тогда мне нужно найти минимальный остов по весу. То есть вот среди всех
[12:12.240 --> 12:16.200]  деревьев выбрать то, у которого минимальный суммарный вес, минимальный вес ребер, который в него
[12:16.200 --> 12:32.040]  входит. Значит, остов минимального веса, ну, это просто остовное дерево с минимальной суммой весов ребер.
[12:32.040 --> 12:51.520]  Ну, это очень естественная задача, потому что если у вас есть какой-нибудь граф, ну, не знаю, опять,
[12:51.520 --> 12:57.000]  какая-нибудь компьютерная сеть, и для того, чтобы провести канал взаимодействия между двумя
[12:57.000 --> 13:01.080]  компьютерами, вам нужно потратить столько-то денег. То есть у вас каждое ребро имеет какую-то
[13:01.080 --> 13:06.400]  стоимость. Вот, и вам нужно выбрать какие-то каналы так, чтобы сеть была связанная, то есть компьютеры
[13:06.400 --> 13:12.200]  могли обмениваться, ну, там можно по цепочке любой информации, ну, и при этом потратить как можно
[13:12.200 --> 13:17.080]  меньше денег. Пожалуйста, задача минимального остова. То есть нужно выбрать связанный под граф,
[13:17.080 --> 13:36.040]  потратив при этом минимальную сумму. Вот. Значит, леммо, которое будет, кажется, единственное содержательное
[13:36.040 --> 13:50.840]  сегодня, окей, единственное важное, называется леммо о безопасном ребре. Ну, давайте в общем случае
[13:50.840 --> 14:10.520]  я напишу. Пусть g это взвешенный неориентированный граф, а s это остовный под граф, являющийся под
[14:10.520 --> 14:19.640]  множеством, то есть под графом, какого-то минимального остова. Это остованный под граф, то есть он
[14:19.640 --> 14:31.520]  содержит все вершины, но, возможно, не все ребра, являющийся под графом какого-то минимального остова.
[14:31.520 --> 14:48.080]  Вот. Ну, то есть у нас алгоритм будет интеративный, он будет постепенно расширять наш миностов, то есть
[14:48.080 --> 14:52.640]  изначально мы возьмем, скажем, пустое множество, то есть все вершины и ноль ребер, без ребер вообще.
[14:52.640 --> 14:58.640]  Понятно, что это под граф миностов, потому что любой миностов содержит пустое множество. Вот. И дальше мы
[14:58.640 --> 15:03.200]  будем потихонечку расширять, добавлять туда ребра. Вот сейчас опишем, как их будем добавлять.
[15:03.200 --> 15:14.920]  Значит, пусть s это что-то, что можно расширить до миностова. Пусть e это самое дешевое ребро графа g.
[15:14.920 --> 15:23.560]  Соединяющие разные компоненты связанности графа s.
[15:23.560 --> 15:44.960]  Значит, картинка будет чуть позже. Тогда s плюс e тоже под граф минимального остова.
[15:44.960 --> 16:00.840]  Тоже под граф минимального остова. Вот. Ну, то есть картинка, давайте нарисуем. Что такое s?
[16:00.840 --> 16:07.080]  s содержит все вершины и, возможно, он еще не связан. То есть, на самом деле, s это какое-то
[16:07.080 --> 16:12.280]  разбиение всех вершин нашего графа на какие-то компоненты связанности. Внутри каждой компонент
[16:12.280 --> 16:22.360]  у меня на самом деле будет дерево. Ну, это неважно. То есть, как-то внутри компонент уже... Да. Да,
[16:22.360 --> 16:32.480]  это не имеет значения, вроде бы. Думаете, имеет? Ну, давайте поживем, увидим. На самом деле это
[16:32.480 --> 16:38.720]  точно неважно, потому что мы знаем, что в любом остове ровно n-1 ребро. Ну, потому что чтобы
[16:38.720 --> 16:44.000]  обеспечить связанность, нужно провести n-1 ребро. А значит, если мы прибавим одну большую константу
[16:44.000 --> 16:49.320]  ко всем весам, то у нас в предсказуемом изменится стоимость. Значит, алгоритм ему на самом деле
[16:49.320 --> 16:52.520]  неважно. Даже если все отрицательно, я могу прибавить большую константу, и точно все будет
[16:52.520 --> 16:58.960]  нормально. Вроде доказательством этим неважно на отрицательность. Так вот, какой-то такой граф
[16:58.960 --> 17:03.920]  у нас есть, и мне нужно его добить до связанного, проводя какие-то ребра, соответственно, между
[17:03.920 --> 17:08.480]  компонентами. Я знаю, что его можно как-то дополнить. То есть, эта множество ребер не противоречит
[17:08.480 --> 17:14.960]  выбору минимального остову. И вот я беру какое-то E из графа, например, вот это вот E, утверждаю,
[17:14.960 --> 17:18.720]  что его можно добавить, то есть объединить эти две компоненты, и сказать, что это по-прежнему
[17:18.720 --> 17:24.800]  под множество миностово. Ну, во-первых, если E само по себе, то есть, если вот это S плюс E это
[17:24.800 --> 17:31.480]  под множество миностово, то и так уже все очевидно. Давайте напишем. Пусть S вложено в T,
[17:32.320 --> 17:54.160]  если S плюс E тоже вложено в T, то доказывать нечего. Иначе E в T не лежит, иначе E не лежит в T.
[17:54.160 --> 18:02.160]  Хорошо, давайте посмотрим на конце этого ребра. Пусть E соединяет какие-то вершины U и V,
[18:02.160 --> 18:09.720]  но T же ведь это связанный граф, T это минимальный остов, поэтому он в частности связанный. Значит,
[18:09.720 --> 18:14.720]  есть какой-то путь в графе T между этими вершинками, между U и V, при этом ребро E
[18:14.720 --> 18:20.240]  использовать нельзя. Ну, как-то этот путь выглядит. Понятно, что в какой-то момент он,
[18:20.240 --> 18:25.040]  ну вот если я рассмотрю этот путь, соединяющий U и V в графе T, то понятно, что он в какой-то
[18:25.040 --> 18:29.280]  момент выходит из этой компоненты связанности и попадает сюда. Возможно, по пути заходит сюда,
[18:29.280 --> 18:34.320]  возможно там. Ну, короче, он может быть какой-то сложный, вот какой-то такой стремный вообще,
[18:34.320 --> 18:41.720]  но понятно дело, что он хотя бы один раз перейдет из одной компоненты в другую. То есть,
[18:41.720 --> 18:46.520]  он может быть вот такой еще, например, вот так может быть. То есть, на этом пути гарантировано
[18:46.520 --> 18:52.400]  будет хотя бы одно ребро, соединяющие вершины разных компонент связанности. Давайте это напишем.
[18:52.400 --> 19:09.200]  Тогда в пути между U и V в графе T есть хотя бы одно ребро,
[19:09.200 --> 19:22.440]  соединяющий вершины разных компонент графа S. Ну, то есть, вот такой переход из одной компоненты
[19:22.440 --> 19:47.560]  в другую. Так, есть ребро, соединяющие вершины разных компонент графа S.
[19:52.440 --> 20:03.760]  Значит, его вес хотя бы такой же, как у E. Давайте я назову E'. Тогда стоимость E' точно больше
[20:03.760 --> 20:09.720]  равна стоимости E. Ну, потому что E это минимальная из ребер, соединяющие разные компоненты,
[20:09.720 --> 20:19.360]  а E' какое-то. Вот E' это минимальная, а E' вот оно, это какое-то. Вот это или вот это, ну какое-то
[20:19.360 --> 20:24.920]  ребро другое. Его стоимость больше равна, чем стоимость E. Ну, тогда смотрите, в графе T у меня
[20:24.920 --> 20:31.280]  что происходит? У меня есть некоторый путь между U и V, вот такой вот длинный путь, содержащий где-то
[20:31.280 --> 20:42.080]  по дороге ребро E'. При этом во всем графе G есть еще вот такое ребро между ними E. Ну, значит,
[20:42.080 --> 20:48.480]  я могу просто смело удалить E' и добавить E в наш граф T. Связанность у меня не изменится,
[20:48.880 --> 20:53.760]  связанность не сломается, потому что на этом цикле у меня связанность сохранилась, а значит все
[20:53.760 --> 21:00.040]  остальное тоже достижимо. А стоимость могла только уменьшиться, но не строго уменьшиться. Значит,
[21:00.040 --> 21:23.480]  тогда T-E' плюс E, а стовное дерево не большего веса. Да, ну и значит S
[21:23.480 --> 21:29.200]  плюс E это по однорству вот такого минимального стова. Вот это вот минус стов.
[21:41.200 --> 21:53.240]  Нормально? Хорошо. Все, ну член мы доказали. Отсюда автоматически следует алгоритм Прима.
[21:53.240 --> 22:03.080]  Который я уже на самом деле заспойлерил. Алгоритм Прима. Сначала в качестве S берем пустой под
[22:03.080 --> 22:11.640]  граф, то есть граф, содержащий все вершины, но не содержащий ребра. Дальше, так нет, так не хочу,
[22:11.640 --> 22:18.920]  хочу по-другому сказать на самом деле. Давайте вот такую картинку нарисую. Значит, изначально
[22:18.920 --> 22:24.880]  у меня есть какая-то первая вершина и весь остальной граф. Я нахожу самое дешевое ребро,
[22:24.880 --> 22:31.240]  ведущее из единички в весь остальной граф. Пусть это будет реброк какой-то. В вершинку номер два,
[22:31.240 --> 22:36.600]  например. Тогда я это ребро добавляю в минус стов и могу это сделать, потому что изначально у меня
[22:36.600 --> 22:40.760]  один и все остальное, это разные компоненты связанности, но теперь на самом деле у меня все вершины
[22:40.760 --> 22:51.640]  в попарно-разных компонентах и нет ребер. Это ребро можно добавить по лемме. Я его добавляю и
[22:51.640 --> 22:58.560]  теперь говорю, что у меня один-два это компоненты связанности и вот есть все остальное. Опять нахожу
[22:58.560 --> 23:04.200]  самое дешевое ребро отсюда-сюда, какое-нибудь вот такое, но опять там какое-то ребро. Его добавляю,
[23:04.200 --> 23:10.640]  говорю, что вот это теперь моё подножие минус 100. Потом нахожу новое ребро из этого подножия
[23:10.640 --> 23:25.720]  в остаток графа и так делаю, пока весь остов не построю. Давайте я напишу так. Давайте с первой
[23:25.720 --> 23:35.480]  будет только одна вершина. Дальше n-1 раз, потому что чтобы построить остов, мне нужно добавить
[23:35.960 --> 23:55.640]  ребро. Находим самое дешевое ребро между s,e и остатком графа. Между s,e и, ну, видимо,
[23:55.640 --> 24:07.640]  g без s,e. Пусть это будет ребро e. Ну и говорим, что если плюс первое, это s,e и t плюс e. Мы просто
[24:07.640 --> 24:12.320]  итеративно применяем лему безопасным ребром. Добавляем каждый раз самое дешевое ребро в
[24:12.320 --> 24:24.400]  подножие, ну не в подножие, а, сейчас скажу, в текущую, ну да, в подножие минус 100. И так
[24:24.400 --> 24:30.040]  итеративно добавляем. В конце у нас получается минус 100, потому что раз каждый раз было подножие
[24:30.040 --> 24:34.040]  минус 100, то в конце тоже будет подножие минус 100, которое уже является остовом на самом деле.
[24:34.040 --> 24:55.160]  Вот, значит, вопрос, за сколько это работает. За сколько? Да, ну, можно и м-логерство. На самом
[24:55.160 --> 24:59.760]  деле тут симдотики такие же, как в DX3. Значит, во-первых, можно за n квадрат, что тоже иногда
[24:59.760 --> 25:03.600]  бывает полезно, если у вас в графе слишком много ребер, и m-лог n больше, чем n квадрат.
[25:03.600 --> 25:12.360]  То есть тогда можно за квадрат следующим образом. Давайте поддерживать массив d от v. Это так,
[25:12.360 --> 25:26.040]  вес минимального ребра ведущего из s,e, ну как бы, из текущего s в v. То есть вот у меня есть, как бы,
[25:26.040 --> 25:32.040]  s, текущая подножие минус 100, есть все остальные вершинки. Давайте я для каждой вершины буду
[25:32.040 --> 25:36.360]  хранить самое минимальное, которое в нее входит. Вот из всех этих ребер выбираю самый маленький,
[25:36.360 --> 25:42.280]  храню его вес d от v. Значит, тогда, чтобы найти самое дешевое ребро, мне достаточно пройтись
[25:42.280 --> 25:49.000]  по всем еще не включенным вершинам и взять из них минимальное d от v. Вот этот шаг. Это просто выбор
[25:49.000 --> 25:58.720]  минимального d от v. Давайте еще раз картиночку. Вот есть s, вот есть g без s, есть все остальное,
[25:58.720 --> 26:05.720]  как бы. Для каждой вершины здесь я знаю самое дешевое ребро, ведущее в нее из s. А мне нужно из
[26:05.720 --> 26:09.520]  всех таких самое дешевое. То есть из всех ребер между двумя вот этими долями мне нужно
[26:09.520 --> 26:13.920]  самое дешевое ребро взять. Ну тогда я просто по ним по всем прохожусь, выбираю минимальное
[26:13.920 --> 26:18.000]  значение d от v, то есть минимум по всем минимумам. Ну вот пусть он какое-то такое ребро, вершинку,
[26:18.000 --> 26:25.120]  скажем, x. Я ее хочу добавить в s, вот так вот расширить мое s. Ну и соответственно,
[26:25.120 --> 26:29.040]  тогда мне нужно будет пересчитать все дешки, потому что у меня теперь появились новые ребра, вот такие
[26:29.040 --> 26:34.720]  вот, ведущие из x. Мне нужно теперь дешки для всех концов этих ребер тоже обновить.
[26:34.720 --> 26:49.760]  Значит, по всем, ну не буду, короче, писать. Напишу так, по всем ребрам, исходящим из x,
[26:49.760 --> 27:08.080]  обновляем d от v. Итого, 8 точек у меня будет n квадрат, потому что мне нужно n раз выбрать
[27:08.080 --> 27:14.800]  минимум в массиве длины n. Каждый раз выбор делается за линию, всего minus 1 раз, поэтому будет квадрат.
[27:14.800 --> 27:19.360]  Вот. А эта штука суммарно работает за m, вот это вот все суммарно работает за m,
[27:19.360 --> 27:24.480]  потому что каждое ребро посмотрится два раза. Каждая вершина добавится один раз,
[27:24.480 --> 27:28.980]  значит, каждое исходящее ребро по одному разу, ну и потому что у ребра есть два конца, то каждое
[27:28.980 --> 27:33.400]  ребро дважды просмотрится. Поэтому эта штука дает от m. Ну, как обычно, я считаю, что m меньше
[27:33.400 --> 27:44.640]  чем n квадрат, поэтому основной слоган будет вот такой. Вот. Ну и можно сделать то же самое за m лог n.
[27:44.640 --> 27:56.320]  Просто надо хранить бинарную кучу. Бинарная куча на вот этих вот дешках, на массиве d. Ну,
[27:56.320 --> 28:02.680]  потому что так же, как в dx-ре на самом деле, мне нужно уметь делать экстракт мин и уметь делать
[28:02.680 --> 28:06.960]  декрески, потому что здесь происходит только декрески. А я, когда обновляю, только уменьшаю,
[28:06.960 --> 28:12.120]  потому что у меня добавляются какие-то ребра, я к имеющемуся минимуму могу что-то, ну короче,
[28:12.120 --> 28:16.480]  могу его обновить чем-то еще более маленьким. Поэтому у меня бывает только экстракт мин и декрески.
[28:16.480 --> 28:32.160]  Вот. Ну и поэтому будет такая симпатика. И если мы опять-таки внезапно откуда-то знаем про кучу
[28:32.160 --> 28:37.760]  фибоначи, то будет опять такая симпатика m плюс n лог n, потому что декрески фибоначи
[28:37.760 --> 28:43.400]  работают за быстро, за учетную единицу, за амортизированную единицу. Поэтому будет m без
[28:43.400 --> 28:49.080]  множителя лог n, ну а экстракт мин за логарифом работает амортизировано. Поэтому второй слоган
[28:49.080 --> 29:07.560]  и логан. Вот эта симпкуча. Так, вопросики есть? Хорошо.
[29:19.080 --> 29:29.400]  Так, следующий алгоритм. Алгоритм Крускала.
[29:39.400 --> 29:45.240]  Значит тоже, тоже, тоже очень естественный. Смотрите, давайте мы посортируем все ребра в
[29:45.240 --> 29:52.880]  порядке возрастания веса. Ну как бы понятно, да? Вот наша лемма как бы говорит, что у нас довольно
[29:52.880 --> 29:57.400]  хорошо работают жадно алгоритмы. То есть если я на каждом шаге в каком-то смысле выбираю минимальное
[29:57.400 --> 30:02.440]  ребро, ну подходящее, да, чтобы циклов не образовывалось и так далее, то, наверное, его можно
[30:02.440 --> 30:12.240]  добавлять. Ну давайте на первом шаге мы посортируем все ребра. Сортировка ребер всех, всех ребер по
[30:12.240 --> 30:25.120]  возрастанию веса. Вот, а дальше мы просто в этом порядке по ним проходим и добавляем все, что можно.
[30:25.120 --> 30:33.360]  Главное, чтобы не было циклов. Нам, мы понимаем, что циклы нам не нужны. Циклы в, ну как бы они, они
[30:33.360 --> 30:39.600]  связанности нам, связанности не помогают. Нам нужны только циклический граф, да? Дерево это граф
[30:39.600 --> 30:46.160]  без циклов. Вот, поэтому мы просто в этом порядке идем и все, что цикла в подграфе не образует, добавляем
[30:46.160 --> 31:04.640]  в подграф. Собственно и все. Вот, и в этом порядке просматриваем ребра. Добавляем те из них,
[31:04.640 --> 31:29.360]  которые не образуют цикла. Ну то есть, например, если у меня какой-нибудь такой граф, вот этот,
[31:29.360 --> 31:34.000]  например, самое дешевое ребро, я его сразу беру. Вот это второе по дешевизне ребро, я его тоже беру.
[31:34.000 --> 31:39.880]  Если, например, третий было бы вот это, то я его игнорирую. Его брать контрпродуктивно, да, у меня
[31:39.880 --> 31:45.880]  и так уже есть путь между ними, нет смысла брать еще вот это ребро. Поэтому я его игнорирую, третье
[31:45.880 --> 31:49.520]  пропускаю. Ну и, например, если четвертое вот такое, то я беру вот это четвертое ребро. И вот вам,
[31:49.520 --> 31:57.360]  пожалуйста, прекрасный миностов получился. Вот, значит, корректность опять-таки тривиально следует
[31:57.360 --> 32:01.760]  из леммы, ну потому что на каждом шаге я выбираю вообще потенциально самое дешевое существующее
[32:01.760 --> 32:07.040]  ребро. Из всех доступных я выбираю самое дешевое. Если его можно взять, добавляю по лемме безопасным
[32:07.040 --> 32:11.280]  ребре, это всегда можно сделать. Если раньше было подносит миностово, то сохранится подносит миностово.
[32:11.280 --> 32:18.320]  Вот, значит, поэтому единственный вопрос это, как делать вот это вот? То есть, как проверять,
[32:18.320 --> 32:24.440]  появляется ли цикл после добавления ребра или нет? Значит, как это проверять? Мы это будем
[32:24.440 --> 32:30.600]  делать с помощью новой структуры данных, которая называется СНМ. Значит, это система не пересекающих
[32:54.440 --> 33:24.000]  ребров. Что это такое? Смотрите, СНМ как следует из названия? Поддерживает разбиение какого-то
[33:24.000 --> 33:29.360]  множества элементов, какой-то совокупности элементов на непересекающееся множество. Одно множество,
[33:29.360 --> 33:39.760]  второе, третье, четвертое, пятое. Ну, вот как-то, что-то такое. И умеет отвечать на два типа запросов.
[33:39.760 --> 33:46.040]  Значит, во-первых, собственно, что нам нужно? На самом деле разбиение на множество, это будет разбиение
[33:46.040 --> 33:50.680]  на компонент связанности. Каждое множество, это своя компонент связанности в этом вот графе по
[33:50.680 --> 33:55.320]  мере построения к рускала. По мере выполнения к рускала. Первый запрос, который нам надо умеет
[33:55.320 --> 34:06.640]  отвечать. Давайте объединить две компоненты. Unite. Слить два множества в одно. Два множества в одно.
[34:06.640 --> 34:13.160]  Это нужно делать, когда проводится ребро между компонентами. То есть, если у меня были две
[34:13.160 --> 34:19.640]  разные компоненты, я добавляю ребро в текущую версию миностово. Значит, у меня вот эти две
[34:19.640 --> 34:23.840]  компоненты сливаются в одно большое. Мне нужно слить эти два множества в одно. То есть, теперь у меня не два
[34:23.840 --> 34:31.040]  множества раздельных, а одно большое вот такое. И второе, соответственно, это надо уметь проверять,
[34:31.040 --> 34:37.280]  добавляет ли цикл добавления ребра. То есть, по факту, мне нужно научиться, лежат ли две вершины
[34:37.280 --> 34:44.040]  в разных в разных долях, в разных множествах. Ну, пока не буду называть. Мне нужно учиться проверять,
[34:44.040 --> 34:58.680]  лежат ли два элемента в одном множестве. Если они лежат в одном множестве, значит,
[34:58.680 --> 35:05.320]  добавление ребра в эту компонентную связанность образует цикл. Ну, потому что, если у меня есть
[35:05.320 --> 35:09.880]  какой-то здесь связанный подграф, я добавляю туда ещё ребра, и понятно, что образуется цикл. Нет
[35:09.880 --> 35:15.080]  смысла добавлять ребра в уже и так связанный подграф. А вот если бы эти вершины были в разных долях,
[35:15.080 --> 35:20.080]  в разных компонентах, то добавление ребра как раз таки нам полезно. Нам не нужно с Лидвигом.
[35:20.080 --> 35:26.840]  Ну и теперь вот такую задачу мы научимся быстренько решать, и её вот сюда вставим,
[35:26.840 --> 35:35.200]  как под задачу, и так у нас кросскава будет хорошо работать. Так, как я буду хранить вот это всё
[35:35.200 --> 35:48.360]  безобразие. Значит, я скажу следующее. Для множества в СНМ мы будем хранить как корневое дерево.
[35:48.360 --> 36:08.520]  Будем хранить корневое дерево. То есть вот если множество, ну, точнее, если набор элементов
[36:08.520 --> 36:09.200]  лежит в одном множестве...
[36:38.520 --> 36:40.520]  Ну и вот так вот, как мы будем хранить корневое дерево. Ну и вот так вот, как мы будем хранить корневое дерево.
[36:40.520 --> 36:44.520]  Ну и вот так вот, как мы будем хранить корневое дерево. Ну и вот так вот, как мы будем хранить корневое дерево.
[37:08.520 --> 37:26.520]  У каждого элемента В храним В от В. Это родитель В в соответствующей деле.
[37:26.520 --> 37:38.520]  Ну или минус один, если родителя нет, то есть вершина сама уже является корнем.
[37:38.520 --> 37:50.520]  Или минус один, если В хранит.
[37:50.520 --> 37:55.520]  Причём вот тут важное замечание, которое надо сделать, чтобы не запутаться.
[37:55.520 --> 38:03.520]  Вот эта структура в множествах, которую я только что вёл, эта древесная структура, никак не связана с исходным графом.
[38:03.520 --> 38:09.520]  То есть вот смотрите, раньше у меня там было что? У меня был какой-то граф, я добавляю ребра, соединяю компонент связанности и так далее.
[38:09.520 --> 38:14.520]  То есть на самом деле там каждое множество тоже было деревом. Но вот то дерево и вот эти, это разные деревья.
[38:14.520 --> 38:21.520]  И вообще давайте про ту задачу поповременно забудем. Забудем, что там что-то, какой-то граф был, какие-то деревья были, не было ничего.
[38:21.520 --> 38:27.520]  Вот просто вот эта задача. Я здесь сам самостоятельно свяжу новую структуру на множество. В каждом множестве своя структура дерева.
[38:27.520 --> 38:34.520]  Никак не связана я с тем, что было там. Эта структура берется только из того, как я обрабатываю запрос.
[38:34.520 --> 38:39.520]  То есть давайте мы забудем про кроп скала, только на этом мы сомплюсируемся. И структура вот здесь.
[38:39.520 --> 38:45.520]  Мы сами вали выбирать как хотим. Не то как задача исходная была дано, там какие-то ребра проводились, так и расставляем деревья.
[38:45.520 --> 38:53.520]  Нет. Как хотим, так и делаем. Вот сейчас мы полностью властны на тем, как строить эти деревья.
[38:53.520 --> 39:00.520]  Давайте на вот этот вопрос быстро ответим. Как понять, что два элемента в одном множестве?
[39:00.520 --> 39:05.520]  Давайте дойдем до корня обоих деревьев. Вот есть U, вот есть V.
[39:05.520 --> 39:10.520]  Давайте дойдем по стрелочкам до вершины с P, вот V равно минус 1. То есть вот до сюда и до сюда.
[39:10.520 --> 39:15.520]  Если пришли в один тот же корень, то значит они в одном дереве. Если в разном, то в разном.
[39:15.520 --> 39:21.520]  То есть если бы V был вот здесь, то они бы пришли в разные вершины, и значит они лежат в разных множествах.
[39:21.520 --> 39:27.520]  Поэтому вот эту штуку мы уже умеем обрабатывать просто пройдя по дереву до корня.
[39:27.520 --> 39:30.520]  Этого неплохо.
[39:30.520 --> 39:36.520]  Так, ну что, давайте продолжать.
[39:36.520 --> 39:42.520]  У нас про SNM осталось чуть-чуть на самом деле довести.
[39:42.520 --> 39:47.520]  Давайте я напишу простой код, который здесь делает то, что я начал говорить,
[39:47.520 --> 39:54.520]  что по вершине мне нужно до корня дойти, и соответственно критерии того, что вершины в одном дереве или в разных,
[39:54.520 --> 39:57.520]  это то, совпадают ли у них корни или не совпадают.
[39:57.520 --> 40:02.520]  Давайте я напишу следующую очень простую процедуру int get,
[40:02.520 --> 40:07.520]  которая берет вершину, если она корень, разрешает ее же саму.
[40:12.520 --> 40:17.520]  То есть если у нее нет родителя, то значит она сама по себе уже корень.
[40:17.520 --> 40:20.520]  А иначе нужно вернуть get от родителя.
[40:20.520 --> 40:29.520]  Такая функция делает то, что я сказал.
[40:29.520 --> 40:31.520]  По дереву поднимается просто вверх.
[40:31.520 --> 40:33.520]  Никаких хитростей не делает.
[40:33.520 --> 40:36.520]  Просто поднимается, поднимается, пока до корня не дойдет.
[40:36.520 --> 40:38.520]  Охранистим как ноты?
[40:38.520 --> 40:42.520]  До интов хватит, но у нас же изначально числа от 0 до 0,1.
[40:42.520 --> 40:45.520]  Мне так и хватит.
[40:45.520 --> 40:46.520]  Массив чисел?
[40:46.520 --> 40:49.520]  Да, тут никаких структур даже не надо.
[40:49.520 --> 40:52.520]  Хорошо, значит с get разобрались.
[40:52.520 --> 40:55.520]  Соответственно на второй запрос более-менее научились отвечать.
[40:55.520 --> 40:59.520]  Теперь что делать со слиянием, с юнайтом?
[40:59.520 --> 41:03.520]  Вот есть два дерева каких-то.
[41:03.520 --> 41:05.520]  Я хочу их следить в одном множестве.
[41:05.520 --> 41:07.520]  То есть как это происходило?
[41:07.520 --> 41:10.520]  Мне сказали, что вот есть у, вот есть в.
[41:10.520 --> 41:16.520]  Я каким-то образом хочу множество, содержащее у и множество, содержащее в, следить в одно.
[41:16.520 --> 41:19.520]  Для этого, понятно, разумно наверное подняться до корня.
[41:19.520 --> 41:23.520]  Получить корень одного дерева и второго.
[41:23.520 --> 41:26.520]  А дальше давайте подвесим одно из деревьев к другому.
[41:26.520 --> 41:29.520]  У нас же это все корневые деревья.
[41:29.520 --> 41:31.520]  Давайте меньше из них подвесим к большему.
[41:31.520 --> 41:34.520]  Просто посчитаем количество вишен здесь, количество вишен здесь.
[41:34.520 --> 41:39.520]  И то из них, которое меньше, назначим сыном большего.
[41:39.520 --> 41:44.520]  Давайте картинку симпатичнее нарисую.
[41:44.520 --> 41:51.520]  Чуть-чуть докажем.
[41:51.520 --> 41:53.520]  Было такое маленькое дерево.
[41:53.520 --> 41:56.520]  И вот было какое-нибудь большое.
[41:56.520 --> 42:00.520]  Такое вот кустистое, если есть такое слово, дерево.
[42:00.520 --> 42:03.520]  Вот такое что-нибудь.
[42:03.520 --> 42:05.520]  Совсем не обязательно бинарное.
[42:05.520 --> 42:07.520]  Я нигде про бинарность ничего не говорил.
[42:07.520 --> 42:12.520]  Вот тут я когда рисовал, оно не бинарное.
[42:12.520 --> 42:15.520]  Я по В нашел корень.
[42:15.520 --> 42:17.520]  С помощью процедуры GET по U нашел корень.
[42:17.520 --> 42:19.520]  Посчитал размеры.
[42:19.520 --> 42:21.520]  И подвесил меньше к большему.
[42:21.520 --> 42:25.520]  То есть по факту провел просто вот такое одно ребро.
[42:25.520 --> 42:29.520]  Для этого, чтобы сравнивать, какой из деревьев меньше, какой больше,
[42:29.520 --> 42:34.520]  давайте я в каждой вершине еще буду хранить размер.
[42:34.520 --> 42:36.520]  Давайте я буду писать size.
[42:36.520 --> 42:38.520]  Это размер по дереву.
[42:38.520 --> 42:42.520]  То есть в каждой вершине я храню, сколько вершин лежит в ее по дереве.
[42:42.520 --> 42:47.520]  Тогда процедура UNITE у меня работает следующим образом.
[42:47.520 --> 42:51.520]  UNITE от U и V работает следующим образом.
[42:51.520 --> 42:58.520]  Ну, сначала давайте U заменим на GET от U, V заменим на GET от V.
[42:58.520 --> 43:01.520]  То есть считаем, что у меня деревья корнями заданы.
[43:01.520 --> 43:05.520]  Не какими-то там рандомными вершинками, а корнями своими.
[43:05.520 --> 43:07.520]  Вот это и вот это.
[43:07.520 --> 43:09.520]  Я считаю, что U не равно V.
[43:09.520 --> 43:14.520]  Потому что если U равно V, то меня попросили множество само собой.
[43:14.520 --> 43:16.520]  Видите, это бред. Мы так не делаем.
[43:16.520 --> 43:18.520]  Дальше я сделаю следующее.
[43:18.520 --> 43:23.520]  Если size от U меньше size от V, то я их свопну.
[43:23.520 --> 43:27.520]  И подвешу V к U после этого.
[43:27.520 --> 43:29.520]  Что такое подвесить V к U?
[43:29.520 --> 43:34.520]  Это значит назначить родителем V вершину U и пересчитать size от U,
[43:34.520 --> 43:37.520]  потому что у него появился новое под дерево.
[43:37.520 --> 43:41.520]  Появилось новый сын и вместе с ним все под деревом.
[43:41.520 --> 43:44.520]  Поэтому size от U я просто прибавляю size от V.
[43:44.520 --> 43:46.520]  Конец.
[43:46.520 --> 43:48.520]  Я взял два корня.
[43:48.520 --> 43:50.520]  К большему из них подвесил меньше.
[43:50.520 --> 43:53.520]  У меня сейчас U больше, V меньше.
[43:53.520 --> 43:55.520]  Соответственно родитель V это U.
[43:55.520 --> 44:00.520]  И размер U поменялся, потому что там появился новый под деревом.
[44:00.520 --> 44:04.520]  Причем тут давайте еще раз повторим.
[44:04.520 --> 44:07.520]  У меня сейчас U больше, V меньше.
[44:07.520 --> 44:13.520]  У меня у меня U больше, V меньше.
[44:13.520 --> 44:17.840]  тут давайте еще раз, я повторю. вот это
[44:17.840 --> 44:19.420]  ребро, которое я провожу, вот это вот
[44:19.420 --> 44:21.280]  древесное ребро, оноuchenасно не
[44:21.280 --> 44:22.920]  связано с исходной задачей, потому что
[44:22.920 --> 44:24.320]  в исходной задачи меня просили вот
[44:24.320 --> 44:26.220]  такое ребро провести, вот они. а
[44:26.220 --> 44:28.540]  я вместо этого взял, поднялся в корне и
[44:28.540 --> 44:31.340]  провел вот такое ребро. этого ребра
[44:31.340 --> 44:33.060]  возможно даже в исходном графе нету.
[44:33.060 --> 44:34.480]  но еще раз, те ребра, которые я провожу
[44:34.480 --> 44:36.800]  внутри своей струху не обязаны
[44:36.800 --> 44:38.200]  соотноситься с исходным графом.
[44:38.200 --> 44:40.640]  я внутри множества могу
[44:40.640 --> 44:42.260]  провести ребра как угодно. да, эти
[44:42.260 --> 44:42.440]  ребраtoo notebookEL�, это и sedukir, что
[44:42.440 --> 44:45.740]  только то, что это все в одной компоненте. То есть если бы провел такое ребро,
[44:45.740 --> 44:50.320]  у меня бы тоже все это осталось одной компонентой, но я для удобства, для того,
[44:50.320 --> 44:54.400]  чтобы асимптотика была такая, как надо, я прожу вот такое ребро. Еще раз, это ребро
[44:54.400 --> 44:59.800]  не из исходного графа, а вот я его сам хочу и ввожу.
[45:00.520 --> 45:06.280]  Вот, собственно, все. Вот того, что я написал на той доске, хватит, чтобы
[45:06.280 --> 45:09.880]  отвечать на запросы за логарифм.
[45:13.440 --> 45:20.200]  Значит, теперь все запросы работают за отлогарифма. Теперь ответ на каждый
[45:20.200 --> 45:31.000]  запрос. У меня будет отлогарифма N. Ну почему? Давайте покажем, что глубина всех
[45:31.000 --> 45:40.200]  деревьев будет максимум всегда логарифм. Глубина всех деревьев не превосходит
[45:40.200 --> 45:48.560]  высшего логарифма N. Почему? Смотрите, потому что каждый раз, когда я прохожу по
[45:48.560 --> 45:54.200]  ребру снизу вверх, я уменьшаю размер текущего по дереву хотя бы в два раза.
[45:54.200 --> 45:58.200]  Да, потому что вот был у меня, вот, что такой проход по ребру снизу вверх? Это
[45:58.200 --> 46:01.840]  значит, в какой-то момент это под дерево приклеилось к этому, причем это было
[46:01.840 --> 46:06.720]  меньшим, а это большим. Я всегда меньше к большему подвешиваю. Значит, при проходе снизу
[46:06.720 --> 46:11.080]  вверх у меня размер текущего по дереву увеличивается хотя бы вдвое, потому что
[46:11.080 --> 46:15.680]  раньше было вот это, а стало вот это при переходе в родителя. Причем, если тут был
[46:15.680 --> 46:22.160]  х, тут был у больше равной х, то значит, суммарно будет хотя бы 2х. Вот, ну значит,
[46:22.160 --> 46:26.240]  каждый подъем это увеличение размера по дереву хотя бы вдвое. Но увеличиваться
[46:26.240 --> 46:30.360]  вдвое мы можем не больше, чем лог раз, потому что всего N элементов. Ну, значит,
[46:30.360 --> 46:35.800]  глубина алгорифма. Значит, подъем в родителя
[46:39.560 --> 46:42.560]  увеличивает
[46:45.000 --> 46:48.160]  размер под дерево
[46:50.320 --> 46:53.720]  хотя бы вдвое.
[46:54.720 --> 47:01.080]  Ну, значит, глубина максимум алгорифма.
[47:10.040 --> 47:16.720]  В п, в п, в п. Не обязательно в корень, то есть все вот эти стрелки, они всегда
[47:16.720 --> 47:22.520]  увеличивают хотя бы вдвое. Не обязательно в корню, просто, ну, в непосредственно
[47:22.520 --> 47:30.880]  родителя. Ну вот, а значит, у меня гет работает за алгорифм всегда, потому что
[47:30.880 --> 47:35.280]  гет просто прыгает в родителя, ну, многократно поднимается в родителя, а каждый
[47:35.280 --> 47:39.880]  подъем в родителя это увеличение хотя бы в два раза размера под дерево, значит,
[47:39.880 --> 47:43.440]  таких прыжков будет максимум алгорифма. Ну, юнайт автоматически работает за алгорифм,
[47:43.440 --> 47:47.720]  потому что юнайт — это просто два гета, а дальше вот и днице. Что-таки свопы, какие-то
[47:47.720 --> 47:53.520]  прибавления и так далее. Вот, поэтому сразу у меня все работает за алгорифм, все запросы
[47:53.520 --> 48:04.080]  алгорифм. Окей? Так, хорошо. Значит, это, ну, такая самая простая реализация СНМ. Есть
[48:04.080 --> 48:11.200]  чуть более изочеренная, есть следующая эвристика. Значит, давайте я здесь напишу. Вот то, что я
[48:11.200 --> 48:21.400]  делаю вот здесь вот — это эвристика по рангу, эвристика по рангу называется. Вот, а сейчас мы сделаем
[48:21.400 --> 48:34.800]  эвристику сжатия путей. Значит, тут помогает следующее важное замечание. Смотрите, мне на самом деле,
[48:34.800 --> 48:40.480]  повторно скажу, от структуры дерева не так уж много и нужно. Мне на самом деле нужно только
[48:40.480 --> 48:45.520]  уметь находить корня дерева. И вот то, что здесь был какой-то там длинный путь вот такой из трех
[48:45.520 --> 48:50.040]  ребер отсюда до сюда, мне на самом деле это не очень важно. И я сделаю следующее. Каждый раз,
[48:50.040 --> 48:56.800]  когда я для какой-то вершины В, многократно поднимаясь по стрелочке, дохожу до корня своего
[48:56.800 --> 49:01.760]  дерева, я могу попутно для всех вершин на этом пути перенаправить эту стрелку сразу в корень.
[49:01.760 --> 49:07.600]  То есть я все вот эти стрелки удаляю и перенаправляю их сразу в корень непосредственно, без вот этих
[49:07.600 --> 49:15.840]  промежуточных вершин. Повторюсь, у меня структура дерева как-то меняется, но сами множество, сами
[49:15.840 --> 49:21.200]  в себе не меняются. У меня остаются на месте корни, у меня остаются достижимости все, то есть то,
[49:21.200 --> 49:25.400]  что было в одном множестве, в одном множестве останется лежать. А то, что было в разных, по-прежнему
[49:25.400 --> 49:34.320]  будет в разных лежать. Поэтому такое преобразование точно мне ничего не портит. Короче, структура
[49:34.320 --> 49:38.160]  остается корректной. То есть это будет другое дерево, но по-прежнему корректное. Разбеяние на множество
[49:38.160 --> 49:44.520]  будет корректным. Но зато понятно делать в каком-то смысле оптимизация, потому что потом, если в
[49:44.520 --> 49:49.360]  будущем меня кто-то попросит сделать гет от В, я не буду проходить все вот эти ребра, а сразу прыгну
[49:49.360 --> 49:55.680]  вот сюда. То есть какую-то часть работы на будущее я себе уже сэкономил. Давайте я напишу обновленный гет.
[49:55.680 --> 50:08.280]  Значит, как обычно, если мы уже пришли в корень, то надо его вернуть. Вот, а иначе, ну давайте
[50:08.280 --> 50:17.040]  какой-нибудь х я заведу. Пусть это будет корень, полученный из родителя. Ну я сразу ПЛТВ переназначу
[50:17.040 --> 50:32.400]  родителя, в корень точнее, и верну его в качестве ответа. И эта эвристика вкупе с предыдущей,
[50:32.400 --> 50:42.400]  с эвристикой по рангу, работает супер быстро. Сейчас напишем засколько вам не понравится.
[50:47.040 --> 50:58.120]  Теорема, конечно. Значит, давайте введем следующую функцию, называется функция кирмана.
[50:58.120 --> 51:20.880]  Я тупой, мне можно. Значит, n плюс 1, если m равно нулю, а m минус 1, 1, если m больше нуля, а n ноль,
[51:20.880 --> 51:47.800]  и а m минус 1, а m n минус 1, если оба положительные. Вот, какая-то такая функция. Значит, важное
[51:47.800 --> 51:53.600]  здесь вот это, что при уменьшении первого аргумента на единичку, вы в качестве второго
[51:53.600 --> 51:58.600]  подставляете что-то уже насчитанное. И за счет этого у вас получается на самом деле взрывной рост
[51:58.600 --> 52:03.120]  этой функции, потому что когда вы здесь уменьшили на единичку, а в качестве второго аргумента
[52:03.120 --> 52:09.640]  поставили что-то, ну короче, почти amn, чуть-чуть поменьше, amn минус 1. На самом деле за счет этого
[52:09.640 --> 52:13.800]  у вас она будет очень быстро расти. Мы там напишем примерчик, она там уже для а4,4 какая-то
[52:13.800 --> 52:27.240]  астрономически огромная просто. Вот, начинается называть функцией керман. Дальше пусть а это
[52:27.240 --> 52:38.800]  обратная функция кермана, то есть минимальное такое n, что amn больше или равно k, что обратная
[52:38.800 --> 52:50.680]  функция кермана. Вот, и тогда оказывается, что две эверистики вместе работают за амортизированную
[52:50.680 --> 53:20.680]  обратную функ
[53:20.680 --> 53:37.520]  Вот, почему это хороший результат? Потому что а4,4 это 2 в степени 65536-3, это тоже там 2 в какой-то,
[53:37.520 --> 53:47.080]  не помню в какой, 16 наверное. Ну и поэтому, типа а это уже что-то гигантское, представь
[53:47.080 --> 53:51.720]  себе 2 в степени 65536, это уже что-то гигантское, это больше, мол, кунг, уже заведомо. И вы еще и двойку в
[53:51.720 --> 53:58.080]  этой степени возводите, это прям, не знаю, это что-то супер огромное. Вот, поэтому а для всего адекватного
[53:58.080 --> 54:05.160]  не больше чем 4. То есть если вы тут поставляете какое-то нормальное число, там не, ну я даже не знаю,
[54:05.160 --> 54:09.960]  таких слов, наверное, нет. Наверное, больше чем 10 в сотой, ну уж точно больше, короче, от любого
[54:09.960 --> 54:21.400]  нормального числа от не больше чем 4. Вот, поэтому здесь у вас написано 4. Ну вот, поэтому в каких-то
[54:21.400 --> 54:27.320]  местах вы даже можете увидеть на трассу что-то работать типа за единицу, ну потому что как бы,
[54:27.320 --> 54:33.160]  ну на всех, на всех как бы, не просто реальных там вычислителях, а ну на всех как бы мыслямых
[54:33.160 --> 54:38.360]  задачах даже, это всегда не больше чем 4, поэтому можно считать, что это единица. Ну все-таки как бы не
[54:38.360 --> 54:43.640]  хочется так говорить, потому что там мало ли когда-нибудь, не знаю, ну помимо, что число атомов
[54:43.640 --> 54:50.360]  во вселенной больше, чем вот это и тогда, ну типа, ну короче, короче, вот теоретически оценка
[54:50.360 --> 54:56.080]  правильная вот такая, но в практических как бы вычислениях можно, ну ею часто пренебрегают,
[54:56.080 --> 54:59.440]  давайте так, я не буду пренебрегать, но часто можете увидеть, что ею пренебрегают и пишут,
[54:59.440 --> 55:06.520]  что это просто единичка. Вот, ну здесь еще замечание, что здесь как бы важно, что ну,
[55:06.520 --> 55:13.920]  существенно, что это именно учетная оценка, ну потому что, например, если у вас вполне спокойно мог
[55:13.920 --> 55:19.600]  вот такой вот бамбук когда-то появиться, то есть вы вот так вот, если подвешивали там вот это к этому,
[55:19.600 --> 55:24.760]  это к этому и так далее, такое, такое могло быть, тогда у вас может быть вполне, что у вас такой
[55:24.760 --> 55:28.760]  длинный бамбук есть. Тогда чтобы вам выполнить гет для этой вершинки, вам нужно весь его пройти,
[55:28.760 --> 55:33.240]  но зато вы сразу все вот эти стрелки сюда перенаправляете и больше поэтому бамбуку не ходите.
[55:33.240 --> 55:39.440]  То есть каждая конкретная операция может работать задолго, но учетно вот там, как обычно в среднем,
[55:39.440 --> 55:50.880]  все работает быстро, примерно за единицу. Вот, ну и поэтому давайте вернемся к Рускалу,
[55:50.880 --> 56:01.040]  давайте 8 дочек напишем. Значит, сколько работает сортировка? За m log m, а дальше за m на альфа от m,
[56:01.040 --> 56:09.280]  потому что у меня будет m запросов каждый, ну к СНМ, каждый работает за учетную альфу,
[56:09.280 --> 56:10.720]  значит, суммарно работает за m на альфа.
[56:10.720 --> 56:29.800]  Хороший вопрос. Это правда. Ну по крайней мере асимпатички точно правда. Это справедливое
[56:29.800 --> 56:35.440]  замечание, да, что как бы вот это всегда меньше, чем это асимпатически. Вот, но опять-таки тут-то у
[56:35.440 --> 56:40.400]  меня написана сортировка, а мы про сортировку знаем много чего. Например, если бы мы могли
[56:40.400 --> 56:45.080]  сделать сортировку под счетом, то это было бы за отм. То есть если бы мы внезапно откуда знаем,
[56:45.080 --> 56:50.400]  что веса, ребра маленькие целые числа, тогда можем сортировку побыстрее сделать. Вот. Ну
[56:50.400 --> 56:55.000]  поэтому как бы вот давайте я все-таки оставлю и то и то, потому что и эту штуку можно оптимизировать,
[56:55.000 --> 56:59.920]  да, ну здесь там не оптимизируешь, но по крайней мере альфа это всегда маленькая штука, поэтому тут
[56:59.920 --> 57:04.360]  как бы тоже можно понять, что это в каком-то смысле отм. Вот, но вообще говоря вот такая сумма остается,
[57:04.360 --> 57:11.680]  и это асимптотика Kruskal. Так, все, SNM плюс Kruskal закончили, вопросы есть по этому блоку?
[57:11.680 --> 57:32.200]  Окей. Так, ну тогда последний алгоритм, алгоритм Барувки, который делает то же самое. Ну в плане
[57:32.200 --> 57:43.760]  решает ту же самую задачу. Алгоритм тоже описывается довольно просто. Во-первых,
[57:43.760 --> 57:50.960]  давайте для каждой вершины выделим самое дешевое ребро из нее исходящее. Ну как бы понятно,
[57:50.960 --> 57:55.000]  что если мы ищем минимальный астов, то наверное в каждую вершину что-то должно входить,
[57:55.000 --> 57:59.320]  грав должен быть связан, и у каждой вершины должно быть какое-то исходящее ребро, если грав
[57:59.320 --> 58:08.120]  больше, чем из одной вершины состоит. Поэтому понятно, что в вершину должно ввести хотя бы
[58:08.120 --> 58:13.120]  минимальное ребро. Возможно больше, но минимальное точно по стоимости должно входить. Ну, в ответ
[58:13.120 --> 58:19.240]  точно войдет ребро веса хотя бы такой как минимальный. Вот давайте его возьмем. Для каждой вершины
[58:19.240 --> 58:26.600]  возьмем в астов
[58:26.600 --> 58:33.880]  самое дешевое исходящее ребро.
[58:33.880 --> 58:54.800]  Второе. Сожмем компоненты связанности и запустимся рекурсивно.
[59:03.880 --> 59:16.720]  Ну, пока в графе хотя бы две вершины остается.
[59:16.720 --> 59:28.480]  Да, ну, то есть примерчик давайте нарисую опять. Вот есть какой-то такой граф. Давайте я для каждой
[59:28.480 --> 59:31.400]  вершины найду самое дешевое исходящее ребро. Например, для этой вершины будет вот это ребро,
[59:31.400 --> 59:36.160]  для этой пусть будет оно же, а для этой вот это. Для этой вершины будет вот это ребро, для этой
[59:36.160 --> 59:44.640]  вершины вот это. Я утверждаю, что это подножие на 100. Я могу превратить эти вершины в одну большую
[59:44.640 --> 59:50.960]  вершину, сжать их. То есть сказать, что вот эта теперь одна вершина и вот эта одна вершина. Ребра,
[59:50.960 --> 59:56.200]  которые остаются, это ребра между компонентами. То есть ребра между вершинами, ну вот одна здесь,
[59:56.200 --> 01:00:00.400]  другая здесь. То есть все вот эти ребра теперь у меня превращаются в ребро
[01:00:00.400 --> 01:00:04.840]  между компонентой вот этой и вот этой. То есть я их там всех склеиваю, но на самом
[01:00:04.840 --> 01:00:08.080]  деле могу сказать, что выбираю минимальное. Понятно, что если есть несколько таких
[01:00:08.080 --> 01:00:12.080]  ребер, то мне нужно из них только минимальное. Вот, сжимаю компоненты,
[01:00:12.080 --> 01:00:16.560]  остается вот такой граф. Ну и в нем уже рекурсивно нахожу минимальный астов, это
[01:00:16.560 --> 01:00:19.480]  просто это ребро будет всегда.
[01:00:20.480 --> 01:00:31.480]  Вот такой алгоритм. Значит, тут есть два вопроса. Во-первых, почему у нас не
[01:00:31.480 --> 01:00:34.840]  образуются циклов, во-вторых, почему у нас получится минимальный астов в конце.
[01:00:34.840 --> 01:00:39.880]  Вот давайте сначала с циклов начнем. Значит, как сделать так, чтобы не образовывалось
[01:00:39.880 --> 01:00:57.360]  циклов, чтобы не образовывалось циклов. Потому что на самом деле в той
[01:00:57.360 --> 01:01:01.480]  реализации, в которой я написал, циклы могут появляться. Потому что если бы у
[01:01:01.480 --> 01:01:06.600]  меня, например, были три вершины, соединенные ребрами веса 1, ну одного и
[01:01:06.840 --> 01:01:09.940]  того же минимального веса, то я мог бы для этой вершины выбрать это ребро, для этой
[01:01:09.940 --> 01:01:11.920]  вершины выбрать это ребро, для этой вершины выбрать это ребро.
[01:01:11.920 --> 01:01:15.340]  Тогда у меня бы был цикл, а так точно нельзя. Мы не можем цикл добавлять в
[01:01:15.340 --> 01:01:18.320]  минастов, это бред. Поэтому на самом деле мне здесь нужно немножко уточнить и
[01:01:20.860 --> 01:01:24.920]  сказать примерно следующее. Если есть несколько ребер минимального веса, то я
[01:01:24.920 --> 01:01:29.340]  из них выбираю то, которое ведет вершину с минимальным номером, ну, чтобы не было
[01:01:29.340 --> 01:01:35.220]  такого, что я для этой вершинки выбрал это, а для этой вот это. Ну, короче, чтобы
[01:01:35.220 --> 01:01:41.960]  чтобы у нее не было циклов как раз. вот давайте здесь это формализую. если есть
[01:01:41.960 --> 01:01:57.840]  несколько исходящих ребер одинакового веса, одинаково минимального веса,
[01:01:57.840 --> 01:02:14.240]  выбираем ребро ведущее вершину с минимальным номером.
[01:02:27.840 --> 01:02:32.640]  вот тогда уже циклов я не получится.
[01:02:32.640 --> 01:02:38.440]  почему?
[01:02:38.440 --> 01:02:56.040]  ну чтобы доказать, что циклов не получится, я сделаю следующее.
[01:02:56.040 --> 01:03:07.440]  давайте я вот эти ребра, когда их выбираю, давайте их буду ориентировать. то есть я их
[01:03:07.440 --> 01:03:10.200]  ориентирую только для доказательства, на самом деле не в алгоритме, не в
[01:03:10.200 --> 01:03:14.040]  реализации. короче, я их ориентировать не буду, сейчас только для доказательства буду ориентировать.
[01:03:14.040 --> 01:03:20.960]  так вот, давайте в случае, когда я довершины В, выбираю некоторое ребро Е, из нее торчащее,
[01:03:20.960 --> 01:03:26.400]  я ориентирую это ребро в сторону от В. то есть я его вот так вот ориентирую. это значит, что из В
[01:03:26.400 --> 01:03:35.720]  я выбрал ребро Е. давайте нарисуем в нем стрелку. тогда, как выглядит граф после вот этих выборов,
[01:03:35.720 --> 01:03:41.720]  после выборов ребра для каждой вершины? ну это так называемый функциональный граф,
[01:03:41.720 --> 01:03:53.880]  когда из каждой вершины выходит ровно одно ребро. ну понятно, я для каждой вершины нашел
[01:03:53.880 --> 01:03:57.520]  минимальную по весу, из минимальных по весу взял то, которое ведет в вершину с минимальным
[01:03:57.520 --> 01:04:02.920]  номером, и ориентировал его в сторону от В. теперь у меня исходящая степень каждой вершины ровно
[01:04:02.920 --> 01:04:09.480]  один. так вот, этот граф всегда выглядит как-то так. в каждой компоненте связанности у меня есть
[01:04:09.480 --> 01:04:17.720]  некий цикл, к которому подвешены деревья. вот так, и в общем виде нарисую, что-то вот такое будет.
[01:04:17.720 --> 01:04:25.880]  здесь дерево, здесь какое-то дерево, ну и так далее. и таких циклов может быть несколько.
[01:04:25.880 --> 01:04:41.200]  возможно цикл из двух вершин, вот такой может быть. ну смотрите, вот давайте посмотрим
[01:04:41.200 --> 01:04:45.760]  функциональный граф. что это такое? это значит, мы встали в какую-то вершинку, и у нас всегда
[01:04:45.760 --> 01:04:50.760]  есть одно исходящее ребро, одно направленное исходящее ребро. вот оно куда-то ведет. давайте
[01:04:50.760 --> 01:04:55.000]  просто пойдем по этим по этим ребрам, куда-то пришли. дальше, здесь опять есть исходящее
[01:04:55.000 --> 01:04:59.680]  ребро, куда-то пришли. здесь есть исходящее ребро, куда-то пришли. и так далее, и так далее. мы не
[01:04:59.680 --> 01:05:03.920]  можем продолжить цикл до бесконечности, потому что граф конечный. рано или поздно мы попадем туда,
[01:05:03.920 --> 01:05:08.200]  куда уже были. туда, где уже были. и вот вам, пожалуйста, цикл. то есть тут, как ни крути цикл,
[01:05:08.200 --> 01:05:12.640]  обязательно будет. в функциональном графе обязательно есть циклы. ну возможно вот такие длины 2,
[01:05:12.640 --> 01:05:18.360]  когда из У пошли в В и из В в У. это вот случай, как вот тут на картинке было. одно и то же ребро
[01:05:18.360 --> 01:05:25.760]  назначено сразу двум вершинам. это будет цикл длины 2. почему граф так выглядит? понятно,
[01:05:25.760 --> 01:05:31.840]  я начал в В, обязательно вошел в цикл. то есть из каждой вершины достижем какой-то цикл. вот этот,
[01:05:31.840 --> 01:05:37.440]  вот этот или вот этот. а дальше к этому циклу, что в этот цикл может входить? только какие-то пути.
[01:05:37.440 --> 01:05:45.560]  то есть только деревья. вот такие вот подвешенные деревья. у меня вершинами, корнями деревьев
[01:05:45.600 --> 01:05:49.720]  выступают эти вершины на цикле. и к ним может быть подвешено что угодно, но только уже без циклов.
[01:05:49.720 --> 01:05:53.860]  потому что если там где-то есть цикл, то это будут отдельные компоненты несвязанные с этим циклом.
[01:05:53.860 --> 01:05:58.880]  если достижим какой-то цикл вот здесь, то я уже до этого цикла точно никак не доберусь,
[01:05:58.880 --> 01:06:04.000]  потому что я все достижим и исчерпал. поэтому именно что каждый компонент
[01:06:04.000 --> 01:06:07.800]  по связности...�� тут не очень хорошо говорить про компонент связанности, потому что граф ориентирую,
[01:06:07.800 --> 01:06:13.160]  но тем не менее каждая компонента этого графа — это цикл с подвеш standardized и к нему деревьями.
[01:06:13.160 --> 01:06:23.480]  Ну и в общем случае бывают у меня, конечно, петли в качестве циклов, но тут такого не бывает,
[01:06:23.480 --> 01:06:29.800]  потому что у меня все-таки в графе нет петель, я не выбираю петли, поэтому тут такого не бывает.
[01:06:29.800 --> 01:06:32.040]  Но в общем случае в функциональной графе бывают вот такие петельки.
[01:06:32.040 --> 01:06:39.440]  Так, и вот я утверждаю, что в случае построения функциональной графа так, как я писал,
[01:06:39.440 --> 01:06:45.040]  у меня не будет вот таких вот больших компонент связанности, где цикл имеет длину больше, чем два.
[01:06:45.040 --> 01:06:55.720]  Потому что цикл длины больше, чем два, это как раз есть, ну, обычный цикл в исходном графе,
[01:06:55.720 --> 01:07:01.600]  а цикл длины просто два, это нормальный цикл, это вот такая штука, просто одно ребро,
[01:07:01.600 --> 01:07:08.080]  я его могу добавлять. Так вот я утверждаю, что не будет цикла в длине хотя бы три.
[01:07:08.080 --> 01:07:26.920]  Не будет циклов длины хотя бы три. Почему? Первое замечание, если есть два ребра подряд,
[01:07:26.920 --> 01:07:34.200]  из В какое-то исходящее, в У и из У какое-то исходящее, то их стоимости при проходе по
[01:07:34.200 --> 01:07:44.520]  ребру только уменьшаются. Это очевидно следует из того, что вот для этой вершинки, давайте я их
[01:07:44.520 --> 01:07:51.520]  назову В, У, ВВ, что значит, что для У я выбрал Е штриха, а не Е. Но это уж точно значит,
[01:07:51.520 --> 01:07:56.240]  что вес Е штриха точно не больше, чем Е, потому что если бы он был больше, то я мог бы вместо
[01:07:56.240 --> 01:08:00.240]  этого ребра выбрать Е, и мне стало бы только лучше. А поскольку я выбираю минимально исходящее
[01:08:00.280 --> 01:08:07.680]  ребро, то я Е штрих никак взять бы не мог. Поэтому если есть два ребра подряд, то их веса уменьшаются
[01:08:07.680 --> 01:08:14.480]  при проходе по направлению. Отсюда до сюда вес только уменьшается, не строго уменьшается. Поэтому
[01:08:14.480 --> 01:08:20.920]  если у меня есть некий цикл, то при проходе по нему постоянно уменьшается стоимость. Но давайте я
[01:08:20.920 --> 01:08:26.000]  начну с какого-то там кост от Е. Пришел сюда, стоимость уменьшилась, еще уменьшилась, еще уменьшилась,
[01:08:26.760 --> 01:08:30.880]  еще уменьшилась и осталась такой же, какой была. Ну значит, понятно дело, что они все одинаковые,
[01:08:30.880 --> 01:08:39.680]  что веса всех этих ребер одинаковые, кост у них одинаковый. Значит, стоимость одинаковая, и тогда
[01:08:39.680 --> 01:08:43.840]  играет как раз вот то, что я здесь говорил, что мне нужно выбирать вершину с минимальным номером.
[01:08:43.840 --> 01:08:53.320]  Давайте примерно рисуем. Вот у меня есть цикл из пяти вершин. Давайте я их зонумирую V1, V2, V3, V4, V5.
[01:08:53.320 --> 01:08:59.880]  Давайте напишем, что значит, что для v1 я выбрал v2, а не v5. Они же одинаковые,
[01:08:59.880 --> 01:09:05.200]  то есть вот эти стоимости одинаковые, но я выбрал тем не менее вот это ребро в v2, а не в v5. Это
[01:09:05.200 --> 01:09:14.480]  значит, что его номер меньше, чем v5. Раз я для v1 выбрал ребро v2, а не v5, то v2 меньше,
[01:09:14.480 --> 01:09:22.160]  чем v5 численно. Это вершина с меньшим номером. Дальше давайте посмотрим на v4. v4 выбрала v5,
[01:09:22.160 --> 01:09:28.760]  а не v3, хотя это ребра одинакового веса, значит v5 меньше, чем v3. Могу продолжить
[01:09:28.760 --> 01:09:36.160]  это неравенство вот до сюда. Теперь смотрим на v2. Для v2 опять есть два одинаковых ребра
[01:09:36.160 --> 01:09:48.000]  минимального веса, но я выбираю v3, а не v1, значит v3 меньше, чем v1. Ну и наконец для v5
[01:09:48.000 --> 01:09:52.600]  тоже самое пишу. v1 предпочтительнее v4, хотя они имеют одинаковый вес, значит v1 меньше,
[01:09:52.600 --> 01:09:59.640]  чем v4. Ну и теперь наконец для v3 v4 предпочтительнее, чем v2, значит v4 меньше,
[01:09:59.640 --> 01:10:09.240]  чем v2. Противоречиво, v2 меньше, чем v2. Это было для цикла нечетной длины. Для цикла
[01:10:09.240 --> 01:10:26.600]  нечетной длины будет на самом деле еще проще. Давайте для v1 напишу. Значит раз v1 выбирают v2,
[01:10:26.600 --> 01:10:34.840]  а не v6, то v2 меньше, чем v6. v5 выбирает v6, а не v4, поэтому v6 меньше, чем v4. v3 выбирает v4,
[01:10:34.840 --> 01:10:42.640]  а не v2, поэтому v4 меньше, чем v2. И мы уже схлопнулись, v2 меньше, чем v2. Ну и собственно и все.
[01:10:42.640 --> 01:10:45.680]  То есть там на самом деле можно аккуратнее расписать, что если длина цикла нечетная,
[01:10:45.680 --> 01:10:49.480]  тогда будет вот такая цепочка, ведущая к противоречию. Если длина цикла четная,
[01:10:49.480 --> 01:10:55.480]  то будет вот такая цепочка в два раза меньше длины, но тоже ведущая к противоречию. И не
[01:10:55.480 --> 01:11:05.640]  будет противоречия, только если цикл у нас вот такой. Потому что здесь я уже ни одного
[01:11:05.640 --> 01:11:10.520]  такого неравенства написать не могу, потому что если из v1 есть только одно исходящее в v2
[01:11:10.520 --> 01:11:14.840]  минимального веса, то там уже нет никаких вот таких условий, что v2 предпочитнее, чем кто-то.
[01:11:14.840 --> 01:11:20.280]  Поэтому здесь просто никакого противоречия нет, такое бывает, и только так на самом деле будет.
[01:11:20.280 --> 01:11:25.800]  Мы показали, что больших циклов не бывает. Могут быть только такие, а это не то, что цикл,
[01:11:25.800 --> 01:11:29.600]  это просто одно и то же ребро. То есть это цикл только из-за того, что я его ориентировал,
[01:11:29.600 --> 01:11:33.560]  одно и то же ребро в две стороны. Но на самом деле это просто одно ребро графа,
[01:11:33.560 --> 01:11:36.160]  которое не образует циклов при добавлении в наш миностов.
[01:11:36.160 --> 01:11:46.480]  Поэтому мы теперь доказали, что с учетом вот этой оговорки у нас граф всегда будет оставаться
[01:11:46.520 --> 01:11:51.440]  дерево. Точнее, ацикличность будет оставаться, циклов там не будет. И если я вот так постепенно
[01:11:51.440 --> 01:11:55.280]  все склею, то это будет дерево в конце концов, потому что циклов никогда в нем не появятся.
[01:11:55.280 --> 01:11:59.880]  Так, чудно.
[01:11:59.880 --> 01:12:15.000]  Значит, ацикличность мы доказали.
[01:12:15.000 --> 01:12:28.840]  Теперь вопрос про минимальность. Почему, добавляя все эти ребра, мы остаемся под
[01:12:28.840 --> 01:12:38.120]  множеством миностова? Ну давайте опять порисуем. Смотрите, ребра, которые я добавляю на очередном
[01:12:38.120 --> 01:12:44.200]  шаге, это несколько вот таких вот компонент связанности, опять-таки в кавычках, вот такого
[01:12:44.200 --> 01:12:49.440]  вида. То есть у меня есть цикл длины 2 и к нему подвешены деревья. То есть все, что я добавляю в
[01:12:49.440 --> 01:12:54.880]  наш миностов, это какое-то ребро, которое по факту я ориентировал в обе стороны. То есть я для этого
[01:12:54.880 --> 01:12:59.480]  вершины выбрал это ребро и для этого выбрал тоже самое ребро, поэтому получился цикл длины 2. И к нему
[01:12:59.480 --> 01:13:10.080]  что-то еще подвешено. Вот какие-то там такие штуки. Давай что-нибудь длинное нарисую. Вот я утверждаю,
[01:13:10.080 --> 01:13:15.000]  что это все можно скопом добавить в миностов, и у меня останется все это под множеством миностова.
[01:13:15.000 --> 01:13:22.800]  Почему? Смотрите, ну давайте посмотрим на вот эту вершину. Это какая-то компонента связанности в
[01:13:23.040 --> 01:13:28.000]  миностове, то есть тут, на самом деле, опять лэма в безопасном ребре. Вот это, это какая-то компон�menы
[01:13:28.000 --> 01:13:33.400]  связанности в исходом миностове. Потому что у меня сейчас после сжатия компонент и у меня
[01:13:33.400 --> 01:13:37.260]  дома, на самом деле, каждый вышина это своя отдельный компонент связанности. Вот отдельные компоненты.
[01:13:37.260 --> 01:13:42.640]  Что такое это? Это минимальное ребро, ведущее из этой компоненты во все остальное. Поэтому
[01:13:42.640 --> 01:13:48.580]  это ребро точно безопасное, по лэме. Вот это одна компонента, это все остальное, я могу взять это
[01:13:48.580 --> 01:13:53.560]  ребро добавить в ответ. поэтому так точно можно сделать. теперь что такое вот это
[01:13:53.560 --> 01:13:58.840]  ребро? это ребро на самом деле это минимальное ребро, соединяющее вот эту
[01:13:58.840 --> 01:14:03.400]  компоненту связанности со всем остальным. потому что какие ребра вообще из
[01:14:03.400 --> 01:14:08.000]  этой компонентной связанности торчат? они либо отсюда выходят, либо отсюда. но я знаю,
[01:14:08.000 --> 01:14:11.440]  что вес этого ребра не больше, чем вес этого ребра. я делал уже это замечание, что
[01:14:11.440 --> 01:14:15.160]  здесь при проходе по ребру у меня вес только уменьшается. поэтому вес этого
[01:14:15.160 --> 01:14:20.500]  ребра точно меньше, чем веса всех ребр исходящих отсюда. joue просто
[01:14:20.500 --> 01:14:23.960]  минимальной выходящей schooling то есть тут еще возможно какие-то есть
[01:14:23.960 --> 01:14:28.300]  ребра, но они все хуже чем вот это, а это хуже, чем вот это значит это опять так
[01:14:28.300 --> 01:14:34.800]  и безопасная я могу его добавить в наш ответ. ну и здесь то самая для этой
[01:14:34.800 --> 01:14:39.380]  вершины, эта ребра оптимальная, для этой компоненты эта ребра оптимальная, ну потому что
[01:14:39.380 --> 01:14:42.920]  есть только еще вот такие, но они хуже чем то, она хуже, чем это. поэтому все это
[01:14:42.920 --> 01:14:46.220]  можно склеить в одну компоненту. И так далее. Теперь у меня есть одна большая
[01:14:46.400 --> 01:14:50.760]  компонента. Это ребро лучше, чем все входившие в него, а значит, чем все остальные
[01:14:50.860 --> 01:14:55.680]  вообще, поэтому можно вот это склеить. Это ребро опять-таки оптимальное среди
[01:14:55.780 --> 01:15:00.200]  всех входящих. Это можно склеить ну и так далее. То есть мы как бы вот здесь
[01:15:00.300 --> 01:15:03.940]  вот можем все это добавить, получить вот эту компоненту связанности. Здесь все
[01:15:04.040 --> 01:15:07.680]  объединить. Ну опять это ребро в конце будет ребро, минимальное ребро
[01:15:07.760 --> 01:15:11.880]  соединяющие две компоненты связанности. То есть по факту я просто многократно
[01:15:11.880 --> 01:15:15.880]  Многократно применяю лему о безопасном ребре и понимаю, что каждое добавление ребра корректно.
[01:15:15.880 --> 01:15:17.880]  Ну, как бы победа.
[01:15:17.880 --> 01:15:20.880]  Давайте я так это лениво напишу.
[01:15:20.880 --> 01:15:38.880]  Многократно применяем лему о безопасном ребре.
[01:15:38.880 --> 01:15:40.880]  Снизу вверх давайте напишу.
[01:15:40.880 --> 01:15:54.880]  То есть я прохожу по стрелкам снизу вверх.
[01:15:54.880 --> 01:15:59.880]  Так, с минимальностью тоже разобрались, следует из лему безопасном ребре.
[01:15:59.880 --> 01:16:07.880]  Ну и последней осталась эту точку оценить.
[01:16:07.880 --> 01:16:12.880]  Здесь вроде получается m log n.
[01:16:12.880 --> 01:16:16.880]  Потому что рекурсивных запусков у меня будет логарифмическое количество.
[01:16:16.880 --> 01:16:20.880]  Здесь запусков будет log n.
[01:16:20.880 --> 01:16:27.880]  Почему? Потому что на самом деле после вот этого мероприятия,
[01:16:27.880 --> 01:16:31.880]  после взятия всех минимальных ребер и после сжатия компонент,
[01:16:31.880 --> 01:16:36.880]  я утверждаю, что число компоненту уменьшается хотя бы вдвое.
[01:16:36.880 --> 01:16:42.880]  Если оно уменьшается хотя бы вдвое, то значит количество рекурсивных запусков будет максимум логарифмическим.
[01:16:42.880 --> 01:16:45.880]  Ну и понятно, что внутри каждого запуска мне по факту надо просто все ребра перебрать,
[01:16:45.880 --> 01:16:47.880]  чтобы минимально для каждой шины идти.
[01:16:47.880 --> 01:16:49.880]  Поэтому будет вот такая симпотика.
[01:16:49.880 --> 01:16:59.880]  Почему, давайте это напишу.
[01:16:59.880 --> 01:17:16.880]  Число компонент связности уменьшается хотя бы вдвое на каждом шаге.
[01:17:16.880 --> 01:17:21.880]  Просто потому, что размер каждой компоненты связанности будет хотя бы два.
[01:17:21.880 --> 01:17:26.880]  Потому что если была какая-то вершина, я из нее выбираю хотя бы одно исходящее ребро,
[01:17:26.880 --> 01:17:30.880]  по построению я выбираю хотя бы одно ребро.
[01:17:30.880 --> 01:17:35.880]  А значит компонента, содержащая эту вершину, хотя бы две вот эти вершины уже содержат.
[01:17:35.880 --> 01:17:38.880]  Возможно там что-то еще, возможно там какая-то более сложная компонента.
[01:17:38.880 --> 01:17:42.880]  Но хотя бы две вершины там точно есть.
[01:17:43.880 --> 01:17:47.880]  И потом там что-то еще, есть какая-то вершина, из нее есть хотя бы одно исходящее ребро.
[01:17:47.880 --> 01:17:53.880]  Опять-таки, возможно, что-то еще есть, но здесь хотя бы две вершины в этой новой компоненте будут содержаться.
[01:17:53.880 --> 01:17:59.880]  И раз в каждой компоненте хотя бы две вершины исходного графа, то всего компонент не больше чем n.
[01:17:59.880 --> 01:18:04.880]  А если изначально было n вершин, а стало не больше чем n пополам,
[01:18:04.880 --> 01:18:11.880]  то получается, что на каждом шаге вершин хотя бы в два раза меньше чем на предыдущем.
[01:18:11.880 --> 01:18:25.940]  Норм? Ну вот, все. Значит, log n итерации, log n – глубина рекурсии. Наверное, слово
[01:18:25.940 --> 01:18:29.660]  «рекурсия» не очень хорошо, потому что это можно просто в цикле обернуть. Мне от
[01:18:29.660 --> 01:18:33.020]  рекурсии здесь надо просто многократность скорее. Поэтому можно
[01:18:33.020 --> 01:18:36.580]  говорить, что не рекурсивный запуск, а просто вот пока n хотя бы двойка, делаем
[01:18:36.580 --> 01:18:43.220]  вот это. Вот. И на каждом уровне, на каждой итерации, за линейное время, но я тоже
[01:18:43.220 --> 01:18:46.220]  сказал, нужно для каждой вышины найти минимальное ребро. Для этого просто
[01:18:46.220 --> 01:18:51.380]  перебираю все ребра и релаксирую минимум для обоих концов этого ребра.
[01:18:51.380 --> 01:18:56.460]  То есть еще пережить компоненты? Да-да, тоже справедливо. Надо сжать компоненты, но это DFS.
[01:18:56.740 --> 01:19:03.500]  Тоже за m. Ну, m плюс n. Да, m больше, чем n, как обычно.
[01:19:04.700 --> 01:19:10.260]  Вот. Ну, все тогда. Спасибо. До следующего раза.
