[00:00.000 --> 00:12.000]  Последнее, что мы доказали, была такая теорема о графике.
[00:12.000 --> 00:19.000]  Теорема о графике. Она нам говорила, что для любой частичной функции,
[00:19.000 --> 00:25.000]  ну можно считать из натуральных натуральный, хотя для пар, троек и прочего это также работает,
[00:25.000 --> 00:40.000]  F вычислимо тогда и только тогда, когда F как множество пар, то есть F перечислимо.
[00:40.000 --> 00:49.000]  Почему о графике? Ну мы воспринимаем F как множество пар, как график функций.
[00:50.000 --> 00:56.000]  Отсюда у нас были следствия, что образ и прообраз перечислимого множества
[00:56.000 --> 01:01.000]  под действием вычислимой функции является перечислимым.
[01:01.000 --> 01:15.000]  В частности, если F вычислимо, то ее область определения, ее область значений перечислима.
[01:15.000 --> 01:23.000]  Нашей задачей на самое ближайшее время является получение некоторых
[01:23.000 --> 01:30.000]  эквивалентных перечислимости свойств. Итак, давайте попробуем.
[01:30.000 --> 01:37.000]  Прежде всего, мы дадим такое определение. Ну пусть у нас есть какое-то множество,
[01:37.000 --> 01:44.000]  например, натуральных чисел, но как обычно на пары, тройки и прочее это все тоже распространяется.
[01:44.000 --> 01:58.000]  Мы говорим, что хи с чертой из n в, ну на самом деле в 1 подчеркнуто.
[01:58.000 --> 02:06.000]  Хи с чертой называется полухарактеристической, ну не один чертой, пусть будет два черта, это неважно,
[02:06.000 --> 02:22.000]  называется полухарактеристической, то есть характеристический, но полу, не полностью.
[02:22.000 --> 02:33.000]  Полухарактеристической функцией множества тогда и только тогда,
[02:33.000 --> 02:40.000]  когда для любого числа это хи у нас устроено следующим образом.
[02:40.000 --> 02:49.000]  Мы с вами вступаем в мир частичных функций. Помните, были такие, которые не везде определены.
[02:49.000 --> 03:02.000]  Когда это значение единица, если n попадает в а, и оно не определено, если n не попадает в а.
[03:02.000 --> 03:16.000]  Что означает этот знак, помним? Он применялся нами для частичных функций, означает он следующее, давайте напомним.
[03:16.000 --> 03:42.000]  Это означает, что или f от x и g от y не определены, либо оба не определены, либо оба определены, а значения равны.
[03:42.000 --> 03:54.000]  Я буду читать этот символ как совпадает.
[03:54.000 --> 04:05.000]  Это естественное обобщение понятия равенства значений для частичных функций, то есть два выражения, которые могут быть не определены,
[04:05.000 --> 04:15.000]  они совпадают, если они одновременно не определены, оба не определены, или оба определены, но значения равны.
[04:15.000 --> 04:25.000]  Например, я могу сказать, что один разделить на ноль совпадает с два разделить на ноль, правильно?
[04:25.000 --> 04:43.000]  Вот полухарактеристическая функция, как она себя ведет, она определенная равна единице на а, а вне а она не определена.
[04:43.000 --> 05:01.000]  Какой будет у полухарактеристической функции домен? Где она определена? В точности на а, это понятно? Ясно это?
[05:01.000 --> 05:13.000]  А теперь давайте посмотрим, какая связь с перечислимостью.
[05:13.000 --> 05:24.000]  Утверждение А перечислимо тогда и только тогда, когда полухарактеристическая функция вычислима.
[05:24.000 --> 05:30.000]  Помните, мы говорили, что разрешимость эквивалентной вычислимости характеристическая функция.
[05:30.000 --> 05:37.000]  Так вот, перечислимость эквивалентной вычислимости полухарактеристической функции.
[05:37.000 --> 05:45.000]  Ну, в одну сторону, почему, если перечислимо, то она вычислима? Как ее вычислить?
[05:45.000 --> 05:52.000]  Нам нужен какой-нибудь алгоритм для этой полухарактеристической функции.
[05:52.000 --> 05:57.000]  Давайте его, так сказать, условно напишем на таком псевдокоде.
[05:57.000 --> 06:06.000]  Вот нам дали n на вход. Нам надо посчитать значение полухарактеристической функции.
[06:06.000 --> 06:14.000]  Что мы делаем? Запускаем бесконечный цикл, и что делаем?
[06:15.000 --> 06:26.000]  Делаем шаг А красивого. Пусть А красивый перечисляет А.
[06:26.000 --> 06:32.000]  Помните, у нас был алгоритм-перечислитель?
[06:32.000 --> 06:39.000]  Ну, этот алгоритм может что-то вывести, правильно?
[06:39.000 --> 06:54.000]  Если А вывел n, вот наше входное значение, то, останов, возвращаем 1. Понятно?
[06:54.000 --> 06:59.000]  Почему такой алгоритм вычисляет полухарактеристическую функцию? Доказываем.
[06:59.000 --> 07:07.000]  Если n принадлежит ее домену, то есть А, мы дождемся появления n, вернем единицу.
[07:07.000 --> 07:15.000]  Если n не принадлежит ее домену, то такой алгоритм зацикливается.
[07:15.000 --> 07:20.000]  Как им должно быть по определению вычислимости? Понятно?
[07:20.000 --> 07:29.000]  В другую сторону более-менее очевидно из того, что мы доказали.
[07:29.000 --> 07:37.000]  Ведь если полухарактеристическая функция вычислима, то ее домен мы знаем.
[07:37.000 --> 07:46.000]  Мы знаем, что домен вычислимой функции всегда перечислим.
[07:46.000 --> 07:59.000]  Значит, если она вычислима, то ее домен, то есть А, перечислим.
[07:59.000 --> 08:05.000]  Каким образом перечислимость эквивалентна вычислимости полухарактеристической функции?
[08:05.000 --> 08:11.000]  Согласны? Сейчас мы дадим еще одну характеристику.
[08:11.000 --> 08:16.000]  Можно стереть определение полухарактеристической?
[08:16.000 --> 08:31.000]  Это функция, которой единица на множестве не определена в ней Иван.
[08:31.000 --> 08:48.000]  Утверждение два. Если А не пусто и перечислима, то существует вычислимая,
[08:48.000 --> 08:56.000]  я отдельно напишу специально, тотальная функция, то есть определенная на всех натуральных числах,
[08:56.000 --> 09:10.000]  такая, что А это просто range нашей функции, то есть f от нуля, f от единицы, f от двойки и так далее.
[09:10.000 --> 09:17.000]  Понятно? В каком смысле мы можем перечислить множество?
[09:17.000 --> 09:26.000]  Мы можем его перечислять в смысле алгоритма перечислителя, но есть и другой возможный смысл.
[09:26.000 --> 09:36.000]  Мы можем считать, что перечислимость означает, что есть такая функция, которая порождает наше множество.
[09:36.000 --> 09:48.000]  Вот считаем f0, f1, f2 каждое законеченное время, это будут все значения нашей функции и только они, правильно?
[09:48.000 --> 09:57.000]  Согласны? А если па было пустым, это было бы верно?
[09:57.000 --> 10:03.000]  Ну как range тотальной функции может быть пустым? Никак.
[10:03.000 --> 10:15.000]  Ну как это доказать? Нам надо по сути дела объяснить, как такую f посчитать, имея перечислитель.
[10:15.000 --> 10:27.000]  Ну смотрите, а не пусто, значит в этом а что-то есть, правильно? Существует какое-то такое а малое, которое принадлежит а.
[10:27.000 --> 10:45.000]  Но если оно принадлежит а, то перечислитель, как обычно считаем, что а красивое перечисляет а.
[10:45.000 --> 11:11.000]  Следовательно, существует какой-то шаг. Существует шаг k, такое что а, ну даже просто, существует число k, что а красивое выведет а малое на шаге k.
[11:11.000 --> 11:37.000]  Правильно? Ну это неправильно. А не пустое, значит перечислитель выведет хотя бы одно число, согласны?
[11:37.000 --> 11:49.000]  Правильно. Какое-то число будет выведено самым первым. По принципу наименьшего числа можно найти наименьший шаг, на котором будет что-то выведено.
[11:49.000 --> 12:17.000]  Тогда, значит, пускай наименьший шаг, когда что-то выведено самым первым.
[12:17.000 --> 12:45.000]  То есть мы хотим зафиксировать самый первый шаг, когда что-то выводится, и само это выводим в выведенное значение, согласны?
[12:45.000 --> 13:01.000]  Имеем право так сделать. А теперь давайте определим функцию f. Мы ее определим следующим образом. Неформально будет ясно, что она вычислима.
[13:01.000 --> 13:20.000]  Пусть f от нуля это наша а0, то значение, которое вывелось первым. А вот для любого n f от n плюс 1 это будет знаете что?
[13:20.000 --> 13:49.000]  Не, не максимум. Мы не будем сравнивать выведенные значения. Это будет последнее значение, последнее число, которое наш алгоритм перечислитель вывел за k плюс n плюс 1 шаг.
[13:50.000 --> 14:00.000]  То есть как это работает? Смотрите, нам надо, чтобы функция была тотальной, правильно? Если уже в нуле должно быть какое-то значение.
[14:00.000 --> 14:20.000]  Мы возьмем самое первое число, которое вывел наш перечислитель. А дальше мы что делаем? Мы для каждого следующего аргумента эмулируем вот столько шагов перечислителя, выполняем.
[14:20.000 --> 14:44.000]  Правильно? На некоторых шагах возникают новые числа, мы их выводим. А если на шаге k плюс n плюс 1 ничего не вывелось, что мы возвращаем? Мы возвращаем прошлое значение, понятно?
[14:44.000 --> 15:03.000]  То есть нам надо обеспечить тотальность этой функции. Как это работает? Зря стер утверждение 1.
[15:03.000 --> 15:18.000]  Тогда полухарактеристическая вычислима. Для мной предшедших полухарактеристическая это как характеристическая. На множестве она дает 1, а вот вне множества она не определена.
[15:18.000 --> 15:40.000]  Значит, ну что можно сказать о такой функции? Очевидно, что эв вычислима. Вот по сути дела алгоритм, как ее считать. Очевидно ли, что все, что она выводит, это элементы А?
[15:40.000 --> 15:52.000]  Очевидно, потому что все, что она выводит, напечатал перечислитель. Наиболее тонкий момент. Очевидно ли, что она выведет все те значения, которые перечислитель вывел?
[15:52.000 --> 16:06.000]  Потому что каждое значение будет напечатано впервые на каком-то шаге с номером большим или равным k, потому что k это первый шаг, когда что-то будет напечатано.
[16:06.000 --> 16:20.000]  Каждое значение в какой-то момент будет последним напечатано. Оно будет выведено. Как это происходит? Как мы функцию f определяем?
[16:20.000 --> 16:32.000]  Вот если у нас шаги, если у нас тут шаги, смотрите, вот как работает перечислитель. Он на некоторых шагах что-то выводит.
[16:32.000 --> 16:44.000]  Вот впервые он на шаге k выводит а0. Потом он еще что-то выводит, еще что-то, еще что-то, еще что-то. Согласны?
[16:44.000 --> 16:52.000]  Но мы не можем допускать пустых промежутков. Значит, как наша функция устроена?
[16:52.000 --> 17:02.000]  Во-первых, у нас f от 0 это то, что выведено на шаге k. А дальше мы ее вот так вот дополняем.
[17:13.000 --> 17:21.000]  Понятная идея? Делаем тотальный. Согласны? Вот как это работает.
[17:21.000 --> 17:39.000]  Итак, любое непустое перечислимое множество это область значений вычислимой функции. Согласны? Можно стирать? Вычислимый даже тотальный.
[17:39.000 --> 18:01.000]  И последняя. А перечислимо? Ну, а имеет какую-то размерность там k.
[18:01.000 --> 18:20.000]  Ну, для простоты можно считать, что, ну давайте, а состоит из наборов длины k. А перечислимо тогда и только тогда, когда существует b на единицу больше размерности.
[18:20.000 --> 18:48.000]  Такое, что b разрешимо. И наша a это что такое? Ну, это проекция b. Ну, как это обозначить? У нас была проекция на одну координату, но проекция на первый k координат вас не шокирует?
[18:50.000 --> 19:08.000]  Не понятно, что это такое? Как бы нам это обозначить? Ну, вот проекция на координаты с первой по кату. То есть это первый k координат пары с b, да?
[19:08.000 --> 19:30.000]  Что? Размерность n? В степени k плюс 1. На единицу больше. Давайте только k мы переименуем в другую букву лучше, t. k я использую для другой цели.
[19:30.000 --> 19:54.000]  Ну вот, то есть что это такое? Это все такие наборы длины k, что существует y такое, что набор x, y попадает в b. Понятно, что такое проекция? Ну, первые там t координат. Согласны?
[19:54.000 --> 20:04.000]  Итак, каждое перечислимое множество это проекция разрешимого множества на единицу больше размерности.
[20:04.000 --> 20:24.000]  Доказательства. Ну, в одну сторону на самом деле мы это проходили, мы понимаем, что если b разрешимо, то тогда b, конечно, перечислимо. Согласны?
[20:24.000 --> 20:48.000]  А проекция перечислимого любая, что на одну координату, что на несколько, она перечислима. Согласны? Поэтому справа налево, справа налево утверждение очевидное. Согласны?
[20:48.000 --> 21:00.000]  Ну почему? Ну если я могу перечислять набор длины t плюс один, я запускаю перечислялку, но печатаю только первый t координат. Это будет причисление а, правильно?
[21:00.000 --> 21:18.000]  А вот другую сторону чуть менее тривиально. Тут надо заняться таким делом, как подсчет шагов. Смотрите, значит нам дано, что а перечислимо.
[21:18.000 --> 21:32.000]  Что это значит? Значит, что существует алгоритма красивая, который перечисляет а. Согласны?
[21:32.000 --> 21:57.000]  А теперь я множество b определю следующим образом. Что такое b? b это все такие пары x, k. Размерность, ясное дело, на единицу больше размерности x.
[21:57.000 --> 22:13.000]  Это все такие пары, что а выводит x на шаге номер k.
[22:13.000 --> 22:41.000]  Смотрим, когда у нас x попадает ва? Ну тогда и только тогда, когда для некоторого k а выводит x на шаге k, правильно? Это из определений перечислителя.
[22:41.000 --> 22:55.000]  Но то есть и получается, что тогда и только тогда, когда существует такое k, что пара x, k попадает в наше b. Согласны?
[22:55.000 --> 23:17.000]  Итак, а действительно проекция нашего b. Только почему b разрешима? Тут такой неформальный аргумент, интересное свойство алгоритмов. Я эту мысль разовью сейчас.
[23:17.000 --> 23:32.000]  Почему b разрешима? Ну смотрите, но мы верим, что алгоритмы можно эмулировать, можно исполнять по шагам. Я могу как мне проверить принадлежит ли пара x, k множеству b?
[23:32.000 --> 23:45.000]  Надо запустить перечислитель на k шагов и посмотреть, вывел он x или не вывел. Понятно, что эту саму процедуру можно сделать за конечно много шагов.
[23:45.000 --> 23:59.000]  То есть, что такое разрешимость? Это перечислимость с подсказкой. Перечислимость – это кванторсуществование. Существует номер шага, на котором будет выведена.
[23:59.000 --> 24:13.000]  А разрешимость возникает, когда мы указываем номер этого шага. Если подсказка есть, мы можем k шагов прокрутить и за конечное время посмотреть, выводит или нет. Понятно?
[24:13.000 --> 24:23.000]  Итак, каждая перечислимая множество – это проекция разрешимого множества некоторого на единицу больше размерности.
[24:23.000 --> 24:39.000]  Так, а теперь давайте соберем все это вместе. Можно стирать?
[24:39.000 --> 24:54.000]  Теорема 4. Эквивалентное определение перечислимости.
[24:54.000 --> 25:04.000]  Для любого множества, ну неважно принадлежащего там n, то пусть будет n в степени t.
[25:04.000 --> 25:24.000]  Для любого а следующие свойства равносильны. Первое свойство – а перечислимо.
[25:24.000 --> 25:47.000]  Второе свойство – существует вычислимая функция f частичная. Такая, что наша a – это домен f.
[25:47.000 --> 26:04.000]  Вычислимые множества – это в точности области определения вычислимых функций. Область определения вычислимой функции всегда перечислима.
[26:04.000 --> 26:19.000]  И обратно, если а перечислима, то такая функция есть. Какую можно взять? Мы доказывали, что полухарактеристическая будет обладать таким свойством. Согласны?
[26:19.000 --> 26:41.000]  Так, это у нас утверждение 1. Что дальше? Третье свойство – если а перечислимо, то существует вычислимая, внимание, тотальная f.
[26:41.000 --> 27:04.000]  Давайте так. Тогда если а не пусто, то существует вычислимая тотальная f, такая, что а – это ее область значений. Ну это откуда? Это утверждение 2, правильно?
[27:11.000 --> 27:34.000]  Четвертое. Существует вычислимая, но не обязательно тотальная функция f, такая, что а – это ее рейндж. Ну почему? В одну сторону.
[27:34.000 --> 27:52.000]  Но из третьего следует четвертое. Если а не пустое, то в качестве вычислимой функции f можно взять вычислимую тотальную. Если а пустое, то она будет рейнджем какой вычислимой функции?
[27:52.000 --> 28:10.000]  Нигде неопределенной функции. Давайте сразу ее заведем. Вот функция дзета. Нигде неопределенная функция, нигде неопределенная функция.
[28:10.000 --> 28:29.000]  Этот дзета вычислимо. Согласны? Вы все писали алгоритм, вычисляющий дзету? Он принимает любой вход произвольный, зацикливается. Писали алгоритм для дзета?
[28:29.000 --> 28:39.000]  Нигде неопределенная функция, она имеется. Если а пустое, то она будет рейнджем нигде неопределенной. Понятно?
[28:39.000 --> 28:49.000]  И пятое свойство. Оно, как мы знаем, по утверждению 3, эквивалентной перечислимости.
[28:49.000 --> 29:02.000]  Кстати, а почему, если существует вычислимая функция такая, что а является ее рейнджем, то а перечислимо?
[29:02.000 --> 29:20.000]  Ну потому что рейндж вычислимой функции перечислим, правильно? То есть в эту сторону последствию ноль. Понятно?
[29:20.000 --> 29:31.000]  И пятое свойство эквивалентной перечислимости. Существует b на единицу больше размерности.
[29:31.000 --> 29:44.000]  Такое, что b разрешима, и наша a это проекция b, ну, например, на первый t координат.
[29:50.000 --> 30:00.000]  Понятно? Все переходы обоснованы, или есть сомнения какие-то? Какие сомнения?
[30:00.000 --> 30:11.000]  Итак, какие же свойства эквивалентной перечислимости? Перечислимое множество – это то же самое, что области определения вычислимых функций.
[30:11.000 --> 30:27.000]  Это то же самое, что области значения вычислимых функций. Не пустые перечислимые множества, это то же самое, что области значений вычислимых тотальных функций.
[30:27.000 --> 30:37.000]  Перечислимое множество это то же самое, что проекция разрешимых множеств на единицу большей размерности.
[30:37.000 --> 30:41.000]  Понятно? Вот такая теорема.
[30:41.000 --> 30:49.000]  А теперь пойдем далее, и сейчас мы введем некоторые новые понятия.
[30:49.000 --> 30:56.000]  Одно из них будет ухватывать ту идею, которую мы использовали здесь.
[30:56.000 --> 31:01.000]  Помните, когда мы исполняли алгоритм на к шагов?
[31:01.000 --> 31:04.000]  И не только здесь.
[31:12.000 --> 31:15.000]  Определение.
[31:15.000 --> 31:24.000]  Пусть АА какой-либо алгоритм. Ну, такое слегка неформальное определение.
[31:24.000 --> 31:29.000]  Мы можем ввести так называемый Т-предикат.
[31:29.000 --> 31:34.000]  Т от А. Что такое Т-предикат?
[31:34.000 --> 31:52.000]  Т-предикат говорит нам, ТХК говорит, что алгоритм А на входе Х останавливается за к шагов.
[31:56.000 --> 31:59.000]  Понятно?
[31:59.000 --> 32:07.000]  И другой вариант Т-предиката. Ну, можно считать, что Х это набор, можно считать, что это число, это неважно.
[32:07.000 --> 32:10.000]  И другой вариант Т-предиката.
[32:10.000 --> 32:18.000]  ХYК. Что это означает?
[32:18.000 --> 32:34.000]  Алгоритм А на входе Х останавливается за к шагов, включаем интуицию, причем здесь Y.
[32:34.000 --> 32:42.000]  Да, и выводит Y.
[32:42.000 --> 32:46.000]  Понятно, что за Т-предиката?
[32:46.000 --> 32:56.000]  Так вот, мы от нашей модели алгоритмов, от того, что такое алгоритм, от возможных уточнений этого понятия или из нашей интуиции,
[32:56.000 --> 33:07.000]  мы требуем такое свойство алгоритмов своего рода аксиому.
[33:07.000 --> 33:13.000]  Такие Т-предикаты разрешимы.
[33:13.000 --> 33:16.000]  Понятно, что значит разрешимы?
[33:16.000 --> 33:25.000]  За конечное число шагов можно по каждой паре или, соответственно, тройке узнать, верно для нее это или нет.
[33:25.000 --> 33:30.000]  Вот это свойство алгоритмов, на которые мы опираемся.
[33:30.000 --> 33:41.000]  Всегда можно за конечное число шагов проверить, правда ли, что алгоритм А на входе Х останавливается за к шагов, по входу ХК.
[33:41.000 --> 33:53.000]  Также можно по входу ХК узнать, правда ли, что он остановился за к шагов на входе Х и выдал Y.
[33:53.000 --> 33:56.000]  Понятно это?
[33:56.000 --> 34:01.000]  Вся наша наука основана на том, что эти свойства разрешимы.
[34:01.000 --> 34:04.000]  Ясен этот момент?
[34:04.000 --> 34:08.000]  Поехали дальше.
[34:08.000 --> 34:16.000]  На самом деле я еще одну теорему пропустил, к сожалению.
[34:16.000 --> 34:22.000]  Ее следовало бы рассказать в прошлый раз, но я просто забыл.
[34:22.000 --> 34:26.000]  Значит, это так называемая теорема Поста.
[34:26.000 --> 34:28.000]  Она очень проста.
[34:28.000 --> 34:31.000]  Тем не менее давайте ее отметим.
[34:31.000 --> 34:45.000]  А разрешима тогда и только тогда, когда А и его дополнение перечислимы.
[34:45.000 --> 34:49.000]  Оказывается, нам еще такая теорема нужна.
[34:49.000 --> 34:54.000]  Она больше относится к прошлой лекции, но в одну сторону.
[34:54.000 --> 35:02.000]  Если А разрешима, то, конечно, и А и его дополнение разрешимы.
[35:02.000 --> 35:06.000]  Помним, что дополнение разрешимого разрешима?
[35:06.000 --> 35:09.000]  Надо узнать принадлежит ли ХА и обратить ответ.
[35:09.000 --> 35:12.000]  Ноль в единице, единицу в ноль.
[35:12.000 --> 35:14.000]  Нормально?
[35:14.000 --> 35:22.000]  Так, ну а если они разрешимы, то каждое разрешимое множество оно также перечислимо.
[35:22.000 --> 35:24.000]  Справедливо?
[35:31.000 --> 35:34.000]  В другую сторону чуть труднее.
[35:34.000 --> 35:37.000]  Значит, как мы делаем?
[35:37.000 --> 35:41.000]  Нам нужно разрешитель придумать для А.
[35:43.000 --> 35:46.000]  Вот у нас есть какой-то вход N.
[35:46.000 --> 35:48.000]  Что мы будем делать?
[35:53.000 --> 35:57.000]  Поочередно делаем шаги.
[35:57.000 --> 36:01.000]  А красивого и чего?
[36:01.000 --> 36:03.000]  И А красивого штрих.
[36:03.000 --> 36:05.000]  Где что это такое?
[36:07.000 --> 36:12.000]  Пусть А красивое перечисляет А,
[36:12.000 --> 36:17.000]  и А красивое штрих перечисляет А с чертой.
[36:17.000 --> 36:19.000]  Правильно?
[36:22.000 --> 36:35.000]  Если А красивое вывел N, то что?
[36:35.000 --> 36:40.000]  Возвращаем единицу, значит мы попали в А.
[36:40.000 --> 36:42.000]  Не понятно?
[36:42.000 --> 36:44.000]  Нет, не понятно.
[36:46.000 --> 36:50.000]  Если А красивое со штрихом вывел N,
[36:51.000 --> 36:54.000]  то возвращаем ноль.
[36:55.000 --> 36:57.000]  Как это работает?
[36:57.000 --> 37:07.000]  Ну смотрите, ведь у нас любое N точно принадлежит либо А, либо А с чертой.
[37:07.000 --> 37:09.000]  Правильно?
[37:09.000 --> 37:14.000]  Значит, либо один, либо другой перечислитель его обязательно напечатает.
[37:15.000 --> 37:19.000]  Мы перечисляем множество и дополнение параллельно.
[37:19.000 --> 37:26.000]  Шаг в перечислении множества, шаг в перечислении дополнения.
[37:26.000 --> 37:33.000]  За конечное число шагов N появится в выводе того или другого перечислителя.
[37:33.000 --> 37:35.000]  Согласны?
[37:35.000 --> 37:40.000]  И нам остается только заметить в выводе какого из них оно появится.
[37:41.000 --> 37:44.000]  Понятно теорема Поста?
[37:44.000 --> 37:47.000]  Она показывает довольно простую мысль.
[37:47.000 --> 37:51.000]  Перечислимость это половинка разрешимости.
[37:51.000 --> 37:56.000]  Поэтому ее часто называют полуразрешимостью.
[37:56.000 --> 38:01.000]  И там же, как видите, живет полухарактеристическая функция.
[38:02.000 --> 38:07.000]  Разрешимость эквивалентна перечислимости множества и его дополнения.
[38:07.000 --> 38:09.000]  Понятно?
[38:12.000 --> 38:16.000]  А теперь давайте двинемся немножко дальше.
[38:17.000 --> 38:25.000]  Сейчас мы опять обратимся к нашей интуиции или, если угодно, к эксиумам каким-то,
[38:25.000 --> 38:31.000]  или, если угодно, к свойствам нашего конкретного языка программирования.
[38:31.000 --> 38:37.000]  Сейчас мы поговорим о такой вещи как универсальный алгоритм.
[38:37.000 --> 38:42.000]  Ну хорошо.
[38:42.000 --> 38:46.000]  Возьмем ваш любимый язык программирования.
[38:46.000 --> 38:48.000]  Какой?
[38:48.000 --> 38:50.000]  Плюсы. Но мне не нравится там компилятор.
[38:50.000 --> 38:52.000]  Пусть будет питон.
[38:52.000 --> 38:55.000]  Питон – интерпретируемый язык.
[38:55.000 --> 38:57.000]  Как он работает?
[38:57.000 --> 39:01.000]  Дело в том, что там есть интерпретатор.
[39:01.000 --> 39:03.000]  Правильно?
[39:03.000 --> 39:15.000]  Вы ему подаете на вход какую-то программу и, возможно, какие-то аргументы этой программы.
[39:15.000 --> 39:17.000]  Согласны?
[39:21.000 --> 39:30.000]  Обратите внимание, все алгоритмы, которые вы пишете на питоне, вы выполняете более или менее так.
[39:31.000 --> 39:41.000]  То есть, по сути дела, ваш код является аргументом, является входом.
[39:41.000 --> 39:43.000]  Для чего?
[39:43.000 --> 39:46.000]  Для некоторого универсального алгоритма.
[39:46.000 --> 40:01.000]  То есть, можно рассматривать вашу программу как аргумент другого алгоритма.
[40:01.000 --> 40:13.000]  Более того, мы верим, что любую программу, которую можно реализовать на питоне, можно таким образом выполнить.
[40:16.000 --> 40:22.000]  Мы верим, что каждую вычислимую функцию можно вычислить и на питоне.
[40:22.000 --> 40:26.000]  Это вариант того, что называется тезис Тьюринга.
[40:26.000 --> 40:34.000]  Любую вычислимую функцию можно вычислить конкретно фиксированной модели вычислений.
[40:36.000 --> 40:41.000]  Но вот тезис питона – любую вычислимую функцию можно вычислить на питоне.
[40:41.000 --> 40:44.000]  Доказать это нельзя.
[40:44.000 --> 40:46.880]  Потому что непонятно, что такое вычислимая функция.
[40:46.880 --> 40:54.400]  Если вы уточните это понятие, то возникнут теоремы, что один язык программирования эквивалентен другому.
[40:54.400 --> 40:58.880]  Например, все, что можно вычислить на Си, можно вычислить на Питоне, и наоборот.
[40:58.880 --> 41:07.680]  Все, что можно вычислить на машинах тюринга, можно вычислить там в безтипу, в лямбдоисчислении или еще какую-нибудь модель можно взять.
[41:07.680 --> 41:09.680]  Понятна идея?
[41:10.160 --> 41:19.680]  То есть, фактически, если понятие вычислимость и уточнять, оно превратится в вычислимость в каком-то конкретном языке программирования.
[41:19.680 --> 41:27.680]  Во всех наших рассуждениях мы язык не фиксировали, а рассуждали о нем довольно расплывчато.
[41:27.680 --> 41:37.680]  Тем не менее, языки, которые существуют на практике, наводят нас на мысль о том, что существует универсальный алгоритм.
[41:37.680 --> 41:45.680]  Где у нас, который по сути дела принимает два аргумента.
[41:45.680 --> 41:55.680]  Программу и вход этой самой программы.
[41:55.680 --> 41:59.680]  Ну и программу типа исполняет. Понятно?
[41:59.680 --> 42:05.680]  То есть, он делает то же самое, что делала бы программа.
[42:05.680 --> 42:15.680]  Вот эта вот команда, как мы понимаем, она эквивалентна такой.
[42:15.680 --> 42:21.680]  Этот алгоритм, по сути, делает то, что делает эта программа.
[42:21.680 --> 42:27.680]  На самом деле, вот эта штука реализована через это.
[42:27.680 --> 42:31.680]  Понятно вообще, о чем я вещаю? Вы же программисты.
[42:31.680 --> 42:33.680]  Так, хорошо.
[42:33.680 --> 42:37.680]  Теперь давайте внимательно посмотрим на эту программу.
[42:37.680 --> 42:39.680]  В случае питона, что это такое?
[42:45.680 --> 42:47.680]  Это конечный набор чего?
[42:47.680 --> 42:49.680]  Байтов.
[42:49.680 --> 42:53.680]  Это какое-то конечное слово, правильно?
[42:53.680 --> 42:57.680]  Конечное слово в конечном алфавите.
[42:57.680 --> 43:01.680]  Мы его можем закодировать натуральным числом.
[43:01.680 --> 43:03.680]  Согласны?
[43:03.680 --> 43:09.680]  Не каждая последовательность байтов является программой на питоне.
[43:09.680 --> 43:13.680]  Сколько корректных программ на питоне?
[43:13.680 --> 43:17.680]  Ровно счетно много, легко доказать.
[43:17.680 --> 43:23.680]  Не более чем счетные, можно построить не менее чем счетно корректных программ.
[43:23.680 --> 43:25.680]  Правильно?
[43:25.680 --> 43:27.680]  Вот.
[43:27.680 --> 43:33.680]  То есть по сути дела, можно программы это же действительно натуральными числами.
[43:33.680 --> 43:37.680]  Понятно это?
[43:39.680 --> 43:47.680]  И при этом мы надеемся, что каждая вычислимая функция вычисляется некоторой программой.
[43:47.680 --> 43:49.680]  Понятно?
[43:49.680 --> 43:55.680]  Все эти соображения подводит нас к следующему определению.
[44:05.680 --> 44:07.680]  Функция У.
[44:07.680 --> 44:13.680]  Это частичная функция двух натуральных аргументов.
[44:13.680 --> 44:19.680]  Это пока не алгоритм, а функция.
[44:19.680 --> 44:25.680]  Называется универсальной вычислимой функцией.
[44:25.680 --> 44:31.680]  Ну в классе функции одного натурального аргумента, но я не буду уточнять.
[44:31.680 --> 44:37.680]  Называется универсальной вычислимой функцией.
[44:37.680 --> 44:41.680]  Универсальной вычислимой функцией.
[44:41.680 --> 44:45.680]  Сокращенно УВФ.
[44:45.680 --> 44:49.680]  Я постоянно буду использовать это обозначение.
[44:49.680 --> 44:59.680]  Она называется универсальной вычислимой функцией тогда и только тогда, когда обладает следующими свойствами.
[44:59.680 --> 45:05.680]  Вот универсальная вычислимая функция не похожа на морскую свинку.
[45:05.680 --> 45:11.680]  Морская свинка не имеет отношения ни к свине, ни к морю.
[45:11.680 --> 45:17.680]  А вот универсальная вычислимая функция вычислима.
[45:19.680 --> 45:23.680]  И универсальна.
[45:23.680 --> 45:29.680]  Ну а что значит универсальна?
[45:29.680 --> 45:37.680]  Универсальна значит, что она реализует каждую вычислимую функцию одного аргумента.
[45:37.680 --> 45:41.680]  Давайте запомним это, поймем и запомним.
[45:41.680 --> 45:51.680]  Для любой вычислимой Ф, для любой вычислимой функции одного аргумента, существует что?
[45:51.680 --> 46:03.680]  Существует программа, но в нашем языке программирования у нас программы это сразу натуральные числа.
[46:03.680 --> 46:09.680]  Существует такая программа, что?
[46:09.680 --> 46:29.680]  Для любого х то, что функция у вычисляет на входе нх, совпадает с тем, что функция Ф вычислила бы на входе просто х.
[46:29.680 --> 46:41.680]  То есть каждую функцию можно, по сути дела, заменить на подстановку некоторого специального аргумента у.
[46:41.680 --> 46:47.680]  У умеет считать все вычислимые функции.
[46:47.680 --> 46:53.680]  Для каждой вычислимой функции можно дать соответствующий аргумент.
[46:53.680 --> 47:01.680]  Неформально это соответствует тому, что число n это программа для функции Ф.
[47:01.680 --> 47:08.680]  Язык программирования у универсален, но есть его, для него есть такая функция.
[47:08.680 --> 47:13.680]  Если для любого Ф существует n. Понятно?
[47:13.680 --> 47:22.680]  Ну мы же об этом говорили, но вы пропустили.
[47:22.680 --> 47:32.680]  Это, как мы это понимаем, вот если у нас есть два выражения, которые могут быть неопределены.
[47:32.680 --> 47:48.680]  Это означает две вещи. Оба неопределены или оба определены и равны.
[47:48.680 --> 47:58.680]  Например, один разделить на ноль совпадает с два разделить на ноль, то и другое неопределено. Понятно?
[47:58.680 --> 48:07.680]  Я использую это обобщение вместо равенства, потому что они могут быть и неопределены.
[48:07.680 --> 48:16.680]  Понятно это? Вот это вот n имеет специальное название.
[48:16.680 --> 48:36.680]  Н называется индексом, индексом или номером, или номером функции Ф относительно у.
[48:36.680 --> 48:46.680]  Содержательно же это программа для функции Ф, понимаемая как натуральное число. Понятно?
[48:46.680 --> 48:56.680]  Какой вопрос?
[48:56.680 --> 49:02.680]  Еще немного терминология.
[49:02.680 --> 49:10.680]  Пусть у нас В какая-нибудь функция двух аргументов.
[49:10.680 --> 49:29.680]  Для любого n определим функцию Вn. Это будет функция одного аргумента. Как она определяется?
[49:29.680 --> 49:35.680]  Она определяется вот таким вот уравнением.
[49:35.680 --> 49:52.680]  Вn от х понимается как В от n от х. То есть мы первый аргумент фиксируем. Вы не шокированы?
[49:52.680 --> 49:58.680]  У вас на мотоне такое было?
[49:58.680 --> 50:15.680]  Вn называется n-тым сечением, n-тым сечением В, ну по первому аргументу, по первому аргументу.
[50:15.680 --> 50:29.680]  Понятно, что такое n-тый сечение? Функция одного аргумента, когда мы значение фиксируем.
[50:29.680 --> 50:35.680]  Почему сечение? Ну вот у нас n-ки, вот у нас x-ы.
[50:35.680 --> 50:43.680]  Вот как бы график функции В, да, такая типа поверхность, может быть с дырками, потому что она не всюду определена.
[50:43.680 --> 50:51.680]  Ну вот если мы значение n зафиксируем равным чему-то, что у нас получится?
[50:51.680 --> 51:00.680]  Ну вот у нас получается такой, что мы этот торт разрезали. Вот тут вот.
[51:00.680 --> 51:08.680]  Параллельно оси в точке н-ноль, понятно? На срезе получилось сечение.
[51:08.680 --> 51:13.680]  Ясно это? Очень наглядное понятие.
[51:13.680 --> 51:22.680]  В терминах сечений вот это как будет выглядеть требование универсальности?
[51:22.680 --> 51:29.680]  Что функция n-тый сечение у равна функции f?
[51:29.680 --> 51:38.680]  То есть что такое универсальная функция, которая среди своих сечений содержит все вычислимые функции?
[51:38.680 --> 51:44.680]  Меньшего числа аргумента, в данном случае одного. Понятно?
[51:44.680 --> 51:50.680]  Обратите внимание, здесь стоит не совпадение, а равенство.
[51:50.680 --> 52:01.680]  Все помните, первый семестр две частичные функции равны тогда и только тогда, когда их значения совпадают во всех точках.
[52:01.680 --> 52:04.680]  Понятно это?
[52:04.680 --> 52:10.680]  Что мы утверждаем о универсальной вычислимой функции?
[52:10.680 --> 52:16.680]  Об универсальной вычислимой функции мы утверждаем то, что она есть.
[52:16.680 --> 52:20.680]  В конкретном языке программирования это теорема.
[52:20.680 --> 52:28.680]  Надо универсальный алгоритм построить, то есть написать на питоне интерпретатор питона.
[52:28.680 --> 52:32.680]  А что вы сомневаетесь в том, что это можно сделать?
[52:32.680 --> 52:39.680]  Очень даже, но компилятор c написан же на c и ничего.
[52:39.680 --> 52:44.680]  Написан ли реально используем интерпретатор питона на питоне, я сомневаюсь.
[52:44.680 --> 52:48.680]  В принципе это можно сделать.
[52:48.680 --> 52:56.680]  Итак, то свойство алгоритма, в котором мы будем пользоваться, такое.
[52:56.680 --> 53:08.680]  Существует хотя бы одна универсальная вычислимая функция у.
[53:08.680 --> 53:14.680]  Можно.
[53:14.680 --> 53:24.680]  И что?
[53:24.680 --> 53:28.680]  Но его можно с нуля написать.
[53:28.680 --> 53:36.680]  Итак, в нашей теории мы верим, что универсальная вычислимая функция существует.
[53:36.680 --> 53:42.680]  Этому нас учит практика, потому что функция, которая вычисляет программы питона,
[53:42.680 --> 53:46.680]  это более или менее есть универсальная универсальная функция.
[53:46.680 --> 53:55.680]  По модулю незначительных отличий, что на питоне не каждое натуральное число это программа.
[53:55.680 --> 53:57.680]  Ну, можно сказать и так.
[53:57.680 --> 54:01.680]  Это свойство алгоритмов, свойство модели.
[54:01.680 --> 54:03.680]  Но мы не можем сейчас это доказать.
[54:03.680 --> 54:07.680]  Для этого надо уточнить понятие алгоритма.
[54:07.680 --> 54:09.680]  Итак, какая существует?
[54:09.680 --> 54:17.680]  Давайте сразу ковать железо пока горячо и зафиксируем какой-нибудь алгоритм, который вычисляет эту у.
[54:17.680 --> 54:24.680]  Но если она вычислима, есть же вычисляющий алгоритм.
[54:24.680 --> 54:35.680]  Пусть у красивая, это некоторый алгоритм, вычисляющий у.
[54:35.680 --> 54:39.680]  Теперь мы введем t-предикаты.
[54:39.680 --> 54:50.680]  Там были t-предикаты для какого-то алгоритма, а сейчас мы введем t-предикаты для, по сути дела, этого у.
[54:50.680 --> 54:56.680]  Просто t от n от x от k.
[54:56.680 --> 54:58.680]  Что это такое?
[55:02.680 --> 55:08.680]  Ну, это t-предиката от u для входа n, x и k.
[55:08.680 --> 55:11.680]  Понятно, что имеется в виду?
[55:11.680 --> 55:23.680]  То есть это свойство, которое говорит, что у красивая останавливается за k шагов на входе n, x.
[55:23.680 --> 55:30.680]  И вот такая бяка разрешима, как и всякий t-предикат.
[55:30.680 --> 55:38.680]  Мы можем запустить универсальный алгоритм на входе n, x на k шагов и посмотреть, остановился он или нет.
[55:38.680 --> 55:40.680]  Понятно это?
[55:42.680 --> 55:48.680]  Аналогично t-штрих от n, x, y, k.
[55:48.680 --> 55:50.680]  Что это такое?
[55:50.680 --> 55:55.680]  Это t-предикат со штрихом для нашего у.
[55:55.680 --> 55:58.680]  То есть имеется в виду что?
[55:58.680 --> 56:16.680]  Что у красивая остановится за k шагов на входе n, x и выдаст y.
[56:16.680 --> 56:18.680]  Согласны?
[56:18.680 --> 56:26.680]  Оба свойства разрешим.
[56:26.680 --> 56:31.680]  Сейчас мы прямо не будем этим пользоваться, но давайте себя заметим.
[56:31.680 --> 56:33.680]  Понятно это?
[56:33.680 --> 56:39.680]  Мы зафиксировали uvf и связали с ней 2t-предиката.
[56:39.680 --> 56:45.680]  Даже зафиксировали не просто сам uvf, но и некий алгоритм ее вычисляющий.
[56:45.680 --> 56:47.680]  В принципе, их может быть много.
[56:47.680 --> 56:49.680]  Понятно?
[56:49.680 --> 56:51.680]  Вы не шокированы?
[56:51.680 --> 56:55.680]  Знаменитая проблема остановки.
[56:55.680 --> 57:01.680]  Сейчас мы явно построим пример неразрешимого множества.
[57:01.680 --> 57:09.680]  В прошлый раз мы говорили, что такое множество существует, потому что всего под множеством натурального ряда континум.
[57:09.680 --> 57:14.680]  А разрешимых множеств лишь счетно много, потому что счетно много алгоритмов.
[57:14.680 --> 57:20.680]  А сейчас мы приведем явный пример.
[57:20.680 --> 57:28.680]  На этой конструкции держатся многие-многие-многие другие.
[57:28.680 --> 57:31.680]  Определение.
[57:31.680 --> 57:35.680]  Вот здесь и далее u будет какая-то uvf.
[57:35.680 --> 57:37.680]  Какая неважна?
[57:37.680 --> 57:41.680]  Какая-то.
[57:41.680 --> 57:45.680]  Пусть u это uvf.
[57:48.680 --> 57:53.680]  Положим k, ну можно считать с индексом u.
[57:53.680 --> 57:56.680]  Иногда будем писать, иногда не будем.
[57:56.680 --> 58:00.680]  Что такое k с индексом u?
[58:00.680 --> 58:09.680]  Это просто все те и только те натуральные числа, что u от nn определена.
[58:09.680 --> 58:12.680]  Как вам такое?
[58:15.680 --> 58:18.680]  Ну индексу я не буду писать.
[58:21.680 --> 58:23.680]  k с индексом u.
[58:23.680 --> 58:34.680]  Аналогично, s это все такие пары натуральных чисел, что u от n от x определена.
[58:34.680 --> 58:37.680]  Батюшки, что это такое?
[58:37.680 --> 58:39.680]  Что такое s?
[58:41.680 --> 58:44.680]  Домен функции u.
[58:46.680 --> 58:48.680]  Согласны?
[58:48.680 --> 58:51.680]  Непонятно это?
[58:51.680 --> 58:58.680]  Все такие пары программа-аргумент, где программа останавливается на аргументе.
[59:02.680 --> 59:06.680]  Еще мы введем функцию d.
[59:07.680 --> 59:11.680]  Функция d задается таким уравнением.
[59:12.680 --> 59:15.680]  d от x это u от xx.
[59:15.680 --> 59:18.680]  Как вам такая функция?
[59:21.680 --> 59:30.680]  d называется диагональю uvf.
[59:31.680 --> 59:33.680]  Согласны?
[59:33.680 --> 59:36.680]  Слушайте, а что такое k?
[59:39.680 --> 59:43.680]  Это же домен функции d.
[59:43.680 --> 59:45.680]  Справедливо?
[59:46.680 --> 59:50.680]  Итак, с функцией u мы связали функцию d и два множества.
[59:50.680 --> 59:54.680]  k домен d и s домен u.
[59:54.680 --> 59:56.680]  Согласны?
[59:56.680 --> 59:59.680]  Вы не шокированы?
[01:00:00.680 --> 01:00:04.680]  Давайте сделаем наблюдение.
[01:00:20.680 --> 01:00:22.680]  Замечания.
[01:00:23.680 --> 01:00:28.680]  Так как у нас u вычислимая функция, правильно?
[01:00:30.680 --> 01:00:37.680]  Тогда s, который является ее доменом, какое множество?
[01:00:39.680 --> 01:00:41.680]  Перечислимо.
[01:00:41.680 --> 01:00:45.680]  Домен вычислимой функции перечислим. Согласны?
[01:00:46.680 --> 01:00:48.680]  Был такое?
[01:00:49.680 --> 01:00:55.680]  Так, вы согласны, что функция d является вычислимой?
[01:00:56.680 --> 01:01:00.680]  Ну, это видно из этого уравнения.
[01:01:01.680 --> 01:01:03.680]  Согласны?
[01:01:03.680 --> 01:01:08.680]  Ну, а если она вычислима, то ее домен k...
[01:01:12.680 --> 01:01:16.680]  ее домен k обязательно перечислим.
[01:01:16.680 --> 01:01:21.680]  Итак, множество k и s перечислимо. Согласны?
[01:01:21.680 --> 01:01:25.680]  Какая у нас была прошлая теорема? 5, что ли?
[01:01:25.680 --> 01:01:27.680]  Теорема Поста.
[01:01:33.680 --> 01:01:35.680]  Теорема 6.
[01:01:36.680 --> 01:01:43.680]  Неразрешимость проблемы самоприменимости.
[01:01:52.680 --> 01:01:56.680]  Множество k неразрешимо.
[01:02:04.680 --> 01:02:07.680]  Множество k неразрешимо.
[01:02:10.680 --> 01:02:13.680]  Заметьте, но перечислимо.
[01:02:16.680 --> 01:02:18.680]  Согласны?
[01:02:19.680 --> 01:02:22.680]  Вот перечислимо неразрешимое множество.
[01:02:22.680 --> 01:02:27.680]  Мы доказываем, что перечислимость отличается от разрешимости.
[01:02:27.680 --> 01:02:30.680]  Как мы рассуждаем от противного?
[01:02:31.680 --> 01:02:34.680]  Допустим, k все-таки разрешимо.
[01:02:37.680 --> 01:02:40.680]  Давайте рассмотрим некую функцию.
[01:02:41.680 --> 01:02:43.680]  Назовем ее f.
[01:02:44.680 --> 01:02:48.680]  Наша функция устроена следующим образом.
[01:02:49.680 --> 01:02:56.680]  Она возвращает единицу, если n не принадлежит k.
[01:02:58.680 --> 01:03:05.680]  И она не определена, если n принадлежит k. Что это такое?
[01:03:05.680 --> 01:03:13.680]  На самом деле это полухарактеристическая функция дополнения k.
[01:03:14.680 --> 01:03:16.680]  Согласны?
[01:03:18.680 --> 01:03:22.680]  Я утверждаю, что f вычислимо.
[01:03:23.680 --> 01:03:25.680]  Но почему?
[01:03:26.680 --> 01:03:31.680]  Ну, можно формально. Если k разрешимо, то дополнение k разрешимо.
[01:03:31.680 --> 01:03:35.680]  Если k разрешимо, значит дополнение k перечислимо,
[01:03:36.680 --> 01:03:39.680]  значит его полухарактеристически вычислимо.
[01:03:40.680 --> 01:03:42.680]  На пальцах.
[01:03:42.680 --> 01:03:45.680]  Ну как вычислить f? Нам дали на вход n.
[01:03:46.680 --> 01:03:51.680]  У нас по предположению k разрешимо. Правильно?
[01:03:52.680 --> 01:03:55.680]  Проверим n на принадлежность k.
[01:03:56.680 --> 01:03:59.680]  Если ответ нет, выдаем 1.
[01:03:59.680 --> 01:04:04.680]  Если ответ да, мы всегда можем искусственно зациклиться.
[01:04:05.680 --> 01:04:11.680]  Это понятно? Поднимите руку, кому ясно, что f вычислимо.
[01:04:12.680 --> 01:04:16.680]  Не всем. Кому не ясно, почему.
[01:04:18.680 --> 01:04:24.680]  Еще раз на пальцах. Как посчитать a, f от n?
[01:04:24.680 --> 01:04:26.680]  У нас k множество разрешимостей.
[01:04:27.680 --> 01:04:32.680]  Значит за конечное время можно алгоритмом любой n проверить на принадлежность k.
[01:04:33.680 --> 01:04:38.680]  Проверяем. Если ответ нет, выдаем единицу останов.
[01:04:39.680 --> 01:04:42.680]  Если ответ да, входим в бесконечный цикл wild true.
[01:04:43.680 --> 01:04:47.680]  Непонятно? Все равно непонятно?
[01:04:48.680 --> 01:04:53.680]  Еще один аргумент. Но что можно сделать?
[01:04:54.680 --> 01:04:57.680]  А ну нет, это не очень хорошо.
[01:04:58.680 --> 01:05:01.680]  Ладно, ну что, понятно?
[01:05:02.680 --> 01:05:11.680]  Но смотрите, раз эта функция вычислимая, а у универсальная, это же что означает?
[01:05:12.680 --> 01:05:21.680]  Значит существует такое число, ну допустим n 0 или давайте m.
[01:05:21.680 --> 01:05:30.680]  Существует такое число m, что наше f это mt, сечение u, правильно?
[01:05:32.680 --> 01:05:44.680]  Или другими словами, существует такое m, что для любого x, f от x совпадает su от m от x.
[01:05:45.680 --> 01:05:47.680]  Согласны?
[01:05:52.680 --> 01:05:57.680]  Но это для любого x верно. В частности...
[01:06:05.680 --> 01:06:11.680]  В частности мы можем посмотреть, что такое f от m. Что такое f от m?
[01:06:11.680 --> 01:06:13.680]  Вот f от m.
[01:06:18.680 --> 01:06:22.680]  Вот f от m, или что то же самое, d от m. Согласны?
[01:06:23.680 --> 01:06:27.680]  Вопрос, принадлежит ли m множеству k?
[01:06:28.680 --> 01:06:31.680]  Ну либо принадлежит, либо нет.
[01:06:32.680 --> 01:06:37.680]  Так, допустим m принадлежит множеству k.
[01:06:37.680 --> 01:06:46.680]  Тогда вот по этому определению f от m не определена. Согласны?
[01:06:48.680 --> 01:06:57.680]  Но f от m совпадает su от m от m. Следовательно, u от m от m не определена.
[01:06:58.680 --> 01:07:03.680]  Следовательно, m не принадлежит k.
[01:07:04.680 --> 01:07:10.680]  Противоречие. Значит, не может так быть, чтобы m принадлежало k.
[01:07:11.680 --> 01:07:14.680]  Значит, m не принадлежит k.
[01:07:15.680 --> 01:07:18.680]  Предположим, m не принадлежит k.
[01:07:19.680 --> 01:07:31.680]  Так, тогда опять же по определению у нас f от m равно единицей, в частности, определено. Согласны?
[01:07:33.680 --> 01:07:42.680]  Значит, что получается? Получается, что u от m от m тоже определено. Согласны?
[01:07:44.680 --> 01:07:51.680]  Получается, что m таки принадлежит k. Опять противоречие.
[01:07:53.680 --> 01:07:59.680]  То есть, m не может ни принадлежать ни не принадлежать k.
[01:08:00.680 --> 01:08:08.680]  Мы вывели противоречие, допустим, что k разрешимо. Значит, k неразрешимо. Понятно?
[01:08:09.680 --> 01:08:15.680]  То есть, что мы сделали? Мы запросили, принадлежит ли nk, и сделали наоборот.
[01:08:18.680 --> 01:08:27.680]  Принципиально здесь мы узнали, что n не принадлежит k за конечное время, выдали единицу. Понятно это?
[01:08:28.680 --> 01:08:37.680]  Итак, множество k является неразрешимым, но перечислимым.
[01:08:38.680 --> 01:08:46.680]  Следствие 7. Множество дополнения k неперечислимо.
[01:08:51.680 --> 01:08:55.680]  Это пример неперечислимого множества. Почему?
[01:08:56.680 --> 01:09:06.680]  Ну, потому что если оно перечислимо, то тогда у нас и k, и его дополнение перечислимо. Согласны?
[01:09:07.680 --> 01:09:09.680]  Мы же знаем, что k перечислимо.
[01:09:09.680 --> 01:09:27.680]  Значит, по теореме Поста, по теореме Поста тогда k было бы разрешимо. Что не так? Согласны?
[01:09:27.680 --> 01:09:41.680]  Согласны? Итак, дополнение k – это конкретный пример неперечислимого множества. Согласны?
[01:09:42.680 --> 01:09:53.680]  Понятно это? Следствие 8. Неразрешимость проблемы остановки.
[01:09:53.680 --> 01:10:01.680]  Что такое проблема остановки? Проблема остановки неформально звучит так.
[01:10:02.680 --> 01:10:10.680]  Надо по программе и по ее входу узнать, остановится ли эта программа на входе или нет.
[01:10:11.680 --> 01:10:21.680]  Придумать алгоритм, который за конечное число шагов бы это узнавал для любой пары, программа-вход, ключевые слова, для любой пары, один алгоритм.
[01:10:22.680 --> 01:10:29.680]  Такого алгоритма быть не может, что в нашей теории выражается как то, что s – неразрешимо.
[01:10:30.680 --> 01:10:40.680]  Нельзя по входу программа и ее вход алгоритмически проверить, остановится она или нет, то есть определена у от n от x или нет.
[01:10:42.680 --> 01:10:48.680]  Множество s неразрешимо. Ну как это доказать?
[01:10:49.680 --> 01:10:57.680]  Здесь мы впервые увидим так называемое сведение, тоже очень распространенная естественная идея.
[01:10:58.680 --> 01:11:07.680]  Смотрите, давайте посмотрим на определение множества k и сравним его с определением множества s.
[01:11:08.680 --> 01:11:15.680]  Вы согласны, что n принадлежит k тогда и только тогда, когда пара nn принадлежит s?
[01:11:15.680 --> 01:11:32.680]  Таким образом, что я вижу? Я вижу, что характеристическая функция k, она равна характеристической функции s на входе nn.
[01:11:32.680 --> 01:11:51.680]  Поэтому если х и s вычислимо, то тогда и х и k вычислимо, то есть тогда было бы k разрешимо. Что не так? Понятно?
[01:11:51.680 --> 01:12:00.680]  Ну если бы я умел любую пару проверять на принадлежность s, я мог бы любое число проверить на принадлежность k. Как?
[01:12:01.680 --> 01:12:14.680]  Взять входное число, изготовить из него пару nn и спросите, принадлежит ли она s. Понятно? Вы не шокированы?
[01:12:14.680 --> 01:12:26.680]  Нормально? Вот неразрешимость проблемы остановки. Ещё несколько замечаний.
[01:12:26.680 --> 01:12:43.680]  Оказывается, любая вычислимая функция хоть где-нибудь, но совпадает с диагональю. С d.
[01:12:43.680 --> 01:12:58.680]  Это принципиальный момент. Он позволяет доказывать невычислимость функций. Если какая-то функция всюду отличается от диагонали, то она точно невычислима.
[01:12:58.680 --> 01:13:17.680]  Давайте это докажем. Лемма 9 или какая там лемма? Лемма 9. Пусть у f, как обычно.
[01:13:17.680 --> 01:13:41.680]  Тогда если функция f, если функция вычислима, то обязательно существует такое натуральное число, где она совпадает с функцией d.
[01:13:41.680 --> 01:14:00.680]  Может быть они обе не определены, но всюду отличаться от d она не может. Доказательство этого крайне полезного утверждения буквально однострочное.
[01:14:00.680 --> 01:14:19.680]  Значит, как это сделать? Ну раз f вычислима, а у это uvf, то существует такое n, что для любого x у от n от x совпадает с f от x. Согласны?
[01:14:19.680 --> 01:14:39.680]  Согласны? Ну подставим сюда вместо x и n. Что получится? Значит, существует такое n, что у от n от n совпадает с f от n. Ну что такое у от n от n?
[01:14:39.680 --> 01:15:03.680]  Это d от n есть. Согласны? Итак, никакая вычислимая функция не может всюду отличаться от d.
[01:15:03.680 --> 01:15:18.680]  Давайте представим себе какую-нибудь функцию частичную. Вот она где-то определена, а где-то нет. Согласны? Но мы можем в принципе функцию продолжить.
[01:15:18.680 --> 01:15:33.680]  Это что значит? Это значит доопределить ее на некоторых точках, где она раньше не была определена. Не обязательно на всех. Понятно?
[01:15:33.680 --> 01:15:53.680]  В таком случае мы говорим, что функция g продолжает f. Это что значит? Ну просто график f включен в график g. Не более того. Понятная идея?
[01:16:03.680 --> 01:16:29.680]  Лемма 10. Функция d не имеет вычислимого тотального продолжения. Вот это вот может быть странное свойство, но оно естественное. Не имеет вычислимого тотального продолжения.
[01:16:29.680 --> 01:16:40.680]  Мало того, что она сама не везде определена. Ее даже нельзя так доопределить, чтобы получилась вычислимая функция.
[01:16:40.680 --> 01:16:57.680]  Сейчас, минутку. То есть, если g продолжает d и g тотально, то g не вычислима.
[01:16:57.680 --> 01:17:18.680]  Любая функция, которая продолжала бы d, вот представьте себе, что у нас вот есть d, она где-то определена, где-то нет. Предположим, мы ее доопределили на всех точках каким-то образом.
[01:17:18.680 --> 01:17:35.680]  При этом не может получиться вычислимая функция. Понятная идея? Доказательства очень простые.
[01:17:35.680 --> 01:17:58.680]  Допустим, что g действительно продолжает d, а g тотально. Выопределена во всех точках. Давайте рассмотрим такую функцию. Рассмотрим h. Она тоже будет тотальна. h задается следующим уравнением.
[01:17:58.680 --> 01:18:18.680]  h от x. Заметьте, я пишу равенство, потому что функции здесь всюду определенные. h от x это g от x плюс 1. Как вам такое?
[01:18:18.680 --> 01:18:30.680]  Рассмотрели функцию h? Я утверждаю, что функция h всюду отличается от d, а значит не вычислима. Доказательства.
[01:18:30.680 --> 01:18:50.680]  Вы согласны, что каждое число либо принадлежит домену d, либо нет? Если оно принадлежит домену d, чему у нас равно d от x?
[01:18:50.680 --> 01:19:11.680]  d от x равно g от x. Почему? Потому что g это продолжение d. Где d определена, они совпадают. Согласны? d равно g от x. Но g от x не может быть равно g от x плюс 1.
[01:19:11.680 --> 01:19:32.680]  Значит d от x и h от x различны. Они не совпадают. В точках, где d определена, они отличаются друг от друга. Согласны?
[01:19:32.680 --> 01:19:49.680]  А что будет, если x не принадлежит домену d? Но все довольно просто. d от x, ведь она будет не определена в таком случае.
[01:19:49.680 --> 01:20:06.680]  А h от x, чему бы она не была равна, но она же всюду определена, она будет определена. То есть они точно не совпадают.
[01:20:06.680 --> 01:20:25.680]  Что же мы видим? Мы видим, что для любого x h от x отличается от d от x. Отсюда следует, что h не вычислимо. Согласны?
[01:20:25.680 --> 01:20:39.680]  Но с другой стороны, если бы g была вычислима, то и h была бы вычислима. Если g вычислима, то тогда и h вычислима.
[01:20:39.680 --> 01:20:59.680]  Вывод. g не вычислима. Итак, функцию d нельзя даже определить таким образом, чтобы она сделалась тотальной, но сохранила вычислимость. Согласны?
[01:20:59.680 --> 01:21:11.680]  Ну и самое последнее. Вот прям самое последнее. Мы на семинаре это используем.
[01:21:11.680 --> 01:21:33.680]  Лемма 11. Существует вычислимая функция f, внимание, она из натуральных, но она принимает только два значения, 0 единица.
[01:21:33.680 --> 01:21:51.680]  Существует вычислимая функция f, принимающая только два значения, такая, что у f нет вычислимого тотального продолжения.
[01:21:51.680 --> 01:22:09.680]  Существует такая функция, которую нельзя продолжить до вычислимы тотальной, при том, что она принимает только два значения. Согласны?
[01:22:09.680 --> 01:22:29.680]  Сейчас мы ее построим, и все. И гулять пойдем. Она устроена следующим образом. Вот смотрите, если d от x определена и равна 0, мы вернем что?
[01:22:29.680 --> 01:22:53.680]  1 мы хотим отличаться от d. Если d от x определена и d от x не равна 0, мы вернем 0. Если d от x не определена, мы вернем неопр.
[01:22:53.680 --> 01:23:16.680]  Почему эта функция вычислема? Это очень просто понять, каким же образом. А вот каким f от x это 1 минус d от x.
[01:23:16.680 --> 01:23:32.680]  Ну смотрите, если d от x определена, ну только не 1, а там 1 минус 5. Давайте так, усеченное вычитание. Понятно, что такое усеченное вычитание?
[01:23:32.680 --> 01:23:53.680]  Ничего не понятно. Усеченное вычитание это максимум из нуля и разности. Ну, например, 5 минус 2 это 3, а 5 минус 6 это 0. Понятно?
[01:23:53.680 --> 01:24:09.680]  Ну то есть как оно работает? Если d от x это 0, мы возвращаем 1. Если это 1 и больше, мы возвращаем 0. А если d от x не определена, ну это выражение не определено.
[01:24:09.680 --> 01:24:25.680]  То есть функция вычислимая, согласна? Почему у нее нет вычислимого тотального продолжения? Ну если оно есть, то тогда оно всюду будет отличаться от d.
[01:24:25.680 --> 01:24:40.680]  Я так конспективно напишу, без подробностей. Если g это продолжение d и g тотально, то g всюду отличается от d.
[01:24:40.680 --> 01:25:00.680]  Следовательно, g не вычислимо. Ну почему она всюду отличается от d? Ну там, где d не определена, там g определена, потому что она тотально, значит, отличается от d.
[01:25:00.680 --> 01:25:15.680]  А там, где d определена, там g принимает то же значение, что и f. Ведь домен нашей функции f равен домену d, правильно?
[01:25:15.680 --> 01:25:34.680]  Она определена всюду, где d, но на домене она отличается от d. Она и на домене, и вне домена отличается от d, значит g отличается от d. Значит, она не вычислима. Понятно?
[01:25:34.680 --> 01:25:46.680]  Мы построили пример вычислимой функции, принимающей только значение 0,1, которую нельзя продолжить до тотальной вычислимой.
[01:25:46.680 --> 01:25:58.680]  Этот пример мы используем на семинаре для важной конструкции, являющейся усилением теоремы о том, что существует перечислимое неразрешимое множество.
[01:25:58.680 --> 01:26:06.680]  Теорема о неразрешимости, проблемы с самоприменимостью, ну или проблемы остановки, вопросы?
[01:26:06.680 --> 01:26:12.680]  Ну уже мысленно на следующей лекции. Я понимаю. Спасибо за внимание. До свидания.
