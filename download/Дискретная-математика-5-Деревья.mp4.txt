[00:00.000 --> 00:16.680]  ладно начнем смотрите какую часть определение я не успел дать это понятие простой цепи простого
[00:16.680 --> 00:43.200]  цикла простой цепью простой цепью называется маршрут маршрут помните определение маршрута
[00:43.200 --> 00:48.560]  это последовательность ребер вершина ребро вершина ребра вершина ребра помните да
[00:48.560 --> 01:05.360]  цепь маршрут я говорил это это цепь путь маршрут это на одной тоже там просто разные литературе
[01:05.360 --> 01:12.600]  немножко по-разному называются но это можно использовать как синонима вот кому как удобно
[01:12.600 --> 01:31.800]  маршрут цепь путь вот называется маршрут в котором все вершины ребра попарно различные вот так
[01:42.600 --> 01:57.120]  видимо только последнюю часть как раз лица и за и посмотрел потому что мне там нужно было
[01:57.120 --> 02:07.360]  высмотреть где я закончил вот ну и куда что понять что вписать в программу я как говорил я
[02:07.400 --> 02:12.880]  составляю ее прям по ходу прочел лекцию вписал то что прочел в программу ссылки
[02:12.880 --> 02:22.960]  себе сразу сделал чтобы в конце в конце этим не заниматься уже вот ну и простой цикл это вот что
[02:22.960 --> 02:49.960]  простым циклом циклом называется просто цикл цикл в котором все ребра попарно различные помните
[02:50.040 --> 02:57.560]  что такое цикл это замкнутая цепь да то есть цепь в котором первые последние вершины одинаковые
[02:57.560 --> 03:15.560]  вот все ребра попарно различные должны быть простой цикле и все вершины кроме первой
[03:15.560 --> 03:36.360]  последней тоже попарно различные все вершины кроме первой последний попарно различные
[03:45.560 --> 03:57.800]  ну что же вот две вещи еще которые нам понадобятся дальше это так в смысле вершины
[03:57.800 --> 04:07.320]  кроме последний первый последний попарно различный тоже вот понимаете в чем разница
[04:07.320 --> 04:18.800]  между простым циклом и циклом который простым не является понимаете нет ну цикл который простым
[04:18.800 --> 04:28.840]  не является может выглядеть например вот так ну то есть мы вот так двигаемся например
[04:28.840 --> 04:46.840]  вот цикл который простым не является например цикл простой если у него все вершины разные
[04:46.840 --> 05:05.760]  кроме первой последней и все ребра поняли да да хорошо значит смотрите теперь дерево деревья
[05:05.760 --> 05:21.280]  это такой подраздел которым в котором мы докажем того но смотрите давайте я вот буду
[05:21.280 --> 05:28.840]  подсказать подсказать подглядывать потому что у меня во первых определений дерево 6 я хочу
[05:28.840 --> 05:36.840]  эквивалентность их 6 доказать для этого их нужно выстроить в правильной последовательности значит
[05:36.840 --> 05:47.320]  смотреть теорема это как раз 6 эквалентных определений дерева
[05:47.320 --> 06:09.160]  то есть как раз сразу докажем эквивалентность их смотрите первое определение смотрите теорема
[06:09.160 --> 06:26.680]  для графа же который в ие эквивалентно следующие эквивалентные следующие утверждения
[06:39.160 --> 06:57.120]  первое утверждение заключается том что же связано циклический граф что такое циклический
[06:57.120 --> 07:04.720]  граф грамбес циклов вот ну или давайте связанный граф без простых циклов так вот напишем
[07:04.720 --> 07:21.440]  пожалуйста
[07:21.440 --> 07:28.840]  так
[07:28.840 --> 07:48.160]  сложный цикл в любом графе может быть пожалуйста вам приведу пример раз раз
[07:48.160 --> 07:52.000]  вот сложный цикл вам пожалуйста
[07:52.000 --> 08:09.840]  у всех графов есть сложные циклы пожалуйста вот если хоть одно ребро есть раз раз вот вам
[08:09.840 --> 08:23.520]  сложный цикл все это у любого графа есть такое ну нет циклов да вообще здесь связанный связанный
[08:23.520 --> 08:32.920]  кстати что такое связанный забыл я давал это определение вот надо дать сейчас напишу определение
[08:32.920 --> 08:35.640]  граф же
[08:35.640 --> 09:00.280]  называется связанным связанным если между любыми двумя вершинами любыми двумя
[09:02.920 --> 09:22.800]  вершинами есть есть путь их соединяющие
[09:22.800 --> 09:36.680]  вот ну то есть связанный граф это граф в котором между любыми двумя вершинами если они даже если
[09:36.680 --> 09:43.560]  они не бы если они соединили бром то это есть путь а если они не соединили бром то можно построить
[09:43.560 --> 09:50.520]  путь который соединяет поняли не связанный граф собственно распадается так называемые компоненты
[09:50.520 --> 10:00.640]  связанности пример не связанного графа вот такого например вот что-нибудь такое вот вот
[10:00.640 --> 10:05.320]  между вот этими компонентами связанности между вершинами этих компонент связанности пути нет
[10:05.320 --> 10:13.960]  вот в данном случае связанный граф написан поэтому ребра там точно есть потому что гроба
[10:13.960 --> 10:33.320]  1 раз уж что и одна вершинка подходит там ребер нету так где вот тут так ok это первая
[10:33.320 --> 10:42.920]  часть вторая часть второе утверждение эквивалентный связанный граф в котором же связанный граф
[10:42.920 --> 11:07.760]  в котором при удалении любого ребра который который при удалении любого ребра при удалении
[11:07.760 --> 11:26.920]  любого ребра любого ребра становится не становится не терять связанности
[11:26.920 --> 11:44.240]  это второго определение дерева третье определение дерева значит граф без циклов
[11:44.240 --> 11:56.120]  в котором при добавлении любого ребра появляется цикл же граф без простых циклов
[11:56.120 --> 12:10.480]  в котором при добавлении любого ребра
[12:26.120 --> 12:33.600]  появляется простой цикл
[12:33.600 --> 12:57.800]  так четвертая связанный граф же связанный граф
[12:57.800 --> 13:13.600]  в котором количество вершин количество ребер равно количество вершин минус один вот так вот
[13:13.600 --> 13:22.160]  без затей вот тут то есть наставил на самом деле красота в чем с чем с чем и элегантность
[13:22.160 --> 13:26.840]  подтверждение в том что на самом деле все это по порогу все все это все все тиши штук и
[13:26.840 --> 13:46.760]  эквивалентно между собой вот 5 ж граф в котором между любыми двумя вершинами
[13:46.760 --> 14:06.240]  двумя вершинами есть простой путь есть единственный простой путь вот так
[14:06.240 --> 14:25.160]  ну и шестое граф без циклов же граф без циклов
[14:25.160 --> 14:51.800]  в котором число вершин число ребер равно число вершин минус один вот 6 штук нет вот здесь
[14:52.800 --> 15:01.360]  здесь граф без циклов это разные вещи вот на самом деле крат видите в чем дело то есть можно одно из
[15:01.360 --> 15:07.760]  двух тут связанный граф без циклов дерево базовое определение это связанный граф без циклов да
[15:07.760 --> 15:14.920]  без простых циклов но вот тут на самом деле видите если у вас есть такое условие что мы знаем
[15:14.920 --> 15:20.760]  количество вер количество ребер то можно только одну из них оставить а второй будет следовать
[15:20.760 --> 15:40.480]  вот ну давайте доказывать ну я и так так так так мы 12 20 до 10 10 12 10 смотреть но вообще это по
[15:40.480 --> 15:47.280]  идее дать аремов всю лекцию потому что тут эквивалентности много переходов много не все
[15:47.280 --> 15:57.000]  не простые но сначала из 1 1 2 же связанный граф без простых циклов вот мы знаем же связанный
[15:57.000 --> 16:23.000]  граф без простых циклов нужно доказать что же связанный граф в котором при удалении любого
[16:23.000 --> 16:31.400]  ребра терять связанность но связанная связанность у нас так уже дана она известна а нужно доказать
[16:31.400 --> 16:36.360]  что если нет простых циклов то при удалении любого любого ребра мы потеряем связанность смотрите
[16:36.360 --> 16:43.440]  ну если уже при удалении ребра е
[16:43.440 --> 17:11.520]  которая ув связанность не потерялась не потерялась
[17:11.520 --> 17:26.280]  то смотрите что это значит это значит что между ув в частности вот было ребро я его удалили
[17:26.280 --> 17:33.600]  связанность не потерялась при этом значит между ув есть еще один какой-то простой
[17:33.600 --> 17:49.040]  если какой-то путь который соединяет так теперь возвращаем ув мы получаем цикл поняли
[17:49.040 --> 18:18.720]  ув ув соединены путем соединены уже путем возвращая и возвращая и мы получаем
[18:18.720 --> 18:36.320]  цикл вместе с этим путем получаем цикл получим цикл
[18:36.320 --> 18:45.880]  вот
[18:45.880 --> 18:55.600]  ну давайте 1 в 2 в 2 из 2 в 3
[19:06.320 --> 19:35.880]  2
[19:35.880 --> 19:51.120]  в 3 но смотрите мы знаем что же связанный граф в котором при удалении любого ребра пропадает
[19:51.120 --> 20:05.680]  связанность же связанный граф в котором при удалении любого ребра
[20:21.120 --> 20:39.160]  пропадает связанность тогда нужно доказать что же граф без простых циклов в котором при
[20:39.160 --> 20:55.360]  добавлении любого ребра появляется простой цикл ну да правильно правильно то есть вот что нам
[20:55.360 --> 21:04.360]  дано при удалении любого ребра пропадает связанность да я теперь пусть пусть сначала
[21:04.360 --> 21:17.520]  нужно доказать что граф не имеет простых циклов докажем сначала что же не имеет простых циклов
[21:17.520 --> 21:26.480]  что же тут два утверждения получается потому что ни одного из этих утверждений в трех нет ну
[21:26.920 --> 21:33.080]  в предпосылке не присутствует докажем что же не содержит простых циклов
[21:33.080 --> 21:51.960]  ну смотрите если если не так если не так то смотрите вот возьмем это самый простой цикл
[21:51.960 --> 22:03.760]  заметьте что при удалении любого ребра простого цикла связанность не теряется потому что у нас
[22:03.760 --> 22:12.720]  есть альтернативный маршрут между теми вершинами которые были связаны ребром раньше так то есть
[22:12.720 --> 22:20.440]  что мы потеряли мы мы мы потеряли у нас если есть если пути соединяли через вот это ребро то
[22:20.440 --> 22:27.760]  мы можем обойти по циклу это ребро правильно если между самими этими вершинами просто тоже опять
[22:27.760 --> 22:43.120]  же в другую сторону по циклу обойти то есть если не так и уже есть простой цикл то при удалении
[22:43.120 --> 22:55.600]  любого ребра простого цикла связанность не теряется любого ребра простого цикла
[22:55.600 --> 23:25.360]  не теряется противоречие с предпосылкой который говорит что при удалении любого
[23:25.360 --> 23:33.280]  ребра связанность как раз теряется вот то есть циклов простых тут нету значит граф ациклический
[23:33.280 --> 23:38.560]  в котором при добавлении любую давайте докажем что при добавлении любого ребра цикл как раз
[23:38.560 --> 23:53.320]  явится ну скажем смотрите пусть вершина ув в нашем графеже ребром не были соединены а мы это
[23:53.320 --> 24:05.200]  ребро туда добавили но смотрите а почему цикл появится до граф был связан значит
[24:05.200 --> 24:15.040]  ув были соединены ребром до ой и цепь путем путем ув были соединены ребром добавили еще
[24:15.040 --> 24:39.200]  одно ребро появился цикл все так как же связан то между ув между ув есть путь
[24:45.040 --> 25:02.480]  тогда добавление добавление ребра ув создаст цикл создаст цикл
[25:02.480 --> 25:09.680]  все
[25:09.680 --> 25:24.280]  давайте следующий переход это простые переходы были теперь давайте переход из 3 стройчик в
[25:24.280 --> 25:31.960]  пятерочку сделаем то есть граф без простых циклов в котором при добавлении более любого
[25:31.960 --> 25:38.000]  ребра простой цикл мы это знаем докажем что это что граф в котором между любыми двумя вершинами
[25:38.000 --> 25:44.960]  есть и доказом что граф и же граф который между двумя вершинами есть простой путь есть единственный
[25:44.960 --> 25:53.360]  простой путь вот смотрите наверное вот это стереть придется
[26:14.960 --> 26:30.800]  3 следует 5 5 5 ну немножко не подряд наверное нужно их было переставить чтобы так красиво что
[26:30.800 --> 26:39.160]  было но почему-то я я просто короче проворонил этот момент ну по идее их нужно перестать так
[26:39.160 --> 26:45.560]  чтобы совсем красиво было шел вот прям подряд шли но удобнее доказывать не подряд в данный если
[26:45.560 --> 27:07.480]  их так расположить в таком порядке вот что за что достаточно
[27:09.160 --> 27:26.360]  ну да он но да этот деревья это сайт в некотором смысле это минимум в прямом смысле это самый
[27:26.360 --> 27:35.080]  минимальный связный граф понимаете минимальный даже по количеству ребер вот меньше ребер
[27:35.080 --> 27:41.400]  связанном графе быть не может поэтому собственно он такой преудаление он сразу перестает быть
[27:41.400 --> 27:48.520]  связанного что-то как минимум количество ребер уменьшается вот при добавлении появляется цикл но
[27:48.520 --> 27:54.080]  это очень хороший очень интересный граф когда вы знаете что будет если вы дерево добавить ребро
[27:54.080 --> 28:03.480]  появится граф который называется унициклическим графом это граф в котором единственный простой цикл вот
[28:03.480 --> 28:11.480]  можно в принципе про него тоже очень интересная наука там кое кое что тоже можно доказать но у нас
[28:11.480 --> 28:18.560]  я не помню хватало ли времени это рассказ мне все когда-нибудь когда-либо сейчас посмотрим посмотрю
[28:18.560 --> 28:32.360]  можно любой использовать это же они же квалентны можно всем можно всем конечно да мне кажется этих
[28:32.360 --> 28:40.800]  этих у достаточно вот они в основном-то используется но вот иногда люди проверяют что же граф связи на
[28:40.800 --> 28:49.160]  количество ребер например нужное этого достаточно чтобы сказать что граф дерева вот потому что вот
[28:49.160 --> 28:55.160]  вот нас есть такая теорема то есть в целом то в таку в том или ином виде это наиболее часто
[28:55.160 --> 29:02.120]  используемое определение дерево это частый объект он везде появляется вот и вот но это наиболее
[29:02.120 --> 29:11.640]  часто используемые часто используемые способы проверки на то что граф дерева вот так вот 6
[29:11.640 --> 29:18.800]  различных тестов так сказать на дерево вот значит на третьей же граф без простых циклов
[29:18.800 --> 29:26.760]  без простых циклов
[29:26.760 --> 29:39.520]  в которых в котором
[29:39.520 --> 29:46.880]  при добавлении любого ребра
[29:46.880 --> 30:01.240]  появится цикл
[30:01.240 --> 30:17.880]  появляется смотрим что нужно доказать что граф же граф который между любыми двумя вершинами есть
[30:17.880 --> 30:27.400]  единственный путь проходящие но единственный путь проще ну смотрите это же просто смотрите
[30:27.400 --> 30:40.400]  вот есть вершина у пускай вершина в и пускай между вершинами между вершинами у и в два различных
[30:40.400 --> 30:50.280]  простых путей что у нас получится но не совсем простой там не какие-то ребра придется убрать то
[30:50.280 --> 30:56.680]  есть в принципе да они могут совпадать на некоторых участках но в целом цикл там пополучится
[30:56.680 --> 31:02.520]  потому что разные ребра там есть он просто понятие не с такой как может быть цикл нет
[31:02.520 --> 31:08.560]  не соединяющий у его непосредственно а посередине что-нибудь вот такое получится вот но цикл там
[31:08.560 --> 31:17.440]  расхождения будет и цикл из них создастся поймите понимаете да вот если между
[31:17.440 --> 31:29.160]  у и в есть два простых путей два различных простых путей
[31:29.160 --> 31:40.360]  то уже есть простой цикл
[31:47.440 --> 31:54.760]  ну собственно три валечия
[31:54.760 --> 32:04.000]  вот этой части вот эти переходы простые теперь
[32:04.000 --> 32:18.720]  нет вот тут ну если то что он существует
[32:18.720 --> 32:35.400]  что существует давайте так ну давайте если да вспомнил действительно правда право-право если
[32:35.400 --> 32:49.200]  же не связан не связан то добавление ребра между компонентами связанности не создаст не
[32:49.200 --> 32:56.640]  создаст цикла понимаете ну возьмите любые две компоненты связан соедините любые две вершины
[32:56.640 --> 33:06.840]  между разными компонентами связанности цикл не появится так то добавление ребра
[33:06.840 --> 33:23.440]  между любыми двумя вершинами между любыми двумя вершинами из разных компонент связанности
[33:23.440 --> 33:37.840]  из разных компонент связанности цикла не создаст
[33:53.440 --> 33:59.840]  тоже противоречия
[33:59.840 --> 34:11.360]  которая показывает вот здесь что гроза стоит путь а тот что он единственный вот так
[34:11.360 --> 34:25.800]  следующий переход из пятерочки давайте так из 1 в 2 2 в 3 3 в 5 из пятерочки надо на
[34:25.800 --> 34:34.920]  садили в любую из этих двух можно но давайте в четверочку перейдем тут уже вот это сложный
[34:34.920 --> 34:51.840]  переход давайте его докажем так значит то есть у нас мы знаем что в g это граф который между
[34:51.840 --> 34:59.120]  любыми двумя вершинами есть единственный путь простой путь нужно доказать что граф ну граф связан
[34:59.120 --> 35:08.040]  это понятно да уже уже повторяем повторим просто предыдущая в котором она вот про
[35:08.040 --> 35:18.800]  количество ребер утверждение давайте докажем сейчас смотрите пусть же а стоп а зачем связанность
[35:18.800 --> 35:29.360]  доказывать между любыми двумя есть путь все чего там доказывать да уже граф в котором
[35:29.360 --> 35:47.520]  между любыми двумя вершинами есть простой путь
[35:48.800 --> 36:13.440]  единственный простой вот как связанность понятно тогда потому что просто есть путь
[36:13.440 --> 36:19.120]  между любыми двумя как доказать что количество вершин количество реберов на количество вершин
[36:19.120 --> 36:34.320]  не сойдет давайте индукция обозначим обозначим количество вершин буковка и давайте докажем
[36:34.320 --> 36:36.720]  утверждение индукция пэн индукция пэн
[36:36.720 --> 36:52.600]  смотрите база выглядит следующим образом сейчас давайте я на следующей доске уже напишу
[36:52.600 --> 37:15.840]  да но там придет ну давайте проверим сейчас напишу я так для подстраховки базу проверял
[37:15.840 --> 37:31.160]  2 1 2 вершины деревья база значит n равно единицы тогда у нас граф так называемая ну не знаю не
[37:31.160 --> 37:38.560]  официальный термин райгородский называют это семечком ну одна вершинка семечка это дерево вот
[37:38.560 --> 37:47.440]  а значит количество ребер равно 0 количество вершин равно единицы поэтому количество
[37:47.440 --> 37:57.960]  ребер равно качество вершин минус 1 равно 2 связанный граф который между любыми двумя вершинами
[37:57.960 --> 38:05.320]  есть единственный простой путь в данном случае с двух вершин вот только такой да поэтому в нем
[38:05.320 --> 38:20.280]  одно ребро 2 вершины а ну наверное так для потра подстраховки все-таки делаем скорее
[38:20.280 --> 38:28.520]  просто продемонстрировать так скорее сюда да не надо переход но это тоже простое
[38:29.000 --> 38:42.440]  смотрите пусть утверждение доказано пусть что мы доказываем что количество ребер пусть утверждать
[38:42.440 --> 38:57.440]  пусть для любых же удовлетворяющих 5 и хочу переписывать это эту формулировку что между
[38:57.440 --> 39:05.040]  любыми двумя вершинами есть единственный простой путь давайте напишем удовлетворяющих 5 доказано
[39:05.040 --> 39:18.960]  с количеством вершин равным n доказано что количество ребер в них всегда равно
[39:18.960 --> 39:28.800]  количество вершин минус 1 докажем рассмотрим любой граф удовлетворяющих 5 рассмотрим любой
[39:28.800 --> 39:57.800]  граф же удовлетворяющий 5 в котором количество вершин равно n плюс 1 значит смотрите что это что
[39:57.800 --> 40:09.800]  я тогда хочу доказать я хочу доказать что любого что у такого граф тогда обязательно найдется то
[40:09.800 --> 40:20.560]  что называется лист что такой лист до вершины степени 1 листом называется вершина степени а
[40:20.560 --> 40:32.080]  вершина степени 2 называется проходной вершины стандартной терминологии вот нет узлы это это не
[40:32.080 --> 40:44.960]  что больше так ну давайте это не что другое значит смотрите узлы значит смотрите узбился сбили
[40:45.440 --> 41:01.640]  давайте докажем что уже есть докажем что уже есть вершина степени 1
[41:01.640 --> 41:16.000]  давайте мы предположим что все вершины степени 2 или больше пусть
[41:16.000 --> 41:33.960]  уже не вершин больше ли бы рано чем два тогда вот что мы с вами сможем сделать
[41:33.960 --> 41:43.120]  стартуем из любой вершины у нее степень хотя бы 2 поэтому мы можем из нее прийти
[41:43.240 --> 41:54.880]  какой-то следующую вершину до по ребро у нее степень 2 поэтому мы можем из нее уйти в
[41:54.880 --> 42:05.200]  какой-то следующий вершины причем не совпадающий с предыдущими правильно так у нее тоже степень 2
[42:05.200 --> 42:18.360]  единственный вопрос почему мы можем дальше уйти так чтобы вершины не повторялись у нас
[42:18.360 --> 42:25.680]  появится простой цикл и два простых пути между между некоторыми двумя вершинами у нас же вот
[42:25.680 --> 42:32.600]  есть только вот это утверждение что уже есть а что в жем между любыми двумя вершинами единственный
[42:32.600 --> 42:41.440]  простой путь смотрите если мы мы можем уйти но есть такой нюанс нюанс заключается в том что мы
[42:41.440 --> 42:49.960]  возможно сможем уйти скажем в у но если мы сможем в уйти то между у и у 2 есть два простых пути
[42:49.960 --> 42:58.440]  противоречия с условием правильно значит мы сможем уйти ту вершину в которой еще не было
[42:58.440 --> 43:05.760]  правильно из у 3 мы тоже сможем и она степень у нее степень хотя бы 2 значит сможем уйти и
[43:05.760 --> 43:12.280]  опять же из ту же вершину в другую вершину которая еще не было потому что иначе опять у нас
[43:12.280 --> 43:19.480]  получается два простых пути между некоторыми вершины так ребят эта процедура можно продолжать
[43:19.480 --> 43:30.200]  бесконечно что невозможно потому что граф конечна но это значит что мы повторимся мы в каком-то
[43:30.200 --> 43:38.240]  в какой-то момент обязаны будем вернуться в ту вершину в которые уже прошли а это значит что
[43:38.240 --> 43:49.080]  у нас не дерево поняли в речи них не буду это записывать давайте просто вот так я словами
[43:49.080 --> 44:14.560]  некоторые тут длинное просто рассуждение вот то мы сможем построить бесконечно простой цепь
[44:14.560 --> 44:29.360]  противоречия
[44:29.360 --> 44:48.560]  ну значит в деле в таком графе есть степершина степень который называть будем удаляем этот
[44:48.560 --> 45:01.600]  лист значит есть вершина степени 1 есть вершина степени вершина у степени 1
[45:01.600 --> 45:20.960]  в степени 1 смотреть удаляем этот лист тогда количество вершины количество ребер уменьшится
[45:20.960 --> 45:28.280]  на единичку и полученному графу мы можем уже предположение индукции применить который говорит
[45:28.280 --> 45:35.720]  что количество ребер в нем в графе в котором удален лист количество ребер равно вершин минус
[45:35.720 --> 45:45.320]  один потом добавляем обратно этот самый лист и это раньше сохранится поняли но на самом деле
[45:45.320 --> 45:51.640]  если не формально рассуждать то по сути вот именно так это и доказывается здесь произвольном
[45:52.200 --> 45:58.920]  как бы дерево строится из листов каждый раз к вот этому вот ребру добавляется лист потом еще
[45:58.920 --> 46:06.920]  раз лист еще раз лист еще раз лист и каждый раз вот это раз сохраняется поняли но это вот вот
[46:06.920 --> 46:12.440]  это слишком неформально не то чтобы на экзамен я приветствовал такое рассуждение понимаете
[46:12.440 --> 46:19.720]  в чем проблема с таким рассуждением почему она не индукция ребят иногда просто студенты пытаются
[46:19.720 --> 46:27.320]  строить до вот как что такое индукция вот пускай для н доказано рассмотрим любую конфигурации
[46:27.320 --> 46:35.560]  н плюс 1 используя предположение индукции докажем для нее это индукция а вот если мы берете предыдущие
[46:35.560 --> 46:44.760]  достраивайте это предыдущие до следующего да это достройка не индукция или не полная индукция
[46:44.760 --> 46:51.520]  потому что вы по идее если вы такую достройку делаете должны доказать что при помощи достройки
[46:51.520 --> 46:57.360]  вы получите все конфигурации следующего уровня понимаете для следующего значения параметра без
[46:57.360 --> 47:08.600]  этого это не работает мы просто студентов по одному курсу дрессировали заставляя решать задачи
[47:08.600 --> 47:15.840]  что-то и на индукцию вот чтобы чтобы студенты не путали достройку или не полную индукцию с
[47:15.840 --> 47:21.660]  настоящай индукции настоящей индукция предполагает рассмотрены любой конфигурация размер а versus 1 и
[47:21.660 --> 47:27.600]  сведение эта конфигурация к размеруを но не наоборот если вы рассматриваете любую конфигурация
[47:27.600 --> 47:33.920]  размера нэ достраивайте ее до конфигурации размеров плюс один это вот тогда еще надо доказывать
[47:33.920 --> 47:39.640]  что вы там всю, во все раз все конфигурации размера n плюс 1 получите еще в добавок.
[47:39.640 --> 48:00.560]  Вот. А что еще раз? Узел это сейчас. Я не помню в какой теории это появляется,
[48:00.560 --> 48:07.400]  это терминология, но это просто вот в том, в той части науки, которую мы будем изучать,
[48:07.400 --> 48:13.800]  там термин такой не используется. Это вот какая-то прикладной термин, что ли. В той литературе,
[48:13.800 --> 48:22.800]  которую я читал по графам, нет термина узел вообще. Я помню, он появлялся вот в той самой книжке,
[48:22.800 --> 48:30.400]  упомянутой Еблонского, где изучалась информатика, часто и чаще информатические приложения в
[48:30.400 --> 48:38.400]  информатике. Там любят именно такие термины, но информатики это используют как синоним вершины,
[48:38.400 --> 48:51.400]  по идее. Просто им вот нравится такое слово, я не знаю. Если так разобраться, вот книжка Еблонского,
[48:51.400 --> 48:58.720]  который вы выложил, можете посмотреть там дальше, что он там пишет, о чем он там пишет. Он пишет про
[48:59.400 --> 49:05.960]  теоретическую информатику, то, что называется сейчас в западном мире компьютерсайенс. Не знаю,
[49:05.960 --> 49:12.160]  как нормально перевести сей термин, поэтому чаще всего говорят просто англоязычный термин. Наука
[49:12.160 --> 49:18.440]  о компьютерах я не знаю, хотя там чаще всего объект, главное изучение от алгоритмы. И там вот
[49:18.440 --> 49:24.040]  эта вот терминология как раз и развивается. Им приятнее почему-то так называть.
[49:48.440 --> 50:02.640]  Так, ну хорошо, давайте, как я здесь запишу. Удаляя вершину В из графа G
[50:02.640 --> 50:14.960]  и применяя к полученному графу предположение индукции,
[50:14.960 --> 50:29.840]  полученному графу предположение индукции,
[50:29.840 --> 50:49.760]  получаем, что количество ребер Е штрих равно количество ребер вершин В штрих,
[50:49.760 --> 51:01.040]  но это граф, который получился после удаления. Уже штрих это Е штрих В штрих граф, получившийся
[51:01.040 --> 51:03.400]  после удаления листа.
[51:03.400 --> 51:29.040]  Возвращаем лист, возвращаем В.
[51:29.040 --> 51:48.000]  Получим, получим. Количество ребер равно количество вершин минус один. Переход доказан.
[51:48.000 --> 52:09.760]  Поняли, да? Ребят, хорошо. Так, сейчас посмотрю. Мы доказывали переход из 5 в 4. Теперь из 4 в 6. Я напомню,
[52:09.760 --> 52:23.600]  что там я раз мы стерли все эти формулировки. То есть у нас дано G связанный граф, в котором
[52:23.600 --> 52:36.360]  количество ребер равно количество вершин минус один, а это четверочка, а шестерочка G это
[52:36.360 --> 52:58.000]  ациклический граф, граф без простых циклов, в котором количество ребер равно количество вершин
[52:58.000 --> 53:04.160]  минус один. Ну то есть про количество ребер мы доказывать не можем, не нужно нам ничего доказывать,
[53:04.160 --> 53:15.160]  правильно? Оно повторяется, но нужно вывести, что и связанности, и вот этого утверждения следует,
[53:15.160 --> 53:34.360]  что нет простых циклов. Как это сделать? Ну можно так в принципе, но вообще давайте более формально
[53:34.360 --> 53:51.880]  и опять по индукции. Давайте докажем. Индукция PN, пусть N это количество вершин, индукция PN
[53:51.880 --> 54:06.840]  опять база. То есть в чем утверждение, какое утверждение мы по индукции доказываем? То,
[54:06.840 --> 54:11.880]  что в любом графе, который связан, в котором количество ребер равно количество вершин минус
[54:11.880 --> 54:22.920]  один, нет простых циклов. Смотрите, ну если N равно один, то у нас количество ребер равно
[54:22.920 --> 54:35.080]  количество вершин минус один, да и только один граф вот такой, да, он связан. Вот N, ой, простите,
[54:35.080 --> 54:54.960]  господи, связан, без простых циклов. Вот N равно два графа, в котором количество вершин,
[54:54.960 --> 55:01.800]  количество ребер равно количество вершин минус один и связан, он один, он вот такой, тоже без
[55:01.800 --> 55:15.000]  простых циклов. Итак, на самом деле чисто для подстраховки, на самом деле лишь это не нужно.
[55:15.000 --> 55:22.920]  Давайте для N равно трём проверим. Какой граф, связанный, в котором количество ребер равно
[55:22.920 --> 55:29.360]  количество вершин минус один? Количество вершин три, ребер соответственно два. Связанный граф,
[55:29.360 --> 55:40.800]  в котором два ребра. Какой граф? Цепочка. Он тоже без простых циклов. Он единственный такой, да.
[55:40.800 --> 55:54.240]  Давайте переход доказывать.
[56:10.800 --> 56:25.600]  Пусть для любого графа,
[56:25.600 --> 56:38.520]  для любого связанного графа,
[56:38.520 --> 56:57.320]  с которым количество ребер равно количество вершин минус один, доказывает и такого,
[56:57.320 --> 57:11.560]  что количество вершин равное, значит доказано, что он не содержит простых циклов.
[57:27.320 --> 57:38.400]  Давайте смотреть. Рассмотрим любой связанный граф.
[57:38.400 --> 57:58.520]  Ж такое, что количество вершин равно N плюс один, а количество ребер равно N.
[57:58.520 --> 58:13.000]  Давайте докажем, что в нём нет простых циклов. Что нужно сделать? Нужно сделать,
[58:13.000 --> 58:23.000]  доказать, что в таком графе с такими параметрами обязательно есть лист. Как это доказать?
[58:23.000 --> 58:31.360]  Вот здесь мы в рассуждении использовали некоторые другие данные. У нас данные,
[58:31.360 --> 58:37.080]  предпосылка другая была. Это рассуждение, к сожалению, здесь не работает. Нам дано только,
[58:37.080 --> 58:42.920]  лишь он связан, что количество вершин известны, количество ребер известны. Как доказать,
[58:42.920 --> 59:08.720]  что тут есть лист? Если для любой вершины В из В большой, степень её больше либо равна двух,
[59:08.720 --> 59:31.680]  то смотрите, сумма степеней вершин больше либо равна чем два N плюс один, правильно?
[59:31.800 --> 59:43.920]  Но по теореме рукопожатия это удвоенное количество ребер. То есть степень вершин
[59:43.920 --> 59:50.280]  должна быть равна двоим. Сумма степеней вершин должна быть равна двоим по теореме рукопожатия.
[59:50.280 --> 01:00:17.960]  Ну, противоречие. Значит, тогда существует В такой, что степень В равна единице. Ну,
[01:00:18.000 --> 01:00:34.160]  тогда мы её удаляем. Удаляем В. Ну, естественно, вместе с ребром, который из неё исходит. Тогда
[01:00:34.160 --> 01:01:03.400]  в получившемся графе же штрих, который во штрихе штрих, количество вершин равна N,
[01:01:03.400 --> 01:01:14.160]  а количество ребер равна N минус один. По предположению индукции там нет простых циклов.
[01:01:14.160 --> 01:01:25.000]  Так, ребят, возвращаем лист, но простой цикл не появляется. Поняли? По предположению индукции.
[01:01:33.400 --> 01:02:00.040]  Уже штрих. Нет простых циклов. Добавление листа не создаёт простых циклов. Не добавит
[01:02:00.040 --> 01:02:29.720]  простых циклов. Ну что ж,
[01:02:29.720 --> 01:02:41.400]  смотрите. У нас 6 утверждений было. Какие мы переходы с вами обосновали? 1, 2, 2, 3, 3, 5, 5,
[01:02:41.400 --> 01:02:57.520]  4, 4, 6. Остался переход 6, 1, чтобы почку замкнули. 6, 1. Давайте замкнём. Что нам нужно? Что из чего и
[01:02:57.520 --> 01:03:27.240]  что нужно вывести? Да. Значит, g без простых циклов. 6, g без простых циклов и с количеством
[01:03:27.240 --> 01:03:46.280]  ребер равным количеству вершин минус один. Один это g без простых циклов связанный. Да,
[01:03:46.280 --> 01:03:54.520]  нужно обосновать. Можно показать, что из вот этих посылок, что число без простых циклов и
[01:03:54.520 --> 01:04:02.400]  количества ребер это количество вершин минус один. В нём нет простых циклов, что нужно обосновать,
[01:04:02.400 --> 01:04:12.400]  что из этого следует что же связь. Ну давайте. Как доказать, ребята? Как в прошлый раз. Тут по
[01:04:12.400 --> 01:04:35.320]  сути повторение, только с небольшой модификацией. Ещё раз. Не выполняется,
[01:04:35.320 --> 01:04:53.640]  что количество ребер. Но это в принципе можно, кстати. Только там счёт какой-то нужен всё-таки.
[01:04:53.640 --> 01:05:01.240]  Количество считать количество ребер в лесу, так называемый, граф, просто граф без связанности,
[01:05:01.240 --> 01:05:09.680]  называется лесом. Количество ребер в лесе можно посчитать. Оно зависит от количества компонент
[01:05:09.680 --> 01:05:18.200]  связанности. В принципе тут легко доказывается также. То есть индукция по количеству вершин,
[01:05:18.200 --> 01:05:27.360]  база n равно единиц непосредственно проверяем, что у нас тут вот такие графы. Пожалуйста,
[01:05:27.360 --> 01:05:39.280]  они все связаны. Переход. Вот у нас эти данные имеются. И мы знаем, что количество ребер равно
[01:05:39.280 --> 01:05:44.160]  количество вершин минус один. Значит есть вершина степени один. Мы просто повторяем рассуждение
[01:05:44.160 --> 01:05:54.680]  вот здесь. Вот здесь вот это рассуждение. Что лист есть. Удаляем лист. Из предположений индукции
[01:05:54.680 --> 01:06:00.640]  следует, что без листа получившийся граф связан. Добавляем лист, он остаётся связанным. Всё.
[01:06:00.640 --> 01:06:14.200]  Поняли, ребята? Ух ты. Ну вот. Видите? Шесть вот этих определений. Они все эквивалентные. Вот такая
[01:06:14.200 --> 01:06:31.120]  теория. Теперь давайте считать деревья. То, что я сегодня успею рассказать, это формулировки по
[01:06:31.120 --> 01:06:41.880]  сути. Доказательства все будут уже на следующей неделе. Это тоже я всё обосную. Это вот эта штука,
[01:06:42.040 --> 01:06:51.080]  которая в литературе почти не доказывается. И поэтому мне просто как челлендж захотелось
[01:06:51.080 --> 01:07:01.000]  это взять и доказать. Потому что, ну что это такое? Это безобразие. И вторую вещь,
[01:07:01.000 --> 01:07:05.080]  которую я сейчас буду рассказывать про кодирование приухера и про подсчет количества
[01:07:05.080 --> 01:07:14.160]  деревьев. Это тоже вещи, которые формулируются, не доказываются. А там, ну вот здесь, сейчас,
[01:07:14.160 --> 01:07:19.200]  когда второй раз это рассказываю, это все переходы, доказательства, мне это не кажется
[01:07:19.200 --> 01:07:25.720]  уже сложным. А в той там теориям такие довольно существенные, нужно сказать, по сложности. Вот.
[01:07:25.720 --> 01:07:37.480]  И догадаться до них довольно трудно. Ну что ж, подсчет деревьев. Количество деревьев.
[01:07:37.480 --> 01:07:58.680]  Смотрите. В данном случае лучше нужно определиться с терминологией. Смотрите.
[01:07:58.680 --> 01:08:11.640]  Фух. Есть термин помеченное дерево. Я вообще лучше, наверное, его сейчас не использовать. Потому
[01:08:11.640 --> 01:08:18.720]  что на самом деле помеченное дерево. Что такое помеченное дерево? Это, грубо говоря, если не
[01:08:18.720 --> 01:08:30.960]  формально, то это дерево, в котором вершины помечены цифрами. Ну так. Цифрами. Цифрами.
[01:08:30.960 --> 01:08:38.800]  Помечены цифрами. Причем, смотрите, деревья считаются различными, если они различны. Ну,
[01:08:38.800 --> 01:08:47.280]  смотрите. Формально это что такое? Это граф, в котором множество вершин. Это 1, 2, 3, 4. Так.
[01:08:47.280 --> 01:08:56.840]  А множество ребер. В данном случае это пара 1, 2, 2, 3, 2, 4. Да. А вот у такого дерева,
[01:08:56.840 --> 01:09:04.120]  например, список ребер тот же самый, список вершин тот же самый. Значит, они как теоретика,
[01:09:04.120 --> 01:09:10.800]  как просто множественный объект. Они совпадают. То есть это одинаковый граф. Да, ребят? То есть
[01:09:10.800 --> 01:09:16.520]  вот это дерево такое же, как такое. То есть они совпадают просто как графы. А вот такое дерево
[01:09:16.520 --> 01:09:31.560]  уже не совпадает с вот этим. Оно как граф различается. Правильно? Ну вот. При этом эти деревья
[01:09:31.560 --> 01:09:41.680]  изоморфны, если вы можете понять. Правильно, ребят? Изоморфизм, например, вот такой. Вот такой
[01:09:41.680 --> 01:09:50.000]  изоморфизм. Переводят одно дерево в другое. Это разные деревья, но они изоморфны. Вот.
[01:09:50.000 --> 01:10:03.200]  Кодирую. Вот то, что я сейчас вам напишу. Давайте. Это так называемая формула Келли. Теория Маккелли.
[01:10:03.280 --> 01:10:17.480]  Вот. Она считает количество деревьев. Количество деревьев без учёта изоморфизма. То есть изоморфные,
[01:10:17.480 --> 01:10:26.160]  но различные деревья считаются разными. Понимаете, да? Почему я так обращаю ваше внимание на это?
[01:10:26.160 --> 01:10:32.760]  Потому что есть разные способы подсчёта количества деревьев. И вот другие методы подсчёта.
[01:10:32.760 --> 01:10:41.080]  Дают совершенно другие цифры, но они считают на самом деле количество деревьев с учётом того,
[01:10:41.080 --> 01:10:47.480]  что изоморфные деревья считаются одинаковыми. То есть склеивается все изоморфные деревья в один
[01:10:47.480 --> 01:10:54.120]  класс эквалентности и считается количество получившихся классов эквалентности. Неформально
[01:10:54.120 --> 01:11:01.760]  делается что? Стираются вот эти пометки, получаются просто дерево, и вот количество различных вот
[01:11:01.760 --> 01:11:09.560]  таких деревьев считается. Это сложнее, на порядок сложнее, чем посчитать с учётом пометок. Понимаете,
[01:11:09.560 --> 01:11:21.840]  да? Ну давайте. С учётом пометок подсчёт есть, всё это считается. Получается прям конкретная формула
[01:11:21.840 --> 01:11:29.800]  для количества графов с учётом изоморфизмов. То есть когда графы изоморфные считаются одинаковыми,
[01:11:29.960 --> 01:11:36.880]  нет точного ответа. Там есть асимпточки, там есть оценки верхние и нижние, но прям
[01:11:36.880 --> 01:11:56.680]  замкнутой красивой формулы нету. Вот так. Чарема Келли.
[01:11:56.680 --> 01:12:12.080]  Так, число деревьев, число попарно различных деревьев
[01:12:12.080 --> 01:12:37.960]  на множестве вершин. 1, 2 и так далее. Просто видите, обращаю внимание, попарно различных,
[01:12:37.960 --> 01:12:45.480]  а во-вторых, в других формулировках, может быть, мы почитаем, оценим количество деревьев с учётом
[01:12:45.480 --> 01:12:54.280]  изоморфизма. То есть когда мы считаем изоморфные деревья одинаковыми, там будут несколько другие
[01:12:54.280 --> 01:13:12.560]  цифры. Не столько деревьев будет равно. Н в степени минус 2. Вот. Ладно, специально прям здесь подпишу.
[01:13:12.560 --> 01:13:18.320]  Изоморфные деревья считаются разными.
[01:13:42.560 --> 01:14:04.160]  Вот. Как доказывается чарема Келли. 10 минут, да? Или сколько у нас осталось? Для этого нужно
[01:14:04.160 --> 01:14:33.360]  описать кодирование прюфера. Кодирование заключается вот в чем. Пускай у нас есть
[01:14:33.360 --> 01:14:44.760]  дерево, в котором на вершинах из множества 1 и так далее. В этом дереве, как мы доказали раньше,
[01:14:44.760 --> 01:14:59.440]  имеется лист. Просто я сейчас пример какой-нибудь на вам приведу, потом опишу алгоритм.
[01:15:14.760 --> 01:15:27.000]  Смотрите. На каждом шаге отрезается лист с наименьшим номером. Давайте ищем лист с наименьшим
[01:15:27.000 --> 01:15:37.240]  номером. Здесь 6. И пишется вершина. Пятёрка, прости, пятёрка. Спасибо. И пишется вершина,
[01:15:37.400 --> 01:15:44.840]  с которой лист был соединён. На следующем шаге делается то же самое. То есть в новом дереве
[01:15:44.840 --> 01:15:55.160]  опять отрезается лист с наименьшим номером и пишется вершина, с которой лист был соединён.
[01:15:55.160 --> 01:16:10.680]  Так значит здесь дальше четвёрка. Дальше тройка срезается. Получается двойка. Так пишется двойка.
[01:16:10.680 --> 01:16:35.000]  Следующее 7. Пишем 1. 8. Пишем 1. 1 срезаем, пишем 2. Последнее ребро осталось. С ним ничего не
[01:16:35.000 --> 01:16:43.560]  делаем. Просто не пишем никуда это ребро. Получается дерево на N вершинах записывается
[01:16:43.560 --> 01:16:58.360]  к длине N-2. Правильно, ребята? Алгоритм понятен? То есть каждый шаг кромсаем листы с наименьшим
[01:16:58.360 --> 01:17:03.840]  номером. Записываем вершину, с которой лист был соединён. С новым деревом,
[01:17:03.840 --> 01:17:08.280]  которое осталось. Продолжаем то же самое. До тех пор, пока не останется одно ребро,
[01:17:08.280 --> 01:17:14.440]  его никуда не пишем. Вот. Декодирование. Как вы думаете, как работает декодирование?
[01:17:14.440 --> 01:17:18.360]  То есть вот у нас есть код, как по коду восстановить дерево.
[01:17:29.240 --> 01:17:39.800]  Сейчас я опишу этот алгоритм. Придется видимо повторять на следующей лекции,
[01:17:39.800 --> 01:17:45.160]  потому что я хочу доказать свойства этого кодирования, которые нам нужны. Смотрите,
[01:17:45.160 --> 01:17:56.920]  ребята. Предположим, что мы доказали следующее утверждение. Например, что каждому коду
[01:17:56.920 --> 01:18:08.240]  соответствует единственное дерево. То есть нет двух деревьев с одинаковым кодом. Предположим,
[01:18:08.240 --> 01:18:20.800]  мы доказали, что каждый код восстанавливает по многому декодирование. Сейчас я опишу,
[01:18:20.800 --> 01:18:26.360]  что процедура декодирования создаст, кажется, именно дерево. Процедура декодирования работает
[01:18:26.360 --> 01:18:32.040]  следующим образом. Давайте нужно всё-таки описать, а потом рассказать набор утверждений,
[01:18:32.040 --> 01:18:49.360]  которые мы должны доказать, чтобы всё работало. Смотрите, пускай наш код 3 4 3 2 1 1 2. Внизу приписываем
[01:18:49.360 --> 01:19:04.640]  цифры подряд идущие 1 2 3 4 5 6 7 8 9 на две больше. Теперь алгоритм работает следующим образом. Ищем
[01:19:04.640 --> 01:19:12.560]  внизу числа, чиселок здесь на две больше, чем тут. Значит, очевидно есть чиселки, которые не
[01:19:12.560 --> 01:19:21.260]  встречаются вверху. Ищем наименьшее по номеру число, которое отсутствует вверху. Смотрите,
[01:19:21.260 --> 01:19:32.360]  какое здесь наименьшее по номеру, которое отсутствует 5. И вот так вычёркиваем 5, вычёркиваем 3. Записываем
[01:19:32.360 --> 01:19:41.200]  ребро 5 3 и продолжаем для нового набора то же самое. Ищем число, которое есть внизу, но отсутствует
[01:19:41.200 --> 01:19:58.800]  вверху. Вот 6. Записываем ребро 6 4. Вычёркиваем дальше. Ищем так 1 2 3 здесь 4, да, если не ошибаюсь.
[01:19:58.800 --> 01:20:21.960]  4 3. Теперь 3 2. 7 1. 8 1.
[01:20:21.960 --> 01:20:50.680]  7 1 вроде всё. Ну, давайте 3 2.
[01:20:51.960 --> 01:20:59.160]  Теперь 1 2 есть. Значит, минимальное, которое отсутствует, это 7. 7 1 вроде всё правильно. Потом
[01:20:59.160 --> 01:21:11.560]  опять 1 2 всё ещё есть. Их использовать нельзя. 8 1. А теперь минимальное, которое отсутствует, это единица.
[01:21:11.560 --> 01:21:25.920]  И осталось последние две цифры. Это последнее ребро, которое мы никуда не вписали. Его отдельно
[01:21:25.920 --> 01:21:38.880]  выписываем. Эта процедура декодирована. То есть кодирование. Каждое из дерева каждый раз ищем
[01:21:38.880 --> 01:21:44.400]  лист с наименьшим номером. Удаляем. Продолжаем до тех пор, пока не останется на ребро, которое
[01:21:44.400 --> 01:21:50.640]  никуда не пишется. Декодирование. Записываем код внизу. Записываем подряд идущие числа в
[01:21:50.640 --> 01:22:00.480]  количестве n минус 2. n плюс 2 штук, где n длина кода. И на каждом шаге ищем наименьшее число внизу,
[01:22:00.480 --> 01:22:09.120]  которое отсутствует вверху. Соединяем в ребро эти найденные числа. Удаляем их и продолжаем до тех
[01:22:09.120 --> 01:22:17.160]  пор, пока не останется два последних числа внизу. Их отдельное ребро пишем. А потом можем нарисовать
[01:22:17.160 --> 01:22:29.080]  дерево, когда все ребра выписаны. Что нужно доказать про эти две процедуры? Что нет двух деревьев с
[01:22:29.080 --> 01:22:39.920]  одинаковым кодом. Что любой код декодируется именно в дерево. Вообще-то не очевидно. Смотрите,
[01:22:39.920 --> 01:22:45.480]  вот код, вот какой-то описанный алгоритм. Почему он построит дерево? Вдруг он чуть
[01:22:45.480 --> 01:22:52.360]  не связанный построит? Это же последовательность ребра какая-то. Что любой код декодируется
[01:22:52.360 --> 01:23:03.400]  именно в дерево. И что не бывает два кода, которые кодируют одно и то же дерево. Тогда у нас
[01:23:03.400 --> 01:23:10.840]  получится биекция между набором кодов и набором множества деревьев и множества кодов. Коды
[01:23:10.840 --> 01:23:18.220]  считаются легко. Их n как раз n в степени n-2, потому что длина кода n-2. А на каждой позиции
[01:23:18.220 --> 01:23:24.420]  здесь может стоять любое отсесло от 1 до n. То есть если мы вот эти три утверждения докажем,
[01:23:24.420 --> 01:23:33.300]  а декодирование именно декодирует дерево, что нет двух деревьев с одинаковым кодом и что нет
[01:23:33.300 --> 01:23:40.900]  двух кодов с одинаковым деревом, то мы докажем однозначность кодирования декодирования и
[01:23:40.900 --> 01:23:51.700]  корректность его. Ну и соответственно докажем, что это биекция. Поняли? Ну всё.
