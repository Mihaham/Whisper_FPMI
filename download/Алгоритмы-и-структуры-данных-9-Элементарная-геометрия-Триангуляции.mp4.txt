[00:00.000 --> 00:16.560]  Хорошо, давайте тогда начинать. Давайте начинать. Девятая лекция у нас и 28 октября.
[00:16.560 --> 00:26.120]  Значит, мы плюс-минус разобрали все, что я хотел рассказать про теорию чисел в
[00:26.640 --> 00:33.440]  там всякая математика, комбинаторика, что-то такое. И сейчас переходим к блоку про геометрию.
[00:33.440 --> 00:43.520]  Посмотрим тоже, что успеем, что будет интересно нам разбирать. Сегодня такая вступительная,
[00:43.520 --> 00:54.160]  довольно простая, надеюсь, лекция. Это элементарная геометрия и триангуляции.
[00:54.160 --> 01:07.480]  Сначала поговорим про то, что, я надеюсь, всем из вас известны из курсов либо линейная алгебра,
[01:07.480 --> 01:14.000]  либо алгебра геометрии. Как вообще можно задавать точку на плоскости? Мы пока что
[01:14.000 --> 01:18.280]  будем жить в R2, то есть на обычной плитке плоскости, в пространство там где-нибудь.
[01:18.280 --> 01:25.960]  Чуть позже выйдем в R3. Как хранить точки, что с ними можно делать, всякие скалярные векторные
[01:25.960 --> 01:30.880]  произведения, как пересекать прямые, как находить расстояние от точки до прямой. Вероятно,
[01:30.880 --> 01:37.080]  вы все эти формулы уже знаете, поэтому мы по ним быстро пройдем. Возможно, что доказывать не
[01:37.080 --> 01:41.800]  будем, но просто чтобы повторить, осуществляйте в памяти, потому что когда-нибудь это все точно
[01:41.800 --> 01:49.000]  будет, все эти формулы будут нужны. Так, ну поехали. Значит, сначала точки, векторы, как мы их
[01:49.000 --> 02:00.840]  представляем, что мы от них хотим? Предлагается, что мы живем в R2 на обычной плоскости. Ну тогда
[02:00.840 --> 02:07.720]  все, что у меня есть, это две координатные оси X и Y. Если, соответственно, каждая точка задается
[02:07.720 --> 02:15.040]  своей проекцией на оси абсцисс и на оси ординат. То есть мы сейчас будем говорить по модуле
[02:15.040 --> 02:23.680]  программирования только о полярных и ордонормированных декартовых координатах, да? Так, что такое полярные,
[02:23.680 --> 02:31.160]  я не очень понял. Ну, когда точка задается радиусом и углом от абсцисс. Ну, я бы сказал, что мы будем
[02:31.160 --> 02:38.520]  говорить только обычными координатами X и Y, то, что вы называли ордонормированными. Там, где нам
[02:38.520 --> 02:43.360]  нужны будут всякие углы, мы это будем высчитывать исходя из этих координат. То есть у нас основная
[02:43.360 --> 02:48.880]  форма представления — это вот в ордономерном базисе, с каким коэффициентом нужно взять два
[02:48.880 --> 02:54.680]  базистных вектора, чтобы получить наш вектор. Вот, и при необходимости мы будем переходить в ту форму,
[02:54.680 --> 02:58.680]  которая будет удобнее. То есть, когда мы будем говорить про повороты, мы там будем считать угол,
[02:58.680 --> 03:06.680]  но это вот базируется все на одном нашем. То есть, даже полярных не будет, не то, что этих самых
[03:06.680 --> 03:15.760]  наклонных осей, да, на финнах? Ну, видимо, не будет, да. Ну, ладно, хорошо. Ну, то есть, кажется,
[03:15.760 --> 03:23.320]  все, что нам нужно, оно выражается через X и Y, и поэтому без этого сможем бойтись. Итак,
[03:23.440 --> 03:30.840]  любая точка, она сдается своими двумя координатами A и B, проекция на OX, проекция на OEDIC. Вот,
[03:30.840 --> 03:34.840]  и здесь же мы говорим, что, в общем-то, каждая точка, она однозначно соответствует вектору,
[03:34.840 --> 03:41.400]  такому радиус-вектору из точки 0 в нее же, в точку B. Тем самым у меня, как бы, точки и векторы,
[03:41.400 --> 03:45.720]  такие радиус-векторы из начала координат в эту точку, они друг другу соответствуют и имеют
[03:45.720 --> 03:49.880]  одни и те же координаты. Потому что, если точка P имеет координату AB, то, собственно, векторы из 0,
[03:50.120 --> 03:56.240]  в эту точку имеют те же самые координаты AB. Поэтому мы структуру точку и структуру вектора будем
[03:56.240 --> 04:05.000]  хранить в одной большой структуре, которую, ну, я обычно называю point. Потому что, ну,
[04:05.000 --> 04:09.040]  скорее главное, что нам нужно, это, что это точка, потому что любой вектор, он как бы сдается своим
[04:09.040 --> 04:13.520]  концом, когда мы знаем вначале, что это 0, 0. Вот какая структура point. Ну и, соответственно,
[04:13.520 --> 04:18.120]  здесь основные поля, это A и B. Давайте, скажем, пока считать, что у меня все координаты целочисленные,
[04:18.120 --> 04:29.000]  насчет меня будет два поля, давайте не A и B, я назову координаты, соответственно, OBC. Вот,
[04:29.000 --> 04:35.720]  ну что, например, если у меня есть теперь две точки какие-нибудь на плоскости P и Q, то чтобы
[04:35.720 --> 04:41.880]  посчитать вектор между ними, чтобы задать вектор с координатами равными вектору из P в Q,
[04:41.880 --> 04:52.440]  то мне нужно написать что-то примерно такое, мне нужно написать Q.X-P.X, Q.Y-P.Y. Мне нужно просто
[04:52.440 --> 04:57.960]  посчитать разность по X, разность по Y, и это будет наш задержавший вектор, давайте я назову V со
[04:57.960 --> 05:05.440]  стрелочкой, V со стрелочкой. Это такой вектор из P в Q, да, конец, значит, координаты конца,
[05:05.440 --> 05:11.440]  минус координаты начала из P в Q. Ну и, соответственно, здесь тогда можно написать оператор минус на
[05:11.440 --> 05:15.680]  наших точках, чтобы он по двум точкам строил векторы из одной в другую, ну или просто как бы по
[05:15.680 --> 05:22.680]  компонентных вычитал. Вот здесь внутри можно написать что-то в стиле point оператор минус,
[05:22.680 --> 05:33.640]  принимая там какую-то другую точку по константной ссылке. Я не знаю, как вы здесь привыкли писать,
[05:33.640 --> 05:40.040]  я обычно пишу здесь other, передаю как бы другую точку еще в конце const, чтобы ничего не менять,
[05:40.040 --> 05:49.080]  ну и return, соответственно, точку с координатами X минус other X, Y минус other Y.
[05:49.080 --> 05:59.840]  Вот подразумеваю, что у меня есть конструктор по двум координатам, просто конструктор точки по
[05:59.840 --> 06:06.800]  координате X и в координате Y. Все, тогда мы можем очень легко считать вектор между двумя точками.
[06:06.800 --> 06:13.480]  Ну и то же самое можно определять там, сложение точек как сложение векторов, если есть два вектора,
[06:13.480 --> 06:24.840]  там у и в какие-то, у и в, то мы можем определить их сложение, как вот диагональ параллограмма
[06:24.840 --> 06:30.040]  натянутого на эти два вектора, вектор вот такой вот у плюс в, ну и соответственно его координаты это
[06:30.040 --> 06:36.880]  просто покомпонентное сложение уX плюс вX и уY плюс вY, я даже писать не буду, это опять
[06:36.880 --> 06:44.600]  покомпонентная просто операция сложений. Можно также что сделать, можно увеличить вектор в какой-то
[06:44.600 --> 06:51.720]  константу раз, можно имея вектор у, значит давайте здесь подпишем, что это мы подразумеваем оператор
[06:51.720 --> 06:57.320]  плюс, оператор плюс сложение двух векторов, здесь по вектору у я тоже могу построить какой-нибудь
[06:57.320 --> 07:03.600]  вектор кау, взять этот вектор, отложить несколько раз, то есть умножить на к, тогда это реализуется
[07:03.600 --> 07:10.160]  с помощью оператора умножить на какое-то там целое число к, пока что если мы считаем, что все координаты
[07:10.160 --> 07:17.360]  целые, да и что у меня это всегда выполняется, то как будто бы я всегда беру только целое число раз
[07:17.360 --> 07:25.600]  этот вектор откладок, тогда к как будто бы целый. Ну вот такие базовые операции очень легко пишутся
[07:25.600 --> 07:31.680]  с помощью нашего конструктора по двум координатам по х и по у, и очень удобно с ними работать,
[07:31.680 --> 07:37.120]  если вы напишите именно это как оператор, то вы в общем-то в прям в коде можете работать с этими
[07:37.120 --> 07:43.480]  объектами как на бумаге, то есть пишите на бумаге там не знаю, вектор у минус вектор в, и точно то же
[07:43.480 --> 07:47.040]  самое у вас будет в коде, просто у минус в, вот прям тот же самый минус, который вы пишете на бумаге,
[07:47.040 --> 07:52.120]  это также у вас будет в коде, вот это довольно удобно, чтобы там не писать всякие функции типа
[07:52.200 --> 07:59.480]  там subtract вектора, писать один оператор и работать так же, как вы пишите на бумаге.
[07:59.480 --> 08:12.000]  Следующий примитив, который нам нужен, это прямая struct line, ну и соответственно мы хотим от нее,
[08:12.000 --> 08:15.960]  чтобы она как-то, чтобы эта структура однозначно создавала какую-то прямую на плотности.
[08:15.960 --> 08:29.760]  Структура прямая должна как-то, вот нам нужно как-то создавать прямую на плотности.
[08:29.760 --> 08:38.800]  Даже не знаю, вы наверное и так все знаете, но все равно проговорю, что обычно прямые удобно,
[08:38.800 --> 08:45.200]  ну или по крайней мере принято представлять в виде х равно кх плюс b, и тогда можно было бы сказать,
[08:45.200 --> 08:51.040]  что прямую мы будем хранить как-то эти два коэффициента кайбы. Это как бы в принципе валидно,
[08:51.040 --> 08:56.920]  но к сожалению в таком виде задаются не все прямые, а именно они задаются вертикально прямые,
[08:56.920 --> 09:03.320]  то есть такие прямые, у которых х не меняется, у них какой-то х фиксированный, а y любой,
[09:03.320 --> 09:09.960]  и тогда вот такое уравнение здесь не подойдет, не подходит, и значит наша форма, представление
[09:09.960 --> 09:16.600]  прямой в виде кх плюс b, она ну как бы исключает из рассмотрения вертикальной прямой. В принципе с этим
[09:16.600 --> 09:23.080]  можно было бы и пожить, сказать, что перед тем как обрабатывать все что нужно, перед тем как решать
[09:23.080 --> 09:29.360]  задачу, мы повернем всю картинку на какой-нибудь случайный угол альфа, где альфа там ну равномерно
[09:29.360 --> 09:35.760]  выбирается из интервала 0.2b, и тогда скажем, что тогда с вероятностью 1 у меня не будет
[09:35.760 --> 09:42.480]  никаких вертикальных прямых, и соответственно таких крайних случаев не возникнет. Это валидный
[09:42.480 --> 09:48.320]  подход, но здесь когда мы переходим к поворотам, когда мы сначала всю картинку поворачиваем на
[09:48.320 --> 09:53.080]  альфа, у меня конечно, во-первых, сразу точно у меня не получится работать в целых числах,
[09:53.080 --> 09:57.800]  потому что поворот на альфа это точно всякие косинусы, синусы, умножения всякие, это точно
[09:57.800 --> 10:07.920]  переход к даблам или лонг даблам, короче к числу с плавающей точкой. Да? Да, ну на самом деле, если мы
[10:07.920 --> 10:15.200]  работаем в двумерном варианте, то возможно можем обойтись без синусов косинусов, использовав
[10:15.200 --> 10:25.800]  комплексные числа и умножение на комплексную экспоненту. Ну хорошо, в каком виде вы храните
[10:25.800 --> 10:32.040]  комплексные числа? Ну да, а там тоже с даблами все, не спорю, но как бы, что вообще лучше,
[10:32.040 --> 10:36.960]  кстати, будет, косинусы, синусы или комплексные экспоненты? Это одно и то же. Комплексная экспонента,
[10:36.960 --> 10:45.440]  она, ну по крайней мере, насколько я знаю, есть этот класс комплекс C++, и он как хранится? Он
[10:45.440 --> 10:53.120]  хранится к веществной части и мимо части. Ну да. Поэтому нет разницы, поэтому мимо экспонента это
[10:53.120 --> 11:04.400]  косинус альфа запитая и синус альфа. А, то есть он не хранит это? Ладно, я понял. Да, но как бы,
[11:04.400 --> 11:11.240]  он же не может себе написать, что там z равно e в степени и альфа, он же, ну как бы, ему нужно знать,
[11:11.240 --> 11:22.720]  ну короче нет, все равно там нужны обе координаты. В итоге, в этом подходе, если переходить
[11:22.720 --> 11:28.920]  к повороту, то возникает много всяких поворотов, возникает много неточностей, и мы будем иногда
[11:28.920 --> 11:34.880]  стараться следить за тем, чтобы не переходить к веществным числам, когда это не нужно. Вот и здесь,
[11:34.880 --> 11:39.400]  если у меня исходные числа были целые, то, в принципе, можно без этого обойтись. А именно,
[11:39.400 --> 11:45.320]  мы будем хранить прямую в виде трех координат, не как здесь было две координаты k и b, у меня
[11:45.320 --> 11:51.440]  будут три координата a, b, c. Соответственно, прямая у нас представляется в виде ax plus by plus c
[11:51.440 --> 11:58.920]  равно 0. Ax plus by plus c равно 0. Вот в таком виде уже задается любая прямая, и строго вертикальная,
[11:58.920 --> 12:06.240]  и строго горизонтальная, и любая другая наклонная. Единственный, ну такой, возможно, минус этого
[12:06.240 --> 12:12.360]  подхода в том, что прямая тогда задается неоднозначно, потому что, если вы умножите все
[12:12.360 --> 12:17.640]  три коэффициента a, b, c на какую-то общую константу, скажем, лямбда, тогда у вас, ну не нулевую,
[12:17.640 --> 12:22.640]  понятное дело, тогда у вас уравнение не изменится, потому что если вы левую часть умножите на лямбду,
[12:22.640 --> 12:28.560]  правую на лямбду, то у вас ничего не поменялось. То есть как бы у уравнения прямой есть несколько
[12:28.560 --> 12:33.760]  одинаковых записей, когда у вас все константы отличаются в лямбду раз. Ну, бог с ним. Нам
[12:33.760 --> 12:38.680]  главное, чтобы была хоть какая-то запись, чтобы было хоть какое-то представление для прямой.
[12:38.680 --> 12:47.880]  Можно построить конструктор прямой по двум точкам. Самый простой способ построения прямой,
[12:47.880 --> 12:53.920]  ну или даже, возможно, не самый простой, а самый частый, частый нам нужный, это прямая по двум
[12:53.920 --> 13:07.720]  точкам. Значит, пишем конструктор по каким-то двум точкам. Const point p, const point q. Есть у нас два
[13:07.720 --> 13:13.240]  объектика. Мы хотим, точнее есть две точки, мы хотим по ним построить прямую. То есть найти такие
[13:13.240 --> 13:21.400]  ABC, что точки по IQ на них лежат. Так, значит, давайте я оставлю место под код, а внизу напишу следующую
[13:21.400 --> 13:30.920]  форму. Если у меня есть точка p с координатами x1 и y1 и точка q с координатами x2 и y2, мы строим
[13:30.920 --> 13:37.000]  вот такую прямую. Тогда нам на роль ABC подойдут следующие, следующие штуки. Значит, на роль p
[13:37.000 --> 13:51.160]  можно взять, на роль a, извините, y1-y2, на роль b можно взять x2-x1, на роль c x1-y2-x2-y1.
[13:51.160 --> 13:59.520]  Вот, значит, я утверждаю, что если взять такие ABC, то они нам подойдут. То есть, если рассмотреть
[13:59.520 --> 14:04.800]  потом прямую ax плюс bq плюс c равно 0, то у них будут лежать точки по IQ. Если предположить, что
[14:04.800 --> 14:10.200]  точки по IQ изначально различные, то есть прямая однозначно восстанавливается, то вот ее можно
[14:10.200 --> 14:19.840]  сохранить в таком виде a такое, b такое. По формализму это докажем. Чтобы нам доказать,
[14:19.840 --> 14:25.760]  нужно просто подставить точки по IQ в нашу уравнение прямой, в ax плюс bq плюс c, и проверить,
[14:25.760 --> 14:40.000]  что на обеих точках достигается равенство 0. Сделаем это для точки по a на x плюс b на y плюс c.
[14:40.000 --> 14:47.240]  Я подставил точку по в уравнении прямой. Раскрываем скобки. Даже, наверное, не буду
[14:47.240 --> 14:51.640]  раскрывать, просто давайте посмотрим, что здесь сокращается. Вот есть x1-y1,
[14:51.640 --> 15:00.440]  которое здесь сократится, да, слева с плюсиком, справа с минусиком. Дальше есть минус x1-y2 плюс
[15:00.440 --> 15:16.400]  x1-y2. Есть x2-y1 минус x2-y1. Получился 0. То же самое можно проделать для P. Если я подставлю координат
[15:16.400 --> 15:32.240]  x2 и y2, то, понятно, получится тоже самое, но давайте тоже проверим. x2-y1 минус x2-y1,
[15:32.240 --> 15:43.480]  минус x2-y2 плюс x2-y2, минус x1-y2 плюс x1-y2. Тоже получился 0. Ну все, значит, мы действительно,
[15:43.480 --> 15:50.600]  если мы задаем просто ABC вот так, вот так, то получаем прямую, на которой лежат обе наши точки,
[15:50.600 --> 15:54.360]  собственно, что нам нужно. Нам нужно было построить такую прямую, на которой лежали все, что нужно
[15:54.360 --> 15:59.320]  лежит, точнее, наши две точки лежат. Вот мы ее получили. Повторюсь, их там несколько. Если я умножу
[15:59.320 --> 16:04.000]  ABC на одно и другое число лямбда, не нулевое, то получится тоже корректное уравнение нашей прямой.
[16:04.000 --> 16:07.720]  Но нам не нужно хранить все, нам достаточно кого-то одного, нам достаточно какого-то одного
[16:07.720 --> 16:15.840]  представления нашей прямой. И здесь тоже очень приятно, что корректные координаты x и y были целыми,
[16:15.840 --> 16:22.560]  то ABC тоже останется целыми, потому что здесь разность и произведение. Все точки будут целыми.
[16:22.560 --> 16:30.640]  Вот, а если бы, например, делали бы в виде y равно kx плюс b, там, ну там не явно, ну даже явно,
[16:30.640 --> 16:36.520]  да, зашитка в центре наклона k, и там явно будет нужна какая-то дробь. k там точно будет какой-то
[16:36.520 --> 16:42.760]  нецелое обязательно. И, то есть, тут у нас даже как бы два выигрыша. Во-первых, мы не переходим к
[16:42.760 --> 16:48.000]  доблам, там где-то можно избежать, там где-то можно избежать. И во-вторых, мы можем представлять все прямые.
[16:48.000 --> 16:56.400]  В итоге код такой. Ну, здесь я напишу, что если точки p и q одинаковые, то там нужно, вот это вы
[16:56.400 --> 17:03.800]  лучше меня знаете, что есть там какой-то сроу написать, какой-нибудь exception. В общем, как-то дать
[17:03.800 --> 17:08.720]  понять пользователю, что он делает какую-то дичь, что нельзя построить точку по двум прямям. В нормальном случае,
[17:08.720 --> 17:16.200]  если точки p и q различны, значит, нужно сделать понятно, что. Просто то, что написано ниже. Значит,
[17:16.200 --> 17:38.440]  а это py-qy, b это qx-px, c это px на qy-py на qx. Потом, пожалуйста, конструктор прямой по двум точкам.
[17:38.440 --> 17:54.040]  Прямая по двум точкам. Да, хорошо. Хорошо. Давайте еще поговорим про прямую, про всякие ее параметры.
[17:54.040 --> 18:03.600]  Если есть какая-то прямая с уравнением ax plus b equals 0, то с ней связаны два следующих векторов.
[18:03.800 --> 18:11.480]  Во-первых, есть вектор нормаля. Вектор нормаля n, у которого координаты a, z, z, b. И здесь направляющий вектор.
[18:11.480 --> 18:27.040]  Направляющий вектор. Его обычно называют a, конечно, но давайте я его назову vector l. И здесь у него есть два представления.
[18:27.120 --> 18:39.000]  Либо это b-a, либо b-a. Во-первых, h и b поменяли местами, во-вторых, любая из них взята с минусом.
[18:39.000 --> 18:46.600]  Одна с плюсом, другая с минусом. Можно взять и так, и так. Понятно, что от изменения знака обеих координат,
[18:46.600 --> 18:52.000]  то есть когда мы переходим отсюда-сюда, мы меняем знак обеих координат, это на самом деле просто будет противоположный вектор.
[18:52.000 --> 19:00.400]  То есть один из них смотрит направо, другой налево. Вот если мы берем b-а, он смотрит куда-то, а минус b-а смотрит в другую сторону.
[19:00.400 --> 19:10.600]  Как-нибудь надо это, наверное, понять. Давайте сначала поймем, что l это действительно направляющий вектор, вот этот вот синенький направляющий вектор.
[19:10.600 --> 19:17.840]  Это легко понять. Пусть есть какая-то точка x, y, лежащая на прямой. Соответственно, тогда для нее выполняется вот это уравнение прямой.
[19:17.840 --> 19:25.040]  А х плюс b как равно нулю. Тогда давайте мы отложим точку, точнее отложим вектора l, направляющий вектор нашей прямой.
[19:25.040 --> 19:36.400]  Ну, потенциально, который мы проверяем на то, что он направляющий. Мы отложим от точки x, y. Соответственно, получим точку какую-то новую с координатами x плюс b.
[19:36.400 --> 19:41.600]  Что эта точка тоже лежит на прямой, то есть удовлетворяет уравнению прямой.
[19:41.600 --> 19:50.600]  Тогда мы получим, что действительно l это направляющий вектор. Потому что, по сути, это это разница между какими-то двумя точками на прямой.
[19:50.600 --> 19:55.520]  Ну, значит, это по определению практически вравляющий вектор.
[19:55.520 --> 20:07.240]  Значит, подставляем x, вот это новое, х плюс b, y минус а в нашем уравнении прямой. Получаем а на х плюс b, плюс b на y минус а, плюс c.
[20:07.320 --> 20:15.800]  Ну, здесь все отлично. Здесь у меня вылазит из скобок ab и минус ab. Они сократятся, останется исходно а х плюс y, плюс c.
[20:15.800 --> 20:19.800]  И это равно 0 по предположению, потому что точка x, y лежала на прямой.
[20:19.800 --> 20:27.680]  Ну, все, значит, l действительно это направляющий вектор. То есть вектор, который как бы параллели нашей прямой.
[20:27.680 --> 20:35.080]  Вот, теперь, чтобы понять, что n это вектор нормали, достаточно проверить, что векторы l и n артегональны.
[20:35.920 --> 20:41.920]  Ну, а артегональность векторов мы знаем, как проверять. Это равенство нулю эксталлярного произведения.
[20:41.920 --> 20:51.920]  Опять-таки там из какого-нибудь линала. Мы знаем, что артегональность векторов это то же самое, что равенство нулю эксталлярного произведения.
[20:51.920 --> 20:55.920]  Ну, давайте перемножим. Да, то есть поточечно перемножим и сложим.
[20:55.920 --> 21:00.920]  Что у меня будет? У меня будет b умножить на а, минус а умножить на b. То есть как раз 0.
[21:01.760 --> 21:11.760]  Вот. Ну, хорошо. Такие два важных вектора прямой, вектор нормали, вектор направляющий, нам будет удобно с ними работать, ну, особенно с нормали.
[21:11.760 --> 21:19.760]  Так, если есть какие-нибудь вопросы, то, пожалуйста, прерывайте, я отвечу.
[21:20.600 --> 21:28.600]  Да, ну, тут еще можно такое заметить, что довольно часто вектор нормали удобно представлять единичным вектором.
[21:28.600 --> 21:34.600]  То есть, когда у него длина единичная. Если это нужно сделать, то мы, конечно же, можем вот этот вектор обычным вектором.
[21:34.600 --> 21:40.600]  Поэтому, если у нас есть какие-нибудь вопросы, то, пожалуйста, прерывайте, я отвечу.
[21:40.600 --> 21:44.600]  Ну, я не знаю, что ещё можно заметить.
[21:44.600 --> 21:46.600]  единичным вектором, то есть когда у него длина единичная.
[21:47.120 --> 21:51.960]  Если это нужно сделать, то мы, конечно же, можем вот этот вектор, там, n, поделить обе его координаты
[21:52.120 --> 21:59.680]  на длину вектора, то есть на корень из a2 тус b2. Мы можем, конечно, этот вектор сжать так, что он будет единичной длины, если это прям нужно.
[21:59.700 --> 22:01.940]  Да, но тогда мы, скорее всего,
[22:02.700 --> 22:11.540]  ну там, почти всегда, мы уйдем от целочисленности. Поэтому, как бы, формально вектор n, это не то, что вектор нормальный, да, не то, что и вектор единичный нормальный,
[22:11.860 --> 22:20.100]  что там обычно строится во всяком атоме, когда мы берем там производную кривую или что-то такое и нормируем, это просто какой-то вектор перпендикулярной прямой.
[22:21.700 --> 22:30.420]  И нам это нужно учитывать, что это не единичный вектор, а вектор какой-то произвольной длины, и потом, если что, нужно будет делить на как раз таки этот корень из суммы квадратов a и b.
[22:32.740 --> 22:33.140]  Так.
[22:33.140 --> 22:42.140]  Окей, давайте тогда, здесь же, раз мы про это говорим, мы вспомним, как считать расстояние от точки до прямой.
[22:43.460 --> 22:48.420]  Расстояние от точки до прямой.
[22:50.380 --> 22:55.940]  Есть какая-то прямая, сдаваемая уравнение вот таким вот, и точка с координатами.
[22:56.460 --> 23:01.100]  Ну, давайте скажем, что это точка с координатами px, py.
[23:02.780 --> 23:06.740]  Мне нужно найти вот это вот расстояние, то есть, что будет, если я опущу перпендикулирую,
[23:10.740 --> 23:11.740]  какая бы длина этого нет.
[23:15.140 --> 23:22.540]  Я утверждаю, что достаточно просто подставить точку p в уравнении прямой, то есть, здесь вот вместо xiy написать px, py,
[23:23.540 --> 23:27.140]  взять модуль у этой величины и нормировать на корень из суммы квадратов a и b.
[23:29.540 --> 23:29.860]  Так.
[23:32.860 --> 23:36.260]  Да, тут я понял, что это не очевидно, но давайте поровну как-нибудь быстро доказать.
[23:36.820 --> 23:41.540]  Я утверждаю, что расстояние равно следующей величине.
[23:41.540 --> 23:55.060]  Ну, я для удобства это переобозначу, давайте это будет у меня x0, y0, вот так, тогда расстояние будет равно следующей величине a x0 плюс b y0
[23:57.060 --> 24:01.060]  плюс c делить на корень из суммы квадратов a и b.
[24:01.580 --> 24:07.580]  Так, ну, чтобы это доказать, давайте мы опустим перпендикуляр на нашу прямую, это будет какая точка q.
[24:08.580 --> 24:16.580]  И тогда мне что нужно написать, чтобы q было действительно перпендикулярно, в смысле, оставание перпендикулярно, то есть, проекция q на нашу прямую,
[24:16.580 --> 24:25.580]  мне нужно написать, чтобы q, во-первых, лежит на прямой, во-вторых, что вектор pq коллиниарен нормали, вектор pq нормален.
[24:26.100 --> 24:38.100]  Ну или иными словами, я могу написать следующее, что q это какой-то p плюс n умножено лямбду, то есть, я понимаю, что чтобы по точке добраться до прямой,
[24:38.100 --> 24:41.100]  мне нужно двигаться в направлении параллельного нормали.
[24:41.100 --> 24:46.100]  Если у меня есть вектор нормали, то есть, вектор a b, то мне нужно будет его умножить на q, это лямбда, чтобы опуститься на прямую.
[24:46.100 --> 24:50.100]  То есть q это p плюс n лямбда, и при этом q лежит на прямой.
[24:50.620 --> 24:52.620]  Ну и, соответственно, это будет уравнение на лямбду.
[24:52.620 --> 24:55.620]  Давайте посмотрим, q имеет какие координаты.
[24:58.620 --> 25:02.620]  Давайте я напишу в виде столбика из двух чисел.
[25:02.620 --> 25:06.620]  x0 плюс a лямбда, iq0 плюс b лямбда.
[25:08.620 --> 25:13.620]  Теперь мне нужно написать уравнение на лямбда, которое бы означало, что точка q лежит на прямой.
[25:14.140 --> 25:18.140]  Соответственно, я подставляю вот эти вот координаты в уравнении прямой,
[25:18.140 --> 25:22.140]  получаю следующее, a на x0 плюс a лямбда,
[25:22.140 --> 25:26.140]  плюс b на y0 плюс b лямбда,
[25:26.140 --> 25:28.140]  плюс c должно быть равно 0.
[25:28.140 --> 25:32.140]  Это выражение для лямбда, чтобы точка q лежала на прямой.
[25:34.140 --> 25:38.140]  Так, разрешаем его относительно неизвестного.
[25:38.660 --> 25:42.660]  Направо переносим все остальное.
[25:48.660 --> 25:52.660]  Перенесли и получили, что лямбда это минус
[25:54.660 --> 25:58.660]  подстановка точки p в уравнении прямой
[26:00.660 --> 26:04.660]  делить на a квадрате.
[26:05.180 --> 26:09.180]  Делить на a квадрат плюс b квадрат.
[26:11.180 --> 26:13.180]  Соответственно, мы получили лямбда,
[26:13.180 --> 26:17.180]  мы получили то, сколько раз нужно приложить вектор нормальный к точке p,
[26:17.180 --> 26:19.180]  чтобы опуститься на прямую.
[26:19.180 --> 26:21.180]  Ну, значит, ответ...
[26:21.180 --> 26:25.180]  Давайте напишем, что distance от p до l,
[26:25.180 --> 26:27.180]  расстояние от p до прямой,
[26:27.180 --> 26:31.180]  это что такое? Это длина вектора лямбда n.
[26:31.180 --> 26:34.180]  Потому что мне нужно к точке p лямбда раз приложить вектор n,
[26:34.180 --> 26:36.180]  чтобы опуститься на прямую.
[26:36.180 --> 26:38.180]  То есть как раз длина вектора есть наш ответ.
[26:40.180 --> 26:42.180]  Модуль лямбда мы знаем.
[26:42.180 --> 26:44.180]  Это модуль лямбда на длину вектора n.
[26:44.180 --> 26:49.180]  Модуль лямбда это как раз таки модуль a x0 plus b y0 plus c
[26:49.180 --> 26:52.180]  деленный на a квадрат плюс b квадрат.
[26:52.180 --> 26:54.180]  А вектор нормальный, как я уже говорил выше,
[26:54.180 --> 26:56.180]  у него длина имеет...
[26:59.180 --> 27:01.180]  Потому что его координат это просто a b.
[27:01.180 --> 27:03.180]  Ну и получили, собственно, искомую формулу,
[27:03.180 --> 27:06.180]  когда мы здесь вот сократим сумму квадратов
[27:06.180 --> 27:08.180]  и корень из суммы квадратов,
[27:08.180 --> 27:10.180]  у меня получится искомая формула,
[27:10.180 --> 27:12.180]  что когда мы просто подставили p в ранении прямой,
[27:12.180 --> 27:14.180]  поделили на корень из суммы квадратов,
[27:14.180 --> 27:16.180]  и это есть расстояние от точки до прямой.
[27:21.180 --> 27:24.180]  Ну и заодно мы нашли не только расстояние от точки до прямой,
[27:24.180 --> 27:26.180]  но и по сути нашли проекцию,
[27:26.180 --> 27:29.180]  потому что если мы знаем, чему равно лямбда,
[27:29.180 --> 27:32.180]  то есть сколько раз нужно приложить вектор нормальный к точке p,
[27:32.180 --> 27:35.180]  тогда мы просто прибавляем это самое лямбда n к p
[27:35.180 --> 27:37.180]  и получаем проекцию.
[27:37.180 --> 27:39.180]  То есть мы знаем не только расстояние до прямой,
[27:39.180 --> 27:41.180]  но и проекцию точки напрямую.
[27:41.180 --> 27:44.180]  И здесь уже, скорее всего, нам придется отказываться от целочисленности,
[27:44.180 --> 27:47.180]  потому что здесь, когда мы опускаем нормально прямую,
[27:47.180 --> 27:51.180]  во-первых, расстояние, там явно уже какие-то корни возникают,
[27:51.180 --> 27:56.180]  во-вторых, чтобы посчитать вектор лямбда n,
[27:56.180 --> 27:58.180]  мне нужно поделить там что-то,
[27:58.180 --> 28:00.180]  ну даже целочисленное,
[28:00.180 --> 28:03.180]  на что-то целочисленное, что потенциально не делится,
[28:03.180 --> 28:05.180]  что может не делиться,
[28:05.180 --> 28:08.180]  поэтому точка q имеет уже, вероятно, рациональные координаты,
[28:08.180 --> 28:11.180]  и, значит, нам нужно переходить к доблу.
[28:11.180 --> 28:14.180]  То есть в момент, когда нам нужно опускать вермедикуляры,
[28:14.180 --> 28:18.180]  то есть опускать проекции напрямую из точки,
[28:18.180 --> 28:21.180]  уже, к сожалению, в НТАВ все еще что-то не получится,
[28:21.180 --> 28:23.180]  даже если исходные координаты все целочисленные,
[28:23.180 --> 28:27.180]  здесь уже придется переходить к либо доблам,
[28:27.180 --> 28:29.180]  числом с половочей точкой,
[28:29.180 --> 28:31.180]  либо заводить свой класс rational
[28:31.180 --> 28:35.180]  и хранить эти точки в виде числитель, запятая знаменатель.
[28:35.180 --> 28:38.180]  Если мы хотим считать все точно,
[28:38.180 --> 28:43.180]  и вот у нас прям какие-то большие проблемы с точностью,
[28:43.180 --> 28:46.180]  может быть, очень много операций,
[28:46.180 --> 28:48.180]  тогда, возможно, еще может быть такое нужно делать,
[28:48.180 --> 28:50.180]  что считать нужно все в рациональных,
[28:50.180 --> 28:52.180]  то есть считать, что у каждой точки,
[28:52.180 --> 28:54.180]  каждая точка теперь не насточисленная,
[28:54.180 --> 28:56.180]  а рациональная, у нее есть координата,
[28:56.180 --> 29:01.180]  у нее есть числики по х, числитель знаменатель по у,
[29:01.180 --> 29:03.180]  и, соответственно, все вот это то, что было выше,
[29:03.180 --> 29:04.180]  нужно переписать на...
[29:04.180 --> 29:06.180]  То есть, если вы заведете свой класс rational,
[29:06.180 --> 29:10.180]  класс рациональных чисел как числитель знаменатель,
[29:10.180 --> 29:12.180]  то тогда вот это все, что выше,
[29:12.180 --> 29:16.180]  надо будет переписать для рациональных чисел.
[29:17.180 --> 29:19.180]  Если пока что, то есть пока что можно считать,
[29:19.180 --> 29:21.180]  что все в рациональных, дальше будет так,
[29:21.180 --> 29:23.180]  что уже рациональных не хватает,
[29:23.180 --> 29:28.620]  не хватает, и придется переходить к обычным веществам. Там лучше, чем double, ничего не сделать.
[29:28.620 --> 29:40.620]  Окей, мы опустили пермитигуляр напрямую. Дальше простой примитив – это пересечение прямых.
[29:40.620 --> 29:55.420]  Пересечение прямых. Здесь решается просто методом грамма. Значит, смотрите, есть у вас две прямые,
[29:55.420 --> 30:06.500]  одна имеет вот такой вид, другая вот такой вид. И вам нужно найти точку их пересечения. Ну,
[30:06.500 --> 30:11.180]  или сказать, что прямые параллельные, то есть, имеют ноль точек пересечения, или прямые
[30:11.180 --> 30:18.580]  совпадают, то есть, имеют бесконечно много точек пересечения. Так, ну давайте как-нибудь это поймем.
[30:18.580 --> 30:24.380]  Давайте я не буду писать какую-то функцию, потому что непонятно, что она должна возвращать. Да,
[30:24.380 --> 30:31.860]  она должна возвращать сообщение какое-то, типа, как эти прямые относительно друг и расположены,
[30:31.860 --> 30:37.020]  и при этом, если они пересекаются по одной точке, то эту точку, давайте не будем писать возвращаемый
[30:37.020 --> 30:42.140]  тип. Давайте просто напишем уравнение, ну, систему уравнений, которую мы решаем. По сути,
[30:42.140 --> 30:49.140]  мы просто решаем вот такую систему. Система линейных уравнений относительно двух переменных,
[30:49.140 --> 30:56.620]  х и у. Вот у нас есть замечательный способ это решать. Это метод граммера, он работает следующим
[30:56.620 --> 31:02.220]  образом. Значит, мы считаем определитель нашей, давайте я перепишу это в терминах матрицы.
[31:02.220 --> 31:13.140]  В терминах матрицы это работает вот так. Ну и здесь, значит, граммер работает следующим образом.
[31:13.140 --> 31:18.900]  Мы считаем сначала определитель вот этой исходной матрицы, которая стоит слева. Это, соответственно,
[31:18.900 --> 31:27.420]  а1b2-a2b1. Затем мы подставляем вместо первого столбца вот этот результирующий столбец,
[31:27.420 --> 31:31.380]  который стоит справа. Тем самым мы как бы забываем про ашки и ставим на их места
[31:31.380 --> 31:41.060]  минус c1-c2. И опять считаем определитель. Получится, ну давайте я напишу, что это будет минус c1b2 плюс c2b1.
[31:41.060 --> 31:49.860]  То же самое delta2, это когда мы вместо b ставим наш столбец минус c. То есть вместо b1b2 ставим
[31:49.860 --> 32:02.060]  минус c1-c2. Будет у меня видимо минус a1c2 плюс a2c1. Для тех, кто вдруг не знаком с методом граммера,
[32:02.060 --> 32:08.820]  давайте просто я скажу следующее. Вот посчитаем delta1 delta2, sorry delta1 delta2 по таким формам.
[32:08.820 --> 32:18.100]  Тогда верно следующее. Если delta равно нулю, то что такое delta? Delta это определитель нашей
[32:18.100 --> 32:22.700]  исходной матрицы, вот этой матрицы 2 на 2. И понятно, что если delta равно нулю, то значит
[32:22.700 --> 32:28.620]  матрица выражена. И поэтому система, она либо несовместна, либо имеет бесконечную много решений.
[32:28.620 --> 32:42.660]  То прямые, значит параллель, потому что если наша, если наша, если наша матрица вырожденная,
[32:42.660 --> 32:50.620]  да тогда это значит, что в терминах, не знаю там, в терминах направляющих векторов это можно,
[32:50.620 --> 32:55.980]  скажем, переформулировать. Значит можно написать, можно написать вот здесь вот направляющий вектор,
[32:55.980 --> 33:04.020]  там b1-a1, и вот здесь это b2-a2. И написать условия на то, что эти векторы коллинеарны,
[33:04.020 --> 33:07.860]  то есть там пропорциональны с точностью какой-то констант мультипликативно. То есть скажем,
[33:07.860 --> 33:12.740]  что один вектор это другой умножить на лямбду, другой умножить на лямбду. И тогда как раз вот
[33:12.740 --> 33:17.540]  это вот выражение 1b2-a2b1 будет равно нулю, ровно в том случае, когда ваши векторы,
[33:17.540 --> 33:23.700]  ну пропорциональны, что один включается другого на константу, извините, в константу раз.
[33:23.700 --> 33:30.740]  Получается, что как раз равенство нулю нашего определителя означает, что направляющие векторы
[33:30.740 --> 33:37.420]  наших прямых параллельны. Значит они, ну точно, значит и прямые параллельны, поэтому они либо
[33:37.420 --> 33:43.100]  просто параллельные не пересекаются, либо они совпадают. Вот две такие прямые в одном месте.
[33:43.100 --> 34:01.260]  Прямые параллельны или даже совпадают. Ну хорошо, это в случае, когда дельта равно нулю. В
[34:01.260 --> 34:08.020]  случае, когда дельта не равно нулю, если дельта не равно нулю, то из-за этого грамера нам известно,
[34:08.020 --> 34:15.460]  что единственное решение этого уравнения это следующие две дроби. Вместо х нужно написать
[34:15.460 --> 34:24.660]  дельта 1 делить на дельта, вместо у дельта 2 делить на дельта. Вот, это просто метод грамера.
[34:24.660 --> 34:35.340]  Если он вам не знаком, то просто в качестве уражения докажите, что действительно в этом
[34:35.340 --> 34:39.180]  случае, когда дельта не равно нулю, то есть когда можно делить и когда наши прямые не параллельны,
[34:39.180 --> 34:44.940]  точка пересечения задается вот такими вот уравнениями, вот такими вот координатами.
[34:44.940 --> 34:52.740]  Можно просто подставить вот эти вот оба числа уравнения прямых обеих, проверить, что в эти
[34:52.740 --> 34:58.700]  точки зануляется оба уравнения. То есть получается, что эта точка лежит на обеих прямых, что и
[34:58.700 --> 35:07.340]  требовалось. Мы нашли такую точку, которая лежит там и там. Ну хорошо, мы поняли, как различить два
[35:07.340 --> 35:12.220]  случая параллельности или пересекаемости, и в случае, когда они пересекаются, мы нашли их общую
[35:12.220 --> 35:17.580]  точку через метод грамера. Теперь, как различить два случая, когда прямые параллельные или когда
[35:17.580 --> 35:23.220]  они совпадают? Как-нибудь можно это различить? У вас есть коэффициент версии?
[35:31.340 --> 35:34.620]  Если они совпадают, то у них коэффициенты пропорциональны.
[35:34.620 --> 35:41.340]  Если они совпадают, то коэффициенты пропорциональны. Да, можно так сказать.
[35:41.340 --> 35:45.180]  Действительно, они совпадают. Давайте пропишем, они совпадают.
[35:45.180 --> 35:55.300]  Давайте ка, напишу лям, мы уже переиспользовали, что там а1 это ка2,
[35:55.300 --> 36:08.860]  б1 это ка2, ц1 это ка2. Да, это верно. И соответственно, можно, например,
[36:08.860 --> 36:13.180]  рассуждать так. Чтобы проверить, что они совпадают при условии, что они параллельны,
[36:13.180 --> 36:19.420]  давайте мы скажем, что ка равно а1 делить на а2 и проверим выполнение вот этих двух уравнений.
[36:23.420 --> 36:28.060]  Но, к сожалению, это не работает, если а2 равно нулю. Поэтому так можно делать только,
[36:28.060 --> 36:32.700]  если а2 не равно нулю. Значит, в общем случае, такой подход, мне кажется,
[36:32.700 --> 36:39.060]  работал бы так. Мы находим из трех координат a, b, c, там a2, b22, какую-то не нулевую, скажем там b,
[36:39.060 --> 36:45.260]  не нулевая. Тогда пишем, что k равно b1 делить на b2 коэффициент пропорциональности. Да, и сравним,
[36:45.260 --> 36:49.620]  что там для остальных двух координат a и c выполняется такая же пропорциональность с тем
[36:49.620 --> 36:59.980]  же самым коэффициентом. Да, можно так. У меня есть другое предложение, можно еще проверить,
[36:59.980 --> 37:04.780]  можно сделать следующее. Взять, найти какую-нибудь точку на одну из прямых и
[37:04.780 --> 37:11.180]  проверить, лежит ли она на другой прямых. Соответственно, если она лежит, то получается,
[37:11.180 --> 37:15.460]  что у точек есть общая, у прямых есть общая точка, значит, они обязательно совпадают,
[37:15.460 --> 37:19.820]  там просто все точки общие. Вот вопрос, можно ли как-нибудь найти какую-нибудь точку на прямой
[37:19.820 --> 37:29.340]  a и c плюс b, плюс c равно 0. Можно найти какую-нибудь точку.
[37:39.620 --> 37:44.020]  Так, ну здесь, видимо, те же самые проблемы. Давайте скажем следующее, что в обычном случае,
[37:44.020 --> 37:48.820]  когда у меня прямая не вертикальная и не горизонтальная, можно, ну там точно есть точка
[37:48.820 --> 37:59.300]  с координатой y равно 1. Точно есть точка с координатой y равно 1. Да, тогда надо просто посчитать,
[37:59.300 --> 38:08.860]  чему равно x. Тогда x это минус b, минус c, делить на a. Значит, в случае, когда a не равно 0, у меня
[38:08.860 --> 38:15.580]  на прямой обязательно лежит вот такая точка, минус b, минус c, делить на a за 2 единицы. Так,
[38:15.580 --> 38:24.580]  добился ли я чего-нибудь полезного от этого? Кажется, нет, потому что я хотел сделать как-нибудь
[38:24.580 --> 38:29.260]  это без делений, потому что вот здесь вот так. Не очень хорошо, что мы, если в тупую это реализовывать,
[38:29.260 --> 38:34.540]  то мы по сути написали деление двух чисел. И если до этого все было целочисленное, да, и скажем,
[38:34.540 --> 38:39.540]  мне нужно просто проверить, прямые совпадают или нет, то хотелось бы это все тоже сделать в целых числах
[38:39.540 --> 38:44.380]  без делений. Ну, понятно, что этот способ, который выше, вот этот вот, его, конечно, можно сделать в целых
[38:44.380 --> 38:48.940]  числах, просто сохранить вот это отношение a1 делить на a2 как, ну, числитель-знаменатель,
[38:48.940 --> 38:57.980]  да, без деления явного. И тогда подставляя его сюда, просто проверять, что b1 равно a1 b2 делить на a2,
[38:57.980 --> 39:02.460]  и просто это a2 перенести сюда, и будет все хорошо. То есть понятно, что это можно сделать в целом. Вот здесь
[39:02.460 --> 39:07.340]  я хотел придумать какую-нибудь такую точку, которая заведомо целочисленная, но что-то как-то
[39:07.340 --> 39:15.980]  не зашло, не зашло. Ну и, видимо, в общем случае я не верю, что это делается, потому что если мы
[39:15.980 --> 39:21.380]  фиксируем какую-то из переменных x и y, тогда мне нужно будет поделить, скажем, когда мы фиксировали
[39:21.380 --> 39:26.820]  y, мне нужно будет вот это поделить на a и добиться того, чтобы это делилось на a нацело. Не очень понятно,
[39:26.820 --> 39:33.500]  как, потому что у меня есть слагаемая c, да, и непонятно, как не возбавляться. Поэтому предлагаю
[39:33.500 --> 39:39.180]  предзабить. И действительно, чтобы проверить, что не совпадает, надо просто проверить пропорциональность
[39:39.180 --> 39:54.980]  коэффициентов. Да, ваш метод рабочий. Хорошо, хорошо это сделали. Давайте еще одну штучку,
[39:54.980 --> 40:01.860]  здесь же про пересечение. Это пересечение окружности и прямой. Пересечение окружности и прямой.
[40:01.860 --> 40:08.940]  Ну, сначала, как можно хранить окружность? Окружность можно хранить центром, вот этой
[40:08.940 --> 40:16.620]  вот точкой p, которая является центром окружности, а также ее радиусом, радиусом r. Соответственно,
[40:16.620 --> 40:24.020]  там для удобства можно написать какую-нибудь структуру, которая хранит точку p и одно число r,
[40:24.020 --> 40:32.180]  одно число r-радиус. Вот и вопрос, как решить. Какую задачу погнать и вот эти точки пересечения
[40:32.180 --> 40:48.420]  прямой ax plus bk plus c равно нулю и окружности центров p радиуса r? Так, сейчас, секунду. Да. Ну,
[40:48.420 --> 40:54.900]  у нас интересует просто, чтобы расстояние от p до прямой было меньше или равно радиусу. Да,
[40:54.900 --> 41:04.620]  это мы проверяем наличие пересечения. Пересечение вообще есть? Пересечение есть. Если только,
[41:04.620 --> 41:11.220]  если distance от p до l, давайте опять прямой назову l-кой, меньше либо равно радиусу.
[41:11.220 --> 41:16.940]  Мы можем сейчас, кстати, разделить отдельное на случае меньше и равно, потому что в случае
[41:16.940 --> 41:21.260]  равенства будет касание. Да, все верно. В случае, в случае равенства действительно,
[41:21.260 --> 41:27.500]  когда расстояние от p до l равно r, это значит, что у меня картина какая-то вот такая. Да,
[41:27.500 --> 41:36.300]  и прямая у меня пересекает окружность в одной точке. Это случай distance равно r. Ну, соответственно,
[41:36.300 --> 41:40.740]  когда distance меньше, чем r, то у меня происходит пересечение в двух точках, вот этих вот двух.
[41:40.740 --> 41:45.860]  И смотрите, здесь можно было бы действовать совершенно наивно, сказать, что по сути мы
[41:45.860 --> 41:49.780]  решаем вот такую систему уравнений. То есть при вот этом условии, когда мы поняли, скажем,
[41:49.780 --> 41:54.860]  что пересечения в принципе существуют, иначе нужно сказать, что их нету. При этом условии мы
[41:54.860 --> 42:01.380]  решаем такую систему уравнений. Значит, уравнений прямой, а также уравнений окружности. Уравнений
[42:01.380 --> 42:09.380]  окружности можно писать так. Давайте опять скажем, что у p картината x0, y0. Тогда уравнение окружности
[42:09.380 --> 42:21.420]  задается вот в таком вот виде. Это уравнение просто говорит, что расстояние до точки x0, y0 равно r. Ну,
[42:21.420 --> 42:27.900]  или точнее, квадрат расстояния равен r в квадрате. Это вот то, что написано в этой строчке. Можно
[42:27.900 --> 42:35.300]  дальше просто сказать, что ага, у меня есть две переменные x и y. Какой-то из коэффициентов a или b
[42:35.300 --> 42:43.300]  не равен нулю. Если а не равно нулю, тогда давайте разрешим уровень относительно x. Выразим x через y.
[42:43.300 --> 42:51.220]  Выразим x через y. Подставим его вот сюда, решим квадратно уравнение, найдем y, и по формуле выражения
[42:51.220 --> 42:59.180]  x через y найдем x. Валидный способ. Так можно сделать, но какие тут есть проблемы? Во-первых,
[42:59.180 --> 43:06.180]  ну ладно, наверное одна проблема. Я вижу одну проблему в таком методе. Проблема в том,
[43:06.180 --> 43:13.500]  что когда не понятно, кто равен нулю, что делать, короче, если a или b равно нулю. То есть хорошо
[43:13.500 --> 43:19.900]  общий код работает, если а не равно нулю. Какое выражение работает? Выражение x через y,
[43:19.900 --> 43:24.860]  и потом подстановка и подсчет x в конце. А если a равно нулю, то нужно, наоборот,
[43:24.860 --> 43:32.180]  y выражать через x, потому что то, что было выше, не работает. Поэтому нам нужно оба
[43:32.180 --> 43:36.660]  случая обработать, когда a равно нулю нужно y выражать, когда b равно нулю, то надо x выражать.
[43:36.660 --> 43:46.180]  И то это надо делать, поэтому нужно оба случая разбирать. Метод, который, мне кажется,
[43:46.180 --> 44:03.020]  чуть более экономен с точки зрения количества кода следующий. Давайте мы опустим перпендикуляр
[44:03.020 --> 44:07.940]  из центра окружности на нашу прямую. Лага перпендикуляра мы уже опускать умеем,
[44:07.940 --> 44:15.700]  то есть мы по сути найдем проекцию центра на нашу прямую. И у нас уже выше есть написанная процедура,
[44:16.580 --> 44:20.740]  то есть я ее там явно не прописывал, но понятно, что это можно сделать по точке и прямой, найти
[44:20.740 --> 44:25.540]  проекцию. А дальше, что дальше мне нужно от нее отступить, понятное дело, на одинаковое расстояние
[44:25.540 --> 44:29.580]  в обе стороны по этой прямой. Вот сюда на какое-то расстояние, сюда на то же самое расстояние,
[44:29.580 --> 44:34.180]  на то же самое, потому что картинка симметрична относительно вот такой вот оси.
[44:34.180 --> 44:41.860]  Значит, что нам теперь нужно будет сделать? Нам нужно будет найти направляющий вектор этой прямой,
[44:41.860 --> 44:49.780]  а это мы уже тоже знаем, как его находить через уравнение прямой. И останется найти длину
[44:49.780 --> 44:54.340]  вот этого вектора, и потом нам нужно будет просто от Q в обе стороны прибавить этот
[44:54.340 --> 44:58.900]  направляющий вектором ножом на эту длину. То есть направляющий вектор мы нормируем,
[44:58.900 --> 45:03.300]  чтобы он был длиной 1, и откладываем его влево, то есть с плюсиком на какую-то длину k,
[45:03.300 --> 45:10.580]  и вправо, то есть с минусиком, на ту же самую длину k. Вопрос только, какова это длина? Какова
[45:10.580 --> 45:21.060]  это длина k? Ну, она понятна какая. Это корень из 1 в квадрате минус расстояние от Q до Q,
[45:21.060 --> 45:28.100]  distance от Q до Q в квадрате. Потому что просто ремни фагора. У нас есть расстояние от Q до Q,
[45:28.100 --> 45:34.180]  у нас есть гипотенузы нашего катета, это радиус просто окружности. Значит,
[45:34.180 --> 45:37.940]  второй катет k – это вот такой корень. Корень из 1 в квадрате минус расстояние от Q до Q.
[45:37.940 --> 45:45.140]  Ну а расстояние от Q до Q тоже давайте напишем. Расстояние между точками – это
[45:45.140 --> 45:56.540]  px – qx в квадрате плюс px – y – qx в квадрате есть всего этого корня. Расстояние между точками,
[45:56.540 --> 46:02.180]  соответственно, здесь даже как бы не нужно вот этот корень извлекать. Если мы борцали
[46:02.180 --> 46:05.940]  за точность, то вот этот корень здесь не нужен, потому что по сути мы ищем только квадрат
[46:05.940 --> 46:11.740]  расстояния. И там нужна как функция считающих квадрат расстояния, т.е. не извлекающий корень.
[46:11.740 --> 46:17.860]  Вот потом соответственно мы посчитали это k путем однократного извлечения корня. Ну и в качестве
[46:17.860 --> 46:30.420]  этого мы разрешаем точки Q плюс kV и Q минус kV, если V – это направляющий вектор прямой единичной
[46:30.420 --> 46:48.820]  длины. Направляющий вектор l – единичной длины. Ну а в случае равенства, в случае, когда расстояние
[46:48.820 --> 46:55.420]  от p до l равно в точность r, тогда вот эти две точки будут одинаковые, там k будет равно 0. И,
[46:55.420 --> 47:00.700]  ну по сути, если не париться и написать просто то же самое, то вы вернуете две одинаковые точки,
[47:00.700 --> 47:08.540]  потому что когда вы так непрерывно сдвигаете вашу прямую вдоль точки касания, у вас точки
[47:08.540 --> 47:12.740]  прещения движутся на встречу друг к другу, и вот эта вот экстремальная ситуация, когда у вас
[47:12.740 --> 47:17.460]  прямая переходит в касательную, у вас точки склеиваются, образуется одна точка. Но здесь уже
[47:17.460 --> 47:22.820]  как бы зависит от деталей того, как вам нужно все обрабатывать. Если вам нужно прям конкретно
[47:22.820 --> 47:27.500]  вывести на множество точек, то нужно тогда отдельно случай за f и вернуть одну точку,
[47:27.500 --> 47:33.860]  просто q, просто основание перпендикулярно из p на l. Иначе, если точки прещения 2,
[47:33.860 --> 47:43.860]  то вот нужно плюс-минус kv добавить к q. Вот, у этого метода преимущество в том,
[47:43.860 --> 47:50.020]  что нам не нужно ждать два случая f, не нужно понимать, выражать x через y или y через x,
[47:50.020 --> 47:57.860]  а также мы существенно задействуем уже то, что написано выше. Чего у нас есть?
[47:57.860 --> 48:10.460]  Нам самое важное это найти проекцию точки напрямую, q найти, а дальше умножение числа на вектор,
[48:10.460 --> 48:16.300]  сложение двух векторов, вычитание двух векторов. Это у нас тоже уже все написано. Здесь как будто
[48:16.300 --> 48:22.740]  мы с нулям все делаем, да, не имея никаких уже написанных функций, поэтому это получили.
[48:22.740 --> 48:33.700]  Так, ну и последнее пересечение, это пересечение двух окружностей. Есть две окружности, соответственно,
[48:33.700 --> 48:45.580]  задаваемые своими центрами x1 и y1, x2 и y2 и радиусами r1 и r2. Наша задача понять их
[48:45.580 --> 48:54.580]  точки пересечения и пересекаются ли они вообще. Вот здесь можно написать кучу всего,
[48:54.580 --> 49:02.460]  можно развивать кучу случаев, решать систему квадратных управлений, все это можно делать,
[49:02.460 --> 49:07.900]  но все это на самом деле излишне и очень-очень громоздко, потому что здесь куча всяких неприятных
[49:07.900 --> 49:13.420]  случаев, типа, например, вот такого, когда одна окружность лежит внутри другой, соответственно,
[49:13.580 --> 49:18.540]  предельно случаи, когда они касаются по внутренности, предельно случаи, когда они,
[49:18.540 --> 49:25.900]  наоборот, ну там, сейчас, ну, касаются так вот по внешности. В общем, куча всяких неприятных случаев
[49:25.900 --> 49:31.580]  может быть их взаимного расположения. И, соответственно, как-то все это в нашем
[49:31.580 --> 49:36.220]  уровне, их квадратных управлений мы будем решать. Надо будет учитывать там какие-то, чтобы делить,
[49:36.220 --> 49:40.100]  оно же будет проверить, что там что-то не равно нулю и так далее и так далее. В общем, это все довольно
[49:40.100 --> 49:46.580]  неприятно. Гораздо проще сделать следующее. Давайте мы, ну, по сути, мы все также решаем вот
[49:46.580 --> 49:52.380]  такую систему уравнений, что мы ищем такие точки, которые находятся на расстоянии от первого центра
[49:52.380 --> 50:02.420]  на расстоянии r1 и на расстоянии второго центра равным r2. То есть, по сути, мы решаем ту же самую
[50:02.420 --> 50:09.820]  систему уравнений, только мы будем решать ее не как систему квадратных уравнений, а давайте
[50:09.820 --> 50:14.780]  вычтем из одного уравнений в другое. То есть, мы вычтем из одного ровнений в другое, то у меня
[50:14.780 --> 50:20.200]  как раз таки, ну, там, скажем, я первое, первое оставляю и записываю второе уравнение минус
[50:20.200 --> 50:26.460]  первое. Тогда, у меня вот в этом вот уравнении в втором, когда мы вычитаем первое и второе у меня
[50:26.460 --> 50:32.760]  сократятся все квадраты, потому что у меня здесь было x квадрат y квадрат и здесь тоже x квадрат y
[50:32.760 --> 50:36.580]  квадрат. И когда я их вычту, у меня все квадраты сократятся и будет просто такое линейное уравнение.
[50:36.580 --> 50:45.860]  ровнение. Эта штука это уже линейная относительно х и у. Линейная уравнение относительно х и у.
[50:45.860 --> 50:49.860]  То есть на самом деле, когда мы вычитаем из одного уровня другое, мы получаем уравнение вида ax
[50:49.860 --> 50:57.140]  плюс dy плюс c равно 0. То есть на самом деле мы получаем уравнение прямой, а дальше нам достаточно
[50:57.140 --> 51:02.380]  теперь решить такую систему уравнений. Первое уравнение и вот эта прямая, которая получается
[51:02.380 --> 51:06.060]  как разность наших двух окружностей. И вот это кажется как раз будет та самая прямая,
[51:06.060 --> 51:11.300]  которая через эти точки и проходит. Да-да-да-да-да-да-да. Да, конечно, потому что это такая прямая,
[51:11.300 --> 51:15.940]  на которой лежат точки причины наших окружностей. Ну, значит как раз вот эта самая прямая.
[51:15.940 --> 51:25.940]  Здесь я неявно подразумеваю, что вот эти вот две системы эквивалентны. Что множество решений
[51:25.940 --> 51:33.860]  системы 1 и 2 эквивалентно, ну точнее равно просто множество решений системы 1 и 2 минус 1.
[51:33.860 --> 51:41.180]  Тут, кстати, небольшая аналогия с алгоритмом Евклида, потому что как у нас было в алгоритме
[51:41.180 --> 51:45.740]  Евклида, что гцд двух вот таких вот чисел, правень гцд двух вот таких вот чисел,
[51:45.740 --> 51:52.380]  мы считаем из одного другое. То же самое, что если что-то и там какая-то точка x и y является
[51:52.380 --> 51:55.500]  решением левой системы, то она является решением и правой системы. И наоборот,
[51:55.500 --> 52:01.620]  если есть решение правой системы, то есть решение левой системы. Но неважно, шаг в сторону.
[52:01.620 --> 52:10.060]  Ну все, а пересекать окружность с прямой мы уже умеем. Это вот было выше. Если мы напишем процедуру,
[52:10.060 --> 52:15.140]  которая нам по окружности прямой находит их все пересечения или сообщает, что их нет,
[52:15.140 --> 52:19.100]  тогда нам нужно просто будет дернуть эту функцию, один раз просто вызвать функцию с
[52:19.100 --> 52:23.220]  нужными коэффициентами, и будет нам победа. Мы тоже найдем сервишкой пересечений.
[52:23.220 --> 52:30.300]  Вот здесь вот, когда мы говорим уже про пересечение, там сложных фигур, типа прямой
[52:30.300 --> 52:36.860]  окружности прямой и двух окружностей, здесь уже, видимо, никак не обойтись без перехода к доблам.
[52:36.860 --> 52:45.220]  Потому что, когда мы пересекали прямую окружность, нам нужно опустить проекцию,
[52:45.220 --> 52:50.020]  допустим, периметигулярно прямую, и потом от вектора отступить в обе стороны что-то. И понятно,
[52:50.020 --> 52:55.300]  что вот эти отступы, они там нужно извлекать в кучу корней, и тогда эти координаты на желудочных
[52:55.300 --> 52:59.660]  они уже совсем не обязательно рациональны, уже, возможно, произвольные вещественные,
[52:59.660 --> 53:03.300]  когда мы извлекаем корень, часто могут стать вещественными, а не рациональными.
[53:03.300 --> 53:06.900]  Но то же самое здесь, если мы пересечения окружности с великоперечения окружности прямой,
[53:06.900 --> 53:13.380]  то тоже мы здесь в рациональных уже не всегда сможем обойтись. Придется использовать плавающую
[53:13.380 --> 53:21.900]  точку и, соответственно, как-то накапливать ошибку, потому что если мы переходим к вещественным
[53:21.900 --> 53:26.740]  числам, к даблам, то, конечно, максимально точно мы их хранить не можем, там будет какая-то погрешность,
[53:26.740 --> 53:31.740]  всегда в наших вычислениях какая-то маленькая нок-нок будет. Кстати, а вообще, если у нас
[53:31.740 --> 53:37.020]  контест будет, то его можно будет залить на рейшналах или всё-таки слишком долго будет?
[53:37.020 --> 53:45.420]  Нет, ну обычно это не очень долго, обычно это не очень долго, ну, то есть, но для этого задача
[53:45.420 --> 53:49.380]  должна быть такой специфической, что в ней не нужно находить вот этих вот точек, да, то есть,
[53:49.380 --> 53:55.820]  там в частности нельзя будет пересекать прямые окружности, но если в прямой задаче этого не нужно,
[53:55.820 --> 54:02.180]  то, ну, там с широтностью 1 можно будет написать в рейшналах, но, скорее всего, можно будет и без
[54:02.180 --> 54:06.300]  этого написать, можно написать в даблах, как обычно, да, и просто там равенство проверить
[54:06.300 --> 54:11.380]  с помощью epsilon, чтобы проверить, что две точки одинаковые, вы проверяете, что у них разность по
[54:11.380 --> 54:21.940]  иксам не больше, и разность по иксам не больше. Скорее всего, можно будет так и так. Так, хорошо,
[54:21.940 --> 54:28.940]  давайте тогда последний примитив, который мы уже неярно пользовались, это скалярное векторное
[54:28.940 --> 54:35.380]  произведение. Скалярное, и, ну, вот это называется векторное, да, давайте мы называем его псевдовекторное,
[54:35.380 --> 54:49.700]  всё-таки псевдовекторное произведение. Векторное произведение это строгое, это в трёхмерном
[54:49.700 --> 54:53.660]  пространстве строгое определение, там, когда мы умножаем, в общем, когда мы считаем какой-то
[54:53.660 --> 55:01.100]  определитель, там всё хорошо определено, у нас такое кривое векторное произведение. Ну, скалярное
[55:01.100 --> 55:09.220]  произведение мы знаем, что такое, если у меня есть два вектора x1 и x2, то их скалярное произведение это
[55:09.220 --> 55:18.100]  по компонентной просто произведение и сумма. Это скалярное произведение. По-английски это называется dot
[55:18.100 --> 55:25.140]  product, произведение как бы через точку, вот, ну и я обычно пишу, если мне нужно скалярное произведение
[55:25.140 --> 55:34.020]  считать, то я пишу функцию dot, которая принимает две точки и соответственно возвращает их dot product, их скалярное произведение.
[55:34.020 --> 55:48.060]  Значит, если у меня есть два вектора u и v с вот этим координатом x1, y1, x2, y2, то можно также показать,
[55:48.060 --> 55:55.580]  что это скалярное произведение равно следующей величине u на v на косину с угла между ними, косину с этого
[55:55.580 --> 56:07.660]  угла phi. Это тоже скалярное произведение. Вот, ну давайте это там без заказательства, да, скорее всего это было в каком-нибудь
[56:07.660 --> 56:14.220]  опять линале, и это работает в любом пространстве любой размерности, если у вас есть два вектора, вы их вот так
[56:14.220 --> 56:20.140]  по компоненту перемножите и все сложите, то вы получите произведение их длины, умноженное на косину с угла между ними,
[56:20.140 --> 56:24.620]  причем косину с угла определен в любом пространстве, угол определен в любом пространстве, косину тоже можно
[56:24.620 --> 56:32.940]  посчитать. Вот это скалярное произведение, оно нам позволяет сделать, например, следующее, оно позволяет понять, какой
[56:32.940 --> 56:41.700]  угол между двумя векторами, потому что если угол между ними, скажем, острый, тогда это значит, что косинус phi больше
[56:41.700 --> 56:48.800]  0, если угол острый, значит скалярное произведение будет положительным, потому что произведение двух лин на косину с
[56:48.800 --> 56:53.340]  угла, который положительный, т.е. скалярное произведение будет положительным, если угол прямой между ними,
[56:53.340 --> 57:00.860]  то косинус Phi равно 0 и значит скалярное произведение тоже равно 0, раз у нас есть нулевой множитель,
[57:00.860 --> 57:05.820]  то значит все произведение равно 0, этим и пользовались, когда проверяли артагонали из двух векторов,
[57:05.820 --> 57:11.820]  что векторы антагональны, если их скалярное произведение равно 0.
[57:11.820 --> 57:16.820]  Последний случай, скажем, вот такой, когда между ними угол тупой.
[57:16.820 --> 57:22.820]  Угол тупой, соответственно, cos phi меньше 0, cos phi меньше 0.
[57:22.820 --> 57:25.820]  И значит, скалярное произведение отрицательное.
[57:25.820 --> 57:29.820]  То есть, по сути, знак скалярного произведения больше 0 равно 0 или меньше 0
[57:29.820 --> 57:32.820]  сообщает о типе угла между двумя векторами.
[57:32.820 --> 57:37.820]  Тупой он, острый или прямой.
[57:37.820 --> 57:41.820]  Три возможности, три возможных знака для скалярного произведения.
[57:41.820 --> 57:45.820]  Ну и отсюда же можно не просто узнать тип угла, но и найти значение угла.
[57:45.820 --> 57:48.820]  Достаточно просто взять cos от нужной штуки.
[57:48.820 --> 57:51.820]  Давайте скажем, пусть у меня есть скалярное произведение u и v.
[57:51.820 --> 57:53.820]  Я его так обозначу.
[57:53.820 --> 57:57.820]  Через скобки скалярное произведение.
[57:57.820 --> 58:02.820]  Тогда понятно, что cos phi это скалярное произведение.
[58:07.820 --> 58:09.820]  Делить на произведение длин.
[58:09.820 --> 58:13.820]  Делить на длину u умножить на длину v.
[58:13.820 --> 58:16.820]  Значит phi это просто arcosinus.
[58:16.820 --> 58:19.820]  phi равно, в плюсах это arcos.
[58:19.820 --> 58:22.820]  Не arc, а просто arcos.
[58:22.820 --> 58:24.820]  Вот уже две штуки.
[58:27.820 --> 58:29.820]  Ну и это наш угол phi.
[58:35.820 --> 58:38.820]  Причем, насколько я знаю,
[58:41.820 --> 58:44.820]  эта штука принимает значение от 0 до pi.
[58:44.820 --> 58:46.820]  От 0 до pi не включительно.
[58:46.820 --> 58:48.820]  Сейчас, секунду.
[58:48.820 --> 58:50.820]  Или включительно.
[58:51.820 --> 58:53.820]  Так.
[58:58.820 --> 59:00.820]  Наверное, включительно.
[59:00.820 --> 59:05.820]  Потому что если векторы вот так вот противоположны,
[59:07.820 --> 59:09.820]  то угол между ними равен pi.
[59:11.820 --> 59:15.820]  Мы можем также найти и угол между двумя прямыми,
[59:15.820 --> 59:19.820]  но уже с помощью такой еще более сложной тригонометрической функции.
[59:19.820 --> 59:24.820]  И на самом деле вообще во всей этой геометрии есть
[59:24.820 --> 59:27.820]  как минимум три класса функций.
[59:27.820 --> 59:32.820]  Первый – это всякие простые сложения, деления, умножения.
[59:32.820 --> 59:34.820]  Ну и то там лучше без деления, бойтесь.
[59:34.820 --> 59:37.820]  Это прямо наши любимые функции, которые в идеале вообще
[59:37.820 --> 59:40.820]  позволяют нам не переходить к веществным числам.
[59:40.820 --> 59:43.820]  Это сложение, умножение, на крайний случай деление.
[59:43.820 --> 59:46.820]  Потом есть всякие извлечения корней.
[59:46.820 --> 59:48.820]  Когда нам нужно там опускать периметикуляры,
[59:48.820 --> 59:50.820]  пересекать ровно степрему и так далее.
[59:50.820 --> 59:53.820]  Это вот всякие извлечения корней.
[59:53.820 --> 59:56.820]  Ну, собственно, там основная процедура – это извлечение корней.
[59:56.820 --> 59:58.820]  И третий тип функций – это всякие тригонометрические.
[59:58.820 --> 01:00:01.820]  Косинусы, синусы, арк-косинусы, арк-синусы.
[01:00:01.820 --> 01:00:05.820]  Это еще более неточные функции.
[01:00:05.820 --> 01:00:09.820]  И поэтому я рекомендую их избегать,
[01:00:09.820 --> 01:00:11.820]  только если нет явной необходимости.
[01:00:11.820 --> 01:00:14.820]  Понятно, что если вам нужно посчитать вектор между…
[01:00:14.820 --> 01:00:16.820]  В условиях, грубо говоря, написано,
[01:00:16.820 --> 01:00:18.820]  что нужно найти вектор между двумя отрезками,
[01:00:18.820 --> 01:00:19.820]  между двумя векторами,
[01:00:19.820 --> 01:00:22.820]  то, понятно дело, вам нужно вызвать арк-косинус.
[01:00:22.820 --> 01:00:24.820]  Понятно, что без этого никак.
[01:00:24.820 --> 01:00:25.820]  Но если вам это не нужно,
[01:00:25.820 --> 01:00:28.820]  если вам, скажем, нужно только вывести тупой угол,
[01:00:28.820 --> 01:00:29.820]  острый или прямой,
[01:00:29.820 --> 01:00:31.820]  то вы считаете скалярное произведение.
[01:00:31.820 --> 01:00:33.820]  Причем, возможно, вам для этого хватит интов,
[01:00:33.820 --> 01:00:35.820]  ну, или там, лонг-лонгов.
[01:00:35.820 --> 01:00:36.820]  Вы считаете скалярное произведение
[01:00:36.820 --> 01:00:38.820]  и по знаку определяете тип угла.
[01:00:38.820 --> 01:00:40.820]  То есть не нужно его сам находить
[01:00:40.820 --> 01:00:42.820]  и потом там сравнивать спип пополам,
[01:00:42.820 --> 01:00:44.820]  чтобы понять, тупой он или острый.
[01:00:44.820 --> 01:00:46.820]  Чтобы понять его тип,
[01:00:46.820 --> 01:00:48.820]  можно просто посмотреть на знак скалярного произведения.
[01:00:49.820 --> 01:00:51.820]  Поэтому, как говорится,
[01:00:51.820 --> 01:00:53.820]  I cannot stress this enough.
[01:00:53.820 --> 01:00:56.820]  Невозможно это переоценить.
[01:00:56.820 --> 01:00:59.820]  Старайтесь использовать как можно более простые функции.
[01:00:59.820 --> 01:01:01.820]  Если можно обойтись без тригонометрии,
[01:01:01.820 --> 01:01:02.820]  то обходитесь.
[01:01:02.820 --> 01:01:05.820]  Если можно обойтись без извлечения корней,
[01:01:05.820 --> 01:01:06.820]  обходитесь.
[01:01:06.820 --> 01:01:08.820]  Старайтесь как бы использовать умножение,
[01:01:08.820 --> 01:01:10.820]  где-то можно, вычитание, где можно.
[01:01:10.820 --> 01:01:13.820]  Потом, если этого не хватает,
[01:01:13.820 --> 01:01:14.820]  то извлечение корней.
[01:01:14.820 --> 01:01:16.820]  И потом только в самом крайнем случае
[01:01:16.820 --> 01:01:18.820]  это вообще косинусы, синусы, тангенсы
[01:01:18.820 --> 01:01:20.820]  и все такое прочее.
[01:01:20.820 --> 01:01:22.820]  Потому что эти функции сильно менее точны.
[01:01:22.820 --> 01:01:24.820]  Да, у нас
[01:01:24.820 --> 01:01:26.820]  ну, вполне бывает такое, что
[01:01:26.820 --> 01:01:28.820]  из-за точности,
[01:01:28.820 --> 01:01:30.820]  из-за того, что у нас накапливается погрешность,
[01:01:30.820 --> 01:01:32.820]  когда мы делаем много-много-много вычислений,
[01:01:32.820 --> 01:01:34.820]  у меня погрешность накапливается
[01:01:34.820 --> 01:01:36.820]  и, возможно, там
[01:01:36.820 --> 01:01:38.820]  результат мы бы считаем слишком плохой,
[01:01:38.820 --> 01:01:40.820]  не достаточно точно.
[01:01:42.820 --> 01:01:44.820]  Ну вот, что я хотел сказать.
[01:01:46.820 --> 01:01:50.820]  Так, есть ли вопросы какие-нибудь сейчас?
[01:01:54.820 --> 01:01:56.820]  Если нет, тогда давайте перейдем к триангуляции.
[01:01:58.820 --> 01:02:02.820]  Триангуляции многоугольников.
[01:02:06.820 --> 01:02:08.820]  Триангуляции многоугольников.
[01:02:10.820 --> 01:02:12.820]  Значит, здесь задача такая.
[01:02:12.820 --> 01:02:14.820]  Есть у вас какой-то многоугольник,
[01:02:14.820 --> 01:02:16.820]  а именно
[01:02:16.820 --> 01:02:18.820]  что такое многоугольник?
[01:02:18.820 --> 01:02:20.820]  Это какая-то замкнутая, не самая пересекающая, сломанная.
[01:02:20.820 --> 01:02:22.820]  Вот я что-то такое нарисовал.
[01:02:22.820 --> 01:02:24.820]  И нам нужно его триангулировать.
[01:02:24.820 --> 01:02:26.820]  То есть провести там несколько
[01:02:26.820 --> 01:02:28.820]  отрезков между вершинами,
[01:02:28.820 --> 01:02:30.820]  так чтобы все разбилось на треугольнике.
[01:02:30.820 --> 01:02:32.820]  Давайте нарисуем какую-нибудь триангуляцию.
[01:02:44.820 --> 01:02:46.820]  Так, вроде нарисовал.
[01:02:46.820 --> 01:02:48.820]  Значит, мне нужно провести какие-то отрезки
[01:02:48.820 --> 01:02:50.820]  между вершинами, так чтобы все разбилось
[01:02:50.820 --> 01:02:52.820]  на треугольнике, ну и причем вот эти вот отрезки,
[01:02:52.820 --> 01:02:54.820]  которые я провожу, они лежали с рук
[01:02:54.820 --> 01:02:56.820]  внутри нашего многоугольника.
[01:02:56.820 --> 01:02:58.820]  То есть, понятное дело, что вот такой, скажем,
[01:02:58.820 --> 01:03:00.820]  отрезок, он бессмысленный,
[01:03:00.820 --> 01:03:02.820]  он не отсекает никого треугольника.
[01:03:02.820 --> 01:03:04.820]  Он плохой, его нельзя рисовать.
[01:03:04.820 --> 01:03:06.820]  Вот эти отрезки мы будем называть диагональными.
[01:03:06.820 --> 01:03:08.820]  Диагонали.
[01:03:08.820 --> 01:03:10.820]  То есть диагонали это,
[01:03:10.820 --> 01:03:12.820]  это просто какие-то отрезки, которые
[01:03:12.820 --> 01:03:14.820]  целиком лежат внутри многугольника.
[01:03:14.820 --> 01:03:16.820]  Точнее, это отрезки между вершинами,
[01:03:16.820 --> 01:03:18.820]  отрезки
[01:03:18.820 --> 01:03:20.820]  между
[01:03:20.820 --> 01:03:22.820]  не соседними вершинами,
[01:03:26.820 --> 01:03:28.820]  не соседними вершинами,
[01:03:28.820 --> 01:03:30.820]  целиком лежащие
[01:03:30.820 --> 01:03:32.820]  внутри многугольника.
[01:03:32.820 --> 01:03:34.820]  Даже я скажу, во внутренности.
[01:03:34.820 --> 01:03:36.820]  То есть,
[01:03:36.820 --> 01:03:38.820]  вот эти отрезки,
[01:03:38.820 --> 01:03:40.820]  даже я скажу, во внутренности.
[01:03:42.820 --> 01:03:44.820]  Во внутренности
[01:03:48.820 --> 01:03:50.820]  многугольника.
[01:03:58.820 --> 01:04:00.820]  Вот, про эту триангуляцию есть
[01:04:00.820 --> 01:04:02.820]  ну, такой а-ля
[01:04:02.820 --> 01:04:04.820]  практический повод это вообще изучать.
[01:04:04.820 --> 01:04:06.820]  Это примерно следующее. Вот представьте,
[01:04:06.820 --> 01:04:08.820]  у вас есть какая-нибудь музейная галерея,
[01:04:08.820 --> 01:04:10.820]  в которой хранятся какие-то картины
[01:04:10.820 --> 01:04:12.820]  или что угодно.
[01:04:12.820 --> 01:04:14.820]  И вот вся галерея задается таким вот,
[01:04:14.820 --> 01:04:16.820]  каким-то странным многугольником.
[01:04:16.820 --> 01:04:18.820]  Бог знает, почему-то архитектор
[01:04:18.820 --> 01:04:20.820]  выдел вам вот такое помещение
[01:04:20.820 --> 01:04:22.820]  очень странное, с кучей углов.
[01:04:22.820 --> 01:04:24.820]  Вы поставили картины,
[01:04:24.820 --> 01:04:26.820]  и вам нужно поставить несколько камер
[01:04:26.820 --> 01:04:28.820]  или поставить несколько
[01:04:28.820 --> 01:04:30.820]  вахтёрж, которые будут сидеть на своих
[01:04:30.820 --> 01:04:32.820]  стульчиках и смотреть, что вокруг них,
[01:04:32.820 --> 01:04:34.820]  всё, что они видят, всё хорошо.
[01:04:34.820 --> 01:04:36.820]  И это не получается украсть,
[01:04:36.820 --> 01:04:38.820]  или там что камеры видят, что вокруг них
[01:04:38.820 --> 01:04:40.820]  никто не пытается там нарисовать что-нибудь плохое
[01:04:40.820 --> 01:04:42.820]  на картине.
[01:04:42.820 --> 01:04:44.820]  Тогда задача сводится к тому,
[01:04:44.820 --> 01:04:46.820]  чтобы поставить какие-то точки
[01:04:46.820 --> 01:04:48.820]  внутри нашего многугольника,
[01:04:48.820 --> 01:04:50.820]  так чтобы всё, ну,
[01:04:50.820 --> 01:04:52.820]  из каждой точки
[01:04:52.820 --> 01:04:54.820]  был виден
[01:04:54.820 --> 01:04:56.820]  какой-то кусок вашего многугольника,
[01:04:56.820 --> 01:04:58.820]  и при этом объединение этих кусков было
[01:04:58.820 --> 01:05:00.820]  равно всему вашему многугольнику.
[01:05:00.820 --> 01:05:02.820]  Вот, например, если я поставлю точку где-нибудь
[01:05:02.820 --> 01:05:04.820]  здесь, вот, то я
[01:05:04.820 --> 01:05:06.820]  не буду видеть, не знаю, там, что-нибудь вот здесь,
[01:05:06.820 --> 01:05:08.820]  потому что вот этот отрезок,
[01:05:08.820 --> 01:05:10.820]  он проходит, как бы, частично
[01:05:10.820 --> 01:05:12.820]  через границу нашего прямоугольника, и даже
[01:05:12.820 --> 01:05:14.820]  где-то вне, поэтому из-за вот этой вот
[01:05:14.820 --> 01:05:16.820]  стенки я что-то видеть не буду.
[01:05:16.820 --> 01:05:18.820]  Вот эту точку я видеть не буду.
[01:05:18.820 --> 01:05:20.820]  Ну, а там кажется, что если поставить
[01:05:22.820 --> 01:05:24.820]  точку где-то вот здесь, то, видимо,
[01:05:24.820 --> 01:05:26.820]  из неё вообще всё видно. Ну, если
[01:05:26.820 --> 01:05:28.820]  вот этот угол, он там, то есть
[01:05:28.820 --> 01:05:30.820]  если его так усилить, то он будет не видно.
[01:05:30.820 --> 01:05:32.820]  Вот, если он такой, как на картинке,
[01:05:32.820 --> 01:05:34.820]  то всё видно.
[01:05:34.820 --> 01:05:36.820]  Вот, ну, в общем случае
[01:05:36.820 --> 01:05:38.820]  можно действовать так. То есть это наш
[01:05:38.820 --> 01:05:40.820]  хороший случай, когда там вообще одна точка всё покрывается.
[01:05:40.820 --> 01:05:42.820]  В общем случае, это не обязательно так.
[01:05:42.820 --> 01:05:44.820]  Вот, и, соответственно,
[01:05:44.820 --> 01:05:46.820]  задача такая. Сколько нужно
[01:05:46.820 --> 01:05:48.820]  поместить, или там, сколько достаточно
[01:05:48.820 --> 01:05:50.820]  поместить вахтёрш, чтобы они всё видели.
[01:05:50.820 --> 01:05:52.820]  Простой решение такое. Давайте мы
[01:05:52.820 --> 01:05:54.820]  построим треангуляцию нашего
[01:05:54.820 --> 01:05:56.820]  многугольника вот такими вот диагональками,
[01:05:56.820 --> 01:05:58.820]  и в каждом треугольнике просто назначим
[01:05:58.820 --> 01:06:00.820]  бабушку, которая там будет сидеть и совсем наблюдать.
[01:06:00.820 --> 01:06:02.820]  Тогда получается, что нам нужно
[01:06:02.820 --> 01:06:04.820]  бабушек ровно столько, сколько треугольников.
[01:06:04.820 --> 01:06:06.820]  Да, сколько, сколько треугольников.
[01:06:06.820 --> 01:06:08.820]  Ну и вот, понятное дело,
[01:06:08.820 --> 01:06:10.820]  просто
[01:06:10.820 --> 01:06:12.820]  упражнение, что
[01:06:12.820 --> 01:06:14.820]  треугольников в треангуляции
[01:06:14.820 --> 01:06:16.820]  всегда равна
[01:06:16.820 --> 01:06:18.820]  n-2.
[01:06:18.820 --> 01:06:20.820]  Треугольников всегда
[01:06:20.820 --> 01:06:22.820]  ровно
[01:06:22.820 --> 01:06:24.820]  n-2, где
[01:06:24.820 --> 01:06:26.820]  n – это число в вершин высходном многугольнике.
[01:06:28.820 --> 01:06:30.820]  Число вершин в многугольнике.
[01:06:34.820 --> 01:06:36.820]  Ну, потому что
[01:06:36.820 --> 01:06:38.820]  если у вас есть один, если у вас
[01:06:38.820 --> 01:06:40.820]  n равно тройке, то у вас
[01:06:40.820 --> 01:06:42.820]  просто
[01:06:42.820 --> 01:06:44.820]  индукция, если n равно тройке,
[01:06:44.820 --> 01:06:46.820]  то у вас есть один треугольник всего,
[01:06:46.820 --> 01:06:48.820]  он сам по себе равен
[01:06:48.820 --> 01:06:50.820]  тому, чему нужно. Если там
[01:06:50.820 --> 01:06:52.820]  для n это верно, и вы
[01:06:52.820 --> 01:06:54.820]  находите для большего n, то вы порвете
[01:06:54.820 --> 01:06:56.820]  одну диагональ, разбиваете ваш
[01:06:56.820 --> 01:06:58.820]  треугольник на два куска, там
[01:06:58.820 --> 01:07:00.820]  левый и правый, здесь там k-2
[01:07:00.820 --> 01:07:02.820]  треугольника, здесь m-2, и в сумме
[01:07:02.820 --> 01:07:04.820]  там k плюс m
[01:07:04.820 --> 01:07:06.820]  равно
[01:07:08.820 --> 01:07:10.820]  n плюс 2, потому что вот эти две точки
[01:07:10.820 --> 01:07:12.820]  на пересечении многугольников, они учатся
[01:07:12.820 --> 01:07:14.820]  два раза. Вот так вот я
[01:07:14.820 --> 01:07:16.820]  коротко доказал.
[01:07:16.820 --> 01:07:18.820]  Ну вот, значит, в итоге всегда обязательно
[01:07:18.820 --> 01:07:20.820]  хватит n-2 фактёрж,
[01:07:20.820 --> 01:07:22.820]  но можно даже делать лучше.
[01:07:22.820 --> 01:07:24.820]  Давайте тоже упражнение, которое я, наверное,
[01:07:24.820 --> 01:07:26.820]  в итоге в семинар вставлю, что из этой
[01:07:26.820 --> 01:07:28.820]  конструкции можно показать, что
[01:07:28.820 --> 01:07:30.820]  всегда достаточно...
[01:07:30.820 --> 01:07:32.820]  Так, сколько их?
[01:07:32.820 --> 01:07:34.820]  Ну, видимо, n делит на 3
[01:07:34.820 --> 01:07:36.820]  фактёрж,
[01:07:38.820 --> 01:07:40.820]  чтобы обозреть весь
[01:07:40.820 --> 01:07:42.820]  многугольник.
[01:07:42.820 --> 01:07:44.820]  Обозреть весь
[01:07:44.820 --> 01:07:46.820]  многугольник.
[01:07:46.820 --> 01:07:48.820]  То есть достаточно поставить
[01:07:48.820 --> 01:07:50.820]  не в каждом треугольнике, но, грубо говоря,
[01:07:50.820 --> 01:07:52.820]  не в каждом треугольнике,
[01:07:52.820 --> 01:07:54.820]  а в каждом третьем треугольнике,
[01:07:54.820 --> 01:07:56.820]  тогда тоже всё можно будет увидеть.
[01:07:56.820 --> 01:07:58.820]  А точно вниз?
[01:08:00.820 --> 01:08:02.820]  Да, да,
[01:08:02.820 --> 01:08:04.820]  да.
[01:08:06.820 --> 01:08:08.820]  Вот. Ну, на семинаре
[01:08:08.820 --> 01:08:10.820]  надеюсь разберём ещё.
[01:08:10.820 --> 01:08:12.820]  Разберёте.
[01:08:12.820 --> 01:08:14.820]  Так, для нас,
[01:08:14.820 --> 01:08:16.820]  ну и ещё здесь же упражнение,
[01:08:16.820 --> 01:08:18.820]  причём бывают многугольники, для которых
[01:08:18.820 --> 01:08:20.820]  нельзя обойтись меньшим числом фактёрж.
[01:08:20.820 --> 01:08:22.820]  Бывают многугольники.
[01:08:24.820 --> 01:08:26.820]  Многугольники,
[01:08:28.820 --> 01:08:30.820]  для которых
[01:08:32.820 --> 01:08:34.820]  необходимо...
[01:08:36.820 --> 01:08:38.820]  Ну, я здесь не уверен, что n на 3,
[01:08:38.820 --> 01:08:40.820]  но там точно n делит на 3
[01:08:40.820 --> 01:08:42.820]  минус константа.
[01:08:42.820 --> 01:08:44.820]  Необходимо n делить на 3
[01:08:44.820 --> 01:08:46.820]  минус константа
[01:08:46.820 --> 01:08:48.820]  фактёрж.
[01:08:48.820 --> 01:08:50.820]  То есть, по порядку
[01:08:50.820 --> 01:08:52.820]  у нас будет правильная
[01:08:52.820 --> 01:08:54.820]  оценка.
[01:08:54.820 --> 01:08:56.820]  То есть, что n на 3
[01:08:56.820 --> 01:08:58.820]  иногда достигается, и всегда достаточно
[01:08:58.820 --> 01:09:00.820]  n на 3.
[01:09:00.820 --> 01:09:02.820]  Ну, а мы,
[01:09:02.820 --> 01:09:04.820]  мотивировавшись как бы этим примером
[01:09:04.820 --> 01:09:06.820]  про музей, построим алгоритм
[01:09:06.820 --> 01:09:08.820]  реангуляции произвольного многугольника
[01:09:08.820 --> 01:09:10.820]  за n в квадрате.
[01:09:10.820 --> 01:09:12.820]  Реангуляция.
[01:09:12.820 --> 01:09:14.820]  Реангуляция
[01:09:14.820 --> 01:09:16.820]  за...
[01:09:16.820 --> 01:09:18.820]  За...
[01:09:18.820 --> 01:09:20.820]  Ещё первый случай, который
[01:09:20.820 --> 01:09:22.820]  так просто обсудим, что если
[01:09:22.820 --> 01:09:24.820]  многугольник выпуклый,
[01:09:24.820 --> 01:09:26.820]  то это можно сделать просто за от и
[01:09:28.820 --> 01:09:30.820]  потому что
[01:09:30.820 --> 01:09:32.820]  выпуклый многугольник и всё
[01:09:32.820 --> 01:09:34.820]  отлично. Мы, скажем, можем взять просто одну вершину,
[01:09:34.820 --> 01:09:36.820]  провести из неё все диагоны
[01:09:36.820 --> 01:09:38.820]  и тогда автоматически всё разобьётся
[01:09:38.820 --> 01:09:40.820]  на треугольнике. И из-за выпуклости
[01:09:40.820 --> 01:09:42.820]  у меня не будет таких проблем, что там какая-то
[01:09:42.820 --> 01:09:44.820]  диагональ как-то пересекает вдруг
[01:09:44.820 --> 01:09:49.500]  или что-то такое, в выпуклом случае все прям идеально, мы просто проводим вот эти отрезки,
[01:09:49.500 --> 01:09:57.360]  и это будет наша реангуляция. Здесь все шикарно, просто, и думать ни на чем не нужно. Поэтому считаем,
[01:09:57.360 --> 01:10:02.100]  что наш нагугольник не выпуклый, и соответственно тогда задача интересная, потому что провести
[01:10:02.100 --> 01:10:08.220]  отрезок не всегда понятно, можно ли его провести или нет. Иногда там он может пересекаться в другие
[01:10:08.220 --> 01:10:13.300]  стороны, или там в каком-то треугольнике могут держать другие точки, вот это все нужно отслеживать.
[01:10:13.300 --> 01:10:27.780]  Ну хорошо, давай тогда докажем следующее утверждение. Сначала определение. Ухом в нагугольнике
[01:10:27.780 --> 01:10:31.740]  называется
[01:10:42.100 --> 01:10:45.220]  треугольник
[01:10:45.220 --> 01:10:59.060]  в и-1, в и, в и плюс один, то есть образованы тремя последовательными вершинами, которые целиком
[01:10:59.060 --> 01:11:19.980]  лежит в нагугольнике, и при этом внутри этого треугольника нет других вершин.
[01:11:19.980 --> 01:11:31.220]  То есть ухо, это как раз то, что мы будем отрезать. Вот такой треугольник торчащий где-то,
[01:11:31.220 --> 01:11:36.060]  который можно отрезать, который можно сгладить, оставить одним треугольником и
[01:11:36.060 --> 01:11:40.620]  треангулировать все остальное. Ну картинки какие-нибудь здесь такие можно нарисовать.
[01:11:40.620 --> 01:11:47.060]  В хорошем случае, когда есть какой-то такой нагугольник, у меня вот это вот является хорошим
[01:11:47.060 --> 01:11:55.100]  ухом. То есть это такой треугольник из трех подряд задушек вершин, где внутри ничего нет другого.
[01:11:55.100 --> 01:12:06.260]  Это хороший случай. Плохой случай, например, вот такой, когда угол при вершине больше чем 180
[01:12:06.260 --> 01:12:12.100]  градусов, то есть как бы угол вот такой вот лежащий во внутренности, и мы как будто бы смотрим на вот
[01:12:12.100 --> 01:12:18.980]  такой вот треугольник, построенный по вот этим трёх сторонам, и это по трём вершинам. Это плохой
[01:12:18.980 --> 01:12:24.020]  треугольник, потому что он не лежит во внутренности, он лежит где-то там вовне. Ещё плохой пример это,
[01:12:24.020 --> 01:12:33.820]  когда ну просто что-нибудь вот такое происходит, когда вы проводите тогда отрезок между вашими
[01:12:33.820 --> 01:12:38.340]  вершинками и минус первый и плюс первый, у вас внутри может лежать какая-то другая вершина,
[01:12:38.340 --> 01:12:43.020]  и соответственно тогда у вас автоматически это не ухо, вы не можете его отрезать, перейдя к другому на
[01:12:43.020 --> 01:12:50.020]  другому. А у нас такое может быть вообще? Потому что у нас же тогда следующая вершина просто будет другой.
[01:12:50.020 --> 01:12:59.340]  Ну смотрите, следующее у нас идёт в понимании просто звеньев ломаных. У нас вершины задаются так,
[01:12:59.340 --> 01:13:09.420]  там не знаю, первая, вторая, третья, четвёртая, пятая, шестая и так далее. Как мы тогда соединили третью с первой,
[01:13:09.420 --> 01:13:14.100]  если после неё есть ещё какое-то количество? Нет, ну смотрите, мы её соединяем, вот это красное ребро,
[01:13:14.100 --> 01:13:21.620]  это как бы попытка провести, сейчас, возможно здесь чёрное, это я плохо нарисовал. Сейчас, сейчас, одну секунду.
[01:13:21.620 --> 01:13:27.820]  Нет, я имею в виду мы же соединяем как бы, берём треугольник на трёх подряд идущих вершинах, а здесь
[01:13:27.820 --> 01:13:34.020]  не подряд идут. Нет, так вот же три подряд, вот эта первая, вот эта вторая, следующая за ней, вот эта третья, следующая за
[01:13:34.020 --> 01:13:42.620]  второй. Ой, да, да, извините. Окей, окей. Вот, и последний пример я нарисую, близкий к предыдущему, это вот такой пример.
[01:13:42.620 --> 01:13:53.020]  И вот здесь какое-то такое касание происходит. То есть почти всё, почти всё идеально, только на вот
[01:13:53.020 --> 01:13:59.180]  этой вот стороне лежит какая-то другая вершина. Это тоже плохо, мы такого будем избегать, потому что
[01:13:59.180 --> 01:14:06.300]  после этого наш треугольник распределяется на два несвязанных, и это плохо, мы такого не хотим. Вот что такое ухо,
[01:14:06.300 --> 01:14:12.700]  это вот треугольник из трёх подряд ищущих вершин, который можно отрезать. Утверждение, в любом
[01:14:12.700 --> 01:14:19.340]  многогольнике, ну давайте мы напишем в любом простом многогольнике. Простой это значит, что его
[01:14:19.340 --> 01:14:26.340]  стороны попарно не пересекаются, то есть у него нет самоперещений, то есть без самоперещений.
[01:14:26.340 --> 01:14:36.740]  То есть его граница, это одна замкнутая ломанная без самоперещений, какая-то такая штука, а не вот
[01:14:36.740 --> 01:14:44.620]  такая какая-то, которая пересекает сама себя много раз. В любом простом многогольнике,
[01:14:44.620 --> 01:14:57.220]  хотя бы четыре, есть хотя бы два не пересекающихся уха, есть хотя бы два не пересекающихся по
[01:14:57.220 --> 01:15:14.540]  внутренности. Доказательства индукции по построению, индукция палин, индукция
[01:15:14.540 --> 01:15:23.260]  ПП. База N-4 у нас есть всего два, ну два типа многогольников на N-4. Это как для N-3 у нас
[01:15:23.260 --> 01:15:29.660]  есть всего один треугольник, так для N-4 у нас есть выпуклый четырёхугольник, вот такой вот, и не
[01:15:29.660 --> 01:15:35.660]  выпуклый, такая вот галочка вложенная, такая вот галочка. Ну понятно, что у них у обоих есть два уха,
[01:15:35.660 --> 01:15:43.660]  первое и второе, здесь тоже первое и второе. Причем, если в выпуклом случае мы можем так,
[01:15:43.660 --> 01:15:48.420]  ну найти такие два уха без самоперещений двумя способами, то есть можно провести вот эту красную
[01:15:48.420 --> 01:15:51.860]  диагональ, можно провести вот такую зеленую противоположную, и будет другое разгонение
[01:15:51.860 --> 01:15:57.940]  на два уха. Ну не важно, главное, что оно какое-то есть. В не выпуклом случае тоже оно есть, причем
[01:15:57.940 --> 01:16:07.420]  оно обязательно только одно, только одно только разгонение на два уха. Теперь переход. Давайте
[01:16:07.420 --> 01:16:17.540]  мы посмотрим на какую-то вершину произвольную, которая выпуклая. Выпуклая вершина. Что это значит?
[01:16:17.540 --> 01:16:28.660]  Произвольная выпуклая вершина. Ну это значит как раз, что угол при ней меньше чем 180 градусов,
[01:16:28.660 --> 01:16:37.340]  вот такой был меньше, чем P. Выше я рисовал картинку, где угол при вершине был больше 180
[01:16:37.340 --> 01:16:43.260]  градусов, давайте его установлю. Вот какая такая, если картинка, да, то есть когда вы идете от
[01:16:43.260 --> 01:16:48.980]  одной стороны к другой, когда вы делаете такой поворот, вы поворачиваетесь на 270 градусов,
[01:16:48.980 --> 01:16:55.180]  например, когда у вас во в нужности лежит большой угол. Это плохо, это тогда не выпуклая вершина,
[01:16:55.180 --> 01:17:00.060]  а выпуклая вершина, это когда у вас этот угол при ней меньше чем P. Обычно нормальный угол
[01:17:00.060 --> 01:17:08.460]  поворота. Какая-то такая картина. Итак, рассматриваем произвольную выпуклую вершину WE и двух ее соседей,
[01:17:08.460 --> 01:17:17.900]  WE плюс один, WE минус один. Давайте проведем вот такой отрезочек между ними, поймем, правда ли,
[01:17:17.900 --> 01:17:26.100]  что это ухо или нет. В идеале, если это ухо, если как раз на вершине WE мы получили здесь ухо,
[01:17:26.100 --> 01:17:32.380]  то давайте мы просто отрежем, перейдем к меньшему многоугольнику, у которого уже на одну вершинку
[01:17:32.380 --> 01:17:36.740]  меньше. В нем по предложению индукции будет хотя бы два непредсекращихся уха, и значит,
[01:17:36.740 --> 01:17:42.980]  одно из них я могу объединить или их просто оставить, и у меня будут уже два уха. То есть,
[01:17:42.980 --> 01:17:47.980]  на самом деле у меня уже получится три уха, но это не важно, главное, что есть хотя бы два. В хорошем
[01:17:47.980 --> 01:17:55.020]  случае, когда мы нашли вершинку, в которой уже торчит ухо, мы просто отрезаем, и по предложению
[01:17:55.020 --> 01:17:59.900]  индукции в этом меньшее прямоугольнике есть хотя бы два уха. Извините, не прямоугольники, а многоугольники.
[01:17:59.900 --> 01:18:07.700]  Это хороший случай, когда мы можем отрезать эту прямую, то есть, когда вот здесь нет точек,
[01:18:07.700 --> 01:18:16.820]  нет точек, и эта вершина выпукла. Это критерий того, что эта диагональ нам отрезает ухо.
[01:18:16.820 --> 01:18:21.700]  Значит, плохой случай, это когда у меня в этом треугольнике нашлись какие-то другие вершины.
[01:18:29.900 --> 01:18:36.500]  Я провожу этот отрезок. И там нашлись какие-то другие вершины. То есть, картинка какая-то вот такая,
[01:18:36.500 --> 01:18:43.980]  ну что-то такое. Тогда давайте сделаем следующее. Давайте мы среди всех вершин, которые попали
[01:18:43.980 --> 01:18:50.820]  внутрь этого треугольника, точнее, внутрь или на его границу, мы найдем такую, которая ближе всех
[01:18:50.820 --> 01:18:58.380]  находится к точке ВИ. То есть, из всех этих, в нашем случае, трех вершин, которые попали
[01:18:58.860 --> 01:19:05.660]  во внутренность нашего треугольника, мы найдем самую близкую к ВИ. Вот это будет точка КУ.
[01:19:05.660 --> 01:19:28.860]  Самая близкая к ВИ среди точек внутри треугольника. Внутри или на границе треугольника.
[01:19:28.860 --> 01:19:42.540]  Тогда я утверждаю, что ВИ-КУ это диагональ. Это практически очевидно, потому что, смотрите,
[01:19:42.540 --> 01:19:50.860]  когда я провожу вот этот отрезок из ВИ до КУ, на нем точно нет никаких других точек. Потому что
[01:19:50.860 --> 01:19:55.780]  мы взяли КУ такую, что она самая близкая к ВИ внутри треугольника. Ну а этот отрезок, он понятно,
[01:19:55.780 --> 01:19:59.780]  он тоже лежит внутри треугольника, значит, на нем нет никаких других точек и, соответственно,
[01:19:59.780 --> 01:20:07.380]  никакие другие стороны его не пересекают. Вот, поэтому это опять-таки диагональ. И мы наш
[01:20:07.380 --> 01:20:14.620]  многоугольник тогда можем разбить на два. Мы можем разбить его на вот этот многоугольник. Давайте
[01:20:14.620 --> 01:20:29.820]  красным вытерем, который лежит выше, чем наш диагональ, и ниже. Второй. Ну и, собственно, победа,
[01:20:29.820 --> 01:20:35.420]  да. Ну, то есть, тут надо аккуратно посмотреть за количеством вершин, но понятно, что в обеих
[01:20:35.420 --> 01:20:40.540]  частях будет хотя бы по три вершины. Здесь хотя бы три, здесь хотя бы три. Значит, в каждой части
[01:20:40.540 --> 01:20:44.900]  есть хотя бы одно ухо, то есть там либо ровно три вершины осталось тогда, просто это один треугольник
[01:20:44.900 --> 01:20:50.780]  уха, либо это там хотя бы четыре, и по предложению дукса там хотя бы их два. Значит, обязательно есть
[01:20:50.780 --> 01:20:59.700]  и там, и там по уху, ну вот, суммарно их будет опять-таки хотя бы два. Вот вроде победа. Мы нашли такую
[01:20:59.700 --> 01:21:04.980]  диагональку за счет того, что взяли самую близкую точку внутри треугольника к ВИ и, соответственно,
[01:21:04.980 --> 01:21:09.260]  ее больше никто не будет пересекать, потому что иначе, а там, если бы ее кто-то другой пересекал,
[01:21:09.260 --> 01:21:14.300]  там что-то такое, если бы ее пересекал кто-то, то за счет того, что мы как бы должны как-то
[01:21:14.300 --> 01:21:19.660]  выйти сюда, зайти сюда и выйти, то обязательно здесь там должна быть какая-то более близкая точка.
[01:21:19.660 --> 01:21:31.940]  Вот. Хорошо, значит, мы доказали, что всегда есть хотя бы два уха. Ну тогда алгоритм строится
[01:21:32.700 --> 01:21:46.060]  алгоритм триангуляции. Алгоритм триангуляции. Мы поддерживаем на треугольник, поддерживаем,
[01:21:46.060 --> 01:22:02.180]  точнее, вершинам на треугольника, например, в связанном списке. То есть у меня каждая
[01:22:02.180 --> 01:22:09.940]  вершина ставится на следующую и на предыдущую. Тогда алгоритм такой. Значит, на первом шаге мы
[01:22:09.940 --> 01:22:18.780]  найдем и отрежем либо одно ухо, либо найдем диагональ. У меня будет такая процедура,
[01:22:18.780 --> 01:22:28.740]  которая находит одно ухо в наугольнике. Find ear. Найти ухо в наугольнике. Что она делает?
[01:22:28.740 --> 01:22:37.700]  Она берет, проходит по всем вершинкам и находит произвольную выпуклую. Выпуклая вершина. Затем
[01:22:37.700 --> 01:22:49.140]  строить треугольник. проводит такой отрезок и смотрит, проводит такой отрезок и смотрит.
[01:22:49.140 --> 01:22:55.060]  Если внутри этого треугольника ничего больше не попало, то это ухо и мы его сразу нашли.
[01:22:55.060 --> 01:22:59.900]  Соответственно, его можно отрезать, изъять из нашего списка вот эту вершинку,
[01:22:59.900 --> 01:23:05.540]  соответственно, перенаправить стрелочки вот здесь, вот из двух соседей друг в друга и решить
[01:23:05.540 --> 01:23:10.460]  задачу на меньшее наугольник. Это хорошо. В случае же, когда это не ухо, мы сделаем следующее.
[01:23:10.460 --> 01:23:16.620]  Мы найдем, как бы, почему-то не ухо, то есть найдем такие точки, которые лежат внутри треугольника,
[01:23:16.620 --> 01:23:22.260]  возьмем из них самую близкую КВИ и проведем такую диагональ. Соответственно, как вышел,
[01:23:22.260 --> 01:23:29.140]  у меня наугольник развелся на два кусочка. Там один и другой. И тогда я обсуждаю, что в каком-то
[01:23:29.140 --> 01:23:35.780]  из них точек не больше, чем n пополам. Точно, n пополам плюс один или плюс два. Потому что понятно,
[01:23:35.780 --> 01:23:40.300]  что сумма арта в них в вершинах на два больше, чем в исходном chilli dåику, потому
[01:23:40.300 --> 01:23:44.400]  что в Vater и Cup считалось в一些 два раза, значит в каком-то из них точек не больше
[01:23:44.400 --> 01:23:47.860]  marrow пополам плюс один. Скажем, здесь точёк не большеиля взaced further, н minus five also 1
[01:23:47.860 --> 01:23:54.860]  1 и давайте я запарусь рекурсивно от того наугольника в плульсках уха то это какой-то
[01:23:54.860 --> 01:23:58.880]  под наугольник. Я в нём найду ухо рекурсивно и его отрежу.
[01:23:58.880 --> 01:24:03.040]  И потом опять буду решать задачу на исходе многогонника, от которого откусно ухо.
[01:24:03.040 --> 01:24:09.760]  Тогда время работы будет примерно таким. Это какое-то линейное время, чтобы, во-первых,
[01:24:09.760 --> 01:24:15.800]  найти произвольную выпуклую вершину и проверить, что мы отрезаем ухо.
[01:24:15.800 --> 01:24:22.440]  Если мы отрезали не ухо, то значит, мы нашли Q, и наш многогонник сократился в два раза.
[01:24:22.440 --> 01:24:28.760]  Тетан пополам, тогда тетан это тетата.
[01:24:28.760 --> 01:24:39.000]  Еще раз, мы проверяем какой-то треугольник на то, ухо это или нет. Если ухо, то отрезаем,
[01:24:39.000 --> 01:24:44.600]  и получается, мы за линейное время прохода по всему многогоннику, мы отрезали какое-то ухо,
[01:24:44.600 --> 01:24:48.920]  теперь решаем задачу на меньшем многогоннике, опять, там n плюс m minus 1 и так далее, будет
[01:24:48.920 --> 01:24:54.040]  квадратичное время. Если же это не ухо, и, соответственно, здесь лежат какие-то другие точки,
[01:24:54.040 --> 01:24:58.440]  то давайте возьмем самую близкую Q, и, соответственно, многогонник разбесован на два кусочка,
[01:24:58.440 --> 01:25:05.640]  легко это переписать в серверах double linked list, то есть в связанном списке есть одна половинка
[01:25:05.640 --> 01:25:10.720]  и другая, в одном из них в каком-то вершине меньше, чем в другом, меньше половину. Вот я от него
[01:25:10.720 --> 01:25:16.520]  запускаюсь и крусивно, там делаю тоже самое, нахожу какое-то ухо, отрезаю, и получается,
[01:25:16.520 --> 01:25:24.520]  что я за вот такое время могу найти ухо, ну, одну из ушей в нашем многоугоннике, отрезаю и решаю
[01:25:24.520 --> 01:25:30.680]  задачу на меньшем многоугоннике, тогда весь алгоритм для ангуляции работает за квадрат.
[01:25:30.680 --> 01:25:41.560]  Вот, если нет вопросов, то спасибо, на этом мы заканчиваем,
[01:25:41.560 --> 01:25:46.560]  отмечу только лишь в конце, что существует алгоритм за НЛГ, мы его, наверное, не будем рассматривать.
[01:25:46.560 --> 01:25:59.520]  Он сильно сложный или нет? Ну, не особо. Хорошо, ладно, до свидания. Вот, да, спасибо, до свидания.
