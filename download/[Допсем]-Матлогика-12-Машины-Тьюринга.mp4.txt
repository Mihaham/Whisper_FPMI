[00:00.000 --> 00:08.680]  раз мы завершили вопрос теории множеств и начинаем двигаться в сторону новой теории, а именно
[00:08.680 --> 00:24.840]  теории вычислимости. Как понятно из названия, будет нас интересовать вопрос того, что такое
[00:24.840 --> 00:34.280]  вычисление. И чтобы задать понятие вычисления, нам нужно построить какую-то математическую модель,
[00:34.280 --> 00:42.440]  такой математический компьютер. Есть несколько вариантов того, как это делать. Первым из таких
[00:42.440 --> 01:10.720]  является машина тюринга. Задается на следующим образом. У нас есть sigma, gamma,
[01:10.720 --> 01:38.640]  множество s большое, s нулевое, s f и дельта. Итак, первое.
[01:38.640 --> 02:07.120]  Начнем объяснять что и что. Сигма. Дайте так запишу. Конечный алфавит. Все-таки неправильная
[02:07.120 --> 02:16.920]  запись. Конечный алфавит. Коротко о том, почему вот писать что-то меньше,
[02:16.920 --> 02:24.560]  чем вот так вот, касательно мощности, некорректно. Вот этот вот знак, это знак
[02:24.560 --> 02:29.520]  какой-то бесконечно большого часа. Какого-то бесконечно большого часа, то есть это предел.
[02:29.520 --> 02:40.040]  Что-то шоу очень большое. А мощность, мы помним, это ординалы. Это вот конкретно есть чисто там.
[02:40.040 --> 02:48.160]  Хорошо, gamma это, конечно, алфавит. Называется такая штука входным алфавитом.
[02:48.160 --> 03:08.360]  Ходной алфавит. Второе гамма. Тоже конечный алфавит.
[03:08.360 --> 03:20.000]  Но теперь это называется уже ленточным алфавитом.
[03:20.000 --> 03:46.160]  Как связаны гамма и сигма. У нас есть следующее правило, что гамма содержит себе сигма.
[03:46.160 --> 03:57.000]  Причем они не совпадают. В каком смысле? Что есть выделенный символ решетка,
[03:57.000 --> 04:13.560]  который принадлежит гамма без сигма. Такой символ решетка называется пустым символом.
[04:13.560 --> 04:37.120]  Дальше. С большое. Это множество состояний.
[04:37.120 --> 04:50.760]  Я не машина тюринга. Я вот везде дальше буду писать не машина тюринга, а МТ. Сокращение.
[04:50.760 --> 04:54.360]  Конечное.
[04:54.360 --> 05:14.520]  Это английского слова states. Состояние. Есть несколько выделенных состояний.
[05:14.520 --> 05:21.800]  С нулевое. Начальное состояние.
[05:21.800 --> 05:43.000]  Сф. Final. Завершающие стыни.
[05:43.000 --> 06:00.280]  То есть у нас есть какой-то компьютер, который умеет начинать работу из состояния с нули,
[06:00.280 --> 06:09.480]  завершать в некотором состоянии. Но мы помним, что у нас, например, есть функция. У нас есть
[06:09.480 --> 06:25.600]  функция. Она действует следующим образом. А есть предикат. Который действует из МН множество лжи и
[06:25.600 --> 06:46.080]  правды. И эти два понятия на самом деле друг другу переводятся. Поэтому, ровно так же,
[06:46.080 --> 06:52.560]  как мы функцию можем переделать предикат, точно так же мы можем переводить обычные машины тюринга
[06:52.560 --> 07:14.880]  в такие, назовем их предикатные машины тюринга, у которых место завершающего состояния можно
[07:14.880 --> 07:26.320]  называть там терминальным, финальным. Есть еще и вместо как раз завершающего состояния есть
[07:26.320 --> 07:49.120]  состояние SA и SR. А от слова accepted, R от слова rejected. То есть у нас accepted это принимающее
[07:49.120 --> 08:01.400]  состояние. То, что мапится на истину. А rejected то, что отвергающее состояние. То есть у нас здесь ложь.
[08:01.400 --> 08:17.320]  Хорошо. Так, это мы дали. Последнее осталось, самый трудный объект, это Delta. Delta это функция
[08:17.320 --> 08:37.360]  переходов. Начнем. У нас есть Delta. Из чего, куда она действует. Delta берет в себя некоторое
[08:37.360 --> 08:51.440]  состояние. И символ ленты. После чего она возвращает нам новое состояние. Новый символ
[08:51.440 --> 09:11.200]  ленты и использует еще 3 дополнительных символа. L это движение влево, N это остаться на месте, R это
[09:11.200 --> 09:21.120]  движение вправо. На самом деле вместо LNR мы можем писать произвольные вещи. Это просто вопрос
[09:21.120 --> 09:37.520]  формализации. Это математическая модель, нужно еще сказать как это все интерпретировать. У нас есть
[09:37.520 --> 10:03.720]  некоторая лента, бесконечная в обе стороны. Эта лента стоит из ячейка. То есть своего рода
[10:03.720 --> 10:18.200]  что-то изоморфное целым числом. Мы можем, мы на этой ленте имеем какие-то символы в каждой ячейке.
[10:18.200 --> 10:40.800]  Символы этой ячейки это элементы гамма. То есть своего рода у нас есть что? У нас есть некоторое
[10:40.800 --> 11:00.600]  отображение из Z в гамма. Последовательность каждому числу мы замапили какой-то символ. И причем
[11:00.600 --> 11:07.840]  у нас есть условия про входной афавит. То есть на самом деле входные данные это не вся лента.
[11:07.840 --> 11:19.240]  По большей части на ленте там записан какой-нибудь мусор. Чтобы гарантированно вход занимал не весь
[11:19.240 --> 11:29.600]  мусор, а какое-то определенное слово, мы сразу требуем наличия вот этого вот пустого символа.
[11:29.600 --> 11:36.800]  На самом деле пустой символ мы это интерпретируем. Это может быть не пустой символ, а там какой-нибудь
[11:36.920 --> 11:44.960]  мусор. Там у нас памяти компьютера тоже хранится везде. Вот у нас везде в гамме мусор,
[11:44.960 --> 11:58.160]  но где-то у нас есть входные данные. Вот у нас кусок входных данных. Здесь все лежит в сигне.
[11:58.160 --> 12:13.040]  Также у нас есть что-то вида,
[12:13.040 --> 12:25.840]  скажу, считывающей головки, как в жестком диске. В жестком диске у нас есть головка, сам диск
[12:25.840 --> 12:31.520]  крутится и читается информация. Вот у нас точно так же здесь есть где-то считывающая головка.
[12:31.520 --> 12:43.000]  Она сейчас находится на какой-то ячейке. И у нас вся машина живет на состояниях.
[12:43.000 --> 12:47.000]  Вот здесь у нас сейчас какое-то
[12:47.000 --> 13:08.160]  состояние идет. Хорошо, это так мы сама передадим. И что умеет делать машина? Машина умеет выполнять
[13:08.160 --> 13:16.840]  шаги. Один шаг это применение функции перехода. То есть если у нас есть вот например такое состояние,
[13:16.840 --> 13:28.920]  такой символ, вот с гамма, то мы можем сменить на следующее состояние, записать, заменить,
[13:28.920 --> 13:34.400]  то есть символ на какую-то гамму и выполнить одно из действий. Переместиться в ячейку влево,
[13:34.400 --> 13:45.920]  вправо или не перемещаться. Это интерпретация этой модели. На самом деле, если мы посмотрим,
[13:45.920 --> 13:52.560]  уже сама по себе математическая модель, она достаточно. Нам не нужны никакие ленты,
[13:52.560 --> 13:59.440]  в принципе даже просто наличие головки. Это то, что мы себе придумали. Не обязательно наличие
[13:59.440 --> 14:10.920]  какой-то головки. Модель это излишняя штука. Машина как работает? Давайте скажем, что такое.
[14:10.920 --> 14:20.520]  У нас есть понятие конфигурации.
[14:20.520 --> 14:44.480]  Конфигурация машины тюринга. Конфигурация машины тюринга это что-то вида снимок всего с
[14:44.480 --> 14:51.240]  всей машины. Какое у нее состояние? Конкретное максимально цельное состояние общей машины
[14:51.240 --> 15:02.520]  тюринга. Оно себя должно включать. Понятно, что оно будет включать, например, с состояния. Дальше оно
[15:02.520 --> 15:12.120]  должно включать что-то, что мы делали раньше. А то, что делали раньше, мы можем сохранить,
[15:12.120 --> 15:21.320]  например, при помощи записи слова. Мы же работаем как? Что машина принимает на вход какое-то
[15:21.320 --> 15:29.760]  слово и дальше работает. Машина прочитала какую-то часть слова. Это история до.
[15:42.120 --> 15:51.400]  И также машина
[15:51.400 --> 16:07.800]  должна прочитать еще слово when. Это вариант того, как записывается стройка. И в задании
[16:07.800 --> 16:16.640]  будет следующее. Задание будет в формировке вид следующий, что у нас есть некоторое у, дальше с,
[16:16.640 --> 16:29.560]  дальше идет в, но причем в мы дробим следующим образом. В равняется некоторый символ сима,
[16:29.560 --> 16:42.920]  конкатенция, давайте на v'. То есть мы дополнительно здесь слово дробим,
[16:42.920 --> 16:52.760]  еще выделяем символ. Тут тут sigma и v'. Зачем это делают? Это то, что было раньше. Это история.
[16:52.760 --> 17:02.360]  Тогда значит сейчас мы находимся на вот этом вот выделенном символе sigma. То есть как бы
[17:02.360 --> 17:12.760]  вот эту головку указывать вот сюда. Это будущее, то что мы должны будем где-то там в будущем
[17:12.760 --> 17:37.840]  определить. Хорошо. На самом деле вот это лишь всего лишь расписано слово when.
[17:37.840 --> 17:56.000]  Тогда что такое в принципе вычисления? У нас есть конфигурации, у нас есть некоторые
[17:56.000 --> 18:03.760]  конфигурации и мы можем по ним перемещаться. Давайте скажем как можем перемещаться. Я вот
[18:03.760 --> 18:17.440]  буду переводить таким. У нас есть s1, у, давайте выделим символ sigma, v' и есть другое состояние,
[18:17.440 --> 18:33.280]  t''v'. В каком случае мы можем переместиться от одной конфигурации в другую? То есть
[18:33.280 --> 18:49.880]  изменить состояние общей машины. Как-то поменять ее. Если выполнено следующее, что дельта от s' у,
[18:49.880 --> 19:19.640]  сейчас os s sigma равняется t. Сейчас скажу. Тут будет сложнее сказать.
[19:19.640 --> 19:46.040]  Давайте я пока t, я сделаю uv, не uv, я сделаю a. Давайте o1 sigma n, t1 tn. Можно переместиться в t,
[19:46.040 --> 20:14.240]  sigma 1 sigma n, t1 tn. Если мы заменим sigma на tau и останемся на месте. То есть что мы сказали?
[20:14.240 --> 20:26.560]  Вот у нас есть сейчас некоторое состояние машины s. Мы можем это состояние заменить на состояние t,
[20:26.560 --> 20:40.760]  если мы должны будем обработать символ sigma. У нас действительно есть символ sigma. Тогда мы
[20:40.760 --> 20:53.600]  заменяем состояние s на состояние t, заменяем символ и при этом не сдвигаемся по слову.
[20:53.600 --> 21:06.760]  Это вот да, мы начинаем строить такое отношение, что помним, был у нас что-то уводимость,
[21:06.760 --> 21:24.120]  теперь у нас-то достижимость. Дальше у нас есть s sigma 1 sigma n sigma tau 1 tau n. Мы аналогично
[21:24.120 --> 21:32.360]  сможем сменить состояние на t, но только теперь обработаем случай сдвига налево. Случай сдвига
[21:32.360 --> 21:57.760]  налево, теперь мы n-1 sigma n tau 1 tau n. То есть что произошло? У нас есть функция переходов. Она
[21:57.760 --> 22:09.240]  приняла в себе состояние s и символ sigma. В результате она нам отдала состояние t символ
[22:09.240 --> 22:22.320]  tau, но сказала, что сдвинется налево. Это мы сделали. У нас s-s sigma sigma меняется на t. Символ,
[22:22.320 --> 22:33.240]  который был sigma, поменялся на символ tau, но теперь у нас первым стал не tau, а тот,
[22:33.240 --> 22:44.720]  который был левее. Вот у нас она сдвинулась налево. Как бы мы слово перекинули один символ
[22:44.720 --> 22:55.680]  в право. Симметрично этому будет правило перехода из конфигурации. Следующий
[22:55.680 --> 23:15.080]  в конфигурацию, когда мы... жух. Сдвинемся сюда.
[23:15.080 --> 23:44.360]  S sigma tau и сдвиг вправо. S есть, sigma есть. Поменяли на t, заменили символ,
[23:44.360 --> 23:53.560]  но только теперь, так как R, мы сдвинули запятую вправо. L сдвинули запятую влево,
[23:53.560 --> 24:07.280]  R сдвинули запятую вправо. Всё. Таким образом мы сказали переход по конфигурациям. Дальше
[24:07.280 --> 24:16.480]  делается стандартный трюк с таким действием. У нас есть конфигурация. Давайте скажем,
[24:16.480 --> 24:36.640]  что c множество конфигураций. То, что сейчас мы построили, вот, некоторые такой штопор,
[24:36.640 --> 25:00.560]  то штопор есть не что иное, как под множество c квадрат. Штопор это отношение. Ну, отношение
[25:00.560 --> 25:07.320]  уже мы понимаем, что в некотором смысле нам его недостаточно. Например, мы можем перейти от
[25:07.320 --> 25:16.520]  одной конфигурации к другой, потом от второй к третьей, и тогда значит, что мы можем от первой
[25:16.520 --> 25:24.720]  перейти к третьей. Или там, почему мы, находясь в одной ситуации, не можем достичь другой.
[25:24.720 --> 25:39.280]  Поэтому проворачиваем, сейчас, проворачиваем фишку с тем, чтобы, давайте так, возьму,
[25:39.280 --> 25:53.120]  по-пажамистски напишу, что штопор теперь берется рефлексивное и транзитивное
[26:03.320 --> 26:05.040]  замыкание вот этого штопора.
[26:10.240 --> 26:21.240]  Можно сказать, что давайте там сделаем что-то типа, здесь навесим там нулевой. Что бы не было,
[26:21.240 --> 26:31.640]  то теперь у нас вот на основе таких вот базовых переходов, мы смогли распространить, получить
[26:31.640 --> 26:39.360]  цепочки. То есть, теперь у нас есть что-то типа цепочек вычислений. Здесь есть какая-то конфигурация,
[26:39.360 --> 26:49.760]  другая, третья, пятая, четвертая. Как-нибудь так. У нас есть там переходы по конфигурациям,
[26:49.760 --> 26:58.640]  и теперь у нас есть возможность при помощи этого штопора переходить из этой точки сразу вот,
[26:58.640 --> 27:18.360]  сюда или сюда. Здесь же у нас действует. По сути, здесь это есть элементарные переходы по функции
[27:18.360 --> 27:33.640]  перехода. Здесь же у нас замыкание это все. Зачем нам нужно такое замыкание? По сути,
[27:33.640 --> 28:01.120]  теперь у нас есть понимание того, что есть вычисление. Вычисление, опять же там в кавычках,
[28:01.120 --> 28:17.880]  это последовательность переходов по конфигурациям.
[28:31.120 --> 28:54.400]  Давайте так скажу. Удовлетворяя вот этим вот штопором. Почему я сейчас сказал штопор,
[28:54.400 --> 29:05.040]  а не там штопор нулевой? Потому что это в некотором смысле чуть более общим. Вот,
[29:05.040 --> 29:12.400]  например, когда мы рассматриваем какие-нибудь простые алгоритмы, даже не просто рассматриваем,
[29:12.400 --> 29:19.360]  вот курс алгоритма, там мы не смотрим на какие-то уж очень элементарные операции. На уровне даже
[29:19.360 --> 29:26.160]  самого компьютера уже там операция на самом деле сложнее. Мы оперируем там уже достаточно
[29:26.160 --> 29:33.320]  высокоуровневыми абстракциями. Мы можем сложить два числа, на самом деле сложение двух чисел это
[29:33.320 --> 29:48.600]  ну не типа hop и сложились. Сложение-то уже там много себе подшагов включает, что у нас есть.
[29:48.600 --> 29:59.800]  Ну там, например, когда мы строим, ну разбираем, проверяем на правильность, последовательность
[29:59.800 --> 30:08.000]  скобок. Мы там же не говорим, что вот там мы создали стэк в нем, что-то там создали ноду в нее,
[30:08.000 --> 30:14.720]  положили, переставили указатель, мы говорим, что ну просто вот типа push в стэк, потом pop из
[30:14.720 --> 30:21.320]  стэка. Это уже более крупные такие высокоуровневые операции, которые под собой скрывают очень много
[30:21.320 --> 30:31.160]  других операций. И вот подобным образом я говорю, что мы в качестве вот этих вот элементарных
[30:31.160 --> 30:37.000]  переходов берем не единичные атомарные шаги, а мы можем уже брать какие-то более сложные
[30:37.000 --> 30:42.560]  комбинированные шаги и смотреть это с разных уровней абстракции.
[30:42.560 --> 31:00.720]  Хорошо. Дальше, давайте прежде чем дальше, может кто-то есть вообще в принципе вопросы по тому,
[31:00.720 --> 31:07.360]  как работает машина тюринга, в чем, какой смысл этой всей математической абстракции,
[31:07.360 --> 31:26.560]  как она ложится на практику. Но видимо ни у кого нет. Тогда пойдем дальше.
[31:26.560 --> 31:41.280]  А куда мы пойдем? Мы пойдем в функции, а именно,
[31:41.280 --> 32:02.880]  рассмотрим функции. Будем рассматривать не оба какие функции, а конкретно из натуральных,
[32:02.880 --> 32:11.760]  числа в натуральные. Почему мы рассматриваем именно такие функции, там не больше? Потому что,
[32:11.760 --> 32:21.840]  вот если функции будут действовать из чего-то большего, то как нам например записать это все
[32:21.840 --> 32:28.080]  на ленте? Все натуральные числа мы можем спокойно перекодировать в числа на этой ленте,
[32:28.080 --> 32:44.360]  некоторые символы в этой ленте. Если мы возьмем произвольное действительное число. Мы знаем,
[32:44.360 --> 32:53.000]  что например произвольные действительные числа настолько сложны, что большую часть действительных
[32:53.000 --> 33:01.400]  чисел мы даже не знаем. Мы даже не представляем, что это просто, там что-то. И представить их уже
[33:01.400 --> 33:09.200]  просто на уровне каких-то там десятичных знаков мы не можем. Мы помним, что для иррациональных
[33:09.200 --> 33:19.240]  чисел у нас есть бесконечная, непериодическая десятичная запись. Мы не можем представить это
[33:19.240 --> 33:27.640]  в виде какого-то деления. Потому что если мы ограничились там условно этими алгебраическими
[33:27.640 --> 33:36.280]  числами, то алгебраические числа мы можем более-менее как-то явно записать. Записав их,
[33:36.280 --> 33:43.680]  мы можем интерпретировать. Соответственно, их мы можем вогнать в N в силу равномочности. Там
[33:43.680 --> 33:52.200]  как-то перекодировать. Концидентный мы уже не можем, поэтому рассматриваем что-то более простое.
[33:52.200 --> 33:58.680]  Начнем это делать.
[33:58.680 --> 34:12.960]  Так, есть некоторая функция из N в N. Мы называем ее вычислимой.
[34:12.960 --> 34:18.800]  Вычислимой.
[34:18.800 --> 34:48.520]  Называется такая функция F из N в N, что существует
[34:48.520 --> 35:17.280]  машина тюринга. Давайте я буду называть ее Mio от X. Что Mio от X равняется F
[35:17.280 --> 35:38.840]  от X. Что для любого N, принадлежащего N, выполняется, что
[35:38.840 --> 35:57.960]  машина тюринга Mio от N...
[35:57.960 --> 36:16.120]  Не так. Вот так вот лучше будет.
[36:16.120 --> 36:25.160]  Что я записал?
[36:25.160 --> 36:46.040]  У нас есть натуральные числа. У нас есть машина тюринга Mio, у которой есть некоторый входной
[36:46.040 --> 37:02.440]  алфавит. Соответственно, мы должны уметь как-то переводить натуральные числа в слова, а именно
[37:02.440 --> 37:17.400]  элементы сигмы со звездой. Делать мы это можем при помощи некоторого кодирования от энкода.
[37:17.400 --> 37:30.160]  Отображение из N в сигмы со звездой. И получается, у нас есть машина тюринга. Она принимает
[37:30.160 --> 37:49.800]  в себя некоторый вход. Это будет означать следующее, что у нас машина тюринга приняла
[37:49.800 --> 38:01.280]  некоторые слова, его обработала и запустила. Но есть одно но. Почему у нас здесь не гамма со
[38:01.280 --> 38:09.760]  звездой, а некоторая более другая конструкция? Потому что гамма со звездой это множество слов
[38:09.760 --> 38:23.160]  конечных. У нас же машина тюринга работает как? У нас есть вот такая вот фигуринка и на ней
[38:23.160 --> 38:30.320]  нож живет. Но это абстракция. Это вот именно что абстракция, что у нас бесконечная обе стороны
[38:30.320 --> 38:40.120]  лента. В реальности же здесь нигде никакой ленту у нас не зашито. Поэтому мы можем спокойно здесь
[38:40.120 --> 38:50.960]  писать и работать со словами. Как бы реальности у нас как бы вот в описании модели у нас бесконечная
[38:50.960 --> 39:06.400]  обе стороны. Но по факту у нас конечность. Эффективно конечна. Единственный способ как мы
[39:06.400 --> 39:15.560]  можем использовать эту бесконечность просто бесконечно шагать в один из концов. Но в таком
[39:15.560 --> 39:29.040]  случае просто машина тюринга не завершается, поэтому, поэтому ничего. Ну и я здесь записал,
[39:29.040 --> 39:42.680]  что у нас есть машина тюринга, у нас есть некоторое закодированное значение числа n и после себя
[39:42.680 --> 39:56.600]  нас ставит тоже какое-то закодированное значение от FATN. Как мы понимаем, что у нас вход,
[39:56.600 --> 40:04.000]  что у нас выход. То есть у нас есть последовательность конфигурации. Машина тюринга это вот
[40:04.000 --> 40:14.720]  переход по конфигурациям. У нас есть конфигурация изначально нулевая, стартовая там, я назову это input,
[40:14.720 --> 40:27.600]  в нашем случае там закодированное значение числа n и ничего. Слово Epsilon.
[40:27.600 --> 40:43.760]  Верну здесь sigma в силу того, что мы поняли, что это некая излишняя абстрактность. Здесь sigma
[40:43.760 --> 40:52.760]  достаточно. Вот у нас здесь есть жух и дальше мы начинаем работать. Хотя сейчас скажу,
[40:52.760 --> 41:03.920]  я сделаю все-таки здесь гамму, я объясню, зачем я его обратно верну чуть позже. Мы начинаем
[41:03.920 --> 41:11.360]  переходить по конфигурациям как-то и достигаем следующей конфигурации.
[41:11.360 --> 41:23.840]  S final. Дальше здесь какое-то слово U, здесь какое-то слово V.
[41:23.840 --> 41:42.720]  Жух. Тогда результатом машины тюринга мы положим вот этот Uv. То есть все то,
[41:42.720 --> 42:00.440]  что осталось от работы, это ее выход. SF это конец вычислений. Так вот, на самом же деле мы можем
[42:00.440 --> 42:14.520]  как-то это скажу. Мы можем как-то вот все эти закодированные штуки на самом деле также и
[42:14.520 --> 42:22.720]  в результате преобразования получить вот например там что-то типа просто все стереть.
[42:22.720 --> 42:37.640]  Тогда нам нужно будет то, что вывод это то, что мы все стерли. И вот как раз здесь именно
[42:37.640 --> 42:45.760]  поэтому я верну обратно гамму. В дальнейшем мы не будем явно писать, что там происходит
[42:45.760 --> 42:58.800]  перекодирование. Будем просто писать, что есть некоторые машины тюринга U и что U от N равняется
[42:58.800 --> 43:10.800]  F от N. Понимая, что на самом деле вот здесь вот мы как-то закодировали в терминах слов над
[43:11.400 --> 43:20.120]  гамма, а это то, что осталось после работы машины тюринга, закодированные тоже в терминах
[43:20.120 --> 43:36.320]  афавита гамма. Возможно да, сейчас я начинаю, тут слишком много формализма, но мне кажется,
[43:36.320 --> 43:45.840]  для того чтобы понимать в чем вся соль вот это вот байды, нужно чуть повозиться с этим.
[43:45.840 --> 44:05.360]  Так вот, как мы вообще понимаем, что машины тюринга у нас функция не определена. Функция
[44:05.360 --> 44:12.160]  не определена на каком значении, то есть у нее нет ответа. И в случае вот таком,
[44:12.160 --> 44:19.120]  что перекодирование. Мы вот перекодировали вход, запустили машины тюринга M, у нас начали
[44:19.120 --> 44:28.480]  вертеться конфигурации, но мы понимаем, что у нас из некоторой конфигурации, в которой машины
[44:28.480 --> 44:35.320]  тюринга будет зайти в какой-то бесконечный цикл или там она просто пойдет в бесконечность,
[44:35.320 --> 44:47.760]  у нее никогда не найдется состояния доступного из начальной конфигурации, в котором будет
[44:47.760 --> 45:03.920]  в качестве состояния иметься SF. То есть у нас буквально не существует,
[45:03.920 --> 45:31.120]  я скажу, то есть буквально не существует значения функции. Хорошо. Если у нас есть
[45:31.120 --> 45:43.120]  понятие вычислимости, мы можем смотреть, как вычислимость функции связана с некоторыми множествами.
[45:43.120 --> 45:49.960]  У нас множество можно, например, определять некоторой характеристической функцией. Вот оказывается,
[45:49.960 --> 45:57.040]  что если характеристическая функция множества вычислима, то такое множество разрешено называется.
[45:57.040 --> 46:21.160]  Ну вот, запишем это. Определение разрешимым называется такое множество,
[46:21.160 --> 46:41.200]  что существует машина тюринга, которая по элементу множества,
[46:41.200 --> 47:01.320]  просто по заданному элементу скажет, принадлежит ли он нарасту или нет.
[47:11.200 --> 47:19.840]  Принадлежит ли он множеству или нет, это означает, что мы имеем дело с предикатом машины тюринга.
[47:19.840 --> 47:28.000]  Принадлежит это значит, мы можем достичь состояния конфигурации с состоянием
[47:28.000 --> 47:36.080]  с accepted, а если не принадлежит, мы можем достичь конфигурации со состоянием с rejected.
[47:36.080 --> 47:46.960]  Если мы попытаемся чуть ослабить, казалось бы, свойства хорошо разрешимости,
[47:46.960 --> 47:52.400]  значит мы можем точно определить по каждому элементу. А что если мы не будем точно говорить,
[47:52.400 --> 48:14.960]  а просто перечислим все элементы. Перечислим называется такое множество,
[48:14.960 --> 48:36.360]  что существует машины тюринга, его перечисляющие. Все просто.
[48:36.360 --> 48:47.880]  Ко перечислимо. В принципе приставка ко говорит о том, что следующее свойство
[48:47.880 --> 49:08.920]  выполняется для дополнения. Дополнение перечислено. Какие у нас есть критерии разрешимости?
[49:08.920 --> 49:23.000]  Первые критерии это то, про что я начал. Что характеристическая функция
[49:23.000 --> 49:40.040]  фи хи от м от элемента а равняется
[49:40.040 --> 50:04.520]  1 если а принадлежит м и 0 если а не принадлежит м. И она должна быть вычислима.
[50:04.520 --> 50:21.800]  Второе это то, что называется теоремой поста. И формулируется она следующим образом.
[50:21.800 --> 50:47.320]  М разрешима равносима тому, что м тире перечислима и ко перечислима. Это что мы имеем
[50:47.320 --> 50:56.720]  про разрешимость? Про перечислимость мы имеем более грустное свойство.
[50:56.720 --> 51:06.960]  Первое это аналог, что сделается характеристической функцией. Надо ее как-то испортить. Сделаем
[51:06.960 --> 51:15.120]  полухарактеристическую функцию. Как работает полухарактеристическая функция?
[51:15.120 --> 51:39.520]  1 если а принадлежит м и не определено если а не принадлежит м. То есть наша машина
[51:39.520 --> 52:04.440]  терлинга никогда не остановится. Дайте я скажу, что пусть f тире учислимая функция. Тогда вторым
[52:04.440 --> 52:19.640]  будет у нас область значений и область определений. Это они будут перечислимыми.
[52:19.640 --> 52:32.840]  Это последнее, что нужно найти в теории. Перейдем к задачкам. Первая задачка наверное самая
[52:32.840 --> 52:56.440]  неприятная за контрольную. Ей я дам наверное красный цвет. Давайте разберем. Если на некого
[52:56.440 --> 53:02.640]  н больше 10 через н в третьей степени плюс один шаг после начала работы машина посетила не больше
[53:02.640 --> 53:10.280]  н ячейка. А при этом ледночный алфамин состоит только из этих. Пункт а про то, что машина тюринга
[53:10.280 --> 53:18.880]  также определяется количеством состояний. Давайте я тебе сказал. Наверное да в машине тюринга я забыл
[53:18.880 --> 53:36.880]  сказать, что эти все с они лежат из нее. И конфигурация у нас вот это вот это из с. Но
[53:36.880 --> 53:51.440]  слова понятно. Так вот у нас машина тюринга определяется не только самими словами, но и
[53:51.440 --> 53:59.800]  состояниями. Если у нас очень много состояний, то в целом нам никто не мешает просто стоять на одной
[53:59.800 --> 54:12.440]  той же ячейке и менять состояние. От пункта а берем давайте я сделаю е в степени н. Состоянии
[54:12.440 --> 54:30.280]  и я вполне себе могу просто переходить вот там с нулевое, с первое и так далее до с финального.
[54:30.280 --> 54:41.800]  Я просто стою на месте и меняю вот эти состояния. Я посещу не больше н. Ячейк. Да, для ночного фита
[54:41.800 --> 54:51.640]  вообще какое угодно. Поэтому это неверно. Одна и та же конфигурация повторилась второй раз. В чем
[54:51.640 --> 54:57.760]  особенность? Мы рассматриваем машины тюринга особые, детерминированные. Детерминированный
[54:57.760 --> 55:07.480]  стих выражается, что мы работаем с отображением. Дельта это отображение. У нас каждый переход он
[55:07.480 --> 55:14.800]  единственный. То есть если мы дошли докуда, то у нас только один способ найти. И поэтому если мы как-то
[55:14.800 --> 55:20.440]  вот с конфигурацией, мы там что-то двигались, двигались, двигались, двигались, вернулись саму
[55:20.440 --> 55:30.160]  себя, у нас нигде не может быть развилок. Это означает, что мы зациклились. Если мы дошли до
[55:30.160 --> 55:41.320]  нее, то вот тут мы не встретили, здесь нет финального состояния. Если вот здесь нет, то значит все. Мы до него
[55:41.320 --> 55:53.880]  никогда не дойдем. У нас машина тюринга зашла в бесконечность. Через некоторое время после конфигурации
[55:53.880 --> 56:09.040]  AQB возникла конфигурация AQBB. Ну и поначалу кажется, что все плохо.
[56:09.040 --> 56:23.360]  У нас никто, что скажу, но
[56:39.040 --> 56:46.520]  в общем давайте, да, я покажу сейчас на примере просто, почему это неверно. В целом мне кажется,
[56:46.520 --> 56:55.920]  до этого просто взять и догадаться с ничего достаточно трудно. У меня есть, в какой-то момент
[56:55.920 --> 57:05.000]  здесь написан B, а по краям ничего нет. Ну хорошо, я нахожусь вот здесь, к стене Q. Тогда что я делаю?
[57:05.000 --> 57:21.480]  Я возьму, перейду в новое состояние и сдвинусь вправо. Ужух, я сдвинулся вправо. Я окажусь в состоянии Q2.
[57:21.480 --> 57:32.320]  Но Q2 будет как работать? Что Q2 и пустой символ, здесь у меня все пустые символы.
[57:32.320 --> 57:46.360]  Переводит нас в Q1, B и лево. То есть буквально мы заменяем этот символ на B,
[57:46.360 --> 57:53.640]  сменяем состояние на Q1 и двигаемся влево. Возвращаемся изначально в ту же конфигурацию,
[57:53.640 --> 58:05.160]  но не в ту же конфигурацию, в то же состояние, на той же ячейке. Но если мы возьмем Q2 и уже в этот раз
[58:05.160 --> 58:18.720]  символ B, то сюда мы перейдем в финальное состояние. Ну и там пофиг уже. Поэтому
[58:23.640 --> 58:31.160]  здесь зашито то, что вот на этом состоянии мы действительно повторим то же самое действие,
[58:31.160 --> 58:37.960]  но никто не говорит нам, что если здесь мы повторили то же самое действие, то его второй раз нам
[58:37.960 --> 58:48.640]  придется повторить его так же. У нас мог измениться следующий контекст. Здесь B не определено.
[58:48.640 --> 59:02.320]  Хорошо. Для некоторого N больше 10 через N шагов после конфигурации возникла следующая конфигурация.
[59:02.320 --> 59:11.840]  Давайте смотреть. У меня есть вот следующая конфигурация. Я сейчас, у меня есть N плюс
[59:11.840 --> 59:38.240]  один нулей. Я нахожусь вот на первом нуле. Следующий же раз через некоторых шагов у меня
[59:38.240 --> 59:44.520]  возникла конфигурация. Вот такая вот.
[59:44.520 --> 01:00:08.880]  Ну теперь я смотрю сюда. Что? Левый контекст у меня одинаковый. Контекст это то, что находится
[01:00:08.880 --> 01:00:18.840]  от указателя. Левый контекст у меня здесь и здесь одинаков. А что с правым контекстом? Вот у меня
[01:00:18.840 --> 01:00:30.560]  здесь написано, что N шагов. То есть на самом деле у меня за N шагов доступен контекст размера N. Я не
[01:00:30.560 --> 01:00:37.520]  смогу за N шагов перейти на больше, чем N ячеек. То есть у меня буквально доступна только вот
[01:00:37.520 --> 01:00:48.320]  эта вот область. Все, что дальше меня не интересует. Даже можно да вот тут вот здесь так же сказать. Все
[01:00:48.320 --> 01:00:59.320]  дальше это что-то, до чего я не доберусь никогда априори. Так вот здесь. Я нахожусь здесь. У меня вот
[01:00:59.320 --> 01:01:07.920]  он контекст. Все, что дальше оно недостижимо. Поэтому если оно недостижимо, я туда никогда не
[01:01:07.920 --> 01:01:15.520]  попаду. Соответственно эта штука не влияет на мой процесс исполнения. И реальной эффективной
[01:01:15.520 --> 01:01:23.040]  реальной эффективной конфигурации моей машины тюринга будет не все, что справа, все что слева,
[01:01:23.040 --> 01:01:31.360]  а вот то, что доступно за эти N шагов влево-вправо. И оно в точности опять же повторилось. А если я
[01:01:31.360 --> 01:01:45.920]  побывал два раза в одной и той же конфигурации, значит я зациклился. Поэтому здесь ГВН. 23 номер.
[01:01:53.040 --> 01:02:15.800]  Вопрос про всю допределенность и вычислимость функций. Как это связано? Мы помним, что у нас
[01:02:15.800 --> 01:02:22.080]  есть полух... Важно помнить сразу про полухареактивистическую функцию, которая вычислима.
[01:02:22.080 --> 01:02:35.080]  Вот. Она может быть вычислима, может быть нет, но при этом она не определена. То есть у нас уже
[01:02:35.080 --> 01:02:44.360]  есть вычислимые функции, но которые не определены. Ну хорошо. Это неверно. Если функция сюда определена,
[01:02:44.480 --> 01:02:50.460]  то она вычислима. Это вообще неверно. У нас же есть неразрешимые множество. Просто давайте пока
[01:02:50.460 --> 01:02:56.200]  запомним, что есть неразрешимые и есть непричислить. И не будем смотреть пример, так вот... У нас есть
[01:02:56.200 --> 01:03:01.780]  неразрешимые множество. Значит, есть характеристическая функция, которая сюда определена, но она
[01:03:01.780 --> 01:03:08.280]  не вычислена. Если функция having сюда определена и принимает только назначение, то она вычислима.
[01:03:08.280 --> 01:03:13.180]  Но если она всюду определевна и возвращает только на значения, то мы можем явно сказать,
[01:03:13.180 --> 01:03:21.140]  как ее вычислить, просто всегда возвращать это значение. Все. Пунга, если функция f всюду принимает
[01:03:21.140 --> 01:03:28.140]  только одно значение, то она вычислима, даже если всюду не определена. Полухарактеристическая
[01:03:28.140 --> 01:03:33.180]  функция, она бывает не вычислимой. Она принимает только одно значение, но не всюду определена.
[01:03:33.180 --> 01:03:46.620]  Это задание крайне простое. На нем нужно утаить баллы. Второе также тривиальное задание.
[01:03:46.620 --> 01:04:02.180]  Какие свойства эквивалентные? Какие эквивалентные разрешимости?
[01:04:02.180 --> 01:04:07.500]  Смотрите, вам специально даже пометили, что имеется ввиду именно эквивалентность.
[01:04:07.500 --> 01:04:18.780]  Не следование, не из этого следует, а что это эквивалентно. У нас есть два простых способа,
[01:04:18.780 --> 01:04:23.380]  их только два. Это теорема поста про перечислимости, кооперечислимость и
[01:04:23.380 --> 01:04:28.140]  разрешимость характеристической функции. Вычислимость характеристической функции.
[01:04:28.140 --> 01:04:34.980]  Видим, что здесь уже все есть два критерия. Вот это a и g. g теорема поста,
[01:04:34.980 --> 01:04:42.580]  а это про характеристическую функцию. А конечно разрешимость. Конечно же это неверно. Самым
[01:04:42.580 --> 01:04:48.100]  простым способом того, что является разрешимым множеством, это множество натуральных чисел.
[01:04:48.100 --> 01:04:55.740]  Мы просто будем всегда возвращать единицу. Так мы рассматриваем функции Zenven. Мы просто
[01:04:55.740 --> 01:04:59.700]  всегда говорим, что да, всегда лежит. У нас нет натуральных чисел, которые бы не лежали
[01:04:59.700 --> 01:05:06.620]  на натуральных числах. А перечислимо. Неверно. У нас из разрешимости следует перечислимость,
[01:05:06.620 --> 01:05:14.700]  а просто перечислимости недостаточно. Должна быть еще кооперечислимость. Все подножества
[01:05:14.700 --> 01:05:32.900]  a разрешимы. Это тоже неверно. Почему, почему, почему? Ну понятно, что если все подножества a разрешимы,
[01:05:32.900 --> 01:05:38.580]  то и a разрешимы. То есть в одну сторону есть импликация, а в другую сторону. Что правда ли,
[01:05:38.580 --> 01:05:48.420]  что у любого разрешимого множества будет все подножества разрешимы? Нет. Возьмем,
[01:05:48.420 --> 01:05:56.860]  рассмотрим снова n. Обращаю внимание на это множество. На него смотрим, пытаемся его применить.
[01:05:56.860 --> 01:06:04.220]  Вот n разрешима, но у него не все множества разрешимы, поэтому это неверно. Просто потому,
[01:06:04.340 --> 01:06:09.180]  что все подножества, которые мы только рассматриваем, это есть множество натуральных чисел. Мы пока живем
[01:06:09.180 --> 01:06:19.100]  на них. Все иное это либо какие-то там переводы в натуральные числа, либо натуральные числа,
[01:06:19.100 --> 01:06:28.780]  n-ты степени натуральных чисел, множество натуральных чисел. И общая картинка мира у нас должна
[01:06:28.780 --> 01:06:48.620]  быть такая. У нас вот есть все множества. У нас есть среди них, дайте кукурузку. Не хочу,
[01:06:48.620 --> 01:06:59.180]  хочу кукурузку. Вот у меня есть кукурузка. У меня есть в этой кукурузке есть вот такая вот штучка.
[01:06:59.180 --> 01:07:20.020]  Это разрешимы. Ой, это у нас перечислимое множество. У нас есть, помимо перечислимости,
[01:07:20.020 --> 01:07:24.820]  есть, например, вот еще другая штучка. Называется она ко перечислимости.
[01:07:24.820 --> 01:07:42.540]  А в их пересечении лежит штучка, называемая разрешимость. Здесь же лежит у нас неразрешимость.
[01:07:42.540 --> 01:07:51.500]  На самом деле у нас буквально там будет початок. Вот он будет вот таким вот просто дальше жук,
[01:07:52.500 --> 01:07:57.380]  и это будет называться арифметической иерархией, но мы поговорим об этом позже.
[01:07:57.380 --> 01:08:18.220]  Сейчас подправим. К початку мы вернемся еще. Новое задание. Вообще самое простое,
[01:08:18.220 --> 01:08:22.380]  которое только может быть. Наверное, из всего этого, из всей контрольной,
[01:08:22.380 --> 01:08:29.700]  самой простой, его нужно просто сразу делать, садиться и писать. Прям на чистовик и лутать
[01:08:29.700 --> 01:08:37.540]  один балл. Это зелень, это зелень, конечно же. Все очень просто и очень эффективно для набора баллов.
[01:08:37.540 --> 01:08:42.700]  Два разрешимых множества. Докажите, что такое множество разрешимы. Что значит доказать,
[01:08:42.700 --> 01:08:47.860]  что разрешимость? Значит, нам нужно сконструировать характеристическую функцию. Конструируем.
[01:08:47.860 --> 01:09:04.300]  Говорим, что вот это вот множество от элемента m равняется. Что равняется у нас? Да, у нас
[01:09:04.300 --> 01:09:13.860]  программирование. Что мы делаем? Мы делаем for int и равняется 0. У нас 0 натуральное число,
[01:09:13.860 --> 01:09:30.980]  не забываем про это. И не превосходит m. Плюс плюс и. For int иод равняется 0. Иод не превосходит m.
[01:09:30.980 --> 01:09:41.940]  Плюс плюс иод. То есть что я хочу сделать? Я хочу просто перебрать все пары и проверить
[01:09:41.940 --> 01:09:52.340]  само число. То есть я беру такую штуку и я проверяю.
[01:09:52.340 --> 01:10:06.460]  У нас из-за разрешимости есть характеристические функции a и b.
[01:10:06.460 --> 01:10:35.180]  И от i и от b от iод. То если i степень iод,
[01:10:35.180 --> 01:10:55.460]  равняется m, то я пишу нормальный код и возвращаю сразу к идика.
[01:11:05.180 --> 01:11:22.220]  То есть буквально что я сделал? Я прошелся от нуля до этого числа и проверяю, что если у меня
[01:11:22.220 --> 01:11:38.620]  вот это вот i и b лежат в этом множестве, то если их... Ладно, тут реально нужно делать if a. Тут нужно
[01:11:38.620 --> 01:11:50.220]  исправлять код. If i степень iod равняется равняется m, то вот тогда я сделаю return
[01:11:50.220 --> 01:12:02.180]  through. А вот почему не получится возвращать? Потому что да, это если вот все проверки не прошли,
[01:12:02.180 --> 01:12:17.220]  только тогда false. И вот если у меня ничего не вышло, ни один for не вышел, я такой... Ну ладно,
[01:12:17.220 --> 01:12:46.340]  значит я все проверил, я такой return false. А единственный случай с нулем. Вот что если я подам 0?
[01:12:46.340 --> 01:12:59.620]  Если я подам 0, то 0 равняется 1. А вот 0 в степени 1 равняется уже 0. Поэтому отдельно тут нужно
[01:12:59.620 --> 01:13:13.860]  помнить, что нужно обрабатывать 0. Но я не буду писать типа как подправить код, чтобы он проверил 0.
[01:13:13.860 --> 01:13:24.020]  Ну там как мне проверить, что 0 лежит в таком множестве? Он лежит в множестве тогда и только
[01:13:24.020 --> 01:13:35.020]  тогда, когда в a есть 0 и в b есть что-то кроме 0. Ну то есть b не пусто и там не 0. Ну просто
[01:13:35.020 --> 01:13:50.340]  дополнительно мы form здесь посмотрели кейс для 0. Последний номер 26. Мы уходим в перерыв.
[01:13:54.020 --> 01:13:55.380]  Так, сейчас напишу.
[01:13:55.380 --> 01:14:24.020]  Да, не забываем его. Так, вот сюда я вставлю задачу. Вот эта задача уже более сложная.
[01:14:24.020 --> 01:14:42.460]  Она более сложная. Я помещу ее желтой. Что происходит? Первый от нас будут прояснить в процессе решения,
[01:14:42.460 --> 01:14:51.380]  почему любой знак разложения можно вычислить. Ну не знак вообще, а цифру имеется в виду. Так,
[01:14:51.380 --> 01:14:56.620]  чисто придеремся к формулировке. Если нам сказано вспомнить формулу Тейлора,
[01:14:56.620 --> 01:15:05.860]  ну давайте вспомним формулу Тейлора. Там формула Тейлора это что? Я лично ее не особо помню,
[01:15:05.860 --> 01:15:18.740]  что это у нас есть ряд iot x iot от iota равного 0 до плюс бесконечности. И у нас там есть как-то
[01:15:18.740 --> 01:15:30.620]  коэффициенты iota. Что такое по определению такой ряд? Это есть предел ряда от iota равному 0 до iota
[01:15:30.620 --> 01:15:48.140]  большой iota и степень iota. Но что такое предел? Предел у нас как задает? Что я назову, пусть это будет
[01:15:48.140 --> 01:16:07.260]  там сумма. Тогда что для любого iot больше 0 существует такое iota большое, что для любого iota
[01:16:07.260 --> 01:16:21.660]  больше либо равного n выполняется, что разница по модру чем iota от 0 до iota большого iota x iota
[01:16:21.660 --> 01:16:41.980]  minus s не превосходит ipsum. В нашем случае s это sin n. То есть у нас мы можем задать конечные суммы
[01:16:41.980 --> 01:16:55.780]  приближения sin. Если мы хотим получить там n и знак, то тогда давайте возьмем число в степени 10
[01:16:55.780 --> 01:17:11.860]  минус n. Давайте я возьму запас mn плюс 2. Это я задам ipsum. Тогда в силу того, что я смогу по
[01:17:11.860 --> 01:17:33.260]  определению предела найти такое iota большое, то на n-том разряде будет верное число.
[01:17:33.260 --> 01:17:44.780]  Это мы пояснили, почему можно получить. Хорошо, если теперь мы знаем, что это можно получить,
[01:17:44.780 --> 01:17:54.020]  нам теперь нужно просто рассказать, как перечислить множество sin a, зная a. У нас
[01:17:54.020 --> 01:18:04.540]  есть некоторый перечислятор элементов множества a. Тут важное замечание. Обратимся к этому коду.
[01:18:04.540 --> 01:18:20.700]  Смотрите, у меня везде здесь i и конечная граница. У меня нигде нет for i из натуральных чисел. Это
[01:18:20.700 --> 01:18:30.180]  строго запрещено. Как только вы записали в разрешимости такую штуку, вы получили ноль баллов.
[01:18:30.180 --> 01:18:50.380]  Нельзя так. Нельзя вот так. Потому что a может быть как раз точностью счетным. Что это значит?
[01:18:51.340 --> 01:18:57.100]  Мой алгоритм будет работать следующим образом. Он пойдет по всем элементам из a. По всем элементам из
[01:18:57.100 --> 01:19:02.580]  a нельзя идти. Их счетное число. У нас алгоритм может не закончиться. Мы просто будем ходить, ходить,
[01:19:02.580 --> 01:19:09.820]  ходить и так не пройдем. Например, если не принадлежит. Мы все будем пытаться обойти,
[01:19:09.820 --> 01:19:21.700]  но мы так в итоге и не обойдемся. А в случае с перечислением, наша задача просто перечислить.
[01:19:21.700 --> 01:19:26.460]  Мы можем бесконечно перечислять. Если элементы бесконечно, то у нас не остается ничего иного,
[01:19:26.460 --> 01:19:39.180]  кроме как перечислять бесконечно. Вот это мы и будем делать. Берем что? У нас
[01:19:39.180 --> 01:19:48.420]  нам нужно будет перебирать последовательность и часть с удовеченным разложением. Нам нужно
[01:19:48.420 --> 01:20:02.540]  будет получать как-то последовательность элементов из разложения синуса и проверять, что она лежит в a.
[01:20:09.180 --> 01:20:27.340]  Ну то есть берем, делаем что? Первый псевходокод будет такой. For int i в натуральных. Давайте так скажу
[01:20:27.340 --> 01:20:51.700]  for i от као натуральных. Делаем следующее. If синус n, который мы можем приблизить. Мы знаем
[01:20:51.700 --> 01:20:57.140]  вот за какое-то конечное число шагов. Здесь конечная сумма, конечное число шагов мы можем
[01:20:57.140 --> 01:21:23.740]  высчитать. С йод по i равняется там, скажем, просто йод и дополнительно нам нужно будет запустить
[01:21:23.740 --> 01:21:34.540]  перечисление a. У нас есть перечислятор, соответственно мы тоже запустим перечислять. Это
[01:21:34.540 --> 01:21:54.660]  равняется a, то выводим эту, там типа, что там, system out println a.
[01:21:54.660 --> 01:22:06.540]  Вот сейчас скажу, это таких x, что последовательность.
[01:22:06.540 --> 01:22:24.340]  А, даже проще, мы просто будем перебирать такие, мы будем делать вывод из этого.
[01:22:24.340 --> 01:22:40.420]  У нас есть его построитель записи, берёмся и поёт.
[01:22:40.420 --> 01:22:57.460]  А теперь важное но. Как нам уметь вот это вот всё защитить перечисление? Мы имеем возможность
[01:22:57.460 --> 01:23:09.540]  перечислять только n. Действительно, 1, 2, 3, 4. А здесь мы перечисляем на n, на n, на a. Такое слабо
[01:23:09.540 --> 01:23:19.900]  возможно. Хорошо, давайте рассмотрим два случая. А у нас может быть конечно, тогда у нас на самом
[01:23:19.900 --> 01:23:27.820]  деле перечисление идёт всё равно по n на n, но n на n на там какой-нибудь там ограниченное множество,
[01:23:27.820 --> 01:23:36.460]  поэтому на нём можно забить. Либо бесконечно, точнее счётно, тогда у нас перечисление уже
[01:23:36.460 --> 01:23:45.060]  на декардовом кубе. Что в таком случае делать? В таком случае нужно будет явно указать следующую
[01:23:45.060 --> 01:24:11.340]  штуку. Так как пусть c из n вычислимая в обе стороны бекцы. У нас она существует,
[01:24:11.340 --> 01:24:20.580]  там из лекции. Ну или даже просто мы там рассматриваем, что у нас есть явный алгоритм,
[01:24:20.580 --> 01:24:27.620]  как нам пронумеровать все элементы табицы. Так вот, если у нас такая штука существует,
[01:24:27.620 --> 01:24:44.740]  то мы можем сделать следующие. Тогда существует phi, которое по n вернёт нам вот такую штуку.
[01:24:44.740 --> 01:24:56.420]  Но если мы можем занумеровать n квадрат, то тогда нам ничего не стоит, ещё раз применяв там psi,
[01:24:56.420 --> 01:25:09.900]  занумеровать куб. И в принципе любую степень. То существует уже супер функция,
[01:25:09.900 --> 01:25:19.020]  я его назову кси от n, которая действует иначе. Она берёт натуральное число и возвращает вот такую
[01:25:19.020 --> 01:25:27.980]  пару. У нас либо n конечную, тогда нам ничего не хватит там дополнительно бекции перевести. А если
[01:25:27.980 --> 01:25:36.060]  там бесконечно, у нас всё равно это может перевестись там какой-то бекцией. Так что никакого
[01:25:36.060 --> 01:25:47.020]  проблемы перевести, никаких проблем перевести phi в кси нет. И теперь вот этот вот весь страшный
[01:25:47.020 --> 01:26:07.500]  бок мы заменяем на и по натуральном, давайте n по натуральном, а дальше и от а равняется кси от n.
[01:26:07.500 --> 01:26:15.940]  Кси приняла, вернула нам три аргумента, мы с помощью их получили. Всё, так мы это всё вывели.
[01:26:15.940 --> 01:26:20.380]  В целом, я на этом всё. Если есть вопросы, готов ответить.
[01:26:30.380 --> 01:26:33.540]  Видимо вопросов нет, тогда всё, всем спасибо.
[01:26:37.500 --> 01:26:39.540]  С вами был Игорь Негода.
