[00:00.000 --> 00:13.200]  Так, ну ладно, окей, давайте продолжим. У нас сегодня с вами планы более чем наполеоновские,
[00:13.200 --> 00:19.040]  я бы сказал. Хочется разобрать целых две структуры данных, успеть за одну лекцию.
[00:19.040 --> 00:23.720]  Вот если мы успеем, то сегодня мы закончим тогда обработку запросов на отрезках и
[00:23.720 --> 00:32.040]  пойдем дальше в какую-нибудь степь, скорее всего будет хэштаблица. Так, лекция девять.
[00:32.040 --> 00:42.080]  Дерево Фенлика.
[00:42.080 --> 00:56.440]  Собственно, вот это последняя структура, ну предпоследняя. И что мы от нее хотим?
[00:56.440 --> 01:09.400]  Пусть F. Давайте даже F. Какая она у нас будет? Ну ассоциативная.
[01:09.400 --> 01:19.160]  Чем еще от нее будем хотеть? Ну мы будем хотеть не обратимости.
[01:19.160 --> 01:29.440]  Ассоциативная обратимая имеет не тройный элемент, кому-то активность, это стандартные
[01:29.440 --> 01:45.600]  требования. Вот это вот два главных. Вот тогда назовем деревом Фенлика массив 3,
[01:45.600 --> 02:02.880]  который по определению имеет вот такой вот вид. Вот видите, F большую мы еще не вводили,
[02:02.880 --> 02:12.400]  это она вот с этой никак не связана. Так, сейчас. Сумма, то есть у нас F это сумма, а иначе мы будем
[02:12.400 --> 02:34.400]  делать вот так вот. Вот это у нас вот F от А, F от И, А, F от И, А, И, Т. И, Т. Элемент дерева Фенлика.
[02:34.400 --> 02:48.880]  Деревом Фенлика будем называть сам массив 3. Теперь, чтобы окончательно вас обескуражить,
[02:48.880 --> 03:05.280]  я скажу, что такое F от И, F большая. Это вот такая вот странная закорючка, где берут И и плюс 1,
[03:05.280 --> 03:14.560]  делают побитого И между ними. Ну, давайте я приведу пример. Давайте здесь напишем. Например,
[03:14.560 --> 03:34.200]  И равно АИТ. Так, например, И равно, давайте какое-нибудь такое число выберем в двоичной
[03:34.200 --> 03:50.360]  системе счисления. Вот. Ну, что это такое? 0, 1, 2, 3, 4, 5, 32 плюс 7, 39. Тогда И плюс 1,
[03:50.360 --> 04:14.240]  это будет вот такая вот крокозябра какая-то. 40. Давайте возьмем побитого И. 0, 0, 0, 0, 0, 1, 32.
[04:14.240 --> 04:33.000]  Так, ладно. Какая-то интересная вещь. Зачем нам нужна обратимость операции? Что, обратимость?
[04:33.000 --> 04:40.960]  Не так. Давайте я напишу заново определение обратимости. Ну, у нас было на первой лекции.
[04:40.960 --> 05:00.800]  Будем называть F обратимой, если для любых Х, З существует единственный Y, такой, что F от Х,
[05:00.840 --> 05:12.440]  Y равно Z. Ну, в частности, для сложения, то есть у вас Х плюс Y равно Z, вы можете написать,
[05:12.440 --> 05:19.160]  что у вас есть обратная операция, что Y это Z минус X. То есть вы можете однозначно найти,
[05:19.160 --> 05:24.200]  то есть если вы знаете один аргумент и ответ, вы однозначно можете восстанавливать второй
[05:24.200 --> 05:31.160]  аргумент. Ну, вот пример необратимых операций. Это минимум. Минимум из 3 и X равен 3. У
[05:31.160 --> 05:40.680]  СХ может быть любое число, превосходящее 3. Ну или тройка тоже. Вот. Окей, тогда как мы будем
[05:40.680 --> 05:51.520]  считать F от АЛ того, АР того? Это массивчик наш исходный. Но у нас был какой-то исходный массив,
[05:51.520 --> 05:55.920]  мы все время хотим отвечать на запросы на подотрески. У нас вот все вот эти лекции,
[05:55.920 --> 06:03.720]  значит, так стоит. Вот есть массив А, хотим отвечать на подотрески. Вот. F от АЛ, АР. Как-то
[06:03.720 --> 06:10.360]  понимать можно. Это можно понимать так, что это будто бы какая-то F минус первая, то есть обратная
[06:10.360 --> 06:34.680]  операция. F от А1, АР, F от А1, АЛ минус 1. Сложно понимаю. Если F это сумма, то сумма от АЛ
[06:34.680 --> 06:45.280]  до АР, это А1 плюс тра-та-та плюс АР минус А1 плюс тра-та-та АЛ минус 1. Мы вспоминаем префиксные
[06:45.280 --> 06:53.360]  суммы с первой лекции. Только это они записаны в страшном видео. Вот для этого нам нужна обратимость,
[06:53.360 --> 07:02.880]  чтобы умели делать вот так вот. Давайте в частности напишем, что сумма пожи от L до R, а житых это
[07:02.880 --> 07:20.840]  пожи от 1 до R, а житых минус до L минус 1, а житых. Вот. Окей. Оказалось бы, все круто, да?
[07:23.360 --> 07:32.160]  L минус 1, да. Где L? Это R.
[07:32.160 --> 07:53.360]  Нет. F минус 1 со двух аргументов. Раз аргумент, два аргумент.
[07:53.360 --> 08:08.120]  Вот. Окей. То есть получается, что у нас с вами есть. У нас есть с вами это, у нас есть с вами что-то вот
[08:08.120 --> 08:16.800]  такое вот страшное. Давайте поймем тогда, как считать будто бы код запроса на отрезке.
[08:16.800 --> 08:24.120]  Давайте сначала научимся считать вот F от тра-та-та. То есть у нас здесь будет
[08:24.120 --> 08:35.960]  существовать класс Henvick 3. Мы его сегодня будем сами в лекцию писать и дописывать постепенно.
[08:35.960 --> 08:42.040]  У которого будут какие-то паблик штуки.
[08:42.040 --> 08:49.840]  Наверное, здесь позволят только объявления. Я буду считать его только для субма.
[08:49.840 --> 09:00.760]  И мы будем возвращать следующее.
[09:00.760 --> 09:18.120]  Метод будет константным у нас. Префикс sum от R. Префикс sum от L минус 1.
[09:18.120 --> 09:27.920]  Вот. Это выражение dF минус 1. Теперь для самой F будем считать.
[09:27.920 --> 09:34.080]  Давайте сразу напишем функцию update просто.
[09:34.080 --> 09:47.960]  Напишу объявление, потому что реализация сюда не влезет. Мы сейчас будем приватную часть класса писать.
[09:47.960 --> 09:50.480]  Где-нибудь потом допишем update потом.
[09:50.480 --> 10:00.080]  Первым у нас будет вот это вот префикс sum.
[10:00.080 --> 10:27.440]  Собственно, она будет делать, теперь будет for и больше нуля.
[10:27.440 --> 10:37.000]  И равно f от i минус 1.
[10:37.000 --> 10:45.200]  ans 3 it.
[10:45.200 --> 10:50.320]  Дальше будет return ans.
[10:50.320 --> 10:58.720]  Вот пока что такой вот код.
[10:58.720 --> 11:02.240]  Смотрите, что мы делаем.
[11:02.240 --> 11:08.320]  Вот наш массивчик есть.
[11:08.320 --> 11:11.280]  Вот есть какой-то индекс i.
[11:11.280 --> 11:15.960]  Допустим, что f от i где-то здесь.
[11:16.120 --> 11:21.760]  Но я думаю, не трудно догадаться, что f от i строго меньше i.
[11:21.760 --> 11:30.240]  Вот это достаточно очевидное неравенство, меньше либо равно.
[11:30.240 --> 11:35.200]  Чуть позже мы его объясним. Пока что просто уверуем в это.
[11:35.200 --> 11:43.000]  Тогда дальше вот эта вот часть. Это f от i минус 1. То есть у вас теперь новый индекс.
[11:43.040 --> 11:50.200]  Вы получаете новое значение f от f от i минус 1.
[11:50.200 --> 11:57.080]  Отнимаете снова 1, снова прыгаете назад. И рано или поздно вы допрыгаете до нуля.
[11:57.080 --> 12:06.200]  Таким образом, вот это вот получение префиксной суммы просто очень-очень странным образом.
[12:06.200 --> 12:09.880]  Ну тогда ответ получается как разность префиксных сумм.
[12:09.920 --> 12:16.840]  В общем случае, вы здесь просто пишете не плюс равно, а ans равно f от ans запитает 3i.
[12:16.840 --> 12:20.520]  Если у вас шаблон на f туда передается.
[12:20.520 --> 12:24.080]  Ну и здесь применяйте f минус 1.
[12:24.080 --> 12:34.480]  Хорошо. Давайте разберемся с тем, что делает f большая.
[12:34.480 --> 12:36.880]  Будут идеи у кого, что делает f большая с числом?
[12:40.880 --> 12:43.880]  Если у вас число заканчивается на ноль, что делает f большая?
[12:48.880 --> 12:56.880]  Если i делится на 2, то f от i равно i.
[12:57.280 --> 12:58.280]  Но почему это так?
[12:58.280 --> 13:07.280]  Потому что у вас i тогда равно 0 в двуичной системе и плюс 1 равно 1 в двуичной системе.
[13:07.280 --> 13:14.280]  Но берем побитого i, получаем тоже самое, потому что здесь все одинаковое, а здесь 0.
[13:14.680 --> 13:28.680]  Хорошо. Пускай, пусть i, это будет что-то что-то 0, 1, 1.
[13:28.680 --> 13:30.680]  Здесь все единицы будут.
[13:30.680 --> 13:35.680]  То есть это какая-то штука, которая как-то начинается, дальше идет 0 и дальше блок из единиц.
[13:35.680 --> 13:38.680]  Тогда как выглядит i плюс 1?
[13:44.680 --> 13:46.680]  Просыпаемся.
[13:49.680 --> 13:52.680]  Тра-та-та, 1, 0, 0.
[13:52.680 --> 13:55.680]  Берем побитого i, получаем.
[13:59.680 --> 14:09.680]  Итого f от i зануляет правый блок из единиц.
[14:14.680 --> 14:16.680]  Откуда вас следует?
[14:16.680 --> 14:24.680]  Что у вас при каждом запуске f от i число единичек падает, хорошо, до каждой 2 запуска f от i.
[14:24.680 --> 14:30.680]  На каждый день даже запуска f от i у вас хотя бы на единицу падает число единицы в двуичной записи числа i.
[14:32.680 --> 14:35.680]  Возвращаемся к коду запроса.
[14:36.080 --> 14:47.080]  То есть у вас каждой 2 таких запуска уменьшается хотя бы на единицу число единиц в двуичной записи изначального i.
[14:47.080 --> 14:54.080]  Откуда вас следует, что этот код работает за логарифом как максимум.
[14:54.080 --> 14:59.080]  Но на самом деле он пропорционален числу единиц в двуичной записи вашего числа.
[14:59.080 --> 15:03.080]  Точнее, там немножко другая зависимость.
[15:03.480 --> 15:05.480]  Но я думаю, идея есть сна.
[15:05.480 --> 15:08.480]  То есть у вас зависимость не просто от n, а от двуичной записи числа i.
[15:08.480 --> 15:10.480]  То есть на более точное, более тонкое.
[15:10.480 --> 15:12.480]  И в среднем гораздо быстрее, чем в дереве отрезков.
[15:12.480 --> 15:14.480]  Константа у вас будет.
[15:17.480 --> 15:22.480]  Поэтому если вы интересовались до сих пор вопросом, зачем мы это делаем все,
[15:22.480 --> 15:25.480]  есть у нас тут и ассоциативность, и обратимость.
[15:25.480 --> 15:28.480]  А дерево отрезков умеет без обратимости работать.
[15:28.880 --> 15:32.880]  Во-первых, мы стремимся к тому, что это будет быстро работать.
[15:32.880 --> 15:34.880]  Быстрее, чем дерево отрезков.
[15:34.880 --> 15:36.880]  Это первое.
[15:36.880 --> 15:38.880]  Что?
[15:38.880 --> 15:41.880]  Ну, конечно, иначе нельзя это применять.
[15:41.880 --> 15:43.880]  Второе.
[15:43.880 --> 15:51.880]  Как вы помните, если я подам дереву отрезков массив длиной 2 в степени k плюс 1,
[15:51.880 --> 15:53.880]  что я должен буду сделать?
[15:53.880 --> 15:55.880]  Я должен буду его выделить.
[15:55.880 --> 15:57.880]  То есть как у меня будет эволюционировать размер дерева?
[15:58.280 --> 16:00.280]  Вот я ему подал вот такое вот для дерева отрезков.
[16:00.280 --> 16:06.280]  Вы должны будете выделить, дополнить нейтральными, до вот такого вот размера.
[16:06.280 --> 16:08.280]  Согласны?
[16:08.280 --> 16:12.280]  А дальше мы это еще с вами превращали в вот такую вот штуку.
[16:14.280 --> 16:17.280]  Чтобы верхушку дерева написать в массив.
[16:17.280 --> 16:22.280]  То есть, и того 4 в степени k.
[16:22.280 --> 16:24.280]  Ой, Господи.
[16:24.680 --> 16:27.680]  Два степени k плюс два приблизительно.
[16:27.680 --> 16:29.680]  А вот здесь два степени k.
[16:29.680 --> 16:31.680]  То есть, приблизительно в 4 раза вы здесь увеличиваете память.
[16:31.680 --> 16:35.680]  А здесь вам дали ваш массив и вы записали,
[16:35.680 --> 16:38.680]  можете хоть поверх него вот это дерево написать, массив 3.
[16:38.680 --> 16:40.680]  Можете отдельно записать.
[16:40.680 --> 16:42.680]  Он все равно длины n.
[16:42.680 --> 16:44.680]  То есть, памяти в константу раз меньше.
[16:44.680 --> 16:46.680]  Это два.
[16:46.680 --> 16:48.680]  Три.
[16:48.680 --> 16:53.680]  Ну, давайте посмотрим, сколько строчек у нас заняло код запроса.
[16:54.080 --> 16:56.080]  Раз, два, три.
[16:56.080 --> 16:58.080]  Давайте содержательно.
[16:58.080 --> 17:00.080]  Хорошо, без объявлений.
[17:00.080 --> 17:02.080]  Раз, два, три, четыре, пять.
[17:02.080 --> 17:04.080]  Шесть.
[17:04.080 --> 17:06.080]  Все.
[17:06.080 --> 17:08.080]  Если вы писали дерево отрезков на семинаре или еще где-то,
[17:08.080 --> 17:14.080]  вы могли видеть, что там внезапно в 4 раза больше строк.
[17:14.080 --> 17:16.080]  То есть, пишется это гораздо быстрее.
[17:16.080 --> 17:18.080]  Вот.
[17:18.080 --> 17:20.080]  Ладно.
[17:20.080 --> 17:22.080]  Хорошо.
[17:22.480 --> 17:24.480]  В итоге умеем.
[17:24.480 --> 17:28.480]  На текущий момент мы умеем с вами брать стумму на подотрезке.
[17:28.480 --> 17:32.480]  Ну, какую-то обратимую ассоциативную операцию.
[17:32.480 --> 17:34.480]  Хорошо, на подотрезке.
[17:34.480 --> 17:36.480]  Мы не умеем обновлять элементы.
[17:36.480 --> 17:40.480]  Мы умеем брать эту операцию от логарифма.
[17:40.480 --> 17:42.480]  Круто.
[17:42.480 --> 17:44.480]  Мы пришли к успеху.
[17:44.480 --> 17:46.480]  У нас перфиксная сумма умеет все то же самое,
[17:46.480 --> 17:48.480]  только за единицу брать результат операции на подотрезке.
[17:48.480 --> 17:50.480]  Поэтому давайте учиться обновлять элементы.
[17:50.880 --> 17:52.880]  Вот.
[17:52.880 --> 17:54.880]  Какую доску можно стереть?
[17:54.880 --> 17:56.880]  Наверное, эту.
[18:08.880 --> 18:10.880]  Так.
[18:10.880 --> 18:12.880]  Давайте я здесь напишу, чтобы мы не забывали с вами,
[18:12.880 --> 18:14.880]  что f от i.
[18:15.280 --> 18:17.280]  Вот такая вот.
[18:19.280 --> 18:21.280]  Теперь страшная.
[18:21.280 --> 18:23.280]  Я введу функцию g от i.
[18:27.280 --> 18:29.280]  Обитывая i или i плюс 1.
[18:31.280 --> 18:33.280]  Зачем нам нужна g?
[18:33.280 --> 18:35.280]  Мы с вами еще выясним.
[18:35.280 --> 18:37.280]  Пока что.
[18:37.280 --> 18:39.280]  До новых встреч.
[18:44.880 --> 18:46.880]  Давайте я сформулирую страшное утверждение.
[18:46.880 --> 18:50.880]  Ну и может это сформулировать теоремой.
[18:50.880 --> 18:52.880]  Теорема.
[19:00.880 --> 19:02.880]  Даже не так.
[19:02.880 --> 19:04.880]  Зафиксируем i.
[19:08.880 --> 19:10.880]  Зафиксируем какое-то число i.
[19:10.880 --> 19:12.880]  Тогда
[19:14.880 --> 19:16.880]  все такие
[19:16.880 --> 19:18.880]  g
[19:18.880 --> 19:20.880]  что
[19:20.880 --> 19:22.880]  f от g
[19:24.880 --> 19:26.880]  вот так вот
[19:26.880 --> 19:28.880]  то есть что у вас i попадет в этот подотрезок
[19:32.880 --> 19:36.880]  лежат в множестве
[19:38.880 --> 19:40.880]  i
[19:40.880 --> 19:42.880]  g от i
[19:42.880 --> 19:44.880]  g от g от i
[19:48.880 --> 19:50.880]  g от g от i
[20:00.880 --> 20:02.880]  более того
[20:04.880 --> 20:06.880]  в этом множестве
[20:06.880 --> 20:08.880]  нет других
[20:10.880 --> 20:12.880]  элементов.
[20:16.880 --> 20:18.880]  То есть я утверждаю
[20:18.880 --> 20:20.880]  что если я буду брать
[20:20.880 --> 20:22.880]  i
[20:22.880 --> 20:24.880]  затем от этого числа возьму функцию g
[20:24.880 --> 20:26.880]  от этого числа снова возьму функцию g
[20:26.880 --> 20:28.880]  и так далее
[20:28.880 --> 20:30.880]  то я таким образом переберу все возможные g
[20:30.880 --> 20:32.880]  для которых выполнено вот это неравенство.
[20:36.880 --> 20:38.880]  Зачем нам это нужна эта теорема?
[20:38.880 --> 20:40.880]  А затем что
[20:40.880 --> 20:42.880]  если мы ее докажем
[20:42.880 --> 20:44.880]  то как понимать какие у нас
[20:44.880 --> 20:46.880]  элементы дерева
[20:46.880 --> 20:48.880]  нашего массива затронулись?
[20:48.880 --> 20:50.880]  То есть у нас по идее
[20:54.880 --> 20:56.880]  это была вот такая вот штука
[20:56.880 --> 20:58.880]  давайте f
[20:58.880 --> 21:00.880]  f
[21:00.880 --> 21:02.880]  вот a
[21:02.880 --> 21:04.880]  f от i
[21:04.880 --> 21:06.880]  а i
[21:06.880 --> 21:08.880]  вот
[21:08.880 --> 21:10.880]  и теперь нам нужно найти
[21:10.880 --> 21:12.880]  если мы хотим новить элемент
[21:12.880 --> 21:14.880]  то понятное дело что один элемент
[21:14.880 --> 21:16.880]  по одному индексу он попадет в несколько таких отрезков
[21:16.880 --> 21:18.880]  и мы хотим найти все такие
[21:18.880 --> 21:20.880]  отрезки и поменять
[21:20.880 --> 21:22.880]  окей?
[21:22.880 --> 21:24.880]  а вот как их искать
[21:24.880 --> 21:26.880]  непонятно, вообще не очевидно
[21:26.880 --> 21:28.880]  какие i у вас попадет
[21:28.880 --> 21:30.880]  если вы обновите седьмой элемент
[21:30.880 --> 21:32.880]  они говорят обновите седьмой элемент
[21:32.880 --> 21:34.880]  тогда какие 3 i
[21:34.880 --> 21:36.880]  мне придется поменять
[21:36.880 --> 21:38.880]  вот согласно этой теореме
[21:38.880 --> 21:40.880]  что это седьмерка, j от семерки
[21:40.880 --> 21:42.880]  j от j от семерки и так далее
[21:44.880 --> 21:46.880]  ну здесь пока что
[21:46.880 --> 21:48.880]  он не определен, в общем случае
[21:48.880 --> 21:50.880]  мы будем делать пока вот это число не превзойдет
[21:50.880 --> 21:52.880]  размера массива
[21:54.880 --> 21:56.880]  вот
[21:56.880 --> 21:58.880]  ну давайте доказывать теорему
[22:02.880 --> 22:04.880]  давайте докажем первую часть
[22:04.880 --> 22:06.880]  что
[22:06.880 --> 22:08.880]  если
[22:08.880 --> 22:10.880]  число удовлетворяет такому неравенству
[22:10.880 --> 22:12.880]  j, то оно лежит
[22:12.880 --> 22:14.880]  здесь
[22:14.880 --> 22:16.880]  хорошо
[22:16.880 --> 22:18.880]  первая часть
[22:18.880 --> 22:20.880]  ну очевидно
[22:20.880 --> 22:22.880]  что
[22:22.880 --> 22:24.880]  очевидно
[22:24.880 --> 22:26.880]  и подходит
[22:28.880 --> 22:30.880]  f от i
[22:30.880 --> 22:32.880]  меньше либо равно i
[22:32.880 --> 22:34.880]  меньше либо равно i
[22:34.880 --> 22:36.880]  но это тривиально
[22:36.880 --> 22:38.880]  ну вот это вот
[22:38.880 --> 22:40.880]  просто тождественно верно
[22:40.880 --> 22:42.880]  равенство здесь, а здесь
[22:42.880 --> 22:44.880]  потому что у вас либо число не меняется
[22:44.880 --> 22:46.880]  либо у него зануляется блок из единиц
[22:46.880 --> 22:48.880]  поэтому оно только уменьшаться может
[22:50.880 --> 22:52.880]  теперь давайте докажем следующее
[22:52.880 --> 22:54.880]  что
[22:54.880 --> 22:56.880]  я возьму следующее число
[22:56.880 --> 22:58.880]  f от
[22:58.880 --> 23:00.880]  j от i
[23:00.880 --> 23:02.880]  рассмотрю его
[23:02.880 --> 23:04.880]  и
[23:04.880 --> 23:06.880]  рассмотрю его с j от i
[23:10.880 --> 23:12.880]  вот если это
[23:12.880 --> 23:14.880]  верно
[23:14.880 --> 23:16.880]  значит я докажу, что вся вот эта вот огромная цепочка
[23:16.880 --> 23:18.880]  удовлетворяет неравенству
[23:20.880 --> 23:22.880]  то есть это как бы база, а это переход
[23:24.880 --> 23:26.880]  давайте доказывать
[23:28.880 --> 23:30.880]  и меньше либо равно j от i
[23:30.880 --> 23:32.880]  ну почему это так?
[23:32.880 --> 23:34.880]  давайте подумаем, что я делаю от фами j
[23:38.880 --> 23:40.880]  ну это понятно, что это по битве или
[23:40.880 --> 23:42.880]  давайте поймем глубинный смысл j от i
[23:42.880 --> 23:44.880]  ну для этой части это не нужно
[23:44.880 --> 23:46.880]  для этой части очевидно, что если вы делаете или
[23:46.880 --> 23:48.880]  с большим числом, то вы не можете себя уменьшить
[23:48.880 --> 23:50.880]  потому что все что было единицами
[23:50.880 --> 23:52.880]  у вас останется единицами
[23:52.880 --> 23:54.880]  а то что было нулями может стать единицами
[23:54.880 --> 23:56.880]  поэтому это неравенство очевидно
[23:56.880 --> 23:58.880]  это очевидно, плюс-минус
[23:58.880 --> 24:00.880]  это очевидно
[24:02.880 --> 24:04.880]  вот второе
[24:04.880 --> 24:06.880]  вот эта вот часть, она вообще не очевидная
[24:06.880 --> 24:08.880]  давайте поймем, что я делаю от j от i
[24:10.880 --> 24:12.880]  пусть i равно
[24:12.880 --> 24:14.880]  что-то, что-то, что-то, ноль, что-то, что-то, что-то
[24:14.880 --> 24:16.880]  а, ну здесь куча единиц
[24:18.880 --> 24:20.880]  то есть это что-то начинающееся
[24:20.880 --> 24:22.880]  затем ноль, затем куча единиц
[24:22.880 --> 24:24.880]  тогда i плюс один
[24:24.880 --> 24:26.880]  плюс один как устроено?
[24:30.880 --> 24:32.880]  да
[24:32.880 --> 24:34.880]  тогда берем побитого или
[24:36.880 --> 24:38.880]  что я сам получу?
[24:38.880 --> 24:40.880]  блок из единиц
[24:40.880 --> 24:42.880]  что?
[24:42.880 --> 24:44.880]  да
[24:46.880 --> 24:48.880]  то есть что у меня получилось?
[24:48.880 --> 24:50.880]  я беру самую правую единицу
[24:50.880 --> 24:52.880]  самую правую ноль
[24:52.880 --> 24:54.880]  превращаю его в единицу
[24:54.880 --> 24:56.880]  то есть у меня i перешел в j от i
[24:56.880 --> 24:58.880]  то есть что делает функция j?
[24:58.880 --> 25:00.880]  она берет самое маленькое число
[25:00.880 --> 25:02.880]  ну самый правый ноль
[25:02.880 --> 25:04.880]  и превращает его в единицу, все
[25:06.880 --> 25:08.880]  j от i
[25:08.880 --> 25:10.880]  превращает
[25:12.880 --> 25:14.880]  младший ноль
[25:18.880 --> 25:20.880]  в единицу
[25:22.880 --> 25:24.880]  я проверял в начале лекции
[25:24.880 --> 25:26.880]  все были рабочими
[25:26.880 --> 25:28.880]  но они почему-то умирают, видимо коллективно
[25:28.880 --> 25:30.880]  как-то
[25:30.880 --> 25:32.880]  вот
[25:32.880 --> 25:34.880]  окей
[25:34.880 --> 25:36.880]  ну давайте тогда поймем, почему это неравенство верное
[25:40.880 --> 25:42.880]  а случай первый i четная
[25:44.880 --> 25:46.880]  то есть i заканчивается на ноль
[25:46.880 --> 25:48.880]  тогда j от i
[25:48.880 --> 25:50.880]  превратит последний ноль в единицу
[25:50.880 --> 25:52.880]  согласны?
[25:52.880 --> 25:54.880]  тогда f от j от i
[25:54.880 --> 25:56.880]  хотя бы эту единицу в ноль точно превратит
[25:58.880 --> 26:00.880]  и дальше единицы, которые могли стоять
[26:00.880 --> 26:02.880]  она тоже могла занудить, если такие были
[26:02.880 --> 26:04.880]  то есть поэтому f от j от i
[26:04.880 --> 26:06.880]  если i четная
[26:06.880 --> 26:08.880]  оно здесь верно
[26:08.880 --> 26:10.880]  давайте сейчас это напишу на доске
[26:10.880 --> 26:12.880]  это вот рассуждение
[26:20.880 --> 26:22.880]  так
[26:22.880 --> 26:24.880]  рассмотрим i
[26:28.880 --> 26:30.880]  давайте рассматривать
[26:30.880 --> 26:32.880]  это что-то что-то что-то
[26:32.880 --> 26:34.880]  имеющее вид
[26:34.880 --> 26:36.880]  там допустим
[26:36.880 --> 26:38.880]  1 ноль заканчивается
[26:42.880 --> 26:44.880]  тогда j от i
[26:44.880 --> 26:46.880]  это вот что-то что-то
[26:46.880 --> 26:48.880]  1 1
[26:48.880 --> 26:50.880]  f от j от i
[26:50.880 --> 26:52.880]  заведомо здесь 0 0
[26:52.880 --> 26:54.880]  вот здесь может быть уже
[26:54.880 --> 26:56.880]  неравные
[26:58.880 --> 27:00.880]  но
[27:02.880 --> 27:04.880]  f от j от i
[27:04.880 --> 27:06.880]  будет меньше, чем j от i
[27:06.880 --> 27:08.880]  в любом случае
[27:08.880 --> 27:10.880]  потому что когда они могут быть неравными
[27:12.880 --> 27:14.880]  когда у вас здесь была единица
[27:14.880 --> 27:16.880]  и здесь единица
[27:16.880 --> 27:18.880]  тогда у вас f от j от i еще и ее съест
[27:22.880 --> 27:24.880]  то есть мы получили с вами
[27:24.880 --> 27:26.880]  что если у нас на 1 ноль заканчивается, то все
[27:26.880 --> 27:28.880]  но аналогично, если мы заканчиваемся
[27:28.880 --> 27:30.880]  давайте
[27:30.880 --> 27:32.880]  f от j
[27:32.880 --> 27:34.880]  да, да, да
[27:34.880 --> 27:36.880]  правда
[27:36.880 --> 27:38.880]  хорошо
[27:38.880 --> 27:40.880]  второй случай
[27:40.880 --> 27:42.880]  заканчивается на 0 0
[27:42.880 --> 27:44.880]  двуечной записи
[27:44.880 --> 27:46.880]  f от j от i
[27:46.880 --> 27:48.880]  0 1
[27:48.880 --> 27:50.880]  f от j от i
[27:50.880 --> 27:52.880]  0 0
[27:54.880 --> 27:56.880]  что равно i
[27:58.880 --> 28:00.880]  окей
[28:00.880 --> 28:02.880]  следующий случай
[28:02.880 --> 28:04.880]  i равно
[28:04.880 --> 28:06.880]  0 1
[28:06.880 --> 28:08.880]  не 0 там
[28:08.880 --> 28:10.880]  просто что-то что-то
[28:10.880 --> 28:12.880]  да, j от i
[28:12.880 --> 28:14.880]  равно
[28:16.880 --> 28:18.880]  1 0
[28:18.880 --> 28:20.880]  f от j от i
[28:20.880 --> 28:22.880]  ой, 1 1, извините
[28:22.880 --> 28:24.880]  мы правой ноль заменяем
[28:26.880 --> 28:28.880]  0 0
[28:28.880 --> 28:30.880]  как видите
[28:30.880 --> 28:32.880]  f от j от i заведомо меньше, чем i
[28:32.880 --> 28:34.880]  и все еще будет здесь
[28:34.880 --> 28:36.880]  здесь ситуация та же самая
[28:36.880 --> 28:38.880]  что если у вас здесь были единицы
[28:38.880 --> 28:40.880]  то f от j от i еще и ее съест сверху
[28:40.880 --> 28:42.880]  третий случай
[28:42.880 --> 28:44.880]  когда вы на 1 1 заканчиваетесь
[28:44.880 --> 28:46.880]  его понятно как анализировать
[28:46.880 --> 28:48.880]  его анализировать надо так
[28:48.880 --> 28:50.880]  когда вы заканчиваетесь на блок из единиц
[28:50.880 --> 28:52.880]  в частности 1 1 сюда подойдет
[28:52.880 --> 28:54.880]  когда j от i
[28:54.880 --> 28:56.880]  это
[28:56.880 --> 28:58.880]  а f от j от i
[28:58.880 --> 29:00.880]  это
[29:00.880 --> 29:02.880]  это
[29:02.880 --> 29:04.880]  это
[29:04.880 --> 29:06.880]  это
[29:06.880 --> 29:08.880]  это
[29:08.880 --> 29:10.880]  а f от j от i
[29:10.880 --> 29:12.880]  вы просто
[29:12.880 --> 29:14.880]  убиваете младший блок из единиц вообще целиком
[29:18.880 --> 29:20.880]  ну понятно
[29:20.880 --> 29:22.880]  что это вообще строго меньше, чем i
[29:24.880 --> 29:26.880]  ну все, мы распространили все возможности в лучшем, доказали
[29:28.880 --> 29:30.880]  доказали
[29:30.880 --> 29:32.880]  что
[29:32.880 --> 29:34.880]  f от
[29:34.880 --> 29:36.880]  j от i
[29:36.880 --> 29:38.880]  не превосходит i
[29:38.880 --> 29:40.880]  не превосходит j от i
[29:40.880 --> 29:42.880]  ну все
[29:42.880 --> 29:44.880]  победа
[29:44.880 --> 29:46.880]  эта часть мы доказали
[29:46.880 --> 29:48.880]  что все такие
[29:48.880 --> 29:50.880]  j от множества
[29:52.880 --> 29:54.880]  то есть
[29:54.880 --> 29:56.880]  все
[29:56.880 --> 29:58.880]  такие j
[29:58.880 --> 30:00.880]  что
[30:00.880 --> 30:02.880]  f от j
[30:02.880 --> 30:04.880]  и меньше, чем j
[30:04.880 --> 30:06.880]  и не так
[30:06.880 --> 30:08.880]  мы доказали с вами, что
[30:08.880 --> 30:10.880]  все элементы множества
[30:10.880 --> 30:12.880]  удовлетворяют нашему
[30:12.880 --> 30:14.880]  так
[30:14.880 --> 30:16.880]  что
[30:16.880 --> 30:18.880]  j лежит
[30:18.880 --> 30:20.880]  в множестве
[30:20.880 --> 30:22.880]  j от i
[30:22.880 --> 30:24.880]  tra ta ta
[30:26.880 --> 30:28.880]  что
[30:28.880 --> 30:30.880]  удовлетворяют
[30:30.880 --> 30:32.880]  f от
[30:34.880 --> 30:36.880]  j
[30:36.880 --> 30:38.880]  меньше его равно i
[30:38.880 --> 30:40.880]  меньше его, чем j
[30:40.880 --> 30:42.880]  вот это мы сами доказали
[30:42.880 --> 30:44.880]  то есть мы доказали, что
[30:44.880 --> 30:46.880]  если я возьму элементы отсюда
[30:46.880 --> 30:48.880]  то он под неравенство подойдет
[30:48.880 --> 30:50.880]  теперь я хочу доказать обратную сторону
[30:50.880 --> 30:52.880]  что если я возьму элементы не отсюда
[30:52.880 --> 30:54.880]  то он под неравенство не подойдет
[30:54.880 --> 30:56.880]  тогда я докажу, что эти множества совпадают
[31:00.880 --> 31:02.880]  ой, ну как доказывать обратную сторону
[31:04.880 --> 31:06.880]  здесь я воспользуюсь
[31:06.880 --> 31:08.880]  немножко записями
[31:08.880 --> 31:10.880]  чтобы было проще
[31:10.880 --> 31:12.880]  докажем
[31:12.880 --> 31:14.880]  что
[31:14.880 --> 31:16.880]  если
[31:18.880 --> 31:20.880]  j
[31:20.880 --> 31:22.880]  не лежит в этом множестве
[31:26.880 --> 31:28.880]  то
[31:30.880 --> 31:32.880]  неверно
[31:34.880 --> 31:36.880]  что
[31:36.880 --> 31:38.880]  f от
[31:38.880 --> 31:40.880]  j
[31:40.880 --> 31:42.880]  докажем
[31:42.880 --> 31:44.880]  что это неравенство неверно
[31:44.880 --> 31:46.880]  хорошо
[31:46.880 --> 31:48.880]  пусть
[31:50.880 --> 31:52.880]  k не принадлежит
[31:52.880 --> 31:54.880]  этому множеству
[31:54.880 --> 31:56.880]  но при этом
[31:56.880 --> 31:58.880]  f от k
[32:02.880 --> 32:04.880]  меньше либо равно k
[32:04.880 --> 32:06.880]  предположим, что
[32:06.880 --> 32:08.880]  у нас нашлось такое k
[32:08.880 --> 32:10.880]  что оно действительно не из этого множества
[32:10.880 --> 32:12.880]  и для него верно неравенство
[32:12.880 --> 32:14.880]  в частности, из вот этой вот части
[32:14.880 --> 32:16.880]  из вот второй
[32:16.880 --> 32:18.880]  и меньше либо равно k
[32:18.880 --> 32:20.880]  следует, что
[32:20.880 --> 32:22.880]  что мы можем записать их
[32:22.880 --> 32:24.880]  следующим образом
[32:34.880 --> 32:36.880]  ну очень хорошо
[32:36.880 --> 32:38.880]  случай первый
[32:38.880 --> 32:40.880]  и равно k
[32:40.880 --> 32:42.880]  понятное дело, что мы его рассмотрели
[32:42.880 --> 32:44.880]  поэтому такого быть не может
[32:46.880 --> 32:48.880]  и равно k
[32:48.880 --> 32:50.880]  противоречие
[32:50.880 --> 32:52.880]  назовем так
[32:52.880 --> 32:54.880]  значит и меньше k
[32:54.880 --> 32:56.880]  тогда вот такой формат
[32:56.880 --> 32:58.880]  у нас есть
[32:58.880 --> 33:00.880]  то есть есть какой-то разряд
[33:00.880 --> 33:02.880]  где здесь написано 0, здесь написано 1
[33:02.880 --> 33:04.880]  хорошо
[33:04.880 --> 33:06.880]  возьмем и штрих
[33:06.880 --> 33:08.880]  то есть мы отсекаем
[33:08.880 --> 33:10.880]  вот этот вот префикс
[33:10.880 --> 33:12.880]  этот префикс, этот первый многоточий
[33:12.880 --> 33:14.880]  мы его отсекаем
[33:14.880 --> 33:16.880]  но что мы с вами видим
[33:16.880 --> 33:18.880]  мы утверждаем, что k
[33:18.880 --> 33:20.880]  не лежит в этом множестве
[33:20.880 --> 33:22.880]  а что у нас с вами делала
[33:22.880 --> 33:24.880]  функция g
[33:24.880 --> 33:26.880]  она берет 0 и постепенно превращает в единицы
[33:26.880 --> 33:28.880]  начиная с самого правого
[33:30.880 --> 33:32.880]  согласны?
[33:32.880 --> 33:34.880]  но функция g
[33:38.880 --> 33:40.880]  делает
[33:40.880 --> 33:42.880]  0
[33:42.880 --> 33:44.880]  единицу
[33:44.880 --> 33:46.880]  тогда
[33:46.880 --> 33:48.880]  как должны быть устроены и штрих, и k-штрих
[33:52.880 --> 33:54.880]  а k-штрих
[33:54.880 --> 33:56.880]  здесь 1
[33:56.880 --> 33:58.880]  здесь 0
[34:00.880 --> 34:02.880]  если бы это было не так
[34:02.880 --> 34:04.880]  то есть у нас не существовала бы позиции
[34:04.880 --> 34:06.880]  где здесь 1, а где здесь 0
[34:08.880 --> 34:10.880]  это значит, что
[34:10.880 --> 34:12.880]  какие у нас переходы может быть g
[34:12.880 --> 34:14.880]  вот в конкретном разряде g что может сделать
[34:14.880 --> 34:16.880]  она может 0 в 1
[34:16.880 --> 34:18.880]  1 в 1
[34:18.880 --> 34:20.880]  ну и там 0 не трогать, например
[34:22.880 --> 34:24.880]  мы убрали вот префикс этот
[34:24.880 --> 34:26.880]  первый многоточий убрали
[34:26.880 --> 34:28.880]  и все, получили такие части
[34:28.880 --> 34:30.880]  будто бы взяли по модулю
[34:30.880 --> 34:32.880]  или сдвинули
[34:34.880 --> 34:36.880]  здесь?
[34:36.880 --> 34:38.880]  смотрите
[34:38.880 --> 34:40.880]  еще раз
[34:40.880 --> 34:42.880]  если к
[34:42.880 --> 34:44.880]  не могло быть получено
[34:44.880 --> 34:46.880]  вот таким вот образом
[34:46.880 --> 34:48.880]  мы должны тогда понять, что у нас должно быть
[34:48.880 --> 34:50.880]  и та к единица
[34:50.880 --> 34:52.880]  которая в к на соответствующем месте дает 0
[34:54.880 --> 34:56.880]  тогда к не может быть получено
[34:56.880 --> 34:58.880]  из и такой операции
[34:58.880 --> 35:00.880]  иначе, как бы вы не пытались
[35:00.880 --> 35:02.880]  вы можете получить k
[35:02.880 --> 35:04.880]  ну почему?
[35:04.880 --> 35:06.880]  потому что если у вас 0
[35:06.880 --> 35:08.880]  0
[35:08.880 --> 35:10.880]  это окей
[35:10.880 --> 35:12.880]  типа если у вас здесь 0 и здесь 0
[35:12.880 --> 35:14.880]  то окей, без проблем
[35:16.880 --> 35:18.880]  хорошо, если у вас здесь 1 и здесь 1
[35:18.880 --> 35:20.880]  то тоже без проблем
[35:20.880 --> 35:22.880]  1 в 1 перейдет под действием g
[35:22.880 --> 35:24.880]  и все будет нормально
[35:24.880 --> 35:26.880]  дальше
[35:26.880 --> 35:28.880]  0 в 1
[35:28.880 --> 35:30.880]  ну да, вы следовательно применяя
[35:30.880 --> 35:32.880]  функцию jack и превратите
[35:32.880 --> 35:34.880]  0 в единичку на этой позиции
[35:34.880 --> 35:36.880]  но вот единичку в 0
[35:36.880 --> 35:38.880]  вы никогда не превратите с помощью функции g
[35:40.880 --> 35:42.880]  то есть применяя функцию g к числу вот здесь
[35:42.880 --> 35:44.880]  у вас никогда
[35:44.880 --> 35:46.880]  0 не встанет на этой позиции
[35:46.880 --> 35:48.880]  как бы вы же не применяли
[35:48.880 --> 35:50.880]  потому что g уважает единицу
[35:50.880 --> 35:52.880]  у вас была единица, она останется единицей
[35:52.880 --> 35:54.880]  был 0, он станет единицей
[35:54.880 --> 35:56.880]  но единица 0 никогда не станет
[35:58.880 --> 36:00.880]  окей, тогда мы получаем, что у нас
[36:00.880 --> 36:02.880]  вот такой вид
[36:02.880 --> 36:04.880]  но осталась последняя
[36:04.880 --> 36:06.880]  рассмотрим f от k'
[36:10.880 --> 36:12.880]  как вы думаете, чему равно f от k'?
[36:16.880 --> 36:18.880]  f от k'
[36:18.880 --> 36:20.880]  не
[36:20.880 --> 36:22.880]  занулит
[36:22.880 --> 36:24.880]  левую
[36:24.880 --> 36:26.880]  единицу
[36:28.880 --> 36:30.880]  то есть f от k'
[36:30.880 --> 36:32.880]  не может никак в эту единицу
[36:32.880 --> 36:34.880]  превратить в 0
[36:34.880 --> 36:36.880]  согласны?
[36:36.880 --> 36:38.880]  потому что у вас здесь банально есть 0
[36:38.880 --> 36:40.880]  она бы с этим бы нулем сначала разбиралась
[36:42.880 --> 36:44.880]  но из этого следует
[36:46.880 --> 36:48.880]  что f от k'
[36:48.880 --> 36:50.880]  строго больше
[36:50.880 --> 36:52.880]  чем и штрих
[36:52.880 --> 36:54.880]  потому что
[36:54.880 --> 36:56.880]  если вы f от k' применять
[36:56.880 --> 36:58.880]  у вас здесь все равно останется 1, а здесь все равно 0
[36:58.880 --> 37:00.880]  а из этого следует
[37:00.880 --> 37:02.880]  что f от k'
[37:02.880 --> 37:04.880]  больше
[37:04.880 --> 37:06.880]  чем и
[37:08.880 --> 37:10.880]  противоречие
[37:10.880 --> 37:12.880]  доказали
[37:12.880 --> 37:14.880]  что если число
[37:14.880 --> 37:16.880]  не было получено
[37:16.880 --> 37:18.880]  таким вот применением g
[37:18.880 --> 37:20.880]  то оно не будет подходить
[37:20.880 --> 37:22.880]  под вот это неравенство
[37:22.880 --> 37:24.880]  тирем доказано
[37:28.880 --> 37:30.880]  тезис
[37:30.880 --> 37:32.880]  на что именно?
[37:32.880 --> 37:34.880]  мы доказали
[37:34.880 --> 37:36.880]  что
[37:36.880 --> 37:38.880]  в чем была глубинная идея
[37:38.880 --> 37:40.880]  и с чем мы вообще хотим добиться
[37:40.880 --> 37:42.880]  мы с вами говорили, что
[37:42.880 --> 37:44.880]  мы умеем с вами брать get some
[37:44.880 --> 37:46.880]  но мы не умеем делать update
[37:46.880 --> 37:48.880]  потому что непонятно
[37:48.880 --> 37:50.880]  что если я скажу поменяй мне
[37:50.880 --> 37:52.880]  житый элемент на такой-то
[37:52.880 --> 37:54.880]  какие 3 it
[37:54.880 --> 37:56.880]  будут таковы, что
[37:56.880 --> 37:58.880]  они будут лежать внутри этого множества
[37:58.880 --> 38:00.880]  не очевидно
[38:00.880 --> 38:02.880]  то есть нам непонятно
[38:02.880 --> 38:04.880]  какие g нам надо будет поменять в случае апдейта
[38:04.880 --> 38:06.880]  этого элемента
[38:06.880 --> 38:08.880]  это все такие g
[38:08.880 --> 38:10.880]  что выполнено вот это неравенство
[38:10.880 --> 38:12.880]  если мы меняем it
[38:12.880 --> 38:14.880]  и теперь мы доказываем
[38:14.880 --> 38:16.880]  что все такие g получаются
[38:16.880 --> 38:18.880]  последовательным применением кучи раз функций g
[38:18.880 --> 38:20.880]  и доказываем, что других быть не может
[38:20.880 --> 38:22.880]  тогда update ведется к тому
[38:22.880 --> 38:24.880]  что мы просто будем брать g
[38:24.880 --> 38:26.880]  поменять индексы, менять элемент
[38:26.880 --> 38:28.880]  это все, что мы будем делать
[38:32.880 --> 38:34.880]  ну и дальше что мы делаем
[38:34.880 --> 38:36.880]  мы доказываем две части
[38:36.880 --> 38:38.880]  первая часть, что
[38:38.880 --> 38:40.880]  эти числа отсюда
[38:40.880 --> 38:42.880]  удовлетворяет это неравенство
[38:44.880 --> 38:46.880]  доказали каким образом
[38:46.880 --> 38:48.880]  посмотрели, что для i подходит
[38:48.880 --> 38:50.880]  применили переход функций g
[38:50.880 --> 38:52.880]  то есть база i подошла
[38:52.880 --> 38:54.880]  переход функций g подошло, все
[38:56.880 --> 38:58.880]  доказываем в обратную сторону
[38:58.880 --> 39:00.880]  что никаких других чисел быть не может
[39:00.880 --> 39:02.880]  удовлетворяющих нашему двойному неравенству
[39:04.880 --> 39:06.880]  действуем от противного
[39:06.880 --> 39:08.880]  предполагаем, что такое возможно
[39:08.880 --> 39:10.880]  то есть найдется такой g
[39:10.880 --> 39:12.880]  не лежащий в этом множестве
[39:12.880 --> 39:14.880]  такой каточнее
[39:14.880 --> 39:16.880]  но при этом верно такое неравенство
[39:16.880 --> 39:18.880]  ну и теперь мы просто рассмотрели конструктивно
[39:18.880 --> 39:20.880]  и пришли к подтвердить, что такого быть не может
[39:20.880 --> 39:22.880]  просто играли с двуичной записью
[39:26.880 --> 39:28.880]  ну по приколу, чтобы не мучиться
[39:28.880 --> 39:30.880]  с этими префиксами
[39:30.880 --> 39:32.880]  можно без них побойтись
[39:32.880 --> 39:34.880]  ну просто как-то
[39:34.880 --> 39:36.880]  писать многоточие здесь еще несколько раз
[39:36.880 --> 39:38.880]  было бы неприятно
[39:38.880 --> 39:40.880]  возможно еще раз
[39:40.880 --> 39:42.880]  когда мы говорим, что g у нас
[39:42.880 --> 39:44.880]  ну короче, g не сделает левишки и кастрюли
[39:44.880 --> 39:46.880]  все просто по-всему
[39:46.880 --> 39:48.880]  почему у нас это не сделает
[39:48.880 --> 39:50.880]  если у нас была куча нулей
[39:50.880 --> 39:52.880]  ну типа
[39:52.880 --> 39:54.880]  тогда они не различаются вообще
[39:54.880 --> 39:56.880]  в этой позиции
[39:56.880 --> 39:58.880]  мы должны рассматривать позиции, где они разные
[39:58.880 --> 40:00.880]  если у вас 0 в 1
[40:00.880 --> 40:02.880]  легко перейдет, а вот 1 в 0 никогда
[40:02.880 --> 40:04.880]  а если у вас одинаковые
[40:04.880 --> 40:06.880]  на этой позиции были, то че их рассматривать
[40:06.880 --> 40:08.880]  там не интересно
[40:10.880 --> 40:12.880]  если они не найдутся
[40:12.880 --> 40:14.880]  да
[40:18.880 --> 40:20.880]  ну это правда
[40:20.880 --> 40:22.880]  на самом деле, да
[40:22.880 --> 40:24.880]  кастрих нуля достаточно
[40:24.880 --> 40:26.880]  ну да, действительно
[40:26.880 --> 40:28.880]  да, вам достаточно, чтобы в кастрих
[40:28.880 --> 40:30.880]  нашелся 0
[40:30.880 --> 40:32.880]  чтобы вы не могли
[40:32.880 --> 40:34.880]  из иштрих, как бы вы не пытались
[40:34.880 --> 40:36.880]  да, действительно, здесь вы правы
[40:36.880 --> 40:38.880]  здесь можно любое число поставить
[40:38.880 --> 40:40.880]  главное, чтобы в кастрих 0 нашелся
[40:40.880 --> 40:42.880]  тогда вы
[40:42.880 --> 40:44.880]  не превратите
[40:44.880 --> 40:46.880]  последовательно при мне иштрих
[40:46.880 --> 40:48.880]  в 0 ничего
[40:48.880 --> 40:50.880]  в ноль
[40:50.880 --> 40:52.880]  иштрих
[40:52.880 --> 40:54.880]  последовательно применяя иштрих
[40:54.880 --> 40:56.880]  в ноль ничего не превратите
[40:56.880 --> 40:58.880]  применяя ж иштрих кучу раз
[40:58.880 --> 41:00.880]  у вас здесь станет единица рано или поздно
[41:00.880 --> 41:02.880]  а здесь у вас ноль
[41:02.880 --> 41:04.880]  да, спасибо
[41:08.880 --> 41:10.880]  ну доказали, в общем-то
[41:14.880 --> 41:16.880]  ну если его нет
[41:16.880 --> 41:18.880]  если здесь все единица
[41:18.880 --> 41:20.880]  из такой позиции нет
[41:20.880 --> 41:22.880]  если применяю функцию ж, вы здесь все в единицу превратите
[41:24.880 --> 41:26.880]  и значит вы станете равным
[41:26.880 --> 41:28.880]  кастрих
[41:28.880 --> 41:30.880]  а вы хотите доказать, что такого быть не может
[41:30.880 --> 41:32.880]  потому что у вас кастрих заведомо
[41:32.880 --> 41:34.880]  берется такое, что оно не может быть
[41:34.880 --> 41:36.880]  таким образом получено
[41:40.880 --> 41:42.880]  потому что у вас ка не лежит в этом множестве
[41:42.880 --> 41:44.880]  просто
[41:44.880 --> 41:46.880]  ладно, давайте
[41:46.880 --> 41:48.880]  сделаем проще, избавимся от иштрих кастрих
[41:48.880 --> 41:50.880]  и штрих
[41:50.880 --> 41:52.880]  я понял
[41:54.880 --> 41:56.880]  и равно
[41:56.880 --> 41:58.880]  ноль, ка равно
[41:58.880 --> 42:00.880]  один
[42:02.880 --> 42:04.880]  все
[42:04.880 --> 42:06.880]  f от k не нулит левую единицу
[42:06.880 --> 42:08.880]  f от k больше и
[42:08.880 --> 42:10.880]  ну
[42:14.880 --> 42:16.880]  избавились от лишних сущностей
[42:16.880 --> 42:18.880]  так понятно
[42:20.880 --> 42:22.880]  почему здесь не может быть единицу
[42:22.880 --> 42:24.880]  ну примените f от k хорошо
[42:24.880 --> 42:26.880]  f от k
[42:26.880 --> 42:28.880]  если у вас вы находите
[42:28.880 --> 42:30.880]  на ноль
[42:30.880 --> 42:32.880]  смотри, f от k, оно что делает
[42:34.880 --> 42:36.880]  то у вас блок из единицы только здесь может быть
[42:36.880 --> 42:38.880]  у вас ноль
[42:38.880 --> 42:40.880]  у вас ноль ограждает специально
[42:40.880 --> 42:42.880]  для этого он нам нужен
[42:42.880 --> 42:44.880]  то он вообще ничего не сделает
[42:44.880 --> 42:46.880]  с числом
[42:46.880 --> 42:48.880]  мы здесь специально поставили ноль
[42:48.880 --> 42:50.880]  чтобы оградить эту единицу
[42:50.880 --> 42:52.880]  если вы в шахматы играли
[42:52.880 --> 42:54.880]  чтобы спасти короля
[42:54.880 --> 42:56.880]  вы ставите фигурку между нападающей фигурой
[42:56.880 --> 42:58.880]  и королем
[42:58.880 --> 43:00.880]  вы ставите ноль специально
[43:00.880 --> 43:02.880]  как защиту
[43:02.880 --> 43:04.880]  от действия функциев
[43:04.880 --> 43:06.880]  что?
[43:06.880 --> 43:08.880]  не понял
[43:08.880 --> 43:10.880]  справа от нуля
[43:10.880 --> 43:12.880]  не обязательно
[43:12.880 --> 43:14.880]  мы просто сказали, что должен быть какой-то ноль
[43:14.880 --> 43:16.880]  для определенности
[43:16.880 --> 43:18.880]  это самый правый ноль
[43:18.880 --> 43:20.880]  и здесь действительно блок из единиц
[43:20.880 --> 43:22.880]  но это не принципиально, вам главное чтобы какой-то ноль нашелся
[43:22.880 --> 43:24.880]  окей
[43:24.880 --> 43:26.880]  давайте так скажем для определенности
[43:26.880 --> 43:28.880]  если у вас здесь все единицы
[43:28.880 --> 43:30.880]  то у вас f от k
[43:30.880 --> 43:32.880]  превращает эту штуку в нули
[43:32.880 --> 43:34.880]  это плохо
[43:34.880 --> 43:36.880]  нет, смотрите еще раз
[43:36.880 --> 43:38.880]  у вас не может быть здесь все единицы
[43:38.880 --> 43:40.880]  просто по определению
[43:40.880 --> 43:42.880]  того, что k
[43:42.880 --> 43:44.880]  не лежит в этом множестве
[43:44.880 --> 43:46.880]  потому что если бы здесь
[43:46.880 --> 43:48.880]  были бы все единицы, то k могло бы быть получено
[43:48.880 --> 43:50.880]  из и такими операциями
[43:50.880 --> 43:52.880]  такими операциями
[43:52.880 --> 43:54.880]  что?
[43:54.880 --> 43:56.880]  такими операциями
[43:56.880 --> 43:58.880]  так
[43:58.880 --> 44:00.880]  давайте мы закончим код наконец-то
[44:00.880 --> 44:02.880]  раз мы доказали теорему
[44:02.880 --> 44:04.880]  мы можем дерево дописать
[44:04.880 --> 44:06.880]  а именно мы сделаем следующее
[44:08.880 --> 44:10.880]  вызовем функцию
[44:12.880 --> 44:14.880]  update
[44:14.880 --> 44:16.880]  delta от
[44:16.880 --> 44:18.880]  по индексу
[44:18.880 --> 44:20.880]  и
[44:20.880 --> 44:22.880]  сейчас
[44:22.880 --> 44:24.880]  val
[44:24.880 --> 44:26.880]  minus aity
[44:28.880 --> 44:30.880]  то есть это delta, на который вам надо
[44:30.880 --> 44:32.880]  увеличить значение все
[44:32.880 --> 44:34.880]  то есть у вас был aity
[44:34.880 --> 44:36.880]  стал value
[44:36.880 --> 44:38.880]  то есть вы берете их разность, это значит вашу delta
[44:38.880 --> 44:40.880]  на которую надо ее изменить
[44:42.880 --> 44:44.880]  говорите, что aity равно
[44:44.880 --> 44:46.880]  val
[44:46.880 --> 44:48.880]  и код закончен в общем-то
[44:48.880 --> 44:50.880]  осталось update delta
[44:50.880 --> 44:52.880]  она будет написана на той доске
[44:56.880 --> 44:58.880]  что будет делать update delta
[44:58.880 --> 45:00.880]  она будет делать следующее
[45:02.880 --> 45:04.880]  for
[45:04.880 --> 45:06.880]  i
[45:06.880 --> 45:08.880]  меньше n
[45:08.880 --> 45:10.880]  i равно
[45:10.880 --> 45:12.880]  g большая от i
[45:14.880 --> 45:16.880]  и
[45:16.880 --> 45:18.880]  и
[45:18.880 --> 45:20.880]  3
[45:22.880 --> 45:24.880]  и ты
[45:26.880 --> 45:28.880]  плюс равно delta
[45:34.880 --> 45:36.880]  поймаю шок
[45:38.880 --> 45:40.880]  если что классно писан
[45:42.880 --> 45:44.880]  закончили
[45:48.880 --> 45:50.880]  гробовая тишина
[45:52.880 --> 45:54.880]  update delta
[45:54.880 --> 45:56.880]  смотрите
[45:56.880 --> 45:58.880]  что значит обновить сумму
[45:58.880 --> 46:00.880]  на подотрезке
[46:00.880 --> 46:02.880]  вы уберете эту сумму
[46:02.880 --> 46:04.880]  и прибавляете к ней разность
[46:04.880 --> 46:06.880]  между тем элементом, который был
[46:06.880 --> 46:08.880]  и который стал
[46:12.880 --> 46:14.880]  получается да
[46:14.880 --> 46:16.880]  храним массив i и храним массив 3
[46:18.880 --> 46:20.880]  и
[46:22.880 --> 46:24.880]  и
[46:24.880 --> 46:26.880]  и
[46:26.880 --> 46:28.880]  и
[46:30.880 --> 46:32.880]  и
[46:32.880 --> 46:34.880]  ты хочешь обновить дерево
[46:34.880 --> 46:36.880]  обновляй
[46:36.880 --> 46:38.880]  на такую delta
[46:38.880 --> 46:40.880]  и дальше скажи, что aity
[46:40.880 --> 46:42.880]  равно val
[46:42.880 --> 46:44.880]  а вот это мы сейчас еще обсудим
[46:46.880 --> 46:48.880]  это один из вариантов
[46:48.880 --> 46:50.880]  но мы посмотрим быстрее
[46:56.880 --> 46:58.880]  ой ну да
[46:58.880 --> 47:00.880]  да да да
[47:00.880 --> 47:02.880]  индекс да
[47:02.880 --> 47:04.880]  индекс да
[47:12.880 --> 47:14.880]  не в update delta, я здесь i принимаю
[47:14.880 --> 47:16.880]  я
[47:16.880 --> 47:18.880]  себя жить проще сделал
[47:22.880 --> 47:24.880]  да да да да
[47:24.880 --> 47:26.880]  а здесь
[47:26.880 --> 47:28.880]  все
[47:28.880 --> 47:30.880]  ну
[47:30.880 --> 47:32.880]  надо было просто int и
[47:32.880 --> 47:34.880]  оставить и все
[47:38.880 --> 47:40.880]  смотрите
[47:40.880 --> 47:42.880]  я написал там int и dx в аргументах
[47:42.880 --> 47:44.880]  а здесь int и
[47:44.880 --> 47:46.880]  а потом везде написал
[47:46.880 --> 47:48.880]  здесь и и там и
[47:48.880 --> 47:50.880]  мне сказали, что я максимально некорректен
[47:50.880 --> 47:52.880]  и вообще нарушаю все заповеди
[47:52.880 --> 47:54.880]  потому что у меня здесь были
[47:54.880 --> 47:56.880]  и здесь и
[47:56.880 --> 47:58.880]  и компилятор не скомпилировал в голове у зрителей
[47:58.880 --> 48:00.880]  вот поэтому пришлось и dx везде
[48:00.880 --> 48:02.880]  дописать, чтобы скомпилировалось
[48:02.880 --> 48:04.880]  наконец
[48:14.880 --> 48:16.880]  обратную функцию берете
[48:16.880 --> 48:18.880]  у нас была f попротива
[48:18.880 --> 48:20.880]  минус это обратная для плюса
[48:20.880 --> 48:22.880]  как будто бы
[48:26.880 --> 48:28.880]  бинго
[48:28.880 --> 48:30.880]  мы об этом говорили минут 40 назад
[48:32.880 --> 48:34.880]  с этим мы разобрались
[48:34.880 --> 48:36.880]  теперь время осознать почему это дерево
[48:36.880 --> 48:38.880]  да
[48:48.880 --> 48:50.880]  дельта
[48:50.880 --> 48:52.880]  переменная дельта
[48:52.880 --> 48:54.880]  ок
[48:54.880 --> 48:56.880]  смотрите
[48:56.880 --> 48:58.880]  честно не очень хочу вам раскрывать эту тайну
[48:58.880 --> 49:00.880]  это хорошо просто на экзамен
[49:00.880 --> 49:02.880]  в общем это дерево
[49:02.880 --> 49:04.880]  давайте рассмотрим массивы
[49:04.880 --> 49:06.880]  моментов
[49:14.880 --> 49:16.880]  давайте пока из восьми
[49:16.880 --> 49:18.880]  посмотрим что будет
[49:20.880 --> 49:22.880]  f от нуля чему равно?
[49:24.880 --> 49:26.880]  ноль
[49:30.880 --> 49:32.880]  f от единицы чему равно?
[49:32.880 --> 49:34.880]  ноль
[49:38.880 --> 49:40.880]  f от двойки чему равно?
[49:42.880 --> 49:44.880]  ноль
[49:56.880 --> 49:58.880]  f от тройки чему равно?
[49:58.880 --> 50:00.880]  ноль
[50:02.880 --> 50:04.880]  f от четырки
[50:04.880 --> 50:06.880]  это четверка
[50:08.880 --> 50:10.880]  f от пятерки
[50:12.880 --> 50:14.880]  четверка
[50:26.880 --> 50:28.880]  f от шестерки
[50:28.880 --> 50:30.880]  f от шестерки
[50:32.880 --> 50:34.880]  шесть
[50:36.880 --> 50:38.880]  f от семерки
[50:38.880 --> 50:40.880]  ноль
[50:46.880 --> 50:48.880]  то есть здесь длина
[50:48.880 --> 50:50.880]  два в нулевой
[50:50.880 --> 50:52.880]  два в первой
[50:52.880 --> 50:54.880]  два во второй, два в третий
[50:54.880 --> 50:56.880]  в третьей
[50:58.880 --> 51:00.880]  когда вы спрашиваете в семерке
[51:00.880 --> 51:02.880]  у вас ответ это вот такой отрезок
[51:04.880 --> 51:06.880]  и у вас есть деление пополам
[51:06.880 --> 51:08.880]  от тройки
[51:08.880 --> 51:10.880]  на этом под отрезке есть деление
[51:10.880 --> 51:12.880]  пополам
[51:12.880 --> 51:14.880]  и на этом под отрезке пополам есть
[51:14.880 --> 51:16.880]  вот этот
[51:16.880 --> 51:18.880]  это дерево отрезков
[51:18.880 --> 51:20.880]  без правого сына
[51:20.880 --> 51:22.880]  в каждом узле
[51:22.880 --> 51:29.880]  То есть если вы рассматриваете, будто бы, это узел и контролируем его под отрезок, то это будто бы у вас только левая часть дерева отрезков есть.
[51:30.880 --> 51:31.880]  Поэтому это дерево.
[51:36.880 --> 51:38.880]  Потому что это дерево отрезков без правого сына.
[51:39.880 --> 51:45.880]  Смотрите, у вас будто бы действительно есть везде деление пополам, как было в дереве отрезков.
[51:46.880 --> 51:50.880]  Дерево отрезков убрали огромной массив, делили его пополам и рекурсивно строили вашу структуру.
[51:51.880 --> 51:57.880]  Здесь же вы делите пополам, но рекурсивно строите будто бы только для левой половины.
[52:01.880 --> 52:04.880]  Это отрезочки от F от И до И.
[52:07.880 --> 52:10.880]  Это краски-отрезочки, которые три с И контролируют.
[52:10.880 --> 52:30.880]  Дерево отрезков у вас была структура такая, что есть один массив, есть две половинки, дальше, не знаю, как там дальше у счет древних русов идет, потом однушки, у вас их 8 штук.
[52:31.880 --> 52:32.880]  Вот это дерево отрезков.
[52:33.880 --> 52:37.880]  А теперь вы сделали все то же самое, только у всех узлов уничтожили правого сына.
[52:40.880 --> 52:50.880]  То есть у этого теперь нет правого сына, у этого нет правого сына, у этого нет правого сына, у этого вообще нет, потому что он правый сын этого, которого нет.
[52:53.880 --> 52:57.880]  Но этой информации достаточно, чтобы отвечать на запросах на префиксах.
[52:57.880 --> 53:11.880]  Ну смотри, я брал И, я считал F от И, а дальше брал и отрезочки рисовал.
[53:12.880 --> 53:19.880]  Вот отрезочек длины 1, 2 в 1 СО на 0 уровень, отрезочек длины 2, 2 в 1 СО на 2 уровень и так далее.
[53:20.880 --> 53:22.880]  Лучилось такое дерево холостное.
[53:26.880 --> 53:27.880]  Ручками.
[53:28.880 --> 53:31.880]  Ну в плане, ну есть два варианта построения, сейчас мы до этого доберемся.
[53:32.880 --> 53:33.880]  Огрессивно построение.
[53:39.880 --> 53:42.880]  Так, ну первый способ, он максимально наивный.
[53:44.880 --> 53:45.880]  Давайте, построение.
[53:45.880 --> 53:50.880]  А, ну да, я надеюсь понятно теперь, почему апдейты и запросы работают за O от log M.
[53:52.880 --> 53:55.880]  Ну да, потому что длина двуечной записи это логарифм.
[53:56.880 --> 53:58.880]  А теперь, построение.
[54:05.880 --> 54:06.880]  За O от log M.
[54:07.880 --> 54:08.880]  За O от log M.
[54:13.880 --> 54:14.880]  M раз апдейт.
[54:18.880 --> 54:19.880]  Легендарное построение.
[54:22.880 --> 54:24.880]  Второе, за O от M.
[54:29.880 --> 54:30.880]  Нейтрально.
[54:36.880 --> 54:45.880]  Мы же сговорились с вами на прошлой лекции, что, что они нейтральны, это такое странное требование, что можно просто создать костыль в виде опшенного, что если нет значения, пиши туда просто число.
[54:46.880 --> 54:48.880]  Ну все, поэтому мы как бы не требуем будто бы.
[54:55.880 --> 55:01.880]  Ну потому что чисто алгебраически иногда надо просто сказать и все, чтобы формально было все соблюдено.
[55:01.880 --> 55:06.880]  Мы договорились в прошлый раз, что не надо.
[55:07.880 --> 55:08.880]  За O от M.
[55:09.880 --> 55:11.880]  Строим массив префиксных сумм.
[55:22.880 --> 55:24.880]  Далее по определению.
[55:31.880 --> 55:32.880]  Все.
[55:32.880 --> 55:36.880]  Ну или же преф, и ты минус преф.
[55:44.880 --> 55:45.880]  Все.
[55:47.880 --> 55:49.880]  Это построение феновика за линию.
[55:52.880 --> 55:53.880]  Да.
[55:54.880 --> 55:55.880]  Да, это да.
[55:55.880 --> 55:56.880]  Окей.
[55:59.880 --> 56:05.880]  Окей, мы с вами обсудили, что у нас памяти в два раза меньше и во времени быстрее.
[56:06.880 --> 56:09.880]  В среднем два раза запросы будут делаться.
[56:10.880 --> 56:13.880]  Но мы с вами не обсудили главное, зачем мы это сидели.
[56:13.880 --> 56:15.880]  А именно такая классная вещь, как...
[56:20.880 --> 56:21.880]  Она будет вот так вот.
[56:23.880 --> 56:24.880]  Да.
[56:26.880 --> 56:27.880]  Да.
[56:28.880 --> 56:29.880]  Да.
[56:30.880 --> 56:31.880]  Да.
[56:32.880 --> 56:33.880]  Да.
[56:34.880 --> 56:35.880]  Да.
[56:36.880 --> 56:37.880]  Да.
[56:38.880 --> 56:39.880]  Да.
[56:40.880 --> 56:41.880]  Да.
[56:41.880 --> 56:42.880]  Да.
[56:44.880 --> 56:45.880]  Два-три-дерево.
[56:49.880 --> 56:50.880]  Что?
[56:51.880 --> 56:52.880]  Нет.
[56:53.880 --> 56:56.880]  Есть такое интересное утверждение, что K-мерное дерево феновика пишется в K плюс 1 строку.
[56:58.880 --> 56:59.880]  Вот.
[57:00.880 --> 57:01.880]  Мы сейчас поймем, что это значит.
[57:02.880 --> 57:06.880]  Ведем такую, что 3 с и 3...
[57:07.880 --> 57:08.880]  Или 3 у нас было 3, просто.
[57:11.880 --> 57:33.880]  по u f от i до i, по v f от j до j, а u ты в этой, тогда как считать сумму на подпрямоугольнике каком-то?
[57:33.880 --> 57:37.880]  Мы умеем считать сами сумму на префиксных прямоугольниках на самом деле.
[57:41.880 --> 57:49.880]  То есть мы с вами умеем спрашивать сумму от прямоугольников, в которых вот один угол включен вот так вот.
[57:49.880 --> 57:52.880]  То есть для каких мы умеем узнавать ответ?
[57:52.880 --> 58:00.880]  Да, формула включения и исключения называется.
[58:00.880 --> 58:06.880]  То есть вы умеете отвечать для префиксов аналогично. Как написать в двумерном случае?
[58:06.880 --> 58:21.880]  Делается следующее.
[58:21.880 --> 58:25.880]  Все, это апдейт.
[58:25.880 --> 58:33.880]  Я же сказал, камерное дерево Хенрика пишется в каплю с одну строчку.
[58:33.880 --> 58:38.880]  Каплю с одну, только если вы фигурные скобочки не ставите, пишете как олимпиадники,
[58:38.880 --> 58:44.880]  типа у вас будет фор без фигурных скобочек, фор, фор, фор и выражение.
[58:44.880 --> 58:58.880]  Здесь также фор j больше 0, j равно f от j минус 1, 3 и ты, j ты, конец.
[58:58.880 --> 59:06.880]  А теперь представьте, что такое двумерное дерево отрезков.
[59:06.880 --> 59:11.880]  Это дерево отрезков, деревьев отрезков.
[59:11.880 --> 59:14.880]  В прошлом году я пытался это объяснять, было очень плохо.
[59:14.880 --> 59:20.880]  В этом году мы не будем это пытаться делать.
[59:20.880 --> 59:29.880]  Единственная проблема в этом все, это то, что у вас здесь будет, все-таки префикс сам-то двумерный,
[59:29.880 --> 59:42.880]  поэтому давайте его обозначу как L1, R1, L2, R2, то есть первое измерение, второе измерение, лево-право, лево-право.
[59:42.880 --> 01:00:04.880]  Тогда анс у вас будет выражаться так, преф от R2, L2 минус преф от R1, L2 минус преф от...
[01:00:04.880 --> 01:00:23.880]  Что я делаю вообще? L2, R2, L1, R2, L2, R1 плюс преф от L1, R1.
[01:00:23.880 --> 01:00:34.880]  Да, это будет домашкой на ревью требования, написать шаблон новокомерного Фенрика.
[01:00:34.880 --> 01:00:42.880]  У вас же есть плюсы, шаблон уже прошли на плюсах, да? Это обман, я знаю, что прошли.
[01:00:42.880 --> 01:00:49.880]  Ладно, шучу, это не будет в требованиях, но будет классно, если кто-то все-таки напишет такую штуку.
[01:00:49.880 --> 01:00:59.880]  В контесте будет трехмерный Фенрик. Нет, надо будет написать просто трехмерного Фенрика.
[01:00:59.880 --> 01:01:05.880]  Ну да, действительно, надо еще две прибавить в каждое место.
[01:01:05.880 --> 01:01:10.880]  Самое сложное в трехмерном Фенрике это написать формулу включения-всключения, как я выяснил, по опыту.
[01:01:10.880 --> 01:01:16.880]  Ой, я вас обманул. Знаете, почему я вас обманул?
[01:01:16.880 --> 01:01:22.880]  Думаю, что у вас здесь минус один, должно быть.
[01:01:22.880 --> 01:01:25.880]  Вот, теперь верно.
[01:01:25.880 --> 01:01:27.880]  То есть какое здесь правило?
[01:01:27.880 --> 01:01:38.880]  Что вы берете самое большее, затем выписываете с минусом все те, у которых один из индексов становится на единичку меньше.
[01:01:38.880 --> 01:01:45.880]  То есть у вас было бы два-два, здесь у вас всего лишь один из индексов стал на единичку меньше, поэтому вы их с минусом выписываете.
[01:01:45.880 --> 01:01:48.880]  А здесь у вас изменилось два, поэтому с плюсом.
[01:01:48.880 --> 01:01:56.880]  Там, где единички теперь у вас стоят, там вы должны минус один везде делать, чтобы они были не включительны.
[01:01:56.880 --> 01:02:06.880]  Если вы это напишете, вот сюда вот, вместо этого.
[01:02:06.880 --> 01:02:12.880]  Здесь вот мы дописали фор новый, и там дописали фор второй. Все, это двумерный фенвик.
[01:02:12.880 --> 01:02:22.880]  Трехмерный фенвик это написать в два раза большую формулу здесь, написать еще по одному фору здесь и там, и победить.
[01:02:22.880 --> 01:02:32.880]  Окей, кто-то тебе вдруг захочет считать сумму на подматрицу.
[01:02:32.880 --> 01:02:37.880]  Камерное зачем, я не знаю. Вдруг тебе кто-то захочет сумму на подматрицах считать?
[01:02:37.880 --> 01:02:45.880]  Мы этим занимаемся всю лекцию.
[01:02:45.880 --> 01:02:50.880]  Это разрывный, конечно, вопрос.
[01:02:51.880 --> 01:03:01.880]  Ладно, давайте подумаем про сложность. Память, понятно, до памяти от mm у вас требуется, если здесь m, здесь m.
[01:03:01.880 --> 01:03:14.880]  Время работы, log m, log m.
[01:03:14.880 --> 01:03:28.880]  Так, кстати, вопрос со звездочкой, за сколько работает GetSum и XLSK мер на дерево фенвика, и все измерения равны m.
[01:03:28.880 --> 01:03:35.880]  Ну подумайте. Это такой вопрос такой хитрый, он сравнивается с подвохом.
[01:03:35.880 --> 01:03:43.880]  Ладно, про дерево фенвика закончили. Поехали последнее, можно сделать.
[01:03:52.880 --> 01:03:55.880]  Последняя структура это декартово дерево по неявному ключу.
[01:03:55.880 --> 01:04:05.880]  Дерево по неявному ключу.
[01:04:11.880 --> 01:04:14.880]  Идея следующая.
[01:04:14.880 --> 01:04:19.880]  Помните, у нас когда-то было давным-давно декартово дерево?
[01:04:19.880 --> 01:04:29.880]  И как мы сами выяснили, что если выписать в порядке обхода декартового дерева, то у вас по ключам будет отсортированный массив.
[01:04:29.880 --> 01:04:32.880]  Ну inorder обход, получается отсортированный массив.
[01:04:32.880 --> 01:04:34.880]  Идея следующая.
[01:04:34.880 --> 01:04:43.880]  Давайте хранить вместо ключей индексы от 0 до n-1.
[01:04:43.880 --> 01:04:58.880]  Храним вместо ключей индексы n-1.
[01:04:58.880 --> 01:05:03.880]  Будем хранить также элемент и приоритет.
[01:05:03.880 --> 01:05:15.880]  То есть надо будет хранить себе ключ в виде индекса, сам элемент аиты и приоритет для балансировки дерева.
[01:05:15.880 --> 01:05:18.880]  Что теперь давайте осознаем?
[01:05:18.880 --> 01:05:22.880]  Осознаем, что по сути мы получили с вами массив в форме дерева.
[01:05:22.880 --> 01:05:27.880]  Пока не понятно вообще, зачем нам это надо, но потихонечку мы к этому придем.
[01:05:27.880 --> 01:05:36.880]  Тогда вопрос, что такое сплит в таком массиве?
[01:05:36.880 --> 01:05:39.880]  Сплит у нас был раньше по ключу, да?
[01:05:39.880 --> 01:05:48.880]  Давайте теперь делать сплит по ключу, действительно, ind key.
[01:05:48.880 --> 01:05:51.880]  В смысле? Нет, сплит у вас делил дерево на два.
[01:05:51.880 --> 01:05:55.880]  В одном все ключи меньше, в другом все ключи больше.
[01:05:55.880 --> 01:05:59.880]  Теперь вы можете это...
[01:05:59.880 --> 01:06:03.880]  То есть будто бы вы умеете делать сплит по индексам, на самом деле.
[01:06:03.880 --> 01:06:07.880]  То есть вы говорите, у вас был массив, вы взяли и рассекли пополам,
[01:06:07.880 --> 01:06:11.880]  получили разделение массива где-то посредине за логарифом.
[01:06:11.880 --> 01:06:14.880]  Ну уже неплохо.
[01:06:14.880 --> 01:06:18.880]  Следующая идея. Что делал мерч?
[01:06:18.880 --> 01:06:21.880]  Ладно, пока что не будем про мерч.
[01:06:21.880 --> 01:06:23.880]  В чем проблема?
[01:06:23.880 --> 01:06:27.880]  Казалось бы, все круто, да? В чем проблема?
[01:06:27.880 --> 01:06:30.880]  Нет, не проблема, это потом спускаемся по дереву и побеждаем.
[01:06:30.880 --> 01:06:35.880]  Это вообще не проблема. Проблема в следующем, что...
[01:06:35.880 --> 01:06:41.880]  Если вы считали массив ваш, вот ваши ключи,
[01:06:41.880 --> 01:06:45.880]  то будто бы это два независимых массива теперь.
[01:06:45.880 --> 01:06:49.880]  Здесь были индексы 0, и...
[01:06:49.880 --> 01:06:53.880]  Ну ладно, здесь и-1.
[01:06:53.880 --> 01:06:57.880]  Давайте ключ К, К-1.
[01:06:57.880 --> 01:07:01.880]  То есть здесь у вас индексация будто бы хранится такая,
[01:07:01.880 --> 01:07:05.880]  а здесь у вас К, Н-1.
[01:07:05.880 --> 01:07:11.880]  Ну раз это два независимых массива, наверное я хочу здесь индексацию сделать.
[01:07:11.880 --> 01:07:15.880]  Согласны?
[01:07:15.880 --> 01:07:21.880]  Окей. Ну тогда же мне придется за линию пройтись по дереву и переписать индексы.
[01:07:24.880 --> 01:07:28.880]  Нет.
[01:07:28.880 --> 01:07:34.880]  Вспомним, как мы искали кату порядковую статистику.
[01:07:34.880 --> 01:07:37.880]  Мы смотрели, сколько элементов влево под дереве.
[01:07:37.880 --> 01:07:41.880]  Если меньше, то шли в него, если равно, то останавливались.
[01:07:41.880 --> 01:07:44.880]  Если больше, то шли вправо.
[01:07:44.880 --> 01:07:47.880]  То есть нам достаточно было размера левого под дерево.
[01:07:47.880 --> 01:07:50.880]  А катая порядка в этом массиве таком, это что?
[01:07:50.880 --> 01:07:53.880]  Это катый элемент массива.
[01:07:53.880 --> 01:07:57.880]  Ну тогда давайте хранить неявный ключ.
[01:07:57.880 --> 01:08:01.880]  Неявный ключ – это размер левого под дерево.
[01:08:09.880 --> 01:08:15.880]  Тогда с помощью него я могу четко получать элемент по индексу.
[01:08:15.880 --> 01:08:19.880]  Действовать будто бы это катая порядковая.
[01:08:19.880 --> 01:08:23.880]  А если я храню только это, то есть я не храню только это.
[01:08:24.880 --> 01:08:28.880]  А если я храню только это, то есть я не храню индекс теперь.
[01:08:28.880 --> 01:08:30.880]  Все, он мне не нужен.
[01:08:30.880 --> 01:08:34.880]  При необходимости я смогу восстановить индекс с помощью этой информации.
[01:08:34.880 --> 01:08:37.880]  То есть по индексу я смогу найти элемент.
[01:08:37.880 --> 01:08:41.880]  С помощью этой информации, не храня явно индексы вообще.
[01:08:41.880 --> 01:08:45.880]  Ну тогда если я не храню явно индексы, у меня нет этой явной индексации.
[01:08:45.880 --> 01:08:50.880]  И у меня эта проблема исчезает сама собой, что мне нужно здесь переиндексировать.
[01:08:50.880 --> 01:08:52.880]  Я вообще не храню индексы.
[01:08:52.880 --> 01:08:56.880]  Не вообще по барабану, что там происходит. Ребят, вы поймите это.
[01:08:58.880 --> 01:09:02.880]  Я просто знаю, что у меня в левом по дереве столько-то элементов. Все.
[01:09:02.880 --> 01:09:04.880]  Вообще все.
[01:09:04.880 --> 01:09:08.880]  Что там в правом цене происходит вообще не волнует.
[01:09:10.880 --> 01:09:12.880]  В каждом узле размер левого по дереву – все.
[01:09:12.880 --> 01:09:18.880]  Мы умеем четко понимать тогда, нужно ли нам, если я хочу этот элемент по индексу получить, идти ли мне влево или вправо.
[01:09:20.880 --> 01:09:26.880]  То есть смотрите, что я научился делать.
[01:09:26.880 --> 01:09:28.880]  Я научился с вами делать сплит.
[01:09:28.880 --> 01:09:30.880]  То есть разбивать массив на два.
[01:09:30.880 --> 01:09:32.880]  Дологарифум, не сбивая индексации.
[01:09:32.880 --> 01:09:34.880]  Просто потому что ее нет.
[01:09:40.880 --> 01:09:42.880]  Грустные ситуации.
[01:09:42.880 --> 01:09:46.880]  Этот И равносильно ИТ порядковое.
[01:09:46.880 --> 01:09:48.880]  Сплит.
[01:09:52.880 --> 01:09:54.880]  Разделение посередине.
[01:10:00.880 --> 01:10:02.880]  Теперь время мерджа.
[01:10:02.880 --> 01:10:04.880]  Что делал мердж? Как он работал?
[01:10:04.880 --> 01:10:06.880]  Вы ему подавали два дерева.
[01:10:06.880 --> 01:10:10.880]  В Т1 ключи были строго меньше, чем ключи в Т2.
[01:10:10.880 --> 01:10:12.880]  Помните такое?
[01:10:12.880 --> 01:10:14.880]  И дальше сравнивал только по приоритетам.
[01:10:14.880 --> 01:10:16.880]  Я ключа вообще никак не дозрадил в мерджу.
[01:10:16.880 --> 01:10:24.880]  Я делал, что если у меня приоритет корня левого дерева меньше, чем второго, то тогда этот корень будет корнем итогового дерева.
[01:10:24.880 --> 01:10:26.880]  И дальше мердж снова вызывал.
[01:10:26.880 --> 01:10:28.880]  Все, это все, что я делал.
[01:10:28.880 --> 01:10:30.880]  А теперь...
[01:10:30.880 --> 01:10:32.880]  Смотрите, у нас нет ключей.
[01:10:32.880 --> 01:10:34.880]  Мы код мерджа не меняем.
[01:10:36.880 --> 01:10:40.880]  Он как верил, что ключи были поданы ему в соотношении одни меньше второго,
[01:10:40.880 --> 01:10:42.880]  в соотношении одни меньше второго.
[01:10:42.880 --> 01:10:44.880]  Так и будет верить.
[01:10:44.880 --> 01:10:46.880]  Но у нас вообще нет ключей.
[01:10:46.880 --> 01:10:50.880]  Мердж смотрит только на приоритеты и все.
[01:10:50.880 --> 01:10:52.880]  То есть он берет два массива,
[01:10:54.880 --> 01:10:56.880]  А, Б,
[01:10:56.880 --> 01:11:00.880]  и превратит его вам в конкатинацию двух массивов.
[01:11:04.880 --> 01:11:08.880]  И будто бы, у нас действительно, будто бы здесь есть индексация какая-то,
[01:11:08.880 --> 01:11:10.880]  но ее здесь нет.
[01:11:10.880 --> 01:11:12.880]  И мердж работает.
[01:11:12.880 --> 01:11:14.880]  Здесь такая вот неявная идея,
[01:11:14.880 --> 01:11:16.880]  просто два дерева с мерджа без ключей
[01:11:16.880 --> 01:11:18.880]  превращают в конкатинацию массивов.
[01:11:28.880 --> 01:11:30.880]  Масивов.
[01:11:32.880 --> 01:11:36.880]  Вспомните, что мы с вами в дикартом дереве делали с помощью сприта и мерджа?
[01:11:36.880 --> 01:11:38.880]  Инсерт и рейс.
[01:11:38.880 --> 01:11:44.880]  То есть мы с вами научились взять и вставку в середину массива делать за логарифум,
[01:11:44.880 --> 01:11:46.880]  удаление из середины массива за логарифум.
[01:11:48.880 --> 01:11:50.880]  Пожертвовал в тока одной операции.
[01:11:50.880 --> 01:11:52.880]  Гет.
[01:11:54.880 --> 01:11:56.880]  То есть теперь у вас АИ, ты квадратные скобочки,
[01:11:56.880 --> 01:11:58.880]  за логарифм лишь работает, все.
[01:11:58.880 --> 01:12:00.880]  Но зато вы избавились от линейной вставки,
[01:12:00.880 --> 01:12:02.880]  линейного удаления,
[01:12:02.880 --> 01:12:04.880]  чего-то там еще.
[01:12:04.880 --> 01:12:06.880]  Нет никаких амортизированных оценок
[01:12:06.880 --> 01:12:08.880]  для вставки в конец.
[01:12:08.880 --> 01:12:10.880]  Все за логарифм.
[01:12:10.880 --> 01:12:12.880]  Жизнь прекрасна.
[01:12:12.880 --> 01:12:14.880]  Теперь pushback это просто
[01:12:14.880 --> 01:12:16.880]  сделать мердж с новым чуваком в конце.
[01:12:18.880 --> 01:12:20.880]  Popback это просто отсеки
[01:12:20.880 --> 01:12:22.880]  по размеру массива минус один.
[01:12:22.880 --> 01:12:24.880]  Вообще.
[01:12:24.880 --> 01:12:26.880]  Гениальная вещь.
[01:12:26.880 --> 01:12:28.880]  Получи по индексу это,
[01:12:28.880 --> 01:12:30.880]  верни и ту порядку в этом дереве.
[01:12:30.880 --> 01:12:32.880]  Конечно.
[01:12:32.880 --> 01:12:34.880]  Мы же хотим глубину поддерживать плюс-минус логарифм.
[01:12:34.880 --> 01:12:36.880]  Окей.
[01:12:40.880 --> 01:12:42.880]  Нет.
[01:12:42.880 --> 01:12:44.880]  Мердж как раз такой приоритет и смотрит.
[01:12:44.880 --> 01:12:46.880]  И по ним делает дерево.
[01:12:46.880 --> 01:12:48.880]  Нет.
[01:12:48.880 --> 01:12:50.880]  Это под ключи было.
[01:12:50.880 --> 01:12:52.880]  Мердж смотрит какой приоритет
[01:12:52.880 --> 01:12:54.880]  и, соответственно, то дерево,
[01:12:54.880 --> 01:12:56.880]  корень того дерева будет корнем итогового дерева.
[01:12:56.880 --> 01:12:58.880]  Все.
[01:12:58.880 --> 01:13:00.880]  Вообще.
[01:13:00.880 --> 01:13:02.880]  Нет. У нас нет ключа.
[01:13:02.880 --> 01:13:04.880]  У нас вместо ключа хранится неявный ключ.
[01:13:04.880 --> 01:13:06.880]  Размер левого под дерево. Все.
[01:13:06.880 --> 01:13:08.880]  Это информационным более чем достаточно.
[01:13:10.880 --> 01:13:12.880]  Нет.
[01:13:12.880 --> 01:13:14.880]  Вы ему даете индекс, по которому я хочу засплитить.
[01:13:14.880 --> 01:13:16.880]  Разбить на два.
[01:13:16.880 --> 01:13:18.880]  Вот у меня есть массив.
[01:13:18.880 --> 01:13:20.880]  1, 2, 3, 4, 5.
[01:13:20.880 --> 01:13:22.880]  Я говорю по сплит по третьему индексу.
[01:13:22.880 --> 01:13:24.880]  Он такой окей.
[01:13:24.880 --> 01:13:26.880]  Левый массив 1, 2, 3, правый массив 4, 5. Все.
[01:13:28.880 --> 01:13:30.880]  Хорошо. В массиве 6, 7, 8, 9, 10.
[01:13:30.880 --> 01:13:32.880]  Я говорю по тройке засплит.
[01:13:32.880 --> 01:13:34.880]  6, 7, 8 это одно.
[01:13:34.880 --> 01:13:36.880]  9, 10 это другое.
[01:13:36.880 --> 01:13:38.880]  Окей.
[01:13:40.880 --> 01:13:42.880]  Абсолютно так же.
[01:13:42.880 --> 01:13:44.880]  Только вы смотрите, правда ли, что
[01:13:44.880 --> 01:13:46.880]  в левом под дерево меньше к или больше к.
[01:13:46.880 --> 01:13:48.880]  Все.
[01:13:52.880 --> 01:13:54.880]  Это будет на семинаре вы напишете код подробнее.
[01:13:54.880 --> 01:13:56.880]  Зачем? Вам достаточно знать размер
[01:13:56.880 --> 01:13:58.880]  под дерево левого.
[01:13:58.880 --> 01:14:00.880]  Тогда вы будете понимать, нужно ли вам идти влево
[01:14:00.880 --> 01:14:02.880]  или вправо. Все.
[01:14:06.880 --> 01:14:08.880]  Каминус размер левого под дерево,
[01:14:08.880 --> 01:14:10.880]  если вправо пойдете.
[01:14:12.880 --> 01:14:14.880]  По размеру левого под дерево поймешь.
[01:14:18.880 --> 01:14:20.880]  Это как в кат и порядковый.
[01:14:20.880 --> 01:14:22.880]  Ты в кат и порядковый?
[01:14:22.880 --> 01:14:24.880]  Ты в кат и порядковый?
[01:14:24.880 --> 01:14:26.880]  Тебе вообще не важно, что происходит в правом под дереве.
[01:14:30.880 --> 01:14:32.880]  К передаешь.
[01:14:34.880 --> 01:14:36.880]  Число элементов, сколько у тебя
[01:14:36.880 --> 01:14:38.880]  будет в левом массиве.
[01:14:42.880 --> 01:14:44.880]  Хорошо. Окей. Что я еще умею делать?
[01:14:44.880 --> 01:14:46.880]  Ну, с помощью сплитов
[01:14:46.880 --> 01:14:48.880]  я умею посплитить
[01:14:48.880 --> 01:14:50.880]  и перенести тут сюда.
[01:14:50.880 --> 01:14:52.880]  То есть делать циклический сдвиг
[01:14:52.880 --> 01:14:54.880]  на к вообще могу.
[01:14:54.880 --> 01:14:56.880]  Просто так за логарифом.
[01:15:00.880 --> 01:15:02.880]  Давайте больше трюков.
[01:15:02.880 --> 01:15:04.880]  Так, у нас с вами 20 минут еще
[01:15:04.880 --> 01:15:06.880]  до конца перерыва.
[01:15:08.880 --> 01:15:10.880]  Подождите, мы еще не закончили магию.
[01:15:10.880 --> 01:15:12.880]  Мы только начали.
[01:15:14.880 --> 01:15:16.880]  Нет, это халява.
[01:15:16.880 --> 01:15:18.880]  Давайте вспомним,
[01:15:18.880 --> 01:15:20.880]  что дерево отрезков
[01:15:20.880 --> 01:15:22.880]  у нас хранило результат
[01:15:22.880 --> 01:15:24.880]  операции в под дерево.
[01:15:26.880 --> 01:15:28.880]  А здесь мы можем будто бы
[01:15:28.880 --> 01:15:30.880]  и мы там должны были хранить
[01:15:30.880 --> 01:15:32.880]  для запроса на подотрески
[01:15:32.880 --> 01:15:34.880]  индексы, в которых мы находимся.
[01:15:36.880 --> 01:15:38.880]  Тогда правда ли,
[01:15:38.880 --> 01:15:40.880]  что размера левого под дерево
[01:15:40.880 --> 01:15:42.880]  мне более чем достаточно,
[01:15:42.880 --> 01:15:44.880]  чтобы понимать, какие
[01:15:44.880 --> 01:15:46.880]  индексы у меня здесь, а какие здесь
[01:15:46.880 --> 01:15:48.880]  при рекурсивных вызовах?
[01:15:50.880 --> 01:15:52.880]  Тогда я же могу
[01:15:52.880 --> 01:15:54.880]  реализовать логику дерева отрезков.
[01:15:54.880 --> 01:15:56.880]  То есть для хранить результат
[01:15:56.880 --> 01:15:58.880]  операции на подотреске.
[01:15:58.880 --> 01:16:00.880]  То есть я получил быстрый массив, который
[01:16:00.880 --> 01:16:02.880]  умеет делать вставки в середину, удаления в середину.
[01:16:02.880 --> 01:16:04.880]  И он умеет теперь делать все то же самое,
[01:16:04.880 --> 01:16:06.880]  что умело делать
[01:16:06.880 --> 01:16:08.880]  дерево отрезков.
[01:16:08.880 --> 01:16:10.880]  То есть я умею
[01:16:10.880 --> 01:16:12.880]  брать операции,
[01:16:12.880 --> 01:16:14.880]  уровня, сделать
[01:16:14.880 --> 01:16:16.880]  циклический сдвиг нога, посчитать
[01:16:16.880 --> 01:16:18.880]  сумму на подотреске.
[01:16:22.880 --> 01:16:24.880]  Вот, это краски квинтэссенции
[01:16:24.880 --> 01:16:26.880]  того, что мы с вами делали
[01:16:26.880 --> 01:16:28.880]  половину семестра.
[01:16:28.880 --> 01:16:30.880]  Ну треть семестра, хорошо.
[01:16:30.880 --> 01:16:32.880]  Мы изучали вот эти вот структуры для работы
[01:16:32.880 --> 01:16:34.880]  на сотресками и изучали деревья поиска.
[01:16:34.880 --> 01:16:36.880]  Окей, зачем нужно было
[01:16:36.880 --> 01:16:38.880]  делать сплит дерева?
[01:16:38.880 --> 01:16:40.880]  Оно тоже умеет делать сплит мерш
[01:16:40.880 --> 01:16:42.880]  и тоже за логарифом.
[01:16:42.880 --> 01:16:44.880]  И, возможно, вам
[01:16:44.880 --> 01:16:46.880]  понравится более сплит дерева по неявному ключу,
[01:16:46.880 --> 01:16:48.880]  чем декартовое дерево по неявному ключу.
[01:16:48.880 --> 01:16:50.880]  Ведь, по сути, что мы хотим
[01:16:50.880 --> 01:16:52.880]  уметь делать? Мы лишь хотим
[01:16:52.880 --> 01:16:54.880]  уметь делать, чтобы наше дерево делало сплит и мерш.
[01:16:54.880 --> 01:16:56.880]  Это все, что требуется нам.
[01:16:56.880 --> 01:16:58.880]  Потому что мы с вами доказали, что через сплит и мерш
[01:16:58.880 --> 01:17:00.880]  можно выразить все остальные операции.
[01:17:02.880 --> 01:17:04.880]  То есть инсерт и рейс и так далее.
[01:17:04.880 --> 01:17:06.880]  И здесь, по сути, мы только ими и пользуемся.
[01:17:06.880 --> 01:17:08.880]  Так же сплит дерева,
[01:17:08.880 --> 01:17:10.880]  только через сплит вы можете вообще
[01:17:10.880 --> 01:17:12.880]  все это выразить.
[01:17:12.880 --> 01:17:14.880]  Это достаточно одной операции сплит,
[01:17:14.880 --> 01:17:16.880]  чтобы за логарифом делать кучу этих запросов.
[01:17:18.880 --> 01:17:20.880]  Просто подумайте, насколько это концептуально вообще.
[01:17:22.880 --> 01:17:24.880]  Окей.
[01:17:26.880 --> 01:17:28.880]  Ну, что можно здесь сказать на этом?
[01:17:30.880 --> 01:17:32.880]  Ну, на этом еще можно сказать следующее.
[01:17:34.880 --> 01:17:36.880]  Тут вот с первых рядов заявляли про переворот под отрезка.
[01:17:38.880 --> 01:17:40.880]  Разворот под отрезка.
[01:17:48.880 --> 01:17:50.880]  Я сказал, что мы можем реализовывать всю логику дерева отрезка,
[01:17:50.880 --> 01:17:52.880]  включая массовые операции, проталкивания и так далее.
[01:17:54.880 --> 01:17:56.880]  Для разворота под отрезка можно придумать
[01:17:56.880 --> 01:17:58.880]  проталкивания.
[01:18:00.880 --> 01:18:02.880]  Почему вы на меня так смотрите?
[01:18:02.880 --> 01:18:04.880]  Вот у вас есть отрезок.
[01:18:06.880 --> 01:18:08.880]  Вам сказали, я хочу этот под отрезок развернуть
[01:18:08.880 --> 01:18:10.880]  в цель по Р.
[01:18:10.880 --> 01:18:12.880]  Я знаю, что у меня в текущем узле
[01:18:12.880 --> 01:18:14.880]  он бьется на под отрезки
[01:18:14.880 --> 01:18:16.880]  LM и MR.
[01:18:18.880 --> 01:18:20.880]  Окей.
[01:18:20.880 --> 01:18:22.880]  Как тогда развернуть LR?
[01:18:26.880 --> 01:18:28.880]  LR.
[01:18:28.880 --> 01:18:30.880]  Шаг первый.
[01:18:32.880 --> 01:18:34.880]  Развернуть
[01:18:34.880 --> 01:18:36.880]  LM.
[01:18:36.880 --> 01:18:38.880]  Шаг второй.
[01:18:38.880 --> 01:18:40.880]  Развернуть
[01:18:42.880 --> 01:18:44.880]  MR.
[01:18:44.880 --> 01:18:46.880]  Шаг третий.
[01:18:46.880 --> 01:18:48.880]  Поменять
[01:18:48.880 --> 01:18:50.880]  детей местами.
[01:18:54.880 --> 01:18:56.880]  Все.
[01:18:58.880 --> 01:19:00.880]  Я теперь
[01:19:00.880 --> 01:19:02.880]  проталкиваю флаг.
[01:19:02.880 --> 01:19:04.880]  Операция push состоит
[01:19:04.880 --> 01:19:06.880]  из проталкивания флага.
[01:19:06.880 --> 01:19:08.880]  Через XOR равно,
[01:19:08.880 --> 01:19:10.880]  потому что у меня на бок уже стоит флаг,
[01:19:10.880 --> 01:19:12.880]  что нужно развернуть под отрезок.
[01:19:12.880 --> 01:19:14.880]  И дальше просто свапнуть детей местами
[01:19:14.880 --> 01:19:16.880]  в конце push.
[01:19:16.880 --> 01:19:18.880]  Я с вами научился за логарифом переворачивать под отрезок.
[01:19:20.880 --> 01:19:22.880]  А теперь тогда несложно понять,
[01:19:22.880 --> 01:19:24.880]  как делать операцию
[01:19:24.880 --> 01:19:26.880]  next permutation на под отрезке.
[01:19:26.880 --> 01:19:28.880]  То есть построить следующую дексографическую
[01:19:28.880 --> 01:19:30.880]  перестановку на под отрезке.
[01:19:30.880 --> 01:19:32.880]  С помощью этих двух операций,
[01:19:32.880 --> 01:19:34.880]  с помощью циклического сдвига на K,
[01:19:34.880 --> 01:19:36.880]  с помощью разворота на под отрезке,
[01:19:36.880 --> 01:19:38.880]  ее можно организовать.
[01:19:38.880 --> 01:19:40.880]  Но это у вас звездочка в терках.
[01:19:40.880 --> 01:19:42.880]  Это вот вершина
[01:19:42.880 --> 01:19:44.880]  вообще всего всей этой науки.
[01:19:46.880 --> 01:19:48.880]  Вот. Такая вот классная идея.
[01:19:48.880 --> 01:19:50.880]  И мы закончили на этом лекцию.
