[00:00.000 --> 00:14.320]  сегодня мы наконец-то поговорим про дизайн, про чем мы уже упоминали многие вещи, такие дизайн
[00:14.320 --> 00:22.920]  уровня скорее чем инструментария, но тем не менее сегодняшние темы считаются такой основой более
[00:22.920 --> 00:35.760]  менее дизайном шаблонов. первым пунктом программу будет следующий код, я думаю ни у кого шока не
[00:35.760 --> 00:45.240]  вызывает, в принципе это стд попе, только написанное руками. представим, что сейчас у нас стд нет, а также
[00:45.240 --> 00:52.760]  представим, что мы такие совсем глупые программисты синтаксис плюсов выучили, но стандартную библиотеку
[00:52.760 --> 01:00.680]  вообще не знаю. ну и вот мы как бы написали свой копия, который раньше итераторов от first до last
[01:00.680 --> 01:12.720]  вписывает в result и тут выяснилось, что на нашей платформе есть магическая операция bitblast или как
[01:12.720 --> 01:19.680]  хотите называйте memcopy, которая чиселки умеет копировать гораздо быстрее, чем вот так вот проходясь
[01:19.680 --> 01:26.760]  циклом. компилятор соответственно мы предполагаем, что глупый, сам не догадается, поэтому нам
[01:26.760 --> 01:35.200]  надо ему помочь. мы хотим заоптимизировать копии, чтобы если у нас тип лежащий в итераторе, типа
[01:35.200 --> 01:43.560]  int, чтобы у нас использовалась некая другая функция. ну и если мы все-таки совсем глупые программисты,
[01:43.560 --> 01:52.680]  то мы вот что-то такое напишем. если int будем использовать волшебный bitblast, иначе цикл как раньше.
[01:52.680 --> 02:01.720]  ну это можно также на специализациях сделать или перегрузках и прочие-прочие фентифлюшки. но
[02:01.720 --> 02:08.200]  поинт не в этом. поинт в том, что ну окей, для int это работает, но наверное был же это тоже как
[02:08.200 --> 02:14.880]  бы типа int. для него тоже наверняка нам нужно использовать эту операцию. и еще для многих типов.
[02:14.880 --> 02:22.200]  и если их вот так вот все выписывать здесь, то получается крайне некрасиво и неприятно.
[02:22.200 --> 02:29.560]  какие у вас есть идеи, как избавиться от этой проблемы, вот представляя, что стандартной библиотеки нет.
[02:31.720 --> 02:42.720]  вроде нам в какой-то момент придется зафиксировать набор типов, которые применимы super speed
[02:42.720 --> 02:51.480]  bitblast. поэтому нам все равно вот этот список, этот cms, как бы его не убрать идеально. то есть
[02:51.480 --> 02:57.000]  его можно как-то абстрагировать. да, это правильно, что его идеально не убрать. его не надо идеально
[02:57.000 --> 03:06.120]  выбирать. но нам нужно его абстрагировать, чтобы нам не приходилось сюда вот вписывать вот эти
[03:06.120 --> 03:17.560]  вот типы. сделать концепт там или констекс ворбул готовый там, супер спид и плайбл. и соответственно
[03:17.560 --> 03:27.960]  как мы будем кастомизировать тогда такую штуку? сделать специализацию копии для вот этого?
[03:27.960 --> 03:37.840]  да, ровно так. более олдовая вещь это сделать класс, внутри которого есть констекс ворбул,
[03:37.840 --> 03:46.120]  потому что раньше нельзя было специализировать переменные. но суть та же. и что мы по сути сделали?
[03:46.120 --> 03:57.040]  мы применили технику, которая решает 99 процентов программистских задач, добавление индирекции. то
[03:57.040 --> 04:03.880]  есть мы не напрямую получаем доступ к данным или какое-то решение принимаем, или действие совершаем,
[04:03.880 --> 04:12.960]  а через что-то. указатель можно считать индирекцией. вот эту штуку можно считать индирекцией. вот и такие
[04:12.960 --> 04:21.080]  индирекции, которые используются для принятия решений, основываясь на типах, их называют трейдами.
[04:21.080 --> 04:28.080]  соответственно код в итоге будет выглядеть вот так, а пользователь в свою очередь может для
[04:28.080 --> 04:35.640]  произвольного своего типа, если он уверен, что битбласт поддерживает этот тип, сделать специализацию.
[04:35.640 --> 04:42.960]  вот собственно так, как Александровский определяет, что такое type трейд, это дополнительный уровень
[04:42.960 --> 04:53.840]  индирекции, выносящий принятие решений из текущего контекста. ну как обычно у нас бывает,
[04:53.840 --> 05:03.840]  все эти определения плавающие, и что только в этом мире не называют трейдами. так что да,
[05:03.840 --> 05:11.360]  но тут возникает куча вопросов. вот мы приняли итераторы и решили битбластить, потому что под ними
[05:11.360 --> 05:17.480]  лежат менты. а последовательный или вообще контейнер, в котором они лежат? вдруг это мапчик,
[05:17.480 --> 05:26.960]  где хитрое красно-черное дерево, какой тогда битбласт? еще проблема. вдруг у нас разыменование
[05:26.960 --> 05:33.320]  итератора работает очень по-хитрому, оно не просто возвращает ссылку или указатель на тип,
[05:33.320 --> 05:44.800]  а какой-то врапер. даже в стандарте есть некоторые враперы над ссылками, которые иногда используются,
[05:44.800 --> 05:53.920]  ну и здесь тоже. вероятно, есть шанс, что итератор такой хитрый, что он возвращает прокси. а кто знает
[05:53.920 --> 06:04.360]  итераторы стандартной библиотеки, которые такие прокси возвращают? вектор bool. да, вектор bool. он вместо
[06:04.360 --> 06:10.840]  того, чтобы возвращать ссылку на bool, возвращает прокси, потому что внутри bool хранятся не как
[06:10.840 --> 06:20.280]  массив boolof, а как массив int, каждый битик, в котором обозначает bool. ну и какая может быть ссылка
[06:20.280 --> 06:25.840]  на один бит? ну такая проблема теоретически может быть, и вот код, который здесь у нас был,
[06:25.840 --> 06:35.200]  он сломается, конечно. мы разыменуем first, берем деколта, там будет какая-то прокси, что-то там. более
[06:35.200 --> 06:40.960]  того, вдруг у first-to-result разные типы внутри лежат, и мы как бы хотим, чтобы у нас неявное
[06:40.960 --> 06:47.000]  преобразование происходило. ладно, буду отметывать. в тот момент, когда мы делаем звездочку result,
[06:47.000 --> 06:55.880]  равнозначность .first, может быть преобразование. тоже проблема. более того, вот эти три проблемы,
[06:55.880 --> 07:05.160]  они еще понятны, совсем удочка так на будущее. вдруг у нас еще какие-то есть оптимайзы этого
[07:05.160 --> 07:11.840]  алгоритма, какие-то хитрые способы его сделать более быстро для других типов, для других
[07:11.840 --> 07:24.080]  других итераторов, для которых тоже придется добавлять новые ифы. ну первые три проблемы
[07:24.080 --> 07:31.360]  решаются легко, и стандартная библиотека для всего этого имеет соответствующие трейты. да,
[07:31.360 --> 07:39.840]  помимо трейтов для типов конкретных или для конкретных алгоритмов, бывают трейты для каких-то
[07:39.840 --> 07:46.320]  общих концепций. вот в стандартной библиотеке есть концепция итератора, и для них есть трейты.
[07:46.320 --> 07:52.520]  соответственно, у трейта итератора можно спросить последовательные ли это итераторы, то есть
[07:52.520 --> 07:57.560]  последовательные в памяти лежат объекты, на которые мы указываем. а также можно спросить,
[07:57.560 --> 08:06.760]  какой тип на самом деле лежит под этим итератором. ну и одинаковые ли значения, соответственно,
[08:06.760 --> 08:13.560]  через value-type можно узнать. вот, а про то, как справиться с новыми ифами, которые придется
[08:13.560 --> 08:23.120]  дописывать, это пока непонятно. ну тут может возникнуть идея, о чем нам эти трейты, мы же можем
[08:23.120 --> 08:29.360]  просто сказать, что пусть каждый итератор, он будет удовлетворять концепт. просто такой концепт есть,
[08:29.360 --> 08:37.720]  если что. концепт требует, чтобы у него был bool contiguous, чтобы мы могли прямо у типа
[08:37.720 --> 08:45.440]  спрашивать через статическую переменную в нем, и некоторые type-def или using на value-type. вот
[08:45.440 --> 08:53.000]  почему это нехорошо? в каком случае это сломается, и почему так не сделано в стандартной библиотеке?
[08:53.000 --> 09:07.160]  да, сырые указатели тоже считаются итераторами. ну и проблема на самом деле более общая, если у
[09:07.160 --> 09:16.160]  нас есть сторонняя библиотека, и мы хотим ее подружить с нашим кодом. вот с таким концептом мы
[09:16.160 --> 09:25.120]  никак не подружим эту библиотеку. нам придется модифицировать то, что... как бы придется
[09:25.120 --> 09:29.880]  модифицировать класс итератора, добавляя туда все, что мы потребовали в концепте. а вот трейты мы
[09:29.880 --> 09:34.720]  можем специализировать на конкретные итераторы. даже если итератор лежит в какой-то библиотеке,
[09:34.720 --> 09:42.880]  нам не доступны. это чем-то напоминает ситуацию с тыганволком с прошлой пары. да, здесь есть
[09:42.880 --> 09:49.520]  некоторая тонкая связь между тыганволком и трейтами, но я ее не смог прочувствовать. ну и
[09:49.520 --> 09:56.760]  конечно литературы никакой на эту тему нет. но что-то есть такое общее, видимо общие принципы
[09:56.760 --> 10:05.600]  дизайна, что хотим расширяемость, ну и прочие вещи, которые на ДП рассказывают на лекциях.
[10:05.600 --> 10:18.960]  вот, соответственно, да. трейты в стд, итератор трейты. справа, соответственно, две картинки,
[10:18.960 --> 10:27.720]  что вот есть класс итератора, структура с одним шаблонным параметром, где объявлена куча member
[10:27.720 --> 10:36.880]  типов. их там побольше, чем мы просто сказали value type. там дополнительно есть difference type,
[10:36.880 --> 10:48.360]  который говорит разность двух итераторов, чем она является. обычно это size t или какой-нибудь
[10:49.240 --> 11:03.560]  это патердифтэ скорее. но теоретически это может быть кастомизировано, если вдруг у нас
[11:03.560 --> 11:15.080]  итераторы на какие-то очень маленькие структурки, маленькие контейнеры, где не больше 255 элементов,
[11:15.080 --> 11:21.800]  наверное, там одним чариком можно обойтись. соответственно, стандарт позволяет заоптимизировать
[11:21.800 --> 11:28.400]  в этом месте, но я не встречал года, которые пользуются этой фичей. соответственно, есть и
[11:28.400 --> 11:36.680]  pointer и reference type. это как раз к вектору углов. скорее всего, референс для итератора по вектору
[11:36.680 --> 11:43.480]  углов говорит, что здесь референс это не просто ссылка, а вот этот хитрый врайпер. и
[11:43.480 --> 11:51.280]  есть итератор категории, который говорит, что в целом имеет итератор. ну, я думаю,
[11:51.280 --> 11:58.160]  все это вы уже видели когда-то давно, но с 20 стандартом все немного поменялось. теперь
[11:58.160 --> 12:08.520]  есть концепты вместо вот этих просто словесных описаний того, что такое forward итератор,
[12:08.520 --> 12:16.120]  что такое random access итератор. есть концептики, в которых прямо в коде описано, что это такое,
[12:16.120 --> 12:22.080]  какие требования предоставляются. то есть у нас есть и концепты, как я показывал только что,
[12:22.080 --> 12:31.720]  и трейты. они дружат вместе. если мы посмотрим на концепт input итератора снизу, то он определяется
[12:31.720 --> 12:40.560]  через input-output итератор. input-output совсем простая штука. говорят, что можно разыминовать,
[12:40.560 --> 12:47.600]  и говорят, что можно прибавлять. ну, не будем уже здесь отвлекли incrementable. понятно, что там
[12:47.600 --> 12:54.560]  какой-то итератор плюс-плюс. дальше в input итераторе, ну, indirectly readable какой-то,
[12:54.560 --> 13:00.840]  неважно-неважно, итератор концепт. здесь самое интересное. то есть это, заметьте,
[13:00.840 --> 13:07.200]  не какой-то типо, просто некоторая штука, которая затем описана словами. вот итератор концепт,
[13:07.200 --> 13:19.400]  это exposition only alias template. и дальше написано, как он получается. и тут вот сложные алгорели
[13:19.400 --> 13:30.720]  получается. иter-traits это либо и если нет специализации у iter-traits, то есть вот есть
[13:30.720 --> 13:35.880]  iter-traits с большими буквами, а есть iter-traits, который шаблоны стандарта, который можно
[13:35.880 --> 13:40.720]  специализировать пользователем. вот если пользователь его не специализировал, то в качестве
[13:40.720 --> 13:52.200]  iter-traits мы берем сам тип итератора, иначе вот этот iter-traits специализацию. дальше еще один
[13:52.200 --> 14:01.360]  слой индирекции. в этом iter-traits мы пытаемся взять тип итератор подчеркивания концепт и вот его
[14:01.360 --> 14:14.960]  использовать. дальше если есть итератор в категории, то как бы это используется. ну в общем,
[14:14.960 --> 14:21.720]  правила сложные, давайте не будем их переводить на русский на лету. но в итоге зачем они используются?
[14:21.720 --> 14:32.040]  проверяют, что iter-concept наследуется от input итератора. то есть идея в чем? по умолчанию
[14:32.040 --> 14:39.200]  итератор не будет считаться ни input, ни random access, ни каким другим из всех вот этих вот перечисленных.
[14:39.200 --> 14:47.400]  чтобы попасть в этот концепт, нужно самому сказать, да, я хочу, чтобы я удовлетворял этому концепту.
[14:48.280 --> 14:53.360]  и благодаря всем этим сложным правилам есть миллион способов, как подписаться на это.
[14:53.360 --> 15:00.280]  самый простой отнаследует наш класс от input иter-traitor tag. вот этот input иter-traitor tag,
[15:00.280 --> 15:07.240]  это пустая структурка, ничего в ней нет, ну как обычно теги и работают. просто помечает этот
[15:07.240 --> 15:17.720]  класс как input иter-traitor. можно в итератор trades, вот этот вот итератор tag поместить в итератор
[15:17.720 --> 15:28.920]  category. можно еще там хитрым образом указать. ну и все это нужно ровно за тем, чтобы любую библиотеку,
[15:28.920 --> 15:34.880]  какой бы она злой, плохой, не дружащейся стандартом не была, можно было вкрутить в этот механизм,
[15:34.880 --> 15:43.440]  в эти trades, указать все необходимые свойства для принятия решений в стандартных алгоритмах и
[15:43.440 --> 15:50.920]  использовать эти итераторы в стандартных алгоритмах. вот есть pointer trades, вот это уже изотерика
[15:50.920 --> 15:58.120]  пошла, это то, что обычно никто не знает и не использует. это trades для различных умных указателей,
[15:58.120 --> 16:08.160]  типа unicpointer, просто звездочки sharepointer. соответственно тут говорят, какой element type,
[16:08.160 --> 16:16.440]  какой difference type, а также есть шаблон, чтобы заребиндить этот умный указатель с одного типа
[16:16.440 --> 16:23.280]  на другой. ну почему это нужно? потому что у умных указателей бывает много шаблонных аргументов.
[16:23.280 --> 16:36.200]  у unicpointer какой второй шаблонный аргумент? делитер. хочется общий механизм, чтобы заменить то,
[16:36.200 --> 16:41.360]  на что указывает умный указатель. можно как-то это теоретически подкострелять,
[16:41.360 --> 16:47.920]  но вдруг там вторым шаблонным аргументом указывается тип, который надо использовать в какой-то
[16:47.920 --> 16:53.960]  билетике. ну вдруг. поэтому вот такой механизм предоставляется. если вам когда-то на первых
[16:53.960 --> 17:02.000]  курсах тосфистеха затирали про ребинд в локаторах, и было абсолютно непонятно, зачем он нужен. вот я
[17:02.000 --> 17:13.000]  пришел к выводу, что за тем же, хотя и не увидят. это штука жуткая. вот, ну ладно, chartrace, штука,
[17:13.000 --> 17:23.920]  которая говорит про разные типы букв или символов, какими свойствами они обладают. ну и вот
[17:23.920 --> 17:30.800]  эту штуку, кажется, в 23 стандарте будут перепиливать, потому что подъезжает поддержка utf-8. вот если вы
[17:30.800 --> 17:38.400]  когда-то пытались работать с кодировками в плюсах, вы узнаете какая-то боль со всеми этими v-chart-t,
[17:38.400 --> 17:48.560]  просто char, там есть еще всякие char32, разные кодировки туда-сюда, сложно, непонятно. ну и вот
[17:48.560 --> 17:54.320]  стандартные алгоритмы со строками работающие, они вот этот chartrace используют, чтобы некоторые вещи
[17:54.320 --> 18:02.600]  понять. но пока что многие вещи все еще плохо кастомизируются, так что есть-есть. ну и наконец
[18:02.600 --> 18:11.360]  локатор трейдс есть, но он совсем скучный. там примерно то же самое, что и в pointer-trade. но такие
[18:11.360 --> 18:21.840]  трейды вы можете встретить очень много где. мне кажется, в любой и хоть сколько-то крупной библиотеке
[18:21.840 --> 18:32.800]  плюсовые найдутся такие вот трейды. так вот, это тоже как бы трейды, это точки кастомизации для
[18:32.800 --> 18:43.960]  свойств тимошей в первую очередь. они хорошо дружат с концептами, вот никто не заставляет использовать
[18:43.960 --> 18:50.960]  либо одно либо другое, обычных вместе хорошо делать. но тут важно разграничать, что трейды все-таки не
[18:50.960 --> 18:58.720]  используются для того, чтобы определять поведение в зависимости от типа. вот у нас был тегенболк,
[18:58.720 --> 19:03.960]  который я надеюсь кто-то понял. вот он был про поведение, а здесь исключительно вот какие-то
[19:03.960 --> 19:16.400]  свойства. описать и принять решение на основании их в ваших алгоритмах. как-то так. вернемся к этому коду
[19:16.400 --> 19:31.040]  и что я хотел сказать? хотел сказать, кажется, про ифы новых. про то, что у нас может быть много
[19:31.040 --> 19:38.680]  разных ифов, хочется как-то это единообразно кастомизировать. да, вообще вся идея полиморфизма,
[19:38.680 --> 19:49.000]  она обычно начинается с того, что, а вот пусть у нас есть много разных классов или там, как лучше
[19:49.000 --> 19:54.600]  сказать, да, есть много разных типов и для них нужно разное поведение. мы можем наплодить много
[19:54.600 --> 20:00.920]  ифов, сделать switch или еще что-нибудь такое, но это будет не расширяемо, нам нужно модифицировать
[20:00.920 --> 20:08.920]  код неудобно. дальше говорят, вот виртуальные вызовы здорово, но у нас тут все статическое, так что
[20:08.920 --> 20:14.520]  тоже какое-то решение хочется. конечно, мы уже миллион видели, но вот они такие более техничные,
[20:14.520 --> 20:21.080]  если там какой-то статический полиморфизм просто прикрутить. хочется что-то более архитектурно
[20:21.080 --> 20:31.560]  общего, как такие проблемы решать. рассмотрим более сложный алгоритм, чтобы понять, насколько
[20:31.560 --> 20:46.720]  велика проблема. распределенная сортировка на нескольких потоках или еще чем-то таком. грубо
[20:46.720 --> 20:52.960]  говоря, параллельно сортируем по порядку некоторый набор значений, а дальше сразу начинается миллион
[20:52.960 --> 21:01.280]  вопросов, а вот какой набор значений, что это за контейнер, что значит параллельно, то есть на чем мы
[21:01.280 --> 21:10.000]  запускаем на трэдах, а мы их сами запускаем, новые создаем или чужие используем, а промежуточные
[21:10.000 --> 21:17.480]  результаты, которые нам неизбежно понадобятся, где их хранить, где память выделять, и хотя бы вообще
[21:17.480 --> 21:25.680]  что такое порядок на тех типах, которые нам дали. есть такой антагональный набор вопросов про то,
[21:25.680 --> 21:37.920]  как конкретно этот алгоритм должен работать, и хочется их кастомизировать, и вот инструмент,
[21:37.920 --> 21:42.160]  который мы будем использовать для этой кастомизации, он должен обладать некоторыми
[21:42.160 --> 21:48.080]  свойствами. во-первых, эта кастомизация должна быть открытой, чтобы пользователь мог прийти и
[21:48.080 --> 21:55.320]  свою новую кастомизацию дописать, не модифицируя наш код. во-вторых, должна быть артагональность
[21:55.320 --> 22:02.360]  этих измерений, по которым мы кастомизируем. не хочется, чтобы один контейнер работал с
[22:02.360 --> 22:08.200]  вот этими тремя экзекьюторами и только этим локатором, другой только с тем, да, хочется
[22:08.200 --> 22:15.000]  незаместимости, чтобы любое как угодно устанавливаешь, и все работало, и не приходилось думать, а можно ли
[22:15.000 --> 22:22.760]  эксплуировать это с этим. и наконец, хочется комбинаторного взрыва избежать, потому что теоретически мы
[22:22.760 --> 22:29.400]  можем взять и просто для всех комбинаций, которые потенциально нужны в коде, написать по отдельной
[22:29.400 --> 22:36.800]  специализации нашего алгоритма. но это жесть, да, как только добавляется новый локатор, количество
[22:36.800 --> 22:48.400]  специализации удовлетворится. мы так не хотим. да, но у нас же был для этого инструмент. из OP такой
[22:48.400 --> 23:13.320]  паттерн проектирования. кто догадается, о чем речь. это поведенческий паттерн. стратегия.
[23:13.320 --> 23:22.880]  да, вот как-то так она выглядит. мы в нашем контексте, то бишь в нашем алгоритме заводим
[23:22.880 --> 23:33.480]  указатели на стратегии, указывающие по интерфейсу, и стратегии соответственно относятся к одной
[23:33.480 --> 23:39.960]  кастомизации какой-то. то есть в предыдущем примере была бы стратегия запуска, стратегия
[23:39.960 --> 23:49.600]  локации, стратегия сравнивания и так далее. и этот интерфейс стратегии, он какой-то один, а может
[23:49.600 --> 23:55.800]  несколько методов предоставляет, и пользователь может наследовать интерфейс и уже конкретные
[23:55.800 --> 24:04.560]  реализации поставить. вот, простое понятное решение, на джеве все так пишут. но так как у нас
[24:04.560 --> 24:12.880]  метапробовый плюс C, мы не хотим runtime-полиморфизм, а он почти во всех случаях, да и не нужен толком,
[24:12.880 --> 24:21.840]  только замедляется зазря. мы хотим статический полиморфизм. соответственно, мы погнали заменять
[24:21.840 --> 24:33.760]  OP, наш облог. стратегия выполнения сальто, это будет концепт вместо интерфейса. мы требуем,
[24:33.760 --> 24:43.880]  чтобы у типа T, являющимся somersault strategy был метод статический somersault каких-то данных,
[24:43.880 --> 24:55.400]  а наш контекст или алгоритм принимает шаблонный параметр этой somersault strategy и в своем алгоритме
[24:55.400 --> 25:06.120]  используют этот шаблонный параметр. вроде, просто вроде понятно, но можно лучше, можно сделать вот так.
[25:06.120 --> 25:13.400]  казалось бы, мы ничего не поменяли, следите за руками. раньше мы просто strategy2.2.sommersault
[25:13.400 --> 25:23.160]  использовали и somersault был статическим. а теперь мы отнаследовались. а, я забыл исправить. теперь мы
[25:23.160 --> 25:28.640]  отнаследовались и просто запускаем somersault, который должен быть объявлен в родительской
[25:28.640 --> 25:38.720]  class strategy. он уже может быть на самом деле не статический. давайте это сделаем, чтобы
[25:38.720 --> 25:52.480]  чтобы не смущать. вот так вот имеется ввиду. и это нам на самом деле приятные плюшки привнесет,
[25:52.480 --> 26:00.560]  которые мы увидим чуть позже. и вот такие статические стратегии, их собственно называют
[26:00.560 --> 26:11.080]  policy. это вот тот самый policy based design, который уже неоднократно упоминался. надо перейти к более
[26:11.080 --> 26:19.040]  сложному примеру, зато такому кандому и традиционному, прямо из Александраевска. в качестве нашего
[26:19.240 --> 26:31.640]  будет некий widget manager. у него будет необходимость создавать виджеты. почему-то, не задаёмся вопрос
[26:31.640 --> 26:41.000]  не почему. соответственно, ему нужна стратегия создания виджетов. creation policy. но так как создавать
[26:41.000 --> 26:45.440]  виджеты, создавать какие-либо другие классы, это вроде как примерно одинаковые идеи,
[26:45.440 --> 26:57.840]  почему бы не сделать просто общие шаблоны. pop new creator, prototype creator. pop new просто в методе create
[26:57.840 --> 27:06.000]  вызывает оператор new. в Александраевску ещё указывается malloc creator, который с помощью malloc
[27:06.000 --> 27:11.920]  выделяет. а prototype creator, соответственно, хранит в себе какой-то прототип и вызывает у него метод
[27:11.920 --> 27:20.760]  clone. вполне адекватные стратегии или политики создания объектов. а пользователь в свою очередь,
[27:20.760 --> 27:30.000]  когда делает widget manager, выбирает, что он хочет, какую политику. и вот внизу пример pop new creator
[27:30.000 --> 27:38.240]  в policy было выбрано. почему может понадобиться прототип? тут легко привязывать. да, скажем,
[27:38.240 --> 27:45.960]  что у нас есть стиле виджетов. и вот виджет с дефолтным стилем — это прототип, клонируя
[27:45.960 --> 27:53.120]  который, стиль сохраняется. и соответственно, наш виджет менеджер, засунув prototype creator с
[27:53.120 --> 27:58.360]  этим конкретным прототипом, стилизованным, мы автоматом будем все виджеты получать стилизованными.
[27:58.360 --> 28:07.520]  здорово. а не здорово вот что. виджет менеджер уже знает, что он собирается эту стратегию или эту
[28:07.520 --> 28:13.920]  политику применять только к виджетам и создавать только виджеты. так почему же мы от пользователя
[28:13.920 --> 28:22.320]  требуем указывать вот этот класс виджет при инстанциации виджет менеджер? неудобно. но мы это
[28:22.320 --> 28:34.080]  конечно можем исправить. да, мы можем шаблонные аргументы использовать и вот это уже прям полностью
[28:34.080 --> 28:42.200]  политика по Александровскому. некоторый шаблонный шаблонный параметр, от которого мы наследуемся и
[28:42.200 --> 28:52.840]  который кастомизирует наше поведение. их может быть много. и даже наследоваться мы в принципе можем
[28:52.840 --> 29:00.000]  с несколькими, от нескольких инстанциаций, да, то есть creation policy и для виджета и для еще чего-то. но
[29:00.000 --> 29:07.160]  тут нужно быть осторожными с методами, которые внутри вот этой creation policy содержатся. они будут
[29:07.160 --> 29:13.600]  по имени конфликтовать. соответственно нам придется уточнять, какой метод create мы сейчас используем.
[29:13.600 --> 29:24.840]  ну, это деталь. ну, раз уж так сделали, возникает желание концепт написать, что есть некоторая creation
[29:24.840 --> 29:37.160]  policy. она там должна удовлетворять некоторым требованиям вроде иметь метод create. но загвоздка
[29:37.160 --> 29:45.840]  тут в двух вещах. первое это концепт на шаблон. то есть не на класс или тип, а на шаблон. template
[29:46.840 --> 29:55.320]  штука. соответственно, тот синтаксис, который здесь использовал, он на самом деле не работает. мы
[29:55.320 --> 30:02.680]  сталкиваемся с этим вроде. ну, так вышло. не включили пока. надеюсь, когда-нибудь включат. то есть
[30:02.680 --> 30:13.360]  в виджет менеджере сейчас нужно писать template++ creation policy от creation policy. в явные requires
[30:14.240 --> 30:32.000]  и вторая загвоздка вот в чем. а как мы в этом концепте проверим, что у t есть метод? это же шаблон. а у шаблона
[30:32.000 --> 30:41.880]  может быть много специализаций. что это вообще значит? проверить, что у шаблона есть метод.
[30:44.120 --> 30:54.080]  вот хотелось бы написать так, t, t, taste create, но t шаблон. это не тип.
[30:54.080 --> 31:02.480]  первое, что мне, когда я с этой проблемой столкнулся, к голове пришло, это использовать какой-то такой
[31:02.480 --> 31:11.760]  класс пустышку и через него проверять. но это ломается. это очень быстро ломается, потому что для того
[31:11.760 --> 31:19.600]  конкретного класса, который мы будем использовать в виджет менеджере, у конкретной политики может
[31:19.600 --> 31:27.480]  быть специализация. Более того, эта политика может работать только для классов,
[31:28.480 --> 31:40.760]  конкретному концепту, и этот концепт заранее мы узнать не сможем. До этого пока не дошли,
[31:40.760 --> 31:47.680]  но вот проблема, я думаю, ясна. Вроде как очень естественно сюда приклести концепты,
[31:47.680 --> 31:56.680]  но так просто не получается. Да, вернемся к прототипу.
[31:56.680 --> 32:07.280]  Прототип-крейтер должен в себе хранить объект какой-то, прототип. Откуда мы его возьмем?
[32:07.280 --> 32:13.240]  Вот когда метод create запускается у прототип-крейтера, откуда он взял этот прототип?
[32:13.240 --> 32:22.640]  Ну, я думаю, вы уже догадались, что секретов тащим-то тут нет. Просто в prototype-крейтере
[32:22.640 --> 32:30.800]  можно хранить указатель на этот самый прототип. А так как мы от политик наследуемся, нам ничто не
[32:30.800 --> 32:38.240]  мешает состояние хранить в этих политиках. Оно как бы подмешается в наш класс. А дальше
[32:38.240 --> 32:48.520]  политики могут объявить некоторые методы getPrototype, setPrototype, либо конструктор,
[32:48.520 --> 32:59.720]  что чуть более неудобно в каких-то ситуациях, но неважно. И когда мы инстанцируем widget-менеджер,
[32:59.720 --> 33:10.360]  эти функции getPrototype или даже create, на самом деле извне можно будет вызывать и кастомизировать.
[33:10.360 --> 33:22.400]  Да, но вот здесь сразу возникает желание навесить концепт, как обычно. У нашего класса T должен
[33:22.400 --> 33:29.520]  быть метод clone, возвращающий нам копию. Соответственно, нужно навесить концепт,
[33:29.520 --> 33:36.000]  что у T есть метод clone по-хорошему. Но тогда вот как раз сломается этот трюк с виднесом.
[33:36.000 --> 33:41.680]  Мы заранее не можем знать, какие концепты требует конкретная политика для того, чтобы ее можно было
[33:41.680 --> 33:49.000]  использовать. В общем, сплошные проблемы, поэтому единственное более-менее адекватное решение,
[33:49.000 --> 33:57.000]  как мне кажется, вот так выглядит. Добавить конкретный класс, с которым мы собираемся инстанцировать и
[33:57.000 --> 34:07.120]  проверять, что все нормально именно с этим классом. Если постараться, можно даже позволить проверку с
[34:07.120 --> 34:13.400]  несколькими классами. То есть целый пак принимать, и вот если мы хотим creation policy использовать не
[34:13.400 --> 34:19.680]  только для виджетов, а еще для чего-то, автоматом, концептом смотреть, что и виджеты нормально
[34:19.680 --> 34:27.800]  инстанцируются, есть метод create, какие-нибудь button-виджеты, еще-еще-еще.
[34:27.800 --> 34:41.360]  Да, давайте на этом моменте немного остановимся и посмотрим на время, ну более-менее пока.
[34:41.360 --> 34:50.240]  Нет ни у кого каких вопросов, пока что все понятно, отлично.
[34:50.240 --> 35:04.640]  Да, ну тут есть альтернативный подход, в каком-то смысле он менее удобный, в каком-то более, когда-как.
[35:04.640 --> 35:13.840]  Можно делать шаблоном не саму политику, а метод create. Ну и тут уж надо поработать со всем этим в
[35:13.840 --> 35:20.600]  конкретном кейсе, чтобы понять, подходит ли такой подход или лучше шаблоном весь класс делать.
[35:20.600 --> 35:28.080]  Если у нас несколько методов в политике, то наверное все-таки весь класс шаблонным более
[35:28.080 --> 35:41.960]  удобно, чем каждый метод отдельно шаблонизировать. Дальше есть такой тонкий момент, совсем тонкий
[35:41.960 --> 35:52.000]  момент, это уже вот совсем красоту навести. Код. Мы сделали конкретный виджет менеджер с конкретной
[35:52.000 --> 35:59.400]  политикой, создали и так вышло, что нам пришлось куда-то по ссылке или по указателю передать
[35:59.400 --> 36:07.760]  политику, которая содержалась в этом менеджере. Ну здесь тривиальный пример, да, просто взяли
[36:07.760 --> 36:16.400]  указатель в ЭМИС, кастили к криэйтору. Ну может быть более сложное что-то, где уже это не отловить,
[36:16.400 --> 36:26.840]  а потом удалили эту политику по указателю. И это полная фигня, вот вообще непонятно что.
[36:26.840 --> 36:35.960]  Конечно в адекватной ситуации, в адекватном ходе и в здравом уме никто такого делать не будет,
[36:35.960 --> 36:45.720]  слишком как-то завуалированно, но это можно запретить, обезопасив себя. Как это запретить?
[36:45.720 --> 36:52.720]  Перегрузить билеты к спрессу? Сейчас секундочку, вопрос еще.
[36:52.720 --> 37:17.840]  Ну как бы представим, что мы используем много-много ООП в своем коде, и увлекшийся ООП так вышло,
[37:17.840 --> 37:25.360]  что мы скастили виджет менеджер к прототайп криэйтору, звездочка, и забыли, что это вообще был виджет менеджер,
[37:25.360 --> 37:32.280]  ну как к интерфейсу, в ООП такое часто бывает. А потом, но это все попало в юнит ПТР или что-нибудь такое,
[37:32.280 --> 37:41.520]  и пыталось удалиться по указателю на родителя, на политику. Такое теоретически могло произойти,
[37:41.520 --> 37:51.360]  и конечно это УБ, почему? Потому что у нас не виртуальный деструктор, и мы не хотим сюда добавлять
[37:51.360 --> 37:57.360]  какие-то виртуальные деструкторы и динамические полиморфизмы. Вот, в этом проблема. Так, кто что в зуме говорил?
[37:57.360 --> 38:05.040]  Как это исправить? Я говорил про перегрузку оператора delete и поместить ее как deleted,
[38:05.040 --> 38:11.360]  но ты уже сказал, в случае при котором, видимо, это не работает. Я услышал про перегрузку оператора delete,
[38:11.760 --> 38:22.240]  нет, проще, пожалуйста. А второй вариант какой был? Плохо слышно? Андрей, какой второй вариант был?
[38:24.240 --> 38:32.320]  Я ничего второго не говорил, я просказал, так я, кажется, сломал мою идею. А, окей, да нет, все проще.
[38:34.800 --> 38:40.640]  Любые методы, они бывают публичные, приватные и защищенные. Что значит?
[38:41.360 --> 38:50.080]  Так, прошу прощения, надо вырубить эти обещания, а то надоело. Всем кресту на пжнстар.
[38:54.960 --> 39:03.760]  Так вот, что значит приватный, приватный метод в классе? Можно только из класса выпускать. Публичный
[39:04.080 --> 39:14.480]  можно отовсюду. А приватный? Ну, protected, да, protected. Да, из себя и из наследников,
[39:15.360 --> 39:23.120]  но это ровно то, что нам нужно. Если мы сделаем деструктор в политике protected, то вот такой код
[39:23.680 --> 39:31.280]  будет не комплинироваться, да, потому что мы не можем извне вызвать этот деструктор.
[39:31.280 --> 39:36.960]  Но при этом в самом widget manager все будет нормально, потому что в наследнике
[39:36.960 --> 39:45.280]  мы можем деструктор запустить, да. Но вот в приватном деструктор делать смысла нету. Такое
[39:45.280 --> 39:55.600]  бывает нужно очень-очень редко. Синдалтоны можно так делать, да, еще какие-нибудь совсем
[39:55.600 --> 40:03.200]  эзотерически извращенные вещи, но это все странно. А вот protected деструктор, это, мне кажется,
[40:03.200 --> 40:09.840]  идея очень здравая, когда мы не хотим, мы хотим обезопасить себя от того, чтобы какие-то наши
[40:09.840 --> 40:16.400]  шаблонные кусочки компоненты, которые отнаследованы публично, нельзя было к ним
[40:16.400 --> 40:22.400]  скастить случайно и куда-то унести. То есть, в принципе, везде, где мы такие трюки делаем с
[40:22.400 --> 40:34.360]  наследованием от чего-то и не хотим каститься, наследование обязано быть публично. Вот protected
[40:34.360 --> 40:46.800]  деструктор, мне кажется, хорошо бы дописывать. Да, здесь есть еще плюшка. Посмотрим на этот
[40:46.800 --> 41:06.880]  код. В WidgetManager добавили метод SwitchPrototype, который берет из CreationPolicy, тестает прототип из
[41:06.880 --> 41:15.800]  произвольной CreationPolicy. CreationPolicy шаблонный шаблон. Может быть, и не Prototype Creator,
[41:15.800 --> 41:23.120]  а PopNewCreator. Так вот, мы его достаем, то есть кастим себя к нему, удаляем старый прототип и
[41:23.120 --> 41:33.320]  устанавливаем новый прототип. Ну, конечно, это код плохой, некрасиво, delete и new, надо Unique,
[41:33.320 --> 41:41.600]  но книга писалась давно, допустим. Почему это будет работать? В чем трюк?
[41:41.600 --> 41:50.800]  Почему, если мы подставим WidgetManager PopNewCreator, то все будет работать?
[41:50.800 --> 42:03.840]  Мы же всю вторую задачу этот факт исследовали. Шаблонные инстанциируются лениво. Те их члены,
[42:03.840 --> 42:11.200]  которые вы не попросите использовать в рамках конкретной инстанциации, не будут впилены в
[42:11.200 --> 42:18.360]  эту инстанциацию. Соответственно, если вы инстанцируете WidgetManager с PopNewCreator и не будете
[42:18.360 --> 42:25.240]  вызывать SwitchPrototype, то этот метод не будет туда вписан, в эту инстанциацию, и все будет работать.
[42:25.240 --> 42:33.240]  А если вы уже знаете, что у вас WidgetManager с прототипом сидит, работает, то да, вы можете этот SwitchPrototype
[42:33.240 --> 42:40.360]  спокойно вызвать и все скомпилировать. Таким образом, поведение WidgetManager можно очень круто
[42:40.360 --> 42:49.960]  расширять в зависимости от того, какие у вас политики. То есть в зависимости от конкретных политик
[42:49.960 --> 42:55.480]  можно добавлять новые функционалы. И, ну, в современных плюсах мы, конечно, можем дописать
[42:55.480 --> 43:02.520]  следующие Requires и явно выписать требования, чтобы политика была такой-то или даже удовлетворяла
[43:02.520 --> 43:14.760]  какому-то свойству. То есть расширяемости предела нет. Хочется решить следующую прикольную задачу.
[43:14.760 --> 43:26.520]  Сделать UniquePointer, но с политиками. Политики будет две. Первая это политика многопоточности. Что
[43:26.520 --> 43:34.920]  происходит, если вот конкретно эту одну переменную типа UniquePointer из нескольких потоков модифицируют?
[43:34.920 --> 43:43.160]  А также политика разыменования, которая будет говорить, что происходит при разыменовании этого
[43:43.160 --> 43:54.040]  указателя. Есть ли ассерт на то, что он не NullPtr? Полне полезная политика. В дебагсборке можно
[43:54.040 --> 44:00.520]  впилить ее и таким образом получить везде проверку, что у вас не NullPtr, а если NullPtr,
[44:00.520 --> 44:06.920]  получить ассерт со stacktrace и прочими пределами, вместо ошибки сегментации или чего-то такого.
[44:06.920 --> 44:14.680]  Вот, это хочется покодить, но для начала, я думаю, стоит сделать перерыв, чтобы у вас немножко переварилось.
[44:14.680 --> 44:23.360]  Итак, мы остановились на том, что хотим написать UniquePointer. У него должна быть
[44:23.360 --> 44:31.400]  политика, кастомизирующая многопоточность и политика, кастомизирующая безопасность или опасность
[44:31.400 --> 44:43.000]  разыменования. И дальше мы немного подумаем о кастах. Соответственно, давайте сделаем
[44:43.000 --> 44:47.000]  CodeShare. Я надеюсь, кто-нибудь сейчас покодит.
[45:14.000 --> 45:25.000]  Итак, давайте, я знаю, кто-нибудь точно хочет написать код. На всяких паблик правил мы сейчас забьем.
[45:25.000 --> 45:39.000]  Ну, нам единственное, что интересно, это политики. Кто готов написать?
[45:39.000 --> 45:53.000]  Ну, я сейчас попробую, если у меня не начнет скачиваться.
[45:53.000 --> 45:58.000]  Ну, пока мы впишем очевидные вещи.
[46:09.000 --> 46:11.000]  Так сделаем.
[46:39.000 --> 46:50.000]  А, ну да. Тут, конечно, мало всего написать.
[46:50.000 --> 47:08.000]  Ну что, у кого-нибудь скачалось, подключилось?
[47:20.000 --> 47:48.000]  Никто не присоединился, кто-нибудь?
[47:48.000 --> 48:01.000]  Да, кинул я в чат в этом зуме. Если так сложно, могу вкинуть в телеграмму.
[48:01.000 --> 48:10.000]  Нет, ладно, не хочу открывать телеграмму. Там что-то понаписали.
[48:18.000 --> 48:46.000]  Ну что, ни у кого не хочет открываться?
[48:46.000 --> 49:12.000]  О, что я творю?
[49:12.000 --> 49:19.000]  Скелет есть. Надо добавить политики.
[49:19.000 --> 49:29.000]  Давайте даже все сократим. О, я опять не соблюдаю код-стайл.
[49:29.000 --> 49:36.000]  Как-то так. О чем будет первая политика многопоточности?
[49:36.000 --> 49:46.000]  Она будет о том, как хранится вот эта-то звездочка и о том, как с ней работать.
[49:46.000 --> 50:00.000]  А мы пока никак не работаем. Нам кажется, нужен оператор-звездочка.
[50:00.000 --> 50:11.000]  Да, ну оператор-стрелочка не будем делать.
[50:11.000 --> 50:19.000]  Так вот, здесь должно быть что-то.
[50:19.000 --> 50:24.000]  Узовем это мт-полис. Можете строить мт-полис.
[50:24.000 --> 50:28.000]  И вот в зависимости от этой мт-полис у нас что должно происходить?
[50:28.000 --> 50:37.000]  Просто указатель должен заменяться на одномик-указатель.
[50:37.000 --> 50:47.000]  Все операции присвоения и забирания на атомарной аналоге.
[50:47.000 --> 50:53.000]  Это первый вариант политики. Другой вариант политики это Mutex.
[50:53.000 --> 50:59.000]  Добавить. Ну, наверное, это не очень хорошо.
[50:59.000 --> 51:07.000]  Mutex не муваются, и у нас ничего не выйдет. Поэтому давайте через атомик.
[51:07.000 --> 51:17.000]  Как минимум один человек у нас уже присоединился. Андрей, давай. Дерзай.
[51:17.000 --> 51:22.000]  Еще раз, полиси многопоточности надо осознать.
[51:22.000 --> 51:26.000]  Еще раз, это полиси ухранения указателя?
[51:26.000 --> 51:29.000]  Да, ухранение и доступ к нему.
[51:29.000 --> 51:34.000]  То есть он хранится как обычный указатель и используются обычные операции доступа.
[51:34.000 --> 51:42.000]  Или он хранится как атомик и используется атомарная операция.
[51:42.000 --> 51:44.000]  Еще попробуем.
[51:52.000 --> 52:01.000]  Возможно, стоит начать с того, чтобы написать политику многопоточную, а потом подбить обычную политику.
[52:12.000 --> 52:22.000]  А ты хочешь с Mutex?
[52:22.000 --> 52:31.000]  Он, хотя ладно, да, вспоминая задачу скукса конкарнси, наверное, не стоит.
[52:31.000 --> 52:37.000]  Да нет, просто Mutex и не муваются. Мы, наверное, хотим отнаследоваться от этой политики.
[52:37.000 --> 52:43.000]  Я здесь написал класс, но, возможно, тебе шаблон будет удобнее.
[52:43.000 --> 52:47.000]  Ну и да, у нас тогда UniquePunter не будет муваться, что плохо.
[52:47.000 --> 52:51.000]  Да, это плохо.
[52:51.000 --> 52:59.000]  Поэтому я говорю, просто атомик, это уже будет окей опыт, понимание, как оно работает.
[53:07.000 --> 53:20.000]  Впрочем, атомики тоже не муваются, но мы все равно с этим справимся.
[53:20.000 --> 53:24.000]  Да и с Mutex тоже можно, на самом деле.
[53:24.000 --> 53:28.000]  Но у нас не на конкарнсе задача, так что давай как проще.
[53:28.000 --> 53:31.000]  Атомик, по-моему, проще.
[53:37.000 --> 53:46.000]  Только давай назовем это AtomicPunterPort.
[53:46.000 --> 53:53.000]  У нас появляется GetRef.
[53:53.000 --> 54:13.000]  Мы пока посмотрим, где GetRef будет.
[54:13.000 --> 54:19.000]  GetRef как минимум вот здесь.
[54:20.000 --> 54:24.000]  Возможно, еще здесь.
[54:24.000 --> 54:34.000]  Возможно, тут.
[54:34.000 --> 54:41.000]  Ну да, но...
[54:41.000 --> 54:48.000]  Ну, так можно.
[54:48.000 --> 54:58.000]  Но я бы сказал, что это не очень хорошая идея.
[54:58.000 --> 55:05.000]  На что стоит обратить внимание, если у нас...
[55:05.000 --> 55:08.000]  Блин, ну уже на конкарнсе получается задача, к сожалению.
[55:08.000 --> 55:12.000]  Но вы все конкарнсе проходили и все это знаете, так что нормально.
[55:12.000 --> 55:17.000]  Я надеюсь, если я хорошо сделаю свою работу.
[55:17.000 --> 55:22.000]  Когда у нас оператор присваивания происходит, нам что нужно сделать?
[55:22.000 --> 55:27.000]  Стащить у Адар его указатель.
[55:27.000 --> 55:34.000]  А там Адар.
[55:34.000 --> 55:36.000]  Это первое.
[55:36.000 --> 55:41.000]  А второе, это когда мы удаляем наш pointer.
[55:41.000 --> 55:46.000]  Вот нам нужно его не просто удалить, а как бы стащить и удалить.
[55:46.000 --> 55:52.000]  Потому что если мы загрузим, удалим, а потом поменяем, то между вот этими двумя операциями
[55:52.000 --> 55:57.000]  может кто-то втиснуться.
[55:57.000 --> 56:00.000]  Приемшем, так сказать.
[56:00.000 --> 56:02.000]  Ну и все сломается.
[56:02.000 --> 56:12.000]  Поэтому здесь тоже, на самом деле, хочется exchange.
[56:12.000 --> 56:17.000]  Чтобы мы разом атомарно заменили на новый pointer, загрузили, удалили.
[56:17.000 --> 56:22.000]  А потом вот это произошло.
[56:22.000 --> 56:33.000]  Конечно, все сломаться все равно может.
[56:33.000 --> 56:43.000]  Мне начинает казаться, что это плохая идея, писать это на атомике.
[56:43.000 --> 56:46.000]  Вконтакте никогда про спину не было?
[56:46.000 --> 56:49.000]  Никогда, да.
[56:49.000 --> 56:55.000]  Просто упражнение выбрать какой-то минимальный набор операций, которые мы хотим.
[56:55.000 --> 56:58.000]  И только их вынести в политику.
[56:58.000 --> 57:00.000]  Вот это огромное многообразие операций.
[57:00.000 --> 57:09.000]  Мне кажется, перебор.
[57:09.000 --> 57:15.000]  Ой, не так.
[57:15.000 --> 57:19.000]  Вот здесь тоже.
[57:19.000 --> 57:23.000]  Следовательно кажется, что фактически единственная операция,
[57:23.000 --> 57:28.000]  которая нам нужна, это exchange с нашим хранилищем.
[57:28.000 --> 57:50.000]  Ну, еще загрузка.
[57:50.000 --> 58:02.000]  Я не знаю, откроется ли у меня сейчас по контролю.
[58:02.000 --> 58:03.000]  Не открывается.
[58:03.000 --> 58:05.000]  Ну ладно.
[58:05.000 --> 58:08.000]  Пока Андрей пишет.
[58:08.000 --> 58:11.000]  Давайте.
[58:11.000 --> 58:29.000]  Оператор дилит.
[58:29.000 --> 58:52.000]  Где же оно?
[58:52.000 --> 58:56.000]  Нул пробел pointer.
[58:56.000 --> 59:05.000]  То есть, смотрите, поведение неопределено, если только не указатель это нул pointer или pointer,
[59:05.000 --> 59:14.000]  перед этим выделенный с помощью оператора new.
[59:14.000 --> 59:21.000]  Если pointer это no pointer, the allocation function do nothing.
[59:21.000 --> 59:24.000]  Да, можно не ставить лишние.
[59:24.000 --> 59:32.000]  За вас их уже поставили в библиотеку.
[59:32.000 --> 59:40.000]  Так, получается, функции такие.
[59:40.000 --> 59:45.000]  Вот этот using можно не писать, потому что у нас публичное наследование.
[59:45.000 --> 59:49.000]  Предоставлять пользователю эти операции мы не хотим.
[59:49.000 --> 01:00:05.000]  Вот этот using, он позволяет тем, кто использует наш уник ptr, получать доступ к вот этим вот функциям getptr, exchangeptr.
[01:00:05.000 --> 01:00:08.000]  А, тебе это нужно, чтобы вот так работали.
[01:00:08.000 --> 01:00:20.000]  Да, закономерно.
[01:00:20.000 --> 01:00:23.000]  Мне казалось, что оно должно работать и без этого.
[01:00:23.000 --> 01:00:26.000]  Ну ладно, если так, то всяко.
[01:00:26.000 --> 01:00:29.000]  А, ну конечно, оно не работает вот так. Мы же об этом говорили.
[01:00:29.000 --> 01:00:34.000]  Да, вопрос. Почему, если вот эту строчку убрать, оно не компилируется?
[01:00:34.000 --> 01:00:43.000]  Вот это мы делаем, и нам говорят, а я и не знаю, не могу найти.
[01:00:43.000 --> 01:00:49.000]  Как бы все связано.
[01:00:49.000 --> 01:00:54.000]  Вот это гадость.
[01:00:54.000 --> 01:00:58.000]  Это dependent base.
[01:00:58.000 --> 01:01:03.000]  А вот это не dependent expression.
[01:01:03.000 --> 01:01:15.000]  Поэтому при двухвазном локапе у нас при парсинге шаблона пытается найти имя для вот этого exchangeptr.
[01:01:15.000 --> 01:01:20.000]  И не находит. Потому что в dependent base ходить нельзя.
[01:01:20.000 --> 01:01:28.000]  А вот если мы эту штуку тоже сделаем dependent, то она должна работать.
[01:01:28.000 --> 01:01:34.000]  Ну что значит нет? Ну в смысле?
[01:01:34.000 --> 01:01:37.000]  Вот, все нормально.
[01:01:37.000 --> 01:01:42.000]  Вот, соответственно, мы можем сделать вот так и не делать этот using.
[01:01:42.000 --> 01:01:45.000]  А можем не делать.
[01:01:45.000 --> 01:01:51.000]  И соответственно, здесь можно сделать вот так.
[01:01:51.000 --> 01:01:57.000]  Вот. Внезапно понимание двухвазного локапа все-таки в жизни бывает нужно.
[01:01:57.000 --> 01:02:05.000]  Вот. Ну как-то так. То есть интерфейс политики получился минимальный.
[01:02:05.000 --> 01:02:09.000]  Тут ничего сложного.
[01:02:09.000 --> 01:02:25.000]  Я не скажу, что вот так нужно писать uniqueptr, потому что вот здесь мы получим взрыв, если у нас конкурируют два присвоения лабешета.
[01:02:25.000 --> 01:02:31.000]  Проблема, в общем, сплошная.
[01:02:31.000 --> 01:02:35.000]  Вообще странно, что такое конкурируют два присвоения?
[01:02:35.000 --> 01:02:45.000]  Если у нас два присвоения конкурируют, то это можно дописать, чтобы оно работало.
[01:02:45.000 --> 01:02:53.000]  Даже более-менее локфри, но давайте не будем.
[01:02:53.000 --> 01:02:58.000]  Ну, смотри, два оператора присвоения запустились на разных потоках.
[01:02:58.000 --> 01:03:02.000]  Оба удалили. Только одному удалось. С этим все хорошо.
[01:03:02.000 --> 01:03:14.000]  А потом оба у двух других агеров забрали их pointer и попытались вшибнуть вот сюда.
[01:03:14.000 --> 01:03:17.000]  И как бы это...
[01:03:17.000 --> 01:03:22.000]  Все плохо. Да, еще вот здесь тоже нужно наш Exchange использовать.
[01:03:22.000 --> 01:03:35.000]  Как-то так.
[01:03:35.000 --> 01:03:44.000]  Ну, да.
[01:03:44.000 --> 01:03:49.000]  О, да нет, это можно добить.
[01:03:49.000 --> 01:04:01.000]  Кажется, вот так это будет работать.
[01:04:01.000 --> 01:04:08.000]  Даже вот так можно сделать. Написали локфри на коленке.
[01:04:08.000 --> 01:04:16.000]  То есть что вот эта строчка значит? Мы поменяли у другого на nullptr его указатель.
[01:04:16.000 --> 01:04:21.000]  И сейчас вот этот указатель, который у другого был, он у нас в воздухе находится.
[01:04:21.000 --> 01:04:27.000]  А дальше мы присваиваем его себе, а свой старый удаляем.
[01:04:27.000 --> 01:04:34.000]  И если две вот таких операции присвоения себе конкурируют, то та из них, что произошла позже,
[01:04:34.000 --> 01:04:40.000]  она удалит то, что та, которая раньше присвоила, и все будет чики-пуки.
[01:04:40.000 --> 01:04:55.000]  Ну, то есть ладно, это все concurrency, но point в том, что вот как-то так можно писать политики.
[01:04:55.000 --> 01:05:03.000]  Давайте даже чуть сократим код, чтобы было больше места на экране.
[01:05:10.000 --> 01:05:20.000]  Окей.
[01:05:20.000 --> 01:05:29.000]  Так, что?
[01:05:29.000 --> 01:05:36.000]  Все хорошо. Следующая политика, которую мы хотим, это политика разыминования.
[01:05:36.000 --> 01:06:05.000]  А что это значит? Это значит, что вот здесь вот мы хотим делать вот так, делать некоторый check.
[01:06:05.000 --> 01:06:12.000]  А как check работает? Определяет вот это вот как раз политика.
[01:06:12.000 --> 01:06:22.000]  Что там может быть? Там может быть assert, там может быть исключение, там может быть свой кастомный классный пользовательский механизм assert.
[01:06:22.000 --> 01:06:26.000]  Такие, если вы не знали, есть почти в каждом проекте.
[01:06:26.000 --> 01:06:33.000]  Особенно во всяких игровых движках очень любят писать свои хитрые системы assertion,
[01:06:33.000 --> 01:06:41.000]  обмазанные репортами на сервер, сборкой дампов, прочим-прочим.
[01:06:41.000 --> 01:06:53.000]  Вот. Посмотрим, что Андрей напишет. Ну, кажется, тут очевидно, что написать.
[01:06:53.000 --> 01:06:59.000]  Если есть check, надо делать check.
[01:06:59.000 --> 01:07:06.000]  Заметим, что вот даже сейчас, когда мы вот этот check не реализовали, нам красным не подсвечивает слайд.
[01:07:06.000 --> 01:07:18.000]  Почему? Почему вот такую штуку он подсвечивал красным, а вот такую не подсвечивает?
[01:07:18.000 --> 01:07:24.000]  Ну, вернее, вот тут было без this, он подсвечивал красным, а вот здесь не подсвечивает.
[01:07:34.000 --> 01:07:43.000]  Да, что MyPTR? Зависимый. Да, MyPTR, он зависит от...
[01:07:43.000 --> 01:07:53.000]  Вот он определен как тип возвращаемый из стрелка GetPTR, его тип, скорее всего...
[01:07:53.000 --> 01:07:57.000]  А непонятно, какой на самом деле. В общем, зависимый, 100%.
[01:07:57.000 --> 01:08:03.000]  В таких случаях, мне кажется, двухфазный лукап тоже сдается, даже несмотря...
[01:08:03.000 --> 01:08:07.000]  Что там дальше в цепочке? Определение?
[01:08:20.000 --> 01:08:23.000]  Ну, что сеосерты мне нравятся?
[01:08:33.000 --> 01:08:52.000]  В ассертах нельзя писать сообщения, это же сишная ассерта.
[01:08:52.000 --> 01:09:00.000]  Вот, ну как-то так. Соответственно, вновь сократим код, чтобы было весь видно.
[01:09:00.000 --> 01:09:10.000]  На демонстрации мы можем сделать ExceptionInDirectionPolicy и сюда написать...
[01:09:10.000 --> 01:09:12.000]  Сив не ПТР.
[01:09:24.000 --> 01:09:26.000]  Как джайв?
[01:09:28.000 --> 01:09:37.000]  Класс. Да, Андрей, ты не слушал. Здесь можно не писать this, потому что MyPTR уже зависимый.
[01:09:38.000 --> 01:09:47.000]  Это вот здесь нам необходимо было написать this, потому что NoPTR независимое выражение, а значит и весь вызов функций независимых.
[01:09:47.000 --> 01:09:54.000]  Более того, вот здесь, мне кажется, this не обязательно писать. Да, Витя? Да.
[01:09:54.000 --> 01:10:04.000]  Потому что Adr зависимый. Его тип это injectedName класса, а injectedName зависимый.
[01:10:04.000 --> 01:10:12.000]  То есть этот стрелочка нужен фактически только вот здесь и вот здесь.
[01:10:14.000 --> 01:10:19.000]  Окей, а теперь внимание, вопрос.
[01:10:20.000 --> 01:10:27.000]  Если мы хотим написать... Вот самый важный point, собственно, сейчас идет.
[01:10:28.000 --> 01:10:36.000]  Если мы хотим написать... Давайте вот это скопируем.
[01:10:37.000 --> 01:10:39.000]  Сделаем вот так.
[01:10:40.000 --> 01:10:43.000]  Это уберем.
[01:10:45.000 --> 01:10:47.000]  Цифра два.
[01:10:52.000 --> 01:10:56.000]  UniquePointer от UniquePointer.
[01:10:56.000 --> 01:11:07.000]  AdrPolicy2, DirectionPolicy2.
[01:11:09.000 --> 01:11:11.000]  Вот так.
[01:11:11.000 --> 01:11:29.000]  Вопрос. Всегда ли этот каст должен срабатывать? Казалось бы.
[01:11:30.000 --> 01:11:34.000]  Наверное, нам хочется уметь кастить.
[01:11:35.000 --> 01:11:40.000]  Про MTPolicy это вопрос, конечно, отдельный, над которым надо подумать.
[01:11:40.000 --> 01:11:44.000]  Но с IndirectionPolicy нам бы точно хотелось его менять.
[01:11:44.000 --> 01:11:49.000]  Взяли и запихнули в другой pointer с другим IndirectionPolicy.
[01:11:51.000 --> 01:11:54.000]  Ну, оператор был, можно написать.
[01:11:54.000 --> 01:11:58.000]  Вопрос в следующем.
[01:11:58.000 --> 01:12:15.000]  Вот если мы кастим CheckedPointer к Unchecked, то есть тот, у которого мастер-то кидается,
[01:12:15.000 --> 01:12:18.000]  кастим, который unsafe.
[01:12:18.000 --> 01:12:21.000]  Это, наверное, всегда должен работать.
[01:12:21.000 --> 01:12:23.000]  Нам не важно.
[01:12:23.000 --> 01:12:29.000]  Но как бы обратная операция, она, возможно, работать не должна.
[01:12:31.000 --> 01:12:33.000]  То бишь, что это значит?
[01:12:35.000 --> 01:12:49.000]  Если у вот этого pointer-а политика unsafe, а у нас safe, мы такой каст хотим запретить.
[01:12:49.000 --> 01:12:52.000]  Предположим, это обозначено у бизнес-требования.
[01:12:52.000 --> 01:12:54.000]  Конечно, тут тоже можно рассуждать, хотим или не хотим.
[01:12:54.000 --> 01:12:56.000]  Вот хотим.
[01:12:56.000 --> 01:12:58.000]  Давайте придумаем, как это сделать.
[01:13:00.000 --> 01:13:03.000]  То есть еще раз запишем.
[01:13:13.000 --> 01:13:19.000]  Если IndirectionPolicy2 у нас unsafe,
[01:13:22.000 --> 01:13:30.000]  а IndirectionPolicySafe запретить.
[01:13:33.000 --> 01:13:35.000]  Как сделать?
[01:13:43.000 --> 01:13:45.000]  Тут есть простой вариант.
[01:13:46.000 --> 01:13:54.000]  Нет, мы вообще хотим запретить инстанциацию вот этого, вот этого.
[01:13:54.000 --> 01:14:04.000]  Чтобы казалось, что нет в текущей инстанциации UncheckedPointer с IndirectionPolicySafe
[01:14:04.000 --> 01:14:09.000]  вот такого оператора для IndirectionPolicy2 unsafe.
[01:14:09.000 --> 01:14:17.000]  Да, мы это можем сделать просто через реклапс в наших современных плюсах.
[01:14:22.000 --> 01:14:28.000]  Ну да, но в старых плюсах это делалось по-другому.
[01:14:29.000 --> 01:14:31.000]  Есть смешной трюк.
[01:14:36.000 --> 01:14:44.000]  Который как бы даже лучше будет работать, чем вот эти вот requires.
[01:14:44.000 --> 01:14:47.000]  Но почему опять requires плохо на самом деле?
[01:14:50.000 --> 01:14:54.000]  Ну тут можно написать длинное логическое выражение.
[01:14:54.000 --> 01:14:58.000]  Ну что, мне точно в CompileTime только будет работать.
[01:15:03.000 --> 01:15:07.000]  Мы хотим не в рентайме, мы хотим именно в CompileTime, как будто requires выпилили.
[01:15:07.000 --> 01:15:12.000]  Но вот если вот здесь руками вписать вот это сравнение, что это равно это, это равно это,
[01:15:12.000 --> 01:15:20.000]  это будет плохо, потому что пользователь как бы нашей библиотеки, он может свой...
[01:15:20.000 --> 01:15:22.000]  Трейты что ли?
[01:15:25.000 --> 01:15:28.000]  Можно трейты, а можно проще.
[01:15:28.000 --> 01:15:36.000]  Мы можем сказать, что собственно сами наши политики являются для себя трейтами.
[01:15:38.000 --> 01:15:43.000]  Вряд ли возникнет такая ситуация, что какая-то совсем сторонняя библиотека
[01:15:43.000 --> 01:15:48.000]  предоставляет политику, но при этом она не удовлетворяет каким-то дополнительным
[01:15:48.000 --> 01:15:52.000]  нашим требованием, например, иметь констэкспорт булл какой-то.
[01:15:56.000 --> 01:16:02.000]  То есть вот такие требования, что у каждой политики indirection должен быть булл
[01:16:02.000 --> 01:16:05.000]  или какой-то юзинг или еще что-то, это нормально.
[01:16:05.000 --> 01:16:08.000]  Мы и так уже требуем, чтобы были какие-то методы.
[01:16:08.000 --> 01:16:11.000]  И дополнительно накручивать трейты нужды нет.
[01:16:11.000 --> 01:16:16.000]  Это не даст нам дополнительной расширенности по сравнению с тем, что есть.
[01:16:16.000 --> 01:16:24.000]  Соответственно нам как-то нужно спросить эти политики indirection, умеют ли они каститься друг к другу.
[01:16:26.000 --> 01:16:28.000]  Давайте ровно так это и запишем.
[01:16:29.000 --> 01:16:30.000]  Мы скажем...
[01:16:30.000 --> 01:16:32.000]  Так, что мы еще раз таким?
[01:16:33.000 --> 01:16:37.000]  Мы хотим, чтобы unsafe кастился ко всем...
[01:16:37.000 --> 01:16:39.000]  Нет, наоборот.
[01:16:41.000 --> 01:16:44.000]  Чтобы все safe кастились к unsafe.
[01:16:44.000 --> 01:16:51.000]  То бишь, мы можем сделать оператор unsafe indirection policy.
[01:16:58.000 --> 01:17:03.000]  Причем хочется его, что ты рекомендуешь.
[01:17:04.000 --> 01:17:07.000]  А мы пометим explicit false.
[01:17:15.000 --> 01:17:17.000]  А, я оператор...
[01:17:24.000 --> 01:17:26.000]  Вот ClangD странно работает.
[01:17:26.000 --> 01:17:30.000]  Я явно написал explicit false, он все равно советует implicit.
[01:17:31.000 --> 01:17:33.000]  Ладно, так вот.
[01:17:33.000 --> 01:17:37.000]  Сделали так, чтобы assert кастился к unsafe.
[01:17:38.000 --> 01:17:40.000]  А теперь вот здесь...
[01:17:44.000 --> 01:17:46.000]  Вот в этом вот операторе.
[01:17:47.000 --> 01:17:49.000]  Можем написать следующее.
[01:18:04.000 --> 01:18:05.000]  Да?
[01:18:08.000 --> 01:18:10.000]  Кажется, вот так все-таки надо.
[01:18:11.000 --> 01:18:12.000]  Вот.
[01:18:13.000 --> 01:18:15.000]  То есть мы прям взяли из кастинга.
[01:18:16.000 --> 01:18:25.000]  Вернее, явно потребовали, чтобы наш indirection policy конструировался от indirection policy другого.
[01:18:27.000 --> 01:18:32.000]  Точно так же мы можем потребовать для mt-policy на самом деле.
[01:18:34.000 --> 01:18:36.000]  Коди, а зачем ты написал explicit false?
[01:18:37.000 --> 01:18:38.000]  Чего?
[01:18:39.000 --> 01:18:42.000]  А зачем ты написал explicit false к оператору?
[01:18:42.000 --> 01:18:46.000]  Кажется, оно вот в таком случае не сможет, если я напишу просто explicit.
[01:18:47.000 --> 01:18:48.000]  Возможно, сможет.
[01:18:48.000 --> 01:18:50.000]  Сейчас, погоди-ка.
[01:18:50.000 --> 01:18:52.000]  Запустим и потестим, так сказать.
[01:18:58.000 --> 01:19:00.000]  Да, это будет pointer на int.
[01:19:00.000 --> 01:19:06.000]  Это будет unsafe indirection policy.
[01:19:08.000 --> 01:19:21.000]  Что у тебя не так?
[01:19:31.000 --> 01:19:33.000]  Здесь все-таки explicit.
[01:19:34.000 --> 01:19:35.000]  Напишем.
[01:19:39.000 --> 01:19:40.000]  Таки почему?
[01:19:41.000 --> 01:19:42.000]  Все нормально.
[01:19:43.000 --> 01:19:45.000]  Странно, почему оно через равно не делается.
[01:19:45.000 --> 01:19:46.000]  Ну ладно.
[01:19:46.000 --> 01:19:47.000]  И сделаем...
[01:19:47.000 --> 01:19:49.000]  Вот ты конструктор explicit объявил.
[01:19:53.000 --> 01:19:54.000]  Я только сейчас это сделал.
[01:19:54.000 --> 01:19:55.000]  Ну ладно.
[01:19:56.000 --> 01:19:57.000]  Search.
[01:19:58.000 --> 01:20:03.000]  И попытаемся сконструировать P2 от std move P1.
[01:20:06.000 --> 01:20:07.000]  Скомпилируется ли это?
[01:20:08.000 --> 01:20:09.000]  Не скомпилируется.
[01:20:10.000 --> 01:20:12.000]  Вопрос скомпилируется ли наоборот?
[01:20:16.000 --> 01:20:17.000]  Вот так, а здесь…
[01:20:22.000 --> 01:20:23.000]  Тоже не скомпилируется.
[01:20:26.000 --> 01:20:30.000]  Рома, там был прикол, ты написал в пигурной искусстве?
[01:20:31.000 --> 01:20:32.000]  И что там?
[01:20:32.000 --> 01:20:41.240]  Рома, там прикол был, ты написал фигурные скобки, а так как это в полисе было агрегатом,
[01:20:41.240 --> 01:20:46.880]  то это он как агрегат в индициализации пытался сделать. В индициализации с плюс,
[01:20:46.880 --> 01:20:53.000]  мое любимое занятие. Я, если честно, всегда просто иду по порядку от фигурных круглым скобкам,
[01:20:53.000 --> 01:21:05.800]  и чем первая срабатывала, то использовала. Да, а что ему не нравится? Мне кажется,
[01:21:05.800 --> 01:21:10.200]  все-таки нам нужно убрать вот этот explicit. Да?
[01:21:10.200 --> 01:21:31.800]  Кажется, я фигню написал, да? Подожди, да, полную фигню написал. Здесь мы такую же мт-полисе
[01:21:31.800 --> 01:21:57.160]  просим. Полисе проблема. А, да, подожди, да, полисе последний идет. Я перестал,
[01:21:57.160 --> 01:22:14.080]  потому что interaction нужнее будет. Чуть из сада и долька.
[01:22:27.160 --> 01:22:37.280]  Ну, тут, конечно, большой вопрос, как это написать. Ну ладно, нас интересует не это.
[01:22:37.280 --> 01:22:53.600]  Чек валидите. Ага, я был неправ, оно не считается зависимо. Странно. Ну, мы, конечно, можем сделать так,
[01:22:53.600 --> 01:23:14.400]  чтобы оно считалось зависимо. Странно, странно, странно. Ну ладно. Окей, так компилируется.
[01:23:14.400 --> 01:23:21.680]  Пробуем наоборот. Там просто оно было зависимо в имени, оно зависело от параметра шаблона,
[01:23:21.840 --> 01:23:29.360]  а не от базы в каком-то виде. Наверное, поэтому, в общем, он не зависит от шаблонного класса или его базы,
[01:23:29.360 --> 01:23:43.400]  поэтому он сразу пытался его как-то сделать. Но это не точно. Ну вот, мы добились успеха.
[01:23:43.400 --> 01:23:57.320]  Погоди, кажется, там меня что-то сломал. Ты ничего не ломал, это я сейчас сломал в мейне,
[01:23:57.320 --> 01:24:04.040]  сейчас я пытаюсь скастить к ascertained direction, и оно не кастится. А если поставить наоборот и
[01:24:04.040 --> 01:24:13.600]  безопасно кастить к небезопасному, оно скастится. Ну и, конечно, мы можем пойти и сделать это не вот
[01:24:13.600 --> 01:24:25.240]  такими хаками теперь, как в старых добрых плюсах 98, ну и в один стор и вообще давно, а сделать
[01:24:25.240 --> 01:24:38.560]  вот такую фигню. Да, только нам придется это дописать где? Кажется, что вот здесь.
[01:24:38.560 --> 01:24:52.200]  Да, а на томик иникполисе все равно надо нецелизовывать.
[01:25:08.560 --> 01:25:35.880]  Так, все, теперь нету хаков.
[01:25:35.880 --> 01:26:03.120]  Все еще работает. Да, и нам написали, что неудовлетворен constraint. Соответственно,
[01:26:03.120 --> 01:26:11.280]  люди, которые пишут политики, какие-то новые свои, они могут вот так помечать их, что их можно
[01:26:11.280 --> 01:26:18.080]  кастить к той или другой политике, и таким образом можно обеспечить кастомизацию кастов,
[01:26:18.080 --> 01:26:27.920]  классов с разными хитрыми политиками. Так, окей, на этом упражнение заканчивается,
[01:26:27.920 --> 01:26:42.680]  я надеюсь, мы что-то полезное вынесли, и мы возвращаемся к презентации. Возвращаемся мы к
[01:26:42.680 --> 01:26:52.400]  ПБД в дикой природе. ПБД – сокращение policy based design, то есть дизайн-библиотека на основе
[01:26:52.400 --> 01:27:00.840]  политика. Одно из них, те из вас, кто в детстве увлекался олимпудками, должны знать вот это вот.
[01:27:00.840 --> 01:27:12.040]  Кому-нибудь говорит, да, вот такой хак, о котором очень немногие знали, он очень сильно помогает
[01:27:12.040 --> 01:27:20.880]  писать всякие код форсусы, олимпиады и прочее. Это такое расширение стандартной библиотеки плюсов
[01:27:20.880 --> 01:27:32.920]  от ГЦЦ, в котором есть куча разных деревьев и других крутых структур данных с очень сильной
[01:27:32.920 --> 01:27:41.320]  кастомизацией, то есть там красно-черный, сплайн деревьев и прочие. Оно все есть, и оно
[01:27:41.320 --> 01:27:50.200]  кастомизируется очень хорошо, как раз за счет политика. То есть давайте, так, наверное лучше я сделаю вот так.
[01:27:50.200 --> 01:28:07.680]  Вот, конфигурация стинг-контейнеров, то есть контейнеры в ПБДС параметризуются политиками.
[01:28:07.680 --> 01:28:17.040]  В принципе, в Эстейле тоже есть политики, например, локат, как и здесь, но тут их больше. Вот
[01:28:17.040 --> 01:28:29.640]  некоторая политика хэширования, некоторый предикат. Еще какая-то политика хэширования хэшей, видимо.
[01:28:31.640 --> 01:28:41.000]  Политика увеличения размера хэштаблицы. Я думаю, многие из вас слышали, что несмотря на то, что
[01:28:41.000 --> 01:28:50.960]  стандартные контейнеры обычно при заполнении наполовину удваивают свой размер. Ну, в смысле вектор,
[01:28:50.960 --> 01:28:59.600]  когда полностью заполнен, удваивает размер. Хэштаблица на какой-то половине берет и удваивает. Вот это вроде как
[01:28:59.600 --> 01:29:05.880]  не во всех случаях оптимально, и под разные задачи вот этот коэффициент, когда мы расширяем контейнеры,
[01:29:05.880 --> 01:29:11.080]  можно подкручивать, таким образом выжимать производительность. Вот здесь все это реализовываю.
[01:29:11.080 --> 01:29:18.280]  Соответственно, Traits, конечно, у них тут тоже есть стандартная библиотека все-таки.
[01:29:25.920 --> 01:29:34.840]  Да, стратегия политика сравнивания. И вот еще один интересный тип политик, это, собственно,
[01:29:34.840 --> 01:29:41.240]  просто пэй. Когда какая-то структура может быть реализована конечным числом способов,
[01:29:41.240 --> 01:29:49.680]  ну, там какая-нибудь стд-мап или стд-сайт, там вариантов не очень много. Красно-черное дерево,
[01:29:49.680 --> 01:29:59.800]  сплайн дерево, какой-нибудь овель, но так никто не пишет. Ты хотел сказать сплей? Сплей, да, сплей.
[01:29:59.800 --> 01:30:14.000]  В общем, да, их там по пальцам можно пересчитать, эти деревья, которые подходят под требования
[01:30:14.000 --> 01:30:21.760]  стандарта. Поэтому там просто есть тэг, которым выбирают, а какое дерево использовать. Если мы
[01:30:21.760 --> 01:30:34.600]  сейчас вверх поднимемся и посмотрим на деревянные структуры, то вот, собственно, тут тоже некоторые
[01:30:34.600 --> 01:30:44.680]  политики сравнения, и вот тэг. Тэги есть вот всего три, rb, splay и ov. Я не знаю, что это, кстати.
[01:30:44.680 --> 01:30:57.640]  Ордер 2. Да, дальше есть какие-то хитрые политики для поддержания вариантов дерева. Это вот какая-то
[01:30:57.640 --> 01:31:02.320]  дополнительная кастомизация, которую некоторые олимпиадные волшебники умеют использовать,
[01:31:02.320 --> 01:31:09.640]  но мне не сложилось, я не научился. Но, говорят, с помощью этих вещей можно просто в пух и прах
[01:31:09.640 --> 01:31:19.600]  рвать многие задачи. Я абсолютно не знаю алгоритмов. Там есть самая популярная политика, это порядковая
[01:31:19.600 --> 01:31:26.320]  статистика. Да, вот порядковую статистику, через вот эту вот штучку, ее можно сюда вставить и
[01:31:26.320 --> 01:31:31.560]  научиться легко считать порядковой статистики во многих деревьях. Собственно, они даже об этом
[01:31:31.560 --> 01:31:41.200]  здесь пишут, по-моему. Да, естественно, для порядковых статистик нужна некоторая методата в рамках
[01:31:41.200 --> 01:31:50.560]  вершинок и еще что-то там. Эту методату нужно обновлять как вариант поддержки. Вот они все это
[01:31:50.560 --> 01:31:57.720]  позволяют делать. Так что вот, как бы в ГЦЦ стандартная библиотека реализована через полисы
[01:31:57.720 --> 01:32:04.560]  из дизайна. Ну, собственно, локаторы во всех структурах стандартной библиотеки – это политики.
[01:32:04.560 --> 01:32:10.800]  А дальше есть смешная библиотечка, которую мне на Reddit посоветовали, и я просто в шоке от нее.
[01:32:10.800 --> 01:32:17.760]  Эта библиотечка содержит вообще все, что нам в этой жизни интересно. Там и динамические поливарфизмы,
[01:32:17.760 --> 01:32:26.680]  там руками написаны, там и трейты, там и политики, там еще куча всего интересного. Но сейчас только
[01:32:26.680 --> 01:32:32.880]  про политики. Вот эта библиотечка – она про систему эвентов. Здесь некоторые классы
[01:32:32.880 --> 01:32:41.080]  Эвент-диспатчера, им можно добавлять лиснеры на некоторые эвенты, а дальше говорить – произошел
[01:32:41.080 --> 01:32:49.800]  эвент с вот таким пейлоудом. И оно всех лиснеров оповестит, что вот эвент произошел, а ты его ждал.
[01:32:49.800 --> 01:33:02.120]  Но понт в том, что здесь миллион кастомизаций есть. В частности, вот этот эвент-диспатчер принимает
[01:33:02.120 --> 01:33:12.760]  на вход политики эвентов. И первое, что в этих политиках кастомизируется – это то, на основании
[01:33:12.760 --> 01:33:19.680]  чего идет диспетчеризация эвентов. То есть, как бы, эвенты – это произвольные титы здесь. Вот мы
[01:33:19.680 --> 01:33:28.600]  прям маэвент определили. И вопрос – как хранить эти эвенты? Как понимать, к какому лиснеру какой
[01:33:28.600 --> 01:33:37.520]  эвент прилетает? И в этой политике прописано, что есть некоторый Инт, с помощью которого
[01:33:37.520 --> 01:33:45.440]  идентифицируются и диспетчеризуются эти эвенты. И в данном случае он получается через E.type. Дальше
[01:33:45.440 --> 01:33:56.400]  лиснеры говорят, какой идентификатор они слушают, а в диспатче мы просто кладем
[01:33:56.400 --> 01:34:02.560]  эвент. И дальше сам механизм диспатчера по вот этому вот Инту.type через политику
[01:34:02.560 --> 01:34:14.400]  проходит и понимает, какие колбэки вызывать. Но там еще не все, конечно. Там политик очень много.
[01:34:14.400 --> 01:34:29.760]  Политика многопоточность есть. Давайте по порядку. Есть некоторая функция, которую в политике можно
[01:34:29.760 --> 01:34:38.360]  положить, которая контролирует, можно ли продолжать диспетчеризацию. Видимо, речь о том, что в списке
[01:34:38.360 --> 01:34:42.680]  колбэков можно остановиться на каком-то из них и сказать «все, дальше не иду», то есть как бы
[01:34:42.680 --> 01:34:55.000]  отменить события. Такие системы колбэков тоже бывают. Есть миксины, просто типы, которые используются
[01:34:55.000 --> 01:35:04.280]  для колбэков. По умолчанию STD-фанкшн можете кастомизировать. Политика трейдинга. Какой тип использовать как
[01:35:04.280 --> 01:35:12.440]  мютекс, какой тип использовать как атомик, какой как кондвар. Если вы хорошо помните курс конкарнси и
[01:35:12.440 --> 01:35:19.760]  помните, что есть такое понятие, как асинхронный мютекс для файберов, то становится понятно, зачем
[01:35:19.760 --> 01:35:27.520]  такая кастомизация нужна. Казалось бы, есть STD-мютекс, что еще нужно? Максимум спинлог. А вот как бы
[01:35:27.520 --> 01:35:34.880]  нет. Если у вас какая-нибудь система на крутинах, файберах или прочих интересных вещах, особенно
[01:35:34.880 --> 01:35:39.160]  праприетарных, то у вас, скорее всего, есть какой-то свой кастомный и синхронный мютекс, который сюда
[01:35:39.160 --> 01:35:49.120]  можно указать. Ну и своя кастомная и синхронная кондвар. Наверное, стоит на этом остановиться,
[01:35:49.360 --> 01:35:53.440]  потому что к этой штуке мы еще вернемся. Она уж очень-очень интересная и очень сладенькая.
[01:35:53.440 --> 01:36:01.440]  Еще одна библиотека, которую нашел некоторая библиотека для парсинга JSON.
[01:36:01.440 --> 01:36:26.240]  Вот здесь некоторые политики парсера. И вот опять эти checked and checked.
[01:36:26.240 --> 01:36:47.800]  Типа проверять валидный или JSON. Валидация JSON операция не быстрая. Если мы уверены,
[01:36:47.800 --> 01:36:53.520]  что у нас JSON нормальный, то есть если мы, например, какие-то конфиги к игре сделали,
[01:36:53.520 --> 01:37:01.560]  и при дебаге эти конфиги могут быть битые, кто-то их редачит, меняет, что-то делает,
[01:37:01.560 --> 01:37:07.040]  нам хочется чекать все-таки валидность, если что, кидать нормальную ошибку, а не крашиться. А вот
[01:37:07.040 --> 01:37:14.120]  как только мы игру доделали и все запекли, и эти конфиги вшили в экзешник, эти чеки можно отключить,
[01:37:14.120 --> 01:37:20.600]  все. Конфиги парсятся, все хорошо. Зачем тратить время на эти чеки? Берем, меняем политику,
[01:37:20.600 --> 01:37:33.840]  типа if-release, if-deaf-and-debug, политика такая, иначе сякая. Вот, соответственно, тут какие-то
[01:37:33.840 --> 01:37:41.120]  политики, пропуска, комментариев, еще что-то такое. В общем, это много где внезапно так
[01:37:41.120 --> 01:37:46.520]  смотришь, смотришь, и внезапно приходит в голову, что да, здесь можно сделать вот на этот
[01:37:46.520 --> 01:37:55.560]  вопрос политика, не просто костылять if-re, а структурировано сделать. Вот, ну давайте
[01:37:55.560 --> 01:38:03.120]  к последнему пункту программы, это уже вандерборд, а не Александреско теперь, или стоит перерыв
[01:38:03.120 --> 01:38:13.520]  сделать раз в час. Мне кажется, это хорошая идея. Пятиминутный перерыв, отдохнуть голосом и телом.
[01:38:18.680 --> 01:38:27.200]  Так, а вот так. Значит, да, тогда пять минут, семь десять, девятнадцать десять, возвращаемся.
[01:38:27.200 --> 01:38:37.360]  Значит, точка и полигон, который, ну, вектор точек, ну понятно. Ну, без контекста непонятно,
[01:38:37.360 --> 01:38:44.040]  к чему это все относится. Давайте считать, что мы пишем такое приложение для инженеров,
[01:38:44.040 --> 01:38:51.360]  которые эти точки рисуют, какие-то чертежи, графики, вот что-то вот такое из этого плана.
[01:38:51.360 --> 01:39:05.480]  Так проще замотивировать то, что дальше будет происходить. И как инженером нам может понадобиться
[01:39:05.480 --> 01:39:15.840]  расширять некоторым образом вот этот функционал точек. То есть, вероятно, хочется иметь возможность
[01:39:16.440 --> 01:39:25.840]  точкам добавить какие-нибудь метки или цвет, или еще что-нибудь такое. И вот сейчас вот эта пара
[01:39:25.840 --> 01:39:33.080]  классов, она вообще никак не расширяется. Кроме как саму точку внести новые поля, мы ничего не
[01:39:33.080 --> 01:39:39.200]  можем сделать. Отнаследоваться от точки, ну, отнаследовались и к чему. А вектор-то хранить
[01:39:39.200 --> 01:39:46.240]  поинты, а не наследников. И ООП использовать тоже невероятно, потому что чертеж может содержать
[01:39:46.240 --> 01:39:53.440]  миллионы этих точек со всеми этими indirection мы просто офигеем все это отрисовывать и хранить.
[01:39:53.440 --> 01:40:05.000]  Плохо. Конечно, шаблоды спасают. Шаблонизировали — отлично. Теперь мы можем отнаследоваться и
[01:40:05.000 --> 01:40:17.320]  добавить некоторые лейблы. Вот проблема. Тут опять нужно смотреть, что point пишем мы, а labeled point
[01:40:17.320 --> 01:40:24.600]  пишет какой-то пользователь нашей библиотеки. И вот если мы в point решим поменять конструкторы как-то.
[01:40:24.600 --> 01:40:30.920]  Ну, вот так вышло просто, что теперь конструктор не просто double off, но еще какого-то була,
[01:40:30.920 --> 01:40:37.440]  который определяет абсолютные координаты или относительные там курсоры или еще что-нибудь
[01:40:37.440 --> 01:40:48.400]  такого. Ну, мало ли чего может быть. Окей, добавили новый булл в конструктор point от двух даблов.
[01:40:48.400 --> 01:40:59.400]  Теперь нужно сходить в label point и обновить там конструктор. Если у нас более сложная система
[01:40:59.560 --> 01:41:05.120]  и таких расширений точек много, то это просто беда. Нам придется сходить по всей кодбазе
[01:41:05.120 --> 01:41:14.080]  и обновлять эти конструкторы. Неудобно. Надо как-то сделать, чтобы можно было добавлять какие-то
[01:41:14.080 --> 01:41:24.680]  новые данные и операции с ними, при этом не страдая, когда базовый класс поменяется,
[01:41:24.680 --> 01:41:33.320]  когда точка как-то изменится сама по себе. Как это можно сделать? Тут на мысли должно наткнуть
[01:41:33.320 --> 01:41:40.480]  следующее. Вот если у point мы конструктор меняем, то придется все менять. У родителя поменяли,
[01:41:40.480 --> 01:41:47.960]  в детях приходится менять. Вот если мы у ребенка поменяем конструктор, у родителя конструктора
[01:41:47.960 --> 01:41:57.040]  менять не надо. Родители ничего не знают про своих детей. Может как-то можно сделать,
[01:41:57.040 --> 01:42:08.800]  чтобы label point был родителем point, а не ребенком. Но ровно так мы и сделаем. Называется эта
[01:42:08.800 --> 01:42:17.520]  технология mixin. От слова подмешивать. То есть мы подмешиваем некоторые набор данных и функционала,
[01:42:17.520 --> 01:42:27.000]  вот last point compile time. Это могут быть лейблы, это могут быть цвета, еще что угодно. Их может быть
[01:42:27.000 --> 01:42:37.680]  сколько угодно. И пример mixin это вот просто label структурка ничего необычного. И после этого
[01:42:37.680 --> 01:42:50.600]  появляется публичное поле label. Техника вроде как очень простая, такая прикольная. Но вот где
[01:42:50.600 --> 01:42:58.760]  ее использовать? Этот вопрос конечно очень большой. Я бы не советовал ее тыкать не подумав 10 раз,
[01:42:58.760 --> 01:43:08.280]  даже не дважды, а 10 раз. В чем фундаментальное отличие от policy?
[01:43:08.280 --> 01:43:19.960]  Policy обычно это политика делания чего-то. То есть point в том, что тебе внутри класса нужно уметь
[01:43:19.960 --> 01:43:25.680]  делать что-то. Нужна какая-то стратегия или политика того, как это делать. Policy это вот про это.
[01:43:25.680 --> 01:43:33.200]  А mixin это просто про то, чтобы расширить функционал. Накидать еще полей, накидать еще методов.
[01:43:33.200 --> 01:43:40.640]  Вот только про это. Policy это про настройку какой-то generic вещи, а mixin это про внедрение
[01:43:40.640 --> 01:43:49.080]  абсолютно новой течи. То есть тут в принципе и trade, и policy, и mixin очень похожи, но нужно
[01:43:49.080 --> 01:43:57.240]  чувствовать вот эту тонкую грань, что трейты это в первую очередь про выбор, про свойство,
[01:43:57.240 --> 01:44:07.160]  описание. Policy это в первую очередь про то, как делать какое-то действие. Вот статически в
[01:44:07.160 --> 01:44:13.080]  compile-time кастомизировать то, как делается какое-то действие. А mixin это про произвольным
[01:44:13.080 --> 01:44:22.960]  образом расширить класс, но при этом не страдает проблем с наследованием. Потому что если у нас много
[01:44:22.960 --> 01:44:31.920]  измерений, по которым можно кастомизировать, label, цвет, форма, звездочки, точки или квадратика,
[01:44:31.920 --> 01:44:37.440]  это независимые измерения. Если мы будем наследование делать, то получим комбинаторный
[01:44:37.440 --> 01:44:45.280]  взрыв и умрем. Придется делать бриджи, выносить вот эти вот указатели, indirection, ну как на TP делали,
[01:44:45.280 --> 01:44:55.480]  медленно, неудобно. Шаблоны абсолютно бесплатно позволяют это сделать с mixin. И mixins бывают
[01:44:55.480 --> 01:45:04.560]  с rtp-шными, никто не мешает. Это позволит больше информации иметь в самом mixin о том, куда его
[01:45:04.560 --> 01:45:15.720]  подмешивают. Мало ли, что он хочет делать с этой информацией. Клоун был в каком-то смысле,
[01:45:15.720 --> 01:45:23.160]  ну, помните, мы писали для прототипа через с rtp штуку. Это тоже в каком-то смысле можно как mixin
[01:45:23.160 --> 01:45:31.080]  понимать, скорее всего. Наверное, ничто не мешает, если у нас произвольный класс, который умеет mixin
[01:45:31.080 --> 01:45:40.560]  делать, туда закинуть mixin прототипа. Да, но более подробных примеров не будет.
[01:45:40.560 --> 01:45:50.560]  Еще один трюк, который шокирует просто. Что можно сделать с mixin? Следите за руками.
[01:45:50.560 --> 01:46:02.020]  Base – некий класс с операцией foo. И у него есть mixins. Derived наследует base, и mixins просто
[01:46:02.020 --> 01:46:14.640]  прокидывают. И у него тоже есть foo. Теперь есть два mixins. Node-virtual ничего не делает. И mixin-virtual,
[01:46:14.640 --> 01:46:23.760]  который объявляет void foo как виртуальную функцию. И теперь в инстанциациях derived, в зависимости от того,
[01:46:23.760 --> 01:46:31.920]  какой mixin мы положили, virtual или non-virtual, функция foo будет либо виртуальной, либо не виртуальной.
[01:46:31.920 --> 01:46:41.600]  То есть такая conditional виртуальность. Как вот noexcept есть conditional, вот была. Explicit есть
[01:46:41.600 --> 01:46:49.720]  conditional. Вот virtual ключевого слова conditional нет, но мы его можем устроить таким образом. Я не
[01:46:49.720 --> 01:46:55.400]  уверен, насколько это полезно на практике, но тот факт, что так можно, это мне кажется очень здорово.
[01:46:55.400 --> 01:47:05.800]  Да, и, собственно, основным примером, где эти mixins юзаются и объюзятся, опять же, вот этот
[01:47:05.800 --> 01:47:14.400]  event-cpp. Это какая-то дикая библиотека, потому что я на нее наткнулся, и она покрывает весь материал
[01:47:14.400 --> 01:47:21.920]  сегодняшней лекции. Это прям очень здорово. Еще и предыдущие некоторые захватывают. Они здесь
[01:47:21.920 --> 01:47:28.880]  рассказывают следующее, что вот у нас есть event-dispatcher и есть event-dispatcher-base. И то и другое
[01:47:29.080 --> 01:47:40.280]  шаблоны. Там все обмазано этими шаблонами, политиками. Но пункт в том, что если мы откроем список того,
[01:47:40.280 --> 01:47:51.120]  что можно в политике засунуть, то тут, помимо всего, есть вот такая политика mixins. В отличие
[01:47:51.120 --> 01:47:56.560]  от нас, когда мы вот несколько разных политик делали разными классами, они все свои политики
[01:47:56.560 --> 01:48:03.880]  по разным вопросам засовывают в одну структурку или класс policies. И вот среди этих политик есть
[01:48:03.880 --> 01:48:13.680]  политика mixins. Mixins тоже как политику можно понимать. И это type list внезапно, тоже тема
[01:48:13.680 --> 01:48:34.600]  покрывается. Но type list необычный. Давайте, наверное, все-таки откроем. Вот, mixing list это необычный
[01:48:34.600 --> 01:48:44.160]  type list, а template list. То есть там хранятся не типа шаблоны. Mixins, CRTP-шные, это удобно.
[01:48:44.160 --> 01:48:53.760]  Но пункт даже не в том, что они CRTP-шные, эти mixins. Пункт в том, как они эти mixins подмешивают. Они
[01:48:53.760 --> 01:49:03.120]  их не коризонтально наследуют, то есть не event-dispatcher наследует все mixins. Это такая скатер-ерархия,
[01:49:03.120 --> 01:49:13.680]  которая у нас была, когда factory делали. Они делают линейную иерархию. Внимание, еще и тема генерации
[01:49:13.680 --> 01:49:21.720]  иерархии покрывается. Они используют то, что у mixins есть шаблонный параметр. Вернее, не так. Они
[01:49:21.720 --> 01:49:27.840]  требуют от mixins, чтобы он наследовался от своего шаблонного параметра. И за счет этого генерируют
[01:49:27.840 --> 01:49:34.200]  иерархию, где самый ребенок это event-dispatcher, его наследник это первый mixin, его наследник
[01:49:34.200 --> 01:49:45.280]  второй mixin и так далее до event-dispatcher-base. Вот так вот. Соответственно получается просто муть.
[01:49:45.280 --> 01:49:54.680]  Вот то, как должен mixin выглядеть. И в итоге это позволяет вообще все что угодно делать. Если
[01:49:54.680 --> 01:50:02.160]  в dispatcher-base есть некоторые виртуальные функции, в mixin мы их можем перегрузить. Если там какие-то
[01:50:02.160 --> 01:50:13.580]  невиртуальные штуки или какие-то поля даже, мы их можем зашедовать. Это просто магия. Правда,
[01:50:13.580 --> 01:50:21.560]  кажется, они здесь особо не приводят примеров адекватного использования mixins. Но зато...
[01:50:21.560 --> 01:50:27.560]  А, нет. Вот, mixin-фильтры есть некоторые. По-моему, это единственный mixin,
[01:50:27.560 --> 01:50:38.560]  который у них по умолчанию включен. Только я так не разобрался, что он делает, правда. Mixin-фильтр.
[01:50:38.560 --> 01:50:50.360]  Вот, у них есть еще некоторая возможность по цепочке mixin принимать какие-то решения
[01:50:50.360 --> 01:50:58.240]  при диспетчеризации. А также фильтровать ивенты и говорить, что вот этим колбэком они не подходят.
[01:50:58.240 --> 01:51:04.760]  То есть, насколько я понимаю, они позволяют вообще любую систему диспетчеризации рандаймовой
[01:51:04.760 --> 01:51:12.120]  сконфигурировать на шаблонах. Да, вот то, что мы раньше смотрели, там тупо понимали какой колбэк.
[01:51:12.120 --> 01:51:17.280]  Но вроде как тут можно вообще что угодно придумать. Любые фильтры, любой выбор. И
[01:51:17.280 --> 01:51:28.640]  почитать код этой библиотеки я рекомендую. Я начал, но все, дочитать не успел. Но то,
[01:51:28.640 --> 01:51:34.040]  что я успел, уже как бы вызывает уважение к человеку, который это написал. Уж очень классно.
[01:51:34.040 --> 01:51:43.120]  Вот, на этом, кажется, все. Если у кого-то есть какие-то вопросы, давайте их обсудим.
[01:51:43.120 --> 01:51:52.320]  В первую очередь, по домашку. По третьей домашке подошел Deadline. Ее решила мало человек.
[01:51:52.320 --> 01:51:58.960]  Явно какие-то трудности. Возможно, вам нужна помощь. Мы можем это обсудить.
[01:51:58.960 --> 01:52:07.920]  Или у вас просто не было времени. Или уже все из зума убежали и не слушают.
[01:52:07.920 --> 01:52:24.160]  Нет, ну окей, тут есть всего два человека, которые не решили. Но, видимо,
[01:52:24.160 --> 01:52:43.200]  что это такое? Почему люди левают? Это было Citro, ладно. Я не знаю,
[01:52:43.200 --> 01:52:48.000]  если вообще смысл тогда разбор в домашке делать. Под запися его не хочу делать. Запися все-таки
[01:52:48.000 --> 01:52:58.040]  на YouTube. А если никого нету, ну вернее, из тех, кто есть, почти все решили, то какой смысл?
[01:52:58.040 --> 01:53:06.000]  А вот один из вас не решил, я забыл, кто. Ты не решил, потому что не успел или? То есть,
[01:53:06.000 --> 01:53:23.160]  пока еще не пытался даже. Не потому что сложно, непонятно. А, третье легче, чем второе гораздо.
[01:53:23.160 --> 01:53:34.640]  Да, это я в чатике вроде уже писал, а может и не писал. По третьей домашке куда проще второй.
[01:53:34.640 --> 01:53:42.960]  Внезапно. За второй я, наверное, приниму баллы. Все-таки я никак не могу решиться делать это или нет.
[01:53:42.960 --> 01:53:52.920]  Но посмотрим. А еще хочу с таким вопросом обратиться к тем, кто еще остался. А не хотели
[01:53:52.920 --> 01:54:01.800]  ли бы вы поделать докладики и порассказать что-нибудь прикольное? А, например, есть Густ Хана. Это такая
[01:54:01.800 --> 01:54:07.120]  библиотека, которая проповедует очень хитрую идеологию того, как нужно заниматься метапрограммированием.
[01:54:07.120 --> 01:54:19.440]  Они... Ну ладно, даже в двух словах это не рассказать. В общем, это целый такой отдельный стиль того,
[01:54:19.440 --> 01:54:25.680]  как писать метакод и метафункции, любые там подчисления со списком типов и прочими вещами.
[01:54:25.680 --> 01:54:31.640]  Было бы интересно, если бы кто-нибудь про это готовил доклад, рассказал. За это, конечно,
[01:54:31.640 --> 01:54:40.280]  уже будут баллы. Вот. Можно еще какие-то темы придумать. Вот если у вас есть желание что-нибудь
[01:54:40.280 --> 01:54:46.920]  разводить и поднять за это баллов, возможно, упущенных на домашко, то такая возможность есть.
[01:54:46.920 --> 01:55:02.920]  А когда угодно. Ну, то есть, доклад не должно быть три часа, как я тут вещаю. Это должно быть
[01:55:02.920 --> 01:55:17.360]  что-нибудь типа полчасика рассказать. Вот. У нас просто осталось еще материала на лекции три. Я вот
[01:55:17.360 --> 01:55:25.840]  не знаю. Даже меньше, наверное. Две-три, наверное. Ну, моя оценка может быть неправильной, может
[01:55:25.840 --> 01:55:33.680]  оказаться, что на самом деле больше. А может и меньше. Соответственно, есть возможность какие-то
[01:55:33.680 --> 01:55:44.000]  вещи на самом деле даже скипануть. Какие-то вещи скипануть не получится, потому что домашки. В общем,
[01:55:44.000 --> 01:55:51.760]  доклады впихнутся явно. То есть, в любой момент пишете там на выходных, что-то мне вдохновение
[01:55:52.120 --> 01:56:00.440]  пришло, хочу доклад, такая-то тема. Мы обсуждаем в следующий семинар, занятия, вы что-нибудь рассказываете
[01:56:00.440 --> 01:56:07.520]  классное. Я, наверное, накидаю в чат темы, по которым я считаю было бы интересно подготовить и рассказать.
[01:56:07.520 --> 01:56:19.040]  Вот. Ну, один человек желающий есть. Надеюсь, еще кто-нибудь появится. Вот. На этом, видимо, все. Не
[01:56:19.040 --> 01:56:31.720]  будем досиживать эти три часа. Все хотят есть, спать и отдыхать. Так что, да. Всем спасибо, всем пока.
