[00:00.000 --> 00:13.000]  Товарищи, нам предстоит грандиозный выбор. Есть STD Any, есть STD Function.
[00:13.000 --> 00:19.000]  Что из них? Function больше интересно, да, как работает?
[00:20.000 --> 00:24.000]  Bind. А Any вы писали на...
[00:38.000 --> 00:42.000]  Короче, давайте считать, что не все здесь писали Function.
[00:42.000 --> 00:55.000]  Поэтому сюда. Нет, не сюда. Так, давай не будем. Нам сюда.
[00:55.000 --> 01:13.000]  Значит, смотрите. Сеттинг следующий. Мы хотим STD Function.
[01:13.000 --> 01:23.000]  Работать он должен примерно точно так же, как STD Function. Просто пихаем туда лямду, и она работает.
[01:23.000 --> 01:31.000]  Ну, тут от какого-то функционального объекта конструируют, от лямды, и там что-то происходит.
[01:31.000 --> 01:38.000]  Я не помню, я это вписал в четыре ночи в какой-то момент в начале семестра.
[01:38.000 --> 01:43.000]  Давайте разберемся, что я хотел сказать. Cold ones изначально равно false.
[01:43.000 --> 01:52.000]  Возможно. Нет, я хочу просто, чтобы лямда, когда ее первый раз вызвали, написала hello,
[01:52.000 --> 02:04.000]  а второй нет. Вот F, и мы тут эту F фу передаем, она туда копируется и пишет что-то.
[02:04.000 --> 02:10.000]  Ну, короче, неважно. Нужно написать Function. Какая семантика? Кладем внутрь лямду,
[02:10.000 --> 02:16.000]  и она внутри живет вместе со своим захватом. То есть Function это не только указатель на функцию,
[02:16.000 --> 02:21.000]  это еще и какое-то состояние. И то, и другое.
[02:21.000 --> 02:27.000]  Причем сюда можно не только лямды класть, можно еще класть объекты какие-то,
[02:27.000 --> 02:31.000]  которые умеет оператор круглые скобки, но и все поля, которые у этих объектов есть,
[02:31.000 --> 02:36.000]  они как бы тоже внутри должны жить. То есть это полноценный контейнер для любого типа.
[02:36.000 --> 02:44.000]  И вот это ровно то, что называется TypeRager. Мы сюда можем положить объект любого типа,
[02:44.000 --> 02:50.000]  коль скоро у него есть оператор круглой скобки. И этот оператор круглой скобки каким-то
[02:50.000 --> 02:56.000]  волшебным образом мы запомним и будем уметь его звать даже не зная типа объекта.
[02:56.000 --> 03:03.000]  То есть вот эта функция Fу, она понятия не имеет, какой на самом деле тип внутри F лежит.
[03:03.000 --> 03:09.000]  Но она все равно может его позвать. Вот это такой некоторый аналог,
[03:09.000 --> 03:16.000]  некоторое скрещивание статического и динамического полиморфизма. Что-то есть от обоих.
[03:16.000 --> 03:25.000]  И называется это TypeRager. А теперь надо это написать, потому что здесь вот так вот,
[03:25.000 --> 03:35.000]  а надо свою. Но тут, конечно, большой вопрос, как мы это будем писать.
[03:35.000 --> 03:45.000]  Нет, это не то, что я имел в виду. Давайте, наверное, все-таки я буду писать,
[03:45.000 --> 03:49.000]  потому что сложно сейчас как-то это распараллелить на всех будет.
[03:49.000 --> 03:57.000]  Ну первое, давайте интерфейс публичный повторим. Тут есть один шаблонный параметр,
[03:57.000 --> 04:05.000]  должен быть какой-то конструктор чего-то и оператор круглые скобки. Шаблонный параметр.
[04:11.000 --> 04:17.000]  Конструктор. Ну, наверное, и дефолтный будет, и еще какой-то, пока непонятно какой.
[04:17.000 --> 04:27.000]  Оператор круглые скобки. Что? АТ? Ну, пока давай так оставим.
[04:27.000 --> 04:35.000]  Оператор круглые скобки, тоже пока непонятно от чего. Вплевать, что-то будет лежать, наверное.
[04:35.000 --> 04:43.000]  Ну, еще я... Ну, это прекрасная идея, но сейчас разберемся.
[04:43.000 --> 04:55.000]  Ну, это не интересно, если так. Да, про то, что мы передаем в конструктор,
[04:55.000 --> 05:03.000]  Т или не Т. Ну, какие мнения есть? Вот похожа на правду вот такая конструкция?
[05:03.000 --> 05:11.000]  Разный тип, да. Вот просто смотря на то, как используется std.function...
[05:11.000 --> 05:19.000]  Сейчас разберемся. Вот как function используется. Вот здесь указан тип функции, функциональный тип.
[05:19.000 --> 05:25.000]  Просто void.int. Это значит какая-то функция, принимающая int.
[05:25.000 --> 05:37.000]  А в конструктор мы кладем объект типа functional object. То есть вот этот тип и тип аргумента конструктора, они отличаются.
[05:37.000 --> 05:47.000]  Ну, внезапно оказывается, что мы хотим вот так. Причем здесь какой-то вообще там по универсальной ссылке принимаем f.
[05:47.000 --> 05:53.000]  Дальше. Мы хотим оператора круглые скобки. Какой хотим оператора круглые скобки?
[05:53.000 --> 06:01.000]  Ну, ровно такой же, какой указан вот здесь, да? Вот это сигнатура для нашего оператора круглые скобки.
[06:01.000 --> 06:11.000]  Внимание, вопрос. Как сделать сигнатуру вот этой фигни такой, как написано вот здесь?
[06:11.000 --> 06:21.000]  Нет, в ряде. Сейчас. Что же ты имеешь ввиду?
[06:31.000 --> 06:35.000]  Как? Ты хочешь вот так сделать или что?
[06:35.000 --> 06:39.000]  Что? Что? Что ты хочешь сделать?
[06:39.000 --> 07:07.000]  Ну, это как-то очень глупо, потому что у нас вот в этом типе уже закодирована вся информация о том, какая должна быть сигнатура. Прямо сказанная.
[07:07.000 --> 07:19.000]  Возвращать void, принимать на вход int. Нет, мы не хотим статик касты. Мы хотим, чтобы тут сигнатура была у оператора круглые скобки ровно как написано вот здесь.
[07:19.000 --> 07:31.000]  Ну, раз уж у нас есть конструктор tf, наверное, мы напишем поле, типа. А, сейчас у нас конструктор шаблонный, а tf – сигнатура, да?
[07:31.000 --> 07:39.000]  Про конструктор пока вообще не думаем. Тут ничего не понятно. Единственное, что поняли, сюда приходит произвольный объект, и его как-то надо сохранить, как непонятно.
[07:39.000 --> 07:57.000]  Ну, вот просто руками вот так вот сделать, и оно, конечно, сработает.
[07:57.000 --> 08:09.000]  Да, в стандартном std function используется не такой синтаксис, а прямо пишется сигнатура функции. То есть вот это тоже тип, да? Это тип ссылки на функцию.
[08:09.000 --> 08:23.000]  Когда-нибудь задумывались в таких вещах? Нет? Нет, ну functional pointer выглядит вот так. Вот такой дурацкий синтаксис, да?
[08:23.000 --> 08:33.000]  Вот эта звездочка в круглых скобках значит, что это указатель на функцию, слева от нее пишется возвращаемое значение, справа в круглых скобках – аргументы.
[08:33.000 --> 08:46.000]  Да, еще можно название внутри, но я предпочитаю всегда юзинги заводить, чтобы о таких бредовых вещах не думать. А есть function ref, она выглядит вот так.
[08:46.000 --> 09:11.000]  Вот это тоже вполне валидный тип в языке C++, это ссылка на функцию. Более того, если навесить звездочку, то будет то, что вы ожидаете. Funcraft превратится в funcptr.
[09:11.000 --> 09:26.000]  Ну давай посмотрим. Только, а как мы разменим? Не, ну нельзя.
[09:26.000 --> 09:43.000]  Очень сомневаюсь, что что-то получится, но вдруг. Ну не работает, нельзя.
[09:43.000 --> 10:02.000]  Ну вот, е-мое, каждый год что-то новое узнаю. Это еще один тип, да? Совсем другой.
[10:02.000 --> 10:18.000]  Вот это не то же самое, что вот это, а это как бы, то есть это как бы тоже указатель, а нет, да, это указатель, а это фигня, это ссылка.
[10:18.000 --> 10:31.000]  Нет, сейчас. И так можно, да? Слушайте, ну давайте тогда не будем это плохом.
[10:31.000 --> 10:45.000]  То есть, короче, C++ язык считает, что функция, это в принципе то же самое, что объекты, да? То есть это даже не function reference, я, получается, наврал.
[10:45.000 --> 11:01.000]  Я всегда его function reference называл, но, да, видимо, C++ считает, что точно так же, как у вас есть int, обычный int, есть int, а бывает указатель на int.
[11:01.000 --> 11:19.000]  Бывает ссылка на int и бывает R-value ссылка на int. Оказывается, C++ считает, что то же самое, что с функциями происходит, да? Есть тип функции, есть указатель на функцию, есть ссылка на функцию, R-value ссылка на функцию.
[11:19.000 --> 11:25.000]  Что нет, вот, я написал.
[11:25.000 --> 11:41.000]  Фанк, вот это вот что такое? Ну это тип, это тип функция. У этого типа не думаю, что есть значение. Как это использовать, да никак. Нет, а, окей, значение этого типа это функция.
[11:41.000 --> 11:51.000]  Ну, то есть сейчас я, короче, вас, кажется, начну учить супер плохому.
[11:51.000 --> 12:05.000]  Нет, sizeof, я думаю, не скомпилируется, потому что это нерегулярный тип, но можно написать вот так.
[12:05.000 --> 12:19.000]  Что это значит? Это значит, где-то в другой единице трансляции есть функция foo. Я могу ее в той же написать, в принципе, да? Нет, не могу. Могу.
[12:19.000 --> 12:45.000]  Ну, функция foo. А да, чтобы подтвердить мой point, я просто вот так сделаю.
[12:45.000 --> 12:57.000]  Если мы кликнем, то нас приведет сюда. Вы видите, компилятор считает, что это мы вызвали вот эту функцию. Ну, то есть этот тип работает как любой другой тип.
[12:57.000 --> 13:05.000]  Вы можете объявить функцию при помощи этого типа. Просто взять и объявить. Вот она, foo, объявлена. Это функция.
[13:05.000 --> 13:15.000]  У меня есть предположение, что sizeof.funk не скомпилируется, а sizeof.funk.vr.funk.ref и funk.vr.ref скомпилируются.
[13:15.000 --> 13:27.000]  Да, правильно. Так нельзя. Так implementation defined, кажется. Ну, тут вот 8 получилось.
[13:27.000 --> 13:37.000]  Sizeof.ref, он не компилируется, конечно же, потому что это все равно, что применить sizeof к тому, на что reference. Ну, как функции нельзя.
[13:37.000 --> 13:59.000]  Чудеса происходят в языке C++, но тем не менее. Исторически так сложилось, что вот этот синтаксис используется как abuse, чтобы указать функции тип ее оператора круглой скобки.
[13:59.000 --> 14:07.000]  Вот, ну если, ой, вот это же вас на плохие мысли должно было вытолкнуть, да?
[14:07.000 --> 14:23.000]  Что значит using? Вот у нас класс T, тип функции. Ну, значит мы можем объявить функцию. Я не уверен, что это сработает, если что-нибудь такое написать.
[14:23.000 --> 14:33.000]  Нет, если это работает, ну не должно, короче.
[14:33.000 --> 14:46.000]  Ну, такие приколы не пройдут. Все, забыли пошлости. Давайте, ну просто взять нужные и достать из вот этого T, что там внутри запаковано с помощью этого синтакса смешного. Как это сделать?
[14:46.000 --> 14:51.000]  Распаковать такой тип сложный.
[14:51.000 --> 15:04.000]  Зачем? Мы можем написать, ну, если мы хотим прям закрыть от юлера все это, мы можем сначала написать, типа template class signature с class function.
[15:04.000 --> 15:09.000]  И затем уже сматчить его непосредственно к class tag.
[15:09.000 --> 15:19.000]  Нет, сейчас у нас всего час, поэтому мы не будем пытаться совсем красиво делать. Специализацию, все, вот простой ответ. Вам нужно распаковать сложный тип, делайте специализацию.
[15:19.000 --> 15:31.000]  Рет. Аркс. Да, наверное, все-таки сегодня все время я буду писать код, а вы будете мне подсказывать и мы будем обсуждать.
[15:31.000 --> 15:37.000]  Потому что надо успеть побыстрее, чтобы я финальные слова еще сказал про всю эту бодягу.
[15:37.000 --> 15:43.000]  Рет. Аркс. OK, теперь мы знаем, какой рет, какой аркс.
[15:43.000 --> 15:49.000]  Можем написать рет, оператор, круглые скобки, аркс.
[15:55.000 --> 16:01.000]  Вот, это важный вопрос. Нужен ли здесь perfect forwarding? Я утверждаю, что не нужен.
[16:01.000 --> 16:14.000]  Почему я так утверждаю? Потому что если мы начнем пытаться for perfect forwarding делать вот в этом месте, то, вернее, как универсальные ссылки начнем пытаться делать, вот такое вот.
[16:14.000 --> 16:16.000]  Так будет не очень.
[16:16.000 --> 16:18.000]  Так будет не очень. Вот почему так не очень?
[16:18.000 --> 16:20.000]  Потому что не шаблонный.
[16:21.000 --> 16:33.000]  Ну да, он как бы самый не шаблонный, но и это в принципе бессмысленно, потому что уже в этом t, вот уже в этой сигнатуре, вам могли, да, уже могли присылать зашитые ссылки.
[16:33.000 --> 16:43.000]  Там бул и тут флот с двумя. Во что это превратится после навешивания еще одной рвали ссылки?
[16:43.000 --> 16:55.000]  Ну да, да, зачем? Ну это первый может просадить, если у вас там... Ну вы понимаете, да, что маленький тип, их быстрее не по ссылке гонять, а по значению.
[16:55.000 --> 16:57.000]  То есть, ну...
[17:01.000 --> 17:06.000]  Да, крупные типы нужно оставить такие ссылки, какие указал пользователь, вот здесь, а не свои какие-то навешивать.
[17:06.000 --> 17:12.000]  Поэтому нет, здесь не нужно навешивать еще ссылки, а вот ну использовать std forward в рамках этого реализации,
[17:12.000 --> 17:15.000]  которую у нас пока нету, ну наверное понадобится все-таки.
[17:25.000 --> 17:27.000]  Почему вопрос? Я не понял.
[17:37.000 --> 17:41.000]  Я все еще не понял, что ты говоришь.
[17:41.000 --> 17:46.000]  Вот в треугольных скобочках у function...
[17:46.000 --> 17:50.000]  В треугольных скобочках...
[17:50.000 --> 17:52.000]  Можем.
[17:54.000 --> 17:56.000]  Просто у нас это не работает.
[17:56.000 --> 17:58.000]  Окей, давайте научимся выводить.
[17:58.000 --> 18:04.000]  Смотрите, вот здесь сейчас работает, код компилируется в принципе, да, ну запускать бессмысленно, я думаю.
[18:04.000 --> 18:09.000]  А вот здесь ругаются, что no viable constructor or deduction guide.
[18:09.000 --> 18:12.000]  Но вы уже умные и должны знать, чего не хватает, да?
[18:12.000 --> 18:15.000]  Вот это и вот это.
[18:15.000 --> 18:17.000]  Никак не связано, да?
[18:17.000 --> 18:19.000]  Как связать?
[18:19.000 --> 18:21.000]  Нет.
[18:21.000 --> 18:23.000]  Дедакшн гайд надо написать.
[18:26.000 --> 18:28.000]  Кто может надиктовать дедакшн гайд?
[18:28.000 --> 18:30.000]  Или мне написать?
[18:30.000 --> 18:36.000]  Ну я почти уверен, что нет.
[18:36.000 --> 18:43.000]  Потому что пишем, мы всегда в дедакшн гайде всегда пишем аргументы этого конструктора.
[18:47.000 --> 18:49.000]  Давай сначала так напишем.
[18:49.000 --> 18:51.000]  Что такое дедакшн гайд?
[18:51.000 --> 18:58.000]  Если нам позвали конструктор от вот такого выражения, то какой должен быть вот этот шаблонный аргумент T?
[18:58.000 --> 19:00.000]  Главного шаблона.
[19:00.000 --> 19:04.000]  А что ты разворачивать собрался?
[19:04.000 --> 19:08.000]  О, STD and book result.
[19:08.000 --> 19:10.000]  Нет, это не то.
[19:10.000 --> 19:12.000]  Это все не то.
[19:12.000 --> 19:15.000]  Смотрите, есть вот такой тип functional object.
[19:15.000 --> 19:17.000]  Вот его передали в конструктор.
[19:17.000 --> 19:21.000]  И мы хотим вот автоматом определить вот это.
[19:21.000 --> 19:24.000]  Где вот это вот написано у этого типа?
[19:24.000 --> 19:26.000]  Да.
[19:27.000 --> 19:30.000]  Сигнатура оператора круглые скобочки.
[19:30.000 --> 19:32.000]  Поняли, что происходит, да?
[19:32.000 --> 19:35.000]  Поэтому напишем здесь ровно так.
[19:38.000 --> 19:40.000]  Ну или не напишем.
[19:42.000 --> 19:44.000]  Написали? Получилось?
[19:44.000 --> 19:48.000]  Вот кто сказал про дес избавиться, да, вы абсолютно правы.
[19:48.000 --> 19:52.000]  Сейчас это будет pointer на мембера.
[19:52.000 --> 19:56.000]  А там уже будет тайн трейд, который управляет.
[19:56.000 --> 19:58.000]  Ну надо.
[19:58.000 --> 20:02.000]  Если у нас перегрузка оператора круглой скобочки,
[20:02.000 --> 20:04.000]  то дедакшн гайд работать не должен.
[20:04.000 --> 20:05.000]  Все.
[20:05.000 --> 20:07.000]  Как и в стандартной библиотеке.
[20:07.000 --> 20:11.000]  Ну как ты выведешь, какой из операторов круглой скобочки ты хочешь?
[20:11.000 --> 20:13.000]  Ну давайте напишем.
[20:13.000 --> 20:15.000]  Ну вот.
[20:15.000 --> 20:17.000]  Ну вот.
[20:17.000 --> 20:19.000]  Ну вот.
[20:19.000 --> 20:21.000]  Ну вот.
[20:21.000 --> 20:23.000]  Ну вот.
[20:23.000 --> 20:25.000]  Ну вот.
[20:25.000 --> 20:27.000]  Ну вот.
[20:27.000 --> 20:31.000]  Ну давайте напишем по-быстрому эту вспомогательную фигню.
[20:31.000 --> 20:35.000]  Мы хотим имя pointer на мембер, да?
[20:35.000 --> 20:37.000]  Ну это будет какой-то непонятный...
[20:39.000 --> 20:41.000]  Имея вот такую штуку.
[20:44.000 --> 20:46.000]  Что я пишу, боже мой.
[20:46.000 --> 20:51.000]  Имея такую штуку, хотим получить сигнатуру.
[20:51.000 --> 20:53.000]  Да.
[20:53.000 --> 20:55.000]  Только что tend to member, можно сразу...
[20:55.000 --> 20:57.000]  Ну можно даже без присоединяется, что-то здесь сделать.
[20:57.000 --> 20:59.000]  Нет.
[20:59.000 --> 21:01.000]  А, не пообща, да.
[21:01.000 --> 21:03.000]  Присоединяйся.
[21:03.000 --> 21:05.000]  Двоеточие, двоеточие, звездочка, да.
[21:05.000 --> 21:07.000]  Класс T, класс Red, класс...
[21:07.000 --> 21:09.000]  ARKS, да?
[21:09.000 --> 21:11.000]  Опа.
[21:11.000 --> 21:13.000]  T, двоеточие, двоеточие, звездочка.
[21:13.000 --> 21:15.000]  А это все в скобке?
[21:15.000 --> 21:17.000]  Да, это все в скобке, Red.
[21:17.000 --> 21:19.000]  И вот здесь...
[21:19.000 --> 21:21.000]  Ты понимаешь, что происходит?
[21:21.000 --> 21:23.000]  Кроме вот одного человека, который меня диктовывает правильно.
[21:23.000 --> 21:25.000]  Хорошо.
[21:25.000 --> 21:27.000]  И вот здесь...
[21:31.000 --> 21:33.000]  Так тьюзинги же нельзя специализировать вроде.
[21:33.000 --> 21:35.000]  Можно все-таки, да.
[21:35.000 --> 21:37.000]  У меня...
[21:39.000 --> 21:41.000]  Нет.
[21:41.000 --> 21:43.000]  У меня какая-то странная квантовая запутанность тьюзингов в голове.
[21:43.000 --> 21:45.000]  Я то считаю и полностью уверен, что их можно специализировать,
[21:45.000 --> 21:47.000]  то считаю полностью уверен, что нельзя.
[21:49.000 --> 21:51.000]  Вот...
[21:51.000 --> 21:53.000]  Да.
[21:53.000 --> 21:55.000]  Ну...
[21:55.000 --> 21:57.000]  По-моему, все-таки...
[21:57.000 --> 21:59.000]  Что-то у меня не так шло. Я не знаю, как так вышло.
[21:59.000 --> 22:01.000]  Надо этот вопрос решить раз и навсегда.
[22:01.000 --> 22:03.000]  Но теперь мы научились утаскивать сигнатуру.
[22:03.000 --> 22:05.000]  Что?
[22:05.000 --> 22:07.000]  Да.
[22:07.000 --> 22:09.000]  Если есть вопрос, что за фигня происходит, задайте его, пожалуйста.
[22:09.000 --> 22:13.000]  Да.
[22:13.000 --> 22:15.000]  Тип...
[22:15.000 --> 22:17.000]  Вот это...
[22:19.000 --> 22:21.000]  Что?
[22:21.000 --> 22:23.000]  Нет.
[22:23.000 --> 22:25.000]  Нет.
[22:25.000 --> 22:27.000]  Ну сейчас поймем, почему.
[22:27.000 --> 22:29.000]  Что-что?
[22:31.000 --> 22:33.000]  Ну как бы...
[22:33.000 --> 22:35.000]  Мы хотим узнать сигнатуру для оператора круглой скобки
[22:35.000 --> 22:37.000]  в нашем functional object.
[22:37.000 --> 22:39.000]  Нет.
[22:39.000 --> 22:41.000]  Нам в качестве this
[22:41.000 --> 22:43.000]  сам вот этот function выступает.
[22:43.000 --> 22:45.000]  Вот тут тоже есть this.
[22:45.000 --> 22:47.000]  Вот.
[22:47.000 --> 22:49.000]  Он и будет this.
[22:49.000 --> 22:51.000]  В том смысле, что в std function
[22:51.000 --> 22:53.000]  можно передать ссылку на метод,
[22:53.000 --> 22:55.000]  а потом первым аргументом,
[22:55.000 --> 22:57.000]  когда вы эту функцию вызываете,
[22:57.000 --> 22:59.000]  вы должны передать указатель.
[22:59.000 --> 23:01.000]  Это отдельный конструктор будет.
[23:01.000 --> 23:03.000]  Вот этот конструктор
[23:03.000 --> 23:05.000]  просто от объекта,
[23:05.000 --> 23:07.000]  у которого есть оператор круглой скобки.
[23:07.000 --> 23:09.000]  От лямбды там от прочего.
[23:09.000 --> 23:11.000]  Это отдельный конструктор, а отдельный специалист.
[23:11.000 --> 23:13.000]  Все, да, я понял.
[23:13.000 --> 23:15.000]  Кстати, у нас здесь уже сигната
[23:15.000 --> 23:17.000]  была выточена чуть-чуть дальше.
[23:21.000 --> 23:23.000]  Да.
[23:23.000 --> 23:25.000]  Я не понимаю, как выточить
[23:25.000 --> 23:27.000]  звездочку.
[23:27.000 --> 23:29.000]  Вот. Это правильный вопрос.
[23:29.000 --> 23:31.000]  Значит, в языке
[23:31.000 --> 23:33.000]  C++...
[23:33.000 --> 23:35.000]  Тут просто образовательная сейчас
[23:35.000 --> 23:37.000]  будет очень сильно.
[23:37.000 --> 23:39.000]  Давайте вспомним, какие операторы
[23:39.000 --> 23:41.000]  из C++?
[23:41.000 --> 23:43.000]  Я думаю, много звездных.
[23:43.000 --> 23:45.000]  Оператор, стрелочка, звездочка.
[23:45.000 --> 23:47.000]  Да, оператор, стрелочка, звездочка
[23:47.000 --> 23:49.000]  и оператор, точка, звездочка.
[23:49.000 --> 23:51.000]  Да. Так, в языке C++
[23:51.000 --> 23:53.000]  если сделать структуру...
[23:57.000 --> 23:59.000]  и сделать в нее, например, вот так.
[23:59.000 --> 24:01.000]  Внезапно, внезапно
[24:01.000 --> 24:03.000]  можно в runtime значение
[24:03.000 --> 24:05.000]  сохранить в каком-то смысле
[24:05.000 --> 24:07.000]  сдвиг поля относительно
[24:07.000 --> 24:09.000]  начала структуры.
[24:13.000 --> 24:15.000]  Вот.
[24:19.000 --> 24:21.000]  Называется это pointer to member.
[24:21.000 --> 24:23.000]  То есть это
[24:23.000 --> 24:25.000]  некоторый тип, описывающий
[24:25.000 --> 24:27.000]  какое из полей структуры мы выбрали.
[24:31.000 --> 24:33.000]  Выглядит заполнение
[24:33.000 --> 24:35.000]  вот так.
[24:35.000 --> 24:37.000]  То есть мы выбрали первое поле
[24:37.000 --> 24:39.000]  структуры. Могли второе,
[24:39.000 --> 24:41.000]  могли третье.
[24:41.000 --> 24:43.000]  Можем перезаписать.
[24:45.000 --> 24:47.000]  Да, ну при этом
[24:47.000 --> 24:49.000]  все эти поля, они все интового типа
[24:49.000 --> 24:51.000]  и поэтому это работает.
[24:51.000 --> 24:53.000]  А дальше вот этот вот волшебный указатель
[24:53.000 --> 24:55.000]  ptr, который как бы
[24:55.000 --> 24:57.000]  помнит
[24:57.000 --> 24:59.000]  какое из полей
[24:59.000 --> 25:01.000]  нас интересует, мы можем его
[25:01.000 --> 25:03.000]  использовать, чтобы на конкретном объекте
[25:03.000 --> 25:05.000]  point
[25:05.000 --> 25:07.000]  обратиться к
[25:07.000 --> 25:09.000]  конкретному полю
[25:11.000 --> 25:13.000]  и заполнить его или прочитать.
[25:15.000 --> 25:17.000]  Прикол, да?
[25:17.000 --> 25:19.000]  Кто не знал об этом?
[25:19.000 --> 25:21.000]  А зачем?
[25:25.000 --> 25:27.000]  Ну, в языке C++
[25:27.000 --> 25:29.000]  таких вопросов обычно не задают.
[25:31.000 --> 25:33.000]  Ну можно.
[25:35.000 --> 25:37.000]  Почему?
[25:37.000 --> 25:39.000]  Вдруг тебе реально хочется, чтобы
[25:39.000 --> 25:41.000]  вот один и тот же кусок кода отработал
[25:41.000 --> 25:43.000]  два раза.
[25:57.000 --> 25:59.000]  Кстати, это отличный
[25:59.000 --> 26:01.000]  пример, который даже я в какой-то момент
[26:01.000 --> 26:03.000]  накодил, правда на ревью у меня конечно
[26:03.000 --> 26:05.000]  косо посмотреть.
[26:05.000 --> 26:07.000]  Потом я накодил лучше, но в принципе так
[26:07.000 --> 26:09.000]  можно.
[26:09.000 --> 26:11.000]  Просто нормальный код писать я не знаю.
[26:17.000 --> 26:19.000]  Ну да.
[26:19.000 --> 26:21.000]  Можно сделать мапу
[26:21.000 --> 26:23.000]  из стринга в точку
[26:23.000 --> 26:25.000]  point.
[26:25.000 --> 26:27.000]  Вот.
[26:33.000 --> 26:35.000]  Ой, да.
[26:35.000 --> 26:37.000]  Потом еще хранить где-то эти строки.
[26:37.000 --> 26:39.000]  Давайте не будем.
[26:43.000 --> 26:45.000]  А, в смысле конфиг у тебя не
[26:45.000 --> 26:47.000]  из этого прочитано, а откуда-то там
[26:47.000 --> 26:49.000]  из...
[26:49.000 --> 26:51.000]  Я все равно должен написать отдельную
[26:51.000 --> 26:53.000]  руку.
[26:53.000 --> 26:55.000]  Окей, я пишу это с мыслью...
[27:03.000 --> 27:05.000]  Короче, неважно, так...
[27:07.000 --> 27:09.000]  В проде так не пишите, все.
[27:09.000 --> 27:11.000]  Пример следующий, вот есть конфиг
[27:11.000 --> 27:13.000]  его хотим из файла инициализировать.
[27:13.000 --> 27:15.000]  Мы знаем, что в файле вот написано
[27:15.000 --> 27:17.000]  там field1, field2, field3.
[27:17.000 --> 27:19.000]  Но это JSON какой-то, да?
[27:19.000 --> 27:21.000]  Там просто строки написаны.
[27:21.000 --> 27:23.000]  Соответственно, нам нужно понять как-то
[27:23.000 --> 27:25.000]  по строке файла, какой из полей мы хотим
[27:25.000 --> 27:27.000]  заполнить.
[27:27.000 --> 27:29.000]  Но мы возьмем и сделаем мапчик
[27:29.000 --> 27:31.000]  из строк в конфиг
[27:31.000 --> 27:33.000]  2.2.
[27:33.000 --> 27:35.000]  Вот так вот.
[27:35.000 --> 27:37.000]  Инициализируем этот мапчик тем,
[27:37.000 --> 27:39.000]  что
[27:39.000 --> 27:41.000]  field1
[27:41.000 --> 27:43.000]  попадает в
[27:43.000 --> 27:45.000]  i
[27:45.000 --> 27:47.000]  f
[27:51.000 --> 27:53.000]  Нет.
[27:53.000 --> 27:55.000]  Никуда мы не превращаемся.
[28:03.000 --> 28:05.000]  Вот, а еще, еще мы сюда в какой-то момент
[28:05.000 --> 28:07.000]  flatmap бахнем и допишем
[28:07.000 --> 28:09.000]  constexpr. И тогда
[28:09.000 --> 28:11.000]  мы вот вообще там...
[28:11.000 --> 28:13.000]  Не даже теперь потеряли.
[28:13.000 --> 28:15.000]  Но пока не можем так.
[28:15.000 --> 28:17.000]  Пока что не работает.
[28:17.000 --> 28:19.000]  Понятно суть, да? Зачем это может быть
[28:19.000 --> 28:21.000]  нужно?
[28:25.000 --> 28:27.000]  Ну вот, такая штука, по-моему, я что-то такое
[28:27.000 --> 28:29.000]  описал в какой-то момент, но потом удалил
[28:29.000 --> 28:31.000]  и правильно сделал.
[28:37.000 --> 28:39.000]  В редких.
[28:41.000 --> 28:43.000]  Да.
[28:43.000 --> 28:45.000]  Во-во-во.
[28:45.000 --> 28:47.000]  Да, это отличный пример.
[28:47.000 --> 28:49.000]  Если чуть подробнее рассказать, то давайте
[28:49.000 --> 28:51.000]  вот так.
[28:53.000 --> 28:55.000]  Вот в ренджах
[28:55.000 --> 28:57.000]  добавили новую функцию сортировки.
[28:57.000 --> 28:59.000]  То есть просто вот такая функция есть.
[28:59.000 --> 29:01.000]  Где она полностью выписана?
[29:01.000 --> 29:03.000]  Нигде.
[29:03.000 --> 29:05.000]  Ну, ты видела, как я только что вписал, да?
[29:05.000 --> 29:07.000]  Вот.
[29:07.000 --> 29:09.000]  std.range.sort
[29:09.000 --> 29:11.000]  Сортирует, но вот тут есть buff,
[29:11.000 --> 29:13.000]  ей добавили proj, такой аргумент.
[29:13.000 --> 29:15.000]  И вот в этот аргумент можно
[29:15.000 --> 29:17.000]  скормить вот такой
[29:17.000 --> 29:19.000]  указатель. И тогда
[29:19.000 --> 29:21.000]  ты сможешь конфиги или там точки
[29:21.000 --> 29:23.000]  отсортировать по иксу.
[29:23.000 --> 29:25.000]  Да, но
[29:25.000 --> 29:27.000]  это мне неудобно, чем проекция.
[29:29.000 --> 29:31.000]  Да. Вот тут нормальное
[29:31.000 --> 29:33.000]  применение. И у нас нормальное
[29:33.000 --> 29:35.000]  применение, потому что мы только что это
[29:35.000 --> 29:37.000]  применили. И вот точно так же,
[29:37.000 --> 29:39.000]  как я говорил, что
[29:39.000 --> 29:41.000]  вообще-то
[29:41.000 --> 29:43.000]  вообще-то вот это
[29:43.000 --> 29:45.000]  вполне нормальный тип, функ, да?
[29:45.000 --> 29:47.000]  Давайте запомним его.
[29:47.000 --> 29:49.000]  Вообще-то вот здесь можно написать любой
[29:49.000 --> 29:51.000]  тип. То есть конфиг, два двуточья, звездочка
[29:51.000 --> 29:53.000]  и перед этим что угодно.
[29:55.000 --> 29:57.000]  Где?
[29:57.000 --> 29:59.000]  Вот тут стринг.
[30:03.000 --> 30:05.000]  Нет, ну всегда надо что-то писать
[30:05.000 --> 30:07.000]  перед вот этим вот конструкцией.
[30:13.000 --> 30:15.000]  Вот здесь?
[30:15.000 --> 30:17.000]  А, нет, туда пока не смотрим.
[30:17.000 --> 30:19.000]  Потому что тут прикол.
[30:19.000 --> 30:21.000]  Ну, раз туда что угодно можно
[30:21.000 --> 30:23.000]  написать, почему бы туда не написать тип
[30:23.000 --> 30:25.000]  функции?
[30:25.000 --> 30:27.000]  Функция, это что же в каком-то смысле
[30:27.000 --> 30:29.000]  член класса, структура и прочего?
[30:31.000 --> 30:33.000]  Тоже member.
[30:33.000 --> 30:35.000]  А это указатель на любой member.
[30:35.000 --> 30:37.000]  Но будет указатель на функцию, являющуюся
[30:37.000 --> 30:39.000]  мембером.
[30:47.000 --> 30:49.000]  Member функцию к
[30:49.000 --> 30:51.000]  мембер полю?
[30:55.000 --> 30:57.000]  Так это ж одно и то же нет.
[30:57.000 --> 30:59.000]  Потому что вот я тип функции указал и вот.
[30:59.000 --> 31:01.000]  Ну, если это
[31:01.000 --> 31:03.000]  расписать подробнее, то вот мы посмотрим
[31:03.000 --> 31:05.000]  какая сигнатура у функ была void
[31:05.000 --> 31:07.000]  int bool, да?
[31:07.000 --> 31:09.000]  Явно расписывая, будет вот так.
[31:09.000 --> 31:11.000]  Да, ты что-то другое, кажется,
[31:11.000 --> 31:13.000]  имел ввиду. Вот это
[31:13.000 --> 31:15.000]  один и тот же класс, да?
[31:23.000 --> 31:25.000]  А, про это готов
[31:25.000 --> 31:27.000]  поверить, там странные правила.
[31:27.000 --> 31:29.000]  Ну вот, что это значит?
[31:29.000 --> 31:31.000]  Мы умеем хранить указатель
[31:31.000 --> 31:33.000]  на конкретную функцию,
[31:33.000 --> 31:35.000]  вернее, конкретный метод в
[31:35.000 --> 31:37.000]  поле, в классе.
[31:37.000 --> 31:39.000]  Ага.
[31:39.000 --> 31:41.000]  Вот здесь ровно это происходит.
[31:41.000 --> 31:43.000]  Мы говорим, что
[31:43.000 --> 31:45.000]  decltype f2.
[31:45.000 --> 31:47.000]  оператор круглой скобки, это что такое?
[31:47.000 --> 31:49.000]  Это указатель вообще-то
[31:49.000 --> 31:51.000]  на member.
[31:51.000 --> 31:53.000]  Оператор круглой скобки это member вот этого f.
[31:53.000 --> 31:55.000]  Мы берем ссылку
[31:55.000 --> 31:57.000]  на самом деле, а не указатель, да?
[31:57.000 --> 31:59.000]  Тут опять вот эти вот все оговорки
[31:59.000 --> 32:01.000]  про то, что здесь не только звездочка,
[32:01.000 --> 32:03.000]  наверное, может быть, скорее всего.
[32:05.000 --> 32:07.000]  Вот это вот, это
[32:07.000 --> 32:09.000]  ссылка на member.
[32:09.000 --> 32:11.000]  Нет, указатель, нет, все, вру.
[32:11.000 --> 32:13.000]  Тут только указатель, тут только указатель.
[32:13.000 --> 32:15.000]  Это указатель на...
[32:19.000 --> 32:21.000]  Ну вот, наверное, да,
[32:21.000 --> 32:23.000]  наверное, все-таки тут просто ничего компилироваться не будет.
[32:25.000 --> 32:27.000]  Вот, нет, вот так, именно так.
[32:27.000 --> 32:29.000]  Вот, это указатель на
[32:29.000 --> 32:31.000]  member, мы берем его
[32:31.000 --> 32:33.000]  тип и запихиваем в нашу
[32:33.000 --> 32:35.000]  шаблон волшебный.
[32:35.000 --> 32:37.000]  Вот этот шаблон распаковывает
[32:37.000 --> 32:39.000]  по общему паттерну, как оно
[32:39.000 --> 32:41.000]  выглядит, ред,
[32:41.000 --> 32:43.000]  класс у которого этот
[32:43.000 --> 32:45.000]  member и аргументы.
[32:45.000 --> 32:47.000]  Потому что мы тут оператор круглой скобки
[32:47.000 --> 32:49.000]  смотрим, это всегда
[32:49.000 --> 32:51.000]  member функция,
[32:51.000 --> 32:53.000]  то есть метод. Ну и
[32:53.000 --> 32:55.000]  распаковав, мы обратно запаковываем,
[32:55.000 --> 32:57.000]  но уже без
[32:57.000 --> 32:59.000]  вот этой вот фигни, просто как обычную
[32:59.000 --> 33:01.000]  функцию. Прикол,
[33:01.000 --> 33:03.000]  да?
[33:05.000 --> 33:07.000]  Вот то,
[33:07.000 --> 33:09.000]  что вот эта вот часть, она
[33:09.000 --> 33:11.000]  как бы, она и отвечает за
[33:11.000 --> 33:13.000]  this, да?
[33:15.000 --> 33:17.000]  Ну кто-то
[33:17.000 --> 33:19.000]  в смысле, ну кто-то говорил,
[33:19.000 --> 33:21.000]  что вот так надо написать,
[33:21.000 --> 33:23.000]  что типа давайте явно передавать this.
[33:23.000 --> 33:25.000]  Или может
[33:25.000 --> 33:27.000]  я не понял просто, что мне говорит.
[33:27.000 --> 33:29.000]  Специализацию
[33:29.000 --> 33:31.000]  и без указательств.
[33:31.000 --> 33:33.000]  Специализацию, да, function.
[33:33.000 --> 33:35.000]  Просто звездочку
[33:35.000 --> 33:37.000]  без std.
[33:37.000 --> 33:39.000]  This.
[33:39.000 --> 33:41.000]  Что?
[33:41.000 --> 33:43.000]  Ну короче,
[33:43.000 --> 33:45.000]  как функция, которая первым аргументом
[33:45.000 --> 33:47.000]  this принимает. Ну можно
[33:47.000 --> 33:49.000]  написать функцию, которая первым аргументом this принимает.
[33:49.000 --> 33:51.000]  А, нет.
[33:51.000 --> 33:53.000]  Нет, нет, нет.
[33:53.000 --> 33:55.000]  Это не то же самое.
[33:55.000 --> 33:57.000]  Вот как раз в том-то и сложность, что ты не можешь
[33:57.000 --> 33:59.000]  получить функцию, которая как бы
[33:59.000 --> 34:01.000]  имеет такую же сигнатуру, но явный аргумент,
[34:01.000 --> 34:03.000]  кроме как вот через вот такой вспомогательный
[34:03.000 --> 34:05.000]  шаблон.
[34:05.000 --> 34:07.000]  Ну как бы
[34:07.000 --> 34:09.000]  полный тип да,
[34:09.000 --> 34:11.000]  но нам this не нужен.
[34:11.000 --> 34:13.000]  Ну вообще тип
[34:13.000 --> 34:15.000]  метода в классе,
[34:15.000 --> 34:17.000]  вот он.
[34:17.000 --> 34:19.000]  Полный тип метода в классе.
[34:19.000 --> 34:21.000]  Здесь неявный аргумент, это this,
[34:21.000 --> 34:23.000]  который обозначен через вот этот забавный синтаксис,
[34:23.000 --> 34:25.000]  то есть у какого класса
[34:25.000 --> 34:27.000]  это member.
[34:27.000 --> 34:29.000]  А так в целом это просто функция
[34:29.000 --> 34:31.000]  с вот такими аргументами, вот таким результатом.
[34:31.000 --> 34:33.000]  Что?
[34:33.000 --> 34:35.000]  Почему
[34:35.000 --> 34:37.000]  в скобочках в правом рейтере
[34:39.000 --> 34:41.000]  Так, ты проснулся, кажется.
[34:41.000 --> 34:43.000]  Вот,
[34:43.000 --> 34:45.000]  сюда возвращаемся.
[34:45.000 --> 34:47.000]  Это то же самое.
[34:47.000 --> 34:49.000]  Вот это указатель
[34:49.000 --> 34:51.000]  на member такого типа.
[34:59.000 --> 35:01.000]  Нет, есть общий синтаксис
[35:01.000 --> 35:03.000]  указатель на member.
[35:03.000 --> 35:05.000]  Вот это указатель на member string.
[35:07.000 --> 35:09.000]  Да?
[35:09.000 --> 35:11.000]  Я говорю, давай вместо стринга сюда
[35:11.000 --> 35:13.000]  поставим тип функции.
[35:13.000 --> 35:15.000]  Вспоминаю, этот метод выглядит как void от int bool.
[35:19.000 --> 35:21.000]  String заменили на void от int bool.
[35:23.000 --> 35:25.000]  И на самом деле
[35:27.000 --> 35:29.000]  получили
[35:29.000 --> 35:31.000]  method.
[35:31.000 --> 35:33.000]  Вот так надо назвать это.
[35:33.000 --> 35:35.000]  Я заговариваюсь.
[35:35.000 --> 35:37.000]  И мы получили то, что называется
[35:37.000 --> 35:39.000]  указатель на метод.
[35:39.000 --> 35:41.000]  Вот эти два типа одинаковые.
[35:41.000 --> 35:43.000]  Да?
[35:43.000 --> 35:45.000]  То есть это указатель на поле
[35:45.000 --> 35:47.000]  в кавычках,
[35:47.000 --> 35:49.000]  которая на самом деле является функцией.
[35:49.000 --> 35:51.000]  Суммарно, это указатель
[35:51.000 --> 35:53.000]  на конкретный метод в классе.
[35:53.000 --> 35:55.000]  Если этого класса несколько методов
[35:59.000 --> 36:01.000]  foobar,
[36:01.000 --> 36:03.000]  то ты в переменную вот такого
[36:03.000 --> 36:05.000]  типа сможешь положить
[36:07.000 --> 36:09.000]  То есть указатель на member походит
[36:09.000 --> 36:11.000]  в часть типа метода.
[36:13.000 --> 36:15.000]  Чей member входит в часть типа метода, да.
[36:19.000 --> 36:21.000]  Фу, можно вот так.
[36:25.000 --> 36:27.000]  Можно вот так.
[36:29.000 --> 36:31.000]  Да, в типе
[36:31.000 --> 36:33.000]  указателя на функцию member
[36:33.000 --> 36:35.000]  зашита
[36:35.000 --> 36:37.000]  у какого класса member
[36:37.000 --> 36:39.000]  какого типа member.
[36:39.000 --> 36:41.000]  А для функции тип означает
[36:41.000 --> 36:43.000]  возвращаемое значение и аргументы.
[36:53.000 --> 36:55.000]  В общем, что-то образовательно
[36:55.000 --> 36:57.000]  сегодня получилось, но я надеюсь, вы поняли
[36:57.000 --> 36:59.000]  идею с этим.
[36:59.000 --> 37:01.000]  Возможно, это надо перечитать,
[37:01.000 --> 37:03.000]  пересмотреть несколько раз.
[37:03.000 --> 37:05.000]  И один раз самостоятельно закодить
[37:05.000 --> 37:07.000]  какой-то из домашек, а может и не надо.
[37:07.000 --> 37:09.000]  Ну вот, такой есть.
[37:09.000 --> 37:11.000]  Это жестко,
[37:11.000 --> 37:13.000]  но оно нужно.
[37:13.000 --> 37:15.000]  Напоминаю, с чего мы все начали.
[37:15.000 --> 37:17.000]  Мы хотели, чтобы вот этот код компилировался.
[37:19.000 --> 37:21.000]  Хотим вывести тип
[37:21.000 --> 37:23.000]  для функции,
[37:23.000 --> 37:25.000]  в которую положили какую-то лямду.
[37:27.000 --> 37:29.000]  Ну, давайте проверим,
[37:29.000 --> 37:31.000]  что моя гипотеза верна.
[37:31.000 --> 37:33.000]  Только для этого понадобится
[37:39.000 --> 37:41.000]  вытащить
[37:41.000 --> 37:43.000]  наружу.
[37:43.000 --> 37:45.000]  Давайте проверим, что
[37:51.000 --> 37:53.000]  у вот этой вот f,
[37:53.000 --> 37:55.000]  ее тип получился
[37:55.000 --> 37:57.000]  ровно такой, какой мы ожидаем.
[37:57.000 --> 37:59.000]  Какой мы ожидаем у этой лямды?
[37:59.000 --> 38:01.000]  Вот в этом месте, чтобы вывелся тип.
[38:01.000 --> 38:03.000]  Void attempt.
[38:07.000 --> 38:09.000]  Не поверите, статик ассорт прошел.
[38:11.000 --> 38:13.000]  Он же не просто сломался,
[38:13.000 --> 38:15.000]  да? Все нормально.
[38:15.000 --> 38:17.000]  То есть мы правильно выдрали
[38:17.000 --> 38:19.000]  из вот этой вот сложной конструкции
[38:19.000 --> 38:21.000]  сигнатуру оператора круглой скобки.
[38:21.000 --> 38:23.000]  Теперь, наконец-то, пора
[38:23.000 --> 38:25.000]  имплементировать эту шнягу.
[38:25.000 --> 38:27.000]  Вы рады?
[38:27.000 --> 38:29.000]  Да, такое бывает.
[38:33.000 --> 38:35.000]  Давайте думать.
[38:35.000 --> 38:37.000]  Нам нужно сохранить две вещи.
[38:37.000 --> 38:39.000]  Сам объект
[38:39.000 --> 38:41.000]  и как вызвать оператора
[38:41.000 --> 38:43.000]  круглой скобки?
[38:43.000 --> 38:45.000]  Каким образом это надо сохранить?
[38:45.000 --> 38:47.000]  Какие у вас будут предложения?
[38:47.000 --> 38:49.000]  Ну, нам нужно найти,
[38:49.000 --> 38:51.000]  как мы можем взять,
[38:51.000 --> 38:53.000]  написать какой-нибудь интерфейс
[38:53.000 --> 38:55.000]  или
[38:55.000 --> 38:57.000]  просто написать
[38:57.000 --> 38:59.000]  указательную...
[38:59.000 --> 39:01.000]  Интерфейс. Мне нравится предложение.
[39:01.000 --> 39:03.000]  Давайте подумаем.
[39:03.000 --> 39:05.000]  Необходимую семантику.
[39:05.000 --> 39:07.000]  Мы...
[39:07.000 --> 39:09.000]  Ну, вот...
[39:09.000 --> 39:11.000]  Здесь у нас будет какой-нибудь
[39:11.000 --> 39:13.000]  интерфейс. Мы сейчас не точим,
[39:13.000 --> 39:15.000]  какое именно. И тогда мы можем
[39:15.000 --> 39:17.000]  написать какой-нибудь класс
[39:17.000 --> 39:19.000]  с шаблонным параметром
[39:19.000 --> 39:21.000]  видефункция, который конструируется
[39:21.000 --> 39:23.000]  в шаблонных полях. И нас следует
[39:23.000 --> 39:25.000]  вот этот интерфейс.
[39:25.000 --> 39:27.000]  Это правильное решение.
[39:27.000 --> 39:29.000]  Поднимите руку, если вы поняли.
[39:31.000 --> 39:33.000]  Ну, вот.
[39:33.000 --> 39:35.000]  Кажется, не все
[39:35.000 --> 39:37.000]  поняли.
[39:37.000 --> 39:39.000]  Да, зачем интерфейс не ясно?
[39:39.000 --> 39:41.000]  А это легко замотивировать.
[39:41.000 --> 39:43.000]  Мы собрались хранить произвольную F.
[39:43.000 --> 39:45.000]  Все, что мы об этой F знаем, а мы пока
[39:45.000 --> 39:47.000]  ничего не знаем, давайте потребуем
[39:47.000 --> 39:49.000]  кое-что от нее.
[39:51.000 --> 39:53.000]  Мы потребуем, чтобы она
[39:53.000 --> 39:55.000]  инвокабл была.
[39:59.000 --> 40:01.000]  Вот ARKS.
[40:01.000 --> 40:03.000]  Чтобы это был
[40:03.000 --> 40:05.000]  такой тип, функциональный,
[40:05.000 --> 40:07.000]  который можно вызвать.
[40:07.000 --> 40:09.000]  Здесь ошибки были.
[40:09.000 --> 40:11.000]  Сейчас.
[40:11.000 --> 40:13.000]  Мы требовали, чтобы ее можно было вызвать
[40:13.000 --> 40:15.000]  от ARKS, а потом выводим
[40:15.000 --> 40:17.000]  эти самые
[40:17.000 --> 40:19.000]  ARKS и так же гляньте.
[40:21.000 --> 40:23.000]  Спасибо.
[40:27.000 --> 40:29.000]  Видимо, просто нет концепта с ретерном.
[40:29.000 --> 40:31.000]  Ну,
[40:31.000 --> 40:33.000]  ладно. Сойдет.
[40:33.000 --> 40:35.000]  То есть мы что-то требуем, но это
[40:35.000 --> 40:37.000]  требование будет потом проверяться.
[40:37.000 --> 40:39.000]  В самом конце.
[40:39.000 --> 40:41.000]  Вот этот дедакшн гайд не привязан
[40:41.000 --> 40:43.000]  к этому конструктору.
[40:43.000 --> 40:45.000]  Дедакшн гайды запускаются еще
[40:45.000 --> 40:47.000]  до того, как какие-то конструкторы где-то
[40:47.000 --> 40:49.000]  искать.
[40:49.000 --> 40:51.000]  Очень нормально.
[41:15.000 --> 41:17.000]  Да не должно работать, блин. Я такой код
[41:17.000 --> 41:19.000]  примерно писал, он работал.
[41:19.000 --> 41:21.000]  Наверное, там бага был, но его пофиксить должны были.
[41:21.000 --> 41:23.000]  Либо не знаю.
[41:23.000 --> 41:25.000]  Увидим.
[41:25.000 --> 41:27.000]  Что мы хотим сделать на самом деле?
[41:27.000 --> 41:29.000]  Мы хотим вот этот вот объект типа F
[41:29.000 --> 41:31.000]  сохранить в поле.
[41:31.000 --> 41:33.000]  Все, что мы хотим.
[41:33.000 --> 41:35.000]  Можем ли мы это сделать? Почему красно
[41:35.000 --> 41:37.000]  обугается?
[41:41.000 --> 41:43.000]  Вот тип этот F
[41:43.000 --> 41:45.000]  известен только в рамках конструктора.
[41:45.000 --> 41:47.000]  В рамках самого шаблона класса
[41:47.000 --> 41:49.000]  неизвестно, какой F мы храним.
[41:49.000 --> 41:51.000]  Вот его стереть надо, да?
[41:51.000 --> 41:53.000]  Стодайни это прекрасная идея,
[41:53.000 --> 41:55.000]  только мы руками хотим написать.
[41:57.000 --> 41:59.000]  Прекрасно. Давайте сделаем
[41:59.000 --> 42:01.000]  шаблонный стордж.
[42:09.000 --> 42:11.000]  Это поможет в принципе.
[42:11.000 --> 42:13.000]  Ну, не важно.
[42:15.000 --> 42:17.000]  Стордж.
[42:17.000 --> 42:19.000]  Стордж будет хранить F.
[42:21.000 --> 42:23.000]  Прямо брать и хранить.
[42:23.000 --> 42:25.000]  Прекрасно.
[42:27.000 --> 42:29.000]  Ну, а как мы сам стордж будем
[42:29.000 --> 42:31.000]  хранить, да? То есть ну...
[42:31.000 --> 42:33.000]  Взять и создать стордж.
[42:33.000 --> 42:35.000]  Это как бы много
[42:35.000 --> 42:37.000]  ума не надо.
[42:37.000 --> 42:39.000]  Т...
[42:39.000 --> 42:41.000]  Наверное, лучше DK, да?
[42:41.000 --> 42:43.000]  DK и T.
[42:43.000 --> 42:45.000]  Да, про всякие рему в референции
[42:45.000 --> 42:47.000]  и DK вам же рассказывали всем уже.
[42:47.000 --> 42:49.000]  Я вот на это не обращаю внимания.
[42:49.000 --> 42:51.000]  Все убирает, чтобы было нормально.
[42:51.000 --> 42:53.000]  Ну да.
[42:53.000 --> 42:55.000]  Такие вещи будем
[42:55.000 --> 42:57.000]  игнорировать.
[42:57.000 --> 42:59.000]  Ну, считать, что все вы уже знаете.
[42:59.000 --> 43:01.000]  Вот можем сделать стордж от F, да?
[43:01.000 --> 43:03.000]  Как его сохранить теперь?
[43:03.000 --> 43:05.000]  Ну, давайте вводить звездочку, что ли.
[43:09.000 --> 43:11.000]  Только уж не вводим звездочку, а скорее
[43:11.000 --> 43:13.000]  какой-нибудь тип
[43:13.000 --> 43:15.000]  или морфон, который вам будет
[43:15.000 --> 43:17.000]  наследоваться, или мы считаем, что это зло?
[43:17.000 --> 43:19.000]  Ну, нет, мы не считаем, что это зло.
[43:19.000 --> 43:21.000]  Это отличная идея, но как-то зачем?
[43:21.000 --> 43:23.000]  Пока идем по пути наименьшего
[43:23.000 --> 43:25.000]  сопротивления.
[43:25.000 --> 43:27.000]  Вопрос теперь. Как у этого
[43:27.000 --> 43:29.000]  сторджа вызвать оператора круглый
[43:29.000 --> 43:31.000]  скоб?
[43:31.000 --> 43:33.000]  Мы же уже забыли, что там лежит внутри.
[43:37.000 --> 43:39.000]  Ну, вот в этот стордж мы
[43:39.000 --> 43:41.000]  запендюрили какую-то F.
[43:41.000 --> 43:43.000]  Типа F.
[43:43.000 --> 43:45.000]  О,
[43:45.000 --> 43:47.000]  это отличная идея.
[43:47.000 --> 43:49.000]  Значит,
[43:49.000 --> 43:51.000]  это первая идея.
[43:51.000 --> 43:53.000]  Ну, вопрос-то понятен в целом.
[43:55.000 --> 43:57.000]  Сейчас
[43:57.000 --> 43:59.000]  обсудим.
[43:59.000 --> 44:01.000]  Сейчас обсудим.
[44:01.000 --> 44:03.000]  Сейчас обсудим, да.
[44:03.000 --> 44:05.000]  А,
[44:05.000 --> 44:07.000]  ну, я считаю, что
[44:07.000 --> 44:09.000]  Дэвид сам разберет.
[44:09.000 --> 44:11.000]  Нет.
[44:11.000 --> 44:13.000]  Вот два человека уже все
[44:13.000 --> 44:15.000]  поняли.
[44:15.000 --> 44:17.000]  Так, давайте на шаг назад.
[44:17.000 --> 44:19.000]  Вы поняли
[44:19.000 --> 44:21.000]  вопрос. Как вызвать оператора
[44:21.000 --> 44:23.000]  круглой скобки? Поняли, зачем его вызвать?
[44:23.000 --> 44:25.000]  Поняли, что лежит в этом, в этой его
[44:25.000 --> 44:27.000]  звездочке? Просто F, который нам
[44:27.000 --> 44:29.000]  прислали изначально.
[44:29.000 --> 44:31.000]  Ну, и тут вопрос. А как вызвать?
[44:31.000 --> 44:33.000]  А ответ на этот вопрос
[44:33.000 --> 44:35.000]  может быть простой, может быть хороший.
[44:35.000 --> 44:37.000]  Простой ответ
[44:37.000 --> 44:39.000]  это вот действительно, как посоветовали.
[44:39.000 --> 44:41.000]  А давайте полиморф на иерархию бахнем.
[44:41.000 --> 44:43.000]  Давайте не поводить
[44:43.000 --> 44:45.000]  звездочки хранить. Это ж плохо.
[44:45.000 --> 44:47.000]  Нам джави учат. Не надо по объекту хранить.
[44:47.000 --> 44:49.000]  Делайте интерфейсы. Мы сделаем
[44:49.000 --> 44:51.000]  интерфейс, а и стордж
[44:53.000 --> 44:55.000]  виртуальный метод будет.
[44:55.000 --> 44:57.000]  Только пока не понятно какой.
[44:57.000 --> 44:59.000]  Ну ладно, нас учат виртуальный
[44:59.000 --> 45:01.000]  диструктор нужен.
[45:01.000 --> 45:03.000]  Сейчас.
[45:03.000 --> 45:05.000]  Там
[45:05.000 --> 45:07.000]  сейчас все будет.
[45:07.000 --> 45:09.000]  Стордж, нужно
[45:09.000 --> 45:11.000]  оверрайдить.
[45:11.000 --> 45:13.000]  Сейчас. Ой.
[45:13.000 --> 45:15.000]  Что-то я.
[45:17.000 --> 45:19.000]  Так, да.
[45:19.000 --> 45:21.000]  Ну вот, там про диструктор
[45:21.000 --> 45:23.000]  у кого-то были сомнения.
[45:23.000 --> 45:25.000]  Вот теперь все нормально будет, да?
[45:25.000 --> 45:27.000]  Потому что тут очевидно, что
[45:27.000 --> 45:29.000]  своей звездочкой мы как-то ошибемся
[45:29.000 --> 45:31.000]  и как вообще диструктора вызвать.
[45:31.000 --> 45:33.000]  Теперь мы будем вот айс стордж.
[45:33.000 --> 45:35.000]  Та же можно в юник
[45:35.000 --> 45:37.000]  поинтер запихнуть.
[45:37.000 --> 45:39.000]  Ну вот,
[45:39.000 --> 45:41.000]  поинтер запихнуть.
[45:41.000 --> 45:43.000]  Тогда все вообще довольны будут.
[45:43.000 --> 45:45.000]  Да.
[45:47.000 --> 45:49.000]  Только айс тордж
[45:49.000 --> 45:51.000]  тоже должен быть шаблоном.
[45:51.000 --> 45:53.000]  Да, тут мы наталкиваемся на проблему.
[45:53.000 --> 45:55.000]  Хочется написать ред, оператор,
[45:55.000 --> 45:57.000]  круглые
[45:57.000 --> 45:59.000]  скобки, аркс.
[45:59.000 --> 46:01.000]  А, давайте кол.
[46:01.000 --> 46:03.000]  Наверное можно написать.
[46:03.000 --> 46:05.000]  Шаблон не дружеский.
[46:05.000 --> 46:07.000]  А, нет.
[46:07.000 --> 46:09.000]  Прекрасно дружит.
[46:09.000 --> 46:11.000]  Ну, поняли, что я хочу написать?
[46:11.000 --> 46:13.000]  Ред и аркс хочу.
[46:13.000 --> 46:15.000]  Которые вот здесь, а их здесь нету.
[46:15.000 --> 46:17.000]  Шаблон засунуть.
[46:17.000 --> 46:19.000]  То есть мы на момент...
[46:19.000 --> 46:21.000]  Айс стордж сможет добавить туда.
[46:21.000 --> 46:23.000]  Давайте просто все
[46:23.000 --> 46:25.000]  впендюрем в шаблон.
[46:25.000 --> 46:27.000]  И ставим.
[46:27.000 --> 46:29.000]  Теперь у нас
[46:29.000 --> 46:31.000]  и айс стордж приматеризован
[46:31.000 --> 46:33.000]  всеми разными сигнатурами,
[46:33.000 --> 46:35.000]  которые нам могут сюда припихнуть.
[46:35.000 --> 46:37.000]  И сам стордж приматеризован
[46:37.000 --> 46:39.000]  разными сигнатурами.
[46:39.000 --> 46:41.000]  Теперь мы можем с чистой совестью
[46:41.000 --> 46:43.000]  заверрадить наш метод
[46:43.000 --> 46:45.000]  col
[46:45.000 --> 46:47.000]  и позвать
[46:47.000 --> 46:49.000]  f круглые скобочки.
[46:53.000 --> 46:55.000]  Ну, тут разумные мысли, конечно,
[46:55.000 --> 46:57.000]  говорят. Абсолютно.
[47:01.000 --> 47:03.000]  Знаете, так-то
[47:03.000 --> 47:05.000]  знаете, так тяжело,
[47:07.000 --> 47:09.000]  когда привык уже писать
[47:09.000 --> 47:11.000]  вместо std ea stl,
[47:13.000 --> 47:15.000]  что да, не нужна.
[47:15.000 --> 47:17.000]  Я прям контролирую
[47:17.000 --> 47:19.000]  свои руки, потому что я очень хочу
[47:19.000 --> 47:21.000]  вот так вот написать.
[47:21.000 --> 47:23.000]  Но нет.
[47:23.000 --> 47:25.000]  Мы пишем по-нормальному.
[47:25.000 --> 47:27.000]  Ea stl.
[47:27.000 --> 47:29.000]  Это замена стандартной
[47:29.000 --> 47:31.000]  библиотеки от Ea, которая работает
[47:31.000 --> 47:33.000]  одинаково на всех платформах.
[47:33.000 --> 47:35.000]  Потому что очень некруто, когда
[47:35.000 --> 47:37.000]  у тебя, казалось бы, одинаковая
[47:37.000 --> 47:39.000]  дистрибуция какой-нибудь libc++
[47:39.000 --> 47:41.000]  на PlayStation и инвенде работает
[47:41.000 --> 47:43.000]  полностью по-разному.
[47:43.000 --> 47:45.000]  Тут этот код не компилируется,
[47:45.000 --> 47:47.000]  тут тот. Тут сортировки
[47:47.000 --> 47:49.000]  алгоритм такой, тут секой.
[47:49.000 --> 47:51.000]  И там, оказывается, перв просел.
[47:51.000 --> 47:53.000]  А тут при таком паттерне
[47:53.000 --> 47:55.000]  использования перв проседает, но уже
[47:55.000 --> 47:57.000]  по-другому. Вот от таких проблем
[47:57.000 --> 47:59.000]  многие в геймдеве просто берут
[47:59.000 --> 48:01.000]  и выкидывают всю стандартную библиотеку
[48:01.000 --> 48:03.000]  и используют
[48:03.000 --> 48:05.000]  кастомную, самописную.
[48:05.000 --> 48:07.000]  Да, в Unreal Engine
[48:07.000 --> 48:09.000]  вообще не стандартная
[48:09.000 --> 48:11.000]  библиотека.
[48:17.000 --> 48:19.000]  Почему не хватает одного указателя
[48:19.000 --> 48:21.000]  на storage? Ну, пока тут был только...
[48:21.000 --> 48:23.000]  Ну, сейчас, на сам storage нельзя.
[48:23.000 --> 48:25.000]  Storage же шаблонный был.
[48:25.000 --> 48:27.000]  Мы же не знаем, какой тип
[48:27.000 --> 48:29.000]  storage у нас.
[48:31.000 --> 48:33.000]  Не знаем, не знаем.
[48:37.000 --> 48:39.000]  И изначально я написал void звездочку.
[48:39.000 --> 48:41.000]  Потому что, ну, раз тип
[48:41.000 --> 48:43.000]  не знаем, запихнем void звездочку.
[48:43.000 --> 48:45.000]  Но тогда мы не знаем
[48:45.000 --> 48:47.000]  никак деструктор позвать, никак оператор
[48:47.000 --> 48:49.000]  круглые скобки.
[48:51.000 --> 48:53.000]  Ну, просто нет способа. Вот тут там
[48:53.000 --> 48:55.000]  подсказали, что можно указатели на функции
[48:55.000 --> 48:57.000]  начать сохранять. Это один путь.
[48:57.000 --> 48:59.000]  Он тоже абсолютно валидный.
[48:59.000 --> 49:01.000]  И даже, я бы сказал, более хороший.
[49:01.000 --> 49:03.000]  Но мы выбрали пока более простой путь.
[49:03.000 --> 49:05.000]  Завести интерфейс
[49:05.000 --> 49:07.000]  и именно в нем
[49:07.000 --> 49:09.000]  орудовать.
[49:09.000 --> 49:11.000]  То есть теперь у нас есть интерфейс
[49:11.000 --> 49:13.000]  в виртуальной иерархии. Там и деструктор,
[49:13.000 --> 49:15.000]  и оператор вызова есть.
[49:15.000 --> 49:17.000]  Вот они для конкретного
[49:17.000 --> 49:19.000]  f реализованы.
[49:19.000 --> 49:21.000]  То есть вот этот тут конкретный storage
[49:21.000 --> 49:23.000]  он параметризован шаблонным параметром,
[49:23.000 --> 49:25.000]  который говорит, что за
[49:29.000 --> 49:31.000]  объект к нам пришел изначально.
[49:31.000 --> 49:33.000]  Но в поле мы
[49:33.000 --> 49:35.000]  сохраняем его
[49:35.000 --> 49:37.000]  по указателю
[49:37.000 --> 49:39.000]  на iStorage.
[49:39.000 --> 49:41.000]  И в этом указателе уже
[49:41.000 --> 49:43.000]  мы не помним,
[49:43.000 --> 49:45.000]  какой был тип f.
[49:47.000 --> 49:49.000]  Но мы все еще можем
[49:49.000 --> 49:51.000]  виртуальные методы вызвать.
[49:53.000 --> 49:55.000]  Соответственно, в деструкторе UnicPtr нам автоматом
[49:55.000 --> 49:57.000]  вызовут виртуальный деструктор, и мы нормально
[49:57.000 --> 49:59.000]  удалим вот этот объект f, каким бы он хитрым ни был.
[49:59.000 --> 50:01.000]  А в операторе круглые скобки
[50:01.000 --> 50:03.000]  мы можем сделать return
[50:03.000 --> 50:05.000]  storage call
[50:07.000 --> 50:09.000]  std forward.arx
[50:13.000 --> 50:15.000]  И я утверждаю, что это в принципе все.
[50:19.000 --> 50:21.000]  Ну кроме одного подвоха.
[50:21.000 --> 50:23.000]  Давайте я вот здесь, чтобы подвоха
[50:23.000 --> 50:25.000]  не возникло, поставлю
[50:25.000 --> 50:27.000]  const ссылку.
[50:27.000 --> 50:29.000]  Так.
[50:29.000 --> 50:31.000]  Хорошо, не const ссылку.
[50:31.000 --> 50:33.000]  Тогда точно никакого подвоха.
[50:35.000 --> 50:37.000]  Код про все эти указатели
[50:37.000 --> 50:39.000]  на поля и функциональные
[50:39.000 --> 50:41.000]  типы, наверное, надо
[50:41.000 --> 50:43.000]  вынести
[50:43.000 --> 50:45.000]  отсюда нафиг.
[50:45.000 --> 50:47.000]  Пусть в новом файле будет.
[50:47.000 --> 50:49.000]  А.
[50:53.000 --> 50:55.000]  Какую ссылку на метод, куда пихнуть?
[51:05.000 --> 51:07.000]  Так, давай конкретный тест
[51:07.000 --> 51:09.000]  писать.
[51:11.000 --> 51:13.000]  Вот это уберем только
[51:13.000 --> 51:15.000]  и вот
[51:15.000 --> 51:17.000]  это уберем.
[51:19.000 --> 51:21.000]  Конкретный тест.
[51:21.000 --> 51:23.000]  Мы...
[51:25.000 --> 51:27.000]  Ok, std vector int
[51:29.000 --> 51:31.000]  vec
[51:39.000 --> 51:41.000]  Мы хотим...
[51:45.000 --> 51:47.000]  По-моему,
[51:47.000 --> 51:49.000]  void,
[51:49.000 --> 51:51.000]  std vector ссылки.
[51:55.000 --> 51:57.000]  Void, std vector int
[51:57.000 --> 51:59.000]  ссылка.
[51:59.000 --> 52:01.000]  Yes.
[52:01.000 --> 52:03.000]  Задает int.
[52:07.000 --> 52:09.000]  Funcrow or
[52:11.000 --> 52:13.000]  Percent, std vector
[52:13.000 --> 52:15.000]  std vector int
[52:23.000 --> 52:25.000]  Причем нужно конкретно ids передать.
[52:25.000 --> 52:27.000]  vec.
[52:27.000 --> 52:29.000]  Вот это имеет смысл.
[52:29.000 --> 52:31.000]  Не, не, не. Или это без vec.
[52:31.000 --> 52:33.000]  А потом function
[52:33.000 --> 52:35.000]  от vec запятает.
[52:35.000 --> 52:37.000]  Ну, function от vec запятает.
[52:37.000 --> 52:39.000]  Ты такое хочешь?
[52:39.000 --> 52:41.000]  Для этого свой, конечно же,
[52:41.000 --> 52:43.000]  кастомный конструктор придется написать.
[52:43.000 --> 52:45.000]  Но
[52:45.000 --> 52:47.000]  я вообще не понимаю, зачем тебе
[52:47.000 --> 52:49.000]  для этого function?
[52:51.000 --> 52:53.000]  Ну, окей.
[52:55.000 --> 52:57.000]  Сейчас я не туда смотрю. Это какая-то
[52:57.000 --> 52:59.000]  помойка.
[52:59.000 --> 53:01.000]  Ну, кастомный конструктор
[53:01.000 --> 53:03.000]  да, придется написать. Тут будет куча
[53:03.000 --> 53:05.000]  кода. Сейчас вот тут класс
[53:05.000 --> 53:07.000]  red, класс
[53:07.000 --> 53:09.000]  u, класс
[53:09.000 --> 53:11.000]  args.
[53:11.000 --> 53:13.000]  Причем не, не, не. Все, я вру.
[53:13.000 --> 53:15.000]  Только u будет, да?
[53:15.000 --> 53:17.000]  Мы хотим принять
[53:17.000 --> 53:19.000]  red
[53:23.000 --> 53:25.000]  вот такую шнягу.
[53:27.000 --> 53:29.000]  Заметьте, где
[53:29.000 --> 53:31.000]  пишется имя аргумента, когда вы
[53:31.000 --> 53:33.000]  передаете указатель
[53:33.000 --> 53:35.000]  на member function
[53:35.000 --> 53:37.000]  как аргумент в другую функцию.
[53:37.000 --> 53:39.000]  А при этом, если я сделаю type desk,
[53:39.000 --> 53:41.000]  то все нормально становится.
[53:41.000 --> 53:43.000]  Да, поэтому...
[53:43.000 --> 53:45.000]  Ну, тут по-другому не особо это.
[53:45.000 --> 53:47.000]  Короче, вот мы передали pointer
[53:47.000 --> 53:49.000]  to member и хотим
[53:49.000 --> 53:51.000]  что-то сохранить, да?
[53:51.000 --> 53:53.000]  Кстати, вот это вот я бы даже
[53:53.000 --> 53:55.000]  выпилил, наверное, отсюда. Там же
[53:55.000 --> 53:57.000]  вывод работает. Все должно само.
[53:57.000 --> 53:59.000]  Ну, знаете,
[53:59.000 --> 54:01.000]  что я сделал?
[54:07.000 --> 54:09.000]  Я вот так сделаю просто.
[54:09.000 --> 54:11.000]  Этот pointer
[54:11.000 --> 54:13.000]  to member сюда захвачу.
[54:15.000 --> 54:17.000]  Да, да,
[54:17.000 --> 54:19.000]  да, да, да.
[54:19.000 --> 54:21.000]  Окей.
[54:27.000 --> 54:29.000]  Да, все.
[54:31.000 --> 54:33.000]  Да.
[54:33.000 --> 54:35.000]  self pointer to member
[54:35.000 --> 54:37.000]  straight,
[54:37.000 --> 54:39.000]  forward.
[54:43.000 --> 54:45.000]  Нет, там
[54:45.000 --> 54:47.000]  был запрос, что именно
[54:47.000 --> 54:49.000]  вот такая вот шняга.
[54:49.000 --> 54:51.000]  Я такого... Это есть
[54:51.000 --> 54:53.000]  стандартная библиотека или нет? Я не в курсе.
[54:57.000 --> 54:59.000]  Вот так и return.
[54:59.000 --> 55:01.000]  Ну, то есть вот.
[55:01.000 --> 55:03.000]  Ну, такое можно сделать, но зачем?
[55:05.000 --> 55:07.000]  Давайте проверим, что оно работает
[55:07.000 --> 55:09.000]  все-таки напоследок.
[55:11.000 --> 55:13.000]  Не работает, да?
[55:19.000 --> 55:21.000]  Кто может понять, что не так
[55:21.000 --> 55:23.000]  пошло?
[55:25.000 --> 55:27.000]  Copy constructor,
[55:27.000 --> 55:29.000]  off constructor.
[55:29.000 --> 55:31.000]  Ой, там же еще нужно писать перегрузки на тему того, что это может быть
[55:31.000 --> 55:33.000]  const, может быть
[55:33.000 --> 55:35.000]  2 сутки, тогда.
[55:35.000 --> 55:37.000]  Про это сейчас поговорим.
[55:37.000 --> 55:39.000]  Но тут я не уверен, в чем проблема,
[55:39.000 --> 55:41.000]  тут, возможно, в этом, да, или в чем?
[55:43.000 --> 55:45.000]  Couldn't infer template argument
[55:45.000 --> 55:47.000]  U.
[55:51.000 --> 55:53.000]  U не смог вывести.
[55:53.000 --> 55:55.000]  Да, вы шутите.
[55:57.000 --> 55:59.000]  Возможно, проблема в
[55:59.000 --> 56:01.000]  чем-то таком
[56:01.000 --> 56:03.000]  дурацком. Нет, нет.
[56:13.000 --> 56:15.000]  Нет, тут пока даже до дедакшн гайда,
[56:15.000 --> 56:17.000]  ну, тут я указал явный тип,
[56:17.000 --> 56:19.000]  дедакшн гайд не нужен.
[56:29.000 --> 56:31.000]  Сейчас, может, я просто
[56:31.000 --> 56:33.000]  наткнулся на most vexing pars,
[56:33.000 --> 56:35.000]  нет, не угадал.
[56:41.000 --> 56:43.000]  Почему?
[56:43.000 --> 56:45.000]  Ну,
[56:45.000 --> 56:47.000]  давайте посмотрим.
[56:47.000 --> 56:49.000]  Может, там
[56:49.000 --> 56:51.000]  будут проблемы,
[56:51.000 --> 56:53.000]  да, указатель на member
[56:53.000 --> 56:55.000]  наследуется от другого
[56:55.000 --> 56:57.000]  типа, от Bayza.
[56:57.000 --> 56:59.000]  Указатель на member
[56:59.000 --> 57:01.000]  наследуется от Bayza.
[57:01.000 --> 57:03.000]  От класса, в котором
[57:03.000 --> 57:05.000]  наследуется.
[57:05.000 --> 57:07.000]  Ну, да, будут проблемы, ну, какие,
[57:07.000 --> 57:09.000]  я боюсь представить.
[57:09.000 --> 57:11.000]  Нет, ну, в целом, вот где это мы сейчас?
[57:13.000 --> 57:15.000]  Тут есть pair value,
[57:15.000 --> 57:17.000]  pair value.
[57:21.000 --> 57:23.000]  Блин, а у меня здесь не стоит
[57:23.000 --> 57:25.000]  расширение, да?
[57:25.000 --> 57:27.000]  Черт, которое.
[57:27.000 --> 57:29.000]  Может, посмотрим с size,
[57:29.000 --> 57:31.000]  потому что там понятно.
[57:31.000 --> 57:33.000]  А, мы прямо внутри вектора, все нормально.
[57:33.000 --> 57:35.000]  Да, вот тут показывают,
[57:35.000 --> 57:37.000]  мы внутри вектора, это не из родителей пришло.
[57:37.000 --> 57:39.000]  Ну, я не знаю.
[57:39.000 --> 57:41.000]  Может, для size попробуем?
[57:41.000 --> 57:43.000]  Может, на size?
[57:43.000 --> 57:45.000]  Ну, давай.
[57:45.000 --> 57:47.000]  Я не готовился такие вещи смотреть.
[57:47.000 --> 57:49.000]  Это, конечно, забавно.
[57:49.000 --> 57:51.000]  Сейчас
[57:51.000 --> 57:53.000]  size только void должен...
[57:53.000 --> 57:55.000]  А, ну, что-то фигня, да, сразу пошла.
[57:57.000 --> 57:59.000]  Но это плохо, кстати, что у нас
[57:59.000 --> 58:01.000]  компилировался код, который
[58:01.000 --> 58:03.000]  я тут void написал,
[58:03.000 --> 58:05.000]  а там был size t.
[58:05.000 --> 58:07.000]  Давайте запустим наконец-то.
[58:07.000 --> 58:09.000]  Прекратим все это безобразие.
[58:13.000 --> 58:17.000]  And sign long.
[58:17.000 --> 58:19.000]  Ah, constantly accept.
[58:21.000 --> 58:23.000]  Ну, вот мы, короче, наткнулись на проблемы
[58:23.000 --> 58:25.000]  с constantly accept.
[58:29.000 --> 58:31.000]  Предлагаю пока под ковер, окей?
[58:31.000 --> 58:33.000]  Вот это вот момент,
[58:33.000 --> 58:35.000]  хотя или сейчас пришло уже время,
[58:35.000 --> 58:37.000]  у нас 15 минут остается, да?
[58:37.000 --> 58:39.000]  Давайте тогда сначала
[58:39.000 --> 58:41.000]  из пушки альтернативное
[58:41.000 --> 58:43.000]  решение вот этому, которое вам уже, видимо,
[58:43.000 --> 58:45.000]  дома придется. А, или мы на следующем
[58:45.000 --> 58:47.000]  паре продолжим
[58:47.000 --> 58:49.000]  наши развлечения, мы будем писать
[58:49.000 --> 58:51.000]  из стд n, но
[58:51.000 --> 58:53.000]  через указатели на функции.
[58:59.000 --> 59:01.000]  Ну, с той же целью, что и здесь.
[59:01.000 --> 59:03.000]  Вот есть конструктор,
[59:03.000 --> 59:05.000]  фу, есть
[59:05.000 --> 59:07.000]  деструктор, есть какая-то функция,
[59:07.000 --> 59:09.000]  которую мы стерли.
[59:09.000 --> 59:11.000]  Вот на самом деле, как бы,
[59:11.000 --> 59:13.000]  вот этот вот контейнер структуры
[59:13.000 --> 59:15.000]  данных function, она стирает
[59:15.000 --> 59:17.000]  не только операторы круглые скобки, но и
[59:17.000 --> 59:19.000]  как бы две стираемых функции имеет.
[59:19.000 --> 59:21.000]  Деструктор тоже.
[59:21.000 --> 59:23.000]  Any это контейнер, который стирает
[59:23.000 --> 59:25.000]  только одну функцию, только деструктор.
[59:25.000 --> 59:27.000]  Но, в принципе,
[59:27.000 --> 59:29.000]  имеет смысл
[59:29.000 --> 59:31.000]  писать структуры какие-то
[59:31.000 --> 59:33.000]  хранилища функцион...
[59:33.000 --> 59:35.000]  функций, которые умеют стирать и какие-то
[59:35.000 --> 59:37.000]  другие
[59:37.000 --> 59:39.000]  функции.
[59:39.000 --> 59:41.000]  Если кто-то из вас задумается
[59:41.000 --> 59:43.000]  о том, как работает, например,
[59:43.000 --> 59:45.000]  Rust, то что-то общее
[59:45.000 --> 59:47.000]  нащупывается здесь. Если
[59:47.000 --> 59:49.000]  взять
[59:49.000 --> 59:51.000]  Trade и посмотреть
[59:51.000 --> 59:53.000]  какие там методы упомянуты
[59:53.000 --> 59:55.000]  и написать вот такой класс,
[59:55.000 --> 59:57.000]  который кроме вот этой вот одной функции
[59:57.000 --> 59:59.000]  call будет стирать все методы
[59:59.000 --> 01:00:01.000]  упомянутые в Trade,
[01:00:01.000 --> 01:00:03.000]  то мы, по сути, сделаем Rust на C++.
[01:00:03.000 --> 01:00:05.000]  Ну, я замотивировал
[01:00:05.000 --> 01:00:07.000]  у вас идеи использовать указатели на функции,
[01:00:07.000 --> 01:00:09.000]  потому что вот здесь
[01:00:09.000 --> 01:00:11.000]  не разгуляешься с этими виртуальными,
[01:00:11.000 --> 01:00:13.000]  а с указателями на функциями
[01:00:13.000 --> 01:00:15.000]  там как-то более пластично все,
[01:00:15.000 --> 01:00:17.000]  а еще она работает быстрее.
[01:00:17.000 --> 01:00:19.000]  В некоторых ситуациях в зависимости от того, насколько
[01:00:19.000 --> 01:00:21.000]  прямо рукой вы напишете. А оговорки все
[01:00:21.000 --> 01:00:23.000]  дальше будут.
[01:00:23.000 --> 01:00:25.000]  Да, давайте все дальше это на следующую
[01:00:25.000 --> 01:00:27.000]  пару оставим, а сейчас про консты
[01:00:27.000 --> 01:00:29.000]  и экзепты.
[01:00:29.000 --> 01:00:31.000]  И не только, на самом деле.
[01:00:31.000 --> 01:00:33.000]  Давайте
[01:00:33.000 --> 01:00:35.000]  подумаем про свойства, которые получились
[01:00:35.000 --> 01:00:37.000]  из нашего класса. Нет, сначала мы запустим,
[01:00:37.000 --> 01:00:39.000]  убедимся, что мы написали, а оно работает.
[01:00:43.000 --> 01:00:45.000]  Тут надо вернуть, тут ничего не выводится.
[01:00:47.000 --> 01:00:49.000]  DKT
[01:01:03.000 --> 01:01:05.000]  Что пошло не так?
[01:01:15.000 --> 01:01:17.000]  Я забыл
[01:01:21.000 --> 01:01:23.000]  move, наверное.
[01:01:29.000 --> 01:01:31.000]  Нет.
[01:01:33.000 --> 01:01:35.000]  Пусть будет forward. Тут конечно
[01:01:35.000 --> 01:01:37.000]  непонятно.
[01:01:39.000 --> 01:01:41.000]  Помогите запустить код.
[01:01:41.000 --> 01:01:43.000]  Почитайте ошибки вместе со мной.
[01:01:43.000 --> 01:01:45.000]  Идейно здесь все хорошо. По факту
[01:01:45.000 --> 01:01:47.000]  начало что-то крашиться.
[01:01:47.000 --> 01:01:49.000]  Не компилироваться, в смысле.
[01:01:49.000 --> 01:01:51.000]  Да я в storage не могу запихнуть F.
[01:01:55.000 --> 01:01:57.000]  Ну, кстати, да, скорее всего оно
[01:01:57.000 --> 01:01:59.000]  функциональный, хотя нет.
[01:01:59.000 --> 01:02:01.000]  Нет, это для...
[01:02:05.000 --> 01:02:07.000]  Так, структура,
[01:02:07.000 --> 01:02:09.000]  в ней поле типа F.
[01:02:09.000 --> 01:02:11.000]  Надо снять референс.
[01:02:11.000 --> 01:02:13.000]  Надо.
[01:02:15.000 --> 01:02:17.000]  А даже
[01:02:17.000 --> 01:02:19.000]  вот так надо.
[01:02:19.000 --> 01:02:21.000]  Окей.
[01:02:23.000 --> 01:02:25.000]  Ничего не получилось.
[01:02:25.000 --> 01:02:27.000]  Ничего не получилось.
[01:02:51.000 --> 01:02:53.000]  По ходу, да.
[01:02:55.000 --> 01:02:57.000]  F
[01:02:57.000 --> 01:02:59.000]  все.
[01:03:01.000 --> 01:03:03.000]  Тогда
[01:03:03.000 --> 01:03:05.000]  можно иди.
[01:03:07.000 --> 01:03:09.000]  Кажется, так надо,
[01:03:09.000 --> 01:03:11.000]  чтобы у нас ничего не сломалось.
[01:03:21.000 --> 01:03:23.000]  Сейчас это вообще нужно указывать
[01:03:23.000 --> 01:03:25.000]  F.
[01:03:37.000 --> 01:03:39.000]  Ну да, правильно.
[01:03:39.000 --> 01:03:41.000]  То, что надо вот так.
[01:03:43.000 --> 01:03:45.000]  Нет, стоп.
[01:03:47.000 --> 01:03:49.000]  Кто помнит, как
[01:03:49.000 --> 01:03:51.000]  его сделать полиморфным?
[01:03:53.000 --> 01:03:55.000]  Кто не помнит, да?
[01:03:55.000 --> 01:03:57.000]  Но он пытается вызвать
[01:03:57.000 --> 01:03:59.000]  деструктор никак,
[01:03:59.000 --> 01:04:01.000]  но не полиморфный, короче.
[01:04:03.000 --> 01:04:05.000]  Давайте.
[01:04:23.000 --> 01:04:25.000]  Это конструктор.
[01:04:25.000 --> 01:04:27.000]  Нет оператора присваивания,
[01:04:27.000 --> 01:04:29.000]  ни муба, ни копирования, ничего,
[01:04:29.000 --> 01:04:31.000]  нету, все.
[01:04:31.000 --> 01:04:33.000]  Деструктор.
[01:04:33.000 --> 01:04:35.000]  Делит.
[01:04:35.000 --> 01:04:37.000]  Так, что не так?
[01:04:45.000 --> 01:04:47.000]  Потому что
[01:04:47.000 --> 01:04:49.000]  наследник вызывает
[01:04:49.000 --> 01:04:51.000]  еще деструктора
[01:04:51.000 --> 01:04:53.000]  и не теряет.
[01:04:53.000 --> 01:04:55.000]  Какая-то интерфейс.
[01:04:55.000 --> 01:04:57.000]  Это классический ход
[01:04:57.000 --> 01:04:59.000]  у Qwitch
[01:04:59.000 --> 01:05:01.000]  с трактами.
[01:05:01.000 --> 01:05:03.000]  Но зачем Qwitch делать,
[01:05:03.000 --> 01:05:05.000]  чтобы
[01:05:05.000 --> 01:05:07.000]  все работает
[01:05:07.000 --> 01:05:09.000]  должно?
[01:05:15.000 --> 01:05:17.000]  Обожаю C++.
[01:05:17.000 --> 01:05:19.000]  В прошлом году тот же код писался и работал
[01:05:19.000 --> 01:05:21.000]  с первого раза, а тут началось.
[01:05:21.000 --> 01:05:23.000]  Что?
[01:05:35.000 --> 01:05:37.000]  Я подозреваю,
[01:05:37.000 --> 01:05:39.000]  что от того, что я вот здесь пишу,
[01:05:39.000 --> 01:05:41.000]  вероятно не virtual.
[01:05:41.000 --> 01:05:43.000]  Должно, но я
[01:05:43.000 --> 01:05:45.000]  не верю.
[01:05:45.000 --> 01:05:47.000]  Ладно.
[01:05:49.000 --> 01:05:51.000]  Я вот так даже сделал.
[01:05:51.000 --> 01:05:53.000]  Да, родительский.
[01:06:01.000 --> 01:06:03.000]  Я просто поражен тем,
[01:06:03.000 --> 01:06:05.000]  что происходит, если мы словили баг компилятора,
[01:06:05.000 --> 01:06:07.000]  то это...
[01:06:07.000 --> 01:06:09.000]  Это прекрасно.
[01:06:11.000 --> 01:06:13.000]  Ну так заработает, я не знаю.
[01:06:15.000 --> 01:06:17.000]  Ну я не знаю,
[01:06:17.000 --> 01:06:19.000]  я, честно, такой же код в прошлый раз.
[01:06:19.000 --> 01:06:21.000]  А можно сделать
[01:06:21.000 --> 01:06:23.000]  это out-of-line
[01:06:23.000 --> 01:06:25.000]  дефиницию Qwitch-деструктора.
[01:06:25.000 --> 01:06:27.000]  Ну, смотри,
[01:06:27.000 --> 01:06:29.000]  написать равно 0 и дальше прямо под ним...
[01:06:29.000 --> 01:06:31.000]  А дальше все такие пальмы обычно...
[01:06:31.000 --> 01:06:33.000]  Да нет, прямо под ним можно просто
[01:06:33.000 --> 01:06:35.000]  i-storage и до i-storage
[01:06:35.000 --> 01:06:37.000]  и сказать, что ничего не делает.
[01:06:39.000 --> 01:06:41.000]  Можно попробовать.
[01:06:41.000 --> 01:06:43.000]  Здесь 0,
[01:06:43.000 --> 01:06:45.000]  затем...
[01:06:47.000 --> 01:06:49.000]  У меня так не работает, да?
[01:06:49.000 --> 01:06:51.000]  Нет, ну я предлагаю out-of-line
[01:06:51.000 --> 01:06:53.000]  вот дефинировать, просто прям
[01:06:53.000 --> 01:06:55.000]  дефинировать. Ну как его можно делать?
[01:06:55.000 --> 01:06:57.000]  Ладно.
[01:06:57.000 --> 01:06:59.000]  Что, чтобы так?
[01:07:01.000 --> 01:07:03.000]  Да, и тут
[01:07:03.000 --> 01:07:05.000]  его просто
[01:07:05.000 --> 01:07:07.000]  не только virtual, наверное, выбрать.
[01:07:09.000 --> 01:07:11.000]  И здесь не равно 0.
[01:07:11.000 --> 01:07:13.000]  Я фигурую с помычки.
[01:07:13.000 --> 01:07:15.000]  Вместо 1 0.
[01:07:17.000 --> 01:07:19.000]  Ну, мы внутри
[01:07:19.000 --> 01:07:21.000]  другого класса, напоминаю, находимся,
[01:07:21.000 --> 01:07:23.000]  от этого, возможно, у нас все ломается.
[01:07:23.000 --> 01:07:25.000]  Тут как?
[01:07:25.000 --> 01:07:27.000]  Ну, короче, ничего не выйдет, все.
[01:07:27.000 --> 01:07:29.000]  Мы как-то заставили работать.
[01:07:31.000 --> 01:07:33.000]  Тут все ужасно, да.
[01:07:41.000 --> 01:07:43.000]  Так, что произошло?
[01:07:47.000 --> 01:07:49.000]  Все зарешилось.
[01:07:49.000 --> 01:07:51.000]  Почему все зарешилось?
[01:07:51.000 --> 01:07:53.000]  О, смотрите, hello, hello.
[01:07:53.000 --> 01:07:55.000]  Что-то написало.
[01:07:55.000 --> 01:07:57.000]  Я предполагаю, что это значит, что
[01:07:57.000 --> 01:07:59.000]  все работает.
[01:08:01.000 --> 01:08:03.000]  То есть что мы...
[01:08:03.000 --> 01:08:05.000]  HelloFromStruct и hello
[01:08:05.000 --> 01:08:07.000]  1 раз про этот.
[01:08:07.000 --> 01:08:09.000]  А helloFromStruct, вот он
[01:08:09.000 --> 01:08:11.000]  здесь.
[01:08:11.000 --> 01:08:13.000]  А вот здесь мы 2 раза вызываем f,
[01:08:13.000 --> 01:08:15.000]  да?
[01:08:15.000 --> 01:08:17.000]  Но там вот этот вот костылек, который
[01:08:17.000 --> 01:08:19.000]  запоминает, что там нас 1 раз вызвали
[01:08:19.000 --> 01:08:21.000]  или 2.
[01:08:21.000 --> 01:08:23.000]  Все работает, ура.
[01:08:23.000 --> 01:08:25.000]  То есть типа function, сверх легко
[01:08:25.000 --> 01:08:27.000]  написать в минимальном виде.
[01:08:27.000 --> 01:08:29.000]  Но нас не устраивает.
[01:08:29.000 --> 01:08:31.000]  Раз по перву,
[01:08:31.000 --> 01:08:33.000]  а два, такой смешной
[01:08:33.000 --> 01:08:35.000]  вопрос.
[01:08:37.000 --> 01:08:39.000]  Если вот этот
[01:08:39.000 --> 01:08:41.000]  оператор const, внимание,
[01:08:41.000 --> 01:08:43.000]  важный вопрос решается,
[01:08:43.000 --> 01:08:45.000]  важнейший.
[01:08:45.000 --> 01:08:47.000]  Если оператор круглой скобки был const
[01:08:47.000 --> 01:08:49.000]  object,
[01:08:49.000 --> 01:08:51.000]  хотим ли мы...
[01:08:51.000 --> 01:08:53.000]  Ну, и
[01:08:53.000 --> 01:08:55.000]  наоборот, если он был не
[01:08:55.000 --> 01:08:57.000]  const, вот такой, да,
[01:08:57.000 --> 01:08:59.000]  хотим ли мы позволять
[01:08:59.000 --> 01:09:01.000]  запускать
[01:09:01.000 --> 01:09:03.000]  по const ссылке?
[01:09:03.000 --> 01:09:05.000]  Вот даже если
[01:09:05.000 --> 01:09:07.000]  так написать, то уже у нас
[01:09:07.000 --> 01:09:09.000]  вот этот оператор круглой скобки, он не
[01:09:09.000 --> 01:09:11.000]  const.
[01:09:11.000 --> 01:09:13.000]  Ну,
[01:09:13.000 --> 01:09:15.000]  какая-то
[01:09:15.000 --> 01:09:17.000]  несогласованность вы чувствуете?
[01:09:17.000 --> 01:09:19.000]  Вот здесь оператор может быть const,
[01:09:19.000 --> 01:09:21.000]  а может быть не const. И это часть
[01:09:21.000 --> 01:09:23.000]  сигнатуры. А вот здесь
[01:09:23.000 --> 01:09:25.000]  у нас он всегда просто вот такой.
[01:09:25.000 --> 01:09:27.000]  Либо const,
[01:09:27.000 --> 01:09:29.000]  либо не const.
[01:09:29.000 --> 01:09:31.000]  Фигня, да?
[01:09:31.000 --> 01:09:33.000]  Это, наверное, pointer to number type
[01:09:33.000 --> 01:09:35.000]  или
[01:09:35.000 --> 01:09:37.000]  что у const
[01:09:37.000 --> 01:09:39.000]  владеется тип класса, наверное,
[01:09:39.000 --> 01:09:41.000]  t, а const...
[01:09:41.000 --> 01:09:43.000]  Ну, сейчас правильный ответ-то скажу.
[01:09:43.000 --> 01:09:45.000]  Я просто хочу
[01:09:45.000 --> 01:09:47.000]  void.int
[01:09:47.000 --> 01:09:49.000]  хочу вас
[01:09:49.000 --> 01:09:51.000]  обрадовать, что это баг в стандартной
[01:09:51.000 --> 01:09:53.000]  библиотеке.
[01:09:53.000 --> 01:09:55.000]  Вернее, в ее дизайне.
[01:09:57.000 --> 01:09:59.000]  Так.
[01:10:01.000 --> 01:10:03.000]  Bad.
[01:10:03.000 --> 01:10:05.000]  Bad инициализируем
[01:10:05.000 --> 01:10:07.000]  functional object.
[01:10:09.000 --> 01:10:11.000]  И
[01:10:13.000 --> 01:10:15.000]  сделаем
[01:10:15.000 --> 01:10:17.000]  const ссылку.
[01:10:19.000 --> 01:10:21.000]  Very bad.
[01:10:31.000 --> 01:10:33.000]  Так, внимание, так не работает.
[01:10:35.000 --> 01:10:37.000]  Что?
[01:10:37.000 --> 01:10:39.000]  Да.
[01:10:39.000 --> 01:10:41.000]  Вот, все так работает.
[01:10:41.000 --> 01:10:43.000]  Видите нарушение
[01:10:43.000 --> 01:10:45.000]  const-корректности?
[01:10:49.000 --> 01:10:51.000]  Примерно поэтому, да.
[01:10:51.000 --> 01:10:53.000]  Нет, вот эта вот фигня хранит состояние
[01:10:53.000 --> 01:10:55.000]  в себе.
[01:10:55.000 --> 01:10:57.000]  Вот точно так же,
[01:10:57.000 --> 01:10:59.000]  как functional object. Вот он внутри себя
[01:10:59.000 --> 01:11:01.000]  какое-то состояние мог хранить.
[01:11:01.000 --> 01:11:03.000]  И вот эта функция, она не const, она могла
[01:11:03.000 --> 01:11:05.000]  модифицировать это состояние.
[01:11:05.000 --> 01:11:07.000]  Ну окей, нам с неба свалилась
[01:11:07.000 --> 01:11:09.000]  вот эта вот ссылка, very bad.
[01:11:09.000 --> 01:11:11.000]  const ссылка, да.
[01:11:11.000 --> 01:11:13.000]  И мы вызываем в нее оператора круглой
[01:11:13.000 --> 01:11:15.000]  скобки, который const.
[01:11:15.000 --> 01:11:17.000]  Вот он const же, да.
[01:11:17.000 --> 01:11:19.000]  Но мы верим, значит, что он не будет модифицировать
[01:11:19.000 --> 01:11:21.000]  состояние, а он его модифицирует.
[01:11:21.000 --> 01:11:23.000]  Полное нарушение
[01:11:23.000 --> 01:11:25.000]  const-корректности.
[01:11:25.000 --> 01:11:27.000]  Правильный fix.
[01:11:27.000 --> 01:11:29.000]  Явно в сигнатуру
[01:11:29.000 --> 01:11:31.000]  прописывать const или не const.
[01:11:31.000 --> 01:11:33.000]  Вот стандартная
[01:11:33.000 --> 01:11:35.000]  улучшен не умеет так.
[01:11:35.000 --> 01:11:37.000]  Просто не догадались.
[01:11:37.000 --> 01:11:39.000]  Да, может быть возникнет
[01:11:39.000 --> 01:11:41.000]  вопрос, да, что вот это такое?
[01:11:41.000 --> 01:11:43.000]  Ну вы же знаете, как мы в конце
[01:11:43.000 --> 01:11:45.000]  методов можем писать const
[01:11:45.000 --> 01:11:47.000]  или ampersand, или twampersand,
[01:11:47.000 --> 01:11:49.000]  или volatile.
[01:11:49.000 --> 01:11:51.000]  Все же это знают.
[01:11:55.000 --> 01:11:57.000]  Что?
[01:11:57.000 --> 01:11:59.000]  Да, но это abus.
[01:11:59.000 --> 01:12:01.000]  Потому что оказывается
[01:12:01.000 --> 01:12:03.000]  в системе типов языка C++
[01:12:05.000 --> 01:12:07.000]  вот это вот const можно дописать
[01:12:07.000 --> 01:12:09.000]  к любому типу функции.
[01:12:09.000 --> 01:12:11.000]  То есть нельзя написать глобальную функцию,
[01:12:11.000 --> 01:12:13.000]  которая const.
[01:12:13.000 --> 01:12:15.000]  Но вот это слово const справа дописать
[01:12:15.000 --> 01:12:17.000]  можно к любому типу функции.
[01:12:17.000 --> 01:12:19.000]  Я говорю, как к любому типу?
[01:12:19.000 --> 01:12:21.000]  Потому что int const есть, да?
[01:12:21.000 --> 01:12:23.000]  Да, вот
[01:12:23.000 --> 01:12:25.000]  раз есть int,
[01:12:25.000 --> 01:12:27.000]  есть int const.
[01:12:27.000 --> 01:12:29.000]  Но у нас есть вот
[01:12:29.000 --> 01:12:31.000]  void от int тогда, да?
[01:12:31.000 --> 01:12:33.000]  Почему не должно быть void от int const?
[01:12:37.000 --> 01:12:39.000]  Ну как бы на самом деле нет.
[01:12:39.000 --> 01:12:41.000]  Потому что вот это вот это не то же самое,
[01:12:41.000 --> 01:12:43.000]  что и...
[01:12:43.000 --> 01:12:45.000]  Ну вот так можно.
[01:12:45.000 --> 01:12:47.000]  Примите это как данность.
[01:12:49.000 --> 01:12:51.000]  И хак заключается в том, чтобы
[01:12:51.000 --> 01:12:53.000]  повторять в операторе круглая скобка
[01:12:53.000 --> 01:12:55.000]  нашего вот этого вот
[01:12:55.000 --> 01:12:57.000]  функциона,
[01:12:57.000 --> 01:12:59.000]  повторять
[01:12:59.000 --> 01:13:01.000]  все, что написали вот здесь.
[01:13:01.000 --> 01:13:03.000]  То есть должны быть отдельные специализации
[01:13:03.000 --> 01:13:05.000]  для const, для noexcept,
[01:13:05.000 --> 01:13:07.000]  для volatile
[01:13:07.000 --> 01:13:09.000]  noexcept,
[01:13:09.000 --> 01:13:11.000]  const, ну вы поняли, да?
[01:13:15.000 --> 01:13:17.000]  Вопрос, как это написать нормально,
[01:13:17.000 --> 01:13:19.000]  на него пока ответа не дается.
[01:13:19.000 --> 01:13:21.000]  Но идейно...
[01:13:21.000 --> 01:13:23.000]  Аркс при чем тут?
[01:13:27.000 --> 01:13:29.000]  Это не типа, это квалифаеры
[01:13:29.000 --> 01:13:31.000]  в конце
[01:13:31.000 --> 01:13:33.000]  метода.
[01:13:33.000 --> 01:13:35.000]  На нашем методе оператор круглая
[01:13:35.000 --> 01:13:37.000]  скобочка, мы в конец можем написать const.
[01:13:37.000 --> 01:13:39.000]  Что это значит? This, константный.
[01:13:41.000 --> 01:13:43.000]  Можем написать noexcept.
[01:13:43.000 --> 01:13:45.000]  Это значит, что метод не кидает
[01:13:45.000 --> 01:13:47.000]  исключения.
[01:13:49.000 --> 01:13:51.000]  Вот давайте добьем.
[01:13:51.000 --> 01:13:53.000]  Вы поняли, о чем речь идет, правда, товарищи?
[01:13:53.000 --> 01:13:55.000]  Может быть
[01:13:55.000 --> 01:13:57.000]  может быть
[01:13:57.000 --> 01:13:59.000]  функция noexcept.
[01:13:59.000 --> 01:14:01.000]  Да.
[01:14:03.000 --> 01:14:05.000]  Вот const и volatile относятся
[01:14:05.000 --> 01:14:07.000]  к типу this.
[01:14:09.000 --> 01:14:11.000]  Вот volatile const, это this.
[01:14:11.000 --> 01:14:13.000]  Ну, ему не нравится
[01:14:13.000 --> 01:14:15.000]  что-то, да, тут?
[01:14:15.000 --> 01:14:17.000]  А, потому что сначала надо вот это вот,
[01:14:17.000 --> 01:14:19.000]  а потом noexcept. То есть вот это
[01:14:19.000 --> 01:14:21.000]  относится к типу this.
[01:14:21.000 --> 01:14:23.000]  А вот это относится ко всему
[01:14:23.000 --> 01:14:25.000]  функции.
[01:14:25.000 --> 01:14:27.000]  И вот это говорит, что this должен быть
[01:14:27.000 --> 01:14:29.000]  const, вернее будет const, это
[01:14:29.000 --> 01:14:31.000]  говорит, что this будет volatile, а это говорит,
[01:14:31.000 --> 01:14:33.000]  что я не буду кидать исключения.
[01:14:33.000 --> 01:14:35.000]  Вот все эти три штуки и все возможные их
[01:14:35.000 --> 01:14:37.000]  комбинации, их невозможно
[01:14:37.000 --> 01:14:39.000]  знать наперед. Невозможно
[01:14:39.000 --> 01:14:41.000]  угадать, какую пользователь хочет поведение.
[01:14:41.000 --> 01:14:43.000]  Чтобы эта функция можно
[01:14:43.000 --> 01:14:45.000]  была константная или там
[01:14:45.000 --> 01:14:47.000]  не константная, но exeptная или нет.
[01:14:47.000 --> 01:14:49.000]  Наперед неизвестно. Поэтому, поэтому
[01:14:49.000 --> 01:14:51.000]  хороший, правильный дизайн
[01:14:51.000 --> 01:14:53.000]  функционального контейнера
[01:14:53.000 --> 01:14:55.000]  вот такой, что он умеет парсить
[01:14:55.000 --> 01:14:57.000]  вот эти вот const и noexcept, которые
[01:14:57.000 --> 01:14:59.000]  ему передали внутрь
[01:14:59.000 --> 01:15:01.000]  и ставить их на свой
[01:15:01.000 --> 01:15:03.000]  оператор круглые скобки.
[01:15:03.000 --> 01:15:05.000]  Вот.
[01:15:05.000 --> 01:15:07.000]  Значит, где такой хороший контейнер
[01:15:07.000 --> 01:15:09.000]  найти?
[01:15:09.000 --> 01:15:11.000]  Function2.
[01:15:11.000 --> 01:15:13.000]  Вот, если вам с конкарнсом было интересно,
[01:15:13.000 --> 01:15:15.000]  почему нам он так нравится и почему мы его
[01:15:15.000 --> 01:15:17.000]  используем, это одна из причин.
[01:15:17.000 --> 01:15:19.000]  Вот, можете почитать, там круто.
[01:15:21.000 --> 01:15:23.000]  Про
[01:15:23.000 --> 01:15:25.000]  про-про-про-про-про
[01:15:25.000 --> 01:15:27.000]  последний пункт.
[01:15:27.000 --> 01:15:29.000]  Смешную вещь.
[01:15:29.000 --> 01:15:31.000]  Давайте запихнем в
[01:15:31.000 --> 01:15:33.000]  этот
[01:15:33.000 --> 01:15:35.000]  UniquePtr.
[01:15:45.000 --> 01:15:47.000]  Мы неправильно, мы вообще ее не описывали.
[01:15:47.000 --> 01:15:49.000]  Я про STD Function.
[01:15:49.000 --> 01:15:51.000]  Смотрите, что нам скажут.
[01:15:51.000 --> 01:15:53.000]  Нельзя
[01:15:53.000 --> 01:15:55.000]  инициализировать STD Function.
[01:15:55.000 --> 01:15:57.000]  Почему?
[01:15:57.000 --> 01:15:59.000]  Мы пытались копировать
[01:15:59.000 --> 01:16:01.000]  UniquePtr.
[01:16:11.000 --> 01:16:13.000]  Сейчас бы правильную ошибку
[01:16:13.000 --> 01:16:15.000]  еще словить.
[01:16:19.000 --> 01:16:21.000]  Почему IGNORED?
[01:16:21.000 --> 01:16:23.000]  Не говорят нам
[01:16:23.000 --> 01:16:25.000]  даже, да?
[01:16:25.000 --> 01:16:27.000]  Но видите, как нас ненавидит STD Function?
[01:16:27.000 --> 01:16:29.000]  Она даже не объясняет, что не так пошло.
[01:16:29.000 --> 01:16:31.000]  Короче,
[01:16:31.000 --> 01:16:33.000]  если открыть
[01:16:33.000 --> 01:16:35.000]  preference, то мы узнаем гораздо быстрее.
[01:16:35.000 --> 01:16:37.000]  STD Function
[01:16:39.000 --> 01:16:41.000]  Any Copy
[01:16:41.000 --> 01:16:43.000]  Constructible Callable Target.
[01:16:43.000 --> 01:16:45.000]  STD Function
[01:16:45.000 --> 01:16:47.000]  требует, чтобы вашу лямду можно было
[01:16:47.000 --> 01:16:49.000]  не копировать.
[01:16:49.000 --> 01:16:51.000]  Потому что фигово
[01:16:51.000 --> 01:16:53.000]  написано.
[01:16:53.000 --> 01:16:55.000]  Но на самом деле утверждается, что невозможно
[01:16:55.000 --> 01:16:57.000]  написать идеальный Function.
[01:16:57.000 --> 01:16:59.000]  Это просто бредовый дизайн в целом.
[01:16:59.000 --> 01:17:01.000]  Вот вы не знаете
[01:17:01.000 --> 01:17:03.000]  ничего про свой тип F, который
[01:17:03.000 --> 01:17:05.000]  сюда впихивается.
[01:17:05.000 --> 01:17:07.000]  Про вот эту вот лямду или функциональный объект.
[01:17:07.000 --> 01:17:09.000]  Вы не знаете какой там оператор круглой
[01:17:09.000 --> 01:17:11.000]  скобки.
[01:17:11.000 --> 01:17:13.000]  Не знаете.
[01:17:13.000 --> 01:17:15.000]  Так с чего бы вы могли знать, какой он будет
[01:17:15.000 --> 01:17:17.000]  копированный или некопируемый.
[01:17:17.000 --> 01:17:19.000]  Все эти данные вам неизвестны.
[01:17:19.000 --> 01:17:21.000]  На момент создания
[01:17:21.000 --> 01:17:23.000]  самого STD Function.
[01:17:29.000 --> 01:17:31.000]  Вот. И это и есть
[01:17:31.000 --> 01:17:33.000]  правильный ответ. Нужен
[01:17:33.000 --> 01:17:35.000]  Move Only Function
[01:17:35.000 --> 01:17:37.000]  отдельно. И отдельно
[01:17:39.000 --> 01:17:41.000]  Copyable Function.
[01:17:41.000 --> 01:17:43.000]  Это единственный
[01:17:43.000 --> 01:17:45.000]  способ разрешить эту проблему.
[01:17:45.000 --> 01:17:47.000]  И вот тогда будет хорошо.
[01:17:47.000 --> 01:17:49.000]  Но
[01:17:53.000 --> 01:17:55.000]  Как видите, проблему обнаружили
[01:17:55.000 --> 01:17:57.000]  только спустя сколько лет
[01:17:57.000 --> 01:17:59.000]  STD Function
[01:17:59.000 --> 01:18:01.000]  в 11 C++ добавили.
[01:18:01.000 --> 01:18:03.000]  А Move Only Function
[01:18:03.000 --> 01:18:05.000]  в 23.
[01:18:05.000 --> 01:18:07.000]  Типа 12 лет понадобилось, чтобы обнаружить,
[01:18:07.000 --> 01:18:09.000]  что наложали и сделали штуку, которая
[01:18:09.000 --> 01:18:11.000]  в некоторых случаях работает.
[01:18:11.000 --> 01:18:13.000]  Но как только что-то нетривиальное происходит,
[01:18:13.000 --> 01:18:15.000]  сразу выкидывается на помойку и заменяется
[01:18:15.000 --> 01:18:17.000]  какой-нибудь библиотекой сторонней
[01:18:17.000 --> 01:18:19.000]  или своей костыльной имплементацией.
[01:18:19.000 --> 01:18:21.000]  Вот. Move Only Function
[01:18:21.000 --> 01:18:23.000]  как можно догадаться
[01:18:23.000 --> 01:18:25.000]  из названия, лямбда, передающаяся
[01:18:25.000 --> 01:18:27.000]  туда, не обязана копироваться.
[01:18:27.000 --> 01:18:29.000]  И тогда сама вот эта
[01:18:29.000 --> 01:18:31.000]  функция будет только муваться.
[01:18:31.000 --> 01:18:33.000]  И есть
[01:18:33.000 --> 01:18:35.000]  STD Copyable
[01:18:37.000 --> 01:18:39.000]  Function.
[01:18:39.000 --> 01:18:41.000]  Которую в 26-ые плюсы одобрили,
[01:18:41.000 --> 01:18:43.000]  но еще на ЦП референс не добавили.
[01:18:43.000 --> 01:18:45.000]  Вот.
[01:18:45.000 --> 01:18:47.000]  Ну Copyable Function это аналог STD Function,
[01:18:47.000 --> 01:18:49.000]  но который правильно консткорректность
[01:18:49.000 --> 01:18:51.000]  учитывает, да, потому что
[01:18:51.000 --> 01:18:53.000]  вот так можно короче делать,
[01:18:53.000 --> 01:18:55.000]  оно правильно работает. В этом
[01:18:55.000 --> 01:18:57.000]  Move Only Function это тоже учли.
[01:18:57.000 --> 01:18:59.000]  Вот. И вот это вот,
[01:18:59.000 --> 01:19:01.000]  мне кажется, квинтэссенция вообще разговоров
[01:19:01.000 --> 01:19:03.000]  о том, как должны выглядеть
[01:19:03.000 --> 01:19:05.000]  вот эти обертки над функциональными
[01:19:05.000 --> 01:19:07.000]  объектами, стирающие типы. Вот это вот
[01:19:07.000 --> 01:19:09.000]  хороший дизайн, к нему вопросов
[01:19:09.000 --> 01:19:11.000]  нет. К STD Function есть,
[01:19:11.000 --> 01:19:13.000]  а то, что мы написали, это вот просто
[01:19:13.000 --> 01:19:15.000]  жалкое подобие STD Function, которое
[01:19:15.000 --> 01:19:17.000]  а, медленное, b, ну вот все вот эти
[01:19:17.000 --> 01:19:19.000]  проблемы в нем есть.
[01:19:19.000 --> 01:19:21.000]  Так что в следующий раз будем либо
[01:19:21.000 --> 01:19:23.000]  эти проблемы решать, либо ускорять,
[01:19:23.000 --> 01:19:25.000]  либо еще что-нибудь,
[01:19:25.000 --> 01:19:27.000]  может STDE не напишем.
[01:19:27.000 --> 01:19:29.000]  В общем, посмотрим. На сегодня
[01:19:29.000 --> 01:19:31.000]  все.
