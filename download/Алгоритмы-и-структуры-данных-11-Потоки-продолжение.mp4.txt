[00:00.000 --> 00:08.800]  Так, мы продолжим говорить про потоки, давайте сначала
[00:08.800 --> 00:11.960]  доведем до конца Эдмонскарпа, давайте напомню, что мы
[00:11.960 --> 00:12.960]  успели сделать.
[00:12.960 --> 00:28.960]  Мы доказали вторую лему, которая самосодержательная,
[00:28.960 --> 00:31.240]  что в алгоритме Эдмонскарпа каждое ребро насыщается
[00:31.240 --> 00:49.800]  не больше, чем от ВРАС, но отсюда следует, что алгоритм
[00:49.800 --> 00:50.800]  работает за ВЕ квадрат.
[00:50.800 --> 01:05.080]  Почему, ну, смотрите, понятное дело, напомню, что итерация
[01:05.080 --> 01:08.920]  в алгоритме Эдмонскарпа, я называю запуск БФСа плюс
[01:08.920 --> 01:12.080]  пропускание потока по кратчайшему найденному пути.
[01:12.080 --> 01:13.920]  Эдмонскарп работает так, мы многократно делаем
[01:13.920 --> 01:16.520]  итерации, на каждой итерации пускаем поток в той же
[01:16.520 --> 01:17.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:17.520 --> 01:18.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:18.520 --> 01:19.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:19.520 --> 01:20.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:20.520 --> 01:21.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:21.520 --> 01:22.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:22.520 --> 01:23.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:23.520 --> 01:24.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:24.520 --> 01:25.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:25.520 --> 01:26.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:26.520 --> 01:27.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:27.520 --> 01:28.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:28.520 --> 01:29.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:29.520 --> 01:30.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:30.520 --> 01:31.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:31.520 --> 01:32.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:32.520 --> 01:33.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:33.520 --> 01:34.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:34.520 --> 01:35.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:35.520 --> 01:36.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:36.520 --> 01:37.520]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:37.520 --> 01:39.520]  кратчайшем, кратчайшем,
[01:39.520 --> 01:44.020]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:44.020 --> 01:48.300]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:48.300 --> 01:50.900]  кратчайшем, кратчайшем,
[01:50.900 --> 01:55.020]  кратчайшем, кратчайшем, кратчайшем, кратчайшем,
[01:55.020 --> 01:58.260]  кратчайшем, кратчайшем,
[01:58.260 --> 01:59.820]  кратчайшем.
[01:59.820 --> 02:04.580]  Иитает от weniger чем нулёгberg.
[02:04.580 --> 02:06.080]  А сейчас я這裡 소리 звонит,
[02:06.080 --> 02:12.280]  Значит, суммарная итерация от ве, потому что всего
[02:12.280 --> 02:16.200]  е-рёбер, ну два е-рёбер, если мы считаем прямое и обратное,
[02:16.200 --> 02:18.640]  по два раза их надо считать, значит, два е-рёбер, каждое
[02:18.640 --> 02:22.920]  ребро вот столько раз насыщается, значит максимум от ве итерации.
[02:22.920 --> 02:35.340]  Но раз итерации столько, а каждый работает, это просто
[02:35.340 --> 02:38.420]  по сути бфс, ну значит нам нужно число итерации перемножить
[02:38.420 --> 02:42.220]  на время работы бфс, и как раз получается ве квадрат.
[02:42.220 --> 02:46.100]  Напоминаю, мы считаем, что е у нас больше, чем ве,
[02:46.100 --> 02:49.580]  потому что иначе мы можем много ребер удалить, оставить
[02:49.580 --> 02:53.180]  граф связанным, то есть все достижимое из с, тогда
[02:53.180 --> 02:56.780]  е будет хотя бы ве-1 и можно считать, что оно асимпатически
[02:56.780 --> 02:57.780]  больше.
[02:57.780 --> 03:05.980]  Значит, суммарная симптотика это от ве на от бфс, есть
[03:05.980 --> 03:14.020]  точность его от ве квадрат, доказали, просто будут.
[03:14.020 --> 03:21.900]  Хорошо, тогда едем дальше, следующая идея, так называемая
[03:21.900 --> 03:23.580]  техника масштабирования потока.
[03:23.580 --> 03:38.260]  Вот, это скорее не алгоритм, а надстройка над любым алгоритмом
[03:38.260 --> 03:41.660]  поиска максимального потока, то есть ее можно применять
[03:41.660 --> 03:45.740]  и к Форт Фалкерсону, и к Эдман Скарпу, и к Деницу,
[03:45.740 --> 03:47.420]  который мы сегодня тоже пройдем, ну и на самом деле
[03:47.420 --> 03:50.980]  к другим алгоритмам поиска потока, которая в принципе
[03:51.260 --> 03:54.940]  существует, вот, поэтому она может быть полезна как
[03:54.940 --> 03:56.860]  надстройка над каким-нибудь алгоритмом.
[03:56.860 --> 04:00.340]  Так вот, идея в следующем, смотрите, давайте мы скажем,
[04:00.340 --> 04:05.620]  что пусть С большое это ограничение сверху на все
[04:05.620 --> 04:16.060]  капасити, ограничение сверху на все пропускные способности.
[04:16.060 --> 04:21.380]  Вот, ну еще я буду считать, что кратных ребер нет.
[04:21.380 --> 04:29.540]  Раньше это было неважно, а здесь я подчеркну, потому
[04:29.540 --> 04:32.180]  что это может быть существенно, кратных ребер нету.
[04:32.180 --> 04:35.780]  Вот, тогда давайте делать следующее, ну давайте, например,
[04:35.780 --> 04:39.500]  я скажу, что С равно 100, давайте мы будем идти по степеням
[04:39.500 --> 04:43.340]  двойки в порядке убывания, то есть там 64, 32, 16 и так
[04:43.340 --> 04:46.860]  далее, и будем пускать поток непрозвольной величины,
[04:46.860 --> 04:50.140]  а вот в точности такой степени двойки, то есть если изначально
[04:50.140 --> 04:52.740]  скажем С равно 100, мы будем пытаться пустить поток
[04:52.740 --> 04:57.140]  величины 64, пустим все такие возможные потоки, то есть
[04:57.140 --> 05:00.660]  найдем все пути, на которых есть поток величины 64, пропустим
[05:00.660 --> 05:04.020]  их, дальше поток 64 мы уже пустить не можем, возможно
[05:04.020 --> 05:08.060]  можем пустить поток величины 32, тогда соответственно какие-то
[05:08.060 --> 05:10.540]  ребра у нас станут, можно будет опять использовать,
[05:10.540 --> 05:13.460]  то есть если там капасти было 50, то 64 пустить нельзя,
[05:13.460 --> 05:16.540]  а 32 уже можно, вот, и давайте допустим все потоки величины
[05:16.540 --> 05:20.140]  32, потом 16 и так далее, и рано или поздно мы дойдем
[05:20.140 --> 05:23.260]  до состояния, когда мы пытаемся пускать единичные потоки
[05:23.260 --> 05:27.460]  величины 1, как очередная степень двойки, и тогда
[05:27.460 --> 05:29.140]  понятно, что в конце мы все равно найдем максимальный
[05:29.140 --> 05:31.540]  поток, то есть мы вот так вот идем и пытаемся сначала
[05:31.540 --> 05:34.460]  какими-то большими батчами пускать по степени двойки
[05:34.460 --> 05:37.180]  потока, сначала большие куски пытаемся переправить,
[05:37.660 --> 05:40.740]  в самом конце дойдем до к равной единице, когда
[05:40.740 --> 05:43.500]  будем пытаться пускать единицу потока, но это вот
[05:43.500 --> 05:46.060]  более-менее то, что мы делали в Эдманскарпе, но тут на
[05:46.060 --> 05:48.260]  самом деле не единичка пускается, а минимум из
[05:48.260 --> 05:51.540]  капасити, но в худшем случае это единица, вот, а здесь
[05:51.540 --> 05:54.620]  мы идем как бы начиная с больших величин потока
[05:54.620 --> 06:01.860]  до самой маленькой, до единички, значит, сейчас я это напишу,
[06:01.860 --> 06:15.060]  в цикле К от двоичного алгорифма С до нуля мы делаем следующее,
[06:15.060 --> 06:30.380]  мы хотим пускать поток величин два степени К, для этого
[06:30.380 --> 06:33.860]  я сделаю следующее, я все остаточные пропускные
[06:33.860 --> 06:37.660]  способности округлю вниз до ближайшего числа кратного
[06:37.660 --> 06:41.780]  вот этому 2 вкатый, то есть понятно, что число 100 превращается
[06:41.780 --> 06:45.980]  в 64, потому что как бы, ну, больше чем 64 пустить нельзя,
[06:45.980 --> 06:48.500]  ну а все, весь остальной остаток мне не важно, поэтому
[06:48.500 --> 06:58.460]  я сделаю следующее, для всех ребер найдем, вот как раз
[06:58.460 --> 07:01.260]  максимальное число снизу, которое делится на очередную
[07:01.260 --> 07:08.060]  степень двойки, я напишу так, значит, С штрих от Е, это
[07:08.060 --> 07:11.140]  остаточное капасити этого ребра делить на 2 вкатый умножить
[07:11.140 --> 07:16.060]  на 2 вкатый, только после деления беру целую часть,
[07:16.060 --> 07:18.980]  ЦФ делить на 2 втепняка, это как раз максимальное
[07:18.980 --> 07:21.420]  степень двойки кратное, смотри, максимальное число
[07:21.420 --> 07:25.460]  меньше либо равное остаточной капасити кратное 2 вкатый,
[07:25.460 --> 07:30.460]  вот, и на такой сети я пускаю поток каким-нибудь алгоритмом,
[07:30.460 --> 07:34.060]  там Форт Фалкерс, на самом деле не важно, вот в этой
[07:34.060 --> 07:47.220]  сети, в сети с новыми капасити запускаем алгоритм поиска
[07:47.220 --> 07:58.340]  максимального потока, вот, и поскольку теперь вот
[07:58.340 --> 08:02.020]  в этой сети у меня все капасити кратные 2 вкатый, то понятно,
[08:02.020 --> 08:04.420]  что любой путь, который я найду будет повельшине
[08:04.420 --> 08:07.300]  ну хотя бы 2 вкатый, то есть я по нему смогу протолкнуть
[08:07.300 --> 08:11.500]  хотя бы 2 вкатый единиц потока, точнее кратные 2 вкатые,
[08:11.500 --> 08:15.700]  либо 2 вкатые, либо 2 на 2 вкатые, либо 3 на 2 вкатые и так далее,
[08:16.180 --> 08:19.780]  ну и все, и так в цикле до нуля, когда кара равно нулю,
[08:19.780 --> 08:22.940]  у меня будет просто здесь написано остаточное капасити,
[08:22.940 --> 08:25.180]  да, потому что если кара равно нулю, то здесь я делю на
[08:25.180 --> 08:29.460]  единицу, умножаю на единицу, значит корректность на самом
[08:29.460 --> 08:32.500]  деле автоматически следует из того, что у меня рано
[08:32.500 --> 08:35.380]  или поздно я дойду до последней стадии, когда кара равно нулю,
[08:35.380 --> 08:40.980]  значит я ну по сути с осашенной капаситой ничего не делаю,
[08:40.980 --> 08:52.180]  корректность на последней итерации, то есть когда кара
[08:52.180 --> 08:56.140]  равно нулю, у меня вот эта вот моя сеть с штрихами совпадает
[08:56.140 --> 08:59.020]  с сущностью с осашенной сетью, ну и поскольку я
[08:59.020 --> 09:02.100]  в ней нахожу пути пока можно, то соответственно
[09:02.100 --> 09:03.860]  у меня на последней итерации я как раз найду максимальный
[09:03.860 --> 09:06.780]  поток, потому что по теориям Форт Фалкерсона поток
[09:06.780 --> 09:08.540]  максимален, если только если в осашенности нет
[09:08.540 --> 09:11.660]  пути, а на последней итерации я как раз просто, у меня
[09:11.660 --> 09:14.300]  вот эта вот сеть с штрихами, это в точности осаточная
[09:14.300 --> 09:16.740]  сеть, и я в ней нахожу все пути и соответственно
[09:16.740 --> 09:20.420]  исчерпываю весь поток, который мог быть, значит на последней
[09:20.420 --> 09:27.300]  итерации, остаточная сеть совпадает ну с вот этой вот
[09:27.300 --> 09:36.660]  рассматриваемой, вот, значит алгоритм заканчивается
[09:36.660 --> 09:41.500]  ровно тогда, когда нет путей в осаточной сети, поэтому
[09:41.500 --> 09:42.500]  он корректен.
[09:42.500 --> 09:46.540]  А что здесь с асимптотикой, то есть как бы корректно
[09:46.540 --> 09:49.180]  здесь будьте здоровы, как обычно следует из Форт
[09:49.180 --> 09:53.660]  Фалкерсона, что со временем работы, но вот на самом деле
[09:53.660 --> 09:56.740]  независимо от того, какой вы алгоритм здесь пускаете,
[09:56.740 --> 09:59.940]  Форт Фалкерсон и Ледман Скарп, асимптотика будет
[10:00.940 --> 10:10.020]  на лог ц, асимптотика при использовании алгоритма
[10:10.020 --> 10:15.660]  Форда Фалкерсона и Ледман Скарпа будет е квадрат на лог
[10:15.660 --> 10:16.660]  ц.
[10:16.660 --> 10:22.500]  Сейчас мы это докажем, ну лог ц понятно откуда берется,
[10:22.500 --> 10:26.200]  потому что у нас лог ц итераций, лог ц значений принимает
[10:26.200 --> 10:29.020]  переменная k, и вот хотелось бы доказать, что каждое
[10:29.500 --> 10:31.220]  значение k работает примерно за е квадрат.
[10:31.220 --> 10:40.220]  Давайте докажем, давайте это утверждение, доказательство.
[10:45.820 --> 10:55.820]  Ну пусть, скажу следующее, пусть f это настоящий максимальный
[10:55.820 --> 11:02.820]  поток, максимальный поток, а fкт это суммарный поток,
[11:04.460 --> 11:06.900]  который я успел пустить за первые k итерации, то
[11:06.900 --> 11:12.260]  есть вот у меня k убывает от лог ц до какого-то k,
[11:12.260 --> 11:15.420]  и пусть fкт это сколько суммарного потока мы успели пустить.
[11:15.420 --> 11:22.420]  Значит, общий пущенный поток.
[11:25.820 --> 11:32.820]  На итерациях, собственно, от лог 20 до kт, если мы выполнили
[11:39.980 --> 11:42.460]  первые вот столько-то итерации, сколько потока мы уже суммарно
[11:42.460 --> 11:43.460]  пустили.
[11:43.460 --> 11:50.460]  То есть тогда я утверждаю, что f не больше чем fкт, плюс
[11:51.100 --> 11:58.100]  2хкт умножить на е.
[12:01.100 --> 12:05.340]  Почему?
[12:05.340 --> 12:08.220]  Ну смотрите, давайте рассмотрим, что происходит с нашей сетью
[12:08.220 --> 12:10.260]  в конце ката-итерации.
[12:10.260 --> 12:12.460]  Значит, с нашей сетью в конце ката-итерации происходит
[12:12.460 --> 12:13.460]  следующее.
[12:13.460 --> 12:16.780]  В ней, вот в этой сети, когда я вот так вот определяю
[12:16.780 --> 12:22.340]  ее капасити, больше нет никакого пути из s в t.
[12:22.340 --> 12:24.380]  Значит, вот если я рассмотрю вот эту вот сеть, где все
[12:24.380 --> 12:30.020]  капасити кратны 2хкт, у меня есть s, у меня есть t, все
[12:30.020 --> 12:33.740]  капасити кратны 2хкт, но пути из s в t нет.
[12:33.740 --> 12:35.260]  Что это значит?
[12:35.260 --> 12:37.060]  Это значит, что все вот эти вот ребра, которые были
[12:37.060 --> 12:39.940]  в исходном графе между этими двумя долями, то есть по
[12:39.940 --> 12:41.980]  факту я здесь опять пользуюсь Форт Фалкерсом тем, что
[12:41.980 --> 12:42.980]  у меня есть разрез.
[12:43.180 --> 12:45.860]  Что если у меня нет пути из s в t, значит есть...
[12:49.860 --> 12:50.860]  Так, сейчас, одну секунду.
[13:01.460 --> 13:03.460]  Ну да, значит есть...
[13:04.460 --> 13:05.460]  Да-да-да, все правильно.
[13:05.460 --> 13:07.980]  Значит, раз нет пути из s в t, значит по терям Форда
[13:07.980 --> 13:10.380]  Фалкерсона есть разрез, величина которого равна
[13:10.380 --> 13:13.860]  остаточному потоку, сколько осталось потока до конца
[13:13.860 --> 13:14.860]  довести.
[13:14.860 --> 13:18.540]  Вот я этот разрез нарисовал, здесь все ребра на самом
[13:18.540 --> 13:20.060]  деле, они имеют капасити...
[13:20.060 --> 13:28.060]  Сейчас, момент.
[13:28.060 --> 13:31.060]  Туплю.
[13:31.740 --> 13:34.740]  Туплю.
[13:34.740 --> 13:37.740]  Два вкатые.
[13:37.740 --> 13:40.740]  А, меньше два вкатые, меньше два вкатые, да.
[13:40.740 --> 13:44.740]  Вот у них у всех остаточное капасити меньше, чем два
[13:44.740 --> 13:46.740]  вкатые, потому что если было бы больше, соответственно
[13:46.740 --> 13:49.740]  здесь было бы ребро графа, и тогда отсюда можно было
[13:49.740 --> 13:50.740]  бы достичь вот эту вот вершинку.
[13:50.740 --> 13:53.940]  Да, то есть еще раз, у меня нет пути из s в t, значит
[13:53.940 --> 13:56.740]  есть разрез их разделяющий, поэтому все ребра исходного
[13:56.740 --> 13:58.940]  графа, которые пересекают этот разрез, на самом деле
[13:58.940 --> 14:00.300]  в этом графе не участвуют.
[14:00.540 --> 14:02.540]  А раз они не участвуют, значит их остаточное капасити
[14:02.540 --> 14:03.540]  меньше, чем два вкатые.
[14:03.540 --> 14:06.540]  Было бы больше, оно бы вот здесь вот было бы.
[14:06.540 --> 14:07.540]  Вот.
[14:07.540 --> 14:09.540]  Значит здесь все ребра имеют капасити меньше два вкатые,
[14:09.540 --> 14:12.540]  и их не больше, чем е, потому что всего е ребер.
[14:12.540 --> 14:21.540]  Значит, суммарно величина вот этого вот разреза
[14:21.540 --> 14:24.540]  не превосходит даже строго меньше два вкатые умножить
[14:24.540 --> 14:25.540]  на е.
[14:25.780 --> 14:32.780]  Это настоящий максимальный поток во всей сети.
[14:34.780 --> 14:35.780]  Вот.
[14:35.780 --> 14:39.780]  Значит мы показали, что после кат-итерации величина
[14:39.780 --> 14:42.780]  разреза в исходной сети между s и t не больше, чем
[14:42.780 --> 14:43.780]  вот это.
[14:43.780 --> 14:45.780]  Ну а это в точности то, сколько потока осталось
[14:45.780 --> 14:46.780]  пустить.
[14:46.780 --> 14:48.780]  Вот я формулировал, что отсутствие пути из s в t в
[14:48.780 --> 14:53.780]  нашей сети, новой, равносильно тому, что в исходной сети
[14:54.260 --> 14:57.720]  величина этого разреза равна величине потока,
[14:57.720 --> 14:58.780]  который осталось пустить.
[14:58.780 --> 14:59.780]  Вот.
[14:59.780 --> 15:03.060]  Ну значит как раз f – fk не больше, чем два вкаты
[15:03.060 --> 15:04.060]  на е.
[15:04.060 --> 15:08.020]  Да, потому что это сколько потока осталось пустить
[15:08.020 --> 15:10.320]  до самого конца.
[15:10.320 --> 15:14.020]  А это это величина разреза, которая вот равна всегда
[15:14.020 --> 15:15.120]  величины потока.
[15:15.120 --> 15:19.120]  Но это сколько потока осталось пустить до конца.
[15:19.120 --> 15:23.120]  Сколько потока будет найдено на следующих террациях.
[15:23.780 --> 15:35.300]  Вот, поэтому это утверждение мы доказали.
[15:35.300 --> 15:45.420]  Вот, хорошо, а что дальше, зачем это нам нужно было?
[15:45.420 --> 15:48.860]  Смотрите, когда это сделали, я хочу сказать следующее,
[15:48.860 --> 15:52.700]  что на самом деле на каждой итерации, для каждого k,
[15:52.700 --> 15:57.700]  количество ребер, точнее, количество путей, которые я нахожу в нашей новой сети
[15:57.700 --> 16:04.700]  вот с этими странными копастями, это от E.
[16:04.700 --> 16:18.700]  Сейчас мы это покажем.
[16:18.700 --> 16:44.700]  Отсюда следует, что число путей, найденных на следующей итерации, есть от E.
[16:44.700 --> 16:52.700]  Потому что, смотрите, я доказал, что то неравенство означает, что осталось, после k от итерации,
[16:52.700 --> 16:55.700]  осталось пустить не больше, чем 2 вкаты на E потока.
[16:55.700 --> 16:58.700]  Но, смотрите, на следующей итерации, что такое следующая итерация?
[16:58.700 --> 17:04.700]  Это когда k равно k-1. На следующей итерации у меня все ребра будут иметь
[17:04.700 --> 17:09.700]  капасти кратной 2 в степени k-1. Значит, каждый путь, который я найду на следующем шаге,
[17:09.700 --> 17:18.700]  он вносит в ответ хотя бы вот столько. Но при этом внести нам осталось максимум 2 вката на E.
[17:18.700 --> 17:23.700]  А если каждый путь, который я нахожу, вносит хотя бы столько, то суммарно пути не больше,
[17:23.700 --> 17:27.700]  чем вот это поделить на вот это, то есть 2E.
[17:27.700 --> 17:38.700]  Значит, каждый путь вносит хотя бы 2 в степени k-1, значит,
[17:38.700 --> 17:47.700]  путей не больше, чем то, сколько осталось найти, поделить на то, сколько вносит каждый конкретный путь.
[17:57.700 --> 18:06.700]  Окей? Ну, собственно, все. Это мы доказали, что на каждой конкретной итерации находятся
[18:06.700 --> 18:12.700]  пути максимум от E. Ну, а нахождение любого пути это еще один от E. То есть, не важно,
[18:12.700 --> 18:18.700]  Форд Фалкерсон у вас или Эдман Карп, находите путь вы за линейное время. Тут DFS, тут BFS.
[18:18.700 --> 18:24.700]  Поэтому суммарно для каждого конкретного k у вас итерация работает за E квадрат,
[18:24.700 --> 18:34.700]  ну и итерация локция. Поэтому такая символика получается. Окей? Ну, значит, тут самое главное,
[18:34.700 --> 18:40.700]  что на каждой итерации мы находим максимум от E путей. Ну, а дальше уже просто надо посчитать,
[18:40.700 --> 18:48.700]  за сколько находится каждый путь и сколько раз мы это делаем. Так. Вот такой прикол.
[18:48.700 --> 18:55.700]  Ну и значит, на семинаре будет упражнение сделать то же самое для алгоритма Диница,
[18:55.700 --> 19:05.700]  который мы сейчас начнем осматривать. Значит, сделать то же самое для алгоритма Диница.
[19:05.700 --> 19:14.700]  То есть, для Форд Фалкерсон и Эдман Карп мы доказали, и для Диница тоже надо то же самое
[19:14.700 --> 19:32.700]  сделать. Значит, давайте, собственно, тогда к нему и перейдем.
[19:32.700 --> 19:47.700]  Для этого мне нужно будет два вспомогательных определения, оба не сложные. Значит, первое такое.
[19:47.700 --> 19:55.700]  Первая – слоистая сеть. Слоистая сеть. Значит, слоистая сеть определяется так.
[19:55.700 --> 20:02.700]  Смотрите, в алгоритме Эдманца Карпа мы находили кратчайшие пути из S до T.
[20:02.700 --> 20:07.700]  Давайте мы вот, то есть с помощью BFS, давайте мы этот BFS оставим и для каждой вершинки
[20:07.700 --> 20:13.700]  сохраним какое расстояние до нее нашлось. Дальше, давайте все вершины разобьем на кластеры
[20:13.700 --> 20:19.700]  по, собственно, этому самому расстоянию. Соответственно, S будет сама по себе до нее расстояние 0.
[20:19.700 --> 20:23.700]  Дальше будет некий набор вершин, до которых расстояние равно единице.
[20:23.700 --> 20:30.700]  Дальше расстояние – 2, ну и так далее, вот вплоть до T, DST.
[20:30.700 --> 20:39.700]  И оставим все ребра, которые идут только слева направо.
[20:39.700 --> 20:45.700]  Вот это будет слоистая сеть. То есть слоистая сеть строится так. Я запускаю BFS,
[20:45.700 --> 20:52.700]  разделяю, разбиваю все вершинки по классам по значению расстояния и оставляю только ребра слева направо.
[20:52.700 --> 21:02.700]  Формально можно сказать следующее. VIT – это множество вершин таких, что DST S V равно I.
[21:02.700 --> 21:06.700]  Я как раз классифицировал все вершины по DST. А дальше провожу ребра только слева направо,
[21:06.700 --> 21:25.700]  только из I этого слоя V плюс первый. Давайте словами напишу. Оставляем только ребра слева направо.
[21:25.700 --> 21:32.700]  То есть из VIT V и плюс первая для любого I.
[21:32.700 --> 21:37.700]  Понятно, что ребро слева направо не может перескакивать через слой. Из V1 в V3 ребра быть не может,
[21:37.700 --> 21:43.700]  потому что до этой вершинки путь длины 1, а для этой путь длины 3 кратчайше.
[21:43.700 --> 21:47.700]  Но при этом есть вот такое ребро, до него был бы путь длины 2. Такого не бывает.
[21:47.700 --> 21:52.700]  Поэтому ребра, идущие слева направо, они только в следующий слой идут. Из I V плюс первый.
[21:52.700 --> 21:56.700]  Но через слой им прыгать нельзя.
[21:56.700 --> 22:01.700]  Соответственно, слоистые сети я оставляю только такие ребра. Все остальные, которые ведут справа налево,
[22:01.700 --> 22:07.700]  или которые зачем-то внутри слоя находятся, я их удаляю, я их просто игнорирую.
[22:07.700 --> 22:25.700]  Второе определение.
[22:25.700 --> 22:36.700]  Это блокирующий поток.
[22:36.700 --> 22:44.700]  Тут вот так его проще всего задать. Это такой поток, который нельзя увеличить, не водя обратных ребер.
[23:06.700 --> 23:12.700]  Пример.
[23:12.700 --> 23:18.700]  Наш любимый вот такой вот граф.
[23:18.700 --> 23:23.700]  Вот если я такую картинку нарисую, мы знаем, что здесь правильный поток имеет величину 2.
[23:23.700 --> 23:25.700]  Капасти единичка сейчас все.
[23:25.700 --> 23:32.700]  Но смотрите, если я пущу вот такой вот поток, глупенький вот такой вот, величины 1,
[23:32.700 --> 23:34.700]  то он будет блокирующим.
[23:34.700 --> 23:39.700]  Потому что не вводя вот это вот обратное ребро, которое на самом деле появляется в осадочной сети,
[23:39.700 --> 23:42.700]  не вводя это ребро, я этот поток никак увеличить не смогу.
[23:42.700 --> 23:47.700]  То есть да, конечно, правильный алгоритм вводит это обратное ребро и пускает такой поток,
[23:47.700 --> 23:52.700]  отменяя какой-то плохой поток вот здесь, находя правильный поток 2.
[23:52.700 --> 23:56.700]  Но вот если не вводить обратное ребро, то мы нашли блокирующий поток.
[23:56.700 --> 23:59.700]  Один из блокирующих потоков.
[23:59.700 --> 24:01.700]  Окей?
[24:01.700 --> 24:03.700]  Хорошо.
[24:03.700 --> 24:07.700]  Ну и тогда алгоритм Диница очень простой.
[24:07.700 --> 24:16.700]  Мы просто строим каждый раз слоистую сеть, и в слоистой сети находим блокирующий поток.
[24:16.700 --> 24:31.700]  Пока есть путь из СВТ в осадочной сети, мы строим слоистую сеть, и в ней находим блокирующий поток произвольный.
[24:31.700 --> 24:41.700]  Пускаем блокирующий поток в слоистой сети.
[24:47.700 --> 24:51.700]  ЖФ, ну в осадочной сети.
[24:51.700 --> 24:59.700]  Так, в слоистой сети графа ЖФ.
[24:59.700 --> 25:04.700]  Ну, как бы вот это условие можно было бы заменить на вайл-тру, грубо говоря.
[25:04.700 --> 25:12.700]  То есть пока можно, мы делаем вот это вот действие, пока оно осмысленно.
[25:12.700 --> 25:14.700]  Вот.
[25:14.700 --> 25:16.700]  То есть смотрите, мы что делаем.
[25:16.700 --> 25:21.700]  Вот у нас есть исходный граф, мы по нему построили слоистую сеть по этому правилу.
[25:21.700 --> 25:28.700]  В ней нашли блокирующий поток, пустили его, и только после пропускания всего блокирующего потока начнем перестраивать сеть.
[25:28.700 --> 25:35.700]  Мы ведем обратные ребра, у меня изменится осадочная сеть, потому что там какие-то ребра пропадают, какие-то появляются.
[25:35.700 --> 25:37.700]  В частности, какие-то обратные появляются.
[25:37.700 --> 25:42.700]  Дальше, по этой осадочной сети строим слоистую, в ней находим блокирующий поток, ну и так далее.
[25:42.700 --> 25:47.700]  Опять перестроили осаточную, по ней слоистую, в ней блокирующий поток, и так по кругу.
[25:49.700 --> 25:51.700]  Вот.
[25:58.700 --> 26:02.700]  Ну и оказывается, что асимптотика вот такой штуки В квадрат Е будет.
[26:02.700 --> 26:04.700]  Асимптотика.
[26:07.700 --> 26:09.700]  В квадрат Е.
[26:10.700 --> 26:17.700]  Что обычно лучше, чем Эдманскарп, потому что Эдманскарп это ВЕ квадрат, а здесь я квадрат перенес с Ешки на Вешку.
[26:17.700 --> 26:21.700]  Это обычно лучше, потому что ребра обычно больше, чем верши.
[26:23.700 --> 26:25.700]  Так.
[26:27.700 --> 26:28.700]  Окей.
[26:28.700 --> 26:35.700]  Значит, чтобы это доказать, что у нас засток работает, надо сначала разобраться, как мы будем искать блокирующий поток.
[26:35.700 --> 26:39.700]  За сколько мы в слоистой сети можем найти блокирующий поток.
[26:41.700 --> 26:46.700]  Ну, давайте опишем алгоритм, который находит блокирующий поток в осаточной сети.
[26:47.700 --> 26:56.700]  Поиск блокирующего потока, извините, в слоистой сети, в слоистой сети, в слоистой сети, за ВЕ.
[26:56.700 --> 27:09.700]  Если мы это научимся делать, то после этого надо будет показать, что число итераций, то есть перестраивания слоистой сети будет от В.
[27:09.700 --> 27:15.700]  Тогда мы, соответственно, от В раз ищем блок поток в слоистой сети, а асимптотика будет как раз в квадрат Е.
[27:15.700 --> 27:17.700]  Ну, пока давайте на этом сфокусируемся.
[27:17.700 --> 27:19.700]  Значит, вопрос.
[27:19.700 --> 27:21.700]  Представьте себе, что у вас есть такая слоистая сеть.
[27:21.700 --> 27:22.700]  Вот она.
[27:22.700 --> 27:25.700]  Вы хотите в ней найти какой-нибудь блокирующий поток?
[27:25.700 --> 27:29.700]  Так, я, кстати, забыл сказать про корректность, но она здесь очевидна опять из Форт Фалкерсона,
[27:29.700 --> 27:34.700]  потому что заканчивается наш алгоритм только в случае отсутствия пути из СПТ в осаточной сети,
[27:34.700 --> 27:37.700]  а это в точности по Форт Фалкерсону критерии максимальности.
[27:37.700 --> 27:40.700]  Поэтому я тут даже это забыл сказать, потому что это очевидно.
[27:40.700 --> 27:44.700]  Вот эта первая строчка автоматически знает, что алгоритм корректный.
[27:44.700 --> 27:46.700]  Итак, вернемся.
[27:46.700 --> 27:49.700]  Значит, есть слоистая сеть, я хочу найти какой-нибудь блокирующий поток.
[27:51.700 --> 27:53.700]  Давайте сделаем следующее.
[27:53.700 --> 27:58.700]  Давайте будем в каком-то смысле просто жадно идти и пускать максимально возможный поток по каждому ребру.
[27:59.700 --> 28:00.700]  Значит, что я имею в виду?
[28:00.700 --> 28:01.700]  Смотрите.
[28:02.700 --> 28:06.700]  Пусть мы начинаем в С, как-нибудь прошли,
[28:07.700 --> 28:10.700]  и, ну понятно, нам нужно хранить минимально из вот этих capacity,
[28:10.700 --> 28:13.700]  то есть какой поток мы можем пустить по вот этим ребрам.
[28:13.700 --> 28:15.700]  Пусть мы находимся в очередной вершинке В,
[28:15.700 --> 28:18.700]  и хотим дальше пустить как можно больше потока.
[28:19.700 --> 28:22.700]  Но давайте просто перебирать все исходящие ребра.
[28:23.700 --> 28:25.700]  И смотреть, что с ними происходит.
[28:25.700 --> 28:28.700]  Значит, во-первых, вот если я рассматриваю очередное ребро,
[28:28.700 --> 28:31.700]  надо не забыть, что оно находится на самом деле в слоистой сети.
[28:31.700 --> 28:34.700]  Что оно ведет реально из предыдущего слоя в следующий.
[28:34.700 --> 28:39.700]  Вот если это хорошее ребро, давайте попытаемся по нему протолкнуть этот поток,
[28:39.700 --> 28:43.700]  ну и дальше с помощью какого-то DFS'а попытаемся найти путь отсюда до T.
[28:44.700 --> 28:48.700]  Если получилось, то хорошо, вот мы нашли какой-то поток.
[28:48.700 --> 28:52.700]  Ну, пока не блокирующий, но это какой-то поток, по этому пути можно что-то протолкнуть.
[28:53.700 --> 28:55.700]  Но, более важное,
[28:55.700 --> 28:58.700]  если мы не смогли отсюда дойти до T,
[28:58.700 --> 29:01.700]  мы можем сразу сказать, что это ребро бесполезно, но мусорное,
[29:01.700 --> 29:03.700]  его можно больше никогда не рассматривать.
[29:04.700 --> 29:06.700]  То есть, если я использую это ребро,
[29:06.700 --> 29:09.700]  отсюда не смог дойти до T, вот здесь нет пути до T.
[29:09.700 --> 29:12.200]  Значит, это ребро больше никогда рассматривать не нужно.
[29:12.200 --> 29:14.700]  По нему больше поток в принципе нельзя пустить.
[29:14.700 --> 29:20.700]  Потому, что отсюда нет пути до T, значит, это ребро не участвует ни в каком потоке.
[29:20.700 --> 29:27.700]  Вот, если мы это сделали, если мы нашли, что ребро бесполезно, давайте его таким пометим и больше его не использовать.
[29:27.700 --> 29:29.700]  Собственно, это все, что будет нужно.
[29:29.700 --> 29:37.700]  Значит, у меня в каждой вершинке будет, ну, давайте, у меня есть какая-то вершина, v, из нее выходят ребра,
[29:37.700 --> 29:40.700]  и я постепенно буду их помечать бесполезными.
[29:40.700 --> 29:44.700]  То есть, я, скажем, взял это ребро, не смог дойти до t, это ребро, ну, как бы удалил.
[29:44.700 --> 29:47.700]  Я не буду удалять, просто буду помечать его бесполезно.
[29:47.700 --> 29:49.700]  Дальше буду пытаться через это ребро пустить поток.
[29:49.700 --> 29:52.700]  Если смог, ну, хорошо, потом я могу, если что, его переиспользовать.
[29:52.700 --> 29:56.700]  Рано или поздно оно тоже станет бесполезным, потому что либо оно само насытится,
[29:56.700 --> 30:02.700]  либо я отсюда просто не смогу дойти до t, потому что там какие-то другие ребра стали уже насыщенными.
[30:02.700 --> 30:05.700]  Значит, это ребро станет насыщенным, ну и так далее.
[30:06.700 --> 30:12.700]  И, ну, собственно, вот очень простой алгоритм, просто пока ребро, пока по ребру что-то можно пустить, пускаем,
[30:12.700 --> 30:14.700]  а если нельзя, то, значит, это ребро можно игнорировать.
[30:14.700 --> 30:17.700]  Значит, немножко деталей реализации.
[30:18.700 --> 30:28.700]  Мне будет нужен вектор ptr, который для каждой вершины говорит номер первого интересного ребра.
[30:31.700 --> 30:41.700]  ptr от v – это номер первого интересного исходящего ребра.
[30:42.700 --> 30:48.700]  Интересно, это то, про которое мы еще не знаем, что оно бесполезно.
[30:48.700 --> 30:53.700]  То есть, если оно бесполезно, то мы его должны игнорировать, а иначе, если мы про него еще не знаем, что оно бесполезно,
[30:53.700 --> 30:57.700]  вот давайте с него пытаться начинать наш путь.
[30:58.700 --> 31:03.700]  Вот. И тогда, значит, давайте напишем такой dfs.
[31:03.700 --> 31:08.700]  Значит, пусть мы дошли до вершины v и смогли до нее довести f потока.
[31:08.700 --> 31:12.700]  То есть, грубо говоря, f – это минимум из вот этих вот всех остаточных capacity.
[31:12.700 --> 31:14.700]  То есть, я же как-то до сюда дошел.
[31:14.700 --> 31:19.700]  Соответственно, f – это то, сколько поток я могу по этому началу пути протолкнуть.
[31:20.700 --> 31:26.700]  Значит, условия выхода, если мы внезапно закончились, то надо просто вернуть f.
[31:26.700 --> 31:29.700]  Да, у меня dfs будет возвращать, сколько потока мы нашли.
[31:33.700 --> 31:40.700]  А иначе, мне нужно просматривать вот эти ребра в порядке вот, в том, в котором они занумерованы исходящие ребра,
[31:40.700 --> 31:46.700]  и каждое еще интересное ребро, вдоль каждого такого ребра, попытаться протолкнуть какой-то поток.
[31:46.700 --> 31:48.700]  Значит, это я сделаю следующим образом.
[31:48.700 --> 31:50.700]  Давайте там уже.
[31:50.700 --> 32:02.700]  Пока ptr от V меньше, чем количество ребер, то есть, меньше, чем в этой точке size tv,
[32:02.700 --> 32:19.500]  Пока ptr от v меньше, чем количество ребер, то есть
[32:19.500 --> 32:27.820]  меньше, чем wt.size, пока есть хотя бы одно интересное
[32:27.820 --> 32:30.820]  ребро, про которое мы еще не знаем, что оно бесполезное.
[32:30.820 --> 32:33.820]  Да, вот берем, берем его номер, пусть e это то
[32:33.820 --> 32:34.820]  самое ребро.
[32:34.820 --> 32:45.940]  Значит пусть e это ребро, исходящее из v, вот с этим
[32:45.940 --> 32:46.940]  номером.
[32:46.940 --> 32:54.060]  То есть это первое ребро, про которое мы еще не знаем,
[32:54.060 --> 32:57.020]  что бесполезное, по которому мы сейчас будем пытаться
[32:57.020 --> 32:58.020]  прогнуть поток.
[32:58.020 --> 33:02.280]  Значит сначала давайте проверим, что оно реально
[33:02.280 --> 33:03.280]  слой сети.
[33:03.280 --> 33:07.700]  То есть это ребро слева направо, и оно, на нем не
[33:07.700 --> 33:08.700]  нулевая capacity.
[33:08.700 --> 33:23.660]  Я напишу так, если dist от v плюс 1 не равно dist от tu,
[33:23.660 --> 33:25.980]  ну где tu это конец этого ребра, то есть e это ребро
[33:25.980 --> 33:36.420]  из v2, да, e это ребро из v2, или это ребро насыщенное,
[33:36.420 --> 33:46.380]  e capacity равно e flow, тогда я просто делаю continue.
[33:46.380 --> 33:50.540]  Вот эта проверка отсекает все нележащие в слоистой
[33:50.540 --> 33:51.540]  сети ребра.
[33:51.540 --> 33:54.660]  Потому что в слоистой сети у меня только ребра слева
[33:54.660 --> 33:58.020]  направо, то есть dist от конца должно быть на ничку
[33:58.020 --> 34:00.740]  больше, чем от начала, и при этом capacity должна быть
[34:00.740 --> 34:03.180]  положительная, а station capacity должна быть положительная.
[34:03.180 --> 34:05.060]  Ну потому что иначе по нему ничего пустить нельзя,
[34:05.060 --> 34:08.740]  оно нам точно ничего не даст.
[34:08.740 --> 34:11.300]  Мы такие ребра игнорируем, на самом деле, sorry, тут не
[34:11.300 --> 34:16.740]  continue, глупость написал, надо plus plus ptr at first сделать сначала,
[34:16.740 --> 34:19.740]  после этого continue.
[34:19.740 --> 34:24.300]  Ну потому что вот это конкретное ptr в это ребро бесполезно,
[34:24.460 --> 34:27.380]  мы его помечаем бесполезным, сдвигаем указатель на
[34:27.380 --> 34:29.980]  единичку, вот этот вот, и переходим к следующему
[34:29.980 --> 34:31.740]  ребру, которым мы еще не знаем, что бесполезно.
[34:31.740 --> 34:37.260]  Ну а иначе давайте сделаем следующее.
[34:37.260 --> 34:39.940]  Мы считаем, что ребро e хорошее, пытаемся по нему что-то
[34:39.940 --> 34:40.940]  пропустить.
[34:40.940 --> 34:46.140]  Вопрос, сколько мы можем суммарно перенести потока,
[34:46.140 --> 34:48.860]  если мы вот это вот ребро в конец нашего пути приклеиваем.
[34:48.860 --> 34:53.220]  То есть мы сначала дошли от s до v, смогли здесь f потока
[34:53.220 --> 34:56.460]  протолкнуть, и теперь еще вот вдоль этого ребра пускаем
[34:56.460 --> 34:57.460]  поток.
[34:57.460 --> 35:02.700]  Ну понятно тогда, что поток ограничен сверху f и остаточной
[35:02.700 --> 35:05.340]  капастью этого ребра, а остаточная капасть этого
[35:05.340 --> 35:13.580]  ребра это e cap – e flow, e cap – e flow.
[35:13.580 --> 35:14.980]  Соответственно тогда я с помощью того же самого
[35:14.980 --> 35:19.300]  DFS пытаюсь найти, сколько я могу до конца, то есть
[35:19.300 --> 35:22.740]  до t, пустить потока из вершинки 2.
[35:22.740 --> 35:26.540]  Вот я в вершинке 2 начинаю, потока не больше, чем вот
[35:26.540 --> 35:30.340]  это вот количество, ну и сколько я могу до t довести.
[35:30.340 --> 35:34.420]  Если вдруг так получилось, что x равно нулю, это как раз
[35:34.420 --> 35:37.020]  значит, что ребро вот это вот e бесполезно, то есть
[35:37.020 --> 35:40.340]  я до сюда дошел, пытаюсь что-то пустить, но не могу,
[35:40.340 --> 35:44.060]  то есть я отсюда до t никак не могу добраться, то есть
[35:44.060 --> 35:46.700]  передав положительное количество потока, я до t добраться не
[35:46.700 --> 35:47.700]  могу.
[35:47.700 --> 35:50.220]  Значит это ребро бесполезно, его больше никогда рассматривать
[35:50.220 --> 35:52.340]  нет смысла, потому что если я до него вдруг дойду как-нибудь
[35:52.340 --> 35:55.180]  по-другому, то все равно с его помощью я до t никак
[35:55.180 --> 35:57.740]  не доберусь, поэтому больше его рассматривать нет смысла.
[35:57.740 --> 36:04.100]  В этом случае я просто делаю, ну вот то же самое по факту,
[36:04.100 --> 36:06.060]  помечаю его бесполезным и перехожу к следующему
[36:06.060 --> 36:07.060]  ребру в цикле.
[36:07.060 --> 36:14.620]  А иначе, если x положительное, значит я смог по вот этому
[36:14.780 --> 36:19.900]  пути от s до v через ребро e до t пропустить поток x, вот
[36:19.900 --> 36:22.500]  здесь вот везде я должен пропустить x.
[36:22.500 --> 36:26.820]  Ну давайте тогда, чтобы этот x учесть, я сделаю, я его
[36:26.820 --> 36:30.540]  учту для ребра e, а на всех остальных ребрах его учтет
[36:30.540 --> 36:32.740]  dfs, который те ребра рассматривал.
[36:32.740 --> 36:37.420]  Значит я сделаю так, e flow плюс равно x, потому что я
[36:37.420 --> 36:39.620]  на этом ребре пустил поток x.
[36:39.620 --> 36:42.620]  Вот и здесь же мне нужно не забыть, что у меня на самом
[36:42.620 --> 36:45.660]  деле же обратные ребра на самом деле присутствуют
[36:45.660 --> 36:46.660]  во всем графе.
[36:46.660 --> 36:48.500]  Мне нужно не забыть, что на обратном ребре я пускаю
[36:48.500 --> 36:51.620]  получается минус x, всегда если я по одному ребру, по
[36:51.620 --> 36:54.020]  прямому ребру пускаю x, то по обратному надо не забыть
[36:54.020 --> 36:56.500]  вычесть x, ну потому что у меня антисимметричность
[36:56.500 --> 36:57.500]  потока есть.
[36:57.500 --> 37:00.420]  Значит здесь мне нужно написать что-то типа для обратного
[37:00.420 --> 37:07.420]  ребра, да, reverse вот e, точка flow, мне нужно сделать минус
[37:07.420 --> 37:08.420]  равно x.
[37:08.420 --> 37:09.420]  Вот.
[37:10.220 --> 37:14.420]  Ну и все, после этого можно сделать return x, как знак
[37:14.420 --> 37:20.380]  того, что какой-то поток я протолкнул, а если у меня
[37:20.380 --> 37:22.380]  весь этот файл закончился и я ничего не вернул, то
[37:22.380 --> 37:28.500]  мне нужно сделать return 0, все, и на этом dfs закончился.
[37:28.500 --> 37:29.500]  Вот.
[37:29.500 --> 37:38.220]  То есть что делать dfs, он в самом начале, да, как я
[37:38.220 --> 37:39.220]  его буду вообще вызывать?
[37:39.220 --> 37:44.020]  Я его из main буду вызывать так, dfs, s бесконечности.
[37:44.020 --> 37:50.340]  То есть я стою в s, говорю, что я могу сюда привести
[37:50.340 --> 37:53.340]  сколько-года много потока, и дальше ты, пожалуйста,
[37:53.340 --> 37:55.460]  найди мне какой-нибудь путь, протолкни хоть какой-нибудь
[37:55.460 --> 37:58.300]  по точек, по какому-нибудь пути, да, вот с помощью этой
[37:58.300 --> 37:59.300]  процедуры.
[37:59.300 --> 38:02.460]  То есть мы по факту просто идем как-нибудь, что можем
[38:02.460 --> 38:05.420]  проталкиваем, если какие-то ребра помещаются бесполезными,
[38:05.420 --> 38:07.080]  то мы их больше никогда рассматривать не будем.
[38:11.080 --> 38:12.000]  Вот.
[38:12.000 --> 38:19.140]  И, соответственно, блокирующий поток, поиск блокирующего
[38:19.140 --> 38:21.340]  потока работает так, пока эта штука возвращает положительную
[38:21.340 --> 38:23.380]  величину, мы ее запускаем многократно.
[38:23.380 --> 38:28.020]  То есть пока эта штука возвращает что-то положительное,
[38:28.020 --> 38:31.320]  то есть пока в осадь bucket есть путь, я просто ее запускаю,
[38:31.320 --> 38:33.180]  запускаю, запускаю много раз, пока хоть что-то пропускается.
[38:33.180 --> 38:35.300]  Как только ничего не пропускается, значит у меня все
[38:35.300 --> 38:39.900]  рёбра стали бесполезными, я ничего пустить больше не могу.
[38:39.900 --> 38:49.620]  Так, давайте это запишем тоже. Блок поток. Ну и так очень некрасиво
[38:49.620 --> 39:01.540]  напишу, пока dfs, s бесконечность больше нуля. То есть пока
[39:01.540 --> 39:04.780]  у меня получается пустить положительный поток,
[39:04.780 --> 39:09.460]  я его запускаю, запускаю, запускаю. Как только эта штука вернула ноль, значит больше
[39:09.460 --> 39:12.700]  потока я пустить не могу без введения обратных рёбер. Ну и у меня этот вайл
[39:12.700 --> 39:17.420]  соответственно заканчивается. Пережив. Так, давайте продолжать.
[39:17.420 --> 39:21.660]  Чего? Мы хотим понять, за сколько это работает. То есть я научился
[39:21.660 --> 39:26.700]  находить какой-то блокирующий поток, вопрос это за сколько было. Я утверждаю
[39:26.700 --> 39:32.420]  следующее, что если, давайте рассмотрим какой-то запуск, вот конкретно dfs, s
[39:32.420 --> 39:38.180]  бесконечность. Вот я, вот я из моего мейна запускаю dfs, s бесконечность. Вопрос
[39:38.180 --> 39:46.980]  за сколько он отработал. Давайте скажем, что суммарно все ptr вот эти вот
[39:46.980 --> 40:05.700]  увеличились на k. Пусть суммарно все ptr увеличились на k. То есть вот если я
[40:05.700 --> 40:09.500]  посчитаю, сколько раз у меня вот этот вот ptr увеличился или вот этот, вам там
[40:09.500 --> 40:15.060]  удобно? Отлично. Вот сколько суммарно было вот этих плюс-плюсов, пусть их было
[40:15.060 --> 40:23.740]  ровно k. Тогда я утверждаю, что время работы вот этого dfs, вот этой вот штуки,
[40:23.740 --> 40:35.060]  есть v плюс k. Почему? Потому что, смотрите, давайте рассмотрим вот окончание, когда
[40:35.060 --> 40:40.140]  это dfs закончил работу. Что это значит? Это по факту значит, что он нашел какой-то
[40:40.140 --> 40:46.540]  путь из s в t и пустил по нему какой-то поток. Ну либо он вообще рассмотрел все возможные
[40:46.540 --> 40:51.980]  пути и сказал, что пути нет. Давайте общий случай, когда он нашел путь. Вот он нашел
[40:51.980 --> 40:59.700]  какой-то путь. И что он еще сделал? Для того, чтобы его найти, он несколько раз увеличил ptr.
[40:59.700 --> 41:04.100]  То есть он какие-то ребра помечал бесполезными. Вот тут или вот тут. То есть он еще какие-то
[41:04.100 --> 41:11.580]  ребра рассмотрел и пометил их бесполезными. Снял с них ptr, то есть мы их больше рассматривать
[41:11.580 --> 41:16.860]  не будем. Поэтому на самом деле суммарно время работы вот этого dfs, это сколько ребер он
[41:16.860 --> 41:21.860]  просмотрел и пометил бесполезными, плюс вот это количество ребер на этом пути. Ну потому что
[41:21.860 --> 41:26.100]  что делает dfs? Он рассматривает ребра в каком-то порядке и либо он ребра помечает бесполезным,
[41:26.100 --> 41:33.700]  либо это ребро участвует в нашем пути от s до t. Время работы dfs вот этого вот,
[41:33.700 --> 41:50.580]  это просто число просмотренных ребер. Вот таких вот ребер мы просмотрели k, вот таких
[41:50.580 --> 41:56.620]  мы просмотрели v, потому что в слейстой сети расстояние от s до t максимум v. Ну значит вот
[41:56.620 --> 42:10.540]  время работы v плюс k. Чудесно. Значит время работы одного dfs v плюс k. За сколько работают вот эти
[42:10.540 --> 42:17.340]  многократные запуски dfs тогда? Но мне нужно его пускать, пускать, пускать, пока пускается, да,
[42:17.340 --> 42:25.340]  то есть пока он что-то находит. Вопрос сколько раз это может происходить? Да, вопрос к вам,
[42:25.340 --> 42:33.220]  сколько максимум раз может dfs запуститься? Да, вот этот while сколько сколько раз он может
[42:33.220 --> 42:45.060]  запустить dfs с бесконечности? Вот как говорит vector, это говорит e, а почему v? Вроде e я могу только
[42:45.060 --> 42:57.900]  сказать. Да, значит давайте напишем, что число запусков, да, да, да, число таких запусков есть
[42:57.900 --> 43:05.580]  от e, потому что каждый запуск насыщает хотя бы одно ребро, а значит оно помещается бесполезным и
[43:05.580 --> 43:12.260]  значит его больше мы не рассматриваем. Но суммарно по меток бесполезности максимум e потому что
[43:12.260 --> 43:35.500]  всего e ребер. Так как хотя бы одно ребро насытится, значит помещается бесполезным. Ну вот,
[43:35.500 --> 43:42.140]  значит у меня e раз опускается такой dfs, каждый dfs работает за столько и вот пусть, соответственно,
[43:42.300 --> 43:49.500]  k1 и так далее k e это то насколько сдвинули суммарно все ptr на очередной итерации. Тогда время работы
[43:49.500 --> 44:07.620]  будет, ну давайте суммарно, у меня будет сумма по e итерациям o от v плюс k i t. Вот, ну здесь будет
[44:07.620 --> 44:13.540]  v e, а здесь будет сумма всех k i t, сумма всех k i t это o от e, потому что k на сколько сдвинутся
[44:13.540 --> 44:23.460]  указатели, ребер всего e, значит указатели суммарно сдвинутся максимум на e. Значит у меня
[44:23.460 --> 44:36.060]  получился алгоритм за v e. Так, все, значит мы сделали то, что я обещал, мы нашли блок поток за v e.
[44:36.060 --> 44:55.740]  Прекрасно. Теперь я хочу доказать, что, я хочу доказать, что суммарное количество раз,
[44:55.740 --> 45:00.420]  которые мне потребуется искать блок поток, это будет o от v, тогда будет как раз такая симптомика.
[45:00.420 --> 45:13.980]  Для этого я покажу следующее. После каждой итерации, после каждой итерации, ну то есть когда я нахожу
[45:13.980 --> 45:18.460]  слоистую сеть, в ней блокирующий поток, вот после этого, после того как я пустил блок поток в новой
[45:18.460 --> 45:36.380]  сети, у меня увеличивается расстояние от s до t. Расстояние от s до t увеличивается. То есть после
[45:36.380 --> 45:42.460]  пропускания блокирующего потока в слоистой сети, у меня новый дист в остаточной сети будет больше,
[45:42.460 --> 45:53.020]  чем старый. Дист-штрих больше, чем дист-ст. То есть скажем, если у меня раньше была слоистая сеть вот
[45:53.020 --> 46:00.820]  такая вот, расстояние было тройка от s до t, то после пускания весь блок потока у меня расстояние будет
[46:00.820 --> 46:17.940]  хотя бы 4, строго больше, чем раньше. Почему так? Потому что мы нашли блокирующий поток, значит в
[46:17.940 --> 46:24.140]  каком-то смысле мы исчерпали все пути текущей длины, вот этой вот старой длины st. Значит блокирующий
[46:24.140 --> 46:44.460]  поток исчерпал все пути вот такой длины, все пути длины st, длины диста st. Давайте картинка,
[46:44.460 --> 46:52.820]  вот была наша слоистая сеть, все ребра шли слева направо, я нашел в ней какой-то блокирующий
[46:52.820 --> 46:58.380]  поток, его пустил. Я утверждаю, что после того, как я пустил блокирующий поток, у меня в новой
[46:58.380 --> 47:05.580]  остаточной сети, если я ввожу обратные ребра, как и надо делать в обычном алгоритме, у меня не будет
[47:05.580 --> 47:10.500]  ни одного пути той же самой длины от s до t, какой был раньше. То есть если какой-то пути будет,
[47:10.500 --> 47:16.860]  то только больше. А давайте вообще поймем, что происходит с сетью остаточной после пускания
[47:16.860 --> 47:22.580]  здесь блокирующего потока. Значит как выглядела сеть изначально? Мы знаем, что есть ребра слева
[47:22.580 --> 47:31.900]  направо, мы знаем, что есть ребра внутри слоя, и есть, возможно, ребра справа налево. Других ребр
[47:31.900 --> 47:36.380]  не бывает. Либо внутри, либо справа налево, либо слева направо, из одного слоя в следующий.
[47:36.380 --> 47:43.020]  Значит после того, как я пустил здесь блокирующий поток, у меня не осталось ни одного пути от s
[47:43.020 --> 47:48.140]  до t по ребрам слева направо, на котором был бы положительной остаточной капасити. То есть любой
[47:48.140 --> 47:56.180]  путь из s в t, вот такой вот прямой, давайте опять возьму цветной мелок, значит любой путь слева
[47:56.180 --> 48:04.020]  направо, он уже исчерпан. Потому что, ну, иначе можно было бы его добавить и увеличить блокирующий
[48:04.020 --> 48:08.820]  поток. Значит на любом таком пути, на самом деле, хотя бы одно ребро насыщенное, значит этого пути
[48:08.820 --> 48:14.940]  в остаточной сети уже нету, его как бы не существует, нельзя вот s до t по нему добраться. Давайте посмотрим,
[48:14.940 --> 48:20.580]  какие могут быть другие пути. Можно ли после проведения блокирующего потока найти поток
[48:20.580 --> 48:26.940]  меньше длины, путь меньше длины или такой же? Ну вот нельзя, потому что как вообще может
[48:26.940 --> 48:33.300]  выглядеть любой путь отсюда до сюда в новой сети? Что у нас вообще происходит после того,
[48:33.300 --> 48:38.260]  как я блокирующий поток провел? У меня какие-то ребра исчезли, потому что насытились, скажем,
[48:38.260 --> 48:42.700]  вот это ребро могло исчезнуть. И какие-то ребра могли появиться, но ребра только справа налево
[48:42.700 --> 48:48.260]  появляются, потому что появляются только обратные ребра, обратные к прямым, то есть из и плюс первого
[48:48.260 --> 48:54.620]  слоя вытой. Поэтому изменения только в том, что какие-то ребра слева направо пропадают, а справа
[48:54.620 --> 49:01.020]  налево появляются. Ну тогда понятно, что кратчайший путь от s до t мог только увеличиться по длине,
[49:01.020 --> 49:10.260]  да, ну потому что за один шаг я могу прыгнуть только в следующий слой, и если, скажем, ну путь был бы
[49:10.260 --> 49:13.980]  той же длины, то у меня получается мне нужно отсюда до сюда прыгнуть, отсюда до сюда, сюда-сюда-сюда,
[49:13.980 --> 49:19.300]  но все такие пути исчерпаны. Значит единственная возможность это, ну что-то вот такое, сюда-сюда,
[49:19.300 --> 49:23.660]  потом вернулись, потом опять сюда, потом как-нибудь вернулись, ну короче вот как-то так, он мог
[49:23.660 --> 49:46.460]  быть только длиннее. Ну значит дист увеличился. Давайте это я что-нибудь здесь напишу. Так, момент.
[49:46.460 --> 50:05.820]  Давайте напишу так, чтобы путь имел меньшую длину, меньше либо равную длину, значит он должен идти
[50:05.820 --> 50:09.820]  только по ребрам слева направо, потому что если он использует хотя бы одно ребро справа налево,
[50:09.820 --> 50:15.300]  то значит его длина уже точно больше, ну потому что вот быстрее, чем за количество слоев плюс
[50:15.300 --> 50:19.140]  один, мы добраться точно никак не можем, потому что каждое ребро только на один слой вперед нас
[50:19.140 --> 50:26.940]  проталкивает. Значит чтобы путь имел длину не больше, чем раньше, он должен проходить по всем
[50:26.940 --> 50:44.580]  слоям в порядке слева направо. Походить по всем слоям в порядке слева направо. Но поскольку мы
[50:44.580 --> 50:50.020]  пустили блокирующий поток, то все такие пути исчерпаны, по ним ничего больше пустить нельзя. Ну все,
[50:50.020 --> 50:55.500]  значит меньше либо равно иметь нельзя, значит будет только больше. Но все такие пути исчерпаны.
[50:55.500 --> 51:06.660]  Все, значит дист штрих строго больше мдист эста.
[51:25.500 --> 51:39.300]  Ну и отсюда не следует, что время работы это v квадрат на e. Алгоритм работает за v квадрат на
[51:39.300 --> 51:46.740]  e. Потому что каждая итерация работает за v, а каждая итерация это поиск блока потока за
[51:46.740 --> 51:54.660]  ve. И итерация максимум от v, потому что дист не может возрастать больше, чем до v. Значит итерация
[51:54.660 --> 52:08.500]  за ve, а всего итераций от v, потому что каждая итерация увеличивает дист хотя бы на единичку. Дист не
[52:08.500 --> 52:12.940]  может быть больше, чем v, потому что если в графе v вершин, то украшение не больше, чем v, не больше,
[52:13.540 --> 52:37.180]  значит их от v. Ну все, получили v квадрат e. Так, хорошо. Значит, секунда рассуждений. Смотрите,
[52:37.180 --> 52:42.820]  все эти симптотики, которые я пишу, v квадрат e в Диннице, ve квадрат в Эдманскарпе или там f на
[52:42.820 --> 52:52.060]  e в Форт Фалкерсоне, они все теоретически, я скажу так. На самом деле на практике они работают гораздо
[52:52.060 --> 52:56.780]  быстрее, чем если вы просто посчитаете вот эту величину и поделите на количество операций в
[52:56.780 --> 53:05.780]  секунду. На самом деле поток найдется, скорее всего, гораздо быстрее. Почему? Ну потому что вот
[53:05.780 --> 53:12.740]  эти вот условия, которые вот такую асимптотику дают, они тяжело достижимы. Давайте проанализируем,
[53:12.740 --> 53:17.420]  когда здесь достигается v квадрат e. Во-первых, мне нужно, чтобы на каждой итерации дист увеличился
[53:17.420 --> 53:23.620]  ровно на единицу, чтобы итерация была e. Во-вторых, мне нужно, чтобы при поиске блокирующего потока
[53:23.620 --> 53:28.620]  каждый поток насыщал только одно ребро. Вот из всего длинного пути только одно ребро насыщалось,
[53:28.620 --> 53:34.940]  тогда будет как раз ve вот здесь время работы. Ну понятно, что это не очень правдоподобно. Наверняка
[53:34.940 --> 53:41.860]  там каждый путь, ну несколько ребер насытит. Особенно если у вас там все capacity довольно
[53:41.860 --> 53:48.020]  маленькие, capacity числа от 1 до 10, например, тогда понятно, что вместе с одним ребром насытится
[53:48.020 --> 53:55.340]  еще все такой же capacity, ну то есть там несколько, грубо говоря. Поэтому вот такая асимптотика,
[53:55.340 --> 54:00.420]  она, наверное, не очень достижима. Это очень неформальное рассуждение. Ну на пальцах почему
[54:00.420 --> 54:07.540]  здесь, почему может быть сильно лучше, чем вот это. И то же самое с Edmunds Carp, и то же самое с
[54:07.540 --> 54:13.060]  Fort Falkers, потому что они только в худшем случае работают за вот это время какое-то, но на практике
[54:13.060 --> 54:20.420]  часто лучше. Есть еще теоретические оценки, вот мы сейчас еще на них посмотрим, как можно
[54:20.420 --> 54:28.100]  еще жестче, еще строже оценить теоретически время работы алгоритма Деница. Вот мы сейчас их
[54:28.100 --> 54:32.660]  подоказываем, что в некоторых специфических графах можно теоретически доказать, что время
[54:32.660 --> 54:45.300]  работы будет еще лучше. Так, для этого нужны будут определения. Пусть, ну там, как обычно, G, S, T, C это
[54:45.300 --> 55:01.700]  сеть. Значит, для любой вершины я могу определить C in от V. Это сумма всех входящих capacity. И C out от V.
[55:01.700 --> 55:15.180]  Это сумма всех исходящих capacity. Так, sorry, здесь U, здесь U, здесь capacity U V. То есть это вот вершину
[55:15.180 --> 55:25.580]  я складываю сколько входит суммарно и сколько выходит. Не потока, а capacity. Вот, и потенциалом
[55:25.580 --> 55:35.980]  вершинки P от V я назову минимум из этих двух величин. Минимум из C in от V и C out от V. Потенциал
[55:35.980 --> 55:51.220]  вершины V. Общий потенциал сети это сумма по всем вершинам, сумма потенциалов по всем вершинам.
[55:51.220 --> 56:19.940]  Теорема. Число итерации алгоритма 1 не превосходит корни SP. Число итерации алгоритма 1 есть от корни
[56:19.940 --> 56:31.660]  SP. Поэтому если вдруг вот это вот сильно лучше, чем V, да, у нас пока что мы пока что знаем только,
[56:31.660 --> 56:38.020]  что число итерации есть от V. Если вдруг P, точнее корень SP сильно меньше, чем V, то это дает более
[56:38.020 --> 56:51.620]  содержательную оценку на время работы денницы. Особенно это здорово работает, если у вас,
[56:51.620 --> 56:58.060]  например, ну до этого дойдем, да, но если, например, сети деничные, у вас все capacity равны деничке,
[56:58.060 --> 57:06.060]  тогда у вас вот эта вот штука, сумма, она на самом деле будет от E. Ну потому что вы как бы здесь,
[57:06.100 --> 57:11.020]  это у вас что-то типа степени вершины, и вы складываете в степени всех вершин. И тогда у
[57:11.020 --> 57:17.140]  вас P это от E, и здесь будет корень из E вместо V. Ну понятно, что корень из E очень часто лучше,
[57:17.140 --> 57:23.300]  чем V. Поэтому это полезная оценка будет. Ну чтобы доказать, опять надо будет повозиться с графами.
[57:23.300 --> 57:41.460]  Так, ну да, шлема первая. Пусть L это distance t, пусть F это величина максимального потока,
[57:41.460 --> 58:01.140]  а P это потенциал сети. Вот это вот P. Тогда L, не помню, надо списать,
[58:01.140 --> 58:22.180]  меньше это равно, чем 1 плюс P делить на F. Доказательства. Давайте нарисуем слоистую сеть.
[58:22.180 --> 58:39.460]  Вот наша слоистая сеть, выделим в ней все слои. Это будет в L минус 1, t будет в L там
[58:39.460 --> 58:51.180]  слои, соответственно. И давайте в ней нарисуем наш вот этот поток F максимальный. Я утверждаю,
[58:51.180 --> 58:58.460]  что, ну давайте я введу обозначение, пусть P i t это сумма по всем V из V i, потенциал в вершинке V.
[58:58.460 --> 59:07.500]  Так вот, я утверждаю, что поток не больше, чем потенциал каждой конкретной доли для всех i от
[59:07.500 --> 59:16.660]  1 до L минус 1. На пальцах объяснений смотрите. Вот я рассматриваю какую-нибудь конкретную долю,
[59:16.660 --> 59:27.460]  вот V2, например. Что такое P i? Это для каждой вершины минимум из того, сколько сюда втекает,
[59:27.460 --> 59:33.420]  точнее сколько может втечь и сколько может вытечь. То есть по факту P от V это какое-то
[59:34.180 --> 59:38.900]  ограничение сверху на то сколько сквозь вершину протекает. Потому что втекает не больше, чем столько,
[59:38.900 --> 59:43.220]  вытекает не больше, чем столько, значит поток, идущий сквозь вершину не больше, чем минимум
[59:43.220 --> 59:49.220]  из них. P от нее дальше. Дальше. И так я для каждой вершины считаю Ограничение сверху на то сколько
[59:49.220 --> 59:54.620]  потока через нее протекает. Но тогда понятно, что поток от S до T он рано или поздно вот эту
[59:54.620 --> 01:00:03.340]  как бы проходит да то есть вот рано или поздно поток протекает сквозь очередную долю ну и
[01:00:03.340 --> 01:00:08.500]  понятно тогда что он не больше чем суммарный потенциал всех этих вершин f не больше чем чем
[01:00:08.500 --> 01:00:25.220]  pi значит да 1 плюс п делить на f еще раз нет это извините ага не это у меня осталось просто
[01:00:25.220 --> 01:00:31.700]  прошлого раза вот значит поток текущий сквозь долю не больше потенциал этой доли значит если
[01:00:31.700 --> 01:00:37.460]  это давайте вот такого рассуждения будет достаточно если мы хотим это чуть более формально
[01:00:37.460 --> 01:00:41.100]  доказать нам нужно будет на самом деле такое утверждение было бы нужно такое утверждение
[01:00:41.100 --> 01:00:46.740]  значит лемма о декомпозиции потока которая должна была быть на семинарах лемма декомпозиции
[01:00:46.740 --> 01:01:01.780]  потока что любой поток можно представить как сумму путей плюс циклов любой поток это сумма
[01:01:01.780 --> 01:01:12.180]  путей плюс сумма циклов вот ну циклы понятное дело вносят нулевой поток но как бы они фиктивно
[01:01:12.180 --> 01:01:17.820]  могут какие-то эвки добавлять на ком-то цикле и не не вносить содержательного вклада в настоящий
[01:01:17.820 --> 01:01:26.460]  поток вот а пути это ну пути там с единичным потоком как могут у нас здесь эти пути выглядеть
[01:01:26.460 --> 01:01:33.220]  если он вот такой вот просто слева направо то это прям идеальный поток он как раз проходит
[01:01:33.220 --> 01:01:38.020]  через каждую через каждую долю ровно один раз и смотрите он задействует единичку входного
[01:01:38.020 --> 01:01:43.180]  единичку входного капасти вершину и выходного капасти из вершины поэтому как раз ну вот там
[01:01:43.180 --> 01:01:49.660]  единичка потока равна единичке вот которая может сюда втечь и вычесть вытечь бывают еще правда
[01:01:49.660 --> 01:01:56.100]  плохие пути какие-то вот такие вот например которые многократно через нашу долю через
[01:01:56.100 --> 01:02:01.420]  нашу долю протекают но тогда смотрите единица потока обеспечивал нам сразу много капасти вот
[01:02:01.420 --> 01:02:05.700]  здесь вот единичка втекла вытекла здесь единичку вышли и здесь еще единичку ушли то есть чтобы
[01:02:05.700 --> 01:02:12.980]  пустить единицу потока я потратил аж три capacity вот здесь одна здесь другая здесь третья поэтому
[01:02:12.980 --> 01:02:17.780]  f не больше чем чем суммарно p и ну и там если вот формально все эти пути расписать то будет как
[01:02:17.780 --> 01:02:25.020]  раз такая оценка что поток не больше чем чем чем потенциал вот она пальцах это просто сколько
[01:02:25.020 --> 01:02:29.900]  потока протекает через вот вот этот разрез ну все теперь это просуммирую получу получу то что
[01:02:29.900 --> 01:02:43.620]  нужно значит суммируем по всем и суммируем по всем и получаем l минус 1 f не больше чем сумма
[01:02:43.620 --> 01:02:53.140]  п это не больше чем п потому что п это общий потенциал п это потенциал в доле в этой доле ну
[01:02:53.140 --> 01:02:57.780]  если я здесь поделю на f получится поделить на f и прибавлю единичку как раз или не больше чем 1
[01:02:57.780 --> 01:03:24.300]  плюс п на f лемма вторая потенциал сети величина постоянная и не зависит от того какой какой
[01:03:25.300 --> 01:03:45.180]  п не изменяется при переходе от g gf то есть если у меня был какой-то потенциал для старой сети g
[01:03:45.180 --> 01:03:50.540]  я пустил какой-то поток и перестроил нашу сеть то есть пришел к оставшему сети так вот я тоже
[01:03:50.540 --> 01:03:57.020]  что потенциал не изменяется но здесь нужно на самом деле добавить ремарку что в отсутствии
[01:03:57.020 --> 01:04:20.340]  рёбер ведущих в s или исходящих из t ведущих в s или исходящих из t ну понятно что эти рёбра
[01:04:20.340 --> 01:04:24.980]  бесполезные да есть у меня есть с и в него входят какие-то рёбра то я могу их смело удалить
[01:04:24.980 --> 01:04:31.580]  потому что нет смысла какой-то водичке в текать в с она отсюда вытекла как-то она сюда обратно
[01:04:31.580 --> 01:04:35.820]  попала и то и дальше потом пошла ну понятно что такие рёбра они как бы нам ничего не дают их можно
[01:04:35.820 --> 01:04:41.540]  смело удалить вот поэтому если их нет я могу то есть если они есть я могу их удалить или ему будет
[01:04:41.540 --> 01:04:51.020]  будет верна полностью доказательства ну тут все очень просто надо проследить за каждой вершиной
[01:04:51.020 --> 01:04:57.820]  что с ней происходит когда я пускаю какой-то поток вот если у меня был какой-то путь я по
[01:04:57.820 --> 01:05:08.020]  этому пути пустил f потока надо просто понять как у меня меняется c in c out значит вспоминаем
[01:05:08.020 --> 01:05:14.180]  что если я пустил v потока по sorry f потока по ребру у меня на самом деле по обратному
[01:05:14.180 --> 01:05:19.860]  ребру появляется минус f потока минус f потока соответственно здесь копасть уменьшилась на f
[01:05:19.860 --> 01:05:25.740]  здесь уменьшилась на f а на обратных ребрах наоборот увеличилась на f ну и отсюда все следует
[01:05:25.740 --> 01:05:37.620]  потому что давайте посмотрим на цин как поменялся цин как поменялась цин рассматриваем входящие
[01:05:37.620 --> 01:05:44.020]  ребра вот это вот и вот это вот здесь capacity упала на ц и а здесь увеличилась ссори здесь
[01:05:44.020 --> 01:05:49.620]  capacity упала на f а здесь увеличилась на f значит у нас сумма не изменилась плюс f минус
[01:05:49.620 --> 01:05:58.340]  поэтому при проталкивании f потока вдоль какого-то пути цин для вершины на этом пути не изменилась
[01:05:58.340 --> 01:06:07.300]  потому что здесь уменьшилась здесь увеличилась на f то же самое с ци аут как поменялась ци аут
[01:06:07.300 --> 01:06:17.020]  ну то же самое рассматриваем все исходящие ребра вот они два здесь упала на f здесь увеличилась
[01:06:17.020 --> 01:06:24.700]  на f осаточная capacity но поэтому ци аут тоже не изменилась то же самое плюс f минус f и так для
[01:06:24.700 --> 01:06:29.860]  всех вершин и какой бы поток я не пустил то есть если опускаю поток там да вот очередную порцию f
[01:06:29.860 --> 01:06:35.860]  потока пустил для любой промежуточной вершины у меня ци аут остались такими как были значит
[01:06:35.860 --> 01:06:43.460]  праут значит прадвэ тоже не изменилась но раз прадвэ не изменилась то и весь потенциал не
[01:06:43.460 --> 01:06:58.020]  изменился окей так ну все тогда мы готовы доказать эту теоремку
[01:06:58.020 --> 01:07:08.700]  тоже именная теорема корзанова
[01:07:08.700 --> 01:07:19.980]  теорема корзанова число итерации в алгоритме 1 не происходит корни из я
[01:07:19.980 --> 01:07:35.820]  число итерации в алгоритме 1 есть футы корень исп от корни сп от корни сп
[01:07:35.820 --> 01:07:51.700]  доказательства давайте мы запустим алгоритм 1 на корень исп итерации вот нам нам разрешили
[01:07:51.700 --> 01:08:10.100]  от корни сп давайте корни сп запустим запустим первые корни сп итерации алгоритма 1 если он
[01:08:10.100 --> 01:08:16.540]  успеет завершиться за эти корни сп итерации то мы же победили если он закончился то ну число
[01:08:16.540 --> 01:08:23.300]  итерации есть вот корни сп значит если он не закончился если он не закончился мы можем написать
[01:08:23.300 --> 01:08:31.860]  что дист ст больше либо равно корни сп потому что по одной из лям которые мы когда-то доказали мы
[01:08:31.860 --> 01:08:37.500]  знаем что после каждой алгоритма 1 расстояние восстанчивой сети между стт увеличивается хотя
[01:08:37.500 --> 01:08:42.460]  бы на 1 каждый раз увеличивается если я сделаю столько итераций то после этого количества
[01:08:43.020 --> 01:08:50.660]  расстояние будет хотя бы число итерации хотя бы корень сп то есть смотрите я я пустил сколько
[01:08:50.660 --> 01:08:57.260]  это раций пустил какой-то поток дальше восстанчивой сети у меня расстояние хотя бы корень исп давайте
[01:08:57.260 --> 01:09:15.500]  тогда посмотрим на лему 1 пусть давайте применим лему 1 к остаточной сети в ней л это дист ст хотя
[01:09:15.500 --> 01:09:24.060]  бы корни сп f это сколько потока осталось пустить до самого конца до победы сколько осталось пустить
[01:09:24.540 --> 01:09:35.140]  сколько осталось пустить потока на дополнение до максимально вот я уже сколько допустил
[01:09:35.140 --> 01:09:38.980]  рассматривать столько осталось до конца вот это вот f максимальный поток восстанчивой
[01:09:38.980 --> 01:09:45.780]  сети это сколько осталось потока вот ну а потенциал п это потенциал исходной сети
[01:09:45.780 --> 01:09:56.220]  Давайте я напишу так. p от g f равно p от g. Это по второй лемме. Потому что потенциал не
[01:09:56.220 --> 01:10:03.420]  меняется при переходе касашной сети. По второй лемме. Ну все, теперь применяем первую лему вот
[01:10:03.420 --> 01:10:12.060]  к этим числам, что-то получаем. l не больше чем 1 плюс p на f. Дальше оцениваю l снизу корнем из p,
[01:10:12.060 --> 01:10:22.900]  и решаю это как неравенство относительно f. Получится p делить на f больше или равно корень
[01:10:22.900 --> 01:10:35.780]  из p минус 1. Ну наверное там все числа положительные, поэтому f меньше либо равно p делить на корень из p
[01:10:36.060 --> 01:10:49.620]  и singing f-1. Cколько осталось пустить потока f не больше, чем p делить на корень из p минус 1,
[01:10:49.620 --> 01:10:57.840]  ну это примерно корень из p. Если бы не былоUM-1, бы просто был корень из p. Ну подумайте,
[01:10:57.840 --> 01:11:04.260]  асимптати joue не влияет ни на что. Осталось пустить потока от корня из p. Ну значит понятно,
[01:11:04.260 --> 01:11:08.260]  не больше, чем от корни СП, потому что каждый террация хотя бы единичку потока-то находит.
[01:11:08.260 --> 01:11:13.260]  Каждая террация строит слоистую сеть, в ней находит поток блокирующий,
[01:11:13.260 --> 01:11:16.260]  и понятно, что он положительный, потому что есть путь из С в Т.
[01:11:16.260 --> 01:11:22.260]  Значит, суммарно осталось до конца террации не больше, чем f, то есть не больше, чем от корни СП.
[01:11:22.260 --> 01:11:24.260]  Значит, давайте здесь напишу.
[01:11:24.260 --> 01:11:31.260]  Значит, осталось от корни СП террации.
[01:11:35.260 --> 01:11:40.260]  Конец. Мы сделали корень СП террации, потом еще осталось сделать от корни СП.
[01:11:40.260 --> 01:11:42.260]  Суммарно это от корни СП.
[01:11:52.260 --> 01:11:57.260]  Так, вопросики есть?
[01:12:04.260 --> 01:12:06.260]  Ну вот, хорошо.
[01:12:11.260 --> 01:12:14.260]  Значит, давайте тогда пример один я напишу.
[01:12:14.260 --> 01:12:16.260]  Идиничные сети.
[01:12:22.260 --> 01:12:26.260]  Значит, сеть называется единичной, если в ней все капасти от 0 или единицы.
[01:12:34.260 --> 01:12:39.260]  В ней, во-первых, П это от Е.
[01:12:43.260 --> 01:12:46.260]  Ну, потому что давайте напишем, что давайте я напишу вот так.
[01:12:46.260 --> 01:12:48.260]  Я здесь только так умею это нормально объяснять.
[01:12:48.260 --> 01:12:50.260]  Ну, то есть В это минимум из C in и C out.
[01:12:56.260 --> 01:12:58.260]  Минимум не больше суммы.
[01:13:03.260 --> 01:13:05.260]  А это просто степень вершины В.
[01:13:08.260 --> 01:13:10.260]  Сколько ребер входит, плюс сколько выходит.
[01:13:14.260 --> 01:13:16.260]  Ну, значит, П.
[01:13:19.260 --> 01:13:21.260]  Не больше суммы степней, то есть 2E.
[01:13:27.260 --> 01:13:29.260]  Поэтому П это от Е.
[01:13:33.260 --> 01:13:35.260]  Значит, число итерации будет от корни СЕ.
[01:13:36.260 --> 01:13:38.260]  Уже хорошо.
[01:13:38.260 --> 01:13:42.260]  От корни СП, но от корни СЕ итерации.
[01:13:42.260 --> 01:13:46.260]  Более того, мы можем оценить не только число итерации,
[01:13:46.260 --> 01:13:50.260]  но можем еще оценить, за сколько работает каждая итерация.
[01:13:52.260 --> 01:13:56.260]  Значит, за сколько работает каждая итерация.
[01:14:03.260 --> 01:14:05.260]  То есть за сколько работает пояс блокирующего потока.
[01:14:07.260 --> 01:14:09.260]  Вот я вот и жажду за О от Е.
[01:14:12.260 --> 01:14:16.260]  Значит, раньше блокирующий поток я умел искать за ВЕ.
[01:14:16.260 --> 01:14:20.260]  В произвольной сети, ну, в слоистой сети я ищу поток, блокирующий за ВЕ.
[01:14:20.260 --> 01:14:23.260]  А вот если она единичная, то на самом деле это работает,
[01:14:23.260 --> 01:14:26.260]  вот тот же самый алгоритм работает за просто О от Е.
[01:14:26.260 --> 01:14:31.260]  Потому что, давайте вспомним, да, как у нас работает каждый запуск ДФСа.
[01:14:31.260 --> 01:14:34.260]  Каждый запуск ДФСа находит какой-то путь из С в Т
[01:14:34.260 --> 01:14:38.260]  и еще какие-то ребра помечает помеченными, бесполезными,
[01:14:38.260 --> 01:14:40.260]  которые больше не обращаются.
[01:14:40.260 --> 01:14:44.260]  Ну, понятно, что суммарное количество ребер, которое я здесь посмотрел...
[01:14:45.260 --> 01:14:49.260]  Да, то есть самое важное следующее, что когда я нахожу какой-то путь,
[01:14:49.260 --> 01:14:52.260]  у меня все эти ребра сразу автоматически становятся насыщенными.
[01:14:52.260 --> 01:14:56.260]  Потому что все копасти единичные, вот в этой остаточности все копасти единичные,
[01:14:56.260 --> 01:14:58.260]  и когда я пускаю поток по какому-то пути,
[01:14:58.260 --> 01:15:01.260]  я могу сразу сказать, что эти ребра бесполезные.
[01:15:02.260 --> 01:15:06.260]  Поэтому у меня каждый ДФС работает за количество ребер,
[01:15:06.260 --> 01:15:09.260]  которые он помечает бесполезными, то есть он эти помечает бесполезными
[01:15:09.260 --> 01:15:12.260]  и эти сразу помечает бесполезными.
[01:15:12.260 --> 01:15:14.260]  Но значит суммарно все ДФС работают за число ребер.
[01:15:15.260 --> 01:15:18.260]  Просто потому, что каждый просмотр каждого ребра,
[01:15:18.260 --> 01:15:21.260]  либо он говорит, что он бесполезный, потому что из него нельзя добраться до Т,
[01:15:21.260 --> 01:15:24.260]  либо оно полезное, выпускаю вдоль него поток,
[01:15:24.260 --> 01:15:26.260]  он сразу насыщается и больше его брать нельзя.
[01:15:26.260 --> 01:15:28.260]  Оно сразу становится бесполезным.
[01:15:29.260 --> 01:15:33.260]  То есть причем любой просмотр ребра finestive,
[01:15:33.260 --> 01:15:36.260]  потому что любой просмотр ребра,
[01:15:36.260 --> 01:15:39.260]  давайте я напишу так, любое ребро просмотрено не более одного раза.
[01:15:39.260 --> 01:15:49.260]  Любое ребро просмотрено не больше одного раза.
[01:15:49.260 --> 01:15:54.260]  Ну а значит, суммарно это будет вот E.
[01:15:54.260 --> 01:15:57.260]  Вот, получается, если сеть единичная,
[01:15:57.260 --> 01:16:01.260]  то у меня столько итераций, и каждый работает за вот столько.
[01:16:01.260 --> 01:16:05.260]  Поэтому суммарно единица работает за E корней из E.
[01:16:05.260 --> 01:16:10.260]  Значит, алгоритм единица в единичных сетях
[01:16:13.260 --> 01:16:17.260]  будет работать за E корней из E.
[01:16:17.260 --> 01:16:32.260]  Ну и второй пример еще более стильный.
[01:16:32.260 --> 01:16:35.260]  Хотя мы, наверное, его не успеем.
[01:16:35.260 --> 01:16:40.260]  Давайте тогда, возможно, в следующий раз забудем про него.
[01:16:40.260 --> 01:16:42.260]  Все, спасибо, на сегодня закончили.
