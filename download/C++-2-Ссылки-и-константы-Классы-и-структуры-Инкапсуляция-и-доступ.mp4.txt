[00:00.000 --> 00:12.240]  Значит, все, давайте вернемся к делу. Я остановился на ссылках в прошлый раз.
[00:12.240 --> 00:35.840]  Так, напоминаю еще раз, что самое главное нужно было запомнить про ссылки. Значит,
[00:35.840 --> 00:44.840]  как в голове правильно их держать. Значит, ссылка это другое название для переменной.
[00:44.840 --> 00:55.720]  Если вы завели ссылку, то это значит, что отныне у и х неразличимы, и любое обращение к у это
[00:55.720 --> 01:04.280]  обращение к иксу. И на вопрос, правда ли, что от изменения у изменится и икс тоже,
[01:04.280 --> 01:10.960]  я бы ответил, что не икс тоже изменится, а именно он изменится, потому что у икс теперь то одно и
[01:10.960 --> 01:18.920]  тоже буквально. Но компилятор, впрочем, ссылки иногда хранит как указатели, когда не может
[01:18.920 --> 01:24.120]  просто сделать замену. Например, если вы по ссылке принимаете переменную функцию, то она будет
[01:24.120 --> 01:31.280]  как указатель передана. Ну, там еще и, например, если вы ссылку храните, ну, там мы разбирали,
[01:31.280 --> 01:37.280]  если вы храните ссылку то на одно, то на другое, в зависимости от каких-то runtime условий, то
[01:37.280 --> 01:43.040]  компилятор тоже будет вынужден ее хранить как указатель. Вот, по этой причине, когда вы функцию
[01:43.040 --> 01:48.240]  передаете имп по ссылке, вы несете некоторые накладные расходы по сравнению с тем, как если
[01:48.240 --> 01:54.080]  вы передавали его по значению, потому что передать имп по ссылке фактически это означает, что
[01:54.080 --> 02:01.160]  обращение к нему это будет разыменование указателя, но в остальном они будут неотличимы, то есть тот
[02:01.160 --> 02:06.600]  имп будет вести себя как будто это исходная переменная. Вот, если я, например, спрошу,
[02:06.600 --> 02:23.640]  какой адрес у y? Да, ну вот там скажу, cout, адрес y и адрес x. Это одно и то же или нет?
[02:23.640 --> 02:35.960]  Конечно, это одно и то же. Это адрес x будет просто. Тоже самое. Адрес той же самой переменной.
[02:36.600 --> 02:43.720]  Адрес той самой переменной. Нет, какой указатель? Никакой указатель не знаю.
[02:43.720 --> 02:57.000]  То, что она получила указатель, это вне нашего уровня абстракции. Это как оно реализовано в низком
[02:57.000 --> 03:03.240]  уровне. Задача компилятора сделать для вас ссылку и переменную неотличимой. И он это делает. Как он
[03:03.240 --> 03:08.240]  это реализует внутри? Ну да, с помощью указателей. Но для вас ссылка и переменная неотличимы,
[03:08.240 --> 03:13.800]  поэтому вы узнаете адрес исходной переменной, а не адрес какого-то там указателя. Дальше,
[03:13.800 --> 03:25.360]  что если я спрошу size of y? Ну я узнаю size of x. Размер ссылки узнать нельзя. Я могу узнать размер
[03:25.360 --> 03:32.560]  переменной, на которую ссылается. Но самой ссылки я не узнаю размер таким образом. Ну size of y,
[03:32.560 --> 03:37.480]  если я спрошу. Это будет size of x просто. 4 байта. То есть вы могли бы захотеть узнать,
[03:37.480 --> 03:42.000]  сколько байт ссылка в памяти занимает. Вы не узнаете. Вы только узнаете, сколько байт
[03:42.000 --> 03:52.640]  исходной переменной занимает в памяти. По факту она вероятно хранится как указатель. То есть
[03:52.640 --> 04:10.400]  занимает 8 байт, но вы это узнаете только вот. Ну например. Так, да. Да, отличный вопрос. Давайте
[04:10.400 --> 04:17.520]  как раз про это и поговорим. Можно ли объявить ссылку? Ну давайте сначала начнем с того ссылка на
[04:17.520 --> 04:28.760]  указатель. Это окей или нет? Вот я говорю int звездочка p равно, ну не знаю, null ptr и говорю int
[04:28.760 --> 04:39.520]  звездочка амперсант r равно p. Это нормально? Да, это абсолютно нормально. Я взял ссылку на указатель.
[04:39.520 --> 04:45.000]  Указатель это самостоятельный тип, а ссылка на... Ну то есть я просто назвал, я завел другое
[04:45.000 --> 04:51.040]  название для этого указателя. r и p это один и тот же указатель просто. Ну я сделал ссылку на указатель.
[04:51.040 --> 04:58.960]  А вот указатель на ссылку сделать нельзя, как и ссылку на ссылку. То есть вот так писать нельзя.
[04:58.960 --> 05:06.840]  Значит указатель на ссылку это бессмысленная конструкция. Это c и e. Ссылку на ссылку тоже
[05:06.840 --> 05:12.840]  сделать нельзя. Впрочем, если вы попытаетесь вот так написать, то это будет означать нечто другое,
[05:12.840 --> 05:25.600]  а не ссылку на ссылку. Вот, но я сейчас не буду даже вскрывать эту тему. Просто давайте пока считать,
[05:25.600 --> 05:33.480]  что так нельзя писать. Вот и значит, ну если вы знаете, что это такое, вы можете этим пользоваться,
[05:33.480 --> 05:43.280]  если вы правильно умеете пользоваться. Что? R-value ссылка. Я не рекомендую вам сейчас гуглить,
[05:43.280 --> 05:49.080]  вот. Во втором семестре вы настрадаетесь с ними. Вот. Я рекомендую вам пока считать,
[05:49.080 --> 05:55.000]  что их не существует. Если считать, что их не существует, возможно они обойдут вас стороной
[05:55.000 --> 05:58.880]  до конца этого семестра. Вот. В следующем семестре мы обязательно с ними поработаем,
[05:58.880 --> 06:02.080]  но пока без ущерба для понимания и даже с пользой для понимания можно считать,
[06:02.080 --> 06:07.480]  что такого не бывает и это нельзя так писать. Вот. Короче, ссылку на ссылку заводить нельзя.
[06:07.480 --> 06:19.320]  Нельзя заводить массив ссылок. Массив ссылок заводить нельзя. Ну, то есть вот так нельзя написать.
[06:19.320 --> 06:32.200]  Интомперсант А из 10, допустим. Все равно нельзя. Просто нельзя. Запрещено заводить массив ссылок.
[06:32.200 --> 06:47.800]  Вот. И вектор ссылок тоже нельзя. Ты пробовал? Продемонстрируй, я не верю. Я думаю,
[06:47.800 --> 06:55.680]  что вектор ссылок нельзя заводить. Возможно, с какого-то стандарта она стала можно. Вектор
[06:55.680 --> 07:05.080]  ссылок заводить нельзя по той же причине, что и... Ну, потому что внутри себя вектор же хранит
[07:05.080 --> 07:11.120]  указатель на T. А если T это ссылка, то получится, что у вас указатель на ссылку там внутри должен
[07:11.120 --> 07:20.320]  храниться. И это проблема. Так решил комитет по стандартизации. Но это бессмысленно. То есть
[07:20.320 --> 07:32.320]  это лишено здравого смысла. Что такое указатель на ссылку? Вектор ссылок нельзя заводить. Вектор
[07:32.320 --> 07:38.880]  ссылок нельзя заводить. Все. А какая ошибка, кстати, когда ты пытаешь завести вектор ссылок? Создать
[07:38.880 --> 07:43.560]  указатель на ссылку. Но это именно та причина. Потому что внутри, когда ты подставляешь вектор
[07:43.560 --> 07:50.480]  тип T, вот этот вот, у тебя там внутри образуется вот такой тип. Потому что он внутри такой массив
[07:50.480 --> 07:58.520]  пытается хранить. И все, у него не получится. А вот ссылку на массив можно. А как завести ссылку
[07:58.520 --> 08:09.760]  на массив? Ну, надо просто так же написать int вот так вот. Ну, допустим, у вас был другой массив,
[08:09.760 --> 08:15.920]  и вы сделали A с ссылкой на тот массив. Это ссылка на массив. Ну, как и указатель на массив,
[08:15.920 --> 08:23.920]  также есть ссылка на массив. Синтаксис такой же. То есть что с указателями, что со ссылками. Нет,
[08:23.920 --> 08:29.120]  мы ссылку пишем рядом с типом. Но если мы хотим вот так писать, то нам ничего не остается,
[08:29.120 --> 08:33.280]  как брать в скобки это. Потому что рядом уже не получится. Потому что это приоритет, ну,
[08:33.280 --> 08:40.480]  потому что иначе это будет массив ссылок, а так нельзя писать. Вот. Массив ссылок заводить нельзя.
[08:40.480 --> 08:51.800]  Ссылку на массив заводить можно. Ну, в первую очередь партия вот эта. Это ссылка на массив из 10
[08:51.800 --> 08:57.000]  int. Ну, в прошлый раз я разбирал довольно много примеров. Ссылками точно так же,
[08:57.000 --> 09:06.140]  как с указателями работает. Дальше. Можно... Вот смотрите, были функции, были указатели на
[09:06.140 --> 09:15.520]  функции. Отгадайте, что еще бывает. Ссылки на функции. Ссылки на функции. Можно завести ссылку на
[09:15.520 --> 09:23.560]  функцию. Почему нет? Ссылку на... Ну, ссылка на указатель можно. Это мы уже выясняли. Ссылку на указатель
[09:23.560 --> 09:30.400]  на функцию тоже можно. Но можно ссылку на функцию. То есть я могу сказать, ну, допустим, функция,
[09:30.400 --> 09:44.560]  которая возвращает void, амперсант f равно, ну, не знаю, g. g это некоторая функция. Теперь f — это та
[09:44.560 --> 09:54.160]  же самая функция, что и g. Ну, то есть... Я не знаю, какой в этом смысл. Там на stackoverflow есть вопрос,
[09:54.160 --> 09:59.280]  как всегда, в котором люди пытаются объяснить, зачем это, может быть, надо. Ну, мало ли,
[09:59.280 --> 10:04.320]  вдруг пригодится. Вот, кстати... А, да, еще ссылку на void заводить нельзя. Вот ссылку на void
[10:04.320 --> 10:08.600]  заводить нельзя. Вот если это без скобок написать, то это получится, как будто бы пытались объявить
[10:08.600 --> 10:15.260]  функцию, которая ничего не принимает и возвращает void, амперсант. Так нельзя. А вот ссылку на функцию,
[10:15.260 --> 10:22.160]  которая возвращает void, можно. Стоп, а ссылка, которая вообще возвращает, например, им, если функция
[10:22.160 --> 10:29.280]  возвращает ссылку на им. Да, это нормально совершенно. И такое даже часто будет нужно. Сейчас им, амперсант,
[10:30.280 --> 10:50.680]  какая? Вот эта? Это... Да, ну, она зачертнута. А, нет. Сейчас я про это поговорю. Это будет...
[10:50.680 --> 10:59.000]  Сейчас, короче, это отличный вопрос. Сейчас про его поговорим. Давайте пока еще пару того,
[10:59.000 --> 11:08.920]  чем можно и чем нельзя. Ну, ссылка на функцию. Окей. Значит, массив ссылок. Да, ссылка обязательно
[11:08.920 --> 11:14.000]  должна быть проинциализирована при создании, но мы это уже обсуждали. А еще ссылка обязательно
[11:14.000 --> 11:21.840]  должна быть проинциализирована посредством lvalue. Да, ну, то есть нельзя написать int амперсант
[11:21.840 --> 11:31.800]  там x равно 5. Это должна быть обязательно какая-то, ну, реально существующая переменная. Ну, то есть
[11:31.800 --> 11:38.480]  lvalue, чтобы это не значило. Ну, там написать int амперсант y равно plus plus x опять-таки можно,
[11:38.480 --> 11:44.480]  а вот написать x plus plus нельзя, потому что x plus plus возвращает временную копию,
[11:44.480 --> 11:48.960]  которая как бы не является реально существующей в памяти переменной, и поэтому на нее ссылаться
[11:48.960 --> 12:00.080]  нельзя. А вот на lvalue можно. Ну, это все равно, как если бы я сделал plus plus x, а потом int
[12:00.080 --> 12:09.880]  амперсант y равно x, да. Вопрос некорректный. В lvalue бывают выражения, а не переменные.
[12:09.880 --> 12:20.680]  Лишь про expression имеет смысл спрашивать, какое они lvalue. Что? Бывают, да, сейчас мы про них тоже
[12:20.680 --> 12:34.720]  поговорим. Так, если ты хотел спросить, является ли вот такое выражение, является ли выражение
[12:35.200 --> 12:46.040]  lvalue, если x-константная переменная нет, ну, является lvalue все еще. Так, ну хорошо. Значит, теперь,
[12:46.040 --> 12:54.160]  что я еще забыл сказать, значит, чем можно инициализировать, что можно то, это все нельзя.
[12:54.160 --> 13:00.840]  Хорошо, давайте теперь поговорим вот про эту проблему, про которую тут некоторые из вас
[13:00.840 --> 13:25.640]  спрашивали. Что будет, если я из функции решу вернуть ссылку? Тут не знаю, равно нулю. Вот я
[13:25.640 --> 13:31.080]  завел функцию, в которой завел локальную переменную и вернул наружу ссылку на нее.
[13:31.080 --> 13:45.280]  Значит, что будет, если я попытаюсь в дальнейшем использовать возвращаемое значение этой функции
[13:45.280 --> 13:56.280]  где-то в мейне, скажем. Значит, будет УБ, и это один из наиболее распространенных сценариев, как
[13:56.280 --> 14:03.600]  возникает УБ на практике. Это очень болезненный сценарий. Это называется DenGlingReference, висяча ссылка.
[14:03.600 --> 14:32.120]  Значит, что зачем нужно? Зачем? Так, с точки зрения компиляции я, конечно,
[14:32.120 --> 14:39.840]  могу написать вот так. Ну, F это как ссылка на Инт, я создаю новый Инт из того Инта. В чем проблема?
[14:39.840 --> 14:50.960]  Это с точки зрения компиляции. С точки зрения рантайма это уже УБ. Давайте я вам приведу пример,
[14:50.960 --> 15:09.320]  когда это не УБ. Что? Да. Как не скомпилируется? И так тоже скомпилируется. Я создал новый Инт из того
[15:09.320 --> 15:17.560]  Инта. В чем проблема? Вот здесь происходит копирование. Вот из того Инта, который там был,
[15:17.560 --> 15:27.840]  я создал новый Инт с таким значением, как там. Это компилируется, но это УБ, потому что ссылка
[15:27.840 --> 15:34.920]  указывает на переменную, которая уже реально уничтожена в памяти. Ссылка ссылается на локальную
[15:34.920 --> 15:39.600]  переменную этой функции, но при выходе из функции локальная переменная снялась со стека, и у вас
[15:39.600 --> 15:44.800]  фактически вы обращаетесь к участку памяти, на котором раньше лежала та локальная переменная,
[15:44.800 --> 15:57.000]  но она уже снята со стека, и это УБ. Хоть это и скомпилируется, но это УБ. Да, вот если,
[15:57.000 --> 16:06.120]  например, вам в функцию передали переменную, вот если вам передали переменную по ссылке,
[16:06.120 --> 16:14.160]  то вы можете вернуть опять же ссылку на нее, и тогда все будет корректно. И с амперсандом
[16:14.160 --> 16:21.080]  все будет корректно. Но если вам передали по значению, то опять УБ, потому что это же снова
[16:21.080 --> 16:25.400]  локальная переменная получается. Она на стек кладется вместе с локальными переменными функциями.
[16:25.400 --> 16:29.200]  Опять, когда вы возвращаетесь с функции, она снимается со стека, значит вы ссылаетесь уже
[16:29.200 --> 16:42.440]  на нелегальную память. Почему это не CE? Догадайтесь. Так решил комитет по стандартизации.
[16:42.440 --> 16:54.680]  Значит, что? Х – это локальная переменная для данной функции. Когда я возвращаюсь из
[16:54.680 --> 17:06.400]  функции, х снимается со стека. Значит, да, это хороший вопрос, почему компилятор не ловит это в
[17:06.400 --> 17:14.520]  compile-time? Кажется, что, вот я не уверен, но кажется это алгоритмически возможно было бы отлавливать.
[17:14.520 --> 17:24.440]  То есть, всякий раз, когда я пытаюсь вернуть из функции что-то, ссылку на переменную область,
[17:24.440 --> 17:29.680]  время жизни которой заканчивается вместе с этой функцией, кажется это можно было бы отлавливать
[17:29.680 --> 17:45.880]  в compile-time. Ну вот, мы можем с помощью тернардного оператора намутить что-нибудь такое, типа я
[17:45.880 --> 17:52.440]  ссылаюсь на переменную, которая при одном условии глобальная, при одном условии локальная. То есть,
[17:52.440 --> 17:59.200]  можно было бы на этапе компиляции запретить и все это вообще такое, такие действия? Это warning,
[17:59.200 --> 18:04.120]  да. Почему это не ошибка компиляции? Честно говоря, я не знаю, почему они этого не сделают. Возможно...
[18:04.120 --> 18:12.120]  Ну не всегда. Ну не всегда. В некоторых случаях замечать, в некоторых нет.
[18:12.120 --> 18:34.840]  Если мы x создадим через new, если x это будет переменная из динамической памяти,
[18:34.840 --> 18:39.320]  или это будет глобальная переменная или статическая переменная, то да, конечно,
[18:39.320 --> 18:44.160]  на нее ссылку возвращать нормально. Вот. А если вы возвращаете ссылку на кальву переменную,
[18:44.160 --> 18:55.040]  то это denlin-reference, это уб классическая. Кого? Ну если вы здесь напишете int звездочка p равно newint,
[18:55.040 --> 19:04.680]  а потом скажете return звездочка p, то это, конечно же, окей. Потому что под p лежит динамическая
[19:04.680 --> 19:10.440]  переменная, и вы, более того, вы даже не потеряли тем самым указательную, потому что вы можете потом
[19:10.440 --> 19:24.920]  delete, delete ampersand p сделать извне, и это будет нормально работать. Вот. Так, окей. В чем прикол
[19:24.920 --> 19:29.680]  возвращать ссылки из функций? А просто тогда присваивать можно будет. Например, можно вот так
[19:29.680 --> 19:43.840]  написать. Что? Ну. Указатель указывает на динамическую память. Я вернул переменную,
[19:43.840 --> 19:54.120]  дальше я могу адрес взять. Конечно. Переменная лежит в динамической памяти. Вот у меня stack,
[19:54.120 --> 20:02.760]  а вот динамическая память. Вот мой указатель указывает сюда. И что? Если я снова возьму адрес
[20:02.760 --> 20:11.120]  этой переменной, то я получу адрес того же самого куска памяти. Нет, я же не видел delete,
[20:11.120 --> 20:22.480]  не вызвал delete. Вот когда я вызову извне. Что? Этот указатель указывает куда-то в динамическую
[20:22.480 --> 20:37.280]  память. Я взял то, что под ним. Получил. Ну да, тут, конечно, интересно. Тут такое. Ну да, а что?
[20:37.280 --> 20:47.080]  Какой у него еще может быть адрес? Ну да, да, да. Ну дальше, если вы возьмете адрес, то я думаю,
[20:47.080 --> 20:53.160]  да, все будет хорошо. Ну должно быть хорошо. Вы получите снова адрес того же самой переменной.
[20:53.160 --> 21:02.480]  Она все еще в динамической памяти. Так, окей, это была проблема висячих ссылок. Какие-то еще там
[21:02.480 --> 21:17.480]  вопросы были про ссылки. Ссылку на контест? Ссылка на указатель можно, ссылку на массив можно,
[21:17.480 --> 21:45.120]  ссылку на функцию можно, ссылку на контест нельзя. Так, последнее, что я хочу сказать про ссылки,
[21:45.120 --> 21:50.200]  вот что. Допустим, вы решили сделать такую перегрузку функций. У вас есть функция,
[21:50.200 --> 22:00.840]  которая принимает int и функция, которая принимает int&. Вот, можно ли такую перегрузку сделать?
[22:00.840 --> 22:08.800]  Нельзя, потому что тогда получается вы бы сумели отличать ссылки от исходных. Да, ну,
[22:08.800 --> 22:15.040]  то есть это заблуждение, что, допустим, если вы заведете такую функцию и такую функцию, то когда
[22:15.040 --> 22:19.000]  вы вызоветесь от х, вы поведете первую, когда вы вызоветесь от y, вы поведете во вторую. Нет,
[22:19.000 --> 22:27.360]  нет, ничего подобного. Вот, ну, ты правильно думаешь. Это часто встречающиеся заблуждения. Люди
[22:27.360 --> 22:35.280]  думают, ну ладно, ну я заведу две функции, таким образом отличу х от y. Нет, ничего подобного. Просто
[22:35.280 --> 22:39.640]  вам запретят объявить две такие функции, потому что нельзя перегружать. Ну, я на самом деле не знаю,
[22:39.640 --> 22:44.160]  в какой именно момент возникнет ce, в момент, когда вы, наверное, в момент, когда вы их объявите,
[22:44.160 --> 22:48.360]  определить еще не возникнет, потому что типы формально разные. Но когда вы вызываться будете,
[22:48.360 --> 22:53.640]  у вас будет ambiguous call, потому что что сюда пойти, что сюда пойти, разницы нет для него. Это одинаково
[22:53.640 --> 23:01.440]  хорошо. Ну, я думал плохо или хорошо сказать, но это хорошо, это почти нет приведений типов.
[23:01.440 --> 23:15.320]  Ну, формально с точки зрения компилятора все-таки есть, но для вас видимость как будто нет. Ну,
[23:15.320 --> 23:19.200]  если вы почитаете формально правила разрешения перегрузки, там про ссылки тоже есть параграф,
[23:19.200 --> 23:30.040]  что если там амперсант, тут нет амперсанта, но это мы забьем. Ну да-да-да-да-да. Компилятор
[23:30.040 --> 23:38.800]  реализует это так, но это разные типы формально, но для вас не отличимые. В чем проявляется,
[23:38.800 --> 23:46.160]  почему это? Ну, давай. Я про конс пока не говорил, про конс будет следующий параграф,
[23:46.360 --> 23:53.120]  я сейчас к нему перейду. Для компилятора существенно, что это разные типы, потому что в случае
[23:53.120 --> 23:58.120]  снятия одного из них со стека нужно уничтожать, а в случае другого не нужно уничтожать реальный
[23:58.120 --> 24:05.080]  объект. Вы это, мы это обсуждали в прошлый раз. Ну, я еще раз повторю, что это ключевое вот,
[24:05.080 --> 24:11.440]  что есть в плюсах, вот эти ссылки, потому что в джаве, в питоне вы с ними, у вас нет ссылок,
[24:11.440 --> 24:18.000]  вы просто, когда пишете вектор b равно a, вы на самом деле создаете, вы ссылаетесь на тот
[24:18.000 --> 24:22.400]  же самый вектор, вы не указываете явно ссылку, но это приводит к тому, что ему в рантайме нужно
[24:22.400 --> 24:26.960]  считать количество ссылок, указывающих на каждый объект, чтобы вовремя удалять. За счет того,
[24:26.960 --> 24:32.920]  что в плюсах мы явно указываем, когда мы делаем ссылку, в компайл тайме понятно, в какой момент
[24:32.920 --> 24:37.440]  нужно что уничтожать, а в какой не нужно. Когда отмирает ссылка, уничтожать сам объект не нужно,
[24:37.440 --> 24:45.520]  когда отмирает настоящий объект, тогда его очень нажать нужно. Кто сам не удаляет? Сборки
[24:45.520 --> 24:53.560]  мусора нет, да, но это тоже правда, у нас еще сборка мусора должна была бы быть. Все, про ссылки,
[24:53.560 --> 25:00.160]  ну пока все, то есть это тема, к которой нам предстоит возвращаться еще неоднократно. Вот,
[25:00.160 --> 25:13.360]  а теперь константы. Это предпоследняя тема перед началом большой эпопеи. Итак, предпоследняя тема
[25:13.360 --> 25:31.040]  это константы. Можно объявить константную переменную, но я опять буду в примере ИНТА.
[25:43.360 --> 25:52.720]  Что такое константный ИНТ? Что вообще такое константный Т, где Т некоторый тип? Нет,
[25:52.720 --> 25:59.960]  подождите, вы вообще на какой вопрос пытаетесь ответить? Я пытаюсь понять, что это за тип такой?
[25:59.960 --> 26:19.760]  Какое value? Я пока ничего не говорю про value. Ну не с одним. Я думаю, все вы пользуетесь константами
[26:19.760 --> 26:26.400]  хоть раз в жизни. Я попытаюсь сейчас точно так же, как я навел правильную интуицию насчет ссылок,
[26:26.560 --> 26:30.840]  как нужно мыслить о ссылках. Я сейчас попытаюсь донести, как нужно правильно мыслить о константах,
[26:30.840 --> 26:39.120]  чтобы у вас правильно отгадывать, что произойдет в разных ситуациях. Какая должна быть правильная
[26:39.120 --> 26:46.160]  интуиция о том, что такое константный тип? Это такой же тип, как и исходный, но это другой тип,
[26:46.160 --> 26:52.120]  и отличается от исходного он тем, что в нем некоторые операции запрещены просто. Ну вот,
[26:52.120 --> 26:58.080]  я в свое время, когда мне первый раз рассказывали про константы, и когда я вообще с ними работал в
[26:58.080 --> 27:04.400]  плюсах, константы это еще одна очень большая боль, как и ссылки. Если вы с самого начала
[27:04.400 --> 27:08.440]  неправильно себе представляете, что такое константы, у вас какая-то неправильная в голове модель мира
[27:08.440 --> 27:14.400]  относительно них, то вы будете не отгадывать, что будет происходить, вы будете постоянно напарываться
[27:14.400 --> 27:18.480]  на то, что происходит какая-то дичь неожиданная для вас. Как нужно правильно мыслить о константах?
[27:18.480 --> 27:23.240]  Просто представляйте их себе как тип с урезанным функционалом. У вас есть, не знаю,
[27:23.240 --> 27:31.040]  рациональные числа, в них еще деление определено, а вот в натуральных не определено. Ну, на множество
[27:31.040 --> 27:36.120]  натуральных чисел нельзя делить, потому что ты выскочишь из множества. Ну типа если рассматриваешь,
[27:36.120 --> 27:43.200]  не знаю, вы можете рассматривать целые числа, и там есть сложение, вычитание, умножение. А можете
[27:43.200 --> 27:45.400]  рассматривать рациональные числа, там есть сложение,
[27:45.400 --> 27:46.400]  вычитание и множение деления.
[27:46.400 --> 27:53.720]  Вот, ну то есть это просто тип, у которого части операции
[27:53.720 --> 27:54.720]  отсутствуют.
[27:54.720 --> 28:05.880]  Вот, значит, константный тип, это тип, во всем похожий
[28:05.880 --> 28:08.520]  на исходный, с той разницей, что часть операции в нем
[28:08.520 --> 28:10.360]  отсутствует просто.
[28:10.360 --> 28:12.760]  Вот это правильная интуиция относительно констант.
[28:12.760 --> 28:16.440]  Вот, ну а какие в нем операции отсутствуют?
[28:16.440 --> 28:18.220]  А в нем отсутствуют… Да.
[28:18.220 --> 28:19.300]  Они взяли копию пасты и вырезали нескольких
[28:19.300 --> 28:20.580]  пластов, да?
[28:21.800 --> 28:22.860]  Ну, типа, примерно.
[28:22.860 --> 28:25.120]  Ну, какие операции в нем отсутствуют по сравнению
[28:25.120 --> 28:26.560]  с обычным int?
[28:26.560 --> 28:29.980]  А вот как раз те, которые модифицируют этот аргумент.
[28:29.980 --> 28:33.400]  Ну, то, что они модифицируют этот аргумент, это как
[28:33.400 --> 28:34.960]  раз вторично.
[28:34.960 --> 28:37.880]  Вот первично, то, что они у константа отсутствуют.
[28:37.880 --> 28:40.260]  Вот, операции как раз называются модифицирующими, если они
[28:40.260 --> 28:41.440]  у константа отсутствуют.
[28:41.440 --> 28:47.320]  То есть формально операция может ничего не менять с переменной, ну по факту она может не
[28:47.320 --> 28:56.760]  менять с переменной, но если она не разрешена для констант, она считается модифицирующей.
[28:56.760 --> 29:03.680]  Ну это довольно сложно понять на примере int, это будет понятно, когда вы будете свои классы писать,
[29:03.680 --> 29:08.540]  и вы поймете, что далеко не всегда операция, запрещённая для констант, на самом деле что-то
[29:08.540 --> 29:13.140]  меняет. Она может ничего не менять, просто быть запрещённой для констант. Ну констант просто часть
[29:13.140 --> 29:25.260]  операции отсутствует. Давай не будем, я понимаю о чём ты говоришь, ты забегаешь вперёд, пока не надо
[29:25.260 --> 29:42.760]  про это. Потому что констант и компилятор может соптимизировать и встроить в код прям.
[29:42.760 --> 29:56.740]  Давайте по порядку, давайте по порядку. Сначала какие операции запрещены? Ну какие? Присваивание
[29:56.740 --> 30:02.500]  запрещено и все составные присваивания, понятно, вот с левым аргументом константа не запрещены.
[30:02.500 --> 30:16.120]  Инкремент и декремент запрещен. Что ещё запрещено? Все вроде. Нет, это уже другое,
[30:16.120 --> 30:21.640]  это уже сейчас приведение. Ну вот по сути да, чем отличается константный int от неконстантного?
[30:21.640 --> 30:25.600]  У константового просто отсутствует часть операции, вот эти операции отсутствуют, возможно ещё какие-то,
[30:25.600 --> 30:32.400]  я забыл. Вот эти операции, они потому и называются неконстантными, что у константа отсутствует. Ну то
[30:32.420 --> 30:39.100]  есть попытка вызвать любую из этих операций над левым аргументом. X это будет CE. Просто нет
[30:39.100 --> 30:50.300]  такой операции. Вот, но это не отменяет того, что X это L-value. И вот вам пример L-value,
[30:50.300 --> 30:59.260]  которому нельзя присваивать ещё один. Ещё один пример был R-massive. Что? По определению. Ну
[30:59.260 --> 31:06.720]  переменная это L-value. Вид value определяется синтаксически по виду выражения. Вот если у вас
[31:06.720 --> 31:11.520]  просто переменная, то это L-value. Если у вас префиксный инкремент, то это L-value. Если постфиксинг,
[31:11.520 --> 31:17.400]  то R-value и так далее. Это не зависит от того, какой там тип. Ну, почти не зависит. Если вы свой
[31:17.400 --> 31:22.000]  напишете, вы можете всё испортить. В общем, это вот ещё один пример L-value, которому нельзя
[31:22.000 --> 31:27.040]  присваивать. Но не берите в голову, забейте сейчас на то, какой это вид value. Это я так в сторону
[31:27.040 --> 31:33.140]  немножко ушёл. Короче, нельзя присваивать и нельзя инкрементировать. Так, какие были вопросы
[31:33.140 --> 31:39.340]  про константы? Ну давай. Можно ли как-то захакивать константы и изменить значение,
[31:39.340 --> 31:49.540]  которое по ней лежит? Можно. Можно. Но про это я расскажу в параграфе 2.7. Давайте другой вопрос
[31:49.540 --> 31:58.940]  какой-нибудь пока. А, да. Зачем нужны константы? На самом деле, я бы сказал так. Вообще константы,
[31:58.940 --> 32:09.020]  я тут уж не знаю, имею ли я моральное право судить, значит, создателя за такое решение. Но вот
[32:09.020 --> 32:14.260]  помните, я вам говорил, что неявные касты — это одна из больших ошибок в проектировании C++ была,
[32:14.260 --> 32:20.660]  по мнению самого создателя. Вот. Константы в том виде, в каком они существуют в языке C++ — это
[32:20.660 --> 32:26.540]  очень, ну я не уверен прям, что это очень большая ошибка, но это большое неудобство. Если бы константы
[32:26.540 --> 32:31.500]  были изначально спроектированы иначе, то писать на плюсах было бы гораздо проще. Вот. Дело в том,
[32:31.500 --> 32:37.220]  что в плюсах всякий раз, когда вы хотите запретить менять объект, вам нужно явно это сказать. А когда
[32:37.220 --> 32:40.940]  вы не хотите запрещать, вам не нужно ничего говорить. То есть, по умолчанию, то, что вы
[32:40.940 --> 32:46.420]  пишете изменяемо, пока вы явно не скажете, что оно не изменяемо. Странно. Логичнее было бы
[32:46.420 --> 32:52.420]  сделать наоборот. Потому что в одном случае вы всегда забываете сказать, что оно изменяемо,
[32:52.420 --> 32:57.220]  не изменяемо, потому что ошибки-то нет. Когда вы написали и пытаетесь изменить, ошибки нет. А
[32:57.220 --> 33:06.460]  когда вы пытаетесь сделать наоборот, ну короче, если бы система была наоборот устроена, то вам бы
[33:06.460 --> 33:12.580]  компилятор просто говорил всякий раз и забыл написать здесь слово изменяемый. Вот. Поэтому путаница
[33:12.580 --> 33:17.580]  очень большая с константами возникает из-за того, что нужно все время помнить, держать в уме вот
[33:17.580 --> 33:21.780]  это вот самому. А это константы или не константы? Если константы, то мне надо обязательно писать
[33:21.780 --> 33:33.060]  конст. По-моему, в Rust-е что-то попытались сделать наоборот, но я не уверен. Я не знаю Rust. Вот.
[33:33.060 --> 33:44.420]  Но, короче, да. Зачем нужны константы? Ну, про то, что там это какая-то ошибка, это вперед забежал
[33:44.420 --> 33:51.580]  опять-таки. Пока первоначально нужны еще константы. Ну, чтобы объявить в коде какую-то величину,
[33:51.580 --> 33:55.260]  которая меняться не будет. Что за глупый вопрос? Зачем же константы? Ну как? Вот вам захотелось,
[33:55.260 --> 34:01.380]  не знаю, какой-то вот констинт модулус равной, там, какой сейчас принято делать, я забыл,
[34:01.380 --> 34:11.100]  вот это число классическое. Вот он у нас сквозь... Нет, там сейчас, там сейчас, да, там сейчас в моде
[34:11.100 --> 34:18.620]  какой-то другой, по-моему, стал. Ну, короче, да. Ну вот вам захотелось сделать просто число,
[34:18.620 --> 34:22.820]  которое не меняется в течение работы программы. Вы его назвали константой. Отныне попытки его
[34:22.820 --> 34:27.700]  изменить будут приводить к CE. Вот. А что это еще вам дает? А это вам дает то, что компилятор,
[34:27.700 --> 34:33.220]  видя, что вы написали конст, он может опять-таки не заводить под это реально в памяти ячейку,
[34:33.220 --> 34:38.020]  а просто ваши выражения подставить сразу и предвычислить даже некоторые из них. Вот,
[34:38.020 --> 34:41.780]  естественно, компилятор видит, что вы объявили что-то константой, он имеет право в целях
[34:41.780 --> 34:47.540]  оптимизации взять и просто подставить, ну, захардкодить это число в те места, где вы его
[34:47.540 --> 34:52.500]  используете. И даже предвычислить некоторые выражения прямо в compile-time, если он понимает,
[34:52.500 --> 34:59.140]  что и так понятно здесь, что будет деление на два, например. Ну, например, вот у вас x это,
[34:59.140 --> 35:05.500]  скажем там, 16, когда степень двойки. Компилятор, зная, что это 16, оно никогда не будет меняться,
[35:05.500 --> 35:09.900]  может деление на x заменить просто побитым сдвигом на 4, потому что он же понимает,
[35:09.900 --> 35:14.220]  что оно не изменится и, значит, он эффективнее может оптимизировать. Вот зачем нужны константы.
[35:14.220 --> 35:25.020]  Вот, но все становится интересней, когда на арену выходят указатели со ссылками. Да,
[35:25.020 --> 35:32.580]  ну давайте сначала просто, вот если я говорю, constant x равно 5, int y равно x, так можно? Ну,
[35:32.580 --> 35:40.180]  конечно, можно. Я просто создал новый int из того, и этот int это уже другой, это не тот же самый,
[35:40.180 --> 35:54.060]  он изменяемый. Вот, ладно, ну и, конечно, я могу сказать const int z равно y. Я создал еще один int из
[35:54.060 --> 36:02.260]  того, этот z теперь не изменяемый, но это все три разных int. Вот, что происходит, если я с
[36:02.260 --> 36:14.900]  указателями пытаюсь работать. Окей, вот у меня есть const int x равно 5. Могу ли я сказать int
[36:14.900 --> 36:30.420]  звездочка p равно адрес x? Нет, CE, нарушение константности, потому что указатель на int это
[36:30.420 --> 36:36.620]  такая сущность, которая подразумевает, что разыменовав ее, вы получите int. То есть менять можете
[36:36.620 --> 36:48.860]  то, что под ним. Вот, но здесь вы не должны уметь менять то, что вы разыменовываете. Int звездочка
[36:48.860 --> 36:56.460]  это такой тип, что по операции разыменования он возвращает просто int. Ну, если быть точным,
[36:56.460 --> 37:07.380]  ссылку на int. Вот. Ну, считайте, что просто int. Вот. И поэтому такая фигня не скомпилируется,
[37:07.380 --> 37:12.980]  потому что у вас будет нарушение константности, вы тогда получаете разыменовывать, сможете менять,
[37:12.980 --> 37:17.900]  они должны. Поэтому, если вы хотите указывать на констант, то вам надо const повторять,
[37:18.900 --> 37:27.740]  const int звездочка p равно да. Это замечательный вопрос, очень правильный. Хорошо, вот я написал
[37:27.740 --> 37:39.900]  const int звездочка p равно %x, а могу я сказать plus plus p? Могу, конечно, потому что это указатель
[37:39.900 --> 37:51.260]  на константный int, а вовсе не константный указатель на int. Если я хочу сделать указатель,
[37:51.260 --> 37:58.780]  который нельзя менять, то это пишется так. Я пишу int звездочка и const справа от звездочки.
[37:58.780 --> 38:10.700]  Это указатель, менять который нельзя. Вот это константный аналог int звездочки. То есть вот
[38:10.700 --> 38:18.100]  к этому b уже не применимо, plus plus, к самому b не применимо. Но если я разыменую b, я получу
[38:18.100 --> 38:22.700]  просто int, и вот то, что под ним, то есть результат разыменования, я могу менять,
[38:22.700 --> 38:29.300]  что хочу делать. Я могу написать const int звездочка const, и это будет означать,
[38:29.300 --> 38:34.100]  что ни сам указатель сдвигать присваивать нельзя, ни после разыменования, то что под
[38:34.100 --> 38:45.540]  ним сдвигать присваивать нельзя. Да, можно написать int const звездочка const. Надо запомнить,
[38:45.540 --> 38:50.660]  если const перед звездочкой, то это означает, что он относится к тому, что под указателем,
[38:50.660 --> 38:56.460]  а если const справа от звездочки после звездочки, то значит этот const относится к самому указателю.
[38:56.460 --> 39:13.020]  Значит тест. Это что я сейчас объявил?
[39:13.020 --> 39:29.660]  Почему? Нет, все нормально, но тут надо только правильный инициализатор написать, но я могу
[39:29.660 --> 39:37.900]  написать на lptr, что я отупарюсь. Константный указатель на указатель, на константный указатель,
[39:38.740 --> 39:46.660]  ну то есть сам этот указатель менять нельзя, но то, что под ним менять можно, а то, что дважды
[39:46.660 --> 39:57.860]  под ним менять опять нельзя, то, что трижды под ним менять опять можно. Что? Бьёрн Страуструп,
[39:57.860 --> 40:08.420]  я рассказывал на первой лекции. Чё вы такие вопросы? Не смейте оскорблять создателя. В СИ не было
[40:08.420 --> 40:20.020]  const, их потом ввели, но изначально в СИ не было const, как из ссылок. Константный указатель
[40:20.020 --> 40:41.940]  на указатель, на константный указатель на int. Да, это очень мудрая мысль, кстати. Наверное,
[40:41.940 --> 40:46.660]  поэтому так и сделано. Потому что изначально не додумались добавить const, но об этом не подумали,
[40:46.660 --> 40:54.740]  блин, это какие годы были, там 70-80-е годы? Господи, ну да, то есть ещё раньше, ну то есть тогда об этом,
[40:54.740 --> 40:59.940]  конечно же, заранее не подумали, но когда поняли, что надо бы ввести const, уже нельзя же было всё
[40:59.940 --> 41:15.540]  наоборот переделать, поэтому вот так, да. Ну да, можно написать const int звёздочка p,
[41:15.540 --> 41:20.500]  а можно писать int const звёздочка p, нет разницы, как и здесь можно писать int const x, это неважно,
[41:20.500 --> 41:37.780]  но мы будем писать const перед типом, по код стайлу. Не знаю, была пробой, думаю нет. Константный
[41:37.780 --> 41:44.820]  указатель на обычный указатель, на константный указатель на int. Ну да, да, да, да, да, то есть
[41:44.820 --> 41:51.540]  вот это константный указатель на int. Вот это константный указатель на обычный указатель на
[41:51.540 --> 42:06.860]  константный указатель на int. Ну да, есть пословица, ехал const через const, видит const в реке const,
[42:06.860 --> 42:16.060]  ну продолжение вы знаете. Да, ну короче, да, когда вы пишете на плюсах, вам нужно постоянно и много
[42:16.060 --> 42:21.500]  раз в разных местах писать слово const, и если вы забудете, то ошибки компиляции вас впечатлят.
[42:21.500 --> 42:28.140]  Вот, значит, умение по огромному логу ошибок компиляции понимать, в каком именно месте забыто
[42:28.140 --> 42:34.020]  const, это отдельное искусство, вы ему будете учиться весь этот год. Вот, к концу года, я думаю, вы научитесь.
[42:34.220 --> 42:44.320]  Просто предупреждаю, что вам, что нам предстоит с этим какое-то время жить. Так, итак, это были
[42:44.320 --> 42:51.080]  константные указатели, указатель на константный, теперь константные ссылки. А, нет, еще не сразу,
[42:51.080 --> 43:00.920]  вот смотрите, если у меня есть обычный int, если у меня есть обычный int, то могу ли я завести const int
[43:00.920 --> 43:08.240]  звёздочку на него.
[43:08.240 --> 43:12.000]  Конечно могу, потому что каст в эту сторону неявный
[43:12.000 --> 43:13.560]  разрешён.
[43:13.560 --> 43:19.360]  Приведение типов от неконстанты к константе разрешено,
[43:19.360 --> 43:21.440]  и оно делается очень легко и неявно.
[43:21.440 --> 43:29.160]  Вот это вот имеет тип int звёздочка.
[43:29.160 --> 43:31.280]  Я пытаюсь constant звёздочку пронизализировать через
[43:31.280 --> 43:32.280]  int звёздочка.
[43:32.280 --> 43:33.280]  Это можно.
[43:33.280 --> 43:35.280]  То есть я дополнительное ограничение себе таким
[43:35.280 --> 43:36.880]  объявлением накладываю.
[43:36.880 --> 43:41.080]  Вот это вообще-то указатель на неконстанту, но я буду
[43:41.080 --> 43:42.840]  считать его указателем на константу.
[43:42.840 --> 43:47.200]  И под этим менять, и теперь написать плюс-плюс звёздочка
[43:47.200 --> 43:48.200]  b нельзя.
[43:48.200 --> 43:53.760]  А плюс-плюс a можно, и тогда то, что лежит под b поменяется.
[43:53.760 --> 43:59.120]  Но само b, то, что под b лежит, через вот это менять нельзя.
[43:59.120 --> 44:02.600]  А то, что там лежит, менять можно через a.
[44:02.600 --> 44:05.800]  И это на самом деле не так уж странно.
[44:05.800 --> 44:09.880]  У вас просто есть разные способы доступа к одному
[44:09.880 --> 44:10.880]  и тому же.
[44:10.880 --> 44:13.000]  Один с доступом на запись, другой с доступом только
[44:13.000 --> 44:14.760]  на чтение.
[44:14.760 --> 44:17.800]  Вы же не удивляетесь, если у вас есть там, грубо говоря,
[44:17.800 --> 44:18.800]  два юзера.
[44:18.800 --> 44:20.920]  Один имеет право и читать и писать файл, другой только
[44:20.920 --> 44:22.200]  читать из файла.
[44:22.200 --> 44:24.200]  По сути, вот это оно и есть.
[44:24.200 --> 44:26.920]  Вы сказали, вот через это разрешено только чтение,
[44:27.000 --> 44:28.440]  а через это и чтение и запись.
[44:30.440 --> 44:31.920]  Теперь константные ссылки.
[44:35.920 --> 44:42.920]  Вот у меня опять есть обычный INT, и я решил завести ссылку.
[44:46.920 --> 44:51.920]  Но я решил написать вот так, const int&b равно a.
[44:56.920 --> 44:57.920]  Все нормально.
[44:57.920 --> 45:03.920]  Я сказал теперь, что b это другое название для a, но
[45:03.920 --> 45:08.920]  с той разницей, что b не допускает изменения, а a допускает.
[45:11.920 --> 45:15.920]  Когда мы меняем a, конечно же меняется b.
[45:15.920 --> 45:17.920]  Потому что a и b это одно и то же.
[45:17.920 --> 45:20.920]  Просто называя его b, менять мы его не можем.
[45:20.920 --> 45:22.920]  А называя его a можем.
[45:27.920 --> 45:28.920]  Вы...
[45:37.920 --> 45:41.920]  Да, это очень удобно именно для передачи функцию.
[45:41.920 --> 45:45.920]  Потому что в функцию вы зачастую хотите передавать
[45:45.920 --> 45:49.920]  тот самый объект, с которым вы ходно работаете, но запретить
[45:49.920 --> 45:51.920]  функции менять его.
[45:51.920 --> 45:52.920]  В этом смысл.
[45:52.920 --> 45:54.920]  То есть вы хотите иметь дело с тем самым объектом,
[45:54.920 --> 45:57.920]  не создавая его копию, но чтобы функция вам случайно
[45:57.920 --> 45:58.920]  его не испортила.
[45:58.920 --> 46:00.920]  Вот для чего это нужно в основном.
[46:00.920 --> 46:02.920]  Поэтому, на самом деле, вот такое преобразование
[46:02.920 --> 46:04.920]  типов, оно делается...
[46:04.920 --> 46:07.920]  Это одно из самых распространенных преобразований типов,
[46:07.920 --> 46:09.920]  которые в реальности используются.
[46:09.920 --> 46:11.920]  Всякий раз, когда вы что-то функцию отдаете по ссылке,
[46:11.920 --> 46:13.920]  вы, как правило, именно так делаете.
[46:13.920 --> 46:15.920]  Вы отдаете по константной ссылке.
[46:15.920 --> 46:17.920]  Вот это называется константная ссылка.
[46:18.920 --> 46:20.920]  Это называется константная ссылка.
[46:27.920 --> 46:29.920]  Вот.
[46:29.920 --> 46:31.920]  Дальше.
[46:31.920 --> 46:35.920]  Ну да, я могу поменять A, и поменяться B тем самым.
[46:35.920 --> 46:37.920]  Поменять B я не могу.
[46:37.920 --> 46:43.920]  Но, конечно же, я теперь не могу написать вот так.
[46:43.920 --> 46:45.920]  Вот это будет CЕ.
[46:49.920 --> 46:54.920]  Если я теперь решу обычную ссылку создать из B,
[46:54.920 --> 46:56.920]  то это, конечно же, CЕ, потому что
[46:56.920 --> 46:58.920]  B это константный int,
[46:58.920 --> 47:01.920]  а я пытаюсь его сказать, что это...
[47:03.920 --> 47:04.920]  Да, да, да.
[47:04.920 --> 47:07.920]  То есть сказать теперь, что
[47:07.920 --> 47:11.920]  имея B получить права на запись к нему,
[47:11.920 --> 47:13.920]  таким образом я не могу.
[47:13.920 --> 47:17.920]  Но если я здесь напишу A, то все нормально.
[47:17.920 --> 47:19.920]  Ну понятно.
[47:19.920 --> 47:23.920]  То есть A дает мне право как менять int,
[47:23.920 --> 47:25.920]  так и передавать его дальше с правами на изменение.
[47:25.920 --> 47:28.920]  B дает мне право только смотреть на int.
[47:28.920 --> 47:32.920]  И, конечно же, имея B, я не могу дальше никому выдать права на запись к нему.
[47:33.920 --> 47:37.920]  И, конечно же, имея B, я не могу дальше никому выдать права на запись к нему.
[47:37.920 --> 47:38.920]  Все.
[47:38.920 --> 47:42.920]  Имея B, получить не константную ссылку я уже не могу.
[47:52.920 --> 47:55.920]  Ну, разумеется, если у меня есть
[47:55.920 --> 47:57.920]  исходно константный int,
[47:57.920 --> 48:00.920]  то на него я могу только константные ссылки делать.
[48:00.920 --> 48:03.920]  То есть если у меня есть констант int X равно чему-то,
[48:03.920 --> 48:06.920]  то написать int % B равно B я не могу уже.
[48:06.920 --> 48:08.920]  Потому что, ну понятно,
[48:08.920 --> 48:10.920]  исходно не было прав на запись, откуда они возьмутся.
[48:12.920 --> 48:13.920]  Вот.
[48:13.920 --> 48:15.920]  Зачем писать когда-либо констант,
[48:15.920 --> 48:17.920]  если можно просто не менять ничего?
[48:18.920 --> 48:19.920]  Вот.
[48:19.920 --> 48:20.920]  Тут мы приходим...
[48:20.920 --> 48:22.920]  А, ты что-то хотел сказать.
[48:22.920 --> 48:28.920]  Тут мы приходим к трем, значит, важным...
[48:28.920 --> 48:30.920]  Я бы не сказал прям столпам.
[48:30.920 --> 48:32.920]  Ну, короче,
[48:32.920 --> 48:34.920]  как правильно
[48:34.920 --> 48:37.920]  передавать аргументы в функцию?
[48:37.920 --> 48:39.920]  Этот вопрос,
[48:39.920 --> 48:42.920]  который будет тоже вас...
[48:42.920 --> 48:44.920]  Это один из вечных вопросов
[48:44.920 --> 48:46.920]  языка C++.
[48:46.920 --> 48:47.920]  Вот.
[48:47.920 --> 48:50.920]  И сейчас мы подступимся к нему в первый раз,
[48:50.920 --> 48:52.920]  но далеко не в последний.
[48:52.920 --> 48:54.920]  Дискуссия на эту тему
[48:54.920 --> 48:56.920]  не утихает и по сей день в профессиональном сообществе,
[48:56.920 --> 48:58.920]  как это делать правильно, в каком случае.
[48:58.920 --> 49:00.920]  Но давайте для начала осветим
[49:00.920 --> 49:02.920]  возможные варианты
[49:02.920 --> 49:04.920]  с, так сказать, наивным взглядом.
[49:04.920 --> 49:06.920]  Когда вы хотите что-то передать в функцию,
[49:06.920 --> 49:08.920]  у вас есть, по сути, три
[49:08.920 --> 49:10.920]  способа.
[49:10.920 --> 49:12.920]  Передать это по значению,
[49:12.920 --> 49:14.920]  по обычной ссылке или по константной ссылке.
[49:14.920 --> 49:16.920]  По константному значению
[49:16.920 --> 49:18.920]  передавать
[49:18.920 --> 49:20.920]  нет смысла никогда.
[49:20.920 --> 49:22.920]  Потому что
[49:22.920 --> 49:24.920]  если вы что-то хотите передать по значению,
[49:24.920 --> 49:26.920]  то вам не важно
[49:26.920 --> 49:28.920]  будет функция его менять
[49:28.920 --> 49:30.920]  или не будет.
[49:30.920 --> 49:32.920]  Если вы хотите функцию
[49:32.920 --> 49:34.920]  отдать копию чего-то,
[49:34.920 --> 49:36.920]  то вам не важно, что функция сделает с копией.
[49:36.920 --> 49:38.920]  Поэтому...
[49:44.920 --> 49:46.920]  Ну вот тут начинается
[49:46.920 --> 49:48.920]  философия,
[49:48.920 --> 49:50.920]  что якобы иногда...
[49:50.920 --> 49:52.920]  В общем, более-менее
[49:52.920 --> 49:54.920]  профессиональное собственность
[49:54.920 --> 49:56.920]  сходится в том, что по константному значению
[49:56.920 --> 49:58.920]  не надо передавать ничего никогда.
[49:58.920 --> 50:00.920]  Вот.
[50:00.920 --> 50:02.920]  Вот вроде как так принято
[50:02.920 --> 50:04.920]  большинством код-стайлов. По константному значению
[50:04.920 --> 50:06.920]  передавать это что-то бессмысленное
[50:06.920 --> 50:08.920]  и странно.
[50:08.920 --> 50:10.920]  Вот.
[50:10.920 --> 50:12.920]  Поэтому на самом деле
[50:12.920 --> 50:14.920]  есть реально три
[50:14.920 --> 50:16.920]  способа.
[50:16.920 --> 50:18.920]  То есть можно передать...
[50:18.920 --> 50:20.920]  Ну давайте я буду не Инт писать, а произвольный Т.
[50:20.920 --> 50:22.920]  Да.
[50:24.920 --> 50:26.920]  Да, можно передавать по обычной ссылке,
[50:26.920 --> 50:28.920]  а можно передавать по константной ссылке.
[50:30.920 --> 50:32.920]  И надо каждый раз, когда вы объявляете
[50:32.920 --> 50:34.920]  какую-то функцию, думать
[50:34.920 --> 50:36.920]  о том, каким способом
[50:36.920 --> 50:38.920]  она принимает каждый из своих аргументов.
[50:38.920 --> 50:40.920]  По значению она должна
[50:40.920 --> 50:42.920]  его принимать. И если вы действительно
[50:42.920 --> 50:44.920]  хотите копировать это значение каждый раз,
[50:44.920 --> 50:46.920]  когда передаете функцию, надо понимать, что если это тяжелый
[50:46.920 --> 50:48.920]  тип, например, вектор или строка,
[50:48.920 --> 50:50.920]  то она будет реально создавать полноценную копию
[50:50.920 --> 50:52.920]  с выделением новой памяти, чтобы отдать в эту
[50:52.920 --> 50:54.920]  функцию и в конце функцию уничтожать
[50:54.920 --> 50:56.920]  эту локальную копию.
[50:56.920 --> 50:58.920]  Если вы передаете по ссылке, то есть вы не хотите
[50:58.920 --> 51:00.920]  копировать, то вы, конечно, несете
[51:00.920 --> 51:02.920]  небольшие издержки, что обращение
[51:02.920 --> 51:04.920]  к этому будет стоить вам разыменование
[51:04.920 --> 51:06.920]  указателей на практике в реальности.
[51:06.920 --> 51:08.920]  Поэтому
[51:08.920 --> 51:10.920]  маленькие типы вроде Инта
[51:10.920 --> 51:12.920]  и Чара так не принято передавать.
[51:12.920 --> 51:14.920]  Вот по константной ссылке принимать Инты
[51:14.920 --> 51:16.920]  не принято, потому что их можно
[51:16.920 --> 51:18.920]  понимать по значению, это дешевле будет.
[51:18.920 --> 51:20.920]  Но если вам
[51:20.920 --> 51:22.920]  нужно, чтобы ваша функция меняла
[51:22.920 --> 51:24.920]  ваш объект, который вы передали, то ваш выбор
[51:24.920 --> 51:26.920]  это не константная ссылка.
[51:28.920 --> 51:30.920]  Ну да, если у вас маленькая
[51:30.920 --> 51:32.920]  переменная,
[51:32.920 --> 51:34.920]  какого-то примитивного типа, то
[51:34.920 --> 51:36.920]  не принято передавать ее по значению.
[51:36.920 --> 51:38.920]  Ой, по константной ссылке.
[51:38.920 --> 51:40.920]  Вот два наиболее
[51:40.920 --> 51:42.920]  распространенных способа принимать функцию
[51:42.920 --> 51:44.920]  это по значению и по константной ссылке.
[51:46.920 --> 51:48.920]  Самый распространенный
[51:48.920 --> 51:50.920]  это по константной ссылке.
[51:50.920 --> 51:52.920]  Наиболее часто вы будете
[51:52.920 --> 51:54.920]  видеть в реальном коде и будете писать
[51:54.920 --> 51:56.920]  в своем коде вот такие функции, которые
[51:56.920 --> 51:58.920]  принимают константные ссылки, потому что
[51:58.920 --> 52:00.920]  как правило вы работаете с объектами сейчас
[52:00.920 --> 52:02.920]  и вы не хотите копировать эти объекты.
[52:02.920 --> 52:04.920]  Но если вы работаете с объектом
[52:04.920 --> 52:06.920]  и действительно осознанно хотите его скопировать,
[52:06.920 --> 52:08.920]  что функция с ним что-то сделала,
[52:08.920 --> 52:10.920]  то это ваш выбор.
[52:10.920 --> 52:12.920]  И это также ваш выбор, если вы Инт
[52:12.920 --> 52:14.920]  передаете. Что?
[52:14.920 --> 52:16.920]  Это прекрасный вопрос, и сейчас я как раз о нем
[52:16.920 --> 52:18.920]  буду говорить следующим
[52:18.920 --> 52:20.920]  пунктом.
[52:20.920 --> 52:22.920]  Да.
[52:22.920 --> 52:24.920]  Да,
[52:24.920 --> 52:26.920]  если вам
[52:26.920 --> 52:28.920]  указатель как бы он
[52:28.920 --> 52:30.920]  это самостоятельный тип такой. Ссылка
[52:30.920 --> 52:32.920]  не совсем самостоятельный тип, это как бы другое название
[52:32.920 --> 52:34.920]  для. Вот.
[52:34.920 --> 52:36.920]  Если вы хотите иметь дело
[52:36.920 --> 52:38.920]  с указателями, можете передавать по указателю,
[52:38.920 --> 52:40.920]  да. Но мы
[52:40.920 --> 52:42.920]  имеем дело с указателями,
[52:42.920 --> 52:44.920]  хотим иметь дело с указателями,
[52:44.920 --> 52:46.920]  то когда реально это необходимо,
[52:46.920 --> 52:48.920]  мы что-то с памятью хотим делать.
[52:48.920 --> 52:50.920]  Вот. Ссылки пришли
[52:50.920 --> 52:52.920]  на замену указателям, чтобы нам не
[52:52.920 --> 52:54.920]  приходилось брать адрес и разыменовывать постоянно.
[52:54.920 --> 52:56.920]  Мы стараемся избавиться, мы стараемся
[52:56.920 --> 52:58.920]  вот так писать, если мы не хотим копию создавать.
[52:58.920 --> 53:00.920]  Вот. А теперь замечательный
[53:00.920 --> 53:02.920]  вопрос, очень правильный,
[53:02.920 --> 53:04.920]  который
[53:04.920 --> 53:06.920]  на самом деле логически следует из вот
[53:06.920 --> 53:08.920]  этого вот, что я сказал. Раз
[53:08.920 --> 53:10.920]  функцию можно,
[53:10.920 --> 53:12.920]  ну, функции могут принимать объекты по константной
[53:12.920 --> 53:14.920]  ссылке. Это означает,
[53:14.920 --> 53:16.920]  что они обязуются не менять их и не копировать,
[53:16.920 --> 53:18.920]  пока когда передаются.
[53:18.920 --> 53:20.920]  Ну вот, допустим, у меня есть функция, которая принимает
[53:20.920 --> 53:22.920]  const string&
[53:22.920 --> 53:24.920]  то есть константную
[53:24.920 --> 53:26.920]  ссылку, ну, константную ссылку на string.
[53:26.920 --> 53:28.920]  А
[53:28.920 --> 53:30.920]  могу ли я туда
[53:30.920 --> 53:32.920]  отдать
[53:34.920 --> 53:36.920]  строку, которая вот не
[53:36.920 --> 53:38.920]  переменная, а только что созданная строка?
[53:38.920 --> 53:40.920]  Там...
[53:42.920 --> 53:44.920]  Что слабое?
[53:48.920 --> 53:50.920]  В этом-то и проблема. Я же говорил, что
[53:50.920 --> 53:52.920]  ссылки нельзя инициализировать посредством R-value.
[53:52.920 --> 53:54.920]  То есть ссылку можно инициализировать лишь
[53:54.920 --> 53:56.920]  реально существующей переменной.
[53:56.920 --> 53:58.920]  А тут получается, что я пытаюсь
[53:58.920 --> 54:00.920]  инициализировать ссылку временным значением,
[54:00.920 --> 54:02.920]  которое даже в переменную ни в какую не записано.
[54:04.920 --> 54:06.920]  Это неважно. Я пытаюсь
[54:06.920 --> 54:08.920]  инициализировать ссылку временным значением,
[54:08.920 --> 54:10.920]  которое не хранится ни в какой переменной.
[54:10.920 --> 54:12.920]  Я могу тебе не string привести пример,
[54:12.920 --> 54:14.920]  а любой другой. Вот у меня f принимает
[54:14.920 --> 54:16.920]  const &&, а я 5 передаю
[54:16.920 --> 54:18.920]  сюда. Что будет?
[54:18.920 --> 54:20.920]  Могу ли я проинциализировать
[54:20.920 --> 54:22.920]  константную ссылку конкретным
[54:22.920 --> 54:24.920]  значением R-value?
[54:26.920 --> 54:28.920]  Мы с ней не можем сделать ничего такого,
[54:28.920 --> 54:30.920]  что нельзя было бы. А как компилятор
[54:30.920 --> 54:32.920]  это должен реализовать?
[54:32.920 --> 54:34.920]  Да нет, ложно.
[54:34.920 --> 54:36.920]  Я не хочу проинциализовать.
[54:36.920 --> 54:38.920]  Мы же не на стол хотим сказать о нём.
[54:44.920 --> 54:46.920]  Так, я уже чувствую, что разрожается дискуссия.
[54:46.920 --> 54:48.920]  Тихо, тихо, тихо
[54:48.920 --> 54:50.920]  тебя ждет
[54:50.920 --> 54:52.920]  ещё одно удивление
[54:52.920 --> 54:54.920]  сейчас. Я предупреждаю.
[54:54.920 --> 54:56.920]  Сиди, держись за стол
[54:56.920 --> 54:58.920]  крепко. Можно так делать.
[55:00.920 --> 55:02.920]  И можно так делать.
[55:04.920 --> 55:14.640]  и можно так делать ровно по этой причине потому что вот такой способ принятия
[55:14.640 --> 55:19.560]  аргумента функцию самый распространенный и было бы странно если бы чтобы передать
[55:19.560 --> 55:23.800]  что-то функцию которая не собирается это менять и не хочет это копировать вам бы приходилось
[55:23.800 --> 55:28.200]  заводить отдельную переменную и только потом эту переменную туда передавать у вас очень многие
[55:28.200 --> 55:32.760]  функции стандартные вообще любые в любой библиотеке у вас функции зачастую имеют вот такую
[55:32.760 --> 55:37.560]  сигнатуру не принимают объекты по константным ссылкам и очень хочется чтобы можно было в эти
[55:37.560 --> 55:43.960]  функции отдавать объекты без перед без создания переменных под них а просто вот объекты как есть
[55:43.960 --> 55:51.560]  числа например там не знаю поэтому это разрешено что же должен компилятор тогда с этим делать ну
[55:51.560 --> 55:59.960]  он должен временно создать переменную под это как бы пока не отомрет вот эта ссылка это называется
[55:59.960 --> 56:11.960]  lifetime prolongation продление времени жизни объекта когда вы инициализируете константную ссылку
[56:11.960 --> 56:17.360]  посредством airvalue компилятор запоминает вот эту вот самую вот первую константную ссылку посредством
[56:17.360 --> 56:25.120]  которой был объект который был проинциализирован этот объект и компилятор соответственно будет
[56:25.120 --> 56:29.520]  уничтожать этот объект когда отомрет вот это вот исходная ссылка по которой он был проинциализирован
[56:29.520 --> 56:38.400]  ну то есть я могу в мэйне написать грубо говоря конст стд стрингом персант там я могу написать
[56:38.400 --> 56:49.160]  конст стрингом персант но стд я опускаю там s равно abc дальше я эту s куда-то передаю функции
[56:49.160 --> 56:54.280]  создали другие ссылки на нее что там еще делаю но вот когда заканчивается область видимости вот
[56:54.280 --> 57:02.360]  этой ссылки строка уничтожается это называется продление времени жизни потому что
[57:16.360 --> 57:21.160]  если вы ну
[57:25.160 --> 57:32.160]  ну тут давайте я сейчас не буду вдаваться в подробности как именно создается строка
[57:32.160 --> 57:37.760]  из сишной строкея потому что это уже немножечко оп и вам это кстати самим предстоит скоро
[57:37.760 --> 57:44.400]  реализовывать вот я просто пока говорю что я могу создать объект проинциализирую создать объект
[57:44.400 --> 57:52.440]  посредством заведения константной ссылки на тип они самого то есть я могу объявить исходно объект
[57:52.440 --> 57:58.440]  не как стринга как констрингом персант и эта строка будет жить пока жива вот это вот это
[57:58.440 --> 58:04.960]  переменная исходная остальные ну компилятор вынужден это запоминать это называется продление
[58:04.960 --> 58:14.720]  жизни посредством константной ссылки вот возникает вопрос а почему нельзя также сделать для обычной
[58:14.720 --> 58:26.120]  ссылки тогда ну вот этой строки ну как тут как бы ну тут как бы создалась временная строка вот
[58:26.120 --> 58:37.280]  она создалась там в динамической памяти выделился буфер и там значит ну что-то создался объект вот
[58:37.280 --> 58:43.760]  эта строка не уничтожается пока вот эта переменная не выйдет из области видимости хотя если бы я
[58:43.760 --> 58:49.800]  просто написал стринг обц точкой запятой то она бы уничтожилась сразу же когда когда создалась вот
[58:49.800 --> 59:05.720]  для обычной ссылки для обычной ссылки по идее можно было бы сделать также но есть но это волевое
[59:05.720 --> 59:13.160]  решение было это на самом деле очень глубокий глубокая мысль почему если константная ссылки
[59:13.160 --> 59:19.480]  умеют продлевать жизнь объектам почему обычные не умеют вот ну то есть можно сказать так решил
[59:19.480 --> 59:25.120]  комитет по стандартизации на самом деле так решил сам создатель и он решил это неспроста а
[59:25.120 --> 59:32.080]  дело в том что есть один плохой пример когда продление жизни обычными ссылками приводила бы
[59:32.080 --> 59:41.000]  к проблемам и вот какой но прежде чем показать этот пример я вам сначала задам интересный вопрос
[59:41.320 --> 59:48.640]  давайте представим что у меня есть int x равные ну не знаю пяти люблю числа 5 а потом я говорю
[59:48.640 --> 59:57.360]  конст дабл амперсант игрок равно x как вы думаете что будет
[59:57.360 --> 01:00:08.160]  дело в том что int умеет кастоваться к дабл создавать временный дабл из
[01:00:08.160 --> 01:00:14.680]  него а конст дабл амперсант умеет инициализироваться временным даблом это значит что инт не явно
[01:00:14.680 --> 01:00:19.640]  скатится в дабл то есть x не изменит с x ничего не случится но создастся временный дабл из
[01:00:19.640 --> 01:00:25.200]  него и вот к этому временную даблу будет привязана вот эта вот ссылка после этого вы сможете
[01:00:25.200 --> 01:00:35.160]  менять x и на игрок это никак не повлияет потому что дабл создался из x то есть у вас был x x это
[01:00:35.520 --> 01:00:42.480]  поменять тип x вы никак не можете как я говорил в самом начале неоднократно но дабл но это чем-то
[01:00:42.480 --> 01:00:46.920]  надо проинциализировать что делает компилятор он видит что у него есть каст из инта в дабл а
[01:00:46.920 --> 01:00:52.840]  этот дабл рвл ю можно проинциализировать им этот амперсант значит он применяет этот каст таким
[01:00:52.840 --> 01:00:56.920]  образом у вас образовываются две перемены одна из которых инт спокойно вы с ним можете работать
[01:00:56.920 --> 01:01:03.600]  а другая дабл со значением 5.0 изменение x не повлияет на этот дабл а дабл будет жить
[01:01:03.600 --> 01:01:14.560]  отдельно но он будет константный ну да что что ну проверьте что так работает но так должен
[01:01:14.560 --> 01:01:26.880]  работать да я вот просто вот этот вот отдельный пример рассматриваю потому что тут прямоугольник
[01:01:26.880 --> 01:01:37.200]  нарисован поверх этого забейте это будет ce потому что нельзя ссылки инициализировать
[01:01:37.200 --> 01:02:00.520]  временными объектами не переменными ну фактически да если мы заменим дабл на
[01:02:00.520 --> 01:02:04.800]  ин то он будет просто на тот же самый инц ссылаться да а так создается отдельная
[01:02:04.800 --> 01:02:18.480]  переменная под дабл да потому что это разные переменные что это же игрок ссылается на временный
[01:02:18.480 --> 01:02:26.000]  дабл который был создан из инта посредством неявного каста это будет ссылаться на 1 это будет
[01:02:26.000 --> 01:02:30.120]  одно и то же тогда x и y будет одно и то же но сейчас ты не одно и то же потому что но это не
[01:02:30.120 --> 01:02:35.200]  может быть одно и то же игрок ссылается на дабл а и а икс на ин в как они могут быть одним и тем
[01:02:35.200 --> 01:02:43.280]  смысле за что именно сделали зачем разрешили каст не явный к из инта в дабл или зачем разрешили
[01:02:43.280 --> 01:02:47.400]  привязывать константные ссылки к временным объектам ну каст из инта в дабл не явный
[01:02:47.400 --> 01:02:52.480]  создатель уже уже раскаивался а привязывает ссылки к временному объекту я объяснил почему
[01:02:52.480 --> 01:03:05.560]  разрешили потому что нельзя привязать да кстати вот это хороший вопрос если здесь консту брать
[01:03:05.560 --> 01:03:10.480]  написать просто дабл амперсант тихо дабл амперсант игрок равно икс почти что будет будет
[01:03:10.480 --> 01:03:17.440]  сие потому что нужно привязать ссылку на дабл к инту но нельзя же ссылаться не над свой тип
[01:03:17.440 --> 01:03:21.360]  значит нужно создать из инта дабл он будет временным но нельзя ссылку не стилизировать
[01:03:21.360 --> 01:03:24.920]  временным даблом это будет сие со словами попытка инициализирует ссылку посредством
[01:03:24.920 --> 01:03:37.880]  рвэлью это если конст не было бы вот и здесь кроется разгадка почему запрещено продление
[01:03:37.880 --> 01:03:45.160]  жизни обычными ссылками не константными потому что представьте у вас было бы оно разрешено и
[01:03:45.160 --> 01:03:51.580]  вот вы пишете допустим у вас есть какая-нибудь словно функция там не знаю своп которая принимает
[01:03:51.580 --> 01:04:01.880]  ссылку на инт и другую ссылку на инт а вы подсунули этой функции два дабла но вы чуть-чуть ошиблись
[01:04:01.880 --> 01:04:07.000]  в типе у вас функция принимает две ссылки и вы с ними что-то делаете а вы этой функции подсовывайте
[01:04:07.000 --> 01:04:13.160]  не совсем тот тип потому что вы ну чуть забыли что тип не совсем такой чуть ошиблись тогда если
[01:04:13.160 --> 01:04:19.760]  бы так можно было делать получилось бы что у вас произошел не явный каст эти ссылки про
[01:04:19.760 --> 01:04:24.800]  индициализируют временными значениями созданными из вашего типа и вы думаете что вы передали их и
[01:04:24.800 --> 01:04:29.920]  меняете свои собственные объекты но из-за того что вы чуть-чуть не отгадали тип у вас произошло
[01:04:29.920 --> 01:04:33.440]  бы на самом деле каст который вы не заметили и вы думали что вы меняете их на самом деле не
[01:04:33.440 --> 01:04:39.080]  меняете и это не было бы никакой ошибкой вы вот никак не отловили вот по этой причине страустроб
[01:04:39.080 --> 01:04:46.480]  запретил продлевать жизнь объектов не константными ссылками но константными вот нужно оставить
[01:04:46.480 --> 01:05:08.120]  потому что вот такая передача по ссылке нужна ну и последнее как вы думаете что означает
[01:05:08.120 --> 01:05:19.200]  вот такая запись ну там на самом деле я даже не знаю это то ли ци то ли то ли ничего но
[01:05:19.200 --> 01:05:28.000]  это бессмысленно так писать нет смысла потому что константность комперсанту то есть нет смысла
[01:05:28.000 --> 01:05:39.920]  пытаться возможно это ци я не помню на самом деле это ци да вы проверили да это ци хорошо ну так
[01:05:39.920 --> 01:05:45.120]  все равно не надо писать никогда ну понятно даже если бы это было не ци это бессмысленно это
[01:05:45.120 --> 01:05:50.120]  бессмысленная запись потому что она ничего не дабы вот этот констант ничего не дает он как бы
[01:05:50.120 --> 01:05:57.640]  говорит что сама ссылка она должна не это бессмысленно потому что ссылка и так не может
[01:05:57.640 --> 01:06:03.600]  быть перепривязана к ничему другому в случае с указателями конст вправо от звездочки осмысленен
[01:06:03.600 --> 01:06:10.280]  это значит что указатель двигать нельзя в случае ссылок константа не осмысленен это ци просто вот
[01:06:10.280 --> 01:06:20.760]  и последнее допустим у меня есть вот такая функция и вот такая функция могу ли я перегрузку сделать
[01:06:20.760 --> 01:06:35.160]  да могу принять по ссылке принять по константной ссылке это разные в общем то вещи если я буду
[01:06:35.160 --> 01:06:40.640]  передавать константу то я попаду в эту версию если не константу то в эту версию то есть я могу
[01:06:40.640 --> 01:06:48.760]  делать перегрузку в зависимости от того по константной или по неконстантной ссылке я принимаю это
[01:06:48.760 --> 01:06:55.800]  прям раз ну то есть int и const int это разные типы и если я хочу int отдать или const int отдать это
[01:06:55.800 --> 01:07:02.320]  раз я ну причем в эту сторону неявный каст разрешен если у меня есть функция которая принимает только
[01:07:02.980 --> 01:07:08.160]  это то я могу и обычной int отдать вообще легко но если есть функция которые принимает только это
[01:07:08.160 --> 01:07:14.040]  то констант на int я не могу и отдать конечно и если есть функция которая принимает t по значению
[01:07:14.040 --> 01:07:18.680]  то тогда перегрузку уже ломается перегружать вот это с этим нельзя как я уже говорил и перегружать
[01:07:18.680 --> 01:07:24.920]  вот это с этим тоже нельзя то есть принять по значению или по константной ссылке из этих
[01:07:24.920 --> 01:07:29.840]  вариантов выбор сделать нельзя. Компилятор, ну эта перегрузка запрещена. Это будет амбигиус-кол.
[01:07:29.840 --> 01:07:45.560]  Все, вопросы? В общем, там третья строчка, там констанция, можно засунуть в мерсенте
[01:07:46.560 --> 01:07:57.600]  Ну догадайся, исходя из того, как я на доске пишу все это время. Наверное, я пишу так,
[01:07:57.600 --> 01:08:09.920]  как я рекомендую не писать. Нет, по код-стайлу мы пишем вот так. Более-менее так все пишут.
[01:08:09.920 --> 01:08:27.120]  Что еще раз? Что такое ссылка на лямбдо-функцию? В смысле, какой тип-то там будет? Давай в перерыве.
[01:08:27.120 --> 01:08:34.720]  У лямбдо-функции ты не можешь тип точно назвать, тебе нужно будет и слово авто использовать для этого.
[01:08:34.840 --> 01:08:45.040]  Нет, это нормально. Так, отставить. Все, нет, мы короче не будем про это сейчас отговорить.
[01:08:45.040 --> 01:08:56.160]  Вопросы вот в рамках вот рассказанного есть? Какого черта? Это C++.
[01:08:56.160 --> 01:09:08.680]  Ну это разные типы принципиально тогда вообще. Какой разговор? Если вместо ссылки указатель,
[01:09:08.680 --> 01:09:16.320]  ну да, если ты вместо ссылки сделаешь указатель, да, точно так же будет работать.
[01:09:16.320 --> 01:09:33.000]  А вот T звездочка и T звездочка const нельзя перегружать. Ну если у вас есть f от int и f от
[01:09:33.000 --> 01:09:40.000]  const int, то так тоже нельзя перегружать, если нет амперсантов. Потому что и там и там копия непонятна.
[01:09:40.000 --> 01:09:44.520]  Ну const int вообще не надо никогда принимать, я вам говорю, поэтому так это не актуально.
[01:09:44.520 --> 01:09:53.040]  Ну и последняя тема, прежде чем мы сделаем перерыв и дальше начнем творить великие дела. Последний,
[01:09:53.040 --> 01:10:10.360]  так сказать, параграф из области. Введение нам последний перед бурей. Это type conversions. Я
[01:10:10.360 --> 01:10:16.960]  много вам рассказал про то, какие бывают типы, какие бывают странные указатели, ссылки массива
[01:10:16.960 --> 01:10:23.440]  и так далее. И последнее, что нам надо обсудить, прежде чем мы начнем писать ООП, это какие есть
[01:10:23.440 --> 01:10:35.600]  приведения типов. Значит в C++ есть пять способов приведения типа. Пять принципиально разных,
[01:10:35.600 --> 01:10:44.080]  все они по-своему применимы в разных ситуациях. Нет-нет-нет-нет, вы не поняли, это не относится
[01:10:44.080 --> 01:10:51.600]  к указаниям. Есть пять операторов приведения типа. Обычное приведение типа, сишное, статическое
[01:10:51.600 --> 01:10:57.360]  приведение типа, динамическое приведение типа, reinterpret и константное приведение типа. Ну есть
[01:10:57.360 --> 01:11:03.040]  пять операторов приведения типа, sys-tile-cast, static-cast, dynamic-cast, reinterpret-cast и const-cast. Все они
[01:11:03.040 --> 01:11:17.840]  в своих ситуациях нужны и, значит, нам их все предстоит с вами изучить. В перерыве задашь
[01:11:17.840 --> 01:11:32.480]  тогда. Тогда в перерыве задашь. Значит, на самом деле все не так страшно, как кажется. Я вам сейчас
[01:11:32.720 --> 01:11:39.360]  озвучу первое правило приведения типа в C++, которое исчерпает большую часть ваших нужд в
[01:11:39.360 --> 01:11:46.080]  приведении типа. Во-первых, приведения типа нужно стараться избегать, но это скорее нулевое
[01:11:46.080 --> 01:11:51.360]  правило. А первое правило приведения типа звучит так. Если вы ничего не знаете о приведениях
[01:11:51.360 --> 01:11:58.640]  типа и не знаете, какое вам нужно, значит вам нужен static-cast. Во всех остальных ситуациях вы
[01:11:58.640 --> 01:12:02.560]  скорее всего будете подозревать, что приведение типа не совсем обычное, наверное, нужно что-то
[01:12:02.560 --> 01:12:08.160]  иное. Вот все те приведения типов, о которых вы скорее всего сейчас думаете, когда я говорю
[01:12:08.160 --> 01:12:17.840]  приведения типов, это static-cast называется. Нет, не sys-tile-cast, а static-cast. Есть такой оператор static-cast.
[01:12:17.840 --> 01:12:24.640]  Как он пишется? Вы пишете static-cast в угловых скобочках. К чему? В обычных скобочках от чего?
[01:12:24.640 --> 01:12:36.160]  Ну, то есть вы говорите там static-cast, допустим, к double от там от x, где x это int. Вы тем самым
[01:12:36.160 --> 01:12:48.840]  делаете явное приведение типа от int к double. Вот. Да, sys-tile-cast. Сейчас я скажу, возможно,
[01:12:48.840 --> 01:12:59.720]  для кого-то пугающие вещи, sys-tile-cast запрещен код-стайлом. Статик-cast. Я же первое правило
[01:12:59.720 --> 01:13:05.720]  приведения типа. Всякий раз, когда вам нужно приведение типа и вы не разбираетесь, какое,
[01:13:05.720 --> 01:13:16.360]  значит нужен static-cast. Нет, define запрещены тем более. Значит, ну, я на самом деле не знаю,
[01:13:16.360 --> 01:13:20.920]  что еще сказать про static-cast, кроме того, что это вот то самое приведение типов,
[01:13:20.920 --> 01:13:27.920]  которым скорее всего исчерпываются все ваши представления о приведении типов сейчас. Вот.
[01:13:27.920 --> 01:13:43.800]  Ну, ты какой-то слишком умный пока. Пока этого ты не должен был знать. Значит, итак, static-cast это
[01:13:43.800 --> 01:13:48.800]  вот классическое приведение типов, которое надо использовать всякий раз, когда вам нужно обычное,
[01:13:48.800 --> 01:13:55.560]  чтобы это не значило приведение типов. Теперь, что же это все-таки за остальные приведения
[01:13:55.560 --> 01:14:03.720]  типов, для чего они нужны? Из int в строку это не приведение типов, это функция преобразования,
[01:14:03.720 --> 01:14:10.000]  то есть data-string. Но это не приведение типа. Это не приведение типа. Приведение типа — это вот
[01:14:10.000 --> 01:14:15.840]  именно из одного типа сделает другой, не посредством функции, а вот посредством каста. Вот.
[01:14:15.840 --> 01:14:26.880]  Dynamic-cast я пропущу. Сейчас не буду об нем рассказывать. Значит, ну, есть еще dynamic. Вот есть static-cast
[01:14:26.880 --> 01:14:36.400]  и есть dynamic-cast еще. Dynamic-cast. Сейчас я не буду рассказывать, что такое dynamic-cast. Нет,
[01:14:36.400 --> 01:14:45.920]  я не буду сейчас рассказывать, что такое dynamic-cast, просто потому что не хочу. Расскажу я о нем через
[01:14:45.920 --> 01:14:55.680]  месяц примерно. Ну, просто сейчас вы пока не готовы к этому. Вот. Пока еще мы не готовы с вами
[01:14:55.680 --> 01:15:00.560]  понять, что такое dynamic-cast, пока мы будем считать, что dynamic-cast не существует. Потребность в нем мы
[01:15:00.560 --> 01:15:07.520]  осознаем примерно через месяц, и тогда и поговорим, что, оказывается, есть еще такой-то каст. Вот. Я
[01:15:07.520 --> 01:15:14.000]  сейчас расскажу вам про остальные три каста, и я буду рассказывать о них в порядке ухудшения,
[01:15:14.000 --> 01:15:24.400]  значит, в порядке устрашения. Я люблю называть их запрещенными заклинаниями языка C++. Вот. Значит,
[01:15:24.400 --> 01:15:33.280]  три запрещенных заклинания языка C++, да. От самого лайтового к самому ужасному, и самое
[01:15:33.280 --> 01:15:43.960]  лайтовое из трех, наверное, это reinterpret-cast. Значит, что такое reinterpret-cast? Reinterpret-cast.
[01:15:43.960 --> 01:15:53.000]  Опять в угловых скобочках к чему и в скобочках от чего. Reinterpret, да.
[01:15:53.000 --> 01:15:59.840]  Судя по названию, это по битовому отчету. Да. Это такой каст, который позволяет вам сделать,
[01:15:59.840 --> 01:16:08.880]  например, следующее. Он говорит, возьми биты вот этой переменной и трактуй их, как будто это
[01:16:08.880 --> 01:16:14.560]  другой тип. Никаких преобразований не делай, просто у тебя там int лежал, прочитай эти биты,
[01:16:14.560 --> 01:16:36.120]  как будто там дабл записан. Ну, возможно, да, возможно. Значит, если вы на самом деле при
[01:16:36.120 --> 01:16:44.240]  reinterpret-cast'е... Нет, получится всегда, все получится. Просто будет UB всегда. Ну, то есть,
[01:16:44.240 --> 01:16:50.760]  вы можете любой тип привести к любому с некоторыми оговорками, о которых я скажу в следующем пункте,
[01:16:50.760 --> 01:16:57.720]  а вы можете с помощью reinterpret-cast любой тип привести к любому. Просто прочитать биты одного
[01:16:57.720 --> 01:17:05.280]  типа, как биты другого типа. Вот. Только надо понимать важную вещь, что reinterpret-cast'ить нельзя
[01:17:05.280 --> 01:17:12.840]  сами типы, можно только указатели из ссылки. Тут есть некоторое вот такое концептуальное тоже
[01:17:12.840 --> 01:17:20.040]  концептуальный момент. Когда вы пишете static-cast, вы делаете его к дабл, а если вы хотите сделать
[01:17:20.040 --> 01:17:25.280]  reinterpret-cast, вот, допустим, у меня int, я хочу его как дабл прочитать. Как будто там... Ну,
[01:17:25.280 --> 01:17:30.920]  давайте float, чтобы размер совпадал. Я пишу float-ampersand, просто к float не скомпилируется.
[01:17:30.920 --> 01:17:39.280]  Почему я имею... Почему я пишу ampersand? Потому что я как бы говорю, не создавай новый float. А вот
[01:17:39.280 --> 01:17:47.080]  считай, что вот это и есть float. Ты как бы теперь к нему обращаешься, как будто он float. Ты не
[01:17:47.080 --> 01:17:53.240]  создаешь новый. Но это примерно, как я говорил, const int ampersand там y равно x. То есть, обращайся,
[01:17:53.240 --> 01:17:59.440]  пожалуйста, теперь к этому x, как будто он const int. То есть, через это имя я обращаюсь к тому же
[01:17:59.440 --> 01:18:16.120]  самому, но считаю его другим типом. Значит, если ты приравняешь это к y, ну, будет убе формально,
[01:18:16.120 --> 01:18:23.840]  а в реальности будет следующее. Вот я говорю float ampersand y равно вот это. Именно float ampersand y.
[01:18:23.840 --> 01:18:30.040]  Потому что если я говорю float y, это скомпилируется, но копия создастся в итоге все равно. То есть,
[01:18:30.040 --> 01:18:38.480]  я говорю reinterpret cast как float x из битов x. Вот он записан как int в двоичной системе. Создастся
[01:18:38.480 --> 01:18:45.320]  float вот с такими же битами. То есть, это будет какой-то странный float. То есть, вот прочитали
[01:18:45.320 --> 01:18:53.400]  его как float. Вот как float кодируется по битам. Вот так он и прочитается. Вот, если так написано,
[01:18:53.400 --> 01:18:59.280]  то y и x будут независимо существовать. Но если вот так написано, то когда ты x поделишь на 2,
[01:18:59.280 --> 01:19:03.760]  float тоже как-то изменится. Но как именно изменится, это трудно предсказать. Потому что,
[01:19:03.760 --> 01:19:10.360]  ну, биты просто будут, ну, там, деление на 2 в nt это будет по битовый сдвиг, а во float,
[01:19:10.360 --> 01:19:15.440]  ну, у тебя там мантиса съедет на экспоненту. Ну, то есть, те же самые биты он будет читать,
[01:19:15.440 --> 01:19:22.040]  как будто это float. Понятно? Соответственно, ты можешь y поделить на 2 и посмотреть, как x изменится.
[01:19:22.040 --> 01:19:26.640]  Ну, он выполнит деление в исчезных числах, закодирует этот float обратно, как если бы он делел
[01:19:26.640 --> 01:19:39.800]  на nt на 2. И int при этом прочитается как-то иначе. Нет, не всегда. Ну, reinterpret cast. На самом
[01:19:39.800 --> 01:19:44.480]  деле, reinterpret cast у b почти всегда за редким списком случаев, которые, я не помню, ну,
[01:19:44.480 --> 01:19:50.920]  можно на cpp-референс прочитать. Но это действительно иногда нужно, когда у вас есть какие-то структуры,
[01:19:51.480 --> 01:19:56.480]  ну, у вас есть какие-то структуры данных там, с какими-то полями вида там. Ну, допустим,
[01:19:56.480 --> 01:20:03.320]  у вас есть структура, ну, именно struct, и в ней много int в подряд лежит. И вам нужны эти int там,
[01:20:03.320 --> 01:20:15.800]  ну, например, вам, например, да, хочется, чтобы вы считали эту структуру. Ну,
[01:20:15.800 --> 01:20:21.360]  ну, в случае с практики, например, бывает такое, у вас есть какие-нибудь id-шники,
[01:20:21.360 --> 01:20:25.160]  они хранятся там, определенная структура, там юзер какой-нибудь, да, у него есть id-шник
[01:20:25.160 --> 01:20:32.000]  такой, id-шник сикой. И вам надо эту структуру интерпретировать как структуру другой вид
[01:20:32.000 --> 01:20:36.960]  id-шника, но вы знаете, что там ровно те же числа в таком же порядке лежат. Чтоб вам стать и кастом
[01:20:36.960 --> 01:20:41.600]  копию всех этих чисел не создавать, вы можете сказать, считай просто, что это такой, ну, другие
[01:20:41.600 --> 01:20:45.960]  виды id-шников, но они просто лежат в таком же порядке, в таком же размере, и вы точно знаете,
[01:20:45.960 --> 01:20:50.720]  что они так и лежат. То есть вам, вы reinterpret cast экономите операции просто, тем самым,
[01:20:50.720 --> 01:21:04.600]  вы читаете биты как другие типы. Да, он будет читать этот и следующий за ним 4 байта. То есть,
[01:21:04.600 --> 01:21:10.400]  если вы reinterpret cast эти типы, у которых не совпадают размеры, ну, удачи вам, как говорится,
[01:21:10.400 --> 01:21:19.200]  просто вы будете читать следующие биты, он будет, да. Конечно, можно. У B, что вы хотите?
[01:21:19.200 --> 01:21:35.000]  Статические ссылки, что такое статические ссылки? Константный ты имел в виду? Можем,
[01:21:35.000 --> 01:21:44.600]  сейчас расскажу как. Статик каст — это вообще не то же самое, что reinterpret. Статик каст — это
[01:21:44.600 --> 01:21:52.880]  создать из одного типа другой тип. Нет, нельзя. Нельзя статик кастом сказать, прочитай биты одного
[01:21:52.880 --> 01:21:59.360]  числа как другой тип. Можно ли только создать одно число из другого по некоторым правилам
[01:21:59.360 --> 01:22:07.160]  создания. Double вот умеет создаваться из МТА. Потому что я не создаю новый флоат. Я считаю,
[01:22:07.160 --> 01:22:13.120]  что вот те биты, которые там написаны, это и есть флоат. reinterpret каст не умеет создавать
[01:22:13.120 --> 01:22:17.600]  новые сущности. Он умеет только смотреть на существующие сущности, как будто они другой
[01:22:17.600 --> 01:22:24.080]  тип. Вот поэтому ссылка. Вот это выражение оно LVL на самом деле, опять-таки. Вот ему присваивать
[01:22:24.080 --> 01:22:28.880]  можно. Потому что ссылка, она как бы говорит, смотри на то, что у тебя уже есть, как будто это
[01:22:28.880 --> 01:22:42.680]  тип другой. Да. Да, по-моему. А может и нет. Я не помню. По-моему, там есть оговорки, по которым
[01:22:42.680 --> 01:22:52.800]  это не undefined behavior. Да. Никак не работает. Игнорирует их. Ну как, если у вас одинаковый,
[01:22:52.800 --> 01:22:58.000]  если вы знаете, что типы одинаковые по внутренней структуре, и вам надо просто один трактовать как
[01:22:58.000 --> 01:23:07.400]  другой, вы можете reinterpret кастнуть. Еще раз. Я не понимаю, о чем вы хотите спросить. Еще раз.
[01:23:07.400 --> 01:23:12.160]  У вас есть два типа, и вы просто читаете биты одного как биты другого. Если вы знаете,
[01:23:12.160 --> 01:23:17.040]  что биты одного в точности лежат так же, как биты другого, там ровно те же числа, ровно в том
[01:23:17.040 --> 01:23:23.320]  же порядке, ровно с теми же промежутками, то вы можете reinterpret кастнуть. То все сбилось бы,
[01:23:23.320 --> 01:23:35.320]  и вы бы читали числа не по тем битам. Да. Вот. Можно reinterpret кастить указателя. Можно reinterpret
[01:23:35.320 --> 01:23:41.160]  кастить от одного указателя к другому указателю. То есть я могу, например, сказать float звездочка
[01:23:41.160 --> 01:23:53.000]  y равно, ну я могу вот так еще делать. То есть я могу по плюсовому, скажем так, ссылку, ну прям в лоб,
[01:23:53.000 --> 01:23:58.560]  а могу вот указатель на одно считать указателем на другое. Потом, когда разами новую, ну будет,
[01:23:58.560 --> 01:24:05.880]  по сути, то же самое. Вот. Короче, reinterpret каст — это первое запрещенное заклинание языка C++.
[01:24:05.880 --> 01:24:20.440]  Оно, возможно, вам будет иногда нужно, но я не рекомендую. Ну, в общем, используется осторожностью,
[01:24:20.440 --> 01:24:29.440]  только в экстренных ситуациях. Нет, ну на нашем курсе нет. Я не знаю, с Филиппом будете вы или нет
[01:24:29.440 --> 01:24:36.280]  писать это нам. Так, это первое. Теперь второе запрещенное заклинание, которое хуже, чем reinterpret
[01:24:36.280 --> 01:24:42.880]  каст, я считаю. reinterpret каст, я вам сказал, умеет кастить любой тип к любому с некоторыми
[01:24:42.880 --> 01:24:47.800]  оговорками. На самом деле, по сути, с одной единственной оговоркой — он конст снимать не умеет.
[01:24:47.800 --> 01:25:12.920]  Ну, быстрее, быстрее. Я не понимаю, давай ты в перерыв подойдешь, сейчас я хочу закончить
[01:25:12.920 --> 01:25:18.920]  быстро, устроить перерыв, и надо уже дальше двигаться. Сейчас я расскажу про два оставшихся каста,
[01:25:18.920 --> 01:25:28.480]  и мы закончим. const каст. reinterpret каст все умеет, кроме одного, он const не может снять и навесить
[01:25:28.480 --> 01:25:35.480]  не может. Если у вас была ссылка на int, если у вас была ссылка на константный int, то reinterpret
[01:25:35.480 --> 01:25:46.880]  кастом вы не сможете сделать из нее ссылку на обычный int. Навесить? Навесить, кстати, навесить
[01:25:46.880 --> 01:25:51.320]  может и может, ладно, снять не может. То есть, если у вас была ссылка на, если у вас был int,
[01:25:51.320 --> 01:25:56.920]  если у вас был константный int, то вы reinterpret кастом не можете его скастить к неконстантному,
[01:25:56.920 --> 01:26:02.120]  да неважно к чему. Вот к чему бы вы не кастили, только к константному сможете. reinterpret
[01:26:02.120 --> 01:26:08.960]  каст не умеет снимать конст, а const каст умеет. Вот если вам нужно снять конст вероломно, то есть,
[01:26:08.960 --> 01:26:15.360]  у вас есть переменная, у которой тип константное что-то, а вы хотите сказать, мне наплевать,
[01:26:15.360 --> 01:26:22.280]  что она константная, я все равно хочу выполнить над ней операции изменения. Тогда у вас есть const
[01:26:22.280 --> 01:26:39.680]  каст. Это второе по ужасности запрещен заклять, да. С++ неисчерпаемо богато, он позволяет тебе
[01:26:39.680 --> 01:26:46.760]  иногда делать, с++ он позволяет тебе, он у тебя есть как бы экстренные, для экстренных ситуаций
[01:26:46.760 --> 01:27:05.360]  нужны экстренные меры. const каст очень плохо, но это нужно для экстренных ситуаций, для экстренных
[01:27:05.360 --> 01:27:14.200]  ситуаций экстренные меры. У нас в курсе будет как минимум одна ситуация, когда нужно const каст
[01:27:14.200 --> 01:27:20.040]  использовать во втором семестре. Когда вы до нее доживете, вы поймете, что иногда это полезно.
[01:27:20.040 --> 01:27:25.920]  Иногда это очень сильно в разы упрощает код, вам не приходится дублировать много строк благодаря
[01:27:25.920 --> 01:27:32.000]  этому. Вот const каст уб, за исключением ситуации, когда у вас изначально это действительно было не
[01:27:32.000 --> 01:27:42.600]  const. Какое корректное использование const каста? Вот у вас был int, смотрите, вот у вас был int,
[01:27:42.600 --> 01:27:52.520]  потом вы сделали const int % ссылку на него, и вы хотите теперь сделать опять неконстантную ссылку
[01:27:52.520 --> 01:27:58.400]  на то же самое, имея y. Вот вы допустим y приняли функцию по константной ссылке, но вы из каких-то
[01:27:58.400 --> 01:28:02.520]  соображений знаете, что изначально он вообще-то был неконстантным, вам просто дали его как константу.
[01:28:02.520 --> 01:28:11.640]  Тогда const каст легален, вы можете сказать const каст к int % const каст, как и reinterpret,
[01:28:11.640 --> 01:28:16.280]  он только к указательным и к ссылкам может. И все, что он умеет, это добавлять и снимать const.
[01:28:16.280 --> 01:28:28.120]  const каст к int % от y, там равно единице. Вот это нормально, это lvalue, разумеется, это ссылка. Вот.
[01:28:28.120 --> 01:28:38.440]  Вот это корректное использование const каста. И x, конечно, изменится, да. Вот. Но если x изначально
[01:28:38.440 --> 01:28:49.280]  действительно был константный, то это UB. Я не знаю, что ты хочешь сказать про const итератор.
[01:28:49.280 --> 01:28:58.960]  Давай не, пожалуйста, давай в перерыве, очень-очень-очень напаздываю. const каст умеет только снимать
[01:28:58.960 --> 01:29:04.960]  и добавлять const. Если вам надо из константного intа получить неконстантный даббл, то вам нужно
[01:29:04.960 --> 01:29:19.440]  сделать сначала reinterpret к const int, а потом const каст к обычному int. Так. Нет, это все lvalue,
[01:29:19.440 --> 01:29:29.440]  к ссылке и к указателю, к указателю lvalue. Они не создают новые объекты, они смотрят на старые
[01:29:29.440 --> 01:29:36.800]  объекты через другой тип. И последнее. Sistyle каст. Это одно из самого плохого, что вы вообще
[01:29:36.800 --> 01:29:45.520]  можете написать. Значит, что на самом деле такое Sistyle каст? Sistyle каст запрещен код стайлом. Вот
[01:29:45.520 --> 01:29:51.360]  конст каст иногда бывает нужен. И иногда он вам один раз даже в курсе понадобится. Reinterpret
[01:29:51.360 --> 01:29:57.040]  каст тоже вам может быть пару раз понадобится. Но Sistyle каст мы будем банить жестко. Как работает
[01:29:57.040 --> 01:30:04.080]  Sistyle каст? Работает он так. Сначала он пробует, нельзя ли обойтись одним конст кастом. Нельзя
[01:30:04.080 --> 01:30:09.040]  ли обойтись навешиванием или сбрашиванием константы. Если нельзя, то он пытается сделать static
[01:30:09.040 --> 01:30:14.400]  каст. Если нельзя, то он пытается сделать static каст, а поверх него const каст. Если нельзя, то он
[01:30:14.400 --> 01:30:18.880]  пытается сделать reinterpret каст. А если это нельзя, то он пытается сделать reinterpret каст, а поверх
[01:30:18.880 --> 01:30:26.520]  него const каст. И только если ничего из этого нельзя, CE. Когда вы на самом деле пишете вот в таких
[01:30:26.520 --> 01:30:32.800]  круглых скобочках приведения типа, вы сами того не подозревая, проходите все вот эти стадии
[01:30:32.800 --> 01:30:44.720]  принятия, значит, последовательно. Нет, reinterpret от static, но это бессмысленно. В смысле const
[01:30:44.720 --> 01:30:51.680]  reinterpret от static это бессмысленная конструкция. Ты сначала пытаешься static, потом static,
[01:30:52.280 --> 01:30:56.920]  потом const, а потом static. Если это не получилось, значит, нормального способа привести нет,
[01:30:56.920 --> 01:31:03.240]  значит, ты только reinterpret можешь пытаться сделать. Тогда reinterpret, потом const. И все. И самое
[01:31:03.240 --> 01:31:08.080]  плохое, что вы не знаете, какой из этих кастов реально сработает. Когда вы пишете c style каст,
[01:31:08.080 --> 01:31:13.080]  вы можете забыть константу, навесить лишний амперсант, навесить лишнюю звездочку. Это все
[01:31:13.080 --> 01:31:18.560]  вам будет прощено, потому что он просто будет перебирать подряд касты, какой-нибудь да получится.
[01:31:18.560 --> 01:31:24.720]  Таким образом, вы можете словить уб совершенно этого не заметив. Поэтому c style каст c++ в код
[01:31:24.720 --> 01:31:28.880]  стайле запрещен и использовать ее рекомендуется только в низкоуровневом коде, когда вам почему-то
[01:31:28.880 --> 01:31:41.480]  нужно писать на c, а не на c++. Но в нашем случае c style каст будет запрещен в коде. Вот это все,
[01:31:41.480 --> 01:31:46.040]  что я хотел рассказать вам о приведениях типов. И мы закончили главу вторую, и давайте сделаем
[01:31:46.040 --> 01:32:01.400]  перерыв. Мы до сих пор разговаривали о том, что есть какие-то переменные, есть какие-то типы,
[01:32:01.400 --> 01:32:12.000]  можно что-то создавать, можно объявлять переменные, и можно с этими переменными
[01:32:12.000 --> 01:32:16.120]  что-то делать в зависимости от того, какого они типа. Вот, но сейчас мы начнем говорить о том,
[01:32:16.120 --> 01:32:22.200]  как свои собственные типы объявлять и определять. Вот, и два наиболее распространенных способа
[01:32:22.200 --> 01:32:30.520]  объявить свой собственный тип c++ это объявить структуру либо объявить класс. Да, можно еще объявить
[01:32:30.520 --> 01:32:38.800]  enum, можно еще объявить union, но про них мы попозже поговорим. Вот, но мы сейчас будем говорить про
[01:32:38.800 --> 01:32:45.920]  структуру и классы, и в рамках этого пункта, а именно в рамках пункта 3.1, я буду считать,
[01:32:45.920 --> 01:32:52.480]  что структура и класса это полные синонимы. На самом деле это почти правда. Структура и класс
[01:32:52.480 --> 01:32:59.800]  c++ это почти одно и то же, с очень-очень маленькой разницей, о которой я скажу вскоре, но пока я буду
[01:32:59.800 --> 01:33:09.000]  считать, что это совсем одно и то же. И я буду писать структуру вместо класс. Вот, как это...
[01:33:09.000 --> 01:33:17.240]  Ну что ж такое, слушайте, ну все-то вам не так. Ну как же, ну потерпите.
[01:33:17.240 --> 01:33:39.000]  Вот, я пишу структуру, объявляю имя структуры. Стракт я пишу. Это структура.
[01:33:48.240 --> 01:34:00.600]  Так, я не помню, что у меня там... Сейчас. Блин, ну мне нужно из полноэкранного режима выходить,
[01:34:00.600 --> 01:34:11.520]  типа, да. Сейчас, ну е-мое, ну что ж такое. Ну хорошо, давайте вот так сделаем, ладно. Если так, лучше.
[01:34:17.240 --> 01:34:29.840]  Так, все. Я объявил структуру. Тихо, пожалуйста. Я объявил структуру, назвал ее s. В принципе,
[01:34:29.840 --> 01:34:36.720]  на этом можно и закончить. Вот, но я могу структуру определить. Для структур, как и для функций,
[01:34:36.720 --> 01:34:45.040]  я могу писать отдельное объявление, отдельное определение. Вот, после определения, кстати,
[01:34:45.040 --> 01:34:49.800]  нужно точку запятой ставить. Такое довольно странное правило, после определения функций точку
[01:34:49.800 --> 01:34:56.040]  запятой ставить нельзя, после определения структуры нужно. Вот, ну что из себя представляет структура?
[01:34:56.040 --> 01:35:06.080]  Ну, обычно в структуре какие-то данные лежат. Вот эти данные называются полями структуры.
[01:35:06.080 --> 01:35:28.600]  Введение в ООП. Introduction to OOP. Ну, я могу внутри структуры объявить какие-то поля,
[01:35:28.600 --> 01:35:34.000]  то есть данные, которые в этой структуре храниться будут. Ну, давайте там, не знаю,
[01:35:34.000 --> 01:35:46.920]  int x, double y, char c. Вот, вот это поля. Соответственно, я могу теперь в мейне создавать переменные
[01:35:46.920 --> 01:35:56.160]  такого типа, как эта структура. И, ну, по умолчанию поля будут проницилизированы каким-то мусором,
[01:35:56.160 --> 01:36:05.440]  как и в случае с локальными переменными. Вот, но я могу чем-то их проницилизировать по умолчанию.
[01:36:05.440 --> 01:36:12.840]  Например, могу сказать int x равно 1, double y равно там 3 и 14, char c равно a. Вот, тогда,
[01:36:12.840 --> 01:36:17.480]  когда я создаю структуру по умолчанию, эти поля будут проницилизированы вот чем там написано.
[01:36:17.480 --> 01:36:24.440]  Вот, а я могу сделать и так. Я могу сказать при создании структуры явно, чем проницилизировать
[01:36:24.440 --> 01:36:30.520]  поля. Это делается следующим образом. Я открываю фигурные скобочки и говорю,
[01:36:30.520 --> 01:36:44.920]  например, вот так вот. Я перечислил значения полей в том порядке, в котором они были объявлены
[01:36:44.920 --> 01:36:53.720]  в структуре. Таким образом, я проницилизировал структуру своими значениями. Если бы я не написал
[01:36:53.720 --> 01:36:56.400]  чем, то они бы проницилизировались по умолчанию. Если там не написано чем,
[01:36:56.400 --> 01:37:01.960]  то они бы мусором проницилизировались. Вот, я могу не все, кстати, так указать. Я могу сказать только
[01:37:01.960 --> 01:37:10.000]  вот так. Тогда остальные проницилизируются по умолчанию. Вот это вот называется агрегатная
[01:37:10.000 --> 01:37:20.760]  инициализация. Когда я инициализирую фигурными скобочками, перечисляя поля по порядку. Вот в
[01:37:20.760 --> 01:37:25.360]  каком порядке поля объявлены, в таком они и будут применяться. Если там типы не соответствуют,
[01:37:25.360 --> 01:37:31.040]  то будет CE. Либо преобразование типов, либо CE. Вот, как обращаться к полям структуры. Для
[01:37:31.040 --> 01:37:40.880]  этого существует оператор точка. Я могу вывести поля этой структуры. Я могу сказать s.x, s.y, s.c.
[01:37:40.880 --> 01:38:04.800]  s.c. Вот сейчас я поля этой структуры увижу, как они есть. Первое поле проницилизировалось
[01:38:05.280 --> 01:38:13.920]  двойкой, а остальные проницилизировались, чем было написано по умолчанию. Вот, это оператор
[01:38:13.920 --> 01:38:18.920]  точка. Если я имею дело с указателем на структуру, то я могу использовать оператор
[01:38:18.920 --> 01:38:26.400]  стрелочка для доступа к полям. Давайте, допустим, скажем, что у меня есть... Ой. Допустим,
[01:38:26.400 --> 01:38:41.720]  я... Что ж такое? Что я сделал? Извините. Так. Да, мастер ВИМА. Ну, я могу вот так сделать.
[01:38:41.720 --> 01:38:49.680]  Вот. То есть, я скажу, что... Давайте, скажем, я структуру в динамической памяти создал. А,
[01:38:49.680 --> 01:39:00.320]  да. Ну, s. p.s. Тогда мне нужно будет в конце обязательно писать delete p.s. А тут я... p.s
[01:39:00.320 --> 01:39:04.720]  теперь это у меня указатель. Вот если я имею дело с указателем на структуру, то чтобы мне по
[01:39:04.720 --> 01:39:12.240]  указателю на структуру обращаться к полям... Ну, я мог бы, конечно, писать вот так. Да,
[01:39:12.240 --> 01:39:17.920]  то есть, в скобочках звездочка p.s, а потом точка x. То есть, если я напишу без скобочек,
[01:39:17.920 --> 01:39:26.320]  точка приоритетнее, чем звездочка, поэтому оно будет неправильно работать. Вот. Ну,
[01:39:26.320 --> 01:39:32.920]  чтобы мне не приходилось писать вот так, в c++ придуман оператор стрелочка. Это вот так пишется.
[01:39:32.920 --> 01:39:39.440]  Значит, оператор стрелочка — это как бы разыменование и сразу обращение к полю.
[01:39:39.440 --> 01:39:53.120]  Вот. Ну, сейчас будет то же самое, что и раньше. Вот. Кроме полей, я могу в структуре объявлять
[01:39:53.120 --> 01:40:02.240]  еще методы. Методы — это функции. Ну, по сути, это операции, которые можно производить над
[01:40:02.240 --> 01:40:10.520]  структурой. Я могу объявить, ну, какой-нибудь метод f. Вот. Функции, которые объявлены в структуре,
[01:40:10.520 --> 01:40:15.800]  называются методами структуры. Я могу объявить какой-нибудь метод f, который, ну, собственно,
[01:40:15.800 --> 01:40:24.800]  и выводит, допустим, эти поля. Вот. Когда я нахожусь в методе, мне не нужно писать там. То есть,
[01:40:24.800 --> 01:40:31.000]  когда я нахожусь в методе, подразумевается, что поля у меня уже есть. То есть, я реализовываю
[01:40:31.000 --> 01:40:35.840]  операцию над некоторым существующим объектом своей структуры. То есть, я просто здесь пишу вот так.
[01:40:35.840 --> 01:40:57.040]  Да. И вот здесь я напишу, давайте я это удалю. Я напишу s, s там от 2. И дальше я пишу s.f. Я вызываю
[01:40:57.040 --> 01:41:06.960]  метод f у структуры s. Этот метод, в свою очередь, у данного экземпляра структуры выполняет вот это.
[01:41:06.960 --> 01:41:13.240]  Но в данном экземпляре структуры понятно, что x, y, z означают те вот значения, которые там лежат в
[01:41:13.240 --> 01:41:20.240]  этом экземпляре. Вот. Экземпляры структуры называются объектами. То есть, s – это объект,
[01:41:20.240 --> 01:41:26.240]  а это метод объекта. Но я, понятное дело, могу в f передать какие-нибудь параметры. Я могу из f
[01:41:26.240 --> 01:41:41.000]  что-нибудь вернуть. Вот. Ну, то есть, обычная функция просто у нее есть еще дополнительные
[01:41:41.000 --> 01:41:55.560]  переменные. Это поля этой структуры. Вот. Дальше вот такую ситуацию разберем. Вот я, допустим,
[01:41:55.560 --> 01:42:04.360]  захотел сделать функцию от какого-нибудь числа. Я передал параметр сюда. Тогда вот этот x,
[01:42:04.360 --> 01:42:12.480]  он будет означать какой x? Параметр. Как мне обратиться к полю, если у меня x затмевает
[01:42:12.480 --> 01:42:22.040]  название этого поля? Есть ключевое слово vis. Есть ключевое слово vis, которое позволяет явно
[01:42:22.040 --> 01:42:28.120]  обратиться к указателю на данный объект из тела объекта. То есть, я сейчас нахожусь в методе
[01:42:28.120 --> 01:42:34.840]  объекта, то есть в теле объекта. Я хочу получить указатель на данный объект из тела. Для этого
[01:42:34.840 --> 01:42:41.040]  я пишу vis. Vis – это указатель на данный объект. Соответственно, получить поле x данного объекта
[01:42:41.040 --> 01:42:57.400]  я могу вот так. Да. Функции, если я объявляю методы в структуре, то неважно в каком порядке
[01:42:57.400 --> 01:43:03.000]  их объявляю. В рамках тела структуры, неважно в каком порядке объявлены методы. Они видят
[01:43:03.000 --> 01:43:10.840]  все друг друга. Вообще, эта область видимости фигурными скобками ограничена. Она называется
[01:43:10.840 --> 01:43:19.440]  classScope. В ней можно тоже делать только объявления. Я не могу здесь писать expression,
[01:43:19.440 --> 01:43:24.200]  я не могу здесь писать control statement. Вот здесь я могу писать только объявления. Либо полей,
[01:43:24.200 --> 01:43:29.680]  либо методов, либо внутренних типов. Я могу здесь написать using vi равно vector int. Это будет
[01:43:29.680 --> 01:43:36.000]  означать, что локально в рамках этой структуры vi означает vector int. Я могу делать, конечно же,
[01:43:36.000 --> 01:43:41.480]  перегрузку методов. Я могу сделать f без параметров, а могу сделать f от int. Это будут два разных метода,
[01:43:41.480 --> 01:44:03.880]  называющиеся одинаково, с разной сигнатурой. Это я объявил структуры, рассказал про слово vis
[01:44:03.880 --> 01:44:23.080]  и про поля и методы. Я могу метод объявить внутри структуры и определить вне. Например,
[01:44:23.080 --> 01:44:28.800]  я этот метод объявил здесь, а определить захотел из вне. Как мне это сделать? Понятно как,
[01:44:28.800 --> 01:44:40.320]  так же как с namespace. Я просто говорю, что я теперь этот метод, пишу void s 2.2 f и определяю. Ну и
[01:44:40.320 --> 01:44:47.720]  разумеется, здесь отсюда мне будут видны поля моей структуры и я могу запросто обратиться к ним.
[01:44:47.720 --> 01:44:53.760]  То есть тот факт, что я вне структуры определяю метод, никак не мешает мне видеть все поля и
[01:44:53.760 --> 01:45:15.640]  обращаться к ним с полным правым доступом. Дальше. Я могу внутри структур объявлять другие структуры.
[01:45:15.640 --> 01:45:24.120]  Тогда они называются inner classes, внутренние классы. Я использую слова классы и структуры как синонима.
[01:45:24.120 --> 01:45:38.360]  Внутренние классы. То есть я могу внутри s объявить еще структуру, стракт ss. И она будет хранить в себе,
[01:45:38.360 --> 01:45:53.520]  не знаю, что-нибудь простое, float, f. Вот. И могу например объявить поле такого типа. Вот.
[01:45:53.520 --> 01:45:59.640]  Соответственно из вне я тоже могу видеть эту структуру. То есть я могу захотеть объявить из
[01:45:59.640 --> 01:46:07.520]  мэйна объект типа ss, но для этого мне нужно указать откуда он. То есть я вот так вот буду вынужден это писать.
[01:46:07.520 --> 01:46:23.080]  Все? Нет, подожди, что значит поля из…
[01:46:29.640 --> 01:46:54.480]  Так, минуточку. Ss это тип. Я не понимаю вопрос. Что ты хочешь написать? После структа завести
[01:46:54.480 --> 01:47:18.840]  новую переменную. Где? В мэйне? Вот здесь. Завести переменную. Что такое b? А, ну и что? А что такое d?
[01:47:18.840 --> 01:47:25.880]  D откуда? Из какого объекта? Из какого объекта она взята? S это тип, а не объект.
[01:47:25.880 --> 01:47:38.440]  Ну вопрос бессмысленный, потому что поля имеет смысл брать только у существующего объекта. Да.
[01:47:38.440 --> 01:47:48.080]  Нет, нет, нет, нет. Я не буду сейчас… В перерыве. Вопрос забанен. Про статические поля потом.
[01:47:48.080 --> 01:47:56.720]  Можем инициализировать поля не константно? Можно инициализировать переменную. Ну да,
[01:47:56.720 --> 01:48:02.240]  я могу написать double y равно x, например. Но я могу и экспрешным каким-то инициализировать, да,
[01:48:02.240 --> 01:48:10.480]  результатом функции. Вы это сделаете, если у вас… Если циклические зависимости. Поля инициализируются в
[01:48:10.480 --> 01:48:23.080]  порядке объявления. Сначала x, потом y, потом c, потом d. Нет, я имел в виду, вы же это инициализируете,
[01:48:23.080 --> 01:48:29.520]  у вас не создается инициализация структуры. Не, не, не. Когда я пишу здесь инициализацию,
[01:48:29.520 --> 01:48:34.840]  это означает следующее, что если экземпляр будет создан по умолчанию, то эти поля должны
[01:48:34.840 --> 01:48:40.960]  быть инициализированы этим. Когда я здесь инициализирую чем-то поля, то я указываю
[01:48:40.960 --> 01:48:43.920]  инициализаторы по умолчанию. Это значит, что в момент, когда будет создаться структура,
[01:48:43.920 --> 01:48:49.560]  они инициализируются этим. Это не значит, что я объявляю перемену такого типа, они прямо сразу…
[01:48:49.560 --> 01:49:04.680]  Пока я не создал s объект, я ничего не инициализировал нигде. Внутри чего? Что такое double s? Где? Вот здесь?
[01:49:04.680 --> 01:49:17.560]  Что написать? Что такое y? Y откуда? Y бывает у объекта. Нету никакого объекта.
[01:49:17.560 --> 01:49:27.560]  Y это поле объекта. У какого объекта ты берешь поле? Нет, ss это другой тип. Хоть он и внутри s
[01:49:27.560 --> 01:49:31.800]  находится, это другой тип, никак не связанный с s. Он просто виден только изнутри s.
[01:49:34.680 --> 01:49:40.600]  Да, конечно, вот я это и сделал в мейне. Я создал ss и назвал его ss маленькое. Это никак
[01:49:40.600 --> 01:49:52.920]  не связанный с s тип. Просто его область видимости ограничена типом s. Можно? Конечно. Я внутри ss.
[01:49:52.920 --> 01:50:04.600]  В смысле, где? Вот тут? Не понял, где? Вот здесь.
[01:50:04.600 --> 01:50:28.440]  Здесь, что ли? Здесь? Вот так? После скобочки? Вот так? Так можно делать, потому что вы можете
[01:50:28.440 --> 01:50:35.320]  тем самым... Я объявил структуру и сразу же создал переменную такого типа. Да, так можно.
[01:50:35.320 --> 01:50:47.960]  Зачем? Это будет поле, да? Это будет поле s, да. Какое поле? Кольцо, блин. Это поле без объявленного
[01:50:48.200 --> 01:50:59.160]  Математик детектат просто. Это будет поле... В смысле, без объявлённого? Это поле типа ss.
[01:50:59.160 --> 01:51:05.400]  Тип ss только что определён. В чём проблема? Это переменная ss, которая имеет тип ss, да?
[01:51:05.400 --> 01:51:12.920]  Это переменная ss маленькая, которая имеет тип ss большой, да. Это переменная ss маленькая с типом ss большой?
[01:51:13.000 --> 01:51:29.080]  Да. Я объявил тип и сразу же переменную такого типа. Это будет поле класса s. Что? Это поле s,
[01:51:29.080 --> 01:51:42.200]  полноценное поле s. Я могу сказать s.ss. Так, по одному. Что ты хотел сказать? Ещё или всё? Всё.
[01:51:42.440 --> 01:51:46.520]  Чё там кто хотел сказать? Никто. Ты давай теперь.
[01:51:46.520 --> 01:52:02.520]  Мы можем вот это ss маленькое по агрегатно-баннистерской? Да. Да. Агрегатно, я думаю, да. Ну, давайте попробуем.
[01:52:02.520 --> 01:52:14.920]  Ну, по идее должно быть можно. Я не уверен, да, можно. Но агрегатная инициализация для полей, да,
[01:52:14.920 --> 01:52:24.520]  почему бы и нет. Можем создавать объекты класса ss вне? Конечно, можем. Объекты класса ss вне? Да,
[01:52:24.520 --> 01:52:35.400]  можем. Я же в мейне сделал это. Вот я сделал. Флот d равно… Что такое y? Это поле… Где? В каком объекте?
[01:52:35.400 --> 01:52:45.600]  У нас есть структура s. У нас есть структура s и вот это… Когда ты объявляешь, у тебя нет ни одного
[01:52:45.600 --> 01:52:53.000]  объекта s. Откуда ты берёшь y? Ну, вот вам будет ошибка компиляции сейчас.
[01:52:53.000 --> 01:53:00.520]  Ну, типа нельзя обращаться к полю, не имея объекта соответствующего типа.
[01:53:00.520 --> 01:53:07.000]  Просто в джаве вложенные ссылки, это имеют типа ссылку на хозяина и что-то такое,
[01:53:07.000 --> 01:53:12.720]  поэтому можно к ним обращаться. Нет-нет-нет-нет, подожди-подожди. Одно дело ссылка на родителя,
[01:53:12.720 --> 01:53:18.640]  другое дело внутренний класс внутри внешнего класса. Ты, наверное, имеешь в виду ссылка на
[01:53:18.640 --> 01:53:27.760]  типа parent, ну как это супер? На родителя. Нет, на хозяина, типа внутри которого и поэтому он как-бы
[01:53:27.760 --> 01:53:33.960]  может обращаться. Что такое хозяин? Здесь нет ни одного объекта. Так, какая разница? Это хоть
[01:53:33.960 --> 01:53:42.200]  джава, хоть плюсы есть? Я бил класс внутри класса, а объект откуда взялся? В общем, если… Так,
[01:53:42.200 --> 01:53:58.360]  ладно, нет, это долго. А ты что хотел сказать? Что понадобится? Ну, внутри какого-то… Ты пишешь
[01:53:58.360 --> 01:54:04.360]  очень большой класс. Тебе нужен какой-то тип только в рамках определения своего внешнего типа.
[01:54:04.360 --> 01:54:11.160]  Вполне себе нормальная ситуация. Ты реализуешь вектор. Внутри вектора нужно написать итератор.
[01:54:11.160 --> 01:54:22.120]  Вектор int 2.2. итератор – это внутренний тип в векторе. Да, вот внутри вектора есть такая внутренняя
[01:54:22.120 --> 01:54:30.760]  структура, итератор. Вот вам пример. Что? Функции внутри функции нельзя. А ты что хотел сказать?
[01:54:34.360 --> 01:54:44.120]  Да, кстати, спасибо. Начиная с и плюс-плюс-двадцать, есть так называемый design initializers. Сейчас я
[01:54:44.120 --> 01:55:00.720]  покажу, что это такое. Я могу писать так. s.x равно 2.y равно… Это не параметры функции, это
[01:55:00.720 --> 01:55:12.000]  инициализаторы. Но это начинает с и плюс-плюс-двадцать. Можно и не по порядку. Да, в этом и смысл. Так,
[01:55:12.000 --> 01:55:19.880]  тут правда у меня сейчас будет непоняточка. Да, это design initializers. Почему-то он меня компилирует
[01:55:19.880 --> 01:55:28.520]  по умолчанию с и плюс-плюс. Странно. Ну, значит он поддерживает уже без всяких дополнительных
[01:55:28.840 --> 01:55:35.960]  флагов. Вот, да, можно и так. Так, окей, ладно, идем дальше. Еще можно объявлять структуры
[01:55:35.960 --> 01:55:40.280]  внутри функций. Вот функции внутри функций нельзя. Но структуры внутри структур можно,
[01:55:40.280 --> 01:55:49.720]  и структуры внутри функций можно. Внутри функций я могу объявить структуру. Структуры внутри
[01:55:49.720 --> 01:55:55.520]  функций можно объявлять. Внутри функций нельзя объявлять функции? Внутри функций объявлять можно,
[01:55:55.520 --> 01:56:03.640]  определять нельзя. А структуру я могу объявить и определить внутри функции. Но я могу назвать,
[01:56:03.640 --> 01:56:15.560]  ну давайте как-нибудь по-другому назовем. По-другому назовем. Значит, другая структура. Вот, и я могу
[01:56:15.560 --> 01:56:24.560]  соответственно объявлять переменные такого типа. Вот. Интереснее, что я могу возвращать их наружу.
[01:56:24.560 --> 01:56:32.400]  То есть представим, что это не f, а какая-нибудь там другая функция, там g. Да, это не main. А main будет
[01:56:32.400 --> 01:56:46.760]  другой. И вот в main, допустим, я хочу... Ну, смотрите, я написал. Сейчас, минуточку. Так у меня не
[01:56:46.760 --> 01:57:00.920]  получится, так у меня не получится, потому что она еще не объявлена. Да, у меня не получится так
[01:57:00.920 --> 01:57:07.160]  сделать, к сожалению. Ну, я могу... Да, да, так не получится сделать. Но я могу авто написать,
[01:57:07.160 --> 01:57:11.360]  конечно, но про авто я еще не хочу говорить. В общем, я теоретически мог бы этот тип вернуть
[01:57:11.360 --> 01:57:19.320]  наружу из функции и внешней функции его использовать, хотя его объявление было в другой функции. Ну так,
[01:57:19.320 --> 01:57:25.800]  просто тип создается и назвать его извне я не могу. Название, видимо, только из функции. Но сам тип
[01:57:25.800 --> 01:57:44.160]  можно... Что? Нет, про авто забудьте. Все, забудьте про авто, я ничего не говорил про авто.
[01:57:44.160 --> 01:57:52.520]  Значит, просто можно объявлять типы внутри функции. Ну, проблема... Да, сможете. Но проблема в том,
[01:57:52.520 --> 01:57:58.560]  что вам возвращаемый тип никак не назвать, потому что он еще не объявлен, а слово авто мы пока не
[01:57:58.560 --> 01:58:08.960]  знаем. Да, но вы никак не скастуете его к тому типу, которому надо, потому что назвать тот тип вы
[01:58:08.960 --> 01:58:33.440]  не можете извне и вам никакой каст не поможет. Так, хорошо. Значит, вот эти вот эти классы,
[01:58:33.440 --> 01:58:38.280]  которые внутри классов, называются inner classes, внутренние классы, а это называется local
[01:58:38.280 --> 01:58:47.400]  classes, локальные классы или структуры, если они внутри функции. Вот. Ну и еще моментик. Как вы думаете,
[01:58:47.400 --> 01:59:05.320]  какой будет sizeof от этой структуры, вот которой мне сейчас написано? 24. Вот у этой структуры размер
[01:59:05.320 --> 01:59:19.040]  24. Почему 24? Казалось бы, размер nt4, размер w8, размер char1 и размер ss еще 4. Ну, я даже могу
[01:59:19.040 --> 01:59:30.160]  закомментировать это. Нет, таблица функции, это вы что-то намудрили. А, блин. Ну, короче, да, вот я
[01:59:30.160 --> 01:59:34.200]  закомментировал, у меня нет ss теперь. Сейчас еще где-нибудь что-нибудь не скомпилируется. Нет,
[01:59:34.200 --> 01:59:44.160]  все равно 24. Почему размер этой структуры 24? В ней int, double и char лежат. Смотрите фокус. Если я
[01:59:44.160 --> 01:59:56.160]  сейчас вот этот char перемещу сюда. Так, нет. То размер внезапно изменится и станет 16. От того,
[01:59:56.160 --> 02:00:04.840]  в каком порядке я перечисляю поля, зависит размер структуры. Да, потому что переменную типа double
[02:00:04.840 --> 02:00:10.760]  можно класть только по адресу кратному 8, а поля кладутся подряд. Вот в отношении полей компилятор
[02:00:10.760 --> 02:00:15.600]  не имеет права их класть в веном переупорядочивать. Поэтому компилятор сначала кладет int, потом
[02:00:15.600 --> 02:00:21.800]  char, потом double. Но int он кладет на адрес кратный 4, char на следующий за ним ближайший байт, а дальше он
[02:00:21.800 --> 02:00:26.320]  3 байта вынужден пропустить, чтобы double положить на адрес кратный 8. Но если я
[02:00:26.320 --> 02:00:41.440]  char возвращаю сюда, почему размер становится 24? Да, казалось бы я положил int, пропустил 4 байта,
[02:00:41.440 --> 02:00:47.560]  положил double, пропустил, ничего не пропустил, положил сразу char и дальше зачем-то еще 7 байт
[02:00:47.560 --> 02:00:56.840]  зарезервировано. Вот, дело в том, что память округляется до наибольшего поля, потому что
[02:00:56.840 --> 02:01:04.680]  мы исходим из того, что следующую s мы должны уметь положить в притык к предыдущим. То есть
[02:01:04.680 --> 02:01:10.240]  если я заведу массив нескольких s, то мне надо, чтобы они подряд лежали в памяти в притык. А
[02:01:10.240 --> 02:01:15.960]  если я бы не дополнил до 8 байта, то получалось бы, что у следующей s все бы поехало, там уже они
[02:01:15.960 --> 02:01:22.360]  лежали бы не на кратных 4 адресах. Поэтому он дополняет до 8 байт, чтобы следующий экземпляр s,
[02:01:22.360 --> 02:01:36.760]  если это будет массив, лежал вот как надо ровно. Что комплиатор? Что не оптимизирует? В смысле,
[02:01:36.760 --> 02:01:43.360]  почему он не... это и есть оптимизация, что он дополняет до 8. Почему он не меняет местами так,
[02:01:43.360 --> 02:01:58.720]  чтобы всегда было 16? Потому что в случае структур, потому что во многих местах используется тот факт,
[02:01:58.720 --> 02:02:04.120]  что поля лежат подряд. В сишном коде это часто используемый факт, это как раз в частности
[02:02:04.120 --> 02:02:09.520]  вот используется, когда вы хотите реинтерпреткаснуть одну структуру к другой. Вы, когда пишете код со
[02:02:09.520 --> 02:02:13.920]  структурами, вы часто опираетесь на то, что поля подряд лежат. Это вот базовое правило,
[02:02:13.920 --> 02:02:25.400]  которое как бы не нарушается. Кстати, а что если бы я завел структуру, а единственным полем в ней
[02:02:25.400 --> 02:02:43.760]  была бы ссылка? Ну, на Инт. А глобальным Интом? Бьют, но для учебных целей можно. На самом деле
[02:02:43.760 --> 02:02:49.840]  мне сейчас не важно, чем она проинциализирована, потому что я объект не создаю. Какой будет размер
[02:02:49.840 --> 02:03:06.760]  этой структуры? Да, если я такую структуру создам, то размер будет 8, потому что по факту там
[02:03:06.760 --> 02:03:11.400]  хранится указатель на Инт, конечно. Потому что если я ссылку храню как поле структуры, то что
[02:03:11.400 --> 02:03:17.880]  остается делать? Только указатель хранить. Это компилируется. Ссылка не инициализирована,
[02:03:17.880 --> 02:03:23.240]  но я не создаю объекта. Я просто объявил поле. Я сказал, вот структура есть такое поле, но я же
[02:03:23.240 --> 02:03:35.800]  не создал экземпляр. Это просто поле. Я не создал, в смысле, люди с ссылки. Вот если я напишу вот так,
[02:03:35.800 --> 02:03:40.680]  то все это СЕ, потому что ссылка ничем не проинциализирована. Но пока я не создал объекта,
[02:03:40.680 --> 02:03:57.040]  я не пытаюсь реально положить. Вот сейчас нельзя. Так, окей. Ладно, идем дальше. Давайте следующий файл откроем.
[02:03:57.040 --> 02:04:11.640]  Давайте я назову его так. Следующий параграф будет называться инкапсуляция и модификаторы
[02:04:11.640 --> 02:04:27.840]  доступа. Да, давай вопрос. Сайзов… чем ты ее проинциализируешь? Сайзов ссылки – это то же самое,
[02:04:27.840 --> 02:04:32.840]  что сайзов… нельзя спросить сайзов ссылки. Все, что ты спрашиваешь про ссылку, ты спрашиваешь
[02:04:32.840 --> 02:04:50.680]  происходный объект. Понятно? Ну если б я спросил… если я спросил сайзов хаха, то я узнал,
[02:04:50.680 --> 02:04:54.960]  сколько занимает структура в памяти. Но она занимает восемь, потому что там по факту указатель
[02:04:54.960 --> 02:04:58.440]  хранится. Но если б я спросил сайзов ее поля, я бы получил сайзов инта.
[02:05:02.840 --> 02:05:16.480]  Ну в каком смысле отличили? Я узнал, сколько занимает структура. Но если я задам тот же самый
[02:05:16.480 --> 02:05:28.760]  вопрос про ее поле, то мне как будто это инт будет. Это понятно. Ну да. Да, это правда. У одной 4,
[02:05:28.760 --> 02:05:36.920]  у другой 8 будет. Потому что ссылку мы храним как указатель, иначе не получается. Так,
[02:05:36.920 --> 02:06:02.080]  инкапсуляция, модификаторы доступа. Да. Чего-чего-чего? Да. Где сделать?
[02:06:06.920 --> 02:06:24.560]  Нет, нет, нет. Ссылку нельзя перепривязать, понимаешь? Нет смысла делать заглушку под ссылку,
[02:06:24.560 --> 02:06:36.600]  ее нельзя проницилизировать заново будет. Поэтому и нет. То же самое, кстати, с константами.
[02:06:36.600 --> 02:06:40.800]  Константы тоже надо идентифицировать при создании, потому что переприсвоить им ничего нельзя потом.
[02:06:40.800 --> 02:06:47.320]  Так, инкапсуляция. Существует три так называемых принципа ВВП основных,
[02:06:47.320 --> 02:06:53.520]  называются инкапсуляция, наследование и полиморфизм. Вы наверняка о них слышали. Мы их подряд будем
[02:06:53.520 --> 02:06:59.200]  разбирать и начнем с инкапсуляции. Что такое инкапсуляция? Ну, трудно сказать. Кажется,
[02:06:59.200 --> 02:07:07.600]  что сообщество так и не пришло к единому мнению, что это значит. Вот, но почему у меня Bluetooth
[02:07:07.600 --> 02:07:16.640]  включен? Ну, короче, если вы откройте Википедию, там есть два разных объяснения, как можно считать,
[02:07:16.640 --> 02:07:22.080]  что в разных языках программирования. По-разному это определяется. Кто-то говорит, что инкапсуляция
[02:07:22.080 --> 02:07:32.640]  это просто хранение данных и методов работы с ними в одном месте. А кто-то говорит, что инкапсуляция
[02:07:32.640 --> 02:07:38.160]  включает в себя еще и сокрытие, то есть разгонячение доступа к данным методам. Ну, классический
[02:07:38.160 --> 02:07:43.880]  пример со стиральной машинкой. У вас есть стиральная машинка, а в ней несколько кнопок. У
[02:07:43.880 --> 02:07:47.640]  стиральной машинки есть какие-то внутренности, но вы не понимаете, как они работают. Все, что вы
[02:07:47.640 --> 02:07:52.480]  можете делать с стиральной машинкой, нажимать на кнопки и выполнять какие-то предопределенные
[02:07:52.480 --> 02:08:04.240]  операции. Стиральная машинка будет со своими внутренностями. Что? Да, кстати, это вполне
[02:08:04.240 --> 02:08:20.280]  вероятно. Да, это, наверное, правда. Да, инкапсуляция, потому что мы в капсулу вкладываем. Да,
[02:08:20.280 --> 02:08:26.440]  это правда. Это хорошее замечание. Ну вот, у вас есть типа машинка стиральная, и вы умеете только
[02:08:26.440 --> 02:08:32.040]  на кнопки нажимать, а как она внутри реализована вы не знаете. У стиральной машинки есть какие-то
[02:08:32.040 --> 02:08:36.720]  свои внутренние данные, но все, что она вам предоставляет наружу, это интерфейс взаимодействия
[02:08:36.720 --> 02:08:43.080]  с ней. Ну вот, примерно такая идея. Это одна из главных идей ООП, что у вас есть какие-то данные и
[02:08:43.080 --> 02:08:48.640]  есть какие-то методы работы с ними, но наружу вы предоставляете только методы. И вы еще занимаетесь
[02:08:48.640 --> 02:08:58.840]  разграничением доступа. То есть вы говорите, что некоторые методы или поля из вне недоступны должны
[02:08:58.840 --> 02:09:06.920]  быть, а пользоваться внешние юзеры могут только какими-то определенными. Вот для этого существуют
[02:09:06.920 --> 02:09:18.040]  так называемые модификаторы доступа. Это такие специальные слова private и public. Ну protected,
[02:09:18.040 --> 02:09:24.960]  да, но пока мы про них не говорим. Вот, допустим, у меня есть опять-таки какое-то поле, ну и другое
[02:09:24.960 --> 02:09:35.120]  поле. Я могу сказать, что вот это поле приватное. Значит, что я пишу? Я пишу слово private. Тут у меня
[02:09:35.120 --> 02:09:40.000]  автоматический отступ ставится, но обычно слово private по кодстайлу пишется либо на одном уровне
[02:09:40.000 --> 02:09:49.440]  со словом struct, либо на половинчатом отступе. Вот. Ну, я буду писать на одном уровне. Вот, но
[02:09:49.440 --> 02:09:53.560]  по Google кодстайлу вы на половинчатом отступе пишете. И, кстати, это еще одно объяснение,
[02:09:53.920 --> 02:09:59.280]  почему табы не надо использовать. Google кодстайл это же один пробел, то есть private на одном пробеле? Да.
[02:09:59.280 --> 02:10:07.000]  А вот так можно писать, да? Как? На одном пробеле. Да. Ну, если у вас отступ два пробела, то private
[02:10:07.000 --> 02:10:15.280]  вы пишете на одном пробеле. А если отступ один пробел? Вот, а это давайте я напишу public. Если отступ один
[02:10:15.280 --> 02:10:24.920]  пробел, то, значит, не повезло. Ну, пишите с нулевым отступом. Вот. Так, так, так, тихо. Значит, вот,
[02:10:24.920 --> 02:10:30.680]  смотрите, я написал private, и теперь вот это поле у меня недоступное извне, а public это значит
[02:10:30.680 --> 02:10:37.200]  доступное извне. Слова private и public в плюсах, в отличие от java там и c-sharp, они пишутся один раз,
[02:10:37.200 --> 02:10:42.240]  после них ставятся двоеточие, и дальше вот все, что после слова private написано, считается private.
[02:10:42.240 --> 02:10:53.840]  Значит, я могу слова private и public писать сколько угодно раз, в каком угодно порядке. Ну, то есть я
[02:10:53.840 --> 02:10:57.840]  могу написать private, двоеточие, и дальше что-то наобъявлять, потом написать public, что-то наобъявлять,
[02:10:57.840 --> 02:11:02.320]  потом слово private, что-то наобъявлять. То есть слово private распространяется на все, что ниже него,
[02:11:02.320 --> 02:11:09.600]  вплоть до следующего модификатора доступа. Что по кодстайлу сначала вы должны писать? Я...
[02:11:09.600 --> 02:11:18.440]  Сейчас скажу. Значит, что правильно писать в начале, что в конце, это тоже спорный философский
[02:11:18.440 --> 02:11:23.360]  вопрос. Разные кодстайлы советуют по-разному. Кто-то считает, что нужно сначала писать public,
[02:11:23.360 --> 02:11:27.560]  чтобы люди сначала видели, что ваш класс предоставляет, какие методы, а только потом,
[02:11:27.560 --> 02:11:32.640]  как он устроен. Кто-то наоборот предпочитает сначала писать private, чтобы сначала было видно,
[02:11:32.640 --> 02:11:40.000]  что вы храните, а потом, что вы умеете делать. Я никакой из этих способов строго не предпочитаю.
[02:11:40.000 --> 02:11:44.440]  В кодстайле у нас не будет запрета писать не так, не так, не знаю. Как удобнее в каждом конкретном
[02:11:44.440 --> 02:11:55.120]  случае, сами решайте. Вот. Ну или там на review будем обсуждать. А если вы не написали ни private,
[02:11:55.120 --> 02:11:59.960]  ни public, то какой модификатор доступа применяется по умолчанию? И вот тут ответ на вопрос,
[02:11:59.960 --> 02:12:05.200]  почему я пишу struct вместо class. Дело в том, что класс от структуры как раз с темой отличается,
[02:12:05.200 --> 02:12:09.040]  что у класса все по умолчанию private, а у структуры public. И это единственная чем
[02:12:09.040 --> 02:12:16.200]  он отличается от структуры C++. Вот. Значит, если бы я написал просто class, а не struct,
[02:12:16.200 --> 02:12:20.960]  то у меня бы все не компилировалось со словами все private, доступ запрещен. Вот. Но поскольку
[02:12:20.960 --> 02:12:26.760]  я пишу структуру, то там все по умолчанию public. Вот. Я отныне буду писать class вместо
[02:12:26.760 --> 02:12:36.080]  struct, если буду что-то нетривиальное делать, но буду уточнять public. Вот. Ну такое соглашение,
[02:12:36.080 --> 02:12:41.880]  что если вы хотите писать какие-то простые вещи, ну то есть вы не хотите писать, реализовать какую-то
[02:12:41.880 --> 02:12:46.640]  сложную логику, то используйте слово struct. Если у вас там методы, ну если вы действительно там в
[02:12:46.640 --> 02:12:51.920]  основном поля хотите напрямую к ним обращаться извне, а если у вас со сложной логикой какой-то
[02:12:51.920 --> 02:12:55.920]  тип, который там сложные методы, который хочет инкапсулировать приватные какие-то поля, то лучше
[02:12:55.920 --> 02:13:01.080]  пишите class. Ну такое вот общее соглашение, когда class писать, когда struct, в основном разницы нет.
[02:13:01.080 --> 02:13:14.280]  Ну вот. Если я сейчас попытаюсь из main обратиться к polux, то будет ошибка компиляции со словами
[02:13:14.280 --> 02:13:23.560]  нарушения прав доступа. И с private within this context. И это другая ошибка компиляции,
[02:13:23.560 --> 02:13:29.600]  принципиальная другая по сравнению с тем, что мы встречали раньше, потому что это ошибка уже не
[02:13:29.600 --> 02:13:38.440]  уровня, не видно имя или неоднозначный вызов, а уровня все видно, все понятно, что вы просите, но вам запрещено.
[02:13:38.440 --> 02:13:50.320]  Вот. Ну я могу точно также методы делать с приватными и публичными. Кстати, да.
[02:13:50.320 --> 02:14:00.800]  Ну, разумеется, сколько byte в памяти занимает S? 16.
[02:14:00.800 --> 02:14:15.720]  Значит, не менять, обращаться к ним нельзя. Это запрещенное слово для вас. Значит,
[02:14:15.720 --> 02:14:23.120]  какую правильную интуицию нужно держать про модификаторы доступа? Что означает слово private?
[02:14:23.120 --> 02:14:29.360]  Слово private означает, что из вне структуры вам запрещено произносить это слово. И больше ничего.
[02:14:29.360 --> 02:14:36.800]  Нельзя говорить с.x. Нельзя. Если вы говорите с.x, бан. Compile time error. Вы называете поле, которое
[02:14:36.800 --> 02:14:44.440]  не имеете права называть. Из области, из класс скопа своего, ты, конечно, можешь обращаться к
[02:14:44.440 --> 02:14:50.480]  чему угодно. Если я реализую здесь какой-то метод, то я запросто могу обращаться отсюда
[02:14:50.480 --> 02:14:56.920]  к приватному полю. Если я нахожусь в класс скопе, то я запросто обращаюсь к своим полям. Более того,
[02:14:56.920 --> 02:15:05.920]  если я этот метод реализую извне, то я тоже запросто обращаюсь к полям. То есть даже если я
[02:15:05.920 --> 02:15:11.440]  реализую, ну не буду показывать, если я определяю этот метод вне класса, я все равно имею доступ к
[02:15:11.440 --> 02:15:16.840]  своим полям. Потому что это мои поля, я реализую метод класса, конечно, он имеет доступ к полям.
[02:15:16.840 --> 02:15:24.840]  Из метода класса я могу обращаться к полям этого класса. Этот метод публичный сейчас,
[02:15:24.840 --> 02:15:32.160]  потому что он под паблик. Где он объявлен, такой и он. Он публичный сейчас.
[02:15:32.160 --> 02:15:46.800]  Потому что мне нужно, чтобы класс был выровнен, чтобы он лежал по адресу кратному 8. Чтобы дабл всегда
[02:15:46.800 --> 02:15:53.240]  лежал по адресу кратному 8. Потому что процессор считывает машинными словами, если дабл будет
[02:15:53.240 --> 02:15:57.400]  лежать не по адресу кратному 8, то процессору, чтобы считать этот дабл, потребуется больше
[02:15:57.400 --> 02:16:08.960]  инструкций. Он бы догнал до кратного 8, потому что иначе этот дабл бы в следующем с подряд лежал
[02:16:08.960 --> 02:16:20.880]  бы не в адресе кратном 8. Если после дабла я объявлю еще ind, то размер станет 24. Потому что
[02:16:20.880 --> 02:16:25.440]  если я эти структуры буду хранить в массиве, мне надо, чтобы все даблы по-прежнему лежали по
[02:16:25.440 --> 02:16:35.800]  адресам кратным 8. Нет, если я не догоню до 24, то следующий с не будет лежать по адресу кратному 8.
[02:16:35.800 --> 02:16:53.160]  Какие у нас в целом правила по названию классов, полей классов, методов?
[02:16:53.160 --> 02:17:00.240]  Ну давайте лучше я скину код style и там это будет написано. Я не хочу сейчас про это говорить,
[02:17:00.240 --> 02:17:06.920]  тратить время. Давайте лучше я что-нибудь содержательное скажу. Так, вот смотрите,
[02:17:06.920 --> 02:17:15.960]  у меня есть метод, он публичный. Да, если метод приватный. Давайте, кстати,
[02:17:15.960 --> 02:17:32.760]  не знаю, один просто буду здесь выводить. Могу ли я приватный метод определить вне класса?
[02:17:32.760 --> 02:17:39.000]  Конечно, могу. Определить метод вне класса, это пожалуйста. Обращаться к методу вне класса,
[02:17:39.000 --> 02:17:53.320]  к приватному нельзя. Какая должна быть правильная интуиция? Ну я же сказал, вы просто не можете
[02:17:53.320 --> 02:17:58.560]  называть как бы вслух это название. Ну за исключением ситуации, что вы его определили,
[02:17:58.560 --> 02:18:02.960]  определение этого метода написать, пожалуйста, вы можете вне класса. То, что он private public,
[02:18:03.320 --> 02:18:11.080]  вот обратиться к нему откуда-то вне класса нельзя. Именно назвать его по названию нельзя. При этом,
[02:18:11.080 --> 02:18:16.080]  если вы каким-то хитрым способом получите указательный этот метод и через этот указатель
[02:18:16.080 --> 02:18:29.040]  сумеете его вызвать, это пожалуйста. Но назвать этот метод по названию нельзя. Да. Что у вас память?
[02:18:32.960 --> 02:18:45.440]  Я не понимаю, что значит в память будут переменные. Слова private и public никак не влияют на
[02:18:45.440 --> 02:18:55.360]  размещение класса в памяти. Так, понятно? Никак не влияют на то, кто будет первым. Вот кого вы
[02:18:55.360 --> 02:18:59.720]  первым объявили, тот и будет первым лежать в памяти. Что там private, кто public, это никак не
[02:18:59.720 --> 02:19:07.120]  влияет на размещение класса в памяти. Кто раньше объявлен, это совершенно не связанные вещи.
[02:19:07.120 --> 02:19:23.240]  Вот теперь следующий вопрос на понимание. Вот смотрите, у меня есть voidf от int. Вот смотрите,
[02:19:23.240 --> 02:19:30.560]  у меня есть структура, и в ней есть метод от int и метод от double. Один публичный, другой
[02:19:30.560 --> 02:19:39.480]  приватный. И я пишу s.f от нуля. Что будет?
[02:19:39.480 --> 02:20:07.440]  Значит, в вашей версии что будет? Ce или вызов метода от double? Кто считает, что вызов метода от double?
[02:20:07.440 --> 02:20:22.040]  Все вы все неправы, да. Будет ce. И это логично. Нет, это логично. Это просто так решил комитет
[02:20:22.040 --> 02:20:28.400]  фантастеризации, но это логично. И если вы вдумаетесь, вы поймете, что именно так и должно быть. Иначе
[02:20:28.400 --> 02:20:34.720]  было бы очень неудобно. Что означает, что вы объявили какой-то метод private? Это означает,
[02:20:34.720 --> 02:20:41.680]  что вы хотите запретить людям вызывать f с такими параметрами извне класса. Если кто-то пытается
[02:20:41.680 --> 02:20:50.400]  вызвать f от int, компилятор должен ему сказать, что нельзя. Смысл запрета в том, чтобы как раз не
[02:20:50.400 --> 02:20:57.480]  дать человеку сделать то, что нельзя делать. Если бы этот запрет работал так, что ну хорошо,
[02:20:57.480 --> 02:21:03.280]  ты случайно ошибся, ну давай мы тебя это подстрахуем, тут другой метод есть. Ты, наверное,
[02:21:03.280 --> 02:21:10.920]  на его имел в виду. Нет, типа так не должно работать. Смысл слова private в том, что если кто-то
[02:21:10.920 --> 02:21:23.080]  пытается извне сделать это, он должен получить ошибку. Значит, правило следующее. Сначала выбирается
[02:21:23.080 --> 02:21:28.000]  подходящая версия, потом делается проверка доступа. Сначала разрешение перегрузки, потом
[02:21:28.000 --> 02:21:34.800]  проверка доступа. Вот такой принцип. Проверка доступа делается после того, как стало понятно,
[02:21:34.800 --> 02:21:47.120]  кто, да, если бы она делалась до, то какой уровень доступа у методов это не влияет на то,
[02:21:47.120 --> 02:21:51.560]  какой метод выбирается при разрешении перегрузки. Разрешение перегрузки выполняется до того,
[02:21:51.560 --> 02:21:57.000]  как компилятор проверяет, а имеете ли вы право. Сначала компилятор пытается понять,
[02:21:57.000 --> 02:22:02.880]  какой это вызов, вызов какого метода вы пытаетесь сделать, потом только компилятор проверяет,
[02:22:02.880 --> 02:22:17.680]  а имеете ли вы право его вызывать. Вот здесь я объясняю, потому что когда написано private,
[02:22:17.680 --> 02:22:25.240]  это означает, что вы хотите запретить этот метод, чтобы вы хотите разрешить метод от double,
[02:22:25.240 --> 02:22:33.120]  но запретить от int. Когда вы пишете private что-то от чего-то, вы хотите тем самым себя обезопасить,
[02:22:33.120 --> 02:22:42.920]  чтобы человек извне, пытаясь вызвать с такими параметрами, получил бы ошибку. Когда вы пишете
[02:22:42.920 --> 02:22:47.680]  private, это же все делается ради удобства самого себя. Вы пытаетесь…
[02:22:47.680 --> 02:22:58.160]  Да, именно. Если бы он вместо этого получал вызов не той функции,
[02:22:58.160 --> 02:23:03.440]  которую он уже дал, это вряд ли то, что он хотел. Он пишет f от int, а ему говорят,
[02:23:03.440 --> 02:23:08.400]  ты, наверное, ошибся, потому что f от int запрещено вызывать. Ты либо не ту версию вызвал,
[02:23:08.400 --> 02:23:16.880]  либо ты неправильная, логика действия у тебя неправильная. Вот. Когда… Как это все связано
[02:23:16.880 --> 02:23:23.080]  с перегрузкой? В перегрузке, как вы помните, первая стадия — это выбор кандидатов, потом отбор
[02:23:23.080 --> 02:23:30.440]  самого лучшего из кандидатов, но только после этого делается отсе в подоступу. Вот здесь есть
[02:23:30.440 --> 02:23:40.520]  важное понятие, два важных понятия — видимость и доступность, visibility и accessibility. Видимость
[02:23:40.520 --> 02:23:46.240]  функции и доступность функции — это разные понятия, их надо различать. Функция вам, может быть,
[02:23:46.240 --> 02:23:53.720]  не видна, но доступна, а может быть, недоступна, но видна. Вот сейчас функция f от int мне видна,
[02:23:53.720 --> 02:23:59.800]  но недоступна. Видна — это значит, что она попадает в кандидаты на перегрузку и участвует в конкурсе,
[02:23:59.800 --> 02:24:07.240]  кто лучший кандидат. Но когда выбирается лучший кандидат, мне говорят нельзя, мне этого кандидата
[02:24:07.240 --> 02:24:14.240]  не положено. То есть доступность — это следующая стадия после того, как решается видимость и
[02:24:14.240 --> 02:24:20.640]  выбирается из видимых кандидатов. Видимость — это концепция предыдущего уровня, когда решается,
[02:24:20.640 --> 02:24:27.520]  из каких namespace, какая f взята и что там нужно из них по include, вот это все видимость. Из них
[02:24:27.520 --> 02:24:32.360]  выбираются кандидаты, оттуда выбирается лучший кандидат. Когда он выбран, проверяется доступность,
[02:24:32.360 --> 02:24:39.440]  и это уже другой термин. Вот. Короче, сначала видимость, сначала разрешение перегрузки,
[02:24:39.440 --> 02:24:49.240]  потом проверка доступа. Вот. Ну и это не были бы плюсы, если бы не существовало способа обойти.
[02:24:49.240 --> 02:24:59.680]  Приватность. Что-что? Что такое offset-off? Я такого не знаю.
[02:24:59.680 --> 02:25:04.040]  Так, нет, define я не хочу слышать.
[02:25:04.040 --> 02:25:19.160]  Ты не можешь называть приватные поля из-вне клавиши.
[02:25:19.640 --> 02:25:23.640]  Если это приводит к тому, что тебе приходится из-вне класса обратиться к приватному полю,
[02:25:23.640 --> 02:25:30.640]  значит ты CE схватываешь. Назвать имя приватного поля из-вне ты не можешь.
[02:25:30.640 --> 02:25:37.080]  Так, последнее, что я скажу в этом параграфе, видимо это последнее, что я скажу сегодня,
[02:25:37.080 --> 02:25:51.960]  это как обойти приватность. Есть слово, как и в случае с константностью, как и в случае с
[02:25:51.960 --> 02:26:03.160]  ринтерпретом, то есть существует слово такое, такая мигалка, да, с звуковым сигналом,
[02:26:03.240 --> 02:26:08.120]  позволяет обойти правила, если очень хочется. Что за слово позволяет приватность обойти?
[02:26:08.120 --> 02:26:22.880]  Friend. Есть такое замечательное слово friend. Значит вы можете иногда, то есть у вас поля
[02:26:22.880 --> 02:26:30.680]  приватные, публичные там функции, но вы можете некоторым функциям разрешить нарушать правила
[02:26:30.680 --> 02:26:38.960]  доступа. Скажем так, добавить их в список исключений. Я могу сказать, например, что вот у меня
[02:26:38.960 --> 02:26:47.560]  есть здесь функция, вот допустим у меня есть функция G какая-то, и я в ней хочу вывести X.
[02:26:47.560 --> 02:26:53.880]  Сейчас это будет конечно ошибка компиляции, да, ну сейчас будет две ошибки компиляции,
[02:26:53.880 --> 02:27:03.680]  потому что f от int приватная и x приватная. Но я могу в классе S написать, что вот эти поля
[02:27:03.680 --> 02:27:08.680]  приватные, но некоторым функциям все-таки можно, несмотря на то, что приватные, к ним обращаться.
[02:27:08.680 --> 02:27:17.360]  Такие функции называются друзьями. Друзья класса – это функции, которым разрешен доступ к приватной
[02:27:17.360 --> 02:27:24.520]  части, несмотря на то, что они не члены класса. Да, разрешить только к каким-то отдельным приватным
[02:27:24.520 --> 02:27:30.400]  полям нельзя, можно только ко всем сразу. Вот я могу написать, причем неважно в какой именно части
[02:27:30.400 --> 02:27:40.400]  класса я это напишу, хоть в паблик, хоть в private, я пишу следующее. Friend – это ключевое слово,
[02:27:40.600 --> 02:27:54.920]  и дальше сигнатура функции. Friend void g. Тем самым я объявил функцию g другом для класса S. Теперь
[02:27:54.920 --> 02:28:02.760]  из функции g обращаться к приватным полям можно, но из main по-прежнему нельзя. Если бы я написал
[02:28:02.760 --> 02:28:16.080]  friend int main, то из main было бы можно, а из g нельзя. Конечно, я могу написать friend int main,
[02:28:16.080 --> 02:28:26.560]  friend void g, я могу несколько друзей. Friend неважно где написать, главное, что внутри S. Вот,
[02:28:26.560 --> 02:28:32.760]  но внутри S нужно написать friend. Далее, я могу делать друзьями целые классы, то есть я могу
[02:28:32.760 --> 02:28:38.840]  для класса S объявить другом целый другой класс. Для этого я могу написать friend class ss,
[02:28:38.840 --> 02:28:43.680]  например. Ну, если у меня есть еще один какой-то класс, я могу написать friend class или struct ss.
[02:28:43.680 --> 02:28:54.760]  Это означает, что всем методам класса ss разрешен доступ к приватной части класса S. Вот.
[02:28:54.760 --> 02:29:03.040]  Если я объявил ss другом класса S, это еще не значит, что есть теперь друг ss. Граф не
[02:29:03.040 --> 02:29:11.740]  ориентированный. Ой, наоборот, ориентированный, то есть и нетранзитивный еще. То есть отношение
[02:29:11.740 --> 02:29:29.700]  дружбы, оно несимметрично и нетранзитивно. Ну да. Ну это понятно, то есть явно нужно
[02:29:29.700 --> 02:29:36.020]  прописывать. Если вы хотите, чтобы s был другом ss, то нужно это в классе ss прописать. Вообще,
[02:29:36.020 --> 02:29:41.940]  слово friend не рекомендуется по кодстайлу использовать. И это плохой кодстайл, если у вас много где
[02:29:41.940 --> 02:29:47.420]  использовано слово friend. Вот. У вас в домашних задачах, вот когда вы будете реализовывать string,
[02:29:47.420 --> 02:29:54.260]  например, у вас будет искушение написать friend много где. Но это ошибка. Я вам сразу говорю,
[02:29:54.260 --> 02:29:59.060]  спойлер. В задачи string friend слово не нужно использовать ни разу. Вот если вы напишите friend,
[02:29:59.060 --> 02:30:05.820]  то значит вы не пройдете код review, оно там не нужно. Вот. В следующих задачах вам иногда будет
[02:30:05.820 --> 02:30:12.900]  нужно слово friend, но изредка. Вот. Писать слово friend много раз, это значит, что у вас плохая
[02:30:12.900 --> 02:30:19.980]  организация кода. Если вы, если вам много раз приходится писать friend, это значит,
[02:30:19.980 --> 02:30:24.540]  что вы плохо спроектировали класс. Ну потому что friend это слово, как бы это обход правил,
[02:30:24.540 --> 02:30:29.900]  по сути. То есть это слово на экстренный случай. Если вам нужно почему-то нарушить правила вот в
[02:30:29.900 --> 02:30:37.580]  этот конкретный раз. Это как с const-cast. Типа const-cast применять нужно очень редко на случай,
[02:30:37.580 --> 02:30:42.220]  если почему-то вам в экстренной ситуации надо нарушить правила. То же самое friend. Если вам
[02:30:42.220 --> 02:30:47.380]  нужно нарушить правила по какой-то причине экстренной. Вот почему-то вот здесь вот тот самый случай,
[02:30:47.380 --> 02:30:57.260]  когда нужно. Тогда надо переменять friend. Но вообще писать friend часто не стоит. Много друзей это плохо.
[02:30:57.260 --> 02:31:07.580]  Вот. Приватные поля нужны для того, чтобы реализовывать инкапсуляцию. Ну что значит
[02:31:07.580 --> 02:31:15.620]  реализовывать инкапсуляцию? Чтобы ваш код был понятен для внешнего пользователя. Чтобы в вашем коде,
[02:31:15.620 --> 02:31:21.620]  в ваших классах было понятно, какая часть является внутренней реализацией, а какая часть является
[02:31:21.620 --> 02:31:27.700]  методами для внешнего юзера. Почему стиральная машинка или микроволновка закрывается крышкой
[02:31:27.700 --> 02:31:35.860]  обычно? Почему вы как бы не видите все механизмы, почему механизмы не торчат наружу? Ну потому что
[02:31:35.860 --> 02:31:42.900]  вам считается небезопасно в них тыкать. Вы если будете тыкать в приватные методы или поля извне,
[02:31:42.900 --> 02:31:49.540]  вы что-нибудь случайно сломаете. Вот. Публичной делается та логика вот с понятным действием,
[02:31:49.540 --> 02:31:54.140]  которая предназначена для внешнего использования. А внутренние поля, ну например у вектора
[02:31:54.140 --> 02:31:59.340]  внутренний массив, он приватный, потому что извне тыкать в него лучше не стоит. Вы что-нибудь сломаете,
[02:31:59.340 --> 02:32:05.500]  нарушите внутреннюю логику какую-нибудь. Вот. Приватные поля нужны, чтобы обезопасить вас от вас самих.
[02:32:05.500 --> 02:32:30.100]  Ну вот так, например. А вот я только что это сделал. Смотрите, я сейчас взял адрес S,
[02:32:30.100 --> 02:32:46.620]  который был... Смотрите, я сейчас взял... Ну вот S это объект типа S. Я взял адрес S,
[02:32:46.620 --> 02:32:59.540]  скастовал его к ин звездочки и разыминовал. Что я получу? Единицу. Вот сейчас я получу
[02:32:59.540 --> 02:33:15.140]  единицу. Потому что я таким образом получил доступ к приватному полю. Я же объяснил вам,
[02:33:15.140 --> 02:33:18.500]  что значит приватность. Это значит, что вы не имеете права к ним обращаться,
[02:33:18.500 --> 02:33:24.140]  называть их вы не можете. Но компилятор, конечно, не в состоянии проверить, что вы случайно разыминовываете
[02:33:24.140 --> 02:33:27.860]  указатель, под которым лежит приватное поле. Приватность и публичность — это концепция,
[02:33:27.860 --> 02:33:32.140]  существующая исключительно в компайл тайме. Если я за интерпрет кастил, то, разумеется,
[02:33:32.140 --> 02:33:37.700]  я спокойно могу получить доступ к приватному полю. И запросто я могу сделать вот так,
[02:33:37.700 --> 02:33:48.460]  без всякого разыминования. Ну, то же самое будет. Только здесь я адреса, мне нужно само S. Я скастовал
[02:33:48.460 --> 02:33:56.860]  S к ссылке на int. И тем самым получил, ну, я начал трактовать биты S, как будто там int. Но оно
[02:33:56.860 --> 02:34:04.940]  действительно начинается с int. И поэтому я и получил int, с которого оно начинается. Вот.
[02:34:04.940 --> 02:34:17.620]  Ну, я могу, например, сделать так. Я могу сказать double, double звездочка, адрес S,
[02:34:17.620 --> 02:34:34.460]  плюс один, и это разыминовать. И таким образом я получу 3.14. Понятно? Потому что я же знаю,
[02:34:34.460 --> 02:34:39.420]  что в структуре S сначала лежит int, потом 4 байта пропущено, потом лежит double. Поэтому,
[02:34:39.420 --> 02:34:46.420]  если я приведу указатель на S к double звездочке, топором просто, кувал, бульдозером, ну, на самом
[02:34:46.420 --> 02:34:51.260]  деле, интерпрет кастом, сестайл каст, который работает как интерпрет каст в данном случае,
[02:34:51.260 --> 02:34:57.820]  я получаю указатель на S, как будто это указатель на double. Я сдвигаю его на 8 байт вправо и получаю
[02:34:57.820 --> 02:35:06.140]  реально указатель на вот этот double. И разыминовый под ним действительно оказывается double. Ну и,
[02:35:06.140 --> 02:35:12.980]  конечно же, если здесь было написано private, это бы ничего не спасло. Я бы тоже самое... Ну,
[02:35:12.980 --> 02:35:25.060]  какая разница? Да, кстати, кстати, кстати. Смотрите. Допустим, здесь написано const double. А я сейчас вот так
[02:35:25.060 --> 02:35:40.620]  сделаю? Ну, я возьму и заменю. Скомпилируется или нет? Скомпилируется, потому что константность уже
[02:35:40.620 --> 02:35:47.020]  потерялась. Ну как? Да, вот эта константность сейчас ничего не спасет, потому что, и даже хоть она
[02:35:47.020 --> 02:35:54.820]  приватная, это ничего не спасет, потому что я взял адрес структуры, получил неконстантный указатель
[02:35:54.820 --> 02:36:01.820]  на S, трактовал указатель на double, сдвинул на 8, получил неконстантный... Ну, это УБ, конечно,
[02:36:01.820 --> 02:36:08.420]  но по факту я сейчас изменю поле, там будет ноль лежать. Ну, можно проверить, что там ноль лежит.
[02:36:08.420 --> 02:36:17.420]  Ну все, на сегодня хватит. Там ничего не вывел, потому что ничего не вывел.
[02:36:17.420 --> 02:36:38.660]  Что? А, ну да. Так он в начале, почему, его видно.
[02:36:38.660 --> 02:36:51.460]  Не видно, что он вообще не вывел. Так, ну ладно. Что мы только что делали, это же УБ? Конечно.
[02:36:51.460 --> 02:37:12.500]  Санитайзеры. Ну да, да, да. Вот сейчас Федя вам про санитайзеры расскажет. А как к следующему?
[02:37:12.500 --> 02:37:31.220]  Ай, нет, ничего не ловит, смотрите. Все, пара закончена. Санитайзеры не помогут.
