[00:00.000 --> 00:11.280]  Добрый день, давайте начнем. Следующий пункт нашей программы — это наследование.
[00:11.280 --> 00:18.040]  Наследование — это одна из трех-четырех концепций объектно-оритерированного
[00:18.040 --> 00:21.040]  программирования, с которым мы с вами начали знакомиться в прошлом семестре.
[00:21.040 --> 00:24.760]  Напомню, что объектно-оритерированное программирование — это подход
[00:24.760 --> 00:27.760]  программирования, в котором мы, соответственно, логику нашей программы
[00:27.760 --> 00:32.760]  выделяем в отдельные классы, структуры, объекты, их взаимодействия между собой.
[00:32.760 --> 00:36.760]  И мы с вами поговорили о том, что существуют четыре основные концепции
[00:36.760 --> 00:40.760]  объектно-оритерированного программирования — это абстракция, инкапсуляция, полиморфизм
[00:40.760 --> 00:45.760]  и наследование. То есть первые три вещи мы с вами так или иначе поговорили.
[00:45.760 --> 00:48.760]  В некотором смысле мы к ним еще вернемся.
[00:48.760 --> 00:54.760]  Сегодня и на следующих занятиях погрузимся в то, что такое наследование,
[00:54.760 --> 00:58.760]  как эта штука позволяет нам писать, что она позволяет нам сделать,
[00:58.760 --> 01:01.760]  как она упрощает написание кода и так далее.
[01:01.760 --> 01:04.760]  В общем-то, суть наследования довольно-таки проста.
[01:04.760 --> 01:07.760]  Извучается она в том, что вы написали какие-то свои собственные классы,
[01:07.760 --> 01:12.760]  какие-то свои собственные типы, и вполне себе возможно, что в процессе проектирования ваших программ
[01:12.760 --> 01:16.760]  у вас возникла необходимость написать класс с похожим функционалом.
[01:16.760 --> 01:18.760]  Что значит с похожим функционалом?
[01:18.760 --> 01:23.760]  Либо его функционал полностью или частично совпадает с тем классом, который вы уже когда-либо писали.
[01:23.760 --> 01:26.760]  Например, интерфейс класса, который вы пишете,
[01:26.760 --> 01:30.760]  совпадает с интерфейсом того класса, который вы уже когда-либо написали.
[01:30.760 --> 01:35.760]  Например, у нас есть класс стека и есть класс очереди.
[01:35.760 --> 01:39.760]  Понятно дело, что стек позволяет нам добавить элемент в конец, удалить элемент с конца.
[01:39.760 --> 01:41.760]  Очередь позволяет сделать то же самое.
[01:41.760 --> 01:43.760]  По сути, в некотором смысле можно считать, что очередь это стек,
[01:43.760 --> 01:45.760]  но просто с каким-то дополнительным функционалом,
[01:45.760 --> 01:48.760]  в частности с возможностью удалить элемент из начала.
[01:49.760 --> 01:51.760]  Ну и собственно так.
[01:51.760 --> 01:54.760]  Оно следовательно является одним из основных понятий, на которых держится ООП.
[01:54.760 --> 01:55.760]  Другой пример.
[01:55.760 --> 01:59.760]  Представьте, что вы проектируете какую-то игру, какую-то программу,
[01:59.760 --> 02:01.760]  в которой у нас есть набор персонажей.
[02:01.760 --> 02:07.760]  В данном примере есть набор персонажей, типа лучник и есть там боец ближнего боя.
[02:07.760 --> 02:10.760]  У них есть общие характеристики.
[02:10.760 --> 02:13.760]  У всех игровых персонажей есть какие-то общие характеристики.
[02:13.760 --> 02:17.760]  Например, у них есть показатели здоровья, показатели силы, показатели опыта и так далее.
[02:17.760 --> 02:20.760]  И в целом, как бы, все персонажи участ are отличают только тем,
[02:20.760 --> 02:23.760]  какие действия, точнее, какие специфичные действия они могут делать.
[02:23.760 --> 02:26.760]  Например, каждый персонаж может выполнять действия, например, лечение.
[02:26.760 --> 02:28.760]  То есть, в какое-то время он там может подождать
[02:28.760 --> 02:33.760]  и вылечить, восстановить свои чки с дороги.
[02:33.760 --> 02:36.760]  Либо же он может, например, вступить в ближний бой.
[02:36.760 --> 02:39.760]  Или если мы говорим о лучнике, он может вступить в дальний бой.
[02:39.760 --> 02:42.760]  То есть, например, боец ближнего боя в дальний бой вступить не может,
[02:42.760 --> 02:44.760]  лучник не может вступить в ближний бой.
[02:44.760 --> 02:53.760]  Вот, соответственно, у них есть какие-то общие черты, и при этом есть какие-то отличия, которые делают, грубо говоря, одного персонажа, именно персонажа этого типа.
[02:53.760 --> 03:06.760]  И, соответственно, я думаю, вы понимаете, что если мы пишем какую-то большую программу, допустим, если останемся в том же сеттинге игры, то, понятное дело, в процессе возникнет необходимость вводить новых персонажей.
[03:06.760 --> 03:13.760]  Либо как-то развивать игру, вводить новых персонажей, или как-то персонажей этих развивать, в общем, добавлять какой-то новый функционал, и так далее.
[03:13.760 --> 03:21.760]  И я думаю, вы понимаете, что довольно-таки накладно для каждого нового вводимого персонажа прописывать всю ту же самую логику, что вы прописывали для предыдущих персонажей.
[03:21.760 --> 03:30.760]  Потому что, как я уже сказал, у нас, в принципе, программа может развиваться, то есть наша вымышленная игра, она может как-то развиваться, то есть мы можем хотеть добавлять какие-то общие черты для всех персонажей,
[03:30.760 --> 03:36.760]  можем уметь добавлять, можем захотеть добавить какие-то новые характеристики для персонажей.
[03:36.760 --> 03:43.760]  И каждый раз, когда вы будете добавлять нового персонажа, вам нужно им держать в голове то, что вот у вас у всех персонажей есть такой набор характеристик,
[03:43.760 --> 03:49.760]  плюс у каждого персонажа должны быть реализованы вот такие вот свойства, и, соответственно, этот персонаж отличается как-то другими штуками.
[03:49.760 --> 03:54.760]  И если вы хотите ввести какой-то новый акционал, вам придется во всех классах этот функционал внести.
[03:54.760 --> 03:57.760]  Ну, в общем, проблема. Первая проблема.
[03:57.760 --> 04:08.760]  Вторая проблема, на самом деле, еще заключается в том, что, вообще говоря, если мы посмотрим на такой вот мымышленный код, то есть у нас есть 4 класса, Арчер, Мили, Кавалерия, Импостер и так далее.
[04:08.760 --> 04:14.760]  Вот с точки зрения кода на C++ все эти классы никак не взаимосвязаны друг с другом.
[04:14.760 --> 04:18.760]  Грубо говоря, вот у вас есть Лучник, у вас есть Кавалерия.
[04:19.760 --> 04:23.760]  И, собственно, как минимум вы не можете их хранить в одном массиве.
[04:23.760 --> 04:30.760]  Вообще говоря, это логично. Если вдруг игрок хочет создать свою армию, он, соответственно, добавляет Лучников, Кавалерию и так далее.
[04:30.760 --> 04:33.760]  И вполне себе логично это все хранить в одном массиве.
[04:33.760 --> 04:37.760]  Но в C++ мы знаем, что в массиве может храниться только элементы одного типа.
[04:37.760 --> 04:39.760]  А это все 4 разных типа.
[04:39.760 --> 04:44.760]  То есть с логической точки зрения мы с вами понимаем, что, в принципе, они реализуют один тот же концепт.
[04:44.760 --> 04:47.760]  Они реализуют одну и ту же сущность, как игровой персонаж.
[04:47.760 --> 04:51.760]  Но при этом они имеют разные типы, поэтому мы не можем их хранить даже в одном контейнере.
[04:51.760 --> 04:52.760]  Беда.
[04:52.760 --> 04:54.760]  И в этом нам тоже поможет Наследование.
[04:54.760 --> 04:56.760]  Давайте обсудим как.
[04:56.760 --> 05:00.760]  Смотрите, как я уже сказал, Наследование это свойство системы, свойство языка программирования,
[05:00.760 --> 05:03.760]  которое позволяет создавать новые типы на основе существующих.
[05:03.760 --> 05:06.760]  Значит, решение с помощью Наследования заключается в следующем.
[05:06.760 --> 05:11.760]  Давайте я заведу специальный класс, такой общий класс, который назову класс-персонаж.
[05:11.760 --> 05:13.760]  Вот класс Hero.
[05:13.760 --> 05:17.760]  И вот в этот класс персонажа заведу все общие свойства, все общие характеристики,
[05:17.760 --> 05:20.760]  которыми обладают все персонажи в моей игре.
[05:20.760 --> 05:26.760]  Например, подсказатели силы, здоровье, опыта вынесу в структуру этого персонажа,
[05:26.760 --> 05:31.760]  плюс какие-то общие методы, какие-то общие свойства, какие-то общие действия, которые могут делать эти персонажи,
[05:31.760 --> 05:34.760]  тоже вынесу в этот класс.
[05:34.760 --> 05:36.760]  Этот класс как-то реализую.
[05:36.760 --> 05:40.760]  А дальше, собственно, уже понимая, что у меня есть некоторый общий концепт персонажа,
[05:40.760 --> 05:44.760]  я возьму и всех конкретных персонажей, там лучник, кавалерия, ближний бой и так далее,
[05:44.760 --> 05:47.760]  унаследую от этого общего класса персонажа.
[05:47.760 --> 05:51.760]  В частности, возьму класс Archer, унаследую его от Hero.
[05:51.760 --> 05:53.760]  Просим, если мы чуть подробнее потом поговорим.
[05:53.760 --> 05:56.760]  Но, в общем, чтобы унаследовать один класс от другого, мы просто ставим двоеточие
[05:56.760 --> 05:58.760]  и после этого пишем имя класса.
[05:58.760 --> 06:00.760]  То есть строк Archer, двоеточие, Hero.
[06:00.760 --> 06:03.760]  Ну, что означает Public, мы через 5 минут поговорим.
[06:03.760 --> 06:06.760]  А что означает Наследование?
[06:06.760 --> 06:09.760]  Наследование, собственно, говорит то, что все те свойства,
[06:09.760 --> 06:12.760]  которые обладает клад, который написан справа от двоеточия,
[06:12.760 --> 06:15.760]  все те же самые свойства должны быть и у моего класса тоже.
[06:15.760 --> 06:19.760]  И уже понимая это, держа это в голове, я просто-напросто внутри класса Archer
[06:19.760 --> 06:22.760]  прописываю дополнительные свойства, дополнительные характеристики,
[06:22.760 --> 06:24.760]  которым обладает мой новый класс.
[06:24.760 --> 06:25.760]  Окей?
[06:25.760 --> 06:27.760]  То есть, по сути, что я тут говорю?
[06:27.760 --> 06:30.760]  Я говорю, что лучник полностью обладает чёртовым персонажем
[06:30.760 --> 06:32.760]  и плюс кое-чем ещё.
[06:32.760 --> 06:35.760]  И вот это вот кое-что ещё я прописываю внутри фигурных скобок.
[06:35.760 --> 06:36.760]  Окей?
[06:36.760 --> 06:41.760]  И вот в этом контексте говорит следующее, что Hero, то есть, персонаж – это базовый класс,
[06:41.760 --> 06:44.760]  Archer – это производный класс, или класс Наследник.
[06:44.760 --> 06:46.760]  То есть, получается такая вот и рамка.
[06:46.760 --> 06:49.760]  Есть базовые классы, а эти производные, это не классы, то есть, класс Наследники.
[06:49.760 --> 06:52.760]  Более того, эта связь уже видна языку C++,
[06:52.760 --> 06:58.760]  и язык C++ может уже на этой основе делать какие-то выводы.
[06:58.760 --> 07:01.760]  То есть, если раньше я написал класс лучника,
[07:01.760 --> 07:03.760]  написал класс персонажа ближнего боя,
[07:03.760 --> 07:06.760]  и, соответственно, с точки зрения C+, то есть, это были два разных класса,
[07:06.760 --> 07:10.760]  то теперь, зная, например, о том, что лучник и боец ближнего боя
[07:10.760 --> 07:12.760]  наследны от того класса персонаж,
[07:12.760 --> 07:16.760]  компилятор может позволять делать какие-то вещи, которые присущи обоям этим типам.
[07:16.760 --> 07:20.760]  Ну, в частности, например, мы сможем создать массив,
[07:20.760 --> 07:23.760]  в котором можно сохранить объекты обоих этих типов.
[07:23.760 --> 07:26.760]  Но об этом мы ещё поговорим позже.
[07:26.760 --> 07:29.760]  В целом, концепция понятна. В целом, для чего это нужно?
[07:29.760 --> 07:31.760]  Окей.
[07:31.760 --> 07:33.760]  Хорошо.
[07:35.760 --> 07:38.760]  Да, ну, собственно, я на предыдущем слайде беру пример,
[07:38.760 --> 07:40.760]  как выглядит синтез наследования.
[07:40.760 --> 07:42.760]  Ну и, собственно, вот, как это работает.
[07:42.760 --> 07:44.760]  То есть, теперь я могу создать объект типа персонаж,
[07:44.760 --> 07:47.760]  объект типа лучника, и, соответственно, и у персонажа, и у лучника
[07:47.760 --> 07:50.760]  будет такая характеристь, как HP, то есть, здоровье,
[07:50.760 --> 07:52.760]  будут такие же методы, как heal.
[07:52.760 --> 07:54.760]  Но при этом у лучника будет дополнительный метод shoot,
[07:54.760 --> 07:58.760]  то есть, будет метод выстрелить, которого нет у персонажа.
[07:58.760 --> 08:01.760]  У лучника это полностью, ну, является полной копией персонажа,
[08:01.760 --> 08:04.760]  то есть, полностью совпадает по свойствам с персонажем,
[08:04.760 --> 08:06.760]  и плюс ещё обладает какими-то дополнительными методами.
[08:06.760 --> 08:08.760]  Ну, в частности, вот, обладает методом shoot,
[08:08.760 --> 08:10.760]  которым обычный персонаж не обладает.
[08:10.760 --> 08:12.760]  Окей?
[08:13.760 --> 08:14.760]  Так.
[08:14.760 --> 08:16.760]  Теперь давайте поговорим про вот эти вот самые,
[08:16.760 --> 08:19.760]  про вот это вот самое слово public, которое пишется после двоеточия,
[08:19.760 --> 08:23.760]  вообще говоря, как ведут себя модификаторы доступа при наследовании.
[08:23.760 --> 08:25.760]  Значит, смотрите, ну, мы с вами в прошлом семестре
[08:25.760 --> 08:28.760]  говорили про два модификатора доступа.
[08:28.760 --> 08:30.760]  Это public и private, да, то есть, с ними всё просто.
[08:30.760 --> 08:33.760]  Public – это секция, которая позволяет, ну, вообще,
[08:33.760 --> 08:36.760]  всем, всему коду в нашей программе обращаться к этим полям методам.
[08:36.760 --> 08:39.760]  Private секция разрешает обращаться к этим полям методам
[08:39.760 --> 08:41.760]  только, ну, собственно, изнутри самого класса, да,
[08:41.760 --> 08:44.760]  то есть, только объектам этого класса, только, в общем, да,
[08:44.760 --> 08:46.760]  только самому этому классу, ну, и плюс друзьям этого класса.
[08:46.760 --> 08:48.760]  В случае наследования всё остаётся то же самое.
[08:48.760 --> 08:51.760]  Вот. Если внутри класса написан private,
[08:51.760 --> 08:53.760]  то никому, кроме этого класса,
[08:53.760 --> 08:55.760]  обращаться к этим полям и методам нельзя.
[08:55.760 --> 08:58.760]  Если public, то всем подряд можно обращаться к этим полям и методам.
[08:58.760 --> 09:01.760]  Вот. Ну и, соответственно, то же самое распространяется
[09:01.760 --> 09:05.760]  и на нас... кстати, вот это вот разграничение касается наследников.
[09:05.760 --> 09:07.760]  То есть, если у меня, смотрите, есть класс archer,
[09:07.760 --> 09:10.760]  ну, структура archer, и она унаследована от hero,
[09:10.760 --> 09:13.760]  то это означает, что archer не будет иметь доступ
[09:13.760 --> 09:15.760]  к приватной секции hero.
[09:15.760 --> 09:17.760]  Ну, вот пример. Вот у меня есть структура hero,
[09:17.760 --> 09:19.760]  которая обладает публичным методом heal
[09:19.760 --> 09:21.760]  и приватным методом updateHP.
[09:21.760 --> 09:25.760]  Вот. И есть archer, который реализует метод rest.
[09:25.760 --> 09:28.760]  Вот к методу heal archer обращаться может.
[09:28.760 --> 09:31.760]  А вот к методу updateHP archer обращаться не может.
[09:31.760 --> 09:33.760]  То есть, возникает тут довольно странная ситуация,
[09:33.760 --> 09:36.760]  ну, с одной стороны странная, в общем,
[09:36.760 --> 09:38.760]  заключается она в следующем, что
[09:38.760 --> 09:42.760]  внутри класса archer есть метод updateHP.
[09:42.760 --> 09:45.760]  Но самому archer этот метод недоступен.
[09:45.760 --> 09:49.760]  Вот. То есть, метод updateHP может вызывать только hero.
[09:49.760 --> 09:52.760]  Но при этом сам archer вызывать updateHP не может.
[09:52.760 --> 09:54.760]  Окей? То есть, private на самом деле распространяется
[09:54.760 --> 09:56.760]  и на наследников тоже.
[09:56.760 --> 09:58.760]  То есть, если в моем классе, например, вот в классе hero
[09:58.760 --> 10:00.760]  есть приватный метод updateHP,
[10:00.760 --> 10:03.760]  то его наследники к этому методу тоже не будут иметь доступ.
[10:03.760 --> 10:05.760]  Понятно?
[10:05.760 --> 10:07.760]  То есть, private – это прям вот жесткое закрытие.
[10:07.760 --> 10:10.760]  То есть, вот к этому методу могут обращаться только объекты этого класса.
[10:10.760 --> 10:12.760]  Наследники обращаться не могут.
[10:12.760 --> 10:14.760]  Пример понятен?
[10:14.760 --> 10:16.760]  Окей.
[10:16.760 --> 10:20.760]  Ну, собственно, вот.
[10:20.760 --> 10:24.760]  Теперь в контексте наследования у слов private и public
[10:24.760 --> 10:26.760]  появляется еще один дополнительный смысл.
[10:26.760 --> 10:30.760]  Значит, private и public могут обучать не только модификатор доступа,
[10:30.760 --> 10:32.760]  но и режим наследования.
[10:32.760 --> 10:34.760]  Вот. Что такое режим наследования?
[10:34.760 --> 10:37.760]  Значит, режим наследования пишется как раз таки вот после…
[10:37.760 --> 10:39.760]  как раз таки после двоеточия, да, то есть
[10:39.760 --> 10:41.760]  структ archer – public hero.
[10:41.760 --> 10:43.760]  Что означает слово public перемещено сюда,
[10:43.760 --> 10:45.760]  или что означает слово private?
[10:45.760 --> 10:47.760]  Что означает слово private помещенное туда?
[10:47.760 --> 10:49.760]  Смотрите.
[10:49.760 --> 10:51.760]  Private и public наследования отличаются тем,
[10:51.760 --> 10:53.760]  знает ли внешний код,
[10:53.760 --> 10:55.760]  о том, унаследован класс или нет.
[10:55.760 --> 10:57.760]  Смотрите.
[10:57.760 --> 10:59.760]  То есть, на самом деле, эта аналогия довольно-таки прямая
[10:59.760 --> 11:01.760]  с модификаторами доступа.
[11:01.760 --> 11:03.760]  То есть, про private и public мы с вами говорили так,
[11:03.760 --> 11:05.760]  что если что-то помещено в секцию private,
[11:05.760 --> 11:07.760]  то, по сути, никто, никакой внешний код,
[11:07.760 --> 11:09.760]  не имеет права знать о том, что там находится.
[11:09.760 --> 11:11.760]  Ну, что там находится какой-то метод, что там находится какой-то поле и так далее.
[11:11.760 --> 11:13.760]  Если там есть модификатор доступа public,
[11:13.760 --> 11:15.760]  то, соответственно, все имеют право знать,
[11:15.760 --> 11:17.760]  что у меня там есть такой метод,
[11:17.760 --> 11:19.760]  и все имеют право к нему обращаться.
[11:19.760 --> 11:21.760]  Вот с наследованием, по сути, то же самое.
[11:21.760 --> 11:23.760]  Вот если я пишу archer.publichero,
[11:23.760 --> 11:25.760]  это означает, что весь внешний код
[11:25.760 --> 11:27.760]  знает о том,
[11:27.760 --> 11:29.760]  что archer унаследован от hero.
[11:29.760 --> 11:31.760]  А если весь внешний код знает о том,
[11:31.760 --> 11:33.760]  что archer унаследован от hero,
[11:33.760 --> 11:35.760]  и может использовать эту информацию,
[11:35.760 --> 11:37.760]  то это значит, что весь внешний код
[11:37.760 --> 11:39.760]  имеет право обращаться
[11:39.760 --> 11:41.760]  к полям и методам hero
[11:41.760 --> 11:43.760]  через объекты archer.
[11:43.760 --> 11:45.760]  Вот у меня есть стул.
[11:45.760 --> 11:47.760]  Я говорю, что он там унаследован
[11:47.760 --> 11:49.760]  от концепции мебель.
[11:49.760 --> 11:51.760]  Если я знаю, что стул унаследован
[11:51.760 --> 11:53.760]  от концепции мебель, то, соответственно,
[11:53.760 --> 11:55.760]  я могу использовать эту информацию.
[11:55.760 --> 11:57.760]  Например, я могу понять, что раз это мебель,
[11:57.760 --> 11:59.760]  я могу пойти в мебельную магазину
[11:59.760 --> 12:01.760]  и купить стул там.
[12:01.760 --> 12:03.760]  Если бы стул реализовывал приватное наследование,
[12:03.760 --> 12:05.760]  то стул бы являлся мебелью,
[12:05.760 --> 12:07.760]  но при этом я бы об этом не знал.
[12:07.760 --> 12:09.760]  Тогда бы я не имел права
[12:09.760 --> 12:11.760]  пойти в мебельную магазину и купить стул.
[12:11.760 --> 12:13.760]  Странный пример.
[12:13.760 --> 12:15.760]  Вот история.
[12:15.760 --> 12:17.760]  Приватное наследование
[12:17.760 --> 12:19.760]  то, что этот класс действительно
[12:19.760 --> 12:21.760]  унаследован от другого класса,
[12:21.760 --> 12:23.760]  но при этом никто другой,
[12:23.760 --> 12:25.760]  никакой внешний код не имеет права
[12:25.760 --> 12:27.760]  использовать эту информацию.
[12:27.760 --> 12:29.760]  Приватное наследование
[12:29.760 --> 12:31.760]  это наследование, при котором
[12:31.760 --> 12:33.760]  я унаследую только для своих внутренних нужд,
[12:33.760 --> 12:35.760]  а любой внешний код не имеет права
[12:35.760 --> 12:44.880]  право использовать информацию о том, что я от кого-то унаследован, окей? Да, да, это вот
[12:44.880 --> 12:48.800]  вообще другая вещь, да, то есть даже если у hero есть какие-то приватные поля, даже
[12:48.800 --> 12:53.320]  несмотря на то, что написано паблик, archer не сможет использовать приватные поля hero, то есть если
[12:53.320 --> 12:57.800]  что-то стало приватным, то это приватное останется навсегда. Открыть уровень доступа нельзя будет.
[12:57.800 --> 13:06.920]  Давайте посмотрим на конкретные примеры. Вот у меня есть класс A, публичное поле x, и есть
[13:06.920 --> 13:13.360]  приватный метод f. Есть структура B, которая публичным образом унаследована от A, вот,
[13:13.360 --> 13:19.400]  и в ней есть метод h. И давайте посмотрим на этот метод h, что в нем происходит. В нем я x
[13:19.400 --> 13:24.800]  предстояю значение 0 и вызываю метод f. Вопрос, какие из этих строчек я смогу вызвать? Смогу ли
[13:24.800 --> 13:34.200]  я сделать x равной 0? Почему? Ну, тут, кажется, все просто, потому что поле x является публичным,
[13:34.200 --> 13:42.040]  я к нему обратиться могу. Да, окей, здорово. А могу ли я вызвать метод f? Почему? У меня же публичное
[13:42.040 --> 13:54.160]  наследование. Да, смотрите, что тут мы делаем? Во-первых, мы должны проверить две вещи. Во-первых,
[13:54.160 --> 14:00.760]  есть ли метод f в структуре B? Ответ да, нет. Можно ли обратиться к тому, к той или иной
[14:00.760 --> 14:10.560]  вещи? Мы задаем два вопроса. Первый вопрос, вообще говоря, этот метод или поле есть в моем классе или
[14:10.560 --> 14:19.480]  нет? Вот для f ответ положительный или отрицательный? Есть ли метод f в моей структуре B? И ответ да,
[14:19.480 --> 14:24.360]  есть. Почему? Потому что B унаследовано от A, не важно каким образом. То есть факт состоит в том,
[14:24.360 --> 14:28.160]  что B унаследовано от A. Если B унаследовано от A, значит в B есть все те же самые свойства,
[14:28.160 --> 14:33.320]  что и в A. Вот, и действительно в классе B есть метод f. А теперь другой вопрос. Имеет ли
[14:33.320 --> 14:40.120]  право класс B обращаться к своему методу f? И ответ нет. Да, почему? Потому что f пришел в класс B
[14:40.120 --> 14:47.880]  через класс A, а класс A запретил использовать свой метод f. Вот, поэтому метод f вызвать будет нельзя.
[14:47.880 --> 14:59.640]  То есть он как бы есть, но к нему доступа нет. Окей, другой пример. Та же самая структура C,
[14:59.640 --> 15:04.920]  ну в смысле по виду, значит у нее тоже есть метод h, у нее тоже x равнули f, но при этом
[15:04.920 --> 15:09.520]  унаследование приватное. Изменится ли что-то в этом контексте внутри структуры C или нет?
[15:09.520 --> 15:22.360]  Так, да, нет. Нет, почему нет? Да, потому что вот это вот слово, вот это слово влияет только на внешний
[15:22.360 --> 15:28.520]  код. Смотрите, структура C же знает, что она сама унаследована от A. Но раз она знает, что она унаследована
[15:28.520 --> 15:34.000]  от A, значит она может спокойно обращаться и к x, и к f. Единственное, тут все окей, потому что x
[15:34.000 --> 15:39.720]  не является публичным, то есть класс A разрешает пользоваться x всем, ну кто может это делать,
[15:39.720 --> 15:44.960]  а к методу f обратиться нельзя, потому что A запретил использовать f вообще кому бы то ни было,
[15:44.960 --> 15:54.880]  кроме себя. Вот, модификатор наследования, который пишется после D, он на самом деле влияет только
[15:54.880 --> 15:59.400]  на внешний код. То есть на код внутри структуры B и структуры C он никак не влияет. То есть если
[15:59.400 --> 16:04.720]  класс унаследовал какой-то другой класс, то он может спокойно обращаться ко всем публичным полям
[16:04.720 --> 16:12.120]  того класса. Вот. Окей, ну смотрите, тут два вопроса. Первый вопрос, типа внешний код,
[16:12.120 --> 16:15.720]  он действительно, ну то есть можем ли мы считать, что внешний код это видит, и второй вопрос, какая будет
[16:15.720 --> 16:20.840]  ошибка. Ну вообще, с точки зрения программирования, лучше считать, что приватность означает, что мы не имеем
[16:20.840 --> 16:26.560]  права знать об этом. То есть это как бы, не знаю, вашего класса могут быть приватные поля, и если вы
[16:26.560 --> 16:30.120]  что-то поместили в приватную секцию, скорее всего, вы имели в виду, что это какая-то деталь реализации,
[16:30.120 --> 16:35.760]  которую знать не стоит. Которую можно не знать. Вот тоже самое, кстати, приватная реализация. Это означает, что вот это какая-то
[16:35.760 --> 16:40.600]  деталь реализации, и вот внешнему коду об этом знать не нужно, об этом знать не обязательно. Вот. Другой вопрос,
[16:40.600 --> 16:44.960]  что ошибка компиляции, скорее всего, будет осмысленная. То есть ошибка компиляции, скорее всего, она не скажет вам,
[16:44.960 --> 16:49.800]  что такого метода нет, или такого поля нет. Ошибка компиляции покажет, что просто нет доступа. Ну то же
[16:49.800 --> 16:57.920]  самое, как если бы вы обращались к приватному полю и к приватному методу. Вот. Окей. Теперь давайте
[16:57.920 --> 17:02.600]  посмотрим, ну представим себе, что вот у меня есть какая-то функция main, вот. И внутри функции main
[17:02.600 --> 17:10.640]  написан следующий код. Я создаю объект a, и обращаюсь к полю x и к полю f. Вопрос, получится мне это сделать или нет?
[17:10.640 --> 17:22.640]  A.x. Получится обратиться? Да, ну a.x всё получится. Почему? Потому что x это публичное поле структуры a. А к методу f?
[17:22.640 --> 17:28.000]  Нет. Ну тут всё просто, тут вообще никого наследования нет, потому что есть класс a, и у него есть просто
[17:28.000 --> 17:35.360]  публичное поле x, и есть собственный приватный метод f, к которому обращаться нельзя. Окей. Ну я думаю, тут
[17:35.360 --> 17:40.240]  сразу везде понятно, что к методу f, не тут, не тут, обратиться будет нельзя, потому что f является приватным,
[17:40.240 --> 17:47.560]  а f-тость никак не снимается, к сожалению. Вот. Теперь давайте посмотрим на объект класса b, и объект класса c,
[17:47.560 --> 17:56.080]  обращение к x. Вот b.x равно 11, скомпилируется это или нет? Да, смотрите, почему? Потому что мы проверяем,
[17:56.080 --> 18:02.400]  есть ли в классе b поле x. Ответ да, почему? Потому что оно пришло из класса a. Теперь проверяем,
[18:02.400 --> 18:08.040]  можно ли к x обратиться, ну можно ли обратиться к x. Смотрите, b унаследовано от a публично, это значит,
[18:08.040 --> 18:13.040]  что b всем рассказывает, что он наследован от a. Вот я там являюсь наследником a, и все здорово. Вот.
[18:13.040 --> 18:17.800]  Поэтому, когда я обращаюсь к b.x, компилятор говорит, ну окей там, мы имеем право знать о том,
[18:17.800 --> 18:23.480]  что мы унаследованы от a, и при этом x является публичным полем, поэтому к x мы тоже можем обратиться.
[18:23.480 --> 18:32.200]  Вот. А в случае c.x? c.x нет, да, почему? Потому что, несмотря на то, что x содержится, действительно,
[18:32.200 --> 18:38.040]  в классе c действительно x содержится, но при этом класс a, точнее класс c, наследует класс a
[18:38.040 --> 18:42.000]  приватно. То есть, тут он не сообщает всем, что он наследник, он как бы такой бастар,
[18:42.000 --> 18:46.480]  говорит, вот я лучше скрою о том, что я от кого-то унаследован. То есть, внешний код не имеет
[18:46.480 --> 18:51.560]  права об этом знать. Ну и тут компилятор ровно это нам сообщит. То есть, как бы скажет, ну как бы да,
[18:51.560 --> 18:57.000]  в классе c есть x, но вообще ты не должен был об этом знать, потому что x пришел из класса a,
[18:57.000 --> 19:02.280]  который унаследован приватно. Вот. То есть, как бы к полям и методам своего базового класса ты
[19:02.280 --> 19:10.760]  не имеешь права обращаться. Ну, точнее, внешний код не имеет права обращаться. Окей? Есть еще вопросы? Да.
[19:10.760 --> 19:31.400]  Ну, в некотором смысле, да. Мы не можем в класс наследник добавить поле, который... Нет, почему? Нет,
[19:31.400 --> 19:37.760]  в класс наследник можно добавить все что угодно, и поля, и методы. Вот. Там не совсем все так просто,
[19:37.760 --> 19:46.040]  то есть там, в общем, мы до этого дойдем. Ну, короче говоря, если у вас есть класс a, и класс b у наследован от a,
[19:46.040 --> 19:51.680]  то вы не можете создать, короче, то вы можете создать массив из объектов класса a. И туда
[19:51.680 --> 19:56.800]  можете помещать как объект класса a, так и класса b. Вот. То есть, грубо говоря, вы урезаете все доны
[19:56.800 --> 20:13.560]  меньшего класса. Ну, мы до этого дойдем еще. Да. Вот. В общем, да, нам будет на слайдах, но по умолчанию,
[20:13.560 --> 20:18.640]  если не писать через двоеточки никакого слова, то по умолчанию, для структуры public, для классов
[20:18.640 --> 20:29.480]  private. Ну, ровно такое же отличие, как и для модификаторов доступа. Окей. Значит, наследование
[20:29.480 --> 20:35.120]  обводит еще один модификатор доступа, ну, еще один уровень наследования, это protected. В прошлом
[20:35.120 --> 20:39.200]  семестре мы на самом деле так с курсом упоминали, и в прошлом семестре я говорил, что protected это
[20:39.200 --> 20:42.720]  на самом деле то же самое, что и private. И вообще говоря, если мы не знаем про наследование, то это
[20:42.720 --> 20:47.320]  действительно так и есть. Protected работает точно так же, как и private. Вот. Единственное отличие
[20:47.320 --> 20:54.200]  protected от private заключается в том, что protected дополнительно разрешает получать доступ к полям и
[20:54.200 --> 21:01.360]  методам для наследников. Вот. То есть, если private запрещает вообще всем, то protected запрещает
[21:01.360 --> 21:08.320]  внешнему коду, но разрешает наследникам. Окей. То есть, protected работает public, как public для
[21:08.320 --> 21:13.760]  наследников, но при этом как private для внешнего кода, то есть, для ненаследников. Окей. Ну, то есть,
[21:14.720 --> 21:20.360]  какой тут пример? Вот есть структура A, в которой есть protected поле X и protected поле F. Я структуру B
[21:20.360 --> 21:26.920]  наследую от A, и при этом B имеет право обращаться к полям X и F. Почему? Потому что X и F являются
[21:26.920 --> 21:33.920]  protected полями A. Вот. И так как B наследует от A, то A разрешает B использовать свои поля X и F. Вот.
[21:33.920 --> 21:38.960]  Но при этом внешний код к X и F не имеет права обращаться. То есть, если я пишу A.X или A.F
[21:38.960 --> 21:46.600]  во внешнем коде, ну, тут третья строчка снизу, то это не скомпилируется. И плюс последняя строчка B.X
[21:46.600 --> 21:51.680]  и B.F тоже не скомпилируется. Да, почему? Потому что protected, еще раз повторю, protected разрешает
[21:51.680 --> 21:58.240]  обращаться к полям и методам только наследникам. Внешнему коду по-прежнему запрещено. Окей. То есть,
[21:58.240 --> 22:05.040]  к X и F я могу обратиться только изнутри A или только изнутри наследника A, то есть B. Понятно?
[22:05.040 --> 22:14.480]  Из main я добраться до X и F никак не смогу. Вот. Ну и модификатор доступа, ну, точнее,
[22:14.480 --> 22:20.160]  модификатор наследования protected также может быть написан и после двоеточия при указании типа
[22:20.160 --> 22:24.960]  наследования. Вот. И означает это, ну, по сути, то же самое, что модификатор доступа. То есть об этом
[22:24.960 --> 22:31.080]  наследовании, о том, что B наследует от A, имеет право знать только, ну, сам класс B и все наследники
[22:31.080 --> 22:36.840]  класса B. Вот. То есть, внешний код не имеет права знать о том, что B как-то унаследован от A,
[22:36.840 --> 22:41.760]  но если кто-то унаследуется от B, то тот имеет право использовать информацию о том, что B унаследован
[22:41.760 --> 22:46.760]  от A. Ну, вот, например, у меня есть класс A, у меня есть класс B, который protected образом унаследован
[22:46.760 --> 22:52.000]  от A, и есть структура C, которая унаследована от B. При этом C имеет право обращаться к X и F.
[22:52.000 --> 22:56.280]  Почему? Потому что A, потому что B является наследником A, то есть в B содержится все те
[22:56.280 --> 23:00.680]  же самые поля, что и в A. Потом C унаследовано от B, то есть в C содержится все те же поля,
[23:00.680 --> 23:06.280]  что и B. Вот. То есть поле X и метод F в структуре C содержится. И при этом я могу к нему обращаться,
[23:06.280 --> 23:12.200]  почему? Потому что B protected образом унаследованно от A, то есть C знает о том, что B унаследовано от A.
[23:12.200 --> 23:17.480]  А раз C знает о том, ну, грубо говоря, знает о том, что B унаследовано от A, он может спокойно к
[23:17.480 --> 23:23.280]  нему обращаться. Вот. Но при этом с внешнего кода, вот, если возьму последнюю строчку, да, создам
[23:23.280 --> 23:29.760]  объект B и обращусь к B.X и B.F, то тут будет ошибка эмпиляции. Почему? Потому что B protected
[23:29.760 --> 23:33.840]  образом унаследовано от A, а раз он protected образом унаследовано от A, то значит, что внешний код
[23:33.840 --> 23:44.920]  не имеет права знать о том, что B унаследовано от A. Понятно? Ну и давайте еще посмотрим, например,
[23:44.920 --> 23:50.800]  вот у меня есть структура A, в нем есть публичное поле X, есть приватный метод F, есть protected
[23:50.800 --> 23:57.680]  метод G. Вот. У меня есть структура B, которая protected образом унаследовано от A. Вот, есть X равный нулю, F и G.
[23:57.680 --> 24:05.200]  Каким из этих трех строчек я могу обратиться? То есть какие из этих трех строчек не приведут к ошибке эмпиляции?
[24:05.200 --> 24:18.400]  Так, ну, X, с X все будет нормально, да, почему? Потому что B унаследовано от A, и при этом X являются публичным
[24:18.400 --> 24:24.560]  полем. Окей, к F я могу обратиться? Нет, F приватный, к F вообще никогда нельзя обращаться. Вот вообще
[24:24.560 --> 24:31.440]  никогда. То есть тут сразу везде, где F поставить минус. Вот. А могу ли я внутри B обратиться к G? Да,
[24:31.440 --> 24:36.080]  потому что, во-первых, B знает о том, что унаследовано от A, так как B унаследуется от A, естественно,
[24:36.080 --> 24:42.240]  знает кто его предок. Плюс сама структура A разрешила своим наследником обращаться к G,
[24:42.240 --> 24:48.320]  да, потому что это protected, поэтому к G обращаться внутри наследников можно. Окей, так, теперь на
[24:48.320 --> 24:53.200]  правую сторону, допустим, снова у нас есть какая-то функция main, и я обращаюсь A.G. Могу я это сделать или нет?
[24:53.200 --> 25:00.160]  Нет, для внешнего кода protected работает как private, да, поэтому к G обратиться я не могу. Дальше,
[25:00.160 --> 25:10.920]  ну, B.X, а, да, могу ли обратиться B.X? Почему нет? Да, потому что B protected образом наследования,
[25:10.920 --> 25:16.840]  да, protected наследования означает, что никто, кроме моих наследников, не имеет права знать о том, что я унаследован
[25:16.840 --> 25:21.280]  от A. Функция main, естественно, не является наследником B, поэтому, вообще говоря, мы не имеем права
[25:21.280 --> 25:25.400]  использовать информацию о том, что мы как-то унаследованы от A, поэтому к X мы обратиться не
[25:25.400 --> 25:30.560]  можем. К G, естественно, по тем же самым причинам мы тоже обратиться не можем. Вот. Можем либо обратиться к
[25:30.560 --> 25:36.840]  A.X? Да, A является непосредственным методом B, да, он находится в его публичной области, поэтому к A.X
[25:36.840 --> 25:46.400]  мы можем спокойно обратиться. Вот. Теперь то же самое для A.C. Могу ли обратиться C.X? Нет, да,
[25:46.400 --> 25:51.640]  C.X обратиться не можем, почему? Потому что, ну, смотрите, мы проверяем, да, где находится X? Ну, в самом
[25:51.640 --> 25:56.720]  C.X нет. Поднимаемся выше, то есть можем ли я подняться выше? Да, то есть C всем сообщает о том, что у наследован
[25:56.720 --> 26:01.880]  от B, поэтому можно подняться в B. Смотрим в B. Есть непосредственно в B поле X? Нет, поле X в B нет.
[26:01.880 --> 26:05.720]  Можем подняться у наследника, но у наследника подняться не можем, почему? Потому что B запретил
[26:05.720 --> 26:14.240]  внешнему коду знать о том, что наследован от A, поэтому как бы внутри класса C поле X нет, ну, в смысле,
[26:14.240 --> 26:22.160]  для внешнего кода поле X не существует. Вот. Ну, по аналогичным причинам нет C.G, а C.H? Да, ну,
[26:22.160 --> 26:27.360]  снова продолжаем логику, да, внутри структуры C метода H нет, поднимаемся в наследника, это сделать
[26:27.360 --> 26:31.360]  мы можем, потому что наследование публичное, вот. Ну и, собственно, в структуре B мы как раз находим
[26:31.360 --> 26:44.520]  нужный метод H, поэтому тут все окей. Так, есть ли вопросы? Да. Ну, нет, с друзьями все,
[26:44.520 --> 26:48.240]  ну, с друзьями все остается так же, да, то есть, если какой-то класс объявляет какую-то функцию
[26:48.240 --> 26:52.520]  с твоим другом, то эта функция теперь получает полный доступ, там, ко всем приватным,
[26:52.520 --> 27:05.080]  protected полям. Вот, смотрите, да, хороший вопрос. Смотрите, допустим, у нас структура A сказала
[27:05.080 --> 27:18.160]  следующее, что у меня int main это друг. Вот если структура A объявляет, если структура A объявляет
[27:18.160 --> 27:23.920]  функцию своим другом, то это значит, что структура A разрешает обращаться к своим private и protected
[27:23.920 --> 27:31.840]  полям. Но, но, при этом все вот это по-прежнему останется ошибкой компиляции. Почему? Потому что
[27:31.840 --> 27:37.800]  несмотря на то, что A разрешает доступ к своим полям и методам, B запрещает знать о том, что кто-то
[27:37.800 --> 27:44.320]  у него односледован. Ну, то есть, ну, не знаю, представьте себе, что, не знаю, вот у вас есть родители,
[27:44.320 --> 27:48.400]  если они такие очень гостеприимные, они там приглашают, они хотят пригласить всех ваших друзей,
[27:48.400 --> 27:52.400]  но вы своим друзьям не рассказываете, что, вот, как бы, где вы живете, где находятся ваши родители. Вот,
[27:52.400 --> 27:57.320]  поэтому, естественно, ваши друзья не могут там прийти к вам в дом. Ну, такая вот аналогия. Вот, то есть,
[27:57.320 --> 28:04.320]  тут проблема именно в B, да, то есть, когда я обращаюсь в B.X, как бы, нет, давайте тут, я обращаюсь, вот,
[28:04.320 --> 28:12.400]  я обращаюсь в B.F, обращаюсь в B.F, и, как бы, класс A, он как бы рад, ну, как бы рад, он вызвать метод F, да,
[28:12.400 --> 28:17.400]  потому что Main его друг, но B сказал нет, я, как бы, протектор образом наследуюсь от A, то есть,
[28:17.400 --> 28:22.840]  я сам, вот, сам B, никому не расскажу о том, что я наследовал от A, кроме своих наследников, вот, и,
[28:22.840 --> 28:28.600]  поэтому, B, Main не рассказывает о том, что наследовал от A, поэтому, к доступу к функции F и функции G
[28:28.600 --> 28:48.480]  я не получу. Понятно? Да. Нет, давайте тут, правильно я понял вопрос, что, вот,
[28:48.480 --> 29:00.480]  допустим, у меня есть структура A, структура A, у меня есть какой-то, допустим, приватное поле, да, private index, и вот у меня есть
[29:00.480 --> 29:14.160]  структура, которая наследована от A, и она объявляет там кого-то своим другом, friend, допустим, avoid F, и вот у меня есть
[29:14.160 --> 29:30.960]  это вот самое avoid F, я создаю B и обращаюсь в B.exe. Вот это вопрос. Ну, давайте подумаем, кто считает, что тут будет ошибка
[29:30.960 --> 29:39.720]  компиляции? Смотрите, B в структуре B объявила функцию F своим другом, то есть, как бы, B говорит, что я могу, что я позволяю всем
[29:40.320 --> 29:47.080]  обращаться к моим приватным полям, методам и так далее. Вот, например, внутри структуры A, X приватен. Могу ли я тут с помощью B
[29:47.080 --> 29:59.960]  обратиться к exe? Кто считает, что можем? Кто считает, что не можем? Поздравляю, вы победили. Да, обратиться тут мы не можем. Почему?
[29:59.960 --> 30:08.520]  Складить это было бы довольно странно, если бы, ну, как его назвать, не знаю, какой-то сопляк наследник разрешал бы
[30:08.520 --> 30:16.840]  обращаться к приватным полям своего предка. Ну, как бы, структура A говорит, нет, нельзя к exe обращаться, а структура B такая
[30:16.840 --> 30:22.840]  приходит, наследник тогда говорит, да нет, можно, всем можно. Ну, так же не должно работать. То есть, как бы, сама структура A
[30:22.840 --> 30:29.640]  запретила X. Если сама структура A запретила обратиться к exe, то как бы сама структура A должна разрешать им пользоваться.
[30:29.640 --> 30:34.920]  То есть, как бы, не может прийти B и сказать, что нет, на самом деле всем там можно пользоваться. Вот. То есть, вот это вот слово
[30:34.920 --> 30:41.320]  friend относится только к тому, что в структуре B. То есть, если бы B объявил какие-то поля, то тогда бы мог обратиться.
[30:41.320 --> 30:48.360]  Или если я тут написал там слово private, то тогда бы friend f знал бы о том, что я унаследован от A. Вот. Но при этом на доступ
[30:48.360 --> 30:54.040]  на доступы в наследниках это никак не распространяется. Понятно? Да.
[30:54.040 --> 31:08.920]  То же самое. Потому что X является полем, который находится в структуре A. И структура A говорит, что я разрешаю пользоваться только
[31:08.920 --> 31:27.880]  к наследникам, но не внешнему коду. Вот. Да, friend влияет и на protect private. Вот. То есть, friend влияет только на сущности, которые объявлены
[31:27.880 --> 31:35.000]  внутри самой структуры. Вот. То есть, если где-то внутри этой структуры написано private and protected, то к этому с помощью friend
[31:35.080 --> 31:40.120]  можно получить доступ. Если где-то в наследнике написано private and protected, то, к сожалению, вот это friend никак на это не повлияет.
[31:40.120 --> 31:55.880]  То есть, сама структура должна позволять или не позволять обращаться к полям или методам. Окей? Идем дальше. Хорошо. Да.
[31:55.880 --> 32:16.600]  Какие три функции? Сейчас. Какая стройка смущает? Вот эта? Нет, ну тут все окей. Почему? Потому что, смотрите, у меня есть B. Я вызываю B.h.
[32:16.600 --> 32:24.520]  Если у меня в структуре B функция h, метод h. Да, он есть. Я могу к нему спокойно обратиться. Или вас смущает то, что внутри h вызывается x, f?
[32:25.160 --> 32:32.120]  Нет, в этом-то никакой проблемы нет. То есть, как бы, метод же может обращаться к приватным полям своего класса, и это же нормально.
[32:35.720 --> 32:45.080]  То есть, суть в том, что я не могу непосредственно обратиться к x, f и h. Но при этом сами методы класса, естественно, не могут обращаться к ним. Вот. То есть, тут проблемы нет.
[32:45.080 --> 33:02.680]  Так. Что? А, ну тут, не, ну в смысле, да. Да, имеется в виду, что с x нет никакой проблемы. Нормально? Хорошо.
[33:03.560 --> 33:12.920]  Ну, если коротко, да. То паблик, в общем… то режим наследования паблик говорит о том, что все имеют право использовать информацию о том, что мой класс унаследован у кого-то другого.
[33:14.920 --> 33:22.040]  Вот. P comunacle режим наследования говорит о том, что никто не имеет права использовать информацию о том, что я как-то от кого-то унаследован. То есть, если я с помощью внешнего кода, или с помощью своего наследника,
[33:22.120 --> 33:30.520]  пытаюсь как-то использовать поля-еплименты, которые находятся в моем предке, то будет ошибка в компиляции. Вот.
[33:30.520 --> 33:34.520]  Протектор действует точно так же, как и private, но только за исключением наследников.
[33:34.520 --> 33:40.520]  То есть, если кто-то унаследовался от моего класса, то, соответственно, я этому наследнику позволяю пользоваться своими полями и методами.
[33:40.520 --> 33:42.520]  Окей?
[33:42.520 --> 33:44.520]  Хорошо.
[33:46.520 --> 33:50.520]  Вот. Ну и на самом деле такое небольшое замечание.
[33:50.520 --> 33:56.520]  Вообще говоря, таким чистым наследованием, как правило, называют наследование именно с помощью public.
[33:56.520 --> 34:02.520]  Потому что, как правило, когда мы делаем какое-то наследование, мы хотим этим что-то сказать.
[34:02.520 --> 34:06.520]  Мы хотим сказать, что вот эти вот классы как-то связаны каким-то функционалом.
[34:06.520 --> 34:10.520]  То есть, например, там, где можно поставить A, туда же можно поставить B. Почему?
[34:10.520 --> 34:12.520]  Потому что B обладает этими же свойствами и характеристиками.
[34:12.520 --> 34:18.520]  В этом смысле private и protected наследование используются, к вашему счастью, наверное, гораздо реже.
[34:18.520 --> 34:23.520]  И в большинстве ситуаций private и protected наследование можно просто-напросто заменить на A-композицию.
[34:23.520 --> 34:29.520]  То есть, смотрите, вот если у меня есть структура B, и я приватным образом наследуюсь от A,
[34:29.520 --> 34:38.520]  то в целом примерно то же самое может добиться, если я просто-напросто в структуру помещу в приватную секцию поле, которое будет иметь тип A.
[34:38.520 --> 34:40.520]  Согласны?
[34:40.520 --> 34:45.520]  Вот структура B будет иметь все те же самые поля и методы, что и A в случае структуры B.
[34:45.520 --> 34:49.520]  Ну и плюс структура C тоже будет иметь все те же самые поля и методы, что и A.
[34:49.520 --> 34:55.520]  Но при этом мы к ним сможем обращаться через имя A.
[34:55.520 --> 35:01.520]  И во втором, то есть и в случае структуры B, и в случае структуры C, у меня в классе появляются поля и методы A.
[35:01.520 --> 35:11.520]  Но только в третьем случае я получаю к ним доступ через имя A, а во втором случае получаю к ним доступ непосредственно, как если бы это были мои собственные типы.
[35:11.520 --> 35:16.520]  В этом смысле реализация с помощью B и C, они эквалютны за некоторым исключением.
[35:16.520 --> 35:21.520]  И одно из исключений это такая оптимизация компилятора, которая называется empty-base-optimization.
[35:21.520 --> 35:23.520]  В чем она заключается?
[35:23.520 --> 35:25.520]  Включается она в следующем.
[35:25.520 --> 35:32.520]  Вообще говоря, в C++ любой тип данных, точнее объект любой тип данных, обязан занимать в памяти как минимум один байт.
[35:32.520 --> 35:39.520]  Ну это просто связано с тем, что стандарт C++ гарантирует, что если у вас есть два разных объекта, то они обязаны лежать в разных местах памяти.
[35:39.520 --> 35:45.520]  Поэтому если вы заведете в пустую структуру, например структуру A, она будет занимать один байт.
[35:45.520 --> 35:50.520]  Кстати, вот еще одно замечание про наследование, что если у вас есть какая-то структура,
[35:50.520 --> 35:56.520]  допустим структура A, в ней есть поля x, y, z, пусть интовые.
[35:56.520 --> 36:09.520]  И вы как-то берете структуру B, наследуетесь от A, ну и пусть тут еще есть int A.
[36:09.520 --> 36:13.520]  Вот, то в памяти структура B будет выглядеть примерно так.
[36:13.520 --> 36:18.520]  Сначала будет идти часть, которая относится к A, а потом часть, которая относится к B.
[36:18.520 --> 36:20.520]  То есть вот как-то так.
[36:20.520 --> 36:24.520]  x, y, z.
[36:24.520 --> 36:26.520]  Вот.
[36:26.520 --> 36:29.520]  Так, а в чем заключается empty-base optimization?
[36:29.520 --> 36:31.520]  Значит, empty-base optimization заключается в следующем.
[36:31.520 --> 36:37.520]  Если у вас структура A пустая, то
[36:37.520 --> 36:44.520]  Сайзов A будет, ну давайте скажем, больше правильной единицей, но на самом деле на практике правило единицы.
[36:44.520 --> 36:48.520]  Потому что объекты C++ не могут занимать меньше одного байта.
[36:48.520 --> 36:54.520]  Но в этом случае, если вы B унаследуете от пустой структуры, или B унаследуете от пустого класса,
[36:54.520 --> 36:58.520]  то на A место вообще тратиться не будет.
[36:58.520 --> 37:00.520]  Вот.
[37:00.520 --> 37:02.520]  То есть size of B
[37:05.520 --> 37:07.520]  будет в точности равен
[37:10.520 --> 37:12.520]  size of int.
[37:12.520 --> 37:17.520]  Короче говоря, если вы унаследуете от пустого класса, то место на этот класс в наследники не тратится совсем.
[37:17.520 --> 37:22.520]  Ну даже несмотря на то, что по стандарту требуется, чтобы все классы занимали как минимум один байт.
[37:22.520 --> 37:25.520]  Ну почему это так работает?
[37:25.520 --> 37:29.520]  Ну потому что если у вас есть структура B, то
[37:29.520 --> 37:33.520]  даже если структура B будет пустой, то мне достаточно хранить один байт для самой структуры B,
[37:33.520 --> 37:37.520]  и тогда у меня разным объектам будут соответствовать разные адреса.
[37:38.520 --> 37:43.520]  Поэтому, в общем, иногда вот этот вот трюк с приватным наследованием используется именно для того, чтобы
[37:43.520 --> 37:46.520]  не занимать много места памяти.
[37:46.520 --> 37:51.520]  Потому что если вы внутрь структуры B внесете объект A,
[37:51.520 --> 37:53.520]  то если вы сделаете вот так,
[37:59.520 --> 38:02.520]  то есть если вы внесете поле A внутрь структуры B,
[38:02.520 --> 38:06.520]  то вот на этот A уже будет тратиться один байт, как минимум.
[38:06.520 --> 38:09.520]  А если вы выполните наследование,
[38:09.520 --> 38:13.520]  то вот на это наследование не потратится ни одного байта.
[38:13.520 --> 38:20.520]  Это вот такой вот небольшой пример, когда приватный или препарктальный наследование может быть полезным.
[38:21.520 --> 38:23.520]  Окей?
[38:23.520 --> 38:25.520]  Хорошо.
[38:25.520 --> 38:27.520]  Ну и, наконец, вот то, про что я сказал.
[38:27.520 --> 38:33.520]  Мы когда с вами говорили в прошлом семестре про классы и структуры,
[38:35.520 --> 38:37.520]  в качестве одного из отличий, точнее, в качестве...
[38:37.520 --> 38:41.520]  То есть я сказал, что классы и структуры на самом деле отличаются только тем, что
[38:41.520 --> 38:45.520]  в классах по умолчанию все приватно, в структурах по умолчанию все публично.
[38:45.520 --> 38:47.520]  Ну, это на самом деле так.
[38:47.520 --> 38:50.520]  То есть классы и структуры, они с точки зрения кода и так далее,
[38:50.520 --> 38:52.520]  они эквиваленны, да, вот за исключением вот такого отличия.
[38:52.520 --> 38:54.520]  Ну и плюс, на самом деле, есть еще одно отличие,
[38:54.520 --> 38:56.520]  которое связано с наследованием,
[38:56.520 --> 38:57.520]  по сути, оно то же самое, да?
[38:57.520 --> 38:59.520]  То есть если структуры...
[38:59.520 --> 39:03.520]  Если мы после структуры, после двоеточиля не пишем слово паблик или правит,
[39:03.520 --> 39:05.520]  то по умолчанию считается, что вы наследуете публичным образом.
[39:05.520 --> 39:08.520]  Для классов по умолчанию считается, что вы наследуете приватным образом.
[39:08.520 --> 39:09.520]  Вот.
[39:09.520 --> 39:11.520]  То есть на этом список отличий классовح структур заканчивается,
[39:11.520 --> 39:13.520]  то есть, если коротко,
[39:13.520 --> 39:15.520]  то для классов по умолчанию все приватно,
[39:15.520 --> 39:17.520]  что наследование, что пар Lite, методы,
[39:17.520 --> 39:21.520]  А в структурах по умолчанию все публично, что наследование, что поля, методы и т.д.
[39:21.520 --> 39:26.520]  Все это второе и последнее отличие структуры от класса.
[39:26.520 --> 39:35.520]  Давайте поговорим про то, как ведут себя уже изученные нами концепции вместе с наследованием.
[39:35.520 --> 39:38.520]  В частности, поговорим про то, как ведут себя конструкторы и деструкторы,
[39:38.520 --> 39:43.520]  если вдруг возникает в ваших классах наследование.
[39:43.520 --> 39:49.520]  Снова пример. Допустим, у меня есть написанный класс stack,
[39:49.520 --> 39:53.520]  и у меня есть его наследники stackMax и stackMin.
[39:53.520 --> 39:56.520]  То есть, stack с поддержкой максимума, есть stack,
[39:56.520 --> 39:59.520]  плюс есть stack с дополнительной поддержкой максимума,
[39:59.520 --> 40:03.520]  и есть stack с дополнительной поддержкой минимума.
[40:03.520 --> 40:09.520]  Понятное дело, что класс stack содержит указательную динамическую память,
[40:09.520 --> 40:12.520]  поэтому у него есть какие-то конструкторы, деструкторы и все подряд.
[40:12.520 --> 40:15.520]  То же самое касается stackMax и stackMin.
[40:15.520 --> 40:18.520]  Так как мы реализуем stackMax и stackMin,
[40:18.520 --> 40:20.520]  так как нам нужно хранить максимум минимум,
[40:20.520 --> 40:23.520]  нам необходимо еще дополнительно хранить указательную массив,
[40:23.520 --> 40:26.520]  либо дополнительный список.
[40:26.520 --> 40:29.520]  Так или иначе, нам в stackMax и stackMin нужно прописать дополнительную логику,
[40:29.520 --> 40:32.520]  как правильно выделять ресурсы, как ее очищать.
[40:32.520 --> 40:35.520]  Вопрос заключается в следующем.
[40:35.520 --> 40:37.520]  Вот у меня есть stackMax.
[40:37.520 --> 40:41.520]  И stackMax в какой-то момент вызывает свой конструктор.
[40:42.520 --> 40:53.500]  Нужно
[40:53.520 --> 40:55.520]  сначала создать stack,
[40:55.520 --> 40:58.520]  то есть сначала создать часть, которая относится к stack,
[40:58.520 --> 41:01.520]  а потом из Terr grow ltт tart consultativeей,
[41:01.520 --> 41:02.520]  для которой есть р brewing,
[41:02.520 --> 41:04.520]  при котором, например, вот вlan 학,
[41:04.520 --> 41:07.520]  более Elizabeth, более Terrya.
[41:07.520 --> 41:10.520]  В принципе, в consecutive линдии irgendя� HTML,
[41:10.520 --> 41:22.520]  Когда я пишу конструктор по умолчанию, любой конструктор вашего класса устроен следующим образом.
[41:22.520 --> 41:25.520]  В первую очередь, он всегда вызывает конструкторы базовых классов.
[41:25.520 --> 41:31.520]  То есть, части, которые относятся к базовым классам, создаются всегда без вашего ведома.
[41:31.520 --> 41:38.520]  То есть, создание наследника состоит в том, чтобы создать наследников, а только потом вызвать конструктор вашего класса.
[41:38.520 --> 41:47.520]  То есть, в частности, конструктор по умолчанию StackMax сначала вызовет Stack по умолчанию, и только потом сделает необходимую инциализацию дальше.
[41:47.520 --> 41:54.520]  Примерно то же самое касается и конструктора копирования во втором примере.
[41:54.520 --> 42:00.520]  Если мы посмотрим на Stackmin конструктор копирования равно default, то конструктор по умолчанию для вашего класса сработает так.
[42:00.520 --> 42:09.520]  Он вызовет конструктор копирования для класса Stack, то есть, часть, которая относится к Stack в вашем классе, копируется друг в друга.
[42:09.520 --> 42:13.520]  И потом выполнится тело непосредственно своего конструктора копирования.
[42:13.520 --> 42:18.520]  Тут оно будет просто пустое по умолчанию.
[42:18.520 --> 42:23.520]  Кстати, в первом примере StackMax, в первом примере конструктора копирования, тут будет немного иначе.
[42:23.520 --> 42:27.520]  Смотрите, тут я написал конструктор копирования, и дальше написал пустые фигурные скобки.
[42:27.520 --> 42:29.520]  И вот тут будет проблема. Почему?
[42:29.520 --> 42:37.520]  Потому что я сказал, что чтобы создать StackMax, нужно все проинциализировать по умолчанию, и только потом запустить фигурные скобки.
[42:37.520 --> 42:39.520]  Смотрите, что мы знаем про фигурные скобки.
[42:39.520 --> 42:47.520]  Мы знаем, что фигурные скобки в конструкторе начинаются только тогда, когда все поля и вообще все части уже проинциализированы.
[42:47.520 --> 42:51.520]  Возникает вопрос, а как тогда будет проинциализирована часть, которая относится к Stack?
[42:51.520 --> 42:55.520]  И ответ заключается в том, что часть, которая относится к Stack, будет проинциализирована по умолчанию.
[42:55.520 --> 43:03.520]  Это означает, что компилятор сам не догадается о том, какой конкретно конструктор нужно вызвать для базового класса.
[43:03.520 --> 43:09.520]  Ну точнее, если вы напишете равно default, то компилятор догадается, что, наверное, если вы пишете конструктор копирования, то все нужно скопировать.
[43:09.520 --> 43:12.520]  Если вы пишете конструктор по умолчанию, то нужно вызвать конструктор по умолчанию.
[43:12.520 --> 43:23.520]  Если вы пишете самостоятельно фигурные скобки и не прописываете ничего в списке инциализации, то единственное, о чем может догадаться компилятор, это то, что вам нужно все проинциализировать по умолчанию.
[43:23.520 --> 43:29.520]  Так вот, как сказать компилятору о том, что мне нужно вызвать конкретный конструктор моего базового класса?
[43:29.520 --> 43:34.520]  Ну и, собственно, ответ заключается в том, что нужно это тоже прописать в списке инциализации.
[43:34.520 --> 43:43.520]  Ну смотрите, вот я пишу класс StackMax, значит, написал конструктор по умолчанию, ну, понятное дело, он просто равно default, вот, и пишу конструктор копирования.
[43:43.520 --> 43:49.520]  Вопрос, в чем заключается копирование Stack с поддержкой максимума?
[43:49.520 --> 43:53.520]  Ну, копирование получается в следующем. Сначала я должен скопировать часть, которая относится к стеку.
[43:53.520 --> 44:00.520]  То есть у меня есть базовая часть стека, и я базовую часть стека, ну вот, стека Other, копирую в базовую часть своего стека.
[44:00.520 --> 44:07.520]  То есть вот, в списке инциализации я прописываю конструктор, который должен быть вызван для моего предка, для моей базовой части.
[44:07.520 --> 44:13.520]  И только потом прописываю все то, что мне нужно для копирования всех остальных частей, которые относятся к моему классу.
[44:13.520 --> 44:14.520]  Понятно?
[44:22.520 --> 44:23.520]  Так.
[44:23.520 --> 44:41.520]  Ну, в целом, да. Ну, короче, тут идея в том, что если у вас класс A, точнее, наоборот, класс B, следовало от класса A,
[44:41.520 --> 44:53.520]  то вы можете сохранить ссылку на объекты типа B. Вот. Вот так это работает.
[44:53.520 --> 45:05.520]  Причем как это работает? Это работает так, что вот это вот A будет ссылкой на часть A, которая находится в B.
[45:05.520 --> 45:15.520]  Ну, смотрите, так как класс B у меня содержит все то же самое, что и A, то, соответственно, ссылку я тоже могу создать.
[45:15.520 --> 45:21.520]  Просто вот эта ссылка будет ссылаться только на ту часть B, которая относится к A. Понятно? Вот.
[45:21.520 --> 45:29.520]  То есть из чего состоит B? То есть B состоит из части, которая относится к A, ну и там, ко всей дополнительной части, которая относится к B.
[45:29.520 --> 45:32.520]  И вот эта вот ссылка будет ссылаться только вот на эту часть.
[45:33.520 --> 45:35.520]  Окей? Да.
[45:38.520 --> 45:42.520]  Не, никуда. То есть у меня в памяти вот есть объект. Вот.
[45:42.520 --> 45:47.520]  Значит, в памяти вначале расположено какие-то данные, которые относятся к A, а потом идут данные, которые относятся, ну, только к B.
[45:47.520 --> 45:51.520]  Вот. Когда я ссылую ссылку, у меня, по сути, эта ссылка ссылается только вот на эту часть памяти.
[45:51.520 --> 45:57.520]  Нет, остальная память, она по-прежнему тут находится, но просто ссылка ссылается вот только на эту часть. Да.
[45:57.520 --> 45:59.520]  Да.
[46:01.520 --> 46:07.520]  Не, не, ничего не кастуется. Нет, нет, как бы тут чисто дело, ну дело в памяти. Вот.
[46:07.520 --> 46:13.520]  То есть как бы вот, допустим, вас A занимает, не знаю, там 8 байт, B занимает, не знаю, 24 байта.
[46:13.520 --> 46:19.520]  Вот. То есть первые 8 байт – это вот то, что относится к A, остальные 16 байт – это то, что относится к B, без учета A.
[46:19.520 --> 46:24.520]  Вот. И вот эта ссылка, она ничего не кастует, она просто-напросто, ну как бы считает, что она ссылается вот на объект A.
[46:24.520 --> 46:30.520]  Ну, действительно, это так, да. То есть тут, на самом деле, вот эта вот, вот эта вот часть памяти, она вообще неотличима от объекта A.
[46:30.520 --> 46:36.520]  То есть, грубо говоря, B состоит из A и чего-то еще. И вот эта ссылка ссылается только на часть B, которая относится к A.
[46:36.520 --> 46:38.520]  Все. Да.
[46:38.520 --> 46:46.520]  Ну, опять же, тут не совсем, ну, можно считать, что, ну, наверное, можно считать, что каст, но просто можно считать так, что конструктор stack'a принимает ссылку на stack.
[46:46.520 --> 46:52.520]  Вот. В adder содержится часть, которая относится к stack'a, поэтому в нее можно тоже создать ссылку. Вот.
[46:52.520 --> 46:56.520]  Что мы имеем право?
[46:56.520 --> 47:02.520]  Ну, с помощью константной стэк, мы можем создать ссылку.
[47:03.520 --> 47:07.520]  Что мы имеем право?
[47:07.520 --> 47:12.520]  Ну, с помощью константной ссылки не можем. Если бы была обыкновенная, то могли бы.
[47:12.520 --> 47:18.520]  Да, да. Да.
[47:18.520 --> 47:21.520]  Это хороший вопрос.
[47:21.520 --> 47:29.520]  Ну, типа, да. Ну, не хочется говорить про родитель номер 1, родитель номер 2. В общем, допустим, есть A, есть B, есть C.
[47:29.520 --> 47:31.520]  Такая ситуация, возможно, C++.
[47:31.520 --> 47:35.520]  Вот. То есть, называется множество наследований.
[47:40.520 --> 47:43.520]  Ну, про него мы поговорим как-нибудь в другой раз.
[47:43.520 --> 47:46.520]  Вот. Ну, просто такой теоретически возможно.
[47:46.520 --> 47:54.520]  Вот. Ну, вообще говоря, как правило, такое, ну, многим констант такой запрещается, потому что добавляет хаотичности в код и так далее.
[47:54.520 --> 47:56.520]  В общем, про это мы тоже поговорим.
[47:56.520 --> 47:59.520]  Вот. Ну, в этом случае на самом деле тоже будет работать.
[47:59.520 --> 48:13.520]  Вот. То есть, если C публично у наследованного A и C публично у наследованного B, то я также могу создать ссылку A на C и ссылку B на C.
[48:13.520 --> 48:16.520]  Ну, просто компилятору тут будет немного сложнее работать, но в целом.
[48:16.520 --> 48:23.520]  Ну, как бы, в самом простом случае это будет устроено так, что у вас сначала идет часть, которая относится к A, потом часть, которая относится к B,
[48:23.520 --> 48:30.520]  а потом часть, которая относится к C без A и B.
[48:30.520 --> 48:35.520]  Вот. Тогда ссылка на A будет ссылаться вот сюда, ссылка на B будет ссылаться вот сюда.
[48:35.520 --> 48:38.520]  Дальше начинается прикол, а что, если у A и B есть какая-то своя общая часть.
[48:38.520 --> 48:41.520]  Ну, в общем, давайте пока не думать.
[48:41.520 --> 48:43.520]  Так. Есть ли еще вопросы?
[48:47.520 --> 48:49.520]  Окей. То есть, резюмируем.
[48:49.520 --> 48:52.520]  Значит, классы инициализируются в следующем порядке. Сначала инициализируются базовые классы.
[48:52.520 --> 48:58.520]  То есть, если у класса A, то есть, если у класса есть какие-то предки, то сначала инициализируются они.
[48:58.520 --> 49:02.520]  Вот. Причем то, как они будут пронициализированы, вы можете задать списки инициализации.
[49:02.520 --> 49:10.520]  То есть списки инициализации вы можете задать, что мой наследник, что мой предок один должен быть сгенерирован так, наследник второй должен быть сгенерирован так и так далее.
[49:10.520 --> 49:14.520]  Вот. А затем, а затем создаются поля класса наследника.
[49:14.520 --> 49:17.520]  Причем в строго порядке объявления.
[49:17.520 --> 49:19.520]  Ну, вот такой пример.
[49:19.520 --> 49:24.520]  Вот у меня есть структура A, которая есть два конструктора, конструктора tent-A и конструктора двух int.
[49:24.520 --> 49:27.520]  У меня есть структура B, в которой есть одно интовое положение z, при этом b у нас следовано от A.
[49:27.520 --> 49:30.020]  Значит, как я могу написать конструктор для B?
[49:30.020 --> 49:41.520]  Значит, конструктор для B я могу написать, например так, да, конструктор B от tent-A будет просто вызывать конструктор A от x, да, то есть я просто-напрасно говорю, что чтобы создать B, мне нужно создать части, которые относятся к A, с помощью одного int, с помощью x.
[49:41.520 --> 49:47.360]  с помощью xA. Вот. Если я, например, допустим, создать конструктор B, который принимает два аргумента, я могу, например,
[49:48.240 --> 49:51.560]  в списке интеллизации указать, что вот все эти два аргумента пойдут в конструктор A.
[49:52.080 --> 49:57.840]  Вот. Если у меня B принимает три аргумента, то я говорю, что первые два аргумента пойдут в A, а остальным аргументом третьим я
[49:58.080 --> 49:59.440]  заполню Z.
[49:59.440 --> 50:01.560]  При этом, заметьте, что конструктор по умолчанию,
[50:02.360 --> 50:08.600]  что конструктор по умолчанию, я просто так вот создать конструктор по умолчанию я не смогу. То есть я не могу написать там B пустые круглые скобки и фигурные скобки.
[50:08.940 --> 50:12.440]  Почему? Потому что в этот момент, так как я не написал в списке интеллизации,
[50:12.780 --> 50:16.780]  компилятор попытается вызвать конструктор по умолчанию A, а A нет конструктора по умолчанию.
[50:18.360 --> 50:20.360]  Понятно?
[50:20.760 --> 50:25.860]  То есть, если вы в списке интеллизации не написали, как нужно создать наследника, наследник будет создан с помощью
[50:26.400 --> 50:31.100]  конструктор по умолчанию. Если же вы хотите вызвать какой-то другой конструктор, а не конструктор по умолчанию,
[50:31.120 --> 50:36.000]  то вы через дветочие прописывайте, что, вот, я хочу A вызвать конструктор от вот таких аргументов. Вот.
[50:36.000 --> 50:42.360]  При этом важно понимать, что отдельно поля структуры A я заполнить не могу, то есть я не могу написать
[50:42.360 --> 50:50.320]  Кажется, у меня это есть на слайдах или... Ладно, кажется, нет. А, нет, вот есть. То есть отдельно
[50:50.320 --> 50:56.040]  поля базового класса я проинфициализировать не могу. То есть класс A, то есть если у меня B унаследован от A,
[50:56.040 --> 51:01.520]  то A у меня входит в B целиком, ну как бы вот, в единым целом. Поэтому и часть, которая относится к A,
[51:01.520 --> 51:04.640]  я тоже должен создать и создавать единым целым. То есть сейчас, например, я тут не могу,
[51:04.640 --> 51:10.040]  вот в этом примере я не могу создать конструктор B, который отдельно проинфициализирует x, x, y, y, z, z.
[51:10.040 --> 51:15.920]  Вот. То есть я должен именно передать параметры в конструктор A, вот. А единственное поле,
[51:15.920 --> 51:21.080]  которое я могу проинфициализировать тут самостоятельно, это поле z. Окей?
[51:21.080 --> 51:37.240]  А есть пример? Вот. Смотрите, давайте посмотрим на это пример. Тут может показаться, что мы
[51:37.240 --> 51:42.840]  делаем что-то неэффективное, ну, в смысле, с точки зрения написания кода. Смотрите,
[51:42.840 --> 51:48.120]  вот давайте посмотрим на последнюю, ну, на третью строчку снизу и четвертую строчку снизу. Вот я
[51:48.120 --> 51:57.240]  пишу bintx.ax или bintxy.axy. То есть что тут я тут пишу? Я говорю, что если я вызываю конструктор,
[51:57.240 --> 52:01.040]  то есть если вызываю конструктор одного аргумента, то я должен вызвать конструктор для A. Если
[52:01.040 --> 52:04.920]  вызываю конструктор от двух аргументов, я вызываю конструктор для A от двух аргументов. То есть,
[52:04.920 --> 52:09.680]  по сути, кажется, что я просто-напросто подменяю конструктор B конструктором A. И во втором случае
[52:09.680 --> 52:13.760]  тоже подменяю конструктор B конструктором A. Вот. Ну, кажется, что я просто-напросто тупо дублирую
[52:13.760 --> 52:18.440]  код. Ну, как бы я прописываю один и тот же конструктор несколько раз. А представьте мне,
[52:18.440 --> 52:24.400]  что я хочу сказать следующую вещь. Я хочу сказать, что на самом деле класс B должен задержать все те
[52:24.400 --> 52:29.680]  же самые конструкторы, что и A. Вот. То есть он должен принимать ровно такое же количество конструкторов,
[52:29.680 --> 52:35.680]  и он должен принимать ровно такие же аргументы, что и конструктор A. Вот. Я это могу сделать с помощью
[52:35.680 --> 52:43.440]  директивы using. Вот. Вторая строчка снизу, ну или третья. Вот. Я пишу using A.A, и это означает,
[52:43.440 --> 52:49.120]  что в классе B должны быть точно такие же конструкторы, как и в A. В этом случае я B
[52:49.120 --> 52:53.760]  могу вызывать точно таким же, могу создавать точно таким же набором параметров. Вот. И при этом
[52:53.760 --> 52:57.360]  все эти параметры будут просто-напросто передаваться в конструктор A. Ну, а часть, которая относится к B,
[52:57.360 --> 53:01.920]  будет создана по умолчанию. Окей? Ну, то есть, если это примитивный тип, то она будет заполнена мусором.
[53:01.920 --> 53:07.920]  Вот. Если это какие-то классы, то она будет заполнена конструкторами по умолчанию. Понятно? Ну и такой
[53:07.920 --> 53:12.160]  просто способ, грубо говоря, унаследовать конструкторы. Потому что конструкторы сами по себе не
[53:12.160 --> 53:21.200]  наследуются. Да. Не, ну вот это имеет смысл. Если, допустим, у вас, ну если, допустим, у вас структура B,
[53:21.200 --> 53:34.720]  представьте себе, вот если у вас есть какой-то класс B, ну не важно, у вас есть класс B, который содержит
[53:34.720 --> 53:47.760]  какое-то поле, ну не знаю там, типа STD-вектор V. Вот. И, допустим, в классе A есть какие-то, есть какие-то
[53:47.760 --> 53:53.040]  конструкторы? Типа конструктор от NTA, от NTA и DLA, от DLA и BLA, ну и так далее. Куча-куча конструкторов. Вот.
[53:53.040 --> 54:01.520]  И я бы хотел, чтобы A, да и при этом B унаследован от A. Вот. То есть, класс B отличается от класса A
[54:01.520 --> 54:06.400]  всего лишь на I, чем вектор. Вот. Ну и я бы хотел, чтобы в классе B были ровно такие же конструкторы,
[54:06.400 --> 54:11.520]  как и в A. Ну, естественно, мне бы не хотелось вручную переписывать, что у класса B есть конструктор от NTA,
[54:11.520 --> 54:18.440]  от NTA и DLA, от DLA и BLA, и так далее. Вот. Поэтому я просто пишу using, ну, в публичной области, естественно.
[54:18.440 --> 54:29.680]  Я просто пишу using B.B. То есть, я говорю, что как бы из B нужно взять все конструкторы. Вот. И в этом
[54:29.680 --> 54:37.320]  случае все те же самые, ой, наоборот. А. Что мне из A нужно взять все конструкторы. Вот. И в этом случае у меня в B
[54:37.320 --> 54:49.000]  будут ровно те же самые конструкторы, что и в A. Еще раз. Если мы это не напишем, то действует обычное
[54:49.000 --> 54:52.440]  правило для классов. А какое у нас обычное правило для классов? Если мы в классе B не написали ни одного
[54:52.440 --> 55:03.080]  конструктора, то в нем есть только конструктор по умолчанию. Вот. Нет, так нельзя. Нет.
[55:07.320 --> 55:17.040]  В целом, да, можем, но у этого есть, в общем, так можно посвести с любым методом. Вот. Но, как правило,
[55:17.040 --> 55:22.000]  это не нужно, потому что методы автоматически подгружаются. То есть, конструкторы, да, вот,
[55:22.000 --> 55:26.640]  наверное, это стоит подсветить. Что? Зачем нам нужно писать вот так? Потому что конструкторы,
[55:26.640 --> 55:32.000]  в отличие от обычных методов, ну, грубо говоря, не наследуются автоматически. Вот. То есть, как бы,
[55:32.000 --> 55:36.840]  если у вас в классе A есть метод F, то метод F появится в классе B. Но если в классе A есть какой-то
[55:36.840 --> 55:40.800]  конструктор, то автоматически в классе B он не появится. Вот. Чтобы они появились автоматически,
[55:40.800 --> 55:57.240]  нужно писать вот так. Окей? А нет, с деструктурами по-другому. Там дальше поговорим. Не, он даже
[55:57.240 --> 56:02.040]  наследуется, но просто класс B не сможет получить к нему доступа. Ну, в смысле, если B попытается
[56:02.040 --> 56:13.640]  вызвать конструктор, ну, приватный конструктор для A, то он зафейлится. Нет, конкретный конструктор,
[56:13.640 --> 56:20.120]  ну, короче, нет. Вы либо импортируете все конструкторы, либо никаких конструкторов. Нет,
[56:20.120 --> 56:25.680]  точнее, нет, вы можете сделать так. А, сейчас. Смотрите, если вам нужен какой-то отдельный конструктор или
[56:25.680 --> 56:29.480]  отдельный конструктор, то вы прописываете его руками. Если вам нужны все конструкторы кроме одного,
[56:29.480 --> 56:34.360]  допустим, кроме конструктора A от NTA, то вы можете отдельно написать вот так using A 2.2.A и
[56:34.360 --> 56:44.040]  написать там B от NTA равно delete. Вот. То есть как бы вы можете так вот либо опционально какие-то
[56:44.040 --> 56:55.960]  добавить вручную, либо какие-то вручную удалить. Окей? Хорошо. Так, теперь с деструктурами. А с
[56:55.960 --> 56:59.280]  деструктурами, на самом деле, та же самая история, но в смысле в порядке. To si, когда мы говорили
[56:59.280 --> 57:02.540]  про конструкторы, конструктора вызыва в следующей порядке. Сначала вызываются конструкторы для
[57:02.540 --> 57:07.680]  предков, а потом вызываются конструкторы для самого класса. С деструктурами ровно обратная
[57:07.680 --> 57:12.580]  ситуация. Сначала вызываются деструкторы для полей вашего класса. То есть сначала будут вызваны
[57:12.580 --> 57:17.880]  деструктуры для В, например, для Вектора и для остальных полей. И в самой последней очереди будет
[57:17.880 --> 57:23.800]  вызван деструктур А. Вот. Вот деструктор, в отличие от конструкторов вызывать явно не нужно, потому что
[57:23.800 --> 57:25.600]  деструктур всегда только один и
[57:25.600 --> 57:26.780]  конструкторов может быть много, а
[57:26.780 --> 57:27.960]  диструктуры в классе всегда
[57:27.960 --> 57:30.560]  только один, поэтому диструктура всегда
[57:30.560 --> 57:32.340]  вызовется автоматически
[57:32.340 --> 57:36.240]  Если у вас класс унаследован
[57:36.240 --> 57:37.520]  от каких-то других классов, то их
[57:37.520 --> 57:38.480]  деструктура тоже будет вызвана
[57:38.480 --> 57:39.800]  автоматически.
[57:39.800 --> 57:40.760]  Например, у меня есть класс B,
[57:40.760 --> 57:43.440]  у меня есть какой-то класс A.
[57:43.440 --> 57:44.460]  Есть класс B, который
[57:44.460 --> 57:46.480]  унаследован от A. И в классе Б содержится
[57:46.480 --> 57:48.680]  допустим два стека зачем-то.
[57:48.680 --> 57:50.900]  Соответственно, я пишу диструктур B и
[57:50.900 --> 57:52.880]  сначала в диструктуре Б вызовутся
[57:52.880 --> 57:56.960]  Деструкторы для стеков, то есть для S1SoC и для С2, а потом для С1SoC
[57:56.960 --> 58:06.120]  а когда в конце деструктуры закончают JS üz disconnected, в конце вызываются деструкторы для частью сpart2
[58:06.200 --> 58:08.200]  понятно?
[58:09.480 --> 58:15.680]  если вам нужен вызвать какой-то конкретный деструктор, вы должны прописаться в списке инт telescope
[58:15.680 --> 58:20.880]  и если вам нужно чтобы вызвался деструктор, вы можете об этом не думать, в touble, т.е. да grasp
[58:22.880 --> 58:37.880]  Единственное, что важно понимать, что конструкторы выполняются в прямом порядке, то есть сначала наследники, потом поля класса, а деструктор в обратном порядке, то есть сначала поля класса в обратном порядке, а потом предок.
[58:37.880 --> 59:00.880]  Так, теперь к интересной части, к срезке, вот про то, как на самом деле связаны между собой классы. Смотрите, вот я про это еще не проговорил, про это не сказал, но вообще говоря стоило.
[59:00.880 --> 59:28.880]  Смотрите, публичное наследование реализует так называемую симматику является. То есть если у меня класс B публично унаследован от A, то с такой симматической точки зрения можно считать, что B является A.
[59:30.880 --> 59:48.880]  Почему это верно? Потому что если класс B унаследован от A, то значит все то, что верно для A, верно и для B. То есть если в классе A есть какие-то поля, то и в B они есть. Если в A есть какие-то методы, то и в B они есть. Причем если в A они доступны, то и в B они тоже доступны.
[59:48.880 --> 01:00:01.880]  То есть по сути везде, где встречается A, я могу подставить B. И от этого ничего не потеряю. Согласны? Вот этот принцип называется принцип установки Барбарлистков.
[01:00:01.880 --> 01:00:12.880]  То есть если везде вместо одного типа вы можете подставить другой тип, то вот этот тип является подтипом вот этого типа. То есть на самом деле B является A, то есть B унаследован публичным образом от A.
[01:00:12.880 --> 01:00:20.880]  Вот. И вот давайте сейчас будем жить парадигме, что мы работаем с публичным наследованием, то есть у нас при наследовании реализуется семантика является.
[01:00:20.880 --> 01:00:30.880]  Вот. То есть у меня есть какая-то структура A, есть структура B, которая унаследована от A. То есть B является A. К чему это приводит?
[01:00:30.880 --> 01:00:38.880]  А это на самом деле приводит к тому, что на самом деле действительно если в коде, ну везде где в коде вы можете подставить A объекты A, вы можете подставить и объекты B.
[01:00:38.880 --> 01:00:48.880]  Ну вот примеры следующие. Я создал, ну вот в самом конце. Я создал объект типа B. Вот. И создал объект типа A с помощью объекта типа B.
[01:00:57.880 --> 01:01:07.880]  И это возможно. То есть так делать можно. Почему? Потому что B является A. Раз B является A, то везде где я могу подставить A, ну тут я мог подставить A? Мог.
[01:01:07.880 --> 01:01:19.880]  Вот. Поэтому везде где я подставляю A, я могу подставить и B. Вот. Ну и логично я могу написать A, присваивание B. То есть вообще говоря в нормальной ситуации я могу присваивать только объекта одного типа.
[01:01:19.880 --> 01:01:30.880]  Ну то есть я могу присваивать только объекта одного типа тому же самому типу. Но тут так как у меня объекты типа B являются объектами типа A, то вот это присваивание тоже работает.
[01:01:30.880 --> 01:01:40.880]  Но при этом заметьте, что не наоборот. То есть, например, написать вот так у меня не получится. Почему? Потому что если B является A, отсюда вообще не следует, что A является B.
[01:01:40.880 --> 01:01:48.880]  Да? Ну то есть из того, что стул является мебелью, не следует, что любая мебель это стул. Понятно? Вот.
[01:01:49.880 --> 01:01:56.880]  Вопрос. Как это работает? Что при этом происходит? Вот давайте сосредоточимся вот на этих примерах.
[01:01:56.880 --> 01:02:05.880]  Ну, допустим, мне удалось присвоить объект типа B, объекта типа A. Ну, точнее создать объект типа A с помощью объекта B или присвоить B, A.
[01:02:05.880 --> 01:02:13.880]  Что при этом происходит? При этом происходит такая вещь, которая называется срезкой. Что такое срезка? Срезка это явление, при котором...
[01:02:13.880 --> 01:02:23.880]  Вот смотрите, вот у меня есть, допустим, объект A и есть объект B. Вот в объекте B находится часть, которая относится к A, часть, которая относится только к B.
[01:02:23.880 --> 01:02:31.880]  Значит, срезка заключается в следующем. Часть, которая относится к A копируется вот сюда.
[01:02:31.880 --> 01:02:40.880]  То есть при срезке теряется часть информации. То есть как раз не только часть, которая относится к A копируется, а вся остальная часть остается в B.
[01:02:40.880 --> 01:02:49.880]  Вот. Собственно, вот такое вот копирование наследников в предков называется срезкой.
[01:02:49.880 --> 01:02:51.880]  Вот.
[01:02:57.880 --> 01:03:01.880]  Ну, да, собственно, опять же, срезка, повторю, что тут написано.
[01:03:01.880 --> 01:03:06.880]  Тут срезка может работать только в случае, когда у меня наследование публичное.
[01:03:06.880 --> 01:03:14.880]  То есть если бы наследование B от A было, допустим, приватным, вот этот код бы не сработал.
[01:03:14.880 --> 01:03:19.880]  Ну, почему? Потому что вот этот код, он жестко испортит тот факт, что вообще говоря, B унаследован от A.
[01:03:19.880 --> 01:03:23.880]  Да, так как B не унаследован, так как я не имею права в этом знать, то вот этот код не сработает.
[01:03:23.880 --> 01:03:31.880]  Вот. Единственное исключение заключается в том, что если бы тут, допустим, написано было Protected, вот как в примере, как вот в последнем примере.
[01:03:31.880 --> 01:03:38.880]  Если B Protected образом унаследован от A, то это, по сути, вообще говоря, означает, что, понятное дело, что B знает о том, что унаследован от A.
[01:03:38.880 --> 01:03:44.880]  Поэтому внутри B я могу использовать тот факт, что B унаследован от A, и поэтому я могу выполнять срезку.
[01:03:44.880 --> 01:03:51.880]  Вот. Понятно? То есть срезка во внешнем коде возможна только если внешний код знает о том, что кто-то от кого-то унаследован.
[01:03:51.880 --> 01:04:01.880]  Понятно? Срезка. Ну, простой пример такой.
[01:04:01.880 --> 01:04:11.880]  Вот, допустим, у вас есть, ну, представьте себе, что у вас есть, допустим, stack с поддержкой максимума.
[01:04:11.880 --> 01:04:16.880]  Вот. И вы как-то с ним поработали.
[01:04:16.880 --> 01:04:24.880]  Вот. А потом вам необходимо, а потом вдруг, ну, у вас появилась необходимость скопировать stack, но при этом часть, которая относится к максимуму, вам не нужна.
[01:04:24.880 --> 01:04:28.880]  То есть вам нужно использовать только stack, ну, только те элементы, которые в нем содержатся.
[01:04:28.880 --> 01:04:38.880]  Когда вы пишете, когда вы можете написать stack s равно sm, и в этом случае у вас stack скопируется только та часть, которая относится к stack.
[01:04:38.880 --> 01:04:44.880]  Вот. При этом та часть, которая относится к максимуму, у вас будет потеряно, но вам этого и не нужно.
[01:04:44.880 --> 01:04:50.880]  Вы как бы тут пользуетесь только возможностью stack, а на максимуму забиваете.
[01:04:50.880 --> 01:04:52.880]  Окей?
[01:04:56.880 --> 01:05:02.880]  Ну, здесь у меня stack max унаследован от stack.
[01:05:06.880 --> 01:05:10.880]  То есть если у меня stack max унаследован от stack, тогда вот это возможно.
[01:05:10.880 --> 01:05:16.880]  Если бы stack max и stack были бы абсолютно разными типами, то вообще говоря, вот так написать бы не мог.
[01:05:16.880 --> 01:05:23.880]  Ну, точнее, я бы мог это написать, если я написал какой-то специальный конструктор, который бы позволял бы мне создавать стейки на основе stack max.
[01:05:33.880 --> 01:05:37.880]  Не-не-нет. Вот у меня есть такая иерархия. Stack max унаследован от stack.
[01:05:37.880 --> 01:05:44.880]  Вот. Я создал stack max, и дальше о чем говорит публичное исследование?
[01:05:44.880 --> 01:05:49.880]  Публичное исследование говорит о том, что везде, где я использую stack, я могу использовать stack max.
[01:05:49.880 --> 01:05:55.880]  Но в частности вот тут. Я могу создать любой stack, передавая ему аргумент stack max.
[01:05:55.880 --> 01:06:03.880]  Вот в этом случае stack скопируется только часть, которая относится к stack.
[01:06:03.880 --> 01:06:09.880]  Потому что что такое stack max? Stack max это stack и плюс еще что-то.
[01:06:09.880 --> 01:06:12.880]  И вот это вот еще что-то скопировано не будет. Вот это срезка.
[01:06:12.880 --> 01:06:16.880]  То есть я по сути срезал ту часть, которая относится только к stack и скопировал только ее.
[01:06:26.880 --> 01:06:30.880]  Ну, погодите. Во время выполнения программы ничего добавить в класс не можете.
[01:06:30.880 --> 01:06:36.880]  А добавить в класс вы можете только после компиляции. То есть вы как бы внесите изменения в код, и потом заново скомпилируете программу.
[01:06:36.880 --> 01:06:40.880]  Но если так, то у вас в наследнике тоже появятся эти методы.
[01:06:42.880 --> 01:06:49.880]  Ну, можете, да, но вы же код пишете на этапе компиляции, то есть до компиляции.
[01:06:49.880 --> 01:06:52.880]  Вы же не можете во время исполнения программы что-то добавлять в классы.
[01:06:58.880 --> 01:07:02.880]  Не, ну смотрите, у вас же классы, есть две вещи.
[01:07:02.880 --> 01:07:11.880]  Вот у вас есть класс, есть объявление класса, в котором вы, точнее, определение класса, в котором вы прописываете все параллельные методы, которые в нем есть.
[01:07:11.880 --> 01:07:17.880]  А определение метод вне класса означает, что вот у вас есть этот метод, который вы не определили, и вы определяете его в другом месте.
[01:07:17.880 --> 01:07:19.880]  Но при этом сам класс-то знает, что у него есть этот метод.
[01:07:19.880 --> 01:07:25.880]  То есть вы не можете объявить метод внутри, объявить метод класса, который не написан внутри вот этих фигур скопов.
[01:07:30.880 --> 01:07:33.880]  Есть еще вопросы? Окей.
[01:07:33.880 --> 01:07:39.880]  Так, ну и понятное дело, что вот, да, такой пример.
[01:07:39.880 --> 01:07:42.880]  Значит, срезка не всегда делает то, что нам нужно.
[01:07:42.880 --> 01:07:44.880]  Вот, в частности, вот такой пример.
[01:07:44.880 --> 01:07:51.880]  Представьте себе, что у меня есть структура A, и в ней есть поле, ну поле строчки, которая содержит просто-напросто имя класса.
[01:07:51.880 --> 01:07:58.880]  Ну и понятное дело, что в конструкторе я просто пишу, что имя класса это, ну в структуре A я пишу, что имя класса это A.
[01:07:58.880 --> 01:08:03.880]  Потом я беру структуру B, наследую ее от A и говорю, что имя класса это B.
[01:08:03.880 --> 01:08:09.880]  Ну нормально, в структуре B есть поле name, и в конструкторе B я говорю, что name это B.
[01:08:09.880 --> 01:08:14.880]  То есть когда создается объект A, у меня там в name сохраняется A, когда я создаю B, у меня в name сохраняется B.
[01:08:14.880 --> 01:08:16.880]  Ну вот незадача.
[01:08:16.880 --> 01:08:20.880]  А если я напишу, ну я создаю A, a.name равно A, все отлично.
[01:08:20.880 --> 01:08:23.880]  Создаю B, b.name равно B, все отлично.
[01:08:23.880 --> 01:08:28.880]  Но, когда я выполняю срезку, то есть я пишу A, A, A равно B,
[01:08:33.880 --> 01:08:35.880]  начинаются проблемы. Какие?
[01:08:35.880 --> 01:08:40.880]  Смотрите, в B у меня есть поле name, которое содержит B.
[01:08:40.880 --> 01:08:48.880]  Ну так как name это общее место для класса A и для класса B, то поле name как раз таки скопируется с помощью срезки в A.
[01:08:48.880 --> 01:08:55.880]  И таким образом у меня вот в этом объекте в поле name будет храниться A, будет храниться B, хотя хотелось бы A.
[01:08:55.880 --> 01:08:57.880]  Понятна проблема?
[01:08:57.880 --> 01:08:59.880]  Вот.
[01:08:59.880 --> 01:09:06.880]  Поэтому иногда хотелось бы сделать так, чтобы, в общем, при срезке копирование объекта ввело себя немного иначе.
[01:09:06.880 --> 01:09:09.880]  Ну и решение на самом деле заключается довольно простое.
[01:09:09.880 --> 01:09:14.880]  Нужно просто-напросто в классе A написать конструктор, который принимает B.
[01:09:14.880 --> 01:09:16.880]  Вопрос как это сделать?
[01:09:16.880 --> 01:09:18.880]  Да, смотрите, у меня есть структура A.
[01:09:18.880 --> 01:09:23.880]  И естественно структура A, она же не, ну, то есть как бы у меня наследник, он же определяется после структуры A.
[01:09:23.880 --> 01:09:26.880]  То есть у меня есть структура A, и после нее определяется наследник B.
[01:09:26.880 --> 01:09:30.880]  Вот. Как написать в структуре A метод, который бы принимал объекта типа B?
[01:09:30.880 --> 01:09:37.880]  Ну очень просто. Я вот в первой строчке пишу forward declaration, то есть я пишу объявление класса B.
[01:09:37.880 --> 01:09:39.880]  То есть я говорю, что где это у меня будет класс B.
[01:09:39.880 --> 01:09:43.880]  Вот. Дальше в структуру A я пишу конструктор от B.
[01:09:43.880 --> 01:09:45.880]  То есть я говорю, что A, const B, other.
[01:09:45.880 --> 01:09:47.880]  Вот. Дальше прописываю структуру B.
[01:09:47.880 --> 01:09:55.880]  Ну и собственно в конструкторе A, который принимает B, прописываю необходимые действия, которые мне нужно сделать, если мне в структуру A подастся объект B.
[01:09:55.880 --> 01:09:57.880]  Вот. Окей?
[01:09:57.880 --> 01:10:03.880]  То есть если меня не устраивает поведение при срезке, я просто-напросто могу написать дополнительный конструктор в структуре A.
[01:10:03.880 --> 01:10:13.880]  Но при этом я должен помнить о том, что так у меня наследник всегда определяется после предка, то до предка я должен сделать вот этот самый forward declaration, который написан в первой строчке.
[01:10:13.880 --> 01:10:15.880]  Окей?
[01:10:16.880 --> 01:10:18.880]  Вот.
[01:10:18.880 --> 01:10:21.880]  Да, ну в абсолютно аналогичном образом можно запретить срезку.
[01:10:21.880 --> 01:10:25.880]  То есть допустим, вы хотите, чтобы такое безобразие было запрещено.
[01:10:25.880 --> 01:10:29.880]  То есть вы не хотите, чтобы с помощью наследников можно было создавать предков.
[01:10:29.880 --> 01:10:34.880]  Но в этом случае вы просто пишете, конструктор A от наследника равно delete.
[01:10:34.880 --> 01:10:36.880]  И, в образом, от наследника создаваться будет нельзя.
[01:10:36.880 --> 01:10:38.880]  Окей?
[01:10:40.880 --> 01:10:42.880]  Хорошо.
[01:10:42.880 --> 01:10:44.880]  Так.
[01:10:44.880 --> 01:10:46.880]  Теперь важная часть затенения методов.
[01:10:46.880 --> 01:10:48.880]  Последняя часть.
[01:10:48.880 --> 01:10:50.880]  Смотрите.
[01:10:50.880 --> 01:10:53.880]  Вот мы с вами говорили, вот все это время мы с вами говорили о простых ситуациях.
[01:10:53.880 --> 01:11:00.880]  Вот у меня есть класс A, в классе A есть какие-то методы, потом есть класс B, который наследуется от A, и поэтому в B получаются все методы, которые находятся в A.
[01:11:00.880 --> 01:11:02.880]  Да?
[01:11:02.880 --> 01:11:04.880]  Но, возможно, же и более сложная ситуация.
[01:11:04.880 --> 01:11:06.880]  У меня есть класс B, который наследуется от A.
[01:11:06.880 --> 01:11:08.880]  И в A есть метод F.
[01:11:08.880 --> 01:11:10.880]  Но в то же время в B тоже есть метод F.
[01:11:10.880 --> 01:11:13.880]  То есть, у меня и в предке, и в наследнике есть один и тот же метод.
[01:11:13.880 --> 01:11:16.880]  Что при этом происходит?
[01:11:18.880 --> 01:11:20.880]  При этом происходит следующая вещь.
[01:11:20.880 --> 01:11:24.880]  Вот, есть у меня в классе A есть метод F, который принимает Int, и в классе B есть метод F, который принимает Int.
[01:11:24.880 --> 01:11:33.880]  А если я буду вызывать метод F с помощью класса B, с помощью объекта класса B, у меня будет вызываться метод, который находится в классе B.
[01:11:33.880 --> 01:11:35.880]  И эта ситуация называется затенением методов.
[01:11:37.880 --> 01:11:39.880]  То есть, если у меня в классе B есть метод,
[01:11:39.880 --> 01:11:44.660]  метод с таким же именем, что и в классе A, то при вызове через класс B у меня будут
[01:11:44.660 --> 01:11:49.080]  вызваться именно методы, которые находятся в классе B. Еще раз, это называется затенение метода.
[01:11:49.080 --> 01:11:55.240]  То есть наибольший приоритет имеют методы, которые объявлены внутри класса наследника.
[01:11:55.240 --> 01:12:06.600]  Запомнили. Тут мог возникнуть вопрос, а можно ли как-то все-таки обратиться к методу F,
[01:12:06.600 --> 01:12:11.200]  которая находится в классе A, и ответ – да, можно, вот последняя строчка, в общем, вот с
[01:12:11.200 --> 01:12:14.600]  помощью такого способа вы можете обратиться к методу, которая находится в классе A. То есть,
[01:12:14.600 --> 01:12:20.160]  если очень хочется, вы можете написать, ну, это называется полным именем метода. Вы пишите
[01:12:20.160 --> 01:12:27.480]  B.A.F. A.F – это полное квалифицированное имя, называется полное квалифицированное имя F.
[01:12:27.480 --> 01:12:33.800]  Вот. Окей. Но это все еще очень простые примеры. То есть, если у меня и в A есть F от int, и в B есть F
[01:12:33.800 --> 01:12:38.080]  от int, то приоритет будет отдаваться наследнику. То есть, если вызываетесь через наследников.
[01:12:38.080 --> 01:12:44.440]  Другой, более странный пример. Смотрите, у меня в структуре A метод F, который не принимает
[01:12:44.440 --> 01:12:50.120]  аргументов. Структура B у наследована от A, и она реализует метод F, который принимает int.
[01:12:50.120 --> 01:12:55.000]  Ну, смотрите, казалось бы, в классе A есть метод F, который не принимает аргументов. В классе B
[01:12:55.000 --> 01:13:00.280]  есть метод F, который принимает int. Казалось бы, это два совершенно разных метода. Один ничего не
[01:13:00.280 --> 01:13:05.000]  принимает второй, принимает int. Но даже в этом случае работает затенение. Даже в этом случае
[01:13:05.000 --> 01:13:12.000]  работает shadowing. Смотрите, я вызываю B F от нуля, вызывается F от int. Все нормально. В классе B есть
[01:13:12.000 --> 01:13:17.800]  метод F от int, он и должен вызываться. Но при попытке вызвать B.F без аргументов у меня внезапно
[01:13:17.800 --> 01:13:23.280]  возникнет ошибка компиляции. И вот это важно понимать, что если у меня и наследники, и предки
[01:13:23.280 --> 01:13:29.000]  есть одни и те же методы, то класс наследника полностью помещает все методы класса A, которые
[01:13:29.000 --> 01:13:33.680]  имеют одно и то же имя. То есть, когда я попытаюсь B вызвать метод F без аргументов, несмотря на то,
[01:13:33.680 --> 01:13:38.320]  что в классе A он есть и он доступен, все равно класс B скажет, погоди, у меня есть свой хороший
[01:13:38.320 --> 01:13:42.080]  метод B, который нужно вызывать с помощью int A. Поэтому без аргументов его вызывать нельзя.
[01:13:42.080 --> 01:13:59.320]  Проблема понятна? Да. Если есть большая иерархия, то тоже можно обращаться B.C или B.A и так далее.
[01:13:59.320 --> 01:14:06.000]  Вот. Эта проблема понятна? Если у вас и в предке, и в наследнике есть метод с одним и тем же именем,
[01:14:06.000 --> 01:14:09.960]  то предпочтение будет обдаваться именно наследнику. Даже несмотря на то, что у вас
[01:14:09.960 --> 01:14:18.360]  сигнатуры методов разные. Вот. Ну тут такой, не знаю, риторический вопрос, логично это или нет. Ну,
[01:14:18.360 --> 01:14:24.480]  с одной стороны, логично, да, потому что если вы в наследнике написали какой-то специфичный метод,
[01:14:24.480 --> 01:14:28.680]  то, наверное, вы имели в виду, что для наследника имеет смысл вызывать именно этот метод, а методы
[01:14:28.680 --> 01:14:33.560]  предка вызывать не имеет смысла. Вот. Ну, с другой стороны, ну, как бы, если методы не пересекаются по
[01:14:33.560 --> 01:14:37.720]  сигнатурам, то, наверное, можно было бы их решить такое. Ну, в общем, так или иначе, мы живем в
[01:14:37.720 --> 01:14:43.440]  реальности, в которой это есть. Вопрос, как с этим бороться. Есть три пути. Первый, это просто
[01:14:43.440 --> 01:14:48.120]  принять как факт, что вот это все работает именно так и стараться не допускать таких ситуаций.
[01:14:48.120 --> 01:14:53.240]  Если путь смирится, это не наш путь, то мы используем пункты 2 и 3. Пункт 2 заключается в следующем.
[01:14:53.240 --> 01:15:00.040]  При вызове используем полное имя метода. Ну, собственно, как и раньше, да, то есть b.a.f. Вот. То есть,
[01:15:00.040 --> 01:15:06.280]  если вы хотите вызвать метод предка, то вы пишете полное имя этого метода. Если это вас не устраивает,
[01:15:06.280 --> 01:15:11.400]  то есть не хочется писать постоянно полное имя метода, то в этом случае можно писать решение с
[01:15:11.400 --> 01:15:19.240]  помощью директивы using. Как мы писали вот тут. Ну, решение, собственно, описано выше. Вот если у
[01:15:19.240 --> 01:15:23.880]  меня есть структура a, в которой описаны методы f, и есть структура b, которая тоже пишет свой метод f.
[01:15:23.880 --> 01:15:29.160]  И, допустим, я хочу, чтобы через структуру b был доступен обычный вызов метода f, который находится
[01:15:29.160 --> 01:15:35.880]  в a. В этом случае я могу написать директивы using. То есть, я пишу using a.a.f. И что это делает? Это
[01:15:35.880 --> 01:15:42.200]  говорит о том, что при вызове метода f у b нужно рассматривать еще и дополнительные методы a. Понятно?
[01:15:42.200 --> 01:15:54.640]  Да. Если они пересекаются, то смотри пункт два. Вот. Нет, нет, там просто будет предпочтение
[01:15:54.640 --> 01:16:11.920]  даваться метод b. Окей? Ну, все. Ну, в общем, что еще раз? Да, да. Так.
[01:16:11.920 --> 01:16:28.480]  Ну, тут вопрос. Либо будет предпочтение даваться b, либо ошибка вариации. Это надо отдельно проверить.
[01:16:28.480 --> 01:16:42.640]  Я точно сейчас не скажу. Так. Все. Последняя проблема. Ну, ладно. Нет, давайте без проблем. Давайте
[01:16:42.640 --> 01:16:49.000]  просто оставим тизер на следующее занятие. Смотрите. Допустим, снова та же самая ситуация.
[01:16:49.000 --> 01:16:56.920]  У меня есть объект b. Короче, у b есть свой метод f, и у a есть свой метод f. Вот. Ну,
[01:16:56.960 --> 01:17:02.080]  у каждого из них своя версия метод f. Вот. У меня есть указатель a, который указывает на
[01:17:02.080 --> 01:17:12.160]  самом деле на объект b. Вот. У меня есть b, который содержит часть, которая относится к a, и часть,
[01:17:12.160 --> 01:17:21.360]  которая относится только к b. Я создаю указатель a, допустим, ptr, и он указывает, и он может указывать
[01:17:21.360 --> 01:17:26.120]  вот на b. Ну, почему? Потому что, так как b является a, то и указатели a, естественно, могут указывать на
[01:17:26.120 --> 01:17:31.400]  объект b. Понятно, да? Ну, смотрите, в b есть часть, которая относится к, вот. Поэтому этот указатель
[01:17:31.400 --> 01:17:37.520]  будет указывать именно на нее. Вот. То есть, смотрите, у меня есть объект b, у меня есть указатель b ptr,
[01:17:37.520 --> 01:17:43.880]  который думает, что он указывает на a. Вот. Потом я пишу b ptr, стрелочка f. В этом случае вызывается
[01:17:43.880 --> 01:17:53.000]  метод a. И вот это поведение может быть уже довольно странным. Почему? Потому что, смотрите, ptr имеет
[01:17:53.160 --> 01:17:59.080]  указатель на a. Вот. Но при этом он указывает на объект типа b. И вот тут возникает вопрос,
[01:17:59.080 --> 01:18:08.000]  что логичней? Опираться на тип указателя или опираться на то, на что на самом деле он указывает?
[01:18:08.000 --> 01:18:15.880]  И вот на самом деле в большинстве ситуаций нам бы хотелось второго поведения. В этой ситуации
[01:18:15.880 --> 01:18:22.720]  нам бы хотелось поступать так. Мы бы хотели, чтобы указатель смотрел на что реально он указывает,
[01:18:22.720 --> 01:18:26.920]  чтобы он мог посмотреть. Я указываю на a или я указываю на b. Если он указывает на a,
[01:18:26.920 --> 01:18:32.080]  он бы вызывал метод f. Если бы он указывал на b, он бы вызывал метод b. Вот. Мы бы хотели,
[01:18:32.080 --> 01:18:37.560]  что в зависимости от этого вызываем метод, вел бы себя по-разному. Вот. Но тут, к сожалению,
[01:18:37.560 --> 01:18:42.760]  в обычном рамках того, что мы с вами сегодня обсудили, к сожалению, в данном примере всегда
[01:18:42.760 --> 01:18:47.960]  будет вызываться метод a. То есть, компилятор всегда будет опираться только на статический тип
[01:18:47.960 --> 01:18:52.600]  указателя. То есть, если есть указатель a, который указывает на b, то равно будет вызываться метод,
[01:18:52.600 --> 01:18:57.800]  который находится в a. Вот. И про то, как это победить, мы с вами поговорим в следующий раз.
[01:18:57.800 --> 01:19:08.360]  А на сегодня вот такое небольшое резюме. На это у меня все. Есть ли вопросы? Нет. Если вы тут
[01:19:08.360 --> 01:19:14.440]  напишете вместо указателя a, то будет указатель на b. Потому что адрес b имеет b указатель.
[01:19:14.440 --> 01:19:18.640]  Все. Спасибо. До встречи в следующем деле.
