[00:00.000 --> 00:19.280]  Продолжаем говорить про динамику. Начнем с вы ворвались в банк. И там есть какие-нибудь,
[00:19.280 --> 00:24.160]  ну обычно это слитки золота, ну или в общем какие-нибудь драгоценности. У каждой драгоценности
[00:24.160 --> 00:31.920]  есть свой вес и своя стоимость. Давайте буду писать о тен предметов, чтобы, так сказать,
[00:31.920 --> 00:43.680]  гендерно-нейтрально было. Значит, этот предмет имеет некий вес W и стоимость.
[00:43.680 --> 00:53.680]  Вот, а пришли в банк вы с одним единственным рюкзаком в вместимости W.
[00:53.680 --> 01:08.480]  W большое. Вместимость рюкзака. Ну и ваша задача, значит, утащить сколько-нибудь предметов так,
[01:08.480 --> 01:12.920]  чтобы они все поместились в ваш рюкзак, ну и суммарная стоимость была как можно больше. То есть
[01:12.920 --> 01:19.520]  вес явным образом на стоимость не влияет. Вес влияет только на то, что вы можете в рюкзак максимум W
[01:19.520 --> 01:24.320]  большое набрать. Вот. И при этом условии, что сумма весов, которые вы взяли не больше, чем W большое,
[01:24.320 --> 01:32.400]  вам нужно набрать максимальную стоимость предметов. Вот. Такая задача. Значит, сразу скажу, что
[01:32.400 --> 01:39.440]  известно, что в такой постановке она является NP трудной. Для нас это значит, что, значит, там я
[01:39.440 --> 01:44.240]  еще тоже чуть-чуть дальше, когда мы будем про графы говорить, там тоже целый пласт задач, которые
[01:44.240 --> 01:51.200]  являются NP трудными, для нас это означает, что пока не мы, никто другой не умеет решать эти задачи за
[01:51.200 --> 01:57.480]  полиномиальное время от размеров хода. Вот. И соответственно лучшее, на что можно надеяться,
[01:57.480 --> 02:03.320]  это что-то там сверхполиномиальное. Значит, дальше мы увидим, что там как бы что-то похоже на полином,
[02:03.320 --> 02:11.040]  но полином там будет зависеть от W явным образом. То есть неформально мы будем для всех возможных
[02:11.400 --> 02:16.480]  частичных замощений этого W большого хранить, какой максимальную стоимость мы можем получить с такой
[02:16.480 --> 02:23.920]  заполненностью рюкзака. Но если ваш алгоритм работает за время пропорциональное W, именно W,
[02:23.920 --> 02:28.680]  то это уже не полиномиальный алгоритм может быть, потому что, ну представьте, у вас там W это что-нибудь
[02:28.680 --> 02:39.480]  типа два в степени 64, и тогда ваш алгоритм работает за два в степени 64. Чтобы написать число два в
[02:39.480 --> 02:46.080]  степени 64, вам нужно всего 65 бит потратить. Получается, что время работы оно экспоненциальное от размера
[02:46.080 --> 02:50.280]  входа. Если вход там 65 бит, а время работает два в степени 64, то это экспоненциальная зависимость.
[02:50.280 --> 02:57.240]  Вот. И так будет у нас, что мы будем зависеть там линейно по W, но само W описывается всего лишь
[02:57.240 --> 03:02.360]  логарифмическим числом бит, чтобы его задать вашей программе, нужен логарифм бит. Итого у нас
[03:02.360 --> 03:07.720]  будет как бы экспонент от логарифма, то есть полином. Вот. Поэтому как бы, вообще говоря,
[03:07.880 --> 03:13.080]  это экспоненциальный алгоритм, но если W маленькое, то это что-то адекватное. Если W порядка тысячи,
[03:13.080 --> 03:17.880]  сотен тысяч и так далее, миллионов возможно, то это какой-то адекватный алгоритм. А в общем случае,
[03:17.880 --> 03:22.280]  если W как-то быстро растет, то время работы это уже будет экспоненциальное, ну и в общем какое-то
[03:22.280 --> 03:34.760]  непозволительное. Ну так вот. Простое решение. Ну тут давайте опять вот эту, скажу, мантру. Вот давайте
[03:34.760 --> 03:38.680]  мы начали набирать предметы. Сколько-то взяли, сколько-то еще не взяли, и какая-то вместимость у нас,
[03:38.680 --> 03:42.680]  соответственно, уже заполнена. Вопрос, что нам нужно знать, чтобы двигаться дальше?
[03:42.680 --> 03:52.600]  Ну, наверное, надо знать, какая емкость рюкзака заполнена, какую мы набрали стоимость, и в каком-то
[03:52.600 --> 03:57.400]  смысле, какие предметы мы уже рассмотрели, какие предметы мы уже взяли или не взяли, и больше их
[03:57.400 --> 04:01.240]  пытаться брать не будем. Но давайте тогда просто идти по всем предметам в порядке увеличения
[04:01.240 --> 04:07.680]  номеров. Первый, второй, третий и так далее, н-ный. И на каждом шаге будем либо брать, либо не брать
[04:07.680 --> 04:17.800]  предмет. Тогда ведем такую динамику. Значит, dp it какой-нибудь, ну пусть будет x. Это максимальная
[04:17.800 --> 04:30.920]  суммарная стоимость предметов. Если мы рассматриваем только первый i из них, значит, если рассматриваем
[04:30.920 --> 04:51.840]  только первый i предметов, ну а их суммарный вес это в точности x. А я напишу так, суммарный набранный
[04:51.840 --> 05:07.040]  вес в точности x. То есть я знаю, какие предметы я уже рассмотрел, первый i. Знаю, что я набрал
[05:07.040 --> 05:12.240]  суммарный вес точности x, и в значении dp у меня будет лежать максимально возможная стоимость,
[05:12.240 --> 05:20.720]  если вот эти все условия выполнены, то какая будет максимальная стоимость. Ну дальше все довольно
[05:20.880 --> 05:25.400]  прозрачно. Значит, база, давайте мы будем идти и заполнять нашу динамику по слоям, то есть порядка
[05:25.400 --> 05:33.680]  увеличения i. Тогда база, это когда i равно нулю. Когда я рассматриваю 0 первых предметов, соответственно,
[05:33.680 --> 05:38.880]  я ничего брать не могу. Единственный способ это взять пустое множество предметов. Тогда у меня стоимость,
[05:38.880 --> 05:44.920]  тогда у меня вес 0 и стоимость тоже 0. Я могу из первых нуля предметов взять ничего, тогда стоимость
[05:44.920 --> 05:54.240]  будет нулевая и вес будет тоже нулевой. А если у меня здесь что-то стоит больше нуля, тогда я такого
[05:54.240 --> 05:59.120]  не могу сделать, я не могу набрать с помощью нуля предметов какой-то положительный вес. И давайте
[05:59.120 --> 06:04.600]  я сюда положу число, которое является нейтральным элементом по функции максимум. То есть, например,
[06:04.600 --> 06:10.680]  минус бесконечность. Я могу сказать, что нет ни одного способа выбрать из первых нуля предметов
[06:10.680 --> 06:15.680]  несколько с положительным весом, поэтому их максимальная суммарная стоимость и минус бесконечность.
[06:15.680 --> 06:23.560]  Такого просто нет. Значит, здесь что-то как раз фиктивное, то, чего набрать нельзя. Ну и дальше
[06:23.560 --> 06:37.600]  переход. Значит, чему равно dp и tx? Я хочу выразить dp и tx через значение dp на предыдущем уровне,
[06:37.600 --> 06:42.400]  то есть через dp и минус первое для каких-то там разных возможных х. Значит, вопрос. Вот смотрите,
[06:42.400 --> 06:52.040]  у меня есть первые и предметов. Я хочу набрать вес х. Давайте посмотрим на и ты предмет и спросим
[06:52.040 --> 06:57.360]  себя, мы его берем в наше множество или нет? Берем ли мы и ты предмет в наше множество, чтобы набрать
[06:57.360 --> 07:03.640]  сумму х? Соответственно, два варианта. Либо берем, либо не берем. Если не берем, то понятно, что здесь
[07:03.640 --> 07:09.920]  можно просто написать dp и минус первое х. Потому что если я знаю, что и ты предмет брать невыгодно,
[07:09.920 --> 07:14.840]  то я просто про него как бы забываю, говорю, что мы его не используем. И задача сводится к тому,
[07:14.840 --> 07:19.800]  чтобы выбрать из первых и минус этого предмета тот же самый вес х. То есть этот случай достигается,
[07:19.800 --> 07:31.280]  если и ты предмет не берем. Тогда, собственно, эти просто значения dp будут равны. Второй случай,
[07:31.280 --> 07:41.240]  когда мы его берем. Если у него был какой-то вес w и, то мне нужно из оставшихся и минус одного
[07:41.240 --> 07:46.600]  набрать вес уже х-w и. Потому что я последний взял, я знаю его вес. Если суммарный вес был х,
[07:46.600 --> 07:53.160]  то из всех предыдущих надо брать вес х-w и. Поэтому здесь я с помощью первых и минус одного предмета
[07:53.160 --> 08:03.440]  пытаюсь набрать вес х-w и, но не забывая добавить сюда плюс ц и. Это случай, если и ты предмет
[08:03.440 --> 08:20.080]  берем. Более-менее все. То есть я либо предмет не беру, тогда просто dp с предыдущего слоя с
[08:20.080 --> 08:25.400]  тем же самым весом. Либо беру, но тогда мне нужно из первых и минус первого предмета и минус
[08:25.400 --> 08:31.400]  одного предмета выбрать уже вот такой вот вес суммарный на w и поменьше. Но при этом к этой dp
[08:31.400 --> 08:39.360]  надо добавить стоимость последнего взятого предмета, стоимости этого предмета. Естественно,
[08:39.360 --> 08:45.200]  я не пишу всяких условий, что вот это должно быть больше или равно нуля. То есть если х-w и меньше
[08:45.200 --> 08:49.240]  чем ноль, то я в принципе не могу рассмотреть такой вариант. То есть я не могу набрать вес меньше
[08:49.240 --> 08:55.640]  чем w и, используя предмет веса w и. Поэтому когда-то это не существует. Этот вариант вообще не
[08:55.640 --> 09:00.120]  рассматривается. Ну и если здесь равно минус бесконечность, если вот это вот это минус бесконечность,
[09:00.120 --> 09:06.480]  то я считаю, что минус бесконечность плюс любая константа тоже минус бесконечность. Ну и в итоге
[09:06.480 --> 09:11.080]  у меня форма перехода будет примерно такая. Вот я здесь её попробую вместить.
[09:11.080 --> 09:40.600]  Вот собственно всё. Ну и соответственно наша динамика вот так работает. Мы сначала подсчитываем
[09:40.600 --> 09:45.960]  все, то есть по всем х подсчитываем dp0х. То есть вот у меня есть нулевой уровень, он так заполнен.
[09:45.960 --> 09:51.080]  И дальше каждый следующий, каждый и-тый уровень я могу посчитать через и минус 1. Вот я вижу,
[09:51.080 --> 10:03.040]  что у меня dp и, то я завис только от dp и минус 1. Всё. Получается асимптотика. По времени это будет
[10:03.040 --> 10:11.520]  видимо n на w, потому что у меня столько состояний динамики. Первый аргумент у меня принимает
[10:11.520 --> 10:15.880]  одно из n значений, ну из n плюс 1 формально, ну неважно. Здесь примерно n значений, здесь
[10:15.880 --> 10:21.720]  примерно w значений. И причем каждая насчитывается через предыдущие золотые еницы. Я просто беру
[10:21.720 --> 10:26.800]  два значения и выбираю из них максимум. Поэтому вообще время работы n на w, вот значит это время.
[10:26.800 --> 10:32.680]  Ну и с памятью здесь можно поступить как обычно. Можно заметить, что у меня и-тый слой зависит
[10:32.680 --> 10:38.200]  только от и минус 1, поэтому память можно не всю динамику хранить, а только последние два слоя.
[10:38.200 --> 10:55.960]  И тогда памяти будет просто от w. Если хранить только предыдущий слой dp и минус 1 и следующий
[10:55.960 --> 11:07.200]  dp и t. Тогда в любое время нам достаточно от w и человек памяти. Постепенно что-то очищается,
[11:07.200 --> 11:14.640]  что-то можно заполнять. Ну или мы можем просто хранить два массива размера w. Сначала считать,
[11:14.640 --> 11:19.160]  что это предыдущий, а это следующий. И следующий заполнять через предыдущий. А потом этот мы
[11:19.160 --> 11:23.800]  можем назначить предыдущим и следующий вычислять через него. То есть у меня можно всего двумя массивами
[11:23.800 --> 11:29.000]  обойтись и их между собой друг друга чередовать. Сначала это предыдущий, это следующий. Я второй
[11:29.000 --> 11:33.480]  высчитываю через первый. Потом наоборот про первый забываю и первый высчитываю через второй. Тогда
[11:33.480 --> 11:37.560]  мне даже не нужно выделять новую память. У меня просто на двух массивах длины w они будут так друг
[11:37.560 --> 11:54.760]  через друга пересчитываться. Окей? Вопрос, где лежит ответ? Еще раз? Неправда. Да, где-то в последней
[11:54.760 --> 12:04.280]  строке. Ответ это максимум по всем возможным х от 0 до w dp nхt. Потому что мы не знаем,
[12:04.280 --> 12:08.680]  сколько на самом деле выгодно всего запихнуть в рюкзак. Возможно не в точности w, а чуть поменьше.
[12:08.680 --> 12:13.560]  Ну и тогда мне нужно просто перебрать, насколько заполнен рюкзак на последнем слое. Ну и выбрать из
[12:13.560 --> 12:17.800]  них максимальное значение dp. Ну понятно, что здесь n, потому что это означает, что я могу брать любые
[12:17.800 --> 12:22.720]  предметы, могу не брать. Когда здесь n, значит я могу любой брать, могу любой не брать. Рассматривать
[12:22.720 --> 12:26.640]  все предыдущие dp-шки бессмысленно, потому что там какие-то предметы заведомо не включены. А здесь
[12:26.640 --> 12:36.920]  можно любой брать или не брать. Так, хорошо. Вот такое решение у нас есть. Давайте второе решение,
[12:36.920 --> 12:49.320]  кратко освещу тоже. Оно меняет местами стоимость и вес. Вот тут я когда проговаривал, что нам нужно
[12:49.320 --> 12:54.920]  знать, чтобы динамику нашу насчитывать, я говорил, что мне нужно знать, сколько предметов мы
[12:54.920 --> 13:00.720]  рассмотрели, какой текущий вес, какая текущая стоимость. И я почему-то в аргумент динамики
[13:00.720 --> 13:06.720]  засунул именно вес. А мог вообще, говоря, поступить наоборот, мог засунуть стоимость. Поэтому я могу
[13:06.720 --> 13:17.000]  написать другое решение. Я из лености буду писать, короче, везде dp. Давайте я веду dp и t от ct.
[13:17.000 --> 13:38.840]  Давайте yt. Значит, это минимальный суммарный вес выбранных предметов. Если опять-таки можно
[13:38.840 --> 13:43.240]  рассматривать только предметы с первого поитой, но при этом их стоимость это y.
[13:43.240 --> 14:04.440]  Если можно выбирать только первый и предметов, а суммарная набранная стоимость это y.
[14:04.440 --> 14:27.720]  Вот. Ну, естественно, это будет работать хоть сколько-то адекватно, если у вас стоимости все
[14:27.720 --> 14:31.840]  маленькие. То есть представьте, что у вас веса у предметов большие, а стоимости маленькие. Ну,
[14:31.840 --> 14:36.320]  там нолики, единички и двойки, например. Вдруг у вас такая задача, что у вас предметы тяжелые,
[14:36.320 --> 14:42.120]  но в среднем мало полезные. Тогда вам как бы, наоборот, хочется, чтобы аргументом динамики было
[14:42.120 --> 14:46.880]  что-то поменьше. Ну, вот давайте стоимость тогда возьмем в качестве аргумента. А значение это будет
[14:46.880 --> 14:52.200]  минимальный суммарный набранный вес. То есть мы поменяли как бы местами вот здесь вот x и y,
[14:52.200 --> 14:55.520]  которое раньше было значением динамики. Если раньше при фиксированном x была максимальная
[14:55.520 --> 15:01.480]  стоимость, то теперь, наоборот, при фиксированной стоимости хотим минимальный вес сделать. Вот.
[15:01.480 --> 15:09.200]  Ну и дальше, собственно, все аналогично. Давайте я просто переход здесь напишу. Значит,
[15:09.200 --> 15:18.480]  чему равно dp i t y t? Тут опять, либо я i-ты предметов вообще не беру, тогда у меня стоимость
[15:19.080 --> 15:27.320]  и вес сохраняется. Поэтому мне нужно просто сюда положить dp i-ты. Это случай, когда i предмет
[15:27.320 --> 15:34.560]  не взят в сумму. Ну и второй случай, когда он взят, тогда у меня с помощью оставшихся и минус одного
[15:34.560 --> 15:46.680]  предмета нужно брать стоимость y-ci, но зато вес растет на w i. Правильно? Ну, собственно,
[15:46.680 --> 15:54.400]  очень-очень похожая формула. По сути, я поменял местами просто веса и стоимости. Вот. И тогда
[15:54.400 --> 16:05.480]  получится решение за... Я напишу n умножить на c большое, где c большое – это стоимость всех предметов.
[16:05.480 --> 16:16.360]  Ну суммарная стоимость, имею в виду сумма всех c маленьких. Вот. И это более смыслно, чем вот это,
[16:16.360 --> 16:23.720]  в случае, когда c меньше mw. Потому что там время работы n на c, а здесь n на w. Понятно,
[16:23.720 --> 16:31.640]  что эффективнее из них тот алгоритм, где меньше вот эта вот константа, c или w. Значит, выгоднее,
[16:31.640 --> 16:58.040]  ну в плане времени работы, если c меньше, чем w. Окей? Так. Чудно. Ну это мы обсудили. Значит,
[16:58.040 --> 17:03.000]  повторюсь, что эти алгоритмы на самом деле не полиномиальные от размера входа. Потому что вот
[17:03.000 --> 17:09.600]  это вот число w, оно может быть настолько большим, что для его задания там достаточно сколько-то бит,
[17:09.600 --> 17:13.720]  а само оно экспоненциально от, собственно, этого количества бит. Если у вас там 65 бит,
[17:13.720 --> 17:21.520]  то значение может быть 2,64. И даже больше. Вот. Ну да, собственно, это я уже проговорил. Ладно,
[17:21.520 --> 17:29.680]  не надо повторяться. Так. Вопрос есть? Хорошо.
[17:29.680 --> 17:57.240]  Значит, еще одно замечание здесь скажу. Здесь опять-таки не работают всякие жадные алгоритмы.
[17:57.240 --> 18:06.120]  Давайте напишу так. Неоптимальность. Будьте здоровы. Жадных алгоритмов.
[18:06.120 --> 18:19.440]  Значит, ну поскольку задача NP трудная, то мы пока не можем надеяться на то, что здесь есть
[18:19.440 --> 18:23.760]  полиномиальный алгоритм. И в частности, любой полиномиальный алгоритм, который я бы мог
[18:23.760 --> 18:28.520]  предъявить, имеет некий контрпример, некий контртест. Но давайте рассмотрим такой алгоритм,
[18:28.520 --> 18:33.280]  который как бы в каком-то смысле действует логично. Значит, давайте мы отсортируем все предметы в
[18:33.280 --> 18:49.280]  порядке удельной полезности. Сортируем предметы по, ну видимо, c делить на w. То есть как бы
[18:49.280 --> 18:56.640]  логично, что выгоднее тот, у кого больше плотность, ну типа стоимость деленной на вес. Тогда их как бы
[18:56.640 --> 19:01.520]  наверное выгоднее всего убрать. Ну будем просто идти по этому списку предметов и брать первые
[19:01.520 --> 19:08.720]  попавшиеся вот, чтобы они не переполнялись за w. Вроде логично такое предположение, что мы
[19:08.720 --> 19:15.800]  предметы берем жадным образом в порядке убывания удельной полезности. Выбираем предметы.
[19:15.800 --> 19:31.000]  Предметы в порядке убывания. Вот, я уже что-то на самом деле не всегда выгодно.
[19:31.000 --> 19:48.880]  Давайте посмотрим почему. Ну, мне приходит в голову какой-то такой пример. Сейчас я что-нибудь
[19:48.880 --> 20:04.640]  нарисую. Значит пусть будет чуть-чуть выгоднее. Нет, плохо, плохо, плохо. А нет, нормально.
[20:18.880 --> 20:32.880]  Вот так. Значит, возможно, не самый удобный пример, но вот мне такой сегодня приснился. Значит,
[20:32.880 --> 20:43.640]  смотрите, я их расположил уже в порядке убывания. Так, глупость, да, сказал. Момент. Да, да, да, я это
[20:43.640 --> 20:48.720]  имел в виду, спасибо. Да, вот так. Теперь они в порядке убывания удельной полезности. То есть здесь
[20:48.720 --> 20:54.360]  плотность чуть больше 1, здесь плотность равна 1. И вот наш наивный алгоритм что делает? Он берет вот
[20:54.360 --> 20:59.720]  это и сразу заканчивается, потому что к нему больше ничего добавить нельзя и получит стоимость
[20:59.720 --> 21:04.880]  1100. А можно сделать похитрее, можно на этот предмет забить, взять вот эти два, рюкзак не
[21:04.880 --> 21:10.840]  переполнится, он полностью заполнится, но не переполнится, а вес будет больше, будет 1100. Профит.
[21:10.840 --> 21:17.640]  То есть этот алгоритм как бы неэффективный. Ну и любые такие жадники, что давайте ассортируем предметы
[21:17.640 --> 21:22.160]  по какому-нибудь компаратору и дальше будем просто брать в порядке убывания полезности. Вот это и вот.
[21:22.160 --> 21:30.200]  Все, которые не переполняют наш рюкзак. Все такие алгоритмы, по крайней мере, на текущий уровень
[21:30.200 --> 21:36.040]  знания человечества не всегда предоставляют правильный ответ, потому что задача НП трудная. И если бы
[21:36.040 --> 21:41.680]  был какой-то такой алгоритм упорядочивания, который соответственно работает за N log N и мы потом
[21:41.680 --> 21:46.360]  бы просто жадно их брали, тогда получается, что мы задачу рюкзака решили бы за N log N за полинальное
[21:46.360 --> 21:51.480]  время, что пока что противоречит тому, что мы знаем о сложности вычислительных задач.
[21:51.480 --> 21:57.960]  Вот. Соответственно, можете попробовать поэкспериментировать дома, если вам внезапно
[21:57.960 --> 22:02.680]  нечего делать, придумать какие-нибудь компараторы, как можно было бы упорядочить предметы и придумать
[22:03.000 --> 22:08.080]  пример, почему это невыгодно. Или внезапно, наоборот, у вас получится доказать, что вы правильно
[22:08.080 --> 22:15.560]  посортировали, когда вы решите задачу за миллион долларов и будете очень крутым. Вот. Всем советую.
[22:33.680 --> 22:48.400]  Так, хорошо. Едем дальше. Следующий блок – это динамика на матрицах. Динамическое программирование.
[22:48.400 --> 23:00.920]  Ну, на матрицах как-то так уже называют обычно, я так же сделаю. Значит, здесь речь пойдет о том,
[23:00.920 --> 23:09.720]  что мы будем пытаться формулу пересчета следующего значения динамики через предыдущие выразить в
[23:09.720 --> 23:19.840]  терминах умножения на матрицу. Пример, самая простая задача. Есть у нас последователь, чисел
[23:19.840 --> 23:37.400]  фибоначи. Задаваем вот таким вот правилом. Мы хотим найти fn для какого-нибудь большого n. Ну да,
[23:37.400 --> 23:55.280]  хотим найти fn для заданного n. Пока давайте в таком виде оставлю. Без подробностей. Понятно,
[23:55.280 --> 23:59.640]  можно за линию просто пройтись, поскладывать два последних числа, получать три следующие и так
[23:59.640 --> 24:06.640]  далее. Но это не интересно. Это мы все умеем. Можно сделать по-другому. Можно заметить выполнение
[24:06.640 --> 24:30.280]  следующего равенства. Все же умеют матрицу умножать, я надеюсь. Но тогда вы согласны с таким вот
[24:30.280 --> 24:36.160]  равенством. А если я нигде не накосячил, то у меня fn это произведение вот такой строки на такой
[24:36.160 --> 24:41.040]  столбец. Это верно, да, сумма двух предыдущих. А fn-1, произведение такой строки на такой столбец,
[24:41.040 --> 24:49.720]  это просто fn-1. Пока все верно. Значит, если я буду продолжать эту логику, то я могу написать вот
[24:49.720 --> 24:59.720]  здесь вот квадрат моей матрицы на столбец, соответственно, на два шага назад. fn-2, fn-3. Ну и так
[24:59.720 --> 25:08.400]  далее. Я могу дойти последним столбцом до моей базы f0, f1. Здесь будет что-то вот такое в степени
[25:08.400 --> 25:26.880]  n-1, f1, f0. Ну вот. Поэтому, чтобы найти n-ый член нашей последовательности, мне нужно всего лишь как-нибудь
[25:26.880 --> 25:32.320]  быстренько возвести вот эту матрицу в степень и умножить на столбец из двух единиц. Давайте я
[25:32.320 --> 25:42.320]  сразу здесь сотру, потому что не из двух единиц, а из единиц и нуля. Вот так. То есть достаточно
[25:42.320 --> 25:46.000]  научиться каким-то образом быстро возводить матрицу в степень. Ну давайте этим займемся.
[25:46.000 --> 26:05.920]  Быстрое или бинарное возведение в степень. Значит, начнем с чисел, но и матрицы тоже научимся
[26:05.920 --> 26:15.920]  так быстро. Идея очень простая. Смотрите, пусть нам надо найти a в степени n. Пока что пусть
[26:15.920 --> 26:26.320]  a это число. Потом подставим матрицу, логика будет та же самая. Значит, два варианта. Если n четное,
[26:26.320 --> 26:39.400]  то мы можем найти a в степени n пополам и возвести его в квадрат. Если же n не четное, то я могу
[26:39.400 --> 26:49.960]  просто одну h отщепить и домножить результат на a в степени n-1. Так, ну давайте еще я для
[26:49.960 --> 26:54.280]  приличия здесь напишу условия выхода из-за рекурсии. Это единица, если n равно нулю.
[26:54.280 --> 27:02.600]  Ну я считаю, конечно, что a изначально не нулевое, потому что начать задача неинтересная. Тогда
[27:02.600 --> 27:10.800]  в нулевой это единица. Вот, собственно, тут написано рекурсивный алгоритм. Пусть у
[27:10.800 --> 27:18.080]  меня есть какая-то функция. Я ее обычно называю binary power. Возможно, логично было называть как
[27:18.080 --> 27:25.200]  binary exp, но неважно. Она принимает два числа a и n, хочет возвести a в степень n, проверяет
[27:25.200 --> 27:33.240]  эти условия. Если n 0, то можно сразу вернуть 1. Если n четное, то он его делит пополам,
[27:33.240 --> 27:39.840]  рекурсивно запускается binary power от a n пополам и возводит результат в квадрат. Если n не четное,
[27:39.840 --> 27:47.560]  то вычитать единицу рекурсивно высчитает вот это и он нажает ответ на a. Ну давайте напишу этот код.
[27:55.200 --> 28:10.000]  Если n четное, то я рекурсивно посчитаю x равное a в степени n пополам и верну x в квадрате.
[28:10.000 --> 28:35.080]  Значит, иначе посчитаю a в степени n минус 1, ну и верну a на x. Вот такой нехитрый алгоритм.
[28:35.080 --> 28:52.260]  Так, согласны с ним? Чудно. За сколько он работает? Почему за алгоритм? Еще раз? Ну вот иногда же на
[28:52.260 --> 29:00.920]  единицу всего лишь. Да, действительно можно заметить, что если мы в какой-то момент уменьшили n на
[29:00.920 --> 29:05.840]  единицу, то в следующий момент мы обязательно поделим пополам. Потому что если здесь n было нечетным,
[29:05.840 --> 29:10.640]  то при уменьшении на единицу он станет четным, и на следующем шаге оно уже будет делиться пополам.
[29:10.640 --> 29:16.840]  Поэтому количество раз, когда мы вычитаем единицу, короче, таких два раза в квадрат быть не может.
[29:16.840 --> 29:19.920]  Потому что если мы из нечетного вышли, 1 стало четным, и потом оно уже делится пополам.
[29:19.920 --> 29:26.080]  Поэтому можно сказать следующее. Из каждых двух последовательных рекурсивных запусков нашей
[29:26.080 --> 29:31.400]  функции, по крайней мере, в одном n делится пополам. Ну а деление пополам может быть максимальным алгоритмом.
[29:31.400 --> 29:37.080]  Если у меня деление пополам возникает, по крайней мере, в каждом втором случае, на те времена
[29:37.080 --> 29:47.520]  работает максимум удвоенный двуичный алгоритм. Так, асимптотика. Получается алгоритмическая.
[29:47.520 --> 29:58.200]  Да, это хороший вопрос. Вот на самом деле большая проблема с тем, как работает умножение.
[29:58.200 --> 30:10.440]  Тут есть два ответа. Первый такой наиболее, хотя сказать наиболее распространен,
[30:10.440 --> 30:14.720]  ну давайте так. В наших задачах, в большинстве, во всяком случае в контестах,
[30:15.400 --> 30:21.280]  надо будет находить ответ по модулю, скажем, p. То есть нам не нужно будет находить само это значение x на x.
[30:21.280 --> 30:27.240]  Достаточно будет найти его остаток определения на p. И тогда уже, если p достаточно маленькое число,
[30:27.240 --> 30:31.480]  тогда нам жить будет сильно легче, потому что после каждого умножения можно брать ответ по модулю p.
[30:31.480 --> 30:36.480]  Вот здесь взяли процент p, вот здесь взяли процент p, ну и так далее. Тогда ответ, как бы, текущая величина
[30:36.480 --> 30:41.040]  никогда не будет больше, чем p. Если я умножаю там два таких числа, два вычета умножаю,
[30:41.040 --> 30:45.240]  и потом беру опять по модулю p. У меня все это всегда будет в каком-то нормальном типе данных.
[30:45.240 --> 30:53.400]  Это, в общем-то, даже в теории довольно неплохой подход. Потому что, если, скажем, вы найдете вот это
[30:53.400 --> 30:59.840]  значение по нескольким разным простым модулям, там avn и по модулю 2, 3, 5 и так далее, по нескольким разным
[30:59.840 --> 31:04.400]  простым модулям, то дальше вы можете просто покидать какое-то время об остатках, восстановить явным образом это число.
[31:04.400 --> 31:09.280]  Но если вам уж надо само это число восстановить, то в принципе из значений по модулям вы можете восстановить
[31:09.360 --> 31:13.920]  само это значение. Другой вопрос, за сколько это работает? Ну, короче, за сколько это точно можно?
[31:15.920 --> 31:23.760]  Вторая идея, да, здесь, если нам нужен ответ в точности, то здесь нужно узнавать, за сколько работает произведение чисел.
[31:23.760 --> 31:28.560]  Ну, это там какой-то аккуратный анализ. Давайте я скажу следующее, что если я возвожу в n-ую степень,
[31:28.560 --> 31:38.760]  то у меня длина в худшем случае умножается максимум на n. Потому что если a это 10 вкатый, то 10 вкатый в степени n
[31:38.760 --> 31:45.640]  и это 10 в степени kn. Длина как раз в n раз увеличилась. Значит, тогда в результате у меня вот здесь вот длины будут
[31:45.640 --> 31:53.640]  полинамиальными по n и время работы будет что-то типа n квадрат на log n, насколько я понимаю. Но это в случае,
[31:53.640 --> 32:00.800]  если мне нужно находить точное значение. На самом деле мы такого делать не будем, то есть скажем так, можно всегда провести
[32:00.800 --> 32:06.480]  анализ того, что если мы хотим находить значение точно, а не по какому-то модулю, можно провести аккуратный анализ,
[32:06.640 --> 32:13.440]  за сколько работают все эти умножения и так далее. Но нам всегда будет достаточно это делать только по какому-то модулю или можем
[32:13.440 --> 32:21.440]  просто считать, что все вот эти вот операции арифметические работают за единицу. Мы будем жить в такой модели, нас это
[32:21.440 --> 32:39.520]  в общем-то нигде стеснять не будет. Теперь к матрицам вернемся. Как умножать матрицы? Ну, собственно, точно так же, если мы хотим
[32:39.520 --> 32:55.760]  найти а в степени n, где а это матрица размера k на k. Матрица k на k. Меняется две вещи всего. Во-первых, надо научиться
[32:55.760 --> 33:02.480]  понимать, что такое а в нулевой. Что такое а в нулевой? Единственная матрица. Да, здесь будет просто единичная матрица размера
[33:02.480 --> 33:14.800]  k на k. И здесь надо научиться понимать, за сколько работают произведения двух матриц аж мира k на k. За сколько? Четырех? Не, ну если на k на k. Нет.
[33:14.800 --> 33:24.440]  Ка-куб, да. Потому что у вас для каждой строки, для каждого столбца вы n произведений считаете. Вот я сказал k на k, я более общую
[33:24.440 --> 33:36.120]  задачу. Ну, давайте это здесь отражу. А в нулевой это матрица, единичная матрица порядка k, то есть на диагонали единички, вне диагонали нули.
[33:36.120 --> 33:52.640]  А перемножаем мы две матрицы. Перемножаем за отка в кубе. Ну, если просто написать форму из определения, там сумма по и сумма по ж и внутри,
[33:52.640 --> 34:04.560]  что сказал? В смысле, там c и t аж и t это сумма по k попарных произведений. Итого у меня три переменные, каждый из которых пробегает n значение,
[34:04.560 --> 34:13.400]  получается кубичка 7 точек. Вот. А канва точно такая же. Если мы закончились в нуле, то надо вернуть единичную. Если четно, делим пополам,
[34:14.280 --> 34:26.280]  если нечетно, единичку отщепляем, рекурсивно считаем а в степени минус 1, умножаем на а. В итоге будет кавкубиналуген.
[34:26.280 --> 34:39.160]  Но опять-таки в предположении, что все риффметические операции работают за вот единицы. Как, например, в случае, если бы нас просили найти ответ по модулю p какому-нибудь.
[34:39.160 --> 34:55.640]  Вот. Ну и тогда все мы смогли научиться находить n число фибоначи, даже не только эда, но и два последних, n и n минус первое, за время q под размер этой матрицы на логарифм от показателя степени.
[34:55.640 --> 35:08.280]  То есть это будет, ну, примерно log n как раз. Поскольку матрица здесь константного размера на 2, соответственно здесь будет множество 8, как бы неявный 8, это константа можно не писать, получается логарифм просто от показателя степени.
[35:08.280 --> 35:15.160]  Понятно? Хорошо.
[35:15.160 --> 35:30.280]  Так, ну и давайте тогда быстро здесь же в догонку еще одну рекурренту напишем и также быстро ее решим.
[35:30.280 --> 35:55.080]  Значит, пусть у меня задна последность как-нибудь так. Ну а 0, какое-нибудь конкретное значение, давайте я напишу здесь x, а 1 это y, а для всех больших ну что-нибудь такое напишу, ну вот пусть, пусть, например, что-то такое.
[35:55.080 --> 36:01.400]  Я хочу просто показать, что все похожие рекурренты можно считать примерно таким же образом.
[36:01.400 --> 36:12.360]  Ну здесь понятно, опять-таки у меня каждый член выражает через два предыдущих, но проблема здесь вот с этой единицей. Откуда нам в матричном умножении взять плюс один?
[36:12.360 --> 36:22.600]  Прибавить кого? Да, да, да. Мы так-так и сделаем.
[36:22.920 --> 36:35.480]  Я сделаю следующее. Просто напишу единичку в конце. Пересчитаем столбец, допишу единицу, выражаю этот столбец через предыдущий того же вида.
[36:38.120 --> 36:48.680]  Ну здесь уже все будет смотреться нормально. Здесь будет лямбда мю единица, здесь будет единица 0,0, здесь будет 0,0,1. Профит.
[36:52.600 --> 37:14.360]  Если я сделаю такое же преобразование минус один раз, то у меня вот этот столбец выразить через исходный столбец, а 1, а 0, sorry, наоборот, видимо, ух, а 1, а 0, единица.
[37:15.080 --> 37:23.080]  Получается, что мы смогли выразить n-ый член через первое путем умножения на матрицу какого-то размера.
[37:23.080 --> 37:36.680]  Ну и, в общем, если здесь формула какого-то достаточно приятного вида, то можно так всегда расширить этот столбец вот этих хранимых величин, чтобы на следующем уровне можно было посчитать путем умножения на матрицу просто слева.
[37:36.680 --> 37:38.680]  Перев.
[37:39.000 --> 37:51.000]  Так, ну что, давайте дальше продолжать. Следующую задачу, которую мы хотим рассмотреть, формулирую следующим образом.
[37:51.320 --> 38:07.320]  Представьте себе, что у вас есть граф, граф задней какой-то матрице смежности, ну и давайте считать, что в нем, например, кратных ребер нет.
[38:07.320 --> 38:17.320]  То есть у вас есть там какие-то точки, есть какие-то стрелочки между ними, давайте считаем, что граф ориентированный, то есть у меня есть некие ребра между какими-то парами вершин.
[38:17.640 --> 38:19.640]  Вот.
[38:19.640 --> 38:33.640]  И мы хотим посчитать, сколько есть путей из и в жи для некоторой конкретной пары городов, для некоторых конкретных пар точек, найти количество путей длины какой-нибудь.
[38:33.960 --> 38:51.960]  Дан граф, надо найти количество путей длины к из и в жи.
[38:51.960 --> 38:59.960]  Ну, путь длины к, это вы начали в и, вам нужно пройти ровно к ребер и закончится в жи.
[39:00.280 --> 39:06.280]  Давайте здесь попишу, что длины ровно к, длина ровно к, ну вот такая задача.
[39:06.280 --> 39:16.280]  Вы турист, вы хотите гулять ко дней, начать, не знаю, в гостинице, закончить в аэропорту, чтобы улететь отсюда.
[39:16.280 --> 39:20.280]  Вам надо узнать, сколько у вас есть потенциальных маршрутов.
[39:20.280 --> 39:28.280]  Причем нет ограничений на то, что локации, которые вы посчитаете, обязательно различны, вы вполне можете ходить в одно и то же место несколько раз.
[39:28.280 --> 39:56.600]  Сначала простая динамика, пусть у нас фиксирована точка i, пусть dp в этой, ну пусть будет n, это количество путей из i в длины ровно n.
[39:58.600 --> 40:08.600]  То есть, если я прошел какое-то ограниченное количество путей, sorry, ребер, например n ребер прошел,
[40:08.600 --> 40:12.600]  мне нужно знать, где мы закончились и, соответственно, сколько способов было там закончиться.
[40:12.600 --> 40:16.600]  Сколько способов закончиться в конкретном городе, пройдя конкретное число ребер.
[40:16.600 --> 40:26.600]  Ну и здесь есть очень простая форма, давайте только их местами поменяю, не знаю зачем, но мне хочется.
[40:28.600 --> 40:34.600]  Да, это я не сказал, но граф не взвешен и все ребра одинаковые, имеют вес 1.
[40:34.600 --> 40:40.600]  Значит, формула пересчета, ну очень простая.
[40:40.600 --> 40:46.600]  Если я хочу с помощью n плюс одного ребра закончиться в городе v,
[40:46.600 --> 40:51.600]  то давайте рассмотрим последнее ребро, вот есть v, вот есть все входящие в него ребра.
[40:51.600 --> 40:54.600]  Как я могу закончить путь длины n плюс 1 в v?
[40:54.920 --> 41:00.920]  Это значит, что мне нужно построить путь длины n, заканчиваться в одной из этих вершинок и потом пройти это ребро.
[41:00.920 --> 41:09.920]  Поэтому здесь можно просто написать сумму по всем ребрам u, v нашего графа,
[41:09.920 --> 41:11.920]  то есть по всем входящим стрелочкам в нашу вершину.
[41:11.920 --> 41:14.920]  Надо просто сложить dp, n, ut.
[41:14.920 --> 41:20.920]  Мне нужно сначала добраться до вершинки u за n шагов, потом еще с помощью одного ребра попасть в v.
[41:21.240 --> 41:27.240]  Значит, понятна формула?
[41:27.240 --> 41:38.240]  Вот, ну и здесь видим, на самом деле, обычно самые популярные задачи на вот эту вот матричную оптимизацию,
[41:38.240 --> 41:43.240]  они тогда, когда у вас, ну когда вы считаете какое-нибудь количество способов,
[41:43.240 --> 41:47.240]  то есть тогда, когда у вас формула пересчета, это просто какая-нибудь сумма,
[41:47.560 --> 41:51.560]  сумма произведений, например, ну или здесь в этом случае просто сумма.
[41:51.560 --> 41:57.560]  Тогда мы можем на самом деле выразить каждый следующий слой через предыдущий опять-таки до умножения на матрицу.
[41:57.560 --> 42:03.560]  Я могу написать вот такой большой столбец,
[42:03.560 --> 42:08.560]  где первый аргумент это n минус 1, а второй аргумент все возможные вершины.
[42:08.880 --> 42:18.880]  Ну давайте я, так, давайте я занумирую все вершины числами от 0 до v минус 1, видимо.
[42:18.880 --> 42:24.880]  Нет, давайте от 1 до v, или не писать v минус 1.
[42:24.880 --> 42:32.880]  Значит, вот есть v большое, v большое – это количество вершин в графе.
[42:33.200 --> 42:39.200]  Вот есть такой столбец, есть аналогичный столбец предыдущего слоя,
[42:39.200 --> 42:45.200]  то есть dpn первая, и так далее, dpn vt.
[42:45.200 --> 42:53.200]  Вопрос, на что нужно домножить предыдущий столбец, чтобы получить следующий?
[42:53.200 --> 42:59.200]  Что будет являться нашей матрицей?
[42:59.520 --> 43:02.520]  Да, на самом деле просто матрица смежности.
[43:02.520 --> 43:08.520]  То есть у меня в i житом элементе, так давайте i ж у меня уже занято,
[43:08.520 --> 43:11.520]  давайте в x там y там элементе,
[43:11.520 --> 43:15.520]  будет располагаться единица, если есть ребро из x в y.
[43:15.520 --> 43:23.520]  Да, вот это вот давайте назову mxt yt ровно единица,
[43:23.840 --> 43:31.840]  если есть ребро из x в y, ну и ноль иначе.
[43:35.840 --> 43:39.840]  Это называется матрица смежности.
[43:44.840 --> 43:45.840]  Почему это верно?
[43:45.840 --> 43:47.840]  Давайте просто по определению проверим.
[43:47.840 --> 43:49.840]  Перемножим матрицу на столбец, проверим, что получится.
[43:50.160 --> 43:56.160]  Заберем x-ую строчку здесь, dp n plus 1 xt.
[43:59.160 --> 44:04.160]  Чтобы его получить, мне нужно умножить x-ую строчку отсюда на первый столбец здесь.
[44:04.160 --> 44:07.160]  Что такое произвление x-ой строчки на вот это?
[44:07.160 --> 44:09.160]  Ну давайте напишу формулу.
[44:09.160 --> 44:15.160]  Это сумма по всем y, mxy на dp n y.
[44:15.480 --> 44:19.480]  Что-то не так, да?
[44:21.480 --> 44:24.480]  Сейчас, видимо, наоборот сделать.
[44:29.480 --> 44:34.480]  Это x из x в y, а мне нужно как бы обратить.
[44:34.480 --> 44:38.480]  Ну понятно, потому что здесь в каком-то смысле у меня обратный граф рассматривается,
[44:38.480 --> 44:41.480]  поэтому здесь я давайте местами поменяю стрелку.
[44:45.480 --> 44:49.480]  Ну это то же самое, что матрица смежности обратного графа.
[44:49.480 --> 44:53.480]  Я инвертировал направление всех ребер, изменив xy на yx.
[44:53.480 --> 44:57.480]  Вот, тогда такая сумма это в точности dp n plus 1 x.
[44:57.480 --> 45:01.480]  Потому что я суммирую по всем как бы предыдущим решинам на пути.
[45:01.480 --> 45:03.480]  Здесь либо 1, либо 0.
[45:03.480 --> 45:05.480]  1 если ребро есть, 0 если ребра нет.
[45:05.480 --> 45:10.480]  И умножается на dp, сколько способов есть попасть сюда за n шагов.
[45:10.480 --> 45:14.480]  Получается, что здесь как раз каждая слагаемая в этой сумме,
[45:14.480 --> 45:19.480]  это либо 0, если нет ребра из y в x, либо в точности это dp, если такое ребро есть.
[45:19.480 --> 45:23.480]  Получается, в точности вот эта штука равна в точности вот этой вот.
[45:23.480 --> 45:25.480]  Согласны?
[45:25.480 --> 45:31.480]  Вот, давайте напишем, что это dp n plus 1 x.
[45:33.480 --> 45:35.480]  Ну все.
[45:35.480 --> 45:39.480]  Получили выражение n plus первого славца через n-ый,
[45:39.480 --> 45:41.480]  путем домножения на матрицу смежности.
[45:41.480 --> 45:43.480]  И значит, если нам внезапно нужно...
[45:48.480 --> 45:54.480]  Если нам нужно найти какое-то там количество путей из y в z длины ровно k,
[45:54.480 --> 45:57.480]  то мне нужно просто эту матрицу зазвести в k ту степень,
[45:57.480 --> 46:00.480]  получится выражение через то, что нужно.
[46:03.480 --> 46:07.480]  Опять-таки, получили стандартные выражения нового слоя через предыдущий,
[46:07.480 --> 46:09.480]  путем домножения на матрицу.
[46:09.480 --> 46:13.480]  Нужно бинарного зазвести в нужную степень и домножить на базовый столбец,
[46:13.480 --> 46:15.480]  где это, скажем, n равно 0.
[46:15.480 --> 46:17.480]  Вот, может действовать так.
[46:17.480 --> 46:19.480]  Давайте я немножко переформулирую.
[46:19.480 --> 46:21.480]  Будет несколько более удобно.
[46:21.480 --> 46:25.480]  Давайте я это назову все-таки m reverse,
[46:25.480 --> 46:27.480]  потому что это была матрица обратного графа.
[46:29.480 --> 46:33.480]  Давайте я веду обычную нормальную матрицу смежности.
[46:39.480 --> 46:45.480]  И я утверждаю, что можно вообще обойтись без всякой динамики,
[46:45.480 --> 46:51.480]  без dp, а просто возведить вот эту матрицу в степень,
[46:51.480 --> 46:55.480]  и ее элементы будут сущностью показывать то, что мне нужно.
[46:55.480 --> 47:02.480]  Я утверждаю, что m в степени k в позиции x, y
[47:02.480 --> 47:05.480]  это то самое количество путей длины ровно k из x, y.
[47:09.480 --> 47:23.480]  Можно даже динамику всю не считать, а просто возводить матрицу в степень,
[47:23.480 --> 47:26.480]  и в ней будут не только лежать все пути из i до всех остальных,
[47:26.480 --> 47:31.480]  а вообще все попарные количество путей из x, y для любого x и y.
[47:31.480 --> 47:38.480]  Почему это верно?
[47:38.480 --> 47:41.480]  Давайте доказывать по индукции.
[47:41.480 --> 47:45.480]  Индукция по k.
[47:45.480 --> 47:50.480]  Ну, база, например, k равно нулю.
[47:50.480 --> 47:55.480]  Тогда m в нулевой это единичная матрица.
[47:55.480 --> 48:02.480]  И понятно, что это отражается в точности число путей длины 0
[48:02.480 --> 48:04.480]  для каждой пары вершин.
[48:04.480 --> 48:09.480]  Число путей длины 0 это единица, если x равно y, то есть на диагонали единицы.
[48:09.480 --> 48:12.480]  А если x не равно y, то путей длины 0 между ними нет,
[48:12.480 --> 48:15.480]  поэтому в ней диагонали все нули.
[48:15.480 --> 48:19.480]  Поэтому с базой все окей.
[48:19.480 --> 48:21.480]  Начну переход.
[48:21.480 --> 48:28.480]  Пусть m вкатый отражает количество путей длины k.
[48:28.480 --> 48:41.480]  Отражает количество путей длины k.
[48:41.480 --> 48:49.480]  Ну, что такое m в степени k плюс 1?
[48:49.480 --> 48:57.480]  Давайте рассмотрим какой-то конкретный элемент нашей матрицы x и y.
[48:57.480 --> 49:05.480]  Скажем, что m в степени k плюс 1 это m в степени k умножить на m.
[49:05.480 --> 49:09.480]  Отказывается работать со мной.
[49:17.480 --> 49:23.480]  Ну и дальше по формуле произвления матриц я напишу, что и x, y элемент здесь.
[49:23.480 --> 49:27.480]  Эта сумма по всем, например, z.
[49:28.480 --> 49:35.480]  Элемент x, z первой матрицы умножить на элемент z, y второй матрицы.
[49:41.480 --> 49:45.480]  Просто определение произвения матрицы.
[49:45.480 --> 49:53.480]  То есть я перебираю промежуточную столбец в первой матрице x, z в этой матрице
[49:53.480 --> 49:57.480]  и потом z, y во второй матрице перемножаю и по парам складываю.
[49:57.480 --> 50:03.480]  А это в точности, если я знаю, что вот это число путей длины k из x в z.
[50:03.480 --> 50:07.480]  То есть я сначала пытаюсь добраться до z с помощью k-ребер
[50:07.480 --> 50:11.480]  и потом с помощью одного ребра пытаюсь добраться из z в y.
[50:11.480 --> 50:15.480]  Но это в точности число путей длины k плюс 1 x в y.
[50:15.480 --> 50:20.480]  Потому что любой путь из x в y длины k плюс 1 устроен ровно так.
[50:20.480 --> 50:25.480]  Мы сначала фиксируем какую-то предпоследнюю вершину z такую, что есть ребро из z в y.
[50:25.480 --> 50:28.480]  То есть вот здесь вот это множество появляется, 1 или 0.
[50:30.480 --> 50:34.480]  А до этого я должен был из x попасть в z ровно за k шагов.
[50:34.480 --> 50:38.480]  И по предположению индукции вот эта штука отражает ровно это самое количество.
[50:38.480 --> 50:43.480]  m в степени k в точке x, z это как раз таки количество путей длины ровно k из x в z.
[50:44.480 --> 50:56.480]  Поэтому эта сумма в точности и есть число путей из x в y длины ровно k плюс 1, что и требовалось.
[51:07.480 --> 51:11.480]  Вроде победа. Вроде победа мы доказали наше утверждение.
[51:11.480 --> 51:14.480]  А значит теперь вот эту задачу мы могли бы решать вот так.
[51:14.480 --> 51:18.480]  Мы можем просто взять матрицу смежности нашего графа,
[51:18.480 --> 51:23.480]  возвести ее в катую степень и вывести элемент на предширение 1040 ежитого столбца.
[51:23.480 --> 51:31.480]  То есть вот это вот количество это просто m в степени k в точке ежи. Победа.
[51:31.480 --> 51:37.480]  А возводить матрицу степень мы уже умеем, мы знаем, за сколько это делается, мы умеем это делать.
[51:37.480 --> 51:44.480]  Нам для этого нужно времени куб от размера матрицы, куб от порядка матрицы на логарифм показателя степени.
[51:44.480 --> 51:49.480]  То есть время работы будет что-то в стиле v куб умножить на лог k.
[51:49.480 --> 51:56.480]  v куб от произведения матрицы самой на себя, логарифм от собственного возведения в степень бинарного.
[51:56.480 --> 52:02.480]  Вот. Нормально?
[52:02.480 --> 52:09.480]  Логарифм от бинарного возведения, вам нужно m возвести в катую степень,
[52:09.480 --> 52:16.480]  у вас там примерно логарифм итерации, на каждой итерации вы перемножаете матрицу,
[52:16.480 --> 52:19.480]  ну там две матрицы размера v от работы dv куб.
[52:19.480 --> 52:29.480]  Да. Нет? Все нормально?
[52:29.480 --> 52:42.480]  Чудно.
[52:42.480 --> 52:48.480]  Тогда следующая задача.
[52:48.480 --> 53:00.480]  То же самое, только найти количество путей длины не больше чем k.
[53:00.480 --> 53:12.480]  Мы из x в y длины не больше чем k.
[53:12.480 --> 53:18.480]  Не ровно k, а не больше, чем k.
[53:18.480 --> 53:24.480]  Если у вас какие-нибудь идеи, как это можно нормально было бы решать?
[53:24.480 --> 53:28.480]  По всеми же по всем. На самом деле мы так и будем делать, просто будем это делать довольно хитро,
[53:28.480 --> 53:33.480]  но мы же не можем все матрицы посчитать, их будет довольно много.
[53:33.480 --> 53:36.480]  Но мы будем на самом деле ровно этим заниматься.
[53:36.480 --> 53:44.480]  И мы сможем себя бинарно, собственно, считать все степени матрицы, сумму всех степеней матрицы.
[53:44.480 --> 53:49.480]  Может расширить два раза.
[53:49.480 --> 53:52.480]  Шину матрицы и зачем?
[53:52.480 --> 54:02.480]  Чтобы хранить большее состояние, хранить и предыдущее состояние, которое меньше равно k и ровно k.
[54:02.480 --> 54:08.480]  Сейчас подумаю.
[54:08.480 --> 54:14.480]  Боюсь, что тогда вы два раза что-нибудь можете посчитать, потому что...
[54:14.480 --> 54:22.480]  Сейчас, я понял мысль.
[54:22.480 --> 54:27.480]  Боюсь, что вы как раз что-то можете два раза посчитать, потому что когда вы перемножаете,
[54:27.480 --> 54:33.480]  вы берете путь длины меньше k, умножаете на количество путей длины меньше чем k, вы получаете два раза посчитать на одно и то же,
[54:33.480 --> 54:39.480]  потому что можно путь разбить там. Путь длины меньше чем k можно представить как сумму двух путей меньше чем k половым,
[54:39.480 --> 54:47.480]  многими способами. Поэтому скорее всего там что-то посчитается несколько раз. Я думаю так.
[54:47.480 --> 54:51.480]  А сумму степеней матрицы можно попорно сумму тех кишек?
[54:51.480 --> 54:54.480]  Нельзя, потому что может быть необратимая.
[54:54.480 --> 55:04.480]  На самом деле у нас любая матрица может быть матрица графа, поэтому не обязательно совсем.
[55:04.480 --> 55:14.480]  Ну давайте посмотрим. Смотрите. Действительно здесь мы знаем, что m в степени k
[55:14.480 --> 55:22.480]  это количество путей ровно k, количество путей длины ровно k.
[55:22.480 --> 55:30.480]  Поэтому нам как бы хочется посчитать сумму степеней m в нулевой, m в первой и так далее, m в степени k
[55:30.480 --> 55:38.480]  и найти значение этой матрицы в точке x, y. Нужно найти x, y элемент этой матрицы.
[55:38.480 --> 55:45.480]  Это уже верно, потому что мы знаем, что каждая конкретная матрица это количество путей какой-то конкретной длины.
[55:45.480 --> 55:49.480]  Когда мы все сложим, мы получим все возможные пути всех длин.
[55:49.480 --> 55:53.480]  Действительно можно было бы сказать, что это геометрическая прогрессия.
[55:53.480 --> 56:05.480]  И сделать вывод о том, что ее сумма это что-то типа... Ой, никогда не умел.
[56:05.480 --> 56:11.480]  Сделаю вот так.
[56:11.480 --> 56:19.480]  Да? Ну, казалось бы, а почему она обратимая?
[56:19.480 --> 56:24.480]  Фиг знает, может и нет.
[56:24.480 --> 56:30.480]  Потому что при умножении на вот эту сумму дает, собственно, вот это.
[56:30.480 --> 56:42.480]  Нет, ну подождите. Все-таки обратимая к вот этой матрице такая, что g на x для любого x...
[56:42.480 --> 56:46.480]  Нет, ладно, глупо сказал.
[56:46.480 --> 56:52.480]  Ну да, нет, еще раз, g это обратная к −e, если g на −e это единичная. Почему она существует?
[56:52.480 --> 56:57.480]  На самом деле так нельзя делать, потому что в общем случае она необратимая.
[56:57.480 --> 57:01.480]  Поэтому мы так ее и не будем.
[57:01.480 --> 57:14.480]  Но мы научимся обобщать наш алгоритм бинародного задания в степень, чтобы он насчитывал не только степень, но и как бы сумму всех степеней.
[57:14.480 --> 57:25.480]  Сейчас мы это сделаем.
[57:25.480 --> 57:37.480]  Смотрите, раньше у меня был алгоритм binary power, который брал матрицу, брал степень и находил a в степени n.
[57:37.480 --> 57:46.480]  Теперь я хочу этот алгоритм немножко подхачивать, так чтобы он возвращал не только a в степени, но и сумму всех степеней со 0 по a в степени n.
[57:46.480 --> 57:49.480]  Давайте я его назову f.
[57:49.480 --> 58:02.480]  Значит, эта штука будет возвращать мне пару a n и сумму всех степеней матрицы с 0 по n.
[58:02.480 --> 58:06.480]  Осталось научиться такой алгоритм делать.
[58:06.480 --> 58:14.480]  Но здесь формулы перешеда будут очень похожие, потому что, смотрите, давайте рассмотрим базовые случаи, как вся n равна 0.
[58:14.480 --> 58:23.480]  Тогда у вас здесь единичная матрица, здесь единичная матрица, тут все понятно.
[58:23.480 --> 58:37.480]  Дальше, если она нечетна, то мы хотим посчитать f от a n через f от a n-1.
[58:37.480 --> 58:45.480]  Но тут все просто, если нам известно a в степени n-1 и сумма матриц от a в 0 до a в степени n-1,
[58:45.480 --> 58:53.480]  то чтобы получить вот это, нам нужно первый аргумент пары домножить на a и его добавить к второму элементу пары.
[58:53.480 --> 59:00.480]  Если нам известно a в степени n-1 и сумма всех степеней от 0 до n-1, мы сначала первый элемент пары домножаем на a,
[59:00.480 --> 59:06.480]  получаем a в степени n, и потом его добавляем сюда, получаем сумму от a в 0 до a в степени n.
[59:06.480 --> 59:08.480]  Понятно?
[59:08.480 --> 59:17.480]  Так, ладно, давайте тогда напишем. Пусть вот это вот x, вот это вот y,
[59:17.480 --> 59:28.480]  тогда здесь мы возвращаем x умножить на a, а здесь y плюс x умножить на a.
[59:28.480 --> 59:36.480]  То есть я рекурсивно, в случае нечетного n, я рекурсивно запускаюсь от той же матрицы a и n-1.
[59:36.480 --> 59:43.480]  Она возвращает мне две матрицы x и y, такие что x это a в степени n-1, а y это сумма степеней от 0 до n-1.
[59:43.480 --> 59:50.480]  Теперь, чтобы посчитать a в степени n, мне достаточно x умножить на a, потому что они отличаются просто на одну степень a.
[59:50.480 --> 59:56.480]  Поэтому первый элемент пары здесь это x умножить на a, а второй, это что такое?
[59:56.480 --> 01:00:03.480]  Мне нужно вот сюда вот добавить a в степени n, но a в степени n у меня уже есть, я ее просто добавляю в конец, получаю то, что надо.
[01:00:03.480 --> 01:00:13.480]  Так, это простой случай, теперь случай четного n, n четно.
[01:00:13.480 --> 01:00:20.480]  Но опять я хочу научиться считать f a n через f a n пополам.
[01:00:20.480 --> 01:00:27.480]  Пусть мы рекурсивно посчитали, запустили, оно нам что-то выдало, мы знаем a в степени n пополам
[01:00:27.480 --> 01:00:36.480]  и сумму всех матриц от a в степени 0 до a в степени n пополам.
[01:00:36.480 --> 01:00:41.480]  Но опять, пусть вот это x, это y.
[01:00:41.480 --> 01:00:48.480]  Значит, что делать с первым элементом пары понятно, надо просто вернуть x в квадрате, то есть x умножить на x.
[01:00:48.480 --> 01:00:55.480]  Но тут ничего хитрого нет, у этого мы уже делали, чтобы получить a в степени n из a в степени n пополам, надо просто его вывести в квадрат.
[01:00:55.480 --> 01:00:58.480]  x на x умножить, это будет a в степени n.
[01:00:58.480 --> 01:01:05.480]  Вот, чуть похитрее дело вот с этой суммой.
[01:01:05.480 --> 01:01:11.480]  y плюс x, y. Ну да.
[01:01:11.480 --> 01:01:14.480]  Ну, мне придется по крайней мере.
[01:01:14.480 --> 01:01:25.480]  Давайте я вот так вот сделаю.
[01:01:25.480 --> 01:01:30.480]  Я напишу сумму, которую хочу получить.
[01:01:30.480 --> 01:01:34.480]  Разобью на 2 подотрезка.
[01:01:34.480 --> 01:01:39.480]  Из второго вынесу a в степени n плюс 1 пополам.
[01:01:39.480 --> 01:01:49.480]  Ой.
[01:01:49.480 --> 01:01:56.480]  Еще раз?
[01:01:56.480 --> 01:01:59.480]  Где, где?
[01:01:59.480 --> 01:02:02.480]  Нет, sorry, я не понимаю, дайте я сделаю.
[01:02:02.480 --> 01:02:05.480]  Я на слух x на y не воспряму.
[01:02:05.480 --> 01:02:11.480]  Сейчас, что-то тут было проще же, нет?
[01:02:11.480 --> 01:02:13.480]  Мне не нравится, что у меня...
[01:02:13.480 --> 01:02:15.480]  А, не, все нормально, все нормально.
[01:02:15.480 --> 01:02:17.480]  Я вот здесь a в степени n пополам вынесу, все ок.
[01:02:17.480 --> 01:02:19.480]  Значит, смотрите, вот это будет...
[01:02:19.480 --> 01:02:23.480]  Это я оставлю, а здесь вынесу a в степени n пополам.
[01:02:23.480 --> 01:02:25.480]  Все, норм, я победил.
[01:02:25.480 --> 01:02:31.480]  Значит, останется a в первой, a во второй и так далее a в степени n пополам.
[01:02:31.480 --> 01:02:36.480]  Потому что здесь, если я вынес из a в степени n а в степени n пополам множителем, то остается а в степени n пополам.
[01:02:36.480 --> 01:02:44.480]  То есть тут у меня получилось почти то же самое, что здесь за вычетом a в нулевой, что есть единичная матрица.
[01:02:44.480 --> 01:02:54.480]  Поэтому я могу переписать, что у меня написано здесь y, здесь написано x, а здесь написано y минус e.
[01:02:54.480 --> 01:02:56.480]  Я смог.
[01:02:58.480 --> 01:03:00.480]  Правда?
[01:03:02.480 --> 01:03:04.480]  Ну все.
[01:03:04.480 --> 01:03:07.480]  Тогда я могу написать, что второй элемент пары это вот то безобразие.
[01:03:07.480 --> 01:03:10.480]  y плюс x на y минус e.
[01:03:12.480 --> 01:03:14.480]  Конец.
[01:03:16.480 --> 01:03:21.480]  Да, конечно, со симпатикой все то же самое, потому что опять-таки у меня работает как бинарное воздействие в степень.
[01:03:21.480 --> 01:03:27.480]  То есть на нечетных я делаю минус 1, на черных делю пополам, поэтому глубина рекурсии будет логарифмическая.
[01:03:27.480 --> 01:03:32.480]  А на каждом шаге я умножаю и складываю матрицы.
[01:03:32.480 --> 01:03:35.480]  Умножение работает за куб от размера матрицы.
[01:03:35.480 --> 01:03:39.480]  Сколько я делаю неважно, главное, что константное количество.
[01:03:39.480 --> 01:03:44.480]  Поэтому все это работает опять-таки за куб размера матрицы умноженного логарифма показателя степени.
[01:03:51.480 --> 01:03:53.480]  Хорошо.
[01:03:53.480 --> 01:03:55.480]  Все.
[01:03:55.480 --> 01:03:57.480]  Ну и за кольцу.
[01:03:57.480 --> 01:04:01.480]  Если мы научились вот это вот делать, то мы научились решать вот эту задачу.
[01:04:01.480 --> 01:04:03.480]  Потому что мы научились считать вот это.
[01:04:03.480 --> 01:04:09.480]  И дальше надо просто вывести элемент на першине х из страхи у столбца.
[01:04:09.480 --> 01:04:13.480]  Так. Что-то как-то я быстро все рассказал.
[01:04:13.480 --> 01:04:16.480]  Ну давайте еще такой сюжет.
[01:04:16.480 --> 01:04:18.480]  Тоже вокруг этого.
[01:04:18.480 --> 01:04:20.480]  Задача.
[01:04:24.480 --> 01:04:26.480]  Так.
[01:04:26.480 --> 01:04:30.480]  Давайте я для простоты опять-таки буду считать пути длины ровно к.
[01:04:30.480 --> 01:04:34.480]  Но спрошу себя более простой вопрос.
[01:04:34.480 --> 01:04:38.480]  А именно, не количество путей, а просто есть ли путь длины ровно к.
[01:04:38.480 --> 01:04:44.480]  Есть ли путь из х в у?
[01:04:44.480 --> 01:04:46.480]  Нет.
[01:04:46.480 --> 01:04:50.480]  А есть ли путь из х в у?
[01:04:50.480 --> 01:04:52.480]  Нет.
[01:04:52.480 --> 01:04:58.480]  Есть ли путь из х в у?
[01:04:58.480 --> 01:05:00.480]  Длины ровно к.
[01:05:04.480 --> 01:05:08.480]  Значит, ну понятно. Можно было бы просто найти их количество и сравнить с нулем.
[01:05:08.480 --> 01:05:10.480]  Ну, можно сделать, но это не интересно.
[01:05:10.480 --> 01:05:14.480]  Я хочу проиллюстрировать сейчас определенную технику.
[01:05:14.480 --> 01:05:16.480]  Можно там, ну типа да.
[01:05:16.480 --> 01:05:18.480]  Можно сделать, чтобы лучше было.
[01:05:18.480 --> 01:05:22.480]  Сейчас скажу.
[01:05:22.480 --> 01:05:24.480]  Значит, смотрите.
[01:05:24.480 --> 01:05:26.480]  Что можно делать?
[01:05:26.480 --> 01:05:32.480]  Давайте мы будем считать не количество, а факт наличия.
[01:05:32.480 --> 01:05:36.480]  То есть будем считать не количество путей, а просто узнавать есть путь или нет.
[01:05:36.480 --> 01:05:39.480]  Тогда, собственно, наша динамика тоже пересчитана.
[01:05:39.480 --> 01:05:41.480]  Давайте я напишу пересчет динамики.
[01:05:41.480 --> 01:05:43.480]  Вот пусть, как проверить, что есть путь.
[01:05:43.480 --> 01:05:45.480]  Давайте я сначала напишу.
[01:05:46.480 --> 01:05:54.480]  Это значит есть ли путь из х в у длины n.
[01:05:54.480 --> 01:05:56.480]  То есть это просто единица или ноль.
[01:05:56.480 --> 01:05:58.480]  Единица если есть, ноль если нет.
[01:05:58.480 --> 01:06:00.480]  Булисский флаг.
[01:06:00.480 --> 01:06:08.480]  Тогда, смотрите, я могу написать выражение для n плюс 1v
[01:06:08.480 --> 01:06:12.480]  через дизъюнкцию следующих конъюнкций.
[01:06:15.480 --> 01:06:17.480]  То есть по всем последним ребрам.
[01:06:17.480 --> 01:06:19.480]  Нет, просто дизъюнкцию.
[01:06:19.480 --> 01:06:21.480]  Давайте я напишу так.
[01:06:21.480 --> 01:06:23.480]  dp, n, ut.
[01:06:25.480 --> 01:06:29.480]  Потому что, чтобы попасть в вершину v за n плюс 1 шаг,
[01:06:29.480 --> 01:06:32.480]  я должен фиксировать некое последнее ребро из uv
[01:06:32.480 --> 01:06:34.480]  и добраться до него за n шагов.
[01:06:34.480 --> 01:06:36.480]  Соответственно, по ним по всем взять дизъюнкцию,
[01:06:36.480 --> 01:06:38.480]  потому что достаточно наличия хотя бы одного такого ребра,
[01:06:38.480 --> 01:06:42.480]  чтобы был путь до начала ребра длины n.
[01:06:42.480 --> 01:06:46.480]  Либо же, если я хочу брать дизъюнкцию не по всем ребрам,
[01:06:46.480 --> 01:06:50.480]  а по всем вершинам, от 1 до v большого,
[01:06:50.480 --> 01:06:54.480]  тогда здесь можно взять конъюнкцию dp, n, u
[01:06:54.480 --> 01:06:58.480]  на факс того, что есть ребро из uv.
[01:07:02.480 --> 01:07:04.480]  Ау?
[01:07:04.480 --> 01:07:06.480]  Нет, конечно.
[01:07:06.480 --> 01:07:11.480]  Значит, m, ut, v.
[01:07:11.480 --> 01:07:14.480]  Ну, где m это как раз матрица смежности.
[01:07:22.480 --> 01:07:24.480]  Похоже на правду?
[01:07:24.480 --> 01:07:26.480]  Чудно.
[01:07:26.480 --> 01:07:28.480]  Так вот.
[01:07:28.480 --> 01:07:32.480]  Я хочу ввести новую процедуру умножения матриц.
[01:07:32.480 --> 01:07:36.480]  Я хочу ввести буллевское умножение матриц.
[01:07:40.480 --> 01:07:44.480]  А именно, я в обычном определении произведения матриц
[01:07:44.480 --> 01:07:46.480]  заменю сумму на дизъюнкцию,
[01:07:46.480 --> 01:07:49.480]  а произведение на конъюнкцию.
[01:07:51.480 --> 01:07:54.480]  Давайте я ее как-нибудь обозначу, не знаю,
[01:07:54.480 --> 01:07:57.480]  к сорам каким-нибудь.
[01:07:57.480 --> 01:08:00.480]  Пусть у меня есть две матрицы a и b.
[01:08:00.480 --> 01:08:16.480]  Две матрицы из 0 единиц размера, пусть будет v на v.
[01:08:19.480 --> 01:08:23.480]  Тогда давайте определим их буллевское умножение.
[01:08:25.480 --> 01:08:28.480]  Ну, тут вроде как нет у кого-то стандартного значка.
[01:08:28.480 --> 01:08:30.480]  Давайте я нарисую тензорное произведение,
[01:08:30.480 --> 01:08:32.480]  потому что имею право.
[01:08:32.480 --> 01:08:35.480]  Буллевское произведение,
[01:08:42.480 --> 01:08:44.480]  которое сдается вот по тому правилу,
[01:08:44.480 --> 01:08:46.480]  это дизъюнкция конъюнкции.
[01:08:46.480 --> 01:08:50.480]  c и tожи t это дизъюнкция по всем k.
[01:08:52.480 --> 01:08:54.480]  Давайте не буду писать пределы,
[01:08:54.480 --> 01:08:57.480]  потому что как-то криво получается.
[01:08:58.480 --> 01:09:09.480]  Собственно, вот ту формулу просто переложил на случай матриц призвольных.
[01:09:13.480 --> 01:09:16.480]  Тогда я утверждаю, что вот та задача решается следующим образом.
[01:09:16.480 --> 01:09:18.480]  Нужно взять матрицу смежности,
[01:09:18.480 --> 01:09:22.480]  возвести ее в терминах вот такого умножения в катую степень
[01:09:22.480 --> 01:09:25.480]  и посмотреть на ячейку с номером x и y.
[01:09:26.480 --> 01:09:29.480]  Здесь, чтобы ответить на этот вопрос,
[01:09:29.480 --> 01:09:32.480]  я просто беру матрицу смежности m,
[01:09:32.480 --> 01:09:37.480]  возвожу ее с точки зрения нашего нового умножения Буллевского в катую степень
[01:09:37.480 --> 01:09:40.480]  и вывожу ее значение в точку x и y.
[01:09:43.480 --> 01:09:46.480]  Собственно, доказательства здесь вот отсюда следуют,
[01:09:46.480 --> 01:09:49.480]  потому что мы ввели такую динамику как раз таки,
[01:09:49.480 --> 01:09:52.480]  ее очередной слой выражается как дизъюнкция конъюнкции,
[01:09:52.480 --> 01:09:56.480]  ну и мы ровно так определили бинарное умножение,
[01:09:56.480 --> 01:09:58.480]  Буллевское умножение матриц.
[01:09:58.480 --> 01:10:02.480]  Мы его определили так, чтобы это было ответом на самом деле.
[01:10:02.480 --> 01:10:05.480]  Мы так ввели умножение, чтобы оно отражало те свойства,
[01:10:05.480 --> 01:10:07.480]  которые мы от него хотим.
[01:10:11.480 --> 01:10:14.480]  Осталось научиться как-нибудь быстро возводить матрицу
[01:10:14.480 --> 01:10:17.480]  в нужную степень по данному умножению.
[01:10:18.480 --> 01:10:20.480]  Работает все то же самое,
[01:10:20.480 --> 01:10:24.480]  что отсюда вместо умножений нужны вот эти нормальные умножения Буллевские.
[01:10:25.480 --> 01:10:28.480]  Давайте быстренько это напишем.
[01:10:29.480 --> 01:10:34.480]  Пусть я хочу, чтобы f от a, n возвращала мне n-ую степень матрицы a
[01:10:34.480 --> 01:10:37.480]  с точки зрения нашего Буллевского умножения.
[01:10:37.480 --> 01:10:42.480]  Тут надо еще научиться находить эту самую единичную матрицу.
[01:10:42.480 --> 01:10:45.480]  Что будет единичной матрицы здесь?
[01:10:45.480 --> 01:10:47.480]  Сойдет ли e?
[01:10:47.480 --> 01:10:50.480]  Вот я сейчас попытаюсь понять.
[01:10:51.480 --> 01:10:53.480]  Похоже на правду.
[01:10:53.480 --> 01:10:55.480]  Если я беру какую-то строчку.
[01:10:58.480 --> 01:11:01.480]  Ну да, как раз она выделяет...
[01:11:05.480 --> 01:11:07.480]  Да, да, да.
[01:11:07.480 --> 01:11:10.480]  То есть на самом деле с точки зрения умножения вот этого или обычного
[01:11:10.480 --> 01:11:13.480]  у меня единичная матрица тоже будет нейтральным элементом.
[01:11:13.480 --> 01:11:15.480]  Ей это нейтральный элемент.
[01:11:16.480 --> 01:11:19.480]  В том смысле, что на какую матрицу ее не умножай,
[01:11:19.480 --> 01:11:22.480]  вот в этих терминах получится как раз-таки другая матрица.
[01:11:22.480 --> 01:11:24.480]  Давайте переду, если не видно.
[01:11:34.480 --> 01:11:37.480]  Я вот ожидал, что е – это нейтральный элемент.
[01:11:39.480 --> 01:11:44.480]  В том смысле, что е на любую матрицу m – это m.
[01:11:44.480 --> 01:11:47.480]  Ну и m на е – это тоже m.
[01:11:48.480 --> 01:11:51.480]  Ну легко пронаблюдать, что если у вас в е на диагонали
[01:11:51.480 --> 01:11:53.480]  единичка все стами нули,
[01:11:53.480 --> 01:11:55.480]  то когда вы перемножаете е на m,
[01:11:55.480 --> 01:11:58.480]  у вас в этом строке в житом столбце получается как раз
[01:11:58.480 --> 01:12:00.480]  m и t житое.
[01:12:00.480 --> 01:12:02.480]  То есть мы просто оставляем...
[01:12:02.480 --> 01:12:04.480]  Поскольку здесь единица только в одной позиции,
[01:12:04.480 --> 01:12:06.480]  мы просто оставляем то, что было в точке m и g,
[01:12:06.480 --> 01:12:08.480]  и все будет нормально.
[01:12:08.480 --> 01:12:10.480]  Ну а дальше все как обычно.
[01:12:11.480 --> 01:12:20.480]  f a n – это f a n пополам умножить само на себя,
[01:12:20.480 --> 01:12:22.480]  если n четно.
[01:12:24.480 --> 01:12:26.480]  Да, если n четно.
[01:12:28.480 --> 01:12:30.480]  Ну если n нечетно,
[01:12:31.480 --> 01:12:33.480]  то я как всегда отделяю сначала
[01:12:34.480 --> 01:12:36.480]  один раз нашу матрицу a
[01:12:36.480 --> 01:12:39.480]  и рекурсивно считаю f a n – 1.
[01:12:40.480 --> 01:12:42.480]  Если н нечетно.
[01:12:45.480 --> 01:12:47.480]  Получается вновь решение за
[01:12:48.480 --> 01:12:50.480]  куб размера матрицы на логарифум
[01:12:51.480 --> 01:12:53.480]  чего там, видимо, k.
[01:12:53.480 --> 01:12:55.480]  Да, логарифум показателя степени.
[01:12:59.480 --> 01:13:01.480]  Я обещал, что это можно делать чуть быстрее,
[01:13:01.480 --> 01:13:03.480]  чем вот это.
[01:13:03.480 --> 01:13:05.480]  Да, на самом деле можно просто
[01:13:05.480 --> 01:13:07.480]  более эффективно перемножать
[01:13:07.480 --> 01:13:09.480]  строчку на столбец.
[01:13:10.480 --> 01:13:12.480]  Ну давайте я напишу утверждение.
[01:13:33.480 --> 01:13:35.480]  Буливское произвление матриц можно найти
[01:13:35.480 --> 01:13:42.480]  за o от v в кубе делить на w,
[01:13:42.480 --> 01:13:44.480]  где w длина машинного слова.
[01:13:52.480 --> 01:13:54.480]  То есть это, грубо говоря, то,
[01:13:54.480 --> 01:13:56.480]  что у вас помещается в регистр,
[01:13:56.480 --> 01:13:58.480]  или там в int, или в long-long.
[01:13:59.480 --> 01:14:02.480]  Например, если у вас длина машинного слова 32,
[01:14:02.480 --> 01:14:04.480]  то у вас здесь будет n² на 32.
[01:14:05.480 --> 01:14:07.480]  Куб размера поделить на 32,
[01:14:07.480 --> 01:14:09.480]  или на 64.
[01:14:09.480 --> 01:14:11.480]  Значит, здесь очень просто.
[01:14:11.480 --> 01:14:13.480]  Смотрите, вот это две матрицы.
[01:14:15.480 --> 01:14:17.480]  Мы хотим перемножить, как всегда работает
[01:14:17.480 --> 01:14:19.480]  произведение, мы хотим перемножить
[01:14:19.480 --> 01:14:21.480]  эту строчку на житый столбец.
[01:14:23.480 --> 01:14:25.480]  Давайте побьем их на
[01:14:25.480 --> 01:14:27.480]  блоке длины w.
[01:14:34.480 --> 01:14:36.480]  И теперь мне что нужно?
[01:14:36.480 --> 01:14:38.480]  Мне нужно побитого их умножить,
[01:14:38.480 --> 01:14:40.480]  в смысле, взять побитую конъюнкцию
[01:14:40.480 --> 01:14:42.480]  и взять потом дизюнкцию.
[01:14:42.480 --> 01:14:44.480]  Но я умею уже брать конъюнкцию
[01:14:44.480 --> 01:14:46.480]  двух слов.
[01:14:46.480 --> 01:14:48.480]  У меня есть такое слово,
[01:14:48.480 --> 01:14:50.480]  машинное, длина w, и вот такое.
[01:14:50.480 --> 01:14:52.480]  Я хочу взять побитую конъюнкцию.
[01:14:52.480 --> 01:14:54.480]  Это просто ант.
[01:14:54.480 --> 01:14:56.480]  Беру дальше ант вот этого и вот этого,
[01:14:56.480 --> 01:14:58.480]  вот этого и вот этого,
[01:14:58.480 --> 01:15:00.480]  вот этого и вот этого.
[01:15:00.480 --> 01:15:02.480]  В конце мне нужно проверить,
[01:15:02.480 --> 01:15:04.480]  есть ли там хотя бы
[01:15:04.480 --> 01:15:06.480]  один единичный бит.
[01:15:06.480 --> 01:15:08.480]  Это надо просто сравнить эту...
[01:15:12.480 --> 01:15:14.480]  Еще раз, я беру попарную конъюнкцию
[01:15:14.480 --> 01:15:16.480]  вот этих, вот этих, вот этих, вот этих.
[01:15:16.480 --> 01:15:18.480]  Потом это все беру под дизюнкцией,
[01:15:18.480 --> 01:15:20.480]  и мне нужно проверить, что в этой дизюнкции
[01:15:20.480 --> 01:15:22.480]  есть хотя бы один нелевой бит,
[01:15:22.480 --> 01:15:24.480]  то есть дизюнкция не нулева.
[01:15:24.480 --> 01:15:26.480]  Давайте я напишу так, вот есть
[01:15:26.480 --> 01:15:28.480]  x1, x2, x3, x4,
[01:15:28.480 --> 01:15:30.480]  y1, y2, y3, y4.
[01:15:32.480 --> 01:15:34.480]  Я беру попарные конъюнкции,
[01:15:36.480 --> 01:15:38.480]  потом их объединяю через дизюнкции.
[01:15:46.480 --> 01:15:48.480]  И соответственно, если здесь
[01:15:48.480 --> 01:15:50.480]  не ноль, то значит,
[01:15:50.480 --> 01:15:52.480]  то значит на переченье
[01:15:52.480 --> 01:15:54.480]  этой строки житого сопса в новой матрице
[01:15:54.480 --> 01:15:56.480]  стоит единица.
[01:15:58.480 --> 01:16:00.480]  Если здесь не ноль, то это значит,
[01:16:00.480 --> 01:16:02.480]  что c и t ажито равно единице.
[01:16:10.480 --> 01:16:12.480]  Понятно, что произошло?
[01:16:14.480 --> 01:16:16.480]  Еще раз, смотрите, вот у меня,
[01:16:16.480 --> 01:16:18.480]  как у меня считается c и t ажито,
[01:16:18.480 --> 01:16:20.480]  c и t ажито, это я беру итую строчку
[01:16:20.480 --> 01:16:22.480]  в матрице A, житую строчку в матрице B,
[01:16:22.480 --> 01:16:24.480]  причем все, столбец, sorry,
[01:16:24.480 --> 01:16:26.480]  причем это нули единицы все.
[01:16:26.480 --> 01:16:28.480]  Дальше я бью на одинаковые
[01:16:28.480 --> 01:16:30.480]  блоги длины w, например,
[01:16:30.480 --> 01:16:32.480]  по 32 бита.
[01:16:32.480 --> 01:16:34.480]  Я могу представить эти 32 бита как один int,
[01:16:34.480 --> 01:16:36.480]  unsigned int, например.
[01:16:36.480 --> 01:16:38.480]  Потом я их все попарно andeo,
[01:16:38.480 --> 01:16:40.480]  oreo и они,
[01:16:40.480 --> 01:16:42.480]  вот этот or не нулевой,
[01:16:42.480 --> 01:16:44.480]  только если в конце единицы.
[01:16:44.480 --> 01:16:46.480]  В итоге как раз получили ускорение
[01:16:46.480 --> 01:16:48.480]  ровно в w раз, что равно длине машинного слова.
[01:16:48.480 --> 01:16:50.480]  Иногда бывает полезно.
[01:16:50.480 --> 01:16:52.480]  Все, спасибо.
