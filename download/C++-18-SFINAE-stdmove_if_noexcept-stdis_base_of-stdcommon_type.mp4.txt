[00:00.000 --> 00:12.320]  Следующее, что мы хотим научиться реализовывать, это no throw move constructible и move no accept.
[00:12.320 --> 00:21.420]  Is no throw move constructible и move if no accept.
[00:22.060 --> 00:25.260]  Почему мы нампистим no throw и move no accept?
[00:33.260 --> 00:35.260]  Без комментариев, не знаю.
[00:35.260 --> 00:36.780]  Интересно, интересно.
[00:36.780 --> 00:47.820]  Ну, понятно, что мы сейчас научимся реализовывать не только из no throw move constructible, но просто из no throw что угодно, а move no accept просто для него как раз no throw move constructible понадобится.
[00:47.900 --> 01:00.940]  Ну, смотрите, у нас в принципе уже есть из move constructible, ну, почти есть, но давайте я вам скажу, что у меня есть вот, вот по сути, что такое из move constructible?
[01:00.940 --> 01:04.940]  Это из constructible от T и T, V, M, A.
[01:04.940 --> 01:06.940]  Так?
[01:06.940 --> 01:15.980]  А из move constructible V это из move constructible от V, V, L, все, все, move constructible готово.
[01:18.780 --> 01:22.780]  Вот это же R-value ссылка, а не универсальная ссылка, понятно.
[01:22.780 --> 01:26.300]  Как это отличать? Я уже видимо, я без того понимаю.
[01:26.300 --> 01:38.460]  Универсальная ссылка это то, что в функции, а здесь конкретная штука, ты просто с the mempersand'ами, ты янжер, указываешь, когда этот шамлон используешь, типа свой, the mempersand.
[01:38.460 --> 01:40.460]  Универсальная ссылка появляется в функции.
[01:40.460 --> 01:42.460]  Ну еще, а у универсанта.
[01:43.100 --> 01:51.100]  Не всегда появляется когда-нибудь ссылка, потому что, если у тебя перейдут 1-2 конструктора и 1-2 нет, то одна из них универсальная.
[01:51.100 --> 01:57.100]  В общем, давайте начнем опять с застряния надолго на этом сговорю, хочется побыстрее уже.
[01:57.100 --> 02:09.100]  Значит, как реализовать из move constructible? Ну, наивный способ сказать, что это же просто, что такое из move constructible?
[02:09.740 --> 02:17.740]  No, throw move constructible. Ну, это, казалось бы, просто из constructible и что?
[02:17.740 --> 02:19.740]  No, except, what?
[02:19.740 --> 02:21.740]  No, except, what?
[02:21.740 --> 02:23.740]  T, what?
[02:23.740 --> 02:25.740]  Чего?
[02:29.740 --> 02:31.740]  Decal valve.
[02:31.740 --> 02:33.740]  Ну, можно сказать decal valve.
[02:34.380 --> 02:38.380]  Ну, можно сказать так, да, нормально.
[02:38.380 --> 02:44.380]  Она и так правила T, но, в принципе, можно и так сказать.
[02:44.380 --> 02:50.380]  Почему это неправильное? Это наивная реализация, но неверная. Принципиально неверная.
[02:50.380 --> 02:52.380]  Она не будет работать.
[02:52.380 --> 02:54.380]  Вообще, в любом случае.
[02:54.380 --> 02:56.380]  Нет, ну, в каких-то случаях она будет работать.
[02:56.380 --> 02:58.380]  Не по-всюду.
[02:58.380 --> 03:00.380]  Что?
[03:00.380 --> 03:02.380]  Decal valve.
[03:03.020 --> 03:05.020]  Приватный, например.
[03:05.020 --> 03:09.020]  Ну, она не будет работать, в случае, когда...
[03:09.020 --> 03:11.020]  Можно говорить, пожалуйста, что такое noexcept, what?
[03:11.020 --> 03:13.020]  А ну, говорит, правда ли, что это выражение не может пьянуть исключение?
[03:13.020 --> 03:15.020]  Это оператор noexcept.
[03:15.020 --> 03:17.020]  Он, по-настоящему, впечатлимый.
[03:17.020 --> 03:19.020]  Возвращает true...
[03:19.020 --> 03:29.020]  Возвращает false, если там внутри есть mu, dynamic cast или throw, или какая-нибудь не noexcept функция и false во всех остальных случаях.
[03:29.660 --> 03:31.660]  Конечно, non-evil-weighting.
[03:31.660 --> 03:33.660]  Он не вычисляет, разумеется, это выражение.
[03:33.660 --> 03:35.660]  Он только проверяет noexcept ли там.
[03:35.660 --> 03:37.660]  Почему это не будет работать?
[03:37.660 --> 03:39.660]  Потому что, если нет move-конструктора,
[03:39.660 --> 03:41.660]  если эта штука не move-constructible,
[03:41.660 --> 03:43.660]  то из constructible будет false,
[03:43.660 --> 03:49.660]  ну, я могу написать здесь, наверное, из move-constructible от t,
[03:49.660 --> 03:51.660]  это будет false,
[03:52.300 --> 03:54.300]  и вот эта вот выдаст ошибку, купиляция.
[03:54.300 --> 04:02.300]  Если нет move-конструктора, то вы скажете, ну, правая часть логического i не вычисляется.
[04:02.300 --> 04:04.300]  Так никто ее не вычисляет.
[04:04.300 --> 04:06.300]  Она же компилируется.
[04:06.300 --> 04:10.300]  Ну, это конъюнция обычная.
[04:10.300 --> 04:12.300]  Если первый аргумент false, то конъюнция обычная.
[04:12.300 --> 04:14.300]  Это конъюнция в каверси.
[04:14.300 --> 04:16.300]  Это конъюнция в каверси.
[04:16.300 --> 04:18.300]  Это конъюнция в каверси.
[04:18.300 --> 04:20.300]  Это конъюнция в каверси.
[04:20.300 --> 04:24.300]  Если первый аргумент false, то, казалось бы, правый аргумент не должен вычисляться.
[04:24.300 --> 04:27.300]  Нет, значит, надо поприкнуть типа шаблон conjunction.
[04:27.300 --> 04:29.300]  Вот даже, типа, мы сделаем проект первого и все.
[04:29.300 --> 04:31.300]  Сенсибы точно не будет.
[04:31.300 --> 04:32.300]  Все равно нужно сделать какой-то тип.
[04:32.300 --> 04:33.300]  Шаблон conjunction.
[04:33.300 --> 04:35.300]  Шаблон, нужно сделать какой-то тип.
[04:35.300 --> 04:37.300]  Не, не, используется deconjunction.
[04:37.300 --> 04:39.300]  А что во второй подставить?
[04:39.300 --> 04:40.300]  Тоже самое.
[04:40.300 --> 04:42.300]  Это не твой тип, а что?
[04:42.300 --> 04:44.300]  Это же буллевский констант, а просто нужен тип другой.
[04:44.300 --> 04:46.300]  Так мы же говорили, что conjunction просто...
[04:46.300 --> 04:49.300]  Что, типа, conjunction просто реализован для типов,
[04:49.300 --> 04:51.300]  но про факт, что она не будет работать.
[04:51.300 --> 04:53.300]  Не, не, не, булл констант вот этот.
[04:53.300 --> 04:55.300]  Да, если нужен булл вот этот.
[04:55.300 --> 04:57.300]  Нужно булл... Вы предлагаете писать булл констант?
[04:57.300 --> 04:58.300]  Да.
[04:58.300 --> 05:00.300]  Которая... Че будет здесь?
[05:00.300 --> 05:02.300]  Не, мы предлагаем...
[05:02.300 --> 05:04.300]  Мы запихиваем в STD булл константа все этот месяц.
[05:04.300 --> 05:06.300]  Что запихиваем в STD булл констант?
[05:06.300 --> 05:08.300]  Пишем там создать конст булл value равно вот этому?
[05:08.300 --> 05:09.300]  Да.
[05:09.300 --> 05:11.300]  Так это опять CE будет?
[05:11.300 --> 05:13.300]  И это запихнуть в SP conjunction?
[05:13.300 --> 05:15.300]  И какая разница-то? Опять CE будет?
[05:15.300 --> 05:16.300]  Почему оно подставится?
[05:16.300 --> 05:17.300]  Он не должен подставить сюда.
[05:17.300 --> 05:19.300]  Но он еще скорее потом должен уже был следом.
[05:19.300 --> 05:21.300]  Посмотри второе.
[05:21.300 --> 05:23.300]  В смысле, ты хочешь сказать, что он его не инстанцирует?
[05:23.300 --> 05:25.300]  Да, почему его должен инстанцировать?
[05:25.300 --> 05:27.300]  Мы же обсуждали то, что у нас...
[05:27.300 --> 05:29.300]  В чем разница между full expression и conjunction?
[05:29.300 --> 05:31.300]  Ну, я думаю, что...
[05:31.300 --> 05:33.300]  Давай проверим.
[05:33.300 --> 05:35.300]  Значит, че я хочу сказать?
[05:37.300 --> 05:41.300]  Ты предлагаешь мне написать из no throw...
[05:41.300 --> 05:42.300]  Что?
[05:42.300 --> 05:44.300]  Ровно из твоей conjunction.
[05:44.300 --> 05:46.300]  Мне нужно булл констант, значит.
[05:46.300 --> 05:47.300]  А, ты хочешь...
[05:47.300 --> 05:49.300]  Ты хочешь булл констант вот здесь?
[05:49.300 --> 05:51.300]  Окей. Я понял.
[05:51.300 --> 05:52.300]  Да.
[05:52.300 --> 05:53.300]  Сейчас.
[05:53.300 --> 05:55.300]  И там тоже.
[05:55.300 --> 05:57.300]  Это мы на плеотипе закомментируем?
[05:57.300 --> 05:59.300]  Сейчас, почему у нас из move constructable...
[05:59.300 --> 06:01.300]  А, из move constructable это будет false type.
[06:01.300 --> 06:03.300]  Ты хочешь сказать...
[06:03.300 --> 06:05.300]  Стоп, что у нас сейчас вообще написано сейчас?
[06:05.300 --> 06:07.300]  Секунду. Можно вернуть назад?
[06:07.300 --> 06:08.300]  Я не понимаю.
[06:08.300 --> 06:10.300]  Что у нас было написано?
[06:10.300 --> 06:12.300]  Из move constructable V надо, конечно, здесь.
[06:12.300 --> 06:13.300]  Да.
[06:13.300 --> 06:15.300]  И using V?
[06:19.300 --> 06:21.300]  Ой, да, constextable...
[06:21.300 --> 06:23.300]  Да, это тоже правда.
[06:23.300 --> 06:25.300]  Да, но constextable можно...
[06:25.300 --> 06:27.300]  Все, хорошо, все нормально.
[06:27.300 --> 06:29.300]  Только тогда из no throw move constructable V.
[06:31.300 --> 06:33.300]  Да. Ну, можно...
[06:33.300 --> 06:35.300]  Ну, хорошо. Давайте скажем, что...
[06:35.300 --> 06:37.300]  Struct из no throw move constructable...
[06:37.300 --> 06:39.300]  Это...
[06:39.300 --> 06:41.300]  Это равно или наследование?
[06:41.300 --> 06:43.300]  Наследование.
[06:43.300 --> 06:45.300]  Это наследование, stconjunction V,
[06:45.300 --> 06:47.300]  с шаглонными параметрами какими?
[06:47.300 --> 06:49.300]  Из move constructable от T.
[06:49.300 --> 06:51.300]  А еще, что вы предлагаете в constant?
[06:55.300 --> 06:57.300]  От...
[06:57.300 --> 06:59.300]  Э...
[06:59.300 --> 07:01.300]  Вот этого.
[07:01.300 --> 07:03.300]  И...
[07:03.300 --> 07:05.300]  Углова скобочка закрылась.
[07:07.300 --> 07:09.300]  И пустое тело.
[07:09.300 --> 07:11.300]  Сейчас должно быть выгонять.
[07:11.300 --> 07:13.300]  Вот. Ну...
[07:13.300 --> 07:15.300]  Попробуем.
[07:15.300 --> 07:17.300]  Возьму-ка я какую-нибудь структуру,
[07:21.300 --> 07:23.300]  которая...
[07:23.300 --> 07:25.300]  Которую нельзя мутить.
[07:33.300 --> 07:35.300]  И попробую проверить, правда ли, что она
[07:35.300 --> 07:37.300]  из no throw move constructable.
