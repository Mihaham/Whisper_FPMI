[00:00.000 --> 00:09.640]  раз мы поговорили про, в принципе, что такое машина тюринга, в этот раз мы будем обобщать
[00:09.640 --> 00:17.400]  машины тюринга, ну точнее не обобщать, а увеличивать размерность. У нас была там некоторая машина
[00:17.400 --> 00:26.320]  тюринга от одного аргумента, сегодня мы переходим от машины тюринга с двумя аргументами nk, например.
[00:26.320 --> 00:44.080]  Так вот, мы будем рассматривать не все такие бинарные машины тюринга, а особые. Которые
[00:44.080 --> 01:05.200]  называются универсальные вычислимые функции. У нас есть, мы знаем, что у нас есть некое такое
[01:05.200 --> 01:10.720]  соответствие между вычислимыми функциями машинами тюринга, поэтому я буду больше говорить про
[01:10.720 --> 01:17.560]  функции, но то же самое вот справедливо там для машин тюринга, ну с точностью до определенных изменений.
[01:17.560 --> 01:32.600]  Ну что такое универсальные вычислимые функции? Первое, это такая у нас будет функция у от слова
[01:32.600 --> 01:45.080]  universal от двух аргументов nx, которая обладает двумя свойствами. Первое, у вычислима как функции
[01:45.080 --> 02:14.640]  двух аргументов. Второе, это что для любого, скажем, что для любой f принадлежащей классу
[02:14.640 --> 02:32.960]  вычислимых функций. Давайте я назову их как там вычислимые. Ну давайте вычислимые функции.
[02:32.960 --> 02:50.600]  Найдется такой номер, что для любого x принадлежащего натуральным числам.
[02:50.600 --> 03:06.520]  Ладно, давайте просто напишу для любого x. Понятно. Будет упоняться следующее, что у от
[03:06.520 --> 03:18.560]  n0x равняется f от x. Причем мы будем допускать себе следующее обозначение. Вот такое вот,
[03:18.560 --> 03:31.440]  что у с индексом n от x это есть не что иное, как у nx. В чем смысл вот такой вот штуки? В том,
[03:31.440 --> 03:37.320]  что у нас есть все возможные вычислимые функции, а теперь мы их можем засунуть в
[03:37.320 --> 03:49.000]  некоторую такую табличку. Вот у меня были. У меня табличка. Вот здесь пусть будут x. У меня
[03:49.000 --> 03:53.400]  была функция, но просто принимал какие-то значения. А теперь у меня их можно замена
[03:54.400 --> 04:00.040]  и получается вот здесь у меня лежит одна функция, здесь другая. Вот так вот они все сложены вверх.
[04:00.040 --> 04:10.680]  На это можно смотреть, как на своего рода, как бы так сказать, трансляцию из одного языка в другую.
[04:10.680 --> 04:17.120]  То есть у нас есть некоторый, например язык программирования, есть переводчик этого языка
[04:17.120 --> 04:28.840]  программирования в программы на другом языке программирования. Так как у нас здесь и здесь n,
[04:28.840 --> 04:32.840]  то есть на самом деле у нас есть двойственность, что у нас одновременно функции занумерованы,
[04:32.840 --> 04:42.740]  аргументы занумерованы, и вот с этим как раз связан следующий прикол, что и аргументы это
[04:42.740 --> 04:47.380]  натуральное число и функции тоже в некотором смысле натуральное число. Называется такой
[04:47.380 --> 05:03.300]  прикол, проблема остановки. Пусть у нас есть некоторая универсальная честная функция,
[05:03.300 --> 05:16.920]  буду обозначать везде ее как УВФ. Тогда множество, множество с, множество таких
[05:16.920 --> 05:32.660]  аргументов n, что у n, n определено. Оно является неразрешимым.
[05:32.660 --> 05:53.200]  Это называется проблема остановки.
[05:53.200 --> 06:09.160]  Но несмотря на то, что это неразрешимо, мы можем точно сказать, что это перечислимо.
[06:09.160 --> 06:26.400]  Давайте придумаем алгоритм, как это все перечислить. Ну, у нас есть, есть,
[06:26.400 --> 06:42.520]  у n, t это у нас некоторые машины тюринга, то есть у нас у n, t это будет некоторая функция,
[06:42.520 --> 06:53.440]  аргумент, который будет подаваться вот во второй знак. Ну давайте, я не знаю, были ли у вас,
[06:53.440 --> 07:00.480]  но языке бы программирование, это бы назвали в языках программирования, если бы мы писали,
[07:00.480 --> 07:10.280]  мы бы написали что-то такое, что f от x это у нас равняется, а здесь даже нужна лямбда, ладно,
[07:10.280 --> 07:24.680]  окей, хорошо, у n, x, для какого-то n. Тогда, если эта машина, это какая-то вычисленная функция,
[07:24.680 --> 07:29.480]  соответственно, есть некоторые машины тюринга, которые вычисляют, тогда что мы делаем? Мы берем,
[07:29.480 --> 07:58.360]  перебираем все пары, пары вида n, t и запускаем у n в аргументе n,
[07:58.360 --> 08:10.680]  на t шагов. Если завершится, то соответственно, мы выведем, не завершится, но не выведем. Все,
[08:10.680 --> 08:17.720]  таким образом, мы сможем перечислить все такие n, на которых эта универсальная функция будет
[08:17.720 --> 08:27.520]  завершаться. В следующем, ну, сначала свойств следующим теоремой, мы обозначим теорему
[08:27.520 --> 08:39.520]  поста. Вроде в прошлый раз мы о ней говорили, что множество m является разрешимым,
[08:39.520 --> 09:07.960]  раносимо тому, что m перечислим и ко перечислим. Что мы можем здесь сказать, что если у нас есть
[09:07.960 --> 09:15.240]  теорема поста, мы имеем неразрешимость, но перечислимость, тогда отсюда мы можем сделать
[09:15.240 --> 09:36.640]  следующее заключение, что не ко перечислимо по теореме поста. Хорошо, следующей характеристикой
[09:36.640 --> 10:02.560]  интересной будет тотальность. Тотальность функции. Что такое тотальность функции? Это всю доопределенность.
[10:06.640 --> 10:28.480]  Ну, то есть, не существует такого x, что не существует f от x. Ну, или по-другому будет у нас,
[10:28.480 --> 10:43.480]  как это звучать, что для любого x будет существовать некоторое a такое, что a равняется f от x.
[10:43.480 --> 10:56.640]  Ну, функции там действуют из какого-то одного множества в другое, не конкретизируем.
[10:56.640 --> 11:10.160]  Хорошо, вот у нас есть универсальность функции, а что насчет, скажу, насчет универсальной
[11:10.160 --> 11:14.480]  функции, которая при этом является тотальной. Так вот, подтверждается, что не существует
[11:14.480 --> 11:24.720]  такой функции. Не существует универсальной тотально участвуемой функции. Почему не существует?
[11:24.720 --> 11:42.240]  Опять же, используется техника диагонального метода кантера. Это же кантер? Вроде кантер. То есть,
[11:42.240 --> 11:49.560]  у нас снова есть вот эта табличка. Здесь x, здесь n. Если диагональный, рассматриваем диагональ.
[11:49.560 --> 12:07.200]  И берем, рассматриваем аргументы. То есть, здесь 0, 1, 2, 3, 4, 5, полетели. 1, 2, 3, 4. Рассматриваем
[12:07.200 --> 12:26.760]  функцию d на 1 диагонали. d от x равняется, давайте вот, пусть это у нас какая-то функция tnx,
[12:26.760 --> 12:33.840]  тотально универсально участвуемая. Пусть она существует. Тогда мы рассматриваем d от x, это txx.
[12:33.840 --> 12:48.540]  Что в таком случае? В таком случае рассмотрим функцию d штрих, от x полученные d от x плюс 1.
[12:48.540 --> 12:57.720]  Это натуральное, плюс 1 тоже будет натуральным. Хорошо, если это везде определено, то и это тоже
[12:57.720 --> 13:05.760]  везде определено. Ну а это означает, что d штрих от x принадлежит классу тотальных функций.
[13:05.760 --> 13:25.120]  Но, очевидно, не существует такого n, что tnt от x будет равняться d штрих от x. Поэтому
[13:25.120 --> 13:38.640]  универсальные тотально участвуемые функции не существуют. Хорошо, мы говорили про кооперечислимость
[13:38.640 --> 13:50.040]  как то, что дополнение принадлежит. Также на кооперечислимость можно смотреть немножко другим
[13:50.040 --> 14:02.680]  способом, на самом деле тем же самым. А именно следующим, что мы должны перечислить элементы,
[14:02.680 --> 14:16.320]  которые не лежат. А, ну это в целом и есть, да, по сути тоже самое. Хорошо.
[14:16.320 --> 14:34.640]  Смотрим следующий. Терема райса Успенского. Очень важная терема. Терема райса Успенского.
[14:34.640 --> 14:57.120]  И говорит она нам о следующем, что любое нетривиальное свойство машин тюринга неразрешимо.
[15:04.640 --> 15:13.840]  Начнем. Что это означает? Первое, что нужно отметить, что значит нетривиальное.
[15:13.840 --> 15:33.320]  Нетривиальное тире это не пустое множество и не все натуральные числа. Ну то, мы же про машин
[15:33.320 --> 15:42.320]  тюринга. Не все машины тюринга. Вот так вот. Мы сейчас работаем не в некоторой номинальности.
[15:42.320 --> 15:55.120]  Хорошо. У нас есть машины тюринга. Свойства это у нас что? Это у нас некоторые подможества.
[15:55.120 --> 16:22.120]  Время вспомнить. Интересным следствием этой теоремы будет то, что у нас неразрешимым будет в принципе
[16:22.120 --> 16:39.600]  произвольный предикат. Нетривиальный. Свойства это предикат унарный. Для большей
[16:39.600 --> 16:58.080]  мощности мы просто можем сводить их. Но о сведении вроде попозже или давайте сейчас расскажем про сводимость.
[16:58.080 --> 17:14.560]  У нас есть операция M с водимостью. В чем ее смысл? У нас есть некоторые два множества. Множество A и множество B.
[17:14.560 --> 17:21.480]  Мы про эти множества можем говорить разрешимые они, неразрешимые, перечислимые не перечислимые,
[17:21.480 --> 17:31.560]  копии перечислимые, не копии перечислимые. Там много еще интересных свойств. У нас есть функции.
[17:31.560 --> 17:40.360]  Функции могут действовать с одного множества в другое. И вопрос. На каких множествах возможны
[17:40.360 --> 17:47.880]  вычислимые функции? Как будут связаны между собой множества, если на них действует вычислимая
[17:47.880 --> 18:01.960]  функция? Начнем с первого момента. Давайте рассматривать не просто такую, а функцию,
[18:01.960 --> 18:09.720]  некоторую такую функцию из аморфизма этих двух множеств. То есть что у нас было из аморфизмом,
[18:09.720 --> 18:24.440]  что x принадлежит A, равносильно f от x принадлежит B. Мы накладываем на это из аморфизм требования,
[18:24.440 --> 18:40.040]  что это вычислимо. И в таком случае мы называем, мы говорим, что ам сводится к B.
[18:40.040 --> 18:51.680]  И оказывается, что из этого вытечет несколько интересных свойств.
[18:51.680 --> 19:11.400]  Первое свойство. Оказывается, что B накладывает уже в себе очень... B накладывает уже сильные
[19:11.400 --> 19:17.480]  требования на то, как ему должно быть A. Но в целом это действительно понятно. Если мы можем как-то
[19:17.480 --> 19:26.200]  определять... Сейчас. Можем как-то определять элементы B, то используя функцию f,
[19:26.200 --> 19:37.680]  которая вычислима, мы также можем определять элементы A. Поэтому из B перечислимости,
[19:37.680 --> 19:46.360]  разрешимости ко перечислимости будет следовать, что A тоже перечислима, разрешима ко перечислима.
[19:46.360 --> 19:56.360]  Понятно, что если у нас есть импликация в одну сторону, у нас есть контрпозиция.
[19:56.360 --> 20:14.320]  То есть если A не что-то из этого, то B тоже не. Дальше есть следующие два свойства. Это
[20:14.320 --> 20:29.440]  свойства, которые позволяют нам охарактеризовать M-сводимость как отношение. И это рефлексивность.
[20:29.440 --> 20:43.720]  Очевидно, функция Identity вычислима, поэтому селок. И транзитивность.
[20:43.720 --> 21:00.280]  Транзитивность. Композиция двух вычислимых функций тоже вычислима. Это нам дает свойство предпорядка.
[21:00.280 --> 21:19.520]  Антисимметричности нет, в том смысле, что у нас, например, все разрешимые между собой M-сводятся.
[21:19.520 --> 21:43.640]  Так что все M-сводятся. Более того, на самом деле есть более сильные свойства про все разрешимые,
[21:43.640 --> 22:02.760]  что любое разрешимое множество сводится к любому нетривиальную множеству.
[22:02.760 --> 22:16.960]  Когда я сказал, что любые два разрешимые сводятся друг к другу, исключая вот случай тривиальных множеств.
[22:16.960 --> 22:24.600]  Не все плохо. Почему пятая возможна? Потому что если A нетривиальная, в нем есть элемент,
[22:24.600 --> 22:28.240]  который принадлежит, и есть, который не принадлежит. В этом его нетривиальность.
[22:28.240 --> 22:35.520]  Там не может быть только один случай, там обязательно два. И если оно разрешимое, то у нас есть
[22:35.520 --> 22:41.640]  характеристическая функция. Ну тогда мы просто давайте там, где она единица, сведем к элементу,
[22:41.640 --> 22:53.720]  который лежит, там где ноль, сведем к элементу, который не лежит. На этом все по теории. Если есть
[22:53.720 --> 23:07.240]  вопросы, я могу ответить. Если нет, то будем разбирать. Хорошо.
[23:07.240 --> 23:28.600]  Первый номер. Смысл его определить перечислимость, не перечислимость,
[23:28.600 --> 23:41.800]  коперечислимость, не коперечислимость. Задание желтое, непростое. Здесь много подводных камней.
[23:41.800 --> 23:49.080]  Ну в целом здесь можно ошибиться. Начнем. Множество простых чисел. Какие предположения?
[23:58.600 --> 24:18.000]  Мы можем определить число простое или нет? Ладно, видимо все спят.
[24:18.000 --> 24:28.600]  Простые числа мы умеем проверять на простоту, просто проходить по всем числам меньше его и
[24:28.600 --> 24:38.760]  проверять делимость. Поэтому это разрешимо. У нас буквально есть алгоритм. По теориям
[24:39.760 --> 24:52.120]  что разрешимность это перечислимость плюс коперечислимость. Дальше. Множество всех программ,
[24:52.120 --> 24:58.600]  вычисляющих все функции. Ну смотрите. Множество всех программ, вычисляющих функцию. Оно тривиальное
[24:58.600 --> 25:06.840]  нет. Потому что есть которые не вычисляют и есть которые вычисляют. Соответственно это у нас
[25:06.840 --> 25:16.360]  неразрешимы по теориям Ирайса Успенского. Множество программ, вычисляющих функции совпадающие. Ну так же,
[25:16.360 --> 25:27.800]  так же, так же. Тривиальных здесь нет. Все что про программы. Пар программ. Это уже предикат.
[25:27.800 --> 25:48.400]  Бинарный. Он тоже работает. Поэтому здесь уже все. Вот в этом блоке ничего кроме обыть не может.
[25:48.400 --> 25:54.960]  Скорее всего да. Здесь будет какой-нибудь простой алгоритм. Все остальное здесь не лежит. То есть
[25:54.960 --> 26:01.600]  здесь у нас максимум один элемент в этом блоке. Поехали. Множество программ, вычисляющих функции.
[26:01.600 --> 26:11.760]  Что мы можем делать? Давайте думать алгоритм который мы попробуем. Ну мы можем просто
[26:11.760 --> 26:20.720]  перечислять подряд программы и проверять что хорошо не хорошо. Если один раз хорошо это не
[26:20.720 --> 26:26.160]  значит что всегда хорошо. Но если один раз плохо это значит что всегда плохо. То есть если один раз
[26:26.160 --> 26:34.040]  встретили беду мы можем остановить цикл и выйти из него. Поэтому мы можем определять программы
[26:34.040 --> 26:43.480]  которые не вычисляют ее в этом перечислении. То есть нам буквально не нужно проходить все аргументы
[26:43.480 --> 26:55.800]  и все и чтобы узнать функция не вычисляет ли функцию квадрата. Соответственно это есть
[26:55.800 --> 27:13.520]  код. Оно не разрешило значит у нас есть код перечислимость и не перечислимость. Сейчас жу.
[27:13.520 --> 27:28.280]  Стоп у меня печено как здесь. Сейчас подумаю.
[27:28.280 --> 27:54.600]  Давайте подумаем а я пока пойдем дальше. Почему у меня так ступило с b? Странно странно странно.
[27:54.600 --> 28:11.920]  Ну все просто с b я понял что происходит. Здесь работает следующая логика. Что у нас есть тотальные
[28:11.920 --> 28:22.120]  функции множество тотальных функций. У меня есть некоторая функция t. Я эту могу функцию t свести
[28:22.120 --> 28:32.560]  к программе которая вычисляет вот эту функцию квадрат. Каким образом? Я по t построю функцию t от x.
[28:32.560 --> 28:47.160]  По t от x я строю функцию t от x делить на t от x умножить на x квадрат. Мы видим что это сводимость
[28:47.160 --> 28:56.160]  она вычислима. Соответственно тотально у нас не перечислимый и не ко перечислимый.
[28:56.160 --> 29:11.600]  Не перечислимый и не ко перечислимый. Соответственно это лежит здесь.
[29:11.600 --> 29:33.120]  Я все понял в чем проблема с не ко перечислимостью. В том что когда говорю что есть один раз у нас
[29:33.120 --> 29:38.640]  случилась проблема и на этом можем закончиться. На самом деле у нас же есть там класс функций
[29:38.640 --> 29:45.960]  которые вообще никогда не останавливаются. Поэтому проверка того что функция определенна
[29:45.960 --> 29:56.520]  она уже не особо вычислим. Как раз на тотальных здесь мое прорабатывает. На нетотальных не отрабатывает.
[29:56.520 --> 30:12.560]  Множество программ вычисляющих функцию f совпадающие с x квадрат на своей области
[30:12.560 --> 30:21.360]  определения. Ну вот тут как раз отрабатывает то о чем я говорил. На своей области определения
[30:21.360 --> 30:27.720]  значит мы можем там она область определения значит она за конечные шагов конечные числа
[30:27.720 --> 30:32.320]  шагов отработает мы можем просто проверить результат верный он неверный если он где-то
[30:32.320 --> 30:46.440]  неверный значит ну все беда мы сразу ее выведем здесь в буква gm множество пар программ с
[30:46.440 --> 30:53.100]  не пересекающимися областями определения что тут делать
[31:03.340 --> 31:14.980]  пупу пупу пупу пупу пу пу ой тут пересекающиеся. С пересекающимися ну все просто мы можем
[31:14.980 --> 31:24.040]  перечислять пары программ и проверять, просто запускать их на определенное число шагов. Если у
[31:24.040 --> 31:32.760]  меня отработали, я могу проверять, что отрабатывает ли вторая программа на том же аргументе. То есть мы
[31:32.760 --> 31:39.040]  просто берем пара программ, запускаем на каком-то аргументе на определенный число шагов. Если они обе
[31:39.040 --> 31:50.080]  остановились, то значит все это победа. У них пересеклась область определения. Если нет,
[31:50.080 --> 32:01.880]  ну не повезло. Получили перечислимость. Пункт D. Множество программ, вычисляющих функции,
[32:01.880 --> 32:09.600]  строго возрастающих на своей области определения. Но опять же замечаем вот этот вот паттерн.
[32:09.600 --> 32:23.480]  Чуть-чуть слабее его сделаем. Вот на своей области определения, на своей области определения. Этот
[32:23.480 --> 32:36.520]  паттерн как раз подсказывает нам, что здесь есть ко перечислимость. То есть на своей области
[32:36.520 --> 32:46.000]  определения, значит программы тут завершились. Поэтому вопрос лишь в том, что мы можем на этом
[32:46.000 --> 32:52.520]  сделать. Если мы можем какое-то свойство на область определения, если оно один раз не выполнилось,
[32:52.520 --> 33:01.280]  на каком-то элементе, то оно не выполнится на всем. А свойство для области определения в общем случае,
[33:01.280 --> 33:06.200]  то есть что для всех оно выполняется, это не вычислимо. Потому что сама по себе область
[33:06.200 --> 33:11.760]  определения может быть бесконечной. А мы не можем бесконечное количество элементов обработать.
[33:11.760 --> 33:18.320]  Поэтому здесь точно также ко перечислимость.
[33:18.320 --> 33:31.880]  Вот. Да пусть у нас есть некоторые свойства. Даже отмечу это, что у нас есть свойства.
[33:31.880 --> 33:44.000]  Дайте я просто напишу. На области определения это дом,
[33:44.000 --> 34:02.440]  сразу подозрение на ко перечислимость. Почему может быть не только ко перечислимость? Потому
[34:02.440 --> 34:09.400]  что, во-первых, проверьте, может быть, во-первых, это тривиальное множество или там еще есть какие-то
[34:09.400 --> 34:26.920]  подводные камни. Идейно почему-то так, что не выполнено на х, то
[34:26.920 --> 34:45.680]  и на дом, на всем. Ну то есть на всей области определения.
[34:56.920 --> 35:21.720]  Дом бесконечный. Вот да. Вот такой вот есть интересный момент, который можно сразу в этом
[35:21.720 --> 35:35.840]  задании улавливать. Дальше. Ну это уже очень простое задание. Тут нужно брать все баллы за него.
[35:35.840 --> 35:59.360]  Задание на эмсводимость. Задание простое. Поехали. Если A сводится B и A сводится C,
[35:59.360 --> 36:10.200]  то B сводится к C. Ну вообще не факт. Как это опровергнуть? Ну очень просто. Разрешимость,
[36:10.200 --> 36:18.640]  неразрешимость, разрешимость, разрешимость, неразрешимость, разрешимость. Такого быть не
[36:18.640 --> 36:28.800]  может. Если неразрешимая, то она сводится к неразрешимому. Если A сводится к B и B
[36:28.800 --> 36:34.200]  разрешимая, то A разрешимая. Ну да, верно, это свойство. Если A сводится к B и A перечислимо,
[36:34.200 --> 36:46.480]  то B перечислимо. Ну не факт. Если было бы B перечислимым, то как раз могло бы не так.
[36:46.480 --> 36:57.200]  В каком случае? Ну почему не так? Возьмем в качестве A разрешимое множество B множество
[36:57.200 --> 37:06.320]  тотальных функций. Множество тотальных функций не перечислимо и не ко перечислимо. Прекрасное
[37:06.320 --> 37:12.320]  множество, которое прям отрицает все. То есть если мы только свели тотальное множество к чему-то,
[37:12.320 --> 37:19.960]  мы сразу показали и неразрешимость, и не ко перечислимость. Ну и неразрешимость тоже.
[37:19.960 --> 37:35.080]  Если A и B разрешимые, и B и не B пустые, то да, все верно. Вот это вот условие, оно и означает,
[37:35.080 --> 37:42.640]  что B не тривиальное множество. Ну и это мы никогда не убираем.
[37:42.640 --> 38:09.160]  Ух, а теперь уже более сложные.
[38:09.160 --> 38:17.080]  Поехали. Множество самоприменимых программ M сводится, множество самоприменимых программ
[38:17.080 --> 38:28.320]  это 0100S. М сводится множество программ, останавливающихся в нуле. Давайте, которые
[38:28.320 --> 38:35.720]  останавливаются в нуле, будем называть H0. H от слова holds останавливается. Останавливается
[38:35.720 --> 38:44.280]  0, H0, M сводится, множество программ останавливается на любом входе. Останавливается на любом входе,
[38:44.280 --> 38:54.680]  это значит тотальные. 100T. Множество программ останавливается на любом входе,
[38:54.760 --> 39:13.880]  к множеству программ, не останавливающихся ни на каком ходе. Давайте их... Сейчас подумаю.
[39:13.880 --> 39:35.840]  Давайте, скажем... Давайте U.S. назовем их Unstoppable. Множество программ не останавливается
[39:35.840 --> 39:41.800]  ни на каком входе, и снова U.S. M сводится к множеству самоприменимых программ S. Ну и поехали.
[39:41.800 --> 39:48.360]  Нам нужно просто разобраться про каждое множество, что я ищу. Начнем. Про множество U.
[39:48.360 --> 39:58.120]  Ой, про множество S мы сразу знаем два свойства. Перечислимость,
[39:58.120 --> 40:04.640]  кооперечислимость. Разрешимость я писать здесь не буду, потому что да, это комбинация тех.
[40:04.640 --> 40:24.800]  Поехали. Множество S. Перечислимо, некоперечислимо. Дальше.
[40:34.640 --> 40:47.440]  Дальше. Множество тотальных функций. Неперечислимо, некоперечислимо. Рассмотрим множество HX.
[40:47.440 --> 40:59.040]  То есть множество программ, которые останавливаются на входе N. Что мы можем сделать? Понятно,
[40:59.040 --> 41:07.080]  что оно неразрешимо. То есть у нас не может быть одновременно два плюса. Но я могу сказать,
[41:07.080 --> 41:12.160]  что оно перечислимо. Почему? Давайте я буду подряд запускать все программы на определенное число
[41:12.160 --> 41:19.560]  шагов. И на вот аргументе N. Если программа остановилась, я выведу. Так я перечислю все
[41:19.560 --> 41:39.200]  алгоритмы, которые останавливаются на каком-то шаге. Сам применим. Применимы. Тотальные. Останавливаются
[41:39.200 --> 42:03.200]  на всех ходах. Определены на N. Останавливаются. Дальше.
[42:09.200 --> 42:24.200]  Давайте. Множество программ, которые не останавливаются на каком-то входе. Это тоже
[42:24.200 --> 42:27.840]  не тривиальное множество, поэтому два плюса не может быть. Соответственно, у нас осталось два
[42:27.840 --> 42:36.120]  варианта. Либо это перечислимо, либо коперечислимо. Работаем по той же схеме, что и с HN. Запускаем все
[42:36.120 --> 42:45.360]  программы на входе N и проверяем. Если программа остановилась, ну все. Значит, она не принадлежит
[42:45.360 --> 42:52.520]  ему точно. Поэтому можем вывести. Откуда имеем не коперечислим. Имеем коперечислим и не
[42:52.520 --> 43:17.480]  перечислим. Unstoppable. Дальше. Это не на каком входе она останавливается. Они аналогичны
[43:17.480 --> 43:38.720]  коперечислим. Теперь мы берем еще перебираем все входы. Еще какие-то интересные множества
[43:38.720 --> 43:58.080]  вроде бы не было. Вроде бы это все, что нам нужно. Можно было подумать, что как бы HN, если мы N
[43:58.080 --> 44:05.760]  начнем постепенно разворачивать во все чиса, оно перейдет в T, а это переходит сюда, то,
[44:05.760 --> 44:18.440]  по аналогии, что мы начнем в общей тени на все, то множество тотальных функций US должны стать тоже
[44:18.440 --> 44:29.600]  не коперечислим и не коперечислим. Почему же тут все по-другому? Как раз проблема в том, что нам
[44:29.600 --> 44:40.400]  очень сложно понять. Уже еще работала, и нам нужно еще подождать, и она закончит. И рефункция,
[44:40.400 --> 44:51.360]  в принципе, никогда не может работать. Поэтому неопределенность ломает тотальность. А в случае
[44:51.360 --> 45:00.640]  с неостановкой, у нас нет проблем с тем, что программа может работать бесконечно. У нас здесь
[45:00.640 --> 45:24.800]  какой критерий того, что не лежит. Так, о чем это я был? О том, что функции, которые... вот US множество,
[45:24.800 --> 45:38.160]  оно будет... сейчас... останавливаться, это holds. Зачем я начал S использовать? Ну ладно, раз начал,
[45:38.160 --> 45:49.200]  то уже начал. В общем, проблема в том, что здесь как раз мы будем проверять остановку. Остановка
[45:49.200 --> 45:54.480]  это конечное число шагов. Поэтому если функция остановилась, то она остановилась. Все, у нас нету
[45:54.480 --> 46:02.640]  вариантов того, что нужно подождать пару шагов или бесконечности. Вот, здесь нужно быть внимательным.
[46:02.640 --> 46:13.040]  Откуда что мы можем сказать? Что, например, к тотальным... сейчас... тотальным и ни к чему другому из
[46:13.040 --> 46:28.280]  этого сести не можем. Поэтому V точно не отрабатывает. Дальше... сейчас... US к S. OK, по табличке
[46:28.280 --> 46:34.680]  возможно. То есть смотрим, чтобы не было такого, что минус перешел к плюсу. Вот этого точно нельзя.
[46:34.680 --> 46:54.920]  H0 к T OK, S0 к H0 OK. Теперь начинаем думать, можно ли это осуществить.
[46:54.920 --> 47:07.920]  А, ну еще G невозможно, потому что да, тут плюс-минус, а здесь минус-плюс. Такие программы друг другу не
[47:07.920 --> 47:15.000]  сводятся. Ужух. У нас осталось вот первые два пункта, которые, казалось бы, по табличке в целом
[47:15.000 --> 47:20.120]  вообще возможны. Но если табличка говорит, что возможно, значит, пытаемся придумать сводимость.
[47:20.120 --> 47:26.400]  В целом, если время меняем в обрез, ну, все то, что осталось... все то, что возможно по табличке,
[47:26.400 --> 47:41.240]  то и отмечаем. Это, кстати, я бы назвал достаточно сложным заданием. Начнем. Множество самоприменимых
[47:41.360 --> 47:57.680]  сводится к нуду с программ, останавливающихся в нуде. Просто построим по программе самоприменимых
[47:57.680 --> 48:16.720]  программ. Ух. То есть программ с номером. То есть у нас есть программа. Вот такая вот у nt от x. Мы по этой
[48:16.720 --> 48:42.360]  функции построим функцию следующую. Функцию f от x равняется у от nn. Мы взяли вот наши функции,
[48:42.360 --> 48:51.560]  просто разбили вот ее самоприменимость на все аргументы. Сделали такую а-ля константу,
[48:51.560 --> 49:08.320]  которая... ну, либо константа, либо функция нигде вообще не завершается. И что теперь происходит?
[49:08.320 --> 49:15.840]  Если m самоприменима, то она останавливается. Соответственно у нас, что функция f от x останавливается
[49:15.840 --> 49:26.800]  в нуде. Если функция у nt не останавливается, то и функция f от x тоже не останавливается в нуде.
[49:26.800 --> 49:39.160]  Ну какая здесь аналогия? Ну если у нас была функция самоприменимая, там f от x, мы по ней
[49:39.160 --> 49:52.480]  строим функцию g от x равную f0. Но если она останавливается в 0, то та будет самоприменима.
[49:52.480 --> 49:55.160]  Не останавливается, то та тоже сама неприменима.
[49:55.160 --> 50:17.840]  А теперь время следующего номера.
[50:17.840 --> 50:42.520]  Что происходит в данном случае?
[50:47.840 --> 50:54.680]  Тридцать шестая задача. Здесь есть два варианта того, как может быть. Множество
[50:54.680 --> 51:00.840]  программ может быть и некоперечислимым, и неперечислимым. В таком случае вам
[51:00.840 --> 51:08.800]  нужно будет сводить множество тотальных функций к функциям из условия. Либо оно будет только
[51:08.800 --> 51:15.320]  коперечислимо, либо оно будет только коперечислимо, или только перечислимо. В таком случае вам
[51:15.320 --> 51:25.240]  нужно показать одну и дальше доиспользовать теоремы Райя Суспенского. В общем, здесь понятно,
[51:25.240 --> 51:30.960]  теорема Райя Суспенского даст неразрешимость, и я утверждаю, что это множество коперечислимо.
[51:30.960 --> 51:38.480]  Почему? Так.
[51:38.480 --> 52:08.440]  Будем перебирать тройки вида МХ.
[52:08.480 --> 52:21.560]  И будем делать что? Запускаем
[52:21.560 --> 52:39.960]  МТЮ машину тюринга, ну программу, то есть машину тюринга, на входе Х, на время Т,
[52:39.960 --> 52:59.560]  на Т шагов. Если завершилось, и выход нечетный,
[52:59.560 --> 53:12.040]  следовательно, не принадлежит. Следовательно, вывод.
[53:12.040 --> 53:33.120]  Это алгоритм коперечисления. Для программ, которые где-то определены, хоть где-то определены,
[53:33.120 --> 53:43.840]  это точно работает. Возникает вопрос, а что если у меня, в принципе, программа, которая никогда,
[53:43.840 --> 53:53.000]  нигде не завершается, ни на каком входе. В таком случае, я, в принципе, никогда ее не смогу здесь
[53:53.000 --> 54:01.400]  вывести. Это будет означать, что она должна принадлежать этому множеству. Но и действительно,
[54:01.400 --> 54:07.840]  если программа нигде не определена, то у нее множество значений, это пустое множество. А для
[54:07.840 --> 54:16.280]  пустого множества все свойства выполнено. Все значения, все элементы пустого множества,
[54:16.280 --> 54:23.240]  вычетные, да, все верно. Поэтому также здесь еще нужно добавить комментарии про
[54:23.240 --> 54:49.480]  случаи, нигде не останавливающихся программ. Ну, откуда имеем коперечислимость?
[54:53.240 --> 55:09.480]  Плюс теорема райса Успенского равняется неперечислимости. Но опять же, про теорема райса Успенского нужно будет
[55:09.480 --> 55:16.800]  сказать пару слов, что это множество нетривиально. Показать, что действительно это нетривиально,
[55:16.800 --> 55:29.960]  привести пример, когда лежит, когда не лежит. Пример того, что это множество не пусто, вот такая
[55:29.960 --> 55:40.960]  функция. То, что дополнение множества не пусто, вот такая функция. Все, показали, что действительно
[55:40.960 --> 55:47.760]  условия теоремы райса Успенского верны, соответственно, можем ее использовать. Вот это вот не забываем.
[55:47.760 --> 56:01.400]  Но опять же, на самом деле, это тоже не до конца. Теоремы райса Успенского даст неразрешимость,
[56:01.400 --> 56:09.680]  и надо будет сказать, что еще плюс теорема поста. Вот про это не забывайте. Сама по себе,
[56:09.680 --> 56:17.560]  только теоремы райса Успенского это не даст. Нужен еще критерий поста. Что у нас осталось? У нас осталось...
[56:17.560 --> 56:38.320]  У нас осталось 37 номер. Он про свадимость.
[56:47.560 --> 57:12.840]  Я поставлю здесь красное, здесь желтое. Что с машинами тюринга? У нас не перечислимо,
[57:12.840 --> 57:24.320]  не ко перечислимо. Есть такая комбинация, то используем Т. Если не перечислимо, а не ко перечислимо,
[57:24.320 --> 57:37.400]  используем множество тотальных функций. Если перечислимо, не ко перечислимо, используем
[57:37.400 --> 57:44.840]  множество самоприменимых. Не перечислимо, ко перечислимо, используем дополнение множества
[57:44.840 --> 57:53.880]  самоприменимых. Все. Сразу понимаем, что будем использовать, после этого проводим
[57:53.880 --> 58:15.400]  саму М-свадимость. Покажем, что множество тотальных функций сводится к множеству М. Я вот этот
[58:15.400 --> 58:27.280]  положу за М. Хорошо. Итак, пусть у меня есть некоторые функции f от x принадлежит М. Мне
[58:27.280 --> 58:41.320]  нужно по ней построить, сейчас скажу, некоторые тотальные функции. Хорошо. Как я буду ее строить?
[58:41.320 --> 59:08.760]  Нет, у меня есть некоторые t от x, тотальная функция. У меня есть теорема о том, что М и П,
[59:08.760 --> 59:19.480]  они равномочны, то есть существуют некоторые объекции. Назовут их f. Она вычислима, вычислимая
[59:19.480 --> 59:42.600]  объекция, там все хорошо, поэтому я могу сделать следующее. Давайте я возьму и скажу, что я по t от x
[59:42.600 --> 59:56.640]  построю М от x. М от x принадлежит М. И буду я это делать все функционалом psi. Как работает
[59:56.640 --> 01:00:14.600]  функционал psi? Функционал psi берет себя функцию t и возвращает функцию M. Давайте я так запишу.
[01:00:14.600 --> 01:00:32.840]  Функционал psi на функции t в точке x, то есть это равняется M от x, равняется следующим образом.
[01:00:32.840 --> 01:00:56.760]  Функция t, тотальная, от psi минус 1 от x, если x принадлежит простым числам. Не определено,
[01:00:56.760 --> 01:01:23.880]  если x не принадлежит простым. Что теперь мы имеем? Сейчас скажу. Если t, можно сказать,
[01:01:23.880 --> 01:01:51.200]  что psi из комы M с водимостью. В чем тут идея? Почему сделано так? Если t, тотальное, то у любого
[01:01:52.080 --> 01:01:59.400]  x из п будет какой-то некоторый прообраз в N, соответственно, применив к нему t, мы получим какое-то значение.
[01:01:59.400 --> 01:02:07.360]  Действительно, множество областей определения будет совпадать множеством простых чисел. Получается,
[01:02:07.360 --> 01:02:14.360]  M будет лежать в M. Если же t не тотальная, то будет какой-то аргумент, на котором она не определено.
[01:02:14.360 --> 01:02:23.880]  Это означает, что для некоторого, ну понятно, что для некоторого, сейчас скажу, для некоторого
[01:02:23.880 --> 01:02:37.960]  натурального числа будет некоторый прообраз, будет образ в простых числах, и вот на нем окажется,
[01:02:37.960 --> 01:02:46.880]  что функция будет неопределена. Поэтому область определения у M не совпадет с простыми числами,
[01:02:46.880 --> 01:02:55.000]  и в результате это будет действительно M с водимостью. Зачем мы делали вот это вот phi? Потому
[01:02:55.000 --> 01:03:02.720]  что, казалось бы, зачем вообще оно нам нужно? Мы могли бы просто сразу делать t от x. А что,
[01:03:02.720 --> 01:03:10.840]  если t это не тотальная функция, которая определена на всех x, кроме x равного 6? 6 не является простым.
[01:03:10.840 --> 01:03:20.200]  Поэтому, в таком случае, функция t построит нам вполне себе функцию M, у которой область
[01:03:20.200 --> 01:03:26.000]  определения будет совпадать с областью простых чисел. Именно для этого мы перевели все простые в
[01:03:26.000 --> 01:03:37.080]  некоторые натуральные числа, чтобы гарантировать, что если t где-то не останавливается,
[01:03:37.080 --> 01:03:48.480]  то вот это натуральное число мы его получим в качестве аргумента. Хорошо, и вроде последний
[01:03:48.480 --> 01:04:11.040]  номер. Да, последний номер. 38. Скажу честно, я уже не помню какие варианты к нему,
[01:04:11.040 --> 01:04:17.920]  поэтому, возможно, я его оценивать не буду. Тот, который здесь есть, но он не особо сложный.
[01:04:17.920 --> 01:04:27.680]  Логика выполнения здесь следующая, что нам нужно неразрешимое множество, любое бесконечное
[01:04:27.680 --> 01:04:34.000]  множество, которое также неразрешимое. Для этого нам нужно воспользоваться следующим свойством.
[01:04:34.000 --> 01:04:47.680]  Первое. Разрешимых множеств счетно. Соответственно, мы можем их нумеровать.
[01:04:47.680 --> 01:05:03.400]  Поехали. Давайте считать, что это номерация. Буду, наверное,
[01:05:03.400 --> 01:05:18.840]  играть в их омега 1, омега 2, омега 3, омега 4 и так далее. Также я скажу,
[01:05:18.840 --> 01:05:26.000]  что не просто это разрешимое множество, а разрешимое множество, мощность которых бесконечна.
[01:05:33.400 --> 01:06:00.760]  Ну и поехали. Имеем вот такую табличку. 0, 1, 2, 3, 4, 5, 6 и так далее. Это номерация элементов.
[01:06:00.760 --> 01:06:11.160]  Здесь по строкам будет номерация самих множеств. Омега 0, омега 1, омега 2,
[01:06:11.160 --> 01:06:25.360]  омега 3, 4, 5, 6 и так далее. Ну и поехали. У меня здесь вот так вот элементы и добро.
[01:06:30.760 --> 01:06:40.640]  Чем идея в том, что давайте мы просто для любого такого множества выкинем один элемент. В
[01:06:40.640 --> 01:06:48.520]  таком случае у нас получится нужное. Осталось просто правильно это сделать.
[01:06:48.520 --> 01:06:55.960]  Как мы будем это делать? Сейчас скажу.
[01:06:55.960 --> 01:07:20.760]  У 0 множества 8 0 его элементы. И скажем, что вот этот элемент мы берем,
[01:07:20.760 --> 01:07:36.120]  вот этот вот обязательно мы не берем. Хорошо. В следующем множестве,
[01:07:36.120 --> 01:07:48.960]  сейчас неразрешимое множество, любое бесконечное множество тоже неразрешимое. Хорошо. Мы берем,
[01:07:48.960 --> 01:07:59.200]  идем и проверяем, что первый элемент, который можно взять. Вот предыдущий элемент, его взяли.
[01:07:59.200 --> 01:08:08.560]  Берем и идем дальше, не берем после него. Первый элемент, который нельзя, который новый будет.
[01:08:08.560 --> 01:08:20.240]  Дальше. Следующий множество. Первый элемент новый, если есть мы берем, который не встретился,
[01:08:20.240 --> 01:08:30.000]  не берем и так далее. Отметим, что на каждом шаге у нас берется лишь конечное число элементов и
[01:08:30.000 --> 01:08:36.280]  аналогично лишь конечное число элементов было выкинуто. Поэтому рано или поздно найдется для
[01:08:36.280 --> 01:08:45.880]  любого омега некоторый элемент, который мы еще ранее не использовали, поэтому его можно будет взять
[01:08:45.880 --> 01:08:58.480]  и найдется элемент, который можно выкинуть. Таким образом, мы пройдемся по всем разрешимым множествам
[01:08:58.480 --> 01:09:09.840]  и все взятые элементы дадут нам именно то множество, которое мы хотим. Почему это сработает? Потому
[01:09:09.840 --> 01:09:19.320]  что если вдруг у нас есть некоторые бесконечные под множество, которое разрешимо, то значит выбранное
[01:09:19.320 --> 01:09:27.320]  нами множество пересекает, ой, выбранное наше множество содержит некоторую строчку. А этого не
[01:09:27.320 --> 01:09:38.680]  может быть, потому что мы с каждой строчки вычеркнули один элемент хотя бы. Все. Задача решена.
[01:09:38.680 --> 01:09:49.880]  Ну, на этом у меня все. Если есть вопросы, можете задавать. Если нет, то в целом все. Контрольная не
[01:09:49.880 --> 01:09:59.080]  сложная, местами чуть неприятная. Вот этот вот момент, наверное, это самый сложный, но он сложный
[01:09:59.080 --> 01:10:05.520]  за счет того, что здесь он нужно работать с функционалами, хотя до этого нигде с функционалами
[01:10:05.520 --> 01:10:11.480]  не работали. То есть, по сути, вам нужна функция, которая берет на вход функцию и строит другую
[01:10:11.480 --> 01:10:18.440]  функцию. Вот это вот вещь не особо интуитивно понятная и здесь действительно может быть непонятно.
[01:10:18.440 --> 01:10:25.920]  Там и сложно придумать сразу, не нужно там больше времени. Все остальное легко, достаточно. Ну,
[01:10:25.920 --> 01:10:32.480]  35-я тут. Ну, тут, опять же, просто поставить вот эту табличку для всех множеств. В целом,
[01:10:32.480 --> 01:10:40.560]  наверное, процентов 50 всех множеств мы рассмотрели здесь. На самом деле, n здесь можно заменять не
[01:10:40.560 --> 01:10:54.240]  только на n, а на какой-то тут картридж из n1, nk и все также работает. Ну, только конечный картридж,
[01:10:54.240 --> 01:11:00.440]  конечно же. У меня все. Ну, видим, вопросов нет, тогда всем спасибо.
[01:11:10.560 --> 01:11:12.480]  Все, пока-пока.
