[00:00.000 --> 00:08.440]  Всем доброго дня! Мы с вами продолжаем изучать курс технологии
[00:08.440 --> 00:14.160]  программирования. Сегодня у нас четвертая лекция. В прошлой лекции была без, как помните,
[00:14.160 --> 00:20.040]  без проектора, но сегодня вроде нам повезло, и у нас проектор заработал. Кстати, вполне возможно
[00:20.040 --> 00:25.280]  он заработал по той причине, что я подключил зарядник к своему ноутбуку. Это вполне может
[00:25.280 --> 00:32.400]  быть. Организационное объявление. Первое организационное объявление стоит в том,
[00:32.400 --> 00:37.920]  что сайт обновился, и в нем появилась возможность устных сдач. То есть по техническим заданиям,
[00:37.920 --> 00:43.120]  начиная с первого, будут устные сдачи. Вы договариваетесь со своими ассистентами,
[00:43.120 --> 00:51.200]  записываетесь на слоты и приходите сдавать задания. Что касается тем, мы почему решили
[00:51.200 --> 00:56.000]  так сделать, потому что в предыдущих запусках курса было так, что вы сдаете задания, а потом
[00:56.000 --> 01:00.800]  забываете, что вы сделали в этом задании. А как говорится, процесс долговременной памяти,
[01:00.800 --> 01:07.640]  он работает как минимум в три такта. Если мы, грубо говоря, вспомним, как у нас происходит процесс
[01:07.640 --> 01:16.720]  затухания информации, запоминания информации, то у нас будет три экспонента. Первое затухание
[01:16.720 --> 01:20.920]  будет приблизить на таким, соответственно, если вы подкрепляете какими-то знаниями,
[01:20.920 --> 01:26.120]  оно у вас повышается, у вас кривая экспонента идет такой, и потом, когда вы в третий раз
[01:26.120 --> 01:33.920]  обучаете, у вас кривая экспонента идет вот такой, точнее затухающий экспонент. Ну и понятно,
[01:33.920 --> 01:39.280]  что первый процесс это сдача задания, возможно, когда-то вы столкнетесь с этим в проекте и не
[01:39.280 --> 01:45.800]  хватало третьей стадии. Поэтому у нас будет устная сдача, значит, вы будете получать уведомления
[01:45.800 --> 01:52.920]  также о сдаче и не сдаче задания о том, что вы приглашаетесь к устной защите, то есть у вас
[01:52.920 --> 01:58.280]  будет две стадии. Первая это код-ревью, который вы проходите в самом задании, а потом вы общаетесь
[01:58.280 --> 02:07.080]  по тем преподавателям. Вот, будет три попытки устной сдачи, ну я надеюсь, что там с первой,
[02:07.080 --> 02:14.640]  со второй попытки максимально все получат свои баллы. Вот, естественно, понятно, что те замечания,
[02:14.960 --> 02:19.680]  которые вам дают на устной сдаче, их лучше доработать для того, чтобы потом на следующей устной сдаче у вас
[02:19.680 --> 02:24.520]  все было хорошо. Это первое организационное объявление, второе организационное объявление. У нас
[02:24.520 --> 02:30.840]  наступает конец февраля, да, сегодня, кстати, не последний день февраля, напомню, год высокосный,
[02:30.840 --> 02:37.560]  завтра будет последний день февраля, но в целом у нас будет еще одно выданное техническое задание,
[02:37.560 --> 02:43.160]  я думаю, оно будет выданное сегодня и сразу скажу, что оно будет двухуровневым. Это означает,
[02:43.160 --> 02:49.680]  что вы можете сдать одно задание, но получить чуть меньше баллов и можете сдать второе задание и
[02:49.680 --> 02:54.280]  получить максимальный балл. Одно задание будет проще, чем другое. Можно на выбор будет делать одно
[02:54.280 --> 02:59.000]  из них. Возможно, мы поступим хитрее и скажем, что второе задание будет больше баллов давать,
[02:59.000 --> 03:05.240]  чем базовый балл. Упраздно говоря, если у вас первое задание оценивается на 100%, то второе
[03:05.240 --> 03:13.880]  будет оцениваться на 120%. Это второе замечание и третье замечание, поскольку у нас заканчивается
[03:13.880 --> 03:19.440]  февраль, то в начале марта мы сделаем форму опроса, она будет полностью анонимной, вам нужно будет
[03:19.440 --> 03:25.200]  написать отзывы о курсе, тем самым мы с вами сможем получить обратную связь и двигаться дальше.
[03:25.200 --> 03:37.600]  Так, есть ли еще вопросы по организации процесса нашего? Хорошо, тогда давайте продолжим. Сегодня у
[03:37.600 --> 03:42.120]  нас такая будет смешанная тема. Мы сегодня, во-первых, будем говорить про UML, про который я хотел
[03:42.120 --> 03:47.560]  говорить в прошлый раз, но у нас этого не получилось по причине того, что нужно показывать большое
[03:47.560 --> 03:52.520]  количество диаграмм. И закончим тему, связанную с методологиями разработки ПО, программного
[03:52.520 --> 04:02.680]  обеспечения. Давайте вспомним, что мы с вами разобрали в прошлый раз. Мы с вами разобрали
[04:02.680 --> 04:11.960]  систему версионирования. Что еще разобрали? Подходы к разработке ПО, какие факторы влияют,
[04:11.960 --> 04:18.920]  и еще начали рассматривать сами методологии разработки. Какие мы с вами успели уже посмотреть?
[04:22.920 --> 04:29.440]  Waterfall, V-модель и спиральную модель. Мы с вами рассмотрели три методологии, как раз которых
[04:29.440 --> 04:37.320]  обычно не хватает. Точнее, базовые, и они, как говорится, зачастую не используются. Дополнительно,
[04:37.320 --> 04:43.240]  мы с вами еще разобрали два паттерна. Это адаптер и фасад. Хорошо, давайте сейчас мы вкратце напомним,
[04:43.240 --> 04:48.840]  в чем какие методологии разработки ПО бывают и какие бывают в стадии разработки ПО. Значит,
[04:48.840 --> 04:54.680]  их на самом деле немного больше. Я перечислил только основные стадии. Значит, смотрите,
[04:54.680 --> 04:59.520]  опять же, это концептуально большая картинка. У нас сначала есть какая-то идея к продукту,
[04:59.520 --> 05:04.640]  потом мы с вами описываем требования к продукту. Они бывают функциональные и не функциональные.
[05:04.640 --> 05:08.960]  Функциональные это означает, что вы выполняете какую-то функцию, у вас получается результат.
[05:08.960 --> 05:15.440]  Не функциональный это, которое зачастую нельзя описать в виде там требований к функции. Пример
[05:15.440 --> 05:21.840]  функционального требования. При нажатии на кнопку X у вас должна открываться страница Y.
[05:21.840 --> 05:28.960]  Пример не функциональных требований. У вас сайт, я не знаю, ваша программа должна отрисовывать
[05:28.960 --> 05:35.120]  красивые кнопочки, разноговоря, и чтобы вы зашли на какой-нибудь интернет магазин и купили товар
[05:35.120 --> 05:41.720]  как можно быстрее. То есть по факту в какое количество кликов вы можете это сделать. Или,
[05:41.800 --> 05:46.120]  допустим, мы с вами можем сказать, что когда вы заходите на сайт, он кажется вам незнакомым,
[05:46.120 --> 05:53.040]  и здесь нам очень важно будет удобство сопровождения. Если вы играли в какие-то игры,
[05:53.040 --> 06:00.840]  то с чего начинаются любые игры? С обучения. Нам нужно как раз адаптировать нашего пользователя
[06:00.840 --> 06:08.360]  под обучение. Точнее, адаптировать пользователя под наш продукт через обучение. Сейчас, конечно,
[06:08.360 --> 06:14.400]  это делают все интерактивным, с завязкой на сюжет, но в целом обучаемость это важный фактор.
[06:14.400 --> 06:23.280]  Дальше мы говорим с вами про дизайн, и смотрите, не путать это с классическим дизайном. То есть это
[06:23.280 --> 06:29.280]  именно системный дизайн. Есть даже такая специальная аббревиатура, точнее перевод,
[06:29.280 --> 06:37.040]  System Design. В русском языке я бы сказал, что это архитектура программного обеспечения,
[06:37.520 --> 06:42.520]  про которую мы тоже с вами говорили как раз до этого. После этого у нас идет стадия разработки,
[06:42.520 --> 06:48.440]  после разработки идет стадия тестирования. Мы с вами поняли на самом деле, что в V-модели мы
[06:48.440 --> 06:56.800]  можем приступать, по крайней мере, к намеченным тест-планам до того, как мы с вами приступаем к
[06:56.800 --> 07:02.200]  стадии разработки. То есть мы можем уже наметить наш тест-план. После этого у нас возникает
[07:02.200 --> 07:09.680]  развертывание нашего проекта. То есть мы должны его где-то развернуть, либо выдать сайт с
[07:09.680 --> 07:16.400]  установочными файлами, либо сказать, пожалуйста, откройте сайт, зайдите на сервис, и он у нас будет
[07:16.400 --> 07:21.640]  работать. После этого у нас идет долгая стадия поддержки нашего программного продукта. Мы как
[07:21.640 --> 07:28.040]  раз в версионировании это говорили, что обычно описывает период поддержки. И самый такой важный
[07:28.040 --> 07:34.640]  процесс, который обычно не хватает, это этап закрытия этого продукта. Потому что проект закрыть
[07:34.640 --> 07:42.000]  это тоже надо уметь. Потому что, ладно, вы закрываете какой-нибудь проект внутри какой-то
[07:42.000 --> 07:48.080]  компании. Вот мы, извините, пожалуйста, мы не будем обновлять новую версию. Все такое. А если
[07:48.080 --> 07:54.280]  продукт не взлетел, то понятно, что нам так или иначе нужно будет вернуть все деньги и, собственно,
[07:54.280 --> 08:00.280]  рассчитаться с нашими клиентами. Вот, кстати, пример на прошлой неделе. По-моему, да, он как раз
[08:00.280 --> 08:06.840]  был в прошлую среду. Пример того, каким образом может внезапно произойти закрытие кое-чего.
[08:06.840 --> 08:18.760]  Да, Центробанк это звал лицензию Банка Киви. Да, да, да, все. Этот сервис больше не работает на
[08:18.760 --> 08:23.400]  территории нашей страны. И, естественно, им теперь надо рассчитываться со всеми. То есть у нас
[08:23.400 --> 08:29.160]  может быть какое-нибудь закрытие, которое есть плавным, а есть принудительное закрытие. Вот,
[08:29.160 --> 08:34.880]  и к принудительному закрытию тоже нужно быть готовым при желании. Так, значит, вы каскадной
[08:34.880 --> 08:39.560]  модели. Давайте напомним, у нас есть с вами по факту пять стадий, которые идут последовательно
[08:39.560 --> 08:47.240]  друг за другом. И видно, что к предыдущей стадии нам будет тяжело вернуться. Вот, значит, плюсы этой
[08:47.240 --> 08:54.360]  схемы, что у нас схема достаточно простая. Можно просчитать затраты. Важно здесь правильно
[08:54.360 --> 09:00.840]  просчитать затраты. И смотрите, здесь важный процесс. Помните, я рисовал в прошлый раз диаграмму о том,
[09:00.840 --> 09:06.720]  что у нас процессы плавно переходят друг в друга. Поэтому чисто водопадную модель воспринимать не
[09:06.720 --> 09:15.240]  стоит. У нас может быть связь между последовательными стадиями. Вот у новой модели. Напоминаю, что
[09:15.240 --> 09:19.720]  параллельно тому, как мы прорабатываем с вами бизнес-требования, некоторые функциональные и
[09:19.720 --> 09:24.900]  системные требования, архитектура и реализацию, у нас параллельно выстраивается другая пирамида,
[09:24.900 --> 09:29.680]  так называемая пирамида тестирования. То есть у нас появляется приемоздаточное тестирование.
[09:29.680 --> 09:38.040]  Да, это такой русский термин. Его обычно сокращают как приемка. Дальше функциональное тестирование или
[09:38.040 --> 09:43.920]  системное тестирование. Это мы проверяем наши требования, как работает вся система целиком.
[09:43.920 --> 09:50.000]  Интеграционная система. Мы смотрим, как модули между собой взаимодействуют, компоненты. И последнее
[09:50.000 --> 09:54.840]  это модульное тестирование. То есть когда мы тестируем классы либо какие-то компоненты и пакеты.
[09:54.840 --> 10:01.080]  То есть образно говоря, вы написали модуль, связанный с геометрией, а дальше вам нужно подружить его
[10:01.080 --> 10:06.640]  с модулем отрисовки для экрана. То есть у нас возникает связь между компонентами, нам нужно
[10:06.640 --> 10:10.600]  проверить их взаимодействие. В деталях мы будем рассматривать это в лекциях по тестированию.
[10:10.600 --> 10:17.320]  Значит, следующая диаграмма. Это спиральная модель. Мы тоже с вами про нее поговорили, когда вы
[10:17.320 --> 10:23.520]  говорили, что мы с вами разрабатываем какую-то модель. И у нас с вами по факту идет спираль. То
[10:23.520 --> 10:29.080]  есть мы сначала анализируем риски. Точнее мы получаем концепцию продукта. Потом начинаем работать
[10:29.080 --> 10:34.640]  с требованием. Приходим еще раз на согласование. Потом мы оцениваем риски. Прототип создаем модель.
[10:34.640 --> 10:41.840]  Делаем какой-то маленький прототип. Потом у нас появляется план разработки модели проектирования.
[10:41.840 --> 10:47.880]  Потом мы верифицируем и валидируем наш проект. Не путать валидацию и верификацию. Это два разных
[10:47.880 --> 10:58.400]  термина. Образно говоря, знаете, как я бы скажу, что такое верификация и валидация? Валидация.
[10:58.400 --> 11:11.960]  Представьте себе, что у вас задание по мотону. Как легко пройти валидацию. Очень просто. Вы берете
[11:11.960 --> 11:16.520]  домашню, какую-нибудь прошлогоднюю, какого-то товарища, которую он сдал на полный балл,
[11:16.520 --> 11:24.800]  переписываете ее себе, сдаете. Вот это валидация. По формальным требованиям у вас все пройдет
[11:24.800 --> 11:32.840]  успешно. Когда произойдет верификация, что вы ничего не понимаете? Либо на экзамене,
[11:32.840 --> 11:38.080]  либо на устной сдаче этого домашнего задания. То есть мы проверяем на стадии верификации то,
[11:38.080 --> 11:44.000]  что как бы тот продукт, который мы делаем, он действительно делает важные вещи, и мы понимаем,
[11:44.000 --> 11:49.320]  как эти вещи делаются. А валидация – это просто то, что все проходит по формальной требованию. То
[11:49.320 --> 11:53.280]  есть в нашем случае на технологиях программирования по факту валидация – это сдача задания,
[11:53.280 --> 11:57.920]  в систему получения полного балла. А верификация – это устная сдача.
[11:57.920 --> 12:05.400]  Вот. А дальше, собственно, мы пишем план тестирования, и вот на каждой стадии у нас
[12:05.400 --> 12:09.880]  появляется какая-то модель. То есть у нас сначала может быть маленькая модель, потом уже модель,
[12:09.880 --> 12:16.480]  образно говоря, какого-то там одного вагона из всего поезда, который мы потом будем дополнительно
[12:16.480 --> 12:23.000]  тестировать и дорабатывать с учетом хода обратной связи. И я вам говорил, что в предыдущий раз,
[12:23.000 --> 12:27.680]  что сроки проекта как раз за счет каждой из этих стадий мы можем с вами регулировать.
[12:27.680 --> 12:34.760]  Вот. Это то, за что отвечает спиральная модель. Это было напоминание с прошлой лекции. Есть ли
[12:34.760 --> 12:48.800]  вопросы по сравнению, которые остались с прошлой лекции? Так. Теперь следующая модель. Переходим к
[12:48.800 --> 12:55.480]  более интересным вещам. Это итеративная модель. Значит, в чем она заключается? Мы сначала планируем
[12:55.480 --> 13:02.160]  наш продукт, а потом начинаем запускать определенные итерации нашего продукта. Они обычно не очень
[13:02.160 --> 13:08.280]  большие. Ну, зависит на самом деле от самого проекта. Если мы смотрим на классическую итеративную
[13:08.280 --> 13:13.520]  модель, то продолжительность итерации может быть несколько месяцев. То есть вы говорите,
[13:13.520 --> 13:19.240]  окей, у вас есть первая итерация проекта, вторая итерация проекта, третья итерация проекта. Причем,
[13:19.240 --> 13:23.920]  смотрите, хочу сказать важное, что в итеративной модели зачастую количество итераций фиксировано.
[13:23.920 --> 13:31.760]  И по результатам каждой из итераций что-то у вас будут ожидать. Вот. После того, как, собственно,
[13:31.760 --> 13:37.120]  мы проводим... Тут у нас видим классический цикл ПО. То есть у нас планирование, требование,
[13:37.120 --> 13:41.760]  архитектура, реализация тестирования. После этого мы проводим некоторую оценку, там,
[13:41.760 --> 13:48.240]  ревью кода, ревью всяких там процедур. И после этого мы снова переходим на следующую итерацию
[13:48.240 --> 13:54.120]  планирования. То есть как бы нам нужно полный цикл пройти, прежде чем мы с вами переходим на
[13:54.120 --> 14:00.160]  новую стадию. Вот. А после того, как мы понимаем, что наш продукт готов, после тестирования мы его
[14:00.160 --> 14:08.960]  запускаем и начинаем поддерживать. Вот. Здесь хочу подчеркнуть, что количество стадий является
[14:08.960 --> 14:18.960]  фиксированным. То есть количество итераций является фиксированным. В чем отличие этой
[14:18.960 --> 14:40.640]  модели от модели спиральды? Как понимает? Нет, не совсем. Значит, смотрите, еще раз поясню. В
[14:40.640 --> 14:46.920]  итеративной модели итерации больше заточены про то, чтобы создать какой-то прототип. То есть он
[14:46.960 --> 14:52.560]  даже может не быть похожим на реальный продукт. То есть и спиральная модель хорошо, в принципе,
[14:52.560 --> 15:02.560]  подходит для разных, так сказать, не программистских вещей. То есть у нас, видите, здесь последний
[15:02.560 --> 15:08.680]  цикл в этой спирали. У нас есть прототип, а потом у нас есть рабочий прототип, поверх которого мы
[15:08.680 --> 15:14.160]  уже пишем программный продукт. То есть для того, чтобы выйти по факту на финальную стадию водопадной
[15:14.160 --> 15:20.920]  модели, мы проходим несколько стадий верификации, а потом мы действуем по водопадной модели. Потому
[15:20.920 --> 15:27.040]  что мы уже все прототипы отработали и все готово. Нам остается просто это, так сказать, отмасштабировать
[15:27.040 --> 15:33.320]  и перенести в реальные условия. А здесь мы как раз сами несколько итераций работаем с программным
[15:33.320 --> 15:48.360]  продуктом. Вот так. Понятно ли суть вот этой модели? Вот здесь главное будет понять ее. Ну ладно,
[15:48.360 --> 15:55.080]  давайте тогда, если будет вопрос, может будет задать их после. Значит, плюсы. Она хорошо работает
[15:55.080 --> 16:02.640]  для меньших команд, потому что как бы итерацию бежать можем для команд поменьше. Дальше снижение
[16:02.640 --> 16:08.960]  рисков. То есть мы снижаем вероятность того, что из-за того, что мы получаем каждый раз обратную
[16:08.960 --> 16:14.960]  связь, мы сильно уменьшаем вероятность того, что в конце что-то пойдет не так. Вот представьте
[16:14.960 --> 16:23.520]  себе, что образно говоря, вы работаете над каким-то проектом и вам никогда не дают обратную связь.
[16:23.520 --> 16:30.800]  Ну просто забывают дать обратную связь по каким-то там заданиям, задачам и так далее. И понятно,
[16:30.880 --> 16:37.840]  что мы тогда с вами строем непонятную ситуацию, а что же у нас будет на выходе. Поэтому важно
[16:37.840 --> 16:47.000]  именно здесь получать обратную связь на выходе каждой итерации. Смотрите, обратная связь может
[16:47.000 --> 16:51.360]  исходить от следующих людей. Это может быть заказчик. То есть вы делаете какой-то проект под
[16:51.360 --> 17:03.360]  заказ. Вы пришли к дяде Пете, которому нужно, образно говоря, открыть какой-нибудь не простой
[17:03.360 --> 17:09.680]  интернет-магазин. В базовом случае вы говорите, у вас есть первая итерация, приходите к дяде Пете,
[17:09.680 --> 17:15.960]  показываете первую версию сайта. Он говорит, фигня, короче, нельзя тут заказать, образно говоря,
[17:15.960 --> 17:23.280]  шурму. Неудобно, нет выбора вкуса. Вы идете следующую итерацию, планируете задачу для того,
[17:23.280 --> 17:29.240]  чтобы появилась новая версия шурма. Говорит, не пойдет, говорит, молодежные тренды, там онлайн
[17:29.240 --> 17:35.840]  доставка на самокатах и так далее. Вы идете делать вторую итерацию. Но понятно, что единственное
[17:35.840 --> 17:42.760]  момент следующее, что здесь нужно будет дядю Васю остановить и сказать, что вот, типа мы работаем
[17:42.760 --> 17:49.880]  с вами по итерациям. То есть у нас итерация 1, 2, 3, 4. И на выходе каждой итерации было бы неплохо описать.
[17:49.880 --> 17:56.440]  То есть ваша цель, допустим, Вася приходит, дядя Петя приходит, говорит, мне нужен онлайн сайт
[17:56.440 --> 18:03.640]  с доставкой, вот это вот все. То есть у вас здесь финальная стадия, дальше у вас здесь получается
[18:03.640 --> 18:24.120]  будет сайт. Здесь, допустим, сайт с выбором товаров. Здесь сайт с доставкой. И четвертая стадия это
[18:24.120 --> 18:30.280]  полностью готовый сайт, в котором, допустим, идет какие-то уже исправления, ошибок. Вот это
[18:30.280 --> 18:34.240]  итеративная модель. Мы заранее прописали с вами четыре итерации, по которым мы с вами готовы
[18:34.240 --> 18:48.040]  работать. Так, я ответил на вопрос? Тут вопрос задавал. Да, все. Хорошо, давайте перейдем к
[18:48.040 --> 18:55.120]  следующей модели. Следующая модель интересная, она называется инкрементная. Да, минусы, значит,
[18:55.120 --> 19:00.040]  забыл сказать про итеративную модель. Минусы непонятны, когда конец этого проекта. То есть,
[19:00.040 --> 19:08.320]  если мы заранее ограничим количество итерации, это может продолжаться бесконечно. Так, а следующая
[19:08.320 --> 19:14.360]  модель является инкрементной. И здесь она очень сильно похожа на итеративную модель, но ее лучше
[19:14.360 --> 19:19.480]  именно продемонстрируешь вот такой картинкой. При итеративном подходе, представьте себе, что мы
[19:19.480 --> 19:26.880]  рисуем монолизу. И в итеративном подходе как бы мы рисовали? Мы сначала бы нарисовали эскиз,
[19:26.880 --> 19:33.320]  потом его уточнили, потом нанесли бы какие-то цвета, раскрасили их в определенный фон, то есть
[19:33.320 --> 19:38.040]  сначала бы мы отсегментировали картинку, то есть для каждого цвета определили, какой тематики идет.
[19:38.040 --> 19:45.960]  Дальше делали на грубое начертание и получили бы в результате выход монолиз. А что такое
[19:46.920 --> 19:55.240]  инкрементная модель? Вы говорите, что вы делаете задания, но вы делаете как бы не улучшаете каждый
[19:55.240 --> 20:00.040]  сайт, который был на каждой стадии, а вы делаете его по кускам. То есть сначала сделали одну часть,
[20:00.040 --> 20:06.720]  потом сделали вторую часть, третью часть, и в итоге у вас сайт собрался. А дальше вы говорите
[20:06.720 --> 20:14.240]  следующее. Окей, ну в чем минус инкрементной модели? Что вам как бы сразу заранее надо понимать,
[20:14.240 --> 20:20.440]  какую часть модели вам нужно перенести вашего программного продукта. То есть если у вас есть
[20:20.440 --> 20:26.320]  вот четкое разделение на какие-то наборы компонент и вы четко знаете, как каждую из этих компонентов
[20:26.320 --> 20:34.560]  делать, то тогда можно принять инкрементальную модель. Но обычно происходит так. Вы понимаете,
[20:34.560 --> 20:42.440]  каким образом можно оценить, типа пойдет все по плану или нет? Как вы думаете?
[20:42.440 --> 20:52.560]  Нет, в инкрементной модели, да. Есть, кстати, классический пример инкрементной модели,
[20:52.560 --> 21:06.200]  и, кстати, он практикуется на этапе обучения. У кого задавальник с собой есть или он сейчас в онлайнах?
[21:06.200 --> 21:21.360]  В онлайнах. Откройте любой задавальник. Что вы увидите? Задание 1, задание 2, задание 3, задание 4.
[21:21.660 --> 21:27.240]  Вот у вас четыре итерации. Причем каждый из них считается независимо от другой. Сначала вы
[21:27.240 --> 21:31.480]  задаете первое задание, получаете какой-то бал, потом задаете второе задание, получаете какой-то бал,
[21:31.480 --> 21:35.240]  задаете третье задание, получаете какой-то бал. Задает 4 задение, получаете какой-то бал. То есть
[21:35.240 --> 21:40.360]  у вас как раз пример инкрементной модели. Если вы в какой-то из стадии не проходите,
[21:40.360 --> 21:46.800]  то вам ставят минус балла. Вот она и инкрементная модель. Понятно, что если вы
[21:46.800 --> 21:52.900]  вы получаете какую-то нехватку времени для наших задач,
[21:52.900 --> 21:57.600]  пудо получаем, в итоге, не знаю, что тут отрисовано.
[21:57.600 --> 22:04.360]  Тут конягу нарисовали, да, тут конь изображен на правом
[22:04.360 --> 22:05.360]  нижнем слайде.
[22:05.360 --> 22:09.000]  То есть, все это разваливается, и в итоге мы не получаем
[22:09.000 --> 22:10.880]  никаких знаний, никаких умений.
[22:10.880 --> 22:14.600]  Поэтому, опять же, желательно, если мы говорим про программный
[22:14.600 --> 22:17.160]  процесс, то лучше все-таки использовать итеративную
[22:17.160 --> 22:18.160]  модель.
[22:18.160 --> 22:21.720]  Вопрос, давайте сразу на понимание.
[22:21.720 --> 22:24.800]  Какую модель вы будете использовать в проекте?
[22:24.800 --> 22:26.800]  Да, итеративную.
[22:26.800 --> 22:27.800]  Почему?
[22:27.800 --> 22:32.800]  Потому что у нас в базаре есть первая итерация.
[22:32.800 --> 22:33.800]  Угу.
[22:33.800 --> 22:38.800]  Просто если мы почитаем, что у нас требуется, то у нас
[22:38.800 --> 22:41.800]  требуется, что все будет очень позитивно писать.
[22:41.800 --> 22:42.800]  Да.
[22:42.800 --> 22:43.800]  Именно так.
[22:43.800 --> 22:46.120]  То есть, вас сначала просят маленький-маленький прототип
[22:46.120 --> 22:49.520]  создать, потом его расширить, потом его еще раз расширить.
[22:49.520 --> 22:53.200]  Да, а в конце еще и тесты написать к нему.
[22:53.200 --> 22:54.200]  Вот.
[22:54.200 --> 22:55.200]  То есть, у нас итеративная модель.
[22:55.200 --> 22:57.680]  С инкраментной моделью было бы очень печально писать
[22:57.680 --> 22:58.680]  проекта.
[22:58.680 --> 23:01.040]  То есть, напишите один модуль, второй модуль, третий модуль.
[23:01.040 --> 23:02.040]  Это плохо.
[23:02.040 --> 23:03.040]  Хорошо.
[23:03.040 --> 23:07.040]  Но вопрос здесь такой, почему мы с вами в проектах
[23:07.040 --> 23:11.640]  останавливаемся на итеративной модели?
[23:11.640 --> 23:12.640]  Хотите, я объясню?
[23:12.640 --> 23:13.640]  Потому что вы не работаете.
[23:13.640 --> 23:19.480]  Не работаете не в том плане, что вы не трудитесь, вы действительно
[23:19.480 --> 23:20.480]  трудитесь.
[23:20.480 --> 23:23.960]  Тут надо не перемешивать понятия труд и работа,
[23:23.960 --> 23:25.880]  а работаете именно полноценно.
[23:25.880 --> 23:30.760]  То есть, идете в офис либо на дистанционном формате,
[23:30.760 --> 23:34.360]  работаете по 8 часов в день, 5 дней в неделю.
[23:34.360 --> 23:35.360]  Да.
[23:35.360 --> 23:38.080]  Поэтому у вас есть другие проекты, другие предметы,
[23:38.080 --> 23:39.080]  мы это понимаем.
[23:39.280 --> 23:43.480]  У нас такие по факту какая-то эмуляция рабочей деятельности.
[23:43.480 --> 23:46.280]  Именно эмуляция трудовой деятельности.
[23:46.280 --> 23:50.320]  Но если вы работаете, то скорее всего вы уже не встретите
[23:50.320 --> 23:52.000]  ни одну из этих моделей.
[23:52.000 --> 23:54.800]  Вы встретите одну из двух следующих методологий.
[23:54.800 --> 23:59.120]  Первая методология, которая есть, это Agile.
[23:59.120 --> 24:01.920]  Про него, возможно, вы слышали, это гибкие методологии
[24:01.920 --> 24:02.920]  разработки.
[24:02.920 --> 24:07.320]  Она заточена на итеративном процессе, просто величина
[24:07.320 --> 24:10.920]  этих итераций, она очень небольшая.
[24:10.920 --> 24:12.720]  Она порядка нескольких недель.
[24:12.720 --> 24:16.080]  То есть, в некоторых компаниях прямо одна-две недели.
[24:16.080 --> 24:20.000]  При этом вы получаете плотную связь с коллегами, потому
[24:20.000 --> 24:22.880]  что все работают, все работают тем же продуктом.
[24:22.880 --> 24:25.240]  Она отлично работает для малых команд.
[24:25.240 --> 24:30.600]  Значит, она по факту есть такое понятие, что человек,
[24:30.600 --> 24:33.400]  который вот работает и вообще пытается акцентировать
[24:33.400 --> 24:36.480]  фокус на какой-то информации, может запомнить, как вы
[24:36.640 --> 24:37.640]  знаете, сколько объектов?
[24:37.640 --> 24:41.080]  Да, семь плюс-минус два.
[24:41.080 --> 24:45.520]  Собственно, Agile в методологии хорошо подходит на концепциях
[24:45.520 --> 24:47.000]  семь плюс-минус два человека.
[24:47.000 --> 24:49.080]  То есть, если у вас команда такая, то, в принципе, вы
[24:49.080 --> 24:50.840]  можете спокойно контролировать процесс.
[24:50.840 --> 24:56.680]  Значит, у вас здесь видно, что прямо все вещи, все итерации
[24:56.680 --> 24:59.200]  проходят взаимозаменимым друг с другом.
[24:59.200 --> 25:04.000]  То есть, вы можете перекидывать все, что у вас есть, от стадии
[25:04.000 --> 25:06.600]  требований к стадии архитектуры и дизайна.
[25:06.600 --> 25:08.400]  От стадии архитектурного дизайна, если что-то пошло
[25:08.400 --> 25:11.720]  не так, вы осмотрите быстро темвление, возвращаетесь
[25:11.720 --> 25:12.720]  обратно.
[25:12.720 --> 25:13.720]  То же самое разработка.
[25:13.720 --> 25:15.240]  И начинается веселая вещь.
[25:15.240 --> 25:17.200]  Вы разработали какой-то продукт, сразу передали
[25:17.200 --> 25:18.560]  его в тестирование.
[25:18.560 --> 25:21.000]  На тестирование получили быстро обратную связь, вернули
[25:21.000 --> 25:22.000]  обратно в разработку.
[25:22.000 --> 25:24.840]  То есть, вы бьете проект на атомарные единицы.
[25:24.840 --> 25:29.520]  Вот, это все достаточно хорошо работает для малых
[25:29.520 --> 25:30.520]  команд.
[25:30.520 --> 25:32.120]  Значит, давайте я скажу следующее.
[25:32.120 --> 25:34.520]  Здесь обычно говорят, что гибкие методологии, это
[25:34.520 --> 25:37.960]  типа устарелы, это прошлый век, это нам не нравится,
[25:37.960 --> 25:41.520]  но это все зависит от того, каким образом эта методология
[25:41.520 --> 25:42.520]  соблюдается.
[25:42.520 --> 25:44.680]  Правильным образом или неправильным образом.
[25:44.680 --> 25:48.800]  Потому что зачастую люди, которые начитались умных
[25:48.800 --> 25:52.320]  книжек про Agile, такие думают, ну все, сейчас мы Agile внедрием
[25:52.320 --> 25:53.320]  в компанию.
[25:53.320 --> 25:56.600]  И это заканчивается полным развалом.
[25:56.600 --> 25:57.600]  Вот.
[25:57.600 --> 26:00.960]  А и поэтому здесь нужно сказать следующее.
[26:01.040 --> 26:03.880]  Здесь у меня на самом деле опечатка в презентации.
[26:03.880 --> 26:07.040]  Давайте я поправлю ее сразу.
[26:07.040 --> 26:12.680]  Значит, это не технология Kanban, это Cramban называется
[26:12.680 --> 26:13.680]  технология.
[26:13.680 --> 26:15.120]  Kanban, она находится в другом месте.
[26:15.120 --> 26:19.840]  Значит, в гибких методологиях есть некоторые подтипы,
[26:19.840 --> 26:20.840]  которые мы можем внедрять.
[26:20.840 --> 26:25.640]  Одно из самых первых парадигм, которое возникло в гибких
[26:25.640 --> 26:28.080]  методологиях, это был extreme programming.
[26:28.080 --> 26:29.280]  Экстремальное программирование.
[26:29.280 --> 26:34.520]  Вы не поверите, но я вам скажу, что, как ни странно,
[26:34.520 --> 26:37.560]  вы уже работали в парадигме экстремального программирования,
[26:37.560 --> 26:40.080]  только не совсем правильно работали в этой парадигме.
[26:40.080 --> 26:44.520]  Зачастую вы работаете в парадигме экстремального
[26:44.520 --> 26:47.680]  программирования, когда сидите 5 часов в 3 человека
[26:47.680 --> 26:48.680]  за одним компьютером.
[26:48.680 --> 26:55.600]  Были такие моменты в жизни?
[26:55.600 --> 26:56.600]  У некоторых до сих пор есть.
[26:56.740 --> 26:58.560]  Теперь представьте,
[26:58.560 --> 27:01.440]  что не вы три программиста, тринадцать программистей
[27:01.440 --> 27:02.960]  один математик в команде.
[27:02.960 --> 27:04.980]  Где то такое разделение.
[27:05.460 --> 27:06.880]  А представьте себе,
[27:06.880 --> 27:09.260]  что сидит либо программист и математик, и математик
[27:09.260 --> 27:13.260]  должен объяснить программисту как писать код.
[27:13.260 --> 27:14.400]  А теперь представьте,
[27:14.400 --> 27:17.340]  что вместо математика и программиста сидит программист
[27:17.340 --> 27:21.240]  и дядя Вася, про которого мы сегодня говорили.
[27:21.240 --> 27:26.300]  И говорит, дядя Вася, пожалуйста, ему facade с выбором заказов,
[27:26.300 --> 27:30.900]  доставкой и так далее. Ну и сразу смотрится результат. Это называется парное
[27:30.900 --> 27:36.500]  программирование. Вот, то есть, когда прямо на лету, прямо действия какие-то делают.
[27:36.500 --> 27:41.700]  Понятно, что это работает хорошо, но когда у вас там очень-очень маленькая команда и в принципе
[27:41.700 --> 27:47.420]  заказчик готов сидеть, в нашем случае заказчик это или какое-то производство, либо какой-то клиент
[27:47.420 --> 27:53.780]  готов прямо с вами сидеть и вот прямо общаться и править код на лету. Понятно, что до такого не
[27:53.780 --> 27:58.980]  дошли и поэтому, так или иначе, самая активная гибкая методология, которая применяется на сегодняшний
[27:58.980 --> 28:06.580]  день, является методология Scrum. Вот, есть еще смесь двух методологий Scrum и Kanban. Про
[28:06.580 --> 28:11.740]  Kanban мы поговорим подальше, потому что это другая методология. Это методология под названием Scrumban.
[28:11.740 --> 28:22.580]  Давайте как раз мы рассмотрим, из чего состоит Agile. Значит, что происходит, как вообще создавался
[28:22.580 --> 28:31.020]  Agile. Это произошло в начале 21 века, где-то в конце 20-х, начале 21 века. Значит, собрались люди, причем,
[28:31.020 --> 28:36.780]  если вы сейчас, мы откроем список создателей Agile-манифеста, то вы внезапно удивитесь,
[28:36.780 --> 28:43.380]  потому что скорее всего половину этих людей, где-то добрую часть этих людей, скорее всего вы слышали,
[28:43.380 --> 28:50.700]  потому что они написали очень большое количество книг, которые читаются и по сей день. Давайте я
[28:50.980 --> 28:58.860]  открою Agile-манифеста. Вот, собственно, вот она Agile-манифеста. Вот видно как раз создатели этого
[28:58.860 --> 29:03.700]  Agile-манифеста как раз обсуждают кое-что. Здесь написано все на английском языке, но в принципе
[29:03.700 --> 29:10.300]  мы можем перевести это все на русский язык. Давайте я как раз переведу на русский язык.
[29:10.300 --> 29:19.500]  Вот, значит, причем видите, это уже международно сертифицированная история. Ну, я не знаю, кого из
[29:19.500 --> 29:43.140]  них. Возможно, это. Это авторы Agile-манифеста. Мы видим с вами, что их 17 человек. Ну, давайте
[29:43.140 --> 29:51.420]  я расскажу. Значит, Роберт Мартин. Создатель вообще концепции чистого кода и сейчас у него достаточно
[29:51.420 --> 29:56.780]  большое количество книг выходит. Значит, если мы говорим про Мартина Фаулера, это как раз тоже
[29:56.780 --> 30:03.020]  про организацию качества кода. Самая известная книга, его называется Refactoring. Давайте, сейчас я
[30:03.020 --> 30:17.580]  буду открывать. А это как раз все практические книги. Да, конечно. Они работали в компании. Допустим,
[30:17.580 --> 30:24.540]  тот же самый Роберт Мартин написал фреймворк для тестирования. Фитнес называется. Который до
[30:24.540 --> 30:34.420]  сих пор используется. Вот она, книга. Вот она, Refactoring. То есть, это прямо классическая книга.
[30:34.420 --> 30:42.100]  Тот видно, что Мартин Фаулер связан с Кентом Бэк. А Кентом Бэк считают создателем парадигмы
[30:42.100 --> 30:47.900]  тест-дривен-девелопонт, которая как раз рождается из Ви-модели. И здесь еще есть большое количество
[30:47.900 --> 30:54.900]  людей, которые достаточно известны. Джефф Сазерленд, Варт Каннингем и так далее. Поэтому давайте
[30:54.900 --> 31:03.460]  познакомимся с методологиям. Но важно здесь именно акцентировать внимание на то, что здесь указано. Так,
[31:03.460 --> 31:12.100]  давайте сейчас еще раз. Agile Manifesto состоит из четырех пунктов. Причем они здесь именно правильно
[31:12.100 --> 31:16.900]  сделаны. Первое, это люди и взаимодействие важнее процессов инструментов. То есть, взаимодействие
[31:16.900 --> 31:22.180]  между людьми важнее теми инструментами, которыми мы используем. Работающий продукт важнее исчерпывающей
[31:22.180 --> 31:33.060]  документации. Вопрос. Кто-нибудь писал хоть раз документацию? Ну, пришлось, да? Вот. Сотрудничество
[31:33.060 --> 31:38.740]  с заказчиком важнее согласования условий контракта. То есть, как бы важно говорить с заказчиком,
[31:38.740 --> 31:44.100]  а не кусаться и отцапаться с ним. Про контракт можно параллельно обсуждать. И готовность изменения
[31:44.460 --> 31:49.060]  важнее исследования первоначальным планом. То есть, видите, в чем заключается гибкость? То есть,
[31:49.060 --> 31:56.340]  гибкость заключается в том, что именно мы постараемся изменяться как можно чаще. То есть,
[31:56.340 --> 32:00.980]  за счет того, что у нас величина и итерация очень небольшая, мы это вполне сможем делать. Но,
[32:00.980 --> 32:10.020]  смотрите, важную часть, которую обычно забывают все, не стоит забывать про важность правых частей.
[32:10.020 --> 32:15.980]  То есть, они важнее, но про правую часть забывать не стоит. Потому что про исчерпывающую документацию
[32:15.980 --> 32:22.940]  вы просто не сможете продать, передать свой продукт в случае вашего успеха. Опять же,
[32:22.940 --> 32:27.500]  люди и взаимодействие важнее процессового инструмента. Про это обычно забывают менеджеры.
[32:27.500 --> 32:33.100]  Если вдруг вы станете менеджерами, пожалуйста, не забывайте, что программистам больше нравится
[32:33.100 --> 32:42.020]  писать код, а не общаться с другими людьми. Да, бывает такое, потому что там созвоны, созвоны,
[32:42.020 --> 32:46.860]  созвоны, созвоны. И потом-то вы задолбали со своими созвоны. Можно мне, пожалуйста,
[32:46.860 --> 32:54.740]  и тип код написать? Вот. Ну, то есть, а это важно, но важно при этом еще исследовать процессы
[32:54.740 --> 33:02.220]  инструмента. Значит, и, во-первых, мы с вами понимаем, что мы можем с вами меняться в каких-то
[33:02.780 --> 33:08.100]  аспектах, но при этом следование определенному плану очень важно. То есть, как бы у нас есть
[33:08.100 --> 33:12.860]  вектор какой-то развития, в который мы смотрим. Понятно, что мы можем от него немного отклониться,
[33:12.860 --> 33:18.780]  но в целом мы придем к нашей цели. То есть, потому что вы начинаете работать над проектом, вы не
[33:18.780 --> 33:23.940]  знаете, что у вас произойдет по ходу действия этого проекта. Там, допустим, новый закон появится,
[33:23.940 --> 33:29.940]  какие-то новые конкуренты появятся, и вам нужно максимально к этому адаптироваться.
[33:29.940 --> 33:42.620]  Так, давайте я спрошу. Вот этот слайд понятен? Понятно, что он, я скажу сразу, что пока вы не
[33:42.620 --> 33:47.660]  поработаете по гибкой методологии, это будет сложно понять, но в целом хоть какая-то адаптация
[33:47.660 --> 33:55.660]  по роклевую забывание, все-таки мы с вами поговорим. Значит, теперь принципы Agile. Их всего 12 штук.
[33:55.660 --> 34:03.900]  Значит, давайте проговорим их. Первое это про приоритеты. Наивысшим приоритетом является
[34:03.900 --> 34:09.980]  удовлетворение потребности заказчика благодаря регулярной и ранней поставке ценного программного
[34:09.980 --> 34:16.300]  продукта. То есть, это закладывает в следующее, что после каждой итерации нам нужно получать
[34:16.300 --> 34:22.500]  новую версию продукта. И желательно после каждой итерации прямо общаться с заказчиком и понимать,
[34:22.980 --> 34:28.900]  окей, не окей. И как ни странно, когда вы это будете делать, вы обнаружите, что у вас огромное
[34:28.900 --> 34:34.100]  количество багов будет на демонстрации. Серьезно, то у вас база данных упадет,
[34:34.100 --> 34:38.700]  то у вас проект не запустится и так далее. Допустим, вы ставили на своем компьютере,
[34:38.700 --> 34:44.420]  у вас какое-то количество большое, локально все работали, как-то на костылях это все держалось,
[34:44.420 --> 34:51.380]  вы переносите это на другой компьютер, не работает. Увы. Дальше. Изменение требований
[34:51.380 --> 34:57.460]  приветствуется даже на поздних стадиях разработки. Как раз процессы, которые выстраиваются,
[34:57.460 --> 35:03.100]  позволяют использовать изменения для обеспечения заказчику конкурентного преимущества. То есть,
[35:03.100 --> 35:08.540]  вы можете, за счет чего эта металлогия называется гибкость, то вы можете адаптироваться под
[35:08.540 --> 35:19.620]  процессом. Но важно, что здесь мы говорим про гибкость. Это не означает, что люди,
[35:19.620 --> 35:27.020]  которые работают внутри этой металлогии, могут подстроиться. Несмотря на то, что металлогия гибкая,
[35:27.020 --> 35:34.740]  к ней очень сложно адаптироваться самим людям. Поэтому это зачастую люди не могут сделать.
[35:34.740 --> 35:42.460]  Дальше. Работающий продукт следует выпускать как можно чаще, с периодичностью от пары недель
[35:42.460 --> 35:49.860]  до пары месяцев. Это концепция Agile, которая говорит о том, что как бы каждая итерация должна
[35:49.860 --> 35:56.660]  идти от двух недель до пары месяцев. Некоторые строятся неделю-две недели. И, как ни странно,
[35:56.660 --> 36:07.660]  вы думаете сейчас, как вы думаете, это много или мало две недели? Очень мало. На самом деле,
[36:07.660 --> 36:15.260]  некоторые считают, что это много уже. Потому что сейчас появилась другая концепция. Она идет из
[36:15.260 --> 36:21.700]  другой металлогии разработки, но с точки зрения классической разработки она использует Agile. Это
[36:21.700 --> 36:32.900]  концепция Devops. Возможно, слышали про такое. Это связь development и operations. То есть команда
[36:32.900 --> 36:37.300]  разработки и команда техподдержки. Давайте мы в какой-то момент времени поговорим про то,
[36:37.340 --> 36:42.940]  какие роли бывают в командах и вообще, какие бывают разработчиками и какие бывают операционистами.
[36:42.940 --> 36:48.620]  Так вот, здесь как раз в некоторых версиях говорится, что новая версия продукта может
[36:48.620 --> 36:53.860]  появляться по требованию. То есть, мы внедрили новый функционал, он сразу поехал в производство.
[36:53.860 --> 36:59.460]  Но опять же, для этого нужны большое количество инструментов. И как раз, так сказать, базовый
[36:59.460 --> 37:08.420]  девопспрактики, как ни странно, мы осваиваем в технических заданиях. То есть, с гитом пользоваться,
[37:08.420 --> 37:13.180]  командной строкой пользоваться. Ну, понятно, что базовый механизм. А к концу вы увидите как
[37:13.180 --> 37:17.820]  раз концепции, которые именно затачиваются под девопспрактики. Но опять же, с точки зрения
[37:17.820 --> 37:23.460]  разработчика, понятно, что новый продукт, грубо говоря, небольшой командой очень сложно выпускать
[37:23.460 --> 37:30.660]  за один день. Ну, это практически нереально. Так, по этим принципам есть вопросы? Сейчас мы на
[37:30.660 --> 37:38.580]  следующий слайд перелезем. Следующее. На протяжении всего проекта разработчики и представители бизнеса
[37:38.580 --> 37:45.060]  должны ежедневно работать вместе. Опять же, почему не подходит для нас? Потому что это ежедневная
[37:45.060 --> 37:50.980]  коллаборация. Понятно, что у вас здесь, допустим, есть другие предметы. А дальше, вот это важный
[37:50.980 --> 37:56.940]  момент. Над проектом должны работать мотивированные профессионалы. Это означает следующее, что нужно
[37:56.940 --> 38:02.180]  обеспечить условия, обеспечить поддержку и полностью довериться им. И как раз мы здесь понимаем,
[38:02.180 --> 38:10.180]  говорим про концепцию печеньки в офисе, тренажерные залы и все условия иже с ними. То есть, пытаются
[38:10.180 --> 38:17.580]  людей именно таким образом загнать в офис. Понятно, что у разных людей разная мотивация. Вот. Кого-то
[38:17.580 --> 38:24.340]  это будет далеко не интересовать. То есть, именно здесь в том деле нам нужны именно профессионалы
[38:24.340 --> 38:29.540]  своего дела, которые четко смогут выполнять требования, которые к ним наложены. То есть,
[38:29.540 --> 38:35.020]  здесь нужно принимать ответственность. То есть, люди в команде должны быть ответственными и открытыми
[38:35.020 --> 38:41.060]  друг с другом. Значит, дальше. Непосредственно общение является наиболее практичным и эффективным
[38:41.060 --> 38:47.420]  способом обмена информации как самой команды, так и внутри команды. Смотрите, сейчас это,
[38:47.420 --> 38:54.260]  да, но поскольку у нас немножко в двадцатых годах поменялась практика, то сейчас, в принципе,
[38:54.260 --> 38:59.620]  мессенджеры и дистанционная связь в принципе решают эту проблему. Конечно, у нас скорость
[38:59.620 --> 39:05.660]  коммуникации замедляется, но в целом это можно делать. То есть, как бы сейчас, если бы мы с вами
[39:05.660 --> 39:11.140]  общались со всеми по почте и вы бы приходили на пары, это было бы, ну, крайне неэффективно. Поэтому
[39:11.140 --> 39:16.540]  мы, собственно, сидим в мессенджерах и пытаемся именно работать с ними. Хотя, кстати, проводили
[39:16.580 --> 39:22.100]  исследование. Забавное исследование говорит о том, что продуктивность онлайн образования составляет
[39:22.100 --> 39:30.860]  55 процентов от продуктивности очного образования. Это, правда, исследование уже давнее, но оно во
[39:30.860 --> 39:35.860]  время ковида как раз всплыло. То есть, иногда полезно именно непосредственно общаться друг с
[39:35.860 --> 39:43.660]  другом. Поэтому мы стараемся, собственно, и подключить команду ассистентов, чтобы мы сократили
[39:43.660 --> 40:02.500]  этот цикл. Так, по этим трем принципам. Нет, смотрите, значит, это хороший вопрос. Нет, конечно,
[40:02.500 --> 40:08.260]  это понятно, что так. Но вот у нас должна быть еще и стадия обучения сотрудников. То есть, если
[40:08.260 --> 40:12.980]  мы, помните, что если мы в компанию приглашаем каких-то других людей, то мы должны быть,
[40:12.980 --> 40:17.500]  их должны обучать не только замотивированные профессионалы, да, профессионалы от своего
[40:17.500 --> 40:22.660]  дела, а еще и должны быть преподаватели, так сказать, кураторы, которые вводят их в курс дела и,
[40:22.660 --> 40:30.340]  ну, мотивируют то, чтобы вот изучай новые технологии, мы тебе поможем. Вот. Да, кстати,
[40:30.340 --> 40:36.580]  вот в сфере образования с мотивированными профессионалами обычно возникает беда. Сразу
[40:37.060 --> 40:44.300]  говорю по опыту. Так, последняя вещь. Так, следующая страница. Работающий продукт – основной
[40:44.300 --> 40:53.620]  показатель прогресса. Если у вас что-то не запускается – увы, идите чинить. Дальше.
[40:53.620 --> 40:59.700]  Значит, инвесторы, разработчики и пользователи должны иметь возможность поддерживать постоянный
[40:59.700 --> 41:06.340]  ритм бесконечно. Значит, тут сразу нужно сказать про белку в колесе. Пожалуйста, не делайте этого,
[41:06.340 --> 41:12.020]  то есть нужно, грубо говоря, если вы готовы бежать долго, ну, как бы это, так сказать,
[41:12.020 --> 41:19.020]  марафон. Это не спринт, где можно, ай, давайте за ночь все заботаем и пойдем сдадим, а потом
[41:19.020 --> 41:25.060]  все забудем. Нет, в таком ритме нужно работать постоянно, его нужно уметь выдерживать. Поэтому
[41:25.060 --> 41:31.340]  это тяжелая методология, и Agile позволяет наладить такой устойчивый процесс разработки. То есть,
[41:31.340 --> 41:37.420]  грубо говоря, если что-то пойдет не так, мы сразу сможем с вами отреагировать. И последняя вещь – это
[41:37.420 --> 41:42.940]  постоянное внимание к техническому совершенству и качеству проектирования позволяет повышать
[41:42.940 --> 41:47.860]  гибкость проекта. То есть, как бы у нас получается, если мы технически совершаем все, мы с вами говорили
[41:47.860 --> 41:53.460]  про архитектуру. Если наша архитектура является гибкой, то, соответственно, с гибкой методологией
[41:53.460 --> 41:59.060]  разработки она будет работать очень удачно. Поэтому мы с вами и говорили про солид и про разные
[41:59.060 --> 42:05.580]  концепции. То есть, что мы выкидываем лишние, рассматриваем только основные вещи. Так, по этим
[42:05.580 --> 42:20.980]  трех принципам. Вопросы? Хорошо. Опять же, связь с простотой. Значит, простота искусства минимизации
[42:20.980 --> 42:27.460]  лишней работы крайне необходима. То есть, смотрите, иногда бывает такое, что вам какую-то вещь проще
[42:27.460 --> 42:34.300]  сделать самостоятельно, сделать ручками, нежели чем ее автоматизировать. Конечно,
[42:34.300 --> 42:38.340]  на автоматизацию потратите большое количество времени, но, возможно, более простое решение – это
[42:38.340 --> 42:43.140]  пойти ручками сделать. Значит, если вы делаете это уже пятый или десятый раз, скорее всего,
[42:43.140 --> 42:49.780]  одно из тех, скорее всего, вам его надо автоматизировать. Просто время, которое затрачивается на эту величину,
[42:49.780 --> 42:58.820]  на этот процесс нужно изменять. Так, значит, дальше. Тоже важный момент. Самые лучшие
[42:58.820 --> 43:02.980]  требования архитектурно-технических решений ожидается у самоорганизующихся команд. То есть,
[43:02.980 --> 43:09.820]  в agile'е подразумевается то, что вас никто из-под палки не пинает. То есть, нужно готовиться к
[43:09.820 --> 43:16.660]  тому, что вы самостоятельно будете улучшать свой продукт. И команда должна систематически
[43:16.660 --> 43:21.340]  анализировать возможную способу улучшения эффективности и, соответственно, корректировать стиль своей работы.
[43:21.340 --> 43:29.500]  То есть, тут опять же мы говорим про нерабочее время. Сейчас обычно людей закидывают помидорами
[43:29.500 --> 43:35.540]  за это все дело. Но все-таки параллельно стоит смотреть, какие технологии выходят. Возможно,
[43:35.540 --> 43:42.260]  там можно перейти на какой-то более новый фреймворк, либо посмотреть какая-то новая технология. Но именно
[43:42.260 --> 43:49.460]  попытаться что-то внедрить из тех практик, которые появляются. Ну, вы говорите, вот вышла вот такая
[43:49.460 --> 43:54.940]  вот новая вещь, давайте ее внедрим, образно говоря, для того, чтобы мы каждый раз руками там не диплоили,
[43:54.940 --> 44:00.100]  ну не развертывали наше приложение. И в итоге развертывание нашего приложения будет занимать не,
[44:00.100 --> 44:07.980]  не знаю, полдня, а минут десять. Допустим, вчерашний человек обновился минут за десять.
[44:07.980 --> 44:18.540]  Просто из-за счета наличия таких инструментов. Но, опять же, напоминаю, что взаимодействие
[44:18.540 --> 44:23.260]  важнее инструментов и процессов, но инструменты и процессы помогают как раз большую часть времени
[44:23.260 --> 44:31.300]  говорить про взаимодействие. Так, это было 12 принципов Agile. Давайте вопросы по ним.
[44:37.980 --> 44:43.980]  Окей. Давайте тогда едем дальше. Значит, теперь поговорим про технологию, как раз,
[44:43.980 --> 44:50.540]  с которой можно это делать. Самая популярная гибкая технология является Scrum. Значит, в чем
[44:50.540 --> 44:56.780]  он заключается? У нас есть некоторые итерации, которые называются спринтами. Значит, продолжительность
[44:56.780 --> 45:03.420]  спринта всегда фиксирована, и она занимает от одного до четырех недель. В классических
[45:03.420 --> 45:09.580]  компаниях спринт это две недели. Значит, в каких-то там проектах они работают одна неделя. А теперь,
[45:09.580 --> 45:15.980]  смотрите, что здесь есть. Давайте расскажу. Значит, есть такой человек под названием product
[45:15.980 --> 45:23.060]  owner. Значит, кто он? Он, так называемый, владелец продуктом, это тот человек, который будет держать
[45:23.060 --> 45:28.180]  связь напрямую с заказчиком. То есть, понятно, что разработчики не очень любят общаться с
[45:28.180 --> 45:35.740]  заказчиком, с этим человеком, дяди Вася, так сказать. Дядя Петий мы его назвали. И ему
[45:35.740 --> 45:43.300]  делегируется общение с заказчиком. В чем его заключаются задачи? Он спрашивает, интервьюет
[45:43.300 --> 45:50.060]  этого заказчика и спрашивает, какие задачи нам нужно поставить. После этого у нас формируется
[45:50.060 --> 45:58.620]  так называемый список задач, который называется продуктовый бэклок. То есть, мы заполняем набор
[45:58.620 --> 46:03.340]  задач, которые у нас существуют для того, чтобы наш проект закончился. Понятно, что бэклок
[46:03.340 --> 46:10.380]  продуктовым может пополняться в течение работы. И мы с вами видим следующую вещь. То есть, у нас
[46:10.380 --> 46:16.580]  получается большой-большой список задач, которые нужно решать. После этого мы с вами переходим в
[46:16.940 --> 46:24.780]  планирование итераций еженедельных. Это называется спринт-планирование. Тут важно сказать, что на
[46:24.780 --> 46:31.500]  планирование спринта очень надо быть аккуратным. То есть, к нему надо заранее готовиться всем
[46:31.500 --> 46:37.140]  членам команды. Почему? Потому что если планирование спринта будет проводиться неопытной командой,
[46:37.140 --> 46:44.060]  это 4 часа просто согласовать. Вы хотите тратить 4 часа своего рабочего времени на то, чтобы
[46:44.060 --> 46:57.700]  планировать новую итерацию? Ну, как-то оплатят обычно за совершенные действия, за полученный
[46:57.700 --> 47:04.540]  продукт. Или вам будет удобнее обсудить все за полчаса и пойти работать. Возможно, что даже
[47:04.540 --> 47:10.820]  идти отдыхать, если вы все правильно сделали. Ну, не все же правильно, все грамотно распланировали.
[47:10.820 --> 47:20.860]  У нас возникает спринт-планирование-митинг, который может идти где-то от полчаса до четырех
[47:20.860 --> 47:29.420]  часов. Опытных команд полчаса, неопытных до четырех часов. Как ни странно, как вы начнете
[47:29.420 --> 47:34.820]  работать по скраму, у вас как раз продолжительность этих спринт-планирований будет постепенно
[47:34.820 --> 47:41.580]  уменьшаться. То есть в среднем. То есть у вас 4 часа. Реально были кейсы, когда там 20-30 минут все
[47:41.580 --> 47:48.380]  распланировали, побежали дальше. После этого у нас возникает небольшой список задач спринт-бэклог.
[47:48.380 --> 47:56.700]  И вот здесь возникает одна классическая ошибка, которую допускают продукт-оунеры либо еще какие-то
[47:56.700 --> 48:02.460]  вещи. Либо еще, допустим, вот товарищ, который, видите, про который мы не сказали, он называется
[48:02.460 --> 48:09.620]  скрам-мастер. Они говорят, окей, значит какая-то прилетела срочная задача от заказчика, нам ее нужно
[48:09.620 --> 48:19.140]  срочно внедрить. После этого вы идете либо говорите к вот этому товарищу, скрам-мастеру, либо
[48:19.140 --> 48:30.100]  продукт-оунер. Говори, иди вот туда. Вот. И вы имеете право его послать вот туда. Я не знаю, где баня
[48:30.100 --> 48:38.860]  находится. По-моему, баня где-то там находится. Нет, ближайшие баня находятся вон там. Вот туда
[48:38.860 --> 48:45.980]  их мы всех посылаем. Почему? Потому что спринт-бэклог это вещь зафиксированная. То есть вы фиксируете,
[48:45.980 --> 49:01.220]  вы фиксируете, да. Что? А, мне казалось, она в этом, на первомайке. Возможно, не одна баня есть.
[49:01.220 --> 49:10.660]  Или у меня топографический кретинизм. Ну ладно, короче, суть в том, что мы можем, если то людей
[49:10.660 --> 49:15.180]  послать в баню, потому что когда вы фиксируете спринт-бэклог, это именно набор задач, которые
[49:15.180 --> 49:19.660]  фиксируются на текущие турансы. То есть больше задач вы никаких не берете, не добавляете в этот
[49:19.660 --> 49:28.180]  список. Ваша цель будет за этот спринт как раз решить все эти задачи. Вот. После как раз завершения
[49:28.180 --> 49:34.700]  спринта у вас должна появиться новая итерация продукта. Ваше решение. Вот. И получаете финиш
[49:34.700 --> 49:41.660]  тропворка. После этого, значит, проводите спринт-ревью. То есть это обычно называется демо. То есть когда вы
[49:41.660 --> 49:46.340]  перед заказчиком показываете новую версию продукта, которая у вас получилась. Вот такая вот функциональность.
[49:46.340 --> 49:56.140]  Вот. И дальше вы говорите следующее. Окей. Значит, мы проводим еще одно совещание, не совещание,
[49:56.140 --> 50:04.380]  еще один собор, который называется ретроспектива спринта. И на ней вы составляете такую таблицу,
[50:04.380 --> 50:12.740]  которая состоит из двух пунктов. Первый пункт называется что мы сделали хорошо.
[50:12.740 --> 50:32.220]  Как вы думаете, как вторая называется? Нет. Нет. Да, что можно сделать лучше.
[50:32.220 --> 50:41.740]  То есть мы не критикуем друг друга. То есть, ну, нам не получилось, допустим, сделать вот это. Мы могли
[50:41.740 --> 50:49.980]  бы, допустим, лучше наладить коммуникацию в вот этом вот процессе. После этого наступает новая
[50:49.980 --> 50:56.900]  итерация. И вот здесь еще одна бывает ошибка. То есть ретроспектива это важный момент. Это саморефлексия.
[50:56.900 --> 51:01.820]  И здесь какую часть я еще не объяснил на этом слайде.
[51:01.820 --> 51:10.100]  Что, что, что?
[51:10.100 --> 51:24.980]  Смотрите, здесь важный, важный процесс в этом скраме заключается в следующем. Вы спрашиваете,
[51:24.980 --> 51:31.420]  действительно ли вам нужно срочно, срочно или, как говорят, до следующей недели потерпят. Вот,
[51:31.420 --> 51:36.020]  у нас же запланированные задачи. Потому что вообще заказчик бы тоже было бы неплохо знать, что вы
[51:36.020 --> 51:41.980]  по скраму работаете. Если он говорит, следующей недели потерпят, значит эта задача добавляется просто
[51:41.980 --> 51:47.980]  с повышенным приоритетом в следующий спринт. Если вот совсем строчняк-строчняк, то вы делаете
[51:47.980 --> 51:52.940]  следующее. Вы берете, останавливаете этот цикл, это называется экстренное завершение спринта,
[51:52.940 --> 52:00.700]  и собираетесь планировать новый спринт. Да, а не добавлять задачу. Собственно, здесь как раз возникает
[52:00.700 --> 52:07.020]  такая диаграмма. Каждая задача при этом спринте оценивается. Оценивается она в так называемых
[52:07.020 --> 52:13.820]  story points. Это сразу скажу не человек, а часы. Это некоторая сложность продукта. Значит,
[52:13.820 --> 52:23.660]  в story points. То есть главная ценность как раз с скрама то, что мы так сказать предоставляем
[52:23.660 --> 52:31.740]  некоторые user story. Что такое user story? Это по факту новая функциональность, которую вы хотите
[52:31.740 --> 52:38.220]  добавить. И каждое из этих user story оценивается в какое-то количество story points. То есть это
[52:38.220 --> 52:52.460]  сложность выполнения этой задачи. После этого, когда вы получаете какое-то количество story
[52:52.460 --> 53:00.860]  points, у вас возникает вот такая диаграмма. Значит, у вас есть какое-то количество story
[53:00.860 --> 53:06.740]  points для каждой суммарности задач, которые здесь есть. Сразу скажу баги не оцениваются. То есть,
[53:06.780 --> 53:11.100]  если у вас есть какие-то баги, то они не оцениваются. Их надо просто поправить. Это ваш долг.
[53:11.100 --> 53:20.220]  Надо определить, что это баг или фича. Если фича, то оценивается. Если баг, то нет.
[53:20.220 --> 53:32.620]  Нет, все-таки лучше отделять баги. Допустим, вы запланировали какие-нибудь 58 story points на
[53:32.620 --> 53:43.380]  эту неделю. И у вас возникает величина времени t. Допустим, у нас sprint это две недели. Дайте
[53:43.380 --> 53:51.980]  одна неделя. Дальше у вас возникает следующая вещь. У вас возникает вот такая диаграмма. Это
[53:51.980 --> 54:03.700]  называется диаграмма сгорания. Burn down chart. И это идеальная линия, по которой должен у вас идти
[54:03.700 --> 54:14.100]  процесс. 58 story points, которые мы запланировали на этот sprint. То есть, у вас какие-то задачи будут
[54:14.100 --> 54:19.460]  стоить 4 story points, 3 story points, 2 story points. Поэтому каждая задача будет ответственной о сайне.
[54:20.420 --> 54:30.420]  И вы начинаете сжигать эту диаграмму, начинаете выполнять задачу. Когда мы должны заказчика послать
[54:30.420 --> 54:41.220]  в баню, как мы можем понять по этой диаграмме? Не, значит, функция story points должна быть
[54:41.220 --> 54:47.260]  убывающей. Если она в какой-то момент времени возрастает, это означает, что вы в sprint добавили
[54:47.260 --> 54:56.540]  какую-то еще новую задачу. Такого делать не должно. Такого быть не должно, соответственно,
[54:56.540 --> 55:03.820]  вы должны всегда строить убывающую функцию. Знаете, я вам скажу следующее, что если вы увидите когда-нибудь
[55:03.820 --> 55:13.660]  вот такую функцию, я вам похопаю в ладоши. Потому что такой функции вы никогда не увидите. Значит,
[55:13.660 --> 55:20.780]  вот это идеальное кривое, ожидаемое, вот это идеальное кривое сгорание задачи. То есть,
[55:20.780 --> 55:26.260]  как бы получается, вы идете ровно с планом. И как вы думаете, может ли идти все по плану?
[55:26.260 --> 55:34.300]  Нет. Поэтому, значит, если мы говорим про, образно говоря, любую диаграмму сгорания,
[55:34.300 --> 55:37.700]  то она у нас будет выглядеть приблизительно вот так.
[55:43.660 --> 55:51.700]  Вот так как-то. Вот это уже более похоже на реальную диаграмму. Значит, как это мы можем назвать с вами?
[55:51.700 --> 56:02.020]  Мы вспомнили, что до дедлайна по окончанию спринта три дня и побежали решать задачи.
[56:02.020 --> 56:11.420]  Вы не поверите, даже есть специальный терпен, который, правда, мне прямо сказали. Знаете,
[56:11.420 --> 56:22.220]  какой он называется? Ну, можно и так сказать. На самом деле, это называется синдром студента.
[56:22.220 --> 56:30.740]  То есть, когда все вспоминают, что наконец-таки наступил дедлайн, пора бы все заканчивать.
[56:30.740 --> 56:38.620]  Вот. Соответственно, чтобы такого не было и хоть как-то контролировать этот процесс,
[56:38.620 --> 56:46.460]  есть такое понятие, как Daily Scrum. Значит, что это такое? Это небольшое совещание,
[56:46.460 --> 56:56.380]  в котором вы делаете следующую вещь. Каждый из людей отвечает на три вопроса. Причем, смотрите,
[56:56.380 --> 57:02.820]  здесь не очень хороший слайд. Здесь мы говорим, что у нас есть Daily Scrum. Он обычно называется Daily Stand Up.
[57:02.820 --> 57:20.700]  Да, почему Stand Up называют? Не-не-не. Нет, как переводится Stand Up в английском языке? Встань.
[57:20.700 --> 57:27.460]  Да, то есть, это совещание производится, когда все стоят. Серьезно, почему-почему
[57:27.500 --> 57:36.660]  проводится совещание, когда все стоят? Ну, нет, чтобы не было желания сесть. То есть,
[57:36.660 --> 57:42.980]  если вы хотите сесть уже, то это означает, что собрание идет слишком долго. Значит,
[57:42.980 --> 57:49.420]  здесь нужно по кругу каждому члену команды ответить на три вопроса. Первый вопрос. Что я
[57:49.420 --> 57:54.660]  сделал за предыдущую итерацию, за предыдущий день? Второе. С какими проблемами столкнулся?
[57:54.780 --> 58:01.580]  Нет, второй вопрос. Что я планирую делать сегодня? И третий вопрос. С какими проблемами
[58:01.580 --> 58:09.100]  столкнулся? Все, каждый человек должен возникнуть, и дальше разрешаются небольшие ответы. Я тебе помогу,
[58:09.100 --> 58:14.660]  образно говоря, столкнулся по такой проблеме. Можно спросить, кто-то готов помочь или не готов
[58:14.660 --> 58:21.380]  помочь. То есть, они отвечают, после собрания уже идут и разрешают все проблемы. На Daily Stand Up обычно
[58:21.380 --> 58:30.020]  занимают там до 15 минут в команде. Значит, если вдруг в команде приходит менеджер, вот этого не
[58:30.020 --> 58:36.860]  надо запускать. На Daily Stand Up лучше менеджеров не допускать, поскольку он говорит, ну вот у нас
[58:36.860 --> 58:42.140]  задачи горят, нам нужно решить вот эту проблему. И начинается следующее. Давайте мы с Daily Stand Up
[58:42.140 --> 58:49.260]  растянем на час. Потому что человеку просто общения не хватает. Вот так делать не надо. То есть,
[58:49.260 --> 58:56.020]  15 минут побежали дальше. То есть, это не должно занимать больше времени в коммуникации в нашем
[58:56.020 --> 59:07.780]  проекте. После окончания спринта мы получаем спринт-демо, которое с этим работает. Более того,
[59:07.780 --> 59:16.020]  как ни странно, давайте немножко связь с практикой. Заключается в том, каким образом процесс в
[59:16.020 --> 59:22.420]  DT вести в системе контроля версии, посвященной этому. Значит, поскольку у нас продукт достаточно
[59:22.420 --> 59:28.020]  небольшой, то здесь подходит вот такая концепция, под названием feature branching.
[59:28.020 --> 59:46.180]  Feature branching, feature ветвление. Значит, с чем оно заключается? У нас есть основная ветка, main,
[59:46.180 --> 59:57.860]  в которой ведется, хранится продакшен версия нашего кода. Значит, поскольку мы работаем по
[59:57.860 --> 01:00:03.220]  вот такой методологии, и в принципе, продукт у нас работает активно, то при создании нового
[01:00:03.220 --> 01:00:12.500]  user story либо бага у нас создается новая задача. Она обычно имеет некоторые наименования. Если мы
[01:00:12.500 --> 01:00:21.980]  говорим про story, то это ветка feature slash ttt. Если мы говорим про какую-то другую ветку, если исправление,
[01:00:21.980 --> 01:00:29.300]  допустим, у нас в мастер ветки произошло, то мы делаем hotfix, то есть и правим нашу задачу. То есть
[01:00:29.300 --> 01:00:34.820]  прямо название ветки говорит, что это за тип задачи. Если бы у нас была более большая история и у
[01:00:34.820 --> 01:00:42.820]  нас было бы ветвление с веткой для разработки, ветки для продакшена, для релиза, то у нас была бы
[01:00:42.820 --> 01:00:48.220]  ветка еще bugfix что-то там. То есть как бы мы сразу видим, что мы делаем. Новую фичу мы правим баг,
[01:00:48.220 --> 01:00:53.060]  который горит прямо, либо мы правим баги, которые нашли в версии для разработки, но не шли
[01:00:53.060 --> 01:00:58.620]  претестировать. Соответственно, что происходит в этот момент? В этот момент происходит следующее.
[01:00:58.620 --> 01:01:03.420]  После этого мы создаем merge request, и после того, как у вас произошло слияние изменений, вы считаете,
[01:01:03.420 --> 01:01:10.300]  что задача закрыта. То есть как только у вас автоматически происходит merge из фичи ветки в
[01:01:10.300 --> 01:01:17.980]  мейн, вы ее протестировали, у вас работает, собирается, мержится код, у вас происходит
[01:01:17.980 --> 01:01:25.220]  выпуск новой версии. И по факту вы просто на стадии как раз merger контролируете тот процесс,
[01:01:25.220 --> 01:01:30.580]  который у вас происходит. Что делать, если у вас допустим какое-то изменение пришло из мастер ветки,
[01:01:30.580 --> 01:01:37.340]  из мейн ветки новые. Перед чем, соответственно, делать push, вы можете сделать команду pull,
[01:01:37.340 --> 01:01:45.700]  то есть подтянуть изменения, которые были от других коллег. Так, давайте вопрос. Теперь
[01:01:45.700 --> 01:01:49.820]  после того, как делаете задание, вы начинаете делать задание по гиту. Вот это вот понятно,
[01:01:49.820 --> 01:02:11.420]  что я тут рассказал. Хотите покажу, как это выглядит? В одной команде 7 плюс-минус 2
[01:02:11.420 --> 01:02:22.700]  человека нормально. Смотрите, если у нас большая компания, у нас есть несколько команд, то обычно
[01:02:22.700 --> 01:02:28.620]  существует еще одно мероприятие, помимо классической scrum mythology, называется scrum of scrums. То есть когда
[01:02:28.620 --> 01:02:37.580]  вы уже проводите не такой denly stand-up, а уже wickly stand-up, нежнеленое совещание, где вы как раз всех
[01:02:37.580 --> 01:02:44.260]  scrum-мастера разных команд собираются и рассказывают, что каждый будет делать на каждой итерации. Так,
[01:02:44.260 --> 01:02:55.420]  ладно, давайте ветвление как раз посмотрим. Собственно, вот они ветвление. Да, к сожалению,
[01:02:55.420 --> 01:03:05.780]  не все у нас любят в команде делать это все дело, но вот. По крайней мере видно название веток.
[01:03:05.780 --> 01:03:14.020]  То есть у каждой ветки, которая здесь есть название фичи, давайте вот так. Вот они.
[01:03:14.020 --> 01:03:24.260]  Boards, export, dry, expert и так далее. То есть мы видим сразу какие у нас ветки являются hotfix'ами.
[01:03:24.260 --> 01:03:36.100]  Фичи есть hotfix'ы. Вот они. Get parsec, serializer, reset password, bug run и так далее. То есть как бы у
[01:03:36.100 --> 01:03:42.580]  нас создается hotfix ветка. Вот они создаются прямо отсюда. То есть это вот классический фичи
[01:03:42.580 --> 01:03:52.140]  branching. Собственно, это то, как разрабатывается лохчек в текущих концепциях. Так, вот, если мы говорим
[01:03:52.140 --> 01:04:00.300]  про, собственно, где задачи располагаются. Да, для этого есть определенные инструменты, то есть
[01:04:00.300 --> 01:04:06.740]  которые заточены под это. Первый инструмент, который есть, это инструмент под названием джира. Значит, от нее
[01:04:06.740 --> 01:04:17.780]  много кто плюется, сразу говорю. Но она выглядит вот так. К сожалению, она сейчас недоступна. Давайте попробую
[01:04:17.780 --> 01:04:31.180]  открыть инструкцию. Открыть презентацию. Кто-нибудь видит тут картинку? Вот. Вот так называется скрам доска.
[01:04:31.180 --> 01:04:40.420]  У нас здесь открыт определенный спринт. И это спринт-баклок, это все задачи, которые есть в этом
[01:04:40.420 --> 01:04:48.860]  спринте. Значит, у нас с вами есть набор задач to do, есть задачи in progress, есть задачи in review
[01:04:48.860 --> 01:04:57.140]  и есть задачи done. У каждой задачи, видите, в кругляшке есть определенное количество очков. 9, 3, 1 и так
[01:04:57.140 --> 01:05:03.900]  далее. Это так называемые story points, которые есть. Значит, как строится диаграмма со сгорания? Вы
[01:05:03.900 --> 01:05:15.220]  оцениваете количество задач, которые у вас не находятся в done. То есть, что? Не находятся в
[01:05:15.220 --> 01:05:22.780]  done. То есть, как только задачи попадают в done, у нас количество очков в story point снижается. Вот. И
[01:05:22.780 --> 01:05:29.620]  дальше стоит приоритет. И здесь мы видим, кстати, здесь небольшой дефект, потому что можно настроить так,
[01:05:29.620 --> 01:05:35.940]  чтобы баги все-таки считали за story point, но лучше так не делать. Красные это баги, зеленые это user
[01:05:35.940 --> 01:05:41.860]  story и синие это task. То есть, у нас user story может состоять из некоторого набора задач, внутри них
[01:05:41.860 --> 01:05:47.740]  состоящих. Но лучше именно отдельно отделять user story. Вот. При этом это можно ввести не только
[01:05:47.740 --> 01:05:54.460]  для разработки, но и, допустим, для команд дизайна, управления и так далее. Вот. Вот таким образом
[01:05:54.460 --> 01:06:04.580]  выглядит доска. Значит, опять же, доски можно настраивать очень просто. Тут ошибки где-то,
[01:06:04.580 --> 01:06:10.740]  где-то баги. Значит, для этого мы можем использовать такой инструмент. Правда, по-моему, у нас в стране
[01:06:10.740 --> 01:06:16.860]  сейчас не позволяют заводить новые аккаунты на него. Может кто-то знает инструмент под названием
[01:06:16.860 --> 01:06:29.700]  трэла? Слышали про такой? Да. Интересно, почему же так же выглядит? Капаня Atlastik выкупила трэла в итоге.
[01:06:29.700 --> 01:06:44.700]  Да, есть. Правда, оно там называется по-другому. Оно называется как milestone. То есть, сприты можно
[01:06:44.700 --> 01:06:49.620]  редактировать через milestone. Правда, назначение веса задач недоступно в базовая версия GitLab.
[01:06:49.620 --> 01:06:57.460]  То есть, нужно покупать более продвинутую подписку. Что, у нас интернет кончился, да? Вот. Управление
[01:06:57.460 --> 01:07:09.660]  проектов команды с любым устройством. Вот. Можно, можно, конечно же. В Google таблицах вполне. То есть,
[01:07:09.660 --> 01:07:15.700]  вообще раньше это все было. Вы приходите в офис, у вас висит огромная доска, на которой вот эти вот
[01:07:15.700 --> 01:07:21.740]  задачки берете, переносите ручками. Это сейчас просто процесс автоматизирован. Вот. Вот они задачки.
[01:07:21.740 --> 01:07:28.500]  Ну и в принципе, там разработку можно видеть сразу. Все задачи занумерованы. Чем это удобно? Вы
[01:07:28.500 --> 01:07:34.340]  сразу заговорите номер задачи, все понимают, что это за задача. Вот. Это что касается про методологию
[01:07:34.340 --> 01:07:41.620]  разработки по Scrum. То есть, она зачастую как раз и встречается. То есть, она наиболее популярна. Вот.
[01:07:41.620 --> 01:07:45.860]  То есть, если вы хотите, допустим, в проекте попробовать работать по Scrum, ну скажите,
[01:07:45.860 --> 01:07:56.900]  мы поможем в технологиях программирования. Не, ну организуем доски и поможем в налаживании
[01:07:56.900 --> 01:08:07.180]  процессов. Так. Хорошо. Значит, это про задачу, связанную с методологией Scrum. Понятно ли в первом
[01:08:07.180 --> 01:08:13.580]  приближении, что такое Scrum? Поехали дальше. Следующая методология это Kanban. Это не Scrum
[01:08:13.580 --> 01:08:20.220]  методология, это подконцепция гибких методологий разработки. Значит, в чем заточены гибкие методологии
[01:08:20.220 --> 01:08:28.980]  разработки? Ой, не гибкие. Lin, бережливые методологии разработки. Пишется это как LiAn.
[01:08:28.980 --> 01:08:37.580]  Значит, они заточены в том, чтобы бережно сохранить тот процесс, который у нас имеется.
[01:08:37.580 --> 01:08:43.620]  Значит, вообще одним из основателей гибких методологий разработки, ой, бережливых методологий
[01:08:43.620 --> 01:08:49.140]  разработки является страна под названием Япония. Именно в Японии появились бережливые методологии
[01:08:49.140 --> 01:08:53.700]  разработки, и на самом деле первая крупная компания, которая внедрила бережливые методологии
[01:08:53.700 --> 01:09:08.020]  разработки в производство, является компания... угадайте. А? Нет. Toyota. Toyota. Они внедрили это все в
[01:09:08.020 --> 01:09:14.660]  своем конвейерном производстве. То есть, что означает бережливые методологии разработки? Там есть
[01:09:14.660 --> 01:09:20.620]  основная концепция, это постоянная обучаемость и возможность приходить в взаимопомощь. То есть,
[01:09:20.620 --> 01:09:27.060]  наша цель это беречь те ресурсы, которые у нас имеются. Вот, и здесь мы видим с вами интересные
[01:09:27.060 --> 01:09:34.100]  концепции. Значит, мы видим с вами ту же самую доску, только не скрам-доску, а так называемую
[01:09:34.100 --> 01:09:41.100]  канман-доску. Значит, в чем в нее отличия? Мы видим здесь, что количество задач, которые у нас есть,
[01:09:41.100 --> 01:09:47.700]  они не оцениваются все эти задачи. Но здесь в доске есть кое-что интересное. Смотрите,
[01:09:47.700 --> 01:09:57.020]  видите вот тут цифра 3, 3, 1. Это ограничение на количество задач, которые могут находиться в
[01:09:57.020 --> 01:10:06.060]  этом столбце. Это означает, что если кто-то сейчас захочет перевести вот эту задачу в
[01:10:06.060 --> 01:10:12.980]  тестирование и спирр-ревью, то ему это не позволит сделать. Ему скажут, вот у нас задача в тестировании,
[01:10:12.980 --> 01:10:25.220]  сначала продвинь эту задачу, потом работай с текущей задачей. Это является узким горлышком,
[01:10:25.220 --> 01:10:30.260]  но наша цель как раз состоит в том, чтобы избавиться от этого узкого горлышка. То есть,
[01:10:30.260 --> 01:10:35.940]  мы эмулируем вот эту узкую горлышку и говорим команде старайтесь, пожалуйста, либо вы расширяете
[01:10:35.940 --> 01:10:40.420]  эту узкую горлышку. Мы видим, допустим, по процессам, что у вас одна задача в тестировании,
[01:10:40.420 --> 01:10:48.100]  но вы можете вывозить две задачи в тестирование. Давайте, позволяем. Если мы хотим, то тогда
[01:10:48.100 --> 01:10:52.260]  можем расширять. Понятно, что если у нас есть какие-то дефекты или баги, то они идут вне
[01:10:52.260 --> 01:11:01.220]  приоритета другой очереди. Классический пример, который обычно проводит пробу узкая горлышка. Вот
[01:11:01.220 --> 01:11:08.540]  она. У нас есть узкая горлышка, нам нужно его расширить. Пример, собственно, который здесь есть,
[01:11:08.540 --> 01:11:21.780]  мы берем вот эту узкую горлышку. Вопрос, за какое время выльется вода? Ну, смотря как делает,
[01:11:22.420 --> 01:11:31.380]  смотрите, вы можете проколоть дырочки вот здесь. Оно вылется медленно. Как вы можете еще? Вы можете
[01:11:31.380 --> 01:11:38.780]  открыть крышку, оно будет выливаться быстрее. Еще есть способ, смотрите, есть еще один способ,
[01:11:38.780 --> 01:11:44.340]  это взять, обрезать вот эту бутылку, тогда оно сразу быстро вылется, но опять же вы потеряете
[01:11:44.340 --> 01:11:54.900]  общий объем. А есть еще, среди вас есть физики, что еще можно сделать? Ну да, либо прокрутить,
[01:11:54.900 --> 01:12:02.060]  либо проткнуть, для того чтобы воздух попадал и создавалось дополнительное давление. Вот, то есть
[01:12:02.060 --> 01:12:06.260]  вы можете не только классическим расширением узкого горлышка подействовать, а еще какими-то
[01:12:06.260 --> 01:12:13.260]  другими процессами. На эту всю методологию. Вот, в этом как раз заключается идея методологии
[01:12:13.260 --> 01:12:20.420]  Ганбан. И вот как раз, если мы говорим про девопс, про который мы говорили, то с точки
[01:12:20.420 --> 01:12:25.460]  зрения разработки, он как раз относится к гибким методологиям разработки, с точки зрения вообще
[01:12:25.460 --> 01:12:31.020]  самого процесса, он относится к бережливым методологиям разработки. То есть это такая смесь
[01:12:31.020 --> 01:12:38.820]  этих концепций. Да, в итоге мы с вами проговорили очень много, и давайте еще раз тогда профинишируем.
[01:12:38.820 --> 01:12:43.580]  Еще вопрос. Какая методология в наших проектах? И среди всех представленных.
[01:12:43.580 --> 01:13:02.140]  Нет, мы говорили про Scrum, что Scrum мы не вывезем сейчас. Я боюсь проверяющий не будет вместе с вами
[01:13:02.140 --> 01:13:16.940]  сидеть, код писать. Нет, не Agile у нас все-таки. Если бы Agile, то у нас был бы один курс и там, грубо говоря,
[01:13:16.940 --> 01:13:23.700]  остальные половины курсов. У нас итеративные методологии разработки. У нас заранее четко определенное
[01:13:23.700 --> 01:13:29.860]  число итераций. В Agile, вот в чем особенность именно Agile из Scrum, что за счет такой гибкой
[01:13:29.860 --> 01:13:33.520]  методологии вы не поверите. Вы можете общее количество итераций, которое у вас было,
[01:13:33.520 --> 01:13:38.820]  попробовать даже сократить. То есть у вас было, грубо говоря, 40 итераций, вы планировали где-то
[01:13:38.820 --> 01:13:43.980]  в среднем 40 итераций, но вы видите, как у вас быстро задачи закрываются. Думаете, что вы активно
[01:13:43.980 --> 01:13:48.180]  действуете. Вы можете за 30 итераций делать. Ну и вы говорите, грубо говоря, заказчику. Вот у вас,
[01:13:48.180 --> 01:13:53.860]  вы за 40 итераций платите столько, но мы вам можем сделать это все за 3. Если мы делаем это раньше,
[01:13:53.860 --> 01:14:00.940]  то вы платите нам за 30 итераций, плюс бонус за то, что мы закрыли проект раньше. В итоге получается
[01:14:00.940 --> 01:14:08.900]  удельная величина на одного товарища, который писал код, будет больше, потому что он работал 30
[01:14:08.900 --> 01:14:15.580]  недель, а не 40 недель, плюс ему дают премию, а заказчику будет платить меньше, придется платить
[01:14:15.580 --> 01:14:24.260]  меньше денег. Да, потому что он оплачивает 30 плюс бонус, а они все 40. А взаимовыгодное соглашение.
[01:14:24.260 --> 01:14:34.860]  Нет, ну тут уже, могу сказать, давайте не согласовывать такой контракт. Ну типа,
[01:14:34.860 --> 01:14:40.060]  обычные требования бизнеса, они такие, что хочется продукт делать. Вот,
[01:14:41.020 --> 01:14:48.100]  значит, у нас время 12. Давайте я как раз сделаю затравку на следующую лексу. Не успели мы про UML
[01:14:48.100 --> 01:14:56.500]  поговорить, поговорим про вид диаграмм UML, которые существуют. Значит, у нас есть элементы связи и
[01:14:56.500 --> 01:15:02.140]  так далее. Нотация крайне сложная, но можно использовать некоторые упрощения модели. То есть,
[01:15:02.140 --> 01:15:07.780]  в чем заключается концепция людей, которая придумала? Они говорили, что давайте мы при
[01:15:07.780 --> 01:15:14.700]  помощи схем попробуем вообще генерировать весь код. Ну, это было лет 20 назад, поскольку мы
[01:15:14.700 --> 01:15:21.020]  код не генируем схемами. Наверное, эта методология сильно не взлетела 30 лет назад. Ну,
[01:15:21.020 --> 01:15:25.820]  можно использовать упрощения. Значит, каким образом можно рисовать диаграммы? Вот это важный момент.
[01:15:25.820 --> 01:15:32.020]  Есть несколько инструментов, которые можно использовать для этого. Сразу скажу, я вас всячески
[01:15:32.020 --> 01:15:40.900]  отзываю от использования инструментов а-ля PlantUML, Draw.io и так далее. Почему? Потому что они не умеют
[01:15:40.900 --> 01:15:46.860]  валидировать результаты. То есть, они не имеют автоматической проверки. То есть, для какого-то
[01:15:46.860 --> 01:15:53.060]  локального рисования вполне возможно. Ну, вот если мы говорим про вот эти инструменты, они есть.
[01:15:53.060 --> 01:15:57.940]  Значит, еще есть один инструмент. Он, правда, платный и дорогой, но он самый ультимативный. Он
[01:15:57.940 --> 01:16:08.980]  называется Magic Draw. Ну, стоит он дорого, честно. 25 зеленых единиц в месяц. Он стоил где-то лет
[01:16:08.980 --> 01:16:16.260]  пять назад, но мы сейчас его не купить. Собственно, Visual Paradigms имеет онлайн интерфейс, который можно
[01:16:16.260 --> 01:16:21.820]  зайти и делать. То есть, вот здесь реализуются диаграммы классов, связи и прямо у полей можно
[01:16:21.820 --> 01:16:29.980]  прописывать атрибуты. Значит, здесь доступная версия. Это Modelio. И здесь тоже можно видеть,
[01:16:29.980 --> 01:16:36.740]  что есть диаграммы, есть поля, есть методы и так далее. Более того, слева можно видеть атрибуты
[01:16:36.740 --> 01:16:42.700]  классов. То есть, оно явно подсвечивает, какие атрибуты классов есть, какой visibility и так далее.
[01:16:42.700 --> 01:16:49.100]  То есть, опять же, можно проводить валидацию. Причем, все стрелочки они есть. И если вы внезапно
[01:16:49.420 --> 01:16:56.420]  владеете таким инструментом, как Eclipse, поверх нее тоже есть инструмент моделирования под
[01:16:56.420 --> 01:17:03.620]  названием Papyrus. Вот, попробуйте повалидировать модели. Мне кажется, будет интересным опыт,
[01:17:03.620 --> 01:17:09.740]  что вы начинаете рисовать диаграмму, а оно у вас с ошибками падает. Да, просто потому,
[01:17:09.740 --> 01:17:14.860]  что, допустим, вы поля какого-то класса не объявили. Точнее, вы объявили, что у вас есть
[01:17:14.860 --> 01:17:20.380]  экземпляр такого-то класса, а этого класса у вас просто вообще нигде в диаграмме не существует.
[01:17:20.380 --> 01:17:29.660]  Вот такое оно проверит. Вот, теперь давайте как раз поговорим про большую картинку,
[01:17:29.660 --> 01:17:36.380]  которая есть. Значит, все типы диаграмм в UML делятся на структурные и поведенческие.
[01:17:36.380 --> 01:17:44.660]  Значит, структурные диаграммы описывают то, каким образом у нас объекты связаны между собой.
[01:17:44.660 --> 01:17:51.420]  Значит, из таких диаграмм, которые нам понадобятся, это диаграмма классов. Вы ее уже видели на самом
[01:17:51.420 --> 01:17:55.500]  деле не раз. Когда мы говорим про паттерны проектирования, нам удобно все изображать в виде
[01:17:55.500 --> 01:18:02.060]  диаграммы классов. Вторая вещь, которая частенько используется, это диаграмма компонентов. То есть,
[01:18:02.060 --> 01:18:09.580]  у вас некоторые наборы классов объединяются в компоненты, которые дальше между собой коммуницируют.
[01:18:09.580 --> 01:18:13.060]  То есть, вы можете прямо прописать, каким образом компоненты взаимодействуют. По сети они
[01:18:13.060 --> 01:18:18.700]  взаимодействуют или не по сети взаимодействуют. Преимущество других протоколов. Есть диаграмма
[01:18:18.700 --> 01:18:25.420]  пакетов. Что это такое? Это по факту, если грубо говоря, структура ваших папок в проекте. То есть,
[01:18:25.420 --> 01:18:30.220]  вы можете прямо отрисовать структуру папок в проекте и увидеть в каких пакетах какие компоненты
[01:18:30.220 --> 01:18:37.020]  находятся. То есть, вы визуально... Помните, мы с вами говорили на первых занятиях про high
[01:18:37.020 --> 01:18:43.740]  cohesion low coupling. Вот как раз вот UML диаграмма позволяет оценить cohesion и coupling для вашего кода
[01:18:43.740 --> 01:18:49.620]  на уровне вот этих пакет. Есть поведенческие диаграммы, которые описывают взаимодействие
[01:18:49.620 --> 01:18:54.980]  между нашими объектами. Значит, самая классическая диаграмма, с которой вообще начинается все
[01:18:54.980 --> 01:19:01.060]  моделирование, это диаграмма вариантов использования. Она называется use case диаграммой. То есть,
[01:19:01.060 --> 01:19:11.100]  ваша цель описать, грубо говоря, ваш проект состоит из... Допустим, пользователь должен зайти
[01:19:11.100 --> 01:19:21.140]  авторизоваться на сайте, добавить товар к корзину, оформить заказ. То есть, это такие крупные мазки,
[01:19:21.140 --> 01:19:25.220]  которые мы с вами обеспечим. То есть, мы не пишем дизинальную функциональность. У нас появляются
[01:19:25.220 --> 01:19:32.140]  три варианта использования. Авторизация на сайте, оформить заказ, там оплатить заказ.
[01:19:32.140 --> 01:19:39.940]  Вот. Дальше мы уже это все будем раскладывать на составные части. То есть, если говорить по порядку,
[01:19:39.940 --> 01:19:46.980]  то сначала строится вариант use case, потом строится класс диаграмм. После этого иногда рисуют
[01:19:46.980 --> 01:19:52.820]  объект-диаграмм, чтобы понять, каким образом происходит взаимодействие классов. И дальше
[01:19:52.820 --> 01:19:59.700]  все переходит как раз на более тонкие диаграммы. Есть активные классы, у которых есть диаграмма
[01:19:59.700 --> 01:20:05.980]  состояний, есть диаграмма деятельности, есть диаграмма последовательности. То есть,
[01:20:05.980 --> 01:20:12.220]  каким образом, какие процессы выполняют взаимодействие между собой. И здесь еще,
[01:20:12.220 --> 01:20:18.460]  кстати, есть одна диаграмма. После этого классическая. Это диаграмма развертывания. То есть,
[01:20:18.460 --> 01:20:24.780]  где вы будете разворачивать ваше приложение. На мобильных устройствах, просто на ноутбуке
[01:20:24.780 --> 01:20:34.500]  или на сервере. Это что касается этой диаграммы в целом. Они здесь все еще перечислены,
[01:20:34.500 --> 01:20:41.300]  которые мы с вами будем смотреть. Давайте я, наверное, начну сегодня с вот этого вещи. То,
[01:20:41.300 --> 01:20:48.860]  каким образом можно выделять классы, чтобы вы уже начали с этим работать. Значит, первая вещь,
[01:20:48.860 --> 01:20:54.300]  которая есть, это CRC-карточки. Часто используют. Ну, можно использовать. У вас обычно есть текстовое
[01:20:54.300 --> 01:20:58.980]  описание. И вам по текстовому описанию проекта нужно понять, какие классы в этом проекте будут.
[01:20:58.980 --> 01:21:05.740]  И вы можете составить для каждого потенциального класса ту ответственность, которую он должен
[01:21:05.740 --> 01:21:12.380]  делать. И какое взаимодействие с этим классом происходит. Допустим, мы понимаем, что продажи. Нам
[01:21:12.380 --> 01:21:19.660]  нужно знать о продажах. Нам нужно делать промо-акции и так далее. А кто с этим взаимодействует с
[01:21:19.660 --> 01:21:25.220]  продажами? С продажами взаимодействует партнер и продажами взаимодействует клиент. То есть,
[01:21:25.220 --> 01:21:29.740]  грубо говоря, что вы делаете с точки зрения структуры? Вы, допустим, предложение читаете,
[01:21:29.740 --> 01:21:37.460]  у вас есть подлежащее, у вас есть сказуемое и, допустим, есть этот, как он называется, либо дополнение,
[01:21:37.460 --> 01:21:43.180]  либо обстоятельство. То есть, у вас есть какое-то обстоятельство, которое выражено существительным.
[01:21:43.180 --> 01:21:54.340]  Клиент хранит деньги в банке. Клиент хранит деньги, клиент хранит в банке. Соответственно,
[01:21:54.460 --> 01:22:03.060]  у нас получается для клиента сразу возникает роль хранения, что он хранит деньги, где он хранит в
[01:22:03.060 --> 01:22:10.700]  банке. То есть, у нас получается два коллаборатора. Деньги и банки. Ну, образно говоря. Не деньги,
[01:22:10.700 --> 01:22:15.420]  валюту, потому что нам нужно специфицировать название. Вот таким вот образом вы можете
[01:22:15.420 --> 01:22:21.060]  попробовать разложить текст и составить вот такие карточки. Примером как раз посмотрим,
