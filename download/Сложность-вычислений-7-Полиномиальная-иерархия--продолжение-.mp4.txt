[00:00.000 --> 00:16.560]  Сегодня мы поговорим еще раз про баллиональную иерархию. Сегодня основных темы две. Это полная
[00:16.560 --> 00:27.760]  задача на уровнях и иерархии. И еще альтернирующие машины, то есть представление вообще и всей иерархии и
[00:27.760 --> 00:35.200]  классов отдельных не через цепочки формул с кванторами, а через поллиминальное время работы
[00:35.200 --> 00:39.760]  на машине некоторого вида. То есть как для NP было два определения, так и здесь будет два
[00:39.760 --> 00:45.120]  определения. Но потом посмотрим, если останется время, я еще немножко поговорю про характеризацию
[00:45.880 --> 00:59.640]  Хорошо, давайте вспомним, что у нас было. Начиналось все с нулевого уровня, который был просто класс
[00:59.640 --> 01:17.200]  NP. Дальше что вложено в класс NP, который Sigma 1, также в класс CoNP, который Pi 1. Дальше и Sigma 1 и Pi 1,
[01:17.200 --> 01:35.200]  вложенные в Sigma 2 и Pi 2. То есть здесь Sigma 2, Pi 2, Sigma 3, Pi 3 и так далее. И все это вместе
[01:35.200 --> 01:46.320]  вложено в pH, которое есть объединение всех уровней. Дальше мы успели в прошлый раз обсудить,
[01:46.320 --> 01:52.440]  почему во всем классе pH, скорее всего, нет полной задачи, потому что мы верим в то, что все эти
[01:52.440 --> 02:00.240]  классы различные. Но на самом деле, может верить в то, что p равно NP, тогда это все схлопывается.
[02:00.240 --> 02:08.000]  Можно, наверное, верить в какой-то причине, что p не равно NP, но NP равно CoNP. Но предполагая,
[02:08.000 --> 02:16.560]  что первые три уровня различные, а дальше Sigma 3 равно Pi 3 и всем большим, это совсем странно.
[02:16.560 --> 02:28.600]  Да, не очень понятно, чем 3 от 4 так отличается, что оно должно схлопнуться. Тем не менее, нет
[02:28.600 --> 02:36.360]  никакой теоремы. Если до 10 уровня все различное, то дальше тоже различное. Это
[02:36.360 --> 02:45.080]  не умеют исключать. Более того, умеют строить аракулы, что с этими аракулами как раз так и
[02:45.080 --> 02:50.520]  получается. Знаешь, такие специальные аракулы, которые разграничивают до 10 уровня, а дальше уже
[02:50.520 --> 02:59.200]  все схлопывается. Вот. Соответственно, если есть полная задача во всей иерархии, то она будет
[02:59.200 --> 03:04.440]  лежать в каком-то классе, и значит, вся иерархия будет сводиться к этому классу. А значит,
[03:04.440 --> 03:10.840]  она будет совпадать с этим классом, но иначе схлопнется. Тем не менее, на каждом конкретном
[03:10.840 --> 03:20.520]  уровне будут свои полные задачи. Определение стандартное. Значит, языка будет Sigma k, например,
[03:20.520 --> 03:33.480]  Sigma kt и pt полным, если верны две вещи. Если, во-первых, он лежит в этом самом Sigma k там,
[03:33.480 --> 03:45.720]  ну и во-вторых, любой другой язык из Sigma k и pt к нему сводится полинамиально. Геосводимость
[03:45.720 --> 04:03.640]  в точности та же самая, что и всегда было. Так. Хорошо. На самом деле, не во всех классах очевидно,
[04:03.640 --> 04:15.720]  что есть полная задача, но здесь есть. Теорема такая. Сейчас дайте я сначала сформулирую какие
[04:15.720 --> 04:27.880]  задачи. Значит, Sigma kt sat. Это вот какая штука. Значит, это множество таких формул phi. Значит,
[04:27.880 --> 04:39.520]  что все аргументы этих формул разбиты на k групп, ну и дальше, соответственно, цепочка кванторов
[04:39.520 --> 04:49.640]  существует x1 для любого x2 и так далее. Здесь существует ли для любого xkt в зависимости отчетности,
[04:49.640 --> 05:18.760]  и тут будет phi от x1 и так далее xkt. Вот. Ну и аналогично есть pk t sat. Значит,
[05:18.760 --> 05:36.360]  то же самое только начинается с квантора всеобщенности. Вот. На самом деле тут
[05:36.360 --> 05:45.120]  подразумевается, что в состав описания формулы phi включено разбиение переменных на группы. То есть
[05:45.120 --> 05:51.240]  мы знаем, какие переменные, от которых зависит форму, входят в группу x1, в группу x2 и так далее.
[05:51.240 --> 06:10.280]  Вот. Хорошо. Ну, значит, теорема, что каждая задача полна на своем уровне. Теорема,
[06:10.280 --> 06:35.040]  что sigma k sat является sigma k tp полной. Значит, phi k t sat является phi k tp полной. Так. Ну,
[06:35.120 --> 06:45.360]  дать доказывать. Эти задачи являются аналогом задачи у выполнимости, задачи у тавтологии. То есть
[06:45.360 --> 06:59.520]  можно прямо написать, что sigma 1 sat это sat обычная, а phi 1 sat это тавтология. То есть нужно понять
[06:59.520 --> 07:15.800]  по формуле являтия на тавтологии. Вот. Так. Хорошо. Значит, давайте доказывать. Значит,
[07:15.800 --> 07:24.080]  тут на самом деле важным является следующее соображение. Важно, не какой квантор первый,
[07:24.080 --> 07:32.880]  а какой квантор последний. Доказательства проходят, если последний квантор существования. Но
[07:32.880 --> 07:40.200]  нам-то вообще никто не гарантировал, что последний будет квантором существования. Вот. Поэтому надо
[07:40.200 --> 07:47.400]  какой-то еще шаг. Но этот шаг очень простой. Первый шаг стоит в том, что просто вот эти два
[07:47.400 --> 08:02.280]  утверждения друг другу эквивалентны. Так. Значит, первое. Эти два утверждения эквивалентны друг
[08:02.280 --> 08:18.600]  другу. Значит, конечно, что здесь важно? Важно, во-первых, что если язык в одном из этих классов,
[08:18.600 --> 08:30.760]  то его дополнение в двойственном. То есть если A лежит в сигмакатом, то это равносильно тому,
[08:30.760 --> 08:51.320]  что A с чертой лежит в пикатом. Ну и наоборот. Хорошо. Значит, теперь надо сказать следующее.
[08:51.320 --> 09:01.240]  Ну, например, для выполнимости тавтологии у нас что есть? Что фе выполнимо тогда и только тогда,
[09:01.240 --> 09:25.320]  когда отрицание фе не принадлежит тавтологии. Ну и наоборот. Наоборот получается, что это к тому,
[09:25.320 --> 09:34.160]  как доказывать, что тавтология Co-NP полная. Давайте вспомним. И аналогично здесь. Значит,
[09:34.160 --> 09:54.120]  для тавтологии у нас произвольный A сводится к выполнимости. Значит, дальше A из NP. Дальше нам
[09:54.120 --> 10:01.800]  нужно показать, что любой B сводится к тавтологии из Co-NP. Значит, что мы делаем? Если B лежит в Co-NP,
[10:01.800 --> 10:17.400]  то тогда, значит, B с чертой у нас лежит в NP. Из этого следует, что B с чертой,
[10:17.400 --> 10:35.080]  значит, B с чертой сводится к Co-NP. Ну а дальше может прийти к дополнению. То есть B сводится к Co-NP
[10:35.080 --> 10:47.880]  с чертой. Значит, B сводится к Co-NP с чертой. Ну, значит, из чего стоит Co-NP с чертой? Но Co-NP
[10:47.880 --> 10:54.560]  с чертой состоит из записей, которые вообще не формула, а также из записей невыполнимых формул.
[10:54.560 --> 11:07.680]  То, что запись формулы или не формула, это мы как-нибудь разберемся. Нужно договориться о кодировании,
[11:07.680 --> 11:12.200]  чтобы по коду можно было понять, это вообще формула или не формула. И тогда можно считать,
[11:12.200 --> 11:19.080]  что вот это с A с чертой состоит только из формул, которая невыполнимая. Но невыполнимая формула,
[11:19.840 --> 11:31.840]  значит, ее отрицание тавтология. Так, ну вот и получается, что у нас х лежит в B тогда и только тогда,
[11:31.840 --> 11:41.680]  когда формула phi х в лежит в сад с чертой. А это тогда и только тогда, когда отрицание phi х в
[11:41.680 --> 11:49.920]  лежит в ножте тавтологии. Ну и вот получается такая сводимость из X в отрицании phi х.
[11:49.920 --> 12:01.760]  Вот, хорошо, как это в общем случае будет? Ну, в общем случае, пусть, например, первое утверждение
[12:01.760 --> 12:21.240]  выполнено. В общем случае, пусть sigma k сад будет sigma k пт полным. Значит,
[12:21.240 --> 12:37.680]  тогда рассмотрим произвольный язык из pi ktp. Пусть у нас B лежит в pi kt пальномиальном. Значит,
[12:37.680 --> 12:46.720]  отсюда мы получаем, что B с чертой это sigma kt пальномиальная, и отсюда B с чертой сводится
[12:46.720 --> 12:58.320]  пальномиально к sigma kt сад. Вот, и отсюда мы снова приходим к дополнениям. Отсюда B сводится
[12:58.320 --> 13:10.800]  к sigma kt сад с чертой. Вот, и опять же мы игнорируем некорректные записи, получаем,
[13:10.800 --> 13:18.960]  что sigma kt с а с чертой такие формулы, для которых вот то вот условие не выполнено. Ну вот, значит,
[13:18.960 --> 13:27.360]  тогда, расписывая вот так вот, получаем, что X лежит в B. Тогда и только тогда, когда phi х лежит
[13:27.360 --> 13:42.960]  в sigma kt сад с чертой. Так, тут давайте подробнее распишем с кванторами. Так,
[13:42.960 --> 13:48.600]  давайте, поскольку у меня X здесь, то я здесь Y напишу. Существует Y1 для любого Y2 и так далее,
[13:48.600 --> 14:03.600]  существует ли для любого Ykt. Значит, тут соответственно phi х от Y1 и так далее Ykt. Вот,
[14:03.600 --> 14:13.640]  так. И еще нужно отрицание же поставить, да. Это я написал просто sigma kt сад, а с чертой
[14:13.640 --> 14:22.280]  нужно еще отрицание поставить. Вот сюда вот самое начало, надо поставить отрицание. А потом
[14:22.280 --> 14:30.400]  это отрицание пронесется через все кванторы. Это получится равносильно тому, что для любого
[14:30.400 --> 14:39.640]  Y1 существует Y2 и так далее. Здесь тоже квантор последний перевернется, Ykt и в самом конце еще
[14:39.640 --> 14:51.520]  будет не phi х. Вот Y1 и так далее Ykt. Ну а это равносильно тому, что отрицание phi х... Так,
[14:51.520 --> 14:59.840]  на всякий случай давайте я тут шкуфки поставлю, чтобы однозначно толковал. Значит, не phi х лежит
[14:59.840 --> 15:10.520]  в pi kt сад. Ну, значит получается, что та же самая сводимость плюс отрицание дает сводимость
[15:10.520 --> 15:24.240]  уже произвольного языка из pi kt к pi kt сад. То есть в итоге получается, что B сводится к pi kt сад.
[15:29.840 --> 15:35.720]  Ну и аналогично наоборот. Если наоборот предположить нижнее, то полностью аналогично
[15:35.720 --> 15:43.880]  замены всех кванторов на противоположное, мы получим верхнее. Так, хорошо, понятно, да. Но дальше
[15:43.880 --> 15:52.600]  при фиксированном K из двух вот этих вот цепочек ровно одна заканчивается на квантор существования.
[15:52.600 --> 16:00.440]  Вот именно эту цепочку мы и возьмем. То есть мы будем непосредственно доказывать для того K,
[16:00.440 --> 16:07.440]  при котором последний квантор существования. Это что значит? Это значит, что если K нечетная,
[16:07.440 --> 16:16.200]  то мы доказываем для sigma, а если K четная, то мы доказываем для pi. То есть будем...
[16:23.560 --> 16:46.840]  доказывать sigma K полноту sigma K сад при K нечетном. И соответственно pi kt полноту pi kt сад
[16:46.840 --> 17:04.840]  при K четном. Так, как же мы это будем делать? Ну а сами так или иначе нужно как-то посмотреть
[17:04.840 --> 17:13.880]  на конструкцию, которую мы в Теремьку Калиевина использовали. То есть тут, чтобы доказать,
[17:13.880 --> 17:19.520]  нужно лезть немножко в детали работы машины. Так, ну сейчас разберемся. На самом деле,
[17:19.520 --> 17:32.520]  лезть-то надо, но ровно точно так же, как это было в Теремьку Калиевина. Но, конечно,
[17:32.520 --> 17:36.560]  остается вопрос, зачем нам нужно, чтобы последний квантор был существованием. И это,
[17:36.560 --> 18:05.120]  конечно, сейчас должно быть использовано. Так, хорошо.
[18:06.560 --> 18:12.440]  Ну вот теперь пусть у нас есть произвольный... опять же, на самом деле,
[18:12.440 --> 18:19.120]  тут первое и второе полностью одинаково делается. Так что давайте доказывать первое. Пусть
[18:19.120 --> 18:39.200]  B из sigma kt P. Значит, докажем, что B сводится к sigma kt sad. И K нечетно, да.
[18:39.200 --> 18:51.240]  Ну, смотрите, пусть у нас есть конкретная машина, которая задает принадлежность как
[18:51.240 --> 19:01.440]  раз к sigma kt. То есть получается, что X лежит в B тогда, когда существует y1 для любого y2,
[19:01.440 --> 19:10.000]  существует y3 и так далее. И последнее квантор существования. Существует yt и тут V от x,
[19:10.000 --> 19:21.120]  y1 и так далее. И мы точно так же, как делали в Теремьку Калиевина, рассмотрим протокол работы.
[19:21.120 --> 19:26.160]  Протокол работы машины Turing. Мы считаем, что она прямо одноленточная. Что у нее все эти
[19:26.160 --> 19:36.800]  k плюс один аргумент записаны на первой ленте через какие-то пробелы. Будет квадратная таблица,
[19:36.800 --> 19:48.000]  и соответственно в первой строчке тут будет какой-то, может быть, ограничитель. А может и нет,
[19:48.000 --> 20:05.600]  это мелкие детали. В общем, x, потом y1, пробел, y2 и так далее. Потом ykt и потом еще пустое место.
[20:18.880 --> 20:27.360]  Вот так выглядит первая строчка. А, еще есть начальница состояния. Вот чего. Начальница
[20:27.360 --> 20:35.520]  состояния должен быть q1. Соответственно, после этого происходит работа машины Turing,
[20:35.520 --> 20:45.360]  которая определяется все теми же фигурами при так определенной записи. Фигуры будут именно
[20:45.440 --> 20:54.040]  такие. Эта ячейка однозначно определяется этими четырьмя. И это какая-то очень большая,
[20:54.040 --> 21:04.640]  но фиксированная функция. Нет, это не более переменные, это слова некоторые.
[21:04.640 --> 21:11.600]  Значит, мы будем считать, что ограничения длины зашиты прямо в этот V.
[21:11.600 --> 21:28.880]  Не любой, а фиксированный полинавиальный. Например, можно сказать, что есть какой-то V изначальный,
[21:28.880 --> 21:39.280]  и у этого изначального V есть какое-то время работы. И тогда можно все вот эти вот y ограничить
[21:39.280 --> 21:50.400]  временем работы этого исходного V. А потом можно предположить, что мы все эти y кодируем,
[21:50.400 --> 21:56.320]  например, беспрефиксно, так, чтобы у всех одинаковая длина получилась. И после этого эта одинаковая
[21:56.320 --> 22:02.680]  длина будет как раз этим полиномом. И у нас будет новый V-штрих, который будет читать эти длины y,
[22:02.680 --> 22:10.560]  их расшифровывать, брать, соответственно, код, который будет префиксом, из него получать исходный
[22:10.560 --> 22:19.440]  y и запускать старый V. И для этого нового V уже длины всех y будут фиксированы, фиксированный полином
[22:19.440 --> 22:31.280]  от длины x. Так, что, неувидительно? Нет, смотрите, на чем это вообще основано? На том, что вообще это
[22:31.280 --> 22:39.240]  основано на том, что машина тюринга, чтобы прочесть информацию, должна до нее дойти по ленте. Она не
[22:39.240 --> 22:43.760]  может сразу прыгнуть далеко, ей нужно все эти шашки сделать. Соответственно, то, что она прочтет,
[22:43.760 --> 22:54.280]  будет не длиннее, чем число шашков, которое она делает. При этом, если существует хоть какой-то y,
[22:54.280 --> 23:00.800]  на котором там дальше что-то происходит, то есть y не длиннее этого числа шашков. Потому что даже
[23:00.800 --> 23:05.760]  если есть более длинный y, то она его весь не прочтет, а прочтет только вот этот префикс. Ну,
[23:05.760 --> 23:11.200]  и наоборот, если для любого y вот такой длины что-то выполнено, то и вообще для любого выполнено,
[23:11.200 --> 23:17.200]  потому что все более длинные, она не прочтет, а прочтет только префикс. Поэтому все вот эти
[23:17.200 --> 23:23.800]  потенциально бесконечные кванторы существования всеобщности можно заменить на ограниченные кванторы
[23:23.800 --> 23:36.720]  только по словам длины не больше, чем время работы. А сделать так, чтобы у всех y, у всех данных y была
[23:36.720 --> 23:51.920]  одинаковая длина, можно за счет беспрефиксного кодирования. Ну, кстати, можно и обойтись и без
[23:51.920 --> 24:00.200]  этого, но формулу проще записывать. Да, просто если одинаковая длина, то мы точно знаем, что,
[24:00.200 --> 24:06.120]  скажем, у бита, который лежит вот здесь, будет кванш всеобщности. А если длина не одинакова,
[24:06.120 --> 24:12.080]  то нам нужно откуда-то знать, сколько разделителей было левее этого бита. Это тоже можно сделать,
[24:12.080 --> 24:23.520]  но будет более сложная формула. Беспрефиксное кодирование, это простейшее беспрефиксное кодирование,
[24:23.520 --> 24:32.560]  это все биты удваиваются, а потом пишутся 0, 1, а потом все что угодно. И тогда, пока биты идут двойками,
[24:32.560 --> 24:38.160]  мы считаем, что это настоящий y, а как стало 0, 1, значит, y закончилось, все дальнейшее можно
[24:38.160 --> 24:48.360]  игнорировать. И тогда можно сделать все y одинаковой длины. Так, ну хорошо, значит, вот, допустим,
[24:48.360 --> 24:57.160]  мы сделали одинаковые длины, и, соответственно, есть вот функция перехода машины тюринга,
[24:57.160 --> 25:05.320]  перекодирована в функцию зависимости вот этой клетки, вот этих четырех клеток. Это вообще реально
[25:05.320 --> 25:12.520]  большая константа, то есть на практике такая сводимость не будет работать, потому что если хоть
[25:12.520 --> 25:20.280]  сколько бы ни большое число состояний и большое число символов, то здесь будет совсем грубая
[25:20.280 --> 25:28.920]  оценка число состояний плюс число символов в четвертой степени, и еще это будет показателем,
[25:28.920 --> 25:35.320]  и экспоненты основанием будут то же самое.
[25:50.280 --> 25:54.280]  Вот мы скодировали ленту и положение головы.
[25:54.280 --> 26:06.360]  Это можно делать сотни разных способов. Значит, я предлагаю такой способ. Он наверняка не самый
[26:06.360 --> 26:12.600]  экономный, но мне, конечно, довольно понятный, что мы прям все данные записываем в одну строчку,
[26:12.600 --> 26:19.080]  что у нас сначала какие-то символы, потом символы алфавита, потом символ состояния и потом еще символы
[26:19.080 --> 26:25.880]  алфавита. Это означает, что машины находятся в том состоянии, которое в единственном символе состояния,
[26:25.880 --> 26:34.520]  указывает на ячейку следующую этим символом, ну а правее и левее, соответственно, содержимые
[26:34.520 --> 26:42.760]  ленты правее и левее написаны. Тогда утверждается, что такую же конфигурацию на следующем этапе
[26:42.760 --> 26:48.680]  можно сгенерировать за счет вот таких вот функций перехода, что содержимый вот этой клеточки
[26:48.680 --> 26:55.680]  однозначно определяет содержимый вот этих четырех клеточек. Почему несимметрично? Ровно потому,
[26:55.680 --> 27:01.560]  что мы записываем состояние слева от ячейки, то есть если здесь состояние, а здесь ячейка,
[27:01.560 --> 27:10.520]  то тогда что будет вот здесь зависит и от этой ячейки. Соответственно, это будет просто
[27:10.520 --> 27:29.560]  дискретная функция, но тут будет много данных. Подождите, это я количество функций таких
[27:29.560 --> 27:36.280]  написал, а запись будет логарифом от этого. Кстати, не такая уж большая получится. Это у меня число
[27:36.280 --> 27:50.040]  функций перехода, потому что в каждой из вот этих вот нужно определить вот это, а длина записи будет
[27:50.040 --> 28:01.760]  логарифм от этого. Кстати, не так уж много. Значит, длина записи, это будет Q плюс А в четвертой на
[28:01.760 --> 28:17.440]  логарифм от Q плюс А. Да, ну какой-то полином от числа стояний и размера алфавита. Ну как,
[28:17.440 --> 28:25.080]  длина записи будет это самое, логарифм от числа объектов. Нет, ну можно сказать так,
[28:25.080 --> 28:29.800]  что у нас будет Q плюс А в четвертой комбинации, которая записанная вот здесь, вот в четырех
[28:29.800 --> 28:35.640]  клетках. И для каждой комбинации нам нужен логарифм символов, чтобы написать, что будет вот в этой клетке.
[28:35.640 --> 28:57.480]  Да, сейчас, вся таблица в смысле. Да, вся таблица, это прям подряд записанная конфигурация на всех
[28:57.480 --> 29:09.760]  шагах машины тюринга. Сейчас, мы в таблицу прям подряд, вот первая строчка конфигурации в начале,
[29:09.760 --> 29:13.880]  вторая строчка конфигурации после первого шага, третья строчка после второго шага и так далее.
[29:13.880 --> 29:25.920]  Сейчас, не, в итоге мы должны, конечно, формулу сделать. Да, мы переделываем машину тюринга
[29:25.920 --> 29:32.080]  формулу. Так что, если к формуле дописать нужные кванторы, то это будет равносильно
[29:32.080 --> 29:42.240]  тому, что машина тюринга примет, соответственно, X с вот этими кванторами. Ну сейчас, давайте тогда,
[29:42.240 --> 29:52.200]  сейчас я напишу, может быть понятно. То есть глобально, что мы хотим, глобально нужно переделать
[29:52.200 --> 30:01.800]  исход на X в формулу, так что формула лежит в нужном сигмакатом SAT, тогда только тогда,
[30:01.800 --> 30:19.680]  когда X лежала в B. Вот это мы хотим сделать. Сейчас, подождите, пока мы просто рассуждаем о том,
[30:19.680 --> 30:28.880]  как машина тюринга работает. Сначала рассуждаем, потом напишем формулу. У машины тюринга есть
[30:28.880 --> 30:37.720]  начало шаги и конец. Начало выглядит вот так вот, что начальство состояния, потом тот X,
[30:37.720 --> 30:45.600]  который у нас был изначально, и потом какие-то Y нужны длины через пробелы. После этого переходы
[30:45.600 --> 30:52.920]  все выглядят одинаково. Все переходы выглядят, что если взяли четыре соседних клетки, то содержимое
[30:52.920 --> 31:03.520]  вот этой клетки однозначно определяется этими четырьмя. Просто по таблице функции. Ну однозначно,
[31:03.520 --> 31:13.400]  машина тюринга, сейчас, утверждение такое, что вот эти вот фигуры, заполненные состояниями и
[31:13.880 --> 31:20.480]  символами алфавита, бывают совместимые с работой машины тюринга, бывают несовместимые. Вот если они
[31:20.480 --> 31:26.920]  все совместимые, то тогда и переход от строчки к строчке тоже ровно по команде машины тюринга
[31:26.920 --> 31:34.120]  происходит. Не надо говорить конфигурации, потому что конфигурация это как-то строчка.
[31:56.920 --> 32:12.240]  Я чуть-чуть подробнее поговорю, что означает эта корректность. Во-первых, если в этих четырех
[32:12.240 --> 32:18.520]  клетках состояния нет вообще, то тогда символ здесь просто повторяет символ вот здесь. В каждой
[32:19.120 --> 32:30.480]  клетке может быть состояние либо символ. Ну еще раз, символы конфигурации это либо состояние,
[32:30.480 --> 32:37.920]  либо символ ленты. В клетке и лежит либо состояние, либо символ ленты. Корректная
[32:37.920 --> 32:45.780]  конфигурация означает, что там есть ровно одно состояние, и соответственно машина в этом
[32:45.780 --> 32:49.500]  состояние находится, указывает на следующую клетку после этого состояния,
[32:49.500 --> 32:53.300]  ну и символы там какие написаны.
[32:53.300 --> 32:57.620]  Соответственно, если состояния здесь нет вообще, то тут символ просто повторяет
[32:57.620 --> 33:02.820]  вот этот вот. И даже если состояние вот здесь вот, если состояние вот здесь вот, то это
[33:02.820 --> 33:09.620]  тоже повторяет. Но если состояние в одной из этих трех клеток, то нужно уже
[33:09.620 --> 33:14.500]  смотреть на команду. Ну и дальше там несколько вариантов, например, если
[33:14.860 --> 33:20.940]  символ вот здесь вот, то мы смотрим там, если она на месте останется, то здесь
[33:20.940 --> 33:23.700]  должно быть новое состояние, а если она лево сдвинется,
[33:23.700 --> 33:27.900]  то здесь должен быть вот этот вот символ. А если направо сдвинется, то вот этот,
[33:27.900 --> 33:32.500]  но после применения команды и так далее. Нужно рассмотреть несколько случаев,
[33:32.500 --> 33:37.460]  там, не знаю, десяток видимо случаев, и в каждом определится, что в этой клетке.
[33:37.460 --> 33:47.500]  И дальше, соответственно, если у нас есть уже какая-то конфигурация корректная, и в каждой
[33:47.500 --> 33:52.380]  клетке написано то, что получается по этой функции, то следующая конфигурация тоже корректная.
[33:52.380 --> 34:00.980]  Но это доказывается аккуратным анализом, разбором всех этих десяти случаев и сравнением,
[34:00.980 --> 34:05.380]  что должно быть по этому правилу и что должно быть по машине чюрлинга, и что всюду будет одно и то же.
[34:05.380 --> 34:18.980]  Вот. Ну а в конце нужно, чтобы было принимающее состояние. То есть в последней строчке будет
[34:18.980 --> 34:35.700]  написано только, что здесь в какой-то ячейке будет принимающее состояние. Вот. Но это проверяется
[34:35.700 --> 34:44.700]  просто сравнением. То есть в последней кроссформе очень легко написать, что у нас вот эта клетка
[34:44.700 --> 34:51.340]  равняется QA или следующая равняется QA и так далее, что какая-то клетка равняется QA. QA это QA accept.
[34:51.340 --> 35:01.020]  Так, хорошо, теперь как же это все форму записать и откуда получатся кванторы? Значит, нужно написать так.
[35:01.020 --> 35:15.220]  Так, ну если коротко, коротко я вот здесь напишу. Значит, X лежит в B тогда и только тогда, когда
[35:15.220 --> 35:28.620]  существует Y1, там для любого Y2 существует Y3 и так далее, существует YK и еще существует
[35:28.620 --> 35:34.860]  содержимый всех остальных клеток. И существует, вот зачем нужен был последний квантор, чтобы он
[35:34.860 --> 35:49.780]  склеился со следующим. Значит, существует содержимое остальных клеток. Вот. Такое, что начальная
[35:49.780 --> 36:01.380]  конфигурация получается из X вот с этими Y. Начальная конфигурация из X, Y1, Y2 и так далее, YK,
[36:01.380 --> 36:12.020]  значит, конечная это QA, а переходы корректные, да, то есть переходы вот через вот эти фигуры.
[36:12.020 --> 36:24.900]  Значит, переходы корректные. Вот. Ну и дальше еще, чтобы это была именно формула, нужно объяснить,
[36:24.900 --> 36:30.540]  как записать формулами все, что здесь написано. Вот. Но это мы уже делали в Теремку Кулевина,
[36:30.540 --> 36:37.500]  и здесь в целом точно так же, да, то есть нужно написать, что тут первый символ это QA1, да,
[36:37.500 --> 36:44.940]  а второй символ это первый символ X и так далее. Потом здесь, соответственно, пробел. Все бит Y это
[36:44.940 --> 36:53.860]  либо 0, либо 1 обязательно, а не что-либо еще. Да, здесь пустые. В конце где-то здесь есть символ QA.
[36:53.860 --> 37:03.580]  Вот. И дальше большая конъюнкция по всем клеткам, да, что все клетки получаются вот здесь, как функции,
[37:03.580 --> 37:10.140]  вот эта фиксированная функция от вот этих вот четырех. Вот. Это будет большая, но поленомиальная
[37:10.140 --> 37:16.660]  формула. Вот. И ровно за счет того, что здесь последнее кванторское существование и следующий
[37:16.660 --> 37:21.860]  тоже кванторское существование, получится, что и кванторная глубина не изменится. Все еще будет
[37:21.860 --> 37:31.940]  начинаться существование и все еще будет коальтернирование. Ну вот. Вот так это и делается.
[37:31.940 --> 37:37.980]  И также видно, что здесь важно именно, что это квантор именно в конце должен быть, его нельзя
[37:37.980 --> 37:43.620]  вначале поместить, будет другой смысл. Что сначала мы как бы выбрали цепочку этих Y,
[37:43.620 --> 37:47.940]  а потом уже дозаполняем всю остальную таблицу, которая именно на этих Y вычисляется.
[37:51.860 --> 38:00.700]  Существует содержимое остальных клеток. То есть есть вот протокол работы машины тюринга. Значит
[38:00.700 --> 38:05.180]  есть первая строка, что было написано в начало, последняя строка, что должно быть принимающее
[38:05.180 --> 38:14.580]  состояние и все промежуточные, которые получаются по правилам работы машины тюринга. Так. Ну ладно,
[38:14.580 --> 38:17.780]  дайте небольшой перерыв сделаем, чтобы это все уложилось.
[38:22.620 --> 38:33.260]  Так, хорошо. Значит вот доказать для базовых задач. Значит для sigma k at s at, pi k at s at.
[38:33.260 --> 38:43.300]  Значит дальше конечно же есть много других полных задач на уровнях иерархии. В том числе те примеры,
[38:43.300 --> 38:50.060]  которые мы разбирали в прошлый раз, там окликовые раскраски и прочее, они все на самом деле будут
[38:50.060 --> 38:57.020]  полные в тех классах, в которых мы их классифицировали. Но это правда в основном не простые рассуждения,
[38:57.020 --> 39:05.420]  то есть там должны быть какие-то конструкции. Простые рассуждения получаются, если как-то модифицировать
[39:05.420 --> 39:14.540]  те примеры, которые были с NP полными задачами. Ну например,
[39:14.540 --> 39:25.540]  может там какая-нибудь, они немножко игрушечные примеры будут получаться, но тем не менее формально
[39:25.540 --> 39:37.180]  правильные по крайней мере. Значит, например, можно рассмотреть задачу о дополнении раскраски.
[39:37.180 --> 39:59.820]  Задача о дополнении раскраски. Можно даже по-разному ставить, но, например, можно так поставить вопрос.
[39:59.820 --> 40:09.580]  Значит, есть граф и есть некоторое множество s. Значит, где s это множество вершин, под множество вершин.
[40:09.580 --> 40:17.060]  Да, естественно так, что любая раскраска,
[40:17.060 --> 40:40.500]  любую корректную раскраску s в три цвета можно дополнить
[40:47.060 --> 40:59.940]  можно дополнить до корректной раскраски, до корректной раскраски всего графа.
[40:59.940 --> 41:18.020]  Вот так, это p2 получается. Значит, любую можно дополнить. Вот это будет p2 полная.
[41:18.020 --> 41:24.540]  Так, да, кстати, прежде чем говорить про вот эту задачу или вообще любую другую,
[41:24.540 --> 41:33.340]  надо поговорить про нормализацию задачи, то есть сводимость к 3 KNF.
[41:33.340 --> 41:49.300]  Значит, мы знаем, что... так, тут я давайте подробно буду писать. Значит, 3 KNF SAT. Это задача NP полная.
[41:49.300 --> 42:06.260]  Значит, выполнимость 3 KNF это задача NP полная. А вот, например, 3 KNF ТАФТОЛОГИЯ, и это будет лежать в p.
[42:06.260 --> 42:14.500]  Почему? Ну, вообще-то 3 KNF почти никогда не будет ТАФТОЛОГИЙ. Потому что если скобка будет нулевая,
[42:14.500 --> 42:22.780]  то и вся конъюнкция будет нулевая. По этой ТАФТОЛОГИИ 3 KNF может быть только если там в каждой скобке есть какая-то
[42:22.780 --> 42:29.420]  применная и ее отрицание с дизюнкцией. Тогда будет как бы конъюнкция большого числа законов исключенного третий,
[42:29.420 --> 42:37.060]  в этом будет, конечно, ТАФТОЛОГИЯ. Но это, конечно, можем проверить. Поэтому 3 KNF ТАФТОЛОГИЯ это лежит в p.
[42:37.060 --> 42:52.540]  А вот если взять 3 DNF ТАФТОЛОГИЯ, это будет KNP полная. Потому что понять, что DNF будет ТАФТОЛОГИЙ,
[42:52.540 --> 43:00.700]  значит, это задача о том, могут ли все скобки одновременно обнулиться. И это двойственная задача к вопросу,
[43:00.700 --> 43:10.620]  могут ли все скобки быть истинными в 3 SAT. То есть видно, что такие нормальные формы будут разные.
[43:10.620 --> 43:20.140]  Но почему это KNP полная? Потому что если мы возьмем отрицание KNF, то мы получим DNF, пронеся внутрь.
[43:20.140 --> 43:31.300]  Вот здесь я еще не стер, мы берем отрицание, вот здесь KNF, проносим его внутрь и получаем DNF.
[43:31.300 --> 43:43.180]  И, конечно, число литералов скобки не поменяется. Ну и, соответственно, так будет и дальше,
[43:43.180 --> 44:01.780]  и это будет определяться, опять же, последним квантором. Соответственно, будет, так, давайте я тут напишу,
[44:01.780 --> 44:23.500]  значит, 3 KNF sigma kT SAT будет sigma kT полная при нечетном K.
[44:31.780 --> 44:52.820]  И, наоборот, 3 DNF, все еще sigma k SAT будет sigma kT полная при нечетном K.
[44:53.780 --> 45:04.460]  Потому что важно, какой там квантор в конце стоит. Ну спикат и наоборот.
[45:04.460 --> 45:23.820]  Спикат и наоборот, то есть оно будет полным, с KNF будет полным при четном K, и с DNF будет полным при нечетном K.
[45:23.820 --> 45:39.380]  Так, хорошо, но в том примере там как раз P2, то есть будет 3 KNF, в котором мы привыкли.
[45:39.380 --> 45:49.700]  Так, ну правда, на лекции именно для три раскраски я там для нотоликвелл рассказывал, если мы его
[45:49.700 --> 45:54.380]  хотим использовать, то свадимость, то нужно еще сначала первую свадимость повторить.
[45:54.380 --> 46:06.380]  Вот, но есть свадимость, которую, видимо, многие на семинаре прошли, которая сразу из 3 SAT без
[46:06.380 --> 46:21.180]  посредничества нотоликвелл. Так, соответственно, вот эта вот задача о дополнении раскраски можно
[46:21.180 --> 46:41.500]  как-нибудь назвать, там coloring extension, и чтобы доказать, что она полная, в P2, чтобы доказать,
[46:41.500 --> 46:52.420]  что она полная, нужно свести P2, 3 SAT, ну или, да, можно в разном порядке писать, то есть 3 KNF,
[46:52.420 --> 47:06.460]  P2, SAT нужно свести вот к нашему продолжению раскраски, на продолжении три раскраски.
[47:06.460 --> 47:18.340]  Вот, так, ну я всю конструкцию не буду рассказывать, это будет повторение, в общем, как бы там детали
[47:18.340 --> 47:24.820]  гаджетов другие, если у вас не было на семинаре, но вы были на лекции, то там детали гаджетов другие,
[47:24.820 --> 47:40.180]  но общая конструкция, например, такая же, то есть тут есть палитра, значит, где цвета, значит,
[47:40.180 --> 47:52.060]  истинный, ложный и вспомогательный, вот, и дальше это как бы такой веер, да, значит, веер разных
[47:52.060 --> 48:11.860]  переменных. Вот, и дальше какие-то гаджеты, которые их друг с другом соединяют. Вот,
[48:11.860 --> 48:23.420]  значит, как вот это вот выглядит, 3 KNF, P2, SAT, значит, тут, значит, для любого, значит, для любого
[48:23.420 --> 48:35.060]  X существует Y, значит, ну а дальше какие-то скобки, значит, скобка, конъюнция скобка, значит, какая-то
[48:35.060 --> 48:43.700]  вот такая вот формула, и причем в скобках могут быть сразу и X, и Y, да, не то что в одной скобке X,
[48:43.700 --> 48:49.220]  и в другой Y, они как-то друг к другу переплетаются. Вот, ну вот, примерно так же нужно и здесь сделать,
[48:49.220 --> 49:01.740]  значит, нужно выделить группу X, значит, нужно выделить группу Y, и вот это вот, значит, S, да,
[49:01.740 --> 49:17.300]  тут дальше еще какие-то гаджеты, значит, которые сейчас не очень важно как выглядят, вот, а важно,
[49:17.300 --> 49:27.260]  откуда мы S возьмем, значит, в S можно включить палитру и вот эти вот переменные для X,
[49:27.260 --> 49:39.340]  то есть вот эта вот часть, это S, и тогда получается, что любая раскраска S, но это фактически
[49:39.340 --> 49:47.420]  присвоение значений всем их сам, вот, а до раскрашивания это, ну, присвоение значений Y,
[49:47.420 --> 49:54.020]  ну а гаджеты там однозначно раскрашиваются, и, соответственно, если все нормально раскрасывается,
[49:54.020 --> 49:59.940]  то это значит, что для любой раскраски вот этого, то есть для любых значений X существует раскраска
[49:59.940 --> 50:05.940]  вот этой части, то есть выбор значений Y, что все скобки выполнены, то есть все гаджеты раскрасились.
[50:05.940 --> 50:20.220]  Вот, ну вот, примерно так доказывается, что это P2 полная задача. Так, ну чего, понятно? Вот, так,
[50:20.220 --> 50:28.140]  ну, повторюсь, что это пример немножко искусственный, но тут есть, в Гэри Джонсо ни этого
[50:28.140 --> 50:42.220]  нету, но есть другой список, тоже где-то страниц на 80, наверное. Вот, называется красивым латинским
[50:42.220 --> 50:55.100]  словом компендиум разных задач исполнительной иерархии. Вот, ну и там, в этом списке, там где-то
[50:55.100 --> 51:01.860]  процентов 80 на втором уровне, остальные 20 на третьем уровне, а выше там вообще ничего нету. И он
[51:01.860 --> 51:08.260]  структурирован по разным областям, то есть там есть отдельно графы, там логика, алгебра, головоломки
[51:08.260 --> 51:22.700]  и так далее. Вот, ну и там много разных ссылок на статьи, где это все показано. Знаешь, что задачи
[51:22.700 --> 51:31.540]  полные в соответствующих классах. Есть там некоторое число открытых вопросов. Вот,
[51:31.540 --> 51:47.100]  так, значит, что же дальше? Ну, поговорим про машины, которые я анонсировал. Значит,
[51:47.100 --> 52:07.100]  машины, соответствующие, машины, соответствующие вычисления в pH. Да, то есть идея такая, что точно
[52:07.100 --> 52:13.780]  так же, как для NP у нас есть недetermинированная машина, так что мы говорим, что задача живет в NP,
[52:13.780 --> 52:22.420]  если она распознается на недetermинированной машине за полиминальное время. Точно так же,
[52:22.420 --> 52:28.220]  здесь будут специальные альтернирующие машины, так что, соответственно, задача лежит там в
[52:28.220 --> 52:36.220]  сигмакатом, если она распознается за полиминальное время альтернирующей машины и там типа сигмакаты.
[52:36.220 --> 52:59.860]  Называется альтернирующие машины. Знаете, что это такое? Ну, это некоторое расширение недetermинированной
[52:59.860 --> 53:13.140]  машины. Значит, там все состояния делятся на два класса. Прям состояние. Состояние делится на два
[53:13.140 --> 53:35.820]  класса. Сигма-состояние и пи-состояние. Вот, значит, и так же, как и в недetermинированной
[53:35.820 --> 53:55.100]  машине, там многозначная функция перехода. Соответственно, раз есть многозначная функция
[53:55.100 --> 54:02.380]  перехода, то вместо линейного вычисления получается дерево вычислений. Например,
[54:02.380 --> 54:13.340]  вот начальство состояния, пусть это сигма-состояние. Да, вот я говорю сигма, а пишу квантор. И это потому,
[54:13.340 --> 54:25.580]  что это одно и то же. Читаясь проще сигма, метку проще ставить существует. Соответственно,
[54:25.580 --> 54:32.580]  тут может быть, ну, например, три разных перехода. Соответственно, тут где-то может быть
[54:32.580 --> 54:43.940]  тоже сигма-состояние, а где-то пи-состояние. Вот. Дальше там тоже как-то это ветвится, да, значит,
[54:43.940 --> 55:01.380]  может где-то и не ветвится. Дерево исполнения программы, да. Ну, для конкретного входа. Да,
[55:01.380 --> 55:11.100]  то есть для конкретного входа будет конкретное дерево. Вот. Ну и так далее. Значит, и так далее.
[55:11.100 --> 55:26.620]  И дальше где-то будут уже ответы. Так, ну давайте я прям, дать я yes и no поставлю.
[55:41.100 --> 55:55.580]  Вот. Ну, в общем, и так далее. Значит, теперь смотрите. Во-первых, как определяется ответ. Во-первых,
[55:55.580 --> 56:01.300]  требуется, чтобы обязательно дерево было конечным на любом входе, да, то есть никаких бесконечных
[56:01.300 --> 56:07.380]  ветвей нету, и более того, чтобы глубина была полиномиальная. Да, то есть обязательно вот
[56:07.380 --> 56:18.260]  глубина будет полиноматенна на любом входе. Значит, после этого, значит, в конечных вершинах у нас
[56:18.260 --> 56:25.900]  уже есть ответ, да или нет. И дальше этот ответ поднимается снизу вверх с учетом того кванта,
[56:25.900 --> 56:34.420]  который здесь стоит. Да, то есть, например, вот здесь существует yes и no, значит, ответ yes, да,
[56:34.420 --> 56:43.020]  существует. Здесь для любого, значит, yes, yes, ответ тоже yes. Значит, здесь существует, соответственно,
[56:43.020 --> 56:50.940]  ответ yes. Значит, здесь там yes и no, но здесь для любого, да, значит, поэтому здесь ответ no, значит,
[56:50.940 --> 56:57.780]  и здесь ответ no. Вот. Ну, здесь что-то еще будет. Да, в принципе, можно не вычислять в данном случае.
[56:57.780 --> 57:12.740]  Ну, значит, для любого входа будет какое-то дерево, и, значит, ответ вычисляется от листьев к корню,
[57:12.740 --> 57:38.740]  от листьев к корню, применяя нужные операции. Так.
[57:42.740 --> 58:02.700]  Не, ну это, конечно, это даже в НПО может быть экспоненциальным. Значит, то есть, ну, смотрите,
[58:02.700 --> 58:08.820]  в качестве метафора полезно считать следующее, что вот просто недетерминированная машина,
[58:08.820 --> 58:15.940]  она как бы так делает форки в параллельные миры, и, соответственно, если в каком-то параллельном
[58:15.940 --> 58:26.100]  мире получился ответ да, то, так сказать, центральный форк сразу получает об этом информацию, да,
[58:26.100 --> 58:30.820]  и выдает ответ да. Вот. А если ни из одного параллельного мира не пришел ответ да, то центральный
[58:30.820 --> 58:40.260]  форк говорит ответ нет. Вот. А здесь более хитро. Значит, здесь как бы есть форки, которые вычисляют
[58:40.260 --> 58:44.420]  конъюнкцию, а есть форки, которые вычисляют дезюнкцию. То есть те, которые вычисляют дезюнкцию работают
[58:44.420 --> 58:49.740]  так же, как недетерминированная машина тюринга, а те, которые конъюнкции, они должны со всех
[58:49.740 --> 58:58.860]  параллельных миров собрать ответ да, чтобы потом сказать да. Вот. Так, ну и хорошо. Значит, дальше
[58:58.860 --> 59:10.540]  можно ввести вот такой общий класс, sigma kt time. Значит, sigma kt time от t от n. Значит, это означает,
[59:10.540 --> 59:26.420]  что для любого х, во-первых, правильный ответ, полученный вот таким образом. Значит, ответ,
[59:26.420 --> 59:37.540]  вот этот вот, соответствует тому, что х лежит ва. То есть, если х лежит, то должен быть ответ да,
[59:37.540 --> 59:51.460]  если х лежит, то должен быть ответ нет. Значит, дальше глубина равна у большой от t от n. То есть,
[59:51.460 --> 59:59.140]  время работы считается как глубина дерева. В-третьих, начальное состояние, значит, если sigma kt,
[59:59.140 --> 01:00:16.020]  то начальное состояние это sigma состояние. Вот. И четвертое, что вдоль любой ветви не больше
[01:00:16.020 --> 01:00:33.660]  k-1 перемены типов состояния. Значит, вдоль каждой ветви не больше k-1 перемены
[01:00:33.660 --> 01:00:50.220]  типа состояния. Ну или что то же самое, не больше, чем k групп состояния одинаковых типов. Вот.
[01:00:50.220 --> 01:00:56.140]  Последнее, конечно, такое немножко сложное и не очень удобоваримое определение, но тут как-то
[01:00:56.140 --> 01:01:07.580]  проще не получается. Нет, ну логично, конечно, да. Вот. Соответственно, значит, pi kt аналогично,
[01:01:07.580 --> 01:01:22.460]  кроме начального состояния. Значит, pi kt time, а t от n, значит, это аналогично, но начальное
[01:01:22.460 --> 01:01:37.580]  состояние это pi состояние. Вот. Ну и после этого можно определить, значит, sigma kt p. Это,
[01:01:37.580 --> 01:01:51.340]  соответственно, sigma kt time от полинома от n. Вот. А то, что это равняется тому, что мы определяем,
[01:01:51.340 --> 01:02:06.620]  это уже теорема. Соответственно, pi kt p, значит, это pi kt time тоже от полинома. Вот. Ну и, значит,
[01:02:06.620 --> 01:02:15.700]  теорема состоит в том, что sigma kt p это то же самое, что через кванторы sigma kt
[01:02:15.700 --> 01:02:24.500]  полиномиальная. Вот. Ну а pi kt p это тоже то, что мы определяем через кванторы pi kt
[01:02:24.500 --> 01:02:36.780]  полиномиальная. Так. Ну, теорема-то не очень сложная, потому что, значит, в одну сторону,
[01:02:36.780 --> 01:02:41.780]  я, наверное, не буду записывать, да, проговорю, потому что это очень похоже на теорему для NP.
[01:02:41.780 --> 01:02:46.700]  Да, для NP у нас была теорема о том, что два определения эквивалентны. Здесь примерно то
[01:02:46.700 --> 01:03:00.460]  же самое. Значит, в одну сторону нужно в качестве вот этого v написать, ну, так сказать, компилятор
[01:03:00.460 --> 01:03:07.140]  вот такой вот альтернирующей машины тюринга. То есть компилятор получает ветку, по которой нужно
[01:03:07.140 --> 01:03:15.140]  идти. И он по ней идет и возвращает нужный ответ. Тогда, конечно, такой компилятор будет полиномиальным,
[01:03:15.140 --> 01:03:21.380]  потому что он не перебирает, куда идти, а он в каждой развилке получает подсказку, куда идти,
[01:03:21.380 --> 01:03:29.340]  и по ней идет. Вот. Но с другой стороны получается, что вот там, где существует,
[01:03:29.340 --> 01:03:35.460]  там как бы должна существовать подсказка, куда идти. Вот. Если есть там длинная ветка,
[01:03:35.460 --> 01:03:45.780]  как вот эта вот. Там налево, налево, налево. Или там налево, направо, налево. А, кстати, здесь уже
[01:03:45.780 --> 01:03:55.980]  другое, да. Вот. В общем, пока идут квандры существования, можно эту ветку просто предъявлять.
[01:03:55.980 --> 01:04:00.620]  Когда начинается квандры всеобщности, нужно, наоборот, перебрать и вот эту ветку, и вот эту ветку.
[01:04:00.620 --> 01:04:08.060]  Но так получается, что если там как группа везенковых состояний, то существует начало ветви,
[01:04:08.060 --> 01:04:14.460]  что для любого продолжения по пи-состояниям существует ветка по сигма-состояниям и так
[01:04:14.460 --> 01:04:21.980]  далее, что в итоге будет ответ да. Вот. Так получается в одну сторону, что если у нас
[01:04:21.980 --> 01:04:30.780]  альтернирующая машина, то можно построить, можно построить предикат так, что формул с квандрами
[01:04:30.780 --> 01:04:37.660]  для предиката верна тогда, только когда машина вернет да. Это в одну сторону. Так. А в другую
[01:04:37.660 --> 01:04:44.060]  сторону нужно, наоборот, нужно построить альтернирующую машину. Там еще проще. Эта
[01:04:44.060 --> 01:04:49.660]  альтернирующая машина сначала там в сигма-состояниях строит там у1, потом в пи-состояниях
[01:04:49.660 --> 01:04:55.500]  строит у2, потом в сигма-состояниях строит у3 и так далее, а потом уже детерминированно запускает
[01:04:55.500 --> 01:05:11.900]  моделирование вот этого исходного предиката на этих построенных у. Вот. Ну ладно. Так, что еще
[01:05:11.900 --> 01:05:18.140]  можно сказать про полинамеральную верахию? Так, ну следующий я доказывать не буду, но полезно
[01:05:18.140 --> 01:05:28.460]  представлять себе характеризацию иерархии через аракулы. Полинамеральная иерархия через аракулы.
[01:05:28.460 --> 01:05:45.020]  Через аракулы. Значит, смотрите, что означает, что какой-то класс, например, NP с аракулом А.
[01:05:45.020 --> 01:05:55.660]  Значит, с аракулом А это означает, что можно за один шаг, за один шаг получать ответ на вопрос
[01:05:55.660 --> 01:06:21.900]  лежит ли Хва. Значит, можно за один шаг узнавать, верно ли Х лежит Ва. Вот. Ну и дальше это
[01:06:21.900 --> 01:06:27.780]  подставляется в определении NP, то есть неважно в какое. Может быть, это недетерминированная
[01:06:27.780 --> 01:06:35.380]  машина, которая в процессе вычисления умеет строить Х, ну вообще-то говоря, тоже недетерминированно,
[01:06:35.380 --> 01:06:43.580]  и потом за один шаг про этот Х узнавать лежит он в А или не лежит. Вот. А может быть верификатор.
[01:06:43.580 --> 01:06:49.980]  У верификатора есть какой-то вход, какая-то подсказка. Он проверяет эту подсказку, но в
[01:06:49.980 --> 01:06:57.340]  процессе может про любой вычисленный Х спрашивать, верно ли он лежит Ва. Значит, это можно делать
[01:06:57.340 --> 01:07:03.820]  адаптивно. То есть можно про один Х узнать, лежит он Ва или нет, и с учетом этого знания вычислить
[01:07:03.820 --> 01:07:13.580]  следующий Х, про который будет идти вопрос. Вот. Но кроме конкретного языка в виде аракулы
[01:07:13.580 --> 01:07:26.540]  бывает целый класс в виде аракула. Что такое NP? NP с аракулом NP. А это один язык. А NP это класс.
[01:07:26.540 --> 01:07:34.140]  Но на самом деле можно сказать, что это NP с одним NP-полным языком. То есть NP, скажем, с трясат.
[01:07:34.140 --> 01:07:42.300]  Ну и с другим NP-полным языком. Вот. Ну либо можно говорить, что аракул выбирает язык,
[01:07:42.300 --> 01:07:52.380]  про который спросить, и выбирает спросить про этот язык. Но все равно, если он спрашивает про
[01:07:52.380 --> 01:07:59.700]  язык, то он его задает какой-то формулой или машиной тюринга и так далее. И все равно,
[01:07:59.700 --> 01:08:03.100]  в принципе, все вопросы к NP можно переделать к вопросу трясат.
[01:08:03.100 --> 01:08:09.180]  Сейчас еще раз. А что мы хотим? Мы хотим все еще находить вот эту коллиндральную машину,
[01:08:09.180 --> 01:08:22.540]  которую мы будем читать? Сейчас. Ну определение, да, что класс NP с аракулом NP. Значит, это класс
[01:08:22.540 --> 01:08:29.980]  тех языков, для которых, соответственно, есть процедура, которая отвечает верно на вопрос,
[01:08:29.980 --> 01:08:38.020]  лежит X в этом языке или нет. Да, и она нетренированная и использует аракул. Ну дальше
[01:08:38.020 --> 01:08:42.340]  есть два варианта. Может быть, что она может сама решить, какой NP-язык спросить и о чем спросить,
[01:08:42.340 --> 01:08:48.740]  а может вместо этого все свести к NP-полному языку и про конкретный NP-полный язык спрашивать. Это
[01:08:48.740 --> 01:09:05.540]  будет одно и то же. Так вот, теорема. Значит, теорема такая, что первая, что sigma k плюс первая
[01:09:05.540 --> 01:09:26.220]  пальномиальная. Это будет NP в степени sigma k, но и также это будет NP в степени pi k.
[01:09:28.220 --> 01:09:32.780]  Второй раз на самом деле очевидно, потому что аракул, в отличие просто от NP, аракул может
[01:09:32.780 --> 01:09:38.540]  переворачивать ответ. И, соответственно, если он умеет решать выполнимость, то тавтологи он
[01:09:38.540 --> 01:09:44.420]  тоже умеет решать и наоборот. Поэтому второе равенство очевидное, а вот первое не вполне очевидное.
[01:09:44.420 --> 01:09:52.700]  Ну и, соответственно, второе то же самое с pi. Значит, pi k плюс первая пальномиальная. Это будет
[01:09:52.700 --> 01:10:10.940]  coNP с аракулом sigma kt pt и это же будет coNP с аракулом pi kt pt. Ну и вот такое
[01:10:10.940 --> 01:10:17.300]  определение позволяет определить еще один класс, который как-то через кванторы, не понятно как
[01:10:17.300 --> 01:10:33.620]  определять. Значит, он называется дельта. Значит, дельта k плюс первая pt это p с аракулом sigma kt pt.
[01:10:33.620 --> 01:10:45.220]  Вот, ну видно, что дельта k плюс первая, она как раз будет где-то между, она будет внутри
[01:10:45.220 --> 01:10:52.900]  в пересечении sigma k плюс первая и pi kt плюс первого, но с другой стороны включая в себя sigma kt и pi kt.
[01:10:52.900 --> 01:10:58.100]  То есть это как раз такой преимущественный класс. Ну, например, дельта первая это p,
[01:10:58.100 --> 01:11:06.020]  дельта первая это p, потому что p с аракулом p это p. Вот, но дельта вторая это уже что-то
[01:11:06.020 --> 01:11:18.020]  больше, чем coNP, но меньше, чем sigma 2 и pi 2. Вот, и кроме того, это больше, чем даже dp,
[01:11:18.020 --> 01:11:33.460]  который мы изучали. Вот, хорошо. Так, наверное, вас интересует вопрос, что будет с альтернирующими
[01:11:33.460 --> 01:11:41.180]  машинами, если мы откажемся от ограничения на число перемен типа, вот здесь вот. Или вообще,
[01:11:41.180 --> 01:11:48.500]  или что будет с формулами, если мы откажемся от ограничений на число кванторов. Ну, ответ такой.
[01:11:48.500 --> 01:11:56.900]  Ну, значит, смотрите, у нас с sigma k там, у нас твердо сказано, что вот у нас есть ровно k этих
[01:11:56.900 --> 01:12:06.500]  самых групп у, ровно k групп у, независимо от длины х. Да, хоть х длины тысячи, хоть х длины миллион,
[01:12:06.500 --> 01:12:12.860]  хоть их длины миллиард, все равно там будет, скажем, 7 этих самых групп кванторов. Вот. А откажемся,
[01:12:12.860 --> 01:12:19.100]  это означает, что число может расти с ростом х. Да, что их может быть там линейное число,
[01:12:19.100 --> 01:12:25.020]  или там квадратичное, или логарифмическое, да, в общем, какое-то. Вот. Ну, и здесь тоже, да,
[01:12:25.020 --> 01:12:30.740]  значит, здесь, конечно, глубина будет полиномиальная, если мы сохраняем вот эту букву p. Вот. Но число
[01:12:30.740 --> 01:12:37.820]  примера кванторов тоже может быть от константы до полинома. Любое. Вот. Вопрос, что будет? Вот.
[01:12:37.820 --> 01:12:45.380]  Ну, оказывается, что это будет класс p-space, то есть класс языков, которые решаются на полиномиальной
[01:12:45.380 --> 01:12:54.820]  памяти. Вот. И, соответственно, все вот это вот и кванторы, и альтернирующие машины дают разные
[01:12:54.820 --> 01:13:05.380]  способы характеризации класса p-space. Значит, на следующей лекции мы как раз будем изучать класс
[01:13:05.380 --> 01:13:14.300]  p-space, как он себя ведет, какие там есть полные задачи. Вот. Ну, насколько я понимаю, все-таки для PMF
[01:13:14.300 --> 01:13:19.220]  это, вроде, последняя лекция от меня. Значит, вы, конечно, можете продолжать ходить, если хотите. Вот.
[01:13:19.220 --> 01:13:25.980]  Но Сергей Алексеевич вроде должен начать лекции, и, значит, где-то там в апреле, наверное,
[01:13:25.980 --> 01:13:30.780]  программа немножко разойдется. Все. Спасибо за внимание.
