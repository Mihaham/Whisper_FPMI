[00:00.000 --> 00:14.000]  Короче говоря, мы с Алиной, Алина идёт сюда, Алина показывает, короче, вот мы показываемся вам,
[00:14.000 --> 00:21.000]  вот я София Молончук, вот Алина Кузнецова, и мы, короче, будем вам расшаривать алгоритмчики.
[00:21.000 --> 00:31.000]  Короче говоря, у вас будет контрольная, контрольная 2 по час 20, как это уже говорил Александр Александрович,
[00:31.000 --> 00:36.000]  час 20, перерыв и час 20, если меня не изменяет память. Согласуется? Согласуется.
[00:36.000 --> 00:42.000]  Сначала будут задачи вроде как попроще, потом задачи вроде как посложнее, формат OpenBook,
[00:42.000 --> 00:47.000]  то есть можно пользоваться любыми бумажными материалами, передавать нельзя, соседам пользоваться нельзя,
[00:47.000 --> 00:52.000]  электронным пользоваться нельзя, вот. И короче говоря, вот такая тема.
[00:52.000 --> 00:59.000]  Мой совет, пойдите в библиотеку, возьмите бумажного кормона, бумажных кормонов расхватывают просто
[00:59.000 --> 01:06.000]  впереди паровоза, то есть за 3 дня до контрольной бумажных кормонов вряд ли найдёте.
[01:06.000 --> 01:10.000]  Он помогал, мне он помогал. Хорошо.
[01:11.000 --> 01:18.000]  Собственно говоря, бумажные кормоны. Это ваш лучший друг на контрольной по алгоритмам.
[01:18.000 --> 01:28.000]  Конспектики, всякое такое, вот. Значит, какие мы темы, все темы дографов не включительно будут в контрольной,
[01:28.000 --> 01:38.000]  то есть это асимптотики, это мастер теорема, это оценки нижние, это всякие такие вычислительные штучки
[01:38.000 --> 01:47.000]  для Euclid и быстроразведения в степень, вот, RSA будет, быстропродолжение Fourier будет, вот такие вот штуки.
[01:47.000 --> 01:53.000]  Собственно, мы сейчас их и расскажем. Я, потом Алина, потом я, потом Алина, да.
[01:53.000 --> 02:00.000]  Ну да, короче, начнёт Sonya. Да. Отлично. Собственно, про асимптотики. Что мы помним про асимптотики?
[02:00.000 --> 02:18.000]  Мы помним, что есть у от f от n, у от j от n будет вот так. f от n равно u от j от n, если существует константа больше 0.
[02:18.000 --> 02:28.000]  Значит, что оценивается сверху, что для любого, значит, существует константа больше 0, такая, что существует n большое,
[02:28.000 --> 02:36.000]  такая, что для любого n маленького больше, либо равного n большого f от n меньше, либо равен константа на j от f.
[02:36.000 --> 02:50.000]  Вот. А это оценка сверху, то есть растёт не быстрее, чем эта оценка снизу растёт немедленнее, чем если существует константа больше 0,
[02:50.000 --> 03:00.000]  такая, что существует n такое, что для любого n больше, либо равного, чем n большое f от n больше, либо равно, чем cj от n.
[03:00.000 --> 03:16.000]  Вот. Ну и наконец, θ. θ от j от n, если от j от n и ω от j от n.
[03:16.000 --> 03:20.000]  Вот. Про то, как с полиномами эта вся штука работает.
[03:20.000 --> 03:33.000]  Помним, что полином является большим от своей самой старшей степени, что любой полином съедает любой логарифм.
[03:33.000 --> 03:51.000]  Мы помним. Вот. То есть как бы важная такая штука для любого epsilon больше 0, логарифм n, это ограничивается сверху n в степени epsilon.
[03:51.000 --> 03:59.000]  Вот. Собственно, поэтому если у нас что-то там плюс логарифм, то логарифм съедается.
[03:59.000 --> 04:03.000]  Если у нас, допустим, какой-то многочлен, то все степени, кроме старшей, опять-таки съедаются.
[04:03.000 --> 04:12.000]  Вот. Мы можем так оценивать. Да. Ну, это как бы такие базовые основные штуки.
[04:12.000 --> 04:24.000]  Дальше. Важно помнить, что ω, ω и θ – это не то же самое, что мотоновские о малое, собственно, и эквалентность.
[04:24.000 --> 04:32.000]  Вот. Ну, как мы помним, что в о малом в мотоне там предел, а в о большом тут существует константа.
[04:32.000 --> 04:43.000]  То есть, например, как мы говорим, что мы говорим, что n – это о большое от n, но неверно, что n – это о малое от n.
[04:43.000 --> 04:48.000]  Вот. В этом суть разницы, что здесь существует константа, а там чисто предел.
[04:48.000 --> 04:52.000]  Вот. Это как-то такой тоже поинт достаточно важный.
[04:52.000 --> 04:58.000]  Дальше. Какие у нас есть способы оценки, асинтетической оценки разных функций?
[04:58.000 --> 05:04.000]  Ну, собственно, непосредственно по определению проверять, подбирать константы сверху-снизу.
[05:04.000 --> 05:13.000]  Собственно, смотреть на многочлен, то во многочлене убивать нужные, соответственно, степень, которая меньше, чем старшая.
[05:13.000 --> 05:18.000]  Если у нас функция рекурсивная, то есть вызывает сама себя.
[05:18.000 --> 05:24.000]  Вот. Как, например, ну, та же сортировка там, сортировка с лиянием.
[05:24.000 --> 05:27.000]  Отсортируйте первую половину, отсортируйте вторую половину, сливайте.
[05:27.000 --> 05:36.000]  Вот. И прочее. То есть, грубо говоря, t от n – это несколько раз, t от n – это, собственно, время работы.
[05:36.000 --> 05:43.000]  Несколько раз вызывает саму себя от какой-то части, плюс еще какая-то функция.
[05:43.000 --> 05:46.000]  Как это можно оценивать?
[05:46.000 --> 05:54.000]  Допустим, мы знаем, что при малых n, то есть, ну, что, например, там меньше чего-то там, у нас ограниченно сверху константы.
[05:54.000 --> 06:00.000]  Как у вас была в классной домашней, не помню, работе задачке там, помните с циклом Print Hello World?
[06:00.000 --> 06:04.000]  Если n меньше 2020, то от 1 до n печатать.
[06:04.000 --> 06:09.000]  Вот заметим, что констант n достаточно маленький, то есть, меньше чем 2020.
[06:09.000 --> 06:14.000]  И дальше, несмотря на то, что мы там, ну, как бы, линейно зависит от n, то есть, n раз печатать.
[06:14.000 --> 06:19.000]  Но все равно мы говорим, что это не больше, чем 2020. То есть, оно ограничено сверху константы.
[06:19.000 --> 06:27.000]  Значит, мы имеем право оценивать это через дерево рекурсии и через основную теорему рекурсии, мастер-теорему.
[06:27.000 --> 06:29.000]  Но мастер-теорема работает не всегда.
[06:29.000 --> 06:40.000]  А вообще, одна тема дерева. Вот, собственно, вот здесь было t от n, вот здесь h штук, t от n бетов.
[06:40.000 --> 06:47.000]  Если верхняя, нижняя оценка на асинхетическом уровне, то как бы можно пренебречь.
[06:47.000 --> 06:52.000]  Там, если вот здесь будет округление вниз, округление вверх.
[06:52.000 --> 06:58.000]  Вот, из-за того, что константы, они как бы, константы, вот.
[06:58.000 --> 07:05.000]  А как это делается, как помним, находим глубину, вот.
[07:05.000 --> 07:09.000]  Глубина, то есть, соответственно, вот эта n маленькая.
[07:09.000 --> 07:15.000]  Ну, грубо говоря, можно сказать даже до единицы, если мы ведем речь о чем-то асинхетическом.
[07:15.000 --> 07:23.000]  Ну, мы говорим, что там n на b в степени глубины должно быть там больше единицы.
[07:23.000 --> 07:27.000]  Вот, соответственно, больше либо равно.
[07:27.000 --> 07:33.000]  Но при этом n на b в h плюс первой уже будет меньше единицы.
[07:33.000 --> 07:37.000]  Ну, здесь можно не единицу, а ту самую маленькую константу,
[07:37.000 --> 07:41.000]  начиная с которой n мало и алгоритм работает за константы.
[07:41.000 --> 07:44.000]  Вот так оцениваем глубину.
[07:44.000 --> 07:52.000]  И как помним, что вот это f от n, то есть вот здесь выполняется f от n операции.
[07:52.000 --> 07:58.000]  Вот здесь в каждой ячейке будет выполняться f от n на b операции и так далее.
[07:58.000 --> 08:03.000]  Тогда наша оценка, это будет сумма от 0 до глубины.
[08:03.000 --> 08:13.000]  Собственно, a в итой f от n поделить на b в итой.
[08:13.000 --> 08:16.000]  Вот это то, что внутри дерева.
[08:22.000 --> 08:27.000]  А потом мы досчитываем сколько у нас будет листьев в дереве.
[08:27.000 --> 08:31.000]  Вот, то есть a в степени h будет листьев.
[08:33.000 --> 08:36.000]  И, соответственно, в каждом листе константа.
[08:36.000 --> 08:41.000]  Вот, как известно, константа операции, когда дерево уже перестает разветвляться дальше.
[08:41.000 --> 08:45.000]  Ну и, собственно, когда мы смотрим, что происходит в листьях,
[08:45.000 --> 08:51.000]  то мы возьмем a в h умножим на константу в листьях.
[08:53.000 --> 08:55.000]  Дальше мы это все сложим.
[08:55.000 --> 08:58.000]  То есть может быть достаточно очень-очень сильно разветвляться.
[08:58.000 --> 09:00.000]  Допустим, может дерево и быстро.
[09:00.000 --> 09:06.000]  И тогда эти константы из листьев за счет количества листьев заберут на себя основную массу работы.
[09:06.000 --> 09:14.000]  А может, наоборот, дерево быть каким-нибудь графом путем, каким-нибудь получится оно.
[09:14.000 --> 09:21.000]  И тогда в течение самих этих разделений вызывает t от n пополам плюс там еще что-нибудь.
[09:21.000 --> 09:27.000]  Например, тогда внутри самого дерева наберется намного больше операций, чем в листьях.
[09:27.000 --> 09:31.000]  Но складывать мы должны посчитать то, посчитать второе и сложить.
[09:33.000 --> 09:35.000]  Это оценка через дерево лькуси.
[09:35.000 --> 09:40.000]  Если оценка через мастер-теорему, мастер-теорема, как мы правильно можем вспомнить,
[09:40.000 --> 09:48.000]  мы можем вспомнить t от n, a t от n на b плюс f от n.
[09:48.000 --> 09:54.000]  Обозначаем d логонифом по основанию b от a и три случая.
[09:54.000 --> 10:11.000]  Первый, если f от n, то есть если существует epsilon больше нуля, f от n это o большое от n в степени d минус epsilon,
[10:11.000 --> 10:17.000]  то есть, грубо говоря, для своего внимания f от n маленькое.
[10:18.000 --> 10:27.000]  Следовательно, тогда t от n это o от n в степени d.
[10:27.000 --> 10:35.000]  Второй случай, если f от n это θ от n в степени d,
[10:35.000 --> 10:49.000]  тогда t от n это θ от n в степени d логон, кто писать не умеет, я писать не умею.
[10:49.000 --> 10:58.000]  Ну и наконец третья часть, это когда f от n большое, существует epsilon больше нуля,
[10:58.000 --> 11:16.000]  такое, что f от n оценивается снизу как n в степени d плюс epsilon, тогда t от n это θ от f от n.
[11:16.000 --> 11:26.000]  Но здесь, кроме прочего, должно быть еще такое, что существует константа из помежутка от нуля до единицы такая,
[11:26.000 --> 11:39.000]  что a f от n на b должно быть меньше, чем c f от n. Здесь условие 2.
[11:39.000 --> 11:48.000]  Вот, мастер-теорему помним, дерево-рекурсии помним, определение вот эти про асимпотики помним.
[11:48.000 --> 11:55.000]  Соответственно, дальше, что мы сделаем? Сейчас мы посмотрим на пару задачек на мастер-теорему на три случая
[11:55.000 --> 12:01.000]  и на задачку еще достаточно такую интересную тему. Была задачка год назад на контрольной.
[12:01.000 --> 12:07.000]  Вот была задачка. Рекурендтные соотношения часто решают методом постановки.
[12:07.000 --> 12:16.000]  Для разрешения t от n равно 2t от n пополам плюс cn.
[12:16.000 --> 12:31.000]  Можно подставить d лог d, dn лог d, dn лог n и подобрать d так, чтобы доказать индуктивный переход.
[12:31.000 --> 12:37.000]  То есть, предполагаем, что t от n это dn лог n.
[12:37.000 --> 12:42.000]  По мастер-теореме, если прикинуть, то здесь d маленькая из мастер-теоремы это единичка.
[12:42.000 --> 12:53.000]  Собственно, f это t от f первой и, соответственно, по идее должно вот такое получиться.
[12:53.000 --> 12:58.000]  Дальше они просто подбирают константу. То есть, асимпотика предполагается, константа подбирается
[12:58.000 --> 13:03.000]  и таким образом доказываем, что это действительно рабочая схема.
[13:03.000 --> 13:12.000]  Ну, что дальше? А дальше вот мы говорим о задаче.
[13:12.000 --> 13:19.000]  Так, что-то вылетело. Я про константы проверить надо, чтобы они правильнее были.
[13:19.000 --> 13:38.000]  t от n равно, значит, соответственно, 2t от n пополам и плюс единица.
[13:38.000 --> 13:45.000]  Легко получить, что t от n это t от n. Логично?
[13:45.000 --> 13:50.000]  Если посмотреть опять-таки на мастер-теорему, то d маленькая из мастер-теоремы единица,
[13:50.000 --> 13:58.000]  f от n это у малое от, ну, даже если epsilon равен единице, то тогда будет,
[13:58.000 --> 14:05.000]  существует epsilon равный единице такой, что f от n, то есть единица, это o большое от n в степени 1-1,
[14:05.000 --> 14:10.000]  то есть от n в нулевой, то есть от единицы. Соответственно, t от n должно быть t от n.
[14:10.000 --> 14:26.000]  Дальше. Если подставить t от n пополам равное dn пополам, то получим, ну, что мы получим?
[14:26.000 --> 14:37.000]  Мы получим ничего хорошего. t от n равно 2 на dn пополам плюс 1.
[14:37.000 --> 14:48.000]  А с одной стороны должно быть dn плюс 1, а с другой стороны тогда t должно быть dn.
[14:48.000 --> 14:56.000]  Логично? Противоречие? Казалось бы.
[14:56.000 --> 15:05.000]  Вот. Если мы, если, это нам такое дается в условии, если мы подставим вот такое, то что тогда будет?
[15:05.000 --> 15:13.000]  Вот это будет так. Да? Да. Под знак равенства подставляем ту же самую тему.
[15:13.000 --> 15:18.000]  Получается, двойка на двойка сокращается. Вот. Ну, бред же. Бред.
[15:18.000 --> 15:24.000]  Соответственно, нам нужно найти ошибку. Вот.
[15:24.000 --> 15:29.000]  Как-то исправить и решить рекурсионное соотношение методом подстановки.
[15:29.000 --> 15:41.000]  Вот. Ну, а что мы знаем? А мы знаем, что не обязательно, если f от n это t от n, то это просто какая-то константа умноженная на n.
[15:41.000 --> 15:51.000]  Нет. Мы хотим, допустим, я хочу подставить dn плюс константа.
[15:54.000 --> 15:57.000]  Логично? Могу так сделать? Могу так сделать.
[15:57.000 --> 16:02.000]  Ну, тогда что происходит? Тогда происходит dn плюс константа.
[16:02.000 --> 16:10.000]  Это 2 на dn плюс константа. И еще плюс 1.
[16:10.000 --> 16:16.000]  Тогда... Что? Да, dn пополам. Спасибо.
[16:16.000 --> 16:25.000]  Тогда dn плюс константа. Это, собственно говоря, dn плюс 2 константы плюс 1.
[16:25.000 --> 16:35.000]  Ну, dn с dn сокращается. Константа с константой... Соответственно, константа должна быть равна минус 1.
[16:35.000 --> 16:40.000]  Окей. Константу мы нашли. Но все ли так просто?
[16:40.000 --> 16:47.000]  А вот я хочу сказать... Что я хочу сказать?
[16:47.000 --> 16:57.000]  Я хочу, чтобы наша функция, как известно, она бьет из n в r плюс, в строго положительные числа.
[16:57.000 --> 17:03.000]  Помним такое? Функции, которые мы работаем в курсе алгоритма. Они бьют именно в r плюс.
[17:03.000 --> 17:11.000]  Ну, соответственно, значит что? t от единицы больше нуля. Логично? Логично.
[17:11.000 --> 17:19.000]  Ну, соответственно, d минус 1 больше нуля. d больше единицы.
[17:19.000 --> 17:29.000]  Ну, соответственно, даже такая функция t от n равна 2n минус 1. Подходит.
[17:29.000 --> 17:39.000]  Мы можем подставить ее рекуррентное соотношение, получить соответственно верное равенство
[17:39.000 --> 17:48.000]  и таким образом показать, что вот это заведомо t от единицы, t от n, и значит наша функция является t от n.
[17:48.000 --> 17:54.000]  Логично? Всем логично? Отлично.
[17:54.000 --> 18:03.000]  Так, хорошо. С такой темой, как рекуррентное соотношение постановкой и с двумя важными фактами,
[18:03.000 --> 18:08.000]  что просто так об и что мы поставлять не можем, то есть t от функции,
[18:08.000 --> 18:12.000]  не обязательно константа, умноженная на функцию, и что функция бьет в r плюс.
[18:12.000 --> 18:16.000]  Это важно помнить. Мы, собственно, мы это помним.
[18:16.000 --> 18:20.000]  Ну, дальше что? Дальше давайте мастер-теорему.
[18:20.000 --> 18:40.000]  Ну, я хочу допустим, я не знаю, 16t от n поделить на 4 плюс 3n квадрат плюс 1.
[18:40.000 --> 18:48.000]  Вот. Похоже на соотношение из мастер-теоремы? Да, похоже.
[18:48.000 --> 18:55.000]  Соответственно, что a равно 16, b равно 4, d равно 4 от 16.
[18:55.000 --> 18:58.000]  Это будет соответственно 2.
[18:58.000 --> 19:05.000]  Собственно, f от n это 3n квадрат плюс 1.
[19:05.000 --> 19:12.000]  Это t от n квадрат, это t от n с этими d. Логично?
[19:12.000 --> 19:16.000]  Логично. Значит, в какой случае мастер-теоремы применяем?
[19:16.000 --> 19:22.000]  Второй. Соответственно, t от n. Согласно второму случаю мастер-теоремы.
[19:28.000 --> 19:37.000]  Оно будет равно t от n квадрат лог n. Логично?
[19:37.000 --> 19:43.000]  Хорошо. Дальше? Ну, дальше проверим, допустим, первый случай.
[19:43.000 --> 19:45.000]  Ну, что у нас на первый случай?
[19:45.000 --> 19:54.000]  Я хочу сказать, что t от n будет, ну, так, нам надо, чтобы d было достаточно большим.
[19:54.000 --> 20:12.000]  Ну, окей, 125t от n на 25 плюс n квадрат лог n. Вот так.
[20:13.000 --> 20:24.000]  Соответственно, что a равно 125, b равно 5.
[20:24.000 --> 20:32.000]  b равно 5, d равно, соответственно, логарифм по основанию 5 от 125.
[20:32.000 --> 20:44.000]  Это будет 3. f от n. Это n квадрат лог n. Это o большое.
[20:44.000 --> 20:51.000]  Ну, оценим, как n два с половиной. Это верно? Это верно.
[20:51.000 --> 20:55.000]  Потому что лог n оценивается сверху любой степенью n.
[20:55.000 --> 21:01.000]  Ну, вот и все. Соответственно, существует epsilon, равный, ну, даже 0,5.
[21:01.000 --> 21:09.000]  Логично? Логично. Вот. Ну, таким образом, согласно первому случаю мастер-тиоремы,
[21:09.000 --> 21:22.000]  t от n будет t от n. Логично? Логично.
[21:22.000 --> 21:38.000]  И, наконец, последний случай. Значит,
[21:38.000 --> 22:01.000]  последний случай t от n. Это, ну, пускай 5t от n на 25, вот, плюс n.
[22:01.000 --> 22:15.000]  Что? Тогда я говорю a равно 5, b равно 25. Видно?
[22:15.000 --> 22:21.000]  d равно логарифм по основанию 25 от 5. Это 1 вторая.
[22:21.000 --> 22:37.000]  Соответственно, f от n. Это n. Это ω от n в степени 0,75.
[22:37.000 --> 22:43.000]  Существует epsilon, равный 0,25. Вполне себе? Вполне себе.
[22:43.000 --> 22:52.000]  И при этом, ну, существует, существует константа, чему равная.
[22:52.000 --> 23:01.000]  Давайте a, f от n, b. Соответственно, это будет 5 умножить на n, 25.
[23:01.000 --> 23:14.000]  Это n пятых. Ну, меньше, чем n на, ну, пускай 4. Вот.
[23:14.000 --> 23:20.000]  А равно 1 четвертая на n. Ну, константа равная 1 четвертой.
[23:20.000 --> 23:29.000]  Вот. Соответственно, по третьему случае мастер теоремы t от n. Это θ от n.
[23:29.000 --> 23:39.000]  Логично. Вот. Если у нас вдруг, например, не будет выполняться вот это свойство,
[23:39.000 --> 23:43.000]  например, тут будет какой-нибудь логарифм гулять или вроде того,
[23:43.000 --> 23:46.000]  то тогда мы будем просто мучаться суммировать дерево рекурсии.
[23:46.000 --> 23:50.000]  То есть распишем дерево рекурсии, посчитаем его высоту,
[23:50.000 --> 23:56.000]  поскладываем вот эту сумму, посчитаем количество листов,
[23:56.000 --> 23:59.000]  поскладываем сумму в листах, собственно, константы.
[23:59.000 --> 24:03.000]  И, собственно, сложив их, найдем вот это асимптотику.
[24:03.000 --> 24:11.000]  Вот. Ну, собственно говоря, базовое понимание того, как это происходит,
[24:11.000 --> 24:16.000]  везде. Вот. Это применяется. Как асимптотику считать?
[24:16.000 --> 24:24.000]  Всем понятно, осознаваемо, легко, халяво. Все решат? Все решат. Все решат?
[24:24.000 --> 24:33.000]  Отлично. Так. Очередь. Что? С постановкой? Ну, давайте сейчас. Почему что?
[24:33.000 --> 24:47.000]  Ну так потому, что я задаю, что t от n пополам. Ну, что? Ну, t от n пополам.
[24:47.000 --> 24:52.000]  Ну, что это такое, грубо говоря? t от n пополам я хочу сказать.
[24:52.000 --> 24:58.000]  Это ведь тоже самое буквально. Вот такая запись. Логично?
[25:03.000 --> 25:09.000]  Где? Нет, это вот здесь как бы описывалось, что вот существует такая тема,
[25:09.000 --> 25:15.000]  что вот тут есть такая рекуррента. Допустим, ну как?
[25:15.000 --> 25:19.000]  Здесь описывается метод постановки как факт, что вот есть такая рекуррента.
[25:19.000 --> 25:26.000]  Мы можем придумать какую-то функцию, вот такую, подставить ее сюда, порешать,
[25:26.000 --> 25:36.000]  показать, что это правильно, точно и работает, и получить, собственно говоря, нужную нам доказательств.
[25:36.000 --> 25:40.000]  Вот эта функция при постановке сюда даст верное равенство.
[25:40.000 --> 25:45.000]  Соответственно, значит, наша t от n имеет асимптотику вот такую.
[25:45.000 --> 25:52.000]  А здесь что произошло? Ну, вот я говорю, человек, который это делал гипотетически,
[25:52.000 --> 25:57.000]  говорит, что я хочу задать вот такую функцию.
[25:57.000 --> 26:01.000]  Ну, это ведь тоже самое, что вот эта запись. Логично?
[26:01.000 --> 26:07.000]  Кажется, нет. Нет? Почему нет?
[26:07.000 --> 26:13.000]  Нет, это вот одна и та же d. Вот эта запись и вот эта запись, они же идентичны?
[26:13.000 --> 26:19.000]  Нет, другая d. Это одно, это из объяснения, а это просто так само по себе.
[26:19.000 --> 26:24.000]  Новая задача пошла. Вам дана новая рекуррента.
[26:24.000 --> 26:28.000]  И вы в этой новой рекурренте пытаетесь что-то сделать.
[26:28.000 --> 26:33.000]  Ваш гипотетический человек говорит, я хочу решать ее вот так.
[26:33.000 --> 26:38.000]  Я задал вот такую функцию. Логично, что это вот тоже самое?
[26:38.000 --> 26:42.000]  Ну, собственно говоря, потом этот гипотетический человек подставляет.
[26:42.000 --> 26:47.000]  Сюда будет функцию, в левую часть это получается dn, в правую часть, собственно,
[26:47.000 --> 26:50.000]  в правую часть рекуррента он подставляет вместо t эту же функцию.
[26:50.000 --> 26:56.000]  Получается dn плюс константа. И он такой, что делать?
[26:56.000 --> 27:02.000]  Ну, и такой не получилось. Как-то плохой у вас метод.
[27:02.000 --> 27:07.000]  А мы ему говорим, что нет, метод наш неплохой, просто ты функцию выбрал неправильную.
[27:07.000 --> 27:11.000]  А мы выберем правильную. Вот она наша правильная функция.
[27:11.000 --> 27:14.000]  Не будем ограничиваться просто dn, добавим еще к ней константу.
[27:14.000 --> 27:19.000]  И дальше, собственно, эту константу, с этой константой будем гонять наш.
[27:22.000 --> 27:27.000]  Ну да, мы по мастер-теореме, мы-то по мастер-теореме, но человек интуитивно.
[27:27.000 --> 27:33.000]  В голове какая-то у него интуитивная мастер-теорема, но он ее, допустим, не помнит, доказать не может.
[27:33.000 --> 27:37.000]  То есть вот он, как у меня было в начале введение курса алгоритмов, например,
[27:37.000 --> 27:43.000]  что вот есть мастер-теорема, а как там все точно доказать, это надо было вспомнить,
[27:43.000 --> 27:48.000]  открыть и обновить у себя в памяти эту надпись, что вот все такие соотношения.
[27:48.000 --> 27:52.000]  Но как бы при беглом взгляде на вот это, я бы сказала, n log n.
[27:52.000 --> 27:56.000]  При беглом взгляде на вот это, я бы сказала, n.
[27:56.000 --> 28:01.000]  Ну или там по дереву расписал, но в своем решении, в правильности своего дерева он не уверен.
[28:01.000 --> 28:08.000]  Откуда-то у него из головы вот эта оценка, скорее всего оно там тета от чего-то.
[28:08.000 --> 28:13.000]  И дальше он берет какую-то функцию из класса тета от чего-то.
[28:13.000 --> 28:20.000]  То есть здесь удалось без каких-либо добавочных константов работать, допустим, им, а здесь нет.
[28:20.000 --> 28:27.000]  Как мы все помним, важный факт, что о, омега и тета – это класс, класс и функция, то есть это множество.
[28:27.000 --> 28:33.000]  И нельзя ни в коем случае написать, что омега от n, например, равно n. Нет.
[28:33.000 --> 28:37.000]  Знак равен, то есть только функция равна, собственно, классу.
[28:37.000 --> 28:43.000]  То есть это как бы такая договоренность, неформальная, что на самом деле надо написать, например, вот так.
[28:43.000 --> 28:46.000]  n принадлежит омега от n.
[28:46.000 --> 28:51.000]  Но мы не хотим везде писать, принадлежит, поэтому мы пишем равно. Переставить местами нельзя.
[28:51.000 --> 28:53.000]  Логично?
[29:03.000 --> 29:08.000]  Если ты не хочешь оценивать тету, а хочешь оценивать о или омегу?
[29:08.000 --> 29:34.000]  Ну, это не совсем так, типа, да, это так не можно, да.
[29:34.000 --> 29:42.000]  Нет. Если ты хочешь оценить тету через вот такое веселье, то ты должен тогда и сверху, и снизу, и константы по подбирать.
[29:42.000 --> 29:47.000]  Но на самом деле все проще через мастера решать и через яреварь рекурсий в худшем случае.
[29:47.000 --> 29:49.000]  Вот.
[29:49.000 --> 29:53.000]  Где?
[29:53.000 --> 30:05.000]  Ну, мы говорим, что t от n вот такое годится для нашей рекурренты.
[30:05.000 --> 30:11.000]  Вот. Ну, а рекуррент она однозначно задает, собственно, нашу функцию.
[30:11.000 --> 30:19.000]  Собственно, вот мы ее нашли. Да?
[30:19.000 --> 30:23.000]  Да, они только деревом. Для них мастертирами, к сожалению, нет.
[30:23.000 --> 30:30.000]  Оценка снизу, оценка сверху, в случае чего-то по длинному, по длинной ветке, по короткой ветке, можете прикинуть.
[30:30.000 --> 30:37.000]  Вот. Если совпадет, повезет. Если не совпадет, придется дальше мучаться.
[30:37.000 --> 30:43.000]  Вот. Хорошо. Дальше. Понятно все про рекурренты?
[30:43.000 --> 30:51.000]  Вот. На эти деревья там одна задача была. В Домашке одна задача классная, так что я очень сильно сомневаюсь.
[30:51.000 --> 30:55.000]  Теперь Алина расскажет. Про что Алина расскажет?
[30:55.000 --> 31:00.000]  Я скажу про всякие твои задачи, где нужно придумать алгоритмы, там где сортировки.
[31:00.000 --> 31:06.000]  Такие видели в Домашках. На них аж много листочек.
[31:06.000 --> 31:17.000]  Я что будет в контрольной не знаю совсем, но там же есть вторая часть, в которой задачи не простые, как в первой.
[31:17.000 --> 31:25.000]  И там обычно нужно придумать какой-то алгоритм, и он как-то не связан с какой-то конкретной темой.
[31:25.000 --> 31:29.000]  Либо там нужно воспользоваться какими-то известными алгоритмами.
[31:30.000 --> 31:37.000]  Несколько раз применить и доказать корректность того, что мы это последовательно применяем и получаем то, что нужно.
[31:37.000 --> 31:42.000]  Сейчас я разберу две такие задачи из прошлой контрольной.
[31:42.000 --> 31:49.000]  Когда ты видела еще задачи из контрольных годов ранее, и там они тоже были, это очень логично.
[31:49.000 --> 31:53.000]  Просто придумай тебе алгоритмы чего-нибудь.
[31:53.000 --> 32:03.000]  Первая задача. На вход подается массив из 2n чисел.
[32:03.000 --> 32:12.000]  Построить алгоритм, который разбивает эти 2n чисел на пары так, что максимальная сумма чисел в парах минимальна.
[32:12.000 --> 32:27.000]  Есть такой алгоритм, такой массив, в нем 2n чисел.
[32:27.000 --> 32:33.000]  Нам нужно эти 2n чисел разбить на пары.
[32:33.000 --> 32:45.000]  Как бы на пары какие-то А1, 1, а вот на И, это каждая пара такая.
[32:45.000 --> 32:59.000]  Такая, что вот такая сумма, вот такое число минимально по всем И.
[32:59.000 --> 33:06.000]  И у нас, соответственно, от 1 до n, сколько у нас пар.
[33:06.000 --> 33:11.000]  И что, собственно, можно здесь делать?
[33:11.000 --> 33:16.000]  Можно воспользоваться уже тем, чем вы пользовались, это сортировки.
[33:16.000 --> 33:19.000]  Можно отсортировать как угодно эти числа.
[33:19.000 --> 33:24.000]  Допустим, можно указать, чем вы сортируете, например, слиянием.
[33:24.000 --> 33:27.000]  И отсортируем этот массив.
[33:27.000 --> 33:37.000]  Вот, у нас теперь он отсортированный, и отсортированную его версию мы назовем b1, b2 и b2n.
[33:37.000 --> 33:41.000]  Вот. Что?
[33:41.000 --> 33:45.000]  Условие такое, что у нас есть массив, в нем 2n чисел.
[33:45.000 --> 33:47.000]  Ну, теперь четное число.
[33:47.000 --> 33:52.000]  И нам нужно разбить на пары, ну, то есть на выходе должны быть пары.
[33:52.000 --> 34:02.000]  Н пар таких, что максимальная сумма в паре минимальна.
[34:02.000 --> 34:04.000]  Вы поняли условия?
[34:04.000 --> 34:07.000]  Короче, я постараюсь формально записать условия.
[34:07.000 --> 34:13.000]  Смотрите, у нас есть массив, и мы разбиваем на пары.
[34:13.000 --> 34:15.000]  Обрабатывайте условия.
[34:15.000 --> 34:17.000]  Короче, мы разбиваем на пары.
[34:17.000 --> 34:27.000]  Вот пара 1, вот пара 2.
[34:27.000 --> 34:34.000]  Допустим, нижний индекс – это номер пары, верхний индекс – это номер числа в паре.
[34:34.000 --> 34:35.000]  И так далее.
[34:35.000 --> 34:43.000]  И здесь будет an1, an2.
[34:43.000 --> 34:45.000]  Вот это выход.
[34:45.000 --> 34:47.000]  И что нам нужно от выхода?
[34:47.000 --> 35:09.000]  Чтобы максимальная по i от 1 до n, вот такого числа, было минимально.
[35:09.000 --> 35:13.000]  Стало ли так понятнее, если записала это формально?
[35:13.000 --> 35:14.000]  Ну да, наверное.
[35:14.000 --> 35:18.000]  Ну, то есть я верю, что если иметь условия перед глазами, то это будет совсем понятно.
[35:18.000 --> 35:22.000]  Но вот требование такое от выхода.
[35:22.000 --> 35:25.000]  И, собственно, мы делаем простую штуку.
[35:25.000 --> 35:27.000]  Мы сортируем массив.
[35:27.000 --> 35:30.000]  Ну, это логичное действие с массивом.
[35:30.000 --> 35:35.000]  А дальше мы разбиваем по парам вот так.
[35:36.000 --> 35:39.000]  Вот раз пара, два пара.
[35:39.000 --> 35:41.000]  То есть мы разбиваем на пары b и t.
[35:41.000 --> 35:47.000]  И b2n-i плюс 1.
[35:47.000 --> 35:48.000]  Ну, это как раз можно проверить.
[35:48.000 --> 35:51.000]  Иr1 и 2n.
[35:51.000 --> 35:56.000]  Ну да, понятно, что мы вот так соединяем.
[35:56.000 --> 35:57.000]  Это, на самом деле, логично.
[35:57.000 --> 36:00.000]  Мы берем, чтобы в паре было самое маленькое и самое большое.
[36:00.000 --> 36:04.000]  Потом второе по маленькости и второе по величине.
[36:04.000 --> 36:05.000]  Вот.
[36:05.000 --> 36:07.000]  Ну так, чтобы у нас примерно было сбалансировано.
[36:07.000 --> 36:09.000]  То есть интуитивно понятно, что происходит?
[36:09.000 --> 36:12.000]  Ну, то есть какую-то логичную штуку сделали.
[36:12.000 --> 36:14.000]  Хорошо.
[36:14.000 --> 36:15.000]  Действие простое.
[36:15.000 --> 36:20.000]  Мы взяли, отсортировали и потом разбили вот так на пары.
[36:20.000 --> 36:27.000]  На контрольной, как и в домашних и в любых задачах, нужно еще доказать корректность и оценить симпатику.
[36:27.000 --> 36:28.000]  Но симпатику здесь проще.
[36:28.000 --> 36:29.000]  Давайте с нее начнем.
[36:30.000 --> 36:35.000]  Что сортировка это n log n.
[36:35.000 --> 36:36.000]  Хорошо.
[36:36.000 --> 36:40.000]  Первое действие у нас от n log n.
[36:40.000 --> 36:44.000]  На самом деле, формально здесь 2n, 2n, 2log n.
[36:44.000 --> 36:48.000]  Но это ничего не меняет.
[36:48.000 --> 36:52.000]  Второе действие мы берем, разбиваем на пары.
[36:52.000 --> 36:53.000]  Ну, это что?
[36:53.000 --> 36:56.000]  Мы просто расходимся по массиву.
[36:56.000 --> 37:00.000]  Это o от n.
[37:00.000 --> 37:02.000]  Ну, значит, это поменьше.
[37:02.000 --> 37:05.000]  Их сумма это o от n log n.
[37:08.000 --> 37:12.000]  То есть подробно, конечно, можно не расписывать, как считается асимпточка.
[37:12.000 --> 37:15.000]  Но вот два таких простых действия.
[37:15.000 --> 37:18.000]  Значит, асимпточка всего алгоритма n log n.
[37:18.000 --> 37:22.000]  Весь прикол задачи в корректности, кажется.
[37:22.000 --> 37:23.000]  Нет, весь прикол, наверное, придумать.
[37:23.000 --> 37:26.000]  Но самое сложное здесь это доказать корректность.
[37:26.000 --> 37:27.000]  Что мы делаем?
[37:27.000 --> 37:30.000]  Ну, ее можно доказать от противного.
[37:30.000 --> 37:33.000]  То есть у нас есть какой-то набор, который мы получили.
[37:33.000 --> 37:36.000]  Вот таких пар такого вида.
[37:36.000 --> 37:40.000]  И мы утверждаем, что он подходящий.
[37:40.000 --> 37:43.000]  Максимум таких сумм он минимален.
[37:43.000 --> 37:45.000]  Ну, можно предположить, что он не минимален.
[37:45.000 --> 37:49.000]  И представить другое развиение.
[37:49.000 --> 37:57.000]  Допустим, у нас сумма максимальна в какой-то паре.
[37:57.000 --> 38:04.000]  На самом деле здесь делается индуктивно.
[38:04.000 --> 38:10.000]  Смотрите, если у нас n равно единице, то у нас всего одна пара.
[38:10.000 --> 38:14.000]  Ничего интересного в этом случае не происходит.
[38:14.000 --> 38:19.000]  Если n равно 2, то что мы говорим?
[38:19.000 --> 38:24.000]  Что у нас есть 1, a2, a3, a4.
[38:24.000 --> 38:32.000]  И на самом деле можно просто руками посмотреть, что они уже отсортированы.
[38:32.000 --> 38:37.000]  И мы смотрим, что если у нас как-то по-другому,
[38:37.000 --> 38:42.000]  это означает, что либо a1, a2 пара есть.
[38:42.000 --> 38:45.000]  Либо вот эта пара и вот эта.
[38:45.000 --> 38:48.000]  Либо вот эта пара и вот эта.
[38:48.000 --> 38:52.000]  Здесь легко показать, что у нас вот эти два числа меньше.
[38:52.000 --> 38:55.000]  Каждый из них вот этих двух.
[38:55.000 --> 39:01.000]  И у нас максимальная пара будет a3 плюс a4.
[39:01.000 --> 39:05.000]  Но наш алгоритм бы выдал a1.
[39:05.000 --> 39:10.000]  Но это явно больше, чем a1 плюс a4.
[39:10.000 --> 39:14.000]  И больше, чем a2 плюс a3.
[39:14.000 --> 39:16.000]  Правда?
[39:16.000 --> 39:19.000]  У нас эти просто самые большие числа.
[39:19.000 --> 39:23.000]  Значит, вот такое разбиение точно не подходит.
[39:23.000 --> 39:26.000]  Это первый случай.
[39:26.000 --> 39:31.000]  А второй, что мы разбили вот так на пары.
[39:31.000 --> 39:36.000]  То есть у нас вот так.
[39:36.000 --> 39:43.000]  У нас есть сумма 1 плюс a3 и a2 плюс a4.
[39:43.000 --> 39:52.000]  Но у нас a2 плюс a4 явно больше и равно, чем a2 плюс a3.
[39:52.000 --> 39:59.000]  А это больше или равно, чем a4?
[39:59.000 --> 40:01.000]  Нет, а сейчас.
[40:01.000 --> 40:03.000]  Я, кажется, сама запуталась.
[40:03.000 --> 40:07.000]  1 плюс...
[40:07.000 --> 40:12.000]  Меньше ли, должно быть в другую сторону.
[40:12.000 --> 40:14.000]  Чем a1?
[40:14.000 --> 40:17.000]  Сейчас.
[40:17.000 --> 40:20.000]  Какая-то путаница вышла.
[40:20.000 --> 40:25.000]  Сек.
[40:25.000 --> 40:37.000]  Там у нас, когда мы так разбиваем.
[40:37.000 --> 40:38.000]  Сейчас.
[40:38.000 --> 40:42.000]  На самом деле, мы здесь оценивали одной вот такой суммой.
[40:42.000 --> 40:45.000]  А на нас было, мы знали, что она максимально.
[40:45.000 --> 40:47.000]  А там?
[40:47.000 --> 40:49.000]  Что?
[40:49.000 --> 40:53.000]  Вот здесь?
[40:53.000 --> 40:59.000]  Слева?
[40:59.000 --> 41:01.000]  Нет, смотри.
[41:01.000 --> 41:03.000]  Здесь мы что хотим показать?
[41:03.000 --> 41:08.000]  Что наше вот такое разбиение, оно действительно оптимально.
[41:08.000 --> 41:16.000]  Да, действительно, она больше, чем a2.
[41:16.000 --> 41:18.000]  Да, спасибо.
[41:18.000 --> 41:20.000]  У нас есть какая-нибудь тряпка?
[41:20.000 --> 41:24.000]  Этого действительно достаточно, потому что она одна.
[41:24.000 --> 41:27.000]  О, кофе, конечно.
[41:27.000 --> 41:28.000]  Сейчас.
[41:28.000 --> 41:31.000]  Она станет чуть.
[41:31.000 --> 41:33.000]  А воды тут нет?
[41:33.000 --> 41:35.000]  Вода есть.
[41:35.000 --> 41:42.000]  Чуть-чуть сейчас.
[41:42.000 --> 41:48.000]  Ну да, и у нас вот это и больше или равно, чем a1 плюс a4.
[41:48.000 --> 41:50.000]  Ну это, допустим, была база.
[41:50.000 --> 41:53.000]  А что мы делаем по индукции?
[41:53.000 --> 42:00.000]  У нас есть теперь вот такой отсортированный массив.
[42:00.000 --> 42:05.000]  A2n-1, a2n.
[42:05.000 --> 42:11.000]  И мы предполагаем, что у нас для n верно.
[42:11.000 --> 42:21.000]  Соответственно, если мы уберем вот эти два элемента, то у нас внутри отсортированный массив выдаст то, что нужно.
[42:21.000 --> 42:29.000]  Значит, теперь, когда мы запустили наш алгоритм для вот всего массива, то у нас вдруг что-то поменялось.
[42:29.000 --> 42:39.000]  Если что-то поменялось, это означает, что у нас минимальный или максимальный элемент в паре не друг с другом.
[42:39.000 --> 42:41.000]  Это понятно, ведь?
[42:41.000 --> 42:42.000]  Ну вот этот переход.
[42:42.000 --> 42:52.000]  Хорошо, у нас предположим, вот это минимальный элемент, вот этот максимальный.
[42:52.000 --> 43:00.000]  Допустим, они в паре с каким-то a, а максимальный с каким-то b.
[43:00.000 --> 43:06.000]  Ну тогда у нас на самом деле повторяются те же самые рассуждения.
[43:06.000 --> 43:12.000]  Пусть у нас вот это число максимальное от суммы это m.
[43:13.000 --> 43:25.000]  Теперь мы сравниваем. То есть мы знаем, что любые суммы вот здесь, то есть любые суммы вот в этом отсортированном массиве пар, они меньше или равны, чем m.
[43:25.000 --> 43:39.000]  Ну, что мы сделаем? Мы поменяем теперь вот такие пары на пару min-max и ab, как мы и хотели изначально.
[43:39.000 --> 43:48.000]  И тогда, что мы скажем? Что у нас min-plus-a меньше или равен, чем m.
[43:48.000 --> 43:52.000]  Ну, потому что мы как раз m-такое взяли в нашем разбиении.
[43:55.000 --> 44:01.000]  И max-plus-b тоже меньше или равен, чем m.
[44:01.000 --> 44:18.000]  Теперь мы, теперь в нашем теперь будет, сейчас min-plus-max будет меньше, чем вот это.
[44:18.000 --> 44:24.000]  И тоже меньше, равен, чем m.
[44:24.000 --> 44:34.000]  А a-plus-b будет меньше и равно, чем max-plus-b. Тоже меньше и равен, чем m.
[44:34.000 --> 44:39.000]  Значит, то, как мы разбили, это как минимум не хуже.
[44:39.000 --> 44:46.000]  Поэтому если мы вдруг, если у нас есть какое-то альтернативное разбиение, то хорошо.
[44:46.000 --> 44:51.000]  Но наш алгоритм находит то, которое не хуже любого хорошего.
[44:51.000 --> 44:57.000]  Понятно суть? То есть, общая концепция такая. Мы взяли какое-то другое разбиение.
[44:57.000 --> 45:00.000]  Абсолютно любое мы можем взять.
[45:00.000 --> 45:06.000]  И потом показываем, что то, которое приводит наш алгоритм, оно не хуже.
[45:06.000 --> 45:09.000]  И этого достаточно сказать, что оно оптимальное.
[45:09.000 --> 45:15.000]  Потому что если есть что-то получше, то мы снова можем сказать, что оно не хуже.
[45:16.000 --> 45:21.000]  Я там в середине запуталась. Вы не потерялись по дороге?
[45:27.000 --> 45:31.000]  С какого момента? С начала? Хорошо, давай вообще в чертах.
[45:31.000 --> 45:34.000]  Сейчас я точно не запутаюсь, смотри.
[45:34.000 --> 45:39.000]  Ну, алгоритм понятен, как действует. Хорошо, теперь про корректность.
[45:39.000 --> 45:43.000]  Мы доказываем по индукции.
[45:43.000 --> 45:47.000]  То есть, для n равно 1 мы рассматривать не будем, там всего одна пара.
[45:47.000 --> 45:54.000]  Для n равно 2 мы рассмотрели, наш алгоритм приводит пары a1, a4, a2, a3.
[45:54.000 --> 45:57.000]  Мы теперь рассматриваем, вдруг у нас есть разбиения получше.
[45:57.000 --> 45:59.000]  Какие будут тут есть разбиения?
[45:59.000 --> 46:04.000]  Ну, их типа конечное число это a1, a2, a4.
[46:04.000 --> 46:07.000]  Или a1, a2, a3, a4.
[46:07.000 --> 46:10.000]  Ну, вот второе, оно не подходит, очевидно, почему.
[46:10.000 --> 46:14.000]  Потому что у нас a3, a4 – это самые большие элементы.
[46:14.000 --> 46:20.000]  И они будут явно больше, чем a1, a4 и a2, a3.
[46:20.000 --> 46:22.000]  Это мы отбросили сразу.
[46:22.000 --> 46:29.000]  Теперь у нас, возможно, случай a1 плюс a3 и a2 плюс a4.
[46:29.000 --> 46:32.000]  Но a2 плюс a4 больше, чем a2 плюс a3.
[46:32.000 --> 46:36.000]  Ну, понятно, почему, потому что a3 меньше, чем a4.
[46:37.000 --> 46:42.000]  И a1 на 3, ну, собственно, a2, a4 больше, чем a1 на 3.
[46:42.000 --> 46:45.000]  Соответственно, эти оба варианта, ну, не лучше точно.
[46:45.000 --> 46:48.000]  Потому что здесь нестрогие неравенства, они могут быть такими же.
[46:48.000 --> 46:50.000]  Хорошо, для базы мы доказали.
[46:50.000 --> 46:51.000]  Шаг какой?
[46:51.000 --> 46:55.000]  Мы отсортировали массив, потом здесь взяли…
[46:55.000 --> 46:58.000]  Ну, а потом в центр мы умеем отсортировать.
[46:58.000 --> 47:05.000]  То есть наша сортировка плюс последующий выбор пар, короче, наш алгоритм.
[47:05.000 --> 47:10.000]  Он на вот этих элементах действительно сделает оптимальный выбор пар.
[47:10.000 --> 47:13.000]  Теперь его запустим на всем алгоритме.
[47:13.000 --> 47:15.000]  Добавим вот эти два элемента.
[47:15.000 --> 47:18.000]  Что у нас может измениться?
[47:18.000 --> 47:23.000]  Что что-то станет вот этими элементами, крайними.
[47:23.000 --> 47:25.000]  И у нас станут пары…
[47:25.000 --> 47:28.000]  Это мы назвали минимум, это максимум для наглядности.
[47:28.000 --> 47:31.000]  И что у нас может быть?
[47:31.000 --> 47:33.000]  Что они стоят не в паре друг с другом.
[47:33.000 --> 47:35.000]  Они стоят не в паре друг с другом.
[47:35.000 --> 47:38.000]  Это значит, что у нас минимум стоит с a, а максимум с b.
[47:38.000 --> 47:40.000]  С каким-то b.
[47:40.000 --> 47:44.000]  Ну, вот этот a — это не максимум, а b — не минимум.
[47:44.000 --> 47:47.000]  И что мы показываем?
[47:47.000 --> 47:54.000]  Что у нас пусть m — это вот то максимальная сумма в паре, то записанное число.
[47:54.000 --> 47:56.000]  И что тогда?
[47:56.000 --> 48:00.000]  Тогда у нас m меньше равен чем минимум плюс a,
[48:00.000 --> 48:06.000]  потому что это по определению у нас любая сумма в нашем разбе меньше равна чем m.
[48:06.000 --> 48:09.000]  И то же самое — максимум плюс b меньше равна чем m.
[48:09.000 --> 48:11.000]  А теперь мы делаем оценку.
[48:11.000 --> 48:14.000]  Мы поменяем вот в этих парах…
[48:14.000 --> 48:19.000]  Поставим минимум с максимум в пару и a с b.
[48:19.000 --> 48:23.000]  Тогда у нас мин плюс максимум меньше чем максимум плюс b,
[48:23.000 --> 48:26.000]  потому что b не больше чем минимум.
[48:26.000 --> 48:28.000]  Не меньше.
[48:28.000 --> 48:32.000]  А a плюс b меньше чем максимум плюс b,
[48:32.000 --> 48:35.000]  потому что b не больше чем максимум.
[48:35.000 --> 48:39.000]  И, значит, у нас транзитивность — вот такие оценки.
[48:39.000 --> 48:43.000]  Значит, у нас вот наше разбиение, которое мы теперь получили,
[48:43.000 --> 48:49.000]  поменяв вот в этих парах элементы местами,
[48:49.000 --> 48:53.000]  оно стало не хуже, потому что вот эта максимальная сумма,
[48:53.000 --> 48:57.000]  она как минимум не изменилась.
[48:57.000 --> 49:01.000]  Может быть, она стала лучше, но мы этого не знаем.
[49:01.000 --> 49:05.000]  И общая идея такая, что если у нас есть решение получше,
[49:05.000 --> 49:12.000]  то мы можем сказать, что и наше решение не уступает вот этому лучшему решению.
[49:12.000 --> 49:16.000]  Значит, у нас оптимальный алгоритм.
[49:16.000 --> 49:18.000]  Вроде разобрались, да?
[49:18.000 --> 49:20.000]  Да, Вить?
[49:20.000 --> 49:22.000]  Да.
[49:23.000 --> 49:30.000]  Мы переходим от n-1n.
[49:30.000 --> 49:34.000]  У нас есть вот этот массив.
[49:34.000 --> 49:40.000]  Мы обрезаем массив, убираем первый и последний элемент.
[49:40.000 --> 49:42.000]  И на нем алгоритм будет...
[49:42.000 --> 49:46.000]  У нас алгоритм сортирует, и у нас сортировка не изменится от этого.
[49:46.000 --> 49:50.000]  И мы знаем, что если мы отсортировали массив,
[49:50.000 --> 49:54.000]  и вот на элементах, кроме крайних,
[49:54.000 --> 50:01.000]  мы предположили, что действительно наш алгоритм выдаёт оптимальное разбиение на пары.
[50:01.000 --> 50:03.000]  А потом добавили крайние элементы.
[50:03.000 --> 50:08.000]  И показываем, что если у нас...
[50:08.000 --> 50:14.000]  Мы не добавляем элементы, мы сортируем, а потом рассматриваем средний под массив.
[50:14.000 --> 50:16.000]  Просто если мы...
[50:16.000 --> 50:20.000]  Ну да, мы сначала сортируем, потом бросим элементы.
[50:24.000 --> 50:30.000]  Мы разбиваем на пары и говорим, что такое разбиение оптимально.
[50:30.000 --> 50:36.000]  А потом смотрим, какое может быть другое разбиение, если мы добавим крайние элементы.
[50:36.000 --> 50:38.000]  Вот.
[50:44.000 --> 50:46.000]  Да.
[50:56.000 --> 50:58.000]  На самом деле...
[51:01.000 --> 51:03.000]  Он, может быть, существует.
[51:06.000 --> 51:08.000]  Может быть.
[51:08.000 --> 51:10.000]  На самом деле, когда мы...
[51:10.000 --> 51:17.000]  То есть нигде в задачах не просят доказать, что ваш алгоритм работает быстрее всех остальных алгоритмов.
[51:17.000 --> 51:19.000]  То есть...
[51:20.000 --> 51:22.000]  Она работает дольше.
[51:22.000 --> 51:26.000]  Понимаешь, просто контрольный рубцов работает так, что там не сказано,
[51:26.000 --> 51:30.000]  чаще всего не сказано, за какое время ты должен решить задачу,
[51:30.000 --> 51:32.000]  ну, за какое время должен работать алгоритм.
[51:32.000 --> 51:37.000]  Но если он работает недостаточно быстро, по мнению автора задачи,
[51:37.000 --> 51:39.000]  то это будет минус балл.
[51:39.000 --> 51:45.000]  То есть, возможно, существует, но ни мы, ни автор задачи об этом не знают.
[51:49.000 --> 51:53.000]  Да. То есть, бывает такое, что ты придумал алгоритм, но есть быстрее,
[51:53.000 --> 51:56.000]  и ты просто не думал, что это будет не полный балл.
[51:56.000 --> 51:58.000]  Да.
[51:58.000 --> 52:01.000]  Короче, тема с алгоритмами и скоростью.
[52:01.000 --> 52:07.000]  Иногда бывает такой прикол, что, например, кто-нибудь очень крутой придумал задачу
[52:07.000 --> 52:10.000]  и говорит, а вот у нее есть там решение за линию.
[52:10.000 --> 52:14.000]  Но это решение за линию настолько замудренное и страшное, что рубцов говорит,
[52:14.000 --> 52:18.000]  нет, я готов оценивать полным баллом решение за n log n.
[52:18.000 --> 52:20.000]  То есть, грубо говоря, как?
[52:20.000 --> 52:24.000]  Какие у вас есть базовые? То есть, у вас есть сортировка, у вас есть сортировки там какие-то с приколами,
[52:24.000 --> 52:28.000]  если речь идет о ни каком-нибудь рандомной сортировке с сравнениями,
[52:28.000 --> 52:32.000]  а просто о сортировке с приколами под счетом, еще чем-нибудь,
[52:32.000 --> 52:36.000]  который работает быстрее, чем n log n, но использует свойство сортируемого.
[52:36.000 --> 52:41.000]  Ну и, собственно, тогда это может обводить шутка быстрее.
[52:41.000 --> 52:48.000]  Ну так, в принципе, если не видно, если практически не видно линейного алгоритма
[52:48.000 --> 52:55.000]  через какие-то порядковые статистики или хитрые сортировки, то, скорее всего, там будет он лукор.
[52:55.000 --> 53:00.000]  Чисто как на эмпирическим путем посмотрено, что едва ли алгоритм
[53:00.000 --> 53:05.000]  затребуется где-то быстрее, чем n log n, но если там не очевидная линия
[53:05.000 --> 53:09.000]  через какие-нибудь те же порядковые статистики.
[53:09.000 --> 53:14.000]  Да, иногда бывает, если слишком уж страшное решение какое-то быстрое,
[53:14.000 --> 53:19.000]  то может быть, что по мнению автора оно решается за линию,
[53:19.000 --> 53:23.000]  по мнению Александра Александровича, оно решается за n log n,
[53:23.000 --> 53:28.000]  типа на уровне студентов, без использования каких-нибудь замудренных структур
[53:28.000 --> 53:31.000]  или еще ничего не будет, и n log n канает.
[53:31.000 --> 53:35.000]  Ну да. Я хотела забыть...
[53:35.000 --> 53:53.000]  Ну, наверное, если ты напишешь о...
[53:53.000 --> 53:57.000]  Короче, изначально вроде предполагается, что мы оптимизируем по времени,
[53:57.000 --> 54:01.000]  но бывает, где в задачах оговорено, что а теперь построите так, чтобы память
[54:01.000 --> 54:05.000]  занимала не больше алгоритма, или что-нибудь такое.
[54:05.000 --> 54:09.000]  То есть если нет ограничений на память, как бы прописанных задач,
[54:09.000 --> 54:12.000]  то можно сказать, что да.
[54:12.000 --> 54:15.000]  В целом, да.
[54:15.000 --> 54:19.000]  Если не прописано отдельное ограничение, что память такая-то, такая-то,
[54:19.000 --> 54:22.000]  не больше чем, то у вас не ограничено это.
[54:22.000 --> 54:26.000]  Ну или если написано не словами, что... Можно написать словами,
[54:26.000 --> 54:29.000]  типа построить онлайн алгоритм.
[54:29.000 --> 54:33.000]  То есть он тоже накладывает ограничения по памяти, что мы ничего не запоминаем.
[54:33.000 --> 54:37.000]  Ну, там, констант запоминаем, в смысле, не запоминаем массиве.
[54:37.000 --> 54:41.000]  Еще одна задача как раз немножко с ловушкой,
[54:41.000 --> 54:46.000]  потому что решение, которое первое приходит на ум, оно неправильное.
[54:46.000 --> 54:51.000]  Ну вот оно мне пришло, к сожалению, на контрольный.
[54:51.000 --> 54:54.000]  Короче, звучит она так.
[54:54.000 --> 54:58.000]  Есть массив A, в котором n элементов, опять массив,
[54:58.000 --> 55:03.000]  и элемент называется пиком, если... Вот я сейчас запишу условия, чтобы это не озвучивать.
[55:03.000 --> 55:06.000]  Вот it элемент – это пик.
[55:06.000 --> 55:17.000]  Если A it больше или равно, чем A i плюс первое,
[55:17.000 --> 55:22.000]  и больше равно, чем A i минус первое.
[55:22.000 --> 55:29.000]  Это для всех i, то есть у нас есть массив A1, An.
[55:29.000 --> 55:33.000]  Это для всех, от 2 до n минус 1.
[55:33.000 --> 55:37.000]  А для крайних элементов такое.
[55:37.000 --> 55:45.000]  Вот этот элемент тоже может быть пиком, если он больше или равен, чем A2.
[55:45.000 --> 55:52.000]  А An является пиком, если он больше или равно, чем An минус 1.
[55:52.000 --> 55:57.000]  Ну такие логичные штуки, если мы нарисуем, типа у нас n,
[55:57.000 --> 56:01.000]  а вот это An, то это какой-то максимум функции.
[56:01.000 --> 56:04.000]  Вот, функция дисклет. Ну ладно.
[56:04.000 --> 56:10.000]  И просятся найти, просят построить алгоритм, который находит пик массива.
[56:10.000 --> 56:15.000]  Первое, что приходит на ум, нужно просто найти максимум функции.
[56:15.000 --> 56:20.000]  Это делается, очевидно, за o от n.
[56:20.000 --> 56:27.000]  Но нас просят пик просто, такое удовлетворяющее неравенство.
[56:27.000 --> 56:30.000]  И такое, спойлер, можно построить за n лог n.
[56:30.000 --> 56:34.000]  Ой, просто лог n.
[56:34.000 --> 56:36.000]  Какой здесь алгоритм?
[56:36.000 --> 56:38.000]  Ну, для начала мы проверяем крайние точки.
[56:38.000 --> 56:45.000]  Если они нас удовлетворяют нашим условиям, то мы нашли пик за o от 1 вообще хорошо.
[56:45.000 --> 56:57.000]  Типа, проверка a от 1 и a от n минус 1.
[56:57.000 --> 57:00.000]  От n.
[57:00.000 --> 57:03.000]  А ведь условия понятны, да?
[57:03.000 --> 57:04.000]  Да, любой.
[57:04.000 --> 57:08.000]  Любой. Их может быть сколько-то.
[57:08.000 --> 57:14.000]  Может быть, n пополам. Нам нужен какой-нибудь.
[57:14.000 --> 57:18.000]  Но понятно, почему он обязательно есть.
[57:18.000 --> 57:22.000]  Хорошо.
[57:22.000 --> 57:25.000]  Проверяем крайние элементы.
[57:25.000 --> 57:31.000]  Если они не пики, то приходим дальше.
[57:31.000 --> 57:33.000]  А дальше мы что делаем?
[57:33.000 --> 57:36.000]  Мы заводим перемены для правой и левой.
[57:36.000 --> 57:38.000]  У нас есть вот массив.
[57:38.000 --> 57:45.000]  У нас есть указатели. Изначально левый указывает сюда, а правый сюда.
[57:45.000 --> 57:47.000]  Изначально вот мы такое пишем.
[57:47.000 --> 57:54.000]  Это a от n, а left это a от 1.
[57:54.000 --> 57:57.000]  И мы потом смотрим в середину.
[57:57.000 --> 58:03.000]  Дальше мы смотрим, как мы заводим m равное l плюс r пополам.
[58:03.000 --> 58:06.000]  Ну, какое-то округление.
[58:06.000 --> 58:17.000]  И что мы смотрим? Мы проверяем, является ли амт пиком.
[58:17.000 --> 58:20.000]  Если да, то вообще хорошо, мы нашли.
[58:20.000 --> 58:23.000]  Если нет, то какие возможны тут случаи?
[58:23.000 --> 58:36.000]  Если у нас амт меньше, значит одно из тех условий не выполняется.
[58:36.000 --> 58:38.000]  Ну, у нас не крайние элементы, мы уже проверили.
[58:38.000 --> 58:41.000]  Значит, мы проверяем вот эти верхние два.
[58:41.000 --> 58:43.000]  Значит, у нас какое-то из условий не выполняется.
[58:43.000 --> 58:51.000]  Значит, амт, первый случай, амт меньше, чем ам плюс 1.
[58:51.000 --> 59:01.000]  Тогда мы что делаем? Мы говорим, что у нас сейчас, если у нас меньше следующего,
[59:01.000 --> 59:10.000]  то мы говорим, что у нас левый теперь равен ам, то есть подвинули указатель.
[59:10.000 --> 59:29.000]  Если у нас амт оказалось меньше, чем ам минус 1, то у нас правая граница двигается в амт.
[59:29.000 --> 59:39.000]  Ну и так сужаем. Пока у нас это мы делаем, пока там допустим, r минус l.
[59:39.000 --> 59:45.000]  В авторском решении больше 5, больше равно 5.
[59:45.000 --> 59:49.000]  Ну, в общем, здесь может быть, мне кажется, любая константа до 3.
[59:49.000 --> 59:56.000]  Ну да, нам достаточно проверить. Мы можем брать, когда 3 центры и проверять то же самое.
[59:56.000 --> 01:00:04.000]  Вот. Это покажется более интуитивным, и это плюс-минус два шага, поэтому не очень важно.
[01:00:04.000 --> 01:00:07.000]  А теперь вопрос, почему это работает.
[01:00:07.000 --> 01:00:15.000]  Ну, здесь важно заметить, то есть ту картинку я не хотела оставить, потому что, мне кажется, очень логично.
[01:00:15.000 --> 01:00:25.000]  То есть когда мы начинаем, вот у нас с нулевой, вот n элемент первый, то у нас вот как-то так следующие элементы идут себя.
[01:00:25.000 --> 01:00:29.000]  То есть у нас здесь возрастает, а здесь убывает.
[01:00:29.000 --> 01:00:35.000]  Теперь, когда мы, допустим, мы подвинули в случае а, левую границу, это что значит?
[01:00:35.000 --> 01:00:41.000]  У нас вот есть m и m плюс 1, и у нас вот это больше.
[01:00:41.000 --> 01:00:47.000]  Значит у нас снова, не здесь, наверное, где-то, а вот снова возрастает, а здесь убывает.
[01:00:48.000 --> 01:00:58.000]  Если вот эту границу подвинули, то у нас вот это больше, чем вот это, значит у нас вот здесь возрастает, а здесь убывает.
[01:00:58.000 --> 01:01:01.000]  То есть у нас сохраняется такое свойство левая и правая граница.
[01:01:01.000 --> 01:01:04.000]  Что это может говорить нам о Василье?
[01:01:04.000 --> 01:01:10.000]  Что у нас, на самом деле, это показывает, что у нас вообще есть пик.
[01:01:10.000 --> 01:01:22.000]  То есть если у нас где-то убывает, ну где-то возрастает, а где-то убывает потом, то у нас, кажется ли это очевидно?
[01:01:22.000 --> 01:01:25.000]  То есть, на самом деле, даже Рубцов в критериях казалось это очевидным.
[01:01:25.000 --> 01:01:33.000]  Но вам понятно, почему у нас, если где-то, ну то есть в начале массива возрастает, потом убывает, то где-то между ними есть пик.
[01:01:33.000 --> 01:01:35.000]  Ну хорошо.
[01:01:36.000 --> 01:01:45.000]  Ну тогда, и он не на концах, потому что у нас концы, очевидно, уже не могут, они не подходят, значит где-то между.
[01:01:49.000 --> 01:02:01.000]  То есть мы можем здесь итеративно идти типа вот этот, если есть что-то побольше, то мы будем также возвращаться, но мы не сможем это делать все время, потому что у нас самое левое вершинное пик.
[01:02:01.000 --> 01:02:10.000]  Ну хорошо, то есть мы на каждом шаге двигаем границы так, что у нас пик где-то между этими границами, не включая эти границы.
[01:02:10.000 --> 01:02:22.000]  И в конечном счете мы, ну и в конечном счете у нас каждый раз ответы поиска уменьшаются, значит пик мы найдем.
[01:02:22.000 --> 01:02:41.000]  То есть когда у нас R-L стало меньше или равно пяти, ну или какой-то констант, меньше или равно какой-то константы, то мы просто можем перебрать константу этих элементов массива и проверить, является ли оно пиком.
[01:02:41.000 --> 01:02:55.000]  И понятно, теперь просим точку. Как я сказала, она работает от log n, но это понятно, мы здесь берем средний элемент, это работает как bin поиск.
[01:02:55.000 --> 01:03:08.000]  То есть грубо говоря, это просто модификация bin поиска. То есть если в первой задаче нам нужно было готовым алгоритму воспользоваться, потом как-то хитро доказать его корректность, то здесь нам нужно было известный нам алгоритм модифицировать.
[01:03:08.000 --> 01:03:18.000]  Ну а корректность, она даже представитель задачи кажется интуитивно понятной, просто важно было описать правильно и придумать этот алгоритм.
[01:03:18.000 --> 01:03:30.000]  Вот. Соня, о чем у нас там по времени? Про статистику что-нибудь расскажите?
[01:03:31.000 --> 01:03:35.000]  У нас уже немало.
[01:03:35.000 --> 01:03:51.000]  Ладно. Что еще? Из таких тем, которые, не знаю, bin поиск и сортировки, они кажется достаточно понятными, чтобы модифицировать.
[01:03:51.000 --> 01:04:01.000]  Я подумала, что не такими очевидными, кажется, к порядковой статистике. Наверное, надо помнить, что это такое, ну в смысле, как оно ищется.
[01:04:01.000 --> 01:04:15.000]  Ну то есть к порядковой статистике, это вот если у нас есть какая-то массива, то если массив отсортировать, то это к порядковой статистике, это значение того элемента, который будет стоять на катом месте.
[01:04:15.000 --> 01:04:22.000]  Да, хорошее уточнение, возрастание отсортировать.
[01:04:22.000 --> 01:04:32.000]  Оно ищется, то есть чтобы строить модификацию этого, наверное, нужно помнить, как оно работает, как ищется к порядковая статистика.
[01:04:32.000 --> 01:04:42.000]  Ну там есть какой-то быстрый вариант, но он основывается на базу, что он делает. У нас есть же, быстрая сортировка. Все помните, как работает быстрый сортировка?
[01:04:42.000 --> 01:04:52.000]  У нас же там есть, вот у нас массив, и мы выбираем какой-то элемент, катый.
[01:04:52.000 --> 01:05:04.000]  И дальше сортируем, вот, не знаю, от одного, короче, мы сортируем все элементы, которые меньше окатыва и которые больше окатыва.
[01:05:04.000 --> 01:05:22.000]  И здесь мы делаем то же самое. Мы берем какой-то элемент, сортируем и получаем, мы, допустим, мы выделили два под массива.
[01:05:22.000 --> 01:05:32.000]  Как бы записать?
[01:05:32.000 --> 01:05:41.000]  Мы выделили два под массива, а дальше мы смотрим, и у нас где-то здесь есть опуск.
[01:05:41.000 --> 01:05:52.000]  И дальше мы смотрим, если у нас вот индекс вот этого элемента равен k, q равно k, то вот мы нашли катый порядковую статистику.
[01:05:52.000 --> 01:06:06.000]  Если у нас q оказалось больше, чем k, то это, ну, мы же помним, что при сортировке у нас вот эти будут сортироваться, но в отсортированном массиве, а q будет стоять здесь.
[01:06:06.000 --> 01:06:16.000]  Ну, значит, если у нас q больше, чем k, то мы ищем вот в левом под массиве.
[01:06:16.000 --> 01:06:37.000]  А если q меньше, чем k, то мы ищем вот здесь. Понятно, что происходит, да?
[01:06:37.000 --> 01:06:51.000]  Это вот как работает статистика. Она работает за, есть ее быстрая модификация, и она работает за odd n.
[01:06:51.000 --> 01:07:04.000]  Это быстрее сортировки, поэтому, когда просят построить эффективный алгоритм чего-нибудь, и там нам не нужны все элементы, там все пара элементов,
[01:07:04.000 --> 01:07:12.000]  а нужно только какой-то один конкретный, то нужно подумать о том, а можно ли построить это быстрее, чем за n log n?
[01:07:12.000 --> 01:07:21.000]  Потому что n log n нам даст положение всех элементов друг относительно друга, а нам здесь нужен один. Возможно, мы сделаем лишнюю работу.
[01:07:21.000 --> 01:07:34.000]  Я не нашла и не придумала задачу, где нужно модифицировать алгоритм кат и порядковой статистики, чтобы это еще было адекватной сложностью,
[01:07:34.000 --> 01:07:42.000]  но на прошлой контрольной была задача, где нужно было его применить. Задача звучала так.
[01:07:42.000 --> 01:07:59.000]  На Олимпиаде по знанию алгоритмов сортировок было n участников. Известно, что некоторые балл t набрало больше, чем n делить на 5 участников.
[01:07:59.000 --> 01:08:09.000]  И нужно предложить эффективный алгоритм, который находит такой балл. Если подходящих t несколько, то можно увести любой.
[01:08:09.000 --> 01:08:21.000]  Ну и t – это целое неотрицательное число. Верхних ограничений нет. То есть верхних ограничений нет для людей, которые хотят использовать сортировок по подсчетам,
[01:08:21.000 --> 01:08:32.000]  потому что здесь у нас сложность o от n. Сортировки по подсчетам тоже o от n. Вроде формальные условия выполнены, но вот уточнили, что им пользоваться нельзя.
[01:08:32.000 --> 01:08:47.000]  У нас было n участников, и у нас понятного условия. У нас n участников, и каждый из них набрал какое-то количество баллов.
[01:08:47.000 --> 01:09:07.000]  То есть у нас t1, t2, tn – это результаты участников. И вот таких t, то есть у нас множество t – это такие t и t, что t и t равно t.
[01:09:07.000 --> 01:09:23.000]  И вот таких t, n пополам. Ой, n на 5. Понятно, что тут большая задача? Первый шаг – это понять условия. Она понятна, да? Хорошо.
[01:09:23.000 --> 01:09:41.000]  Что тут можно сказать про… Ну, нужно как-то воспользоваться катой, порядковой статистикой. Ну, у нас есть логичный вариант пооспользоваться n на 5 порядковой статистикой.
[01:09:41.000 --> 01:09:55.000]  Зачем это может быть нужно? Ну, смотрите, если у нас какое-то конкретное количество баллов t набрало, хотя бы, ну, то есть n на 5 участников, то это значит…
[01:09:55.000 --> 01:10:12.000]  Ну, запишем, отметим, вот у нас на прямой результаты. У нас где-то есть t1, там t3, t4, tn. Вот. И еще что-то там есть.
[01:10:12.000 --> 01:10:26.000]  И вот у нас, очевидно, здесь есть t5, не знаю, t сколько-нибудь. Вот в этом числе. Значит, если мы отсортируем, а если у нас отсортировано, то у нас они будут идти друг за другом.
[01:10:26.000 --> 01:10:44.000]  И у нас какие-то… И мы можем посчитать… И у нас, смотрите, если мы разобьем множество всех результатов на пять одинаковых частей, то у нас вот какую-то часть…
[01:10:44.000 --> 01:10:54.000]  У нас есть отрезок длиной n на 5, потому что, ну, у нас есть ответные. Каждое, не знаю, каждое черточка – это какой-то участник.
[01:10:54.000 --> 01:11:08.000]  И у нас, если мы разобьем вот так этот отрезок результатов от минимального до максимального, там от нуля до максимального балла, то у нас будет отрезок длиной n на 5.
[01:11:08.000 --> 01:11:24.000]  Это значит, что он какую-то порядковую статистику покроет. То есть, если мы разобьем на пять одинаковых отрезков, если мы разобьем на пять отрезков результаты участников,
[01:11:24.000 --> 01:11:41.000]  а у нас вот какой-то конкретный бал набрали n на 5 участников, то это, в принципе, рехле. У нас вот этот отрезок, человек, который получил t баллов, он покроет один из таких штрихов.
[01:11:41.000 --> 01:11:49.000]  Это n на 5, это 2n на 5 и так далее, и n. Понятно, что происходит?
[01:11:49.000 --> 01:12:06.000]  Вот, супер. Значит, мы посчитаем n на 5 порядковую статистику, 2n на 5 порядковую статистику и так далее, n. Мы посчитаем такие всего пять – это константы. У нас совсем точка не изменится.
[01:12:06.000 --> 01:12:22.000]  А дальше мы должны их сравнить. Мы дальше должны просто пройтись по массиву и посчитать, сколько у нас элементов равны каждой из порядковой статистик.
[01:12:22.000 --> 01:12:39.000]  Мы заведем такой массив. И в каждой из них будем записывать, сколько элементов равно n на 5 порядковой статистики, сколько 2n на 5 порядковой статистики и так далее.
[01:12:39.000 --> 01:12:51.000]  И в конце мы найдем какое-то, то есть мы показали, что у нас какой-то порядковой статистики будет равно n на 5.
[01:12:51.000 --> 01:13:07.000]  n на 5 – это количество человек, которые получили такое количество баллов. А теперь мы просто пытаемся найти, какую именно порядковую статистику, вот, какая именно порядковая статистика – это t. Понятно?
[01:13:07.000 --> 01:13:15.000]  Есть еще альтернативный вариант. Мы ищем не n на 5, а n на 10. Зачем?
[01:13:15.000 --> 01:13:29.000]  То есть мы разобьем на 10, а дальше просто говорим, что если у нас есть отрезок длины n на 5, то он покроет две порядковые статистики. Правда?
[01:13:29.000 --> 01:13:33.000]  В общем, бред, да?
[01:13:33.000 --> 01:13:42.000]  Покроет две порядковые статистики, и мы посчитаем таких 10 штук, и какие-то две будут равные.
[01:13:42.000 --> 01:13:52.000]  Ну, собственно, мы просто их попарно сравним. Это тоже константы в вычислении. И найдем. И те, которые равны – это и есть, собственно, наш балл t.
[01:13:52.000 --> 01:13:57.000]  То есть понятно, что произошло, да? Ну, просто киваете.
[01:14:04.000 --> 01:14:15.000]  То есть здесь нужно было понять, какую просто порядковую статистику считать, но никакой оригинальный алгоритм не нужно было изменять.
[01:14:15.000 --> 01:14:27.000]  Вот. Ну, да, асимптотика здесь оценивается очевидно, что мы пять раз посчитали какую порядковую статистику, и потом константа…
[01:14:27.000 --> 01:14:39.000]  То есть либо мы прошлись по массиву, это от n, либо мы сделали константное количество сравнений. Это тоже не изменило асимптотику.
[01:14:39.000 --> 01:14:53.000]  Собственно, будем смотреть на протоколы РСА, а перед этим на штуки про такие алгоритмы, которые используются для расчетов.
[01:14:53.000 --> 01:15:01.000]  Ну, помним про алгоритм Евклида расширенный и про быстрое возведение в степень. Как работает быстрое возведение в степень?
[01:15:01.000 --> 01:15:07.000]  То есть мы хотим… Ну, понятно, возведение в степень – трудоемкая тема, умножение само по себе не особо вкусно.
[01:15:07.000 --> 01:15:12.000]  Возведение в степень – это еще и многоумножение, это еще более мерзкая тема.
[01:15:12.000 --> 01:15:20.000]  Ну, хотим возвести в степень как можно быстрее, и помним, что хотим возвести в нечетную степень число.
[01:15:20.000 --> 01:15:27.000]  Вот я хочу возвести число b в степень n. Если n нечетная, тогда это будет что?
[01:15:27.000 --> 01:15:35.000]  b в степени n-1 пополам в квадрате умножить на b. Логично, логично.
[01:15:35.000 --> 01:15:46.000]  Если это нечетная, то тогда это будет b в степени n пополам в квадрате. Логично, логично.
[01:15:46.000 --> 01:15:56.000]  Уже уменьшаем. Тут n пополам умножение убрали, там еще n на 4 уберем, и так далее, и так далее.
[01:15:56.000 --> 01:16:03.000]  Собственно говоря, мы не хотим морочить себе голову с умножениями в количестве n штук,
[01:16:03.000 --> 01:16:07.000]  но вот так достаточно логарифм n умножений будет и произвести.
[01:16:07.000 --> 01:16:12.000]  Еще лучше, если это делается по какому-то модулю.
[01:16:12.000 --> 01:16:16.000]  Например, вообще в компьютере всегда это делается по какому-то модулю,
[01:16:16.000 --> 01:16:21.000]  но тот же 32-битный INT это по модулю 2,32 будет считаться.
[01:16:21.000 --> 01:16:24.000]  Ну а если мы хотим работать по какому-то модулю поменьше,
[01:16:24.000 --> 01:16:29.000]  как, например, в том же протоколе RSA, который будем сейчас смотреть.
[01:16:29.000 --> 01:16:34.000]  То есть там по модулю 13, по модулю 20, по модуле там еще кому-нибудь.
[01:16:34.000 --> 01:16:43.000]  Окей, я хочу возвести 3 в 21, по модулю 13.
[01:16:43.000 --> 01:16:45.000]  Тут совсем просто будет.
[01:16:45.000 --> 01:16:47.000]  Ну что я хочу сделать?
[01:16:47.000 --> 01:16:54.000]  Ну как? Все просто. 3 в 21, то же самое, что 3 на 3 в 10 в квадрате.
[01:16:54.000 --> 01:17:01.000]  Это то же самое, что 3 на 3 в 5 в квадрате в квадрате.
[01:17:01.000 --> 01:17:11.000]  3 на, скобка, скобка, 3 в квадрате, в квадрате на 3, в квадрате, в квадрате.
[01:17:11.000 --> 01:17:20.000]  По модулю 13, если смотреть, это, соответственно, 3 на, скобка, скобка.
[01:17:20.000 --> 01:17:23.000]  Получится 9, 9 это что по модулю 13?
[01:17:23.000 --> 01:17:26.000]  Вот это 9, 9 это что по модуле 13, ты минус 4.
[01:17:26.000 --> 01:17:31.000]  Минус 4 в квадрате на 3, квадрат, квадрат.
[01:17:31.000 --> 01:17:37.000]  Это то же самое, что 3 на, минус 4.
[01:17:37.000 --> 01:17:40.000]  Это тоже что, минус 4 в квадрате, тоже что 4 в квадрате.
[01:17:40.000 --> 01:17:42.000]  16, 16 по модулю 13, это 3.
[01:17:42.000 --> 01:17:47.000]  Собственно, 3 на 3 в квадрате, в квадрате.
[01:17:47.000 --> 01:17:50.000]  Это что? Тройка остается, как была.
[01:17:50.000 --> 01:17:56.000]  3 на 3, 9, 9 это минус 4, минус 4, квадрат, квадрат.
[01:17:56.000 --> 01:18:04.000]  Это то же самое, что 3 на, что?
[01:18:04.000 --> 01:18:19.000]  3, короче, в квадрат, 3 квадрат, 3 на минус 4, минус 12, вот.
[01:18:19.000 --> 01:18:22.000]  Логично, логично. Быстро, быстро.
[01:18:22.000 --> 01:18:26.000]  Вот. Собственно, быстрее, чем могло бы быть.
[01:18:26.000 --> 01:18:32.000]  Да и плюс мы не делаем каждый раз, не зяним за собой большое, большое число.
[01:18:32.000 --> 01:18:34.000]  Вот. Долго.
[01:18:34.000 --> 01:18:37.000]  Собственно, быстро разденемся опять дальше.
[01:18:37.000 --> 01:18:38.000]  Алгоритм Евклида.
[01:18:38.000 --> 01:18:43.000]  Как известно, алгоритм Евклида из школы, это поиск наибольшего общего делителя.
[01:18:43.000 --> 01:18:49.000]  Если у нас наибольший общий делитель двух чисел, то мы из большего вычтем меньшее.
[01:18:49.000 --> 01:18:53.000]  Потом из того, что получилось, насчет это меньшее число и разность.
[01:18:53.000 --> 01:18:57.000]  Из того, что из них больше, вычтем то из них, что меньше, и так далее,
[01:18:57.000 --> 01:19:02.000]  до тех пор, пока либо не наступит наибольший общий делитель, вот.
[01:19:02.000 --> 01:19:06.000]  То есть либо до тех пор, пока эти два числа не станут равны,
[01:19:06.000 --> 01:19:09.000]  либо до тех пор, пока там единицы не вылезет где-то.
[01:19:09.000 --> 01:19:13.000]  Вот. Алгоритм Евклида расширенный.
[01:19:13.000 --> 01:19:16.000]  Ну, в чем его расширенность?
[01:19:16.000 --> 01:19:19.000]  В том, что Диафантово – уравнение.
[01:19:19.000 --> 01:19:21.000]  Это уравнение в целых числах Лида.
[01:19:21.000 --> 01:19:25.000]  Ах плюс Би век равно С.
[01:19:25.000 --> 01:19:30.000]  Оно имеет решение или не одного, или бесконечно много.
[01:19:30.000 --> 01:19:32.000]  Вот.
[01:19:32.000 --> 01:19:36.000]  Ну, собственно, когда не одного, когда бесконечно много,
[01:19:36.000 --> 01:19:40.000]  когда К работает расширенный алгоритм Евклида, расширенный алгоритм Евклида,
[01:19:40.000 --> 01:19:45.000]  я хочу найти наибольший общий делитель этих вот А, Б и С.
[01:19:45.000 --> 01:19:53.000]  Почему? Если вдруг А и Б делятся на то, на что С не делится,
[01:19:53.000 --> 01:19:57.000]  то мы никак не получим никакого решения.
[01:19:57.000 --> 01:20:02.000]  Потому что правая часть будет кратно, скажем, К, а левая часть не будет кратно К.
[01:20:02.000 --> 01:20:06.000]  И мы уже никак не сможем, домножая ни на что, ничего изменить.
[01:20:06.000 --> 01:20:10.000]  Просто тут вылезли козыскотка, а тут нам выносить нечего.
[01:20:10.000 --> 01:20:13.000]  Вот. Находим наибольший общий делитель.
[01:20:16.000 --> 01:20:19.000]  Второе. Делим наибольший общий делитель.
[01:20:33.000 --> 01:20:36.000]  Или нет корней сразу.
[01:20:36.000 --> 01:20:42.000]  Дальше расширенный алгоритм. То есть мы записываем х, у,
[01:20:42.000 --> 01:20:47.000]  но пусть будет а штрих, пусть будет b штрих, пусть будет c штрих.
[01:20:47.000 --> 01:20:57.000]  Х, у, а штрих, х, плюс b штрих, у, а штрих и b штрих.
[01:20:57.000 --> 01:20:59.000]  Наибольший общий делитель – это единица.
[01:20:59.000 --> 01:21:03.000]  Логично, логично. Поделили, все посокращали, все поубивалось.
[01:21:03.000 --> 01:21:06.000]  Вот так, вот так, вот так и вот так.
[01:21:06.000 --> 01:21:09.000]  Соответственно, здесь будет а штрих, здесь будет b штрих.
[01:21:09.000 --> 01:21:13.000]  Дальше. Проводим итерации, как у обычного алгоритма Евклида.
[01:21:13.000 --> 01:21:16.000]  Поиска собственного наибольшего общего делителя.
[01:21:16.000 --> 01:21:21.000]  Как? Из большего вычитаем меньше, мы вычитаем не об и как, а построчно.
[01:21:21.000 --> 01:21:25.000]  То есть вот я вычела из а штриха b штрих.
[01:21:25.000 --> 01:21:34.000]  Это значит, что я здесь, например, запишу 1 минус 1, а штрих минус b штрих и так далее.
[01:21:34.000 --> 01:21:39.000]  То есть я провожу обычный алгоритм Евклида с правой частью,
[01:21:39.000 --> 01:21:43.000]  а левую часть при этом построчно за ней тяну.
[01:21:43.000 --> 01:21:54.000]  В конечном итоге будет х ноль штрих, у ноль штрих, единица.
[01:21:54.000 --> 01:21:58.000]  Если корни есть, хоть какие-то. Вот.
[01:21:58.000 --> 01:22:00.000]  Х ноль штрих, у ноль штрих, единица.
[01:22:00.000 --> 01:22:06.000]  Дальше. Х ноль это c штрих, х ноль штрих.
[01:22:06.000 --> 01:22:12.000]  У ноль это c штрих, у ноль штрих.
[01:22:12.000 --> 01:22:17.000]  Это частное решение.
[01:22:17.000 --> 01:22:23.000]  Почему частное решение? Ну, все просто, типа, да можешь ли обещаешься на c?
[01:22:23.000 --> 01:22:25.000]  Вот и все. На 1 c штрих. Окей.
[01:22:25.000 --> 01:22:28.000]  А дальше осталось найти общее решение.
[01:22:28.000 --> 01:22:30.000]  А что такое общее решение?
[01:22:30.000 --> 01:22:38.000]  Мы говорим, что a штрих х плюс b штрих у равен c штрих.
[01:22:38.000 --> 01:22:50.000]  Тогда х это х ноль плюс b штрих на целое число,
[01:22:50.000 --> 01:22:56.000]  у это у ноль минус a штрих на целое число.
[01:22:56.000 --> 01:22:58.000]  Почему? А очень просто.
[01:22:58.000 --> 01:23:02.000]  А потому что, если мы поставим сюда, то здесь будет h штрих b штрих k,
[01:23:02.000 --> 01:23:04.000]  здесь будет минус h штрих b штрих k,
[01:23:04.000 --> 01:23:07.000]  и остается то, что было часто в решении у нас.
[01:23:07.000 --> 01:23:09.000]  Логично.
[01:23:09.000 --> 01:23:13.000]  Доказательство того, почему это все решение дает, там побольше будет.
[01:23:13.000 --> 01:23:17.000]  Я вам голову морочить, и он на быстром таком расшарчике не буду.
[01:23:17.000 --> 01:23:22.000]  Ну, собственно, причем здесь важно.
[01:23:22.000 --> 01:23:26.000]  Прямо вот ультраважно. Прямо вот 3 отрицательных знака.
[01:23:26.000 --> 01:23:34.000]  Вот а штрих b штрих равен единице.
[01:23:34.000 --> 01:23:39.000]  Иначе мы потеряем решение. Целую пачку решений потеряем.
[01:23:39.000 --> 01:23:42.000]  Именно вот этих вот общих.
[01:23:42.000 --> 01:23:45.000]  Дальше.
[01:23:45.000 --> 01:23:47.000]  Что происходит дальше?
[01:23:47.000 --> 01:23:51.000]  Это зачем? Решим давать какое-нибудь диафантовое уравнение.
[01:23:51.000 --> 01:23:53.000]  Какое-нибудь...
[01:23:53.000 --> 01:23:55.000]  Многие крутили какое-нибудь.
[01:23:55.000 --> 01:23:59.000]  Давайте 31.
[01:23:59.000 --> 01:24:01.000]  Нет, 31 плохо. 32.
[01:24:01.000 --> 01:24:11.000]  32х плюс 18у равно 2.
[01:24:11.000 --> 01:24:13.000]  Окей.
[01:24:13.000 --> 01:24:15.000]  Собственно, первое алгоритм не вклеено.
[01:24:15.000 --> 01:24:21.000]  32, 18.
[01:24:21.000 --> 01:24:25.000]  Бьет во что? Ну, 32-18 будет...
[01:24:25.000 --> 01:24:29.000]  Это будет 18, 16.
[01:24:29.000 --> 01:24:34.000]  18, 2.
[01:24:34.000 --> 01:24:39.000]  И так далее. 4, 2, 2, 2.
[01:24:39.000 --> 01:24:42.000]  Вот выиграли. Вот он наибольший общий делитель.
[01:24:42.000 --> 01:24:49.000]  12, 2, 16, 2, 14, 2, там 12, 2, 10, 2, 8, 2, 6, 2, 4, 2, 2, 2.
[01:24:49.000 --> 01:24:51.000]  Совпали? Прекрасно.
[01:24:51.000 --> 01:24:53.000]  Наибольший общий делитель.
[01:24:53.000 --> 01:24:56.000]  Нод равен 2.
[01:24:56.000 --> 01:24:59.000]  Двократно.
[01:24:59.000 --> 01:25:01.000]  И решение 10.
[01:25:01.000 --> 01:25:05.000]  Если бы здесь было, например, 3, то решений бы не было.
[01:25:05.000 --> 01:25:08.000]  То есть вот здесь нод равен был бы 2,
[01:25:08.000 --> 01:25:10.000]  а правая часть на 2 бы не делилась.
[01:25:10.000 --> 01:25:12.000]  Все, до свидания. Решений нет.
[01:25:12.000 --> 01:25:14.000]  Итак, двократно.
[01:25:14.000 --> 01:25:15.000]  Следственно, второй этап.
[01:25:15.000 --> 01:25:17.000]  Мы сократим на нод все.
[01:25:17.000 --> 01:25:21.000]  16х плюс 9у равен 1.
[01:25:21.000 --> 01:25:23.000]  А дальше что?
[01:25:23.000 --> 01:25:26.000]  А дальше все просто.
[01:25:26.000 --> 01:25:36.000]  Значит, х, у, 16х плюс 9у.
[01:25:36.000 --> 01:25:40.000]  1, 0, еще 16.
[01:25:40.000 --> 01:25:46.000]  0, 1, еще 9.
[01:25:46.000 --> 01:25:48.000]  16-9, 7.
[01:25:48.000 --> 01:25:54.000]  Значит, 1, минус 1, 7.
[01:25:54.000 --> 01:25:59.000]  Вычитаем опять из этой строки эту строку.
[01:25:59.000 --> 01:26:00.000]  То есть что будет?
[01:26:00.000 --> 01:26:05.000]  Минус 1, 2, 2.
[01:26:05.000 --> 01:26:07.000]  Дальше что? Вычитаем.
[01:26:07.000 --> 01:26:10.000]  Из этой строки эту три раза.
[01:26:10.000 --> 01:26:12.000]  Можно сразу, можно не тащить за собой.
[01:26:12.000 --> 01:26:14.000]  А там 7, минус 3, 2.
[01:26:14.000 --> 01:26:16.000]  Окей, ладно.
[01:26:16.000 --> 01:26:19.000]  1, минус 3, минус 1.
[01:26:19.000 --> 01:26:21.000]  То есть плюс 3, это будет тут 4.
[01:26:21.000 --> 01:26:25.000]  Значит, минус 1, минус 3, 2.
[01:26:25.000 --> 01:26:29.000]  Это будет минус 7.
[01:26:29.000 --> 01:26:30.000]  Вот 1.
[01:26:30.000 --> 01:26:31.000]  Ну вот и все.
[01:26:31.000 --> 01:26:32.000]  Частное решение.
[01:26:32.000 --> 01:26:35.000]  Х0 равно.
[01:26:35.000 --> 01:26:38.000]  Значит, здесь домножать не на что не надо.
[01:26:38.000 --> 01:26:40.000]  Если бы, например, 4 написано,
[01:26:40.000 --> 01:26:42.000]  здесь была бы 2.
[01:26:42.000 --> 01:26:43.000]  И мы бы домножали на 2.
[01:26:43.000 --> 01:26:44.000]  Но тут 4 не написано.
[01:26:44.000 --> 01:26:45.000]  Написано 2.
[01:26:45.000 --> 01:26:47.000]  Вот.
[01:26:47.000 --> 01:26:51.000]  Тогда х0 равен, получается, 4.
[01:26:51.000 --> 01:26:55.000]  y0 равен, получается, минус 7.
[01:26:55.000 --> 01:26:58.000]  Окей, осталось найти общее.
[01:26:58.000 --> 01:27:00.000]  Общее, вспоминаем формулу.
[01:27:00.000 --> 01:27:08.000]  х равен х0 плюс 9k.
[01:27:08.000 --> 01:27:16.000]  y равен y0 минус 16k.
[01:27:16.000 --> 01:27:18.000]  Вот так.
[01:27:18.000 --> 01:27:19.000]  Все, все.
[01:27:19.000 --> 01:27:21.000]  На том и порешили.
[01:27:21.000 --> 01:27:23.000]  Дальше.
[01:27:23.000 --> 01:27:27.000]  Как эти две вещи сконетчены
[01:27:27.000 --> 01:27:28.000]  с достаточно важной темой
[01:27:28.000 --> 01:27:31.000]  криптографический протокол RSA.
[01:27:31.000 --> 01:27:32.000]  Вот.
[01:27:32.000 --> 01:27:34.000]  Как эта тема работает.
[01:27:34.000 --> 01:27:37.000]  RSA.
[01:27:37.000 --> 01:27:42.000]  Вот тут сидит Алиса.
[01:27:42.000 --> 01:27:45.000]  Вот тут сидит Боб.
[01:27:45.000 --> 01:27:46.000]  Вот.
[01:27:46.000 --> 01:27:48.000]  Алиса хочет написать сообщение Бобу.
[01:27:48.000 --> 01:27:54.000]  Вот тут сидит Ева.
[01:27:54.000 --> 01:27:57.000]  И пытается это все подслушать.
[01:27:57.000 --> 01:28:00.000]  Вот.
[01:28:00.000 --> 01:28:03.000]  И мы хотим, собственно, чтобы Ева не поняла
[01:28:03.000 --> 01:28:09.000]  о том, что Алиса говорит Бобу.
[01:28:09.000 --> 01:28:11.000]  Вот.
[01:28:11.000 --> 01:28:14.000]  Пусть Боб улыбается.
[01:28:14.000 --> 01:28:16.000]  Да, пусть Боб улыбается.
[01:28:16.000 --> 01:28:18.000]  Ладно, вот Алиса что-то пишет Бобу.
[01:28:18.000 --> 01:28:20.000]  Какое-то сообщение.
[01:28:20.000 --> 01:28:22.000]  Понятно, что если Ева тут сидит и смотрит,
[01:28:22.000 --> 01:28:24.000]  слушает, то если сообщение не зашифровано,
[01:28:24.000 --> 01:28:26.000]  то она его прочитает десять раз,
[01:28:26.000 --> 01:28:28.000]  пойдет растрепит все, что Алиса рассказывает Бобу.
[01:28:28.000 --> 01:28:30.000]  Ну ладно.
[01:28:30.000 --> 01:28:32.000]  Алиса хочет, чтобы Ева это не прочитала.
[01:28:32.000 --> 01:28:34.000]  Окей.
[01:28:34.000 --> 01:28:37.000]  Она берет число N,
[01:28:37.000 --> 01:28:45.000]  которое равно произведению двух простых чисел.
[01:28:45.000 --> 01:28:48.000]  Простые.
[01:28:48.000 --> 01:28:50.000]  Некоторые так обозначают,
[01:28:50.000 --> 01:28:52.000]  потому что это, на самом деле,
[01:28:52.000 --> 01:28:54.000]  достаточно конфликтная буква.
[01:28:54.000 --> 01:28:56.000]  Blackboard как R, как C.
[01:28:56.000 --> 01:28:58.000]  Некоторые так обозначают простые числа,
[01:28:58.000 --> 01:29:00.000]  так что не пугайтесь.
[01:29:00.000 --> 01:29:02.000]  Вот.
[01:29:02.000 --> 01:29:04.000]  Почему?
[01:29:04.000 --> 01:29:06.000]  Если N большое,
[01:29:06.000 --> 01:29:08.000]  прям какое-то десятизначное,
[01:29:08.000 --> 01:29:10.000]  то разложите его на два простых множителя,
[01:29:10.000 --> 01:29:12.000]  которые сами тоже там немаленькие.
[01:29:12.000 --> 01:29:16.000]  То есть не дважды там 1, 2, 3, 4, 5,
[01:29:16.000 --> 01:29:20.000]  а там какой-нибудь 330 там что-нибудь,
[01:29:20.000 --> 01:29:24.000]  умноженное на 1500 там еще что-нибудь.
[01:29:24.000 --> 01:29:26.000]  Как бы, имея только произведение их,
[01:29:26.000 --> 01:29:28.000]  Ева не умеет, значит,
[01:29:28.000 --> 01:29:30.000]  эффективно раскладывать это все на множители
[01:29:30.000 --> 01:29:34.000]  и эффективно находить по ику.
[01:29:34.000 --> 01:29:36.000]  Зачем ей эффективно находить по ику?
[01:29:36.000 --> 01:29:38.000]  Есть такая тема,
[01:29:38.000 --> 01:29:40.000]  как Фиатен, функция Эйлера.
[01:29:40.000 --> 01:29:42.000]  Это у вас на воидке?
[01:29:42.000 --> 01:29:44.000]  Это у вас на воидке.
[01:29:44.000 --> 01:29:46.000]  В общем, Фиатен, функция Эйлера,
[01:29:46.000 --> 01:29:48.000]  это количество чисел,
[01:29:48.000 --> 01:29:50.000]  меньших N и взаимно простых с ним.
[01:29:50.000 --> 01:29:52.000]  От простого числа
[01:29:52.000 --> 01:29:54.000]  Фиатен равна N-1,
[01:29:54.000 --> 01:29:56.000]  от произведения нескольких простых чисел
[01:29:56.000 --> 01:29:58.000]  она будет равна
[01:29:58.000 --> 01:30:02.000]  T-1Q-1.
[01:30:04.000 --> 01:30:06.000]  Вот.
[01:30:06.000 --> 01:30:08.000]  Если мы будем знать Фиатен,
[01:30:08.000 --> 01:30:10.000]  вот.
[01:30:10.000 --> 01:30:12.000]  Если мы будем знать Фиатен,
[01:30:12.000 --> 01:30:14.000]  то посчитаем все эти зашифровки
[01:30:14.000 --> 01:30:16.000]  и расшифровки RSA.
[01:30:16.000 --> 01:30:18.000]  Если мы не знаем Фиатен,
[01:30:18.000 --> 01:30:20.000]  тогда мы это не посчитаем.
[01:30:20.000 --> 01:30:22.000]  А чтобы знать Фиатен, нам надо знать
[01:30:22.000 --> 01:30:24.000]  разложение на простые множители.
[01:30:24.000 --> 01:30:26.000]  Разлагать на простые множители,
[01:30:26.000 --> 01:30:28.000]  N по полную задачу решать,
[01:30:28.000 --> 01:30:30.000]  если там числа достаточно большие,
[01:30:30.000 --> 01:30:32.000]  вот это вот не умеет Ева.
[01:30:32.000 --> 01:30:34.000]  Окей, ладно.
[01:30:34.000 --> 01:30:36.000]  Как, в принципе, эта тема работает?
[01:30:36.000 --> 01:30:38.000]  Мы берем,
[01:30:38.000 --> 01:30:40.000]  значит, мы берем число,
[01:30:40.000 --> 01:30:42.000]  у меня M.
[01:30:42.000 --> 01:30:44.000]  Есть публичный ключ,
[01:30:44.000 --> 01:30:46.000]  есть приватный ключ, вот.
[01:30:46.000 --> 01:30:48.000]  Соответственно,
[01:30:48.000 --> 01:30:50.000]  у нас есть ключ,
[01:30:50.000 --> 01:30:52.000]  вот у меня цифры.
[01:30:52.000 --> 01:30:54.000]  Вот.
[01:30:54.000 --> 01:30:56.000]  Есть вот это число Е.
[01:30:56.000 --> 01:30:58.000]  Вот. Е и N.
[01:30:58.000 --> 01:31:00.000]  Это открытый ключ Алисы.
[01:31:00.000 --> 01:31:02.000]  Алиса хочет зашифровать им.
[01:31:02.000 --> 01:31:04.000]  Естественно, вот у нее текст M,
[01:31:04.000 --> 01:31:06.000]  который она хочет передать Бобу.
[01:31:06.000 --> 01:31:08.000]  Она хочет.
[01:31:08.000 --> 01:31:10.000]  Значит,
[01:31:10.000 --> 01:31:12.000]  этот текст
[01:31:12.000 --> 01:31:14.000]  зашифровать
[01:31:14.000 --> 01:31:16.000]  с использованием
[01:31:16.000 --> 01:31:18.000]  M ключа.
[01:31:18.000 --> 01:31:20.000]  Соответственно, она берет сообщение M,
[01:31:20.000 --> 01:31:22.000]  возводит в степень D,
[01:31:22.000 --> 01:31:24.000]  считает ее по модулю
[01:31:24.000 --> 01:31:26.000]  N и передает.
[01:31:26.000 --> 01:31:28.000]  В это вот будет
[01:31:28.000 --> 01:31:30.000]  зашифрованное сообщение.
[01:31:30.000 --> 01:31:32.000]  Вот. Она передает
[01:31:32.000 --> 01:31:34.000]  это Бобу. Дальше.
[01:31:34.000 --> 01:31:36.000]  Что умеет Боб?
[01:31:36.000 --> 01:31:38.000]  Он принимает эту штуку.
[01:31:38.000 --> 01:31:40.000]  Значит,
[01:31:40.000 --> 01:31:42.000]  вот это вот сообщение зашифровано.
[01:31:42.000 --> 01:31:44.000]  Принимает Боб.
[01:31:44.000 --> 01:31:46.000]  Значит, закрытый ключ.
[01:31:48.000 --> 01:31:50.000]  Вот такой.
[01:31:50.000 --> 01:31:52.000]  Берет.
[01:31:52.000 --> 01:31:54.000]  Как считается D?
[01:31:54.000 --> 01:31:56.000]  Сейчас разберемся.
[01:31:56.000 --> 01:31:58.000]  Теперь он возводит C
[01:31:58.000 --> 01:32:00.000]  в степени D.
[01:32:00.000 --> 01:32:02.000]  Это будет мод
[01:32:02.000 --> 01:32:04.000]  N.
[01:32:04.000 --> 01:32:06.000]  И получает, собственно,
[01:32:06.000 --> 01:32:08.000]  эту самую,
[01:32:08.000 --> 01:32:10.000]  собственно, сообщение.
[01:32:10.000 --> 01:32:12.000]  Почему? Потому что мы
[01:32:12.000 --> 01:32:14.000]  число D и E подбираем так.
[01:32:14.000 --> 01:32:16.000]  Вот. Мы хотим, чтобы
[01:32:16.000 --> 01:32:18.000]  C D,
[01:32:18.000 --> 01:32:20.000]  то же самое, что M в степени E
[01:32:20.000 --> 01:32:22.000]  в степени D
[01:32:22.000 --> 01:32:24.000]  было сравнимо с M
[01:32:24.000 --> 01:32:26.000]  по модулю, собственно, N.
[01:32:26.000 --> 01:32:28.000]  Ну, вот.
[01:32:28.000 --> 01:32:30.000]  Сейчас на E мы должны найти D.
[01:32:30.000 --> 01:32:32.000]  Мы должны уметь шифровать
[01:32:32.000 --> 01:32:34.000]  и уметь расшифровывать.
[01:32:34.000 --> 01:32:36.000]  Вот.
[01:32:36.000 --> 01:32:38.000]  Будет еще цифровая подпись.
[01:32:38.000 --> 01:32:40.000]  Для цифровой подписи нам понадобится уже,
[01:32:40.000 --> 01:32:42.000]  значит, phi.
[01:32:42.000 --> 01:32:44.000]  Ладно.
[01:32:44.000 --> 01:32:46.000]  Допустим, мы знаем
[01:32:46.000 --> 01:32:48.000]  число N.
[01:32:48.000 --> 01:32:50.000]  Вот. Мы знаем число N.
[01:32:50.000 --> 01:32:52.000]  Оно, ну, пускай, будет...
[01:32:52.000 --> 01:32:54.000]  Как у него пример? Сейчас разберем.
[01:32:56.000 --> 01:32:58.000]  Пожалуй, я пример с Евфридом сотру.
[01:32:58.000 --> 01:33:00.000]  И будем разбирать.
[01:33:00.000 --> 01:33:02.000]  Да?
[01:33:06.000 --> 01:33:08.000]  Ну,
[01:33:08.000 --> 01:33:10.000]  вы смотрите, D от...
[01:33:10.000 --> 01:33:12.000]  E это ключ...
[01:33:12.000 --> 01:33:14.000]  E это ключ
[01:33:14.000 --> 01:33:16.000]  Алисы.
[01:33:16.000 --> 01:33:18.000]  Вот. D это ключ Боба. Он генерируется
[01:33:18.000 --> 01:33:20.000]  так, чтобы
[01:33:20.000 --> 01:33:22.000]  они могли обмениваться,
[01:33:22.000 --> 01:33:24.000]  чтобы вот Боб возводил
[01:33:24.000 --> 01:33:26.000]  в свою степень D полученные
[01:33:26.000 --> 01:33:28.000]  сообщения
[01:33:28.000 --> 01:33:30.000]  и получал
[01:33:30.000 --> 01:33:32.000]  да.
[01:33:32.000 --> 01:33:34.000]  Открытый ключ Алисы.
[01:33:34.000 --> 01:33:36.000]  Вообще-то...
[01:33:36.000 --> 01:33:38.000]  Ну, как?
[01:33:38.000 --> 01:33:40.000]  Смотрите.
[01:33:40.000 --> 01:33:42.000]  Алисы возводит в понятную...
[01:33:42.000 --> 01:33:44.000]  В открытую...
[01:33:46.000 --> 01:33:48.000]  Ну, N общий.
[01:33:48.000 --> 01:33:50.000]  На них, на двоих.
[01:33:50.000 --> 01:33:52.000]  Вот.
[01:33:56.000 --> 01:33:58.000]  Да.
[01:34:00.000 --> 01:34:02.000]  Да.
[01:34:02.000 --> 01:34:04.000]  И N, оно общее, как бы, на двоих.
[01:34:04.000 --> 01:34:06.000]  Да.
[01:34:06.000 --> 01:34:08.000]  Значит...
[01:34:12.000 --> 01:34:14.000]  N оно у обоих.
[01:34:14.000 --> 01:34:16.000]  Вот. N это число.
[01:34:16.000 --> 01:34:18.000]  Оно равно P умножить на Q,
[01:34:18.000 --> 01:34:20.000]  где P и Q простые.
[01:34:20.000 --> 01:34:22.000]  Вот. А E и D они
[01:34:22.000 --> 01:34:24.000]  это, собственно, ключи.
[01:34:24.000 --> 01:34:26.000]  Вот.
[01:34:26.000 --> 01:34:28.000]  Значит,
[01:34:28.000 --> 01:34:30.000]  как это все работает?
[01:34:30.000 --> 01:34:32.000]  Собственно,
[01:34:32.000 --> 01:34:34.000]  у нас есть ключи.
[01:34:34.000 --> 01:34:36.000]  У нас есть, значит,
[01:34:36.000 --> 01:34:38.000]  число N.
[01:34:38.000 --> 01:34:40.000]  Оно есть.
[01:34:40.000 --> 01:34:42.000]  Дальше.
[01:34:42.000 --> 01:34:44.000]  Мы ищем
[01:34:44.000 --> 01:34:46.000]  Fiat N.
[01:34:46.000 --> 01:34:48.000]  Вот.
[01:34:48.000 --> 01:34:50.000]  Ну, пусть у нас будет там N равно.
[01:34:50.000 --> 01:34:52.000]  Окей.
[01:34:52.000 --> 01:34:56.000]  16 на 31.
[01:34:56.000 --> 01:34:58.000]  Хочу.
[01:34:58.000 --> 01:35:00.000]  Хочу такое.
[01:35:00.000 --> 01:35:02.000]  Fiat N тогда будет 16 на 30.
[01:35:02.000 --> 01:35:04.000]  Вот.
[01:35:04.000 --> 01:35:06.000]  Это первое.
[01:35:06.000 --> 01:35:08.000]  Первое задается число. Второе задается, значит,
[01:35:08.000 --> 01:35:10.000]  находится его функция Эйлера.
[01:35:10.000 --> 01:35:12.000]  Дальше.
[01:35:12.000 --> 01:35:14.000]  Мы берем
[01:35:14.000 --> 01:35:16.000]  число. Число E.
[01:35:16.000 --> 01:35:18.000]  Которое открыто, открывается
[01:35:18.000 --> 01:35:20.000]  открытым ключом. Вот.
[01:35:20.000 --> 01:35:22.000]  Какое это выбирается?
[01:35:22.000 --> 01:35:24.000]  Взаимно простое с Fiat N.
[01:35:24.000 --> 01:35:26.000]  Ну.
[01:35:26.000 --> 01:35:28.000]  17.
[01:35:28.000 --> 01:35:30.000]  Или 14.
[01:35:30.000 --> 01:35:32.000]  Давайте
[01:35:32.000 --> 01:35:34.000]  19.
[01:35:34.000 --> 01:35:36.000]  Да, 14 невзаимно.
[01:35:36.000 --> 01:35:38.000]  Просто это плохо.
[01:35:38.000 --> 01:35:40.000]  Тут 2 есть, и тут 2 будут. Вот.
[01:35:40.000 --> 01:35:42.000]  19. Вот 19 точно или просто.
[01:35:42.000 --> 01:35:44.000]  Дальше.
[01:35:44.000 --> 01:35:46.000]  Мы, что мы хотим?
[01:35:46.000 --> 01:35:48.000]  Значит, дальше что мы хотим?
[01:35:48.000 --> 01:35:50.000]  Чтобы
[01:35:50.000 --> 01:35:52.000]  D на E
[01:35:52.000 --> 01:35:54.000]  было сравнимо с единицей
[01:35:54.000 --> 01:35:56.000]  по модулю
[01:35:56.000 --> 01:35:58.000]  Fiat N.
[01:35:58.000 --> 01:36:00.000]  Вот такое мы хотим.
[01:36:00.000 --> 01:36:02.000]  Как мы это можем считать?
[01:36:02.000 --> 01:36:04.000]  Вот.
[01:36:04.000 --> 01:36:06.000]  Ева не посчитает, потому что Ева не знает
[01:36:06.000 --> 01:36:08.000]  Fiat N. Вот.
[01:36:08.000 --> 01:36:10.000]  Как мы это можем посчитать?
[01:36:10.000 --> 01:36:12.000]  Мы можем взять
[01:36:12.000 --> 01:36:14.000]  и решить.
[01:36:14.000 --> 01:36:16.000]  Что решить? На фантовое уравнение решить.
[01:36:16.000 --> 01:36:18.000]  Логично. Что такое D E сравнилось
[01:36:18.000 --> 01:36:20.000]  с единицей по модуле Fiat N?
[01:36:20.000 --> 01:36:22.000]  Это значит, что
[01:36:22.000 --> 01:36:24.000]  D
[01:36:24.000 --> 01:36:26.000]  умножить на E
[01:36:26.000 --> 01:36:28.000]  плюс
[01:36:28.000 --> 01:36:30.000]  соответственно
[01:36:30.000 --> 01:36:32.000]  какая-то константа, умноженная на Fiat N
[01:36:32.000 --> 01:36:34.000]  равно единице.
[01:36:34.000 --> 01:36:36.000]  Логично.
[01:36:36.000 --> 01:36:38.000]  Вот. Минус константа
[01:36:38.000 --> 01:36:40.000]  на самом деле.
[01:36:40.000 --> 01:36:42.000]  Но плюс, минус там не важно.
[01:36:42.000 --> 01:36:44.000]  Чисто для полного понимания.
[01:36:44.000 --> 01:36:46.000]  Fiat N плюс 1 – это D на E.
[01:36:46.000 --> 01:36:48.000]  Вот.
[01:36:48.000 --> 01:36:50.000]  Ну, собственно говоря, что? E мы знаем,
[01:36:50.000 --> 01:36:52.000]  Fiat N мы знаем, единицу мы знаем.
[01:36:52.000 --> 01:36:54.000]  Соответственно, в нашем случае я хочу найти D.
[01:36:54.000 --> 01:36:56.000]  Я подставляю сюда
[01:36:56.000 --> 01:36:58.000]  значит
[01:36:58.000 --> 01:37:00.000]  19D
[01:37:00.000 --> 01:37:02.000]  минус
[01:37:02.000 --> 01:37:04.000]  16 на 30 сколько будет?
[01:37:06.000 --> 01:37:08.000]  На 480.
[01:37:10.000 --> 01:37:12.000]  480.
[01:37:12.000 --> 01:37:14.000]  Это умножить на K.
[01:37:14.000 --> 01:37:16.000]  Это равно единице.
[01:37:16.000 --> 01:37:18.000]  Дальше.
[01:37:18.000 --> 01:37:20.000]  Мы умеем решать диафантовое уравнение.
[01:37:20.000 --> 01:37:22.000]  Мы находим
[01:37:22.000 --> 01:37:24.000]  вот отсюда.
[01:37:24.000 --> 01:37:26.000]  Будем решать
[01:37:26.000 --> 01:37:28.000]  или не будем время тратить.
[01:37:28.000 --> 01:37:30.000]  Вот. Решать диафантовое уравнение
[01:37:30.000 --> 01:37:32.000]  мы умеем. Находим нот
[01:37:32.000 --> 01:37:34.000]  19, 480 – это будет
[01:37:34.000 --> 01:37:36.000]  единица. Находим
[01:37:36.000 --> 01:37:38.000]  значит
[01:37:38.000 --> 01:37:40.000]  числа,
[01:37:40.000 --> 01:37:42.000]  Y соответствующий.
[01:37:42.000 --> 01:37:44.000]  Находим общее решение.
[01:37:44.000 --> 01:37:46.000]  То есть на D
[01:37:46.000 --> 01:37:48.000]  вот нужное нам
[01:37:48.000 --> 01:37:50.000]  выбираем. Ну,
[01:37:50.000 --> 01:37:52.000]  чтобы оно не было слишком огромным,
[01:37:52.000 --> 01:37:54.000]  ну, их там, понятно, бесконечно много будет.
[01:37:54.000 --> 01:37:56.000]  Ну, вот E у нас фиксированное.
[01:37:56.000 --> 01:37:58.000]  Значит,
[01:37:58.000 --> 01:38:00.000]  вот E фиксированное, оно меньше,
[01:38:00.000 --> 01:38:02.000]  меньше, чем Fiat N.
[01:38:02.000 --> 01:38:04.000]  Ну, то есть на D тоже должен быть меньше,
[01:38:04.000 --> 01:38:06.000]  чем Fiat N, но остаток, по-моему, для Fiat N какой-то.
[01:38:06.000 --> 01:38:08.000]  Вот. Из всего этого бесконечного
[01:38:08.000 --> 01:38:10.000]  множества пар D и K
[01:38:10.000 --> 01:38:12.000]  мы выберем там какой-то D,
[01:38:12.000 --> 01:38:14.000]  которое достаточно мало, чтобы не трепать нам нервы.
[01:38:14.000 --> 01:38:16.000]  Вот так, зная Fiat N, мы можем,
[01:38:16.000 --> 01:38:18.000]  зная открытый ключ Алисы,
[01:38:18.000 --> 01:38:20.000]  найти
[01:38:20.000 --> 01:38:22.000]  приватный ключ Боба.
[01:38:22.000 --> 01:38:24.000]  Вот. Дальше.
[01:38:24.000 --> 01:38:26.000]  Дальше.
[01:38:26.000 --> 01:38:28.000]  Вот эта штука.
[01:38:28.000 --> 01:38:30.000]  E и N видны всем.
[01:38:30.000 --> 01:38:32.000]  D
[01:38:32.000 --> 01:38:34.000]  Да, Алисы
[01:38:34.000 --> 01:38:36.000]  передают...
[01:38:36.000 --> 01:38:38.000]  Да, я забыла,
[01:38:38.000 --> 01:38:40.000]  да, я забыла, что
[01:38:40.000 --> 01:38:42.000]  моего ключ. Ну, да, короче,
[01:38:42.000 --> 01:38:44.000]  в общем,
[01:38:44.000 --> 01:38:46.000]  Алисы шифруют ключом E
[01:38:46.000 --> 01:38:48.000]  сообщение,
[01:38:48.000 --> 01:38:50.000]  передаваемое Бобу.
[01:38:50.000 --> 01:38:52.000]  Вот.
[01:38:52.000 --> 01:38:54.000]  А Боб расшифровывает своим приватным ключом D
[01:38:54.000 --> 01:38:56.000]  сообщение, передаваемое себе.
[01:38:56.000 --> 01:38:58.000]  Да.
[01:38:58.000 --> 01:39:00.000]  Ключа D Алиса не знает.
[01:39:00.000 --> 01:39:02.000]  Алиса знает E.
[01:39:04.000 --> 01:39:06.000]  Ну, да.
[01:39:08.000 --> 01:39:10.000]  Алиса знает E.
[01:39:10.000 --> 01:39:12.000]  Да, ключ Боба.
[01:39:14.000 --> 01:39:16.000]  Да, все знают E.
[01:39:16.000 --> 01:39:18.000]  Кто угодно может написать
[01:39:18.000 --> 01:39:20.000]  Бобу и Алиса и...
[01:39:20.000 --> 01:39:22.000]  Да, все знают E
[01:39:22.000 --> 01:39:24.000]  и все знают N.
[01:39:24.000 --> 01:39:26.000]  Да, никто не знает D,
[01:39:26.000 --> 01:39:28.000]  потому что никто не может
[01:39:28.000 --> 01:39:30.000]  разложить N на множители.
[01:39:30.000 --> 01:39:32.000]  Никто не может разложить N
[01:39:32.000 --> 01:39:34.000]  на множители.
[01:39:34.000 --> 01:39:36.000]  Никто не может посчитать fiat N.
[01:39:36.000 --> 01:39:38.000]  Никто не может
[01:39:38.000 --> 01:39:40.000]  таким образом высчитать,
[01:39:40.000 --> 01:39:42.000]  составить вот это диаф converging, никто не может.
[01:39:42.000 --> 01:39:44.000]  И, соответственно,
[01:39:44.000 --> 01:39:46.000]  никто не может насчитать D.
[01:39:48.000 --> 01:39:50.000]  Да.
[01:39:50.000 --> 01:39:52.000]  Вот. Ничего, да.
[01:39:52.000 --> 01:39:54.000]  Все упирается, да,
[01:39:54.000 --> 01:39:56.000]  в то, что вот они не могут разложить
[01:39:56.000 --> 01:40:01.500]  Если найти достаточно эффективный алгоритм, который будет быстро раскладывать намножители большие числа,
[01:40:01.500 --> 01:40:08.500]  то вы получите миллион долларов и разлом алгоритма RSA просто на патче.
[01:40:08.500 --> 01:40:18.500]  Ну, значит, ты уже не ЕВА. Если ты ЕВА, то ты не придешь к Бобу и не попросишь.
[01:40:18.500 --> 01:40:21.500]  Ну или Боб доверчивый дурачок.
[01:40:22.000 --> 01:40:26.000]  А доверчивые дурачки как-то не будут пользоваться криптографическими алгоритмами.
[01:40:26.000 --> 01:40:32.000]  Ну да ладно, вот. Собственно, как D находится, это понятно.
[01:40:32.000 --> 01:40:35.000]  Ну теперь я хочу отправить сообщение.
[01:40:35.000 --> 01:40:45.000]  Вот, я Алиса, я знаю пару EN, я знаю, что EN это 19 и 500 там с чем-то.
[01:40:45.000 --> 01:40:49.000]  Там, короче, 17 на 31 пусть будет, как будет.
[01:40:49.500 --> 01:40:57.500]  Вот. И я хочу отправить сообщение, ну, например, 5.
[01:41:00.500 --> 01:41:02.500]  Хочу отправить сообщение 5 Бобу.
[01:41:02.500 --> 01:41:06.500]  А вот. Ну ок. Я говорю, что я делаю шифротекст.
[01:41:06.500 --> 01:41:16.500]  Как я делаю шифротекст? Я беру и возвожу 5 в степень 19 по модулю.
[01:41:19.500 --> 01:41:21.500]  Давайте все-таки умножим и сейчас чиселки посчитаем.
[01:41:21.500 --> 01:41:25.500]  Да, 17 на 31. 527.
[01:41:27.500 --> 01:41:32.500]  Ок. Я говорю, что 5 в 19.
[01:41:32.500 --> 01:41:34.500]  А вот тут быстро возведение в степень пошло.
[01:41:34.500 --> 01:41:37.500]  Я не хочу считать миллиард лет. Это 5 в 19.
[01:41:37.500 --> 01:41:41.500]  5 на 5 в 18.
[01:41:41.500 --> 01:41:45.500]  5 на 5 в 9.
[01:41:46.000 --> 01:41:48.000]  Можно сейчас сразу это все...
[01:41:48.000 --> 01:41:52.000]  5 в 9 в квадрате. 5 на 5 в 9 в квадрате.
[01:41:52.000 --> 01:41:54.000]  Это 5 на 5.
[01:41:58.000 --> 01:42:00.000]  Так. 5 в квадрате.
[01:42:01.000 --> 01:42:03.000]  5 в 4.
[01:42:03.000 --> 01:42:05.000]  5 в 8.
[01:42:06.000 --> 01:42:08.000]  5 в 9.
[01:42:08.000 --> 01:42:10.000]  В 18. Вот так.
[01:42:11.000 --> 01:42:13.000]  Логично? Логично.
[01:42:13.500 --> 01:42:16.500]  Ну это что? Внешняя пятерка пока так пусть остается.
[01:42:16.500 --> 01:42:18.500]  5 в квадрате. Это 25.
[01:42:19.500 --> 01:42:21.500]  Раз, два, две скобки.
[01:42:21.500 --> 01:42:23.500]  25 в квадрате.
[01:42:25.500 --> 01:42:27.500]  В квадрате. На 5.
[01:42:27.500 --> 01:42:29.500]  Все это в квадрате. Дальше.
[01:42:29.500 --> 01:42:31.500]  Что будет?
[01:42:31.500 --> 01:42:33.500]  25 в квадрате это 625.
[01:42:33.500 --> 01:42:37.500]  625 минус 527.
[01:42:37.500 --> 01:42:39.500]  Это 98.
[01:42:39.500 --> 01:42:41.500]  Дальше говоря.
[01:42:43.000 --> 01:42:45.000]  5.
[01:42:45.000 --> 01:42:47.000]  98 в квадрате.
[01:42:50.000 --> 01:42:52.000]  На 5.
[01:42:52.000 --> 01:42:54.000]  И в квадрате.
[01:42:54.000 --> 01:42:56.000]  Что такое 98 в квадрате?
[01:42:56.000 --> 01:42:58.000]  98 в квадрате.
[01:42:58.000 --> 01:43:00.000]  9000 с копейками.
[01:43:00.000 --> 01:43:02.000]  527 0.
[01:43:03.000 --> 01:43:05.000]  Еще опять 270.
[01:43:10.000 --> 01:43:12.000]  Да.
[01:43:14.000 --> 01:43:16.000]  Вот 5.
[01:43:18.000 --> 01:43:20.000]  Да.
[01:43:21.000 --> 01:43:23.000]  Вот.
[01:43:23.000 --> 01:43:25.000]  Это 185 на
[01:43:25.000 --> 01:43:27.000]  118 на 5.
[01:43:29.000 --> 01:43:31.000]  В квадрате.
[01:43:31.000 --> 01:43:33.000]  118 на 5.
[01:43:35.000 --> 01:43:37.000]  Это 65 на 63 в квадрате.
[01:43:40.000 --> 01:43:42.000]  Это что такое 63 в квадрате?
[01:43:50.000 --> 01:43:52.000]  Вот.
[01:43:52.000 --> 01:43:58.000]  Это 280 на 5.
[01:43:58.000 --> 01:44:00.000]  Теперь это получается что?
[01:44:02.000 --> 01:44:04.000]  Вот.
[01:44:05.000 --> 01:44:07.000]  346.
[01:44:07.000 --> 01:44:09.000]  Я отправляю 346
[01:44:09.500 --> 01:44:11.500]  в Бобу.
[01:44:11.500 --> 01:44:13.500]  Значит.
[01:44:13.500 --> 01:44:15.500]  И собственно Боб
[01:44:15.500 --> 01:44:17.500]  может возвести это обратно
[01:44:17.500 --> 01:44:19.500]  в степень какую мы найдем.
[01:44:19.500 --> 01:44:21.500]  Вот здесь насчитаем.
[01:44:21.500 --> 01:44:23.500]  Когда мы решим вот эту штуку
[01:44:23.500 --> 01:44:25.500]  мы найдем число D,
[01:44:25.500 --> 01:44:27.500]  которое соответствует Бобу.
[01:44:27.500 --> 01:44:29.500]  Возведем его в степень обратно.
[01:44:29.500 --> 01:44:31.500]  И получим
[01:44:31.500 --> 01:44:33.500]  нужное нам значение.
[01:44:33.500 --> 01:44:35.500]  Почему эта штука работает?
[01:44:35.500 --> 01:44:37.500]  Потому что ED это единица
[01:44:37.500 --> 01:44:39.500]  к модулю phi от n.
[01:44:39.500 --> 01:44:41.500]  Как известно, если мы возводим какое-то число
[01:44:41.500 --> 01:44:43.500]  в степень phi от
[01:44:43.500 --> 01:44:45.500]  числа
[01:44:45.500 --> 01:44:47.500]  phi от n так к модулю n они совпадут.
[01:44:47.500 --> 01:44:49.500]  Помним мы завоидка.
[01:44:51.500 --> 01:44:53.500]  Если
[01:44:53.500 --> 01:44:55.500]  вот ну
[01:44:57.500 --> 01:44:59.500]  a в степени phi от n
[01:45:03.500 --> 01:45:05.500]  сравнимо с единицей
[01:45:07.500 --> 01:45:09.500]  по модулу n.
[01:45:09.500 --> 01:45:11.500]  Помним мы завоидка.
[01:45:11.500 --> 01:45:13.500]  Вот. Хорошо.
[01:45:13.500 --> 01:45:15.500]  Вот наш RSA.
[01:45:15.500 --> 01:45:17.500]  То есть если мы говорим я хочу отправить
[01:45:17.500 --> 01:45:19.500]  сообщение такое,
[01:45:19.500 --> 01:45:21.500]  то я зная вот открытый ключ
[01:45:21.500 --> 01:45:23.500]  шифрую открытым ключом.
[01:45:23.500 --> 01:45:25.500]  То есть возвожу в степень
[01:45:25.500 --> 01:45:27.500]  открытого ключа по модулю числа.
[01:45:27.500 --> 01:45:29.500]  Возвал быстрого зрения в степень.
[01:45:29.500 --> 01:45:31.500]  Если говорят найдите приватный ключ,
[01:45:31.500 --> 01:45:33.500]  то я составляю
[01:45:33.500 --> 01:45:35.500]  диафантовое уравнение,
[01:45:35.500 --> 01:45:37.500]  нахожу приватный ключ.
[01:45:37.500 --> 01:45:39.500]  Если мне говорят расшифруйте,
[01:45:41.500 --> 01:45:43.500]  то я беру этот шифротекст,
[01:45:43.500 --> 01:45:45.500]  возвожу его в степень приватного ключа.
[01:45:45.500 --> 01:45:47.500]  Логично?
[01:45:47.500 --> 01:45:49.500]  Логично.
[01:45:49.500 --> 01:45:51.500]  Осталась электронная подпись.
[01:45:51.500 --> 01:45:53.500]  Вот.
[01:45:53.500 --> 01:45:55.500]  Но что такое электронная подпись?
[01:45:55.500 --> 01:45:57.500]  Это как под документами подпись.
[01:45:57.500 --> 01:45:59.500]  Но тогда мы получается будем
[01:45:59.500 --> 01:46:01.500]  отправлять.
[01:46:01.500 --> 01:46:03.500]  Вот.
[01:46:03.500 --> 01:46:05.500]  У нас есть у каждого
[01:46:07.500 --> 01:46:09.500]  у каждого челика по алгоритмам
[01:46:09.500 --> 01:46:11.500]  считается эта подпись, и мы будем отправлять
[01:46:11.500 --> 01:46:13.500]  открытое сообщение
[01:46:13.500 --> 01:46:15.500]  с открытой подписью.
[01:46:15.500 --> 01:46:17.500]  Если я, например, хочу
[01:46:17.500 --> 01:46:19.500]  отправить Александру Александровичу
[01:46:19.500 --> 01:46:21.500]  письмо, я решила там
[01:46:21.500 --> 01:46:23.500]  ваше задание по диплому.
[01:46:23.500 --> 01:46:25.500]  И подпись Соня.
[01:46:25.500 --> 01:46:27.500]  Эта подпись Соня, она будет не просто такая,
[01:46:27.500 --> 01:46:29.500]  которую может каждый кто угодно написать.
[01:46:29.500 --> 01:46:31.500]  Я там ее напишу. Но текст, что я там решила
[01:46:31.500 --> 01:46:33.500]  ваше задание по диплому, будет там прямо так
[01:46:33.500 --> 01:46:35.500]  текстово написано. Вот.
[01:46:35.500 --> 01:46:37.500]  А если я не хочу, чтобы кто-то там
[01:46:37.500 --> 01:46:39.500]  третью увидел, что именно
[01:46:39.500 --> 01:46:41.500]  я ему говорю, если я ему
[01:46:41.500 --> 01:46:43.500]  контрольную передаю, например,
[01:46:43.500 --> 01:46:45.500]  то я должна буду потом ее опять засустровать.
[01:46:45.500 --> 01:46:47.500]  То есть вот эту пару.
[01:46:47.500 --> 01:46:49.500]  И сообщение, и электронные
[01:46:49.500 --> 01:46:51.500]  подписи я буду рассматривать
[01:46:51.500 --> 01:46:53.500]  как какое-то число.
[01:46:53.500 --> 01:46:55.500]  Пусть будет М большое.
[01:46:55.500 --> 01:46:57.500]  Опять прогонять его через
[01:46:57.500 --> 01:46:59.500]  РСА. Вот. Через вон тот.
[01:46:59.500 --> 01:47:01.500]  Передавать уже шифротекст
[01:47:01.500 --> 01:47:03.500]  от вот этого вот.
[01:47:03.500 --> 01:47:05.500]  И потом, допустим, Александр
[01:47:05.500 --> 01:47:07.500]  Александрович будет расшифровывать это.
[01:47:07.500 --> 01:47:09.500]  Видеть в нем какой-то текст.
[01:47:09.500 --> 01:47:11.500]  И подпись. Вот.
[01:47:11.500 --> 01:47:13.500]  Там, например, там
[01:47:13.500 --> 01:47:15.500]  я захочу, там, вот, если на подпись
[01:47:15.500 --> 01:47:17.500]  10 бит или там 20 бит.
[01:47:17.500 --> 01:47:19.500]  А на сообщение там
[01:47:19.500 --> 01:47:21.500]  300 бит. И первые 300 бит
[01:47:21.500 --> 01:47:23.500]  после расшифровки будут знать
[01:47:23.500 --> 01:47:25.500]  что это сообщение. Оставшаяся подпись
[01:47:25.500 --> 01:47:27.500]  сможет сверить там подпись
[01:47:27.500 --> 01:47:29.500]  полученную после расшифровки
[01:47:29.500 --> 01:47:31.500]  подписью, которую он знает.
[01:47:31.500 --> 01:47:33.500]  И текст, собственно, дальше прочитать.
[01:47:33.500 --> 01:47:35.500]  Вот. Как строится
[01:47:35.500 --> 01:47:37.500]  электронная подпись С.
[01:47:37.500 --> 01:47:39.500]  Вот.
[01:47:39.500 --> 01:47:41.500]  Значит, у нас есть
[01:47:41.500 --> 01:47:43.500]  значит, наши ключи,
[01:47:43.500 --> 01:47:45.500]  все дела.
[01:47:45.500 --> 01:47:47.500]  Как строится
[01:47:47.500 --> 01:47:49.500]  подпись.
[01:47:49.500 --> 01:47:51.500]  У Алисы есть секретный ключ.
[01:47:53.500 --> 01:47:55.500]  Вот.
[01:47:57.500 --> 01:47:59.500]  И она этим секретным ключом
[01:48:01.500 --> 01:48:03.500]  находит цифровую подпись
[01:48:03.500 --> 01:48:05.500]  равную чему.
[01:48:05.500 --> 01:48:07.500]  Значит, сообщение, которое она
[01:48:07.500 --> 01:48:09.500]  хочет отправить в степени
[01:48:09.500 --> 01:48:11.500]  своего секретного ключа
[01:48:11.500 --> 01:48:13.500]  модулю N.
[01:48:13.500 --> 01:48:15.500]  Вот.
[01:48:15.500 --> 01:48:17.500]  Вот.
[01:48:17.500 --> 01:48:19.500]  Ну, собственно, подпись мы знаем,
[01:48:19.500 --> 01:48:21.500]  что это подпись и не обы что.
[01:48:21.500 --> 01:48:23.500]  Вот. И, соответственно,
[01:48:23.500 --> 01:48:25.500]  передаем эту пару
[01:48:25.500 --> 01:48:27.500]  N. Да.
[01:48:27.500 --> 01:48:29.500]  То есть вот я...
[01:48:29.500 --> 01:48:31.500]  Да. Вот это Алиса.
[01:48:31.500 --> 01:48:33.500]  Да. N Алиса. Вот. Вот.
[01:48:33.500 --> 01:48:35.500]  Вот N, которая генерирует
[01:48:35.500 --> 01:48:37.500]  подпись.
[01:48:37.500 --> 01:48:39.500]  И N, которая передает сообщение.
[01:48:39.500 --> 01:48:41.500]  Это две разных N. То есть сначала мы применяем
[01:48:41.500 --> 01:48:43.500]  протокол для генерации электронной подписи.
[01:48:43.500 --> 01:48:45.500]  Я хочу передать 5.
[01:48:45.500 --> 01:48:47.500]  У меня секретный ключ.
[01:48:47.500 --> 01:48:49.500]  Там, я не знаю,
[01:48:49.500 --> 01:48:51.500]  11.
[01:48:51.500 --> 01:48:53.500]  Ну, давайте 11.
[01:48:53.500 --> 01:48:55.500]  У меня секретный ключ 11.
[01:48:55.500 --> 01:48:57.500]  Я хочу передать сообщение.
[01:48:57.500 --> 01:48:59.500]  Ключ 11.
[01:48:59.500 --> 01:49:01.500]  Я хочу передать 5.
[01:49:01.500 --> 01:49:03.500]  Тогда моя подпись будет 5 в 11.
[01:49:03.500 --> 01:49:05.500]  По модулю там вот этого будет.
[01:49:05.500 --> 01:49:07.500]  Там 5 в 7.
[01:49:07.500 --> 01:49:09.500]  Да.
[01:49:11.500 --> 01:49:13.500]  Вот. Да, подпись.
[01:49:13.500 --> 01:49:15.500]  Ну, и как найти эту подпись?
[01:49:15.500 --> 01:49:17.500]  Опять-таки быстрым возведением.
[01:49:17.500 --> 01:49:19.500]  Вот.
[01:49:19.500 --> 01:49:21.500]  Ну, а дальше
[01:49:21.500 --> 01:49:23.500]  подлинности подписи.
[01:49:23.500 --> 01:49:25.500]  Вот.
[01:49:25.500 --> 01:49:27.500]  Вот это никто не знает.
[01:49:27.500 --> 01:49:29.500]  Да, никто не знает. В алгоритме проверки
[01:49:29.500 --> 01:49:31.500]  подлинности подписи. Вот это пара M S.
[01:49:31.500 --> 01:49:33.500]  Каким-то образом, да, Боба?
[01:49:35.500 --> 01:49:37.500]  У Боба есть
[01:49:37.500 --> 01:49:39.500]  E N, то есть
[01:49:39.500 --> 01:49:41.500]  Алисы на N и Алисы на открытый ключ.
[01:49:41.500 --> 01:49:43.500]  Давайте вот здесь метим N A.
[01:49:43.500 --> 01:49:45.500]  N Алисы, N Алисы.
[01:49:45.500 --> 01:49:47.500]  Вот. Алисы на открытый ключ есть.
[01:49:47.500 --> 01:49:49.500]  И N, который есть.
[01:49:49.500 --> 01:49:51.500]  И, соответственно, пытается
[01:49:51.500 --> 01:49:53.500]  он...
[01:49:53.500 --> 01:49:55.500]  Вот есть
[01:49:55.500 --> 01:49:57.500]  сообщение подписанное. Вот у него есть пара M S.
[01:49:57.500 --> 01:49:59.500]  Он располагает
[01:49:59.500 --> 01:50:01.500]  вот таким.
[01:50:01.500 --> 01:50:03.500]  Он располагает ключом.
[01:50:03.500 --> 01:50:05.500]  Открытым Алисыным.
[01:50:05.500 --> 01:50:07.500]  Он пытается возвести подпись
[01:50:07.500 --> 01:50:09.500]  в степень E.
[01:50:09.500 --> 01:50:11.500]  Это то же самое, что
[01:50:11.500 --> 01:50:13.500]  M в степени D.
[01:50:13.500 --> 01:50:15.500]  В степени E.
[01:50:15.500 --> 01:50:17.500]  Это то же самое, что M.
[01:50:17.500 --> 01:50:19.500]  Логично?
[01:50:19.500 --> 01:50:21.500]  Логично.
[01:50:21.500 --> 01:50:23.500]  Соответственно, он должен...
[01:50:23.500 --> 01:50:25.500]  Вот эта штука M S.
[01:50:25.500 --> 01:50:27.500]  Вот эта штука M S.
[01:50:27.500 --> 01:50:29.500]  По идее,
[01:50:29.500 --> 01:50:31.500]  если подпись подлинна,
[01:50:31.500 --> 01:50:33.500]  то есть если подписалась реально Алиса,
[01:50:33.500 --> 01:50:35.500]  то тогда они должны
[01:50:35.500 --> 01:50:37.500]  вот эта M и M S совпасть.
[01:50:37.500 --> 01:50:39.500]  Если подписалась реально Алиса, раз,
[01:50:39.500 --> 01:50:41.500]  и если никто по дороге не испортил
[01:50:41.500 --> 01:50:43.500]  сообщение, два, вот.
[01:50:43.500 --> 01:50:45.500]  Соответственно,
[01:50:45.500 --> 01:50:47.500]  это штука
[01:50:47.500 --> 01:50:49.500]  передается.
[01:50:49.500 --> 01:50:51.500]  Она может, да, передаваться
[01:50:51.500 --> 01:50:53.500]  в голом виде M S.
[01:50:53.500 --> 01:50:55.500]  Но если мы хотим передать секретно,
[01:50:55.500 --> 01:50:57.500]  то мы сначала подпишем.
[01:50:57.500 --> 01:50:59.500]  То есть у нас будет N Алисы.
[01:50:59.500 --> 01:51:01.500]  Мы подпишем при помощи N Алисы
[01:51:01.500 --> 01:51:03.500]  сообщение
[01:51:03.500 --> 01:51:05.500]  к подписью Алисы.
[01:51:05.500 --> 01:51:07.500]  Потом мы возьмем другое N,
[01:51:07.500 --> 01:51:09.500]  N Боба.
[01:51:09.500 --> 01:51:11.500]  Зашифруем вот эту пару.
[01:51:11.500 --> 01:51:13.500]  В этой паре поставим соответствие
[01:51:13.500 --> 01:51:15.500]  Вот это число зашифруем
[01:51:15.500 --> 01:51:17.500]  другим N, N Боба.
[01:51:17.500 --> 01:51:19.500]  Потом Боб расшифрует
[01:51:19.500 --> 01:51:21.500]  его своей D,
[01:51:21.500 --> 01:51:23.500]  своей N, своей D
[01:51:23.500 --> 01:51:25.500]  и получит этот M.
[01:51:25.500 --> 01:51:27.500]  Потом он, зная, что, допустим,
[01:51:27.500 --> 01:51:29.500]  там первые биты это одно,
[01:51:29.500 --> 01:51:31.500]  последние биты это другое,
[01:51:31.500 --> 01:51:33.500]  где проходит граница между сообщением
[01:51:33.500 --> 01:51:35.500]  и подписью, отсечет сообщение
[01:51:35.500 --> 01:51:37.500]  от подписи, потом он возьмет эту
[01:51:37.500 --> 01:51:39.500]  подпись, возведет ее в степень
[01:51:39.500 --> 01:51:41.500]  Алисыного E и проверит.
[01:51:41.500 --> 01:51:43.500]  Совпадает то M, которое к нему пришло
[01:51:43.500 --> 01:51:45.500]  с подписью и тем
[01:51:45.500 --> 01:51:47.500]  M, которое должно было, или нет?
[01:51:49.500 --> 01:51:51.500]  Все ли понятно про RSA,
[01:51:51.500 --> 01:51:53.500]  про подпись?
[01:51:59.500 --> 01:52:01.500]  Смотри,
[01:52:01.500 --> 01:52:03.500]  все будут, да,
[01:52:03.500 --> 01:52:05.500]  N знать все будут, но
[01:52:05.500 --> 01:52:07.500]  никто не умеет его на множители
[01:52:07.500 --> 01:52:09.500]  раскладывать, поэтому никто не может
[01:52:09.500 --> 01:52:11.500]  посчитать phi.
[01:52:11.500 --> 01:52:13.500]  Поэтому зная E и зная N,
[01:52:13.500 --> 01:52:15.500]  никто не может найти D.
[01:52:19.500 --> 01:52:21.500]  Соответственно,
[01:52:21.500 --> 01:52:23.500]  у Алисы,
[01:52:23.500 --> 01:52:25.500]  еще раз проходит, у нас есть,
[01:52:25.500 --> 01:52:27.500]  чем мы суммарно в итоге
[01:52:27.500 --> 01:52:29.500]  располагаем? Мы располагаем,
[01:52:29.500 --> 01:52:31.500]  у Алисы есть
[01:52:31.500 --> 01:52:33.500]  свое N, свое E,
[01:52:39.500 --> 01:52:41.500]  давайте вернемся к тем
[01:52:41.500 --> 01:52:43.500]  нарисованным классам.
[01:52:43.500 --> 01:52:45.500]  У Алисы есть
[01:52:45.500 --> 01:52:47.500]  N Алисы,
[01:52:49.500 --> 01:52:51.500]  E Алисы,
[01:52:51.500 --> 01:52:53.500]  оно всем видно,
[01:52:53.500 --> 01:52:55.500]  и Бобу, и Алисе, и Еле.
[01:52:55.500 --> 01:52:57.500]  Здесь есть N Боба, и E Боба.
[01:53:01.500 --> 01:53:03.500]  Хорошо,
[01:53:03.500 --> 01:53:05.500]  их тоже всем видно.
[01:53:05.500 --> 01:53:07.500]  Вот здесь у Алисы есть N Алисы,
[01:53:07.500 --> 01:53:09.500]  и D Алисы,
[01:53:09.500 --> 01:53:11.500]  вот здесь у Боба
[01:53:11.500 --> 01:53:13.500]  есть N Боба,
[01:53:13.500 --> 01:53:15.500]  и D Боба.
[01:53:15.500 --> 01:53:17.500]  И никто не знает.
[01:53:17.500 --> 01:53:19.500]  Алиса хочет передать
[01:53:19.500 --> 01:53:21.500]  сообщение M,
[01:53:21.500 --> 01:53:23.500]  она возводит сообщение
[01:53:23.500 --> 01:53:25.500]  M в степень
[01:53:25.500 --> 01:53:27.500]  вот этого вот E,
[01:53:29.500 --> 01:53:31.500]  сообщение M,
[01:53:31.500 --> 01:53:33.500]  шифротекст,
[01:53:33.500 --> 01:53:35.500]  это будет M в степени
[01:53:35.500 --> 01:53:37.500]  E
[01:53:37.500 --> 01:53:39.500]  Боба
[01:53:39.500 --> 01:53:41.500]  по модулю N
[01:53:41.500 --> 01:53:43.500]  Боба.
[01:53:43.500 --> 01:53:45.500]  И вот этот шифротекст передается
[01:53:45.500 --> 01:53:47.500]  от Алисы к Бобу.
[01:53:47.500 --> 01:53:49.500]  Дальше, если Алиса
[01:53:49.500 --> 01:53:51.500]  хочет подписать,
[01:53:51.500 --> 01:53:53.500]  соответственно
[01:53:53.500 --> 01:53:55.500]  отпись будет
[01:53:55.500 --> 01:53:57.500]  сообщение
[01:53:57.500 --> 01:53:59.500]  в степень D Алисы
[01:54:01.500 --> 01:54:03.500]  по модулю N Алисы.
[01:54:05.500 --> 01:54:07.500]  Да.
[01:54:07.500 --> 01:54:09.500]  Вот.
[01:54:13.500 --> 01:54:15.500]  Ну, N Боба
[01:54:15.500 --> 01:54:17.500]  лежит у Боба.
[01:54:17.500 --> 01:54:19.500]  Вот это разложение
[01:54:19.500 --> 01:54:21.500]  на P и Q знает только Боб.
[01:54:21.500 --> 01:54:23.500]  Алисе видно N,
[01:54:23.500 --> 01:54:25.500]  Еве видно N,
[01:54:25.500 --> 01:54:27.500]  еще как-нибудь там Майклу, Джону
[01:54:27.500 --> 01:54:29.500]  и прочим видно N и E.
[01:54:29.500 --> 01:54:31.500]  А P Боба и Q Боба
[01:54:31.500 --> 01:54:33.500]  знают только Боб.
[01:54:33.500 --> 01:54:35.500]  Ну и да.
[01:54:35.500 --> 01:54:37.500]  Если Алиса хочет сказать, что подписаны,
[01:54:37.500 --> 01:54:39.500]  то она сначала шифрует.
[01:54:39.500 --> 01:54:41.500]  Сначала подписывает своим ключом.
[01:54:41.500 --> 01:54:43.500]  Потом
[01:54:43.500 --> 01:54:45.500]  полученную штуку перегоняет
[01:54:45.500 --> 01:54:47.500]  как-то в число.
[01:54:47.500 --> 01:54:49.500]  Вот.
[01:54:49.500 --> 01:54:51.500]  Например, там подпись занимает
[01:54:51.500 --> 01:54:53.500]  там 10 бит.
[01:54:53.500 --> 01:54:55.500]  А сообщение занимает
[01:54:55.500 --> 01:54:57.500]  20 бит.
[01:54:57.500 --> 01:54:59.500]  Соответственно, получится число длиной
[01:54:59.500 --> 01:55:01.500]  в 30 бит.
[01:55:01.500 --> 01:55:03.500]  И вот это как число будем рассматривать.
[01:55:03.500 --> 01:55:05.500]  Это число будем шифровать
[01:55:05.500 --> 01:55:07.500]  ключом N Боба
[01:55:07.500 --> 01:55:09.500]  и E Боба.
[01:55:09.500 --> 01:55:11.500]  Возводить вот этот M-ка будет
[01:55:11.500 --> 01:55:13.500]  состоять из пары перегнанных
[01:55:13.500 --> 01:55:15.500]  в какое-то число.
[01:55:15.500 --> 01:55:17.500]  Возводится в степень.
[01:55:17.500 --> 01:55:19.500]  Дальше Боб
[01:55:19.500 --> 01:55:21.500]  принимает полученную тему.
[01:55:21.500 --> 01:55:23.500]  Возводит ее в степень своего D,
[01:55:23.500 --> 01:55:25.500]  которая знает только он сам.
[01:55:25.500 --> 01:55:27.500]  Получает какое-то опять-таки
[01:55:27.500 --> 01:55:29.500]  30-битное число.
[01:55:29.500 --> 01:55:31.500]  И в этом 30-битном числе
[01:55:31.500 --> 01:55:33.500]  проходит граница между сообщением и подписи.
[01:55:33.500 --> 01:55:35.500]  На первые 20 бит смотрит
[01:55:35.500 --> 01:55:37.500]  как на сообщение.
[01:55:37.500 --> 01:55:39.500]  На последние 10 бит смотрит
[01:55:39.500 --> 01:55:41.500]  как на подпись.
[01:55:41.500 --> 01:55:43.500]  Дальше он проверяет
[01:55:43.500 --> 01:55:45.500]  подлинность подписи
[01:55:45.500 --> 01:55:47.500]  путем возведения подписи.
[01:55:47.500 --> 01:55:49.500]  То есть последних, грубо говоря, 10 бит.
[01:55:49.500 --> 01:55:51.500]  В степень E своего.
[01:55:53.500 --> 01:55:55.500]  E Алисонова.
[01:55:55.500 --> 01:55:57.500]  Если сошлось,
[01:55:57.500 --> 01:55:59.500]  то есть если сообщение,
[01:55:59.500 --> 01:56:01.500]  то есть если последние,
[01:56:01.500 --> 01:56:03.500]  допустим, 10 бит,
[01:56:03.500 --> 01:56:05.500]  возведенные в степень E Алисы
[01:56:05.500 --> 01:56:07.500]  дадут то,
[01:56:07.500 --> 01:56:09.500]  что совпало с первыми 20 битами,
[01:56:09.500 --> 01:56:11.500]  то значит все OK.
[01:56:11.500 --> 01:56:13.500]  То есть E Алиса отправила сообщение,
[01:56:13.500 --> 01:56:15.500]  подписала его подписью,
[01:56:15.500 --> 01:56:17.500]  подписала же действительно она,
[01:56:17.500 --> 01:56:19.500]  и сообщение не поменяли.
[01:56:21.500 --> 01:56:23.500]  Собственно,
[01:56:23.500 --> 01:56:25.500]  если где-то там по дороге поломалось сообщение,
[01:56:25.500 --> 01:56:27.500]  или если где-то
[01:56:27.500 --> 01:56:29.500]  или если подписала не Алиса,
[01:56:29.500 --> 01:56:31.500]  то есть тогда будет ошибка.
[01:56:31.500 --> 01:56:33.500]  Или если и то и то.
[01:56:33.500 --> 01:56:35.500]  Буквально там настолько редко
[01:56:35.500 --> 01:56:37.500]  может встретиться случай,
[01:56:37.500 --> 01:56:39.500]  что они и подпись,
[01:56:39.500 --> 01:56:41.500]  что вот, допустим, абстрактная E,
[01:56:41.500 --> 01:56:43.500]  и подпись так хорошо поломала,
[01:56:43.500 --> 01:56:45.500]  и сообщение так хорошо поломало,
[01:56:45.500 --> 01:56:47.500]  что оно сошлось.
[01:56:47.500 --> 01:56:49.500]  В принципе, может быть, технически,
[01:56:49.500 --> 01:56:51.500]  что первый кусок превратился
[01:56:51.500 --> 01:56:53.500]  в какой-то M штрих,
[01:56:53.500 --> 01:56:55.500]  а подпись, возведенная в степень,
[01:56:55.500 --> 01:56:57.500]  превратилась в какое-то другое число,
[01:56:57.500 --> 01:56:59.500]  и если мы возведем
[01:56:59.500 --> 01:57:01.500]  полученную подпись в нужную степень,
[01:57:01.500 --> 01:57:03.500]  то эти двое сойдутся.
[01:57:03.500 --> 01:57:05.500]  Это настолько редкий случай,
[01:57:05.500 --> 01:57:07.500]  что им можно пренебреть.
[01:57:07.500 --> 01:57:09.500]  Все понятно про E Алиса?
[01:57:11.500 --> 01:57:13.500]  Если есть вопросы,
[01:57:13.500 --> 01:57:15.500]  в каком месте они есть,
[01:57:15.500 --> 01:57:17.500]  говорите их в ж.
[01:57:23.500 --> 01:57:25.500]  Да.
[01:57:25.500 --> 01:57:27.500]  Да.
[01:57:31.500 --> 01:57:33.500]  Нет, смотри, E это открытая ключ.
[01:57:35.500 --> 01:57:37.500]  А D закрытая?
[01:57:37.500 --> 01:57:39.500]  Д закрытая.
[01:57:41.500 --> 01:57:43.500]  Вот.
[01:57:43.500 --> 01:57:45.500]  Вопросики, не вопросики.
[01:57:49.500 --> 01:57:51.500]  E, смотри.
[01:57:53.500 --> 01:57:57.500]  D мы решаем диафантовое уравнение,
[01:57:57.500 --> 01:57:59.500]  то есть наш компьютер.
[01:57:59.500 --> 01:58:01.500]  У меня у Алиса есть компьютер.
[01:58:01.500 --> 01:58:03.500]  Он знает мое N,
[01:58:03.500 --> 01:58:05.500]  разложение его на множители,
[01:58:05.500 --> 01:58:07.500]  он знает мое D,
[01:58:07.500 --> 01:58:09.500]  и он решает вот это вот диафантовое уравнение.
[01:58:09.500 --> 01:58:11.500]  Но если мы сами как люди будем решать
[01:58:11.500 --> 01:58:13.500]  диафантовое уравнение,
[01:58:13.500 --> 01:58:15.500]  то мы накопаем там бесконечно много решений,
[01:58:15.500 --> 01:58:17.500]  и все, кроме одного, будут бредовые.
[01:58:17.500 --> 01:58:19.500]  Почему будут бредовые?
[01:58:19.500 --> 01:58:21.500]  Потому что они будут или отрицательные,
[01:58:21.500 --> 01:58:23.500]  большие, то есть больше, чем Fiat N.
[01:58:25.500 --> 01:58:27.500]  А поскольку нам удобно работать
[01:58:27.500 --> 01:58:29.500]  среди остатков,
[01:58:29.500 --> 01:58:31.500]  то мы просто выберем тот из D,
[01:58:31.500 --> 01:58:33.500]  который является остатком.
[01:58:35.500 --> 01:58:37.500]  Вот, от нуля до Fiat N.
[01:58:39.500 --> 01:58:41.500]  Вопросики?
[01:58:43.500 --> 01:58:45.500]  Алиса, сколько времени?
[01:58:45.500 --> 01:58:47.500]  У тебя вероятность?
[01:58:51.500 --> 01:58:53.500]  Что?
[01:58:53.500 --> 01:58:55.500]  И фурежечка.
[01:58:57.500 --> 01:58:59.500]  Вопрос?
[01:58:59.500 --> 01:59:01.500]  Какой?
[01:59:15.500 --> 01:59:17.500]  Думаешь, я помню эту задачу?
[01:59:35.500 --> 01:59:37.500]  Основание ТНК?
[01:59:37.500 --> 01:59:39.500]  А, ну да.
[01:59:39.500 --> 01:59:41.500]  Мы поражевали,
[01:59:41.500 --> 01:59:43.500]  что в принципе было возможным
[01:59:43.500 --> 01:59:45.500]  какое-то прощение по себе.
[01:59:51.500 --> 01:59:53.500]  То есть, если оно реально
[01:59:53.500 --> 01:59:55.500]  по определению неправильно,
[01:59:55.500 --> 01:59:57.500]  тогда нет, надо его рассматривать.
[01:59:57.500 --> 01:59:59.500]  Давай?
[01:59:59.500 --> 02:00:01.500]  Алиня.
[02:00:01.500 --> 02:00:03.500]  Про вероятность, наверное,
[02:00:03.500 --> 02:00:05.500]  надо сначала напомнить.
[02:00:05.500 --> 02:00:07.500]  Если не определение,
[02:00:07.500 --> 02:00:09.500]  то хотя бы основные формулы.
[02:00:09.500 --> 02:00:11.500]  Давай, чтобы не тереть время.
[02:00:13.500 --> 02:00:15.500]  Что такое вероятность?
[02:00:15.500 --> 02:00:17.500]  От ожидания?
[02:00:17.500 --> 02:00:19.500]  Что такое независимые события?
[02:00:19.500 --> 02:00:21.500]  Все помнят, да?
[02:00:21.500 --> 02:00:23.500]  Это достаточно интуитивно понятные вещи.
[02:00:23.500 --> 02:00:25.500]  Но формулы какие-то основные,
[02:00:25.500 --> 02:00:27.500]  которые стоит пользоваться,
[02:00:27.500 --> 02:00:29.500]  наверное, нужно помнить.
[02:00:29.500 --> 02:00:31.500]  Вот у нас есть формула Байса.
[02:00:37.500 --> 02:00:41.500]  Вероятность события A при условии B.
[02:00:43.500 --> 02:00:47.500]  Вероятность события A.
[02:00:47.500 --> 02:00:53.500]  Вероятность события B при условии A.
[02:00:53.500 --> 02:00:57.500]  Вероятность B.
[02:00:57.500 --> 02:00:59.500]  Мы здесь все приводим без доказательств, конечно.
[02:00:59.500 --> 02:01:01.500]  Что у нас еще там?
[02:01:01.500 --> 02:01:03.500]  Есть формула полной вероятности.
[02:01:07.500 --> 02:01:09.500]  То есть, у нас есть
[02:01:09.500 --> 02:01:11.500]  вероятность на пространство У.
[02:01:13.500 --> 02:01:15.500]  И у нас есть дизъюнтные объединения
[02:01:15.500 --> 02:01:17.500]  на какие-то события.
[02:01:17.500 --> 02:01:19.500]  Здесь важно, что они дизъюнтные.
[02:01:29.500 --> 02:01:31.500]  Сумма вероятностей.
[02:01:31.500 --> 02:01:33.500]  Вероятность.
[02:01:33.500 --> 02:01:35.500]  Понятно, что сумма.
[02:01:35.500 --> 02:01:37.500]  Сейчас.
[02:01:37.500 --> 02:01:39.500]  Ну да.
[02:01:43.500 --> 02:01:45.500]  Вероятность A это
[02:01:47.500 --> 02:01:49.500]  сумма
[02:01:49.500 --> 02:01:51.500]  как равна
[02:01:51.500 --> 02:01:57.500]  вероятности A при условии B.
[02:01:57.500 --> 02:01:59.500]  Вероятность B.
[02:02:01.500 --> 02:02:03.500]  Так.
[02:02:03.500 --> 02:02:05.500]  Чтобы пока далеко не ходить,
[02:02:05.500 --> 02:02:07.500]  вот у нас есть две формулы.
[02:02:07.500 --> 02:02:09.500]  Когда у нас речь заходит об условной вероятности,
[02:02:09.500 --> 02:02:11.500]  то это у нас
[02:02:11.500 --> 02:02:13.500]  в первую очередь про них,
[02:02:13.500 --> 02:02:15.500]  скорее всего.
[02:02:15.500 --> 02:02:17.500]  Давайте для напоминания
[02:02:17.500 --> 02:02:19.500]  простую задачу.
[02:02:19.500 --> 02:02:21.500]  Мне кажется, что это вполне в стиле
[02:02:21.500 --> 02:02:23.500]  того, что у вас было.
[02:02:23.500 --> 02:02:25.500]  Короче, у нас работает
[02:02:25.500 --> 02:02:27.500]  в издании два журналиста X и Y.
[02:02:27.500 --> 02:02:29.500]  И они по очереди пишут статьи.
[02:02:29.500 --> 02:02:31.500]  X и Y.
[02:02:31.500 --> 02:02:33.500]  И иногда допускают фактические ошибки.
[02:02:33.500 --> 02:02:35.500]  Они допускают
[02:02:35.500 --> 02:02:37.500]  что-то подозрительно часто.
[02:02:37.500 --> 02:02:39.500]  То есть в условии, скажем,
[02:02:39.500 --> 02:02:41.500]  что журналист X допускает
[02:02:41.500 --> 02:02:43.500]  фактические ошибки
[02:02:43.500 --> 02:02:45.500]  в 25% статей.
[02:02:45.500 --> 02:02:47.500]  То есть ошибки.
[02:02:47.500 --> 02:02:49.500]  Это одна четвертая
[02:02:49.500 --> 02:02:51.500]  вероятность допустить ошибку.
[02:02:51.500 --> 02:02:53.500]  А Y вообще одна вторая.
[02:02:53.500 --> 02:02:55.500]  Жесть.
[02:02:55.500 --> 02:02:57.500]  Фактические ошибки.
[02:02:57.500 --> 02:02:59.500]  Это супер.
[02:02:59.500 --> 02:03:01.500]  Они, конечно, так и работают
[02:03:01.500 --> 02:03:03.500]  в нашем мире.
[02:03:03.500 --> 02:03:05.500]  И журналист X
[02:03:05.500 --> 02:03:07.500]  пишет в два раза больше статей.
[02:03:07.500 --> 02:03:09.500]  То есть вероятность того,
[02:03:09.500 --> 02:03:11.500]  что статья написана журналистом X
[02:03:13.500 --> 02:03:15.500]  в два раза больше,
[02:03:15.500 --> 02:03:17.500]  чем журналистом Y.
[02:03:19.500 --> 02:03:21.500]  Как бы этого знать, что это
[02:03:21.500 --> 02:03:23.500]  две третьих?
[02:03:23.500 --> 02:03:25.500]  Два раза две третьих.
[02:03:25.500 --> 02:03:27.500]  У нас сейчас кто больше кого?
[02:03:29.500 --> 02:03:31.500]  Два раза больше, чем Y.
[02:03:31.500 --> 02:03:33.500]  Две третьи.
[02:03:33.500 --> 02:03:35.500]  Одна треть.
[02:03:35.500 --> 02:03:37.500]  Первый вопрос такой, что нужно найти
[02:03:37.500 --> 02:03:39.500]  вероятность вообще ошибки.
[02:03:39.500 --> 02:03:41.500]  То есть мы читаем статью.
[02:03:41.500 --> 02:03:43.500]  Какова вероятность, что там есть ошибка?
[02:03:43.500 --> 02:03:45.500]  Что?
[02:03:45.500 --> 02:03:47.500]  Да, правда, правда.
[02:03:47.500 --> 02:03:49.500]  Ну, какой формы, наверное, здесь нужно пользоваться?
[02:03:53.500 --> 02:03:55.500]  Тут у нас выбор небольшой.
[02:03:55.500 --> 02:03:57.500]  Нужно найти вероятность
[02:03:57.500 --> 02:03:59.500]  какого-то события.
[02:03:59.500 --> 02:04:01.500]  Ошибка.
[02:04:01.500 --> 02:04:03.500]  Ну да, полной вероятности.
[02:04:05.500 --> 02:04:07.500]  Вероятность ошибки это,
[02:04:07.500 --> 02:04:09.500]  что у нас вероятность
[02:04:09.500 --> 02:04:11.500]  ошибки,
[02:04:11.500 --> 02:04:13.500]  если она совершена
[02:04:15.500 --> 02:04:17.500]  журналистом X на вероятность того,
[02:04:17.500 --> 02:04:19.500]  что статья написана журналистом Y.
[02:04:19.500 --> 02:04:21.500]  Плюс вероятность ошибки,
[02:04:21.500 --> 02:04:23.500]  если написана журналистом Y
[02:04:23.500 --> 02:04:25.500]  на вероятность того,
[02:04:25.500 --> 02:04:27.500]  что
[02:04:27.500 --> 02:04:29.500]  статья написана журналистом Y.
[02:04:29.500 --> 02:04:31.500]  Ну, мы все эти вероятности сдаем.
[02:04:31.500 --> 02:04:33.500]  Это одна четвертая
[02:04:33.500 --> 02:04:35.500]  на две третьих.
[02:04:35.500 --> 02:04:37.500]  Плюс
[02:04:37.500 --> 02:04:39.500]  одна вторая на одну треть.
[02:04:41.500 --> 02:04:43.500]  Ох, это нужно еще.
[02:04:45.500 --> 02:04:47.500]  Ну, получается...
[02:04:47.500 --> 02:04:49.500]  Нет, что я делаю?
[02:04:49.500 --> 02:04:51.500]  Одна вторая
[02:04:51.500 --> 02:04:53.500]  на одну треть, да?
[02:04:57.500 --> 02:04:59.500]  Ну, это две...
[02:04:59.500 --> 02:05:01.500]  Одна треть. Что?
[02:05:01.500 --> 02:05:03.500]  Спасибо.
[02:05:03.500 --> 02:05:05.500]  С этим я уже не справилась.
[02:05:05.500 --> 02:05:07.500]  Ну, хорошо, мы посчитали вероятность ошибки
[02:05:07.500 --> 02:05:09.500]  одна треть, а теперь вопрос
[02:05:09.500 --> 02:05:11.500]  какого вероятность, что статью
[02:05:11.500 --> 02:05:13.500]  писал...
[02:05:13.500 --> 02:05:15.500]  То есть мы с ситуацией
[02:05:15.500 --> 02:05:17.500]  мы обнаружили ошибку, и мы хотим
[02:05:17.500 --> 02:05:19.500]  понять, с какой вероятностью эту статью написал
[02:05:19.500 --> 02:05:21.500]  журналист X.
[02:05:21.500 --> 02:05:23.500]  То есть
[02:05:23.500 --> 02:05:25.500]  у нас нужно найти такую вероятность,
[02:05:25.500 --> 02:05:27.500]  что у нас статью писал
[02:05:27.500 --> 02:05:29.500]  X при условии, что у нас
[02:05:29.500 --> 02:05:31.500]  есть ошибка.
[02:05:31.500 --> 02:05:33.500]  Здесь вторая формула
[02:05:33.500 --> 02:05:35.500]  нужна.
[02:05:35.500 --> 02:05:37.500]  Что мы ему запишем?
[02:05:37.500 --> 02:05:39.500]  Вероятность того,
[02:05:39.500 --> 02:05:41.500]  что вообще статью писал X,
[02:05:41.500 --> 02:05:43.500]  или вероятность того, что у нас есть ошибка.
[02:05:43.500 --> 02:05:45.500]  Заметим, что если у нас
[02:05:45.500 --> 02:05:47.500]  не было первого пункта до этого действия,
[02:05:47.500 --> 02:05:49.500]  нам бы пришлось додуматься
[02:05:49.500 --> 02:05:51.500]  самим.
[02:05:51.500 --> 02:05:53.500]  И вероятность того,
[02:05:53.500 --> 02:05:55.500]  что
[02:05:55.500 --> 02:05:57.500]  вероятность ошибки,
[02:05:57.500 --> 02:05:59.500]  если статью писал
[02:05:59.500 --> 02:06:01.500]  журналист X. Вот это у нас из условия,
[02:06:01.500 --> 02:06:03.500]  а это мы только что посчитали.
[02:06:03.500 --> 02:06:05.500]  Ну, это, собственно, статья
[02:06:05.500 --> 02:06:07.500]  две третьих
[02:06:07.500 --> 02:06:09.500]  умножить на три,
[02:06:09.500 --> 02:06:11.500]  и на вероятность ошибки
[02:06:11.500 --> 02:06:13.500]  что писал их.
[02:06:13.500 --> 02:06:15.500]  Это
[02:06:15.500 --> 02:06:17.500]  одна вторая.
[02:06:19.500 --> 02:06:21.500]  Ну, что, собственно, кажется, логичным,
[02:06:21.500 --> 02:06:23.500]  что у нас X пишет
[02:06:23.500 --> 02:06:25.500]  в два раза больше статей,
[02:06:25.500 --> 02:06:27.500]  но допускает в два раза меньше ошибок.
[02:06:27.500 --> 02:06:29.500]  На самом деле,
[02:06:29.500 --> 02:06:31.500]  все задачи на условной вероятности,
[02:06:31.500 --> 02:06:33.500]  это нужно что-нибудь,
[02:06:33.500 --> 02:06:35.500]  то есть записать эти формулы и понять,
[02:06:35.500 --> 02:06:37.500]  что у нас какие вероятности даны.
[02:06:37.500 --> 02:06:39.500]  Скорее всего,
[02:06:39.500 --> 02:06:41.500]  что-нибудь через другое можно будет
[02:06:41.500 --> 02:06:43.500]  вот
[02:06:47.500 --> 02:06:49.500]  что у нас есть
[02:06:49.500 --> 02:06:51.500]  еще из формул вероятности,
[02:06:51.500 --> 02:06:53.500]  чуть менее очевидного,
[02:06:53.500 --> 02:06:55.500]  это я пока стирать не буду.
[02:06:59.500 --> 02:07:01.500]  Что? Есть мотожидание.
[02:07:01.500 --> 02:07:03.500]  Но я сейчас до мотожидания
[02:07:03.500 --> 02:07:05.500]  чуть попозже иду, я хочу сейчас...
[02:07:05.500 --> 02:07:07.500]  Хотя, нет, ладно, давайте с мотожиданием.
[02:07:07.500 --> 02:07:09.500]  Ну, что такое мотожидание
[02:07:09.500 --> 02:07:11.500]  все помнят.
[02:07:13.500 --> 02:07:15.500]  Формула, которая связана
[02:07:15.500 --> 02:07:17.500]  еще с мотожиданием, это неравенство
[02:07:17.500 --> 02:07:19.500]  Маркова, то есть если
[02:07:19.500 --> 02:07:21.500]  вероятность того, что у нас
[02:07:23.500 --> 02:07:25.500]  больше или равно какого-то альфа,
[02:07:27.500 --> 02:07:29.500]  это меньше или равно,
[02:07:29.500 --> 02:07:31.500]  что равно E
[02:07:31.500 --> 02:07:33.500]  мотожидание F
[02:07:33.500 --> 02:07:35.500]  делить на альфу.
[02:07:35.500 --> 02:07:37.500]  Помните такое, да?
[02:07:37.500 --> 02:07:39.500]  А физический смысл понятен,
[02:07:39.500 --> 02:07:41.500]  что это...
[02:07:41.500 --> 02:07:43.500]  Понятно, что если у нас
[02:07:43.500 --> 02:07:45.500]  мотожидание
[02:07:47.500 --> 02:07:49.500]  больше, чем альфа,
[02:07:49.500 --> 02:07:51.500]  то у нас это
[02:07:51.500 --> 02:07:53.500]  тривиальное неравенство,
[02:07:53.500 --> 02:07:55.500]  потому что у нас
[02:07:55.500 --> 02:07:57.500]  вероятность всегда меньше
[02:07:57.500 --> 02:07:59.500]  или равна единице, а если альфа
[02:07:59.500 --> 02:08:01.500]  больше, чем мотожидание,
[02:08:01.500 --> 02:08:03.500]  то чем больше альфы,
[02:08:03.500 --> 02:08:05.500]  то чем у нас меньше оценка сверху,
[02:08:05.500 --> 02:08:07.500]  это означает, что у нас величина
[02:08:07.500 --> 02:08:09.500]  вряд ли сильно больше, чем
[02:08:09.500 --> 02:08:11.500]  мотожидание.
[02:08:11.500 --> 02:08:13.500]  Вот такой некоторый
[02:08:13.500 --> 02:08:15.500]  физический смысл происходящего.
[02:08:15.500 --> 02:08:17.500]  Задачка,
[02:08:17.500 --> 02:08:19.500]  которая связана с алгоритмом,
[02:08:19.500 --> 02:08:21.500]  не знаю, у вас была или нет,
[02:08:21.500 --> 02:08:23.500]  но она кажется
[02:08:23.500 --> 02:08:25.500]  очень содержательной,
[02:08:25.500 --> 02:08:27.500]  что пусть у нас есть какой-то алгоритм
[02:08:27.500 --> 02:08:29.500]  и у него есть какая-то асимптотика.
[02:08:29.500 --> 02:08:31.500]  В общем, у нас есть какая-то асимптотика,
[02:08:31.500 --> 02:08:33.500]  пусть от n².
[02:08:33.500 --> 02:08:35.500]  У нас есть алгоритм А
[02:08:35.500 --> 02:08:37.500]  и у него есть асимптотика
[02:08:37.500 --> 02:08:39.500]  от n²,
[02:08:39.500 --> 02:08:41.500]  но не всегда.
[02:08:41.500 --> 02:08:43.500]  Это мотожидание такое.
[02:08:43.500 --> 02:08:45.500]  Но мы хотим,
[02:08:45.500 --> 02:08:47.500]  чтобы он работал
[02:08:47.500 --> 02:08:49.500]  за от n²
[02:08:49.500 --> 02:08:51.500]  всегда,
[02:08:51.500 --> 02:08:53.500]  с какой-то константой может быть,
[02:08:53.500 --> 02:08:55.500]  но в целом нам хочется, чтобы
[02:08:55.500 --> 02:08:57.500]  асимптотика была такая,
[02:08:57.500 --> 02:08:59.500]  но мы готовы пожертвовать
[02:08:59.500 --> 02:09:01.500]  качеством работы алгоритма,
[02:09:01.500 --> 02:09:03.500]  и мы готовы, чтобы
[02:09:03.500 --> 02:09:05.500]  в таком проценте случаев
[02:09:05.500 --> 02:09:07.500]  он выдавал неправильный результат.
[02:09:07.500 --> 02:09:09.500]  Можем ли мы такого добиться?
[02:09:11.500 --> 02:09:13.500]  Вообще доказывать,
[02:09:13.500 --> 02:09:15.500]  что мы такого добиться не можем,
[02:09:15.500 --> 02:09:17.500]  наверное, было очень сложно,
[02:09:17.500 --> 02:09:19.500]  поэтому проще привести такой алгоритм,
[02:09:19.500 --> 02:09:21.500]  потому что в данном случае можно.
[02:09:21.500 --> 02:09:23.500]  Что будет делать такой алгоритм,
[02:09:23.500 --> 02:09:25.500]  который мы хотим?
[02:09:25.500 --> 02:09:27.500]  Вот пусть у нас
[02:09:27.500 --> 02:09:29.500]  время работы t
[02:09:29.500 --> 02:09:31.500]  это случайная величина,
[02:09:31.500 --> 02:09:33.500]  какая-то у нас же есть
[02:09:33.500 --> 02:09:35.500]  мотожидание оно такое,
[02:09:35.500 --> 02:09:37.500]  и это случайная величина f,
[02:09:37.500 --> 02:09:39.500]  и мотожидание это
[02:09:39.500 --> 02:09:41.500]  t,
[02:09:41.500 --> 02:09:43.500]  это какое-то t.
[02:09:45.500 --> 02:09:47.500]  И мы запустим
[02:09:47.500 --> 02:09:49.500]  на каком-то входе конкретно
[02:09:49.500 --> 02:09:51.500]  этого алгоритма,
[02:09:51.500 --> 02:09:53.500]  и этот алгоритм будет
[02:09:53.500 --> 02:09:55.500]  делать следующее.
[02:09:55.500 --> 02:09:57.500]  Он будет запускать алгоритм a
[02:09:57.500 --> 02:09:59.500]  и ждать, пока пройдет время.
[02:09:59.500 --> 02:10:01.500]  Сейчас я могу запутаться в количестве нулей.
[02:10:05.500 --> 02:10:07.500]  10 тысяч, да?
[02:10:07.500 --> 02:10:09.500]  Вот такое время.
[02:10:09.500 --> 02:10:11.500]  Ну, константа не изменится.
[02:10:11.500 --> 02:10:13.500]  То есть, конечно, она большая,
[02:10:13.500 --> 02:10:15.500]  но в целом все точку не изменится.
[02:10:17.500 --> 02:10:19.500]  Мы подождем, пока пройдет столько времени.
[02:10:19.500 --> 02:10:21.500]  Если у нас алгоритм завершился,
[02:10:21.500 --> 02:10:23.500]  то здорово, он выдал какой-то ответ,
[02:10:23.500 --> 02:10:25.500]  он сработал правильно,
[02:10:25.500 --> 02:10:27.500]  он же правильный алгоритм на работе исходный.
[02:10:27.500 --> 02:10:29.500]  А если не завершился,
[02:10:29.500 --> 02:10:31.500]  то мы от балды
[02:10:31.500 --> 02:10:33.500]  что-нибудь выдадем.
[02:10:33.500 --> 02:10:35.500]  Он, скорее всего,
[02:10:35.500 --> 02:10:37.500]  выдаст что-то неправильное.
[02:10:39.500 --> 02:10:41.500]  А теперь нам
[02:10:41.500 --> 02:10:43.500]  что нам теперь нужно сказать?
[02:10:43.500 --> 02:10:45.500]  Вот такой алгоритм h' подходит.
[02:10:47.500 --> 02:10:49.500]  Для этого нам нужно показать вот что.
[02:10:49.500 --> 02:10:51.500]  Смотрите, у нас есть
[02:10:51.500 --> 02:10:53.500]  f. Это t.
[02:10:57.500 --> 02:10:59.500]  А теперь мы хотим оценить вероятность того,
[02:10:59.500 --> 02:11:01.500]  что у нас будет неправильный результат.
[02:11:01.500 --> 02:11:03.500]  Когда у нас будет неправильный результат?
[02:11:03.500 --> 02:11:05.500]  Когда алгоритм будет работать
[02:11:05.500 --> 02:11:07.500]  больше, чем вот столько?
[02:11:07.500 --> 02:11:09.500]  Потому что мы выдадем что-то от балды,
[02:11:09.500 --> 02:11:11.500]  и, скорее всего, он будет не правильным.
[02:11:13.500 --> 02:11:15.500]  И мы хотим оценить вероятность того,
[02:11:15.500 --> 02:11:17.500]  что алгоритм работает более, чем вот такое время.
[02:11:17.500 --> 02:11:29.500]  Вот это у нас будет альфа. Альфа, которая здесь. Больше она, чем мы воспользуемся этой оценкой.
[02:11:29.500 --> 02:11:39.500]  f – это t. Делить на t – это, собственно, процент.
[02:11:39.500 --> 02:11:44.500]  То есть вероятность того, что у нас… А это есть вероятность того, что у нас алгоритм работает неправильно.
[02:11:44.500 --> 02:11:49.500]  И она меньше вот такого маленького процента случаев.
[02:11:55.500 --> 02:12:03.500]  Нет, это именно неправильно. То есть смотри, у нас как раз весь прикол в том, что мы можем…
[02:12:03.500 --> 02:12:08.500]  Если у нас есть алгоритм, в котором иногда мы жертвуем временем работы,
[02:12:08.500 --> 02:12:14.500]  то можем перейти к алгоритму, в котором мы иногда жертвуем качеством работы.
[02:12:14.500 --> 02:12:17.500]  То есть смотри, здесь уже у нас… Что этот делает алгоритм?
[02:12:17.500 --> 02:12:25.500]  Когда мы достигаем такого числа шагов, что в целом тоже от n, то он выдаёт случайное значение.
[02:12:25.500 --> 02:12:29.500]  И на мы находим вероятность того, что он выдаёт случайное значение.
[02:12:29.500 --> 02:12:33.500]  То есть вероятность того, что он выдаст что-то неправильное.
[02:12:33.500 --> 02:12:37.500]  Он закончил свою работу в очень определённый срок.
[02:12:37.500 --> 02:12:42.500]  Просто он выдал что-то другое. Не то, что выдал бы нормальный алгоритм.
[02:12:47.500 --> 02:12:51.500]  Вот такое применение вероятности в алгоритмах.
[02:12:51.500 --> 02:12:59.500]  Но в целом, наверное, будет что-то простое про вероятность и про мотожидание.
[02:12:59.500 --> 02:13:02.500]  Не знаю, у нас очень много времени уже ушло.
[02:13:02.500 --> 02:13:07.500]  Уберите какую-нибудь задачку нам от ожидания? Чего не посчитать?
[02:13:07.500 --> 02:13:13.500]  Что? Я вижу только один… Я увидела только одну реакцию, и это было «нет».
[02:13:13.500 --> 02:13:16.500]  Можно чуть больше ответов.
[02:13:18.500 --> 02:13:21.500]  Фурьешечку? Хорошо.
[02:13:21.500 --> 02:13:24.500]  Ну, фурьешечку, не знаю, что там можно, кроме как посчитать.
[02:13:24.500 --> 02:13:30.500]  Но, наверное, нужно напомнить, как работает алгоритм «Фурье».
[02:13:31.500 --> 02:13:34.500]  Сразу на примере, хорошо.
[02:13:34.500 --> 02:13:40.500]  Вот пример какой-нибудь… Пример многочленов, да, произвели?
[02:13:40.500 --> 02:13:43.500]  X плюс 1.
[02:13:44.500 --> 02:13:49.500]  Так вы хотите пойти спать или нет, я не поняла, как сами себя противоречите.
[02:13:49.500 --> 02:13:54.500]  Вот это у нас A, а вот это B.
[02:13:55.500 --> 02:13:58.500]  Да.
[02:14:11.500 --> 02:14:14.500]  Такая инсайд.
[02:14:14.500 --> 02:14:18.500]  А мотожидание? Мотожидание количества коэффициентов.
[02:14:19.500 --> 02:14:22.500]  Ноль-ноль-ноль.
[02:14:27.500 --> 02:14:30.500]  Бинормально, так ведь не «матан».
[02:14:30.500 --> 02:14:35.500]  Я думала, что все нормально будет, но по идее…
[02:14:35.500 --> 02:14:41.500]  Так, все понимают, что посчитать «Фурье» на возник, а не «ЦН», это точно сложно сделать за час 20,
[02:14:41.500 --> 02:14:47.500]  если возить еще и другие задачи, причем на полусимметра задачи.
[02:14:49.500 --> 02:14:51.500]  Очень долго.
[02:14:51.500 --> 02:14:54.500]  Смотри, как ты его делаешь.
[02:14:54.500 --> 02:14:59.500]  Смотри, у тебя там числа какие-нибудь N-битные, и ты хочешь там их перемножать,
[02:14:59.500 --> 02:15:07.500]  и ты записываешь их, собственно, там многочленов, то есть X, там X равно 10 поставишь потом,
[02:15:07.500 --> 02:15:13.500]  перемножишь их, как многочлены, короче, эти два числа, ну, в общем, и все сделать.
[02:15:14.500 --> 02:15:18.500]  Короче, его не бойтесь.
[02:15:18.500 --> 02:15:22.500]  Постарается, на примере, да, я постараюсь не запутать сама.
[02:15:22.500 --> 02:15:32.500]  Ну, у нас мы запишем векторы этих коэффициентов, получается 1, 1, 0, 1, 0, 1.
[02:15:32.500 --> 02:15:38.500]  Вот, дальше мы подберем омегу, омега, ну, у нас здесь степень не выше второй,
[02:15:38.500 --> 02:15:45.500]  но нам нужно, ну, то есть, у нас длина каждого три, и значит, что у нас N должно быть больше
[02:15:45.500 --> 02:15:52.500]  или равно чем, D равно 3, побольше или равно 7, ну, на N-степень двойки, значит, берем 8.
[02:15:52.500 --> 02:15:58.500]  Вот, мы берем омегу такую, что омега восьмой, короче, восьмую степень из единиц.
[02:16:02.500 --> 02:16:04.500]  Ну, собственно, считаем.
[02:16:04.500 --> 02:16:15.500]  Нам нужно посчитать сначала от A, потом от B, ну, давайте от A посчитаем, что у нас от A и омега.
[02:16:15.500 --> 02:16:22.500]  Мы разделим на A0, это что? Это 1.
[02:16:22.500 --> 02:16:40.500]  Сейчас, 4, да, хорошо, это на самом деле имеет смысл, давайте будет четвертый.
[02:16:40.500 --> 02:16:47.500]  На самом деле это не так уж важно, потому что когда мы заметим, что у нас константа, мы можем сразу выдать,
[02:16:47.500 --> 02:16:54.500]  то есть, мы в какой-то момент заметим, что у нас здесь константа, и у нас мы сразу сможем выдавать ответ.
[02:16:54.500 --> 02:16:58.500]  То есть, мы же не машины, мы можем перестать рекурсивно вызывать.
[02:16:58.500 --> 02:17:01.500]  Но вообще, да, ты прав.
[02:17:01.500 --> 02:17:09.500]  Хорошо, и 1, это тоже 1. Вот, так как мы будем вызывать Fourier сразу от, ну, и от этого, и от этого,
[02:17:09.500 --> 02:17:14.500]  они у нас одинаковые, то можем только один раз посчитать.
[02:17:14.500 --> 02:17:22.500]  Что дальше мы считаем? Мы считаем от A0 и омега в квадрате.
[02:17:22.500 --> 02:17:31.500]  Ну, у нас снова здесь, ну, снова будет здесь 1, а здесь будет 0.
[02:17:31.500 --> 02:17:39.500]  A0 это, пусть будет 0, 0, это 1, а A0, 1, это ну, 0.
[02:17:39.500 --> 02:17:48.500]  Омега в квадрате, ну, и так далее. На самом деле здесь у нас, так как константы, то мы можем дойти до
[02:17:48.500 --> 02:17:57.500]  что-то там, от 1, это будет здесь 1, когда мы будем вызывать, вот от этого у нас будет 1.
[02:18:01.500 --> 02:18:06.500]  Хорошо, давайте, я просто хочу опустить часть шагов, чтобы...
[02:18:06.500 --> 02:18:14.500]  Ну, смотрите, мы же Fourier запускаем рекурсивно, да?
[02:18:14.500 --> 02:18:21.500]  Так, хорошо, давайте уточним, одинаково ли мы быстрое преобразование.
[02:18:21.500 --> 02:18:28.500]  Мне казалось, что одинаковое, но у нас, что мы делаем? Мы берем Fourier-преобразование от...
[02:18:28.500 --> 02:18:32.500]  Мы разделяем на два таких многочлена, правильно?
[02:18:32.500 --> 02:18:35.500]  Ну, у нас при нечетных и нечетных степенях.
[02:18:35.500 --> 02:18:43.500]  Дальше мы вызываем Fourier-преобразование от вот этого многочлена и омега-квадрат, и вот этого многочлена и омега-квадрат.
[02:18:43.500 --> 02:18:50.500]  Проверяем, равно ли то, ну, вот омега, равна ли она единице.
[02:18:50.500 --> 02:18:59.500]  Ну, вот здесь она пока не равна, здесь омега равна корню, ну, это получается минус единица.
[02:18:59.500 --> 02:19:04.500]  На самом деле это и будет.
[02:19:04.500 --> 02:19:13.500]  Вот здесь она равна минус единице, и мы снова разделяем а0 на два многочлена.
[02:19:13.500 --> 02:19:18.500]  И вызываем от каждого из них снова.
[02:19:18.500 --> 02:19:20.500]  Что?
[02:19:20.500 --> 02:19:27.500]  Потому что а0 это 1, и у нас здесь нет х вообще.
[02:19:27.500 --> 02:19:32.500]  Хорошо, мы вызываем теперь от вот этого.
[02:19:32.500 --> 02:19:39.500]  А0, 0 и омега в квадрате, а здесь у нас минус 1, значит 1.
[02:19:39.500 --> 02:19:49.500]  Ну, мы уже достигли вот это наше условие остановки, это единица, мы возвращаем единицу, значит.
[02:19:49.500 --> 02:19:52.500]  Дальше нам нужно посчитать а0, это что?
[02:19:52.500 --> 02:20:03.500]  Это а0, 0, плюс омега, ну, от какого-то омега, то есть нам нужно посчитать от минус 1 и 1.
[02:20:03.500 --> 02:20:14.500]  От омега и плюс омега на а0, 1.
[02:20:14.500 --> 02:20:19.500]  Я вот расписываю, почему это 1, потому что у нас коэффициенты.
[02:20:19.500 --> 02:20:25.500]  Ну, смотри, у нас это коэффициенты при четных степенях, это при нечетных.
[02:20:25.500 --> 02:20:29.500]  Ну, у нас был многочлен, просто у нас здесь степень вообще 1.
[02:20:29.500 --> 02:20:38.500]  И у нас что? У нас вот этот многочлен это а, это а0, плюс х на а1, правда?
[02:20:38.500 --> 02:20:43.500]  Ну, вот подставляем сюда эти два, действительно оно.
[02:20:43.500 --> 02:20:50.500]  Вот здесь, сюда мы, вот мы сейчас вот это, ну, рекурсивно вызвали от вот этого.
[02:20:50.500 --> 02:20:55.500]  Это у нас, ну, типа многочлен константа.
[02:20:55.500 --> 02:21:01.500]  Да, ну, то есть мы взяли многочлен а0 и снова берем от него а0 и а1.
[02:21:01.500 --> 02:21:03.500]  Поэтому такие индексы.
[02:21:03.500 --> 02:21:08.500]  Вот, но это у нас константы, поэтому при нечетных степенях у нас ну, 0.
[02:21:08.500 --> 02:21:13.500]  Вот здесь я расписываю, что мы должны дать на выход, на выходе из этого алгоритма.
[02:21:13.500 --> 02:21:17.500]  Вот, мы вот это считать, смотрите, мы вот это считать не будем.
[02:21:17.500 --> 02:21:25.500]  То есть мы не будем вызывать а0,1, потому что у нас, ну, коэффициент все равно будет 0.
[02:21:25.500 --> 02:21:27.500]  Вот, нам неважно, чему он равен.
[02:21:27.500 --> 02:21:34.500]  Поэтому измеряется и получается а0 от минус 1.
[02:21:34.500 --> 02:21:35.500]  Ну, почему минус 1?
[02:21:35.500 --> 02:21:41.500]  Потому что у нас вот это омега штрих, мы должны получить от омеги штрих и от омеги в квадрате.
[02:21:41.500 --> 02:21:46.500]  Ну, от 1 потом омега штрих, она же омега в квадрате, потому что стыклично.
[02:21:46.500 --> 02:21:49.500]  Вот, это минус 1, а это 1.
[02:21:49.500 --> 02:21:53.500]  Поэтому должны дойти от минус 1 и 1.
[02:21:56.500 --> 02:21:58.500]  Правда?
[02:21:59.500 --> 02:22:00.500]  Что?
[02:22:01.500 --> 02:22:06.500]  Мы должны вернуть, ну, что делает быстрое преобразование в фурье?
[02:22:06.500 --> 02:22:14.500]  Оно находит значение многочлена в n точках, которые являются корнями из единицы.
[02:22:14.500 --> 02:22:22.500]  Корнями из единицы вот такой степени, то есть у нас же вот как-то они распределены равномерно.
[02:22:22.500 --> 02:22:26.500]  И здесь у нас корень дан вот такой.
[02:22:26.500 --> 02:22:31.500]  Вот у нас всего две степени.
[02:22:31.500 --> 02:22:36.500]  Это вот та омега, которую мы подали, и омега в квадрате.
[02:22:36.500 --> 02:22:38.500]  Это будет собственно уже единица.
[02:22:38.500 --> 02:22:40.500]  Ну и все, мы пришли в единицу.
[02:22:40.500 --> 02:22:46.500]  Вот, если изначально мы вызвали алгоритм от четвертой степени единицы, это и.
[02:22:46.500 --> 02:22:54.500]  И поэтому мы должны найти значение исходного многочлена от i, от минус 1, от минус i и от единицы.
[02:22:54.500 --> 02:22:58.500]  Но мы вызываем рекурсивно от, типа, степени поменьше.
[02:22:58.500 --> 02:23:02.500]  Вот, мы нашли от степени поменьше, это минус 1, 1.
[02:23:02.500 --> 02:23:08.500]  Вот, мы, значит, должны найти а0 от минус единицы и а0 от единицы.
[02:23:08.500 --> 02:23:14.500]  Так, ну, мы здесь, мы а0, 0 от единицы вызвали.
[02:23:14.500 --> 02:23:21.500]  Это единица просто потому что, ну, когда у нас омега равна единице, мы сразу говорим ответ.
[02:23:21.500 --> 02:23:23.500]  То есть мы считаем лоб.
[02:23:23.500 --> 02:23:27.500]  Это единица, значит, равно единицы.
[02:23:27.500 --> 02:23:29.500]  Так, это случай разобрали.
[02:23:29.500 --> 02:23:33.500]  Дальше а0, 0 от минус единицы.
[02:23:33.500 --> 02:23:37.500]  Фух, ну, что мы здесь делаем?
[02:23:37.500 --> 02:23:43.500]  Мы здесь вызываем, а, от омега в квадрате.
[02:23:43.500 --> 02:23:45.500]  Почему я никто не поправил?
[02:23:45.500 --> 02:23:47.500]  От омега в квадрате.
[02:23:47.500 --> 02:23:51.500]  А омега в квадрате это у нас всегда единица.
[02:23:51.500 --> 02:23:55.500]  Поэтому один раз посчитали и хватит с нас.
[02:23:59.500 --> 02:24:05.500]  У нас же в чем прикол в том, что мы повышаем каждый раз степень, пока не дойдем до единицы.
[02:24:05.500 --> 02:24:09.500]  Ну, от омега в квадрате это единица, мы уже посчитали это равно единицы.
[02:24:09.500 --> 02:24:11.500]  Хорошо.
[02:24:11.500 --> 02:24:15.500]  Я могу стереть это, чтобы здесь написать шаг.
[02:24:15.500 --> 02:24:19.500]  Смотрите, мы посчитали для а0.
[02:24:19.500 --> 02:24:21.500]  Теперь нам нужно посчитать для а1.
[02:24:21.500 --> 02:24:25.500]  Но смотрите, у нас а1 и а0, они как многочлены равны.
[02:24:25.500 --> 02:24:31.500]  Да, то есть нам не нужно считать второй раз, мы можем воспользоваться теми же самыми результатами.
[02:24:31.500 --> 02:24:35.500]  Ну, а что нам нужно в итоге посчитать?
[02:24:35.500 --> 02:24:41.500]  Вот здесь под чертой будет то, что нам должен дать наш исходный вызов в пулье преобразования.
[02:24:41.500 --> 02:24:47.500]  Он должен дать, вот здесь показаны, я показала уже, корни из единиц в четвертой степени.
[02:24:47.500 --> 02:24:51.500]  Это 1, минус 1 и минус и.
[02:24:51.500 --> 02:25:03.500]  И нам нужно найти а от 1, а от 1, а от минус 1.
[02:25:05.500 --> 02:25:11.500]  А от 1, а от и, и а от минус и.
[02:25:13.500 --> 02:25:15.500]  Что это равно?
[02:25:15.500 --> 02:25:19.500]  Ну вот, у нас записано многочлен, разложенный.
[02:25:19.500 --> 02:25:31.500]  И значит, а0 от 1 в квадрате, это 1, плюс 1 умножить на а1 в квадрате.
[02:25:31.500 --> 02:25:37.500]  А1 от 1 в квадрате это 1.
[02:25:37.500 --> 02:25:47.500]  Но мы уже посчитали, а0 от 1 это 1, и вот это тоже 1, значит 2.
[02:25:47.500 --> 02:25:55.500]  Аналогичными рассуждениями, потому что минус 1 в квадрате это тоже 1, у нас здесь тоже 2.
[02:25:55.500 --> 02:26:07.500]  Не 2, потому что, смотрите, у нас а0 от 1, потому что минус 1 в квадрате, минус 1 умножить на а1 снова от 1.
[02:26:07.500 --> 02:26:09.500]  Это 0.
[02:26:09.500 --> 02:26:11.500]  Что здесь?
[02:26:11.500 --> 02:26:21.500]  Это а0 от минус 1, ну и в квадрате, плюс и на а1 от минус 1.
[02:26:21.500 --> 02:26:25.500]  И то, и другое единица, значит это 1 плюс и.
[02:26:25.500 --> 02:26:29.500]  Здесь 1 минус и аналогично.
[02:26:29.500 --> 02:26:31.500]  Достаточно хорошо видно, да?
[02:26:31.500 --> 02:26:33.500]  1 минус и.
[02:26:33.500 --> 02:26:39.500]  Хорошо, мы посчитали, и вот у нас первый ответ.
[02:26:39.500 --> 02:26:49.500]  То есть первый ответ, это у нас последователь значений, собственно, 2, 0, нет, 2.
[02:26:49.500 --> 02:26:59.500]  У нас по кругу так циклично, значит здесь будет и это 1 плюс и, 0, 1 минус и.
[02:26:59.500 --> 02:27:03.500]  Один многочлен посчитали.
[02:27:03.500 --> 02:27:15.500]  Ну смотри, у нас то версие, которое я знаю, это 1 омега, омега в квадрате и так далее, да, омега в n минус 1.
[02:27:15.500 --> 02:27:19.500]  Такой порядок, а он выглядит типа вот так.
[02:27:19.500 --> 02:27:21.500]  Начинается единица, обход по кругу этих корней.
[02:27:21.500 --> 02:27:27.500]  Фух, мы посчитали многочлен а, теперь осталось то же самое с многочленом b.
[02:27:27.500 --> 02:27:37.500]  Ну вот мы вызываем от b и того же самого омега.
[02:27:37.500 --> 02:27:39.500]  Мы разделяем на b0.
[02:27:39.500 --> 02:27:41.500]  Это что?
[02:27:41.500 --> 02:27:45.500]  Это 1 плюс, плюс х.
[02:27:45.500 --> 02:27:47.500]  Понятно почему, да?
[02:27:47.500 --> 02:27:49.500]  Если мы умножим...
[02:27:49.500 --> 02:27:51.500]  Нет, ну что мы умножить не будем?
[02:27:51.500 --> 02:27:55.500]  Мы когда вызываем от х квадрата, это как раз получается х квадрат плюс 1.
[02:27:55.500 --> 02:28:01.500]  А b1 это 0. Нечетных степеней у нас там нет.
[02:28:01.500 --> 02:28:07.500]  Ну вот у нас хотя бы на одну функцию считать меньше, но что мы теперь делаем?
[02:28:07.500 --> 02:28:11.500]  Мы разделяем от b0 и омега в квадрате.
[02:28:11.500 --> 02:28:13.500]  Омега в квадрате это минус 1.
[02:28:13.500 --> 02:28:15.500]  У нас здесь удобно.
[02:28:15.500 --> 02:28:21.500]  Мы снова разделяем на два многочлена b00 и b01.
[02:28:21.500 --> 02:28:25.500]  У нас такой многочлен здесь.
[02:28:25.500 --> 02:28:27.500]  Это наш предыдущий многочлен.
[02:28:27.500 --> 02:28:29.500]  Смотрите как удобно.
[02:28:29.500 --> 02:28:31.500]  Это 1,1.
[02:28:31.500 --> 02:28:33.500]  Так.
[02:28:33.500 --> 02:28:35.500]  Вот такая штука.
[02:28:35.500 --> 02:28:37.500]  Ну смотри, что мы хотим?
[02:28:37.500 --> 02:28:45.500]  Чтобы у нас наш исходный многочлен b был представимый b0 от х.
[02:28:45.500 --> 02:28:51.500]  Это b0 от х квадрат плюс х на b1 от х квадрат.
[02:28:51.500 --> 02:28:57.500]  То есть у нас и то и другое от х квадрат, но одно сдвигается на х, чтобы были нечетные степени.
[02:28:57.500 --> 02:29:01.500]  А теперь смотрим, если мы сюда подставляем х квадрат вместо х.
[02:29:01.500 --> 02:29:03.500]  Допустим здесь другая переменная t.
[02:29:03.500 --> 02:29:09.500]  Если мы вместо t подставляем х квадрат, то как раз получаем наш исходный многочлен.
[02:29:09.500 --> 02:29:11.500]  Ну а здесь ноль.
[02:29:11.500 --> 02:29:15.500]  Неважно что мы получаем, но все равно на ноль умножается.
[02:29:15.500 --> 02:29:17.500]  Вот.
[02:29:17.500 --> 02:29:21.500]  Соответственно b00 и b01 мы нашли.
[02:29:21.500 --> 02:29:23.500]  У нас здесь минус 1, значит вызываем еще раз.
[02:29:23.500 --> 02:29:27.500]  Но они у нас как в прошлом примере равны.
[02:29:27.500 --> 02:29:31.500]  Поэтому мы можем не вызывать это и другое, но один раз что-нибудь посчитать.
[02:29:31.500 --> 02:29:37.500]  Я даже так и напишу b00 от ω в квадрате это единица.
[02:29:37.500 --> 02:29:41.500]  Это тот же набор, что b01 от единиц.
[02:29:41.500 --> 02:29:45.500]  Просто потому что наши многочлены равны.
[02:29:45.500 --> 02:29:47.500]  Но когда у нас единица, мы говорим в лоб ответ.
[02:29:47.500 --> 02:29:49.500]  Это единица.
[02:29:49.500 --> 02:29:51.500]  Хорошо.
[02:29:51.500 --> 02:29:53.500]  Тогда b0.
[02:29:53.500 --> 02:29:57.500]  Здесь мы у нас единица, значит мы должны искать от единиц и минус единицы.
[02:29:57.500 --> 02:29:59.500]  Потому что два корня вот эти.
[02:29:59.500 --> 02:30:03.500]  b от единицы это равно.
[02:30:03.500 --> 02:30:07.500]  Давайте распишу b00 от единиц.
[02:30:07.500 --> 02:30:13.500]  Плюс b01 от единиц.
[02:30:13.500 --> 02:30:15.500]  И то и другое.
[02:30:15.500 --> 02:30:17.500]  Значит это два.
[02:30:17.500 --> 02:30:21.500]  b0 от минус единицы.
[02:30:21.500 --> 02:30:25.500]  То же самое, потому что минус единиц в квадрате это один.
[02:30:25.500 --> 02:30:27.500]  Только здесь минус один это ноль.
[02:30:27.500 --> 02:30:29.500]  Как в предыдущем случае.
[02:30:29.500 --> 02:30:33.500]  Шаг, в который мы попали в рекурсии мы посчитали.
[02:30:33.500 --> 02:30:37.500]  Теперь возвращаемся к b.
[02:30:37.500 --> 02:30:39.500]  Что нам здесь нужно считать?
[02:30:39.500 --> 02:30:43.500]  b1 мы договорились не считать, потому что зачем?
[02:30:43.500 --> 02:30:55.500]  Мы должны здесь посчитать b от 1, b от и, b от минус 1 и b от минус и.
[02:30:57.500 --> 02:31:07.500]  Так b от единицы это b0 от единицы.
[02:31:09.500 --> 02:31:11.500]  Сейчас.
[02:31:13.500 --> 02:31:17.500]  Мне кажется, что мы что-то не досчитали.
[02:31:17.500 --> 02:31:27.500]  А нет, у нас же вот этот алгоритм выдал b0 от единицы и b0 от минус единицы.
[02:31:27.500 --> 02:31:33.500]  Мы запомним, что я сейчас затру, чтобы удобнее было.
[02:31:33.500 --> 02:31:35.500]  И у нас результат такой.
[02:31:35.500 --> 02:31:43.500]  b0 от единицы это 2, а b0 от минус единицы это ноль.
[02:31:43.500 --> 02:31:45.500]  Это вот результат рекурсивного вызова.
[02:31:45.500 --> 02:31:55.500]  Значит b0 от единицы плюс 1 от b, не важно что там ноль, это 2.
[02:31:55.500 --> 02:32:05.500]  А здесь b0 и в квадрате это минус 1, значит это равно b0 от минус одного, ноль.
[02:32:05.500 --> 02:32:13.500]  Минус 1 в квадрате это 1, значит нам здесь нужно b0 от единицы, это 2.
[02:32:13.500 --> 02:32:23.500]  b0 от минус и в квадрате это b0 от минус одного.
[02:32:23.500 --> 02:32:25.500]  Это снова ноль.
[02:32:25.500 --> 02:32:35.500]  Значит выход у нас быстрого преобразования в фурье от b это 2, 0, 2, 0.
[02:32:35.500 --> 02:32:41.500]  Успеваете? Не потеряли еще связь с моими вычислениями.
[02:32:41.500 --> 02:32:45.500]  Пока что нам глобально что нужно делать?
[02:32:45.500 --> 02:32:53.500]  Нам нужно посчитать значение a в точках вот этих корней единицы, потом значение b в этих точках.
[02:32:53.500 --> 02:32:55.500]  Сейчас мы это перемножим.
[02:32:55.500 --> 02:33:01.500]  А потом быстрое преобразование в фурье, только обратное.
[02:33:01.500 --> 02:33:05.500]  Мы посчитали, получили два ответа.
[02:33:05.500 --> 02:33:17.500]  Теперь нужно найти значение c, значение, собственно, многочлены нашего, который будет на выходе в этих точках.
[02:33:17.500 --> 02:33:31.500]  Собственно, c, вектор будет таким.
[02:33:31.500 --> 02:33:37.500]  2 на 2, 4.
[02:33:37.500 --> 02:33:51.500]  Если есть какое-то число x0, если мы хотим найти c от x0, это просто произведение b от x0 на a от x0.
[02:33:51.500 --> 02:34:01.500]  А вот это у нас точки, это единица, там вот это и, вот это минус единица, и тот вектор аналогичный.
[02:34:01.500 --> 02:34:09.500]  Если у нас есть вот эти векторы, мы их просто отчленно перемножаем.
[02:34:09.500 --> 02:34:13.500]  То есть первый элемент с первым и так далее. Понятно почему, да?
[02:34:13.500 --> 02:34:19.500]  Потому что нам нужно в каждой точке произведение значения в этих точках.
[02:34:19.500 --> 02:34:23.500]  Поэтому мы берем вот здесь первый элемент 2, там первый элемент тоже 2, 4.
[02:34:23.500 --> 02:34:31.500]  Тут первый элемент 0, там и не важно что, там третий элемент 0, здесь 2, 0.
[02:34:31.500 --> 02:34:39.500]  У нас все нули просто, кроме первого элемента. Очень удобно.
[02:34:39.500 --> 02:34:51.500]  Потому что у нас быстрое преобразование в Fourier как работает, что у нас если есть вот вектор коэффициентов,
[02:34:51.500 --> 02:35:07.500]  это что? Это 1 делить на n, быстрое преобразование в Fourier от c и от вот этого.
[02:35:07.500 --> 02:35:17.500]  То есть если мы преобразовывали с помощью какого-то порни из единицы омега, то здесь омега минус 1 сопряженный.
[02:35:17.500 --> 02:35:26.500]  Смотрите, у нас здесь омега был, если у нас давайте, чтобы не считать какое-то конкретное значение,
[02:35:26.500 --> 02:35:31.500]  у нас же четвертой степени, у нас корень четвертой степени это был i.
[02:35:31.500 --> 02:35:36.500]  Если ему сопряженный, это минус i. Что это значит?
[02:35:36.500 --> 02:35:43.500]  Это значит, что мы сейчас вызовем вот такое, только сюда будем вставить не i, а минус i.
[02:35:43.500 --> 02:35:51.500]  Ну а потом просто все значение поделим на 4. В нашем случае запишем 4.
[02:35:51.500 --> 02:35:59.500]  А здесь запишем минус i. А сюда c подставляется как?
[02:35:59.500 --> 02:36:09.500]  У нас же какой-то вектор дается на вход, и если там мы подставляли вектор коэффициентов, то здесь мы подставляем вектор значений.
[02:36:09.500 --> 02:36:18.500]  Ну давайте на этой все равно больше одной доски понадобится, поэтому давайте вот здесь и начнем.
[02:36:18.500 --> 02:36:24.500]  c от минус i. Делаем все тоже самое, как будто у нас там есть многочлен.
[02:36:24.500 --> 02:36:33.500]  Мы записываем c0. Это у нас при нулевой степени.
[02:36:33.500 --> 02:36:40.500]  Значит это 4, а c1 это 0. Очень хорошо.
[02:36:40.500 --> 02:36:48.500]  Мы сразу здесь запишем c от… Мы как будто…
[02:36:48.500 --> 02:36:58.500]  Да-да, то есть на самом деле там… Нужно говорить скорее не в терминах многочлена, а вектора, но просто с многочленами понятнее мы куда-то что-то подставляем.
[02:36:58.500 --> 02:37:05.500]  А здесь приходится с вектором, но как будто у нас есть многочлен. Да, действительно так выглядит.
[02:37:05.500 --> 02:37:20.500]  Здесь мы хотим посчитать от единицы, c от… На самом деле от минус i, потому что я где-то здесь записала, у нас порядок.
[02:37:20.500 --> 02:37:25.500]  То есть здесь важно не запутаться, наверное, это действительно важный момент, чтобы обратить на него внимание.
[02:37:25.500 --> 02:37:32.500]  Здесь мы берем омега, какой-то корень, и вот здесь мы брали первый корень в таком обходе.
[02:37:32.500 --> 02:37:40.500]  Потом его квадрат, это минус 1, потом третью степень, и ну и все, третья степень это была как раз сам минус 1.
[02:37:40.500 --> 02:37:47.500]  А здесь мы берем сопряженное, мы пошли в другую сторону, и поэтому у нас сначала берем минус i.
[02:37:47.500 --> 02:38:01.500]  Мы в таком порядке будем, у нас минус i, потом минус i в квадрате, это минус 1, да, и i.
[02:38:01.500 --> 02:38:11.500]  Вот, но для начала мы вызовем рекурсивно от c0, c0 и омега в квадрате это минус 1.
[02:38:11.500 --> 02:38:21.500]  Хорошо, c0,0 это все еще 4 и c0,1 это 0, потому что у нас константа просто.
[02:38:21.500 --> 02:38:28.500]  И мы хотим посчитать c0,0 в точке минус 1, с точки 1 и минус 1.
[02:38:28.500 --> 02:38:33.500]  0,1, минус 1. Чем это равно?
[02:38:33.500 --> 02:38:41.500]  Ну, мы вызываем от c0,0 и 1, потому что минус 1 в квадрате это 1.
[02:38:41.500 --> 02:38:47.500]  Здесь мы видим 1 и сразу говорим, чему у нас равен этот многочлен в точке 1.
[02:38:47.500 --> 02:38:52.500]  В точке 1 у нас вообще от x не зависит, поэтому здесь равно 4.
[02:38:52.500 --> 02:38:57.500]  Вот это в точке 1 равно 4. Здесь мы что записываем?
[02:38:57.500 --> 02:39:11.500]  c0,0 от 1, плюс, конечно, 1 умножить на c0,1, это 0.
[02:39:11.500 --> 02:39:17.500]  Вот это равно 4.
[02:39:17.500 --> 02:39:23.500]  И это равно тоже 4, потому что здесь мы тоже вызываем c0,0 от 1,
[02:39:23.500 --> 02:39:27.500]  минус 1 в квадрате. Это тоже 4.
[02:39:27.500 --> 02:39:32.500]  Хорошо, теперь мы возвращаемся на шаг назад.
[02:39:32.500 --> 02:39:45.500]  И здесь записываем, что у нас c0 от 1, плюс 1 на c1.
[02:39:45.500 --> 02:39:55.500]  Ну, не важно, c1 равно 0, это будет вот это 0, а вот это 4.
[02:39:55.500 --> 02:39:58.500]  Хорошо, но мы дальше вот это писать не будем.
[02:39:58.500 --> 02:40:01.500]  И минусы в квадрате это минус 1.
[02:40:01.500 --> 02:40:04.500]  Значит, мы смотрим, чему равен c0 от минус 1.
[02:40:04.500 --> 02:40:14.500]  Это тоже 4. У нас просто будет все 4, потому что у нас либо c0 от 1, либо c0 от минус 1 будет.
[02:40:14.500 --> 02:40:24.500]  Красота. Что? В смысле, закрой.
[02:40:24.500 --> 02:40:28.500]  Вообще-то нет. Смотри, у нас же это будут...
[02:40:28.500 --> 02:40:31.500]  Смотри, мы сейчас то, что вернем, вот это сейчас мы возвращаем.
[02:40:31.500 --> 02:40:37.500]  Это на самом деле, мы сейчас вернем вектор 4,4,4,4.
[02:40:37.500 --> 02:40:42.500]  Это значит, что произведение будет...
[02:40:42.500 --> 02:40:49.500]  Сейчас, подожди.
[02:40:49.500 --> 02:40:58.500]  И еще на 1,4. Это 1,1,1,1.
[02:40:58.500 --> 02:41:01.500]  А, да, да, все хорошо. Ну, да.
[02:41:01.500 --> 02:41:05.500]  Ну, сократим потом. Так-то здесь сокращать не надо, потому что это коэффициенты у нас.
[02:41:05.500 --> 02:41:07.500]  Многочлен получится другой.
[02:41:07.500 --> 02:41:10.500]  Ну, да, все хорошо. У нас получился многочлен.
[02:41:10.500 --> 02:41:14.500]  x кубе плюс x в квадрате плюс x плюс 1.
[02:41:14.500 --> 02:41:19.500]  Фух, сошлось реальностью.
[02:41:19.500 --> 02:41:24.500]  Так, что-то смог не потеряться по дороге?
[02:41:37.500 --> 02:41:39.500]  Сейчас.
[02:41:40.500 --> 02:41:47.500]  Я прошу прощения, здесь, на самом деле, банальная путаница в индексах.
[02:41:47.500 --> 02:41:51.500]  На самом деле, сейчас, если я могу где-нибудь записать коротко, что произошло,
[02:41:51.500 --> 02:41:57.500]  без выкладок, потому что здесь я записывала так и считала, что мы...
[02:41:57.500 --> 02:42:06.500]  То есть, наверное, можно повторить в плане, что мы делаем.
[02:42:06.500 --> 02:42:14.500]  Да, понятно, что без подсчета. Подсчет был, чтобы понять, что мы не лажу делаем.
[02:42:14.500 --> 02:42:22.500]  У нас есть два многочлена, и мы вызываем этот алгоритм от A.
[02:42:22.500 --> 02:42:27.500]  Мы выбрали такой аметр, что это I.
[02:42:27.500 --> 02:42:33.500]  Потом, когда мы это считали, мы разложили на A0.
[02:42:33.500 --> 02:42:43.500]  Первый пункт. Мы разложили на A0, и это у нас было 1, и A1 равно 1.
[02:42:43.500 --> 02:42:53.500]  Дальше мы посчитали, мы вызвали этот же алгоритм от A0 и в квадрате, минус 1.
[02:42:53.500 --> 02:42:57.500]  На самом деле, и одновременно с этим мы посчитали...
[02:42:57.500 --> 02:43:01.500]  Вообще-то, по алгоритму должны сначала от этого, а потом от этого.
[02:43:01.500 --> 02:43:04.500]  Но у нас они равны. Мы один раз посчитали.
[02:43:04.500 --> 02:43:13.500]  Что-то там, чтобы это посчитать, мы вызвали рекурсивно.
[02:43:14.500 --> 02:43:20.500]  Мы разложили A0 на A00 и A01.
[02:43:20.500 --> 02:43:27.500]  A00 от минус 1 в квадрате это 1.
[02:43:27.500 --> 02:43:35.500]  Здесь мы сразу вышли, потому что, когда мы видим, что ω равно 1, мы сразу говорим ответ.
[02:43:35.500 --> 02:43:45.500]  От A01 равно 0 мы не вызывали, потому что зачем у нас все равно константный 0?
[02:43:45.500 --> 02:43:54.500]  Нам нужно понять значение функций в каких-то точках, а мы заранее знаем значение этой функции в каких-то точках.
[02:43:54.500 --> 02:43:58.500]  На самом деле, от константы мы тоже можем не вызывать теоретически.
[02:43:58.500 --> 02:44:02.500]  Но у нас тут почти сразу всегда получается констант, поэтому ладно.
[02:44:02.500 --> 02:44:06.500]  Мы получили значение вот это. Что мы получили?
[02:44:06.500 --> 02:44:14.500]  Получили A0 от минус такой вектор.
[02:44:14.500 --> 02:44:17.500]  Я буду записывать вектор, чтобы не путать порядок.
[02:44:17.500 --> 02:44:21.500]  Сейчас мы понятно, что делаем. Мы ищем значения в точках.
[02:44:21.500 --> 02:44:30.500]  А когда мы делаем обратное преобразование в Fourier, то мы делаем тоже как с многочленами, как будто там коэффициенты.
[02:44:30.500 --> 02:44:36.500]  Но на самом деле мы оперируем со значениями, поэтому если мы там попутаем порядок, то у нас потом какой-то другой многочлен получится.
[02:44:36.500 --> 02:44:38.500]  Это не есть хорошо.
[02:44:38.500 --> 02:44:46.500]  Мы получили A0 от единицы и A0 от минус единицы.
[02:44:46.500 --> 02:44:52.500]  Мы это получили, и теперь мы подставили сюда.
[02:44:52.500 --> 02:44:59.500]  И здесь на выходе получили A0 от единицы.
[02:44:59.500 --> 02:45:03.500]  Потом от самого корня, который мы вызывали.
[02:45:03.500 --> 02:45:08.500]  Потом от i в квадрате это минус 1.
[02:45:08.500 --> 02:45:15.500]  И от i в кубе это минус i.
[02:45:15.500 --> 02:45:18.500]  Получили такой вектор. Я не буду записывать то же самое.
[02:45:18.500 --> 02:45:25.500]  Потом мы сделали то же самое для многочлена B.
[02:45:25.500 --> 02:45:30.500]  Здесь то же самое.
[02:45:30.500 --> 02:45:33.500]  Мы посчитали вот такие векторы.
[02:45:33.500 --> 02:45:41.500]  Это был первый шаг, вот это второй шаг.
[02:45:41.500 --> 02:45:45.500]  А на третьем мы просто их перемножили.
[02:45:45.500 --> 02:45:50.500]  Я не знаю, как это перенажают.
[02:45:50.500 --> 02:46:04.500]  С от 1, с от i, с от минус 1, с от минус i.
[02:46:04.500 --> 02:46:09.500]  Вот этот вектор мы перемножили.
[02:46:09.500 --> 02:46:25.500]  Я не хочу все переписывать, но вот такой же для A умножить на для B.
[02:46:25.500 --> 02:46:28.500]  Ну, как лентскалярное произведение.
[02:46:28.500 --> 02:46:31.500]  Это был третий шаг.
[02:46:31.500 --> 02:46:35.500]  Общая идея такова, что мы сначала считаем...
[02:46:35.500 --> 02:46:38.500]  Многочлен можно задавать в двух видах.
[02:46:38.500 --> 02:46:42.500]  Либо мы коэффициенты задаем, либо значения в точках.
[02:46:42.500 --> 02:46:49.500]  То есть если у нас степень D, то нам нужно D плюс одна точка или больше.
[02:46:49.500 --> 02:46:52.500]  Дело в том, что мы переводим в другой вид.
[02:46:52.500 --> 02:46:55.500]  В вид, который по точкам задаем.
[02:46:55.500 --> 02:46:57.500]  А в нем считать многочлен просто.
[02:46:57.500 --> 02:47:00.500]  Мы просто перемножили значения в этих точках.
[02:47:00.500 --> 02:47:04.500]  Потом нам нужно обратно привычный человеку вид.
[02:47:04.500 --> 02:47:15.500]  Поэтому вот мы здесь перемножили, а теперь нам нужно обратное преобразование.
[02:47:15.500 --> 02:47:29.500]  Оно выглядит так, что мы вызываем 1 на n, на c от...
[02:47:29.500 --> 02:47:33.500]  Омега с чертой, сопряженная, короче говоря.
[02:47:33.500 --> 02:47:42.500]  В нашем случае это 1 четвертая на c.
[02:47:42.500 --> 02:47:47.500]  А здесь омега с чертой у нас была минус i.
[02:47:50.500 --> 02:47:53.500]  Для него мы повторяли все то же самое.
[02:47:53.500 --> 02:47:56.500]  Важно, что здесь другой порядок был.
[02:47:56.500 --> 02:48:01.500]  То есть я здесь запишу, что выход был...
[02:48:01.500 --> 02:48:03.500]  В каком порядке должен записываться выход?
[02:48:03.500 --> 02:48:07.500]  Это c от единицы, ну типа нулевая степень.
[02:48:07.500 --> 02:48:11.500]  Вот мы начинаем нулевая степень, потом первая, потом вторая, потом и нулевая.
[02:48:11.500 --> 02:48:19.500]  c от минус i, c от минус единицы и c от i.
[02:48:19.500 --> 02:48:21.500]  Все, мы получили.
[02:48:21.500 --> 02:48:25.500]  Это по своей сути нам же нужно было произведение многочленов.
[02:48:25.500 --> 02:48:31.500]  Это c0, c1, c2 и c3.
[02:48:31.500 --> 02:48:33.500]  Все.
[02:48:33.500 --> 02:48:35.500]  Ой, я что-то зацепила.
[02:48:35.500 --> 02:48:37.500]  Ну, вот такие шаги.
[02:48:37.500 --> 02:48:45.500]  Сейчас, если я в выкладке опустила это сало, более читабельно понятно воспроизведение такое.
[02:48:49.500 --> 02:48:55.500]  Главное не обчитаться, но вот на каких-то примерах степень меньше трех вполне себе.
[02:48:55.500 --> 02:48:57.500]  Норм?
[02:48:57.500 --> 02:49:00.500]  Что, Саня, еще будешь что-нибудь рассказывать?
[02:49:00.500 --> 02:49:03.500]  Я не знаю, мне кажется, уже никто не способен.
[02:49:03.500 --> 02:49:05.500]  23.
[02:49:05.500 --> 02:49:07.500]  Мне в Москву ехать.
[02:49:07.500 --> 02:49:09.500]  Ужас.
[02:49:21.500 --> 02:49:23.500]  Красота.
[02:49:27.500 --> 02:49:29.500]  А теперь непонятно, как ключ сдавать.
[02:49:29.500 --> 02:49:31.500]  В смысле?
[02:49:31.500 --> 02:49:33.500]  Охранник, охранник, все?
