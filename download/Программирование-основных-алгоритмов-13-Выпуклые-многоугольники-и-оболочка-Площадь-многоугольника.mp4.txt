[00:00.000 --> 00:15.760]  Так, ну, давайте начнем тогда. У нас сегодня лекция 13 и будем говорить сегодня с вами про многоугольники.
[00:15.760 --> 00:22.720]  Вообще-то вот, все, что можно сказать о многоугольниках, почти все мы сегодня скажем,
[00:22.720 --> 00:28.720]  остальное скажем через неделю. Наверное, не надо плевать, что такое многоугольник,
[00:28.720 --> 00:34.920]  поэтому у нас первая задача на сегодня — это выпукло из многоугольника.
[00:34.920 --> 00:52.760]  А вот что такое выпукло, наверное, надо определить. И давайте дадим следующее определение — множество
[00:52.760 --> 01:22.240]  точек на плоскости выпукло, если для любых P и Pg из этого множества отрезок от P и до Pg
[01:22.240 --> 01:38.560]  целиком лежит в этом множестве. Ну, самый простой пример выпуклого множества — это одна точка.
[01:38.560 --> 01:47.680]  Чуть более сложный пример — это отрезок. Вот, вы можете рассмотреть любой конечный набор точек,
[01:47.680 --> 01:54.800]  показать, что он не выпуклый. В общем, в случае о плене немного другое — там нужно вводить
[01:54.800 --> 02:00.240]  линейную комбинацию, выпуклую комбинацию и смотреть. Мы не будем этим заниматься,
[02:00.240 --> 02:09.120]  на плоскости нас удовлетворит вот такое вот определение. На это еще можно смотреть
[02:09.120 --> 02:16.360]  подтверждение или упражнение, если вам не доказывали еще нигде в курсе, что это равносильно тому,
[02:16.360 --> 02:33.320]  что множество точек... сейчас не так, неравносильность... давайте для многоугольника
[02:33.320 --> 02:53.240]  сформулируем. Многоугольник выпуклый тогда и только тогда, когда, скажем так, он лежит в одной
[02:53.240 --> 03:00.320]  полуплоскости относительно любой из прямых, проведенной через его сторону, относительно того,
[03:00.320 --> 03:26.640]  что он лежит в одной полуплоскости относительно прямой, содержащей произвольную сторону.
[03:30.320 --> 03:41.720]  Или что еще можно сказать для многоугольника — его выпуклость равносильна тому, что любая
[03:41.720 --> 03:48.240]  его диагональ целиком содержится в многоугольнике. Ну, вроде как нам это не понадобится,
[03:48.240 --> 03:53.480]  поэтому я это не буду выписывать. Оказывается, я его не буду, это будет вам как упражнение,
[03:53.480 --> 04:00.100]  потому что больше на математику, геометрию и все такое. Ну, простой пример не выпуклого
[04:00.100 --> 04:11.040]  многоугольника — это такая вот галочка. Понятное дело, он не выпуклый, у вас найдутся две точки,
[04:11.040 --> 04:17.160]  например, вот эти вот две вершинки его, ну или здесь вот где-нибудь взять можно. Такие,
[04:17.160 --> 04:23.920]  что отрезок не содержится целиком. Или же у вас есть сторона, например, вот эта вот,
[04:23.920 --> 04:30.960]  что если вы проведете прямую, то многоугольник будет по обе стороны от нее располагаться. Или
[04:30.960 --> 04:39.080]  же, что у вас есть диагональ, вот такая вот, что она лежит вне многоугольника. Вот.
[04:39.080 --> 04:53.640]  Ну, простейший пример выпуклого многоугольника — это треугольник любой. Вот. Окей. Теперь мы хотим
[04:53.640 --> 04:57.920]  научиться проявить многоугольник на выпуклость. Зачем нам это нужно? Ну, потому что работать с
[04:57.920 --> 05:03.760]  выпуклыми телами как-то попроще чуть-чуть, чем с неупуклыми. Алгоритм будет следующий.
[05:03.760 --> 05:27.920]  Пусть дан многоугольник P1Pn. Думаю, такого, такой части нам хватит вполне.
[05:33.760 --> 05:42.440]  Вот. И давайте просто проверять для каждой критерии того, что у нас все лежит в одной
[05:42.440 --> 05:47.840]  полуплоскости. Как это можно сделать? Будем рассматривать соседние точки, будто бы проводить
[05:47.840 --> 05:57.720]  через них прямую и смотреть, правда ли, что у нас следующее за ним ребро лежит в так называемой
[05:57.720 --> 06:02.640]  нижней полуплоскости относительно него. Что значит полуплоскость нижняя? Это значит,
[06:02.640 --> 06:09.120]  что если мы рассмотрим вектор направляющий и рассмотрим вектор P2P3, то у нас кратчайший
[06:09.120 --> 06:15.680]  поворот будет от направляющего вектора до P2P3, он будет меньше 90 градусов. Кратчайший угол по
[06:15.680 --> 06:23.400]  часовой стрелке. Ну или против часовой стрелки, если как обычно смотреть, то он будет больше 180
[06:23.400 --> 06:33.640]  градусов. Вот. Окей, как проверять того, что какой-то угол больше, чем 180 градусов? Ну,
[06:33.640 --> 06:38.960]  посмотреть на его синус. Потому что если у вас синус положительный, то он меньше 180 и наоборот.
[06:38.960 --> 06:46.480]  Соответственно, что еще нужно здесь учесть? Учесть нужно то, что можно вычислять не синус угла,
[06:46.480 --> 06:49.580]  а просто векторное, ну, псевдовекторное произведение, которое мы в прошлый раз
[06:49.780 --> 06:52.900]  определили. Поэтому угол есть, на самом деле, очень простой.
[06:52.900 --> 07:09.500]  Да, заметьте, здесь вот меньше, чем 1 плюс 1, ну или меньше, либо равно им нужно будет поставить,
[07:09.500 --> 07:17.260]  потому что у нас будет еще закольцовывание вот здесь вот. Вот, я утверждаю тогда, что если,
[07:17.500 --> 07:27.820]  так сказать, синусы всех вот таких вот углов будут одного знак, то многоугольник выпухлый. Иначе это
[07:27.820 --> 07:36.860]  неверно. Да, естественно, мы работаем только с простыми многоугольниками. Потому что,
[07:36.860 --> 07:46.700]  если у нас есть какие-то самоперещения, то совсем сложно становится дело. Вот. Так, окей. Ну,
[07:46.780 --> 07:54.780]  давайте напишем так, что нам нужно проверять, что все вот эти вот штучки, все векторные произведения
[07:54.780 --> 08:00.860]  будут одного знака, псевдовекторные. Ну, как-то можно делать. Например, просто брать и смотреть,
[08:00.860 --> 08:09.740]  правда ли, что вот эти вот наши штуки будут все время одного знака последовательно. Если они все
[08:09.740 --> 08:15.500]  одного знака, так, так, так, тогда это будет правдой. Иначе у вас есть момент, когда знак поменялся.
[08:15.500 --> 08:30.420]  Поэтому можно делать это следующим образом. И векторное произведение pi, pi плюс один умножить
[08:30.420 --> 08:39.980]  на векторное произведение pi, i плюс один, pi плюс два. Что значит, что они одного знака,
[08:39.980 --> 08:47.300]  что они там все больше нуля. Да, мы здесь можно по-разному пределять правды, что у нас разрешается,
[08:47.300 --> 08:54.740]  например, вот такой вот многоугольник, то есть три точки на одной прямой. В некотором плане вырожденная
[08:54.740 --> 09:00.540]  сторона. Но это не будет играть особой роли, чтобы проверить, если у вас три точки на одной прямой.
[09:00.540 --> 09:07.820]  Ну, здесь можно больше бревна поставить просто-напросто. Что если это верно,
[09:07.820 --> 09:24.460]  точнее давайте не так, если это не верно, то мы делаем return false. Вот. Так, окей. Что
[09:24.460 --> 09:30.180]  здесь нужно сказать? Наверное, здесь нужно сказать, давайте в ноль андексации все-таки,
[09:30.180 --> 09:46.620]  точки. А, ну, сейчас, да, можно сейчас, давайте, это правда, здесь немного некорректно написано.
[09:46.620 --> 09:53.580]  Мы сейчас это будем делать. Просто когда у вас здесь один, у вас не очень приятно
[09:53.580 --> 10:02.940]  смотрится писать. Давайте все-таки п0, здесь p-1 будет у нас. Так,
[10:02.940 --> 10:19.940]  p0, p1, p2, n-1. Так, давайте выписывать вектора p и p-1. Это будет первый вектор от 0 до n, да.
[10:19.940 --> 10:33.660]  p и plus 1, это вот этот вот вектор. Мы смотрим вектор с следующим вектором, то есть p и plus 1,
[10:33.660 --> 10:56.780]  а здесь вектор p и plus 2. И здесь мы смотрим следующий вектор, а здесь p и plus 1, p и plus 2, p и plus 3.
[10:56.780 --> 11:11.940]  Вроде вот так вот. Должно работать. И только здесь меньше, чтобы false вернуть. Да, здесь везде по
[11:11.940 --> 11:24.340]  модуле имеется в виду, да. Здесь везде надо написать %, да, чтобы вернуть false, что он не выпухлый.
[11:24.340 --> 11:31.140]  Если у вас меньше 0, значит у вас в какой-то момент знаки разные. У вас все равно знаки
[11:31.140 --> 11:37.100]  одни и те же будут. Просто они будут... И что? Произведение двух чисел больше 0? Это больше 0.
[11:37.100 --> 11:43.060]  Произведение двух чисел меньше 0? Это больше 0. Здесь именно поэтому так написано, чтобы не
[11:43.060 --> 11:48.460]  выписывать, правда ли, что первый знак был положительный. Если да, то траляля, иначе траляля.
[11:48.460 --> 11:56.540]  Мне немножко лень, я просто напишу такой вот код. Он немножко менее эффективный с точки зрения
[11:56.540 --> 12:05.740]  вычислений, потому что у вас здесь все считается по несколько раз. Ну, банально вы будете считать
[12:05.740 --> 12:11.620]  этот вектор два раза. И вот у вас каждое вектор произведения по два раза посчитается. Жизнь
[12:11.620 --> 12:18.180]  несправедлива. Если у вас закончится этот цикл, то return true, что у вас многоугольник выпухлый.
[12:18.180 --> 12:30.140]  Такой алгоритм. OOTN работает. То есть еще раз, что мы делаем? Мы берем и смотрим следующее,
[12:30.140 --> 12:37.220]  что для каждой пары сторон мы смотрим вектор продолжения одной и следующий. Если все эти
[12:37.220 --> 12:42.700]  повороты будут в одну сторону, значит наш многугольник выпухлый. Значит неправда. Доказательство
[12:42.700 --> 12:47.140]  корректности из того, что у вас в те штуки одного знака, равносильное тому, что у вас для каждой
[12:47.140 --> 12:59.180]  прямой весь многугольник лежит в одной полуплоскости. Вот. Я здесь подпишу, чтобы осталось на доске.
[12:59.180 --> 13:02.620]  В то время работаю.
[13:02.620 --> 13:25.500]  ОТН. Окей. Если у вас в зависимости от того,
[13:25.500 --> 13:29.660]  определяете ли вы это выпухлым или нет в такой кейс. Тут уже зависит от задачи то,
[13:29.660 --> 13:34.260]  что вы хотите. Нули можно обработать отдельно. Если вы встретите в какой-то момент ноль, то все.
[13:34.260 --> 13:40.260]  Типа можно либо сказать, что он не выпухлый, потому что вы так не считаете, либо про скип
[13:40.260 --> 13:46.340]  идёт в сторону, грубо говоря. Тут уже как бы модификация, как вы хотите. Основной ядро алгоритма, вот оно.
[13:46.340 --> 13:58.460]  Окей. Второй сюжет. Это принадлежность точки-многугольнику.
[13:58.460 --> 14:23.340]  У нас будет два случая. Все-таки надо маркер искать, будет новое. Ладно, так принадлежность точки-многугольника.
[14:23.340 --> 14:33.260]  У нас будет два разных случая. Первый будет общий алгоритм, а второй будет алгоритм специально для выпухлых там с определенными пиколами.
[14:33.260 --> 14:43.580]  То есть пункт А. Общий случай. То есть как у вас стоит задача? Вам там какой-то многугольник,
[14:43.580 --> 14:51.340]  быть может выпухлый, быть может не выпухлый. Надо понять, лежит ли точка внутри его или на его границе. Ну или снаружи.
[14:51.340 --> 15:04.340]  Окей, как действовать будем? Здесь будем очень просто на самом деле. Давайте скажем, что первый будет метод такой читерский.
[15:04.340 --> 15:22.340]  Потом мы его доработаем до адекватного. Какой-то классный у вас есть многоугольник, не выпухлый. Вот у вас есть точка.
[15:23.340 --> 15:36.340]  Давайте пустим случайный луч из нее. Утверждается, что если мы пересечем нечетное число раз, то мы объявляем, что точка внутри, иначе точка снаружи.
[15:37.340 --> 15:39.340]  Или здесь.
[15:42.340 --> 15:51.340]  То есть пускаем случайный луч.
[15:51.340 --> 16:16.340]  Если число пересечений со сторонами четно, то то, что снаружи.
[16:16.340 --> 16:33.340]  Ну иначе внутри. Этот метод, конечно, гениален при простоте уникальности, однако у него есть проблема. Проблема заключается в том, что он может попасть в вершину.
[16:33.340 --> 16:52.340]  Ну сейчас я подумаю как-то здесь продемонстрировать. Вот, например, такой луч. Повезло мне так. Пройти даже через две вершины, допустим.
[16:52.340 --> 17:02.340]  Тогда казалось бы, я пересек раз, два. Ну или сторон раз, два, три, четыре. То есть четное количество. То есть будто бы я снаружи, а она внутри нахожусь.
[17:02.340 --> 17:13.340]  Вот здесь есть такой гениальный лайфхак, что если вы убираете случайный луч и попали в какую-то вершину, то пустите другой случайный луч.
[17:13.340 --> 17:28.340]  Чтобы вы два раза подряд попали в вершину, это надо быть не очень везучим человеком. Можно вайл, даже двувайл. Можно двувайл, пока вы попадаете в вершину, перезапускать ваш алгоритм.
[17:28.340 --> 17:36.340]  Вот. Ну утверждается, что вероятность попасть в точку, в вершину очень низкая. Особенно если вы убираете вещественные коэффициенты.
[17:36.340 --> 17:48.340]  Проблема с точностью, поэтому выбираете целые коэффициенты. Ну короче, да. Второй метод. Ну есть два варианта как эту штуку улучшить. Не то, что мы далеко уйдем от этого.
[17:48.340 --> 18:01.340]  А второй вариант такой. Давайте возьмем точку, которая находится на один вправо и на, грубо говоря, бесконечность вверх.
[18:01.340 --> 18:09.340]  Под бесконечность называется самая верхняя точка плюс один. То есть вот такое вот. То есть утверждается, что вы в вершину никогда не попадете.
[18:10.340 --> 18:19.340]  Просто-напросто. В силу того, что у вас угол настолько близок к прямому, что вы не можете попасть в вершину. Вообще никак.
[18:19.340 --> 18:27.340]  Ну все, тогда это не случайный луч и вы победили. В вершину вы никогда не попадете, алгоритм работает.
[18:28.340 --> 18:33.340]  Ну вот смотрите, вот у вас ваш карнатная сетка.
[18:38.340 --> 18:48.340]  Где-то у вас есть ваш многоугольник прекрасный. Выберете вашу точку, сдвигаете на один сюда и почти на бесконечность вверх.
[18:48.340 --> 18:56.340]  Ну типа если у вас все карнаты до 10 в 9 помудрят, то на 1 и 10 в 9 сюда. 10 в 9 плюс 1 вообще возьмите.
[18:56.340 --> 19:03.340]  Вот. То есть утверждается, что у вас на этой прямой не может быть ни одной вершинки, если у вас целочисленный многоугольник.
[19:03.340 --> 19:08.340]  На этом луча. Если многоугольник не целочисленный, это не работает, конечно.
[19:08.340 --> 19:13.340]  Макс поиграет и ты плюс 1.
[19:17.340 --> 19:23.340]  Ну тогда у вас вы находитесь внутри этого тоненького прямоугольника и вы никогда не попадете ни в какую вершину на этой стороне.
[19:23.340 --> 19:27.340]  Ну потому что у вас просто все они ниже будут лежать.
[19:27.340 --> 19:32.340]  Ну это если у вас многоугольник целочисленный, то есть все его вершины в узлах целочисленной сетки находятся.
[19:33.340 --> 19:38.340]  Если у вас это не выполнять, то этот метод не работает.
[19:38.340 --> 19:43.340]  Поэтому его не будем даже с тобой описывать.
[19:46.340 --> 19:49.340]  Давайте теперь нормальный метод.
[19:57.340 --> 20:00.340]  Он касается того, а что им считать пересечением.
[20:01.340 --> 20:04.340]  То есть как понимать, что мы пересекаем какое-то ребро на самом деле.
[20:06.340 --> 20:09.340]  То есть мы сейчас будем разбираться с этим случаем, когда мы в вершину попадаем.
[20:12.340 --> 20:14.340]  А делать следующее.
[20:15.340 --> 20:24.340]  Считаем, что луч пересекает сторону.
[20:24.340 --> 20:26.340]  Тогда и только тогда.
[20:39.340 --> 20:49.340]  Когда одна из этих двух вершин, из концов ребра будет находиться строго ниже луча.
[20:51.340 --> 20:53.340]  Привожу пример.
[20:55.340 --> 20:57.340]  Вот ваша конструкция.
[20:57.340 --> 20:59.340]  Допустим это кусок многоугольника.
[21:02.340 --> 21:05.340]  Тогда мы считаем, что мы пересекаем и это ребро, и это ребро.
[21:07.340 --> 21:09.340]  Получилась магическая шляпа.
[21:09.340 --> 21:14.340]  А в этом случае вы считаете, что вы ноль раз пересекли, потому что у вас все время выше.
[21:15.340 --> 21:18.340]  То есть у вас нет точки, лежащие строго ниже луча.
[21:18.340 --> 21:20.340]  Как это интерпретировать?
[21:20.340 --> 21:22.340]  Интерпретировать можно следующим образом.
[21:22.340 --> 21:30.340]  Чтобы касание сверху, мы взяли и подвинули точечку вверх на епсилон.
[21:30.340 --> 21:32.340]  То есть мы пересекли обе стороны.
[21:32.340 --> 21:38.340]  Эта идея вытекает из того, что у вас в общем случае многоугольники, координаты у них вещественные,
[21:38.340 --> 21:41.340]  поэтому у вас есть точность вычтения с плавающей точкой.
[21:43.340 --> 21:46.340]  И из-за этого будто бы эти епсилон подвигали вверх-вниз.
[21:47.340 --> 22:03.340]  То есть тогда и только тогда, когда одна из вершин при ребре строго ниже луча.
[22:08.340 --> 22:11.340]  Почему я здесь говорю? Потому что у нас есть какой-то верх-низ.
[22:11.340 --> 22:14.340]  В общем случае понятие верх-низ не существует в геометрии.
[22:14.340 --> 22:16.340]  Здесь все просто.
[22:16.340 --> 22:18.340]  Чтобы пускать луч горизонтальный на самом деле.
[22:21.340 --> 22:23.340]  То есть уберете точку, пускаете из нее горизонтальный луч,
[22:23.340 --> 22:25.340]  считаете число пересечений по такому алгоритму,
[22:25.340 --> 22:27.340]  у вас все получается.
[22:30.340 --> 22:33.340]  То есть смотрите, вы для каждой вершины, у которой такой угол,
[22:33.340 --> 22:41.340]  как бы так сказать, то есть вот у вас лучик, что у вас такой вот угол,
[22:41.340 --> 22:45.340]  это значит, что вы лежите целиком в ее полуплоскости, внутри угла,
[22:45.340 --> 22:48.340]  этот вот угран, ну просто угол, да?
[22:51.340 --> 22:53.340]  И это значит, что вы учитываете будто бы только одно пересечение.
[22:53.340 --> 22:56.340]  Ну что логично, потому что вы находитесь внутри этого угла.
[22:56.340 --> 22:58.340]  В некотором плане можно еще считать, что вот этот метод,
[22:58.340 --> 23:01.340]  он про то, что вы находитесь внутри соответствующих углов многоугольника.
[23:08.340 --> 23:10.340]  Вот.
[23:15.340 --> 23:17.340]  А если у вас есть вот такой вот случай, да?
[23:17.340 --> 23:19.340]  Ну вот как вот здесь вот мы рисовали, да?
[23:20.340 --> 23:22.340]  То вы считаете, что оба ребра пересекли?
[23:23.340 --> 23:25.340]  Ну если у вас есть такой вот случай,
[23:25.340 --> 23:28.340]  ну специально для вот таких вот случаев.
[23:28.340 --> 23:32.340]  Здесь считается, что новое пересекли, чтобы сбалансировать вот такие вот шпы.
[23:33.340 --> 23:35.340]  Ну главное то, что у вас все время сохраняется четность.
[23:36.340 --> 23:38.340]  Что вот такие вот выраженные случаи у вас учитываются по два раза,
[23:39.340 --> 23:41.340]  либо два, либо ноль.
[23:41.340 --> 23:44.340]  А вот такие вот случаи, adequately нормальные, учитываются один раз.
[23:46.340 --> 23:48.340]  Собственно из этого и работает правило у вас про четность.
[23:49.340 --> 23:52.340]  То есть вы игнорируете вершинки такого специфичного вида,
[23:52.340 --> 23:54.340]  а вершинки неспецифичного вида краски не игнорируете.
[23:55.340 --> 24:01.980]  Вот. Ну, алгоритм работает за линию, если что. Опять же, вы
[24:01.980 --> 24:06.940]  пробегаете просто форм по всем сторонам и смотрите, правда ли, что у вас это работает.
[24:06.940 --> 24:12.740]  Давайте посмотрим на этом примере для вот такого вот луча. Сколько у нас будет пересечений?
[24:12.740 --> 24:19.620]  Так, здесь я выше, поэтому этим будто бы не пересекаем. И вот здесь мы пересекаем лишь одну
[24:19.620 --> 24:24.740]  сторону, вот эту вот на самом деле. Этого не пересекаем. Поэтому количество нечетно и все
[24:24.740 --> 24:29.620]  сошлось внутри. А, попапа, ну где еще тут можно взять?
[24:37.220 --> 24:44.180]  Ну, что-нибудь такое, да? Здесь вот вы тоже. А, ну нет, у нас горизонтальные лучи, и все. Ну, давайте
[24:44.180 --> 24:52.900]  такой вот луч тоже рассмотрим. Это типа горизонтальный луч. Вот он из точки выходит.
[24:52.900 --> 24:58.060]  Тогда вот здесь тоже будет пересечение лишь одно, а с этим мы и не считаем его.
[24:58.060 --> 25:04.580]  Единственная проблема с тем, что делать, если у нас есть горизонтальные стороны,
[25:04.740 --> 25:10.300]  например, у нас какое-то, нет, закончилось место. Вот здесь вот угольник.
[25:14.300 --> 25:22.780]  Ну, что-нибудь такое, например, да? Ну, буква Г. И вот ваш луч проходит прям целиком через
[25:22.780 --> 25:30.540]  сторону. Как вы думаете, мы считаем, что он пересекает или нет? Согласно нашему определению, нет.
[25:30.540 --> 25:36.580]  Это будто бы да, да? Потому что внутри у нас будто бы нечетное количество сторон пересекается или нет?
[25:36.580 --> 25:46.580]  Сейчас. А, у нас вот она. Вот одна сторона, лишь которую мы пересекаем. Ну да, все, вот мы пересекаем
[25:46.580 --> 25:52.580]  только эту сторону, а эту мы вообще не включаем в рассмотрение. И эту тоже. Поэтому, опять же,
[25:52.580 --> 25:55.780]  согласно определению, если у нас сторона целиком лежит 0, чем ее игнорируем?
[25:55.780 --> 26:09.180]  Вот. Как-то так. Так, окей, пункт Б.
[26:20.180 --> 26:21.540]  Выпуклый многоугольник.
[26:21.540 --> 26:38.020]  И множество запросов. Что здесь подрывается под множеством запросов? То, что у вас многоугольник
[26:38.020 --> 26:43.980]  один, а дальше к нему поступает несколько точек. И для этих нескольких точек нужно определить,
[26:43.980 --> 26:51.260]  лежат ли они внутри или снаружи. При этом желательно, конечно, для одной точки быстрее,
[26:51.260 --> 26:54.860]  чем за линию считать. Вот здесь важна выпуклость. Давайте посмотрим вообще,
[26:54.860 --> 26:58.500]  как красиво устроены выпуклые многоугольники на самом деле.
[26:58.500 --> 27:15.780]  Такой прикольный многоугольник возьмем, да. Шаг первый. То есть у нас будет две стадии.
[27:15.780 --> 27:35.420]  Предподсчет и ответ на запрос. Давайте обозначим, что там P1, P2, Pn. P0 так. Жем в 0 индексации все-таки.
[27:35.420 --> 27:58.100]  Н-1. Шаг первый. Пусть Pi. Точка, самая нижняя точка.
[27:58.100 --> 28:16.820]  Есть в таких несколько, самая левая. Левая из них. То есть вот у нас две самых нижних точки,
[28:16.820 --> 28:24.540]  из них берем эту и объявляем ее. Ну типа это какая-то поитая, да. Делаем циклический разворот
[28:24.540 --> 28:31.460]  нашего массива точек так, чтобы это стало P0. Так, я их нумерал по часовой стрелке, это плохо.
[28:31.460 --> 28:42.820]  Это грустная история. Давайте их против часов пронумеру. Просто чтобы было чуть удобнее жить.
[28:42.820 --> 28:55.380]  Сейчас, подождите. Да-да-да, меня по часовой устроят. Ну скажем так, я буду хотеть,
[28:55.380 --> 28:59.900]  чтобы по часовой было, чтобы было чуть удобнее расписывать. Потому что вы можете определить,
[28:59.900 --> 29:03.260]  по часовой у вас задан или нет. Если нет, то просто реверснуть массив и будет по часовой.
[29:03.260 --> 29:11.700]  То есть я делаю циклический сдвиг так, чтобы это стало P0. Ну просто вот так вот сдвигаю
[29:11.700 --> 29:32.260]  массив циклический. Вот, то есть после этого шага делаем циклический сдвиг так, чтобы поитая на
[29:32.260 --> 29:58.700]  нулевой месте. То есть теперь это у нас P0, это P1, это P2. Сейчас, подождите, куда сейчас уходим?
[29:59.060 --> 30:11.300]  Ну да, это по часовой. Окей, нет, сейчас. Всё, да, это против часовой. Извините, что внес, ну туда,
[30:11.300 --> 30:20.860]  против часовой, конечно. Ну, 21 век. Кто видел последний раз настенные часы? Кроме тех,
[30:20.860 --> 30:30.380]  что на ЛК висят. Вот, окей. Так, это у нас теперь, теперь у нас всё красиво задано. Почему? В общем,
[30:30.380 --> 30:37.660]  красота. Красота заключается в том, что давайте рассмотрим просто диагональ этого прекрасного,
[30:37.660 --> 30:59.380]  шедеврального чувачка. В плане, да, это, конечно, триангуляция, но мы не для этого их рисуем.
[30:59.380 --> 31:24.540]  Пусть αiT это угол между осью OX и P0PiT. То есть это будет α1, α2 и так далее. Вот я утверждаю,
[31:24.540 --> 31:42.780]  что для угловного угольника верно следующее неравенство. То есть здесь будет αn-1 и оно у нас
[31:42.780 --> 31:50.460]  будет строго меньше, чем P. Ну, изменьшить это 80 градусов строго. Почему это так? Потому что у вас
[31:50.460 --> 31:55.020]  нет точки со следующего угла с 88 градусов. Мы специально выбирали из самых нижних в
[31:55.020 --> 32:00.700]  самое левое, чтобы у нас такого прикола не было, что здесь было строго неравенство. Ну, а 0 может
[32:00.700 --> 32:14.220]  быть, если у вас там типа вот такой вот классный многоугольник. Бесполезный, конечно, пример,
[32:14.220 --> 32:29.180]  допустим. Здесь нам наличие точек на одну прямую не очень помешает. OX, это ось OX. У вас есть
[32:29.180 --> 32:39.180]  система координат, в которой вы живете. O, X, Y. Ну как еще ось OX обозначают? У меня так вроде
[32:39.180 --> 32:46.380]  обозначали. Вот, тогда это вроде очевидно. Если у вас многоугольник выпуклый, то это неправда просто-напросто.
[32:46.380 --> 33:03.820]  Сейчас. У нас так совпало.
[33:09.740 --> 33:22.220]  Ну, здесь в общем случае имеется в виду. А, это да. Ну да, это тоже не очень принципиально,
[33:22.220 --> 33:32.420]  будем честны. Все эти конкретные, все эти частности. И что мы можем дальше делать тогда? Шаг 3. А, ну,
[33:32.420 --> 33:43.900]  предпочет закончился, ответ на запрос. А, кстати, если у вас вот такие вот верные соотношения,
[33:43.900 --> 33:48.740]  из этого следует в частности, что у вас вот какое-то прекрасное неравенство есть.
[33:48.740 --> 34:12.980]  Сейчас. Да, строгие неравенства будут. Косинус альфа 2. Косинус альфа n-1. Строго больше, чем
[34:12.980 --> 34:19.380]  минус 1. То есть вы можете теперь не углы считать. Зачем считать как-то точно углы, если можно считать
[34:19.380 --> 34:39.620]  косинуса. Да. Окей, ответ на запрос. Пусть угол фи. Это будет угол между осью х и сейчас.
[34:39.620 --> 34:59.140]  П0 ку. Ку это точка из запроса. Вот у вас ку. Угол, это будет фи. Тогда бинпоискам мы можем найти вот по
[34:59.140 --> 35:08.020]  массиву. Ну, каким бинпоискам можем искать? Например, важно посчитать косинус этого угла и по массиву
[35:08.020 --> 35:17.860]  косинусов идти. Вот. То есть найдем такой сектор, в котором мы еще лежим. Что такое сектор? Сектор
[35:17.860 --> 35:23.820]  если здесь треугольничек. Это может быть бинпоискам, потому что у нас массив косинусов. Тут убывающий,
[35:23.820 --> 35:42.700]  можете его реверснуть, будет возрастающий. Бинпоискам. Найдем сектор. Окей, нашли бинпоискам
[35:42.700 --> 35:50.540]  сектор. Ну, теперь вам нужно проверить, лежит ли точка в треугольнике или на его границе. Ну,
[35:50.620 --> 35:59.460]  это, я думаю, уже просто проверить, лежит ли точка внутри треугольника. Ну, например, не знаю.
[35:59.460 --> 36:09.660]  Можно провести описанную окружность, посмотреть расстояние. Нет, ты жала же. Самый простой метод,
[36:09.660 --> 36:15.500]  который я знаю, это взять, построить треугольнички и посчитать сумму площадей. Если
[36:15.580 --> 36:24.420]  попадается в площадь исходного треугольника, то вы внутри. Иначе у вас будет избыток. Ну, типа...
[36:24.420 --> 36:34.580]  Да нет, почему? Ну, у вас есть функция площадь многоугольника, которая у нас будет дальше, кстати.
[36:34.580 --> 37:00.780]  Вы должны проверить, что вы лежите внутри треугольника. Ну, окей, это уже на ваше усмотрение,
[37:01.140 --> 37:08.180]  как хотите делаете. Ну, можете проверить, что он лежит внутри всех трех этих полуплоскостей,
[37:08.180 --> 37:21.660]  например. Не знаю. Да, ну, либо углы тут, как хотите. Ну, вообще обычно костюмы сыпьешь,
[37:21.660 --> 37:31.260]  чтобы оркосинусы от них еще не брать. Вот. У меня был сектор дальше за от единицы. Хоть не знаю,
[37:31.260 --> 37:37.420]  за три факториала поперебирайте все такие перестановки. Не знаю, за сколько тут можно
[37:37.420 --> 37:44.100]  проверить, что точка в треугольнике. Короче говоря, это можно делать, конечно, очень сложно.
[37:44.100 --> 37:49.940]  Можно делать площадями, что он лежит в полуплоскостях. Короче говоря, можно куча способов это сделать.
[37:49.940 --> 37:59.220]  Вот. Почитали и победили. Ну, поэтому этот запрос в логарифм будет делаться. Потому что все-таки у вас
[37:59.220 --> 38:05.940]  точка лежит внутри треугольника. Это за от единицы у вас делается. Ну, значит, вы можете брать...
[38:05.940 --> 38:11.740]  То есть, эта вот часть, проверка того, что кул лежит внутри, это у от единицы,
[38:11.740 --> 38:19.660]  и бинпоиск по углу. Это, соответственно, этот логарифм по числу вершин. Поэтому у вас будет
[38:19.660 --> 38:29.020]  О от Н плюс число запросов на лог, итоговое время работы. Это, так сказать, одна из подзадач,
[38:29.020 --> 38:35.380]  прекрасной задачи Decontest, где нужно строить набор оболочек и дальше искать номер слоя.
[38:35.380 --> 38:54.020]  Ну, значит, вы лежите внутри. Все. Ну, либо вы лежите отдельно на границе. Тут есть вместо того,
[38:54.020 --> 39:01.460]  что вы хотите. То есть, как бы здесь, вот про задачу, лежит ли точка внутри многоугольника,
[39:01.460 --> 39:05.100]  можно сказать, что есть точка на границе. Наверное, она лежит внутри все-таки. Ну,
[39:05.100 --> 39:14.740]  принадлежит многоугольнику. Так, окей. У нас времени еще. Не, мы сегодня поздно начали,
[39:14.740 --> 39:25.380]  у нас времени нет на перерыв. Так, площадь многоугольника. Сегодня медленно идем, надо ускориться.
[39:32.020 --> 39:43.020]  Площадь многоугольника. Здесь тоже будет не очевидно, почему это будет работать,
[39:43.020 --> 39:50.620]  я оставлю это без доказательств. У нас будут два варианта. Первый вариант – это такой метод
[39:50.620 --> 40:06.420]  треугольников так называемый. Подержится следующее. Возьмем наш многоугольник, васях координат.
[40:06.420 --> 40:16.180]  И сделаем вот что. Рассмотрим ориентированные площади вот таких вот треугольников,
[40:16.180 --> 40:30.180]  построенных на ребре и точке в начале координатов. Утверждается следующее, что площадь – это будет
[40:30.180 --> 40:48.300]  модуль. Сейчас. Вроде бы здесь 1 и 2. Давай так напишем. От суммы pi от 0 до n-1, площадей треугольника
[40:48.300 --> 40:58.380]  o, pi, pi плюс 1. Здесь давайте напишу s со звездочкой. Сейчас объясню, что это значит.
[40:58.380 --> 41:10.700]  s со звездочкой – это ориентированная площадь. То есть у вас s со звездой. Будем считать,
[41:10.700 --> 41:19.620]  что это 1 и 2 бекторного, ну 50 бекторного произведения. В нашем случае o, pi, pi плюс 1. Здесь
[41:19.620 --> 41:35.860]  будет браться как 1 и 2 от o. Сейчас. На самом деле не важно. В каком порядке брать. Вы все равно берете
[41:35.860 --> 41:46.460]  модуль потом от этой суммы. Вот это метод треугольников. Можно так за линию посчитать площадь. Что?
[41:46.460 --> 42:06.620]  Здесь? Важно. Главное, чтобы в одном порядке все время писали. Можно было бы их помять местами,
[42:06.620 --> 42:11.500]  но тогда везде надо было бы их помять местами. Тут уже как вы хотите. Главное, чтобы здесь берем модуль,
[42:11.500 --> 42:20.500]  в конце концов. Конечно, да. Везде модуль здесь соберется. Нам нужно закольцовываться как-то.
[42:20.500 --> 42:29.980]  Да, если вы будете читать площадь многоугольников, то у вас как будут приколы с тем, что вы можете
[42:29.980 --> 42:35.740]  случайно пропускать по среднюю сторону. Сразу же здесь скажу, что у вас есть классная задача
[42:35.740 --> 42:44.060]  про губку-облочку в контесте, где нужно найти ее самой площади. Там типа N ритуальных колонн,
[42:44.060 --> 42:49.420]  надо построить арену для покемонов, там минимальной площади, бла-бла-бла. Короче,
[42:49.420 --> 42:57.700]  надо построить губку-облочку, это называется. Там есть умные ребята, которые уже умеют это делать.
[42:57.700 --> 43:05.260]  Вот, половина таких спадкается на 20-м тесте. Чем этот тест хорош? Он выглядит примерно вот так,
[43:05.260 --> 43:14.340]  если что. Ну, дизельтирующая губка-облочка у него такая вот. Корднаты этой точки
[43:27.700 --> 43:34.660]  А вот длина вот этого треугольника, так сказать, это один, и по этой стороне будет тоже один.
[43:34.660 --> 43:45.340]  Поэтому вам точности дабла просто не хватит. Ну, дабл просто не умеет такой точности считать.
[43:45.340 --> 43:50.260]  Вы будете брать эту сумму, считать-считать-считать-считать, у него, по-моему,
[43:50.260 --> 43:55.540]  точности он гарантирует, что 15 знаков первых. Вот, а здесь у вас 18 целых знаков. Вот видите,
[43:55.540 --> 44:02.940]  он там умирает. Вот, поэтому считайте площадь целочисленная, а дальше там мучайтесь с выводом.
[44:02.940 --> 44:17.860]  Вот. Все. По-моему, тоже не хватит в контесте. Вам нужно короче езгать IN64T в вашем случае,
[44:17.860 --> 44:24.500]  а потом смотреть. Если он четный, то уйдите просто деленное на 2.0 в этом контесте специально.
[44:24.500 --> 44:31.500]  Вот. Иначе, если вы не делите на 2.0, если у вас число не делится на 2.0, вы делите его на 2.0
[44:31.500 --> 44:37.060]  с остатком и точку 5.0 выводите. Вот, можно доказать, что площадь у вас всегда полуцелая, на самом деле.
[44:37.060 --> 44:41.540]  То есть, что удвоенная площадь целая. Ну, это вроде очевидно. Почему? Потому что у вас,
[44:41.540 --> 44:46.340]  если координаты целые, то у вас удвоенная сумма таких штук тоже целая. Потому что эта штука
[44:46.340 --> 44:54.580]  просто там разность произведений, которая тоже целая. Ну, это так. Лирическое отступление по контесту.
[44:54.580 --> 45:03.300]  Есть второй метод подсчета площади. Он плюс-минус похож. Просто, я не знаю, мне он как-то кажется
[45:03.300 --> 45:19.460]  более прикольным. Однако этого хватит, плюс-минус везде. B это метод трапеции. В чем его смысл?
[45:19.460 --> 45:32.500]  Я позволю себе воспользоваться этим рисунком. Снова будет рассматриваться сумма похожая,
[45:32.500 --> 45:38.700]  только немножко по-другому устроенная. Будут рассматриваться сумма ориентированных площадей
[45:38.700 --> 45:53.780]  таких трапеций. То есть, вы берете каждую сторону, проецируете точки на оси и считаете
[45:53.780 --> 46:13.580]  площадь такого трапеции. Оно не проще, мне просто так кажется красивее. Полу целый. Здесь? Ну, у вас же здесь
[46:13.580 --> 46:18.860]  электронное произведение. У вас тоже будут трапециями, тоже полу целые получатся. У вас целые не получится
[46:18.860 --> 46:26.380]  нигде. Как это считать? Как посчитать площадь этой трапеции? Вспомним, что площадь трапеции это
[46:26.380 --> 46:33.900]  полусумма оснований на высоту. Основание у вас это у, высота это разность х. Внезапно вы поменялись.
[46:33.900 --> 46:49.860]  Давайте так выпишем, что площадь равна модулю суммы от 0 до n-1. Давайте f' ее обозначим.
[46:49.860 --> 47:19.860]  f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f
[47:19.860 --> 47:26.860]  это средняя линия трапеции, ну или полсуммы оснований. Вот как считать вот здесь вот эту штуку?
[47:26.860 --> 47:33.860]  Вот казалось бы, если мы все будем учитывать со знаком плюс, здесь будут приколы. Приколы как бы будут, да.
[47:33.860 --> 47:39.860]  Поэтому давайте мы будем считать, что мы все время смотрим из ПИТ и в ПИП 1 точку.
[47:39.860 --> 47:43.860]  Поэтому у нас некоторые трапеции со знаком плюс, а некоторые со знаком минус будут.
[47:43.860 --> 47:48.860]  Ну и в итоге у вас вот эти вот лишние кусочки, они просто компенсируются трапециями выше них.
[47:51.860 --> 47:55.860]  Умножить на ПИТ точка.
[47:57.860 --> 47:59.860]  Давайте из И плюс 1 вычитать.
[48:02.860 --> 48:03.860]  Все.
[48:03.860 --> 48:11.860]  Можно на Y проецировать? Ну не знаю, но типа мне как-то на X проще, красивее смотреть.
[48:11.860 --> 48:15.860]  Вот. То есть да, можно на любую прямую проецировать.
[48:15.860 --> 48:20.860]  Более того, можно сказать, что на самом деле трапеция это выражен, что треугольник это выражен в случае трапеции.
[48:20.860 --> 48:23.860]  Что вы проецируете все в 0,0 просто.
[48:23.860 --> 48:28.860]  Более того, казалось бы, почему мы берем в треугольниках 0,0? Можешь любую точку выбрать.
[48:28.860 --> 48:31.860]  Ну и это будет правдой на самом деле, для любой точки это верно.
[48:31.860 --> 48:34.860]  И здесь проецируя на любую прямую, это тоже будет верно.
[48:35.860 --> 48:40.860]  Вот просто если вы проецируете на ось X или Y, у вас получаются формулы красивые.
[48:42.860 --> 48:48.860]  Все. Сюжет с треугольниками закончен наконец-то. Я рассчитывал у него потратить минут 25.
[48:49.860 --> 48:50.860]  Ну ладно.
[48:51.860 --> 48:55.860]  А теперь второй глобальный сюжет, о котором мы сегодня говорим, это рубклооболочки.
[49:01.860 --> 49:04.860]  Выпуклые оболочки.
[49:09.860 --> 49:15.860]  Ну так как мы давали определение выпуклости только в 2D, здесь я себе позволю наглость тоже только в 2D дать определение.
[49:16.860 --> 49:32.860]  Определение выпуклой оболочкой множества S под множество из R2.
[49:32.860 --> 49:42.860]  Считаем, что это конечное. В конечном случае набор точек на плоскости берется.
[49:43.860 --> 49:52.860]  Называют выпуклый многоугольник.
[50:02.860 --> 50:27.860]  Минимальной площади такой, что для любого S маленького из S большого, S маленький либо внутри, либо на границе.
[50:33.860 --> 50:41.860]  Обозначается CONF от S.
[50:42.860 --> 50:48.860]  CONF это конвекс выпуклый. По-английски выпуклый оболочек конвекс HAL называется.
[50:49.860 --> 50:51.860]  Сейчас я напишу.
[50:51.860 --> 51:01.860]  Так, конвекс HAL. Вот так вот это пишется дело.
[51:02.860 --> 51:06.860]  Вот. Чем-то нужно?
[51:07.860 --> 51:09.860]  Заказал бы незачем.
[51:10.860 --> 51:13.860]  На самом деле нет, очень много алгоритмов используют всякие выпуклые оболочки.
[51:13.860 --> 51:21.860]  Ну, самое банальное, это если вы помните, я не знаю, достали вы или нет выигры приставок PSP или геймбоя.
[51:22.860 --> 51:25.860]  Короче, F2D игры вот так вот скажем.
[51:26.860 --> 51:28.860]  И там у вас есть, например, стенки.
[51:29.860 --> 51:34.860]  Ну или там какое-нибудь тело, состоящий из точек, вы просто хотите проверить, что вы там бежите и врежетесь в это тело.
[51:35.860 --> 51:38.860]  Зачем хранить тело целиком, если можно хранить просто точки какие-то.
[51:39.860 --> 51:41.860]  И просто строить на них выпуклую оболочку и потом уже все делать.
[51:41.860 --> 51:49.860]  То есть выпуклая оболочка позволяет ограничить область какую-то, которая должна содержать все точки, чего-либо.
[51:50.860 --> 51:53.860]  Как это представить себе на интуитивном уровне?
[51:54.860 --> 51:58.860]  Допустим, у вас вот стоит, ну, самая классическая интерпретация.
[51:59.860 --> 52:01.860]  Допустим, у вас есть гвоздики на плоскости впитые.
[52:02.860 --> 52:04.860]  Вы берете канцелярскую резинку обычную.
[52:04.860 --> 52:06.860]  Вот так вот все помещаете в нее внутрь и отпускаете.
[52:07.860 --> 52:09.860]  У вас резинка как-то связывает эту штуку.
[52:10.860 --> 52:12.860]  И получается контур фигуры образованной резинкой.
[52:13.860 --> 52:14.860]  Вот такой вот.
[52:15.860 --> 52:16.860]  На самом деле.
[52:18.860 --> 52:19.860]  Вот.
[52:22.860 --> 52:23.860]  Окей.
[52:25.860 --> 52:30.860]  Ну или там, не знаю, например, у вас есть, вы там хотите понять, какого размера у вас тут.
[52:30.860 --> 52:33.860]  Вы знаете, там грозового облака, например, вы считаете, что оно выпуклое.
[52:34.860 --> 52:37.860]  Вот там Яндекс.Погода в приложении спрашивает, правда ли, что сейчас идет дождь.
[52:38.860 --> 52:42.860]  Вот там разные люди понатыкали, да, да, да, в разных точках мы считаем, что земля плоская все еще.
[52:43.860 --> 52:44.860]  Вот.
[52:45.860 --> 52:48.860]  И получается, мы можем построить такую выпуклую оболочку, где дождь наверняка идет.
[52:49.860 --> 52:53.860]  Ну потому что мы считаем, наверное, что у нас туча не имеет дырок внутри себя.
[52:54.860 --> 52:56.860]  И нет такой области, где везде сыр.
[52:56.860 --> 52:58.860]  У нас туча не имеет дырок внутри себя.
[52:59.860 --> 53:01.860]  И нет такой области, где везде света, вокруг дождь.
[53:02.860 --> 53:03.860]  Вот.
[53:04.860 --> 53:05.860]  И при этом туча, скорее всего, выпуклый объект все-таки.
[53:06.860 --> 53:07.860]  Мы верим в это.
[53:08.860 --> 53:10.860]  Ну что не может быть туча с каким-то таким вот надломом.
[53:11.860 --> 53:12.860]  Как-то это неестественно немного.
[53:13.860 --> 53:14.860]  Вот.
[53:15.860 --> 53:16.860]  Наша реальность естественная.
[53:17.860 --> 53:18.860]  Ну.
[53:19.860 --> 53:20.860]  Нашей реальностью все естественно.
[53:21.860 --> 53:22.860]  Вот.
[53:22.860 --> 53:24.860]  Ну есть как бы разные задачи связанные с ней.
[53:25.860 --> 53:26.860]  Это ее построение.
[53:27.860 --> 53:29.860]  Это добавление точек в множестве, соответственно, ее перестраивания.
[53:30.860 --> 53:33.860]  Об этом мы говорить не будем в курсе, о динамической выпуклой оболочке.
[53:34.860 --> 53:35.860]  Будем говорить о статической.
[53:36.860 --> 53:37.860]  Допустим, что мы на какой-то момент там насобирали данных.
[53:38.860 --> 53:39.860]  Там тут идет дождь, тут идет дождь, тут идет.
[53:40.860 --> 53:41.860]  Собрали там выпуклую оболочку.
[53:42.860 --> 53:43.860]  Вот.
[53:44.860 --> 53:47.860]  Ну понятно дело, что у вас есть, может быть, наглец, который там стоит по центру и говорит, что на него не капает.
[53:48.860 --> 53:49.860]  Вот.
[53:50.860 --> 53:51.860]  Там не знаю, давайте убьем его обманщиком.
[53:52.860 --> 53:53.860]  Там что-нибудь такое с ним сделаем.
[53:57.860 --> 53:59.860]  Ну то есть, казалось бы, задача очень простая.
[54:00.860 --> 54:02.860]  Она в реальности, конечно, усложняется очень сильно.
[54:03.860 --> 54:04.860]  Вот.
[54:05.860 --> 54:08.860]  Но алгоритмический или геометрический примитив, который стоит за этим, это выпуклая оболочка.
[54:09.860 --> 54:10.860]  Вот.
[54:20.860 --> 54:21.860]  Вот.
[54:22.860 --> 54:23.860]  Как ее строить?
[54:24.860 --> 54:25.860]  Ну, есть два алгоритма.
[54:27.860 --> 54:29.860]  На самом деле гораздо больше, мы будем рассматривать только два.
[54:30.860 --> 54:34.860]  И первый алгоритм – это алгоритм Джарвиса так называемый.
[54:41.860 --> 54:43.860]  Или в простонародье алгоритм заворачивания подарка.
[54:43.860 --> 54:44.860]  Почему он так называется?
[54:45.860 --> 54:47.860]  Потому что он очень похож на то, как вы будете заворачивать плоский подарок.
[54:48.860 --> 54:50.860]  Я не знаю, кому вы будете дарить 2D-подарок, но это похоже на это будет.
[54:51.860 --> 54:52.860]  Вот.
[54:53.860 --> 54:54.860]  А алгоритм следующий.
[54:55.860 --> 54:56.860]  Вот ваш, может, точек.
[54:57.860 --> 55:02.860]  Да, то, что я жуку в первой четверти координатной, это потому, что я так хочу.
[55:03.860 --> 55:04.860]  Вот.
[55:04.860 --> 55:05.860]  Что делают?
[55:06.860 --> 55:07.860]  Шаг первый.
[55:11.860 --> 55:12.860]  Пусть по ноль.
[55:16.860 --> 55:17.860]  Самая нижняя.
[55:21.860 --> 55:25.860]  Из них самая левая.
[55:26.860 --> 55:27.860]  И вот.
[55:27.860 --> 55:32.860]  Из них самая левая точка.
[55:37.860 --> 55:38.860]  Из С.
[55:40.860 --> 55:42.860]  Так, эта точка не существует.
[55:43.860 --> 55:45.860]  Вот и наша П0 прекрасная.
[55:48.860 --> 55:49.860]  Что я делаю дальше?
[55:49.860 --> 55:50.860]  Шаг второй.
[55:53.860 --> 55:54.860]  П1.
[55:55.860 --> 55:59.860]  Такая точка.
[56:03.860 --> 56:04.860]  Из С.
[56:05.860 --> 56:16.860]  Что угол между ОХ и П0 П1 минимален.
[56:18.860 --> 56:20.860]  Минимален имеется в виду абсолютно его значение.
[56:20.860 --> 56:23.860]  То есть рассматриваем просто все лучи до всех точек.
[56:23.860 --> 56:25.860]  За линию находим такую точку.
[56:27.860 --> 56:28.860]  Вот ваша ось ОХ.
[56:29.860 --> 56:32.860]  Вы рассматриваете до всех точек, вот у вас поясняется ваша П1 прекрасная.
[56:33.860 --> 56:34.860]  Вот.
[56:34.860 --> 56:37.860]  Но утверждается, что у вас как-то можно еще написать.
[56:39.860 --> 56:42.860]  Что это, так сказать, отрезок состоящий из двух самых нижних точек.
[56:43.860 --> 56:46.860]  Поэтому они обязательно лежат вокруг оболочки.
[56:46.860 --> 56:47.860]  Как это можно доказать?
[56:48.860 --> 56:52.860]  Как можно доказать, что П0 лежит в оболочке?
[56:53.860 --> 56:58.860]  Давайте просто рассмотрим полуплоскость вот такого вот вида.
[56:59.860 --> 57:03.860]  Извинем ее на ε вдоль этого вектора.
[57:04.860 --> 57:09.860]  Тогда у вас П0 обязательно лежит в оболочке.
[57:10.860 --> 57:11.860]  Вдоль этого вектора.
[57:12.860 --> 57:20.860]  Тогда у вас П0 обязательно должна лежать, потому что она как бы крайняя точка в заданном направлении.
[57:21.860 --> 57:28.860]  То есть если вы будете двигать вашу полуплоскость вдоль этого вектора, то у вас эта точка окажется крайней в этом направлении.
[57:29.860 --> 57:34.860]  И более того, для произвольного направления верно, что крайняя точка в нем должна оказаться в выпуклой оболочке.
[57:35.860 --> 57:36.860]  На самом-то деле.
[57:36.860 --> 57:43.860]  Ну почему это так? Допустим, что у вас в каком-то направлении крайняя точка не лежит на границе выпуклой оболочки.
[57:45.860 --> 57:46.860]  Ну грустно.
[57:48.860 --> 57:52.860]  Допустим, что у вас выпуклая оболочка не содержит вот этой вот точки, она идет как-то вот так вот.
[57:53.860 --> 58:02.860]  Ну тогда у вас очевидно, что если она не крайняя в таком направлении, значит что у вас есть точки, лежащие по обе стороны полуплоскости.
[58:03.860 --> 58:07.860]  А мы с вами писали, что тогда многоугольник не выпуклый, просто-напросто будет.
[58:08.860 --> 58:13.860]  То есть у вас что-либо вы построите многоугольник не выпуклый, либо он у вас не будет содержать все точки.
[58:14.860 --> 58:17.860]  Потому что если у вас многоугольник выпуклый, то у вас все его точки лежат по одной из сторон.
[58:18.860 --> 58:19.860]  Вот.
[58:21.860 --> 58:28.860]  Ну сейчас по этому можно рассмотреть направление автогональное P0P1 и понять, что вот оно будет нужным нам.
[58:29.860 --> 58:33.860]  Поэтому P0P1 обязательно лежит внутри оболочки, ну на границе оболочки.
[58:34.860 --> 58:36.860]  Так, ну ладно, все это база индукции была.
[58:39.860 --> 58:42.860]  Шаг третий и тому подобное они будут строиться следующим образом.
[58:42.860 --> 58:44.860]  Мы берем текущую P и эту точку.
[58:45.860 --> 58:47.860]  То есть допустим, что у нас уже первые и-точки набраны.
[58:49.860 --> 58:50.860]  P и плюс один.
[58:51.860 --> 58:59.860]  Это будет argmin по углу от, сейчас я скажу кого с кем.
[59:00.860 --> 59:03.860]  Так, P2 будет получаться как argmin с таким вектором.
[59:04.860 --> 59:08.860]  Поэтому будет P и минус два P и.
[59:08.860 --> 59:09.860]  P и минус один.
[59:14.860 --> 59:17.860]  S, где S маленькое лежит.
[59:18.860 --> 59:20.860]  Где S маленькое лежит.
[59:21.860 --> 59:22.860]  С.
[59:23.860 --> 59:27.860]  Ну можно сказать без этого множества, ну можно забить на самом деле.
[59:28.860 --> 59:29.860]  Вот так вот будет.
[59:30.860 --> 59:34.860]  Давайте оставим все-таки, что С без P0.
[59:35.860 --> 59:39.860]  P0, Pi, плюс один.
[59:41.860 --> 59:43.860]  Пi-то я просто, потому что у нас уже первые и-точки набраны.
[59:44.860 --> 59:47.860]  Вот такое вот выражение будет математически.
[59:48.860 --> 59:51.860]  То есть как это понимать с точки зрения рисуночка, картиночка?
[59:52.860 --> 59:53.860]  Как найти P2?
[59:54.860 --> 59:58.860]  Смотрим, P2, то есть i равно единичке, это argmin по этому множеству интересному.
[59:59.860 --> 01:00:03.860]  От вектора P0P1, то есть вот он ваш вектор смотрится.
[01:00:05.860 --> 01:00:09.860]  И перебираем из P1 все оставшиеся точки.
[01:00:13.860 --> 01:00:17.860]  И смотрим, до какой из них угол меньше, ну самый минимальный, вот он.
[01:00:19.860 --> 01:00:20.860]  Поэтому это P2.
[01:00:22.860 --> 01:00:25.860]  Дальше вы строите все абсолютно то же самое, вот ваш новый вектор.
[01:00:26.860 --> 01:00:30.860]  С продолжением снова все точки перебираете, у нас получается вот эта вот точка.
[01:00:30.860 --> 01:00:36.860]  И так пока вы не вернетесь в P0, вы утверждаете, что вы рано или поздно это сделаете.
[01:00:37.860 --> 01:00:39.860]  Почему данное множество выпукло?
[01:00:40.860 --> 01:00:43.860]  Ну оно выпукло просто по построению.
[01:00:44.860 --> 01:00:48.860]  Всего того, что вы выбирали минимальный угол все время между продолжением и потенциальной новой стороной,
[01:00:49.860 --> 01:00:50.860]  у вас все лежит в одной полуплоскости.
[01:00:51.860 --> 01:00:52.860]  И так для каждой стороны.
[01:00:53.860 --> 01:00:56.860]  А мы говорили, что для многоугольника это равносильно его выпуклости.
[01:00:56.860 --> 01:00:58.860]  Окей, это сказали, почему выпуклый.
[01:00:59.860 --> 01:01:01.860]  Понятно, почему многоугольник получится.
[01:01:02.860 --> 01:01:04.860]  Потому что вы все время строите отрезки.
[01:01:05.860 --> 01:01:07.860]  Почему у вас получится...
[01:01:08.860 --> 01:01:10.860]  Почему вы все время вернетесь в P0?
[01:01:11.860 --> 01:01:13.860]  Это уже интересный вопрос.
[01:01:14.860 --> 01:01:15.860]  Предлагаю вам над ним подумать.
[01:01:16.860 --> 01:01:17.860]  Рано или поздно это сделаете.
[01:01:18.860 --> 01:01:19.860]  Вот.
[01:01:20.860 --> 01:01:21.860]  Ну типа того, да, например.
[01:01:22.860 --> 01:01:24.860]  Нет, почему вы именно в P0 придете, а не в P1?
[01:01:24.860 --> 01:01:25.860]  Например, это вопрос.
[01:01:26.860 --> 01:01:29.860]  На самом деле ответ здесь плюс-минус еще виден, потому что вы встраиваете точки,
[01:01:30.860 --> 01:01:32.860]  если вы рассматриваете их в полярные углы относительно OX,
[01:01:33.860 --> 01:01:36.860]  вы рассматриваете их ровно до тех пор, пока он у вас все время растет.
[01:01:37.860 --> 01:01:41.860]  Вот как у нас был случай с тем, что мы искали площадь для выпуклого многоугольника,
[01:01:42.860 --> 01:01:44.860]  вот, не площадь, а лежит ли точка внутри выпуклого многоугольника,
[01:01:45.860 --> 01:01:49.860]  вы также можете рассмотреть из P0 вот эти вот углы, которые вы построили.
[01:01:50.860 --> 01:01:51.860]  У вас будут эти порядки возрастания.
[01:01:51.860 --> 01:01:54.860]  И по идее вы должны были бы дойти до 180 градусов,
[01:01:55.860 --> 01:01:57.860]  однако у вас там точек нет, поэтому вы придете в P0.
[01:01:58.860 --> 01:02:00.860]  У вас просто закончатся точки.
[01:02:01.860 --> 01:02:02.860]  Вот.
[01:02:03.860 --> 01:02:04.860]  Окей, дальше что?
[01:02:05.860 --> 01:02:07.860]  Почему он минимальной площади из возможных?
[01:02:08.860 --> 01:02:12.860]  Ну, думаю, это плюс-минус тоже видно по строению,
[01:02:13.860 --> 01:02:17.860]  потому что вы просто-напросто не можете его никак уменьшить еще сильнее.
[01:02:18.860 --> 01:02:19.860]  Вот.
[01:02:20.860 --> 01:02:21.860]  Вот.
[01:02:22.860 --> 01:02:24.860]  Почему это называется заворачиваемым подарком?
[01:02:25.860 --> 01:02:28.860]  Потому что по одной сторону будто бы так вот вы и заворачиваете, в общем-то.
[01:02:29.860 --> 01:02:30.860]  Вот.
[01:02:33.860 --> 01:02:34.860]  Окей.
[01:02:35.860 --> 01:02:36.860]  Да.
[01:02:41.860 --> 01:02:45.860]  Мы берем форум, бежим просто и ищем, у кого угол минимальный.
[01:02:46.860 --> 01:02:48.860]  У кого угол минимальный, тот и победитель.
[01:02:49.860 --> 01:02:50.860]  Да.
[01:02:53.860 --> 01:02:54.860]  И минус один.
[01:02:55.860 --> 01:02:56.860]  Здесь и минус один.
[01:02:58.860 --> 01:02:59.860]  Минус два.
[01:03:03.860 --> 01:03:04.860]  Давайте оценим сложность, да.
[01:03:06.860 --> 01:03:10.860]  Ну, здесь можно оценить, на самом деле, сложность не просто в терминах Ошкия.
[01:03:11.860 --> 01:03:14.860]  Вот такое вот страшное обозначение, если еще помните, из начала семестра.
[01:03:15.860 --> 01:03:16.860]  Тета большая.
[01:03:17.860 --> 01:03:18.860]  Что вы делаете?
[01:03:19.860 --> 01:03:23.860]  Вы, по сути, делаете на каждое вычисление новой точки оболочки n действий.
[01:03:24.860 --> 01:03:27.860]  Поэтому здесь на самом деле действит это n на h.
[01:03:28.860 --> 01:03:29.860]  h это...
[01:03:31.860 --> 01:03:32.860]  Давайте напишем так.
[01:03:32.860 --> 01:03:33.860]  h равно...
[01:03:36.860 --> 01:03:37.860]  Это число точки выпуклой оболочки.
[01:03:38.860 --> 01:03:39.860]  Я пишу алгебридически, потому что это долго писать.
[01:03:41.860 --> 01:03:45.860]  В худшем случае понятно, что у вас множество исходное может быть выпуклым просто-напросто.
[01:03:47.860 --> 01:03:49.860]  Поэтому в худшем случае от n квадрат.
[01:03:52.860 --> 01:04:01.860]  Однако, опять же, если оценка важна будет, если у задачи D, когда будете решать, возьметесь, нормально оценивайте с этим точку.
[01:04:05.860 --> 01:04:07.860]  Это число... это мощность t.
[01:04:10.860 --> 01:04:12.860]  Исходный размер множества точек.
[01:04:16.860 --> 01:04:18.860]  Ну, то есть у вас p0, teta, pn-1 здесь будет.
[01:04:19.860 --> 01:04:20.860]  Ой, фу ты.
[01:04:21.860 --> 01:04:22.860]  Это будет ph-1.
[01:04:24.860 --> 01:04:26.860]  Здесь у вас где-то существует pn-1 внутри.
[01:04:27.860 --> 01:04:29.860]  Ну, или она будет с какой-то из них совпадать, не очень важно.
[01:04:30.860 --> 01:04:35.860]  Важно то, что у вас всего n элементов, а их оболочка и советы с h элементов.
[01:04:37.860 --> 01:04:38.860]  Окей.
[01:04:40.860 --> 01:04:41.860]  Так, ну давайте...
[01:04:41.860 --> 01:04:43.860]  Еще один алгоритм разберем, потому что n квадрат все-таки не очень круто.
[01:04:47.860 --> 01:04:48.860]  Кого?
[01:04:48.860 --> 01:04:49.860]  Точек?
[01:04:49.860 --> 01:04:52.860]  Да вы можете просто поставить булевую пометку, использовали вы ее или нет.
[01:04:52.860 --> 01:04:55.860]  Просто завести массив, типа была ли она использована уже.
[01:04:55.860 --> 01:04:56.860]  И просто их скипать.
[01:04:59.860 --> 01:05:00.860]  Нет, зачем?
[01:05:00.860 --> 01:05:03.860]  Оно рационально придется какие-то хэш-функции там считать. Зачем?
[01:05:03.860 --> 01:05:05.860]  Вы же можете просто завести массив.
[01:05:05.860 --> 01:05:09.860]  В котором будет говорится, что эта вершина уже взята в оболочку.
[01:05:09.860 --> 01:05:11.860]  Все, и лезть в него постоянно.
[01:05:11.860 --> 01:05:13.860]  То есть у вас кое-какого кализни никаких нет.
[01:05:13.860 --> 01:05:14.860]  У вас множество маленькое.
[01:05:16.860 --> 01:05:18.860]  А, пункт B – это алгоритм Грэхама.
[01:05:24.860 --> 01:05:25.860]  Грэхама.
[01:05:28.860 --> 01:05:29.860]  Грэхама.
[01:05:31.860 --> 01:05:32.860]  Грэхама.
[01:05:32.860 --> 01:05:33.860]  Грэхама.
[01:05:36.860 --> 01:05:37.860]  Шаг первый.
[01:05:38.860 --> 01:05:41.860]  Это отсортировать точки по Y, внутри них по X.
[01:05:44.860 --> 01:05:49.860]  Отсортировать точки.
[01:05:51.860 --> 01:05:53.860]  Давайте скажу так, по парам Y, X.
[01:05:55.860 --> 01:05:59.860]  То есть вы можете просто передать ему сравнение по такой вот паре координатов.
[01:06:02.860 --> 01:06:05.860]  То есть здесь мы искали минимум, а здесь мы сортируем сразу.
[01:06:07.860 --> 01:06:08.860]  Что уже?
[01:06:09.860 --> 01:06:10.860]  Вот он.
[01:06:11.860 --> 01:06:12.860]  Логан по времени.
[01:06:18.860 --> 01:06:19.860]  Что?
[01:06:22.860 --> 01:06:23.860]  Это все отлукало.
[01:06:25.860 --> 01:06:27.860]  Вот эти ваши поразрядные сортировки.
[01:06:28.860 --> 01:06:30.860]  Ну да, коронаты целочисленные.
[01:06:32.860 --> 01:06:36.860]  Ну да, раз у нас коронаты все вылежат в N64T,
[01:06:36.860 --> 01:06:40.860]  ну, наверное, можно их сравнивать, будто бы это два Лонг-Лонга и все.
[01:06:41.860 --> 01:06:42.860]  Можно, да, но зачем?
[01:06:43.860 --> 01:06:49.860]  Давайте жить в прекрасном добром мире, где все вещественное и ничего не работает.
[01:06:54.860 --> 01:06:55.860]  Что?
[01:06:56.860 --> 01:06:57.860]  ЛСД.
[01:06:58.860 --> 01:06:59.860]  Я отказываюсь отвечать на такой вопрос.
[01:07:00.860 --> 01:07:01.860]  Пользуюсь 51 статьей Конституции.
[01:07:09.860 --> 01:07:10.860]  Сейчас, зачем по Y их сортировали?
[01:07:11.860 --> 01:07:12.860]  Это лажа полная, нет.
[01:07:13.860 --> 01:07:15.860]  Там не так это делается, я перепутал, sorry.
[01:07:20.860 --> 01:07:23.860]  Можно и так сортировать, тоже будет работать, но я не про это хочу рассказать.
[01:07:24.860 --> 01:07:31.860]  Первый шаг такой, что P0 как в алгоритме Джарвис.
[01:07:42.860 --> 01:07:43.860]  P1 тоже.
[01:07:45.860 --> 01:07:46.860]  Так, кстати, нужна база.
[01:07:47.860 --> 01:07:48.860]  База является как в Джарвисе, то есть у вас что?
[01:07:49.860 --> 01:07:51.860]  P0 так строится и P1 так строится.
[01:07:53.860 --> 01:07:54.860]  Наш P0, P1.
[01:07:59.860 --> 01:08:03.860]  Ну, можно P1 не строить явно, конечно, но построим.
[01:08:04.860 --> 01:08:05.860]  Это все равно немного действует.
[01:08:06.860 --> 01:08:07.860]  Всего лишь линейное.
[01:08:08.860 --> 01:08:09.860]  Шаг второй.
[01:08:09.860 --> 01:08:25.860]  Сортируем точки по углу P0, P1, P0, Pi.
[01:08:30.860 --> 01:08:31.860]  Почему я говорю, что можно было P1 не искать?
[01:08:32.860 --> 01:08:33.860]  Вы бы посортировали их между тогда.
[01:08:34.860 --> 01:08:37.860]  Просто сюда поставил OX вместо P0, P1 и ничего бы не изменилось.
[01:08:40.860 --> 01:08:43.860]  Давайте мы занумируем точки, в каком порядке будем рассматривать.
[01:08:44.860 --> 01:08:51.860]  А, да, в случае равенства, то есть если вы лежите на одной прямой P0, Pi, Pj лежат.
[01:08:52.860 --> 01:08:59.860]  Равенство по возрастанию модуля P0, Pi.
[01:09:01.860 --> 01:09:05.860]  То есть если у вас есть несколько точек на одной прямой с P0,
[01:09:05.860 --> 01:09:20.860]  тогда вы берете сначала эту, потом эту.
[01:09:23.860 --> 01:09:24.860]  Давайте занумируем точки.
[01:09:25.860 --> 01:09:30.860]  То есть это будет первое рассмотрение, это вторая, это третья, это четвертая, пятая, шестая.
[01:09:31.860 --> 01:09:32.860]  Дальше мне будет ли не рассматривать.
[01:09:35.860 --> 01:09:36.860]  Ну окей.
[01:09:38.860 --> 01:09:45.860]  Заведем stack.
[01:09:47.860 --> 01:09:49.860]  Я назову его st.
[01:09:50.860 --> 01:09:51.860]  Вы так не делайте в коде.
[01:09:52.860 --> 01:09:54.860]  Положим туда P0, P1.
[01:09:57.860 --> 01:10:00.860]  То есть stack push P0, push P1.
[01:10:02.860 --> 01:10:03.860]  Называйте нормально.
[01:10:06.860 --> 01:10:11.860]  Если вы скажете, что stack можно буквы f-с называть, это будет очень грустная история.
[01:10:12.860 --> 01:10:13.860]  Окей.
[01:10:14.860 --> 01:10:16.860]  Дальше шаг какой.
[01:10:17.860 --> 01:10:18.860]  Ну кладем.
[01:10:20.860 --> 01:10:21.860]  То есть for.
[01:10:22.860 --> 01:10:24.860]  То есть вы уже сфотировали их.
[01:10:25.860 --> 01:10:26.860]  Ну не знаю.
[01:10:27.860 --> 01:10:29.860]  То есть P0, P1 уже положили.
[01:10:29.860 --> 01:10:38.860]  Вы будете говорить stack.push от P и T.
[01:10:41.860 --> 01:10:47.860]  То есть будто бы вы говорите, ага, эта точка я сразу добавляю себе в оболочку.
[01:10:49.860 --> 01:10:50.860]  Дальше я смотрю.
[01:10:51.860 --> 01:10:53.860]  Смотрю вектор между P0, P1.
[01:10:54.860 --> 01:10:55.860]  Дальше я смотрю.
[01:10:56.860 --> 01:10:58.860]  Смотрю вектор между P0, P1.
[01:10:59.860 --> 01:11:00.860]  P1, P2.
[01:11:05.860 --> 01:11:07.860]  Так, это против часовой стрелки, да? Да.
[01:11:08.860 --> 01:11:17.860]  Если кричащий поворот от этого вектора продолжения до этого вектора против часовой стрелки будет меньше, чем 180, то я ее оставляю в stack.
[01:11:18.860 --> 01:11:21.860]  Иначе буду делать кару небесную.
[01:11:24.860 --> 01:11:27.860]  То есть пока что клад окончен. Сейчас он будет меняться.
[01:11:30.860 --> 01:11:32.860]  Теперь допустим рассмотрим эту точку.
[01:11:35.860 --> 01:11:36.860]  Ну почти по прямому провел.
[01:11:37.860 --> 01:11:38.860]  Вот.
[01:11:39.860 --> 01:11:42.860]  Смотрим угол между P1, P2 и P2, потенциальный P3.
[01:11:45.860 --> 01:11:52.860]  Поворот против часовой стрелки больше 180 градусов от продолжения до вектора.
[01:11:53.860 --> 01:11:56.860]  Значит P2 не лежит в оболочке.
[01:11:58.860 --> 01:12:00.860]  И мы ее будем делать pop из нее.
[01:12:01.860 --> 01:12:02.860]  Ну давайте.
[01:12:03.860 --> 01:12:05.860]  Давайте даже пушить будем просто 4.
[01:12:06.860 --> 01:12:07.860]  Да и все.
[01:12:09.860 --> 01:12:10.860]  Сейчас будет while.
[01:12:11.860 --> 01:12:12.860]  А потом будем туда пушить.
[01:12:14.860 --> 01:12:17.860]  Ну а так скажем следующее, что.
[01:12:23.860 --> 01:12:24.860]  While.
[01:12:29.860 --> 01:12:33.860]  Будем считать, что у нас stack умеет выдавать последнюю и предпоследнюю точку.
[01:12:34.860 --> 01:12:37.860]  Верхний и верхний на один ниже элемента.
[01:12:38.860 --> 01:12:40.860]  То есть есть такая операция, pref top так называемый.
[01:12:41.860 --> 01:12:49.860]  То есть если вот ваш stack, то вот это будет top, а вот это будет pref top.
[01:12:50.860 --> 01:12:52.860]  Будем считать, что у нас stack умеет так делать.
[01:12:53.860 --> 01:12:58.860]  Ну это можно эмулировать тем, что вы делаете pop, делаете top, обратно пушь.
[01:13:01.860 --> 01:13:02.860]  Вот.
[01:13:03.860 --> 01:13:04.860]  While.
[01:13:05.860 --> 01:13:06.860]  Сейчас будет страшно.
[01:13:07.860 --> 01:13:12.860]  Нам нужно будет рассмотреть, что угол меньше 180 градусов, то есть больше 180 градусов.
[01:13:15.860 --> 01:13:18.860]  Вектор будет st, pref top.
[01:13:24.860 --> 01:13:26.860]  st.top.
[01:13:35.860 --> 01:13:36.860]  Это будет первый вектор.
[01:13:40.860 --> 01:13:43.860]  Здесь я воспользуюсь нотацией через точку запятой, потому что здесь все-таки сложно.
[01:13:44.860 --> 01:13:49.860]  То есть это так называемый вектор, последний вектор из сторон в стеке, которые лежат.
[01:13:50.860 --> 01:13:52.860]  В нашем случае это p0, p1.
[01:13:53.860 --> 01:13:54.860]  В первом шаге алгоритма.
[01:13:55.860 --> 01:13:56.860]  Потом мы положили p2 туда и стал p1, p2.
[01:13:57.860 --> 01:14:01.860]  То есть у вас st.top это p2, st.pref.top это p1.
[01:14:02.860 --> 01:14:04.860]  То есть вы смотрите вектор p1, p2.
[01:14:05.860 --> 01:14:12.860]  И st.top запятая pi.
[01:14:13.860 --> 01:14:14.860]  Во, наконец-то мы дошли до pi.
[01:14:17.860 --> 01:14:18.860]  То есть вы рассматриваете два вектора.
[01:14:19.860 --> 01:14:20.860]  Раз, вектор.
[01:14:21.860 --> 01:14:22.860]  Два вектора.
[01:14:23.860 --> 01:14:32.860]  Если их псевдовекторное произведение меньше нуля, то есть у вас происходит то, что...
[01:14:33.860 --> 01:14:34.860]  Как сказать?
[01:14:35.860 --> 01:14:37.860]  То есть у вас происходит вот такой вот поворот.
[01:14:38.860 --> 01:14:43.860]  Вы делаете страшную кару и говорите, что st.top не достоин быть.
[01:14:44.860 --> 01:14:45.860]  Выпукло оболочки.
[01:14:49.860 --> 01:14:51.860]  Что это вектор из двух точек.
[01:14:51.860 --> 01:14:52.860]  У вас эта точка, эта точка.
[01:14:56.860 --> 01:14:57.860]  OK.
[01:14:58.860 --> 01:15:01.860]  То есть while это верно, вы будете выкидывать точки одну за другой.
[01:15:02.860 --> 01:15:07.860]  То есть, например, если бы у вас была бы еще какая-то точка между ними.
[01:15:08.860 --> 01:15:09.860]  Не знаю, какая-нибудь вот такая вот бы.
[01:15:11.860 --> 01:15:12.860]  Сейчас, чтобы была острее.
[01:15:15.860 --> 01:15:16.860]  Ну или где-то вот так вот.
[01:15:17.860 --> 01:15:19.860]  То бы вы построили бы p1, p2, p3.
[01:15:20.860 --> 01:15:21.860]  Потом бы дошли до этой точки.
[01:15:22.860 --> 01:15:23.860]  Выкинули бы эту.
[01:15:24.860 --> 01:15:25.860]  Посмотрели бы, что угол снова плохой.
[01:15:26.860 --> 01:15:28.860]  Выкинули бы эту и только потом бы ее вставили.
[01:15:29.860 --> 01:15:35.860]  И говорите, что st.push от pita.
[01:15:36.860 --> 01:15:37.860]  То есть здесь вот такой вот алгоритм.
[01:15:41.860 --> 01:15:43.860]  То есть смотрите, что у вас происходит в нашем примере конкретном.
[01:15:44.860 --> 01:15:45.860]  Точку мы уберем.
[01:15:47.860 --> 01:15:49.860]  У вас происходит то, что у вас угол больше 180 градусов.
[01:15:50.860 --> 01:15:51.860]  То есть выполняется это условие.
[01:15:53.860 --> 01:15:54.860]  Виноват.
[01:15:56.860 --> 01:15:58.860]  Всегда нужно будет еще вставить условие, что...
[01:16:06.860 --> 01:16:07.860]  Что у вас размер стэка хотя бы два.
[01:16:08.860 --> 01:16:09.860]  Что бы вы могли делать при втопе от него.
[01:16:09.860 --> 01:16:10.860]  Вот.
[01:16:12.860 --> 01:16:13.860]  У вас p2 выкинется из стэка.
[01:16:16.860 --> 01:16:17.860]  Все, ее не было как будто бы, да.
[01:16:18.860 --> 01:16:20.860]  И добавится вот эта вот точка, которую мы рассматривали.
[01:16:27.860 --> 01:16:28.860]  Все, этой точки больше нет с нами.
[01:16:30.860 --> 01:16:31.860]  Мы о ней забыли.
[01:16:33.860 --> 01:16:34.860]  И вот она наша новая p2.
[01:16:34.860 --> 01:16:37.860]  Почему мы здесь сортируем по расстоянию, по такому?
[01:16:38.860 --> 01:16:39.860]  Ну, чтобы этот алгоритм сработал.
[01:16:40.860 --> 01:16:41.860]  Потому что сначала мы найдем эту.
[01:16:46.860 --> 01:16:48.860]  Потом поймем, что здесь все плохо, потому что угол вот такой вот.
[01:16:49.860 --> 01:16:51.860]  Выкинем ее и добавим вот эту сторону в оболочку.
[01:16:53.860 --> 01:16:54.860]  Ну и так далее.
[01:16:55.860 --> 01:16:56.860]  Достроим, достроим, достроим в конце концов.
[01:16:57.860 --> 01:16:58.860]  Строили, строили.
[01:16:59.860 --> 01:17:00.860]  Они наконец построили.
[01:17:00.860 --> 01:17:01.860]  Чему это работает?
[01:17:03.860 --> 01:17:12.860]  Доказывается это по индукции тем, что у вас на каждом шаге перед вайлом в стэке лежит выпукла оболочка текущего рассмотренного множество точек.
[01:17:17.860 --> 01:17:24.860]  То есть, например, когда вы добавили эту точку сюда, утверждается, что у вас внутри стэка лежит выпукла оболочка вот этих вот пяти точек.
[01:17:24.860 --> 01:17:26.860]  Дальше потом у вас происходит добавление этой точки.
[01:17:27.860 --> 01:17:29.860]  Вы такие, ага, все понятно.
[01:17:29.860 --> 01:17:31.860]  Это было полной лажей и выкидываете ее.
[01:17:33.860 --> 01:17:35.860]  Когда добавление, видимо.
[01:17:36.860 --> 01:17:37.860]  Сейчас.
[01:17:37.860 --> 01:17:38.860]  Да, вот это вот.
[01:17:38.860 --> 01:17:40.860]  Когда вот это вот добавили, вы поняли, что это полная лажа.
[01:17:40.860 --> 01:17:41.860]  Ее выкинули оттуда.
[01:17:43.860 --> 01:17:44.860]  Вот.
[01:17:44.860 --> 01:17:49.860]  Ну, доказывается чисто геометрически то, что у вас каждый раз при каждом новом шаге перед вайлом в стэке лежит выпукла оболочка.
[01:17:49.860 --> 01:17:50.860]  Вот.
[01:17:50.860 --> 01:17:55.860]  Ну, доказывается чисто геометрически то, что у вас каждый раз при каждом новом шаге выполнения вайла у вас все будет хорошо.
[01:17:57.860 --> 01:17:58.860]  Вот.
[01:17:58.860 --> 01:17:59.860]  Сколько это работает?
[01:18:00.860 --> 01:18:01.860]  Да.
[01:18:02.860 --> 01:18:03.860]  Что именно?
[01:18:10.860 --> 01:18:13.860]  Мы считаем, что иначе у нее был бы больше полярный угол просто-напросто.
[01:18:13.860 --> 01:18:17.860]  Угол между P0 и P1 и вот этой точкой был бы больше, чем у этой и этой.
[01:18:17.860 --> 01:18:19.860]  Мы бы ее рассмотрели позже, чем эту.
[01:18:20.860 --> 01:18:22.860]  А у нас в нашей ситуации они будто бы на одной прямой лежат.
[01:18:23.860 --> 01:18:24.860]  Но я специально так нарисовал.
[01:18:26.860 --> 01:18:30.860]  Сначала по углу, в случае равенства угла по расстоянию.
[01:18:34.860 --> 01:18:35.860]  Время работы следующее.
[01:18:36.860 --> 01:18:38.860]  Давайте оценим каждый шаг.
[01:18:38.860 --> 01:18:39.860]  Это от.
[01:18:40.860 --> 01:18:43.860]  Потому что просто нужно найти два минимума.
[01:18:44.860 --> 01:18:47.860]  Сортировка у от n log n.
[01:18:48.860 --> 01:18:50.860]  Потому что у вас время работы компаратора.
[01:18:50.860 --> 01:18:52.860]  Посчитать угол, посчитать расстояние.
[01:18:52.860 --> 01:18:54.860]  Это от единиц, наверное, всего n log n.
[01:18:56.860 --> 01:18:57.860]  Вопрос в этой вот странной штуке.
[01:18:58.860 --> 01:19:00.860]  Казалось бы, вайл может работать хоть у от n раз.
[01:19:01.860 --> 01:19:07.860]  Ну, действительно, можно построить такой пример, когда у вас вот этот вот вайл будет выполняться там порядка n-3 раз.
[01:19:07.860 --> 01:19:10.860]  То есть у вас вот за одну итерацию фора, итерация вайла будет n-3 штуки.
[01:19:13.860 --> 01:19:14.860]  Вот.
[01:19:14.860 --> 01:19:19.860]  Ну, на самом деле, давайте подумаем, что происходит с каждой точкой.
[01:19:20.860 --> 01:19:22.860]  Вообще, в чем ее, как живет наша точка прекрасная.
[01:19:23.860 --> 01:19:24.860]  Она живет очень хорошо.
[01:19:24.860 --> 01:19:26.860]  Сначала она жила-нетужила.
[01:19:26.860 --> 01:19:27.860]  Ну, жила-нетужила, вот.
[01:19:28.860 --> 01:19:30.860]  Потом ее закинули в стек.
[01:19:30.860 --> 01:19:33.860]  Она такая, о, я стал кандидатом, выпукло оболочку.
[01:19:33.860 --> 01:19:35.860]  Ну, а что происходит с этой точкой?
[01:19:35.860 --> 01:19:36.860]  Она выпукла оболочку.
[01:19:36.860 --> 01:19:38.860]  Ну, а что происходит с кандидатами в нашем мире?
[01:19:38.860 --> 01:19:40.860]  Они либо побеждают, либо их выбрасывают, вот.
[01:19:41.860 --> 01:19:44.860]  Как бы точка может быть либо выброшенная, она больше никогда не будет рассмотрена.
[01:19:45.860 --> 01:19:49.860]  Потому что она с меньшим полярным углом, она больше никогда не попадает в нашу систему в выпукло оболочку.
[01:19:50.860 --> 01:19:51.860]  Вот.
[01:19:51.860 --> 01:19:54.860]  Либо она победила и осталась в выпукло оболочке.
[01:19:54.860 --> 01:19:56.860]  То есть с каждой точкой происходит два действия.
[01:19:57.860 --> 01:19:58.860]  Не больше двух действий.
[01:19:58.860 --> 01:20:03.860]  Ее один раз добавили в кандидата, а второй раз ее, возможно, не выбросили, а, возможно, выбросили.
[01:20:03.860 --> 01:20:04.860]  Вот.
[01:20:04.860 --> 01:20:06.860]  Все, больше никаких действий с точкой пройти не может.
[01:20:06.860 --> 01:20:07.860]  Это весь ее жизненный цикл.
[01:20:08.860 --> 01:20:12.860]  Поэтому суммарно вайлов внутри всех форов будет отn.
[01:20:14.860 --> 01:20:19.860]  Поэтому весь этот страшный шаг – это отn, на самом деле, суммарно.
[01:20:21.860 --> 01:20:26.860]  Собственно, алгоритм Грехома называется алгоритм Грехома за счет прекрасного прохода с стеком по точкам.
[01:20:27.860 --> 01:20:30.860]  Поэтому суммарное время работы отn log n.
[01:20:30.860 --> 01:20:34.860]  У всего этого дела линия, линия, ам лог н.
[01:20:35.860 --> 01:20:36.860]  Вот.
[01:20:44.860 --> 01:20:45.860]  Да, да, конечно.
[01:20:45.860 --> 01:20:53.860]  Потому что, ну, если у вас есть точка, ну, опять же, в терминах направлений, да, если возьмете вот этот вот трезог,
[01:20:54.860 --> 01:20:58.860]  то вдоль этого вектора вам нужна самая дальняя от нее точка, самая крайняя множество.
[01:20:59.860 --> 01:21:02.860]  Ну, потому что, значит, просто нет смысла ее включать.
[01:21:02.860 --> 01:21:03.860]  Ну и все на этом.
[01:21:04.860 --> 01:21:05.860]  В общем, это весь алгоритм.
[01:21:06.860 --> 01:21:09.860]  Если есть вопросы, обращайтесь, мы больше не успели.
