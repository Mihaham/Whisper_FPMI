[00:00.000 --> 00:12.000]  Всем привет! Всем, кто на этот раз-то не присутствует на лекции, смотрит ее, наверное, в записи, я надеюсь, на это.
[00:12.000 --> 00:21.000]  Тема сегодняшней лекции — это прикладные аспекты шифрования, то есть никакой большой теории про это не будет.
[00:21.000 --> 00:28.000]  Курс вообще не про это. И, более того, про криптографию. Тут надо больше изучать на математических дисциплинах.
[00:28.000 --> 00:39.000]  Итак, протоколы HTP и транспортный протокол, который называется TLS, иногда его еще называют не очень корректно SSL.
[00:39.000 --> 00:49.000]  Что это такое? Для начала вспомним общую иерархию, она же модель оси, стеозаимодействия, в которой очень много уровней.
[00:49.000 --> 00:58.000]  На самом деле эта модель очень старая и в современном мире выделяет только четыре уровня, верхний из которых является уровень процесса,
[00:58.000 --> 01:05.000]  который, в свою очередь, можно условно разделять на некоторые подуровни, не всегда это бывает осмысленно.
[01:05.000 --> 01:12.000]  И там есть уровень сеанса, к которому как раз относится протокол TLS.
[01:12.000 --> 01:22.000]  Что это такое? Это дополнительный уровень абстракции, предназначенный для того, чтобы прозрачно шифровать какие-то данные.
[01:22.000 --> 01:29.000]  Что происходит, когда вы подключаетесь к какому-то ресурсу по обычному протоколу HTP?
[01:29.000 --> 01:35.000]  Вы открываете socket, подключаетесь к серверу и начинаете взаимодействовать в обычном текстовом виде.
[01:36.000 --> 01:46.000]  Если вы хотите, чтобы ваши данные не летали по сети в открытом виде, то нужно предварительно что-то сделать,
[01:46.000 --> 01:58.000]  установить соединение, переключиться на протокол TLS и затем уже поверх этого протокола TLS передавать данные, которые будут уже шифроваться.
[01:58.000 --> 02:05.000]  Зачем вам нужна эта задача, шифровать данные?
[02:05.000 --> 02:14.000]  Давайте посмотрим, что у нас будет происходить, когда вы сделаете обычный HTTP запрос куда-нибудь,
[02:14.000 --> 02:21.000]  на example.com и при этом по обычному протоколу HTTP.
[02:21.000 --> 02:33.000]  Почему именно example.com? Потому что сейчас в интернете практически все перешло на протокол HTPS, а example.com еще остался.
[02:33.000 --> 02:48.000]  Вот мы загружаем какие-то данные, давайте посмотрим, что может узнать какой-нибудь злоумышленник, который захочет что-то нехорошее сделать.
[02:48.000 --> 02:57.000]  Так, запускаем наш любимый VRShark, огромное количество взаимодействия, но давайте немножко его пофильтруем,
[02:57.000 --> 03:08.000]  для этого выясним IP адрес example.com и поставим фильтр только на интересующий нас домен.
[03:08.000 --> 03:13.000]  Так, IP адрес меня интересует вот такой.
[03:13.000 --> 03:19.000]  Так, ладно, перезагружаем страницу и смотрим, что у нас отправляется.
[03:19.000 --> 03:28.000]  Во-первых, у нас отправляется некоторый HTTP запрос, который представляется обычным плентекстом,
[03:28.000 --> 03:34.000]  этот запрос, соответственно, можно найти в выводе VRShark.
[03:34.000 --> 03:43.000]  В ответ нам тоже что-то отправляют и опять же VRShark это все видит вот в таком замечательном виде.
[03:43.000 --> 03:55.000]  Ни о какой приватности данных речи не идет, ваш провайдер имеет полный доступ к вашим данным, ваш провайдер может в том числе эти данные модифицировать.
[03:55.000 --> 04:02.000]  Я как-то даже один раз столкнулся в реальной жизни с тем, что провайдер подсовывает какие-то данные,
[04:02.000 --> 04:08.000]  до тех пор, пока протокол HTPS не был распространен повсеместно.
[04:08.000 --> 04:14.000]  Банально московское метро с бесплатным Wi-Fi, но бесплатный сыр бывает только в мышелувке,
[04:14.000 --> 04:23.000]  соответственно, московский метрополитен вставлял в странички свои блоки с рекламой, иногда даже что-нибудь ломал,
[04:23.000 --> 04:25.000]  стремится просто развалить.
[04:25.000 --> 04:34.000]  Это один из примеров, зачем все-таки нужны любые данные шифровать, не только данные, которые содержат какие-то читательные данные.
[04:34.000 --> 04:44.000]  Что можно здесь поделать? Мы можем использовать протокол HTPS с звуковкой.
[04:44.000 --> 04:52.000]  Что у нас здесь тогда будет происходить? У нас происходит обмен сертификатами,
[04:52.000 --> 05:02.000]  ну и дальше какое-то взаимодействие, из которого мы в принципе никакие данные извлечь уже не сможем.
[05:02.000 --> 05:16.000]  При этом сам протокол HTP является текстом, то есть можно запустить telnet,
[05:16.000 --> 05:24.000]  подключиться к какому-то удаленному серверу, вручную набрать команды get что-то там,
[05:24.000 --> 05:32.000]  номер протокола обычно в текстовом виде HTP 1.1 и получить его от страницы.
[05:32.000 --> 05:44.000]  Если вы хотите использовать протокол SSL или HTPS, то здесь уже можно использовать инструмент из фреймворка OpenSSL.
[05:44.000 --> 05:48.000]  Мы несколько раз еще будем сегодня обращаться к этому фреймворку.
[05:48.000 --> 05:52.000]  Это команда, у которой есть много других подкоманд,
[05:52.000 --> 05:58.000]  поскольку OpenSSL это просто набор инструментов одной подставки.
[05:58.000 --> 06:11.000]  И вот в частности s-клайнт – это инструмент, который позволяет установить соединение с каким-то сервером,
[06:11.000 --> 06:14.000]  используя защищенный протокол HTPS.
[06:14.000 --> 06:19.000]  Мы подключаемся с помощью OpenSSL к серверу Яндекса.
[06:19.000 --> 06:26.000]  Происходит обмен шифрами, проверяется подлинность сертификата.
[06:26.000 --> 06:38.000]  После этого мы можем писать обычные HTP запросы в текстовом виде и получать осмысленные ответы.
[06:38.000 --> 06:46.000]  Ну и вот этот вывод – это все страничка Яндекса.
[06:51.000 --> 06:54.000]  Немножко о том, как это все правильно называется.
[06:54.000 --> 06:59.000]  Очень часто протокол называют SSL, что не очень корректно,
[06:59.000 --> 07:06.000]  поскольку SSL – это проприетарный протокол разработанной компанией Netscape.
[07:06.000 --> 07:13.000]  Затем он был стандартизован, переименовался в Transport Layer Security.
[07:13.000 --> 07:21.000]  Именно стандартизованные международные названия TLS являются более правильными, в отличие от SSL, хотя идеально это не то.
[07:21.000 --> 07:29.000]  Есть разные версии. Последняя версия, которая повсеместно используется уже всеми браузерами, всеми серверами,
[07:29.000 --> 07:35.000]  это версия 3. Подробно на версиях тут останавливаться смысла не имеет.
[07:35.000 --> 07:46.000]  Как мы все-таки можем устанавливать защищенное соединение, учитывая, что у нас и так уже есть какие-то сервера,
[07:46.000 --> 07:54.000]  которые работают на определенных портах, и нужно получается выдавать какой-то другой контакт.
[07:54.000 --> 08:05.000]  Решается двумя способами. В случае с HTTP можно просто сделать отдельный порт для прослушивания защищенных соединений, вместо 80-го.
[08:05.000 --> 08:15.000]  В некоторых случаях, например, в почтовых серверах тоже используется обычное текстовое взаимодействие, текстовая команда,
[08:15.000 --> 08:23.000]  и есть отдельная команда, которая инициирует переход в режим TLS со всем последующим ханшейкой.
[08:23.000 --> 08:37.000]  Зачем это все нужно? Во-первых, нужно иметь возможность проверять, не вклювываться ли кто-нибудь в ваше соединение.
[08:37.000 --> 08:46.000]  Тоже не добросовестный провайдер может быть, Wi-Fi, router, может сдержать какие-то закладки.
[08:46.000 --> 09:00.000]  Кроме того, данные нужно иметь шифровать, и вообще индустрия цифровых сертификатов, почему их по всем местам не вводили.
[09:00.000 --> 09:11.000]  Это был достаточно выгодный бизнес для ряда американских компаний, потому что для того, чтобы настроить свой сервер, работающий по протоколу HTTPS,
[09:11.000 --> 09:23.000]  вам нужно иметь подписанный, третей стороной, сертификат. Цифровая попасть она тоже стоит денег, но не так давно появился некоммерческий проект,
[09:23.000 --> 09:38.000]  по названию Let's Encrypt, благодаря которому можно получать подписанные сертификаты, которые имеют не очень большой срок действия, но тем не менее они работают бесплатно.
[09:38.000 --> 09:49.000]  И именно с тех пор, как начали выдавать массово дешевые и бесплатные сертификаты, практически весь интернет перешел на шифрованные соединения.
[09:49.000 --> 10:02.000]  На чем это все основа? Некоторые основы криптографии. Есть три класса криптографических алгоритмов, которые используются на практике.
[10:02.000 --> 10:14.000]  Самый простой, один класс набора простого использования, это вычисление хэшей. Кто помнит в курсе алгоритмов, что такое хэширование?
[10:14.000 --> 10:16.000]  Помните? Молодцы!
[10:16.000 --> 10:29.000]  Итак, напомню, что хэш функция, это функция, которая принимает на вход достаточно большие данные произвольного размера и выдает какое-то скалярное значение.
[10:29.000 --> 10:41.000]  Обычно это число, причем число может быть с достаточно большой разрядностью, не обязательно 32 битная, может быть 128 битная, может быть 256 или 512 битная.
[10:41.000 --> 10:46.000]  Но общий смысл в том, что это число имеет фиксированный размер.
[10:46.000 --> 10:56.000]  Особенность хэш функции в том, что по вычисленному хэш значению вы не можете обратно восстановить данные. Это в принципе невозможно.
[10:56.000 --> 11:06.000]  При этом для хорошей хэш функции гарантируется, что хэш значения от разных данных будут разными.
[11:06.000 --> 11:14.000]  Хэш значения от одинаковых данных будут одинаковыми, но это в случае идеальной хэш функции. Ничего идеального в этом мире не бывает.
[11:14.000 --> 11:32.000]  И есть исследования, которые посвящены тому, чтобы найти какие-то уязвимости в хэш алгоритмах, то есть найти какие-то одинаковые разные данные, которые будут давать один и тот же хэш.
[11:32.000 --> 11:42.000]  И ситуация, когда вы нашли такие данные и хэши их совпадают, это называется компрометация хэш функций.
[11:42.000 --> 11:52.000]  По этой причине хэш функций существует в достаточно большом количестве. Хэши размеров 128 бит уже не используются, потому что они уже давно скомпрометированы.
[11:52.000 --> 12:00.000]  Самый стойкий шифр, который на текущий момент пока еще не узнан, это СИЧ 512 бит.
[12:00.000 --> 12:18.000]  Есть еще некоторые хэш функции, которые в принципе не нацелены на то, чтобы гарантировать уникальность хэшей для разных данных, для которых это не особо принципиальная, например, хэш функция для проверки целостности данных.
[12:18.000 --> 12:31.000]  Алгоритм CRC32, который используется для контроля целостности файлов или вообще даже битчетности, это тоже формально можно считать хэш функций.
[12:31.000 --> 12:43.000]  Хотя про него можно сказать, что он в половине случаев будет давать результат, который будет совпадающий с какими-то другими. Но зато он очень простой в железной реализации.
[12:43.000 --> 13:05.000]  Для чего нужны хэш функции? Во-первых, поскольку у нас результатом хэширования, неважно каких данных, является какое-то число, то это очень удобно для какой-то индексации в хранилищах, но банально ключи в базы данных, которые с очень высокой вероятностью будут уникальными.
[13:05.000 --> 13:32.000]  Могут быть использованы для проверки целостности данных. Например, если вы скачиваете из образ какой-нибудь линк дистрибутива, то обычно рядом где-нибудь лежит файлик, который содержит хэш значения для проверки того, что вы правильный файл скачали из правильного места, потому что файлы бывают раскидываться по зеркалам, и мало ли кто выложил на свое зеркало.
[13:32.000 --> 13:53.000]  Ну и плюс, что файлы действительно до конца. Ну и в том числе хэш значения могут быть использованы для авторизации с использованием паролей. Это совсем не для всех очевидный момент, поэтому почну на небольшом примере.
[13:53.000 --> 14:16.000]  Допустим, у нас есть пользователь под названием админ, и у него есть пароль QWERTY123. Как можно хранить какой-нибудь базы данных пользователей и их пароль?
[14:16.000 --> 14:39.000]  Если мы будем хранить именно в текстовом виде QWERTY123, а сверять их в текстовом виде, то, очевидно, эта система будет не очень безопасной, потому что сис-админ, который имеет админские права, либо вообще хоть кто-нибудь, кто возьмет копию этой базы данных, будет знать все пароли, что не очень хорошо.
[14:39.000 --> 14:55.000]  Как можно поступить? Мы можем пароль QWERTY123 закодировать каким-нибудь специфичным образом, например, используя любую хэш-функцию, пусть даже не самую стойкую, например, MD5.
[14:55.000 --> 15:13.000]  Вот мы получаем значение, да, вывод хэш-функции на практике, это просто строка, которая содержит 16-личную запись какого-то большого числа. Здесь 128 бит, соответственно, 128 бит это 16 байт, которые могут быть закодированы.
[15:13.000 --> 15:35.000]  Так, без переноса строк, вроде ничего визуально не поменялось, но хэш-функция у нас изменилась.
[15:35.000 --> 15:50.000]  Что нам нужно сделать теперь с этим хэжа значения? Вот это хэжа значения мы можем теперь смело хранить, и вот из этих циферок обратно извлечь пароль QWERTY123 мы уже никогда не сможем.
[15:50.000 --> 16:08.000]  Если мы опечатаемся паролем QWERTY124, естественно, мы будем иметь другой хэш, и тем самым система авторизации может сверить сами хэши и принять решение о том, можно ли допускать пароль пользователя или нельзя.
[16:08.000 --> 16:32.000]  Это очень простой и прощенный способ, как организовать парольный ход в систему. На самом деле не идеальный парольный ход в систему, потому что у нас есть пользователь admin с паролем QWERTY123, и, допустим, у нас есть пользователь под названием Вася, который имеет пароль 123.
[16:32.000 --> 16:38.000]  Что вы можете сказать про этот пароль, глядя на эту базу данных?
[16:38.000 --> 17:06.000]  Ну, невозможно, а точно. Если у нас равны хэши, то можно сделать вывод о том, что они получены из одинаковых данных, и, соответственно, если вы хотите компрометировать систему, получить админинские права, вы видите, что хэш админинского пароля совпадает с паролем некоего Вася, то что можно сделать?
[17:06.000 --> 17:15.000]  Можно купить бутылку водки, поставить Вася, сказать Вася, скажи-ка свой пароль, и этот пароль будет подходить к пользователю admin, что не очень хорошо.
[17:15.000 --> 17:35.000]  Поэтому, на самом деле, в реальных системах авторизации используют дополнительные сведения, например, могут быть оди пользователя, логины или еще какие-нибудь рандомные данные, какие-то фиксированные рандомные данные, известные на стадии проверки.
[17:35.000 --> 17:49.000]  Добавляют их исходным данным, подмешивают, еще такая операция называется подсаливание исходных данных, для того, чтобы увеличить количество разных вариантов.
[17:49.000 --> 17:58.000]  Так, это один из примеров, когда осмысленно использовать фрикографические хэш-функции.
[17:58.000 --> 18:03.000]  Что еще бывает помимо хэшей?
[18:03.000 --> 18:08.000]  Помимо хэшей есть обычно шифрование симметричным ключом.
[18:08.000 --> 18:23.000]  Как эта штука работает? У вас есть некоторые данные, которые разбиваются на блоки одинакового размера, и они кодируются с помощью некоторого блока данных, который называется ключ.
[18:23.000 --> 18:31.000]  Как правило, ключ имеет тот же самый размер, что блоки данных, на которые бьется весь поток, либо кратный ему.
[18:31.000 --> 18:37.000]  С помощью этого ключа происходят разные манипуляции над блоками данных.
[18:37.000 --> 18:48.000]  И вот важное отличие от функций хэширования, что на выходе мы получаем объем данных примерно такой же, как у нас был в исходных незашифрованных данных.
[18:48.000 --> 18:54.000]  И применяя этот секретный ключ в обратную сторону, мы можем данные декодировать.
[18:54.000 --> 19:05.000]  Примеры алгоритмов симметричным ключом, панорические, классические, это родом из 70-х годов, под названием ДЭС.
[19:05.000 --> 19:14.000]  В принципе, этот алгоритм можем давать даже в качестве заданий на реализацию, он не особо сложный.
[19:14.000 --> 19:21.000]  ДЭС это американский, был еще советский под названием ГОСТ, очень похожий на ДЭС.
[19:21.000 --> 19:27.000]  Алгоритмы АЭС, БОФ, это чуть по современию, это американские, естественно.
[19:27.000 --> 19:33.000]  Есть еще алгоритм под названием Кузнеевича, который уже не советский, а российский.
[19:33.000 --> 19:39.000]  В полный список есть много разных алгоритмов шифрования.
[19:39.000 --> 19:47.000]  И в разных поставках, в разных дистрибутивах OpenSSL они могут различаться.
[19:47.000 --> 19:52.000]  Количество поддерживаемых шифров.
[19:52.000 --> 20:01.000]  Команда OpenSSL-SHIFRS показывает, какие шифры доступны конкретно вашей реализации.
[20:01.000 --> 20:13.000]  Наиболее столькие алгоритмы — это алгоритмы семейства АЭС, что означает разные цифры в названиях алгоритма.
[20:13.000 --> 20:19.000]  Это размер блока данных, к которому применяется ключ.
[20:19.000 --> 20:31.000]  Размер блока — это размер ключа.
[20:31.000 --> 20:37.000]  На счет АЭС согласен, что блоку 256 бит все равно фиксирован.
[20:37.000 --> 20:43.000]  У нас есть размер ключа. Чем больше размер ключа, тем более стойкий.
[20:43.000 --> 20:58.000]  И еще есть разные варианты. После названия АЭС, например, 256, CBC, ECB — это способы применения ключа к какому-то блоку данных.
[20:58.000 --> 21:09.000]  По умолчанию АЭС использует алгоритм AES 256 CBC, который называется код блокчейнинг.
[21:09.000 --> 21:14.000]  Что это такое и как это влияет на кодирование данных?
[21:14.000 --> 21:23.000]  Способы применения ключа в рамках алгоритма кодированным блокам.
[21:23.000 --> 21:33.000]  Мы берем все данные, разбиваем их на равные куски и применяем ключ независимо каждому отдельному кусочку данных.
[21:33.000 --> 21:41.000]  Такой способ называется электронный код блок. Название, конечно, странное, но тем не менее устояшееся.
[21:41.000 --> 22:00.000]  Чем такой способ хорош? Здесь мы можем закодировать большие объемы данных, а потом, если нам все данные не нужны, то можем указатель чтения прокрутить блока в середине и прочитать только нужный блок и декодировать.
[22:00.000 --> 22:16.000]  Работает быстро. Чем такой способ плох? Плох тем, что он не учитывает возможности ситуации, что данные у нас могут быть похожими.
[22:16.000 --> 22:33.000]  Для того, чтобы сделать хорошее качественное шифрование, часто используется шифр блокчейнинг, либо разные варианты, которые похожи на шифр блокчейнг.
[22:33.000 --> 22:50.000]  После того, как мы закодировали очередной блок, результат закодированной данной, полученный на предыдущем блоке, мы используем по разглядной операции исключающего или для кодирования очередного блока.
[22:50.000 --> 22:59.000]  В этом случае нам нужен еще один начальный блок, который называется инициализационный вектор. Как правило, он получается из самого ключа.
[22:59.000 --> 23:18.000]  И как это влияет с точки зрения качества шифрования. Можно провести эксперимент в гимпе, сохранить пингвина в некотором формате, который не содержит заголовки.
[23:18.000 --> 23:35.000]  Это один и тот же алгоритм IS, но один использует шифрование отдельными блоками, а другой использует информацию о соседних блоках.
[23:35.000 --> 23:52.000]  Ну и какие-то общие очертания пингвина все-таки можно разглядеть. Если мы на каждом блоке исполним информацию от предыдущего, то здесь видит пингвина на самой правой картинке.
[23:52.000 --> 24:11.000]  Как можно пользоваться в команды строки инструментами OpenSSL для того, чтобы закодировать какие-то данные.
[24:11.000 --> 24:25.000]  Немножко выпадаю в втором практике. Команду ENG с опцией minus-shifers просто выдает какие есть у вас доступные шифры.
[24:25.000 --> 24:39.000]  Давайте сделаем какой-нибудь файл, который содержит секретные данные.
[24:39.000 --> 24:53.000]  И сделаем так, чтобы этот файл...
[24:53.000 --> 24:59.000]  Вот мы получили файл hello.txt, замечательно.
[24:59.000 --> 25:04.000]  Теперь сделаем следующий трюк.
[25:04.000 --> 25:14.000]  OpenSSL, закодируем, используем IS-256.
[25:14.000 --> 25:22.000]  Команда уже почти написана.
[25:22.000 --> 25:32.000]  У нас тут спрашивают про пароль, но давайте это будет самая распространенная пароль QWERTY.
[25:32.000 --> 25:38.000]  Получилось. Теперь смотрим на содержимое нашего файла, который мы закодировали.
[25:38.000 --> 25:49.000]  Получаем какой-то abracadabra, никакого слова hello здесь внутри не содержится.
[25:49.000 --> 25:59.000]  Зато он содержит какие-то бинарные данные. В том числе могут содержаться какие-нибудь не печатаемые символы.
[25:59.000 --> 26:03.000]  Это вполне допустимо.
[26:03.000 --> 26:11.000]  Теперь обратная операция, как это все декодировать.
[26:11.000 --> 26:15.000]  Тоже самое. Инкодинг, но с опцией –D сделать обратную операцию.
[26:15.000 --> 26:21.000]  Обязательно нужно указать, какой алгоритм шифрования мы используем.
[26:21.000 --> 26:35.000]  Имя входного файла я указывать не буду, потому что я знаю, что результат должен быть текстовым. Его можно вывести на экран.
[26:35.000 --> 26:41.000]  Так, вводим пароль QWERTY. Получаем строчку hello.
[26:41.000 --> 26:48.000]  Теперь все то же самое, но вместо QWERTY я наберу afdf на клавиатуре.
[26:48.000 --> 26:54.000]  Включаем бабах, ошибку. Решифровка не удалась.
[26:54.000 --> 27:02.000]  Еще один трюк, связанный с криптографией, заключается в добавлении соли.
[27:02.000 --> 27:11.000]  На что оно влияет? Еще раз кодирую файл с тем же самым паролем QWERTY.
[27:11.000 --> 27:21.000]  Давайте посмотрим на полученные файлы.
[27:21.000 --> 27:28.000]  Есть файлы размером 32 байта hello, также файлы размером 32 байта.
[27:28.000 --> 27:34.000]  Это еще раз закодированный файл, который содержит строчку hello, закодированную паролем QWERTY.
[27:34.000 --> 27:39.000]  Так, являются ли эти файлы одинаковыми?
[27:39.000 --> 27:46.000]  Поскольку у нас всего лишь 32 байта, поэтому можно использовать hexdump.
[27:46.000 --> 27:52.000]  Что мы здесь видим? Какие-то байтики у нас различаются.
[27:52.000 --> 27:58.000]  Если я сделаю еще один зашифрованный файл, полученный из того же самого исходного файла,
[27:58.000 --> 28:03.000]  с тем же самым паролем я опять получу файл, который будет отличаться.
[28:03.000 --> 28:12.000]  Это следствие того, что файл добавляется в случайные данные для того, чтобы усложнить процесс декодирования.
[28:12.000 --> 28:23.000]  Эти случайные данные называются солью. В принципе, в канале OpenSSL можно указать эту соль самостоятельно.
[28:23.000 --> 28:28.000]  Соль это 8 байтов.
[28:28.000 --> 28:38.000]  Задать в 16-речном виде QWERTY.
[28:38.000 --> 28:46.000]  И соль, в отличие от ключа, явным образом хранится в самом файле.
[28:46.000 --> 28:56.000]  Если вы увидите содержимое файла в текстовом виде, то будет строчка, которая называется salted, подчеркивание.
[28:56.000 --> 29:02.000]  Дальше какие-то байтики. В hexdump можно наблюдать 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8.
[29:02.000 --> 29:13.000]  Эти самые 8 байтов. Цель стоит не скрыть ее, а просто добавить какую-то рандомизацию в определенные данные.
[29:13.000 --> 29:18.000]  На самом деле использование соли не является обязательным.
[29:18.000 --> 29:27.000]  Если нету строки начинающего в соусе подчеркивание, то алгоритм IES просто соли не будет использовать.
[29:27.000 --> 29:38.000]  Чем плох механизм шифрования симметричным ключом?
[29:38.000 --> 29:46.000]  Плохом тем, что мне приходится вводить пароль QWERTY как для шифрования, так и для расшифровки.
[29:46.000 --> 29:58.000]  Ключом может быть не только пароль. В 256 бит можно сбихать достаточно большие данные, не только текстовые.
[29:58.000 --> 30:07.000]  Ключевая проблема заключается в том, что пароль нужно как-то передать человеку, который будет данные расшифровывать.
[30:07.000 --> 30:12.000]  И это бывает не всегда возможно.
[30:12.000 --> 30:19.000]  Поэтому в интернете используется немножко другой способ.
[30:19.000 --> 30:26.000]  Это шифрование пары ключей, один из которых является публичным, другой является приват.
[30:26.000 --> 30:34.000]  Они генерируются одновременно и являются неотклеенной частью одного большего ключа.
[30:35.000 --> 30:45.000]  Публичный ключ обычно используется для того, чтобы данные можно было зашифровать, но он не пригоден для того, чтобы их расшифровать.
[30:45.000 --> 30:53.000]  Поэтому можно смело передавать, публиковать, ничего страшного не произойдет, если он попадет в ненадежные руки.
[30:53.000 --> 30:57.000]  Приватный ключ нужен как раз для расшифровки.
[30:57.000 --> 31:08.000]  Приватный ключ в принципе никак невозможно получить из публичного ключа, поэтому шифрование достаточно верно.
[31:09.000 --> 31:18.000]  Примеры таких алгоритмов это американские РСА, есть российский аналог, называется ГОСТ, но и более современные алгоритмы.
[31:18.000 --> 31:29.000]  Это свои обописи, основанные на матапарате лептических крывых, где применяется шифрование с открытым ключом практически везде.
[31:29.000 --> 31:35.000]  Начинают протокол HTPS и в том числе в протоколе СССР.
[31:38.000 --> 31:49.000]  Как работает это шифрование? Допустим, есть гражданка Элис, которая хочет передать товарищу Бобу какие-то секретные данные.
[31:49.000 --> 31:53.000]  При этом есть одно важное дополнительное ограничение.
[31:53.000 --> 32:04.000]  Элис и Боб не могут лично пересечься и передать какой-то ключ, не могут использовать никакой публичный канал связи для того, чтобы ключ передать.
[32:04.000 --> 32:11.000]  Мы банально познакомились в Тиндере, Элис хочет отправлять нутцы и не хочет, чтобы нутцы разошлись по всему интернету.
[32:11.000 --> 32:25.000]  Что можно сделать? Боб может сгенерировать пару ключей, приватный ключ, который он оставляет у себя и держит в надежном месте, чтобы никто не утащил, и публичный ключ.
[32:25.000 --> 32:37.000]  Этот публичный ключ Боб переводит Элис. Затем Элис шифрует данные, используя ключ Е, который передал ей Боб, и отправляет данную зашифрованную.
[32:37.000 --> 32:51.000]  Затем Боб применяет этот самый ключ Д, который он Элис вообще не показывал, но этот ключ возможен для того, чтобы расшифровать данные.
[32:51.000 --> 32:59.000]  Элис при этом, кстати, данную расшифровать не сможет, и если она исходник потеряет, не судьба значит.
[32:59.000 --> 33:04.000]  Как этим можно воспользоваться на практике?
[33:04.000 --> 33:27.000]  Во-первых, нам нужно сгенерировать пару ключей. Для генерации пары ключей используется подкоманда GenRSA, OpenSSL, GenRSA, указываем имя выходного ключа и его размер.
[33:27.000 --> 33:32.000]  Размер указать не обязательно, по умолчанию 2048 Б.
[33:32.000 --> 33:46.000]  У нас генерирован файл, который содержит пару ключей. Из этих ключей мы можем извлечь публичную часть.
[33:46.000 --> 33:57.000]  На самом деле, чем больше ключ, тем, казалось бы, лучше. Давайте сделаем ключик размером 4 килобайта.
[33:57.000 --> 34:04.000]  Вот он очень дольше генерировался, можно сделать еще больше.
[34:04.000 --> 34:14.000]  Медленно. Я всего лишь два раза увеличил выходного ключа. Обратите внимание, как медленно он генерируется.
[34:14.000 --> 34:32.000]  А если я скажу сделать ключик размером 65 килобайт, то 8 килобайт я дождался. Если я скажу ключик побольше, то до конца пары мы этого не дождемся.
[34:32.000 --> 34:43.000]  Итак, вот мы сделали пару ключей. Затем отсюда надо извлечь публичную часть.
[34:43.000 --> 35:07.000]  Так, RSA, имя файла, это наш приватный ключик, текстовый файл для вывода и операция под командой RSA опубликовать публичный ключ.
[35:07.000 --> 35:18.000]  Вот у нас появился ключик рядом, который называется public key. Этот ключик мы теперь можем передать товарищу, товарищу Элис.
[35:18.000 --> 35:28.000]  Дальше. Товарищ Элис может сделать команду OpenSSL RSA OTO. Страшно выглядит.
[35:28.000 --> 35:33.000]  Ян Критт.
[35:33.000 --> 35:56.000]  Так, используя публичный ключ, это public.key и входные данные. Файл назывался helloText. Запишем что-нибудь типа out RSA.
[35:56.000 --> 36:13.000]  Так, мы получили файл helloRSA. Давайте теперь его расшифруем. OpenSSL под командой RSA OTO, где Критт.
[36:13.000 --> 36:26.000]  Для этого нам уже требуется наш приватный ключ. Мы получили декодирование того теста, который мы захотели.
[36:26.000 --> 36:40.000]  Еще один эксперимент. Давайте мы теперь поменяем наш приватный ключ на публичный.
[36:40.000 --> 36:52.000]  Ошибка. Сделать это мы не можем. Какие у нас есть ограничения? Допустим, мы хотим зашифровать большой объем данных.
[36:52.000 --> 37:02.000]  Слово hello не интересно, потому что здесь всего-то 5 символов плюс символы приноса строки. И он забыл меньше, чем размер ключа.
[37:02.000 --> 37:16.000]  Можно сделать 151 килобайт. Нормально.
[37:16.000 --> 37:30.000]  Теперь шифруем какой-нибудь большой файлик. Для этого используем публичный ключ.
[37:30.000 --> 37:48.000]  И получаем ошибку, что для данного ключа размер данных слишком большой. Это существенное ограничение алгоритма RSA, потому что мы не можем закодировать данные больше, чем размер ключа.
[37:48.000 --> 38:05.000]  Как можно использовать эту схему? Полезная схема. Казалось бы, очень красивая. Вариант первый. Можно просто побить данные на независимые кусочки, шифровать их отдельно.
[38:05.000 --> 38:23.000]  Чем это плохо? Мы получаем ту же самую ситуацию, что с ECB-пингвином. Подход, который используется на практике, это совместное использование алгоритмов с открытым ключом и симметричным ключом.
[38:23.000 --> 38:36.000]  Что на самом деле происходит в браузерах? Сначала браузеры используют алгоритм RSA либо лептические кривые.
[38:36.000 --> 38:53.000]  Достоверяется в том, что нужная ассервация является нужным. Затем генерируется случайно ключ для алгоритма IS. И этот ключ передается с использованием алгоритма RSA.
[38:53.000 --> 39:13.000]  Какие здесь могли быть проблемы? Хорошо, Элис умеет отправлять нутцы ГОГО, но при этом ГОГ должен был через открытый канал связи опубликовать свой публичный ключ.
[39:13.000 --> 39:28.000]  Если использовать ненадежные каналы связи, то этот ключ может быть кем-то перехвачен. Что может сделать какой-нибудь нехороший человек, используя публичный ключ БОБа?
[39:28.000 --> 39:44.000]  Какой-нибудь нехороший человек может закодировать какие-нибудь фейковые данные и отправить в БОБ. БОБ будет честно думать, что эти данные прислала Элис, поскольку ключ отправлял только Элис.
[39:44.000 --> 40:00.000]  И тем самым может не увидеть никакой разницы. Как эту проблему можно решать? Здесь нужно удостовериться, что Элис действительно Элис, а не кто-то, кто себя за нее выдает.
[40:00.000 --> 40:13.000]  Должен быть третий человек, которому все доверяют, который может сказать, что Элис действительно Элис и подписать, например, какой-то ее ключ.
[40:13.000 --> 40:33.000]  Для этого используется сертификат публичного ключа. Это сертификат, который выдается какой-то сторонней компанией, и этот сертификат удостоверяет, что ключ, который вам прислали, действительно является Элис.
[40:33.000 --> 40:49.000]  То есть когда вы подключаетесь к какому-то серверу по протоколу HTTPS, то вы можете наблюдать, что у сервера есть какой-то сертификат, он имеет определенный срок годности.
[40:49.000 --> 41:04.000]  Этот сертификат выпущен к какой-нибудь конторе, типа Semantic, Commodo, или Aletsyn Crypt. Немножко подробнее по ключи.
[41:04.000 --> 41:19.000]  Итак, Элис хочет отправить Бобу данные. До этого можно воспользоваться некоторым традиционным центром, который точно так же сначала генерирует пару ключей, публичный и приват.
[41:19.000 --> 41:28.000]  Этому центру все доверяют, и публичный ключ доступен всем участникам взаимодействия.
[41:28.000 --> 41:39.000]  Дальше. Элис хочет отправить какие-то данные Бобу, но хочет сделать так, чтобы Боб мог убедиться, что это действительно Элис.
[41:39.000 --> 41:49.000]  Для этого Элис генерирует пару ключей и свой публичный ключ отправляет авторитационному центру.
[41:49.000 --> 42:05.000]  Авторитационный центр вычисляет хэж значения, который является уникальным для разных данных. Он вычисляет хэж значения для публичного ключа, и затем шифрует это хэж значение, используя свой приватный ключ.
[42:05.000 --> 42:11.000]  Естественно, авторитационный центр не должен выдавать и никак светить своих приватных ключей.
[42:11.000 --> 42:18.000]  И вот этот подписанный зашифрованный сертификат доступен и Элису, и Бобу.
[42:18.000 --> 42:24.000]  Соответственно, как Боб может удостовериться, что мы действительно правильный человек, отправив данные.
[42:24.000 --> 42:41.000]  Он может использовать публичный ключ для того, чтобы расшифровать этот сертификат и удостовериться, что ключ действительно был выпущен Элис, что хэж совпадает.
[42:41.000 --> 42:46.000]  Ну и как-то все выглядит в реальности.
[42:46.000 --> 42:52.000]  Когда вы установите ТЛ-соединение, сервер присылает сертификат клиенту.
[42:52.000 --> 43:01.000]  Дальше клиент проверяет сертификат, используя базу данных корневных сертификатов.
[43:01.000 --> 43:06.000]  То есть в каждом браузере вы можете найти список сертификатов.
[43:06.000 --> 43:13.000]  Иногда в некоторых системах это можно найти не в настройках браузера, а в настройках самой операционной системы.
[43:13.000 --> 43:22.000]  То есть множество сертификатов ключей, которые доступны всем приложениям, а не только одному конкретному браузеру.
[43:22.000 --> 43:33.000]  После этого клиент генерирует пару ключей уже для текущего сеанса, отправляет серверы и начинает взаимодействовать.
[43:33.000 --> 43:40.000]  Что такое корневые сертификаты? Где их можно взять?
[43:40.000 --> 43:49.000]  Корневые сертификаты обычно соответствуют каким-то организациям, которые подписывают другие сертификаты.
[43:49.000 --> 44:00.000]  И раньше надо было платить достаточно большие деньги, чтобы ваш сертификат подписала какая-нибудь компанию, доставляющую центр.
[44:00.000 --> 44:10.000]  В то же время, даже если вы заплатили большие деньги за свой сертификат, это еще не значит, что всегда можно вам доверять.
[44:10.000 --> 44:21.000]  Периодически бывают скандальные утечки, из-за чего приходится отзывать очень много сертификатов, выпускать экстренное обновление к браузерам.
[44:21.000 --> 44:23.000]  Редко, но бывает.
[44:23.000 --> 44:32.000]  Второй вариант, если вы не хотите вообще никому доверять, либо против нас ввели санкции и никто не хочет подписывать наши сертификаты,
[44:32.000 --> 44:42.000]  то можно просто выпустить свой корневый сертификат, добавить его в браузеры всех ваших потенциальных клиентов, всех ваших сотрудников,
[44:42.000 --> 44:51.000]  и считать, что этот сертификат, которым вы подписываете свои веб-ресурсы, тоже надежный для определенного круга лиц.
[44:51.000 --> 45:01.000]  В общем-то у нас за государством сейчас то же самое происходит с госуслугами. Браузер Яндекс содержит дополнительные сертификаты.
[45:04.000 --> 45:14.000]  Ну и еще один способ, как можно подписать свой сертификат для своего сервера, есть бесплатный сервис Let's Encrypt.
[45:14.000 --> 45:18.000]  Замечательным тем, что там практически ничего не нужно делать.
[45:18.000 --> 45:29.000]  Просто вставим через APT ГЭЦ или еще что-нибудь, команду по названию CertBot запускаем, и все, и пользуемся счастьем.
[45:29.000 --> 45:37.000]  Очень простой механизм получения сертификатов упрощен настолько, что проще некуда и грехами располиваться.
[45:37.000 --> 45:42.000]  Что такое сертификат, то есть что делает доставающий центр?
[45:42.000 --> 45:47.000]  Доставающий центр, на самом деле, это не просто контора, которая налево-направо всем раздает сертификаты, подписывает.
[45:47.000 --> 45:52.000]  Вовсе нет. Нужно удовлетворять некоторым минимальным требованиям.
[45:52.000 --> 46:01.000]  В случае с Let's Encrypt нужно подтвердить, что вы действительно получаете сертификат на тот сервер, для которого запрашиваете.
[46:01.000 --> 46:12.000]  Для этого нужно с правами рта, либо с правами того пользователя, который имеет доступ на запись в каталог вашего веб-сервера.
[46:12.000 --> 46:27.000]  Запустил CertBot, он скачает с Let's Encrypt какие-то данные, которые нужно будет обязательно положить на ваш сервер, дальше с вашего сервера по доменному имени.
[46:27.000 --> 46:37.000]  Эти данные получаются, тем самым происходит проверка, что вы действительно не на условные яндексеры пытаетесь получать сертификат, а на свой сервер.
[46:37.000 --> 46:44.000]  И это считается достаточным для того, чтобы подтвердить, что действительно вы являетесь владельцем сертификата.
[46:44.000 --> 46:53.000]  Более серьезные конторы могут выполнить дополнительные проверки, например, потребовать ваши паспортные данные.
[46:53.000 --> 47:00.000]  Так, ну и сертификат дальше просто прописывается к веб-серверу Apache либо Nginx, кому что больше нравится.
[47:00.000 --> 47:16.000]  И стандартная практика сейчас является то, что на 80 порту делается простая переадресация, то есть код возврата 301.redirect на новый URL, который отличается от исходного только наличие буковки S названием протокола.
[47:17.000 --> 47:25.000]  Так, ну и сегодня я вам показывал использование команды OpenSSL.
[47:25.000 --> 47:38.000]  На самом деле, пакет OpenSSL содержит не только одну команду с кучей возможностей, это еще и библиотеки, которые в том числе можно использовать в своем программном продукте.
[47:38.000 --> 47:45.000]  И OpenSSL на самом деле используется практически как стандарт де-факто.
[47:45.000 --> 47:53.000]  В многих продуктах для него естественно есть уже готовый написанный CMakeMobile, есть сборки под Windows.
[47:53.000 --> 48:05.000]  В общем, все хорошо, все замечательно. Точнее, почти все хорошо, все замечательно, если не считать того, что исходный код OpenSSL, он не самый аккуратный.
[48:05.000 --> 48:20.000]  И это обнаружилось в 2014 году, когда выяснились подробности бага по названию Hardlead в этой библиотеке OpenSSL.
[48:20.000 --> 48:29.000]  Начали проводить аудит, но выяснилось, что очень много написано коровами руками.
[48:29.000 --> 48:39.000]  И был создан альтернативный проект Fork OpenSSL, из которого выкинули много легоси.
[48:39.000 --> 48:48.000]  Называется он LibreSSL с точки зрения программного интерфейса, с точки зрения сигнатуры команд.
[48:48.000 --> 48:57.000]  Они практически совпадают, и в некоторых дистрибутивах есть даже возможность выбора, из какого пакета ставить OpenSSL.
[48:57.000 --> 49:01.000]  Либо из настоящего OpenSSL, либо из пакета LibreSSL.
[49:01.000 --> 49:09.000]  Ну и соответственно там есть несколько библиотек, которые можно также использовать из своего СИШного кода.
[49:09.000 --> 49:16.000]  LibreSSL на самом деле немножко хуже OpenSSL в плане количества поддерживаемых алгоритмов.
[49:16.000 --> 49:20.000]  Но основные алгоритмы там все равно реализовываются.
[49:20.000 --> 49:24.000]  На этом все, есть ли у вас вопросы?
[49:24.000 --> 49:32.000]  Кажется, в Иране сказали, что нельзя в мире это программство предназначать.
[49:32.000 --> 49:36.000]  Использовать там публичную фигню Стаскевасова и наоборот.
[49:36.000 --> 49:44.000]  Кажется, что если использовать ключи в другом порядке, то мы получаем еще один довольно простой механизм подпись.
[49:44.000 --> 49:49.000]  Возможно, да.
[49:49.000 --> 49:55.000]  Так, ладно, еще вопросы есть.
[49:55.000 --> 49:59.000]  Ну если нет, тогда электро закончилось.
