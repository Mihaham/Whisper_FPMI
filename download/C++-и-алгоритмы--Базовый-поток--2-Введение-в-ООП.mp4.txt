[00:00.000 --> 00:13.400]  Я начну. Первое, с чего хотелось бы начать это объявление. Все видели, что сегодня вам
[00:13.400 --> 00:24.640]  стало доступно первое домашнее задание. Я повторяю, оно стало доступно. Домашнее задание
[00:24.640 --> 00:30.400]  состоит из двух контестов. Первый контест — это примерно такой же контест, к которому вы привыкли,
[00:30.400 --> 00:38.240]  то есть вы отправляете файлик с кодом, с решением, и в общем, ваше решение проверяется на закрытых
[00:38.240 --> 00:44.320]  тестах. Вторая часть — это задачи, так называемые задачи из GitLab или задачи с юнит-тестированием.
[00:44.320 --> 00:49.240]  В этих задачах вам нужно писать некоторый класс. Что такое класс и как их писать, мы поговорим
[00:49.240 --> 00:56.720]  сегодня. Вы пишете некоторые классы, и дальше его функциональность проверяется на публичных тестах.
[00:56.720 --> 01:05.720]  Все публичные тесты можно найти непосредственно в GitLab. У нас есть GitLab, на котором есть условия
[01:05.720 --> 01:10.600]  всех задач, на которых есть некоторые заготовки решений при необходимости, и также есть открытые
[01:10.600 --> 01:15.840]  тесты. У большинства задач тесты все открытые, поэтому, в общем-то, я думаю, что нет причин как-то
[01:15.840 --> 01:23.240]  посылать все в контест и получать неправильные ответы. Весь тот код, на котором будет тестироваться
[01:23.240 --> 01:27.760]  ваше решение, он доступен. Ну и за исключением буквально пара задач, на которых тесты тоже будут
[01:27.760 --> 01:32.860]  закрыты. Ну и вообще, в нашем курсе большинство задач будут с публичными тестами. Вот так у нас
[01:32.860 --> 01:42.120]  принято. На семинарах все успели познакомиться со способом задачи в Яндекс.контест? Все сдавали
[01:42.120 --> 02:05.400]  задачи на семинарах? Нет? Кто нет? Как так? Первые две недели. Молодец. В общем, смотрите,
[02:05.400 --> 02:10.280]  вся процедура того, как устроено тестирование, как будут тестироваться ваши решения и так далее,
[02:10.280 --> 02:14.440]  они, в принципе, на GitLab описаны. То есть, весь процесс того, как будет происходить решение,
[02:14.440 --> 02:20.960]  то есть, от проверки стиля до запуска тестов, там все указано. Поэтому, если вы все настроите у
[02:20.960 --> 02:25.280]  себя на локальных компьютерах, то, в принципе, весь тот pipeline, который будет проходить ваше
[02:25.280 --> 02:29.880]  решение, вы, собственно, сделаете. Понятное дело, что вы можете этому ничего не следовать,
[02:29.880 --> 02:33.160]  просто посылать в контест, получать ваши ошибки, ошибки компириации и так далее. Но,
[02:33.160 --> 02:37.160]  если это будет много, то в какой-то момент мы просто сделаем ограничение числового попыток. Поэтому,
[02:37.160 --> 02:43.320]  в общем, локально все тестируете, тем более все открыто и доступно. Если в процессе возникнут
[02:43.320 --> 02:48.120]  какие-то сложности с отправкой, непонятно, как все посылать, непонятно, как формировать файл,
[02:48.120 --> 02:50.760]  который нужно отсылать, непонятно, как тестировать локально и так далее, в общем,
[02:50.760 --> 02:56.440]  вы пишите там либо мне, либо Роману, ассистенту курса, либо вашим семинаристам. В крайнем случае,
[02:56.440 --> 03:00.360]  если будут какие-то прям нерешаемые проблемы, мы можем устроить дополнительный семинар по тому,
[03:00.360 --> 03:05.040]  как, собственно, сдавать задачи. Поэтому, если у вас есть какой-то дискомфорт, вы об этом пишите.
[03:05.280 --> 03:10.040]  Мы постарались сделать максимально удобную систему, особенно по сравнению с прошлым годом и так далее.
[03:10.040 --> 03:17.600]  Да, ну и дедлайн по первому заданию три недели, то есть до 3 марта можно задавать задания. Ну и,
[03:17.600 --> 03:22.480]  в принципе, у нас так будут устроены задания, что каждые 3-4 недели мы будем выдавать вам новое
[03:22.480 --> 03:31.200]  задание на тоже 3-4 недели. Всего будет 4 домашних задания. Вопросы есть? Отлично, тогда давайте
[03:31.200 --> 03:41.560]  начнем. Ну и, наконец, приступим к теме, главной теме этого семестра. Объектно-ориентированную
[03:41.560 --> 03:48.200]  программированию. Напомню, все лекции в PDF доступны, можете параллельно следить. Итак,
[03:48.200 --> 03:52.560]  с чего начнем? Давайте начнем с того, что определимся с тем, что такое парадигма
[03:52.560 --> 03:58.440]  программирования. Значит, смотрите, вообще есть несколько подходов к программированию. То есть,
[03:58.440 --> 04:02.720]  когда у вас есть некоторая задача, то есть вам поставлена задача написать какую-то функцию,
[04:02.720 --> 04:07.120]  реализовать какой-то алгоритм. Вы можете решать эту задачу несколькими способами. Можете решать,
[04:07.120 --> 04:11.560]  как условно первокурсник, который только пришел на первый семинар и пишет программу в мейне. То
[04:11.560 --> 04:15.240]  есть у вас есть задача, вы написали все в мейне, считали все с консоли, вывели все в консоль,
[04:15.240 --> 04:20.600]  послали в контест, ок, все замечательно. Есть более продвинутый уровень, который вы изучали в
[04:20.600 --> 04:24.520]  прошлом семестре, это все-таки разбивать код на функции. Зачем вообще нужно разбивать код на
[04:24.520 --> 04:29.920]  функции? Смотрите, есть первый студент, который пишет все в мейне и отсылает, у него все работает.
[04:29.920 --> 04:34.040]  Есть второй студент, который все разбивает на функции и посылает, у него тоже все работает.
[04:34.040 --> 04:43.480]  В чем разница этих двух подходов? Зачем декомпозировать вообще на функции? В чем смысл?
[04:43.480 --> 04:52.600]  Так, отлично, хорошо. Ну ок, если там что-то, если какой-то кусок кода изменился, то можно все
[04:52.600 --> 04:56.080]  изменить в функции и весь остальной код будет работать. Но в мейне как будто бы тоже можно
[04:56.080 --> 05:06.360]  что-то изменить и все будет работать. Читаемость. А что с читаемостью? Ну в некотором смысле да. Ну в
[05:06.360 --> 05:11.640]  общем, все это верно. Ну действительно, смотрите, что такое парадигмопрограммирование? В самом коротком
[05:11.640 --> 05:15.200]  варианте парадигмопрограммирование просто способ написания программ. Способ мышления, способ того,
[05:15.200 --> 05:19.040]  как вы строите архитектуру вашей программы. Действительно, разбивание на функции помогает
[05:19.040 --> 05:23.040]  улучшить читаемость кода, ну потому что вы по сути мейн можете описать в виде каких-то некоторых
[05:23.040 --> 05:28.160]  законченных инструкций. Например, считать вот, отсортировать, вывести на экран. Вот, если весь
[05:28.160 --> 05:32.520]  код считывания, сортировки, вывод на экран вы пишете в мейне, то в общем-то сложно разобраться,
[05:32.520 --> 05:36.800]  а что к чему относится. Тем более, если у вас программа очень большая. Вот. И действительно плюс
[05:36.800 --> 05:40.040]  гибкость. Если вам нужно изменить какой-то кусок кода, то есть вам нужно изменить, например,
[05:40.040 --> 05:44.800]  алгоритм сортировки, то вам необходимо просто залезть в функцию, которая собственно эту
[05:44.800 --> 05:50.760]  сортировку выполняет и изменить там необходимый код, необходимую строку и так далее. Вот. А если вы
[05:50.760 --> 05:54.520]  пишете все в мейне, то есть, грубо говоря, в императивном подходе, то у вас получается так,
[05:54.520 --> 05:58.200]  что вы допустим, вы функцию сортировки вызываете несколько раз. То есть, вам нужно отсортировать
[05:58.200 --> 06:01.680]  несколько массивов. Но тогда вам нужно просто в нескольких местах, то есть, найти все местах,
[06:01.680 --> 06:05.680]  где вы осуществляете сортировку и везде эту строку поменять. Согласитесь, это бред. Ну то есть,
[06:05.680 --> 06:10.280]  зачем следить за кодом, все читать и как бы исправлять везде, если можно завести одну функцию,
[06:10.280 --> 06:14.920]  в которой исправить какую-то ошибку и так далее. И тогда это исправление потянется во все остальные
[06:14.920 --> 06:23.160]  сущности, в которых вы эту сортировку используете. Да? Согласны? Вот. Ну и соответственно у нас есть
[06:23.160 --> 06:27.080]  три основные парадигмы программирования. Первая парадигма — это императивное
[06:27.080 --> 06:31.360]  программирование. То есть, это, грубо говоря, программирование путем просто программирования
[06:31.360 --> 06:36.160]  некоторых команд. То есть, вы просто пишете вашу программу как последовательность различных
[06:36.200 --> 06:41.240]  инструкций. Ну, различные языки поддерживают императивное программирование. И так далее.
[06:41.240 --> 06:46.560]  Вот. Дальше программирование, которое вы изучали в прошлом семестве, это было структурное
[06:46.560 --> 06:49.440]  программирование, то есть, программирование с использованием некоторых независимых,
[06:50.620 --> 06:54.360]  логически независимых кусков, то есть, функций. То есть, вы разбиваете вашу программу на функции,
[06:54.920 --> 07:00.160]  некоторые законченные действия, скажем, отсортировать то есть, найти с помощью бинарного поиска, сделать
[07:00.160 --> 07:04.400]  что-то еще, вывести, считать и так далее. И дальше вы, собственно, собираете вашу программу из вот этих
[07:04.400 --> 07:10.120]  вот самых логически независимых кусков, да. В этом смеси будем изучать другой подход,
[07:10.120 --> 07:13.960]  который называется объектно-ориентированным программированием. Смотрите, в чем отличие,
[07:13.960 --> 07:17.520]  ну так на пальцы, в чем отличие объектно-ориентированного подхода от структурного подхода.
[07:17.520 --> 07:21.640]  Когда вы программируете с помощью функций, вы, грубо говоря, программируете действия.
[07:21.640 --> 07:26.840]  То есть, грубо говоря, если вам нужно, не знаю, давайте опишем какое-то действие. Ну, например,
[07:26.840 --> 07:34.280]  ручка лежит на столе. Если вы хотите запрограммировать действие, чтобы ручка лежала
[07:34.280 --> 07:41.080]  на столе, вы пишете «лежать, ручка стол». То есть, есть действие «лежать», которое выполняется над
[07:41.080 --> 07:46.080]  ручкой столом. Но согласитесь, что в повседневной жизни мы рассуждаем не так. Когда мы строим
[07:46.080 --> 07:50.560]  предложения, у нас есть всегда некоторый актор, то есть, некоторый объект, который совершает действие,
[07:50.560 --> 07:57.280]  и есть некоторый объект, над которым он совершает действие. То есть, ручка, что делает, лежит на столе.
[07:57.280 --> 08:04.400]  Если вы программируете какую-то игру, вам очень удобно рассуждать в терминах каких-то абстрактных
[08:04.400 --> 08:10.080]  сущностей. Например, персонаж. Персонаж должен пойти из одной деревни в другую деревню, персонаж
[08:10.080 --> 08:14.300]  должен там что-то сделать и так далее. То есть, есть персонаж, который совершает некоторый набор действий.
[08:14.300 --> 08:23.000]  То есть, вы, например, сидите на лекции. Есть актор, то есть, абсубъект, который совершает действие,
[08:23.000 --> 08:28.720]  вы сидите на лекции. То есть вас никто не сидит на лекции. То есть я вас не стижу на лекции, я не заставляю вас переходить на лекции.
[08:28.720 --> 08:37.960]  Так? Так? Все, отлично. Вот. Ну и основные принципы, на которых строится объектно-ориентируемое
[08:37.960 --> 08:43.640]  программирование, это абстракция, инкапсуляция, полиморфизм и наследование. В общем-то, абстракция
[08:43.640 --> 08:48.280]  это про что? Абстракция это про то, что мы выделяем некоторые объекты из реального мира, то есть
[08:48.280 --> 08:52.680]  выделяем некоторые сущности или концепты и оформляем их в виде некоторого, ну, условного
[08:52.680 --> 08:56.160]  структура или классов, про которые мы сейчас поговорим. То есть мы вычленяем некоторые
[08:56.160 --> 09:00.960]  объекты из реального мира и программируем их в виде некоторых сущностей. При этом оставляют
[09:00.960 --> 09:05.040]  только значимые для нас характеристики. Ну, например, если вы хотите запрограммировать
[09:05.040 --> 09:10.480]  студента, то, наверное, не стоит программировать весь его код ДНК, весь его полвозраст, его
[09:10.480 --> 09:14.080]  родословную и так далее. То есть если вы программируете студента для какой-то базы данных, вам достаточно знать,
[09:14.080 --> 09:19.480]  на каком курсе он учится и какие предметы изучает. В общем-то, мы выделили основные сущности и используем
[09:19.960 --> 09:25.240]  этот объект. Дальше, инкапсуляция. Инкапсуляция — это про то, что на самом деле объекты обладают не
[09:25.240 --> 09:28.700]  только некоторыми свойствами или характеристиками. Вот давайте вернемся, скажем, в прошлость
[09:28.700 --> 09:32.440]  месяца, когда вы программируете структуру. Вот когда вы программируете структуру, вы, на самом
[09:32.440 --> 09:36.320]  деле объединяли между собой только данные. То есть, грубо говоря, у вас была у структуры, не знаю,
[09:36.320 --> 09:40.680]  что вы писали, стэк писали на связанном списке. Вот, значит, стэк что объединяет? Он связанный
[09:40.680 --> 09:45.880]  список. Точнее, узел связанного списка. Это некоторые данные, например, целое число, и плюс
[09:45.880 --> 09:49.120]  указатель на следующий узел. То есть мы объединили данные. Но при этом мы
[09:49.120 --> 09:52.560]  понимаем, что, например, stack — это не только как бы вот некоторая связка данных,
[09:52.560 --> 09:56.380]  ну и плюс действия, на которые можно с ними совершать. То есть объект обладает
[09:56.380 --> 09:59.480]  не только какими-то атрибутами или характеристиками, но и плюс может совершать
[09:59.480 --> 10:02.200]  какие-то действия. То есть мы конкретному объекту приписываем
[10:02.200 --> 10:06.080]  конкретные действия. Вот это про инкапсуляцию.
[10:06.080 --> 10:10.780]  Полиморфизм. Ну полиморфизм — это, если совсем коротко, то это один интерфейс
[10:10.780 --> 10:14.380]  много реализаций. Ну с полиморфизмом мы на самом деле уже знакомы, были знакомы
[10:14.380 --> 10:17.860]  еще в прошлом семестре, когда вы изучали, скажем, перегрузку функций. То есть
[10:17.860 --> 10:20.340]  перегрузка функций — это как раз с помощью одного интерфейса вы можете вызывать
[10:20.340 --> 10:24.340]  несколько реализаций. Ну, например, у вас есть функция с одним именем, но при этом
[10:24.340 --> 10:26.740]  можете принимать различное число аргументов. То есть вы по одному именю
[10:26.740 --> 10:30.940]  можете вызывать различные функции. Ну или шаблоны. Это тоже яркий пример полиморфизма.
[10:30.940 --> 10:34.660]  То есть вы используете общий интерфейс, и при этом вам не важно, как это все
[10:34.660 --> 10:37.900]  внутри реализовано. Самое главное, что это работает так, как вы ожидаете.
[10:37.900 --> 10:42.620]  Ну и наконец наследование. Ну про наследование мы подробно поговорим на
[10:42.620 --> 10:46.380]  отдельной лекции. То есть можно пока записать просто такое определение. Это просто
[10:46.380 --> 10:49.380]  некоторая свойство, которая позволяет создавать новые типы на основе уже
[10:49.380 --> 10:53.180]  созданных. То есть если вы знаете, то есть если у вас уже создан какой-то тип,
[10:53.180 --> 10:57.380]  который вы написали, вот, и вам хочется написать другой тип, который по свойствам
[10:57.380 --> 11:00.660]  очень близок к этому, то чтобы избирать там дублирование кода или как-то указать
[11:00.660 --> 11:03.500]  родственность этих двух типов, вы можете один наследовать от другого.
[11:03.500 --> 11:10.460]  Но об этом поговорим чуть позже. Вот. Ну и давайте поговорим про то, что такое
[11:10.460 --> 11:13.620]  класс. Класс – это тоже основная концепция объектно-ориентированного
[11:13.620 --> 11:16.580]  программирования. Значит, класс – это описание некоторого концепта из предметной
[11:16.580 --> 11:19.940]  области в виде набора полей и методов для работы с ними. Ну, грубо говоря, класс – это
[11:19.940 --> 11:23.780]  описание нового типа. То есть когда вы программируете, когда вы пишете код, вы
[11:23.780 --> 11:27.780]  хотите ввести в код какой-то новый тип. Вот. И описать какие действия над ним
[11:27.780 --> 11:30.780]  можно совершать, какие у него есть характеристики, атрибуты и так далее.
[11:30.780 --> 11:35.140]  Ну вот самый, например, давайте рассмотрим тот же самый пример со стеком. То есть
[11:35.140 --> 11:39.780]  здесь мы ввели на самом деле два класса. Первый класс – нод, то есть узел. Узел
[11:39.780 --> 11:43.100]  имеет две характеристики. Значение, которое он хранит, и указатель на следующий
[11:43.100 --> 11:49.020]  узел. И также мы ввели новый тип, стек, в виде структуры. Что мы здесь делали? Мы
[11:49.020 --> 11:53.100]  сказали, что стек состоит из указателя на вершину стека, то есть на самый верхний
[11:53.100 --> 11:59.180]  узел. И плюс, внимание, мы задали действие, которое можно совершать над стеком. Ну, я так
[11:59.180 --> 12:01.980]  понимаю, в прошлый раз вы не обсуждали, что внутри структуры можно писать какие-то
[12:01.980 --> 12:05.340]  функции. Так вот, я говорю, что на самом деле внутри структуры можно писать
[12:05.340 --> 12:08.420]  функции, которые описывают, ну, собственно, действия, которые можно ним совершать.
[12:08.420 --> 12:14.540]  Но, в частности, я говорю, что в стек можно добавить элемент pushIntValue. Из стека можно
[12:14.540 --> 12:20.180]  удалять элемент с помощью метода pop. Из стека можно взять верхний элемент с помощью метода
[12:20.180 --> 12:25.020]  top. Из стека можно очистить с помощью метода clear. И вот эти вот методы, на самом деле на
[12:25.020 --> 12:29.380]  ровне с полями структуры классов, можно вызывать с помощью точки. То есть, скажем,
[12:29.380 --> 12:36.900]  если у вас есть стек, то вы можете через точку вызвать top. Что это будет означать?
[12:36.900 --> 12:42.380]  Это будет означать, что у данного стека нужно взять вершину. Или если вы напишете
[12:42.380 --> 12:50.540]  stack.push единица, то это значит, что в данный стек нужно вставить единицу. То есть, вот ровно
[12:50.540 --> 12:54.660]  про то, что я говорил. То есть, у нас есть некоторый объект, и мы над этим объектом
[12:54.660 --> 12:59.900]  можем совершать конкретные действия. Мы говорим, стек запушь в себя единицу. Понятно?
[12:59.900 --> 13:07.780]  Ну и здесь, да, собственно, тот пример, который я сказал. Ну и еще одно определение. Объект
[13:07.780 --> 13:12.460]  — это экземпляр класса. То есть, грубо говоря, если класс — это тип, то объект — это, ну,
[13:12.460 --> 13:16.740]  собственно, экземпляр типа. То есть, переменная, которую вы создаете с данным типом. То есть,
[13:16.740 --> 13:24.900]  есть класс и есть объект. Так, надо следить за памятью. Еще что?
[13:24.900 --> 13:34.420]  Вот, давайте сейчас скажу. Действительно, у нас, смотрите, стек, он по сути разделен. То есть,
[13:34.420 --> 13:37.780]  у вас есть отдельная переменная, которая хранит буфер, и отдельная переменная хранит size. Чем
[13:37.780 --> 13:41.980]  это плохо? Ну, это плохо тем, что вам необходимо контролировать, какие две переменные связаны
[13:41.980 --> 13:46.860]  между собой. То есть, вам нужно следить за тем, что в push всегда приходил буфер и size от одного и
[13:46.860 --> 13:51.060]  того же стека. То есть, ничто вас не защитит от того, что вы подсунете ему size от совершенно
[13:51.060 --> 13:55.060]  другого стека или вообще подсунете ему совершенно другую перемену, которая с size не имеет
[13:55.060 --> 14:21.180]  никакого отношения. Еще. Ну, это правда, да, но это тоже алгоритмическая проблема. То есть,
[14:21.180 --> 14:26.220]  на чем стек реализовывать на списке или на массиве, это алгоритмическая часть. Меня больше интересует
[14:26.220 --> 14:32.020]  архитектурная. Ну, действительно. То есть, нужно постоянно таскать за собой указатель. Нужно
[14:32.020 --> 14:35.460]  постоянно за собой таскать размер. Нужно самостоятельно работать с памятью. То есть,
[14:35.460 --> 14:39.700]  выделять память и очищать память. Плюс необходимо самостоятельно имитализировать размер. То есть,
[14:39.700 --> 14:44.580]  что делать, если у вас пустой стек, а вы указали изначально размер равным 10? Ну, тоже ошибка. И при
[14:44.580 --> 14:48.820]  этом за этим никто не следит. И при этом в любой момент, самое главное, вы имеете несанкционированный
[14:48.820 --> 14:53.500]  доступ к данным. Вот, смотрите, давайте посмотрим на main. Что мне должно мешать, кроме совести,
[14:53.500 --> 14:59.540]  обратиться к элементу stackBuffer. Ничего мне не мешает. Я просто могу взять и скажем, ну, несмотря на
[14:59.540 --> 15:03.300]  то, что у меня стек, я могу обратиться куда-то в середину, куда-то в конец, в начало и изменить
[15:03.300 --> 15:07.980]  совершенно свободные свои элементы. Согласны? Хотя, на самом деле, стек не предполагает такого
[15:07.980 --> 15:14.700]  функционала. Вот. И плюс философский вопрос. А что такое вообще stack? Где в данной программе stack?
[15:14.700 --> 15:19.860]  Вот такой сущности как stack в данной программе в принципе не существует. То есть, нельзя сказать,
[15:19.860 --> 15:23.980]  вот где stack? Ну, можно сказать, что это вот и указатель и size, но при этом вот такой вот
[15:23.980 --> 15:29.460]  единой сущности закончено, ее нет. То есть, непонятно, что такое stack. Либо это сам буфер,
[15:29.460 --> 15:34.100]  либо и размер массива, либо вот сами функции push, pop и т.д. Вообще ничего непонятно. Вообще
[15:34.100 --> 15:38.780]  непонятно, существует ли stack в вашей программе или нет. Теперь давайте посмотрим, как бы то же
[15:38.780 --> 15:43.860]  самое можно было реализовать с помощью объектно-ориентированного подхода. С помощью объектно-ориентированного
[15:43.860 --> 15:47.420]  подхода, еще раз повторюсь, это программирование типов. То есть, вы программируете новый тип. Вот
[15:47.420 --> 15:53.980]  давайте заведем новый тип stack. Значит, что такое stack? То есть, если мы реализуем stack на массиве,
[15:53.980 --> 15:57.620]  что он должен хранить внутри себя? Ну, понятное дело, он должен хранить сам массив, то есть,
[15:57.620 --> 16:02.780]  указатель на массив буфер. Дальше он должен хранить размер. И дальше мы указываем набор операций,
[16:02.780 --> 16:07.580]  которые допустимы над stack'ом. То есть, опять же напомню, вот эти функции, которые мы пишем
[16:07.580 --> 16:12.620]  внутри структуры, называются методами. Смотрите, мы заводим отдельный метод init, который просто берет
[16:12.620 --> 16:18.940]  вот эти вот поля нашей структуры, инициализирует с помощью выделения памяти, и size инициализирует
[16:18.940 --> 16:22.820]  нулем. Нам теперь не нужно думать о том, чтобы самостоятельно как-то отдельно инициализировать
[16:22.820 --> 16:27.060]  буфер и size. Все инициализируется в одной отдельной функции. Дальше есть отдельный метод finalize,
[16:27.060 --> 16:31.620]  который делает необходимые действия по очищению stack'а. В частности, просто удаляет буфер. Ну и дальше
[16:31.620 --> 16:37.740]  есть методы push, которые добавляют элементы в наш массив, в наш stack. Pop, которые удаляют верхний
[16:37.740 --> 16:43.460]  элемент из нашего stack'а, и top, который берет верхний элемент. И дальше давайте посмотрим на main.
[16:43.460 --> 16:49.300]  Как выглядит main? В main выглядит чисто и аккуратно. Мы создали переменную stack, дальше что сделали?
[16:49.300 --> 16:53.540]  Пронициализировали его, запушили туда единицу, получили верхний элемент, удалили верхний элемент
[16:53.540 --> 16:58.540]  и очистили наш массив. Все просто и понятно. То есть, нам теперь не нужно следить за тем, что мы правильно
[16:58.540 --> 17:03.500]  передаем нужные указатели, правильно передаем нужный размер и так далее и так далее. Все делается за
[17:03.500 --> 17:07.860]  нас. То есть, все скрытое, грубо говоря, внутри реализации. Вот то, про что мы говорили. Инкапсуляция.
[17:07.860 --> 17:13.220]  То есть, мы объединили данные и методы для работы с ними и, грубо говоря, не видим реализации. То есть,
[17:13.220 --> 17:20.820]  мы видим чистый код и понятный. Мы, по сути, решили большинство проблем и осталась единственная
[17:20.820 --> 17:24.780]  проблема. И это мы, на самом деле, в любой момент все еще имеем несанкционированный доступ к данным.
[17:24.780 --> 17:32.780]  Согласны? Ну почему? Потому что ничто мне не мешает все еще сделать, например, вот такую штуку stack.size
[17:32.780 --> 17:40.700]  равно миллион. Но если у нас структура, то мы в свободном можем обращаться к полям. И никто
[17:40.700 --> 17:45.020]  мне этого не запретит. Нужна некоторая защита от дурака. Наверное, хотелось бы, чтобы такое тоже
[17:45.020 --> 17:49.420]  было запрещено. То есть, если я указал действия, которые необходимы, которые можно совершать над
[17:49.420 --> 17:53.860]  stack, то есть push, pop и top, наверное, хочется, чтобы пользователь совершал только эти действия и
[17:53.860 --> 18:01.180]  ничего другого он сделать не мог. Естественное желание? Ну давайте об этом поговорим. Следующая
[18:01.180 --> 18:07.420]  тема это модификаторы доступа. Значит, классам и структурам можно писать модификаторы доступа.
[18:07.420 --> 18:12.580]  Самые главные модификаторы доступа, на которые стоит обратить внимание, это public и private.
[18:12.580 --> 18:18.020]  Но если совсем коротко, то public разрешает доступ вообще всем, то есть все могут обращаться к данным
[18:18.020 --> 18:24.780]  полям и методам. А private всем запрещает. Теперь подробнее. Да, ну давайте про синдексис поговорим.
[18:24.780 --> 18:28.900]  Значит, когда вы пишете структуру, вы в какой-то момент можете написать модификатор доступа. Ну,
[18:28.900 --> 18:33.860]  грубо говоря, public или private. И вот начиная с этого момента, вот весь код, который написан здесь,
[18:33.860 --> 18:40.020]  он, грубо говоря, становится публичным. Все могут обращаться к данным полям и методам. В какой-то
[18:40.020 --> 18:45.580]  момент вы можете захотеть поменять. Точнее, тут был приватный, то есть вы запретили всем, когда вы
[18:45.580 --> 18:49.740]  пишете приватную область, вы запрещаете всем обращаться к данным полям и методам. Теперь эта область
[18:49.740 --> 18:55.660]  никому не доступна, кроме самой структуры. Потом в какой-то момент вы можете поменять свое желание,
[18:55.660 --> 18:59.140]  вы можете сказать, что нет. Теперь вот, начиная с этого момента, все остальное должно быть публичным.
[18:59.140 --> 19:08.060]  Теперь вот это вот все приватное, а вот это все публичное. Если совсем коротко. Что? Вот, да, то, что
[19:08.060 --> 19:12.180]  сверху. Об этом поговорим чуть позже, но давайте я сразу скажу, что тут по умолчанию все публичное.
[19:12.180 --> 19:15.460]  Ну, об этом можно было догадаться, то есть вы раньше писали структуру, ничего не писали,
[19:15.460 --> 19:21.980]  поэтому по умолчанию в структурах все публичное. Так, какие вообще можно писать модификаторы доступа?
[19:21.980 --> 19:26.820]  На самом деле их всего три. Ну, первое публичное, самое простое. Всем все можно, то есть можно
[19:26.820 --> 19:32.900]  обращаться к полям, к методам и вообще всему, что написано там внутри. Приватное. Доступ имеет
[19:32.900 --> 19:37.100]  только поля и методы самого класса, а также дружественные функции класса. Вот про дружбу мы
[19:37.100 --> 19:42.460]  поговорим чуть позже, но пока можно запомнить то, что, в общем, если вы объявили область приватной,
[19:42.460 --> 19:46.100]  то туда никто не имеет права обращаться, то есть никто не имеет права даже знать, что там что-то
[19:46.100 --> 19:50.980]  находится. То есть вы, грубо говоря, закрыли ровно то, чего мы и хотели до этого. Ну, есть Protected,
[19:50.980 --> 19:55.020]  пока давайте считать, что Protected то же самое, что и Private. На самом деле, Protected действует
[19:55.020 --> 19:58.260]  чуть иначе, когда речь идет про наследование, но про наследование мы поговорим примерно через
[19:58.260 --> 20:03.780]  две лекции, поэтому давайте пока считать, что Protected то же самое, что и Private. Ну, и два правила,
[20:03.780 --> 20:07.940]  располагать модификаторы доступа можно в любом порядке, в любом количестве, то есть вы можете
[20:07.940 --> 20:14.620]  написать, не знаю, public, потом внезапно сразу еще раз написать public, потом снова написать public,
[20:14.620 --> 20:21.820]  потом поменять на private, потом снова поменять на public и так далее. То есть между собой вы можете
[20:21.820 --> 20:26.780]  менять как угодно. Главное, что вот между вот этими объявлениями, то есть между вот этими словами
[20:26.780 --> 20:32.900]  у вас либо публичная, либо приватная область, точнее так, которая написана выше. Ну, и модификатор
[20:32.900 --> 20:37.540]  действует с точки объявления до следующего модификатора, то есть от public до public, от public
[20:37.540 --> 20:42.580]  до private и от private до public. Ну и, соответственно, либо до конца класса, то есть после последнего
[20:42.580 --> 20:50.260]  public, все до конца класса или структура будет публичным. Это понятно, да? Ну и давайте упражнения,
[20:50.260 --> 20:56.500]  посмотрим на то, как это работает. Значит, у меня есть структура S, у меня там есть поле
[20:56.500 --> 21:02.980]  int x и есть еще два int поля y и z, которые объявлены в приватной области. Есть приватная функция f,
[21:02.980 --> 21:08.500]  точнее метод f, который внутри себя устанавливает x равным 0 и y равным 0. И есть публичный метод g,
[21:08.500 --> 21:12.700]  который внутри себя x устанавливает равным 0 и z устанавливает равным 1. Значит, вопрос,
[21:12.700 --> 21:22.900]  есть ли тут ошибки импиляции? Все ли строки хорошо сработают? Так, здесь не будет работать?
[21:22.900 --> 21:33.820]  Что еще не будет работать? Так, давайте разберемся z. Кто считает, что z не будет работать?
[21:34.060 --> 21:46.220]  В общем, вы не правы, z будет работать. Смотрите, на самом деле, это пример как раз про то,
[21:46.220 --> 21:52.900]  что внутри структуры паблик и private не имеют никакого значения. Ну сама структура естественным
[21:52.900 --> 22:12.740]  образом имеет доступ ко всему, вообще ко всему. Обычные переменные? В структурах по умолчанию все
[22:12.740 --> 22:18.460]  публичное. Если у вас ничего сверху не написано, то это публичное в структурах. То есть мораль тут
[22:18.460 --> 22:25.780]  такая, что модификаторы доступа внутри структуры, грубо говоря, не действуют. Понятно дело, что структура
[22:25.780 --> 22:29.980]  s сама себя реализует, она имеет свои характеристики, она реализует свое метод. Естественно, она должна
[22:29.980 --> 22:34.980]  иметь доступ ко всему. То есть как-то странно, что вы внутри структуры объявили что-то приватным,
[22:34.980 --> 22:38.940]  и сама эта структура не имеет права к этому обращаться. Вопрос, кто имеет вообще права к
[22:38.940 --> 22:44.700]  этому обращаться? Зачем тогда вообще задавали эту переменную? Публичные приватные модификаторы
[22:44.700 --> 22:48.900]  доступа имеют смысл только для внешнего кода. То есть вы выставляете, грубо говоря, требования на
[22:48.900 --> 22:54.060]  внешний код. То есть внешний код имеет право к этому обращаться, а к этому не имеет права. Но при этом,
[22:54.060 --> 22:58.620]  так как структура всем этим владеет, она, собственно, имеет право с этим обращаться как угодно. И неважно
[22:58.620 --> 23:03.420]  в каком это методе, в публичном или приватном. То есть поэтому во всех этих трех, точнее во всех
[23:03.420 --> 23:09.180]  этих четырех строках, все работает как надо. То есть функция f устанавливает x и y в ноль,
[23:09.180 --> 23:18.300]  и функция g устанавливает x и z в ноль. Все понятно. А теперь пример со внешним кодом. Значит,
[23:18.300 --> 23:23.940]  рассмотрим структуру s. У нее есть публичное поле x, ну так у нас сверху ничего не написано, и публичные
[23:23.940 --> 23:30.420]  методы g и h. h принимает int, g ничего не принимает. Есть приватная область, в которой объявлено
[23:30.420 --> 23:37.460]  поле y и два метода f и h, который принимает double. Давайте по порядку. Могу ли я из main обратиться к
[23:37.460 --> 23:44.140]  полю x? Да, поле x публичное, поэтому тут мне все разрешено. Могу ли я обратиться к полю y? Нет,
[23:44.140 --> 23:48.860]  а вот тут не могу. И вот это, собственно, главное значение private. Если вы считаете, что данное поле
[23:48.860 --> 23:54.860]  является частью реализации, ее никто не должен трогать. То есть вы считаете, что если это поле
[23:54.860 --> 24:00.540]  кто-то исправит, как-то изменит, и это нарушит работу вашего класса или структуры, то вы
[24:00.540 --> 24:04.780]  должны объявить это поле приватным. Соответственно, здесь так и сделано. Мы объявили поле y приватным,
[24:04.780 --> 24:10.140]  и к нему никто не имеет права обращаться, кроме самого самой структуры. Дальше. Имеем ли право
[24:10.140 --> 24:16.260]  вызывать метод f? Нет. Метод f тоже приватный, то есть он является частью реализации, он не является
[24:16.260 --> 24:21.580]  частью публичного интерфейса. То есть, грубо говоря, не знаю, как телефон. Вот есть публичный
[24:21.580 --> 24:25.660]  интерфейс, там в нем есть камеры, есть, условно, сенсоры, которые позволяют. Еще у него внутри
[24:25.660 --> 24:30.020]  есть процессор, но непосредственно к процессору я обратиться не могу. То есть он там есть, но это
[24:30.020 --> 24:37.500]  часть реализации, это грубая приватная область. Понятно? Вот. Могу ли обращаться к g? К g могу,
[24:37.500 --> 24:43.340]  это публичный метод. Могу ли я вызывать h от нуля? Да, это h от int могу обращаться. Могу ли
[24:43.340 --> 24:52.300]  вызывать h от 0.0? Но у меня же есть публичный h от int. Вот главный вопрос, будет ли тут
[24:52.300 --> 25:02.940]  переобразование или нет? Вот на самом деле нет. Вот на это прошу обратить внимание. На последнюю
[25:02.940 --> 25:09.780]  строку прошу обратить внимание. Этот пример показывает следующее. Как вообще принимается
[25:09.780 --> 25:15.260]  решение, что публичное, что приватное? Смотрите, сначала компилятор выбирает функцию, которую вы
[25:15.260 --> 25:18.420]  вызвали. То есть она определяется с функцией, то есть выбирает перегрузку. То есть в данном случае
[25:18.420 --> 25:23.260]  метод h перегружен. То есть есть метод, который вызывается от int, есть метод, который вызывается
[25:23.260 --> 25:31.020]  от дабла. В данном случае вы h вызвались от дабла. Соответственно сначала компилятор понимает,
[25:31.020 --> 25:36.580]  что вы хотите на самом деле вот этот вот метод. То есть между h от int и h от double, h от double
[25:36.580 --> 25:42.700]  обладает точным соответствием, поэтому выбирается он. А уже потом компилятор начинает думать,
[25:42.700 --> 25:47.660]  а вообще может ли пользователь вызывать этот метод или нет. В данный момент оказывается,
[25:47.660 --> 25:52.740]  что не может, и он выдает ошибку компиляции. То есть порядок следующий. Сначала выбирается
[25:52.740 --> 26:05.900]  перегрузка, а только потом проверяются доступы. Понятно? Объявить функции вы можете внутри
[26:05.900 --> 26:09.660]  структуры. А вот про определение мы сейчас поговорим. Определить можно и вне структуры.
[26:17.660 --> 26:24.220]  Не-не-не. Вот перескальки он не будет. Он выберет h от double, и в этот момент у него будет паника,
[26:24.220 --> 26:30.140]  потому что вы лезете туда, куда вам не нужно. То есть он выдаст ошибку, что-то типа h от double,
[26:30.140 --> 26:41.580]  ну короче из private, in this context. Ну что-то наподобие такого он напишет. Впрочем он просто
[26:41.580 --> 26:46.700]  скажет, что метод приватный, вы не имеете права к нему обращаться. То есть h от int он не будет,
[26:46.700 --> 26:51.700]  то есть он будет его рассматривать на этапе выбора перегрузки, но по итогу выберите h от double,
[26:51.700 --> 26:58.340]  и вот в этот момент будет ошибка доступа. При этом h от int можно спокойно выбирать,
[26:58.340 --> 27:01.460]  почему? Потому что h от double тоже будет рассматриваться, то есть он будет видеть,
[27:01.460 --> 27:05.620]  что у вас есть h от int, и у вас есть h от double. Но по итогу будет выбран h от int, потому что вы
[27:05.620 --> 27:10.260]  вызываетесь от int. А h от int можно спокойно вызывать так, как он публичный. То есть выбор
[27:10.260 --> 27:13.300]  перегрузки, а потом только проверка доступа. Именно в таком порядке.
[27:13.300 --> 27:23.940]  Если был h от float, все равно вызывался бы h от double, потому что 0.0 это литерал типа double.
[27:23.940 --> 27:31.460]  Ну и возвращаемся к тому примеру, который мы писали до этого, то есть stack на массиве.
[27:31.460 --> 27:36.700]  То есть теперь как выглядит примерно правильная реализация stack? То есть мы определяем методы
[27:36.700 --> 27:41.020]  в публичной области. То есть мы говорим, что со stack нужно обращаться так. Можно вызывать
[27:41.020 --> 27:45.620]  метод int, можно вызывать метод finalize, можно что-то добавлять stack, можно из него что-то удалять,
[27:45.620 --> 27:49.900]  можно получать верхний элемент, и можно спрашивать его размер. А к чему нельзя обращаться?
[27:49.900 --> 27:56.340]  А нельзя обращаться к буферу и к size. Это детали реализации, тебе это не надо. И если вы из
[27:56.340 --> 28:01.060]  main попробуете обращиться к size, даже обратиться, то есть не просто как-то изменить, а просто считать
[28:01.060 --> 28:05.620]  его, у вас ничего не получится. То есть у вас правил этот запрет не только на модификацию,
[28:05.620 --> 28:10.540]  но вообще в принципе на доступ, на чтение. То есть если вы обратитесь непосредственно к size,
[28:10.540 --> 28:13.780]  то у вас возникнет вот такая ошибка. Исправить within this context.
[28:13.780 --> 28:26.460]  Ну и до этого я часто говорил слово class, структуру и так далее. Ну в общем, смотрите,
[28:26.460 --> 28:30.540]  class это концепция объектно-ориентированного программирования. То есть объектно-ориентированное
[28:30.540 --> 28:33.220]  программирование просто такая теоретическая штука, которая описывает, ну собственно,
[28:33.220 --> 28:37.700]  парадигму программирования. Ну и там принято такая формировка как class. На самом деле структуры,
[28:37.700 --> 28:43.700]  с точки зрения теории ООП, тоже являются классами. И не стоит путать его с ключевым словом class,
[28:43.700 --> 28:50.220]  которое есть в языке C++. В языке C++ есть ключевое слово class, которое обозначает буквально то же
[28:50.220 --> 28:57.460]  самое, что и структура. То есть слова struct и class взаимозаменяемые. Но у них есть два отличия.
[28:57.460 --> 29:01.900]  Первое отличие заключается в том, что, как мы говорили до этого, в структурах по умолчанию
[29:01.900 --> 29:08.700]  всё публичное. А вот в классах по умолчанию всё приватное. Вот это первое и самое главное отличие.
[29:08.700 --> 29:13.900]  В структурах всё публичное по умолчанию, в классах по умолчанию всё приватное. То есть если вы не
[29:13.900 --> 29:17.900]  писали никакого модификатора доступа, то в классах у вас всё будет приватным. Ну и второе правило,
[29:17.900 --> 29:22.020]  тоже оно связано с наследованием, ну в общем об этом отдельно поговори, ну давайте.
[29:22.020 --> 29:30.660]  Ну смотрите, структ пришёл нам из языка C. В языке C не было никаких модификаторов доступа.
[29:30.660 --> 29:36.900]  А class это концепцию OP, поэтому в языке C++ было добавлено ещё слово class. Ну чтобы было
[29:36.900 --> 29:40.340]  понятней, что мы действительно объявляем class как концепцию объектной ретиропрограммирования.
[29:40.340 --> 29:44.900]  Ну собственно, да, про второй пункт. Классы наследуют по умолчанию приватным образом,
[29:44.900 --> 29:50.420]  а структуры публичным. Что бы это не значило? Об этом поговорим потом. Ну и на самом деле,
[29:50.420 --> 29:57.060]  как правило, если вы пишете именно class, то есть как набор методов, полей и методов для работы с
[29:57.060 --> 30:02.700]  ними, то есть вот так как мы писали stack, обычно пишут class. То есть если вы пишете class, пишите
[30:02.700 --> 30:08.060]  class. Структуры используют в том понимании, в котором вы их использовали в предыдущем
[30:08.060 --> 30:11.340]  семестре. То есть если вам нужна структура просто чтобы объединить какие-то данные,
[30:11.340 --> 30:15.860]  ну просто объединить какие-то данные, то есть допустим у вас функция должна возвращать,
[30:15.860 --> 30:23.540]  не знаю, bool и int. Тогда вы просто объединяете их в структуру и возвращаете совместно. Если вы
[30:23.540 --> 30:27.340]  хотите описать именно новый тип, как набор действий и так далее, то вы пишете class,
[30:27.340 --> 30:31.900]  но это просто некоторые соглашения. Поэтому вот с этого момента мы будем писать только class.
[30:31.900 --> 30:46.580]  Да, то есть если, ну смотрите, вот если вы написали stack таким образом и не написали ни public,
[30:46.580 --> 30:50.180]  ни private, ничего, то внутри stack вы вообще никак не можете обратиться. То есть такой
[30:50.180 --> 30:54.260]  класс, к которому вообще нельзя обращаться. В смысле его можно создать, но при этом внутри
[30:54.260 --> 30:59.140]  него ни к чему нельзя обратиться. Поэтому для класса нужно обязательно в какой-то момент
[30:59.140 --> 31:08.740]  прописать public, если вы хотите его использовать. Теперь вот про то, что вы говорили, про определение
[31:08.740 --> 31:17.780]  вне классов. Ну как и обычные функции, методы можно сначала объявить, то есть методы это те
[31:17.780 --> 31:21.700]  функции, которые мы пишем внутри структуры или класса. Значит, методы можно сначала объявить,
[31:21.700 --> 31:26.460]  а реализацию написать где-нибудь еще. Ну, грубо говоря, в отдельном файле. Вот на семинаре вы
[31:26.460 --> 31:30.380]  должны были изучать, как разделять вашу программу на заголовочные файлы, на файлы реализации.
[31:30.380 --> 31:36.260]  Можно структуру класса писать так. Сначала писать все объявления в заголовочном файле,
[31:36.260 --> 31:42.500]  а все определения писать в CPU файле. Как это делается? Вот мы записали структуру S. Это объявление
[31:42.500 --> 31:48.980]  структуры. То есть мы объявили структуру и объявили метод, который есть внутри него. В данном случае
[31:48.980 --> 31:54.460]  этот метод F. Теперь этот метод F мы можем определить. Мы можем его определить непосредственно
[31:54.460 --> 31:59.740]  внутри структуры, то есть написав здесь фигурные скобки и дальше написав, что мы хотим делать. А можно
[31:59.740 --> 32:05.300]  написать вне структуры или вне класса. Делается таким образом. Вы пишете, собственно, прототип
[32:05.300 --> 32:11.060]  данной функции, то что она возвращает void, то что она ничего не принимает. С единственным отличием вы
[32:11.060 --> 32:17.300]  пишете полное имя, так называемое полное имя вашей функции. А полное имя вашей функции состоит из имени
[32:17.300 --> 32:23.220]  класса, двоеточие, двоеточие и дальше имя метода. То есть вы говорите, что вы определяете функцию F,
[32:23.220 --> 32:34.940]  которая объявлена внутри класса. Дальше вы пишете саму реализацию. Все как обычно. Альтернативно
[32:34.940 --> 32:40.540]  вы можете сделать определение непосредственно внутри структуры. В чем отличие определение внутри
[32:40.540 --> 32:47.660]  структуры или определение вне структуры? Отличие одно. Если вы пишете определение внутри структуры или
[32:47.660 --> 32:56.860]  класса, то эти функции не явно определяются как inline. Все помните, что такое inline? Inline так
[32:56.860 --> 33:03.580]  называемые встраиваемые функции. В общем, раньше смысл встраиваемых функций был такой, что их код
[33:03.580 --> 33:07.940]  просто берется, непосредственно поставляется вместо вызова, то есть не происходит переключение
[33:07.940 --> 33:13.020]  контекста и так далее. Сейчас inline используют для того, чтобы нарушать правила одного определения.
[33:13.020 --> 33:18.140]  То есть вы знаете, что функции в программе могут существовать только в единственном экземпляре,
[33:18.140 --> 33:23.860]  то есть допускается только одно определение функции на всю программу. Но если вы для функции пишете
[33:23.860 --> 33:31.500]  inline, то это правило можно обойти. Inline говорит, что определение этой функции несколько
[33:31.500 --> 33:36.420]  определений, но при этом важно понимать, что у этой функции все определения должны быть одинаковые.
[33:36.420 --> 33:48.820]  В стандарте написано с точностью до токенов. Это такое специальное слово, которое говорит
[33:48.820 --> 33:52.900]  о том, что я хочу так. Это может быть полезно, если вы, например, пишете какую-нибудь короткую
[33:52.900 --> 33:57.540]  функцию, для которой вам не хочется отдельно писать объявление, для которой вам не хочется
[33:57.540 --> 34:02.020]  отдельно писать определение, то есть не хочется разделять ее на h и cpp файл. Вы можете написать
[34:02.020 --> 34:07.380]  определение функции в cpp файле и пометь ее как inline. И тогда эта функция будет присутствовать во
[34:07.380 --> 34:12.580]  многих экземплярах в различных cpp файлах, но при этом так и на inline все будет нормально.
[34:12.580 --> 34:23.620]  Впервые поступил интересный вопрос. Смотрите, все время до этого мы как-то ограничивали доступы,
[34:23.620 --> 34:27.060]  то есть ограничивали с помощью паблика и правила, и вот поступил вопрос, а можно ли,
[34:27.060 --> 34:32.820]  грубо говоря, запретить запись, но разрешить чтение, то есть я хочу создать поле, которое можно
[34:32.820 --> 34:38.020]  читать, но при этом перезаписывать нельзя. Вот напрямую так сделать невозможно, но есть такой
[34:38.020 --> 34:41.260]  специальный паттерн, называется Getter и Setter, то есть вы заводите некоторые специальные методы,
[34:41.260 --> 34:46.940]  которые позволяют либо устанавливать значение, закрытое поле в нужном вам значении, либо его
[34:46.940 --> 34:51.780]  читать. Вот, например, если у вас есть какой-то класс, и у него есть закрытое поле x, которое вы
[34:51.780 --> 34:54.740]  запретили изменять, то есть которое вы хотите запретить изменять, то при этом которое вы хотите
[34:54.740 --> 34:59.980]  разрешить читать. Вот, для этого вы в публичной области заводите специальный метод, условно
[34:59.980 --> 35:05.940]  называете его GetX, то есть получить x, и из него вы возвращаете x. Вот, и тогда с помощью этого метода
[35:05.940 --> 35:09.780]  вы в любой момент можете, то есть внешний код может в любой момент получить значение этого самого
[35:09.780 --> 35:19.500]  поля, но при этом на запись это поле, естественно, недоступно. Понятно? Ну, такой вот паттерн. Так,
[35:19.500 --> 35:27.980]  теперь давайте пойдем дальше. Поговорим про константность. Значит, константные поля. Ну,
[35:27.980 --> 35:34.420]  собственно, как и любые другие обычные переменные, поля можно объявлять константными. То есть у вас
[35:34.420 --> 35:38.980]  может быть поле x, которое неконстантное, может быть поле y, которое является константным n-том.
[35:38.980 --> 35:44.020]  Понятно дело, что как и любые другие константы, константные поля нужно инициализировать сразу
[35:44.020 --> 35:50.020]  при создании объекта. Как это делать правильно, мы поговорим уже на следующей неделе, когда будем
[35:50.020 --> 35:55.340]  говорить про конструкторы. Но пока на текущий момент правильный способ инициализировать
[35:55.340 --> 35:59.220]  константы, это просто непосредственно при объявлении структуры прописать его дефолтные
[35:59.220 --> 36:04.740]  значения. Ну, сейчас я хочу, чтобы у меня было константное поле, которое равно 9. Естественно,
[36:04.740 --> 36:09.300]  такие поля изменить нельзя. То есть, если это поле констант, его изменить нельзя. Вообще никак. Вот
[36:09.300 --> 36:15.060]  эту мысль запомните, она важная. В константной поля никак изменить нельзя. Вот вообще. Даже с
[36:15.060 --> 36:22.100]  помощью того, что мы будем рассматривать дальше. Вопрос? Кост-каст. Ну, кост-каст это запрещенный
[36:22.100 --> 36:29.780]  способ. Вы что, рот смылом-то помойте. Зачем? Нет, короче, нельзя. Ну, короче, если вы объели
[36:29.780 --> 36:40.700]  константы, значит нельзя. В принципе, нельзя. Окей. Ну и простое упражнение. Смотрите, у меня
[36:40.700 --> 36:46.820]  есть структура S, у которой есть публичное поле X и публичное константное поле ID. Которое просто,
[36:46.820 --> 36:51.060]  при создании нового объекта, оно получает некоторый новый уникальный номер. Ну, уникальный номер
[36:51.060 --> 36:55.580]  пусть хранится в глобальной, какой-то глобальной области. То есть, у меня есть N. И при каждом
[36:55.580 --> 37:02.900]  создании объекта у меня N записывается в константное поле ID и увеличивается на единицу. Вот. И у меня
[37:02.900 --> 37:07.220]  есть метод F, который пытается увеличить X на единицу и пытается увеличить ID на единицу. Что здесь
[37:07.220 --> 37:13.100]  не так? Да, ID изменить нельзя. ID это константное поле, поэтому его никто никогда изменить не может.
[37:13.100 --> 37:23.020]  Даже внутри метода. Так, теперь посмотрим на внешний код. Вот когда я объявил S от A, у меня у A ID
[37:23.020 --> 37:30.780]  стал равным нулю. Когда я объявил B, точнее, определил B, у меня ID стал равным единице. При этом я не
[37:30.780 --> 37:35.740]  изменял ID, я их проинициализировал. Понятно? То есть, при создании объекта у меня отработал вот этот
[37:35.740 --> 37:48.460]  код и ID проинициализировался. Все. Могу ли я обратиться к A.X и B.X? Почему нет? Или почему да?
[37:49.180 --> 37:55.360]  Может быть, я там не могу этого? Да, во-первых, потому что x публичная. А во-вторых, потому что x не константная.
[37:55.360 --> 38:00.320]  Точнее так. Я обратится, как Normally parfois могу, потому что он публичный. А изменить его
[38:00.320 --> 38:08.920]  могу, потому что он не константный. А к ID я могу обратиться таким образом? Да, снова, ID публичный,
[38:08.920 --> 38:12.620]  поэтому обратиться-то я могу. Но то есть 對, прочитать его я могу. Но, при этом присвоить ему
[38:12.620 --> 38:16.940]  какое-то значение, или его как-то изменить не могу, поэтому да, здесь ничего не работает.
[38:16.940 --> 38:29.220]  Понятно? Ну, с константными полями все просто. В общем, они ведут себя так же, как и обычные
[38:29.220 --> 38:35.500]  константные. Вот теперь новая сущность, константные методы. Короче, методы или функции,
[38:35.500 --> 38:40.500]  которые написаны внутри классов, на самом деле тоже можно объявить константными. Какой в этом
[38:40.500 --> 38:47.820]  смысл? Смотрите. Давайте вспомним класс stack, который мы буквально недавно написали, ну и посмотрим
[38:47.820 --> 38:53.100]  на реализацию метода size. Что делает метод size у stack? Он просто возвращает размер stack. Согласно,
[38:53.100 --> 38:58.380]  да? То есть size это приватный член, но чтобы получить к нему доступ на члене, я его возвращаю
[38:58.380 --> 39:04.100]  из специального метода size. Окей? Вот. Ну и теперь давайте посмотрим такой момент. Смотрите,
[39:04.100 --> 39:09.700]  я build stack. Ну как-то с ним поработал, что-то в него запушил, там как-то провел над ним необходимые
[39:09.700 --> 39:15.700]  действия. А потом, допустим, создал на него константную ссылку. Ну, что такое константные ссылки, думаю,
[39:15.700 --> 39:20.700]  помните, да? Просто создал ссылку на S. И даже через эту константную ссылку попытался узнать,
[39:20.700 --> 39:26.060]  какой размер у меня у stack S. И внезапно получил довольно странную ошибку. Что-то там passing,
[39:26.060 --> 39:32.980]  какой-то констек, что-то там this и дискарс какие-то qualifiers. Ничего не понятно. Ну, так или иначе,
[39:32.980 --> 39:37.340]  видимо, проблема в том, что у меня, ну то есть, судя по ошибке, проблема в том, что у меня с ref
[39:37.340 --> 39:41.860]  это константная ссылка, и у константной ссылки я попытался что-то сделать. Так это что получается,
[39:41.860 --> 39:47.740]  если у меня объект константный, то я у него не могу вызвать никакие методы? В чем проблема, как вы думаете?
[39:47.740 --> 39:56.900]  Ну, а какая разница? Ну, хорошо, не сказали. Ну, как бы компилятор, он же, ну, смотрите,
[39:56.900 --> 40:02.940]  у нас есть метод size, он ничего не изменяет, на констанцию это не влияет. В чем может быть проблема?
[40:02.940 --> 40:14.260]  Да, отлично. Действительно, методы, в общем случае, могут что-то изменить. То есть, компилятор,
[40:14.260 --> 40:18.060]  смотрите, как действует компилятор. Вот компилятор, когда читает ваш код, он же, на самом деле,
[40:18.060 --> 40:21.660]  вот когда вы вызываете функцию, он же не лезет в ее определение, не смотрит, а что вы там делаете,
[40:21.660 --> 40:25.720]  интересно, давайте я посмотрю, что он там замышляет, этот пользователь. Нет, он просто
[40:25.720 --> 40:32.900]  видит метод на точку вызова, вот, с ref.size и смотрит, можно ли вызывать size с помощью пустых круглоскобок,
[40:32.900 --> 40:37.540]  ну, кажется, да, можно. Что возвращает size? int. Ну, как бы, пользователь не сохранит это, ну ладно,
[40:37.540 --> 40:42.180]  бог с ним. Но при этом он не будет лезть во внутрь этого метода и интересоваться, а меняет ли что-то
[40:42.180 --> 40:47.620]  этот метод или нет. То есть, у компилятора всегда паника в этот момент. Вы у константного метода
[40:47.620 --> 40:54.380]  вызываете метод, метод может что-то изменить, все, нельзя. То есть, проблема в том, что методы могут
[40:54.380 --> 41:02.860]  что-то изменить. Поэтому у константных объектов просто так методы вызывать нельзя. А как это
[41:02.860 --> 41:06.820]  их можно вызывать? Точнее, какие методы можно вызывать? А можно вызывать константные методы.
[41:06.820 --> 41:13.480]  Смотрите, если вы хотите, компилятору, сказать, что этот метод, ну то есть, вы хотите поклястся
[41:13.480 --> 41:17.500]  к компилятору, что вот этот метод точно ничего не будет менять. Все будет нормально. В общем, вызывая
[41:17.500 --> 41:22.260]  этот метод у константных метод, у константных объектов спокойно, вы должны написать ключевое
[41:22.260 --> 41:30.260]  слово const. После прототипа функции. То есть, вы пишете название метода и дальше приписываете
[41:30.260 --> 41:34.260]  И вот это слово const является такой успокоительной таблеткой для компилятора.
[41:34.260 --> 41:38.260]  То есть вы говорите, что этот метод спокойно можно вызывать у константных объектов.
[41:38.260 --> 41:42.260]  Он ничего менять не будет. И вот теперь предыдущий пример будет спокойно работать.
[41:42.260 --> 41:48.260]  То есть компилятор увидит метод size, поймет, что этот метод size вы вызываете от константного объекта,
[41:48.260 --> 41:53.260]  увидит, что этот метод сам константный, то есть вы поклеились ничего не менять, и все будет нормально.
[41:53.260 --> 41:57.260]  Предвосхищаю вас в вопрос, а можно ли на самом деле что-то там изменить?
[41:57.260 --> 42:02.260]  Ответ – нет, нельзя. Константные методы работают таким образом, что они не только успокаивают компилятор,
[42:02.260 --> 42:08.260]  но они контролируют ваши действия за тем, что вы ничего не изменили.
[42:08.260 --> 42:13.260]  То есть если вы поклеились, что ваш метод ничего не меняет, то считаете, что это кряд вы кровью.
[42:13.260 --> 42:18.260]  В общем, вы ничего менять не должны. Если вы попытаетесь что-то изменить внутри константного метода,
[42:18.260 --> 42:23.260]  то у вас будет ошибка компилации. То есть когда вы зашли внутрь константного метода,
[42:23.260 --> 42:26.260]  у вас все поля автоматически стали
[42:26.260 --> 42:29.260]  константными, ну грубо говоря,
[42:29.260 --> 42:32.260]  поэтому мораль. Если ваш метод,
[42:32.260 --> 42:34.260]  то есть если у вас метод на самом деле
[42:34.260 --> 42:36.260]  ничего не меняет, то нужно помечать его
[42:36.260 --> 42:38.260]  const, для чего? Чтобы его можно вызывать
[42:38.260 --> 42:40.260]  с помощью, ну, через константные объекты
[42:40.260 --> 42:42.260]  или через константные ссылки.
[42:42.260 --> 42:44.260]  Ну и плюс, если по логике, по логике вещей,
[42:44.260 --> 42:46.260]  по логике данного метода, этот метод
[42:46.260 --> 42:48.260]  ничего не должен менять, то тоже пишите const,
[42:48.260 --> 42:50.260]  потому что он контролирует вас и
[42:50.260 --> 42:52.260]  избавляет вас от ошибок непреднамеренно.
[42:52.260 --> 42:54.260]  То есть если вы случайно в этом методе
[42:54.260 --> 42:56.260]  что-то измените, то вам компилятор подскажет,
[42:56.260 --> 42:58.260]  что у вас метод константный, а вы что-то поменяли.
[43:00.260 --> 43:02.260]  Понятно? Окей.
[43:04.260 --> 43:06.260]  Ну и наконец, естественно,
[43:06.260 --> 43:08.260]  в константных методах можно вызывать
[43:08.260 --> 43:10.260]  только константные методы.
[43:10.260 --> 43:12.260]  То есть, смотрите, если у вас есть метод size,
[43:12.260 --> 43:14.260]  и вы внутри него вызываете pop, то такого делать
[43:14.260 --> 43:16.260]  естественно нельзя, ну, по понятным причинам.
[43:16.260 --> 43:18.260]  Вы находитесь внутри константного метода
[43:18.260 --> 43:20.260]  и вызываете неконстантный метод.
[43:20.260 --> 43:22.260]  То есть pop по логике не является константным.
[43:22.260 --> 43:24.260]  И по логике, и по сути не является константным.
[43:24.260 --> 43:26.260]  Поэтому его вызывать нельзя.
[43:26.260 --> 43:28.260]  То есть компилятор внутри константных методов
[43:28.260 --> 43:30.260]  проверяет, действительно ли вы вызываете
[43:30.260 --> 43:32.260]  только константные методы.
[43:34.260 --> 43:36.260]  А здесь
[43:36.260 --> 43:38.260]  внутри top можно...
[43:38.260 --> 43:40.260]  Смотрите, я завел...
[43:40.260 --> 43:42.260]  У меня есть метод top, который
[43:42.260 --> 43:44.260]  возвращает верхний элемент
[43:44.260 --> 43:46.260]  стека. Вот в нем я могу спокойно
[43:46.260 --> 43:48.260]  обращаться к методу size. Почему?
[43:48.260 --> 43:50.260]  Потому что и метод top у меня константный,
[43:50.260 --> 43:52.260]  и метод size у меня тоже константный.
[43:52.260 --> 43:54.260]  Константные методы внутри константных методов
[43:54.260 --> 43:56.260]  я вызывать могу спокойно.
[43:56.260 --> 43:58.260]  Ну, мне кажется, это очевидно.
[43:58.260 --> 44:00.260]  Все.
[44:00.260 --> 44:02.260]  Ну, и наконец,
[44:02.260 --> 44:04.260]  еще одно важное правило.
[44:04.260 --> 44:06.260]  Константность является
[44:06.260 --> 44:08.260]  частью сигнатуры метода.
[44:10.260 --> 44:12.260]  Поэтому по константности
[44:12.260 --> 44:14.260]  можно перегружать методы.
[44:14.260 --> 44:16.260]  То есть у вас могут быть два метода
[44:16.260 --> 44:18.260]  с одинаковыми именами и с одинаковыми
[44:18.260 --> 44:20.260]  аргументами, которые отличаются только
[44:20.260 --> 44:22.260]  константностью.
[44:22.260 --> 44:24.260]  Понятно? То есть у вас может быть один метод
[44:24.260 --> 44:26.260]  константным, а другой метод неконстантным.
[44:26.260 --> 44:28.260]  Для чего это может быть нужно?
[44:28.260 --> 44:30.260]  Ну, смотрите.
[44:30.260 --> 44:32.260]  Давайте на примере метода top.
[44:32.260 --> 44:34.260]  Ну, метод top у меня возвращает
[44:34.260 --> 44:36.260]  верхний элемент стека.
[44:36.260 --> 44:38.260]  Понятное дело, что я метод top могу вызывать
[44:38.260 --> 44:40.260]  от константного стека, но просто хочу посмотреть
[44:40.260 --> 44:42.260]  на верхний элемент. Это логично.
[44:42.260 --> 44:44.260]  Поэтому я завожу метод top, который константный,
[44:44.260 --> 44:46.260]  так же возвращает int.
[44:46.260 --> 44:48.260]  А теперь я хочу задать поведение метода top,
[44:48.260 --> 44:50.260]  который будет работать с неконстантным
[44:50.260 --> 44:52.260]  стаком. Вот для неконстантного
[44:52.260 --> 44:54.260]  стека я хочу, чтобы он возвращал не просто
[44:54.260 --> 44:56.260]  верхний элемент, а ссылку
[44:56.260 --> 44:58.260]  на верхний элемент.
[44:58.260 --> 45:00.260]  Ну для чего я это могу захотеть делать?
[45:00.260 --> 45:02.260]  Ну, например, чтобы работал вот следующий код.
[45:02.260 --> 45:04.260]  Например, я хочу чтобы
[45:04.260 --> 45:06.260]  я мог просто взять и изменить верхний
[45:06.260 --> 45:08.260]  элемент. Ну, чтобы не делать там
[45:08.260 --> 45:10.260]  pop и push. blow.
[45:10.260 --> 45:12.260]  То есть представь себе, что у меня есть стity, я хочу просто изменить верхний элемент.
[45:12.260 --> 45:15.260]  Согласитесь, сначала сделать pop, а потом push долго.
[45:15.260 --> 45:18.260]  Я хочу, чтобы у меня работал следующий синтаксис.
[45:18.260 --> 45:22.260]  a.top равно единице. То есть просто взять верхний элемент и его изменить.
[45:22.260 --> 45:26.260]  Вот чтобы такое работало, я из неконстантного метода top возвращаю ссылку.
[45:26.260 --> 45:29.260]  И теперь это работает.
[45:29.260 --> 45:32.260]  А если я тоже самое попытаюсь сделать для константного стека,
[45:32.260 --> 45:34.260]  то у меня будет ошибка компиляции. Почему?
[45:34.260 --> 45:37.260]  Потому что константный стек возвращает мне не ссылку, а временное значение.
[45:37.260 --> 45:40.260]  А временное значение, естественно, ничего нельзя присвоить.
[45:40.260 --> 45:43.260]  Пример понятен? Почему это может быть нужно?
[45:43.260 --> 45:45.260]  Что?
[45:45.260 --> 45:48.260]  Почему не перегрузка? Перегрузка.
[45:48.260 --> 45:51.260]  Так перегрузка, еще раз, что такое перегрузка?
[45:51.260 --> 45:54.260]  Перегрузка – это когда у вас есть две функции с одинаковым именем.
[46:01.260 --> 46:04.260]  Здесь все понятно, да?
[46:05.260 --> 46:08.260]  Окей.
[46:08.260 --> 46:11.260]  Теперь поговорим про статические поля метода.
[46:22.260 --> 46:27.260]  Не, константность определяется тем, какой объект у вас стоит.
[46:27.260 --> 46:31.260]  Константность у вас определяется тем, какой объект у вас стоит здесь.
[46:31.260 --> 46:44.260]  Можно считать так, что у вас у любых методов в качестве первого аргумента всегда стоит ваш объект.
[46:44.260 --> 46:51.260]  Например, если вы вызываетесь от обычного стека, то у вас в первом аргументном стоит ссылка на обычный стек.
[46:51.260 --> 46:55.260]  Если вы вызываете от константного стека, то у вас стоит константная ссылка на стек.
[46:55.260 --> 46:58.260]  То есть можно, грубо говоря, считать так.
[46:58.260 --> 47:00.260]  То, чего вы вызываете, это первый аргумент.
[47:00.260 --> 47:03.260]  А второй аргумент он понимает, что вызывает – константный или неконстантный.
[47:07.260 --> 47:12.260]  Естественный этап компиляции компилятора понимает, объект A – он константный или нет,
[47:12.260 --> 47:14.260]  CRF – это константный объект или нет.
[47:14.260 --> 47:17.260]  И в зависимости от этого вызывает нужный метод.
[47:17.260 --> 47:20.260]  Еще важный момент.
[47:20.260 --> 47:23.260]  Не знаю, говорил я или нет, но и понятно или нет.
[47:23.260 --> 47:26.260]  Представь себе, что у вас вот этого метода нет.
[47:27.260 --> 47:32.260]  Но я думаю понятно, что вот эта строка не в таком виде,
[47:32.260 --> 47:34.260]  а вот в таком виде,
[47:34.260 --> 47:36.260]  по-прежнему будет работать.
[47:36.260 --> 47:40.260]  То есть естественно, если у вас объект неконстантный, то у него일 константные методы тоже можно вызывать.
[47:40.260 --> 47:41.260]  Понятно?
[47:41.260 --> 47:46.260]  То есть если у вас объект неконстантный, то это не значит, что вы его должны постоянно изменять.
[47:46.260 --> 47:51.260]  То есть если у вас объект неконстантный, то вполне возможно, что вы его вызываетете и методы, которые его не меняют.
[47:51.260 --> 47:55.260]  Это очевидно, но давайте проговорим.
[47:56.260 --> 48:05.260]  Так, смотрите, выбор перегрузки же происходит только по сигнатуре.
[48:05.260 --> 48:08.260]  То есть компилятор не будет смотреть, что у вас методы абсолютно одинаковые,
[48:08.260 --> 48:11.260]  он не будет вам говорить, что а что это ты написал одинаковые методы.
[48:11.260 --> 48:13.260]  Ему вообще все равно, что написали.
[48:13.260 --> 48:19.260]  То есть вы вполне можете написать, ну давайте, если вы не писали тут апперсант,
[48:19.260 --> 48:21.260]  вы могли бы написать и так. Компилятор не будет проверять,
[48:21.260 --> 48:23.260]  что вы написали одинаковый код или не одинаковый.
[48:23.260 --> 48:25.260]  То есть тут важное отличие, что будет вызываться в каком случае.
[48:25.260 --> 48:28.260]  Константный метод будет вызываться для константных объектов,
[48:28.260 --> 48:30.260]  не константный или не константный.
[48:30.260 --> 48:32.260]  То есть не обязательно писать разные реализации.
[48:41.260 --> 48:43.260]  Дальше идем?
[48:43.260 --> 48:46.260]  Так, статические поля и методы.
[48:46.260 --> 48:51.260]  Ну, снова, мы знаем ключевое слово static,
[48:51.260 --> 48:56.260]  то есть у него есть очень много различных смыслов в языке C++,
[48:56.260 --> 49:00.260]  то есть статические переменные внутри функций, статические функции,
[49:00.260 --> 49:03.260]  статические константы и так далее, и так далее.
[49:03.260 --> 49:07.260]  Еще есть смысл статических полей класса и статические методы.
[49:07.260 --> 49:11.260]  Значит, когда вы объявляете поле статическим или метод статическим,
[49:11.260 --> 49:13.260]  это означает буквально следующее.
[49:13.260 --> 49:18.260]  Вы говорите, что это поле или этот метод принадлежит не конкретному объекту,
[49:18.260 --> 49:20.260]  а принадлежит классу в целом.
[49:20.260 --> 49:22.260]  Что здесь имеется в виду?
[49:22.260 --> 49:25.260]  Вот смотрите, когда мы работали со стеком,
[49:25.260 --> 49:28.260]  у нас вот этот буфер и вот этот size,
[49:28.260 --> 49:31.260]  к какому объекту они относятся?
[49:31.260 --> 49:35.260]  Они относятся к конкретному объекту, относительно которого мы вызываем метод.
[49:35.260 --> 49:36.260]  Согласны?
[49:36.260 --> 49:45.260]  Вот у меня есть, допустим, стек S1 и есть стек S2.
[49:45.260 --> 49:52.260]  Я вызываю S1.top и вызываю S2.top.
[49:52.260 --> 49:55.260]  Вот top, который вызывается от S1, и top, который вызывается от S2,
[49:55.260 --> 49:58.260]  обращаются к совсем разным данным.
[49:58.260 --> 49:59.260]  Понятно, да?
[49:59.260 --> 50:02.260]  То есть у S1 и S2 у них разные и буфер, и size.
[50:02.260 --> 50:04.260]  Абсолютно разные.
[50:04.260 --> 50:06.260]  А когда вы объявляете статическое поле или метод,
[50:06.260 --> 50:10.260]  вы говорите, что это поле принадлежит сразу всем объектам.
[50:10.260 --> 50:12.260]  То есть такое вот общее место.
[50:12.260 --> 50:16.260]  И вот к этому полю конкретному могут обращаться все объекты.
[50:16.260 --> 50:18.260]  И если какой-то объект изменил это поле,
[50:18.260 --> 50:21.260]  то все остальные объекты это изменение тоже увидят.
[50:21.260 --> 50:22.260]  Понятно?
[50:22.260 --> 50:24.260]  То же самое касается статических методов.
[50:24.260 --> 50:26.260]  Значит, статический метод – это метод,
[50:26.260 --> 50:30.260]  который работает не с конкретными полями конкретного объекта,
[50:30.260 --> 50:34.260]  а работает в целом для всего класса.
[50:34.260 --> 50:36.260]  Понятно или?
[50:36.260 --> 50:39.260]  Ну давайте сейчас перейдем к примерам.
[50:39.260 --> 50:41.260]  Давайте пока правила.
[50:41.260 --> 50:42.260]  Ну да.
[50:42.260 --> 50:45.260]  Поляменты принадлежат не конкретному объекту, а классу в целом.
[50:45.260 --> 50:47.260]  Так как они принадлежат не конкретному объекту, а классу в целом,
[50:47.260 --> 50:50.260]  к ним можно обращаться не через объект.
[50:50.260 --> 50:52.260]  То есть вы можете вообще не…
[50:52.260 --> 50:56.260]  Так как они принадлежат к классу, вы не можете не создавать объект, чтобы обратиться к ним.
[50:56.260 --> 50:59.260]  Например, к полю у вы можете обратиться через двоеточие.
[50:59.260 --> 51:01.260]  Вот так.
[51:01.260 --> 51:06.260]  Можно, вы можете объедить S какой-то объект, и S.45.
[51:06.260 --> 51:08.260]  То есть так тоже можно.
[51:08.260 --> 51:10.260]  Но согласитесь, странно –
[51:10.260 --> 51:12.300] ерг hayırя, еще, наверное, для всех объектов странно как-то создавать объекты classes
[51:12.300 --> 51:15.260]  специально чтобы обратиться к некоторому общем.
[51:15.260 --> 51:17.740]  Чтобы обратиться к общему, вы можете написать вот такой код.
[51:17.740 --> 51:21.740]  К общей функции, к статическому методу вы можете написать вот так.
[51:21.740 --> 51:28.820]  Просто через оператор разрешения области видимости вы можете обратиться к статическому полю
[51:28.820 --> 51:30.460]  или к статическому методу.
[51:30.460 --> 51:48.460]  Это не важно. Смотрите еще раз, давайте повторим, что было в прошлом семестре.
[51:48.460 --> 51:54.460]  Статические переменные в какой области памяти находятся? В глобальной.
[51:54.460 --> 51:58.460]  То есть они создаются в момент, когда у вас инитилизируется программа, когда у вас еще никаких объектов не создано.
[51:58.460 --> 52:04.460]  То есть у вас программа работает, никаких объектов S нет, но статические поля, они уже созданы, так они находятся в глобальной области.
[52:04.460 --> 52:11.460]  То есть вы можете не создавать ни одного объекта, но статические поля у вас уже будут. Вот как здесь.
[52:11.460 --> 52:19.460]  То есть мы здесь, допустим, не объявили никакого объекта, но при этом к S от Y можно спокойно использовать.
[52:20.460 --> 52:40.460]  Ну ровно как и S.G. Что еще раз? Мы про конструкцию еще не говорили, но статические поля создаются не в конструкторах, сразу скажу.
[52:40.460 --> 52:47.460]  Ну естественно, если вы объявите поле константным, то вот так изменить его нельзя будет.
[52:47.460 --> 52:53.460]  То есть вы можете создавать константные статические поля.
[52:53.460 --> 52:58.460]  Да, ну и последнее правило, статические методы могут работать только со статическими полями.
[52:58.460 --> 53:03.460]  Ну я думаю это понятно почему, потому что давайте попробуем написать реализацию функции G.
[53:03.460 --> 53:10.460]  И я тут делаю, например, какой-нибудь плюс-плюс X. В чем проблема, понятно?
[53:10.460 --> 53:14.460]  G принадлежит классу в целом, а не конкретному объекту.
[53:14.460 --> 53:18.460]  Когда вы делаете плюс-плюс X, непонятно, какой конкретно X вы хотите изменить.
[53:18.460 --> 53:24.460]  То есть один раз на экзамене мне сказали, что когда я делаю вот так, то у меня изменяются сразу все X во всех объектах.
[53:24.460 --> 53:27.460]  Ну естественно это не так, это не работает.
[53:27.460 --> 53:34.460]  Когда вы вызываете S, вы метод G вызываете не от объекта.
[53:34.460 --> 53:38.460]  Поэтому G не понимает, какой X ему нужно изменить.
[53:38.460 --> 53:41.460]  И это будет ошибка в компиляции, понятно?
[53:41.460 --> 53:47.460]  А вот так я могу сделать. Почему?
[53:47.460 --> 53:50.460]  Да, потому что Y общий на всех, он глобальный.
[53:50.460 --> 53:53.460]  К какому Y обращаться понятно. То есть Y он единственный на всех.
[53:53.460 --> 53:57.460]  То есть он единственный, и поэтому тут никакого...
[53:57.460 --> 54:01.460]  Как это на русском слово?
[54:01.460 --> 54:09.460]  Короче, никакого конфуза не происходит.
[54:09.460 --> 54:12.460]  Ну и классический пример.
[54:12.460 --> 54:15.460]  Есть у меня структура, для простоты тут все публичное.
[54:15.460 --> 54:20.460]  Ну, кстати, давайте в качестве замечания тоже скажу, что статические поля и статические методы
[54:20.460 --> 54:23.460]  можно объявлять либо в публичную, либо в приватную области.
[54:23.460 --> 54:28.460]  Если вы объявили в приватную область, то теперь обращаться к ним вам запрещено.
[54:28.460 --> 54:32.460]  Если вы объявили в публичную область, как здесь, то можете спокойно к ним обращаться.
[54:32.460 --> 54:35.460]  Понятно, да?
[54:35.460 --> 54:38.460]  Ну вот у меня есть структура S.
[54:38.460 --> 54:42.460]  В ней у меня есть int поле X, статическое поле, и Y.
[54:42.460 --> 54:45.460]  И есть два метода, есть метод F и есть метод G.
[54:45.460 --> 54:48.460]  F не статический, G статический.
[54:48.460 --> 54:50.460]  Давайте посмотрим на метод F.
[54:50.460 --> 54:55.460]  Могу ли я сделать X плюс равно 1?
[54:55.460 --> 54:56.460]  Ну, естественно, я могу.
[54:56.460 --> 54:58.460]  То есть метод спокойно может изменить поля.
[54:58.460 --> 55:02.460]  А могу ли я из метода F изменить Y?
[55:02.460 --> 55:03.460]  Ну тоже да.
[55:03.460 --> 55:06.460]  Мы это не обсуждали, но это логично, что можно.
[55:06.460 --> 55:11.460]  Потому что тоже нет никакой, в общем, нет ниоднозначности.
[55:11.460 --> 55:14.460]  Понятно, к кому Y вы обращаетесь.
[55:14.460 --> 55:16.460]  Теперь рассмотрим метод G, который статический.
[55:16.460 --> 55:18.460]  Могу ли я сделать X плюс равно 1?
[55:18.460 --> 55:20.460]  Нет, это обсуждали.
[55:20.460 --> 55:21.460]  То есть к X обратиться нельзя.
[55:21.460 --> 55:23.460]  Потому что непонятно, какую X вы имеете в виду.
[55:23.460 --> 55:24.460]  А Y можно изменить?
[55:24.460 --> 55:25.460]  Да, можно.
[55:25.460 --> 55:27.460]  Y существует в единственном экземпляре на все классы.
[55:27.460 --> 55:29.460]  Поэтому все нормально.
[55:37.460 --> 55:40.460]  Ну и такой пример.
[55:40.460 --> 55:42.460]  Левая часть у нас рабочая.
[55:42.460 --> 55:45.460]  То есть мы поняли, что внутри метода G нельзя изменить X.
[55:45.460 --> 55:48.460]  Поэтому из него X плюс равно 1 выпили.
[55:48.460 --> 55:50.460]  Теперь давайте посмотрим на Main.
[55:50.460 --> 55:52.460]  Допустим, Main у меня выглядит следующим образом.
[55:52.460 --> 55:56.460]  В Main я создаю две переменные, A и B, которые имеют тип S.
[55:56.460 --> 56:00.460]  Дальше говорю, A точка X равно 0, B точка X равно 0.
[56:00.460 --> 56:03.460]  Ну понятно, что X стал равным 0, B точка X стал равным единице.
[56:03.460 --> 56:08.460]  Я делаю A точка Y равно 0, B точка Y равно единице.
[56:08.460 --> 56:10.460]  Чему у меня равно A точка Y?
[56:10.460 --> 56:12.460]  Единице.
[56:12.460 --> 56:14.460]  Да, почему?
[56:14.460 --> 56:16.460]  Потому что сначала я изменил Y на 0,
[56:16.460 --> 56:19.460]  а потом с помощью B я изменил Y на единицу.
[56:19.460 --> 56:21.460]  Ну естественно, Y у меня один и общий,
[56:21.460 --> 56:23.460]  поэтому в нем хранится последнее изменение.
[56:23.460 --> 56:26.460]  Ну и B точка Y тоже естественно единица.
[56:26.460 --> 56:28.460]  Теперь я делаю S 2.2.X равно 10.
[56:28.460 --> 56:30.460]  Что происходит?
[56:30.460 --> 56:32.460]  Ошибка.
[56:32.460 --> 56:34.460]  X не статическое поле.
[56:34.460 --> 56:36.460]  X принадлежит каждому объекту в отдельности.
[56:36.460 --> 56:38.460]  Когда вы делаете вот так...
[56:38.460 --> 56:40.460]  Во-первых, X не глобальный,
[56:40.460 --> 56:43.460]  поэтому непонятно, к кому X вы в принципе обращаетесь.
[56:43.460 --> 56:46.460]  Но во-вторых, в общем, это тупо не работает.
[56:46.460 --> 56:49.460]  Тут будет ошибка компиляции.
[56:49.460 --> 56:51.460]  Когда я делаю S 2.2.Y равно 11,
[56:51.460 --> 56:53.460]  чему мне равно A точка Y и B точка Y?
[56:53.460 --> 56:55.460]  11. У меня изменился один общий Y,
[56:55.460 --> 56:59.460]  поэтому неважно, к какому Y через A или через B вы обращаетесь.
[57:01.460 --> 57:04.460]  Так, я вызываю A точка F и B точка F.
[57:14.460 --> 57:17.460]  Да, здесь единица, здесь двойка.
[57:19.460 --> 57:22.460]  А Y к чему равен? Давайте пропишем.
[57:24.460 --> 57:27.460]  13, да. То есть мы до этого изменили его на 11,
[57:27.460 --> 57:29.460]  а потом мы два раза увеличили на единицу.
[57:29.460 --> 57:31.460]  Так, и мы два раза вызвали F.
[57:31.460 --> 57:34.460]  Ну и теперь я два раза вызываю G.
[57:36.460 --> 57:38.460]  Да, ну то есть здесь 15, здесь 15.
[57:38.460 --> 57:41.460]  Точнее, один общий Y стал равным 15.
[57:41.460 --> 57:43.460]  Я вызываю S 2.2.F.
[57:44.460 --> 57:46.460]  Ну, нельзя, да, снова.
[57:46.460 --> 57:48.460]  F это нестатический метод, поэтому так нельзя.
[57:48.460 --> 57:51.460]  Возвываю S 2.2.G, так можно.
[57:51.460 --> 57:54.460]  Но в итоге у меня Y стал равен 16.
[57:56.460 --> 57:58.460]  Ну вот.
[57:59.460 --> 58:02.460]  Все понятно, нужно что-то повторить.
[58:02.460 --> 58:05.460]  Ну смотрите, что мы делаем вот в этой строке?
[58:06.460 --> 58:08.460]  Мы Y присваиваем 0,
[58:08.460 --> 58:10.460]  а потом Y присваиваем единицы.
[58:11.460 --> 58:14.460]  Так как Y статическое поле,
[58:14.460 --> 58:16.460]  и A, и B обращаются к одному и тому же Y.
[58:16.460 --> 58:18.460]  Поэтому, ну, собственно, вот последние изменения,
[58:18.460 --> 58:20.460]  оно и отражается в A.
[58:21.460 --> 58:23.460]  Так, еще.
[58:27.460 --> 58:29.460]  Ну, вот.
[58:30.460 --> 58:32.460]  Окей.
[58:33.460 --> 58:35.460]  Вот.
[58:35.460 --> 58:38.460]  Ну и такой сложный момент про статические поля,
[58:38.460 --> 58:40.460]  который нужно проговорить.
[58:40.460 --> 58:42.460]  Смотрите.
[58:42.460 --> 58:45.460]  Статические поля, на самом деле, не так просто проинциализировать.
[58:45.460 --> 58:48.460]  Вот они в этом смысле очень хитрые ребята.
[58:48.460 --> 58:50.460]  Вот если я сделаю вот так,
[58:50.460 --> 58:52.460]  ну, то есть просто напишу структуру S
[58:52.460 --> 58:54.460]  и объюлю в ней статическое поле int X,
[58:54.460 --> 58:56.460]  то я получу ошибку линковки.
[58:56.460 --> 58:58.460]  Ну, я надеюсь, что вы, в общем,
[58:58.460 --> 59:00.460]  рассматриваете, что такое линковка.
[59:00.460 --> 59:02.460]  В общем, произойдет ошибка.
[59:02.460 --> 59:04.460]  Почему?
[59:04.460 --> 59:06.460]  Ну, смотрите, вообще глобальные переменные,
[59:06.460 --> 59:08.460]  они по умолчанию унициализируются нулем,
[59:08.460 --> 59:10.460]  поэтому все нормально.
[59:10.460 --> 59:12.460]  С статическими полями класса такое не работает.
[59:12.460 --> 59:14.460]  Статические поля класса
[59:14.460 --> 59:16.460]  всегда нужно как-то инициализировать.
[59:16.460 --> 59:18.460]  То есть статические поля класса,
[59:18.460 --> 59:20.460]  ровно как и константные поля,
[59:20.460 --> 59:22.460]  нужно всегда чем-то проинциализировать.
[59:22.460 --> 59:24.460]  Ну, вот.
[59:24.460 --> 59:26.460]  Если вы попытаетесь проинциализировать,
[59:26.460 --> 59:28.460]  то вы тоже получите ошибку компиляции,
[59:28.460 --> 59:30.460]  которая уже будет звучать следующим образом,
[59:30.460 --> 59:32.460]  что вот компетент по статистизации языка C++,
[59:32.460 --> 59:34.460]  блабла, короче, запрещает
[59:34.460 --> 59:36.460]  инициализировать неконстантные
[59:36.460 --> 59:38.460]  статические члены.
[59:38.460 --> 59:40.460]  Короче, получается парадокс.
[59:40.460 --> 59:42.460]  Инициализировать нельзя,
[59:42.460 --> 59:44.460]  неинциализировать тоже нельзя.
[59:44.460 --> 59:46.460]  На самом деле парадокса никого нет.
[59:46.460 --> 59:48.460]  Тут проблема заключается в том,
[59:48.460 --> 59:50.460]  ну, то есть тут проблема, как раз заключается в том,
[59:50.460 --> 59:52.460]  что у вас есть один парадокс,
[59:52.460 --> 59:54.460]  то есть тут проблема заключается в
[59:54.460 --> 59:56.460]  правиле одного определения,
[59:56.460 --> 59:58.460]  про которое мы говорили.
[59:58.460 --> 01:00:00.460]  Значит, по поводу глобальных переменных,
[01:00:00.460 --> 01:00:02.460]  правил одного определения говорит следующую вещь,
[01:00:02.460 --> 01:00:04.460]  что все глобальные переменные должны быть определены
[01:00:04.460 --> 01:00:06.460]  только один раз, только в одной единице трансляции.
[01:00:06.460 --> 01:00:08.460]  Ну, короче,
[01:00:08.460 --> 01:00:10.460]  только в одном CPP файле.
[01:00:10.460 --> 01:00:12.460]  Вот так. Окей?
[01:00:12.460 --> 01:00:14.460]  Ну, окей.
[01:00:14.460 --> 01:00:16.460]  А в чем может быть проблема,
[01:00:16.460 --> 01:00:18.460]  если я внутри структуры объявил статическое поле X
[01:00:18.460 --> 01:00:20.460]  и сразу проинциализировал его нулем?
[01:00:20.460 --> 01:00:22.460]  Какая проблема?
[01:00:24.460 --> 01:00:26.460]  Нет, нет,
[01:00:26.460 --> 01:00:28.460]  с объектом это не связано.
[01:00:28.460 --> 01:00:30.460]  Это связано непосредственно с определением S.
[01:00:32.460 --> 01:00:34.460]  Ну, короче говоря, у вас может быть так,
[01:00:34.460 --> 01:00:36.460]  ну, короче, у вас может случиться так,
[01:00:36.460 --> 01:00:38.460]  что вы структуру S написали,
[01:00:38.460 --> 01:00:40.460]  ну, короче, правила одного определения
[01:00:40.460 --> 01:00:42.460]  для структуры и для класса говорит следующую вещь,
[01:00:42.460 --> 01:00:44.460]  что у вас класс и структура может быть объявлен
[01:00:44.460 --> 01:00:46.460]  только один раз в одной единице трансляции.
[01:00:46.460 --> 01:00:48.460]  Ну, или в одном CPP файле.
[01:00:48.460 --> 01:00:50.460]  То есть тут возникает такое несоответствие.
[01:00:50.460 --> 01:00:52.460]  Переменные должны быть объявлены один раз
[01:00:52.460 --> 01:00:54.460]  на всю программу,
[01:00:54.460 --> 01:00:56.460]  а класс должен быть объявлен один раз
[01:00:56.460 --> 01:00:58.460]  на один файл, грубо говоря.
[01:00:58.460 --> 01:01:00.460]  И вот смотрите, что у вас получается.
[01:01:00.460 --> 01:01:02.460]  Представьте себе, что вы одну и ту же структуру S
[01:01:02.460 --> 01:01:04.460]  определили в
[01:01:04.460 --> 01:01:06.460]  нескольких файлах.
[01:01:06.460 --> 01:01:08.460]  Ну, вроде бы все окей.
[01:01:08.460 --> 01:01:10.460]  То есть вы класс определили в нескольких файлах,
[01:01:10.460 --> 01:01:12.460]  и
[01:01:12.460 --> 01:01:14.460]  ну, компилятор на это не жалуется.
[01:01:14.460 --> 01:01:16.460]  Но если вы внутри класса объявили статическую
[01:01:16.460 --> 01:01:18.460]  переменную или статическое поле,
[01:01:18.460 --> 01:01:20.460]  то у вас возникает парадоксальная ситуация,
[01:01:20.460 --> 01:01:22.460]  что вы класс объявили несколько раз, и все нормально,
[01:01:22.460 --> 01:01:24.460]  но при этом глобальная переменная X объявлена
[01:01:24.460 --> 01:01:26.460]  несколько раз уже в одной программе.
[01:01:26.460 --> 01:01:28.460]  Что запрещено?
[01:01:28.460 --> 01:01:30.460]  Ну, просто проблема понятна?
[01:01:30.460 --> 01:01:32.460]  На интуитивном уровне.
[01:01:32.460 --> 01:01:34.460]  Вот.
[01:01:34.460 --> 01:01:36.460]  Как эту проблему обойти? Как ее решить?
[01:01:36.460 --> 01:01:38.460]  А решение очень простое.
[01:01:38.460 --> 01:01:40.460]  Статический поля нужно инициализировать вне класса.
[01:01:40.460 --> 01:01:42.460]  И только один раз.
[01:01:42.460 --> 01:01:44.460]  Делайте это следующим образом.
[01:01:44.460 --> 01:01:46.460]  Вот так.
[01:01:46.460 --> 01:01:48.460]  То есть
[01:01:48.460 --> 01:01:50.460]  где-нибудь вне класса,
[01:01:50.460 --> 01:01:52.460]  в одном файле, ровно в одном файле,
[01:01:52.460 --> 01:01:54.460]  вы должны написать следующую вещь.
[01:01:54.460 --> 01:01:56.460]  Ну, собственно, вы должны написать объявление
[01:01:56.460 --> 01:01:58.460]  переменной
[01:01:58.460 --> 01:02:00.460]  с полным ее именем s2.x
[01:02:00.460 --> 01:02:02.460]  и написать, чему она должна быть равна.
[01:02:02.460 --> 01:02:04.460]  Все.
[01:02:04.460 --> 01:02:06.460]  Таким образом вы вынесли определение
[01:02:06.460 --> 01:02:08.460]  из класса, из структуры,
[01:02:08.460 --> 01:02:10.460]  то есть если вы сделали такое
[01:02:10.460 --> 01:02:12.460]  определение только в одном файле,
[01:02:12.460 --> 01:02:14.460]  то это работает нормально.
[01:02:14.460 --> 01:02:16.460]  У вас статическая переменная, то есть глобальная переменная
[01:02:16.460 --> 01:02:18.460]  определенна только в одном файле,
[01:02:18.460 --> 01:02:20.460]  но при этом структура может быть определенна в нескольких файлах.
[01:02:20.460 --> 01:02:22.460]  Поэтому нет никаких проблем.
[01:02:22.460 --> 01:02:24.460]  То есть это окоперение s2 может быть очень удобной?
[01:02:24.460 --> 01:02:26.460]  Да.
[01:02:26.460 --> 01:02:28.460]  Да, да.
[01:02:28.460 --> 01:02:30.460]  Вот.
[01:02:30.460 --> 01:02:32.460]  Ну, единственное исключение, единственное...
[01:02:34.460 --> 01:02:36.460]  Ну, досье плюс 18
[01:02:36.460 --> 01:02:38.460]  кажется точно единственное,
[01:02:38.460 --> 01:02:40.460]  заключается в том, что в качестве статических
[01:02:40.460 --> 01:02:42.460]  что статические поля можно объявлять
[01:02:42.460 --> 01:02:44.460]  внутри классов, но только если они
[01:02:44.460 --> 01:02:46.460]  константные и целые.
[01:02:46.460 --> 01:02:48.460]  Вот если у вас статическое поле объявлено
[01:02:48.460 --> 01:02:50.460]  как константное, и при этом это константно целое,
[01:02:50.460 --> 01:02:52.460]  то есть int, long или что-то еще,
[01:02:52.460 --> 01:02:54.460]  то ее можно определять
[01:02:54.460 --> 01:02:56.460]  внутри класса. Вот это единственное исключение.
[01:02:56.460 --> 01:02:58.460]  Во всех остальных ситуациях статические
[01:02:58.460 --> 01:03:00.460]  поля должны быть инициализированы вне
[01:03:00.460 --> 01:03:02.460]  класса. Вот таким образом.
[01:03:06.460 --> 01:03:08.460]  Да, тоже вне класса.
[01:03:08.460 --> 01:03:10.460]  То есть если здесь статик,
[01:03:10.460 --> 01:03:12.460]  если тут написано
[01:03:12.460 --> 01:03:14.460]  статик
[01:03:14.460 --> 01:03:16.460]  const
[01:03:18.460 --> 01:03:20.460]  float y,
[01:03:20.460 --> 01:03:22.460]  то вы должны писать
[01:03:22.460 --> 01:03:24.460]  вот так.
[01:03:24.460 --> 01:03:26.460]  const float y
[01:03:26.460 --> 01:03:28.460]  равно, ну, там, скажем, 0.
[01:03:32.460 --> 01:03:34.460]  Ну, короче, мораль, вот самая главная
[01:03:34.460 --> 01:03:36.460]  из того, что нужно вынести из вот этого
[01:03:36.460 --> 01:03:38.460]  пятиминутного спича,
[01:03:38.460 --> 01:03:40.460]  статические
[01:03:40.460 --> 01:03:42.460]  поля нужно инициализировать вне класса.
[01:03:42.460 --> 01:03:44.460]  Вот синтаксис.
[01:03:44.460 --> 01:03:46.460]  Пользуйтесь.
[01:03:46.460 --> 01:03:48.460]  Ну, это связано с тем, что
[01:03:48.460 --> 01:03:50.460]  в C++ есть правила одного определения.
[01:03:54.460 --> 01:03:56.460]  Так, ну и константные статические
[01:03:56.460 --> 01:03:58.460]  методы. Значит, очень короткий пункт.
[01:03:58.460 --> 01:04:00.460]  Константных статических методов не существует.
[01:04:00.460 --> 01:04:02.460]  Ну, короче, у нас есть
[01:04:02.460 --> 01:04:04.460]  константные методы, есть статические методы.
[01:04:04.460 --> 01:04:06.460]  Объединять их нельзя.
[01:04:06.460 --> 01:04:08.460]  Ну, действительно, мне как бы непонятно, в чем смысл.
[01:04:08.460 --> 01:04:10.460]  То есть, константные методы говорят о том,
[01:04:10.460 --> 01:04:12.460]  что этот метод ничего не меняет.
[01:04:12.460 --> 01:04:14.460]  Константные статические методы
[01:04:14.460 --> 01:04:16.460]  должны говорить о том, что они,
[01:04:16.460 --> 01:04:18.460]  короче,
[01:04:18.460 --> 01:04:20.460]  короче, даже если бы они существовали,
[01:04:20.460 --> 01:04:22.460]  то непонятно, как определить,
[01:04:22.460 --> 01:04:24.460]  что вы хотите вызвать. То есть, представьте себе,
[01:04:24.460 --> 01:04:26.460]  что вы, допустим,
[01:04:26.460 --> 01:04:28.460]  мы разрешаем константные статические методы.
[01:04:28.460 --> 01:04:30.460]  Скажем,
[01:04:30.460 --> 01:04:32.460]  static void
[01:04:32.460 --> 01:04:34.460]  g, и у нас есть
[01:04:34.460 --> 01:04:36.460]  static void
[01:04:38.460 --> 01:04:40.460]  g и const.
[01:04:40.460 --> 01:04:42.460]  Я вызываю s
[01:04:42.460 --> 01:04:44.460]  2.2.g.
[01:04:44.460 --> 01:04:46.460]  Вот уже здесь непонятно, что я хочу.
[01:04:46.460 --> 01:04:48.460]  Константный или неконстантный g.
[01:04:48.460 --> 01:04:50.460]  Поэтому
[01:04:50.460 --> 01:04:52.460]  константных статических методов
[01:04:52.460 --> 01:04:54.460]  не существует.
[01:04:54.460 --> 01:04:56.460]  Да, ну еще одно замечание,
[01:04:56.460 --> 01:04:58.460]  которое навеяно, собственно,
[01:04:58.460 --> 01:05:00.460]  разговором на экзаменах.
[01:05:00.460 --> 01:05:02.460]  Константные методы не могут
[01:05:02.460 --> 01:05:04.460]  изменять константные поля.
[01:05:04.460 --> 01:05:06.460]  Это не знаю, запишите отдельно.
[01:05:06.460 --> 01:05:08.460]  Константные поля никто не может изменять,
[01:05:08.460 --> 01:05:10.460]  константные поля вообще нельзя менять.
[01:05:10.460 --> 01:05:12.460]  В константных методах нельзя изменить константные поля.
[01:05:12.460 --> 01:05:14.460]  Смысл константных методов не в этом.
[01:05:14.460 --> 01:05:16.460]  А в чем смысл константных методов?
[01:05:18.460 --> 01:05:20.460]  Да, константные методы ничего не изменяют,
[01:05:20.460 --> 01:05:22.460]  вот они об этом говорят, все.
[01:05:24.460 --> 01:05:26.460]  Ну и, видимо,
[01:05:26.460 --> 01:05:28.460]  последний пункт.
[01:05:28.460 --> 01:05:30.460]  ключевое слово this.
[01:05:35.460 --> 01:05:37.460]  Значит, есть ключевое слово this,
[01:05:37.460 --> 01:05:39.460]  которое говорит следующее,
[01:05:39.460 --> 01:05:41.460]  короче, которое означает следующее.
[01:05:41.460 --> 01:05:43.460]  This возвращает вам указатель
[01:05:43.460 --> 01:05:45.460]  на текущий объект.
[01:05:45.460 --> 01:05:47.460]  This возвращает вам указатель
[01:05:47.460 --> 01:05:49.460]  на объект, над которым вы сейчас работаете.
[01:05:49.460 --> 01:05:51.460]  Ну, то есть,
[01:05:51.460 --> 01:05:53.460]  допустим, вы находитесь в структуре s,
[01:05:53.460 --> 01:05:55.460]  и вы хотите написать метод,
[01:05:55.460 --> 01:05:57.460]  который возвращает адрес
[01:05:57.460 --> 01:05:59.460]  текущего объекта.
[01:05:59.460 --> 01:06:01.460]  Тогда вы можете сделать следующую вещь.
[01:06:01.460 --> 01:06:03.460]  Вы можете просто сказать return this.
[01:06:03.460 --> 01:06:05.460]  This возвращает вам адрес
[01:06:05.460 --> 01:06:07.460]  объекта, над которым вы сейчас работаете.
[01:06:07.460 --> 01:06:09.460]  Что еще можно сделать?
[01:06:09.460 --> 01:06:11.460]  Ну, например, вы можете, если вы хотите
[01:06:11.460 --> 01:06:13.460]  обратиться к кому-то полю,
[01:06:13.460 --> 01:06:15.460]  вы можете написать this и дальше
[01:06:15.460 --> 01:06:17.460]  через стрелочку x.
[01:06:17.460 --> 01:06:19.460]  Понятно, почему через стрелочку, да?
[01:06:19.460 --> 01:06:21.460]  Потому что если у вас есть указательную
[01:06:21.460 --> 01:06:23.460]  структуру, то к его полям вы можете
[01:06:23.460 --> 01:06:25.460]  обратиться через стрелочку.
[01:06:25.460 --> 01:06:27.460]  Вот.
[01:06:27.460 --> 01:06:29.460]  Вот сейчас я про это скажу.
[01:06:29.460 --> 01:06:31.460]  Значит, это будет абсолютный
[01:06:31.460 --> 01:06:33.460]  эквалент на следующему коду.
[01:06:33.460 --> 01:06:35.460]  То есть, на самом деле, можно сказать, что когда вы пишете вот так
[01:06:35.460 --> 01:06:37.460]  x равно value, у вас компилятор
[01:06:37.460 --> 01:06:39.460]  подставляет вот такой код.
[01:06:39.460 --> 01:06:41.460]  То есть, как компилятор понимает, к кому x вы обращаетесь,
[01:06:41.460 --> 01:06:43.460]  он просто-напросто берет и подставляет
[01:06:43.460 --> 01:06:45.460]  this стрелочка x. То есть, вы должны обратиться
[01:06:45.460 --> 01:06:47.460]  к x, который расположен по такому-то адресу.
[01:06:47.460 --> 01:06:49.460]  Окей?
[01:06:49.460 --> 01:06:51.460]  Вот, когда вы...
[01:06:51.460 --> 01:06:53.460]  Вот здесь то же самое.
[01:06:53.460 --> 01:06:55.460]  Вот.
[01:06:55.460 --> 01:06:57.460]  Чтобы понять, к кому x вы обращаетесь,
[01:06:57.460 --> 01:06:59.460]  компилятор подставляет сюда this.
[01:06:59.460 --> 01:07:01.460]  И он говорит буквально о следующем.
[01:07:01.460 --> 01:07:03.460]  Вы переходите по указателю this и смотрите,
[01:07:03.460 --> 01:07:05.460]  к кому x там лежит. И вот его возвращаете.
[01:07:05.460 --> 01:07:07.460]  Теперь про то, имеет смысл это или нет.
[01:07:07.460 --> 01:07:09.460]  Ответ нет.
[01:07:09.460 --> 01:07:11.460]  Короче,
[01:07:11.460 --> 01:07:13.460]  писать вот так...
[01:07:13.460 --> 01:07:15.460]  Короче, пока вы маленький,
[01:07:15.460 --> 01:07:17.460]  на текущем уровне нашего размещения,
[01:07:17.460 --> 01:07:19.460]  стрелочка x писать не нужно. Вот вообще не нужно.
[01:07:19.460 --> 01:07:21.460]  Есть ситуации, при которых
[01:07:21.460 --> 01:07:23.460]  это необходимо.
[01:07:23.460 --> 01:07:25.460]  Но о них мы
[01:07:25.460 --> 01:07:27.460]  либо поговорим, либо не поговорим позже.
[01:07:27.460 --> 01:07:29.460]  Вот.
[01:07:29.460 --> 01:07:31.460]  В общем, это сложная ситуация, которая связана
[01:07:31.460 --> 01:07:33.460]  с шаблонами, с...
[01:07:33.460 --> 01:07:35.460]  Я вижу вас с шаблонами, с наследованием,
[01:07:35.460 --> 01:07:37.460]  с зависимыми именами. В общем,
[01:07:37.460 --> 01:07:39.460]  все мутно. В общем, но ситуация,
[01:07:39.460 --> 01:07:41.460]  когда это нужно есть. Вот.
[01:07:41.460 --> 01:07:43.460]  Пока вам это не нужно.
[01:07:43.460 --> 01:07:45.460]  Вы молодые, шутливые...
[01:07:45.460 --> 01:07:47.460]  Да.
[01:07:47.460 --> 01:07:49.460]  Там тоже можно
[01:07:49.460 --> 01:07:51.460]  использовать this спокойно.
[01:07:55.460 --> 01:07:57.460]  Сейчас, подождите. Если вы...
[01:07:57.460 --> 01:07:59.460]  Нет, давайте так.
[01:07:59.460 --> 01:08:01.460]  Вопрос, видимо, такой был.
[01:08:01.460 --> 01:08:03.460]  Если я хочу написать реализацию какого-то метода
[01:08:03.460 --> 01:08:05.460]  вне структуры. То есть, хотя я хочу написать что-то наподобие такого.
[01:08:05.460 --> 01:08:07.460]  Get x.
[01:08:11.460 --> 01:08:13.460]  Return x.
[01:08:13.460 --> 01:08:15.460]  Вот здесь в написании this тоже нет
[01:08:15.460 --> 01:08:17.460]  необходимости. Почему?
[01:08:17.460 --> 01:08:19.460]  Потому что здесь вы
[01:08:19.460 --> 01:08:21.460]  говорите компилятору, что я хочу реализовать
[01:08:21.460 --> 01:08:23.460]  метод get
[01:08:23.460 --> 01:08:25.460]  у класса s.
[01:08:25.460 --> 01:08:27.460]  Но так как это метод,
[01:08:27.460 --> 01:08:29.460]  он работает с конкретным объектом, поэтому вот тут
[01:08:29.460 --> 01:08:31.460]  он тоже сам, самостоятельно, без вашей помощи
[01:08:31.460 --> 01:08:33.460]  подставит this
[01:08:33.460 --> 01:08:35.460]  стрелочка x.
[01:08:39.460 --> 01:08:41.460]  Есть одна ситуация,
[01:08:41.460 --> 01:08:43.460]  при которой...
[01:08:43.460 --> 01:08:45.460]  Такая абстрактная ситуация, при которой
[01:08:45.460 --> 01:08:47.460]  this вам может помочь. Ну, например,
[01:08:47.460 --> 01:08:49.460]  представьте себе вот здесь.
[01:08:49.460 --> 01:08:51.460]  Допустим, я такой нехороший
[01:08:51.460 --> 01:08:53.460]  и поступил таким образом.
[01:08:53.460 --> 01:08:55.460]  Взял и сказал set x int x.
[01:08:55.460 --> 01:08:57.460]  То есть, у меня
[01:08:57.460 --> 01:08:59.460]  аргумент метода совпадает с полем класса.
[01:08:59.460 --> 01:09:01.460]  Такое может быть.
[01:09:01.460 --> 01:09:03.460]  Тогда, когда вы напишете вот так,
[01:09:03.460 --> 01:09:05.460]  возникнет ошибка.
[01:09:05.460 --> 01:09:07.460]  То есть, непонятно,
[01:09:07.460 --> 01:09:09.460]  что такое x слева, что такое x справа.
[01:09:09.460 --> 01:09:11.460]  Да?
[01:09:11.460 --> 01:09:13.460]  Чтобы, в общем...
[01:09:15.460 --> 01:09:17.460]  Короче, чтобы убрать вот такие неоднозначности,
[01:09:17.460 --> 01:09:19.460]  вы можете использовать this.
[01:09:19.460 --> 01:09:21.460]  Но как бы...
[01:09:21.460 --> 01:09:23.460]  Это единственный способ,
[01:09:23.460 --> 01:09:25.460]  единственное место, в котором вам
[01:09:25.460 --> 01:09:27.460]  нужно использовать this сейчас.
[01:09:27.460 --> 01:09:29.460]  А во-вторых, оно легко фиксится тем, что называете аргументы нормально,
[01:09:29.460 --> 01:09:31.460]  а не так, чтобы они совпадали с полями.
[01:09:35.460 --> 01:09:37.460]  Короче, в написании this стрелочка x
[01:09:37.460 --> 01:09:39.460]  нет никакой необходимости.
[01:09:39.460 --> 01:09:41.460]  Точнее, она есть, но вам рано о ней знать еще.
[01:09:43.460 --> 01:09:45.460]  Еще вопросы?
[01:09:53.460 --> 01:09:55.460]  Так, ну и про это я, конечно,
[01:09:55.460 --> 01:09:57.460]  сказал. Да, обращение к полям методам
[01:09:57.460 --> 01:09:59.460]  не явно происходит через this.
[01:09:59.460 --> 01:10:01.460]  Да, и еще важный момент. Какой тип имеет this?
[01:10:01.460 --> 01:10:03.460]  This имеет тип либо указатель на класс,
[01:10:03.460 --> 01:10:05.460]  либо указатель на константный класс.
[01:10:05.460 --> 01:10:07.460]  Вот.
[01:10:07.460 --> 01:10:09.460]  То есть, если вы вызываете...
[01:10:09.460 --> 01:10:11.460]  Точнее, если вы обращаетесь к this
[01:10:11.460 --> 01:10:13.460]  вне константном методе,
[01:10:13.460 --> 01:10:15.460]  то this у вас, естественно, имеет тип указатель
[01:10:15.460 --> 01:10:17.460]  на объект.
[01:10:17.460 --> 01:10:19.460]  Если вы обращаетесь к this
[01:10:19.460 --> 01:10:21.460]  в константном методе, то this у вас имеет
[01:10:21.460 --> 01:10:23.460]  тип указатель на константу.
[01:10:23.460 --> 01:10:25.460]  Но, собственно, по этой причине
[01:10:25.460 --> 01:10:27.460]  вам нельзя
[01:10:27.460 --> 01:10:29.460]  изменять поля класса.
[01:10:29.460 --> 01:10:31.460]  Почему? Потому что, когда вы пишете
[01:10:31.460 --> 01:10:33.460]  вот так, компилятор это читает дословно
[01:10:33.460 --> 01:10:35.460]  таким образом.
[01:10:35.460 --> 01:10:37.460]  Но так как this это указатель на константу,
[01:10:37.460 --> 01:10:39.460]  то есть то, что лежит
[01:10:39.460 --> 01:10:41.460]  под указатель на константу, изменить нельзя.
[01:10:41.460 --> 01:10:43.460]  Поэтому вам компилятор говорит, что вот такое запрещено.
[01:10:43.460 --> 01:10:45.460]  Ну, собственно, вот поэтому это работает.
[01:10:45.460 --> 01:10:47.460]  Понятно?
[01:10:49.460 --> 01:10:51.460]  Ну и давайте подведем
[01:10:51.460 --> 01:10:53.460]  промежуточный итог
[01:10:53.460 --> 01:10:55.460]  тому, что мы сделали за эту лекцию.
[01:10:55.460 --> 01:10:57.460]  Мы познакомились
[01:10:57.460 --> 01:10:59.460]  с понятием объектно-ориентированного
[01:10:59.460 --> 01:11:01.460]  программирования и, по большому счету,
[01:11:01.460 --> 01:11:03.460]  написали, там, путем
[01:11:03.460 --> 01:11:05.460]  склеивания нескольких пунктов в сегодняшней лекции,
[01:11:05.460 --> 01:11:07.460]  смогли написать вот такой класс стека.
[01:11:07.460 --> 01:11:09.460]  Что мы делаем?
[01:11:09.460 --> 01:11:11.460]  Мы описываем некоторый новый тип, который
[01:11:11.460 --> 01:11:13.460]  называем stack. Что мы говорим?
[01:11:13.460 --> 01:11:15.460]  Давайте рассмотрим публичную часть. Мы говорим, что с моим stack
[01:11:15.460 --> 01:11:17.460]  можно делать следующие вещи. Его можно пронициализировать.
[01:11:17.460 --> 01:11:19.460]  Значит, функция init, она создает
[01:11:19.460 --> 01:11:21.460]  делать необходимые действия для того, чтобы stack
[01:11:21.460 --> 01:11:23.460]  работал. Создаёт нужный буфер
[01:11:23.460 --> 01:11:25.460]  и инициализирует размер stack
[01:11:25.460 --> 01:11:27.460]  нулём.
[01:11:27.460 --> 01:11:29.460]  Дальше свели метод finalize,
[01:11:29.460 --> 01:11:31.460]  который мы должны вызвать
[01:11:31.460 --> 01:11:33.460]  по завершению работы со stack,
[01:11:33.460 --> 01:11:35.460]  который просто очищает память. То есть, над тем, чтобы
[01:11:35.460 --> 01:11:37.460]  выделять память и очищать память, нам задумываться
[01:11:37.460 --> 01:11:39.460]  не нужно, все необходимые действия делаются
[01:11:39.460 --> 01:11:41.460]  в этих методах. Дальше мы говорим,
[01:11:41.460 --> 01:11:43.460]  что в мой stack можно добавлять элемент,
[01:11:43.460 --> 01:11:45.460]  из моего stack можно удалять элемент
[01:11:45.460 --> 01:11:47.460]  с помощью pop и можно получать верхний
[01:11:47.460 --> 01:11:49.460]  элемент. При этом верхний элемент
[01:11:49.460 --> 01:11:51.460]  будет возвращаться по ссылке.
[01:11:51.460 --> 01:11:53.460]  Ну, для того, чтобы я мог его
[01:11:53.460 --> 01:11:55.460]  очень просто изменить.
[01:11:55.460 --> 01:11:57.460]  Ну и дальше я завёл несколько константных методов,
[01:11:57.460 --> 01:11:59.460]  например, метод top,
[01:11:59.460 --> 01:12:01.460]  чтобы я мог узнавать
[01:12:01.460 --> 01:12:03.460]  вершину stack для константного stack,
[01:12:03.460 --> 01:12:05.460]  метод size, который возвращает мне размер
[01:12:05.460 --> 01:12:07.460]  константного stack и метод empty,
[01:12:07.460 --> 01:12:09.460]  который возвращает мне пуст мой stack или нет.
[01:12:11.460 --> 01:12:13.460]  Дальше детали
[01:12:13.460 --> 01:12:15.460]  реализации. В деталях реализации
[01:12:15.460 --> 01:12:17.460]  я описывал, что у меня stack на самом деле состоит
[01:12:17.460 --> 01:12:19.460]  из указательного массива,
[01:12:19.460 --> 01:12:21.460]  из размера и плюс я завёл статическую
[01:12:21.460 --> 01:12:23.460]  константу, которая говорит мне вместимость моего stack.
[01:12:23.460 --> 01:12:25.460]  Вместимость stack равна сотне
[01:12:25.460 --> 01:12:27.460]  в данной реализации.
[01:12:27.460 --> 01:12:29.460]  Я завёл статический
[01:12:29.460 --> 01:12:31.460]  метод capacity, который просто
[01:12:31.460 --> 01:12:33.460]  берёт и возвращает какая вместимость у меня stack,
[01:12:33.460 --> 01:12:35.460]  чтобы пользователь мог узнавать, сколько максимум элементов
[01:12:35.460 --> 01:12:37.460]  он может добавить в мой stack.
[01:12:37.460 --> 01:12:39.460]  Вот и всё.
[01:12:39.460 --> 01:12:41.460]  Теперь stack я могу пользоваться с помощью вот этих
[01:12:41.460 --> 01:12:43.460]  методов и при этом я вообще совершенно не задумываюсь
[01:12:43.460 --> 01:12:45.460]  о том, как у меня stack реализован.
[01:12:45.460 --> 01:12:47.460]  Смотрите, если закрыть правую часть этих методов,
[01:12:47.460 --> 01:12:49.460]  скрыть всё, что написано в фигурных скобках,
[01:12:49.460 --> 01:12:51.460]  можете ли вы в принципе как догадаться,
[01:12:51.460 --> 01:12:53.460]  на чём реализован мой stack, на массиве
[01:12:53.460 --> 01:12:55.460]  или на списке?
[01:12:55.460 --> 01:12:57.460]  Ну нет, то есть нам не важно, нам важно, что stack
[01:12:57.460 --> 01:12:59.460]  умеет добавлять себе элементы, умеет удалять
[01:12:59.460 --> 01:13:01.460]  верхний элемент и умеет получать верхний элемент.
[01:13:01.460 --> 01:13:03.460]  Всё. То есть мы полностью описали stack,
[01:13:03.460 --> 01:13:05.460]  при этом совершенно абстрагируясь от
[01:13:05.460 --> 01:13:07.460]  деталей реализации.
[01:13:07.460 --> 01:13:09.460]  Понятно?
[01:13:09.460 --> 01:13:11.460]  Вот в этом преимущество объекто-ориентированного подхода.
[01:13:11.460 --> 01:13:13.460]  То есть мы вообще никак не вникаем в детали реализации, всё описано...
[01:13:13.460 --> 01:13:15.460]  То есть мы описали айтип
[01:13:15.460 --> 01:13:17.460]  в замкнутом виде с помощью
[01:13:17.460 --> 01:13:19.460]  специальных действий, которые можно над ним совершать.
[01:13:21.460 --> 01:13:23.460]  Ну и вот небольшое резюме.
[01:13:23.460 --> 01:13:25.460]  Объектно-ориентированная парадигма
[01:13:25.460 --> 01:13:27.460]  объектно-ориентированного программирования — это подход к
[01:13:27.460 --> 01:13:29.460]  разработке программ, который позволяет описывать
[01:13:29.460 --> 01:13:31.460]  вычисления в виде набора объектов
[01:13:31.460 --> 01:13:33.460]  и их взаимодействий.
[01:13:33.460 --> 01:13:35.460]  Ласса и структура отвечаются плюс-плюс за объектно-ориентированное
[01:13:35.460 --> 01:13:37.460]  программирование.
[01:13:37.460 --> 01:13:39.460]  Модификаторы доступа private и public позволяют вам
[01:13:39.460 --> 01:13:41.460]  осуществить
[01:13:41.460 --> 01:13:43.460]  сокрытие данных
[01:13:43.460 --> 01:13:45.460]  и сокрытие деталей реализации.
[01:13:45.460 --> 01:13:47.460]  Статические методы и константные методы тоже
[01:13:47.460 --> 01:13:49.460]  обсудили.
[01:13:49.460 --> 01:13:51.460]  Ну, на этом всё.
[01:13:51.460 --> 01:13:53.460]  Продолжим после перерыва.
[01:13:55.460 --> 01:13:57.460]  Небольшой дополнительный пункт,
[01:13:57.460 --> 01:13:59.460]  который касается
[01:13:59.460 --> 01:14:01.460]  классов, константности
[01:14:01.460 --> 01:14:03.460]  и тому подобное,
[01:14:03.460 --> 01:14:05.460]  связан с обсуждением
[01:14:05.460 --> 01:14:07.460]  логической и физической константности.
[01:14:07.460 --> 01:14:09.460]  Это вообще про что?
[01:14:09.460 --> 01:14:11.460]  Давайте будем говорить следующую вещь.
[01:14:11.460 --> 01:14:13.460]  Объект логически константный,
[01:14:13.460 --> 01:14:15.460]  если с точки зрения пользователя
[01:14:15.460 --> 01:14:17.460]  объект не меняет своё состояние.
[01:14:17.460 --> 01:14:19.460]  Если пользователь вообще
[01:14:19.460 --> 01:14:21.460]  никак не может понять, Сейчас
[01:14:21.460 --> 01:14:23.460]  как-то объект или нет.
[01:14:23.460 --> 01:14:25.460]  Если пользователь вызывает метод
[01:14:25.460 --> 01:14:27.460]  top, ему возвращается единица,
[01:14:27.460 --> 01:14:29.460]  а потом он ещё раз вызывает метод top,
[01:14:29.460 --> 01:14:31.460]  он возвращается к методу 2,
[01:14:31.460 --> 01:14:33.460]  то в этот момент объект не был
[01:14:33.460 --> 01:14:35.460]  логически константным.
[01:14:35.460 --> 01:14:37.460]  Потому что объект изменил своё состояние внутреннее.
[01:14:37.460 --> 01:14:39.460]  Если я вызываю метод
[01:14:39.460 --> 01:14:41.460]  top и его возвращает мне единицу,
[01:14:41.460 --> 01:14:43.460]  ещё раз вызываю top и его возвращает мне единицу,
[01:14:43.460 --> 01:14:45.460]  потом size тоже
[01:14:45.460 --> 01:14:51.460]  то есть с моей точки зрения в стеке, допустим, все объекты те же самые, что и были, скажем, до этого.
[01:14:51.460 --> 01:14:59.460]  В этот момент объект является логически константным. Но при этом в то же время объект может не быть физически константным.
[01:14:59.460 --> 01:15:05.460]  Физическая константность — это более сильное требование, которое говорит о том, что внутри объекта вообще ни одна убитая информация не изменилась.
[01:15:05.460 --> 01:15:17.460]  До этого мы рассматривали только логическую... Нет, до этого мы рассматривали физическую константность.
[01:15:17.460 --> 01:15:30.460]  Какой может быть пример? Представьте себе, у вас есть класс, который работает с сетью активно, что-то скачивает с интернета
[01:15:30.460 --> 01:15:35.460]  или посылает какую-то информацию по сети какому-то другому пользователю и так далее.
[01:15:35.460 --> 01:15:40.460]  И при этом он параллельно внутрь себя записывает какую-то информацию, то есть совершает логирование.
[01:15:40.460 --> 01:15:45.460]  Что столько-то байт было отправлено, они успешно дошли, столько-то байт было принято, они успешно прочитано и так далее.
[01:15:45.460 --> 01:15:49.460]  И вот вы пользуетесь таким классом, который посылает какую-то информацию и эту информацию принимает.
[01:15:49.460 --> 01:15:57.460]  С вашей точки зрения вам вообще не нужно знать про эту логику логирования, то, что он там периодически что-то пишет.
[01:15:57.460 --> 01:16:04.460]  В течение последнего часа ничего не было принято. Ваш интерес заключается только в том, что вы какие-то байты принимаете, какие-то байты отправляете.
[01:16:04.460 --> 01:16:10.460]  А то, что там у него какая-то внутренняя, допустим, строка изменяется за счет того, что он там что-то пишет, вас не интересует.
[01:16:10.460 --> 01:16:19.460]  Это ровно про то, что ваш объект логически константен. То есть те атрибуты, которыми вы обращаетесь, которыми вы работаете, они для вас неизменны.
[01:16:19.460 --> 01:16:26.460]  Но при этом внутри себя объект как-то меняется. И давайте попробуем как-то научиться эти 7 моментов разделять.
[01:16:26.460 --> 01:16:36.460]  Давайте еще один пример. Допустим у вас есть класс C, у которого есть какой-то внутренний счетчик, который просто берет и считает количество раз, которые вы вызвали, определенный метод, например, Get 0.
[01:16:36.460 --> 01:16:45.760]  Ну, ну просто для отладки. Вы просто считаете, сколько раз каждый метод был вызван. И потом смотрите что этот метод был вызван столько-то раз, этот метод был вызван сколько-то раз,
[01:16:45.760 --> 01:16:53.460]  и допустим вы понимаете, что этот метод вызывается много раз, поэтому нужно его оптимизировать. Этот метод почти не вызывается, поэтому можно пока начинать его забить.
[01:16:53.460 --> 01:16:59.720]  С точки зрения пользователя он объявляет константный объект c и пытается вызвать get 0,
[01:16:59.720 --> 01:17:08.700]  при этом он получает ошибку компиляции, ведь get 0 не объявлен как константный,
[01:17:08.700 --> 01:17:13.080]  при этом он не может быть константным. Потому что он что-то изменяет.
[01:17:13.080 --> 01:17:16.320]  Но пользователю в принципе всё равно, что он что-то изменяет.
[01:17:16.320 --> 01:17:21.260]  Со его точки зрения объект константный он считает it не то, rainbow и всё, что находится константным объектом,
[01:17:21.260 --> 01:17:22.220]  это получить 0.
[01:17:22.220 --> 01:17:24.220]  что если от объекта просто хотите получить 0,
[01:17:24.220 --> 01:17:26.220]  он не сохраняет свою константность.
[01:17:26.220 --> 01:17:28.220]  Согласитесь, странно.
[01:17:28.220 --> 01:17:30.220]  Логика с физикой тут не сходится.
[01:17:32.220 --> 01:17:34.220]  Как сказать компилятору, что данный объект
[01:17:34.220 --> 01:17:36.220]  является логически константным?
[01:17:36.220 --> 01:17:38.220]  И что на самом деле этот метод можно вызывать
[01:17:38.220 --> 01:17:42.220]  для константных объектов?
[01:17:42.220 --> 01:17:46.220]  Для этого есть специальное ключевое слово,
[01:17:46.220 --> 01:17:48.220]  ключевое слово mutable.
[01:17:48.220 --> 01:17:50.220]  Вот mutable дословно говорит следующее,
[01:17:50.220 --> 01:17:52.220]  что данное поле
[01:17:52.220 --> 01:17:54.220]  можно изменять
[01:17:54.220 --> 01:17:56.220]  в константных методах.
[01:17:56.220 --> 01:17:58.220]  Грубо говоря, вы говорите,
[01:17:58.220 --> 01:18:00.220]  что данное поле не влияет
[01:18:00.220 --> 01:18:02.220]  на логическую константность объектов.
[01:18:02.220 --> 01:18:04.220]  То есть то, что это поле изменяется,
[01:18:04.220 --> 01:18:06.220]  вообще никак не влияет на то, что объект константный,
[01:18:06.220 --> 01:18:08.220]  с логической точки зрения.
[01:18:08.220 --> 01:18:10.220]  Теперь вы можете сделать следующую вещь.
[01:18:10.220 --> 01:18:12.220]  Вы объявили поле Counter константным,
[01:18:12.220 --> 01:18:14.220]  и теперь вы можете сделать
[01:18:14.220 --> 01:18:16.220]  GetZero тоже константным.
[01:18:16.220 --> 01:18:18.220]  И теперь даже несмотря на то,
[01:18:18.220 --> 01:18:20.220]  что это поле,
[01:18:20.220 --> 01:18:22.220]  из-за того, что это поле объявлено как mutable,
[01:18:22.220 --> 01:18:24.220]  его изменять можно.
[01:18:24.220 --> 01:18:26.220]  Теперь я могу GetZero вызывать
[01:18:26.220 --> 01:18:28.220]  для константных объектов,
[01:18:28.220 --> 01:18:30.220]  даже несмотря на то, что какое-то поле там меняется.
[01:18:30.220 --> 01:18:32.220]  В данном случае,
[01:18:32.220 --> 01:18:34.220]  когда я написал ключевое слово mutable,
[01:18:34.220 --> 01:18:36.220]  у меня объект перешел в состояние физически константин
[01:18:36.220 --> 01:18:38.220]  в состояние логически константин.
[01:18:38.220 --> 01:18:40.220]  То есть с точки зрения логики он константный.
[01:18:40.220 --> 01:18:42.220]  С точки зрения внутреннего устройства
[01:18:42.220 --> 01:18:44.220]  он константный свой не сохраняет.
[01:18:48.220 --> 01:18:50.220]  Ну и давайте рассмотрим
[01:18:50.220 --> 01:18:52.220]  небольшой пример,
[01:18:52.220 --> 01:18:54.220]  как работают
[01:18:54.220 --> 01:18:56.220]  mutable, константные поля
[01:18:56.220 --> 01:18:58.220]  и константные методы.
[01:18:58.220 --> 01:19:00.220]  Вот у меня есть структура,
[01:19:00.220 --> 01:19:02.220]  у которой есть публичное поле x,
[01:19:02.220 --> 01:19:04.220]  публичное константо y
[01:19:04.220 --> 01:19:06.220]  и публичное mutable поле z.
[01:19:08.220 --> 01:19:10.220]  Ну и есть, собственно, метод f,
[01:19:10.220 --> 01:19:12.220]  который пытается изменить x, y и z.
[01:19:12.220 --> 01:19:14.220]  И есть константный метод g,
[01:19:14.220 --> 01:19:16.220]  который пытается изменить x, y и z.
[01:19:16.220 --> 01:19:18.220]  В методе f
[01:19:18.220 --> 01:19:20.220]  все ли будет корректно работать?
[01:19:20.220 --> 01:19:22.220]  Все ли три строки будут
[01:19:22.220 --> 01:19:24.220]  корректно работать?
[01:19:24.220 --> 01:19:26.220]  Какие строки не будут работать?
[01:19:26.220 --> 01:19:28.220]  Да, y менять нельзя.
[01:19:28.220 --> 01:19:30.220]  Почему?
[01:19:30.220 --> 01:19:32.220]  Потому что y, да, это константа.
[01:19:32.220 --> 01:19:34.220]  Константа менять нельзя.
[01:19:34.220 --> 01:19:36.220]  x, естественно, менять можно, z менять можно.
[01:19:36.220 --> 01:19:38.220]  Теперь у меня g константный.
[01:19:38.220 --> 01:19:40.220]  Какие строки у меня запрещены?
[01:19:40.220 --> 01:19:42.220]  Ну, понятное дело, y, как и раньше,
[01:19:42.220 --> 01:19:44.220]  запрещен, так как это константа.
[01:19:44.220 --> 01:19:46.220]  x нельзя.
[01:19:46.220 --> 01:19:48.220]  А z можно менять?
[01:19:48.220 --> 01:19:50.220]  z можно, да.
[01:19:50.220 --> 01:19:52.220]  Я написал специальное слово.
[01:19:52.220 --> 01:19:54.220]  Я подписал специальное разрешение
[01:19:54.220 --> 01:19:56.220]  у компилятора, что данное поле
[01:19:56.220 --> 01:19:58.220]  менять можно. Называется mutable.
[01:19:58.220 --> 01:20:00.220]  Mutable поля в константных моментах
[01:20:00.220 --> 01:20:02.220]  изменить можно.
[01:20:02.220 --> 01:20:04.220]  Соответственно, тут единственная строка,
[01:20:04.220 --> 01:20:06.220]  которая работает, это последняя z равно 2.
[01:20:06.220 --> 01:20:08.220]  Так, ну и
[01:20:08.220 --> 01:20:10.220]  давайте посмотрим направо.
[01:20:10.220 --> 01:20:12.220]  Я создал
[01:20:12.220 --> 01:20:14.220]  константный объект s и пытаюсь
[01:20:14.220 --> 01:20:16.220]  изменить x, y и z.
[01:20:16.220 --> 01:20:18.220]  Ну, давайте сразу скажем, что y нельзя,
[01:20:18.220 --> 01:20:20.220]  потому что y это константное поле.
[01:20:20.220 --> 01:20:22.220]  Могу ли я изменить x?
[01:20:22.220 --> 01:20:24.220]  Могу я изменить x?
[01:20:28.220 --> 01:20:30.220]  У меня объект sc это константный объект.
[01:20:32.220 --> 01:20:34.220]  Да, поэтому x менять нельзя.
[01:20:34.220 --> 01:20:36.220]  То есть не потому что x константный,
[01:20:36.220 --> 01:20:38.220]  а потому что сам объект, в котором принадлежит x,
[01:20:38.220 --> 01:20:40.220]  он константный. Могу ли я менять z?
[01:20:40.220 --> 01:20:42.220]  z могу менять,
[01:20:42.220 --> 01:20:44.220]  потому что z объявлено
[01:20:44.220 --> 01:20:46.220]  как mutable. Mutable это специальное поле,
[01:20:46.220 --> 01:20:48.220]  которое для константных объектов менять можно.
[01:20:48.220 --> 01:20:50.220]  То есть из константных методов и для константных
[01:20:50.220 --> 01:20:52.220]  объектов такие поля менять можно.
[01:20:52.220 --> 01:20:54.220]  Могу ли я вызвать
[01:20:54.220 --> 01:20:56.220]  функцию f?
[01:20:56.220 --> 01:20:58.220]  Вот здесь.
[01:20:58.220 --> 01:21:00.220]  Да, f не объявлено как
[01:21:00.220 --> 01:21:02.220]  константное. То есть у константных
[01:21:02.220 --> 01:21:04.220]  объектов можно
[01:21:04.220 --> 01:21:06.220]  вызывать только константные методы.
[01:21:06.220 --> 01:21:08.220]  Поэтому тут нельзя.
[01:21:08.220 --> 01:21:10.220]  Могу ли я вызвать метод g?
[01:21:10.220 --> 01:21:12.220]  Да.
[01:21:12.220 --> 01:21:14.220]  Да, почему?
[01:21:14.220 --> 01:21:30.220]  Потому что у меня есть
[01:21:30.220 --> 01:21:32.220]  константный метод g.
[01:21:32.220 --> 01:21:34.220]  Ну, и если я вызваю для не константного объекта fiy g,
[01:21:34.220 --> 01:21:36.220]  это будет работать?
[01:21:36.220 --> 01:21:40.160]  и мне с refers, чтобы не о fertility х работать, потому что f
[01:21:40.160 --> 01:21:44.080]  у меня не объявлен как constante, я вызываю его от неконстантного объекта.
[01:21:44.080 --> 01:21:49.740]  Вот, ну и g тоже вызывается, ну вызывается при этом неконстантная версия.
[01:21:49.740 --> 01:21:52.580]  Ну то же по понятным причинам.
[01:21:52.580 --> 01:21:55.060]  S у меня не константный объект и при этом у меня есть перегрузка,
[01:21:55.060 --> 01:21:58.360]  у меня есть g как для константного метода, как и для неконстантного метода.
[01:21:58.360 --> 01:22:00.620]  В данном случае вызывается неконстантный, потому что я вызываю его
[01:22:00.620 --> 01:22:03.620]  для неконстантных объектов.
[01:22:03.620 --> 01:22:10.580]  пример. Так, ну все, на этом закончим с первой презентацией и перейдем к следующей теме,
[01:22:10.580 --> 01:22:17.580]  которая называется шаблоны классов. Мы на самом базовом уровне, на первой половине,
[01:22:17.580 --> 01:22:23.660]  познакомились с классами, как с ними работать и так далее. И на прошлой лекции, неделю назад,
[01:22:23.660 --> 01:22:30.580]  мы говорили про шаблонные функции. И вот, собственно, для классов тоже существуют шаблоны, то есть
[01:22:30.580 --> 01:22:37.780]  классы тоже можно делать шаблонами. Ну и смысл, я думаю, тоже понятен. Вот, смотрите, вот мы
[01:22:37.780 --> 01:22:44.940]  буквально недавно написали stack, который работал с int. Но согласитесь, что stack может работать не
[01:22:44.940 --> 01:22:48.660]  только с int, но и вообще, в принципе, с любыми данными. То есть, может создать stack, который хранит
[01:22:48.660 --> 01:22:53.180]  даблы, может создать stack, который хранит були и так далее. Если вы хотите создать stack, который
[01:22:53.180 --> 01:22:57.260]  на текущем уровне развития, если мы хотим создать stack, который работает только с int,
[01:22:57.260 --> 01:23:02.460]  мы можем написать stack int. Если нам в какое-нибудь время понадобится stack, который работает с даблами,
[01:23:02.460 --> 01:23:07.060]  ну мы пишем отдельный класс, который работает, stack, который работает с даблами, ну и так далее.
[01:23:07.060 --> 01:23:14.700]  Ну и проблема, я думаю, уже понятна. Да? То есть, ну какой смысл писать для каждого отдельного
[01:23:14.700 --> 01:23:24.460]  типа свой stack, если реализации, ну по большому счету, отличаться не будут. Поэтому работает
[01:23:24.460 --> 01:23:29.620]  практически такой шаблонный синтаксис, как и для шаблонов функций. Что мы делаем? Ну, как и раньше,
[01:23:29.620 --> 01:23:35.380]  мы пишем преамбулу template класс T, то есть мы говорим, что теперь, что вот с данной строчки сейчас будет
[01:23:35.380 --> 01:23:39.940]  идти шаблон template. И дальше в треугольных скопах мы указываем, каким типом мы параметризуем наш
[01:23:39.940 --> 01:23:44.740]  класс. В данном случае мы говорим, что будет, что наш класс параметризован одним типом шаблоном,
[01:23:44.740 --> 01:23:50.860]  и это тип T. Мы так называем его. И дальше мы пишем обычную реализацию класса, но просто вместо
[01:23:50.860 --> 01:23:57.420]  конкретных типов мы подставляем тип T. Ну, помните, да? То есть, то же самое, что и для функций.
[01:23:57.420 --> 01:24:07.860]  То есть, теперь нам нужно создать не массив интов, а массив элементов T. У нас push теперь принимает
[01:24:07.860 --> 01:24:15.300]  не int, а принимает произвольное значение T и так далее. Ну, при этом size, то есть вне зависимости
[01:24:16.140 --> 01:24:20.260]  какие элементы содержатся в стэке, у меня size всегда возвращают либо int, либо size t.
[01:24:20.260 --> 01:24:28.640]  Ну, и теперь я могу создавать стэки, которые содержат различные элементы. Например, могу
[01:24:28.640 --> 01:24:34.420]  вот так создать стек, который содержит int. Вот так могу создать стек, который содержит phenix.
[01:24:34.420 --> 01:24:38.940]  Соответственно, могу сделать push в стэке, который содержит int. Вот так могу сделать push в стек,
[01:24:38.940 --> 01:24:44.600]  который содержит даблы. Ну и при этом, так как у меня push объявлен как метод, который принимает тип t,
[01:24:44.600 --> 01:24:49.500]  ну здесь у меня реально будет добавлен элемент единица, тут у меня реально будет добавлен элемент 1.0.
[01:24:49.500 --> 01:24:57.780]  Ну, литерал типа double. Что тут важно понимать? Точно так же, как и для шаблонов функций,
[01:24:57.780 --> 01:25:02.060]  когда мы говорили, что у нас один шаблон функции инстанцирован int, а другой инстанцирован
[01:25:02.060 --> 01:25:07.180]  с помощью дабла, мы говорили, что это абсолютно разные функции, так как внутри них, по сути,
[01:25:07.180 --> 01:25:13.620]  описан различный код. Вот для шаблонных классов тоже самое. Stack int и stack double это абсолютно разные
[01:25:13.620 --> 01:25:20.540]  типы, которые никак не связаны. Понятно? То есть можно считать, что вы написали вот такой код,
[01:25:20.540 --> 01:25:25.060]  вы отдельно создали stack int и отдельно создали stack double. Просто это сделали не вы, а за вас это
[01:25:25.060 --> 01:25:29.820]  сделан компилятор. То есть компилятор отдельно поставил для вас int и отдельно поставил для вас
[01:25:29.820 --> 01:25:35.820]  double. То есть грубо говоря, нельзя сделать stack int равно stack double, то есть нельзя один stack
[01:25:35.820 --> 01:25:42.180]  присвоить другому. Просто потому, что это несовместимые типы, они абсолютно разные.
[01:25:42.180 --> 01:25:48.940]  С точки зрения компилятора они вообще никак не связаны. Это как если бы вы объявили два разных
[01:25:48.940 --> 01:25:57.260]  класса. Отлично. В отличие от обычных классов, их можно объявлять только в области видимости
[01:25:57.260 --> 01:26:01.500]  пространства имен либо внутри другого класса. То есть мы помним, что структуры на самом деле можно
[01:26:01.820 --> 01:26:05.520]  объявлять внутри других функций. То есть вы внутри функций можете написать структ и
[01:26:05.520 --> 01:26:09.540]  объявить структуру. Тоже самое для классов- вы можете взять класс и написать его внутри
[01:26:09.540 --> 01:26:14.460]  функций в локальной области видимости. Шаблоны классов можно объявлять только в глобальной
[01:26:14.460 --> 01:26:19.020]  области видимости, либо в пространстве видимости-какого-то пространства имен. Внутри
[01:26:19.020 --> 01:26:25.740]  функций шаблоны классов объявлять нельзя. Дальше тип шаблонового параметра в отличии от функций
[01:26:25.740 --> 01:26:29.900]  нужно указывать явно, то есть мы помним, что если у нас была какая-то шаблонная функция,
[01:26:29.900 --> 01:26:35.900]  то у меня тип T выводится автоматически. То есть компилятор видит, что 0 имеет тип int,
[01:26:35.900 --> 01:26:41.900]  и поэтому вместо типа T подставляется нужный мне тип, то есть int.
[01:26:41.900 --> 01:26:47.900]  В случае шаблонов классов, у меня нет никакой возможности,
[01:26:47.900 --> 01:26:53.900]  то есть, в принципе, у меня нет никакой возможности выводить тип int.
[01:26:53.900 --> 01:26:58.900]  В случае шаблонов классов у меня нет никакой возможности,
[01:26:58.900 --> 01:27:02.900]  то есть, у компилятора нет возможности вывести нужный вам тип,
[01:27:02.900 --> 01:27:06.900]  потому что это не функция, у классов нет аргументов, грубо говоря.
[01:27:06.900 --> 01:27:09.900]  Вы создаете класс и дальше пользуетесь его методами.
[01:27:09.900 --> 01:27:12.900]  Но при этом понять, какой шаблонный тип нужно подставлять,
[01:27:12.900 --> 01:27:16.900]  компилятор должен именно в момент создания объекта вашего класса.
[01:27:16.900 --> 01:27:20.900]  Поэтому здесь нужно указывать явно тип, который вам нужен.
[01:27:20.900 --> 01:27:28.900]  Правда, это было верно до C++17. В C++17 про конструктор мы поговорим в следующий раз уже.
[01:27:28.900 --> 01:27:32.900]  Но если по конструктору теоретически возможно вывести ваши типы,
[01:27:32.900 --> 01:27:36.900]  то необходимый тип будет выведен.
[01:27:36.900 --> 01:27:41.900]  Давайте в общем случае считать, что тип для классов нужно всегда указывать,
[01:27:41.900 --> 01:27:45.900]  и нет никаких исключений.
[01:27:46.900 --> 01:27:51.900]  Еще важный момент, шаблоны классов, как и любые другие шаблоны, инстанцируются лениво.
[01:27:51.900 --> 01:27:55.900]  Что это значит? Это значит, что если вы этот шаблон никак не используете,
[01:27:55.900 --> 01:27:58.900]  то это значит, что у вас ни одного класса в итоге создана не будет.
[01:27:58.900 --> 01:28:03.900]  В данном случае у вас есть структура S, и вы создали структуру S только от int.
[01:28:03.900 --> 01:28:06.900]  То есть вы инстанцировали только ее int.
[01:28:06.900 --> 01:28:10.900]  Никаких других структур S у вас в программе в принципе не существует.
[01:28:10.900 --> 01:28:14.900]  Понятно, да? То есть у вас S double, S float и так далее не создаются.
[01:28:14.900 --> 01:28:19.900]  Более того, методы шаблонного класса тоже инстанцируются лениво.
[01:28:19.900 --> 01:28:26.900]  То есть если вы создали объект шаблонного класса от int
[01:28:26.900 --> 01:28:30.900]  и вызвали метод f, и ни разу не вызывали метод g,
[01:28:30.900 --> 01:28:35.900]  то можно считать, что метода g в вашем классе не существует.
[01:28:35.900 --> 01:28:38.900]  Он просто-напросто не будет инстанцироваться.
[01:28:38.900 --> 01:28:42.900]  То есть кода для функции g, для метода g сгенерирована не будет.
[01:28:42.900 --> 01:28:48.900]  То есть сами классы инстанцируются лениво, и плюс их методы тоже инстанцируются лениво.
[01:28:48.900 --> 01:28:52.900]  Если вы ни один из методов не вызвали, то ни одного метода вашего класса просто-напросто нет.
[01:28:52.900 --> 01:29:00.900]  Ну и тоже понятно, это сделано для того, чтобы рационально использовать ваше время компиляцию.
[01:29:00.900 --> 01:29:03.900]  То есть согласитесь, если у вас есть класс, который шаблонный,
[01:29:03.900 --> 01:29:07.900]  и вы создаете такой шаблонный класс, во-первых, с кучей параметров,
[01:29:07.900 --> 01:29:11.900]  и для каждого из этих параметров нужно создать все методы, но это долго.
[01:29:11.900 --> 01:29:13.900]  Поэтому компилятор поступает в следующем образом.
[01:29:13.900 --> 01:29:17.900]  Он смотрит, во-первых, с какими типами вы создаете ваши классы,
[01:29:17.900 --> 01:29:20.900]  и какие методы там вызываете. Вот только эти методы он создает.
[01:29:20.900 --> 01:29:22.900]  Все, остальные просто-напросто игнорируются.
[01:29:22.900 --> 01:29:24.900]  Да.
[01:29:36.900 --> 01:29:38.900]  Ну, смотрите, очень просто.
[01:29:38.900 --> 01:29:43.900]  Тут очень просто. Если вы не хотите, чтобы инстанцировал G, вы просто-напросто не вызываете G.
[01:29:43.900 --> 01:29:47.900]  То есть если вы хотите, чтобы для дабла не инстанцировался G,
[01:29:47.900 --> 01:29:53.900]  то вы делаете дабл и вызываете SG. Все очень просто.
[01:29:53.900 --> 01:29:55.900]  Тут есть другой вопрос.
[01:29:55.900 --> 01:30:01.900]  А что, если вы хотите, чтобы, скажем, S от int и S от дабла работало разным образом, например?
[01:30:01.900 --> 01:30:06.900]  То есть вы хотите, чтобы, например, функция f для int выводила котики,
[01:30:06.900 --> 01:30:09.900]  функция f для дабла выводила собачки, ну вот как-то так.
[01:30:09.900 --> 01:30:14.900]  Такое можно сделать. И это называется специализация шаблонов.
[01:30:18.900 --> 01:30:21.900]  Ровно так, как у нас было для шаблонов функций,
[01:30:21.900 --> 01:30:25.900]  мы помним, что шаблоны функций можно специализировать.
[01:30:25.900 --> 01:30:30.900]  То есть помните, мы для комплексного числа писали специализацию функции abs.
[01:30:30.900 --> 01:30:35.900]  То есть взятие модуля для обычного числа это просто сравнение с нулем, плюс вывод x или минус x.
[01:30:35.900 --> 01:30:43.900]  А специализация для комплексного числа, она выводила корень квадратный из суммы квадратов действительно имнимой частей.
[01:30:43.900 --> 01:30:46.900]  Вот шаблоны классов тоже можно специализировать.
[01:30:46.900 --> 01:30:49.900]  Но, на самом деле, для шаблонов классов это имеет гораздо больший смысл.
[01:30:49.900 --> 01:30:51.900]  Ну, смотрите, например, какой.
[01:30:51.900 --> 01:30:58.900]  Вот представьте себе, что я хочу написать класс, который выдает мне ответ.
[01:30:58.900 --> 01:31:01.900]  Является ли тип, который я передал int или нет.
[01:31:01.900 --> 01:31:04.900]  Я тогда могу написать следующим образом.
[01:31:04.900 --> 01:31:07.900]  Я пишу общий шаблон вот таким образом.
[01:31:07.900 --> 01:31:15.900]  То есть я говорю, что template класс T, структура из int и создаю там статическое константное polyvalue, которое false.
[01:31:15.900 --> 01:31:16.900]  Ну, понятно дело.
[01:31:16.900 --> 01:31:19.900]  В общем случае, тип T у меня не является int.
[01:31:19.900 --> 01:31:22.900]  А теперь я пишу специализацию.
[01:31:22.900 --> 01:31:25.900]  Полная специализация, вы помните, пишется вот так.
[01:31:25.900 --> 01:31:29.900]  Template и дальше пустые треугольные скобки.
[01:31:29.900 --> 01:31:33.900]  Если я писал template и пустые треугольные скобки, значит сейчас идет специализация.
[01:31:33.900 --> 01:31:39.900]  Дальше я пишу структ из int и дальше указываю тип, который я специализирую.
[01:31:39.900 --> 01:31:43.900]  То есть в данном случае я говорю, что структура из int, точнее шаблонная структура из int,
[01:31:43.900 --> 01:31:47.900]  для int должна вести себя другим образом.
[01:31:47.900 --> 01:31:48.900]  Каким? А вот таким.
[01:31:48.900 --> 01:31:52.900]  Собственно, у нее value в статическом поле должно быть равно true.
[01:31:52.900 --> 01:31:54.900]  И теперь, если я сделаю следующую вещь.
[01:31:54.900 --> 01:32:05.900]  Если я спрошу из int, скажем, double и спрошу value, то мне вернется false.
[01:32:05.900 --> 01:32:08.900]  Точнее value будет иметь значение false.
[01:32:08.900 --> 01:32:16.900]  Если я спрошу из int value, то у меня будет true.
[01:32:16.900 --> 01:32:18.900]  Такие примеры на самом деле не интересны.
[01:32:18.900 --> 01:32:20.900]  У вас наверное возникают вопросы, зачем это нужно.
[01:32:20.900 --> 01:32:25.900]  Казалось бы, если я тут указываю тип, я понимаю, что у меня int, а что у меня не int.
[01:32:25.900 --> 01:32:31.900]  Давайте я приведу пример, когда вы не понимаете, int у вас или не int.
[01:32:31.900 --> 01:32:33.900]  Значит, пример такой.
[01:32:33.900 --> 01:32:36.900]  Давайте я заведу шаблонную функцию.
[01:32:36.900 --> 01:32:48.900]  Template, class t, void f, tx.
[01:32:48.900 --> 01:32:52.900]  Тип t, это int или не int?
[01:32:56.900 --> 01:32:58.900]  Вот вы и попали.
[01:32:58.900 --> 01:33:03.900]  В шаблонной функции непонятно, тип t является int или нет.
[01:33:03.900 --> 01:33:08.900]  Когда вы пишете шаблонную функцию, вы не знаете ничего конкретного об этом типе.
[01:33:08.900 --> 01:33:12.900]  А что если я хочу, в зависимости от того, что мне передали int или не int,
[01:33:12.900 --> 01:33:15.900]  я хочу вывести то или иное сообщение.
[01:33:15.900 --> 01:33:17.900]  Как это теперь можно сделать?
[01:33:17.900 --> 01:33:19.900]  С помощью данного класса можно поступить следующим образом.
[01:33:19.900 --> 01:33:33.900]  Я пишу, если из int t value, то cout int.
[01:33:33.900 --> 01:33:41.900]  Ну а иначе cout not int.
[01:33:41.900 --> 01:33:48.900]  Ну, понятно, делать пример игрушечный, но, в принципе, на практике возникает ситуация,
[01:33:48.900 --> 01:33:52.900]  в которой вам нужна зависимость от того, какой тип вам передали, действовать так или иначе.
[01:33:52.900 --> 01:33:54.900]  Понятно, да?
[01:33:54.900 --> 01:34:09.900]  Нет, проблема в том, что если вы пишете специализацию, то нужно все писать полностью.
[01:34:09.900 --> 01:34:22.900]  Здесь это указано, что на самом деле шаблоны специализации никак не связаны.
[01:34:22.900 --> 01:34:27.900]  Если вы пишете специализацию, то вы обязаны написать класс заново.
[01:34:27.900 --> 01:34:32.900]  Вы сдаете специальное поведение, и при этом из общего шаблона ничего браться не будет.
[01:34:32.900 --> 01:34:39.900]  Например, вы можете написать абсолютно другую реализацию из int для константного указателя на bool.
[01:34:39.900 --> 01:34:41.900]  Не знаю почему, но вот решили так.
[01:34:41.900 --> 01:34:46.900]  Вы написали структуру из int, специализацию, которая действует следующим образом.
[01:34:46.900 --> 01:34:49.900]  Если она инстанцирована с помощью константного указателя на bool,
[01:34:49.900 --> 01:34:54.900]  у нее нет статического поля value, но при этом есть метод print, который печатает no.
[01:35:02.900 --> 01:35:04.900]  Еще раз не понял.
[01:35:04.900 --> 01:35:13.900]  Для шаблонов тоже можно так сделать.
[01:35:13.900 --> 01:35:23.900]  Давайте в общем случае напишу, как у вас есть шаблонная структура,
[01:35:24.900 --> 01:35:28.900]  template class t.
[01:35:28.900 --> 01:35:34.900]  У вас есть структура s, внутри которой есть метод f.
[01:35:34.900 --> 01:35:38.900]  Как написать реализацию метода f вне класса?
[01:35:38.900 --> 01:35:40.900]  Делается следующим образом.
[01:35:40.900 --> 01:35:45.900]  Вы также пишете template class t.
[01:35:45.900 --> 01:35:54.900]  Ну и дальше, как обычно, пишете void s от t, 2.2.f.
[01:35:54.900 --> 01:35:57.900]  И дальше пишете реализацию.
[01:35:57.900 --> 01:35:59.900]  Просто полное имя функции.
[01:35:59.900 --> 01:36:04.900]  Теперь вам нужно написать preamble template, чтобы можно было ввести такое имя как t.
[01:36:04.900 --> 01:36:08.900]  Чтобы комплятор понимал, что t – это имя шаблонного параметра.
[01:36:08.900 --> 01:36:10.900]  Дальше вы пишете полное имя функции.
[01:36:10.900 --> 01:36:16.900]  Это s с параметром t, 2.2.f.
[01:36:16.900 --> 01:36:18.900]  Здесь уже понятно, что вы хотите.
[01:36:18.900 --> 01:36:22.900]  Вы хотите реализовать функцию f, которая находится в специализации или не в специализации.
[01:36:22.900 --> 01:36:25.900]  Потому что когда подставляется тип t, то уже понятно, что вы делаете.
[01:36:25.900 --> 01:36:28.900]  Для специализации или не для специализации.
[01:36:28.900 --> 01:36:30.900]  Вернемся к этому примеру.
[01:36:30.900 --> 01:36:35.900]  В общем, заметьте, что у меня есть общий шаблон, который работает для всех типов.
[01:36:35.900 --> 01:36:40.900]  Есть специализация для int, есть специализация для константов и указателей на bool.
[01:36:40.900 --> 01:36:44.900]  И при этом заметьте, что последняя специализация кардинально отличается от первых двух.
[01:36:44.900 --> 01:36:50.900]  В ней нет статического поля value, и в ней есть метод print, которого нет в других методах.
[01:36:50.900 --> 01:36:53.900]  То есть специализация может кардинально отличаться от общего шаблона.
[01:36:53.900 --> 01:37:00.900]  То есть нет никакого правила языка, который бы вас заставлял писать специализацию точно такой же, как и общий шаблон.
[01:37:00.900 --> 01:37:03.900]  Специализация отдельно, общий шаблон отдельно.
[01:37:06.900 --> 01:37:09.900]  Вот классический пример использования.
[01:37:09.900 --> 01:37:13.900]  Я написал здесь, чтобы проверить какие-то свойства типов.
[01:37:18.900 --> 01:37:21.900]  Давайте еще. Нет, не еще, а вот еще важный момент.
[01:37:21.900 --> 01:37:28.900]  Для шаблонных классов, помимо полной специализации, существует понятие частичной специализации.
[01:37:28.900 --> 01:37:31.900]  Что такое частичная специализация?
[01:37:31.900 --> 01:37:36.900]  Частичная специализация позволяет вам указать специальное поведение не для конкретного типа.
[01:37:36.900 --> 01:37:39.900]  Вот как здесь, мы указали, как должен вести себя общий шаблон
[01:37:39.900 --> 01:37:43.900]  и как должна себя вести структура из int в случае int.
[01:37:43.900 --> 01:37:47.900]  То есть мы указали конкретный тип int и указали, как ему нужно действовать в этом случае.
[01:37:47.900 --> 01:37:52.900]  В случае частичной специализации мы указываем не конкретные тип или не конкретные типы,
[01:37:52.900 --> 01:37:55.900]  а указываем некоторое семейство типов.
[01:37:55.900 --> 01:37:59.900]  Вот, например, еще одно классическое использование специализации шаблонов классов.
[01:37:59.900 --> 01:38:04.900]  То есть мы хотим понять, является ли переданный тип указателем или нет.
[01:38:04.900 --> 01:38:07.900]  Как мы это делаем? Мы пишем общий шаблон.
[01:38:07.900 --> 01:38:09.900]  template class t struct is pointer.
[01:38:09.900 --> 01:38:13.900]  Дальше мы заводим статическую констант node bool, которая равна false.
[01:38:13.900 --> 01:38:16.900]  В общем случае у меня t не является указателем.
[01:38:16.900 --> 01:38:19.900]  В общем случае не является указателем.
[01:38:19.900 --> 01:38:22.900]  Ну и для примера я еще завел статическую функцию из endpoint,
[01:38:22.900 --> 01:38:26.900]  который возвращает, является ли t указателем на int.
[01:38:26.900 --> 01:38:28.900]  Естественно, не является.
[01:38:28.900 --> 01:38:33.900]  А теперь я завожу специализацию, которая работает для всех указателей.
[01:38:33.900 --> 01:38:35.900]  Я это делаю следующим образом.
[01:38:35.900 --> 01:38:37.900]  Смотрите, во-первых, я пишу class t.
[01:38:37.900 --> 01:38:40.900]  Что уже говорит, что это не полная специализация.
[01:38:40.900 --> 01:38:45.900]  В случае полной специализации у меня треугольные скобки пустые.
[01:38:45.900 --> 01:38:52.900]  И дальше я указываю вот здесь уточненный тип.
[01:38:52.900 --> 01:38:55.900]  Понятно?
[01:38:55.900 --> 01:39:00.900]  То есть я указываю, что данная специализация должна работать для всех типов,
[01:39:00.900 --> 01:39:02.900]  которые представимы в виде t звездочка.
[01:39:02.900 --> 01:39:04.900]  То есть для всех указателей.
[01:39:08.900 --> 01:39:10.900]  Ну и дальше, что я говорю.
[01:39:10.900 --> 01:39:14.900]  Если мне передали указатель, то я должен вернуть true и isn't pointer в случае false.
[01:39:14.900 --> 01:39:18.900]  То есть если мне передали указатель, то в общем случае он не является указателем на int.
[01:39:18.900 --> 01:39:21.900]  Я написал частичную специализацию.
[01:39:26.900 --> 01:39:28.900]  Вот здесь?
[01:39:28.900 --> 01:39:30.900]  Потому что class t именует тип.
[01:39:30.900 --> 01:39:32.900]  А здесь я его уточняю.
[01:39:34.900 --> 01:39:36.900]  То есть я не могу здесь написать t звездочка.
[01:39:36.900 --> 01:39:38.900]  Тут у меня должно быть имя.
[01:39:38.900 --> 01:39:40.900]  Имя не может содержать звездочку.
[01:39:44.900 --> 01:39:48.900]  На самом деле тут есть проблема небольшая в данной реализации.
[01:39:48.900 --> 01:39:50.900]  Может кто-нибудь понимает какая проблема?
[01:39:50.900 --> 01:39:52.900]  Почему это на самом деле неправильная реализация?
[01:39:52.900 --> 01:39:54.900]  Почему на самом деле...
[01:39:54.900 --> 01:39:56.900]  Ну так конечно можно проверять на указатель,
[01:39:56.900 --> 01:39:59.900]  но вот для некоторых указателей вот эта штука работать не будет.
[01:39:59.900 --> 01:40:01.900]  Для каких?
[01:40:01.900 --> 01:40:03.900]  Что?
[01:40:03.900 --> 01:40:05.900]  Совсем не совсем понятно.
[01:40:05.900 --> 01:40:07.900]  Указательный констант или константный указатель?
[01:40:07.900 --> 01:40:17.900]  Короче, если вы в isIntPointer
[01:40:17.900 --> 01:40:21.900]  передадите int звездочка конст,
[01:40:21.900 --> 01:40:25.900]  то выберется какой шаблон?
[01:40:25.900 --> 01:40:27.900]  Вот этот шаблон общий.
[01:40:27.900 --> 01:40:29.900]  Понятно почему?
[01:40:29.900 --> 01:40:32.900]  Потому что вот этот тип int звездочка конст
[01:40:32.900 --> 01:40:35.900]  непредставим в виде t звездочка.
[01:40:35.900 --> 01:40:37.900]  Что мне нужно поставить вместо t,
[01:40:37.900 --> 01:40:41.900]  чтобы t звездочка был равен int звездочка конст?
[01:40:41.900 --> 01:40:43.900]  Решите ребус.
[01:40:47.900 --> 01:40:49.900]  Нет, вместо... вот смотрите, вот ребус вам.
[01:40:49.900 --> 01:40:53.900]  Уравнение на языке C++.
[01:40:53.900 --> 01:40:55.900]  t звездочка равно int звездочка конст.
[01:40:55.900 --> 01:40:57.900]  Найти t.
[01:41:00.900 --> 01:41:02.900]  Ответ.
[01:41:03.900 --> 01:41:05.900]  Короче, нет такого t,
[01:41:05.900 --> 01:41:08.900]  который бы давал int звездочка конст.
[01:41:10.900 --> 01:41:12.900]  Поэтому тут еще нужно дополнительно
[01:41:12.900 --> 01:41:14.900]  прописать специализацию,
[01:41:14.900 --> 01:41:16.900]  которая принимает константные указатели.
[01:41:16.900 --> 01:41:18.900]  Это детали уже.
[01:41:18.900 --> 01:41:20.900]  А если я передам, скажем,
[01:41:20.900 --> 01:41:23.900]  вот такой пример, если я передам конст
[01:41:23.900 --> 01:41:25.900]  int звездочка,
[01:41:25.900 --> 01:41:27.900]  что у меня выберется?
[01:41:27.900 --> 01:41:29.900]  Общий шаблон или специализация?
[01:41:32.900 --> 01:41:34.900]  Нет, давайте про третий,
[01:41:34.900 --> 01:41:36.900]  пока забуду. Нет, третьим выбран не будет.
[01:41:36.900 --> 01:41:38.900]  Почему второе?
[01:41:38.900 --> 01:41:40.900]  Да, потому что если я вместо t
[01:41:40.900 --> 01:41:42.900]  подставлю конст int,
[01:41:42.900 --> 01:41:44.900]  то у меня частичная специализация,
[01:41:44.900 --> 01:41:46.900]  вот эта вторая, будет подходить лучше,
[01:41:46.900 --> 01:41:48.900]  чем первая.
[01:41:48.900 --> 01:41:50.900]  Опять же, по принципу, наименьше подстановки.
[01:41:50.900 --> 01:41:52.900]  В первом случае мне нужно подставить
[01:41:52.900 --> 01:41:54.900]  констант звездочка целиком,
[01:41:54.900 --> 01:41:56.900]  а в втором случае только конст инт.
[01:41:56.900 --> 01:41:58.900]  Такой незначительный момент,
[01:41:58.900 --> 01:42:00.900]  хорошо обсудили.
[01:42:00.900 --> 01:42:02.900]  Это полная специализация.
[01:42:02.900 --> 01:42:04.900]  Помимо частичной специализации
[01:42:04.900 --> 01:42:06.900]  я могу одновременно написать и полную специализацию.
[01:42:06.900 --> 01:42:08.900]  То есть я могу писать как частичные,
[01:42:08.900 --> 01:42:10.900]  так и полную специализацию.
[01:42:10.900 --> 01:42:12.900]  Но в данном случае я написал полную специализацию
[01:42:12.900 --> 01:42:14.900]  для int звездочки, и тогда,
[01:42:14.900 --> 01:42:16.900]  понятно дело, что статическое поле
[01:42:16.900 --> 01:42:18.900]  у меня должно содержать true,
[01:42:18.900 --> 01:42:20.900]  и статический метод должен возвращать true,
[01:42:20.900 --> 01:42:22.900]  потому что int звездочка — это указатель на int.
[01:42:22.900 --> 01:42:24.900]  Ну и область применения
[01:42:24.900 --> 01:42:26.900]  примерно такая же, как и здесь.
[01:42:26.900 --> 01:42:28.900]  То есть как было указано вот здесь.
[01:42:28.900 --> 01:42:30.900]  То есть если я работаю внутри
[01:42:30.900 --> 01:42:32.900]  шаблонной функции, я не понимаю,
[01:42:32.900 --> 01:42:34.900]  то есть я хочу понять что-то про тип,
[01:42:34.900 --> 01:42:36.900]  то я могу вот использовать этот isPointer
[01:42:36.900 --> 01:42:38.900]  и понять, что мне передали указатель или не указатель.
[01:42:38.900 --> 01:42:40.900]  Ну и в зависимости от этого использовать там
[01:42:40.900 --> 01:42:42.900]  разные реализации.
[01:42:46.900 --> 01:42:48.900]  Ну и пример как это все работает.
[01:42:48.900 --> 01:42:50.900]  Если я инстанцирую isPointer от int,
[01:42:50.900 --> 01:42:52.900]  то у меня value — это false,
[01:42:52.900 --> 01:42:54.900]  и isIntPointer тоже false.
[01:42:54.900 --> 01:42:56.900]  Ну понятно, потому что вызывается
[01:42:56.900 --> 01:42:58.900]  общий шаблон.
[01:42:58.900 --> 01:43:00.900]  Если вызываю isIntPointer от char звездочка,
[01:43:00.900 --> 01:43:02.900]  то у меня value равно 1,
[01:43:02.900 --> 01:43:04.900]  то есть char звездочка — это указатель.
[01:43:04.900 --> 01:43:06.900]  А если я спрашиваю верно ли,
[01:43:06.900 --> 01:43:08.900]  что это указатель на int, то возвращается 0.
[01:43:08.900 --> 01:43:10.900]  Ну и в последнем случае
[01:43:10.900 --> 01:43:12.900]  у меня работает полная специализация,
[01:43:12.900 --> 01:43:14.900]  то есть для value возвращается true,
[01:43:14.900 --> 01:43:16.900]  для isIntPointer возвращается тоже true.
[01:43:16.900 --> 01:43:18.900]  Все нормально.
[01:43:18.900 --> 01:43:20.900]  С этим разбрались?
[01:43:20.900 --> 01:43:22.900]  Понятно, как работает частичная специализация?
[01:43:22.900 --> 01:43:24.900]  И чем она отличается от полной?
[01:43:26.900 --> 01:43:28.900]  Частичная специализация уточняет
[01:43:28.900 --> 01:43:30.900]  для некоторого множества типов,
[01:43:30.900 --> 01:43:32.900]  а полная специализация уточняет только для конкретного типа.
[01:43:36.900 --> 01:43:38.900]  Ну и еще один пример.
[01:43:38.900 --> 01:43:40.900]  На самом деле тип можно уточнять...
[01:43:40.900 --> 01:43:42.900]  Короче, вот эта штука
[01:43:42.900 --> 01:43:44.900]  тоже является частичной специализацией.
[01:43:44.900 --> 01:43:46.900]  Почему? Потому что я указал...
[01:43:46.900 --> 01:43:48.900]  Если у меня есть шаблон, который принимает
[01:43:48.900 --> 01:43:50.900]  два аргумента, и я уточнил только один из них,
[01:43:50.900 --> 01:43:52.900]  то это тоже частичная специализация.
[01:43:52.900 --> 01:43:54.900]  Полная специализация была бы,
[01:43:54.900 --> 01:43:56.900]  если бы я уточнил и первый тип,
[01:43:56.900 --> 01:43:58.900]  и второй тип.
[01:43:58.900 --> 01:44:00.900]  Окей?
[01:44:00.900 --> 01:44:02.900]  Вот.
[01:44:02.900 --> 01:44:04.900]  Так, ну и давайте попробуем...
[01:44:04.900 --> 01:44:06.900]  Вот эта пусть единица, это два, это три.
[01:44:06.900 --> 01:44:08.900]  Вот. Скажем...
[01:44:08.900 --> 01:44:10.900]  Давайте для каждой строки, вот здесь,
[01:44:10.900 --> 01:44:12.900]  поймем, какой шаблон
[01:44:12.900 --> 01:44:14.900]  используется, общий,
[01:44:14.900 --> 01:44:16.900]  второй или третий.
[01:44:16.900 --> 01:44:18.900]  Вот для первой строки, если я создаю s
[01:44:18.900 --> 01:44:20.900]  с параметрами bool и bool.
[01:44:22.900 --> 01:44:24.900]  Да, общий шаблон, потому что
[01:44:24.900 --> 01:44:26.900]  ни второй, ни третий не подходят.
[01:44:26.900 --> 01:44:28.900]  То есть у меня второй аргумент не int, первый аргумент не float.
[01:44:28.900 --> 01:44:30.900]  Если я вызываю bool int,
[01:44:30.900 --> 01:44:32.900]  что у меня?
[01:44:32.900 --> 01:44:34.900]  Да, второй, потому что второй лучше всего
[01:44:34.900 --> 01:44:36.900]  подходит.
[01:44:36.900 --> 01:44:38.900]  Понятно, что подходит и первый, но по принципу
[01:44:38.900 --> 01:44:40.900]  наименьшего действия мы выбираем только
[01:44:40.900 --> 01:44:42.900]  второй.
[01:44:42.900 --> 01:44:44.900]  В третьем...
[01:44:44.900 --> 01:44:46.900]  В третьем вызывается
[01:44:46.900 --> 01:44:48.900]  третий, а в четвертом...
[01:44:52.900 --> 01:44:54.900]  Уже обсуждение какое-то пошло.
[01:44:54.900 --> 01:44:56.900]  Кто за второй вариант?
[01:44:58.900 --> 01:45:00.900]  Кто за третий?
[01:45:00.900 --> 01:45:02.900]  А кто за ошибка
[01:45:02.900 --> 01:45:04.900]  эмпиляции?
[01:45:04.900 --> 01:45:06.900]  Победа.
[01:45:06.900 --> 01:45:08.900]  Действительно, будет ошибка эмпиляции. Почему?
[01:45:08.900 --> 01:45:10.900]  Ну, просто потому, что
[01:45:10.900 --> 01:45:12.900]  эмпилятор... ну, смотрите,
[01:45:12.900 --> 01:45:14.900]  и вот этот тип, и вот этот тип они одинаково точные.
[01:45:14.900 --> 01:45:16.900]  Ну, то есть
[01:45:16.900 --> 01:45:18.900]  когда выбирается частичная
[01:45:18.900 --> 01:45:20.900]  специализация, происходит так называемая
[01:45:20.900 --> 01:45:22.900]  частичное упорядочение специализаций.
[01:45:22.900 --> 01:45:24.900]  То есть, эмпилилатор смотрит
[01:45:24.900 --> 01:45:26.900]  ну, грубо говоря, верно лишь,
[01:45:26.900 --> 01:45:28.900]  что
[01:45:28.900 --> 01:45:30.900]  параметры одного шаблона
[01:45:30.900 --> 01:45:32.900]  включены в параметру другого шаблона,
[01:45:32.900 --> 01:45:34.900]  то есть, просто есть множество параметров для первого
[01:45:34.900 --> 01:45:36.900]  шаблона, есть множство параметров для второго шаблона.
[01:45:36.900 --> 01:45:38.900]  И если
[01:45:38.900 --> 01:45:40.900]  множество этих параметров включено
[01:45:40.900 --> 01:45:42.900]  в множество параметров второго шаблона,вот эта
[01:45:42.900 --> 01:45:44.900]  штука считается более точной специализацией, чем вторая.
[01:45:44.900 --> 01:45:46.900]  Да?
[01:45:46.900 --> 01:45:48.900]  А здесь нельзя сказать, что
[01:45:48.900 --> 01:45:56.900]  Набор параметров tint вложен в множество параметров float t.
[01:45:56.900 --> 01:46:00.900]  Ну и наоборот, тоже неверно.
[01:46:00.900 --> 01:46:06.900]  В смысле вот эту специализацию?
[01:46:06.900 --> 01:46:15.900]  Да, в этом случае вам достучаться ни до какой специализации невозможно.
[01:46:15.900 --> 01:46:19.900]  К сожалению. Что?
[01:46:19.900 --> 01:46:34.900]  А если вы вызовете sint float, то будут первые шаблоны, потому что ни второй ни треть не подходят.
[01:46:34.900 --> 01:46:38.900]  Окей, да, вот это не работает.
[01:46:38.900 --> 01:46:41.900]  Ну и поговорим коротко про частичную специализацию шаблонов функций.
[01:46:41.900 --> 01:46:45.900]  Частичной специализации шаблонов функций не существует.
[01:46:45.900 --> 01:46:49.900]  Поэтому про частичную специализацию мы говорим сегодня, а не на прошлой лекции.
[01:46:49.900 --> 01:46:53.900]  Шаблоны функций можно специализировать только полностью.
[01:46:53.900 --> 01:46:59.900]  Частично нельзя.
[01:46:59.900 --> 01:47:05.900]  Еще поговорим про шаблоны.
[01:47:05.900 --> 01:47:08.900]  Шаблонный параметр шаблонов.
[01:47:08.900 --> 01:47:10.900]  Что мы знаем про шаблонные параметры?
[01:47:10.900 --> 01:47:12.900]  На самом деле мы знаем две вещи.
[01:47:12.900 --> 01:47:18.900]  Первая, мы знаем, что в качестве шаблонных параметров может выступать какой-то тип.
[01:47:18.900 --> 01:47:24.900]  Мы можем параметризовать наши шаблонные классы или шаблонные функции каким-то типом.
[01:47:24.900 --> 01:47:30.900]  Ну, например, sint, sdouble.
[01:47:30.900 --> 01:47:35.900]  Ну и в прошлый раз мы говорили, что там можно писать также целые числа.
[01:47:35.900 --> 01:47:39.900]  Ну, если мы тут в качестве template указали, например, int x.
[01:47:43.900 --> 01:47:45.900]  Что еще?
[01:47:45.900 --> 01:47:51.900]  Еще в качестве шаблонных параметров могут выступать внезапно другие шаблоны.
[01:47:51.900 --> 01:47:55.900]  Той есть.
[01:47:55.900 --> 01:48:02.900]  Я пишу класс stack шаблонный, который параметризован типом t.
[01:48:02.900 --> 01:48:06.900]  Ну смотрите, класс stack может быть реализован как минимум двумя способами.
[01:48:06.900 --> 01:48:10.900]  Первый с помощью связанного списка, а второй способ с помощью массива.
[01:48:10.900 --> 01:48:16.900]  Ну и мне как-то лень, ну скажем, если я написал реализацию stack на массиве,
[01:48:16.900 --> 01:48:19.900]  мне как-то лень ее перебисывать на реализацию на списке.
[01:48:19.900 --> 01:48:21.900]  Я хочу, чтобы это все происходило как-то автоматически.
[01:48:21.900 --> 01:48:24.900]  И вот чтобы это работало, я делаю следующий трюк.
[01:48:24.900 --> 01:48:28.900]  Я говорю, что stack у меня параметризован двумя шаблонными параметрами.
[01:48:28.900 --> 01:48:30.900]  Первый параметр — это тип.
[01:48:30.900 --> 01:48:32.900]  То есть тип, который хранится внутри stack.
[01:48:32.900 --> 01:48:36.900]  А второй параметр — это шаблон.
[01:48:36.900 --> 01:48:40.900]  То есть шаблонный параметр шаблона пишется следующим образом.
[01:48:40.900 --> 01:48:42.900]  Ну пишется, во-первых, template.
[01:48:42.900 --> 01:48:46.900]  Дальше пишется, собственно, параметр шаблона шаблона.
[01:48:46.900 --> 01:48:54.900]  Ну собственно, вот тот шаблонный класс, который я буду всегда подставлять,
[01:48:54.900 --> 01:48:56.900]  сколько параметров он имеет.
[01:48:56.900 --> 01:48:58.900]  Окей?
[01:48:58.900 --> 01:49:00.900]  Вот здесь давайте посмотрим, например.
[01:49:00.900 --> 01:49:04.900]  Я хочу, например, в качестве второго аргумента, я хочу передать array.
[01:49:04.900 --> 01:49:06.900]  Сколько шаблонных параметров имеет array?
[01:49:10.900 --> 01:49:12.900]  Ну один, вот он.
[01:49:12.900 --> 01:49:16.900]  Поэтому здесь я указываю один шаблонный параметр.
[01:49:18.900 --> 01:49:22.900]  Если было два, то я должен был написать следующую вещь.
[01:49:22.900 --> 01:49:28.900]  template.class.class
[01:49:28.900 --> 01:49:36.900]  И дальше там class.container.
[01:49:36.900 --> 01:49:44.900]  Все, то есть я объявляю, что следующий шаблонный параметр у меня сам по себе является шаблоном,
[01:49:44.900 --> 01:49:46.900]  который принимает один тип.
[01:49:46.900 --> 01:49:48.900]  И дальше пишу, собственно, как-то его называю.
[01:49:48.900 --> 01:49:50.900]  class.container.
[01:49:50.900 --> 01:49:52.900]  То есть, грубо говоря, для stack что я говорю?
[01:49:52.900 --> 01:50:00.900]  Я говорю, что stack содержит элементы типа T и реализован с помощью контейнера.
[01:50:00.900 --> 01:50:02.900]  Да, контейнер.
[01:50:02.900 --> 01:50:04.900]  Контейнер имеет следующий вид.
[01:50:04.900 --> 01:50:08.900]  Контейнер является шаблоном, который принимает один аргумент.
[01:50:10.900 --> 01:50:14.900]  Контейнер является шаблоном template, который принимает один аргумент.
[01:50:14.900 --> 01:50:16.900]  Вот он в треугольной скобке указан, класс.
[01:50:16.900 --> 01:50:24.900]  Нет, в том-то и дело, что нет.
[01:50:24.900 --> 01:50:28.900]  Array сам по себе, само имя array, это и есть шаблон.
[01:50:28.900 --> 01:50:30.900]  Да, вот это важный момент.
[01:50:30.900 --> 01:50:40.900]  Смотрите, если бы я сделал вот таким образом stack int и скажем array от int,
[01:50:40.900 --> 01:50:42.900]  вот это бы не скомпилировалось.
[01:50:42.900 --> 01:50:43.900]  Почему?
[01:50:43.900 --> 01:50:46.900]  Потому что array от int – это не шаблон.
[01:50:46.900 --> 01:50:48.900]  Array от int – это уже конкретный тип.
[01:50:48.900 --> 01:50:59.900]  Чтобы работало так, мне нужно было здесь в качестве параметра указать как обычно class.container.
[01:51:03.900 --> 01:51:05.900]  Чем мне не нравится этот подход?
[01:51:05.900 --> 01:51:07.900]  Кстати, этот подход реализован в стандартной библиотеке.
[01:51:07.900 --> 01:51:11.900]  В стандартной библиотеке есть stack, который можно параметризовать типом
[01:51:11.900 --> 01:51:14.900]  и стандартной библиотеке, который можно параметризовать контейнером.
[01:51:14.900 --> 01:51:16.900]  Но об этом мы говорим ближе к концу курса.
[01:51:16.900 --> 01:51:18.900]  То есть там реализовано вот так.
[01:51:18.900 --> 01:51:19.900]  Но это на самом деле неудобно.
[01:51:19.900 --> 01:51:20.900]  Почему?
[01:51:20.900 --> 01:51:23.900]  Потому что вам нужно как минимум два раза указать тип.
[01:51:23.900 --> 01:51:25.900]  И здесь, и здесь.
[01:51:25.900 --> 01:51:31.900]  Но чтобы так не делать, я предлагаю ввести шаблоны параметром шаблона.
[01:51:31.900 --> 01:51:34.900]  То есть сказать, что stack у меня параметризован int типом хранимых элементов
[01:51:34.900 --> 01:51:37.900]  и плюс другой шаблон – array.
[01:51:37.900 --> 01:51:39.900]  И как теперь этим добром пользоваться?
[01:51:39.900 --> 01:51:40.900]  Это очень просто.
[01:51:40.900 --> 01:51:46.900]  Я просто беру и говорю, что буфер у меня является контейнером от t.
[01:51:46.900 --> 01:51:52.900]  То есть элементы хранятся в буфере, а сам буфер является контейнером от типа t.
[01:51:52.900 --> 01:51:59.900]  То есть на самом деле вот здесь вместо контейнера подставляется array от t.
[01:51:59.900 --> 01:52:01.900]  Все.
[01:52:01.900 --> 01:52:08.900]  Если я хочу использовать stack на связанном списке, я просто пишу stack int list.
[01:52:08.900 --> 01:52:10.900]  stack list.
[01:52:10.900 --> 01:52:15.900]  Ну при этом понятно, что я должен шаблонный класс list тоже как-то реализовать связанный список.
[01:52:15.900 --> 01:52:18.900]  Ну это просто пример применения.
[01:52:18.900 --> 01:52:21.900]  На самом деле шаблонные параметры шаблонов используются крайне редко.
[01:52:21.900 --> 01:52:25.900]  Это просто как бы демонстрация, что вот так можно делать, если вдруг вам нужно.
[01:52:25.900 --> 01:52:27.900]  Окей?
[01:52:27.900 --> 01:52:29.900]  Так, ну все.
[01:52:29.900 --> 01:52:33.900]  Давайте сделаем перерыв и потом продолжим.
[01:52:33.900 --> 01:52:36.900]  Вообще в прошлом году до этого момента мы не доходили.
[01:52:36.900 --> 01:52:41.900]  В этом году мы идем прям очень быстро.
[01:52:41.900 --> 01:52:44.900]  Вам как? Комфортно? Нормально? Успеваете? Все?
[01:52:44.900 --> 01:52:46.900]  Окей.
[01:52:46.900 --> 01:52:48.900]  Ну давайте чтобы...
[01:52:48.900 --> 01:52:50.900]  Что сейчас будет происходить?
[01:52:50.900 --> 01:52:55.900]  Ну чтобы наш разговор про шаблоны был более-менее полным, давайте поговорим, что еще может быть шаблонным.
[01:52:55.900 --> 01:52:57.900]  И на этом закончим.
[01:52:57.900 --> 01:53:00.900]  На самом деле тема шаблонов, она очень большая.
[01:53:00.900 --> 01:53:04.900]  То есть то, что мы с вами проговорили, это буквально вершина айсберга.
[01:53:04.900 --> 01:53:08.900]  На самом деле шаблоны это вот прям язык в языке.
[01:53:08.900 --> 01:53:12.900]  То есть на шаблонах можно сделать кучу всего, кучу всякой магии и так далее.
[01:53:12.900 --> 01:53:17.900]  Но в силу нехватку времени мы, возможно, этим займемся только ближе к концу курса или вообще нет.
[01:53:17.900 --> 01:53:23.900]  Но в качестве дополнительной литературы, если прям совсем интересный, я рекомендую книгу...
[01:53:23.900 --> 01:53:27.900]  Как называется?
[01:53:27.900 --> 01:53:29.900]  Темплотс.
[01:53:38.900 --> 01:53:44.900]  Вот так называется и автор, если я правильно напишу, то Вандервурд.
[01:53:44.900 --> 01:53:52.900]  Эту книгу стоит скачать, просмотреть хотя бы для того, чтобы ужаснуться, какого она размера.
[01:53:52.900 --> 01:53:56.900]  То есть сколько всего можно про шаблоны написать и описать.
[01:53:56.900 --> 01:54:00.900]  Но несмотря на то, что она толстая, там она устроена очень...
[01:54:00.900 --> 01:54:03.900]  То есть она мне очень нравится тем, что она устроена в двух частях.
[01:54:03.900 --> 01:54:08.900]  То есть у нее есть первая часть, буквально 10% в которой описываются все основные концепции с примерами и так далее.
[01:54:08.900 --> 01:54:14.900]  То есть грубо говоря, просто базовая часть, которую мы изучаем здесь и даже чуть больше.
[01:54:14.900 --> 01:54:19.900]  Остальная часть посвящена всей этой магии, как все устроено, как все работает и так далее.
[01:54:19.900 --> 01:54:21.900]  В общем, уже продвинутая часть.
[01:54:21.900 --> 01:54:27.900]  В качестве справки можно использовать эту книгу тоже, что касается шаблона.
[01:54:27.900 --> 01:54:29.900]  Давайте пойдем дальше.
[01:54:29.900 --> 01:54:31.900]  Что мы рассмотрели к текущему моменту?
[01:54:31.900 --> 01:54:35.900]  Мы рассмотрели шаблоны функций и рассмотрели шаблоны классов.
[01:54:35.900 --> 01:54:37.900]  Что еще может быть шаблоном?
[01:54:37.900 --> 01:54:41.900]  Шаблоны могут быть переменные, начиная с C++14.
[01:54:41.900 --> 01:54:45.900]  Какую проблему решают шаблоны переменных?
[01:54:45.900 --> 01:54:51.900]  Вообще говоря, если вам нужно какое-то значение, то есть шаблонное, которое зависит от параметра шаблона.
[01:54:51.900 --> 01:54:53.900]  Раньше C++14 использовались функцией.
[01:54:53.900 --> 01:54:59.900]  И на прошлой лекции мы тоже использовали функцию для получения какого-то значения определенного типа.
[01:54:59.900 --> 01:55:01.900]  Например, getZero.
[01:55:01.900 --> 01:55:05.900]  GetZero у нас была функция шаблонная, которая возвращала 0 определенного типа.
[01:55:05.900 --> 01:55:07.900]  GetZero от int возвращает нам int.
[01:55:07.900 --> 01:55:09.900]  GetZero от obla возвращает нам double.
[01:55:09.900 --> 01:55:15.900]  Мы написали специализацию для комплексного числа, которое возвращает комплексное число, которое является нулем.
[01:55:15.900 --> 01:55:19.900]  Согласитесь, странно использовать функцию для получения какого-то значения.
[01:55:19.900 --> 01:55:25.900]  Соответственно, в C++14 для удобства интерфейса ввели шаблонные переменные.
[01:55:25.900 --> 01:55:31.900]  Синтаксис абсолютно такой же, как и для шаблонов классов и для шаблонов функций.
[01:55:31.900 --> 01:55:37.900]  Вы пишете preamble и template класс T и дальше описываете объявление вашей переменной.
[01:55:37.900 --> 01:55:45.900]  То есть вы говорите, что ваша переменная должна иметь тип T и иметь такое значение.
[01:55:45.900 --> 01:55:51.900]  В частности, getZero это переменная, грубо говоря, шаблонная переменная, которая означает 0 для любого типа.
[01:55:51.900 --> 01:55:57.900]  Шаблоны переменных можно специализировать как частично, так и полностью.
[01:55:57.900 --> 01:56:01.900]  В частности, для комплексного числа 0 выглядит следующим образом.
[01:56:01.900 --> 01:56:05.900]  Так как комплексное число это структура, которая состоит из двух полей.
[01:56:05.900 --> 01:56:09.900]  Действительно не моя часть. Таким образом 0 нельзя определить.
[01:56:09.900 --> 01:56:15.900]  При этом я пишу специализацию для комплексного числа, которая инициализирует его двумя нулями.
[01:56:15.900 --> 01:56:19.900]  Теперь я ее переменную могу спокойно использовать в любых контекстах.
[01:56:19.900 --> 01:56:31.900]  Например, могу ее вывести, cout, k, 0, например, от флота.
[01:56:31.900 --> 01:56:37.900]  А могу присвоить ее в другие перемены, например, в x, в y и в z.
[01:56:37.900 --> 01:56:41.900]  При этом в последней строке будет использована специализация, а не общий шаблон.
[01:56:41.900 --> 01:56:47.900]  Ну и немного правил по работе шаблона переменных.
[01:56:47.900 --> 01:56:51.900]  Шаблонная переменная может быть объявлена только в глобальной области видимости
[01:56:51.900 --> 01:56:57.900]  или в области видимости пространства имен, на самом деле как и любой другой шаблон.
[01:56:57.900 --> 01:57:03.900]  Правда это или нет? Нет, не совсем правда, шаблонные функции могут быть объявлены внутри классов.
[01:57:03.900 --> 01:57:09.900]  В общем, шаблоны могут быть объявлены только в глобальной области видимости
[01:57:09.900 --> 01:57:15.900]  или в некотором пространстве MIM. Внутри функций они объявлены быть не могут,
[01:57:15.900 --> 01:57:20.900]  как и любые другие шаблоны. Шаблонная переменная, думаю, это понятно,
[01:57:20.900 --> 01:57:24.900]  должна быть сразу определена, потому что во время инстанцирования
[01:57:24.900 --> 01:57:28.900]  компилятор должен понимать, какое значение она имеет.
[01:57:28.900 --> 01:57:32.900]  Шаблоны переменных, как и любые другие шаблоны, инстанцируются лениво,
[01:57:32.900 --> 01:57:36.900]  то есть если вы не создали ни одной переменной с определенным типом,
[01:57:36.900 --> 01:57:40.900]  то этих переменных нет. Вот сейчас вот здесь k0. Вы выявили k0 от int,
[01:57:40.900 --> 01:57:44.900]  от doubly, от комплексного числа. Ну и еще от плата мы тут написали.
[01:57:44.900 --> 01:57:48.900]  То есть k0 от bool, от int указателей и так далее, их нет. То есть вот есть
[01:57:48.900 --> 01:57:53.900]  четыре вот этих переменных. Да, ну и шаблоны переменных могут быть
[01:57:53.900 --> 01:58:00.900]  полностью или частично специализированы. По сути все. Есть вопросы?
[01:58:00.900 --> 01:58:17.900]  В смысле вы хотите, грубо говоря, k0 от int указатель?
[01:58:17.900 --> 01:58:21.900]  Ну вполне возможно. То есть вы можете частично специализировать
[01:58:21.900 --> 01:58:28.900]  следующим образом. Давайте пропишем частичную специализацию для этих,
[01:58:28.900 --> 01:58:39.900]  для всех указателей. Вы пишете const t указатель k0 равно...
[01:58:39.900 --> 01:58:45.900]  Так, нет, это видимо не так пишется сейчас. Скорее всего вот так.
[01:58:45.900 --> 01:58:50.900]  Т-звездочка, вот. То есть вот тут явно указываете уточненный тип.
[01:58:50.900 --> 01:58:55.900]  И дальше равно nullptr.
[01:58:55.900 --> 01:59:01.900]  Ну давайте еще раз в время есть, скажу какое основное применение
[01:59:01.900 --> 01:59:04.900]  шаблонов переменных, ну по крайней мере в стандартной библиотеке.
[01:59:04.900 --> 01:59:10.900]  Ну вот помните, мы писали из int, структуру из int шаблонную,
[01:59:10.900 --> 01:59:13.900]  которая проверяет, является ли тип int или не является.
[01:59:13.900 --> 01:59:23.900]  Ну согласитесь, вот писать вот так, из int, int, value, это долго.
[01:59:23.900 --> 01:59:27.900]  Так вот, шаблоны переменных призваны вот это все сократить.
[01:59:27.900 --> 01:59:31.900]  В стандартной библиотеке есть, грубо говоря, если мы писали шаблоны переменных
[01:59:31.900 --> 01:59:38.900]  для этой штуки, мы написали следующим образом. Из int v от int. И все.
[01:59:38.900 --> 01:59:42.900]  То есть мы бы написали просто шаблонную переменную, и тогда нам не нужно было
[01:59:42.900 --> 01:59:46.900]  с этими, со статическими полями и так далее. То есть мы бы написали просто,
[01:59:46.900 --> 01:59:49.900]  ну давайте напишем, ладно.
[01:59:49.900 --> 02:00:02.900]  Template class t const bool из int равно false.
[02:00:02.900 --> 02:00:06.900]  Ну в общем случае переменная из int равна false.
[02:00:06.900 --> 02:00:09.900]  Теперь пишем специализацию полную.
[02:00:09.900 --> 02:00:15.900]  Template, пустые треугольные скобки, const bool.
[02:00:15.900 --> 02:00:20.900]  И дальше пишем из int специально для int.
[02:00:20.900 --> 02:00:25.900]  И тут пишем равно true.
[02:00:25.900 --> 02:00:31.900]  Все, теперь когда вы просите из int от int, это true.
[02:00:31.900 --> 02:00:36.900]  Если вы просите из int от ланга какого-нибудь, то у вас false.
[02:00:36.900 --> 02:00:40.900]  Более лаконичный синтаксис.
[02:00:40.900 --> 02:00:43.900]  Это основное применение.
[02:00:43.900 --> 02:00:48.900]  Ну и что еще может быть шаблоном?
[02:00:48.900 --> 02:00:51.900]  Шаблоны могут быть псевдонимы типов.
[02:00:51.900 --> 02:00:56.900]  Тут, кстати, можно подробно поговорить, потому что это важно.
[02:00:56.900 --> 02:01:00.900]  На самом деле, вот этими четырьмя вариантами шаблоны ограничиваются.
[02:01:00.900 --> 02:01:05.900]  Шаблоны функций, шаблоны классов, шаблоны переменных и шаблоны и псевдонимы типов.
[02:01:05.900 --> 02:01:08.900]  Это про что? Ну давайте издалека начнем.
[02:01:08.900 --> 02:01:11.900]  Про type-def, я думаю, вы знаете, да?
[02:01:11.900 --> 02:01:14.900]  С помощью type-def можно создать псевдоним типа.
[02:01:14.900 --> 02:01:18.900]  Ну скажем, писать long-long – это долго.
[02:01:18.900 --> 02:01:21.900]  Ну и на самом деле неправильно, у нас с кодстайлом запрещен long-long.
[02:01:21.900 --> 02:01:26.900]  Ну допустим, вам нужен long-long, и вам лень его постоянно писать таким длинным.
[02:01:26.900 --> 02:01:31.900]  Тогда вы можете просто-напросто взять и объявить псевдоним для long-long l-l.
[02:01:31.900 --> 02:01:34.900]  Пишете следующим образом. Вы пишете type-def.
[02:01:34.900 --> 02:01:37.900]  Дальше пишете тип, который вам нужно зап псевдонимизировать.
[02:01:37.900 --> 02:01:40.900]  И дальше пишете непосредственно имя псевдонима.
[02:01:40.900 --> 02:01:43.900]  А это пишется внутри?
[02:01:43.900 --> 02:01:46.900]  Это пишется, это может писать и внутри, это может писать везде.
[02:01:46.900 --> 02:01:50.900]  И вне мейна, и в глобальном области видимости, и внутри класса, и так далее.
[02:01:50.900 --> 02:01:53.900]  Наверное, до первого использования.
[02:01:53.900 --> 02:01:58.900]  Ну как и любая другая сущность, до первого использования она должна быть объявлена.
[02:01:58.900 --> 02:02:03.900]  Вот, тогда если вы объявите long-long x, то переменная x будет иметь тип long-long.
[02:02:03.900 --> 02:02:07.900]  Вы можете объять переменную y типа long-long, но уже с помощью псевдонима l-l.
[02:02:07.900 --> 02:02:11.900]  То есть l-l – абсолютный эквивалент long-long.
[02:02:11.900 --> 02:02:14.900]  С помощью псевдонима.
[02:02:14.900 --> 02:02:17.900]  Что?
[02:02:17.900 --> 02:02:20.900]  Ну естественно, да, потому что выбили какое-то имя.
[02:02:20.900 --> 02:02:23.900]  Это может быть использовано только для одной сущности.
[02:02:23.900 --> 02:02:26.900]  Что?
[02:02:26.900 --> 02:02:29.900]  Нет, нет, нет.
[02:02:29.900 --> 02:02:32.900]  Если вы назвали, как-то обозвали l-l чем-то, то вот.
[02:02:32.900 --> 02:02:35.900]  Короче, нельзя, нельзя.
[02:02:35.900 --> 02:02:38.900]  Ну да, у нас код style запрещается сполить long-long.
[02:02:38.900 --> 02:02:43.900]  Короче, используйте типы сфиксированного код стайла.
[02:02:43.900 --> 02:02:46.900]  Ну да, у нас код стайла запрещается сполить long-long.
[02:02:47.900 --> 02:02:50.900]  Короче, используйте типы сфиксированной точностью.
[02:02:50.900 --> 02:02:53.900]  Но это в Google код стайле даже прописано.
[02:02:53.900 --> 02:02:56.900]  То есть int32t, int64t и так далее.
[02:02:56.900 --> 02:02:59.900]  То есть если вам нужен какой-то конкретный тип конкретной ширины,
[02:02:59.900 --> 02:03:02.900]  то прописывайте, сколько bit вам нужно.
[02:03:07.900 --> 02:03:10.900]  Значит, небольшой интересный факт, про который, возможно, вы не знали,
[02:03:10.900 --> 02:03:17.900]  но type-def можно писать где угодно до имени псевдонима.
[02:03:17.900 --> 02:03:21.900]  То есть представьте себе, что я хочу затайп-дефать unsigned long-long.
[02:03:21.900 --> 02:03:26.900]  То есть unsigned long-long писать долго, я хочу, чтобы это было ull.
[02:03:26.900 --> 02:03:34.900]  Так вот, type-def можно писать не только в начале, но и здесь, и здесь, и здесь.
[02:03:34.900 --> 02:03:38.900]  То есть в любом месте до ull вы можете писать type-def.
[02:03:38.900 --> 02:03:41.900]  И это будет работать абсолютно эквивалентно.
[02:03:45.900 --> 02:03:47.900]  Ну а type-def писать в конце нельзя.
[02:03:47.900 --> 02:03:50.900]  Единственное место, где нельзя написать type-def, это в конце.
[02:03:55.900 --> 02:03:57.900]  Да-да-да.
[02:03:57.900 --> 02:04:00.900]  Во всех четырех случаях unsigned long-long.
[02:04:00.900 --> 02:04:03.900]  Так, можно потише, пожалуйста?
[02:04:03.900 --> 02:04:05.900]  Окей.
[02:04:05.900 --> 02:04:10.900]  Ну и я потихоньку подбираюсь к тому, что type-def он не очень удобный.
[02:04:10.900 --> 02:04:12.900]  Ну, во-первых, по этой причине.
[02:04:12.900 --> 02:04:15.900]  Потому что type-def может находиться вообще в произвольном месте.
[02:04:15.900 --> 02:04:20.900]  И понятно, что вряд ли вы ожидаете type-def где-то посередине между unsigned long-long.
[02:04:20.900 --> 02:04:25.900]  То есть если вы прочитали unsigned long и там, короче, есть какой-то мем в сети,
[02:04:25.900 --> 02:04:28.900]  что, типа, если у вас первая буква стоит в последнем нужном месте,
[02:04:28.900 --> 02:04:31.900]  и вы как-то буквы перемешаете, то все равно можно прочитать текст.
[02:04:31.900 --> 02:04:34.900]  Но тут то же самое. Вы как бы читаете, видите, что написана какая-то длинная хрень.
[02:04:34.900 --> 02:04:37.900]  Вначале unsigned, в конце long. Наверное, unsigned long-long.
[02:04:37.900 --> 02:04:39.900]  Type-def вы явно пропустите.
[02:04:39.900 --> 02:04:43.900]  А на самом деле там кто-то имел в виду, что это псевдоним типа, а не переменная.
[02:04:43.900 --> 02:04:46.900]  Вот это первая проблема.
[02:04:46.900 --> 02:04:49.900]  Вторая проблема с тем, как type-def работает.
[02:04:49.900 --> 02:04:56.900]  Вот смотрите, если я хочу объявить псевдоним для указателя,
[02:04:56.900 --> 02:04:58.900]  то это выглядит следующим образом.
[02:04:58.900 --> 02:05:02.900]  Вроде как терпимо. Я пишу type-def int указатель и пишу type.
[02:05:02.900 --> 02:05:08.900]  Если я хочу написать type-def для массива, то все выглядит уже немного страннее.
[02:05:08.900 --> 02:05:14.900]  Я пишу type-def int, и дальше после имени псевдонима я пишу размер массива.
[02:05:14.900 --> 02:05:19.900]  Грубо говоря, я пишу так, как если бы я объявил переменную, но просто вначале пишу type-def.
[02:05:19.900 --> 02:05:24.900]  Странно. То есть снова нужно искать, а где у меня находится имя типа.
[02:05:24.900 --> 02:05:28.900]  Дальше. Если я хочу объявить псевдоним функции, ну псевдоним типа функции,
[02:05:28.900 --> 02:05:31.900]  то снова я должен написать в функциональном стиле.
[02:05:31.900 --> 02:05:33.900]  Я должен написать, что у меня функция возвращает.
[02:05:33.900 --> 02:05:37.900]  Потом нужно написать имя псевдонима и что она принимает.
[02:05:37.900 --> 02:05:40.900]  Еще не забыть вначале type-def написать.
[02:05:40.900 --> 02:05:47.900]  Более того, type-def, то есть я могу написать несколько псевдонимов в одну строку.
[02:05:47.900 --> 02:05:53.900]  Например, вот так. type-def int, int t, int ptr t, int 10 t и так далее.
[02:05:53.900 --> 02:06:02.900]  То есть int t, нижнее подчеркнение t, это псевдоним для int.
[02:06:02.900 --> 02:06:06.900]  Понятно? Вот этот.
[02:06:06.900 --> 02:06:10.900]  Вот это, это псевдоним для указателя.
[02:06:10.900 --> 02:06:14.900]  Почему? А потому что перед ним звездочка написана. Ну, круто.
[02:06:14.900 --> 02:06:17.900]  А вот это, это псевдоним для массива интов размера 10.
[02:06:17.900 --> 02:06:22.900]  Почему? Потому что где-то там вначале написан int, а вот здесь написан в квадратных скобках и 10.
[02:06:22.900 --> 02:06:28.900]  А вот это внезапно, это псевдоним функции, которая принимает int и возвращает int.
[02:06:28.900 --> 02:06:34.900]  Класс? Конечно нет, ну вообще ерунда какая-то.
[02:06:34.900 --> 02:06:38.900]  Ну ладно.
[02:06:38.900 --> 02:06:42.900]  Ну и да, в общем важный момент. type-def не создает нового типа,
[02:06:42.900 --> 02:06:44.900]  а просто является псевдонимом для существующих.
[02:06:44.900 --> 02:06:47.900]  То есть важно понимать, что type-def не является созданием нового типа.
[02:06:47.900 --> 02:06:50.900]  То есть когда мы пишем структ или когда мы пишем класс, мы реально создаем новый тип.
[02:06:50.900 --> 02:06:53.900]  type-def нового типа не создает, он просто делает некоторый псевдоним.
[02:06:53.900 --> 02:06:56.900]  То есть грубо говоря компилятор во время припроцессинга просто все ваши type-def'ы берет,
[02:06:56.900 --> 02:07:00.900]  ну короче он просто выкидывает и везде, где вы используете псевдонимы,
[02:07:00.900 --> 02:07:05.900]  подставляет там int или что вы там хотели.
[02:07:05.900 --> 02:07:09.900]  Внутри структуры тоже можно написать type-def. Да, мы об этом сейчас поговорим.
[02:07:09.900 --> 02:07:13.900]  Ну и про что был вопрос несколько минут назад.
[02:07:13.900 --> 02:07:17.900]  type-def, то есть если вы объявили псевдоним какого-то типа,
[02:07:17.900 --> 02:07:20.900]  то он должен принадлежать только одному типу и только ему.
[02:07:20.900 --> 02:07:25.900]  То есть нельзя написать, что int-t это int и int-t это long. Вот так нельзя.
[02:07:25.900 --> 02:07:29.900]  Но при этом вы можете написать несколько type-def, которые не противоречат друг другу.
[02:07:29.900 --> 02:07:33.900]  Например первые и вторые они не противоречат друг другу, поэтому вы можете написать их подряд.
[02:07:33.900 --> 02:07:36.900]  Не знаю зачем вам это нужно, но вот вы можете.
[02:07:36.900 --> 02:07:41.900]  Вы также нельзя писать вот так. То есть вы не можете переопределять уже существующие типы.
[02:07:41.900 --> 02:07:45.900]  Вы не можете сказать, что float это теперь double.
[02:07:45.900 --> 02:07:50.900]  Ну вот хотя бы тут разумно все.
[02:07:50.900 --> 02:07:58.900]  Мы разобрались с тем, что type-def на самом деле не так хорош, как вы, возможно, о нем думали.
[02:07:58.900 --> 02:08:02.900]  type-def на самом деле плохой вариант, если вы хотите завести псевдоним типа.
[02:08:02.900 --> 02:08:06.900]  А какой вариант хороший? А хороший вариант завезли в C++11.
[02:08:06.900 --> 02:08:09.900]  Это объявление с помощью using.
[02:08:09.900 --> 02:08:14.900]  Если вы хотите объявить псевдоним какого-то типа, то вы должны писать следующее.
[02:08:14.900 --> 02:08:23.900]  using имя псевдонима равно и тот тип, который вы хотите запсевдонимить.
[02:08:23.900 --> 02:08:26.900]  Согласитесь, что этот синтактис гораздо более понятен.
[02:08:26.900 --> 02:08:33.900]  Тут гораздо более явно видно, где псевдоним, а где тип, на который ссылается псевдоним.
[02:08:33.900 --> 02:08:37.900]  Вы грубо говоря int t присваиваете int.
[02:08:37.900 --> 02:08:43.900]  Здесь вы говорите, что псевдоним для int указателя – это int ptr t.
[02:08:43.900 --> 02:08:48.900]  Псевдоним для массива – это int 10 at.
[02:08:48.900 --> 02:08:52.900]  Псевдоним для функции – это func int to int.
[02:08:52.900 --> 02:08:56.900]  Слева стоит имя псевдонима, а справа целиком пишется тип.
[02:08:56.900 --> 02:09:00.900]  Без всяких приколов типа этого.
[02:09:00.900 --> 02:09:05.900]  И что самое главное, синтактис для using задан более жестко.
[02:09:05.900 --> 02:09:08.900]  TypeDef вы можете поставить где угодно.
[02:09:08.900 --> 02:09:10.900]  Using вы можете поставить только в начале.
[02:09:10.900 --> 02:09:13.900]  И при этом только одно объявление на строку.
[02:09:13.900 --> 02:09:16.900]  На самом деле это ограничение, но это благо.
[02:09:22.900 --> 02:09:27.900]  Теперь про то, про что вы спрашивали. Можно ли TypeDef и псевдоним изводить внутри структуры?
[02:09:27.900 --> 02:09:29.900]  Там можно.
[02:09:29.900 --> 02:09:34.900]  Например, я могу внутри структуры объявить псевдоним для int.
[02:09:34.900 --> 02:09:39.900]  Я могу внутри структуры объявить псевдоним для lang.
[02:09:39.900 --> 02:09:45.900]  И вот эти псевдонимы распространяются только на саму эту структуру.
[02:09:45.900 --> 02:09:52.900]  Но что самое главное, эти типы члены теперь становятся доступны с помощью оператора разрешения области видимости.
[02:09:52.900 --> 02:09:55.900]  Вот так.
[02:09:55.900 --> 02:10:00.900]  Какое этому применение есть?
[02:10:00.900 --> 02:10:04.900]  Давайте вернемся к стэку.
[02:10:04.900 --> 02:10:07.900]  У вас есть стэк класс.
[02:10:07.900 --> 02:10:12.900]  Есть философский вопрос. В чем нужно измерять size?
[02:10:12.900 --> 02:10:15.900]  Как вы думаете, в чем нужно измерять размер стэка?
[02:10:15.900 --> 02:10:20.900]  В int, в unsigned int, в long long, unsigned long long и так далее.
[02:10:20.900 --> 02:10:24.900]  В принципе, все эти варианты более-менее разумны.
[02:10:24.900 --> 02:10:27.900]  Можно использовать что угодно.
[02:10:27.900 --> 02:10:32.900]  Но при этом пользователь не знает, когда вы пишете метод size,
[02:10:32.900 --> 02:10:36.900]  пользователь не знает, что у вас возвращает size.
[02:10:36.900 --> 02:10:40.900]  И чтобы сказать пользователю, в чем у вас измеряется size, обычно делают следующую вещь.
[02:10:40.900 --> 02:10:47.900]  Обычно пишут using size type равно ну и допустим int.
[02:10:47.900 --> 02:10:51.900]  То есть таким образом вы говорите, что у вас размер всегда измеряется в int.
[02:10:51.900 --> 02:10:55.900]  Ну и теперь пользователь всегда может понять, а в чем измеряется у вас размер стэка.
[02:10:55.900 --> 02:11:04.900]  Ну каким образом, например, он может взять и сказать stack 2.2.size type.
[02:11:04.900 --> 02:11:08.900]  И объявить свою переменную вот таким образом.
[02:11:08.900 --> 02:11:11.900]  То есть, грубо говоря, пользователь может захотеть создать переменную,
[02:11:11.900 --> 02:11:14.900]  которая имеет такой же тип, которая возвращает метод size.
[02:11:14.900 --> 02:11:17.900]  И вот таким образом он это может получить.
[02:11:22.900 --> 02:11:29.900]  Более того, на псевдонимы внутри структуры классов распространяются модификаторы доступа.
[02:11:29.900 --> 02:11:35.900]  То есть, смотрите, тут на самом деле это написано.
[02:11:35.900 --> 02:11:42.900]  Смотрите, у меня псевдоним для ланга определен в приватной области.
[02:11:42.900 --> 02:11:46.900]  И вот по этой причине последняя строка будет вызывать ошибку компиляции.
[02:11:46.900 --> 02:11:49.900]  Почему? Потому что она находится в приватной области.
[02:11:49.900 --> 02:11:54.900]  Вам запрещено получать доступ к этому псевдониму.
[02:11:54.900 --> 02:11:58.900]  То есть, что бы не было написано в приватной области, вам к этому получать доступ просто нам запрещено.
[02:11:58.900 --> 02:12:01.900]  И псевдонимов это тоже касается.
[02:12:08.900 --> 02:12:13.900]  Ну и на самом деле самое главное преимущество использования псевдонимов в стиле using,
[02:12:13.900 --> 02:12:18.900]  то есть не в стиле typedef, а в стиле using, заключается в том, что псевдонимы могут быть шаблонные.
[02:12:18.900 --> 02:12:23.900]  Что это значит? Ну, смотрите, вот у меня есть шаблонный класс.
[02:12:24.900 --> 02:12:28.900]  И я могу создать альтернативное имя для стека.
[02:12:28.900 --> 02:12:31.900]  Ну, например, вот так.
[02:12:34.900 --> 02:12:39.900]  То есть я пишу template класс T, и дальше пишу using.
[02:12:39.900 --> 02:12:44.900]  Using stack alias равно stack T.
[02:12:44.900 --> 02:12:49.900]  Это означает, что я сделал псевдоним шаблона для шаблона stack.
[02:12:49.900 --> 02:12:53.900]  Теперь я могу создать stack либо обычным образом, то есть stack от nta,
[02:12:53.900 --> 02:12:59.900]  а могу создать stack с помощью его псевдонима stack alias и дальше в треугольных скобках int.
[02:12:59.900 --> 02:13:03.900]  То есть вот эти два объявления, они абсолютно эквивалентны.
[02:13:09.900 --> 02:13:13.900]  То есть я просто завел альтернативное имя для шаблона.
[02:13:14.900 --> 02:13:18.900]  Ну, опять же, ключевой вопрос, а зачем это надо?
[02:13:18.900 --> 02:13:21.900]  Зачем мне, например, stack переименовывать?
[02:13:21.900 --> 02:13:23.900]  Stack переименовывать, наверное, не имеет смысла.
[02:13:23.900 --> 02:13:25.900]  Но это бывает полезно для каких-то длинных типов.
[02:13:25.900 --> 02:13:27.900]  Ну, вот смотрите, самый классический пример.
[02:13:27.900 --> 02:13:36.900]  Вот представьте, что вам нужен тройной stack, который содержит stack, который содержит stack, который содержит int.
[02:13:36.900 --> 02:13:39.900]  Ну, для stack опять же это не имеет смысла.
[02:13:39.900 --> 02:13:44.900]  Например, вы хотите трехмерный массив.
[02:13:44.900 --> 02:13:46.900]  Ну что такое трехмерный массив?
[02:13:46.900 --> 02:13:48.900]  Это массив, который содержит массивы, который содержит массивы.
[02:13:48.900 --> 02:13:52.900]  Вот чтобы написать такой тип, вам нужно написать вот такую длинную штуку.
[02:13:52.900 --> 02:13:56.900]  stack от stack'a от stack'a от t.
[02:13:56.900 --> 02:13:57.900]  Вы можете поступить хитрее.
[02:13:57.900 --> 02:14:00.900]  Вы можете создать псевдоним, создать stack3d,
[02:14:00.900 --> 02:14:06.900]  и сказать, что stack 3D – это то же самое, что stack от stack'a от stack'a, и от типа t.
[02:14:06.900 --> 02:14:12.180]  типа T. И теперь, чтобы создать вот этот трехмерный stack, вам достаточно просто
[02:14:12.180 --> 02:14:16.940]  использовать этот псевдоним stack3d от int. И вот вместо stack3d будет
[02:14:16.940 --> 02:14:20.500]  подставлен вот этот вот stack, stack, stack, и внутри вместо T поставится int, который
[02:14:20.500 --> 02:14:25.540]  подставлен там. Понятно?
[02:14:26.140 --> 02:14:30.100]  То есть шаблоны псевдонима здесь в следующем образом. Вы пишете, вот, какой
[02:14:30.100 --> 02:14:36.180]  тип, чем вы параметризуете stack, точнее, чем вы параметризуете ваш псевдоним. И
[02:14:36.180 --> 02:14:40.500]  дальше в правой части пишете, что нужно подставить вместо этого псевдонима, когда
[02:14:40.500 --> 02:14:44.340]  будет подставлен конкретный T. В данном случае, я говорю, что у меня stack3d это
[02:14:44.340 --> 02:14:48.740]  шаблонная штука, и когда я вместо, и когда я внутрь нее подставляю конкретный
[02:14:48.740 --> 02:14:56.060]  тип T, это должно раскрываться вот в такое объявление, окей?
[02:14:57.060 --> 02:15:00.060]  Ну вот.
[02:15:02.500 --> 02:15:06.380]  Да, ну и, собственно, как я сказал, важное отличие using вот type-def
[02:15:06.380 --> 02:15:10.180]  стоит в том, что using позволяет вам писать шаблонные псевдонимы, а type-def
[02:15:10.180 --> 02:15:13.820]  не поддерживает такого синтаксис. То есть с помощью type-def шаблонные псевдонимы
[02:15:13.820 --> 02:15:20.740]  вы никогда не создадите. Ну, по крайней мере, ну, никогда, ну, пока. Пока в стандарте такого нет.
[02:15:21.740 --> 02:15:27.860]  Окей? Ну и последний момент. Шаблоны псевдонимов нельзя полностью или частично
[02:15:27.860 --> 02:15:39.140]  специализировать. Ну, просто нельзя. На этом все. Вопросы?
[02:15:39.140 --> 02:15:53.420]  Это, это выход, да. То есть можно создать класс, написать в нем полную или частичную
[02:15:53.420 --> 02:15:58.740]  специализацию, а потом создать псевдоним на этот класс. Да, это выход. Ну, собственно,
[02:15:58.740 --> 02:16:03.100]  это одна из причин, почему так не делают. Почему шаблоны псевдонимов не поддерживают
[02:16:03.100 --> 02:16:10.300]  такую штуку. Еще вопросы? Тогда спасибо. До встречи на следующей неделе.
