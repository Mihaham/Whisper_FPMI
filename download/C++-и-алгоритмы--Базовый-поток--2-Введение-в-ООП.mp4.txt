[00:00.000 --> 00:13.400]  Я начну. Первое, с чего хотелось бы начать это объявление. Все видели, что сегодня вам
[00:13.400 --> 00:24.640]  стало доступно первое домашнее задание. Я повторяю, оно стало доступно. Домашнее задание
[00:24.640 --> 00:30.400]  состоит из двух контестов. Первый контест — это примерно такой же контест, к которому вы привыкли,
[00:30.400 --> 00:38.240]  то есть вы отправляете файлик с кодом, с решением, и в общем, ваше решение проверяется на закрытых
[00:38.240 --> 00:44.320]  тестах. Вторая часть — это задачи, так называемые задачи из GitLab или задачи с юнит-тестированием.
[00:44.320 --> 00:49.240]  В этих задачах вам нужно писать некоторый класс. Что такое класс и как их писать, мы поговорим
[00:49.240 --> 00:56.720]  сегодня. Вы пишете некоторые классы, и дальше его функциональность проверяется на публичных тестах.
[00:56.720 --> 01:05.720]  Все публичные тесты можно найти непосредственно в GitLab. У нас есть GitLab, на котором есть условия
[01:05.720 --> 01:10.600]  всех задач, на которых есть некоторые заготовки решений при необходимости, и также есть открытые
[01:10.600 --> 01:15.840]  тесты. У большинства задач тесты все открытые, поэтому, в общем-то, я думаю, что нет причин как-то
[01:15.840 --> 01:23.240]  посылать все в контест и получать неправильные ответы. Весь тот код, на котором будет тестироваться
[01:23.240 --> 01:27.760]  ваше решение, он доступен. Ну и за исключением буквально пара задач, на которых тесты тоже будут
[01:27.760 --> 01:32.860]  закрыты. Ну и вообще, в нашем курсе большинство задач будут с публичными тестами. Вот так у нас
[01:32.860 --> 01:42.120]  принято. На семинарах все успели познакомиться со способом задачи в Яндекс.контест? Все сдавали
[01:42.120 --> 02:05.400]  задачи на семинарах? Нет? Кто нет? Как так? Первые две недели. Молодец. В общем, смотрите,
[02:05.400 --> 02:10.280]  вся процедура того, как устроено тестирование, как будут тестироваться ваши решения и так далее,
[02:10.280 --> 02:14.440]  они, в принципе, на GitLab описаны. То есть, весь процесс того, как будет происходить решение,
[02:14.440 --> 02:20.960]  то есть, от проверки стиля до запуска тестов, там все указано. Поэтому, если вы все настроите у
[02:20.960 --> 02:25.280]  себя на локальных компьютерах, то, в принципе, весь тот pipeline, который будет проходить ваше
[02:25.280 --> 02:29.880]  решение, вы, собственно, сделаете. Понятное дело, что вы можете этому ничего не следовать,
[02:29.880 --> 02:33.160]  просто посылать в контест, получать ваши ошибки, ошибки компириации и так далее. Но,
[02:33.160 --> 02:37.160]  если это будет много, то в какой-то момент мы просто сделаем ограничение числового попыток. Поэтому,
[02:37.160 --> 02:43.320]  в общем, локально все тестируете, тем более все открыто и доступно. Если в процессе возникнут
[02:43.320 --> 02:48.120]  какие-то сложности с отправкой, непонятно, как все посылать, непонятно, как формировать файл,
[02:48.120 --> 02:50.760]  который нужно отсылать, непонятно, как тестировать локально и так далее, в общем,
[02:50.760 --> 02:56.440]  вы пишите там либо мне, либо Роману, ассистенту курса, либо вашим семинаристам. В крайнем случае,
[02:56.440 --> 03:00.360]  если будут какие-то прям нерешаемые проблемы, мы можем устроить дополнительный семинар по тому,
[03:00.360 --> 03:05.040]  как, собственно, сдавать задачи. Поэтому, если у вас есть какой-то дискомфорт, вы об этом пишите.
[03:05.280 --> 03:10.040]  Мы постарались сделать максимально удобную систему, особенно по сравнению с прошлым годом и так далее.
[03:10.040 --> 03:17.600]  Да, ну и дедлайн по первому заданию три недели, то есть до 3 марта можно задавать задания. Ну и,
[03:17.600 --> 03:22.480]  в принципе, у нас так будут устроены задания, что каждые 3-4 недели мы будем выдавать вам новое
[03:22.480 --> 03:31.200]  задание на тоже 3-4 недели. Всего будет 4 домашних задания. Вопросы есть? Отлично, тогда давайте
[03:31.200 --> 03:41.560]  начнем. Ну и, наконец, приступим к теме, главной теме этого семестра. Объектно-ориентированную
[03:41.560 --> 03:48.200]  программированию. Напомню, все лекции в PDF доступны, можете параллельно следить. Итак,
[03:48.200 --> 03:52.560]  с чего начнем? Давайте начнем с того, что определимся с тем, что такое парадигма
[03:52.560 --> 03:58.440]  программирования. Значит, смотрите, вообще есть несколько подходов к программированию. То есть,
[03:58.440 --> 04:02.720]  когда у вас есть некоторая задача, то есть вам поставлена задача написать какую-то функцию,
[04:02.720 --> 04:07.120]  реализовать какой-то алгоритм. Вы можете решать эту задачу несколькими способами. Можете решать,
[04:07.120 --> 04:11.560]  как условно первокурсник, который только пришел на первый семинар и пишет программу в мейне. То
[04:11.560 --> 04:15.240]  есть у вас есть задача, вы написали все в мейне, считали все с консоли, вывели все в консоль,
[04:15.240 --> 04:20.600]  послали в контест, ок, все замечательно. Есть более продвинутый уровень, который вы изучали в
[04:20.600 --> 04:24.520]  прошлом семестре, это все-таки разбивать код на функции. Зачем вообще нужно разбивать код на
[04:24.520 --> 04:29.920]  функции? Смотрите, есть первый студент, который пишет все в мейне и отсылает, у него все работает.
[04:29.920 --> 04:34.040]  Есть второй студент, который все разбивает на функции и посылает, у него тоже все работает.
[04:34.040 --> 04:43.480]  В чем разница этих двух подходов? Зачем декомпозировать вообще на функции? В чем смысл?
[04:43.480 --> 04:52.600]  Так, отлично, хорошо. Ну ок, если там что-то, если какой-то кусок кода изменился, то можно все
[04:52.600 --> 04:56.080]  изменить в функции и весь остальной код будет работать. Но в мейне как будто бы тоже можно
[04:56.080 --> 05:06.360]  что-то изменить и все будет работать. Читаемость. А что с читаемостью? Ну в некотором смысле да. Ну в
[05:06.360 --> 05:11.640]  общем, все это верно. Ну действительно, смотрите, что такое парадигмопрограммирование? В самом коротком
[05:11.640 --> 05:15.200]  варианте парадигмопрограммирование просто способ написания программ. Способ мышления, способ того,
[05:15.200 --> 05:19.040]  как вы строите архитектуру вашей программы. Действительно, разбивание на функции помогает
[05:19.040 --> 05:23.040]  улучшить читаемость кода, ну потому что вы по сути мейн можете описать в виде каких-то некоторых
[05:23.040 --> 05:28.160]  законченных инструкций. Например, считать вот, отсортировать, вывести на экран. Вот, если весь
[05:28.160 --> 05:32.520]  код считывания, сортировки, вывод на экран вы пишете в мейне, то в общем-то сложно разобраться,
[05:32.520 --> 05:36.800]  а что к чему относится. Тем более, если у вас программа очень большая. Вот. И действительно плюс
[05:36.800 --> 05:40.040]  гибкость. Если вам нужно изменить какой-то кусок кода, то есть вам нужно изменить, например,
[05:40.040 --> 05:44.800]  алгоритм сортировки, то вам необходимо просто залезть в функцию, которая собственно эту
[05:44.800 --> 05:50.760]  сортировку выполняет и изменить там необходимый код, необходимую строку и так далее. Вот. А если вы
[05:50.760 --> 05:54.520]  пишете все в мейне, то есть, грубо говоря, в императивном подходе, то у вас получается так,
[05:54.520 --> 05:58.200]  что вы допустим, вы функцию сортировки вызываете несколько раз. То есть, вам нужно отсортировать
[05:58.200 --> 06:01.680]  несколько массивов. Но тогда вам нужно просто в нескольких местах, то есть, найти все местах,
[06:01.680 --> 06:05.680]  где вы осуществляете сортировку и везде эту строку поменять. Согласитесь, это бред. Ну то есть,
[06:05.680 --> 06:10.280]  зачем следить за кодом, все читать и как бы исправлять везде, если можно завести одну функцию,
[06:10.280 --> 06:14.920]  в которой исправить какую-то ошибку и так далее. И тогда это исправление потянется во все остальные
[06:14.920 --> 06:23.160]  сущности, в которых вы эту сортировку используете. Да? Согласны? Вот. Ну и соответственно у нас есть
[06:23.160 --> 06:27.080]  три основные парадигмы программирования. Первая парадигма — это императивное
[06:27.080 --> 06:31.360]  программирование. То есть, это, грубо говоря, программирование путем просто программирования
[06:31.360 --> 06:36.160]  некоторых команд. То есть, вы просто пишете вашу программу как последовательность различных
[06:36.200 --> 06:41.240]  инструкций. Ну, различные языки поддерживают императивное программирование. И так далее.
[06:41.240 --> 06:46.560]  Вот. Дальше программирование, которое вы изучали в прошлом семестве, это было структурное
[06:46.560 --> 06:49.440]  программирование, то есть, программирование с использованием некоторых независимых,
[06:50.620 --> 06:54.360]  логически независимых кусков, то есть, функций. То есть, вы разбиваете вашу программу на функции,
[06:54.920 --> 07:00.160]  некоторые законченные действия, скажем, отсортировать то есть, найти с помощью бинарного поиска, сделать
[07:00.160 --> 07:04.400]  что-то еще, вывести, считать и так далее. И дальше вы, собственно, собираете вашу программу из вот этих
[07:04.400 --> 07:10.120]  вот самых логически независимых кусков, да. В этом смеси будем изучать другой подход,
[07:10.120 --> 07:13.960]  который называется объектно-ориентированным программированием. Смотрите, в чем отличие,
[07:13.960 --> 07:17.520]  ну так на пальцы, в чем отличие объектно-ориентированного подхода от структурного подхода.
[07:17.520 --> 07:21.640]  Когда вы программируете с помощью функций, вы, грубо говоря, программируете действия.
[07:21.640 --> 07:26.840]  То есть, грубо говоря, если вам нужно, не знаю, давайте опишем какое-то действие. Ну, например,
[07:26.840 --> 07:34.280]  ручка лежит на столе. Если вы хотите запрограммировать действие, чтобы ручка лежала
[07:34.280 --> 07:41.080]  на столе, вы пишете «лежать, ручка стол». То есть, есть действие «лежать», которое выполняется над
[07:41.080 --> 07:46.080]  ручкой столом. Но согласитесь, что в повседневной жизни мы рассуждаем не так. Когда мы строим
[07:46.080 --> 07:50.560]  предложения, у нас есть всегда некоторый актор, то есть, некоторый объект, который совершает действие,
[07:50.560 --> 07:57.280]  и есть некоторый объект, над которым он совершает действие. То есть, ручка, что делает, лежит на столе.
[07:57.280 --> 08:04.400]  Если вы программируете какую-то игру, вам очень удобно рассуждать в терминах каких-то абстрактных
[08:04.400 --> 08:10.080]  сущностей. Например, персонаж. Персонаж должен пойти из одной деревни в другую деревню, персонаж
[08:10.080 --> 08:14.300]  должен там что-то сделать и так далее. То есть, есть персонаж, который совершает некоторый набор действий.
[08:14.300 --> 08:23.000]  То есть, вы, например, сидите на лекции. Есть актор, то есть, абсубъект, который совершает действие,
[08:23.000 --> 08:28.720]  вы сидите на лекции. То есть вас никто не сидит на лекции. То есть я вас не стижу на лекции, я не заставляю вас переходить на лекции.
[08:28.720 --> 08:37.960]  Так? Так? Все, отлично. Вот. Ну и основные принципы, на которых строится объектно-ориентируемое
[08:37.960 --> 08:43.640]  программирование, это абстракция, инкапсуляция, полиморфизм и наследование. В общем-то, абстракция
[08:43.640 --> 08:48.280]  это про что? Абстракция это про то, что мы выделяем некоторые объекты из реального мира, то есть
[08:48.280 --> 08:52.680]  выделяем некоторые сущности или концепты и оформляем их в виде некоторого, ну, условного
[08:52.680 --> 08:56.160]  структура или классов, про которые мы сейчас поговорим. То есть мы вычленяем некоторые
[08:56.160 --> 09:00.960]  объекты из реального мира и программируем их в виде некоторых сущностей. При этом оставляют
[09:00.960 --> 09:05.040]  только значимые для нас характеристики. Ну, например, если вы хотите запрограммировать
[09:05.040 --> 09:10.480]  студента, то, наверное, не стоит программировать весь его код ДНК, весь его полвозраст, его
[09:10.480 --> 09:14.080]  родословную и так далее. То есть если вы программируете студента для какой-то базы данных, вам достаточно знать,
[09:14.080 --> 09:19.480]  на каком курсе он учится и какие предметы изучает. В общем-то, мы выделили основные сущности и используем
[09:19.960 --> 09:25.240]  этот объект. Дальше, инкапсуляция. Инкапсуляция — это про то, что на самом деле объекты обладают не
[09:25.240 --> 09:28.700]  только некоторыми свойствами или характеристиками. Вот давайте вернемся, скажем, в прошлость
[09:28.700 --> 09:32.440]  месяца, когда вы программируете структуру. Вот когда вы программируете структуру, вы, на самом
[09:32.440 --> 09:36.320]  деле объединяли между собой только данные. То есть, грубо говоря, у вас была у структуры, не знаю,
[09:36.320 --> 09:40.680]  что вы писали, стэк писали на связанном списке. Вот, значит, стэк что объединяет? Он связанный
[09:40.680 --> 09:45.880]  список. Точнее, узел связанного списка. Это некоторые данные, например, целое число, и плюс
[09:45.880 --> 09:49.120]  указатель на следующий узел. То есть мы объединили данные. Но при этом мы
[09:49.120 --> 09:52.560]  понимаем, что, например, stack — это не только как бы вот некоторая связка данных,
[09:52.560 --> 09:56.380]  ну и плюс действия, на которые можно с ними совершать. То есть объект обладает
[09:56.380 --> 09:59.480]  не только какими-то атрибутами или характеристиками, но и плюс может совершать
[09:59.480 --> 10:02.200]  какие-то действия. То есть мы конкретному объекту приписываем
[10:02.200 --> 10:06.080]  конкретные действия. Вот это про инкапсуляцию.
[10:06.080 --> 10:10.780]  Полиморфизм. Ну полиморфизм — это, если совсем коротко, то это один интерфейс
[10:10.780 --> 10:14.380]  много реализаций. Ну с полиморфизмом мы на самом деле уже знакомы, были знакомы
[10:14.380 --> 10:17.860]  еще в прошлом семестре, когда вы изучали, скажем, перегрузку функций. То есть
[10:17.860 --> 10:20.340]  перегрузка функций — это как раз с помощью одного интерфейса вы можете вызывать
[10:20.340 --> 10:24.340]  несколько реализаций. Ну, например, у вас есть функция с одним именем, но при этом
[10:24.340 --> 10:26.740]  можете принимать различное число аргументов. То есть вы по одному именю
[10:26.740 --> 10:30.940]  можете вызывать различные функции. Ну или шаблоны. Это тоже яркий пример полиморфизма.
[10:30.940 --> 10:34.660]  То есть вы используете общий интерфейс, и при этом вам не важно, как это все
[10:34.660 --> 10:37.900]  внутри реализовано. Самое главное, что это работает так, как вы ожидаете.
[10:37.900 --> 10:42.620]  Ну и наконец наследование. Ну про наследование мы подробно поговорим на
[10:42.620 --> 10:46.380]  отдельной лекции. То есть можно пока записать просто такое определение. Это просто
[10:46.380 --> 10:49.380]  некоторая свойство, которая позволяет создавать новые типы на основе уже
[10:49.380 --> 10:53.180]  созданных. То есть если вы знаете, то есть если у вас уже создан какой-то тип,
[10:53.180 --> 10:57.380]  который вы написали, вот, и вам хочется написать другой тип, который по свойствам
[10:57.380 --> 11:00.660]  очень близок к этому, то чтобы избирать там дублирование кода или как-то указать
[11:00.660 --> 11:03.500]  родственность этих двух типов, вы можете один наследовать от другого.
[11:03.500 --> 11:10.460]  Но об этом поговорим чуть позже. Вот. Ну и давайте поговорим про то, что такое
[11:10.460 --> 11:13.620]  класс. Класс – это тоже основная концепция объектно-ориентированного
[11:13.620 --> 11:16.580]  программирования. Значит, класс – это описание некоторого концепта из предметной
[11:16.580 --> 11:19.940]  области в виде набора полей и методов для работы с ними. Ну, грубо говоря, класс – это
[11:19.940 --> 11:23.780]  описание нового типа. То есть когда вы программируете, когда вы пишете код, вы
[11:23.780 --> 11:27.780]  хотите ввести в код какой-то новый тип. Вот. И описать какие действия над ним
[11:27.780 --> 11:30.780]  можно совершать, какие у него есть характеристики, атрибуты и так далее.
[11:30.780 --> 11:35.140]  Ну вот самый, например, давайте рассмотрим тот же самый пример со стеком. То есть
[11:35.140 --> 11:39.780]  здесь мы ввели на самом деле два класса. Первый класс – нод, то есть узел. Узел
[11:39.780 --> 11:43.100]  имеет две характеристики. Значение, которое он хранит, и указатель на следующий
[11:43.100 --> 11:49.020]  узел. И также мы ввели новый тип, стек, в виде структуры. Что мы здесь делали? Мы
[11:49.020 --> 11:53.100]  сказали, что стек состоит из указателя на вершину стека, то есть на самый верхний
[11:53.100 --> 11:59.180]  узел. И плюс, внимание, мы задали действие, которое можно совершать над стеком. Ну, я так
[11:59.180 --> 12:01.980]  понимаю, в прошлый раз вы не обсуждали, что внутри структуры можно писать какие-то
[12:01.980 --> 12:05.340]  функции. Так вот, я говорю, что на самом деле внутри структуры можно писать
[12:05.340 --> 12:08.420]  функции, которые описывают, ну, собственно, действия, которые можно ним совершать.
[12:08.420 --> 12:14.540]  Но, в частности, я говорю, что в стек можно добавить элемент pushIntValue. Из стека можно
[12:14.540 --> 12:20.180]  удалять элемент с помощью метода pop. Из стека можно взять верхний элемент с помощью метода
[12:20.180 --> 12:25.020]  top. Из стека можно очистить с помощью метода clear. И вот эти вот методы, на самом деле на
[12:25.020 --> 12:29.380]  ровне с полями структуры классов, можно вызывать с помощью точки. То есть, скажем,
[12:29.380 --> 12:36.900]  если у вас есть стек, то вы можете через точку вызвать top. Что это будет означать?
[12:36.900 --> 12:42.380]  Это будет означать, что у данного стека нужно взять вершину. Или если вы напишете
[12:42.380 --> 12:50.540]  stack.push единица, то это значит, что в данный стек нужно вставить единицу. То есть, вот ровно
[12:50.540 --> 12:54.660]  про то, что я говорил. То есть, у нас есть некоторый объект, и мы над этим объектом
[12:54.660 --> 12:59.900]  можем совершать конкретные действия. Мы говорим, стек запушь в себя единицу. Понятно?
[12:59.900 --> 13:07.780]  Ну и здесь, да, собственно, тот пример, который я сказал. Ну и еще одно определение. Объект
[13:07.780 --> 13:12.460]  — это экземпляр класса. То есть, грубо говоря, если класс — это тип, то объект — это, ну,
[13:12.460 --> 13:16.740]  собственно, экземпляр типа. То есть, переменная, которую вы создаете с данным типом. То есть,
[13:16.740 --> 13:24.900]  есть класс и есть объект. Так, надо следить за памятью. Еще что?
[13:24.900 --> 13:34.420]  Вот, давайте сейчас скажу. Действительно, у нас, смотрите, стек, он по сути разделен. То есть,
[13:34.420 --> 13:37.780]  у вас есть отдельная переменная, которая хранит буфер, и отдельная переменная хранит size. Чем
[13:37.780 --> 13:41.980]  это плохо? Ну, это плохо тем, что вам необходимо контролировать, какие две переменные связаны
[13:41.980 --> 13:46.860]  между собой. То есть, вам нужно следить за тем, что в push всегда приходил буфер и size от одного и
[13:46.860 --> 13:51.060]  того же стека. То есть, ничто вас не защитит от того, что вы подсунете ему size от совершенно
[13:51.060 --> 13:55.060]  другого стека или вообще подсунете ему совершенно другую перемену, которая с size не имеет
[13:55.060 --> 14:21.180]  никакого отношения. Еще. Ну, это правда, да, но это тоже алгоритмическая проблема. То есть,
[14:21.180 --> 14:26.220]  на чем стек реализовывать на списке или на массиве, это алгоритмическая часть. Меня больше интересует
[14:26.220 --> 14:32.020]  архитектурная. Ну, действительно. То есть, нужно постоянно таскать за собой указатель. Нужно
[14:32.020 --> 14:35.460]  постоянно за собой таскать размер. Нужно самостоятельно работать с памятью. То есть,
[14:35.460 --> 14:39.700]  выделять память и очищать память. Плюс необходимо самостоятельно имитализировать размер. То есть,
[14:39.700 --> 14:44.580]  что делать, если у вас пустой стек, а вы указали изначально размер равным 10? Ну, тоже ошибка. И при
[14:44.580 --> 14:48.820]  этом за этим никто не следит. И при этом в любой момент, самое главное, вы имеете несанкционированный
[14:48.820 --> 14:53.500]  доступ к данным. Вот, смотрите, давайте посмотрим на main. Что мне должно мешать, кроме совести,
[14:53.500 --> 14:59.540]  обратиться к элементу stackBuffer. Ничего мне не мешает. Я просто могу взять и скажем, ну, несмотря на
[14:59.540 --> 15:03.300]  то, что у меня стек, я могу обратиться куда-то в середину, куда-то в конец, в начало и изменить
[15:03.300 --> 15:07.980]  совершенно свободные свои элементы. Согласны? Хотя, на самом деле, стек не предполагает такого
[15:07.980 --> 15:14.700]  функционала. Вот. И плюс философский вопрос. А что такое вообще stack? Где в данной программе stack?
[15:14.700 --> 15:19.860]  Вот такой сущности как stack в данной программе в принципе не существует. То есть, нельзя сказать,
[15:19.860 --> 15:23.980]  вот где stack? Ну, можно сказать, что это вот и указатель и size, но при этом вот такой вот
[15:23.980 --> 15:29.460]  единой сущности закончено, ее нет. То есть, непонятно, что такое stack. Либо это сам буфер,
[15:29.460 --> 15:34.100]  либо и размер массива, либо вот сами функции push, pop и т.д. Вообще ничего непонятно. Вообще
[15:34.100 --> 15:38.780]  непонятно, существует ли stack в вашей программе или нет. Теперь давайте посмотрим, как бы то же
[15:38.780 --> 15:43.860]  самое можно было реализовать с помощью объектно-ориентированного подхода. С помощью объектно-ориентированного
[15:43.860 --> 15:47.420]  подхода, еще раз повторюсь, это программирование типов. То есть, вы программируете новый тип. Вот
[15:47.420 --> 15:53.980]  давайте заведем новый тип stack. Значит, что такое stack? То есть, если мы реализуем stack на массиве,
[15:53.980 --> 15:57.620]  что он должен хранить внутри себя? Ну, понятное дело, он должен хранить сам массив, то есть,
[15:57.620 --> 16:02.780]  указатель на массив буфер. Дальше он должен хранить размер. И дальше мы указываем набор операций,
[16:02.780 --> 16:07.580]  которые допустимы над stack'ом. То есть, опять же напомню, вот эти функции, которые мы пишем
[16:07.580 --> 16:12.620]  внутри структуры, называются методами. Смотрите, мы заводим отдельный метод init, который просто берет
[16:12.620 --> 16:18.940]  вот эти вот поля нашей структуры, инициализирует с помощью выделения памяти, и size инициализирует
[16:18.940 --> 16:22.820]  нулем. Нам теперь не нужно думать о том, чтобы самостоятельно как-то отдельно инициализировать
[16:22.820 --> 16:27.060]  буфер и size. Все инициализируется в одной отдельной функции. Дальше есть отдельный метод finalize,
[16:27.060 --> 16:31.620]  который делает необходимые действия по очищению stack'а. В частности, просто удаляет буфер. Ну и дальше
[16:31.620 --> 16:37.740]  есть методы push, которые добавляют элементы в наш массив, в наш stack. Pop, которые удаляют верхний
[16:37.740 --> 16:43.460]  элемент из нашего stack'а, и top, который берет верхний элемент. И дальше давайте посмотрим на main.
[16:43.460 --> 16:49.300]  Как выглядит main? В main выглядит чисто и аккуратно. Мы создали переменную stack, дальше что сделали?
[16:49.300 --> 16:53.540]  Пронициализировали его, запушили туда единицу, получили верхний элемент, удалили верхний элемент
[16:53.540 --> 16:58.540]  и очистили наш массив. Все просто и понятно. То есть, нам теперь не нужно следить за тем, что мы правильно
[16:58.540 --> 17:03.500]  передаем нужные указатели, правильно передаем нужный размер и так далее и так далее. Все делается за
[17:03.500 --> 17:07.860]  нас. То есть, все скрытое, грубо говоря, внутри реализации. Вот то, про что мы говорили. Инкапсуляция.
[17:07.860 --> 17:13.220]  То есть, мы объединили данные и методы для работы с ними и, грубо говоря, не видим реализации. То есть,
[17:13.220 --> 17:20.820]  мы видим чистый код и понятный. Мы, по сути, решили большинство проблем и осталась единственная
[17:20.820 --> 17:24.780]  проблема. И это мы, на самом деле, в любой момент все еще имеем несанкционированный доступ к данным.
[17:24.780 --> 17:32.780]  Согласны? Ну почему? Потому что ничто мне не мешает все еще сделать, например, вот такую штуку stack.size
[17:32.780 --> 17:40.700]  равно миллион. Но если у нас структура, то мы в свободном можем обращаться к полям. И никто
[17:40.700 --> 17:45.020]  мне этого не запретит. Нужна некоторая защита от дурака. Наверное, хотелось бы, чтобы такое тоже
[17:45.020 --> 17:49.420]  было запрещено. То есть, если я указал действия, которые необходимы, которые можно совершать над
[17:49.420 --> 17:53.860]  stack, то есть push, pop и top, наверное, хочется, чтобы пользователь совершал только эти действия и
[17:53.860 --> 18:01.180]  ничего другого он сделать не мог. Естественное желание? Ну давайте об этом поговорим. Следующая
[18:01.180 --> 18:07.420]  тема это модификаторы доступа. Значит, классам и структурам можно писать модификаторы доступа.
[18:07.420 --> 18:12.580]  Самые главные модификаторы доступа, на которые стоит обратить внимание, это public и private.
[18:12.580 --> 18:18.020]  Но если совсем коротко, то public разрешает доступ вообще всем, то есть все могут обращаться к данным
[18:18.020 --> 18:24.780]  полям и методам. А private всем запрещает. Теперь подробнее. Да, ну давайте про синдексис поговорим.
[18:24.780 --> 18:28.900]  Значит, когда вы пишете структуру, вы в какой-то момент можете написать модификатор доступа. Ну,
[18:28.900 --> 18:33.860]  грубо говоря, public или private. И вот начиная с этого момента, вот весь код, который написан здесь,
[18:33.860 --> 18:40.020]  он, грубо говоря, становится публичным. Все могут обращаться к данным полям и методам. В какой-то
[18:40.020 --> 18:45.580]  момент вы можете захотеть поменять. Точнее, тут был приватный, то есть вы запретили всем, когда вы
[18:45.580 --> 18:49.740]  пишете приватную область, вы запрещаете всем обращаться к данным полям и методам. Теперь эта область
[18:49.740 --> 18:55.660]  никому не доступна, кроме самой структуры. Потом в какой-то момент вы можете поменять свое желание,
[18:55.660 --> 18:59.140]  вы можете сказать, что нет. Теперь вот, начиная с этого момента, все остальное должно быть публичным.
[18:59.140 --> 19:08.060]  Теперь вот это вот все приватное, а вот это все публичное. Если совсем коротко. Что? Вот, да, то, что
[19:08.060 --> 19:12.180]  сверху. Об этом поговорим чуть позже, но давайте я сразу скажу, что тут по умолчанию все публичное.
[19:12.180 --> 19:15.460]  Ну, об этом можно было догадаться, то есть вы раньше писали структуру, ничего не писали,
[19:15.460 --> 19:21.980]  поэтому по умолчанию в структурах все публичное. Так, какие вообще можно писать модификаторы доступа?
[19:21.980 --> 19:26.820]  На самом деле их всего три. Ну, первое публичное, самое простое. Всем все можно, то есть можно
[19:26.820 --> 19:32.900]  обращаться к полям, к методам и вообще всему, что написано там внутри. Приватное. Доступ имеет
[19:32.900 --> 19:37.100]  только поля и методы самого класса, а также дружественные функции класса. Вот про дружбу мы
[19:37.100 --> 19:42.460]  поговорим чуть позже, но пока можно запомнить то, что, в общем, если вы объявили область приватной,
[19:42.460 --> 19:46.100]  то туда никто не имеет права обращаться, то есть никто не имеет права даже знать, что там что-то
[19:46.100 --> 19:50.980]  находится. То есть вы, грубо говоря, закрыли ровно то, чего мы и хотели до этого. Ну, есть Protected,
[19:50.980 --> 19:55.020]  пока давайте считать, что Protected то же самое, что и Private. На самом деле, Protected действует
[19:55.020 --> 19:58.260]  чуть иначе, когда речь идет про наследование, но про наследование мы поговорим примерно через
[19:58.260 --> 20:03.780]  две лекции, поэтому давайте пока считать, что Protected то же самое, что и Private. Ну, и два правила,
[20:03.780 --> 20:07.940]  располагать модификаторы доступа можно в любом порядке, в любом количестве, то есть вы можете
[20:07.940 --> 20:14.620]  написать, не знаю, public, потом внезапно сразу еще раз написать public, потом снова написать public,
[20:14.620 --> 20:21.820]  потом поменять на private, потом снова поменять на public и так далее. То есть между собой вы можете
[20:21.820 --> 20:26.780]  менять как угодно. Главное, что вот между вот этими объявлениями, то есть между вот этими словами
[20:26.780 --> 20:32.900]  у вас либо публичная, либо приватная область, точнее так, которая написана выше. Ну, и модификатор
[20:32.900 --> 20:37.540]  действует с точки объявления до следующего модификатора, то есть от public до public, от public
[20:37.540 --> 20:42.580]  до private и от private до public. Ну и, соответственно, либо до конца класса, то есть после последнего
[20:42.580 --> 20:50.260]  public, все до конца класса или структура будет публичным. Это понятно, да? Ну и давайте упражнения,
[20:50.260 --> 20:56.500]  посмотрим на то, как это работает. Значит, у меня есть структура S, у меня там есть поле
[20:56.500 --> 21:02.980]  int x и есть еще два int поля y и z, которые объявлены в приватной области. Есть приватная функция f,
[21:02.980 --> 21:08.500]  точнее метод f, который внутри себя устанавливает x равным 0 и y равным 0. И есть публичный метод g,
[21:08.500 --> 21:12.700]  который внутри себя x устанавливает равным 0 и z устанавливает равным 1. Значит, вопрос,
[21:12.700 --> 21:22.900]  есть ли тут ошибки импиляции? Все ли строки хорошо сработают? Так, здесь не будет работать?
[21:22.900 --> 21:33.820]  Что еще не будет работать? Так, давайте разберемся z. Кто считает, что z не будет работать?
[21:34.060 --> 21:46.220]  В общем, вы не правы, z будет работать. Смотрите, на самом деле, это пример как раз про то,
[21:46.220 --> 21:52.900]  что внутри структуры паблик и private не имеют никакого значения. Ну сама структура естественным
[21:52.900 --> 22:12.740]  образом имеет доступ ко всему, вообще ко всему. Обычные переменные? В структурах по умолчанию все
[22:12.740 --> 22:18.460]  публичное. Если у вас ничего сверху не написано, то это публичное в структурах. То есть мораль тут
[22:18.460 --> 22:25.780]  такая, что модификаторы доступа внутри структуры, грубо говоря, не действуют. Понятно дело, что структура
[22:25.780 --> 22:29.980]  s сама себя реализует, она имеет свои характеристики, она реализует свое метод. Естественно, она должна
[22:29.980 --> 22:34.980]  иметь доступ ко всему. То есть как-то странно, что вы внутри структуры объявили что-то приватным,
[22:34.980 --> 22:38.940]  и сама эта структура не имеет права к этому обращаться. Вопрос, кто имеет вообще права к
[22:38.940 --> 22:44.700]  этому обращаться? Зачем тогда вообще задавали эту переменную? Публичные приватные модификаторы
[22:44.700 --> 22:48.900]  доступа имеют смысл только для внешнего кода. То есть вы выставляете, грубо говоря, требования на
[22:48.900 --> 22:54.060]  внешний код. То есть внешний код имеет право к этому обращаться, а к этому не имеет права. Но при этом,
[22:54.060 --> 22:58.620]  так как структура всем этим владеет, она, собственно, имеет право с этим обращаться как угодно. И неважно
[22:58.620 --> 23:03.420]  в каком это методе, в публичном или приватном. То есть поэтому во всех этих трех, точнее во всех
[23:03.420 --> 23:09.180]  этих четырех строках, все работает как надо. То есть функция f устанавливает x и y в ноль,
[23:09.180 --> 23:18.300]  и функция g устанавливает x и z в ноль. Все понятно. А теперь пример со внешним кодом. Значит,
[23:18.300 --> 23:23.940]  рассмотрим структуру s. У нее есть публичное поле x, ну так у нас сверху ничего не написано, и публичные
[23:23.940 --> 23:30.420]  методы g и h. h принимает int, g ничего не принимает. Есть приватная область, в которой объявлено
[23:30.420 --> 23:37.460]  поле y и два метода f и h, который принимает double. Давайте по порядку. Могу ли я из main обратиться к
[23:37.460 --> 23:44.140]  полю x? Да, поле x публичное, поэтому тут мне все разрешено. Могу ли я обратиться к полю y? Нет,
[23:44.140 --> 23:48.860]  а вот тут не могу. И вот это, собственно, главное значение private. Если вы считаете, что данное поле
[23:48.860 --> 23:54.860]  является частью реализации, ее никто не должен трогать. То есть вы считаете, что если это поле
[23:54.860 --> 24:00.540]  кто-то исправит, как-то изменит, и это нарушит работу вашего класса или структуры, то вы
[24:00.540 --> 24:04.780]  должны объявить это поле приватным. Соответственно, здесь так и сделано. Мы объявили поле y приватным,
[24:04.780 --> 24:10.140]  и к нему никто не имеет права обращаться, кроме самого самой структуры. Дальше. Имеем ли право
[24:10.140 --> 24:16.260]  вызывать метод f? Нет. Метод f тоже приватный, то есть он является частью реализации, он не является
[24:16.260 --> 24:21.580]  частью публичного интерфейса. То есть, грубо говоря, не знаю, как телефон. Вот есть публичный
[24:21.580 --> 24:25.660]  интерфейс, там в нем есть камеры, есть, условно, сенсоры, которые позволяют. Еще у него внутри
[24:25.660 --> 24:30.020]  есть процессор, но непосредственно к процессору я обратиться не могу. То есть он там есть, но это
[24:30.020 --> 24:37.500]  часть реализации, это грубая приватная область. Понятно? Вот. Могу ли обращаться к g? К g могу,
[24:37.500 --> 24:43.340]  это публичный метод. Могу ли я вызывать h от нуля? Да, это h от int могу обращаться. Могу ли
[24:43.340 --> 24:52.300]  вызывать h от 0.0? Но у меня же есть публичный h от int. Вот главный вопрос, будет ли тут
[24:52.300 --> 25:02.940]  переобразование или нет? Вот на самом деле нет. Вот на это прошу обратить внимание. На последнюю
[25:02.940 --> 25:09.780]  строку прошу обратить внимание. Этот пример показывает следующее. Как вообще принимается
[25:09.780 --> 25:15.260]  решение, что публичное, что приватное? Смотрите, сначала компилятор выбирает функцию, которую вы
[25:15.260 --> 25:18.420]  вызвали. То есть она определяется с функцией, то есть выбирает перегрузку. То есть в данном случае
[25:18.420 --> 25:23.260]  метод h перегружен. То есть есть метод, который вызывается от int, есть метод, который вызывается
[25:23.260 --> 25:31.020]  от дабла. В данном случае вы h вызвались от дабла. Соответственно сначала компилятор понимает,
[25:31.020 --> 25:36.580]  что вы хотите на самом деле вот этот вот метод. То есть между h от int и h от double, h от double
[25:36.580 --> 25:42.700]  обладает точным соответствием, поэтому выбирается он. А уже потом компилятор начинает думать,
[25:42.700 --> 25:47.660]  а вообще может ли пользователь вызывать этот метод или нет. В данный момент оказывается,
[25:47.660 --> 25:52.740]  что не может, и он выдает ошибку компиляции. То есть порядок следующий. Сначала выбирается
[25:52.740 --> 26:05.900]  перегрузка, а только потом проверяются доступы. Понятно? Объявить функции вы можете внутри
[26:05.900 --> 26:09.660]  структуры. А вот про определение мы сейчас поговорим. Определить можно и вне структуры.
[26:17.660 --> 26:24.220]  Не-не-не. Вот перескальки он не будет. Он выберет h от double, и в этот момент у него будет паника,
[26:24.220 --> 26:30.140]  потому что вы лезете туда, куда вам не нужно. То есть он выдаст ошибку, что-то типа h от double,
[26:30.140 --> 26:41.580]  ну короче из private, in this context. Ну что-то наподобие такого он напишет. Впрочем он просто
[26:41.580 --> 26:46.700]  скажет, что метод приватный, вы не имеете права к нему обращаться. То есть h от int он не будет,
[26:46.700 --> 26:51.700]  то есть он будет его рассматривать на этапе выбора перегрузки, но по итогу выберите h от double,
[26:51.700 --> 26:58.340]  и вот в этот момент будет ошибка доступа. При этом h от int можно спокойно выбирать,
[26:58.340 --> 27:01.460]  почему? Потому что h от double тоже будет рассматриваться, то есть он будет видеть,
[27:01.460 --> 27:05.620]  что у вас есть h от int, и у вас есть h от double. Но по итогу будет выбран h от int, потому что вы
[27:05.620 --> 27:10.260]  вызываетесь от int. А h от int можно спокойно вызывать так, как он публичный. То есть выбор
[27:10.260 --> 27:13.300]  перегрузки, а потом только проверка доступа. Именно в таком порядке.
[27:13.300 --> 27:23.940]  Если был h от float, все равно вызывался бы h от double, потому что 0.0 это литерал типа double.
[27:23.940 --> 27:31.460]  Ну и возвращаемся к тому примеру, который мы писали до этого, то есть stack на массиве.
[27:31.460 --> 27:36.700]  То есть теперь как выглядит примерно правильная реализация stack? То есть мы определяем методы
[27:36.700 --> 27:41.020]  в публичной области. То есть мы говорим, что со stack нужно обращаться так. Можно вызывать
[27:41.020 --> 27:45.620]  метод int, можно вызывать метод finalize, можно что-то добавлять stack, можно из него что-то удалять,
[27:45.620 --> 27:49.900]  можно получать верхний элемент, и можно спрашивать его размер. А к чему нельзя обращаться?
[27:49.900 --> 27:56.340]  А нельзя обращаться к буферу и к size. Это детали реализации, тебе это не надо. И если вы из
[27:56.340 --> 28:01.060]  main попробуете обращиться к size, даже обратиться, то есть не просто как-то изменить, а просто считать
[28:01.060 --> 28:05.620]  его, у вас ничего не получится. То есть у вас правил этот запрет не только на модификацию,
[28:05.620 --> 28:10.540]  но вообще в принципе на доступ, на чтение. То есть если вы обратитесь непосредственно к size,
[28:10.540 --> 28:13.780]  то у вас возникнет вот такая ошибка. Исправить within this context.
[28:13.780 --> 28:26.460]  Ну и до этого я часто говорил слово class, структуру и так далее. Ну в общем, смотрите,
[28:26.460 --> 28:30.540]  class это концепция объектно-ориентированного программирования. То есть объектно-ориентированное
[28:30.540 --> 28:33.220]  программирование просто такая теоретическая штука, которая описывает, ну собственно,
[28:33.220 --> 28:37.700]  парадигму программирования. Ну и там принято такая формировка как class. На самом деле структуры,
[28:37.700 --> 28:43.700]  с точки зрения теории ООП, тоже являются классами. И не стоит путать его с ключевым словом class,
[28:43.700 --> 28:50.220]  которое есть в языке C++. В языке C++ есть ключевое слово class, которое обозначает буквально то же
[28:50.220 --> 28:57.460]  самое, что и структура. То есть слова struct и class взаимозаменяемые. Но у них есть два отличия.
[28:57.460 --> 29:01.900]  Первое отличие заключается в том, что, как мы говорили до этого, в структурах по умолчанию
[29:01.900 --> 29:08.700]  всё публичное. А вот в классах по умолчанию всё приватное. Вот это первое и самое главное отличие.
[29:08.700 --> 29:13.900]  В структурах всё публичное по умолчанию, в классах по умолчанию всё приватное. То есть если вы не
[29:13.900 --> 29:17.900]  писали никакого модификатора доступа, то в классах у вас всё будет приватным. Ну и второе правило,
[29:17.900 --> 29:22.020]  тоже оно связано с наследованием, ну в общем об этом отдельно поговори, ну давайте.
[29:22.020 --> 29:30.660]  Ну смотрите, структ пришёл нам из языка C. В языке C не было никаких модификаторов доступа.
[29:30.660 --> 29:36.900]  А class это концепцию OP, поэтому в языке C++ было добавлено ещё слово class. Ну чтобы было
[29:36.900 --> 29:40.340]  понятней, что мы действительно объявляем class как концепцию объектной ретиропрограммирования.
[29:40.340 --> 29:44.900]  Ну собственно, да, про второй пункт. Классы наследуют по умолчанию приватным образом,
[29:44.900 --> 29:50.420]  а структуры публичным. Что бы это не значило? Об этом поговорим потом. Ну и на самом деле,
[29:50.420 --> 29:57.060]  как правило, если вы пишете именно class, то есть как набор методов, полей и методов для работы с
[29:57.060 --> 30:02.700]  ними, то есть вот так как мы писали stack, обычно пишут class. То есть если вы пишете class, пишите
[30:02.700 --> 30:08.060]  class. Структуры используют в том понимании, в котором вы их использовали в предыдущем
[30:08.060 --> 30:11.340]  семестре. То есть если вам нужна структура просто чтобы объединить какие-то данные,
[30:11.340 --> 30:15.860]  ну просто объединить какие-то данные, то есть допустим у вас функция должна возвращать,
[30:15.860 --> 30:23.540]  не знаю, bool и int. Тогда вы просто объединяете их в структуру и возвращаете совместно. Если вы
[30:23.540 --> 30:27.340]  хотите описать именно новый тип, как набор действий и так далее, то вы пишете class,
[30:27.340 --> 30:31.900]  но это просто некоторые соглашения. Поэтому вот с этого момента мы будем писать только class.
[30:31.900 --> 30:46.580]  Да, то есть если, ну смотрите, вот если вы написали stack таким образом и не написали ни public,
[30:46.580 --> 30:50.180]  ни private, ничего, то внутри stack вы вообще никак не можете обратиться. То есть такой
[30:50.180 --> 30:54.260]  класс, к которому вообще нельзя обращаться. В смысле его можно создать, но при этом внутри
[30:54.260 --> 30:59.140]  него ни к чему нельзя обратиться. Поэтому для класса нужно обязательно в какой-то момент
[30:59.140 --> 31:08.740]  прописать public, если вы хотите его использовать. Теперь вот про то, что вы говорили, про определение
[31:08.740 --> 31:17.780]  вне классов. Ну как и обычные функции, методы можно сначала объявить, то есть методы это те
[31:17.780 --> 31:21.700]  функции, которые мы пишем внутри структуры или класса. Значит, методы можно сначала объявить,
[31:21.700 --> 31:26.460]  а реализацию написать где-нибудь еще. Ну, грубо говоря, в отдельном файле. Вот на семинаре вы
[31:26.460 --> 31:30.380]  должны были изучать, как разделять вашу программу на заголовочные файлы, на файлы реализации.
[31:30.380 --> 31:36.260]  Можно структуру класса писать так. Сначала писать все объявления в заголовочном файле,
[31:36.260 --> 31:42.500]  а все определения писать в CPU файле. Как это делается? Вот мы записали структуру S. Это объявление
[31:42.500 --> 31:48.980]  структуры. То есть мы объявили структуру и объявили метод, который есть внутри него. В данном случае
[31:48.980 --> 31:54.460]  этот метод F. Теперь этот метод F мы можем определить. Мы можем его определить непосредственно
[31:54.460 --> 31:59.740]  внутри структуры, то есть написав здесь фигурные скобки и дальше написав, что мы хотим делать. А можно
[31:59.740 --> 32:05.300]  написать вне структуры или вне класса. Делается таким образом. Вы пишете, собственно, прототип
[32:05.300 --> 32:11.060]  данной функции, то что она возвращает void, то что она ничего не принимает. С единственным отличием вы
[32:11.060 --> 32:17.300]  пишете полное имя, так называемое полное имя вашей функции. А полное имя вашей функции состоит из имени
[32:17.300 --> 32:23.220]  класса, двоеточие, двоеточие и дальше имя метода. То есть вы говорите, что вы определяете функцию F,
[32:23.220 --> 32:34.940]  которая объявлена внутри класса. Дальше вы пишете саму реализацию. Все как обычно. Альтернативно
[32:34.940 --> 32:40.540]  вы можете сделать определение непосредственно внутри структуры. В чем отличие определение внутри
[32:40.540 --> 32:47.660]  структуры или определение вне структуры? Отличие одно. Если вы пишете определение внутри структуры или
[32:47.660 --> 32:56.860]  класса, то эти функции не явно определяются как inline. Все помните, что такое inline? Inline так
[32:56.860 --> 33:03.580]  называемые встраиваемые функции. В общем, раньше смысл встраиваемых функций был такой, что их код
[33:03.580 --> 33:07.940]  просто берется, непосредственно поставляется вместо вызова, то есть не происходит переключение
[33:07.940 --> 33:13.020]  контекста и так далее. Сейчас inline используют для того, чтобы нарушать правила одного определения.
[33:13.020 --> 33:18.140]  То есть вы знаете, что функции в программе могут существовать только в единственном экземпляре,
[33:18.140 --> 33:23.860]  то есть допускается только одно определение функции на всю программу. Но если вы для функции пишете
[33:23.860 --> 33:31.500]  inline, то это правило можно обойти. Inline говорит, что определение этой функции несколько
[33:31.500 --> 33:36.420]  определений, но при этом важно понимать, что у этой функции все определения должны быть одинаковые.
[33:36.420 --> 33:48.820]  В стандарте написано с точностью до токенов. Это такое специальное слово, которое говорит
[33:48.820 --> 33:52.900]  о том, что я хочу так. Это может быть полезно, если вы, например, пишете какую-нибудь короткую
[33:52.900 --> 33:57.540]  функцию, для которой вам не хочется отдельно писать объявление, для которой вам не хочется
[33:57.540 --> 34:02.020]  отдельно писать определение, то есть не хочется разделять ее на h и cpp файл. Вы можете написать
[34:02.020 --> 34:07.380]  определение функции в cpp файле и пометь ее как inline. И тогда эта функция будет присутствовать во
[34:07.380 --> 34:12.580]  многих экземплярах в различных cpp файлах, но при этом так и на inline все будет нормально.
[34:12.580 --> 34:23.620]  Впервые поступил интересный вопрос. Смотрите, все время до этого мы как-то ограничивали доступы,
[34:23.620 --> 34:27.060]  то есть ограничивали с помощью паблика и правила, и вот поступил вопрос, а можно ли,
[34:27.060 --> 34:32.820]  грубо говоря, запретить запись, но разрешить чтение, то есть я хочу создать поле, которое можно
[34:32.820 --> 34:38.020]  читать, но при этом перезаписывать нельзя. Вот напрямую так сделать невозможно, но есть такой
[34:38.020 --> 34:41.260]  специальный паттерн, называется Getter и Setter, то есть вы заводите некоторые специальные методы,
[34:41.260 --> 34:46.940]  которые позволяют либо устанавливать значение, закрытое поле в нужном вам значении, либо его
[34:46.940 --> 34:51.780]  читать. Вот, например, если у вас есть какой-то класс, и у него есть закрытое поле x, которое вы
[34:51.780 --> 34:54.740]  запретили изменять, то есть которое вы хотите запретить изменять, то при этом которое вы хотите
[34:54.740 --> 34:59.980]  разрешить читать. Вот, для этого вы в публичной области заводите специальный метод, условно
[34:59.980 --> 35:05.940]  называете его GetX, то есть получить x, и из него вы возвращаете x. Вот, и тогда с помощью этого метода
[35:05.940 --> 35:09.780]  вы в любой момент можете, то есть внешний код может в любой момент получить значение этого самого
[35:09.780 --> 35:19.500]  поля, но при этом на запись это поле, естественно, недоступно. Понятно? Ну, такой вот паттерн. Так,
[35:19.500 --> 35:27.980]  теперь давайте пойдем дальше. Поговорим про константность. Значит, константные поля. Ну,
[35:27.980 --> 35:34.420]  собственно, как и любые другие обычные переменные, поля можно объявлять константными. То есть у вас
[35:34.420 --> 35:38.980]  может быть поле x, которое неконстантное, может быть поле y, которое является константным n-том.
[35:38.980 --> 35:44.020]  Понятно дело, что как и любые другие константы, константные поля нужно инициализировать сразу
[35:44.020 --> 35:50.020]  при создании объекта. Как это делать правильно, мы поговорим уже на следующей неделе, когда будем
[35:50.020 --> 35:55.340]  говорить про конструкторы. Но пока на текущий момент правильный способ инициализировать
[35:55.340 --> 35:59.220]  константы, это просто непосредственно при объявлении структуры прописать его дефолтные
[35:59.220 --> 36:04.740]  значения. Ну, сейчас я хочу, чтобы у меня было константное поле, которое равно 9. Естественно,
[36:04.740 --> 36:09.300]  такие поля изменить нельзя. То есть, если это поле констант, его изменить нельзя. Вообще никак. Вот
[36:09.300 --> 36:15.060]  эту мысль запомните, она важная. В константной поля никак изменить нельзя. Вот вообще. Даже с
[36:15.060 --> 36:22.100]  помощью того, что мы будем рассматривать дальше. Вопрос? Кост-каст. Ну, кост-каст это запрещенный
[36:22.100 --> 36:29.780]  способ. Вы что, рот смылом-то помойте. Зачем? Нет, короче, нельзя. Ну, короче, если вы объели
[36:29.780 --> 36:40.700]  константы, значит нельзя. В принципе, нельзя. Окей. Ну и простое упражнение. Смотрите, у меня
[36:40.700 --> 36:46.820]  есть структура S, у которой есть публичное поле X и публичное константное поле ID. Которое просто,
[36:46.820 --> 36:51.060]  при создании нового объекта, оно получает некоторый новый уникальный номер. Ну, уникальный номер
[36:51.060 --> 36:55.580]  пусть хранится в глобальной, какой-то глобальной области. То есть, у меня есть N. И при каждом
[36:55.580 --> 37:02.900]  создании объекта у меня N записывается в константное поле ID и увеличивается на единицу. Вот. И у меня
[37:02.900 --> 37:07.220]  есть метод F, который пытается увеличить X на единицу и пытается увеличить ID на единицу. Что здесь
[37:07.220 --> 37:13.100]  не так? Да, ID изменить нельзя. ID это константное поле, поэтому его никто никогда изменить не может.
[37:13.100 --> 37:23.020]  Даже внутри метода. Так, теперь посмотрим на внешний код. Вот когда я объявил S от A, у меня у A ID
[37:23.020 --> 37:30.780]  стал равным нулю. Когда я объявил B, точнее, определил B, у меня ID стал равным единице. При этом я не
[37:30.780 --> 37:35.740]  изменял ID, я их проинициализировал. Понятно? То есть, при создании объекта у меня отработал вот этот
[37:35.740 --> 37:48.460]  код и ID проинициализировался. Все. Могу ли я обратиться к A.X и B.X? Почему нет? Или почему да?
[37:49.180 --> 37:55.360]  Может быть, я там не могу этого? Да, во-первых, потому что x публичная. А во-вторых, потому что x не константная.
[37:55.360 --> 38:00.320]  Точнее так. Я обратится, как Normally parfois могу, потому что он публичный. А изменить его
[38:00.320 --> 38:08.920]  могу, потому что он не константный. А к ID я могу обратиться таким образом? Да, снова, ID публичный,
[38:08.920 --> 38:12.620]  поэтому обратиться-то я могу. Но то есть 對, прочитать его я могу. Но, при этом присвоить ему
[38:12.620 --> 38:16.940]  какое-то значение, или его как-то изменить не могу, поэтому да, здесь ничего не работает.
[38:16.940 --> 38:29.220]  Понятно? Ну, с константными полями все просто. В общем, они ведут себя так же, как и обычные
[38:29.220 --> 38:35.500]  константные. Вот теперь новая сущность, константные методы. Короче, методы или функции,
[38:35.500 --> 38:40.500]  которые написаны внутри классов, на самом деле тоже можно объявить константными. Какой в этом
[38:40.500 --> 38:47.820]  смысл? Смотрите. Давайте вспомним класс stack, который мы буквально недавно написали, ну и посмотрим
[38:47.820 --> 38:53.100]  на реализацию метода size. Что делает метод size у stack? Он просто возвращает размер stack. Согласно,
[38:53.100 --> 38:58.380]  да? То есть size это приватный член, но чтобы получить к нему доступ на члене, я его возвращаю
[38:58.380 --> 39:04.100]  из специального метода size. Окей? Вот. Ну и теперь давайте посмотрим такой момент. Смотрите,
[39:04.100 --> 39:09.700]  я build stack. Ну как-то с ним поработал, что-то в него запушил, там как-то провел над ним необходимые
[39:09.700 --> 39:15.700]  действия. А потом, допустим, создал на него константную ссылку. Ну, что такое константные ссылки, думаю,
