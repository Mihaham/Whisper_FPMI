[00:00.000 --> 00:09.120]  Итак, всем добрый день.
[00:09.120 --> 00:12.800]  Как вы можете видеть с экрана, у нас сегодня максимально
[00:12.800 --> 00:15.520]  подробный разбор ранжей, кто-то из вас что-то про
[00:15.520 --> 00:16.520]  них уже знает.
[00:16.520 --> 00:20.800]  Наверное, стоит сказать, почему на этом курсе мы
[00:20.800 --> 00:24.000]  внезапно идем разбирать такую прикладную библиотеку,
[00:24.000 --> 00:27.160]  которая нужна тупо, чтобы в одну строчку олимпиадные
[00:27.160 --> 00:34.000]  задачки решать, как в питоне, принт, трансформат, мап,
[00:34.000 --> 00:36.360]  от инпута, сплит, вот это все.
[00:36.360 --> 00:39.640]  Кто-то на них когда-нибудь запилить стримы.
[00:39.640 --> 00:40.640]  Стримы?
[00:40.640 --> 00:41.640]  Зачем стримы?
[00:41.640 --> 00:44.480]  Да когда они есть функциональные стримы эти ранжи?
[00:44.480 --> 00:48.080]  Кто-то запилить библиотеку, которая станет на карте.
[00:48.080 --> 00:50.080]  Вот она уже есть, вот эта библиотека.
[00:50.080 --> 00:51.080]  А синхронность еще.
[00:51.080 --> 00:55.400]  А синхронность, это STD execution, да, там это будет технически
[00:55.400 --> 00:56.400]  в какой-то момент.
[00:56.560 --> 00:57.560]  Но это неважно.
[00:57.560 --> 01:00.440]  Даже у нас на курсе не в этом мотивация, а в том,
[01:00.440 --> 01:04.200]  что вот это вот очень мощная метапрограммистская библиотека.
[01:04.200 --> 01:07.880]  Там очень много разной метапроги, во-первых, а во-вторых,
[01:07.880 --> 01:12.320]  там много такой штуки, как generic design.
[01:12.320 --> 01:16.000]  Вот я как-то в прошлых годах больше на этом акцентировал
[01:16.000 --> 01:17.560]  внимание, а в этом забил.
[01:17.560 --> 01:20.480]  Как вы думаете, в чем разница между метапрограммированием
[01:20.480 --> 01:24.320]  и обобщенным программированием или generic design?
[01:25.320 --> 01:26.320]  Слова разные.
[01:26.320 --> 01:27.320]  Слова разные.
[01:29.320 --> 01:30.320]  Ну, нету идеи, да?
[01:39.320 --> 01:42.320]  Ну, это конкретика, и ты почти полиморфизм сейчас описал.
[01:43.320 --> 01:48.320]  Ну, в общем и целом, метапрограммирование – это вот тупые инструменты,
[01:48.320 --> 01:52.320]  которые у нас есть в языке, чтобы что-то в compile-time делать.
[01:52.320 --> 01:55.320]  Это создание программ, которые порождают другие программы.
[01:55.320 --> 01:56.320]  Вот это метапрограммирование.
[01:56.320 --> 01:59.320]  С самого начала я сказал какое-то определение из книжки
[01:59.320 --> 02:01.320]  на первой лекции, что ли.
[02:01.320 --> 02:04.320]  А вот generic design – это более общая штука.
[02:04.320 --> 02:08.320]  Это создание алгоритмов и структур данных, обобщенных
[02:08.320 --> 02:13.320]  по чему-то, которые работают для многих разных ситуаций.
[02:13.320 --> 02:18.320]  STD-вектор – это обобщенный алгоритм или структура данных.
[02:18.320 --> 02:20.320]  Я последнее время перестал различать, в чем разница,
[02:20.320 --> 02:21.320]  если честно.
[02:21.320 --> 02:25.320]  Если задуматься, вектор – это просто какая структура данных?
[02:25.320 --> 02:28.320]  Ну, вводит звездочка, а дальше на нем какие-то алгоритмы,
[02:28.320 --> 02:31.320]  которые там какие-то пушбеки делают и еще что-то.
[02:31.320 --> 02:33.320]  Поэтому не суть важна.
[02:33.320 --> 02:36.320]  Ну, вот вектор – это обобщенная структура данных.
[02:36.320 --> 02:39.320]  Она может работать независимо от того, какой тип данных
[02:39.320 --> 02:43.320]  внутри положите, мапчик какой-нибудь и то же самое.
[02:43.320 --> 02:47.320]  И вот для конкретных данных не шаблонный код, который работает
[02:47.320 --> 02:49.320]  в одном конкретном случае.
[02:49.320 --> 02:52.320]  Вы писать все умите, вас там долго учили.
[02:52.320 --> 02:55.320]  Окей, вопрос возникает, а как это обобщить, чтобы работало
[02:55.320 --> 02:57.320]  со многими типами данных?
[02:57.320 --> 03:00.320]  Ну, ответ простой, навешивай шаблон и погнали, поехали.
[03:00.320 --> 03:04.320]  Не хочешь шаблон, делаешь интерфейс и тоже погнали, поехали.
[03:04.320 --> 03:07.320]  То есть вот дженерик дизайнов не только про шаблоны,
[03:07.320 --> 03:09.320]  да, можно обобщать с помощью чего угодно.
[03:09.320 --> 03:11.320]  Но возникает куча вопросов.
[03:11.320 --> 03:13.320]  Какую абстракцию выделить?
[03:13.320 --> 03:16.320]  И вот ну абстракция – это центральное тут вообще понятие.
[03:16.320 --> 03:19.320]  Что будет единицы абстракции?
[03:19.320 --> 03:22.320]  Что включить, методы какие в интерфейс?
[03:22.320 --> 03:25.320]  Или там в концепт какие требования наложить?
[03:25.320 --> 03:28.320]  Требовать там какой-нибудь регулярности или не требовать?
[03:28.320 --> 03:31.320]  Ну и вообще какую иерархию концептов или интерфейсов сделать?
[03:31.320 --> 03:34.320]  И вот на все эти вопросы нет простого ответа.
[03:34.320 --> 03:38.320]  Народ просто сидит и долго и усердно думает, разбирая разные частные случаи
[03:38.320 --> 03:42.320]  и пытаясь подогнать такой дизайн, который их все покрывает.
[03:42.320 --> 03:47.320]  И вот тут люди много-много лет сидели и разбирали разные случаи того,
[03:47.320 --> 03:50.320]  как разным людям нужно работать с,
[03:50.320 --> 03:55.320]  ну казалось бы, просто викторочками, по сути, или массивчиками.
[03:55.320 --> 04:00.320]  Ну вот в Питоне достаточно мощная библиотека для итерации всякой,
[04:00.320 --> 04:03.320]  по-моему, итертулс называется.
[04:03.320 --> 04:06.320]  Но она далеко не все кейсы все равно покрывает,
[04:06.320 --> 04:09.320]  а тут пытаются все кейсы покрыть.
[04:09.320 --> 04:12.320]  Ну и в первую очередь это связано с перфом.
[04:12.320 --> 04:16.320]  В Питоне могут забить на перф, в плюсах ни в коем случае.
[04:16.320 --> 04:21.320]  И вот много-много-много лет обсуждали, какие абстракции выбрать,
[04:21.320 --> 04:25.320]  как лучше обобщать эти алгоритмы, на чем все строить.
[04:25.320 --> 04:27.320]  И придумали.
[04:27.320 --> 04:30.320]  И вот мы сейчас на все это будем смотреть и пытаться какие-то мысли вынести
[04:30.320 --> 04:33.320]  про то, как надо самостоятельно обобщать алгоритмы,
[04:33.320 --> 04:38.320]  если вам это в жизни когда-то придется делать, выделять абстракции.
[04:38.320 --> 04:42.320]  Ну я не думаю, что этому возможно научить в принципе,
[04:42.320 --> 04:46.320]  только вот тут почувствовать надо, приходит с годами.
[04:46.320 --> 04:49.320]  Но какие-то важные уроки, кажется, мы отсюда вынесем.
[04:49.320 --> 04:53.320]  Плюс сколько они не думали, там очень много подводных камней,
[04:53.320 --> 04:57.320]  которые вот если кто-то не расскажет, и вы наткнетесь на практике,
[04:57.320 --> 05:02.320]  то раздебажить будет крайне сложно, и вы будете очень гореть.
[05:03.320 --> 05:07.320]  Смешные ошибки в компиляции?
[05:07.320 --> 05:12.320]  Да, смешные ошибки в компиляции и сюрпризы в поведении тоже могут быть.
[05:12.320 --> 05:15.320]  Еще нарушения конскорректности могут быть в каких-то местах.
[05:15.320 --> 05:19.320]  Но по-моему, сегодня нарушения конскорректности мы смотреть не будем,
[05:19.320 --> 05:25.320]  но после этой презентации на 150 слайдов вы и сами должны будете
[05:25.320 --> 05:28.320]  смочь прочитать что там с конскорректностью неправильно.
[05:28.320 --> 05:30.320]  Копи-он-райт всегда.
[05:31.320 --> 05:34.320]  Копи-он-райт – это ошибка селекции.
[05:34.320 --> 05:36.320]  Тут немножко по-другому.
[05:36.320 --> 05:38.320]  Ладно, давайте начинать уже к делу.
[05:38.320 --> 05:41.320]  Мы разбираем эстедеренджерс, надеюсь, он понятно зачем и почему,
[05:41.320 --> 05:43.320]  и что мы хотим вынести из них.
[05:45.320 --> 05:48.320]  Понятное дело, что сейчас будет куча концептов,
[05:48.320 --> 05:51.320]  а они используют базовые концепты стандартной библиотеки,
[05:51.320 --> 05:53.320]  поэтому повторим их.
[05:53.320 --> 05:56.320]  Помните их? Да? Нет? Да.
[05:56.320 --> 06:00.320]  Movable – базовый концепт, класс, в котором вообще хоть что-то можно делать.
[06:00.320 --> 06:02.320]  Его можно мувать.
[06:02.320 --> 06:04.320]  Это нормальный такой концепт.
[06:04.320 --> 06:06.320]  Тут UniquePtr туда лежит.
[06:06.320 --> 06:08.320]  То есть копиабл концепт.
[06:08.320 --> 06:11.320]  Его еще копировать можно. И мувать, и копировать класс.
[06:11.320 --> 06:14.320]  Тут на самом деле сложно придумать какой-то…
[06:14.320 --> 06:17.320]  Процесс. Что? Какой-нибудь процесс.
[06:17.320 --> 06:21.320]  Процесс? Поток. Тред нельзя копировать.
[06:22.320 --> 06:26.320]  Ну, бывают такие классы, у которых нет конструктора по умолчанию.
[06:26.320 --> 06:29.320]  Тут дальше после копиабл идет semiRegular.
[06:29.320 --> 06:32.320]  Это класс, у которого есть конструктор по умолчанию.
[06:32.320 --> 06:34.320]  Ну, и копируются, и муваются.
[06:34.320 --> 06:37.320]  Любую кодовую базу на клешах откройте,
[06:37.320 --> 06:41.320]  вы найдете там классы, у которых конструктор от чего-то конкретного,
[06:41.320 --> 06:44.320]  ну а копировать, мувать можно, и все нормально.
[06:44.320 --> 06:49.320]  На ингредиентности Regular – это самая пацанская категория типов,
[06:49.320 --> 06:52.320]  которая вообще ведет себя нормально.
[06:52.320 --> 06:55.320]  Потому регулярное… вот такое слово использовали.
[06:55.320 --> 06:58.320]  Оказалось бы, общее – регулярный класс.
[06:58.320 --> 07:01.320]  Они все ведут себя как стандартные типы данных.
[07:01.320 --> 07:05.320]  Можно сравнивать, дефолтно инициализировать, копировать, мувать – все есть.
[07:05.320 --> 07:08.320]  Вот. Сейчас это все у нас пойдет в обиход.
[07:08.320 --> 07:12.320]  Будем внезапно в какие-то моменты навешивать поверх всего
[07:12.320 --> 07:15.320]  требования какой-нибудь регулярности к чему-нибудь,
[07:15.320 --> 07:18.320]  или копируемости, или еще чего-нибудь.
[07:18.320 --> 07:23.320]  Зачем наличие конструктора по умолчанию в отдельных концепциях?
[07:26.320 --> 07:31.320]  Потому что бывают кейсы, когда тебе не нужен конструктор по умолчанию.
[07:31.320 --> 07:37.320]  Но ты же можешь создать optional на штуку, которую нельзя конструировать по умолчанию?
[07:37.320 --> 07:40.320]  Может быть, может быть… сейчас.
[07:40.320 --> 07:45.320]  Может быть, подключение по концепту нужно, потому что для некоторых проверок
[07:45.320 --> 07:49.320]  нам нужно именно вычислять выражение, а не просто смотреть типы.
[07:49.320 --> 07:53.320]  Там нельзя писать decal law, поэтому там нужно писать дефолтно инициализацию.
[07:53.320 --> 07:58.320]  Например, по концептам проверять constexpr функцию, там можно вычислять.
[07:58.320 --> 08:01.320]  Там нельзя писать decal law, потому что дефолтно инициализовал.
[08:01.320 --> 08:04.320]  Нет, это вообще не к этому, это проблема языка.
[08:04.320 --> 08:07.320]  И вообще, ты говоришь нельзя, а на самом деле можно.
[08:07.320 --> 08:10.320]  Ты же все равно в Requires это все впишешь.
[08:10.320 --> 08:14.320]  Ну или если не впишешь, то впиши в Requires, и вот тебе…
[08:15.320 --> 08:18.320]  Ну у тебя из круглых скобок появится из воздуха переменная, и все.
[08:18.320 --> 08:20.320]  Короче, это не про это.
[08:20.320 --> 08:24.320]  Просто есть алгоритмы в стандартной библиотеке, у которых требование ровно вот такое.
[08:24.320 --> 08:26.320]  Ну им просто не нужно дефолтно конструировать.
[08:26.320 --> 08:28.320]  Поэтому они требуют copyable.
[08:28.320 --> 08:32.320]  А есть алгоритмы, которым обязательно надо дефолтно конструировать,
[08:32.320 --> 08:35.320]  это они по-другому не могут. Для них есть этот.
[08:35.320 --> 08:38.320]  Ну, конкретные примеры надо просто вот, как бы, CTRL-F по стандарту сделать
[08:38.320 --> 08:41.320]  или по cpp-reference вы найдете. Это уж сами.
[08:41.320 --> 08:47.320]  Окей. Что было при Степанове? Кто такой Степанов?
[08:52.320 --> 08:54.320]  Нет, не угадали.
[08:54.320 --> 08:56.320]  Ну, Александр Степанов это…
[08:57.320 --> 08:59.320]  Да, стандартную библиотеку придумал.
[08:59.320 --> 09:03.320]  Вот именно он придумал абстракцию траторов C++.
[09:03.320 --> 09:05.320]  Вот такая абстракция вам давно знакома.
[09:05.320 --> 09:09.320]  Но вообще говоря, ни разу не очевидно, что эта абстракция должна быть именно такой,
[09:09.320 --> 09:11.320]  какой она есть в C++.
[09:11.320 --> 09:14.320]  Если вы какие-нибудь другие языки знаете, типа питон или раста,
[09:14.320 --> 09:18.320]  то там итератор, как бы, слово тоже, а значение совсем другое.
[09:18.320 --> 09:21.320]  Кто-то итераторами называет генераторы вообще.
[09:21.320 --> 09:24.320]  У кого-то там итератор можно к булю кастить,
[09:24.320 --> 09:26.320]  и он говорит, вам дошел до конца или нет.
[09:26.320 --> 09:28.320]  Ну, в джаве что-то такое есть.
[09:28.320 --> 09:32.320]  Кто-то вообще стримы использует вместо итераторов, как джава.
[09:32.320 --> 09:36.320]  Ну, у нас итераторы. Есть вот такие категории итераторов.
[09:36.320 --> 09:39.320]  Ну, что это такое? Это named requirements.
[09:39.320 --> 09:43.320]  Те самые, про которые мы уже говорили, когда концепты впервые смотрели.
[09:43.320 --> 09:46.320]  Ну, конечно, теперь никаких named requirements нет.
[09:46.320 --> 09:51.320]  Они обзавелись префиксом legacy и вообще помещено как deprecated.
[09:51.320 --> 09:56.320]  И более того, они не совпадают с тем, что теперь в концептах написано.
[09:56.320 --> 10:01.320]  Поэтому они вот совсем deprecated и, скорее всего, там removed в каких-нибудь 23-26-ых будут.
[10:01.320 --> 10:04.320]  Ну, почему? Потому что... А, нет.
[10:04.320 --> 10:08.320]  Не мог-то они быть removed, потому что у нас есть legacy-функции в стандартной библиотеке.
[10:08.320 --> 10:10.320]  Ну, короче, да.
[10:12.320 --> 10:16.320]  Требования отличаются, потому что когда вот эти вот требования придумывали,
[10:16.320 --> 10:18.320]  ну, не до конца все додумали.
[10:18.320 --> 10:20.320]  И теперь все чуть-чуть поменялось, чуть-чуть усложнилось,
[10:20.320 --> 10:24.320]  больше случаев покрыли, и некоторые баги, крайние,
[10:24.320 --> 10:26.320]  урнеркейсы тоже пофиксили.
[10:26.320 --> 10:29.320]  Поэтому, в принципе, когда вы там на 20-х плюсах пишете,
[10:29.320 --> 10:32.320]  вот эти вот вещи не смотрите, если вы хотите написать итератор.
[10:32.320 --> 10:34.320]  Надо смотреть концепты.
[10:34.320 --> 10:37.320]  Вот. Но проблема-то в чем?
[10:37.320 --> 10:43.320]  Когда лекция про концепты была, мы уже видели, что там вот такие бывают концепты.
[10:43.320 --> 10:45.320]  Сейчас все то же самое будет.
[10:45.320 --> 10:48.320]  Перед тем, как даже определить, что такое итератор,
[10:48.320 --> 10:51.320]  нам нужно определить, что такое weakly incrementable.
[10:51.320 --> 10:53.320]  Давайте посмотрим на этот концепт.
[10:53.320 --> 10:58.320]  Ну, он default initializable внезапно, и movable.
[10:58.320 --> 11:01.320]  OK.
[11:01.320 --> 11:05.320]  Он требует, чтобы был некоторый тип IterDifferenceT,
[11:05.320 --> 11:07.320]  и он был знаковым.
[11:07.320 --> 11:10.320]  Ну, вот эту вот штуку, это типа...
[11:10.320 --> 11:15.320]  Да, вот signedDifferenceT – это, ну, опять trade,
[11:15.320 --> 11:18.320]  опять там ходим, пытаемся так-сяк.
[11:18.320 --> 11:20.320]  Мы это уже видели, не будем застрять внимание,
[11:20.320 --> 11:24.320]  если будете сами писать, на ЦП-референс есть.
[11:24.320 --> 11:26.320]  Signed integral like – это вот...
[11:26.320 --> 11:29.320]  У меня тут так в презентации написано,
[11:29.320 --> 11:32.320]  но на самом деле это гораздо большая пушка.
[11:32.320 --> 11:35.320]  Там в разделе про weakly incrementable
[11:35.320 --> 11:40.320]  на две страницы определение того, что такое целое число.
[11:40.320 --> 11:44.320]  Что там типа целые числа – это штуки, которые ведут себя в принципе
[11:44.320 --> 11:49.320]  как встроенные целые числа, но может быть чуть иначе, но не совсем.
[11:49.320 --> 11:52.320]  Встроенные целые числа – это вот эти вот типа...
[11:52.320 --> 11:53.320]  Встроенные.
[11:53.320 --> 11:54.320]  Встроенные. Чего-чего?
[11:54.320 --> 11:56.320]  А бигендер же проходит, можно все бигендер же...
[11:56.320 --> 11:59.320]  Да. Кажется, в этом и суть, что...
[11:59.320 --> 12:03.320]  Ну, вообще, что такое intuitive IterDifferenceT, вы понимаете?
[12:03.320 --> 12:06.320]  Это что-то вперед побежал. Думаю, не все.
[12:06.320 --> 12:08.320]  Что?
[12:08.320 --> 12:11.320]  Ну да, то есть вот это weakly incrementable –
[12:11.320 --> 12:13.320]  какая-то такая совсем база-база,
[12:13.320 --> 12:17.320]  которая объединяет в себе и итераторы, и числа.
[12:17.320 --> 12:20.320]  То есть итераторы и числа похожи тем, что их можно там
[12:20.320 --> 12:23.320]  двигать вперед-назад, и можно друг из друга вычитать.
[12:23.320 --> 12:27.320]  Вот числа складывать еще можно, а итераторы складывать нельзя.
[12:27.320 --> 12:30.320]  Ну и вот тут выделены все общие для них свойства,
[12:30.320 --> 12:33.320]  и вот IterDifferenceT – это то, что получается,
[12:33.320 --> 12:36.320]  когда вы вычитаете друг из друга как бы итератор.
[12:36.320 --> 12:39.320]  Но итератор нельзя так же выучить.
[12:39.320 --> 12:42.320]  Ну как бы нельзя, но если очень постараться, то можно.
[12:42.320 --> 12:45.320]  Ты можешь двигать один вперед, пока не дойдешь до второго.
[12:45.320 --> 12:46.320]  Либо до Энда.
[12:46.320 --> 12:47.320]  Что?
[12:47.320 --> 12:49.320]  Либо до Энда, но в смысле там же можно.
[12:49.320 --> 12:52.320]  Ну, считаем, что нормальные итераторы.
[12:52.320 --> 12:54.320]  Двигаем один вперед, пока не дешали до второго,
[12:54.320 --> 12:57.320]  и вот сколько насчитали – это между ними расстояние.
[12:57.320 --> 12:58.320]  Вот.
[12:58.320 --> 13:01.320]  И я хотел спросить, почему здесь минуса не требуется,
[13:01.320 --> 13:03.320]  а вот некоторые типы, которые как бы для разницы
[13:03.320 --> 13:05.320]  между итераторами требуются?
[13:06.320 --> 13:10.320]  Потому что мы можем из большего итератора
[13:10.320 --> 13:12.320]  начать с меньшего и большего числа.
[13:12.320 --> 13:13.320]  Нет, почему это?
[13:13.320 --> 13:16.320]  Что это нам мешает потребовать здесь, чтобы был минус определен?
[13:16.320 --> 13:17.320]  Стоп.
[13:17.320 --> 13:19.320]  Мы не всегда можем определить минусы.
[13:19.320 --> 13:20.320]  Ну да.
[13:20.320 --> 13:23.320]  Кто бы уже сказал про forward list, да, forward итераторы.
[13:24.320 --> 13:29.320]  То есть тут не определено, как именно мы можем найти расстояние пока что.
[13:30.320 --> 13:32.320]  Ну и, вернее, как.
[13:32.320 --> 13:35.320]  Явно в тексте не прописано, но подразумевается,
[13:35.320 --> 13:37.320]  что вы всегда можете найти расстояние,
[13:37.320 --> 13:40.320]  просто двигаясь вперед и записывая, сколько вы инкрементов сделали.
[13:40.320 --> 13:43.320]  Вопрос, в какой тип нужно записывать количество инкрементов,
[13:43.320 --> 13:45.320]  чтобы гарантированно влезло.
[13:45.320 --> 13:46.320]  Вот в этот.
[13:46.320 --> 13:48.320]  За этим здесь этот тип и требуется.
[13:48.320 --> 13:51.320]  Ну и он знаковый, потому что вообще-то у вас и в другую сторону
[13:51.320 --> 13:53.320]  может потребоваться двигать, и...
[13:54.320 --> 13:58.320]  Ну, общий алгоритм такой, что вы и тот, и другой одновременно двигаете,
[13:58.320 --> 14:02.320]  пока там один до другого не дойдет, либо другой до первого.
[14:02.320 --> 14:03.320]  Что-нибудь такое.
[14:04.320 --> 14:06.320]  Ну, он тоже не всегда работает.
[14:06.320 --> 14:07.320]  Ладно.
[14:11.320 --> 14:13.320]  Ты промахнешься.
[14:13.320 --> 14:15.320]  Короче, кажется вообще тут общего алгоритма нет.
[14:16.320 --> 14:18.320]  Если мы двигаем по единичке,
[14:18.320 --> 14:21.320]  но каждый раз бач, это степень последствий в токен.
[14:21.320 --> 14:22.320]  А, окей.
[14:22.320 --> 14:24.320]  И если мы знаем, что тогда он бесконечный,
[14:24.320 --> 14:26.320]  потому что у нас бесконечный итератор,
[14:26.320 --> 14:28.320]  тогда рано или поздно не встретиться.
[14:28.320 --> 14:29.320]  Ну окей, да.
[14:29.320 --> 14:30.320]  Ну вот что-то такое.
[14:30.320 --> 14:32.320]  Но вам же две разные копии надо двигать.
[14:32.320 --> 14:34.320]  Да, мы до этого пока не дошли.
[14:35.320 --> 14:38.320]  Тут только плюс-плюс, и постфиксные, и префиксные есть.
[14:38.320 --> 14:42.320]  То есть в обратную сторону двигать мы не можем вообще-то.
[14:42.320 --> 14:45.320]  Там, по-моему, если мы дойдем уже до Энда,
[14:45.320 --> 14:47.320]  и мы проверим, наверное, и пойдем дальше,
[14:47.320 --> 14:48.320]  это будет УБ.
[14:49.320 --> 14:51.320]  Но это очень абстрактный концепт.
[14:51.320 --> 14:53.320]  И предполагается, что ты вот это расстояние
[14:53.320 --> 14:55.320]  будешь искать только для двух корректных.
[14:55.320 --> 14:57.320]  А, нет, даже если не корректные,
[14:57.320 --> 14:58.320]  даже если не корректные,
[14:58.320 --> 15:00.320]  ты просто дошел до Энда.
[15:00.320 --> 15:01.320]  А, говоришь УБ.
[15:01.320 --> 15:03.320]  И если мы будем дальше, это вроде бы УБ.
[15:03.320 --> 15:04.320]  Ну, беда.
[15:04.320 --> 15:06.320]  Ну, короче, ладно.
[15:06.320 --> 15:08.320]  Ну вот ровно такими вопросами,
[15:08.320 --> 15:09.320]  как вот мы сейчас задаемся,
[15:09.320 --> 15:11.320]  задавались люди, которые это придумывали,
[15:11.320 --> 15:13.320]  написали про это,
[15:13.320 --> 15:15.320]  толмут на 250 страниц,
[15:15.320 --> 15:17.320]  про то, как правильно и почему,
[15:17.320 --> 15:19.320]  и не один, по-моему.
[15:19.320 --> 15:20.320]  Это итоговый документ,
[15:20.320 --> 15:22.320]  только с формулировками 250 страниц.
[15:22.320 --> 15:24.320]  Перед этим еще десятки статей были.
[15:24.320 --> 15:26.320]  Ну и выбрали вот такой.
[15:26.320 --> 15:28.320]  Догадаться до всего, почему тут так написано,
[15:28.320 --> 15:31.320]  мы вряд ли сможем, но многие мысли увидим.
[15:31.320 --> 15:34.320]  Никак не гарантируется качество это состояние,
[15:34.320 --> 15:36.320]  но гарантируется, что если мы его можем посчитать,
[15:36.320 --> 15:38.320]  то ответ на корректных таким.
[15:38.320 --> 15:40.320]  Да, что ответ можно хранить в таком типе.
[15:40.320 --> 15:42.320]  Вот что нам гарантирует.
[15:42.320 --> 15:44.320]  Ну и как бы это нужно для всех концептов,
[15:44.320 --> 15:46.320]  которые дальше будут,
[15:46.320 --> 15:48.320]  потому что дальше мы собрались над этим что-то строить,
[15:48.320 --> 15:50.320]  и там, конечно, расстояние считать нужно будет.
[15:50.320 --> 15:52.320]  Вот, и да, как мы уже говорили,
[15:52.320 --> 15:54.320]  пока не прервались, Signed Integral Like
[15:54.320 --> 15:56.320]  включает в себя даже
[15:56.320 --> 16:00.320]  симдешные int 128t
[16:00.320 --> 16:02.320]  и даже беганты,
[16:02.320 --> 16:04.320]  формально говоря.
[16:04.320 --> 16:06.320]  Не знаю, кому нужно
[16:06.320 --> 16:08.320]  два в 128 степени
[16:08.320 --> 16:10.320]  байтиков считать итераторами,
[16:10.320 --> 16:12.320]  но кому-то, видимо, нужно.
[16:12.320 --> 16:14.320]  Ну есть пропозлы,
[16:14.320 --> 16:16.320]  ну, холевары,
[16:16.320 --> 16:18.320]  пропозлы холевары,
[16:18.320 --> 16:20.320]  как обычно.
[16:20.320 --> 16:22.320]  Вот на любой вопрос собираются ли в стандарт добавить
[16:22.320 --> 16:24.320]  ответ холевары,
[16:24.320 --> 16:26.320]  бюрократия, споры,
[16:26.320 --> 16:28.320]  ну, вот так вот.
[16:30.320 --> 16:32.320]  Да, плюсы,
[16:32.320 --> 16:34.320]  префиксный и постфиксный.
[16:34.320 --> 16:36.320]  Ну, префиксный прямо требуется,
[16:36.320 --> 16:38.320]  что у нас все нормальные
[16:38.320 --> 16:40.320]  префиксные инкременты, они возвращают ссылку
[16:40.320 --> 16:42.320]  на себя.
[16:42.320 --> 16:44.320]  От постфиксного ничего не требуется.
[16:44.320 --> 16:46.320]  Почему?
[16:46.320 --> 16:48.320]  Может вам разрешить революции объекта?
[16:48.320 --> 16:50.320]  Нет.
[16:50.320 --> 16:52.320]  Ну что вот постфиксный инкремент?
[16:54.320 --> 16:56.320]  В плане?
[16:56.320 --> 16:58.320]  Копию.
[16:58.320 --> 17:00.320]  Видите, чтобы здесь копируемость требовалась?
[17:02.320 --> 17:04.320]  Нету.
[17:04.320 --> 17:06.320]  Мы можем здесь просто взять и потребовать, чтобы вернули копию.
[17:06.320 --> 17:08.320]  Потому что копируемость
[17:08.320 --> 17:10.320]  не требуется.
[17:10.320 --> 17:12.320]  Тут вообще ничего не просят возвращать.
[17:12.320 --> 17:14.320]  То есть можно void поставить.
[17:14.320 --> 17:16.320]  Так, прошу прощения, у меня
[17:16.320 --> 17:18.320]  пиликает.
[17:20.320 --> 17:22.320]  Все, теперь не будет пиликать.
[17:24.320 --> 17:26.320]  А, тогда получается, что мы допускаем,
[17:26.320 --> 17:28.320]  что i++, вот справа,
[17:28.320 --> 17:30.320]  он может работать как-то
[17:30.320 --> 17:32.320]  необычно. Да, может.
[17:32.320 --> 17:34.320]  Викле-инкремент был, он может работать необычно.
[17:34.320 --> 17:36.320]  Зачем это
[17:36.320 --> 17:38.320]  требовать, чтобы это вообще было?
[17:38.320 --> 17:40.320]  А есть стандартные типы, у которых они
[17:40.320 --> 17:42.320]  работают необычно.
[17:44.320 --> 17:46.320]  А как ты ее в концепте
[17:46.320 --> 17:48.320]  напишешь?
[17:48.320 --> 17:50.320]  Требования есть, сейчас они будут.
[17:50.320 --> 17:52.320]  Секунду, вот перед тем, как требования
[17:52.320 --> 17:54.320]  перейти, заметьте, что
[17:54.320 --> 17:56.320]  слово wikli, мы помним,
[17:56.320 --> 17:58.320]  что оно значит, да?
[17:58.320 --> 18:00.320]  Что-что?
[18:00.320 --> 18:02.320]  Да.
[18:02.320 --> 18:04.320]  Про equality preservation.
[18:04.320 --> 18:06.320]  Про то, что
[18:06.320 --> 18:08.320]  выражения сохраняют равенство.
[18:08.320 --> 18:10.320]  Любое wikli сразу выражение
[18:10.320 --> 18:12.320]  не сохраняет равенство. И вот
[18:12.320 --> 18:14.320]  операторы i++ тут не требуется, чтобы они
[18:14.320 --> 18:16.320]  сохраняли равенство. Почему?
[18:16.320 --> 18:18.320]  И вот к этому
[18:18.320 --> 18:20.320]  вопросу тоже. Почему
[18:20.320 --> 18:22.320]  вот здесь ничего не требуется и почему настолько
[18:22.320 --> 18:24.320]  слабый его концепт вообще нужен?
[18:24.320 --> 18:26.320]  Может, таких типов не бывает, настолько слабых
[18:26.320 --> 18:28.320]  и зачем нам это все?
[18:28.320 --> 18:30.320]  Вот есть в стандартной библиотеке тип, у которого
[18:30.320 --> 18:32.320]  вот эти вещи...
[18:32.320 --> 18:34.320]  Input итератор и Output итератор.
[18:34.320 --> 18:36.320]  Как мы здесь...
[18:36.320 --> 18:38.320]  Типа
[18:38.320 --> 18:40.320]  не знаю.
[18:40.320 --> 18:42.320]  Я не помню. Может Void?
[18:42.320 --> 18:44.320]  От Input итератора
[18:44.320 --> 18:46.320] ++ возвращает
[18:46.320 --> 18:48.320]  себя же, который префиксный.
[18:48.320 --> 18:50.320]  Префиксный? Да, постфиксный.
[18:50.320 --> 18:52.320]  Что у него?
[18:52.320 --> 18:54.320]  В Void или
[18:54.320 --> 18:56.320]  Bool? Ну вот, то есть это все сделано
[18:56.320 --> 18:58.320]  для того, чтобы Input и Output итератора
[18:58.320 --> 19:00.320]  поддерживать. И на этом
[19:00.320 --> 19:02.320]  интуиция, и конечно же equality preservation никакого
[19:02.320 --> 19:04.320]  не может быть, потому что
[19:04.320 --> 19:06.320]  мы уже много раз обсудили, что
[19:06.320 --> 19:08.320]  Input и Output итераторы
[19:08.320 --> 19:10.320]  equality не сохраняют, потому что
[19:10.320 --> 19:12.320]  с внешним миром взаимодействуют.
[19:12.320 --> 19:14.320]  Окей.
[19:14.320 --> 19:16.320]  Семантические требования.
[19:16.320 --> 19:18.320]  Тут внезапно
[19:18.320 --> 19:20.320]  вводится понятие incrementable.
[19:20.320 --> 19:22.320]  Ну вот вы могли подумать,
[19:22.320 --> 19:24.320]  что это как концепт incrementable, но концепт
[19:24.320 --> 19:26.320]  incrementable это другое.
[19:26.320 --> 19:28.320]  А это определение incrementable.
[19:28.320 --> 19:30.320]  Слова одни и те же, но
[19:30.320 --> 19:32.320]  смысл разный.
[19:32.320 --> 19:34.320]  Значит, говорят, что если у
[19:34.320 --> 19:36.320]  префиксного и постфиксного
[19:36.320 --> 19:38.320]  оператора incrementa одинаковый
[19:38.320 --> 19:40.320]  domain, то есть область определения,
[19:40.320 --> 19:42.320]  то есть либо
[19:42.320 --> 19:44.320]  одновременно оба определены,
[19:44.320 --> 19:46.320]  либо одновременно оба undefined behavior,
[19:46.320 --> 19:48.320]  то вот называем incrementable.
[19:48.320 --> 19:50.320]  Итак,
[19:50.320 --> 19:52.320]  требования. Во-первых,
[19:52.320 --> 19:54.320]  внезапно у них
[19:54.320 --> 19:56.320]  один и тот же domain.
[19:56.320 --> 19:58.320]  То есть, ну,
[19:58.320 --> 20:00.320]  странная формулировка уже, да, что
[20:00.320 --> 20:02.320]  типа... Во-первых,
[20:02.320 --> 20:04.320]  мы определяем, что incrementable, а потом
[20:04.320 --> 20:06.320]  говорим, что у них один и тот же domain,
[20:06.320 --> 20:08.320]  а потом говорим if
[20:08.320 --> 20:10.320]  incrementable.
[20:10.320 --> 20:12.320]  А, стоп.
[20:14.320 --> 20:16.320]  Я неправильно вам перевел, вы...
[20:16.320 --> 20:18.320]  Я вас обманул.
[20:18.320 --> 20:20.320]  Сейчас. Во-первых, да,
[20:20.320 --> 20:22.320]  вот это пока игнорируем. Во-первых,
[20:22.320 --> 20:24.320]  плюс-плюс, префиксный и постфиксный
[20:24.320 --> 20:26.320]  можно делать либо оба,
[20:26.320 --> 20:28.320]  либо не один из них. Вот
[20:28.320 --> 20:30.320]  domain — это область определения, для каких
[20:30.320 --> 20:32.320]  i маленьких эти операции определены,
[20:32.320 --> 20:34.320]  они там кидают исключения.
[20:34.320 --> 20:36.320]  Вот про это речь, да?
[20:36.320 --> 20:38.320]  Ну, одновременно они должны быть.
[20:38.320 --> 20:40.320]  То есть либо оба кинули бы
[20:40.320 --> 20:42.320]  исключения, либо оба нормально отработают.
[20:42.320 --> 20:44.320]  Да, а дальше говорят,
[20:44.320 --> 20:46.320]  что если i маленькое значение
[20:46.320 --> 20:48.320]  в этом самом домене лежит, то оно называется incrementable.
[20:48.320 --> 20:50.320]  Вот так вот.
[20:52.320 --> 20:54.320]  Если...
[20:56.320 --> 20:58.320]  Нет. Domain — это область определения,
[20:58.320 --> 21:00.320]  математическое понятие. Функция есть область
[21:00.320 --> 21:02.320]  определения, значение для которых функция
[21:02.320 --> 21:04.320]  определена, вне этой области она
[21:04.320 --> 21:06.320]  не определена.
[21:06.320 --> 21:08.320]  Вот. И называют incrementable, когда он лежит
[21:08.320 --> 21:10.320]  в области определения этих двух операторов.
[21:10.320 --> 21:12.320]  Вот.
[21:12.320 --> 21:14.320]  И для всех i маленьких, которые
[21:14.320 --> 21:16.320]  импровизируют incrementable,
[21:16.320 --> 21:18.320]  оба постфиксные
[21:18.320 --> 21:20.320]  интераты, инкременты
[21:20.320 --> 21:22.320]  должны продвигать и
[21:22.320 --> 21:24.320]  на следующий элемент.
[21:24.320 --> 21:26.320]  Ваши теории, что значит
[21:26.320 --> 21:28.320]  продвигать на следующий элемент?
[21:28.320 --> 21:30.320]  Что такое следующий элемент?
[21:38.320 --> 21:40.320]  Вот это вот S, вот это следующий.
[21:40.320 --> 21:42.320]  Ну, это...
[21:42.320 --> 21:44.320]  ...реализуют математическую идею
[21:44.320 --> 21:46.320]  вполне упорядоченных множеств,
[21:46.320 --> 21:48.320]  где на нас гарантируется наличие следующего
[21:48.320 --> 21:50.320]  элемента. Нет.
[21:50.320 --> 21:52.320]  В вполне упорядоченных множествах
[21:52.320 --> 21:54.320]  гарантируется наличие минимальных
[21:54.320 --> 21:56.320]  элементов. Если я еще что-то помню в этой
[21:56.320 --> 21:58.320]  жизни, правда ведь?
[21:58.320 --> 22:00.320]  Подтвердите кто-нибудь.
[22:00.320 --> 22:02.320]  В каждом множестве
[22:02.320 --> 22:04.320]  наименьшее.
[22:04.320 --> 22:06.320]  Вот. Вполне упорядоченное множество.
[22:06.320 --> 22:08.320]  Но тут не гарантирует вполне упорядоченность.
[22:12.320 --> 22:14.320]  Если у нас у каждого элемента есть следующий,
[22:14.320 --> 22:16.320]  но он кажется сложнее,
[22:16.320 --> 22:18.320]  тогда это будет...
[22:18.320 --> 22:20.320]  Ну, просто смотри,
[22:20.320 --> 22:22.320]  я что утверждаю, что
[22:22.320 --> 22:24.320]  для типов этого концепта,
[22:24.320 --> 22:26.320]  что такое следующий элемент, определяется
[22:26.320 --> 22:28.320]  как раз вот этими вот...
[22:28.320 --> 22:30.320]  вот этими вот операторами.
[22:30.320 --> 22:32.320]  А потом говорят,
[22:32.320 --> 22:34.320]  что эти операторы на самом деле...
[22:34.320 --> 22:36.320]  Зацикленное определение.
[22:36.320 --> 22:38.320]  Зацикленное определение, да.
[22:38.320 --> 22:40.320]  Я попытался в чат с крифеями
[22:40.320 --> 22:42.320]  плюсов задать этот вопрос. Там вообще не поняли
[22:42.320 --> 22:44.320]  про что я говорю, начали думать,
[22:44.320 --> 22:46.320]  что я дурак, и кидать ссылки на стандарт,
[22:46.320 --> 22:48.320]  вот, почитай. Ну,
[22:48.320 --> 22:50.320]  неудача произошла, к сожалению.
[22:50.320 --> 22:52.320]  Может быть, здесь просто имеется...
[22:52.320 --> 22:54.320]  Здесь имеется в виду, что
[22:56.320 --> 22:58.320]  если обратиться
[22:58.320 --> 23:00.320]  к оператору
[23:00.320 --> 23:02.320]  после поста
[23:02.320 --> 23:04.320]  и после крифи,
[23:04.320 --> 23:06.320]  то мы получим ссылку
[23:06.320 --> 23:08.320]  на...
[23:08.320 --> 23:10.320]  Возможно, именно это и хотели сказать.
[23:10.320 --> 23:12.320]  Тогда вопрос,
[23:12.320 --> 23:14.320]  а почему такая формулировка странная?
[23:18.320 --> 23:20.320]  To the same нельзя, потому что
[23:20.320 --> 23:22.320]  мы, во-первых, скопировать и маленькое не можем,
[23:22.320 --> 23:24.320]  и проверить это, а во-вторых,
[23:24.320 --> 23:26.320]  как бы increment он ломает, поэтому обратно
[23:26.320 --> 23:28.320]  откатить тоже не можем. Возможно,
[23:28.320 --> 23:30.320]  они пытаются выкрутиться из того, чтобы
[23:30.320 --> 23:32.320]  что, ну, типа, когда у вас
[23:32.320 --> 23:34.320]  вик и нету копируемости, то невозможно
[23:34.320 --> 23:36.320]  говорить о том, что вообще происходит,
[23:36.320 --> 23:38.320]  и вот... Сейчас они тут явно говорят,
[23:38.320 --> 23:40.320]  что plus plus i и
[23:40.320 --> 23:42.320]  i plus plus продвигает i
[23:42.320 --> 23:44.320]  на какой-то следующий элемент.
[23:44.320 --> 23:46.320]  То есть, на один.
[23:46.320 --> 23:48.320]  То есть, to the same точно есть.
[23:48.320 --> 23:50.320]  A booth
[23:50.320 --> 23:52.320]  продвигают на...
[23:52.320 --> 23:54.320]  Ну, нет,
[23:54.320 --> 23:56.320]  все равно непонятно.
[23:56.320 --> 23:58.320]  Ну, штуки при иной и красной
[23:58.320 --> 24:00.320]  свете...
[24:04.320 --> 24:06.320]  Ну, нет, observable штуки, да,
[24:06.320 --> 24:08.320]  их нету пока что.
[24:12.320 --> 24:14.320]  Вот непонятно.
[24:16.320 --> 24:18.320]  Мне вообще кажется, что это баг стандарта,
[24:18.320 --> 24:20.320]  и что вот таких размывчатых,
[24:20.320 --> 24:22.320]  расплывчатых формулировок быть не должно.
[24:22.320 --> 24:24.320]  То есть, возможно, здесь имеется как то,
[24:24.320 --> 24:26.320]  я про равенство вам рассказывал.
[24:26.320 --> 24:28.320]  Помните прекрасное заклинание?
[24:28.320 --> 24:30.320]  Если bool a равно равно b
[24:30.320 --> 24:32.320]  является true,
[24:32.320 --> 24:34.320]  то обязательно
[24:34.320 --> 24:36.320]  a равно b и наоборот.
[24:38.320 --> 24:40.320]  То есть, a равно b тогда и только тогда,
[24:40.320 --> 24:42.320]  когда a равно b.
[24:42.320 --> 24:44.320]  Помните это? Нет?
[24:44.320 --> 24:46.320]  Было такое. Ну, один человек помнит,
[24:46.320 --> 24:48.320]  остальные нет.
[24:48.320 --> 24:50.320]  Да.
[24:50.320 --> 24:52.320]  Там было вот так вот, что
[24:52.320 --> 24:56.320]  bool a равно равно b
[24:58.320 --> 25:00.320]  is true
[25:00.320 --> 25:02.320]  равно сильно
[25:02.320 --> 25:04.320]  a equals
[25:06.320 --> 25:08.320]  b.
[25:08.320 --> 25:10.320]  Вот это вот заклинание,
[25:10.320 --> 25:12.320]  что вот это true,
[25:12.320 --> 25:14.320]  тогда и только тогда, когда a равно b.
[25:14.320 --> 25:16.320]  В каком смысле справа слово equals употреблено
[25:16.320 --> 25:18.320]  в стандарте? Непонятно.
[25:18.320 --> 25:20.320]  Ну, я пришел к выводу, что
[25:20.320 --> 25:22.320]  мы сами решаем, что это значит.
[25:22.320 --> 25:24.320]  Это value equality.
[25:24.320 --> 25:26.320]  То есть, мы пишем тип, мы понимаем, что для него
[25:26.320 --> 25:28.320]  value, мы сами определяем равенство.
[25:36.320 --> 25:38.320]  Ну да, что у тебя есть оператор
[25:38.320 --> 25:40.320]  сравнения.
[25:40.320 --> 25:42.320]  Эквиваленс, может, ты хочешь сказать.
[25:42.320 --> 25:44.320]  Эквиваленс это совсем
[25:44.320 --> 25:46.320]  про другое.
[25:50.320 --> 25:52.320]  Да, наверное.
[25:52.320 --> 25:54.320]  И должно
[25:54.320 --> 25:56.320]  существовать какое-то абстрактное
[25:56.320 --> 25:58.320]  определение next element.
[25:58.320 --> 26:00.320]  И какое бы мы определение
[26:00.320 --> 26:02.320]  не выбрали,
[26:02.320 --> 26:04.320]  результат... Нет, нет, нет.
[26:04.320 --> 26:06.320]  Какое бы не выбрали.
[26:06.320 --> 26:08.320]  Какое бы мы не выбрали определение next element,
[26:08.320 --> 26:10.320]  у нас должно быть так, что
[26:10.320 --> 26:12.320]  и постфиксные, и префиксные
[26:12.320 --> 26:14.320]  переносят нас к одному и тому же next element.
[26:14.320 --> 26:16.320]  Я бы...
[26:16.320 --> 26:18.320]  Next нужно было заменить на same.
[26:18.320 --> 26:20.320]  Ну вот да, тут нигде нет
[26:20.320 --> 26:22.320]  подразумевания, что это same.
[26:22.320 --> 26:24.320]  То есть,
[26:24.320 --> 26:26.320]  формулировка ужасная.
[26:26.320 --> 26:28.320]  Я склонен считать, что
[26:28.320 --> 26:30.320]  тут и тут идея одинаковая.
[26:30.320 --> 26:32.320]  Вы сами садитесь писать тип,
[26:32.320 --> 26:34.320]  и вы понимаете, что для вашего типа value.
[26:34.320 --> 26:36.320]  Я надеюсь, кто-нибудь еще помнит,
[26:36.320 --> 26:38.320]  в чем разница между value и object representation.
[26:40.320 --> 26:42.320]  И полями. Все тут разные вещи.
[26:42.320 --> 26:44.320]  В value это ваше абстрактное в голове.
[26:44.320 --> 26:46.320]  Вы придумали value,
[26:46.320 --> 26:48.320]  вы должны в голове у себя понимать,
[26:48.320 --> 26:50.320]  что такое для этого value равенство.
[26:50.320 --> 26:52.320]  И вы должны закодить оператор сравнения,
[26:52.320 --> 26:54.320]  чтобы он был согласован с тем,
[26:54.320 --> 26:56.320]  что у вас в голове, с вашей интуицией.
[26:56.320 --> 26:58.320]  Тут то же самое подразумевают,
[26:58.320 --> 27:00.320]  что когда вы пишете
[27:00.320 --> 27:02.320]  weakly incrementable class, у вас в голове должно быть
[27:02.320 --> 27:04.320]  понимание, какую последовательность
[27:04.320 --> 27:06.320]  он как бы моделирует по факту,
[27:06.320 --> 27:08.320]  что вы хотите написать интуитивно
[27:08.320 --> 27:10.320]  или математически.
[27:10.320 --> 27:12.320]  И должно быть понимание, что там такое значит advance
[27:12.320 --> 27:14.320]  и что значит nextElement.
[27:14.320 --> 27:16.320]  И тогда ваши операторы++
[27:16.320 --> 27:18.320]  и только они должны именно
[27:18.320 --> 27:20.320]  делать то, что вы подразумеваете.
[27:20.320 --> 27:22.320]  То есть пытаются сказать вам,
[27:22.320 --> 27:24.320]  что не надо делать какую-нибудь
[27:24.320 --> 27:26.320]  функцию nextElement в оператор++
[27:26.320 --> 27:28.320]  пихать какую-то дичь, которая вообще
[27:28.320 --> 27:30.320]  не имеет отношения к делу.
[27:30.320 --> 27:32.320]  Что-то вот такое. Так же, как не надо в оператор
[27:32.320 --> 27:34.320]  сравнения писать какую-то дичь
[27:34.320 --> 27:36.320]  и потом отдельно делать метод isEqual.
[27:36.320 --> 27:40.320]  Вот nextElement как-то стыкуется с тем,
[27:40.320 --> 27:42.320]  что у нас профессионально может
[27:42.320 --> 27:44.320]  последовательность закончится или она не может здесь закончиться?
[27:44.320 --> 27:46.320]  Тут может
[27:46.320 --> 27:48.320]  не закончиться, вообще говоря.
[27:48.320 --> 27:50.320]  Но ничего ни с чем здесь не стыкуется, понимаешь?
[27:52.320 --> 27:54.320]  Я буду выяснять это дальше,
[27:54.320 --> 27:56.320]  наверное.
[27:56.320 --> 27:58.320]  У нас есть еще элементы?
[27:58.320 --> 28:00.320]  У нас есть еще элементы?
[28:00.320 --> 28:02.320]  А int не в домейне получается, да?
[28:02.320 --> 28:04.320]  Что?
[28:04.320 --> 28:06.320]  int он не в домейне,
[28:06.320 --> 28:08.320]  потому что++ до него нельзя сделать.
[28:08.320 --> 28:10.320]  int не в домейне.
[28:10.320 --> 28:12.320]  Ну да, кажется, что.
[28:12.320 --> 28:14.320]  Да, разумно.
[28:14.320 --> 28:16.320]  Ну да, да, да, да, да, да.
[28:16.320 --> 28:18.320]  То есть он исключение не кидает, конечно,
[28:18.320 --> 28:20.320]  но это все равно считается undefinedBehaviour,
[28:20.320 --> 28:22.320]  поэтому да, он не в домейне.
[28:22.320 --> 28:24.320]  Ну если там не зациклено какое-нибудь контейнер.
[28:24.320 --> 28:26.320]  Да, такие бывают.
[28:26.320 --> 28:28.320]  Но это ты уже сам можешь для своего контейнера
[28:28.320 --> 28:30.320]  определить, какой у твоих утераторов домейн.
[28:30.320 --> 28:32.320]  Вот у стандартных...
[28:32.320 --> 28:34.320]  В общем, странно выглядит, что int может быть
[28:34.320 --> 28:36.320]  в домейне, может не в домейне.
[28:36.320 --> 28:38.320]  Ну, тут же написано, что ты написал
[28:38.320 --> 28:40.320]  свои функции++.
[28:40.320 --> 28:42.320]  Чувствуется слово int в этом месте?
[28:42.320 --> 28:44.320]  Да, в этом месте пока еще нету
[28:44.320 --> 28:46.320]  ни бегины, ни энда, ни утераторов, ничего.
[28:46.320 --> 28:48.320]  Но теоретически вы сами
[28:48.320 --> 28:50.320]  определяете домен для ваших функций++.
[28:50.320 --> 28:52.320]  Вы сами написали.
[28:52.320 --> 28:54.320]  И как бы вот.
[28:54.320 --> 28:56.320]  Можно вам сказать, что дюйм был определен
[28:56.320 --> 28:58.320]  просто если выше size, то no off.
[28:58.320 --> 29:00.320]  Ну окей, да, можно.
[29:00.320 --> 29:02.320]  Получается вот как будто для
[29:02.320 --> 29:04.320]  итераторов, например, sender, что
[29:04.320 --> 29:06.320]  если бы прямо перед эндом,
[29:06.320 --> 29:08.320]  то nextElement это самый энд,
[29:08.320 --> 29:10.320]  а этот nextElement он уже не инкредентный был.
[29:10.320 --> 29:12.320]  Для него nextElement это нет.
[29:12.320 --> 29:14.320]  Ты сказал хотя бы хотя бы для контейнеров.
[29:14.320 --> 29:16.320]  Да, нет, внимание.
[29:16.320 --> 29:18.320]  Ну да, тут если мы указываем
[29:18.320 --> 29:20.320]  на последний элемент контейнера,
[29:20.320 --> 29:22.320]  ну и вот в этой ситуации у нас nextElement
[29:22.320 --> 29:24.320]  это как бы что?
[29:24.320 --> 29:26.320]  Это же конец контейнера.
[29:26.320 --> 29:28.320]  NextElement
[29:28.320 --> 29:30.320]  это не значение, на которое
[29:30.320 --> 29:32.320]  указывает итератор, это самый итератор.
[29:32.320 --> 29:34.320]  То есть энд это и будет nextElement.
[29:34.320 --> 29:36.320]  А вот для энда уже
[29:36.320 --> 29:38.320]  не определено
[29:38.320 --> 29:40.320]  эти операции, поэтому вне домейна,
[29:40.320 --> 29:42.320]  поэтому нет никакого nextElement.
[29:44.320 --> 29:46.320]  В общем, очень странно,
[29:46.320 --> 29:48.320]  но вот так вот сложилось,
[29:48.320 --> 29:50.320]  возможно когда-нибудь пофиксить это,
[29:50.320 --> 29:52.320]  поменяют, если кто-нибудь, может даже Яна
[29:52.320 --> 29:54.320]  пишет пейпер.
[29:54.320 --> 29:56.320]  Ну вряд ли, конечно.
[29:56.320 --> 29:58.320]  Так, и последнее.
[29:58.320 --> 30:00.320]  Вот это вот уже совсем понятно.
[30:00.320 --> 30:02.320]  Не понятно? Последнее.
[30:02.320 --> 30:04.320]  Совсем просто.
[30:04.320 --> 30:06.320]  Префиксный.
[30:06.320 --> 30:08.320]  Increment возвращает указатель на this,
[30:08.320 --> 30:10.320]  ну ссылку на this.
[30:10.320 --> 30:12.320]  Поэтому адрес того, что вернут нам,
[30:12.320 --> 30:14.320]  должен быть равен адресу i.
[30:14.320 --> 30:16.320]  Ну все, совсем тупо.
[30:18.320 --> 30:20.320]  Что, что? Я не понял сейчас.
[30:20.320 --> 30:22.320]  Так. Почему не postfixny?
[30:22.320 --> 30:24.320]  Postfixny возвращает старое значение
[30:24.320 --> 30:26.320]  итератора. Ну да.
[30:26.320 --> 30:28.320]  И? А плюс плюс и?
[30:28.320 --> 30:30.320]  Postfixny возвращает
[30:30.320 --> 30:32.320]  копию старого значения.
[30:32.320 --> 30:34.320]  Префиксный возвращает
[30:34.320 --> 30:36.320]  себя, то есть this.
[30:36.320 --> 30:38.320]  А, все. Да.
[30:38.320 --> 30:40.320]  Префиксный итератор,
[30:40.320 --> 30:42.320]  префиксный ингримент, это значит увеличь на единицу
[30:42.320 --> 30:44.320]  и верни, что получилось.
[30:44.320 --> 30:46.320]  Вот.
[30:46.320 --> 30:48.320]  Окей, все поняли, все поняли. Едем дальше.
[30:48.320 --> 30:50.320]  Дальше таких затыков не будет.
[30:50.320 --> 30:52.320]  А, у меня тут вот обведено было даже, но неважно.
[30:52.320 --> 30:54.320]  Да, про
[30:54.320 --> 30:56.320]  ип и вот это все мы сказали.
[30:58.320 --> 31:00.320]  Equality preservation.
[31:00.320 --> 31:02.320]  Не требуется, чтобы там как-то равенство
[31:02.320 --> 31:04.320]  сохранялось
[31:04.320 --> 31:06.320]  после и до инкремента.
[31:06.320 --> 31:08.320]  Про острый мы сказали, все прекрасно.
[31:08.320 --> 31:10.320]  Проговорили без слайдов. Бывает.
[31:10.320 --> 31:12.320]  А вот это концепт инкрементабл.
[31:12.320 --> 31:14.320]  Там было понятие инкрементабл,
[31:14.320 --> 31:16.320]  а теперь концепт инкрементабл.
[31:16.320 --> 31:18.320]  Никак не связанные вещи.
[31:20.320 --> 31:22.320]  Нет.
[31:22.320 --> 31:24.320]  Это понятие инкрементабл определялось для конкретного
[31:24.320 --> 31:26.320]  значения типа И.
[31:26.320 --> 31:28.320]  Вот это вот шняга, да?
[31:28.320 --> 31:30.320]  А вот этот концепт
[31:30.320 --> 31:32.320]  он для типов определяется.
[31:32.320 --> 31:34.320]  Ну, о.
[31:34.320 --> 31:36.320]  Ну, что-то написано,
[31:36.320 --> 31:38.320]  что он еще и копируемый, да и вообще регулярный,
[31:38.320 --> 31:40.320]  да.
[31:40.320 --> 31:42.320]  Wecl incrementable, плюс теперь уже ЕП требуется,
[31:42.320 --> 31:44.320]  потому что больше не Wecl.
[31:44.320 --> 31:46.320]  И уже
[31:46.320 --> 31:48.320]  нормальные условия на postfix,
[31:48.320 --> 31:50.320]  на increment, да.
[31:50.320 --> 31:52.320]  Ну, то есть всего этого стоило ожидать.
[31:52.320 --> 31:54.320]  Wecl incrementable
[31:54.320 --> 31:56.320]  нужен для вот этих ребят.
[31:56.320 --> 31:58.320]  Поэтому тут куча требований отпилена.
[31:58.320 --> 32:00.320]  Equality preservation отпилен, вот здесь ничего не требуется,
[32:00.320 --> 32:02.320]  да.
[32:02.320 --> 32:04.320]  А incrementable нужен для всего остального.
[32:04.320 --> 32:06.320]  Здесь же мы нормально можем написать,
[32:06.320 --> 32:08.320]  что И++ вернет
[32:08.320 --> 32:10.320]  другое значение типа И.
[32:10.320 --> 32:12.320]  Ну, и там дальше
[32:12.320 --> 32:14.320]  будет сказано, какое значение.
[32:14.320 --> 32:16.320]  Ну, и копируемость тоже требовать надо.
[32:16.320 --> 32:18.320]  Потому что...
[32:18.320 --> 32:20.320]  И равенство тоже требуется.
[32:20.320 --> 32:22.320]  И равенство требуется.
[32:22.320 --> 32:24.320]  А то этого мы не требуем, то есть input иterator на равенство мы не требуем.
[32:24.320 --> 32:26.320]  Да.
[32:26.320 --> 32:28.320]  Сейчас определяем какие-то подложения
[32:28.320 --> 32:30.320]  для этих итераторов, да? Да, такие базовые
[32:30.320 --> 32:32.320]  building блоки, из которых потом построятся
[32:32.320 --> 32:34.320]  концепты новые для
[32:34.320 --> 32:36.320]  input итераторов,
[32:36.320 --> 32:38.320]  output итераторов,
[32:38.320 --> 32:40.320]  support, bidirectional и так далее.
[32:40.320 --> 32:42.320]  То есть вот все
[32:42.320 --> 32:44.320]  named requirements, которые я в самом начале
[32:44.320 --> 32:46.320]  показал, они превратились в концепты,
[32:46.320 --> 32:48.320]  но сложные концепты. И нам сейчас нужно вот снизу
[32:48.320 --> 32:50.320]  вверх пройтись по буквально
[32:50.320 --> 32:52.320]  четырем или пяти концептам, чтобы дойти
[32:52.320 --> 32:54.320]  до них. Может больше.
[32:54.320 --> 32:56.320]  Окей.
[32:56.320 --> 32:58.320]  Ну, то есть сейчас интуитивно должно быть понятно, что вот эту шнягу
[32:58.320 --> 33:00.320]  мы потребуем в input итераторе
[33:00.320 --> 33:02.320]  и в output итераторе, а вот эту во всех остальных.
[33:04.320 --> 33:06.320]  Окей.
[33:06.320 --> 33:08.320]  И театрические требования на нее
[33:08.320 --> 33:10.320]  уже понятные. То есть ну тут буквально
[33:10.320 --> 33:12.320]  equality preservation написан.
[33:12.320 --> 33:14.320]  Как бы.
[33:14.320 --> 33:16.320]  А что значит implies? Подразумевает.
[33:18.320 --> 33:20.320]  То есть если у нас было a равно b,
[33:20.320 --> 33:22.320]  то postfix на increment вернет
[33:22.320 --> 33:24.320]  то же самое старое значение.
[33:24.320 --> 33:26.320]  То же самое, которое было раньше.
[33:28.320 --> 33:30.320]  Ну, в техе
[33:30.320 --> 33:32.320]  сложно значок следствия написать,
[33:32.320 --> 33:34.320]  там надо вспоминать буквы.
[33:34.320 --> 33:36.320]  Вот, если...
[33:36.320 --> 33:38.320]  Да.
[33:38.320 --> 33:40.320]  Если a было равно b,
[33:40.320 --> 33:42.320]  то заклинание.
[33:42.320 --> 33:44.320]  Понятно кому-нибудь это заклинание?
[33:44.320 --> 33:46.320]  Да.
[33:46.320 --> 33:48.320]  Да.
[33:48.320 --> 33:50.320]  Да, это...
[33:50.320 --> 33:52.320]  Вот так не надо писать код.
[33:52.320 --> 33:54.320]  Это оператор запятая,
[33:54.320 --> 33:56.320]  каст к Вайду
[33:56.320 --> 33:58.320]  не знаю.
[33:58.320 --> 34:00.320]  А, если...
[34:00.320 --> 34:02.320]  Нет, нет, нет, я знаю зачем.
[34:02.320 --> 34:04.320]  Тут нигде не ограничено,
[34:04.320 --> 34:06.320]  что нельзя написать атрибут
[34:06.320 --> 34:08.320]  node-discard.
[34:08.320 --> 34:10.320]  Да, окей.
[34:10.320 --> 34:12.320]  A++, окей.
[34:12.320 --> 34:14.320]  Если каст к Вайду, чтобы заигнорить
[34:14.320 --> 34:16.320]  node-discard и записать.
[34:16.320 --> 34:18.320]  Можно еще раз объяснить?
[34:18.320 --> 34:20.320]  Знаешь, что такое node-discard?
[34:20.320 --> 34:22.320]  Короче можно...
[34:22.320 --> 34:24.320]  Аркадий, давай я буду объяснять, потому что
[34:24.320 --> 34:26.320]  у меня микрофон и то, что ты говоришь, не будет
[34:26.320 --> 34:28.320]  на записи слышно, и
[34:28.320 --> 34:30.320]  нужно подумать о наших коллегах, которые
[34:30.320 --> 34:32.320]  не ходят на пары.
[34:32.320 --> 34:34.320]  Да, атрибут node-discard,
[34:34.320 --> 34:36.320]  его можно повесить на функцию,
[34:36.320 --> 34:38.320]  которая возвращает что-то кроме Вайда,
[34:38.320 --> 34:40.320]  и тогда компилятор будет тебе писать ошибку,
[34:40.320 --> 34:42.320]  если ты возвращенное значение
[34:42.320 --> 34:44.320]  не использовал как-то.
[34:44.320 --> 34:46.320]  Ну, то есть, а-ля
[34:46.320 --> 34:48.320]  ты написал вот этот вот A++,
[34:48.320 --> 34:50.320]  оно тебе вернуло значение, а ты просто точку
[34:50.320 --> 34:52.320]  с запятой после этого написал и никуда его не запомнил,
[34:52.320 --> 34:54.320]  не пихнул. Например,
[34:54.320 --> 34:56.320]  в цикле 4.
[34:56.320 --> 34:58.320]  Вот последним этим написал A++,
[34:58.320 --> 35:00.320]  возвращенное значение не использовал.
[35:00.320 --> 35:02.320]  Вот если бы node-discard висел
[35:02.320 --> 35:04.320]  на операторе A++,
[35:04.320 --> 35:06.320]  то тебе выдали бы ошибку.
[35:06.320 --> 35:08.320]  Чтобы эту ошибку подавить, можно сделать
[35:08.320 --> 35:10.320]  вот так. Прикастить к Вайду.
[35:10.320 --> 35:12.320]  Это подавление ворнинга.
[35:12.320 --> 35:14.320]  Значит, что мы с ним что-то делаем и...
[35:14.320 --> 35:16.320]  Ну, как бы что-то, но на самом деле ничего.
[35:16.320 --> 35:18.320]  То есть, такой странный
[35:18.320 --> 35:20.320]  синтаксис в плюсах используется, чтобы...
[35:20.320 --> 35:22.320]  Вроде, в ингейде
[35:22.320 --> 35:24.320]  в некоторых местах вот ставил
[35:24.320 --> 35:26.320]  что-то типа
[35:26.320 --> 35:28.320]  Ну, может быть.
[35:30.320 --> 35:32.320]  Оператор запятая,
[35:32.320 --> 35:34.320]  вычисляет... Сначала левое
[35:34.320 --> 35:36.320]  вычисляет, потом вычисляет правое
[35:36.320 --> 35:38.320]  и возвращает правое.
[35:38.320 --> 35:40.320]  Вот.
[35:44.320 --> 35:46.320]  Чё?
[35:48.320 --> 35:50.320]  Да.
[35:50.320 --> 35:52.320]  Да, да.
[35:52.320 --> 35:54.320]  Именно так. Поэтому тут, видимо,
[35:54.320 --> 35:56.320]  для этого. Ну, что тут написано?
[35:56.320 --> 35:58.320]  Что если мы сначала сделаем
[35:58.320 --> 36:00.320]  постфиксный инкремент для A,
[36:00.320 --> 36:02.320]  а потом сравним A с
[36:02.320 --> 36:04.320]  A++B, префиксным,
[36:04.320 --> 36:06.320]  то будет одно и то же.
[36:06.320 --> 36:08.320]  Ну, то есть, после постфиксного инкремента
[36:08.320 --> 36:10.320]  увеличится точно так же,
[36:10.320 --> 36:12.320]  как после префиксного.
[36:12.320 --> 36:14.320]  Вот очень сложный
[36:14.320 --> 36:16.320]  способ сказать вот эту мысль.
[36:18.320 --> 36:20.320]  Можно было на двух разных строчках написать,
[36:20.320 --> 36:22.320]  что если мы сделаем сначала
[36:22.320 --> 36:24.320]  A++, то
[36:24.320 --> 36:26.320]  A будет равно
[36:26.320 --> 36:28.320] ++B, если при этом
[36:28.320 --> 36:30.320]  A и B изначально были равны.
[36:30.320 --> 36:32.320]  Всё, ничего интеллектуального, но написано, как всегда,
[36:32.320 --> 36:34.320]  через пятую точку.
[36:34.320 --> 36:36.320]  Давайте двигаться дальше.
[36:36.320 --> 36:38.320]  Наконец-то мы определяем свой первый
[36:38.320 --> 36:40.320]  итератор. Это будет прям вот
[36:40.320 --> 36:42.320]  the итератор. Вот
[36:42.320 --> 36:44.320]  теперь просто слово
[36:44.320 --> 36:46.320]  итератор в коде
[36:46.320 --> 36:48.320]  заменяется на вот этот концепт.
[36:48.320 --> 36:50.320]  Всё, что ему
[36:50.320 --> 36:52.320]  подходит, является итератором. Всё, что не подходит,
[36:52.320 --> 36:54.320]  не является.
[36:54.320 --> 36:56.320]  Ну, и тут требования очень тупые.
[36:56.320 --> 36:58.320]  WicleIncrementable и можно
[36:58.320 --> 37:00.320]  звёздочку навесить,
[37:00.320 --> 37:02.320]  и получится некоторый
[37:02.320 --> 37:04.320]  тип, очень
[37:04.320 --> 37:06.320]  хитрый. Ну, сейчас...
[37:06.320 --> 37:08.320]  Нет, это всё, что написано
[37:08.320 --> 37:10.320]  какими-то через тире, странные,
[37:10.320 --> 37:12.320]  красным текстом или комментарием,
[37:12.320 --> 37:14.320]  или вот italics, ну, наклонным
[37:14.320 --> 37:16.320]  текстом, это как бы концепт,
[37:16.320 --> 37:18.320]  но которого нет в стандарте.
[37:18.320 --> 37:20.320]  То есть, который чисто нужен, чтобы
[37:20.320 --> 37:22.320]  сформулировать, что происходит.
[37:22.320 --> 37:24.320]  Вот, и тут вот
[37:24.320 --> 37:26.320]  так выглядит этот концепт,
[37:26.320 --> 37:28.320]  вообще говоря. То есть, тип,
[37:28.320 --> 37:30.320]  на который можно навесить амперсант,
[37:30.320 --> 37:32.320]  то есть ссылку, и получить тоже нормальный
[37:32.320 --> 37:34.320]  тип. На что нельзя навесить амперсант?
[37:34.320 --> 37:36.320]  На Void.
[37:36.320 --> 37:38.320]  Ну, ещё на что-то, наверное, нельзя.
[37:38.320 --> 37:40.320]  Ну, нам неважно.
[37:40.320 --> 37:42.320]  На incomplete, как раз-то можно.
[37:42.320 --> 37:44.320]  Наоборот,
[37:44.320 --> 37:46.320]  это смысл incomplete-тайтов.
[37:46.320 --> 37:48.320]  Вот. То есть, вам должно
[37:48.320 --> 37:50.320]  вернуться что-то, на что можно навесить ссылку.
[37:50.320 --> 37:52.320]  Не Void.
[37:52.320 --> 37:54.320]  Кроме не Void,
[37:54.320 --> 37:56.320]  ну, не помню, по-моему, нет таких.
[37:56.320 --> 37:58.320]  Ну, в общем, для всех ваших типов всё пройдёт и нормально.
[37:58.320 --> 38:00.320]  Главное, Void не возвращайте.
[38:00.320 --> 38:02.320]  Окей.
[38:02.320 --> 38:04.320]  Input и Output-этератор.
[38:04.320 --> 38:06.320]  Простой как пробка, самый общий.
[38:06.320 --> 38:08.320]  Ничего не требуется, кроме плюс-плюса,
[38:08.320 --> 38:10.320]  который что-то делает,
[38:10.320 --> 38:12.320]  вообще непонятно чё. И звёздочки,
[38:12.320 --> 38:14.320]  которые тоже непонятно чё делают.
[38:14.320 --> 38:16.320]  Вот. А чтобы дальше
[38:16.320 --> 38:18.320]  что-то хоть чуть-чуть понятно
[38:18.320 --> 38:20.320]  стало про то, что все эти
[38:20.320 --> 38:22.320]  операции должны делать, нам нужны ещё
[38:22.320 --> 38:24.320]  два вот таких смешных определения.
[38:24.320 --> 38:26.320]  Да.
[38:26.320 --> 38:28.320]  Да.
[38:28.320 --> 38:30.320]  Where the incrementable, кроме
[38:30.320 --> 38:32.320]  Input и Output-этератора где-то используется?
[38:36.320 --> 38:38.320]  Не помню. Скорее всего, где-то есть.
[38:40.320 --> 38:42.320]  Надо посмотреть.
[38:44.320 --> 38:46.320]  Ну,
[38:46.320 --> 38:48.320]  в одном месте точно есть increment,
[38:48.320 --> 38:50.320]  а нет. Wicle, наверное.
[38:50.320 --> 38:52.320]  Да, используется, в самом конце у нас будет.
[38:52.320 --> 38:54.320]  Ну, если мне память не изменяет,
[38:54.320 --> 38:56.320]  может там просто incrementable написан.
[38:56.320 --> 38:58.320]  Хотя ничто не должно мешать Wicle,
[38:58.320 --> 39:00.320]  поэтому... Окей.
[39:00.320 --> 39:02.320]  Два
[39:02.320 --> 39:04.320]  новых концепта, которые тут даже без определения,
[39:04.320 --> 39:06.320]  а просто так интуитивно.
[39:06.320 --> 39:08.320]  Потому что там слишком сложное определение
[39:08.320 --> 39:10.320]  и, ну,
[39:10.320 --> 39:12.320]  дебри. Indirectly readable
[39:12.320 --> 39:14.320]  Indirectly writable. И это на самом деле
[39:14.320 --> 39:16.320]  целое такое. Семейство,
[39:16.320 --> 39:18.320]  целое семейство концептов,
[39:18.320 --> 39:20.320]  как вот есть концепты со словом Wicle,
[39:20.320 --> 39:22.320]  это значит, что там и Quality Preservation
[39:22.320 --> 39:24.320]  выкинут. Слово indirectly
[39:24.320 --> 39:26.320]  значит, что после разыменования
[39:26.320 --> 39:28.320]  итератора.
[39:28.320 --> 39:30.320]  То есть что-то можно сделать
[39:30.320 --> 39:32.320]  с тем, что вам вернёт итератор после разыменования.
[39:32.320 --> 39:34.320]  Или указатель.
[39:34.320 --> 39:36.320]  Или там smart pointer.
[39:36.320 --> 39:38.320]  То есть это очень общий класс.
[39:38.320 --> 39:40.320]  Ну, и значит, что вот
[39:40.320 --> 39:42.320]  то, что звёздочка возвращает оператор.
[39:42.320 --> 39:44.320]  С ним можно сделать что-то.
[39:44.320 --> 39:46.320]  И вот indirectly readable I
[39:46.320 --> 39:48.320]  значит, что существует
[39:48.320 --> 39:50.320]  некоторый тип T,
[39:50.320 --> 39:52.320]  что можно как бы прочитать
[39:52.320 --> 39:54.320]  из вот этого типа такую
[39:54.320 --> 39:56.320]  T путём разыменования.
[39:56.320 --> 39:58.320]  То есть, в принципе, все indirectly
[39:58.320 --> 40:00.320]  они описывают похожесть на указатель
[40:00.320 --> 40:02.320]  чем-то.
[40:02.320 --> 40:04.320]  Вот readable похож на указатель тем,
[40:04.320 --> 40:06.320]  что можно прочитать. То есть
[40:06.320 --> 40:08.320]  написать справа от знака равенства.
[40:08.320 --> 40:10.320]  Да, да, да.
[40:10.320 --> 40:12.320]  И то же самое indirectly writable.
[40:12.320 --> 40:14.320]  Ну, следите
[40:14.320 --> 40:16.320]  за T.
[40:16.320 --> 40:18.320]  T здесь нет, а тут есть.
[40:18.320 --> 40:20.320]  Поэтому тут квантера, здесь его нет.
[40:20.320 --> 40:22.320]  То есть тут мы не знаем,
[40:22.320 --> 40:24.320]  какой T прочитаем.
[40:24.320 --> 40:26.320]  А здесь мы точно знаем, что
[40:26.320 --> 40:28.320]  writable в смысле можно записать
[40:28.320 --> 40:30.320]  вот такой конкретно T, а не
[40:30.320 --> 40:32.320]  любой.
[40:32.320 --> 40:34.320]  Ну, как бы да, тут
[40:34.320 --> 40:36.320]  тоже формулировка такая, но по сути
[40:36.320 --> 40:38.320]  должно скомпилироваться
[40:38.320 --> 40:40.320]  звёздочка I равно T.
[40:44.320 --> 40:46.320]  Ну, окей, здесь можно ли вот этот концепт
[40:46.320 --> 40:48.320]  сформулировать, если ты не знаешь,
[40:48.320 --> 40:50.320]  какой T собрался записать?
[40:54.320 --> 40:56.320]  Ну, если бы вот его здесь явно
[40:56.320 --> 40:58.320]  не написали, получится какой-то такой концепт
[40:58.320 --> 41:00.320]  написать?
[41:00.320 --> 41:02.320]  Не получится.
[41:02.320 --> 41:04.320]  Потому что ты в концепте должен...
[41:04.320 --> 41:06.320]  Ты хочешь написать выражение, а звёздочка I
[41:06.320 --> 41:08.320]  равно что?
[41:08.320 --> 41:10.320]  Что ты туда записываешь?
[41:10.320 --> 41:12.320]  Вот непонятно.
[41:16.320 --> 41:18.320]  Ну, а считываю я всегда понятно.
[41:18.320 --> 41:20.320]  Да, потому что ты можешь взять деколтай
[41:20.320 --> 41:22.320]  под звёздочка I.
[41:28.320 --> 41:30.320]  Да, да.
[41:30.320 --> 41:32.320]  Да, у звёздочка I нету никаких перегрузок.
[41:32.320 --> 41:34.320]  Это один конкретный оператор всегда.
[41:34.320 --> 41:36.320]  Поэтому ты точно знаешь, какой тип тебе
[41:36.320 --> 41:38.320]  вернут. А вот оператор присваивания,
[41:38.320 --> 41:40.320]  который вы вызовете после того, как
[41:40.320 --> 41:42.320]  разыменуете, у него могут быть
[41:42.320 --> 41:44.320]  перегрузки. И вы не знаете, какой из этих
[41:44.320 --> 41:46.320]  перегрузок взять. Поэтому здесь необходимо
[41:46.320 --> 41:48.320]  указать T конкретный.
[41:48.320 --> 41:50.320]  Вот один человек понял, кажется,
[41:50.320 --> 41:52.320]  наверное, даже два или три.
[41:52.320 --> 41:54.320]  Но это такая мелочь. Давайте
[41:54.320 --> 41:56.320]  пойдём дальше. Ну, и да, если
[41:56.320 --> 41:58.320]  вы пытаетесь посмотреть внутрь, да?
[41:58.320 --> 42:00.320]  Кажется, что можно сделать
[42:00.320 --> 42:02.320]  более частный,
[42:02.320 --> 42:04.320]  когда
[42:04.320 --> 42:06.320]  indirectly readable, который уже с T.
[42:06.320 --> 42:08.320]  Можно. Он, наверное,
[42:08.320 --> 42:10.320]  есть даже в стандарте, но не знаю.
[42:12.320 --> 42:14.320]  Ну, ты можешь сделать indirectly readable
[42:14.320 --> 42:16.320]  плюс звёздочка I, same,
[42:16.320 --> 42:18.320]  st, вот что-нибудь такое.
[42:20.320 --> 42:22.320]  Ну, да, потому что у тебя
[42:22.320 --> 42:24.320]  есть
[42:24.320 --> 42:26.320]  объект типа I,
[42:26.320 --> 42:28.320]  и маленькая, ты можешь оператор звёздочка
[42:28.320 --> 42:30.320]  к нему применить. У него не бывает
[42:30.320 --> 42:32.320]  перегрузок, потому что оператор звёздочка нет
[42:32.320 --> 42:34.320]  аргументов, кроме самого I.
[42:34.320 --> 42:36.320]  Ну, у тебя вернётся один конкретный тип.
[42:36.320 --> 42:38.320]  Вариантов нет.
[42:38.320 --> 42:40.320]  И ты этот тип точно знаешь.
[42:40.320 --> 42:42.320]  И вот этот вот квантор, он как раз про него.
[42:42.320 --> 42:44.320]  Ну, то есть
[42:44.320 --> 42:46.320]  я так упрощённо объясняю,
[42:46.320 --> 42:48.320]  если вы реально полезете смотреть, там
[42:48.320 --> 42:50.320]  опять вот столько буков,
[42:50.320 --> 42:52.320]  и очень сложно, но мораль
[42:52.320 --> 42:54.320]  понятна. И это за нас кто-то выяснил, как
[42:54.320 --> 42:56.320]  нормально сформулировать.
[42:56.320 --> 42:58.320]  И как только у вас интуитивное понимание есть,
[42:58.320 --> 43:00.320]  в своих алгоритмах можете это использовать,
[43:00.320 --> 43:02.320]  если когда-то понадобится.
[43:02.320 --> 43:04.320]  Но на самом деле они используются, как
[43:04.320 --> 43:06.320]  несложно догадаться, в input и
[43:06.320 --> 43:08.320]  output итераторах.
[43:08.320 --> 43:10.320]  То есть вот был раньше input
[43:10.320 --> 43:12.320]  or output итератор, это и то
[43:12.320 --> 43:14.320]  и другое. А теперь
[43:14.320 --> 43:16.320]  мы уточняем до input итератора.
[43:16.320 --> 43:18.320]  Это input or output итератор,
[43:18.320 --> 43:20.320]  который при этом indirectly readable,
[43:22.320 --> 43:24.320]  определён некоторый
[43:24.320 --> 43:26.320]  iter-concept,
[43:26.320 --> 43:28.320]  и вот этот iter-concept наследуется
[43:28.320 --> 43:30.320]  от input итератора тега.
[43:30.320 --> 43:32.320]  Сложно, да?
[43:32.320 --> 43:34.320]  Indirectly readable, indirectly write,
[43:34.320 --> 43:36.320]  вполне формализованные концепты. Да-да-да,
[43:36.320 --> 43:38.320]  это прям настоящие концепты, можно
[43:38.320 --> 43:40.320]  preference открыть, если интересно.
[43:40.320 --> 43:42.320]  Ну, во-первых,
[43:42.320 --> 43:44.320]  вопрос к вам смешной,
[43:44.320 --> 43:46.320]  который я раньше забыл задать.
[43:46.320 --> 43:48.320]  Что если вот эту вот строчку
[43:48.320 --> 43:50.320]  с type-name iter-concept
[43:50.320 --> 43:52.320]  зачеркнуть, убрать отсюда?
[43:52.320 --> 43:54.320]  Изменится ли что-то в этом концепте?
[43:56.320 --> 43:58.320]  Ошибка может быть
[43:58.320 --> 44:00.320]  некрасивая, по-моему. Ошибки
[44:00.320 --> 44:02.320]  будут некрасивые. Ну да,
[44:02.320 --> 44:04.320]  именно так. А ещё?
[44:04.320 --> 44:06.320]  Здесь он
[44:06.320 --> 44:08.320]  инстанцирует
[44:08.320 --> 44:10.320]  по правилам, что, допустим, наследники там
[44:10.320 --> 44:12.320]  корректные. Так, а тут тоже инстанцируют.
[44:12.320 --> 44:14.320]  Я говорю, вот одну строчку, где requires type-name
[44:14.320 --> 44:16.320]  вот эту зачеркнуть,
[44:16.320 --> 44:18.320]  остальную оставить.
[44:18.320 --> 44:20.320]  Type-name
[44:20.320 --> 44:22.320]  слот.
[44:22.320 --> 44:24.320]  Ну а зачем?
[44:26.320 --> 44:28.320]  Ну, на самом деле
[44:28.320 --> 44:30.320]  правильный ответ уже сказали, но
[44:30.320 --> 44:32.320]  не уверена.
[44:32.320 --> 44:34.320]  Действительно, никакой разницы с точки зрения
[44:34.320 --> 44:36.320]  семантики языка не будет.
[44:36.320 --> 44:38.320]  Потому что по дефолту, если вы
[44:38.320 --> 44:40.320]  какой-то тип написали, где-то внутри
[44:40.320 --> 44:42.320]  концепта, то концепт
[44:42.320 --> 44:44.320]  будет false, если этот тип не валидный.
[44:44.320 --> 44:46.320]  Всё. То есть ошибки компиляции
[44:46.320 --> 44:48.320]  вы не получите, даже если вот эту строчку уберёте.
[44:48.320 --> 44:50.320]  Может ещё вызвать специализация,
[44:50.320 --> 44:52.320]  когда вы используете концепт и тератор,
[44:52.320 --> 44:54.320]  есть какой-нибудь другой концепт, который
[44:54.320 --> 44:56.320]  имеет вероятность ровно, но имеет и интерконцепт.
[44:56.320 --> 44:58.320]  И тогда, чтобы
[44:58.320 --> 45:00.320]  он выбирался как-то более часто в случае...
[45:00.320 --> 45:02.320]  Нет, нет, нет. Я говорю, с точки зрения
[45:02.320 --> 45:04.320]  механики языка ничего не изменится.
[45:04.320 --> 45:06.320]  Просто вы будете получать более
[45:06.320 --> 45:08.320]  понятные ошибки.
[45:08.320 --> 45:10.320]  Потому что, ну вернее,
[45:10.320 --> 45:12.320]  когда вы напишете
[45:12.320 --> 45:14.320]  статик, ассорт,
[45:14.320 --> 45:16.320]  input и тератор от чего-то
[45:16.320 --> 45:18.320]  равно true, вот в этот момент
[45:18.320 --> 45:20.320]  вы получите более понятную ошибку,
[45:20.320 --> 45:22.320]  если написать так.
[45:22.320 --> 45:24.320]  Что вам скажут сразу, у вас итерконцепт не нашёлся.
[45:24.320 --> 45:26.320]  Я объясню это почему. Если написать вот так,
[45:26.320 --> 45:28.320]  вам скажут, не получилось
[45:28.320 --> 45:30.320]  распарсить что-то там,
[45:30.320 --> 45:32.320]  потому что мы не знаем,
[45:32.320 --> 45:34.320]  это шаблон или не шаблон. Короче, ошибка плохая
[45:34.320 --> 45:36.320]  будет. Вот и всё.
[45:38.320 --> 45:40.320]  Вот, а теперь по делу. А что это
[45:40.320 --> 45:42.320]  за итерконцепт такой, input и тератор
[45:42.320 --> 45:44.320]  теги, зачем это всё?
[45:44.320 --> 45:46.320]  Ну, итерконцепт
[45:46.320 --> 45:48.320]  это нечто похожее
[45:48.320 --> 45:50.320]  на итератор категории.
[45:50.320 --> 45:52.320]  Помните такую?
[45:52.320 --> 45:54.320]  Вам точно про неё рассказывали
[45:54.320 --> 45:56.320]  когда-то давно. Но это
[45:56.320 --> 45:58.320]  легко вылетающая
[45:58.320 --> 46:00.320]  из головы информация.
[46:00.320 --> 46:02.320]  Но суть тут в чём?
[46:02.320 --> 46:04.320]  Есть теги, соответствующие
[46:04.320 --> 46:06.320]  каждой категории итераторов.
[46:06.320 --> 46:08.320]  Есть input итератор тег,
[46:08.320 --> 46:10.320]  есть output итератор тег,
[46:10.320 --> 46:12.320]  есть там random access
[46:12.320 --> 46:14.320]  итератор тег, и для всех
[46:14.320 --> 46:16.320]  видов, которые вы помните, они есть.
[46:18.320 --> 46:20.320]  И внезапно, внезапно,
[46:20.320 --> 46:22.320]  чтобы стать input итератором,
[46:22.320 --> 46:24.320]  вам нужно хотя бы
[46:24.320 --> 46:26.320]  явно прописать где-то,
[46:26.320 --> 46:28.320]  что ваш тип
[46:28.320 --> 46:30.320]  является input итератором,
[46:30.320 --> 46:32.320]  и вот где-то нужно вписать input итератор
[46:32.320 --> 46:34.320]  тег. А вот этот итерконцепт
[46:34.320 --> 46:36.320]  это просто способ найти,
[46:36.320 --> 46:38.320]  куда вы там вписали этот тег,
[46:38.320 --> 46:40.320]  что у вас всё нормально.
[46:40.320 --> 46:42.320]  Ну и draft втором тут почему?
[46:42.320 --> 46:44.320]  Мы такой трюк уже видели.
[46:46.320 --> 46:48.320]  Потому что очень часто
[46:48.320 --> 46:50.320]  что-то можно написать. Да,
[46:50.320 --> 46:52.320]  потому что, например, random access итератор тег
[46:52.320 --> 46:54.320]  он наследуется от
[46:54.320 --> 46:56.320]  input итератор тега.
[46:56.320 --> 46:58.320]  Там такое дерево наследования у них.
[46:58.320 --> 47:00.320]  А где этот
[47:00.320 --> 47:02.320]  итератор концепт находит этот тег?
[47:02.320 --> 47:04.320]  Ну, итератор trades.
[47:04.320 --> 47:06.320]  Уже видим.
[47:06.320 --> 47:08.320]  И внезапно он сначала смотрит в итератор концепта,
[47:08.320 --> 47:10.320]  а потом в итератор категории.
[47:10.320 --> 47:12.320]  Почему переименовали итератор
[47:12.320 --> 47:14.320]  категории, который был раньше,
[47:14.320 --> 47:16.320]  в итератор концепт?
[47:16.320 --> 47:18.320]  Идеи?
[47:22.320 --> 47:24.320]  Там порядок выставляется
[47:24.320 --> 47:26.320]  между концептами?
[47:26.320 --> 47:28.320]  И раньше, по-моему, был.
[47:28.320 --> 47:30.320]  Ну, я вначале
[47:30.320 --> 47:32.320]  чуть-чуть об этом сказал, когда про legacy
[47:32.320 --> 47:34.320]  named requirements и говорил.
[47:34.320 --> 47:36.320]  А, сейчас, ещё раз.
[47:36.320 --> 47:38.320]  Вот тут есть итератор концепт,
[47:38.320 --> 47:40.320]  мы сначала сюда идём, потом идём
[47:40.320 --> 47:42.320]  в итератор категории.
[47:42.320 --> 47:44.320]  Итератор категории это очень старое.
[47:44.320 --> 47:46.320]  Да.
[47:46.320 --> 47:48.320]  Да, старое.
[47:48.320 --> 47:50.320]  Да, вот.
[47:50.320 --> 47:52.320]  В этом суть.
[47:52.320 --> 47:54.320]  С named requirements у нас
[47:54.320 --> 47:56.320]  чуть-чуть поменялась семантика.
[47:56.320 --> 47:58.320]  Вот миллиметр.
[47:58.320 --> 48:00.320]  Большинство пользователей это не затронет.
[48:00.320 --> 48:02.320]  Но для тех, кого это затронет,
[48:02.320 --> 48:04.320]  возможно, у них внезапно
[48:04.320 --> 48:06.320]  их итераторы перестанут удовлетворять
[48:06.320 --> 48:08.320]  какой-то категории.
[48:08.320 --> 48:10.320]  Например, перестанут bidirectional быть
[48:10.320 --> 48:12.320]  или вообще input итераторами перестанут быть.
[48:12.320 --> 48:14.320]  И вот, чтобы у них
[48:14.320 --> 48:16.320]  не ломались стандартные алгоритмы,
[48:16.320 --> 48:18.320]  которые теперь полагаются на эти новые
[48:18.320 --> 48:20.320]  требования,
[48:20.320 --> 48:22.320]  им дали возможность явно
[48:22.320 --> 48:24.320]  типа переписать вот эту вот старую...
[48:24.320 --> 48:26.320]  Ну, во-первых, разделили их, да, старая категория
[48:26.320 --> 48:28.320]  и новая, чтобы
[48:28.320 --> 48:30.320]  и старые алгоритмы работали, и новые.
[48:30.320 --> 48:32.320]  Во-вторых, дали возможность разно их поставить.
[48:34.320 --> 48:36.320]  Да.
[48:36.320 --> 48:38.320]  Если вы пишете свежий код на C++20,
[48:38.320 --> 48:40.320]  итератор категории вам не нужен.
[48:40.320 --> 48:42.320]  Вам нужен итератор концепт.
[48:42.320 --> 48:44.320]  Вот.
[48:44.320 --> 48:46.320]  И оно идет туда, идет сюда.
[48:46.320 --> 48:48.320]  А если ничего не подошло,
[48:48.320 --> 48:50.320]  то, кажется, идет в random access
[48:50.320 --> 48:52.320]  итератор тег внезапно.
[48:52.320 --> 48:54.320]  И то и другое,
[48:54.320 --> 48:56.320]  там должно лежать
[48:56.320 --> 48:58.320]  значение типа
[48:58.320 --> 49:00.320]  input итератор тег
[49:00.320 --> 49:02.320]  или output итератор тег.
[49:02.320 --> 49:04.320]  Это просто типа.
[49:04.320 --> 49:06.320]  Структурки пустые.
[49:06.320 --> 49:08.320]  А раньше же были...
[49:08.320 --> 49:10.320]  А сейчас.
[49:10.320 --> 49:12.320]  Так, еще раз.
[49:12.320 --> 49:14.320]  Семантика
[49:14.320 --> 49:16.320]  вот этих категорий итераторов
[49:16.320 --> 49:18.320]  немножко поменялась.
[49:18.320 --> 49:20.320]  Чуть-чуть.
[49:20.320 --> 49:22.320]  Но, если быть честным, то старые
[49:22.320 --> 49:24.320]  алгоритмы, они полагались на старую
[49:24.320 --> 49:26.320]  семантику и использовали итератор категории.
[49:26.320 --> 49:28.320]  Новый алгоритм будет полагаться
[49:28.320 --> 49:30.320]  на новую семантику.
[49:30.320 --> 49:32.320]  Нельзя переиспользовать старый
[49:32.320 --> 49:34.320]  type def итератор категории.
[49:36.320 --> 49:38.320]  А теги те же, получается?
[49:38.320 --> 49:40.320]  Теги те же.
[49:40.320 --> 49:42.320]  Нет, это абсолютно нормально.
[49:42.320 --> 49:44.320]  Теги те же, но в другом месте
[49:44.320 --> 49:46.320]  написано для старых алгоритмов
[49:46.320 --> 49:48.320]  и для новых. Ну, вот так вот.
[49:52.320 --> 49:54.320]  Нет, все старые алгоритмы
[49:54.320 --> 49:56.320]  используют итератор категории.
[49:56.320 --> 49:58.320]  Все, что в алгоритм хедрил лежит,
[49:58.320 --> 50:00.320]  используют итератор категории, как и раньше.
[50:00.320 --> 50:02.320]  Новые алгоритмы лежат в хедри-ранжес,
[50:02.320 --> 50:04.320]  и они используют вот в таком порядке.
[50:04.320 --> 50:06.320]  Просто как будто
[50:06.320 --> 50:08.320]  переименовали поле, и все.
[50:08.320 --> 50:10.320]  Да.
[50:10.320 --> 50:12.320]  Нет, потому что нельзя переиспользовать
[50:12.320 --> 50:14.320]  старое поле. Оно для того,
[50:14.320 --> 50:16.320]  чтобы лего сжило, должно остаться
[50:16.320 --> 50:18.320]  и не измениться.
[50:18.320 --> 50:20.320]  Там просто теперь разные деления на...
[50:20.320 --> 50:22.320]  Да, чуть-чуть другое.
[50:22.320 --> 50:24.320]  Теперь, если
[50:24.320 --> 50:26.320]  для какой-то итератора раньше был
[50:26.320 --> 50:28.320]  иностранный процесс,
[50:28.320 --> 50:30.320]  он будет перелететь в рейтинг-дирекцию.
[50:30.320 --> 50:32.320]  Да.
[50:32.320 --> 50:34.320]  Или перестал быть итератором.
[50:34.320 --> 50:36.320]  Что?
[50:36.320 --> 50:38.320]  Смотри, если ты внимательно...
[50:38.320 --> 50:40.320]  Внимательно пос...
[50:40.320 --> 50:42.320]  Да, equality preservation какой-нибудь,
[50:42.320 --> 50:44.320]  или еще что-нибудь такое, да?
[50:44.320 --> 50:46.320]  То есть, если ты внимательно посмотришь на
[50:46.320 --> 50:48.320]  named requirements
[50:48.320 --> 50:50.320]  для разных итераторов
[50:50.320 --> 50:52.320]  и на новые концепты, и сравнишь их,
[50:52.320 --> 50:54.320]  то ты поймешь, в каких случаях оно ломается,
[50:54.320 --> 50:56.320]  долго, муторно и не нужно.
[50:56.320 --> 50:58.320]  Ужесточили требования, получается?
[50:58.320 --> 51:00.320]  Да.
[51:00.320 --> 51:02.320]  Уточнили их.
[51:02.320 --> 51:04.320]  То есть, если ты хочешь,
[51:04.320 --> 51:06.320]  чтобы у вас не работало на старых версиях,
[51:06.320 --> 51:08.320]  пишем концепт.
[51:08.320 --> 51:10.320]  Итератор, концепт.
[51:10.320 --> 51:12.320]  Кажется, да.
[51:14.320 --> 51:16.320]  Не уверен, кстати.
[51:16.320 --> 51:18.320]  Может, они и в хедре-алгоритм
[51:18.320 --> 51:20.320]  тоже закостыляли,
[51:20.320 --> 51:22.320]  чтобы оно умело и с новыми работать
[51:22.320 --> 51:24.320]  и как-то в compile-тайме понимало,
[51:24.320 --> 51:26.320]  это legacy итератор или новый итератор
[51:26.320 --> 51:28.320]  за счет этого.
[51:28.320 --> 51:30.320]  Надо посмотреть. Ну, в общем, вот такая судьба.
[51:30.320 --> 51:32.320]  Предполагаем, что у вас нет legacy.
[51:32.320 --> 51:34.320]  Если есть, то для вас кастыль есть,
[51:34.320 --> 51:36.320]  вы внимательно подсчитайте цп референс,
[51:36.320 --> 51:38.320]  там написано, или стандарт.
[51:38.320 --> 51:40.320]  Если у вас legacy нет, то вы пишите итер концепт
[51:40.320 --> 51:42.320]  и радуйтесь жизни. Проблем нету.
[51:42.320 --> 51:44.320]  Да, и внимание, по дефолту
[51:44.320 --> 51:46.320]  будет random access итератор tag.
[51:46.320 --> 51:48.320]  То есть, любая шняга, которая
[51:48.320 --> 51:50.320]  всему этому удовлетворяет, она по дефолту
[51:50.320 --> 51:52.320]  будет внезапно.
[51:52.320 --> 51:54.320]  Почему такой узкий?
[51:54.320 --> 51:56.320]  Какой-то общий, по-дефолту?
[51:56.320 --> 51:58.320]  Самый общий?
[51:58.320 --> 52:00.320]  Нет, общий — это самый частый,
[52:00.320 --> 52:02.320]  который у тебя в коде встречается.
[52:02.320 --> 52:04.320]  Самый частый итератор в коде —
[52:04.320 --> 52:06.320]  это random access.
[52:06.320 --> 52:08.320]  Я могу забыть и забыть написать,
[52:08.320 --> 52:10.320]  и у меня вот это, типа, сделается.
[52:10.320 --> 52:12.320]  Ну да.
[52:12.320 --> 52:14.320]  Короче, сейчас про это поговорим еще.
[52:14.320 --> 52:16.320]  Почему тут такой дефолт
[52:16.320 --> 52:18.320]  и почему такие теги?
[52:18.320 --> 52:20.320]  Там как раз вот здесь
[52:20.320 --> 52:22.320]  где-то кроется очень важная мысль
[52:22.320 --> 52:24.320]  про дизайн, но пока мы
[52:24.320 --> 52:26.320]  до нее не дошли.
[52:26.320 --> 52:28.320]  Согласились, что вот input иterатор есть,
[52:28.320 --> 52:30.320]  все хорошо. Вот теги наши прекрасные.
[52:30.320 --> 52:32.320]  Input иterатор tag,
[52:32.320 --> 52:34.320]  output иterатор tag, вот forward
[52:34.320 --> 52:36.320]  наследует
[52:36.320 --> 52:38.320]  только input иterатор
[52:38.320 --> 52:40.320]  tag внезапно.
[52:40.320 --> 52:42.320]  Почему, кстати, непонятно.
[52:42.320 --> 52:44.320]  Надо же output иterатор
[52:44.320 --> 52:46.320]  tag, наверное,
[52:46.320 --> 52:48.320]  следовать, а тут только input.
[52:52.320 --> 52:54.320]  Что? Ну нет, forward иterатор является
[52:54.320 --> 52:56.320]  input и output иterатором, правда?
[52:56.320 --> 52:58.320]  Ну так, идеино, концептуально.
[52:58.320 --> 53:00.320]  А почему нет?
[53:04.320 --> 53:06.320]  Ну как бы...
[53:06.320 --> 53:08.320]  Нет.
[53:12.320 --> 53:14.320]  Нет, input и output иterатор
[53:14.320 --> 53:16.320]  принципиально разный. В один ток
[53:16.320 --> 53:18.320]  писать, в другой ток читать, да?
[53:18.320 --> 53:20.320]  Один с консоли читает,
[53:20.320 --> 53:22.320]  другой в консоль пишет. В обратную сторону
[53:22.320 --> 53:24.320]  их как бы нельзя. А вот любой forward иterатор
[53:24.320 --> 53:26.320]  он же и то, и другое имеет. Это вот прям уже
[53:26.320 --> 53:28.320]  нормальный итератор. По списку, например,
[53:28.320 --> 53:30.320]  бегайте, forward-листу, связанный
[53:30.320 --> 53:32.320]  список, да? Идете вперед, можете
[53:32.320 --> 53:34.320]  писать, можете читать. Чего хотите делать?
[53:34.320 --> 53:36.320]  Почему не наследуется output иterатор
[53:36.320 --> 53:38.320]  tag? Непонятно.
[53:38.320 --> 53:40.320]  Потом дойдем.
[53:40.320 --> 53:42.320]  Bidirectional, random access, contiguous.
[53:42.320 --> 53:44.320]  Ну, эти категории вам знакомы, да?
[53:44.320 --> 53:46.320]  Вы понимаете.
[53:46.320 --> 53:48.320]  А тут никто не наследуется. Внезапно.
[53:48.320 --> 53:50.320]  Да, contiguous,
[53:50.320 --> 53:52.320]  по-моему, новая категория. Слышали
[53:52.320 --> 53:54.320]  про нее раньше? Нет? Была?
[53:54.320 --> 53:56.320]  Все, окей.
[53:58.320 --> 54:00.320]  Окей, это хорошо.
[54:02.320 --> 54:04.320]  Да, тут подчеркнуто. Ну раз
[54:04.320 --> 54:06.320]  изучали, то окей. Никому не надо проговорить.
[54:06.320 --> 54:08.320]  Окей.
[54:08.320 --> 54:10.320]  Окей. Random access
[54:10.320 --> 54:12.320]  Сказалось бы, что еще можно хотеть, кроме
[54:12.320 --> 54:14.320]  random access? Вот вы в любое место прыгаете,
[54:14.320 --> 54:16.320]  зовут единицы, все двигается, все хорошо.
[54:16.320 --> 54:18.320]  Contiguous добавляет дополнительное
[54:18.320 --> 54:20.320]  требование, что все элементы в памяти
[54:20.320 --> 54:22.320]  расположены подряд.
[54:22.320 --> 54:24.320]  То есть contiguous итератор — это
[54:24.320 --> 54:26.320]  обертка над указателем и только
[54:26.320 --> 54:28.320]  она. И ничего больше.
[54:28.320 --> 54:30.320]  Ну, какой есть контейнер, у которого
[54:30.320 --> 54:32.320]  итераторы random access, но не contiguous?
[54:32.320 --> 54:34.320]  Deck.
[54:34.320 --> 54:36.320]  Deck — это набор блоков памяти.
[54:36.320 --> 54:38.320]  В каждом из блоков двигаться
[54:38.320 --> 54:40.320]  можно, ну, типа, просто
[54:40.320 --> 54:42.320]  передвигая указатель.
[54:42.320 --> 54:44.320]  А вот следующий блок перепрыгнуть — там уже что-то надо
[54:44.320 --> 54:46.320]  сложное делать. Поэтому вот он...
[54:46.320 --> 54:48.320]  Что?
[54:48.320 --> 54:50.320]  Кто?
[54:54.320 --> 54:56.320]  Ну да.
[54:56.320 --> 54:58.320]  Подряд виртуальные памяти лежат.
[55:00.320 --> 55:02.320]  Что? Нет, вообще не думаем
[55:02.320 --> 55:04.320]  про страницы.
[55:04.320 --> 55:06.320]  Виртуальная память
[55:06.320 --> 55:08.320]  машины C++ абстрактной —
[55:08.320 --> 55:10.320]  это последовательность байт подряд
[55:10.320 --> 55:12.320]  идущая. Ничего больше.
[55:12.320 --> 55:14.320]  Никаких страниц не существует для языка
[55:14.320 --> 55:16.320]  C++. Как только они у вас
[55:16.320 --> 55:18.320]  существуют, вы уже, как бы, на уровень ниже
[55:18.320 --> 55:20.320]  смотрите под язык C++.
[55:22.320 --> 55:24.320]  Наверное, было предложение,
[55:24.320 --> 55:26.320]  что у дека каждый кусок размером
[55:26.320 --> 55:28.320]  со страницы, поэтому эффективно
[55:28.320 --> 55:30.320]  получается, что он, как бы, contiguous.
[55:30.320 --> 55:32.320]  Нет. Ну, contiguous нужен,
[55:32.320 --> 55:34.320]  чтобы мем-копии использовать.
[55:34.320 --> 55:36.320]  Для итераторов на дек вы не можете
[55:36.320 --> 55:38.320]  использовать мем-копии.
[55:38.320 --> 55:40.320]  Да, да, да.
[55:40.320 --> 55:42.320]  То есть STD array и STD vector — у них contiguous.
[55:42.320 --> 55:44.320]  Вы можете мем-копии копировать всякую
[55:44.320 --> 55:46.320]  шнягу по итераторам.
[55:46.320 --> 55:48.320]  Тут можно было по-другому
[55:48.320 --> 55:50.320]  сформулировать не contiguous, а
[55:50.320 --> 55:52.320]  mem-copiable. Имеется в виду именно это.
[55:52.320 --> 55:54.320]  Окей.
[55:54.320 --> 55:56.320]  Output итератор.
[55:56.320 --> 55:58.320]  На него посмотрим.
[55:58.320 --> 56:00.320]  On input or output. Он
[56:00.320 --> 56:02.320]  indirectly writable.
[56:02.320 --> 56:04.320]  Ожидаемо.
[56:04.320 --> 56:06.320]  И требуется, чтобы вот такая
[56:06.320 --> 56:08.320]  шняга компилировалась.
[56:08.320 --> 56:10.320]  Ну, вот ровно это присвоение. Что разминовали,
[56:10.320 --> 56:12.320]  присвоили. Причем можно
[56:12.320 --> 56:14.320]  par-value ссылки, можно pl-value.
[56:14.320 --> 56:16.320]  И equality-preservation не потребовали
[56:16.320 --> 56:18.320]  при этом.
[56:18.320 --> 56:20.320]  Да, помним, по дефолту все выражения
[56:20.320 --> 56:22.320]  в стандартных концептах требуют
[56:22.320 --> 56:24.320]  equality-preservation. Если не сказано обратного,
[56:24.320 --> 56:26.320]  тут сказано.
[56:26.320 --> 56:28.320]  Чего не хватает?
[56:28.320 --> 56:30.320]  Ой.
[56:40.320 --> 56:42.320]  Дико извиняюсь
[56:42.320 --> 56:44.320]  перед человеком, который будет это
[56:44.320 --> 56:46.320]  монтировать, или теми, кто слушает на запися.
[56:46.320 --> 56:48.320]  Ну, надеюсь, на монтаже вырежут,
[56:48.320 --> 56:50.320]  и страдать будет монтажер.
[56:52.320 --> 56:54.320]  Но вопрос-то ответьте мне.
[56:54.320 --> 56:56.320]  Чего не хватает здесь?
[56:56.320 --> 56:58.320]  Только что смотрели на input
[56:58.320 --> 57:00.320]  operator, да?
[57:00.320 --> 57:02.320]  Тут примерно то же самое было.
[57:02.320 --> 57:04.320]  Ну, мы там разминование уже потребовали, да?
[57:04.320 --> 57:06.320]  А вот, типа, ставим random access
[57:06.320 --> 57:08.320]  stack, а он самый
[57:08.320 --> 57:10.320]  derived, если
[57:10.320 --> 57:12.320]  здесь...
[57:12.320 --> 57:14.320]  Нет, что?
[57:14.320 --> 57:16.320]  Ну, вот, просто чисто на концепт смотрите.
[57:16.320 --> 57:18.320]  Input
[57:18.320 --> 57:20.320]  or output, indirectly
[57:20.320 --> 57:22.320]  readable. Ну, и все.
[57:22.320 --> 57:24.320]  Input or output, indirectly readable.
[57:24.320 --> 57:26.320]  И что-то еще, но...
[57:26.320 --> 57:28.320]  тега нету.
[57:28.320 --> 57:30.320]  Тега не требуется. Output
[57:30.320 --> 57:32.320]  тег здесь не используется.
[57:32.320 --> 57:34.320]  Да!
[57:34.320 --> 57:36.320]  Да! Внезапно!
[57:36.320 --> 57:38.320]  Еще, output-утератор от двух шаблонных
[57:38.320 --> 57:40.320]  параметров. Он хочет
[57:40.320 --> 57:42.320]  сразу знать, что мы туда можем outputить.
[57:42.320 --> 57:44.320]  И тега output-утератор не
[57:44.320 --> 57:46.320]  требует.
[57:46.320 --> 57:48.320]  Ну, казалось бы...
[57:50.320 --> 57:52.320]  Когда тебе нечего больше
[57:52.320 --> 57:54.320]  написать, от безысходности ты можешь его написать.
[57:54.320 --> 57:56.320]  Но это тебе
[57:56.320 --> 57:58.320]  никак не поможет.
[58:02.320 --> 58:04.320]  Нет, смотри.
[58:04.320 --> 58:06.320]  Random access дефолтный возникает тогда,
[58:06.320 --> 58:08.320]  когда ты, в принципе,
[58:08.320 --> 58:10.320]  пытаешься понять, какой концепт
[58:10.320 --> 58:12.320]  у итератора.
[58:12.320 --> 58:14.320]  Вот эта вот категория. Чего?
[58:14.320 --> 58:16.320]  А тут мы даже понять
[58:16.320 --> 58:18.320]  не пытаемся. Ничего не пытаемся понять.
[58:18.320 --> 58:20.320]  Мы не пытаемся найти никакой тег,
[58:20.320 --> 58:22.320]  мы пытаемся его сравнить с output-утератор
[58:22.320 --> 58:24.320]  тегом.
[58:24.320 --> 58:26.320]  Загадочная вещь.
[58:26.320 --> 58:28.320]  Вот меня это тоже в ступор
[58:28.320 --> 58:30.320]  поставило, когда я наткнулся.
[58:30.320 --> 58:32.320]  Надеюсь, вы сейчас не заснули
[58:32.320 --> 58:34.320]  и действительно в ступоре.
[58:34.320 --> 58:36.320]  Правда?
[58:36.320 --> 58:38.320]  Давайте окно откроем, а можете
[58:38.320 --> 58:40.320]  вот, ребят, там как-то чутка
[58:40.320 --> 58:42.320]  пора.
[58:46.320 --> 58:48.320]  Сейчас как-то морозит.
[58:50.320 --> 58:52.320]  Да нет, нифига.
[58:52.320 --> 58:54.320]  Спится хорошо, когда
[58:54.320 --> 58:56.320]  душно.
[58:56.320 --> 58:58.320]  Сейчас очень душно.
[58:58.320 --> 59:00.320]  И дальше будет душнее.
[59:00.320 --> 59:02.320]  Итак,
[59:02.320 --> 59:04.320]  поговорим с вами про апгрейды
[59:04.320 --> 59:06.320]  итераторов в алгоритмах
[59:06.320 --> 59:08.320]  стандартной библиотеки и не только.
[59:08.320 --> 59:10.320]  Вот это вот как раз очень важное
[59:10.320 --> 59:12.320]  наблюдение про
[59:12.320 --> 59:14.320]  generic design и то, как писать
[59:14.320 --> 59:16.320]  хорошие обобщенные библиотеки.
[59:16.320 --> 59:18.320]  Если вы
[59:18.320 --> 59:20.320]  успехаете в алгоритм стандартный,
[59:22.320 --> 59:24.320]  который требует некоторого уровня
[59:24.320 --> 59:26.320]  итераторов,
[59:26.320 --> 59:28.320]  то есть constraint написан и требуется
[59:28.320 --> 59:30.320]  random access итератор или
[59:30.320 --> 59:32.320]  forward итератор,
[59:32.320 --> 59:34.320]  вы гарантируете
[59:34.320 --> 59:36.320]  не кто-то там, а именно вы
[59:36.320 --> 59:38.320]  компилятору и всему миру, что
[59:38.320 --> 59:40.320]  либо тип этого объекта
[59:40.320 --> 59:42.320]  не удовлетворяет
[59:42.320 --> 59:44.320]  концепту полностью,
[59:44.320 --> 59:46.320]  именно концепту,
[59:46.320 --> 59:48.320]  то есть если вы спросите концепт
[59:48.320 --> 59:50.320]  true или false, он вернет false,
[59:50.320 --> 59:52.320]  либо что тип моделирует концепт.
[59:52.320 --> 59:54.320]  Помните слово
[59:54.320 --> 59:56.320]  моделирует?
[59:56.320 --> 59:58.320]  Семантические требования.
[59:58.320 --> 01:00:00.320]  То есть вы должны
[01:00:00.320 --> 01:00:02.320]  гарантировать, когда зовете
[01:00:02.320 --> 01:00:04.320]  любой алгоритм стандартной библиотеки,
[01:00:04.320 --> 01:00:06.320]  что не возникнет такой ситуации,
[01:00:06.320 --> 01:00:08.320]  что концепт сработал ложно-положительно,
[01:00:08.320 --> 01:00:10.320]  что
[01:00:10.320 --> 01:00:12.320]  семантические требования не выполнены,
[01:00:12.320 --> 01:00:14.320]  а концепт по синтаксису
[01:00:14.320 --> 01:00:16.320]  говорит, что да, мне подходит,
[01:00:16.320 --> 01:00:18.320]  я готов над этим работать.
[01:00:22.320 --> 01:00:24.320]  Ну, короче, мы не обманываем концепт.
[01:00:24.320 --> 01:00:26.320]  Что? Да.
[01:00:26.320 --> 01:00:28.320]  Да, мы гарантируем, что мы
[01:00:28.320 --> 01:00:30.320]  не обманываем концепты синтаксисом.
[01:00:32.320 --> 01:00:34.320]  Ну, как бы,
[01:00:34.320 --> 01:00:36.320]  понятное дело, что другого выхода
[01:00:36.320 --> 01:00:38.320]  нет в принципе, кроме как вот это вот потребовать.
[01:00:38.320 --> 01:00:40.320]  И вот это вот неявное требование всей
[01:00:40.320 --> 01:00:42.320]  стандартной библиотеки, не только про итераторы,
[01:00:42.320 --> 01:00:44.320]  а вообще про все алгоритмы,
[01:00:44.320 --> 01:00:46.320]  все концепты и все алгоритмы стандартной библиотеки.
[01:00:48.320 --> 01:00:50.320]  А дальше идет некоторая рекомендация
[01:00:50.320 --> 01:00:52.320]  или принцип дизайна.
[01:00:52.320 --> 01:00:54.320]  Для любых двух концептов,
[01:00:54.320 --> 01:00:56.320]  где из одного следует другой,
[01:00:56.320 --> 01:00:58.320]  а мы только что их видели,
[01:00:58.320 --> 01:01:00.320]  ну, окей, пока не видели,
[01:01:00.320 --> 01:01:02.320]  но считаем, что видели.
[01:01:02.320 --> 01:01:04.320]  Из концепта contiguous следует
[01:01:04.320 --> 01:01:06.320]  очевидно random access. Из random access
[01:01:06.320 --> 01:01:08.320]  следует forward. Из forward
[01:01:08.320 --> 01:01:10.320]  следует output и input.
[01:01:10.320 --> 01:01:12.320]  В любых таких ситуациях,
[01:01:12.320 --> 01:01:14.320]  когда вы уточняете концепты,
[01:01:14.320 --> 01:01:16.320]  требуете что-то предыдущее,
[01:01:16.320 --> 01:01:18.320]  есть импликация, и вот если это есть,
[01:01:18.320 --> 01:01:20.320]  то чтобы вот это вот свойство,
[01:01:20.320 --> 01:01:22.320]  вот этот принцип гарантировать,
[01:01:24.320 --> 01:01:26.320]  от нас
[01:01:26.320 --> 01:01:28.320]  нам рекомендуют
[01:01:28.320 --> 01:01:30.320]  либо давать возможность явно отписываться
[01:01:30.320 --> 01:01:32.320]  от концепта A,
[01:01:32.320 --> 01:01:34.320]  либо явно вписываться
[01:01:34.320 --> 01:01:36.320]  в A.
[01:01:36.320 --> 01:01:38.320]  Ничего не понятно, да?
[01:01:38.320 --> 01:01:40.320]  А как у нас будет
[01:01:40.320 --> 01:01:42.320]  из forward следовать output?
[01:01:42.320 --> 01:01:44.320]  Что?
[01:01:44.320 --> 01:01:46.320]  Из forward будет следовать output,
[01:01:46.320 --> 01:01:48.320]  мы потом пониже увидим.
[01:01:48.320 --> 01:01:50.320]  Просто это вот так вот работает.
[01:01:52.320 --> 01:01:54.320]  А как мы давим возможность явно отписываться?
[01:01:54.320 --> 01:01:56.320]  Через трейты какие-то.
[01:01:56.320 --> 01:01:58.320]  Ну, сделайте там
[01:01:58.320 --> 01:02:00.320]  для своего концепта трейты,
[01:02:00.320 --> 01:02:02.320]  где там флажок bool или какие-то
[01:02:02.320 --> 01:02:04.320]  теги тоже, которые позволяют
[01:02:04.320 --> 01:02:06.320]  типу, который
[01:02:06.320 --> 01:02:08.320]  подходит под A синтаксически,
[01:02:08.320 --> 01:02:10.320]  но не подходит под него семантически,
[01:02:10.320 --> 01:02:12.320]  выписаться из A.
[01:02:12.320 --> 01:02:14.320]  Ну, то есть ситуация вот такая вот.
[01:02:14.320 --> 01:02:16.320]  Надо, наверное, сюда смотреть в самый низ.
[01:02:16.320 --> 01:02:18.320]  Представим себе алгоритм, который принимает что-то
[01:02:18.320 --> 01:02:20.320]  концепта B.
[01:02:20.320 --> 01:02:22.320]  И он
[01:02:22.320 --> 01:02:24.320]  внутри может пытаться апгрейдить
[01:02:24.320 --> 01:02:26.320]  эту вот штуку концепта B
[01:02:26.320 --> 01:02:28.320]  до чего-то концепта A.
[01:02:28.320 --> 01:02:30.320]  Зачем?
[01:02:30.320 --> 01:02:32.320]  Ну, зачем алгоритму внутри пытаться посмотреть,
[01:02:32.320 --> 01:02:34.320]  а не удовлетворяет ли
[01:02:34.320 --> 01:02:36.320]  еще какому-то концепту
[01:02:36.320 --> 01:02:38.320]  то, что нам дали?
[01:02:38.320 --> 01:02:40.320]  Да, вот STD копия.
[01:02:40.320 --> 01:02:42.320]  По дефолту STD копия принимает
[01:02:42.320 --> 01:02:44.320]  forward iterator. И как оно копирует?
[01:02:44.320 --> 01:02:46.320]  Ну, просто
[01:02:46.320 --> 01:02:48.320]  по очереди идет в цикле.
[01:02:48.320 --> 01:02:50.320]  Инкрементит и копирует.
[01:02:50.320 --> 01:02:52.320]  Но если вам дали contiguous iterator,
[01:02:52.320 --> 01:02:54.320]  можно
[01:02:54.320 --> 01:02:56.320]  Memcopy бахнуть.
[01:02:56.320 --> 01:02:58.320]  Да,
[01:02:58.320 --> 01:03:00.320]  и вам дали contiguous iterator.
[01:03:00.320 --> 01:03:02.320]  Вы можете бахнуть Memcopy.
[01:03:02.320 --> 01:03:04.320]  Копия будет быстрее.
[01:03:04.320 --> 01:03:06.320]  Внутри STD копии написано
[01:03:06.320 --> 01:03:08.320]  if constexpr,
[01:03:08.320 --> 01:03:10.320]  contiguous iterator
[01:03:10.320 --> 01:03:12.320]  и tip.
[01:03:12.320 --> 01:03:14.320]  Так вот, может так чисто случайно
[01:03:14.320 --> 01:03:16.320]  получиться, что ваш
[01:03:16.320 --> 01:03:18.320]  forward iterator
[01:03:18.320 --> 01:03:20.320]  по синтаксическим требованиям
[01:03:20.320 --> 01:03:22.320]  удовлетворяет
[01:03:22.320 --> 01:03:24.320]  contiguous.
[01:03:24.320 --> 01:03:26.320]  Потому что в принципе
[01:03:26.320 --> 01:03:28.320]  то, что iterator contiguous невозможно
[01:03:28.320 --> 01:03:30.320]  проверить как-то синтаксисом.
[01:03:30.320 --> 01:03:32.320]  Да, это в голове у нас.
[01:03:32.320 --> 01:03:34.320]  То есть с точки зрения
[01:03:34.320 --> 01:03:36.320]  языка, если бы мы без всяких
[01:03:36.320 --> 01:03:38.320]  этих тегов писали, у вас бы
[01:03:38.320 --> 01:03:40.320]  концепт contiguous и random access
[01:03:40.320 --> 01:03:42.320]  они вообще равны были.
[01:03:44.320 --> 01:03:46.320]  Поэтому вот этот if был бы
[01:03:46.320 --> 01:03:48.320]  бессмысленным абсолютно.
[01:03:48.320 --> 01:03:50.320]  То есть
[01:03:50.320 --> 01:03:52.320]  вот этот вот апгрейд, он мог произойти
[01:03:52.320 --> 01:03:54.320]  случайно. Этот if на более эффективную
[01:03:54.320 --> 01:03:56.320]  реализацию мог сработать просто так.
[01:03:56.320 --> 01:03:58.320]  Но
[01:03:58.320 --> 01:04:00.320]  бывают и более плохие ситуации.
[01:04:00.320 --> 01:04:02.320]  Бывают, что у вас те же самые операторы,
[01:04:02.320 --> 01:04:04.320]  что требуются в каком-то уточненном
[01:04:04.320 --> 01:04:06.320]  концепте a,
[01:04:06.320 --> 01:04:08.320]  они просто есть у
[01:04:08.320 --> 01:04:10.320]  вашего класса, потому что так исторически
[01:04:10.320 --> 01:04:12.320]  сложилось. Но они там есть
[01:04:12.320 --> 01:04:14.320]  совсем другой семантикой, нежели
[01:04:14.320 --> 01:04:16.320]  требуется концепту a.
[01:04:16.320 --> 01:04:18.320]  Класс концепту b удовлетворяет и моделирует
[01:04:18.320 --> 01:04:20.320]  и удовлетворяет. А концепту
[01:04:20.320 --> 01:04:22.320]  a он случайно удовлетворил, потому
[01:04:22.320 --> 01:04:24.320]  что конфликтами он возник.
[01:04:24.320 --> 01:04:26.320]  Одно и то же имя используется
[01:04:26.320 --> 01:04:28.320]  в концепте a и еще где-то там просто так.
[01:04:28.320 --> 01:04:30.320]  Как тогда быть?
[01:04:30.320 --> 01:04:32.320]  Потому что очевидно, что оно моделировать
[01:04:32.320 --> 01:04:34.320]  а не будет, но удовлетворять ему будет.
[01:04:34.320 --> 01:04:36.320]  Вот нам
[01:04:36.320 --> 01:04:38.320]  дают совет как быть. Нужно всегда
[01:04:38.320 --> 01:04:40.320]  предоставлять некоторый механизм либо
[01:04:40.320 --> 01:04:42.320]  отписки, либо подписки.
[01:04:42.320 --> 01:04:44.320]  Ну, отписка это значит, что
[01:04:44.320 --> 01:04:46.320]  мы можем явно где-то в трейтах написать
[01:04:46.320 --> 01:04:48.320]  я не a.
[01:04:48.320 --> 01:04:50.320]  Вот к концепту a я
[01:04:50.320 --> 01:04:52.320]  не принадлежу. И в сам концепт a
[01:04:52.320 --> 01:04:54.320]  вписать требование, что там
[01:04:54.320 --> 01:04:56.320]  должно быть написано в трейтах, что принадлежишь.
[01:04:56.320 --> 01:04:58.320]  Ну, либо наоборот, явно отписку.
[01:04:58.320 --> 01:05:00.320]  И вот эти...
[01:05:00.320 --> 01:05:02.320]  Это тогда получается, мы для всех
[01:05:02.320 --> 01:05:04.320]  потенциальных таких a,
[01:05:04.320 --> 01:05:06.320]  что из них следует b, должны отписываться.
[01:05:06.320 --> 01:05:08.320]  Да.
[01:05:08.320 --> 01:05:10.320]  Потенциально, да, это каждый концепт
[01:05:10.320 --> 01:05:12.320]  в стандартной библиотеке. По факту
[01:05:12.320 --> 01:05:14.320]  это нужно делать, конечно же,
[01:05:14.320 --> 01:05:16.320]  только в местах, где у вас есть подозрение,
[01:05:16.320 --> 01:05:18.320]  что могут такие вообще вещи происходить.
[01:05:18.320 --> 01:05:20.320]  Вот эти вот апгрейды, да?
[01:05:20.320 --> 01:05:22.320]  То есть если у вас есть алгоритмы,
[01:05:22.320 --> 01:05:24.320]  которые внутри пытаются апгрейдить
[01:05:24.320 --> 01:05:26.320]  с одного концепта до другого,
[01:05:26.320 --> 01:05:28.320]  сделайте возможность
[01:05:28.320 --> 01:05:30.320]  отписки или подписки. Надеюсь, вы все
[01:05:30.320 --> 01:05:32.320]  поняли, почему и зачем.
[01:05:32.320 --> 01:05:34.320]  А если у вас таких алгоритмов нет, то может ничего не делать.
[01:05:34.320 --> 01:05:36.320]  В Голливе делать
[01:05:36.320 --> 01:05:38.320]  gRPC, например.
[01:05:38.320 --> 01:05:40.320]  Там нужно, чтобы был метод
[01:05:40.320 --> 01:05:42.320]  с длинным названием, типа
[01:05:42.320 --> 01:05:44.320]  «я действительно...»
[01:05:48.320 --> 01:05:50.320]  Потому что там дактайпинг...
[01:05:50.320 --> 01:05:52.320]  Вот, да. У нас тоже дактайпинг.
[01:05:52.320 --> 01:05:54.320]  Ну, по отношению
[01:05:54.320 --> 01:05:56.320]  к моделированию. И нам тоже нужно
[01:05:56.320 --> 01:05:58.320]  писать длинный метод, который «да, я действительно
[01:05:58.320 --> 01:06:00.320]  контигиус-атератор». И вот эти теги,
[01:06:00.320 --> 01:06:02.320]  про которые мы только что говорили, это ровно
[01:06:02.320 --> 01:06:04.320]  есть этот механизм подписки
[01:06:04.320 --> 01:06:06.320]  или отписки. Он нужен не просто
[01:06:06.320 --> 01:06:08.320]  там, чтобы уточнить, или для
[01:06:08.320 --> 01:06:10.320]  читаемости, или еще для чего-то, а строгого
[01:06:10.320 --> 01:06:12.320]  для этого, чтобы, когда в алгоритме
[01:06:12.320 --> 01:06:14.320]  вы пытаетесь проапгрейдить итератор до более
[01:06:14.320 --> 01:06:16.320]  мощного, вы случайно не ошиблись.
[01:06:16.320 --> 01:06:18.320]  Чтобы
[01:06:18.320 --> 01:06:20.320]  не было ложно-положительных срабатываний.
[01:06:20.320 --> 01:06:22.320]  Итак, random access
[01:06:22.320 --> 01:06:24.320]  итератор — это дефолт
[01:06:24.320 --> 01:06:26.320]  в нашем случае. Почему? Потому что
[01:06:26.320 --> 01:06:28.320]  больше всего в программе указателей.
[01:06:28.320 --> 01:06:30.320]  Любой указатель — это random access.
[01:06:30.320 --> 01:06:32.320]  И он был выбран дефолтом.
[01:06:32.320 --> 01:06:34.320]  Возможно, исторически. Возможно, и с другим
[01:06:34.320 --> 01:06:36.320]  дефолтом тоже неплохо бы работало.
[01:06:36.320 --> 01:06:38.320]  Ну, вот эта вот историческая данность.
[01:06:38.320 --> 01:06:40.320]  — Указатель, наверное, скорее контигиус?
[01:06:40.320 --> 01:06:42.320]  — Ну, нет.
[01:06:42.320 --> 01:06:44.320]  Потому что ты же не знаешь, куда ты указываешь.
[01:06:44.320 --> 01:06:46.320]  Указатель контигиус,
[01:06:46.320 --> 01:06:48.320]  если он указывает в массив.
[01:06:48.320 --> 01:06:50.320]  А если это указатель в мапчик,
[01:06:50.320 --> 01:06:52.320]  и чтобы его подвинуть,
[01:06:52.320 --> 01:06:54.320]  нужно по указателю прочитать что-то.
[01:06:54.320 --> 01:06:56.320]  И random access
[01:06:56.320 --> 01:06:58.320]  тогда не обязательно.
[01:06:58.320 --> 01:07:00.320]  Ну, не знаю.
[01:07:00.320 --> 01:07:02.320]  Плохое обоснование.
[01:07:02.320 --> 01:07:04.320]  Давайте скажем, что исторический дефолт
[01:07:04.320 --> 01:07:06.320]  сложился.
[01:07:06.320 --> 01:07:08.320]  Но мне все равно ощущение,
[01:07:08.320 --> 01:07:10.320]  что он действительно самый частый.
[01:07:10.320 --> 01:07:12.320]  Мы больше всего орудуем
[01:07:12.320 --> 01:07:14.320]  в жизни с векторами.
[01:07:14.320 --> 01:07:16.320]  А уж я только с векторами.
[01:07:16.320 --> 01:07:18.320]  Как и многие разработчики игр,
[01:07:18.320 --> 01:07:20.320]  потому что вместо мапа у нас есть
[01:07:20.320 --> 01:07:22.320]  vector-map.
[01:07:22.320 --> 01:07:24.320]  Это массив, который автоматически сортируется
[01:07:24.320 --> 01:07:26.320]  на вставке с помощью insertion-сорта.
[01:07:26.320 --> 01:07:28.320]  То есть такой массив с bin-поиском.
[01:07:28.320 --> 01:07:30.320]  Это типа мапчик.
[01:07:30.320 --> 01:07:32.320]  И vector-set, и вот такие вещи.
[01:07:32.320 --> 01:07:34.320]  Они там на малых размерах,
[01:07:34.320 --> 01:07:36.320]  до 32 работают
[01:07:36.320 --> 01:07:38.320]  в разы быстрее, чуть ли не в 100 раз,
[01:07:38.320 --> 01:07:40.320]  чем std-map или std-set.
[01:07:44.320 --> 01:07:46.320]  Не поможет.
[01:07:46.320 --> 01:07:48.320]  Не поможет.
[01:07:48.320 --> 01:07:50.320]  Хэши все равно медленнее считать,
[01:07:50.320 --> 01:07:52.320]  чем положить до 8 элементов
[01:07:52.320 --> 01:07:54.320]  так точно. Всегда быстрее
[01:07:54.320 --> 01:07:56.320]  вектор-set и при вставке сортировать,
[01:07:56.320 --> 01:07:58.320]  а потом
[01:07:58.320 --> 01:08:00.320]  bin-поиск.
[01:08:00.320 --> 01:08:02.320]  Линейный поиск даже быстрее,
[01:08:02.320 --> 01:08:04.320]  чем bin-поиск до 5 элементов
[01:08:04.320 --> 01:08:06.320]  или до 10, в зависимости от размера.
[01:08:06.320 --> 01:08:08.320]  Короче, ладно, все в этом мире
[01:08:08.320 --> 01:08:10.320]  это вектор. Вам рассказывают
[01:08:10.320 --> 01:08:12.320]  про какие-то списки связанные,
[01:08:12.320 --> 01:08:14.320]  мапы, сеты.
[01:08:14.320 --> 01:08:16.320]  Все вектор. Хэши таблицы тоже вектор,
[01:08:16.320 --> 01:08:18.320]  если что.
[01:08:18.320 --> 01:08:20.320]  Ну...
[01:08:20.320 --> 01:08:22.320]  Окей.
[01:08:22.320 --> 01:08:24.320]  Все вектор, возможно, спарс.
[01:08:24.320 --> 01:08:26.320]  Потому что иногда вам нужно
[01:08:26.320 --> 01:08:28.320]  расширяться, не мувая старые
[01:08:28.320 --> 01:08:30.320]  элементы из-за многопоточных соображений.
[01:08:30.320 --> 01:08:32.320]  Поэтому вы делаете что-то вроде
[01:08:32.320 --> 01:08:34.320]  дека. Ну и, короче,
[01:08:34.320 --> 01:08:36.320]  какое-то такое обоснование дурацкое.
[01:08:36.320 --> 01:08:38.320]  Давайте по существу
[01:08:38.320 --> 01:08:40.320]  input forward bidirectional,
[01:08:40.320 --> 01:08:42.320]  вот эти вот теги, это отписка
[01:08:42.320 --> 01:08:44.320]  от того, что мы являемся рандомэксис
[01:08:44.320 --> 01:08:46.320]  итератором. Зачем эта отписка нужна?
[01:08:48.320 --> 01:08:50.320]  Чтобы можно закручить все античистое
[01:08:50.320 --> 01:08:52.320]  инициативное.
[01:08:52.320 --> 01:08:54.320]  Чтобы ложно-положительные
[01:08:54.320 --> 01:08:56.320]  срабатывания подушить,
[01:08:56.320 --> 01:08:58.320]  по синтаксису
[01:08:58.320 --> 01:09:00.320]  можно посмотреть, являемся ли мы input forward
[01:09:00.320 --> 01:09:02.320]  bidirectional, но может быть...
[01:09:02.320 --> 01:09:04.320]  Окей. Можно посмотреть, являемся ли мы
[01:09:04.320 --> 01:09:06.320]  forward, bidirectional или рандомэксис итератор,
[01:09:06.320 --> 01:09:08.320]  но этот взгляд по синтаксису
[01:09:08.320 --> 01:09:10.320]  может дать ложно-положительное срабатывание.
[01:09:10.320 --> 01:09:12.320]  Поэтому у нас всегда должна быть
[01:09:12.320 --> 01:09:14.320]  возможность отписаться до самого
[01:09:14.320 --> 01:09:16.320]  простого, до input итератора.
[01:09:16.320 --> 01:09:18.320]  То есть вот эти теги – это отписки.
[01:09:18.320 --> 01:09:20.320]  Потому что их свойства,
[01:09:20.320 --> 01:09:22.320]  что у forward, что у bidirectional,
[01:09:22.320 --> 01:09:24.320]  что у рандомэксис,
[01:09:24.320 --> 01:09:26.320]  они только по синтаксису не детектятся.
[01:09:26.320 --> 01:09:28.320]  Там есть еще семантические требования.
[01:09:28.320 --> 01:09:30.320]  У
[01:09:30.320 --> 01:09:32.320]  contiguous итератор тега явная
[01:09:32.320 --> 01:09:34.320]  подписка, то есть в обратную сторону.
[01:09:34.320 --> 01:09:36.320]  Мы по дефолту рандомэксис,
[01:09:36.320 --> 01:09:38.320]  но если мы уж уверены, что у нас подряд
[01:09:38.320 --> 01:09:40.320]  байты в памяти идут, то мы можем сказать,
[01:09:40.320 --> 01:09:42.320]  нет, я даже более сильный, я
[01:09:42.320 --> 01:09:44.320]  contiguous.
[01:09:44.320 --> 01:09:46.320]  И вот это уж вообще не детектится
[01:09:46.320 --> 01:09:48.320]  по синтаксису никак, потому что это
[01:09:48.320 --> 01:09:50.320]  чисто семантическое требование.
[01:09:50.320 --> 01:09:52.320]  А вот output итератор
[01:09:52.320 --> 01:09:54.320]  оказывается, никаких
[01:09:54.320 --> 01:09:56.320]  семантических
[01:09:56.320 --> 01:09:58.320]  требований не имеет.
[01:09:58.320 --> 01:10:00.320]  И он всегда
[01:10:00.320 --> 01:10:02.320]  однозначно детектится по синтаксису.
[01:10:02.320 --> 01:10:04.320]  Вот всегда.
[01:10:04.320 --> 01:10:06.320]  Если у вас
[01:10:06.320 --> 01:10:08.320]  по синтаксису подходит
[01:10:08.320 --> 01:10:10.320]  к output итератору,
[01:10:10.320 --> 01:10:12.320]  ко всему остальному не подходит, то все,
[01:10:12.320 --> 01:10:14.320]  вот вы output итератор.
[01:10:14.320 --> 01:10:16.320]  И тут не нужны никакие механизмы
[01:10:16.320 --> 01:10:18.320]  ни апгрейда, ни отписки, ни подписки.
[01:10:18.320 --> 01:10:20.320]  И второй пункт,
[01:10:20.320 --> 01:10:22.320]  то есть вообще, когда у вас
[01:10:22.320 --> 01:10:24.320]  output итератор тег,
[01:10:24.320 --> 01:10:26.320]  когда у вас по факту output итератор, а вы поставите
[01:10:26.320 --> 01:10:28.320]  рандомэксис итератор тег,
[01:10:28.320 --> 01:10:30.320]  все сломается, конечно.
[01:10:30.320 --> 01:10:32.320]  Но не факт, может все сломаться,
[01:10:32.320 --> 01:10:34.320]  если у вас сложно положительное срабатывание
[01:10:34.320 --> 01:10:36.320]  по синтаксису.
[01:10:36.320 --> 01:10:38.320]  Поэтому отписка как бы есть.
[01:10:38.320 --> 01:10:40.320]  Есть output итератор тег, вы его должны
[01:10:40.320 --> 01:10:42.320]  не вписать, если у вас output итератор.
[01:10:42.320 --> 01:10:44.320]  Но почему там нет унаследования
[01:10:44.320 --> 01:10:46.320]  и почему нет всех этих проверок?
[01:10:46.320 --> 01:10:48.320]  То есть вот помните, в концепте не было
[01:10:48.320 --> 01:10:50.320]  проверки, что есть output итератор тег.
[01:10:50.320 --> 01:10:52.320]  И forward итератор
[01:10:52.320 --> 01:10:54.320]  тег не наследует
[01:10:54.320 --> 01:10:56.320]  output итератор тег. Почему?
[01:10:56.320 --> 01:10:58.320]  Потому что ни один алгоритм в жизни
[01:10:58.320 --> 01:11:00.320]  не будет пытаться апгрейдить output итератор
[01:11:00.320 --> 01:11:02.320]  до какого-то другого.
[01:11:02.320 --> 01:11:04.320]  Почему-то так сложилось.
[01:11:04.320 --> 01:11:06.320]  Да, то есть внезапно
[01:11:06.320 --> 01:11:08.320]  почему-то
[01:11:08.320 --> 01:11:10.320]  алгоритмы не хотят апгрейдить
[01:11:10.320 --> 01:11:12.320]  output итераторы ни до чего.
[01:11:12.320 --> 01:11:14.320]  По-моему,
[01:11:14.320 --> 01:11:16.320]  с тд копии не output итераторы требуется.
[01:11:16.320 --> 01:11:18.320]  А может и требуется, а может и апгрейдится.
[01:11:18.320 --> 01:11:20.320]  Хороший вопрос, конечно.
[01:11:20.320 --> 01:11:22.320]  Я нашел это обоснование не сам, конечно же,
[01:11:22.320 --> 01:11:24.320]  а читал...
[01:11:24.320 --> 01:11:26.320]  Да, тут
[01:11:26.320 --> 01:11:28.320]  важное подчеркнуто.
[01:11:28.320 --> 01:11:30.320]  Сейчас.
[01:11:30.320 --> 01:11:32.320]  Ладно.
[01:11:32.320 --> 01:11:34.320]  Короче, потом скажу, где я это нашел.
[01:11:34.320 --> 01:11:36.320]  Вы можете сами еще пересерчить,
[01:11:36.320 --> 01:11:38.320]  потому что тут все еще однозначного ответа
[01:11:38.320 --> 01:11:40.320]  такого удовлетворяющего нет на самом деле,
[01:11:40.320 --> 01:11:42.320]  как это полагается.
[01:11:42.320 --> 01:11:44.320]  Но вот ключевое отличие в этом
[01:11:44.320 --> 01:11:46.320]  согласно некоторым людям.
[01:11:46.320 --> 01:11:48.320]  Что вот эти вещи
[01:11:48.320 --> 01:11:50.320]  мы не можем явно проверить, что
[01:11:50.320 --> 01:11:52.320]  куда мы здесь попадаем
[01:11:52.320 --> 01:11:54.320]  только по синтаксису, а здесь
[01:11:54.320 --> 01:11:56.320]  можем.
[01:11:56.320 --> 01:11:58.320]  Почему-то.
[01:11:58.320 --> 01:12:00.320]  Ну, окей.
[01:12:00.320 --> 01:12:02.320]  На самом деле понятно почему,
[01:12:02.320 --> 01:12:04.320]  потому что вы можете для удобства
[01:12:04.320 --> 01:12:06.320]  определить все методы
[01:12:06.320 --> 01:12:08.320]  random access итератора
[01:12:08.320 --> 01:12:10.320]  для даже
[01:12:10.320 --> 01:12:12.320]  forward итератора.
[01:12:12.320 --> 01:12:14.320]  Можете же, да?
[01:12:14.320 --> 01:12:16.320]  Или для bidirectional.
[01:12:16.320 --> 01:12:18.320]  Они будут неэффективны, но определить можете.
[01:12:18.320 --> 01:12:20.320]  Но
[01:12:20.320 --> 01:12:22.320]  тогда получите
[01:12:22.320 --> 01:12:24.320]  ложноположительное срабатывание на концептах.
[01:12:24.320 --> 01:12:26.320]  И поэтому есть эта отписка.
[01:12:26.320 --> 01:12:28.320]  А для output итератора невозможно
[01:12:28.320 --> 01:12:30.320]  определить какие-то операции,
[01:12:30.320 --> 01:12:32.320]  которые там есть у random access или
[01:12:32.320 --> 01:12:34.320]  у contiguous, потому что он настолько...
[01:12:34.320 --> 01:12:36.320]  Ну, имплементации обычно такие,
[01:12:36.320 --> 01:12:38.320]  что ты пишешь в поток.
[01:12:38.320 --> 01:12:40.320]  Ты там никакие прыжки на n не можешь делать,
[01:12:40.320 --> 01:12:42.320]  ничего не можешь делать.
[01:12:42.320 --> 01:12:44.320]  Возможно, в этом как по сути.
[01:12:44.320 --> 01:12:46.320]  А то, что ты говорил про то, что у нас там может быть
[01:12:46.320 --> 01:12:48.320]  эти плюсы, они на самом деле
[01:12:48.320 --> 01:12:50.320]  исторически сложились, они не то вообще
[01:12:50.320 --> 01:12:52.320]  значат, но они есть.
[01:12:52.320 --> 01:12:54.320]  Ну, да. В этой ситуации.
[01:12:54.320 --> 01:12:56.320]  Ну,
[01:12:56.320 --> 01:12:58.320]  все равно же есть механизм отписки
[01:12:58.320 --> 01:13:00.320]  на самом деле, вот этот output итератор tag.
[01:13:00.320 --> 01:13:02.320]  Сейчас.
[01:13:02.320 --> 01:13:04.320]  Вот output итератор tag был.
[01:13:04.320 --> 01:13:06.320]  Если у вас
[01:13:06.320 --> 01:13:08.320]  эти рандомные исторические плюсы есть,
[01:13:08.320 --> 01:13:10.320]  и вы хотите как-то
[01:13:10.320 --> 01:13:12.320]  безопасить себя, чтобы случайно не сработал концепт
[01:13:12.320 --> 01:13:14.320]  на random access, вот вы этот
[01:13:14.320 --> 01:13:16.320]  output итератор tag все равно пишете.
[01:13:16.320 --> 01:13:18.320]  И тогда вы запретите во все остальные
[01:13:18.320 --> 01:13:20.320]  категории попадать.
[01:13:20.320 --> 01:13:22.320]  А?
[01:13:22.320 --> 01:13:24.320]  Ну, или попадать, или апгрейдиться.
[01:13:24.320 --> 01:13:26.320]  Ну, да.
[01:13:26.320 --> 01:13:28.320]  То есть, это делается.
[01:13:32.320 --> 01:13:34.320]  Вот здесь вот написано про
[01:13:34.320 --> 01:13:36.320]  отписку, вообще вы делаете
[01:13:36.320 --> 01:13:38.320]  для любого a, из которого следует b.
[01:13:38.320 --> 01:13:40.320]  А здесь мы рассмотрели
[01:13:40.320 --> 01:13:42.320]  вперед, мы рассмотрели
[01:13:42.320 --> 01:13:44.320]  только концепты
[01:13:44.320 --> 01:13:46.320]  итераторские. Но наш потенциаль
[01:13:46.320 --> 01:13:48.320]  может быть какой-то другой концепт,
[01:13:48.320 --> 01:13:50.320]  из которого неожиданно следует random access.
[01:13:50.320 --> 01:13:52.320]  Не может, потому что импликация,
[01:13:52.320 --> 01:13:54.320]  мы про это говорили подробно, импликация
[01:13:54.320 --> 01:13:56.320]  строится только если у тебя
[01:13:56.320 --> 01:13:58.320]  явно упомянут
[01:13:58.320 --> 01:14:00.320]  другой концепт в твоем концепте.
[01:14:00.320 --> 01:14:02.320]  Если вот сюда вписать то,
[01:14:02.320 --> 01:14:04.320]  что внутри input or output итератора
[01:14:04.320 --> 01:14:06.320]  написано, то импликации не будет.
[01:14:06.320 --> 01:14:08.320]  Импликация будет только если ты явно
[01:14:08.320 --> 01:14:10.320]  написал именно input or output итератор.
[01:14:10.320 --> 01:14:12.320]  Вот тогда есть импликация из
[01:14:12.320 --> 01:14:14.320]  output в input or output.
[01:14:14.320 --> 01:14:16.320]  Вот.
[01:14:16.320 --> 01:14:18.320]  Да, еще мысль
[01:14:18.320 --> 01:14:20.320]  последняя
[01:14:20.320 --> 01:14:22.320]  на эту тему.
[01:14:22.320 --> 01:14:24.320]  Почему все-таки вот здесь не обязательно
[01:14:24.320 --> 01:14:26.320]  детектится, а вот здесь прям детектится?
[01:14:26.320 --> 01:14:28.320]  Потому что когда мы делаем
[01:14:28.320 --> 01:14:30.320]  indirectly readable, у нас
[01:14:30.320 --> 01:14:32.320]  кванторсуществование, и мы
[01:14:32.320 --> 01:14:34.320]  на самом деле просто типа
[01:14:34.320 --> 01:14:36.320]  не особо понимаем, что у нас конкретно будет.
[01:14:36.320 --> 01:14:38.320]  А вот
[01:14:38.320 --> 01:14:40.320]  когда у нас output итератор,
[01:14:40.320 --> 01:14:42.320]  у нас
[01:14:42.320 --> 01:14:44.320]  в indirectly writable и вообще в концепте
[01:14:44.320 --> 01:14:46.320]  output итератор указан T.
[01:14:46.320 --> 01:14:48.320]  Конкретный T.
[01:14:48.320 --> 01:14:50.320]  Да? Внимание!
[01:14:50.320 --> 01:14:52.320]  Еще раз. Output итератор, здесь конкретный
[01:14:52.320 --> 01:14:54.320]  T указан.
[01:14:54.320 --> 01:14:56.320]  А вот здесь не указан.
[01:14:56.320 --> 01:14:58.320]  И вот из-за этого еще
[01:14:58.320 --> 01:15:00.320]  по синтаксису детектить вот это не получается,
[01:15:00.320 --> 01:15:02.320]  как-то апгрейды туда-сюда.
[01:15:02.320 --> 01:15:04.320]  А output итератор он особенный, он в стране.
[01:15:04.320 --> 01:15:06.320]  У него есть конкретное T, и мы
[01:15:06.320 --> 01:15:08.320]  можем прям проверить, и все нормально
[01:15:08.320 --> 01:15:10.320]  будет. То есть вот какое-то такое
[01:15:10.320 --> 01:15:12.320]  обоснование я составил из
[01:15:12.320 --> 01:15:14.320]  своего гуглежа, здесь
[01:15:14.320 --> 01:15:16.320]  есть прекрасная ссылка, как всегда там
[01:15:16.320 --> 01:15:18.320]  в папочке на Google Drive презентацию уже есть,
[01:15:18.320 --> 01:15:20.320]  они все всегда там. Можете по ней
[01:15:20.320 --> 01:15:22.320]  пройти и перечитать оригинал
[01:15:22.320 --> 01:15:24.320]  мысли, откуда
[01:15:24.320 --> 01:15:26.320]  взялись эти рассуждения,
[01:15:26.320 --> 01:15:28.320]  там еще линки есть всякие.
[01:15:28.320 --> 01:15:30.320]  Ну, надеюсь, я вас смог убедить,
[01:15:30.320 --> 01:15:32.320]  что... Во-первых, донести
[01:15:32.320 --> 01:15:34.320]  некоторые мысли. Первая мысль,
[01:15:34.320 --> 01:15:36.320]  что вот это.
[01:15:36.320 --> 01:15:38.320]  Если вы в алгоритмах
[01:15:38.320 --> 01:15:40.320]  собрались что-то апгрейдить, дайте возможность
[01:15:40.320 --> 01:15:42.320]  подписки или отписки. Пример,
[01:15:42.320 --> 01:15:44.320]  вот он. Вы есть дефолт, есть явная
[01:15:44.320 --> 01:15:46.320]  отписка, есть явная подписка. Где
[01:15:46.320 --> 01:15:48.320]  выбрать дефолт, это вы уже сами должны
[01:15:48.320 --> 01:15:50.320]  решить на основании того, что чаще
[01:15:50.320 --> 01:15:52.320]  используется.
[01:15:52.320 --> 01:15:54.320]  То есть, условно говоря, более частные
[01:15:54.320 --> 01:15:56.320]  случаи, это
[01:15:56.320 --> 01:15:58.320]  мы организуем подписку на них,
[01:15:58.320 --> 01:16:00.320]  от более общих
[01:16:00.320 --> 01:16:02.320]  отписков? Да.
[01:16:08.320 --> 01:16:10.320]  То есть, random access это более частные случаи
[01:16:10.320 --> 01:16:12.320]  input, forward и
[01:16:12.320 --> 01:16:14.320]  direction? Да, и от него должна быть возможность
[01:16:14.320 --> 01:16:16.320]  отписаться как бы.
[01:16:16.320 --> 01:16:18.320]  Это симметричные слова,
[01:16:18.320 --> 01:16:20.320]  просто в зависимости от того, где дефолт,
[01:16:20.320 --> 01:16:22.320]  мы либо подписка, либо
[01:16:22.320 --> 01:16:24.320]  отписка говорим. Во-первых,
[01:16:24.320 --> 01:16:26.320]  делайте так, если вам суждено
[01:16:26.320 --> 01:16:28.320]  когда-то все-таки писать обобщенные
[01:16:28.320 --> 01:16:30.320]  библиотеки.
[01:16:30.320 --> 01:16:32.320]  Во-вторых, иногда вот эта вся система
[01:16:32.320 --> 01:16:34.320]  дает некоторый избой, когда у вас
[01:16:34.320 --> 01:16:36.320]  есть такие вещи, как output, iter, tag.
[01:16:36.320 --> 01:16:38.320]  И тут все становится чуть хитрее,
[01:16:38.320 --> 01:16:40.320]  но зато
[01:16:40.320 --> 01:16:42.320]  меньше боли, да? То есть,
[01:16:42.320 --> 01:16:44.320]  в каком-то смысле
[01:16:44.320 --> 01:16:46.320]  вообще думать не надо, если у вас output
[01:16:46.320 --> 01:16:48.320]  итератор. Просто ни о чем
[01:16:48.320 --> 01:16:50.320]  думать не надо. Он просто работает и все.
[01:16:52.320 --> 01:16:54.320]  Потому что это Т известен ему.
[01:16:54.320 --> 01:16:56.320]  Вот.
[01:16:56.320 --> 01:16:58.320]  То есть, это было сделано специально
[01:16:58.320 --> 01:17:00.320]  или так получилось просто? А по-другому
[01:17:00.320 --> 01:17:02.320]  и нельзя, потому что мы не знаем, что
[01:17:02.320 --> 01:17:04.320]  мы собираемся туда писать, если не требуемо.
[01:17:04.320 --> 01:17:06.320]  Конкретно вот это.
[01:17:10.320 --> 01:17:12.320]  Вот как только у нас будет input и output
[01:17:12.320 --> 01:17:14.320]  итератор, мы как бы сможем
[01:17:14.320 --> 01:17:16.320]  потребовать, чтобы писать можно было
[01:17:16.320 --> 01:17:18.320]  ровно то, что мы прочитали оттуда.
[01:17:18.320 --> 01:17:20.320]  А тут мы читать ничего
[01:17:20.320 --> 01:17:22.320]  не можем, а что-то писать надо.
[01:17:22.320 --> 01:17:24.320]  Надо указать, что писать, и за счет этого
[01:17:24.320 --> 01:17:26.320]  как бы вот
[01:17:26.320 --> 01:17:28.320]  чуть-чуть асимметрия в системе возникла.
[01:17:28.320 --> 01:17:30.320]  Во-первых,
[01:17:30.320 --> 01:17:32.320]  не наследуется вот эта вот штука
[01:17:32.320 --> 01:17:34.320]  output итератор тега. Во-вторых,
[01:17:34.320 --> 01:17:36.320]  вот здесь нету никакого реквайерса,
[01:17:36.320 --> 01:17:38.320]  потому что зачем?
[01:17:38.320 --> 01:17:40.320]  Вот.
[01:17:40.320 --> 01:17:42.320]  Давайте пойдем дальше.
[01:17:42.320 --> 01:17:44.320]  Над этим вам нужно подмозговывать
[01:17:44.320 --> 01:17:46.320]  над output итератором.
[01:17:46.320 --> 01:17:48.320]  Возможно, почитать,
[01:17:48.320 --> 01:17:50.320]  если вам, конечно, все это интересно и вас
[01:17:50.320 --> 01:17:52.320]  это волнует, и станет
[01:17:52.320 --> 01:17:54.320]  лучше. Ну или смириться просто.
[01:17:54.320 --> 01:17:56.320]  Вот по некоторым вопросам я, возможно,
[01:17:56.320 --> 01:17:58.320]  уже смирился, а не понял
[01:17:58.320 --> 01:18:00.320]  на самом деле. Смирился с этой
[01:18:00.320 --> 01:18:02.320]  взглядой реальностью, где происходит какая-то дичь,
[01:18:02.320 --> 01:18:04.320]  и вас пытаюсь тоже так убедить,
[01:18:04.320 --> 01:18:06.320]  что все нормально, но на самом деле
[01:18:06.320 --> 01:18:08.320]  происходит дичь.
[01:18:08.320 --> 01:18:10.320]  Это я не контролирую, это возможно,
[01:18:10.320 --> 01:18:12.320]  но надеюсь, что это не так.
[01:18:12.320 --> 01:18:14.320]  Какой час, кстати, у нас?
[01:18:14.320 --> 01:18:16.320]  Ровно пара прошла.
[01:18:16.320 --> 01:18:18.320]  Ровно пара прошла.
[01:18:18.320 --> 01:18:20.320]  Тогда давайте сделаем перерыв на 10 минут
[01:18:20.320 --> 01:18:22.320]  перед тем, как приходить уже к ранжам-ранжам.
[01:18:22.320 --> 01:18:24.320]  Только мы медленно как-то идем,
[01:18:24.320 --> 01:18:26.320]  надеюсь, дальше ускоримся.
[01:18:26.320 --> 01:18:28.320]  Итак.
[01:18:28.320 --> 01:18:30.320]  Мы подошли к самого важного.
[01:18:30.320 --> 01:18:32.320]  К ранжам.
[01:18:32.320 --> 01:18:34.320]  Но перед тем, как определять ранжи, нам нужно
[01:18:34.320 --> 01:18:36.320]  определить сентинел.
[01:18:36.320 --> 01:18:38.320]  Его мы уже спилерили
[01:18:38.320 --> 01:18:40.320]  на одной из прошлых лекций, да.
[01:18:40.320 --> 01:18:42.320]  Это некоторая штука,
[01:18:42.320 --> 01:18:44.320]  которая при этом
[01:18:44.320 --> 01:18:46.320]  сентинел для чего-то,
[01:18:46.320 --> 01:18:48.320]  ну, s это
[01:18:48.320 --> 01:18:50.320]  сентинел и это итератор.
[01:18:50.320 --> 01:18:52.320]  И вот тип s является сентинелом
[01:18:52.320 --> 01:18:54.320]  для итератора, если он
[01:18:54.320 --> 01:18:56.320]  регулярный,
[01:18:56.320 --> 01:18:58.320]  при этом и это input-output
[01:18:58.320 --> 01:19:00.320]  итератор, и
[01:19:00.320 --> 01:19:02.320]  можно сравнивать s и e,
[01:19:02.320 --> 01:19:04.320]  но
[01:19:04.320 --> 01:19:06.320]  weekly и вот там
[01:19:06.320 --> 01:19:08.320]  with.
[01:19:08.320 --> 01:19:10.320]  Помните ли вы наши долгие беседы про то,
[01:19:10.320 --> 01:19:12.320]  что такое концепт, окончающийся
[01:19:12.320 --> 01:19:14.320]  на with?
[01:19:14.320 --> 01:19:16.320]  И кто такой common type, with
[01:19:16.320 --> 01:19:18.320]  и вот эти вещи?
[01:19:18.320 --> 01:19:20.320]  Common reference with.
[01:19:20.320 --> 01:19:22.320]  Ну, даже если не помните, наверное,
[01:19:22.320 --> 01:19:24.320]  неважно. Суть
[01:19:24.320 --> 01:19:26.320]  можно на оператор равенства
[01:19:26.320 --> 01:19:28.320]  сравнивать инстанции s и e.
[01:19:28.320 --> 01:19:30.320]  Именно в таком порядке
[01:19:30.320 --> 01:19:32.320]  и негарантированной
[01:19:32.320 --> 01:19:34.320]  quality preservation, то есть
[01:19:34.320 --> 01:19:36.320]  с всякими
[01:19:36.320 --> 01:19:38.320]  ice-tream итераторами все
[01:19:38.320 --> 01:19:40.320]  работать будет.
[01:19:44.320 --> 01:19:46.320]  Внутренний, да.
[01:19:46.320 --> 01:19:48.320]  Внутренний, который наружу не вылезает.
[01:19:54.320 --> 01:19:56.320]  Возможно, это из старой версии
[01:19:56.320 --> 01:19:58.320]  стандарта я скопировал.
[01:19:58.320 --> 01:20:00.320]  Вот так вот.
[01:20:00.320 --> 01:20:02.320]  Возможно, разные люди формулировки
[01:20:02.320 --> 01:20:04.320]  писали, поэтому в одном месте
[01:20:04.320 --> 01:20:06.320]  наклонными буквами, а в другом месте
[01:20:06.320 --> 01:20:08.320]  вот так написали. Не знаю.
[01:20:10.320 --> 01:20:12.320]  Да,
[01:20:12.320 --> 01:20:14.320]  мы уже, кажется, про это говорили.
[01:20:14.320 --> 01:20:16.320]  Сантинеллы — это такие
[01:20:16.320 --> 01:20:18.320]  шняги, которые
[01:20:18.320 --> 01:20:20.320]  позволяют по странному алгоритму
[01:20:20.320 --> 01:20:22.320]  проверять, дошли ли мы до конца
[01:20:22.320 --> 01:20:24.320]  контейнера или нет.
[01:20:24.320 --> 01:20:26.320]  Например, с сантинеллом может быть конец файла.
[01:20:26.320 --> 01:20:28.320]  То есть для
[01:20:28.320 --> 01:20:30.320]  ice-tream итератора, который что-то читает
[01:20:30.320 --> 01:20:32.320]  из файла, может быть сантинелл, который
[01:20:32.320 --> 01:20:34.320]  просто при сравнении
[01:20:34.320 --> 01:20:36.320]  итератора с ним смотрит,
[01:20:36.320 --> 01:20:38.320]  был ли последний прочитанный элемент
[01:20:38.320 --> 01:20:40.320]  e, o, f.
[01:20:40.320 --> 01:20:42.320]  Вот так вот.
[01:20:42.320 --> 01:20:44.320]  Может быть бесконечность.
[01:20:44.320 --> 01:20:46.320]  То есть сантинелл, который всегда при сравнении
[01:20:46.320 --> 01:20:48.320]  говорит false — мы еще не дошли.
[01:20:48.320 --> 01:20:50.320]  Это вам внезапно позволяет
[01:20:50.320 --> 01:20:52.320]  сделать итератор, который идет по всем
[01:20:52.320 --> 01:20:54.320]  натуральным числам до бесконечности
[01:20:54.320 --> 01:20:56.320]  и дальше.
[01:20:56.320 --> 01:20:58.320]  Зачем?
[01:20:58.320 --> 01:21:00.320]  Увидим. Полезно, оказывается.
[01:21:00.320 --> 01:21:02.320]  Также может быть сантинелл, который
[01:21:02.320 --> 01:21:04.320]  разыменовывает итератор
[01:21:04.320 --> 01:21:06.320]  и смотрит, лежит ли там
[01:21:06.320 --> 01:21:08.320]  backslash 0.
[01:21:08.320 --> 01:21:10.320]  То есть сантинелл для конца всей строки.
[01:21:10.320 --> 01:21:12.320]  Очень полезная штука.
[01:21:12.320 --> 01:21:14.320]  И теперь
[01:21:14.320 --> 01:21:16.320]  мы можем forward итератор определить.
[01:21:16.320 --> 01:21:18.320]  Я соврал. Еще не ранжи.
[01:21:18.320 --> 01:21:20.320]  После forward итератора ранжи.
[01:21:22.320 --> 01:21:24.320]  Ну да, внезапно для forward итератора
[01:21:24.320 --> 01:21:26.320]  требуется
[01:21:26.320 --> 01:21:28.320]  input.
[01:21:30.320 --> 01:21:32.320]  Аутпут итератора не требуется.
[01:21:34.320 --> 01:21:36.320]  Слушайте, память меня обманула.
[01:21:36.320 --> 01:21:38.320]  Вот видите, как все хорошо.
[01:21:38.320 --> 01:21:40.320]  Аутпут итератора вообще нельзя апгрейдить. Ни до чего.
[01:21:40.320 --> 01:21:42.320]  Да. Ну ладно.
[01:21:42.320 --> 01:21:44.320]  Input итератора требуется. Тег, конечно же.
[01:21:44.320 --> 01:21:46.320]  Incrementable требуется.
[01:21:46.320 --> 01:21:48.320]  Вот тут уже сильный incrementable.
[01:21:48.320 --> 01:21:50.320]  Раньше был wick все это время у нас.
[01:21:50.320 --> 01:21:52.320]  Потому что input-output.
[01:21:52.320 --> 01:21:54.320]  А тут strong и
[01:21:54.320 --> 01:21:56.320]  сантинелл для самого себя.
[01:21:56.320 --> 01:21:58.320]  Что значит сантинелл для самого себя?
[01:21:58.320 --> 01:22:00.320]  Да, вот это
[01:22:00.320 --> 01:22:02.320]  ладно. Это просто значит, что он
[01:22:02.320 --> 01:22:04.320]  регулярный, по сути.
[01:22:04.320 --> 01:22:06.320]  Ну если мы посмотрим на концепт
[01:22:06.320 --> 01:22:08.320]  сантинелла, подставим сюда
[01:22:08.320 --> 01:22:10.320]  i и i, одинаковые
[01:22:10.320 --> 01:22:12.320]  два типа, то
[01:22:12.320 --> 01:22:14.320]  вот это, ну у нас там уже
[01:22:14.320 --> 01:22:16.320]  и итератор, ничего значит не будет.
[01:22:16.320 --> 01:22:18.320]  Ну окей, вернее это будет там
[01:22:18.320 --> 01:22:20.320]  импликацию какую-то делать, не важно.
[01:22:20.320 --> 01:22:22.320]  Вот это тоже ничего значит не будет.
[01:22:22.320 --> 01:22:24.320]  Потому что
[01:22:24.320 --> 01:22:26.320]  нет, будет.
[01:22:26.320 --> 01:22:28.320]  Да, будет.
[01:22:28.320 --> 01:22:30.320]  Потому что да, будет просто оператор сравнения с самим собой.
[01:22:30.320 --> 01:22:32.320]  И semi-regular плюс
[01:22:32.320 --> 01:22:34.320]  оператор сравнения с самим собой это
[01:22:34.320 --> 01:22:36.320]  regular.
[01:22:36.320 --> 01:22:38.320]  Почему не написать regular?
[01:22:38.320 --> 01:22:40.320]  Почему сюда не написать regular, а
[01:22:40.320 --> 01:22:42.320]  сантинелл for сам себя?
[01:22:42.320 --> 01:22:44.320]  Чтобы импликация была.
[01:22:44.320 --> 01:22:46.320]  Чтобы компилятор умел вводить,
[01:22:46.320 --> 01:22:48.320]  что forward итератор, следовательно,
[01:22:48.320 --> 01:22:50.320]  сантинелл для самого себя.
[01:22:52.320 --> 01:22:54.320]  Вот это
[01:22:54.320 --> 01:22:56.320]  regular,
[01:22:56.320 --> 01:22:58.320]  регуляр.
[01:23:02.320 --> 01:23:04.320]  Слушайте, да, наверное
[01:23:04.320 --> 01:23:06.320]  это пофиксили в каком-нибудь c
[01:23:06.320 --> 01:23:08.320]  плюс плюс 23 или 26.
[01:23:08.320 --> 01:23:10.320]  Потому что тут, конечно, хочется иметь импликацию
[01:23:10.320 --> 01:23:12.320]  в regular, а тут ее нету, кажется,
[01:23:12.320 --> 01:23:14.320]  действительно.
[01:23:14.320 --> 01:23:16.320]  Ну...
[01:23:16.320 --> 01:23:18.320]  Да.
[01:23:18.320 --> 01:23:20.320]  Нет, в reg... Нет, просто
[01:23:20.320 --> 01:23:22.320]  должно где-то быть явно выписан концепт
[01:23:22.320 --> 01:23:24.320]  regular. Импликации не берутся из ниоткуда,
[01:23:24.320 --> 01:23:26.320]  они берутся только если вы прям руками
[01:23:26.320 --> 01:23:28.320]  вписали.
[01:23:28.320 --> 01:23:30.320]  А равны, потому что вот здесь equality preservation
[01:23:30.320 --> 01:23:32.320]  не требуется, а вот здесь уже требуется.
[01:23:32.320 --> 01:23:34.320]  Forward итератор
[01:23:34.320 --> 01:23:36.320]  и equality preservation, потому что поэтому все эти
[01:23:36.320 --> 01:23:38.320]  вики слетают, все strong
[01:23:38.320 --> 01:23:40.320]  и все нормально. Forward итератор он
[01:23:40.320 --> 01:23:42.320]  прям совсем нормальный, он регулярный,
[01:23:42.320 --> 01:23:44.320]  он там сравнивается
[01:23:44.320 --> 01:23:46.320]  хорошо, инкрементиться нормально,
[01:23:46.320 --> 01:23:48.320]  никаких проблем с ним нету.
[01:23:48.320 --> 01:23:50.320]  И больше итератора смотреть мы
[01:23:50.320 --> 01:23:52.320]  не будем, потому что мы бы здесь уснули
[01:23:52.320 --> 01:23:54.320]  смотреть все эти разные
[01:23:54.320 --> 01:23:56.320]  bidirectional, random access.
[01:23:56.320 --> 01:23:58.320]  Ну, мы и так уснули, да.
[01:23:58.320 --> 01:24:00.320]  Но они не такие
[01:24:00.320 --> 01:24:02.320]  проблематичные. Их вы сами можете
[01:24:02.320 --> 01:24:04.320]  посмотреть и увидеть, что там
[01:24:04.320 --> 01:24:06.320]  не так все сложно. Там просто
[01:24:06.320 --> 01:24:08.320]  добавляются какие-то простые требования,
[01:24:08.320 --> 01:24:10.320]  вполне резонные и
[01:24:12.320 --> 01:24:14.320]  в общем самостоятельно.
[01:24:16.320 --> 01:24:18.320]  А вот мы наконец-то к ранжапе
[01:24:18.320 --> 01:24:20.320]  пришли, теперь вот все точно.
[01:24:20.320 --> 01:24:22.320]  Итак, определение.
[01:24:22.320 --> 01:24:24.320]  Ранжом со звездочкой,
[01:24:24.320 --> 01:24:26.320]  не просто ранжом, а именно со звездочкой
[01:24:26.320 --> 01:24:28.320]  называется пара из input
[01:24:28.320 --> 01:24:30.320]  итератора и сентинела,
[01:24:30.320 --> 01:24:32.320]  которая такова, что
[01:24:32.320 --> 01:24:34.320]  если они не равны,
[01:24:34.320 --> 01:24:36.320]  то разыменование валидно
[01:24:36.320 --> 01:24:38.320]  и при этом
[01:24:38.320 --> 01:24:40.320]  если сделать инкремент,
[01:24:40.320 --> 01:24:42.320]  то мы все еще получим ранж
[01:24:42.320 --> 01:24:44.320]  со звездочкой.
[01:24:44.320 --> 01:24:46.320]  Рекурсивное определение.
[01:24:46.320 --> 01:24:48.320]  Ранж это что-то,
[01:24:48.320 --> 01:24:50.320]  что можно прочитать его начало
[01:24:50.320 --> 01:24:52.320]  и пойти дальше.
[01:24:52.320 --> 01:24:54.320]  И получить все еще то же самое.
[01:24:54.320 --> 01:24:56.320]  И дальше прочитать еще раз, еще раз, еще раз.
[01:24:56.320 --> 01:24:58.320]  Такая штука.
[01:24:58.320 --> 01:25:00.320]  В принципе, да.
[01:25:00.320 --> 01:25:02.320]  На удивление.
[01:25:02.320 --> 01:25:04.320]  А теперь есть valet range.
[01:25:08.320 --> 01:25:10.320]  А, это опечатка.
[01:25:12.320 --> 01:25:14.320]  Чем отличается valet range
[01:25:14.320 --> 01:25:16.320]  от range со звездочкой?
[01:25:16.320 --> 01:25:18.320]  Да. То есть мы можем
[01:25:18.320 --> 01:25:20.320]  за конечное число плюсиков дойти до конца.
[01:25:20.320 --> 01:25:22.320]  А вот тут не требуется,
[01:25:22.320 --> 01:25:24.320]  как и в наших списках
[01:25:24.320 --> 01:25:26.320]  типов.
[01:25:26.320 --> 01:25:28.320]  И вот как бы зачем нам
[01:25:28.320 --> 01:25:30.320]  бесконечные сентинелы?
[01:25:30.320 --> 01:25:32.320]  Потому что мы можем делать бесконечные ранжи.
[01:25:32.320 --> 01:25:34.320]  Например, все натуральные числа.
[01:25:34.320 --> 01:25:36.320]  А дальше с ними работать
[01:25:36.320 --> 01:25:38.320]  как с тейп-листами и
[01:25:38.320 --> 01:25:40.320]  на слово вы мне не поверите,
[01:25:40.320 --> 01:25:42.320]  что это круто, пока сами не поработаете с этим.
[01:25:42.320 --> 01:25:44.320]  Так что едем дальше.
[01:25:44.320 --> 01:25:46.320]  Concept range.
[01:25:46.320 --> 01:25:48.320]  Простой, как пробка.
[01:25:48.320 --> 01:25:50.320]  Наконец-то.
[01:25:50.320 --> 01:25:52.320]  Ranges begin работает и ranges end.
[01:25:52.320 --> 01:25:54.320]  Все.
[01:25:54.320 --> 01:25:56.320]  И quality preservation требуется
[01:25:56.320 --> 01:25:58.320]  только если вот этот begin вернет что-то
[01:25:58.320 --> 01:26:00.320]  вроде forward итератора
[01:26:00.320 --> 01:26:02.320]  или круче.
[01:26:02.320 --> 01:26:04.320]  Для end ничего.
[01:26:04.320 --> 01:26:06.320]  Для end там все не явно.
[01:26:06.320 --> 01:26:08.320]  Begin очевидно
[01:26:08.320 --> 01:26:10.320]  возвращает итератор end-сентинел.
[01:26:10.320 --> 01:26:12.320]  Но здесь это не написано.
[01:26:12.320 --> 01:26:14.320]  Написано это на самом деле
[01:26:14.320 --> 01:26:16.320]  в самих функциях.
[01:26:16.320 --> 01:26:18.320]  Но еще есть
[01:26:18.320 --> 01:26:20.320]  семантические требования.
[01:26:20.320 --> 01:26:22.320]  Перед тем, как посмотреть функции begin и end,
[01:26:22.320 --> 01:26:24.320]  семантические требования range.
[01:26:24.320 --> 01:26:26.320]  Они немножко
[01:26:26.320 --> 01:26:28.320]  взрывают мозг.
[01:26:28.320 --> 01:26:30.320]  Begin и end
[01:26:30.320 --> 01:26:32.320]  оба
[01:26:32.320 --> 01:26:34.320]  не модифицируют
[01:26:34.320 --> 01:26:36.320]  E и имеют
[01:26:36.320 --> 01:26:38.320]  константное время работы, амортизировано.
[01:26:42.320 --> 01:26:44.320]  Они не модифицируют E,
[01:26:44.320 --> 01:26:46.320]  они константы.
[01:26:46.320 --> 01:26:48.320]  Они не константные методы,
[01:26:48.320 --> 01:26:50.320]  они не изменяют состояние E.
[01:26:50.320 --> 01:26:52.320]  Вот так вот.
[01:26:52.320 --> 01:26:54.320]  В каком случае у нас
[01:26:54.320 --> 01:26:56.320]  амортизировано, значит в каком-то случае
[01:26:56.320 --> 01:26:58.320]  у нас там можно занять
[01:26:58.320 --> 01:27:00.320]  end-акцию.
[01:27:00.320 --> 01:27:02.320]  Begin.
[01:27:02.320 --> 01:27:04.320]  Если вы много-много-много
[01:27:04.320 --> 01:27:06.320]  раз будете звать begin и end,
[01:27:06.320 --> 01:27:08.320]  то у вас амортизировано
[01:27:08.320 --> 01:27:10.320]  зовут единицы они зовут.
[01:27:10.320 --> 01:27:12.320]  В среднем.
[01:27:12.320 --> 01:27:14.320]  Монетки, потенциалы.
[01:27:14.320 --> 01:27:16.320]  Помнишь еще что-то?
[01:27:16.320 --> 01:27:18.320]  Begin.
[01:27:18.320 --> 01:27:20.320]  У вектора Begin знаешь, как работает?
[01:27:20.320 --> 01:27:22.320]  Он зовут единицы честно.
[01:27:22.320 --> 01:27:24.320]  Да,
[01:27:24.320 --> 01:27:26.320]  когда может быть
[01:27:26.320 --> 01:27:28.320]  нечестная единица
[01:27:28.320 --> 01:27:30.320]  амортизированная,
[01:27:30.320 --> 01:27:32.320]  это чуть попозже.
[01:27:32.320 --> 01:27:34.320]  Такое...
[01:27:34.320 --> 01:27:36.320]  Сплей деревья?
[01:27:36.320 --> 01:27:38.320]  Да нет, закашируй просто и все.
[01:27:46.320 --> 01:27:48.320]  Ты хочешь найти
[01:27:48.320 --> 01:27:50.320]  первый элемент сплей дерева,
[01:27:50.320 --> 01:27:52.320]  и выше на каждой вставке будешь обновлять.
[01:27:52.320 --> 01:27:54.320]  В чем проблема?
[01:27:56.320 --> 01:27:58.320]  Ну бывает, короче...
[01:28:00.320 --> 01:28:02.320]  Ладно, на самом деле твой пример правильный.
[01:28:02.320 --> 01:28:04.320]  И все примеры примерно такие будут.
[01:28:04.320 --> 01:28:06.320]  Что в лоб по самой структуре данных
[01:28:06.320 --> 01:28:08.320]  нельзя найти.
[01:28:08.320 --> 01:28:10.320]  Но мы хотим, чтобы у нас begin и end
[01:28:10.320 --> 01:28:12.320]  не ходили ни по каким сплей деревьям.
[01:28:12.320 --> 01:28:14.320]  Мы хотим, чтобы они быстро работали.
[01:28:14.320 --> 01:28:16.320]  Поэтому требуем его от единицы.
[01:28:16.320 --> 01:28:18.320]  Но вот
[01:28:18.320 --> 01:28:20.320]  вопрос в какой момент
[01:28:20.320 --> 01:28:22.320]  вычислять этот кэш.
[01:28:22.320 --> 01:28:24.320]  И вот амортизация нам позволяет
[01:28:24.320 --> 01:28:26.320]  кэш вычислять прямо в Begin.
[01:28:26.320 --> 01:28:28.320]  Но чуть попозже увидим причину
[01:28:28.320 --> 01:28:30.320]  почему именно так. Почему мы не можем
[01:28:30.320 --> 01:28:32.320]  сказать всегда заранее кэш вычисляйте
[01:28:32.320 --> 01:28:34.320]  или что-нибудь такое.
[01:28:34.320 --> 01:28:36.320]  Да,
[01:28:36.320 --> 01:28:38.320]  так же я пропустил, но
[01:28:38.320 --> 01:28:40.320]  значения, которые
[01:28:40.320 --> 01:28:42.320]  возвращают begin и end, они вместе
[01:28:42.320 --> 01:28:44.320]  должны образовывать range,
[01:28:44.320 --> 01:28:46.320]  который не вот этот
[01:28:46.320 --> 01:28:48.320]  range, а вот этот range
[01:28:48.320 --> 01:28:50.320]  со звездочкой.
[01:28:50.320 --> 01:28:52.320]  Что?
[01:28:52.320 --> 01:28:54.320]  Не обязательно valid.
[01:28:54.320 --> 01:28:56.320]  Да, и
[01:28:56.320 --> 01:28:58.320]  тыры-пыры-пыры.
[01:29:02.320 --> 01:29:04.320]  Ну, короче, да, тут про equality preservation
[01:29:04.320 --> 01:29:06.320]  это уже мелочи. Если forward,
[01:29:06.320 --> 01:29:08.320]  то все equality preserving все довольны. Если
[01:29:08.320 --> 01:29:10.320]  нет, то и сюда нет.
[01:29:10.320 --> 01:29:12.320]  Окей.
[01:29:12.320 --> 01:29:14.320]  Да, причем на самом деле
[01:29:14.320 --> 01:29:16.320]  тут забавное уточнение,
[01:29:16.320 --> 01:29:18.320]  что
[01:29:18.320 --> 01:29:20.320]  мы говорим про выражение,
[01:29:20.320 --> 01:29:22.320]  а не про тип конкретный.
[01:29:22.320 --> 01:29:24.320]  Вот я это не тип, а выражение,
[01:29:24.320 --> 01:29:26.320]  которое может быть там l-value,
[01:29:26.320 --> 01:29:28.320]  может быть r-value.
[01:29:28.320 --> 01:29:30.320]  Это не внезапно
[01:29:30.320 --> 01:29:32.320]  влияет.
[01:29:32.320 --> 01:29:34.320]  А что значит
[01:29:34.320 --> 01:29:36.320]  амортизированная константа от
[01:29:36.320 --> 01:29:38.320]  рв выражения?
[01:29:38.320 --> 01:29:40.320]  Что? Нет, ну амортизированная константа
[01:29:40.320 --> 01:29:42.320]  относительно размера контейнеров.
[01:29:42.320 --> 01:29:44.320]  В смысле, амортизированная
[01:29:44.320 --> 01:29:46.320]  константная линия?
[01:29:46.320 --> 01:29:48.320]  Да.
[01:29:48.320 --> 01:29:50.320]  Я это понимаю, но если у нас r-value, то мы не можем
[01:29:50.320 --> 01:29:52.320]  много раз применить.
[01:29:52.320 --> 01:29:54.320]  Ну, может быть, в теории, но
[01:29:54.320 --> 01:29:56.320]  не как все значения, мы можем много раз применить.
[01:29:56.320 --> 01:29:58.320]  Ты такие вопросы не задавай.
[01:30:00.320 --> 01:30:02.320]  Ты чертовски прав, и ответа на меня
[01:30:02.320 --> 01:30:04.320]  нету. Ну,
[01:30:04.320 --> 01:30:06.320]  нет, ты можешь...
[01:30:06.320 --> 01:30:08.320]  Ну, окей,
[01:30:08.320 --> 01:30:10.320]  ты к r-value вообще не можешь
[01:30:10.320 --> 01:30:12.320]  на begin и end применить
[01:30:12.320 --> 01:30:14.320]  вообще-то, потому что
[01:30:14.320 --> 01:30:16.320]  как только ты begin применил, у тебя, типа,
[01:30:16.320 --> 01:30:18.320]  невалидно и...
[01:30:18.320 --> 01:30:20.320]  Ну, получается, e должно быть l-value expression.
[01:30:20.320 --> 01:30:22.320]  Ну, нет, на самом деле нет.
[01:30:22.320 --> 01:30:24.320]  То есть, окей, тебе дали r-value,
[01:30:24.320 --> 01:30:26.320]  но ты как бы используешь на нём
[01:30:26.320 --> 01:30:28.320]  begin и end много раз, но само
[01:30:28.320 --> 01:30:30.320]  сам объект,
[01:30:30.320 --> 01:30:32.320]  сам объект, он не модифицируется,
[01:30:32.320 --> 01:30:34.320]  несмотря на то, что ты как бы
[01:30:34.320 --> 01:30:36.320]  move делаешь.
[01:30:36.320 --> 01:30:38.320]  Да.
[01:30:38.320 --> 01:30:40.320]  Нет.
[01:30:40.320 --> 01:30:42.320]  Ну, да.
[01:30:42.320 --> 01:30:44.320]  Чёрт.
[01:30:44.320 --> 01:30:46.320]  Нет, это...
[01:30:46.320 --> 01:30:48.320]  Окей, нет, это может быть
[01:30:48.320 --> 01:30:50.320]  и std move от чего-то.
[01:30:50.320 --> 01:30:52.320]  Всё выражение вместе будет r-value.
[01:30:52.320 --> 01:30:54.320]  И...
[01:30:54.320 --> 01:30:56.320]  Да, такое
[01:30:56.320 --> 01:30:58.320]  можно написать, и это тоже
[01:30:58.320 --> 01:31:00.320]  осмыслено в некоторых ситуациях. Кажется, что
[01:31:00.320 --> 01:31:02.320]  сейчас точно не скажу. Давайте ехать дальше.
[01:31:02.320 --> 01:31:04.320]  Такой спойлер
[01:31:04.320 --> 01:31:06.320]  на будущее. Вот теперь пришло
[01:31:06.320 --> 01:31:08.320]  время посмотреть время. Мы уже смотрели чуть-чуть.
[01:31:08.320 --> 01:31:10.320]  Вот эта цепошка такая, там
[01:31:10.320 --> 01:31:12.320]  по универсальной ссылке берёт. Действительно
[01:31:12.320 --> 01:31:14.320]  можно передать туда по r-value.
[01:31:14.320 --> 01:31:16.320]  И она вот в таком порядке
[01:31:16.320 --> 01:31:18.320]  и делает свои кастомизации.
[01:31:18.320 --> 01:31:20.320]  Во-первых, она пытается т плюс ноль
[01:31:20.320 --> 01:31:22.320]  сделать. Что это значит?
[01:31:22.320 --> 01:31:24.320]  Это значит, что это надо максимально...
[01:31:24.320 --> 01:31:26.320]  Нет, что... Что это за выражение
[01:31:26.320 --> 01:31:28.320]  дурацкое? Нам дали контейнер,
[01:31:28.320 --> 01:31:30.320]  begin что он принимает? Контейнер
[01:31:30.320 --> 01:31:32.320]  возвращает тератор.
[01:31:32.320 --> 01:31:34.320]  Мы... Чего? Копирует?
[01:31:34.320 --> 01:31:36.320]  Нет, begin дали контейнер
[01:31:36.320 --> 01:31:38.320]  на вход. Здесь t это контейнер.
[01:31:38.320 --> 01:31:40.320]  Мы к контейнеру прибавили ноль. Что это значит?
[01:31:42.320 --> 01:31:44.320]  Что?
[01:31:44.320 --> 01:31:46.320]  Эператор плюс...
[01:31:48.320 --> 01:31:50.320]  Контейнер
[01:31:50.320 --> 01:31:52.320]  tt
[01:31:52.320 --> 01:31:54.320]  это контейнер, это
[01:31:54.320 --> 01:31:56.320]  вектор или рей.
[01:31:56.320 --> 01:31:58.320]  Да!
[01:31:58.320 --> 01:32:00.320]  Это сишные массивы.
[01:32:00.320 --> 01:32:02.320]  Потому что указатель на begin
[01:32:02.320 --> 01:32:04.320]  сишного массива, это
[01:32:04.320 --> 01:32:06.320]  ну просто вот
[01:32:06.320 --> 01:32:08.320]  он плюс ноль.
[01:32:08.320 --> 01:32:10.320]  Ну, окей.
[01:32:10.320 --> 01:32:12.320]  Это действительно делается там
[01:32:12.320 --> 01:32:14.320]  специализациями, но, по-моему,
[01:32:14.320 --> 01:32:16.320]  это, цитата чуть ли не из стандарта,
[01:32:16.320 --> 01:32:18.320]  что там вот так написано.
[01:32:18.320 --> 01:32:20.320]  Это 1 в 1 трюк как с лямбами
[01:32:20.320 --> 01:32:22.320]  делают? Да, типа того.
[01:32:22.320 --> 01:32:24.320]  Чтобы прикастить тип массива к типу
[01:32:24.320 --> 01:32:26.320]  указателя.
[01:32:28.320 --> 01:32:30.320]  Не знаю. А плюс, по-моему,
[01:32:30.320 --> 01:32:32.320]  определённо нарный для массивов.
[01:32:32.320 --> 01:32:34.320]  Плюс ноль определённо.
[01:32:34.320 --> 01:32:36.320]  Ну, не важно.
[01:32:36.320 --> 01:32:38.320]  Просто мы хендлим массивы сишные.
[01:32:38.320 --> 01:32:40.320]  Потом мы пытаемся вызвать метод,
[01:32:40.320 --> 01:32:42.320]  а потом... Что это такое?
[01:32:42.320 --> 01:32:44.320]  Вот это последнее.
[01:32:46.320 --> 01:32:48.320]  Что-то написано. Зачем это?
[01:32:50.320 --> 01:32:52.320]  Ага, это каратский точек астомизации. Да.
[01:32:52.320 --> 01:32:54.320]  Как механизм называется, который
[01:32:54.320 --> 01:32:56.320]  вот тут что-то находит.
[01:32:56.320 --> 01:32:58.320]  Что-то с dl. А?
[01:32:58.320 --> 01:33:00.320]  А dl.
[01:33:00.320 --> 01:33:02.320]  Окей. Ну, со скрипом.
[01:33:02.320 --> 01:33:04.320]  То же самое с эндом.
[01:33:04.320 --> 01:33:06.320]  Только он уже не атератор возвращает
[01:33:06.320 --> 01:33:08.320]  внезапно. Энд возвращает сентинел.
[01:33:08.320 --> 01:33:10.320]  Ну и тут такой же костыль,
[01:33:10.320 --> 01:33:12.320]  где extent-v по типу
[01:33:12.320 --> 01:33:14.320]  массива, у которого указан размер,
[01:33:14.320 --> 01:33:16.320]  возвращает этот размер.
[01:33:16.320 --> 01:33:18.320]  Если не вышло, то мы дальше идём, пробуем так,
[01:33:18.320 --> 01:33:20.320]  пробуем так.
[01:33:22.320 --> 01:33:24.320]  Вот. Да, обратите внимание,
[01:33:24.320 --> 01:33:26.320]  тут ещё требуется, чтобы каждый контейнер
[01:33:26.320 --> 01:33:28.320]  мог говорить, какой у него итератор будет.
[01:33:30.320 --> 01:33:32.320]  То есть это от любого контейнера
[01:33:32.320 --> 01:33:34.320]  нормального требуется, а значит
[01:33:34.320 --> 01:33:36.320]  и от range. Напоминаю,
[01:33:36.320 --> 01:33:38.320]  мы с чего начали. Что мы смотрим,
[01:33:38.320 --> 01:33:40.320]  что такое range, а range просто требуется,
[01:33:40.320 --> 01:33:42.320]  чтобы begin и end были валидными,
[01:33:42.320 --> 01:33:44.320]  а begin и end валидные вот в одном из этих трёх
[01:33:44.320 --> 01:33:46.320]  случаев, где везде
[01:33:46.320 --> 01:33:48.320]  требуется итератор t
[01:33:48.320 --> 01:33:50.320]  и чтобы
[01:33:50.320 --> 01:33:52.320]  итератор вернулся.
[01:33:52.320 --> 01:33:54.320]  То есть если так подытожить,
[01:33:54.320 --> 01:33:56.320]  то range – это
[01:33:56.320 --> 01:33:58.320]  штука, у которой есть методы begin и end,
[01:33:58.320 --> 01:34:00.320]  первая из которых возвращает
[01:34:00.320 --> 01:34:02.320]  input route под итератор,
[01:34:02.320 --> 01:34:04.320]  а вторая возвращает sent and alphore
[01:34:04.320 --> 01:34:06.320]  для ассоциированного типа
[01:34:06.320 --> 01:34:08.320]  итератор t, который должен
[01:34:08.320 --> 01:34:10.320]  тоже быть.
[01:34:10.320 --> 01:34:12.320]  Можно уточнить,
[01:34:12.320 --> 01:34:14.320]  что у нас есть типа end,
[01:34:14.320 --> 01:34:16.320]  not forward,
[01:34:16.320 --> 01:34:18.320]  это в чём-то какая-то функция?
[01:34:20.320 --> 01:34:22.320]  Это как... Короче, тут
[01:34:22.320 --> 01:34:24.320]  чёрт пойми, что написано.
[01:34:24.320 --> 01:34:26.320]  Это не синтаксис плюсов, но
[01:34:26.320 --> 01:34:28.320]  вот эта строчка end от forward – это
[01:34:28.320 --> 01:34:30.320]  синтаксис вызова
[01:34:30.320 --> 01:34:32.320]  неквалифицированного вызова
[01:34:32.320 --> 01:34:34.320]  функции, который ещё и ADL включает.
[01:34:34.320 --> 01:34:36.320]  Если вниз не смотреть.
[01:34:36.320 --> 01:34:38.320]  А вот это я просто написал,
[01:34:38.320 --> 01:34:40.320]  что...
[01:34:40.320 --> 01:34:42.320]  Потому что
[01:34:42.320 --> 01:34:44.320]  неквалифицированный вызов
[01:34:44.320 --> 01:34:46.320]  end. Тут не std end
[01:34:46.320 --> 01:34:48.320]  вызывается, а просто end.
[01:34:48.320 --> 01:34:50.320]  Неквалифицированный вызов значит
[01:34:50.320 --> 01:34:52.320]  работает ADL. Если у нас вот это вот
[01:34:52.320 --> 01:34:54.320]  t и t в каких-то namespace, то там
[01:34:54.320 --> 01:34:56.320]  будет тоже иск от send.
[01:34:56.320 --> 01:34:58.320]  Окей.
[01:34:58.320 --> 01:35:00.320]  Вью.
[01:35:00.320 --> 01:35:02.320]  Вью – это
[01:35:02.320 --> 01:35:04.320]  некоторый
[01:35:04.320 --> 01:35:06.320]  легковесный range, с которым
[01:35:06.320 --> 01:35:08.320]  можно работать, в принципе, как с парой
[01:35:08.320 --> 01:35:10.320]  итераторов, но оно не обязательно
[01:35:10.320 --> 01:35:12.320]  на самом деле является парой
[01:35:12.320 --> 01:35:14.320]  итераторов. То есть это range,
[01:35:14.320 --> 01:35:16.320]  который movable.
[01:35:16.320 --> 01:35:18.320]  Обратите внимание,
[01:35:18.320 --> 01:35:20.320]  в общем случае, ринжи могут быть
[01:35:20.320 --> 01:35:22.320]  immovable.
[01:35:22.320 --> 01:35:24.320]  Default initializable и
[01:35:24.320 --> 01:35:26.320]  явная подписка.
[01:35:26.320 --> 01:35:28.320]  Почему
[01:35:28.320 --> 01:35:30.320]  явная подписка? Потому что есть
[01:35:30.320 --> 01:35:32.320]  семантические требования.
[01:35:32.320 --> 01:35:34.320]  От единицы – всё.
[01:35:34.320 --> 01:35:36.320]  Все действия, которые
[01:35:36.320 --> 01:35:38.320]  совершаются над view, над ринжами,
[01:35:38.320 --> 01:35:40.320]  которые являются view, они должны
[01:35:40.320 --> 01:35:42.320]  делаться за от единицы.
[01:35:44.320 --> 01:35:46.320]  Если копируемо, то и копирование
[01:35:46.320 --> 01:35:48.320]  за от единицы.
[01:35:48.320 --> 01:35:50.320]  Move, конструкторы, деструкторы
[01:35:50.320 --> 01:35:52.320]  от единицы.
[01:35:56.320 --> 01:35:58.320]  Вот. То есть
[01:35:58.320 --> 01:36:00.320]  давайте кто-нибудь
[01:36:00.320 --> 01:36:02.320]  своими словами объяснит
[01:36:02.320 --> 01:36:04.320]  из этого и
[01:36:04.320 --> 01:36:06.320]  того, что я раньше рассказывал,
[01:36:06.320 --> 01:36:08.320]  зачем здесь enable view?
[01:36:08.320 --> 01:36:10.320]  Чтобы случайно тут ещё могли быть такие свойства,
[01:36:10.320 --> 01:36:12.320]  если не стало view, пока мы явно не написали, чтобы
[01:36:12.320 --> 01:36:14.320]  был view, потому что мы не можем
[01:36:14.320 --> 01:36:16.320]  сказать, то есть компилятор не может проверить, что это
[01:36:16.320 --> 01:36:18.320]  выполняется. Да, компилятор не может проверить,
[01:36:18.320 --> 01:36:20.320]  что у нас копирование
[01:36:20.320 --> 01:36:22.320]  за от единицы.
[01:36:22.320 --> 01:36:24.320]  Да. То есть
[01:36:24.320 --> 01:36:26.320]  без enable view вектор стал бы view,
[01:36:26.320 --> 01:36:28.320]  потому что movable, movable, default
[01:36:28.320 --> 01:36:30.320]  initializable – ну да.
[01:36:30.320 --> 01:36:32.320]  Ринжом вектор, очевидно, является.
[01:36:32.320 --> 01:36:34.320]  Это базовый вид ринжа.
[01:36:34.320 --> 01:36:36.320]  View должен
[01:36:36.320 --> 01:36:38.320]  за от единицы копироваться и прочее.
[01:36:38.320 --> 01:36:40.320]  Он не владеет данными, он только на них
[01:36:40.320 --> 01:36:42.320]  смотрит. Такая
[01:36:42.320 --> 01:36:44.320]  ссылка, не владеющая на данные.
[01:36:44.320 --> 01:36:46.320]  Эти требования
[01:36:46.320 --> 01:36:48.320]  проверить невозможно.
[01:36:48.320 --> 01:36:50.320]  Поэтому мы явную подписку делаем.
[01:36:50.320 --> 01:36:52.320]  Вектор конструкции за от единицы.
[01:36:52.320 --> 01:36:54.320]  Вектор конструкции за от единицы.
[01:36:54.320 --> 01:36:56.320]  Mova тоже за от единицы.
[01:36:56.320 --> 01:36:58.320]  Нет. Ладно, нет.
[01:36:58.320 --> 01:37:00.320]  Нет.
[01:37:00.320 --> 01:37:02.320]  Можно написать такую имплементацию Mova у вектора,
[01:37:02.320 --> 01:37:04.320]  которая будет за от единицы.
[01:37:04.320 --> 01:37:06.320]  Своп.
[01:37:06.320 --> 01:37:08.320]  А вот деструктор уже тогда будет не за
[01:37:08.320 --> 01:37:10.320]  от единицы, потому что нам надо освободить
[01:37:10.320 --> 01:37:12.320]  эти элементы.
[01:37:12.320 --> 01:37:14.320]  Копироваться точно вектор будет не за от единицы,
[01:37:14.320 --> 01:37:16.320]  поэтому вьюхой вектор не
[01:37:16.320 --> 01:37:18.320]  является.
[01:37:22.320 --> 01:37:24.320]  T это контейнер.
[01:37:24.320 --> 01:37:26.320]  Мы начали говорить про контейнеры.
[01:37:26.320 --> 01:37:28.320]  Контейнер является ринжом, если у него
[01:37:28.320 --> 01:37:30.320]  есть вот такие штуки.
[01:37:30.320 --> 01:37:32.320]  Контейнер является
[01:37:32.320 --> 01:37:34.320]  вьюхой, если у него есть вот такие
[01:37:34.320 --> 01:37:36.320]  штуки.
[01:37:36.320 --> 01:37:38.320]  Да.
[01:37:40.320 --> 01:37:42.320]  Что касается того, что считается
[01:37:42.320 --> 01:37:44.320]  сложностью.
[01:37:44.320 --> 01:37:46.320]  СТД рэй является вьюхой,
[01:37:46.320 --> 01:37:48.320]  потому что в рантайне у него
[01:37:48.320 --> 01:37:50.320]  константная сложность.
[01:37:50.320 --> 01:37:52.320]  Такие вопросы ты не задавай.
[01:37:52.320 --> 01:37:54.320]  Да, копируется за от единицы.
[01:37:54.320 --> 01:37:56.320]  Если каждый его объезд
[01:37:56.320 --> 01:37:58.320]  остается на...
[01:37:58.320 --> 01:38:00.320]  Это абсолютно корректный вопрос, который у меня есть.
[01:38:00.320 --> 01:38:02.320]  Это получается, что
[01:38:02.320 --> 01:38:04.320]  рэй от некопируемого
[01:38:04.320 --> 01:38:06.320]  контейнера
[01:38:06.320 --> 01:38:08.320]  будет вьюхой.
[01:38:08.320 --> 01:38:10.320]  А ну да, будет.
[01:38:18.320 --> 01:38:20.320]  Это
[01:38:20.320 --> 01:38:22.320]  центральный вопрос,
[01:38:22.320 --> 01:38:24.320]  на который у меня ответа нет.
[01:38:28.320 --> 01:38:30.320]  В стандарте просто берут
[01:38:30.320 --> 01:38:32.320]  и пишут от единицы.
[01:38:32.320 --> 01:38:34.320]  Что вас учили на матане целый год
[01:38:34.320 --> 01:38:36.320]  не делать.
[01:38:36.320 --> 01:38:38.320]  Писать вот так.
[01:38:38.320 --> 01:38:40.320]  Чего здесь не хватает?
[01:38:40.320 --> 01:38:42.320]  Да, при каком
[01:38:42.320 --> 01:38:44.320]  стремлении чего куда от единицы.
[01:38:46.320 --> 01:38:48.320]  Вдалбливали, вдалбливали, вдалбливали, вдалбливали.
[01:38:48.320 --> 01:38:50.320]  Не пишите просто ошки.
[01:38:50.320 --> 01:38:52.320]  Должно написать от единицы
[01:38:52.320 --> 01:38:54.320]  запятая, н стремится к бесконечности.
[01:38:54.320 --> 01:38:56.320]  А еще уточнить,
[01:38:56.320 --> 01:38:58.320]  что за н, какая н.
[01:38:58.320 --> 01:39:00.320]  Здесь это нигде не уточнено.
[01:39:00.320 --> 01:39:02.320]  Поэтому черт его знает.
[01:39:02.320 --> 01:39:04.320]  Интуитивно вы должны себя
[01:39:04.320 --> 01:39:06.320]  удивить, что это от единицы.
[01:39:06.320 --> 01:39:08.320]  Все.
[01:39:08.320 --> 01:39:10.320]  Ну да.
[01:39:10.320 --> 01:39:12.320]  Ну то есть,
[01:39:12.320 --> 01:39:14.320]  я не знаю.
[01:39:14.320 --> 01:39:16.320]  По-моему в стандарте для STD Rea
[01:39:16.320 --> 01:39:18.320]  не сделано enable view, поэтому все-таки
[01:39:18.320 --> 01:39:20.320]  Rea не вьюшка.
[01:39:20.320 --> 01:39:22.320]  А по тюплу одинаковых типов
[01:39:22.320 --> 01:39:24.320]  ты не можешь пройти с итератором?
[01:39:24.320 --> 01:39:26.320]  А, можешь.
[01:39:26.320 --> 01:39:28.320]  Ну это то же самое, что Rea, ну короче тоже нет.
[01:39:30.320 --> 01:39:32.320]  Вот, ну я вам скажу не только
[01:39:32.320 --> 01:39:34.320]  что стандартизация от этого страдает.
[01:39:34.320 --> 01:39:36.320]  Я там для своей научной работы
[01:39:36.320 --> 01:39:38.320]  статьи время от времени читаю.
[01:39:38.320 --> 01:39:40.320]  Я знаю страшные вещи, но там тоже все пишут.
[01:39:40.320 --> 01:39:42.320]  Математики, профессиональные.
[01:39:42.320 --> 01:39:44.320]  Просто от там того-то от, сего-то.
[01:39:44.320 --> 01:39:46.320]  Кто и куда стремится, никто не уточняет.
[01:39:46.320 --> 01:39:48.320]  Ты сидишь и
[01:39:48.320 --> 01:39:50.320]  пытаешься угадать, что было в голове у авторов,
[01:39:50.320 --> 01:39:52.320]  что они и куда стремили,
[01:39:52.320 --> 01:39:54.320]  когда это написали. И там порой такие
[01:39:54.320 --> 01:39:56.320]  нетривиальные ответы бывают,
[01:39:56.320 --> 01:39:58.320]  что они рассматривали произвольную
[01:39:58.320 --> 01:40:00.320]  последовательность случайных графов,
[01:40:00.320 --> 01:40:02.320]  которые сгенерированы там вот как-то так-то и сяк-то.
[01:40:02.320 --> 01:40:04.320]  И вот когда номер
[01:40:04.320 --> 01:40:06.320]  графа в этой последовательности стремится
[01:40:06.320 --> 01:40:08.320]  к бесконечности, то у нас будет
[01:40:08.320 --> 01:40:10.320]  от чего-то. О!
[01:40:10.320 --> 01:40:12.320]  Конечно это писать не надо.
[01:40:12.320 --> 01:40:14.320]  Это абсолютно очевидно. Здесь такая же ситуация.
[01:40:14.320 --> 01:40:16.320]  Сделать ничего с ней не можем.
[01:40:16.320 --> 01:40:18.320]  Поэтому просто пойдем дальше и посмотрим на
[01:40:18.320 --> 01:40:20.320]  EnableView
[01:40:20.320 --> 01:40:22.320]  и вообще откуда он берется.
[01:40:22.320 --> 01:40:24.320]  Вот есть такая штука ViewBase.
[01:40:24.320 --> 01:40:26.320]  И EnableView
[01:40:26.320 --> 01:40:28.320]  требует ровно этого, чтобы вы
[01:40:28.320 --> 01:40:30.320]  в этот ViewBase наследовались.
[01:40:30.320 --> 01:40:32.320]  То есть каждый раз, когда вы пишете View,
[01:40:32.320 --> 01:40:34.320]  View надо писать
[01:40:34.320 --> 01:40:36.320]  с нуля. Потому что это совершенно новое
[01:40:36.320 --> 01:40:38.320]  понятие стандартной библиотеки.
[01:40:38.320 --> 01:40:40.320]  Раньше такого понятия не было. Поэтому
[01:40:40.320 --> 01:40:42.320]  ни через какие трейты
[01:40:42.320 --> 01:40:44.320]  ничего старого сделать
[01:40:44.320 --> 01:40:46.320]  вьюхой нельзя.
[01:40:46.320 --> 01:40:48.320]  Потому что вы, скорее всего, нарушите вот эти вот
[01:40:48.320 --> 01:40:50.320]  семантические требования и все полетит.
[01:40:50.320 --> 01:40:52.320]  А надо переписать SliceView
[01:40:52.320 --> 01:40:54.320]  и просто расследоваться?
[01:40:54.320 --> 01:40:56.320]  Ну, формально да. Формально вы должны
[01:40:56.320 --> 01:40:58.320]  в свой SliceEspance впихнуть EnableView
[01:40:58.320 --> 01:41:00.320]  через ViewBase.
[01:41:00.320 --> 01:41:02.320]  Но есть второй вариант.
[01:41:02.320 --> 01:41:04.320]  Вот есть тут DerivedFromViewInterface.
[01:41:04.320 --> 01:41:06.320]  Вот это очень
[01:41:06.320 --> 01:41:08.320]  классная штука. Но тут опять через
[01:41:08.320 --> 01:41:10.320]  тире написано, поэтому никакой не концепта
[01:41:10.320 --> 01:41:12.320]  так словами описывается.
[01:41:12.320 --> 01:41:14.320]  Да?
[01:41:14.320 --> 01:41:16.320]  Да.
[01:41:16.320 --> 01:41:18.320]  Да.
[01:41:18.320 --> 01:41:20.320]  Вы должны публично отнаследоваться
[01:41:20.320 --> 01:41:22.320]  от ViewBase.
[01:41:22.320 --> 01:41:24.320]  Ну, вот так решили.
[01:41:28.320 --> 01:41:30.320]  Ну, такой код
[01:41:30.320 --> 01:41:32.320]  никто точно не напишет.
[01:41:32.320 --> 01:41:34.320]  Я бы не так делал.
[01:41:34.320 --> 01:41:36.320]  Я бы потребовал объявления
[01:41:36.320 --> 01:41:38.320]  поля. Или объявления
[01:41:38.320 --> 01:41:40.320]  типа ViewBase внутри структурки.
[01:41:40.320 --> 01:41:42.320]  Но тут почему-то вот так решили сделать.
[01:41:42.320 --> 01:41:44.320]  Ну, или сделать
[01:41:44.320 --> 01:41:46.320]  какой-нибудь ViewBaseTrade,
[01:41:46.320 --> 01:41:48.320]  в котором нужно специалистов.
[01:41:48.320 --> 01:41:50.320]  Вот.
[01:41:50.320 --> 01:41:52.320]  Нет, нет.
[01:41:52.320 --> 01:41:54.320]  Вот этот вот
[01:41:54.320 --> 01:41:56.320]  Trade, где Bool выставляется,
[01:41:56.320 --> 01:41:58.320]  вот это вот мы не хотим.
[01:41:58.320 --> 01:42:00.320]  Потому что у нас есть всякие legacy-типы
[01:42:00.320 --> 01:42:02.320]  старые, до плюсов двадцатых
[01:42:02.320 --> 01:42:04.320]  сделанные, которые как бы похожи
[01:42:04.320 --> 01:42:06.320]  на View и всякие
[01:42:06.320 --> 01:42:08.320]  не очень внимательно читающие стандарт программисты
[01:42:08.320 --> 01:42:10.320]  могут захотеть из них сделать View.
[01:42:10.320 --> 01:42:12.320]  А там STD Begin
[01:42:12.320 --> 01:42:14.320]  за линию высчитывается.
[01:42:14.320 --> 01:42:16.320]  Или там копируйня за
[01:42:16.320 --> 01:42:18.320]  логарифм. И вот чтобы этого избежать,
[01:42:18.320 --> 01:42:20.320]  мы требуем
[01:42:20.320 --> 01:42:22.320]  не указывать старым
[01:42:22.320 --> 01:42:24.320]  типам, особенно если они из других
[01:42:24.320 --> 01:42:26.320]  библиотек, через какие-то
[01:42:26.320 --> 01:42:28.320]  там трейты, где-то там непонятно
[01:42:28.320 --> 01:42:30.320]  где, что они являются View.
[01:42:30.320 --> 01:42:32.320]  Да?
[01:42:32.320 --> 01:42:34.320]  Исбейзов.
[01:42:34.320 --> 01:42:36.320]  Исбейзов.
[01:42:36.320 --> 01:42:38.320]  Он же работает
[01:42:38.320 --> 01:42:40.320]  и только при публичном.
[01:42:40.320 --> 01:42:42.320]  Не знаю.
[01:42:42.320 --> 01:42:44.320]  Не знаю. Можно дефект репорт
[01:42:44.320 --> 01:42:46.320]  отправить. Ну, или это и поменяли
[01:42:46.320 --> 01:42:48.320]  в двадцать третьем, двадцать шестом.
[01:42:48.320 --> 01:42:50.320]  А если хочешь пересчитать, чтобы что-то считалось с View,
[01:42:50.320 --> 01:42:52.320]  то есть оно расследовался с чего-то,
[01:42:52.320 --> 01:42:54.320]  при этом ты им пересел метод, а он пересел с View.
[01:42:54.320 --> 01:42:56.320]  Ну, бери наследование. Короче,
[01:42:56.320 --> 01:42:58.320]  это такая мелочь. Ребят,
[01:42:58.320 --> 01:43:00.320]  давайте не зациклються на этом.
[01:43:00.320 --> 01:43:02.320]  Вот мы и так уже много времени тратим.
[01:43:02.320 --> 01:43:04.320]  View Interface. Это CRTP.
[01:43:04.320 --> 01:43:06.320]  Наш любимый.
[01:43:06.320 --> 01:43:08.320]  Он требует от вас сделать свой
[01:43:08.320 --> 01:43:10.320]  Begin и End. И автоматом вам
[01:43:10.320 --> 01:43:12.320]  все вот эти вот методы нагенеривает.
[01:43:12.320 --> 01:43:14.320]  Через CRTP.
[01:43:14.320 --> 01:43:16.320]  Это супер удобно.
[01:43:16.320 --> 01:43:18.320]  То есть половина методов, которые вы писали
[01:43:18.320 --> 01:43:20.320]  ручками в слайсе, можете их не писать.
[01:43:20.320 --> 01:43:22.320]  Все вот это вот вам
[01:43:22.320 --> 01:43:24.320]  дают бесплатно.
[01:43:26.320 --> 01:43:28.320]  В слайсе,
[01:43:28.320 --> 01:43:30.320]  а как это квадратные скобки?
[01:43:30.320 --> 01:43:32.320]  Что?
[01:43:32.320 --> 01:43:34.320]  Begin плюс... У вас же
[01:43:34.320 --> 01:43:36.320]  random access стератор.
[01:43:36.320 --> 01:43:38.320]  Begin плюс End.
[01:43:38.320 --> 01:43:40.320]  В слайсе тоже random access.
[01:43:40.320 --> 01:43:42.320]  Но стератор...
[01:43:42.320 --> 01:43:44.320]  Не contiguous, но random access.
[01:43:44.320 --> 01:43:46.320]  Какие проблемы?
[01:43:46.320 --> 01:43:48.320]  Ну, то есть как бы...
[01:43:48.320 --> 01:43:50.320]  Короче, все это нормально будет.
[01:43:50.320 --> 01:43:52.320]  Вот эти вот штуки они генерируются
[01:43:52.320 --> 01:43:54.320]  только если соответствующий
[01:43:54.320 --> 01:43:56.320]  концепт удовлетворен.
[01:43:56.320 --> 01:43:58.320]  И там всякие хитрости немножко есть.
[01:43:58.320 --> 01:44:00.320]  И вот там
[01:44:00.320 --> 01:44:02.320]  кое-где еще там вот эти точнения,
[01:44:02.320 --> 01:44:04.320]  что size за от единицы должен работать,
[01:44:04.320 --> 01:44:06.320]  поэтому он только для random access
[01:44:06.320 --> 01:44:08.320]  сгенерируется. И оператор
[01:44:08.320 --> 01:44:10.320]  квадратной скобки тоже, по-моему, только
[01:44:10.320 --> 01:44:12.320]  для random access сгенерируется.
[01:44:12.320 --> 01:44:14.320]  То есть он на ваш Begin посмотрит, вы random access
[01:44:14.320 --> 01:44:16.320]  вернули. Если да, то все.
[01:44:16.320 --> 01:44:18.320]  А view требует...
[01:44:18.320 --> 01:44:20.320]  В view требует
[01:44:20.320 --> 01:44:22.320]  contiguous стератор? Нет.
[01:44:22.320 --> 01:44:24.320]  А как мы этот дат возвращаем?
[01:44:24.320 --> 01:44:26.320]  Ну, смотри,
[01:44:26.320 --> 01:44:28.320]  вот этот view
[01:44:28.320 --> 01:44:30.320]  interface,
[01:44:30.320 --> 01:44:32.320]  в нем есть дата, и там написано
[01:44:32.320 --> 01:44:34.320]  requires contiguous
[01:44:34.320 --> 01:44:36.320]  стератор декалтай под Begin.
[01:44:36.320 --> 01:44:38.320]  Вот. Ну и все.
[01:44:38.320 --> 01:44:40.320]  Если у вас Begin, который вы написали
[01:44:40.320 --> 01:44:42.320]  возвращает contiguous стератор, то вот этот метод
[01:44:42.320 --> 01:44:44.320]  будет включен. Иначе выключен.
[01:44:44.320 --> 01:44:46.320]  И все.
[01:44:46.320 --> 01:44:48.320]  Окей.
[01:44:48.320 --> 01:44:50.320]  Давайте разбираться, кто из них в view?
[01:44:50.320 --> 01:44:52.320]  Нет.
[01:44:52.320 --> 01:44:54.320]  Спан точно, string view точно.
[01:44:54.320 --> 01:44:56.320]  Спан точно, string view точно, slice.
[01:44:56.320 --> 01:44:58.320]  Удивительно, судя по личику, нет?
[01:44:58.320 --> 01:45:00.320]  Да нет, да.
[01:45:00.320 --> 01:45:02.320]  Ну, то есть...
[01:45:02.320 --> 01:45:04.320]  Ну, мы сами slice написали.
[01:45:04.320 --> 01:45:06.320]  Прикольно.
[01:45:06.320 --> 01:45:08.320]  Но это наш slice, сами придумали.
[01:45:08.320 --> 01:45:10.320]  Но, в общем-то, правильно.
[01:45:10.320 --> 01:45:12.320]  Спан, string view и slice — это вот это в view-хе.
[01:45:12.320 --> 01:45:14.320]  Было бы забавно сказать, когда в view
[01:45:14.320 --> 01:45:16.320]  не было бы view.
[01:45:16.320 --> 01:45:18.320]  Да, было бы немножко неловко.
[01:45:18.320 --> 01:45:20.320]  String array
[01:45:20.320 --> 01:45:22.320]  и vector, конечно же, не в view.
[01:45:22.320 --> 01:45:24.320]  Ну, по разным причинам.
[01:45:24.320 --> 01:45:26.320]  Копируемость и прочее.
[01:45:26.320 --> 01:45:28.320]  Не от единицы.
[01:45:28.320 --> 01:45:30.320]  Теперь
[01:45:30.320 --> 01:45:32.320]  мы плюс-минус поняли, что такое RNG
[01:45:32.320 --> 01:45:34.320]  и что такое view, я надеюсь.
[01:45:34.320 --> 01:45:36.320]  Как с ними работать?
[01:45:36.320 --> 01:45:38.320]  Первая категория способов
[01:45:38.320 --> 01:45:40.320]  работать с ренджами или view-хами —
[01:45:40.320 --> 01:45:42.320]  это создать новую view-ху.
[01:45:42.320 --> 01:45:44.320]  Для этого есть семейство функций,
[01:45:44.320 --> 01:45:46.320]  не функций, cpo-шек,
[01:45:46.320 --> 01:45:48.320]  не cpo-шек, непонятно чего,
[01:45:48.320 --> 01:45:50.320]  которое нам умеет возвращать
[01:45:50.320 --> 01:45:52.320]  новые view-хи.
[01:45:54.320 --> 01:45:56.320]  Да, ну...
[01:45:56.320 --> 01:45:58.320]  Короче, в чем проблема? Вы смотрите
[01:45:58.320 --> 01:46:00.320]  в cpp-референс, там написано.
[01:46:00.320 --> 01:46:02.320]  Ну, что такое empty-view?
[01:46:02.320 --> 01:46:04.320]  empty-view — это inline constexpr
[01:46:04.320 --> 01:46:06.320]  unspecified empty-view
[01:46:06.320 --> 01:46:08.320]  равно unspecified.
[01:46:08.320 --> 01:46:10.320]  Или empty.
[01:46:10.320 --> 01:46:12.320]  Могут быть.
[01:46:12.320 --> 01:46:14.320]  Поэтому
[01:46:14.320 --> 01:46:16.320]  все эти вещи — это объекты,
[01:46:16.320 --> 01:46:18.320]  которые типа unspecified со значением unspecified.
[01:46:18.320 --> 01:46:20.320]  Но неважно.
[01:46:20.320 --> 01:46:22.320]  Я думаю, вы можете догадаться, что они делают, правда?
[01:46:22.320 --> 01:46:24.320]  Что все эти штуки делают?
[01:46:24.320 --> 01:46:26.320]  Вот иота.
[01:46:26.320 --> 01:46:28.320]  Вот иота не очевидна, да.
[01:46:28.320 --> 01:46:30.320]  Давайте смотреть.
[01:46:30.320 --> 01:46:32.320]  empty-view — это пустая вьюха
[01:46:32.320 --> 01:46:34.320]  на ноль элементов.
[01:46:34.320 --> 01:46:36.320]  Тип обязательно надо указать,
[01:46:36.320 --> 01:46:38.320]  потому что нетипизированных вьюх RNG.
[01:46:38.320 --> 01:46:40.320]  Всегда есть 200 тип.
[01:46:40.320 --> 01:46:42.320]  Single-view оборачивает один элемент.
[01:46:42.320 --> 01:46:44.320]  Тут тип тоже обязательно нужен,
[01:46:44.320 --> 01:46:46.320]  но он выводится.
[01:46:46.320 --> 01:46:48.320]  В single-view
[01:46:48.320 --> 01:46:50.320]  думаю, что нет.
[01:46:50.320 --> 01:46:52.320]  Почему?
[01:46:52.320 --> 01:46:54.320]  Да тоже, наверное, нет.
[01:46:54.320 --> 01:46:56.320]  А, ну стоп.
[01:46:56.320 --> 01:46:58.320]  Вспоминаем, вью всегда должен муваться.
[01:46:58.320 --> 01:47:00.320]  Так.
[01:47:00.320 --> 01:47:02.320]  Значит, single-view, ну где
[01:47:02.320 --> 01:47:04.320]  хранит свой один единицный элемент?
[01:47:04.320 --> 01:47:06.320]  Наверное, внутри себя. По значению.
[01:47:06.320 --> 01:47:08.320]  А если он
[01:47:08.320 --> 01:47:10.320]  не мувается за от единицы?
[01:47:10.320 --> 01:47:12.320]  Если он не мувается за от единицы,
[01:47:12.320 --> 01:47:14.320]  то
[01:47:14.320 --> 01:47:16.320]  ну, ты проиграл.
[01:47:16.320 --> 01:47:18.320]  Нагомо считается, что
[01:47:18.320 --> 01:47:20.320]  все-таки элементы вьюхи
[01:47:20.320 --> 01:47:22.320]  муваются за от единицы.
[01:47:22.320 --> 01:47:24.320]  Да, да, да. Кстати, вот это вот
[01:47:24.320 --> 01:47:26.320]  от единицы вьюха мувается,
[01:47:26.320 --> 01:47:28.320]  введу, что относительно
[01:47:28.320 --> 01:47:30.320]  количества, относительно
[01:47:30.320 --> 01:47:32.320]  времени мувания одного элемента.
[01:47:32.320 --> 01:47:34.320]  Но тут и так один элемент, поэтому
[01:47:34.320 --> 01:47:36.320]  во всяком случае зовут единицы, и все хорошо.
[01:47:36.320 --> 01:47:38.320]  Можно не париться.
[01:47:38.320 --> 01:47:40.320]  Да, еще
[01:47:40.320 --> 01:47:42.320]  вот такой синтак
[01:47:42.320 --> 01:47:44.320]  сейчас вы встречали когда-нибудь? На всякий случай хочу
[01:47:44.320 --> 01:47:46.320]  его упомянуть хоть раз в наших лекциях.
[01:47:46.320 --> 01:47:48.320]  Inplace.
[01:47:48.320 --> 01:47:50.320]  Что это такое?
[01:47:50.320 --> 01:47:52.320]  Это же конструктор какой-нибудь.
[01:47:54.320 --> 01:47:56.320]  Ну, чем отличается
[01:47:56.320 --> 01:47:58.320]  вот это от вот этого?
[01:47:58.320 --> 01:48:00.320]  А, заменить прям.
[01:48:00.320 --> 01:48:02.320]  Ничего.
[01:48:02.320 --> 01:48:04.320]  Что он зовут конструктор 3 и аж 3?
[01:48:04.320 --> 01:48:06.320]  Да.
[01:48:06.320 --> 01:48:08.320]  Внутри SingleView лежит свой
[01:48:08.320 --> 01:48:10.320]  стринг, поле. И вызов вот такого
[01:48:10.320 --> 01:48:12.320]  конструктора, он прямо
[01:48:12.320 --> 01:48:14.320]  у этого поля, которое внутри
[01:48:14.320 --> 01:48:16.320]  SingleView лежит, у этого поля
[01:48:16.320 --> 01:48:18.320]  вызовет его конструктор от аргументов,
[01:48:18.320 --> 01:48:20.320]  которые после inplace.
[01:48:20.320 --> 01:48:22.320]  Чем это отличается от этого?
[01:48:22.320 --> 01:48:24.320]  А тем, что здесь будет move произведен.
[01:48:24.320 --> 01:48:26.320]  Ну, на int это без разницы.
[01:48:26.320 --> 01:48:28.320]  А вот на стринге move это
[01:48:28.320 --> 01:48:30.320]  чуть более жалко может быть.
[01:48:30.320 --> 01:48:32.320]  Или на каком-нибудь array.
[01:48:32.320 --> 01:48:34.320]  Ну или там даже копия может быть.
[01:48:34.320 --> 01:48:36.320]  То есть это способ
[01:48:36.320 --> 01:48:38.320]  избежать лишнего вызова move конструктора,
[01:48:38.320 --> 01:48:40.320]  если вам жалко.
[01:48:40.320 --> 01:48:42.320]  Или если у вас немувабельный тип.
[01:48:42.320 --> 01:48:44.320]  Хотя тут конечно
[01:48:44.320 --> 01:48:46.320]  да, немувабельных не бывает.
[01:48:46.320 --> 01:48:48.320]  Но такой же есть optional и еще некоторых
[01:48:48.320 --> 01:48:50.320]  контейнеров, вот если вы не видели.
[01:48:50.320 --> 01:48:52.320]  Это тот самый tag-based
[01:48:52.320 --> 01:48:54.320]  dispatch, который
[01:48:54.320 --> 01:48:56.320]  мы видели где-то,
[01:48:56.320 --> 01:48:58.320]  я уже забыл где, но видели.
[01:48:58.320 --> 01:49:00.320]  Inplace это тег и есть отдельная
[01:49:00.320 --> 01:49:02.320]  std lockguard.
[01:49:04.320 --> 01:49:06.320]  Вот мы там его видели.
[01:49:06.320 --> 01:49:08.320]  Тут такой же тег inplace, это
[01:49:08.320 --> 01:49:10.320]  именно значение, а тип у него
[01:49:10.320 --> 01:49:12.320]  inplace.t
[01:49:12.320 --> 01:49:16.320]  Вот здесь
[01:49:16.320 --> 01:49:18.320]  ты обязан вот это значение, которое тебе
[01:49:18.320 --> 01:49:20.320]  дали, move-нуть в свое поле.
[01:49:20.320 --> 01:49:22.320]  Вот single view у него есть поле, туда нужно move-нуть
[01:49:22.320 --> 01:49:24.320]  вот это значение. А тут ты конструируешь
[01:49:24.320 --> 01:49:26.320]  этот стринг,
[01:49:26.320 --> 01:49:28.320]  прям это поле, типа стринг, конструируешь
[01:49:28.320 --> 01:49:30.320]  аргументов.
[01:49:30.320 --> 01:49:32.320]  Ну да, мы move-аем аргументы
[01:49:32.320 --> 01:49:34.320]  для конструктора.
[01:49:34.320 --> 01:49:36.320]  У самого типа move конструктор не вызываем.
[01:49:36.320 --> 01:49:38.320]  Это может быть быстрее.
[01:49:38.320 --> 01:49:40.320]  Тоже верно, да.
[01:49:42.320 --> 01:49:44.320]  Что?
[01:49:44.320 --> 01:49:46.320]  А да, тут временная
[01:49:46.320 --> 01:49:48.320]  переменная конструируется, у нее тоже
[01:49:48.320 --> 01:49:50.320]  деструктор зовется, это тоже может быть там
[01:49:50.320 --> 01:49:52.320]  нехорошо. Yota, вот то, что
[01:49:52.320 --> 01:49:54.320]  не очевидно, вот числа будут.
[01:49:54.320 --> 01:49:56.320]  1, 2, 3, 4, 5.
[01:49:58.320 --> 01:50:00.320]  Теперь все очевидно.
[01:50:00.320 --> 01:50:02.320]  Yota
[01:50:02.320 --> 01:50:04.320]  это греческая буква.
[01:50:04.320 --> 01:50:06.320]  Видите там
[01:50:06.320 --> 01:50:08.320]  яблоко.
[01:50:08.320 --> 01:50:10.320]  Это Apple, но не тот, о котором вы подумали.
[01:50:10.320 --> 01:50:12.320]  Это язык программирования
[01:50:12.320 --> 01:50:14.320]  такой парадигмы,
[01:50:14.320 --> 01:50:16.320]  как array-oriented programming.
[01:50:16.320 --> 01:50:18.320]  То есть есть object-oriented
[01:50:18.320 --> 01:50:20.320]  programming, а есть array-oriented
[01:50:20.320 --> 01:50:22.320]  programming. Это совсем
[01:50:22.320 --> 01:50:24.320]  типа чуждая нам
[01:50:24.320 --> 01:50:26.320]  современным людям парадигма, но когда-то она
[01:50:26.320 --> 01:50:28.320]  была очень модной.
[01:50:28.320 --> 01:50:30.320]  Как ты угадал.
[01:50:32.320 --> 01:50:34.320]  Больше всего эта парадигма похожа
[01:50:34.320 --> 01:50:36.320]  на нампай.
[01:50:36.320 --> 01:50:38.320]  Когда у вас есть тензор или массив,
[01:50:38.320 --> 01:50:40.320]  и все операции сразу
[01:50:40.320 --> 01:50:42.320]  бродкастятся на весь массив,
[01:50:42.320 --> 01:50:44.320]  всякие тензорные произведения берете
[01:50:44.320 --> 01:50:46.320]  и махаете с данными руками.
[01:50:46.320 --> 01:50:48.320]  Это язык, который нативно
[01:50:48.320 --> 01:50:50.320]  для этого делался, а не библиотечка
[01:50:50.320 --> 01:50:52.320]  на питоне, черт пойми как работающая.
[01:50:52.320 --> 01:50:54.320]  И там
[01:50:54.320 --> 01:50:56.320]  чем он знаменит?
[01:50:56.320 --> 01:50:58.320]  Когда-то давно
[01:50:58.320 --> 01:51:00.320]  компьютер это был
[01:51:00.320 --> 01:51:02.320]  mainframe, стоит в подвале в вашем
[01:51:02.320 --> 01:51:04.320]  университете, а у вас в кабинете стоит
[01:51:04.320 --> 01:51:06.320]  терминал.
[01:51:06.320 --> 01:51:08.320]  В Яндексе
[01:51:08.320 --> 01:51:10.320]  так до сих пор.
[01:51:10.320 --> 01:51:12.320]  Есть сервер, который где-то далеко,
[01:51:12.320 --> 01:51:14.320]  а есть терминал. И терминал это не
[01:51:14.320 --> 01:51:16.320]  компьютер, это просто монитор, а раньше
[01:51:16.320 --> 01:51:18.320]  это была не монитор, а печатная машинка.
[01:51:18.320 --> 01:51:20.320]  И вы кнопки вбиваете, нажимаете
[01:51:20.320 --> 01:51:22.320]  enter, по проводу на mainframe
[01:51:22.320 --> 01:51:24.320]  отправляется ваша строчка, возвращается
[01:51:24.320 --> 01:51:26.320]  новая строчка, и печатная машинка
[01:51:26.320 --> 01:51:28.320]  вам печатает сама, что вам сервер
[01:51:28.320 --> 01:51:30.320]  ответил.
[01:51:30.320 --> 01:51:32.320]  Собственно, вот эти 31 символы,
[01:51:32.320 --> 01:51:34.320]  32 символы в начале кодировки ASCII,
[01:51:34.320 --> 01:51:36.320]  это с тех времен.
[01:51:36.320 --> 01:51:38.320]  Вот, это вот
[01:51:38.320 --> 01:51:40.320]  телетайп, как раз оттуда слово пошло,
[01:51:40.320 --> 01:51:42.320]  и в чем проблема такого подхода?
[01:51:42.320 --> 01:51:44.320]  Блин, ждать долго. Пока у вас
[01:51:44.320 --> 01:51:46.320]  распечатается этот код на C++, 200
[01:51:46.320 --> 01:51:48.320]  строк, чтобы Hello World
[01:51:48.320 --> 01:51:50.320]  напечатать.
[01:51:50.320 --> 01:51:52.320]  Да-да-да-да.
[01:51:52.320 --> 01:51:54.320]  Да-да-да-да.
[01:51:54.320 --> 01:51:56.320]  Вот
[01:51:56.320 --> 01:51:58.320]  очень проблематично.
[01:51:58.320 --> 01:52:00.320]  Поэтому языки старались делать
[01:52:00.320 --> 01:52:02.320]  максимально компактными. Ребят, вы можете
[01:52:02.320 --> 01:52:04.320]  пожалуйста не переговариваться параллельно со мной,
[01:52:04.320 --> 01:52:06.320]  я теряю мысль, и на записи может быть слышно,
[01:52:06.320 --> 01:52:08.320]  и короче...
[01:52:08.320 --> 01:52:10.320]  Итак.
[01:52:10.320 --> 01:52:12.320]  Как решить проблему? Долго
[01:52:12.320 --> 01:52:14.320]  печатается. Надо сделать языки,
[01:52:14.320 --> 01:52:16.320]  в которых меньше символов.
[01:52:16.320 --> 01:52:18.320]  Ну, язык Apple очень
[01:52:18.320 --> 01:52:20.320]  хитро решил эту проблему.
[01:52:20.320 --> 01:52:22.320]  Он сказал, давайте мы несколько
[01:52:22.320 --> 01:52:24.320]  символов будем комбинировать,
[01:52:24.320 --> 01:52:26.320]  друг на друга нашлепывать, и говорить, что это отдельные
[01:52:26.320 --> 01:52:28.320]  символы. У нас есть плюс
[01:52:28.320 --> 01:52:30.320]  и есть буква O. Давайте
[01:52:30.320 --> 01:52:32.320]  напечатаем плюс, нажмем Backspace,
[01:52:32.320 --> 01:52:34.320]  напечатаем O, и будет плюс
[01:52:34.320 --> 01:52:36.320]  в кружочке, типа как там
[01:52:36.320 --> 01:52:38.320]  прямая сумма.
[01:52:38.320 --> 01:52:40.320]  Да. Вот.
[01:52:40.320 --> 01:52:42.320]  И отличная идея. И там
[01:52:42.320 --> 01:52:44.320]  код на языке Apple выглядит как какое-то древнее
[01:52:44.320 --> 01:52:46.320]  заклинание на неизвестном языке. В том
[01:52:46.320 --> 01:52:48.320]  числе там греческие буквы используются, всякие
[01:52:48.320 --> 01:52:50.320]  диагритики какие-то.
[01:52:50.320 --> 01:52:52.320]  Да. Йота пошла
[01:52:52.320 --> 01:52:54.320]  оттуда. Стандартные
[01:52:54.320 --> 01:52:56.320]  функции Apple. Была буква
[01:52:56.320 --> 01:52:58.320]  Йота, одна буква.
[01:52:58.320 --> 01:53:00.320]  Надеюсь, вы знаете, как она
[01:53:00.320 --> 01:53:02.320]  выглядит, как буква I, только
[01:53:02.320 --> 01:53:04.320]  без палки. Вот это Йота.
[01:53:04.320 --> 01:53:06.320]  И вот этот символ, эта буква,
[01:53:06.320 --> 01:53:08.320]  она как раз распечатывала последовательность
[01:53:08.320 --> 01:53:10.320]  чисел. И с тех пор
[01:53:10.320 --> 01:53:12.320]  традиционно во многих языках
[01:53:12.320 --> 01:53:14.320]  используется Йота.
[01:53:14.320 --> 01:53:16.320]  Так вот. Вот про это мы проговорили,
[01:53:16.320 --> 01:53:18.320]  что от одного до пяти не
[01:53:18.320 --> 01:53:20.320]  включая пять. А можно вот так еще написать.
[01:53:20.320 --> 01:53:22.320]  Что это значит?
[01:53:22.320 --> 01:53:24.320]  Несконечность не придет.
[01:53:24.320 --> 01:53:26.320]  Да, это range всех натуральных
[01:53:26.320 --> 01:53:28.320]  чисел от одного и так далее.
[01:53:28.320 --> 01:53:30.320]  Внезапно
[01:53:30.320 --> 01:53:32.320]  n будет unreachable
[01:53:32.320 --> 01:53:34.320]  sentinel. Прям стандартной
[01:53:34.320 --> 01:53:36.320]  библиотеке, специальный тип для
[01:53:36.320 --> 01:53:38.320]  сентинела, до которого никогда невозможно дойти.
[01:53:38.320 --> 01:53:40.320]  Он всегда при сравнении false возвращает.
[01:53:40.320 --> 01:53:42.320]  И вот этот view, она
[01:53:42.320 --> 01:53:44.320]  ленивая. Вы могли
[01:53:44.320 --> 01:53:46.320]  подумать, что view внутри себя заводит
[01:53:46.320 --> 01:53:48.320]  массив чисел от одного до пяти. Ничего
[01:53:48.320 --> 01:53:50.320]  подобного. Просто оно возвращает
[01:53:50.320 --> 01:53:52.320]  итератор, в котором запоминает текущий
[01:53:52.320 --> 01:53:54.320]  элемент. При разминовании его возвращает
[01:53:54.320 --> 01:53:56.320]  и при
[01:53:56.320 --> 01:53:58.320]  инкременте просто увеличивает.
[01:53:58.320 --> 01:54:00.320]  То есть оно работает
[01:54:00.320 --> 01:54:02.320]  лениво, как в Хаскеле, например.
[01:54:02.320 --> 01:54:04.320]  Вы можете
[01:54:04.320 --> 01:54:06.320]  сделать Йоту на миллиард элементов,
[01:54:06.320 --> 01:54:08.320]  памяти займет восемь байт.
[01:54:08.320 --> 01:54:10.320]  Это и позволяет бесконечные списки
[01:54:10.320 --> 01:54:12.320]  делать. То есть точно так же, как мы ленивые
[01:54:12.320 --> 01:54:14.320]  тейп-листы изобретали, в ренджах все
[01:54:14.320 --> 01:54:16.320]  вьюхи ленивые.
[01:54:16.320 --> 01:54:18.320]  И
[01:54:18.320 --> 01:54:20.320]  немножко про требования
[01:54:20.320 --> 01:54:22.320]  Йота-вью.
[01:54:22.320 --> 01:54:24.320]  Ну,
[01:54:24.320 --> 01:54:26.320]  я тут так писал.
[01:54:26.320 --> 01:54:28.320]  Йота-вью – это класс.
[01:54:28.320 --> 01:54:30.320]  Вот тот самый викли-инкрементабл, который
[01:54:30.320 --> 01:54:32.320]  мы все ждали.
[01:54:32.320 --> 01:54:34.320]  Тот тип, который мы из
[01:54:34.320 --> 01:54:36.320]  этой Йоты будем доставать,
[01:54:36.320 --> 01:54:38.320]  вот он указывает первым аргументом
[01:54:38.320 --> 01:54:40.320]  викли-инкрементабл.
[01:54:40.320 --> 01:54:42.320]  Может быть int, а может быть другой итератор.
[01:54:42.320 --> 01:54:44.320]  Внезапно можно сделать
[01:54:44.320 --> 01:54:46.320]  Йота-вью на все инкременты нашего
[01:54:46.320 --> 01:54:48.320]  итератора.
[01:54:48.320 --> 01:54:50.320]  И есть тиктри-баунд,
[01:54:50.320 --> 01:54:52.320]  который по дефолту там unreachable-sentinel,
[01:54:52.320 --> 01:54:54.320]  но может быть что-то другое,
[01:54:54.320 --> 01:54:56.320]  если вы там вдруг хотите что-то хитрое
[01:54:56.320 --> 01:54:58.320]  делать. Не уверен, зачем это нужно.
[01:55:00.320 --> 01:55:02.320]  Да, и внезапно еще самиреглар
[01:55:02.320 --> 01:55:04.320]  требуется поверх викли-инкрементабл.
[01:55:04.320 --> 01:55:06.320]  Что, ну,
[01:55:06.320 --> 01:55:08.320]  немножко странно, почему не требовать
[01:55:08.320 --> 01:55:10.320]  инкрементабл, но, видимо,
[01:55:10.320 --> 01:55:12.320]  не хотят.
[01:55:12.320 --> 01:55:14.320]  Так, про айстрим-вью.
[01:55:14.320 --> 01:55:16.320]  Вот такая штука.
[01:55:16.320 --> 01:55:18.320]  Вот представим,
[01:55:18.320 --> 01:55:20.320]  что из консоли ввели вот это вот.
[01:55:20.320 --> 01:55:22.320]  То есть какие-то флоты и какие-то
[01:55:22.320 --> 01:55:24.320]  символы пробелов там, странные.
[01:55:24.320 --> 01:55:26.320]  Вот это все, если что, это разные символы
[01:55:26.320 --> 01:55:28.320]  пробелов. Мы можем
[01:55:28.320 --> 01:55:30.320]  взять и сделать копии из айстрим-вью
[01:55:30.320 --> 01:55:32.320]  в
[01:55:32.320 --> 01:55:34.320]  oStream-итератор на cout и
[01:55:34.320 --> 01:55:36.320]  нам как бы распарсят
[01:55:36.320 --> 01:55:38.320]  флоты
[01:55:38.320 --> 01:55:40.320]  подряд идущие через пробел
[01:55:40.320 --> 01:55:42.320]  и сделают из них вьюху,
[01:55:42.320 --> 01:55:44.320]  а потом из этой вьюхи мы переложим
[01:55:44.320 --> 01:55:46.320]  все на выход, но уже через запятую.
[01:55:46.320 --> 01:55:48.320]  То есть, как бы,
[01:55:48.320 --> 01:55:50.320]  вот этот алгоритм, он все, что делает,
[01:55:50.320 --> 01:55:52.320]  это заменяет пробелы на запятые вот в этой строке.
[01:55:56.320 --> 01:55:58.320]  Где?
[01:55:58.320 --> 01:56:00.320]  Айстрим-вью и oStream-итератор?
[01:56:00.320 --> 01:56:02.320]  Ну, ты их один раз,
[01:56:02.320 --> 01:56:04.320]  скорее всего, в программе напишешь.
[01:56:04.320 --> 01:56:06.320]  Ты не так часто по айстриму
[01:56:06.320 --> 01:56:08.320]  итерируешься.
[01:56:08.320 --> 01:56:10.320]  Ну, вот, собственно, на этом все с тем, откуда брать вьюхи.
[01:56:10.320 --> 01:56:12.320]  На самом деле у вас должны закрадываться
[01:56:12.320 --> 01:56:14.320]  какие-то подозрения, что должно быть
[01:56:14.320 --> 01:56:16.320]  какое-то вью на целый контейнер.
[01:56:16.320 --> 01:56:18.320]  Но об этом чуть позже.
[01:56:18.320 --> 01:56:20.320]  Есть
[01:56:20.320 --> 01:56:22.320]  адаптеры.
[01:56:22.320 --> 01:56:24.320]  Адаптеры берут на вход другой,
[01:56:24.320 --> 01:56:26.320]  один рендж,
[01:56:26.320 --> 01:56:28.320]  один вью, на выход выдают другой вью.
[01:56:28.320 --> 01:56:30.320]  Ну, то есть, такие
[01:56:30.320 --> 01:56:32.320]  обертки над другим вью и делают
[01:56:32.320 --> 01:56:34.320]  какое-то преобразование.
[01:56:34.320 --> 01:56:36.320]  Фильтры transform, take,
[01:56:36.320 --> 01:56:38.320]  take while, все прочее. Кажется, эти слова
[01:56:38.320 --> 01:56:40.320]  мы уже где-то видели.
[01:56:40.320 --> 01:56:42.320]  Поэтому мы должны интуитивно понимать, что делают все эти вещи.
[01:56:42.320 --> 01:56:44.320]  Есть претензии к фильтру.
[01:56:44.320 --> 01:56:46.320]  К фильтру? Сейчас будет наша претензия
[01:56:46.320 --> 01:56:48.320]  к фильтру, не спилди, пожалуйста.
[01:56:48.320 --> 01:56:50.320]  К всему есть претензии.
[01:56:50.320 --> 01:56:52.320]  Тут везде все
[01:56:52.320 --> 01:56:54.320]  достаточно нетривиально.
[01:56:54.320 --> 01:56:56.320]  Ну, вот, дроп, ну, понятно,
[01:56:56.320 --> 01:56:58.320]  что такое. Дропнуть первые
[01:56:58.320 --> 01:57:00.320]  n элементов. Или там
[01:57:00.320 --> 01:57:02.320]  take. Это взять первые 5 элементов.
[01:57:02.320 --> 01:57:04.320]  То есть, например, вы можете сделать
[01:57:04.320 --> 01:57:06.320]  бесконечный список на все натуральные числа,
[01:57:06.320 --> 01:57:08.320]  а потом сделать take 5.
[01:57:08.320 --> 01:57:10.320]  И возьмете первые 5.
[01:57:10.320 --> 01:57:12.320]  Ну, вот, начиная с этих
[01:57:12.320 --> 01:57:14.320]  адаптеров,
[01:57:14.320 --> 01:57:16.320]  начинаются танцы с бубном,
[01:57:16.320 --> 01:57:18.320]  с тем, как их вызывать.
[01:57:18.320 --> 01:57:20.320]  Потому что, вообще говоря,
[01:57:20.320 --> 01:57:22.320]  вообще говоря, это все классы.
[01:57:22.320 --> 01:57:24.320]  И вы можете спокойно создать инстинкты с этого класса,
[01:57:24.320 --> 01:57:26.320]  вызовы конструктора, и все будет работать,
[01:57:26.320 --> 01:57:28.320]  как вот здесь написано. То есть, фильтр view,
[01:57:28.320 --> 01:57:30.320]  вы ему даете какой-то range или view,
[01:57:30.320 --> 01:57:32.320]  и он
[01:57:32.320 --> 01:57:34.320]  не какой-то предикат,
[01:57:34.320 --> 01:57:36.320]  он фильтрует.
[01:57:36.320 --> 01:57:38.320]  Можете написать
[01:57:38.320 --> 01:57:40.320]  просто фильтр. Можете
[01:57:40.320 --> 01:57:42.320]  написать фильтр и аргументы
[01:57:42.320 --> 01:57:44.320]  переставить местами и в круглых скобках
[01:57:44.320 --> 01:57:46.320]  написать. А можете
[01:57:46.320 --> 01:57:48.320]  range, который вы запихиваете,
[01:57:48.320 --> 01:57:50.320]  пайпнуть, как в башее,
[01:57:50.320 --> 01:57:52.320]  в фильтр от предиката.
[01:57:54.320 --> 01:57:56.320]  Да, это самый крутой способ,
[01:57:56.320 --> 01:57:58.320]  потому что это вам позволяет делать длинные
[01:57:58.320 --> 01:58:00.320]  пайплайны обработки данных.
[01:58:00.320 --> 01:58:02.320]  Прекрасно читаемые.
[01:58:02.320 --> 01:58:04.320]  Слева-направо читаешь?
[01:58:04.320 --> 01:58:06.320]  Нет, на новой строчке.
[01:58:06.320 --> 01:58:08.320]  Сейчас, короче, будет пример.
[01:58:08.320 --> 01:58:10.320]  Сейчас пример будет, как это выглядит.
[01:58:10.320 --> 01:58:12.320]  Пока давайте
[01:58:12.320 --> 01:58:14.320]  с тем, что вот это вот за шняга такая.
[01:58:14.320 --> 01:58:16.320]  Вот это вот range adapter object называется.
[01:58:16.320 --> 01:58:18.320]  И он не bloat.
[01:58:18.320 --> 01:58:20.320]  Не точка кастомизации.
[01:58:20.320 --> 01:58:22.320]  Вот фильтр
[01:58:22.320 --> 01:58:24.320]  begin-end были точками
[01:58:24.320 --> 01:58:26.320]  кастомизации, а это нет. Это просто
[01:58:26.320 --> 01:58:28.320]  не bloat.
[01:58:28.320 --> 01:58:30.320]  И вызвать его можно от двух аргументов,
[01:58:30.320 --> 01:58:32.320]  можно от одного.
[01:58:32.320 --> 01:58:34.320]  То есть это вот объект, у которого есть
[01:58:34.320 --> 01:58:36.320]  деператор круглые скобки, с двумя аргументами,
[01:58:36.320 --> 01:58:38.320]  а также с одним.
[01:58:38.320 --> 01:58:40.320]  И если вы вызовите его с одним
[01:58:40.320 --> 01:58:42.320]  аргументом, вам вернут то, что называется
[01:58:42.320 --> 01:58:44.320]  range adapter closure.
[01:58:44.320 --> 01:58:46.320]  Замыкание.
[01:58:46.320 --> 01:58:48.320]  То есть мы
[01:58:48.320 --> 01:58:50.320]  как бы вернули
[01:58:50.320 --> 01:58:52.320]  лямду, по сути,
[01:58:52.320 --> 01:58:54.320]  у которой уже зафиксирован первый аргумент
[01:58:54.320 --> 01:58:56.320]  предикат.
[01:58:56.320 --> 01:58:58.320]  А вот такой синтаксис позволяет эту лямду
[01:58:58.320 --> 01:59:00.320]  вызвать от range.
[01:59:00.320 --> 01:59:02.320]  Ну или можно просто как обычную функцию вызвать.
[01:59:02.320 --> 01:59:04.320]  Коррирование.
[01:59:04.320 --> 01:59:06.320]  Говорили мы с вами про коррирование что-нибудь?
[01:59:06.320 --> 01:59:08.320]  Ну вот это оно.
[01:59:08.320 --> 01:59:10.320]  Ну вот мы
[01:59:10.320 --> 01:59:12.320]  захотели применить частично
[01:59:12.320 --> 01:59:14.320]  функцию, только к одному аргументу.
[01:59:14.320 --> 01:59:16.320]  Один зафиксировать, другой оставить.
[01:59:16.320 --> 01:59:18.320]  Так, всем кроме первого.
[01:59:18.320 --> 01:59:20.320]  Ну это коррирование.
[01:59:20.320 --> 01:59:22.320]  Почему удивленный взгляд такой?
[01:59:22.320 --> 01:59:24.320]  Ну вот не коррированная версия.
[01:59:24.320 --> 01:59:26.320]  Вот коррированная версия.
[01:59:26.320 --> 01:59:28.320]  Ты вызвал только от предиката.
[01:59:28.320 --> 01:59:30.320]  Тебе вернули функциональный объект.
[01:59:30.320 --> 01:59:32.320]  У которого уже один аргумент.
[01:59:32.320 --> 01:59:34.320]  Range.
[01:59:34.320 --> 01:59:36.320]  Ровно коррирование.
[01:59:36.320 --> 01:59:38.320]  Можешь.
[01:59:38.320 --> 01:59:40.320]  Можешь сохранить переменную
[01:59:40.320 --> 01:59:42.320]  и потом куда-то пихнуть
[01:59:42.320 --> 01:59:44.320]  или вызвать.
[01:59:44.320 --> 01:59:46.320]  Да.
[01:59:46.320 --> 01:59:48.320]  Все эти строчки эквалентны.
[01:59:48.320 --> 01:59:50.320]  Все это одно и то же значение.
[01:59:50.320 --> 01:59:52.320]  Все, пропало удивление.
[01:59:52.320 --> 01:59:54.320]  Давайте дальше.
[01:59:54.320 --> 01:59:56.320]  А, да.
[01:59:56.320 --> 01:59:58.320]  Тут тоже прям явно написано,
[01:59:58.320 --> 02:00:00.320]  что C это название
[02:00:00.320 --> 02:00:02.320]  какого-то адаптера.
[02:00:02.320 --> 02:00:04.320]  И тогда вот C подчеркивание вью,
[02:00:04.320 --> 02:00:06.320]  C от аргументов, C от коррированных
[02:00:06.320 --> 02:00:08.320]  аргументов и вот такой пайп.
[02:00:08.320 --> 02:00:10.320]  Оно все эквивалентно.
[02:00:10.320 --> 02:00:12.320]  То есть для всех, что я там показывал,
[02:00:12.320 --> 02:00:14.320]  фильтр, дробь,
[02:00:14.320 --> 02:00:16.320]  все это эквивалентно.
[02:00:16.320 --> 02:00:18.320]  То есть все это эквивалентно.
[02:00:18.320 --> 02:00:20.320]  То есть для всех, что я там показывал,
[02:00:20.320 --> 02:00:22.320]  фильтр, дробь, тейк, трансформ.
[02:00:22.320 --> 02:00:24.320]  Че?
[02:00:24.320 --> 02:00:26.320]  Нет, стрим это
[02:00:26.320 --> 02:00:28.320]  айстрим вью.
[02:00:28.320 --> 02:00:30.320]  Это не адаптер.
[02:00:30.320 --> 02:00:32.320]  Это фактори, да.
[02:00:32.320 --> 02:00:34.320]  Адаптер они берут один вью на вход
[02:00:34.320 --> 02:00:36.320]  или один рендж на вход и возвращают вью.
[02:00:36.320 --> 02:00:38.320]  То есть вот это вот просто
[02:00:38.320 --> 02:00:40.320]  некорректное будет определение
[02:00:40.320 --> 02:00:42.320]  для того, что не является адаптером.
[02:00:42.320 --> 02:00:44.320]  Потому что всегда первый аргумент на вход
[02:00:44.320 --> 02:00:46.320]  это другой рендж.
[02:00:46.320 --> 02:00:48.320]  Все остальные аргументы не коррируются.
[02:00:48.320 --> 02:00:50.320]  Руками закостыли на да.
[02:00:54.320 --> 02:00:56.320]  Примерчик, по-моему, у нас.
[02:00:56.320 --> 02:00:58.320]  Вот мы взяли йота 0.
[02:00:58.320 --> 02:01:00.320]  Это все числа натуральные.
[02:01:00.320 --> 02:01:02.320]  Ну, матложные натуральные числа.
[02:01:02.320 --> 02:01:04.320]  С нуля начинаем.
[02:01:04.320 --> 02:01:06.320]  Палка, фильтр.
[02:01:06.320 --> 02:01:08.320]  Ну вообще рекомендуется палку на следующей строке писать.
[02:01:08.320 --> 02:01:10.320]  Я не знаю, почему тут на этой же написано.
[02:01:10.320 --> 02:01:12.320]  В общем, запихнули йоту
[02:01:12.320 --> 02:01:14.320]  в фильтр, который
[02:01:14.320 --> 02:01:16.320]  выкинет элементы,
[02:01:16.320 --> 02:01:18.320]  которые
[02:01:18.320 --> 02:01:20.320]  не 0 по моделю 3.
[02:01:20.320 --> 02:01:22.320]  Наоборот.
[02:01:22.320 --> 02:01:24.320]  Наоборот оставят те, которые
[02:01:24.320 --> 02:01:26.320]  выкинет то, что по моделю 3
[02:01:26.320 --> 02:01:28.320]  ноль.
[02:01:28.320 --> 02:01:30.320]  Это все еще вьюшка.
[02:01:30.320 --> 02:01:32.320]  Одна вьюшка стала другая, теперь третья.
[02:01:38.320 --> 02:01:40.320]  Ты о правильных вещах думаешь.
[02:01:40.320 --> 02:01:42.320]  Но ты не дошел до истины пока.
[02:01:42.320 --> 02:01:44.320]  Сейчас дойдем.
[02:01:44.320 --> 02:01:46.320]  Трансформ, ну это как мап.
[02:01:46.320 --> 02:01:48.320]  Вот в задачи тайп-листов оно мап
[02:01:48.320 --> 02:01:50.320]  называлось.
[02:01:50.320 --> 02:01:52.320]  Пока да.
[02:01:52.320 --> 02:01:54.320]  Это важно, кстати, почувствовать
[02:01:54.320 --> 02:01:56.320]  душой. Все эти вещи,
[02:01:56.320 --> 02:01:58.320]  они не запускаются
[02:01:58.320 --> 02:02:00.320]  вообще. Они конструируют
[02:02:00.320 --> 02:02:02.320]  некоторую сложную луковицу из вью,
[02:02:02.320 --> 02:02:04.320]  которая оборачивает вью,
[02:02:04.320 --> 02:02:06.320]  причем все они оборачивают друг друга
[02:02:06.320 --> 02:02:08.320]  шаблонно.
[02:02:08.320 --> 02:02:10.320]  Нет.
[02:02:10.320 --> 02:02:12.320]  Уходи со своими сэндерами.
[02:02:12.320 --> 02:02:14.320]  Не пугай детей.
[02:02:14.320 --> 02:02:16.320]  Были.
[02:02:16.320 --> 02:02:18.320]  Забыли уже.
[02:02:18.320 --> 02:02:20.320]  Троп-пайл.
[02:02:20.320 --> 02:02:22.320]  И выкинули первые
[02:02:22.320 --> 02:02:24.320]  несколько элементов.
[02:02:24.320 --> 02:02:26.320]  Все, которые меньше 20.
[02:02:26.320 --> 02:02:28.320]  Пускай троп-пайл что-то или нет.
[02:02:28.320 --> 02:02:30.320]  Правильные вопросы
[02:02:30.320 --> 02:02:32.320]  сдаешь. Я на них пока ответов не даю.
[02:02:34.320 --> 02:02:36.320]  Взяли тейк 5.
[02:02:36.320 --> 02:02:38.320]  И вот получили.
[02:02:40.320 --> 02:02:42.320]  То есть, в какой момент все эти
[02:02:42.320 --> 02:02:44.320]  вычисления, которые мы здесь написали,
[02:02:44.320 --> 02:02:46.320]  запускаются?
[02:02:46.320 --> 02:02:48.320]  Вот только здесь, да.
[02:02:48.320 --> 02:02:50.320]  Да,
[02:02:50.320 --> 02:02:52.320]  все эти вычисления...
[02:02:52.320 --> 02:02:54.320]  Интуитивно
[02:02:54.320 --> 02:02:56.320]  все эти вычисления запускаются только в момент,
[02:02:56.320 --> 02:02:58.320]  когда мы начали итерироваться.
[02:02:58.320 --> 02:03:00.320]  Причем более того, каждый элемент
[02:03:00.320 --> 02:03:02.320]  лениво вычисляется.
[02:03:04.320 --> 02:03:06.320]  Очень просто.
[02:03:06.320 --> 02:03:08.320]  Все эти ребята запоминают
[02:03:08.320 --> 02:03:10.320]  в новом типе,
[02:03:10.320 --> 02:03:12.320]  какую операцию они должны произвести,
[02:03:12.320 --> 02:03:14.320]  и какая операция была предыдущая.
[02:03:14.320 --> 02:03:16.320]  Что-то типа того.
[02:03:16.320 --> 02:03:18.320]  Ну да,
[02:03:18.320 --> 02:03:20.320]  потому что здесь все статическое.
[02:03:20.320 --> 02:03:22.320]  Потому что ты буквально,
[02:03:22.320 --> 02:03:24.320]  когда ты делаешь фильтр от вот этой йоты,
[02:03:24.320 --> 02:03:26.320]  у тебя в тип
[02:03:26.320 --> 02:03:28.320]  вьюхи, которая вернет вот эту функцию,
[02:03:28.320 --> 02:03:30.320]  вшивается, что
[02:03:30.320 --> 02:03:32.320]  у нее есть поле йота,
[02:03:32.320 --> 02:03:34.320]  и эта йота там хранится просто как элемент.
[02:03:34.320 --> 02:03:36.320]  Ну и...
[02:03:36.320 --> 02:03:38.320]  Вот это все в шаблонах.
[02:03:38.320 --> 02:03:40.320]  Потом все схлопывается и оптимизируется,
[02:03:40.320 --> 02:03:42.320]  и тут оверхеда ноль.
[02:03:42.320 --> 02:03:44.320]  Вот этот код работает с такой же скоростью,
[02:03:44.320 --> 02:03:46.320]  как если бы вы руками написали тот же код на C
[02:03:46.320 --> 02:03:48.320]  или даже быстрее.
[02:03:48.320 --> 02:03:50.320]  Ну то есть, вот сейчас про
[02:03:50.320 --> 02:03:52.320]  InlineLand,
[02:03:52.320 --> 02:03:54.320]  если в том же фильтр у меня вот там
[02:03:54.320 --> 02:03:56.320]  процент 3,
[02:03:56.320 --> 02:03:58.320]  если у меня это процент N,
[02:03:58.320 --> 02:04:00.320]  и N вводится из консоли.
[02:04:00.320 --> 02:04:02.320]  Да все равно инлайнится.
[02:04:02.320 --> 02:04:04.320]  Инлайнится не значит предпочитываться
[02:04:04.320 --> 02:04:06.320]  инлайн просто значит, что здесь
[02:04:06.320 --> 02:04:08.320]  очень хорошо заоптимизируется код
[02:04:08.320 --> 02:04:10.320]  до цикла, в котором все вот
[02:04:10.320 --> 02:04:12.320]  как бы вот прям вот здесь в цикле
[02:04:12.320 --> 02:04:14.320]  будет высчитываться следующий элемент последовательности.
[02:04:14.320 --> 02:04:16.320]  То есть нужного функции тут ни одного не будет?
[02:04:16.320 --> 02:04:18.320]  Ну да, да, да.
[02:04:18.320 --> 02:04:20.320]  Ни одного.
[02:04:20.320 --> 02:04:22.320]  Ленивость за счет того,
[02:04:22.320 --> 02:04:24.320]  что ничего мы не вычисляем.
[02:04:24.320 --> 02:04:26.320]  Мы просто строим сложный объект вью,
[02:04:26.320 --> 02:04:28.320]  в который внутри как-то зашита
[02:04:28.320 --> 02:04:30.320]  схема, по которой считать его
[02:04:30.320 --> 02:04:32.320]  элементы. Вот внутри вью...
[02:04:32.320 --> 02:04:34.320]  А это runtime scheme или compile time scheme?
[02:04:34.320 --> 02:04:36.320]  Наполовину compile time,
[02:04:36.320 --> 02:04:38.320]  наполовину runtime, потому что такие вещи
[02:04:38.320 --> 02:04:40.320]  как вот этот ноль,
[02:04:40.320 --> 02:04:42.320]  он как бы runtime прокидываться должен,
[02:04:42.320 --> 02:04:44.320]  а вот в каком порядке
[02:04:44.320 --> 02:04:46.320]  мы операции применяли,
[02:04:46.320 --> 02:04:48.320]  это compile time.
[02:04:48.320 --> 02:04:50.320]  Давайте, да,
[02:04:50.320 --> 02:04:52.320]  небольшой комментарий, вот это вот мусор,
[02:04:52.320 --> 02:04:54.320]  вот эти символы выделенные,
[02:04:54.320 --> 02:04:56.320]  их надо выкинуть отсюда.
[02:04:56.320 --> 02:04:58.320]  И тогда язык будет хороший.
[02:04:58.320 --> 02:05:00.320]  Никак. В том-то и проблема.
[02:05:00.320 --> 02:05:02.320]  То есть пока что у нас немножко плоховатый
[02:05:02.320 --> 02:05:04.320]  язык на самом деле.
[02:05:04.320 --> 02:05:06.320]  Ноль должен прокидываться в compile time,
[02:05:06.320 --> 02:05:08.320]  а... На самом деле, да, тут все вы записаны
[02:05:08.320 --> 02:05:10.320]  новыми символами выражения.
[02:05:10.320 --> 02:05:12.320]  Да. Вообще тут весь будет numbers,
[02:05:12.320 --> 02:05:14.320]  он его константный, если не шавайзер.
[02:05:14.320 --> 02:05:16.320]  Да, да, да, по факту все будет
[02:05:16.320 --> 02:05:18.320]  в compile time, но теоретически мы могли с консоли
[02:05:18.320 --> 02:05:20.320]  ввести первые элементы, тогда вот эта штука
[02:05:20.320 --> 02:05:22.320]  это очевидно должно быть прям поле.
[02:05:22.320 --> 02:05:24.320]  То есть переводы определяются в compile time,
[02:05:24.320 --> 02:05:26.320]  а вот то откуда,
[02:05:26.320 --> 02:05:28.320]  то сколько раз...
[02:05:28.320 --> 02:05:30.320]  Да, там прям есть поля.
[02:05:30.320 --> 02:05:32.320]  Да, runtime поля, сколько,
[02:05:32.320 --> 02:05:34.320]  чего, куда.
[02:05:34.320 --> 02:05:36.320]  Сейчас мы посмотрим на то, как это разворачивается.
[02:05:36.320 --> 02:05:38.320]  Да, можем
[02:05:38.320 --> 02:05:40.320]  взять 10, можем взять 5,
[02:05:40.320 --> 02:05:42.320]  все это будет работать, то есть можно даже
[02:05:42.320 --> 02:05:44.320]  переиспользовать эту вьюху.
[02:05:46.320 --> 02:05:48.320]  Окей.
[02:05:48.320 --> 02:05:50.320]  Что там дальше?
[02:05:52.320 --> 02:05:54.320]  Вопрос.
[02:05:54.320 --> 02:05:56.320]  А...
[02:05:56.320 --> 02:05:58.320]  Да, это концепт range,
[02:05:58.320 --> 02:06:00.320]  все, у меня мозговой затоп
[02:06:00.320 --> 02:06:02.320]  произошел, выведет ли нам true или false?
[02:06:04.320 --> 02:06:06.320]  Видите код, вот vector сделали,
[02:06:06.320 --> 02:06:08.320]  vv, decal type
[02:06:08.320 --> 02:06:10.320]  его является range'ом?
[02:06:12.320 --> 02:06:14.320]  Ну, это без подвоха пока.
[02:06:14.320 --> 02:06:16.320]  Всегда первый вопрос
[02:06:16.320 --> 02:06:18.320]  без подвоха. Да, действительно, range все нормально.
[02:06:18.320 --> 02:06:20.320]  А вот
[02:06:20.320 --> 02:06:22.320]  вьюха является vector?
[02:06:22.320 --> 02:06:24.320]  Не является,
[02:06:24.320 --> 02:06:26.320]  потому что нет enable view,
[02:06:26.320 --> 02:06:28.320]  потому что копирование не зовут единицы.
[02:06:28.320 --> 02:06:30.320]  А вот этот вот, я
[02:06:30.320 --> 02:06:32.320]  пофильтровал этот vector и получил
[02:06:32.320 --> 02:06:34.320]  какую-то шнягу.
[02:06:34.320 --> 02:06:36.320]  Вот она view, да?
[02:06:36.320 --> 02:06:38.320]  Тут range спрашивают.
[02:06:38.320 --> 02:06:40.320]  Да, и range тоже.
[02:06:40.320 --> 02:06:42.320]  И view тоже, но потому что даже
[02:06:42.320 --> 02:06:44.320]  название как-то, filter view, вот это все.
[02:06:44.320 --> 02:06:46.320]  Окей.
[02:06:46.320 --> 02:06:48.320]  Ну, пока все более-менее очевидно.
[02:06:48.320 --> 02:06:50.320]  Подожди, то есть можно
[02:06:50.320 --> 02:06:52.320]  использовать vector в view,
[02:06:52.320 --> 02:06:54.320]  если применить filter,
[02:06:54.320 --> 02:06:56.320]  который всегда true возвращает?
[02:06:56.320 --> 02:06:58.320]  Есть более нормальный способ.
[02:06:58.320 --> 02:07:00.320]  Есть более нормальный способ.
[02:07:00.320 --> 02:07:02.320]  Вообще я сказал, что вьюхи принимают
[02:07:02.320 --> 02:07:04.320]  на вход другие, ну, view адаптеры
[02:07:04.320 --> 02:07:06.320]  принимают на вход другие вьюхи.
[02:07:06.320 --> 02:07:08.320]  А здесь у нас каким-то волшебным образом
[02:07:08.320 --> 02:07:10.320]  vector, какой-то range,
[02:07:10.320 --> 02:07:12.320]  не вьюха, сконвертировался во вьюху.
[02:07:12.320 --> 02:07:14.320]  Вот этот волшебный образ пока
[02:07:14.320 --> 02:07:16.320]  за скобками отпускаем,
[02:07:16.320 --> 02:07:18.320]  сейчас дойдем до него.
[02:07:18.320 --> 02:07:20.320]  Вот так летит по векторам,
[02:07:20.320 --> 02:07:22.320]  например, вектор, то результат
[02:07:22.320 --> 02:07:24.320]  затирается, походу затирается вектор.
[02:07:24.320 --> 02:07:26.320]  Сейчас поговорим про это.
[02:07:26.320 --> 02:07:28.320]  Сейчас поговорим про это.
[02:07:28.320 --> 02:07:30.320]  Ты в правильную сторону копаешь,
[02:07:30.320 --> 02:07:32.320]  и тебя ожидает разочарование в жизни.
[02:07:32.320 --> 02:07:34.320]  В жизни или в плюсах?
[02:07:34.320 --> 02:07:36.320]  В плюсах в жизни не уверен.
[02:07:36.320 --> 02:07:38.320]  Вот, про типы.
[02:07:38.320 --> 02:07:40.320]  Все, наконец-то про типы чуть-чуть поговорим.
[02:07:40.320 --> 02:07:42.320]  Вот это вот
[02:07:42.320 --> 02:07:44.320]  от элемента нечетное.
[02:07:44.320 --> 02:07:46.320]  Тип какой будет?
[02:07:46.320 --> 02:07:48.320]  Вот эту штуку вы должны были уже
[02:07:48.320 --> 02:07:50.320]  видеть где-то.
[02:07:50.320 --> 02:07:52.320]  Подвох в том, что 25 и 26
[02:07:52.320 --> 02:07:54.320]  выбраны неправильно.
[02:07:54.320 --> 02:07:56.320]  Подвоха
[02:07:56.320 --> 02:07:58.320]  нету.
[02:07:58.320 --> 02:08:00.320]  Это pretty function,
[02:08:00.320 --> 02:08:02.320]  мы про него говорили, он позволяет нам
[02:08:02.320 --> 02:08:04.320]  посмотреть к строку типа.
[02:08:04.320 --> 02:08:06.320]  Давайте ее посмотрим.
[02:08:06.320 --> 02:08:08.320]  Строка будет вот такая.
[02:08:08.320 --> 02:08:10.320]  FilterView от refView,
[02:08:10.320 --> 02:08:12.320]  от вектора
[02:08:12.320 --> 02:08:14.320]  и лямбда.
[02:08:14.320 --> 02:08:16.320]  То есть внимание,
[02:08:16.320 --> 02:08:18.320]  мы в FilterView
[02:08:18.320 --> 02:08:20.320]  вот здесь запихали сколько аргументов?
[02:08:20.320 --> 02:08:22.320]  Два. Во-первых, вектора,
[02:08:22.320 --> 02:08:24.320]  во-вторых, лямбду.
[02:08:24.320 --> 02:08:26.320]  И типы обоих этих аргументов
[02:08:26.320 --> 02:08:28.320]  вшились в тип FilterView.
[02:08:28.320 --> 02:08:30.320]  К вопросу, за счет чего
[02:08:30.320 --> 02:08:32.320]  эта ленивость достигается.
[02:08:32.320 --> 02:08:34.320]  За счет того, что у нас
[02:08:34.320 --> 02:08:36.320]  типы аргументов каждого адаптера
[02:08:36.320 --> 02:08:38.320]  вшиваются в тип самого шаблона адаптера.
[02:08:38.320 --> 02:08:40.320]  И хранятся как поля,
[02:08:40.320 --> 02:08:42.320]  соответственно, то, что нам прислали.
[02:08:42.320 --> 02:08:44.320]  И мы все статически
[02:08:44.320 --> 02:08:46.320]  в compile-time композируем
[02:08:46.320 --> 02:08:48.320]  в одну большую толстую структуру
[02:08:48.320 --> 02:08:50.320]  без всяких динамических локаций
[02:08:50.320 --> 02:08:52.320]  или виртуальных каких-то функций.
[02:08:52.320 --> 02:08:54.320]  И компилятор это все в пух и прах
[02:08:54.320 --> 02:08:56.320]  рвет и все работает.
[02:08:56.320 --> 02:08:58.320]  И оптимизится отлично.
[02:08:58.320 --> 02:09:00.320]  Тут возникает
[02:09:00.320 --> 02:09:02.320]  вопрос к этому.
[02:09:02.320 --> 02:09:04.320]  Казалось бы, мы передали просто вектор
[02:09:04.320 --> 02:09:06.320]  на вход, а он обернулся у нас в refView
[02:09:06.320 --> 02:09:08.320]  какой-то автоматом.
[02:09:08.320 --> 02:09:10.320]  Но кажется, мы не сейчас
[02:09:10.320 --> 02:09:12.320]  будем говорить про это.
[02:09:12.320 --> 02:09:14.320]  Чуть позже.
[02:09:14.320 --> 02:09:16.320]  Но тем не менее, догадаться можно,
[02:09:16.320 --> 02:09:18.320]  что это, наверное, view на весь вектор,
[02:09:18.320 --> 02:09:20.320]  но почему он здесь и почему не как-то по-другому
[02:09:20.320 --> 02:09:22.320]  рассказ позже будет.
[02:09:22.320 --> 02:09:24.320]  Да, вот мы с этим
[02:09:24.320 --> 02:09:26.320]  разобрались, да.
[02:09:26.320 --> 02:09:28.320]  Кто view, кто range.
[02:09:28.320 --> 02:09:30.320]  Теперь начинаем творить непотребство.
[02:09:30.320 --> 02:09:32.320]  Const.Vector является ли он
[02:09:32.320 --> 02:09:34.320]  range'ом и является ли view'хой?
[02:09:38.320 --> 02:09:40.320]  Const.Vector является view'хой.
[02:09:44.320 --> 02:09:46.320]  Так тут пока про сам vv,
[02:09:46.320 --> 02:09:48.320]  вектор.
[02:09:48.320 --> 02:09:50.320]  Ну да, ничего не поменялось.
[02:09:52.320 --> 02:09:54.320]  А теперь про od.
[02:10:08.320 --> 02:10:10.320]  Как будто бы
[02:10:10.320 --> 02:10:12.320]  не должно ничего поменяться.
[02:10:12.320 --> 02:10:14.320]  Два человека заявляют
[02:10:14.320 --> 02:10:16.320]  провокационно, что это
[02:10:16.320 --> 02:10:18.320]  не является range'ом. Почему вы так думаете?
[02:10:22.320 --> 02:10:24.320]  Const.View у нас.
[02:10:24.320 --> 02:10:26.320]  То есть вектор, он обычный.
[02:10:26.320 --> 02:10:28.320]  Const.View.
[02:10:32.320 --> 02:10:34.320]  И range'ом и view осталось.
[02:10:34.320 --> 02:10:36.320]  Андрей, ты не давай подсказок.
[02:10:38.320 --> 02:10:40.320]  Ну ты, скорее всего, додумаешься правильно.
[02:10:40.320 --> 02:10:42.320]  Людям, которые впервые это слушают,
[02:10:42.320 --> 02:10:44.320]  подумать.
[02:10:44.320 --> 02:10:46.320]  Там что-то с move'ом, нет?
[02:10:46.320 --> 02:10:48.320]  С move'ом?
[02:10:48.320 --> 02:10:50.320]  Ну нет, технически
[02:10:50.320 --> 02:10:52.320]  все равно даже const можно
[02:10:52.320 --> 02:10:54.320]  move'ать и копировать это все можно.
[02:10:54.320 --> 02:10:56.320]  Нет, не с этим проблема.
[02:10:58.320 --> 02:11:00.320]  Да-да-да, там все стандартные view'и, они
[02:11:00.320 --> 02:11:02.320]  копия был, по-моему, и поэтому
[02:11:02.320 --> 02:11:04.320]  просто вместо move'а копия будет.
[02:11:04.320 --> 02:11:06.320]  А в чем проблема?
[02:11:06.320 --> 02:11:08.320]  А вот в чем.
[02:11:08.320 --> 02:11:10.320]  Действительно, внезапно
[02:11:10.320 --> 02:11:12.320]  это не будет являться ни range'ом,
[02:11:12.320 --> 02:11:14.320]  ни view'ой.
[02:11:14.320 --> 02:11:16.320]  Просто const навесили, оно уже не range.
[02:11:16.320 --> 02:11:18.320]  Давайте часать репы
[02:11:18.320 --> 02:11:20.320]  и вспоминать, какие требования были к range'у.
[02:11:22.320 --> 02:11:24.320]  Begin и end.
[02:11:24.320 --> 02:11:26.320]  Они const должны быть.
[02:11:26.320 --> 02:11:28.320]  Non-modifying, begin и end.
[02:11:28.320 --> 02:11:30.320]  И за от единицы работают.
[02:11:30.320 --> 02:11:32.320]  Что-то из этого
[02:11:32.320 --> 02:11:34.320]  именно у filter view
[02:11:34.320 --> 02:11:36.320]  нарушается.
[02:11:36.320 --> 02:11:38.320]  Каширование
[02:11:38.320 --> 02:11:40.320]  за от единицы.
[02:11:40.320 --> 02:11:42.320]  Вот.
[02:11:42.320 --> 02:11:44.320]  Теперь нужно, чтобы все остальные поняли.
[02:11:44.320 --> 02:11:46.320]  Да, вот у нас такой концепт
[02:11:46.320 --> 02:11:48.320]  был.
[02:11:48.320 --> 02:11:50.320]  И внезапно, внезапно,
[02:11:50.320 --> 02:11:52.320]  тут вот такое требуется,
[02:11:52.320 --> 02:11:54.320]  тыры-пыры, внезапно
[02:11:54.320 --> 02:11:56.320]  у begin и end
[02:11:56.320 --> 02:11:58.320]  у filter view
[02:11:58.320 --> 02:12:00.320]  нету константных перегрузок.
[02:12:00.320 --> 02:12:02.320]  Вот у них begin и end
[02:12:02.320 --> 02:12:04.320]  они модифицируют что-то.
[02:12:04.320 --> 02:12:06.320]  У filter view и еще у нескольких
[02:12:06.320 --> 02:12:08.320]  вот filter view, drop while view,
[02:12:08.320 --> 02:12:10.320]  drop view.
[02:12:10.320 --> 02:12:12.320]  У всех из них begin и end
[02:12:12.320 --> 02:12:14.320]  что-то внутри модифицируют.
[02:12:14.320 --> 02:12:16.320]  С как бы общечеловеческого
[02:12:16.320 --> 02:12:18.320]  точки зрения они non-modifying,
[02:12:18.320 --> 02:12:20.320]  но при этом
[02:12:20.320 --> 02:12:22.320]  они не могут быть range'ом,
[02:12:22.320 --> 02:12:24.320]  если на них const навесить тогда.
[02:12:24.320 --> 02:12:26.320]  Да, вопрос.
[02:12:26.320 --> 02:12:28.320]  А как у этих
[02:12:28.320 --> 02:12:30.320]  view за от единицы считается
[02:12:30.320 --> 02:12:32.320]  begin? Задумайтесь.
[02:12:32.320 --> 02:12:34.320]  Вот оно место для использования mutable
[02:12:34.320 --> 02:12:36.320]  в структу.
[02:12:36.320 --> 02:12:38.320]  Казалось бы, но нет.
[02:12:38.320 --> 02:12:40.320]  Давайте, как посчитать
[02:12:40.320 --> 02:12:42.320]  begin у filter view?
[02:12:44.320 --> 02:12:46.320]  Идти вперед, пока не найдем подходящую.
[02:12:48.320 --> 02:12:50.320]  Будет ли это амортизированного
[02:12:50.320 --> 02:12:52.320]  от единиц? Не будет.
[02:12:52.320 --> 02:12:54.320]  Мы каждый раз можем до конца дойти и ничего не найти.
[02:12:54.320 --> 02:12:56.320]  При конструировании
[02:12:56.320 --> 02:12:58.320]  по-моему нельзя,
[02:12:58.320 --> 02:13:00.320]  а может и можно.
[02:13:00.320 --> 02:13:02.320]  Почему
[02:13:02.320 --> 02:13:04.320]  при конструировании
[02:13:04.320 --> 02:13:06.320]  нельзя считать?
[02:13:06.320 --> 02:13:08.320]  Конструирование за от единицы
[02:13:08.320 --> 02:13:10.320]  должно быть, да.
[02:13:10.320 --> 02:13:12.320]  Конструктор у view всегда должен
[02:13:12.320 --> 02:13:14.320]  быть за от единицы.
[02:13:14.320 --> 02:13:16.320]  Амортизированного
[02:13:16.320 --> 02:13:18.320]  от единицы, а это другое.
[02:13:20.320 --> 02:13:22.320]  Амортизированно относительно 10 разных
[02:13:22.320 --> 02:13:24.320]  вызовов begin. Конструктор ты один раз
[02:13:24.320 --> 02:13:26.320]  вызываешь. Он тупо за от единицы
[02:13:26.320 --> 02:13:28.320]  работает строго.
[02:13:28.320 --> 02:13:30.320]  А begin работает амортизированно за от единицы.
[02:13:30.320 --> 02:13:32.320]  Если ты 10 раз
[02:13:32.320 --> 02:13:34.320]  разных begin вызываешь
[02:13:34.320 --> 02:13:36.320]  и делишь на 10, то должна константа получиться.
[02:13:36.320 --> 02:13:38.320]  Ну что мы сделаем?
[02:13:38.320 --> 02:13:40.320]  Мы в первом вызове begin пробежимся
[02:13:40.320 --> 02:13:42.320]  за линию и найдем этот begin
[02:13:42.320 --> 02:13:44.320]  и закашируем его внутри filter view.
[02:13:44.320 --> 02:13:46.320]  А в последующих
[02:13:46.320 --> 02:13:48.320]  begin мы просто будем из каша доставать.
[02:13:48.320 --> 02:13:50.320]  Вот мы амортизировали.
[02:13:52.320 --> 02:13:54.320]  Я не знаю, почему.
[02:13:54.320 --> 02:13:56.320]  Не mutable.
[02:13:56.320 --> 02:13:58.320]  Может там
[02:13:58.320 --> 02:14:00.320]  оптимизация уйдет.
[02:14:00.320 --> 02:14:02.320]  Меня самого этот вопрос интересует,
[02:14:02.320 --> 02:14:04.320]  но вот говорят
[02:14:04.320 --> 02:14:06.320]  mutable плохо.
[02:14:06.320 --> 02:14:08.320]  Более конкретного нет у меня.
[02:14:08.320 --> 02:14:10.320]  Ну в этих тоже понятно, что тоже самое
[02:14:10.320 --> 02:14:12.320]  происходит, да.
[02:14:12.320 --> 02:14:14.320]  Но только drop view со звездочкой.
[02:14:14.320 --> 02:14:16.320]  Почему со звездочкой?
[02:14:16.320 --> 02:14:18.320]  Ну drop view
[02:14:18.320 --> 02:14:20.320]  дропает первые 10 элементов, скажем.
[02:14:20.320 --> 02:14:22.320]  Да, если
[02:14:22.320 --> 02:14:24.320]  итератор у нас нормальный,
[02:14:24.320 --> 02:14:26.320]  там contiguous или random access даже,
[02:14:26.320 --> 02:14:28.320]  мы можем на 10 элементов вперед
[02:14:28.320 --> 02:14:30.320]  продвинуть и все. Больше ничего делать
[02:14:30.320 --> 02:14:32.320]  не надо.
[02:14:32.320 --> 02:14:34.320]  Что?
[02:14:34.320 --> 02:14:36.320]  Да, да.
[02:14:36.320 --> 02:14:38.320]  Cons drop view будет нормальной view
[02:14:38.320 --> 02:14:40.320]  если у вас внутри лежит
[02:14:40.320 --> 02:14:42.320]  random access итератор. А вот если у вас
[02:14:42.320 --> 02:14:44.320]  forward итератор или bidirectional,
[02:14:44.320 --> 02:14:46.320]  то там шагать надо за линию.
[02:14:46.320 --> 02:14:48.320]  И тогда опять нужен cache.
[02:14:48.320 --> 02:14:50.320]  Вот такие фокусы
[02:14:50.320 --> 02:14:52.320]  и подводы и камни внезапно.
[02:14:52.320 --> 02:14:54.320]  Но эффектов у этого на самом деле
[02:14:54.320 --> 02:14:56.320]  еще больше, чем вам кажется.
[02:14:56.320 --> 02:14:58.320]  То есть помимо того, что там вот эти
[02:14:58.320 --> 02:15:00.320]  cons штуки не являются view,
[02:15:00.320 --> 02:15:02.320]  давайте еще такой код рассмотрим.
[02:15:02.320 --> 02:15:04.320]  Все еще там чиселки, взяли
[02:15:04.320 --> 02:15:06.320]  нечетные и поменяли
[02:15:06.320 --> 02:15:08.320]  уже после того, как мы составили
[02:15:08.320 --> 02:15:10.320]  фильтр, поменяли на 5 нулевой
[02:15:10.320 --> 02:15:12.320]  элемент. Что выведет?
[02:15:14.320 --> 02:15:16.320]  А если он расширится, то это begin не const?
[02:15:16.320 --> 02:15:18.320]  Begin не const.
[02:15:20.320 --> 02:15:22.320]  Вот у
[02:15:22.320 --> 02:15:24.320]  begin и end
[02:15:24.320 --> 02:15:26.320]  вот у этих ребят
[02:15:26.320 --> 02:15:28.320]  нету константного begin и нету
[02:15:28.320 --> 02:15:30.320]  константного end.
[02:15:34.320 --> 02:15:36.320]  Нельзя кашировать при конструировании.
[02:15:36.320 --> 02:15:38.320]  Мы только что выяснили.
[02:15:38.320 --> 02:15:40.320]  Вот единицы.
[02:15:46.320 --> 02:15:48.320]  Начинается
[02:15:48.320 --> 02:15:50.320]  считаться в момент вызова.
[02:15:50.320 --> 02:15:52.320]  Он будет считать, что первый момент 5.
[02:15:52.320 --> 02:15:54.320]  Да, то есть вот ровно так.
[02:15:54.320 --> 02:15:56.320]  5, 1, 3, 5.
[02:15:58.320 --> 02:16:00.320]  Сейчас я что-то хотел сказать.
[02:16:00.320 --> 02:16:02.320]  Да, тут ты начал говорить
[02:16:02.320 --> 02:16:04.320]  про то, что рекомендации так не делать есть
[02:16:04.320 --> 02:16:06.320]  в стандарте.
[02:16:08.320 --> 02:16:10.320]  Begin и end non-modifying.
[02:16:10.320 --> 02:16:12.320]  С точки зрения внешнего мира.
[02:16:12.320 --> 02:16:14.320]  А cache наш внешний мир
[02:16:14.320 --> 02:16:16.320]  наблюдать не может, поэтому
[02:16:16.320 --> 02:16:18.320]  как бы они non-modifying.
[02:16:18.320 --> 02:16:20.320]  То есть вот это non-modifying оно
[02:16:20.320 --> 02:16:22.320]  было не про константность строгую,
[02:16:22.320 --> 02:16:24.320]  а про человеческую
[02:16:24.320 --> 02:16:26.320]  интерпретацию, грубо говоря.
[02:16:26.320 --> 02:16:28.320]  Опять неточные формулировки.
[02:16:28.320 --> 02:16:30.320]  Теперь
[02:16:30.320 --> 02:16:32.320]  усложним задачу.
[02:16:32.320 --> 02:16:34.320]  Мы сделали так. Сначала вывели
[02:16:34.320 --> 02:16:36.320]  то, что в этой вьюхе лежит,
[02:16:36.320 --> 02:16:38.320]  потом поменяли изначальный вектор,
[02:16:38.320 --> 02:16:40.320]  а потом опять вывели.
[02:16:40.320 --> 02:16:42.320]  А здесь он пропустил
[02:16:42.320 --> 02:16:44.320]  на первый элемент.
[02:16:44.320 --> 02:16:46.320]  Да, в обоих случаях
[02:16:46.320 --> 02:16:48.320]  причем?
[02:16:48.320 --> 02:16:50.320]  Из этого
[02:16:50.320 --> 02:16:52.320]  рекомендация.
[02:16:52.320 --> 02:16:54.320]  Коль скоро у вас хоть одна вьюха
[02:16:54.320 --> 02:16:56.320]  на ваш контейнер жива, ни в коем случае
[02:16:56.320 --> 02:16:58.320]  не модифицируйте его.
[02:16:58.320 --> 02:17:00.320]  В гораздо более
[02:17:00.320 --> 02:17:02.320]  непонятном виде.
[02:17:02.320 --> 02:17:04.320]  В гораздо более
[02:17:04.320 --> 02:17:06.320]  непонятном виде.
[02:17:07.320 --> 02:17:09.320]  Какой мув?
[02:17:12.320 --> 02:17:14.320]  Нет, ну просто
[02:17:14.320 --> 02:17:16.320]  вы какую-то вьюху
[02:17:16.320 --> 02:17:18.320]  сделали, чтобы какие-то данные
[02:17:18.320 --> 02:17:20.320]  завьювить, а потом их вынести
[02:17:20.320 --> 02:17:22.320]  оттуда, видимо.
[02:17:22.320 --> 02:17:24.320]  Есть что-нибудь типа
[02:17:24.320 --> 02:17:26.320]  дот рефреш,
[02:17:26.320 --> 02:17:28.320]  которое скидывает все куши?
[02:17:28.320 --> 02:17:30.320]  Нет.
[02:17:32.320 --> 02:17:34.320]  Напиши бумагу.
[02:17:34.320 --> 02:17:36.320]  Ну да.
[02:17:36.320 --> 02:17:38.320]  Сейчас такого нет.
[02:17:38.320 --> 02:17:40.320]  Да?
[02:17:40.320 --> 02:17:42.320]  Я понимаю, что у нас
[02:17:42.320 --> 02:17:44.320]  в первом форе от уже там
[02:17:44.320 --> 02:17:46.320]  подставляется и все считается.
[02:17:46.320 --> 02:17:48.320]  Мы бегин здесь вызовем, мы пройдемся
[02:17:48.320 --> 02:17:50.320]  насквозь и каши сгенерируем.
[02:17:50.320 --> 02:17:52.320]  Да, и во втором форе
[02:17:52.320 --> 02:17:54.320]  уже не будет пересчитываться.
[02:17:54.320 --> 02:17:56.320]  Да, каши не пересчитываются.
[02:17:56.320 --> 02:17:58.320]  А вот значения
[02:17:58.320 --> 02:18:00.320]  пересчитываться будут, внимание.
[02:18:00.320 --> 02:18:02.320]  Есть каши для бегинов,
[02:18:02.320 --> 02:18:04.320]  а есть вот эти итоговые значения,
[02:18:04.320 --> 02:18:06.320]  которые мы здесь посчитали.
[02:18:06.320 --> 02:18:08.320]  Вот эти итоговые значения не кашируются.
[02:18:08.320 --> 02:18:10.320]  Кашируется только то, что бегин дает.
[02:18:10.320 --> 02:18:12.320]  То есть здесь каждый раз мы заново будем
[02:18:12.320 --> 02:18:14.320]  все-таки проходиться от бегина до энда
[02:18:14.320 --> 02:18:16.320]  и проверять каждый элемент, делится
[02:18:16.320 --> 02:18:18.320]  ли он на 2 или нет.
[02:18:18.320 --> 02:18:20.320]  Это так можно?
[02:18:20.320 --> 02:18:22.320]  Не знаю.
[02:18:22.320 --> 02:18:24.320]  Наверное, не уверен.
[02:18:24.320 --> 02:18:26.320]  Но кажется, это не УБ, ничего.
[02:18:26.320 --> 02:18:28.320]  Это прям по стандарту так.
[02:18:28.320 --> 02:18:30.320]  Он специфируется.
[02:18:30.320 --> 02:18:32.320]  Он специфируется.
[02:18:32.320 --> 02:18:34.320]  Еще раз.
[02:18:34.320 --> 02:18:36.320]  Вот у нас
[02:18:36.320 --> 02:18:38.320]  фор, второй,
[02:18:38.320 --> 02:18:40.320]  будет вести к тому, что у нас фильтр
[02:18:40.320 --> 02:18:42.320]  снова применится к УБ.
[02:18:42.320 --> 02:18:44.320]  Да, вот эту функцию мы снова будем вызывать,
[02:18:44.320 --> 02:18:46.320]  но не ко всем элементам,
[02:18:46.320 --> 02:18:48.320]  а начиная с бегина, который закаширован.
[02:18:48.320 --> 02:18:50.320]  То есть мы в первом цикле
[02:18:50.320 --> 02:18:52.320]  найдем бегин, вот он, бегин,
[02:18:52.320 --> 02:18:54.320]  и закашируем его.
[02:18:54.320 --> 02:18:56.320]  Во втором цикле мы уже с этого бегина
[02:18:56.320 --> 02:18:58.320]  будем дальше идти.
[02:18:58.320 --> 02:19:00.320]  То есть если мы вот здесь бы
[02:19:00.320 --> 02:19:02.320]  поменяли не нулевой элемент, а
[02:19:02.320 --> 02:19:04.320]  второй, например,
[02:19:04.320 --> 02:19:06.320]  тоже на 5, то он бы
[02:19:06.320 --> 02:19:08.320]  появился.
[02:19:08.320 --> 02:19:10.320]  Почему так важно все-таки иметь бегин
[02:19:10.320 --> 02:19:12.320]  за амортизированного?
[02:19:12.320 --> 02:19:14.320]  Расчехляя архивы,
[02:19:14.320 --> 02:19:16.320]  читая эти мега срачи
[02:19:16.320 --> 02:19:18.320]  на тысячи и тысячи страниц, про то,
[02:19:18.320 --> 02:19:20.320]  почему он все-таки должен быть
[02:19:20.320 --> 02:19:22.320]  за вот единицы.
[02:19:22.320 --> 02:19:24.320]  Амортизируете, что бегин совсем так работает?
[02:19:24.320 --> 02:19:26.320]  Нет, он так работает.
[02:19:26.320 --> 02:19:28.320]  То есть мы в первом...
[02:19:28.320 --> 02:19:30.320]  У нас не будет, что мы за 10...
[02:19:30.320 --> 02:19:32.320]  Ну, если мы поделим на 10,
[02:19:32.320 --> 02:19:34.320]  то у нас не будет, что мы за 1.
[02:19:34.320 --> 02:19:36.320]  Потому что мы на первом шаге могли там
[02:19:36.320 --> 02:19:38.320]  все обойти и...
[02:19:38.320 --> 02:19:40.320]  От единицы
[02:19:40.320 --> 02:19:42.320]  приближается тремя, шесть, воскресенье,
[02:19:42.320 --> 02:19:44.320]  секретов, количество вызовов, пятенок.
[02:19:44.320 --> 02:19:46.320]  В вопрос фильтров, например, мы
[02:19:46.320 --> 02:19:48.320]  фильтруем... Фильтры, я вам представлю,
[02:19:48.320 --> 02:19:50.320]  витер X равно
[02:19:50.320 --> 02:19:52.320]  равно 5. И запускаю
[02:19:52.320 --> 02:19:54.320]  там массив, где у нас только одна пятенка.
[02:19:54.320 --> 02:19:56.320]  Фильтр работает
[02:19:56.320 --> 02:19:58.320]  не за от единицы, в принципе,
[02:19:58.320 --> 02:20:00.320]  и итерация.
[02:20:00.320 --> 02:20:02.320]  Амортизировано.
[02:20:02.320 --> 02:20:04.320]  А если можно было менять...
[02:20:04.320 --> 02:20:06.320]  А, когда ты...
[02:20:06.320 --> 02:20:08.320]  Например, я встречу генератор, который
[02:20:08.320 --> 02:20:10.320]  вместит 2 в степь ИИ,
[02:20:10.320 --> 02:20:12.320]  ставит пятенку в остальных лодках.
[02:20:12.320 --> 02:20:14.320]  Я ставлю фильтр X равно равно 5,
[02:20:14.320 --> 02:20:16.320]  и вот он выдает...
[02:20:18.320 --> 02:20:20.320]  Так, инкримент никто не требует,
[02:20:20.320 --> 02:20:22.320]  чтобы работал у итератора за от единицы.
[02:20:22.320 --> 02:20:24.320]  Но амортизировано...
[02:20:24.320 --> 02:20:26.320]  Не, амортизировано то, что мне единицы требуют за у итератора.
[02:20:26.320 --> 02:20:28.320]  Да, да, да.
[02:20:28.320 --> 02:20:30.320]  Или нет?
[02:20:30.320 --> 02:20:32.320]  Сейчас, кстати.
[02:20:32.320 --> 02:20:34.320]  Я не помню, чтобы в презентации
[02:20:34.320 --> 02:20:36.320]  было что-то про
[02:20:36.320 --> 02:20:38.320]  амортизиру... про там
[02:20:38.320 --> 02:20:40.320]  от единицы на инкримент. Инкримент сколько угодно
[02:20:40.320 --> 02:20:42.320]  может работать.
[02:20:42.320 --> 02:20:44.320]  И менять
[02:20:44.320 --> 02:20:46.320]  контейнер и
[02:20:46.320 --> 02:20:48.320]  опять вызывать. Если мы будем менять,
[02:20:48.320 --> 02:20:50.320]  пробавиваешься,
[02:20:50.320 --> 02:20:52.320]  так он будет ограничиваться. Каждый раз он будет
[02:20:52.320 --> 02:20:54.320]  двигаться на сколько-нибудь, слушай.
[02:20:54.320 --> 02:20:56.320]  Нет, он...
[02:20:56.320 --> 02:20:58.320]  Что? Я не понял,
[02:20:58.320 --> 02:21:00.320]  что ты хочешь сделать.
[02:21:00.320 --> 02:21:02.320]  Бегин, вым, ломать...
[02:21:02.320 --> 02:21:04.320]  Нет, бегин...
[02:21:04.320 --> 02:21:06.320]  Это элемент, который указал, бегин, вым,
[02:21:06.320 --> 02:21:08.320]  заменяем на что-то плохое, бегин дальше,
[02:21:08.320 --> 02:21:10.320]  ищи, находим, потом сразу заменяем.
[02:21:10.320 --> 02:21:12.320]  Нет, кэш не обновляется
[02:21:12.320 --> 02:21:14.320]  после первого вычисления, насколько я помню.
[02:21:14.320 --> 02:21:16.320]  То есть, ну, короче...
[02:21:16.320 --> 02:21:18.320]  Да, кэш один раз считается
[02:21:18.320 --> 02:21:20.320]  и больше не обновляется.
[02:21:20.320 --> 02:21:22.320]  А вот если мы в этом примере
[02:21:22.320 --> 02:21:24.320]  сделаем не
[02:21:24.320 --> 02:21:26.320]  vv от 0 равно 5,
[02:21:26.320 --> 02:21:28.320]  а vv от 1 равно 2,
[02:21:30.320 --> 02:21:32.320]  То оно заново пересчитает
[02:21:32.320 --> 02:21:34.320]  и не выведет первый элемент,
[02:21:34.320 --> 02:21:36.320]  но кэш не обновится.
[02:21:36.320 --> 02:21:38.320]  Если оно будет неправо,
[02:21:38.320 --> 02:21:40.320]  то есть, если он уходит в кредитат,
[02:21:40.320 --> 02:21:42.320]  и раздует...
[02:21:42.320 --> 02:21:44.320]  Еще раз, кэшируется то, откуда
[02:21:44.320 --> 02:21:46.320]  поиск начинается,
[02:21:46.320 --> 02:21:48.320]  с какого элемента мы начинаем поиск.
[02:21:48.320 --> 02:21:50.320]  А дальше мы каждый раз, при каждом вызове,
[02:21:50.320 --> 02:21:52.320]  заново ходим от этого элемента
[02:21:52.320 --> 02:21:54.320]  и дальше, проверяя, делится или нет.
[02:21:54.320 --> 02:21:56.320]  Насколько я помню, это работает так.
[02:22:04.320 --> 02:22:06.320]  Может, потому что мы заново перепроверяем,
[02:22:06.320 --> 02:22:08.320]  а если не перепроверяем, то...
[02:22:08.320 --> 02:22:10.320]  Не знаю.
[02:22:10.320 --> 02:22:12.320]  Проверьте это, пожалуйста, сами.
[02:22:12.320 --> 02:22:14.320]  Нам надо дальше ехать,
[02:22:14.320 --> 02:22:16.320]  у нас еще столько вообще взрывного
[02:22:16.320 --> 02:22:18.320]  с времени-то уже...
[02:22:20.320 --> 02:22:22.320]  Все, давайте меньше
[02:22:22.320 --> 02:22:24.320]  вещей, которые вы можете сами проверить
[02:22:24.320 --> 02:22:26.320]  за 5 минут, потому что я их
[02:22:26.320 --> 02:22:28.320]  многие не знаю
[02:22:28.320 --> 02:22:30.320]  или не помню наизусть.
[02:22:30.320 --> 02:22:32.320]  Take view. Зачем я вам
[02:22:32.320 --> 02:22:34.320]  показываю?
[02:22:34.320 --> 02:22:36.320]  View interface, view...
[02:22:36.320 --> 02:22:38.320]  Да, у нас там был вопросик,
[02:22:38.320 --> 02:22:40.320]  который мы все хотели утрести.
[02:22:40.320 --> 02:22:42.320]  Откуда там какой-то ref view берется?
[02:22:42.320 --> 02:22:44.320]  Вот вообще, что take view оборачивает?
[02:22:44.320 --> 02:22:46.320]  Внезапно view.
[02:22:46.320 --> 02:22:48.320]  Как тогда в take view можно запихать
[02:22:48.320 --> 02:22:50.320]  вектор? Ну никак нельзя.
[02:22:50.320 --> 02:22:52.320]  Вектор нельзя запихать в take view. Нужна
[02:22:52.320 --> 02:22:54.320]  некоторая обертка промежуточная.
[02:22:56.320 --> 02:22:58.320]  Да, тут
[02:22:58.320 --> 02:23:00.320]  принимаются нернжи.
[02:23:02.320 --> 02:23:04.320]  Но когда мы так пишем,
[02:23:04.320 --> 02:23:06.320]  появляется обертка
[02:23:06.320 --> 02:23:08.320]  волшебная, из воздуха.
[02:23:08.320 --> 02:23:10.320]  Откуда же она появляется?
[02:23:10.320 --> 02:23:12.320]  Если посмотреть на
[02:23:12.320 --> 02:23:14.320]  дедакшн гайд для take view,
[02:23:14.320 --> 02:23:16.320]  а здесь же мы это, на самом деле
[02:23:16.320 --> 02:23:18.320]  дедакшн гайдом пользуемся.
[02:23:18.320 --> 02:23:20.320]  То есть у нас вывод аргументов
[02:23:20.320 --> 02:23:22.320]  шаблона типа
[02:23:22.320 --> 02:23:24.320]  из типов аргументов конструктора.
[02:23:24.320 --> 02:23:26.320]  Мы такое уже видели, умеем,
[02:23:26.320 --> 02:23:28.320]  вот оно, дедакшн гайд.
[02:23:28.320 --> 02:23:30.320]  Итак, если нам дали range
[02:23:30.320 --> 02:23:32.320]  и какое-то число,
[02:23:32.320 --> 02:23:34.320]  сколько брать,
[02:23:34.320 --> 02:23:36.320]  мы должны выбрать своим аргументом
[02:23:36.320 --> 02:23:38.320]  шаблоном views all t
[02:23:38.320 --> 02:23:40.320]  от этого ренджа.
[02:23:40.320 --> 02:23:42.320]  All t
[02:23:42.320 --> 02:23:44.320]  это некоторое...
[02:23:44.320 --> 02:23:46.320]  Сейчас, куда?
[02:23:46.320 --> 02:23:48.320]  Да,
[02:23:48.320 --> 02:23:50.320]  ничего.
[02:23:50.320 --> 02:23:52.320]  Давай еще раз.
[02:23:52.320 --> 02:23:54.320]  Написали такой код.
[02:23:54.320 --> 02:23:56.320]  Take view.
[02:23:56.320 --> 02:23:58.320]  Пихаем туда векторы 3. Первые 3 элемента
[02:23:58.320 --> 02:24:00.320]  берем.
[02:24:00.320 --> 02:24:02.320]  Смотрим тип
[02:24:02.320 --> 02:24:04.320]  вот этого 3,
[02:24:04.320 --> 02:24:06.320]  которая тут будет. Он вот такой.
[02:24:06.320 --> 02:24:08.320]  Другой
[02:24:08.320 --> 02:24:10.320]  странно было ожидать, потому что
[02:24:10.320 --> 02:24:12.320]  в сигнатуре в классе take view
[02:24:12.320 --> 02:24:14.320]  уже написано, что range
[02:24:14.320 --> 02:24:16.320]  нельзя запихать, только view.
[02:24:16.320 --> 02:24:18.320]  И вот мы когда просто вызвали take view,
[02:24:18.320 --> 02:24:20.320]  его конструктор,
[02:24:20.320 --> 02:24:22.320]  мы получили,
[02:24:22.320 --> 02:24:24.320]  что там промежуточный ref view какой-то
[02:24:24.320 --> 02:24:26.320]  обертка. Откуда она возникла?
[02:24:26.320 --> 02:24:28.320]  На самом деле
[02:24:28.320 --> 02:24:30.320]  take view is дедакшн гайд,
[02:24:30.320 --> 02:24:32.320]  который говорит, что в случае, если тебя
[02:24:32.320 --> 02:24:34.320]  от ренджа, используй
[02:24:34.320 --> 02:24:36.320]  в качестве своего типа поля
[02:24:36.320 --> 02:24:38.320]  вот какой-то all t.
[02:24:38.320 --> 02:24:40.320]  Его инициализируют от этого самого ренджа.
[02:24:40.320 --> 02:24:42.320]  Что такое all t?
[02:24:42.320 --> 02:24:44.320]  Пока попридержим коней,
[02:24:44.320 --> 02:24:46.320]  но к вам вопрос.
[02:24:46.320 --> 02:24:48.320]  Будет ли то же самое, если мы вот так
[02:24:48.320 --> 02:24:50.320]  напишем?
[02:24:50.320 --> 02:24:52.320]  Кажется, это будет очень плохая вещь,
[02:24:52.320 --> 02:24:54.320]  когда у нас создастся временный объект
[02:24:54.320 --> 02:24:56.320]  и он же сломается
[02:24:56.320 --> 02:24:58.320]  сразу же.
[02:24:58.320 --> 02:25:00.320]  Ну, ты не прав. Разработчики
[02:25:00.320 --> 02:25:02.320]  стандарта нас
[02:25:02.320 --> 02:25:04.320]  разработчики стандарта нас позаботились.
[02:25:04.320 --> 02:25:06.320]  Если бы вот такой код мгновенно
[02:25:06.320 --> 02:25:08.320]  вёл к
[02:25:08.320 --> 02:25:10.320]  протухшей ссылке,
[02:25:10.320 --> 02:25:12.320]  что мол вот временный объект разрушился и всё
[02:25:12.320 --> 02:25:14.320]  пропало, то это было бы
[02:25:14.320 --> 02:25:16.320]  как-то мега тупо.
[02:25:16.320 --> 02:25:18.320]  Наверное, тогда бы просто запретили
[02:25:18.320 --> 02:25:20.320]  от airvalue вызывать конструктор take view.
[02:25:20.320 --> 02:25:22.320]  Ну или вот если бы мы
[02:25:22.320 --> 02:25:24.320]  так писали, то как бы это вот
[02:25:24.320 --> 02:25:26.320]  тоже запретили и вообще зачем
[02:25:26.320 --> 02:25:28.320]  это так делать? Но нет,
[02:25:28.320 --> 02:25:30.320]  это делать можно.
[02:25:30.320 --> 02:25:32.320]  И будет даже разумный результат.
[02:25:32.320 --> 02:25:34.320]  Сейчас мы увидим, какой.
[02:25:34.320 --> 02:25:36.320]  Вот этот самый alt-t, вот мы о чём
[02:25:36.320 --> 02:25:38.320]  сказали,
[02:25:38.320 --> 02:25:40.320]  take view будет смотреть в alt-t, какой
[02:25:40.320 --> 02:25:42.320]  на самом деле тип view в качестве обёртки
[02:25:42.320 --> 02:25:44.320]  использовать.
[02:25:44.320 --> 02:25:46.320]  А вот этот вот alt-t,
[02:25:46.320 --> 02:25:48.320]  он на вход берёт что-то
[02:25:48.320 --> 02:25:50.320]  концепта viewable range.
[02:25:50.320 --> 02:25:52.320]  То есть был range, был view, теперь viewable range.
[02:25:52.320 --> 02:25:54.320]  Это третий концепт, совсем другой,
[02:25:54.320 --> 02:25:56.320]  не путайте.
[02:25:56.320 --> 02:25:58.320]  И с помощью какой-то дополнительной
[02:25:58.320 --> 02:26:00.320]  функции all, как-то
[02:26:00.320 --> 02:26:02.320]  понимает, какую
[02:26:02.320 --> 02:26:04.320]  обёртку использовать над нашим
[02:26:04.320 --> 02:26:06.320]  range. Ну там был
[02:26:06.320 --> 02:26:08.320]  refview, по-моему, у нас, то есть
[02:26:08.320 --> 02:26:10.320]  как-то тут что-то определяется.
[02:26:10.320 --> 02:26:12.320]  А вот эта функция all, которая
[02:26:12.320 --> 02:26:14.320]  тут использована, она следующим образом
[02:26:14.320 --> 02:26:16.320]  определена, что если
[02:26:16.320 --> 02:26:18.320]  е без всяких там ссылок
[02:26:18.320 --> 02:26:20.320]  и констов view,
[02:26:20.320 --> 02:26:22.320]  то и оставляем view.
[02:26:22.320 --> 02:26:24.320]  А если
[02:26:24.320 --> 02:26:26.320]  refview от е
[02:26:26.320 --> 02:26:28.320]  корректно,
[02:26:28.320 --> 02:26:30.320]  то его используем, а иначе subrange
[02:26:30.320 --> 02:26:32.320]  е. Вот refview
[02:26:32.320 --> 02:26:34.320]  это то, что у нас там выбралось,
[02:26:34.320 --> 02:26:36.320]  когда мы вектор вкинули просто.
[02:26:36.320 --> 02:26:38.320]  Да?
[02:26:38.320 --> 02:26:40.320]  Вот оно.
[02:26:40.320 --> 02:26:42.320]  То есть, видимо, refview для
[02:26:42.320 --> 02:26:44.320]  вектора работает, поэтому оно использовано.
[02:26:44.320 --> 02:26:46.320]  Но в каких-то случаях refview
[02:26:46.320 --> 02:26:48.320]  видимо не работает и используется
[02:26:48.320 --> 02:26:50.320]  subrange. То есть вот эта вот
[02:26:50.320 --> 02:26:52.320]  функция all, она как раз используется,
[02:26:52.320 --> 02:26:54.320]  чтобы выбрать обертку.
[02:26:54.320 --> 02:26:56.320]  А
[02:26:56.320 --> 02:26:58.320]  перед тем, как понять, что такое refview,
[02:26:58.320 --> 02:27:00.320]  мы накидали еще один концепт.
[02:27:00.320 --> 02:27:02.320]  Был range, view,
[02:27:02.320 --> 02:27:04.320]  там где-то промелькнуло вот этот вот
[02:27:04.320 --> 02:27:06.320]  viewable range, но даже перед тем,
[02:27:06.320 --> 02:27:08.320]  как про него говорить, нам нужно ввести
[02:27:08.320 --> 02:27:10.320]  понятие borrowed range.
[02:27:10.320 --> 02:27:12.320]  Так я вижу здесь пройски
[02:27:12.320 --> 02:27:14.320]  языка хорошей. Да, пройски
[02:27:14.320 --> 02:27:16.320]  крабов, проклятые крабы пробрались
[02:27:16.320 --> 02:27:18.320]  в наши ряды. Borrowed range
[02:27:18.320 --> 02:27:20.320]  это range
[02:27:20.320 --> 02:27:22.320]  как
[02:27:22.320 --> 02:27:24.320]  раст,
[02:27:24.320 --> 02:27:26.320]  крабы.
[02:27:26.320 --> 02:27:28.320]  Borrowed range это range,
[02:27:28.320 --> 02:27:30.320]  который является еще при этом
[02:27:30.320 --> 02:27:32.320]  lvalue ссылкой.
[02:27:32.320 --> 02:27:34.320]  То есть lvalue ссылка
[02:27:34.320 --> 02:27:36.320]  на range это borrowed range.
[02:27:36.320 --> 02:27:38.320]  Всегда.
[02:27:38.320 --> 02:27:40.320]  То есть когда мы там вектор пихали
[02:27:40.320 --> 02:27:42.320]  в фильтр, это был range, это
[02:27:42.320 --> 02:27:44.320]  было lvalue. Значит это lvalue ссылка.
[02:27:44.320 --> 02:27:46.320]  Значит это был
[02:27:46.320 --> 02:27:48.320]  borrowed range.
[02:27:48.320 --> 02:27:50.320]  А еще
[02:27:50.320 --> 02:27:52.320]  можно явно сказать enabled borrowed
[02:27:52.320 --> 02:27:54.320]  range руками
[02:27:54.320 --> 02:27:56.320]  для любого range
[02:27:56.320 --> 02:27:58.320]  и включить этот концепт.
[02:28:00.320 --> 02:28:02.320]  Наверное он все-таки семантический,
[02:28:02.320 --> 02:28:04.320]  раз тут такой бред написан, что вообще ни черта
[02:28:04.320 --> 02:28:06.320]  не понятно, что хотел сказать автор.
[02:28:06.320 --> 02:28:08.320]  И действительно он полностью семантический.
[02:28:08.320 --> 02:28:10.320]  Вот.
[02:28:10.320 --> 02:28:12.320]  Ну как вам перевести
[02:28:12.320 --> 02:28:14.320]  со стандартного на русский то?
[02:28:14.320 --> 02:28:16.320]  Короче borrowed range это такая штука,
[02:28:16.320 --> 02:28:18.320]  у которой можно взять итераторы,
[02:28:18.320 --> 02:28:20.320]  итераторы взяли, сохранили,
[02:28:20.320 --> 02:28:22.320]  а сам range выкинули, удалили.
[02:28:22.320 --> 02:28:24.320]  И итераторы все еще будут
[02:28:24.320 --> 02:28:26.320]  валидные.
[02:28:26.320 --> 02:28:28.320]  Логично.
[02:28:28.320 --> 02:28:30.320]  Я правильно понял, что borrowed range это нет?
[02:28:30.320 --> 02:28:32.320]  Нет, конечно.
[02:28:32.320 --> 02:28:34.320]  Borrowed range это штука,
[02:28:34.320 --> 02:28:36.320]  у которой можно взять итераторы, штуку
[02:28:36.320 --> 02:28:38.320]  выкинуть, итераторы останутся
[02:28:38.320 --> 02:28:40.320]  валидными. Да?
[02:28:40.320 --> 02:28:42.320]  Вот это не всегда верно.
[02:28:42.320 --> 02:28:44.320]  Констекс про рей?
[02:28:44.320 --> 02:28:46.320]  Нет.
[02:28:46.320 --> 02:28:48.320]  Если у тебя объект удален,
[02:28:48.320 --> 02:28:50.320]  то итераторы перестают быть валидными.
[02:28:50.320 --> 02:28:52.320]  Вообще говоря. Да?
[02:28:58.320 --> 02:29:00.320]  Зачем на самом деле этот концепт нужен?
[02:29:00.320 --> 02:29:02.320]  Тут есть заметка прекрасная.
[02:29:02.320 --> 02:29:04.320]  Смысл в том, что вы в функцию хотите
[02:29:04.320 --> 02:29:06.320]  пихнуть range, а из функции
[02:29:06.320 --> 02:29:08.320]  вернуть итераторы в этот range.
[02:29:08.320 --> 02:29:10.320]  Где мы такое видели?
[02:29:10.320 --> 02:29:12.320]  Где в функцию пихали range и наружу
[02:29:12.320 --> 02:29:14.320]  вытаскивали какие-то итераторы?
[02:29:18.320 --> 02:29:20.320]  Пара...
[02:29:20.320 --> 02:29:22.320]  Пара две назад было.
[02:29:22.320 --> 02:29:24.320]  Что?
[02:29:24.320 --> 02:29:26.320]  Any? Нет, раньше.
[02:29:26.320 --> 02:29:28.320]  А про что мы вообще тогда говорили?
[02:29:34.320 --> 02:29:36.320]  Когда спылили что-то
[02:29:36.320 --> 02:29:38.320]  про ranges, там копий был.
[02:29:38.320 --> 02:29:40.320]  Помните?
[02:29:40.320 --> 02:29:42.320]  Зачем мы про копий говорили?
[02:29:42.320 --> 02:29:44.320]  Что ты...
[02:29:46.320 --> 02:29:48.320]  Ну, значит, три.
[02:29:50.320 --> 02:29:52.320]  А, про неблоиды.
[02:29:52.320 --> 02:29:54.320]  Про неблоиды, когда мы говорили, вот.
[02:29:54.320 --> 02:29:56.320]  Про неблоиды и CPO, когда говорили,
[02:29:56.320 --> 02:29:58.320]  там был копия.
[02:29:58.320 --> 02:30:00.320]  Копия новая из ranges, что возвращал?
[02:30:00.320 --> 02:30:02.320]  Он возвращал какие-то итераторы внутрь контейнера.
[02:30:02.320 --> 02:30:04.320]  А теперь задумайтесь,
[02:30:04.320 --> 02:30:06.320]  что если мы внутрь копия
[02:30:06.320 --> 02:30:08.320]  что-то?
[02:30:08.320 --> 02:30:10.320]  Вдруг у нас move only range,
[02:30:10.320 --> 02:30:12.320]  который нельзя копировать,
[02:30:12.320 --> 02:30:14.320]  можно только мувать или там вот...
[02:30:14.320 --> 02:30:16.320]  Ну, и мы мувнули почему-то его в копии.
[02:30:16.320 --> 02:30:18.320]  Он вам наружу может вернуть
[02:30:18.320 --> 02:30:20.320]  итераторы?
[02:30:20.320 --> 02:30:22.320]  Ну, нет. Вообще-то это небезопасно.
[02:30:22.320 --> 02:30:24.320]  Могло удалиться то,
[02:30:24.320 --> 02:30:26.320]  что он внутри и сохранился в копии,
[02:30:26.320 --> 02:30:28.320]  потом удалился и все.
[02:30:28.320 --> 02:30:30.320]  Итераторы вы на мусор вернете.
[02:30:30.320 --> 02:30:32.320]  A borrowed range — это такой range, который можно
[02:30:32.320 --> 02:30:34.320]  мувнуть прямо внутри функции,
[02:30:34.320 --> 02:30:36.320]  вернуть наружу итераторы на него,
[02:30:36.320 --> 02:30:38.320]  и это будет работать.
[02:30:38.320 --> 02:30:40.320]  Конкретный пример,
[02:30:40.320 --> 02:30:42.320]  где это делается, увидим чуть позже.
[02:30:42.320 --> 02:30:44.320]  Но пока что вот есть такой
[02:30:44.320 --> 02:30:46.320]  borrowed range.
[02:30:46.320 --> 02:30:48.320]  Viewable range — это range,
[02:30:48.320 --> 02:30:50.320]  который при этом либо borrowed,
[02:30:50.320 --> 02:30:52.320]  либо является view после
[02:30:52.320 --> 02:30:54.320]  удаления референсов.
[02:30:54.320 --> 02:30:56.320]  Вот.
[02:30:56.320 --> 02:30:58.320]  И вот этот вот alt,
[02:30:58.320 --> 02:31:00.320]  который используется для выбора,
[02:31:00.320 --> 02:31:02.320]  он в любом адаптере,
[02:31:02.320 --> 02:31:04.320]  на самом деле, когда вы в него
[02:31:04.320 --> 02:31:06.320]  запихиваете range или вообще что угодно
[02:31:06.320 --> 02:31:08.320]  запихиваете, от того, что вы запихиваете,
[02:31:08.320 --> 02:31:10.320]  требуется viewable range.
[02:31:10.320 --> 02:31:12.320]  То есть либо это view,
[02:31:12.320 --> 02:31:14.320]  либо borrowed range.
[02:31:16.320 --> 02:31:18.320]  В
[02:31:18.320 --> 02:31:20.320]  адаптеры
[02:31:20.320 --> 02:31:22.320]  можно пихать, помимо других
[02:31:22.320 --> 02:31:24.320]  вьюх, только borrowed range.
[02:31:26.320 --> 02:31:28.320]  А в borrowed range было сказано, что это range,
[02:31:28.320 --> 02:31:30.320]  который
[02:31:30.320 --> 02:31:32.320]  вот эта вот опция
[02:31:32.320 --> 02:31:34.320]  интересна,
[02:31:34.320 --> 02:31:36.320]  range, который
[02:31:36.320 --> 02:31:38.320]  lvalue-reference.
[02:31:40.320 --> 02:31:42.320]  То есть пока все сходится с тем,
[02:31:42.320 --> 02:31:44.320]  что мы вектор пихаем, и оно работает.
[02:31:48.320 --> 02:31:50.320]  Но саму lvalue-reference
[02:31:50.320 --> 02:31:52.320]  ты можешь выкинуть, это же ссылка,
[02:31:52.320 --> 02:31:54.320]  а не сам объект. Вот ее выкидываешь и
[02:31:54.320 --> 02:31:56.320]  пока не понятно, почему не умирает
[02:31:56.320 --> 02:31:58.320]  объект.
[02:31:58.320 --> 02:32:00.320]  Да, lvalue ссылку выкинул, а сам объект
[02:32:00.320 --> 02:32:02.320]  он где-то в другом месте живет, в этом
[02:32:02.320 --> 02:32:04.320]  задумка.
[02:32:06.320 --> 02:32:08.320]  А
[02:32:08.320 --> 02:32:10.320]  мувнули его внутрь,
[02:32:10.320 --> 02:32:12.320]  вьюхе в смысле?
[02:32:12.320 --> 02:32:14.320]  Сейчас до этого дойдем.
[02:32:14.320 --> 02:32:16.320]  Refview, вот
[02:32:16.320 --> 02:32:18.320]  та обертка, которая у нас
[02:32:18.320 --> 02:32:20.320]  используется, когда мы по lvalue-вектор
[02:32:20.320 --> 02:32:22.320]  передаем.
[02:32:22.320 --> 02:32:24.320]  Ну, это такая замысловатая обертка.
[02:32:24.320 --> 02:32:26.320]  Тут вот говорят,
[02:32:26.320 --> 02:32:28.320]  что она оборачивает какой-то range r,
[02:32:28.320 --> 02:32:30.320]  она у себя его там как поле посылки
[02:32:30.320 --> 02:32:32.320]  хранит.
[02:32:32.320 --> 02:32:34.320]  Что?
[02:32:38.320 --> 02:32:40.320]  Из object...
[02:32:40.320 --> 02:32:42.320]  А, что это не указатель
[02:32:42.320 --> 02:32:44.320]  на функцию или что-нибудь такое,
[02:32:44.320 --> 02:32:46.320]  короче, нормальный класс.
[02:32:48.320 --> 02:32:50.320]  Требует, чтобы то, чего мы конструируем,
[02:32:50.320 --> 02:32:52.320]  было там, ну, convertible-to, это вот какие-то
[02:32:52.320 --> 02:32:54.320]  уже такие костыли невнятные.
[02:32:54.320 --> 02:32:56.320]  Короче, это lvalue-ранжи.
[02:32:56.320 --> 02:32:58.320]  Вот, любой lvalue-range
[02:32:58.320 --> 02:33:00.320]  можно обернуть в lvalue-сылку
[02:33:00.320 --> 02:33:02.320]  на range, можно обернуть в refview
[02:33:02.320 --> 02:33:04.320]  и начать пихать в другие вьюхи, и, типа,
[02:33:04.320 --> 02:33:06.320]  все предполагается будет нормально у вас, потому что
[02:33:06.320 --> 02:33:08.320]  вы сами этот объект завели где-то,
[02:33:08.320 --> 02:33:10.320]  ссылку взяли, с ней поработали,
[02:33:10.320 --> 02:33:12.320]  потом выкинули ссылку, все окей.
[02:33:12.320 --> 02:33:14.320]  А вот если у вас
[02:33:14.320 --> 02:33:16.320]  rvalue-сылка на range,
[02:33:16.320 --> 02:33:18.320]  rvalue-сылка на range,
[02:33:18.320 --> 02:33:20.320]  это значит у вас какой-то промежуточный temporary
[02:33:20.320 --> 02:33:22.320]  объект, который может удалиться,
[02:33:22.320 --> 02:33:24.320]  у вас ссылка пропадет.
[02:33:24.320 --> 02:33:26.320]  Вот, и нужно где-то это все продлить
[02:33:26.320 --> 02:33:28.320]  жизни, как-то сохранить.
[02:33:28.320 --> 02:33:30.320]  И тут
[02:33:30.320 --> 02:33:32.320]  есть вот такая вот штука как subrange,
[02:33:32.320 --> 02:33:34.320]  которая внутри себя
[02:33:34.320 --> 02:33:36.320]  хранит просто пару итераторов.
[02:33:36.320 --> 02:33:38.320]  Вот сюда надо смотреть.
[02:33:38.320 --> 02:33:40.320]  То есть, она как бы конструируется
[02:33:40.320 --> 02:33:42.320]  от пары итераторов. Пара итераторов
[02:33:42.320 --> 02:33:44.320]  вам, например, equal-range из
[02:33:44.320 --> 02:33:46.320]  multimap может вернуть.
[02:33:46.320 --> 02:33:48.320]  Да, то есть, ну, как бы с equal-range
[02:33:48.320 --> 02:33:50.320]  хочется, чтобы он вернул range, он вместо
[02:33:50.320 --> 02:33:52.320]  этого пару итераторов возвращает. Ну, вот теперь
[02:33:52.320 --> 02:33:54.320]  subrange еще умеет возвращать,
[02:33:54.320 --> 02:33:56.320]  по-моему. Либо вам самим
[02:33:56.320 --> 02:33:58.320]  надо упаковывать, не важно.
[02:33:58.320 --> 02:34:00.320]  Вот, и
[02:34:00.320 --> 02:34:02.320]  к чему я все это веду?
[02:34:02.320 --> 02:34:04.320]  Теперь нам понятно
[02:34:04.320 --> 02:34:06.320]  эта функция, что
[02:34:06.320 --> 02:34:08.320]  когда мы хотим превратить range во Vue,
[02:34:08.320 --> 02:34:10.320]  чтобы ее куда-то дальше пихнуть,
[02:34:10.320 --> 02:34:12.320]  надо думать, что это за range.
[02:34:12.320 --> 02:34:14.320]  Если этот range уже является Vue,
[02:34:14.320 --> 02:34:16.320]  то, ну, без разницы, просто ее и кидаем.
[02:34:16.320 --> 02:34:18.320]  Если это lvalue-ссылка
[02:34:18.320 --> 02:34:20.320]  на другой range,
[02:34:20.320 --> 02:34:22.320]  то мы используем rev-vue.
[02:34:22.320 --> 02:34:24.320]  Или там, если это...
[02:34:26.320 --> 02:34:28.320]  Сейчас.
[02:34:28.320 --> 02:34:30.320]  Да.
[02:34:30.320 --> 02:34:32.320]  А вот если это
[02:34:32.320 --> 02:34:34.320]  какой-нибудь borrow-range, то мы
[02:34:34.320 --> 02:34:36.320]  subrange внезапно используем.
[02:34:40.320 --> 02:34:42.320]  Вот.
[02:34:42.320 --> 02:34:44.320]  Subrange не shert-ссылка.
[02:34:48.320 --> 02:34:50.320]  Сейчас конкретный пример чуть попозже будет.
[02:34:50.320 --> 02:34:52.320]  Блин, мы так не успеваем. Такая
[02:34:52.320 --> 02:34:54.320]  беда.
[02:34:56.320 --> 02:34:58.320]  Вопрос такой, когда вот это вот
[02:34:58.320 --> 02:35:00.320]  стригерится на самом деле.
[02:35:00.320 --> 02:35:02.320]  То есть я только что наговорил кучу всякой хитрости,
[02:35:02.320 --> 02:35:04.320]  которая сейчас, наверное, вообще не понятна,
[02:35:04.320 --> 02:35:06.320]  потому что я и сам себя немного запутал.
[02:35:06.320 --> 02:35:08.320]  Но вопрос такой, когда
[02:35:08.320 --> 02:35:10.320]  будет все-таки subrange выбран, а не rev-vue.
[02:35:10.320 --> 02:35:12.320]  Вот утверждается, что
[02:35:12.320 --> 02:35:14.320]  в каких-то супер-идиотских случаях,
[02:35:14.320 --> 02:35:16.320]  например, когда у вас есть
[02:35:16.320 --> 02:35:18.320]  shert-вектор, который внутри
[02:35:18.320 --> 02:35:20.320]  себя хранит shert-поинтер
[02:35:20.320 --> 02:35:22.320]  на массив.
[02:35:22.320 --> 02:35:24.320]  И он как бы ни рыбы, ни мяса.
[02:35:24.320 --> 02:35:26.320]  И, наверное, для него borrow-range
[02:35:26.320 --> 02:35:28.320]  имеет смысл включить.
[02:35:28.320 --> 02:35:30.320]  Потому что
[02:35:30.320 --> 02:35:32.320]  удалили вы один из shert-векторов,
[02:35:32.320 --> 02:35:34.320]  но другой-то где-то живет, и все будет
[02:35:34.320 --> 02:35:36.320]  нормально.
[02:35:36.320 --> 02:35:38.320]  Вот почему-то у меня нету слайда про это.
[02:35:38.320 --> 02:35:40.320]  И меня это крайне бесит.
[02:35:40.320 --> 02:35:42.320]  Меня тоже этот вопрос стал интересовать.
[02:36:06.320 --> 02:36:08.320]  На owning-vue все понятно в целом.
[02:36:08.320 --> 02:36:10.320]  Он уже живет, вот этого товарища.
[02:36:10.320 --> 02:36:12.320]  Не, на subrange может быть по-русски.
[02:36:12.320 --> 02:36:14.320]  Subrange, кажется, нет.
[02:36:14.320 --> 02:36:16.320]  Кажется, он все-таки...
[02:36:16.320 --> 02:36:18.320]  А, хорошо.
[02:36:18.320 --> 02:36:20.320]  Тут что-то поизменилось
[02:36:20.320 --> 02:36:22.320]  с 23-ми или 26-ми плюсами.
[02:36:22.320 --> 02:36:24.320]  Возможно, нам стоит это
[02:36:24.320 --> 02:36:26.320]  на следующий раз отложить.
[02:36:26.320 --> 02:36:28.320]  Где она живет?
[02:36:28.320 --> 02:36:30.320]  Как она живет?
[02:36:30.320 --> 02:36:32.320]  Кто?
[02:36:32.320 --> 02:36:34.320]  Когда мы муваем v-vector
[02:36:34.320 --> 02:36:36.320]  в vue, там, кажется,
[02:36:36.320 --> 02:36:38.320]  owning-vue вот этот используется,
[02:36:38.320 --> 02:36:40.320]  до которого тут мы не дошли.
[02:36:40.320 --> 02:36:42.320]  И, видимо, не дойдем.
[02:36:42.320 --> 02:36:44.320]  Давайте быстро по алгоритмам пробежимся.
[02:36:44.320 --> 02:36:46.320]  Их буквально два тут будет рассказано.
[02:36:46.320 --> 02:36:48.320]  А про owning-vue
[02:36:48.320 --> 02:36:50.320]  я, видимо, в следующий раз расскажу,
[02:36:50.320 --> 02:36:52.320]  потому что уже убойная, у нас там, скорее всего,
[02:36:52.320 --> 02:36:54.320]  минус 5 минут осталось.
[02:36:54.320 --> 02:36:56.320]  Алгоритмы.
[02:36:56.320 --> 02:36:58.320]  Раньше были в алгоритме алгоритмы, был
[02:36:58.320 --> 02:37:00.320]  std сам алгоритм с begin-end
[02:37:00.320 --> 02:37:02.320]  и аргументами. Теперь вместо этого
[02:37:02.320 --> 02:37:04.320]  есть в ренджах сам алгоритм.
[02:37:04.320 --> 02:37:06.320]  std range сам алгоритм,
[02:37:06.320 --> 02:37:08.320]  и вместо begin-end просто range.
[02:37:08.320 --> 02:37:10.320]  В целом все. Сигнатуры некоторые
[02:37:10.320 --> 02:37:12.320]  поменялись, и некоторые алгоритмы проапгрейдились.
[02:37:12.320 --> 02:37:14.320]  Про апгрейд копии мы уже с вами
[02:37:14.320 --> 02:37:16.320]  говорили долго и тщательно.
[02:37:18.320 --> 02:37:20.320]  Другой важный класс
[02:37:20.320 --> 02:37:22.320]  апгрейдов, которые очень полезны,
[02:37:22.320 --> 02:37:24.320]  очень классные, относятся
[02:37:24.320 --> 02:37:26.320]  ко всяким структуркам, которые там ключ
[02:37:26.320 --> 02:37:28.320]  значения.
[02:37:28.320 --> 02:37:30.320]  ID и value. Вот мы такой вектор сделали,
[02:37:30.320 --> 02:37:32.320]  как вектор map.
[02:37:32.320 --> 02:37:34.320]  Вектор, пар, ключ значения.
[02:37:34.320 --> 02:37:36.320]  Хотим отсортировать по ключу.
[02:37:36.320 --> 02:37:38.320]  Теперь можно писать вот так.
[02:37:38.320 --> 02:37:40.320]  Вот это компаратор.
[02:37:40.320 --> 02:37:42.320]  А вот это что?
[02:37:42.320 --> 02:37:44.320]  Справа от компаратора.
[02:37:44.320 --> 02:37:46.320]  Проекция. Да.
[02:37:46.320 --> 02:37:48.320]  Теперь можно тупо брать и делать проекцию.
[02:37:48.320 --> 02:37:50.320]  Это может быть функция какая-то, которая принимает
[02:37:50.320 --> 02:37:52.320]  на вход элементы, возвращается что угодно.
[02:37:52.320 --> 02:37:54.320]  Ну, как в питоне.
[02:37:54.320 --> 02:37:56.320]  А можно просто указатель на
[02:37:56.320 --> 02:37:58.320]  мембр.
[02:38:00.320 --> 02:38:02.320]  Чего?
[02:38:02.320 --> 02:38:04.320]  Нет, никакого каста и KSTD
[02:38:04.320 --> 02:38:06.320]  функшн, все статическое.
[02:38:06.320 --> 02:38:08.320]  For rich вывели,
[02:38:08.320 --> 02:38:10.320]  отсортировалось.
[02:38:10.320 --> 02:38:12.320]  По value отсортировалось.
[02:38:12.320 --> 02:38:14.320]  Потом еще раз по ID-шнику посортируем.
[02:38:14.320 --> 02:38:16.320]  Вывели, все по ID-шнику отсортировано.
[02:38:16.320 --> 02:38:18.320]  Если на слайдах не отсортировано,
[02:38:18.320 --> 02:38:20.320]  игнорируйте.
[02:38:20.320 --> 02:38:22.320]  По-моему нормально.
[02:38:22.320 --> 02:38:24.320]  Так вот.
[02:38:24.320 --> 02:38:26.320]  Sort.
[02:38:26.320 --> 02:38:28.320]  Берет компаратор, берет проекцию.
[02:38:28.320 --> 02:38:30.320]  Ну, тут что-то random access range.
[02:38:30.320 --> 02:38:32.320]  OK. Sortable.
[02:38:32.320 --> 02:38:34.320]  Какой-то убойный концепт.
[02:38:34.320 --> 02:38:36.320]  Да.
[02:38:36.320 --> 02:38:38.320]  Итератор T, мы помним, что он возвращает
[02:38:38.320 --> 02:38:40.320]  итератор для ренджа.
[02:38:40.320 --> 02:38:42.320]  Sortable.
[02:38:42.320 --> 02:38:44.320]  Требует, чтобы можно было переставлять
[02:38:44.320 --> 02:38:46.320]  местами то, что лежит в итераторе
[02:38:46.320 --> 02:38:48.320]  и чтобы было
[02:38:48.320 --> 02:38:50.320]  indirect strict quick
[02:38:50.320 --> 02:38:52.320]  order. Что вы думаете
[02:38:52.320 --> 02:38:54.320]  про indirect strict quick order?
[02:38:54.320 --> 02:38:56.320]  Нет.
[02:38:56.320 --> 02:38:58.320]  Нет indirect, потому что
[02:38:58.320 --> 02:39:00.320]  через разыменование итератора.
[02:39:02.320 --> 02:39:04.320]  Ну,
[02:39:04.320 --> 02:39:06.320]  да.
[02:39:06.320 --> 02:39:08.320]  А strict, почему?
[02:39:08.320 --> 02:39:10.320]  Почему weak? Как может быть strict,
[02:39:10.320 --> 02:39:12.320]  но weak?
[02:39:12.320 --> 02:39:14.320]  Строго меньше, но при этом
[02:39:14.320 --> 02:39:16.320]  свойство Erwin. Да,
[02:39:16.320 --> 02:39:18.320]  строго меньше, но при этом без equality preservation.
[02:39:18.320 --> 02:39:20.320]  Но сейчас про permutable. Тут просто опять
[02:39:20.320 --> 02:39:22.320]  indirectly что-то можно делать.
[02:39:22.320 --> 02:39:24.320]  Можно indirectly swap-ать местами
[02:39:24.320 --> 02:39:26.320]  и можно indirectly movable
[02:39:26.320 --> 02:39:28.320]  storable какой-то, ну вот еще там
[02:39:28.320 --> 02:39:30.320]  forward iterator, это неважно.
[02:39:30.320 --> 02:39:32.320]  Movable storable это лютая жесть.
[02:39:32.320 --> 02:39:34.320]  Туда...
[02:39:34.320 --> 02:39:36.320]  Все больше напоминает
[02:39:36.320 --> 02:39:38.320]  еще племян копий sometimes
[02:39:38.320 --> 02:39:40.320]  в одну фазу.
[02:39:40.320 --> 02:39:42.320]  Так и есть. Это все не шутки, блин.
[02:39:42.320 --> 02:39:44.320]  Вот эта штука,
[02:39:44.320 --> 02:39:46.320]  короче, означает, что вы можете как бы
[02:39:46.320 --> 02:39:48.320]  прочитать, записать во временную
[02:39:48.320 --> 02:39:50.320]  переменную, а потом эту временную
[02:39:50.320 --> 02:39:52.320]  переменную обратно в другое место
[02:39:52.320 --> 02:39:54.320]  записать. Вот такой концепт.
[02:39:54.320 --> 02:39:56.320]  Почему он именно такой?
[02:39:56.320 --> 02:39:58.320]  Я не знаю.
[02:39:58.320 --> 02:40:00.320]  Но проигнорируем его. Indirect strict
[02:40:00.320 --> 02:40:02.320]  recorder, ну вот как уже правильно сказали,
[02:40:02.320 --> 02:40:04.320]  это
[02:40:04.320 --> 02:40:06.320]  после разоминования итератора
[02:40:06.320 --> 02:40:08.320]  те элементы, которые мы
[02:40:08.320 --> 02:40:10.320]  получим, имеют строгий порядок
[02:40:10.320 --> 02:40:12.320]  на себе, которые поменьше,
[02:40:12.320 --> 02:40:14.320]  но при этом equality preservation
[02:40:14.320 --> 02:40:16.320]  не гарантируется. А тут какой-то класс
[02:40:16.320 --> 02:40:18.320]  внутрь пихается, projected от
[02:40:18.320 --> 02:40:20.320]  итератора и p. Ну вот это класс
[02:40:20.320 --> 02:40:22.320]  обертка, который делает псевдо
[02:40:22.320 --> 02:40:24.320]  итератор, который
[02:40:24.320 --> 02:40:26.320]  ну скорее indirectly readable
[02:40:26.320 --> 02:40:28.320]  только, а даже не итератор.
[02:40:28.320 --> 02:40:30.320]  И вот он как бы оборачивает итератор
[02:40:30.320 --> 02:40:32.320]  и превращает его в новый
[02:40:32.320 --> 02:40:34.320]  итератор, где
[02:40:34.320 --> 02:40:36.320]  применена проекция. То есть вот как бы
[02:40:36.320 --> 02:40:38.320]  итератор и он возвращал
[02:40:38.320 --> 02:40:40.320]  какой-то тип T,
[02:40:40.320 --> 02:40:42.320]  а вот эта вот
[02:40:42.320 --> 02:40:44.320]  обертка projected будет вместо T
[02:40:44.320 --> 02:40:46.320]  возвращать indirect
[02:40:46.320 --> 02:40:48.320]  result T, ну то есть
[02:40:48.320 --> 02:40:50.320]  применение проекции к T.
[02:40:50.320 --> 02:40:52.320]  Indirect result T то же самое, что
[02:40:52.320 --> 02:40:54.320]  result T, только indirect.
[02:40:54.320 --> 02:40:56.320]  То есть мы сначала разоминовываем
[02:40:56.320 --> 02:40:58.320]  итератор и то
[02:40:58.320 --> 02:41:00.320]  значение, тот тип, который он нам вернул
[02:41:00.320 --> 02:41:02.320]  впихаем в проекцию.
[02:41:02.320 --> 02:41:04.320]  Ну и вот так вот он как-то выглядит
[02:41:04.320 --> 02:41:06.320]  invoke result
[02:41:06.320 --> 02:41:08.320]  от там применения
[02:41:08.320 --> 02:41:10.320]  вот этой функции к
[02:41:10.320 --> 02:41:12.320]  iterreference T от
[02:41:12.320 --> 02:41:14.320]  аргументов, ну
[02:41:14.320 --> 02:41:16.320]  итераторов нескольких.
[02:41:16.320 --> 02:41:18.320]  Вот.
[02:41:18.320 --> 02:41:20.320]  И тут кое-где
[02:41:20.320 --> 02:41:22.320]  да, кое-где
[02:41:22.320 --> 02:41:24.320]  где-то в глубинах стандартах
[02:41:24.320 --> 02:41:26.320]  инвука есть вот такая смешная
[02:41:26.320 --> 02:41:28.320]  строчка, что он умеет работать
[02:41:28.320 --> 02:41:30.320]  с указателями
[02:41:30.320 --> 02:41:32.320]  на мембера теперь.
[02:41:32.320 --> 02:41:34.320]  Вот внезапно STD инвук
[02:41:34.320 --> 02:41:36.320]  научился использовать...
[02:41:36.320 --> 02:41:38.320]  Всегда думаете?
[02:41:40.320 --> 02:41:42.320]  Окей.
[02:41:42.320 --> 02:41:44.320]  Окей.
[02:41:44.320 --> 02:41:46.320]  Но, по-моему, все-таки
[02:41:46.320 --> 02:41:48.320]  не всегда, где-то давно
[02:41:48.320 --> 02:41:50.320]  а может в нашей
[02:41:50.320 --> 02:41:52.320]  ESTL библиотеке просто плохо
[02:41:52.320 --> 02:41:54.320]  STD инвук реализован.
[02:41:54.320 --> 02:41:56.320]  Вот он умеет брать указатель на мембер
[02:41:56.320 --> 02:41:58.320]  и применять его к
[02:41:58.320 --> 02:42:00.320]  ну то есть как бы берет указатель на мембер
[02:42:00.320 --> 02:42:02.320]  берет указатель на this
[02:42:02.320 --> 02:42:04.320]  применяет, получаем указатель на
[02:42:04.320 --> 02:42:06.320]  или там ссылку на поле.
[02:42:06.320 --> 02:42:08.320]  Ура.
[02:42:08.320 --> 02:42:10.320]  Да, напоминаем.
[02:42:10.320 --> 02:42:12.320]  Теперь вот последний алгоритм осталось посмотреть
[02:42:12.320 --> 02:42:14.320]  мы расходимся, который
[02:42:14.320 --> 02:42:16.320]  ну такой прототипный пример
[02:42:16.320 --> 02:42:18.320]  мучения с BORUT range.
[02:42:18.320 --> 02:42:20.320]  Итак, вот мораль какая была раньше.
[02:42:20.320 --> 02:42:22.320]  BORUT range является
[02:42:22.320 --> 02:42:24.320]  BORUT range, тогда и только тогда,
[02:42:24.320 --> 02:42:26.320]  когда можно оставить его итераторы
[02:42:26.320 --> 02:42:28.320]  даже когда сам range выкинули, удалили.
[02:42:28.320 --> 02:42:30.320]  Да?
[02:42:30.320 --> 02:42:32.320]  Представляю
[02:42:32.320 --> 02:42:34.320]  вашему вниманию, что
[02:42:34.320 --> 02:42:36.320]  unique. Вот название
[02:42:36.320 --> 02:42:38.320]  здесь, что этой гадости.
[02:42:38.320 --> 02:42:40.320]  Это алгоритм
[02:42:40.320 --> 02:42:42.320]  unique. Ну что он делает?
[02:42:42.320 --> 02:42:44.320]  Ему дают какую-то сравнивалку
[02:42:44.320 --> 02:42:46.320]  и она как бы выкидывает
[02:42:46.320 --> 02:42:48.320]  повторения, да, подряд идущие.
[02:42:48.320 --> 02:42:50.320]  Да, да, да.
[02:42:50.320 --> 02:42:52.320]  Но даем ему range, который forward range.
[02:42:52.320 --> 02:42:54.320]  Даем ему проекцию.
[02:42:54.320 --> 02:42:56.320]  И даем ему лютую вещь.
[02:42:56.320 --> 02:42:58.320]  Вот этот синтаксис распарсить,
[02:42:58.320 --> 02:43:00.320]  это просто застрелится. Я вчера вечером
[02:43:00.320 --> 02:43:02.320]  сидел минут пять.
[02:43:02.320 --> 02:43:04.320]  Ну то есть
[02:43:04.320 --> 02:43:06.320]  вот все
[02:43:06.320 --> 02:43:08.320]  вот это вот, да, вот буквы
[02:43:08.320 --> 02:43:10.320]  C это концепт
[02:43:10.320 --> 02:43:12.320]  indirect equivalence relation, то есть
[02:43:12.320 --> 02:43:14.320]  что после разыминования итератора,
[02:43:14.320 --> 02:43:16.320]  а также после проекции
[02:43:16.320 --> 02:43:18.320]  можно сравнить на равенство
[02:43:18.320 --> 02:43:20.320]  при помощи
[02:43:20.320 --> 02:43:22.320]  C, да,
[02:43:22.320 --> 02:43:24.320]  потому что весь этот концепт он применен
[02:43:24.320 --> 02:43:26.320]  к вот этому шаблонному аркументу.
[02:43:26.320 --> 02:43:28.320]  Да, а значение
[02:43:28.320 --> 02:43:30.320]  по умолчанию просто оператор равенства
[02:43:30.320 --> 02:43:32.320]  используется. Жуткая
[02:43:32.320 --> 02:43:34.320]  вещь.
[02:43:34.320 --> 02:43:36.320]  Что нас тут интересует?
[02:43:36.320 --> 02:43:38.320]  Возвращает эта шняга BORUT subrange
[02:43:38.320 --> 02:43:40.320]  внезапно.
[02:43:40.320 --> 02:43:42.320]  Это конкретный тип.
[02:43:42.320 --> 02:43:44.320]  Который, ну вот здесь универсальная
[02:43:44.320 --> 02:43:46.320]  ссылка на любой range, да.
[02:43:46.320 --> 02:43:48.320]  И мы
[02:43:48.320 --> 02:43:50.320]  по этой универсальной ссылке как-то понимаем,
[02:43:50.320 --> 02:43:52.320]  что нам надо возвращать из уника.
[02:43:54.320 --> 02:43:56.320]  Ну и тут делается как бы ровно
[02:43:56.320 --> 02:43:58.320]  то, что я говорил.
[02:43:58.320 --> 02:44:00.320]  Мы смотрим, вот этот range, который
[02:44:00.320 --> 02:44:02.320]  нам пришел, он является BORUT
[02:44:02.320 --> 02:44:04.320]  range. Если да, то мы будем
[02:44:04.320 --> 02:44:06.320]  возвращать subrange.
[02:44:06.320 --> 02:44:08.320]  Пару итераторов.
[02:44:08.320 --> 02:44:10.320]  То есть уник, он
[02:44:10.320 --> 02:44:12.320]  после своей работы вернет пару итераторов
[02:44:12.320 --> 02:44:14.320]  на начало и конец того, где
[02:44:14.320 --> 02:44:16.320]  валидные элементы. То есть вот мы сказали,
[02:44:16.320 --> 02:44:18.320]  что он там подряд идущие элементы выкидывает.
[02:44:18.320 --> 02:44:20.320]  Но он их не выкидывает, он их в конец
[02:44:20.320 --> 02:44:22.320]  передвигает, да.
[02:44:22.320 --> 02:44:24.320]  То есть чтобы их
[02:44:24.320 --> 02:44:26.320]  еще и выкинуть, нужно после уника
[02:44:26.320 --> 02:44:28.320]  запустить arrays. Вы
[02:44:28.320 --> 02:44:30.320]  сталкивались такой, где-то должны были
[02:44:30.320 --> 02:44:32.320]  сталкиваться с такой идиомой, да, что
[02:44:32.320 --> 02:44:34.320]  find arrays вот это все.
[02:44:36.320 --> 02:44:38.320]  Нет, смотри, у тебя есть группы
[02:44:38.320 --> 02:44:40.320]  подряд идущих элементов, равных друг другу.
[02:44:40.320 --> 02:44:42.320]  Ну group by по сути.
[02:44:42.320 --> 02:44:44.320]  И вот ты их вот вместе сплющиваешь,
[02:44:44.320 --> 02:44:46.320]  выкидываешь все равные
[02:44:46.320 --> 02:44:48.320]  кроме первого.
[02:44:48.320 --> 02:44:50.320]  Он не возвращает их, он
[02:44:50.320 --> 02:44:52.320]  прямо модифицирует R.
[02:44:52.320 --> 02:44:54.320]  А возвращает наружу
[02:44:54.320 --> 02:44:56.320]  subrange. Но возвращает наружу
[02:44:56.320 --> 02:44:58.320]  subrange, только если R изначально
[02:44:58.320 --> 02:45:00.320]  был BORUT range.
[02:45:00.320 --> 02:45:02.320]  То есть вспоминаем, что
[02:45:02.320 --> 02:45:04.320]  lvalue ссылка на любой range
[02:45:04.320 --> 02:45:06.320]  это BORUT range.
[02:45:06.320 --> 02:45:08.320]  То есть мы можем
[02:45:08.320 --> 02:45:10.320]  спокойно lvalue ссылку сюда
[02:45:10.320 --> 02:45:12.320]  запихнуть, и оно отработает и вернет
[02:45:12.320 --> 02:45:14.320]  нам пару итераторов. А вот если мы
[02:45:14.320 --> 02:45:16.320]  туда мувнем range
[02:45:16.320 --> 02:45:18.320]  внутрь уника,
[02:45:18.320 --> 02:45:20.320]  то это тоже может отработать.
[02:45:20.320 --> 02:45:22.320]  Но lvalue ссылка на range она даже
[02:45:22.320 --> 02:45:24.320]  BORUT range не будет, потому что
[02:45:24.320 --> 02:45:26.320]  это temporary, как только мы ссылку дропнем,
[02:45:26.320 --> 02:45:28.320]  объект тоже удалится.
[02:45:28.320 --> 02:45:30.320]  Поэтому тут с помощью conditional
[02:45:30.320 --> 02:45:32.320]  t выбирают, что если у нас не
[02:45:32.320 --> 02:45:34.320]  BORUT range, мы выберем
[02:45:34.320 --> 02:45:36.320]  RNG-данглинг.
[02:45:36.320 --> 02:45:38.320]  А это просто пустая
[02:45:38.320 --> 02:45:40.320]  структура.
[02:45:40.320 --> 02:45:42.320]  То есть алгоритм unique
[02:45:42.320 --> 02:45:44.320]  в зависимости от того, далее ли вы ему
[02:45:44.320 --> 02:45:46.320]  BORUT range или нет, даст вам
[02:45:46.320 --> 02:45:48.320]  либо пару итераторов наружу,
[02:45:48.320 --> 02:45:50.320]  либо пустую структуру.
[02:45:50.320 --> 02:45:52.320]  То есть если у вас есть этот
[02:45:52.320 --> 02:45:54.320]  мифический вектор, внутри которого
[02:45:54.320 --> 02:45:56.320]  лежит shared
[02:45:56.320 --> 02:45:58.320]  pointer на сишный массив,
[02:45:58.320 --> 02:46:00.320]  и вы мувнули
[02:46:00.320 --> 02:46:02.320]  внутри этого алгоритма
[02:46:02.320 --> 02:46:04.320]  такой shared
[02:46:04.320 --> 02:46:06.320]  вектор, мувнули его внутрь,
[02:46:06.320 --> 02:46:08.320]  чтобы лишний раз refcounter не
[02:46:08.320 --> 02:46:10.320]  уменьшать для копирования,
[02:46:10.320 --> 02:46:12.320]  вот тогда
[02:46:12.320 --> 02:46:14.320]  вы должны явно пойти
[02:46:14.320 --> 02:46:16.320]  и пометить, что это у вас BORUT
[02:46:16.320 --> 02:46:18.320]  range, и поэтому
[02:46:18.320 --> 02:46:20.320]  ты алгоритм unique, std unique,
[02:46:20.320 --> 02:46:22.320]  не пугайся, что в тебя мувнули
[02:46:22.320 --> 02:46:24.320]  это rvalue-референс.
[02:46:24.320 --> 02:46:26.320]  Так и задумано, пусть он умирает,
[02:46:26.320 --> 02:46:28.320]  после этого контейнер не исчезнет,
[02:46:28.320 --> 02:46:30.320]  верни мне все равно, пожалуйста,
[02:46:30.320 --> 02:46:32.320]  пару итераторов.
[02:46:34.320 --> 02:46:36.320]  Он скомпилируется, он скомпилируется и выдаст
[02:46:36.320 --> 02:46:38.320]  ничего.
[02:46:38.320 --> 02:46:40.320]  Возвращаемый тип ничего, он скомпилируется,
[02:46:40.320 --> 02:46:42.320]  но итераторов вам не вернет.
[02:46:42.320 --> 02:46:44.320]  Что за страшное такое поведение?
[02:46:44.320 --> 02:46:46.320]  Почему там не выгибается ошибка?
[02:46:46.320 --> 02:46:48.320]  Потому что вдруг ты так и хотел, чтобы
[02:46:48.320 --> 02:46:50.320]  тебе контейнер поменяли,
[02:46:50.320 --> 02:46:52.320]  там какие-то свопы
[02:46:52.320 --> 02:46:54.320]  делали.
[02:46:54.320 --> 02:46:56.320]  А он делает свопы, даже если
[02:46:56.320 --> 02:46:58.320]  не он внули?
[02:46:58.320 --> 02:47:00.320]  Кажется, что да.
[02:47:00.320 --> 02:47:02.320]  Алгоритм отрабатывает, но вернуть он ничего он не может.
[02:47:02.320 --> 02:47:04.320]  И вот как бы
[02:47:04.320 --> 02:47:06.320]  вот главное,
[02:47:06.320 --> 02:47:08.320]  зачем вся эта машинерия жуткая.
[02:47:08.320 --> 02:47:10.320]  И вот собственно
[02:47:10.320 --> 02:47:12.320]  да, если сюда пришло lvalue, то
[02:47:12.320 --> 02:47:14.320]  автоматом вернется пара, если нет, то
[02:47:14.320 --> 02:47:16.320]  фигня вернется.
[02:47:16.320 --> 02:47:18.320]  Окей,
[02:47:18.320 --> 02:47:20.320]  и того,
[02:47:20.320 --> 02:47:22.320]  кто является вообще бару дранжами
[02:47:22.320 --> 02:47:24.320]  внезапно. Любая lvalue ссылка
[02:47:24.320 --> 02:47:26.320]  на контейнер,
[02:47:26.320 --> 02:47:28.320]  refview сам является бару дранжом,
[02:47:28.320 --> 02:47:30.320]  потому что это view, ну и в принципе любой
[02:47:30.320 --> 02:47:32.320]  view, даже string view или empty
[02:47:32.320 --> 02:47:34.320]  view и так далее.
[02:47:34.320 --> 02:47:36.320]  Но
[02:47:36.320 --> 02:47:38.320]  тут есть вот это
[02:47:38.320 --> 02:47:40.320]  примечание,
[02:47:40.320 --> 02:47:42.320]  что на самом деле
[02:47:42.320 --> 02:47:44.320]  есть вьюхи,
[02:47:44.320 --> 02:47:46.320]  которые как фильтр view,
[02:47:46.320 --> 02:47:48.320]  они в себе что-то кашируют.
[02:47:48.320 --> 02:47:50.320]  И вот вы взяли
[02:47:50.320 --> 02:47:52.320]  бигину какой-то другой вьюхи,
[02:47:52.320 --> 02:47:54.320]  она как бы могла случайно
[02:47:54.320 --> 02:47:56.320]  вернуть ссылку на какой-то кэш
[02:47:56.320 --> 02:47:58.320]  внутри. И вот в этом случае
[02:47:58.320 --> 02:48:00.320]  все может сломаться, поэтому там
[02:48:00.320 --> 02:48:02.320]  далеко не во всех ренджах
[02:48:02.320 --> 02:48:04.320]  стандартной библиотеки
[02:48:04.320 --> 02:48:06.320]  проставлено, что они бару дранж.
[02:48:06.320 --> 02:48:08.320]  Но вот эти вот как бы точно.
[02:48:08.320 --> 02:48:10.320]  Ну тут
[02:48:10.320 --> 02:48:12.320]  странно. И в 23 плюсах еще
[02:48:12.320 --> 02:48:14.320]  что-то меняют, до сих пор
[02:48:14.320 --> 02:48:16.320]  у меня актуальной информации нету,
[02:48:16.320 --> 02:48:18.320]  предлагаю вам самостоятельно, и сюда
[02:48:18.320 --> 02:48:20.320]  уже и не влезает эту презентацию.
[02:48:20.320 --> 02:48:22.320]  Вот, if the argument
[02:48:22.320 --> 02:48:24.320]  is inner value, то
[02:48:24.320 --> 02:48:26.320]  ill-formed.
[02:48:26.320 --> 02:48:28.320]  Да.
[02:48:30.320 --> 02:48:32.320]  Зачем это сюда вставлено?
[02:48:32.320 --> 02:48:34.320]  Я забыл.
[02:48:42.320 --> 02:48:44.320]  Если enabled borrow range
[02:48:44.320 --> 02:48:46.320]  не помечено, вот так вот.
[02:48:46.320 --> 02:48:48.320]  То есть outer value
[02:48:48.320 --> 02:48:50.320]  брать begin можно только если у вас enabled
[02:48:50.320 --> 02:48:52.320]  borrow range.
[02:48:52.320 --> 02:48:54.320]  А на кого цвет пойдет
[02:48:54.320 --> 02:48:56.320]  бурл дранж?
[02:48:56.320 --> 02:48:58.320]  Ну да, и там вот для этого
[02:48:58.320 --> 02:49:00.320]  овнинг вью автоматом
[02:49:00.320 --> 02:49:02.320]  подпихивает. По-моему
[02:49:02.320 --> 02:49:04.320]  да, тут все в очень
[02:49:04.320 --> 02:49:06.320]  странном положении застряло,
[02:49:06.320 --> 02:49:08.320]  потому что я еще не играл с 23 плюсами,
[02:49:08.320 --> 02:49:10.320]  и вот да.
[02:49:10.320 --> 02:49:12.320]  Когда мы сказали, что
[02:49:12.320 --> 02:49:14.320]  будет утечка памяти,
[02:49:14.320 --> 02:49:16.320]  это было правдой.
[02:49:16.320 --> 02:49:18.320]  Там будет ссылка, продуша.
[02:49:18.320 --> 02:49:20.320]  По-моему нет, оно потом
[02:49:20.320 --> 02:49:22.320]  почистится все. Нет, тут точно нигде
[02:49:22.320 --> 02:49:24.320]  протекающих ссылок нет, все нормально.
[02:49:24.320 --> 02:49:26.320]  Окей.
[02:49:26.320 --> 02:49:28.320]  Да, тут важное замечание,
[02:49:28.320 --> 02:49:30.320]  что вот это все верно для ranges
[02:49:30.320 --> 02:49:32.320]  begin, а std begin и std end
[02:49:32.320 --> 02:49:34.320]  всю эту технологию не учитывают
[02:49:34.320 --> 02:49:36.320]  и забивают на нее. Поэтому
[02:49:36.320 --> 02:49:38.320]  если вы хотите писать
[02:49:38.320 --> 02:49:40.320]  современный к алгоритмический код
[02:49:40.320 --> 02:49:42.320]  с рейнджами, не используйте std begin.
[02:49:44.320 --> 02:49:46.320]  Все, последний слайд.
[02:49:48.320 --> 02:49:50.320]  В 23 плюсах добавили еще
[02:49:50.320 --> 02:49:52.320]  кучу прикольных вьюх, которые вот раньше
[02:49:52.320 --> 02:49:54.320]  не были упомянуты. Например, zip, суперважное.
[02:49:54.320 --> 02:49:56.320]  В питоне zip видели, все хотят
[02:49:56.320 --> 02:49:58.320]  zip, но он только в 23. Group by
[02:49:58.320 --> 02:50:00.320]  наш любимый, даже декартовое
[02:50:00.320 --> 02:50:02.320]  произведение внезапно. И главное
[02:50:02.320 --> 02:50:04.320]  это вот ranges to, на который я даже все-таки
[02:50:04.320 --> 02:50:06.320]  вставил пример, потому что это супер круто.
[02:50:06.320 --> 02:50:08.320]  Иногда вы сделали
[02:50:08.320 --> 02:50:10.320]  огромное вью и хотите это вью
[02:50:10.320 --> 02:50:12.320]  все-таки в памяти где-то сохранить.
[02:50:12.320 --> 02:50:14.320]  Взять, посчитать и сохранить.
[02:50:14.320 --> 02:50:16.320]  Раньше это было сделать неудобно,
[02:50:16.320 --> 02:50:18.320]  непонятно, как это сделать эффективно,
[02:50:18.320 --> 02:50:20.320]  ну и много букв.
[02:50:20.320 --> 02:50:22.320]  Теперь есть ranges to,
[02:50:22.320 --> 02:50:24.320]  std vector и vector будет вектором.
[02:50:24.320 --> 02:50:26.320]  Только с 23? С 23.
[02:50:26.320 --> 02:50:28.320]  То есть получается
[02:50:28.320 --> 02:50:30.320]  он вычитает все? Да, да, да.
[02:50:30.320 --> 02:50:32.320]  To прям схлопнет всю эту ленивость
[02:50:32.320 --> 02:50:34.320]  и прям вычислит и прям вектор
[02:50:34.320 --> 02:50:36.320]  положит. Я считаю, что
[02:50:36.320 --> 02:50:38.320]  нужно до конца, если зараза перетягивать,
[02:50:38.320 --> 02:50:40.320]  нужно type deduction нормально
[02:50:40.320 --> 02:50:42.320]  поставить. Не будет.
[02:50:44.320 --> 02:50:46.320]  Нет, ну не будет.
[02:50:46.320 --> 02:50:48.320]  Короче, в to вот здесь указываем
[02:50:48.320 --> 02:50:50.320]  куда. А еще
[02:50:50.320 --> 02:50:52.320]  заметьте, что в to можно кажется
[02:50:52.320 --> 02:50:54.320]  указать и шаблон и конкретную
[02:50:54.320 --> 02:50:56.320]  специализацию. То есть там указан
[02:50:56.320 --> 02:50:58.320]  лист даблов, а здесь просто вектор.
[02:50:58.320 --> 02:51:00.320]  Вот здесь оно догадается, что изначально int
[02:51:00.320 --> 02:51:02.320]  были, значит и вектор int будет.
[02:51:02.320 --> 02:51:04.320]  А вот там мы как бы насильно
[02:51:04.320 --> 02:51:06.320]  вектор даблов хотим, и оно скастит.
[02:51:06.320 --> 02:51:08.320]  Вначале он смотрит
[02:51:08.320 --> 02:51:10.320]  на самые последние цепочки,
[02:51:10.320 --> 02:51:12.320]  потому что можно transform, который
[02:51:12.320 --> 02:51:14.320]  да, да, да, да, да. Ну то есть оно по цепочке
[02:51:14.320 --> 02:51:16.320]  проходит и понимает, какой type будет.
[02:51:16.320 --> 02:51:18.320]  Все. На этом
[02:51:18.320 --> 02:51:20.320]  итог надо подвести. У нас вначале
[02:51:20.320 --> 02:51:22.320]  был вопрос, какова цена
[02:51:22.320 --> 02:51:24.320]  того, чтобы вот это все привнести.
[02:51:24.320 --> 02:51:26.320]  Так вот, в Java у нас
[02:51:26.320 --> 02:51:28.320]  был simple bin factory aware aspect
[02:51:28.320 --> 02:51:30.320]  instance factory.
[02:51:30.320 --> 02:51:32.320]  Знакомо, да?
[02:51:32.320 --> 02:51:34.320]  Теперь мы тоже клоуны. У нас
[02:51:34.320 --> 02:51:36.320]  directly regular
[02:51:36.320 --> 02:51:38.320]  and re-invocable.
[02:51:38.320 --> 02:51:40.320]  Так что мы
[02:51:40.320 --> 02:51:42.320]  больше не можем шутить над джавистами.
[02:51:46.320 --> 02:51:48.320]  По количеству символов
[02:51:48.320 --> 02:51:50.320]  уже все плохо. Видишь там
[02:51:50.320 --> 02:51:52.320]  только слово factory дописать не хватает.
[02:51:52.320 --> 02:51:54.320]  Мы еще тут resolution
[02:51:54.320 --> 02:51:56.320]  arrangement написали.
[02:51:56.320 --> 02:51:58.320]  Кого они написали?
[02:51:58.320 --> 02:52:00.320]  Ну как какой?
[02:52:00.320 --> 02:52:02.320]  Стой, да.
[02:52:02.320 --> 02:52:04.320]  Тут должен быть...
[02:52:04.320 --> 02:52:06.320]  А нет, это не для...
[02:52:06.320 --> 02:52:08.320]  Это VSTD.
[02:52:08.320 --> 02:52:10.320]  Ну, в общем,
[02:52:10.320 --> 02:52:12.320]  на этой веселой ноте мы наконец-то
[02:52:12.320 --> 02:52:14.320]  заканчиваем. Мы задержались
[02:52:14.320 --> 02:52:16.320]  на 15 минут. Черт.
