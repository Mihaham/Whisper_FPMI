[00:00.000 --> 00:10.120]  И начнем с вами говорить уже чуть больше про алгоритмы, наконец-то, но никуда не
[00:10.120 --> 00:19.040]  деменимся в то же время от математики. Это видно, это отлично. Очень рад, что вы пришли снова.
[00:19.040 --> 00:28.000]  Что поделать, что бывает. В действительности, мы сегодня поговорим также, у нас будет вот такой
[00:28.160 --> 00:33.560]  математический аппарат, где мы будем что-то делать, что-то у нас будет происходить. Вам,
[00:33.560 --> 00:37.920]  может быть, это частично не понравится, но по итогу мы выйдем к алгоритмам, и мы будем уже
[00:37.920 --> 00:43.040]  говорить об алгоритмах все в последующее время, кроме, может быть, последней лекции. Последняя
[00:43.040 --> 00:48.240]  лекция будет такая, более теоретическая. Плюс там еще посерединке будет эмоциональный анализ.
[00:48.240 --> 00:53.440]  Но это все очень важно, это все очень нужно, поэтому никогда не думайте, что, типа, блин, да зачем мне
[00:53.440 --> 00:57.800]  нужна эта ваша математика, я вообще хочу стать разработчиком. Разработчиков без математики не
[00:57.800 --> 01:05.560]  бывает. Вот. Без какого-то, во-первых, мышления, во-вторых, без какого-то понимания, типа, мира.
[01:05.560 --> 01:12.480]  Вот. И в то же время, ну, напишите, вы перебор, типа, за n в степени n, и будет все грустно. А если
[01:12.480 --> 01:20.280]  вы будете смеяться и обсуждать какие-то фотки, я не знаю, что вы там делаете. Девочки? Привет! Я
[01:20.360 --> 01:30.920]  здесь. Вот. Вроде меня не транслируют, поэтому в телефон можете смотреть. В общем-то, все, как обычно,
[01:30.920 --> 01:38.240]  я прошу вас сильно громко не говорить или вообще не говорить. Это было бы совсем чудесно. А в
[01:38.240 --> 01:43.560]  остальном, как бы, мы здесь много чему научимся. Я надеюсь, сегодня вы поймете какую-нибудь новую
[01:43.560 --> 01:49.640]  интересную тему. И первое, что мы будем с вами говорить, это рекуррентные соотношения. Кто
[01:49.640 --> 01:57.440]  представляет, что такое рекуррентные соотношения? Как тебя зовут? Саша. Да, отлично. Что в твоем понимании
[01:57.440 --> 02:06.120]  рекуррентные соотношения? Ну, рекуррентные соотношения, когда мы создаем какой-нибудь, ну, член-то за это, через предыдущий.
[02:06.120 --> 02:11.560]  Да, действительно, это такая подзадача в задача. Мы сначала добиваемся какой-то подзадачи более
[02:11.560 --> 02:17.840]  маленькой, и с ней мы уже работаем. На самом деле, рекурренты возникают в следующих случаях. Очень
[02:17.840 --> 02:26.440]  часто вы их встретите в задачах разделяй и властвуй. Это принцип. Это не какое-то такое, знаете,
[02:26.440 --> 02:34.000]  вот слово, это цитата великих людей, нет. Разделяй и властвуй — это некоторый принцип в алгоритмах, где
[02:34.000 --> 02:39.600]  говорится о следующем, что благодаря разбиению на какие-то подзадачи мы начинаем собирать полную
[02:39.600 --> 02:45.800]  задачу. Иначе бы у нас этого не было. И в действительности разделяй и властвуй работает за счет каких-то
[02:45.880 --> 02:54.200]  рекурсивных разбиений на более мелкие задачи, чаще всего именно рекурсивных. Иногда можно сказать,
[02:54.200 --> 03:00.200]  что, блин, ну, зачем нам тут рекурсия? И в действительности, если я вас на экзамене спрошу типа,
[03:00.200 --> 03:07.120]  а надо ли рекурсивную, можно ли любую рекурсивную задачу свести какую-нибудь с циклами, вы должны
[03:07.120 --> 03:15.440]  мне ответить да. Это правда. Есть отдельное доказательство этому. Но да, любая рекурсивная
[03:15.440 --> 03:19.720]  задача так или иначе будет сводиться к циклам. Если у вас задача только циклы, не думайте,
[03:19.720 --> 03:27.320]  что вы не пользуетесь принципом разделяй и властвуй. Это не так работает. Многие задачи можно
[03:27.320 --> 03:34.480]  переписать даже в каком-то объективно адекватном виде. Вот. И мы в этом принципе что делаем? Когда
[03:34.480 --> 03:40.800]  мы получили более мелкие подзадачи, мы их комбинируем и получаем какой-то следующий ответ. В этих
[03:40.800 --> 03:46.800]  более мелких задачах мы спускаемся до каких-то элементарных, где мы точно знаем ответ. Ну, не знаю,
[03:46.800 --> 03:53.040]  там для нуля это выглядит именно так, для единицы вот так. Отлично. Значит, для двойки мы можем сказать.
[03:53.040 --> 03:59.800]  Простой пример числа Фибоначчи. Вот вам те маленькие подзадачки. Хотя это больше динамика,
[03:59.800 --> 04:06.400]  но это очень похожая между собой вещь. Здесь у меня, я не знаю почему, но у меня не отображается
[04:06.480 --> 04:13.320]  фигурная скобка. Я когда-нибудь, надеюсь, это починю, потому что в превьюшке она всегда есть.
[04:13.320 --> 04:21.320]  Вообще, если вы используете хоть какой-то алгоритм разделяй и властвуй, то почти, наверное,
[04:21.320 --> 04:29.880]  во время работы с ним вы встретите какую-то рекурренту, какое-то взаимоотношение между предыдущими
[04:29.880 --> 04:39.440]  и новыми действиями. Рекуррентное соотношение это, по сути, некоторое уравнение или неравенство,
[04:39.440 --> 04:45.000]  которое описывает функцию. Это не обязательно всегда равно, это может быть и меньше. То есть мы
[04:45.000 --> 04:51.760]  выполним меньше действий, чем что-то. Это тоже рекуррента, но если она зависит от какой-то
[04:51.760 --> 04:58.800]  более мелкой подзадачи. Вот здесь написано, так можно сказать, полная рекуррента, что вот для n
[04:58.800 --> 05:04.880]  равного единицы у нас есть крайний случай раз, и для всех остальных случаев у нас описано вот таким
[05:04.880 --> 05:11.560]  вот образом. Чаще всего мы будем сокращать до последнего равенства. Почему? Потому что первое
[05:11.560 --> 05:19.560]  неинтересное. Что там? Это от единицы. Вы же знаете, что такое это. Значит, зачем нам одно и то же
[05:19.560 --> 05:25.800]  повторять? Поэтому мы будем смотреть что-нибудь интересное. Вот там вот написано 2tn пополам равно
[05:25.800 --> 05:36.160]  ttn, там плюс ttn. За это я прошу прощения. Это моя ошибка. Вот, возьмем, к примеру, такую рекурренту. И как
[05:36.160 --> 05:42.600]  вообще оценить, за сколько это работает? Вот у нас есть рекуррентное соотношение. Как вы, может быть,
[05:42.600 --> 05:53.120]  в школе какие-нибудь рекурренты встречали? Какие? Числа фибоначи. Хорошо, это правда рекуррента.
[05:53.120 --> 06:07.480]  Есть еще что-нибудь? Вот самое простое. А факториал еще раз? Другое. Какие еще раз? Натуральные числа.
[06:07.480 --> 06:20.120]  Хорошо, это правда. А натуральные числа это что? Хорошо, ладно, подведу. Так, и как это называлось у вас?
[06:20.120 --> 06:28.240]  Линейная рекуррента. Хорошо, ладно, арифметическая прогрессия. Я очень долго пытался добиться этого
[06:28.240 --> 06:34.120]  слова. А линейная рекуррентная правда, натуральные числа правда, это просто арифметическая прогрессия.
[06:34.120 --> 06:39.040]  Это самый простой способ рекуррента. Вот та самая арифметическая прогрессия. Существуют еще кроме
[06:39.040 --> 06:43.520]  одной прогрессии, существуют еще геометрические прогрессии. И как-то с ними тоже нужно работать,
[06:43.520 --> 06:49.400]  что-то с ними делать. И как же вообще жить в этом плане? Так вот, а если мы с вами говорим о том,
[06:49.400 --> 06:54.360]  что у нас есть какая-то рекуррент, надо оценить время. Ну вот у нас есть, к примеру, арифметическая
[06:54.360 --> 06:59.800]  прогрессия. Можем ли мы посчитать сумму арифметической прогрессии? Это все достаточно просто и тривиально.
[06:59.800 --> 07:05.960]  Сложить первые и последние члены, разделить пополам. Ну либо просто воспользоваться этой суммой. Это не
[07:05.960 --> 07:12.480]  очень сложная задача сама по себе. Правда? Я надеюсь, вы это знаете. Вы знаете, как сложить чиселки от
[07:12.480 --> 07:22.040]  одного до ста в уме? Какой ответ там будет? 5000. Отлично, вы все учили в школе. Меня это очень радует.
[07:22.040 --> 07:29.440]  Да, в действительности, к примеру, вот таким вот образом. Но мы возьмем вот ту рекурренту,
[07:29.440 --> 07:37.320]  которую мы с вами смотрели. Первый метод – это метод постановки. Метод постановки – очень банальная
[07:37.320 --> 07:47.440]  вещь. Мы просто предполагаем. Мы такие, ну возьмем, к примеру, вот такую вот оценку. Будем считать,
[07:47.440 --> 07:55.560]  что там t от n равно θ от n. То есть время работы оно линейно зависит, причем явно линейно. И мы скажем,
[07:55.560 --> 08:02.520]  хорошо, в этом случае отлично, мы будем с этим работать. Чудно. Вот, но что в этом случае необходимо?
[08:02.520 --> 08:08.520]  Необходимо доказать. Я подозреваю, что в школе у вас, когда метод мат-индукса, во всяком случае у меня
[08:08.520 --> 08:15.680]  так было, может меня поправите. Когда вот была сумма квадратов или что-то такое было, для того,
[08:15.680 --> 08:20.880]  чтобы найти там от 1 до n, необходимо было просто доказать. Вот типа нам дали выражение, такие докажите
[08:20.880 --> 08:27.440]  методом мат-индукции. Откуда взялась, что взяло, почему – никто не знает. Вот это примерно тот же метод.
[08:27.440 --> 08:33.920]  Предполагаем, смотрим, доказали, доказали, не доказали – грустная история, пробуем еще раз.
[08:33.920 --> 08:42.800]  То есть здесь нет какого-то такого глобального, не знаю, как его назвать-то правильно, теории
[08:42.800 --> 08:49.240]  заговора нет здесь. Вы ее не раскроете, потому что она просто здесь существует. И нужно подумать,
[08:49.240 --> 08:57.240]  как с этим жить. Возьмем, например, вот такую функцию. t от n равно 2t n пополам. Заметьте,
[08:57.240 --> 09:01.960]  у меня здесь нижнее округление. Почему? Потому что просто это удобнее. Бывают нижние,
[09:01.960 --> 09:06.840]  бывают верхние, бывает просто округление. Чаще всего берут что-то одно, просто легче это всегда
[09:06.840 --> 09:16.440]  оценивать. 2t n пополам плюс n. Вот нам нужно оценить эту штуку. Ну, давайте начнем с каких-нибудь
[09:16.440 --> 09:22.560]  предположений. Я возьму здесь сразу верное предположение, что это o большое от n log n.
[09:22.560 --> 09:30.280]  Хорошо выглядит? Ну, хорошо. Давайте пробовать, что делать. Что означает o большое? o большое
[09:30.280 --> 09:36.080]  означает, что оно меньше, чем c умноженное на n log n. То есть существует такое c, что оно
[09:36.080 --> 09:43.160]  ограничивает вот сверху вот эту функцию. То есть t от n меньше, чем c от n log n. Это наше
[09:43.160 --> 09:53.000]  предположение индукции. И нам его нужно доказать. Ну, смотрите, у любой математической индукции есть
[09:53.000 --> 10:00.240]  что? Есть база, есть переход индукции. Но база здесь всегда почти очень легкая. Единственное,
[10:00.240 --> 10:08.320]  что вы не можете взять здесь единичку, потому что для единички будет неверно. Потому что логарифм от
[10:08.320 --> 10:16.640]  единички чему равен? Нулю. Ну а здесь скорее все-таки t от n будет равно единице. То есть для единички оно
[10:16.640 --> 10:21.840]  не подходит. Но можно сказать, что мы возьмем какое-то n нулевое чуть подальше, чем единичка,
[10:21.840 --> 10:26.920]  и возьмем какое-то специальное c. И тогда все будет хорошо. Это действительно так, вы можете на это
[10:26.920 --> 10:37.360]  посмотреть. Вот. Чудно. Это вот такая вот база индукции. И дальше берем предположение индукции.
[10:37.360 --> 10:43.600]  Предположение какое? Что для любых меньше, чем n, а для любых m меньше, чем n. Предполагаем,
[10:43.600 --> 10:51.600]  что это верно. В том числе это верно для n пополам. Если это верно для n пополам, тогда вот то,
[10:51.600 --> 10:56.800]  что у меня написано посерединке. То есть t делить t от n пополам, оно меньше либо равно, чем c
[10:56.800 --> 11:06.000]  n пополам, но логарифм n пополам. Звучит все равно не круто, не классно. Но что нам это позволяет?
[11:06.000 --> 11:15.280]  Во-первых, сократить двойку. Это чудесно. Во-вторых, можно раскрыть логарифм. Если в логарифме есть
[11:15.280 --> 11:24.280]  деление, то это раскрывается как разность логарифма. Все верно. Вот. Именно этим я здесь и использую.
[11:24.280 --> 11:33.000]  Тогда подставляем это в t от n. Если мы это подставляем в t от n, то мы просто вот эту двойку опять же
[11:33.000 --> 11:39.960]  сокращаем. Получаем логарифм n пополам плюс n. Я здесь почему ставлю меньше либо равно? Потому
[11:39.960 --> 11:49.480]  что я вот это n пополам просто беру как число. Я убираю вот то самое округление вниз. Если бы у меня
[11:49.480 --> 11:54.840]  было округление вверх, тогда бы я должен был взять там n пополам плюс один. Что-нибудь такое. Вот здесь
[11:54.840 --> 12:02.600]  округление вниз мне помогло. Ну и плюс n? Раскрываю логарифм. Получаю c, n логарифм n,
[12:02.600 --> 12:11.480]  минус c, n логарифм 2, плюс n. Ну что я могу сказать здесь? Ну у нас логарифм здесь ну возьмем
[12:11.480 --> 12:18.840]  двоичный. Нам не важно. Константа все и так съест. Вот это c, которое существует, оно все и так съест.
[12:18.840 --> 12:26.240]  Но мы можем взять специально логарифм по основанию 2, тогда получим, что логарифм 2 по основанию 2
[12:26.240 --> 12:36.560]  это единичка. Чудно, тогда получаем c, n логарифм n, минус c, n, плюс n. Но вы согласны с тем, что это
[12:36.560 --> 12:47.840]  меньше, чем c, n логарифм n? Да любой c больше единички. Правильно? Потому что если я возьму c
[12:47.840 --> 12:53.960]  меньше единички, то будет неверно. Но если я возьму c больше единички, то это окажется верно. Вот оно наше
[12:53.960 --> 13:10.960]  доказательство индукции. Мы доказали для любого n. Это правда. Это правда. Здесь я не буду спорить.
[13:10.960 --> 13:19.360]  Можно попробовать. И мы даже это попробуем. Я больше скажу. Но в том суть здесь, что это все нам
[13:19.360 --> 13:30.280]  позволяет сделать? Что же такое это? Все это нам позволяет с вами посмотреть на то, что здесь
[13:30.280 --> 13:35.240]  происходит. Как минимум сверху мы уже ограничили. Можем ли ограничить еще? Можем попробовать.
[13:35.240 --> 13:41.840]  Естественно мы могли сказать o от n квадрат, o от n куб, o от n в четвертый, получить верный ответ.
[13:41.840 --> 13:48.920]  Да, не спорю. То есть ваши предположения могут сыграть вам на руку, а могут сыграть против вас.
[13:48.920 --> 13:57.880]  Потому что вы подумаете, что это рекуррент работает за n квадрат. Не круто. Вообще не круто. Но вы
[13:57.880 --> 14:04.200]  докажете. Но это не будет означать ничего. Для данной именно задачи. То есть в данной
[14:04.200 --> 14:10.120]  задаче это будут такие вещи. Пока мы будем ограничиваться вот таким методом и еще
[14:10.120 --> 14:16.240]  максимум с деревьями, потому что для других методов вам нужен чуть-чуть подкачать математический
[14:16.240 --> 14:23.440]  аппарат. Чуть-чуть. Как подкачаете, поверьте, научите. У вас будут какие-нибудь дискретная
[14:23.440 --> 14:36.760]  математика, дискретный анализ. Извините, все, я рассуждаю в рамках другого. Да, там такое тоже
[14:36.760 --> 14:43.440]  возможно. Скорее будет. Ну посмотрите, не знаю точно. Вы встретите слова в виде производящей
[14:43.440 --> 14:50.640]  функции и это решается с помощью них. Достаточно легкая вещь, когда вы знаете там разложение в
[14:50.640 --> 14:56.400]  ряды и все такое. Это немного просто другая штука. Поэтому здесь мы не будем на этом долго
[14:56.400 --> 15:11.240]  останавливаться. Окей. С этим понятно? Отлично. Какие есть ошибки? Вот то самое ОАТН. Возьмем
[15:11.240 --> 15:23.480]  ОАТН. Скажем, что пусть это так, тогда у нас Т от Н меньше, чем С от Н. Для С больше нуля. Ну,
[15:23.480 --> 15:28.840]  опустим любые предположения, связанные с единицей и так далее. Здесь оно в принципе подойдет.
[15:28.840 --> 15:36.640]  Окей. Тогда, рассуждая похожим образом, мы с вами в какой-то момент получим, что Т от Н меньше,
[15:36.640 --> 15:45.800]  чем два на С и Н пополам плюс Н. Ну, просто подставив. Правильно? Чудно. Мы подставили,
[15:45.800 --> 15:53.560]  сказали, что это так. Значит оно меньше либо равно, чем С и Н плюс Н. А потом вы говорите типа,
[15:53.560 --> 16:06.000]  С и Н плюс Н. Но это ОАТН. Все доказали. Где ошибка? Констант меняется. Еще что?
[16:06.000 --> 16:22.520]  Ну, с точки зрения формальной рассуждения, скажите, где ошибка? Предположение. Мы должны доказать
[16:22.520 --> 16:28.800]  предположение индукции. В нашем же случае мы предположение индукции не доказываем. У нас
[16:28.800 --> 16:33.600]  предположение, что меньше либо равно, чем С и Н. А здесь у нас получается меньше либо равно,
[16:33.600 --> 16:40.880]  чем С и Н плюс Н. Это уже неверное предположение. Значит, мы не доказали это методом от индукции.
[16:40.880 --> 16:49.120]  Поэтому не спешите все заносить в «О, большое Т, ты думаешь, что вот так хорошо? Она там лежит? Я
[16:49.120 --> 16:59.520]  его не трогаю? И у меня все хорошо». Нет. К сожалению, в эти моменты могут возникать не те вещи. Поэтому
[16:59.520 --> 17:09.960]  не делайте так. Второй способ решения, который доступен в общем виде, это деревья рекурсии.
[17:09.960 --> 17:17.280]  Что такое деревья рекурсии? На самом деле дерево рекурсии достаточно простая штука. Вы просто
[17:17.280 --> 17:30.680]  рисуете дерево. Вот у вас есть какая-то, например, задача, связанная с рекурсией, и вы в узле храните то,
[17:30.680 --> 17:38.480]  сколько действий потратится именно в этот момент на это выполнение. Однако все рекурсивные вещи вы
[17:38.480 --> 17:46.400]  спустите их как детей, и тогда получите такое вот дерево. У меня там будет пример. Давайте я что-нибудь
[17:46.400 --> 17:54.560]  попишу для приличия. Если мы с вами будем говорить о рекурсии именно в таком виде,
[17:54.560 --> 18:07.120]  ну не знаю, там скажу, что АТ от N равняется 3Т от N пополам, к примеру, плюс, там не знаю,
[18:07.120 --> 18:16.640]  ТТ от N. То есть смотрите, каждый раз я должен прибавлять вот это самое ТТ от N и как-то с ним
[18:16.640 --> 18:23.680]  жить, что-то с ним делать. Что я делаю здесь? Я на самом деле буду строить следующим образом. Вот на
[18:23.680 --> 18:34.080]  этом месте я буду делать цен действий. Плюсом к этому всему у меня появляется 3 ребенка. Эти
[18:34.080 --> 18:54.600]  три ребенка сколько действий делают? ЦН пополам. Ну смотрите, они же тоже работают за ТТ от N.
[18:54.600 --> 19:13.000]  Ну то есть ТТ от N пополам чему? Она равна 3Т от N на 4, плюс ТТ от N пополам. Правильно? Ну вот
[19:13.000 --> 19:22.160]  она. А так как я ограничил все ТТ от N с константой С, то я могу везде писать С. Правильно? Потому что я
[19:22.160 --> 19:27.760]  ж функцию говорю, что для любых. И вот в какой-то момент вот это вот все спустится до каких-то
[19:27.760 --> 19:48.520]  элементарных вещей. Ну там работающих, к примеру, за ТТ от единички. Ну и так далее. И что такое
[19:48.520 --> 20:07.720]  будет общее время работы ТТ от N? Это нужно просуммировать вот это все. Все верно. Да. Какая? Вот это?
[20:07.720 --> 20:18.440]  Ну это то же самое, только для N пополам. Для того, чтобы показать, что вот тут ТТ от N пополам,
[20:18.440 --> 20:30.760]  С от N пополам. Ну я могу сказать, что тут дальше продолжение будет СН на 4. У каждого будет опять
[20:31.720 --> 20:51.720]  Понятно, что я сделал? Смотри, у меня есть вот такая рекуррента. Она зависит от N пополам. Значит,
[20:51.720 --> 20:57.760]  я буду рассматривать следующий от N пополам. Для нее я буду рассматривать следующий от N пополам.
[20:57.760 --> 21:07.600]  И так далее. Согласен? Вот, поэтому здесь N пополам. Вот у тебя ТТ от N пополам. Конечно,
[21:07.600 --> 21:14.320]  константы это все съест. Ну первые константы, особенно. Потому что ну ТТ от N пополам это то
[21:14.320 --> 21:20.520]  же самое, что ТТ от N. Но так как я говорю про определенную константу С, то лучше писать вот
[21:20.520 --> 21:32.200]  так. Вот. И тогда в этом случае я смотрю, я как бы, что должен делать? Я смотрю, что вот на первом
[21:32.200 --> 21:43.560]  уровне у меня здесь СН. На втором уровне сколько? 3 СН пополам. На третьем уровне сколько будет?
[21:43.560 --> 22:05.720]  9 четвертых. 9 четвертых СН пополам. Неправда. Это рекурсивно так задано. У вас рекуррента такая,
[22:05.720 --> 22:14.320]  что у вас зависимость здесь N от N пополам, плюс выполнение действий ТТ от N. На каждом шаге.
[22:14.320 --> 22:35.400]  Сорри, да. Все верно. Она одинаковая. Ну как бы, мы в каком смысле рассуждаем? Мы же когда
[22:35.400 --> 22:43.040]  говорим, что у нас ТТ от N, мы можем сказать, ну какая-то там функция F от N, можем сказать,
[22:43.040 --> 22:53.000]  что F от N меньше, чем СН, правильно? Согласен? Ну если я скажу, что это F от N пополам, то это
[22:53.000 --> 23:05.480]  СН пополам. Я про ту же, одну и ту же константу. Вот. Потому что иначе бы ТТ от N. Ну единственное,
[23:05.480 --> 23:11.320]  что, ну как бы эти N должны быть какие? Большие достаточно. Ну и считается таким, чтобы это все
[23:11.320 --> 23:19.080]  таки симпатически верно работало. Но это не более того. Вот, мы каждый раз это считаем, и у нас
[23:19.080 --> 23:28.840]  получается вот такое вот восхитительное дерево. Интересное дерево, но интересное дерево. А до какого-то
[23:28.840 --> 23:33.840]  момента это будет продолжаться, там уже станет это от единички. В какой момент станет это от единички?
[23:33.840 --> 23:55.880]  Когда мы спустимся с вами вниз на логарифм N по основанию 3. Ой, два. Соря. Количество,
[23:55.880 --> 24:04.520]  количество 3, а это 2. Да. Мы уменьшаем все время в два раза. Вот. Ну а дальше мы должны сделать сумму ряда.
[24:04.520 --> 24:29.720]  Вот это? Ну представь следующее. Это строчка, но если убрать коэффициент 3, то это будет очень
[24:29.720 --> 24:35.600]  похоже на так называемый мёртвый сорт. Не то что так называемый, а действительно мёртвый сорт. Что под этим
[24:35.600 --> 24:44.880]  подразумевается? У тебя есть два массивчика половинчатых. Ну, к примеру. У тебя есть раз массивчик из N
[24:44.880 --> 24:54.320]  пополам элементов и два массива из N пополам элементов. Давайте потише. Отлично. А представь
[24:54.320 --> 25:00.360]  следующее. Они отсортированы между собой. Ну, то есть этот верх и этот верх. Тебе нужно получить из этого всего
[25:00.360 --> 25:08.520]  массив из N элементов, который тоже будет отсортирован. За сколько времени ты это сложишь?
[25:08.520 --> 25:21.480]  Ты должен по элементу насмотреть здесь и здесь. Какой меньше, тот сюда и класть. Согласен? Вот. Сколько
[25:21.480 --> 25:35.120]  раз элементов ты так пройдешь? N. Получается вот это то самое тетто от N. Плюс два t от N пополам.
[25:35.120 --> 25:45.160]  Потому что как-то я же эти отсортировал. Согласен? Плюс еще тетто от N, потому что я их смёржу.
[25:45.160 --> 25:54.440]  Но это количество действий на данном шаге. Сколько я потратил времени на данном шаге?
[25:54.440 --> 26:05.440]  Тебе не нравится, что я складываю с множеством? Это некоторая функция. Здесь воспринимается,
[26:05.440 --> 26:10.360]  что это некоторая функция оттуда. То есть я должен N элементов сюда переложить. Я считаю,
[26:10.360 --> 26:18.640]  что это произойдет асимптатически за тетто от N. Там есть какое-то конкретное число, грубо говоря,
[26:18.640 --> 26:24.600]  но я смотреть на него не буду. Я буду смотреть именно тетто от N. Асимптатически. Это некоторая
[26:24.600 --> 26:34.960]  функция, которая лежит в этом множестве. Так понятнее? А как тебя зовут, подскажешь? Саша.
[26:34.960 --> 26:53.280]  Что-то я сегодня только Сашу спрашиваю. Так, да. На C от N. В принципе, в какой-то момент можно,
[26:53.280 --> 27:07.200]  но что такое C? Можно так попробовать сделать. Это не спорю. Но есть проблема такая, более глобальная.
[27:07.200 --> 27:12.920]  Если у тебя количество элементов четное, то можешь одно количество делать. Если не четное,
[27:12.920 --> 27:17.960]  то другое. Тетто от N все это в себя взбирает. Ну да, плюс-минус один, грубо говоря,
[27:18.960 --> 27:28.360]  а здесь же ты когда конкретно напишешь, это может быть немного проблемно. Привыкайте к тете и к
[27:28.360 --> 27:36.120]  о большому. Окей, и дальше мы все это складываем. Я вам сейчас покажу пример немного на другой
[27:36.120 --> 27:50.080]  рекурренте. Вот, а еще я вам покажу, я забыл в прошлый раз сказать, что такое знание алгоритмов.
[27:50.080 --> 28:00.840]  Знание алгоритмов это вот это. Кто знает, что это? Так, какая? Правда. Алгоритмы по строению
[28:01.840 --> 28:10.360]  Это самая важная книга по алгоритмам в принципе, которая рекомендует вообще все, всегда. Написана
[28:10.360 --> 28:16.880]  достаточно нетривиальным языком, я бы сказал. Это книга Кормана. Там на самом деле четыре автора,
[28:16.880 --> 28:28.440]  но по факту книга Кормана. В ней если что, сейчас скажу, 1300 страничек. Вот, написанных достаточно
[28:28.440 --> 28:35.640]  небольшим шерифтом, если вы думаете. Частично я беру материалы отсюда, частично нет, но в том
[28:35.640 --> 28:41.440]  суть, что здесь по сути лежит все. Вот все, что вам будут рассказывать, вот почти в глобальном масштабе
[28:41.440 --> 28:47.160]  будет здесь. Единственное, там есть некоторые исключения, например там, не знаю, какие-то вещи,
[28:47.160 --> 28:53.640]  которые мы вам объясняем, они даны как упражнения. Вот, и вы должны сами подумать, как это сделать.
[28:53.640 --> 28:59.960]  В общем, в глобальном виде оно здесь, все остальное описано, можно посмотреть всегда, поэтому всем
[28:59.960 --> 29:05.600]  рекомендую, если что, ну не прикупиться. В библиотеке, по-моему, она существует, ну либо взять хотя бы
[29:05.600 --> 29:14.200]  электронную версию, чтобы если что у вас было. Если, ну вы можете попробовать это взять, да. Можете
[29:14.200 --> 29:24.280]  посмотреть, что это вообще такое. Это фундаментальный труд. Что-то все закашли резко. Ужас. Видимо,
[29:24.280 --> 29:29.880]  вам очень не нравится и вы пытаетесь испугнуть эту книгу. Нет, она вас будет преследовать. Так вот,
[29:29.880 --> 29:36.840]  вернемся к дереву рекурсии. Что там происходит и что мы делаем. Я здесь взял немного другой
[29:36.840 --> 29:43.200]  пример. Пример действительности из того же Кормана. Тут даже будут картиночки из Кормана.
[29:43.200 --> 29:51.120]  Возьмем, потому что рисовать в презентации все эти деревья мне, честно, было категорически
[29:51.120 --> 30:02.040]  сложно, поэтому я просто взял это для фоточки. Возьмем такую рекурсию. t от n равно 3t n делить на
[30:02.040 --> 30:10.600]  4. Плюс t от n квадрат. А мы возьмем 3t n делить на 4 плюс t от n квадрат. Что в этом случае делать?
[30:10.600 --> 30:22.720]  Да. Я вам привел алгоритм, пример, для вот этой вот штуки. На три? Ну три кучки мердж.
[30:22.720 --> 30:37.880]  n делить на три, n делить на три, n делить на три. Давайте еще раз. Эти массивы были сформированы
[30:37.880 --> 30:43.840]  самостоятельно. Мы пока на них не смотрим. Для того, чтобы сюда положить элементик,
[30:43.840 --> 30:56.840]  друзья, чтобы первый элемент положить, ты должен сравнить отсюда, 2 отсюда, 3 отсюда и
[30:56.840 --> 31:07.120]  переложить. Согласен? На каждый из этих элементов я трачу раз, ну там, даже взять так, раз, два,
[31:07.120 --> 31:16.600]  два сравнения плюс перекладывание. Там три действия. Я таких действий делаю n. Суммарно их
[31:16.600 --> 31:25.800]  получается 3t n. Если бы мы не смотрели на массивы, то почему, нам уже даны ассортированные массивы,
[31:25.800 --> 31:34.800]  почему мы тогда прибавляем еще 3t n пополам на их ассортировку? А, вот здесь? Ну здесь n на 3.
[31:34.800 --> 31:46.560]  3t n пополам? Господи, прости, я взял просто рекурренту, друзья. Нет какого-то, прям как
[31:46.560 --> 31:55.320]  какого-то сакрального, сакрального здесь смысла. Потому что я точно знаю, что это t,
[31:55.320 --> 32:03.640]  t, t, t сильнее всегда. Все просто. Давайте посмотрим на дерево рекурсии, вот то рекуррент,
[32:03.640 --> 32:08.120]  которое у нас было. Давайте я сейчас запишу, на всякий случай, чтобы вы не путались со всеми
[32:08.120 --> 32:22.960]  остальными. Вот, а давайте я сейчас перепишу. Это 3t n делить, что там, на 4,
[32:22.960 --> 32:37.400]  плюс тета от n квадрат. Вот я сейчас рассматриваю эту рекурренту. И что-то я с ней делаю. Смотрите,
[32:37.400 --> 32:42.640]  первое дерево рекурсии. Ну, если мы возьмем первые элементики, то у меня будет cn квадрат,
[32:42.640 --> 32:53.200]  tt n делить на 4. Ну, к примеру, что там n делить на 4, оно уже пришло к своему апогее. А если мы скажем,
[32:53.200 --> 33:02.600]  что нет, не пришло, тогда мы еще больше развернем в этом случае количество действий. Вот. А по поводу
[33:02.600 --> 33:07.800]  вопроса с точки зрения питона, почему мы не посчитаем и просто не умножим. Вопрос следующий,
[33:07.800 --> 33:13.480]  вот у тебя есть 3 массива. Это 3 разных массива. Как ты каждый из них умножишь?
[33:13.480 --> 33:22.920]  Ну, типа ты для каждого из них выполняешь какие-то действия. Вот. Мы продолжаем это
[33:22.920 --> 33:36.040]  рекурсивное дерево и получаем вот такой вот его вид. Красиво, красиво. Я говорю, мне было,
[33:36.040 --> 33:43.280]  правда, честно признаюсь. Вот. На первом действии это cn квадрат. Почему? Потому что тут tt от
[33:43.280 --> 33:51.960]  n квадрат. На вторых, там уже идет cn делить на 4 в квадрате количество действий. Поэтому здесь
[33:51.960 --> 33:59.760]  мы можем сложить вот эти три штуки, получу 3 шестнадцатых cn квадрат. Дальше получу квадрат
[33:59.760 --> 34:04.640]  этих вещей, то есть 3 шестнадцатых в квадрате cn квадрат и так далее. То есть то же самое,
[34:04.640 --> 34:14.920]  что здесь. Здесь было 3 вторых, 9 четвертых и так далее. Согласны? Что это такое? Вот это вот.
[34:14.920 --> 34:24.880]  1, ага, действительность. Да, это геометрическая прогрессия. Как-то с ней нужно жить. На последнем
[34:24.880 --> 34:33.800]  уровне, я надеюсь вы понимаете почему, tt от n в степени логарифм 3 по основанию 4. Понятно?
[34:33.800 --> 34:42.440]  Но мы каждый раз увеличиваем в 3 раза, вниз мы делаем логарифм n делить на 4 действия. Вот и все.
[34:42.440 --> 34:53.720]  Поэтому у нас такое количество. Давайте все это суммировать, смотреть что получается. Красиво
[34:53.720 --> 35:00.600]  выглядит. Здесь не хватает знака суммы почему-то. Грустная история, то есть тут лимиты написаны,
[35:00.600 --> 35:07.000]  а знака суммы не хватает. Такой забавный, конечно, забавный вид. Ладно, я потом это перепишу так,
[35:07.000 --> 35:19.480]  чтобы вам было красиво. Да. Спасибо. Тут уж извините, я это пишу в ночи, иногда могу ошибаться.
[35:19.480 --> 35:28.080]  За русский язык не ручаюсь, правда. У меня было 80 баллов по-русскому, простите, 8 стадий. Ваше
[35:28.080 --> 35:39.480]  время я бы... Ладно, я бы поступил. Все было хорошо, у меня был бы вы. Так вот, если мы возьмем это tt от n,
[35:39.480 --> 35:46.280]  вот у нас есть какая-то огромная сумма. Это сумма геометрического ряда плюс некоторое тета,
[35:46.280 --> 35:52.600]  которое получилось из нижнего уровня. Давайте смотреть, что мы сделаем. Мы суммируем от нуля
[35:52.600 --> 36:03.600]  до логариев n-1 по основанию 4, 3 шестнадцатых степени на cn квадрат. Мы получаем вот такую
[36:03.600 --> 36:09.840]  геометрическую прогрессию. Круто, классно, мы умеем считать эту геометрическую прогрессию,
[36:09.840 --> 36:18.000]  сумма убывающей геометрической прогрессии, достаточно понятно. Правда? Чудно. Мы это получаем. Такие
[36:18.000 --> 36:25.120]  классно, круто. А что делать дальше? Что с этим делать вообще? Оно выглядит неприятно и непонятно в
[36:25.120 --> 36:34.160]  итоге. Это n в степени логарифма ограничения или cn квадрат. Поэтому здесь надо применить просто
[36:34.160 --> 36:39.960]  следующее. У нас есть сумма бесконечной геометрической прогрессии. Если я добавлю хвост к своей прогрессии,
[36:39.960 --> 36:47.920]  ничего не изменится, только увеличится. Поэтому я поставлю знак меньше, строго меньше, и получу с вами,
[36:47.920 --> 36:52.800]  что у меня есть бесконечная геометрическая прогрессия, поэтому я могу просто написать 1
[36:52.800 --> 37:00.400]  делить на 1 минус 3 шестнадцатых cn квадрат. Красиво? Красиво. Это мы с вами и используем здесь.
[37:00.400 --> 37:04.920]  Таким образом, мы получим точное число шестнадцатых тринадцатых cn квадрат,
[37:04.920 --> 37:12.600]  а плюс это от n в степени какой-то логарифм, ну какая-то константа. Эта константа явно меньше
[37:12.600 --> 37:21.360]  квадрата. Правильно, правильно. Поэтому это все o от n квадрат. То есть, если мы получили с вами
[37:21.360 --> 37:28.280]  такую рекурриенту, то все это работает за o от n квадрат. А теперь, смотрите, я скажу,
[37:28.280 --> 37:41.360]  что это работает за t от n квадрат. Почему? Да, можно это просто снизу ограничить, причем не просто,
[37:41.360 --> 37:48.720]  ну даже 3 шестнадцатых не обязательно, вот t от n квадрат. Ну все, снизу она ограничена
[37:49.320 --> 38:08.560]  точно, потому что вот эта сумма что-то дает. Еще раз. Почему? Нет, мы не забивали. Вот это cn
[38:08.560 --> 38:14.440]  квадрат, 3 шестнадцатых cn квадрат, это все от это. Это все идет от это. Еще раз,
[38:14.440 --> 38:19.560]  смотрите на это дерево. Видите, первое действие, которое требует вот корень,
[38:19.560 --> 38:28.440]  который там есть, написано cn квадрат. Этот cn квадрат получился отсюда, а дальше у него есть
[38:28.440 --> 38:39.760]  3 ребенка, которые от n не четвертые, значит они cn на 4. Вот, и так далее. То есть, вот такое тоже
[38:39.760 --> 38:46.440]  бывает. Поэтому здесь, да, в действительности, если мы с вами рассмотрим, то здесь не просто
[38:46.440 --> 38:53.320]  у от n квадрат, а t от n квадрат. Красиво-красиво, то есть вот это слагаемое в итоге нам ничего не
[38:53.320 --> 39:10.680]  испортило. Ага, да. Нет, это конечно. Там по-разному, смотря какие тут коэффициенты будут еще. Вот,
[39:10.680 --> 39:17.720]  к примеру, здесь вот 3n пополам. Смотрите, здесь какая прогрессия? Неубывающая. Мы просто так
[39:17.720 --> 39:29.240]  не ограничим. Нужно думать, что делать. Да. Смотрите, на последнем уровне сколько элементов? Вот там
[39:29.240 --> 39:36.920]  вот везде t от единички. Ну, один элемент какой-то. С ним нужно понять, сколько таких элементов. Ну,
[39:36.920 --> 39:47.560]  мы вниз спустились сколько раз? Логарифм n по 4, а каждый раз количество детей увеличилось в 3.
[39:47.560 --> 39:57.840]  Ну вот, твое количество это n в степени, логарифм 3 делить на 4. Ой, господи, 3 по основанию 4.
[39:57.840 --> 40:12.520]  Так, хорошо. Давайте так, начнем с простого. У нас есть дерево. Сколько находится на этом уровне?
[40:12.840 --> 40:26.280]  Это нулевой уровень, первый, второй. Два в степени. Вот так находится здесь. Здесь у нас 3 в степени логарифм.
[40:26.280 --> 40:51.840]  N по основанию 4. Поменять можем? Извините, на выражение лица было бесценно. Количество,
[40:51.840 --> 40:57.040]  сколько этих элементов? Почему мы можем вот это взять и поменять вот эту тройку с четверкой?
[40:57.040 --> 41:17.920]  Свойство логарифма существует, правда? Так, какой момент мне из этого объяснить? Давай ты
[41:17.920 --> 41:27.440]  подойдешь после, я тебе покажу свойство логарифма, хорошо? Ты смотришь на меня очень недоверчиво. Мне страшно.
[41:27.440 --> 41:33.400]  Смотрите, да, это действительность, но есть несколько свойств у логарифма,
[41:33.400 --> 41:36.800]  чего как можно переносить. Если я здесь поменяю местами, ничего не произойдет.
[41:36.800 --> 41:54.240]  Еще вопросы есть? Вопросы задавать не бойтесь, все нормально. Здесь было немного про другое просто.
[41:54.240 --> 42:04.240]  Хорошо. Понятно, как работать с деревом рекурсии. То есть нужно как-то сверху что-то оценивать.
[42:04.240 --> 42:11.560]  Почему? Непонятно, но вот так. Но количество действий хотя бы понятно, откуда берется. То есть каждый
[42:11.560 --> 42:18.400]  ряд просуммировали, все, получили нам ответ. Вот это теорема, я ее доказывать вам не буду,
[42:18.400 --> 42:25.080]  потому что это а, занимает пару страниц 4, б, наверное, не самая полезная теорема в вашей
[42:25.080 --> 42:37.240]  жизни будет. Вы вряд ли ее доказательства запомните. А? Почитайте. Все включил. Тебе точно.
[42:37.240 --> 42:45.760]  Смотрите, эта теорема будет без доказательств точно и даже, наверное, не буду ее спрашивать.
[42:45.760 --> 42:52.600]  Здесь главный принцип-то какой? Пусть у нас есть некоторая рекурсивная формула, что там
[42:52.600 --> 42:59.920]  t от n равно a, t от n делить на b, плюс f от n. А больше либо равно единице, b строго больше единице.
[42:59.920 --> 43:05.960]  Потому что если равно единице, тут все совсем просто становится. Вот. f от n просто некоторая
[43:05.960 --> 43:16.960]  функция. Окей. Теперь смотрите, если f от n это o большое от n в степени логарифм a-epsilon по
[43:16.960 --> 43:24.960]  основанию b, где epsilon любое, то все хорошо. Важный момент. Здесь опять мы будем применять вот такие
[43:24.960 --> 43:32.960]  вот свойства с логарифами. Потому что мы переведем немного в другие степени. Н в квадрате, n в кубе,
[43:32.960 --> 43:41.120]  что-нибудь такое. Тогда в этом случае мы строго можем сказать, что это t от n в степени логарифма
[43:41.120 --> 43:55.200]  a по основанию b. Это первое. Второе. Это то, что если у нас f от n это θ от какой-то n в степени логарифм
[43:55.200 --> 44:03.080]  a по основанию b, здесь нет никакого epsilon, ничего не происходит. Тогда здесь t от n это θ от n в
[44:03.080 --> 44:11.080]  какой-то степени плюс логарифм, умноженный на логарифм. Ну и последнее, это если это омега
[44:11.080 --> 44:20.720]  большое, то есть снизу ограничено чем-то с plus epsilon. Друзья, пожалуйста, ну либо встаньте,
[44:20.720 --> 44:30.920]  уйдите, не мешайте, бога ради. Окей. В этом случае добавляются еще дополнительные ограничения на
[44:30.920 --> 44:39.600]  f. То есть смотрите, во-первых, здесь омега большое, то есть ограничено с ней. Во-вторых,
[44:39.600 --> 44:49.640]  a на fn делить на b должно быть меньше либо равно, чем cf от n для некоторой константы c, что тоже непонятно,
[44:49.640 --> 44:55.920]  типа выглядит неприятно. И тогда для всех достаточно больших θ от n это будет то же самое,
[44:55.920 --> 45:03.400]  что θ от f от n. По факту, что нам показывает эта теорема в общем-то виде? В общем, в виде она
[45:03.400 --> 45:11.920]  показывает следующее, вот если мы разбиваем с вами и у нас f от n это там o большое от вот этого n в
[45:11.920 --> 45:19.840]  степени логарифма, то есть оно делит меньше, чем нам нужно, тогда в этом случае мы смотрим лишь
[45:19.840 --> 45:28.440]  на первую часть. То есть вот это tn делить на b. То есть f не дает сильного вклада. В последнем же
[45:28.440 --> 45:34.600]  случае f дает сильный вклад и поэтому все от f зависит. В среднем же случае мы говорим,
[45:34.600 --> 45:43.400]  что оно и оттуда и оттуда и вашим и нашим, поэтому здесь будет серединка такая. Понятно? Не скажу,
[45:43.400 --> 45:54.000]  что это теорема, типа вот все вы должны вызубрить, запомнить, снижить. Нет, конечно. Это просто вам
[45:54.000 --> 46:05.000]  на то, чтобы вы чем-то проще делали. Ну все, на сегодня мы с математикой закончили в каком-то
[46:05.000 --> 46:19.160]  общем виде. Остались ли вопросы к рекуррентам у вас сейчас? В голове держать? Ну это просто вот
[46:19.160 --> 46:23.960]  в голове ты держишь и все. Ну вот рекурренты, ну надо как-то решить. Ну ты как-то решаешь.
[46:23.960 --> 46:32.600]  Все достаточно просто. С рекуррентами на самом деле, а вот пока у вас эти два способа и мы
[46:32.600 --> 46:40.520]  пытаемся с ними как-то жить. Ну что-то с ними делать. Если мы с вами будем говорить про, не знаю там,
[46:40.520 --> 46:46.120]  вот у нас есть рекурренты, если мы четкое решение рекурренты хотим, тогда в этом случае нам
[46:46.120 --> 46:52.200]  действительно понадобятся производящие функции, либо характеристическое уравнение, что-нибудь из
[46:52.200 --> 46:57.840]  этого и с помощью этого решать. Но это не сейчас, потому что это ровно так же, что я вам буду...
[46:57.840 --> 47:05.040]  Вот про рекурренты. В действительности мы с рекуррентами встретимся с вами в одном из случаев.
[47:05.040 --> 47:10.480]  Это будет, это будет быстрая сортировка. Там я с вами буду говорить про рекурренту и про то,
[47:10.480 --> 47:18.880]  что типа вы ее сами будете решать. Я лишь скажу результат. На экзамене я попрошу вас это решить,
[47:18.880 --> 47:25.640]  но так в общем мы скорее время на это тратить не будем, мы будем говорить о том, что там
[47:25.640 --> 47:31.480]  происходит. Научить рекурренту решать я вас научу. Подставить я уж думаю вы сможете,
[47:31.480 --> 47:41.120]  потому что вы знаете, за сколько это работает. Вот. Когда мы с вами прошли вот это все, мы переходим
[47:41.120 --> 47:48.680]  к действительности блока с алгосами. Так как пока у вас не так много такой базы по плюсам,
[47:48.680 --> 47:54.680]  мы начинаем с достаточно простых алгоритмов. Но поверьте, мы очень скоро уйдем куда-то в
[47:54.680 --> 47:59.520]  глубь, потому что всей базы плюсов типа хватит вам, ну, наверное, за первые 5 недель,
[47:59.520 --> 48:04.120]  это будет достаточно, чтобы реализовать все остальные алгоритмы в каком-то виде. Не скажу,
[48:04.120 --> 48:12.760]  что хорошо. Просто в каком-то. Так вот. Первое это алгоритм Евклида. Скорее всего вы встречались с
[48:12.760 --> 48:19.680]  ним в школе. Вам рассказывали, что существует такой Евклид. Он придумал свой алгоритм для
[48:19.680 --> 48:26.000]  нахождения наибольшего общего делителя. Наибольший общий делитель числа, ну, в принципе,
[48:26.000 --> 48:33.600]  это тот, на который делится и первое, и второе число. Все достаточно просто. Самый наивный подход
[48:33.600 --> 48:39.360]  к этому всему, это просто перебрать все числа от первого до минимального из двух чисел и сказать,
[48:39.360 --> 48:47.840]  ну вот он тогда наш минимальное число. Классно это? Ну нет, это работает слишком долго. Для этого
[48:47.840 --> 48:53.800]  существует тот самый алгоритм Евклида. Его существует две версии. Первая версия опирается на то,
[48:53.800 --> 49:01.080]  что наибольший общий делитель ГЦД, если что, это по-английски наибольший общий делитель. Да? Кто
[49:01.080 --> 49:13.480]  сможет? Правильно. Отлично. Ни в коем случае не пишите, когда вы будете реализовывать нод. Ну вот,
[49:13.720 --> 49:24.040]  по-английски вы такие, ну я же англичанин. Вот, типа нод. Нет, это неправда, это ГЦД. Все-таки
[49:24.040 --> 49:31.680]  давайте будем следовать английскому не только в транслите. Так вот, у нас есть наибольший общий
[49:31.680 --> 49:39.640]  делитель от А и Б, и это означает следующее, что он есть доказательство, что он равен, во-первых,
[49:39.640 --> 49:44.800]  наибольшему общему делителю от А и Б минус А. Если мы считаем, что без ограничения общности,
[49:44.800 --> 49:52.040]  то Б больше чем А. Вот, БОО это без ограничения общности. Возможно, вы в мотоне уже с этим
[49:52.040 --> 50:00.160]  столкнулись. И еще это то же самое, что А, что наибольший общий делитель от А и Б процент А,
[50:00.160 --> 50:07.280]  то есть взятие остатка. В этом плане мы можем всегда брать и смотреть, что происходит. В какой
[50:07.280 --> 50:11.720]  момент какой из алгоритмов останавливается. Но если мы вычитанием работаем, то если что-то
[50:11.720 --> 50:19.400]  станет нулем, если мы говорим с вами про взятие с остатком, то это то же самое, когда что-то станет
[50:19.400 --> 50:26.760]  нулем, когда один начнет делиться над другой. Это вариант остановки. А рассмотрим первый вариант.
[50:26.760 --> 50:33.760]  Достаточно просто. Я пишу здесь все-таки ближе к питону. Вам нужно будет все-таки писать на плюсах.
[50:33.760 --> 50:39.880]  Специально взял другой язык. Псевдокод некрасиво подсвечивается, поэтому уж на питоне.
[50:39.880 --> 50:46.440]  Так вот, если мы с вами говорим про наибольший общий делитель, в этом случае то, что мы делаем,
[50:46.440 --> 50:53.000]  что если один больше другого, тогда вычтем из большего меньше. Иначе, наоборот, будем вычитать
[50:53.000 --> 50:59.520]  до тех пор, пока у нас один не станет равен нулю, и тогда тот, который не равен нулю, становится
[50:59.520 --> 51:06.320]  нашим наибольшим общим делителем. Но что в этом случае происходит? Один ноль, другой наибольший
[51:06.320 --> 51:15.080]  общий делитель. Как понять, кого выбрать? Можно заевфать. Типа, если а равно нулю, то надо сказать,
[51:15.080 --> 51:21.000]  что наибольший общий делитель равен b. Иначе наибольший общий делитель равен a. Это не круто.
[51:21.000 --> 51:28.160]  Зачем писать много бесполезных строк, когда можно просто взять сумму? Потому что один из них нулевой,
[51:28.160 --> 51:34.480]  другой не нулевой. Вот этот не нулевой и будет в этой сумме. Понятно? Все просто. Не пытайтесь из
[51:34.480 --> 51:43.360]  этого сделать что-то вот, нужно строго, как вот вот прям вот сказали, ну если это ноль, то это нет.
[51:43.360 --> 51:49.360]  Всегда выкручивайтесь из того, что есть. Не пишите много скода, это лень, и вы действительно скоро
[51:49.360 --> 51:59.920]  в этом привыкнете. Но есть проблема этого алгоритма Евклида. Какая? В том, что в наихудшем случае это
[51:59.920 --> 52:09.040]  будет долго работать. Возьмем, например, число a равное единичке и b равное десять восьмой. Он
[52:09.040 --> 52:16.640]  будет из десять восьмой постоянно вычитать единичку. Приятно это, но не очень. Он будет
[52:16.640 --> 52:22.800]  десять восьмой раз это делать. То, что у вас это произойдет за одну секунду, дай бог. Потому что он
[52:22.800 --> 52:32.000]  здесь еще и фает, смотрит, вайлом проходит. Некруто. Это не прикольно, поэтому здесь мы вам такое не
[52:32.000 --> 52:43.960]  советуем. А советуем использовать алгоритм Евклида с остатком. Алгоритм Евклида с остатком выглядит
[52:43.960 --> 52:53.080]  то же самое, просто вместо минуса процент. Все довольно просто и очевидно. Но это идет из
[52:53.080 --> 52:59.000]  определения, наибольшего общего делителя. А дальше, когда что-то стало равно нулю, опять возьмем просто
[52:59.000 --> 53:09.200]  сумму и получим то, что нам необходимо. Хорошо это хорошо, но за сколько же это работает? Вот я вам
[53:09.200 --> 53:21.600]  здесь написал. А вы понимаете, что здесь написано? А почему? Смотрите, считайте это загадкой Жака
[53:21.600 --> 53:27.360]  Фреско для вас. Попробуйте дома, погуглите, подумайте, что здесь происходит. В действительности есть
[53:27.360 --> 53:36.600]  отдельное доказательство на тему того, что в этом случае вам необходимо взять соседние числа
[53:36.600 --> 53:43.720]  Фибоначчи, и это будет худший случай для N чисел. Ну для какого-то там числа N, грубо говоря. Вот
[53:43.720 --> 53:50.720]  ближайшие два числа Фибоначчи до этих чисел. И это будет худшее время работы данного алгоритма.
[53:50.720 --> 53:57.120]  Это первое, что здесь нужно усвоить. Почему это так? Но это связано с самым делом с сетем остатка.
[53:57.120 --> 54:04.080]  Там можно это представить в необходимом виде. Это раз. Второе, числа Фибоначчи представимы вот
[54:04.080 --> 54:13.960]  в таком восхитительном виде. 1 делить на корень из 5 на 1 плюс корень из 5 на 2 в степени. Ну вот так они
[54:13.960 --> 54:22.200]  могут представляться на самом деле. Красиво, но не сказать что. Но что мы из этого можем сказать? Мы
[54:22.200 --> 54:28.400]  можем посчитать количество действий. Потому что если он будет идти по числу Фибоначчи, он будет
[54:28.400 --> 54:35.280]  просто по ним спускаться. Вот мы можем здесь понять количество действий. И тогда здесь на самом деле
[54:35.280 --> 54:43.200]  количество действий, но N, это просто логарифм от ФН. Ну с какой-то там константой. Согласны?
[54:43.200 --> 54:55.720]  Да. Ну там есть минус один, ну там есть с минусом, там есть один плюс корень из 5, есть один минус.
[54:55.720 --> 55:17.400]  Оно всегда будет иррационально. Смотрите, это написано асимптотически, как это выглядит. К этому
[55:17.400 --> 55:23.280]  можно привести то, что у вас есть. То, что вы сказали, это точное число Фибоначчи. Меня не
[55:23.280 --> 55:29.280]  интересует точно. Меня интересуют асимптотики всегда. Вот. Поэтому для N-ого числа я могу сказать,
[55:29.280 --> 55:39.480]  что оно такое. Ну в N-ой штуке. И тогда в этом случае я говорю, что если у меня есть FN, то есть я
[55:39.480 --> 55:47.120]  нахожу наибольший общеделитель для N-ого числа Фибоначчи. N это число само по себе, значит мне
[55:47.120 --> 55:52.720]  нужно спуститься сильно вниз. Сколько раз я буду спускаться? Ну все достаточно просто,
[55:52.720 --> 56:00.320]  так как я буду все время вмешаться на один. Я скажу, что N это логарифма FN. А значит,
[56:00.320 --> 56:07.880]  а в худшем случае время работы вот этого алгоритма, это O от логарифма, от минимума этих двух чисел.
[56:07.880 --> 56:17.840]  Ты можешь проверить, как работает этот алгоритм на числах Фибоначчи. Да.
[56:22.720 --> 56:32.560]  На единицу в плане N-1 числа Фибоначчи. Вот. Попробуйте дома, почитайте, подумайте,
[56:32.560 --> 56:39.640]  что здесь происходит. Теперь поговорим про другие алгоритмы. Другой алгоритм у нас это
[56:39.640 --> 56:47.640]  бинарный поиск по ответу. А что такое бинарный поиск по ответу? Я вам не рассказываю пока просто
[56:47.640 --> 56:52.480]  про бинарный поиск, потому что вы еще массивы не дошли. Но бинарный поиск по ответу мы же можем
[56:52.480 --> 57:00.440]  с вами поговорить. Бинарный поиск по ответу это достаточно простая штука. А как она выглядит?
[57:00.440 --> 57:07.240]  Она выглядит примерно в следующем виде, что у нас есть ответы, мы знаем, в каком диапазоне они
[57:07.240 --> 57:18.800]  лежат. Там от минус N до плюс N. От минус N до N. И я могу каждый раз, я знаю, что и то, и то
[57:18.800 --> 57:24.320]  достижимо. И я могу по серединкам ходить, в зависимости от того, осознавая, как рекуррентно все зависит.
[57:24.320 --> 57:30.720]  Могу смотреть, подходит это под ответ или нет, больше чем какой-то ответ или нет. И в зависимости
[57:30.720 --> 57:39.520]  от этого смотреть. Самый простой смысл с точки зрения бинарного поиска по ответу – это пояс
[57:39.520 --> 57:46.640]  корни из числа. Пояс корни из числа можно сделать с помощью бинарного поиска. Ну как сказать? Ну пусть
[57:46.640 --> 57:53.160]  у меня есть неотрицательное число, там до 10-18. Мне необходимо с точностью 10-10 найти это число.
[57:53.160 --> 58:01.520]  Самый минимальный корень, какой может быть ноль? Самый максимальный – это 10 в 9, согласны? Чудно. И
[58:01.520 --> 58:09.040]  тогда я просто буду брать середину и смотреть. Ага, если это число в квадрате в середине будет
[58:09.040 --> 58:16.200]  больше, чем мое число А, тогда в этом случае я должен пойти влево, то есть уменьшить наше
[58:16.200 --> 58:23.040]  число. Если оно же больше, тогда я должен пойти вправо. Ой, если серединка меньше в квадрате. Тогда
[58:23.040 --> 58:30.920]  я иду вправо, потому что мне необходимо увеличить это число. И я здесь буду двигать так называемые
[58:30.920 --> 58:38.320]  правые и левые границы. Правые и левые границы сначала являются ноль и 10 в 9. То есть тот диапазон,
[58:38.320 --> 58:43.880]  где оно лежит. И я буду так сужаться, сужаться, сужаться до какого-то момента. На самом деле я буду
[58:43.880 --> 58:51.860]  здесь сужаться до момента, пока разность этих диапазонов не будет 10 в минус 10. Как только она
[58:51.860 --> 58:59.680]  будет, я сразу попаду в нужный мне диапазончик. Окей? Реализация здесь достаточно простая. Вот у меня
[58:59.680 --> 59:06.800]  есть левая, есть правая граница. Я говорю, что пока правая минус левая граница больше, чем 10 в минус
[59:06.800 --> 59:14.040]  10, тогда я буду брать середину, возводить эту середину в квадрат. Если эта середина больше
[59:14.040 --> 59:21.040]  либо равна а, тогда мне надо уходить влево. Значит, я говорю, что правую границу я сдвигаю на серединку.
[59:21.040 --> 59:40.720]  Число. Мне надо найти корень из-за. Да, извините, но здесь суть не изменится. Поэтому так можно найти
[59:40.720 --> 59:47.880]  корень. Ну и последнее на сегодня, и мы с вами как раз укладываемся в тайминг, и я вас не
[59:47.880 --> 59:55.880]  передержу. Задача с бешеными ксероксами. Ну, я и так назвал. На самом деле задача просто с принтерами
[59:55.880 --> 01:00:01.800]  или с ксероксами, всегда по-разному называют. У нас есть какой-то один листочек. Там есть вообще
[01:00:01.800 --> 01:00:13.040]  красивая преамбула этой задачи, что вот у нас там есть... Да, у нас есть распечатанные условия. Вот
[01:00:13.040 --> 01:00:20.440]  его нужно срочно взять и откопировать, наверное, участников Олимпиада, потому что там изменилась
[01:00:20.440 --> 01:00:27.880]  какая-то задача. Я чуть полегче написал просто. У нас есть один листочек, есть два ксерокса. Один
[01:00:27.880 --> 01:00:38.560]  копирует за х секунд, второй за у. За сколько они вместе могут напечатать ян листов. Что здесь важно
[01:00:38.560 --> 01:00:45.840]  понимать? Ну, первое, очевидно, что если нужно сделать 0 копий, то это займет 0 секунд. Это наша
[01:00:45.840 --> 01:00:56.000]  левая граница. Второе, очевидно, что если взять максимальное количество... Ну вот, у меня есть первый
[01:00:56.000 --> 01:01:02.800]  принтер за 5 секунд, второй за 10. Вот если я во второй принтер загружу копии делать, 10 умножить
[01:01:02.800 --> 01:01:12.080]  на вот это n, то это будет время, которое максимально, в принципе, возможно. Согласны? Вот. Потом мне
[01:01:12.080 --> 01:01:17.880]  нужно искать минимальное. Сейчас будем это пробовать сделать. Как мы это можем сделать? Ну,
[01:01:17.880 --> 01:01:23.960]  во-первых, если нам нужно сделать всего одну копию, то ее достаточно сделать на самом быстром
[01:01:23.960 --> 01:01:34.680]  принтере, ксероксе, извините. Это факт, который нам нужно себе оценить. А дальше, как только я сделаю
[01:01:34.680 --> 01:01:41.440]  эту первую копию, то я положу одну копию в один принтер, а другую в другой. И только с этого момента
[01:01:41.440 --> 01:01:48.960]  я начну все копировать в нужном мне порядке. Значит, там будет n-1 количество копий, сколько мне
[01:01:48.960 --> 01:01:56.680]  нужно сделать, я его буду делать и на x, и на y. И каждый раз я буду что-то смотреть, как это делать.
[01:01:56.680 --> 01:02:02.880]  Ну, какое количество времени здесь это займет? Достаточно просто это понять, на самом деле. Вот,
[01:02:02.880 --> 01:02:10.440]  пусть у меня есть некоторое число. Число в серединке подразумевает то самое время. Сколько сделается
[01:02:10.440 --> 01:02:18.400]  копий, если у меня количество времени t? Но это t делить на x, плюс t делить на y. Согласны?
[01:02:18.400 --> 01:02:26.040]  За это время копий может сделано быть. Если это количество копий будет больше моего n-1,
[01:02:26.040 --> 01:02:35.960]  тогда в этом случае что? Значит, я могу быстрее это сделать. Значит, я пойду влево. Если же я не
[01:02:35.960 --> 01:02:44.000]  могу этого сделать, то есть t делить на x, плюс t делить на y, оно будет меньше, чем n, тогда я должен
[01:02:44.000 --> 01:02:51.440]  увеличить время для данных сероксов, иначе они не успеют. Понятно? Ну, вот так это выглядит.
[01:02:51.440 --> 01:03:04.800]  Все достаточно просто. Есть ли у вас какие-то к этому вопросы? А минимум plus left плюс 1. Смотрите,
[01:03:04.800 --> 01:03:09.200]  потому что right minus left больше единички. В момент, когда мы дойдем до нужного момента,
[01:03:09.200 --> 01:03:22.760]  right будет указывать на нужный нам ответ. Можно писать всегда по-разному. Есть ли у вас к этому
[01:03:22.760 --> 01:03:34.360]  всему вопросы? Неужели вам все сегодня было понятно? Чудно. Если вам все было сегодня понятно,
[01:03:34.360 --> 01:03:40.120]  то я скажу вам такой спойлер. Как вы думаете, чем вы будете на семинарах заниматься?
[01:03:40.120 --> 01:03:53.800]  Правильно, все верно. Будете рассчитывать рекурренты, плюс, возможно, будут некоторые задачки отсюда,
[01:03:53.800 --> 01:04:01.320]  мы их поразбираем еще в каком-то виде. На самом деле, задачки, связанные с бинпоиском по ответу,
[01:04:01.480 --> 01:04:08.520]  очень часто будут у вас возникать какие-то рандомные моменты, поэтому вы можете их всегда
[01:04:08.520 --> 01:04:17.040]  найти. И здесь важно всегда понимать, это более такая олимпиадная чуйка, я бы сказал. На этом,
[01:04:17.040 --> 01:04:23.640]  в принципе, сегодня все. Всем большое спасибо, не болейте и хорошего вам вечера!
