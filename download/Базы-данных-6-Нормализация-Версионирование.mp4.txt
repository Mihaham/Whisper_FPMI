[00:00.000 --> 00:12.960]  Очередная лекция. У нас сегодня такая, наверное, окончательная лекция, связанная с какой-то глубокой
[00:12.960 --> 00:22.080]  применимой теорией, корреляционным базам данных, по крайней мере. Сейчас ее закончим, наконец-то
[00:22.080 --> 00:31.200]  таки. Следующий уже у нас будет такая больше по углубленному синтаксису SQL и расширенным
[00:31.200 --> 00:40.560]  возможностям. Ладно, такой анонс, который должен был бы быть в конце. Хорошо, мы с вами остановились
[00:40.560 --> 00:49.000]  на нормализации, посмотрели основные нормальные формы. Вообще, что такое нормализация? Что такое
[00:49.000 --> 00:54.200]  нормальные формы? Посмотрели, какие они бывают. В принципе, перечень увидели и остановились на
[00:54.200 --> 01:00.480]  первых двух. Сегодня мы продолжим с нормализацией и закончим ее, собственно говоря. Посмотрим,
[01:00.480 --> 01:06.040]  что такое версионирование и посмотрим на TCL, Transaction Control Language, а также,
[01:06.040 --> 01:14.640]  что такое ACID и какие есть проблемы, связанные с изолированностью. Давайте начнем с нормализации
[01:14.640 --> 01:21.520]  и, собственно говоря, закончим ее. Как вы помните из прошлой лекции, нормализация у нас определяется,
[01:21.520 --> 01:29.360]  вернее сказать, тесно связана с понятием функциональной зависимости. И функциональная
[01:29.360 --> 01:39.200]  зависимость, в принципе, довольно простая концепция, пришла к нам из математики.
[01:39.200 --> 01:43.760]  Соответственно, здесь интуитивно нам все должно быть понятно, но здесь небольшая трудность,
[01:43.960 --> 01:51.760]  заключающаяся в том, что у нас вместо одного одной переменной, по сути дела множество переменных
[01:51.760 --> 01:58.520]  с одной и с другой стороны по отношению к знаку функциональной зависимости. Самое главное,
[01:58.520 --> 02:03.640]  что нужно понимать, это если у нас кортежи совпадают по некоему атрибуту или некой
[02:03.640 --> 02:13.720]  совокупности атрибутов, входящих в X, то, соответственно, значение их атрибутов, входящих
[02:13.720 --> 02:20.040]  в множество Y, также должны совпадать. Ну или верно обратное, не существует двух различных
[02:20.040 --> 02:24.400]  кортежей, которые в атрибуте X имеют совпадающее значение, в атрибуте Y имеют разные значения.
[02:24.400 --> 02:35.760]  Левая часть на слайде это X-детерминат, правая это Y-зависимая часть. На прошлой лекции мы с вами
[02:35.760 --> 02:42.080]  не разбирали усно, но давайте проговорим тоже, в принципе, в слайдах есть. Давайте проговорим
[02:42.080 --> 02:48.320]  еще так же сейчас, чтобы, может быть, было всем очевидно и понятно, что такое теория Макитта,
[02:48.320 --> 02:53.200]  потому что она, в принципе, позволяет более или менее простым, наверное, образом декомпозировать
[02:53.200 --> 03:03.840]  вторую, по крайней мере, нормальную форму. По теориям Хитта у нас есть возможность декомпозировать
[03:03.840 --> 03:10.840]  множество из, некое отношение, состоящее из трех множеств атрибутов, ABC это причем множество,
[03:10.840 --> 03:14.360]  то есть под A и B и C может быть совокупность, не обязательно это один атрибут, может быть
[03:14.360 --> 03:20.960]  совокупность атрибутов. Мы можем декомпозировать отношение R, если у нас есть функциональная
[03:20.960 --> 03:30.600]  зависимость AB, на проекции AB и AC. И вот у нас будет следующий пример, поставщик город-продукт по
[03:30.600 --> 03:37.320]  отношению к таблице, ну ниже в данном случае, применим, что A это поставщик, B город, C продукт.
[03:37.320 --> 03:44.520]  Тогда, по теории Хитта, у нас AB поставщик город и AC поставщик продукт, можно декомпозировать это
[03:44.520 --> 03:51.840]  отношение. Здесь видно же у нас, что между поставщиком и городом наличит функциональная
[03:51.840 --> 03:58.760]  зависимость, у нас соответственно одинаковые значения атрибута поставщик, это ромашка и
[03:58.760 --> 04:05.160]  подорожник, и у нас соответственно одинаковое значение для атрибута город, соответствующих
[04:05.160 --> 04:10.080]  кортежей Москва и Краснодара. Срого говоря, нам не обязательно было бы для констатации
[04:10.080 --> 04:16.240]  функциональной зависимости находить повторяющиеся значения. По большому счету, для функциональной
[04:16.240 --> 04:19.960]  зависимости нам было бы достаточно, если бы поставщик и город, эти два атрибута, были бы
[04:19.960 --> 04:28.080]  каждая из них уникальна. Там был бы тогда вопрос о возможности формирования составного первичного
[04:28.080 --> 04:34.840]  ключа, ну как бы это оставим за скобками. Смысл в том, что если у нас не было бы противоречащего
[04:34.840 --> 04:38.480]  определению функциональной зависимости условий, то есть, если бы у нас не было такого, что у нас
[04:38.480 --> 04:46.220]  ромашка, это город Москва, и в строке 4 ромашка это город, не знаю, там, Екатеринбург, если бы у нас
[04:46.220 --> 04:52.160]  такого не было, нам было бы этого достаточно. Если бы у нас была бы такая запись в таблице,
[04:52.160 --> 04:56.440]  мы бы наоборот не смогли констатировать наличие функциональной зависимости, потому что это
[04:56.440 --> 05:03.480]  бы противоречило, чему правильно определение. Ну или, соответственно, у нас можно
[05:03.480 --> 05:10.720]  посмотреть на атрибут продукты город и обратить внимание, что для конфет у нас,
[05:10.720 --> 05:16.320]  казалось бы, ситуация похожа на функциональную зависимость. То есть, когда у нас продукты,
[05:16.320 --> 05:24.240]  это детерминат, а город-зависимая часть, имеется в виду, что конфеты у нас влекут Москву. Но если мы
[05:24.240 --> 05:30.200]  посмотрим на шоколад, то при функциональной зависимости, ну предполагаемый продукт от
[05:30.200 --> 05:36.080]  продукта к городу, а город зависит от продукта, у нас не соблюдается определение, потому что у нас
[05:36.080 --> 05:43.440]  для атрибута продукт при значениях шоколад не все значения совпадают, потому что в одном из
[05:43.440 --> 05:50.800]  случаев будет, соответственно, Санкт-Петербург. Ну, очевидно, что здесь имеют место избыточность,
[05:50.800 --> 05:57.840]  как мы от этого избавимся по теореме Хита. Ну, все довольно просто, как описано выше. Для данного
[05:57.840 --> 06:10.080]  случая все, в принципе, элементарно. Да, теорема, в принципе, да, есть доказательства ее, то есть,
[06:10.080 --> 06:15.440]  есть доказательства у дейта, есть, нет, у дейта, ну такое, она описательная. Есть у Кузнецова
[06:15.440 --> 06:21.560]  доказательства, прям формальная, хорошая. А все, что нам нужно запомнить из теоремы Хита, это,
[06:21.560 --> 06:28.920]  в общем-то, вот, вот эта вот строка, что если у нас R, A, B, C, ну вот этот абзац получается, да, если R,
[06:28.920 --> 06:34.640]  A, B, C, и если есть зависимость между A и B, ну, может быть, между A и C могла бы быть зависимость,
[06:34.640 --> 06:40.000]  между B и C. Ну, вы понимаете, да, мы здесь просто для, мы не ограничены в вариантах. Смысл в том,
[06:40.000 --> 06:46.320]  что есть три группы атрибутов, между двумя из группами есть функциональная зависимость. Тогда
[06:46.320 --> 06:54.840]  мы можем отношение декомпозировать на два, декомпозировать без потерь на два вот таким вот образом.
[06:54.840 --> 07:00.560]  A, B, A, C. Ну, в зависимости от того, да, какие у нас здесь бы буквы, какие у нас переменные бы стояли
[07:00.560 --> 07:05.880]  вот в этой части, в этом, в этой функциональной зависимости, у нас бы здесь соответственно менялись.
[07:05.880 --> 07:14.520]  Не знаю, B, C было бы, здесь бы тогда было бы B, A, и B, C, условно говоря. Вот, собственно,
[07:14.520 --> 07:21.480]  все. Это просто вот способ, который нам позволяет декомпозировать наше отношение таким простым,
[07:21.480 --> 07:26.840]  да, что ли, с образом, когда мы просто берем листок бумаги, записываем атрибуты или группы
[07:26.840 --> 07:35.400]  атрибутов, делим их на три, находим функциональную зависимость и разбиваем соответственно на два.
[07:35.400 --> 07:42.240]  Ну, повторюсь, это в первую очередь для второй нормальной формы, пожалуй, что актуально. Для
[07:42.240 --> 07:47.840]  третьей, там не совсем теорема хита, ну, как бы не теорема хита даже, можно сказать, используется.
[07:47.840 --> 07:58.280]  Поэтому, ну, вот здесь просто формальная, да, формальная теорема, позволяющая нам проводить
[07:58.280 --> 08:03.880]  какие-то операции по типу, не знаю, теории множества, математической логики. Здесь
[08:03.880 --> 08:09.520]  содержания нам, содержания какого-то по большому счету нет, просто игра с символами,
[08:09.520 --> 08:13.880]  которая нам позволяет, когда мы эти символы интерпретируем, проецируем на какую-то предметную
[08:13.880 --> 08:25.680]  область, прощать наши логические построения. Ну, собственно, вот на примере, да, здесь, обратите
[08:25.680 --> 08:34.080]  внимание, мы просто взяли посылку теоремы, ее следствие, ну, посылка там, да, еще R, A, B, C,
[08:34.080 --> 08:40.720]  и если A, то B, ну, вернее, если B функционально зависит от A, то тогда вот у нас R разбивается
[08:40.720 --> 08:48.120]  на какую проекцию. И все просто вот формально расписали нам, расписали наш таблицу на поставщик
[08:48.120 --> 08:53.200]  города, поставщик продукта. Еще раз, между поставщиком и городом у нас функциональная
[08:53.200 --> 08:58.600]  зависимость, вот она явно представлена, потому что Ромашка-Москва, Ромашка-Москва, Подорожник-Краснодар,
[08:58.600 --> 09:04.280]  Подорожник-Краснодар, то есть у нас нет нарушения здесь на совпадающих атрибутах у детермината и у
[09:04.280 --> 09:14.040]  зависимой части. И мы могли бы взять другую функциональную зависимость, мы не здесь, ну,
[09:14.040 --> 09:19.520]  мы здесь ограничены только содержательной областью, семантикой наших данных и наложенными
[09:19.520 --> 09:24.480]  ограничениями, какие они у нас есть в базе данных. То есть, может быть, здесь это демонстрационная
[09:24.480 --> 09:29.120]  таблица на три атрибута, понятно, у нас может быть таблица на 20 атрибутов, тогда там будет
[09:29.120 --> 09:36.560]  сложнее. Нужно будет смотреть, что нам выгоднее, что образует более разумную семантику при
[09:36.560 --> 09:46.560]  разбиении. В примере, вот, да, мы декомпозируем над поставщик-город, поставщик-продукт,
[09:46.560 --> 09:54.440]  по теории Михита, и, в принципе, нам этого достаточно, то есть, в общем-то, довольно формально идем.
[09:54.440 --> 10:04.440]  Ну, я не буду, наверное, останавливаться дальше на теории Михита. Единственно, ну, просто я даже
[10:04.440 --> 10:08.280]  не знаю, что здесь содержательно еще можно было бы сказать, кроме того, что попробуйте взять,
[10:08.280 --> 10:16.600]  попробуйте сгенерировать какую-нибудь базу, какое-нибудь отношение, да, и пора декомпозировать
[10:16.600 --> 10:23.720]  его по хиту. Буквально там пару, парочку, троечку раз, если вы этого не делали еще на семинарах,
[10:23.720 --> 10:28.760]  или, может быть, не допоняли чего-то, по теории Михита все будет довольно прозрачно и понятно.
[10:28.760 --> 10:35.320]  А еще, наверное, есть, о чем хотелось бы сказать, мы на прошлой лекции немножко
[10:35.320 --> 10:41.200]  порассуждали, задали вопрос на тему того, что у нас вторая нормальная форма говорит о том,
[10:41.200 --> 10:49.960]  что у нас должен быть атрибут не ключевой, не минимально функционально зависим от первичного
[10:49.960 --> 10:56.600]  ключа. Не является ли в данном случае, не было ли там пересечений между свойством несокрасимости
[10:56.600 --> 11:04.720]  первичного ключа и вот этим вот требованием ко второй нормальной форме. Пересечений, я не было,
[11:04.720 --> 11:09.480]  по одной простой причине. У нас несократимость первичного ключа говорит о том, что мы не можем
[11:09.480 --> 11:13.960]  первичный ключ умножить там, ну не знаю, с трех, например, если он у нас составной, мы не можем,
[11:13.960 --> 11:18.080]  ну мы выбрали его таким, у нас единственная возможность только его сформировать. Мы не
[11:18.080 --> 11:23.440]  можем с трех атрибутов уменьшить до двух атрибутов. А вторая нормальная форма у нас говорит о том,
[11:23.440 --> 11:33.560]  что если у нас есть некое отношение, в котором не ключевой атрибут будет зависеть не от всех трех
[11:33.640 --> 11:40.040]  атрибутов первичного ключа, только от двух или от одного, то мы можем это отношение разбить на два.
[11:40.040 --> 11:48.680]  И в исходном отношении у нас все равно первичный ключ будет несократимым из трех атрибутов. В
[11:48.680 --> 11:54.920]  декомпозиции у нас может быть два отношения с другими первичными ключами, где количество первичных
[11:54.920 --> 11:58.680]  ключей для каждого этого декомпозированного отношения, по сути, для проекции изначального
[11:58.680 --> 12:06.080]  отношения. Может быть первичный ключ у нас в декомпозиции из двух атрибутов или из одного
[12:06.080 --> 12:10.080]  атрибута или вообще из одного атрибута для каждого декомпозированного отношения. То есть вот
[12:10.080 --> 12:17.200]  примерно такой ответ на тот вопрос, если его автор присутствует на лекции, то соответственно
[12:17.200 --> 12:24.120]  ответ такой, если он помнит еще свой вопрос. Ну хорошо, функциональность, так, функциональная
[12:24.120 --> 12:29.240]  зависимость аремы хита, ну вот то, что мы получили из тех формул, которые были на слайде, из тех
[12:29.240 --> 12:42.200]  выкладок даже скорее. Вот пример. У нас все здесь получается по теории аремы хита, по-моему,
[12:42.200 --> 12:51.000]  даже нормализовано до второй формы, если я не ошибаюсь. Так, ну хорошо, давайте посмотрим дальше,
[12:51.240 --> 12:57.500]  что у нас есть. Еще две формы нормальных. Это третья нормальная форма и нормальная форма
[12:57.500 --> 13:05.640]  бойса кода. Сразу оговорюсь, вот о чем. Мы с вами идем от простого к сложному, но на самом деле
[13:05.640 --> 13:15.000]  здесь от элементарных до форм более сложных, но здесь есть некоторые нюансы. Нюанс номер один.
[13:15.000 --> 13:22.440]  На самом деле мы стремимся к третьей, как минимум, нормальной форме, и предыдущие нормальные формы
[13:22.440 --> 13:32.760]  это вспомогательные этапы, которые нам, ну, возможно, нужны будут, ну, очевидно,
[13:32.760 --> 13:39.280]  нужны будут на пути для понимания, для формализации наших рассуждений, но вряд ли мы начнем с них,
[13:39.280 --> 13:46.640]  когда нам придется декомпозировать таблицу из 20-30 атрибутов, ну, например, если не больше,
[13:46.640 --> 13:53.920]  когда нам придется декомпозировать ее на какие-то составляющие отношения. Мы начнем не с того,
[13:53.920 --> 13:59.080]  что попытаемся атомизировать данные, хотя, наверное, при определенных условиях это тоже
[13:59.080 --> 14:03.800]  будет необходимо, ну, в зависимости от того, сможем ли мы вообще вычленить эти ненормализованные
[14:03.800 --> 14:11.240]  данные или нет, но при нормализации мы, скорее всего, будем идти от понимания того, где у нас есть
[14:11.240 --> 14:20.080]  функциональная зависимость, а где нет, и, ну, это так получается, да, немножко, немножко
[14:20.080 --> 14:24.960]  контуитивно тому, о чем мы с вами говорим на последних двух лекциях. Мы идем от первой нормальной
[14:24.960 --> 14:31.400]  вверх, на самом деле мы, скорее всего, будем спускаться вниз, проходя шаги, ну, если уж не с
[14:31.400 --> 14:39.000]  третьей до первой, то, по крайней мере, не линейно будем идти. Также, что хотелось бы сказать еще,
[14:39.000 --> 14:46.960]  подчеркнуть дополнительно, на самом деле у нас есть, вот какой момент, все эти нормальные формы,
[14:46.960 --> 14:51.720]  по большому счету, способ, ну, по крайней мере, вот те, которые мы сейчас рассматриваем, не даваясь
[14:51.720 --> 14:59.720]  более какие-то сложные вещи после бойса кода, они, по большому счету, призваны формализовать некое
[14:59.720 --> 15:08.800]  такое, да, некий такой common sense, что ли, некий здравый смысл того, как данные должны выглядеть.
[15:08.800 --> 15:17.240]  Поэтому, с одной стороны, у нас вот на форуме бойса кода будет пример, где декомпозиция привела к
[15:17.240 --> 15:24.640]  некоторые дополнительные сложности в оперировании данными, а с другой стороны, это я к тому говорю,
[15:24.640 --> 15:30.760]  что у нас нет прямой связи между тем, что мы нормализуем, и у нас будет идеальная база данных.
[15:30.760 --> 15:35.020]  Нет, это как на практике неверно, потому что может повлечь дополнительные расходы просто на
[15:35.020 --> 15:40.720]  транзакции, так и в теории неверно, потому что, ну, может повлечь тот или иной вариант декомпозиции,
[15:40.720 --> 15:48.400]  те или иные потенциальные проблемы с аномалией, с обновлениями, как ни странно. То есть, здесь у
[15:48.400 --> 15:56.440]  нас, еще раз, нормальные формы, все эти, они, получается, не всегда сильно связаны друг с другом,
[15:56.440 --> 16:01.800]  что если мы там декомпозировали до третьей, нормализовали, вернее, до третьей нормальной
[16:01.800 --> 16:07.160]  формы, то у нас прям вот, да, нормальная форма бойса кода, мы прям, молодцы, мы можем гарантировать,
[16:07.160 --> 16:13.280]  что наша база данных замечательная, не противоречивая и все такое прочее.
[16:13.280 --> 16:17.640]  Проблема возникает в том, что нормальные формы не отвечают за нашу симантику данных,
[16:17.640 --> 16:23.920]  не отвечают за наше моделирование, за те сущности, которые мы выделяем, и поэтому к ним надо
[16:23.920 --> 16:29.720]  относиться, ну, и ими надо пользоваться, надо уметь ими пользоваться точно, но, тем не менее,
[16:29.720 --> 16:37.320]  относиться к ним с пониманием о том, что неверная формализация предметной области не сможет быть
[16:37.320 --> 16:45.600]  исправлена нормализацией на этапе проектирования вот такого логического или даже, может быть,
[16:45.600 --> 16:52.680]  физического, поэтому вот, пользуйтесь, но пользуйтесь с умом, что называется. Ладно,
[16:52.680 --> 16:59.480]  long story short, простите за мой английский. Что такое третья форма? Отношение находится в
[16:59.480 --> 17:03.360]  третьей нормальной форме тогда и только тогда, когда оно находится во второй нормальной форме,
[17:03.360 --> 17:07.920]  и ни один не ключевой атрибут не является транзитивно зависимым от его первичного ключа.
[17:07.920 --> 17:15.240]  Ну, и в скобках уточнения, что мы в данном случае полагаем, чтобы не было пересечений
[17:15.240 --> 17:25.080]  с бойсом кодом, полагаем, что в наличии в нашем отношении только одного первичного ключа.
[17:25.080 --> 17:29.400]  Ну, потенциального, да, здесь сказано, не прошу прощения, это не совсем верно,
[17:29.400 --> 17:33.240]  первичного мы имеем в виду, потому что потенциальных может быть сильно больше,
[17:33.240 --> 17:37.880]  ну, вернее, да, здесь я говорю, но потенциального к тому же является первичным ключом, да.
[17:37.880 --> 17:43.960]  Неформальное определение отношения находится в третьей нормальной форме тогда и только тогда,
[17:43.960 --> 17:48.920]  когда каждый картридж состоит из значений первичного ключа и множества взаимно независимых атрибутов.
[17:48.920 --> 18:00.080]  Ну, наверное, неформально, наверное, попроще будет, то есть у нас каждый атрибут должен зависеть,
[18:00.080 --> 18:08.880]  получается, только от первичного ключа, и первичный ключ у нас должен быть еще и таким вот атомарным,
[18:08.880 --> 18:13.040]  скажем, да, подразумевается, что имеет только один атрибут в своем составе.
[18:13.040 --> 18:17.360]  Но, тем не менее, давайте мы раскроем понятие транзитивной зависимости,
[18:17.360 --> 18:22.560]  коль скоро мы все же его употребили в более формальном определении, но здесь все довольно просто,
[18:22.560 --> 18:31.120]  как и в той области, откуда к нам пришло понятие функциональной зависимости,
[18:31.120 --> 18:36.800]  определение тривиально, то есть если у нас есть последовательная зависимость атрибутов,
[18:36.800 --> 18:45.800]  x, y, y, z, то мы можем говорить, что у нас x связан с y некой транзитивной зависимостью,
[18:45.800 --> 18:54.600]  ну, не некой, а просто транзитивной функциональной зависимостью. Ну, можно уточнять,
[18:54.600 --> 19:00.960]  да, что x не должен функционально зависеть ни от атрибута y, ни от атрибута z, чтобы у нас
[19:00.960 --> 19:07.920]  не закольцовывалось все, но это уже, как бы, частности, с которыми мы, наверное, сейчас,
[19:07.920 --> 19:17.880]  пожалуй, не будем взаимодействовать. Давайте посмотрим лучше, например, вот у нас есть третья
[19:17.880 --> 19:24.400]  нормальная форма. Да, вопрос в чате. Может ли быть такое, что несколько атрибутов связано
[19:24.400 --> 19:29.280]  с зависимостью с несколькими другими, как в этом определении, и в этой форме это учитывается?
[19:29.280 --> 19:36.360]  Не совсем, честно говоря, я понял вопрос, но похоже, что может быть, если я его понял правильно,
[19:36.360 --> 19:41.640]  то, в принципе, может быть несколько атрибутов, связанных с несколькими другими, и в этом
[19:41.640 --> 19:50.520]  определении, ну, наверное, да, вы имеете в виду, что больше трех транзитивных, больше как бы
[19:50.520 --> 19:59.200]  двух зависимости образует транзитивную, если вы имеете, ну, то есть, да, больше просто физически
[19:59.200 --> 20:06.360]  количество стрелочек должно быть вот здесь. Там будет x, y, y, z, z там, не знаю, дальше пойдем,
[20:06.360 --> 20:18.200]  да, зациклим z, a, z, a, a, b и так далее, и тогда у нас там y будет связан транзитивно с b. Такое
[20:18.200 --> 20:25.840]  теоретически может быть, да, но здесь, пожалуй, вот о чем стоит сказать, что если у вас такая
[20:25.840 --> 20:33.760]  зависимость, то, очевидно, вам не нужно будет разбивать ее, исходя из y и b транзитивно зависит
[20:33.760 --> 20:39.640]  от y. Вам нужно будет декомпозировать ее поэтапно и смотреть, что получается. Опять же, не забывая
[20:39.640 --> 20:48.360]  о семантике данных, чтобы получались какие-то рациональные отношения декомпозиционные,
[20:48.360 --> 20:54.840]  а не, там, непонятно что, чтобы там сохранялись еще какие-то вот, ну, сейчас мы посмотрим,
[20:54.840 --> 21:02.240]  что должно сохраняться. Хорошо, так, пример, поставщик, город, деталь, поставщик, у нас
[21:02.240 --> 21:10.400]  еще и, допустим, первичный ключ. Ромашка, Ландыш, Василек, Роза, Архидея. Так, первичный ключ,
[21:10.400 --> 21:17.680]  первичный ли это ключ у нас? Вот, казалось бы, Ромашка, Москва, Архидея, Москва. Нет ли здесь
[21:17.680 --> 21:26.720]  противоречия? Противоречия нет, потому что у нас на разные, на разные значения детерминатов может
[21:26.720 --> 21:34.760]  быть, тем не менее, одинаковое значение зависимости. На это функциональная зависимость ограничений
[21:34.760 --> 21:43.080]  не налагает. А вот зато у нас, если бы была Ромашка в первой строке и Ромашка в пятой строке,
[21:43.080 --> 21:48.200]  ну, у нас здесь Москва, окей, это нормально. Вот если бы была Ромашка в первой строке и Ромашка
[21:48.200 --> 21:56.400]  в четвертой строке, вот тогда бы у нас не было функциональной зависимости и, ну, мы должны были бы
[21:56.400 --> 22:01.640]  заключить, что мы сделали что-то не так. Не надо было либо первичный ключ делать естественным,
[22:01.640 --> 22:07.880]  либо не надо было, либо надо было как-то базу данных иначе проектировать, чтобы у нас не попадалось в,
[22:07.880 --> 22:20.760]  ну, не попадалось разных значений противоречивых в один картеж. Ну хорошо, это такое отступление
[22:20.760 --> 22:26.360]  просто. Еще раз про функциональную зависимость, такая ремарка на полях, потому что понятие важное
[22:26.360 --> 22:34.120]  для нормализации проектирования имеет существенное значение. Хорошо, поставщик, первичный ключ,
[22:34.120 --> 22:39.160]  город, деталь. Какие функциональные зависимости? Поставщик и город есть, да, есть на каждую
[22:39.160 --> 22:48.000]  независимую, на каждое уникальное значение детерминанта у нас также, да, некоторые,
[22:48.000 --> 22:52.160]  любое в принципе нам значение зависимости в данном случае неважно. Главное у нас детерминанты
[22:52.160 --> 22:56.880]  уникальные, зависимые части в этом отношении могут быть произвольные, хоть везде здесь могла бы
[22:56.880 --> 23:05.960]  стоять Москва. А город, деталь, подходит ли или нет? Так, в детерминанте два повторяющихся
[23:05.960 --> 23:10.600]  атрибута, Москва и Москва, для них должны быть одинаковые значения атрибутов в зависимости
[23:10.600 --> 23:15.680]  части. Правильно, правильно, саморезы, саморезы. Опять же, но обратно это не работает. Вот город,
[23:15.680 --> 23:22.480]  деталь, нет функциональной зависимости, почему? Потому что саморезы у нас есть, а им соответствует
[23:22.480 --> 23:28.040]  в одном из трех случаев значение атрибута город значение краснодар. Ну и соответственно город
[23:28.040 --> 23:33.600]  поставщики, поставщик тоже мы уже это проговорили, потому что Москва-Ромашка окей, а Москва-Архидея
[23:33.600 --> 23:40.040]  уже не окей, функциональная зависимость по определению нарушается. А попробуем избавиться
[23:40.040 --> 23:46.600]  от функциональной зависимости как и для второй нормальной формы с помощью теоремы хита. Вот
[23:46.600 --> 23:58.840]  x, y, z, x, z, тогда r, это у нас что? Если x, z, то это x, y, проекция на x, z, прошу прощения,
[23:58.840 --> 24:08.200]  на x, y. Получается поставщик-деталь, поставщик-город. Так делать не стоит, по крайней мере в общем
[24:08.200 --> 24:17.760]  случае, потому что у нас так, да, мы теряем в данном случае при такой декомпозиции, мы теряем
[24:17.760 --> 24:23.760]  одну из наших начальных функциональных зависимостей, мы теряем город-деталь,
[24:23.760 --> 24:35.920]  вторую в череде наших транзитивных зависимостей, и мы по сути дела ее уже из нашей схемы не
[24:36.000 --> 24:42.320]  восстановим. Мы ее можем восстанавливать только в некотором смысле искусственным путем,
[24:42.320 --> 24:53.280]  только налагает дополнительные ограничения, какие-то проверки на наши отношения. Поэтому
[24:53.280 --> 24:59.760]  в реальных БДД это может быть проблемой при добавлении данных, и так делать нельзя,
[24:59.760 --> 25:05.040]  нам нужно как-то эту зависимость сохранить, по крайней мере, повторюсь, нельзя в общем случае,
[25:06.000 --> 25:12.640]  исходя из теории, так делать нельзя, потому что деталь-город у нас независимый, и на этих
[25:12.640 --> 25:18.640]  двух, на этом упрощенном примере этого не видно, да, нужно было бы что-то такое более или менее
[25:18.640 --> 25:25.960]  реальное представлять себе, где бы у нас реально возникали проблемы с обновлениями,
[25:25.960 --> 25:36.400]  здесь у нас с аномалиями. Мы хотим избавиться, мы хотим избавиться, это абсолютно точно,
[25:36.400 --> 25:40.880]  мы хотим избавиться от транзитивной зависимости поставщик деталь, просто по хиту у нас получается,
[25:40.880 --> 25:47.000]  что когда мы избавились по хиту, мы потеряли зависимость-город-деталь, и если в данном
[25:47.000 --> 25:54.800]  случае у нас декомпозировано исходное отношение на два отношения, и они всего из двух атрибутов
[25:55.040 --> 26:01.240]  состоят, каждый из, один из двух атрибутов при этом еще и первичным ключом является, то здесь,
[26:01.240 --> 26:09.840]  конечно, у нас будут минимальные проблемы с нашим добавлением, мы можем всегда, не знаю,
[26:09.840 --> 26:15.880]  ну единственно, да, там будут, возможно, если мы ромашку захотим поменять, ну мы затрем значение
[26:15.880 --> 26:24.240]  города, да, для деталей мы если затрем саморезы, ну тоже, да, здесь не видно, но поверьте мне на слово,
[26:24.240 --> 26:31.560]  если не верите мне, рекомендую вам прочитать Кристофера Дейта, у него прям две-три получается
[26:31.560 --> 26:40.480]  главы про зависимость, ограничения и проектирование там до, ну до бойса кода там,
[26:40.480 --> 26:49.400]  часть главы, еще часть главы, да, следующих более серьезных форм, в общем, поскольку мы потеряли
[26:49.400 --> 26:54.920]  город деталь, повторюсь, мы здесь, конечно, вот, на таком простом примере, может быть, этого не
[26:54.920 --> 27:00.320]  видим, но здесь возможны проблемы с обновлениями, то есть, если бы у нас были бы еще деталь там,
[27:00.320 --> 27:08.400]  часть детали, не знаю, цвет, вкус, запах и цвет, город, там улица, дом, не знаю, количество человек,
[27:08.400 --> 27:16.600]  может быть, или номер склада, у нас могли бы возникнуть проблемы при попытке добавления данных,
[27:16.600 --> 27:25.440]  при, да, мы, так, мы хотим избавиться от зависимости среди неключевых признаков, но поставщик ключевой,
[27:25.440 --> 27:34.480]  зачем от такой зависимости избавляться, а поставщик ключевой, ключевой вот в этом отношении. Смотрите,
[27:34.600 --> 27:41.320]  еще один интересный момент, функциональная зависимость вообще никак не связана с ключами,
[27:41.320 --> 27:52.200]  и это просто определение третьей нормальной формы нам говорит, что нам говорит о том, что если у
[27:52.200 --> 28:00.480]  нас есть, так, промотал уже, да, что если у нас есть отношения, там, первичные, потенциальные ключи,
[28:00.480 --> 28:07.000]  то тогда нам нужно понимать, что, то тогда мы уже здесь на третьей нормальной форме говорим,
[28:07.000 --> 28:14.880]  что вот есть ключевые и неключевые атрибуты, и у нас от, неключевые атрибуты не должны быть,
[28:14.880 --> 28:32.600]  неключевые атрибуты не должны быть взаимно зависимы. И, да, автор вопроса все понял,
[28:32.600 --> 28:39.720]  ну, автор вопроса молодец. Еще раз, смотрите, у нас, да, есть в определениях и второй на самом
[28:39.720 --> 28:44.960]  деле нормальные формы, да, там, когда перекрытие потенциальных ключей, первичных ключей идет,
[28:44.960 --> 28:52.480]  там тоже про ключи, в принципе, говорится, но еще раз, в вакууме таком, что ли, функциональная
[28:52.480 --> 28:56.920]  зависимость не про ключи, вообще не про ключи, функциональная зависимость, это просто про
[28:56.920 --> 29:07.680]  совпадение значений атрибутов слева и справа, все. Поэтому тот факт, что у нас, мы хотим там
[29:07.680 --> 29:14.960]  какие-то, где-то у нас ключевая, ключевой атрибут стоит в детерминате, где-то он появляется в
[29:14.960 --> 29:21.600]  зависимой части, но теоретически, да. Окей, это нам не мешает рассуждать на тему того, что вот так вот
[29:21.600 --> 29:27.520]  делать нельзя, а вот так уже можно, вот так кстати можно, вот так нельзя, потому что, и опять же,
[29:27.520 --> 29:35.640]  мы здесь на самом деле, если приспотреться, мы здесь даже вот так вот просто на сколько можем
[29:35.640 --> 29:43.280]  говорить, что мы сохранили избыточность данных. В каком плане у нас, если мы нормализуем это правильно,
[29:43.280 --> 29:49.320]  ну как бы более рационально, сохраняя вот этот город деталь зависимости, то у нас здесь будет
[29:49.320 --> 29:55.600]  меньше срок, так на минуточку. Мы избыточность убрали, которая у нас возникала, если бы у нас
[29:55.600 --> 30:04.880]  поставщик и деталь ставились бы в зависимость. Поэтому еще раз, у нас в данном случае хит не
[30:04.920 --> 30:11.240]  очень хорошо работает в общем случае, потому что город деталь не позволяет сохранить. Мы этот
[30:11.240 --> 30:18.800]  город деталь зависимости нам пришлось бы сохранять иными способами, не внутри отношения,
[30:18.800 --> 30:25.880]  не декомпозировав отношения на два и наведя между ними там функциональные зависимости какие-то
[30:25.880 --> 30:31.880]  за счет ключей, а нам бы пришлось дополнительно как-то говорить, что какие-то ограничения вешать
[30:32.080 --> 30:38.440]  на проверку, на добавление данных, триггеры бы какие-то ставить. Вот об этом идет речь,
[30:38.440 --> 30:47.000]  что когда мы вот эту зависимость удаляем, мы ее формируем уже, вот здесь вот формируем не за счет
[30:47.000 --> 30:51.720]  отдельного отношения, а нам придется вот эти отношения как-то связывать какими-то функциями,
[30:51.720 --> 31:00.520]  какими-то триггерами, какими-то ограничениями, налагаемыми на реализуемые на этапе добавления
[31:00.520 --> 31:08.280]  данных, на этапе операции insert или update или delete. И это не совсем правильно, поэтому мы здесь идем,
[31:08.280 --> 31:14.880]  нам желательно провести декомпозицию так, чтобы сохранить промежуточные функциональные
[31:14.880 --> 31:20.080]  зависимости в разных отношениях ях, и поэтому предлагается декомпозировать здесь в обратном
[31:20.080 --> 31:26.120]  порядке, начиная справа налево, то есть имеется в виду, что поставщик это левый, деталь это право,
[31:26.120 --> 31:36.560]  мы идем справа налево город деталь и город поставщик. Таким образом, если мы можем так сделать,
[31:36.560 --> 31:43.800]  а мы можем так сделать в данном случае, то мы сохраняем зависимости и получаем два отношения,
[31:43.800 --> 31:48.640]  которые еще и не страдают от избыточности, ну мы здесь как бы визуально видим, что мы
[31:48.640 --> 31:57.480]  сократили даже число наших записей с 10 до 9 в нашей базе данных. Ну это скорее хорошо,
[31:57.480 --> 32:08.320]  не обязательно, мы к этому не стремимся, но это, пожалуй, хорошо. Прошу прощения. Так,
[32:08.320 --> 32:19.560]  если что-то непонятно, если что-то непонятно из этого, то я рекомендую таки к Дейту обратиться,
[32:19.560 --> 32:26.520]  а если не к Дейту, то к Кузнецову, если не к Дейту, не к Кузнецову, если вы хотите получить вопрос о
[32:26.520 --> 32:31.280]  лекции, можете задать его и мы попробуем еще раз проговорить об этом в следующий раз, потому что
[32:31.280 --> 32:38.120]  тема интересная, ну такая она насущная, прям здесь есть интересная теория подлежащая,
[32:38.120 --> 32:48.440]  которую можно, конечно, покрутить по интересным образом. Ну давайте пойдем дальше, нормальная форма
[32:48.440 --> 32:55.120]  бойса кода, нормальная форма бойса кода используется, это более сильный вариант третьей нормальной формы,
[32:55.120 --> 32:59.920]  и по большому счету в некотором смысле обобщение его на случай, когда у нас потенциальные ключи
[32:59.920 --> 33:11.760]  являются составными, и они еще и перекрываются. На практике совокупность таких условий встречается
[33:11.760 --> 33:17.440]  нечасто, поэтому часто ограничивается, ну, второй или третий нормальными формами в зависимости от
[33:17.440 --> 33:25.520]  условий. Определение на слайде, то есть, опять же, формальная и менее формальная, давайте менее
[33:25.520 --> 33:30.760]  формальная, наверное, хотя, ну, давайте формально тоже проговорим, потому что здесь терминология
[33:30.760 --> 33:36.240]  немножко отличается от предыдущей лекции. Отношения находятся в нормальной форме бойса кода тогда,
[33:36.240 --> 33:40.760]  и только тогда, когда каждая его нетривиальная и неприводимая слева функциональной зависимости
[33:40.760 --> 33:46.400]  видит в качестве своего деттерминанта некоторый потенциальный ключ. Тривиальная
[33:46.400 --> 33:51.840]  функциональная зависимость речь идет о том, что если у нас есть множество атрибутов, входящие в
[33:51.840 --> 34:04.440]  первичный ключ, и если у нас какой-то атрибут отдельный или под множество, множество атрибутов
[34:04.440 --> 34:09.800]  первичного ключа образует между собой функциональную зависимость, то есть между всем множеством,
[34:09.800 --> 34:17.640]  например, и одним из атрибутов, или между всем можем множеством, мы его под множеством,
[34:17.640 --> 34:24.160]  то такая зависимость называется тривиальная. Понятно, множество внутри себя замыкается,
[34:24.160 --> 34:33.800]  то есть каждое под множество является включенным в некое свое над множеством. Как-то так,
[34:33.800 --> 34:39.120]  наверное, если вспоминать более или менее терминологию теории множеств. А неприводимость
[34:39.120 --> 34:43.800]  слева тоже самое, что минимальная функциональная зависимость. То есть слева, где терминанти,
[34:43.800 --> 34:48.960]  у нас должны стоять атрибуты, какое-то количество атрибутов, которые мы не можем сократить,
[34:48.960 --> 34:53.160]  мы не можем выдернуть из этой совокупности, из этого множества атрибутов, какой-то один,
[34:53.160 --> 35:03.000]  не потеряв зависимости. Неформальное определение, оно следующее, переменные отношения находятся
[35:03.000 --> 35:08.680]  в BCNF, BCNF тогда уж, а тогда и только тогда, когда детерминанты всех ее функциональных
[35:08.680 --> 35:15.040]  зависимости являются потенциальными ключами. Причем, обратите в дебаде, еще у нас, что интересно,
[35:15.040 --> 35:26.720]  что любопытно, BCNF определяется без привязки к нормальным формам нижестоящим. Здесь в этом,
[35:26.720 --> 35:32.800]  наверное, проявляется определенная проблема, которую мы сейчас проиллюстрируем примером
[35:32.800 --> 35:41.880]  на слайде. Давайте возьмем, например, отношение студент-предмет-преподаватель. Пусть у него
[35:41.880 --> 35:48.080]  будут следующие ограничения предметной области, это не ограничение базы данных, это просто,
[35:48.080 --> 35:54.280]  как бы, по сути, как эти существа, а в реальности, как эти сущности взаимодействуют. Они
[35:54.280 --> 35:59.320]  взаимодействуют так, что каждый студент изучает определенный предмет только у одного преподавателя,
[35:59.320 --> 36:06.640]  и каждый преподаватель ведет только один предмет, но каждый предмет ведут несколько преподавателей.
[36:06.640 --> 36:15.600]  Слитно должно быть, прошу прощения за опечатки. А что из указанного условия следует? Вот так вот
[36:15.600 --> 36:22.400]  абстрактно, даже не погружаясь в какие-то конкретные данные, мы понимаем, что студенты-предмет
[36:22.400 --> 36:36.680]  забыкаются на конкретного преподавателя. Понятно, наверное, что студент Иванов,
[36:36.680 --> 36:45.160]  наверное, теоретически может изучать студент Иванов предмет, не знаю, математическую логику
[36:45.160 --> 36:49.880]  преподавателя Сидрова и преподавателя Смирнова, они, например, в течение семестра друг друга
[36:49.880 --> 36:56.520]  заменили, но ладно, не будем такие крайние случаи рассмотреть. Для примера просто возьмем, что у нас
[36:56.520 --> 37:01.760]  один преподаватель всегда ведет один предмет, поэтому студент с предметом можно считать это
[37:01.760 --> 37:09.120]  детерминатом для преподавателя. Мы полагаем, что один и тот же предмет, изучаемый одним и тем же
[37:09.120 --> 37:15.740]  студентом, обязательно влекут одного преподавателя в рамках конкретного семестра. А наоборот,
[37:15.740 --> 37:26.300]  преподаватель ведет только один предмет. Кстати, если вы вспомните, у нас чуть раньше было на
[37:26.300 --> 37:32.660]  начальных слайдах оговорка, что функциональная зависимость – это зависимость многие к одному,
[37:32.660 --> 37:38.380]  причем многие это относятся к детерминату, а к одному это относятся к зависимости части. То есть
[37:38.380 --> 37:44.740]  студент-предмет, многие студенты и предметы, многие, вернее, совокупность студентов-предметов,
[37:44.740 --> 37:52.460]  они стыкуются с одним преподавателем, например, преподавателем Матлогита. И из второго условия
[37:52.460 --> 38:01.460]  в сущности вытекает, что множество преподавателей у нас стыкуются с одним предметом, потому что
[38:01.460 --> 38:13.660]  преподаватель ведет только один предмет, но у каждого несколько преподавателей. Соответственно,
[38:13.660 --> 38:19.300]  многие на стороне преподавателей, а предмет остается в единственном числе. И, в принципе,
[38:19.300 --> 38:24.500]  тоже опять же оговорка, пометка на полях, что функциональная зависимость – это связь
[38:24.500 --> 38:36.340]  многие к одному, и при этом у нас детерминат, казалось бы, интуитивно на уровне какого-то
[38:36.340 --> 38:43.300]  словопотребления, такого общего. То есть детерминат, то, что определяет, по идее,
[38:43.300 --> 38:49.460]  наверное, он должен был быть один, ну и зависимая часть тогда одна, но на самом деле нет. На самом
[38:49.620 --> 38:57.340]  деле нет. Детерминатов как раз такие может быть много. И вот с точки зрения наложения зависимости
[38:57.340 --> 39:02.780]  на физическую модель путем формирования первичных и внешних ключей, вот те атрибуты,
[39:02.780 --> 39:11.460]  на которых наложено ограничение внешнего ключа, они на самом деле будут детерминатами, а те
[39:11.460 --> 39:15.660]  атрибуты, до которых наложено ограничение первичного ключа, будут зависимой частью,
[39:16.340 --> 39:22.700]  хотя на самом деле, когда мы добавляем данные, когда мы пишем код, скорее всего, логично,
[39:22.700 --> 39:29.500]  ну более интуитивно для нас будет подход, когда мы сначала говорим, ага, вот это будет
[39:29.500 --> 39:36.700]  первичным ключом, этот атрибут, а на него будут ссылаться какие-то внешние ключи. Но тем не менее,
[39:36.700 --> 39:44.660]  вот по определению возникает наоборот, получается наоборот. Так, BCNF, пример Иванов в математика
[39:45.620 --> 39:50.900]  так, математика здесь должно быть да, предмет ДCan Cмирнов, профессор Кузнецов,
[39:50.900 --> 39:54.200]  Д Can Cмирнов, профессор Кузнецов, имеющиеся потенциальные ключи Иванов, математика,
[39:54.200 --> 40:01.580]  и студент-преподаватель. Потенциально ли это ключ? Иванов, математика, уникальное значение,
[40:01.580 --> 40:06.180]  Иванов физика, уникальное значение, ну для Иванова физика имеется ввиду, для Ивановой,
[40:06.180 --> 40:12.620]  для предмета физика у нас не повторяется больше Ивановы физика нигде, поэтому соответственно,
[40:12.620 --> 40:22.560]  здесь вот этот кортеж он уникален, так то есть в принципе что еще да студент
[40:22.560 --> 40:29.440]  преподаватель тоже получается что Иванов доцент Иванов профессор Кузнецов тоже
[40:29.440 --> 40:33.880]  является уникальными значениями в рамках таблицы
[40:33.880 --> 40:37.920]  совокупно да вот сложный составной ключ студент преподаватель студент
[40:37.920 --> 40:41.320]  предмет у нас нигде значения их не повторяются
[40:41.320 --> 40:47.460]  да здесь даже не нужно сравнивать с третьей колонкой нигде прошу прощения
[40:47.460 --> 40:51.020]  здесь вот я вначале немножко оговорился по сути дела студент предмет уникальный
[40:51.020 --> 40:58.660]  уникальный уникальный уникальный студент преподаватель тоже самое так и что
[40:58.660 --> 41:04.980]  у нас тогда в чем возникает проблема ой прошу прощения
[41:05.720 --> 41:15.640]  нам нужно чтобы все все наши детерминаты являлись потенциальными ключами и при
[41:15.640 --> 41:29.680]  этом так когда являются потенциальными ключами да у нас здесь есть зависимость
[41:30.280 --> 41:35.620]  функциональная между да студент предмет преподаватель преподаватели
[41:35.620 --> 41:39.960]  предмет стоит смотрите студент предмет
[41:40.380 --> 41:47.120]  оępляет преподавателя и вместе с тем у нас есть потенциальный ключ студент
[41:47.120 --> 41:54.380]  преподаватель в котором мы можем взять преподавателя и указать функциональную
[41:54.380 --> 42:01.300]  функциональную зависимость для атрибута предмет, но доцент спритов, доцент спритов, математика,
[42:01.300 --> 42:06.620]  математика, кузнецов, кузнецов, физика, физика, то есть вот у нас первичный ключ,
[42:06.620 --> 42:15.500]  студент, преподаватель, у нас привычный ключ, они пересекаются по атрибуту студент, и у нас есть
[42:15.500 --> 42:23.260]  функциональные зависимости, но во втором случае у нас не обязательно функциональная, вторая
[42:23.260 --> 42:27.740]  функциональная зависимость у нас не обязательно от второго функционального составного тревичного
[42:27.740 --> 42:35.820]  ключа, достаточно только одного компонента, а мы это тогда декомпозируем, чтобы у нас по условию
[42:35.820 --> 42:49.900]  все детерминаты всех функциональных зависимости являлись потенциальными ключами, и у нас мы
[42:49.900 --> 42:59.940]  декомпозировали, преподаватель студент у нас тоже декомпозировал, у нас все детерминаты здесь
[42:59.940 --> 43:08.580]  являются потенциальными ключами, но есть определенная проблема, все еще существует проблема вот какого
[43:08.580 --> 43:14.700]  рода, что у нас исходная функциональная зависимость студент предмет, детерминат, что преподаватель
[43:14.700 --> 43:20.460]  зависит от студента и предмета, не может быть выведено из той единственной функциональной
[43:20.460 --> 43:27.420]  зависимости, которая сохранилась, преподаватель предмет. Что имеется в виду? Имеется в виду,
[43:27.420 --> 43:32.740]  что у нас на самом деле в левом декомпозированном отношении функциональной зависимости как
[43:32.740 --> 43:41.500]  не забавно и нет, у нас отношение преподавателя студент, исходное отношение разделилось таким
[43:41.500 --> 43:49.980]  образом, что мы не сохранили все функциональные зависимости, но при этом мы наше исходное
[43:49.980 --> 43:56.820]  отношение, которое не находилось в форме бойса, нормальной форме бойса кода, нормализовали,
[43:56.820 --> 44:05.380]  вот то о чем я говорил, что у нас должна быть еще какая-то семантика подлежащая, на которую нам
[44:05.380 --> 44:13.580]  стоит обращать внимание, и в данном случае такая нормализация, как приведена на рисунке,
[44:13.580 --> 44:21.940]  она возможна, но получим ли мы здесь какой-то существенный прирост в производительности или
[44:21.940 --> 44:26.100]  непротиворечивости, ну сложно, наверное, сказать, потому что преподаватель студент у нас вообще
[44:26.100 --> 44:31.700]  получается стаблица «многие ко многим», которая будет у нас и слева, и справа очевидно иметь
[44:31.720 --> 44:42.260]  ограничение внешнего ключа, и преподавателю к преподавателю в левой таблице будет вести
[44:42.260 --> 44:48.140]  к преподавателю правой таблице, атрибут студента левой таблице — это estar wnекаем таблице студентов,
[44:48.140 --> 44:50.720]  где уже студент, уже у нас будут уникальными сущностями.
[44:52.100 --> 44:59.540] E sister
[44:59.540 --> 45:17.540]  Почему изначальная таблица не в нормальной форме бойс-кода, потому что переменные отношения находятся в нормальной форме бойс-кода тогда и только тогда, когда детерминаты всех фоноксиональной зависимости являются потенциальными ключами.
[45:17.540 --> 45:32.540]  У нас здесь детерминаты фоноксиональной зависимости от 2 мы вывели.
[45:32.540 --> 45:46.540]  Студент-предмет и преподаватель. Являются ли они у нас фоноксиональными ключами? Прошу прощения, потенциальными ключами.
[45:46.540 --> 46:09.540]  Студент-предмет является ли у нас преподавателем? Преподаватель у нас не является первичным ключом, не является детерминатом и не является первичным ключом.
[46:09.540 --> 46:19.540]  Вот здесь у нас преподаватель стал детерминатом по отношению к предмету и также первичным ключом.
[46:19.540 --> 46:29.540]  А здесь правда у нас не сохранилась детермината и первичного ключа.
[46:29.540 --> 46:41.540]  Знаете, любопытный получился пример, потому что он не то чтобы получился, это пример на самом деле из Кристофера Дейта, из его введения в базы данных.
[46:41.540 --> 46:51.540]  Пример, иллюстрирующий неорганичность нормализации по отношению к реальной семантике данных.
[46:51.540 --> 47:10.540]  Семантика у нас есть, она не в форме бойса кода изначальная таблица, потому что у нас в данном случае у функциональной зависимости преподаватель предмет не является детерминатом.
[47:10.540 --> 47:23.540]  Функциональная зависимость преподавателя предмет есть, детермината, преподаватель предмет всех является потенциальным ключами.
[47:23.540 --> 47:27.540]  Прошу прощения, преподаватель не является потенциальным ключом в данном случае.
[47:27.540 --> 47:36.540]  Заговариваюсь, извините, ребят, не является потенциальным ключом, хотя зависимость есть, не является потенциальным ключом, потому что значения повторяются.
[47:36.540 --> 47:39.540]  Вот здесь у нас значения не повторяются, здесь значения повторяются.
[47:39.540 --> 47:45.540]  При этом функциональная зависимость преподавателя предмет есть, студент предмет, преподаватель тоже функциональная зависимость есть.
[47:45.540 --> 47:47.540]  Нам это нужно разбить.
[47:47.540 --> 47:57.540]  Преподаватель предмет мы разбиваем, у нас получается преподаватель-студент мы разбиваем.
[47:57.540 --> 48:07.540]  Мы разбиваем, но по сути дела у нас здесь каждый кортеж является первичным ключом.
[48:07.540 --> 48:18.540]  У нас здесь не то чтобы нарушается что-то, не то чтобы нарушается принцип чего-то, у нас по сути дела нет третьего атрибута, который был бы зависимой частью.
[48:18.540 --> 48:22.540]  У нас вот это первичный ключ, вот это первичный ключ, вот это первичный ключ, вот это первичный ключ.
[48:22.540 --> 48:27.540]  Просто вот здесь отсутствует функциональная зависимость по отношению к неключевому какому-то атрибуту.
[48:27.540 --> 48:38.540]  В таком случае, это особенность отношения, потому что оно у нас такое маленькое, компактное получилось из трех атрибутов, демонстрационное.
[48:38.540 --> 48:49.540]  Но мы тем не менее его нормализовали, мы убрали то, о чем шла речь, чтобы у нас не было детерминатов, не являющихся ключами.
[48:49.540 --> 48:55.540]  Но при этом у нас появилась другая проблема, связанная с тем, что вот эта таблица многие ко многим.
[48:55.540 --> 49:05.540]  И вот здесь из студента будет идти другая зависимость уже в другую сторону, должна идти, чтобы все это было тоже нормализовано, чтобы мы не добавляли сюда что-то произвольное.
[49:05.540 --> 49:15.540]  Так что пример вот такой, пример с изъяном запланированный.
[49:15.540 --> 49:26.540]  Для более, может быть, подробного описания, опять же, вас подсылаю к Кристоферу Дейту, где у него там целая глава на это отведена.
[49:26.540 --> 49:39.540]  Но, в принципе, здесь, наверное, важно усвоить, что здесь нет четкого простого алгоритма для нормализации.
[49:39.540 --> 49:51.540]  Как со второй нормальной формой или хотя бы с третьей нормальной формой, когда мы просто идем справа налево и декомпозируем.
[49:51.540 --> 49:55.540]  Но, грубо говоря, в примере у нас получилось по стрелочкам. Вот какие у нас стрелочки были.
[49:55.540 --> 50:03.540]  Мы две стрелочки, мы там выбрали два отношения, чтобы функциональную зависимость в них соблюсти, которая не была транзитивной.
[50:03.540 --> 50:09.540]  Здесь нет какого-то четкого критерия.
[50:09.540 --> 50:17.540]  Ну, опять же, Кристофер Дейт превыходит, честно говоря, алгоритм, но он такой сильно теоретический.
[50:17.540 --> 50:27.540]  Я со своей стороны просто скажу, что для формы бойса кода, ну, практических ситуаций не так часто возникают для применения.
[50:27.540 --> 50:37.540]  Поэтому знать нужно, применять стоит, если вы опознали ситуацию, подходящую под этот случай.
[50:37.540 --> 50:42.540]  Но не факт, что это будет часто.
[50:42.540 --> 50:59.540]  Поэтому еще раз напомню, что нам нужно было избавиться, и мы избавились от детермината функциональной зависимости в исходном отношении, который не являлся первичным ключом.
[50:59.540 --> 51:02.540]  Ну, потенциальным ключом, во всяком случае.
[51:02.540 --> 51:15.540]  Потому что вот преподаватели у нас в данном случае не уникальные записи, не соответствуют требованию уникальности первичного ключа.
[51:15.540 --> 51:24.540]  Хорошо, все, распрощались с нормализацией. По бойсу кода у нас в любом случае не будет никаких вопросов, ничего.
[51:24.540 --> 51:28.540]  На семинарах мы, по-моему, тоже это не должны проходить и не проходили.
[51:28.540 --> 51:38.540]  Поэтому это такой теоретический плюсик в копилку ваших теоретических знаний, по крайней мере, и, возможно, практических тоже.
[51:38.540 --> 51:43.540]  Хорошо, версионирование. Давайте быстро посмотрим, на слайдах будет подробнее.
[51:43.540 --> 51:51.540]  Ну, что это такое? Версионирование, в общем случае, это просто способ хранить историческую информацию о измененных значениях в базе данных.
[51:51.540 --> 52:01.540]  Можно говорить о том, что есть и версионирование на уровне физическом, ну, окей, на уровне функционирования СУБД,
[52:01.540 --> 52:12.540]  а есть версионирование на уровне логическом, логикосемантическом, даже скажем так, встроенное за счет внутренних средств СУБД или расширений.
[52:12.540 --> 52:17.540]  Понятно, утилиты какие-то, в позгрессе, например, ну и не только в позгрессе.
[52:17.540 --> 52:28.540]  Вот там, если вы погрузитесь, там, на самом деле, есть у каждой строки, на диске физически есть версия, хранятся версии строк.
[52:28.540 --> 52:36.540]  Это не совсем про версионирование в том смысле, что можно это извлечь и прочитать, но, тем не менее, позгресс хранит версии строк,
[52:36.540 --> 52:44.540]  и в момент совершения транзакции там может быть несколько этих версий строк, хранящихся одновременно, ну как бы и так далее.
[52:44.540 --> 52:52.540]  Ручное, ну понятно, мы здесь строим какие-то конструкции, чтобы в нашей схеме данных, чтобы мы могли при изменении данных
[52:52.540 --> 52:59.540]  в наших каких-то технических таблицах ввести учет этому.
[52:59.540 --> 53:08.540]  Ручное версионирование используется такая концепция, как Slowly Changing Dimensions, медленно меняющиеся измерения,
[53:08.540 --> 53:16.540]  а, в свою очередь, почему мы сейчас вдруг вот такую терминологию, внезапно к ней пришли и ее используем, очень просто.
[53:16.540 --> 53:24.540]  Это речь о том, что концепцию эту придумал Ральф Кимбл, ну, в частности, можно посмотреть и подробнее прочитать.
[53:24.540 --> 53:29.540]  Ральф Кимбл и Маржи Роз.
[53:29.540 --> 53:39.540]  Вообще, Ральф Кимбл это один из двух ключевых ученых и публицистов, специализирующихся на построении хранилищ данных.
[53:39.540 --> 53:43.540]  Второй это Уильям Эйнман, ну а об этом мы с вами поговорим на отдельной лекции.
[53:43.540 --> 53:49.540]  Смысл в чем? В том, что в хранилище данных, условно, то есть хранилище данных, что такое?
[53:49.540 --> 54:00.540]  Это место на диске, или большой диск, или большое количество серверов с большими дисками, куда сливаются данные из разных источников.
[54:00.540 --> 54:09.540]  И подчас не всегда они нормализованы, и сама структура этих хранилищ данных не всегда предполагает или требует нормализации.
[54:09.540 --> 54:19.540]  Вот Ральф Кимбл как раз сторонник идеи, что нормализация, такая глубокая хранилища данных, она мне нужна.
[54:19.540 --> 54:26.540]  Он предлагает иную схему построения, которая называется звезда, звездочка или снежинка,
[54:26.540 --> 54:32.540]  где таблица у нас делится на таблице фактов и таблице данных, таблице измерений, прошу прощения.
[54:32.540 --> 54:38.540]  А таблица фактов, это просто условно говоря, вот у вас чек пробивается до касси и идут данные в таблицу фактов.
[54:38.540 --> 54:48.540]  А в таблице фактов у вас там есть кассир, магазин, номер кассового устройства, товар.
[54:48.540 --> 54:56.540]  И вот эти данные, кассир, магазин, товар, они у вас являются внешними ключами по отношению к каким-то таблицам измерений.
[54:56.540 --> 55:02.540]  У вас есть таблица отдельная на измерение товаров, на измерение кассиров, на измерение магазинов.
[55:02.540 --> 55:11.540]  То есть измерение в данном случае в русском языке, здесь такая амонемия получается, измерение я измерить и измерение в смысле пространства какого-то.
[55:11.540 --> 55:20.540]  В данном случае речь, когда мы говорим про медленно меняющееся измерение, про некие пространства в семантическом плане,
[55:20.540 --> 55:31.540]  в некой области наших данных, по сути дела это отношение, медленно меняющееся отношение для лучшего понимания, можно сказать так.
[55:31.540 --> 55:41.540]  Хорошо, так, ну здесь еще немножко подробностей про...
[55:41.540 --> 55:52.540]  Да, так, и это просто для примера, да, sales effects, таблица фактов, и вот date dimension, product dimension, это вот прямо из книги, цитата,
[55:52.540 --> 55:57.540]  в виде рисунка дата warehouse look 2013 года издания.
[55:57.540 --> 56:06.540]  Медленно меняющиеся измерения несколько типов выделяют, у Kimball их вообще шесть, но последние два они производные от предыдущих,
[56:06.540 --> 56:13.540]  поэтому мы поговорим о четырех быстренько, пяти вернее, с нуля начинают, там получается семь у Kimball.
[56:13.540 --> 56:23.540]  Тип 0 это вообще, по большому счету, не SCD, это просто оригинальная таблица, тип 1 это перезапись, когда мы постоянно меняем данные в некой исходной таблице,
[56:23.540 --> 56:30.540]  и тип 2 это новые строки, тип 3 новые атрибуты, тип 4 новые отношения. Как это все выглядит?
[56:30.540 --> 56:39.540]  Ну, все довольно просто, тип 0, тип 1, понятно, там не о чем говорить, не будем приводить примеры.
[56:40.540 --> 56:49.540]  В данном случае у нас в каждую запись добавляется новая запись при каждом изменении,
[56:49.540 --> 56:57.540]  и здесь еще и атрибуты добавлены, конечно, но они такие технические, что ли, которые хранят время просто в записи, когда у нас что-то меняется.
[56:57.540 --> 57:05.540]  Вот Николай перешел из позиции 21 в департаменте 2, на позицию 23 в департаменте 3.
[57:05.540 --> 57:19.540]  И, вернее, наоборот, нет, прошу прощения, он перешел с одной позиции на другую, там или работал где-то, может быть, даже параллельно.
[57:19.540 --> 57:29.540]  У нас здесь есть время, начало-время-окончание, и вот здесь время еще не закончено, он продолжает работать в департаменте 3 на позиции 23.
[57:29.540 --> 57:39.540]  Вот мы вот так храним по Николаю каждое движение внутри нашей корпоративной структуры в таблице типа SCD2.
[57:39.540 --> 57:53.540]  В полях технических обычно не пишется null, то есть мы здесь пишем не null, а просто филер такой добавляем для того, чтобы упрощать запросы,
[57:53.540 --> 58:11.540]  чтобы писать в первом случае where day dt between valid from dttm и valid to dttm вместо вот такого более сложного запроса еще и с несколькими условиями.
[58:11.540 --> 58:23.540]  Так, достоинство неудобства хранит не полную и ограниченную историю версии, хранит полный и не ограниченный удобный и простой доступ к данным необходимого периода,
[58:23.540 --> 58:31.540]  и с другой стороны провоцирует избыточность или заведение дополнительных наблиз для хранения изменений атрибута.
[58:31.540 --> 58:44.540]  SCD типа 3, где мы прям отдельно храним в виде отдельного атрибута значение предыдущей нашей некой переменной.
[58:44.540 --> 59:07.540]  У нас в принципе что здесь имеет место быть, то есть мы здесь прям идем не от дат, не от новых строк с точки зрения времени, мы идем с точки зрения изменения качественной характеристики,
[59:07.540 --> 59:15.540]  добавляем для этих качественных характеристик отдельные поля, причем в данном случае это упрощенный пример такой.
[59:15.540 --> 59:27.540]  По большому счету мы бы могли целиком добавить предыдущее значение некоего кортежа в левую часть таблицы, дописав точно те же самые колонки,
[59:27.540 --> 59:41.540]  ну за исключением первичного ключа там айдишника, и у нас была бы строка, где вот не просто привез current state 01, а у нас была бы еще строка, где было бы update DTTM дополнительно и было бы старое время.
[59:41.540 --> 59:50.540]  Ну пример такой да условно немножко в данном случае в педагогических так сказать целях.
[59:50.540 --> 01:00:05.540]  Достоинство небольшой объем данных, простой быстрый доступ к истории, но ограниченная история, потому что мы храним только, ну как бы вот по методологии этой нас никто конечно не ограничивает, но по методологии мы храним только последнюю версию,
[01:00:05.540 --> 01:00:15.540]  последнюю и предпоследнюю версию и не глубже. SCD тип 4 здесь тоже все довольно просто, у нас просто отдельная таблица с историей.
[01:00:15.540 --> 01:00:23.540]  Ну собственно все в отдельную таблицу мы заводим все что захотим, ну подробности изменений заводим любые какие посчитаем нужным.
[01:00:23.540 --> 01:00:36.540]  Недостатки здесь разделение сущности на разные таблицы, это с одной стороны и недостаток некоторые, что нам придется более сложные запросы какие-то составлять,
[01:00:36.540 --> 01:00:49.540]  с другой стороны это может быть наоборот достоинство, потому что логически у нас хорошо все это разделено и у нас не возникает никаких проблем при добавлении данных,
[01:00:49.540 --> 01:00:57.540]  мы их по разным таблицам распихиваем, у которых разные ограничения, разные условия и в этом смысле все достаточно удобно кажется.
[01:00:57.540 --> 01:01:15.540]  Так, TCL, ACID и изолированность, вот мы и добрались до очередной группы нашего SQL, SQL SQL Transaction Control Language, основные команды Комит и Албек,
[01:01:15.540 --> 01:01:19.540]  и у нас здесь возникает вопрос, а что такое вообще транзакция?
[01:01:19.540 --> 01:01:25.540]  Транзакция это группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными,
[01:01:25.540 --> 01:01:29.540]  гарантированно переводящая базу данных из одного непротиворечивого состояния в другое.
[01:01:29.540 --> 01:01:44.540]  То есть у нас смысл в том, что при выполнении транзакции должны сохраняться все те ограничения, все те зависимости, которые у нас предусмотрены нашей схемой,
[01:01:44.540 --> 01:01:53.540]  и при этом наша транзакция должна работать независимо от каких-то сбоев в плане физического оборудования в том числе,
[01:01:53.540 --> 01:02:00.540]  и также она должна выполняться по принципу все или ничего.
[01:02:00.540 --> 01:02:17.540]  Транзакции реляционных с систем управления баз данных обязательно имеют четыре ключевых свойства, это аббревиатура ACID,
[01:02:17.540 --> 01:02:29.540]  и важно подчеркнуть, что речь идет именно о реляционных с UBD, потому что для иных типов с UBD там могут быть иные варианты их существования,
[01:02:29.540 --> 01:02:34.540]  как бы в реальном мире проведения транзакций.
[01:02:34.540 --> 01:02:42.540]  Но об этом мы с вами поговорим, я надеюсь успеем затронуть NoSQL базы данных в общих чертах, поговорим.
[01:02:42.540 --> 01:02:51.540]  Здесь небольшое отступление сразу сделаю, есть более общая концепция, из которой можно как бы вывести ACID,
[01:02:51.540 --> 01:02:59.540]  свойства, это теорема Брюера или CAP, CAP теорема, она говорит, ну такая по большому счету империческое наблюдение,
[01:02:59.540 --> 01:03:06.540]  это из серии, что можно долго, дорого и качественно, вот мы можем из этих трех вариантов максимизировать только два и никогда не три,
[01:03:06.540 --> 01:03:12.540]  вот здесь то же самое, только качество согласованность данных, доступность данных и устойчивость к разделению,
[01:03:12.540 --> 01:03:21.540]  мы можем максимизировать только два из них, но никак не три, ну как бы физически это наше ограничение,
[01:03:21.540 --> 01:03:26.540]  в той реальности, в которой мы живем, только два можем на данный момент, может быть что-то придумают дальше,
[01:03:26.540 --> 01:03:32.540]  более интересное, какие-нибудь квантовые базы данных, ну ладно, не будем фантазировать на эту тему,
[01:03:32.540 --> 01:03:38.540]  смысл в том, что максимизация параметров consistency и availability, то есть согласованности и доступности данных,
[01:03:38.540 --> 01:03:43.540]  порождает ACID свойства транзакций для реализационных систем управления баз данных,
[01:03:43.540 --> 01:03:51.540]  и соответственно, как вы понимаете, у нас более низкая устойчивость к разделению в наших РСОБД.
[01:03:51.540 --> 01:03:58.540]  А что такое ACID? Это Atomic Consistent Isolated Endurable, атомарные согласованные, изолированные, долговечные,
[01:03:58.540 --> 01:04:03.540]  устойчивые должны быть транзакции, то есть выполняться по принципу все или ничего Atomic Consistent,
[01:04:04.540 --> 01:04:09.540]  каждая успешная транзакция фиксирует только допустимые результаты, то есть соблюдает все ограничения наших данных,
[01:04:09.540 --> 01:04:13.540]  изолированные, то есть параллельные транзакции не влияют на результаты друг друга,
[01:04:13.540 --> 01:04:20.540]  durable, долговечные, устойчивые, то есть вне зависимости от сбоев, результаты успешных транзакций сохраняются в системе.
[01:04:20.540 --> 01:04:30.540]  Так, ну здесь просто более подробное описание Isolated Consistent Endurable, ничего сложного на самом деле нет,
[01:04:30.540 --> 01:04:37.540]  там можете посмотреть просто слайды, все это довольно явно вытекает из того, о чем мы говорили,
[01:04:37.540 --> 01:04:42.540]  из того, о чем сказано на начальном слайде по поводу ACID.
[01:04:42.540 --> 01:04:47.540]  По поводу основных команд TCL, это Commit Rollback SF Safe Point.
[01:04:47.540 --> 01:04:58.540]  По умолчанию, кстати, у нас наше insert, например, update, delete команды, они уже, ну и там еще ряд команд SQL,
[01:04:58.540 --> 01:05:05.540]  которые мы проходили, они уже у нас содержат команду Commit после себя, то есть происходит autocommit всегда после их выполнения.
[01:05:05.540 --> 01:05:15.540]  Мы же можем произвольно задать условия для выполнения коммитов, в них сделать Rollback и Safe Point для того,
[01:05:15.540 --> 01:05:22.540]  чтобы в случае, когда мы сомневаемся в отношении какого-то каких-то данных их внесения,
[01:05:22.540 --> 01:05:28.540]  когда мы сомневаемся в отношении устойчивости нашей системы, мы могли всегда откатиться либо на Safe Point,
[01:05:28.540 --> 01:05:32.540]  либо на начало операции, ну сейчас посмотрим, что это такое.
[01:05:32.540 --> 01:05:43.540]  Всегда начинается с Begin Transaction, наши TCL команды, уровень изоляции определяется, что это такое сейчас тоже скажем.
[01:05:43.540 --> 01:05:51.540]  Дальше Read-Write Only, понятно, писатели читают только уровень ограничения.
[01:05:51.540 --> 01:06:01.540]  Defrable, ну давайте пока без Defrable, если хотите, можете в документации почитать подробнее.
[01:06:01.540 --> 01:06:12.540]  В принципе Safe Point, мы можем еще задать имя Safe Point для того, чтобы конкретно указывать,
[01:06:12.540 --> 01:06:18.540]  куда конкретно к какому Safe Point из нескольких нам откатываться.
[01:06:18.540 --> 01:06:28.540]  А вот пример, Begin Transaction Isolated Level Read Committed, добавляем данные в таблицу, делаем Safe Point, My Safe Point,
[01:06:28.540 --> 01:06:33.540]  добавляем в единичку, добавляем двойку, добавляем тройку.
[01:06:33.540 --> 01:06:40.540]  Когда у нас срабатывает Rollback to Safe Point, после добавления двойки мы откатываемся вот в этом блоке,
[01:06:40.540 --> 01:06:50.540]  мы откатываемся на Safe Point, у нас двойка не сохраняется, у нас тогда и конечная команда нашей транзакции будет добавить тройку,
[01:06:50.540 --> 01:06:55.540]  и мы на выходе получим таблицу Table1 со значениями 1 и 3.
[01:06:55.540 --> 01:06:59.540]  В данном примере, конечно, здесь нет никакой логики, для чего это нужно,
[01:06:59.540 --> 01:07:05.540]  но это бывает нужно для того, чтобы лишний раз удостовериться, что у нас не упадет наша транзакция с ошибкой,
[01:07:05.540 --> 01:07:10.540]  либо если упадет, то тогда хотя бы часть данных будет внесена либо изменена,
[01:07:10.540 --> 01:07:14.540]  на которую мы рассчитываем и надеемся, на их изменения.
[01:07:14.540 --> 01:07:21.540]  Есть проблемы поддержки изолированности.
[01:07:21.540 --> 01:07:30.540]  Проблема поддержки изолированности – потерянное обновление, грязное чтение, неповторяющееся чтение и чтение фантомов.
[01:07:30.540 --> 01:07:38.540]  И для этих проблем существует уровень изолированности, корреспонтирующий им.
[01:07:39.540 --> 01:07:44.540]  Потерянное обновление – это когда у нас…
[01:07:44.540 --> 01:07:47.540]  Ну да, проблемы изолированности вообще что означают?
[01:07:47.540 --> 01:07:50.540]  Что у нас в параллели выполняются какое-то количество транзакций,
[01:07:50.540 --> 01:07:55.540]  и они начинают влиять на данные, которые используются друг другом.
[01:07:55.540 --> 01:07:58.540]  То есть одна использует те же самые данные, что и вторая.
[01:07:58.540 --> 01:08:02.540]  Ну а в масштабе это может быть десятки, там сотни транзакций.
[01:08:02.540 --> 01:08:08.540]  И потерянное обновление, например, у нас неопределенный результат получается,
[01:08:08.540 --> 01:08:15.540]  когда у нас две транзакции обращаются к одной и той же таблице, к одному и тому же атрибуту этой таблицы.
[01:08:15.540 --> 01:08:23.540]  Итоговая сумма на вашем счете при внесении пополнения и поступления перевода будет неопределена.
[01:08:23.540 --> 01:08:29.540]  Ну как бы в плохой ситуации. В реальности, конечно, у нас банковские базы данных умеют этим бороться.
[01:08:29.540 --> 01:08:41.540]  Грязное чтение. Когда у нас получается, что последствия одной транзакции влияют на другую.
[01:08:41.540 --> 01:08:50.540]  И неповторяющееся чтение, ну да, то есть грязное чтение, когда у нас,
[01:08:50.540 --> 01:08:58.540]  когда происходит чтение изменяемых в процессе чтения данных,
[01:08:58.540 --> 01:09:07.540]  уже непонятно может получиться, что данные, которые прочитает база, они будут либо старые,
[01:09:07.540 --> 01:09:14.540]  либо, наоборот, новые. Например, если у нас еще иерлбек произошел, то будут новые, которые тем не менее не были внесены.
[01:09:14.540 --> 01:09:24.540]  Это тоже проблема. Неповторяющееся чтение, когда у нас между двумя последовательными обращениями к базе данных происходит какая-то транзакция.
[01:09:24.540 --> 01:09:32.540]  Ну, например, причем это не просто разные селект-запросы, а это, например, один вложен в другой, то есть это под запрос.
[01:09:32.540 --> 01:09:40.540]  И здесь у нас может получиться так, что данные будут, да, инконсистентные, не связанные, не соответствующие друг другу.
[01:09:40.540 --> 01:09:52.540]  И таким образом возникнет проблема, связанная с тем, что мы просто получим какой-то невразумительный результат на итоге,
[01:09:52.540 --> 01:09:56.540]  ну или вот как в примере, да, что с карты списывается большая сумма, чем мы ожидали.
[01:09:56.540 --> 01:10:10.540]  Хотя мы там могли либо там удалить данные из корзины, либо, наоборот, там данные какие-то поменять, если бы речь идет о каком-то онлайн-магазине.
[01:10:10.540 --> 01:10:21.540]  Или чтение фантомов, когда у нас происходит тоже, ну, по сути дела, похожая ситуация,
[01:10:21.540 --> 01:10:31.540]  что мы не учитываем какое-то обновление данных, которое происходит в процессе нашей работы с базами данных.
[01:10:31.540 --> 01:10:44.540]  Изменяются данные в том или ином отношении, в той или иной таблице, а наш результат выполнения наших запросов не соответствует реальному содержанию нашей базы данных.
[01:10:44.540 --> 01:10:54.540]  Соответственно, есть уровни изолированности транзакций, uncommitted, committed, repeatable, repeatable, serializable.
[01:10:54.540 --> 01:11:10.540]  Все эти уровни, они на самом деле типические, и от менее изолированного к более изолированному располагаются.
[01:11:10.540 --> 01:11:20.540]  Смотрите, уровни изолированности обеспечивают решение проблемы потерянного обновления, грязного, неповторяющегося фантомного чтения.
[01:11:20.540 --> 01:11:25.540]  И вот чем выше уровень, тем больше проблем решается.
[01:11:25.540 --> 01:11:35.540]  По умолчанию, кстати, в Postgres return committed установлено, поэтому здесь ну, это тоже нулевой уровень для Postgres.
[01:11:35.540 --> 01:11:45.540]  Есть проблемы, связанные с увеличением уровня изоляции, когда мы делаем наши транзакции, совершаем.
[01:11:45.540 --> 01:11:59.540]  Проблема очень простая заключается в том, что чем выше уровень изоляции транзакции, тем проблемнее будет другим командам, конкурирующим запросам,
[01:11:59.540 --> 01:12:12.540]  прочитать, изменить, удалить, внести данные, то отношение в тот кортеж, который сейчас у нас находится, который сейчас у нас обрабатывается транзакцией с высоким уровнем изолированности.
[01:12:12.540 --> 01:12:17.540]  То есть чем выше уровень изолированности, тем ниже уровень параллелизма.
[01:12:17.540 --> 01:12:22.540]  Все, на этом сегодня заканчиваем.
[01:12:22.540 --> 01:12:47.540]  В следующий раз у нас будет большая, по содержанию, лекция, связанная с
[01:12:47.540 --> 01:12:51.540]  расширенными возможностями SQL и расширениями процедурными SQL.
[01:12:51.540 --> 01:12:59.540]  Все это наконец охватим и, в принципе, наверное, по большому счету, можно сказать, завершим основной инструментарий
[01:12:59.540 --> 01:13:05.540]  SQL языка для СУБД и, в частности, для СУБД Postgres.
