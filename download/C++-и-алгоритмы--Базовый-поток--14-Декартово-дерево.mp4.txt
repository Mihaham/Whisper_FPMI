[00:00.000 --> 00:07.000]  И на самом деле вот так решается любая задача из контрольной.
[00:07.000 --> 00:09.000]  Очень просто.
[00:09.000 --> 00:12.000]  Абсолютно таким образом. Не беспокойтесь, все будет нормально.
[00:12.000 --> 00:15.000]  А теперь давайте перейдем к лекции.
[00:15.000 --> 00:21.000]  Сегодня мы продолжим обсуждать задачи RMQ и RSQ.
[00:21.000 --> 00:27.000]  Но перед этим нам необходимо поговорить про бинарные деревья поиска.
[00:28.000 --> 00:32.000]  В принципе, я мог воспользоваться вашими текущими знаниями и сказать,
[00:32.000 --> 00:36.000]  что в прошлом семестре вы изучали бинарные деревья поиска.
[00:36.000 --> 00:38.000]  Например, AVL дерево, Splay дерево.
[00:38.000 --> 00:42.000]  Но я поступлю по-другому. Сегодня я рассмотрю еще одно дерево поиска.
[00:42.000 --> 00:46.000]  По нескольким причинам. С одной стороны, по педагогическим.
[00:46.000 --> 00:49.000]  Потому что в прошлом семестре вы изучали AVL дерево.
[00:49.000 --> 00:52.000]  Напомню, что AVL дерево дает строгую гарантию того,
[00:52.000 --> 00:57.000]  что у вас любая операция, ставки, удаление поиска занимает логарифмическое время.
[00:57.000 --> 00:59.000]  Потом вы изучали Splay дерево.
[00:59.000 --> 01:03.000]  Splay дерево уже не гарантирует, что каждая операция будет занимать логарифмическое время.
[01:03.000 --> 01:07.000]  Но она, скажем так, дает амортизационную логарифмическую стоимость каждой операции.
[01:07.000 --> 01:11.000]  То есть это означает, что какое бы количество операций вы ни сделали,
[01:11.000 --> 01:15.000]  если вы просуммируете их время работы, то в сумме это будет неотличимо от того,
[01:15.000 --> 01:18.000]  как бы каждая операция выполнялась за логарифм.
[01:18.000 --> 01:23.000]  Соответственно, у нас есть дерево, которое работает в худшем случае за логарифм.
[01:23.000 --> 01:26.000]  Есть дерево, которое работает в амортизированном случае.
[01:26.000 --> 01:29.000]  В случае амортизационного анализа за логарифм.
[01:29.000 --> 01:33.000]  И есть еще одна ипостась анализа алгоритмов.
[01:33.000 --> 01:36.000]  Какую мы еще не рассматривали.
[01:38.000 --> 01:44.000]  Сложность бывает в худшем случае, в амортизированном смысле и в среднем.
[01:44.000 --> 01:47.000]  Если у вас в алгоритме есть какая-то рандомизация,
[01:47.000 --> 01:52.000]  то мы можем говорить о том, что алгоритм работает за такое-то время в среднем.
[01:52.000 --> 01:56.000]  Если мы несколько раз запустим алгоритм и потом в среднем все это время работает,
[01:56.000 --> 01:58.000]  то мы получим определенную величину.
[01:58.000 --> 02:01.000]  Давайте рассмотрим пример такого дерева.
[02:01.000 --> 02:05.000]  Если вы в прошлом семестре не писали бинарные деревья поиска,
[02:05.000 --> 02:09.000]  то сейчас мы изучим еще одно дерево поиска, которое, на мой взгляд, гораздо более простое,
[02:09.000 --> 02:11.000]  чем те, которые изучали до этого.
[02:11.000 --> 02:15.000]  Если вы до этого дерева поиска не писали, то хороший повод начать.
[02:15.000 --> 02:18.000]  Сегодня мы говорим про дикартовое дерево.
[02:36.000 --> 02:38.000]  Начнем с определения.
[02:41.000 --> 02:56.000]  Дикартовое дерево – это структура данных в виде бинарного дерева,
[02:56.000 --> 03:15.000]  которая хранит пары.
[03:15.000 --> 03:19.000]  Как правило, первый элемент пары называют ключом.
[03:19.000 --> 03:23.000]  Пары ключ и у называют приоритетом.
[03:26.000 --> 03:29.000]  Структура данных, которая хранит пары x, y,
[03:29.000 --> 03:38.000]  является бинарным деревом поиска по x.
[03:38.000 --> 03:42.000]  То есть по ключам эта структура данных является бинарным деревом поиска.
[03:42.000 --> 03:51.000]  А по y – бинарной кучей или пирамидой.
[03:57.000 --> 03:59.000]  То есть можно сказать, что дикартовое дерево – это структура данных,
[03:59.000 --> 04:02.000]  которая является два в одном.
[04:02.000 --> 04:08.000]  То есть она одновременно и бинарное дерево поиска, и куча по минимуму.
[04:09.000 --> 04:15.000]  Иногда из-за этого ее называют в англоязычной литературе «trip»
[04:15.000 --> 04:20.000]  от слова «tree» плюс «hip».
[04:20.000 --> 04:23.000]  Ну, в розыскоязычной, как только не коверкают,
[04:23.000 --> 04:28.000]  в общем, дуча, дирамида, курева и так далее.
[04:28.000 --> 04:33.000]  Давайте привезем пример того, что мы на самом деле ввели,
[04:33.000 --> 04:36.000]  что это такая структура данных.
[04:36.000 --> 04:41.000]  Давайте рассмотрим какое-нибудь дерево.
[04:52.000 --> 04:54.000]  Вот это бинарное дерево.
[04:54.000 --> 04:57.000]  Ну и давайте напишем какие-нибудь значения в узлах этого дерева.
[04:57.000 --> 04:59.000]  Значит, что мы знаем?
[04:59.000 --> 05:04.000]  Мы знаем, что эта структура данных является деревом поиска по x.
[05:04.000 --> 05:06.000]  То есть давайте напишем какие-нибудь значения.
[05:06.000 --> 05:13.000]  То есть тут один, тут два, тут нет, тут два.
[05:13.000 --> 05:22.000]  Дальше пусть четыре, пять, семь, восемь, девять, десять, одиннадцать.
[05:22.000 --> 05:25.000]  Ну, кажется так.
[05:25.000 --> 05:29.000]  То есть в каждом узле, точнее говоря, в каждом подделье
[05:29.000 --> 05:35.000]  дерево выполняется свойство бинарного дерева поиска.
[05:35.000 --> 05:37.000]  Ну и давайте напишем приоритеты.
[05:37.000 --> 05:41.000]  Ну, давайте для общности считать, что у нас эта структура данных
[05:41.000 --> 05:43.000]  является кучей и по минимуму.
[05:43.000 --> 05:45.000]  То есть в корне всегда хранится минимум.
[05:45.000 --> 05:53.000]  Ну, давайте нуль, один, пять, восемь, десять, одиннадцать.
[05:53.000 --> 05:56.000]  Два, три, четыре.
[05:56.000 --> 05:58.000]  Вот.
[05:58.000 --> 06:02.000]  Соответственно, вот эта структура данных, которая хранит в себе пары
[06:02.000 --> 06:04.000]  один, пять, два, один, пять, восемь, четыре, десять, семь,
[06:04.000 --> 06:06.000]  одиннадцать, десять, четыре, одиннадцать, три и так далее.
[06:06.000 --> 06:10.000]  Вот пример. То есть по x, по первому элементу пар
[06:10.000 --> 06:12.000]  она является бинарным деревом поиска, по второму элементу пар
[06:12.000 --> 06:18.000]  она является бинарной пирамидой с минимумом в корне.
[06:18.000 --> 06:20.000]  Вот.
[06:20.000 --> 06:26.000]  Давайте, ну, не докажем, а просто
[06:26.000 --> 06:30.000]  я расскажу некоторые утверждения про дикартовое дерево,
[06:30.000 --> 06:34.000]  которое нам еще поможет.
[06:34.000 --> 06:48.000]  Значит, пусть x и не равно y и y и не равно y и g
[06:48.000 --> 06:52.000]  для любых пар i и g,
[06:56.000 --> 06:58.000]  тогда дикартовое дерево
[06:58.000 --> 07:02.000]  по парам x и y и
[07:04.000 --> 07:06.000]  строится единственным образом.
[07:14.000 --> 07:16.000]  Ну, короче, если вам даны пары,
[07:16.000 --> 07:18.000]  и там все ключи уникальные, плюс все приоритеты уникальные,
[07:18.000 --> 07:20.000]  то в этом случае у вас дикартовое дерево,
[07:20.000 --> 07:22.000]  ну, то есть его сразу можно восстановить,
[07:22.000 --> 07:24.000]  то есть оно имеет единственный вид.
[07:24.000 --> 07:26.000]  Ну, доказательств не доказательств, давайте просто
[07:26.000 --> 07:28.000]  поймем это геометрически и заодно
[07:28.000 --> 07:30.000]  наконец разберемся, почему дикартовое дерево
[07:30.000 --> 07:32.000]  называют дикартовым деревом.
[07:32.000 --> 07:36.000]  Давайте на координатной плоскости отложим
[07:36.000 --> 07:38.000]  наши элементы, то есть наши пары,
[07:38.000 --> 07:40.000]  ну, непосредственно вот на картинке.
[07:40.000 --> 07:42.000]  Ну, давайте вот, получится этот пример.
[07:42.000 --> 07:44.000]  Ну, давайте прямо этот пример.
[07:44.000 --> 07:46.000]  Значит, у нас есть...
[07:50.000 --> 07:52.000]  Давайте пусть y вниз растет.
[07:52.000 --> 07:56.000]  Ну, давайте примерно хотя бы 8, 0,
[07:56.000 --> 07:58.000]  где-то здесь,
[07:58.000 --> 08:02.000]  значит, где-то здесь одна вершина,
[08:02.000 --> 08:04.000]  здесь другая вершина.
[08:06.000 --> 08:08.000]  Значит, 5,
[08:14.000 --> 08:16.000]  и, и, и.
[08:18.000 --> 08:20.000]  Ну, как-то так.
[08:20.000 --> 08:22.000]  Вот, и что мы сделаем?
[08:22.000 --> 08:24.000]  Давайте возьмем все эти пары и просто набросаем
[08:24.000 --> 08:26.000]  на координатную плоскость, окей?
[08:26.000 --> 08:28.000]  Вот.
[08:28.000 --> 08:30.000]  Изобразили так.
[08:30.000 --> 08:32.000]  Значит, вопрос.
[08:32.000 --> 08:34.000]  И мы из этой картинки хотим сейчас построить
[08:34.000 --> 08:36.000]  дикартовое дерево.
[08:36.000 --> 08:38.000]  Знаем ли мы, какая вершина
[08:38.000 --> 08:40.000]  будет корнем этого дерева?
[08:42.000 --> 08:44.000]  Какая?
[08:44.000 --> 08:46.000]  Да, у которой наименьший приоритет.
[08:46.000 --> 08:48.000]  То есть мы знаем, что так как
[08:48.000 --> 08:50.000]  дикартовое дерево является кучей по минимуму,
[08:50.000 --> 08:52.000]  то есть бинарной пирамидой по минимуму,
[08:52.000 --> 08:54.000]  то значит, что в корне обязательно должен стоять
[08:54.000 --> 08:56.000]  элемент с минимальным приоритетом,
[08:56.000 --> 08:58.000]  то есть с минимальным y. То есть у нас корень
[08:58.000 --> 09:00.000]  дерева восстанавливается однозначно.
[09:02.000 --> 09:04.000]  Так.
[09:04.000 --> 09:06.000]  А что можно сказать дальше?
[09:06.000 --> 09:08.000]  Что можно сказать про остальные точки?
[09:08.000 --> 09:10.000]  А остальные точки разобьются
[09:10.000 --> 09:12.000]  строго на две группы.
[09:12.000 --> 09:14.000]  Давайте проведем здесь
[09:14.000 --> 09:16.000]  вот такую вертикальную линию.
[09:16.000 --> 09:18.000]  То есть мы знаем, что так как наша структура данных
[09:18.000 --> 09:20.000]  должна являться бинарным деревом поиска,
[09:20.000 --> 09:22.000]  то есть знать, что все элементы больше вот этого
[09:22.000 --> 09:24.000]  x-а должны пойти вправо,
[09:24.000 --> 09:26.000]  а все элементы меньше x-а должны пойти
[09:26.000 --> 09:28.000]  влево. Согласны?
[09:28.000 --> 09:30.000]  То есть мы однозначно, во-первых,
[09:30.000 --> 09:32.000]  останавливаем корень, а во-вторых, однозначно
[09:32.000 --> 09:34.000]  отправляем элементы направо и отправляем элементы налево.
[09:34.000 --> 09:36.000]  Окей?
[09:36.000 --> 09:38.000]  А что мы делаем дальше?
[09:38.000 --> 09:40.000]  Да, ну а дальше просто рекурсивно применяемся к левой части
[09:40.000 --> 09:42.000]  и правой части. Окей?
[09:42.000 --> 09:44.000]  То есть здесь вершина
[09:44.000 --> 09:46.000]  с минимальным приоритетом,
[09:46.000 --> 09:48.000]  она является левым сыном.
[09:48.000 --> 09:50.000]  Здесь вершина с минимальным приоритетом,
[09:50.000 --> 09:52.000]  поэтому строится так.
[09:52.000 --> 09:54.000]  Ну и аналогично.
[09:54.000 --> 09:56.000]  Здесь разделяем на лево и право по дереву,
[09:56.000 --> 09:58.000]  налево и право, и так далее.
[09:58.000 --> 10:00.000]  Ну давайте, восстановим здесь так,
[10:00.000 --> 10:02.000]  здесь так, здесь так,
[10:04.000 --> 10:06.000]  вот так.
[10:06.000 --> 10:08.000]  То есть корень каждого по дереву мы
[10:08.000 --> 10:10.000]  определяем однозначно.
[10:10.000 --> 10:12.000]  И плюс элементы относятся либо к левой части
[10:12.000 --> 10:14.520]  с правой часть, тоже однозначно. Соответственно, дерево тоже однозначно
[10:14.520 --> 10:19.180]  останавливается по всем парам x и y. Но, естественно, если ключи уй, то для уникальных clues.
[10:19.180 --> 10:28.680]  На самом деле, если они rabbits, тоым ă убеждение верно и
[10:28.680 --> 10:32.320]  нужно определиться с тем, что делать, если у вас одинаковые y&y.
[10:32.320 --> 10:36.120]  Какую вершину вы будете отправить к правому дереву, либо будут行uks
[10:36.120 --> 10:53.000]  равные элементы влево по дереву и так далее. Ясно, да? Окей. Так, ну и чего? Ну, смотрите, вроде как, вроде как
[10:53.000 --> 10:58.520]  мы, то есть в начале лекции я сказал, что мы хотим построить некоторое бинарное дерево поиска.
[10:58.520 --> 11:02.520]  Ну, построили нечто большее, да, то есть мы построили вроде бинарное дерево поиска и плюс там
[11:02.520 --> 11:07.680]  некоторую кучу. Да, то есть что, если мне хочется там только бинарное дерево поиска? Зачем мне, ну то есть
[11:07.680 --> 11:11.680]  откуда мне брать приоритеты? Зачем они мне нужны? Так вот, приоритеты на самом деле сейчас мне будут
[11:11.680 --> 11:16.720]  гарантировать, что у меня дерево в среднем будет хорошим. То есть приоритеты, они на самом деле
[11:16.720 --> 11:31.000]  будут балансировать мое дерево. Давайте докажем следующую теорему. Значит, откуда тут в зекартовом
[11:31.000 --> 11:55.040]  деле возьмется случайность? А вот отсюда. Значит, пусть у сгенерированы случайно и независимо
[11:55.040 --> 12:12.560]  друг от друга и иксов. Что это значит? Это значит, что мне приходит какой-то икс и я просто для каждого
[12:12.560 --> 12:17.640]  у подбрасываю монетку. Какое-то из значения, да, просто генеру абсолютно рандомное число, которое
[12:17.640 --> 12:21.280]  вообще никак не зависит от того, какие у меня до этого были иксы сгенерированы и вообще никак не
[12:21.280 --> 12:28.520]  зависит от того, какие у меня вообще есть иксы. То есть у абсолютно случайны, окей? Что тогда? Ну,
[12:28.520 --> 12:33.920]  давайте еще одно условие напишем, формально оно, наверное, тут нужно, что вероятность того, что y
[12:33.920 --> 12:46.200]  и равен y g, ну при и условии, что и не равны g должна быть равна нулю. Ну, просто чтобы не заморачиваться с
[12:46.200 --> 12:52.720]  одинаковыми приоритетами, скажем, что приоритеты сгенерированы случайно, они не равны друг другу. Так вот
[12:52.720 --> 13:11.040]  оказывается, что тогда средняя для любого икс, средняя глубина икса, вот что такое dx? Давайте поясним.
[13:11.040 --> 13:21.840]  Вот у меня где-то есть икс, и вот dx это вот, это вот расстояние от корня до этой самой вершины. Ну,
[13:21.840 --> 13:26.400]  то есть глубина, на которой находится икс, окей? Тогда средняя глубина для любой вершины икс,
[13:26.400 --> 13:32.960]  ее средняя глубина будет являться о большим, вот логарифма n. Ну, где n, естественно, это
[13:32.960 --> 13:43.120]  общее количество элементов в нашей структуре данных. Вот. Значит, прежде чем перейдем к доказательству,
[13:43.120 --> 13:50.240]  я хочу, чтобы все понимали, в чем состоит условие данной теоремы. Вопрос, верно ли,
[13:50.240 --> 13:54.520]  что эта теорема утверждает, что у вас средняя глубина дерева логарифмическая?
[13:54.520 --> 14:08.040]  Правда или нет? Можно ли на основании теоремы сделать вывод, что, там, если вы построите дерево
[14:08.040 --> 14:11.760]  со случайными приоритетами, то есть выберете эти приоритеты случайно, то у вас средняя
[14:11.760 --> 14:20.800]  глубина дерева всегда будет логарифмической. Ну, вообще говоря, неправда. И это важный момент. То
[14:20.880 --> 14:27.040]  есть эта теорема это не утверждает. То есть из этой теоремы не следует то, что если вы сгенирируете
[14:27.040 --> 14:31.640]  кучу деревьев и потом усредните все глубины этих деревьев, то есть максимальную глубину этих
[14:31.640 --> 14:36.760]  деревьев, то вы получите логарифм. Это неправда. Ну, почему? Давайте просто сгенирием кучу деревьев,
[14:36.760 --> 14:44.920]  то есть контрпример, да? Можно сгенить кучу деревьев и посмотреть, куда попадает x. То есть x может
[14:44.920 --> 14:51.480]  попасть сюда, сюда, сюда, ну и там какой-то один момент здесь. То есть средняя глубина x вроде
[14:51.480 --> 14:56.040]  как, средняя глубина x вроде нормальная, да? Но при этом у вас каждое дерево, в свою очередь,
[14:56.040 --> 15:04.240]  оно глубокое, да? Понятно? То есть x, то есть когда мы берем dx, мы берем глубину конкретного элемента.
[15:04.240 --> 15:11.680]  Когда мы считаем глубину дерева, мы должны здесь формально написать максимум среди всех x dx, да?
[15:11.680 --> 15:15.800]  То есть согласны, что это разные функции. Взять какой-то произвольный x и взять его среднее,
[15:15.800 --> 15:22.720]  или взять среднее среди максимумов. Естественно, среднее максимумов оно будет больше. Ну, забегая
[15:22.720 --> 15:26.480]  вперед, скажу, что на самом деле для глубины это верно. Вот, просто доказать чуть более сложное,
[15:26.480 --> 15:31.520]  и оно нам не понадобится, то есть нам будет достаточно вот этого утверждения. Так, давайте перейдем к
[15:31.520 --> 15:39.400]  доказательству. Блин, я забыл посмотреть, как вы в прошлом семестре доказывали быструю сортировку.
[15:39.400 --> 15:44.440]  Просто эту теорию можно доказать в одну строчку, просто сведя ее к быстрой сортировке. Вы доказывали,
[15:44.440 --> 15:47.680]  что средняя глубина рекурсии логарифмы или как-то по-другому?
[15:47.680 --> 16:01.000]  Ладно, все, я понял. Ладно, давайте докажем честно. Доказать следующее. Смотрите, доказывать будем так.
[16:01.000 --> 16:19.680]  Назовем узел, ну или корень под дерево. Каждый узел, ну, я надеюсь, вы понимаете,
[16:19.680 --> 16:23.320]  каждый узел является корнем некоторого под дерева. То есть вот этот узел является корнем вот этого под
[16:23.320 --> 16:50.120]  дерева и так далее. Назовем узел или корень под дерева хорошим, если размеры его под деревьев,
[16:50.120 --> 17:14.480]  отличаются не более чем в три раза. Ну, что это означает? Это означает, что вот у меня есть какой-то
[17:14.480 --> 17:19.040]  узел, вот тут есть одно под дерево и есть другое под деревом. Давайте скажем, что общее количество
[17:19.360 --> 17:27.520]  элементов здесь N. Так вот, узел вот это будем называть хорошим, если у вас здесь больше чем N на 4
[17:27.520 --> 17:36.080]  элемента и тут больше чем N на 4 элемента. Ну то есть у вас могут быть плохие разбиения, то есть у вас
[17:36.080 --> 17:42.800]  может быть плохое разбиение, что вот тут один узел, а тут целое огромное под дерево. Вот этот плохой узел,
[17:42.800 --> 17:49.400]  он не сильно хорошо разбил нам наши элементы. А вот если тут хотя бы N на 4 элементы, а тут 3 N
[17:49.400 --> 18:16.400]  на 4, то все нормально, окей? Вот, теперь вопрос вам. Пусть в под дереве N элементов с какой
[18:16.400 --> 18:41.080]  вероятностью корень хороший? Ну вот вы берете произвольное, вы смотрите на произвольное под
[18:41.080 --> 18:59.480]  дерево. Почему? Так, ответ был с вероятностью на второе, почему? Ну да, смотрите, вот давайте просто
[18:59.480 --> 19:10.640]  рассмотрим вот элементы под дерево. Ну вот пусть они упорядочены по возрастанию. Значит, какие элементы
[19:10.640 --> 19:16.440]  какие элементы в качестве корня меня устраивают? Как сделать так, чтобы у меня соотношение было хотя
[19:16.440 --> 19:27.880]  бы один к трем? То есть устраивает ли меня вот этот элемент? Ну нет, он какой-то плохой, да, он
[19:27.880 --> 19:32.320]  разобьет вот этот маленький кусок и все остальное. А какие элементы меня устраивают? Ну на самом деле
[19:32.320 --> 19:39.120]  меня устраивают элементы, которые расположены на расстоянии как раз таки N на 4 отсюда и N на 4 отсюда,
[19:39.120 --> 19:45.520]  согласны? То есть если я возьму любой элемент из середины размер N пополам, то то есть я беру
[19:45.520 --> 19:48.840]  допустим этот элемент, то у меня как раз таки получается так, что я беру вот эти элементы,
[19:48.840 --> 19:54.200]  то есть размер этого под дерево больше чем N на 4 и вот это под дерево, размер которого тоже больше
[19:54.200 --> 19:58.480]  чем N на 4. То есть меня устраивают только вот эти центральные элементы. А теперь вопрос, с какой
[19:58.480 --> 20:03.440]  вероятностью у меня корнем под дерево будет один из этих элементов? Сверять сюда вторая, почему?
[20:03.440 --> 20:09.640]  Ну ровно половина, ну а почему не может быть такого, что у меня вот эти элементы будут
[20:09.640 --> 20:20.080]  браться с большей вероятностью, чем эти? Ну потому что я приоритет генерирую случайно, да, то есть за
[20:20.080 --> 20:25.800]  корень дерева всегда отвечает только на имение приоритетный элемент. То есть определить то,
[20:25.800 --> 20:31.000]  является элемент корнем или нет, мы можем только исходя вот его приоритета. А так приоритетами
[20:31.000 --> 20:35.160]  генерируем случайно, то есть знать, что вообще произвольный элемент с равной вероятностью может
[20:35.160 --> 20:52.400]  стать корнем. Согласны? Давайте зафиксируем. Любой элемент может быть корнем с равной...
[20:52.400 --> 21:01.360]  Этот тезис понятен или пояснить еще раз? Так мы приоритет выбираем случайно, ну а за корень
[21:01.360 --> 21:05.960]  нас отвечает только приоритет, только приоритет у нас выбирает корень. Приоритет мы выбираем
[21:05.960 --> 21:10.000]  абсолютно случайно и независимо, поэтому абсолютно любой элемент с равной вероятостью может стать
[21:10.000 --> 21:25.480]  корнем. Из этого следует, что корень хороший с вероятностью... Давайте напишем примерно 1 вторая.
[21:25.480 --> 21:31.560]  Почему примерно? Потому что тут может нацело не разделиться и так далее, но на это забиваем.
[21:31.560 --> 21:42.640]  Давайте просто напишем 1 вторая. Вот, ну все. Значит вероятно все 1 вторая, у нас узел хороший.
[21:42.640 --> 21:51.080]  Ну а теперь давайте просто возьмем и посмотрим на глубину элемента х. Значит вот у меня есть
[21:51.080 --> 21:59.440]  какое-то дерево, в нем есть где-то элемент х. Чтобы добраться до х, мы должны проделать какой-то путь.
[21:59.440 --> 22:05.920]  Из чего состоит этот путь? Он состоит из хороших узлов и из плохих узлов, согласны?
[22:05.920 --> 22:16.000]  То есть это D плюс х плюс D минус х. Ну это вот хорошие, а это плохие.
[22:16.000 --> 22:37.320]  Вот. Что мы можем сказать про среднее значение хороших узлов? Вот на пути от корня до вершины х.
[22:37.320 --> 22:44.400]  Сколько в среднем у нас... Точнее не сколько, а вот что можно сказать про количество в среднем
[22:44.400 --> 22:52.720]  хороших узлов? Ну не то, что 1 вторая, а их примерно столько же, сколько и плохих. Согласны? То есть
[22:52.720 --> 22:58.680]  во-первых, можно сказать вот так. Ну потому что с вероятностью 1 вторая я встречаю хороший узел и
[22:58.680 --> 23:02.240]  с вероятностью 1 вторая я встречаю плохой узел. Поэтому на этом пути у меня примерно одинаково
[23:02.240 --> 23:08.240]  количество и хороших, и плохих узлов. Ну точнее в среднем строгое равенство. Вот. А что еще
[23:08.240 --> 23:17.880]  можем сказать? Можем ли мы как-то ограничить количество хороших узлов сверху? Вот. Может ли
[23:17.880 --> 23:22.560]  быть такое, что вот я иду от корня до х и у меня встречается прямо очень-очень много хороших
[23:22.560 --> 23:34.360]  узлов? То есть верно ли, что хорошего может быть много? К сожалению, нет. Почему? Ну их нет пополам,
[23:34.360 --> 23:37.960]  их гораздо меньше на самом деле. Ну смотрите, что происходит, когда я нахожусь, вот давайте я
[23:37.960 --> 23:43.640]  нахожусь в корне. Точнее давайте так. Вот я нахожусь в хорошем узле. Всего элементов у меня изначально
[23:43.640 --> 23:47.760]  n. Я попадаю вот из хорошего узла в какое-то поддерево. Что я могу сказать про его размер?
[23:47.760 --> 23:57.640]  Ну он точно меньше либо равен чем 3n на 4. Согласны? Так как размер у меня каждого поддерева больше
[23:57.640 --> 24:07.680]  равен чем n на 4, значит размер каждого поддерева меньше равен чем 3n на 4. Согласны? Хорошо. Дальше. Я
[24:07.680 --> 24:13.960]  где-то здесь снова встречаю хороший узел. Что можно сказать про размер поддерева, в который я попадаю?
[24:13.960 --> 24:22.680]  Да, но он снова уменьшается в четыре третьих раза. Согласны? То есть если я иду из хорошего
[24:22.720 --> 24:27.440]  узла в какое-то поддерево, то я размер моего дерева уменьшаю как минимум в четыре третьих
[24:27.440 --> 24:32.040]  раза. Согласны? А много ли я так могу раз сделать? Вот у меня есть число n. Могу ли я бесконечный
[24:32.040 --> 24:36.400]  количество раз его уменьшать в четыре третьих раза? Ну нет, в какой-то момент я паду в отдельную вершину.
[24:36.400 --> 24:44.240]  Да? То есть на самом деле количество хороших шагов сколько? Да, не более чем логарифм. Ну давайте
[24:44.240 --> 24:54.920]  напишем четыре третьих от n. Ну кажется все. Остался последний штрих. Как раз таки давайте
[24:54.920 --> 25:01.480]  посчитаем чему равен средняя длина пути от корня до х. Ну это просто равняется двум.
[25:01.480 --> 25:09.360]  D плюс от х. Понятно почему, да? Ну мы берем средние от этой, средние от этой штуки, но средние эти равны,
[25:09.360 --> 25:16.040]  поэтому просто вдваем эту штуку. А что можно сказать про средние от D плюс? Ну так как сам D плюс не
[25:16.040 --> 25:20.600]  больше чем логарифм, то и средние от D плюса тоже не больше чем логарифм. Да? Поэтому это очень не
[25:20.600 --> 25:43.400]  более чем логарифм n. Ну все, доказали. Вопросы? Все понятно. Ну и на самом деле,
[25:43.400 --> 25:48.160]  давайте замечания напишем.
[25:48.160 --> 26:15.520]  Верно и то,
[26:15.520 --> 26:43.320]  что средняя глубина декартового дерева вычисляется вот так. Есть и большое от логарифма n. Но доказательство
[26:43.320 --> 26:53.720]  чуть более сложное и в общем оно нам не надо. Ну то есть план использования декартового дерева на
[26:53.720 --> 26:59.480]  самом деле очень прост. Если вам нужно бинарное дерево поиска, то вы делаете следующую вещь. Ну вот
[26:59.480 --> 27:05.800]  у вас есть х, то есть вам х уже даны, и вы просто для каждого х случайно генерируете y. И дальше на
[27:05.800 --> 27:10.240]  основе этих пар x и y строите декартовое дерево. И декартовое дерево заодно как раз вам построит
[27:10.240 --> 27:18.000]  бинарное дерево поиска, которое ищет по иксам. Ну и осталось самое главное это разобраться как
[27:18.000 --> 27:21.640]  с этим декартом дерева работать. Как туда вставлять элементы, как оттуда удалять элементы и так далее.
[27:21.640 --> 27:27.640]  Ну в общем хорошая новость заключается в том, что строго говоря нам понадобится всего две операции,
[27:27.640 --> 27:35.040]  через которые мы выведем вообще все-все-все, что нам понадобится на сегодняшней лекции. И этих
[27:35.040 --> 28:01.440]  операций две. Операции merge и split. Про что сначала поговорим? Давайте про merge. Что делает эта
[28:01.440 --> 28:14.640]  операция? Значит merge принимает два декартовых дерева, ну или два корня декартовых дерева,
[28:14.640 --> 28:39.840]  таких что все ключи одного дерева строго меньше ключей второго. То есть она принимает два декартовых
[28:39.840 --> 29:00.360]  дерева и объединяет их в одно декартовое дерево. То есть у вас есть два декартовых дерева,
[29:00.360 --> 29:07.360]  одно второе. Известно, что все ключи здесь строго меньше, чем все ключи здесь, и вы можете к ним
[29:07.360 --> 29:14.920]  применить операцию merge и получить одно большое декартовое дерево. Давайте разбираться как это
[29:14.920 --> 29:31.720]  работает. С алгоритм простой и рекурсивный merge от t1 и t2. Ну давайте изобразим. Вот есть t1,
[29:31.720 --> 29:46.800]  есть t2, одно дерево, второе, одно, второе. Все ключи здесь, допустим, меньше, чем все ключи в t2.
[29:46.800 --> 29:52.280]  Так, вопрос вам. Ну то есть алгоритм я сказал рекурсивный. С чего мы начинаем любой рекурсивный
[29:52.280 --> 29:59.240]  алгоритм? Да, условия выхода из рекурсии. Значит давайте так. Вот самый простой вариант. Какие два
[29:59.240 --> 30:10.840]  дерева очень легко слить? Пустые, это слишком просто. Давайте что-нибудь посложнее. Что? Это сложно,
[30:10.840 --> 30:21.080]  давайте что-нибудь попроще. Два единичных, сложно. Давайте чуть-чуть усложним два пустых дерева. Одно
[30:21.080 --> 30:28.320]  пустое, отлично. Ну понимаете, что делать если у вас одно пустое дерево? Вернуть второе просто,
[30:28.320 --> 30:33.720]  в качестве ответа. Ну как слить пустое дерево с каким-то другим? Просто вернуть другое. Давайте этим
[30:33.720 --> 30:53.080]  займемся. Если t1 0, то просто return t2. Аналогично, если t2 0, то return t1. Все. Так, халява закончилась,
[30:53.080 --> 30:59.840]  теперь давайте что-то делать. Известно, что после этих двух ифов у нас два дерева не пустых. Что делать?
[30:59.840 --> 31:08.600]  Давайте просто возьмем и выберем корень. Что будет корнем общего дерева? Понятно, что это будет
[31:08.600 --> 31:15.680]  либо t1, либо вот этот элемент, либо вот этот элемент. А вот кто из них, как понять? Как понять,
[31:15.680 --> 31:22.400]  что будет корнем дерева? Нам достаточно всего лишь посмотреть на приоритеты. Нам не важно,
[31:22.400 --> 31:25.960]  каким там ключи, просто достаточно посмотреть на приоритеты. Какой приоритет меньше, тот и будет
[31:25.960 --> 31:44.480]  корнем. Давайте так и напишем. Значит, если t1 y меньше, чем t2 y, давайте изобразим. Вот есть t1,
[31:44.480 --> 31:50.240]  у него приоритет меньше, то есть он как бы выше находится. То есть картина какая-то вот такая.
[31:50.240 --> 32:02.160]  Т1, т2. То что нужно сделать? Ну, во-первых, мы понимаем, что t1 будет корнем дерева. Что будет
[32:02.160 --> 32:09.080]  слева вот этого корня? Что будет левым сыном этого дерева? Его левый сын. Верно ли, что вот эти
[32:09.080 --> 32:14.400]  элементы вообще не смогут попасть к нему влево? Ну, понятно, да. Потому что все эти элементы строго
[32:14.400 --> 32:19.760]  больше, чем t1, и вот эти элементы тоже по условию строго больше, чем t1. Поэтому половину дерева мы уже
[32:19.760 --> 32:29.120]  знаем. Согласны? А что делать с этими поддеревьями? Да, алгоритм-рекурсивный. Давайте просто наоборот
[32:29.120 --> 32:37.640]  возьмем и рекурсивно смерджим вот эти части и подвесим в качестве правого поддерева. Согласны?
[32:37.640 --> 32:47.880]  Ну, давайте так и сделаем. Напишем t1 right. То есть что подвесим в качестве правого поддерева t1?
[32:47.880 --> 33:02.200]  Просто результат мерджа от t1 right, то есть правое поддерево, смерджим с t2. Ну, давайте еще
[33:02.200 --> 33:13.920]  будем отдельно хранить родителей. Для каждого узла будем хранить родителей левого сына и
[33:13.920 --> 33:34.800]  правого сына. Это нам еще понадобится. Вот. И это равно t1. Вот. Ну, казалось бы, все. И просто return t1.
[33:34.800 --> 33:44.600]  Что мы сделали? Мы поняли, что корнем общего дерева будет вот этот вот узел t1. Вот. И что мы
[33:44.600 --> 33:48.200]  делаем? Ну, в качестве левого сына оставляем левого сына. В качестве правого сына просто делаем
[33:48.200 --> 33:53.680]  результат слияния его правого поддерева и t2. Все. В результате этого слияния нам мердж вернул
[33:53.680 --> 33:58.000]  какое-то поддерево, в котором все ключи строго больше, чем t1. Ну и, соответственно, это дерево мы
[33:58.000 --> 34:02.360]  можем уже подвесить в качестве правого сына t1. Ну, ровно это здесь мы и делаем. Да? Ну, и в
[34:02.360 --> 34:08.720]  качестве результировающего дерева, естественно, возвращаем t1. Потому что это корень. Так, ну и давайте,
[34:08.720 --> 34:20.440]  чтобы закрепить успех, симметричный случай рассмотрим. Что если у меня все-таки у дерева t2 меньше
[34:20.440 --> 34:38.680]  приоритет t2, чем у t1? Что в этом случае надо делать? Во-первых, вот с этой веткой ничего делать не надо.
[34:38.680 --> 34:44.680]  То есть мы знаем, что t2 будет корнем дерева, да? И его правым поддерем останется его правым поддерем.
[34:44.680 --> 34:53.000]  А что будет выступать у него в качестве левого поддерева? Результат слияния вот этих вот двух деревьев.
[34:53.000 --> 35:14.160]  Все. То есть t2 left равно merge от t1 и t2 left. У t2 left нужно обновить родителя,
[35:14.160 --> 35:32.080]  ровно t2. Ну и вернуть в качестве ответа t2. Вот и все. Вот и весь рекуртивный merge.
[35:32.080 --> 35:50.720]  Ну и в среднем он работает за логарифом по теореме или по замечанию. Ну почему за логарифом?
[35:50.720 --> 35:54.720]  Потому что на каждом шаге что мы делаем? На каждом шаге мы берем и уменьшаем глубину
[35:54.880 --> 36:00.880]  дерева на единицу. Согласны? Ну на единицу уменьшаем глубину одного из деревьев. Вот и все.
[36:00.880 --> 36:16.320]  Ну ладно, ставим. Так, с merge разобрались. Вопросы есть? Вроде нет. Ну и давайте разберемся с плитом.
[36:16.320 --> 36:43.120]  Уже всю работу почти сделаем. Так, что такое split? Split принимает дикартовое дерево t и ключ x.
[36:43.120 --> 37:12.880]  x0 давайте. Split принимает и разбивает t, разбивает дерево t на t1 и t2.
[37:13.120 --> 37:29.120]  Ну такие, что все ключи в t1 будут меньше x, а все ключи в t2 больше равны x.
[37:29.120 --> 37:37.120]  Ну то есть неформально split просто берет дерево и разрезает его по элементу x0.
[37:37.120 --> 37:45.120]  То есть мы берем и разрезаем просто по ключу x0 и получаем два дерева t1 и t2.
[37:45.120 --> 37:49.120]  Здесь все элементы меньше x, а тут все элементы больше равны x0.
[37:57.120 --> 37:59.120]  Вот реализация тоже и крутивная и простая.
[38:07.120 --> 38:21.120]  Так, split tx0. Так, алгоритм будет рекурсивный, условия выхода из рекурсии.
[38:21.120 --> 38:27.120]  Какое дерево проще всего разрубить? То дерево, которого нет. Отлично.
[38:27.120 --> 38:39.120]  Если t это null, то что мы должны вернуть? Пару из null и null.
[38:39.120 --> 38:45.120]  Ну, split у нас возвращает два дерева t1 и t2, поэтому возвращаем пару.
[38:45.120 --> 38:48.120]  Теперь давайте разбираться с тем, что делать.
[38:48.120 --> 39:00.120]  Значит, вот у меня есть какое-то дерево t, тут какой-то элемент x, и мне нужно разрубить его по ключу x0.
[39:00.120 --> 39:04.120]  Давайте сначала эти идеи обсудим, а мы на первый пойдем.
[39:04.120 --> 39:07.120]  Значит, смотрите, что делать? Что мне делать, если x0?
[39:07.120 --> 39:10.120]  Ну, получилось так, что x0 больше, чем x.
[39:10.120 --> 39:16.120]  Что если линия, так скажем, проруба, линия разделения должна происходить как-то вот так?
[39:19.120 --> 39:23.120]  Ну, не совсем.
[39:23.120 --> 39:26.120]  Что мне, если x находится здесь?
[39:26.120 --> 39:29.120]  Ну, разрубить я должен дерево как-то вот справа.
[39:29.120 --> 39:32.120]  То есть представьте себе дерево, я вот рулю вот так.
[39:38.120 --> 39:43.120]  Да, да, то есть смотрите, если у меня линия разруба проходит справа, то есть x0 больше, чем x,
[39:43.120 --> 39:47.120]  то я должен рекурсивно разрубить правое под дерево,
[39:47.120 --> 39:52.120]  а потом вот левый кусочек прикрепить сюда, а правый кусочек отпустить в свободное плавание.
[39:52.120 --> 39:53.120]  Согласны?
[39:53.120 --> 39:55.120]  Ну вот, по сути, и все.
[39:55.120 --> 39:59.120]  То есть это сейчас после перерыва мы напишем и, собственно, весь алгоритм.
[39:59.120 --> 40:01.120]  Операция сплит.
[40:01.120 --> 40:04.120]  Значит, как обсудили, алгоритм простой.
[40:04.120 --> 40:06.120]  Значит, как разрубить дерево?
[40:06.120 --> 40:09.120]  Ну, нужно разрубить либо правое под дерево, либо левое под дерево.
[40:09.120 --> 40:12.120]  Все, то есть рекурсивно.
[40:12.120 --> 40:14.120]  Давайте условия здесь...
[40:14.120 --> 40:19.120]  Значит, если в Merge мы там сравнивали приоритеты, то здесь теперь мы будем сравнивать ключи.
[40:19.120 --> 40:30.120]  То есть если tx меньше, чем x0, то есть если элемент, по которому нам нужно разрубить находится где-то справа,
[40:30.120 --> 40:33.120]  то что мы должны сделать?
[40:33.120 --> 40:46.120]  Мы должны, во-первых, разрубить правое под дерево, то есть split t right по x0.
[40:46.120 --> 40:48.120]  Вот что в итоге получим.
[40:48.120 --> 40:55.120]  Значит, когда мы разрубили правое под дерево, у нас получается следующая картина.
[40:55.120 --> 40:59.120]  Значит, есть какое-то левое под дерево, есть какое-то правое под дерево.
[40:59.120 --> 41:04.120]  При этом известно, что тут все элементы меньше, чем x0, тут все элементы больше, либо разные, чем x0.
[41:04.120 --> 41:08.120]  Ну, естественно, здесь тоже все элементы меньше, чем x0.
[41:08.120 --> 41:12.120]  Соответственно, что нужно сделать?
[41:12.120 --> 41:17.120]  Как собрать ответ? Как собрать t1 и t2?
[41:17.120 --> 41:21.120]  Ну, Merge слишком сильно, можно проще.
[41:21.120 --> 41:26.120]  Да, ну просто можно вот это вот дерево подвесить к t в исходном.
[41:26.120 --> 41:32.120]  Давайте так и сделаем. t right равно l.
[41:32.120 --> 41:44.120]  Ну и давайте так, если l не равно 0, то l parent равно t.
[41:44.120 --> 41:47.120]  Ну, просто так могло получиться, что l оказался пустым деревом,
[41:47.120 --> 41:52.120]  поэтому у него как бы некомильфо брать стрелочку, но тут мы это проверяем.
[41:52.120 --> 41:54.120]  Так, хорошо, подвесили l к t.
[41:54.120 --> 41:56.120]  То есть вот такую связь, вот такую связь.
[41:56.120 --> 42:01.120]  Так, ну у r, ну у r на самом деле мог остаться какой-то фантомный родитель,
[42:01.120 --> 42:03.120]  поэтому давайте просто-напросто пустим его в свободное плавание.
[42:03.120 --> 42:13.120]  То есть скажем, что если r не равен 0, то r parent равно 0.
[42:13.120 --> 42:15.120]  То есть у него нет родителя.
[42:15.120 --> 42:23.120]  Ну все, и дальше делаем return t и r.
[42:23.120 --> 42:30.120]  То есть отдельно возвращаем дерево t и дерево r.
[42:45.120 --> 42:52.120]  Ну и аналогично поступаем с левым под деревом, то есть иначе.
[42:52.120 --> 42:54.120]  Ну что значит в данном контексте иначе?
[42:54.120 --> 42:58.120]  Это означает, что у меня есть в корне x, тут какое-то правое под дерево,
[42:58.120 --> 43:05.120]  тут левое под дерево, и x0 на самом деле должен проходить где-то здесь.
[43:05.120 --> 43:06.120]  Ну что я в этом случае должен сделать?
[43:06.120 --> 43:09.120]  Я должен разрубить левое под дерево.
[43:09.120 --> 43:19.120]  То есть lr равно split t left по x0.
[43:19.120 --> 43:25.120]  Вот разрубил это под дерево на l и r.
[43:25.120 --> 43:32.120]  Ну и аналогично r подвешиваю к t, а l отпускаю, ну вот, пусть сам по себе живет.
[43:32.120 --> 43:38.120]  То есть t left равно r.
[43:38.120 --> 43:47.120]  Давайте напишем, если r, то r parent равно t.
[43:47.120 --> 43:55.120]  Если l, то l parent равно 0.
[43:55.120 --> 44:02.120]  Ну и в этом случае возвращаем пару из l и t.
[44:02.120 --> 44:05.120]  Здесь tr, там lt.
[44:05.120 --> 44:07.120]  Ну вот.
[44:16.120 --> 44:18.120]  Нет, если l.
[44:18.120 --> 44:24.120]  То есть если l не пуст, то у него есть родители, я могу присовывать ему 0.
[44:24.120 --> 44:28.120]  Если l 0, то я не могу стрелочку применить.
[44:36.120 --> 44:44.120]  Ну собственно вот, две основные операции merge и split.
[44:44.120 --> 44:49.120]  И в основном мы будем работать с ними.
[44:49.120 --> 44:54.120]  Ну прежде чем идти дальше, давайте собственно обсудим.
[44:54.120 --> 44:56.120]  Ну хорошо, есть операция split, есть операция merge.
[44:56.120 --> 44:58.120]  Причем тут вообще бинарные деревья поиска.
[44:58.120 --> 45:04.120]  То есть родители как бинарные деревья поиска нам обещают, что они умеют делать поиск, умеют делать ставку, умеют делать удаление.
[45:04.120 --> 45:06.120]  Причем тут merge и split.
[45:06.120 --> 45:08.120]  Ну про поиск я, думаю, говорить не буду.
[45:08.120 --> 45:10.120]  Как делать поиск в бинарных деревьях поиска, я думаю, все понимают.
[45:10.120 --> 45:13.120]  То есть там никаких новшеств нет.
[45:13.120 --> 45:16.120]  То есть просто идете от корня либо влево, либо вправо.
[45:16.120 --> 45:20.120]  Давайте обсудим, как делать insert и erase в адекартовом дереве.
[45:20.120 --> 45:25.120]  Значит, хорошая новость заключается в том, что insert и erase выражается полностью через split и merge.
[45:25.120 --> 45:28.120]  Давайте поговорим.
[45:28.120 --> 45:38.120]  Сразу insert, t, x.
[45:38.120 --> 45:44.120]  У меня есть дерево t, давайте здесь изобразим, есть какое-то дерево t,
[45:44.120 --> 45:48.120]  и я хочу в него вставить новый элемент x.
[45:48.120 --> 45:52.120]  Как бы мне это сделать?
[45:52.120 --> 45:56.120]  Как мне вставить элемент x внутрь дерева t?
[46:05.120 --> 46:07.120]  Так не получится, смотрите.
[46:07.120 --> 46:09.120]  Приложение было следующее.
[46:09.120 --> 46:14.120]  Взять дерево t, построить одно элементное дерево x и смержить их.
[46:14.120 --> 46:18.120]  Так не получится, потому что merge хочет, чтобы у него два дерева были...
[46:18.120 --> 46:21.120]  Круг говоря, одно дерево было строго меньше, чем второе.
[46:21.120 --> 46:25.120]  А вообще говоря, x может быть где-то посередине.
[46:25.120 --> 46:29.120]  Место x может быть где-то посередине.
[46:29.120 --> 46:31.120]  Давайте проведем хирургическую операцию.
[46:31.120 --> 46:36.120]  Сначала разрежем дерево t пополам, а потом и в середину вставим x.
[46:36.120 --> 46:39.120]  И потом их смержем.
[46:39.120 --> 46:41.120]  Естественно, предполагаем, что...
[46:41.120 --> 46:45.120]  Давайте отдельно напишем, что x не принадлежит t.
[46:45.120 --> 46:48.120]  То есть ключи у нас уникальны.
[46:48.120 --> 46:50.120]  То есть если у нас x не принадлежит t, то что мы можем сделать?
[46:50.120 --> 46:53.120]  Ну действительно, давайте разобьем его на левое и правое дерево.
[46:53.120 --> 46:56.120]  Давайте как-то разумных назовем.
[46:56.120 --> 47:07.120]  Давайте так t меньше x и t больше x равно split tx.
[47:07.120 --> 47:09.120]  Вот.
[47:09.120 --> 47:12.120]  Давайте сразу иллюстрировать.
[47:12.120 --> 47:18.120]  У меня есть t меньше x, у меня есть t больше x.
[47:18.120 --> 47:23.120]  Все, и теперь я могу взять x, ну действительно взять вершину x.
[47:23.120 --> 47:29.120]  Давайте еще один аргумент добавим, x и y.
[47:29.120 --> 47:33.120]  У меня все-таки дерево хранит пары, поэтому мы вставляем пару x и y.
[47:33.120 --> 47:35.120]  Ну то есть что я могу сделать?
[47:35.120 --> 47:37.120]  Я могу теперь смержусь x и t меньше x.
[47:37.120 --> 47:40.120]  И потом результат смержусь с t больше x.
[47:40.120 --> 47:45.120]  Все условия для смержа у меня выполняются.
[47:45.120 --> 47:49.120]  Давайте так и поступим.
[47:49.120 --> 47:51.120]  Давайте просто напишем так.
[47:51.120 --> 48:03.120]  return merge от t меньше x и x и y.
[48:03.120 --> 48:04.120]  Ну предполагается, что это узел.
[48:04.120 --> 48:08.120]  Я создал узел с x и y.
[48:08.120 --> 48:16.120]  Ну и потом результат этого мерджа снова смерживаю с t больше x.
[48:16.120 --> 48:21.120]  Ну то есть собираю обратно сначала, допустим, вот эти элементы.
[48:21.120 --> 48:27.120]  Получаю какое-то t меньше либо равно x.
[48:27.120 --> 48:33.120]  И потом мержу вот эти два дерева, получаю финальное дерево.
[48:33.120 --> 48:36.120]  Ну вот.
[48:36.120 --> 48:39.120]  Все ясно?
[48:39.120 --> 48:53.120]  Ну смотрите, зачем нужны это ограничения?
[48:53.120 --> 48:59.120]  Значит, если у меня x был в исходном дереве, то он бы разделил у меня на дерево меньше x.
[48:59.120 --> 49:01.120]  И дерево больше или равно x.
[49:01.120 --> 49:08.120]  И когда бы я мержил, это если я мержу x, то я получаю дерево меньше либо равно x.
[49:08.120 --> 49:10.120]  И после этого я должен мержить дерево,
[49:10.120 --> 49:11.120]  в котором все элементы меньше либо равно x,
[49:11.120 --> 49:15.120]  с элементом, в котором все элементы больше либо равно x.
[49:15.120 --> 49:17.120]  И вот если и там и там есть элементы,
[49:17.120 --> 49:18.120]  то вообще говоря ситуация для мерджа, она не выполняется.
[49:18.120 --> 49:21.120]  Мердж очень строгое неравенство.
[49:21.120 --> 49:27.120]  Ну то есть это можно починить, но я не хочу в этих деталях углубляться.
[49:27.120 --> 49:29.120]  В общем, это можно починить.
[49:29.120 --> 49:37.120]  что все элементы равные x должны уходить в правое под дерево и соответствующим образом изменить лип нам мердж и вставку.
[49:37.120 --> 49:47.120]  Нам достаточно сета, а не мульти-сета.
[49:47.120 --> 49:58.120]  Так, ну и удаление erase из дерева t нужно удалить элемент x.
[49:58.120 --> 50:05.120]  Ну вот снова есть у меня t. Вот тут, кстати, не важно есть у меня x за дереве или нет, тут алгоритм нормально сработает.
[50:05.120 --> 50:12.120]  Ну, представь себе, что у меня где-то есть в этом дереве x. Вот он где-то лежит в середине. Что нужно сделать?
[50:17.120 --> 50:30.120]  Давайте так, первый пункт. Предлагаю посплитить по x. Давайте посплитим по x, что мы в итоге получим.
[50:30.120 --> 50:36.120]  Получим дерево, в котором все элементы меньше x, получим элементы, в котором все элементы больше равные x.
[50:36.120 --> 50:55.120]  Так, что дальше? Что мержусь? x мы не извлекли. Что можно всплитить?
[50:55.120 --> 51:05.120]  Можно рекурсивно вызвать erase с права. А условия выхода из рекурсии?
[51:05.120 --> 51:17.120]  Нет, ну это понятно, что x обязательно будет, x где-то обязательно будет.
[51:17.120 --> 51:22.120]  Можно, но я хочу просто все выразить через split и merge. То есть так тоже можно.
[51:22.120 --> 51:27.120]  Ты об этом может в конце поговорим, но давайте это дерево тоже посплитим.
[51:27.120 --> 51:33.120]  Давайте просто применим к нему split от upper bound от x.
[51:33.120 --> 51:38.120]  А upper bound от x это первый элемент, который больше x.
[51:38.120 --> 51:42.120]  Давайте просто-напросто так сделаем, и что в итоге получим?
[51:42.120 --> 51:46.120]  Здесь получим все элементы, которые строго меньше, чем верхняя граница x.
[51:46.120 --> 51:51.120]  Но это ровно один элемент x. Так у нас все элементы уникальны.
[51:51.120 --> 51:57.120]  И получим дерево, в котором все элементы больше x.
[51:57.120 --> 52:07.120]  А потом просто смержем вот это дерево и вот это дерево. Идея понятна?
[52:07.120 --> 52:12.120]  Это дерево поиска.
[52:12.120 --> 52:17.120]  У вас задача в задании есть, как найти upper bound?
[52:17.120 --> 52:22.120]  Задайте этим вопросам.
[52:22.120 --> 52:27.120]  Ну upper bound естественно как и lower bound, как и любой элемент,
[52:27.120 --> 52:30.120]  ищется за алгоритмическое время в дереве поиска.
[52:30.120 --> 52:35.120]  И это мы делаем с помощью гранитопорядочных элементов.
[52:35.120 --> 52:38.120]  Что мы делаем сначала?
[52:38.120 --> 52:42.120]  Мы делим на дерево, в котором все элементы меньше x,
[52:42.120 --> 52:49.120]  все элементы, которые больше upper bound x, делаем это с помощью сплита дерева t по x.
[52:49.120 --> 52:54.120]  Дальше нам нужно из вот этого дерева извлечь x.
[52:54.120 --> 52:58.120]  У нас есть tx, t больше x.
[52:58.120 --> 53:04.120]  И это мы делаем с помощью сплита t и upper bound от x.
[53:04.120 --> 53:08.120]  Ну на самом деле, если у вас целые числа, вы вместо upper bound можете взять x плюс 1.
[53:08.120 --> 53:10.120]  Но если целое число.
[53:10.120 --> 53:13.120]  Тут я предполагаю, что у вас все-таки дерево произвольное,
[53:13.120 --> 53:16.120]  то есть оно хребет произвольные ключи, поэтому пишу так.
[53:16.120 --> 53:20.120]  То есть вы взяли вот это дерево, в котором все элементы больше равны x,
[53:20.120 --> 53:23.120]  и разбили его на элемент x, и все элементы больше равны x.
[53:23.120 --> 53:27.120]  Что делаем дальше? Дальше, собственно, можем сделать delete tx,
[53:27.120 --> 53:29.120]  то есть удалить этот узел,
[53:29.120 --> 53:37.120]  и в качестве ответа вернуть merge от дерева, в котором все элементы меньше x,
[53:37.120 --> 53:40.120]  и дерева, в котором все элементы больше x.
[53:40.120 --> 53:44.120]  t меньше x, t больше x.
[53:48.120 --> 53:49.120]  Ну вот.
[53:49.120 --> 53:51.120]  И merge и split у нас работают с средним залогарифом.
[53:51.120 --> 53:54.120]  Инсерт и рейс мы выразили через сплиты и мержи,
[53:54.120 --> 53:56.120]  соответственно, они тоже работают с средним залогарифом.
[53:56.120 --> 53:58.120]  Ну то есть, что такое инсерт?
[53:58.120 --> 54:02.120]  Инсерт это сплиты два мержа, и рейс это два сплита и мерж.
[54:04.120 --> 54:06.120]  Каждый сплит и мерж работает с средним залогарифом,
[54:06.120 --> 54:10.120]  поэтому и общая сложность с средним тоже логарифом.
[54:16.120 --> 54:18.120]  Все ясно?
[54:21.120 --> 54:25.120]  Так, ну и последний пункт, который касается такого чистого декартового дерева.
[54:25.120 --> 54:27.120]  Дальше перейдем к задачам RMQ, RSQ.
[54:27.120 --> 54:30.120]  И вообще при чем тут декартовое дерево и деревья поиска?
[54:30.120 --> 54:35.120]  Прежде чем перейти, давайте обсудим проблему построения.
[54:35.120 --> 54:38.120]  Последний пункт здесь.
[54:38.120 --> 54:40.120]  Ну вот.
[54:40.120 --> 54:42.120]  Ну вот.
[54:42.120 --> 54:44.120]  Ну вот.
[54:44.120 --> 54:46.120]  Ну вот.
[54:46.120 --> 54:48.120]  Ну вот.
[54:48.120 --> 54:50.120]  Ну вот.
[54:51.120 --> 54:56.120]  Построение декартового дерева.
[54:56.120 --> 54:58.120]  Значит, в чем проблема построения?
[54:58.120 --> 55:01.120]  Вот смотрите, допустим, вам изначально даны какие-то ключи.
[55:01.120 --> 55:05.120]  То есть вам даны какие-то ключи, вам даны возможно приоритеты.
[55:05.120 --> 55:09.120]  И вам нужно из этого набора пар ключ значения построить декартовое дерево.
[55:09.120 --> 55:12.120]  Ну, казалось бы, ну чего?
[55:12.120 --> 55:15.120]  Можно просто взять и...
[55:15.120 --> 55:19.120]  Там for x, y и a.
[55:19.120 --> 55:21.120]  Ну где a это там какой-то ваш массив.
[55:21.120 --> 55:23.120]  Мы просто делаем...
[55:23.120 --> 55:33.120]  То есть так t равно insert t, x, y.
[55:33.120 --> 55:36.120]  Ну, казалось бы, в чем проблема?
[55:36.120 --> 55:39.120]  А в чем тут может быть проблема?
[55:39.120 --> 55:45.120]  Отлично.
[55:45.120 --> 55:49.120]  Значит, в среднем...
[55:49.120 --> 55:53.120]  В среднем действительно работает zn log n.
[55:53.120 --> 55:57.120]  Ну, не то чтобы это само по себе плохо, но...
[55:57.120 --> 55:59.120]  В целом, наверное...
[55:59.120 --> 56:01.120]  Ну, наверное, неприятно.
[56:01.120 --> 56:04.120]  А проблема-то в чем?
[56:09.120 --> 56:25.120]  Ну, смотрите, мы сказали, что insert в среднем работает за алгорифом.
[56:25.120 --> 56:29.120]  А за сколько он работает в худшем случае?
[56:29.120 --> 56:33.120]  Да, вот в худшем случае нам вообще говоря...
[56:33.120 --> 56:36.120]  Ну, худший случай нам вообще говоря никто не гарантировал.
[56:36.120 --> 56:40.120]  Понятно, что в худшем случае insert может работать за линию.
[56:40.120 --> 56:44.120]  Ну, опять же, легко придумать пример, когда у вас, скажем,
[56:44.120 --> 56:46.120]  emergency split будут работать за линейное время.
[56:46.120 --> 56:49.120]  Ну, скажем, вы генерируете там приоритеты случайно,
[56:49.120 --> 56:56.120]  блабла и так далее, но при этом вы же не застрахованы от такой ситуации.
[56:56.120 --> 56:58.120]  Ну, вы поняли.
[56:58.120 --> 57:00.120]  То есть теоретически это...
[57:00.120 --> 57:02.120]  Ну, то есть на практике, естественно, наверное, это как бы маловероятно,
[57:02.120 --> 57:05.120]  но теоретически никто вам не гарантирует, что так будет.
[57:05.120 --> 57:08.120]  Вот, более того, если у вас там в контесте будет задача,
[57:08.120 --> 57:11.120]  в которой вам будут давать там свои пары ключ-значения,
[57:11.120 --> 57:14.120]  ой, свои пары ключ-приоритет, вот они те, которые будете генерировать вы,
[57:14.120 --> 57:17.120]  то такая ситуация возможна.
[57:17.120 --> 57:22.120]  Вот, поэтому данное построение в худшем случае, worst-case,
[57:22.120 --> 57:24.120]  работает за n квадрат.
[57:24.120 --> 57:27.120]  И вот это прям совсем плохо.
[57:27.120 --> 57:30.120]  Наверное, должен быть способ, который бы позволял из набора ключей
[57:30.120 --> 57:33.120]  и приоритетов построить дикартовое дерево, ну, как-то быстро, да,
[57:33.120 --> 57:35.120]  ну, скажем, за линейное время.
[57:35.120 --> 57:37.120]  И это действительно возможно.
[57:37.120 --> 57:40.120]  Давайте рассмотрим алгоритм построения дикартового дерева
[57:40.120 --> 57:42.120]  за линейное время.
[57:57.120 --> 58:00.120]  Значит, важный момент здесь заключается в том, что...
[58:03.120 --> 58:14.120]  что мы будем предполагать, что массив A, ну, массив пар,
[58:14.120 --> 58:21.120]  массив пар x, y отсортирован по x.
[58:28.120 --> 58:31.120]  Ну, если вот этот массив пар отсортирован по x,
[58:31.120 --> 58:33.120]  тогда можно построить за линейное время.
[58:33.120 --> 58:35.120]  Если он не отсортирован, то вы можете отсортировать
[58:35.120 --> 58:37.120]  за лагарив за n log n.
[58:37.120 --> 58:39.120]  Там любой сортировок, который гарантирует вам, собственно,
[58:39.120 --> 58:41.120]  сортировку за n log n, и дальше строить его за линейное время.
[58:41.120 --> 58:43.120]  То есть в любом случае вы n квадрат не получаете.
[58:43.120 --> 58:46.120]  Если массив отсортирован, то всё отлично,
[58:46.120 --> 58:48.120]  и если массив не отсортирован, то сначала его сортируете,
[58:48.120 --> 58:51.120]  а потом строите дикартового дерева.
[58:51.120 --> 58:58.120]  Так, как мы будем строить дикартового дерева?
[58:58.120 --> 59:03.120]  build от a.
[59:03.120 --> 59:06.120]  Будем делать следующую вещь.
[59:06.120 --> 59:17.120]  Во-первых, в качестве декартового дерева мы вернем корень этого самого дерева,
[59:17.120 --> 59:20.120]  и в любой момент времени мы будем поддерживать следующую величину,
[59:20.120 --> 59:23.120]  точнее следующий указатель.
[59:23.120 --> 59:28.120]  Последний вставленный элемент.
[59:28.120 --> 59:31.120]  Давайте обсудим идею.
[59:31.120 --> 59:37.120]  Обсудим идею, что вообще говоря будет делать наш алгоритм.
[59:37.120 --> 59:47.120]  Пусть уже какое-то декартовое дерево построено.
[59:47.120 --> 59:50.120]  Вот это какое-то декартовое дерево.
[59:50.120 --> 59:55.120]  Я буду просто последовательный тип элементов от меньшего к большему
[59:55.120 --> 59:59.120]  и вставлять элементы в это дерево.
[59:59.120 --> 01:00:07.120]  Из этой картинки, понятно ли вам какой элемент был вставлен последним?
[01:00:07.120 --> 01:00:11.120]  Если я иду от меньшего к большему и последовательно вставляю сначала минимальный элемент,
[01:00:11.120 --> 01:00:13.120]  потом следующий, следующий и так далее,
[01:00:13.120 --> 01:00:16.120]  какой элемент был вставлен последним?
[01:00:16.120 --> 01:00:23.120]  Да, самый правый, то есть вот этот. То есть вот этот элемент, это как раз-таки тот самый last-inserted.
[01:00:23.120 --> 01:00:28.120]  Указатель, на который я буду поддерживать. Ну, вот это корень root.
[01:00:28.120 --> 01:00:41.120]  Так, ко мне приходит новый друг, скажем, не знаю, давайте тут, просто last, и он находится где-то здесь.
[01:00:41.120 --> 01:00:43.120]  Приходит новый элемент, который нужно вставить.
[01:00:44.120 --> 01:00:50.120]  Соответственно, так как я обрабатываю все мои элементы в порядке взрастания, то этот элемент больше, чем все остальные.
[01:00:52.120 --> 01:00:54.120]  Что мне нужно с ним сделать?
[01:00:57.120 --> 01:01:01.120]  Как бы мне его вставить в дерево так, чтобы оно было как можно более просто?
[01:01:03.120 --> 01:01:11.120]  Понятно ли вам, ну давайте предположим, что у него приоритет находится на таком уровне, ну и по вертикали, точнее по ключу он больше всех остальных.
[01:01:11.120 --> 01:01:15.120]  Понятно ли вам, как нужно исправить дерево так, чтобы этот элемент встал на свое место?
[01:01:25.120 --> 01:01:37.120]  Ну, я предлагаю сделать такую вещь. Вот так и вот так. Как вам? Разумно?
[01:01:41.120 --> 01:01:46.120]  Этот элемент больше, чем корень, ну априори, да, и плюс этот элемент больше, чем все остальные вот эти элементы.
[01:01:46.120 --> 01:01:53.120]  Все, поэтому вот этот элемент я отправляю в правое под дерево вот этого элемента, а вот это все под дерево отправляю в левую часть.
[01:01:53.120 --> 01:01:59.120]  Ну и плюс, так как у него приоритет находится между вот этими элементами, то, соответственно, он тоже стоит на своем месте.
[01:01:59.120 --> 01:02:09.120]  Ну, вот план такой, я буду делать, соответственно, вот такую вещь.
[01:02:09.120 --> 01:02:17.120]  Давайте изобразим. То есть вот у меня есть последний добавленный элемент, и что мне нужно найти?
[01:02:17.120 --> 01:02:23.120]  Мне нужно просто найти то место, куда мне нужно вставить вот этот элемент.
[01:02:29.120 --> 01:02:40.120]  Давайте сделаем. То есть for x, y, a, то есть в цикле я перебираю все элементы в массиве a, и пишу следующую вещь.
[01:02:40.120 --> 01:02:59.120]  Значит, inserted.
[01:02:59.120 --> 01:03:07.120]  То есть я возьму самый правый элемент и просто буду подниматься все выше и выше, до тех пор, пока я не найду место, куда мне вставить этот элемент.
[01:03:07.120 --> 01:03:09.120]  Как мне определить, куда этот элемент должен встать?
[01:03:09.120 --> 01:03:19.120]  Ну, я просто должен проверить верно лишь, что cur y меньше, чем рассматриваемый y.
[01:03:19.120 --> 01:03:29.120]  Нет, наоборот.
[01:03:29.120 --> 01:03:36.120]  Вот так. То есть я нахожусь в этом элементе, и я понимаю, что приоритет вот этого элемента, он, в смысле, он должен вставить выше, чем этот элемент.
[01:03:36.120 --> 01:03:41.120]  Поэтому я должен подняться чуть выше. Ну и так далее я поднимаюсь, пока я не найду вот до этого элемента.
[01:03:41.120 --> 01:03:49.120]  Все, я дошел до этого элемента, и я понимаю, что приоритет, что это первая вершина, приоритет которой меньше, чем у этой вершины.
[01:03:49.120 --> 01:03:53.120]  Ну, соответственно, ее я должен подсоединить сюда, а это сюда.
[01:03:53.120 --> 01:04:02.120]  Поэтому пока у меня выполняется такое условие, то есть пока я не дошел до самого конца, то есть пока я не дошел там до абстрактного нуля,
[01:04:02.120 --> 01:04:13.120]  и пока у меня приоритет, приоритет новой вершины меньше, чем приоритет той вершины, которой я сейчас нахожусь, я поднимаюсь выше и выше.
[01:04:13.120 --> 01:04:22.120]  То есть я делаю cur равно cur стрелочка parent.
[01:04:22.120 --> 01:04:24.120]  Вот.
[01:04:29.120 --> 01:04:33.120]  Ну и дальше я должен проверить, что я должен проверить.
[01:04:33.120 --> 01:04:37.120]  Ну, вот это хороший случай, давайте его оставим на потолке, у меня может быть плохой случай.
[01:04:37.120 --> 01:04:44.120]  Я поднимался выше и выше, и так не нашел ни одного элемента, который бы приоритету был бы меньше, чем мой элемент.
[01:04:44.120 --> 01:04:48.120]  То есть, грубо говоря, мой элемент находится где-то вот здесь.
[01:04:48.120 --> 01:04:51.120]  Что это означает?
[01:04:51.120 --> 01:04:56.120]  Вот если приоритет вот этого элемента меньше, чем все приоритеты вот на этом пути.
[01:04:56.120 --> 01:05:09.120]  Да, ну во-первых, мой cur это nullptr, то есть если cur равно равно null, что я должен сделать в этом случае?
[01:05:09.120 --> 01:05:14.120]  Да, я должен вот этот элемент просто взять и сделать корнем.
[01:05:14.120 --> 01:05:18.120]  Давайте так и поступим.
[01:05:18.120 --> 01:05:35.120]  Ну, во-первых, я говорю x, y, left равно корень, да, то есть я добавляю вот такую вот связь.
[01:05:35.120 --> 01:05:49.120]  Ну, опять же, да, если есть корень, то я корню говорю, что у него родитель это новый элемент x, y.
[01:05:49.120 --> 01:05:59.120]  Ну и, собственно, сам x, y я должен сделать корнем, то есть root равен x, y.
[01:05:59.120 --> 01:06:01.120]  Вот.
[01:06:13.120 --> 01:06:16.120]  То есть еще раз, вот мне пришел новый элемент, я хочу понять, куда его вставить.
[01:06:16.120 --> 01:06:20.120]  Вот я поднимаюсь выше-выше, я понимаю, что я дошел до самого верха,
[01:06:20.120 --> 01:06:24.120]  и при этом все эти элементы имеют больше приоритет, чем вот этот элемент.
[01:06:24.120 --> 01:06:26.120]  То есть вот этот элемент должен стать в качестве корня.
[01:06:26.120 --> 01:06:28.120]  Ну и, соответственно, все, я делаю этот элемент корнем.
[01:06:28.120 --> 01:06:32.120]  Все эти элементы, все построенное дерево должно пойти в качестве левого сына.
[01:06:32.120 --> 01:06:36.120]  Вот. x, y, left равно root, то есть root это вот этот элемент.
[01:06:36.120 --> 01:06:41.120]  Вот. Если корень не нулевой, то я должен еще дополнительно добавить вот такую вот связь.
[01:06:41.120 --> 01:06:48.120]  Вот. Ну и просто-напросто перевесить указатель корня вот сюда.
[01:06:49.120 --> 01:06:52.120]  Ну давайте вот.
[01:06:55.120 --> 01:07:00.120]  То есть ситуация у меня вот такая. Понятно?
[01:07:00.120 --> 01:07:04.120]  Вот. Ну и теперь давайте вернемся к нормальной ситуации,
[01:07:04.120 --> 01:07:09.120]  то есть ситуации, когда у меня элемент все-таки должен стать куда-то вот сюда.
[01:07:09.120 --> 01:07:14.120]  То есть вот пришел новый элемент, вот.
[01:07:14.120 --> 01:07:17.120]  Это root. Вот.
[01:07:17.120 --> 01:07:22.120]  И я понимаю, что вот мой элемент должен лежать где-то в промежутке между этим элементом и этим элементом.
[01:07:22.120 --> 01:07:24.120]  Да?
[01:07:24.120 --> 01:07:27.120]  Ну а здесь мы, кажется, обсудили, что надо делать.
[01:07:30.120 --> 01:07:33.120]  Что нужно сделать?
[01:07:33.120 --> 01:07:38.120]  Нужно к этому элементу подвесить вот этот элемент.
[01:07:38.120 --> 01:07:42.120]  Ага, нет, не так. В другом порядке.
[01:07:42.120 --> 01:07:45.120]  Что вот этого не потерять.
[01:07:45.120 --> 01:07:51.120]  Давайте наоборот сделаем. Давайте сначала вот это поддерево подвесим к новому элементу.
[01:07:51.120 --> 01:07:53.120]  То есть понятно, да, почему они должны стоять слева?
[01:07:53.120 --> 01:07:55.120]  Во-первых, они все меньше, чем этот элемент.
[01:07:55.120 --> 01:07:59.120]  А во-вторых, этот элемент имеет больше приоритет, чем все вот эти остальные.
[01:07:59.120 --> 01:08:03.120]  Поэтому этот элемент теперь должен стать новым корнем для вот этого поддерева.
[01:08:03.120 --> 01:08:21.120]  То есть else я делаю x, y left равно cur right.
[01:08:21.120 --> 01:08:26.120]  То есть вот этот элемент, который я нашел, и его правое поддерево должно стоять слева.
[01:08:26.120 --> 01:08:32.120]  Ну и, как обычно, если правое дерево не нулевое, то есть если вот это дерево не нулевое,
[01:08:32.120 --> 01:08:42.120]  то это я у него еще должен обновить родителя parent равно x, y.
[01:08:42.120 --> 01:08:45.120]  Все, то есть я вот эту связь провязал.
[01:08:45.120 --> 01:08:49.120]  Ну и теперь осталось только добавить вот эту связь.
[01:08:49.120 --> 01:09:04.120]  Делать это так. Не root, а cur right равно x, y.
[01:09:04.120 --> 01:09:14.120]  Ну x, y parent равно cur.
[01:09:14.120 --> 01:09:22.120]  Ну и после вот этих двух условий, if else, что я должен в конце сделать?
[01:09:22.120 --> 01:09:31.120]  Обновить last inserted равно x, y.
[01:09:31.120 --> 01:09:39.120]  После того, как у меня цикл while завершится, я должен в конце просто сделать return root.
[01:09:39.120 --> 01:09:41.120]  Вот такой алгоритм.
[01:09:41.120 --> 01:09:50.120]  Ну давайте пример какую-нибудь приведем, чтобы стало понятно, что происходит.
[01:09:50.120 --> 01:09:53.120]  Давайте какие-нибудь пары вставим.
[01:09:53.120 --> 01:10:05.120]  1, 2, 3, 4, 5, 6. Ну и какие-нибудь приоритеты.
[01:10:05.120 --> 01:10:18.120]  5, 4, 6, 3, 7, 2.
[01:10:18.120 --> 01:10:23.120]  Ну попробуем вставить вот эти элементы.
[01:10:23.120 --> 01:10:25.120]  Так, ну рассмотрим первый элемент.
[01:10:25.120 --> 01:10:34.120]  Это 1, 5. То есть у нас root это 0.
[01:10:34.120 --> 01:10:37.120]  То есть root указывает никуда, last указывает никуда.
[01:10:37.120 --> 01:10:40.120]  Соответственно, мне подниматься некуда, то есть тут везде у меня 0.
[01:10:40.120 --> 01:10:43.120]  Соответственно, я попадаю в ветку, когда у меня текущий элемент равен 0.
[01:10:43.120 --> 01:10:45.120]  Соответственно, что я должен сказать?
[01:10:45.120 --> 01:10:54.120]  Я должен сказать, что я создаю вершину 1, 5.
[01:10:54.120 --> 01:10:56.120]  Я говорю, что ее левый ребенок это root.
[01:10:56.120 --> 01:10:59.120]  То есть левый ребенок это 0, поэтому ничего не делаем.
[01:10:59.120 --> 01:11:02.120]  Если root, то есть корня пока нет, поэтому пропускаем.
[01:11:02.120 --> 01:11:06.120]  И говорим, что новый корень, теперь вот этот новый элемент x, y.
[01:11:06.120 --> 01:11:08.120]  root указывает вот сюда.
[01:11:08.120 --> 01:11:11.120]  Ну и соответственно, последний вставленный элемент это тоже этот элемент.
[01:11:11.120 --> 01:11:16.120]  Окей, идем дальше. Следующий элемент это 2, 4.
[01:11:16.120 --> 01:11:20.120]  Начинаем с последнего вставленного элемента и поднимаемся наверх.
[01:11:20.120 --> 01:11:27.120]  Значит, смотрим на этот элемент и спрашиваем, верно ли, что приоритет у этой вершины меньше, чем приоритет у этой вершины.
[01:11:27.120 --> 01:11:32.120]  То есть вот элемент 2, 4.
[01:11:32.120 --> 01:11:34.120]  То есть верно ли, что ее приоритет меньше, чем приоритет этой вершины?
[01:11:34.120 --> 01:11:36.120]  Да, верно.
[01:11:36.120 --> 01:11:40.120]  Поэтому мы поднимаемся выше.
[01:11:40.120 --> 01:11:45.120]  Из этой вершины мы поднимаемся наверх, подниматься некуда, поэтому мы падаем в 0.
[01:11:45.120 --> 01:11:50.120]  Все, как только мы падаем в 0, мы завершаем работу над пол awak hari, и снова попадаем в эту ветку.
[01:11:50.120 --> 01:11:52.120]  Т.е. вершина, которую мы нашли, это 0.
[01:11:52.120 --> 01:11:53.120]  Ну, это никакая вершина.
[01:11:53.120 --> 01:11:55.120]  Поэтому начинаем работать здесь.
[01:11:55.120 --> 01:11:57.120]  То есть, что мы должны сказать?
[01:11:57.120 --> 01:11:59.120]  Мы должны сказать, что левым сыном новую вершину должен стать корень.
[01:11:59.120 --> 01:12:04.120]  Корень сейчас у нас 15, поэтому добавляем вот такую связь.
[01:12:04.120 --> 01:12:12.120]  Дальше у корня провязываем родителя, и дальше говорим, что новый корень – это новая вершина.
[01:12:12.120 --> 01:12:16.120]  Заменяем корень, вставляем сюда.
[01:12:16.120 --> 01:12:20.120]  Ну и в самом конце говорим, что последняя вставленная вершина – это та вершина, которую мы вставили.
[01:12:20.120 --> 01:12:23.120]  Пока понятно, да?
[01:12:23.120 --> 01:12:26.120]  Идем дальше.
[01:12:26.120 --> 01:12:30.120]  Вершина 3,6.
[01:12:30.120 --> 01:12:34.120]  Давайте что-нибудь интересное попробуем придумать.
[01:12:34.120 --> 01:12:37.120]  3,6 станет туда.
[01:12:37.120 --> 01:12:41.120]  Давайте так. Давайте тут сделаем 4,8.
[01:12:41.120 --> 01:12:44.120]  Будет 4,6,8.
[01:12:44.120 --> 01:12:47.120]  Тут будет 5.
[01:12:47.120 --> 01:12:51.120]  Давайте так сделаем, чтобы пример интересный получился.
[01:12:51.120 --> 01:12:53.120]  Дальше вставляем элемент 3,6.
[01:12:53.120 --> 01:12:57.120]  Что делаем? Мы стартуем отсюда, то есть вот эта текущая вершина.
[01:12:57.120 --> 01:13:01.120]  И вершина 3,6 должна встать вот здесь.
[01:13:02.120 --> 01:13:06.120]  Стравим мы приоритет этой вершины и приоритет этой вершины.
[01:13:06.120 --> 01:13:09.120]  Что мы видим? Верно ли что приоритет этой вершины меньше, чем приоритет текущей вершины?
[01:13:09.120 --> 01:13:11.120]  Нет. Не верно.
[01:13:11.120 --> 01:13:12.780]  Поэтому цикл заканчиваем. workout.com pops'ourstands
[01:13:12.780 --> 01:13:15.120]  Мы становились вот в этой вершине.
[01:13:15.120 --> 01:13:19.120]  Верно ли что эта вершина 0? Нет, не верно, поэтому мы идем вот по этой ветке.
[01:13:19.120 --> 01:13:22.120]  То есть эта вершина 0, поэтому мы должны что сделать?
[01:13:22.120 --> 01:13:26.120]  Мы должны сказать, что в качестве левого сына подвешиваем,
[01:13:26.120 --> 01:13:29.200]  подвешиваем правого сына иную эту вершину, но
[01:13:29.200 --> 01:13:32.040]  у него ничего нет, оставляем как есть.
[01:13:32.040 --> 01:13:33.840]  Следующий оBooks как раз нужно 38 в ooh,
[01:13:33.840 --> 01:13:39.520]  его пр quintake 1976 lk AND 우
[01:13:40.080 --> 01:13:42.080]  В качестве правой вершины это такой штука,
[01:13:42.080 --> 01:13:43.400]  чтобы стать новый элемент,
[01:13:43.400 --> 01:13:45.400]  соответственно добавляем такую связь.
[01:13:45.400 --> 01:13:47.400]  Ну иày Stanley тоже добавляем.
[01:13:47.400 --> 01:13:49.400]  Все, корень не изменился
[01:13:49.400 --> 01:13:51.400]  последний вставленный элемент,
[01:13:51.400 --> 01:13:53.400]  это вот этот элемент.
[01:13:53.400 --> 01:13:54.400]  Вот.
[01:13:54.400 --> 01:14:00.800]  Ну, давайте один шаг пропустим, то есть 4,8 на самом деле станет точно так же,
[01:14:00.800 --> 01:14:06.000]  то есть будет вот так. Ну и последний вставленный 4,8. Давайте перейдем вот сюда,
[01:14:06.000 --> 01:14:11.680]  вот тут интересный момент, значит 5,5. Что мы делаем? Значит, вот в этом цикле,
[01:14:11.680 --> 01:14:15.840]  мы ищем первый элемент, у которого приоритет меньше, чем у
[01:14:15.840 --> 01:14:20.720]  вставляемого элемента. То есть 5,5, он должен встать где-то вот здесь.
[01:14:20.720 --> 01:14:26.040]  Начинаем 4,8, поднимаемся наверх, поднимаемся наверх, вот снова эта вершина.
[01:14:26.040 --> 01:14:30.600]  Это вершина, это первая вершина вот на этом пути, у которой приоритет меньше, чем
[01:14:30.600 --> 01:14:37.560]  5,5. Поэтому в качестве кучи вершин и берем эту вершину. Что мы делаем? Во-первых, мы
[01:14:37.560 --> 01:14:42.480]  говорим, что в качестве левого поддерева у новой вершины вот этой, в качестве левого
[01:14:42.480 --> 01:14:46.420]  поддерева, должно выступать правое поддерево вот этой вершины. То есть мы должны
[01:14:46.420 --> 01:14:55.420]  мы можем взять все вот этого поддерево и пристанить его слева вот сюда.
[01:14:55.420 --> 01:15:00.420]  Ну а далее, в качестве правого сына, вот для этой вершины, которую мы нашли,
[01:15:00.420 --> 01:15:08.420]  делаем новую вершину.
[01:15:08.420 --> 01:15:17.420]  Ну, предполагаем, что нет. Ну, формально могут, но давайте предполагать, что нет.
[01:15:17.420 --> 01:15:26.420]  Ну, тут ни на что это не повлияло. Ну, давайте, не знаю, пять половин. Нормально?
[01:15:26.420 --> 01:15:31.420]  Ну, на практике, как генерировать приоритеты? Вы просто генерируете приоритеты из какого-то большого множества.
[01:15:31.420 --> 01:15:34.420]  И там вероятность того, что какие-то приоритеты случайно совпадут, она очень маленькая.
[01:15:34.420 --> 01:15:40.420]  Поэтому этого достаточно. То есть, на самом деле, равные приоритеты, они ничего почти не портят, поэтому можно забить.
[01:15:40.420 --> 01:15:48.420]  Ну, давайте, ладно. Пусть так. Ну и теперь мы вставляем 6,2. Ну, в качестве 6,2 мы должны...
[01:15:48.420 --> 01:15:53.420]  То есть, что мы делаем? У нас root не изменился, последний вставленный элемент – это вот этот элемент.
[01:15:53.420 --> 01:15:57.420]  Когда мы будем вставлять 6,2, что мы будем делать? Мы будем подниматься наверх, отсюда поднимемся наверх,
[01:15:57.420 --> 01:16:02.420]  отсюда поднимемся наверх. То есть, мы не найдем ни одной вершины, у которой приоритет был бы меньше,
[01:16:02.420 --> 01:16:10.420]  у которой приоритет был бы меньше. Поэтому мы вставляем сюда 6,2, ну и действуем согласно этой ветке.
[01:16:10.420 --> 01:16:16.420]  То есть, мы не нашли ни одной вершины, qr. qr – это вершина, у которой приоритет меньше, чем у вставляемой вершины.
[01:16:16.420 --> 01:16:20.420]  Мы не нашли ни одной вершины, у которой приоритет был бы меньше, поэтому мы 6,2 делаем корнем.
[01:16:20.420 --> 01:16:28.420]  То есть, на самом деле делается просто вот так. Вот так и сюда root.
[01:16:28.420 --> 01:16:39.420]  Все. Вот таким образом мы построили дикартовое дерево.
[01:16:39.420 --> 01:16:46.420]  Ну и главный вопрос – почему, вообще говоря, это работает за линейное время?
[01:16:46.420 --> 01:16:54.420]  Ну смотрите, вот в этом алгоритме есть один цикл, и внутри этого цикла есть аж целый цикл здесь.
[01:16:54.420 --> 01:16:59.420]  То есть, если у вас есть цикл внутри цикла, при этом, причем вот этот цикл – это линейный цикл,
[01:16:59.420 --> 01:17:02.420]  а вот этот цикл – это, вообще говоря, теоретически тоже линейный цикл.
[01:17:02.420 --> 01:17:10.420]  Ну почему? Потому что у вас может быть такая ситуация, что у вас могла возникнуть вот такая цепочка,
[01:17:10.420 --> 01:17:17.420]  ну то есть не совсем цепочка, но вот такая картина.
[01:17:17.420 --> 01:17:22.420]  И, в принципе, когда вы оставляете новый элемент, ну, допустим, вот этот,
[01:17:22.420 --> 01:17:27.420]  в принципе, вы должны пройти достаточно большой путь, чтобы добраться до нужного места.
[01:17:27.420 --> 01:17:31.420]  То есть, в принципе, как вот этот цикл может быть большим, ну так и этот цикл, он априори большой,
[01:17:31.420 --> 01:17:33.420]  потому что он занимает линейное время.
[01:17:33.420 --> 01:17:38.420]  А почему суммарно это все занимает линейное время? Понимаете вы или нет?
[01:17:38.420 --> 01:17:42.420]  То есть почему, несмотря на то, что у меня вот такие вот пути могут быть большими,
[01:17:42.420 --> 01:17:47.420]  то есть несмотря на то, что у меня file в принципе может работать долго, почему суммарно это линейное время?
[01:17:47.420 --> 01:18:15.420]  А почему я еще раз не буду проходить по этому пути?
[01:18:15.420 --> 01:18:25.420]  Что мне мешает?
[01:18:25.420 --> 01:18:32.420]  То есть тезис-то правильный, вопрос, почему это так?
[01:18:32.420 --> 01:18:39.420]  Что произойдет с этими вершинами, когда я буду вставлять вот этот элемент вот сюда?
[01:18:39.420 --> 01:18:41.420]  Ну не совсем.
[01:18:41.420 --> 01:18:45.420]  Ну то есть у меня, то есть в чем проблема? У меня теоретически может быть длинный правый путь,
[01:18:45.420 --> 01:18:49.420]  то есть путь, который вот идет строго по правым элементам.
[01:18:49.420 --> 01:18:53.420]  И вот утверждение это состоит в следующем, что вот если я по этим элементам,
[01:18:53.420 --> 01:18:59.420]  по этому правому пути как-то поднялся наверх, то вот по этим элементам я уже никогда не пройду.
[01:18:59.420 --> 01:19:03.420]  Да, именно, потому что что происходит, когда я вставляю новый элемент?
[01:19:03.420 --> 01:19:10.420]  Я делаю вот так и вот так. Все, все эти элементы у меня ушли в левое поддерево нового вершины.
[01:19:10.420 --> 01:19:14.420]  Все, вправо они никогда не вернутся. Все, мы их как бы замели.
[01:19:14.420 --> 01:19:20.420]  Все, теперь у меня новый правый путь, это вот такой путь. Согласны?
[01:19:21.420 --> 01:19:29.420]  То есть почему вот это?
[01:19:29.420 --> 01:19:40.420]  Значит, на каждой икарации for,
[01:19:40.420 --> 01:19:48.420]  давайте так, правый путь, ну или правая цепочка, ну давайте правый путь.
[01:19:48.420 --> 01:19:53.420]  Ну под правым путем я понимаю вот этот путь, да?
[01:19:53.420 --> 01:19:56.420]  От последнего вставленного до там самого корня.
[01:19:56.420 --> 01:20:02.420]  Правый путь увеличивается на один. Ну почему на один?
[01:20:02.420 --> 01:20:05.420]  Ну потому что за счет вставляемого элемента, да?
[01:20:05.420 --> 01:20:08.420]  То есть если я вставляю элемент, то он обязательно идет вправо,
[01:20:08.420 --> 01:20:11.420]  то путь как-то увеличится на один.
[01:20:11.420 --> 01:20:27.420]  За счет вставляемого элемента.
[01:20:27.420 --> 01:20:37.420]  Вот. Но цикл while, что делает while?
[01:20:38.420 --> 01:20:43.420] 後 это stolчевое ваше disproportionate.
[01:20:43.420 --> 01:20:47.420]  То есть кор behaviors надо jaws.
[01:20:47.420 --> 01:20:51.420]  То есть у меня правый путь, он увеличивается за счет новых элементов.
[01:20:51.420 --> 01:20:53.420]  То есть я вставляю все новые и новые элементы.
[01:20:53.420 --> 01:20:57.420]  Но при этом этот же самый путь в какие-то моменты уменьшается.
[01:20:57.420 --> 01:21:00.420]  А за счет чего он уменьшается?
[01:21:00.420 --> 01:21:02.420]  То есть как мы обсудили, это за счет цикла while,
[01:21:02.420 --> 01:21:05.940]  путь на одну вершину здесь, но при этом уменьшил на целую группу вершин здесь,
[01:21:05.940 --> 01:21:19.940]  окей? Поэтому, ну а цикл while уменьшает его на, ну давайте напишем ki, ну ki это вот
[01:21:19.940 --> 01:21:27.820]  общее количество итераций циклов while. Давайте тут еще пояснее напишем, так как все
[01:21:27.820 --> 01:21:55.780]  пройденные вершины уйдут в левое под дерево новой вершины. Ну а теперь смотрите, что у меня
[01:21:55.780 --> 01:22:05.220]  происходит. У меня размер, у меня длина правого пути за 1, ну за одну итерацию цикла for может
[01:22:05.220 --> 01:22:16.660]  максимум увеличиться на 1 и уменьшится на ki. Вот чума равна сумму вообще всех уменьшений, ну не
[01:22:16.660 --> 01:22:24.100]  более чем n. Согласны ли вы, что вот количество уменьшений не может быть больше чем n, ну потому
[01:22:24.100 --> 01:22:28.700]  что у меня всего элементов n, то есть я не могу этот путь уменьшать бесконечно. То есть так у меня
[01:22:28.700 --> 01:22:33.340]  суммарно всего элементов n, то я уменьшать этот путь буду максимум n раз, то есть общее количество
[01:22:33.340 --> 01:22:53.740]  итераций цикла while не больше чем n. Ну вот, ну все, из этого следует o от n, то есть общее число итераций
[01:22:53.740 --> 01:23:03.580]  цикла while не более чем n. Ну и соответственно, общее число итераций цикла while у меня не больше чем n, здесь
[01:23:03.580 --> 01:23:11.540]  я выполняю какую-то работу за 1, ну и вот сумма, ну и сам цикл for занимает линейное время. Все. Поэтому
[01:23:11.540 --> 01:23:18.700]  получается, что алгоритм работает за o от n. Да, но напомню, что при предположении, что у меня массив
[01:23:18.700 --> 01:23:29.620]  отсортирован по иксам. Так, значит, теперь давайте, наконец, перейдем к решению задачи RMQ-RSQ и
[01:23:29.620 --> 01:23:44.260]  попробуем понять, причем тут вообще бинарные деревья поиска. Значит, сформулируем задачу следующим
[01:23:44.260 --> 01:23:57.100]  образом. Представьте себе, что у вас есть некоторый ассоциативный массив. Давайте пункт назовем
[01:23:57.100 --> 01:24:18.180]  RSQ. Вот так. Значит, пусть у нас есть ассоциативный массив.
[01:24:18.180 --> 01:24:31.740]  Ну или в народе MAP. То есть вам просто дана некоторая структура данных, которая осуществляет
[01:24:31.740 --> 01:24:41.020]  отображение ключей и значения. То есть, грубо говоря, у вас есть ключи, есть ключи, есть значения.
[01:24:41.020 --> 01:24:49.420]  Вот. Значит, до этого мы формулировали задачи поиска минимума, максимума, суммы и тому подобное на
[01:24:49.420 --> 01:24:54.100]  обычных массивах. То есть у нас есть обычный массив, ноль индексации, и мы, соответственно,
[01:24:54.100 --> 01:24:59.660]  на определенных отрезках пытаемся найти результат некоторой операции. Теперь мы сформулируем
[01:24:59.660 --> 01:25:05.940]  ту же самую задачу, но в терминах ассоциативного массива. Пусть данный ассоциативный массив
[01:25:05.940 --> 01:25:29.340]  необходимо отвечать на запросы вида кьюри, ну все те же самые LR. Но уже этот запрос выглядит следующим
[01:25:29.340 --> 01:25:38.020]  образом. Нам нужно найти результат некоторой ассоциативной операции на следующем интервале.
[01:25:38.020 --> 01:25:51.340]  K меньше R, а вот K. Ну это просто там некоторый знак суммирования, да, то есть некоторые операции.
[01:25:51.340 --> 01:25:56.820]  Найти минимум, найти максимум, найти сумму, что угодно. Вот. То есть чьем отличие? Раньше у нас
[01:25:56.820 --> 01:26:02.980]  были обычные индексы, да, то есть если нам нужно было найти сумму на отрезке от 2 до 4,
[01:26:02.980 --> 01:26:07.140]  то мы брали элементы 2, 3, 4 и считали там сумму. Здесь у нас другая ситуация. Здесь мы не
[01:26:07.140 --> 01:26:10.660]  привязываемся конкретно к числовым индексам. Здесь, вообще говоря, мы говорим, что у нас ключ
[01:26:10.660 --> 01:26:14.220]  может быть произвольным, то есть, например, строки, да, то есть у вас могут быть там, не знаю, какое
[01:26:14.220 --> 01:26:19.700]  отображение, там, не знаю, имена и там возраст. Вот вы можете выбрать там все ключи, которые
[01:26:19.700 --> 01:26:23.500]  вытворяют там, не знаю, у всех ВАС, нужно посчитать средний возраст, да, или у всех ВАС
[01:26:23.500 --> 01:26:27.940]  нужно посчитать максимальный возраст. То есть вот вы берете там определенный промежуток и
[01:26:27.940 --> 01:26:34.220]  выполняете на нем некоторую операцию. Задача понятна? То есть ключ
[01:26:34.220 --> 01:26:47.260]  произвольным. Как можно решить эту задачу? Ну, тут нам очень сильно помогут бинарные
[01:26:47.260 --> 01:27:03.220]  деревья поиска. Давайте делаем следующую вещь. Давайте для начала нарисуем какой-нибудь бинарное
[01:27:03.220 --> 01:27:06.740]  дерево поиска, ну, точнее, нарисуем какой-нибудь ассоциативный массив, который представляется в
[01:27:06.740 --> 01:27:20.380]  виде бинарного дерева поиска. Ну, например, как-то вот так. Ну, изобразим тут какие-то
[01:27:20.380 --> 01:27:32.940]  значения. Давайте тут один, три, четыре, пять, семь, восемь, десять, двенадцать, двадцать. Это ключи.
[01:27:32.940 --> 01:27:43.220]  Вот, то есть, заметьте, что, ну, да, тут ключи числовые, но при этом они все идут не подряд, да, то есть
[01:27:43.220 --> 01:27:51.620]  тут нет ноль, тут нет нуля, тут нет двойки и так далее. Ну, и напишем там некоторые значения. Не знаю, пять, семь,
[01:27:51.620 --> 01:28:05.300]  минус три, два, шесть, десять, один, ноль, пять. Ну, давайте какую-нибудь операцию придумаем. Какую операцию
[01:28:05.300 --> 01:28:14.420]  будем использовать? Минимум, максимум, сумму, что хотите. Давайте минимум, ладно. А в общем, идея такая,
[01:28:14.420 --> 01:28:25.540]  то есть, необходимо уметь отвечать на запросы вида, не знаю, там найти минимум на полуинтервале от пяти до,
[01:28:25.540 --> 01:28:33.580]  не знаю, десяти. Вот, что я делаю? Я ищу ключи, которые удовлетворяют этому критерию, да, то есть,
[01:28:33.580 --> 01:28:40.700]  это элемент вот этот, этот, этот. Десятку не включаем, то есть, соответственно, вот в данном конкретном примере,
[01:28:40.700 --> 01:28:45.820]  в этом астративном массиве у меня три ключа удовлетворяют этому условию, да, то есть, они лежат в пределах от пяти до
[01:28:45.820 --> 01:28:50.860]  десяти невключительно, вот. Ну, и, соответственно, среди этих элементов я должен найти минимум, в данном случае
[01:28:50.860 --> 01:29:07.420]  ответ два. Задача понятна, да. Как мы ее будем решать? Значит, идея такая, идея. Будем в каждом узле, значит, идея очень
[01:29:07.420 --> 01:29:12.540]  похожа на идею деревоотресков. То есть, если деревоотреска, ну, деревоотреска, по сути, тоже дерево, тоже
[01:29:12.540 --> 01:29:17.060]  бинарное дерево, ну, то есть, ну, там все значения хранились, ну, в последнем уровне, да, то есть, в
[01:29:17.060 --> 01:29:22.340]  листовых вершинах. А здесь у нас бинарное дерево поиска и сами значения у нас хранятся непосредственно в узлах.
[01:29:22.340 --> 01:29:27.700]  То есть, если в декартом, то есть, если в деревеотресках у нас вот во внутренних узлах хранились только
[01:29:27.700 --> 01:29:34.820]  результаты, то здесь у нас во внутренних узлах, вообще говоря, хранятся и сами значения. Но ровно как и в деревеотресках,
[01:29:34.820 --> 01:29:40.780]  давайте в каждом узле хранить и результат операции тоже. Но при этом будем хранить результат операции не на каком-то
[01:29:40.780 --> 01:29:46.340]  отрезке, а в самом поддереве. То есть, скажем, возьмем этот узел и будем хранить результат операции во всем
[01:29:46.340 --> 01:29:59.380]  поддереве сразу, окей? То есть, будем в каждом поддереве хранить результат
[01:29:59.380 --> 01:30:21.620]  операции на элементах поддерева. Ну, то есть, мы как бы в случае декартов в дереве не обсуждали, но вообще говоря,
[01:30:21.620 --> 01:30:27.140]  я думаю, понятно, что у вас узел представляется в виде некоторой структуры, что у вас хранится в узле. То есть, у вас хранится
[01:30:27.380 --> 01:30:38.180]  ключ, возможно хранится приоритет, давайте х, мы обозначали х, возможно хранится у. Опять же, я не настаиваю, но если вы используете
[01:30:38.180 --> 01:30:45.060]  в качестве бинарного дерева поиска декартового дерева, то вы еще храните дополнительные приоритеты. Плюс вы храните
[01:30:45.060 --> 01:30:51.300]  собственное значение, то есть, так у вас ассоциативный массив, вы храните пары ключа значения. Ну, там понятно,
[01:30:51.300 --> 01:31:07.460]  всякие указатели left, right, возможно parent, если надо, и дополнительно храните result. То есть, в одном узле вы храните
[01:31:07.460 --> 01:31:12.580]  ключ значения, понятное дело указатель на левостен, указатель на правостен, возможно указатель на родителя, и храните
[01:31:12.580 --> 01:31:18.500]  результат применения операции ко всему поддереву. Ну, давайте здесь посмотрим, что мы будем хранить, будем красного цвета обозначать.
[01:31:19.460 --> 01:31:27.380]  Значит, здесь хранится пятерка, здесь храниться семерка, то есть, напоминаю, операция минимум, здесь хранится
[01:31:27.380 --> 01:31:36.820]  минус тройка. Почему, потому что во всем этом поддереве результат операции минус 3. Здесь 6, здесь 0, здесь 5.
[01:31:36.820 --> 01:31:41.860]  Здесь во всем этом поддереве результат операции ноль, поэтому пишем 0. Во всем этом поддереве результат операции
[01:31:41.860 --> 01:31:47.420]  это минус 3, поэтому храним минус 3. Во всем дереве целиком результат операции минус 3.
[01:31:47.420 --> 01:31:53.260]  То есть в принципе все очень похоже на дерево отрезков. То есть дерево отрезков тоже хранило
[01:31:53.260 --> 01:31:56.660]  результатом целой операции на каком-то подотреске. То есть единственное отличие заключается в том,
[01:31:56.660 --> 01:32:02.220]  что мы здесь помимо самого результата храним еще некоторые значения тоже. В дереве отрезков
[01:32:02.220 --> 01:32:13.260]  у нас эти значения хранились только в листовых вершинах. Вот, отлично. Ну, я думаю, построить вот
[01:32:13.260 --> 01:32:17.900]  эти вот значения result не составляет никакого труда. То есть мы тоже это можем сделать рекурсивно,
[01:32:17.900 --> 01:32:22.820]  грубо говоря. То есть спуститься в левый сын, спуститься в рамовый сын, посчитать тут результат,
[01:32:22.820 --> 01:32:28.740]  посчитать тут результат, написать Русат здесь, ну и так далее. Вопрос заключается в другом. А как
[01:32:28.740 --> 01:32:33.780]  эту структуру поддерживать? То есть у меня же, вообще говоря, бинарное дерево поиска,
[01:32:33.780 --> 01:32:38.900]  оно может как бы менять свою структуру. То есть в чем отличие от исходной задачи RSQR и RMQ? Здесь у
[01:32:38.900 --> 01:32:42.540]  меня появляются дополнительные запросы вида вставить новый элемент или удалить элемент.
[01:32:42.540 --> 01:32:47.300]  Согласны? То есть если на массиве, наверное, не имеет смысла говорить о операциях вставки,
[01:32:47.300 --> 01:32:50.820]  удаления, потому что они занимают линейное время, и в принципе сложно это организовать,
[01:32:50.820 --> 01:32:54.340]  то в бинарном дереве поиска в принципе вы можете задаться вопросом, а что если я хочу
[01:32:54.340 --> 01:32:57.540]  дополнительно вставлять сюда дополнительные элементы, и плюс чтобы у меня поддерживались вот
[01:32:57.540 --> 01:33:04.780]  эти вот все инварианты, то есть все вот эти результаты. Нормальный вопрос. Давайте попробуем
[01:33:04.780 --> 01:33:13.500]  понять, как поддерживать все эти операции. Ну точнее, вот мне приходит новый элемент,
[01:33:13.500 --> 01:33:18.340]  я вставляю новый элемент, что мне нужно сделать, чтобы все корректно работало. Вот здесь мне
[01:33:18.340 --> 01:33:26.340]  пригодится, здесь мне пригодится одна операция, которую давайте назовем
[01:33:26.340 --> 01:33:54.900]  починка вершин, будем называть FixedNode. Смотрите, в какой момент мне может понадобиться
[01:33:54.900 --> 01:34:00.380]  починить вершины? В какой момент мне может понадобиться изменить, скажем так, изменить
[01:34:00.380 --> 01:34:10.020]  результат операции? Что может произойти, что мне там необходимо было? Ну MergeSplit это как бы частный
[01:34:10.020 --> 01:34:15.380]  случай, вот если в общем говорить. Ну MergeSplit это конкретно там для декартового дерева. Да,
[01:34:15.380 --> 01:34:20.820]  мы посмотрим там, что надо делать, вот если в общем говорить. За счет чего у меня может
[01:34:20.820 --> 01:34:26.640]  измениться здесь значение? Да, что есть у меня появится какое-то, ну допустим, если у меня
[01:34:26.640 --> 01:34:38.040]  появится какое-то левое поддерево, или правое поддерево, ну или в принципе, если меня изменяет
[01:34:38.040 --> 01:34:39.500]  левое или правое поддерево, да, то мне нужно починить вершину. Ну почему? Потому что если у меня
[01:34:39.500 --> 01:34:47.300]  левое сын или правое сын изменился, то это значит, что результат операции в принципе теоретически
[01:34:47.300 --> 01:35:05.300]  вызывается при изменении левого или правого сына.
[01:35:05.300 --> 01:35:09.300]  Что в этом случае нужно сделать?
[01:35:10.300 --> 01:35:18.300]  Давайте на всякий случай добавим проверку.
[01:35:18.300 --> 01:35:26.300]  Мы фиксируем не нулевую вершину.
[01:35:26.300 --> 01:35:30.300]  Если вершина не нулевая, то что значит пофиксить ее результат?
[01:35:30.300 --> 01:35:37.300]  Что нужно сделать?
[01:35:37.300 --> 01:35:47.300]  Нужно просто взять и сказать, что node.result это что?
[01:35:47.300 --> 01:35:51.300]  Давайте еще какое-то место пропустим.
[01:35:51.300 --> 01:35:54.300]  Давайте дополнительную функцию заведем.
[01:35:54.300 --> 01:35:57.300]  result от node.
[01:35:57.300 --> 01:36:01.300]  Чтобы не возиться с проверками, давайте так сделаем.
[01:36:01.300 --> 01:36:18.300]  Если вершина node не нулевая, то будем возвращать node по C++.
[01:36:18.300 --> 01:36:25.300]  Если вершина не нулевая, то возвращаем node.result.
[01:36:25.300 --> 01:36:30.300]  А иначе возвращаем некоторый нейтральный элемент.
[01:36:30.300 --> 01:36:36.300]  Если я попросил результат от нормальной вершины, то я должен обратиться к result.
[01:36:36.300 --> 01:36:42.300]  Если я попросил результат от пустой вершины, то я возвращаю нейтральный элемент.
[01:36:42.300 --> 01:36:46.300]  Как тогда обновить результат в вершине?
[01:36:46.300 --> 01:36:54.300]  Нужно просто взять результат из левого сына node.left.
[01:36:54.300 --> 01:37:00.300]  Заметьте, что я тут проверок теперь не пишу, потому что я проверку вынес в отдельную функцию.
[01:37:00.300 --> 01:37:09.300]  Смотрю результат в левой вершине, добавляю значение в текущей вершине.
[01:37:09.300 --> 01:37:15.300]  Почему значение? Потому что меня интересует то, что в ней сейчас находится.
[01:37:15.300 --> 01:37:25.300]  Ну и плюс, не знаю, минимум, максимум от result, от write.
[01:37:25.300 --> 01:37:35.300]  Все довольно просто.
[01:37:35.300 --> 01:37:43.300]  Общая идея простая. Мы храним в каждой вершине отдельное поле result, которое хранит результат в некоторой операции на всем поддереве.
[01:37:43.300 --> 01:37:53.300]  Если у вас изменилось вот это значение или изменился левый сын или правый сын, вы вызываете функцию fixNode, которая фиксит значение здесь.
[01:37:53.300 --> 01:37:59.300]  Вообще говоря, при необходимости нужно рекурсивно вызывать.
[01:37:59.300 --> 01:38:07.300]  Сейчас мы поймем, что на самом деле в случае декартового дерева это нам не нужно.
[01:38:07.300 --> 01:38:12.300]  Все примеры я буду привозить в парадигме декартового дерева.
[01:38:12.300 --> 01:38:22.300]  Еще раз повторюсь, что это все можно сделать и для любого бинарного дерева поиска, но вот сегодня мы разбираем конкретно декартового дерева.
[01:38:22.300 --> 01:38:32.300]  Мы в декартово дерево или в наше бинарное дерево поиска добавили соответственно новые значения и добавили хранение некоторых результатов операции.
[01:38:32.300 --> 01:38:42.300]  Вопрос вам, много ли операций декартового дерева нужно изменить, чтобы подружить его с этой всей структурой?
[01:38:49.300 --> 01:38:57.300]  Оказывается, нет. Через какие операции у нас выражается вообще все в декартовом дереве?
[01:38:57.300 --> 01:39:09.300]  Мерш и сплит. Вы согласны, что если я добавлю поддержку фиксноута сплит и мерж, то у меня автоматически инсерты и рейсы заработают.
[01:39:09.300 --> 01:39:17.300]  Давайте посмотрим, что нужно изменить в мерже и сплите, чтобы это все заработало.
[01:39:17.300 --> 01:39:27.300]  Давайте я тут буду, напишу мерч и сплит и больше стирать не буду, чтобы перед глазами был.
[01:39:27.300 --> 01:39:37.300]  Давайте восстановим, что у нас было мерч.
[01:39:37.300 --> 01:39:47.300]  Т1, Т2. Напомню, что все ключи в Т1 строго меньше, чем все ключи в Т2.
[01:39:47.300 --> 01:40:09.300]  Условия выхода из рекурсии. Если Т1 нул, то return Т2. Если Т2 равно равно нул, то return Т1.
[01:40:09.300 --> 01:40:16.300]  Что мы проверяем в мерже? Когда мы склеиваем два дерева, нам нужно выбрать корень.
[01:40:16.300 --> 01:40:22.300]  Поэтому мы сравниваем лево под дерево приоритет правого под дерево.
[01:40:22.300 --> 01:40:37.300]  Если это выполняется, то в качестве правого под дерево я сохраняю результат мержа от Т1 right.
[01:40:37.300 --> 01:40:42.300]  Вы и следите, согласуете ли это всем, что мы до этого писали.
[01:40:42.300 --> 01:41:01.300]  В качестве правого под дерево здесь. Дальше, Т1 right parent равно Т1. И все. Return Т1.
[01:41:01.300 --> 01:41:16.300]  Аналогично else. Вот здесь. Что мерж принимает в качестве своих аргументов?
[01:41:16.300 --> 01:41:21.300]  В качестве своих аргументов предполагаем, что он принимает корректное дерево Т1 и корректное дерево Т2.
[01:41:21.300 --> 01:41:25.300]  В процессе своей работы он как-то эти деревья модифицирует.
[01:41:25.300 --> 01:41:31.300]  В частности, тут видно, что есть правое под дерево, он это правое под дерево меняет.
[01:41:31.300 --> 01:41:36.300]  Вопрос. В какой момент не нужно вызывать fixNode и для каких вершин?
[01:41:36.300 --> 01:41:49.300]  Куда здесь нужно вставить fixNode?
[01:41:49.300 --> 01:41:52.300]  Не так уж много вариантов, на самом деле.
[01:41:52.300 --> 01:41:54.300]  Можно ли вставить куда-нибудь сюда?
[01:41:54.300 --> 01:41:59.300]  Нет, здесь никаких изменений не произошло. Мы тут возвращаем дерево Т2 как оно было, Т1 как оно было.
[01:41:59.300 --> 01:42:01.300]  Где мы портим деревья?
[01:42:01.300 --> 01:42:05.300]  Вообще говоря, вот здесь это единственная строчка, где мы испортили дерево.
[01:42:05.300 --> 01:42:07.300]  В частности, тут испортили правое под дерево.
[01:42:07.300 --> 01:42:11.300]  Тут было какое-то раньшее старое под дерево, мы заменили его на результат мержа.
[01:42:11.300 --> 01:42:19.300]  Естественно, по предположению индукции предполагаем, что мерж от меньших деревьев возвращает корректный результат.
[01:42:19.300 --> 01:42:22.300]  То есть мерж нам вернул корректное дерево, в котором все посчитано.
[01:42:22.300 --> 01:42:30.300]  Мы сказали, что у Т1 изменилось правое дерево.
[01:42:30.300 --> 01:42:33.300]  Соответственно, какую вершину мы должны пофиксить?
[01:42:33.300 --> 01:42:35.300]  Собственно, Т1.
[01:42:35.300 --> 01:42:43.300]  Единственная строчка, которую тут нужно добавить, это fixNodeT1.
[01:42:43.300 --> 01:42:47.300]  И после этого сделать returnT1.
[01:42:47.300 --> 01:42:50.300]  Вопрос на понимание.
[01:42:50.300 --> 01:42:57.300]  Смотрите, я вызвал fixNode от Т1, но при этом у Т1 же есть еще какие-то родители.
[01:42:57.300 --> 01:43:01.300]  Вот это родители, вот это родители.
[01:43:01.300 --> 01:43:06.300]  И в принципе, если изменился Т1, то должны были измениться его родители, родители родителей и так далее.
[01:43:06.300 --> 01:43:09.300]  Нужно ли это как-то эту ситуацию обрабатывать отдельно или нет?
[01:43:17.300 --> 01:43:22.300]  Варианты? Да, нет, тут всего два ответа.
[01:43:22.300 --> 01:43:25.300]  Самый простой ответ какой?
[01:43:25.300 --> 01:43:27.300]  Нет, ничего не надо делать.
[01:43:27.300 --> 01:43:29.300]  Ничего не надо делать. Почему?
[01:43:29.300 --> 01:43:34.300]  Потому что мы все операции реализовали рекурсивно, у нас как раз таки рекурсивно все и решится.
[01:43:34.300 --> 01:43:36.300]  То есть как работает рекурсия?
[01:43:36.300 --> 01:43:41.300]  Рекурсия спускается вниз до тех пор, пока мы не встретим пустое дерево.
[01:43:41.300 --> 01:43:46.300]  После того, как мы встретили пустое дерево, рекурсия раскручивается обратно.
[01:43:46.300 --> 01:43:49.300]  То есть мы вернулись обратно, пофиксили здесь.
[01:43:49.300 --> 01:43:54.300]  Дальше, после того, как вот этот мерж завершился, мерж поднялся куда-то наверх, пофиксил здесь и так далее.
[01:43:54.300 --> 01:43:57.300]  То есть рекурсия все сделает за нас.
[01:43:57.300 --> 01:44:00.300]  Что делает мерж? Мерж рекурсивно вызывает сам себя.
[01:44:00.300 --> 01:44:03.300]  Все места, где у нас потенциально меняется дерево, мы пофиксили.
[01:44:03.300 --> 01:44:06.300]  Соответственно, в мерже все хорошо.
[01:44:06.300 --> 01:44:09.300]  Логика понятна?
[01:44:09.300 --> 01:44:12.300]  Поэтому все, на этом достаточно.
[01:44:12.300 --> 01:44:16.300]  То есть добавили всего лишь одну строчку, и теперь у нас все вот это заработало в случае мержа.
[01:44:16.300 --> 01:44:20.300]  Теперь давайте сделаем так, что все работало и для сплита.
[01:44:28.300 --> 01:44:33.300]  Сплит дерево t по x0.
[01:44:33.300 --> 01:44:38.300]  Снова предполагаем, что дерево t там хорошее, то есть там все почти нормально.
[01:44:38.300 --> 01:44:45.300]  Если t это null, то просто делаем return пару null-null.
[01:44:48.300 --> 01:44:55.300]  Ну и в случае сплита мы проверяем, верно ли что x меньше, чем x0.
[01:44:55.300 --> 01:45:00.300]  Если это так, то мы должны распилить правое под дерево.
[01:45:00.300 --> 01:45:10.300]  Lr равно split t right x0.
[01:45:10.300 --> 01:45:15.300]  Дальше что мы делали?
[01:45:15.300 --> 01:45:25.300]  Распилили право под дерево. Дальше сказали, что t right ght равно l.
[01:45:25.300 --> 01:45:30.300]  Ну и если l, то l parent.
[01:45:30.300 --> 01:45:35.300]  Ну даже не интересно, если l, если r, тоже бла-бла.
[01:45:35.300 --> 01:45:42.300]  Ну и делаем return, пилили правое, поэтому lt.
[01:45:42.300 --> 01:45:45.300]  Ну else аналогично.
[01:45:45.300 --> 01:45:50.300]  Давайте подумаем, куда сюда нужно вставить fixed node.
[01:45:55.300 --> 01:46:03.300]  Нет, split же у нас делит на два дерева.
[01:46:03.300 --> 01:46:09.300]  А, да, мы пилили правое, да, tl.
[01:46:09.300 --> 01:46:14.300]  Мы пилили правое, тогда tr.
[01:46:14.300 --> 01:46:19.300]  А до этого мы правильно писали?
[01:46:20.300 --> 01:46:25.300]  У нас было дерево t, мы его правое под дерево распилили,
[01:46:25.300 --> 01:46:30.300]  поэтому мы возвращаем t и вот этот кусочек r.
[01:46:30.300 --> 01:46:35.300]  Ну так чего?
[01:46:35.300 --> 01:46:42.300]  Ну, давайте рассуждаем как математики по индукции.
[01:46:42.300 --> 01:46:46.300]  Сплит у нас рекурсивная функция, то есть по сути это такая математическая индукция.
[01:46:46.300 --> 01:46:51.300]  То есть мы свели исходную задачу в задачу поменьше.
[01:46:51.300 --> 01:46:56.300]  Предположим, что маленькие задачи мы умеем решать корректно.
[01:46:56.300 --> 01:47:01.300]  Вот допустим, сплит нам вернул два корректных дерева.
[01:47:01.300 --> 01:47:06.300]  lr корректные, что у нас тут портится, где нужно вызывать fix?
[01:47:06.300 --> 01:47:11.300]  Единственное дерево, которое у нас портится, это t.
[01:47:11.300 --> 01:47:14.300]  То есть мы у t меняем правое под дерево.
[01:47:14.300 --> 01:47:17.300]  Так что результат самой вершине t мог измениться.
[01:47:17.300 --> 01:47:26.300]  Поэтому здесь то же самое. Перед самым ретерном мы должны вызвать fix?node от t.
[01:47:26.300 --> 01:47:31.300]  Ну и return?tr. Все.
[01:47:35.300 --> 01:47:37.300]  Снова почему это корректно работает?
[01:47:37.300 --> 01:47:40.300]  Потому что сплит тоже работает рекурсивно.
[01:47:40.300 --> 01:47:42.300]  То есть если у вас есть какое-то исходное дерево,
[01:47:42.300 --> 01:47:45.300]  то вы в нем спускаетесь до тех пор, пока вы не встретите нулевую вершину,
[01:47:45.300 --> 01:47:48.300]  а дальше у вас рекурсия разгонит обратно.
[01:47:48.300 --> 01:47:51.300]  То есть вы дальше будете идти по одной вершине, по родителю и так далее.
[01:47:51.300 --> 01:47:54.300]  И когда вы будете подниматься от листа к родителю,
[01:47:54.300 --> 01:47:56.300]  вы будете последовательно вызывать fix?node.
[01:47:56.300 --> 01:48:01.300]  Соответственно так вы от самой низкой вершины до самой верхней обновите все вершины.
[01:48:01.300 --> 01:48:04.300]  С помощью fix?node.
[01:48:04.300 --> 01:48:06.300]  Ну или если хотите по индукции.
[01:48:06.300 --> 01:48:09.300]  У нас маленький сплит, предполагаем, что работает корректно.
[01:48:09.300 --> 01:48:13.300]  Но сплит тоже работает корректно, потому что мы там везде, где надо fix?node вызвали.
[01:48:16.300 --> 01:48:18.300]  Все понятно?
[01:48:18.300 --> 01:48:22.300]  Вот и теперь, смотрите, мы починили merge, мы починили сплит.
[01:48:22.300 --> 01:48:26.300]  То есть теперь и merge, и сплит у нас умеют восстанавливать справедливость.
[01:48:26.300 --> 01:48:29.300]  То есть они умеют восстанавливать корректный результат здесь.
[01:48:29.300 --> 01:48:33.300]  Ну а соответственно из этого следует, что теперь и insert, и erase тоже работают корректно.
[01:48:33.300 --> 01:48:35.300]  То есть что мы сейчас научились делать?
[01:48:35.300 --> 01:48:42.300]  Мы научились поддерживать бинарное дерево поиска, в котором у нас сохраняются результаты некоторых операций на поддеревьях.
[01:48:42.300 --> 01:48:47.300]  И плюс они будут сохраняться и при всяких вставках, удалениях и тому подобное.
[01:48:47.300 --> 01:48:52.300]  Остался на самом деле один несущественный вопрос.
[01:48:52.300 --> 01:48:57.300]  А как найти минимум на 5-10?
[01:48:57.300 --> 01:49:01.300]  Ну хорошо, вот мы где-то в поддеревьях что-то сохранили.
[01:49:01.300 --> 01:49:04.300]  А ответ как считать?
[01:49:04.300 --> 01:49:09.300]  Все умеем делать, insert умеем, erase умеем, в поддеревьях умеем там корректно считать.
[01:49:09.300 --> 01:49:12.300]  Вот если был запрос на поддеревья, то все отлично, мы все умеем делать.
[01:49:12.300 --> 01:49:17.300]  А вот тут минимум на 5-10 у нас результат не на поддеревья.
[01:49:17.300 --> 01:49:24.300]  Ну то есть результат операции вот на этом участке нигде в какой-то конкретной вершине не хранится, согласны?
[01:49:24.300 --> 01:49:27.300]  Что делать?
[01:49:27.300 --> 01:49:32.300]  Ответ вас шокирует.
[01:49:32.300 --> 01:49:35.300]  Давайте, что делать?
[01:49:35.300 --> 01:49:38.300]  Я в самом начале лекции обещал, что...
[01:49:38.300 --> 01:49:43.300]  В общем, я что-то обещал.
[01:49:43.300 --> 01:49:47.300]  Как посчитать результат операции на произвольном куске дерева?
[01:49:47.300 --> 01:49:50.300]  Ну обход...
[01:49:50.300 --> 01:49:55.300]  Ну с обходами тоже все сложно, потому что у нас нет обходов.
[01:49:55.300 --> 01:49:58.300]  С обходами тоже все сложно, потому что...
[01:49:58.300 --> 01:50:02.300]  Ну в принципе у вас запрос может быть произвольным, то есть произвольная сложность.
[01:50:02.300 --> 01:50:04.300]  Запрос может быть каким-то вот таким.
[01:50:04.300 --> 01:50:06.300]  Тогда это совсем не обход.
[01:50:06.300 --> 01:50:08.300]  Да, вот смотрите, вот вообще плохая ситуация.
[01:50:08.300 --> 01:50:12.300]  Вот если меня попросили на 5-11,
[01:50:12.300 --> 01:50:17.300]  то тогда мне нужно взять вот эти вершины и плюс кусочек вот этого поддерева.
[01:50:17.300 --> 01:50:21.300]  То есть мне нужно отдельно выделить вот эту вершину, потом взять там какие-то вершины отсюда.
[01:50:21.300 --> 01:50:24.300]  В общем, не очень ситуация, согласна.
[01:50:32.300 --> 01:50:35.300]  Как мы берем...
[01:50:35.300 --> 01:50:37.300]  Что он означает?
[01:50:37.300 --> 01:50:40.300]  Он означает, что мы должны выбрать все элементы дерева
[01:50:40.300 --> 01:50:43.300]  с ключами от 5 до 11 не включительно.
[01:50:43.300 --> 01:50:45.300]  В данном случае это 5, 7, 8, 10.
[01:50:45.300 --> 01:50:47.300]  11 тут нет, но мы его не включаем.
[01:50:47.300 --> 01:50:50.300]  Выбираем вот эти 4 узла.
[01:50:50.300 --> 01:50:53.300]  Выбираем минимум вот на значениях.
[01:50:53.300 --> 01:50:55.300]  Ну, грубо говоря, это ассоциативный массив.
[01:50:55.300 --> 01:50:58.300]  Только вместо индексов у нас вот ключи.
[01:51:00.300 --> 01:51:04.300]  Короче, я обещал, что все операции, которые мы сегодня будем изучать,
[01:51:04.300 --> 01:51:08.300]  они будут сводиться к операции merge и split.
[01:51:08.300 --> 01:51:12.300]  Соответственно запрос тоже можно сделать с помощью merge и split.
[01:51:12.300 --> 01:51:15.300]  Вопрос, как посчитать результат операции здесь?
[01:51:16.300 --> 01:51:19.300]  Давайте общую идею.
[01:51:19.300 --> 01:51:22.300]  Что нужно сделать?
[01:51:25.300 --> 01:51:29.300]  Давайте просто возьмем и вырежем это дерево.
[01:51:29.300 --> 01:51:35.300]  Просто возьмем и вот это дерево с помощью сплитов вырежем из всего под дерево.
[01:51:35.300 --> 01:51:38.300]  Получим вот такое вот маленькое под дерево, в котором хранятся только вот эти ключи.
[01:51:38.300 --> 01:51:41.300]  И где будет храниться ответ у такого дерева?
[01:51:41.300 --> 01:51:43.300]  Просто в корне.
[01:51:43.300 --> 01:51:45.300]  Все? Гениально?
[01:51:49.300 --> 01:51:52.300]  Давайте напишем операцию запроса.
[01:51:55.300 --> 01:51:58.300]  Операцию запроса.
[01:51:58.300 --> 01:52:00.300]  Кьюри от L...
[01:52:00.300 --> 01:52:06.300]  Ну давайте я так буду писать, чтобы подчеркнуть, что правая граница не включается.
[01:52:06.300 --> 01:52:10.300]  Кьюри от L до R. Видно или плохо?
[01:52:10.300 --> 01:52:13.300]  Давайте поменяем.
[01:52:29.300 --> 01:52:32.300]  В 3D лекция пошла.
[01:52:32.300 --> 01:52:36.300]  Давайте разобьемся с кьюри и потом перерыв.
[01:52:36.300 --> 01:52:38.300]  Все очень просто.
[01:52:38.300 --> 01:52:42.300]  Если я хочу посчитать результат операции на произвольной части ключей,
[01:52:42.300 --> 01:52:45.300]  я должен все эти ключи вырезать из дерева.
[01:52:45.300 --> 01:52:47.300]  Давайте сделаем так.
[01:52:47.300 --> 01:52:52.300]  Во-первых, давайте отрежем всю часть, которая относится к L.
[01:52:52.300 --> 01:52:54.300]  Все, что L справа.
[01:52:55.300 --> 01:52:59.300]  Разрежем дерево так, чтобы все ключи, которые меньше L, остались в одном дереве.
[01:52:59.300 --> 01:53:02.300]  Все ключи, которые больше набраны, чем L, остались в другом дереве.
[01:53:02.300 --> 01:53:05.300]  Делаем это с помощью сплита.
[01:53:05.300 --> 01:53:08.300]  Тут еще дерево T.
[01:53:13.300 --> 01:53:15.300]  Работаем над деревом T.
[01:53:15.300 --> 01:53:19.300]  Сплитим исходное дерево T по ключу L.
[01:53:19.300 --> 01:53:22.300]  Как работает сплит, но ровно так он работает.
[01:53:22.300 --> 01:53:26.300]  Получаем дерево, в котором все ключи меньше L и все ключи, в котором больше набраны L.
[01:53:26.300 --> 01:53:29.300]  Что теперь нужно сделать?
[01:53:29.300 --> 01:53:34.300]  Теперь из этого дерева нужно вырезать все значения, которые удовлетворяют, которые меньше, чем R.
[01:53:34.300 --> 01:53:36.300]  Как это сделать?
[01:53:41.300 --> 01:53:43.300]  Дерево от L до R.
[01:53:43.300 --> 01:53:45.300]  Дерево, в котором все ключи больше R.
[01:53:45.300 --> 01:53:52.300]  Это просто сплит вот этого дерева по R.
[01:53:52.300 --> 01:53:56.300]  За два сплита мне удалось вырезать нужное мне дерево.
[01:53:56.300 --> 01:54:01.300]  Все, ну и я сохраняю результат в какую-то отдельную переменную.
[01:54:01.300 --> 01:54:03.300]  Не знаю, result.
[01:54:03.300 --> 01:54:08.300]  Это result от T и R.
[01:54:08.300 --> 01:54:10.300]  Почему я использую функцию?
[01:54:10.300 --> 01:54:14.300]  Потому что теоретически у меня в этом диапазоне может совсем никакой вершины не оказалось.
[01:54:14.300 --> 01:54:19.300]  Поэтому там result возвращает в этом случае нейтральный элемент.
[01:54:19.300 --> 01:54:22.300]  И что я должен после этого сделать?
[01:54:22.300 --> 01:54:24.300]  Вернуть все обратно.
[01:54:24.300 --> 01:54:26.300]  Как будто ничего и не было.
[01:54:26.300 --> 01:54:29.300]  Ну давайте склеим все обратно.
[01:54:29.300 --> 01:54:35.300]  T равно merge.
[01:54:35.300 --> 01:54:39.300]  Так, как мы склеиваем?
[01:54:44.300 --> 01:54:46.300]  Ну, например, так.
[01:54:46.300 --> 01:54:49.300]  T меньше L.
[01:54:49.300 --> 01:54:50.300]  T L R.
[01:54:50.300 --> 01:54:53.300]  В любом порядке можно склеивать, неважно.
[01:54:53.300 --> 01:54:57.300]  Вот так и T больше R.
[01:54:57.300 --> 01:54:59.300]  Больше ли равно R?
[01:54:59.300 --> 01:55:01.300]  Тут больше ли равно должно быть?
[01:55:01.300 --> 01:55:03.300]  Все элементы меньше R здесь.
[01:55:03.300 --> 01:55:06.300]  Все элементы больше равные R здесь.
[01:55:06.300 --> 01:55:08.300]  Ну все, собрали обратно.
[01:55:09.300 --> 01:55:13.300]  Возвращаем ответ result.
[01:55:13.300 --> 01:55:15.300]  Все, что получилось?
[01:55:15.300 --> 01:55:17.300]  Результат мы посчитали.
[01:55:17.300 --> 01:55:19.300]  Дерево исходное не изменилось.
[01:55:19.300 --> 01:55:22.300]  То есть мы его как расклеили, так и склеили обратно.
[01:55:22.300 --> 01:55:27.300]  Продолжим обсуждать дружбу между бинарными деревьями поиска и RMQ-RSQ.
[01:55:27.300 --> 01:55:30.300]  В общем-то запрос мы делать научились.
[01:55:30.300 --> 01:55:34.300]  Мы храним результат операции в корне дерева.
[01:55:34.300 --> 01:55:39.300]  Соответственно, если хотим получить результат на определенном диапазоне ключей,
[01:55:39.300 --> 01:55:42.300]  то мы просто нужное поддерево вырезаем.
[01:55:42.300 --> 01:55:45.300]  За счет того, что мы исправили операции MergeSplit,
[01:55:45.300 --> 01:55:51.300]  нам теперь гарантируется, что в вырезанном дереве в корне будет храниться нужный результат.
[01:55:51.300 --> 01:55:54.300]  Точнее результат операции, примененный ко всему этому поддереву.
[01:55:54.300 --> 01:55:58.300]  Соответственно, мы смотрим на корень этого поддерева и получаем результат.
[01:55:58.300 --> 01:56:02.300]  После этого склеиваем все обратно и работаем дальше.
[01:56:02.300 --> 01:56:07.300]  Еще один короткий пункт, который тут нужно обсудить.
[01:56:07.300 --> 01:56:10.300]  Что если мне хочется выполнять групповые обновления?
[01:56:10.300 --> 01:56:13.300]  Как мы это делали в дереве отрезков?
[01:56:13.300 --> 01:56:15.300]  Помимо того, что мы хотим узнавать результат,
[01:56:15.300 --> 01:56:17.300]  мы хотим выполнять групповые обновления.
[01:56:18.300 --> 01:56:30.300]  А add на отрезке от 5 до 10 прибавить 5.
[01:56:34.300 --> 01:56:37.300]  Снова я хочу взять все эти элементы и ко всем value,
[01:56:37.300 --> 01:56:40.300]  то есть 6, 0, 2, 10, ко всем ним прибавить 5.
[01:56:44.300 --> 01:56:46.300]  Как это можно сделать?
[01:56:48.300 --> 01:56:52.300]  На самом деле, идея тут точно такая же, как и в дереве отрезков.
[01:56:52.300 --> 01:56:55.300]  Что мы делали, когда мы делали групповые обновления?
[01:56:55.300 --> 01:56:57.300]  Мы хранили обещание.
[01:56:57.300 --> 01:57:02.300]  На самом деле, спускать обещание или обновлять со значения долго.
[01:57:02.300 --> 01:57:06.300]  Давайте просто возьмем поддерево, в котором хранятся все эти элементы,
[01:57:06.300 --> 01:57:10.300]  и в корне этого поддерева сохраним нужное нам обещание.
[01:57:10.300 --> 01:57:13.300]  Есть правда проблема, которая заключается в том,
[01:57:13.300 --> 01:57:16.300]  что все эти элементы лежат в разных поддеревьях.
[01:57:16.300 --> 01:57:18.300]  Как эта проблема решается?
[01:57:18.300 --> 01:57:21.300]  Давайте снова просто вырежем все эти элементы,
[01:57:21.300 --> 01:57:24.300]  в корне добавим обещание, и потом склеим все обратно.
[01:57:29.300 --> 01:57:40.300]  Давайте сначала идея групповых обновлений.
[01:57:47.300 --> 01:57:59.300]  В корне дерева храним промисс.
[01:57:59.300 --> 01:58:01.300]  Заводим дополнительное поле.
[01:58:01.300 --> 01:58:06.300]  Помимо value, parent, result и так далее, пишем еще промисс.
[01:58:07.300 --> 01:58:19.300]  Тогда update на интервале от L до R, delta, выглядит следующим образом.
[01:58:19.300 --> 01:58:23.300]  На самом деле, можно просто переписать все то же самое.
[01:58:23.300 --> 01:58:26.300]  Давайте делаем так.
[01:58:36.300 --> 01:58:39.300]  То есть вставим все сюда, все то же самое.
[01:58:39.300 --> 01:58:45.300]  Единственное отличие вот в этой строчке,
[01:58:45.300 --> 01:58:52.300]  заменим эту строчку на что?
[01:58:52.300 --> 01:59:02.300]  T, L, R, промисс.
[01:59:02.300 --> 01:59:06.300]  Обновим его обещание на дельту.
[01:59:06.300 --> 01:59:08.300]  Логика понятна.
[01:59:08.300 --> 01:59:10.300]  Вырезаем нужное нам под дерево,
[01:59:10.300 --> 01:59:11.300]  в его корне сохраняем обещание,
[01:59:11.300 --> 01:59:13.300]  дальше склеиваем все обратно.
[01:59:13.300 --> 01:59:16.300]  Вот весь апдейт.
[01:59:16.300 --> 01:59:18.300]  Как правильно заметили, раз мы храним обещание,
[01:59:18.300 --> 01:59:21.300]  нам, наверное, эти обещания нужно выполнять.
[01:59:21.300 --> 01:59:26.300]  В данном случае, как выглядит push?
[01:59:26.300 --> 01:59:30.300]  Пушноут, ну это давайте выполнение обещания.
[01:59:30.300 --> 01:59:35.300]  Выполнение обещания.
[01:59:35.300 --> 01:59:38.300]  Что мы должны сделать?
[01:59:38.300 --> 01:59:42.300]  Если у нас совершенно не пусто,
[01:59:42.300 --> 01:59:47.300]  то выполнение обещания выглядит следующим образом.
[01:59:47.300 --> 02:00:00.300]  Во-первых, node value может равно на node promise.
[02:00:00.300 --> 02:00:06.300]  В первую очередь мы обновляем само вот это значение.
[02:00:06.300 --> 02:00:11.300]  Потом спускаем.
[02:00:11.300 --> 02:00:14.300]  Или давайте не спускаем, а давайте так сделаем.
[02:00:14.300 --> 02:00:30.300]  node result равно на node promise.
[02:00:30.300 --> 02:00:33.300]  Раньше в result у нас хранился результат без учета обещания,
[02:00:33.300 --> 02:00:38.300]  а теперь мы это обещание просто напоследобавляем.
[02:00:38.300 --> 02:00:41.300]  Теперь promise спускаем влево и право сына.
[02:00:41.300 --> 02:00:50.300]  node left promise умножить.
[02:00:50.300 --> 02:00:53.300]  Давайте просто напишу promise.
[02:00:53.300 --> 02:00:58.300]  node стрелочка promise и node.
[02:00:58.300 --> 02:01:01.300]  И здесь еще надо не забыть, я сейчас писать не буду,
[02:01:01.300 --> 02:01:10.300]  проверить, что они существуют.
[02:01:10.300 --> 02:01:12.300]  В смысле дети.
[02:01:12.300 --> 02:01:16.300]  Понятно, что если node left нет, то спрашивать в него promise не имеет смысла.
[02:01:16.300 --> 02:01:18.300]  То же самое с write.
[02:01:18.300 --> 02:01:32.300]  node right promise умножить равно node promise.
[02:01:32.300 --> 02:01:41.300]  В самом конце говорим, что node promise равно ничему.
[02:01:41.300 --> 02:01:49.300]  Короче говоря, то же самое, только вот эта строчка добавилась по сравнению с деревом отрезков.
[02:01:49.300 --> 02:01:51.300]  Почему первой строчки не было в дереве отрезков?
[02:01:51.300 --> 02:01:54.300]  Потому что дерево отрезков хранит только результаты.
[02:01:54.300 --> 02:01:59.300]  Здесь у нас по миру результат хранит сами значения.
[02:01:59.300 --> 02:02:04.300]  Я это не проговорил, но требования на операции все те же самые.
[02:02:04.300 --> 02:02:07.300]  Потому что алгоритм по сути такой же, как и в дереве отрезков.
[02:02:07.300 --> 02:02:12.300]  Требования на результат запроса это ассоциативность.
[02:02:12.300 --> 02:02:18.300]  Требования на результат обновления это ассоциативность плюс дистрибутивность.
[02:02:18.300 --> 02:02:23.300]  Я понял, почему я это не говорил, потому что в тесте это было.
[02:02:23.300 --> 02:02:28.300]  Последний вопрос в этом пункте.
[02:02:28.300 --> 02:02:31.300]  В какой момент вызвать push?
[02:02:31.300 --> 02:02:40.300]  Все операции, и update, и query, и insert, и erase выражены через merger-split.
[02:02:40.300 --> 02:02:43.300]  Поэтому единственные две операции, которые нам нужно исправить, это merger-split.
[02:02:43.300 --> 02:02:45.300]  Давайте на них посмотрим.
[02:02:45.300 --> 02:02:47.300]  Где тут нужно вызвать push?
[02:02:53.300 --> 02:02:58.300]  Давайте вспомним. В дереве отрезков.
[02:02:58.300 --> 02:03:01.300]  В какой момент вызвали push?
[02:03:01.300 --> 02:03:03.300]  В общем случае.
[02:03:03.300 --> 02:03:11.300]  В какой момент мы должны выполнить обещание?
[02:03:11.300 --> 02:03:14.300]  Когда не полный отрезок или когда мы что делали?
[02:03:14.300 --> 02:03:16.300]  Когда мы спускались в детей?
[02:03:16.300 --> 02:03:21.300]  Если нам нужно спускаться в детей, то дети должны узнать об обещаниях.
[02:03:21.300 --> 02:03:23.300]  В какой момент мы спускаемся в детей?
[02:03:23.300 --> 02:03:26.300]  В какой момент мы спускаемся либо к правому сыну, либо к левому сыну?
[02:03:30.300 --> 02:03:34.300]  Вообще говоря, здесь и здесь.
[02:03:34.300 --> 02:03:40.300]  Но если мы хотим написать здесь и здесь, то нам придется и в lc тоже написать.
[02:03:40.300 --> 02:03:44.300]  А это дублирование кода. Давайте просто возьмем и напишем перед if.
[02:03:44.300 --> 02:03:47.300]  Согласны?
[02:03:47.300 --> 02:03:51.300]  Если у нас нетривиальный случай, то это значит, что мы должны спуститься в левую или правую сыну.
[02:03:51.300 --> 02:03:53.300]  А собственно в этот момент мы сделаем push.
[02:03:53.300 --> 02:03:59.300]  Здесь мы делаем push от...
[02:03:59.300 --> 02:04:05.300]  Ну давайте тут сделаем сразу push от t1 и push от t2.
[02:04:05.300 --> 02:04:07.300]  Хуже не будет.
[02:04:07.300 --> 02:04:12.300]  Но в принципе можете здесь отдельно сделать push для t1, а в lc push для t2.
[02:04:12.300 --> 02:04:13.300]  Как вам угодно.
[02:04:13.300 --> 02:04:17.300]  А вот здесь достаточно всего лишь одного общего push от t.
[02:04:28.300 --> 02:04:30.300]  Логика простая.
[02:04:30.300 --> 02:04:35.300]  Push выполняем до рекурсивного вызова, а fix выполняем после рекурсивного вызова.
[02:04:38.300 --> 02:04:40.300]  Почему push выполняем до рекурсивного вызова?
[02:04:40.300 --> 02:04:44.300]  Потому что до того, как делать рекурсивный вызов, нам нужно спустить обещание в детей.
[02:04:44.300 --> 02:04:46.300]  Почему мы fix вызываем после рекурсивного вызова?
[02:04:46.300 --> 02:04:52.300]  Ну чтобы после того, как все у нас сработало, чтобы мы все починили, чтобы все вернулось на круги свое.
[02:04:52.300 --> 02:04:54.300]  Вот.
[02:04:54.300 --> 02:05:02.300]  На самом деле все, что касается темы rsq и rmq применительно к бинарным деревьям поиска.
[02:05:02.300 --> 02:05:04.300]  Есть вопрос.
[02:05:04.300 --> 02:05:08.300]  То есть теперь мы в некотором смысле обобщили решение задачи rsq и rmq
[02:05:08.300 --> 02:05:10.300]  на произвольной ассоциативной массивы.
[02:05:10.300 --> 02:05:14.300]  И кроме того научились поддерживать операции вставки и удаления.
[02:05:14.300 --> 02:05:18.300]  То есть мы теперь поддерживаем все те же самые операции, что и до этого, но дополнительно умеем делать insert и erase.
[02:05:18.300 --> 02:05:20.300]  Причем все за логарифмическое время.
[02:05:20.300 --> 02:05:24.300]  Ну в случае декартового дерева там за логарифмическое время в среднем.
[02:05:24.300 --> 02:05:30.300]  Если вы там как-то пропатчите сплей дерева или овел дерева, то там в худшем случае или в амортизированном смысле.
[02:05:30.300 --> 02:05:32.300]  Вот.
[02:05:32.300 --> 02:05:34.300]  И последний пункт на сегодня.
[02:05:34.300 --> 02:05:36.300]  Сколько у нас времени?
[02:05:40.300 --> 02:05:42.300]  Достаточно.
[02:05:42.300 --> 02:05:44.300]  Последний пункт на сегодня.
[02:05:44.300 --> 02:05:46.300]  Деревья по неявному ключу.
[02:05:52.300 --> 02:05:54.300]  Давайте, давайте, давайте.
[02:06:04.300 --> 02:06:06.300]  Так.
[02:06:24.300 --> 02:06:26.300]  Так.
[02:06:26.300 --> 02:06:28.300]  Вернемся к старой доброй задачи rmq rsq.
[02:06:28.300 --> 02:06:32.300]  То есть мы работаем не с ассоциативным массивом, а с обычными массивами.
[02:06:32.300 --> 02:06:34.300]  Индексация там 0, 1, 2 и так далее.
[02:06:38.300 --> 02:06:42.300]  Давайте я заведу дерево и сделаю страшную вещь.
[02:06:46.300 --> 02:06:48.300]  Уберу ключи.
[02:06:54.300 --> 02:06:56.300]  Много информации о дереве мы потеряли.
[02:07:02.300 --> 02:07:04.300]  Например, вопрос.
[02:07:04.300 --> 02:07:06.300]  Я возьму вот эту вершину и эту вершину.
[02:07:12.300 --> 02:07:20.300]  Понимаете ли вы какой из этихistinct больше?
[02:07:20.300 --> 02:07:22.300]  Да.
[02:07:22.300 --> 02:07:24.300]  Да, то есть смотрите, сами значения ключей вам на самом деле не нужны.
[02:07:24.300 --> 02:07:28.300]  Если вы хотите определить относительный порядок элементов друг от друга,
[02:07:28.300 --> 02:07:30.300]  то к próxima ключи нам не нужны.
[02:07:30.300 --> 02:07:35.300]  Согласны? То есть в принципе мы понимаем, что вот этот элемент...
[02:07:35.300 --> 02:07:40.300]  Сотрут, это нижняя. В принципе я понимаю, что если я, например,
[02:07:40.300 --> 02:07:48.300]  спровицирую все элементы на горизонтальную ось, вот так, вот так, вот так,
[02:07:48.300 --> 02:07:52.300]  то я понимаю, что вот этот элемент имеет индекс 0.
[02:07:52.300 --> 02:07:58.300]  Этот элемент имеет индекс 1, этот 2, этот 3, этот 4, этот 5, этот 6,
[02:07:58.300 --> 02:08:06.300]  этот 7, этот 8. Согласны? То есть в принципе,
[02:08:06.300 --> 02:08:11.300]  если я храню мои данные в виде бинарного дерева, то в принципе я понимаю
[02:08:11.300 --> 02:08:13.300]  относительный порядок элементов друг относительно друга.
[02:08:13.300 --> 02:08:16.300]  Что вот этот элемент левее, чем этот элемент, да, и так далее.
[02:08:16.300 --> 02:08:21.300]  То есть в принципе вы не отличите ситуацию, когда у вас это дерево совсем не имеет ключей,
[02:08:21.300 --> 02:08:25.300]  когда у вас это дерево имеет ключ, там 0, 1, 2, 3 и так далее. Согласны?
[02:08:25.300 --> 02:08:31.300]  И вот собственно в этом и заключается смысл деревьев поиска по неявному ключу.
[02:08:31.300 --> 02:08:35.300]  То есть даже в отсутствии ключей мы понимаем относительный порядок элементов.
[02:08:35.300 --> 02:08:42.300]  Друг относительно друга. Хорошо. Давайте зададимся следующим вопросом.
[02:08:42.300 --> 02:08:48.300]  А как мне понять, допустим, вот у меня есть какое-то бинарное дерево поиска,
[02:08:48.300 --> 02:08:53.300]  я хочу найти пятый элемент в этом дереве. Ну или скажем, найти пятую порядковую статистику.
[02:08:53.300 --> 02:09:10.300]  Значит, пункт поиск порядковой статистики.
[02:09:10.300 --> 02:09:13.300]  Вот нет, но произвольное бинарное дерево поиска.
[02:09:13.300 --> 02:09:23.300]  Я хочу в нем найти десятый элемент сначала. Как мне это сделать?
[02:09:23.300 --> 02:09:26.300]  Но вот в таком виде, к сожалению, никак.
[02:09:26.300 --> 02:09:29.300]  Ну, чего мне не хватает? Какой информации?
[02:09:29.300 --> 02:09:33.300]  Ну смотрите, вот я нахожусь здесь и я хочу найти, допустим, пятый элемент.
[02:09:33.300 --> 02:09:38.300]  Какой мне информации не хватает, чтобы понять, куда мне нужно идти, влево или вправо?
[02:09:38.300 --> 02:09:40.300]  Да, мне не хватает размера под деревьев.
[02:09:40.300 --> 02:09:44.300]  То есть, скажем, смотрите, если бы я понимал, что вот в этом под дереве у меня 5 элементов,
[02:09:44.300 --> 02:09:47.300]  то я бы сразу понял, что вот этот элемент это пятый элемент.
[02:09:47.300 --> 02:09:52.300]  Почему? Потому что слева все элементы, которые меньше него, и меньше него 5 элементов.
[02:09:52.300 --> 02:09:57.300]  Но это значит, что вот этот элемент стоит на пятой позиции, ну в ноль индексации.
[02:09:57.300 --> 02:10:06.300]  Поэтому давайте просто возьмем и добавим дополнительную информацию size.
[02:10:06.300 --> 02:10:15.300]  Добавим size в node.
[02:10:19.300 --> 02:10:22.300]  Так, мы добавили size в node.
[02:10:23.300 --> 02:10:26.300]  К сожалению, стер. Давайте...
[02:10:26.300 --> 02:10:37.300]  Смотрите, size, по сути, это тоже некоторая величина, которую нужно постоянно обновлять,
[02:10:37.300 --> 02:10:39.300]  которую нужно поддерживать. Согласны?
[02:10:39.300 --> 02:10:42.300]  Скажем, я добавил новый элемент, у меня сайза все изменились.
[02:10:42.300 --> 02:10:46.300]  Я, скажем, разделил дерево на две части, у меня сайз левой части и правой части, они изменились.
[02:10:46.300 --> 02:10:49.300]  Поэтому мне нужно как-то уметь исправлять size.
[02:10:49.300 --> 02:10:52.300]  Ну давайте это сделаем тоже в том же самом FixedNode.
[02:10:52.300 --> 02:10:57.300]  Как это делать? Ну просто FixedNode нуждается строчку следующего вида.
[02:10:57.300 --> 02:11:11.300]  node size равно 1, плюс size of left, плюс size of right.
[02:11:12.300 --> 02:11:15.300]  Ну то есть, если у меня изменился левый сын или изменился правый сын,
[02:11:15.300 --> 02:11:18.300]  то я просто должен пересчитать значение size в самой вершине.
[02:11:18.300 --> 02:11:21.300]  Ну а значение size в самой вершине – это размер левого по дереву,
[02:11:21.300 --> 02:11:25.300]  размер правого по дереву, плюс сама эта вершинка.
[02:11:25.300 --> 02:11:29.300]  Все, то есть мы добавили одну строчку FixedNode, все остальное продолжает работать.
[02:11:29.300 --> 02:11:33.300]  FixedNode мы вызываем в правильном месте, здесь тоже FixedNode мы вызываем в правильном месте.
[02:11:33.300 --> 02:11:35.300]  Значит, этот пункт сделали.
[02:11:35.300 --> 02:11:48.300]  Ну и теперь давайте напишем процедуру caveElement от дерева T и K.
[02:11:48.300 --> 02:11:52.300]  Хочу найти катую порядку и статистику в дереве.
[02:11:52.300 --> 02:11:55.300]  Теперь у меня в каждом дереве дополнительно хранится и размер.
[02:11:55.300 --> 02:12:08.300]  Давайте так 1, 1, 3, 1, 5, тут 1, тут 1, тут 3, тут 9.
[02:12:08.300 --> 02:12:11.300]  Вот, допустим я хочу найти, не знаю, шестой элемент.
[02:12:11.300 --> 02:12:16.300]  Я нахожусь вначально в корне. Что мне нужно сделать?
[02:12:16.300 --> 02:12:21.300]  Как мне понять, где мне продолжать искать, в левом или в правом по дереве?
[02:12:28.300 --> 02:12:41.300]  Давайте так, если size от T left меньше, чем K, то что это означает?
[02:12:46.300 --> 02:12:51.300]  Это значит, что нужно искать в правом по дереве.
[02:12:51.300 --> 02:12:59.300]  Вот здесь суммарно, в корне и в левом по дереве, мне не хватает элементов, чтобы добить до K.
[02:12:59.300 --> 02:13:05.300]  Ну точнее так, если у меня размер левого по дереву равен K-1,
[02:13:05.300 --> 02:13:09.300]  то с учетом корня у меня всего элементов, у меня K.
[02:13:09.300 --> 02:13:14.300]  Но чтобы найти K от элемента, мне нужно К плюс первый элемент, потому что у меня ноль индексации.
[02:13:14.300 --> 02:13:18.300]  Поэтому я должен продолжить поиск справа. Согласны?
[02:13:18.300 --> 02:13:24.300]  Вот, в этом случае я просто говорю, что T равно T right.
[02:13:24.300 --> 02:13:33.300]  Так, дальше else, if, значит иначе.
[02:13:33.300 --> 02:13:41.300]  Так, тут на самом деле не все. Что забыли?
[02:13:41.300 --> 02:13:47.300]  Смотрите, что я делал. Я находился раньше здесь, я ищу шестой элемент.
[02:13:47.300 --> 02:13:51.300]  Я вижу, что размер левого по дереву равен пяти.
[02:13:51.300 --> 02:13:55.300]  То есть я понимаю, что мне нужно поиск продолжить в правом по дереве.
[02:13:55.300 --> 02:13:59.300]  Я спускаюсь в правом по дереве, и на самом деле я здесь еще не шестой элемент.
[02:13:59.300 --> 02:14:03.300]  А какой элемент? Да, я теперь ищу нулевой.
[02:14:03.300 --> 02:14:06.300]  То есть мне нужно обновить K.
[02:14:06.300 --> 02:14:13.300]  То есть я ищу вправо по дереве, и вправо по дереве я должен искать теперь элемент с номером size от...
[02:14:13.300 --> 02:14:15.300]  Так, поменяем местами.
[02:14:15.300 --> 02:14:19.300]  А, нет, стоп.
[02:14:19.300 --> 02:14:21.300]  По-другому.
[02:14:21.300 --> 02:14:28.300]  Значит, сначала K минус равно size от T left.
[02:14:28.300 --> 02:14:33.300]  А потом T равно T стрелочка right.
[02:14:33.300 --> 02:14:35.300]  Только тут еще плюс один.
[02:14:35.300 --> 02:14:40.300]  Потому что мы пропускаем size вот этих элементов и плюс вот этот элемент.
[02:14:45.300 --> 02:14:50.300]  Ну, иначе, если... Какая у меня еще может быть ситуация?
[02:14:50.300 --> 02:15:00.300]  Ситуация может быть, что, наоборот, K меньше, чем size от T left.
[02:15:00.300 --> 02:15:02.300]  Согласны?
[02:15:02.300 --> 02:15:08.300]  То есть, наоборот, размер этого поддерева больше, чем тот K, который я ищу.
[02:15:08.300 --> 02:15:11.300]  Но это означает, что этот элемент ровно находится в этом поддереве.
[02:15:11.300 --> 02:15:17.300]  Поэтому я просто запускаю T равно T left.
[02:15:17.300 --> 02:15:19.300]  При этом никакой K я не обновляю. Почему?
[02:15:19.300 --> 02:15:25.300]  Потому что если мне нужно найти, скажем, третий элемент во всем поддереве, то это то же самое, что искать третий элемент и здесь.
[02:15:25.300 --> 02:15:28.300]  То есть в левом поддереве я ничего не пропускаю.
[02:15:28.300 --> 02:15:30.300]  Ну и последний давайте здесь напишем.
[02:15:30.300 --> 02:15:35.300]  Смотрите, если у меня ни это условие не выполняется, ни это условие не выполняется, то что это означает?
[02:15:35.300 --> 02:15:39.300]  Все, я нашел нужный элемент. Значит, нужный элемент уже находится в корне.
[02:15:39.300 --> 02:15:43.300]  В этом случае я просто делаю return.
[02:15:43.300 --> 02:15:48.300]  Давайте T. То есть возвращаю тот самый узел, в котором находится нужный элемент.
[02:15:48.300 --> 02:15:56.300]  Ну и после всего цикла while, если цикл while так и не нашел нужный мне элемент, то я просто могу вернуть null.
[02:15:56.300 --> 02:16:01.300]  Таким образом я могу найти произвольный элемент.
[02:16:05.300 --> 02:16:08.300]  Так, к чему я это все?
[02:16:08.300 --> 02:16:14.300]  Я утверждаю, что мы сделали довольно дерзкую вещь.
[02:16:14.300 --> 02:16:20.300]  Мы построили массив, который устроен как бинарное дерево поиска.
[02:16:21.300 --> 02:16:24.300]  Ну, или еще раз смотрите.
[02:16:24.300 --> 02:16:25.300]  Вот у меня какое-то дерево.
[02:16:25.300 --> 02:16:28.300]  Какое-то дерево.
[02:16:28.300 --> 02:16:31.300]  Для каждого элемента я понимаю, какой элемент находится в нулевой позиции,
[02:16:31.300 --> 02:16:34.300]  какой элемент находится в первой позиции, какой элемент находится во второй позиции.
[02:16:34.300 --> 02:16:37.300]  Да то есть доступ к любому элементу я могу получить с помощью такой процедуры.
[02:16:37.300 --> 02:16:38.300]  Согласны?
[02:16:38.300 --> 02:16:41.300]  То есть это ровная процедура, которая дает мне элемент по индексу.
[02:16:41.300 --> 02:16:44.300]  Взять нулевой элемент, взять первый элемент и так далее.
[02:16:44.300 --> 02:16:46.300]  Так, ключи я теперь не храню.
[02:16:46.300 --> 02:16:48.300]  Но мне они не нужны, по сути.
[02:16:48.300 --> 02:16:49.300]  То есть, что у меня получается?
[02:16:49.300 --> 02:16:54.300]  Нет, у меня есть бинарное дерево поисков, в котором хранятся значения и доступ к каждому элементу я осуществляю по индексу.
[02:16:54.300 --> 02:16:55.300]  Но чем это не массив?
[02:16:55.300 --> 02:16:59.300]  Массив, который просто организован в виде бинарного дерева поиска. Согласны?
[02:17:03.300 --> 02:17:05.300]  Поддержите как-то.
[02:17:09.300 --> 02:17:11.300]  Да, это проблема.
[02:17:11.300 --> 02:17:16.300]  Это не совсем массив, но это массив с точки зрения того, что у него точно такой же интерфейс.
[02:17:16.300 --> 02:17:20.300]  Да, то есть мы можем делать pushback за алгорифом.
[02:17:20.300 --> 02:17:24.300]  Но зато мы можем вставлять элемент в произвольную позицию тоже за алгорифом.
[02:17:24.300 --> 02:17:26.300]  Вставлять элементы в начало за алгорифом.
[02:17:26.300 --> 02:17:28.300]  Получать доступ к элементу за алгорифом.
[02:17:28.300 --> 02:17:34.300]  И плюс все те же самые операции с RMQ и RSQ, которые мы до этого обсудили. Согласны?
[02:17:36.300 --> 02:17:38.300]  То есть мы что получили?
[02:17:38.300 --> 02:17:40.300]  Мы получили структуру данных,
[02:17:40.300 --> 02:17:42.300]  которая работает с массивами
[02:17:42.300 --> 02:17:45.300]  и которая умеет осуществлять ставку за алгорифом,
[02:17:45.300 --> 02:17:48.300]  которая умеет осуществлять поиск суммы за алгорифом,
[02:17:48.300 --> 02:17:50.300]  поиск минимума за алгорифом,
[02:17:50.300 --> 02:17:54.300]  всякие запросы на отрезках, обновления на отрезках и так далее.
[02:17:54.300 --> 02:17:58.300]  Мы пропатчили нашу предыдущую структуру данных до того,
[02:17:58.300 --> 02:18:02.300]  что мы теперь в массив можем осуществлять дополнительно еще и вставки удаления.
[02:18:02.300 --> 02:18:05.300]  И при этом поддерживать все необходимые операции RMQ и RSQ.
[02:18:05.300 --> 02:18:07.300]  Понятно?
[02:18:09.300 --> 02:18:11.300]  Тут возникает некоторая проблема.
[02:18:11.300 --> 02:18:13.300]  Точнее так, давайте сначала нет проблем.
[02:18:13.300 --> 02:18:16.300]  И на самом деле проблем никаких нет пока.
[02:18:16.300 --> 02:18:18.300]  Давайте посмотрим на мердж.
[02:18:18.300 --> 02:18:22.300]  Сильно ли пострадал мердж от того, что мы избавились от ключей?
[02:18:25.300 --> 02:18:29.300]  Да он вообще не пострадал. Смотрите, где мы тут используем ключи?
[02:18:29.300 --> 02:18:32.300]  Нигде. То есть мерджу вообще ключи не нужны.
[02:18:32.300 --> 02:18:35.300]  То есть вы что ни подсунете мерджу, он все схавает.
[02:18:35.300 --> 02:18:38.300]  В том смысле, что у вас есть два массива,
[02:18:39.300 --> 02:18:43.300]  которые вы по какой-то причине представляете в виде бинарного дерева поиска.
[02:18:45.300 --> 02:18:47.300]  Вы подсовываете эти два массива мерджу,
[02:18:47.300 --> 02:18:50.300]  и мердж их вам склеивает за логарифмическое время.
[02:18:52.300 --> 02:18:55.300]  То есть из-за того, что мы избавились сейчас от ключей,
[02:18:55.300 --> 02:18:57.300]  мердж вообще никак не пострадал.
[02:19:00.300 --> 02:19:02.300]  А что со сплитом?
[02:19:03.300 --> 02:19:07.300]  Со сплитом проблема. Вроде как сплит хочет нам ключи.
[02:19:11.300 --> 02:19:15.300]  Давайте исправим сплит так, чтобы он требовал не ключи,
[02:19:15.300 --> 02:19:17.300]  а требовал индексы.
[02:19:18.300 --> 02:19:21.300]  Скажем, мы хотим распилить дерево так, чтобы у нас там...
[02:19:21.300 --> 02:19:24.300]  Хотим распилить наше дерево по пятому индексу.
[02:19:26.300 --> 02:19:30.300]  Чтобы все элементы с индексами меньше чем пять оказались в одном дереве,
[02:19:30.300 --> 02:19:34.300]  чтобы все элементы с индексом больше либо рано чем пять оказались в правом под дереве.
[02:19:36.300 --> 02:19:42.300]  Мы избавились от ключей, но при этом вот эти самые значения 0, 1, 2, 3 у нас остались в неярном виде.
[02:19:44.300 --> 02:19:49.300]  Давайте просто возьмем и изменим сплит с х, то есть с ключей, на к.
[02:19:54.300 --> 02:19:56.300]  То есть сплит у нас теперь работает так.
[02:19:57.300 --> 02:20:03.300]  Я делаю сплит к, и он мне возвращает два массива.
[02:20:04.300 --> 02:20:09.300]  Массив, в котором k элементов, и в котором n-k элементов.
[02:20:10.300 --> 02:20:13.300]  Но при этом порядок элементов остается тем же самым.
[02:20:16.300 --> 02:20:19.300]  И заменить мне нужно всего лишь одну строчку, вот тут.
[02:20:20.300 --> 02:20:22.300]  На какое условие мне тут нужно заменить?
[02:20:26.300 --> 02:20:28.300]  Ну, смотрите, я нахожусь в корне.
[02:20:29.300 --> 02:20:31.300]  Чему равен индекс этого корня?
[02:20:35.300 --> 02:20:39.300]  Да, смотрите, индекс корня всегда совпадает с размером левого под дерево.
[02:20:41.300 --> 02:20:44.300]  Давайте, не знаю, это может не очевидно, но давайте так.
[02:20:45.300 --> 02:20:51.300]  Индекс корня, ну или ключ, давайте так, ключ корня,
[02:20:51.300 --> 02:20:54.300]  всегда равен размеру левого под дерево.
[02:20:56.300 --> 02:21:04.300]  То есть теперь вместо t стрелочка x, мне достаточно использовать size от t стрелочка left.
[02:21:06.300 --> 02:21:08.300]  Ну а вместо x0 я использую k.
[02:21:10.300 --> 02:21:11.300]  Вот и все.
[02:21:11.300 --> 02:21:12.300]  Давайте еще раз.
[02:21:14.300 --> 02:21:15.300]  Идея такая.
[02:21:16.300 --> 02:21:19.300]  Я хочу решать задачу RMQ RSQ на массивах.
[02:21:20.300 --> 02:21:24.300]  Но при этом так, чтобы моя структура данных позволяла мне выяснить,
[02:21:25.300 --> 02:21:29.300]  что у меня есть код рамки, у меня есть код код кодов и так далее.
[02:21:30.300 --> 02:21:31.300]  И это будет очень важно.
[02:21:32.300 --> 02:21:34.300]  Но это не будет иначе.
[02:21:34.300 --> 02:21:41.020]  Я хочу решать задачу rmq-rsq на массивах, но при этом так, чтобы моя структура данных
[02:21:41.020 --> 02:21:46.300]  позволяла осуществлять еще и логарифмические вставки и удаление из массива.
[02:21:46.300 --> 02:21:50.140]  Казалось бы, задача нерешаемая, потому что как бы вставлять и удалять элементы из массива
[02:21:50.140 --> 02:21:54.300]  можно только за линейное время. А я предлагаю следующую вещь.
[02:21:54.300 --> 02:21:59.740]  Я предлагаю, давайте я возьму все элементы и упорядочу их в виде, допустим,
[02:21:59.740 --> 02:22:02.940]  дикартового дерева, ну или вообще любого бинарного дерева поиска.
[02:22:02.940 --> 02:22:06.540]  Ну просто вместо ключей, то есть не буду использовать ключи, а буду использовать
[02:22:06.540 --> 02:22:12.460]  ну кату порядковую статистику, окей? То есть вот по структуре дерева я всегда
[02:22:12.460 --> 02:22:16.060]  могу понять, какой элемент у меня стоит на седьмом месте, какой у меня элемент стоит на третьем месте.
[02:22:16.060 --> 02:22:23.020]  Вот, я организую их вот в такую структуру. Ага. Как я этого добьюсь? Ну, очень просто.
[02:22:23.020 --> 02:22:30.460]  Я как бы буду реализовывать дикартовое дерево. С мерджом все в порядке, да?
[02:22:30.460 --> 02:22:35.580]  Мердж как у меня был, так он и остался. Сприт я просто немного изменю, ну просто заменю там ключ
[02:22:35.580 --> 02:22:41.980]  х на индекс к, и вместо там ключа х буду использовать размер левого поддерева. Вот и все.
[02:22:41.980 --> 02:22:50.940]  Ну давайте для примера, не знаю, посмотрим, как должна работать операция вставки.
[02:22:50.940 --> 02:23:00.940]  Вставка в произвольную позицию массива.
[02:23:00.940 --> 02:23:11.980]  Insert. Я хочу вставить элемент, допустим, в позицию k. Элемент со значением value.
[02:23:11.980 --> 02:23:21.580]  Ну и массив a. Ну давайте t. Массив у меня представляется в виде вот такого бинарного дерева.
[02:23:21.580 --> 02:23:27.980]  Что я должен сделать? Ну как и раньше, да? Я должен сделать split.
[02:23:27.980 --> 02:23:47.980]  То есть у меня был массив размера n, я разбил его на два массива. В одном количество элементов k, во втором n-k.
[02:23:47.980 --> 02:23:53.980]  Ну и все. И теперь я сюда вот между ними вставляю новый элемент v. И он как раз таки будет иметь индекс равный k. Согласны?
[02:23:53.980 --> 02:24:21.980]  Вот тут элементы в k, и этот элемент k. Ну то есть, как и раньше, return merge t меньше, чем k. Merge v, и t больше либо равно, чем k.
[02:24:21.980 --> 02:24:37.980]  Мерджу, вообще говоря, плевать на ключи, поэтому я просто говорю, что сначала должен идти массив t меньше k, потом должен идти массив, который получается в результате конкотинации элемента v и массива t больше либо равно, чем k. Вот и все.
[02:24:37.980 --> 02:24:49.980]  Как делать erase тоже понятно. Абсолютно точно так же. Просто вместо ключа в сплети используем порядковую статистику.
[02:24:49.980 --> 02:25:01.980]  Сдайте какой-нибудь вопрос, что непонятно осталось.
[02:25:01.980 --> 02:25:10.980]  Давайте пример приведем.
[02:25:10.980 --> 02:25:28.980]  Если вам дан некоторый массив, скажем, 5, 4, 1, 2, 0, то вы из этого массива можете построить какое-нибудь декартовое дерево.
[02:25:28.980 --> 02:25:34.980]  То есть вы генерируете приоритеты. Какой-нибудь приоритет здесь, какой-нибудь приоритет здесь, приоритет здесь, приоритет здесь.
[02:25:34.980 --> 02:25:40.980]  И дальше, собственно, в цикле вставляете элементы в нужную позицию.
[02:25:40.980 --> 02:25:44.980]  И у вас получается в итоге вот такое вот бинарное дерево. Ну, как пример.
[02:25:44.980 --> 02:26:05.980]  Может получиться другое. 5, 4, 1, 2, 0. Ой, неправильно. 5, 4, 1, 0.
[02:26:05.980 --> 02:26:13.980]  То есть на нулевой позиции у вас стоит 5, на первой позиции у вас стоит 4, на второй позиции стоит 1, на третьей 2, на четвертой 0.
[02:26:13.980 --> 02:26:16.980]  Ну, ровно то, как мы и хотели.
[02:26:16.980 --> 02:26:20.980]  Все, и теперь вот над этой структурой вы можете издеваться как угодно.
[02:26:20.980 --> 02:26:28.980]  Ну, снова, вы можете сделать запрос на отрезки. То есть вы хотите сделать запрос на отрезки от, скажем, от единицы до трех.
[02:26:28.980 --> 02:26:36.980]  Ну, тогда в терминах бинарного дерева поиска вы должны сделать запрос на отрезки, точнее, на полуинтерминале от единицы до четырех.
[02:26:36.980 --> 02:26:41.980]  Ну, ровно то, что мы делали раньше. Разрезаем сначала по единице, потом разрезаем по четверке.
[02:26:41.980 --> 02:26:43.980]  Смотрим результат там и так далее.
[02:26:43.980 --> 02:26:52.980]  Если вы хотите выполнить апдейт, то же самое. Вырезаете нужное вам дерево, ставите промец корень, и дальше дерево собирается обратно.
[02:26:53.980 --> 02:26:58.980]  Все. То есть по сути мы решили ту же самую задачу с помощью кода бинарного дерева поиска.
[02:26:58.980 --> 02:27:01.980]  Но, дополнительно у нас появилась следующая возможность.
[02:27:01.980 --> 02:27:04.980]  Мы можем вставить элемент в нашу структуру данных.
[02:27:04.980 --> 02:27:08.980]  То есть, допустим, я хочу вот сюда вставить минус единицу.
[02:27:08.980 --> 02:27:12.980]  Ну, очень просто. Вызываю вот этот инсерт.
[02:27:12.980 --> 02:27:18.980]  Теперь у меня, ну скажем, курс дат может получиться.
[02:27:19.980 --> 02:27:23.980]  Вот так пойдет? Нет, не пойдет.
[02:27:23.980 --> 02:27:28.980]  Ну, вот так, например. Да? Нормально?
[02:27:30.980 --> 02:27:34.980]  Ну, я не знаю, как там сделать декартовое дерево, но, например, как-то так.
[02:27:34.980 --> 02:27:42.980]  Все. То есть за логарифмическое время вы вставили элемент, и все значения там всяких сумм, минимум, максимум, все, что вам нужно, оно пересчиталось.
[02:27:42.980 --> 02:27:49.980]  Тоже за логарифм. Все. То есть мы теперь умеем выполнять операции на массивах, на их подотресках за логарифмическое время.
[02:27:49.980 --> 02:27:53.980]  При этом со всякими вставками удаления.
[02:27:53.980 --> 02:28:01.980]  Еще. То есть что еще мы умеем делать? На самом деле это еще более мощная структура данных, чем деревоотресков. Почему?
[02:28:01.980 --> 02:28:08.980]  Дело в том, что я могу выполнить такую операцию, как, ну, например, ротейт.
[02:28:08.980 --> 02:28:12.980]  Знаете, что делает ротейт? Ну, C++ в стандартной билетеке.
[02:28:18.980 --> 02:28:25.980]  Ну, ротейт, короче говоря, принимает массив и два его подмассива.
[02:28:25.980 --> 02:28:33.980]  И ротейт просто-напросто берет и меняет эти куски местами.
[02:28:34.980 --> 02:28:40.980]  В общем, в качестве упражнения подумайте, как это можно сделать за линейное время.
[02:28:40.980 --> 02:28:44.980]  Ротейт можно выполнить за линейное время.
[02:28:44.980 --> 02:28:52.980]  Но я утверждаю, что если вы организуете ваши данные в виде декартового дерева или в виде бинарного дерева поиска, то ротейт вы можете выполнить за логарифмическое время.
[02:28:52.980 --> 02:28:54.980]  Как?
[02:28:54.980 --> 02:28:58.980]  На две достаточно.
[02:28:59.980 --> 02:29:07.980]  Да, то есть вы сплитите дерево на две части, а дальше мержите в обратном порядке.
[02:29:07.980 --> 02:29:10.980]  Круто.
[02:29:10.980 --> 02:29:26.980]  То есть ротейт в случае, это просто сплит, плюс мерж в обратном порядке.
[02:29:26.980 --> 02:29:29.980]  И на это все еще навесили rsq и rmq.
[02:29:29.980 --> 02:29:39.980]  То есть вы решаете задачу rsq и rmq с запросами вида, там, не знаю, обновить там сумму на отрезке на плюс десять и поменять местами там два куска массива.
[02:29:42.980 --> 02:29:45.980]  Еще одна операция.
[02:29:45.980 --> 02:29:47.980]  Что еще можно выполнить?
[02:29:47.980 --> 02:29:53.980]  Короче говоря, на самом деле кажется, что сложно придумать, что нельзя сделать с помощью структуры данных.
[02:29:53.980 --> 02:29:57.980]  Но, например, можно еще сделать следующую вещь.
[02:29:57.980 --> 02:30:03.980]  Вы решаете там ту же самую задачу rmq и rsq со всякими суммами на подотрезке, обновления на подотрезке.
[02:30:03.980 --> 02:30:08.980]  И плюс иногда поступают запросы вида развернуть какой-то подотрезок.
[02:30:08.980 --> 02:30:17.980]  Вот вам дан насиль, и вам нужно взять вот этот подотрезок и развернуть его.
[02:30:17.980 --> 02:30:22.980]  То есть делать реверс.
[02:30:22.980 --> 02:30:26.980]  Как это сделать с помощью дерева отрезков, ну, вообще говоря, непонятно.
[02:30:26.980 --> 02:30:29.980]  А с помощью декартового дерева это можно сделать.
[02:30:29.980 --> 02:30:31.980]  Как?
[02:30:31.980 --> 02:30:33.980]  Как можно развернуть...
[02:30:39.980 --> 02:30:41.980]  Умножить на минус один, что это значит?
[02:30:47.980 --> 02:30:48.980]  Приоритеты на минус...
[02:30:48.980 --> 02:30:51.980]  Нет, приоритеты, вообще говоря, сложно менять.
[02:30:51.980 --> 02:30:53.980]  Нет, это не сработает.
[02:30:53.980 --> 02:30:56.980]  Приоритеты у вас считаются фиксированными.
[02:30:56.980 --> 02:31:00.980]  Вообще говоря, сплит и мерч не ожидают, что у вас в какой-то момент приоритеты меняются.
[02:31:00.980 --> 02:31:03.980]  Поэтому это, вообще говоря, тяжело.
[02:31:03.980 --> 02:31:05.980]  Но идея, на самом деле, правильная.
[02:31:05.980 --> 02:31:09.980]  Давайте вырежем нужный нам кусок дерева.
[02:31:09.980 --> 02:31:18.980]  То есть получили какую-то часть массива, которая отвечает за левую часть, которая не вошла,
[02:31:18.980 --> 02:31:23.980]  за правую часть, которая не вошла, и вот за центральный кусок, который нам нужно зареверсить.
[02:31:26.980 --> 02:31:28.980]  А давайте сделаем следующую вещь.
[02:31:28.980 --> 02:31:32.980]  Давайте не будем переворачивать, вообще говоря, массив долго, согласны?
[02:31:32.980 --> 02:31:34.980]  Переворачиваем с массива за линейное время.
[02:31:34.980 --> 02:31:38.980]  Давайте его не будем переворачивать, давайте сохраним обещание, что мы его когда-нибудь перевернем.
[02:31:40.980 --> 02:31:42.980]  То есть это будет такой отложенный переворот.
[02:31:42.980 --> 02:31:50.980]  То есть здесь мы сохраним промисс равно реверс.
[02:31:52.980 --> 02:31:54.980]  То есть мы не будем его переворачивать, мы сохраним обещание.
[02:31:54.980 --> 02:31:56.980]  Ну и склеим обратно.
[02:31:58.980 --> 02:32:00.980]  Вопрос. Как выполнять обещание переворота?
[02:32:00.980 --> 02:32:06.980]  Вот у меня есть вершина, которая говорит, что она реверст.
[02:32:06.980 --> 02:32:08.980]  И у нее есть два сына.
[02:32:08.980 --> 02:32:10.980]  Которые не знают, что они реверст.
[02:32:10.980 --> 02:32:15.980]  И вот в какой-то момент я делаю пуш, то есть говорю, что вот ты должен выполнить свое обещание.
[02:32:15.980 --> 02:32:17.980]  В чем заключается выполнение обещания в этом случае?
[02:32:23.980 --> 02:32:27.980]  Да. Всем понятно? Где? Кто украл?
[02:32:27.980 --> 02:32:29.980]  Всем понятно, в чем заключается пуш?
[02:32:30.980 --> 02:32:32.980]  Как выполнить обещание здесь?
[02:32:32.980 --> 02:32:34.980]  Нужно поменять лево и право с иными местами.
[02:32:40.980 --> 02:32:42.980]  Теперь это R, теперь это L.
[02:32:43.980 --> 02:32:45.980]  И дальше сказать, что вы перевернуты.
[02:32:47.980 --> 02:32:49.980]  И вот здесь.
[02:32:50.980 --> 02:32:52.980]  Теперь это R, теперь это L.
[02:32:53.980 --> 02:32:55.980]  И дальше сказать, что вы перевернуты.
[02:32:58.980 --> 02:33:00.980]  Реверст, реверст.
[02:33:00.980 --> 02:33:02.980]  А ты не реверст.
[02:33:04.980 --> 02:33:09.980]  Дальше, когда уже у детей попросят пуш, они в свою очередь будут что-то менять и так далее.
[02:33:16.980 --> 02:33:18.980]  Видимо пора заканчивать, но в общем резюме.
[02:33:19.980 --> 02:33:27.980]  Тут есть такая идея, которая называется деревья по неявному ключу.
[02:33:28.980 --> 02:33:32.980]  То есть вы избавляетесь от ключей и вместо ключей просто используете порядковые статистики.
[02:33:33.980 --> 02:33:37.980]  Что это вам дает? Это вам дает на самом деле функционал обычного массива.
[02:33:37.980 --> 02:33:42.980]  То есть вы каждому элементу теперь по ключу обратиться не можете, потому что вы ключи сами не храните.
[02:33:42.980 --> 02:33:45.980]  Но зато вы можете обращаться к элементам по их индексу.
[02:33:46.980 --> 02:33:49.980]  То есть, по сути, вы любой массив можете сохранить в виде бинарного дерева поиска.
[02:33:50.980 --> 02:33:54.980]  Что это нам дает? С одной стороны, это дает нам обращение к каждому элементу за алгорифм.
[02:33:54.980 --> 02:33:55.980]  Это дает нам...
[02:33:57.980 --> 02:34:03.980]  Вставку в конец за алгорифм, все то, что в обычном массиве вроде как делается за единицу, мы теперь делаем за алгорифм.
[02:34:03.980 --> 02:34:08.980]  Но верное и обратное. Все то, что мы делали до этого за линейное время, мы теперь можем делать за алгорифмическое.
[02:34:09.980 --> 02:34:11.980]  В частности делать вставку произвольное место массива.
[02:34:12.980 --> 02:34:14.980]  Удаление из произвольного места массива.
[02:34:14.980 --> 02:34:18.980]  всякие операции наподобие rotate, то есть поменять там два куска массива местами,
[02:34:18.980 --> 02:34:23.980]  или даже reverse, то есть взять какой-то кусок массива и перевернуть его за логарифмическое время.
[02:34:23.980 --> 02:34:33.980]  Данная структура данных значительно расширяет функционал и возможности применения массива к задачам RMQ-RSQ.
[02:34:33.980 --> 02:34:38.980]  На сегодня все.
[02:34:38.980 --> 02:34:46.980]  В следующий раз, напоминаю, в следующий раз у нас контрольная,
[02:34:46.980 --> 02:34:52.980]  видимо на второй половине, примерно в 4 часа начнем, в 5 закончим контрольную лекцию.
[02:34:52.980 --> 02:34:57.980]  В общем, будет контрольная по всем тем, которые мы обсуждали на лекциях.
[02:34:57.980 --> 02:35:03.980]  В следующий раз мы, скажем так, все, что касается последнего четвертого задания, мы обсудили.
[02:35:03.980 --> 02:35:07.980]  В принципе, никакого нового семинарского материала не будет.
[02:35:07.980 --> 02:35:11.980]  Этот семинар предстоящий и следующий семинар вы полностью обсуждаете,
[02:35:11.980 --> 02:35:14.980]  дикартово дерево и все остальное, все, что вы не успели обсудить.
[02:35:14.980 --> 02:35:17.980]  В следующий раз мы рассмотрим...
[02:35:17.980 --> 02:35:20.980]  Вообще говоря, я хотел задать вам вопрос, что нужно рассматривать,
[02:35:20.980 --> 02:35:22.980]  но потом я когда сюда шел, я уже сам принял решение.
[02:35:22.980 --> 02:35:26.980]  В следующий раз мы будем рассматривать задачу, которая тесно связана с RMQ-RSQ,
[02:35:26.980 --> 02:35:29.980]  но она как бы имеет такой, больше, наверное, теоретический смысл,
[02:35:29.980 --> 02:35:31.980]  чем практический.
[02:35:31.980 --> 02:35:34.980]  Просто рассмотрим, что еще можно в этой теме сделать,
[02:35:34.980 --> 02:35:37.980]  какие есть алгоритмы и так далее,
[02:35:37.980 --> 02:35:40.980]  без какого-то практического применения в контестах и так далее.
[02:35:40.980 --> 02:35:43.980]  Все, всем спасибо.
