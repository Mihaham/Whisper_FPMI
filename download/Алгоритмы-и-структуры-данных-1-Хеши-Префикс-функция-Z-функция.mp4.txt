[00:00.000 --> 00:23.000]  Давайте потихонечку начинать. Сегодня поговорим про простой линейный алгоритм.
[00:23.000 --> 00:31.000]  На строках простой линейный алгоритм. Строкой я буду называть просто последовательно из каких-то элементов.
[00:31.000 --> 00:42.000]  Часто я буду подразумевать, что все они лежат в каком-нибудь небольшом множестве.
[00:42.000 --> 00:52.000]  Вот такая самая модельная пример, когда все используемые буквы, это просто маленькие латинские буквы, буквы от латинского алфавита.
[00:52.000 --> 01:03.000]  Иногда это ограничение существенное, иногда не очень. В момент, когда это сыграют, я вернусь, пока можно считать, что, например, все буквы маленькие латинские, это нам ничего особенно не судит.
[01:03.000 --> 01:15.000]  Нас задачу не упростит, не усложнит. И, значит, первая, давайте, первый метод, который позволяет многие задачи на строках решать, это криминальное феширование.
[01:15.000 --> 01:30.000]  Ну и ей очень простая. Вместо того, чтобы хранить строку, мы хотим хранить число, а при том желательно не очень большое.
[01:30.000 --> 01:38.000]  Но давайте объявим, что для вот такой строки ее хешем является следующее выражение.
[01:38.000 --> 01:48.000]  S0 на p в степени n-1, plus S1 на p в степени n-2, plus и так далее, ну вплоть до последнего символа Sn-1.
[01:48.000 --> 01:56.000]  Вот, и все это взято по какому-нибудь модулю m, так, чтобы это вместилось в какое-нибудь нормальное тип данных, типа n-та.
[01:56.000 --> 02:02.000]  То есть, можно там m брать порядка 10 в девятке.
[02:02.000 --> 02:15.000]  Здесь S, это вообще формальные буквы, ну понятно, там по какому числу, это, например, просто надо прикосновать чарк n-2, и здесь номер символа в аске таблицы.
[02:15.000 --> 02:33.000]  Давайте напишем, что вот в этом выражении SE это либо под аске таблице, либо, ну, например, порядковый номер вот в этом алфавите.
[02:33.000 --> 02:40.000]  Если мы знаем, что у меня алфавит суженный и состоит не из всех вообще возможных символов, а только вот из этого небольшого количества,
[02:40.000 --> 02:49.000]  то можно их просто нумеровать, раз-два-три, и так далее, двадцать шесть, и сказать, что вот здесь вот подставляется порядковый номер этого символа вот в этом выражении.
[02:49.000 --> 02:59.000]  Вот, это порядковый номер в алфавите.
[02:59.000 --> 03:07.000]  Причем тут будет довольно важно, что у меня один индексация, то есть я не хочу нумеровать алфавитные символы с нуля,
[03:07.000 --> 03:14.000]  ну потому что если я скажу, скажу, что A это ноль, тогда у меня если строка состоит только из одних H, то у него всегда нулевой хэш.
[03:14.000 --> 03:20.000]  Ну это, наверное, не очень красиво, да, представьте, что у вас все S и H, тогда после конвертации они все будут нулями,
[03:20.000 --> 03:23.000]  и тогда вне зависимости от длины строки у вас здесь будет написано ноль.
[03:23.000 --> 03:29.000]  Ну, наверное, мы не хотим, чтобы уж такие простые строчки не различались нашими хэшами, поэтому у меня именно один индексация.
[03:29.000 --> 03:37.000]  Давайте это подчеркну, что это всего один индексация.
[03:37.000 --> 03:42.000]  Вот, такая не очень сложная вещь.
[03:42.000 --> 03:46.000]  Ну и давайте с ее помощью решим задачу.
[03:47.000 --> 03:53.000]  Задача о вхождении шаблонов текста.
[04:00.000 --> 04:06.000]  Представьте, что у вас есть какой-нибудь шаблон P и текст T.
[04:06.000 --> 04:13.000]  Ну на самом деле просто даны две строки, строка P и строка T, надо найти все вхождения P в T.
[04:13.000 --> 04:19.000]  То есть всюду, вот если вы прикладываете это маленькое окошко в T во всех возможных позициях,
[04:19.000 --> 04:25.000]  вот всюду, где символы в точности равны тому, что написано в P, надо найти все такие позиции.
[04:25.000 --> 04:31.000]  Ну, например, нужно сообщить там, где они все начинаются, то есть надо вывести вот этот индекс, вот этот индекс,
[04:31.000 --> 04:38.000]  ну если там еще где-то здесь вхождение, то вот этот индекс, вывести начало всех вхождений шаблонов текста.
[04:38.000 --> 04:42.000]  Вот, ну решается очень просто.
[04:42.000 --> 04:50.000]  Давайте посчитаем hash строки P, давайте посчитаем хеши всех подстрок T правильной длины, ну такой же как у P,
[04:50.000 --> 04:52.000]  и сравним эти хеши на равенство с P.
[04:52.000 --> 04:58.000]  Там, где получилось правильство хешей, мы будем считать, что у меня произошло вхождение строки P в T.
[04:58.000 --> 05:13.000]  Значит, найдем хеши всех подстрок длины P в строке T.
[05:18.000 --> 05:21.000]  Ну и там, где хеши совпали, будем считать, что получили вхождение P.
[05:21.000 --> 05:24.000]  Там, где хеши не совпали, будем считать, что вхождение нет.
[05:24.000 --> 05:32.000]  Вот, ну понятно, что это что-то довольно адекватное, потому что, смотрите, понятно, что если хеши, скажем, не совпали,
[05:32.000 --> 05:38.000]  вот если я посчитал где-нибудь хеш здесь, давайте это назову там, не знаю, ну S какой-нибудь.
[05:38.000 --> 05:46.000]  Вот, понятно, что если H от S не равно H от P, то S не равно P.
[05:46.000 --> 05:51.000]  Ну тривиально, да, то есть если я взял две строки, и у них не совпали вот эти значения,
[05:51.000 --> 05:53.000]  значит, как строки, они тоже, очевидно, разные.
[05:53.000 --> 05:59.000]  Вот, в обратную сторону не обязательно, да, не обязательно, что из равенства H следует равенство строк.
[05:59.000 --> 06:01.000]  Но мы будем считать, что это так.
[06:01.000 --> 06:12.000]  Здесь мы считаем, что равенство хешей увеличивает равенство строк.
[06:12.000 --> 06:20.000]  Ну понятно, как бы, да, ну уж вряд ли, наверное, вот такая вот такая стрёмная махина совпадает на двух разных строчках,
[06:20.000 --> 06:26.000]  вряд ли тут будет одинаковый число, да, там какой-то модуль, непонятно, какой-то P.
[06:26.000 --> 06:29.000]  Казалось бы, с чего будем быть равными на разных строках.
[06:29.000 --> 06:37.000]  Ну, как бы, понятно, что такое вообще бывает, конечно, да, мы большое пространство строк погружаем в маленькое пространство остатка формулы L.
[06:37.000 --> 06:41.000]  Понятно, что там будут коллизии, но мы хотим, как бы, что-то сделать.
[06:41.000 --> 06:43.000]  Но мы хотим, как бы, верить, что их мало.
[06:43.000 --> 06:49.000]  Вот, значит, почему их мало, да, почему есть надежда, что коллизий действительно не очень много.
[06:49.000 --> 07:02.000]  Почему есть надежда, что коллизий, ну коллизий, как всегда, это не равенство строк, но равенство хешей.
[07:02.000 --> 07:12.000]  Вот, почему таких штук мало.
[07:12.000 --> 07:23.000]  Вот, ну, например, потому что, если взять M каким-нибудь достаточно большим числом,
[07:23.000 --> 07:30.000]  ну, давайте я буду считать, что у меня P и T это строки какой-нибудь длинной порядка 10 в пятый, скажем,
[07:30.000 --> 07:37.000]  а M какое-нибудь большое число порядка 10 в девятый.
[07:37.000 --> 07:44.000]  Вот, дальше давайте скажем, что P выбирается случайно равной вероятности среди всех остатков по модулю M,
[07:44.000 --> 08:04.000]  то выбирается случайно среди чисел 0, 1 и так далее, и минус 1.
[08:04.000 --> 08:12.000]  Вот, ну и тогда ясно, что равенство хешей это на самом деле совпадение двух многочленов по модулю M в точке P.
[08:12.000 --> 08:21.000]  А равенство хешей, х х равно h от P, это на самом деле совпадение значений двух многочленов,
[08:21.000 --> 08:39.000]  совпадение значений двух многочленов степени не выше N в точке P.
[08:39.000 --> 08:50.000]  Ну, мы знаем, что у многочленов ZM, у многочленов степени M ZM, ну, по крайней мере с тем простое,
[08:50.000 --> 08:57.000]  корней не больше, чем N, да, потому что вроде бы есть в другом...
[08:57.000 --> 09:00.000]  Сейчас, а у нас P это строка или это перемена?
[09:00.000 --> 09:04.000]  А, пардон, коллизия, да, произошла у меня у самого.
[09:04.000 --> 09:13.000]  Ну, я не буду уж исправлять, но вот здесь вот P это число, да, вот здесь P это строка.
[09:13.000 --> 09:19.000]  Ну, окей, блин, а как это быстро? Давайте здесь когда быстро исправим, давайте здесь B, вот слов base.
[09:19.000 --> 09:29.000]  Да, извините, что-то я подумал, так это не надо. Вот, точка B.
[09:29.000 --> 09:36.000]  Вот вроде так. Ну и все, значит, а многочлены такой степени в таком вот конце могут совпадать
[09:36.000 --> 09:42.000]  не больше, чем в N точках, значит, вероятность попасть в общую точку не совпадает,
[09:42.000 --> 09:48.000]  то есть по факту мы находим корень такого многочлена в таком многочлене не больше, чем N корней,
[09:48.000 --> 09:52.000]  значит, вероятность в него попасть это примерно N делить на M.
[09:52.000 --> 10:02.000]  Вероятность попасть в корень примерно N, наверное.
[10:02.000 --> 10:08.000]  Ну и как бы это в целом уже, что было сейчас, 10-4 это что-то уже более-менее адекватное.
[10:08.000 --> 10:12.000]  Если мы там несколько раз возьмем, если мы возьмем несколько разных B, например,
[10:12.000 --> 10:17.000]  то вероятность каждый раз попасть в корень будет умножаться, N делить на M в степени,
[10:17.000 --> 10:21.000]  сколько раз мы взяли, если достаточно много раз посчитать hash в разных точках,
[10:21.000 --> 10:25.000]  то вероятность коллизий будет все меньше и меньше экспенциально убывать.
[10:25.000 --> 10:28.000]  Окей?
[10:28.000 --> 10:31.000]  Ну все, значит, осталось показать, как эти хаши везде высчитать.
[10:31.000 --> 10:36.000]  Ну понятно, для P мы как-нибудь посчитаем хаши, хэш точнее, мы просто поформуем.
[10:36.000 --> 10:40.000]  Теперь давайте все разберемся, как посчитать хаши под строк T.
[10:40.000 --> 10:45.000]  Ну тоже очень просто, давайте мы посчитаем хаши всех префиксов.
[10:45.000 --> 10:49.000]  То есть строка T, давайте посчитаем хаши всех ее префиксов.
[10:49.000 --> 10:57.000]  То есть преф IT это хэш для строки символа T0, T1 до T1.
[11:00.000 --> 11:05.000]  Так, ну считается вроде тридеально, почти как префиксные суммы.
[11:05.000 --> 11:11.000]  Значит, преф 0 это что, это просто T0, ну там по модулю M, если что.
[11:11.000 --> 11:18.000]  Вот, а преф следующее получается с предыдущего,
[11:18.000 --> 11:23.000]  доножением на P и прибавлением нового символа.
[11:27.000 --> 11:30.000]  Просто на формулу посмотрели, заметили, что это верно.
[11:30.000 --> 11:34.000]  У нас здесь M простой, да.
[11:34.000 --> 11:37.000]  Так, я опять переспользовал P, да, извините.
[11:37.000 --> 11:41.000]  А, M простой, ну вот здесь, да.
[11:41.000 --> 11:46.000]  Чтобы вот это утверждение по количеству корней по модулю ZM было верно,
[11:46.000 --> 11:49.000]  наверное надо, чтобы M было простым, да.
[11:49.000 --> 11:51.000]  Да, да, спасибо.
[11:51.000 --> 11:53.000]  Ну давайте.
[11:58.000 --> 12:02.000]  Так, это понятно, да, всем, что эта штука считает хаши всех префиксов.
[12:02.000 --> 12:05.000]  Ну а дальше, если посчитать хаши всех префиксов,
[12:05.000 --> 12:08.000]  давайте научимся считать хаши любой подстроки.
[12:21.000 --> 12:24.000]  Значит, как найти хаш подстроки?
[12:27.000 --> 12:33.000]  Здесь большая T, вот есть подстрока ее стрельба по R index,
[12:33.000 --> 12:35.000]  как найти ее хэш?
[12:35.000 --> 12:37.000]  Ну тоже очень похожа на префиксную сумму,
[12:37.000 --> 12:39.000]  давайте найдем префикс вот этого
[12:39.000 --> 12:43.000]  и вычтем вот это, ну префикс вот, точнее хэш вот этого
[12:43.000 --> 12:45.000]  с правильным префициентом.
[12:45.000 --> 12:50.000]  То есть я утверждаю, что ответ это следующее.
[12:53.000 --> 12:58.000]  f'-1 умножить на b в правильной степени.
[12:59.000 --> 13:08.000]  Ой, сейчас скажу, значит это будет rt, f'-1, вот вроде бы в плохой степени.
[13:13.000 --> 13:18.000]  В плюсах это неправильно отработано, там может от 30 нечислово звучит.
[13:18.000 --> 13:24.000]  Ну блин, извините, я не буду писать код на плюсах, я вот так вот хочу.
[13:28.000 --> 13:40.000]  Я не вдуюсь в детали реализации, в реализации я бы написал отдельный какой-то класс,
[13:40.000 --> 13:44.000]  который делает все вычтения по модулю m, умножит по модулю m, потом вычет по модулю m
[13:44.000 --> 13:46.000]  и не задумался бы, как она работает внутри.
[13:46.000 --> 13:48.000]  А мы не хотим поделить?
[13:48.000 --> 13:51.000]  Нет, а мы не хотим делить, потому что нам не надо учедить.
[13:51.000 --> 13:53.000]  Давайте напишем вот это, что такое.
[13:53.000 --> 13:54.000]  Что такое f'r?
[13:54.000 --> 14:00.000]  Это s0 на p в rт, плюс s1 на p в r-1, плюс и так далее.
[14:00.000 --> 14:07.000]  Дальше sl будет с коэффициентом что-то типа r-l, ну и так далее вплоть до sl.
[14:07.000 --> 14:10.000]  Что такое f'l-1?
[14:10.000 --> 14:17.000]  Это s0 на p в r-1, плюс s1 на p в степени r-2, плюс и так далее вплоть до sl-1.
[14:17.000 --> 14:19.000]  Если я вот это умножу ровно вот на f...
[14:19.000 --> 14:21.000]  Да что ж я так подешу, виноват.
[14:26.000 --> 14:29.000]  Если я вот это умножу на b в правильной степени,
[14:29.000 --> 14:34.000]  у меня вот эти вот товарищи сократятся все и останется то, что нужно в точности.
[14:34.000 --> 14:39.000]  У нас же степень при s0 будет b в rт, а должна быть меньше.
[14:39.000 --> 14:41.000]  Так я их вычту.
[14:41.000 --> 14:46.000]  Нет, степень будет здесь b в rт, я вычитаю b в r-1 умножу на b в степени r-1.
[14:46.000 --> 14:50.000]  Сейчас здесь будет b в rт, они как раз сократятся, а остается то, что нужно.
[14:50.000 --> 14:54.000]  Ну все, мы победили.
[14:54.000 --> 14:57.000]  Ну понятно, что там надо, чтобы это все работало супер хорошо,
[14:57.000 --> 15:01.000]  надо предпочитать все степени b, завести отдельный массив, куда сохранить все степени b,
[15:01.000 --> 15:04.000]  и дальше тогда я могу находить за единицу.
[15:06.000 --> 15:13.000]  Все, мы получили алгоритм, который за время линейное по суледленных строках
[15:13.000 --> 15:16.000]  находят все спаждения. Мы нашли хэш вот здесь,
[15:16.000 --> 15:18.000]  мы нашли хэши всех префиксов здесь,
[15:18.000 --> 15:21.000]  и затем для каждой строки правильной длины посчитали ее хэш за единицу,
[15:21.000 --> 15:24.000]  ну и сравнили на равенство.
[15:24.000 --> 15:28.000]  Все, это называется алгоритм равен акарбой, если вам это интересно.
[15:43.000 --> 15:46.000]  В целом хэши довольно хороший инструмент,
[15:46.000 --> 15:49.000]  позволяет решать много задач.
[15:49.000 --> 15:53.000]  Ну вот, говорю, иногда с какой-то вероятностью он может ошибаться.
[15:53.000 --> 15:55.000]  Причем здесь, в отличие от дикархового дерева,
[15:55.000 --> 15:57.000]  проблема не в том, что мы можем долго работать,
[15:57.000 --> 16:00.000]  а проблема в том, что мы как бы ответ можем неправильно вывести.
[16:00.000 --> 16:03.000]  Ну так же, как в кэш таблицах было в конце первого семестра,
[16:03.000 --> 16:05.000]  вот иногда мы можем ошибаться.
[16:05.000 --> 16:07.000]  Ну там как бы, а если несколько раз запустить,
[16:07.000 --> 16:10.000]  каждый раз выбирать новое b какое-нибудь случайное,
[16:10.000 --> 16:12.000]  тогда вероятность ошибки будет все меньше и меньше,
[16:12.000 --> 16:16.000]  поэтому мы надеемся, что почти такого никогда не происходит.
[16:16.000 --> 16:19.000]  Есть задачи, которые без хэшей я не умею решать.
[16:19.000 --> 16:21.000]  Ну там их мало, но они бывают.
[16:21.000 --> 16:24.000]  То есть поэтому этот инструмент,
[16:24.000 --> 16:26.000]  я вот сам довольно скептично отношусь к алгоритмам,
[16:26.000 --> 16:28.000]  которые иногда ошибаются,
[16:28.000 --> 16:31.000]  но иногда без них никуда.
[16:31.000 --> 16:33.000]  Ну а если вам нравятся такие, то прямо еще супер.
[16:33.000 --> 16:35.000]  Можно использовать.
[16:35.000 --> 16:38.000]  Можно проверять просто по синтезу?
[16:38.000 --> 16:40.000]  Мы нашли равенство с хэшей?
[16:40.000 --> 16:43.000]  Ну, к сожалению, тогда синтетика испортится.
[16:44.000 --> 16:47.000]  Ну конечно, но представьте, что у вас вот это вот из всех хэшек состоит,
[16:47.000 --> 16:48.000]  и это из всех хэшек.
[16:48.000 --> 16:50.000]  У вас везде хэши совпали,
[16:50.000 --> 16:52.000]  и вы по факту в тупую просто проверяете все на равенство.
[16:52.000 --> 16:55.000]  Многократно. Это будет по умножению на т.
[16:55.000 --> 16:57.000]  Это, к сожалению, грустно.
[16:57.000 --> 16:59.000]  Можно как-то выборочно проверять, конечно,
[16:59.000 --> 17:02.000]  но это непонятно, как вероятность будет в общем.
[17:02.000 --> 17:05.000]  Это сложно. Так не делают обычно.
[17:05.000 --> 17:08.000]  То есть если только гарантируется, что коллизий мало,
[17:08.000 --> 17:10.000]  что вхождения мало,
[17:10.000 --> 17:12.000]  тогда их можно вручную все проверить.
[17:12.000 --> 17:14.000]  А в общем случае непонятно.
[17:14.000 --> 17:16.000]  Так, идем дальше.
[17:16.000 --> 17:18.000]  Следующий алгоритм — это рефикс-функция.
[17:27.000 --> 17:29.000]  Это определение.
[17:29.000 --> 17:31.000]  Пусть есть строка,
[17:31.000 --> 17:33.000]  опять есть 0 и так далее,
[17:33.000 --> 17:35.000]  а сам у нас 1.
[17:35.000 --> 17:40.000]  А рефикс-функция — это набор чисел P0, P1, Pn-1,
[17:40.000 --> 17:46.000]  где P — это длина
[17:46.000 --> 17:51.000]  наибольшего собственного суффикса.
[17:56.000 --> 17:59.000]  Строки с нулевого символа купитой
[17:59.000 --> 18:03.000]  совпадают у вас с рефиксом той же длины.
[18:05.000 --> 18:22.000]  Вот, но суффикс-префикс, давайте на всякий случай напомним,
[18:22.000 --> 18:24.000]  если есть строка, то суффикс — это несколько ее
[18:24.000 --> 18:26.000]  последних символов,
[18:26.000 --> 18:28.000]  префикс — это несколько ее первых символов.
[18:28.000 --> 18:30.000]  Ну вот, префикс — это суффикс.
[18:30.000 --> 18:33.000]  Собственный, значит, отличный от всей строки.
[18:33.000 --> 18:36.000]  То есть нельзя взять в качестве суффикса всю строку,
[18:36.000 --> 18:38.000]  потому что тривиально полный суффикс строки
[18:38.000 --> 18:40.000]  тривиально равен полному префиксу строки.
[18:40.000 --> 18:42.000]  Строка равна само себе, это нам не интересно.
[18:42.000 --> 18:45.000]  Мы хотим следующий, кроме всей строки.
[18:45.000 --> 18:49.000]  То есть на собственный суффикс равен равный префикс.
[18:49.000 --> 18:53.000]  Например, если я нарисую какую-нибудь такую строчку,
[18:53.000 --> 18:58.000]  аба-аба, то в ней, видимо, вот эта вот,
[18:58.000 --> 19:00.000]  это максимальная такая строка,
[19:00.000 --> 19:02.000]  и суффикс, и префикс одновременно.
[19:02.000 --> 19:05.000]  Баба уже нельзя, а баба — это уже полная строка.
[19:10.000 --> 19:12.000]  Ну и соответственно префикс функции,
[19:12.000 --> 19:14.000]  просто массив удовельствия,
[19:14.000 --> 19:16.000]  называйте префикс функции.
[19:23.000 --> 19:25.000]  Ну давайте тривиально замечу,
[19:25.000 --> 19:27.000]  что здесь получается всегда,
[19:27.000 --> 19:29.000]  что P 0 — это 0.
[19:29.000 --> 19:31.000]  Как бы мы ни старались,
[19:31.000 --> 19:33.000]  потому что P 0 — это что такое?
[19:33.000 --> 19:35.000]  Есть у меня строка из одного символа,
[19:35.000 --> 19:37.000]  у нее, в принципе, единственный собственный суффикс —
[19:37.000 --> 19:39.000]  это пустая строка.
[19:39.000 --> 19:41.000]  Ну понятно, что пустая строка равна префику с той же длины,
[19:41.000 --> 19:43.000]  она равна пустой строке.
[19:43.000 --> 19:45.000]  P 0 будет нулевой всегда,
[19:45.000 --> 19:47.000]  ну и нам это, наверное, еще понадобится.
[19:50.000 --> 19:52.000]  Теперь давайте представим,
[19:52.000 --> 19:54.000]  что мы каким-то образом волшебным научились
[19:54.000 --> 19:56.000]  считать префикс функцию за быстро.
[19:56.000 --> 19:58.000]  Как решить ту же самую задачу
[19:58.000 --> 20:00.000]  о вхождении шаблонов в тексте?
[20:00.000 --> 20:02.000]  Уже без хэшей,
[20:02.000 --> 20:04.000]  с помощью префикс функции только.
[20:06.000 --> 20:08.000]  Давайте решение задачи напишем опять.
[20:14.000 --> 20:16.000]  Давайте...
[20:18.000 --> 20:20.000]  Давайте построим следующую страшную строчку.
[20:20.000 --> 20:22.000]  P — решетка T.
[20:22.000 --> 20:24.000]  То есть мы склеим две наши строки,
[20:24.000 --> 20:26.000]  паттерн и текст,
[20:26.000 --> 20:28.000]  с помощью вспомогательного символа решетка,
[20:28.000 --> 20:30.000]  где решетки больше нигде нет.
[20:30.000 --> 20:32.000]  Свежий символ, которого больше нет нигде в наших строчках.
[20:34.000 --> 20:36.000]  Дальше на этом безобразии
[20:36.000 --> 20:38.000]  посчитаем префикс функцию.
[20:40.000 --> 20:42.000]  Посчитаем P от S,
[20:42.000 --> 20:44.000]  но префикс функции до этой строки.
[20:44.000 --> 20:46.000]  И вот в этой строчке
[20:46.000 --> 20:48.000]  префикс функции,
[20:48.000 --> 20:50.000]  префикс функции до этой строки,
[20:50.000 --> 20:52.000]  префикс функции до этой строки.
[20:52.000 --> 20:54.000]  Давайте посмотрим, что это такое.
[20:58.000 --> 21:00.000]  Ну понятно, что
[21:00.000 --> 21:02.000]  всюду, где мы имеем вхождение P
[21:02.000 --> 21:04.000]  в текст T,
[21:04.000 --> 21:06.000]  скажем вот здесь,
[21:06.000 --> 21:08.000]  если вот это равно вот этому,
[21:08.000 --> 21:10.000]  то понятно, что вот в этой точке у меня
[21:10.000 --> 21:12.000]  P и T
[21:12.000 --> 21:14.000]  в точности равно глине P.
[21:16.000 --> 21:18.000]  Ну более-менее по определению,
[21:18.000 --> 21:20.000]  потому что если вот эти символы равны вот этим вот,
[21:20.000 --> 21:22.000]  то есть мы имеем входение P,
[21:22.000 --> 21:24.000]  то в этой точке, как минимум,
[21:24.000 --> 21:26.000]  вот эти все символы в количестве вот таком,
[21:26.000 --> 21:28.000]  равны вот этим символам.
[21:28.000 --> 21:30.000]  Суффикс для такого состояния
[21:30.000 --> 21:32.000]  это суффикс равен этому префиксу,
[21:32.000 --> 21:34.000]  ну если здесь реальное хождение.
[21:34.000 --> 21:36.000]  Ну а больше быть не может,
[21:36.000 --> 21:38.000]  у меня пишка не может быть больше,
[21:38.000 --> 21:40.000]  чем вот эта P, за счет этой решетки.
[21:40.000 --> 21:42.000]  Потому что если
[21:42.000 --> 21:44.000]  этот блок,
[21:44.000 --> 21:46.000]  суффикс равный префиксу внезапно содержит решетку,
[21:46.000 --> 21:51.000]  то значит эта решетка встречается где-то правее в моей строке, а это неверно.
[21:51.000 --> 22:00.000]  Если предположить, что p больше, чем длина p, то она содержит решетку, значит где-то она входит правее, а это неверно.
[22:00.000 --> 22:05.000]  Значит значение p никогда больше, чем p поднимется.
[22:05.000 --> 22:11.000]  Ну вот, поэтому мы доказали на самом деле, что множество позиций,
[22:11.000 --> 22:18.000]  где значение префикс функции совпадает с зеленой p, это множество окончаний всех вхождений p в t.
[22:18.000 --> 22:31.000]  Вот, значит, собственно, ровно здесь заканчивается вхождение p в t.
[22:31.000 --> 22:33.000]  И других позиций не бывает.
[22:33.000 --> 22:36.000]  Ну, потому что p не может быть больше, чем p.
[22:36.000 --> 22:41.000]  Если оно меньше, то понятное дело это сюда не входит, но если равно, значит вот как раз равенство.
[22:41.000 --> 22:44.000]  А тем самым мы описали в точности множество всех вхождений.
[22:44.000 --> 22:47.000]  Согласны?
[22:47.000 --> 22:52.000]  Хорошо.
[22:52.000 --> 22:58.000]  Значит нам осталось научиться эффективно находить рефикс функцию строки.
[22:58.000 --> 23:01.000]  А задачу с ее помощью мы уже решили.
[23:14.000 --> 23:18.000]  Так, теперь давайте научимся находить, собственно, префикс функцию.
[23:18.000 --> 23:27.000]  Давайте я для удобства вот это вот безобразие назову супрефиксом.
[23:32.000 --> 23:36.000]  Собственный суффикс, совпадающий с префиксом той же длины.
[23:36.000 --> 23:38.000]  Я буду называть такие штуки супрефиксом.
[23:38.000 --> 23:42.000]  То есть вот эти вот как раз блоки, суффикс, равный префикс, это у меня супрефикс.
[23:42.000 --> 23:45.000]  Типа одновременный суффикс и префикс.
[23:45.000 --> 23:50.000]  Причем собственный, то есть вся строка супрефиксом не считается.
[23:50.000 --> 23:57.000]  Значит мне нужно в каждой позиции и для вот такой вот строки с нулевого по этой символ
[23:57.000 --> 24:01.000]  найти просто самый длинный супрефикс.
[24:01.000 --> 24:04.000]  И это в точности длина максимального супрефикса.
[24:04.000 --> 24:06.000]  Давайте я это напишу.
[24:06.000 --> 24:20.000]  И это длина наибольшего супрефикса строки символов с нулевого по этой.
[24:26.000 --> 24:28.000]  Ну алгоритмы.
[24:31.000 --> 24:49.000]  Давайте будем идти по строке слева направо и итеративно по одному начитывать отношение pi.
[24:49.000 --> 24:53.000]  Давайте идти слева направо, посчитали pi 0, pi 1 и так далее pi и минус 1.
[24:53.000 --> 24:55.000]  Хотим посчитать новый pi.
[24:57.000 --> 24:59.000]  Пусть известные.
[25:01.000 --> 25:06.000]  Как найти pi?
[25:11.000 --> 25:15.000]  Ну если мы по списку предыдущего значения можем посчитать следующее,
[25:15.000 --> 25:18.000]  то поскольку мы знаем сначала, что pi 0 это всегда 0,
[25:18.000 --> 25:21.000]  значит мы можем посчитать все пишки.
[25:22.000 --> 25:24.000]  Так, хорошо.
[25:28.000 --> 25:32.000]  Как найти? Ну смотрите, вот есть, давайте я нарисую всю строчку,
[25:32.000 --> 25:35.000]  кроме последнего символа.
[25:39.000 --> 25:42.000]  Что мне нужно? Мне нужно найти максимальный супрефикс.
[25:42.000 --> 25:44.000]  Вот это вот равно вот этому вот.
[25:44.000 --> 25:47.000]  Самый длинный префикс, являющийся суффикс.
[25:47.000 --> 25:52.000]  Замечание первое, если я у любого супрефикса строки всей
[25:52.000 --> 25:54.000]  отброшу последний символ, Construction Symmetry Egg,
[25:54.000 --> 25:56.000]  то я получу супрефикс строки на 1 поменьше.
[25:58.000 --> 26:00.000]  Потому что что такое супрефикс большой строки?
[26:00.000 --> 26:01.000]  Это вот это вот, равно вот этому.
[26:02.000 --> 26:05.000]  Если я отброшу последний символ, то у меня и здесь отбросится символ,
[26:05.000 --> 26:07.000]  и здесь отбросится символ.
[26:07.000 --> 26:09.000]  Ну получу, супрефикс меньше под строки.
[26:10.000 --> 26:12.000]  Все длинно на 1 поменьше.
[26:12.000 --> 26:28.000]  Значит множество супрефиксов в предыдущей строке, потому что любой супрефикс большой строки порождает супрефикс меньшей строки длины на один поменьше
[26:28.000 --> 26:32.000]  Давайте я сделаю следующее, на самом деле это будет очень простой
[26:32.000 --> 26:36.000]  Давайте перебирать все супрефиксы, вот это предыдущие под строки
[26:36.000 --> 26:41.000]  И проверять, правда ли, что следующий за ним символ вот здесь такой же как здесь
[26:41.000 --> 26:55.000]  Ну и поскольку мы знаем, что один из супрефиксов, который мы ищем, ровно вот такой вид имеет, что после него стоит SI, то есть это такой супрефикс меньшей строки, который можно продлить вправо новым символом SI
[26:55.000 --> 27:03.000]  Давайте я просто перебирать все супрефиксы буду, найду из них максимальный, который вправо проглевается, то есть вот здесь вот за ним стоит символ SI
[27:03.000 --> 27:07.000]  И это будет в точности максимальный супрефикс новой строки
[27:07.000 --> 27:09.000]  Давайте это запишем
[27:09.000 --> 27:18.000]  Поскольку максимальный супрефикс, ну давайте сразу буду говорить, что новая строка
[27:18.000 --> 27:25.000]  Новая строка это с нулевого по итой, а старая это с нулевого по и минус первой
[27:25.000 --> 27:35.000]  Так вот, поскольку максимальный супрефикс новой строки
[27:35.000 --> 27:42.000]  После удаления последнего символа становится супрефиксом старой строки
[27:55.000 --> 28:12.000]  Значит, мне достаточно просто перебрать все супрефиксы старой строки и попытаться продлить их новым символом
[28:12.000 --> 28:22.000]  То достаточно перебрать все супрефиксы старой строки
[28:32.000 --> 28:35.000]  Ну и алгоритм на сами работает ровно так
[28:35.000 --> 28:39.000]  Ну и он перебирает все супрефиксы старой строки в порядке убывания длины
[28:39.000 --> 28:44.000]  И находит первый из них, то есть максимальный, который продлевается
[28:44.000 --> 28:51.000]  То есть за префиксом которого идет ровно тот же символ, который продлевается символом SI
[28:51.000 --> 28:55.000]  То есть я просто эти все супрефиксы буду перебирать в порядке убывания длины
[28:55.000 --> 29:00.000]  И первый продлевающийся символом SI будет тем, что нужно
[29:05.000 --> 29:13.000]  Так, теперь вопрос, как перебрать все супрефиксы
[29:13.000 --> 29:21.000]  Ну смотрите, я знаю, что P-1 это максимальная длина супрефиксов для старой строки
[29:21.000 --> 29:24.000]  Ну просто потому что вот, по определению на самом деле
[29:24.000 --> 29:27.000]  Вот эта штука длина максимального супрефикса
[29:27.000 --> 29:30.000]  Больше супрефиксов нет, значит это тот, с которого надо начать
[29:30.000 --> 29:35.000]  Да, это максимальный супрефикс, максимальный супрефикс старой строки
[29:42.000 --> 29:45.000]  Что дальше? Какой второй по максимальности супрефикс?
[29:45.000 --> 29:50.000]  Давайте я нарисую старую строчку побольше
[29:50.000 --> 29:53.000]  Вот представьте себе, что вот это вот было P-1
[29:53.000 --> 29:59.000]  И P-1
[29:59.000 --> 30:02.000]  Давайте рассмотрим второй по максимальности
[30:02.000 --> 30:04.000]  Второй порядка убывания по длине супрефикс
[30:04.000 --> 30:09.000]  Он какой-то вот такой
[30:09.000 --> 30:12.000]  Ну тогда на самом деле понятно, что вот этот второй супрефикс
[30:12.000 --> 30:18.000]  Это просто максимальный супрефикс для вот этой вот строки
[30:18.000 --> 30:20.000]  Ну потому что мне нужно вот в этой строке
[30:20.000 --> 30:23.000]  Оставить максимальный суп рефикс, который равен префиксу
[30:23.000 --> 30:25.000]  Ну а поскольку вот это вот, это вот это вот
[30:25.000 --> 30:26.000]  Поскольку это само по себе супрефикс
[30:26.000 --> 30:31.000]  Значит мне нужно просто в нем внутри супрефикс опять найти максимальный суп рефикс
[30:31.000 --> 30:33.000]  Потому что мне надо найти Alexis, равный префикс
[30:33.000 --> 30:35.000]  Ну и поскольку это одна и та же строка
[30:35.000 --> 30:38.000]  То мне нужно внутри вот этой одной строки найти опять такие 서фиксы, рав after gives
[30:38.000 --> 30:42.000]  Да?
[30:42.000 --> 30:46.000]  Давайте напишем, что второй по максимальности
[30:46.000 --> 31:11.000]  Второй по максимальности, это ну какая у него будет длина получается, мне нужно для вот этой вот строки, длины вот такой bx индексивной минус 1, взять максимальный субрефикс, это получается что-то вот в таком вот стиле, и именно 1 минус 1.
[31:11.000 --> 31:39.000]  Потому что еще раз, вот здесь вот эта вот строка, равная префиксу той же длины, мне нужно в ней найти максимальный субрефикс, но ее длина вот такая, значит последний индекс вот здесь, последний индекс, это bd минус 1 минус 1, ну если в ноль индексации живем, и мне нужно здесь взять опять такие значения b, потому что это хранит в себе максимальный субрефикс.
[31:39.000 --> 31:52.000]  Да? Все, ну и так дальше, если я знаю, то есть если я знаю текущий наибольший субрефикс, то следующий по максимальности это его максимальный субрефикс, который у меня и так уже хранится функцией p.
[31:52.000 --> 32:01.000]  То есть у меня вот есть вот эта вот строка, я ее приношу в начало, потому что это тоже самое, рефикс равен субрефиксу, и внутри него еще максимальный субрефикс с помощью значения функции p.
[32:01.000 --> 32:12.000]  Ну вот так. Все. Такой нехитрый угаритель. Давайте его напишем.
[32:31.000 --> 32:48.000]  Так, значит вот у меня есть какая-то строка, давайте я буду считать, что у меня есть string p, давайте я буду считать, что p — это ее длина.
[32:48.000 --> 32:55.000]  Ну и у меня есть вектор p, куда я складываю ответ.
[32:55.000 --> 33:00.000]  На массе значение префикс функции.
[33:00.000 --> 33:05.000]  Так, еще хочу ввести переменную g равную 0 изначально.
[33:05.000 --> 33:20.000]  Переменная g будет отвечать в точности вот за вот это вот значение. Сначала будет вот это, потом вот это, то есть g будет перебирать длину субрефикса текущего кандидата на тот субрефикс, который я хочу продлить новым символом.
[33:20.000 --> 33:22.000]  Изначально 0.
[33:22.000 --> 33:30.000]  Ну мы знаем, что p0 — это 0, поэтому значение p от 0 я явно считать не буду, а может здесь было бы прописать вот так вот его.
[33:30.000 --> 33:33.000]  Дальше я перебираю си и от 1 до n.
[33:33.000 --> 33:52.000]  В этот момент, смотрите, когда я захожу сюда, я буду сейчас поддерживать, что g хранит в длину максимального найденного субрефикса.
[33:52.000 --> 33:57.000]  То есть на самом деле g будет просто равно вот этому вот, p и минус 1.
[33:57.000 --> 34:01.000]  А вот в этот момент g равно p и минус 1.
[34:01.000 --> 34:04.000]  Так, p и минус 1.
[34:04.000 --> 34:08.000]  Теперь мне нужно найти вот этот максимальный субрефикс, который есть.
[34:08.000 --> 34:12.000]  Я хочу найти тот, который можно продлить направо символом s.
[34:12.000 --> 34:16.000]  Ну давайте тогда его уменьшать, пока он не продлевается символом s.
[34:16.000 --> 34:18.000]  Я сделаю это так.
[34:18.000 --> 34:27.000]  Пока g больше 0, то есть это материальный субрефикс, и он не продлевается тем символом, который нам нужен.
[34:27.000 --> 34:32.000]  То есть это плохой субрефикс, то есть это как бы субрефикс старой строки, но не продлевающийся новым символом.
[34:32.000 --> 34:35.000]  То есть s gтое не равно s itoе.
[34:39.000 --> 34:43.000]  Но поскольку g — это длина субрефикса, то как раз s gтое — это следующий за ним символ.
[34:43.000 --> 34:47.000]  Следующий вот за префиксом символ, который должен быть равен s.
[34:47.000 --> 34:51.000]  Я просто делаю вот то преобразование на правой доске.
[34:51.000 --> 34:54.000]  g равно p g и минус 1.
[34:54.000 --> 34:57.000]  Давай сделаем перерыв и вернемся.
[35:00.000 --> 35:03.000]  Вот этот вот цикл из двух строчек.
[35:03.000 --> 35:06.000]  Я вот это делаю ровно то, что мне нужно.
[35:06.000 --> 35:11.000]  Он перебирает все такие g, где g — это длина субрефикса старой строки.
[35:12.000 --> 35:15.000]  Вот это вот старой строки с 0 по s минус 1.
[35:15.000 --> 35:17.000]  Я перевираю все ее субрефиксы.
[35:17.000 --> 35:21.000]  Максимальный, потом второй по максимальности, третий по максимальности и так далее.
[35:21.000 --> 35:23.000]  Почему я делаю ровно вот это вот?
[35:23.000 --> 35:27.000]  Ну, значит, для всех содержательных g, давайте я буду выбрасываться, когда g равно 0.
[35:27.000 --> 35:32.000]  Если g положительно, то у меня получается сейчас рассматривать какой-то содержательный субрефикс.
[35:32.000 --> 35:35.000]  Вот это вот равно вот этому вот.
[35:35.000 --> 35:38.000]  Это текущий субрефикс, за которым...
[35:38.000 --> 35:42.000]  Потому что если g — это длина, то следующий за ним символ — это как раз s g,
[35:42.000 --> 35:45.000]  за которым не стоит то, что мне нужно.
[35:45.000 --> 35:48.000]  Значит, этот текущий субрефикс длины g мне не подходит.
[35:48.000 --> 35:51.000]  Мне же нужен субрефикс, продлевающийся направо символом s i.
[35:51.000 --> 35:56.000]  А этот не продлевается, потому что у него справа стоит s g, не равный s i.
[35:56.000 --> 35:59.000]  Значит, текущий субрефикс длины g мне не подходит.
[35:59.000 --> 36:04.000]  Мне нужен следующий по максимальности, то есть длины чуть поменьше.
[36:04.000 --> 36:09.000]  Но чтобы взять следующий по максимальности субрефикс, как я вот здесь вот показывал,
[36:09.000 --> 36:16.000]  мне достаточно в строке m g взять просто максимальный субрефикс.
[36:16.000 --> 36:19.000]  Ну а это в точности вот это вот, потому что g — это длина.
[36:19.000 --> 36:25.000]  Соответственно, строка с 0 по ds g – 1 как раз имеет вот ту самую длину.
[36:25.000 --> 36:29.000]  А это вот тот самый максимальный субрефикс, который у меня сейчас есть.
[36:29.000 --> 36:32.000]  И я в нем нахожу опять максимальный субрефикс.
[36:32.000 --> 36:34.000]  Я делаю просто такое преобразование.
[36:36.000 --> 36:37.000]  Согласны?
[36:38.000 --> 36:39.000]  Все.
[36:39.000 --> 36:43.000]  Значит, теперь, когда этот файл закончился, у меня верно два условия.
[36:43.000 --> 36:44.000]  Одно из двух точнее.
[36:44.000 --> 36:47.000]  Либо g занулилось, либо s g равно s i.
[36:49.000 --> 36:55.000]  Ну и если здесь в конце написать, что если s i равно s g,
[36:55.000 --> 36:57.000]  то надо сделать плюс плюс g.
[36:57.000 --> 37:01.000]  Давайте я не буду вводить твои вложности.
[37:01.000 --> 37:03.000]  Плюс плюс g напишу.
[37:03.000 --> 37:05.000]  Ну и в конце положить твердый g.
[37:06.000 --> 37:07.000]  Конец.
[37:09.000 --> 37:13.000]  Потому что как раз, да, у меня g сейчас это либо 0,
[37:13.000 --> 37:19.000]  либо максимальная длина субрефикса, продолжающаяся на новый символ.
[37:19.000 --> 37:22.000]  То есть как раз если оно продолжается, даже если же равно 0,
[37:22.000 --> 37:25.000]  даже если оно продолжается, я увеличиваю текущую длину.
[37:25.000 --> 37:30.000]  Ну потому что как раз за счет нового символа я могу продлить мой текущий субрефикс.
[37:30.000 --> 37:32.000]  Мне нужно же увеличить.
[37:32.000 --> 37:34.000]  Увеличиваю на 1.
[37:34.000 --> 37:36.000]  Ну и кладу его в P.
[37:37.000 --> 37:38.000]  Красиво.
[37:42.000 --> 37:43.000]  Все.
[37:43.000 --> 37:44.000]  Амбриктум закончился.
[37:44.000 --> 37:47.000]  Очень простой в плане реализации.
[37:55.000 --> 37:57.000]  Так, хорошо.
[37:58.000 --> 38:01.000]  Ну, корректность мы доказали, вроде как.
[38:01.000 --> 38:03.000]  Надо понять симптотику.
[38:03.000 --> 38:07.000]  Вот я обсуждаю, что время работы этого алгоритма есть вот это.
[38:10.000 --> 38:12.000]  Не очень сильно, на самом деле.
[38:13.000 --> 38:14.000]  Вот.
[38:14.000 --> 38:15.000]  Как это доказать?
[38:15.000 --> 38:17.000]  Ну давайте просто на термин g посмотрим.
[38:22.000 --> 38:25.000]  Смотрите, у меня есть одна глобальная g,
[38:25.000 --> 38:28.000]  которая при входе, ну то есть мне нужно было, чтобы g,
[38:28.000 --> 38:31.000]  при входе в очередную террацию, чтобы g было равно P-1,
[38:31.000 --> 38:35.000]  но как раз если я с прошлой террацию закончил таким присвоением,
[38:35.000 --> 38:38.000]  то как раз следующая террация g это в точности предыдущего значения P.
[38:38.000 --> 38:41.000]  Поэтому здесь у меня g конфликтов нет, это ровно то же, которое мне нужно.
[38:42.000 --> 38:47.000]  Ну понятно, что как у меня ведет себя g.
[38:47.000 --> 38:50.000]  Она при каждом i, возможно, максимум на 1 увеличивается,
[38:51.000 --> 38:54.000]  а каждая террация цикловая, ее уменьшает хотя бы на 1.
[38:54.000 --> 38:58.000]  Даже возможных хотя бы на 2, или это бред.
[38:59.000 --> 39:02.000]  Ну не важно, короче понятно, у меня был супрефикс дыны g,
[39:02.000 --> 39:04.000]  я беру его максимальный супрефикс.
[39:04.000 --> 39:06.000]  Понятно, что новое значение g меньше, чем старое.
[39:06.000 --> 39:09.000]  Я уменьшаю, я иду по супрефиксам в порядке убывания дыны.
[39:09.000 --> 39:12.000]  Значит каждая террация цикловая уменьшает g хотя бы на 1.
[39:15.000 --> 39:22.000]  Каждая террация цикловая уменьшает g хотя бы на 1.
[39:24.000 --> 39:29.000]  Вот.
[39:29.000 --> 39:32.000]  Ну а каждая террация цикловой увеличивает g максимум на 1.
[39:37.000 --> 39:40.000]  Каждая террация цикловой увеличивает g не больше, чем на 1.
[39:40.000 --> 39:42.000]  Значит суммарно вайлов линейное количество.
[39:42.000 --> 39:57.000]  А если g у меня может вырасти максимум на n, то есть у меня n это рацифора,
[39:57.000 --> 40:00.000]  каждая в худшем случае увеличивает g на единицу,
[40:00.000 --> 40:04.000]  значит максимально возможное значение g это как бы n-1.
[40:04.000 --> 40:06.000]  А каждый вайл его уменьшает на 1.
[40:06.000 --> 40:08.000]  Значит суммарно вайлов тоже o от l.
[40:08.000 --> 40:09.000]  Вроде все.
[40:09.000 --> 40:10.000]  Убедительно?
[40:10.000 --> 40:14.000]  Ну блин, если не убедительно, наверное можно вести потенциал
[40:14.000 --> 40:17.000]  фира внуши и что-нибудь с этим поделать.
[40:17.000 --> 40:18.000]  Но зачем?
[40:18.000 --> 40:28.000]  Кстати на сегодня линейн切节ная, а вот есть методом потенциалов appropriate.
[40:28.000 --> 40:32.000]  И что есть с этим поделать, но зачем?
[40:42.000 --> 40:46.000]  Ну, кстати, на самом деле интересно, а вот если методом бы это называть?
[40:46.000 --> 41:00.000]  А, нет, там надо, чтобы дельта фид была.
[41:00.000 --> 41:02.000]  Это упражнение надо?
[41:02.000 --> 41:04.000]  Это упражнение для тех, кто не поверил.
[41:04.000 --> 41:06.000]  А, в смысле?
[41:06.000 --> 41:08.000]  Что?
[41:08.000 --> 41:10.000]  Ну, мало ли.
[41:10.000 --> 41:12.000]  Вот.
[41:12.000 --> 41:14.000]  Так, вроде все.
[41:14.000 --> 41:20.000]  Вот, и третий, значит, алгоритм, который хочется рассказать, это z функция.
[41:20.000 --> 41:24.000]  Z функция.
[41:24.000 --> 41:30.000]  Тоже это, ну, там, еще одна штука, которая позволяет находить все входения шкалонов в текст.
[41:30.000 --> 41:34.000]  Так что, определение.
[41:34.000 --> 41:38.000]  Пусть есть строка.
[41:38.000 --> 42:00.000]  З функция, вновь, это массив чисел z0, z1, zk-1, где z и это, значит, ну, здесь как-то словами не очень получается написать.
[42:00.000 --> 42:16.000]  Вот максимальная такая карта, что прибыль с длинной карты равен под строке с этой позиции длинной карты.
[42:16.000 --> 42:18.000]  Такое формальное определение.
[42:30.000 --> 42:40.000]  Так, ну еще давайте я насильно скажу, что z0 и z0.
[42:40.000 --> 42:42.000]  Вот, значит, картинка.
[42:42.000 --> 42:46.000]  Есть у меня вся большая строка s.
[42:46.000 --> 42:48.000]  Что такое z и это?
[42:48.000 --> 42:52.000]  Это максимальный блок вправо равный перетепицу той же длины.
[42:52.000 --> 43:02.000]  Это вот как раз, максимальная такое к, что если вы вот здесь прочитаете k символов, то эти к символов то что нисти равно, то то, что написано в начале строки той же длины, а вот
[43:02.000 --> 43:05.000]  эти вот k символыvationы тут к этим вот костим.
[43:05.000 --> 43:09.000]  Иinf tel tags vo3, k максимально, значит.
[43:09.000 --> 43:13.000]  Вот, то есть если префикс функции это k-гово, мы находили максимальную строчку влево,
[43:13.000 --> 43:15.600]  равную префиксу той же длины, то теперь, наоборот, пишем villagers
[43:15.600 --> 43:21.000]  максимальную строчку вправо, равную префиксу той же длины.
[43:21.000 --> 43:30.000]  Если мы вдруг научились считать z-функцию, то давайте опять решим задачу по вхождению шаблонов текста.
[43:35.000 --> 43:37.000]  Давайте мы опять построим...
[43:40.000 --> 43:46.000]  Мне хочется опять построить эту строчку, прежде чем kt, найдем на ней z-функцию.
[43:47.000 --> 43:53.000]  И я утверждаю, что опять-таки все позиции, где zt равно длине p, это в точности вхождение p в t.
[44:00.000 --> 44:10.000]  Те позиции, где zt равно p по длине, это в точности такие позиции, что вот эти вот p-символов, идущие вправо, равны первым p-символам.
[44:10.000 --> 44:18.000]  Но значит, в точности мы получили вхождение p. Все позиции, где zt равно p, это начало вхождения p в t.
[44:19.000 --> 44:23.000]  Больше быть не может, zt быть больше, чем p не может, за счет как раз этой решетки.
[44:24.000 --> 44:33.000]  Но опять то же самое. Если бы у меня выводы где-то z больше, чем p, то у меня вот эта штука где-то бы правее сначала в строке, а значит где-то решетка встречалась бы кроме этой позиции.
[44:33.000 --> 44:43.000]  Такого не бывает. Значит у меня бывает максимум z равное p. Ну и понятно, что все вхождения дают такое значение, и наоборот, если значение такое, то значит мы получили вхождение.
[44:47.000 --> 44:56.000]  Вроде привиально показали, что все позиции, где zt равно p, это есть начало вхождения p в t. Да? Хорошо.
[44:56.000 --> 45:06.000]  Теперь давайте опять построим за линейное время z для строки s.
[45:26.000 --> 45:44.000]  Так. Мы будем опять такие типы строки слева направо и насчитывать z0, z1, z2 и так далее слева направо.
[45:44.000 --> 46:03.000]  Вот давайте пусть мы уже насчитали z0, z1 и так далее, z и минус 1. Давайте я еще вот эту вот штуку для удобства своего буду называть z-блоком.
[46:03.000 --> 46:11.000]  Ну это как раз вот тут строка просто. На самом деле под строка разная префикция столь длинная. Я это буду называть z-блоком.
[46:15.000 --> 46:27.000]  Так вот. Я нашел значение z функции на всех предыдущих точках. И давайте среди них я буду хранить координаты самого правого z-блока.
[46:27.000 --> 46:54.000]  Среди всех найденных храним границы lr самого правого z-блока. То есть того, у которого правая граница максимально.
[46:58.000 --> 47:06.000]  Да, ну потому что я когда нашел все вот эти вот z-ки, я нашел на самом деле много строк равных префиксу длины.
[47:06.000 --> 47:13.000]  И вот среди всех таких уже найденных я буду хранить самый правый. Тот, у кого правая граница самая большая. lr максимально.
[47:13.000 --> 47:22.000]  Ну пусть она у меня есть. Что делать дальше? Вот как найти z?
[47:22.000 --> 47:46.000]  Ну давайте порисуем. Вот это будет у меня строка s0 по lr.
[47:46.000 --> 47:55.000]  Пусть я предполагаю, что si где-то вот здесь вот. Внутри этого моего самого крайнего z-блока.
[47:55.000 --> 48:02.000]  Тогда можно сказать, например, следующее. Смотрите.
[48:02.000 --> 48:10.000]  Что такое z-блок? Это значит, что вот эта вот строка с lr symbol равна префиксу той же длины. Вот эта штука равна этой штуке.
[48:10.000 --> 48:17.000]  Давайте я посмотрю на тот символ, который равен si, который соответствует si вот в этом префиксе.
[48:17.000 --> 48:26.000]  То есть на самом деле это будет символ с номером i-l. Если я сдвину все вправо на l, то будет как раз этот символ совпадать вот с этим.
[48:26.000 --> 48:37.000]  Но смотрите, для него я уже знаю значение z функции. Ну потому что он находится где-то левее, я уже знаю, чему равно z с индексом i-l.
[48:37.000 --> 48:50.000]  И если это z с индексом i-l не большой и не вылезает за границы вот этого вот префикса, ну скажем, какой-то вот такой вот, тогда это и есть значение z3.
[48:50.000 --> 48:58.000]  Потому что, смотрите, вот пусть я знаю z2-l, это вот такой вот z-блок равный префикс той же длины.
[48:58.000 --> 49:02.000]  И эта штука не вылезает, даже не доходит до конца этого префикса.
[49:02.000 --> 49:11.000]  Но тогда, смотрите, я знаю, что эта штука равна вот этой штуке, потому что у меня инвесторки равны, и это же все равно префикс той же длины.
[49:11.000 --> 49:17.000]  А вот этот следующий символ уже, следующий символ, лежащий все еще в префиксе, уже не равен вот этому.
[49:17.000 --> 49:23.000]  То есть я не могу продлить мой z-блок в точке i-l, не могу продлить направо. То есть этот символ не равен вот этому.
[49:23.000 --> 49:28.000]  Значит, и в этой точке происходит то же самое. У меня сначала идет несколько символов равных префиксу,
[49:28.000 --> 49:36.000]  а потом идет символ, вот этот символ равный вот этому вот, не равный тому, чем нужно продолжить z-блок.
[49:36.000 --> 49:44.000]  То есть если у меня вот это вот все и следующий символ за ним все еще лежит в префиксе, то это равно вот этому и не равно вот этому.
[49:44.000 --> 49:50.000]  Поэтому z-блок в точке i уже найден. Это в точности z-i-l.
[49:50.000 --> 49:54.000]  Согласны?
[49:54.000 --> 50:11.000]  Вот. Ну давайте, значит, напишу, да, если i внезапно попало в отрезок с l по r, и при этом, то есть я хочу написать условие,
[50:11.000 --> 50:36.000]  что вот эта z-i-l приложенная в точке i не доходит до конца вот этого префикса.
[50:36.000 --> 50:49.000]  Вот если вот это верно, то z-i равно z-i-l. Это просто формализовал то, что здесь не срывал картинку.
[50:49.000 --> 50:57.000]  То есть если у меня i попало в отрезок, вот этот z-блок равный префиксу той же длины, если я смотрю значение z в точке i-l,
[50:57.000 --> 51:03.000]  и это вот значение в точке i, то есть i плюс z-i-l, вот эта вот позиция, она все еще лежит внутри моего префикса.
[51:03.000 --> 51:11.000]  То есть вот это поведение в точности такое же, как здесь. Эти строчки равны, поэтому эти символы равны, и оба не равны продолжению вот здесь вот этого префикса.
[51:11.000 --> 51:16.000]  Поэтому больше, чем столько набрать нельзя, потому что эти символы уже не равны, да, вот эти символы не равны.
[51:16.000 --> 51:19.000]  Ну а здесь все равно. Вот это вот равно, вот это вот равно, вот это вот.
[51:19.000 --> 51:25.000]  Поэтому это точное значение z-i. Да?
[51:25.000 --> 51:35.000]  Ну вот. А иначе, если так вышло, что z-i-l у меня очень большое... Давайте новую картинку нарисую.
[51:41.000 --> 51:52.000]  Если у меня z-i-l очень большое, какое-то вот такое вот, выходящее за пределы моего префикса, то я могу лишь только сказать, что z-i,
[51:52.000 --> 51:57.000]  по крайней мере, вот это вот r-r плюс 1.
[51:57.000 --> 52:04.000]  То есть я точно знаю, что вот это вот равно вот этому вот, и равно вот этому вот, потому что это значение z-блока.
[52:04.000 --> 52:07.000]  Значит, вот эта штука равна вот этой вот сдвинутой.
[52:07.000 --> 52:15.000]  Но я не могу сказать, что то, что происходит уже вне префикса, вне вот этого максимального z-блока, я про эти символы ничего не знаю, на то равны они вот этим или нет.
[52:15.000 --> 52:23.000]  Точнее, даже я знаю, что они не равны. А вот эта символ точно не равна этому вот.
[52:23.000 --> 52:32.000]  Значит, ну я могу точно по крайней мере сказать, что все, доходящее до конца вот этого z-блока, вот это вот, это тоже настоящий z-блок.
[52:32.000 --> 52:40.000]  Потому что все вот эти символы равны вот этим вот, и поскольку это значение z-блока в этой точке, то они же равны префиксу той же длины.
[52:40.000 --> 52:50.000]  Иначе, я могу по крайней мере сказать, что z-i больше либо равно, чем, ну вот эта вот длина этой строки с i-того по этой символ.
[52:50.000 --> 52:53.000]  То есть, больше, но очень короче.
[52:57.000 --> 53:05.000]  А если у меня есть нижняя оценка на z-i, то давайте я просто ее туда положу, а потом вступую, пойду по символам слева направо, буду проверять, равны они или нет.
[53:05.000 --> 53:11.000]  Ну то есть, я знаю тут нижнюю оценку, то есть я знаю, что такой префикс равен, точнее, вот это вот равно префиксу.
[53:11.000 --> 53:17.000]  Давайте просто идти вправо по этим символам и соответственно по префиксу той же длины, ну и проверять, там они равны или нет.
[53:17.000 --> 53:20.000]  И пока равны, я могу текущий z-блок увеличивать.
[53:22.000 --> 53:24.000]  Все, весь алгоритм.
[53:35.000 --> 53:43.000]  Так, давайте опять напишем.
[53:43.000 --> 53:56.000]  Опять есть строка с, есть ее длина, есть вектор значения z-функции.
[53:56.000 --> 54:21.000]  И мне еще нужно, вот если я в прошлом решении, если я в префикс функции хранил в предыдущем найденный максимальную субпрефикс, в переменной j, то здесь мне нужны глобальные переменные lper, ну в глобальном смысле, в рамках всех i, мне нужно поддерживать максимальный найденный z-блок.
[54:21.000 --> 54:26.000]  Ну давайте скажем изначально, что его нет, его координаты минус один и минус один.
[54:28.000 --> 54:32.000]  А потом в будущем я буду хранить там реальные координаты с самым правым z-блоком.
[54:36.000 --> 54:46.000]  Так, ну z нулевое у меня будет ноль, я его не считаю, считаю все, начиная с и равно единиц.
[54:52.000 --> 54:57.000]  Ну вот просто вот это давайте напишем сначала.
[55:00.000 --> 55:02.000]  Сейчас, сейчас, сейчас.
[55:06.000 --> 55:10.000]  Так, да, сейчас, надо, давайте подумаем.
[55:10.000 --> 55:38.000]  Ну да, если l меньше равно i и i меньше равно r, то давайте z и положим изначально минимум из z минус l и r минус и плюс один.
[55:40.000 --> 55:46.000]  Да, ну то есть как раз я вот это вот все учил.
[55:46.000 --> 55:53.000]  Если у меня текущий i попадает в самый правый z-блок среди тех, которые у меня есть, то у меня есть два варианта.
[55:53.000 --> 55:59.000]  Либо мне нужно просто туда положить z и минус l, если оно не вылезает за пределы вот этого вот префикса.
[55:59.000 --> 56:05.000]  Либо если вылезает, то нужно положить количество символов до конца префикса по ср минус и плюс один.
[56:05.000 --> 56:09.000]  Ну и минимальный из них будет как раз вот, как раз правильной границей.
[56:09.000 --> 56:19.000]  То есть у меня либо вот этот, либо вот этот, ну из них минимальная, но если это меньше, то будет вот это, а если это меньше, то будет вот это.
[56:19.000 --> 56:27.000]  То есть у меня сейчас в z и точно лежит какая-то нижняя граница на его правильном значении.
[56:27.000 --> 56:32.000]  То есть либо вот это и это уже даже точно, либо это просто какая-то нижняя граница, возможно ответ больше.
[56:32.000 --> 56:39.000]  Давайте пойдем пока можно следующий символ прочитать, и он будет равен тому, чем продолжается прессить.
[56:39.000 --> 56:44.000]  То есть пока вот этот символ равен вот этому, давайте увеличим z.
[56:44.000 --> 56:46.000]  Ну вот это и сделаем.
[56:46.000 --> 57:09.000]  То есть пока i плюс z i меньше n i s z i t равно s i плюс z i t делаю плюс плюс z i.
[57:09.000 --> 57:11.000]  Это вот в точности то, что я здесь нарисовал.
[57:11.000 --> 57:20.000]  Если я нашел какой-то текущий z block длины z i в позиции i, то вот этот символ следующий за ним имеет номер i плюс z i.
[57:20.000 --> 57:26.000]  А первый символ следующий за префиксом, который я должен проверять на равенство с этим, это просто z i.
[57:26.000 --> 57:30.000]  Ну потому что это длина, значит в ноль индексации будет тот самый символ.
[57:30.000 --> 57:32.000]  Следующий за префиксом.
[57:32.000 --> 57:34.000]  Все, пока они равны, я вывечу.
[57:34.000 --> 57:40.000]  То есть у меня после этой строчки в z i лежит какая-то нижняя граница на z i.
[57:40.000 --> 57:43.000]  То есть я знаю, что ответ в этой точке хотя бы то, что там лежит.
[57:43.000 --> 57:45.000]  Но дальше просто в тупую увеличу.
[57:45.000 --> 57:47.000]  Пока можно увеличу.
[57:52.000 --> 57:54.000]  Все, в конце нужно не забыть пересчитать lr.
[57:54.000 --> 58:03.000]  Если я во время этого вайла нашел какой-то более правый z block, то есть я вот тут шел-шел-шел и нашел какой-то новый вот такой вот z block.
[58:03.000 --> 58:09.000]  Если его правая граница правее чем старая правая граница, то мне нужно мою lr обновить.
[58:09.000 --> 58:18.000]  Если i плюс z i минус 1 больше чем r, то мне нужно сделать что?
[58:18.000 --> 58:24.000]  Мне нужно сказать, что при этом это i, а r это вот эта вот самая правая граница.
[58:24.000 --> 58:26.000]  i плюс z i минус 1.
[58:28.000 --> 58:30.000]  Конец.
[58:39.000 --> 58:54.000]  Так, вопросы будут? По корректности.
[58:54.000 --> 59:06.000]  Давайте еще раз повторю, что из вот этих рассуждений, которые мы здесь привели, следует, что после вот этого ifa у меня в z i лежит какое-то нижнее ограничение на настоящее значение z i.
[59:06.000 --> 59:14.000]  Если там какое-то нижнее ограничение, то давайте просто втуку и потом слева-направо будем идти проверять, увеличивать до настоящего правильного значения z i.
[59:14.000 --> 59:18.000]  Вы всегда либо close z block, либо...
[59:18.000 --> 59:20.000]  Еще раз?
[59:20.000 --> 59:23.000]  В нашей текущей позиции они всегда либо в z block, либо до него?
[59:23.000 --> 59:25.000]  Нет, может быть правее, конечно.
[59:25.000 --> 59:30.000]  Вполне себе, у вас мог закончиться этот блок lr и стать вот сюда.
[59:30.000 --> 59:34.000]  Ну тогда просто это не сработает, будет z i равно 0, и я втуку и его насчитаю.
[59:34.000 --> 59:36.000]  Это не страшно.
[59:39.000 --> 59:40.000]  Вот.
[59:40.000 --> 59:42.000]  Корректность вроде тогда понятна.
[59:42.000 --> 59:45.000]  Значит опять, синтотика почему-то работает за линейное время вновь.
[59:48.000 --> 59:51.000]  Потому что давайте посмотрим на r.
[59:51.000 --> 59:56.000]  Я утверждаю, что каждая итерация цикловая, она сдвигает r хотя бы на 1.
[01:00:05.000 --> 01:00:11.000]  Увеличивает, да, увеличивает r хотя бы на 1.
[01:00:12.000 --> 01:00:14.000]  Почему?
[01:00:14.000 --> 01:00:16.000]  Потому что
[01:00:16.000 --> 01:00:18.000]  Итерация цикловая
[01:00:18.000 --> 01:00:21.000]  могут происходить только в том случае,
[01:00:21.000 --> 01:00:25.000]  если вот здесь вот в минимуме был выбран вот этот вот товарищ.
[01:00:25.000 --> 01:00:28.000]  То есть это вот второй случай, который я здесь рисовал, да?
[01:00:28.000 --> 01:00:31.000]  Когда у меня z и –l большой,
[01:00:31.000 --> 01:00:34.000]  то есть у меня z и –l большой,
[01:00:34.000 --> 01:00:37.000]  то есть у меня z и –l большой,
[01:00:37.000 --> 01:00:40.000]  то есть у меня z и –l большой,
[01:00:40.000 --> 01:00:43.000]  и оно вылезает за пределы вот этого префикса,
[01:00:43.000 --> 01:00:47.000]  я его просто обрубаю концом предыдущего z-блока.
[01:00:47.000 --> 01:00:50.000]  То есть я говорю, что вот это вот текущее мое значение z и.
[01:00:50.000 --> 01:00:54.000]  А дальше, если что, я все вот эти вот символы перебираю просто,
[01:00:54.000 --> 01:00:57.000]  и если они равны, то увеличу z.
[01:00:57.000 --> 01:01:00.000]  Ну тогда понятно, что если я нашел символ равный тому, что чему нужно,
[01:01:00.000 --> 01:01:03.000]  у меня r точно сдвинется, потому что вот у меня z-блок,
[01:01:03.000 --> 01:01:05.000]  он раньше заканчивался в позиции r,
[01:01:05.000 --> 01:01:09.000]  а теперь с каждой новой итерацией цикловая он сдвигается направо на 1.
[01:01:09.000 --> 01:01:12.000]  Потому что я нашел символ, равный чему-то там, чему нужно,
[01:01:12.000 --> 01:01:15.000]  у меня z-блок расширяется направо.
[01:01:15.000 --> 01:01:17.000]  Ну все.
[01:01:17.000 --> 01:01:21.000]  В случае, когда i не лежало в отрезке lr,
[01:01:21.000 --> 01:01:23.000]  и здесь происходило увеличение,
[01:01:23.000 --> 01:01:26.000]  ну значит у меня было lr где-то вот здесь,
[01:01:26.000 --> 01:01:27.000]  и было где-то вот здесь,
[01:01:27.000 --> 01:01:30.000]  и я направо вот так и иду, увеличиваю вот эти символы равно вот этим.
[01:01:30.000 --> 01:01:33.000]  Ну значит опять-таки у меня r двигается хотя бы на 1,
[01:01:33.000 --> 01:01:36.000]  то есть у меня после вот этой итерации lr будет вот такое.
[01:01:37.000 --> 01:01:40.000]  Ну и каждая итерация val увеличивает правую границу на 1.
[01:01:43.000 --> 01:01:45.000]  Все.
[01:01:46.000 --> 01:01:49.000]  r всегда не больше, чем n-x1,
[01:01:49.000 --> 01:01:52.000]  значит сумма вот таких итераций было линейное количество.
[01:01:52.000 --> 01:01:54.000]  Ну все, а все остальное тут понятно,
[01:01:54.000 --> 01:01:56.000]  просто for какой-то, if, if.
[01:01:56.000 --> 01:01:57.000]  Проблема только в val,
[01:01:57.000 --> 01:02:00.000]  но мы доказали, что суммарно в итерации val было линейное количество.
[01:02:02.000 --> 01:02:05.000]  Можно еще раз спросить, почему если первое значение это не вот это,
[01:02:05.000 --> 01:02:08.000]  то у нас, ну, увеличу хотя бы на 1.
[01:02:08.000 --> 01:02:10.000]  Наоборот, со второй это не будет,
[01:02:10.000 --> 01:02:12.000]  потому что у нас будет 1,
[01:02:12.000 --> 01:02:14.000]  и у нас будет 1,
[01:02:14.000 --> 01:02:16.000]  и у нас будет 1,
[01:02:16.000 --> 01:02:18.000]  и у нас будет 1,
[01:02:18.000 --> 01:02:20.000]  и у нас будет 1,
[01:02:20.000 --> 01:02:22.000]  наоборот, со второй это меняет.
[01:02:22.000 --> 01:02:24.000]  Вот давайте вспомним,
[01:02:24.000 --> 01:02:27.000]  давайте вот первый случай, вот этот вот случай рассмотрим.
[01:02:29.000 --> 01:02:33.000]  Когда i плюс z i минус l меньше, чем r минус l,
[01:02:34.000 --> 01:02:37.000]  так, сейчас, дайте подумаю.
[01:02:39.000 --> 01:02:42.000]  А тут другой, да? Ща, ща, ща, момент, момент, момент.
[01:02:42.000 --> 01:02:44.000]  Потому что я с некрайним сам.
[01:02:46.000 --> 01:02:48.000]  Угу, с некрайним сам.
[01:02:48.000 --> 01:02:50.000]  Просто f должно был быть.
[01:02:53.000 --> 01:02:56.000]  Да, там был неправильный раз, но щас вроде правильный.
[01:02:56.000 --> 01:02:58.000]  Еще раз, смотрите, вот что происходит здесь.
[01:02:58.000 --> 01:03:00.000]  Это значит, был у меня вот такой вот z блок,
[01:03:00.000 --> 01:03:02.000]  вот это вот равно вот этому вот.
[01:03:03.000 --> 01:03:06.000]  Я рассматриваю точку i,
[01:03:06.000 --> 01:03:08.000]  ну и соответственно равну ей точку i минус l,
[01:03:08.000 --> 01:03:11.000]  потому что после сдвига этого блока на l влево,
[01:03:11.000 --> 01:03:14.000]  как раз получается та же самая строка, потому что это z блок.
[01:03:14.000 --> 01:03:16.000]  Давайте рассмотрим значение z и минус l.
[01:03:16.000 --> 01:03:18.000]  Вот оно.
[01:03:18.000 --> 01:03:23.000]  Если следующий символ за вот этой вот строкой длины z и минус l
[01:03:23.000 --> 01:03:25.000]  лежит все еще внутри этого префикса,
[01:03:25.000 --> 01:03:28.000]  то я точно знаю, что верно вот это вот равенство.
[01:03:30.000 --> 01:03:32.000]  Это соответственно происходит ровно в этом случае.
[01:03:32.000 --> 01:03:36.000]  Когда прикладывание в этой точке z и минус l символов
[01:03:36.000 --> 01:03:38.000]  оставляет меня левее вот этой правой границы.
[01:03:39.000 --> 01:03:41.000]  Хорошо.
[01:03:41.000 --> 01:03:44.000]  И в этом случае получается, если вот это произошло,
[01:03:44.000 --> 01:03:46.000]  а вот это вот на самом деле означало бы,
[01:03:46.000 --> 01:03:48.000]  что среди этих двух выбрался вот этот вот минимум.
[01:03:49.000 --> 01:03:51.000]  Ну потому что вот как раз z и минус l здесь равны,
[01:03:51.000 --> 01:03:53.000]  и r минус i плюс 1.
[01:03:54.000 --> 01:03:57.000]  Соответственно, если минимум это вот это вот,
[01:03:57.000 --> 01:04:00.000]  то дальше у меня ни одной итерации вала не произойдет,
[01:04:00.000 --> 01:04:02.000]  потому что этот символ не равен вот этому вот,
[01:04:02.000 --> 01:04:04.000]  и ни одного вала не произойдет.
[01:04:04.000 --> 01:04:08.000]  Иначе, если ситуация противоположная,
[01:04:08.000 --> 01:04:10.000]  и этот z блок очень длинный,
[01:04:10.000 --> 01:04:14.000]  и если он уходит за границу префикса,
[01:04:14.000 --> 01:04:19.000]  то я его обрубаю вплоть до этого символа
[01:04:19.000 --> 01:04:21.000]  и кладу как раз r минус i плюс 1.
[01:04:21.000 --> 01:04:24.000]  И только в этом случае может сдвигаться правая граница.
[01:04:27.000 --> 01:04:29.000]  Так, вроде все отказали.
[01:04:34.000 --> 01:04:36.000]  Так, у нас еще немного времени осталось,
[01:04:36.000 --> 01:04:38.000]  давайте попробуем еще один алгоритм.
[01:04:40.000 --> 01:04:42.000]  Сейчас.
[01:04:55.000 --> 01:04:57.000]  Или немного, сейчас.
[01:04:57.000 --> 01:05:00.000]  Так, давайте алгоритм Монайкера посмотрим.
[01:05:06.000 --> 01:05:08.000]  Четвертый прикол сегодня.
[01:05:09.000 --> 01:05:11.000]  Смотрите, задача такая.
[01:05:13.000 --> 01:05:15.000]  Ну, напоминание.
[01:05:15.000 --> 01:05:17.000]  Строка называется полиндромом,
[01:05:17.000 --> 01:05:19.000]  если она равна развернутой себе.
[01:05:20.000 --> 01:05:22.000]  А если записать справа-налево,
[01:05:22.000 --> 01:05:24.000]  получится то же самое строка весь.
[01:05:25.000 --> 01:05:27.000]  Задача такая.
[01:05:27.000 --> 01:05:31.000]  В каком-то смысле найдите все под полиндромом строки.
[01:05:32.000 --> 01:05:36.000]  Более формально давайте рассмотрим следующую картинку.
[01:05:36.000 --> 01:05:40.000]  Вот у меня есть один ямок,
[01:05:40.000 --> 01:05:42.000]  который, я думаю, в каком-то смысле ну,
[01:05:42.000 --> 01:05:45.000]  этот ямок, я думаю, он должен быть под полиндромом.
[01:05:45.000 --> 01:06:10.000]  Рассмотрим следующую картинку, вот у меня любой подполиндром это какая-то строка, у любого полиндрома есть центр, который либо находится в какой-нибудь букве, либо расположен между буквами.
[01:06:10.000 --> 01:06:33.000]  Более того, понятно, что если для какой-то позиции, давайте позиции считать букву или промежуток между буквами, понятно, что если в какой-то позиции такой подстрока с центром в этой позиции длины k является полиндромом, то подстрока длины k-2 тоже является полиндромом.
[01:06:33.000 --> 01:06:43.000]  Вот если есть центр, есть вот такой полиндром симметричный относительно этой точки, ну понятно, что если просто отрезать первый и последний символ, то останется полиндром в самом же центре.
[01:06:43.000 --> 01:06:56.000]  Поэтому я могу определить следующее, я могу для каждой центральной позиции задать максимальную длину крыла в обе стороны такой, что у меня получается префикс.
[01:06:56.000 --> 01:07:05.000]  Ну я раз я взял максимальную, то получается, что все более маленькие, получающиеся отбрасыванием символов с левой правой, тоже будут полиндромом.
[01:07:05.000 --> 01:07:14.000]  В этом смысле, если я для каждой центральной позиции нашел максимальный полиндром в обе стороны, то я нашел вообще все полиндромы, описал точнее все полиндромы.
[01:07:14.000 --> 01:07:23.000]  Это вот эти вот и все их вот так вот получающиеся под полиндромы, получающиеся отбрасыванием с двух сторон равного количества символов.
[01:07:23.000 --> 01:07:30.000]  Ну и соответственно задача для каждой центральной позиции, то есть для каждой буквы или для каждого промежутка между буквами,
[01:07:30.000 --> 01:07:37.000]  считая эту позицию центром полиндрома, найти максимальную крылу полиндрома.
[01:07:37.000 --> 01:07:43.000]  А вот если здесь там х, то соответственно вот эти вот х символов должны быть равные при чтении вот в таком порядке.
[01:07:43.000 --> 01:07:47.000]  Слева направо, справа направо.
[01:07:47.000 --> 01:07:52.000]  То есть в каком-то смысле надо описать все полиндромы из центра в каждой точке.
[01:07:56.000 --> 01:08:03.000]  Так, ну, наверное мы посмотрим, может мы не до конца его разберем, но идею я расскажу.
[01:08:05.000 --> 01:08:11.000]  То есть идея первая. Вместо того, чтобы париться и раздельно рассматривать вот эти два случая,
[01:08:11.000 --> 01:08:17.000]  когда центр полиндрома находится в букве или в промежутке между буквами, я сделаю сначала следующий трюк.
[01:08:17.000 --> 01:08:24.000]  Давайте я на примере строки вот такой вот, его покажу.
[01:08:24.000 --> 01:08:31.000]  Я вставлю просто какой-то фиктивный символ, типа решетки, между всеми символами, перед первым и после последним.
[01:08:31.000 --> 01:08:34.000]  То есть я буду рассматривать вот такую строчку.
[01:08:42.000 --> 01:08:49.000]  Тогда теперь все полиндромы, что такие, что такие, будут в качестве центра иметь символ.
[01:08:49.000 --> 01:08:54.000]  Потому что вот здесь вот, если у меня центр был в промежутке между символами,
[01:08:54.000 --> 01:08:59.000]  я туда вставил решетку, и эта решетка будет теперь центром полиндрома.
[01:09:00.000 --> 01:09:03.000]  Значит теперь я свою задачу, ну, два раза упростил.
[01:09:03.000 --> 01:09:07.000]  То есть мне не нужно отдельно рассматривать полиндромы четной или нечетной длины,
[01:09:07.000 --> 01:09:12.000]  мне достаточно установить только полиндромы нечетной длины, когда центр ровно в символе.
[01:09:13.000 --> 01:09:24.000]  В новой строке достаточно найти все полиндромы нечетной длины.
[01:09:24.000 --> 01:09:41.000]  Нечетные длины, то есть такие, центр которых это символ строки.
[01:09:45.000 --> 01:09:47.000]  Центр которых это символ.
[01:09:48.000 --> 01:09:53.000]  А не вот позиции между символами, как было в случае четкого полиндрома.
[01:09:58.000 --> 01:10:01.000]  Вот, все, то есть теперь у меня задача такая.
[01:10:01.000 --> 01:10:06.000]  У меня есть вот такая новая строка, давайте я ее переназову, это моя новая С.
[01:10:06.000 --> 01:10:07.000]  А новая строка С.
[01:10:07.000 --> 01:10:14.000]  Мне нужно для каждого И, для каждой позиции И, найти такое максимальное значение прям И.
[01:10:17.000 --> 01:10:36.000]  Что если рассмотреть вот эти МИ символов, начиная с И, заканчивая И, то вот это будет полиндром.
[01:10:36.000 --> 01:10:42.000]  Надо найти такое максимальное МИ, что если в качестве М взять крыло полиндрома,
[01:10:42.000 --> 01:10:46.000]  вот эту правую половину полиндрома, то это будет в точности полиндром.
[01:10:46.000 --> 01:10:49.000]  Среди всех таких найти максимальное МИ.
[01:10:49.000 --> 01:10:54.000]  Так, ну тут подсказывать хэши можно, конечно, делать хэшами, да.
[01:10:54.000 --> 01:11:00.000]  Можно, ну смотрите, мы умеем считать, мы умеем, ну я не буду вообще подробно описывать,
[01:11:00.000 --> 01:11:03.000]  но в общем можно бинп-уиском с помощью хэшей это сделать, это правда.
[01:11:03.000 --> 01:11:06.000]  Потому что по факту мне нужно проверять подстрочки на равенстве,
[01:11:06.000 --> 01:11:09.000]  мы можем проверить, что вот это вот равно развернутый вот это и вот.
[01:11:09.000 --> 01:11:14.000]  Там с разворотом как-нибудь разберемся, но а на равенстве проверять мы умеем с помощью хэшей.
[01:11:14.000 --> 01:11:17.000]  Вот это не спортивно.
[01:11:17.000 --> 01:11:22.000]  Собственно, мы могли бы также Z функцию считать, бинп-уиском по значению Z,
[01:11:22.000 --> 01:11:24.000]  проверять на равенстве подстрок.
[01:11:24.000 --> 01:11:28.000]  Вот, теперь давайте спортивно это сделаем.
[01:11:28.000 --> 01:11:32.000]  Делается очень похоже на Z функцию.
[01:11:32.000 --> 01:11:36.000]  Давайте идти по строке слева направо и поддерживать текущий самый найденный,
[01:11:36.000 --> 01:11:41.000]  фу ты, среди всех найденных самый правый подполиндром.
[01:11:41.000 --> 01:11:43.000]  Давайте я иду по строке.
[01:11:43.000 --> 01:11:49.000]  Нашел какой-то момент полиндром самой правой границы.
[01:11:52.000 --> 01:11:59.000]  Храним полиндром самой правой найденной границы.
[01:11:59.000 --> 01:12:11.000]  Полиндром самой правой найденной правой границы.
[01:12:16.000 --> 01:12:20.000]  Ну и дальше какой-то очень похожий разбор случаев.
[01:12:20.000 --> 01:12:30.000]  А именно, давайте считать, что внутри вот этого полиндрома,
[01:12:30.000 --> 01:12:34.000]  самого правого полиндрома, который я нашел, находится наша очередная позиция E.
[01:12:34.000 --> 01:12:36.000]  Вот она где-то здесь.
[01:12:36.000 --> 01:12:40.000]  Где нужно найти максимальный подполиндром.
[01:12:40.000 --> 01:12:44.000]  А у меня был максимальный подполиндром с центром вот этой точки.
[01:12:44.000 --> 01:12:48.000]  Так, давайте как-нибудь...
[01:12:48.000 --> 01:12:53.000]  Давайте я, поскольку это полиндром, то я могу вот эту картинку развернуть,
[01:12:53.000 --> 01:12:56.000]  и, соответственно, E у меня отродится вот куда-то сюда.
[01:12:56.000 --> 01:12:59.000]  Там это будет что-то в стиле, там, не знаю, 2G минус E.
[01:12:59.000 --> 01:13:07.000]  Короче, симметричная позиция для точки E относительно центра вот этого полиндрома.
[01:13:07.000 --> 01:13:09.000]  Добрый практик.
[01:13:09.000 --> 01:13:12.000]  Вот, давайте посмотрим M в этой точке.
[01:13:12.000 --> 01:13:16.000]  Если она более левая, то значение M мы в ней уже знаем.
[01:13:16.000 --> 01:13:21.000]  Если этот полиндром маленький и не вылезает за границы большого полиндрома,
[01:13:21.000 --> 01:13:28.000]  то значит, вот это вот и вот это вот два полиндрома, которые нельзя расширить влево-вправо.
[01:13:28.000 --> 01:13:30.000]  Потому что, что это значит?
[01:13:30.000 --> 01:13:34.000]  Значит, вот эти символы неравны, но поскольку это все один большой полиндром,
[01:13:34.000 --> 01:13:36.000]  вот эти символы будут неравны.
[01:13:36.000 --> 01:13:40.000]  Вот эти вот там. Здесь будет X, Y, а здесь Y, X.
[01:13:40.000 --> 01:13:43.000]  Неравны. Значит, его проглевать нельзя.
[01:13:43.000 --> 01:13:51.000]  Поэтому если M в точке какой-то противной, 2G минус E,
[01:13:51.000 --> 01:13:55.000]  не вылезает за границы текущего найденного полиндрома, самого правого,
[01:13:55.000 --> 01:14:00.000]  то мы в точности знаем M, оно просто равно вот этому вот.
[01:14:00.000 --> 01:14:04.000]  А если вылезает, это простой случай, тогда можно просто присвоить и пойти дальше.
[01:14:04.000 --> 01:14:06.000]  За единиц мы его нашли.
[01:14:06.000 --> 01:14:08.000]  Вот эта картинка такая.
[01:14:08.000 --> 01:14:10.000]  Это у меня был предыдущий центр.
[01:14:10.000 --> 01:14:12.000]  Вот у меня есть текущий И.
[01:14:12.000 --> 01:14:14.000]  Вот его отражение.
[01:14:14.000 --> 01:14:16.000]  Доживенский.
[01:14:16.000 --> 01:14:23.000]  Вот. И эта штука вылезает за границы полиндрома Эллера.
[01:14:23.000 --> 01:14:25.000]  Ну тогда я его могу обрубить опять-таки.
[01:14:25.000 --> 01:14:28.000]  Я могу его обрубить так, чтобы он помещался внутрь Эллера.
[01:14:28.000 --> 01:14:31.000]  То есть я его могу обрубить вот здесь, ну соответственно, симметрично.
[01:14:31.000 --> 01:14:33.000]  Где-то вот здесь он обрубится.
[01:14:33.000 --> 01:14:35.000]  Я знаю, что это тоже по отличному полиндрому.
[01:14:35.000 --> 01:14:38.000]  Который, возможно, можно расширять обе стороны.
[01:14:38.000 --> 01:14:43.000]  И если я его нарисую в центре в позиции E, то у меня получится что-то вот такое.
[01:14:43.000 --> 01:14:47.000]  И дальше, если я буду просто наивно перебирать вот эти вот точки,
[01:14:47.000 --> 01:14:50.000]  как бы точку справа и точку слева текущего полиндрома,
[01:14:50.000 --> 01:14:52.000]  если они равны, буду увеличивать.
[01:14:52.000 --> 01:14:54.000]  Тогда работает даже самая идея, что в Z-функции.
[01:14:54.000 --> 01:14:58.000]  Пока вот эти символы равны, я увеличиваю текущий M и E,
[01:14:58.000 --> 01:15:00.000]  а значит, в частности, увеличиваю R.
[01:15:00.000 --> 01:15:04.000]  Потому что если я проверю, что этот символ равен R и иду дальше,
[01:15:04.000 --> 01:15:08.000]  то у меня после этого текущий найденный самый правый полиндром сдвинется вот сюда.
[01:15:08.000 --> 01:15:11.000]  Потому что эта граница будет больше, чем R.
[01:15:11.000 --> 01:15:15.000]  Поэтому то есть здесь для этого конкретного E может быть несколько итераций цикловаяла.
[01:15:15.000 --> 01:15:18.000]  Пока вот эти символы равны, вот эти, вот эти и так далее.
[01:15:18.000 --> 01:15:23.000]  Но каждый итераций цикловаяла сдвигает текущий найденный самый правый полиндром R.
[01:15:23.000 --> 01:15:26.000]  Значит, суммарно, опять будет задание.
[01:15:26.000 --> 01:15:29.000]  Все, вот такая идея.
[01:15:29.000 --> 01:15:31.000]  Вроде все, кроме кода, я рассказал.
[01:15:31.000 --> 01:15:33.000]  Всем спасибо за внимание.
