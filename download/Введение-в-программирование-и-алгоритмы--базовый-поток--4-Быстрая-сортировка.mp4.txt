[00:00.000 --> 00:09.760]  И сегодня наша тема — это быстрая сортировка.
[00:24.920 --> 00:29.160]  Быстрая сортировка. Скорее всего, кто-то из вас уже слышал эти слова,
[00:29.160 --> 00:35.360]  может быть, даже что-то такое писал, может быть, видел, но не представляет, как это работает точно
[00:35.360 --> 00:42.760]  и почему это работает. Вот поэтому сегодня мы обсудим полностью и посвятим всю лекцию именно
[00:42.760 --> 00:48.520]  быстрой сортировки и оценки этого алгоритма. Как он происходит, какие у него есть модификации,
[00:48.520 --> 00:54.600]  что мы можем сделать. Вот. И этот алгоритм быстрой сортировки вы будете писать, но не в этом
[00:54.600 --> 01:06.120]  контесте, а в следующем. Вот. В этом у вас будет все чуть-чуть полегче. Вот. А это то, что касается вообще
[01:06.120 --> 01:13.040]  того, что вас ожидает впереди. У вас еще ждет задачи по алгоритмам, но их будет много потом.
[01:13.040 --> 01:23.080]  Пока что их немного. Быстрая сортировка. Кто из вас знает, что там самое главное? Выбрать
[01:23.080 --> 01:30.440]  барьерный элемент. А как он по-английски называется обычно? Пивот. Вот. Кто представляет,
[01:30.440 --> 01:36.480]  что такое пивот? Пивот — один из самых главных элементов, который мы должны всегда выбирать и
[01:36.480 --> 01:48.600]  что-то с ним делать. Кто представляет, что такое пивот? Хорошо. Вот сейчас некоторые люди опаздывают
[01:48.600 --> 02:01.640]  периодически. И вот. Так получилось. Вот. И до этого вы рассаживались. Вот девушка. Нет. А в очках
[02:01.640 --> 02:14.600]  с рыжими волосами. Сложно. Ну не с рыжими, но сложно. А как вас зовут? Вот вы, да, да, да. Как
[02:14.600 --> 02:29.080]  вас зовут? Я не слышу. Так. Ладно, хорошо. Рядом сидит Миша. Я хотя бы это знаю. Вот. Окей.
[02:29.080 --> 02:39.120]  А раз уж я не услышал, то буду говорить, что у нас Миша будет опорным элементом того ряда. Когда
[02:39.120 --> 02:46.760]  вы садились на ряд, вот для того, чтобы пропустить Мишу, вам бы всем по-хорошему бы встать и пропустить
[02:46.760 --> 02:53.120]  его на его место. И он является вот таким вот опорным элементом — тиранией Миши такая некоторая.
[02:53.120 --> 02:58.800]  Вот он приходит, и вам приходится вставать, чтобы он туда прошел. Ровно так же вам необходимо ставить
[02:58.800 --> 03:05.000]  какой-то конкретный элемент на его место и рекурсивно убирать отрезки. Вот молодой человек рядом,
[03:05.000 --> 03:24.080]  который сидит. Как вас зовут? А? Рядом с Мишей. Вы на меня, да. Ваня? Вот. А когда Миша сел за свое
[03:24.080 --> 03:31.560]  место, все усели, все хорошо. Но вот Ваня решил выйти куда-то. И включилась тирания Вани, но уже на
[03:31.560 --> 03:38.320]  другом маленьком отрезке. Вот таком вот подотрезке правой части вообще не нравится, видимо, там жить и там
[03:38.320 --> 03:43.760]  находиться, потому что постоянно то вставать надо, то садиться. И Ваня выходит, а потом обратно заходит
[03:43.760 --> 03:52.080]  и опять на свое место. Таким образом мы усадили сначала Мишу, а после этого и сел Ваня туда,
[03:52.080 --> 04:00.000]  куда он захотел и куда ему необходимо. Именно так работает по факту наша быстрая сортировка.
[04:00.000 --> 04:11.120]  Быстрая сортировка делает следующее. Первым действием выбирается так называемый пивот.
[04:22.120 --> 04:23.960]  Выбирается опорный элемент.
[04:37.960 --> 04:46.280]  Вторым действием. Что происходит вокруг этого опорного элемента? Мы ищем то место, куда должен он встать.
[04:46.280 --> 04:52.360]  Причем так, чтобы слева от него были элементы все меньше него, справа от него все больше него,
[04:52.360 --> 04:58.680]  ну либо больше, либо равны. То есть он занимает свое место в этом массиве где-то конкретно,
[04:58.680 --> 05:03.480]  посерединке, может быть чуть дальше, может быть чуть ближе, может быть в самом начале.
[05:03.480 --> 05:10.520]  Но он все равно занимает свое место, поэтому нам необходимо определить его место.
[05:16.280 --> 05:37.360]  Миша с Ваней точно определили свои места сразу же. Хорошо, мы определили место пивота, причем оно должно быть следующее.
[05:46.280 --> 06:13.360]  Все элементы левее меньше пивота.
[06:16.280 --> 06:43.360]  Все элементы правее больше пивота.
[06:46.360 --> 06:57.360]  Больше нашего опорного элемента. Вот, таким образом мы установили место, где находится данный элемент.
[06:57.360 --> 07:04.360]  Теперь давайте те отрезки, которые у нас остались, которые левее меньше пивота и которые правее больше пивота,
[07:04.360 --> 07:13.360]  запустим для них рекурсивно функцию, аналогичную тому же, что и здесь. То есть мы просто повторим ровно то, что мы хотели.
[07:16.360 --> 07:25.360]  Ровно то, что мы хотели.
[07:25.440 --> 07:53.440]  То есть мы повторяем наш алгоритм для левой и правой частей.
[07:53.520 --> 08:08.520]  Севдо кодом. Это выглядит достаточно просто, примерно так. Давайте на ту доску.
[08:08.600 --> 08:33.600]  Квик-сорт. Это рекурсивная функция. Это первый момент, который надо понять. Второе. Квик-сорт.
[08:33.680 --> 08:39.680]  Что принимает себя? Он принимает массив данных, левую и правую границу того, что он пытается отсортировать.
[08:39.680 --> 08:47.680]  То есть первый элемент, который мы выбраем, он будет отвечать за весь массив, дальше мы будем отвечать за части массива,
[08:47.760 --> 08:51.760]  после этого еще за меньшей части. И рекурсивно будем постоянно это делать.
[08:51.760 --> 09:06.760]  Поэтому, когда передается массив, левая и правая граница.
[09:06.760 --> 09:13.760]  Когда мы с вами это передаем, то все хорошо. Какое условие остановки рекурсии?
[09:13.840 --> 09:26.840]  Как вы думаете, какое условие остановки рекурсии?
[09:26.840 --> 09:32.840]  Должна остановиться? Наверное, да.
[09:32.920 --> 09:42.920]  Когда длина равны единице?
[09:43.000 --> 09:54.000]  Можно сказать, что пока мы будем делать рекурсию, то пока у нас левая меньше правая.
[09:54.080 --> 10:12.080]  То есть, если у нас левая граница больше либо равна, чем правая, если левая и правая совпадают,
[10:12.080 --> 10:20.080]  это один элемент как раз. Если левая граница больше либо равна правой, то
[10:20.160 --> 10:30.160]  я буду немного вставлять в псевдокод плюсовых вещей, то мы просто заканчиваем.
[10:30.160 --> 10:39.160]  Иначе мы с вами должны выбрать наш элемент и распределить все элементы левее и правее нашего пивота.
[10:39.160 --> 10:49.160]  И вот это все делает нам следующий пивот. Это все называется partition, то есть расстановка наших элементов.
[10:49.240 --> 10:59.240]  Поэтому мы здесь запускаем с вами partition.
[11:09.240 --> 11:15.240]  Зачем противное? Ну тут return, он так и закончит.
[11:15.320 --> 11:23.320]  Но partition у нас будет возвращать как раз таки сам пивот.
[11:23.320 --> 11:31.320]  Пивот это тот элемент, относительно которого мы пытаемся что-то делать, его местоположение.
[11:31.400 --> 11:35.400]  После этого мы должны
[11:45.400 --> 11:53.400]  рекурсивно от чего-то что-то вызвать. А, ну давайте еще будем кого-нибудь узнавать и спрашивать.
[11:53.480 --> 11:59.480]  Вот вы девушки, вот вы общаетесь как раз. Давайте.
[11:59.480 --> 12:05.480]  От чего нужно вызвать рекурсию? Одна скажет одно, другая другое как раз.
[12:05.480 --> 12:09.480]  От чего?
[12:09.480 --> 12:17.480]  От левой стороны. Левая сторона от чему равна? Ну массив А также передается. Левая сторона какая?
[12:17.480 --> 12:21.480]  Какие у нее границы?
[12:21.560 --> 12:29.560]  От левой до пивота.
[12:41.560 --> 12:45.560]  А теперь скажите мне, что здесь не так?
[12:45.640 --> 12:51.640]  От пивота минус один до пивота плюс один, потому что мы уже наш пивот поставили на нужное место.
[12:51.640 --> 13:01.640]  Поэтому минус один и плюс один. То есть у нас границы сдвигаются, мы один элемент поставили на нужное ему место.
[13:01.640 --> 13:09.640]  Вот, а теперь нам нужно понять, а что делать вообще с этим partition, что это такое и для чего он нам нужен.
[13:09.720 --> 13:15.720]  Давайте попробуем его и написать.
[13:15.720 --> 13:21.720]  Смотрите, в качестве опорного элемента можно выбирать любой элемент из вашего массива.
[13:21.720 --> 13:29.720]  Любой. Но я буду просто выбирать первый.
[13:29.720 --> 13:33.720]  Просто вот первый элемент на этой границе и будет моим опорным элементом.
[13:33.720 --> 13:37.720]  И с помощью него я и буду сортировать.
[13:37.800 --> 13:47.800]  Пока что мы напишем такой самый обычный, возможно тривиальный алгоритм быстрой сортировки.
[13:53.800 --> 13:57.800]  Давайте представим наш массив.
[13:57.800 --> 14:05.800]  Первый элемент, это как раз таки тот самый пивот, который у нас будет необходим.
[14:05.880 --> 14:11.880]  А что будет идти дальше? Вот как раз молодой человек, вот вы засыпаете.
[14:11.880 --> 14:17.880]  Да, как будет распределен массив и что у нас будет происходить?
[14:17.880 --> 14:21.880]  Вот мы выбрали пивот и первый элемент.
[14:21.960 --> 14:41.960]  Ну, для начала левая и правая границы определены.
[14:41.960 --> 14:45.960]  Так, как нам нужно раскидать массив?
[14:46.040 --> 14:52.040]  И заметьте, что вот эта правая граница не обязательно входит во весь массив.
[14:52.040 --> 14:56.040]  Вы можете лишь часть взять и отсортировать.
[15:02.040 --> 15:04.040]  Хорошо.
[15:04.040 --> 15:10.040]  Смотрите, еще раз, мы должны разделить наш массив на две части.
[15:10.040 --> 15:14.040]  Левая часть меньше пивота, правая больше пивота.
[15:16.040 --> 15:26.040]  Тогда мы наш пивот должны поставить как раз таки вот сюда.
[15:26.040 --> 15:36.040]  Вот в это место мы поставим пивот, поменяем его на это место и тогда он определит свое местоположение.
[15:36.040 --> 15:44.040]  Если встречается элемент равный пивоту, мы можем определить его и в правую, и в левую часть.
[15:44.120 --> 15:46.120]  Пока что.
[15:46.120 --> 15:48.120]  Пока для нас это без разницы.
[15:58.120 --> 16:02.120]  Он может оказаться чисто в начале или чисто в конце.
[16:02.120 --> 16:08.120]  У нас одна часть может быть вообще пустой, а одна часть может быть полностью.
[16:08.120 --> 16:10.120]  Да, это возможно.
[16:14.120 --> 16:18.120]  Еще раз, мы пивот определяем его место.
[16:18.120 --> 16:24.120]  Если элементов, например, у меньших пивота нет, мы останавливаемся на том, что он здесь и остается.
[16:24.120 --> 16:28.120]  Если вдруг у нас все наоборот больше пивота.
[16:28.120 --> 16:34.120]  Ой, все меньше пивота, тогда я его беру и ставлю в конец этого отрезка.
[16:34.120 --> 16:38.120]  То есть смотрите, мы пытаемся найти его место.
[16:44.120 --> 16:46.120]  Ну, примерно так и будет.
[16:46.120 --> 16:48.120]  Вот.
[16:48.120 --> 16:56.120]  То есть смотрите, давайте опишем наш partition.
[17:02.120 --> 17:04.120]  У него есть левые и правые границы.
[17:04.200 --> 17:08.200]  Я сказал, что мы выбираем опорным элементом наш первый элемент массива.
[17:14.200 --> 17:18.200]  Пусть это значение, которое там хранится, равно пивот-вэлью.
[17:18.280 --> 17:20.280]  Это было просто пояснение, что это массив.
[17:20.280 --> 17:22.280]  Вы будете вообще передавать его по указателю.
[17:22.280 --> 17:24.280]  Так.
[17:24.280 --> 17:26.280]  Вот.
[17:26.280 --> 17:28.280]  Вот.
[17:28.280 --> 17:30.280]  Вот.
[17:30.280 --> 17:32.280]  Вот.
[17:32.280 --> 17:34.280]  Вот.
[17:34.280 --> 17:36.280]  Вот.
[17:36.280 --> 17:38.280]  Вот.
[17:38.280 --> 17:40.280]  Вот.
[17:40.280 --> 17:42.280]  Вот.
[17:42.280 --> 17:44.280]  Вот.
[17:44.280 --> 17:46.280]  Вот.
[17:46.360 --> 17:48.360]  Вы будете вообще передавать его по указателю.
[17:48.360 --> 17:50.360]  Ну, как бы все.
[17:54.360 --> 17:56.360]  Вот.
[18:00.360 --> 18:06.360]  После этого мы должны с вами пойти по всем элементам и найти, грубо говоря, место нашего пивота.
[18:06.360 --> 18:08.360]  Как это делать?
[18:08.360 --> 18:12.360]  Давайте как только встретим элемент, ну, предположим...
[18:16.360 --> 18:18.360]  Давайте так.
[18:30.360 --> 18:32.360]  Пусть будет вот такой вот массив.
[18:32.360 --> 18:34.360]  Давайте так.
[18:38.360 --> 18:40.360]  Вот.
[18:40.360 --> 18:44.360]  А что мы будем пытаться здесь делать?
[18:44.440 --> 18:52.440]  Мы говорим о том, что пусть у нас есть, так сказать, место, куда нам необходимо вставить пивот.
[18:52.440 --> 18:58.440]  Первоначально это место так же указывает на самое начало.
[18:58.440 --> 19:00.440]  Там в начале.
[19:00.440 --> 19:02.440]  Ну, там.
[19:08.440 --> 19:10.440]  Pivot point.
[19:10.520 --> 19:14.520]  А как только мы встретили элемент, который...
[19:14.520 --> 19:20.520]  Вот этот меньше элемент, а этот больше элемент уже нашего пивота.
[19:20.520 --> 19:22.520]  Правильно?
[19:22.520 --> 19:24.520]  Что нам необходимо в этом случае сделать?
[19:24.520 --> 19:32.520]  Мы говорим о том, что если элемент меньше, мы двигаем наше место, куда должен стать пивот.
[19:32.520 --> 19:36.520]  Если элемент меньше, то мы его не двигаем.
[19:36.600 --> 19:40.600]  Больше, да, извините.
[19:40.600 --> 19:42.600]  Вот.
[19:42.600 --> 19:50.600]  И тогда мы будем постоянно свопать наш пивот с какими-то элементами, которые меньше него.
[19:50.600 --> 19:52.600]  Постоянно свопать между собой.
[19:52.600 --> 19:56.600]  И тогда мы получим с вами необходимое нам место.
[19:56.600 --> 19:58.600]  То есть, что я подразумеваю?
[19:58.600 --> 20:00.600]  Вот у меня пять, вот один.
[20:00.600 --> 20:02.600]  Я их...
[20:02.600 --> 20:04.600]  Элемент один меньше.
[20:04.680 --> 20:06.680]  Я их поменял местами.
[20:06.680 --> 20:08.680]  Так?
[20:08.680 --> 20:14.680]  После этого я прохожусь эти элементы больше моего пивота.
[20:14.680 --> 20:16.680]  Я их не трогаю.
[20:16.680 --> 20:18.680]  Но я встречаю элемент меньше.
[20:18.680 --> 20:20.680]  Тогда...
[20:26.680 --> 20:28.680]  Я получу вот такую последовательность.
[20:28.760 --> 20:32.760]  Но мне останется написать свой пивот в нужное мне место.
[20:32.760 --> 20:40.760]  Для того, чтобы это произошло, мне необходимо поменять вот эти места.
[20:40.760 --> 20:42.760]  Поменять между собой вот эти элементы.
[20:42.760 --> 20:48.760]  Первоначальный пивот-поинт в этом случае был ноль.
[20:48.760 --> 20:50.760]  Здесь уже один, здесь уже два.
[20:50.760 --> 20:52.760]  То есть, это индекс пивота.
[20:52.840 --> 20:56.840]  Таким образом, в конце я должен просто их свопнуть еще раз между собой.
[20:56.840 --> 21:00.840]  И тогда я получу, что относительно пивота, во-первых, все лежит слева.
[21:00.840 --> 21:02.840]  Все, что слева, оно меньше.
[21:02.840 --> 21:04.840]  Все, что справа, оно больше.
[21:06.840 --> 21:08.840]  Давайте допишем это.
[21:08.920 --> 21:11.520]  Мы идем от левой нашей границы плюс 1.
[21:11.520 --> 21:15.520]  То есть, кроме элемента пивота, до самой правой нашей границы.
[21:15.520 --> 21:17.760]  М Animation такая же, не это?
[21:17.760 --> 21:19.760]  Этоblic yeux.
[21:19.760 --> 21:21.760]  Это прин travailler.
[21:21.760 --> 21:37.900]  Ну-
[21:37.900 --> 22:02.480]  что мы говорим если а у этого и от этого индекса меньше значение пивота пивот
[22:02.480 --> 22:27.400]  вал вэлью правильно да давайте пример да пивот поинт верно спасибо
[22:32.480 --> 22:41.520]  пивот поинт левая граница первоначально он стоит как будто бы на своем месте
[22:41.520 --> 22:48.960]  если это так и тот элемент меньше тогда
[22:48.960 --> 23:09.760]  я увеличиваю свой пивот поинт и меняю какие элементы между собой
[23:12.520 --> 23:23.280]  ну а от этого индекса и а пивот поинт
[23:24.060 --> 23:37.600]  почему
[23:37.600 --> 24:03.840]  Так, первый. Правильно. Да, правильно.
[24:03.840 --> 24:26.480]  Но чтобы здесь сильно много не писать. Хотя, стойте, подождите. Сейчас left. Да,
[24:26.480 --> 24:53.640]  я понял. Можно. Да. Это я начал съезжать немножко. Вот, но после того, как у нас
[24:53.640 --> 25:04.880]  все это произойдет, нам необходимо с вами еще вот после этого фора взять и поменять.
[25:04.880 --> 25:31.000]  А от каких элементов? От pivot point. И что еще раз?
[25:31.000 --> 25:50.560]  Да. Вот. Именно поэтому я и писал в обратном порядке. Я сейчас объясню. Смотрите,
[25:50.560 --> 25:57.760]  когда мы нашли элемент меньше, то есть, ну вы сказали, я сделал, как хотели. А вот,
[25:57.760 --> 26:05.880]  но только теперь почему-то не работает. Смотрите, у нас есть с вами элемент pivot, вот этот. Да. Я
[26:05.880 --> 26:17.280]  хочу в конце взять и поменять его вот с этим. Он меньше, потому как я разделил. Я хочу, чтобы
[26:17.280 --> 26:30.880]  я в конце знал, где лежит мой pivot. А мой pivot лежит влево. Скажите, если я вот этот вот pivot
[26:30.880 --> 26:45.160]  point несчастный, который мы таскаем туда-сюда. Если я этот pivot point сделаю на единицу и буду
[26:45.160 --> 26:50.440]  менять даже первый с первым элементом или первый там с пятым, который меньше, то ли у нас будет
[26:50.440 --> 26:58.560]  хорошо работать? Да, все. Почему? Потому что вот здесь появится элемент, который меньше нашего pivot.
[26:58.560 --> 27:05.400]  А если он меньше, то в конце концов я могу их просто между собой потом в конце поменять,
[27:05.400 --> 27:13.360]  потому что у меня pivot point стал left plus 1. И тогда слева от него будет стоять меньше элементы,
[27:13.360 --> 27:27.280]  справа больше, а здесь сам pivot. Понятно или непонятно? Еще раз. Смотрите, я вот эту часть
[27:27.280 --> 27:37.520]  просто не трогаю. Я ее резервирую под свой pivot пока. Мне необходимо пройтись по вот этим вот
[27:37.520 --> 27:44.640]  элементам. Я их между собой раскидываю относительно пивота. Самые маленькие кидаю сюда,
[27:44.640 --> 27:52.080]  которые меньше пивота. Самые большие ничего с ними не делают. Они стоят-стоят. Вот, как только нашел
[27:52.080 --> 28:00.640]  маленький элемент, у меня pivot point сначала стоял на left. Я делаю plus-plus, показываю на первый. Самый
[28:00.640 --> 28:06.560]  маленький элемент, который меньше пивота, ну один из маленьких, я кидаю на первое место, вот сюда.
[28:06.560 --> 28:15.120]  Давайте это сделаем на примере. Понятно, что я примером вас запутал. Так, давайте.
[28:15.120 --> 28:21.680]  Можно. Я сегодня расскажу, какие есть еще способы.
[28:21.680 --> 28:40.040]  На самом деле, кстати, быструю сортировку, ну так, небольшая новостная справка.
[28:40.040 --> 28:48.800]  Быстрая сортировка, если вы где-то найдете название сортировка хара, это ровно она же. Он
[28:48.800 --> 28:56.200]  придумал ее в стенах МГУ, если что. Он приехал сюда на конференцию, и вот придумал в 1960-м году,
[28:56.200 --> 29:03.040]  и все до сих пор ее и пользуются. И она действительно одна из самых быстрых. Давайте еще раз на примере.
[29:03.040 --> 29:27.440]  Пусть у меня есть такой вот массив. Вот мой pivot. Этот pivot я начинаю сравнивать со всеми
[29:27.440 --> 29:39.640]  элементами. Pivot pointer в начале ноль. Давайте его. Я его назову PP. Хорошо? Вот. В начале он ноль.
[29:39.640 --> 29:46.520]  Как только мы встретим единицу, он сначала станет единица, только потом поменяет единицу
[29:46.520 --> 29:57.520]  саму собой. Ну ничего страшного, она осталась на месте. Дальше мы смотрим. 6 больше, 8 больше,
[29:57.520 --> 30:08.480]  9 больше, 11 больше. Пойнтер наш не двигаем. 3 оказалось меньше. Pivot pointer равен одному. Я
[30:08.480 --> 30:22.520]  прибавляю к нему единицу, получаю 2, и поэтому я тройку меняю со вторым элементом. То есть на
[30:22.520 --> 30:49.960]  вот этот момент у меня массив 5, 1, 3, 8, 9, 11, 2, 6. А, да, спасибо. 6, 2, да. Здесь точно правильно.
[30:49.960 --> 30:56.920]  Вот. После этого мы идем к двойке и видим, что двойка опять меньше. У меня pivot pointer
[30:56.920 --> 31:06.000]  становится равным 3. И в этом случае мы берем и меняемся.
[31:06.000 --> 31:25.320]  То есть смотрите, перед тем как, например, тот же Миша решил сесть, он всех подвинул,
[31:25.320 --> 31:33.760]  выбрал себе самое хорошее место, вот это, и только потом туда уселся. Поэтому в самом
[31:33.760 --> 31:50.920]  конце мы меняем между собой вот эти вот два элементика. Получаем 2, 1, 3, 5, 9, 11, 6 и 8. Понятно?
[31:50.920 --> 32:00.600]  То есть вот этот swap в конце от pivot pointer и от left. У меня же pivot pointer 3. То есть последний
[32:00.600 --> 32:08.200]  минимальный элемент, который мы слева вставили, это был вот на индексе 3. Все, отлично. На индексе
[32:08.200 --> 32:13.960]  3. Значит, если я поменяю с pivot, у меня не изменится здесь порядок, потому что слева все и так меньше
[32:13.960 --> 32:22.400]  pivot. Я останавливаюсь. Все, получаю вот такой вот массив. Вот мой pivot встал на нужное мне место.
[32:22.400 --> 32:29.600]  Вернуть мы должны pivot pointer. Да, все правильно.
[32:29.600 --> 32:54.040]  Таким образом, мы взяли и отсортируем наш массив. Потому что после этого мы рекурсивно
[32:54.040 --> 33:06.040]  вызываем от вот этой части и от вот этой части. Здесь pivot будет 2, здесь pivot будет 9. Относительно
[33:06.040 --> 33:13.840]  них сортируем каким-то образом. Получим примерно следующее, что после вызова рекурсии здесь у нас
[33:13.840 --> 33:28.640]  будет 1, 2, 3. Здесь у нас после рекурсии будет 6, 6, 9, 11. Останется здесь еще до
[33:28.640 --> 33:33.520]  рекурсии доделать, потому что мы не дойдем до вот этого условия иначе. Здесь мы уже дойдем.
[33:33.520 --> 33:49.280]  Вот так работает quicksort. Непонятно? Понятно. Тогда давайте с вами говорить о том,
[33:49.280 --> 33:58.480]  насколько он работает. Но давайте усно с вами решим наихудший случай. Наихудший случай здесь,
[33:58.480 --> 34:07.640]  представьте, что он должен сделать так, что какая-то из тестей полная, а другая пустая. То есть все
[34:07.640 --> 34:14.800]  элементы, которые были здесь, они есть отсортированные относительно pivot. Если я каждый раз буду
[34:14.800 --> 34:21.000]  выбирать слева, то у меня все плохо, потому что, к примеру, если у меня будет все больше pivot,
[34:21.000 --> 34:29.360]  я буду их свопать туда, свопать, свопать, свопать, свопать бесконечно много. И это плохо. То есть для того,
[34:29.360 --> 34:34.400]  чтобы у меня это не сработало, мне достаточно взять отсортированный массив. И тогда в этом
[34:34.400 --> 34:43.960]  случае сначала я возьму здесь так, что у меня n-1 своп будет, потом для другой будет n-2 свопов,
[34:43.960 --> 34:50.880]  для следующего n-3. Я буду потому что рекурсивно вызывать от вот этих частей, а другая часть пустая.
[34:50.880 --> 34:59.000]  Когда она пустая, мы там ничего не делаем. И тогда каждый раз, когда я буду вызывать n-1, n-2, n-3 для
[34:59.000 --> 35:07.000]  всех n-чисел, у нас, к сожалению, с вами будет сортировка работать за n квадрат. Понятно,
[35:07.000 --> 35:16.480]  почему? Сумма i-1 от 1 до n. Если посчитать, то это будет n на n-1 пополам. Вот n квадрат.
[35:21.760 --> 35:32.000]  Да, в этом случае. Вот. И тогда у нас все плохо. Как вы думаете, как это можно избежать?
[35:32.000 --> 35:42.200]  Рандомные элементы. Действительно, есть два способа избежать таких вот багов,
[35:42.200 --> 35:52.400]  чтобы она не работала просто так за квадрат. Первый способ выбрать пивот рандомно. У нас же
[35:52.400 --> 35:57.560]  здесь ничего по факту не зависит просто так от пивота. Ну, немножко алгоритм может поменять. Но
[35:57.560 --> 36:03.720]  все равно мы узнаем место пивота и туда его поставим. Правильно? Ну, здесь чуть-чуть надо
[36:03.720 --> 36:11.680]  будет переделать. Как это переделать? Сейчас сделаем. Второй способ – это рандомизировать
[36:11.680 --> 36:17.240]  данные перед тем, как мы начнем писать наш click sort. То есть рандомизировать весь массив.
[36:17.240 --> 36:23.320]  Если мы рандомизируем весь массив, нам не надо будет вызывать функцию run там n раз,
[36:23.320 --> 36:35.600]  а просто перемешаем массив между собой. Зачем другой partition? Другой partition – это не важно,
[36:35.600 --> 36:44.320]  но любой partition, если вы фиксируете пивот, у вас в любом случае есть алгоритм, который сделает
[36:44.320 --> 36:47.920]  это за n квадрат. Даже когда вы рандомно делаете, с очень маленькой долей вероятности,
[36:47.920 --> 36:57.040]  но он тоже возможен. Для любого такого массива все возможно. Поэтому, когда вы будете делать
[36:57.040 --> 37:06.760]  сортировку быструю, возможно такое, что на одном один раз запустите у вас бутель, отправите такой
[37:06.760 --> 37:14.160]  же код, и он зайдет, так как у вас будут там пограничные случаи. Вот, так что с этим нужно
[37:14.160 --> 37:23.280]  быть аккуратным. Но давайте сейчас оценим как-то, за сколько работает в среднем случае и почему эта
[37:23.280 --> 37:40.320]  сортировка так хороша. Пусть у нас есть список из n элементов. А в чем принципиальная разница
[37:40.320 --> 37:45.760]  будет наихудшего и среднего случая. Наихудшем случае мы говорили о том, что мы передвигаем
[37:45.760 --> 37:53.880]  элемент, а дальше мы опять делаем n-2 операции. Было до этого n-1, потом n-2 swap. В рандомизированном
[37:53.880 --> 38:02.320]  случае, когда мы делаем, у нас возможен следующий. То есть мало того, что у нас не факт, что оно встанет
[38:02.320 --> 38:07.480]  в самый конец, но даже если встанет в самый конец, есть вероятность того, что здесь находится минимальный
[38:07.480 --> 38:18.760]  элемент. Если их поменяем мы между собой, то в этом случае у нас будет такое, что тот элемент
[38:18.760 --> 38:25.440]  тоже двигаться не будет больше. Он так и останется. Иногда свопы стоят гораздо дороже проверки,
[38:25.440 --> 38:32.080]  поэтому здесь число n-версий может измениться благодаря тому, что мы что-то рандомизировали.
[38:32.080 --> 38:38.560]  Исходя из этого, мы говорим о том, что, видимо, не всегда оно работает за n-2. Для того, чтобы это
[38:38.560 --> 38:44.880]  оценить, необходимо будет решить рекуррентное соотношение. Сейчас объясню, что это такое,
[38:44.880 --> 38:55.760]  но как его решать, вам не скажу. Объясню сейчас следующее. Давайте скажем, что так как у нас
[38:55.760 --> 39:12.880]  пивот встает на любое из места, то пусть он встанет на место p. В этом случае у нас левая
[39:12.880 --> 39:19.640]  граница, у нас левая часть, от которой мы будем вызывать рекурсивный наш quicksort и правая часть,
[39:19.640 --> 39:34.400]  от которой будет вызываться quicksort, чему равна по длине? p-1, если мы для всего массива из n
[39:34.400 --> 39:47.680]  элементов смотрим. И n-p. Что это означает? Представьте, что количество сравнений,
[39:47.680 --> 39:54.280]  которое было для нашего элемента пивота, равно n-1. Все правильно? Так как мы должны сравнить его
[39:54.280 --> 40:04.400]  с каждым из этих элементов, этим формам. Если мы это делаем, то мы говорим, что наше рекурсивное
[40:04.400 --> 40:15.080]  от n, чему равно n-1, плюс, так как у нас все рендомизировано, нам необходимо взять и
[40:15.080 --> 40:27.440]  все возможные какие-то версии посчитать. Мы просто усредняем все результаты и говорим,
[40:27.440 --> 40:33.960]  что это усредненный результат от, если мы вызовем слева рекурс, у нас будет p-1, правильно?
[40:45.080 --> 41:06.120]  p может быть любое от 0 до n-1, поэтому мы можем сказать, что у нас именно вот так вот это считается.
[41:06.120 --> 41:24.080]  Точнее, давайте сделаем вот так. Что еще раз? Как у нас считается? Все нормально, да? Вот, то есть
[41:24.080 --> 41:31.160]  мы рекурсивно взяли и сказали, что количество действий для n элементов равно n-1 сравнение,
[41:31.160 --> 41:36.000]  плюс количество действий, которое будет с левого куска и количество действий,
[41:36.000 --> 41:40.880]  которое будет с правого куска. Так как нам необходимо посчитать для всех возможных случаях,
[41:40.880 --> 41:46.400]  мы берем и усредняем это по всем n-вариантам. n-вариантов, потому что p может занимать от 1 до n.
[41:46.400 --> 42:07.760]  Хорошо. Настроение константа. Мы взяли и усреднили эту сумму. Дальше нам необходимо просто посчитать
[42:07.760 --> 42:18.080]  здесь кое-что. Ну, смотрите, мы знаем с вами, что a от 1 элемента равно 0 и a от 0 равно 0.
[42:18.080 --> 42:32.400]  Все у нас там по времени успеем. Давайте замечем следующее, что a от i-1 и a от n-ы пробегают одни
[42:32.560 --> 42:43.960]  значения. Просто в разном порядке. При i равном единице, а здесь при i равном n, это 0. При i равном
[42:43.960 --> 42:54.840]  2, это 1. При n-1, это тоже 1. И так далее. Мы можем здесь на это всегда смотреть. И тогда это получается,
[42:54.840 --> 43:24.800]  что у нас двойная сумма просто. Я изменил порядок. Да, n-1 теперь.
[43:25.440 --> 43:33.240]  От 0. Получили такую штуку. Но какая-то не очень приятная рекурренту с учетом того,
[43:33.240 --> 43:39.960]  что здесь у нас a и n. Оно зависит от суммы всех возможных. Правда? Или вам нравится? Вы готовы
[43:39.960 --> 43:53.360]  анализировать эти штуки? Да, все верно. Смотрите, для того чтобы решить данную рекурренту и вывести
[43:53.360 --> 44:04.600]  a от n, от зависимости от a, n-1, достаточно посмотреть на вот это и посмотреть на a от n-1.
[44:24.200 --> 44:27.280]  Ну а здесь мы получим, что это
[44:27.280 --> 44:56.760]  а. Если мы вычтем друг из друга, то у нас все с вами будет хорошо. Единственное,
[44:56.760 --> 45:03.520]  что лучше бы добавить n-1? Это на n умножить, это на n-1. И тогда, если мы вычтем, то вот эти
[45:03.520 --> 45:12.320]  куски друг от друга уйдут. Это понятно? Ну вот. Давайте, чтобы сильно много выкладок каких-то
[45:12.320 --> 45:19.540]  не было, я вам напишу итоговую штуку. Я думаю, вы дома сможете разобраться с этим. Вот. Как
[45:19.540 --> 45:36.580]  домножить и что вычесть. Это я понимаю, что математика вас убивает. Тогда, в этом случае мы
[45:36.580 --> 46:05.700]  получим следующую рекурренту, что? Плюс. Ой, что? Спасибо, n-1.
[46:06.580 --> 46:20.560]  Если мы там все распишем, мы получим такую рекурренту. А вот следующий шаг, это будет точно вам
[46:20.560 --> 46:29.700]  упражнение. Как решить рекурренту и вывести зависимость от просто n. Есть два способа. Первый
[46:29.700 --> 46:39.780]  это разложение в ряды Taylor через производящую функцию. Второй способ это... Понимаю. Второй способ
[46:39.780 --> 47:01.180]  это немножко диффуров необходимо, поэтому здесь такое... А n делить на n-1? А на n-1. Так, и что тогда?
[47:09.780 --> 47:25.460]  Так тоже можно. Действительно. Вот. И получается, что если все это взять и посчитать, то в среднем
[47:25.460 --> 47:31.140]  случае у нас получится... Ну да, вы посмотрите, как решаются рекурренты, типа в общем случае,
[47:31.140 --> 47:40.180]  попробуйте самостоятельно еще порешать. Вот. А вы получите, что а от n это примерно...
[47:40.180 --> 48:07.860]  Примерно вот так. Вот это? Еще раз, смотрите. Когда у нас... Ребят, мы сейчас будем еще
[48:07.860 --> 48:17.260]  модификацию писать quicksort. Вот. Еще раз, смотрите. I and n. I and n. Это количество операций,
[48:17.260 --> 48:23.460]  количество сравнений, которое мне необходимо сделать для того, чтобы найти partition. Их всегда n-1. У меня
[48:23.460 --> 48:32.460]  цикл так построен. Их всегда n-1. Мне необходимо посчитать еще количество операций у p-1, у участка,
[48:32.460 --> 48:38.620]  который слева, и у n-p, участка, который справа. Он плюс-минус... Он константный сам по себе,
[48:38.620 --> 48:45.060]  в зависимости от размера. Тогда я беру их и суммирую между собой и усредняю. То есть,
[48:45.060 --> 48:50.100]  представь, ты получила все результаты. Там 10 различных результатов. Ты хочешь получить средний.
[48:50.100 --> 48:56.060]  Мы же средний случай считаем. Мы их усредняем по n, потому что их n штук, потому что partition может
[48:56.060 --> 49:01.460]  занимать место от 0 до n-1. Тогда все. Мы получили с вами вот такое вот рекуррентное соотношение.
[49:01.940 --> 49:22.180]  Вопросы? Нет. Смотрите. Момент. Сейчас. Ну ладно.
[49:22.180 --> 49:39.900]  У QuickSort есть две хорошие модификации, которые могут вам помочь. Потому что с такой модификации,
[49:39.900 --> 49:46.860]  если вы такое напишите в контест, поверьте, оно не зайдет. И я подозреваю, что часть из вас
[49:46.860 --> 49:52.860]  видела, когда там внутри цикла два вайла. Внутри вайла. Это тоже не зайдет. Вот. Там
[49:52.860 --> 50:09.660]  необходима немного другая вещь. Первая модификация звучит следующим образом. А давайте, а давайте,
[50:09.660 --> 50:15.700]  мы будем идти не только с начала всего вот этого списка, который у нас с вами был, и до конца,
[50:15.700 --> 50:22.020]  а с левой и справа. И с левой мы будем искать элементы больше, с правой мы будем искать
[50:22.020 --> 50:28.460]  элементы меньше. Если их найдем, мы свапнем их между собой. Вот о чем нам говорит первая часть.
[50:28.460 --> 50:36.740]  И это, возможно, и это будет первый partition, который мы с вами можем написать и сделать.
[50:36.740 --> 50:44.700]  В этом partition будут как раз-таки те два вайла, о которых, которые все очень сильно любят,
[50:44.700 --> 51:00.540]  и, чаще всего, именно такой quicksort и пишут. Давайте я напишу L и R, чтобы, ну давайте лучше left
[51:00.540 --> 51:25.340]  and right. Ладно. У нас есть массив левых и правых. Первая модификация. Два указателя.
[51:25.340 --> 51:36.180]  Этот partition, что он делает? Он говорит, ну хорошо, пусть у нас есть какой-то pivot,
[51:36.180 --> 51:45.460]  какой-то. Мы не знаем, какой. Иногда, так как я сказал, что мы можем pivot использовать любые
[51:45.460 --> 51:54.900]  штуки, ну любую вещь на самом деле, то pivot value это может быть любое. Очень часто вы можете
[51:54.900 --> 52:12.740]  встретить, что это просто средний элемент, и к нему тоже есть антимассив, на котором он будет
[52:12.740 --> 52:19.020]  работать за n квадрат, если вы не делали рандомизацию какую-то. Когда вы выберете
[52:19.020 --> 52:24.540]  средний элемент pivot, все будет действовать примерно аналогично. У вас будет какое-то
[52:24.540 --> 52:43.500]  какое-то и, равное левому, и ж, равное правому. Вы пишите while. Смотрите, в том суть этого метода,
[52:43.500 --> 52:50.580]  что как только у нас наши указатели на левую и правую часть начинают пересекаться, мы заканчиваем
[52:50.580 --> 52:58.540]  наш quicksort. Почему? Потому что указатель, который шел слева, он пытался найти элементы, которые
[52:58.540 --> 53:04.580]  больше, чтобы выкинуть из своей части. Указатель, который шел справа, он пытался найти элементы,
[53:04.580 --> 53:11.060]  которые будут меньше, чтобы выкинуть их влево. И тогда в этом случае мы пытались с ними что-то
[53:11.060 --> 53:18.380]  делать. А ровно это же здесь и необходимо. Однако, когда они начинают пересекаться, то вот в этом
[53:18.380 --> 53:23.780]  пересечении может лежать только pivot. Поэтому мы не должны больше там ничего делать. Поэтому мы
[53:23.780 --> 53:32.580]  пишем следующее. Пока и меньше, либо равно g. То есть пока наш указатель на левую часть такой же,
[53:32.580 --> 53:49.020]  как и на правую. Ну меньше, чем на правую. Да. Но если они равны, ну ладно. Хорошо. Пока это так.
[53:49.020 --> 53:54.740]  Что мы делаем? Нам необходимо найти место, которое нам не нравится с левой части и место, которое нам
[53:54.740 --> 54:12.020]  не нравится с правой части. Значит, мы пишем partition. Пивот-поинт был. Да. Но здесь pivot-поинт левый,
[54:12.020 --> 54:20.180]  pivot-поинт справа. Мы еще раз. Мы идем одним слева, другим справа указателем. Вот. Поэтому мы
[54:20.180 --> 54:24.740]  пытаемся левую часть освободить от всех элементов большую правую, а от всех элементов меньше. И
[54:24.740 --> 54:30.780]  чтобы у нас pivot стал, ну вот, в серединку, например. Ну попробуем, мало ли получится. Здесь пишутся
[54:30.780 --> 54:57.380]  также два цикла while. Пока it меньше, чем pivot-value. Пока вот оно меньше пивота, мы делаем плюс-плюсы.
[54:57.380 --> 55:19.940]  Мы и увеличиваем на единичку. Пока. А житое больше pivot-value. Пока житое больше, чем pivot-value.
[55:19.940 --> 55:33.580]  Мы делаем плюс-плюс жи. Ой, минус-минус, да. Извините, мы влево идем, да. Минус-минус жи. Мы это
[55:33.580 --> 55:39.580]  делаем с вами. После этого, когда у нас эти два цикла прошли, мы нашли элементы здесь, которые меньше,
[55:39.580 --> 55:46.700]  здесь, которые больше или бы равен. Это означает, что нам необходимо их между собой поменять местами.
[55:46.700 --> 55:54.980]  Однако, скажите мне, когда эти it-ы и j-ты перешли через друг друга, есть ли нам смысл менять их?
[55:54.980 --> 56:05.140]  Нет. Поэтому здесь пишется if, который предотвращает этот swap.
[56:05.140 --> 56:30.580]  Если и больше, либо равно жи, то мы останавливаем наш цикл. И после этого нам необходимо сделать swap.
[56:30.580 --> 56:46.580]  Давайте я туда перейду. Там осталось две строчки. После этого брейка, нам осталось сделать swap.
[56:46.580 --> 57:06.340]  Мы делаем этот swap, после чего мы говорим, что у нас плюс-плюс и минус-минус жи. Мы же поменяли эти
[57:06.340 --> 57:15.340]  элементы, значит уже рассматриваем только следующее. Понятно? Ну и после этого вне цикла, что должны
[57:15.340 --> 57:23.020]  вернуть? Или это еще не все, что мы сделали? Что нам нужно еще сделать?
[57:23.020 --> 57:34.660]  Пивот поставить на место и или жи. Как нам понять, где находится теперь пивот?
[57:45.580 --> 58:01.500]  Да, это правда. Нет разницы, потому что они одинаковые, если они вышли. То есть если они прошли,
[58:01.500 --> 58:14.860]  они же дойдут до каких-то равных уже в серединке. Нет разницы it или j-ты. Но в этом случае нам
[58:14.860 --> 58:42.420]  необходимо сделать swap. Все верно. Это такой partition. L plus R, no, left plus right.
[58:42.420 --> 58:59.220]  Все ли корректно или нет? Что некорректно? Где? Что еще раз?
[59:12.420 --> 59:20.420]  Пивот вэлью нам зачем посерединке? Здесь именно для этого пивот вэлью делается,
[59:20.420 --> 59:33.060]  а на серединке точно остановится. Пивот вэлью это L plus R пополам. В зависимости от того,
[59:33.060 --> 59:43.380]  какую архитектуру вы рассматриваете массивов. Что еще раз? А вот это вот будет вопрос к вам,
[59:43.380 --> 59:50.780]  когда вы будете его писать. Смотрите, здесь необходимо понять, вот это правильный swap или нет?
[59:50.780 --> 01:00:03.580]  Или же что-то здесь все-таки не так? Это достаточно такая больная тема обычно. Поэтому с ней лучше всего
[01:00:03.580 --> 01:00:09.780]  проработать. Будет работать это или нет? Достаточно будет всего лишь проверить. Вы на семинарах и так
[01:00:09.780 --> 01:00:21.700]  напишите вот такой вот quicksort. Но есть еще одна проблема. Где такой quicksort не работает? Вот вы,
[01:00:21.700 --> 01:00:38.660]  молодой человек. На чем плохо работает такой quicksort? Да. Причем считаем, что это не так,
[01:00:38.820 --> 01:00:44.980]  что там мы специальный массив подали. А вот просто, какой случай здесь не очень хорошо подходит?
[01:00:54.980 --> 01:01:01.260]  Ну, так вы продолжаете общаться, но я не услышал ответа. Так какой случай?
[01:01:09.660 --> 01:01:28.980]  Есть ли кто, кто знает? Нет. Данная сортировка плохо работает с массивом, в котором почти все
[01:01:28.980 --> 01:01:36.980]  константное, потому что он пытается их свопать между собой. Когда у нас абсолютно все, что есть,
[01:01:37.020 --> 01:01:44.820]  оно так и продолжает быть с этой константой. В чем эта проблема? В том, что мы просто делаем
[01:01:44.820 --> 01:02:06.820]  бесполезную работу. И все. Кто понял почему? Так, ладно. Давайте еще вопрос. Хорошо.
[01:02:06.820 --> 01:02:22.300]  Давайте вернемся к этому, пожалуйста. Скажите мне. Давайте, раз уж что сложно, давайте разберемся
[01:02:22.300 --> 01:02:32.740]  здесь, как этот своп пишет. А раз уж здесь мы с вами пишем, что у нас меньше пивота,
[01:02:33.700 --> 01:02:41.540]  сам пивот когда-то здесь может оказаться. Верно? И мы можем взять его и поменять. Но нам
[01:02:41.540 --> 01:02:47.060]  все равно необходимо поставить на его место. Скажите мне, если я его встречу где-то посерединке,
[01:02:47.060 --> 01:03:06.460]  я поставлю его на свое место или нет? Поставлю. Грустно. Поэтому в действительности каждый раз,
[01:03:06.460 --> 01:03:14.620]  когда мне говорят, а для чего здесь это, и мы что-то исправим, может что-то не заработать. Нам
[01:03:14.620 --> 01:03:26.180]  необходимо просто взять и меньше, либо равно же. На середине они так или иначе встретятся. И
[01:03:26.180 --> 01:03:34.420]  когда это произойдет, он может поменяться с необходимым мне местом. И сам пивот встанет на
[01:03:34.420 --> 01:03:43.140]  нужное нам место. Потому что мы будем постоянно их между собой свопать. Если пивот встанет на
[01:03:43.140 --> 01:03:48.780]  место какое-нибудь там подальше, чем необходимо, он все равно потом перейдет в другое место,
[01:03:48.780 --> 01:03:54.580]  потому что G его встретит. Потом его встретит И, потом опять G. Они будут перекидываться между
[01:03:54.580 --> 01:04:01.420]  собой пивотом, как горячая картошка, но по итогу он встанет на свое место. Ну и да, здесь просто
[01:04:01.420 --> 01:04:12.100]  необходимо что-то вернуть. Что касается задачи, когда у нас есть одинаковые элементы. Я, видимо,
[01:04:12.100 --> 01:04:23.420]  сейчас расскажу лишь суть. Возможно, попрошу семинаристов тогда вам рассказать на экзамене,
[01:04:23.420 --> 01:04:36.020]  господи. На экзамене вы будете рассказывать про это. Смотрите, а суть примерно в следующем.
[01:04:36.660 --> 01:04:50.060]  Только что объясню, почему мы не свапаем пивот. Это нормально, потому что ты же хотел как раз другой
[01:04:50.060 --> 01:05:09.140]  партийший написать, но, видимо, что-то не пишется. Почему? Нет, мы можем его менять. В том и суть,
[01:05:09.140 --> 01:05:15.900]  что вот этот while работает пока меньше и пока больше. Как только он встретит такой же,
[01:05:15.980 --> 01:05:24.860]  он может его поменять местами и остановится в этом циклу. Что же касается разбиения массива на три части.
[01:05:24.860 --> 01:05:33.580]  Когда у вас происходит такое, что в массиве много однотипных элементов и вам необходимо
[01:05:33.580 --> 01:05:42.060]  его отсортировать, хотя он на 7 минут может даже успеть. Нам необходимо разбивать массив на три
[01:05:42.060 --> 01:05:52.940]  части. Меньше, равное и больше. И вот эта часть больше случайно может оказаться очень большой,
[01:05:52.940 --> 01:05:58.260]  по факту, ко всему массиву. А когда она очень большая, у нас может что-то не заработать из-за этого
[01:05:58.260 --> 01:06:05.900]  всего. Поэтому нам необходимо понять, а как нам модифицировать алгоритм так, чтобы мы могли
[01:06:05.900 --> 01:06:18.540]  разбивать его на три части. Представим следующее. Вот у меня есть массив, вот у меня есть левая
[01:06:18.540 --> 01:06:31.140]  граница, правая граница. Предположим, я буду теперь пивот выбирать вот отсюда. У нас каждый
[01:06:31.140 --> 01:06:42.900]  раз новый алгоритм, новый выбор. Очень удобно. Я буду выбирать пивот отсюда. Пусть у меня есть
[01:06:42.900 --> 01:06:53.340]  еще P и Q, какие-то элементы, которые будут делать следующее. Вот здесь вот у меня будут элементы
[01:06:53.340 --> 01:07:07.340]  равные пивоту. Вот здесь вот у меня будут элементы меньше пивота. Вот здесь вот у меня будут
[01:07:07.340 --> 01:07:31.420]  элементы равные пивоту, а вот здесь вот элементы будут больше, чем пивот. Вот. И G, U. Вот. И после этого
[01:07:31.420 --> 01:07:46.980]  мне необходимо переделать свой массив так, что посередине стоит все равная пивота,
[01:07:46.980 --> 01:08:02.460]  лево стоит все меньше пивота, а справа стоит все больше пивота. Для начала мне нужно получить вот
[01:08:02.460 --> 01:08:09.940]  это, а потом мне нужно получить вот это. Почему так? Потому что мы пытаемся модифицировать вон ту
[01:08:09.940 --> 01:08:19.420]  машину, которая у нас с вами была. Мы с вами идем с левого и правого края друг к другу, поэтому нам
[01:08:19.420 --> 01:08:26.100]  необходимо, чтобы вот этот указатель E и вот этот указатель G, а как-то внутри себя пока идут,
[01:08:26.100 --> 01:08:30.900]  расправлялись с теми, которые равные пивоту. Мы не знаем их количество и сколько в центре им
[01:08:30.900 --> 01:08:38.780]  понадобится, тоже не знаем. Поэтому нам необходимо их где-то собирать. Так как E идет слева направо,
[01:08:38.860 --> 01:08:44.140]  мы будем левой границы собирать. Так как G идет справа налево, мы будем собирать их у правой
[01:08:44.140 --> 01:08:51.420]  границы. А все элементы больше кидать сюда. Почему это выгодно? Потому что представьте, что я вот здесь
[01:08:51.420 --> 01:09:04.820]  где-то встретил элемент равный пивоту. Так как я до сюда дошел, вот до сюда, и он у меня больше
[01:09:04.820 --> 01:09:11.660]  пивота. Он и должен здесь стоять по-хорошему, значит все хорошо. Иду дальше и встречаю элемент равный
[01:09:11.660 --> 01:09:22.780]  пивоту. Вот он равен пивоту. С чем мне его поменять? Так я возьму просто и вот с этим вот Q на
[01:09:22.780 --> 01:09:29.700]  место Q и поставлю пивот. А если я возьму и поменяю эту ячейку с этой, то что у меня произойдет?
[01:09:29.700 --> 01:09:37.940]  Ничего плохого, потому что также здесь будет все больше пивота. Аналогично слева работает. Понятно?
[01:09:37.940 --> 01:09:50.980]  А потом нам необходимо все перегнать в середину. И вот этот алгоритм работает корректно и быстро.
[01:09:50.980 --> 01:09:59.860]  И эта штука нам поможет. Что там добавляется? Смотрите, помимо того, что мы здесь написали,
[01:09:59.860 --> 01:10:16.860]  вот эти два указателя здесь. Назовем эту модификацию три части. Вот что добавляется.
[01:10:16.860 --> 01:10:26.260]  По факту лишь добавляется вот сюда еще пару условий. А так как этот while доходит и до равных
[01:10:26.260 --> 01:10:34.260]  элементов, то нам необходимо здесь добавить if на равный элемент. Если он равен, то мы должны
[01:10:34.260 --> 01:10:42.980]  его менять с p. Если мы дошли аито, которое равно нашему пивоту. Если мы его нашли,
[01:10:42.980 --> 01:10:53.540]  мы меняем с p и пет двигаем на единичку. Аналогично g. Если мы нашли элемент g какой-то,
[01:10:53.540 --> 01:11:04.540]  который у нас равен пивоту, то мы ставим его на место q и q двигаем на единичку вперед. То есть
[01:11:04.540 --> 01:11:12.940]  мы добавляем вот эти свопы. Этого будет достаточно, чтобы мы разделили на вот эту часть. Я думаю,
[01:11:12.940 --> 01:11:23.740]  вы сможете написать вот эту часть. Да? Или я зря вас верю? Ну хорошо, проверим тогда где-то
[01:11:23.740 --> 01:11:33.900]  через месяц, видимо. Ну может чуть поменьше. Что касается просто сдвига. Смотрите, у нас с
[01:11:33.900 --> 01:11:42.380]  вами p и q будет показывать количество равных пивоту. Нам необходимо
[01:11:42.380 --> 01:11:49.420]  просто взять и свопать все элементы сначала отсюда сюда, потом отсюда сюда. Мы их друг дружку
[01:11:49.420 --> 01:11:54.380]  свопаем по количеству равных здесь. А так как у нас p и q говорит сколько их здесь благодаря
[01:11:54.380 --> 01:11:58.100]  этим указателям, мы понимаем, что делать. То есть здесь таких четыре указатель.
[01:11:58.100 --> 01:12:13.300]  Спасибо. Понимаю. Видимо, quicksort не понравился. Вот. Контест. Значит от меня во все группы
[01:12:13.300 --> 01:12:19.180]  пришли сообщения. Всем большое спасибо. До следующей недели.
