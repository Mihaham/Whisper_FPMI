[00:00.000 --> 00:14.880]  Мы продолжаем разговор о теории вычислимости. В прошлый раз мы поговорили про модели вычислений,
[00:14.880 --> 00:24.840]  значит сегодня поговорим про вычислимые функции,
[00:24.840 --> 00:42.320]  вычислимые функции, разрешимые и перечислимые множество.
[00:42.320 --> 00:55.880]  В конце прошлого занятия я рассказывал про первые два понятия, про перечислимость,
[00:55.880 --> 01:02.240]  ничего не было, но сегодня поговорим. Давайте вспомним, что такое вычислимая функция.
[01:02.240 --> 01:09.080]  Вообще у нас все объекты, то что у нас конструктивные, то есть каким-то образом
[01:09.080 --> 01:17.240]  кодируются битами, то есть они являются строками из нулей единиц, но также можно считать,
[01:17.240 --> 01:30.360]  что это просто натуральные числа. Соответственно, наша функция отображает, например, битовые строки,
[01:30.360 --> 01:38.920]  или двоичные слова еще можно говорить. В двоичные слова это частично определенная
[01:38.920 --> 01:55.560]  функция. Что означает, что если может быть так, что функция определена и равна чему-то конкретному,
[01:55.560 --> 02:02.880]  а может быть так, что функция не определена. Тогда определение вычислимости такое,
[02:02.880 --> 02:13.600]  если существует алгоритм, ну или может говорить программа, может говорить машина,
[02:13.600 --> 02:29.560]  существует алгоритм, который, получив на вход, который на входе х, делает следующее,
[02:29.560 --> 02:50.400]  значит если f от x определена, то возвращает f от x за конечное время, проработав какое-то время,
[02:50.400 --> 02:57.200]  может быть очень долгое, но конечное. А если f от x не определена, то алгоритм ничего не возвращает,
[02:57.200 --> 03:07.320]  то есть не останавливается. Если f от x не определена, то не останавливается.
[03:07.320 --> 03:18.320]  Тут есть тонкая разница между тем, чтобы ничего не возвратить, и тем, чтобы возвратить ничего.
[03:18.320 --> 03:25.200]  Возвратить ничего можно понять так, что f от x это какое-то специальное значение ничего,
[03:25.200 --> 03:32.040]  нул или пустое слово, или еще какое-нибудь специальное значение, которое означает, что нет ответа.
[03:32.040 --> 03:36.440]  Но это не то же самое, что не остановиться и вообще ничего не возвратить.
[03:36.440 --> 03:45.320]  Здесь важно именно, что машина не останавливается, и никакого ответа нет.
[03:45.320 --> 04:03.120]  Вот, значит такие функции называются вычислимыми. Дальше легко понять, утверждение очень простое,
[04:03.120 --> 04:24.720]  что не все функции вычислимые. Почему это так? Да просто из соображения мощности.
[04:25.560 --> 04:37.200]  Всех функций континуум. Потому что, в общем, это обсуждали, что даже тех уже континуум,
[04:37.200 --> 04:45.000]  где значение просто 0 или 1, но вообще тут счетное число аргументов, тут счетное число значений,
[04:45.000 --> 04:56.320]  то есть получается счетная в степени счетная, это будет континуум. Всех функций континуум,
[04:56.320 --> 05:13.200]  а вычислимых функций счетное множество. Почему? Ну просто потому что функция сдается алгоритмом,
[05:13.200 --> 05:21.040]  то есть программой, а программа это конечная строка символов, а конечных строк, в отличие от
[05:21.040 --> 05:28.480]  бесконечных, будет как раз счетное число. Но одна программа максимум для одной функции годится,
[05:28.480 --> 05:36.080]  да еще на самом деле одну и ту же функцию, как правило, можно по-разному написать. Как правило,
[05:36.080 --> 05:39.680]  это зависит немножко от вычислительной модели, но во всех нормальных моделях,
[05:39.680 --> 05:45.560]  во всех нормальных языках программирования у меня есть такая вещь как комментария. В комментариях
[05:45.560 --> 05:51.560]  можно писать все что угодно, это на работу программы не повлияет. Но даже и без комментариев,
[05:51.560 --> 05:58.880]  как правило, можно одно и то же сделать кучу разных способов, но можно искусственным образом
[05:58.880 --> 06:04.080]  разработать такие языки программирования, что там можно действительно все что угодно написать,
[06:04.080 --> 06:10.840]  но ровно одним способом. Это довольно сложная теорема, мы ее не будем доказывать.
[06:10.840 --> 06:18.680]  В общем, так или иначе, программ будет счетное число всех функций Continuum.
[06:18.680 --> 06:46.520]  Что еще можно сказать про вычислимые функции? Есть такое утверждение, что композиция вычислимых
[06:46.520 --> 07:13.880]  функций вычислима. То есть если f и g вычислимые, то там f от g от x вычислимо, если f и g вычислимо.
[07:13.880 --> 07:21.160]  Ну и опять же, более-менее для всех обычных моделей это очевидно, потому что есть такая вещь,
[07:21.160 --> 07:28.480]  как подпрограмма. То есть мы сначала пишем программу для функции g, а потом ее результат
[07:28.480 --> 07:35.240]  подставляем в программу для функции f. В результате вычисляем f от g от x, и как раз если там что-то
[07:35.240 --> 07:40.520]  не определено, если g от x не определено, то мы просто не получим результат, который сможем
[07:40.520 --> 07:46.640]  подставить. Поэтому все вместе тоже будет неопределено. Если g от x определено, но f на этом
[07:46.640 --> 07:56.560]  входе не определено, то же результат будет неопределен. Опять же, там для любых нормальных
[07:56.560 --> 08:05.120]  языков, для машины тюринга можно вот так рассуждать. Для произвольной модели это будет уже не совсем так,
[08:05.120 --> 08:10.800]  но тем не менее сама теория будет верна, потому что класс вычислимых не меняется от того, что мы
[08:10.800 --> 08:16.440]  переходим к другой вычислительной модели. Поэтому всегда можно брать ту модель, которая для нас более
[08:16.440 --> 08:31.360]  удобна. Хорошо, что еще можно тут сказать, но можно сказать, что могут быть еще функции
[08:31.360 --> 08:56.760]  одних аргументов. Могут быть вычислимые функции от нескольких аргументов, например от двух
[08:56.760 --> 09:10.000]  аргументов. Тут тоже возможны разные определения, как вообще определять, что такое функция от
[09:10.000 --> 09:25.720]  нескольких аргументов вычислимая. Тут более-менее два подхода к определению. Первый подход это
[09:25.720 --> 09:35.280]  закодировать пару аргументов или кортеж аргументов как один, как одну строку. Закодировать
[09:35.280 --> 09:56.480]  пару или набор аргументов одной строкой.
[09:56.480 --> 10:08.640]  Ну а если у нас аргумент это одна строка, то мы уже знаем, что такое вычислимые функции от него.
[10:08.640 --> 10:15.440]  Конечно, кодировать должно быть никакое угодно, а такое, что мы по этому коду можем, опять же,
[10:15.440 --> 10:23.520]  вычислимо выцепить каждый из аргументов. Но это, опять же, неудивительно, что такое кодирование есть,
[10:23.520 --> 10:31.520]  и наоборот, скорее сложно описать кодирование, которое таким бы свойством не удовлетворяло.
[10:31.520 --> 10:38.880]  Ну, в общем, можно делать по-разному, но можно даже сказать, что у нас же есть тандарт значения
[10:38.880 --> 10:46.560]  со скобочками и запятой. Можно просто кодировать, скажем, ноль-двумя единицами,
[10:46.560 --> 11:03.600]  с ноль-двумя нулями единицами, с двумя единицами запятую, как 0,1, или можно даже делать так.
[11:03.600 --> 11:13.600]  Если мы пару кодируем, то можно в х биты удвоить, потом написать 0,1, а потом уже y напрямую написать.
[11:13.600 --> 11:24.640]  Ну, давайте я напишу, например, если у нас вот так вот, значит, вот такая пара,
[11:24.640 --> 11:38.640]  значит, можно ее, соответственно, закодировать вот так вот, значит, 1,1, 0,0, 1,1, 1,1, 0,0, потом 0,1 и потом 0,1,1.
[11:38.640 --> 12:03.680]  Тут получается, что здесь удвоенные биты, дальше тут разделитель, и здесь, соответственно, второе слово.
[12:03.680 --> 12:16.720]  Но это один из огромного количества разных способов кодирования, значит, тут это будет не объективно,
[12:16.720 --> 12:20.720]  потому что если тут будут удвоенные, потом 1,0, то это никак не будет.
[12:20.720 --> 12:26.720]  Но хотя мы считаем, что это тоже будет код того же самого, все равно объективно будет.
[12:26.760 --> 12:33.760]  Вообще это будет не биекция, но можно что-нибудь другое придумать, чтобы была биекция.
[12:33.760 --> 12:51.760]  Вот, значит, это один вариант, ну а другой вариант, это такое непосредственное определение,
[12:51.800 --> 12:56.800]  например, у машины тьюринга аргументы написаны там через бланк.
[12:56.800 --> 13:10.800]  Например, машина тьюринга, так, нет места, я напишу там q0, x, потом бланк и потом y.
[13:10.840 --> 13:26.840]  Так, q1 только, да, я договорился, что начальное состояние q1, x.
[13:26.840 --> 13:33.840]  Машина тьюринга начинает работу вот с такого входа, ну а дальше куда придет, туда придет,
[13:33.840 --> 13:35.840]  должна бы вычислить f от x, y.
[13:35.880 --> 13:41.880]  Ну хорошо, значит, ну и так может аргументов и больше быть.
[13:41.880 --> 13:47.880]  Можно вообще считать, что у нас, например, машина тьюринга с несколькими лентами,
[13:47.880 --> 13:51.880]  и у нас там на первой ленте написан x, на второй y.
[13:51.880 --> 13:57.880]  В общем, куча есть разных вариантов, можно любой из них использовать.
[13:57.920 --> 13:59.920]  Так.
[14:06.920 --> 14:12.920]  Хорошо, ну и соответственно получается, что и такие функции можно подставлять вот в это утверждение
[14:12.920 --> 14:20.920]  о вычислимой композиции, ну и будут получаться разные функции.
[14:20.960 --> 14:26.960]  Ну и будут получаться разные теоремы, типа, что сумма вычислимых, вычислимо,
[14:26.960 --> 14:32.960]  произведение вычислимых, конъюнкция вычислимых, вычислима, ну и так далее.
[14:32.960 --> 14:37.960]  В общем, всякие стандартные логические функции будут вычислимыми,
[14:37.960 --> 14:41.960]  поэтому их можно применять к вычислимым.
[14:42.000 --> 14:46.000]  Получается, что следствие, значит, следствие,
[14:46.000 --> 14:54.000]  наш там, сумма вычислимых, сумма вычислимых функций,
[14:54.000 --> 15:04.000]  вычислима, произведение вычислимых функций, вычислима, ну и так далее.
[15:04.040 --> 15:10.040]  Так, хорошо, про вычислимые функции пока это более-менее все, что я хочу сказать.
[15:10.040 --> 15:16.040]  И перейдем к разрешимым множествам, значит, если нет вопросов.
[15:16.040 --> 15:24.040]  Так, хорошо, значит, у нас есть множество А,
[15:24.080 --> 15:32.080]  значит, А у нас вложено в, например, то же самое множество слов из нулей единиц.
[15:32.080 --> 15:36.080]  Так, значит, это разрешимая
[15:36.120 --> 15:42.120]  множество, значит, если...
[15:45.120 --> 15:48.120]  Если существует
[15:48.120 --> 16:07.560]  Разрешимое множество, значит, если, если существует алгоритм,
[16:07.560 --> 16:26.560]  значит, такой, что на входе х, на входе х, соответственно, он возвращает один,
[16:26.560 --> 16:49.440]  если х лежит в а, значит, и 0, если х не принадлежит а. Вот, значит,
[16:49.440 --> 16:59.680]  можно сказать, что это эквивалентно, значит, эквивалентно тому, что вот такая вот функция
[16:59.680 --> 17:22.120]  характеристическая. Функция ха от х, которая равняется единице, если х принадлежит а,
[17:22.120 --> 17:34.120]  и 0, если х не принадлежит а, вычислимо. Ну, это фактически то же самое, но другими словами.
[17:34.120 --> 17:43.040]  То есть мы говорим, что этот алгоритм не просто 1 на 0 возвращает, а он вычисляет функцию,
[17:44.040 --> 17:54.040]  которые те самые значения. Так, ну и дальше с разрешимым множествами та же самая история про мощность,
[17:54.040 --> 18:04.040]  что всех множеств в континуум, а разрешимых счетное число, потому что всех алгоритм в счетное число.
[18:05.040 --> 18:24.040]  Соответственно, получаем теорему, там тоже утверждение, что не все множества разрешимы.
[18:24.040 --> 18:42.040]  Так, что еще можно сказать? Ну, еще из нашей теоремы о композиции получается такое следствие,
[18:42.040 --> 19:00.040]  что если а и b разрешимы, то тогда пересечение а и b, объединение а и b, дополнение к а,
[19:00.040 --> 19:08.040]  ну и так же на самом деле декартовое произведение, они все тоже разрешимы.
[19:08.040 --> 19:18.040]  Ну и все это делается совершенно одинаковым образом, путем композиции каких-то логических функций,
[19:18.040 --> 19:25.040]  которые очевидно вычислимы, и характеристических функций. То есть, например, можно писать так,
[19:25.040 --> 19:38.040]  что характеристическая функция от пересечения на входе х, это будет произведение одной характеристической функции
[19:38.040 --> 19:44.040]  на другую характеристическую функцию. Значит, это у нас вычислимо по предположению, это вычислимо,
[19:44.040 --> 19:54.040]  произведение тоже вычислимо. Ну а, например, у декартового произведения на входе х и у,
[19:54.040 --> 20:01.040]  значит, тут будет характеристическая функция ха от х умножить на хб от у.
[20:01.040 --> 20:18.040]  Тут мы предполагаем, особенно если мы вот эту парадигму используем,
[20:18.040 --> 20:25.040]  если два аргумента, то означает, что мы как-то кодируем пару, то тут еще подспудно используется то,
[20:25.040 --> 20:33.040]  что функция проекции вычислима, то есть мы из пары х и у получаем отдельно х и отдельно у.
[20:33.040 --> 20:44.040]  Конечно, нужно такое кодирование пар использовать, при котором такая функция будет вычислима.
[20:44.040 --> 20:59.040]  Ну и еще похожее утверждение, что если а и b разрешимы, то тогда их конкатинация,
[20:59.040 --> 21:12.040]  а также итерация звездок линия тоже разрешимы. Ну а это из чего следует?
[21:12.040 --> 21:23.040]  Ну, это следует из того, что у нас есть конечное число, пусть нам нужно понять, какое это слово лежит в конкатинации или нет,
[21:23.040 --> 21:28.040]  но если в нем n символов, то есть n плюс один способ разбить его на два слова,
[21:28.040 --> 21:35.040]  и дальше, соответственно, для каждого разбиения нужно проверить, что первое половин лежит ва, а второе лежит в б.
[21:35.040 --> 21:44.040]  И если хотя бы для одного разбиения это будет верно, значит это в конкатинации лежит.
[21:44.040 --> 21:54.040]  То есть с иными словами можно писать так, что z принадлежит конкатинации a на b.
[21:54.040 --> 22:06.040]  Тогда я только тогда... А сейчас слушайте, давайте я лучше других термах напишу.
[22:06.040 --> 22:23.040]  Так, других термах я через характеристическую функцию.
[22:23.040 --> 22:37.040]  Характеристическая функция конкатинации от z, это дизъюнкция по всем i получается от 0 до n.
[22:37.040 --> 22:57.040]  Тут будет хиа от z с индексами от 1 до i, и хиб с индексами z от i плюс 1, и так далее, n.
[22:57.040 --> 23:04.040]  Соответственно, если i равно 0, то вот эта часть будет пустой, а вот эта всем словом z,
[23:04.040 --> 23:09.040]  а если, наоборот, i равно n, то вот это будет всем словом z, а вот это будет пустым.
[23:09.040 --> 23:14.040]  А иначе мы каким-то образом разрезаем z на две части.
[23:14.040 --> 23:24.040]  Ну и тут видно, что тут тоже такая чуть более сложная, но композиция вычинимых функций.
[23:24.040 --> 23:34.040]  Так, ладно, киньте вопросы.
[23:34.040 --> 23:45.040]  Ну, да, значит, на самом деле аналогично можно еще поступить с множеством нейтральных чисел.
[23:45.040 --> 24:04.040]  Вот еще такое утверждение, что если A и B это разрешимые под множество натуральных чисел,
[24:04.040 --> 24:11.040]  то тогда вот такое множество A плюс B, это еще сумма Минковского называется,
[24:11.040 --> 24:14.040]  значит, A плюс B это множество всевозможных попарных сумм,
[24:14.040 --> 24:20.040]  х плюс у таких, что х лежит в А, а у лежит в Б.
[24:20.040 --> 24:27.040]  Значит, такая штука тоже разрешима.
[24:27.040 --> 24:41.040]  Ну и доказывается это примерно таким же способом.
[24:41.040 --> 24:47.040]  То есть есть его, значит, если у нас число там n, то есть n плюс 1 способ его представить,
[24:47.040 --> 24:53.040]  как сумма двух натуральных чисел, включая ноль.
[24:53.040 --> 24:58.040]  И для каждого из этого конечного множества способов нужно проверить, что первый слагаемый лежит в А,
[24:58.040 --> 25:04.040]  второй лежит в B, и если, соответственно, обе проверки выполнены хоть для какого-то разбиения,
[25:04.040 --> 25:09.040]  то, значит, итоговый ответ да, а иначе ответ нет.
[25:09.040 --> 25:12.040]  Так, ничего, понятно?
[25:12.040 --> 25:24.040]  Вот, но с другой стороны, смотрите, а что если, а что будет для разности?
[25:24.040 --> 25:41.040]  Значит, для A минус B, который будет из всевозможных разностей х минус у, значит, таких, что х из А, а у из B.
[25:41.040 --> 25:51.040]  Но вот тут такое рассуждение не пройдет, потому что будет бесконечное число способов представить одно число как разность двух натуральных.
[25:51.040 --> 26:00.040]  Да, там 2, это будет и 2 минус 0, и 3 минус 1, и 4 минус 2, и так далее, бесконечное число вариантов.
[26:00.040 --> 26:19.040]  Значит, тут получается, что конечного перебора может не хватить.
[26:19.040 --> 26:25.040]  Ну, точнее, если мы найдем пример, то тогда ответ будет точно да.
[26:25.040 --> 26:31.040]  А вот если мы перебрали какое-то число вариантов и пример не нашли, то это еще не значит, что его нет.
[26:31.040 --> 26:35.040]  Мы просто недостаточно перебрали.
[26:35.040 --> 26:56.040]  Если подходящий пример есть, то его можно найти.
[26:56.040 --> 27:19.040]  А если нет, то, по крайней мере, в общем случае, неясно, как это доказать.
[27:19.040 --> 27:27.040]  Ну и как раз вот это дает пример эффекта перечислимого множества.
[27:27.040 --> 27:46.040]  Такие множества называются перечислимыми.
[27:46.040 --> 27:58.040]  Ну, на самом деле, у свойств перечислимости есть несколько разных эквивалентных свойств.
[27:58.040 --> 28:04.040]  Значит, они все друг другу эквивалентны, и для разных теорем удобно не применять разные из них.
[28:04.040 --> 28:09.040]  Так что сейчас давайте я одно из них выберу в качестве базового определения,
[28:09.040 --> 28:19.040]  а все остальные будут оказываться как теоремы, что они базовыми эквивалентны.
[28:19.040 --> 28:29.040]  Базовое определение, мне кажется, должно быть то, из которого название берется перечислимость.
[28:29.040 --> 28:53.040]  Базовое определение множества А называется перечислимым, если верно следующее.
[28:53.040 --> 29:22.040]  Если существует алгоритм... так, я сначала напишу, потом прокомментирую, который печатает все элементы А и только их.
[29:22.040 --> 29:24.040]  Что здесь имеется в виду?
[29:24.040 --> 29:36.040]  Имеется в виду такой тип алгоритма, у которого есть нечто, что называется поток вывода, standard out.
[29:36.040 --> 29:45.040]  В тернах машины тюринга можно представлять себе следующее.
[29:45.040 --> 29:59.040]  Например, есть отдельная лента, и на эту ленту время от времени машина может напечатать 0,1 или пробел, который, понимается, как конец слова, но не может оттуда читать.
[29:59.040 --> 30:07.040]  И стирать тоже не может, просто она время от времени на выход выдает биты и иногда говорит, что слово закончилось.
[30:07.040 --> 30:12.040]  Тогда, когда она говорит, что слово закончилось, то считает, что она напечатала очередное слово.
[30:12.040 --> 30:21.040]  И так она может работать бесконечно, и результат ее работы это будет не конечный ответ, а вот такая бесконечная последовательность отдельных слов.
[30:21.040 --> 30:32.040]  И нужно, чтобы в этой бесконечной последовательности каждое слово из языка встречалось, а все остальные слова не из языка, не встречались.
[30:32.040 --> 30:47.040]  Такое у нас требование.
[30:47.040 --> 30:55.040]  Давайте я немножко обсужу, как это связано с тем, что было вот здесь.
[30:55.040 --> 31:08.040]  Например, что можем делать? Мы можем по очереди про каждое число проверять, лежит ли оно в A, лежит ли оно в B.
[31:08.040 --> 31:21.040]  И как только у нас появилось новое число из A, то для всех уже имеющихся из B мы выводим разность х-у, ну, наверное, те, где х больше либрайна у, чтобы натуральное число было.
[31:21.040 --> 31:31.040]  Как только у нас опять появилось новое число из B, снова мы там для всех, которые уже есть из A...
[31:31.040 --> 31:41.040]  Ну, можно сделать так, что мы по очереди про новое число сначала проверяем, что оно лежит в B.
[31:41.040 --> 31:48.040]  Если оно лежит, то нам не нужно ничего добавлять, потому что все остальные из A были меньше.
[31:48.040 --> 31:57.040]  А если у нас появилось новое число из A, то мы все разности вот этого нового числа и тех, которые уже есть из B, выводим.
[31:57.040 --> 32:03.040]  Ну и так рано или поздно мы все эти разности напечатаем.
[32:03.040 --> 32:09.040]  А все остальные числа не напечатаем.
[32:09.040 --> 32:17.040]  Ну вот, поэтому это действительно связано с тем, что здесь было.
[32:25.040 --> 32:31.040]  Сейчас, в общем, будет несколько эквариентных свойств.
[32:31.040 --> 32:42.040]  Ну, если так дать, я одно успею написать, которое как раз связано с тем, что вот здесь написано, что если ответ да, то мы его можем найти и подтвердить.
[32:42.040 --> 32:46.040]  Если ответ нет, то не можем.
[32:46.040 --> 32:54.040]  Так, значит, эквивалентные свойства.
[32:54.040 --> 33:01.040]  Так, ну вот это будет свойство 1.
[33:01.040 --> 33:10.040]  Будет заключаться в том, что вычислимо полухарактеристическая функция.
[33:10.040 --> 33:15.040]  Полухарактеристическая функция.
[33:15.040 --> 33:25.040]  Кое-нибудь хи А с крышкой от х, которая равняется единице, если х принадлежит А.
[33:25.040 --> 33:33.040]  И не определено, если х не принадлежит А.
[33:33.040 --> 33:40.040]  Так, ну ладно, значит, наверное, продолжение после перерыва.
[33:40.040 --> 33:50.040]  Так, давайте продолжать.
[33:50.040 --> 33:57.040]  Так, хорошо, значит, какие еще будут эквалентные свойства?
[33:57.040 --> 34:01.040]  Давайте, слушайте, я сначала для этого докажу.
[34:01.040 --> 34:08.040]  Там у нас есть некоторая одна идея, которая там всюда фигурирует.
[34:08.040 --> 34:17.040]  Я сначала ее покажу, а потом будем на нее смотреть в других вариантах.
[34:17.040 --> 34:30.040]  Так, ну смотрите, как из перечислимости будет следовать вот это свойство 1?
[34:30.040 --> 34:36.040]  Ну, просто запустим причисляющий алгоритм.
[34:36.040 --> 34:41.040]  У нас есть на входе х. Запустим причисляющий алгоритм.
[34:41.040 --> 34:47.040]  Я еще не сказал, у меня в прерыве спросили, что вообще у алгоритма должен быть вход,
[34:47.040 --> 34:50.040]  но у перечисляющего алгоритма можно считать, что пустой вход.
[34:50.040 --> 34:53.040]  Или какой угодно вход, он его игнорирует.
[34:53.040 --> 35:00.040]  Просто он должен нам что-то напечатать.
[35:00.040 --> 35:05.040]  Ну, тогда можно сделать так.
[35:05.040 --> 35:13.040]  Как вычислить вот эту самую полухарактеристическую функцию от х?
[35:13.040 --> 35:17.040]  Ну, просто запускаем перечисление и ждем, пока встретится х.
[35:17.040 --> 35:22.040]  Если встретилось, выводим 1.
[35:22.040 --> 35:32.040]  Значит, запускаем перечисление а.
[35:32.040 --> 35:48.040]  Значит, если встретилось х, значит, печатаем 1.
[35:48.040 --> 35:56.040]  Ну и тогда получается, что мы печатаем, печатаем.
[35:56.040 --> 36:02.040]  Если там х есть, то есть если х лежит в а, то он в перечилении есть.
[36:02.040 --> 36:06.040]  И тогда мы рано или поздно его найдем и напечатаем 1.
[36:06.040 --> 36:11.040]  Если х нет в а, то тогда его там нет.
[36:11.040 --> 36:14.040]  И мы будем ждать, ждать, ждать, никогда не дождемся.
[36:14.040 --> 36:16.040]  И вообще это никогда не закончится.
[36:16.040 --> 36:18.040]  То есть будет как раз неопределенность.
[36:18.040 --> 36:22.040]  Ну, может быть, в принципе, еще вариант, что там множество конечное,
[36:22.040 --> 36:25.040]  и перечисление просто закончилось.
[36:25.040 --> 36:29.040]  На что? Все напечатало, все, и закончилось.
[36:29.040 --> 36:37.040]  Но тогда чтобы все-таки остаться в рамках вот этого,
[36:37.040 --> 36:41.040]  то есть остаться неопределенным,
[36:41.040 --> 36:47.040]  то нужно просто войти в сетчан цикл, и тогда все будет нормально.
[36:52.040 --> 36:55.040]  Так, это в одну сторону.
[36:55.040 --> 37:01.040]  А вот в другую, есть некоторая сложность.
[37:01.040 --> 37:03.040]  С чем сложность?
[37:03.040 --> 37:07.040]  В том, что мы просто не можем взять и запустить вычисление вот этой функции
[37:07.040 --> 37:09.040]  на каком-то входе.
[37:09.040 --> 37:11.040]  Потому что там может быть неопределена.
[37:11.040 --> 37:15.040]  Если мы будем ждать от нее ответа, она будет неопределена,
[37:15.040 --> 37:22.040]  то мы, соответственно, никогда ни к чему другому перейти не сможем.
[37:30.040 --> 37:32.040]  Типа того, да, конечно.
[37:32.040 --> 37:36.040]  Что делает операционная система, когда у нее какая-то программа зацикливается?
[37:36.040 --> 37:43.040]  Если операционная система нормально спроектирована, то она не должна в целом рушиться.
[37:43.040 --> 37:48.040]  Если один процесс какой-то зацикливался, то все вместе не должно обрушиваться.
[37:48.040 --> 37:50.040]  А за счет чего?
[37:50.040 --> 37:53.040]  За счет того, что делает операционная система.
[37:53.040 --> 37:57.040]  Она как-то организует работу разных процессов, дает одному поработать,
[37:57.040 --> 38:00.040]  потом его приостанавливает, дает другому поработать,
[38:00.040 --> 38:03.040]  его тоже приостанавливает, дает третьему поработать,
[38:03.040 --> 38:05.040]  или потом к тому и вернется.
[38:05.040 --> 38:11.040]  И, соответственно, тогда какой-то один процесс может и зациклиться,
[38:11.040 --> 38:14.040]  и никогда не остановиться, но тем не менее система в целом
[38:14.040 --> 38:18.040]  сохранит работоспособность, и какие-то другие параллельные процессы будут работать.
[38:18.040 --> 38:23.040]  На этом принципе и нужно действовать.
[38:23.040 --> 38:29.040]  По этому принципу и нужно действовать.
[38:29.040 --> 38:36.040]  То есть как из вычислимости полухарактеристической функции сделать перечисление.
[38:45.040 --> 38:50.040]  В общем, нужно действительно запускать поочередно.
[38:50.040 --> 38:53.040]  Например, можно сделать такой цикл.
[38:53.040 --> 38:58.040]  Значит, для k равно 1, 2, 3 и так далее до бесконечности.
[39:03.040 --> 39:18.040]  Значит, запустить полухарактеристическую функцию там от нуля и так далее.
[39:18.040 --> 39:23.040]  Полухарактеристическую функцию от k.
[39:23.040 --> 39:26.040]  Тут k плюс 1 получился аргумент.
[39:26.040 --> 39:31.040]  Значит, на k плюс 1 аргументе на k шагов.
[39:36.040 --> 39:42.040]  Ну и напечатать те аргументы, на которых эти процессы успели закончиться.
[39:49.040 --> 39:59.040]  Те аргументы, на которых вычисление закончилось.
[40:03.040 --> 40:07.040]  Ну смотрите, у нас любые алгоритмы работают пошагово.
[40:07.040 --> 40:12.040]  То есть есть какой-то элементарный шаг, их можно по очереди моделировать.
[40:12.040 --> 40:15.040]  Например, сдвиг машины тюринга.
[40:15.040 --> 40:19.040]  Эти шаги можно считать и можно предудительно прерывать процесс после того,
[40:19.040 --> 40:22.040]  как он сделал определенное число шагов.
[40:24.040 --> 40:27.040]  Тут получается такая картина.
[40:29.040 --> 40:34.040]  Тут получается аргумент.
[40:39.040 --> 40:42.040]  Тут получается число шагов.
[40:46.040 --> 40:50.040]  Ну и тут получается как бы некоторая решетка.
[40:50.040 --> 40:54.040]  На ноль шагов, давайте считать, что не будем запускать.
[40:54.040 --> 41:00.040]  Соответственно, вот какая-то решетка.
[41:15.040 --> 41:25.040]  Ну и получается, что для каждой точки этой решетки мы можем запустить вычисление
[41:25.040 --> 41:28.040]  в этой точке на какое число шагов.
[41:28.040 --> 41:34.040]  А дальше получается, что мы все эти вершины обходим.
[41:34.040 --> 41:39.040]  Сначала мы вот так вот запускаем, потом вот так вот запускаем.
[41:41.040 --> 41:48.040]  Потом вот так вот запускаем.
[41:57.040 --> 42:00.040]  Что-то он тут стал плохо рисовать.
[42:04.040 --> 42:14.040]  Ну и тогда, получается, что каждый раз у нас все на большем и большем числе аргументов, на большее и большее число шагов мы запускаем.
[42:14.040 --> 42:34.040]  И тогда получается, что если у нас вообще, то есть если ха с крышкой от какого-то х останавливается за t шагов,
[42:34.040 --> 42:48.040]  то тогда, соответственно, на шаге, так сейчас нехорошо то же самое, то же самое слово использовать.
[42:48.040 --> 43:15.040]  Давайте на стадии, на стадии максимум из t и х, значит, на стадии максимум из t и х, соответственно, будет выведена, будет выведен х.
[43:15.040 --> 43:34.040]  Значит, х будет выведен нам, потому что как раз на этой стадии, когда х равно вот этому, то тогда и х попадет в список аргументов,
[43:34.040 --> 43:43.040]  и за t шагов, соответственно, вычленение закончилось. Ой, я тут как смешно написал.
[43:43.040 --> 44:04.040]  Х попадется в список аргументов, и t уложится в лимитное число шагов.
[44:04.040 --> 44:16.040]  И тогда, соответственно, учленение закончится, и поэтому х будет выведено.
[44:16.040 --> 44:32.040]  Вот так. Ну чего, понятно? Это, в общем, более-менее самое важное рассуждение.
[44:32.040 --> 44:40.040]  Нет, нет, нет, смотрите, потому что мы на t этом шаге мы запускаем только на аргументах от 0 до t.
[44:40.040 --> 44:46.040]  А если х больше, чем t, тогда х не пойдет в список этих аргументов.
[44:46.040 --> 44:54.040]  Но зато, когда до х дойдет, то там он даже быстрее, чем за х завершится.
[44:54.040 --> 45:04.040]  Вот так, хорошо. Ну теперь другие эквалентные свойства.
[45:04.040 --> 45:24.040]  Другие эквалентные свойства. Два, а это область определений вычислимой функции.
[45:24.040 --> 45:34.040]  Три, а это область значений вычислимой функции.
[45:34.040 --> 45:52.040]  Четыре, а пусто, или а это область значений всюдо определенной вычислимой функции.
[45:52.040 --> 45:58.040]  Так, и пять. Ну, наверное, достаточно, можно еще несколько написать.
[45:58.040 --> 46:02.040]  Да, мне кажется, самые важные вот эти вот пять.
[46:02.040 --> 46:26.040]  Так, значит, что а это проекция разрешимого множества пар.
[46:26.040 --> 46:42.040]  Б, что значит проекция? Значит, что а это множество таких х, что существует у такое, что пара х и у лежит в Б.
[46:42.040 --> 47:00.040]  Чта Б разрешима.
[47:00.040 --> 47:28.040]  Вот. Хорошо, значит, теперь как доказывается, что это все эквивалентно между собой.
[47:28.040 --> 47:36.040]  Ну, тут, в общем, более-менее все не совсем по циклу доказывается.
[47:36.040 --> 47:56.040]  Назад.
[47:56.040 --> 48:02.040]  Так, значит, из первого во второе. Ну, это как раз очень легко.
[48:02.040 --> 48:14.040]  Просто а это область определения полухарактеристической функции.
[48:14.040 --> 48:22.040]  Соответственно, если полухарактеристическая функция вычислима, то а это область определения вычислимой функции.
[48:22.040 --> 48:44.040]  Так, ну дальше из 1, из 1.3 получится, что а это область значений f от x, которые есть x умноженное на ха с крышкой от x.
[48:44.040 --> 48:56.040]  Да, то есть это будет равняться x, если x принадлежит а, и не определено, значит, если x не принадлежит а.
[48:56.040 --> 49:18.040]  Подожди, сюда определенно это у нас уже четвертое. Третье это просто вычислимая функция, а четвертое это всегда определённый.
[49:18.040 --> 49:32.040]  Так. Хорошо, значит, четвертое можно по-разному делать.
[49:32.040 --> 49:40.040]  Давайте четвертое напрямую из перечислимости. Покажем.
[49:40.040 --> 49:47.040]  Значит, из перечислимости в четвертое. Значит, и тут разберём два случая.
[49:47.040 --> 49:57.040]  Значит, когда а конечно и когда а бесконечно.
[49:57.040 --> 50:05.040]  Значит, если а конечно, то, ну, например, можно по циклу выводить.
[50:05.040 --> 50:17.040]  Да, значит, например, сейчас. Так, значит, а конечно есть вариант, когда а пустое, это у нас напрямую как вариант.
[50:17.040 --> 50:29.040]  Значит, а равно пустое, значит, это явный вариант.
[50:29.040 --> 50:34.040]  Да, то есть явно вот здесь написан вариант, что а пустое.
[50:34.040 --> 50:47.040]  Значит, если а не пустое, значит, если размер а равен какому-то там s больше 0,
[50:47.040 --> 50:59.040]  то тогда можно считать, что а это будет набор а1, а2 и так далее, аst.
[50:59.040 --> 51:07.040]  Значит, набор zs элементов. И можно сделать просто такую функцию f от x.
[51:07.040 --> 51:15.040]  Это будет а с индексом x по моделю s.
[51:15.040 --> 51:27.040]  Так, только тогда лучше сдвинуть 0, 1 и так далее с минус 1, чтобы это прям остаток был.
[51:27.040 --> 51:37.040]  Так, 0, 1 и так далее с минус 1. Вот, это действительно вот сюда определено.
[51:37.040 --> 52:01.040]  Ну, а если а бесконечная, ну, оно на натуральных числах определено.
[52:01.040 --> 52:09.040]  Вот, соответственно, если размер а бесконечный, то можно поступить по-другому.
[52:09.040 --> 52:28.040]  Мы представляем, что f от k это просто kt числов перечисления.
[52:28.040 --> 52:40.040]  И поскольку а бесконечно, то, соответственно, для любого kt числа встретится, и оно будет как раз в множестве.
[52:40.040 --> 53:00.040]  Вот. Так, ну ладно.
[53:00.040 --> 53:06.040]  Теперь что нам осталось? Там 5 осталось каким-то образом, но еще все в другую сторону.
[53:06.040 --> 53:11.040]  Ну, на самом деле, удобно все эти 2, 3, 4 свести к пятому.
[53:11.040 --> 53:17.040]  Ну, а кроме того, на самом деле, из четвертого, третьего, очевидно, следует.
[53:17.040 --> 53:24.040]  Даже, да, потому что пустое множество будет областью значений нигде неопределенной функции, которая вычислима.
[53:24.040 --> 53:33.040]  Да, а поскольку сюда определенные вычислимые являются, в частном случае, вычислимые, то значит, из четвертого, третьего следует.
[53:33.040 --> 53:42.040]  Да, значит, давайте я напишу, что это, ну я тут позволю себе написать, что это очевидно.
[53:42.040 --> 53:51.040]  Но все-таки тут, если вас спросят, то нужно так и рассказать, что в первом варианте это областье значений пустой функции,
[53:51.040 --> 53:58.040]  а в втором варианте областье значений вот той самой, всю доопределенной.
[53:58.040 --> 54:09.040]  Так, теперь, значит, я еще хочу показать из второго пятая, из третьего пятая и из пятого первого, и тогда уже все направления замкнутся.
[54:17.040 --> 54:25.040]  Из второго пятая. Значит, пусть у нас А это область определения Ф.
[54:28.040 --> 54:47.040]  Вот, но тогда можно все следующее, чтобы это будет, ну что пар Х, Т таких, что Ф от Х останавливается за не более чем Т шагов.
[54:47.040 --> 55:06.040]  Вот, ну тогда действительно, да, значит, если, да, значит, там что нужно написать, что А это множество таких Х, что существует Т, что пара Х, Т лежит в В.
[55:06.040 --> 55:16.040]  Ну действительно, если Ф от Х определено, то есть если Х лежит в А, то Ф от Х определено, тогда Ф от Х останавливается за какое-то число шагов.
[55:16.040 --> 55:24.040]  Именно это число шагов нужно сюда подставить. Если Х не принадлежит А, то Ф от Х не определено.
[55:24.040 --> 55:29.040]  Но тогда за какое число шагов оно не остановится, и поэтому сюда не попадет, вот.
[55:29.040 --> 55:37.040]  А вот такое B будет разрешимым, потому что, раз это ограниченное число шагов,
[55:37.040 --> 55:45.040]  то можно вот это число шагов провести и, соответственно, посмотреть, остановится или нет.
[55:46.040 --> 55:58.040]  Так, ну и с третьего пятая более-менее аналогично, ну чуть-чуть по-другому.
[55:58.040 --> 56:07.040]  Значит, если A это область значений f, то тогда можно писать так, что A это нож таких y,
[56:07.040 --> 56:22.040]  что существует пара x и t, что, соответственно, тут, ну это не то же самое B будет,
[56:22.040 --> 56:41.040]  и что f от x равно y, и f от x останавливается за не более чем t шагов.
[56:41.040 --> 56:51.040]  Вот. И, соответственно, то, что написано после квантора, это тоже вычислимый предикат.
[56:51.040 --> 56:57.040]  Но формально нужно сказать, что нужно сначала из пары x и t быть отдельно x, отдельно t,
[56:57.040 --> 57:03.040]  потом проверить, что f от x останавливается за t шагов, и если останавливается,
[57:03.040 --> 57:11.040]  то еще проверить, что f от x равно y. Вот. Если не останавливаться, то не надо ничего проверять.
[57:11.040 --> 57:37.040]  Вот. Ну и осталось из пятого первое. Значит, из пятого первое получается следующим образом.
[57:37.040 --> 57:49.040]  Опять же у нас x, то есть A это нож таких x, что существует такой y, что пара x и y лежит в B.
[57:49.040 --> 58:05.040]  Вот. А вычислять полухарактеристическую функцию от x надо так. Мы просто перебираем всевозможные y
[58:05.040 --> 58:17.040]  прям по очереди, по возрастанию. Значит, для y равно 0, 1, 2 и так далее.
[58:17.040 --> 58:34.040]  Значит, проверяем, что пара x и y лежит в B. И если верно, возвращаем 1.
[58:34.040 --> 58:40.040]  Тогда, если такой y есть, то мы до него дойдем в каком-то шаге. При этом важно, чтобы разрешим,
[58:40.040 --> 58:51.040]  и поэтому каждая такая проверка завершится с ответом 1 или 0. Вот. Если x лежит в A,
[58:51.040 --> 58:58.040]  тогда такой y есть, и тогда этот перебор до этого y рано или поздно дойдет, и поэтому вернем 1.
[58:58.040 --> 59:08.040]  Вот. А если такого y нету, то тогда для каждого y вернется 0, и, соответственно,
[59:08.040 --> 59:19.040]  никогда мы единицу не вернем, процесс никогда не остановится. Вот.
[59:19.040 --> 59:29.040]  Так. Ну все. Получается, по крайней мере, для вот этих всех вариантов.
[59:29.040 --> 59:39.040]  Инклонец не доказано. Может быть, на семинаре будет еще пара свойств. Да.
[59:39.040 --> 59:54.040]  Нет, из четвертого мы третье вывели. Да. Из четвертого-третьего, да.
[59:54.040 --> 01:00:02.040]  Потому что тут более частный случай в четвертом, чем в третьем.
[01:00:10.040 --> 01:00:16.040]  Так. Ну дальше, на самом деле, все эти эквалентные свойства дают некоторый такой арсенал,
[01:00:16.040 --> 01:00:22.040]  и разные теоремы, может быть, удобнее доказывать через разные свойства.
[01:00:22.040 --> 01:00:39.040]  Ну, например, утверждение, что если A и B перечислимые,
[01:00:39.040 --> 01:00:45.040]  то тогда пересечение A и B тоже перечислимо.
[01:00:45.040 --> 01:00:55.040]  Значит, как это можно делать? Ну, например, через полухарактеристические функции,
[01:00:55.040 --> 01:01:03.040]  можно писать, что полухарактеристическая функция пересечения, это будет произведение.
[01:01:03.040 --> 01:01:25.040]  От X. Это произведение полухарактеристической функции A умножить на вот это вот.
[01:01:25.040 --> 01:01:31.040]  И тут как раз все подходит друг к другу. Как раз если одно не определено,
[01:01:31.040 --> 01:01:37.040]  то и произведение не определено, а только если оба равны единице, то произведение равно единице.
[01:01:37.040 --> 01:01:42.040]  Ну, например, с объединением так не получится.
[01:01:42.040 --> 01:01:48.040]  Потому что не получится так скомбинировать неопределенность хоть чем-нибудь, хоть как-то, чтобы получилась единица.
[01:01:48.040 --> 01:01:58.040]  А для объединения это нужно. Ну, для объединения, например, можно делать так.
[01:01:58.040 --> 01:02:10.040]  Например, через третья. Значит, если A и B перечислимы, то тогда объединение A и B перечислимо.
[01:02:10.040 --> 01:02:25.040]  Ну, например, можно сказать так. Пусть A это область значений F, а B это область значений G.
[01:02:25.040 --> 01:02:34.040]  Тогда объединение A и B это область значений H, которая определена таким образом.
[01:02:34.040 --> 01:02:46.040]  Значит, такая, что H от 2n это будет F от n, а H от 2n плюс 1 это будет G от n.
[01:02:46.040 --> 01:02:55.040]  Получается, что на четных входах H определена также как F, а на нечетных она также как G.
[01:02:55.040 --> 01:03:03.040]  Ну и ясно, что значения там будут те, которые есть в F, те, которые есть в G, но никаких других не будет.
[01:03:16.040 --> 01:03:28.040]  Ну, давайте еще один пример с пятым, с декартом произведения.
[01:03:28.040 --> 01:03:39.040]  Значит, если A и B перечислимы, то тогда декарта произведения A на B перечислима.
[01:03:39.040 --> 01:04:00.040]  Вот, значит, тогда тут получается, что, например, A это множество таких X, что существует Y, что пара X, Y лежит в C.
[01:04:00.040 --> 01:04:16.040]  Значит, B это множество таких Z, что существует T, так что пара Z, T принадлежит D.
[01:04:16.040 --> 01:04:25.040]  Так, ну и дальше так дать, я вот тут вот напишу.
[01:04:25.040 --> 01:04:34.040]  Значит, тогда получается декарта произведения A на B это множество таких пар X, Z,
[01:04:34.040 --> 01:04:51.040]  что существует Y, T так, что одновременно X, Y принадлежит C и Z, T принадлежит D.
[01:04:51.040 --> 01:05:01.040]  Ну и, соответственно, вот эта вот строчка после квантора это на самом деле свойство пары X, Z и Y, T,
[01:05:01.040 --> 01:05:06.040]  это уже разрешимо. То есть мы каждую из этих пар разбиваем на составляющие,
[01:05:06.040 --> 01:05:13.040]  комбинируем их вот так вот и запускаем проверку для C, проверку для D.
[01:05:13.040 --> 01:05:22.040]  То есть тоже получилось такого же рода выражения.
[01:05:22.040 --> 01:05:28.040]  Ну вот, значит, это вот три примера, как разные утверждения можно использовать.
[01:05:28.040 --> 01:05:33.040]  Понятно, что все эти утверждения можно и через другие свойства доказывать.
[01:05:33.040 --> 01:05:40.040]  Тут довольно разнообразные могут быть приемы.
[01:05:40.040 --> 01:05:45.040]  Так, ну и напоследок я поговорю про дополнение.
[01:05:45.040 --> 01:05:53.040]  Потому что это вот то, что отличает перечислимый множество от разрешимых.
[01:05:53.040 --> 01:06:10.040]  Значит, тут из перечислимости A не следует перечислимость A с чертой.
[01:06:10.040 --> 01:06:16.040]  Вместо этого есть теорема Поста.
[01:06:16.040 --> 01:06:33.040]  Теорема Поста такая, что A разрешима тогда и только тогда, когда A и A с чертой перечислимы.
[01:06:46.040 --> 01:06:56.040]  Доказательства.
[01:06:56.040 --> 01:07:02.040]  Так, доказательства, как это устроено.
[01:07:02.040 --> 01:07:09.040]  Ну, смотрите, в одну сторону, значит, если A разрешима,
[01:07:09.040 --> 01:07:15.040]  то тогда A с чертой разрешима.
[01:07:15.040 --> 01:07:22.040]  Значит, отсюда следует, что A перечислима.
[01:07:22.040 --> 01:07:30.040]  И отсюда следует, что A с чертой перечислима.
[01:07:30.040 --> 01:07:40.040]  Да, это, кстати, я не обсудил, кажется, что из разрешимости следует перечислимость.
[01:07:40.040 --> 01:07:47.040]  Ну, это, наверное, очевидное из определения с полухарактеристической функцией.
[01:07:47.040 --> 01:07:52.040]  Откуда вот это вот?
[01:07:52.040 --> 01:08:02.040]  Просто если ха вычислимо, то и ха с крышкой тоже вычислимо.
[01:08:02.040 --> 01:08:10.040]  Просто мы заменяем 0 на неопределенность.
[01:08:10.040 --> 01:08:21.040]  Заменяем 0 на неопределенность.
[01:08:21.040 --> 01:08:28.040]  Вот, поэтому в эту сторону действительно все верно.
[01:08:28.040 --> 01:08:38.040]  Ну а в другую сторону, значит, если A я с чертой перечислимая,
[01:08:38.040 --> 01:08:48.040]  если A я с чертой перечислимая,
[01:08:48.040 --> 01:08:54.040]  но интуитивно надо сказать так, что мы запустим параллельно
[01:08:54.040 --> 01:08:59.040]  А и А с чертой и будем ждать, где х встретится раньше.
[01:08:59.040 --> 01:09:06.040]  То есть у нас получается вход х.
[01:09:06.040 --> 01:09:13.040]  Мы, соответственно, запускаем...
[01:09:13.040 --> 01:09:19.040]  Ну, давайте так, значит, можно запускаем пошагово
[01:09:19.040 --> 01:09:24.040]  полухарактеристическую функцию для A на входе х
[01:09:24.040 --> 01:09:30.040]  и полухарактеристическую функцию для A с чертой на входе х.
[01:09:30.040 --> 01:09:36.040]  И, соответственно, делаем шаг одной, шаг другой, шаг одной, шаг другой.
[01:09:36.040 --> 01:09:44.040]  И, соответственно, если первая из них остановилась,
[01:09:44.040 --> 01:09:52.040]  если первая из них остановилась, то тогда возвращаем единицу.
[01:09:52.040 --> 01:10:04.040]  Если вторая остановилась, то тогда возвращаем ноль.
[01:10:04.040 --> 01:10:12.040]  Ну а одна из них точно остановится.
[01:10:12.040 --> 01:10:24.040]  Одна из них точно остановится за конечное время.
[01:10:24.040 --> 01:10:30.040]  Почему? Потому что что-то одно то верно, либо х лежит в A, либо х лежит у вас чертой.
[01:10:30.040 --> 01:10:39.040]  Если х лежит в A, то первая остановится, если у вас чертой, то вторая остановится.
[01:10:40.040 --> 01:10:47.040]  Ну и, соответственно, если эта процедура остановится, выдаст правильный ответ.
[01:10:47.040 --> 01:10:55.040]  Вот такое это рассуждение.
[01:10:55.040 --> 01:11:01.040]  На следующей лекции мы изучим вопрос о том, что на самом деле бывают перечислимые,
[01:11:01.040 --> 01:11:07.040]  но не разрешимые множества, и это то, что невозможно установить из соображений мощности.
[01:11:07.040 --> 01:11:16.040]  Потому что перечислимых тоже счетное число, то есть нельзя сказать, что их больше, чем разрешимых.
[01:11:16.040 --> 01:11:20.040]  Но, тем не менее, бывают перечислимые, но не разрешимые множества.
[01:11:20.040 --> 01:11:25.040]  Это важнейшее достижение, с которого началась эта теория.
[01:11:25.040 --> 01:11:31.040]  Это результат Тьюринга 1936 года, связан с проблемой остановки.
[01:11:31.040 --> 01:11:35.040]  Вот к нему мы подойдем в следующий раз.
[01:11:35.040 --> 01:11:37.040]  Все, спасибо за внимание.
