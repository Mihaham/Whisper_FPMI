[00:00.000 --> 00:17.400]  Окей, так у нас, по идее, лекция 12. И мы с вами почти закончили в прошлый раз про суфиксный
[00:17.400 --> 00:26.920]  астомат, но вы что-то все умерли, вот, поэтому давайте начнем чуть ли не заново, а именно напомним,
[00:26.920 --> 00:31.920]  что было на последней лекции, на прошлой лекции, чего мы сами добились. Первое, мы сами добились,
[00:31.920 --> 00:35.640]  что мы будем строить автомат итеративно, то есть, написывая по одной буковке, ну или
[00:35.640 --> 00:39.680]  инкрементально, как угодно это называете. Второе, мы добились, что при дописывании
[00:39.680 --> 00:45.840]  одной буквы появляются два новых лонгест. Ну, точнее, один всегда появляется, второй там, как повезет.
[00:45.840 --> 01:02.040]  Не появится повезет, значит. Примерно такая логика. При дописывании S в SC появляются следующие
[01:02.040 --> 01:09.840]  классы. Ну, классы, или мы с вами показали, что у нас SBC из классов лонгест, и поэтому,
[01:09.840 --> 01:19.680]  я буду просто говорить, следующий лонгест. И первое, это соответствующий SC, но он всегда
[01:19.680 --> 01:24.920]  появляется в силу критерия лонгеста, потому что это префикс. И второе, мы с вами показывали,
[01:24.920 --> 01:32.520]  что если он появляется, так сказать, тут со знаком вопросик, потому что может не появиться.
[01:32.520 --> 01:47.280]  T это наибольший суффикс SC, такой, что он является под строкой S.
[01:47.280 --> 02:04.680]  Вот это у нас было, и еще у нас было следствие из критерия лонгест, что, давайте замечание
[02:04.680 --> 02:24.120]  это оформим, что был лонгест, следует, что он всегда лонгест. Опять же, следствие из критерия
[02:24.120 --> 02:31.360]  лонгеста, напомню формулировку, то, что строка является лонгест в своем классе, если она или
[02:31.360 --> 02:40.600]  префикс, или у нее есть два символа, если есть два символа, альфа и бета, такие, что альфа плюс
[02:40.600 --> 02:44.720]  лонгест и бета плюс лонгест, это под строки. То есть, мы можем ее два раза продлить влево,
[02:44.720 --> 02:52.400]  двумя разными способами. Вот. Соответственно, что мы с вами дальше делали? Дальше мы разбирали
[02:52.400 --> 02:59.640]  с вами алгоритм, точнее, мы там почти час вот это все доказывали, выводили всю теорию. Теперь
[02:59.720 --> 03:10.400]  нужно сам алгоритм разобрать. По-хорошему, мы разобрали где-то 70 процентов в прошлый раз.
[03:10.400 --> 03:17.320]  Вот я вчера вел пару, понял, что никто не разобрался, возможно, потому что никто не
[03:17.320 --> 03:27.880]  смотрел лекцию, но это не точно. Вот. Алгоритм построения и стадия первая, то есть, вот у нас наш
[03:27.880 --> 03:46.240]  класс С и вот его суффиксный путь. И допустим, что это корень автомата. Вот, что тогда можно сказать.
[03:46.240 --> 03:54.760]  Я могу сказать следующее, что и вот наш класс С. У нас было с вами утверждение про то, как устроены
[03:54.760 --> 04:00.560]  ребра, ведущие в одну вершину. Первое, они все ведут по одной букве, второе, они являются суффиксом
[04:00.560 --> 04:09.640]  путем друг друга. Поэтому здесь мы пишем букву С, но это просто потому, что мы хотим из С получить СС,
[04:09.640 --> 04:16.480]  это вроде очевидно. Мы сейчас должны несколько подряд выписать по букве С. Почему? Потому что
[04:16.480 --> 04:23.560]  все суффиксы СС выглядят, по сути, как некоторые суффиксы С, которым приписали букву С. С звучит
[04:23.560 --> 04:43.840]  максимально логично. Так. Рисунок или надпись? Куда рисунок-то крупнее? Он уже почти на всю доску.
[04:43.840 --> 04:54.240]  Ну надпись я буду крупнее делать, окей. Так, то есть первая стадия это провести ребра в СС.
[04:54.240 --> 05:19.040]  А как она выглядит псевдокодом? While tu от P по букве С существует,
[05:19.040 --> 05:26.880]  давайте напишем это так. Не ведет в какую-то несуществующую ноду, что-нибудь еще. На коде
[05:26.880 --> 05:34.400]  как угодно выражайте. То есть пока этот переход существует, то есть мы можем из вершины П перейти
[05:34.400 --> 05:48.400]  по С. Ну берем и говорим, что, наоборот, не существует, конечно же. Пока он не существует,
[05:48.400 --> 06:02.200]  и этот маркер плох. Так, пока он не существует, мы должны говорить, что tu из вершины П по
[06:02.200 --> 06:14.800]  букве С равно СС, П равно линк от П. То есть вот мы с вами идем в какой-то момент времени. Мы вот идем,
[06:14.800 --> 06:22.040]  прыгаем по ним и проводим в СС. И первый случай, собственно, это самый классный случай, который
[06:22.040 --> 06:26.120]  почти никогда не реализуется, к сожалению, потому что все хорошее в этой жизни дорого и стоит редко,
[06:27.120 --> 06:37.160]  а это случай, когда П это корень. То есть мы смогли дойти до корня и мы провели из всех вершин по
[06:37.160 --> 06:43.680]  букве С сюда в СС. Когда это может быть? Это может быть тогда и только тогда, когда у вас буква С вообще
[06:43.680 --> 06:50.240]  не встречалась раньше в строке С. Согласитесь, это бывает достаточно редко, не больше, чем модуль Сигма раз.
[06:50.240 --> 07:05.360]  Вот поэтому, типа говорим, все, ретерн напишем. То есть это случай один, и почему всем маркерам так
[07:05.360 --> 07:12.720]  плохо? Просто ретерн, закончили. Это просто процедура добавления буквы, она вряд ли должна что-то возвращать.
[07:12.720 --> 07:19.280]  Безумно логично, она просто меняет текущий состояние автомата. Окей, теперь,
[07:19.280 --> 07:24.920]  допустим, что П не корень. Что это значит? Это значит, что из П есть переход по С. То есть мы
[07:24.920 --> 07:30.640]  где-то вот пропрыгали, и у нас вот закончилась где-то здесь эпопея П. Из нее есть переход по С,
[07:30.640 --> 07:41.680]  состояние Q. Скажу сразу, что П может быть корнем. Это не проблема. Так просто, на всякий случай.
[07:41.680 --> 07:48.640]  Так, здесь мы говорили следующее, что у нас, то есть смотрите, по сути мы провели серебра в СС и
[07:48.640 --> 07:55.640]  описали класс СС. Вот, а дальше у нас есть какие-то новые суффиксы, и здесь надо понять, что с ними
[07:55.640 --> 08:03.760]  надо делать. И по-хорошему, здесь не очень много ситуаций, именно в случае вообще два. Именно надо
[08:03.760 --> 08:12.840]  понять, расщепляет ли вот этот переход, будет ли здесь расщепление Q, грубо говоря. Почему? Потому
[08:12.840 --> 08:21.960]  что, так давайте здесь нарисуем, вот ваш класс Q, а теперь взяли и провелись переход П по С. И что
[08:21.960 --> 08:26.760]  это может быть? Может быть у нас сейчас будет сформирован новый лонгест, как раз-таки который
[08:26.760 --> 08:34.680]  наибольший суффикс СС такой, что он является под строкой С. То есть у нас вот, допустим, вот эта
[08:34.680 --> 08:46.320]  строчечка могла быть под строкой С. Вот, собственно, она лежит в Q по этому, потому что Q мы заново не
[08:46.320 --> 08:53.160]  создавали. Это все вот было в строке С, вот это вот лежит в строке С. И здесь вот может возникнуть
[08:53.160 --> 09:05.400]  такая ситуация, что вот это вот новый лонгест. Когда эта ситуация возникает? Когда у вас вот
[09:05.400 --> 09:12.360]  взяли вашу строку С, приписали к ней букву С, и появилось новое вхождение Т, которое предваряется
[09:12.360 --> 09:21.000]  буквой гамма. Тогда как все вхождения Т раньше предварялись какой-нибудь буквой альфа. Тогда вот у вас
[09:21.000 --> 09:27.280]  новый лонгест по критерии лонгеста, как раз-таки. И вот он может возникнуть посредине класса. И здесь,
[09:27.280 --> 09:33.960]  как раз-таки, две ситуации. Первая ситуация, вот это вот ребро из П по Q приводит вот сюда,
[09:33.960 --> 09:39.080]  вот то есть старый лонгест, то что было лонгестом. А вторая ситуация, она приводит куда-то в
[09:39.080 --> 09:46.400]  середину класса. И тогда нам придется его расщеплять. Как это проверять? Заметим, что Т в нашем
[09:46.400 --> 09:58.640]  случае это лонгест от П плюс С. То есть вот взяли лонгест из П класса и провели его сюда в переход.
[09:58.640 --> 10:04.360]  И теперь, если он пришел сюда, это значит, что нам еще делать не нужно. Новый лонгест не
[10:04.360 --> 10:20.880]  появится, потому что то, что было лонгестом, и останется. То есть, если у вас верно вот такого
[10:20.880 --> 10:31.120]  вот соотношения, здесь нужно сделать лишь одну операцию. Какую? По сути, нужно взять и сказать,
[10:31.120 --> 10:39.120]  окей, вот твоя новая суффиксная ссылка, чувак. А, ну еще здесь надо, конечно,
[10:39.120 --> 10:45.960]  что суффиксная ссылка типа в корень приходит по-хорошему указать. Давайте здесь.
[10:45.960 --> 11:09.840]  Здесь линк от СС это корень, здесь линк СС это Q и return. И самое интеллектуальное,
[11:09.840 --> 11:15.440]  это когда появляется новый лонгест. Это значит, что вы должны разбить, то есть это, так сказать,
[11:15.440 --> 11:25.680]  наш случай 2. Вот это вот случай 2, когда все хорошо. Случай 1. Ну или случай 2.1 в нашей
[11:25.680 --> 11:30.960]  нотации с прошлой лекции, насколько я помню. Есть случай 2.2. Это когда надо расщеплять. То есть,
[11:30.960 --> 11:37.360]  у вас происходит разбирание класса Q на 2. Вот так вот. И теперь мы говорим, что вот это вот старый
[11:37.360 --> 11:41.880]  Q, а вот это мы должны в новый класс выделить, потому что новый лонгест у нас биекция между
[11:41.880 --> 11:50.920]  лонгестами и классами. Мы возьмем его клон. Почему клон? Сейчас будет пояснение. А именно,
[11:50.920 --> 12:02.800]  давайте поймем, чем отличаются правые контексты Q и клона. Я отвержаю, что следующее. Верно,
[12:02.800 --> 12:18.480]  что R от СС от клона это RСС от Q в объединении с Эпсилон. Ну почему это так? Раз-то клон,
[12:18.480 --> 12:23.440]  точнее не так, раз-то новый лонгест, и он появился именно при создании класса СС,
[12:23.440 --> 12:29.960]  значит, это штука суффикс СС. Раз-то суффикс СС, значит, у него Эпсилон входит в правый контекст.
[12:29.960 --> 12:35.720]  С другой стороны, это изначально был один и тот же класс, поэтому все, что было правым контекстом,
[12:35.720 --> 12:42.120]  ему останется. Поэтому мы должны объединить с этим. И теперь нужно понять, почему это дизюнтное
[12:42.120 --> 12:51.160]  объединение, то есть почему в Q не было Эпсилона. Ну если в Q был Эпсилон, значит Q было суффиксом,
[12:51.160 --> 12:59.280]  да, логично, то есть Q было суффиксом S. Ну тогда мы бы не могли бы просто припрыгать в Q по суффиксам
[12:59.280 --> 13:06.520]  ссылкам. Точнее не так, если бы Q было бы суффиксом S, то мы бы припрыгали в него по суффиксам ссылкам.
[13:06.520 --> 13:13.960]  Но Q у нас получается как переход из суффиксного пути по букве, то есть он никак не лежит на пути
[13:13.960 --> 13:23.680]  суффиксных ссылок. Конец. Поэтому дизюнтное объединение. Из этого следует что? Из этого следует,
[13:23.680 --> 13:33.520]  в частности, что раз правые контексты одинаковы, то ту от клона это ту от Q. То есть мы должны
[13:33.520 --> 13:46.240]  клонировать все ребра, исходящие из Q, клонировать в исходящие из клона. Это средняя по сложности часть.
[13:46.240 --> 13:53.520]  Теперь часть чуть попроще. Это про суффиксные ссылки. Как они здесь будут устроены? То есть
[13:53.520 --> 14:01.680]  давайте я здесь нарисую. Так, теперь здесь поправим картинку и нарисуем продолжение суффиксного пути.
[14:01.680 --> 14:11.440]  Вот. То есть смотрите, изначально была какая ситуация? Что все вели по букве C здесь в Q. Ну и здесь
[14:11.440 --> 14:16.440]  вот дальше была вот такая вот суффиксная ссылка. Теперь я сюда буду умещать копию этой картинки.
[14:16.440 --> 14:21.640]  Так, теперь смотрите, что у нас происходит. Мы сказали, что у нас расщепление на два происходит.
[14:21.640 --> 14:35.440]  На Q и на клона. Теперь давайте выпишем суффиксные ссылки сначала. То есть вот здесь вот мы определили,
[14:35.440 --> 14:41.480]  что здесь вот переходы из клона такие же, как из Q куда-то там ведут. Тогда очевидно, что...
[14:41.480 --> 14:49.480]  Что очевидно? Что-нибудь очевидно вообще? Что раз клон наибольший суффикс СС, который мы можем
[14:49.480 --> 15:07.200]  прочитать, суффиксная ссылка СС это клон. Что еще нужно сказать? Да, Q у нас изначально указывал
[15:07.200 --> 15:15.560]  суффиксная ссылка на W. Вот этот элемент. Раз клон это, по сути, в некотором плане замена Q,
[15:15.560 --> 15:33.200]  то мы должны сказать, что линк от клона это W. И теперь так, как Q. Ну почему это так? Потому
[15:33.200 --> 15:40.520]  что клон это по сути несколько меньших суффиксов от Q. А значит суффиксная ссылка клона то же самое,
[15:40.520 --> 15:46.960]  что суффиксная ссылка Q. Потому что у вас вот эта вот W, на которую ссылался Q с суффиксной ссылкой,
[15:46.960 --> 15:52.640]  указывал наибольший суффикс, который не лежит в Q. Теперь это наибольший суффикс, который не
[15:52.640 --> 15:57.200]  лежит в клон. Значит, по определению, линк от клона это W, а линк от Q это клон.
[15:57.200 --> 16:18.680]  Линк от Q это клон. Точно-точно, потому что у вас именно в клоне лежит Epsilon. Именно клон это
[16:18.680 --> 16:27.200]  суффикс строки, нику. Потому что у вас именно эту строчку можно продолжить пустым словом,
[16:27.200 --> 16:31.960]  а это суффиксом не является уже. Ну условно это те части, которые все время предварялись вот буквой
[16:31.960 --> 16:38.400]  альфа. Вот это вот предваряется буквой гамма по этому рисунку. Так, возможно, понять не будет.
[16:38.400 --> 16:44.920]  В некотором плане я могу вот здесь отсечь и сказать, что вот здесь вот стоит гамма с рисунка,
[16:44.920 --> 16:53.960]  а здесь альфа везде. То есть вот это вот все изначальные подстроки. И раньше везде входила
[16:53.960 --> 16:59.920]  альфа, и тут появилось вхождение с гаммой. Поэтому это новый лонгест, поэтому это новый суффикс,
[16:59.920 --> 17:06.480]  и я должен сказать, что вот он, суффиксная ссылка S это клон. То есть смотрите, что еще важно заметить,
[17:06.480 --> 17:11.160]  что раньше изначально, когда мы вот без этого случая, у нас по сути все суффиксные пути были
[17:11.160 --> 17:20.960]  как какой-то бамбук. Теперь это дерево, то есть у нас появляется раздвоение. Вот. У этих суффиксных
[17:20.960 --> 17:25.680]  ссылок будет, у дерева суффиксные ссылки есть интересное устройство. Они являются суффиксным
[17:25.680 --> 17:30.120]  деревом для реверсной строки, но это так для тех, кто знает, что такое суффиксное дерево. Скорее всего
[17:30.120 --> 17:38.920]  почти никто. Окей, последнее. Надо разобраться с тем, как устроены переходы из кув-клона. Что
[17:39.000 --> 17:49.320]  для этого нужно сделать? Это P, это Q. Для этого по-хорошему мы должны взять и
[17:49.320 --> 17:56.160]  пропрыгать по суффиксным ссылкам из P и перенаправить некоторые ребра, которые подсошли в кув-клона.
[17:56.160 --> 18:16.920]  Вроде бы логично. При этом раз мы объявили, что T равновлоги стат-клона, что можно сказать на самом
[18:16.920 --> 18:23.200]  деле? То мы должны перенаправить из P, из всего суффиксного пути до вот некоторые вершины,
[18:23.200 --> 18:30.400]  которые ведет уже в W. Все ребра в клоуна на самом деле. Здесь будет вот такая вот конструкция.
[18:30.400 --> 18:43.920]  Но опять же почему? Потому что у вас по сути логист от клоуна это получение логиста от P,
[18:43.920 --> 18:50.800]  приписав букву C. Поэтому переход здесь вот такой вот в клоуна ведется, а не в Q. Вы мне скажете,
[18:50.800 --> 18:53.720]  что Q стала недостижимой вершиной. Я скажу, что она достижима по другим буквам.
[18:53.720 --> 19:19.240]  Поэтому мы здесь говорим while, tu от P по букве C это Q, мы говорим tu от P, C это клон,
[19:19.240 --> 19:32.280]  и по по по мы говорим P равно link от P. Все это последний случай. Это вот все.
[19:32.280 --> 19:44.840]  Случай 3. Все, алгоритм закончен. Мы молодцы, мы справились. Я справился, вы не знаете.
[19:44.840 --> 19:50.440]  Надеюсь, что справились. Если нет, задавайте вопросы. Потому что по букве C, если она была
[19:50.440 --> 19:56.360]  достижима только по букве C, значит у вас логист от Q это логист от P плюс 1 просто-напросто по
[19:56.360 --> 20:00.920]  буквам. По соотношению букв должно быть. То есть у вас выполнится вот это вот равенство.
[20:00.920 --> 20:06.600]  Оно может не выполнится только если Q достижима по другим буквам в большую сторону. То есть есть
[20:06.600 --> 20:13.400]  путь длиннее, заканчивается на другую букву. Поэтому если у вас Q была достижима только по
[20:13.400 --> 20:19.240]  букве C, значит выполнится всегда вот этот вот случай. И поэтому мы здесь не будем ребра удалять
[20:19.240 --> 20:25.480]  в эту щавку. А в третьем случае мы их перекидываем. Так, теперь нужно про симптотику поговорить.
[20:25.480 --> 20:40.920]  Теперь я без доказательства. Если длина строки больше либо равна 4, либо 3, я тут, к сожалению,
[20:40.920 --> 20:56.400]  не помню точную оценку, либо 3, либо 4, то число ребер не превосходит у такой отмечены. Доказывать
[20:56.400 --> 21:01.680]  не будем. Это сложно доказывается. Я даже нигде не видел нормального доказательства, вот так скажу.
[21:01.680 --> 21:06.840]  Но скорее всего только в оригинальной статье содержится где-нибудь. Поэтому оставим это так.
[21:06.840 --> 21:13.560]  И мы с вами доказывали так типа методом уркомаханий. На семинаре вы должны были
[21:13.560 --> 21:26.600]  по индукции или конструктивно доказать, что если больше равна 2, то число вершин не превосходит
[21:26.600 --> 21:40.760]  2 модуля с минус 1, причем это оценка точная строка, по которой вы строите автомат. То есть на ребрах
[21:40.760 --> 21:48.640]  вас не смутило, да? На вершинах смутило, окей. Так, что это значит? Вот давайте из этого утверждения,
[21:48.640 --> 21:57.680]  из этой теоремы, которую я не доказываю, какие выводы могу сделать. Первое, что вот этот вайл,
[21:57.680 --> 22:03.760]  первый случай, он порождает только новые ребра. Значит суммарно его число итераций не больше,
[22:03.760 --> 22:08.280]  чем число ребер. А число ребер линейно по линии строки. Значит эти вайлы исполняются линейно,
[22:08.280 --> 22:15.200]  суммарно. Это первое. То есть случай 1 суммарно за линию работает. Все возможные ситуации
[22:16.120 --> 22:21.080]  аналогичны реализации случая 2, потому что они ничего нового не приносят с собой в плане ребер.
[22:21.080 --> 22:29.560]  Единственное, что приносит... окей, хорошо, что дальше можно сказать? Теперь разбираем
[22:29.560 --> 22:38.320]  случай 3. Это все от единицы делается, это нам не важно вообще. Вот это вот. Это порождает
[22:38.320 --> 22:44.000]  новые ребра, а новых ребер суммарно вообще линия. Поэтому это укладывается все еще в симптомику
[22:44.000 --> 22:49.960]  нашу. Последний вот этот вайл. Потому что он не порождает новых ребер, но меняет только старые.
[22:49.960 --> 22:56.720]  Это проблема. Почему? Потому что это единственная ситуация, когда мы не можем сказать, что укладывается
[22:56.720 --> 23:03.280]  вот это вот неравенство 3r с минус 4. И теперь нужно как-то доказать, что суммарно вот этих вот вайлов
[23:03.280 --> 23:09.160]  тоже линия. Доказывается на самом деле это очень просто. А именно давайте рассмотрим длину
[23:09.160 --> 23:14.720]  суффиксного пути из вершины соответствующей длине всей строки. Смотрим, как она меняется.
[23:14.720 --> 23:39.440]  Так, давайте здесь напишем, что в случае 1 и 2 очевидно завод модулес. Все в 3, кроме вайл тоже.
[23:39.440 --> 24:09.120]  Разбираемся с вайлом. Так, рассмотрим длину суффиксного пути из СИСЦ. Что такое суффиксный
[24:09.120 --> 24:17.920]  путь? Это цепочка суффиксных ссылок. То есть вот здесь на картинке у нас огромная цепь. Давайте
[24:17.920 --> 24:28.640]  скажем, что этот блок имеет длину m, этот блок имеет длину k, этот блок имеет длину l. Посмотрим,
[24:28.640 --> 24:37.680]  как он меняется. То есть давайте скажем, что, ну давайте я их вон на картинке, не буду вводить
[24:37.680 --> 24:47.480]  текстом, потому что я хочу закончить здесь на этом куске доски. Для С это было m плюс k плюс l.
[24:47.480 --> 25:02.960]  ДСЦ. Давайте смотреть, как меняются блоки. Так, окей, что происходит?
[25:02.960 --> 25:16.920]  Линка ТСЦ это клон. Поэтому, то есть по сути, у нас вот эта вот длина, вот этот кусок совпадает
[25:16.920 --> 25:34.280]  с этим куском. Окей? То есть вот это вот m. Будто бы. Ну да, потому что здесь m. Нет, почему m?
[25:34.280 --> 25:43.960]  Подождите. Не-не-не, вру. Вот давайте на этой картинке будем смотреть. Здесь вроде понятнее. То есть у нас было m, оно все было в q, и оно
[25:43.960 --> 25:52.080]  схлопнулось все в 1. Но это не очень важно, что оно схлопнулось в 1. Нам важно вот этот кусок. То есть нам
[25:52.080 --> 26:04.200]  важно вот этот кусочек, насколько он изменился. Так он тоже стал равен 1, да? Будто бы. Теперь тоже l осталось.
[26:04.200 --> 26:10.960]  А, ну вот, то есть я схлопнул весь этот кусок в 1.
[26:10.960 --> 26:28.240]  Вот у меня сейчас. Я хочу найти место, где у меня уменьшается длина суффиксного пути. То есть вот
[26:28.240 --> 26:33.200]  здесь вот, видите, у меня здесь очень много этих вот прыжочков. А вот здесь вот, когда я перешел в новое
[26:33.200 --> 26:39.800]  состояние, у меня все эти переходы вели из клона, теперь ведут в w. То есть у меня, если здесь был суффиксный
[26:39.800 --> 26:49.240]  путь от p до вот этой вот вершины длины k, то теперь путь из ту от p по букве c, из этой вершины по
[26:49.240 --> 27:05.840]  букве c, имеет длину 1 теперь. Так, давайте я введу вну, введу букву p штрих. Я смотрю длину суффиксного пути
[27:05.840 --> 27:15.040]  между p и p штрих от первого состояния. На втором состоянии я рассмотрю, сейчас смотрю, от p до p штрих
[27:15.040 --> 27:32.040]  и от ту от p по букве c до, это не g, от p штрих по букве c. Рассматриваю длину суффиксного пути.
[27:32.040 --> 27:39.960]  То есть здесь, если у меня длина суффиксного пути это k, вот k прыжков здесь было, то ту от p по букве c это
[27:39.960 --> 27:50.880]  клон, а ту от p штрих по букве c это w. И здесь длина суффиксного пути 1. То есть я схлопну вот этот кусок в единицу.
[27:50.880 --> 28:04.960]  Нет, вот этот кусок у вас 1, 2, 3, k. 1. Нет, я рассматриваю новый суффиксный путь от fc.
[28:05.960 --> 28:15.960]  Еще раз, я рассматриваю суффиксный путь от вершины s сначала и теперь рассматриваю суффиксный путь от вершины sc.
[28:15.960 --> 28:26.960]  Я утверждаю, что вот этот кусок, сколько реберя перенаправил сюда, вот настолько уменьшилась длина суффиксного пути.
[28:26.960 --> 28:45.960]  Ну понятно, да, почему? Потому что у вас длина от sc, это вот все, что у вас было вот здесь вот, оно превратилось в кусочки длины 1.
[28:45.960 --> 28:50.960]  Расстояние от sc до w у нас, по-моему, сократилось.
[28:50.960 --> 28:55.960]  Расстояние от sc до w, да, но расстояние от s до p штрих, оно было больше?
[28:55.960 --> 28:59.960]  Нет. Расстояние от s до p штрих, вот оно.
[28:59.960 --> 29:02.960]  И оно было точно таким же?
[29:02.960 --> 29:10.960]  Еще раз, я смотрю. Окей, вот у меня в первом состоянии было только s. Я рассматриваю длину суффиксного пути.
[29:10.960 --> 29:16.960]  Теперь стало sc. Мне пофиг, что здесь происходит. Я смотрю, вот этот вот путь.
[29:16.960 --> 29:31.960]  Да. Потому что потом я буду к sc приписывать букву. И мне вот этот суффиксный путь вообще не нужен будет для анализа.
[29:31.960 --> 29:38.960]  Для анализа мне важен суффиксный путь последней самой длинной штуки. Именно поэтому я их сравниваю.
[29:38.960 --> 29:58.960]  Вот эти вот? Да, но это мне очень важно. Нам важен этот кусок, потому что я утверждаю, что то, сколько мы ребер перенаправили, настолько мы уменьшили длину суффиксного пути.
[29:58.960 --> 30:04.960]  Поэтому мы уменьшим суммарное число прыжков в следующей итерации. Именно настолько.
[30:08.960 --> 30:18.960]  Кого? Вот здесь вот? Еще раз.
[30:18.960 --> 30:31.960]  Коперфильд момент. Я рассматриваю вот этот суффиксный путь и, внимание, сидите за руками, вот этот вот суффиксный путь.
[30:31.960 --> 30:37.960]  И вот этот кусочек, который был вот этот вот, он внезапно превратился в одно ребро.
[30:37.960 --> 30:45.960]  Вот это вот, что здесь оказалось, мне вообще не важно. Почему? Потому что когда я буду писать новую букву в конец, я буду рассматривать вот этот вот суффиксный путь.
[30:45.960 --> 30:49.960]  Я же к СС приписываю в конец букву.
[30:49.960 --> 30:55.960]  Мы рассматриваем суффиксный путь от всего слова. Да, именно так.
[30:55.960 --> 30:58.960]  И вот этот вот суффиксный путь у нас будет постоянно уменьшаться.
[30:58.960 --> 31:04.960]  И он уменьшаться будет как минимум на очло итерации вот того самого циклова. То есть как минимум на единичку он уменьшается при клоне.
[31:05.960 --> 31:09.960]  Да, короче, как минимум на один он уменьшается.
[31:09.960 --> 31:14.960]  И при этом он увеличивается не больше, чем на один, когда он увеличивается.
[31:14.960 --> 31:17.960]  Когда у вас первый или второй случай.
[31:22.960 --> 31:26.960]  Давайте даже затру эти оценки, это что-то умное.
[31:26.960 --> 31:30.960]  Давайте просто скажем, что он уменьшается.
[31:35.960 --> 31:37.960]  Да.
[31:41.960 --> 31:43.960]  Нам даже не это будет важно.
[31:43.960 --> 31:45.960]  Нам будет важно, что он уменьшается хотя бы на один.
[31:45.960 --> 31:49.960]  И каждый раз приписывая новую букву он увеличится не больше, чем на один.
[31:56.960 --> 31:59.960]  Ну да, да. Ну окей, да, это будет важно.
[32:00.960 --> 32:03.960]  Хорошо. При клонировании...
[32:04.960 --> 32:33.960]  ...суффиксный путь уменьшается ровно на число итераций цикла while в случае 3.
[32:34.960 --> 32:43.960]  И увеличивается не более, чем на один.
[32:56.960 --> 33:00.960]  Откуда следует, что суммарная линия всего итерации while?
[33:01.960 --> 33:05.960]  Ну почему? Потому что раз у вас увеличивается не более, чем на один,
[33:05.960 --> 33:11.960]  значит он у вас дорос до какого-то значения, вы его уменьшили, он снова дорос, вы снова уменьшили.
[33:12.960 --> 33:19.960]  То есть как бы раз у вас увеличивается не более, чем на один, то суммарное уменьшение может быть не более, чем длина строки.
[33:19.960 --> 33:22.960]  Поэтому суммарное число while не более, чем 2 на длину строки.
[33:22.960 --> 33:26.960]  То есть линия время. Можно так рассуждать.
[33:30.960 --> 33:40.960]  Меньше, чем 2 на длину строки.
[33:40.960 --> 33:45.960]  Все, доказали суммарные линии на время работы.
[33:45.960 --> 33:51.960]  В частности, из этого следует, что дописывание одной буквы работает в амортизированную единицу.
[33:51.960 --> 33:59.960]  И на этом мы заканчиваем с автоматом и переходим, казалось бы, к вообще неожиданному, а именно к преобразованию фурья.
[33:59.960 --> 34:02.960]  Что такое быстрое преобразование фурья?
[34:02.960 --> 34:06.960]  Это быстрый способ вычислить дискретное преобразование фурья.
[34:06.960 --> 34:12.960]  Давайте я скажу страшное определение преобразования фурья в мотоне.
[34:12.960 --> 34:20.960]  Короче, если f очень хорошее, f хорошее, да.
[34:20.960 --> 34:26.960]  Это не нужно будет нигде знать, это просто к тому, чтобы вы понимали, откуда эта интуиция берется.
[34:27.960 --> 34:31.960]  Но это слишком хорошее, можно похуже.
[34:31.960 --> 34:41.960]  То преобразование фурья от функции f, то есть f большое, это некоторый оператор, который берет в себя функцию и возвращает функцию.
[34:41.960 --> 34:45.960]  Добавляем 1, достаточно сказать.
[34:45.960 --> 34:55.960]  f от, так сейчас, f от x, вводы x.
[34:55.960 --> 34:59.960]  Вот такая формула страшная.
[34:59.960 --> 35:01.960]  Насладились?
[35:01.960 --> 35:03.960]  Это множество действительных чисел.
[35:03.960 --> 35:06.960]  Ну, от минус бесконечности до бесконечности интегрировал.
[35:06.960 --> 35:08.960]  Интеграл в смысле лебего.
[35:08.960 --> 35:13.960]  Короче, давайте вы будете считать, что вот это очень страшная запись.
[35:13.960 --> 35:17.960]  Второй курс понимают, первый курс не понимают и верят, что это интеграл Риммана.
[35:22.960 --> 35:28.960]  Там есть тонкие грани, о которые мы опустим, потому что я уже не вспомню настолько тонких вещей.
[35:31.960 --> 35:33.960]  Лебегу супер интегрировать всегда.
[35:38.960 --> 35:40.960]  Но если вы так говорите, у вас смотан плохой.
[35:46.960 --> 35:50.960]  Вот, соответственно, что дальше можно сказать?
[35:50.960 --> 35:52.960]  Давайте превратим это в дискретный случай.
[35:54.960 --> 35:56.960]  Что дальше в дискретный случай?
[35:57.960 --> 36:02.960]  Пусть f задана спектром значений.
[36:02.960 --> 36:13.960]  Или мы знаем ее значение в n точках.
[36:13.960 --> 36:22.960]  Ну, в качестве примера можно взять, что, по сути, мелодия это некоторая сумма гармонических сигналов.
[36:22.960 --> 36:24.960]  И они непрерывны. Вау.
[36:26.960 --> 36:30.960]  Вот, соответственно, как вы передаете музыку по телефону?
[36:30.960 --> 36:34.960]  Она не передается как непрерывная функция, она передается как какой-то дискретный спектр.
[36:35.960 --> 36:38.960]  И, соответственно, качество или битрейт?
[36:38.960 --> 36:43.960]  Это вот сколько у вас точек берется, чтобы получить как можно точнее зависимость.
[36:47.960 --> 36:49.960]  Ну, n точек.
[36:49.960 --> 36:52.960]  Тогда мы можем определить переобразование феерии дискретное.
[36:57.960 --> 36:58.960]  Равно...
[37:00.960 --> 37:01.960]  О, сейчас.
[37:06.960 --> 37:09.960]  Интеграл превращается внезапно в красивую штучку.
[37:16.960 --> 37:19.960]  Минус и х жито у.
[37:23.960 --> 37:25.960]  И это получится с какое-то одно значение.
[37:26.960 --> 37:28.960]  Что какая-то лажа, чего не должно быть.
[37:31.960 --> 37:34.960]  А, ну почему у нас... Нет, и это комплексная единица.
[37:35.960 --> 37:36.960]  От у.
[37:36.960 --> 37:39.960]  А, ну да, вы можете разные у перекидывать и все.
[37:40.960 --> 37:43.960]  Все нормально. Построили дискретное преобразование.
[37:46.960 --> 37:50.960]  Собственно, преобразование фурье, это вот это дискретное преобразование фурье, знакомьтесь.
[37:51.960 --> 37:54.960]  Оно удобно тем, что у него есть обратное преобразование,
[37:54.960 --> 37:59.960]  и тем, что оно получается из значения вот этой штуки в у соответствующих.
[37:59.960 --> 38:02.960]  Вы можете вернуть фиксы просто минус и заменив на и.
[38:05.960 --> 38:08.960]  Нет, это вам на аутоне должны были доказать.
[38:12.960 --> 38:15.960]  Так вам это даже знать не надо. Я это так рассказываю.
[38:17.960 --> 38:19.960]  Так, теперь...
[38:21.960 --> 38:29.960]  Теперь я возьму следующее, что на самом-то деле, по-хорошему, вообще зачем нам все это надо?
[38:30.960 --> 38:36.960]  Я хочу передать какую-то непрерывную функцию f, да, по каналу связи.
[38:36.960 --> 38:40.960]  Но в общем-то я не могу передать какую-то непрерывную функцию f в силу определенных ограничений.
[38:42.960 --> 38:46.960]  Например, потому что внезапно непрерывную функцию f передать очень сложно.
[38:46.960 --> 38:48.960]  Потому что у вас сигнал дискретный обычно.
[38:48.960 --> 38:51.960]  Поэтому есть такая теория о маряде фурье,
[38:53.960 --> 38:59.960]  что все еще, если функция достаточно хорошая, в частности 2p периодическое.
[38:59.960 --> 39:01.960]  Ну, вы можете сделать 2p периодическое,
[39:01.960 --> 39:03.960]  потому что у вас сигнал ограничен по времени,
[39:03.960 --> 39:07.960]  сожмите его до 2p линейным отображением и дополните до периодичной.
[39:08.960 --> 39:11.960]  Поэтому любую функцию определенной отрезки можно дополнить до 2p периодичной.
[39:11.960 --> 39:13.960]  ЦК и КХ.
[39:15.960 --> 39:16.960]  По-моему, так вот.
[39:17.960 --> 39:18.960]  Это ряд фурье.
[39:20.960 --> 39:21.960]  К – это, соответственно, номер.
[39:21.960 --> 39:23.960]  Он от минуса бесконечности до бесконечности суммируется.
[39:24.960 --> 39:25.960]  То есть можно сказать, что это просто два ряда.
[39:25.960 --> 39:28.960]  В одном до плюс бесконечности от 0 до 0 другом.
[39:29.960 --> 39:31.960]  От минус одного до минус бесконечности.
[39:32.960 --> 39:34.960]  Вот как-то стоит понимать с точки зрения Маттона.
[39:36.960 --> 39:37.960]  Конечно.
[39:37.960 --> 39:38.960]  Ну, окей, если вы не согласны с этим.
[39:42.960 --> 39:45.960]  До бесконечности ЦК и КХ.
[39:47.960 --> 39:53.960]  Плюс сумма по К от единички до бесконечности.
[39:53.960 --> 39:56.960]  Ц-катых е в степени минус и КХ.
[39:57.960 --> 39:59.960]  Вот как-то стоит понимать с точки зрения Маттона.
[40:00.960 --> 40:02.960]  Если вам не нравится запись таким.
[40:02.960 --> 40:04.960]  Все равно на третьем курсе вы будете только так писать.
[40:05.960 --> 40:07.960]  Там комплексных переменных это будет.
[40:08.960 --> 40:09.960]  Вот, окей.
[40:09.960 --> 40:10.960]  Что теперь нужно сказать?
[40:12.960 --> 40:15.960]  Нужно сказать, что чем больше вот этих вот ц-катых...
[40:15.960 --> 40:16.960]  А, можно сказать следующее.
[40:16.960 --> 40:18.960]  Что раз вы можете функцию F разложить в ряд фурье,
[40:19.960 --> 40:20.960]  то что значит?
[40:20.960 --> 40:22.960]  Это значит, что вы можете просто передать,
[40:23.960 --> 40:26.960]  будто бы ц-каты по каналу связи,
[40:26.960 --> 40:27.960]  и человек сможет установить F.
[40:27.960 --> 40:28.960]  Логично.
[40:28.960 --> 40:30.960]  И чем больше вы этих ц-катых передадите,
[40:30.960 --> 40:33.960]  тем больше точность будет вашего передаванного сигнала.
[40:34.960 --> 40:38.960]  Собственно, чем больше вы ц-катых передадите, тем лучше.
[40:38.960 --> 40:42.960]  И внезапно всякий формат качества музыки зависит в том числе от этого.
[40:43.960 --> 40:44.960]  Вот.
[40:44.960 --> 40:47.960]  Ну, видео туда же, картинки туда же, все туда же.
[40:47.960 --> 40:50.960]  Все вот эти вот сигналы продолжительные, это все вот сюда.
[40:51.960 --> 40:52.960]  Вот.
[40:52.960 --> 40:53.960]  Окей.
[40:53.960 --> 40:55.960]  А что мы теперь хотим?
[40:56.960 --> 40:57.960]  По-хорошему,
[41:00.960 --> 41:01.960]  что здесь нужно сказать?
[41:03.960 --> 41:04.960]  Наверное, все, что нужно сказать на самом деле.
[41:04.960 --> 41:06.960]  А, ну, можно сказать, как ц-каты искать, например.
[41:07.960 --> 41:09.960]  Ц-каты искать неприятно, сразу вам скажу.
[41:10.960 --> 41:13.960]  Ц-каты в некотором плане выражаются вот так вот.
[41:14.960 --> 41:16.960]  С точностью числового коэффициента.
[41:17.960 --> 41:18.960]  Вот.
[41:18.960 --> 41:19.960]  Выражается вот так вот.
[41:21.960 --> 41:23.960]  С точностью числового коэффициента сразу скажу,
[41:23.960 --> 41:25.960]  потому что я не очень вспомню сейчас.
[41:29.960 --> 41:31.960]  Это преображение Fourier функции в точке k.
[41:37.960 --> 41:40.960]  Возможно, там нужно где-то в преображении Fourier численный коэффициент поставить
[41:40.960 --> 41:43.960]  и по 1 делить на корень из 2p, но я не вспомню сейчас, к сожалению.
[41:44.960 --> 41:45.960]  Что?
[41:45.960 --> 41:48.960]  Зависит от того, как вы нормируете преображение Fourier, скажем так.
[41:48.960 --> 41:50.960]  Здесь я уже с точностью к коэффициенту не вспомню.
[41:51.960 --> 41:52.960]  И это не очень важно.
[41:53.960 --> 41:54.960]  Нам важнее другое.
[41:54.960 --> 41:59.960]  То есть, по сути дела, если мы можем быстро вычислять ц-каты,
[42:00.960 --> 42:01.960]  значит, мы умеем быстро вычислять f.
[42:01.960 --> 42:02.960]  И наоборот.
[42:02.960 --> 42:04.960]  Если мы быстро вычисляем f, мы умеем быстро вычислять ц-каты.
[42:05.960 --> 42:07.960]  Но операция интегрирования, причем с комплексным экспонентом,
[42:07.960 --> 42:09.960]  выглядит не очень интересной.
[42:11.960 --> 42:13.960]  Поэтому человечество придумало чуть более интересное,
[42:13.960 --> 42:16.960]  поэтому человечество придумало чуть более интеллектуальную схему.
[42:17.960 --> 42:18.960]  Давайте сделаем следующее.
[42:19.960 --> 42:21.960]  Если у нас есть непрерывный сигнал f, давайте приблизим его многочленам.
[42:22.960 --> 42:23.960]  Это же мы можем делать?
[42:24.960 --> 42:30.960]  Функция f, если она достаточно нормальная, то ее можно приблизить рядом Тейлора.
[42:31.960 --> 42:33.960]  Это уже первокурсники тоже должны знать.
[42:34.960 --> 42:35.960]  Вот, молодцы.
[42:36.960 --> 42:38.960]  Раз вы знаете ряд Тейлора, значит, функция f там многочлен.
[42:39.960 --> 42:40.960]  Окей.
[42:40.960 --> 42:42.960]  Многочленам все еще легко передать.
[42:42.960 --> 42:44.960]  Попробуйте передать коэффициента теперь.
[42:45.960 --> 42:46.960]  Вот.
[42:47.960 --> 42:54.960]  Но прикол в том, что сигналы интересны тем, что вы хотите не только получать, как многочлен,
[42:55.960 --> 42:59.960]  а раз у вас периодичность какая-то, у вас будет гармонический сигнал, сумма синусоид и косинусоид.
[43:02.960 --> 43:06.960]  Раз вы хотите сумму синусоид и косинусоид, вам нужно что-то интеллектуальнее придумывать,
[43:07.960 --> 43:09.960]  чем просто многочлен, а именно тригонометрический многочлен.
[43:09.960 --> 43:10.960]  То есть вот эта вот штука тригонометрический многочлен.
[43:11.960 --> 43:15.960]  Поэтому давайте не будем тратить время на Тейлора, на самом деле, и точности.
[43:16.960 --> 43:21.960]  А скажем, что раз это тригонометрический многочлен, то мы можем считать его значение в интересных точках.
[43:22.960 --> 43:25.960]  И явно их передавать просто-напросто, чтобы можно было обратно его ставить.
[43:26.960 --> 43:27.960]  Вот.
[43:28.960 --> 43:30.960]  И теперь мы приходим к тому, что, собственно, наша задача какая?
[43:31.960 --> 43:38.960]  Мы должны по функции f найти какой-то набор чиселок, значений в каких-то точках интересных.
[43:39.960 --> 43:42.960]  Передать их, и человек должен с момента их восстановить.
[43:43.960 --> 43:49.960]  Поэтому быстрое преобразование фурьер, в нашем случае конкретно, оно будет что делать?
[43:50.960 --> 43:52.960]  Оно будет вычислять интересную штуку.
[43:53.960 --> 44:06.960]  А именно, то есть быстрое преобразование фурьер, или по-английски fast, фурьер transform.
[44:10.960 --> 44:11.960]  FFT.
[44:12.960 --> 44:14.960]  Оно будет брать...
[44:15.960 --> 44:21.960]  Вообще изначально берет функцию f какую-то, и вычисляет это значение в комплексных корнях из единицы.
[44:22.960 --> 44:26.960]  Страшно, очень страшно, я учусь и прощу жизнь.
[44:26.960 --> 44:54.960]  По многочлену P, такому что степень P не превосходит k, ну, минус 1, вычисляет вектор следующего вида.
[44:54.960 --> 45:05.960]  P от Омега в нулевой, P от Омега в первой, P от Омега к минус первой.
[45:06.960 --> 45:08.960]  Где Омега?
[45:14.960 --> 45:16.960]  2еп деленное на k.
[45:17.960 --> 45:19.960]  Почему это так? Почему такое именно число подбирается?
[45:19.960 --> 45:29.960]  Ну, потому что Омега вжитый, давайте посмотрим, что это такое.
[45:30.960 --> 45:37.960]  Ну да, берется обычно примитивный корень, и примитивный, наверное, так выражается.
[45:38.960 --> 45:43.960]  Чем эта штука классная? Тем, что у нее корни зацикливаются.
[45:44.960 --> 45:47.960]  Ну, окей, первого курса звыл комплексное число?
[45:47.960 --> 45:51.960]  Отлично, значит напоминаем второму курсу.
[45:54.960 --> 45:56.960]  Вот наша комплексная окружность.
[46:07.960 --> 46:13.960]  Окружность радиуса r, угол phi, тогда z можно так расписать, через формулу Эйлера.
[46:13.960 --> 46:22.960]  Окей, теперь мы заметим, что у нас Омега здесь радиуса нет, поэтому мы будем считать, что окружность единичная.
[46:27.960 --> 46:30.960]  Так, дальше что? Что?
[46:32.960 --> 46:39.960]  Ну да, потому что я сказал, что у нас здесь нет r, поэтому она единичная. Вот, радиус один.
[46:40.960 --> 46:42.960]  Так, что еще теперь нужно сказать?
[46:43.960 --> 46:49.960]  А, ну окей, теперь посмотрим, какие выглядят правильные корни катой степени из единицы.
[46:50.960 --> 46:57.960]  Внезапно единичка входит в это множество, и дальше вы разбиваете свою окружность.
[47:01.960 --> 47:03.960]  Надеюсь, что у меня получится подгадать.
[47:04.960 --> 47:06.960]  Будем считать, что да, направленный коугольник.
[47:09.960 --> 47:14.960]  То есть phi равно 2 pi деленное на k.
[47:15.960 --> 47:19.960]  То есть вот у вас ваша комплексная корня из единицы расположена на окружности.
[47:20.960 --> 47:22.960]  Но они и зацикливаются, очевидно.
[47:23.960 --> 47:26.960]  Собственно, свойства зацикливания нам и будет важно.
[47:27.960 --> 47:32.960]  Поэтому на самом деле можно брать любую алгебрическую структуру, у которой можно зациклить корень.
[47:33.960 --> 47:37.960]  В частности, можно взять Zm и первообразный корень по модулем, если он существует.
[47:40.960 --> 47:42.960]  Так.
[47:46.960 --> 47:48.960]  Это будет в ходе алгоритма, понятно.
[47:49.960 --> 47:51.960]  Мы потом придем к месту, где нам это понадобится.
[47:52.960 --> 47:54.960]  Да.
[47:55.960 --> 47:59.960]  Сейчас вы должны понять, что FFT берет многочлен, а возвращает вам вектор значений.
[48:00.960 --> 48:01.960]  Все.
[48:02.960 --> 48:04.960]  Это все, что надо знать пока что.
[48:05.960 --> 48:06.960]  Что?
[48:06.960 --> 48:08.960]  Нет, P это просто многочлен, самый обычный.
[48:09.960 --> 48:11.960]  Там 2, плюс 3x, плюс 5x квадрат, например.
[48:13.960 --> 48:14.960]  Что? Нет.
[48:15.960 --> 48:20.960]  Вы берете многочлен, считаете его значение в омеге, в первой, омега во второй и так далее.
[48:31.960 --> 48:35.960]  Ну не знаю, так это a0, x0.
[48:37.960 --> 48:39.960]  То есть вот такой вот набор.
[48:42.960 --> 48:43.960]  Массив a.
[48:44.960 --> 48:45.960]  Массив a, да.
[48:46.960 --> 48:49.960]  То есть по сути, да, на самом деле это крайне важный вопрос, почему.
[48:50.960 --> 48:54.960]  Потому что, грубо говоря, многочлен это кортеж.
[48:55.960 --> 48:58.960]  Вау, да. Если что, многочлен формально является как кортеж.
[48:59.960 --> 49:01.960]  Не как вот сумма мономов.
[49:02.960 --> 49:04.960]  То есть по сути, в некотором плане вектор.
[49:05.960 --> 49:07.960]  То есть у вас многочлен это вектор длины k.
[49:08.960 --> 49:11.960]  И преобразование фурье выплевывает вам вектор длины k.
[49:12.960 --> 49:14.960]  Как вы думаете, преобразование фурье линейно?
[49:18.960 --> 49:19.960]  Да, оно линейно.
[49:20.960 --> 49:21.960]  Поэтому вы можете знать матрицей.
[49:23.960 --> 49:24.960]  На самом-то деле.
[49:25.960 --> 49:31.960]  Ну и по сути, преобразование, то есть по сути, преобразование фурье это линейное преобразование на rk.
[49:31.960 --> 49:34.960]  Ну, на ck точнее, что комплексно можете возвращать.
[49:35.960 --> 49:43.960]  И в некотором плане можно заявить, что у вас работают там всякие теоремы о собственных значениях, собственных векторах преобразования фурье.
[49:44.960 --> 49:45.960]  Можно их себе посчитать.
[49:46.960 --> 49:47.960]  Разложите его в диагональный вид.
[49:48.960 --> 49:49.960]  Он даже существует там нормальный.
[49:50.960 --> 49:51.960]  Блочный диагональный, по-моему, там точно существует.
[49:52.960 --> 49:53.960]  И все вообще красиво.
[49:54.960 --> 49:55.960]  То есть там вся очень красивая линейная алгебра с этим всем связана.
[49:56.960 --> 49:57.960]  Но мы это пока что опустим.
[49:58.960 --> 50:00.960]  И все-таки пора переходить к алгоритму наконец.
[50:01.960 --> 50:02.960]  Потому что сейчас совсем все плохо.
[50:03.960 --> 50:04.960]  Но в каждом нужно просто научиться преобразовать многочлены.
[50:05.960 --> 50:06.960]  Это наша главная цель.
[50:07.960 --> 50:08.960]  По сути дела, я могу заявить, что преобразование фурье многочлены.
[50:09.960 --> 50:15.960]  То есть в некотором плане я могу заявить, что у меня было дискретное преобразование фурье.
[50:16.960 --> 50:18.960]  Игрики могу разные подсовывать.
[50:19.960 --> 50:21.960]  Ну, давайте я буду читать лев в многочленам.
[50:22.960 --> 50:23.960]  Тогда преобразование фурье многочлены.
[50:24.960 --> 50:26.960]  Буду подсовывать в ней разные омеги.
[50:27.960 --> 50:30.960]  Ну и здесь вот заменю на что-то другое, другую ортогональную систему функций.
[50:31.960 --> 50:38.960]  Это тоже пентизм, а то на четвертого семестра, первый курс неважно.
[50:38.960 --> 50:46.960]  Сейчас мы рассуждаем о том, как вот это вот сделать быстро.
[50:46.960 --> 50:59.960]  Давайте заметим, что запишем просто-напросто связь между векторами a0, a1 и так далее, ak-1 и вот этими вот.
[51:00.960 --> 51:19.960]  Выписываем p от ω0, это a0, ω в нулевой плюс a1, ω в первой, ой, это ω в нулевой вот так вот, ω в нулевой в первой,
[51:19.960 --> 51:33.960]  а во второй, ω в нулевой во второй, плюс ak-1, давайте n-1 я буду дальше писать, ω в нулевой, в степени n-1.
[51:33.960 --> 51:36.960]  Согласны? Ну это вроде просто я поставил вместо xa, ω в нулевой.
[51:36.960 --> 51:39.960]  Ну да.
[51:39.960 --> 51:57.960]  Ну понятно, что p от ω в первой я буду везде заменять на ω в первой, по скобкам.
[51:57.960 --> 52:21.960]  То есть я могу расписать, что p от ω в житой равно a0, ω в житой на 0, с a1, ω в житой на 1, a n, ой, n-1 конечно здесь везде, ω в степени g-1, n-1, согласны?
[52:21.960 --> 52:41.960]  Тогда давайте я запишу матрицу w, ω в степени i g, где i g в таких пределах ходят. То есть это просто матрица вот этих вот ω.
[52:41.960 --> 52:50.960]  Тогда что я могу сказать? Я могу расписать вот такую вот матричную постановку задачи.
[52:50.960 --> 53:09.960]  w от ω в степени n-1, это w умножить на вектор a0, a1, a n-1.
[53:09.960 --> 53:15.960]  Внимание, это знание нам сейчас не нужно. Мы идем дальше.
[53:15.960 --> 53:38.960]  То есть я хочу вычислить значение многощина p в степени n-1 в n точках. Вот моя цель. Я могу это сделать за квадрат, просто перемножив патрицу на вектор. Я считаю, что это долго. Нифига, конечно. Долго.
[53:38.960 --> 53:49.960]  Я хочу быстрее, хочу ZEN-логенто сделать. Для этого я рассмотрю следующий, так сказать, схему кули-чьюки она называется. Ну по фамилиям авторов внезапно.
[53:49.960 --> 53:59.960]  Нет.
[53:59.960 --> 54:04.960]  Кули. На букву K.
[54:04.960 --> 54:09.960]  Чьюки.
[54:09.960 --> 54:14.960]  На финском, вот куда авторы.
[54:14.960 --> 54:35.960]  Введу p четное от x, a0, plus a2x, plus a4x2 и так далее. Введу p нечетное от x, это a1, a3x.
[54:35.960 --> 54:50.960]  Зачем? Теперь внимание, то, что они придумали.
[54:50.960 --> 55:05.960]  Знаете, почему это сильно? Это сильно, потому что теперь зачем нам нужно было зацыхливание корней?
[55:05.960 --> 55:20.960]  Потому что если вычисляю эту штуку в корнях омега в нулевой, омега в первой и так далее, в степени n-1 пополам, я вычислю значение p в соответствующих степенях.
[55:20.960 --> 55:29.960]  Потому что у меня здесь, если я буду вычислять в значениях омега в нулевой, омега в первой и так далее, омега в n-1 у меня зациклится.
[55:29.960 --> 55:36.960]  И уникальных значений будет только n пополам. Именно поэтому мне нужно было зацикливание.
[55:36.960 --> 55:43.960]  Поэтому здесь мне достаточно вычислить значение в n пополам точках. И здесь в n пополам точках. И за линию слить результаты.
[55:43.960 --> 55:45.960]  Поэтому рекуррента тогда получается.
[56:03.960 --> 56:04.960]  Можно?
[56:04.960 --> 56:11.960]  То есть что у нас с вами происходит на самом деле?
[56:11.960 --> 56:14.960]  На самом деле у нас происходит следующее.
[56:14.960 --> 56:18.960]  То есть в коде это выглядит так. У меня есть массив.
[56:18.960 --> 56:23.960]  Давайте сразу скажу, что n это степень двойки.
[56:28.960 --> 56:31.960]  Точнее n коэффициент в этом степень двойки.
[56:31.960 --> 56:36.960]  Если многочлен у нас не степень двойки, то полноте нулями старший коэффициент до степени двойки.
[56:36.960 --> 56:37.960]  Все будет хорошо.
[56:39.960 --> 56:41.960]  Окей, что теперь нужно сказать?
[56:42.960 --> 56:44.960]  Всего хорошего, всем пока.
[56:45.960 --> 56:47.960]  Но, к сожалению, нет.
[56:47.960 --> 56:49.960]  Нет, надо сказать.
[56:49.960 --> 56:52.960]  Надо сказать, что как это выглядит в коде.
[56:52.960 --> 56:55.960]  В коде вы передаете ему fft, функции fft.
[56:55.960 --> 56:58.960]  Вы передаете ему вектор коэффициентов.
[56:58.960 --> 57:00.960]  Дальше передаете вот эту n.
[57:00.960 --> 57:02.960]  И передаете комплексный корень.
[57:05.960 --> 57:09.960]  Дальше вы собираете почетный по нечетный.
[57:09.960 --> 57:11.960]  Вызываете два раза рекурсивное fft.
[57:13.960 --> 57:14.960]  В каком плане два раза?
[57:14.960 --> 57:16.960]  Вызываете его от четного от нечетного.
[57:16.960 --> 57:21.960]  При этом передаете ему туда соответствующие вектора коэффициентов, четные и нечетные.
[57:21.960 --> 57:26.960]  Дальше передаете ему вместо n, n пополам.
[57:28.960 --> 57:29.960]  И последнее.
[57:29.960 --> 57:32.960]  Вы должны передать туда какой комплексный корень.
[57:32.960 --> 57:34.960]  Ну, какой комплексный корень?
[57:34.960 --> 57:36.960]  Ломика квадрата надо передать.
[57:37.960 --> 57:38.960]  Ну все.
[57:40.960 --> 57:41.960]  Вот.
[57:42.960 --> 57:43.960]  Окей.
[57:44.960 --> 57:48.960]  Поэтому от работы с nLogan мы научились с вами прямое преобразование в Fourier делать.
[57:48.960 --> 57:52.960]  Ну, в базе рекурсии вектор длины 1, верните a0.
[57:52.960 --> 57:54.960]  Все, конец.
[57:58.960 --> 57:59.960]  Окей.
[57:59.960 --> 58:05.960]  То есть вот этот алгоритм, если что, он входит в топ-3 алгоритма 20 века по полезности.
[58:05.960 --> 58:09.960]  Потому что он позволяет вам быстро преобразовывать сигнал сворачивать.
[58:10.960 --> 58:11.960]  Ой, я не вспомню сейчас что.
[58:11.960 --> 58:13.960]  Там что-то с почмотами связано, по-моему.
[58:13.960 --> 58:19.960]  Там в целом куча алгоритмов, связанных с вычислениями и приближенными вычислениями.
[58:20.960 --> 58:22.960]  И моделированием, точнее.
[58:22.960 --> 58:23.960]  Вот. Окей.
[58:24.960 --> 58:25.960]  Что теперь?
[58:26.960 --> 58:30.960]  Теперь я хочу сказать следующее, что...
[58:30.960 --> 58:33.960]  Какой план по перемножению многочленов у нас с вами?
[58:34.960 --> 58:35.960]  То есть у нас a.
[58:45.960 --> 58:46.960]  b.
[58:46.960 --> 58:47.960]  c.
[58:53.960 --> 58:56.960]  Здесь m-1, m-1.
[58:58.960 --> 59:04.960]  k равно 2 в степени, округленный вверх,
[59:04.960 --> 59:07.960]  двоичный алгоритм от m плюс n минус 2.
[59:09.960 --> 59:13.960]  То есть это такая степень двойки, в которую заведомо влезет наш результат.
[59:13.960 --> 59:18.960]  Потому что при перемножении многочленов максимум, что вы можете получить, это сумма крайних степеней.
[59:18.960 --> 59:20.960]  То есть m плюс n минус 2.
[59:22.960 --> 59:24.960]  Вот. Окей. Что дальше нужно сказать?
[59:25.960 --> 59:26.960]  Шаг первый.
[59:28.960 --> 59:30.960]  Вычисли...
[59:30.960 --> 59:31.960]  ФФТС, b.
[59:32.960 --> 59:33.960]  Шаг второй.
[59:36.960 --> 59:37.960]  Внимание.
[59:46.960 --> 59:50.960]  Вот я не рассказал вам, что это такое,
[59:50.960 --> 59:52.960]  но я не знаю, как это сделать.
[59:52.960 --> 59:54.960]  Но я не знаю, как это сделать.
[59:54.960 --> 59:56.960]  Я не знаю, как это сделать.
[59:56.960 --> 59:58.960]  Я не знаю, как это сделать.
[59:58.960 --> 01:00:02.960]  Вот я не рассказывал про свертку, про свертку будет чуть-чуть дальше.
[01:00:02.960 --> 01:00:07.960]  Однако есть интересное свойство, что преобразование фурье в свертке это произведение сверток.
[01:00:10.960 --> 01:00:11.960]  Точнее...
[01:00:11.960 --> 01:00:14.960]  Ну да, преобразование фурье в свертке это будет...
[01:00:14.960 --> 01:00:15.960]  Господи...
[01:00:16.960 --> 01:00:18.960]  Неважно, короче, что это будет.
[01:00:18.960 --> 01:00:22.960]  А, преобразование фурье в свертке это произведение преобразования фурье.
[01:00:22.960 --> 01:00:25.960]  В каком-то плане берется поточечное.
[01:00:25.960 --> 01:00:27.960]  То есть вы знаете значение...
[01:00:27.960 --> 01:00:29.960]  Вот это значение a в омегах.
[01:00:29.960 --> 01:00:31.960]  Это значение b в омегах.
[01:00:31.960 --> 01:00:34.960]  То вы берете и вычитаете a на b в омегах.
[01:00:34.960 --> 01:00:35.960]  Поточечное.
[01:00:36.960 --> 01:00:43.960]  То есть здесь вот имеется в виду, что a на b от омега в житой.
[01:00:44.960 --> 01:00:48.960]  От омега в житой равно a от омега в житой.
[01:00:48.960 --> 01:00:50.960]  На b от омега в житой.
[01:00:52.960 --> 01:00:54.960]  Ну да, концепт.
[01:00:56.960 --> 01:00:58.960]  Шаг третий, самый сложный.
[01:01:00.960 --> 01:01:01.960]  Вычисли...
[01:01:13.960 --> 01:01:15.960]  И получал b, соответственно.
[01:01:16.960 --> 01:01:18.960]  Вот это мы с вами умеем делать за o от n log n.
[01:01:18.960 --> 01:01:20.960]  Ну, в нашем случае k.
[01:01:23.960 --> 01:01:25.960]  Это вообще за o от k.
[01:01:25.960 --> 01:01:28.960]  Потому что это просто поточечное преимножение надо сделать.
[01:01:28.960 --> 01:01:30.960]  Теперь как обратное считать.
[01:01:30.960 --> 01:01:34.960]  Тут стрельнет великое ружье Бондарчука.
[01:01:35.960 --> 01:01:37.960]  В виде вот этой постановки.
[01:01:37.960 --> 01:01:40.960]  Что я сделал? Я преимножил матрицу на вектор за n log n.
[01:01:40.960 --> 01:01:43.960]  Что я сделал? Я преимножил матрицу на вектор за n log n.
[01:01:43.960 --> 01:01:45.960]  То есть что я сделал?
[01:01:45.960 --> 01:01:49.960]  Я сделал произведение вот этой матрицы на этот вектор.
[01:01:49.960 --> 01:01:50.960]  За n log n.
[01:01:50.960 --> 01:01:53.960]  С помощью той схемы разделить власту.
[01:01:54.960 --> 01:01:58.960]  Теперь я должен взять и домножить на w в минус 1 слева.
[01:01:58.960 --> 01:01:59.960]  Обе части равенства.
[01:01:59.960 --> 01:02:02.960]  Тогда я получу, наоборот, вектор коэффициентов по этой штуке.
[01:02:03.960 --> 01:02:04.960]  То есть,
[01:02:04.960 --> 01:02:08.960]  Заметьте, умножать на матрицу w на вектор,
[01:02:08.960 --> 01:02:11.960]  причем матрица выливаема специфичная, в ней корни зацикливаются.
[01:02:11.960 --> 01:02:13.960]  Именно поэтому и можно так быстро все сделать.
[01:02:13.960 --> 01:02:15.960]  А не потому что это произвольная матрица.
[01:02:15.960 --> 01:02:17.960]  В общем случае это неверно.
[01:02:18.960 --> 01:02:20.960]  Что можно так быстро все посчитать.
[01:02:21.960 --> 01:02:23.960]  Теперь я хочу найти обратную матрицу.
[01:02:23.960 --> 01:02:25.960]  Матрица w.
[01:02:26.960 --> 01:02:28.960]  Вот такая вот интересная.
[01:02:39.960 --> 01:02:41.960]  Почти.
[01:02:42.960 --> 01:02:44.960]  Там придется чуть-чуть поделить ее еще.
[01:02:46.960 --> 01:02:54.960]  Да, теперь давайте я буду считать w на v и ты житый.
[01:02:55.960 --> 01:02:57.960]  Что это такое?
[01:02:57.960 --> 01:03:07.960]  Сумма по k в минус 1 и k ты житый.
[01:03:08.960 --> 01:03:11.960]  Уберу, просто расписываю запление w.
[01:03:11.960 --> 01:03:13.960]  И запление v, которое вон там вот.
[01:03:14.960 --> 01:03:18.960]  Эта сумма по k от 0 в минус 1.
[01:03:19.960 --> 01:03:26.960]  Омега в степени и к, а омега в степени минус к жи.
[01:03:30.960 --> 01:03:31.960]  Дай минус 1.
[01:03:32.960 --> 01:03:35.960]  Омега в степени к и минус жи.
[01:03:36.960 --> 01:03:37.960]  Согласны?
[01:03:38.960 --> 01:03:40.960]  Так, теперь давайте вахнем.
[01:03:40.960 --> 01:03:42.960]  И равно жи.
[01:03:45.960 --> 01:03:47.960]  Что случается, если и равно жи?
[01:03:48.960 --> 01:03:50.960]  Равно n, если и равно жи.
[01:03:55.960 --> 01:03:57.960]  То есть на диагонаре стоят одинаковые элементы.
[01:03:57.960 --> 01:03:58.960]  Уже классно.
[01:03:58.960 --> 01:04:00.960]  Уже близко к единичной.
[01:04:01.960 --> 01:04:02.960]  И понятно, что надо будет делить.
[01:04:02.960 --> 01:04:04.960]  Осталось показать, что в остальных местах ноль будет.
[01:04:04.960 --> 01:04:07.960]  Ну, здесь давайте считать сумму геометрической прогрессии.
[01:04:07.960 --> 01:04:08.960]  Чему она равна?
[01:04:13.960 --> 01:04:15.960]  Ну ладно, понятно, почему она ноль суммируется.
[01:04:15.960 --> 01:04:17.960]  Потому что это геометрическая сумма корней.
[01:04:20.960 --> 01:04:21.960]  Давайте допишу.
[01:04:25.960 --> 01:04:28.960]  И здесь я могу сказать по геометрическому свойству компонентов.
[01:04:29.960 --> 01:04:31.960]  Ну, это уже ну, это уже ну, так что.
[01:04:31.960 --> 01:04:38.960]  Здесь я могу сказать по геометрическому свойству комплексных корней, это ноль, но давайте выпишу все-таки формулу.
[01:04:44.960 --> 01:04:50.960]  Что-то такое, по-моему, должно быть. То есть вы берете omega v на минус 1 и omega v на минус 1.
[01:04:51.960 --> 01:04:53.960]  Кого? Конечно.
[01:05:01.960 --> 01:05:03.960]  А что вам не нравится?
[01:05:04.960 --> 01:05:06.960]  Почему я вот это вынес?
[01:05:11.960 --> 01:05:13.960]  Так нет. А, или да.
[01:05:14.960 --> 01:05:16.960]  Согласен.
[01:05:17.960 --> 01:05:19.960]  Переиграли.
[01:05:20.960 --> 01:05:23.960]  Давайте, ладно, давайте просто напишем полностью.
[01:05:24.960 --> 01:05:27.960]  Нет. Да нет, ладно, я просто напишу полностью.
[01:05:28.960 --> 01:05:31.960]  Справедливо, здесь вы доплавили меня.
[01:05:40.960 --> 01:05:42.960]  Вот так вот.
[01:05:43.960 --> 01:05:45.960]  Вот это, правда, похоже.
[01:05:46.960 --> 01:05:51.960]  Ну, потому что это номинатель геометрической прогрессии, а это n степень его.
[01:05:52.960 --> 01:05:54.960]  Ну, в любом случае, это равно 1.
[01:05:54.960 --> 01:06:02.960]  Почему? Потому что это omega v, и минус g минус 1 делить на и минус g минус 1.
[01:06:03.960 --> 01:06:06.960]  Вот эта часть не равна нулю, потому что эта часть не равна единице.
[01:06:07.960 --> 01:06:09.960]  Вот эта часть равна единице.
[01:06:10.960 --> 01:06:11.960]  Omega v равен единице.
[01:06:12.960 --> 01:06:14.960]  Еще одно, зачем нам нужно было зацикливать корней?
[01:06:17.960 --> 01:06:19.960]  Равну нулю.
[01:06:19.960 --> 01:06:29.960]  Ну, откуда я получаю, что v, то есть что w в минус 1, это 1 деленное на nv.
[01:06:32.960 --> 01:06:34.960]  Ну, тогда что я сделаю?
[01:06:35.960 --> 01:06:40.960]  Давайте я домножу, сделаю то же самое преобразование в Fourier, абсолютно.
[01:06:41.960 --> 01:06:46.960]  Только передам ему вместо omega привитивного корня, omega в минус 1.
[01:06:47.960 --> 01:06:53.960]  Я получу умножение на v слева этого вектора тогда, потому что я все то же самое абсолютно делаю.
[01:06:54.960 --> 01:06:56.960]  Единственное, что мне останется делать, это поделить на n конечный результат.
[01:06:57.960 --> 01:06:59.960]  Конец. Это обратное преобразование в Fourier.
[01:07:00.960 --> 01:07:02.960]  Поэтому на самом деле все очень просто.
[01:07:07.960 --> 01:07:09.960]  В смысле, что значит округлить?
[01:07:10.960 --> 01:07:12.960]  И что? Они комплексные.
[01:07:16.960 --> 01:07:17.960]  Ну да.
[01:07:18.960 --> 01:07:19.960]  Нет, зачем?
[01:07:29.960 --> 01:07:32.960]  Да, проблема в преобразовании в Fourier в том, что он вычислительно неустойчивый.
[01:07:33.960 --> 01:07:34.960]  Очень сильно.
[01:07:35.960 --> 01:07:42.960]  Потому что у вас все-таки комплексные корни из единицы, они имеют вещественные коэффициенты.
[01:07:43.960 --> 01:07:44.960]  И это очень грустно.
[01:07:44.960 --> 01:07:46.960]  И здесь есть два решения.
[01:07:47.960 --> 01:07:49.960]  Первое решение – это смириться и забить.
[01:07:50.960 --> 01:07:55.960]  Второе решение – если вы имеете право работать в ZP, взять нужный вам ZP.
[01:07:56.960 --> 01:07:58.960]  То есть P, который достаточно большой.
[01:07:59.960 --> 01:08:01.960]  То есть больше, чем вот это вот k.
[01:08:04.960 --> 01:08:05.960]  И что?
[01:08:06.960 --> 01:08:10.960]  И по нему считать уже в нем преобразование в Fourier, зная первообразный корень.
[01:08:11.960 --> 01:08:14.960]  Все выкладки абсолютно будут действовать.
[01:08:15.960 --> 01:08:17.960]  Ну все, конец на этом, в общем-то.
[01:08:19.960 --> 01:08:22.960]  Так, проблема в ZP в Fourier – то, что хотелось рассказать.
[01:08:23.960 --> 01:08:25.960]  Давайте я расскажу быстренько про свертку последовательности тогда.
[01:08:26.960 --> 01:08:28.960]  Потому что мы научились переносить многочисленную. Согласна?
[01:08:33.960 --> 01:08:36.960]  Это с одной стороны – нет, почему-то столько же абсолютно.
[01:08:36.960 --> 01:08:40.960]  Только там не будет даблов, комплексных чисел не будет, там все будет ZP.
[01:08:41.960 --> 01:08:43.960]  Потому что остатки модуля придется брать, да, это правда.
[01:08:56.960 --> 01:08:58.960]  Ну да, ну вы берите не сильно прям большую.
[01:08:58.960 --> 01:09:00.960]  Между P и 2P всегда есть одно простое.
[01:09:01.960 --> 01:09:03.960]  Постулат Бертрана, по-моему, это называется.
[01:09:07.960 --> 01:09:10.960]  Ну в смысле нет, это потому, что между любым числом мы его удвоим, что-то простое.
[01:09:14.960 --> 01:09:17.960]  Ну нет, вы знаете значение максималида, возьмите просто P большой и все.
[01:09:18.960 --> 01:09:19.960]  Например, так.
[01:09:22.960 --> 01:09:23.960]  Зафиксируйте P.
[01:09:23.960 --> 01:09:25.960]  Зафиксируйте P, найдите на бумажке.
[01:09:32.960 --> 01:09:33.960]  Можно так, да.
[01:09:35.960 --> 01:09:37.960]  Так, ладно, все, это не интересно.
[01:09:41.960 --> 01:09:43.960]  Кого вы хотите многочисленную перемножить?
[01:09:45.960 --> 01:09:47.960]  Вы перемножили многочисленную, вы молодец.
[01:09:49.960 --> 01:09:50.960]  Ну смотрите.
[01:09:50.960 --> 01:09:54.960]  Теперь, не, касательно какие задачи могут быть еще решены этой штукой.
[01:09:55.960 --> 01:09:59.960]  Ну, помимо того, чтобы считать сами преобразование Fourier для всяких передач и сигналов,
[01:09:59.960 --> 01:10:01.960]  что еще можно сделать?
[01:10:01.960 --> 01:10:05.960]  Ну, внезапно можно, но сейчас будет, собственно, задачу, которую мы будем разбирать.
[01:10:05.960 --> 01:10:07.960]  Это раз, два, у вас на семерах будут несколько задач.
[01:10:09.960 --> 01:10:12.960]  А теперь задача, я хочу посчитать свертку последовательностей.
[01:10:13.960 --> 01:10:15.960]  То есть свертку двух дискретных сигналов.
[01:10:15.960 --> 01:10:17.960]  Сейчас я напишу определение.
[01:10:17.960 --> 01:10:19.960]  Куда вы торопитесь-то?
[01:10:26.960 --> 01:10:28.960]  Вот, n больше, чем m.
[01:10:29.960 --> 01:10:31.960]  Больше либо равно, точнее.
[01:10:31.960 --> 01:10:37.960]  Тогда c равный a звездочка b,
[01:10:37.960 --> 01:10:39.960]  c и ты, давайте так напишем.
[01:10:39.960 --> 01:10:41.960]  a звездочка b это свертка.
[01:10:43.960 --> 01:10:45.960]  И ты, член свертки, определяешь следующим образом.
[01:10:51.960 --> 01:10:54.960]  a и ты с g, b с g.
[01:10:57.960 --> 01:10:59.960]  А теперь задача 3.
[01:11:00.960 --> 01:11:04.960]  a и ты с g, b с g.
[01:11:07.960 --> 01:11:09.960]  Почему это свертка последовательностей?
[01:11:10.960 --> 01:11:13.960]  Снова страшная для первого курса знакомая второму.
[01:11:13.960 --> 01:11:15.960]  Свертка функций. Помним, как выглядит?
[01:11:29.960 --> 01:11:33.960]  Сделайте замену i плюс g, и вы получите вот это.
[01:11:34.960 --> 01:11:37.960]  Вот что значит, поэтому это свертка в дискретном случае.
[01:11:42.960 --> 01:11:45.960]  Вот это? Это скалярное произведение векторов.
[01:11:49.960 --> 01:11:51.960]  Вот не совсем.
[01:11:52.960 --> 01:11:55.960]  Сейчас мы посмотрим, как это приводится к перемножению многощенов.
[01:12:00.960 --> 01:12:03.960]  В частности, можно вычитать произведение сверток.
[01:12:03.960 --> 01:12:05.960]  Свертка произведения, здесь это верно.
[01:12:06.960 --> 01:12:08.960]  Так, теперь что мы хотим?
[01:12:08.960 --> 01:12:10.960]  Хотим почитать ту штуку.
[01:12:10.960 --> 01:12:12.960]  Давайте рассмотрим многощен a.
[01:12:23.960 --> 01:12:25.960]  И многощен b.
[01:12:29.960 --> 01:12:33.960]  Теперь я сделаю страшные. Я возьму их и перемножу. Прямо на доске.
[01:12:38.960 --> 01:12:40.960]  Что?
[01:12:44.960 --> 01:12:46.960]  Возьму и перемножу их на доске.
[01:12:46.960 --> 01:12:48.960]  Так.
[01:12:48.960 --> 01:12:50.960]  a на b
[01:12:51.960 --> 01:12:53.960]  равно
[01:12:53.960 --> 01:12:55.960]  Ну, a0b0 это понятно.
[01:12:56.960 --> 01:13:02.960]  Плюс a1b0 плюс a0b1x.
[01:13:03.960 --> 01:13:08.960]  То есть, перед x в соответствующей степени у меня будет всегда стоять сумма с соответствующими индексами.
[01:13:09.960 --> 01:13:13.960]  То есть, x первой, значит, здесь будут все суммы, которые набирают единичку.
[01:13:15.960 --> 01:13:17.960]  Ну, давайте рассмотрим.
[01:13:17.960 --> 01:13:19.960]  Айминна.
[01:13:19.960 --> 01:13:21.960]  Давайте посмотрим на сумму коэффициентов здесь.
[01:13:24.960 --> 01:13:26.960]  Да.
[01:13:26.960 --> 01:13:28.960]  Это правда.
[01:13:28.960 --> 01:13:30.960]  Айминна.
[01:13:30.960 --> 01:13:32.960]  Айминна.
[01:13:32.960 --> 01:13:34.960]  Айминна.
[01:13:34.960 --> 01:13:36.960]  Айминна.
[01:13:36.960 --> 01:13:38.960]  Айминна.
[01:13:38.960 --> 01:13:40.960]  Айминна.
[01:13:40.960 --> 01:13:42.960]  Айминна.
[01:13:42.960 --> 01:13:44.960]  Айминна.
[01:13:44.960 --> 01:13:46.960]  Айминна.
[01:13:46.960 --> 01:13:48.960]  Это правда.
[01:13:48.960 --> 01:13:50.960]  Но если я заменю...
[01:13:50.960 --> 01:13:52.960]  Ладно, окей, пока что оставим это так.
[01:13:52.960 --> 01:13:54.960]  Но если бы...
[01:13:54.960 --> 01:13:56.960]  Нет, я не буду спойлерить.
[01:13:56.960 --> 01:14:00.960]  Я лучше распишу что-нибудь при, наверное...
[01:14:00.960 --> 01:14:03.960]  Давайте распишем, что будет происходить при x в степени n-1.
[01:14:09.960 --> 01:14:11.960]  Ой, при m-1, конечно же.
[01:14:11.960 --> 01:14:13.960]  Извините.
[01:14:13.960 --> 01:14:25.960]  Из m-1, m-2, m-3, a-m-1, b-0.
[01:14:25.960 --> 01:14:27.960]  x в степени m-1.
[01:14:27.960 --> 01:14:29.960]  Найдите актера в гриме.
[01:14:35.960 --> 01:14:38.960]  Если актер непонятен, давайте еще следующего выпишу чувака.
[01:14:44.960 --> 01:14:46.960]  Да.
[01:14:51.960 --> 01:14:53.960]  Сейчас. Нет, здесь a-1.
[01:14:53.960 --> 01:14:55.960]  Здесь a-2, здесь a-3.
[01:14:57.960 --> 01:15:01.960]  Плюс a-m-1.
[01:15:01.960 --> 01:15:03.960]  Сейчас. Нет.
[01:15:05.960 --> 01:15:07.960]  Кого я обманываю? Себя.
[01:15:07.960 --> 01:15:09.960]  B-0.
[01:15:09.960 --> 01:15:15.960]  Нет, все-таки здесь a-m просто будет.
[01:15:15.960 --> 01:15:17.960]  Ну плюс и так далее.
[01:15:17.960 --> 01:15:19.960]  Это нам уже не очень важно.
[01:15:19.960 --> 01:15:21.960]  То есть, смотрите.
[01:15:21.960 --> 01:15:25.960]  Здесь постоянно сумма по индексам.
[01:15:25.960 --> 01:15:27.960]  А здесь посмотрим, кто здесь постоянен.
[01:15:27.960 --> 01:15:31.960]  И плюс g, минус g это что?
[01:15:31.960 --> 01:15:33.960]  ВОО.
[01:15:33.960 --> 01:15:35.960]  Давайте я заменю
[01:15:35.960 --> 01:15:37.960]  и буду с вот таким вот сворачивать.
[01:15:40.960 --> 01:15:42.960]  Неважно.
[01:15:44.960 --> 01:15:46.960]  Ну окей, да.
[01:15:49.960 --> 01:15:52.960]  Я к тому, что вот в таком случае сумма была бы постоянной.
[01:15:55.960 --> 01:15:57.960]  Но я лох и довольствуюсь божитым.
[01:15:59.960 --> 01:16:03.960]  Как превратить житы в m-1-житы?
[01:16:04.960 --> 01:16:06.960]  Да.
[01:16:06.960 --> 01:16:08.960]  Давайте возьмем и определим
[01:16:08.960 --> 01:16:10.960]  ref от b.
[01:16:12.960 --> 01:16:16.960]  bm-1 на x0.
[01:16:16.960 --> 01:16:18.960]  Плюс bm-2x.
[01:16:20.960 --> 01:16:22.960]  m-3x2.
[01:16:23.960 --> 01:16:25.960]  Плюс b0.
[01:16:25.960 --> 01:16:27.960]  x в m-1.
[01:16:27.960 --> 01:16:31.960]  Тогда, если я перемножу a на ref от b,
[01:16:31.960 --> 01:16:33.960]  я должен буду...
[01:16:33.960 --> 01:16:37.960]  То есть, если я рассмотрю свертку a и ref от b,
[01:16:37.960 --> 01:16:41.960]  я получу как раз-таки вот эти вот коэффициентики.
[01:16:41.960 --> 01:16:43.960]  Да?
[01:16:47.960 --> 01:16:49.960]  Что мне надо, значит, сделать?
[01:16:51.960 --> 01:16:53.960]  Да, все, конец.
[01:16:53.960 --> 01:16:55.960]  m-1...
[01:16:55.960 --> 01:16:57.960]  Плюс b0-g.
[01:17:00.960 --> 01:17:04.960]  Короче, прием минус 1, m, m плюс 1 и так далее,
[01:17:04.960 --> 01:17:06.960]  пока там сумму будут удовлетворять.
[01:17:06.960 --> 01:17:09.960]  Вот. Это свертка последовательностей, собственно.
[01:17:09.960 --> 01:17:11.960]  То есть, что мы с вами сделали?
[01:17:11.960 --> 01:17:15.960]  По сути, мы с вами научились искать вот такое скалярное произведение
[01:17:15.960 --> 01:17:17.960]  длинной строчки
[01:17:17.960 --> 01:17:22.960]  на маленькую строчку, которую мы прикладываем во всех позициях.
[01:17:25.960 --> 01:17:27.960]  Ну и так далее.
[01:17:27.960 --> 01:17:29.960]  И мы это умеем делать быстро.
[01:17:29.960 --> 01:17:33.960]  То есть, в некотором плане мы сможем считать близость паттерна к строке
[01:17:33.960 --> 01:17:36.960]  очень быстро, близость в плане скалярного произведения.
[01:17:38.960 --> 01:17:42.960]  И теперь у нас остается минус 4 минуты времени,
[01:17:42.960 --> 01:17:44.960]  к сожалению.
[01:17:44.960 --> 01:17:48.960]  Поэтому я не успеваю рассказать то, зачем мы это проходили
[01:17:48.960 --> 01:17:50.960]  с точки зрения строк.
[01:17:50.960 --> 01:17:54.960]  С другой стороны, тогда у нас на следующей лекции это останется.
[01:17:54.960 --> 01:17:56.960]  Там будет задача о K-опечатках.
[01:17:56.960 --> 01:18:00.960]  С помощью свертки мы поймем, как искать вхождение с K-опечатками.
[01:18:00.960 --> 01:18:03.960]  Там будет преобразование фурье K штук надо писать.
[01:18:03.960 --> 01:18:05.960]  Вот это первое.
[01:18:05.960 --> 01:18:07.960]  Второе, что еще будет?
[01:18:07.960 --> 01:18:11.960]  Мы научимся делить многочлены друг на друга.
[01:18:13.960 --> 01:18:15.960]  Не, столбик долгий, займем лукен.
[01:18:15.960 --> 01:18:17.960]  Где-то степень старшего.
[01:18:19.960 --> 01:18:21.960]  Вот план такой у нас на следующую лекцию тогда.
[01:18:21.960 --> 01:18:24.960]  И там, видимо, еще многомерное преобразование фурье будет.
[01:18:26.960 --> 01:18:27.960]  Нет.
[01:18:28.960 --> 01:18:29.960]  Нет.
[01:18:30.960 --> 01:18:33.960]  Там по методу Ньютона с преобразованием фурье внутри.
[01:18:34.960 --> 01:18:35.960]  Нет.
[01:18:38.960 --> 01:18:39.960]  Сейчас говорите по второму закону Ньютона.
