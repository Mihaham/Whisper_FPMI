[00:00.000 --> 00:09.520]  Лекция номер 8, которая будет посвящена функциям.
[00:09.520 --> 00:21.000]  Это прекрасная тема, потому что функции — это новый этап в нашей жизни изучения программирования.
[00:21.000 --> 00:25.560]  Когда мы начинали с вами изучать программирование, мы говорили принципы,
[00:25.560 --> 00:31.160]  на которых строится вообще программа. Они были сформулированы еще в 1945 году.
[00:31.160 --> 00:34.600]  Кто помнит, какой главный у нас принцип, как программа исполняется?
[00:34.600 --> 00:41.640]  Последовательно. У нас есть некий код, он исполняется последовательно. И после этого
[00:41.640 --> 00:47.560]  появилась идея структурного программирования, что он исполняется последовательно. Иногда нам
[00:47.560 --> 00:52.400]  надо сделать какие-то решения, какой-то выбор. Вообще говорят, что вся жизнь стоит из выбора и
[00:52.880 --> 00:59.960]  последствий выбора, которые мы совершаем. Вот вы, например, решили поступать на физтех, наверняка
[00:59.960 --> 01:06.520]  ваш жизнь как-то от этого изменится. Последствия выбора вы еще на себе ощутите. Если бы, например,
[01:06.520 --> 01:10.240]  вы поступали в другой вуз, там были бы другие последствия выбора. Если бы никуда не поступали
[01:10.240 --> 01:16.680]  в третий, тоже интересный выбор. Можно в армию было сходить или еще что-нибудь поделать. Поэтому
[01:16.680 --> 01:23.640]  всегда есть у вас выбор. Вот это у нас появилось вветвление. Ну а потом вы прекрасно знаете,
[01:23.640 --> 01:28.280]  что жизнь наша не такая совершенная. Иногда надо выполнять много-много каких-то действий,
[01:28.280 --> 01:33.280]  например, там вот день сурка. Если вы смотрели, вы понимаете идею, что жизнь человека очень часто
[01:33.280 --> 01:41.080]  монотонна. Мы встаем, идем на работу, возвращаемся с работы, смотрим YouTube, ложимся спать и так далее.
[01:41.080 --> 01:51.840]  И у вас мы встаем и ходим на пары, идем в столовую. Я, честно, тоже сходил после нашей пары в столовую
[01:51.840 --> 01:58.640]  КПМ, и вот жив, все нормально. Видите, все еще перед вами. Так что проверил на себе. Идете в
[01:58.640 --> 02:05.840]  столовую, и после этого тоже вечером что-нибудь там расшариваете друг к другу. И после этого
[02:05.840 --> 02:10.200]  обязательно программируете. Мы договаривались, что у нас каждый день час хотя бы программирования.
[02:10.320 --> 02:15.720]  Обязательно программируете, ложитесь спать. И вот примерно у вас тоже такой повторяющийся процесс,
[02:15.720 --> 02:21.920]  этот цикл. И вот у нас программирование, наше составление программ было из трех ключевых вещей,
[02:21.920 --> 02:28.080]  линейное, ветвление и цикл. Но если бы вся программа наша была только такая, нам очень сложно было бы ее
[02:28.080 --> 02:36.080]  разрабатывать, например, совместно с другими. Или даже самому вам было бы сложно, если проект очень
[02:36.080 --> 02:41.640]  большой, никак его не декомпозировать на какие-то законченные блоки, в которых вы можете, например,
[02:41.640 --> 02:47.280]  быть уверены, что оно работает. Потому что когда у вас огромная программа, то как мы ее отлаживаем?
[02:47.280 --> 02:51.680]  Мы пытаемся понять, что вот эта часть работает, а вот эта часть не работает. Вот знаете, как вот
[02:51.680 --> 02:55.760]  телевизор, когда мастер приходил, раньше, я помню, когда я был маленький, у нас был такой большой
[02:55.760 --> 02:59.960]  телевизор, мастер как приходил чинить? Он на дно вытаскивал деталь, вставлял вместо нее работающую.
[02:59.960 --> 03:04.800]  Ага, это не эта деталь, методом исключения. Но мы точно должны понимать, что какие-то части, вот мы в них,
[03:04.800 --> 03:09.720]  например, уверены. Вот эту часть мы отлаживаем, потому что если у нас такой хаос, и мы не понимаем,
[03:09.720 --> 03:15.120]  как вообще поделить на части, то отлаживать сразу миллион строчек кода очень сложно,
[03:15.120 --> 03:20.600]  практически невозможно, или искать там ошибку. И Страуструбт, создатель языка C++, вообще сказал,
[03:20.600 --> 03:28.920]  что функции были созданы для того, чтобы навести порядок в хаосе программы. Поэтому функции,
[03:28.920 --> 03:35.560]  это первое, что появилось в структурном программировании, такая абстракция,
[03:35.560 --> 03:41.640]  которая позволяет нам декомпозировать программу на какие-то законченные блоки. У функции есть
[03:41.640 --> 03:48.840]  некая точка входа и выхода, это некий вообще, как можно сравнить с черным ящиком, и это называется
[03:48.840 --> 03:56.040]  инкапсуляцией, скрытие того, как этот черный ящик работает. Вам важно знать только что, что есть некий
[03:56.040 --> 04:09.360]  интерфейс, когда вы получаете некие данные входные, и этот интерфейс, там какие-то параметры. Потом
[04:09.360 --> 04:15.200]  как-то оно там работает, и вам не важно знать как, и после этого получаете ответ. Например,
[04:15.200 --> 04:20.800]  функция суммы двух чисел, какой у нее будет интерфейс? Мы получаем два числа, она как-то там
[04:20.800 --> 04:28.760]  тужицу-тужицу складывает супер алгоритмом, и получаем на выходе результат суммы двух чисел или функция
[04:28.760 --> 04:35.280]  модуля числа. Когда мы с вами, бедный оператор, простите, что я все время хожу, но я вот такой вот,
[04:35.280 --> 04:46.880]  вот не могу стоять на месте. Функция модуля числа, это когда вы даете какое-то число, там происходит
[04:46.880 --> 04:53.120]  супер сложное условие, зависимость от того числа положительно и отрицательно считается его модуль,
[04:53.120 --> 04:59.520]  и вы получаете ответ. И вот эта инкапсуляция, это скрытие данных от пользователя, который
[04:59.520 --> 05:04.120]  пользуется этой функцией. То есть пользователь, в данном случае для нас, это другой программист,
[05:04.120 --> 05:08.280]  который пользуется какой-то библиотекой или функцией. Ему не важно содержание, мы должны
[05:08.280 --> 05:12.520]  быть уверены, что когда мы вызываем какую-то библиотечную функцию, но, например, я не знаю,
[05:13.080 --> 05:17.840]  которую мы с вами уже пробовали или функцию пау в изведении степени, вы должны быть уверены,
[05:17.840 --> 05:22.600]  что она правильно вам работает, вы не должны лезть в библиотеку Microsoft Visual Studio, проверять,
[05:22.600 --> 05:27.360]  что в степень там возводится действительно правильно, потому что мы доверяем библиотекам,
[05:27.360 --> 05:34.840]  которые у нас есть. И это вот тот самый новый уровень абстракции, который появился,
[05:34.840 --> 05:40.880]  который позволяет теперь совместно разрабатывать программы. Когда он появился, у нас где-то в
[05:40.880 --> 05:48.480]  70-х годах. Понятно, что мы идем с вами исторически, то есть дальше у нас были другие вещи, но что это
[05:48.480 --> 05:53.360]  нам дало? Это дало, что один человек пишет одну функцию, другую-другую функцию, мы можем
[05:53.360 --> 05:59.480]  декомпозировать большой проект, потом это соединять. И у нас есть законченные вот эти блоки. Ну и сами,
[05:59.480 --> 06:04.280]  когда вы пишете теперь одну программу, вам надо... Слушайте, лекция пять минут назад началась,
[06:04.280 --> 06:09.800]  а вы уже заснули, а что же будет через три часа? Вот, у вас день с урка неправильный, вы ночью не
[06:09.800 --> 06:18.240]  спите, видимо. Значит, мы с вами сейчас используем функцию, но дальше у вас будет целый курс на втором
[06:18.240 --> 06:23.840]  семестре объектно-ориентированное программирование. Как вы помните, я вам говорил, что наше кафедрое
[06:23.840 --> 06:28.400]  программирование будет с вами целых три семестра. У некоторых это три экзамена, у некоторых два,
[06:28.400 --> 06:36.560]  в зависимости от групп. Я вам писал в начале семестра эту табличку. Так вот, это будет новый
[06:36.560 --> 06:42.800]  уровень. Абстракция — это классы, когда мы будем уже не совсем замыкать только функцию, но и добавим
[06:42.800 --> 06:49.840]  к ней некие данные, и это будет у нас с вами следующий этап. Но пока вот функции. Теперь давайте
[06:49.840 --> 06:55.240]  запишем формальное определение функции. Это именованная последовательность описаний и
[06:55.240 --> 07:05.640]  операторов, выполняющие какое-либо законченное действие. Функция — это именованная последовательность
[07:05.680 --> 07:09.560]  описаний и операторов, выполняющая какое-либо законченное действие.
[07:20.160 --> 07:28.240]  Выполняющая какое-либо законченное действие. Именованная последовательность описаний и операторов,
[07:28.240 --> 07:43.080]  выполняющая какое-либо законченное действие. Любая программа на C++ у нас состоит из функций. Как
[07:43.080 --> 07:47.960]  вы помните, у нас есть одна особая функция, с которой начинается выполнение программы. Это
[07:47.960 --> 07:56.200]  функция main. Она должна обязательно присутствовать. И любая функция должна быть объявлена и
[07:56.200 --> 08:01.000]  определена. Что такое объявление и определение, сейчас мы рассмотрим более подробно, потому что это
[08:01.000 --> 08:10.680]  очень важные вещи. Итак, сначала синтаксис. Каким образом мы работаем с функцией? Есть
[08:10.680 --> 08:19.000]  необязательная часть объявления функции, называющаяся class. После этого идёт тип возвращаемого значения
[08:19.000 --> 08:26.680]  функции, потом имя функции. У него тоже есть идентификатор, потому что как у вас есть имена,
[08:26.680 --> 08:31.040]  так и у переменных имена, так и у функций имена. Всем понятно, как к кому обращаться.
[08:31.040 --> 08:48.880]  Вот. И после того, как у нас есть имя, у нас есть некий список параметров. Он тоже у нас
[08:48.880 --> 08:53.320]  идёт в квадратных скобках. Это значит, что необязательная часть синтаксиса. То есть может
[08:53.320 --> 09:09.040]  не быть у нас параметров функции. Она может быть без параметров. Если мы говорим, что это полное
[09:09.040 --> 09:16.680]  определение функции, то мы сразу делаем тело функции. То есть те операторы, которые у нас идут,
[09:16.680 --> 09:28.840]  внутри называются телом то, что у нас исполняется. Какой класс у нас может быть? По умолчанию у
[09:28.840 --> 09:35.560]  нас всегда класс экстерн. Можно его не писать. Это значит, что функция у нас видна во всех
[09:35.560 --> 09:43.440]  модулях. Глобальная видимость. И у нас есть статик. Это значит, что данная функция видна только в
[09:43.440 --> 09:51.680]  пределах данного модуля. Данного файла, где у вас располагаются функции, потому что у вас программа
[09:51.680 --> 10:03.680]  может стать из нескольких модулей, которые собираются линковщиком уже. Теперь про тип.
[10:03.680 --> 10:12.600]  Давайте поговорим. Тип у нас может быть с вами любой, кроме функции массива, но может быть
[10:12.600 --> 10:19.600]  указателем на функцию массив. Пометьте себе это, пожалуйста. То есть любой, кроме функции массива,
[10:19.600 --> 10:35.200]  но может быть указателем на функцию массив. Имя. Это правило стандартного идентификатора.
[10:35.200 --> 10:50.160]  То есть я могу назвать 456 функцию? Нет, а как мне назвать? А 456. Это я корейских сериалов
[10:50.160 --> 11:05.520]  насмотрелся, простите. Я, как вы думаете, могу назвать функцию? Это будет более сложный вопрос.
[11:05.520 --> 11:11.720]  Давайте вы над ним подумаете, можно ли назвать функцию как и переменные. Давайте чуть позже с
[11:11.720 --> 11:17.460]  этим разберемся. Писок параметров. Ну, собственно, параметры, которые у нас будут функцией, они
[11:17.460 --> 11:27.100]  объявляются через запятую. Все, что пока нам надо знать. И у нас, как я сказал, есть объявление,
[11:27.100 --> 11:36.860]  а есть определение. Вот с этим давайте сейчас разберемся и приведем пример. Например, я в
[11:36.860 --> 11:42.300]  начале хочу объявить ту самую функцию суммы, о которой я рассказывал. Это некая супер сложная
[11:42.300 --> 11:48.780]  функция, которая складывает два числа. Я хочу сделать сначала ее объявление, то есть не
[11:48.780 --> 11:55.140]  реализовывать тело функции, а объявить, что такая функция будет где-то реализована чуть позже в коде.
[11:55.140 --> 11:59.980]  Но до первого вызова этой функции мы должны объявить для того, чтобы компилятор знал,
[11:59.980 --> 12:06.580]  что такая функция будет и какие у него параметры, и правильно работал с ней. То есть вот если я хочу
[12:06.780 --> 12:13.700]  где-то здесь ее использовать, то она должна до этого места быть объявлена, что есть такая функция. Итак,
[12:13.700 --> 12:21.420]  функция сумма. И есть разные способы. Я могу просто написать int int, не писать даже имена
[12:21.420 --> 12:26.780]  никакие, когда я объявляю. Я просто говорю, что у меня будет вот такой у меня прототип. То есть у
[12:26.780 --> 12:34.380]  меня будет функция суммы реализована, где будет два int приниматься, один int возвращаться. Обязательно
[12:34.380 --> 12:42.740]  ставить точку запятой, закрывать объявление функции. Можно написать сюда переменные? Можно. Они
[12:42.740 --> 12:47.740]  должны совпадать с определением или как-то иметь значение? Нет, они ни на что не влияют. Они
[12:47.740 --> 12:53.020]  все равно игнорируются компилятором при компиляции. А зачем тогда их писать? Какой смысл писать
[12:53.020 --> 12:58.180]  здесь переменные, если они все равно игнорируются? Кто-нибудь может привести разумную причину,
[12:58.180 --> 13:12.700]  иногда полезно в объявлении писать имена переменных. Ну, например, приведите примеры
[13:12.700 --> 13:20.720]  переменных, которые вы там напишете. Там делимое частное. То есть вы имеете в виду,
[13:20.720 --> 13:27.760]  что совершенно верно. Когда функция несет, например, деление одного числа на другое,
[13:27.760 --> 13:32.880]  чтобы не запутаться, что на что делится, называя переменным нужным образом, мы просто подсказываем
[13:32.880 --> 13:39.360]  фактически это некий комментарий, говорящие имена такие, которые сразу скажут человеку,
[13:39.360 --> 13:44.440]  что в этой функции какой параметр, не надо смотреть в комментарии. То есть это действительно
[13:44.440 --> 13:55.880]  единственный разумный способ, когда нам надо писать здесь эти имена. Теперь у нас есть функция
[13:55.880 --> 14:07.000]  main, она идет наследом, и в этой функции мы будем сейчас с вами использовать нашу сумму. Давайте объявим
[14:07.000 --> 14:22.800]  a равно 2, b равно 3, c и d. Пусть у меня такая вот несложная программка. Я могу вызов сделать c равна
[14:22.800 --> 14:45.560]  сумма a и b. В данном случае у нас функция стоит в правой части оператора. Присваивание. Что
[14:45.560 --> 14:52.880]  происходит здесь? Мы подставляем a и b, они подставляют сюда. Причем функция еще не определена,
[14:52.880 --> 14:57.720]  мы не знаем, как там это делается. Сейчас определим позже. Какой-то результат вот этого
[14:57.720 --> 15:04.320]  работы черного ящика. Я хочу к Распринскам инкапсуляции до вас донести, что нам вот момент
[15:04.320 --> 15:11.240]  вызова неважно, как она работает. Это делает другой человек. Мы можем декомпозировать там
[15:11.240 --> 15:15.840]  на разных людей, если это какая-то команда, или даже на себя, но в разные временные промежутки,
[15:15.840 --> 15:22.520]  и можем не помнить, как оно, или даже не знать, а потом написать, что очень тоже интересный момент.
[15:22.520 --> 15:27.760]  Мы уже знаем, что нам это понадобится, но еще не знаем, как это сделать, но уже можем на это
[15:27.760 --> 15:35.240]  ссылаться. Это знаете, как начинать инвестировать миллион долларов. Вот я шел сюда, а там плакат
[15:35.240 --> 15:40.520]  известной компании, когда надо начинать инвестировать. Вчера рядом со столовой как раз,
[15:40.680 --> 15:47.200]  чтобы никто мимо не прошел. Но если ты вчера не начал, то сегодня уже еще не поздно. Мое мнение
[15:47.200 --> 15:53.400]  другое, что если ты в этом ничего не понимаешь, то лучше все-таки сегодня не надо начинать. Там
[15:53.400 --> 15:58.120]  есть более профессиональные люди, которые радостно возьмут ваши деньги и как бы на ваши
[15:58.120 --> 16:04.600]  неопытности заработают. Это же фактически перекладывание денег из одного кармана в другой.
[16:04.600 --> 16:09.960]  Если это не ваш перекладывается, вам не очень от этого инвестирования приятно. Так вот,
[16:09.960 --> 16:16.440]  здесь то же самое. Мы не знаем, как это реализовывать, и мы не знаем, можем с вами
[16:16.440 --> 16:20.640]  сказать, вот когда у меня будет миллион долларов, я буду делать такую стратегию. Здесь то же самое.
[16:20.640 --> 16:30.120]  Я знаю, что у меня будет сумма, и как ее делать неважно. Теперь можно ли использовать еще как-то
[16:30.120 --> 16:36.640]  эту сумму, кроме как просто явно вызвав в правой части операции присваивания. Что ты еще
[16:36.640 --> 16:41.840]  можешь делать? Конечно, можно, например, использовать в выражениях. Можно, например,
[16:41.840 --> 16:50.640]  вывести на экран. Я не пишу здесь не include, не using. У нас весь такой код все-таки больше про
[16:50.640 --> 16:55.880]  содержание, поэтому потом не рассказывайте мне, что она не компилируется. Да, она не компилируется,
[16:55.880 --> 17:01.960]  потому что я не включил в библиотеке. Но все остальное правильно. Я просто помню на второй
[17:01.960 --> 17:12.840]  лекции, когда мне вы сказали, вся сумма c и d. Вот я так, c и d не введены. Давайте не будем плохой
[17:12.840 --> 17:22.840]  код писать, например, a и 2. Вот, a и 2. То есть, я могу в разных местах, в любом выражении. Здесь
[17:22.840 --> 17:27.400]  я могу не обязательно использовать переменные. В данном случае, могу использовать константы,
[17:27.400 --> 17:33.000]  могу использовать 2 умножить на a. То есть, совершенно разные у меня есть моменты,
[17:33.000 --> 17:42.160]  как я эту функцию вызываю. Сейчас я хочу задать вопрос. А может ли функция, в принципе, не это,
[17:42.160 --> 17:50.200]  а какая-либо стоять в левой части оператора присваивания? Не в правой, а в левый. Давайте
[17:50.200 --> 17:54.960]  мы проголосуем. Поднимите руки, кто считает, что может. Поднять руку придется все равно.
[17:54.960 --> 18:02.840]  Ага, когда заставили что-то сделать, вы начали решили послушать, что же вообще тут происходит,
[18:02.840 --> 18:09.560]  и перестали ботать мотан. Значит, функция в данном случае, видите, вот здесь у нас,
[18:09.560 --> 18:16.240]  стоит в правой части оператора присваивания, в правой. У меня вопрос гипотетически про какую-то
[18:16.720 --> 18:22.280]  функцию, не про эту вообще. Может ли быть такая функция, которая будет стоять в левой части оператора
[18:22.280 --> 18:29.600]  присваивания? Надо поднять одну руку, если вы за, то левую, если вы против, то правую, чтобы не было
[18:29.600 --> 18:35.600]  у нас давления людей друг на друга, чтобы все подняли одновременно. Вот я считаю до трех,
[18:35.600 --> 18:41.240]  и на три вы поднимаете левую или правую руку вверх, и не смотрите на соседа. Если вы считаете,
[18:41.240 --> 18:45.320]  что в левой части может стоять функция оператора присваивания, поднимайте левую руку,
[18:45.320 --> 18:51.440]  правую руку, правую, давайте так правую. Я просто показывал для вас левую, чтобы вы не перепутали.
[18:51.440 --> 19:02.720]  В общем, давайте другой способ. Этот очень сложный, хорошо, очень сложный, очень сложный. Мы
[19:02.720 --> 19:10.360]  делаем так. Я понял, что голосование должно быть очень простым. Если вы согласны с тем,
[19:10.360 --> 19:20.680]  что функция может стоять в левой части оператора присваивания, и уверены в этом, то поднимите руку.
[19:20.680 --> 19:27.680]  Если вы считаете, что нет, не поднимайте никакую руку. Все, 1-0 у нас, двоичное голосование, давайте.
[19:27.680 --> 19:34.800]  Все, что не ложь, что истина, любая рука, нога, ухо, которое поднято вверх, считается истиной,
[19:34.800 --> 19:41.280]  как C++. Итак, поднимаем руку тех, кто считает, что может в левой части. Давайте я посчитаю,
[19:41.280 --> 19:48.320]  сколько вас. Раз, два, три, четыре, пять, шесть, семь, восемь, девять, десять, одиннадцать, двенадцать,
[19:48.320 --> 19:53.360]  тринадцать, четырнадцать, пятнадцать, шестнадцать, два, офигенная еще степень двойки. Шестнадцать
[19:53.360 --> 20:00.600]  человек проголосовало, нас здесь несколько больше, наверное, наверное, человек сто, да, поэтому
[20:00.600 --> 20:10.640]  мы узнаем, вот это меньшинство, оно было право или нет, на второй лекции. Вот, хорошо. Теперь нам
[20:10.640 --> 20:15.920]  надо реализовать, но это хороший способ, это знаете, как ютубе говорит, там жмите лайк, ждите,
[20:15.920 --> 20:24.440]  ждите это самое, мы расскажем там в спецвыпуске, да, вот я. Или как вот этот сериал, который я все
[20:24.440 --> 20:29.320]  выходные смотрел и не мог остановиться, потому что всегда заканчивался на самой интересной серии,
[20:29.320 --> 20:36.520]  на самом интересном месте. Вот, теперь надо реализовать эту функцию, так что я надеюсь,
[20:36.520 --> 20:44.120]  что до второй лекции зато вы останетесь и узнаете ответ. Тоже нетфликсовские приемы удержания
[20:44.120 --> 20:54.560]  студентов максимальной посещаемости. Значит, функция сумма, теперь ее определяем с вами, определяем.
[20:54.560 --> 21:02.160]  И здесь я обязан, конечно, писать имена, потому что я буду сейчас ссылаться на эти
[21:02.160 --> 21:13.560]  переменные, это локальные переменные внутри функции. Функции, очень сложный функционал,
[21:13.560 --> 21:23.840]  она складывает два числа и возвращает. И обращаю ваше внимание, что a и b в данном случае это
[21:23.840 --> 21:30.360]  переменные, которые объявляются внутри функции. Они рождаются в момент начала работы функции и
[21:30.360 --> 21:36.240]  уничтожаются вместе с функцией. Это локальные переменные для функции. Они тоже на стэке,
[21:36.240 --> 21:45.240]  как и все переменные временные, автоматически у нас хранятся на стэке, но a и b у нас в данном
[21:45.240 --> 21:56.520]  случае вот такие. Теперь давайте я напишу вам одну программку, у нас будет с вами еще один
[21:56.520 --> 22:05.200]  интерактив, но более сложный, где надо думать, а не только поднимать руку. Напишем с вами функцию.
[22:05.200 --> 22:20.280]  Функция f принимает одну переменную, это один int у нас, который ей передается. Внутри функции
[22:20.280 --> 22:28.960]  объявляется еще одна переменная типа int. Потом мы печатаем с вами
[22:28.960 --> 22:46.360]  nmp через пробел и переводим строку. Делаем while. На прошлой лекции мы уже посмотрели сложные вещи,
[22:46.360 --> 22:51.680]  как работает c++, поэтому while a-minus-minus сегодня уже не доставит вам никаких
[22:51.680 --> 22:57.440]  сложностей. Внутри while, чтобы нам было еще интереснее, объявим статическую переменную.
[22:57.440 --> 23:15.000]  Внутри while объявим статическую переменную. Теперь еще одна переменная int p равная нулю.
[23:15.000 --> 23:25.040]  И печат, и out, это для тех, кто еще не понял, как работает постфиксный инкремент, еще одна
[23:25.040 --> 23:43.960]  задача. Через пробел печатаем n, m++, еще один пробел, p++, я вот здесь сотру, чтобы мы не
[23:44.000 --> 23:58.920]  разрывали строчку и перевод строки. Итак, мы печатаем с вами n++, m++, p++ и перевод строки.
[23:58.920 --> 24:08.560]  Закрываем эту функцию f, закрываем while, закрываем функцию f. И давайте продолжение
[24:08.560 --> 24:19.760]  вот на этой доске напишем с вами. У нас будет функция main, в которой мы с вами делаем следующие
[24:19.760 --> 24:35.760]  вызовы f от 3, f от 2 и return 0. Ну, как обычно в таких случаях, наш вопрос, что будет на экране,
[24:35.880 --> 24:41.040]  если вы компилятор c++, вам дана программа, откомпилируйте, напишите в тетради, чтобы вы
[24:41.040 --> 24:46.320]  напечатали на экране, если вы были компилятором. Значит, что здесь в этой программе происходит?
[24:46.320 --> 24:53.880]  Смотрите, у нас сначала выполняет всегда функция main, поэтому когда вы какую-то программу
[24:53.880 --> 25:02.840]  исполняете, мысляйте как компилятор. Мы начинаем с main, и первое, что происходит, вызов функции с
[25:02.840 --> 25:16.640]  параметром 3. Вот функция, вместо a у нас подставляется 3. Давайте просто распишем себе, если мы были компилятором,
[25:16.640 --> 25:23.200]  как бы мы действовали. Какие у меня на данный момент вообще есть переменные? У меня уже есть
[25:23.200 --> 25:31.240]  одна переменная локальная, это a. Почему? Потому что я вам сказал, что когда мы передаем какой-то
[25:31.240 --> 25:38.000]  параметр по значению, как здесь, это фактически мы объявляем перемену a, как мы объявили missure
[25:38.000 --> 25:42.720]  локальную для функции, здесь в этой строчке объявляется переменная a, и в нее копируются
[25:42.720 --> 25:47.200]  значения, которые ее передали. Вот эта строчку копируется в a, но чтобы она скопировалась,
[25:47.200 --> 25:50.260]  конhésitez, чтобы перемену надо завести, поэтому у нас есть как минимум переменная a,
[25:50.260 --> 25:55.880]  в которой хранится сейчас 3. В следующей строчке у нас объявляется переменная m, в которой хранится
[25:55.880 --> 26:00.640]  граница ноль. В следующей строчке происходит очень
[26:00.640 --> 26:03.480]  важное, что не надо забывать, мы печатаем на экран nmp.
[26:03.480 --> 26:06.680]  И если вы напишите все это правильно, но не напишите
[26:06.680 --> 26:09.440]  nmp, формально вы не выполнили задачу, потому что там вопрос
[26:09.440 --> 26:14.440]  был, что будет на экране. nmp будет первой строчкой.
[26:14.440 --> 26:18.260]  После этого делаем некий while, while а-минус, постфиксный
[26:18.260 --> 26:25.120]  декремент а равно 3 сейчас. 3 это истина. Соответственно,
[26:25.120 --> 26:28.280]  после того, как мы войдем, мы сразу убавимся на 1,
[26:28.280 --> 26:32.680]  но после тока войдем. Ну, не совсем после тока войдем,
[26:32.680 --> 26:35.960]  после тока проверится это условие, скажем так. И
[26:35.960 --> 26:42.160]  внутри цикла мы с вами заводим переменную статическую,
[26:42.160 --> 26:45.600]  переменная n. Она обнуляется только один раз, первый
[26:45.600 --> 26:48.960]  раз, когда ее заводят. Она больше не будет обнуляться,
[26:48.960 --> 26:51.760]  иначе от нее было бы странное сохранение значения между
[26:51.760 --> 26:53.760]  функциями, если она все время обнуляется, когда натыкается
[26:53.760 --> 26:56.440]  на свое прошлое объявление. Поэтому она обнулилась
[26:56.440 --> 27:01.240]  вот здесь и все. Потом идет еще одна переменная p, и
[27:01.240 --> 27:05.920]  она обнуляется. И потом идет nmp. Вот у нас сейчас в данный
[27:05.920 --> 27:12.040]  момент 3 0. Эта первая строка была почти у всех правильна.
[27:12.040 --> 27:14.200]  Наверное, у всех даже была правильная из семи человек,
[27:14.200 --> 27:16.360]  что я смотрел. Дальше там появились у некоторых
[27:16.360 --> 27:19.680]  минусы. Минус 1 там где-то я видел, еще что-то, но вот
[27:19.680 --> 27:26.320]  nmp все сделали. На незачет вы все справились. Дальше
[27:26.320 --> 27:35.880]  у нас идет цикл while. У нас сейчас a равно 2, 2 это истина,
[27:35.880 --> 27:42.040]  значит входим внутри цикла. Убираем 1, фиксный декремент
[27:43.040 --> 27:51.880]  Н у нас уже повторно не обнулится. И после этого печати, что
[27:51.880 --> 27:56.360]  у нас сейчас хранится на nmp? Они все у нас на единичку
[27:56.360 --> 28:00.040]  прибавились, и N повторно не обнулится. А вот p у нас
[28:00.040 --> 28:02.040]  обнулится здесь снова, потому что это обычное
[28:02.040 --> 28:05.680]  объявление переменной. Мало того, p вообще заново у
[28:05.680 --> 28:10.320]  нас инициализируется. Почему? Ну потому что p где обновилось,
[28:10.440 --> 28:14.160]  внутри блока. Вот здесь оно прибавилось до единички,
[28:14.160 --> 28:21.000]  а здесь оно в это моменту, вот здесь уже p. Если бы
[28:21.000 --> 28:24.120]  за блок вышли, не было, но у нас она в цикле, но мы ее
[28:24.120 --> 28:29.600]  берем с вами и все равно обнуляем. Все. И вот у нас
[28:29.600 --> 28:34.560]  текущее состояние nmp стало 1, 1, 0. Почему у нас 1, 1, 0?
[28:34.560 --> 28:40.800]  Потому что у нас m и n не меняются, n настолько один раз
[28:40.800 --> 28:44.400]  инициализируется, а p меняется. И в следующую
[28:44.400 --> 28:50.760]  итерацию у нас будет следующее. Мы опять прибавим 2, 2, 1, p у нас
[28:50.760 --> 29:01.040]  снова будет 0 и будет 2, 2, 0. Все, цикл больше не
[29:01.040 --> 29:06.040]  выполняется, потому что у нас данный момент a уже стало 0, после этого мы пошли в последнюю
[29:06.040 --> 29:12.960]  итерацию цикла. И 0 это у нас ложь, поэтому мы выходим из этого цикла, как только мы выходим
[29:12.960 --> 29:19.080]  из этого цикла, мы выходим из функции, функция ничего не возвращает, и на этом мы закончили эту
[29:19.080 --> 29:26.840]  работу функции и снова в нее входим уже с параметром 2. Вот параметр 2 практически дублирует нам
[29:26.840 --> 29:33.800]  ситуацию, только у нас будет a равно 2, то есть мы два раза с вами будем повторять эту итерацию
[29:33.800 --> 29:43.720]  в данном случае. И mnp, вначале у нас, что вообще произошло с m? m у нас новый, потому что как
[29:43.720 --> 29:50.360]  только функция у нас закончил работу, m у нас с памяти удалился, то есть каждый блок
[29:50.360 --> 30:01.720]  для... каждый блок у нас для функции является окончание блока, фактически, скажем так,
[30:01.720 --> 30:11.640]  для переменной ее смертью, потому что конец блока, все, я больше здесь не нужен, и меня из
[30:11.640 --> 30:20.760]  памяти двигают. Именно поэтому у нас с вами m заново объявляется. Единственное, кто выжил в
[30:20.760 --> 30:27.960]  результате этой страшной игры, это у нас с вами n. Почему была она статической? Статические переменные
[30:27.960 --> 30:33.120]  между мыслями функций сохраняют свое значение, в этом их предназначение, статическая переменная.
[30:33.120 --> 30:38.960]  Вот это статик, это такая коварная вещь, мы уже рассматривали это на одной из первых лекций,
[30:38.960 --> 30:46.640]  но я хочу вам напомнить о том, что мы в любом случае инициализируемся один раз и между вызовем
[30:46.640 --> 30:58.400]  функции сохраним свое значение, поэтому n у нас, вот эта двойка, будет превращаться в тройку,
[30:58.400 --> 31:05.600]  а m и p снова станут нулями, потому что вот он ноль, вот он ноль, и это наша первая будет
[31:05.600 --> 31:14.000]  итерация. Вторая итерация, соответственно, у нас здесь будет четверка, m, которая объявлялась
[31:14.000 --> 31:21.920]  здесь, прибавится, станет один, а p у нас все время рождается заново, поэтому это ноль.
[31:21.920 --> 31:39.680]  p внутри блока, вот правильный был ответ, один человек написал, в основном проблемы,
[31:39.680 --> 31:44.960]  конечно же, были с статической функцией, но как здесь получился минус один у кого-то,
[31:44.960 --> 31:49.480]  я правда не понимаю, у нас же везде плюс-плюс, как можно было минус один, у нас может быть
[31:49.480 --> 31:54.880]  перепутали, а может быть перепутали, что это а, печатается, ну хорошо, может быть,
[31:54.880 --> 31:59.280]  ошибки, не важно как получены, главное, что это ошибки, главное делать их на контрольных,
[31:59.280 --> 32:04.080]  ничего страшного, кто сейчас ошибся, правда, я очень ценю тех, кто вообще старается и что-то
[32:04.080 --> 32:08.920]  делает и показывает, кто ничего не делает, спит или ничего не пишет, это вот намного хуже,
[32:08.920 --> 32:16.720]  чем пытаться понять. Так, у нас с вами пять минут перерыв и после перерыва продолжаем обмен
[32:16.720 --> 32:24.200]  информации. Так, я на перерыв прошу взять кого-нибудь вот этот супер инструмент и
[32:24.200 --> 32:30.800]  нормально помыть всю доску, ладно, чтобы у нас, так, обмен информации, значит,
[32:30.800 --> 32:34.920]  функция может общаться с внешним миром, есть для этого три способа, закройте дверь наверху,
[32:34.920 --> 32:41.760]  пожалуйста, тоже, закройте, да, не надо нам сквозняки устраивать, итак, эпидеологическая
[32:41.760 --> 32:50.120]  обстановка, мы еще сами себя тут будем, функция может обмениваться тремя способами, и самый
[32:50.120 --> 32:56.840]  первый из них, самый неправильный, но в то же время он есть, поэтому мы не можем его обходить,
[32:56.840 --> 33:09.000]  это через глобальные переменные, глобальные переменные, то есть в данном случае глобальных
[33:09.000 --> 33:14.400]  переменных, что значит обмен информации, если функция, это нигде черный ящик, который как-то
[33:14.400 --> 33:18.120]  функционирует, ему же надо как-то с внешним миром взаимодействовать, как минимум получать
[33:18.120 --> 33:22.160]  значение, отдавать значение, возможно какую-то дополнительную информацию получать, как этой
[33:22.160 --> 33:26.600]  функции взаимодействовать со всем внешним миром, вот способ номер один, глобальные переменные,
[33:26.600 --> 33:30.920]  то есть у вас есть некие переменные, которые хранятся у нас статической памяти, они являются
[33:30.920 --> 33:44.040]  глобальными, они объявлены до функ, закрой дверь пожалуйста, и они доступны везде,
[33:44.040 --> 33:57.400]  кроме чего скажите, вот вы да, всегда ли доступны глобальные переменные, вот у вас есть какая-то
[33:57.400 --> 34:04.920]  переменная а, и потом начинаются функции, вот эта переменная а, она во всех функциях видна или нет,
[34:04.920 --> 34:21.280]  во всех, все ли согласны, а если не статик, а нам придется поставить фигурные скобки,
[34:21.280 --> 34:25.040]  потому что как минимум у нас открывается фигурными скобками, поэтому как минимум
[34:25.240 --> 34:31.120]  фигурными скобки у нас всегда есть, то есть если она не перекрывается, правильный ответ, да,
[34:31.120 --> 34:37.520]  не надо мудрить, даже если она вне, если она просто в блоке самого мейна, то она все равно перекроет
[34:37.520 --> 34:44.400]  вот эту а, и в данном случае, когда с момента ее объявления, уже у нас она будет скрыта,
[34:44.400 --> 34:53.000]  этот локальный контекст скроет глобальный, и тем самым доступа к ней у нас не будет или будет,
[34:53.000 --> 35:02.240]  да, у нас есть операция доступ к области видимости, теперь вопрос, а хороший вообще этот метод,
[35:02.240 --> 35:10.080]  работать, получать, обмениваться, то есть вот если у нас одна функция есть, есть другая функция,
[35:10.080 --> 35:18.320]  не знаю, давайте назовем ее f2, она тоже у нас может получать а, вот эту, например, это через
[35:18.320 --> 35:26.480]  доступ, это просто если здесь нет ни киха, и в этом случае хороший этот метод, то есть мы можем здесь ее
[35:26.480 --> 35:31.600]  менять, здесь соответственно получать, когда нам надо, потому что мы поменяли ее после вызова этой
[35:31.600 --> 35:36.800]  функции, например, f2 из мейна, вот вам нравится такой метод обменной информации или он не очень
[35:36.800 --> 35:42.720]  хороший считается, ну кто-нибудь скажите, наверняка же вы читали про программирование,
[35:43.320 --> 35:53.760]  может в школе учились, в школе говорили, что это плохо, кто так сказал, ты из какой школы, из пятого
[35:53.760 --> 36:01.040]  лицея, через дорогу, но там просто это самая сила физтеха распространяется, вы говорили правильно,
[36:01.040 --> 36:06.800]  почему это плохо, как вы думаете, чем этот метод плох, на самом деле это не только в пятом лицее,
[36:06.800 --> 36:14.200]  я думаю, говорили, если вы слушали, везде, это плохо, потому что это очень опасный метод,
[36:14.200 --> 36:19.560]  глобальные переменные вообще надо не использовать, глобальные переменные это плохо, но почему,
[36:19.560 --> 36:25.960]  все говорят, что это плохо, но почему непонятно, потому что очень легко допустить ошибку, например,
[36:25.960 --> 36:33.680]  есть какая-то функция f3, которая вообще не знает о том, что f2 и мейна хорошая жизнь, они через
[36:33.680 --> 36:39.960]  а решают свои проблемы и как-то там работают, а это f3 вообще писал другой программист, случайно,
[36:39.960 --> 36:47.600]  может быть, не объявил или как-то там так сделал, что-то там задел эту а и все испортил, понимаете,
[36:47.600 --> 36:52.820]  то есть у вас никакой защиты нет от дурака, так называемой защиты, то есть он мог даже ее не
[36:52.820 --> 36:57.200]  объявлять, подумал, что он объявил, что это его локальные переменные, она, например, не объявилась
[36:57.200 --> 37:02.400]  или что-то еще произошло, он пропустил эту строчку и просто написал равно 5, и оно работает,
[37:02.400 --> 37:07.880]  потому что она же есть глобальная, и вы взяли и испортили вот этим товарищам передачу информации
[37:07.880 --> 37:13.440]  между собой, поэтому через глобальную переменную очень в этом плане и как раз того, что мы
[37:13.440 --> 37:18.600]  компсулируем плохой у нас метод, поэтому мы стараемся глобальные переменные никогда не использовать,
[37:18.600 --> 37:26.440]  но, конечно, такой способ возможен, если нам очень надо, тогда мы будем с вами это делать.
[37:26.440 --> 37:36.280]  Второе. Это через возвращаемое значение.
[37:36.280 --> 37:50.200]  Возвращаемое значение.
[37:50.200 --> 37:58.720]  Функция может возвращать значение, когда вообще функция у нас завершает свою работу,
[37:58.720 --> 38:02.600]  мы
[38:02.600 --> 38:15.400]  оператором return возвращаем какое-то значение, которое функция должна в соответствии с типом,
[38:15.400 --> 38:25.840]  который она возвращает, вернуть. Если у вас, например, функция должна вернуть int, называется f1,
[38:25.840 --> 38:39.240]  то правильно, например, написать return 1. Вы возвращаете значение равное единице в точку ее вызова.
[38:39.240 --> 38:45.280]  Вот если у вас функция ничего не возвращает, вы не можете вернуть единичку, потому что это
[38:45.280 --> 38:54.360]  будет неправильно, у вас несоответствие типов, то есть это нет, а если, например, у вас функция double,
[38:54.360 --> 39:08.000]  f2. Могу ли я здесь вернуть 1? Как вы думаете, вот такой синтез правильный, скомпилируется или нет?
[39:08.000 --> 39:14.760]  Да, почему? Приведение неявных типов правильно int приводится к double, у нас идет такое
[39:14.760 --> 39:20.880]  преобразование к double. А вот давайте посмотрим теперь вот на такой пример. Пусть у меня есть
[39:20.880 --> 39:26.800]  некая функция, которая возвращает указатель на int. Ведь мы же не обязательно должны
[39:26.800 --> 39:32.000]  int возвращать. Можем указатель int. Ничего не принимает, но возвращает указатель на int.
[39:32.000 --> 39:41.080]  Я внутри функции объявляю локальную переменную a, присваиваю ей начальное значение равное 5 и
[39:41.080 --> 39:51.600]  после этого возвращаю адрес. Да, вот это у нас, напоминаю, операция взятия адреса. Не путайте
[39:51.600 --> 39:55.840]  со ссылкой, в зависимости от контекста вы должны понимать звездочка и амперсант, что значит в
[39:55.840 --> 40:03.680]  каком контексте. Вы же думаете, как компилятор, а значит, у вас есть как минимум какая-то логика.
[40:03.680 --> 40:12.800]  И вот такой код, и завершаю на этом функцию. Вопрос, нравится ли вам это? Может быть,
[40:12.800 --> 40:18.680]  есть какие-то у кого-то сомнения? Поднимите руку, выскажитесь. Кто хочет сказать, только поднимите
[40:18.680 --> 40:25.000]  руку, у нас не хаос. Мы же ввели функции, поэтому они борются с хаосом в программах.
[40:25.000 --> 40:31.400]  Если никто не поднимет руку, я спрошу. Вот у вас желтая, самая яркая здесь кофта,
[40:31.440 --> 40:40.840]  поэтому вот вы ответьте. Да, ну опять я спрашиваю, вы не слушаете. Вот код, ничего ли вас здесь не
[40:40.840 --> 40:54.800]  смущает? Хорошо, вы уже сегодня много отвечали, вы тоже. Давайте мы разнообразие ведем, чтобы все
[40:54.800 --> 41:01.720]  поработали у нас. Вот вы на первой партии на этом ряду в белой кофточке, пожалуйста, да. Что вы
[41:01.720 --> 41:17.160]  думаете? Хорошо, да, пожалуйста. Как вас зовут? Иван, да, расскажите. И что происходит-то? Мы с вами
[41:17.160 --> 41:22.000]  создаем переменные в памяти и возвращаем адрес, совершенно верно, локальный переменный, который
[41:22.000 --> 41:27.040]  сейчас удалится. Так делать нельзя, потому что вы возвращаете адрес того, что сейчас будет
[41:27.040 --> 41:34.640]  уничтожено. И поэтому это код с потенциально огромным количеством проблем, правильно? Потому
[41:34.640 --> 41:39.440]  что он может привести к очень непредсказуемым последствиям, поэтому так нельзя возвращать
[41:39.440 --> 41:49.080]  указатель на локальную переменную. Ну и наконец, давайте рассмотрим третий, самый главный способ,
[41:49.080 --> 41:55.560]  как мы будем с вами передавать информацию через параметры функций. Третий напишем через
[41:55.560 --> 42:07.000]  параметры. И вот это то, на чем мы сейчас заострим свое внимание в этой части лекции,
[42:07.000 --> 42:26.600]  как функция общается с внешним миром через параметры. Пока я не перешел к следующей теме,
[42:26.600 --> 42:34.200]  я хотел вот здесь еще про ретурн кое-что сказать, пара комментариев. Скажите, а как вы думаете,
[42:34.200 --> 42:40.760]  рентурн должен находиться в самом конце последней строчкой при работе нашей функции? Или где-то,
[42:40.760 --> 42:46.440]  может, в середине тоже? Может. И что тогда произойдет, если в середине он находится? Дальнейшие
[42:46.440 --> 42:51.520]  строчки за ним выполнятся? Нет, то есть он выходит досрочно. Это считается плохой стиль,
[42:51.520 --> 42:57.480]  когда у каждой функции должно быть желательно одна точка входа, одна выхода. Не должно быть никаких
[42:57.480 --> 43:02.160]  потайных дверей, потому что это затрудняет прозрачность этой работы функции, когда вы
[43:02.160 --> 43:06.240]  анализируете, как она работает. Потому что вы когда смотрите, вы видите, что она возвращает,
[43:06.240 --> 43:10.840]  а если на самом деле в середине что-то может вернуть, вам надо весь текст просматривать. Поэтому
[43:10.840 --> 43:16.680]  считается, чтобы так называемого спагетти кода не было, у вас должна быть одна точка входа,
[43:16.680 --> 43:23.640]  одна выхода, а не какие-то там дырки такие, которые, я не знаю, какие-то животные делают в земле и
[43:23.640 --> 43:43.280]  ползают. Вы не знаете, откуда они выползают. Да, давайте еще сделаем вот это самое. Давайте.
[43:43.280 --> 43:51.960]  Бак на бак это фича, а не бак уже, я понимаю. Как бы делать-то мы можем, но по правильному стилю
[43:51.960 --> 43:57.120]  нет. Можно по-другому там, не знаю, ввести логическую переменную или поставить все то,
[43:57.120 --> 44:04.480]  что если это, там тогда и скобочку и все остальное у тебя выполняется, а иначе у тебя просто будет
[44:04.480 --> 44:09.360]  сразу ретурн вместе с ним. То есть можно так расположить, что он естественным образом пропустит
[44:09.360 --> 44:15.000]  все остальные строчки, и тебе не придется, например, в else поставить все остальные строчки
[44:15.000 --> 44:24.040]  внутрь else, весь тот блок, и тебе не придется, не придется, в общем, выходить досрочно. Просто
[44:24.040 --> 44:28.160]  надо, чтобы эти строчки не выполнялись естественным путем. Знаете, естественная смерть должна быть,
[44:28.160 --> 44:43.560]  недосрочная. Так, какой еще вопрос? Да. Не написать ничего. Да, потому что он будет
[44:43.560 --> 44:53.480]  у вас автоматически, у вас будет предупреждение, вы, наверное, видите, но у вас вы можете
[44:53.480 --> 44:59.880]  действительно так делать, но это считается плохой стиль, и вы должны обязательно следовать этому типу,
[44:59.880 --> 45:06.040]  который вам дан для того, чтобы не просто выходить, но возвращать еще значение без
[45:06.040 --> 45:10.480]  какого-то значения по умолчанию, что мейн немножко особенная функция, я расскажу,
[45:10.480 --> 45:16.640]  когда мы сейчас дойдем до нее, но мы стараемся следовать хорошему стилю, возвращаем всегда то,
[45:16.640 --> 45:27.960]  что нам хотят. Значит, теперь еще у меня вопрос, а как вы думаете, можно ли вообще не написать
[45:27.960 --> 45:36.720]  ретурн? Можно, она естественным образом закончится, опять же, это тоже самый вопрос,
[45:36.720 --> 45:41.200]  что у вас ничего не возвращается, то есть это фактически то же самое, что просто написать ретурн
[45:41.200 --> 45:46.720]  без параметров, нет последней строчки, но вот что в этом случае будет, мы сейчас рассмотрим,
[45:46.720 --> 45:55.680]  и параметры функции у нас бывают совершенно разные, и давайте рассмотрим это на примере,
[45:55.680 --> 46:02.000]  объявим функцию, которая в себе, я такой для вас пример написал, который содержит все виды,
[46:02.080 --> 46:11.600]  все три способа передачи параметров в функцию, так пусть у вас есть некая функция f,
[46:11.600 --> 46:17.960]  которая принимает три переменные, переменная i у нас будет приниматься по значению,
[46:17.960 --> 46:24.680]  это у нас будет по значению, подписываем себе, чтобы не путать какой есть способ,
[46:24.680 --> 46:37.600]  по значению, переменная g у нас будет по адресу, переменная g и звездочка g у нас с вами будет по адресу,
[46:37.600 --> 46:51.720]  мало того у нас еще будет с вами переменная k по ссылке,
[46:51.720 --> 47:08.840]  переменная k по ссылке, давайте здесь даже не будем ее определять, объявление просто закроем,
[47:08.840 --> 47:16.680]  и перейдем теперь к функции main, которая будет работать с нашей функцией, которую мы определим
[47:16.680 --> 47:21.440]  позже, то есть это просто объявление я написал, какие типы принимаемых значаемых,
[47:21.440 --> 47:31.800]  возвращаемых значений и порядок этих типов, так пусть в main у меня есть следующие переменные,
[47:31.800 --> 47:42.760]  тоже i, g и k, потом у меня с вами, пусть у меня в main будет три переменные,
[47:42.760 --> 48:02.880]  давайте напечатаем i, g и k, как мы вот уже с вами делали и напечатаем собственно i, g и k
[48:02.880 --> 48:18.320]  на экран, какое они сейчас имеют у нас значение, и пробельчик g, пробельчик k, перевод строки,
[48:18.320 --> 48:37.200]  так вот наши три переменные, теперь вызываем функцию f, первый параметр у нас передается по
[48:37.200 --> 48:46.280]  значению, второй как мы говорили по адресу, поэтому надо дать адрес, это операция взятия
[48:46.280 --> 48:53.600]  адреса, а третий по ссылке, ссылка является синонимом имени, просто даем то имя, синонимом
[48:53.600 --> 49:05.640]  которого она является, обращаю внимание, что вот это адрес, а вот это ссылка, еще несколько слов
[49:05.640 --> 49:13.560]  про терминологию, вот эти три параметра называются фактическими параметрами, давайте напишем все
[49:13.560 --> 49:25.680]  фактические, фактические параметры, а вот эти три параметра называются формальными параметрами,
[49:25.680 --> 49:43.120]  формальными, формальные фактически параметры не обязательно совпадают, например здесь у нас
[49:43.120 --> 49:48.280]  формальным параметром является переменная, типа int, а здесь может быть какая-то константа
[49:48.280 --> 49:54.320]  фактически, например пятерка, вот здесь уже константа не может быть, потому что это синоним
[49:54.320 --> 50:00.160]  имени ссылки, здесь должна быть переменная какая-то, здесь какой-то адрес, он может по разному
[50:00.160 --> 50:04.640]  быть также передан, поэтому формальный параметр, это то, что у нас стоит в заголовке, те типы,
[50:04.640 --> 50:09.640]  которые мы принимаем, а фактически то, что будет подставляться на место, это формальных параметров
[50:09.640 --> 50:16.280]  в данном конкретном вызове этой функции, фактически параметры меняются от вызова к вызову, теперь
[50:16.280 --> 50:27.080]  давайте main, мы все-таки будем с вами писать, красиво, return 0 сделаем, так здесь я не могу
[50:27.080 --> 50:32.200]  писать, да вы говорили здесь плохо видно, тогда наверное вот здесь, чтобы не стирать нашу часть
[50:32.800 --> 50:49.080]  теперь давайте реализуем с вами нашу функцию f, наша функция f, очень важный нюанс, вот здесь я
[50:49.080 --> 50:55.560]  написал i, j, k в реализации, когда я пишу определение, я могу написать совсем другие имена, вот те
[50:55.560 --> 51:01.240]  имена игнорируются, они могут не совпадать с этими, чтобы совсем вас не запутывать, я напишу пока
[51:01.240 --> 51:06.480]  такие же, но в принципе вы можете писать любые и браться будут в реализации именно эти, которые
[51:06.480 --> 51:16.000]  вы пишете в самом определении этой функции, но типы должны совпадать безусловно, иначе у вас будет
[51:16.000 --> 51:23.360]  ошибка, в объявлении определений типы должны совпадать все, что делает функция, она и увеличивает
[51:23.360 --> 51:42.360]  на единичку, j увеличивает на единичку, k увеличивает на единичку, давайте функцию закроем, и я наверное знаете,
[51:42.360 --> 51:50.400]  что еще сделаю, какой чит, простите, я вот эту строчку cout продублирую, она здесь тоже будет,
[51:50.400 --> 51:55.360]  вот перед ретурном, чтобы мы написали до вызовы и после, можно я не буду это писать на доске,
[51:55.360 --> 52:04.080]  но вы просто вставите себе еще раз печать вот этих i, j, k, то есть она у нас продублирована здесь,
[52:04.080 --> 52:09.800]  вот здесь cout и после f, такой же cout, i, j, k распечатывается, и сейчас давайте тогда разберемся,
[52:09.800 --> 52:23.360]  что это такое, это самое важное, понять как оно работает, для этого рассмотрим опять все то же
[52:23.360 --> 52:30.800]  самое, что мы делали, у нас есть три вида памяти, у нас есть глобальная память статическая, у нас
[52:30.800 --> 52:38.440]  есть стэк, есть динамическая, здесь все действие на самом деле происходит в стыке, потому что,
[52:38.440 --> 52:42.360]  если когда вы начинаете анализировать, как работает программа, всегда смотрите сначала,
[52:42.360 --> 52:52.600]  вот main это наше начало, первым делом заводится в стэке три переменные i, j и k, и присваиваются
[52:52.600 --> 53:00.080]  им начальные значения 1, 2 и 3, не бойтесь вначале рисовать, когда вы делаете указатель ссылки,
[53:00.080 --> 53:06.080]  это очень помогает пониманию, потом у вас cout и jk, но это как бы то, что напечаталось на экран,
[53:06.080 --> 53:13.880]  и jk, это первая часть ответа, это было у всех правильно, это мы уже поняли, потом идет печать
[53:13.880 --> 53:23.280]  и jk, ну 1, 2, 3, там тоже как бы сложно ошибиться, потому что их только что присвоили, и вы прям
[53:23.280 --> 53:32.080]  сразу их и вывели, а вот дальше идет вызов вот этой функции f, и здесь интересно, как вызывается
[53:32.100 --> 53:39.400]  функция f, смотрите, здесь функции вызов f по значению, это первый способ передачи параметра,
[53:39.400 --> 53:46.520]  что значит по значению? Значит, я копирую значение в новую переменную, вот i, которая здесь,
[53:46.520 --> 53:52.120]  и i, которая здесь, это разные переменные, вот это i находится в контексте этой функции,
[53:52.120 --> 53:58.840]  поэтому объявляется внутри этой функции это i, когда мы находимся в другой функции,
[53:58.840 --> 54:06.400]  мы ничего не знаем про переменные предыдущей функции. Вот это функция main, вот это функция f.
[54:06.400 --> 54:12.760]  Когда работает функция f, она не знает ничего про переменные main, потому что они равны
[54:12.760 --> 54:17.320]  эти функции. Это не глобальные для нее переменные, такие же локальные переменные другого черного
[54:17.320 --> 54:25.160]  ящика. Вот если вы внутри черного ящика, вы знаете либо что там внутри вашего ящика, либо глобальное,
[54:25.160 --> 54:31.160]  что вам сверху спустили там какие-нибудь, я не знаю, правила заповеди ваших всех черных ящиков,
[54:31.160 --> 54:36.720]  и вы глобальную переменную все знаете. Можете менять там и так далее. Ну поэтому плохо,
[54:36.720 --> 54:41.600]  кстати, вы менять, вы уже поняли. Но что в другом черном ящике, в соседней функции, вы не можете
[54:41.600 --> 54:44.960]  посмотреть, поэтому это такие же локальные переменные. Она может что-то передать, вот она вам
[54:44.960 --> 54:50.440]  передает. И первое, что она вам передает здесь, параметр, это по значению, мы просто копируем его,
[54:50.440 --> 54:55.280]  и здесь создается своя переменная и, которую я могу назвать по-другому, горшок, цветок,
[54:55.280 --> 55:05.560]  как угодно. Поэтому то, что она имеет одно и то же имя, ни на что у нас не влияет. Скорее только
[55:05.560 --> 55:17.280]  на ваше запутывание. Вот дальше идет, и если мы эту переменную меняем, то меняется вот эта
[55:17.280 --> 55:21.840]  переменная, к этой она уже никакого значения не имеет, она один раз скопировалась и все. Это передача
[55:21.840 --> 55:31.760]  по значению. Поэтому вот здесь, когда в функции произойдет работа этой строчки, мы и++ увеличим
[55:31.760 --> 55:38.440]  на один, но именно это и, которое находится внутри функции f. Как функция закончится, эта переменная и
[55:38.440 --> 55:44.440]  радостно исчезнет, потому что она живет только время работы функции. И на экран напечатается в
[55:44.440 --> 55:50.760]  следующей строчке, когда будет печатать снова и. Какое и? То, где оно печатается из main,
[55:50.760 --> 55:58.160]  единичка никак не поменяется. Поэтому первый ответ это 1. Это передача по значению. Это безопасная
[55:58.160 --> 56:04.840]  передача. Почему? Потому что ты можешь менять значение, пожалуйста, оно никак не испортится в
[56:04.840 --> 56:09.480]  основной программе, в другой функции, откуда тебя вызвали. То есть по значению сделать копию,
[56:09.480 --> 56:16.600]  я не знаю, как вот вы на своем айфоне или андроиде делаете копию фотки, чтобы там отредактировать,
[56:16.600 --> 56:22.000]  если не хотите потерять оригинал. То же самое. Мы здесь что-то там с этой переменной делаем,
[56:22.000 --> 56:28.720]  но оригинал остается. Это плюс, что он у нас сохраняется, минус это время. Время на копирование
[56:28.720 --> 56:34.640]  и на память. Смотря какой объект, но тем не менее, вы же его каким-то образом переносите,
[56:34.640 --> 56:39.480]  то есть вы его дублируете, и второе вы еще и память занимаете. Поэтому у вас в данном случае,
[56:39.480 --> 56:45.280]  простая переменная, может быть сложная у нас структура, поэтому разные могут быть совершенно
[56:45.280 --> 56:52.920]  у нас ситуации. В данном случае у нас, видите, эта переменная раздвоилась. А дальше второе g,
[56:52.920 --> 57:05.800]  g у нас с вами по адресу. Что такое адрес? Это значит, что g, вот это g, это вообще другое g,
[57:05.800 --> 57:14.640]  это просто int, который живет в мейне. А вот в функции f вторым параметром является int звездочка.
[57:14.640 --> 57:22.800]  Это int звездочка, который тоже назвали g для вашего запутывания. Могли назвать вот
[57:22.800 --> 57:27.440]  всем самым цветком или в чем он там стоит, и это было бы правильно, это совсем другое,
[57:27.440 --> 57:33.480]  другая переменная. Это другая переменная с другим типом, она живет в f, и какое ей
[57:33.480 --> 57:40.840]  дали начальное значение, то есть ее инициализирует фактическим параметром. Адрес какой-то переменной,
[57:40.840 --> 57:45.120]  какой должен быть адрес, который указывать на int, это указатель на int, нам должны были дать
[57:45.120 --> 57:51.840]  какой-то адрес int. Вот нам дали адрес вот этого g, и вот у нас получился указатель на это g. И
[57:51.840 --> 57:58.040]  теперь, когда мы работаем с этим g, мы его разыминовываем. Здесь, видите, вот это звездочка g,
[57:58.040 --> 58:05.560]  разыминование приводит нас вот сюда, и меняем уже на единичку вот это g из мейна, потому что мы
[58:05.560 --> 58:15.000]  работаем через указатель. И это способ, когда мы меняем что-то во внешнем мире, то есть когда нам
[58:15.000 --> 58:22.000]  дают параметры, а мы их еще меняем. Когда мы всовываем там вот руку в черный ящик, а высовываем,
[58:22.000 --> 58:35.520]  она там вся обожжена. Вот как в фильме «Дюна», который я недавно смотрел. Вот, и в этом случае
[58:35.520 --> 58:42.080]  мы меняем. А теперь давайте в программировании какой-нибудь пример, когда нам надо менять
[58:42.080 --> 58:46.920]  параметры, которые нам передают. Жизненный пример, дайте, когда нам надо менять параметры. Самая
[58:46.920 --> 58:53.360]  простой функция с двумя параметрами. Зачем им менять? Подожди, это какая-то странная функция. Я
[58:53.360 --> 58:59.160]  говорю, сложи мне 5 и 8. Она не только их складывает, но и 5 и 8 меняет. И говорит, на самом деле,
[58:59.160 --> 59:10.560]  у тебя было 3 и 4, и результат 7. Давайте другую функцию. Простую. ВАП совершенно верно. Меняете
[59:10.560 --> 59:14.680]  значение двух переменных. Вот в этом случае, когда вы свапаете две переменные, вам дают две
[59:14.680 --> 59:20.640]  переменные, и вам надо их изменить, потому что у вас суть функций в изменении значений, в отличие
[59:20.640 --> 59:31.400]  от суммы. Давайте. Это был единственный способ си, старом добром си, менять переменные, которые нам
[59:31.400 --> 59:36.880]  передают через указатели. И так всю жизнь они делали. И это громоздко. Почему? Здесь мы пишем адрес,
[59:36.880 --> 59:45.320]  здесь нам все время надо разыменовывать. Поэтому в C++, когда он появился, как мы знаем благодаря
[59:45.320 --> 59:53.400]  Strauss-труппу, и потом уже был стандартизован, появились ссылки. Как раз ссылки появились для того,
[59:53.400 --> 59:59.360]  чтобы упростить изменение параметров функции, но без этого все время громоздкого синтакса
[59:59.360 --> 01:00:11.880]  указателей. Потому что здесь теперь к у меня ссылка. Вот это к ссылка. И я передаю ей синоним
[01:00:11.880 --> 01:00:20.120]  имени. То есть, на самом деле, как в матрице, доложки не существуют. Этого к здесь не существует
[01:00:20.120 --> 01:00:26.760]  второго. Никакая копия не делается. Мы просто с вами работаем вот с этой переменной всегда. И когда
[01:00:26.760 --> 01:00:31.840]  я буду обращаться в функции в K, то будет идти обращение непосредственно вот сюда,
[01:00:31.840 --> 01:00:44.800]  потому что это ссылка. И здесь я экономлю и на синтаксисе, и на простоте, и не делаю лишние
[01:00:44.800 --> 01:00:55.520]  переменные благодаря этому. И K++ изменяет вот эту переменную. И вот наш ответ 1, 3, 4. Несколько
[01:00:55.520 --> 01:01:01.160]  человек его получили. Не большинство, к сожалению, но это говорит о том, что, по крайней мере,
[01:01:01.160 --> 01:01:10.880]  вы не зря ходите на лекцию. И вот такая у нас картина. Теперь понятно, почему ссылка. Обратите
[01:01:10.880 --> 01:01:16.940]  внимание, когда вы смотрите на вызов функции, вы не можете понять. Вот между И и К, здесь никакой
[01:01:16.940 --> 01:01:23.600]  разницы. Когда вы смотрите только на вызов, вы не знаете, изменится ваша переменная или нет. То
[01:01:23.600 --> 01:01:32.360]  есть вы можете посмотреть только вот сюда, если здесь по значению, если здесь по ссылке. Потому
[01:01:32.360 --> 01:01:38.600]  что если по значению, она точно не изменится. Это безопасно. Если по ссылке, ее могут поменять.
[01:01:38.600 --> 01:01:44.360]  Это уже опасно. Как нам сделать, чтобы передавать по ссылке, но ее не могли менять так же,
[01:01:44.360 --> 01:01:55.000]  как по значению. Ну это можно сделать. То есть можно было ее отдублировать и уже свой дубликат
[01:01:55.000 --> 01:02:03.240]  передавать. Если его испортят, но это был дубликат. Но это, опять же, не совсем эффективно. Зачем нам
[01:02:03.240 --> 01:02:09.160]  большие могут быть разные объекты дублировать? Это и память занимает, и время на копирование.
[01:02:09.160 --> 01:02:15.920]  Если мы копируем какой-нибудь массив, это от Н до К. Совершенно верно. Делать ссылку
[01:02:15.920 --> 01:02:26.120]  константной. Это что значит? Это значит, что мы можем с вами совместить удобство двух этих
[01:02:26.120 --> 01:02:34.600]  методов. А именно, не надо дописывать, пожалуйста, потому что у вас иначе программа не будет
[01:02:34.600 --> 01:02:41.880]  работать. И вы мне скажете, что она не компилируется. Это просто конст не даст нам вот здесь вот этой
[01:02:41.880 --> 01:02:51.640]  строчки поменять. Но если у нас такая ситуация, что я хочу передать по ссылке и при этом не
[01:02:51.640 --> 01:02:58.800]  запретив возможность менять свою переменную, я делаю константную ссылку. И последнее, что я хотел
[01:02:58.800 --> 01:03:03.760]  на этой лице вас спросить, а для чего нужны константные ссылки? Если у них хоть какие-нибудь
[01:03:03.920 --> 01:03:14.200]  преимущества перед передачей параметров по значению? То есть, смотрите, значение нужно, чтобы вы точно
[01:03:14.200 --> 01:03:19.800]  не меняли объект, вы делаете его копию, с ним работаете. Константная ссылка тоже самая. Она
[01:03:19.800 --> 01:03:24.800]  хочет, чтобы вы не меняли объект, поэтому вам этот объект передают, чтобы вы его не могли изменить.
[01:03:24.800 --> 01:03:30.960]  Но у этого метода, возможно, есть какое-то преимущество перед классическим методом 72 года. Да.
[01:03:30.960 --> 01:03:43.720]  Подождите, у вас в этом и суть, что вы не меняете элементы. Но что лучше-то? Да, пожалуйста.
[01:03:43.720 --> 01:03:52.040]  Мы не копируем элементы, мы работаем с тем же самым элементом, просто заключив его в капсулу,
[01:03:52.040 --> 01:03:57.560]  что его нельзя менять. Мы не просто даем дубликат, говорим, делайте с ним что хотите, а мы даем то
[01:03:57.640 --> 01:04:01.240]  же самое область памяти, где лежит исходный объект, но просто запрещаем его менять. Этим
[01:04:01.240 --> 01:04:10.440]  константная ссылка нам более эффективна. Да. Конечно, в этом и есть разница. Вот ответ на
[01:04:10.440 --> 01:04:16.440]  этот вопрос, что мы не тратим время и память на копирование элемента. Но это способ только был
[01:04:16.440 --> 01:04:25.640]  C++, C его не было. Я, честно скажу, я как бы не считаю, что и C там не надо изучать. Это вот такие
[01:04:25.640 --> 01:04:30.840]  религиозные споры, лучше C или C++. Я считаю, что надо все знать. Но было бы странно, если бы я вам
[01:04:30.840 --> 01:04:35.760]  рассказал только указатели и не сказал, что дальше как бы происходило с человечеством. Но у нас еще
[01:04:35.760 --> 01:04:40.480]  будут последние лекции, где мы с вами еще затронем и умные указатели, то есть развитие языка не
[01:04:40.480 --> 01:04:46.760]  останавливается, поэтому постепенно мы с вами все методы изучим. Но в данном случае ссылка,
[01:04:46.760 --> 01:04:53.280]  конечно же, облегчила жизнь. И вы можете передавать по ссылке, вы можете передавать по адресу и по
[01:04:53.280 --> 01:05:00.160]  значению. Мы будем все способы зависимости от задачи использовать, но вам надо будет уметь
[01:05:00.160 --> 01:05:09.480]  работать совсем. И, например, когда вы будете писать декартовые деревья, вы прочувствуете указатели,
[01:05:09.480 --> 01:05:15.440]  у нас будут многие задачи на указатели, связанные со структурами данных, например, списки. Поэтому вы
[01:05:15.440 --> 01:05:21.280]  попробуйте все способы своей жизни. Все, мы делаем с вами большой прерыв теперь между лекциями.
[01:05:21.440 --> 01:05:28.160]  Насколько по расписанию должен быть прерыв? Десять минут и возвращаемся сюда. Лекция номер
[01:05:28.160 --> 01:05:40.880]  девять. Значит, давайте краткое содержание предыдущих серий. Такой у нас будет рекэпда.
[01:05:40.880 --> 01:05:48.360]  Мы с вами изучали функции. И главное, что мы говорили, что функции необходимы для инкапсуляции и
[01:05:48.360 --> 01:05:58.040]  структурирования нашей программы на какие-то отдельные блоки, которые друг другом непосредственно
[01:05:58.040 --> 01:06:04.440]  не связаны, а общаются с внешним миром тремя способами и между собой. Это глобальные перемены,
[01:06:04.440 --> 01:06:10.440]  не очень хороший способ. Через возвращаемые значения ретурн. При этом мы сказали с вами о том,
[01:06:10.440 --> 01:06:20.520]  что у нас по-хорошему должна быть всегда одна точка входа и одна точка выхода, чтобы функцию
[01:06:20.520 --> 01:06:25.800]  можно было легко анализировать. И поэтому нежелательно выходить из функции досрочно.
[01:06:25.800 --> 01:06:31.520]  Если вам надо выйти досрочно, то можно написать так свои условия, чтобы какие-то строчки не
[01:06:31.520 --> 01:06:35.480]  выполнялись. Молодой человек, закройте там окно, пожалуйста. Я не хочу сам уйти на карантин
[01:06:35.480 --> 01:06:53.480]  досрочно. Еще важно, что функция должна возвращать значение. Значение должно быть такое же,
[01:06:53.480 --> 01:06:59.480]  как в заголовке. То есть то значение, которое должно возвращаться, должно быть в соответствии
[01:06:59.480 --> 01:07:04.600]  типов, либо неявное преобразование. Возможно, как в нашем применении Sintu Wind Double.
[01:07:04.600 --> 01:07:13.760]  Если значение не совпадает по типу, то это будет ошибка. Если ничего не возвращается, вот у нас
[01:07:13.760 --> 01:07:19.480]  был, кстати, интересный вопрос. Давайте на него кого-нибудь спросим, а я скажу прежде чем правильный
[01:07:19.480 --> 01:07:25.240]  ответ. Если ничего из функции не возвращается, вот у вас просто есть функция, я вообще не написал
[01:07:25.240 --> 01:07:32.160]  ретурн. И, кстати говоря, это тоже так на экзаменах могут спрашивать. И вот вам вот конкретно иногда
[01:07:32.160 --> 01:07:37.560]  даже специально дают меньше входных данных. И задают такой вопрос, посмотреть, как вы мыслите,
[01:07:37.560 --> 01:07:45.000]  сдадите ли вы уточняющие вопросы или сразу дадите ответ. Вот вы, молодой человек в белой кофточке,
[01:07:45.000 --> 01:07:52.880]  да. Вот вы не оборачивайтесь, это вы. Как вас зовут? Миша. Нет, Максим, нет. У вас белая кофточка
[01:07:52.880 --> 01:08:00.240]  далеко, вот у него поближе. Вы на одной линии, но почти. Михаил, скажите, так можно из функции
[01:08:00.240 --> 01:08:12.560]  не делать вообще ретурн, нигде его не написать? Ну, это вопрос некорректно поставленный. Надо
[01:08:12.560 --> 01:08:18.600]  сейчас кучу всего переспросить. Во-первых, смотреть, с какой функции. Что значит,
[01:08:18.600 --> 01:08:24.400]  из какой функции? На что нам надо посмотреть? На тип возвращаемого значения, да. Если это void,
[01:08:24.400 --> 01:08:32.600]  окей. Теперь, ну, если она ничего не возвращает. Но это не полный ответ. Какой у нас еще есть особая
[01:08:32.600 --> 01:08:38.560]  функция? Вы еще спрашивали про нее, а почему вот в этой функции можно? В стандарте C++ 2009
[01:08:38.560 --> 01:08:43.960]  написано, что если из Main ничего не возвращать, то вернется ноль по умолчанию. Но это только в
[01:08:43.960 --> 01:08:50.080]  Main. И это считается плохой стиль, поэтому лучше мы будем с вами писать и не делать этого. Хотя
[01:08:50.080 --> 01:08:55.800]  из других функций, конечно, этого делать нельзя. Возвращаемое значение, способ обмена. И, наконец,
[01:08:55.800 --> 01:09:03.920]  третий самый главный способ обмена. Это через передачу параметров. И там у нас было три вида
[01:09:03.920 --> 01:09:11.600]  параметров. По значению, по адресу и по ссылке. И мы говорили, что по значению это копирование
[01:09:11.600 --> 01:09:16.680]  объекта. И с этим объектом можно делать все, что хочешь. Он никак не связан с исходным объектом,
[01:09:16.760 --> 01:09:25.280]  когда мы его передавали. Исходный объект не меняется, при этом вы не можете с помощью этого вернуть
[01:09:25.280 --> 01:09:30.360]  какую-то информацию. Вы можете только получить такой досторонний канал связи. По адресу вы можете
[01:09:30.360 --> 01:09:36.520]  и получить, и вернуть, потому что вы его получаете через адрес, через указатель, и меняете,
[01:09:36.520 --> 01:09:42.840]  соответственно, через этот же указатель. Тем самым, с места вызова вашей функции у вас изменение
[01:09:42.840 --> 01:09:47.800]  объекта происходит. Например, если у вас функция меняет значение двух переменных. И, наконец, третье по
[01:09:47.800 --> 01:09:53.000]  ссылке. Когда мы говорим, что это практически предыдущий способ с улучшенным синтаксисом и
[01:09:53.000 --> 01:10:00.160]  с экономией памяти. И после этого мы с вами рассмотрели константные ссылки, которые на самом
[01:10:00.160 --> 01:10:08.720]  деле очень важны в том плане, что если мы не хотим менять объект, но хотим иметь преимущество ссылок,
[01:10:08.720 --> 01:10:14.320]  не расходовать лишнюю память, не делая копии объекта, есть так называемые константные ссылки.
[01:10:14.320 --> 01:10:19.200]  Вот метод передачи по константным ссылкам у вас будет очень частый в объектно-алитированном
[01:10:19.200 --> 01:10:25.200]  программировании. Вы прям будете видеть его сплошь и рядом. Вот это конст какой-то тип, там, амперсант,
[01:10:25.200 --> 01:10:31.600]  это будет то, что вы будете писать так часто, как даже сейчас все не представляете. Поэтому эти
[01:10:31.600 --> 01:10:37.520]  методы, разумеется, будут очень часто вами использоваться. А сейчас давайте рассмотрим маленькую,
[01:10:37.520 --> 01:10:40.960]  следующую подтему, связанная с функцией передача массива в качестве параметров.
[01:10:40.960 --> 01:11:00.280]  Передача массива в качестве параметра. Передача массива в качестве параметра.
[01:11:00.280 --> 01:11:10.180]  Массив всегда передается по адресу, передается указатель на его первый элемент. Другого способа
[01:11:10.180 --> 01:11:17.620]  передать массив C++ нет, поэтому если я хочу передать массив, я должен дополнительно к
[01:11:17.620 --> 01:11:22.220]  этому массиву передать информацию о количестве элементов этой массивы, потому что просто адрес
[01:11:22.220 --> 01:11:26.260]  на первый элемент массива мне не даст полную информацию о самом массиве. Мы сейчас говорим
[01:11:26.260 --> 01:11:29.780]  только о классических массивах, мы говорим про векторы, другие остейлевские контейнеры,
[01:11:29.780 --> 01:11:38.060]  это все у нас будет позже, сейчас мы говорим именно о массиве. Пусть у меня есть некая функция
[01:11:38.060 --> 01:11:50.820]  сумма, которая находит сумму элементов массива. Если я хочу получить массив, я с вами завожу
[01:11:50.820 --> 01:11:56.980]  указатель на int, это будет указатель на первый элемент массива. И дополнительная информация,
[01:11:56.980 --> 01:12:07.500]  которая мне нужна, это количество элементов в данном массиве. Это функция ищет сумму, она обнуляет
[01:12:07.500 --> 01:12:17.700]  счетчик, проходит по всему массиву. Мы передали информацию, что в массиве n элементов, поэтому
[01:12:17.700 --> 01:12:29.020]  это n мы можем вот здесь использовать и, складывая все элементы, находим сумму с помощью сокращенного
[01:12:29.020 --> 01:12:43.020]  оператора пресваивания, операции пресваивания. Возвращаем с вами обязательно результат, если не
[01:12:43.020 --> 01:13:00.780]  вернем, у нас будет ошибка, это не функция main. Вернули результат, теперь как работать с данной
[01:13:00.780 --> 01:13:14.780]  функцией. Нам нужна, например, функция main. В этом main мы можем завести какой-то массив
[01:13:14.780 --> 01:13:34.380]  из пяти элементов. Присвоить ему начальное извачение и вывести сумму этого массива,
[01:13:34.380 --> 01:13:47.420]  вызвав функцию сумма с двумя параметрами. Адрес имя массива мы даем, который является, как вы
[01:13:47.420 --> 01:13:53.260]  помните, адресом первого элемента этого массива, нулевого, мы говорим первого, понятно, что нулевого,
[01:13:53.260 --> 01:13:59.420]  то есть начало этого массива в памяти. И количество элементов в нем, это у нас параметр по значению,
[01:13:59.420 --> 01:14:05.220]  здесь может быть константа, может быть выражение, в отличие от других способов, когда мы с вами на
[01:14:05.220 --> 01:14:09.340]  припасылке, здесь не может быть константа или выражения, поэтому можно придать константу 5,
[01:14:09.340 --> 01:14:12.940]  хотя стиль программирования, конечно, плохой, магические числа, мы говорили, так не делать,
[01:14:12.940 --> 01:14:19.660]  надо бы сделать было константу, но именно такой учебный скорее пример, и тем самым мы печатаем
[01:14:19.660 --> 01:14:32.260]  сумму на экран. Ретурноль напишу, буду занудным, но хороший стиль. Вот у нас с вами есть такая
[01:14:32.260 --> 01:14:43.900]  способ, могли бы здесь написать еще по-другому, просто другой синтаксис, показав, что это именно
[01:14:44.140 --> 01:14:51.700]  будет передаваться массив, это тоже указатель для компилятора, не будет иметь никакой разницы,
[01:14:51.700 --> 01:15:00.900]  такой способ и другой способ. Теперь давайте более, еще один сложный, рассмотрим вопрос,
[01:15:00.900 --> 01:15:09.140]  ну не сложный, у нас пока все просто, это передача имен функций в качестве параметров,
[01:15:09.140 --> 01:15:18.540]  передача имен функций в качестве параметров, давайте здесь его сделаем, передача имен функций,
[01:15:18.540 --> 01:15:28.260]  давайте просто даже передача функций, напишем грамм, функций в качестве параметров.
[01:15:28.260 --> 01:15:43.300]  Пусть у меня есть некая функция, которая ничего не возвращает,
[01:15:43.300 --> 01:15:54.660]  функция f, которая принимает один параметр int, я ее сразу же определю эту функцию, в ней будет
[01:15:54.660 --> 01:16:03.260]  ровно 0 строчек внутри. Теперь сделаем указатель на функцию, помните у нас была проблема курицы
[01:16:03.260 --> 01:16:07.900]  и яйца, когда мы изучали указатели, нам надо было пройти указатели на функции, а функции мы еще не
[01:16:07.900 --> 01:16:12.300]  знали, ну вот сейчас мы может быть немножечко, если кто-то тогда не понял, будет понятнее,
[01:16:12.300 --> 01:16:20.860]  что такое указатель на функцию. Мы по правилу, когда такие сложные конструкции видим, всегда с вами
[01:16:21.180 --> 01:16:27.060]  действуем по следующему правилу, мы уже подобный пример с вами рассматривали, мы находим сначала
[01:16:27.060 --> 01:16:33.180]  переменную, вот она переменная, это точно не ключевое слово, int это ключевое слово, void ключевое
[01:16:33.180 --> 01:16:37.980]  слово, переменная не может быть ключевым словом, поэтому легко понять, что переменная, то что не
[01:16:37.980 --> 01:16:48.260]  ключевое слово, это переменная. Теперь действуем по правилу, что это такое указатель, доходим до
[01:16:48.260 --> 01:16:52.100]  первой скобки видим, что здесь ничего нет, значит, доходим до этой по правилу
[01:16:52.100 --> 01:16:57.180]  право-лево. Это указатель на что? Дальше идем направо на функцию, которая
[01:16:57.180 --> 01:17:02.300]  возвращает, принимает int и возвращает void. То есть pf это указатель на
[01:17:02.300 --> 01:17:09.740]  функцию, которая принимает int, возвращает void. Вот такая, например.
[01:17:09.740 --> 01:17:13.840]  Это одна из таких функций, которую я могу написать, которая принимает int,
[01:17:13.840 --> 01:17:19.400]  возвращает f, то есть pf может быть указателем на f. Ну давайте я ее
[01:17:19.400 --> 01:17:28.480]  собственно и присвою ей f. Я не одну функцию присвоил другой, а это на самом
[01:17:28.480 --> 01:17:33.420]  деле самый простой синтаксис. Можно было бы написать вот так с точки зрения
[01:17:33.420 --> 01:17:39.240]  языка, это одно и то же адрес начала функции в памяти. То есть я могу как бы
[01:17:39.240 --> 01:17:44.900]  написать операцию взятия адреса, а могу написать просто как и с массивом то
[01:17:44.900 --> 01:17:50.860]  же самое. Связь функции указателей тоже все плюс-плюс очень простая. Имя функции
[01:17:50.860 --> 01:17:58.340]  это адрес этой функции, и мы просто в этот адрес присвоили этот адрес. И
[01:17:58.340 --> 01:18:03.500]  теперь самое интересное, для чего этот указатель нужен. Я могу эту функцию
[01:18:03.500 --> 01:18:07.700]  вызывать не через ее имя, а через указатель. То есть у меня есть некая
[01:18:07.700 --> 01:18:15.080]  функция f, здесь какие-то строчки кода. Я завел указатель на функцию, которая
[01:18:15.080 --> 01:18:20.440]  указывает на начало этой функции. И теперь если я вызову pf, то вызовет cf.
[01:18:20.440 --> 01:18:24.360]  С теми же самыми должен быть параметром, разумеется, потому что указатель у нас
[01:18:24.360 --> 01:18:27.960]  типизированный, он указывает не на все функции, а только на конкретную, которая
[01:18:27.960 --> 01:18:31.640]  принимает int и которая возвращает void. Иначе как компилятору проверять
[01:18:31.640 --> 01:18:35.960]  правильность, когда он будет компилировать всех параметров.
[01:18:35.960 --> 01:18:42.140]  Зачем надо? Я услышал вопрос, я расскажу. Это не бред, это нужно. Не думайте, что люди
[01:18:42.140 --> 01:18:50.380]  делали это, чтобы усложнить вам жизнь только на колоквами. Нет. Например, я
[01:18:50.380 --> 01:18:55.940]  могу вызвать функцию f на самом деле через указатель, можно было вызвать по
[01:18:55.940 --> 01:19:02.420]  другому. Можно было бы разыменовать указатель, да, вот так бы дойти до
[01:19:02.420 --> 01:19:07.960]  значения этой функции и дать значение. Но так не пишут, поскольку первый
[01:19:07.960 --> 01:19:14.760]  синтаксис проще. Но он корректен, и первый, и второй синтаксис. Но давайте в
[01:19:14.760 --> 01:19:22.480]  качестве ответа на то, зачем это надо, я приведу вам пример. Давайте вот на этой
[01:19:22.480 --> 01:19:32.160]  доске объявим тип. Итак, type-def сдаёт некий пользовательский тип. Пусть у меня
[01:19:32.160 --> 01:19:45.280]  тип-f это указатель на функцию, которая принимает int, возвращает void. pf это имя
[01:19:45.280 --> 01:19:56.740]  нового типа. Теперь я могу использовать просто как тип. Давайте я создам функцию f1.
[01:19:56.740 --> 01:20:07.980]  Давайте сейчас чуть легче напишем, чтобы вас сразу не путать. Простите,
[01:20:07.980 --> 01:20:13.860]  это я сотру, это будет следующим нашим усложнением. Сейчас придумаю простой пример.
[01:20:13.860 --> 01:20:25.860]  Пусть у меня будет массив. Называться меню. Некий массив, тип которого pf, а pf мы
[01:20:25.860 --> 01:20:30.260]  только что создали. Что это такое? Это указатель на функцию, принимающую int,
[01:20:30.260 --> 01:20:36.100]  возвращающую void. Массив таких указателей на функцию. Здесь нет количества элементов,
[01:20:36.100 --> 01:20:45.300]  потому что мы сейчас явно пронициализируем какими-то функциями. С именами new, open, save.
[01:20:45.300 --> 01:20:51.340]  Мы с вами конструируем меню в какой-то программе. И в этом меню будут у нас действия. Нажал
[01:20:51.340 --> 01:20:55.940]  пользователь new, новое окошечко в варде, нажал open, открывается файл, нажал save,
[01:20:55.940 --> 01:20:59.540]  сохранился файл. У нас есть такие три функции, которые делают этот функционал.
[01:20:59.540 --> 01:21:07.660]  Адреса этих трех функций мы записали в массив указателей. Теперь, если я хочу вызвать какую-то
[01:21:07.660 --> 01:21:17.420]  функцию в зависимости от сценария пользователя, я могу вызывать ее не зная имени. И это самое
[01:21:17.460 --> 01:21:24.300]  главное для чего это делается. Я могу вызвать, например, первую функцию из них. Open с параметром 10.
[01:21:24.300 --> 01:21:33.220]  Теперь у меня легко логику не привязывать к именам. Я могу программировать абстрагируешься от имен,
[01:21:33.220 --> 01:21:38.220]  заменив имена номерами. И это очень удобно, потому что я могу это делать в цикле. Я не
[01:21:38.220 --> 01:21:46.620]  могу new, open, save писать в цикле какие-то слова, правда? А номера могу вызвать все эти элементы.
[01:21:46.780 --> 01:21:53.180]  Именно поэтому я могу от имен перейти, например, к номерам. Поэтому нам полезны указатели. Это
[01:21:53.180 --> 01:22:01.020]  один из примеров, когда это можно сделать. Ну и давайте сейчас, как обычно, в конце какой-нибудь
[01:22:01.020 --> 01:22:13.500]  под темой у нас, как всегда, пример чуть сложнее. Опять объявим некий тип type-def,
[01:22:13.500 --> 01:22:32.140]  где у нас pf, это указатель на функцию, которая принимает int, возвращает void. Сделаем теперь
[01:22:32.140 --> 01:22:48.300]  функцию f1, которая принимает переменную pf типа pf. pf маленькое имя переменной, pf большое имя типа,
[01:22:48.300 --> 01:22:54.820]  которое мы сами сконструировали. pf это указатель на функцию, принимающую int, возвращающую void.
[01:22:54.820 --> 01:23:02.860]  И эта функция будет через свой указатель pf, через эту локальную переменную вызывать
[01:23:02.860 --> 01:23:09.340]  что-то там с параметром 5. Поскольку функция возвращает void, это ничему не присваивается,
[01:23:09.340 --> 01:23:19.100]  и возврат идет при корректный вызов, поскольку 5 это как раз int. С типами все хорошо. Теперь давайте
[01:23:19.100 --> 01:23:45.260]  void f int cout i. В данной функции f мы просто выводим на экран то, что нам передали. Теперь делаем main,
[01:23:45.260 --> 01:24:00.020]  и вызываем функцию f1 с параметром f. Мы должны передать в качестве параметра указатель на
[01:24:00.020 --> 01:24:06.820]  функцию, которая принимает int, возвращает void. Вот мы даем такой указатель по вот этому способу,
[01:24:06.820 --> 01:24:17.180]  что у нас имя функции является одновременным адресом начала функции, и подставляем функцию f.
[01:24:17.180 --> 01:24:26.980]  Таким образом, f будет указывать в данном вызове на функцию f. Мы можем в другом вызове, понятно,
[01:24:26.980 --> 01:24:40.540]  по-другому. И как будет работать это следующая строчка в f1, когда мы вошли внутрь, это вызов
[01:24:40.540 --> 01:24:46.060]  функции через указатель pf. В данном случае нам он указывает на f, поэтому f вызовет с параметром 5,
[01:24:46.060 --> 01:24:59.820]  и на экране будет 5. Вот такой сложный способ получить пятерку. Какой еще раз вопрос? Объявляет
[01:24:59.820 --> 01:25:06.060]  новый тип для того, чтобы вы просто в синтаксе, если каждый раз не писали эту мантру, то вот как
[01:25:06.060 --> 01:25:13.220]  здесь я объявляю, чтобы f не объявить, надо написать все время вот этот тип, а мне он здесь нужен
[01:25:13.220 --> 01:25:26.620]  как минимум вот здесь, и я просто упрощаю себе синтакс и считаемость кода. И мне понятно,
[01:25:26.620 --> 01:25:36.260]  что это, и легко читать заголовок функции, то есть pf это новый тип данных, то есть я могу делать так
[01:25:36.260 --> 01:25:41.980]  называемые пользовательские типы данных. Например, я вот обозначил за какой-то тип,
[01:25:41.980 --> 01:25:50.860]  назвал там pf, мог назвать его Вася, и будет тип Вася у вас. Вы можете свои типы делать из
[01:25:50.860 --> 01:25:58.500]  существующих и называть их как-то по-своему, чтобы вам было легко читать этот код. Так,
[01:25:58.500 --> 01:26:10.300]  давайте следующий маленький подпункт. Возвращаемое значение по ссылке. Это очень
[01:26:10.300 --> 01:26:23.820]  интересный пример, который я вам хочу рассказать. У нас было однажды контрольное, я вам рассказывал,
[01:26:23.820 --> 01:26:31.580]  что уже много лет я преподаю на фистехе, и наш поток, собственно, я и создал, и в одной из первых
[01:26:31.580 --> 01:26:36.180]  лет у нас была такая контрольная, где был такой вопрос, который очень понравился студентам,
[01:26:36.180 --> 01:26:44.340]  они очень хихикали. А именно, в каком необычном месте может стоять вызов, может стоять функция?
[01:26:44.340 --> 01:26:49.300]  И все догадались, что это за необычное место, какой-то странный вопрос. Вот это
[01:26:49.300 --> 01:26:56.460]  как раз то самое необычное место, может, мы это плохо сформулировали. Где может
[01:26:56.460 --> 01:27:06.020]  использоваться функция? Так, внимание на экран. Что же такое? Итак, пусть у меня есть глобальная
[01:27:06.020 --> 01:27:13.060]  переменная X, я пропускаю подключение библиотека, обращаю ваше внимание, подключение пространств
[01:27:13.060 --> 01:27:18.740]  имен, потому что мы с вами пишем только мясо, суть. Но мясо программы, это самое главное,
[01:27:18.740 --> 01:27:28.540]  как у вас главное мясо, зачем нам жир-то? Вот эти include, это все так, это не суть. И еще давайте
[01:27:28.540 --> 01:27:40.460]  сделаем такое определение, пусть у меня будет функция setX, не принимать параметров,
[01:27:40.460 --> 01:27:52.580]  а возвращать ссылку на int. Так тоже можно. Мы возвращаем ссылку на int. Меня очень радует,
[01:27:52.580 --> 01:27:56.780]  когда на наши лекции приходят, сначала они думают, что они все знают про C++, некоторые,
[01:27:56.780 --> 01:28:01.500]  кто уже писал A+, B, и им кажется вот, но когда начинают погружаться, оказывается, есть чуть
[01:28:01.500 --> 01:28:06.260]  больше чем. Нет, я понимаю, что те, кто никогда не слышал о C++, у вас, конечно, вынос мозга,
[01:28:06.260 --> 01:28:25.540]  но вы извините, надо было поступать другой вуз. Делаем функцию main. И в функцию, вызов функции,
[01:28:25.540 --> 01:28:31.700]  располагаем в необычном месте, в том самом, которое в тот год всем вынесло мозг, никто не
[01:28:31.700 --> 01:28:38.780]  догадался, ну потому что, может, правда, был вопрос криво сформулирован, но не знаю,
[01:28:38.780 --> 01:28:48.460]  мне нравилась эта задача. В левой части оператора присваивания мы пишем setX, вызов равно 92. Так,
[01:28:48.460 --> 01:28:55.500]  как бы, редко кто-то делает. И это корректный синтаксис, вызов функции с левой части в данном
[01:28:55.500 --> 01:29:03.780]  случае, это lvalue у нас. Почему? Сейчас разберемся. Так, вызвали функцию, распечатаем теперь x,
[01:29:03.780 --> 01:29:13.900]  и напишем return 0, и напишем теперь саму функцию, вот здесь, реализацию нашей функции. И так,
[01:29:13.900 --> 01:29:23.260]  определение пишем, функция setX. Тоже самое, у нас параметров нет, есть возвращаемые значения по
[01:29:23.260 --> 01:29:45.460]  ссылке, и она возвращает глобальную переменную x просто. Давайте даже для интереса, вот здесь
[01:29:45.460 --> 01:29:55.020]  тоже напечатаем этот x до и после этой функции, до вызова и после меняет, как она меняет. Итак,
[01:29:55.020 --> 01:30:07.220]  смотрите, что здесь у нас. Смотрите, у нас функция возвращает ссылку, ссылка это синоним имени,
[01:30:07.220 --> 01:30:16.740]  на какое имя она вернула нам ссылку, глобальную переменную x, вот на эту. То есть, этот setX на самом
[01:30:16.740 --> 01:30:22.460]  деле будет ссылаться в данном случае на x, поскольку функция возвращает ссылку, она вернула ссылку на x,
[01:30:22.460 --> 01:30:33.260]  и к x присвоится 92. Именно поэтому от 0 мы поменяемся до 92. Вот, и если вы думаете,
[01:30:33.260 --> 01:30:37.100]  что это нигде не используется, это используется. Мы будем это использовать, например, в перегрузке
[01:30:37.100 --> 01:30:42.060]  операций, когда будем писать класс многоугольник и для доступа к индексу. То есть, это реально
[01:30:42.060 --> 01:30:48.940]  используемые вещи, такой синтаксис нужен, и когда мы присваиваем в левой части элемент массива.
[01:30:48.940 --> 01:30:57.980]  Вопрос, мог я здесь написать return 3? Нет, почему? Непонятно, какому имени ему стать
[01:30:57.980 --> 01:31:04.060]  синонимом. То есть, он должен быть синонимом имени. Если я синонимом имени человека,
[01:31:04.060 --> 01:31:14.420]  я не могу привязаться к столу. Поэтому у нас с вами 3 нельзя, и здесь ему нужно было, как только
[01:31:14.420 --> 01:31:25.540]  конкретная, существующая переменная. А можно было сделать локальную переменную x, она бы скрыла
[01:31:25.540 --> 01:31:38.460]  глобально, и вот так. Что? Она погибла, а мы пытаемся ей присвоить. Тоже неверно. Но ВОП будет
[01:31:38.460 --> 01:31:45.020]  больше применение данного факта, просто обратите на это внимание. Теперь давайте следующий маленький
[01:31:45.020 --> 01:31:49.980]  подпункт про функции. У нас много будет таких вот сегодня. Я вам говорил, что функции — большая тема,
[01:31:49.980 --> 01:31:55.700]  поэтому ее на две лекции с вами изучаем. Встраиваемые функции. Итак, следующая подтема
[01:31:55.700 --> 01:32:22.340]  про функции — встраиваемые функции. Встраиваемые функции. Иногда функция вызывается и пишется,
[01:32:22.340 --> 01:32:31.280]  на самом деле, для того, чтобы упрощать нам синтаксис, хотя она очень простая. Ну давайте приведем
[01:32:31.280 --> 01:32:40.460]  пример. Пусть у меня есть функция float, которая считает среднее значение двух чисел. Она дает,
[01:32:40.460 --> 01:32:47.500]  перенимает 2n, x, y, и поскольку среднее значение может быть не целым, мы сделали тип float и
[01:32:47.500 --> 01:32:57.420]  возвращаем просто с вами их среднее значение. Для приведения типов, обращаю внимание,
[01:32:57.420 --> 01:33:03.620]  используем 2.0, чтобы деление не было целочисленным. Итак, мы сделали среднее значение двух чисел и
[01:33:03.620 --> 01:33:18.700]  вернула эту функцию. Теперь есть функция main, которая будет использовать эти вызывы. Объявим
[01:33:18.700 --> 01:33:32.100]  несколько переменных, a, b и c, присвоим им начальные значения. Ну и теперь давайте будем
[01:33:32.100 --> 01:33:37.500]  использовать нашу функцию average, которую мы уже написали, чтобы ее поэксплуатировать. Не зря же мы
[01:33:37.500 --> 01:33:49.900]  ее писали. Итак, cout. Наша функция от a и b. Можно ее дальше продолжать вызывать. Напечатаем теперь
[01:33:49.900 --> 01:34:03.060]  от b и c, от a и c, ну и так далее. То есть я могу же несколько раз в программе вызывать эту функцию.
[01:34:03.060 --> 01:34:27.100]  Как вы думаете, что здесь не очень эффективно? Ну, для одной переменной типа int не будем
[01:34:27.100 --> 01:34:33.180]  заморачиваться. Это эффективно на больших объектах. Что-то другое. Это что у вас такое? Это делает вас
[01:34:33.180 --> 01:34:42.780]  умнее? Или вы готовитесь к спасвяту в субботу? Итак, что еще вообще, когда функция есть,
[01:34:42.780 --> 01:34:54.100]  не совсем эффективна с точки зрения вызова функции? А вы что делаете с своим телефоном?
[01:34:54.100 --> 01:35:03.460]  Что? А он у вас увеличитель? Я думал, вы там ответы ищете. Это, извините, это реакция.
[01:35:03.460 --> 01:35:10.900]  Преподаватель, когда много работает, он уже сразу смотрит на студента, уже сразу думает,
[01:35:10.900 --> 01:35:20.740]  как он пытается списать данный момент, даже если он не на экзамене. Инстинкт. Вот. Так,
[01:35:20.740 --> 01:35:27.140]  ну что вот функция? Почему вы много раз вызывать функцию не очень хорошо? Да, молодой человек,
[01:35:27.140 --> 01:35:36.980]  пожалуйста, как вас зовут? На последней партии как? Не слышу. Иван. Хорошо. Рекурсии здесь нет,
[01:35:36.980 --> 01:35:42.100]  мы просто ее вызываем с вами несколько раз. Но каждый вызов, что нам стоит? Давайте по другому
[01:35:42.100 --> 01:35:47.460]  вопросу. Что нам стоит вызов функции? Он что-то стоит или нет? Почему вызов функции это время?
[01:35:47.460 --> 01:36:00.220]  Кто может объяснить? Давайте для этого посмотрим, как функция вызывается вообще. Кто такой вызов
[01:36:00.220 --> 01:36:06.540]  функции? Спустимся чуть-чуть ниже, представим себе, что мы компиляторы, мы наш код переходим,
[01:36:06.540 --> 01:36:13.780]  переводим машинный код, и нам надо это скомпилировать. Вот мы шли по строчкам. У нас
[01:36:13.780 --> 01:36:19.860]  была строчка, строчка, строчка, строчка. Потом хоп, в этой строчке вызов функции. Вот здесь какая-нибудь
[01:36:19.860 --> 01:36:26.420]  функция F со строчками. Что ему надо сделать? Ему надо сюда перейти. Может просто перейти,
[01:36:26.420 --> 01:36:32.620]  или ему надо что-то еще перед переходом сохранить? Во-первых, где он был? Правильно,
[01:36:32.620 --> 01:36:38.220]  это очень хороший ответ. Прежде чем куда-то переходить, запомните, где вы были. Ему надо
[01:36:38.220 --> 01:36:42.300]  сохранить адрес возврата, так называемый, чтобы, когда функция ретурном тут вышла в
[01:36:42.300 --> 01:36:47.540]  какое-то месте, он знал, куда вернуться, куда это сохраняется в стейке перед вызовом функции. То есть
[01:36:47.540 --> 01:36:56.460]  тут хоп, новая в стейке запись, адрес возврата. Еще что-то надо ему сохранять перед тем,
[01:36:56.460 --> 01:37:04.500]  как он туда провалится. Есть у процессора так называемые регистры. Это так называемая самая
[01:37:04.500 --> 01:37:09.900]  быстрая память, которая используется для ускорения вычислений и много чего. И этот
[01:37:10.780 --> 01:37:16.380]  это называется контекстом процессора. И контекст процессора надо тоже ему сохранить,
[01:37:16.380 --> 01:37:23.180]  прежде чем он уйдет отсюда. Потому что здесь эти переменные с этим контекстом работают. И тут
[01:37:23.180 --> 01:37:29.940]  он ушел, вернулся, ему все поменялось. Это вот как я отвернулся к доске, повернулся, а здесь все в
[01:37:29.940 --> 01:37:37.420]  одежде из игры кальмаров. Вот. И вот чтобы этот контекст не поменялся, мы с вами должны сохранить
[01:37:37.980 --> 01:37:45.060]  его перед вызовом и вернуть ему, чтобы эти строчки вообще не заметили, чтобы в них выходили,
[01:37:45.060 --> 01:37:50.260]  или заходили. Что все было для него как есть. Вот как я был, вот так у меня все лежит на столе,
[01:37:50.260 --> 01:37:54.860]  ничего не изменилось. Неважно, что тут функция какая-то в это время вызывалась. Она тут бегала,
[01:37:54.860 --> 01:38:00.260]  не знаю, сломала мне стол, выпила мою воду, но мне, когда я повернулся назад, все вернулось. Вот
[01:38:00.260 --> 01:38:09.380]  этот контекст сохранен. И это время. Это время на копирование. Сначала из регистров в стэк,
[01:38:09.380 --> 01:38:16.820]  потом из стэка в регистры. Плюс вот эти переходы. А ради чего это время? Ради вот этой строчки,
[01:38:16.820 --> 01:38:23.420]  ради вот этого выражения. Если бы функция была серьезная, мы ради нее такую подготовку сделали,
[01:38:23.420 --> 01:38:29.740]  а внутри функции всего лишь два числа складываются, делится на два. Но если я вот здесь буду писать,
[01:38:29.740 --> 01:38:35.220]  х плюс у делить на два ноль, х плюс у делить там на два ноль. Но это, конечно, тоже не дело,
[01:38:35.220 --> 01:38:41.860]  если буду дублировать это. Поэтому встроенные функции, это те самые функции, которые обладают
[01:38:41.860 --> 01:38:50.580]  преимуществом функций с точки зрения того, что вы инкапсулируете код, вы его повторно не пишете,
[01:38:50.580 --> 01:38:58.180]  он у вас один раз написан. И при этом она не вызывается вот по этому методу. Что значит не
[01:38:58.180 --> 01:39:03.580]  вызывается по этому методу? Это значит, что когда компилятор компилирует, он в этом месте просто
[01:39:03.580 --> 01:39:09.140]  тело функции подставляет. Фактически здесь напишут эту формулу. И здесь напишут эту формулу. Не будет
[01:39:09.140 --> 01:39:14.900]  делаться вызовов. То есть функция встраивается в текст, и это называется встроенная функция.
[01:39:14.900 --> 01:39:19.700]  Чтобы она такой стала, давайте до float напишем слово inline.
[01:39:19.700 --> 01:39:28.460]  Inline.
[01:39:28.460 --> 01:39:49.100]  Inline. Это если у меня только одно определение. Inline – это как бы все-таки просьба. Это не
[01:39:49.100 --> 01:40:00.020]  указание. Это указание, что вы хотите это сделать, но компилятор сам решит,
[01:40:00.020 --> 01:40:09.220]  может он это сделать или нет. То есть это просьба на то, что встройка мне эту функцию. Что плохого?
[01:40:09.220 --> 01:40:14.500]  Код растет, потому что вместо вызова у вас теперь весь код. Если здесь 10 строчек,
[01:40:14.500 --> 01:40:20.660]  здесь будет 10 строчек, здесь 10. То есть сам код растет, потому что вы ее встроили. С другой стороны,
[01:40:20.660 --> 01:40:30.700]  нет затрат на ее вызовы. Вот здесь у нас просто написано определение. Если бы у вас было
[01:40:30.700 --> 01:40:38.460]  объявление, потом определение, вы можете написать в любом месте. Обычно пишут в объявлении эту
[01:40:38.460 --> 01:40:47.760]  функцию. И то же самое, кстати говоря, со статик. Когда мы делаем функцию статик, мы тоже можем ее
[01:40:47.760 --> 01:40:52.460]  объявлять не везде, но надо как минимум в первом объявлении по стандарту сделать ее статик. Если
[01:40:52.460 --> 01:40:56.100]  вы сделаете втором, это будет ошибка. Несмотря на то, что Visual Studio, например, эту ошибку не дает,
[01:40:56.100 --> 01:41:01.140]  по стандарту это ошибка. Но я вам уже говорил, что Visual Studio – это тот компилятор, который немножко
[01:41:01.140 --> 01:41:07.260]  портит программистов. Он там обнуляет, что не должен, не дает ошибку, когда надо. Потому что он
[01:41:08.060 --> 01:41:17.700]  гнуси++ более следующий стандарту компилятор, поскольку он как раз… А Microsoft, она немножечко вас
[01:41:17.700 --> 01:41:26.820]  расслабляет. Но это неважно. Это такие нюансы. Главное, что вы должны понять, что можно в первом
[01:41:26.820 --> 01:41:36.300]  месте объявить, а потом нет. Следующая наша по тема – аргументы по умолчанию. Ну или параметры
[01:41:36.300 --> 01:41:41.620]  по умолчанию. Давайте напишем параметры, как мы сегодня говорили. Параметры по умолчанию.
[01:41:41.620 --> 01:42:09.940]  Это еще одна интересная наша тема на сегодня. Пусть у меня есть какая-то функция.
[01:42:09.940 --> 01:42:26.500]  И в этой функции у меня есть два параметра. Первый – обычный int, а второй – не совсем
[01:42:26.500 --> 01:42:42.300]  обычный, а со значением по умолчанию. Теперь я могу эту функцию вызывать разным способом. Могу вызвать
[01:42:42.300 --> 01:42:56.700]  обычно с двумя параметрами. Не знаю. А могу вызвать вот так. И это правильно. Потому что если
[01:42:56.700 --> 01:43:01.900]  я не дал второй параметр, то по умолчанию подставится ноль. Вот что значит функция с
[01:43:01.900 --> 01:43:06.980]  параметрами по умолчанию. У вас есть некие параметры, которые заполняются значениями по умолчанию
[01:43:06.980 --> 01:43:21.940]  и в зависимости от того, что вы написали, будет либо ноль, либо тот параметр, который вы передали.
[01:43:21.940 --> 01:43:32.900]  Давайте еще одну такую функцию со значением по умолчанию напишем. Например, функция f1.
[01:43:32.900 --> 01:43:48.180]  int равно 100. Это прототип, обращаю ваше внимание. Мы пишем сейчас объявление, но не определение.
[01:43:48.180 --> 01:43:59.260]  Здесь интересная особенность синтеза. Сейчас звездочка пробел равно нулю. Потому что если
[01:43:59.260 --> 01:44:03.940]  я хочу дать указателю на char параметру по умолчанию ноль, я должен делать пробел. Если
[01:44:03.940 --> 01:44:07.660]  этого не сделаю, у вас будет сокращенное умножение умножить равно. Сокращенное
[01:44:07.660 --> 01:44:12.460]  присваивание с умножением. Он не разберет лексему. Иногда надо расставлять пробел,
[01:44:12.460 --> 01:44:20.020]  чтобы понимать компилятор, что вы хотите от него. Теперь у меня есть функция f1, которая будет
[01:44:20.020 --> 01:44:27.460]  где-то ниже у нас определена. Это только объявление. В объявлении можем не указывать
[01:44:27.460 --> 01:44:33.100]  имена переменных. В определении мы все определим и напишем ее тело. Как мы будем вызывать эту
[01:44:33.100 --> 01:44:39.140]  функцию? Для вызова, кстати, нам не нужно пока определение. Можем вызов делать до того,
[01:44:39.140 --> 01:44:43.980]  как оно сделано. Компилятору главное до вызова увидеть объявление, чтобы он мог проверить
[01:44:43.980 --> 01:44:53.420]  корректность вызова и уже подставлять адреса. Такой вызов допустим. Вы даете f1, один параметр,
[01:44:53.420 --> 01:44:59.820]  первый, он обязателен, и два следующие у вас необязательные параметры. Можно с двумя параметрами.
[01:44:59.820 --> 01:45:12.220]  А и 10. Тоже корректно. В этом случае третий параметр вы не даете, он будет у вас каким-то
[01:45:12.220 --> 01:45:23.700]  инициализирован нулем. А, 10 и наше любимое слово из пяти букв, как вы помните,
[01:45:23.700 --> 01:45:38.860]  матан в прошлых серии. Значит, а, 10 и матан. Значит, у нас с вами все три параметра заполнены,
[01:45:38.860 --> 01:45:55.740]  незначение мы по умолчанию. Вот задали вопрос, можно ли написать так. Я как раз хотел рассказать,
[01:45:55.740 --> 01:46:04.260]  но ты молодец, ты чувствуешь, смотришь прямо в глаз, а не в бровь. Итак, вот у вас а, он не хочет
[01:46:04.260 --> 01:46:11.380]  второй давать, но матан он не может бросить, поэтому третий он хочет. Я, кстати, не знаю,
[01:46:11.380 --> 01:46:15.660]  по-моему, на записи мне сказали, я не смотрел записи ни разу, вопросы, которые вы говорите не
[01:46:15.660 --> 01:46:20.900]  слышные, поскольку петличка далеко, это правда? А, ну, значит, надо ходить на лекции, чтобы слышать
[01:46:20.900 --> 01:46:27.500]  вопросы. Зато вы слышите ответы и должны по ним восстанавливать, какие были вопросы. Значит,
[01:46:27.500 --> 01:46:33.060]  в данном случае был вопрос, можно ли пропускать параметр. Нет, нельзя. Это неправильный синтаксис,
[01:46:33.060 --> 01:46:38.300]  не компилируется. А вопрос к вам меня, почему так сделали сознательно разработчики стандарта?
[01:46:38.300 --> 01:46:44.580]  Почему они в параметрах по умолчанию запретили пропускать? То есть правило какое здесь? Если ты
[01:46:44.580 --> 01:46:49.940]  пропускаешь какое-то, дальше ты обязан все остальные тоже пропустить. То есть если какое-то
[01:46:49.940 --> 01:46:53.820]  ты не указываешь параметры больше, все остальные тоже не указываешь, они тоже все будут правее
[01:46:53.820 --> 01:46:57.860]  по умолчанию. Это правило было сделано сознательно. То есть нельзя вот такой вызов сделать f,
[01:46:57.860 --> 01:47:04.140]  a, 5 запятых, там b. Уже вы догадались, наверное, для чего, чтобы вот эти запятые не пересчитывать.
[01:47:04.140 --> 01:47:09.540]  Знаете, когда я как-то в вербанке счет пересчитывал, ноль, ноль, ноль, ноль, ноль, там сколько этих
[01:47:09.540 --> 01:47:15.220]  ноликов, не ошибиться. Сложно, когда вы видели, когда вот этот номер счет, и вам надо его написать,
[01:47:15.220 --> 01:47:20.140]  и там вот эти 8 нулей подряд, ты пальцем водишь, сколько же там нулей. Чтобы то же самое здесь,
[01:47:20.140 --> 01:47:29.540]  чтобы то же самое здесь у вас не пересчитывать запятые и пропустив запятую не тот параметр,
[01:47:29.540 --> 01:47:34.580]  подставив, потому что ты там не 9, а 8 сделал запятых, просто решили, чтобы люди не страдали этим
[01:47:34.580 --> 01:47:43.100]  разом запретить так делать и все. Залог ошибок это потенциальный, поэтому запретили. Это вот что
[01:47:43.100 --> 01:47:49.660]  касается правил. А теперь еще у меня к вам вопрос, как вы думаете, зачем это надо, зачем вообще
[01:47:49.660 --> 01:47:59.740]  параметры по умолчанию могут быть полезны? Кто даст какую-нибудь версию? Не было бы параметров
[01:47:59.740 --> 01:48:09.700]  по умолчанию, все было бы хорошо, а тут коп, какие-то параметры по умолчанию появились. Ну а зачем
[01:48:09.700 --> 01:48:15.620]  тогда его делать, если он не нужен никогда? Если он всегда ноль у вас практически, тогда и не нужен
[01:48:16.180 --> 01:48:23.380]  почти всегда, но есть более разумные объяснения, для чего они точно нужны. Да, я хочу, чтобы кто-нибудь
[01:48:23.380 --> 01:48:27.700]  догадался, у вас 100 человек и 100 человек точно должен один быть почти разработчиком C++,
[01:48:27.700 --> 01:48:31.740]  родственником дальним страус трупа, по пятым пожатию руки в фейсбуке, да?
[01:48:31.740 --> 01:48:42.820]  Не совсем. Давайте подумаем о совместимости. Смотрите, вы написали какую-то библиотеку.
[01:48:42.820 --> 01:48:59.020]  Чтобы никто не знал, какие значения, тоже плохо, потому что, ну как-то только разработчики знают,
[01:48:59.020 --> 01:49:12.260]  что по умолчанию. Нет, смысл был… Это уже ближе. Смотрите, вы написали какую-то функцию в своей
[01:49:12.260 --> 01:49:19.620]  библиотеке. И эту библиотеку используют миллион программистов по всему миру. Это самая лучшая
[01:49:19.620 --> 01:49:26.660]  функция. Все купили, заплатили вам по доллару, там, не знаю, вашу библиотеку в AppStore, вы стали
[01:49:26.660 --> 01:49:31.220]  богаче Цукерберга, и вообще все хорошо. А потом вы решили заработать еще больше денег и написали
[01:49:31.220 --> 01:49:37.780]  новую версию этой функции, которая чуть более совершенно делает еще больше, но ей надо чуть
[01:49:37.780 --> 01:49:43.100]  больше параметров. Если вы просто добавите параметров, у вас в новой библиотеке она будет
[01:49:43.100 --> 01:49:47.860]  работать, а со старыми, которые не знали, что вы ее обновили, совместимость потеряется, поскольку
[01:49:47.860 --> 01:49:52.980]  они вызывают двумя параметрами, а у вас уже три. И чтобы была совместимость со старыми версиями,
[01:49:52.980 --> 01:49:58.340]  вы можете просто добавить третий, как пример, по умолчанию и видеть, что если вас вызвали со
[01:49:58.340 --> 01:50:03.180]  двумя параметрами по умолчанию, значит они используют там старую версию или поставить тот,
[01:50:03.180 --> 01:50:07.340]  который не испортит вам новую версию. Вот для чего делается, в том числе, в первую очередь для
[01:50:07.340 --> 01:50:11.860]  обратной совместимости, потому что важно, чтобы код не только исполнялся вот в этой конкретной
[01:50:11.860 --> 01:50:17.140]  версии. Вы же когда новую Windows 11 устанавливаете, у вас не перестают приложения, которые были для
[01:50:17.140 --> 01:50:24.460]  Windows 10 работать, и вам надо все заново там покупать. Это было бы очень странно, поэтому обратная
[01:50:24.460 --> 01:50:31.780]  совместимость с вашими программами и с библиотеками, для этого делаются такие вещи.
[01:50:31.780 --> 01:50:38.500]  И переходим к следующей нашей теме, перегрузка функций, перегрузка функций.
[01:50:54.460 --> 01:51:04.060]  Перегрузка функций.
[01:51:04.060 --> 01:51:25.220]  Давайте запишем определение. Перегрузкой функций называется использование нескольких функций
[01:51:25.220 --> 01:51:47.780]  с одним и тем же именем. Перегрузкой функций называется использование нескольких функций с одним
[01:51:47.780 --> 01:51:54.460]  и тем же именем, но с различными типами параметров.
[01:51:54.460 --> 01:52:07.060]  Но с различными типами параметра.
[01:52:07.060 --> 01:52:26.340]  Пусть у меня есть функция максимум, которая ищет максимум из двух чисел,
[01:52:26.340 --> 01:52:42.420]  принимает два int, возвращает тоже int. Допустим, я хочу сделать еще одну функцию максимум,
[01:52:42.420 --> 01:52:49.020]  но которая принимает не int, а например, принимает две char звездочки, указатель на char,
[01:52:49.020 --> 01:52:55.140]  и эти две строки у нас будут, ищет максимальную строку по длине, какая длинее, и возвращает эту
[01:52:55.140 --> 01:53:03.580]  строку. Я бы должен был бы к вами делать другую функцию, но это неудобно. У меня так слова закончатся.
[01:53:03.580 --> 01:53:10.060]  Пусть у меня будет такая же функция с тем же именем, но с другими типами параметра. Это называется
[01:53:10.060 --> 01:53:21.300]  механизм перегрузки, который у нас в C++ есть. А именно, я возвращаю функцию, возвращаю значение
[01:53:21.300 --> 01:53:30.380]  с функцией char звездочка, тоже называю ее max, но здесь у меня уже другие параметры, другие типы
[01:53:30.380 --> 01:53:45.060]  параметров char звездочка и char звездочка. Это подстрока наибольшей длины. А давайте я сделаю
[01:53:45.060 --> 01:53:55.620]  следующее, например, возьму функцию, которая мне находит максимум из моего числа и длины строки,
[01:53:55.620 --> 01:54:02.700]  и возвращает это число в качестве ответа. Еще один пример я придумал, когда я могу
[01:54:02.700 --> 01:54:18.540]  использовать функцию max, но и наоборот, max из длинной строки числа тот больше, какое число больше,
[01:54:18.540 --> 01:54:31.180]  то и вернется в качестве результата. Теперь в основной программе пусть у меня будет какая-то
[01:54:31.180 --> 01:54:53.180]  функция f, которая принимает следующие параметры int a, int b, char звездочка c, char звездочка d. Вот у
[01:54:53.180 --> 01:55:03.860]  меня есть некая функция, которая сейчас будет вызывать наши перегруженные функции. Я могу вывести на
[01:55:03.860 --> 01:55:17.220]  экран max из ab, идет вызов первой функции, потому что a и b у меня int. Из этих четырех функций компилятор
[01:55:17.220 --> 01:55:26.820]  выберет подходящую по параметрам. Выберется первая int, int. Дальше max из cd,
[01:55:26.820 --> 01:55:45.220]  выберется вторая char звездочка, char звездочка. Дальше max из ac, понятно, что вызовется третья
[01:55:45.220 --> 01:55:55.780]  int и char звездочка, и max из cb вызовется четвертая. То есть я вызываю разные функции, но использую одно
[01:55:55.780 --> 01:56:07.940]  и то же имя. Это позволяет мне оставаться в том синтаксисе, в котором я работаю, потому что в старом
[01:56:07.940 --> 01:56:15.460]  добром си не буду ничего плохого говорить про си. Прекрасный язык. Все-таки си плюс тус просто устранил
[01:56:15.460 --> 01:56:20.900]  эти недостатки, которые все были. Нельзя было все продумать изначально. Как там называются у вас
[01:56:20.900 --> 01:56:27.900]  функции? У вас есть функция abs, которая до перегрузки, как это было, abs возвращает у вас
[01:56:27.900 --> 01:56:34.380]  абсолютное значение. Поскольку у нас по расписанию заканчивается, это заглядывают, а то меня сейчас
[01:56:34.380 --> 01:56:43.340]  придут, наверное, выгонять. Вот сейчас в 25 все-таки или в 30? А в следующем во сколько начинается? А у них
[01:56:43.340 --> 01:56:56.580]  5 минут, окей. Abs для int. Например fabs, абсолютное значение. Может быть вы встречали такую функцию
[01:56:56.580 --> 01:57:06.780]  для вещественного числа, для дабла. Для комплексного там было caps у нас, для long было abs. И поскольку
[01:57:06.780 --> 01:57:12.500]  нет когда перегрузки, нам надо придумывать новые имена для разных типов. И это, конечно же, жутко
[01:57:12.500 --> 01:57:22.380]  неудобно. Именно поэтому перегрузка устранила у нас вот эти проблемы. Просто можем теперь писать
[01:57:22.380 --> 01:57:28.260]  одно имя и в зависимости от того, с каким параметром вы вызываем, компилятор то или другое значение
[01:57:28.260 --> 01:57:36.340]  подставляет. Теперь важный вопрос. Как вы думаете, на выбор, на выбор вот когда происходит так
[01:57:36.340 --> 01:57:40.340]  называемый resolution, разрешение с точки зрения компилятора, какую именно функцию выбрать,
[01:57:40.340 --> 01:57:49.580]  потому что у него 4 max вы вызываете, ему приходится подбирать. На что он смотрит? А именно, а можете
[01:57:49.580 --> 01:57:58.900]  закрыть дверь, пожалуйста? Что же такое это? А охрану будем ставить, чтобы следующая лекция по
[01:57:58.900 --> 01:58:09.820]  истории нас не вытесняла. У нас еще время. Ну, по-моему. Значит, на что мы будем смотреть? Вот на это
[01:58:09.820 --> 01:58:20.660]  или на это тоже? Вот вопрос. Только на входные данные. Мы игнорируем значение, мы не знаем.
[01:58:20.660 --> 01:58:28.540]  Тиаути это неважно, это отличный пример как раз, когда мы не можем анализировать выходное значение,
[01:58:28.540 --> 01:58:33.700]  потому что некоторые, когда пишут перегрузку, думают, ну я же присваиваю int, а я присваиваю
[01:58:33.700 --> 01:58:38.620]  чар звездочки в данном случае эту функцию. Почему он не смотрит, куда это присваивают? Да потому что
[01:58:38.620 --> 01:58:45.100]  он не может все, он как бы не анализирует, что вы дальше с этим делаете. Он только вызывает функцию и
[01:58:45.100 --> 01:58:52.180]  все, а дальше вы можете это печатать, можете куда-то присваивать, можете вообще ничего с этим делать,
[01:58:52.180 --> 01:58:59.700]  это никак не влияет. Поэтому вот это значение левое, то есть возвращаемое значение, не участвует в так
[01:58:59.700 --> 01:59:08.100]  называемой сигнатуре той уникальной записи о функции, которая состоит из имени типов и порядки
[01:59:08.100 --> 01:59:16.060]  этих типов. То есть для него важно имя, типы и какой у них порядок, 2 int в таком-то порядке. И вот здесь
[01:59:16.060 --> 01:59:21.820]  мы смотрим 2 int, вот порядок, или там int, чар звездочка, чар звездочка, вот эти отличаются не типами,
[01:59:21.820 --> 01:59:32.900]  но порядка этих типов. А что такое встроенная функция? Это не встроенная функция, это функция
[01:59:32.900 --> 01:59:44.340]  из библиотеки. Нет, конечно, если вы как бы не знаете, как это работает, потому что вы ее не пишете,
[01:59:44.340 --> 01:59:49.820]  при вызове вы об этом не думаете, это уже разработчики этих функций решают, как они ее напишут,
[01:59:49.820 --> 01:59:58.500]  вы только свои можете такими сделать. Вот здесь важно вот это, но бывает у нас не точное
[01:59:58.500 --> 02:00:05.220]  соответствие типов. И в данном случае мы делаем так называемые преобразования типов,
[02:00:05.220 --> 02:00:10.020]  мы уже с вами встречались, например, у нас есть некое продвижение типов,
[02:00:10.020 --> 02:00:29.500]  bool, char могут преобразовываться в int, load в double. Мы уже с вами говорили, что int у нас тоже
[02:00:29.500 --> 02:00:40.300]  стандартно преобразовывается в double, такое у нас преобразование есть, и указатели могут
[02:00:40.300 --> 02:00:49.700]  преобразовываться на пустой указатель звездочку. Но перегрузка нам бывает доставляет очень много
[02:00:49.700 --> 02:00:59.060]  проблем, когда мы начинаем с вами какие-то делать очень сложные комбинации, совмещая перегрузку,
[02:00:59.060 --> 02:01:07.660]  еще с чем-то и может быть такая двухзначность. Давайте рассмотрим пример, который покажет нам,
[02:01:07.660 --> 02:01:12.580]  что и перегрузку, и параметры помолчания, особенно если комбинировать вместе, то у вас
[02:01:12.580 --> 02:01:26.580]  будут просто супер такие сложные вещи. Итак, пусть у меня есть некая функция, у нас так много
[02:01:26.580 --> 02:01:35.500]  материала, мы даже перерыв на второй парень делали, но неважно, float f, и так пусть у меня какая-то
[02:01:35.500 --> 02:02:01.020]  функция. Так пусть у меня есть функция f, которая принимает и и возвращает float. Эта функция ничего
[02:02:01.020 --> 02:02:09.540]  особенного не делает, она просто пусть, например, вернет просто и, которой ей дали. Давайте еще
[02:02:09.540 --> 02:02:25.860]  одну функцию, double f, и она перегружена по даблу, и нам надо здесь тоже самое можно сделать,
[02:02:25.860 --> 02:02:35.500]  просто вернуть, например, и умножить на 2. Вот у нас есть две функции перегруженные, одна float
[02:02:35.500 --> 02:02:45.700]  принимает, другая double. То, что возвращает, никого не волнует. Теперь в мейне. Создадим
[02:02:45.700 --> 02:03:05.660]  с вами переменную x типа float, и создадим переменную y типа double, и тоже дадим такое же значение 10,9.
[02:03:05.660 --> 02:03:14.420]  Теперь я, ой, давайте double, да, я уже тороплюсь, поскольку слышу смех историков в коридоре,
[02:03:14.420 --> 02:03:19.980]  чувствую, что сейчас через минуту они ворвутся такой толпой, и мы не устоим, там их два раза больше.
[02:03:19.980 --> 02:03:36.180]  Итак, c out, c out f от x, c out f от y. Здесь все круто, x float, y double, все вызывается первое,
[02:03:36.180 --> 02:03:47.460]  потом вызывается второе. Никаких проблем нет. А вот теперь, если я напишу c out f от 10, то у него
[02:03:47.460 --> 02:03:54.700]  нет точного соответствия, поскольку 10 может быть преобразовано как во float, так и в double,
[02:03:54.700 --> 02:04:02.100]  и если есть какая-то неоднозначность, это называется двухсмысленный вызов, и вызова не происходит.
[02:04:02.100 --> 02:04:06.260]  Это не скомпилируется, потому что он точно не может знать, что вызывать,
[02:04:06.260 --> 02:04:14.060]  потому что 10 это не float и не double, а может быть преобразовано и туда, и туда. Ну и давайте еще
[02:04:14.060 --> 02:04:26.460]  последний пример дадим с вами на неоднозначность при перегрузке. Вот такой. Так,
[02:04:26.460 --> 02:04:37.860]  пусть у меня есть функция f, которая принимает int, возвращает int, и в теле функция, она просто
[02:04:37.860 --> 02:04:49.820]  возвращает то, что она приняла. Пусть есть другая функция f, которая принимает два параметра,
[02:04:49.820 --> 02:05:03.700]  но второй из них по умолчанию. Ну она что-то там делает, return, а умножить на b, например. Вот такое
[02:05:03.700 --> 02:05:18.580]  у него простое тело. Теперь main. Мы с вами вызываем функцию f, печатая результат с двумя параметрами.
[02:05:18.580 --> 02:05:32.060]  10 и 2. Сейчас одну минуточку. И после этого я вызываю с вами. Все здесь нормально. f с одним
[02:05:32.060 --> 02:05:40.540]  параметром 10. И что ему выбрать? Они перегружены, но здесь у меня значение по умолчанию, и он может
[02:05:40.540 --> 02:05:47.260]  как этот вызвать, так этот. Это неоднозначно связано, что у вас перегрузка со значением по умолчанию.
[02:05:47.740 --> 02:05:54.300]  Этот вызов невозможен, он двухсмысленный. Это все, что я хотел вам рассказать. На этом
[02:05:54.300 --> 02:06:02.700]  наш лекции закончено. Спасибо. Спасибо большое и до следующего раза.
