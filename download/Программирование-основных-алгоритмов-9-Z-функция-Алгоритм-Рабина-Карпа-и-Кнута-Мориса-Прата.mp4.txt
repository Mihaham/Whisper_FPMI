[00:00.000 --> 00:16.680]  Лекция 9. У нас сегодня строки. Начинаем. Первая задача, которую мы будем разбирать всю лекцию,
[00:16.680 --> 00:39.000]  это задача о поиске какого-либо паттерна в тексте. Чуть формальнее даны паттерн P.
[00:46.680 --> 01:04.160]  Ноль индексации будем все вести. И текст. Давайте T его обозначим. Вот такая вот постановка задачи.
[01:04.160 --> 01:25.360]  Это то, что нам дано. Хотим все такие И, что P равно T. Я буду использовать бетоновскую индексацию.
[01:25.360 --> 01:36.320]  То есть мы хотим найти все такие индексы И, что паттерн входит в текст. Если сложно по формуле,
[01:36.320 --> 01:51.480]  то картиночка. Это наш текст. Это наш паттерн. Здесь у нас будет И плюс модуль P минус 1.
[01:52.200 --> 01:58.440]  Мы хотим, чтобы у нас это все было равно паттерну нашему.
[01:58.440 --> 02:13.920]  И мы хотим найти все такие И. Самая наивная постановка и простая. Найти хотя бы одно такое И,
[02:13.920 --> 02:19.040]  то есть есть ли вообще вхождение паттернов в текст. Если да, то хотим найти их все.
[02:19.040 --> 02:26.000]  В общем-то, задача такая. У нее есть несколько решений. Я знаю четыре. У меня даже больше.
[02:26.000 --> 02:32.920]  Но нас будет интересовать не все. А именно есть нулевое решение, которое записывать не буду,
[02:32.920 --> 02:38.400]  называется наивным. Это взять в каждой позиции И, попытаться приложить паттерн и проверить
[02:38.400 --> 02:44.640]  наивно, что они равны. То есть вы берете, перебираете И, дальше сравниваете. Правда ли,
[02:44.640 --> 02:49.080]  что это подстрока равна паттерну? Итак, для каждого И очень интеллектуальное решение,
[02:49.080 --> 02:54.400]  поэтому на доске его не будет. А симпточку предлагаю оценить самостоятельно.
[02:54.400 --> 03:07.920]  Окей, рассмотрим такую штуку. Z функция. Если что, она приобрела такое название задолго до,
[03:07.920 --> 03:13.560]  возможно, символизма у нее. Поэтому просто так оставим. Определение.
[03:13.560 --> 03:32.900]  Z функция от st и t равно максимальному k. Такое, что
[03:43.560 --> 03:51.040]  вот такое вот интересное определение. То есть у вас эта штука Z функция строится по строке и
[03:51.040 --> 04:06.240]  по факту возвращает вам массив, где в итой точке вот такое вот значение. Картиночка. Вот ваша итая
[04:06.240 --> 04:11.240]  позиция. Когда вы хотите как можно дальше направо уйти, чтобы у вас вот эти вот части были равны.
[04:11.240 --> 04:24.640]  То есть это если это и плюс z ита, это просто z ита будет. Берем, что вот это вот равно вот этому вот.
[04:24.640 --> 04:32.920]  Окей, ну это к максимально всех возможностях. То есть можно правее берем.
[04:32.920 --> 04:44.320]  Собственно, как проверять наличие паттернов в тексте? Вам нужно, ну окей, давайте сначала научимся
[04:44.320 --> 04:51.920]  считать их эффективно. Вот, а потом уже разберемся, как паттерны искать. Так, алгоритм построения.
[04:51.920 --> 05:04.600]  Собственно, их два. Первый алгоритм, он тоже не появится на доске, потому что он наивный и не
[05:04.600 --> 05:11.600]  оптимальный по времени, а все-таки Z функцию надо строить оптимально. Вот, поэтому сразу перейдем
[05:11.600 --> 05:34.840]  к линейному алгоритму. Напишем определение. Z блок, это у нас будет, это под строка и плюс z ита,
[05:34.840 --> 05:42.160]  соответственно. То есть если вы в какой-то точке посчитали и, посчитали z и, то вот эта штука
[05:42.160 --> 05:53.520]  называется Z блоком. Окей. Собственно, в ходе алгоритма мы будем поддерживать Z блок. Алгоритм
[05:53.520 --> 06:16.400]  поддерживает Z блок с наибольшей правой границей. То есть если у вас, ну понятно, у вас в каждой
[06:16.400 --> 06:21.360]  точке и начинается какой-то Z блок, вы выбираете тот, у которого правая граница максимальна,
[06:21.360 --> 06:33.720]  ну и мы будем его поддерживать все время. Его границы будут обозначаться очень просто. LR,
[06:33.720 --> 06:43.560]  очень интеллектуально. Окей, тогда нужно просто рассмотреть кучу случаев, как будем переставить
[06:43.560 --> 07:04.480]  Z функцию. Так, картинка, большая картинка. Давайте это L, это R, это I. И допустим, что мы посчитали
[07:04.480 --> 07:12.040]  уже для всех z меньше i, z функцию уже знаем. То есть вот здесь на префиксе мы уже все знаем.
[07:12.040 --> 07:32.880]  Посчитали z0, z и-1. Кстати, чему равен z0? Ну как база индукции. Ну да, можно определить,
[07:32.880 --> 07:41.120]  как длину строки, например. Некоторые говорят, что здесь мы требуем не собственный префикс,
[07:41.120 --> 07:52.680]  то есть чтобы он был не равен всей строке, тогда говорят, что это 0. Ну только он игнорируется
[07:52.680 --> 07:58.760]  при рассмотрении далее. Просто z0, она просто ставится по факту и дальше начинается алгоритм
[07:58.760 --> 08:06.760]  с единички. Вот. Ну можно z0 равный 0, надеюсь, чтобы было проще жить. Не надо, все равно
[08:06.760 --> 08:22.520]  туда смотреть не будем. Окей, что мы делаем дальше? L равно R равно минус 1, то есть у нас нет ни одного
[08:22.520 --> 08:31.640]  z-блока, считаем теперь. Соответственно, теперь нам остается посчитать z и-то, если мы знаем все
[08:31.640 --> 08:56.600]  вот эти вот. Утверждение такое. Сейчас подгоним нужную сторону. Здесь плюс-минус 1. Так,
[08:56.600 --> 09:11.120]  давайте доказывать. Для этого мы посмотрим, если у нас это LR, то вот это значит, что вот эта вот
[09:11.120 --> 09:19.600]  штука равна какой-то вот этой вот штуке, так это z-блок. И что еще мы знаем? Мы знаем его длину
[09:19.600 --> 09:33.400]  что-то типа R минус L плюс 1. В силу того, что они равны, у нас где-то есть аналогичная точка I. Ну,
[09:33.400 --> 09:44.080]  только она будет I минус L, иметь индекс. Окей, что теперь мы знаем? Если у нас есть этот I минус L
[09:44.080 --> 09:55.960]  какой-то, давайте лучше I чуть правее нарисую, чтобы картинка была поадекватней чуть-чуть.
[09:55.960 --> 10:08.080]  И минус L. И у нас есть два случая. Давайте смотрим первый случай. А, еще здесь нужно видеть,
[10:08.080 --> 10:17.320]  что если I лежит в отрезке LR. Вот, теперь будет правдой. Так, первый случай это то, что у нас
[10:17.320 --> 10:31.360]  zI минус L меньше, чем R минус I плюс 1. Что это значит? Это значит, что у нас вот это значение z-функции
[10:31.360 --> 10:39.920]  как-то вот так вот. То есть оно не доходит вот сюда вот. Вот здесь вот такое вот. То есть вот это вот
[10:39.920 --> 10:50.080]  будет вот это вот будет I плюс z I минус L, вот здесь вот. А здесь вот будет I минус L плюс z I минус L.
[10:50.080 --> 10:59.440]  Так как это одинаковые строки, вот эти две штуки тоже равны. Но заметим, что так как мы знаем,
[10:59.440 --> 11:07.800]  что это значение z-функции, значит у нас вот эти вот равны. То есть у нас вот это вот, давайте двумя дужками
[11:07.800 --> 11:19.840]  обозначу. Они равны все друг другу. Вот, ну тогда из этого следует, что z-функция в этой точке,
[11:19.840 --> 11:31.040]  она хотя бы имеет вот такую вот длину. Потому что эти штуки равны. Согласны? Давайте распишем,
[11:31.040 --> 11:44.880]  что именно у нас есть. У нас есть следующее, что так как R минус L плюс 1 равно
[11:44.880 --> 12:03.040]  плюс 1, потому что R все-таки отрезан. Так как это верно, что из этого следует? Из этого следует,
[12:03.040 --> 12:20.320]  что верно нравится вот этих вот штук двух. То есть s I минус L. I минус L плюс z I минус L плюс 1.
[12:20.320 --> 12:27.640]  Вот так вот будет. В полуинтервале вот такого здесь будет обозначаться. Он у нас равен вот этой
[12:27.640 --> 12:51.040]  вот штуке. Так, I плюс z I минус L плюс 1. Вот. Теперь так как у нас есть значение z-функции здесь,
[12:51.040 --> 13:03.160]  из этого следует, что s z I минус L совпадает с, то есть вот эта вот часть с этой.
[13:03.160 --> 13:14.960]  I минус L плюс z I минус L плюс 1.
[13:14.960 --> 13:38.800]  Ну, будто бы вот так вот. Тогда у нас вот эти две части равны. То есть из этого следует.
[13:38.800 --> 14:00.640]  Совпадает с вот такой вот штукой. I. I плюс z I минус L плюс 1. Ну, откуда значит,
[14:00.640 --> 14:23.120]  что у нас и того, что z I t, z I минус L t. То есть z I минус у нас верно вот это вот. И при этом эта штука меньше, чем это.
[14:23.120 --> 14:29.640]  Ну, возвращается тогда, что z I t больше собрать чем минимум из этих двух. Ну, логично. Потому что
[14:29.640 --> 14:35.040]  минимум из этих двух-то вот это вот. А мы получили, что это больше либо равно. Более того, на самом деле,
[14:35.040 --> 14:46.640]  здесь можно заметить следующее. Давайте отметим здесь это. Что у нас верно? Что раз это z-блок,
[14:46.640 --> 14:56.280]  да, вот это вот, то у нас если здесь написано какая-то буква x, то вот здесь написано какая-то буква y.
[14:56.280 --> 15:07.560]  Потому что иначе мы продолжили бы вправо в этой точке. Согласны? Окей. Что теперь можно заметить?
[15:07.560 --> 15:14.400]  Что раз эти две строки побольше, они равны, которые одной душкой обозначены, значит здесь стоит x.
[15:14.400 --> 15:24.640]  Значит, здесь и здесь символы различаются. А из этого следует, что на самом деле здесь равенство.
[15:24.640 --> 15:34.240]  В этом случае. Окей, если с этим понятно, поехали ко второму случаю.
[15:34.240 --> 15:46.280]  Давай теперь вот эту штуку меньше либо равна чем z I-L. И рассмотрим тогда следующую картинку.
[15:46.280 --> 15:54.200]  Что это значит? Это значит, что мы выходим своим z-блоком вот сюда вот, за эту штуку.
[15:54.200 --> 16:02.320]  Согласны? Но логично тогда утверждаем, что мы будто бы выходим сюда, но мы же не знаем,
[16:02.320 --> 16:07.360]  что за r происходит вообще-то. Просто неизвестно. Мы туда никогда не заглядывали.
[16:07.360 --> 16:13.200]  Поэтому разумно обрубить z-функцию вот этим вот значением, потому что у вас здесь равенство есть.
[16:13.200 --> 16:22.120]  А что там дальше справа потом посчитать? Давайте напишем так, что тогда
[16:22.120 --> 16:46.840]  i-Lt v.r-L-1 равняется чему? То есть вот эта вот часть, то есть то, что если мы обрежем,
[16:46.840 --> 16:58.240]  она будет равняться вот этой вот s I-prt. Но это понятно почему. Потому что у нас есть
[16:58.240 --> 17:17.120]  равенство вот этих частей. Просто z-блок выходит аж сюда. Ну все. Что z I-T больше 1 чем r минус i плюс 1.
[17:17.120 --> 17:26.640]  Ну это просто разность, просто длина вот этой штуки. Ну все, доказали тогда утверждение.
[17:26.640 --> 17:36.200]  Окей, утверждение доказано, тогда алгоритм очень простой. Каждый раз давайте ставить,
[17:36.200 --> 17:44.840]  что z I-T, вот эта вот штука, минимум из двух. И дальше, если у нас вот это минимум, да, то есть
[17:44.840 --> 17:49.000]  вот это вот здесь минимум. То есть это вот выполняется. То мы просто будем говорить сразу вот так вот.
[17:49.000 --> 17:58.040]  Иначе, если верно вот это вот, то что мы будем делать? Будем говорить тогда, что z-функция в точке i равна
[17:58.040 --> 18:05.600]  длине вот этой вот оставшейся части. И дальше мы будем просто наивно сравнивать вот эти вот
[18:05.600 --> 18:13.280]  символы и вот эти вот символы. Вдруг можно продолжить z-блок? Ну все, алгоритм примерно такой.
[18:13.280 --> 18:22.360]  Да, ну я вас обманул. Мы не все рассмотрели, а вы появились на развод. Потому что вот это не всегда
[18:22.360 --> 18:28.800]  верно. Когда это может быть неверным? Когда у вас последнее значение z-функции z I-1 равно 0,
[18:28.800 --> 18:39.360]  и при этом у вас крайний z-блок заканчивается в z I-1. Поэтому если i не лежит в отрезке lr,
[18:39.360 --> 18:53.640]  то это возможно только в одном случае. То есть у вас был ваш l, вот ваш r, и вот ваши i. Это возможно
[18:53.640 --> 19:01.160]  только когда у вас l равно r и равно i-1. То есть у вас z-блок длины 0, начинающийся в позиции i-1.
[19:01.160 --> 19:08.440]  Только тогда это возможно. В этом случае мы будем поступать максимально интеллектуально и
[19:08.440 --> 19:17.000]  абсолютно то же самое, просто вайлом считать, сравнивать вот эти вот символы. Все, алгоритм очень
[19:17.000 --> 19:25.600]  интеллектуальный. Теперь давайте напишем псевдокодик быстренький, который объединит
[19:25.600 --> 19:49.000]  все три случая в короткую конструкцию и обрадуемся жизни. Сразу напоминаю
[19:49.000 --> 19:52.120]  псевдокод, поэтому здесь я могу написать ссылки, константности и прочее.
[19:52.120 --> 20:18.160]  Давайте сразу напишу, что модулез, и поехали так, for.
[20:18.160 --> 20:35.040]  Давайте подумаем, что если обозначить, что вот в этом случае, что у меня будет минимумом.
[20:35.040 --> 20:52.360]  Какое значение получится? То есть если i у меня равно r-1, то я получу здесь 0. Возможно,
[20:52.360 --> 20:59.400]  где-то набаговал на плюс-минус 1, поэтому я позволю себе переиграть всех и написать вот так.
[20:59.400 --> 21:18.760]  Вдруг там случайно отрицательное выйдет. Вот так вот. Это изначальное значение zi. Теперь я буду
[21:18.760 --> 21:24.800]  смотреть, что делать. Если у меня вот этот случай верен, то даже если запущу такой вайл,
[21:24.800 --> 21:31.160]  который идет вперед и отстранивает, он тут же оборвется. Если я запущу здесь вайл,
[21:31.160 --> 21:35.000]  то он почитает мне корректно. Если я запущу здесь вайл, то он тоже почитает мне корректно.
[21:35.000 --> 21:50.360]  Значит, я просто запущу вайл. Так, давайте. А ну база там как-нибудь или типа нулю задайте.
[21:50.360 --> 21:58.880]  Непринципиально как задавать, если честно, изначально. Надо, чтобы получилось не отрицательное.
[21:58.880 --> 22:10.880]  Вот так еще напишем. Так, теперь вайл i плюс zi меньше, чем модуль s. Это нам нужно,
[22:10.880 --> 22:35.880]  чтобы не вылететь за индексы при пересчете. Именно сайд почему? Ну давайте нули напишем.
[22:35.880 --> 22:47.040]  Это мелочи жизни. Теперь мы смотрим, правда ли, что у нас верно. Вот такие вот. Если да,
[22:47.040 --> 22:58.640]  то мы говорим плюс плюс zi. Ну и последнее, надо обновить lr.
[22:58.640 --> 23:25.880]  Мы говорим, что r равно i и z от i. l равно i. Ну здесь типа return z. Ну все. Очень интеллектуальный
[23:25.880 --> 23:31.880]  алгоритм на самом деле. Как бы расписывать его долго, понимать его еще хуже, кодом он такой
[23:31.880 --> 23:44.680]  коротенький. i плюс zi символ строки на позиции plus zi равен символу на позиции zi. То есть мы проверяем,
[23:44.680 --> 23:50.440]  правда ли, что вот этот вот, потом вот этот вот, потом вот этот вот. Или в этом случае это будет
[23:50.440 --> 23:58.120]  вот этот, потом вот этот, потом вот этот. А давайте теперь, как искать, собственно,
[23:58.120 --> 24:15.400]  вхождение паттернов текст. Вхождение паттернов текста очень просто. Вхождение ПС. Обозначим,
[24:15.400 --> 24:23.400]  что у нас есть строка S, вот такая вот интересная. Решетка T. Что это значит? Это значит, что решетка
[24:23.400 --> 24:29.320]  это какой-то разделитель, которого нет в алфавите. У вас строки состоят из символов. В символы
[24:29.320 --> 24:32.840]  принадлежат алфавиту. Возьмите какой-нибудь уникальный символ, который не лежит в алфавите.
[24:32.840 --> 24:43.000]  Но обычно говорят, что алфавит это от A до Z, решетка не лежит в алфавите от A до Z. Иначе там,
[24:43.000 --> 24:48.600]  ну не знаю, можно войти себе за решетки на самом деле, но там немножко неприятнее будет жить,
[24:48.600 --> 24:57.240]  поэтому проще с ней жить. Окей, так, вхождение ПФТ. С равно П-решетка T. Тогда строим
[24:57.240 --> 25:25.480]  ZS. Здесь строим Z-функция. Тогда P-решетка T на позиции И. И сейчас картинка для наглядности.
[25:25.480 --> 25:40.840]  Давайте здесь будет решетка стоять наша. Это будет P, это T. Вот, допустим, выбрал И. Тогда
[25:40.840 --> 25:47.680]  вхождение, это то же самое, что у меня вот здесь вот эти вот штуки совпадут. Логично? Ну, максимально
[25:47.680 --> 26:07.920]  логично. То есть я хочу сказать, что на позиции И, если ZИ-модуль П равен модуль П. Конец. Ну, и верну
[26:07.920 --> 26:14.080]  и в обратную сторону. Потому что у вас здесь равенство, потому что если знак меньше здесь,
[26:14.080 --> 26:18.400]  то ZИ-ПТ меньше, чем модуль П, то вхождение неполное, то есть входит какой-то лишь префикс.
[26:18.400 --> 26:24.360]  Если же, может ли выйти знак больше, знака больше быть не может, потому что у вас здесь решетка,
[26:24.360 --> 26:28.960]  которой нет в алхавите. Поэтому решетка, очевидно, в Т не входит, значит вы не можете хотя бы модуль П
[26:28.960 --> 26:39.400]  плюс один выбить значение. Ну и все. Не-не-не-не, почему? На позиции И имеется в виду в тексте Т,
[26:39.400 --> 26:49.840]  безотносительно этого куска. Почему нулевая? У вас берется И во всей строке. Ну да, у вас же будет
[26:49.840 --> 27:01.120]  одна большая строка, поэтому берете, может эта функция берется по строке С, поэтому так. Ну вот пересчет,
[27:01.120 --> 27:08.480]  и у нас модуль П будет примерно. Короче говоря, когда вы решаете задачи, вы просто напишете код,
[27:08.480 --> 27:13.400]  потом такие, блин, перевели позицию, учет на один, он включается во всех индексах в ответе,
[27:13.400 --> 27:18.000]  пойду-ка прибавлю один, или отниму один, и все. Примерно так решаются задачи на простроке.
[27:18.000 --> 27:31.240]  Вот. Окей. Что мы с вами не сделали? Мы с вами не доказали, что это работает за линию. Да? Что нам
[27:31.240 --> 27:34.920]  нужно для этого сделать? Нам нужно доказать, что этот алгоритм работает за линию. Если мы докажем,
[27:34.920 --> 27:47.160]  то это победа. Ну давайте сделаем вот как. Тумарно алгоритм определяется числом вайлов, да?
[27:47.160 --> 27:57.720]  Так, ну что можно здесь сказать? Что здесь хочется вкинуть? Какой-нибудь прикол типа
[27:57.720 --> 28:04.320]  «каждый символ рассмотрен лишь два раза, поэтому у Тумарной линия». Попробуем подробнее с этим
[28:04.320 --> 28:14.120]  разобраться. Так. И вот уже следующее, что каждый символ, давайте время работы,
[28:14.120 --> 28:40.920]  каждый символ просматривается не более двух раз. Да-да-да-да-да. Не более двух раз, вроде бы.
[28:40.920 --> 28:54.960]  Раз, пять, какие-то разы. Ну первое, это будто бы, когда я его прохожу в вайле, да? То есть что у
[28:54.960 --> 29:05.600]  меня происходит в этом случае? То есть нам нужно посчитать суммарное число итерации вайл. Ну,
[29:05.600 --> 29:21.080]  сейчас. Вайл выполняется только когда верно либо вот это, либо вот это, да? Если вот это,
[29:21.080 --> 29:28.040]  то у нас просто R напрямую сдвигается явно, и это посещение указателем R будет символа. Согласны?
[29:28.040 --> 29:47.680]  А второй случай, это вот этот. Тогда с ним что происходит? Да вроде то же самое. Ну будто бы,
[29:47.680 --> 29:55.040]  да. То есть каждый символ повещается не более двух раз, получается. Ну будто бы да, потому что вы
[29:55.040 --> 30:01.200]  выходите за R только либо в этом, либо в этом случае, а если вы находитесь внутри R, то есть вот этот
[30:01.200 --> 30:11.120]  кейс у вас вайл вообще не работает. Ну и все, будто бы это доказывает время работы. Потому что
[30:11.120 --> 30:25.640]  суммарно вайло всего линия. Давайте это обозначить uf3, чтобы можно было индексировать. Либо при выполнении
[30:25.640 --> 30:53.120]  в кубочках 2, либо при кубочках 3. Следовательно, суммарная итерация вайл
[30:53.120 --> 31:08.320]  не более, чем для длины строки. А еще у вас есть пыльная итерация вайла внешний for,
[31:08.320 --> 31:13.040]  который там тоже при не запуске вайла какие-то итерации вам накидывает. Но их тоже не более,
[31:13.040 --> 31:26.320]  чем длина строки, поэтому суммарно здесь не более 3 длины строки операций. Тогда время построения
[31:26.320 --> 31:42.560]  z функции. Вот длина строки. Откуда у вас следует в частности, что вот этот алгоритм,
[31:42.560 --> 31:50.080]  ось к обхождению всех паттернов текст, работает за линейное время от длины паттерна и текста. Ну все,
[31:50.080 --> 31:57.120]  самый сложный часть разобрали. Сейчас маленький перерывчик в виде хашей, потому что нелегкие.
[31:57.120 --> 32:14.240]  Динамиальное хаширование алгоритм Рабина Карпа.
[32:14.240 --> 32:39.640]  Так, ну сейчас будет немного страшно. Определим хэш от 0 по m-1.
[32:39.640 --> 32:55.320]  Так, сейчас самое страшное. Надо вспомнить, что именно из чего вы читаете.
[32:55.320 --> 33:23.000]  Итой на х в степени m-1-i по модулеку. То есть, что я говорю? Я рассматриваю строку как многочлен.
[33:23.000 --> 33:34.400]  Где у него вот есть иксы, есть вот эти пейты. Зачем мне это нужно? Это называется полинейный хэш,
[33:34.400 --> 33:41.800]  ну или роллинг хэш. Или хэш Рабина Карп, как хотите называть. Верно, зачем нам это нужно?
[33:41.800 --> 33:59.080]  Затем, что хэш от 0 по m-1, что это такое? Давайте распишем. Что? Q это число? Пока нет.
[33:59.080 --> 34:10.240]  Пока что любое, потом я скажу, как у х выбирать. Это минус. Минус 1, минус i.
[34:10.240 --> 34:39.200]  Согласно, я просто взял и расписал определение. Давайте теперь я сделаю вот как. Я хочу
[34:39.200 --> 34:55.880]  PM отдельно выяснить отсюда. При индексе равном m, что у меня будет? PM. Крупнее. Пм умножить на х в нулевой.
[34:55.880 --> 35:14.880]  Плюс сумма. Давайте я здесь напишу опять же так. P itx в степени m-i по модулю Q. Согласны?
[35:14.880 --> 35:19.200]  Ну вроде я просто ничего интеллектуального здесь не сделал. Я вынес м-то слагаемое.
[35:19.200 --> 35:34.440]  Кого? При i равном m у меня здесь 0. Х нулевой будет, поэтому он не нужен. Так,
[35:34.440 --> 35:42.080]  теперь остается привести это к классному виду. Вот это кто такой? И чем он отличается от этого?
[35:42.080 --> 35:51.640]  Тем, что у вас здесь есть m-1, а здесь m. Поэтому снова пишем PM и вынесу х один раз.
[35:51.640 --> 36:10.840]  Ну так это же мы знаем кто такой.
[36:21.640 --> 36:35.360]  Собственно, я ввел так интересный хэш, чтобы я мог считать хэш гораздо проще для следующего
[36:35.360 --> 36:41.000]  символа. Чтобы добавление одного символа мне хэш сильно не портило. Я мог его явно за 1 пересчитать.
[36:41.000 --> 36:48.120]  Так давайте теперь, грубо говоря, это первое утверждение будет или свойство его в некотором
[36:48.120 --> 36:55.560]  плане. Теперь второе свойство доказать. А именно как считать хэш произвольной подстроки? Давайте
[36:55.560 --> 37:10.040]  выводить хэш подстроки. Хочу хэш PLPR хочу. Ну давайте выпишем просто по определению. Так,
[37:10.040 --> 37:14.560]  можно я не буду писать везде mod-q, и будем считать, что мы по члену Q ведутся. Просто
[37:14.560 --> 37:35.440]  для экономии места. Так, P и ты. Теперь надо расписать это через страшные вещи. Давайте
[37:35.440 --> 38:05.200]  распишу это вот так вот. Да, R. Согласны, что это верно? Ну я просто взял, здесь все слагаемое,
[38:05.200 --> 38:19.720]  здесь вычил ненужное. Окей, так что теперь нужно сказать? Ну что вот это по формуле это просто
[38:19.720 --> 38:39.560]  хэш от P0 blah blah blah PLR ты. Сейчас PLR ты будет. Не, PLR плюс 1 получится. Потому что там-то у
[38:39.560 --> 38:48.400]  нас M-1-I, то есть я хочу, чтобы здесь-то у меня ходило. А, все, я туплю, sorry. Да.
[38:48.400 --> 38:58.400]  Хэш от P0 PLR. И теперь мне нужно понять, на какую степень здесь домножить,
[38:58.400 --> 39:11.080]  чтобы получить здесь L-1. Ну что здесь получить L-1, мне нужно взять и это превратить в домножить
[39:11.080 --> 39:38.320]  на х в степени L-R. Согласны? L-I только. R-R, да.
[39:38.320 --> 39:53.680]  Какая единичка? Зачем? А, ну мы хотим M-1 здесь еще, да. Вот. Подогнали, да. То есть это хэш,
[39:53.680 --> 40:20.080]  давайте напишу это на следующей строке. Минус. Во, получили формулу.
[40:23.680 --> 40:37.200]  Почему плюс 1? Здесь L-I минус 1. Минус 1. Я хочу по формуле подогнать по ту. А здесь R-L
[40:37.200 --> 40:44.160]  плюс 1, чтобы у меня склопилось в R-. Потом я просто выношу это сюда, потому что оно от и не зависит,
[40:44.160 --> 40:50.320]  и получаю просто по окрению хэш. И того, что мы с вами получили, что если я знаю хэши для всех
[40:50.320 --> 40:56.360]  префиксов, то я знаю хэш любоподстроки быстро достаточно. То есть что я могу сделать? Я могу
[40:56.360 --> 41:02.000]  начать, во-первых, хэши всех префиксов, причем за линию используя вот эту рекурренту, так называемую,
[41:02.000 --> 41:10.280]  и сразу начать все иксы во всех степенях. Потому что эта штука, она не больше, чем для нас строки,
[41:10.280 --> 41:17.520]  очевидно. Ну и все, и тогда вы можете просто брать нужные вам штуки. То есть как искать хэш под
[41:17.520 --> 41:23.400]  строки? Хэш под строки ищется очень просто, вот так вот, по этой формуле. То есть научились.
[41:23.400 --> 41:48.560]  Р. Это R. Но мы искали от LDR, зная все h, i, t, p, i, t за от единички.
[41:48.560 --> 42:09.400]  Находим h от p, l, r. То есть мы умеем находить, мы не будем их искать сейчас, но мы умеем
[42:09.400 --> 42:16.720]  их находить. Как теперь работать в алгоритме Rabinocarp, собственно? Алгоритм Rabinocarp устроен
[42:16.720 --> 42:24.880]  очень просто. Давайте посчитаем хэш паттерна и потом пойдем скользящим окном считать хэш под
[42:24.880 --> 42:33.320]  срок соответствующей длины. Если не равны, то вхождения точно нет. Если равны, то надо проверять
[42:33.320 --> 42:40.360]  наивно, просто в тупую сравнивать. Удержается, что в среднем будет линия. Почему это так? Потому
[42:40.360 --> 42:44.760]  что здесь нужно рассматривать. Ему равна вероятность того, что у вас здесь есть совпадение.
[42:44.760 --> 42:59.200]  И здесь нужно сказать следующее утверждение. Точнее, как мы убираем qx? q – простое, x – случайное,
[42:59.200 --> 43:14.400]  в таком вот множестве. Давайте от двойки хотя бы брать. Потому что x равны нулю бессмысленно,
[43:14.400 --> 43:19.520]  x равны единице, плюс-минус тоже. А вот x равен двойке уже имеет смысл. То есть убирать
[43:19.520 --> 43:27.560]  какой-то случайный за этих чисел. Что делается дальше? Дальше рассматривается вероятность того,
[43:27.560 --> 43:33.960]  что h от x равно h от y, где x и y – разные сроки. И показывается, что она у вас не превосходит,
[43:33.960 --> 43:41.720]  что она равна, меньше либо равна, чем 1 делить на размер вот этого множества. Потеряем без зуб,
[43:41.720 --> 43:48.400]  чтобы у вас коллизия произошла, вам необходимо, чтобы у вас там последние члены совпали. Вот.
[43:48.400 --> 43:57.400]  q – 1. Ну, вы равны q, не будьте врать, вы будете считать все по модулю q. Да, здесь везде по
[43:57.400 --> 44:03.440]  модулю q, если что вычтения берутся. То есть берется x типа r-r-1 по модулю q. Эта штука по
[44:03.440 --> 44:09.960]  модулю q. Перемножаются они по модулю q. Всем из этого вычитают этот и снова берут по модулю q.
[44:09.960 --> 44:15.520]  Если все арифметика модульная, то это будет классно, если вы напишете в ревью класс модульной
[44:15.520 --> 44:24.200]  арифметики, чтобы было проще жить. Заодно задавать туда простое число в compile-time проверять его,
[44:24.200 --> 44:30.360]  что у вас поле и что вы умеете в нем делить. Иначе, если это непростое число, обрубать
[44:30.360 --> 44:39.400]  оператор деления в нем. Ну, это так. Задачка node3 по плюсам. Если что, не шучу, это на комиссии была
[44:39.400 --> 44:48.880]  задача в первом семестре у Мещерина. Там нужно было написать кольцо многощенов над полем. Ну,
[44:48.880 --> 44:53.680]  над кольцом. Если это поле, то их можно делить. Ну, самоделение надо было реализовывать.
[44:53.680 --> 45:09.640]  zp от x, если у вас есть keep, значит это такое. Compile-time. Так, окей. Понятно,
[45:09.640 --> 45:16.440]  как алгоритма Rabinokarp работает. Вот, и выясняется, что если возьмете... короче, выясняется,
[45:16.440 --> 45:24.600]  что вероятность коллизии... а, у нас были хэши, вы знаете, что такое коллизия. Коллизии
[45:24.600 --> 45:46.160]  не превосходит 1 делить на q-3. Вот, это bd, если что. Вероятность. Ну,
[45:46.200 --> 46:00.080]  дайте я напишу здесь нормально, тут совсем все плохо. ABD. Ну, тогда что остается взять?
[46:00.080 --> 46:09.200]  Сколько подстроек мы перебираем в тексте длины паттерна? Ну, худшая оценка порядка длины текста.
[46:09.200 --> 46:30.320]  Тогда при q больше, чем квадрат длины текста, вероятность хотя бы одной коллизии
[46:30.320 --> 46:43.760]  не превосходит 1 делить на q. А если у вас вероятность длины коллизии не превосходит 1 делить на q,
[46:43.760 --> 46:50.200]  то у вас в целом все прекрасно. Потому что можно по неравенству марково оценить
[46:50.200 --> 46:57.320]  ожидание числа коллизий, и оно там будет меньше одного, короче. Вот. У вас будет меньше,
[46:57.320 --> 47:04.320]  чем одна коллизия в среднем. Поэтому у вас среднее время работы выходит, что у вас очень мало
[47:04.320 --> 47:09.280]  раз придется наивно проверять полностью все строки, всю длину строки, и все будет хорошо.
[47:09.280 --> 47:17.880]  Поэтому в среднем тоже линия получается. Вот, окей. С этим справились, да? Да, это не сложно
[47:17.880 --> 47:22.600]  доказать самому на самом деле. Ну, вы берете, расписываете, что у вас две разные строки,
[47:22.600 --> 47:29.040]  и они многощенно от них равны по модулю q. Берете тогда разность по модулю q равна нулю,
[47:29.040 --> 47:34.560]  ну и смотрите, когда у вас разность равна нулю, просто-напросто. Вы выносите там, получается,
[47:34.560 --> 47:43.680]  у вас будет выноситься этот. Сейчас я скажу, что именно. Ну, у вас x берется одинаковый,
[47:43.680 --> 47:50.360]  поэтому везде выносится x-вытый, и берется разность коэффициентов везде. Ну, и чтобы
[47:50.360 --> 47:54.360]  оно там где-то обнулялось, у вас получится примерно один дель на q. Ну, один дель на мощность
[47:54.360 --> 48:03.800]  этого множества. Собственно, это верно только в поле, поэтому q простое. Более того,
[48:03.800 --> 48:08.240]  вам же нужно брать q достаточно большое, поэтому вы заранее фиксируете большое q,
[48:08.240 --> 48:19.160]  да, простое и больше, чем квадрат длины текста. Сразу спойлер, есть такое классное число. По-моему,
[48:19.160 --> 48:27.080]  оно выглядит вот так вот. Вот, по-моему, оно простое. И VDA 63-1 простое, и VDA 64-1 простое.
[48:27.080 --> 48:38.600]  Нет, просто, оно просто простое. Ну, можно явно проверить, но утверждается, что простое. По-моему,
[48:38.600 --> 48:45.400]  числа мерсена они называются или что-то такое. Кстати, скажу сразу, вместо x очень плохо брать
[48:45.400 --> 48:53.520]  двойку, потому что существуют контратесты под двойку, очень легко строятся. Называются строки
[48:53.520 --> 48:59.280]  TOE-MORSE. Это такие забавные строки, в которых у вас очень много коллизий будет, если x равен двойке.
[48:59.280 --> 49:07.440]  Ну и в целом здесь важно про хэши понимать следующее, что если некий злоумышленник знает ваш х и знает
[49:07.440 --> 49:13.120]  ваш q, то он очень легко построит, ну не очень легко, но построит контратест, вот так вот скажем.
[49:13.120 --> 49:20.440]  То есть, есть алгоритм нормального, плюс-минус адекватного построения контратеста, если вы знаете q и x.
[49:20.440 --> 49:28.680]  Поэтому, если у вас задача не заходит хэши, вы должны будете попробовать поменять просто x и q и
[49:28.680 --> 49:34.560]  понять, что теперь заходит. Просто антихэш-тест у автора под эти параметры есть, а под другие нет.
[49:34.560 --> 49:40.560]  И из-за того, что x и q можно выбирать достаточно многими способами, все-таки простых много
[49:40.560 --> 49:50.720]  достаточно чисел, а x чуть побольше, чуть-чуть совсем. Вот, тогда пар еще чуть побольше, а тестов все-таки
[49:50.720 --> 49:56.000]  поменьше. Как бы очень интеллектуальная оценка, тысячи тестов у вас не будет задача.
[49:56.000 --> 50:06.840]  Нет, вы зафиксировали q. У вас q фиксирован.
[50:06.840 --> 50:20.760]  Нет, вы зафиксировали q какое-то. Большое, да.
[50:20.760 --> 50:29.800]  Ну, если вы зафиксировали и вы зафиксировали x, вот. Тогда у вас для двух строк вероятность
[50:29.800 --> 50:35.520]  коллизии вот такая вот, для двух случайных строк. Ну да, при любом фиксируемом.
[50:35.520 --> 50:41.120]  То есть многочлен тут рассматривается. Ну, на вики, по-моему, нет доказательства строгого.
[50:41.120 --> 50:44.320]  Там вроде была ссылка на статью, где это оказывается нормально.
[50:44.320 --> 50:49.200]  В крайнем случае там указан автор этого хэша, и там у него точно можно найти доказательство.
[50:49.200 --> 50:54.320]  Так, все, третий способ. Это префикс-функция.
[50:54.320 --> 51:09.160]  Про что префикс-функция у нас? Мы, так, покукарекали про время.
[51:09.160 --> 51:13.200]  Ну, смотрите, я доказал, что вероятность коллизии хотя бы меньше, чем один делец на q.
[51:13.200 --> 51:21.560]  Окей. Тогда, значит, у меня, грубо говоря, коллизии нет. Так что я делаю? Я просто беру свой текст,
[51:21.560 --> 51:30.160]  беру паттерн и просто везде его прикладываю. Так как я считаю сначала префиксные хэши для всех,
[51:30.160 --> 51:36.160]  тогда для текста я знаю хэш любого строки золоть единицы. Ну все. Коллизии при этом мало.
[51:36.160 --> 51:45.800]  Обычно в задачах, когда пишут хэши, это именно немножко такой практический момент в плане
[51:45.800 --> 51:51.880]  спорт-проги всякой и всяких олимпиадок и контестов. Никто не пишет здесь проверку явно за линию.
[51:51.880 --> 52:02.000]  Если не заходит, все просто меняют параметры q и x, пока не зайдет. Все, примерно так. Вот.
[52:02.000 --> 52:12.800]  Никто не сравнивает, да. Вам хорошему надо проверять. Ну, более чем по-хорошему,
[52:12.800 --> 52:18.360]  нужно изучить просто нормальные алгоритмы и не пользоваться хэшами. Но иногда они вам пригодятся,
[52:18.360 --> 52:23.920]  потому что эти хэши можно обобщать на двумерный и трехмерный случаи, в частности. Но об этом на
[52:23.920 --> 52:33.040]  семинаре поговорите. Так, префикс функции. Кто это такой? Ну, матрица, фотография. Вы хотите
[52:33.040 --> 52:45.240]  найти прогресс фотографии? Фотография. 3D фотография. Ну, в смысле? Ну, я не знаю. Не особо важно.
[52:45.240 --> 52:53.080]  Важно то, что это можно сделать просто. Если вам интересно, зачем, то я отсылаю вас к литературе.
[52:53.080 --> 53:03.680]  Я не знаю такой литературе. Так, кто такой PS от И? Префикс функции обозначается буквой P.
[53:03.680 --> 53:10.480]  Максимальная K такое, что...
[53:23.080 --> 53:32.480]  Вот такая вот картинка будет. Так, это картинка, теперь формула.
[53:32.480 --> 53:46.880]  Вот наша строка S. Так, вот наша точка I. Тогда у нас должно быть равенство вот таких вот тук.
[53:46.880 --> 54:04.160]  Вот это вот. Это K. Это I минус K плюс 1. Вот. Ещё мы хотим махтивно участвовать в эту штуку.
[54:04.160 --> 54:11.840]  План у нас простой. Определить, что такое su prefix. Определяем.
[55:05.040 --> 55:12.840]  Супрефикс на строке S называется под строка P. Такая, что она одновременно и префикс, и суфикс. Очень интеллектуально.
[55:12.840 --> 55:36.520]  Можно переписать тогда определение. PS от И. Это длина максимального su-префикса U S.
[55:36.520 --> 55:48.200]  Вот так вот можно писать. То есть можно писать либо через индекс, либо через su-префикс, это понимать.
[55:48.200 --> 55:50.200]  Придётся проникнуть с картинкой.
[55:50.200 --> 56:07.480]  Вот наша строка S. Всё. И допустим я знаю, что вот это вот её su-префикс. Давайте его подлиннее нарисую.
[56:07.480 --> 56:16.280]  Вот это её su-префикс. То есть вот эта штука равна этой штуке.
[56:16.360 --> 56:21.560]  Как устроим второй подлиннее su-префикс?
[56:29.560 --> 56:39.560]  Заметьте, что если у вас эта штука равна этой штуке, то у вас что получится?
[56:39.560 --> 56:45.560]  Вот у вас второй по длине su-префикс. Вот такая вот штука.
[56:45.560 --> 56:55.560]  Вот так эти две штуки равны. То есть у вас равенство всех четырёх подстрок наблюдается.
[56:55.560 --> 57:03.560]  Почему? Допустим это su-префикс строки, вторая положенность.
[57:03.560 --> 57:09.560]  Тогда он равен вот этой штуке. Но вся эта штука равна всей этой штуке.
[57:09.560 --> 57:13.560]  Поэтому эта равна этой, а эта равна вот этой.
[57:13.560 --> 57:33.560]  То есть su-префиксы позиции И имеют вид.
[57:33.560 --> 57:41.560]  Первый su-префикс это максимальный по вложенности. Мы определили его как префикс функция.
[57:41.560 --> 57:53.560]  Согласны? Ну просто по определению. И вот первый su-префикс.
[57:53.560 --> 58:01.560]  Второй su-префикс в силу того, что мы определили, что здесь и здесь равенство, он равен su-префиксу вот этой штуке.
[58:01.560 --> 58:09.560]  То есть su-префикс. Второй su-префикс это максимальный по вложенности su-префикс первого префикса.
[58:09.560 --> 58:35.560]  То есть это вот этого штука. То есть максимальный su-префикс вот этой вот строке.
[58:35.560 --> 58:41.560]  Кто подскажет третий su-префикс?
[58:41.560 --> 58:49.560]  Да, именно так. То есть они устроены вот таким вот интересным образом. Все su-префиксы.
[58:49.560 --> 58:55.560]  Вот. Ну вы еще можете сказать, что вся строка это su-префикс.
[58:55.560 --> 59:01.560]  Это будет правдой. Но однако мы будем рассматривать не собственные su-префиксы, то есть не равные всей строке.
[59:01.560 --> 59:07.560]  Поэтому вот так вот. Собственно алгоритма очень простой построение тогда префикс-функции.
[59:07.560 --> 59:17.560]  Он устроен так, что вы будете считать также для очередной и этой позиции и просто пересчитывать, когда у вас символы совпадут с следующими из одними.
[59:17.560 --> 59:25.560]  Поясню сейчас, что я имею в виду. То есть допустим я посчитал для первых и позиции и хочу посчитать для и плюс первой.
[59:25.560 --> 59:31.560]  Давайте вот так вот. Для первых и минус один посчитал, хочу длительный посчитать.
[59:31.560 --> 59:41.560]  Случай первый. Это какой? Что я могу продолжить текущий su-префикс на единичку?
[59:41.560 --> 59:49.560]  Да? Могу же так сделать?
[59:49.560 --> 59:59.560]  Когда это будет верно? Тогда когда у нас вот это равно вот этой и вот этот и ты символ равен вот этому символу.
[59:59.560 --> 01:00:13.560]  Держи и минус один, потому что мы переписали. То есть если у нас верно, что s и ты равен s вот
[01:00:13.560 --> 01:00:27.560]  Вот такой вот штуки. То есть этот символ совпадает вот с этим. То есть это x, это x какой-то.
[01:00:27.560 --> 01:00:39.560]  Ну тогда просто-напросто.
[01:00:39.560 --> 01:00:45.560]  Плюс один. Просто уличаем на единичку.
[01:00:45.560 --> 01:00:51.560]  Второй случай. Это когда-то неверно. Что тогда мы должны сделать?
[01:00:51.560 --> 01:00:57.560]  Тогда как мы можем продолжить так, чтобы остаться su-префиксом? Мы просто должны перебрать все su-префиксы меньше длины.
[01:00:57.560 --> 01:01:01.560]  Если мы какой-то из них смогли продолжить, то это победа.
[01:01:01.560 --> 01:01:07.560]  То есть если я не смог продолжить вот этот большой, то вдруг я смогу поменьше продолжить?
[01:01:07.560 --> 01:01:13.560]  Тогда я должен смотреть здесь и вот. То есть допустим здесь y, а вот здесь вот x.
[01:01:13.560 --> 01:01:17.560]  Ну я тогда же могу продолжить на один просто su-префикс чуть поменьше.
[01:01:17.560 --> 01:01:23.560]  Но эти другие строки мне не нужно рассматривать. Почему? Потому что они su-префиксами не являются.
[01:01:23.560 --> 01:01:29.560]  А если у вас вот эти части не являются su-префиксами, то у вас и расширенные на один su-префикс не являются.
[01:01:29.560 --> 01:01:35.560]  То есть поэтому это единственный кандидат, который надо перебрать.
[01:01:35.560 --> 01:01:55.560]  Ну что, y, p, s от i минус 1.
[01:01:55.560 --> 01:02:05.560]  S от i, s от i минус 1, плюс 1.
[01:02:05.560 --> 01:02:17.560]  Не равно s и тому.
[01:02:17.560 --> 01:02:33.560]  И при этом i.
[01:02:33.560 --> 01:02:39.560]  Вот так вот.
[01:02:39.560 --> 01:02:42.560]  Нет.
[01:02:42.560 --> 01:02:47.560]  Я хочу просто перебрать все su-префиксы.
[01:02:47.560 --> 01:02:53.560]  Ну давайте так я кодом пока напишу. Потом поправим чуть условия, чтобы у нас здесь нигде выход за границей не прилетал.
[01:02:53.560 --> 01:02:56.560]  Потому что мы же не можем бесконечно их перебирать.
[01:02:56.560 --> 01:03:02.560]  То есть мы закончим перебирать, когда у вас p, s от i минус 1 равно 0 просто.
[01:03:02.560 --> 01:03:20.560]  Вот эта штука она равно 0. Вы закончите перебирать.
[01:03:20.560 --> 01:03:30.560]  Кого?
[01:03:30.560 --> 01:03:40.560]  Нет, вы хотите проверить, что у вас вы перебираете все su-префиксы уменьшающиеся, то есть у них вот такие вот индексы будут.
[01:03:40.560 --> 01:03:49.560]  Вот это их длина.
[01:03:49.560 --> 01:03:53.560]  Зачем?
[01:03:53.560 --> 01:04:01.560]  Я не пишу код, я пишу просто певдокодом то, что мы перебираем их все. Код сейчас будет.
[01:04:01.560 --> 01:04:06.560]  Ну действительно. Мы же хотим продолжить su-префикс только.
[01:04:06.560 --> 01:04:11.560]  Ну в прямом.
[01:04:11.560 --> 01:04:18.560]  Потому что я ничего не написал.
[01:04:18.560 --> 01:04:25.560]  И не собираюсь дописывать.
[01:04:25.560 --> 01:04:29.560]  Ну в смысле, я здесь написал просто перебор. Я не написал, что буду дальше делать.
[01:04:29.560 --> 01:04:36.560]  Почему? Потому что могу.
[01:04:36.560 --> 01:04:43.560]  Я сейчас напишу полный.
[01:04:43.560 --> 01:04:48.560]  Я же сказал, что мы это не учитываем.
[01:04:48.560 --> 01:04:53.560]  Что?
[01:04:53.560 --> 01:05:02.560]  Ну да. Если у вас строка из всех ашек, то мы учитываем длинную строку минус 1.
[01:05:02.560 --> 01:05:07.560]  Если у вас верно это, то вы делаете вот так вот. Иначе вы делаете это, когда у вас закончился.
[01:05:07.560 --> 01:05:16.560]  Ну окей, хорошо. Здесь надо сказать, что k равно i, перебирать по k. Затем сказать, что k это значение, что перификс функции в точке i равно k плюс 1.
[01:05:16.560 --> 01:05:23.560]  И вот теперь вы поймете. Но мне лень. На текущий момент.
[01:05:23.560 --> 01:05:36.560]  Я напишу словами. То есть перебираемся все супрификсы. Все супрификсы.
[01:05:36.560 --> 01:05:51.560]  И пытаемся их продолжить.
[01:05:51.560 --> 01:05:56.560]  Вот. Теперь код.
[01:05:56.560 --> 01:06:03.560]  Который вы конечно нигде не найдете.
[01:06:03.560 --> 01:06:10.560]  И в нем найдете. И в нем найдете. И на ВИК-конспектах найдете. И на ИМАКСе найдете. Везде найдете.
[01:06:10.560 --> 01:06:28.560]  По-моему только в Корване не найдете. Потому что в Корване строк почти нет.
[01:06:28.560 --> 01:06:40.560]  Ну что? Укнута не знаю. Я знаю, что есть книга Гасфилда классная.
[01:06:40.560 --> 01:06:48.560]  Вот можете книгу Гасфилда почитать. Там про строки много. Вектор int p. Наша перификс функция.
[01:06:48.560 --> 01:07:03.560]  Давайте теперь говорить, что...
[01:07:03.560 --> 01:07:08.560]  Теперь мы допустим знаем все, что до it построено.
[01:07:08.560 --> 01:07:12.560]  Что будем делать?
[01:07:12.560 --> 01:07:20.560]  Ну первый случай. На самом деле понятно, что можно просто вайлом рассмотреть все эти случаи и все.
[01:07:20.560 --> 01:07:25.560]  Они вложены друг в друга.
[01:07:25.560 --> 01:07:31.560]  Поэтому я здесь сижу сразу себе, что int k равно...
[01:07:31.560 --> 01:07:36.560]  Ой, p, извините.
[01:07:36.560 --> 01:07:39.560]  p, s.
[01:07:39.560 --> 01:07:44.560]  Так, p, it.
[01:07:44.560 --> 01:07:51.560]  Вроде бы так, да? Перебираем, что k равно p и минус 1 только, наверное.
[01:07:51.560 --> 01:07:54.560]  Вот это текущее значение перификс функции.
[01:07:54.560 --> 01:08:04.560]  И теперь мы будем просто вайлом смотреть, можем ли мы продлить наш текущий значение перификс функции.
[01:08:04.560 --> 01:08:08.560]  То есть вайл k больше 0.
[01:08:08.560 --> 01:08:18.560]  И...
[01:08:18.560 --> 01:08:22.560]  s, it не равен.
[01:08:22.560 --> 01:08:29.560]  s, k?
[01:08:29.560 --> 01:08:43.560]  Я буду говорить, что k.
[01:08:43.560 --> 01:08:48.560]  Теперь я смотрю, что если у меня k будет больше 0.
[01:08:48.560 --> 01:08:56.560]  Так, сейчас. Здесь k-1 будет.
[01:08:56.560 --> 01:09:02.560]  И теперь давайте осмотреть, что если я все-таки пришел к успеху, то есть у меня s, it оказался равен s, k.
[01:09:02.560 --> 01:09:05.560]  То что тогда у меня получается?
[01:09:05.560 --> 01:09:12.560]  Тогда я делаю плюс плюс k. То есть увеличиваю на единичку все-таки это значение.
[01:09:12.560 --> 01:09:28.560]  Что если s, it...
[01:09:28.560 --> 01:09:32.560]  Ой, мы последние, здесь нужно писать p, it...
[01:09:32.560 --> 01:09:35.560]  равнул k. Ну, все, это конец.
[01:09:35.560 --> 01:09:44.560]  Здесь осталось фигуными сковками закрывать.
[01:09:44.560 --> 01:09:46.560]  Здесь?
[01:09:46.560 --> 01:09:53.560]  k, it и k.
[01:09:53.560 --> 01:09:57.560]  Если что, первая ряд свободен.
[01:09:57.560 --> 01:10:04.560]  Я бы не сказал.
[01:10:04.560 --> 01:10:10.560]  Ну, тогда доски хватает на два предложения.
[01:10:10.560 --> 01:10:13.560]  Ну, все, мы научились... так, теперь мы научились вам строить p-функции.
[01:10:13.560 --> 01:10:18.560]  Давайте поймем, за сколько эта алгоритма работает.
[01:10:18.560 --> 01:10:21.560]  Ровно столько, сколько у нас страции вайла.
[01:10:21.560 --> 01:10:23.560]  Верно?
[01:10:23.560 --> 01:10:25.560]  Ну и сколько их?
[01:10:25.560 --> 01:10:27.560]  Да.
[01:10:27.560 --> 01:10:30.560]  А доказать можете?
[01:10:30.560 --> 01:10:33.560]  Ну, у вас, короче, смотрите, доказать есть следующее,
[01:10:33.560 --> 01:10:37.560]  что суммарное количество увеличений, вот это вот,
[01:10:37.560 --> 01:10:41.560]  их не больше, чем длина строки штук.
[01:10:41.560 --> 01:10:46.560]  Каждая итерация вайла только уменьшает.
[01:10:46.560 --> 01:10:50.560]  Поэтому суммарно, причем уменьшает хотя бы на один.
[01:10:50.560 --> 01:10:53.560]  И пока не ноль.
[01:10:53.560 --> 01:10:56.560]  Поэтому суммарно, может, у вайла не более, чем две длины строки,
[01:10:56.560 --> 01:10:58.560]  но с один итерацией.
[01:10:58.560 --> 01:11:01.560]  Потому что каждая итерация уменьшает на один.
[01:11:01.560 --> 01:11:05.560]  То есть за каждую итерацию мы увеличиваемся либо на один,
[01:11:05.560 --> 01:11:08.560]  либо на ноль, либо вообще уменьшаемся.
[01:11:08.560 --> 01:11:13.560]  Вот так вот.
[01:11:13.560 --> 01:11:17.560]  Что k? k определяется снаружи вайла.
[01:11:17.560 --> 01:11:19.560]  То есть k это текущие значения префикс-функции,
[01:11:19.560 --> 01:11:22.560]  мы перебираемся у префикса просто-напросто.
[01:11:22.560 --> 01:11:29.560]  А k отвечает за вот этот перебор по ним.
[01:11:29.560 --> 01:11:32.560]  Так, окей, что тогда?
[01:11:32.560 --> 01:11:35.560]  Время работы так обосновали.
[01:11:35.560 --> 01:11:40.560]  Тогда остается последнее, это как искать подстроку в строке с помощью этой штуки.
[01:11:40.560 --> 01:11:47.560]  Ну да, пишем паттернешь фоткотекст и перебираем индексы нужные.
[01:11:47.560 --> 01:11:52.560]  И вот эта штука с префикс-функцией называется алгоритм-кнута Мориса Прата.
[01:11:52.560 --> 01:12:08.560]  Алгоритм-кнута Мориса Прата.
[01:12:08.560 --> 01:12:10.560]  Шаг первый.
[01:12:10.560 --> 01:12:13.560]  s равно p пишет kt.
[01:12:13.560 --> 01:12:14.560]  Шаг второй.
[01:12:14.560 --> 01:12:19.560]  Строим p, s.
[01:12:19.560 --> 01:12:25.560]  Смотрим на картинку.
[01:12:25.560 --> 01:12:30.560]  Тогда в хождении есть позиции i.
[01:12:30.560 --> 01:12:34.560]  Есть у нас равные вот такие вот штуки.
[01:12:34.560 --> 01:12:38.560]  То есть здесь у нас позиции i.
[01:12:38.560 --> 01:12:42.560]  И т.д.
[01:12:42.560 --> 01:12:46.560]  Равен длине паттерна.
[01:12:46.560 --> 01:12:59.560]  Тогда это только тогда, когда у вас есть хождение p в тв в вот таком вот индексе.
[01:12:59.560 --> 01:13:04.560]  Ой, два модуля p.
[01:13:04.560 --> 01:13:06.560]  Почему минус два модуля p?
[01:13:06.560 --> 01:13:10.560]  Во-первых, вам нужно вычислить вот эту вот штуку.
[01:13:10.560 --> 01:13:13.560]  Во-вторых, еще у вас вот эта штука вычитается один раз.
[01:13:13.560 --> 01:13:19.560]  Поэтому в системе отсчета на токе текста у вас хождение вот здесь вот.
[01:13:19.560 --> 01:13:26.560]  Это i минус длина паттерна и минус еще вот эта штука будет.
[01:13:26.560 --> 01:13:31.560]  То есть снова за линию нашли все хождения.
[01:13:31.560 --> 01:13:33.560]  А, ну у нас лекция как раз закончилась.
[01:13:33.560 --> 01:13:35.560]  Ну все тогда, всем пока.
