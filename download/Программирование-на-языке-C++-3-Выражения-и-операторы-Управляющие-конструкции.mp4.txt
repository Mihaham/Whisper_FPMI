[00:00.000 --> 00:11.180]  Так, у нас третья лекция сегодня. Мы начнём... Мы в прошлый раз уже начали говорить про
[00:11.180 --> 00:18.000]  операторы и выражения, и сегодня мы продолжим, наверное, большую часть лекций мы будем говорить
[00:18.000 --> 00:32.400]  про них. Вот, я вам сказал, что в программе... Программа, так сказать, исполняемый код на C++
[00:32.400 --> 00:44.480]  state of statement. Statements бывают declaration, то есть можно что-то объявить, бывают expression,
[00:48.480 --> 01:00.840]  а бывают так называемые control statements. Вот, в прошлый раз мы обсуждали declarations и, вроде как,
[01:00.840 --> 01:09.720]  их обсудили, и в этот раз мы предполагаем, что мы обсудим вот эти две вещи. Так вот,
[01:09.720 --> 01:28.360]  параграф 1.4 expressions and operators. Я уже начал говорить, что выражение неформально — это просто
[01:28.360 --> 01:38.800]  набор переменных и литералов, соединённых операторами и скобками, и первый вид самый простой операторов — это
[01:38.800 --> 01:46.480]  арифметические операторы, да, плюс-минус умножить разделить процент. Вот, ну, к арифметическим
[01:46.480 --> 02:01.840]  операторам, наверное, можно ещё отнести... Значит... Наверное, честно говоря, больше никаких
[02:01.840 --> 02:10.160]  им нельзя отнести. Вот, арифметические операторы, наверное, я их в строчку запишу, это просто вот
[02:10.160 --> 02:14.920]  эти пять арифметических действий. Вот, кстати, в прошлый раз кто-то подходил, задавал вопрос,
[02:14.920 --> 02:22.560]  давайте я это для всех скажу, что если вы делаете, если вы выполняете арифметический оператор над
[02:22.560 --> 02:27.640]  какими-то вещами двух разных типов, то они сначала должны перевестись к одинаковому. Например,
[02:27.640 --> 02:41.120]  если вы делите 5 на 3, то это будет 1, потому что вы вызываете деление над типом int и int,
[02:41.120 --> 02:47.800]  и результат снова int. Но если вы сделаете 5 делённое на 3.0, то это уже вызываете деление int на
[02:47.800 --> 02:59.080]  double, и поэтому левый int поднимается до double, и получается у вас 1,666667. Вот, имейте это в
[02:59.080 --> 03:04.920]  виду, это не совсем как в питоне работает. Вот, и оператора вот такого у вас нет. Вот это вот означает
[03:04.920 --> 03:18.920]  комментарий. Хорошо. Дальше побитые операторы, bitwise operators. Значит, что это такое? Ну, это
[03:18.920 --> 03:27.160]  побитые i, побитые i или побитые xor. Ну, я думаю, тоже не надо пояснять, как они работают. Бьём
[03:27.160 --> 03:32.280]  биты, побитые, делаем над ними соответствующую операцию. Вот, они определены над целыми числами,
[03:32.280 --> 03:37.680]  над дробными, по-моему, не определены. Вот, ещё есть побитые сдвиги. Сдвиг влево и сдвиг вправо.
[03:37.680 --> 03:43.960]  Вот про этот оператор и про этот оператор стоит отдельно сказать, что для целых чисел они работают
[03:43.960 --> 03:50.600]  как побитые сдвиги, а для некоторых других типов они работают особенно. Например, если левый
[03:50.600 --> 03:58.000]  аргумент это c in, c out, то эти операторы, если левый аргумент у них поток, то вот этот оператор
[03:58.000 --> 04:02.760]  действует как вывод в поток, а этот действует как ввод из потока. То есть, на самом деле,
[04:02.760 --> 04:09.240]  ещё раз напоминаю, что вот то выражение c out влево-влево, какой-то x, это на самом деле вызов
[04:09.240 --> 04:15.600]  оператора от левого аргумента c out, который имеет тип OStream, и правого аргумента int. И он действует
[04:15.600 --> 04:23.600]  иначе для таких типов аргументов. Так, что-то я русскими буквами начал нумеровать. А на интах,
[04:23.600 --> 04:31.560]  что вот эти операторы делают, которые сдвигают? У тебя есть битовое представление числа. Ты
[04:31.560 --> 04:38.520]  берешь биты и сдвигаешь влево, а заполняешь освободившееся место нулями. Например, я могу
[04:38.520 --> 04:47.480]  тройку сдвинуть влево на 2, и это всё равно, что умножить на 4. Получится 12. Да, но тройка – это
[04:47.480 --> 04:54.520]  вот такое число в двоичной системе, а я сделаю вот так. Тут нули, а я вот так сделаю. Это будет
[04:54.520 --> 05:00.120]  побитый сдвиг на 2. Аналогично вправо я могу сдвигать, тем самым я буду убивать значащие разряды.
[05:00.120 --> 05:13.720]  Такие вот операции. Дальше операторы сравнения. С ними тоже, наверное, всё понятно.
[05:13.720 --> 05:26.240]  Comparison operators. Значит, что это такое? Это вот такое равенство, неравенство, меньше, больше,
[05:26.240 --> 05:34.640]  меньше ли равно, больше ли равно. Опять понятно, как они действуют над интами. Опять-таки, если вы
[05:34.640 --> 05:39.200]  вызываете их над разными аргументами, аргументами разных типов, то эти аргументы приводятся к
[05:39.200 --> 05:47.360]  единому типу сначала по правилам приведения типов. Если вы через равно-равно или неравно пытаетесь
[05:47.360 --> 05:54.120]  сравнивать флоат, и будьте аккуратны, флоаты или даблы у вас могут быть из-за точности. Один и тот
[05:54.120 --> 06:00.400]  же флоат может быть закодирован разными способами, скажем. Ну, в общем, будьте аккуратны. Я сейчас не
[06:00.400 --> 06:07.520]  буду вдаваться в подробности, но могут быть проблемы. Равно-равно может выдавать не совсем такие
[06:07.520 --> 06:17.960]  результаты, как вы ожидаете, а кто-то у меня просит зачем-то локально записать эту встречу.
[06:17.960 --> 06:26.240]  Зачем это делать? Я не знаю, я ее и так записываю. Нет, я вам не разрешу сам мне записывать, наверное,
[06:26.240 --> 06:40.320]  я сам записываю. Идем дальше. Логические операторы. Logical Operators. Это вот такие операторы.
[06:40.320 --> 06:52.480]  Значит, Logical и, Logical или, Logical не. Да, кстати, насчет побитовых операторов я еще забыл вот
[06:52.480 --> 07:00.280]  такой оператор побитого отрицания. Это унарный оператор, он инвертирует все биты числа. Logical и,
[07:00.280 --> 07:06.760]  Logical и, Logical и нет. Они принимают в качестве параметров bool, левым и правым аргументом,
[07:06.760 --> 07:13.440]  и возвращают bool. Ну, отрицание просто берет bool и инвертирует его, как булевское значение.
[07:13.440 --> 07:22.120]  Вот, понятно, что, опять-таки, если у вас вы передадите аргументы не типа bool, то они будут
[07:22.160 --> 07:28.840]  сконвертированы в bool, по правилам, которые мы обсуждали. Также понятно, что здесь, наоборот,
[07:28.840 --> 07:35.880]  если вы сюда передадите bool, то они будут сконвертированы в int, надо помнить. Вот такие
[07:35.880 --> 07:40.040]  операторы, они требуют целых чисел на вход, и соответственно, если вы передадите bool, то они
[07:40.040 --> 07:45.420]  будут явно сконвертированы в int, а если вы вот сюда, наоборот, int передадите, то они будут
[07:45.420 --> 07:51.240]  конвертированы в bool. Вот у этих операторов есть одно важное свойство, так называемое
[07:51.240 --> 08:00.440]  ленивое вычисление или short-circuit по-английски. Значит, что такое short-circuit?
[08:00.440 --> 08:09.680]  По-моему, так это пишется. Значит, как работают эти операторы? Если левая часть ложна в операторе
[08:09.680 --> 08:15.920]  конъюнкции, то правая часть не вычисляется. Это дает вам возможность, например, безопасно
[08:15.920 --> 08:23.160]  писать так. Вот если у вас есть вектор, и вы хотите там проверить, что vsize хотя бы 5 и
[08:23.160 --> 08:33.920]  что-то спросить про v4, то вы можете вот так написать. Вот конъюнкция гарантирует вам,
[08:33.920 --> 08:43.000]  вот этот оператор гарантирует вам, что он не случится ошибки, он не будет как бы делать вот
[08:43.000 --> 08:50.480]  это вот действие, если здесь условие было ложно. Поэтому так писать безопасно. Вот если это условие
[08:50.480 --> 08:59.280]  ложно, правая часть не будет вычисляться. Вот поэтому так можно писать. Аналогично, если у вас
[08:59.280 --> 09:03.880]  в дизъюнкции левая часть истинна, то правая часть тоже не будет вычисляться. Это гарантируется
[09:03.880 --> 09:11.160]  стандартом. Вот. В частности, например, если вы напишете там, я не знаю, если вы напишете
[09:11.160 --> 09:25.440]  там какое-нибудь условие true или сделаете increment, то increment не сделается. Вот. Потому
[09:25.480 --> 09:33.800]  что это true, значит правая часть не вычисляется. Хорошо. Давайте дальше перейдем к более интересным
[09:33.800 --> 09:39.920]  операторам. Следующая группа операторов – это операторы присваивания. Значит assignment operators.
[09:48.920 --> 09:53.680]  Ну, это обычное присваивание, а также это составные присваивания. Плюс равно, минус равно,
[09:53.920 --> 10:07.520]  умножить равно, поделить равно, процент равно. Дальше побитые операторы равно и с побитыми
[10:07.520 --> 10:17.920]  сдвигами присваивания. Кажется, все, я больше ничего не забыл вроде как. Значит, что делают эти
[10:17.920 --> 10:24.600]  операторы? Ну, как вы, наверное, и так знаете, давайте проговорим, что, например, означает вот этот
[10:24.600 --> 10:35.960]  оператор. Это значит, что вы A заменяете на A умножить на B. Как бы, по смыслу, это эквивалентно
[10:35.960 --> 10:42.600]  вот такому. Вот. Это эквивалентно такому для целых чисел, ну, там и для дробных и так далее,
[10:42.600 --> 10:50.600]  но для своих типов это может быть переопределено чуть поумнее. Вот. Но на самом деле смысл в том,
[10:50.600 --> 11:01.240]  что вы просто в A кладете результат, как если A умножить на B. Вот. Чем интересны операторы
[11:01.240 --> 11:06.600]  присваивания? Интересно, какое у них возвращаемое значение. После присваивания получается то,
[11:06.600 --> 11:12.440]  что получилось в результате присваивания, собственно. Вот. Если вы, например, напишете,
[11:12.440 --> 11:21.880]  если вы, например, выведете в cout результат присваивания там x равно 5, то вы получите 5
[11:21.880 --> 11:34.200]  на выходе. Значит, присваивание возвращает вам то, что получилось в итоге присваивания. И это
[11:34.200 --> 11:43.160]  позволяет, например, делать присваивания в строчку несколько, одно за другим. Вот. Когда вы так
[11:43.160 --> 11:49.520]  пишете, это эквивалентно вот этому, и это в свою очередь означает, что вы сначала y присвоите z,
[11:49.520 --> 11:56.800]  а потом x присвоите y. Значит, операторы присваивания, они правоассоциативны,
[11:56.800 --> 12:08.160]  правоассоциативны. Это значит, что если вы напишете несколько в строчку любых вот этих
[12:08.160 --> 12:12.960]  операторов подряд, то они будут выполняться справа налево. То есть это будет эквивалент
[12:12.960 --> 12:16.400]  тому, как если бы скобки у вас стояли в выражении вот сначала самое правое,
[12:16.400 --> 12:21.680]  потом предыдущее и так далее. В отличие от всех предыдущих операторов, предыдущий оператор
[12:21.680 --> 12:27.400]  левоассоциативны. То есть если вы напишете a plus b plus c, то это эквивалент тому, как если бы вот так
[12:27.400 --> 12:38.400]  написали, а не вот так. Так, значит, возвращаемые значения оператора присваивания – это то, что
[12:38.400 --> 12:44.640]  получилось в результате присваивания. Это, кстати, иногда бывает, приводит к такой ошибке,
[12:44.640 --> 12:50.800]  когда новички начинают писать на плюсах, они пишут там, допустим, у их x равно нулю что-то
[12:50.800 --> 12:58.600]  сделать. Да, и вот это, это компилируется, и это корректный код, но он делает не то,
[12:58.600 --> 13:06.280]  что могло бы показаться на первый взгляд. Так, что-то в чате много написали, я все пропустил.
[13:06.280 --> 13:23.480]  Так, если написать 3 больше 2, или 2 делить на 0 равно нулю? Ну, деление на 0 не должно произойти,
[13:23.480 --> 13:29.400]  да. Вот. Ну, на самом деле, 2 делить на 0, мне кажется, вам просто компилятор скажет, что так
[13:29.400 --> 13:36.080]  нельзя писать, потому что он уже сразу заподозрит, деление на 0 – силочисленное,
[13:36.080 --> 13:40.360]  мне кажется, компилятор вам что-нибудь скажет. Но если вы с переменными так сделаете,
[13:40.360 --> 13:47.640]  то деление на 0 не должно произойти у вас. Ну, короче, ошибки в отчлене правой части не должно
[13:47.640 --> 13:52.960]  случиться. Так вот, возвращаясь к ИФУ, вот если так написать, это корректно, но это условие
[13:52.960 --> 13:59.640]  всегда ложно, потому что оно возвращает 0, и таким образом это фолс. Вот. Поэтому
[13:59.640 --> 14:02.720]  будьте аккуратны, не путайте присваивания со сравнением.
[14:02.720 --> 14:12.160]  Извините, можно просить? Да, только очень глухо как-то слышно. Ну, давай.
[14:12.160 --> 14:18.000]  Ну, в общем, х равно у равно z, то есть сначала мы говорим, что у разно z, а потом говорим, что х
[14:18.840 --> 14:28.640]  равно у, потому что возвращается то, что случилось, а не то, что было. Ну, то есть все значения этой
[14:28.640 --> 14:43.880]  игры равны z? Ну, все значения становятся равны z после такого. Вот. Здесь впервые, когда мы
[14:43.880 --> 14:54.320]  разговариваем про операторы присваивания, мне нужно ввести понятие L-value и R-value. Все выражения
[14:54.320 --> 15:02.560]  подразделяются на два вида. Бывает выражение, которое называется L-value. Давайте я прям такую
[15:02.560 --> 15:11.480]  нарисую. Ну, значит, вот такую вот схемку. Значит, все выражения
[15:16.480 --> 15:29.640]  бывают либо L-value, либо R-value. L от слова left, R от слова right. Это довольно странное историческое
[15:29.640 --> 15:36.600]  такое название, исторически сложившееся. Но смысл вот в чем. Формальное определение осуществлять
[15:36.600 --> 15:44.440]  не буду. Я веду неформальное, а формальное мы ведем сильно позже, возможно, во втором семестре. Но
[15:44.440 --> 15:52.920]  неформально L-value это как бы то, что может стоять слева от оператора присваивания, а R-value это то,
[15:52.920 --> 15:58.400]  что не может стоять слева от оператора присваивания. Исторически идея именно такова. То есть некоторым
[15:58.400 --> 16:03.280]  вещам можно что-то присваивать, некоторым вещам нельзя что-то присваивать по смыслу. Вот,
[16:03.280 --> 16:11.000]  например, если вы берете просто переменную какую-то, то она L-value, потому что ну как бы
[16:11.000 --> 16:16.960]  ее, ей можно что-то присваивать. Если вы берете результат, допустим, сложение двух чисел x плюс y,
[16:16.960 --> 16:24.400]  то ему нельзя ничего присваивать, потому что результат сложения это никакая не переменная,
[16:24.400 --> 16:31.240]  это какое-то временное значение, которое вычислено на ходу, на лету, и оно в памяти,
[16:31.240 --> 16:40.040]  возможно, даже не хранится никакой. Вот. И вот это интуитивное понятие того, что переменные
[16:40.040 --> 16:45.760]  соответствуют какой-то ячейке памяти, и выражение просто вычислено на лету, и никакой ячейке
[16:45.760 --> 16:52.520]  памяти не лежит, это вот формализуется в понятиях L-value и R-value. Ну, более правильно понимать L-value
[16:52.520 --> 16:57.080]  как нечто, чему соответствует какая-то переменная, какая-то ячейка памяти соответствует,
[16:57.080 --> 17:03.320]  а R-value — это то, что, возможно, вычислено на лету и никакая ячейка памяти ему не соответствует,
[17:03.320 --> 17:08.560]  это такое временное значение. Так вот, каждое выражение, оно либо дает L-value в результате,
[17:08.560 --> 17:14.380]  либо R-value. И L-value, как правило, это то, чему можно снова что-то присваивать, а R-value — это
[17:14.380 --> 17:18.760]  то, чему нельзя присваивать. Почему я про это говорю сейчас? Потому что вот как раз операторы
[17:18.760 --> 17:23.760]  пресваивания возвращают l-value в отличие от всех предыдущих упомянутых операторов.
[17:23.760 --> 17:28.640]  Вот результаты всех предыдущих операторов, вот всех, которые здесь перечислены,
[17:28.640 --> 17:34.520]  и в том числе вот этих, — это r-value. А вот результаты операторов пресваивания — это l-value.
[17:34.520 --> 17:42.040]  Это значит, что можно, например, написать так. x равно y, и восьмой я думаю, пресвоить z.
[17:42.040 --> 17:51.880]  А это будет означать, что я x-у сначала присвоил y, а потом x-у же я присвоил z. Вот по итогам оператор
[17:51.880 --> 17:56.920]  пресваивания получается не просто значение такое получилось после пресваивания, а как бы сама
[17:56.920 --> 18:01.920]  та переменная, которая получилась, и является результатом пресваивания. В данном случае x.
[18:01.920 --> 18:09.120]  То есть после пресваивания получается та переменная, которой пресваивали. Вот поэтому
[18:09.120 --> 18:13.280]  эта конструкция работает корректно. Если я результату пресваивания снова что-то присваиваю,
[18:13.280 --> 18:20.960]  то получится, что я присваиваю тому же самому. Значит, итак, результат пресваивания — это l-value.
[18:20.960 --> 18:29.120]  Ему снова можно пресваивать. А результат всех предыдущих операций — это r-value.
[18:29.120 --> 18:35.280]  Идем дальше. Следующая операция — это инкремент и декремент.
[18:49.280 --> 18:54.880]  Инкремент и декремент бывают префиксный и постфиксный. Что такое префиксный инкремент?
[18:54.880 --> 19:00.580]  Это вот такой, который перед переменной ставится. постфиксный — этот тот, который после переменной
[19:00.580 --> 19:04.920]  ставится. Аналогично декремент, значит, инкремент — это увеличение на единицу.
[19:04.920 --> 19:13.680]  декремент — это уменьшение на единицу. Я буду говорить про инкремент только, а про декремент
[19:13.680 --> 19:19.640]  все аналогично просто в обратную сторону работы. Префиксный от постфиксного чем отличается?
[19:19.640 --> 19:24.280]  Префиксный инкремент — это такой, который увеличивает переменную единицу и возвращает
[19:24.280 --> 19:28.640]  то что получилось, а постфиксный увеличивает переменную на единицу
[19:28.640 --> 19:31.280]  возвращает то, что было.
[19:31.280 --> 19:33.720]  Отсюда если подумать, можно сразу увести следствие.
[19:33.720 --> 19:36.880]  Результат префиксного инкремента это сама переменная, которая
[19:36.880 --> 19:41.500]  и была, а результат постфиксного инкримента это временное
[19:41.500 --> 19:44.580]  значение, скопированное старое значение переменной,
[19:44.580 --> 19:48.140]  а сама переменная уже равна другому числу.
[19:48.140 --> 19:50.920]  Поэтому результат префиксного инкримента это L-value, а результат
[19:50.920 --> 19:52.920]  постексовый инкремент, это R-value.
[19:52.920 --> 19:54.920]  Значит, вот это L-value,
[19:54.920 --> 19:56.920]  вот это R-value.
[19:58.920 --> 20:00.920]  Соответственно, результату префиксного инкремента
[20:00.920 --> 20:02.920]  можно что-то присваивать, результату постексового
[20:02.920 --> 20:04.920]  инкремента нельзя ничего присваивать.
[20:04.920 --> 20:06.920]  В общем, я делал
[20:06.920 --> 20:08.920]  A++ и A++,
[20:08.920 --> 20:10.920]  и у меня между этим разницы не было вообще.
[20:10.920 --> 20:12.920]  То есть у меня значения
[20:12.920 --> 20:14.920]  увеличиваются один в том и в другом случае.
[20:14.920 --> 20:16.920]  Так, никто и не говорит, что разница в этом.
[20:16.920 --> 20:18.920]  Значения A увеличиваются на один
[20:18.920 --> 20:20.920]  и в том и в другом случае.
[20:20.920 --> 20:22.920]  Просто результат первого, это увеличенное
[20:22.920 --> 20:24.920]  на единицу значение, а результат второго
[20:24.920 --> 20:26.920]  это предыдущее значение.
[20:30.920 --> 20:32.920]  Если ты напишешь вот так
[20:32.920 --> 20:34.920]  A было равно нулю до этого,
[20:34.920 --> 20:36.920]  то ты получишь один.
[20:36.920 --> 20:38.920]  А если выведешь A++,
[20:38.920 --> 20:40.920]  то ты получишь ноль.
[20:40.920 --> 20:42.920]  Вот в этом и разница.
[20:44.920 --> 20:46.920]  Значения A должны измениться на один.
[20:46.920 --> 20:48.920]  Значение A изменяется на один
[20:48.920 --> 20:50.920]  и в том и в другом случае.
[20:50.920 --> 20:52.920]  Но значение этого выражения
[20:52.920 --> 20:54.920]  это и есть то, что получилось,
[20:54.920 --> 20:56.920]  а значение этого выражения
[20:56.920 --> 20:58.920]  это то, что было до увеличения.
[20:58.920 --> 21:00.920]  Да, и при этом
[21:00.920 --> 21:02.920]  первое это Lvalue,
[21:02.920 --> 21:04.920]  а второе это Rvalue.
[21:04.920 --> 21:06.920]  То есть результат вот этого выражения,
[21:06.920 --> 21:08.920]  еще раз говорю, это сама переменная A
[21:08.920 --> 21:10.920]  и, стало быть, ей снова можно
[21:10.920 --> 21:12.920]  что-то присваивать, а результат второго
[21:12.920 --> 21:14.920]  это скопированное старое значение
[21:14.920 --> 21:16.920]  переменной A
[21:16.920 --> 21:18.920]  и ему нельзя ничего присваивать,
[21:18.920 --> 21:20.920]  потому что это временное значение,
[21:20.920 --> 21:22.920]  которому не соответствует никакая переменная.
[21:24.920 --> 21:26.920]  Так вот, инкремент и декремент
[21:26.920 --> 21:28.920]  для себя требуют как оператор
[21:28.920 --> 21:30.920]  присваивания Lvalue в качестве аргумента.
[21:30.920 --> 21:32.920]  То есть я
[21:32.920 --> 21:34.920]  не могу, например, сделать
[21:34.920 --> 21:36.920] ++ от, не знаю,
[21:36.920 --> 21:38.920]  A++. Вот если у меня есть
[21:38.920 --> 21:40.920]  две переменных A и B, я сделал их сложение,
[21:40.920 --> 21:42.920]  а потом попробовал инкрементировать то, что получилось.
[21:42.920 --> 21:44.920]  Не получится, это будет ошибка
[21:44.920 --> 21:46.920]  со словами Lvalue
[21:46.920 --> 21:48.920]  required as
[21:48.920 --> 21:50.920]  an argument of increment.
[21:50.920 --> 21:52.920]  Значит, инкрементировать
[21:52.920 --> 21:54.920]  можно только Lvalue.
[21:54.920 --> 21:56.920]  Инкрементировать можно только переменные,
[21:56.920 --> 21:58.920]  ну, то есть что-то, что в памяти
[21:58.920 --> 22:00.920]  хранится, а не какие-то временные значения
[22:00.920 --> 22:02.920]  выражений.
[22:04.920 --> 22:06.920]  Ну и
[22:06.920 --> 22:08.920]  вот если я, например, напишу так,
[22:08.920 --> 22:10.920]  да, напишу
[22:10.920 --> 22:12.920] ++ от
[22:12.920 --> 22:14.920]  A равно 5.
[22:14.920 --> 22:16.920]  Так можно написать,
[22:16.920 --> 22:18.920]  потому что A присвоить 5 это
[22:18.920 --> 22:20.920]  Lvalue,
[22:20.920 --> 22:22.920]  оно снова
[22:22.920 --> 22:24.920]  соответствует переменной A,
[22:24.920 --> 22:26.920]  и после этого A еще инкрементируется.
[22:26.920 --> 22:28.920]  Вот, да, можно ли
[22:28.920 --> 22:30.920]  писать вот так,++ A
[22:30.920 --> 22:32.920] ++.
[22:32.920 --> 22:34.920]  Так можно.
[22:34.920 --> 22:36.920]  Значит, вот это все OK,
[22:36.920 --> 22:38.920]  вот это я зелененьким помечу, вот это OK.
[22:38.920 --> 22:40.920]  А вот, например,
[22:40.920 --> 22:42.920]  написать так,++
[22:42.920 --> 22:44.920]  от A++,
[22:44.920 --> 22:46.920]  это не OK.
[22:50.920 --> 22:52.920]  Как в том меме с Гриффином.
[22:52.920 --> 22:54.920]  Значит, вот это OK, вот это not OK.
[22:56.920 --> 22:58.920]  Кстати, если оскобки
[22:58.920 --> 23:00.920]  не поставлю,
[23:00.920 --> 23:02.920]  как это будет распаршено?
[23:02.920 --> 23:04.920]  Если я просто напишу++ A++,
[23:04.920 --> 23:06.920]  это тоже будет не OK,
[23:06.920 --> 23:08.920]  потому что пост-виксные операции
[23:08.920 --> 23:10.920]  приоритетнее префиксных,
[23:10.920 --> 23:12.920]  если к одному и тому же выражению
[23:12.920 --> 23:14.920]  применена какая-то пост-виксная операция
[23:14.920 --> 23:17.420]  и какая-то префиксная,
[23:17.420 --> 23:19.420]  то пост-виксные считаются приоритетнее,
[23:19.420 --> 23:21.920]  поэтому написать так без скобок
[23:21.920 --> 23:23.920]  и это все равно, traps,
[23:23.920 --> 23:27.420]  с такими скобками, это не OK.
[23:27.420 --> 23:29.420]  Потому что это все равно, что вы пытаетесь делать префиксный инквимент.
[23:29.420 --> 23:31.420]  Вот результат пост-виксное, то есть A thermovalue, так нельзя.
[23:31.420 --> 23:39.560]  Ну хорошо, идём дальше. Дальше у нас ещё предстоит
[23:39.560 --> 23:43.720]  обсудить парочку операторов. Вот. И ещё один оператор
[23:43.720 --> 23:45.920]  важный, который я хочу обсудить, это тернарный
[23:45.920 --> 23:52.240]  оператор. Тернарный — это значит, что у него три аргумента.
[23:52.240 --> 23:56.760]  Ну, бывают операторы унарные, бинарные и тернарные. Вот
[23:56.760 --> 23:59.040]  все предыдущие операторы были либо унарные, либо
[23:59.040 --> 24:01.400]  тернарные. Вот это тернарный сейчас будет. Он единственный
[24:01.400 --> 24:04.340]  такой, все плюс-плюс, поэтому он и называется тернарный.
[24:04.340 --> 24:07.260]  Сразу всё становится понятно, он такой один. Значит, это
[24:07.260 --> 24:15.020]  оператор, знак вопроса двоеточие. Это такой сокращённый
[24:15.020 --> 24:20.220]  if, как бы, сокращённая условная конструкция. Как им пользоваться?
[24:20.220 --> 24:29.600]  Вы пишите некоторые условия. Значит, condition. Ставите знак
[24:29.600 --> 24:35.120]  вопроса. Дальше пишите первый expression. Дальше ставите
[24:35.120 --> 24:41.980]  двоеточие и второй expression. Вот. Как работает этот оператор?
[24:41.980 --> 24:46.240]  Он вычисляет этот condition. Он ожидает, что там будет
[24:46.240 --> 24:49.740]  булевское значение. Если нет, то приводит его к булевскому
[24:49.740 --> 24:56.700]  значению не явно. И дальше, если это true, то вычисляется
[24:56.700 --> 25:00.260]  выражение 1 и возвращается его значение. Если это false,
[25:00.260 --> 25:03.300]  то вычисляется выражение 2 и возвращается его значение.
[25:03.300 --> 25:09.780]  Ну, например, я могу написать там x присвоить y больше нуля,
[25:09.780 --> 25:16.580]  тогда 1 иначе 2, например. Вот. Получится, что в зависимости
[25:16.580 --> 25:19.500]  от того, был ли x больше, был ли y больше нуля, x станет
[25:19.500 --> 25:23.140]  равен либо единиц, либо двойки. Так работает тернарный
[25:23.140 --> 25:32.180]  оператор. Тернарный оператор можно даже, значит, в левой
[25:32.180 --> 25:35.220]  части присваивания. Например, я могу так написать y больше
[25:35.220 --> 25:41.380]  нуля, тогда a иначе b что-то присвоить. Так тоже можно
[25:41.380 --> 25:47.980]  делать. И еще интереснее, можно делать даже так. Допустим,
[25:47.980 --> 25:56.260]  не знаю, y больше нуля, тогда a иначе b, значит, скажем,
[25:56.260 --> 26:02.220]  точка size. Допустим, a и b это вектор или строки. Вот.
[26:02.220 --> 26:07.020]  Вы можете написать там n равно и в зависимости от
[26:07.020 --> 26:09.540]  какого-то условия, либо у одного вектора, либо у
[26:09.540 --> 26:12.100]  другого вектора спросить размер. Так тоже можно делать.
[26:12.100 --> 26:20.740]  Вот. Что по поводу вида value? Вид value тернарного оператора
[26:20.740 --> 26:25.540]  зависит от того, какие виды value были у среднего аргумента
[26:25.540 --> 26:29.140]  и у правого аргумента. Как вы видите, если я написал
[26:29.140 --> 26:33.460]  вот так, то это l value, потому что я ему снова могу присваивать.
[26:33.460 --> 26:37.220]  А если я написал вот так, то это будет r value. Ну, на
[26:37.260 --> 26:40.620]  самом деле правило такое, если хотя бы один из аргументов
[26:40.620 --> 26:43.940]  средний правый r value, то весь тернарный оператор считается
[26:43.940 --> 26:50.740]  r value. В противном случае l value. Т.е. тернарный оператор
[26:50.740 --> 27:01.300]  r value, если хотя бы один из аргументов r value. А, например, вот корректно
[27:01.300 --> 27:16.180]  ли такое выражение? False, знак вопроса, a++, 2.++a, всему этому
[27:16.180 --> 27:23.780]  присвоить единицу. Вот такое выражение. Такое выражение
[27:23.780 --> 27:29.460]  некорректно, потому что слева от присваивания стоит
[27:29.460 --> 27:36.380]  r value. А почему это r value? По формальному правилу, что
[27:36.380 --> 27:40.060]  вот это r value, а это l value. Поскольку в тернарном
[27:40.060 --> 27:44.500]  операторе хотя бы одна из частей r value, значит весь
[27:44.500 --> 27:47.820]  тернарный оператор считается r value. Значит, ему присваивать
[27:47.820 --> 27:53.060]  нельзя. Ну, казалось бы, у меня же здесь false написано,
[27:53.060 --> 27:58.380]  и всегда будет вот это выбрано, а это не будет. Т.е. казалось
[27:58.380 --> 28:00.500]  бы, этот тернарный оператор – это всегда вот это вот
[28:00.500 --> 28:03.820]  значение, а никогда не это. Почему же тогда ему нельзя
[28:03.820 --> 28:08.100]  присваивать? Потому что вид value выражения проверяется
[28:08.100 --> 28:11.540]  раньше, чем вычисляется само выражение. Т.е. вычисление
[28:11.540 --> 28:15.500]  выражения – это вопрос времени выполнения программы.
[28:15.540 --> 28:18.660]  А анализ того, какой это вид value, то есть какой тип
[28:18.660 --> 28:22.500]  и какая категория value выражения – это задача компилятора.
[28:22.500 --> 28:25.380]  Компилятор не занимается вычислением выражений,
[28:25.380 --> 28:27.700]  компилятор занимается анализом типов и анализом
[28:27.700 --> 28:31.500]  видов value. И всё то, что я сейчас говорю – это ошибки
[28:31.500 --> 28:33.580]  компиляции. Вот я когда сейчас говорю какое-то выражение
[28:33.580 --> 28:36.220]  некорректно, я имею в виду, что компилятор выдаст ошибку
[28:36.220 --> 28:39.100]  компиляции. Проверка видов value, как и проверка корректности
[28:39.100 --> 28:43.060]  типов происходит на этапе компиляции. Поэтому вот это
[28:43.060 --> 28:48.020]  не корректно с точки зрения компилятора. Не важно, что при его вычислении всегда получится
[28:48.020 --> 28:55.160]  реально lvalue. Важно, что формально, по виду выражения, оно rvalue, а значит присваивать ему
[28:55.160 --> 29:00.220]  компилятор запретит. Ну и что, что на практике в рантайме получится что-то хорошее? Мы не можем
[29:00.220 --> 29:06.620]  заранее вычислять, мы должны сначала проанализировать виды value и типы. И компилятор запретит такое
[29:06.620 --> 29:19.620]  присваивание. Что-то еще забыл сказать про тернарный оператор, а и вот что забыл сказать. В тернарном
[29:19.620 --> 29:28.460]  операторе работает следующее правило, как и в булевских операторах, что если условие истинно,
[29:28.460 --> 29:35.580]  то правый аргумент не вычисляется, а если условие ложно, то левый аргумент не вычисляется. То есть,
[29:35.580 --> 29:44.300]  если здесь false, то вот это не будет выполнено, а если здесь true, то вот это не будет выполнено.
[29:44.300 --> 29:49.420]  Ну то есть вы можете написать допустим там какое-нибудь условие х больше нуля,
[29:49.420 --> 29:56.580]  знак вопроса, a++, 2.b++ и быть уверенным, что ровно один из инкрементов выполнится.
[29:56.580 --> 30:07.380]  Вот. Это тернарный оператор. Ну вы на семинарах наверное еще пообсуждаете тернарный оператор и
[30:07.380 --> 30:16.740]  какие-нибудь придумаете примеры его использования. Тернарный оператор я рекомендую в коде использовать,
[30:16.740 --> 30:22.100]  но с умом. То есть, если у вас есть какой-то if, вот например, если вы хотите написать if х больше нуля,
[30:22.100 --> 30:27.220]  то а присвоить 1 иначе b присвоить 1, это разумно заменить на тернарный оператор. Но если у вас там
[30:27.220 --> 30:34.820]  огромный многоуровневый if, то лепить вереницу тернарных операторов наверное не стоит. Короче,
[30:34.820 --> 30:40.820]  пользуйтесь с умом. Да, ну еще один момент, последний наверное про тернарный оператор,
[30:40.820 --> 30:47.260]  который я сейчас скажу. Это то, что типы выражений вот этого и вот этого тоже должны быть,
[30:47.260 --> 30:54.380]  но если не одинаковыми, то хотя бы приводимыми друг к другу. Например, если вы сделаете тернарный
[30:54.380 --> 31:08.780]  оператор, у которого значит тут скажем false знак вопроса два с половиной двоеточие два, то тип этого
[31:08.780 --> 31:17.140]  выражения будет double. Несмотря на то, что как казалось бы всегда возвращается if, но тип выражения
[31:17.140 --> 31:23.460]  это понятие времени компиляции. В вычислении выражений компилятор, еще раз повторяю, он не
[31:23.460 --> 31:30.540]  занимается. Задача компилятора понять все типы и понять все виды value. В данном случае, чтобы понять
[31:30.540 --> 31:35.620]  тип выражения, компилятору нужно найти общий тип между средней и правой частью. Поэтому тип
[31:35.620 --> 31:40.060]  этого выражения это double, несмотря на то, что при вычислении реально будет всегда int получаться,
[31:40.060 --> 31:47.500]  но нет. Поэтому если, например, у вас есть какая-нибудь функция f и вы решите ее вызвать вот от такого,
[31:47.500 --> 31:54.140]  то выберется версия от double. Представьте, что у вас есть версия от int и от double и вы вызвали f вот
[31:54.140 --> 32:00.340]  от такого выражения. Выберется версия от double, потому что тип выражения double. Тип выражения это
[32:00.340 --> 32:02.340]  понятие времени компиляции.
[32:02.340 --> 32:07.900]  А можете немножко ниже опустить? Там не видно было нижнюю строчку.
[32:07.900 --> 32:09.780]  Так что ли?
[32:09.780 --> 32:13.300]  Да, спасибо.
[32:13.300 --> 32:14.140]  Окей.
[32:14.140 --> 32:25.660]  Так, предпоследний оператор, о котором я расскажу, это оператор запятая.
[32:25.660 --> 32:32.580]  Это, пожалуй, самый кринжовый оператор C++.
[32:32.580 --> 32:39.140]  Значит, оператор запятая — это следующая вещь. Это такой оператор, который вычисляет
[32:39.140 --> 32:44.620]  левую часть, вычисляет правую часть и возвращает правую часть, и больше ничего не делает.
[32:44.620 --> 32:51.500]  Вид value у него такой же, как у правой части, и тип этого выражения такой же, как тип правой части.
[32:51.500 --> 32:55.100]  Зачем это нужно? Ну, если вам захотелось несколько выражений в строчку записать,
[32:55.100 --> 32:59.420]  то вы можете это сделать с помощью оператора запятая.
[32:59.420 --> 33:05.060]  Это звучит неубедительно, я понимаю. Не очень понятно, зачем это может быть нужно.
[33:05.060 --> 33:12.260]  Ну вот, поверьте, бывает полезно. В общем, пару раз, наверное, за этот год мы столкнемся с ситуацией,
[33:12.260 --> 33:17.940]  когда нам нужен будет оператор запятая, и вот когда он окажется нужен, это будет очень такой
[33:17.940 --> 33:22.140]  катарсис. Но пока что выглядит немного как кринж.
[33:22.140 --> 33:29.940]  Ну, соответственно, вы можете, например, вот так писать. Это корректно. То есть,
[33:29.940 --> 33:34.860]  запятая возвращает правую часть, и вид value такой же, как у правой части. То есть,
[33:34.860 --> 33:40.300]  вот написать так — это всё равно, что b присвоить единицу. Вот, можно вот так написать a,
[33:40.300 --> 33:47.900]  присвоить b, запятая c. Это всё равно, что a присвоить c. Вот. Ну, можно писать plus plus x,
[33:47.900 --> 33:56.980]  запятая plus plus y. И этому ещё что-нибудь присвоить. Так тоже можно. Это значит,
[33:56.980 --> 34:01.660]  что x увеличится единицу, y увеличится единицу, а потом y присвоится 2.
[34:01.660 --> 34:10.140]  Здесь надо сделать важную оговорку, что не всякая запятая является оператором. Вот,
[34:10.140 --> 34:15.180]  вы можете подумать, например, что самое распространённое заблуждение, которое люди
[34:15.180 --> 34:20.940]  делают, это что вот, например, если у вас есть функция какая-то, voidf от int x запятая int y,
[34:20.940 --> 34:28.140]  то они думают, ну вот, наверное, вот это оператор запятая. Нет, конечно, это никакой не оператор
[34:28.140 --> 34:33.660]  вообще. То, что это является символом запятая, это не значит, что является оператором. Операторы
[34:33.660 --> 34:38.220]  встречаются только в экспрешенах, в выражениях. А это никакой не экспрешен, это список аргументов.
[34:38.220 --> 34:54.060]  Точно так же, как когда вы пишете include и ostream, вот это же не оператор меньше, правда? А это не
[34:54.060 --> 34:59.680]  оператор больше. Ну и что, что символы используют те же самые? Вот это не оператор меньше, потому
[34:59.680 --> 35:03.780]  что это совершенно другая синтоксическая конструкция. Здесь вообще речь об операторах, никакой не идёт.
[35:03.780 --> 35:13.740]  И это точно так же не оператор запятая. Поэтому, значит, например, когда вы пишете f от, когда вы,
[35:13.740 --> 35:19.740]  например, вызываете функцию f от plus plus x запятая plus plus y, представим, что f это некоторая функция.
[35:19.740 --> 35:27.060]  Здесь нет гарантии, что сначала сделается plus plus x, потом сделается plus plus y. Вот. И,
[35:27.060 --> 35:32.940]  например, если вы вызовете функцию от plus plus x запятая plus plus x ещё раз, то нет гарантии,
[35:32.940 --> 35:40.100]  что второй аргумент будет больше, чем первый. Вот в такой конструкции, в таком выражении,
[35:40.100 --> 35:47.460]  в вызове функции, это не оператор запятая. Это потому что вот это вот не экспрешен, а это просто
[35:47.460 --> 35:53.180]  перечисление аргументов функции. Вот всё вместе это экспрешен. Но просто список аргументов функции
[35:53.180 --> 35:59.580]  внутри скобок, это не экспрешен. Поэтому здесь неприменимо правило, как к оператору запятая,
[35:59.580 --> 36:04.500]  что сначала вычитается левая часть, и только потом правая. Вот в операторе запятая это верно,
[36:04.500 --> 36:09.500]  а в списке аргументов функции это не обязательно так, и нет гарантии, что будет левый аргумент
[36:09.500 --> 36:16.860]  меньше правого в итоге. Точно так же не является оператором запятая, когда вы объявляете несколько
[36:16.860 --> 36:23.900]  переменных на одной строке. Вот это не оператор запятая, и более того, вот это не оператор
[36:23.900 --> 36:29.820]  присваивания. Вот это может вообще кого-то сильно шокировать, но вот когда вы объявляете переменную
[36:29.820 --> 36:34.500]  и инициализируете её, пишете равно, вот это не считается оператором присваивания, и работает оно
[36:34.500 --> 36:39.460]  по другим правилам. Если, например, для своих типов вы переопределите присваивание как-то по
[36:39.460 --> 36:45.340]  особенному, то оно не будет вот здесь вот работать, потому что это не присваивание. Символ равно используется
[36:45.340 --> 36:49.740]  такой же как и для присваивания, но по факту это никакой не оператор, потому что это объявление,
[36:49.740 --> 36:54.620]  а не expression, а expression является только вот этой частью, в этой конструкции.
[36:54.620 --> 37:02.860]  Так, это что касается оператора запятая. Ну и последний полезный оператор, о котором мы сейчас
[37:02.860 --> 37:11.500]  поговорим, это... Да, очень слышно из-под воды тебя, говори как-то по-другому.
[37:11.500 --> 37:19.900]  Извините, можно еще буквально одно слово, что делать запятая, просто я немножко это...
[37:19.900 --> 37:27.300]  Запятая еще раз берет и вычисляя. Она сама по себе ничего не делает. Запятая это просто способ
[37:27.300 --> 37:32.220]  вычислить несколько выражений подряд, фактически. То есть что формально такое запятая? Это значит
[37:32.220 --> 37:38.140]  вычисли левую часть, строго после этого вычисли правую часть и результатом объяви правую часть.
[37:38.140 --> 37:42.620]  Вот и все. Между левой и правой частью ничего не делается. Просто вычислять сначала левая часть,
[37:42.620 --> 37:49.380]  потом правая, вот и все. Вот допустим, вот это две скобочки A запятая B равно 1, то я просто
[37:49.380 --> 37:55.300]  попробовал, у меня получилось что-то странное. Ну это все равно, что просто написать B равно 1.
[37:55.300 --> 38:02.100]  А в чем смысл этого действия тогда? Запятая это просто последовательное вычисление
[38:02.100 --> 38:13.580]  нескольких выражений, одно за другим. Да, ну а A равно B скобочкой запятая C? Это все равно,
[38:13.580 --> 38:22.140]  что A равно C. Запятая просто вычисляет это выражение, вычисляет после этого выражение и
[38:22.140 --> 38:27.140]  возвращает то, что получилось справа, то есть C в данном случае. Написать так, это все равно,
[38:27.220 --> 38:35.980]  написать вот так. А плюс плюс X плюс плюс Y равно 2, это значит сначала увеличить X на 1,
[38:35.980 --> 38:43.020]  потом увеличить Y на 1, вернуть то, что получилось после вот этого и вот ему присвоить 2. Просто
[38:43.020 --> 38:48.420]  какая-то странная операция получается, непривычная. Ну она довольно забавная,
[38:48.420 --> 38:54.900]  да она довольно странно себя ведет, возможно. Но иногда бывает полезно, редко, но бывает.
[38:54.900 --> 39:03.420]  Так, чего пишут в чате? X равно 0, запятая Y равно 1. Можете еще раз сказать, что тут оператор. Тут
[39:03.420 --> 39:09.340]  нет ни одного оператора. Вот в этой вот записи нет вообще ни одного оператора. Это не оператор,
[39:09.340 --> 39:19.700]  это не оператор и это не оператор. Потому что равенство, которое используется при объявлениях,
[39:19.700 --> 39:24.100]  не является присваиванием, а запятая, который используется для перечисления объявлений,
[39:24.100 --> 39:29.980]  тоже не является оператором запятая. Поэтому в этой записи, в этом объявлении, нет ни одного
[39:29.980 --> 39:37.940]  оператора. Соответственно, для чего это надо знать? Надо для того, что если вы будете определять
[39:37.940 --> 39:43.260]  операторы для своих типов и будете писать вот такое, то не удивляйтесь, что они не будут
[39:43.260 --> 39:48.860]  действовать, потому что это никакие не операторы. Внутри запятой может быть присваивание,
[39:48.860 --> 39:54.820]  что внутри запятой? В смысле? Ну, конечно, может. Любые выражения могут быть разделены
[39:54.820 --> 40:00.620]  запятой. Пожалуйста, запросто. Любые экспрешены. Слева любой экспрешен, и справа любой экспрешен.
[40:07.820 --> 40:18.820]  А через плюс можно писать три выражения? Да, можно. Просто это будет партия,
[40:18.820 --> 40:24.740]  то же самое и запятой. Если вы напишите A, B, C, это будет все равно, что вот так написать.
[40:24.740 --> 40:31.820]  Запятая лево ассоциативно, как и плюс, как и другие арифметические операторы, как и большинство операторов.
[40:31.820 --> 40:42.780]  Спасибо. И все-таки последний оператор, о котором я сейчас расскажу, это оператор Сайзов.
[40:42.780 --> 40:55.980]  Сайзов – это оператор, он довольно нам будет часто нужен для разных учебных примеров, да и вообще по
[40:55.980 --> 41:03.060]  жизни. Это такой встроенный оператор, и он же является ключевым словом языка C и C++. Ну,
[41:03.060 --> 41:09.060]  то есть встроенным язык словом, которое имеет предопределенное значение. Этот оператор,
[41:09.060 --> 41:14.780]  который позволяет узнать размер в байтах данной переменной или данного типа. Я могу
[41:14.780 --> 41:23.420]  написать Сайзов от какой-то переменной и получить число, обозначающее количество байт,
[41:23.420 --> 41:28.420]  которое эта переменная в памяти занимает. Так я могу, например, узнать, сколько байт
[41:28.420 --> 41:34.700]  занимает int у меня. Например, если у меня есть int A, я могу вывести Сайзов от A и узнать,
[41:34.700 --> 41:41.020]  что это скорее всего 4. Вот так я могу и для остальных переменных сделать. И на самом деле я
[41:41.020 --> 41:47.820]  могу писать Сайзов даже не от переменной, а просто от типа. Сайзов от int, например. И я узнаю размер
[41:47.820 --> 41:56.900]  переменной типа int. А Сайзов от вектора будет капасити его выдавать, да? Вот, значит, очень
[41:56.900 --> 42:01.660]  правильный вопрос, что будет выдавать Сайзов от вектора. Надо понять следующую вещь. Сайзов
[42:01.660 --> 42:06.740]  от любой переменной — это константа, причем известная на этапе компиляции. Сайзов — это
[42:06.740 --> 42:13.780]  количество байт, которое занимает в памяти именно переменная. И результат Сайзова известен всегда
[42:13.780 --> 42:23.660]  на этапе компиляции. В частности, для вектора это будет, скорее всего, 24. Почему для вектора это
[42:23.660 --> 42:28.260]  всегда… Независимо от того, сколько элементов лежит в векторе, Сайзов от вектора — это одно и
[42:28.260 --> 42:37.740]  то же число. Почему? Потому что элементы вектора, они не относятся к памяти, которая относится
[42:37.740 --> 42:43.540]  самопеременной вектор. Когда у вас есть вектор, вектор, он на самом деле устроен как? В нем есть,
[42:43.540 --> 42:49.180]  ну как бы, поля, то есть в нем есть число, которое обозначает, сколько в нем элементов, число,
[42:49.180 --> 42:54.180]  которое обозначает, под сколько элементов память выделено, а также в нем есть поинтер,
[42:54.180 --> 43:03.740]  который указывает на массив из самих элементов. Вот когда вы заводите вектор, переменная В
[43:03.740 --> 43:09.980]  представляет из себя вот такую вот структуру. В, сам вектор, это же динамический массив, и в нем
[43:09.980 --> 43:16.080]  есть вот этот вот указатель на какой-то storage, который хранится в другой памяти. И вот размер
[43:16.080 --> 43:25.880]  вектора, вот это вот, это V.Size, а вот это вот, это Сайзов от V, и это разные вещи, это надо
[43:25.880 --> 43:30.880]  обязательно не путать, то же самое со стрингом строкой. Когда у вас есть строка, то Сайзов от
[43:30.880 --> 43:40.120]  строки — это просто сумма размеров ее полей, а V.Size — это количество элементов, которые выделены
[43:40.120 --> 43:47.440]  этой строкой, но сама переменная S, как и сама переменная V, она фиксированное количество байт
[43:47.440 --> 43:54.120]  занимает. Понятно? Вот это очень важная разница, это надо не путать. Мы с вами в дальнейшем обсудим
[43:54.120 --> 43:59.640]  подробно, как устроен вектор, разумеется, и как строка устроена. У вас будет даже задание написать
[43:59.640 --> 44:04.920]  свою реализацию строки, вот одно из первых заданий в этом семестре скоро, и вы поймете,
[44:04.920 --> 44:10.720]  как это работает, но пока что просто знайте, что Сайзов от строки и строка точка Сайз — это
[44:10.720 --> 44:18.240]  разные вещи. Вот, мы не будем вызывать Сайзов пока от вектора, мы будем Сайзов пользоваться для
[44:18.240 --> 44:30.800]  примитивных типов, чтобы узнавать их размер. Простите, а в переменной Capacity, что содержится,
[44:30.800 --> 44:38.200]  она у вас в табличке, в второй строке? У вектора есть, вам, я не знаю, уже рассказывали об этом на
[44:38.200 --> 44:43.560]  алгоритмах или нет, но у вектора есть количество элементов, которые в него положено, а еще у него
[44:43.560 --> 44:51.120]  есть зарезелированная память, и size — это количество элементов, которые реально лежит в нем,
[44:51.120 --> 44:57.440]  а Capacity — это количество элементов, под которые память выделена. Size — это количество элементов,
[44:57.640 --> 45:01.080]  хранящихся в нем, а Capacity — это количество элементов, под которые память выделена.
[45:01.080 --> 45:03.120]  Понял, спасибо.
[45:08.120 --> 45:13.520]  Сайзов возвращает, я думаю, что он возвращает sizeT, а не int.
[45:13.600 --> 45:31.240]  Я думаю, что тип возвращаемого значения Сайзов — это sizeT, ну то есть тот самый тип,
[45:31.240 --> 45:37.480]  который нужен для индексации, для размера, ну или unsigned, ну вряд ли int, он же беззнаковый.
[45:37.480 --> 45:46.200]  Так, это, пожалуй, все, что я хотел рассказать про операторы, но не совсем. Значит, последняя вещь —
[45:46.200 --> 45:57.080]  это таблица приоритетов операторов. Сейчас я вам ее покажу. Для этого мне нужно расшарить вам
[45:57.080 --> 46:05.960]  другой экран. Сейчас я это сделаю. Вот на сайте CPReference мы можем найти такую таблицу,
[46:05.960 --> 46:15.800]  в которой перечислены приоритеты операторов. Ну вот здесь перечислены все операторы,
[46:15.800 --> 46:21.000]  которые есть в языке C++. Мы с вами рассмотрели не все из них. Часть из них мы рассмотрим позже,
[46:21.000 --> 46:26.520]  а часть мы, возможно, даже и не будем рассматривать в этом курсе, но большую часть из них мы и так
[46:26.520 --> 46:33.480]  рассмотрели. Смотрите, это самым приоритетным является scope resolution. Ну, формально это не
[46:33.480 --> 46:38.600]  совсем оператор, но можно его в некотором приближении таковым считать. Это когда вы
[46:38.600 --> 46:47.520]  пишете std 2.2.cout. Вот когда у вас есть expression std 2.2.cout вправо-вправо x, влево-влево x,
[46:47.520 --> 46:55.680]  то понятно, что вот эта 2.2. в первую очередь выполняется. То есть оно как бы самое приоритетное.
[46:55.680 --> 47:02.800]  Дальше у вас идут поцсексные унарные операторы, дальше у вас идут префиксные унарные операторы,
[47:02.800 --> 47:08.560]  дальше идут бинарные операторы вот в таком порядке. Причем вот здесь про каждую группу
[47:08.560 --> 47:15.000]  операторов написано её ассоциативности. Слева направо, справа налево, вот эти бинарные операторы
[47:15.000 --> 47:19.400]  ассоциативны слева направо, вот эти бинарные операторы ассоциативны справа налево,
[47:19.400 --> 47:24.360]  и запятая опять слева направо. Про запятую следует помнить, что у неё самые низкие
[47:24.360 --> 47:30.880]  приоритеты всех вообще операторов, на самом низу таблиц приоритетов проходится. Надо понимать,
[47:30.880 --> 47:33.640]  что означает приоритет операторов с формальной точки зрения.
[47:33.640 --> 47:37.440]  Вот некоторые думают, что приоритет операторов — это то,
[47:37.440 --> 47:40.400]  в каком порядке реально будут происходить вычисления, это неправда.
[47:40.400 --> 47:45.920]  Вот сейчас я попробую вам объяснить, как правильно понимать приоритет операторов.
[47:45.920 --> 47:50.560]  Вот представьте, что у меня есть выражение, но я не знаю, ну давайте я напишу какое-нибудь выражение.
[47:50.560 --> 47:53.920]  Ну вот такое давайте напишу выражение.
[47:53.920 --> 48:01.240]  Вот это некоторые expression.
[48:01.240 --> 48:08.080]  Когда компилятор синтоксически парсит это выражение, он во-первых понимает,
[48:08.080 --> 48:11.680]  что это выражение, а не объявление, и дальше его задача — понять,
[48:11.680 --> 48:14.600]  какой оператор обладает самым низким приоритетом в этом выражении.
[48:14.600 --> 48:18.760]  Самым низким приоритетом, согласно таблице, в этом выражении обладает вот этот оператор.
[48:18.760 --> 48:23.640]  Это значит, что компилятор начинает строить дерево синтоксического разбора вот так.
[48:24.360 --> 48:28.700]  Он понимает, что вверху этого выражения стоит вот этот оператор, и его левым
[48:28.700 --> 48:36.100]  аргументом является вот такая штука, а правым аргументом является вот такая штука.
[48:36.100 --> 48:38.260]  Дальше каждый из этих под- выражений он парсит отдельно.
[48:38.260 --> 48:42.400]  Здесь он видит, что есть оператор, вот такой, а здесь вот такой.
[48:42.400 --> 48:47.800]  И он понимает, что левым аргументом этого оператора является нечто под названием
[48:47.800 --> 48:52.340]  Estd, а правым — нечто под названием Seout, а здесь левым аргументом является
[48:52.340 --> 48:57.020]  под названием x, а правом нечто под названием 5.
[48:57.020 --> 49:02.660]  Если предположить гипотетически, что у плюса был бы приоритет
[49:02.660 --> 49:06.860]  ниже, чем у оператора побитого с двигателем, то выражение
[49:06.860 --> 49:08.300]  выпарщилось по-другому.
[49:08.300 --> 49:10.420]  Ну вот, например, если я возьму вот такое выражение
[49:10.420 --> 49:17.180]  std seout x присвоить 5.
[49:17.180 --> 49:20.020]  Ситуация кардинально поменяется.
[49:20.020 --> 49:22.980]  А именно, здесь уже наименьшим приоритетом обладает вот
[49:22.980 --> 49:23.980]  это.
[49:23.980 --> 49:27.340]  И тогда в дереве синтоксического разбора вверху будет стоять
[49:27.340 --> 49:31.540]  вот это, и его правым аргументом будет 5, а левым аргументом
[49:31.540 --> 49:39.740]  будет выражение std seout x, соответственно, дальше
[49:39.740 --> 49:46.700]  это распадется на x и std seout, ну и дальше это распадется
[49:46.700 --> 49:48.620]  на std и seout.
[49:49.500 --> 49:51.220]  Вот что такое приоритет операторов.
[49:51.220 --> 49:54.420]  Приоритет операторов — это на самом деле правило
[49:54.420 --> 49:58.540]  того, как компилятор строит синтоксическое дерево
[49:58.540 --> 49:59.540]  разбора.
[49:59.540 --> 50:01.900]  Вот у вас есть выражение, его надо синтоксически разобрать,
[50:01.900 --> 50:05.020]  надо понять, это какая операция над какими аргументами.
[50:05.020 --> 50:08.140]  Вот приоритет как раз говорит компилятору о том, какая
[50:08.140 --> 50:11.460]  операция стоит вверху синтоксического дерева, и что является ее
[50:11.460 --> 50:14.140]  аргументом, и дальше он рекурсивно разбирает ее
[50:14.140 --> 50:15.140]  части.
[50:15.140 --> 50:20.140]  Что означает ассоциативность в этом смысле.
[50:20.140 --> 50:27.100]  Вот, например, если у вас написано a plus b plus c, что означает,
[50:27.100 --> 50:29.460]  что плюс лево ассоциативен.
[50:29.460 --> 50:31.660]  Это значит, что если у вас на верхнем уровне находится
[50:31.660 --> 50:35.340]  несколько операторов одинакового приоритета, то вверху окажется
[50:35.340 --> 50:36.820]  тот из них, кто левее.
[50:36.820 --> 50:40.980]  Вот тот факт, что плюс лево ассоциативен, означает,
[50:40.980 --> 50:42.340]  что дерево будет построено так.
[50:42.340 --> 50:47.220]  Если бы плюс был право ассоциативен, то дерево было бы построено
[50:47.220 --> 50:48.460]  стартуя с этого плюса.
[50:48.460 --> 50:55.100]  Соответственно, если у вас там есть, ну, можете самостоятельно
[50:55.100 --> 50:57.540]  поупражняться, если у вас есть длинное выражение,
[50:57.540 --> 50:59.860]  в котором много операторов, то вы можете самостоятельно
[50:59.860 --> 51:02.580]  построить деревья синтоксического разбора для этих выражений.
[51:02.580 --> 51:11.900]  Вот, и здесь есть одна обманка, одна важная для понимания
[51:11.900 --> 51:14.900]  вещь.
[51:14.900 --> 51:18.300]  Тот факт, что дерево синтоксического разбора так выглядит, не
[51:18.300 --> 51:22.660]  означает, что реальные операции будут выполняться именно
[51:22.660 --> 51:25.900]  в таком порядке, как написано согласно дереву синтоксического
[51:25.900 --> 51:26.900]  разбора.
[51:26.900 --> 51:27.900]  То есть, что я имею в виду?
[51:27.900 --> 51:30.340]  Представьте, что у вас, например, есть такое выражение.
[51:30.340 --> 51:37.020]  А умножить на b, плюс c умножить на d, плюс e умножить на f.
[51:37.020 --> 51:43.180]  Давайте я, наверное, даже отдельную строчку напишу.
[51:43.180 --> 51:49.620]  А умножить на b, плюс c умножить на d, плюс e умножить на f.
[51:49.620 --> 51:51.940]  Ну, дерево синтоксического разбора для этого выражения
[51:51.940 --> 51:52.940]  будет выглядеть так.
[51:52.940 --> 51:56.540]  Сначала левый плюс, слева от него а умножить на b,
[51:56.540 --> 52:00.100]  дальше справа правый плюс, и здесь c умножить на d,
[52:00.100 --> 52:04.780]  а здесь d умножить на f, и e умножить на f.
[52:04.780 --> 52:05.780]  Вот.
[52:05.780 --> 52:08.460]  Понятно, что значение этого выражения определено
[52:08.460 --> 52:11.860]  однозначно в целом, то есть, что результатом этого
[52:11.860 --> 52:15.800]  выражения будет сумма трех произведений, но нет совершенно
[52:15.800 --> 52:19.760]  никаких гарантий относительно того, какой именно из произведений
[52:19.760 --> 52:21.660]  раньше посчитается.
[52:21.660 --> 52:24.300]  Компилятор может сначала посчитать это, потом посчитать
[52:24.300 --> 52:27.940]  это, потом посчитать это и сложить, ну вот, он может
[52:27.940 --> 52:31.380]  сделать вот так, сначала это, потом это, потом это.
[52:31.380 --> 52:34.460]  Он мог бы сначала вот это посчитать, потом это,
[52:34.460 --> 52:37.780]  потом это, потом сделать вот так, потом вот так.
[52:37.780 --> 52:42.220]  Он мог бы, значит, сначала посчитать вот это, потом
[52:42.220 --> 52:45.620]  посчитать и это, потом их сложить, потом посчитать
[52:45.620 --> 52:47.780]  и это, а потом только сложить итоги.
[52:47.780 --> 52:51.700]  То есть, тот факт, что синтоксически эта конструкция распарсилась
[52:51.700 --> 52:55.140]  единственным возможным образом, не означает, что порядок
[52:55.140 --> 52:58.620]  вычислений будет именно таким, как написано слева-направо.
[52:58.620 --> 53:02.900]  Это очень важное понимание, которое надо держать в
[53:02.900 --> 53:03.900]  голове.
[53:03.900 --> 53:06.820]  Приоритет операторов говорить лишь о том, как синтоксически
[53:06.820 --> 53:09.860]  компилятор видит эту запись, но не о том, что реально
[53:09.860 --> 53:11.340]  будет происходить в раундтайме.
[53:11.340 --> 53:15.380]  Приоритет операторов — это понятие этапа компиляции,
[53:15.380 --> 53:17.940]  а понятием этапа выполнения является так называемый
[53:17.940 --> 53:21.100]  order of evaluation — порядок вычисления выражений.
[53:21.100 --> 53:23.340]  И это другая штука, про которую мы попозже поговорим.
[53:23.340 --> 53:30.740]  Что-то в чате написали, приоритет умножения выше
[53:30.740 --> 53:31.740]  приоритета сложения.
[53:31.740 --> 53:35.420]  Я об этом и говорю, что эта конструкция будет распаршена
[53:35.420 --> 53:37.900]  вот так, за счет того, что приоритет умножения выше
[53:37.900 --> 53:38.900]  приоритета сложения.
[53:38.900 --> 53:43.860]  Если бы приоритет умножения был ниже приоритета сложения,
[53:43.860 --> 53:46.100]  то эта конструкция была бы распаршена так, что у
[53:46.100 --> 53:48.700]  вас на верхнем уровне идет умножение, ну то есть,
[53:48.700 --> 53:50.580]  эта конструкция была бы распаршена вот так.
[53:50.580 --> 53:56.060]  У вас тут три умножения, и было бы сначала A умножить
[53:56.060 --> 53:58.100]  на вот это, потом умножить на вот этого.
[53:58.100 --> 54:00.660]  Нет, приоритет умножения выше приоритета сложения,
[54:00.660 --> 54:03.060]  именно поэтому синтоксическое дерево разбора вот так выглядит.
[54:03.060 --> 54:06.140]  Но это все еще не имеет никаких гарантий относительно
[54:06.140 --> 54:08.740]  о, в каком порядке будут вычислены вершины этого
[54:08.740 --> 54:10.740]  дерева.
[54:10.740 --> 54:13.140]  Понимаете разницу между приоритетом и порядком
[54:13.140 --> 54:14.140]  вычислений?
[54:14.140 --> 54:16.860]  Это важная разница.
[54:16.860 --> 54:18.580]  Приоритет не говорит о том, в каком реальном порядке
[54:18.580 --> 54:19.580]  будут вычтения происходить.
[54:19.580 --> 54:28.380]  Приоритет дает лишь понимание, чему равно значение выражения.
[54:28.380 --> 54:31.300]  Напоследок поговорим про control statement, то есть, про
[54:31.300 --> 54:32.300]  управляющие конструкции.
[54:32.300 --> 54:35.980]  Значит, мы закончили говорить про операторы, и сейчас
[54:35.980 --> 54:38.300]  поговорим про управляющие конструкции.
[54:47.860 --> 54:51.300]  Третий вид стейтментов, который может встречаться
[54:51.300 --> 54:53.540]  у вас в функциях, это control statement.
[54:53.540 --> 54:56.580]  Значит, это будет у нас параграф 1.5 в нашем повествовании.
[54:56.580 --> 55:02.740]  Я назову файл просто control.
[55:02.740 --> 55:21.620]  Итак, вот у вас есть main, и что я могу здесь написать
[55:21.620 --> 55:23.020]  из управляющей конструкции?
[55:23.020 --> 55:25.820]  Управляющая конструкция – это значит такие штуки,
[55:25.820 --> 55:29.020]  которые влияют на ход выполнения программы каким-то образом.
[55:29.020 --> 55:31.620]  Наверное, самая простая, самая известная дика – taif.
[55:32.500 --> 55:33.700]  Значит, как выглядит taif?
[55:33.700 --> 55:38.180]  Я пишу taif, да, я заголовок сейчас сделаю, 1.5 control statements.
[55:38.180 --> 55:43.140]  Значит, как пишется taif?
[55:43.140 --> 55:45.540]  Если условие какое-то, то есть, вот здесь вот пишется
[55:45.540 --> 55:49.060]  булевское выражение, которое, ну, то есть, здесь пишется
[55:49.060 --> 55:52.380]  выражение, которое должно быть приведено к типу буль.
[55:52.380 --> 55:57.420]  Здесь можно написать любое выражение, лишь бы оно к
[55:57.420 --> 55:58.700]  типу буль было приводимо.
[55:58.700 --> 56:06.260]  И дальше я пишу, соответственно, какой-то набор других инструкций,
[56:06.260 --> 56:10.380]  причем я могу либо написать одну инструкцию, и тогда
[56:10.380 --> 56:13.140]  мне фигурных скобок писать не надо, либо я пишу несколько,
[56:13.140 --> 56:15.860]  тогда я их в фигурных скобках пишу.
[56:15.860 --> 56:19.700]  И вот здесь вот у меня новая областидимость начинается,
[56:19.700 --> 56:20.540]  более локальная.
[56:20.540 --> 56:22.620]  Вот.
[56:22.620 --> 56:28.220]  Я могу написать так, могу написать if boolexpression и какой-то
[56:28.220 --> 56:31.740]  statement без фигурных скобок.
[56:31.740 --> 56:33.820]  Вот.
[56:33.820 --> 56:37.300]  Так тоже можно, тогда по default будет только вот этот statement.
[56:37.300 --> 56:42.700]  По кодстайлу мы, наверное, так будем стараться пореже писать,
[56:42.700 --> 56:45.780]  вас приучать писать в основном с фигурными скобками, но если
[56:45.780 --> 56:48.420]  какой-то if очень короткий, нужно сделать что-то очень маленькое,
[56:48.420 --> 56:50.220]  там if x больше нуля и y плюс плюс.
[56:50.220 --> 56:51.580]  Ну, хорошо, можно писать так.
[56:51.580 --> 56:59.420]  Я пишу if x больше нуля, там и, значит, говорю y плюс плюс.
[56:59.420 --> 57:00.420]  Вот.
[57:00.420 --> 57:05.980]  Это корректно, по default будет только это.
[57:05.980 --> 57:11.340]  У if есть else clause, так называемый, то есть я могу опционально
[57:11.340 --> 57:13.260]  после этой закрывающей фигурной скобки написать
[57:13.260 --> 57:17.900]  еще else, и здесь будет написано то, что нужно сделать, если
[57:17.900 --> 57:18.900]  условия не выполнены.
[57:18.900 --> 57:19.900]  Вот.
[57:20.540 --> 57:21.540]  Ну.
[57:28.820 --> 57:31.700]  Заметьте, кстати, кодстайл.
[57:31.700 --> 57:32.700]  Вот.
[57:32.700 --> 57:34.540]  Многие пишут вот так.
[57:34.540 --> 57:36.260]  Это мы будем банить.
[57:36.260 --> 57:39.140]  По кодстайлу, который рекомендует Google, который рекомендует
[57:39.140 --> 57:42.380]  Яндекс, который будем рекомендовать мы, else пишется на той же
[57:42.380 --> 57:45.020]  строке, на которой была предыдущая закрывающая фигурная скобка,
[57:45.100 --> 57:47.420]  и призываю вас также делать.
[57:47.420 --> 57:51.380]  Ну вот так не надо делать.
[57:51.380 --> 57:55.620]  Вы можете после else написать еще if, и по кодстайлу опять-таки
[57:55.620 --> 57:59.340]  это пишется на той же строке, на которой else, значит else if,
[57:59.340 --> 58:02.780]  и дальше какой-то там еще expression, bool expression.
[58:10.780 --> 58:11.780]  Вот.
[58:11.780 --> 58:16.700]  Вы можете таким образом делать сложные составные
[58:16.700 --> 58:17.700]  условия.
[58:17.700 --> 58:21.540]  Вот у вас есть один if, если он не верен, то проверьте
[58:21.540 --> 58:22.540]  другой if и так далее.
[58:22.540 --> 58:23.540]  Вот.
[58:23.540 --> 58:27.060]  Надеюсь, что вы не будете делать так.
[58:27.060 --> 58:30.420]  Тут некоторые зачем-то делают так, они берут и
[58:30.420 --> 58:34.820]  каждый следующ if начинают еще на уровень глубже.
[58:34.820 --> 58:38.060]  Вот так не надо делать, потому что вот эта запись,
[58:38.060 --> 58:40.940]  она по сути эквивалентна предыдущей записи, только
[58:40.940 --> 58:42.940]  на больший уровень вложенности спущена.
[58:42.940 --> 58:43.940]  Вот.
[58:43.940 --> 58:47.900]  Если вам нужно несколько if проверить один за другим,
[58:47.900 --> 58:51.740]  то оставляйте их на одном уровне, а не задвигайте
[58:51.740 --> 58:53.500]  в более глубокий уровень вложенности.
[58:53.500 --> 58:55.460]  Вообще уровень вложенности надо экономить.
[58:55.460 --> 59:00.500]  Вообще, кстати, есть такое наблюдение, это скорее
[59:00.500 --> 59:03.620]  наблюдение из области кодстайла, и оно у вас будет в кодстайле
[59:03.620 --> 59:07.380]  написано, который я вам скину, а что на самом деле
[59:07.380 --> 59:09.340]  else не так часто нужен.
[59:09.340 --> 59:10.340]  Вот.
[59:10.340 --> 59:12.140]  На практике, в большинстве случаев, когда вы пишете
[59:12.140 --> 59:15.460]  else, можно обойтись без него, и код проще станет.
[59:15.460 --> 59:16.460]  Вот.
[59:16.460 --> 59:17.460]  Последите за собой.
[59:17.460 --> 59:20.300]  На самом деле, когда вы что-то делаете при условии
[59:20.300 --> 59:23.420]  каком-то, обычно то, что вам нужно сделать без
[59:23.420 --> 59:25.940]  этого условия, это является подмножеством действий,
[59:25.940 --> 59:28.420]  которое нужно сделать при условии, и можно общую
[59:28.420 --> 59:32.460]  часть просто вынести из-под if, и у вас останется, ну
[59:32.460 --> 59:36.220]  как бы, код станет короче, исчезнет из него кэппипастные
[59:36.220 --> 59:37.220]  строки.
[59:37.620 --> 59:40.780]  Бывает такое, что при условии и при нарушении условия нужно
[59:40.780 --> 59:43.260]  сделать принципиально разные действия, вообще не похожие
[59:43.260 --> 59:46.220]  друг на друга, но чаще все-таки бывает так, что при условии
[59:46.220 --> 59:49.100]  вам надо что-то сделать, а при отсутствии условия
[59:49.100 --> 59:52.100]  сделать что-то, но поменьше, или наоборот.
[59:52.100 --> 59:53.980]  То есть, оно является подмножеством другого.
[59:53.980 --> 59:56.540]  В таком случае не нужно писать else, нужно просто вынести
[59:56.540 --> 01:00:00.860]  общую часть наружу за if, и оставить только if без else.
[01:00:00.860 --> 01:00:02.100]  Так просто код красивее будет.
[01:00:02.100 --> 01:00:10.780]  Значит, спрашивают про код стайл, первую скобку
[01:00:10.780 --> 01:00:11.780]  после if.
[01:00:11.780 --> 01:00:14.620]  Ну, в нашем код стайле мы рекомендуем делать вот
[01:00:14.620 --> 01:00:15.620]  так.
[01:00:15.620 --> 01:00:18.020]  Ну, опять-таки, это код стайл, который рекомендуется
[01:00:18.020 --> 01:00:21.900]  гуглом и яндексом, и он вот такой, мы будем ему следовать.
[01:00:21.900 --> 01:00:25.380]  У гугла и яндекса плюс-минус общий код стайл по C++, вот
[01:00:25.380 --> 01:00:30.380]  он такой.
[01:00:31.380 --> 01:00:40.380]  А сколько мы будем пробелов ставить в табли?
[01:00:40.380 --> 01:00:46.380]  В табли можно ставить либо 4, либо 2 пробела, главное,
[01:00:46.380 --> 01:00:48.380]  чтобы одинаково в течение всей программы.
[01:00:48.380 --> 01:00:54.740]  И вместо таблов нужно всегда ставить пробелы, самими
[01:00:54.740 --> 01:00:57.060]  таблами мы никогда пользоваться не будем, но у вас будет
[01:00:57.060 --> 01:01:00.180]  отдельный семинар, посвященный код стайлу, вскоре, и там
[01:01:00.180 --> 01:01:01.260]  вы про все это поговорите.
[01:01:01.260 --> 01:01:06.100]  Хорошо, if обсудили, давайте обсудим switch.
[01:01:06.100 --> 01:01:10.660]  Следующую управляющую конструкцию это switch, значит,
[01:01:10.660 --> 01:01:11.660]  что такое switch?
[01:01:11.660 --> 01:01:15.540]  Это способ выбрать из многих вариантов, что делать.
[01:01:15.540 --> 01:01:21.820]  Так пишется switch x, где x – это целое число, ну или
[01:01:21.820 --> 01:01:24.420]  здесь некоторые волочительные выражения можно написать,
[01:01:24.420 --> 01:01:26.500]  и в зависимости от чего, от чему оно равно, вы можете
[01:01:26.500 --> 01:01:30.340]  делать разные вещи, например, case 1, если оно равно единице,
[01:01:30.340 --> 01:01:31.340]  то что-то сделать.
[01:01:31.340 --> 01:01:48.460]  Значит вот, do something, а дальше case 2, еще раз do something, ну
[01:01:48.460 --> 01:01:53.300]  и так далее, case 3, еще do something.
[01:01:53.300 --> 01:01:57.700]  Не обязательно случаи делать подряд, и вообще не обязательно
[01:01:57.700 --> 01:01:59.660]  они хоть как-то должны быть упорядоченны, я могу сказать
[01:01:59.660 --> 01:02:09.660]  case 1, потом case 8, case 5, и тут опять do something, так, вот.
[01:02:09.660 --> 01:02:14.860]  В конце я могу сказать default, default это на случай, если
[01:02:14.860 --> 01:02:19.700]  у меня ни один из кейсов не сработал, и после default
[01:02:19.700 --> 01:02:24.740]  я опять могу сказать что-то сделать, и это будет сделано
[01:02:24.740 --> 01:02:27.220]  в случае, если вот ни один из предыдущих кейсов не
[01:02:27.220 --> 01:02:28.220]  выполнился.
[01:02:28.220 --> 01:02:33.180]  Тут есть одна очень большая подлость, а именно в C++, как
[01:02:33.180 --> 01:02:36.540]  и в C, switch работает следующим образом, что если у вас какой-то
[01:02:36.540 --> 01:02:41.340]  кейс выполнился, то считается, что выполнены все кейсы
[01:02:41.340 --> 01:02:42.340]  после него.
[01:02:42.340 --> 01:02:43.340]  Ну то есть, что это значит?
[01:02:43.340 --> 01:02:47.980]  Если x сейчас был равен единице, я встану вот на эту метку
[01:02:47.980 --> 01:02:51.340]  и выполнится не только вот это do something, а все ниже
[01:02:51.340 --> 01:02:52.340]  лежащие тоже.
[01:02:52.340 --> 01:02:56.260]  То есть, как бы формально находится просто первая
[01:02:56.260 --> 01:02:59.300]  метка, которая соответствует тому, чему надо, и все, что
[01:02:59.300 --> 01:03:02.620]  ниже нее выполняется, буквально делается прыжок на вот эту
[01:03:02.620 --> 01:03:05.340]  метку, и все, что ниже нее выполняется.
[01:03:05.340 --> 01:03:07.980]  Если вы хотите, чтобы у вас выполнилось только то,
[01:03:07.980 --> 01:03:10.660]  что находится вот в этой секции, но не то, что ниже
[01:03:10.660 --> 01:03:15.420]  до следующих меток, вы здесь пишете break, break это управляющее
[01:03:15.420 --> 01:03:20.500]  слово, которое говорит, что, ну, закончим, выходи
[01:03:20.500 --> 01:03:21.500]  отсюда.
[01:03:21.500 --> 01:03:24.700]  Вот в данном случае, если у меня x равен единице, выполнится
[01:03:24.700 --> 01:03:25.700]  только это.
[01:03:25.700 --> 01:03:30.020]  Если x равен восьми, впрочем, выполнится и это, и это, и
[01:03:30.020 --> 01:03:31.020]  это.
[01:03:31.020 --> 01:03:33.020]  Если x равен пяти, то выполнится вот это, и это.
[01:03:33.020 --> 01:03:35.700]  Если x не равен ничему из вышеперечитенного, то выполнится
[01:03:35.700 --> 01:03:36.700]  только это.
[01:03:36.700 --> 01:03:40.900]  Я могу написать break вот здесь, допустим, а здесь
[01:03:40.900 --> 01:03:41.900]  не писать.
[01:03:41.900 --> 01:03:44.860]  Тогда при восьмерке у меня выполнится и это, и это.
[01:03:44.860 --> 01:03:47.740]  При пятерке выполнится только это, при всех остальных
[01:03:47.740 --> 01:03:51.620]  значениях выполнится только это.
[01:03:51.620 --> 01:03:52.620]  Вот.
[01:03:52.620 --> 01:03:57.260]  Ну, обратите внимание опять на код style, но только я ставлю
[01:03:57.260 --> 01:03:58.260]  отступы.
[01:03:58.260 --> 01:04:02.540]  То есть после switch я ставлю фигурную скобку, и дальше
[01:04:02.540 --> 01:04:06.280]  у меня есть вот, как бы, внутренняя область видимости,
[01:04:06.280 --> 01:04:09.260]  метки, вот эти кейсы, я ставлю на том же уровне,
[01:04:09.260 --> 01:04:11.980]  на котором стоял switch, а то, что внутри, я пишу уже
[01:04:11.980 --> 01:04:12.980]  собственному.
[01:04:12.980 --> 01:04:21.340]  Так, это по поводу switch.
[01:04:21.340 --> 01:04:22.340]  Теперь циклы.
[01:04:22.340 --> 01:04:30.300]  Ну, есть цикл while, да, опять плохо слышно.
[01:04:30.300 --> 01:04:34.940]  Извините, сейчас, то есть, если кратко, то switch, мы говорим
[01:04:34.940 --> 01:04:37.340]  switch, просто пишем далее кейс какой-то, какой-то,
[01:04:37.340 --> 01:04:38.340]  какой-то.
[01:04:38.340 --> 01:04:39.340]  Да.
[01:04:39.500 --> 01:04:42.780]  Типа кейс один, кейс восемь, кейс пять.
[01:04:42.780 --> 01:04:44.780]  Ты хочешь проверить, чему равен х?
[01:04:44.780 --> 01:04:47.060]  Нет, я хочу понять, откуда берутся номера.
[01:04:47.060 --> 01:04:51.460]  Нет, в смысле, тебе здесь написано буквально следующее,
[01:04:51.460 --> 01:04:55.220]  если х равен одному, то сделай это, иначе, если х равен
[01:04:55.220 --> 01:04:58.580]  восьми, то сделай это, иначе, если х равен пяти, то сделай
[01:04:58.580 --> 01:05:00.060]  это, иначе сделай это.
[01:05:00.060 --> 01:05:04.220]  Это просто более короткий, более, ну, так сказать, правильный
[01:05:04.220 --> 01:05:06.860]  способ выбрать из нескольких вариантов, чему может быть
[01:05:06.860 --> 01:05:07.860]  равен х.
[01:05:07.860 --> 01:05:10.340]  Вместо того, чтобы писать if, else, if, else, if, else, if, можно
[01:05:10.340 --> 01:05:12.420]  писать switch и просто для разных вариантов сделать
[01:05:12.420 --> 01:05:13.420]  разные.
[01:05:13.420 --> 01:05:16.020]  И, типа, он первый, он прыгает на первую метку, которая
[01:05:16.020 --> 01:05:18.140]  выполнится, и все, что ниже, заведомо делает, если нет
[01:05:18.140 --> 01:05:19.140]  брейка.
[01:05:19.140 --> 01:05:21.860]  Да, да, до ближайшего брейка, и до ближайшего брейка
[01:05:21.860 --> 01:05:22.860]  делает.
[01:05:22.860 --> 01:05:24.820]  А дефолт всегда делает.
[01:05:24.820 --> 01:05:29.060]  Дефолт – это если ни одна из этих меток не сработала.
[01:05:29.060 --> 01:05:32.460]  Если он все метки проверил и ни одна из них не выполнилась,
[01:05:32.460 --> 01:05:35.100]  то он делает то, что после дефолта написано, но дефолт
[01:05:35.100 --> 01:05:37.860]  необязательно писать, может не быть никого дефолта,
[01:05:37.860 --> 01:05:40.420]  тогда просто ничего не сделает, если ни одна из меток не сработает.
[01:05:40.420 --> 01:05:42.820]  То есть, если ни что не сработало, окей.
[01:05:42.820 --> 01:05:43.820]  Да.
[01:05:43.820 --> 01:05:46.660]  Так, значит, это был switch.
[01:05:46.660 --> 01:05:49.660]  Теперь циклы.
[01:05:49.660 --> 01:05:56.180]  Ну, самый простой – это цикл while, здесь у вас какое-то
[01:05:56.180 --> 01:06:03.660]  буллевское выражение, и тут какой-то набор действий.
[01:06:04.060 --> 01:06:09.500]  Ну как работает while – проверяется, истинно ли вот это, если
[01:06:09.500 --> 01:06:12.740]  истинно, то выполняется то, что в фигурных скобках,
[01:06:12.740 --> 01:06:15.820]  и снова проверяется – истинно ли вот это, если истинно,
[01:06:15.820 --> 01:06:18.260]  то выполняется то, что в ущербных скобках, и снова
[01:06:18.260 --> 01:06:20.960]  проверяется – истинно ли вот это, если истинно, то
[01:06:20.960 --> 01:06:24.060]  выполняется то, что в ущербных скобках, ну и так далее.
[01:06:24.060 --> 01:06:28.340]  А если в любой из этих моментов оно ложно, то то, что фигурно
[01:06:28.340 --> 01:06:30.200]  скобки не выполняем, сразу начинает выполняться то,
[01:06:30.200 --> 01:06:31.200]  что после идёт.
[01:06:31.200 --> 01:06:42.040]  А точно так же с while как и с if можно у вас может быть инструкция из одного просто действия
[01:06:42.040 --> 01:06:48.840]  состоять и не обязательно фигурные скобки тогда ставить. Но по код стайлу мы будем вот в циклах
[01:06:48.840 --> 01:06:55.000]  всегда требовать фигурные скобки, потому что иначе это трудно читаемый код и не рекомендуется так
[01:06:55.000 --> 01:07:02.640]  делать без фигурных скобок цикла писать. Хотя формально это корректно так писать. Здесь может
[01:07:02.640 --> 01:07:10.840]  быть любое буллевское выражение, в том числе и то, которое приводится к буль, хотя само тип буль
[01:07:10.840 --> 01:07:19.240]  явно не имеет. Этот цикл с предусловием. Есть цикл с постусловием do while. Он выглядит так do
[01:07:19.520 --> 01:07:25.100]  фигурной скобки а дальше while и здесь какое-то условие.
[01:07:30.400 --> 01:07:35.920]  Значе точка запятой вот здесь ставится. Как это работает? выполняется в любом случае то, что
[01:07:35.920 --> 01:07:41.360]  в фигурных скобках. Потом только проверяется условия и если оно верно, то снова выполняется
[01:07:41.360 --> 01:07:45.720]  то что в фигурных скобках и опять проверяется условие если оно верно то опять выполняется то
[01:07:45.720 --> 01:07:49.840]  в фигуроскопках и так далее. Как только это условие становится неверным, мы идем дальше выполнять.
[01:07:49.840 --> 01:08:01.120]  Вот. Понятно, что в чем разница между вот этим циклом и вот этим принципиально? В том, что в этом цикле,
[01:08:01.120 --> 01:08:07.120]  если условие изначально ложно, то цикл не выполнется ни разу. Если в этом цикле условие изначально
[01:08:07.120 --> 01:08:11.640]  ложно, то цикл выполнится один раз все равно и только потом проверит условие и перестанет выполнять.
[01:08:11.640 --> 01:08:24.280]  Это цикл с предусловием, это цикл с постусловием. Ну и самый мощный цикл. Да, с do-while тоже возможно
[01:08:24.280 --> 01:08:31.840]  всего одно действие. То есть, например, я могу написать do++x while какое-то условие. Вот я могу
[01:08:31.840 --> 01:08:36.680]  так даже написать. Но опять-таки по код стайлу мы так не будем рекомендовать писать, а будем
[01:08:36.680 --> 01:08:44.560]  требовать фигурные скобки. While пишется на той же строке, что и закрывающая фигурная скобка
[01:08:44.560 --> 01:08:55.840]  перед ним. Ну и самый мощный цикл это for. Значит, for на самом деле позволяет имитировать все остальные
[01:08:55.840 --> 01:09:03.120]  циклы и вообще, строго говоря, вам другие циклы-то и не нужны, все можно for-ом сделать. Но они
[01:09:03.120 --> 01:09:09.800]  используются для красоты, это такие более простые циклы, что ли, для минималистичной версии.
[01:09:09.800 --> 01:09:25.120]  Что делает for? Значит, у for следующий синексис for initializer, дальше bool expression, дальше iteration
[01:09:25.120 --> 01:09:38.560]  и здесь тело цикла. Значит, что такое initializer? Это некоторое объявление или выражение,
[01:09:38.560 --> 01:09:44.840]  которое будет проделано в самом начале цикла. Если это объявление, то вы тем самым ведете
[01:09:44.840 --> 01:09:50.000]  переменную область видимости, которая будет считаться вот этим вот циклом и тем, что внутри
[01:09:50.000 --> 01:09:56.000]  него. Вот. Ну, традиционный способ, что здесь можно написать, это объявить какой-нибудь счетчик int
[01:09:56.000 --> 01:10:03.000]  и равно нулю, например. Вот. Я могу здесь объявить несколько переменных. Я могу не обязательно int
[01:10:03.000 --> 01:10:07.960]  объявить, я могу объявить какой угодно тип. А я могу вообще ничего не объявлять, могу просто изначально
[01:10:07.960 --> 01:10:12.200]  что-то сделать. Вот так, например, могу сделать, если и до этого был какой-то переменный. То есть
[01:10:12.200 --> 01:10:17.560]  здесь я могу сделать любое объявление или expression. Любой абсолютно declaration или expression
[01:10:17.560 --> 01:10:21.960]  здесь подойдет. Ну, declaration переменной я имею в виду. Понятно, что не могу здесь объявить using или
[01:10:21.960 --> 01:10:27.160]  объявить функцию. Переменную я могу только объявить. Могу несколько переменных объявить через запятую.
[01:10:27.160 --> 01:10:32.760]  И это все еще не будет оператором запятая, напоминаю, в объявлениях. Вот это не оператор запятая.
[01:10:32.760 --> 01:10:40.520]  Дальше Boolean expression. Здесь любой expression, который приводится к bool. Например, проверка того,
[01:10:40.520 --> 01:10:46.480]  что и меньше чего-нибудь. И меньше десяти. Но здесь может быть любой boole expression. Здесь может
[01:10:46.480 --> 01:10:51.400]  быть любой expression, который будет приводиться к bool. Если он не приводится к bool, то будет ошибка
[01:10:51.400 --> 01:10:57.480]  компиляции. Итерация это просто любой expression. Вообще любой expression. Как правило, здесь пишут
[01:10:57.480 --> 01:11:05.600]  increment, но можно делать и decrement. А можно делать и плюс равно два, например. А можно делать что-то
[01:11:05.600 --> 01:11:15.080]  вообще не связанное со счетчиком. Можно говорить аито равно одному. Аито равно и. И, пожалуйста,
[01:11:15.080 --> 01:11:26.040]  вы просто будете так, значит, можно вот так написать, и вы будете просто все элементы какого-то
[01:11:26.040 --> 01:11:32.240]  массива А приравнивать очередному индексу И. А это вот уже оператор запятая. И таким образом
[01:11:32.240 --> 01:11:39.120]  вы в одном expression и присваивание делаете, и increment. Вы можете и вот так делать. Вы как бы
[01:11:39.120 --> 01:11:47.120]  присвоили и после этого и увеличилось. Извините, а корректно ли по двумерному массиву проходить
[01:11:47.120 --> 01:11:54.240]  одним таким циклам в форум только с двумя initializers или это некрасиво? Нет, ну это корректно,
[01:11:54.240 --> 01:12:01.160]  но это некрасиво. Вы можете синтоксически вам сказать, здесь можно любой declaration,
[01:12:01.160 --> 01:12:06.480]  в том числе несколько переменных объявить. Здесь любой boole expression, а здесь вообще любой
[01:12:06.480 --> 01:12:12.120]  expression. В том числе здесь может быть присваивание оператора запятая, тиранарная оператор,
[01:12:12.120 --> 01:12:16.520]  что угодно. Любой экспривызов функций здесь может быть. Здесь может быть куча действий
[01:12:16.520 --> 01:12:21.600]  через запятую. Это все будет expression. Синтоксически это будет корректно. Компилятор это скомпилирует,
[01:12:21.600 --> 01:12:32.120]  но рекомендуется все-таки писать так, чтобы понятно было. Стандартный самый вид цикла
[01:12:32.120 --> 01:12:37.240]  for это вот такой, то есть когда вы берете счетчик и этим счетчиком проходите до какого-то значения,
[01:12:37.240 --> 01:12:44.120]  а потом выходите. Здесь вы делаете значит какие-то действия. Как работает for? Сначала
[01:12:44.120 --> 01:12:49.640]  происходит вот этот declaration или expression, так сказать, инициализация цикла. Сразу же проверяется
[01:12:49.640 --> 01:12:55.920]  условия. После этого выполняется тело цикла, если оно истинно. Дальше, после того, как тело цикла в
[01:12:55.920 --> 01:13:00.840]  первый раз выполнилось, впервые делается вот это выражение, вычисляется. И снова проверяется
[01:13:01.000 --> 01:13:06.500]  условие. Если условие истины, мы опять заходим в тело цикла и опять вычисляем вот это выражение,
[01:13:06.500 --> 01:13:12.020]  а потом опять проверяем условие и опять заходим в тело цикла. Потом опять вычисляем это выражение,
[01:13:12.020 --> 01:13:15.920]  опять заходим опять проверяем это условие и опять заходим в тело цикла. И так мы делаем
[01:13:15.920 --> 01:13:20.060]  до тех пор пока наконец не произойдет такого, что это выражение ложно. Как только это выражение
[01:13:20.060 --> 01:13:26.060]  выражение ложно, мы перестаем заходить в тело цикла и дальше идем сразу сюда.
[01:13:26.060 --> 01:13:33.060]  А, значит, вот.
[01:13:33.060 --> 01:13:38.060]  Можно в форе любую из вот этих трех секций оставить пустой,
[01:13:38.060 --> 01:13:40.060]  то есть можно, например, ничего вот здесь не написать,
[01:13:40.060 --> 01:13:42.060]  это будет означать, что вы просто ничего не объявили вначале,
[01:13:42.060 --> 01:13:44.060]  ну и ничего не сделали.
[01:13:44.060 --> 01:13:47.060]  Можно вот эту секцию оставить пустой, и тогда это будет считаться,
[01:13:47.060 --> 01:13:49.060]  как будто все время у вас true.
[01:13:49.060 --> 01:13:51.060]  А можно вот эту оставить пустой, и тогда будет считаться просто,
[01:13:51.060 --> 01:13:55.060]  что вы ничего на каждой итерации не имплементируете, ничего не делаете.
[01:13:55.060 --> 01:14:00.060]  Можно просто вот так написать, и это будет бесконечный цикл.
[01:14:00.060 --> 01:14:03.060]  Вот.
[01:14:03.060 --> 01:14:08.060]  А существует два управляющих слова, которые позволяют,
[01:14:08.060 --> 01:14:11.060]  так сказать, влиять на ход выполнения цикла.
[01:14:11.060 --> 01:14:13.060]  Это break и continue.
[01:14:13.060 --> 01:14:23.060]  Значит, слово break внутри цикла означает, что нужно выброгнуть из цикла,
[01:14:23.060 --> 01:14:25.060]  независимо от того, какие там у вас были условия от цикла,
[01:14:25.060 --> 01:14:30.060]  просто как только встречается команда break внутри цикла,
[01:14:30.060 --> 01:14:33.060]  все, с этого момента из цикла происходит выход,
[01:14:33.060 --> 01:14:36.060]  и вы сразу же оказываетесь вот здесь.
[01:14:36.060 --> 01:14:40.060]  Ну, обычно никто не пишет break просто так, обычно break пишут по default,
[01:14:40.060 --> 01:14:45.060]  то есть если там что-то произошло, то break.
[01:14:45.060 --> 01:14:50.060]  То есть вы делаете, делаете цикл, и вдруг в середине цикла вы поняли,
[01:14:50.060 --> 01:14:53.060]  что если что-то случилось, то надо сразу же выпрыгнуть из цикла.
[01:14:53.060 --> 01:14:56.060]  Когда происходит break, вот здесь больше никакие условия не проверяются,
[01:14:56.060 --> 01:14:59.060]  ничего не вычисляется, вы сразу же выходите вот сюда.
[01:14:59.060 --> 01:15:03.060]  При этом, разумеется, все локальные переменные, которые действовали внутри цикла, уничтожаются.
[01:15:03.060 --> 01:15:08.060]  Вы остаетесь только с теми локальными переменными, которые были во внешней области.
[01:15:08.060 --> 01:15:13.060]  Вот, к сожалению, в C++, как и в C, нельзя сделать break сразу с нескольких уровней,
[01:15:13.060 --> 01:15:18.060]  можно сделать break только из цикла, и только из самого вложенного цикла.
[01:15:18.060 --> 01:15:21.060]  А как же go2?
[01:15:21.060 --> 01:15:26.060]  Ну, go2 это вообще другая история, про него я сейчас вкратце скажу,
[01:15:26.060 --> 01:15:33.060]  но именно словом break сделать выпрыгивание на 1 уровне вверх, например, нельзя.
[01:15:33.060 --> 01:15:41.060]  Вот, ну и второе слово, которое позволяет управлять ходом выполнения цикла, это continue.
[01:15:41.060 --> 01:15:44.060]  Это еще одно ключевое слово, еще одно управляющее слово,
[01:15:44.060 --> 01:15:50.060]  которое говорит, что нужно забить на весь остаток цикла и вернуться к началу.
[01:15:50.060 --> 01:15:57.060]  То есть снова вычислить вот это, снова, значит, сейчас я снова напишу, что тут было,
[01:15:57.060 --> 01:16:03.060]  значит, и меньше десяти, да. Вот, continue говорит, что нужно забить на все оставшиеся команды
[01:16:03.060 --> 01:16:08.060]  внутри цикла и сразу вернуться сюда, то есть вычислить снова вот это и снова проверить условия,
[01:16:08.060 --> 01:16:14.060]  ну, то есть закончить эту итерацию преждевременно, забить на остаток и вернуться сюда.
[01:16:14.060 --> 01:16:20.060]  Ну, опять-таки, continue никто не пишет просто так, его, как правило, пишут под if,
[01:16:20.060 --> 01:16:25.060]  если x равно 1, continue. Это значит, если вот мы дошли до этого места и выяснили,
[01:16:25.060 --> 01:16:29.060]  что здесь x равно 1, то все, что дальше написано, мы в этот раз не делаем,
[01:16:29.060 --> 01:16:34.060]  а сразу переходим к следующему шагу, то есть опять инкриментируем, опять проверяем меньше десяти.
[01:16:34.060 --> 01:16:39.060]  Аналогично можно делать break, continue в while и в do while.
[01:16:39.060 --> 01:16:44.060]  Вот, в if и в switch делать break, continue нельзя, ну, в switch можно делать break,
[01:16:44.060 --> 01:16:49.060]  он там имеет другое значение, а в if под if делать break, continue нельзя.
[01:16:49.060 --> 01:16:58.060]  Ну, еще два управляющих слова, о которых я расскажу, это go to и return.
[01:16:58.060 --> 01:17:03.060]  Давайте сначала go to. Go to это довольно слово с плохой репутацией,
[01:17:03.060 --> 01:17:09.060]  это слово, которое позволяет вам просто прыгнуть на произвольное место кода из данного места.
[01:17:09.060 --> 01:17:15.060]  То есть вы можете написать, у вас есть какая-то, вы можете в коде ставить метки,
[01:17:15.060 --> 01:17:23.060]  вот я могу сказать label и сделать в какой-то момент go to label.
[01:17:23.060 --> 01:17:27.060]  По сути, я могу так циклы имитировать.
[01:17:27.060 --> 01:17:33.060]  Это крайне не рекомендуется, это нужно в очень редких случаях, значит,
[01:17:33.060 --> 01:17:39.060]  это в древние, там, на заре 80-х годов, когда программирование только зарождалось, значит,
[01:17:39.060 --> 01:17:44.060]  так люди писали, но сейчас в современных языках программирования это очень осуждается,
[01:17:44.060 --> 01:17:47.060]  и рекомендуется так не делать почти никогда.
[01:17:47.060 --> 01:17:52.060]  Очень редкие случаи, когда так все-таки стоит писать.
[01:17:52.060 --> 01:17:55.060]  Ну, они бывают, но, наверное, мы не будем их обсуждать.
[01:17:55.060 --> 01:17:58.060]  Ну, в общем, такая возможность есть по историческим причинам,
[01:17:58.060 --> 01:18:01.060]  вы можете в коде ставить в произвольном месте метки,
[01:18:01.060 --> 01:18:06.060]  и в какой-то момент, если какое-то условие выполнилось, говорить go to это метка.
[01:18:06.060 --> 01:18:12.060]  Ну, например, теоретически так можно выпрыгивать сразу из нескольких уровней вложенности цикла.
[01:18:12.060 --> 01:18:19.060]  Правда, с C и C++ есть трудности в этом плане, что если вы, например, с помощью go to попытаетесь
[01:18:19.060 --> 01:18:23.060]  запрыгнуть внутрь, наоборот, какой-то области видимости, скажем, у вас есть цикл,
[01:18:23.060 --> 01:18:28.060]  и вы хотите запрыгнуть внутрь него с помощью go to, вам, скорее всего, выдастся ошибка компиляции,
[01:18:28.060 --> 01:18:34.060]  потому что нельзя делать прыжки через go to, минуя объявления каких-то переменных, например.
[01:18:34.060 --> 01:18:38.060]  У вас в цикле есть какие-то внутренние переменные, вы не можете запрыгнуть в середину,
[01:18:38.060 --> 01:18:44.060]  минуя их объявления, минуя их инициализацию, потому что непонятно тогда, чему эти переменные равны
[01:18:44.060 --> 01:18:47.060]  должны стать и в какой момент они должны создаться.
[01:18:47.060 --> 01:18:53.060]  Но выпрыгивать наружу из циклов можно с помощью go to, и можно таким образом выпрыгивать из нескольких сразу.
[01:18:53.060 --> 01:18:57.060]  Но я все равно не рекомендую вам так делать, это довольно...
[01:18:57.060 --> 01:19:00.060]  В общем, подумайте несколько раз прежде чем это применить.
[01:19:00.060 --> 01:19:07.060]  Это считается очень плохим код-стайлом, так писать это очень запутывает логику выполнения.
[01:19:07.060 --> 01:19:12.060]  Ну и есть слово return.
[01:19:12.060 --> 01:19:15.060]  Return – это слово, которое означает возврат из функции.
[01:19:15.060 --> 01:19:17.060]  Простите, можно вопрос?
[01:19:17.060 --> 01:19:18.060]  Да.
[01:19:18.060 --> 01:19:22.060]  А насчет прошлого там, где вы написали label, а потом go to label, что это в принципе значило?
[01:19:22.060 --> 01:19:24.060]  Label – это что, команда какая-то?
[01:19:24.060 --> 01:19:27.060]  Label – это, значит, специальная...
[01:19:27.060 --> 01:19:35.060]  Ну вот C++ позволяет ставить метки, то есть можно строки кода помечать какими-то метками.
[01:19:35.060 --> 01:19:41.060]  Label, то есть я могу перед произвольной строкой кода сказать abcdef и поставить двоеточие.
[01:19:41.060 --> 01:19:43.060]  Это будет называться меткой.
[01:19:43.060 --> 01:19:45.060]  То есть я эту строку кода пометил.
[01:19:45.060 --> 01:19:51.060]  И это нужно для того, что если я потом хочу сказать go to, я могу назвать какую-то метку.
[01:19:51.060 --> 01:19:57.060]  Просто будет со соответствующей строкой кода ассоциирована вот такая метка, по которой двоеточие стоит.
[01:19:58.060 --> 01:20:02.060]  И можно, например, как это можно сказать?
[01:20:02.060 --> 01:20:06.060]  У нас в цикле есть while, и мы там просто пишем go to label, и он просто выпрыгивает из цикла и идет туда.
[01:20:06.060 --> 01:20:09.060]  Почему? То есть допустим какой-то if сработал, да?
[01:20:09.060 --> 01:20:14.060]  Ну вот у меня есть допустим...
[01:20:14.060 --> 01:20:18.060]  Вот у меня есть какая-нибудь метка abcdef.
[01:20:18.060 --> 01:20:23.060]  И вот у меня есть какой-то while, а внутри него...
[01:20:23.060 --> 01:20:28.060]  Вообще я не хочу эти примеры показывать, потому что вам не нужно этого писать никогда.
[01:20:28.060 --> 01:20:31.060]  Я вам показываю пример того, чем никогда нельзя...
[01:20:31.060 --> 01:20:33.060]  А, ну хоть бы ладно.
[01:20:33.060 --> 01:20:36.060]  Это запрещенные приемы, так не надо делать.
[01:20:36.060 --> 01:20:51.060]  Ну вот я могу почему-то вдруг, там if что-то случилось, там я не знаю, x не равно y, я могу вот здесь написать go to abcdef.
[01:20:51.060 --> 01:20:55.060]  А abcdef это метка, которая после этих двух while стоит.
[01:20:55.060 --> 01:21:00.060]  То есть таким образом я смогу выпрыгнуть сразу с двух уровней цикла.
[01:21:00.060 --> 01:21:02.060]  Вот.
[01:21:02.060 --> 01:21:05.060]  Если бы я написал break, то я бы выпрыгнул только из внутреннего цикла.
[01:21:05.060 --> 01:21:08.060]  А я хочу выпрыгнуть сразу с двух циклов.
[01:21:08.060 --> 01:21:10.060]  И это могу вот таким образом сделать.
[01:21:10.060 --> 01:21:11.060]  Можем вопрос?
[01:21:11.060 --> 01:21:13.060]  Да.
[01:21:13.060 --> 01:21:18.060]  Вот вы говорите, что типа go to запрещенный прием, а как тогда вы выпрыгиваете с двух циклов?
[01:21:18.060 --> 01:21:20.060]  С помощью флагов, что ли?
[01:21:20.060 --> 01:21:35.060]  Давайте так скажу.
[01:21:35.060 --> 01:21:40.060]  Вот я 12 лет программирую на C++.
[01:21:40.060 --> 01:21:45.060]  И много где работал в разных компаниях.
[01:21:45.060 --> 01:21:47.060]  Там в Яндексе два с половиной года.
[01:21:47.060 --> 01:21:48.060]  Там в ВК.
[01:21:48.060 --> 01:21:50.060]  И значит еще кое-где.
[01:21:50.060 --> 01:21:51.060]  И олимпиадки писал.
[01:21:51.060 --> 01:21:54.060]  Ни разу все в это время обходился без go to почему-то.
[01:21:54.060 --> 01:21:55.060]  Не знаю.
[01:21:55.060 --> 01:21:56.060]  Как-то вот.
[01:21:56.060 --> 01:22:03.060]  Ну типа есть подозрение, что если писать хороший код, то go to не нужен.
[01:22:03.060 --> 01:22:08.060]  Ну то есть да, вы можете теоретически извратиться и придумать ситуацию, когда только go to вас спасет.
[01:22:08.060 --> 01:22:15.060]  Но вот я утверждаю, что если вы все нормально пишете, то вам go to ну очень вряд ли пригодится.
[01:22:15.060 --> 01:22:20.060]  В этом году, в этом курсе он вам не пригодится ни разу.
[01:22:20.060 --> 01:22:21.060]  Нет, я пользовался go to.
[01:22:21.060 --> 01:22:23.060]  Вот были случаи, когда я пользовался go to.
[01:22:23.060 --> 01:22:26.060]  Это было там в некоторой компании.
[01:22:26.060 --> 01:22:29.060]  И это было на чистом C.
[01:22:29.060 --> 01:22:31.060]  Вот на плюсах я никогда не пользовался go to.
[01:22:31.060 --> 01:22:33.060]  На чистом C я пользовался go to.
[01:22:33.060 --> 01:22:37.060]  Но не для того, чтобы выпрыгнуть из многих циклов, а для других целей.
[01:22:37.060 --> 01:22:38.060]  Но там это было оправдано.
[01:22:38.060 --> 01:22:43.060]  Там это нужно было для того, чтобы освобождение ресурса в правильном порядке работало.
[01:22:43.060 --> 01:22:44.060]  Вот.
[01:22:44.060 --> 01:22:47.060]  Ну когда вы на чистом C пишете, это, наверное, смысленно иногда.
[01:22:47.060 --> 01:22:49.060]  Но если вы пишете на плюсах...
[01:22:49.060 --> 01:22:55.060]  Ну вот я за все годы своей, так сказать, практики ни разу не встретил необходимости.
[01:22:55.060 --> 01:22:57.060]  Возможно, и вы не встретите.
[01:22:57.060 --> 01:22:59.060]  Я думаю, что и вы не встретите.
[01:22:59.060 --> 01:23:01.060]  Скажем так.
[01:23:01.060 --> 01:23:02.060]  Давайте последнее.
[01:23:02.060 --> 01:23:03.060]  Это слово return.
[01:23:03.060 --> 01:23:04.060]  Ну про return все понятно.
[01:23:04.060 --> 01:23:06.060]  Это способ вернуться из функции.
[01:23:06.060 --> 01:23:08.060]  То есть если вы находитесь в какой-то функции...
[01:23:08.060 --> 01:23:11.060]  Кстати, к вопросу о том, как выйти сразу из нескольких циклов.
[01:23:11.060 --> 01:23:15.060]  Вот, пожалуйста, представьте, что у вас есть функция, и вам нужно выйти из нее.
[01:23:19.060 --> 01:23:21.060]  Ой, я лишнее удалил.
[01:23:21.060 --> 01:23:22.060]  Ну ладно.
[01:23:22.060 --> 01:23:26.060]  Вот представьте, что у меня есть функция, и мне надо выйти из функции.
[01:23:26.060 --> 01:23:28.060]  Я могу написать return.
[01:23:28.060 --> 01:23:32.060]  Слово return позволяет вам выпрыгнуть сразу из функции, в которой вы сейчас находитесь.
[01:23:32.060 --> 01:23:34.060]  Вот это хорошая замена GoTo.
[01:23:34.060 --> 01:23:38.060]  Кстати, если у вас есть какая-то длинная сложная операция из циклов,
[01:23:38.060 --> 01:23:42.060]  и вам нужно, значит, из нее выпрыгивать, вы можете в отдельную функцию вынести,
[01:23:42.060 --> 01:23:44.060]  и тогда просто return выходить из нее.
[01:23:44.060 --> 01:23:46.060]  Return это значит выйти из функции.
[01:23:46.060 --> 01:23:50.060]  Можно, если функция возвращает что-то, например, int,
[01:23:50.060 --> 01:23:54.060]  то вам нужно после return написать, что она возвращает.
[01:23:54.060 --> 01:23:56.060]  Это return 0.
[01:23:56.060 --> 01:23:58.060]  Ну, я могу аналогично из main выходить.
[01:23:58.060 --> 01:24:01.060]  Например, я могу написать return 1 в main.
[01:24:01.060 --> 01:24:03.060]  Main это же функция, которая возвращает int.
[01:24:03.060 --> 01:24:06.060]  Я могу внутри любого места main написать return какой-то int,
[01:24:06.060 --> 01:24:10.060]  и тем самым у меня выполнение закончится на этом месте.
[01:24:10.060 --> 01:24:11.060]  Вот.
[01:24:11.060 --> 01:24:13.060]  Ну, вот как вариант на замену GoTo,
[01:24:13.060 --> 01:24:16.060]  выпрыгивание из этих циклов можно сделать с помощью return,
[01:24:16.060 --> 01:24:19.060]  если внутри функции находим.
[01:24:19.060 --> 01:24:23.060]  А функцию можно прописать внутри main, например?
[01:24:23.060 --> 01:24:26.060]  Нет, функции объявлять внутри других функций,
[01:24:26.060 --> 01:24:28.060]  определять внутри других функций нельзя.
[01:24:28.060 --> 01:24:30.060]  Я уже говорил про это.
[01:24:30.060 --> 01:24:32.060]  Тогда у этого же будет большая проблема,
[01:24:32.060 --> 01:24:37.060]  как у нас в main может быть уже использована структура данных и так далее,
[01:24:37.060 --> 01:24:39.060]  которых не будет в области видимости.
[01:24:39.060 --> 01:24:42.060]  И они будут не доступны функциям.
[01:24:42.060 --> 01:24:46.060]  Ну, в общем, я утверждаю, что если вы пишете хороший код,
[01:24:46.060 --> 01:24:49.060]  то все эти проблемы решаем мы без GoTo.
[01:24:49.060 --> 01:24:52.060]  В общем, вы, когда начнете писать,
[01:24:52.060 --> 01:24:57.060]  вы увидите, что как-то, в общем, вы справляетесь, скорее всего.
[01:24:57.060 --> 01:25:00.060]  Ну, короче, до крайней случаи это слово есть,
[01:25:00.060 --> 01:25:05.060]  но пользоваться им, я думаю, вам не пригодится никогда.
[01:25:05.060 --> 01:25:08.060]  Все, мы с вами закончили говорить про control стейтменты.
[01:25:08.060 --> 01:25:11.060]  На самом деле есть еще один, который я вам не назвал.
[01:25:11.060 --> 01:25:14.060]  Это try catch.
[01:25:14.060 --> 01:25:16.060]  try catch.
[01:25:16.060 --> 01:25:21.060]  Это последний control стейтмент, который существует в языке C++.
[01:25:21.060 --> 01:25:23.060]  Но я не буду про него вам сейчас говорить,
[01:25:23.060 --> 01:25:26.060]  потому что он связан с темой исключений,
[01:25:26.060 --> 01:25:28.060]  которую мы с вами еще не обсуждали.
[01:25:28.060 --> 01:25:31.060]  И мы будем обсуждать ее либо в конце этого семестра,
[01:25:31.060 --> 01:25:33.060]  либо в начале следующего.
[01:25:33.060 --> 01:25:36.060]  И тогда мы поговорим, что try catch – это не так просто.
[01:25:36.060 --> 01:25:38.060]  А пока на сегодня все.
[01:25:38.060 --> 01:25:41.060]  Мы закончили с вами тему control стейтменты.
[01:25:41.060 --> 01:25:43.060]  И почти закончили главу первую.
[01:25:43.060 --> 01:25:45.060]  Нам остался всего один параграф из нее.
