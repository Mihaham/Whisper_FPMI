[00:00.000 --> 00:05.840]  Так, ладно, ну-ки, давайте начнем.
[00:05.840 --> 00:08.560]  У нас сегодня пятая лекция, по-моему.
[00:08.560 --> 00:14.520]  А сегодня мы будем с вами говорить про такую штуку,
[00:14.520 --> 00:16.480]  как минимальные остовные деревья.
[00:16.480 --> 00:29.720]  Это первая часть лекции, а вторая часть в зависимости
[00:29.720 --> 00:32.600]  от того, сколько, как быстро уложимся в эту штуку,
[00:32.600 --> 00:36.680]  там будет определяться находу, импровизация.
[00:36.680 --> 00:38.600]  Давайте определение.
[00:38.600 --> 00:57.080]  Пусть G, V, E это неориентированный граф, тогда T равный V, E штрих.
[00:57.080 --> 01:05.560]  Это остовное дерево.
[01:05.560 --> 01:15.240]  Если это дерево, в общем-то, здесь ничего интеллектуального
[01:15.240 --> 01:16.240]  нет.
[01:16.240 --> 01:17.240]  Как это понимать?
[01:17.240 --> 01:20.520]  У вас есть какой-то граф на множестве вершин V, на
[01:20.520 --> 01:21.520]  ребрах E.
[01:21.520 --> 01:24.000]  Затем вам дали тоже множество вершин.
[01:24.000 --> 01:34.440]  Вы выбрали какие-то ребра в графе, и у вас получилось
[01:34.440 --> 01:35.440]  дерево.
[01:35.440 --> 01:44.880]  Например, тоже граф, раз взяли ребро, два взяли
[01:44.880 --> 01:49.080]  ребро, три, четыре, пять.
[01:49.080 --> 02:08.400]  Это остовное дерево, точнее говоря.
[02:08.400 --> 02:09.400]  Зачем они нужны?
[02:09.400 --> 02:13.440]  Ну, с тем, чтобы хотя бы просто понимать, сколько ребер
[02:13.440 --> 02:15.840]  можно удалить, чтобы, например, там осталось связанности,
[02:15.840 --> 02:16.840]  какие.
[02:17.840 --> 02:22.120]  Ну, это можно делать с помощью остов, а здесь мы поставим
[02:22.120 --> 02:25.120]  задачу немножко по-другому.
[02:25.120 --> 02:31.640]  Теперь мы введем минимальный остов, что это такое.
[02:31.640 --> 02:38.760]  Пусть G, V, E, W, то есть мы даже добавляем сюда вес
[02:38.840 --> 02:47.640]  функцию, это неориентированный, взвешенный граф, на W ограничений
[02:47.640 --> 03:00.360]  не будем накладывать, тогда T равный V, E, W, это минимальный
[03:00.360 --> 03:01.360]  остов.
[03:01.360 --> 03:06.880]  Давайте T звездой его обозначим.
[03:06.880 --> 03:07.880]  Почему?
[03:07.880 --> 03:10.680]  Потому что я хочу вот так вот делать, T со звездой
[03:10.680 --> 03:20.480]  равно argmin, W от T, где T это остовное дерево.
[03:20.480 --> 03:26.080]  То есть я беру минимальный остов по суммарному весу.
[03:26.080 --> 03:32.400]  Например, вы можете с помощью этого решать задачу,
[03:32.400 --> 03:34.720]  не знаю, какое там самое дорогое множество ребер
[03:34.720 --> 03:36.680]  можно все еще выкинуть, чтобы граф остался связанным.
[03:36.680 --> 03:41.160]  Но это самое простое, что можно придумать.
[03:41.160 --> 03:44.800]  Так-то на минус 100 можно много всякого придумать.
[03:44.800 --> 03:48.240]  Например, не знаю, у вас есть там схема, электросхема
[03:48.240 --> 03:52.960]  или микросхема, у вас тут длинные соединения, например,
[03:52.960 --> 03:53.960]  или их стоимость.
[03:54.440 --> 03:56.880]  Вы хотите найти минимальную штуку, которую можно оставить,
[03:56.880 --> 03:59.280]  чтобы у вас граф был связанным, чтобы схема была связана.
[03:59.280 --> 04:03.640]  Вот, ну и теперь нужно понять, как их искать.
[04:03.640 --> 04:14.160]  Не знаю, здесь 100, здесь минус 10, минус 2, 1, 3, P делить
[04:14.160 --> 04:15.160]  на E.
[04:15.160 --> 04:16.160]  Что-нибудь такое.
[04:16.160 --> 04:19.560]  Вот у вас классный граф, то есть вы можете назвать
[04:19.560 --> 04:22.440]  себя отрицательной, рациональной, вообще любые веса.
[04:22.440 --> 04:24.320]  Здесь W действует из E в R.
[04:24.320 --> 04:25.320]  Что?
[04:25.320 --> 04:28.200]  Ну, вы не умеете сравнить комплексные числа.
[04:28.200 --> 04:30.680]  Ну что значит, что одно комплексное число меньше
[04:30.680 --> 04:31.680]  другого?
[04:31.680 --> 04:32.680]  Что?
[04:32.680 --> 04:35.720]  Ну, хорошо, на которых определен полный порядок.
[04:35.720 --> 04:39.960]  То есть, которые являются лумом, если уж так хочется.
[04:39.960 --> 04:43.160]  Все-таки у нас граф конечный, здесь фунтированность не
[04:43.160 --> 04:44.160]  очень интересна.
[04:44.160 --> 04:48.720]  Окей, так, что мы еще хотим?
[04:48.720 --> 04:51.280]  Надо подступиться к чему-нибудь, надо сформулировать снутиарем
[04:51.280 --> 04:53.600]  вообще, сформулировать определение.
[04:53.600 --> 05:03.600]  Пусть, надо подумать, как бы это сказать, не нарочно.
[05:03.600 --> 05:20.240]  Пусть T штрих равно W E штрих, это подграф некоторого
[05:20.240 --> 05:29.920]  миностово, давайте два штриха здесь напишу, миностово
[05:29.920 --> 05:40.120]  T равное W E штрих графа G V E.
[05:40.120 --> 05:45.400]  То есть, вы взяли граф G, нашли в нем миностов, взяли
[05:45.400 --> 05:46.400]  какой-то его кусок.
[05:46.400 --> 06:02.280]  Тогда, ребро E, E маленькое, равное U V, E не лежит в E
[06:02.280 --> 06:15.000]  два штриха, это безопасно для T два штриха.
[06:15.000 --> 06:28.680]  Если T три штриха V E два штриха в объединении с парой U V подграф
[06:28.680 --> 06:40.600]  некоторого миностово G равный V E.
[06:41.600 --> 06:46.440]  Ну, я думал сюда еще миностов T четыре штриха вставить,
[06:46.440 --> 06:47.440]  но я не решился.
[06:47.440 --> 06:54.760]  Как-то понимать, очень классное определение, я уверен, хотите
[06:54.760 --> 06:55.760]  вы мне сказать.
[06:55.760 --> 06:56.760]  Что?
[06:56.760 --> 07:08.160]  Нет, в смысле, нет, какая разница, у вас подграфы
[07:08.160 --> 07:09.160]  миностово.
[07:09.160 --> 07:11.960]  То есть, у вас вершинки могут быть те же, у ребра
[07:11.960 --> 07:15.400]  еще не закончили добавлять туда, да, здесь не принципиально
[07:15.400 --> 07:19.000]  на 2 штрихи ставить, но можно, конечно, и везде подмонстры
[07:19.000 --> 07:22.360]  вставить, но не очень интересно.
[07:22.360 --> 07:37.160]  Например, такой граф, да, и допустим, я знаю, что у
[07:37.160 --> 07:42.960]  меня вот эта вот часть, это подграф некоторого
[07:42.960 --> 07:43.960]  миностово.
[07:43.960 --> 07:47.720]  Ну, если что, это правда, это правда подграф миностово,
[07:47.720 --> 07:48.720]  спойлер.
[07:48.720 --> 07:53.600]  Вот, то есть, вот это вот, давайте, у нас будет T два
[07:53.600 --> 07:54.600]  штриха.
[07:54.600 --> 07:55.920]  То есть, вот сейчас вот T два штриха выделено.
[07:55.920 --> 07:58.960]  Я хочу понять, какое ребро является безопасным.
[07:58.960 --> 08:03.760]  То есть, например, какое ребро я могу добавить, чтобы
[08:03.760 --> 08:06.320]  у меня снова получился подграф какого-то миностово.
[08:06.320 --> 08:12.040]  Ну, будто бы минус три добавлять, классная идея,
[08:12.040 --> 08:13.040]  да.
[08:13.040 --> 08:15.480]  Потому что это такое минимальное ребро здесь, которое достижено
[08:15.480 --> 08:17.160]  из этих, наверное, оно войдет в миностов в итоге.
[08:17.160 --> 08:27.440]  Ну, тоже спойлер, да, но является безопасным, потом
[08:27.440 --> 08:30.040]  поясним с вами, потеряем, почему это будет так.
[08:30.040 --> 08:32.520]  Вот, пока что просто нужно поверить, что вот это подграф
[08:32.520 --> 08:35.080]  миностово, если я добавлю это ребро, то это все еще
[08:35.080 --> 08:37.360]  будут подграфы миностово, поэтому это ребро называется
[08:37.360 --> 08:38.360]  безопасным.
[08:38.360 --> 08:41.360]  Вот и все.
[08:41.360 --> 08:42.360]  Окей.
[08:42.360 --> 08:46.000]  То есть, понятная идея, что здесь имеется в виду.
[08:46.000 --> 08:48.440]  То есть, здесь T три штриха, это вот эти три ребра.
[08:48.440 --> 08:51.440]  Нет, конечно.
[08:51.440 --> 08:54.760]  Ну, здесь не выгодно добавлять, например, миностово.
[08:54.760 --> 08:55.760]  Зачем?
[08:55.760 --> 08:56.760]  Если бы минус десять добавить.
[08:56.760 --> 08:59.720]  Я не помню, упреляли ли мы с вами, что такое разрез
[08:59.720 --> 09:00.720]  в графе.
[09:00.720 --> 09:01.720]  Наверное, нет.
[09:01.720 --> 09:02.720]  Ну да.
[09:03.720 --> 09:06.720]  Еще определение тогда.
[09:11.720 --> 09:28.720]  Пара СТ разрез в G равным VE, если равно V.
[09:28.720 --> 09:31.720]  Надеюсь, что всем знакома эта квадратная оскобка,
[09:31.720 --> 09:32.720]  что это дизюнкное объединение.
[09:32.720 --> 09:35.720]  То есть, у вас С и Т не пересекаются, в объединение
[09:35.720 --> 09:36.720]  будут все П.
[09:36.720 --> 09:39.720]  Например, не знаю, но я могу вот так вот рассечь
[09:39.720 --> 09:40.720]  граф.
[09:40.720 --> 09:43.720]  И вот эта вот часть у меня будет S, вот это T.
[09:43.720 --> 09:44.720]  Ну или наоборот.
[09:44.720 --> 09:46.720]  Ну, разрезов очень много внезапно.
[09:46.720 --> 09:49.720]  Например, сколько у вас способов выделить подмножство
[09:49.720 --> 09:50.720]  S?
[09:50.720 --> 09:51.720]  Почему?
[09:51.720 --> 09:52.720]  Потому что T однозначно определяется.
[09:52.720 --> 09:53.720]  Это столько подмноженств.
[09:53.720 --> 09:57.720]  Ну, обычно С и Т еще считаются непустыми все-таки.
[09:57.720 --> 10:00.720]  То есть, сколько способов выбрать непустое подмножство
[10:00.720 --> 10:01.720]  S?
[10:01.720 --> 10:03.720]  2V минус 1, да.
[10:03.720 --> 10:05.720]  Да, в степень мудра В минус 1.
[10:05.720 --> 10:06.720]  Вот столько разрезов.
[10:06.720 --> 10:07.720]  Вот.
[10:07.720 --> 10:08.720]  Но это не очень интересно.
[10:08.720 --> 10:23.720]  И ребро УВ пересекает разрезы с Т.
[10:24.720 --> 10:27.720]  У лежит в С.
[10:27.720 --> 10:31.720]  И В лежит в Т.
[10:31.720 --> 10:34.720]  Или У лежит в Т.
[10:34.720 --> 10:36.720]  И В лежит в С.
[10:36.720 --> 10:42.720]  То есть, это ребро, у которого концы по разные стороны.
[10:42.720 --> 10:43.720]  Давайте посмотрим.
[10:43.720 --> 10:48.720]  Вот до момента добавления минус 3 в минус 100, что у нас
[10:48.720 --> 10:50.720]  с вами было?
[10:50.720 --> 10:54.720]  По сути, вот это был отдельный разрез.
[10:54.720 --> 10:57.720]  То есть, у нас вот три вершинки лежали в одной половинке,
[10:57.720 --> 11:00.720]  все остальные в другой.
[11:00.720 --> 11:03.720]  И полемия безопасного ребра, который мы сейчас формулируем,
[11:03.720 --> 11:06.720]  утверждается, что минимально ребро пересекающий разрез
[11:06.720 --> 11:11.720]  обязательно является безопасным.
[11:11.720 --> 11:14.720]  Не находите ничего похожего сразу, спрашиваю вас.
[11:14.720 --> 11:16.720]  DX должно похоже быть.
[11:16.720 --> 11:18.720]  Потому что по DX мы тоже делали что?
[11:18.720 --> 11:21.720]  Мы просто делали разрез, пытались докидывать вершинку
[11:21.720 --> 11:24.720]  в одну половинку и брали минимальную по оценке.
[11:24.720 --> 11:27.720]  Дальше у нас будет алгоритм прима, который берет без оценки
[11:27.720 --> 11:30.720]  просто минимальный по весу ребро через разрез.
[11:30.720 --> 11:33.720]  Но это забегает вперед, а пока что
[11:33.720 --> 11:38.720]  лемма по безопасному ребре.
[11:38.720 --> 11:41.720]  Пусть ST это разрез GVE.
[12:08.720 --> 12:18.720]  И пусть на S построен...
[12:18.720 --> 12:22.720]  Блин, я не могу теперь обозначить дерево за T,
[12:22.720 --> 12:25.720]  потому что есть ST разрез.
[12:25.720 --> 12:29.720]  Да нет, я H назову его просто.
[12:29.720 --> 12:37.720]  Устроим H штрих, равный SE штрих,
[12:37.720 --> 12:42.720]  E штрих под множество E.
[12:42.720 --> 12:50.720]  Так, H штрих равный SE штрих под граф,
[12:50.720 --> 12:58.720]  миностово H равный VE штрих.
[12:58.720 --> 13:03.720]  Неудобно, давайте здесь два штриха, здесь один штрих будет.
[13:03.720 --> 13:06.720]  Что мы сделали?
[13:06.720 --> 13:09.720]  Вам говорят, хорошо, пускай я выбрал разрез,
[13:09.720 --> 13:12.720]  и у меня известно на его половинке миностов.
[13:12.720 --> 13:15.720]  Под граф миностово будущего, то есть сам миностово на разрезе.
[13:15.720 --> 13:18.720]  На одной из половинок разреза.
[13:18.720 --> 13:38.720]  Пусть ребро EUV это ребро минимального веса, пересекающее разрез.
[13:38.720 --> 13:52.720]  Тогда E безопасно.
[13:52.720 --> 13:55.720]  То есть еще раз, вот у меня есть разрез,
[13:55.720 --> 13:57.720]  я на нем строил миностов.
[13:57.720 --> 13:59.720]  Я рассматриваю все ребра, пересекающие разрез.
[13:59.720 --> 14:01.720]  Раз, два, три, четыре.
[14:01.720 --> 14:04.720]  Беру из них тот, который минимального веса, минус три.
[14:04.720 --> 14:07.720]  Полемия это ребро получается безопасным,
[14:07.720 --> 14:11.720]  то есть я могу его добавить, я все равно еще останусь в рамках какого-то миностово.
[14:11.720 --> 14:14.720]  Быть может, другого.
[14:14.720 --> 14:19.720]  То есть вот этот вот H штрих, да?
[14:19.720 --> 14:22.720]  То есть мы получим H2 штриха, когда добавлю ребро E туда.
[14:22.720 --> 14:25.720]  Быть может, он уже перестанет быть под графом этого миностово.
[14:25.720 --> 14:29.720]  Потому что миностовов много может быть, на самом деле, в общем случае.
[14:29.720 --> 14:35.720]  Вот. Если это так, то тогда что происходит?
[14:35.720 --> 14:37.720]  По сути дела.
[14:37.720 --> 14:39.720]  Что у вас этот H может быть другим.
[14:39.720 --> 14:42.720]  То есть у вас E штрих здесь будет не такое.
[14:42.720 --> 14:44.720]  Вот, но это не очень важно.
[14:44.720 --> 14:48.720]  Важно то, что вы стоите в рамках какого-то миностово.
[14:48.720 --> 14:50.720]  Окей, давайте доказывать.
[14:50.720 --> 15:01.720]  Зареза здесь крайне интеллектуальная.
[15:01.720 --> 15:07.720]  СТ, да?
[15:07.720 --> 15:12.720]  Это будет, как вы изначально миностово обозвали.
[15:12.720 --> 15:14.720]  На S построен H штрих.
[15:14.720 --> 15:18.720]  Это будет H штрих.
[15:18.720 --> 15:26.720]  Здесь есть какой-то еще...
[15:26.720 --> 15:35.720]  Это H без H штрих.
[15:35.720 --> 15:40.720]  И у нас есть какое-то ребро соединяющее.
[15:40.720 --> 15:47.720]  Это наше ребро E.
[15:47.720 --> 15:50.720]  Ну, доказывается такое.
[15:50.720 --> 16:02.720]  Хорошо, достроим H штрих до миностово.
[16:02.720 --> 16:05.720]  Так как у вас, очевидно, дерево это связано, граф,
[16:05.720 --> 16:09.720]  у вас должно быть хотя бы одно ребро через разрез выбрано.
[16:09.720 --> 16:16.720]  Ну, более того, ровно одно на самом деле, потому что у вас цикл образуется.
[16:16.720 --> 16:22.720]  Окей, выбрали ребро.
[16:22.720 --> 16:28.720]  Пусть... Ой, сори, что я несу?
[16:28.720 --> 16:33.720]  Что это H без H штрих?
[16:33.720 --> 16:40.720]  Это просто под граф какого-то миностово в T.
[16:40.720 --> 16:44.720]  То есть это не обязательно какое-то множество ребра здесь будет.
[16:44.720 --> 16:47.720]  Хорошо, что мы дальше делаем?
[16:47.720 --> 16:55.720]  Пусть E штрих это ребро, пересекающее разреза с T.
[16:55.720 --> 16:58.720]  Очевидно, такое существует, значит, фотограф не связан просто-напросто.
[16:58.720 --> 17:01.720]  Может получить миностов.
[17:01.720 --> 17:06.720]  Два случая. Случа первый.
[17:06.720 --> 17:10.720]  Так, это U, это V.
[17:10.720 --> 17:12.720]  E равно E штрих.
[17:12.720 --> 17:17.720]  То есть мы действительно взяли какой-то E штрих, который равно E.
[17:17.720 --> 17:23.720]  Ну, тогда все доказано. Мы остались в рамках миностово, когда мы добавляли E штрих.
[17:23.720 --> 17:28.720]  Да, когда мы добавляли ребро, мы остались в рамках миностово, потому что оно просто лежит в миностове.
[17:28.720 --> 17:37.720]  Тогда по определению E безопасно.
[17:37.720 --> 17:41.720]  Второй случай. E не равно E штрих.
[17:41.720 --> 17:46.720]  Хорошо, есть какое-то другое ребро.
[17:46.720 --> 17:57.720]  Это E штрих.
[17:57.720 --> 18:03.720]  Рассмотрим.
[18:04.720 --> 18:06.720]  Давайте напишем.
[18:06.720 --> 18:09.720]  У нас же не было H2 штриха в формулировке.
[18:09.720 --> 18:12.720]  Не было. Вот, теперь есть H2 штриха.
[18:12.720 --> 18:27.720]  Рассмотрим путь из U в V, H2 штриха.
[18:27.720 --> 18:32.720]  Какой вид он имеет? Давайте это U штрих, это V штрих.
[18:32.720 --> 18:42.720]  U штрих равно U штрих V штрих. U штрих лежит в S, это лежит в T.
[18:42.720 --> 18:44.720]  Хорошо.
[18:44.720 --> 18:50.720]  Тогда я могу сказать следующее, что...
[18:50.720 --> 18:57.720]  Давайте заметим такое очевидное соотношение, что если у нас есть какие-то вершинки, есть два пути между ними,
[18:57.720 --> 19:00.720]  то мне в миностове выгоднее взять тот, который...
[19:00.720 --> 19:02.720]  Короче, по весу просто.
[19:02.720 --> 19:07.720]  Потому что у вас связанность здесь не нарушится.
[19:07.720 --> 19:14.720]  Это не самое содержательное здесь.
[19:14.720 --> 19:19.720]  Так как E штрих это минимальное ребро...
[19:19.720 --> 19:26.720]  Нет, E это ребро минимального веса. Вот так вот.
[19:26.720 --> 19:27.720]  Что мы сами определили в итоге?
[19:27.720 --> 19:34.720]  Что у нас E это ребро минимального веса, пересекающего разреза, E штрих это то, что ушло в миностов.
[19:34.720 --> 19:53.720]  Заметим, что замена E штрих на E не испортит связанности.
[19:53.720 --> 19:57.720]  Почему? Потому что у вас здесь есть связанная компонента, здесь есть связанная компонента.
[19:57.720 --> 20:00.720]  Вы убрали одно ребро, поставили другое.
[20:00.720 --> 20:14.720]  Поэтому замена E штрих на E не меняет связанности и оставляет древесность.
[20:14.720 --> 20:18.720]  Ну что тогда можно сказать?
[20:18.720 --> 20:30.720]  Но E штрих, вес ребра E штрих, он какой у нас по сути по сравнению с весом E?
[20:30.720 --> 20:36.720]  Больше либо равен. Ну, равенство тоже может быть.
[20:36.720 --> 20:38.720]  Вес E штрих больше равен, чем вес E.
[20:38.720 --> 20:50.720]  Откуда вас следует?
[20:50.720 --> 20:51.720]  Следует две вещи.
[20:51.720 --> 20:56.720]  Первый случай, если строгое неравенство, значит, что это просто-напросто добавление E штрих.
[20:56.720 --> 20:58.720]  Это плохая идея была.
[20:58.720 --> 21:02.720]  И надо было добавлять именно E, потому что E штрих не является безопасным.
[21:02.720 --> 21:05.720]  А второй случай, это то, что E штрих является безопасным.
[21:05.720 --> 21:07.720]  Но это то, что мы хотели получить из условия.
[21:07.720 --> 21:11.720]  Потому что тогда вес равен весу минимального и в том числе минимальным.
[21:11.720 --> 21:14.720]  Давайте первый вариант.
[21:14.720 --> 21:18.720]  W от E равно W от E штрих.
[21:18.720 --> 21:28.720]  Следует, что E штрих безопасно, но он тоже имеет минимальный вес.
[21:35.720 --> 21:38.720]  Откуда вас следует, что все окей в этом случае.
[21:38.720 --> 21:45.720]  Второй случай, это W от E меньше, чем W от E штрих.
[21:45.720 --> 21:53.720]  Откуда вас следует, что H2 штриха не именно стов.
[21:53.720 --> 21:55.720]  Противоречие.
[21:55.720 --> 21:58.720]  Все, доказали лев.
[21:58.720 --> 22:03.720]  А, да, я забыл сказать, как минимальный ствол на дереве по-английски.
[22:03.720 --> 22:05.720]  Минимальный это минимал, это понятно.
[22:05.720 --> 22:08.720]  А стовный это спеннинг.
[22:08.720 --> 22:10.720]  То есть это будет...
[22:10.720 --> 22:13.720]  Надеюсь, подпишу.
[22:13.720 --> 22:16.720]  Минимал.
[22:19.720 --> 22:23.720]  Спеннинг 3.
[22:23.720 --> 22:28.720]  Или еще МСТ.
[22:28.720 --> 22:31.720]  Вот их обычная МСТ куплет.
[22:32.720 --> 22:34.720]  Окей, ну все.
[22:34.720 --> 22:36.720]  Судимо, доказали ключевую леву.
[22:36.720 --> 22:40.720]  Теперь быстренько два алгоритма поиска миностов.
[22:40.720 --> 22:43.720]  И первый алгоритм, это алгоритм Прима.
[22:53.720 --> 22:56.720]  Устроено очень просто.
[22:56.720 --> 22:58.720]  Шаг первый.
[22:58.720 --> 23:01.720]  А, ну не первый шаг, а...
[23:05.720 --> 23:09.720]  Что будет делать? Поддерживаем разрез СТ.
[23:13.720 --> 23:19.720]  Где на С построен миностов.
[23:22.720 --> 23:24.720]  Это все, что мы будем делать.
[23:24.720 --> 23:30.720]  То есть мы будем постепенно увеличивать одну часть и другую часть.
[23:30.720 --> 23:40.720]  База С равно С, Т равно В без С.
[23:40.720 --> 23:43.720]  То есть у вас есть какая-то стартовая вершинка С маленькая,
[23:43.720 --> 23:46.720]  и вы от нее начинаете отсчет свой.
[23:54.720 --> 23:57.720]  Это стартовая вершинка С, например.
[23:57.720 --> 24:01.720]  Браться произвольно, потому что в любом случае ваш миностов должен до всего добраться.
[24:03.720 --> 24:05.720]  Да, кстати, сразу спойлер.
[24:05.720 --> 24:08.720]  Если возьмете несвязанный граф, у него нет миностова.
[24:08.720 --> 24:10.720]  Это вроде тривиальное замечание.
[24:10.720 --> 24:14.720]  Просто ему, что если у вас там будут задачи в контесте, вы увидите миностов,
[24:14.720 --> 24:18.720]  а граф не связан, то что-то не так.
[24:18.720 --> 24:20.720]  Где-то.
[24:24.720 --> 24:26.720]  Какой-нибудь такой граф, да?
[24:27.720 --> 24:29.720]  Вот наш стартовый вершинка С.
[24:29.720 --> 24:31.720]  Вначале у нас вот такой вот разрез.
[24:32.720 --> 24:34.720]  Ребра пересекаются через минус один, три, два.
[24:35.720 --> 24:37.720]  Переход.
[24:40.720 --> 24:45.720]  Е равный УВ, УВС.
[24:45.720 --> 24:47.720]  ВФТ.
[24:50.720 --> 24:57.720]  Ребро минимального веса, пересекающее СТ.
[24:57.720 --> 25:04.720]  Тогда мы объявляем, что С равно СВ, ВВС.
[25:04.720 --> 25:06.720]  Т равно ТВ.
[25:06.720 --> 25:08.720]  ВВС.
[25:08.720 --> 25:10.720]  ВВС.
[25:10.720 --> 25:12.720]  ВВС.
[25:12.720 --> 25:14.720]  ВВС.
[25:14.720 --> 25:16.720]  ВВС.
[25:16.720 --> 25:18.720]  ВВС.
[25:18.720 --> 25:20.720]  ВВС.
[25:20.720 --> 25:22.720]  ВВС.
[25:22.720 --> 25:24.720]  ВВС.
[25:24.720 --> 25:26.720]  ВВС.
[25:26.720 --> 25:28.720]  Равно Т без В.
[25:32.720 --> 25:34.720]  То есть что мы делаем?
[25:34.720 --> 25:36.720]  Мы берем ребро минимального веса, например, минус один.
[25:36.720 --> 25:39.720]  Примокей, тогда оно входит в С.
[25:39.720 --> 25:42.720]  Теперь разрез представляет себе вот такую картинку.
[25:43.720 --> 25:45.720]  Вот наш миностов на текущий момент.
[25:47.720 --> 25:49.720]  Дальше убираем снова ребро минимального веса.
[25:49.720 --> 25:51.720]  Минус три, три, три, два.
[25:51.720 --> 25:53.720]  Минус три минимального веса.
[25:54.720 --> 25:56.720]  Становится новый разрез.
[25:59.720 --> 26:01.720]  Это входит к нам.
[26:01.720 --> 26:03.720]  Кто пересекает?
[26:03.720 --> 26:05.720]  Восемь, десять, три, три, два.
[26:05.720 --> 26:07.720]  Ну два минимального веса.
[26:07.720 --> 26:09.720]  Окей.
[26:09.720 --> 26:11.720]  Выберем миностов.
[26:11.720 --> 26:13.720]  Давайте я здесь перерисую линию разреза.
[26:15.720 --> 26:17.720]  Немножко другое уже.
[26:17.720 --> 26:19.720]  Вот такого вот.
[26:24.720 --> 26:26.720]  Ну кто пересекает разрез?
[26:26.720 --> 26:28.720]  Десять, три, три.
[26:28.720 --> 26:30.720]  Минус пять, восемь, один.
[26:30.720 --> 26:32.720]  Минус пять.
[26:32.720 --> 26:34.720]  А один не пересекает разрез, сори.
[26:34.720 --> 26:36.720]  Вот минус пять.
[26:36.720 --> 26:38.720]  Крутой кандидат, давайте его и возьмем.
[26:45.720 --> 26:47.720]  Вот такой вот разрез.
[26:47.720 --> 26:49.720]  Здесь остается одна вершинка по сути.
[26:49.720 --> 26:51.720]  Можно его замкнуть.
[26:51.720 --> 26:53.720]  Ну ребро минимального веса пересекающее разрез.
[26:53.720 --> 26:55.720]  Кстати, заметим, что восемь разрез не пересекает.
[26:55.720 --> 26:57.720]  Потому что у вас особо конца в С.
[26:57.720 --> 26:59.720]  Поэтому надо замкнуть здесь.
[27:05.720 --> 27:07.720]  Такая вот интересная картинка получилась.
[27:07.720 --> 27:09.720]  Ну здесь ребро минимального веса это один.
[27:13.720 --> 27:15.720]  Ну вот у вас миностов получилось.
[27:17.720 --> 27:19.720]  Давайте подумаем, что мы с вами делаем этому гритме.
[27:19.720 --> 27:21.720]  Мы умеем...
[27:21.720 --> 27:23.720]  Мы, по сути, поддерживаем множество.
[27:25.720 --> 27:27.720]  Если у нас есть какая-то вершинка...
[27:27.720 --> 27:29.720]  Это множество ребер, да, мы поддерживаем с вами?
[27:29.720 --> 27:31.720]  Мы поддерживаем, точнее, множество вершинец.
[27:31.720 --> 27:33.720]  Давайте еще поддерживать множество ребер,
[27:33.720 --> 27:35.720]  которые пересекают разрез.
[27:37.720 --> 27:39.720]  А ну, окей.
[27:39.720 --> 27:41.720]  Так, корректность.
[27:41.720 --> 27:43.720]  Просто полимия на безопасном ребре.
[27:43.720 --> 27:45.720]  Корректность очевидна,
[27:45.720 --> 27:47.720]  потому что на каждом шаге просто ее применялись.
[27:47.720 --> 27:49.720]  А теперь нам нужно
[27:51.720 --> 27:53.720]  понять, что по таймингам
[27:55.720 --> 27:57.720]  и как это плюс-минус реализовывать.
[27:57.720 --> 27:59.720]  Реализуется это, на самом деле,
[27:59.720 --> 28:01.720]  тривиальнейшим образом.
[28:01.720 --> 28:03.720]  Вы поддерживаете напрямую множество ребер,
[28:03.720 --> 28:05.720]  которые пересекают разрез.
[28:05.720 --> 28:07.720]  То есть вы поддерживаете,
[28:07.720 --> 28:09.720]  если вы поддерживаете,
[28:09.720 --> 28:11.720]  вы поддерживаете напрямую множество С и Т.
[28:11.720 --> 28:13.720]  Ну, можно просто С поддерживать.
[28:15.720 --> 28:17.720]  То есть поддерживаем напрямую множество С.
[28:25.720 --> 28:27.720]  Можно one-order множество.
[28:29.720 --> 28:31.720]  И множество ребер,
[28:33.720 --> 28:35.720]  пересекающих разрез.
[28:39.720 --> 28:41.720]  Ну, или когда-то добавленных множеством.
[28:41.720 --> 28:43.720]  Потом мы поймем, что все будет
[28:43.720 --> 28:45.720]  гораздо лучше, чем кажется.
[28:45.720 --> 28:47.720]  Вот.
[28:47.720 --> 28:49.720]  Что мы будем делать?
[28:49.720 --> 28:51.720]  Ну, давайте возьмем.
[28:51.720 --> 28:53.720]  И здесь мы хотим
[28:53.720 --> 28:55.720]  извлекать минимум,
[28:55.720 --> 28:57.720]  поэтому это либо С,
[28:57.720 --> 28:59.720]  ну, вроде как здесь priority-Q хватит.
[28:59.720 --> 29:01.720]  Сейчас посмотрим.
[29:01.720 --> 29:03.720]  То есть база понятна.
[29:03.720 --> 29:05.720]  Множество ребер,
[29:05.720 --> 29:07.720]  пересекающих разрез,
[29:07.720 --> 29:09.720]  это ребра, исходящие из С.
[29:09.720 --> 29:11.720]  Мы их все докидаем туда.
[29:11.720 --> 29:13.720]  Ну, С и Т
[29:13.720 --> 29:15.720]  определены. Переход.
[29:15.720 --> 29:17.720]  Вот, допустим, если было какое-то множество,
[29:17.720 --> 29:19.720]  я пришел по ребру в В.
[29:21.720 --> 29:23.720]  Так какие ребра у меня начали пересекать разрез?
[29:25.720 --> 29:27.720]  Вот ребра, исходящие из В.
[29:29.720 --> 29:31.720]  Очевидно, не все,
[29:31.720 --> 29:33.720]  но некоторые.
[29:33.720 --> 29:35.720]  Поэтому давайте я буду, когда,
[29:35.720 --> 29:37.720]  когда я добавил вершинку В,
[29:37.720 --> 29:39.720]  в множество С,
[29:39.720 --> 29:41.720]  я буду валять ребра, буду просто проходить
[29:41.720 --> 29:43.720]  по всем ребрам из В и смотреть, правда ли,
[29:43.720 --> 29:45.720]  что их конец в С.
[29:45.720 --> 29:47.720]  Если да, то они пересекают, точнее,
[29:47.720 --> 29:49.720]  если да, то они не пересекают разрез,
[29:49.720 --> 29:51.720]  потому что они уже внутри С-большого будут лежать.
[29:53.720 --> 29:55.720]  То есть, как бы до
[29:57.720 --> 29:59.720]  это ребра там, сюда,
[29:59.720 --> 30:01.720]  сюда, сюда, сюда, сюда,
[30:01.720 --> 30:03.720]  сюда, да,
[30:03.720 --> 30:05.720]  у В
[30:05.720 --> 30:07.720]  это С.
[30:07.720 --> 30:09.720]  Новая ситуация,
[30:09.720 --> 30:11.720]  что есть ребра сюда,
[30:11.720 --> 30:13.720]  сюда,
[30:13.720 --> 30:15.720]  и ребра наружу.
[30:17.720 --> 30:19.720]  И вот вы смотрите, правда ли, что конец ребра лежит в С?
[30:19.720 --> 30:21.720]  Если да, то его нет смысла добавлять,
[30:21.720 --> 30:23.720]  потому что он не пересекает разрез.
[30:23.720 --> 30:25.720]  Иначе действительно у вас
[30:25.720 --> 30:27.720]  ребро пересекает разрез,
[30:27.720 --> 30:29.720]  и вы его добавляете туда.
[30:29.720 --> 30:31.720]  Казалось бы, проблема, все равно мы не можем
[30:31.720 --> 30:33.720]  явно учесть в нашей куче
[30:33.720 --> 30:35.720]  в множестве,
[30:35.720 --> 30:37.720]  только ребра пересекающего разреза,
[30:37.720 --> 30:39.720]  когда-то они, то есть, в какой-то момент
[30:39.720 --> 30:41.720]  могли нам давать какое-то ребро, оно
[30:41.720 --> 30:43.720]  после добавления нескольких вершин перестанет быть
[30:43.720 --> 30:45.720]  пересекающим разрезом, оно останется в очереди.
[30:45.720 --> 30:47.720]  Проблема, ну, на самом деле
[30:47.720 --> 30:49.720]  нет, потому что при извлечении ребра
[30:49.720 --> 30:51.720]  вы можете просто посмотреть правильное, что у него бы конца С.
[30:51.720 --> 30:53.720]  Если да, то вы его игнорируете,
[30:53.720 --> 30:55.720]  потому что у вас уже было
[30:55.720 --> 30:57.720]  добавлено лучше ребро.
[30:57.720 --> 30:59.720]  Все.
[30:59.720 --> 31:01.720]  То есть вы поддерживаете
[31:01.720 --> 31:03.720]  кучу с приоритетами
[31:03.720 --> 31:05.720]  или бинарную пирамиду,
[31:05.720 --> 31:07.720]  докидываете туда
[31:07.720 --> 31:09.720]  ребра, каждый раз исходящие,
[31:09.720 --> 31:11.720]  можно там или даже с концом
[31:11.720 --> 31:13.720]  в С, не очень важно, вы все равно потом
[31:13.720 --> 31:15.720]  вы его выкинете при извлечении,
[31:15.720 --> 31:17.720]  то можно вообще все ребра то закинуть, исходящие
[31:17.720 --> 31:19.720]  из вершинки В.
[31:19.720 --> 31:21.720]  Вот. Потом, когда вы достаете
[31:21.720 --> 31:23.720]  ребро, вы проверяете, правда ли, что оно внутри
[31:23.720 --> 31:25.720]  С, оба конца.
[31:25.720 --> 31:27.720]  Если да, то оно неволидное, а почему?
[31:27.720 --> 31:29.720]  Потому что он небезопасный, это развал,
[31:29.720 --> 31:31.720]  просто цикл образуете,
[31:31.720 --> 31:33.720]  потому что у вас уже есть под граф С
[31:33.720 --> 31:35.720]  и еще ребро добавляете, это
[31:35.720 --> 31:37.720]  порождает цикл обязательно.
[31:37.720 --> 31:39.720]  Вот.
[31:39.720 --> 31:41.720]  Это вы смотрите правильно, чтобы конца С есть,
[31:41.720 --> 31:43.720]  если нет, то все. Выкидываем.
[31:43.720 --> 31:45.720]  Не смотрим его.
[31:45.720 --> 31:47.720]  Ну и все.
[31:47.720 --> 31:49.720]  Это и делаем.
[31:49.720 --> 31:51.720]  Окей.
[31:51.720 --> 31:53.720]  Что можно сказать?
[31:53.720 --> 31:55.720]  Будто бы у нас здесь даже в стадии
[31:55.720 --> 31:57.720]  проще, чем в Dx,
[31:57.720 --> 31:59.720]  а время работает плюс-минус такое же. Почему?
[31:59.720 --> 32:01.720]  Потому что вы, по сути, делаете
[32:01.720 --> 32:03.720]  E раз добавление
[32:03.720 --> 32:05.720]  в кучу.
[32:05.720 --> 32:07.720]  Вот.
[32:07.720 --> 32:09.720]  Единственное проблема в том, что у вас
[32:09.720 --> 32:11.720]  размер кучи может быть большим,
[32:11.720 --> 32:13.720]  не принципиально.
[32:13.720 --> 32:15.720]  Вот.
[32:15.720 --> 32:17.720]  И что вы делаете?
[32:17.720 --> 32:19.720]  Вы делаете извлечение из кучи.
[32:19.720 --> 32:21.720]  То есть вы добавляете в кучу элемент
[32:21.720 --> 32:23.720]  инсерты и GetMino делаете.
[32:23.720 --> 32:25.720]  Ну или экстракт.
[32:25.720 --> 32:27.720]  Это может быть как set, так и unordered set,
[32:27.720 --> 32:29.720]  если им точку не влияет.
[32:29.720 --> 32:31.720]  Вот что получается?
[32:31.720 --> 32:33.720]  Порядка E log V здесь.
[32:33.720 --> 32:35.720]  Но если оценивать наивно E log E будет,
[32:35.720 --> 32:37.720]  если там чуть-чуть
[32:37.720 --> 32:39.720]  поавтимизировать этот процесс,
[32:39.720 --> 32:41.720]  E log V получится. Прям как в Dx.
[32:41.720 --> 32:43.720]  Ну и там получится то,
[32:43.720 --> 32:45.720]  что у вас все вот эти контейнеры,
[32:45.720 --> 32:47.720]  то, что можно на массиве делать
[32:47.720 --> 32:49.720]  за V квадрат,
[32:49.720 --> 32:51.720]  куча, выначивай куча,
[32:51.720 --> 32:53.720]  на чем-то можно и не делать.
[32:53.720 --> 32:55.720]  Второй алгоритм он
[32:55.720 --> 32:57.720]  как по мне более элегантный.
[32:59.720 --> 33:01.720]  И вообще требует ноль
[33:01.720 --> 33:03.720]  идейности.
[33:03.720 --> 33:05.720]  Если этот хочешь его-то требовал,
[33:05.720 --> 33:07.720]  то это вообще ничего не требует.
[33:07.720 --> 33:09.720]  Алгоритм
[33:09.720 --> 33:11.720]  Kruskao.
[33:13.720 --> 33:15.720]  Ну, что можно сказать?
[33:15.720 --> 33:17.720]  Ну шаг первый, отсортируем
[33:17.720 --> 33:19.720]  ребра.
[33:21.720 --> 33:23.720]  Ребра по весу.
[33:27.720 --> 33:29.720]  И тут
[33:29.720 --> 33:31.720]  на сцену выходит
[33:31.720 --> 33:33.720]  легендарный участник нашего курса
[33:33.720 --> 33:35.720]  алгоритма в системе не пересекающихся множеств.
[33:39.720 --> 33:41.720]  Напомню, эта штука,
[33:41.720 --> 33:43.720]  которая умеет отвечать ровно на два запроса.
[33:43.720 --> 33:45.720]  Первое, правда ли,
[33:45.720 --> 33:47.720]  что элементы U и V в одном множестве?
[33:47.720 --> 33:49.720]  Второе, объедини множество
[33:49.720 --> 33:51.720]  где лежит U и где лежит V.
[33:51.720 --> 33:53.720]  Построим SNM
[33:53.720 --> 33:55.720]  на
[33:55.720 --> 33:57.720]  вершинах.
[33:57.720 --> 33:59.720]  То есть, если
[33:59.720 --> 34:01.720]  мы рассмотрим наш
[34:01.720 --> 34:03.720]  граф любимый.
[34:09.720 --> 34:11.720]  2-5
[34:11.720 --> 34:13.720]  8-3
[34:13.720 --> 34:15.720]  10-3
[34:15.720 --> 34:17.720]  3-1
[34:17.720 --> 34:19.720]  Вроде бы
[34:19.720 --> 34:21.720]  нет, не все скопировал.
[34:21.720 --> 34:23.720]  С 1 это 5.
[34:23.720 --> 34:25.720]  Изначально считаем, что все вершинки
[34:25.720 --> 34:27.720]  это отдельные компоненты.
[34:27.720 --> 34:29.720]  Все будто бы у нас вот такое леса, столб двух деревьев.
[34:33.720 --> 34:35.720]  Шаг 3.
[34:37.720 --> 34:39.720]  Пока
[34:39.720 --> 34:41.720]  число
[34:41.720 --> 34:43.720]  множеств
[34:43.720 --> 34:45.720]  SNM
[34:45.720 --> 34:47.720]  больше одного.
[34:47.720 --> 34:49.720]  Делаем следующие шаги.
[34:51.720 --> 34:53.720]  E
[34:53.720 --> 34:55.720]  равный U и V.
[34:57.720 --> 34:59.720]  Что-то такое.
[34:59.720 --> 35:01.720]  Это
[35:01.720 --> 35:03.720]  очередное ребро.
[35:05.720 --> 35:07.720]  Дальше, если
[35:09.720 --> 35:11.720]  по-моему, называли
[35:11.720 --> 35:13.720]  same операцию,
[35:13.720 --> 35:15.720]  то если U и V лежат в одном множестве,
[35:15.720 --> 35:17.720]  то
[35:17.720 --> 35:19.720]  там continue.
[35:21.720 --> 35:23.720]  Else
[35:23.720 --> 35:25.720]  если они
[35:25.720 --> 35:27.720]  лежат в разных,
[35:27.720 --> 35:29.720]  unite
[35:29.720 --> 35:31.720]  от U,
[35:31.720 --> 35:33.720]  U,
[35:33.720 --> 35:35.720]  минус 100.
[35:37.720 --> 35:39.720]  Что?
[35:39.720 --> 35:41.720]  Да, да.
[35:41.720 --> 35:43.720]  Очевидно,
[35:43.720 --> 35:45.720]  что ребра сортированы
[35:45.720 --> 35:47.720]  на графе.
[35:47.720 --> 35:49.720]  Вот минимум.
[35:49.720 --> 35:51.720]  Минус 5.
[35:51.720 --> 35:53.720]  Очевидно, что U и V лежат
[35:53.720 --> 35:55.720]  в разных компонентах.
[35:55.720 --> 35:57.720]  Поэтому
[35:57.720 --> 35:59.720]  говорите, что это одна компонента.
[36:03.720 --> 36:05.720]  Дальше.
[36:05.720 --> 36:07.720]  Смотрю следующий ребро минимального веса.
[36:07.720 --> 36:09.720]  Это минус 3.
[36:09.720 --> 36:11.720]  Это одна компонента.
[36:11.720 --> 36:13.720]  Они в разных лежат.
[36:17.720 --> 36:19.720]  Следующий ребро
[36:19.720 --> 36:21.720]  минус 1.
[36:21.720 --> 36:23.720]  Окей.
[36:23.720 --> 36:25.720]  Следующий ребро
[36:25.720 --> 36:27.720]  минус 1.
[36:27.720 --> 36:29.720]  Окей.
[36:37.720 --> 36:39.720]  Следующий ребро
[36:39.720 --> 36:41.720]  минус 1.
[36:41.720 --> 36:43.720]  Окей.
[36:49.720 --> 36:51.720]  Следующий ребро
[36:51.720 --> 36:53.720]  минус 1.
[36:53.720 --> 36:55.720]  Следующий ребро минимального веса 2.
[37:11.720 --> 37:13.720]  Все, что ли?
[37:13.720 --> 37:15.720]  Даже не попалось,
[37:15.720 --> 37:17.720]  чтобы в одном ноте не повезло
[37:17.720 --> 37:19.720]  ситуации.
[37:19.720 --> 37:21.720]  Это очень приятная идея.
[37:21.720 --> 37:23.720]  То есть мы просто делаем примо,
[37:23.720 --> 37:25.720]  запустив сразу низких вершинок.
[37:27.720 --> 37:29.720]  Корректность, внезапно,
[37:29.720 --> 37:31.720]  не поверите,
[37:31.720 --> 37:33.720]  но полемия о безопасном ребре
[37:33.720 --> 37:35.720]  для подграфов.
[37:35.720 --> 37:37.720]  Все.
[37:37.720 --> 37:39.720]  Больше ничего.
[37:39.720 --> 37:41.720]  Поэтому это классное утверждение,
[37:41.720 --> 37:43.720]  что она доказывает все эти алгоритмы.
[37:43.720 --> 37:45.720]  Вот.
[37:45.720 --> 37:47.720]  Ну, заметьте, минус 100, кстати, один тоже получился.
[37:47.720 --> 37:49.720]  В этом семинаре у вас будет задачка
[37:49.720 --> 37:51.720]  доказать, что если
[37:51.720 --> 37:53.720]  минус 100 единственным, то
[37:53.720 --> 37:55.720]  все веса и ребра различны.
[37:55.720 --> 37:57.720]  В обратную сторону это неверно.
[37:57.720 --> 37:59.720]  Ну, давайте подумаем.
[37:59.720 --> 38:01.720]  Это
[38:01.720 --> 38:03.720]  от E
[38:03.720 --> 38:05.720]  logE.
[38:05.720 --> 38:07.720]  Ну, если вы там какие-то радикс-сорты пишете,
[38:07.720 --> 38:09.720]  там по-другому будет работать.
[38:09.720 --> 38:11.720]  Это
[38:11.720 --> 38:13.720]  от V.
[38:13.720 --> 38:15.720]  Давайте посмотрим, сколько здесь запросов.
[38:15.720 --> 38:17.720]  В случае запросов E,
[38:17.720 --> 38:19.720]  запросы к SNM, которые
[38:19.720 --> 38:21.720]  выполняются амортизировано за альфа от V.
[38:21.720 --> 38:23.720]  Поэтому суммарно
[38:23.720 --> 38:25.720]  можно оценивать
[38:25.720 --> 38:27.720]  как-то вот так вот.
[38:27.720 --> 38:29.720]  Ну, это, очевидно,
[38:29.720 --> 38:31.720]  меньше, чем это.
[38:31.720 --> 38:33.720]  Поэтому в сумме
[38:33.720 --> 38:35.720]  получаем от
[38:35.720 --> 38:37.720]  E
[38:39.720 --> 38:41.720]  logE.
[38:41.720 --> 38:43.720]  Время работы.
[38:43.720 --> 38:45.720]  Ну,
[38:45.720 --> 38:47.720]  можно сказать, что
[38:47.720 --> 38:49.720]  E не больше, чем V квадрат.
[38:49.720 --> 38:51.720]  Поэтому
[38:51.720 --> 38:53.720]  logE, это на самом деле
[38:53.720 --> 38:55.720]  logV с точностью сюда константы.
[38:55.720 --> 38:57.720]  И вы действительно будете правы.
[38:57.720 --> 38:59.720]  Однако обычно пишут logE,
[38:59.720 --> 39:01.720]  чтобы все-таки подчеркнуть, что
[39:01.720 --> 39:03.720]  от ребер зависит. Нет, совершенно.
[39:03.720 --> 39:05.720]  Но по факту
[39:05.720 --> 39:07.720]  между примой и кросскалом
[39:07.720 --> 39:09.720]  почти ноль, плюс-минус
[39:09.720 --> 39:11.720]  отличия в работе, по времени работы.
[39:11.720 --> 39:13.720]  Иногда даже эта штука быстрее,
[39:13.720 --> 39:15.720]  потому что
[39:15.720 --> 39:17.720]  воспользоваться кучу раз кучей
[39:17.720 --> 39:19.720]  или один раз отсортировать, ну, понятно.
[39:19.720 --> 39:21.720]  Плюс-минус чего? Лучше.
[39:21.720 --> 39:23.720]  Все-таки попроще
[39:23.720 --> 39:25.720]  опираться, чем куча лазить.
[39:25.720 --> 39:27.720]  С точки зрения константа.
[39:27.720 --> 39:29.720]  Вот. Окей.
[39:29.720 --> 39:31.720]  Поехали, вторая часть лекции.
[39:31.720 --> 39:33.720]  Она с ненастоянием особо
[39:33.720 --> 39:35.720]  не связана вообще, поэтому давайте я все это затру.
[39:35.720 --> 39:37.720]  Задача называется
[39:38.720 --> 39:40.720]  LCA.
[39:40.720 --> 39:42.720]  Так, наименьший общий предок.
[39:42.720 --> 39:44.720]  Меньший
[39:44.720 --> 39:46.720]  общий
[39:46.720 --> 39:48.720]  предок.
[39:52.720 --> 39:54.720]  По-английски
[39:54.720 --> 39:56.720]  лист
[39:58.720 --> 40:00.720]  common
[40:02.720 --> 40:04.720]  ancestor
[40:04.720 --> 40:06.720]  или LCA.
[40:08.720 --> 40:10.720]  Давайте определим.
[40:10.720 --> 40:12.720]  Вот это такой.
[40:16.720 --> 40:18.720]  Пусть T
[40:18.720 --> 40:20.720]  в E
[40:20.720 --> 40:22.720]  это корневое дерево.
[40:26.720 --> 40:28.720]  То есть в нем явно видно какая-то вершинка
[40:28.720 --> 40:30.720]  как корень.
[40:30.720 --> 40:32.720]  И все остальное можно считать, что
[40:32.720 --> 40:34.720]  растет вниз или
[40:34.720 --> 40:36.720]  куда вы хотите, чтобы ваше дерево росло.
[40:37.720 --> 40:39.720]  Все.
[40:39.720 --> 40:41.720]  И у
[40:41.720 --> 40:43.720]  в лежат
[40:43.720 --> 40:45.720]  в.
[40:45.720 --> 40:47.720]  Ну, картинка будет здесь.
[40:57.720 --> 40:59.720]  Что-нибудь такое.
[41:02.720 --> 41:04.720]  Например, вот у вас у,
[41:04.720 --> 41:06.720]  вот у вас в.
[41:08.720 --> 41:10.720]  Тогда
[41:14.720 --> 41:16.720]  LCA
[41:16.720 --> 41:18.720]  с большой буквы не очень важно.
[41:18.720 --> 41:20.720]  А то в
[41:20.720 --> 41:22.720]  это такая вершина
[41:24.720 --> 41:26.720]  из в,
[41:26.720 --> 41:28.720]  что
[41:28.720 --> 41:30.720]  в лежит
[41:30.720 --> 41:32.720]  на пути
[41:36.720 --> 41:38.720]  от корня до U,
[41:40.720 --> 41:42.720]  ну, на путях
[41:44.720 --> 41:46.720]  корня до U,
[41:46.720 --> 41:48.720]  от корня до V
[41:50.720 --> 41:52.720]  и
[41:52.720 --> 41:54.720]  на
[41:54.720 --> 41:56.720]  максимальной
[41:56.720 --> 41:58.720]  глубине.
[41:58.720 --> 42:00.720]  То есть
[42:00.720 --> 42:02.720]  вот, например, U и V
[42:02.720 --> 42:04.720]  рассматривают пути
[42:06.720 --> 42:08.720]  до U
[42:08.720 --> 42:10.720]  и, не знаю, давайте градиентально
[42:10.720 --> 42:12.720]  их отметим, до V.
[42:12.720 --> 42:14.720]  То есть вот у вас общие вершинки.
[42:14.720 --> 42:16.720]  Раз, два.
[42:16.720 --> 42:18.720]  Берут самую глубокую из них.
[42:24.720 --> 42:26.720]  Это наша
[42:26.720 --> 42:28.720]  LCA
[42:28.720 --> 42:30.720]  от U и V.
[42:30.720 --> 42:32.720]  Вот для этих вот двух вершин LCA
[42:32.720 --> 42:34.720]  будет корнем. Для этих двух вершин LCA
[42:34.720 --> 42:36.720]  будет вот это вот, собственно.
[42:36.720 --> 42:38.720]  У LCA может быть равен какой-то
[42:38.720 --> 42:40.720]  из вершин.
[42:40.720 --> 42:42.720]  Когда одна вершина лежит на пути другой.
[42:44.720 --> 42:46.720]  Чем-то нужно, ну,
[42:48.720 --> 42:50.720]  те применения, как вы думаете, могут быть
[42:50.720 --> 42:52.720]  в этой штуке вообще.
[42:52.720 --> 42:54.720]  Вот, внезапно.
[42:54.720 --> 42:56.720]  Очень удобно.
[42:56.720 --> 42:58.720]  Что делать?
[43:00.720 --> 43:02.720]  Например, считать всякие
[43:02.720 --> 43:04.720]  операции на пути в дереве.
[43:04.720 --> 43:06.720]  Например, сумма на пути в дереве.
[43:08.720 --> 43:10.720]  Берете, подвешиваете,
[43:10.720 --> 43:12.720]  находите LCA, потому что сумма на пути
[43:12.720 --> 43:14.720]  это сумма двух нисходящих путей.
[43:16.720 --> 43:18.720]  Зачем это нужно? Я потом приведу
[43:18.720 --> 43:20.720]  прикладку.
[43:20.720 --> 43:22.720]  А пока что, скажем так, есть некоторые задачи,
[43:22.720 --> 43:24.720]  которые нужно решать даже
[43:24.720 --> 43:26.720]  в плане того, чтобы поиск какой-то
[43:26.720 --> 43:28.720]  операции на пути.
[43:28.720 --> 43:30.720]  В общем случае,
[43:30.720 --> 43:32.720]  например, у вас есть две версии проекта.
[43:32.720 --> 43:34.720]  У и V вы хотите узнать, когда они
[43:34.720 --> 43:36.720]  разделились в гите.
[43:36.720 --> 43:38.720]  Самое простое, что можно придумать.
[43:40.720 --> 43:42.720]  То есть на какой момент они все еще были общими,
[43:42.720 --> 43:44.720]  а потом они разорвались.
[43:44.720 --> 43:46.720]  И, конечно,
[43:46.720 --> 43:48.720]  в любом случае,
[43:48.720 --> 43:50.720]  в общем, потом они разорвались.
[43:52.720 --> 43:54.720]  Что?
[43:54.720 --> 43:56.720]  Можно, да.
[43:56.720 --> 43:58.720]  Можно искать, насколько
[43:58.720 --> 44:00.720]  поколений вы далеко от
[44:00.720 --> 44:02.720]  королевы Елизавета, например.
[44:04.720 --> 44:06.720]  Кажется, не очень далеко.
[44:06.720 --> 44:08.720]  Я не уверен.
[44:08.720 --> 44:10.720]  Не очень важно.
[44:12.720 --> 44:14.720]  Ну, там, не знаю, какие-нибудь файловые системы,
[44:14.720 --> 44:16.720]  тоже они там же иерархические. То есть любая
[44:16.720 --> 44:18.720]  иерархическая система, где у вас есть
[44:18.720 --> 44:20.720]  связь предок-потомок,
[44:20.720 --> 44:22.720]  можно искать
[44:22.720 --> 44:24.720]  илца и придавать этому разные
[44:24.720 --> 44:26.720]  смыслы.
[44:26.720 --> 44:28.720]  Как это делается? Давайте
[44:28.720 --> 44:30.720]  наивное решение.
[44:38.720 --> 44:40.720]  Посчитаем
[44:42.720 --> 44:44.720]  для каждой
[44:46.720 --> 44:48.720]  вершины глубины
[44:50.720 --> 44:52.720]  наш любимый DFS.
[44:54.720 --> 44:56.720]  Что мы дальше будем делать?
[45:00.720 --> 45:02.720]  Пусть
[45:02.720 --> 45:04.720]  глубина
[45:04.720 --> 45:06.720]  вершинки В
[45:06.720 --> 45:08.720]  меньше,
[45:08.720 --> 45:10.720]  чем, наверное.
[45:12.720 --> 45:14.720]  Ну, без ограничения общности можно сказать так,
[45:14.720 --> 45:16.720]  потому что иначе вы просто UEV сваппаете,
[45:16.720 --> 45:18.720]  алгоритм никак не меняется.
[45:18.720 --> 45:20.720]  То есть вот наша ситуация.
[45:20.720 --> 45:22.720]  UEV DFS от UU больше, чем DFS от A.
[45:22.720 --> 45:24.720]  Здесь 1, 2,
[45:24.720 --> 45:26.720]  1, 2, 3. Глубина.
[45:26.720 --> 45:28.720]  Окей.
[45:28.720 --> 45:30.720]  Что мы дальше говорим?
[45:30.720 --> 45:32.720]  Что?
[45:32.720 --> 45:34.720]  Да, да, конечно.
[45:36.720 --> 45:38.720]  Давайте DFS от A напишу.
[45:44.720 --> 45:46.720]  В смысле?
[45:46.720 --> 45:48.720]  Ну, по ребрам, например.
[45:48.720 --> 45:50.720]  Рёберная глубина.
[45:50.720 --> 45:52.720]  Вы к антесу 1 писали там?
[46:00.720 --> 46:02.720]  Хорошо, так вот напишу.
[46:02.720 --> 46:04.720]  Не очень важно.
[46:04.720 --> 46:06.720]  Окей, хорошо.
[46:06.720 --> 46:08.720]  Это справедливо.
[46:08.720 --> 46:10.720]  Третий шаг.
[46:10.720 --> 46:12.720]  Пусть
[46:12.720 --> 46:14.720]  U'
[46:14.720 --> 46:16.720]  такая вершина
[46:18.720 --> 46:20.720]  на пути
[46:20.720 --> 46:22.720]  корень
[46:22.720 --> 46:24.720]  U, что
[46:26.720 --> 46:28.720]  от U' равно
[46:28.720 --> 46:30.720]  depth
[46:30.720 --> 46:32.720]  от V.
[46:32.720 --> 46:34.720]  То есть что вы сделали? Вы знаете, для каждой вершины её предка.
[46:34.720 --> 46:36.720]  Например, тоже в DFS посчитали.
[46:36.720 --> 46:38.720]  Допустим.
[46:38.720 --> 46:40.720]  Обычно дается дерево в формате.
[46:40.720 --> 46:42.720]  Для каждой вершины дан номер предка.
[46:44.720 --> 46:46.720]  Тогда вы что сделали?
[46:46.720 --> 46:48.720]  Вы говорите, от U я прыгаю вверх
[46:48.720 --> 46:50.720]  на depth от U-depth от V шагов.
[46:50.720 --> 46:52.720]  Здесь глубина от 3,
[46:52.720 --> 46:54.720]  здесь глубина от 2, я прыгаю на 1 вверх.
[46:54.720 --> 46:56.720]  Получаю вот этот нашу
[46:56.720 --> 46:58.720]  U штрих.
[47:00.720 --> 47:02.720]  Теперь можно догадаться, что если я
[47:02.720 --> 47:04.720]  пойду одновременно вверх
[47:04.720 --> 47:06.720]  несколько раз, то в тот момент,
[47:06.720 --> 47:08.720]  когда я припрыгаю в одну и ту же вершинку,
[47:08.720 --> 47:10.720]  будет у нас в самом первом момент
[47:10.720 --> 47:12.720]  4
[47:14.720 --> 47:16.720]  while
[47:20.720 --> 47:22.720]  Заметьте, что здесь
[47:22.720 --> 47:24.720]  while U не равно V.
[47:26.720 --> 47:28.720]  Потому что вы же могли U-штрих припрыгать
[47:28.720 --> 47:30.720]  уже равно V.
[47:30.720 --> 47:32.720]  While U-штрих
[47:32.720 --> 47:34.720]  не равно V.
[47:34.720 --> 47:36.720]  U-штрих равно
[47:36.720 --> 47:38.720]  ancestors
[47:38.720 --> 47:40.720]  от U-штрих.
[47:40.720 --> 47:42.720]  U-штрих равно ancestors
[47:42.720 --> 47:44.720]  от V.
[47:48.720 --> 47:50.720]  Всё.
[47:50.720 --> 47:52.720]  Ну, return U-штрих
[47:52.720 --> 47:54.720]  или return V.
[47:54.720 --> 47:56.720]  Это будет ответ.
[47:56.720 --> 47:58.720]  За сколько это работает?
[47:58.720 --> 48:00.720]  Здесь
[48:00.720 --> 48:02.720]  будет у нас две стадии. Первая стадия
[48:02.720 --> 48:04.720]  предподсчет, вторая
[48:04.720 --> 48:06.720]  ответ-назапрос.
[48:06.720 --> 48:08.720]  Ответ-назапрос
[48:08.720 --> 48:10.720]  выдается до вершинки УВ,
[48:10.720 --> 48:12.720]  до этих L-ца.
[48:12.720 --> 48:14.720]  Предподсчет.
[48:14.720 --> 48:16.720]  Какой здесь предподсчет?
[48:16.720 --> 48:18.720]  Надо ДФ запустить.
[48:20.720 --> 48:22.720]  Да,
[48:22.720 --> 48:24.720]  заметьте, что здесь
[48:24.720 --> 48:26.720]  раз-то дерево, в нём ребер
[48:26.720 --> 48:28.720]  на единицу меньше, чем вершин,
[48:28.720 --> 48:30.720]  поэтому здесь всё будет в терминах В.
[48:30.720 --> 48:32.720]  Все симпточки считаются.
[48:32.720 --> 48:34.720]  Что можно дальше сказать?
[48:36.720 --> 48:38.720]  Ответ-назапрос.
[48:38.720 --> 48:40.720]  На глубины мы знаем, предков мы знаем.
[48:40.720 --> 48:42.720]  Но проблема в том, что нам нужно
[48:42.720 --> 48:44.720]  подниматься сначала до U-штрих,
[48:44.720 --> 48:46.720]  потом подниматься с В одновременно.
[48:46.720 --> 48:48.720]  В худшем случае это
[48:48.720 --> 48:50.720]  глубина дерева.
[48:50.720 --> 48:52.720]  Глубина дерева в худшем случае
[48:52.720 --> 48:54.720]  совершенно.
[48:54.720 --> 48:56.720]  Поэтому запрос.
[49:00.720 --> 49:02.720]  Вот модуль В.
[49:02.720 --> 49:04.720]  Безмерно долго
[49:06.720 --> 49:08.720]  давайте улучшать
[49:08.720 --> 49:10.720]  нашу ситуацию.
[49:10.720 --> 49:12.720]  И первое, что можно заметить для улучшения
[49:12.720 --> 49:14.720]  всего этого дела,
[49:14.720 --> 49:16.720]  что, в суть,
[49:16.720 --> 49:18.720]  что нам нужно знать?
[49:18.720 --> 49:20.720]  Нам нужно уметь прыгать как-то
[49:20.720 --> 49:22.720]  желательно не на одну вершинку вверх.
[49:24.720 --> 49:26.720]  Давайте реализуем эту идею,
[49:26.720 --> 49:28.720]  а именно
[49:28.720 --> 49:30.720]  так называемый метод
[49:30.720 --> 49:32.720]  двоичных подъёмов.
[49:42.720 --> 49:44.720]  В чём это заключается?
[49:44.720 --> 49:46.720]  Введём такую динамику.
[49:50.720 --> 49:52.720]  ДВК
[49:54.720 --> 49:56.720]  это
[49:56.720 --> 49:58.720]  вершина,
[49:58.720 --> 50:00.720]  если из В
[50:00.720 --> 50:02.720]  прыгнуть
[50:04.720 --> 50:06.720]  на два степенька вверх
[50:10.720 --> 50:12.720]  или корень
[50:12.720 --> 50:14.720]  при перепрыгивании.
[50:20.720 --> 50:22.720]  То есть
[50:22.720 --> 50:24.720]  корня,
[50:24.720 --> 50:26.720]  если вы слишком сильно вверх прыгаете.
[50:26.720 --> 50:28.720]  Например,
[50:28.720 --> 50:30.720]  ДП у 0
[50:30.720 --> 50:32.720]  это её предок.
[50:32.720 --> 50:34.720]  ДП у 1 это вот это вот.
[50:34.720 --> 50:36.720]  Давайте от этой вершинки рассмотрим.
[50:36.720 --> 50:38.720]  Вот у неё ДП у 0
[50:38.720 --> 50:40.720]  это её предок.
[50:40.720 --> 50:42.720]  ДП у 1
[50:42.720 --> 50:44.720]  это будет прыжок на два вверх.
[50:44.720 --> 50:46.720]  ДП у 2 это будет прыжок на четыре вверх.
[50:46.720 --> 50:48.720]  ДП у 3 это прыжок
[50:48.720 --> 50:50.720]  на четыре вверх.
[50:50.720 --> 50:52.720]  Ну, за корень это будет,
[50:52.720 --> 50:54.720]  поэтому в корень прыжок.
[50:54.720 --> 50:56.720]  Давайте посчитаем.
[50:56.720 --> 50:58.720]  Очевидно, что К не превосходит
[50:58.720 --> 51:00.720]  логан двоичный,
[51:00.720 --> 51:02.720]  потому что у вас два в степени
[51:02.720 --> 51:04.720]  вы прыгаете,
[51:04.720 --> 51:06.720]  а у вас длина пути не больше, чем N.
[51:06.720 --> 51:08.720]  Поэтому здесь будет логан
[51:08.720 --> 51:10.720]  по этому измерению,
[51:10.720 --> 51:12.720]  поэтому измерение будет N.
[51:12.720 --> 51:14.720]  Поэтому N логан будет предподсчёт.
[51:14.720 --> 51:16.720]  Давайте напишем формулу.
[51:18.720 --> 51:20.720]  Открываем.
[51:24.720 --> 51:26.720]  Анцестер от V
[51:26.720 --> 51:28.720]  если K равно нулю.
[51:28.720 --> 51:30.720]  То есть это база динамики.
[51:30.720 --> 51:32.720]  Предок корня
[51:32.720 --> 51:34.720]  это корень.
[51:34.720 --> 51:36.720]  Для корректного рассчёта нам будет важно,
[51:36.720 --> 51:38.720]  что предок корня это корень.
[51:42.720 --> 51:44.720]  Надеюсь, подпишу,
[51:44.720 --> 51:46.720]  что это корень.
[51:46.720 --> 51:49.720]  Иначе отработки не будут, я сразу скажу вам.
[51:49.720 --> 51:54.720]  Если вы должны когда проставить массив предков, вы должны в корень засунуть в предкорни это корень.
[51:54.720 --> 52:00.720]  Иначе это будут ифы неприятные, я не хочу ифы, я хочу написать классную формулу.
[52:00.720 --> 52:04.720]  Как выразить вот эту штуку через k-1?
[52:04.720 --> 52:11.720]  Внезапно, что такое прыжок на 2 степени k? Это прыжок на степени k-1 и прыжок из этой вершины на 2 степени k-1.
[52:11.720 --> 52:20.720]  Поэтому это будет dp от dp от v к-1 к-1.
[52:20.720 --> 52:23.720]  Все, такая классная формула.
[52:23.720 --> 52:28.720]  То есть смотрите, что это такое. Это я прыгаю из v на 2 степени k-1 вверх, прихожу в какую-то вершинку.
[52:28.720 --> 52:33.720]  И из нее прыгаю на 2 степени k-1, то есть суммарно я пропрыгаю в 2 степени k.
[52:33.720 --> 52:36.720]  Можно вот так классно это расписать.
[52:37.720 --> 52:41.720]  Предподсчет n лог n согласны.
[52:41.720 --> 52:45.720]  Потому что у вас пока лог n слайв по v н слайв.
[52:45.720 --> 52:55.720]  Здесь предподсчет от v лог v.
[52:55.720 --> 52:58.720]  Давайте теперь обсудим, как делать шаги.
[52:58.720 --> 53:04.720]  Идея будет абсолютно такой же, просто у нас прыжки будут быстрее совершаться.
[53:04.720 --> 53:12.720]  Что? Не, запрос будет лог v.
[53:12.720 --> 53:16.720]  У нас будет предподсчет чуть дольше, но что?
[53:16.720 --> 53:20.720]  Вот так, что мы хотим дальше?
[53:20.720 --> 53:23.720]  Хочешь сделать следующее?
[53:23.720 --> 53:29.720]  Ну казалось бы, я же говорил, что мы здесь прыгнем, по сути, когда ищем у штрих на depth от u-depth от v.
[53:34.720 --> 53:39.720]  Согласно нам, что мы прыгали вот ровно от кубича вверх, чтобы найти у штриха.
[53:39.720 --> 53:43.720]  Давайте ее разложим по степеням 2-ки, да пропрыгаем динамикой.
[53:43.720 --> 53:47.720]  Чудурочки, что ли?
[53:47.720 --> 53:51.720]  То есть это раскладываем по степеням 2-ки.
[53:57.720 --> 54:00.720]  Ну и все, и прыгаем соответственно с динамикой.
[54:00.720 --> 54:03.720]  Как на самом деле это делаться будет?
[54:03.720 --> 54:10.720]  Вы будете делать порка от логарифма до нуля.
[54:10.720 --> 54:18.720]  Если в степень k, то есть bit катый, входит вот в это число, прыгни вверх, поменяй вершинку.
[54:18.720 --> 54:23.720]  Все это, все что вы будете делать кодом. То есть код у вас будет примерно такой.
[54:23.720 --> 54:26.720]  Вот этой вот стадии, третьей.
[54:26.720 --> 54:31.720]  Ну, короче, эту штуку вы заведомо предпочитаете.
[54:31.720 --> 54:34.720]  Я пишу так, потому что я нигде ее не предпочитывал.
[54:34.720 --> 54:46.720]  Если катый bit в depth от u-depth от v, вы давайте обозначу эту штуку за дельта просто.
[54:46.720 --> 54:54.720]  Если я говорю, что катый bit в дельте, ну как-то можно проверить.
[54:54.720 --> 54:57.720]  Ну, например, не знаю.
[54:57.720 --> 55:00.720]  Ну, я не знаю.
[55:00.720 --> 55:03.720]  Я не знаю.
[55:03.720 --> 55:06.720]  Я не знаю.
[55:06.720 --> 55:09.720]  Я не знаю.
[55:09.720 --> 55:12.720]  Я не знаю.
[55:12.720 --> 55:15.720]  Я не знаю.
[55:16.720 --> 55:23.720]  Взять какой-нибудь XOR с один сдвинутый на k, и там что-нибудь проверить.
[55:23.720 --> 55:25.720]  Дельте.
[55:25.720 --> 55:32.720]  А, ну можно взять по bit i с один сдвинутый влево на k.
[55:32.720 --> 55:38.720]  То есть взять дельта по bit i на k, ну так вот.
[55:38.720 --> 55:42.720]  Если это 0, то значит дельте нет бита.
[55:42.720 --> 55:43.720]  Иначе есть bit.
[55:43.720 --> 55:49.720]  Поэтому просто вот эта вот штука можно написать туда.
[55:49.720 --> 55:51.720]  Ну, лучше написать, что не равно 0, например.
[55:51.720 --> 56:00.720]  Короче, там код ставил, скажет, что надо написать, что вот эта вот дельта, побитая из 1 до k, не равно 0.
[56:00.720 --> 56:10.720]  То есть если k-to-bit есть дельта, мы говорим, окей, u равно dp u k.
[56:10.720 --> 56:13.720]  Все, это весь код этого шага третьего.
[56:13.720 --> 56:16.720]  Теперь u равно у штрих на этом этапе.
[56:16.720 --> 56:20.720]  Ну, чтобы просто разложили, будто бы постепенно двойки эту штуку.
[56:20.720 --> 56:23.720]  Вроде все логично, да?
[56:23.720 --> 56:24.720]  Хорошо.
[56:24.720 --> 56:25.720]  Что дальше?
[56:25.720 --> 56:29.720]  Теперь нужно u и v одновременно поднимать.
[56:29.720 --> 56:32.720]  Независимо, мы будем заниматься сейчас тем же самым абсолютно.
[56:32.720 --> 56:41.720]  То есть мы по сути же знаем, что w, то есть hilt, оно имеет какую-то глубину.
[56:41.720 --> 56:45.720]  Если бы мы ее знали, мы бы явно могли бы все абсолютно то же самое сделать.
[56:45.720 --> 56:47.720]  Прям в том, что мы не знаем этой глубины.
[56:47.720 --> 56:52.720]  Поэтому будет делаться следующим образом абсолютно так же.
[56:53.720 --> 57:01.720]  Только если при прыжке вверх мы припрыгаем в одну и ту же вершину, то мы скипаем этот бит.
[57:03.720 --> 57:06.720]  Иначе, если мы приходим в разные вершинки.
[57:08.720 --> 57:11.720]  То есть давайте отсюда пишем.
[57:15.720 --> 57:16.720]  Вот так вот.
[57:17.720 --> 57:19.720]  Сюда вот и отсюда вот.
[57:19.720 --> 57:21.720]  Это не на одной глубине.
[57:22.720 --> 57:24.720]  Вот я беру и смотрю.
[57:24.720 --> 57:26.720]  От k равны log2.
[57:26.720 --> 57:28.720]  Здесь k равны 4.
[57:30.720 --> 57:31.720]  Вот 2 в четвертый.
[57:31.720 --> 57:34.720]  Если я прыгну в четвертый отсюда, я приду в корень выше корня, очевидно.
[57:34.720 --> 57:37.720]  Поэтому мне нет смысла прыгать на эту величину.
[57:37.720 --> 57:38.720]  Окей.
[57:38.720 --> 57:40.720]  Значит я скипаю эту штуку.
[57:40.720 --> 57:41.720]  2 в третье тоже много.
[57:41.720 --> 57:42.720]  Это будет за корнем.
[57:42.720 --> 57:43.720]  Тоже нет смысла.
[57:43.720 --> 57:44.720]  2 во второй.
[57:45.720 --> 57:48.720]  Раз, два, три, четыре.
[57:48.720 --> 57:49.720]  То есть я окажусь вот здесь.
[57:50.720 --> 57:53.720]  Это будет dp, v, 2.
[57:54.720 --> 57:55.720]  Много.
[57:56.720 --> 57:57.720]  Значит я не прыгаю.
[57:58.720 --> 57:59.720]  Хорошо, смотрю.
[57:59.720 --> 58:01.720]  Если я прыгну на первой.
[58:02.720 --> 58:03.720]  Раз, два, окажусь в разных.
[58:03.720 --> 58:04.720]  О, подходят.
[58:09.720 --> 58:10.720]  То есть это новое наше положение.
[58:11.720 --> 58:13.720]  Прыгаю на ноль, смотрю, окажусь в одной.
[58:15.720 --> 58:16.720]  Груз-то я скипаю.
[58:16.720 --> 58:23.720]  И утверждается, что в конце этого путешествия такого прыжков, мне останется сказать, что lc это их предок.
[58:29.720 --> 58:40.720]  То есть я утверждаю, что к концу такого фора, где я скипаю бит, если я попадаю в одну и ту же вершинку или нет, я в конце концов закончу ровно на один уровень ниже, чем lc.
[58:42.720 --> 58:43.720]  Почему это так?
[58:43.720 --> 58:44.720]  Почему это так?
[58:44.720 --> 58:53.720]  Потому что я будто бы на самом деле по битам раскладываю величину разности высоты lc и вершин, только минус один.
[58:54.720 --> 58:56.720]  Вот, есть вот минус один играет.
[58:57.720 --> 58:58.720]  То есть по сути я делаю все то же самое.
[58:59.720 --> 59:01.720]  Если я прыгаю слишком сильно, это плохо.
[59:03.720 --> 59:04.720]  Вот.
[59:04.720 --> 59:08.720]  Тогда значит я в конце концов допрыгаю разницу глубин минус один.
[59:09.720 --> 59:10.720]  Потому что вот я краски пропрыгаю.
[59:10.720 --> 59:12.720]  Потому что почему это так?
[59:12.720 --> 59:18.720]  Потому что ровно в этом числе стоят те биты, которые меня не приведут в конце концов в одинаковую вершинку.
[59:19.720 --> 59:20.720]  Вот.
[59:25.720 --> 59:27.720]  Ну да, только мы там смещаемся еще постепенно.
[59:30.720 --> 59:36.720]  Ну то есть да, это как вы по сути делаете, да вы делаете типа бин поиск по ответ, только сужаете диапазон все время, каждый успешный прыжок.
[59:37.720 --> 59:39.720]  В два раза причем ровно сужаете его.
[59:42.720 --> 59:50.720]  Почему в два раза? Ну вроде понятно, потому что если вы не смогли прыгнуть в два раза больше, но смогли прыгнуть ровно на такую величину, значит у вас там ответ где-то внутри диапазона t2t.
[59:51.720 --> 59:52.720]  Причем t2t минус один.
[59:53.720 --> 59:54.720]  Вот.
[59:55.720 --> 59:59.720]  Тогда, то есть понятно, здесь код будет почти такой же, только здесь будет и в другой стоять.
[01:00:00.720 --> 01:00:04.720]  И здесь будут u и v меняться на dp, ut, kt, vt, kt.
[01:00:05.720 --> 01:00:07.720]  Поэтому время снова log n.
[01:00:08.720 --> 01:00:09.720]  Поэтому запрос.
[01:00:13.720 --> 01:00:14.720]  Вот log v.
[01:00:17.720 --> 01:00:18.720]  Это долго.
[01:00:19.720 --> 01:00:20.720]  Хочу быстрее.
[01:00:21.720 --> 01:00:22.720]  Хочу здесь от единицы.
[01:00:23.720 --> 01:00:25.720]  Нет, вот мы сейчас будем, следующая решение будет от единицы ставить запрос.
[01:00:26.720 --> 01:00:29.720]  Ведь может мы конечно не успеем сейчас скорее всего, но мы заложим фундамент.
[01:00:30.720 --> 01:00:37.720]  А в конце, уже на следующей лекции, где там пол лекции у нас будет уйдет, чтобы vlog v превратить просто в b в предпочете.
[01:00:37.720 --> 01:00:38.720]  Ну и заодно мы сами научимся.
[01:00:39.720 --> 01:00:41.720]  Помните у нас была задача и рамка такая классная.
[01:00:42.720 --> 01:00:44.720]  Которая говорит минимум на подотрезке.
[01:00:45.720 --> 01:00:49.720]  И мы там решали либо деревом отрезков, либо разреженной таблицей.
[01:00:50.720 --> 01:00:56.720]  Разреженной таблицей мы решали, назовем log n построение от единицы ответа на запрос.
[01:00:57.720 --> 01:00:59.720]  В общем, это цель нашей следующей лекции.
[01:00:59.720 --> 01:01:01.720]  Первая половина следующей лекции будет построить такую структурку.
[01:01:02.720 --> 01:01:03.720]  Тотичную, естественно.
[01:01:04.720 --> 01:01:06.720]  То есть у нас не будет запросов изменения.
[01:01:07.720 --> 01:01:09.720]  Чтобы мы могли стать их онлайн на рамку.
[01:01:10.720 --> 01:01:12.720]  Решать за линейный предподсчет.
[01:01:13.720 --> 01:01:15.720]  И константное время на запрос.
[01:01:16.720 --> 01:01:17.720]  Наверное тебе вот как.
[01:01:18.720 --> 01:01:20.720]  Я расскажу задачу, которая нужна, для которой это применяется в жизни.
[01:01:21.720 --> 01:01:22.720]  Вот это вот действие.
[01:01:22.720 --> 01:01:23.720]  А там уже наверное.
[01:01:24.720 --> 01:01:25.720]  Сейчас ставим на следующую лекцию.
[01:01:26.720 --> 01:01:27.720]  Все, что хотелось рассказать.
[01:01:28.720 --> 01:01:32.720]  Потому что план такой, что мы хотим научиться сводить задачу лца к рамку.
[01:01:33.720 --> 01:01:34.720]  И наоборот.
[01:01:35.720 --> 01:01:36.720]  То есть умею решать рамку, мы хотим решать лца.
[01:01:37.720 --> 01:01:38.720]  И наоборот, умею решать лца, мы хотим решать рамку.
[01:01:39.720 --> 01:01:40.720]  Вот.
[01:01:41.720 --> 01:01:43.720]  Пока что там сведение одно и другое.
[01:01:44.720 --> 01:01:45.720]  То есть мы будем решать рамку.
[01:01:46.720 --> 01:01:47.720]  То есть мы будем решать рамку.
[01:01:47.720 --> 01:01:48.720]  Мы будем решать рамку.
[01:01:49.720 --> 01:01:50.720]  Вот.
[01:01:51.720 --> 01:01:53.720]  Пока что там сведение одно интеллектуальное и другое.
[01:01:54.720 --> 01:01:55.720]  Используя дикартачи по неявному ключу.
[01:01:56.720 --> 01:01:57.720]  Но простейшее.
[01:01:58.720 --> 01:01:59.720]  Вот.
[01:02:00.720 --> 01:02:02.720]  Поэтому оставим это пока что.
[01:02:03.720 --> 01:02:04.720]  Задача такая.
[01:02:05.720 --> 01:02:06.720]  Ну, прикладывая сюжет вообще.
[01:02:08.720 --> 01:02:09.720]  Сама задача вообще так.
[01:02:10.720 --> 01:02:11.720]  У вас есть какие-то.
[01:02:12.720 --> 01:02:13.720]  Что-то написано на ребрах.
[01:02:14.720 --> 01:02:15.720]  Например числа самое простое.
[01:02:15.720 --> 01:02:16.720]  Он говорит две вершины УВ.
[01:02:17.720 --> 01:02:18.720]  Хочу сумму на пути найти.
[01:02:21.720 --> 01:02:22.720]  Ну вы такие окей.
[01:02:23.720 --> 01:02:24.720]  Могу просто в тупую идти.
[01:02:25.720 --> 01:02:26.720]  А могу заметить что.
[01:02:27.720 --> 01:02:28.720]  Давайте я просто введу динамику.
[01:02:29.720 --> 01:02:30.720]  Абсолютно такую же.
[01:02:31.720 --> 01:02:32.720]  Как вот двоичные подъемы.
[01:02:33.720 --> 01:02:34.720]  Только она будет хренить и вершинку а там.
[01:02:35.720 --> 01:02:36.720]  Сумму на пути длины 2 степняка вверх.
[01:02:37.720 --> 01:02:38.720]  То я такими прыжками.
[01:02:39.720 --> 01:02:40.720]  Я найду лца сначала.
[01:02:41.720 --> 01:02:42.720]  Потом от У до лца соберу путь.
[01:02:43.720 --> 01:02:44.720]  От В до лца соберу путь.
[01:02:45.720 --> 01:02:46.720]  А теперь прикладной сюжет.
[01:02:51.720 --> 01:02:52.720]  Можно до корни хранить.
[01:02:53.720 --> 01:02:54.720]  Ну да там будет двойная сумма.
[01:02:55.720 --> 01:02:56.720]  Это плюс сумма.
[01:02:57.720 --> 01:02:58.720]  Это минус двойная на пути до корни.
[01:02:59.720 --> 01:03:00.720]  Не очень важно.
[01:03:01.720 --> 01:03:02.720]  Вот теперь.
[01:03:03.720 --> 01:03:04.720]  Допустим у нас необратимая операция.
[01:03:05.720 --> 01:03:06.720]  Не знаю минимум на пути например.
[01:03:07.720 --> 01:03:08.720]  Вот здесь придется явно хранить.
[01:03:10.720 --> 01:03:11.720]  Незавтра я там.
[01:03:12.720 --> 01:03:13.720]  Я работаю.
[01:03:13.720 --> 01:03:15.720]  Я работаю тем, что разрабатываю бесплотные автомобили.
[01:03:16.720 --> 01:03:17.720]  Вот.
[01:03:18.720 --> 01:03:19.720]  И в бесплотных автомобилях есть очень интересная штука.
[01:03:20.720 --> 01:03:22.720]  То, что они постоянно шлют системы координат.
[01:03:23.720 --> 01:03:24.720]  Они же двигаются.
[01:03:25.720 --> 01:03:26.720]  И все вокруг них двигается.
[01:03:27.720 --> 01:03:28.720]  И у них есть куча разных систем координат.
[01:03:29.720 --> 01:03:30.720]  Система координат связанная с картой.
[01:03:31.720 --> 01:03:32.720]  Связанная с GPS.
[01:03:33.720 --> 01:03:34.720]  Еще несколько систем ориентирования.
[01:03:35.720 --> 01:03:36.720]  Связанная с ним самим.
[01:03:37.720 --> 01:03:38.720]  Его система координат скорости.
[01:03:39.720 --> 01:03:40.720]  Ускорения боковых скоростей.
[01:03:41.720 --> 01:03:42.720]  Боковых ускорений.
[01:03:43.720 --> 01:03:44.720]  Координат двигается.
[01:03:45.720 --> 01:03:46.720]  Соответственно постоянно меняется матрица поворота.
[01:03:47.720 --> 01:03:48.720]  Переходы между одной системой координат и другую.
[01:03:49.720 --> 01:03:51.720]  И вот допустим вы хотите понять там.
[01:03:52.720 --> 01:03:54.720]  Ну я занимаюсь тем, что мы предсказываем траекторию агентов среды.
[01:03:55.720 --> 01:03:56.720]  Вот.
[01:03:57.720 --> 01:03:58.720]  И мне нужно понимать там условно три секунды назад.
[01:03:59.720 --> 01:04:00.720]  Где был пешеход.
[01:04:01.720 --> 01:04:02.720]  Он запоминает же это.
[01:04:03.720 --> 01:04:04.720]  Прямо в том, что у меня уже новая система координат.
[01:04:05.720 --> 01:04:06.720]  У меня уже там 100 матриц новых пришло.
[01:04:07.720 --> 01:04:08.720]  То есть я должен уметь понимать.
[01:04:09.720 --> 01:04:11.720]  Как я от одной системы координат должен переходить в другую.
[01:04:11.720 --> 01:04:12.720]  И там как будет все меняться.
[01:04:13.720 --> 01:04:14.720]  Вот.
[01:04:15.720 --> 01:04:16.720]  Как это решается?
[01:04:17.720 --> 01:04:19.720]  Тем, что по сути беспилотник пишет.
[01:04:20.720 --> 01:04:22.720]  Вот тебе сообщение новое.
[01:04:23.720 --> 01:04:24.720]  Это тайм.
[01:04:26.720 --> 01:04:27.720]  Это.
[01:04:28.720 --> 01:04:29.720]  Система координат.
[01:04:30.720 --> 01:04:31.720]  Какую я хочу.
[01:04:32.720 --> 01:04:33.720]  System from.
[01:04:38.720 --> 01:04:39.720]  Or System to.
[01:04:39.720 --> 01:04:41.720]  Такие вот сообщения с тремя вещами генерируют.
[01:04:42.720 --> 01:04:44.720]  Из какой системы куда и в какое время хочу.
[01:04:45.720 --> 01:04:49.720]  Например из системы GPS, системы беспилотника в три секунды.
[01:04:50.720 --> 01:04:53.720]  Внезапно он там пишет более тысячи в секунду сообщений таких.
[01:04:54.720 --> 01:04:55.720]  Много.
[01:04:56.720 --> 01:04:58.720]  И теперь я хочу понять там в системе.
[01:04:59.720 --> 01:05:03.720]  Какая была угловая скорость пешехода или там у другой машины.
[01:05:04.720 --> 01:05:06.720]  В системе отсчета связанной с матрицей.
[01:05:06.720 --> 01:05:07.720]  У другой машины.
[01:05:08.720 --> 01:05:10.720]  В системе отсчета связанной с моей угловой скоростью.
[01:05:11.720 --> 01:05:13.720]  То есть мы разъезжаемся или встречаемся.
[01:05:14.720 --> 01:05:17.720]  Но при этом мне нужны исторические данные, чтобы построить траекторию.
[01:05:18.720 --> 01:05:21.720]  Поэтому я должен уметь быстро запрашивать от разных систем координат в разное время.
[01:05:22.720 --> 01:05:24.720]  И как решать эту задачу?
[01:05:25.720 --> 01:05:27.720]  Первый вариант вы можете явно хранить, когда вам приходит новое сообщение.
[01:05:28.720 --> 01:05:31.720]  Вы можете просто поддержать явный пересчет со всеми возможными матрицами.
[01:05:32.720 --> 01:05:34.720]  Всеми возможными системы координат во всем возможные таймстемпы.
[01:05:36.720 --> 01:05:40.720]  Тогда это будет действительно у вас будет все это быстро делать.
[01:05:41.720 --> 01:05:43.720]  Потому что вы будете доставать нужную матрицу за вот единицу.
[01:05:44.720 --> 01:05:45.720]  Она просто в памяти хранится.
[01:05:46.720 --> 01:05:48.720]  Но при этом в том, что у вас запрос добавления одного сообщения.
[01:05:49.720 --> 01:05:51.720]  Это линия от того, что у вас уже хранится в базе.
[01:05:52.720 --> 01:05:53.720]  Потому что вам нужно все матрицы пересчитать.
[01:05:54.720 --> 01:05:55.720]  Это раз.
[01:05:56.720 --> 01:05:57.720]  Два у вас квадрат по памяти выходит.
[01:05:58.720 --> 01:05:59.720]  Потому что у вас каждый с каждым хранится.
[01:06:00.720 --> 01:06:02.720]  Согласитесь, очень много, если у вас там больше тысячи сообщений в секунду приходит.
[01:06:03.720 --> 01:06:04.720]  Безумно много.
[01:06:04.720 --> 01:06:05.720]  Это проблема.
[01:06:06.720 --> 01:06:07.720]  Учитывая то, что у вас там агентов куча.
[01:06:08.720 --> 01:06:10.720]  Например, вы едете в бесплотник ваш.
[01:06:11.720 --> 01:06:12.720]  И он там едет где-нибудь в центре Москвы.
[01:06:13.720 --> 01:06:14.720]  И там вот пешеходный переход.
[01:06:15.720 --> 01:06:16.720]  Там две минуты светофор.
[01:06:17.720 --> 01:06:18.720]  Вот там 100 человек набилось.
[01:06:19.720 --> 01:06:22.720]  И он там для каждого из 100 пытается строить траекторию, как-то дектировать.
[01:06:23.720 --> 01:06:24.720]  Ему вообще очень плохо становится.
[01:06:25.720 --> 01:06:26.720]  Вот если вы так будете делать.
[01:06:27.720 --> 01:06:28.720]  Поэтому придумали другое решение.
[01:06:29.720 --> 01:06:32.720]  Давайте хранить дерево этих систем координат.
[01:06:33.720 --> 01:06:35.720]  А именно, каждое сообщение.
[01:06:36.720 --> 01:06:37.720]  Что это такое?
[01:06:38.720 --> 01:06:39.720]  Это дописывание новой вершинки вниз.
[01:06:40.720 --> 01:06:41.720]  К вершинке, которую мы знаем.
[01:06:42.720 --> 01:06:43.720]  И знаем таймстэмп.
[01:06:44.720 --> 01:06:45.720]  Мы говорим, окей, чувак.
[01:06:46.720 --> 01:06:49.720]  Ты хочешь к этой вершине прицепить нового ребенка.
[01:06:50.720 --> 01:06:51.720]  Вот тебе сообщение.
[01:06:53.720 --> 01:06:55.720]  Иногда сообщение приходит с запозданиями.
[01:06:56.720 --> 01:06:58.720]  Поэтому там все очень интеллектуально сделано.
[01:06:59.720 --> 01:07:01.720]  То есть вам может потом прийти сюда ребенка.
[01:07:03.720 --> 01:07:04.720]  Прицепить.
[01:07:05.720 --> 01:07:06.720]  И потом говорят, хочу.
[01:07:07.720 --> 01:07:09.720]  И с такой-то системой координат в такое-то время.
[01:07:10.720 --> 01:07:11.720]  И с такой-то системой координат в такое-то время.
[01:07:12.720 --> 01:07:13.720]  Вы говорите, окей, не вопрос.
[01:07:14.720 --> 01:07:15.720]  Раз, два, вот они мои штуки.
[01:07:16.720 --> 01:07:18.720]  И я знаю повороты, написанные на ребрах.
[01:07:19.720 --> 01:07:22.720]  Тогда чтобы получить матрицу и только поворота, мне нужно посчитать произведение матриц на пути.
[01:07:25.720 --> 01:07:26.720]  Двоечные подъемы.
[01:07:27.720 --> 01:07:29.720]  Тогда у вас запрос добавления вершинки.
[01:07:30.720 --> 01:07:31.720]  Это что такое?
[01:07:32.720 --> 01:07:35.720]  Посчитать для одной вершины динамики на лог n всего лишь раз.
[01:07:36.720 --> 01:07:37.720]  Потому что у вас для всех остальных она уже посчитана.
[01:07:38.720 --> 01:07:40.720]  Потом посчитать произведение матрицы соответствующей.
[01:07:41.720 --> 01:07:42.720]  То есть снова лог n.
[01:07:43.720 --> 01:07:44.720]  Добавление вершинки.
[01:07:45.720 --> 01:07:46.720]  И ответный запрос тоже лог n выходит.
[01:07:47.720 --> 01:07:48.720]  Потому что вы можете найти лца.
[01:07:49.720 --> 01:07:50.720]  И это все быстро посчитается.
[01:07:51.720 --> 01:07:53.720]  То есть как бы можно делать.
[01:07:54.720 --> 01:07:55.720]  И причем памяти линейное количество?
[01:07:56.720 --> 01:07:57.720]  То есть наивный способ.
[01:07:58.720 --> 01:08:00.720]  Что он нас предлагал?
[01:08:00.720 --> 01:08:10.720]  Он предлагал память, запрос добавления, запрос матрицы.
[01:08:11.720 --> 01:08:14.720]  Он предлагал n квадрат памяти.
[01:08:15.720 --> 01:08:18.720]  От n на добавление, от 1 на запрос.
[01:08:19.720 --> 01:08:24.720]  Через лца он предлагает от n памяти.
[01:08:25.720 --> 01:08:26.720]  Ой, n лог n.
[01:08:27.720 --> 01:08:28.720]  Потому что у нас динамика же еще хранится.
[01:08:28.720 --> 01:08:29.720]  От n памяти.
[01:08:30.720 --> 01:08:32.720]  От лог n на добавление.
[01:08:33.720 --> 01:08:39.720]  И от лог n на матричку поворота нужного.
[01:08:40.720 --> 01:08:43.720]  Но согласитесь, что это выглядит гораздо привлекательнее, чем это.
[01:08:44.720 --> 01:08:45.720]  Банально по памяти.
[01:08:46.720 --> 01:08:52.720]  Потому что если бы мы хранили в памяти все эти сообщения, то у нас были бы не терабайты данных.
[01:08:53.720 --> 01:08:56.720]  Мы бы никогда не закончили их обрабатывать.
[01:08:57.720 --> 01:08:58.720]  Вот как-то так.
[01:08:59.720 --> 01:09:01.720]  Поэтому что хочется сказать?
[01:09:02.720 --> 01:09:03.720]  На самом деле это вообще неочевидное применение.
[01:09:04.720 --> 01:09:06.720]  Но оно действительно существует.
[01:09:07.720 --> 01:09:08.720]  Вот как-то так.
[01:09:09.720 --> 01:09:13.720]  Поэтому не всегда очевидно, как можно применить алгоритмы, но они применяются.
[01:09:14.720 --> 01:09:16.720]  Причем в таких неожиданных местах вообще.
[01:09:17.720 --> 01:09:18.720]  Вот как-то так.
[01:09:19.720 --> 01:09:21.720]  Заодно мой спич окончательно заканчивает текст.
[01:09:22.720 --> 01:09:23.720]  25 минут.
[01:09:24.720 --> 01:09:25.720]  Все, всем спасибо.
