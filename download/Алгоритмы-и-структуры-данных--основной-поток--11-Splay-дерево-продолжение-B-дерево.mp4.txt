[00:00.000 --> 00:09.400]  Ну вот, давайте тогда анализировать, чему равно учетное время
[00:09.400 --> 00:11.680]  вот этой процедуры, что такое аут-зик-зик.
[00:11.680 --> 00:17.060]  Ну, как обычно, учетное время – это реальное время
[00:17.060 --> 00:19.000]  плюс разность потенциалов.
[00:19.000 --> 00:21.200]  Реальное время давайте считать, что это двойка,
[00:21.200 --> 00:22.960]  потому что здесь всего два поворота, давайте считать,
[00:22.960 --> 00:25.000]  что поворот у нас работает как бы за одно действие,
[00:25.000 --> 00:26.000]  грубо говоря.
[00:26.000 --> 00:28.920]  Мы все равно нигде конкретно не говорим, что такое одно
[00:28.920 --> 00:31.880]  элементарная процедура, но вот давайте считать, что
[00:31.880 --> 00:32.880]  все равно константа.
[00:32.880 --> 00:33.880]  Вот давайте один – это один поворот.
[00:33.880 --> 00:39.520]  Ну и дальше с рангами, давайте я штрихованными рангами
[00:39.520 --> 00:41.960]  буду обозначать ранги в этом новом дереве, а обычными
[00:41.960 --> 00:44.480]  рангами, р-ками, просто ранги в старом.
[00:44.480 --> 00:48.320]  Тогда у меня разных потенциалов будет вот такой, r' от x плюс
[00:48.320 --> 00:56.240]  r' от p плюс r' от g минус, ну, r от x минус r от p, давайте
[00:56.480 --> 01:00.840]  по-другому, здесь у меня будет минус r от g, тут минус
[01:00.840 --> 01:04.800]  r от p, тут минус r от x.
[01:04.800 --> 01:08.240]  Ну, потому что ранги меняются только у этих трех вершин,
[01:08.240 --> 01:13.320]  только у x'a, p и g, потому что в поддеревях a, b, c, d ничего
[01:13.320 --> 01:15.960]  не произошло, там никаких поворотов не было, там все
[01:15.960 --> 01:18.240]  ранги у всех сохранились такие же, такие, какие были
[01:18.240 --> 01:19.240]  раньше.
[01:19.240 --> 01:20.840]  Ну и в над дереве тоже ничего не произошло, потому
[01:20.840 --> 01:24.880]  что это поддерево не поменяло свой размер, s от всего этого
[01:24.960 --> 01:27.000]  поддерева остался таким же, каким был, поэтому для
[01:27.000 --> 01:30.080]  всех предков все ранги тоже сохранились, изменения
[01:30.080 --> 01:31.840]  только вот эти локальные в этих трех вершинах.
[01:31.840 --> 01:36.080]  Ну, хорошо, давайте анализировать, я утверждаю, во-первых, что
[01:36.080 --> 01:37.800]  вот эти два слагаемых можно сократить.
[01:37.800 --> 01:42.240]  Ну, вроде понятно, потому что такой r' от x, это двоичный
[01:42.240 --> 01:43.520]  гриф вот этого всего размера.
[01:43.520 --> 01:47.200]  Что такое r от g, это двоичный гриф вот этого всего размера.
[01:47.200 --> 01:50.040]  Ну, понятно, что одно и то же.
[01:50.040 --> 01:54.760]  Это все мои поддеревья a, b, c, d и три вершинки p, g, x.
[01:55.160 --> 01:59.880]  То есть вот это вот все и вот это вот все по размеру
[01:59.880 --> 02:00.880]  то одно и то же.
[02:00.880 --> 02:01.880]  Значит, ранги у них одинаковые.
[02:01.880 --> 02:05.480]  Поэтому я могу смело сократить r' от x и r от g, просто потому
[02:05.480 --> 02:07.800]  что g раньше было корнем вот этого поддерева, а теперь
[02:07.800 --> 02:08.800]  стал x.
[02:08.800 --> 02:10.120]  У них одинаковые ранги, их можно сократить.
[02:10.120 --> 02:13.120]  А, нормально?
[02:13.120 --> 02:14.120]  Окей.
[02:14.120 --> 02:20.040]  Ну, а дальше давайте я сделаю такие оценочки, давайте
[02:20.040 --> 02:28.600]  я замечу, что r от p больше собравно r от x и наоборот
[02:28.600 --> 02:33.920]  r' от x, нет, нет, нет, да, да, r' от x больше собравно
[02:33.920 --> 02:36.920]  r' от p.
[02:36.920 --> 02:41.120]  Значит, что такое r от p, r от x?
[02:41.120 --> 02:42.120]  Вот они два, да?
[02:42.120 --> 02:43.920]  Вот они раньше без штриха, значит, в старой картинке.
[02:43.920 --> 02:47.480]  r от x это логарифм вот этого дерева, r от p логарифм
[02:47.480 --> 02:48.480]  вот этого дерева.
[02:48.480 --> 02:51.320]  Ясен пень, что r от p больше, чем r от x, но это первое
[02:51.320 --> 02:52.320]  неравенство.
[02:52.320 --> 02:55.720]  И наоборот, в этой картинке r' от x это все вот это, r'
[02:55.720 --> 02:59.360]  от p это все вот это, опять же ясен пень, что более верхняя
[02:59.360 --> 03:01.200]  вершина больше, чем нижняя, имеет больше ранг.
[03:01.200 --> 03:05.000]  Вот, поэтому я здесь могу что-то немножко переписать.
[03:05.000 --> 03:08.080]  Давайте я напишу, что это меньше обравно все, двойку
[03:08.080 --> 03:14.080]  оставлю, r' от g оставлю, дальше r' от p оцениваю сверху
[03:14.080 --> 03:21.520]  как r' от x, минус r от p оцениваю сверху как минус r от x и еще
[03:21.520 --> 03:28.720]  минус r от x остался, получилось минус 2r от x.
[03:28.720 --> 03:31.280]  Вот, проверяйте арифметику, то есть просто эти два неравенства
[03:31.280 --> 03:33.760]  использовал вот здесь, оцениваю сверху таким образом.
[03:33.760 --> 03:39.560]  Ну вот, а дальше я утверждаю, что эту вещь можно оценить
[03:39.560 --> 03:46.240]  сверху тремя вот такими разностями, r' от x минус r от x, сейчас
[03:46.240 --> 03:47.240]  это будем доказывать.
[03:47.240 --> 03:56.760]  Вот, ну давайте поймем, что вот эта вот неравенция,
[03:56.760 --> 03:59.480]  которая здесь написана, она эквивалентна следующему,
[03:59.480 --> 04:02.320]  его можно немножко упростить, что-то подсократить, можно
[04:02.320 --> 04:03.320]  написать так.
[04:03.320 --> 04:11.560]  Значит, оно эквивалентно 2 плюс r' от g, смотрите здесь
[04:11.560 --> 04:15.680]  было плюс r' от x, здесь было 3, поэтому справа остается
[04:15.680 --> 04:16.680]  2r' от x.
[04:16.680 --> 04:19.960]  Ну давайте я на лево все принесу, минус 2r' от x,
[04:19.960 --> 04:22.680]  значит это вот это с этим сократилось и тут остается
[04:22.680 --> 04:25.840]  минус 2r, а справа минус 3r, если все принести на лево
[04:25.840 --> 04:26.840]  будет плюс r.
[04:26.840 --> 04:33.240]  Я утверждаю, что вот это обведенное неравенство
[04:33.240 --> 04:35.880]  эквивалентно вот этому, просто все перенес справа
[04:35.880 --> 04:36.880]  на лево.
[04:36.880 --> 04:37.880]  Да?
[04:37.880 --> 04:38.880]  Хорошо.
[04:38.880 --> 04:48.080]  Вот, ну давайте теперь тогда, давайте я тогда сделаю следующее.
[04:48.080 --> 04:53.040]  Так, видимо я зря перенес лево, давайте направо все
[04:53.040 --> 04:56.320]  уберем обратно и перепишем немножко по-другому.
[04:56.320 --> 05:11.080]  r' от g плюс r' от x минус r' от x.
[05:11.080 --> 05:16.480]  Это то, что мне нужно, сейчас посмотрим, или надо наоборот
[05:16.720 --> 05:19.720]  оставить минус r'.
[05:19.720 --> 05:24.960]  Да, sorry, sorry, sorry, последнее забудьте.
[05:24.960 --> 05:30.760]  Мы так далеко не уедем, наоборот, я все правильно перенес,
[05:30.760 --> 05:36.600]  давайте я просто 2 туда перекину, здесь оставлю r' от g
[05:36.600 --> 05:46.060]  минус r' от x плюс r' от x минус r' от x, а 2 просто пошла
[05:46.060 --> 05:49.780]  направо, минус 2, вот, мне достаточно доказать такое
[05:49.780 --> 05:50.780]  неравенство.
[05:50.780 --> 05:59.940]  Вот, ну давайте смотри, что такое минус r' от x, вот
[05:59.940 --> 06:01.620]  вот я его здесь специально вынес, так чтобы оно было
[06:01.620 --> 06:05.460]  одинаковое в обоих слагаемых, вычитаемые, в обеих скобках,
[06:05.460 --> 06:09.460]  тут минус r', тут минус r', что такое r', это двуечный
[06:09.460 --> 06:13.900]  грифом всего этого безобразия, что такое r' от g, это вот
[06:13.900 --> 06:21.700]  это, что такое r' от x, это вот это.
[06:21.700 --> 06:22.700]  Давайте как это обозначим.
[06:22.700 --> 06:45.700]  Ну окей, давайте перепишем, смотрите, r' это у меня логарифмы
[06:45.700 --> 06:49.020]  размеров по деревьев, разность логарифмов это логарифмы
[06:49.020 --> 06:51.900]  отношения размеров, поэтому первая скобка можно писать
[06:51.900 --> 06:57.180]  так, двуечный логарифм нового размера s' от g поделённым
[06:57.180 --> 07:01.100]  на старый размер s' от x, вторая скобка переписывается
[07:01.100 --> 07:06.700]  как двуечный логарифм s' от x делённым на s' от x, да,
[07:06.700 --> 07:12.740]  потому что rank это логарифм размера, ну и разность логарифмов
[07:12.740 --> 07:13.740]  это логарифм отношения.
[07:13.740 --> 07:16.700]  Вот, мне надо показать, что это минус два.
[07:16.700 --> 07:24.140]  Вот, тут должно быть понятно уже почему это верно.
[07:24.140 --> 07:32.340]  Давайте обозначим вот это вот за a, например, за b.
[07:32.340 --> 07:37.060]  Скажите, пожалуйста, какое-нибудь неравенство на a и b, вот глядя
[07:37.060 --> 07:38.060]  на эту картинку.
[07:38.060 --> 07:41.900]  То есть мы знаем, смотрите, a это что такое, a это отношение
[07:41.900 --> 07:46.700]  вот этого всего g, c и d ко всему дереву, b это вот это, отношение
[07:46.700 --> 07:49.100]  вот этого вот дерева x, a и b ко всему дереву.
[07:49.100 --> 07:54.100]  Что, например, можно сказать про a плюс b?
[07:54.100 --> 08:03.340]  Ну так нельзя сказать, потому что a это всё-таки отношение
[08:03.340 --> 08:05.500]  положительных чисел, но вряд ли будет отрицательным.
[08:05.500 --> 08:08.340]  Давайте про a плюс b сразу.
[08:08.340 --> 08:14.220]  A плюс b не больше, чем 1, потому что, смотрите, ещё раз,
[08:14.220 --> 08:18.500]  a это отношение вот этого поддерева ко всему, то есть g, c и d ко всему
[08:18.500 --> 08:25.340]  вот этому поддереву, вот оно a, а вот оно b, это отношение
[08:25.340 --> 08:28.020]  вот этого размера ко всему.
[08:28.020 --> 08:32.940]  Ну и как видим, они в объединении даже меньше, чем всё дерево,
[08:32.940 --> 08:36.580]  то есть здесь было x, a и b, здесь g, c и d, они в сумме даже
[08:36.580 --> 08:38.300]  всё не покрывают, потому что отсылается непокрытое
[08:38.300 --> 08:41.260]  p, поэтому там даже не меньше левровно, а строго меньше,
[08:41.260 --> 08:44.260]  потому что p не входит.
[08:44.260 --> 08:46.740]  Вот, ну и теперь осталось показать, что если у меня
[08:46.740 --> 08:49.860]  есть два положительных числа, понятно я, что они положительные,
[08:49.860 --> 08:52.140]  потому что это отношение положительных чисел, мне
[08:52.140 --> 08:54.500]  достаточно доказать, что если их сумма не больше
[08:54.500 --> 08:59.100]  единицы, то сумма их логарифмов меньше левровно минус двойки.
[08:59.100 --> 09:07.660]  Вот, ой, b потерялась.
[09:07.660 --> 09:09.580]  Ну давайте перепишем, значит, это не равен свеколентно
[09:09.580 --> 09:10.580]  следующему.
[09:10.580 --> 09:15.540]  Сумму логарифмов я напишу как логарифм произведения.
[09:15.540 --> 09:22.740]  Вот, ну а, например, отсюда я могу сделать вывод о том,
[09:22.740 --> 09:25.740]  что a, b не больше, чем, кажется, одна четверть.
[09:26.380 --> 09:29.580]  Если у меня есть два положительных числа, суммы не больше, чем
[09:29.580 --> 09:31.180]  один, то их произведения максимальны в случае, когда
[09:31.180 --> 09:35.500]  они равны, значит их произведения не больше, чем одна четверть.
[09:35.500 --> 09:37.700]  Значит, вот отсюда мы знаем, что a, b не больше, чем одна
[09:37.700 --> 09:40.300]  четверть, значит это автоматически следует.
[09:40.300 --> 09:44.820]  Вот, кажется так.
[09:44.820 --> 09:52.180]  Да, значит, кто не хочет следить за арифметикой,
[09:52.180 --> 09:54.860]  мы доказали, что учетная стоимость зиг-зига не больше
[09:54.980 --> 09:58.580]  чем вот это, оценивается сверху таким выражением.
[09:58.580 --> 10:01.020]  Кто хочет последить за арифметикой, спросите вопрос.
[10:01.020 --> 10:08.620]  Потому что, смотрите, а это что такое, это s'g делить
[10:08.620 --> 10:09.620]  на s'x.
[10:09.620 --> 10:10.620]  Давайте на картинке посмотрим.
[10:10.620 --> 10:17.020]  s'g это размер вот этого всего, g, c и d, s'x это все вот это.
[10:17.020 --> 10:18.500]  Что такое отношение?
[10:18.500 --> 10:20.060]  А отношение это количество вершин вот здесь поделить
[10:20.060 --> 10:21.060]  на количество вершин вот здесь.
[10:21.060 --> 10:22.060]  Что такое b?
[10:22.060 --> 10:24.260]  Это s от x делить на s' от x.
[10:24.420 --> 10:27.900]  То же самое, b это вот это вот, ну не b в смысле, а s от x
[10:27.900 --> 10:32.900]  это вот это, s' от x это все вот это, значит b это отношение
[10:32.900 --> 10:35.820]  вот этого человеческого ко всему, но они в объединении
[10:35.820 --> 10:37.860]  даже все не покрывают, поэтому сумма маленькая.
[10:37.860 --> 10:38.860]  Норм?
[10:38.860 --> 10:39.860]  Вот это?
[10:39.860 --> 10:47.180]  Ну потому что это одно и то же буквально, s' от x от
[10:47.180 --> 10:50.940]  двоичного грифма вот этого всего, а rg от двоичного грифма
[10:50.940 --> 10:54.060]  вот этого всего, но тут одинаковый число вершин.
[10:54.060 --> 10:58.700]  Сойдет?
[10:58.700 --> 11:01.260]  Ну балдеж.
[11:01.260 --> 11:07.740]  Вот, значит, нам осталось разобраться с зиг-зигом.
[11:07.740 --> 11:10.380]  Давайте картинка, ой, пардон, зиг-загом.
[11:10.380 --> 11:16.060]  Зиг-загом, да, значит, мне нужна тоже картинка, зиг-заг
[11:16.060 --> 11:18.940]  мы применяем в случае, когда x не корень и не сын
[11:18.940 --> 11:24.620]  корня, и при этом x и его родитель находятся по
[11:24.620 --> 11:27.620]  разных сторонах своих родителей, то есть, например, картинка
[11:27.620 --> 11:28.620]  вот такая.
[11:28.620 --> 11:34.060]  Вот, в этом случае я, наоборот, сначала вращаю нижнее
[11:34.060 --> 11:38.380]  ребро, потом верхнее, ну и после этого, значит, у
[11:38.380 --> 11:42.580]  меня x вылезает в корень, p остается слева, уже справа.
[11:42.580 --> 11:47.460]  Тут переподвешивается abcd.
[11:47.460 --> 11:51.220]  Опять же, кто записывал в прошлый раз, проверьте,
[11:51.220 --> 11:52.220]  что картинка такая же, пожалуйста.
[11:52.220 --> 11:55.220]  Похоже?
[11:55.220 --> 11:58.220]  Отлично.
[11:58.220 --> 12:01.220]  Ау?
[12:01.220 --> 12:12.100]  Зиг-заг написано, над вершиной же еще какой-то путь до корня.
[12:12.100 --> 12:14.420]  Это зиг-заг, название операции.
[12:14.420 --> 12:16.540]  Вот, ну давайте анализировать аналогично.
[12:16.540 --> 12:17.540]  Что такое зиг-заг?
[12:17.540 --> 12:18.940]  Точнее, учетная стоимость зиг-зага.
[12:18.940 --> 12:23.340]  Это, как обычно, два, плюс разных потенциалов, потому
[12:23.340 --> 12:25.620]  что я считаю, что у меня всего два поворота, поворот
[12:25.620 --> 12:28.820]  это элементарное действие, двойку пишу, вот, ну и плюс
[12:28.820 --> 12:29.820]  разных потенциалов.
[12:29.820 --> 12:37.180]  Тут то же самое, значит, плюс r' от x, плюс r' от p, плюс
[12:37.180 --> 12:48.140]  r' от g, минус r' от x, минус r' от p, минус r' от g.
[12:48.140 --> 12:51.740]  Смотрите, учетная стоимость, это всегда реальное время
[12:51.740 --> 12:53.180]  работы, плюс разных потенциалов.
[12:53.180 --> 12:56.700]  Давайте вот так вот напишу, а, это всегда t, плюс дельта
[12:56.700 --> 12:57.700]  фи.
[12:57.700 --> 12:59.820]  Ну не всегда в смысле, а если мы рассматриваем метод
[12:59.820 --> 13:01.700]  потенциалов, то мы говорим, что учетное время работы
[13:01.700 --> 13:04.060]  каждой операции, это реальное время работы, плюс разных
[13:04.060 --> 13:05.060]  потенциалов.
[13:05.220 --> 13:08.740]  Ну как бы после операции, минус перед операцией.
[13:08.740 --> 13:09.740]  Вот.
[13:09.740 --> 13:12.060]  Двойка как раз соответствует реальному времени работы.
[13:12.060 --> 13:14.180]  Ну что такое реальное время работы?
[13:14.180 --> 13:16.940]  Что мы реально делаем, когда выполняем зигзаг?
[13:16.940 --> 13:19.420]  Мы делаем два поворота, сначала вот такой, потом
[13:19.420 --> 13:20.420]  вот такой.
[13:20.420 --> 13:24.460]  Ну вот я говорю, что пусть поворот работает за одно
[13:24.460 --> 13:25.460]  действие.
[13:25.460 --> 13:28.580]  На самом деле там типа за пять, но неважно, мы можем
[13:28.580 --> 13:30.900]  так масштабировать, как бы, ну, я нигде не говорю, что
[13:30.900 --> 13:31.900]  такое элементарная операция.
[13:31.900 --> 13:33.700]  Вот, давайте считаем, что элементарная операция
[13:33.700 --> 13:34.700]  это поворот.
[13:34.700 --> 13:37.020]  Это всё равно константа, да, это не влияет на симпточку
[13:37.020 --> 13:38.020]  нигде.
[13:38.020 --> 13:39.020]  Вот.
[13:39.020 --> 13:44.620]  Так, ну здесь первый шаг такой же, что у меня вот
[13:44.620 --> 13:48.340]  это вот и вот это вот сокращается.
[13:48.340 --> 13:49.340]  По тем же причинам.
[13:49.340 --> 14:00.460]  И давайте опять же оценим r от p снизу через r от x.
[14:01.300 --> 14:02.300]  Вот.
[14:02.300 --> 14:06.460]  Тогда эта вся сумма будет не больше чем два плюс,
[14:06.460 --> 14:17.700]  эти сократились, r штрих от p плюс r штрих от g, минус
[14:17.700 --> 14:21.900]  r от p оцениваю сверху, как минус r от x, остается минус
[14:21.900 --> 14:24.900]  два r от x.
[14:24.900 --> 14:25.900]  Вот.
[14:26.660 --> 14:30.580]  И это я утверждаю не больше чем удвоенная разность
[14:30.580 --> 14:34.580]  рангов r штрих и r.
[14:34.580 --> 14:40.300]  Вот, опять же, это неравенство я утверждаю, сейчас буду
[14:40.300 --> 14:41.300]  доказывать.
[14:41.300 --> 14:42.300]  Вот.
[14:42.300 --> 14:45.340]  Ну, заметим, что если мы это докажем, то отсюда
[14:45.340 --> 14:46.980]  немедленно будет следовать, что эта штука не больше
[14:46.980 --> 14:49.820]  чем утроенная разность этих рангов, r штрих от x минус
[14:49.820 --> 14:50.820]  r от x.
[14:50.820 --> 14:55.660]  Ну, потому что ранг x только возрастает при подъеме,
[14:55.660 --> 14:59.100]  значит эта штука не отрицательна и можно сказать, что две
[14:59.100 --> 15:00.940]  не отрицательные штуки не больше чем три не отрицательные
[15:00.940 --> 15:01.940]  штуки.
[15:01.940 --> 15:08.180]  Так, ну давайте переписывать, я утверждаю, что верно вот
[15:08.180 --> 15:09.180]  это.
[15:09.180 --> 15:10.180]  Почему?
[15:10.180 --> 15:18.340]  Опять, тут много чего сокращается.
[15:18.340 --> 15:21.100]  Давайте проследим, что именно, видимо r штрих от p, r штрих
[15:21.100 --> 15:24.300]  от g сохраняются.
[15:24.300 --> 15:26.820]  Минус два r от x было здесь, минус два r от x было здесь,
[15:26.820 --> 15:28.180]  они полностью умерли.
[15:28.180 --> 15:31.780]  Осталось минус два r штрих от x.
[15:31.780 --> 15:33.180]  Надо показать, что эта штука не больше нуля.
[15:33.180 --> 15:39.260]  Вот, ну делаем то же самое, значит двойку туда перебрасываем,
[15:39.260 --> 15:41.740]  r штрих от x группируем по отдельности с этим и с этим,
[15:41.740 --> 15:43.860]  получаем следующее эквивалентное неравенство.
[15:43.860 --> 15:50.580]  r штрих от p минус r штрих от x плюс r штрих от g минус r штрих
[15:50.580 --> 15:51.580]  от x.
[15:52.260 --> 15:54.220]  Вот это вот надо показать, что не превосходят минус
[15:54.220 --> 15:55.220]  двойки.
[15:55.220 --> 16:01.540]  Ну а дальше такое же рассуждение, просто давайте посмотрим
[16:01.540 --> 16:04.860]  на этой картинке, что такое r штрих от p, ну так же давайте
[16:04.860 --> 16:06.900]  перепишем, что это такое.
[16:06.900 --> 16:10.900]  Это двоичный алгорифум s штрих от p делённый на
[16:10.900 --> 16:17.660]  r штрих от x, а это двоичный алгорифум s штрих от g делённый
[16:17.660 --> 16:19.700]  на r штрих от x.
[16:19.740 --> 16:22.900]  Надо показать, что это не больше, чем минус два.
[16:22.900 --> 16:29.340]  Это доказывается точно так же, потому что вот это
[16:29.340 --> 16:32.340]  отношение, что такое, смотрите, это вот это вот поделить
[16:32.340 --> 16:35.860]  на весь размер дерева, а правая штука, это вот это
[16:35.860 --> 16:37.780]  вот поделить на весь размер дерева.
[16:37.780 --> 16:40.540]  Опять сумма их не превосходит единицы, значит сумма двоичных
[16:40.540 --> 16:41.100]  алгорифумов не превосходит минус двойки.
[16:41.100 --> 16:45.660]  Точно такой же аргумент, просто другая картинка.
[16:45.660 --> 16:56.460]  вот оно первое слагаемое, вот оно первое слагаемое, вот оно второе слагаемое, будьте здоровы, вот можно
[16:56.460 --> 17:06.300]  поверить? Вопросы? Чудно. Хорошо, значит смотрите, что мы показали? Мы показали, что зиг-зиг не больше чем
[17:06.300 --> 17:14.740]  вот это учетно, зиг-заг не больше чем то же самое. И давайте вспомним, что у нас было просто для процедуры
[17:14.740 --> 17:24.180]  зиг, там было единица плюс утроенная разность рангов. Напоминаю, что было в конце прошлой лекции, мы
[17:24.180 --> 17:32.740]  доказали, что эта штука не превосходит единице плюс утроенная разность рангов. Вот. Ну тогда я
[17:32.740 --> 17:39.260]  утверждаю, что отсюда немедленно следует, что суммарно учетное время работы сплея не превосходит
[17:39.260 --> 17:49.380]  единицы плюс утроенный, давайте так напишу, rank final, где-нибудь вот здесь final, да, типа конечный
[17:49.380 --> 18:02.780]  rank x-а, минус rank initial, минус изначальный rank x-а. То есть то же самое, я не хочу просто перемешивать
[18:02.780 --> 18:07.780]  здесь штрихи, потому что штрих это у меня как бы одна операция, там, зиг-зиг-зиг или зиг-заг, здесь
[18:07.780 --> 18:14.180]  это как бы вот после всех этих операций конечный rank минус начальный. Вот. Ну почему? Потому что,
[18:14.180 --> 18:20.340]  вспоминаем, сплей это сначала последовательность зиг-зигов или зиг-загов, ну так как надо, да, то
[18:20.340 --> 18:26.820]  есть мы смотрим на x-а и его родителя, по одной стороны или по разной от родителя, если по
[18:26.820 --> 18:32.100]  одну то зиг-зиг, если по разной то зиг-заг, и так делаем, пока либо x не попал в корень, либо x не
[18:32.100 --> 18:37.220]  стал сыном корня. Значит у меня всегда сплей это последовательность зиг-зигов и зиг-загов и
[18:37.220 --> 18:42.700]  возможно плюс один зиг в конце. Вот. Ну отсюда как раз все получается. Вот, значит, давайте
[18:42.700 --> 18:53.920]  предположим, что у меня есть сначала какая-то цепочка зиг-зигов и зиг-загов. Вот. Ну и rank x-а как
[18:53.920 --> 18:58.580] -нибудь менялся. Давайте скажем, что у меня изначально был rank нулевой от x, потом после первого,
[18:58.580 --> 19:04.100]  скажем, зиг-зига у меня стал rank первое от x, потом rank второе и так далее, вплоть до какого-нибудь там
[19:04.100 --> 19:11.740]  rank k-та от x. То есть вот. Сначала в течение k шагов мы делали зиг-зиги или зиг-заги, вот так изменялся
[19:11.740 --> 19:18.780]  rank. И потом в конце еще в худшем случае произошел один зиг и у меня rank стал какой-то финальный rank x-а.
[19:18.780 --> 19:26.660]  Ну, значит, ну тогда смотрите, я знаю за сколько учет работает каждый из вот этих переходов. Все
[19:27.400 --> 19:32.320]  зиг-зиги и зиг-заги. Вот эта штука работает не больше, чем учетно утройная разность рангов r1 от x
[19:32.320 --> 19:38.100]  минус r0 от x. Потому что мы знаем, что зиг-зиг и зиг-заг работают не больше, чем утройенная разность рангов
[19:38.100 --> 19:43.400]  конечные после операции минус начальный. Поэтому здесь учетное время работает не больше, чем тройка на
[19:43.400 --> 19:49.340]  разность рангов. То же самое здесь. Вот эта вот штука, вот этой действия работает не больше чем 3 на r2 от
[19:49.340 --> 19:56.440]  x минус r1 от x. Потому что до операций был такой rank, после операции такой rank. Ну и так далее.
[19:56.440 --> 20:04.440]  Вот. Но на последнем шаге мы получаем, что учетное время работы вот этого последнего шага не больше чем 1 плюс утройная разность рангов.
[20:04.440 --> 20:11.440]  Ранг финальный минус ранг катый. Ранг финальный минус ранг катый.
[20:11.440 --> 20:19.440]  Ну вот, если все просуммировать, понятно, здесь все сократится, вот эти товарищи сократятся, вот этот сократится, вот этот сократится,
[20:19.440 --> 20:24.440]  останется как раз в точности 1 плюс утройная разность, ну короче вот ровно вот это получится.
[20:24.440 --> 20:31.440]  1 плюс утройная разность, конец минус начала.
[20:31.440 --> 20:37.440]  Так, нормально?
[20:37.440 --> 20:41.440]  Ну вот.
[20:41.440 --> 20:50.440]  Ну я вот решу свою штуку этого вот логарифма.
[20:50.440 --> 20:59.440]  И это совсем просто. Потому что что здесь написано? Тут написано 1 плюс утройная разность рангов, а ранг этот двоичный логарифм какого-то размера под дерево.
[20:59.440 --> 21:06.440]  Ну всего в дереве понятно не больше чем n вершин, значит любой ранг всегда не больше чем логарифм, ну и всегда не отрицательным.
[21:06.440 --> 21:16.440]  Значит здесь стоит не больше чем логарифм, тут из него даже что-то вычитается, ну значит понятно, что суммарно это не больше чем 1 плюс 3 логарифма, это все от логарифма.
[21:16.440 --> 21:19.440]  Да?
[21:19.440 --> 21:25.440]  Ну отлично, мы доказали, что учет на время работы сплоя это от логарифма.
[21:25.440 --> 21:29.440]  Вот, собственно, то что мы хотели.
[21:29.440 --> 21:33.440]  Отсюда в общем-то следует все что нужно.
[21:33.440 --> 21:42.440]  То есть смотрите, мы что сделали? Мы свели, точнее мы сказали, что после каждого запроса там find, insert или erase я запускаю сплей.
[21:42.440 --> 21:45.440]  И вот он работает учет на логарифм.
[21:45.440 --> 21:51.440]  Ну и тогда как бы понятно, что, давайте неформально скажу, смотрите, у меня find, за сколько работает find?
[21:51.440 --> 21:56.440]  Грубо говоря, он сначала дошел от корня до икса, ну там нашел или не нашел, прошел какое-то расстояние.
[21:56.440 --> 22:01.440]  И потом после этого вызывается сплей, который поднимает вот эту последнюю вершину в корень.
[22:01.440 --> 22:06.440]  То есть что-то там поднимает, какие-то повороты делают, зигзаги и так далее, поднимает икс в корень.
[22:06.440 --> 22:11.440]  Ну понятно тогда, что время работы реальное find и сплея примерно одно и то же.
[22:11.440 --> 22:15.440]  Потому что find спускался там, вот представьте, что он спустился на глубину h.
[22:15.440 --> 22:21.440]  Потом сплей его поднял вверх на ту же самую глубину h, значит он поворотов сделал как раз h.
[22:21.440 --> 22:23.440]  Поэтому у них время работы примерно одинаковое.
[22:23.440 --> 22:29.440]  Но если мы понимаем, что учетное время работы сплея алгорифм, то всего на стрете тоже учетное время работы алгорифм.
[22:35.440 --> 22:39.440]  Но здесь надо немножко аккуратнее на самом деле сказать, давайте я немножко про это скажу.
[22:39.440 --> 22:43.440]  Вот смотрите, мы оценили, например, учетное время работы сплей.
[22:43.440 --> 22:49.440]  Давайте оценим учетное время работы find.
[22:49.440 --> 22:51.440]  А тут совсем все просто.
[22:51.440 --> 22:54.440]  Вот такое учетное время работы find.
[22:54.440 --> 22:57.440]  Это реальное время работы плюс разных потенциалов.
[22:58.440 --> 23:02.440]  Ну find потенциал и не меняет, find сам по себе потенциал и не меняет,
[23:02.440 --> 23:06.440]  оно они просто спускаются, он дерево никак не меняет, потенциал в нем не меняется.
[23:06.440 --> 23:07.440]  Структура дерева не меняется.
[23:07.440 --> 23:09.440]  Поэтому остается только реальное время работы.
[23:09.440 --> 23:13.440]  Мы знаем, что реальное время работы такое же, как в сплее.
[23:13.440 --> 23:18.120]  И мы его в каком-то смысле реальное время работы
[23:18.120 --> 23:19.480]  файнда учли в сплое.
[23:19.480 --> 23:30.920]  Давайте я так напишу, что здесь find не изменяет потенциалов,
[23:30.920 --> 23:35.380]  и при этом реальное время работы файнда такое же,
[23:35.380 --> 23:38.380]  как у сплоя.
[23:38.380 --> 23:40.440]  Потому что если мы спустились на глубину h, то мы потом
[23:40.440 --> 23:43.880]  его подняли с помощью сплоя как раз за h действий.
[23:43.880 --> 23:52.880]  Ну вот, о, пардон, извините, опечатка, здесь т, конечно.
[23:52.880 --> 23:56.200]  Реальное время работы файнда такое же, как у сплоя.
[23:56.200 --> 24:01.760]  Почему, смотрите, что такое find?
[24:01.760 --> 24:04.680]  Это мы встали в корень и как-то шли в поиск х, нашли
[24:04.680 --> 24:06.560]  или не нашли, дошли до какой-то вершины.
[24:06.560 --> 24:09.880]  Вот пусть мы здесь делали h действий.
[24:09.960 --> 24:11.520]  Реальное время работы файнда на самом деле равно просто
[24:11.520 --> 24:15.200]  глубине от корня до той вершины, которой мы дошли.
[24:15.200 --> 24:16.200]  Вот это вот это вот.
[24:16.200 --> 24:17.200]  Что дальше происходит?
[24:17.200 --> 24:19.240]  Дальше вызывается сплей автоматически.
[24:19.240 --> 24:21.200]  Мы всегда после выполнения каждого запроса делаем
[24:21.200 --> 24:23.520]  сплей от последней посещенной вершины.
[24:23.520 --> 24:26.560]  Ну, за сколько работает сплей для этой вершины?
[24:26.560 --> 24:27.560]  За h.
[24:27.560 --> 24:29.920]  Потому что сплей все, что делает, он просто текущую
[24:29.920 --> 24:35.480]  вершину поднимает в корень и делает это, ну, как бы
[24:35.480 --> 24:37.280]  поворачивает тут какие-то ребра.
[24:37.360 --> 24:39.560]  Суммарно поворотов ровно столько, какой h.
[24:39.560 --> 24:40.840]  Поворот за единичку работает?
[24:40.840 --> 24:41.840]  Да, мы считаем, что за единичку.
[24:45.840 --> 24:49.040]  Ну вот, тогда утверждается отсюда следует, что out
[24:49.040 --> 24:51.600]  find есть от логарифма тоже.
[24:51.600 --> 24:55.280]  Да, потому что время работает там такое же, как в сплее,
[24:55.280 --> 24:56.280]  потенциалы вообще не меняются.
[24:56.280 --> 24:59.280]  Вот, поэтому...
[25:02.280 --> 25:03.760]  Ну, давайте так напишу.
[25:03.760 --> 25:06.760]  Нет, да, все нормально, все нормально.
[25:07.760 --> 25:08.760]  Вот.
[25:08.760 --> 25:12.760]  Поэтому, грубо говоря, учетное время такое же, как у сплея.
[25:12.760 --> 25:13.760]  Да.
[25:13.760 --> 25:19.760]  Как такой переход делается, что мы сравнили out find только
[25:19.760 --> 25:23.760]  с t от сплей, а не с a от сплей?
[25:23.760 --> 25:27.760]  То есть мы в учетное время сплея обошли логарифм,
[25:27.760 --> 25:31.760]  а настоящий время работает только с t от сплей?
[25:31.760 --> 25:34.760]  Тако мне не надо настоящий, мне только учетное важно.
[25:35.240 --> 25:40.240]  Ну, мы сравнили t от find с t от сплей.
[25:40.240 --> 25:41.240]  Да.
[25:41.240 --> 25:42.240]  Ну, смотрите еще раз.
[25:42.240 --> 25:44.240]  Окей, значит, смотри, что такое out find?
[25:44.240 --> 25:46.240]  Вообще, на самом деле...
[25:48.240 --> 25:51.240]  Так, давайте попробуем их объяснить.
[25:54.240 --> 25:57.240]  Смотрите, давайте полностью напишу, что происходит во
[25:57.240 --> 25:59.240]  время ответа на запрос find.
[25:59.240 --> 26:01.240]  Сначала я спускаюсь в дереве на глубину h.
[26:01.240 --> 26:04.240]  Реально время просто h в поисках x.
[26:04.720 --> 26:07.720]  За это у меня разных потенциалов не изменилось, потому что
[26:07.720 --> 26:09.720]  дерево не поменялось.
[26:09.720 --> 26:11.720]  После этого вызывается сплей.
[26:13.720 --> 26:15.720]  Время его работы тоже h.
[26:16.720 --> 26:18.720]  И на сколько-то поменялся потенциал.
[26:19.720 --> 26:21.720]  На какой-то delta phi.
[26:21.720 --> 26:23.720]  Из-за вот этих поворотов как раз меняется структура дерева.
[26:34.720 --> 26:36.720]  Давайте я вот так сделаю.
[26:38.720 --> 26:40.720]  Нет, плохо.
[26:40.720 --> 26:42.720]  Как бы сделать, чтобы было не очень плохо?
[26:50.720 --> 26:52.720]  Значит, тогда, что такое out find?
[26:52.720 --> 26:54.720]  Out find – это удвоенная h плюс delta phi.
[26:55.720 --> 26:58.720]  Потому что я сначала вниз спускаюсь на h, потом
[26:58.720 --> 27:00.720]  вверх поднимаюсь на h, и при этом
[27:00.720 --> 27:02.720]  разных потенциалов поменялось на delta phi из-за сплея.
[27:03.200 --> 27:05.200]  Учетное время – это реальное время плюс
[27:05.200 --> 27:07.200]  разных потенциалов.
[27:07.200 --> 27:09.200]  h плюс h – 0 плюс delta phi.
[27:12.200 --> 27:14.200]  А мы с вами знаем, что эта штука –
[27:14.200 --> 27:16.200]  это от логарифма.
[27:16.200 --> 27:18.200]  Сумма h и delta phi – это от логарифма.
[27:18.200 --> 27:21.200]  Но от того, что здесь напишу 2, а не 1.
[27:23.200 --> 27:25.200]  У меня на самом деле анализ сохранится такой же,
[27:25.200 --> 27:27.200]  как был.
[27:27.200 --> 27:29.200]  Я знаю, что h плюс delta phi –
[27:29.200 --> 27:31.200]  это от логарифма.
[27:31.680 --> 27:33.680]  От того, что у меня добавилась h,
[27:33.680 --> 27:35.680]  от этого у меня было бы
[27:35.680 --> 27:37.680]  вместо 2 – 4.
[27:37.680 --> 27:39.680]  И у меня анализ был
[27:39.680 --> 27:41.680]  сохранился полностью.
[27:41.680 --> 27:43.680]  Опять же, вот эту штуку
[27:51.680 --> 27:53.680]  Для полного лоска
[27:53.680 --> 27:55.680]  мне нужно было бы здесь
[27:55.680 --> 27:57.680]  потенциал заменить на
[27:57.680 --> 27:59.680]  удвоенный потенциал от исходного.
[28:00.160 --> 28:02.160]  Я знаю, что h плюс delta phi –
[28:02.160 --> 28:04.160]  это от логарифма.
[28:06.160 --> 28:08.160]  Но если бы у меня было
[28:08.160 --> 28:10.160]  2h плюс 2 delta phi,
[28:10.160 --> 28:12.160]  было бы тоже от логарифма.
[28:18.160 --> 28:20.160]  И если бы у меня изначальный phi
[28:20.160 --> 28:22.160]  удвоился,
[28:22.160 --> 28:24.160]  тогда у меня было бы
[28:24.160 --> 28:26.160]  удвоенный логарифм.
[28:26.160 --> 28:28.160]  Но опять же,
[28:28.160 --> 28:30.160]  проблема возникает только из-за того,
[28:30.160 --> 28:32.160]  что я проанализировал h плюс delta phi,
[28:32.160 --> 28:34.160]  а здесь 2h плюс delta phi возникает из-за того,
[28:34.160 --> 28:36.160]  что я спускаюсь вверх и вниз.
[28:36.160 --> 28:38.160]  Это все чинится тем,
[28:38.160 --> 28:40.160]  что надо подправить определение элементарной операции.
[28:40.160 --> 28:42.160]  У меня раньше был поворот. Давайте теперь скажем,
[28:42.160 --> 28:44.160]  что поворот делается за одну-вторую элементарную операцию.
[28:44.160 --> 28:46.160]  Это констант, она на анализ не влияет.
[28:46.160 --> 28:48.160]  Поэтому вот здесь
[28:48.160 --> 28:50.160]  двойка тут написана
[28:50.160 --> 28:52.160]  или просто h, с точки зрения суммы
[28:52.160 --> 28:54.160]  и метапотенциалов,
[28:54.160 --> 28:56.160]  это все можно считать просто h плюс delta phi.
[28:56.160 --> 28:58.160]  Остается логарифм.
[29:00.160 --> 29:02.160]  Аналогично со всякими инсертами и рейзами.
[29:02.160 --> 29:04.160]  Давайте инсерт нарисуем.
[29:10.160 --> 29:12.160]  Давайте инсерт нарисуем.
[29:14.160 --> 29:16.160]  Как работает инсерт?
[29:16.160 --> 29:18.160]  Он сначала
[29:18.160 --> 29:20.160]  куда-то в дереве спускается,
[29:20.160 --> 29:22.160]  находит подходящее место для x.
[29:22.160 --> 29:24.160]  Он как-то спускается
[29:24.160 --> 29:26.160]  и куда-то подвешивает x.
[29:28.160 --> 29:30.160]  Потом от него запускает сплей.
[29:34.160 --> 29:36.160]  Мне нужно показать,
[29:36.160 --> 29:38.160]  что когда я подвешиваю x,
[29:38.160 --> 29:40.160]  у меня не очень сильно портится потенциал.
[29:44.160 --> 29:46.160]  Потому что я знаю, что сплей
[29:46.160 --> 29:48.160]  после этого учетно работает за логарифм,
[29:48.160 --> 29:50.160]  но надо еще понять,
[29:50.160 --> 29:52.160]  какая разница потенциалов при подвешивании x.
[29:52.160 --> 29:54.160]  Равна delta phi при подвешивании просто.
[29:54.160 --> 29:56.160]  Насколько меняется потенциал при подвешивании новой вершины.
[29:56.160 --> 29:58.160]  Я подвешиваю, чтобы будет
[29:58.160 --> 30:00.160]  тоже не больше логарифма.
[30:04.160 --> 30:06.160]  Интуитивно смотрите,
[30:06.160 --> 30:08.160]  почему в худшем случае
[30:08.160 --> 30:10.160]  вообще насколько
[30:10.160 --> 30:12.160]  поменялся потенциал.
[30:12.160 --> 30:14.160]  У всех этих вершин
[30:14.160 --> 30:16.160]  увеличился размер по дереву на 1.
[30:16.160 --> 30:18.160]  Значит у них ранг тоже чуть-чуть увеличился.
[30:18.160 --> 30:20.160]  Скажем, если вот здесь было
[30:20.160 --> 30:22.160]  10 вершин в размере
[30:22.160 --> 30:24.160]  в этом по дереве,
[30:24.160 --> 30:26.160]  то логарифм был лог 10 и стал лог 11.
[30:26.160 --> 30:28.160]  Ну и так далее.
[30:28.160 --> 30:30.160]  То есть у всех этих вершин немножко поменялся ранг.
[30:30.160 --> 30:32.160]  Если здесь был какой-то размер
[30:32.160 --> 30:34.160]  SOV,
[30:34.160 --> 30:36.160]  то он станет SOV плюс 1.
[30:38.160 --> 30:40.160]  Ну и то же самое с рангом происходит.
[30:40.160 --> 30:42.160]  Было лого t, стал лого t с плюс 1.
[30:42.160 --> 30:44.160]  Но я утверждаю, что сумма изменений
[30:44.160 --> 30:46.160]  всех этих логарифм будет маленькая.
[30:46.160 --> 30:48.160]  Потому что насколько в худшем случае
[30:48.160 --> 30:50.160]  у меня изменился потенциал.
[30:50.160 --> 30:52.160]  Не больше, чем на логарифм
[30:52.160 --> 30:54.160]  ну скажем там
[30:54.160 --> 30:56.160]  1 минус логарифм 0,
[30:56.160 --> 30:58.160]  плюс логарифм 2 минус логарифм 1,
[31:00.160 --> 31:02.160]  плюс и так далее,
[31:02.160 --> 31:04.160]  плюс логарифм n,
[31:04.160 --> 31:06.160]  минус логарифм n минус 1.
[31:12.160 --> 31:14.160]  Да, это правильное замечание.
[31:14.160 --> 31:16.160]  Но его не было раньше, да.
[31:16.160 --> 31:18.160]  Его не было, а теперь появился,
[31:18.160 --> 31:20.160]  у меня просто появилось новое слагаемое
[31:20.160 --> 31:22.160]  в потенциале.
[31:22.160 --> 31:24.160]  Вот это соответствует иксу,
[31:24.160 --> 31:26.160]  вот это родителю икса и так далее.
[31:26.160 --> 31:28.160]  Но опять же здесь все сократилось,
[31:28.160 --> 31:30.160]  осталось только лог n.
[31:34.160 --> 31:36.160]  Поэтому суммарное изменение потенциала
[31:36.160 --> 31:38.160]  тоже максимально лого.
[31:38.160 --> 31:40.160]  А значит у меня все хорошо.
[31:40.160 --> 31:42.160]  То есть у меня инсерт работает
[31:42.160 --> 31:44.160]  за учетное время инсерта.
[31:44.160 --> 31:46.160]  Вот эта вот глубина плюс разным потенциалов,
[31:46.160 --> 31:48.160]  а мы знаем,
[31:48.160 --> 31:50.160]  и перед этим разным потенциалов небосьчим логарифм.
[31:50.160 --> 31:52.160]  И мы знаем, что вот эта вот глубина плюс
[31:52.160 --> 31:54.160]  разным потенциалов оценится сверху еще логарифмом.
[31:54.160 --> 31:56.160]  Поэтому суммарно
[31:56.160 --> 31:58.160]  аут инсерта
[31:58.160 --> 32:00.160]  работает за логарифм.
[32:04.160 --> 32:06.160]  Ну и то же самое с эрейзом.
[32:06.160 --> 32:08.160]  Уже не буду то же самое проделывать.
[32:08.160 --> 32:10.160]  Вот.
[32:10.160 --> 32:12.160]  Ну это детали.
[32:12.160 --> 32:14.160]  На самом деле можно
[32:14.160 --> 32:16.160]  понимать так,
[32:16.160 --> 32:18.160]  что я все равно, я свожу
[32:18.160 --> 32:20.160]  любой find, insert или erase,
[32:20.160 --> 32:22.160]  я после этого вызываю сплей.
[32:22.160 --> 32:24.160]  Поэтому в каком-то смысле время работы
[32:24.160 --> 32:26.160]  инсерта find и erase
[32:26.160 --> 32:28.160]  оценится сверху
[32:28.160 --> 32:30.160]  время работы сплея.
[32:30.160 --> 32:32.160]  Но если я про сплей доказал,
[32:32.160 --> 32:34.160]  что оно учетано логарифмично,
[32:34.160 --> 32:36.160]  то и все эти тоже учетано логарифмично.
[32:36.160 --> 32:38.160]  Надо только аккуратно еще сказать,
[32:38.160 --> 32:40.160]  что разным потенциалов тут небольшая будет
[32:40.160 --> 32:42.160]  после инсерта или эрейза.
[32:42.160 --> 32:44.160]  Но это делается.
[32:48.160 --> 32:50.160]  Ну что?
[32:50.160 --> 32:52.160]  Вопросы?
[32:52.160 --> 32:54.160]  Хорошо.
[32:54.160 --> 32:56.160]  Хорошо.
[33:06.160 --> 33:08.160]  Ладно.
[33:08.160 --> 33:10.160]  Давайте тогда покажем,
[33:10.160 --> 33:12.160]  что сплей еще умеет отвечать на
[33:12.160 --> 33:14.160]  те самые опциональные запросы,
[33:14.160 --> 33:16.160]  merge и split.
[33:16.160 --> 33:18.160]  Merge.
[33:18.160 --> 33:20.160]  Вот представьте, у вас было два корректных сплея дерева,
[33:20.160 --> 33:22.160]  вы хотите их склеить, хотите их объединить.
[33:26.160 --> 33:28.160]  Так.
[33:28.160 --> 33:30.160]  Ну это не всегда работает, да, видимо.
[33:30.160 --> 33:32.160]  Работает только, если
[33:32.160 --> 33:34.160]  все ключи одного меньше ключей другого.
[33:34.160 --> 33:36.160]  Да.
[33:36.160 --> 33:38.160]  Это работает только в предположении,
[33:38.160 --> 33:40.160]  что все ключи,
[33:40.160 --> 33:42.160]  ну все элементы в смысле, все элементы
[33:42.160 --> 33:44.160]  левого дерева
[33:46.160 --> 33:48.160]  меньше всех ключей правого.
[33:58.160 --> 34:00.160]  Тогда, как можно, например, сделать merge?
[34:00.160 --> 34:02.160]  Ну, смотрите, давайте я найду
[34:02.160 --> 34:04.160]  самое большое число в левом дереве.
[34:04.160 --> 34:06.160]  Максимальное число в левом дереве.
[34:06.160 --> 34:08.160]  Это делается просто.
[34:08.160 --> 34:10.160]  Я встаю в корень, иду направо, пока можно.
[34:10.160 --> 34:12.160]  Вот я встал в корень, иду направо,
[34:12.160 --> 34:14.160]  направо, направо в правый сын,
[34:14.160 --> 34:16.160]  и пока есть правый сын.
[34:16.160 --> 34:18.160]  Таким образом дойду до какой-то вершинки x,
[34:18.160 --> 34:20.160]  который, я утверждаю, будет максимально
[34:20.160 --> 34:22.160]  в этом дереве.
[34:22.160 --> 34:24.160]  Ну, потому что все, что левее, оно меньше,
[34:24.160 --> 34:26.160]  а правее никого нет.
[34:26.160 --> 34:28.160]  А мы такое уже делали, когда искали
[34:28.160 --> 34:30.160]  минимум в дереве и шли налево.
[34:30.160 --> 34:32.160]  Тут, наоборот, давайте найдем максимальное число
[34:32.160 --> 34:34.160]  здесь. Давайте вызовем
[34:34.160 --> 34:36.160]  сплей.
[34:36.160 --> 34:38.160]  Будьте здоровы. Сплей от x.
[34:38.160 --> 34:40.160]  Тогда левое дерево у меня
[34:40.160 --> 34:42.160]  перестроится так, что x станет корнем.
[34:44.160 --> 34:46.160]  Причем, поскольку он был максимальным, у него не будет
[34:46.160 --> 34:48.160]  правого сына. И все левое под дерево
[34:48.160 --> 34:50.160]  целиком уйдет влево.
[34:50.160 --> 34:52.160]  То есть все, что было здесь, вот это t, оно
[34:52.160 --> 34:54.160]  станет теперь вот здесь.
[34:54.160 --> 34:56.160]  У него не будет правого сына, потому что
[34:56.160 --> 34:58.160]  оно было максимально, значит
[34:58.160 --> 35:00.160]  никаких правых потомков у него быть не может.
[35:02.160 --> 35:04.160]  Ну, а после этого я просто могу взять подвес
[35:04.160 --> 35:06.160]  вот это сюда, и у меня будет корректный мерч.
[35:06.160 --> 35:08.160]  Вот если это какой-нибудь
[35:08.160 --> 35:10.160]  t-штрих, я просто беру и
[35:10.160 --> 35:12.160]  объявляю правым сыном x,
[35:12.160 --> 35:14.160]  то самое дерево t-штрих.
[35:18.160 --> 35:20.160]  Все.
[35:20.160 --> 35:22.160]  Ключи правого.
[35:22.160 --> 35:24.160]  Что значит ключи правого?
[35:24.160 --> 35:26.160]  Пардон, элементы, элементы. Извините.
[35:26.160 --> 35:28.160]  Тут элементы, тут элементы тоже.
[35:28.160 --> 35:30.160]  Ключи, элементы я буду смешивать.
[35:30.160 --> 35:32.160]  Это одно и то же.
[35:32.160 --> 35:34.160]  То, что лежит в вершине.
[35:40.160 --> 35:42.160]  Ну опять же, здесь можно аккуратно проанализировать,
[35:42.160 --> 35:44.160]  показать, что учетное время работы тоже будет
[35:44.160 --> 35:46.160]  логарифмическим. Потому что по факту
[35:46.160 --> 35:48.160]  все, что я сделал, запустил сплей, подвесил вот
[35:48.160 --> 35:50.160]  это сюда, но надо еще аккуратно посмотреть,
[35:50.160 --> 35:52.160]  что происходит с потенциалом, когда я
[35:52.160 --> 35:54.160]  делаю такое подвешивание.
[35:54.160 --> 35:56.160]  Но потенциал меняется на
[35:56.160 --> 35:58.160]  логарифм этого дерева,
[35:58.160 --> 36:00.160]  был какой-то логарифм x раньше,
[36:00.160 --> 36:02.160]  точнее все, что было здесь,
[36:02.160 --> 36:04.160]  он поменялся на
[36:04.160 --> 36:06.160]  еще что-то, потому что к нему что-то подвесилось.
[36:06.160 --> 36:08.160]  Но логарифм один стал другим,
[36:08.160 --> 36:10.160]  разность все равно логарифмическая примерно.
[36:10.160 --> 36:12.160]  Поэтому время работы мержа
[36:12.160 --> 36:14.160]  тоже амортизировано логарифм.
[36:14.160 --> 36:16.160]  Ну и сплит давайте.
[36:16.160 --> 36:20.160]  Сплит по значению k.
[36:20.160 --> 36:22.160]  Напоминаю, это процедура,
[36:22.160 --> 36:24.160]  которая требует от меня разбить
[36:24.160 --> 36:26.160]  одно большое дерево на два,
[36:26.160 --> 36:28.160]  таких, что в левом все ключи не больше k,
[36:28.160 --> 36:30.160]  а в правом все больше, чем k.
[36:30.160 --> 36:32.160]  То есть у меня было одно большое,
[36:32.160 --> 36:34.160]  я хочу его разбить так,
[36:34.160 --> 36:36.160]  что в левом все элементы не больше k,
[36:36.160 --> 36:38.160]  а в правом все больше k.
[36:38.160 --> 36:40.160]  Вот.
[36:40.160 --> 36:42.160]  Ну здесь какая-то похожая идея.
[36:42.160 --> 36:44.160]  Давайте мы сначала найдем
[36:44.160 --> 36:46.160]  наибольший элемент не больше, чем k.
[36:50.160 --> 36:52.160]  Найдем наибольший элемент
[36:52.160 --> 36:54.160]  не больше, чем k.
[36:58.160 --> 37:00.160]  Это можно сделать простым спуском по дереву.
[37:00.160 --> 37:02.160]  Встали в корень,
[37:02.160 --> 37:04.160]  если он больше, чем k, то нужно пойти влево,
[37:04.160 --> 37:06.160]  иначе и направо.
[37:06.160 --> 37:08.160]  Тем самым мы найдем максимальный элемент
[37:08.160 --> 37:10.160]  не больше, чем k.
[37:10.160 --> 37:12.160]  Вот нашли.
[37:12.160 --> 37:14.160]  Давайте от него вызовем сплей.
[37:14.160 --> 37:16.160]  Давайте скажу, что пусть это x,
[37:16.160 --> 37:18.160]  вызовем сплей от x.
[37:20.160 --> 37:22.160]  Тогда он у меня поднимется в корень,
[37:22.160 --> 37:24.160]  слева будут все еще меньше,
[37:24.160 --> 37:26.160]  чем x числа,
[37:26.160 --> 37:28.160]  а справа будут все больше, чем x.
[37:28.160 --> 37:30.160]  Тут меньше, чем x, тут больше, чем x.
[37:30.160 --> 37:32.160]  Ну и поскольку x у меня был
[37:32.160 --> 37:34.160]  наибольшим, меньше, либо больше,
[37:34.160 --> 37:36.160]  то здесь все числа будут в частности
[37:36.160 --> 37:38.160]  больше, чем k,
[37:38.160 --> 37:40.160]  потому что они больше, чем x,
[37:40.160 --> 37:42.160]  значит они больше, чем k.
[37:44.160 --> 37:46.160]  А раз x наибольший, меньше,
[37:46.160 --> 37:48.160]  то все, которые больше, больше, чем k.
[37:50.160 --> 37:52.160]  Ну и мы получили то, что нужно.
[37:52.160 --> 37:54.160]  Можно объявить вот это вот левым деревом,
[37:54.160 --> 37:56.160]  а вот это правым,
[37:56.160 --> 37:58.160]  потому что здесь все ключи меньше, либо равные,
[37:58.160 --> 38:00.160]  а здесь больше.
[38:04.160 --> 38:06.160]  Мы еще меньше, либо равные,
[38:06.160 --> 38:08.160]  поэтому идем влево.
[38:10.160 --> 38:12.160]  Вот.
[38:16.160 --> 38:18.160]  Хорошо.
[38:24.160 --> 38:26.160]  Ну и тут тогда,
[38:26.160 --> 38:28.160]  значит, если мы научились
[38:28.160 --> 38:30.160]  делать merges-play,
[38:30.160 --> 38:32.160]  то мы будем делать
[38:32.160 --> 38:34.160]  если мы научились делать merges-play,
[38:34.160 --> 38:36.160]  можно решить задачу.
[38:40.160 --> 38:42.160]  Как это? Сейчас скажу.
[38:52.160 --> 38:54.160]  Ну да.
[38:54.160 --> 38:56.160]  Давайте поговорим тогда про неявное дерево поиска.
[38:58.160 --> 39:00.160]  Чуть-чуть.
[39:02.160 --> 39:04.160]  Вот.
[39:04.160 --> 39:06.160]  Значит, это, например,
[39:06.160 --> 39:08.160]  то, чем можно решать задачи следующего типа.
[39:08.160 --> 39:10.160]  Представьте, у вас есть какой-то массив,
[39:14.160 --> 39:16.160]  и вы хотите над ним проделывать
[39:16.160 --> 39:18.160]  какие-то операции,
[39:18.160 --> 39:20.160]  ну там, не знаю, вырезание, удаление,
[39:20.160 --> 39:22.160]  что-нибудь такое, то есть у вас как бы надо поддерживать порядок элементов,
[39:22.160 --> 39:24.160]  слева-направо, 0, 1, 2 и так далее.
[39:24.160 --> 39:26.160]  И, например, надо, ну не знаю,
[39:26.160 --> 39:28.160]  вырезать какой-то кусок массива и переставлять
[39:28.160 --> 39:30.160]  в другое место. Или там просто взять и удалить элемент.
[39:30.160 --> 39:32.160]  Да, это вот то, что мы
[39:32.160 --> 39:34.160]  когда-то хотели научиться делать erase
[39:34.160 --> 39:36.160]  по позиции.
[39:36.160 --> 39:38.160]  Ну давайте я скажу, что какой-нибудь erase,
[39:38.160 --> 39:40.160]  а, например,
[39:40.160 --> 39:42.160]  аитова.
[39:42.160 --> 39:44.160]  То есть я хочу удалить этот элемент
[39:44.160 --> 39:46.160]  и как бы склеить две оставшиеся части массива.
[39:46.160 --> 39:48.160]  То, что было левее, то, что было правее.
[39:48.160 --> 39:50.160]  Я один элемент выбрасываю, а все, что осталось левее-правее, склеиваю.
[39:50.160 --> 39:52.160]  Ну и, наоборот, например, insert.
[39:52.160 --> 39:54.160]  Аитоя в данную позицию
[39:54.160 --> 39:56.160]  между двумя числами вставить какое-то новое число.
[39:56.160 --> 39:58.160]  Вот.
[39:58.160 --> 40:00.160]  Ну и там, не знаю, еще что-нибудь.
[40:00.160 --> 40:02.160]  То есть такие запросы, которые
[40:02.160 --> 40:04.160]  меняют структуру вашего массива.
[40:04.160 --> 40:06.160]  Меняют порядок элементов, вставляют элементы, удаляют.
[40:06.160 --> 40:08.160]  С порядком элементов
[40:08.160 --> 40:10.160]  что-то делают.
[40:10.160 --> 40:12.160]  Ну тогда можно
[40:12.160 --> 40:14.160]  хранить это все. Давайте хранить массив
[40:14.160 --> 40:16.160]  в дереве поиска.
[40:16.160 --> 40:18.160]  Храним массив
[40:18.160 --> 40:20.160]  в дереве поиска.
[40:28.160 --> 40:30.160]  Да.
[40:32.160 --> 40:34.160]  Ну, не важно.
[40:34.160 --> 40:36.160]  Как определено, так и будет.
[40:38.160 --> 40:40.160]  Главное, что однозначно определено.
[40:42.160 --> 40:44.160]  Так.
[40:48.160 --> 40:50.160]  Что-то я хочу сделать, нет?
[40:50.160 --> 40:52.160]  Давайте пример какой-нибудь нарисую, наверное.
[40:58.160 --> 41:00.160]  Вот.
[41:00.160 --> 41:02.160]  Значит, давайте построим
[41:02.160 --> 41:04.160]  дерево поиска,
[41:04.160 --> 41:06.160]  воспринимая, что у меня
[41:06.160 --> 41:08.160]  как бы они отсортированы.
[41:08.160 --> 41:10.160]  То есть у меня же ведь
[41:10.160 --> 41:12.160]  дерево поиска настроится на каких-то элементах.
[41:12.160 --> 41:14.160]  И там элементы между собой сравнятся.
[41:14.160 --> 41:16.160]  Давайте считать, что элементы
[41:16.160 --> 41:18.160]  это индексы в моем массиве.
[41:18.160 --> 41:20.160]  Ну, я не знаю,
[41:20.160 --> 41:22.160]  как это сделать.
[41:22.160 --> 41:24.160]  Я не знаю, как это сделать.
[41:24.160 --> 41:26.160]  Я не знаю, как это сделать.
[41:26.160 --> 41:28.160]  Это индексы в моем массиве.
[41:28.160 --> 41:30.160]  Ну, например, не знаю,
[41:30.160 --> 41:32.160]  пусть корнем там будет, скажем,
[41:32.160 --> 41:34.160]  вот это вот число
[41:34.160 --> 41:36.160]  минус три.
[41:36.160 --> 41:38.160]  Слева у него там будет
[41:38.160 --> 41:40.160]  что-то типа там вот так вот, например,
[41:40.160 --> 41:42.160]  один, два, семь.
[41:42.160 --> 41:44.160]  И здесь, например, четыре, минус один.
[41:44.160 --> 41:46.160]  Вот, например, так я могу хранить этот массив.
[41:46.160 --> 41:48.160]  Знаешь, что в корне минус три
[41:48.160 --> 41:50.160]  это вот это.
[41:50.160 --> 41:52.160]  Левее него в порядке
[41:52.160 --> 41:54.160]  один, два, семь. Вот они, один, два, семь.
[41:54.160 --> 41:56.160]  Справа минус один, четыре.
[41:56.160 --> 41:58.160]  То есть, дерево можно представлять таким образом.
[41:58.160 --> 42:00.160]  Точнее, массив можно представлять таким деревом.
[42:02.160 --> 42:04.160]  Вот.
[42:04.160 --> 42:06.160]  Ну, то есть, смотрите, оно не явное,
[42:06.160 --> 42:08.160]  потому что если я воспринимаю вот эти
[42:08.160 --> 42:10.160]  числа как ключи, как элементы,
[42:10.160 --> 42:12.160]  которые сравниваются, это не дерево поиска.
[42:12.160 --> 42:14.160]  Потому что у меня
[42:14.160 --> 42:16.160]  ну, много почему.
[42:20.160 --> 42:22.160]  Блин, а как оно получилось деревом поиска у меня?
[42:24.160 --> 42:26.160]  А, не, все-все. Вот, например, да, потому что
[42:26.160 --> 42:28.160]  слева от минус тройки лежит двойка.
[42:28.160 --> 42:30.160]  Это не дерево поиска, потому что вот здесь, например,
[42:30.160 --> 42:32.160]  нарушается неравенство. Вот.
[42:32.160 --> 42:34.160]  Но это именно будет деревом поиска,
[42:34.160 --> 42:36.160]  если я в качестве ключа
[42:36.160 --> 42:38.160]  буду воспринимать номер элемента.
[42:38.160 --> 42:40.160]  То есть, на самом деле, вот это вот,
[42:40.160 --> 42:42.160]  это тройка, типа вот номер,
[42:42.160 --> 42:44.160]  номер в исходном массиве, это тройка,
[42:44.160 --> 42:46.160]  здесь это единица,
[42:46.160 --> 42:48.160]  это, соответственно, ноль, это два,
[42:48.160 --> 42:50.160]  это четыре, это пять.
[42:50.160 --> 42:52.160]  И тогда это как раз будет дерево поиска.
[42:52.160 --> 42:54.160]  В вершинке три, то есть вот этот элемент,
[42:54.160 --> 42:56.160]  слева 0.1.2, справа 4.5.
[42:58.160 --> 43:00.160]  Вот. То есть, если бы я как бы мог у каждой
[43:00.160 --> 43:02.160]  вершины в качестве ее ключа,
[43:02.160 --> 43:04.160]  по которому они сравнятся, хранить индекс,
[43:04.160 --> 43:06.160]  тогда было бы дерево поиска, корректно.
[43:08.160 --> 43:10.160]  Вот. Но если я храню у всех индекс
[43:10.160 --> 43:12.160]  в явном виде, то мне проблемно
[43:12.160 --> 43:14.160]  делать всякие инферсы. Например, если я хочу вот сюда
[43:14.160 --> 43:16.160]  что-то ставить, какой-то новый х,
[43:16.160 --> 43:18.160]  тогда мне нужно
[43:18.160 --> 43:20.160]  у всех вот этих товарищей изменить индекс.
[43:20.160 --> 43:22.160]  Но это та же самая проблема, что у массива.
[43:22.160 --> 43:24.160]  Если я вставляю между двумя элементами,
[43:24.160 --> 43:26.160]  то у меня изменяется нумерация.
[43:26.160 --> 43:28.160]  И мне как бы нужно было бы тогда вот здесь сделать
[43:28.160 --> 43:30.160]  ко всем товарищам плюс один в ключ,
[43:30.160 --> 43:32.160]  в индекс. Я не хочу такого
[43:32.160 --> 43:34.160]  делать.
[43:34.160 --> 43:36.160]  Поэтому дерево на той и неявное,
[43:36.160 --> 43:38.160]  что я явным образом эти индексы хранить не буду.
[43:42.160 --> 43:44.160]  Но я их всегда могу восстановить по картинке.
[43:44.160 --> 43:46.160]  Смотрите, вот я индексы стер,
[43:46.160 --> 43:48.160]  но их можно однозначно
[43:48.160 --> 43:50.160]  восстановить. Их очень легко понять.
[43:50.160 --> 43:52.160]  Потому что что такое, например, самый левый
[43:52.160 --> 43:54.160]  элемент массива?
[43:54.160 --> 43:56.160]  Это самый левый элемент дерева.
[43:56.160 --> 43:58.160]  То есть, да, у него минимальный индекс,
[43:58.160 --> 44:00.160]  он должен быть минимальным элементом в плане ключей в дереве.
[44:00.160 --> 44:02.160]  Мы знаем, что минимальный всегда самый левый.
[44:02.160 --> 44:04.160]  Поэтому здесь ноль.
[44:04.160 --> 44:06.160]  Где лежит вот этот товарищ?
[44:06.160 --> 44:08.160]  Ну понятно, что вот здесь.
[44:08.160 --> 44:10.160]  Потому что это второй по минимальности
[44:10.160 --> 44:12.160]  элемент во всем дереве. Тут один.
[44:12.160 --> 44:14.160]  Ну и так далее.
[44:14.160 --> 44:16.160]  Поэтому на самом деле, даже если
[44:16.160 --> 44:18.160]  индексы я сотру, я могу это восстанавливать всегда
[44:18.160 --> 44:20.160]  легко потому, что я знаю, что, скажем, вот эта
[44:20.160 --> 44:22.160]  вершина, это какой-то элемент дерева,
[44:22.160 --> 44:24.160]  какой-то элемент массива
[44:24.160 --> 44:26.160]  Все что левее находится левее в массиве
[44:26.160 --> 44:28.160]  Вот минус тройка, вот она.
[44:28.160 --> 44:30.160]  Все что левее находится левее, все что правее находится правее.
[44:32.160 --> 44:34.160]  Поэтому, на самом деле, я утверждаю, что
[44:34.160 --> 44:36.160]  чтобы хранить... Чтобы уметь
[44:36.160 --> 44:38.160]  восстановить индексы, достаточно
[44:38.160 --> 44:40.160]  хранить размеры под деревьев.
[44:40.160 --> 44:42.160]  Например, если я знаю, что здесь размер Davis под дерево
[44:42.160 --> 44:44.160]  3, то
[44:44.160 --> 44:50.160]  Индекс этого элемента в точности будет 3, потому что перед ним идет 3 элемента 0,1,2, и он будет третьим.
[44:52.160 --> 44:58.160]  Вот здесь, например, у этого чувака левое поддерево имеет размер 1, поэтому размер этого поддерева 1.
[45:00.160 --> 45:09.160]  У этого чувака индекс будет 4, потому что до него идет целиком вот это поддерево, корень, а дальше он сам, то есть 0,1,2,3,4.
[45:10.160 --> 45:15.160]  Вот, поэтому на самом деле из размеров поддерева, из размеров всех поддерева все будет пересчитываться.
[45:17.160 --> 45:19.160]  То есть индексы я всегда могу восстановить через размеры поддерего.
[45:21.160 --> 45:30.160]  Ну и дальше, уже тогда я могу хранить, я могу просто сказать следующее, я не буду хранить ключи, я не буду хранить индексы, вершин, в массиве,
[45:30.160 --> 45:34.160]  просто скажи, что они восстанов martyrs размеры поддерев, а вот размеры поддерев я буду хранить.
[45:34.160 --> 45:41.840]  хранить. Ну и тогда, например, как сделать инсерт x на позицию между нулевым и первым элементом.
[45:41.840 --> 46:06.240]  Ну, смотрите, если я до вершины до этого дошел как-то, как я дохожу до вершины, я только
[46:06.240 --> 46:11.680]  из корни до нее дохожу. Поэтому все, что я здесь обхожу, я всю нужную информацию могу передать. То есть,
[46:11.680 --> 46:14.800]  не то, что я стоя в вершине, могу понять, какой у нее индекс, но, по крайней мере, я,
[46:14.800 --> 46:22.960]  идя из корни, я могу понять, какой у нее индекс. А, так вот, все, что-то я торможу. Смотрите,
[46:22.960 --> 46:28.440]  теперь, получается, у меня есть дерево, у меня есть дерево поиска, например, с Play. Давайте тогда,
[46:28.440 --> 46:33.760]  чтобы сделать инсерт аито, вот не знаю, был у меня такой массив, который был представлен
[46:33.760 --> 46:39.320]  как дерево. Я хочу между какими-то двумя элементами что-то вклинить. Давайте я сделаю сплит.
[46:39.320 --> 46:46.200]  Давайте я поспличу, то есть, я передам в качестве k как раз столько элементов, сколько мне нужно
[46:46.200 --> 46:54.360]  отрезать слева. Он мне рассплитит все моё дерево на два куска, вот на это вот и на вот это вот. То
[46:54.360 --> 47:00.200]  есть, у меня теперь как бы индексами выступают, pardon, ключами, да, элементы, которые я сравниваю в
[47:00.200 --> 47:06.400]  дереве. Являются индексы в массиве, мне нужно как раз первые k отрезать. Ну вот, я отрезаю с
[47:06.400 --> 47:11.960]  помощью сплита. У меня получается два с Play дерева, вот такое и вот такое. Теперь я между ними хочу
[47:11.960 --> 47:17.960]  вставить новое число x и склеить все в одно большое дерево, но это мерч же. Мерч вот этого, вот этого и
[47:17.960 --> 47:26.680]  вот этого. Получится новое с Play дерево, в нем индексы не хранятся, но хранятся размеры под
[47:26.680 --> 47:32.360]  деревьев. У меня теперь будет корректное дерево в том смысле, что сначала идут все вот эти
[47:32.360 --> 47:38.040]  элементы, потом x, потом все вот эти элементы в том же порядке, в котором они были раньше. То есть,
[47:38.040 --> 47:46.280]  после мерча у меня будет как раз тот самый массив, который был изначально со вставленным x. Ну все.
[47:46.280 --> 48:00.000]  Вот. То же самое с Erase. Чтобы что-то удалить из массива, мне нужно расплитить, ну давайте вот,
[48:00.000 --> 48:05.840]  у меня был такой массив, мне нужно удалить, скажем, вот этот элемент y, его надо удалить. Ну тогда
[48:05.840 --> 48:11.880]  давайте, если мы знаем, то есть у меня Erase по номеру, какой-нибудь там, индекс i, тогда мне нужно
[48:11.880 --> 48:17.640]  вот эти вот первые и минус один элемент отрезать слева, и справа отрезать все остальные там n минусы,
[48:17.640 --> 48:28.960]  и дальше вот эти два смержить. А про y забыть. Опять у меня останется дерево, построенное сначала
[48:28.960 --> 48:33.400]  по этим элементам, потом по этим, как раз в том же порядке, в котором были раньше, только уже без
[48:33.400 --> 48:39.280]  y то, что нам и нужно. Вот. Поэтому теперь мы все такая операция научились делать за логарифм в
[48:39.280 --> 48:51.600]  cosplay дерева, например. Нет, нет, нет, нет. Мы храним только размер под дерево целиком. И утверждаем,
[48:51.600 --> 48:56.920]  что если мы знаем размеры всех под деревьев, то мы любой вершины при необходимости знаем ее индекс.
[48:56.920 --> 49:05.680]  Вот. Хранить сами индексы, это плохо, потому что нам тогда их надо пересчитывать обильно. А
[49:05.680 --> 49:10.720]  размеры под деревьев пересчитывать почти не надо. То есть во всяких там поворотах, во всяких при
[49:10.720 --> 49:15.840]  подвешениях индексы считаются сложно, потому что там, грубо говоря, много индексов заменяется.
[49:15.840 --> 49:19.840]  А размер под дерева меняется только там один или два. При повороте у вас меняется всего два
[49:19.840 --> 49:25.000]  размера под деревьев. Если вы их все считаете, то у вас, если вы все обновляете, то у вас размеры
[49:25.000 --> 49:35.320]  под деревьев будет корректно всегда посчитано. Так, ну че? Окей.
[49:35.320 --> 49:56.040]  Хорошо. Хорошо. Так, тогда давайте пойдем дальше. Посмотрим еще одно дерево поиска,
[49:56.040 --> 50:10.680]  называется бедерево. Вот. Значит, ну мы понимаем, чем нам полезно сплэй-дерево. Во-первых,
[50:10.680 --> 50:15.440]  тем, что оно хранит недавние элементы близко к корню. Если какие-то запросы часто повторяются,
[50:15.440 --> 50:23.640]  то мы на них быстро отвечаем. Быстрее, чем глубина. Вот. Бедерево нужно будет, ну точнее,
[50:23.640 --> 50:28.600]  полезно в случае, когда у вас очень-очень-очень большая какая-то база, которую вы храните в
[50:28.600 --> 50:33.720]  дереве поиска, и вы не можете ее даже в оперативку поместить. Она находится где-то у вас там,
[50:33.720 --> 50:38.440]  на жестком диске или где-то на большом облачном хранилище, есть огромная база данных, представленная
[50:38.440 --> 50:43.960]  в виде как раз бедерево. Вы не можете ее целиком себе подгрузить в оперативку, у вас просто не
[50:43.960 --> 50:48.200]  столько ресурсов. Вы можете ее подгружать только небольшими блоками, небольшими страничками,
[50:48.200 --> 50:57.120]  там не знаю, сколькими-то мегабайтами. Вот. И теперь у меня как бы вершина, это будет как раз то,
[50:57.120 --> 51:03.480]  что я подгружаю из своей большой базы. Значит, смотрите, вершина у меня теперь представляется
[51:03.480 --> 51:13.320]  не одним числом, а набором чисел. Давайте скажем k1, k2 и так далее, какой-нибудь kst. Это набор
[51:13.320 --> 51:17.720]  ключей. Если раньше у меня вершина хранилась одно число, то теперь может быть много ключей.
[51:17.720 --> 51:22.360]  Причем эти ключи внутри одной вершины строго и порядочно, в порядке возрастания.
[51:22.360 --> 51:33.760]  Более того, если раньше у вершины был всего один сын, то теперь сын будет в каждом промежутке
[51:33.760 --> 51:40.520]  между ключами. То есть левее первого, между первым и вторым, между вторым и третьим и так далее,
[51:40.520 --> 51:46.800]  между последним и двумя и после последнего. Вот в каждом промежутке между ключами порождает
[51:46.800 --> 51:51.640]  какого-то сына. Здесь будет соответственно такая же вершина, здесь будет такая же вершина и так далее.
[51:51.640 --> 51:59.560]  Все вот эти штуки это отдельные вершины, которые еще вниз куда-то ведут. И при этом ключи,
[51:59.560 --> 52:05.080]  находящиеся в поддереве, ведут себя естественным образом. То есть вот те, которые слева от k1,
[52:05.080 --> 52:10.280]  здесь все ключи в этом поддереве будут меньше, чем k1. Ну потому что налево от k1, значит оно
[52:10.280 --> 52:16.680]  меньше, чем k1. Все это было вот в этом поддереве. Все, что находится в этом поддереве между
[52:16.680 --> 52:26.920]  ключами k1, k2, по значению будет лежать в диапазоне от k1 до k2. Ну и так далее. Между k2 и k3 будет
[52:26.920 --> 52:35.440]  диапазон между ними. После ks будет множество, ну точнее все, что находится здесь, имеют ключи больше,
[52:35.440 --> 52:46.760]  чем ks. Вот. То есть в каком-то смысле это просто обобщение бинарного деревопоиска двоичного,
[52:46.760 --> 52:51.960]  только теперь мы в вершине храним несколько чисел, и если у меня раньше было налево меньше,
[52:51.960 --> 52:57.520]  направо больше, то теперь каждая засечка между ключами порождает какое-то поддерево с диапазоном
[52:57.520 --> 53:04.720]  ключей. То есть то же самое, только я как бы размножил одну вершину, сказал, что в ней много
[53:04.720 --> 53:09.080]  ключей, она подразбивает вещественную прямую. Можно так нарисовать. Вот скажем, есть у меня вся
[53:09.080 --> 53:17.360]  вещественная прямая, на ней поставлены засечки k1, k2, и так далее, ks. Все, что здесь, это соответственно
[53:17.360 --> 53:23.920]  левый сын, вот эта вот штука, это вот эта вот. Дальше, между k1, k2 стрелка показывает на поддерево
[53:23.920 --> 53:29.720]  целиком вложенной вот сюда. Между k2 и k3 будет вот это, ну и так далее. Справа от ks это все,
[53:29.720 --> 53:43.840]  что справа от ks. Вот. Хорошо. Значит вот так у нас будет оно устроено. И теперь представьте,
[53:43.840 --> 53:50.480]  что вот ровно так дерево где-то хранится в большой базе данных. Так да, ну например,
[53:50.480 --> 53:57.640]  как делать в этом дереве find? Ну вроде несложно, надо встать в корень, find x. Встали в корень,
[53:57.640 --> 54:02.200]  дальше поняли между какими двумя ключами находится x. Скажем, если он больше чем k1,
[54:02.200 --> 54:07.440]  но меньше чем k2, то нужно пойти в это поддерево и там искать. Если оно между k2 и k3, надо пойти в
[54:07.440 --> 54:12.960]  это поддерево и там искать. То есть find более-менее такой же, как всегда. Только теперь надо понять из
[54:12.960 --> 54:18.280]  множества сыновей, в какого нужно идти. Хорошо.
[54:28.520 --> 54:34.720]  Так вот, как мы получаем информацию из базы данных? Как мы подгружаем данные из какого-то вот
[54:34.720 --> 54:40.240]  внешнего источника, внешнего хранилища? Ну обычно она подгружается какими-то блоками байтов,
[54:40.240 --> 54:46.320]  там какими-то страничками из небольшого количества мегабайт, например. И вот обычно считается,
[54:46.320 --> 54:51.040]  что как раз одна подгружаемая страничка, небольшой блок, который вы можете быстро получить из базы
[54:51.040 --> 54:57.000]  данных, это как раз вершина набора вот этих чисел k1 и так далее ks. Тогда вы подгрузили
[54:57.000 --> 55:03.240]  информацию про эту вершинку, поняли, где находится х, и вы сказали, окей, тогда мне нужна вот эта
[55:03.240 --> 55:07.200]  вот вершина. То есть там эта штука куда-то ведет, указывает на какую-то вершину, вы говорите,
[55:07.200 --> 55:12.840]  окей, я перехожу туда-то. Дальше подгружаете из базы содержимое этой вершины, идете туда,
[55:12.840 --> 55:18.480]  куда показывает, понимаете, где х, идете туда, куда надо. То есть у вас как бы элементарная
[55:18.480 --> 55:28.440]  операция обращения к базе это запрос содержимого вершины. То есть как бы самое сложное теперь это
[55:28.440 --> 55:33.400]  спуск по ребру, потому что чем больше у вас спусков, тем больше у вас обращений к базе,
[55:33.400 --> 55:37.960]  соответственно, тем больше выгрузок из нее. Поэтому мы хотим сделать так, мы хотим, чтобы вершина была
[55:37.960 --> 55:43.360]  потолще, чтобы в ней было много ключей, но при этом дерево было как можно менее глубокое, потому что
[55:43.360 --> 55:48.560]  чем оно глубже, тем больше запросов надо делать к базе, тем больше из нее надо делать выгрузок.
[55:48.560 --> 55:53.400]  Поэтому мы хотим, чтобы дерево было не глубокое, но широкое. То есть чтобы в вершине было много
[55:53.400 --> 55:58.560]  ключей. Ну а так оно обычно реализовано. Если вы хотите подгрузить хоть немножко информации,
[55:58.560 --> 56:03.800]  то у вас обычно подгрузится сразу блок вот этот целиком. Содержимое всей вершины вам полностью
[56:03.800 --> 56:10.080]  доступно. Вот так мы и сделаем. Мы сделаем дерево, у которого в вершине много ключей, но оно не глубоко.
[56:10.080 --> 56:25.480]  Определение B дерево с параметром t. Это какое-то целое число больше или равное двойке.
[56:25.480 --> 56:37.840]  Ну давайте я пишу. Дерево вот того вот вида с тремя свойствами. Во-первых, в корне ключей
[56:37.840 --> 57:01.840]  от 1 до 2t-1. Во-вторых, во всех остальных вершинах ключей от t-1 до 2t-1. И третье,
[57:01.840 --> 57:18.400]  оно нужно для анализа симптотики, все листья на одной глубине. То есть B дерево какая-то такая
[57:18.400 --> 57:24.040]  штука. У вас есть корень, возможно какой-то узенький, у него есть какие-то дети потолще уже,
[57:24.040 --> 57:30.400]  у них есть дети. Ну и все листины скажем на одной глубине, вот на этой.
[57:30.400 --> 57:51.720]  Целое больше равное двух. Ключей это вот этих кашек в каждой вершине. Вот тут S ключей. Чисел,
[57:51.720 --> 58:01.160]  который разделяет вещественную прямую. Утверждение очень простое. Глубина дерева
[58:01.160 --> 58:07.280]  с N ключами, то есть если в дереве хранится суммарно N элементов, N ключей, то глубина
[58:07.280 --> 58:17.160]  будет примерно алгорифм по основанию t от N. Глубина B дерева на N вершинах, на N ключах,
[58:17.480 --> 58:41.160]  с N ключами. Есть? O от логарифм N по основанию t. Доказательства. Как обычно сделаем наоборот.
[58:41.160 --> 58:48.720]  Давайте для фиксированной глубины посчитаем минимально возможное количество ключей. Пусть
[58:48.720 --> 59:03.000]  глубина равна h, каково минимальное количество ключей? Каково минимальное количество ключей
[59:03.000 --> 59:12.520]  при данной фиксированной глубине дерева? Если у меня фиксирована глубина и для каждой вершины
[59:12.520 --> 59:18.000]  у меня есть некий диапазон того, сколько ключей может быть в этой вершине, то понятно,
[59:18.000 --> 59:22.960]  мне нужно минимизировать в каждой вершине количество ключей. Потому что чем меньше ключей в вершине,
[59:22.960 --> 59:27.720]  тем у нее меньше детей, и значит мне нужно меньше ключей, чтобы покрыть все это дерево.
[59:27.720 --> 59:31.800]  Значит, минимум достигается в следующей конфигурации, когда в корне всего один ключ,
[59:31.800 --> 59:39.640]  в его детях по t-1 ключу, потому что минимально возможное t-1, дальше здесь у каждого из них
[59:39.640 --> 59:53.200]  тоже по t-1, ну и так далее, вплоть до глубины h. Ну и тогда понятно, что она ростет экспенциально
[59:53.200 --> 01:00:01.800]  по глубине, причем с основанием экспонента типа t. Да, ну давайте нарисуем. Здесь вершин,
[01:00:01.800 --> 01:00:09.320]  здесь скажем глубина, давайте так напишем, чему равна глубина, сколько здесь вершин. Значит,
[01:00:09.320 --> 01:00:16.800]  на глубине 1 у меня одна вершина, это просто вот этот ключ, на глубине 2 у меня 2t-1, не вершин,
[01:00:16.800 --> 01:00:27.200]  а ключей. Глубина 2, ключей 2t-1, потому что две вершины в каждой по t-1 ключу. На глубине 3,
[01:00:27.200 --> 01:00:42.760]  сколько здесь? 2t-1t-1. На t мне кажется просто, потому что у каждой вершины t детей. Да,
[01:00:42.840 --> 01:00:50.400]  потому что вот смотрите, у этих вершин здесь t-1 ключ, а значит детей t, потому что количество
[01:00:50.400 --> 01:00:54.520]  диапазонов, на которые данный t-1 ключ бьет вещественную прямую, это t, левее первого,
[01:00:54.520 --> 01:00:59.280]  между каждым двумя и после последнего, их когда здесь ровно t. И таких два, вот это и вот это,
[01:00:59.280 --> 01:01:08.200]  будет 2t на t-1. Ну и дальше на уровне 4 у меня будет 2t квадрат на t-1 и так далее. На глубине h будет
[01:01:08.200 --> 01:01:24.240]  что-то типа 2t h-2 на t-1. Ну если сложить, только раз получишь примерно t в степени h. Да, давайте
[01:01:24.240 --> 01:01:35.280]  просуммируем. Вот 1 плюс 2 на t-1, тут будет сумма t-шек в степени в нулевой, в первый,
[01:01:35.280 --> 01:01:44.560]  второй и так далее в степени t, t в степени h-2. Что это такое? Это что-то типа t в степени
[01:01:44.560 --> 01:01:55.480]  h-1-1 делить на t-1. Это сумма степеней t-шек. Вот t-1 сократилось, осталось 1 плюс удвоенное t в
[01:01:55.480 --> 01:02:13.720]  степени h-1-1. Вот. Это минимальное количество вершин в вот дереве глубины h. Ну и раз оно
[01:02:13.720 --> 01:02:20.800]  минимальное, то оно должно быть меньше и равное чем n, где n это настоящее число вершин. Пардон,
[01:02:20.800 --> 01:02:37.600]  ключей, ключей, ключей, ключей. Вот. То есть чего? У меня получилось 2 на t в степени h-1 меньше
[01:02:37.600 --> 01:02:46.000]  либо равно n плюс 1. Давайте еще пополам сразу поделю. Ну и теперь, если я возьму логарифм по
[01:02:46.000 --> 01:02:54.080]  основанию t, у меня как раз получится, что h-1 меньше либо равно 2-ичного логарифма по основанию t,
[01:02:54.080 --> 01:03:03.680]  вот n плюс 1 пополам. А, ну все. То, что нужно. Значит, глубина не больше, чем вот такой логарифм.
[01:03:03.680 --> 01:03:15.760]  То есть тут логарифм от n плюс 1 пополам, но понятно, что эта штука там не больше, чем n начинает,
[01:03:15.760 --> 01:03:21.880]  для всех n, начиная с какого-то. Поэтому это не больше, чем просто логарифм по основанию t. Так,
[01:03:21.880 --> 01:03:33.760]  хорошо? Потому что, смотрите, это мы посчитали минимально возможное количество ключей в дереве
[01:03:33.760 --> 01:03:38.240]  глубины h. Минимально возможен достигаться в такой конфигурации. Но если мы знаем,
[01:03:38.240 --> 01:03:45.280]  что в глубине h n ключей, это минимальное количество, а это настоящее количество ключей n. Здесь
[01:03:45.280 --> 01:03:49.880]  не нравится такое. То есть мы предполагаем, что есть дерево на n ключах с глубиной h,
[01:03:49.880 --> 01:04:07.080]  тогда n больше, чем минимум. Значит h не больше, чем логарифм. Так, ну хорошо, мы доказали,
[01:04:07.080 --> 01:04:13.840]  что глубина небольшая. Но раз глубина небольшая, то мы можем делать find быстро. Вот, например,
[01:04:14.440 --> 01:04:23.160]  find мы можем делать за сколько? Ну, кажется, за что-то типа t логарифм n по основанию t. Потому
[01:04:23.160 --> 01:04:29.200]  что в каждой вершине у меня примерно n ключей, но от t ключей. Если мне нужно найти x, то я сначала
[01:04:29.200 --> 01:04:39.320]  нахожу, где там x, между какими ключами находится x. Делаю это за t, потому что здесь примерно t ключей,
[01:04:39.320 --> 01:04:47.680]  от t ключей. Ну дальше перехожу в одного из сыновей. Еще раз? Вы про то, что можно бинпоиск сделать?
[01:04:47.680 --> 01:04:57.040]  Можно, но на самом деле, то есть можно здесь написать лог t, но да, конкретно найти x можно
[01:04:57.040 --> 01:05:05.200]  за лог t. Но у вас все равно это t уходит на подгрузку информации. Если вы живете в той модели,
[01:05:05.200 --> 01:05:09.680]  что именно для доступа к вершине мне нужно обратиться в вас, чтобы всю эту информацию перекопировать
[01:05:09.680 --> 01:05:13.680]  к себе куда-то, в оперативку, то как раз t берется как минимум от того, что мне нужно информацию
[01:05:13.680 --> 01:05:19.240]  перекопировать. Поэтому пишете вы здесь бинпоиск или линейный поиск, у вас t здесь остается,
[01:05:19.240 --> 01:05:24.600]  потому что у вас информацию надо откуда-то взять. Она у вас не лежит в памяти, к сожалению. Поэтому
[01:05:24.600 --> 01:05:34.640]  t множество остается. Понятно с файндом? Хорошо, теперь давайте попробуем сделать инсерт.
[01:05:42.640 --> 01:05:49.960]  Инсерт. Ну давайте считать, что x в дереве не было, потому что если он есть, то мы его находим и больше
[01:05:49.960 --> 01:05:55.440]  ничего не делаем. Он и так есть, делать ничего не нужно. Значит, иначе мы хотим добавить x в какой-то
[01:05:55.440 --> 01:06:02.160]  из листьев. Ну вот было у меня там какое-то такое дерево. В идеале было бы, то есть я спускаюсь в
[01:06:02.160 --> 01:06:07.720]  поисках x, дохожу до какого-то листика. И в идеале мне было бы просто вставить x сюда в нужное место
[01:06:07.720 --> 01:06:12.640]  между какими-то двумя соседними ключами. То есть я дошел до листа, в котором x должен был бы быть,
[01:06:12.640 --> 01:06:17.880]  если бы он был. Ну и дальше нахожу два соседних ключа, диапазон между которыми как раз должен
[01:06:17.880 --> 01:06:24.120]  содержать x. В идеале я бы просто его туда вставил и победил. Но, к сожалению, может нарушиться вот это
[01:06:24.120 --> 01:06:30.400]  вот условие, что у меня немного ключей в вершине. Да, ну потому что если бы, например, этого не было,
[01:06:30.400 --> 01:06:34.920]  то у меня бы деревом был бы, например, просто массив чисел отсортированный, туда вставлять и удалять
[01:06:34.920 --> 01:06:43.320]  долго. Вот, поэтому нужно как-то пофиксить случай вот этого переполненного вершины, переполненного
[01:06:43.320 --> 01:06:49.560]  узла. Когда там слишком много ключей, я не могу туда просто так что-то бесплатно вставить. Ну давайте
[01:06:49.560 --> 01:07:03.000]  напишем начало. Ну давайте интуицию напишу, что хотелось бы вставить x в подходящий лист,
[01:07:03.000 --> 01:07:19.480]  но он может быть заполнен. Заполнен, то есть в нем будет вот это максимально возможное количество
[01:07:19.480 --> 01:07:34.920]  ключей. Вот, надо с этим что-то делать. Давайте сделаем следующее. Давайте мы попробуем в то же
[01:07:34.920 --> 01:07:41.320]  время, пока мы ищем x, то есть пока мы спускаемся от корня до листа в поисках x, давайте поддерживать
[01:07:41.320 --> 01:07:51.960]  следующий вариант, что если я зашел в вершину, то в ней строго меньше, чем 2t-1 ключ. То есть в этом
[01:07:51.960 --> 01:07:59.520]  случае как раз я всегда могу вставить x в данную вершину. Давайте поддерживать инвариант. То есть
[01:07:59.520 --> 01:08:04.720]  наше неизменяемое свойство. Что мы хотим? Я хочу чтобы в вершине, в которой я нахожусь, было меньше
[01:08:04.720 --> 01:08:33.920]  чем 2t-1 ключ. Текущая вершина не заполнена, то есть в ней меньше, чем 2t-1 ключ. То есть вот я хочу
[01:08:33.920 --> 01:08:39.680]  идти, я встаю в корень, иду как-то сверху вниз в поисках x, и хочу чтобы те вершины, которые я
[01:08:39.680 --> 01:08:44.080]  проходил, были всегда не до конца заполнены, чтобы в них было место, куда вставить одно число,
[01:08:44.080 --> 01:08:49.760]  если нужно. Давайте думать, как это делать. Ну, например, там давайте я как-то начал, вот эти все
[01:08:49.760 --> 01:08:53.800]  вершины были не заполнены, хорошо, я просто по ним спускаюсь. Пусть я внезапно дошел до вершины,
[01:08:53.800 --> 01:09:01.160]  в которой 2t-1 ключ. Мне хочется что-то сделать, чтобы здесь уменьшить количество ключей.
[01:09:01.160 --> 01:09:12.480]  Давайте сделаем следующее. Давайте я нарисую картинку поприличнее. Давайте родителей еще
[01:09:12.480 --> 01:09:20.280]  рассмотрим. Вот был у меня родитель. Из него я, найдя диапазон между какими-то двумя средними
[01:09:20.280 --> 01:09:29.600]  ключами, перехожу в какую-то вершину, и вот в ней, например, пусть ровно 2t-1 ключ. Но при этом в
[01:09:29.600 --> 01:09:34.360]  родителе, поскольку я спускаюсь рекурсивно сверху вниз, давайте считать, что в родителе меньше,
[01:09:34.360 --> 01:09:38.960]  чем 2t-1 ключ. То есть, грубо говоря, это первое противоречие, где впервые у меня произошло
[01:09:38.960 --> 01:09:46.040]  заполнение вершин. Тогда можно сделать следующее. Давайте просто я найду здесь центральный элемент y,
[01:09:46.040 --> 01:09:51.680]  давайте m назову его. Центральный элемент m, то есть тот, до кого номер, видимо, ровно t.
[01:09:51.680 --> 01:10:01.800]  Да, t это элемент, ну центральный. И подниму его, вот просто возьму и подниму его вот сюда вот на
[01:10:01.800 --> 01:10:07.360]  позицию между теми двумя ключами, между которыми расположено все вот это вот под дерево. То есть,
[01:10:07.360 --> 01:10:12.200]  если здесь у меня было, скажем, a-b, то я просто беру и это m поднимаю и вставляю вот сюда между
[01:10:12.200 --> 01:10:18.400]  a-шкой и b-шкой. И я могу это сделать, потому что эта вершина при этом, она раньше была не заполнена,
[01:10:18.400 --> 01:10:31.040]  поэтому, если что, одно число и всегда могу смело поднять. Вот. И тогда у меня вот эта
[01:10:31.040 --> 01:10:35.800]  одна большая вершина на самом деле расплитится на две. У меня будет вот эта вот часть и вот эта
[01:10:35.800 --> 01:11:02.560]  вот часть. Будет корректное бы дерево. Сейчас нарисую еще раз. Да. Нет, 2t-2 это не проблема,
[01:11:02.560 --> 01:11:17.800]  2t-2 я туда могу поднять. Еще раз, 2t-2 не проблема, если 2t-2, то я могу сделать 2t-1. Где 2t-1?
[01:11:17.800 --> 01:11:27.320]  Вот здесь? Нет, все, я вас понял. Мне нужно, чтобы только в текущее, вот я спустился из родителя в
[01:11:27.320 --> 01:11:33.440]  новую и вот здесь 2t-1 меньше, чем 2t-1. То, что выше, мне уже не важно. Мне важно, что в текущей только.
[01:11:33.440 --> 01:11:48.560]  Сейчас. Дайте вот эту картинку дорисую. Еще раз, вот у меня был родитель, в диапазоне между двумя
[01:11:48.560 --> 01:11:56.120]  ключами была заполнена вот такая вершина. Я здесь беру центральный элемент m, его удаляю,
[01:11:56.120 --> 01:12:03.000]  поднимаю, вот сюда вот вставляю между h и b и теперь говорю следующее. Давайте перерисуем. Что станет?
[01:12:03.000 --> 01:12:12.800]  У меня будет a, m, b. Ну и там то, что было между ними. Теперь диапазон между a и m будет вести вот то,
[01:12:12.800 --> 01:12:19.680]  что было здесь раньше слева, левый кусок, левые половины массива. А между m и b будет то, что справа.
[01:12:19.680 --> 01:12:27.560]  Как раз все неравенства у меня будут сохранены, потому что l это что такое? Это с одной стороны то,
[01:12:27.560 --> 01:12:35.320]  что между a и b, но левее, чем m. Как раз, да, правее a, левее, чем m. r это то, что между a и b,
[01:12:35.320 --> 01:12:41.920]  но больше, чем m. Больше, чем m и между a и b. Все сохранилось. Поэтому такое расщепление вершины
[01:12:41.920 --> 01:12:49.320]  на две с подъемом центрального элемента вверх останется корректным b-деревом. Ну и тогда,
[01:12:49.320 --> 01:12:54.000]  если я уже отсюда, я все еще иду в поисках х, я понимаю, куда надо пойти сюда или сюда, например,
[01:12:54.000 --> 01:13:02.680]  сюда, ищу здесь x, find x, insert x, точнее, insert x. Ну а это уже будет вершина, которая не заполнена,
[01:13:02.680 --> 01:13:08.920]  в которой меньше 2t-1 ключ. Я ее специально расплитил и если нужно опять с этой вершиной я буду делать то
[01:13:08.920 --> 01:13:13.120]  же самое. Я спускаюсь в ребенка, если ребенок заполнен, то я могу центральный элемент поднять
[01:13:13.120 --> 01:13:17.400]  из него вверх. Ну и так далее. То есть, я когда спускаюсь вниз, я поддерживаю, что в текущей
[01:13:17.400 --> 01:13:35.000]  вершине ключей мало. Ну, меньше, чем максимум. Но у нас есть какая-то еще проблема, когда мы делим после вершин, которые мы делали изначально, у нас получается две части, l и r, каждой размером t-2, а должно быть... Не-не-не, t-1 ровно.
[01:13:35.000 --> 01:13:49.120]  t-1, плюс 1, плюс t-1, как раз 2t-1. Тут все четко как раз. Вот, да, значит, осталось, ну на самом деле,
[01:13:49.120 --> 01:13:54.400]  на самом деле все и так нормально, значит, надо понять только какая у нас база. Что происходит в корне,
[01:13:54.400 --> 01:13:58.200]  вот даже если корень, например, заполнен, что происходит в корне, если корень заполнен?
[01:13:58.200 --> 01:14:05.320]  Представьте, что в корне максимальное число ключей. Делаем ровно то же самое. Мы выбираем здесь,
[01:14:05.320 --> 01:14:14.720]  пусть это корень, в нем 2t-1 ключ. Я выбираю здесь центральный элемент, поднимаю его наверх, но сверху
[01:14:14.720 --> 01:14:20.680]  ничего не было, поэтому то, что становится сверху, становится новым корнем. И теперь у этого корня,
[01:14:20.680 --> 01:14:29.880]  этот корень слева ссылается вот на это под дерево, справа вот на это. То есть я по смыслу сделал то же
[01:14:29.880 --> 01:14:35.480]  самое. Я взял центральный элемент, поднял его в вершину выше и сказал, что теперь границы этой вершины
[01:14:35.480 --> 01:14:41.520]  слева-справа, указатели от нее, ведут на то, что было слева от нее и справа. Только теперь,
[01:14:41.520 --> 01:14:45.880]  поскольку у меня выше вершины не было, то я говорю, что, окей, тогда это новый корень. Вот у меня новая m,
[01:14:45.880 --> 01:15:05.480]  это новый корень. Нет, в корне от 1 до 2t-1 написано. У меня во всех вершинах максимум 2t-1,
[01:15:05.480 --> 01:15:13.120]  в корне минимум 1, а во всех остальных минимум t-1. То есть у меня в корне бывает такое.
[01:15:13.120 --> 01:15:26.600]  Еще раз давайте восстановим, что в корне у меня количество ключей от 1 до 2t-1, а в остальных от t-1
[01:15:26.600 --> 01:15:33.400]  до 2t-1. Вот такое определение. Если у вас по-другому, то исправьте. Вот в корне может быть 2t-1. И если
[01:15:33.400 --> 01:15:40.360]  2t-1, то я центрально также поднимаю наверх и говорю, что это новый корень. Вот. Все. И тогда,
[01:15:40.360 --> 01:15:46.840]  если у меня этот вариант сохраняется, если всегда, когда я спустился до вершины, в ней ключей меньше
[01:15:46.840 --> 01:15:53.440]  чем 2t-1, то я могу всегда вставить x, если нужно. И когда я дошел до листа, этот лист не заполненный,
[01:15:53.440 --> 01:16:06.800]  я могу вставить x, куда нужно, и победить, потому что лист не заполненный. Все. Согласны? Понятно?
[01:16:10.720 --> 01:16:28.840]  Вы имеете в виду содержимое? Как массив. Ну как вектор, да. Как вектор, я думаю. Так, ну что,
[01:16:28.840 --> 01:16:46.480]  пять минут, а сас на рейс, ну это, конечно, невозможно. Давайте идею, ладно. Давайте просто
[01:16:46.480 --> 01:16:58.240]  быстренько идею, как реализовать рейс. Наверное, полностью разбирать не будем. Ну, хотелось бы
[01:16:58.240 --> 01:17:04.560]  делать то же самое. Мне хотелось бы, чтобы в той вершине, откуда я хочу удалить x, было не минимально
[01:17:04.560 --> 01:17:10.600]  возможное количество ключей, то есть не t-1. Если в вершине не t-1 ключ, то, наверное, мы сможем
[01:17:10.600 --> 01:17:23.520]  победить. Вот давайте этого попытаемся добиться. В текущей вершине ключей хотя бы t, ну или она
[01:17:23.520 --> 01:17:28.720]  корень. Или она корень. Потому что все-таки в корне мы такого добиться не можем. Или она корень.
[01:17:28.720 --> 01:17:41.200]  Окей. Ну давайте опять-таки спускаемся в поисках х. Куда-то идем-идем-идем. Дошли, например, до вершины,
[01:17:41.200 --> 01:17:47.480]  в которой это условие не выполняется. То есть в ней минимально возможное плохое количество ключей t-1.
[01:17:47.480 --> 01:17:56.200]  Тогда, если раньше я вершину расщеплял, то теперь мне нужно делать наоборот. Мне нужно, ну как бы,
[01:17:56.200 --> 01:18:00.960]  мне нужно посмотреть на собратьев и, возможно, с кем-то из них склеить. Вот смотрите, вот у меня
[01:18:00.960 --> 01:18:09.480]  была вершина с t-1 ключом. Давайте посмотрим на соседнюю вершину слева, среднюю вершину справа.
[01:18:09.480 --> 01:18:16.400]  Ну то есть у меня же все вершины упорядоченные как бы по уровню. Есть непосредственный брат слева,
[01:18:16.400 --> 01:18:23.160]  непосредственный брат справа. То есть у меня как бы есть вершина такая, что диапазон между
[01:18:23.160 --> 01:18:28.960]  двумя числами указывает сюда, между вот этим двумя сюда, между вот этим двумя сюда. А вот в этом
[01:18:28.960 --> 01:18:34.200]  смысле брат слева справа. Ну тогда, например, смотрите, если у меня вот здесь вот ключи хотя бы t,
[01:18:34.200 --> 01:18:53.240]  то я могу просто взять, давайте какие-нибудь буквы введу, а, б. Так, как я это сделаю? Да, тогда
[01:18:53.240 --> 01:18:58.600]  я могу просто взять и поднять a сюда, а b спустить вот сюда, и тем самым увеличить здесь количество
[01:18:58.600 --> 01:19:05.480]  ключей на один. То есть после преобразования у меня будет вот такая штука, у меня будет
[01:19:05.480 --> 01:19:12.840]  вместо b находиться a, а из левого по дереву просто уйдет, здесь останется t-1 ключ, а b спустится вот
[01:19:12.840 --> 01:19:18.760]  сюда, вот в эту вершину, ну поскольку она была левее, чем разделить, она перейдет самый левым
[01:19:18.760 --> 01:19:25.920]  ключом, станет здесь. Здесь будет b и после него t-1 ключ. То есть по факту я просто a поднял сюда,
[01:19:25.920 --> 01:19:33.680]  а b спустил сюда. Опять, можно легко доказать, что это останется корректным b-деревом,
[01:19:33.680 --> 01:19:41.440]  ну потому что, например, все вот эти элементы должны быть, ну они больше, чем b, потому что они
[01:19:41.440 --> 01:19:47.120]  лежат правее этого указателя, значит, ну как раз здесь все хорошо, они справа от b. A было меньше,
[01:19:47.120 --> 01:19:53.160]  чем b, потому что оно было левее здесь, и здесь все нормально, b находится правее, чем a. Короче,
[01:19:53.160 --> 01:19:57.320]  все нормально, это остается корректным b-деревом. Но при этом, смотрите, мы позаимствовали один
[01:19:57.320 --> 01:20:03.440]  ключ у брата и увеличили количество ключей в самом себе. Значит, у нас стало как раз хотя бы
[01:20:03.440 --> 01:20:10.800]  t ключей, все хорошо. То же самое можно с правым, если с правой хотя бы t ключей. Если у обоих
[01:20:10.800 --> 01:20:17.640]  братьев t-1 всего лишь ключ, то мы можем с одним из братьев склеиться. Значит, вот у меня был,
[01:20:17.640 --> 01:20:30.040]  ну давайте левого нарисую просто, вот у меня был левый брат, вот я. Вот, здесь t-1, здесь t-1,
[01:20:30.040 --> 01:20:35.040]  между ними разделитель какой-нибудь x. Тогда я могу просто сказать следующее, давайте я вот
[01:20:35.040 --> 01:20:42.200]  это вот все безобразие вместе с x объеденю, сделаю новой вершиной. То есть я x спущу в промежуток
[01:20:42.200 --> 01:20:48.960]  между братьями, сюда его вставлю, и склею все это, скажу, что это одна новая большая вершина,
[01:20:48.960 --> 01:20:57.840]  но уже как раз ровно с 2t-1 ключом. Так имею право сделать, потому что x как раз он находится в
[01:20:57.840 --> 01:21:03.920]  диапазоне между всеми этими и всеми этими, поэтому будет корректное b-дерево. И как раз я имею право
[01:21:03.920 --> 01:21:09.000]  позаимствовать x сверху, потому что я иду сверху, у меня выполняется всегда это условие, если здесь
[01:21:09.000 --> 01:21:17.080]  было хотя бы t ключей, то я имею право x спустить вниз. Вот, поэтому всегда, когда я нахожусь в вершинке,
[01:21:17.080 --> 01:21:23.720]  в ней будет хотя бы t ключей. Вот, ну все, ну и типа и там, и там доделывается, короче,
[01:21:23.720 --> 01:21:27.840]  давайте на этом остановимся, Eraser на этом достаточно. Все, спасибо.
