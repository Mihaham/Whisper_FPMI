[00:00.000 --> 00:13.320]  Так, давайте начнем. Значит, мы постепенно приближаемся к центральному
[00:13.320 --> 00:18.360]  результату вот этой части курса, то есть именно теоремии о том, что бывают
[00:18.360 --> 00:22.240]  причислимые, но неразрешимые множества. Может быть, даже мы сегодня в конце его
[00:22.240 --> 00:28.560]  успеем изучить, ну, может быть, начнем с этого следующего лекции.
[00:28.560 --> 00:34.000]  По крайней мере, первую половину лекции я хотел посвятить вопросу о том, что
[00:34.000 --> 00:41.880]  вообще такое перечислимое множество. Да, у нас в прошлый раз было определение, но на
[00:41.880 --> 00:47.800]  самом деле есть много других определений, и разные факты удобно
[00:47.800 --> 00:52.600]  доказывать через разные определения. Ну, точнее, так часто говорят про разные
[00:52.600 --> 00:56.920]  определения, но мне кажется, корректнее говорить про одно определение и много
[00:56.920 --> 01:02.120]  эквивалентных свойств. Значит, так что, давайте так и озаглавим. Эту часть
[01:02.120 --> 01:08.120]  свойства эквивалентной перечислимости.
[01:09.880 --> 01:14.840]  Свойства эквивалентной перечислимости.
[01:18.480 --> 01:25.640]  Значит, базовое определение, которое считается определением, точнее, базовое
[01:25.640 --> 01:29.600]  свойство, которое считается определением, то, что есть перечисляющая машина. Да,
[01:29.600 --> 01:36.680]  давайте его назовем, значит, обозначим цифрой 0. Значит, нулевое
[01:36.680 --> 01:42.760]  свойство, которое оно же определение, то, что есть перечисляющая машина. Значит,
[01:42.800 --> 02:02.720]  есть машина с потоком вывода. Такое, что множество выведенных слов совпадает с
[02:02.720 --> 02:11.560]  данным. Такое, что множество выведенных слов
[02:12.760 --> 02:27.240]  совпадает с данным множеством. Тогда данные может перечислим.
[02:27.240 --> 02:35.760]  Ну, это можно по-разному рассказывать. Можно говорить, что любое слово из множества
[02:35.760 --> 02:40.240]  будет рано или поздно напечатано, а любое слово не из множества не будет напечатано
[02:40.240 --> 02:45.600]  никогда. Значит, при этом, если множество бесконечное, то такая машина не может
[02:45.600 --> 02:51.240]  остановиться. То есть, она будет работать бесконечно долго, чтобы вынести бесконечно
[02:51.240 --> 02:57.800]  много слов. Вот так. Хорошо, значит, тогда какие еще есть свойства эквивалентные?
[02:57.800 --> 03:08.200]  Так, ну, например, первое. Значит, первое, давайте в том же духе, что есть такая же
[03:08.200 --> 03:20.280]  машина, напечатающая без повторений. Давайте я напишу аналогично, только печать без
[03:20.360 --> 03:34.560]  повторений. Аналогично, но слова в выводе не повторяют. Во выводе не повторяются.
[03:34.560 --> 03:57.200]  Так, значит, второе свойство. Значит, второе давайте через полухарактеристическую функцию.
[03:57.200 --> 04:17.200]  Значит, вычислимо полухарактеристическая функция. Значит, в полоте была характеристическая,
[04:17.200 --> 04:24.400]  которая единица внутри множества и ноль вне множества. А вот эта вот функция, дайте ее
[04:24.400 --> 04:34.800]  обозначим из чертой с индексом А от Х. Это по-прежнему будет единица, если Х принадлежит А, и не
[04:34.800 --> 04:54.680]  определено, не определено, если Х не принадлежит А. Вот так, хорошо. Значит, третье. Значит, я думаю,
[04:54.680 --> 05:06.480]  что мы не все это изучим, не все свойства. Значит, третье, что А это область определения вычислимой
[05:06.480 --> 05:24.480]  функции. Значит, четвертое, то А это область значений вычислимой функции. Значит, пятое, А это пустое,
[05:24.480 --> 05:51.480]  или А это область значений. Так, а что такое? Область значений судо-определенной вычислимой
[05:51.480 --> 06:02.480]  функции. Значит, такие функции еще называются тотально вычислимыми. Значит, тотально вычислимая
[06:02.480 --> 06:16.480]  функция. Это просто синоним. Так, ну и дать на это шестое. И на этом осталось, там можно еще парочку
[06:16.480 --> 06:28.480]  добавить. Вообщем, шестое будет следующее, что А это проекция разрешимого множества пар. Проекция
[06:28.480 --> 06:38.480]  разрешимого множества пар В. Вот, что значит проекция? На начале, что мы вторую координату забыли.
[06:38.480 --> 06:50.480]  Ну не забыли, а стерли. Да, то есть А это множество таких Х, то существует Y такое, что пары Х,
[06:50.480 --> 07:05.480]  пары Х, Y лежит в В. Так, что же тут не так? На моем с доской, а не со стилусами. Значит, пары Х,
[07:05.480 --> 07:15.480]  Y лежит в В. Значит, при этом В разрешима. Значит, можно еще немножко поговорить про то, что такое
[07:15.480 --> 07:24.480]  разрешимое множество пар. И про это можно говорить двумя способами. Значит, можно прямо ввести какую-то
[07:24.480 --> 07:32.480]  явную модель вычисления на парах. Например, у машины тюринга на входе записано сначала одно слово,
[07:32.480 --> 07:38.480]  потом пробел, потом другое слово. И вот это мы считаем, что мы пару подали на вход машине тюринга.
[07:38.480 --> 07:45.480]  Или, например, у машины тюринга будет две ленты, и на первой ленте записано одно слово,
[07:45.480 --> 07:51.480]  на второй ленте записано другое слово. Ну или любым другим способом мы как-то научились подавать
[07:51.480 --> 08:01.480]  два аргумента на вход программе. И тогда получается та же самая теория, что мы можем считать, что если
[08:01.480 --> 08:13.480]  подали пару из множества В, то тогда машина выдала 1, если подали на вход не из В, то машина выдала 0.
[08:13.480 --> 08:19.480]  Это будет разрешимое множество пар. Это один подход, а второй подход, что мы просто как-нибудь закодило
[08:19.480 --> 08:27.480]  пары в отдельные числа или в отдельные слова. Но тоже есть много разных способов, да там
[08:28.480 --> 08:36.480]  взаимнооднозначная, не взаимнооднозначная. И тогда мы используем обычную программу с одним входом.
[08:36.480 --> 08:44.480]  Но этот вход понимается как код пары. И можно считать, что программа начинает с того, что она декодирует
[08:44.480 --> 08:48.480]  эту пару в два одинаковых аргумента, и потом уже с ними что-то вычисляет.
[08:48.480 --> 08:54.480]  Ну, в общем, это все одно и то же. И на интуитивном уровне вообще никакой разницы нет.
[08:54.480 --> 08:59.480]  Просто есть алгоритм, который по паре понимает, лежит эта пара в множестве В или не лежит.
[08:59.480 --> 09:08.480]  Ну а тогда утверждается, что если мы вот вторую карнавсу отрем и оставим только первую, то разрешимое
[09:08.480 --> 09:15.480]  множество превратится в перечислимое. И наоборот, любое перечислимое может быть представлено в таком виде.
[09:15.480 --> 09:25.480]  Так, хорошо. Но давайте в каких-то направлениях это докажем.
[09:25.480 --> 09:34.480]  Да, да, да. То есть множество перечислимое утверждает следующее, что множество перечислимое
[09:34.480 --> 09:39.480]  тогда и только тогда, когда для некоторого разрешимого В выполнено это равенство.
[09:39.480 --> 09:46.480]  Так, хорошо. Ну давайте скажем из 0, 1.
[09:46.480 --> 09:51.480]  Значит, как может пришлять без повторений?
[09:51.480 --> 09:58.480]  Значит, идея такая, что мы запускаем старый...
[09:58.480 --> 10:03.480]  Да, во-первых, очевидно, что из единицы следует 0, потому что это просто частный случай.
[10:03.480 --> 10:11.480]  Да, значит, из единицы 0 очевидно, из 0, 1 следующее.
[10:11.480 --> 10:18.480]  Вот пусть у нас есть программа, которая перечисляет, может быть, с повторениями.
[10:18.480 --> 10:24.480]  Но мы ее... Выход будем обрабатывать так.
[10:24.480 --> 10:36.480]  Значит, будем запускать программу, печатающуюся повторениями.
[10:36.480 --> 10:46.480]  Но вывод не забывать, а хранить. И хранить все уже напечатанное.
[10:46.480 --> 10:55.480]  И хранить все уже напечатанные слова.
[10:55.480 --> 11:07.480]  И далее при получении нового слова.
[11:07.480 --> 11:14.480]  При получении нового слова.
[11:14.480 --> 11:33.480]  Прежде чем напечатать, проверить, что оно не было раньше.
[11:34.480 --> 11:45.480]  Проверить, что оно не было напечатано раньше.
[11:45.480 --> 11:53.480]  Не было напечатано раньше. Ну и соответственно, если было, то тогда пропускаем.
[11:53.480 --> 11:56.480]  И заданными не печатаем.
[11:56.480 --> 12:03.480]  Если было, то пропускаем.
[12:03.480 --> 12:10.480]  Если не было, то печатаем.
[12:10.480 --> 12:15.480]  Ну и тогда ясно, что от всех повторов останется только самый первый.
[12:15.480 --> 12:21.480]  Если слово встретилось первый раз, и еще раньше не было ни разу напечатано, то мы его напечатаем.
[12:21.480 --> 12:26.480]  А если оно уже было, то сколько бы раз оно не повторялось, мы все равно все новые
[12:26.480 --> 12:34.480]  разы пропустим, и в итоговый поток их не отправим.
[12:34.480 --> 12:43.480]  Вот так. Ну что, понятно, да?
[12:43.480 --> 12:50.480]  Более чем счетов тут вообще ничего нет.
[12:50.480 --> 12:56.480]  Потому что и сами алгоритмы записывают словами в конечном алфавите,
[12:56.480 --> 12:58.480]  и то, с чем они работают, записывают словами в конечном алфавите.
[12:58.480 --> 13:05.480]  В общем, здесь все внутри натуральных чисел происходит.
[13:05.480 --> 13:12.480]  То есть функция, например, в алгоритмической может быть не вычислимой, просто и для нее вычислима.
[13:12.480 --> 13:19.480]  Да и любая другая, если беденцарно, то А это область определения.
[13:19.480 --> 13:25.480]  Не, ну то смотря, что вы называете алгоритмической функцией.
[13:25.480 --> 13:32.480]  Ну например, алгоритм по сравнению с два числа, если ее область определения.
[13:33.480 --> 13:38.480]  Не, не, не, сейчас. Значит, здесь все функции нужно определить на конечных словах.
[13:38.480 --> 13:42.480]  Или на натуральных числах.
[13:42.480 --> 13:46.480]  Все, что у действительного аргумента в эту теорию плохо ложится,
[13:46.480 --> 13:50.480]  это ее можно расширить, но мы пока не будем так делать.
[13:50.480 --> 14:00.480]  Ну так выделяем область памяти, и каждый раз, когда старый аргумент что-то напечатал,
[14:00.480 --> 14:08.480]  мы как бы работаем как посредники между старым алгоритмом и итоговым потоком вывода.
[14:08.480 --> 14:13.480]  Значит, если старый алгоритм потока вывода напечатал, то мы это как бы ловим
[14:13.480 --> 14:17.480]  и сравним с тем, что уже было напечатано.
[14:18.480 --> 14:23.480]  Если еще не было, то мы это отправляем в итоговый поток вывода
[14:23.480 --> 14:26.480]  и записываем в список того, что уже напечатано.
[14:26.480 --> 14:30.480]  Если было, то просто игнорируем и считаем дальше.
[14:30.480 --> 14:35.480]  То есть есть как бы отдельный кусок памяти, где запускают старый алгоритм,
[14:35.480 --> 14:38.480]  и отдельный, где мы храним его вывод.
[14:38.480 --> 14:48.480]  Не, ну как, по битву сравниваем.
[14:48.480 --> 14:58.480]  То есть мы в детали не лезем, считаем, что там сравнивать строки вы умеете.
[14:58.480 --> 15:02.480]  Если вдруг надо будет, то даже на машине тюринга можно написать.
[15:02.480 --> 15:08.480]  Такие нескромные детали лезть не будем.
[15:12.480 --> 15:19.480]  В общем, считаем, что все, что вы можете запрограммировать сами, заведомо вычислимо.
[15:19.480 --> 15:25.480]  И то, что это вычислимо в конкретных паделях мы особо смотреть не будем.
[15:26.480 --> 15:28.480]  Так, хорошо.
[15:34.480 --> 15:38.480]  Ну, нулевое первое получилось эквивалентно,
[15:38.480 --> 15:42.480]  потому что из первого нулевой это очевидно, потому что частный случай.
[15:44.480 --> 15:50.480]  Значит, очевидно, частный случай.
[15:50.480 --> 15:56.480]  Если мы можем без повторов напечатать, то значит с повторами тоже можем напечатать.
[15:56.480 --> 16:02.480]  Так, хорошо, теперь давайте из первого второго, ну или из нулевого второго,
[16:02.480 --> 16:10.480]  то есть как вычислять полухарактеристическую функцию.
[16:11.480 --> 16:16.480]  Вот, ну это очень легко на самом деле в эту сторону.
[16:16.480 --> 16:23.480]  Значит, программа, вычисляющая полухарактеристическую функцию.
[16:28.480 --> 16:33.480]  Значит, она имеет вход X, и она умеет запускать перечисления.
[16:34.480 --> 16:38.480]  Да, значит, просто запустили перечисление A.
[16:42.480 --> 16:47.480]  Значит, запустили перечисление A, и ждем появления X.
[16:54.480 --> 16:58.480]  Вот, если появилось, то тогда печатаем единицу.
[16:59.480 --> 17:08.480]  Да, значит, если появилось, то тогда возвращаем единицу.
[17:08.480 --> 17:12.480]  Вот, значит, в программе больше ничего не нужно писать.
[17:12.480 --> 17:16.480]  Да, то есть не нужно писать, если не появилось, то делаем что-нибудь еще.
[17:16.480 --> 17:20.480]  Это и не нужно, это и вообще и ошибка была бы.
[17:20.480 --> 17:23.480]  Потому что мы не знаем, появится ну или нет.
[17:23.480 --> 17:31.480]  Процесс бесконечный, соответственно, в общем случае невозможно определить, что никогда точно не появится.
[17:39.480 --> 17:46.480]  Вот, соответственно, что же получается?
[17:46.480 --> 17:51.480]  Получается, что если на самом деле X есть, то тогда он появится в перечислении.
[17:51.480 --> 17:57.480]  Тогда мы его дождемся, и тогда вот это условие сработает, и мы вернем единицу.
[17:57.480 --> 18:03.480]  Если на самом деле X нет, то это условие никогда не сработает.
[18:08.480 --> 18:14.480]  Да, значит, если на самом деле X нет, то это условие никогда не сработает, и эта машина будет работать бесконечно долго.
[18:14.480 --> 18:24.480]  Вот, значит, нужна оговорка, что если перечисление может закончиться, то есть если будет конечное множество, и оно закончится, и там и саня появилась,
[18:24.480 --> 18:28.480]  то нам все равно нужно искусственно там зациклиться, чтобы работать бесконечно долго.
[18:28.480 --> 18:34.480]  Вот, хорошо, значит, из первого, второе получили.
[18:34.480 --> 18:38.480]  И второе, третье.
[18:39.480 --> 18:43.480]  Значит, ну и второго, третье, это просто очевидно.
[18:43.480 --> 18:53.480]  На самом деле, дело в том, что тому множество а это как раз в области определения полухарактеристической функции х и а с чертой.
[18:53.480 --> 18:59.480]  Потому что как раз на элементах а она равна единице, и поэтому определена.
[18:59.480 --> 19:06.480]  На элементах ни и за она не определена, и значит, они не входят в область определения.
[19:07.480 --> 19:13.480]  Так, значит, дальше давайте из второго в четвертое.
[19:15.480 --> 19:22.480]  Значит, из второго в четвертое удобно делать так.
[19:27.480 --> 19:33.480]  Ну, можно сказать так, что а это область значений вот такой функции.
[19:33.480 --> 19:40.480]  Значит, функция х, умноженная на х и а чертой от х.
[19:42.480 --> 19:46.480]  То есть, мы вместо единицы сам х печатаем.
[19:46.480 --> 19:56.480]  То есть, это будет х, если х лежит ва, и не определено, если х не лежит ва.
[19:56.480 --> 20:10.480]  И как раз, если х и а с чертой вычислимо, то тогда умноженная на х, она тоже вычислимо.
[20:12.480 --> 20:17.480]  Так, теперь пятая.
[20:17.480 --> 20:21.480]  Так, может такое пятая. Пятая это значит без повторов.
[20:21.480 --> 20:27.480]  Так, пятая самая удобная из первого получать.
[20:30.480 --> 20:35.480]  Значит, из первого получаем пятая, но тут нам немножко нужно случаев разбирать.
[20:35.480 --> 20:44.480]  Значит, если множество пустое, то у нас это как отдельный случай рассмотрено.
[20:44.480 --> 20:48.480]  Если а пустое, то тогда подходит.
[20:51.480 --> 21:01.480]  Значит, если а конечная, ну как-то можно, я напишу это как упражнение.
[21:04.480 --> 21:10.480]  Значит, упражнение построить вычисливую функцию, в которой область значений, это данное конечное множество.
[21:11.480 --> 21:13.480]  Ну, там есть много разных способов.
[21:13.480 --> 21:20.480]  Ну, например, можно на входе n, вот как число убрать, остаток по модулю число значений
[21:20.480 --> 21:24.480]  не зависит от остатка выдавать нужное значение.
[21:24.480 --> 21:26.480]  Вот, или еще как-нибудь.
[21:26.480 --> 21:34.480]  Вот, а если обрез конечная, то тогда мы сделаем такую функцию.
[21:34.480 --> 21:42.480]  Значит, f от, дайте я напишу не х, а n, чтобы подчеркнуть, что это число.
[21:42.480 --> 21:53.480]  Значит, f от n это n-ый элемент, n-ый элемент перечисления без повторов.
[22:01.480 --> 22:07.480]  Вот, тогда получается, что это всюду...
[22:08.480 --> 22:14.480]  Кстати, тут даже не обязательно без повторов, можно и с повторами.
[22:14.480 --> 22:17.480]  Значит, можно и с повторами.
[22:17.480 --> 22:21.480]  Так, давайте...
[22:21.480 --> 22:24.480]  Тут можно и с повторами.
[22:24.480 --> 22:30.480]  Можно и с повторами.
[22:30.480 --> 22:38.480]  Ну, в общем-то, так или иначе получается, что если процесс бесконечный, то для любого n, на n-ом шаге что-то будет выведено.
[22:38.480 --> 22:40.480]  Поэтому это будет сюда определено.
[22:40.480 --> 22:47.480]  Ну, а с другой стороны, любое элемента будет в перечислении, поэтому на каком-то шаге будет выведено.
[22:47.480 --> 22:51.480]  Значит, поэтому вот значение точно совпадает с нашим множеством.
[23:00.480 --> 23:05.480]  Так, теперь самое интересное, это шестое.
[23:05.480 --> 23:10.480]  Значит, я одно направление напишу, как из третьего делать шестое.
[23:10.480 --> 23:13.480]  А там из четвертого и пятого примерно аналогично.
[23:13.480 --> 23:19.480]  И потом еще из шестого нулевое, и этим цикл замкнется.
[23:19.480 --> 23:25.480]  Да, значит, например, как из третьего и четвертого.
[23:26.480 --> 23:31.480]  Да, значит, например, как из третьего делать шестое.
[23:38.480 --> 23:43.480]  Ну, смотрите, пусть... Тут мы уже от полухарактеристической функции отходим.
[23:43.480 --> 23:50.480]  Пусть A это область определения f, и f вычислимо.
[23:50.480 --> 23:59.480]  Значит, тогда, значит, можно написать следующее.
[23:59.480 --> 24:05.480]  Значит, B это будет следующее.
[24:05.480 --> 24:13.480]  И это будет следующее. Это будет множество из пар X и K.
[24:13.480 --> 24:24.480]  Значит, такое, что f от X останавливается за не более чем K шагу.
[24:24.480 --> 24:36.480]  Значит, то, что D разрешимо, это формально почти очевидно.
[24:36.480 --> 24:40.480]  В смысле, интуитивно почти очевидно.
[24:40.480 --> 24:46.480]  Формально там чуть попозже поговорим, когда закончим разговор про перечислимость.
[24:46.480 --> 24:49.480]  Значит, интуитивно то нужно сделать.
[24:49.480 --> 24:53.480]  Что нужно сделать? Ну, надо взять ту машину, которая вычисляет f,
[24:53.480 --> 25:00.480]  запустить ее на входе X и как бы симулировать K шагов.
[25:00.480 --> 25:05.480]  Если за эти K шагов она остановилась, то, значит, сказать, что ответ да.
[25:05.480 --> 25:08.480]  Если не остановилась, то ответ нет.
[25:08.480 --> 25:13.480]  Значит, в чем тут основная фишка? В том, что фиксируемо число шагов.
[25:13.480 --> 25:16.480]  Если мы будем спрашивать, остановится ли она вообще,
[25:16.480 --> 25:19.480]  то это будет как раз неразрешимая задача.
[25:19.480 --> 25:23.480]  Это проблема остановки, и про это мы будем скоро говорить.
[25:23.480 --> 25:30.480]  Если мы фиксировали время, то на это фиксированное время можно взять и запустить.
[25:30.480 --> 25:38.480]  Значит, с точки зрения обычного программирования это более-менее очевидно,
[25:38.480 --> 25:42.480]  потому что это как называется программа, которая запускает другие программы?
[25:42.480 --> 25:45.480]  Это компилятор. Компилятор это и делает.
[25:45.480 --> 25:51.480]  Компилятор берет текст программы и берет входной файл,
[25:51.480 --> 25:53.480]  ну и в итоге запускает эту программу на этом файле.
[25:53.480 --> 25:56.480]  Это может быть развито на этапы. Сначала какой-нибудь экзешник сделать,
[25:56.480 --> 25:58.480]  потом экзешник запустить.
[25:58.480 --> 26:01.480]  Но если все это вместе воспринимать как один компилятор,
[26:01.480 --> 26:04.480]  то этот компилятор ровно это и делает.
[26:04.480 --> 26:09.480]  А если еще там ему лимит на время поставить, то он делает ровно то, что здесь написано.
[26:09.480 --> 26:15.480]  То есть запускает программу на данном входе на какое-то число шагов,
[26:15.480 --> 26:17.480]  то есть на какое-то время.
[26:20.480 --> 26:28.480]  Если мы берем тезис Чорча, то тогда можно сказать, что раз мы это умеем делать на компьютере,
[26:28.480 --> 26:32.480]  значит и на машине Тернига тоже умеем.
[26:32.480 --> 26:37.480]  Но, конечно, это не только эстезисы Чорча следует,
[26:37.480 --> 26:40.480]  но и может быть получена как формальная теория,
[26:40.480 --> 26:42.480]  она называется универсальная машина Тюринга.
[26:42.480 --> 26:46.480]  Машина, которая запускает другие машины.
[26:46.480 --> 26:50.480]  Про это мы чуть позже поговорим подробнее.
[26:50.480 --> 26:58.480]  Пока что ограничимся тем, что, во-первых, действительно А это проекция В.
[27:02.480 --> 27:06.480]  Почему? Ну, потому что если f от x определено,
[27:09.480 --> 27:15.480]  то тогда значит за какое-то конкретное число шагов оно вычисляется.
[27:16.480 --> 27:27.480]  Тогда f от x вычисляется за какое-то число шагов, значит за какое-то t шагов.
[27:27.480 --> 27:35.480]  И, соответственно, получается, что пара xt лежит в В.
[27:35.480 --> 27:42.480]  А тут еще нам нужно начать, что если x лежит в А, значит если x лежит в А, то f от x определено,
[27:42.480 --> 27:47.480]  значит он принял какое-то конкретное число шагов, значит пара xt лежит в В,
[27:47.480 --> 27:53.480]  и значит x принадлежит к проекции В.
[27:53.480 --> 28:05.480]  Ну, и наоборот, значит, на самом деле эти стрелки можно в обратном направлении пройти.
[28:05.480 --> 28:11.480]  В обратном направлении тоже все стрелки верны.
[28:11.480 --> 28:21.480]  Ну, если правильно квантеры расставить, то есть если x лежит в проекции, то значит для некоторого t,
[28:21.480 --> 28:29.480]  значит для некоторого t пара xt лежит в В, значит для этого t f от x вычисляется за какое-то
[28:29.480 --> 28:37.480]  не более чем t шагов, ну, значит останавливается, значит f от x определенно, значит x лежит в А.
[28:37.480 --> 28:45.480]  Вот, значит действительно получается, что А проекция В.
[28:45.480 --> 28:55.480]  Так, ну что? Насколько это понятно, какие-нибудь вопросы?
[28:55.480 --> 29:05.480]  Так, ну что? Насколько это понятно, какие-нибудь вопросы?
[29:05.480 --> 29:13.480]  Насколько это понятно, какие-нибудь вопросы?
[29:13.480 --> 29:21.480]  Так, ну что же, остается, чтобы все замкнуть, нужно из шестого куда-нибудь перейти.
[29:21.480 --> 29:25.480]  Ну, можно прямо в нулевой перейти.
[29:25.480 --> 29:33.480]  Что, как перечислять проекцию? Да, значит из четвертого и пятого шестого примерно аналогично.
[29:33.480 --> 29:43.480]  Значит, из четвертого шестого, из пятого шестое, получается аналогично.
[29:43.480 --> 29:52.480]  И остается, чтобы замкнуть весь круг, нужно из шестого перейти в нулевой, например.
[29:52.480 --> 30:03.480]  Значит, как перечислить проекцию? Ну как, помните, как обходить эту самую кетку?
[30:03.480 --> 30:07.480]  Как доказывать, что множество рациональных чисел счетно?
[30:07.480 --> 30:10.480]  Ну, а здесь примерно то же самое.
[30:10.480 --> 30:16.480]  Значит, здесь будет решетка.
[30:16.480 --> 30:22.480]  Значит, соответственно, здесь там х, значит здесь у.
[30:22.480 --> 30:28.480]  Значит, вот есть какая-то решетка.
[30:28.480 --> 30:35.480]  Значит, дальше каким-нибудь способом можно это обходить.
[30:35.480 --> 30:44.480]  Ну, на самом деле, чтобы было попроще программу писать, удобнее обходить вот так вот.
[30:44.480 --> 30:54.480]  Да, значит, вот как бы я вот так вот условно нарисую уголкам.
[30:54.480 --> 30:58.480]  Как бы все затрагиваю все больше и больше углы.
[30:58.480 --> 31:01.480]  То есть, программа получается такая.
[31:01.480 --> 31:07.480]  Значит, пусть.
[31:07.480 --> 31:14.480]  Пусть это разрешимое множество пар.
[31:14.480 --> 31:17.480]  Значит, пар.
[31:17.480 --> 31:25.480]  И, соответственно, программа перечисляющая.
[31:25.480 --> 31:31.480]  Значит, программа перечисляющая проекцию В.
[31:31.480 --> 31:33.480]  Будет вот такая.
[31:33.480 --> 31:37.480]  Значит, это просто цикл по всем к.
[31:37.480 --> 31:49.480]  Для к от нуля до бесконечности.
[31:49.480 --> 31:58.480]  Значит, дальше для х от нуля до к.
[31:58.480 --> 32:00.480]  Ну, три тут ложных цикла получаются.
[32:00.480 --> 32:04.480]  Дальше для у от нуля до к.
[32:04.480 --> 32:08.480]  Значит, если.
[32:08.480 --> 32:16.480]  Значит, если пара х лежит в Б.
[32:16.480 --> 32:18.480]  То.
[32:18.480 --> 32:21.480]  Напечатать.
[32:21.480 --> 32:28.480]  Икс.
[32:28.480 --> 32:31.480]  Вот тут даже не совсем, как я нарисовал.
[32:31.480 --> 32:38.480]  Так что мы как бы каждый раз все старое снова перебираем.
[32:38.480 --> 32:42.480]  Значит, если хотите, можно какую-нибудь другую программу написать более.
[32:42.480 --> 32:47.480]  Которая не бесконечно числа раз одно и то же делает.
[32:47.480 --> 32:49.480]  Все по одному разу.
[32:49.480 --> 32:50.480]  Но тут нам не важно.
[32:50.480 --> 32:58.480]  Мы тут не заботимся ни об эффективности, ни о чем.
[32:58.480 --> 33:00.480]  Вот почему это работает.
[33:00.480 --> 33:07.480]  Ну, смотрите, если у нас х лежит в проекции.
[33:07.480 --> 33:09.480]  Ну, так оно здесь было.
[33:09.480 --> 33:13.480]  Вот.
[33:13.480 --> 33:16.480]  Вот это вот.
[33:16.480 --> 33:18.480]  Давайте я здесь тогда припишу.
[33:18.480 --> 33:19.480]  Вот это вот.
[33:19.480 --> 33:22.480]  Это называется проекция Б.
[33:22.480 --> 33:25.480]  Можно написать, что проекция на первую координату.
[33:25.480 --> 33:36.480]  Но у нас других не бывает.
[33:36.480 --> 33:37.480]  Вот.
[33:37.480 --> 33:40.480]  В общем, смотрите, если х лежит в проекции, то это что значит?
[33:40.480 --> 33:43.480]  Это означает, что для какого-то.
[33:43.480 --> 33:46.480]  Давайте я тут еще отдельно напишу.
[33:46.480 --> 33:52.480]  Значит, если х лежит в проекции Б, то это по предельному означает,
[33:52.480 --> 33:58.480]  что существует у такой, что пара х и у лежит в Б.
[33:58.480 --> 34:02.480]  Значит, тогда на шаге.
[34:02.480 --> 34:11.480]  Значит, на шаге максимум из х и у.
[34:11.480 --> 34:16.480]  Вот эта пара попадет в рассмотрение.
[34:16.480 --> 34:27.480]  Значит, х и у попадет в рассмотрение.
[34:27.480 --> 34:35.480]  Ну и, следовательно, программа напечатает х.
[34:35.480 --> 34:40.480]  То есть х получается попало в выход программы.
[34:40.480 --> 34:43.480]  Ну и, с другой стороны, если х попало в выход программы,
[34:43.480 --> 34:51.480]  то значит, вот это вот условие сработало и означает, что х лежит в проекции.
[34:51.480 --> 35:00.480]  То есть опять же в обратную сторону тоже можно пройти.
[35:00.480 --> 35:01.480]  Вот.
[35:01.480 --> 35:02.480]  Значит, что здесь важно?
[35:02.480 --> 35:07.480]  Важно, что до этого шага с таким номером программа точно дойдет.
[35:07.480 --> 35:10.480]  Потому что если к фиксировано, значит, если к фиксировано,
[35:10.480 --> 35:13.480]  то вот этот вот цикл конечный.
[35:13.480 --> 35:17.480]  То есть у нас, значит, почему нам нужно именно так вот?
[35:17.480 --> 35:21.480]  Ну, потому что если мы, не знаю, будем там по первой вертикали
[35:21.480 --> 35:25.480]  идти вот туда в верхней бесконечности и искать, будет там х или не будет,
[35:25.480 --> 35:29.480]  то если его там нет, то мы на все остальные вертикали потом никогда уже не перейдем.
[35:29.480 --> 35:32.480]  И тогда у нас не получится все написать.
[35:32.480 --> 35:39.480]  Поэтому нужно с одной стороны все больше и больше вертикали захватывать,
[35:39.480 --> 35:45.480]  с другой стороны, на каждой вертикали идти ко все более и более высоким точкам.
[35:45.480 --> 35:50.480]  Ну и, соответственно, в принципе любой порядок обхода тут сработает.
[35:50.480 --> 35:56.480]  Важно, чтобы это была единая последовательность.
[35:56.480 --> 36:02.480]  Вот. Хорошо, значит, вот эти вот, эти шесть свойств,
[36:02.480 --> 36:06.480]  семь свойств получаются равносильно.
[36:08.480 --> 36:12.480]  Ну что, меня просили прерыв сделать, давайте сейчас сделаем на пять минут,
[36:12.480 --> 36:18.480]  а потом будем применять эти свойства для разных утверждений.
[36:19.480 --> 36:29.480]  Так, ну что, давайте я разные свойства подхожу на разных,
[36:29.480 --> 36:32.480]  через разные определения.
[36:32.480 --> 36:40.480]  Ну, например, да, например, утверждение один.
[36:40.480 --> 36:48.480]  Значит, утверждение один, что если A и B перечислимы, то пересечение тоже перечислимо.
[36:50.480 --> 37:02.480]  Если A и B перечислимы, то тогда пересечение будет перечислимо.
[37:03.480 --> 37:11.480]  Ну, например, можно доказывать через, это треть у нас получается,
[37:11.480 --> 37:14.480]  через область определения вычислимой функции.
[37:14.480 --> 37:17.480]  Доказательства.
[37:23.480 --> 37:27.480]  Значит, пусть A это область определения функции F.
[37:28.480 --> 37:36.480]  Ой, так, почему оно?
[37:44.480 --> 37:50.480]  Так, сейчас, я не понимаю, они садятся, не заряжаются?
[37:50.480 --> 37:54.480]  Я еще на другом проблеме. Ладно, сейчас.
[37:57.480 --> 38:06.480]  Так, значит, доказательства такое, что пусть A это область определения F,
[38:06.480 --> 38:11.480]  значит, AB это область определения G.
[38:11.480 --> 38:14.480]  Ну, тогда пересечение,
[38:18.480 --> 38:24.480]  значит, пересечение, это область определения, ну, например, суммы F плюс G.
[38:27.480 --> 38:35.480]  Да, значит, я тут все время буду переходить от понимания базовых объектов
[38:35.480 --> 38:40.480]  как слов из 0 единиц, к пониманию их как чисел и обратно.
[38:40.480 --> 38:45.480]  То есть, если, ну, на самом деле, это совершенно неважно, какая операция будет.
[38:45.480 --> 38:50.480]  Но если я не веду, что это числа, что беру F от N, беру G от N,
[38:50.480 --> 38:52.480]  и просто их складываю как числа.
[38:52.980 --> 38:58.480]  Если будет, например, конкатинация, то это будут строки.
[38:58.480 --> 39:01.480]  Почему это будет? Почему пересечение это область определения?
[39:01.480 --> 39:06.480]  Ну, потому что если хотя бы одно слагаемое не определено,
[39:06.480 --> 39:11.480]  то соответственно и сумма тоже не определена.
[39:11.480 --> 39:15.480]  А если в область слагаемых определена, то сумма определена.
[39:15.480 --> 39:19.480]  Ну вот, поэтому сумма будет определена только если и то, и другое определенно,
[39:19.480 --> 39:38.880]  как раз пересечения. Так, ну ничего, понятно, да. Так, хорошо, значит, утверждение 2, значит,
[39:38.880 --> 39:52.720]  утверждение 2 с объединением, значит, если а и b перечислимое, значит, то тогда
[39:52.720 --> 40:07.520]  объединение перечислимо. Вот, тут вот этот уже не подойдет, да, значит, нужно что-то другое,
[40:07.520 --> 40:16.920]  ну, например, можно через область значений. Да, можно сказать, что пусть, пусть а это область
[40:16.920 --> 40:30.320]  значений f, значит, а b это область значений g. А дальше мы рассмотрим такую функцию, значит,
[40:30.320 --> 40:50.640]  h от n, это будет равняться f от k, если n равняется 2k и g от k, если n равняется 2k плюс 1. Вот,
[40:50.640 --> 40:56.560]  ну тогда, конечно, h будет вычислимо, и область значений h как раз будет объединением a и b.
[40:56.560 --> 41:10.560]  Область значений h это как раз объединяемое. Ну, потому что все, что получается ва, будет значение на
[41:10.560 --> 41:16.880]  каком-то четном числе, все, что значение g будет значение на каком-то нечетном числе,
[41:16.880 --> 41:39.760]  ну и наоборот, да, ничего лишнего тут не появится. Так, так, ну хорошо. Ну, давайте еще, чтобы, чтобы
[41:39.760 --> 41:49.040]  показать. Следующее утверждение не то, чтобы очень интересно само по себе, но оно тоже, оно
[41:49.040 --> 41:58.760]  позволяет на последнее ориентироваться, значит, утверждение 3. Значит, смотрите, если бы это
[41:59.020 --> 42:09.660]  перечислимое множество пар, перечислимое множество пар, то тогда его проекции тоже перечислимо.
[42:09.660 --> 42:21.440]  Значит, проекция b тоже перечислима. Да, то есть, перечислимый это всегда проекции разрешимого,
[42:21.440 --> 42:28.600]  но проекции перечислимого будут все еще перечислимым, а не чем-то большим. Значит,
[42:28.600 --> 42:36.780]  смотрите откуда это берется значит доказательства вот это вот бы я как
[42:36.780 --> 42:49.880]  множество пар будет само проекции множество троек да то есть из свойства 6 мы
[42:49.880 --> 42:57.640]  получаем что бы это множество таких пары с игрек то существует з такое что
[42:57.640 --> 43:10.360]  тройка x, y, z лежит но и цит разрешимое множество вот а я кто такой проекция
[43:10.360 --> 43:21.760]  б, значит да проекция б это множество таких x то так квантор забыл что
[43:21.760 --> 43:33.880]  существует y такое что x, y лежит в b вот а это получается из предыдущих множество
[43:33.880 --> 43:46.720]  таких x то существует y существует z такое что тройка x, y, z лежит в ц но дальше
[43:46.720 --> 43:56.920]  те есть то что вот эти вот два квантора можно как бы склеить да то есть можно
[43:56.920 --> 44:07.560]  дайте я сейчас тут напишу обозначение объясню данной доске значит получается
[44:07.560 --> 44:20.680]  x то значит существует пара да значит что x и дальше левая от пары и правая от
[44:20.680 --> 44:36.080]  пары лежит в ц вот но и дальше надо теперь смотреть как бы множество пар да то есть
[44:36.080 --> 44:45.800]  тут конце нужно писать что это множество x такое что существует п то пара x, p лежит в д и что
[44:45.800 --> 44:52.440]  это за обозначение значит я имею ввиду следующее да все-таки нужно немножко в явном виде поговорить
[44:52.440 --> 45:01.240]  про вычислимое кодирование пар вычислимое кодирование пар
[45:01.240 --> 45:16.840]  что есть какой-то x натуральное число значит y натуральное число и мы из них вычисляем
[45:16.840 --> 45:29.480]  некоторые код пары значит p от x, y тоже натуральное число вот это как бы одна функция значит еще есть
[45:29.480 --> 45:37.280]  наоборот функция левая и правая левая из натуральных натуральные и правая из натуральных натуральных
[45:37.280 --> 45:49.260]  соответственно мы хотим чтобы было следующее чтобы левая и правая пары были согласованы да то
[45:49.260 --> 45:55.740]  То есть мы хотим следующее, чтобы левая от пары x и y
[45:55.740 --> 46:01.500]  равнялась бы x, и правая от пары x и y
[46:01.500 --> 46:05.220]  равнялась бы y. То есть если мы сначала
[46:05.220 --> 46:08.900]  образуем код пары, то он может декодировать, и при декодировании
[46:08.900 --> 46:13.100]  получится ровно то, из чего мы этот код собирали.
[46:13.100 --> 46:20.420]  Вот. Ну и более того, все эти функции должны быть
[46:20.420 --> 46:28.340]  вычислимыми. То есть функция пары, функции
[46:28.340 --> 46:31.140]  проекции левой, функции проекции правой, все они вычислим.
[46:31.140 --> 46:37.740]  Вот. Ну, например, можно вот такую функцию
[46:37.740 --> 46:41.900]  рассмотреть. Это не то, что я рисовал, да, по диагональкам.
[46:42.300 --> 46:46.180]  По диагональкам. Сейчас я попробую наизусть написать.
[46:46.180 --> 46:51.940]  Вроде должно быть следующее. Значит, x плюс y на x плюс y плюс 1
[46:51.940 --> 47:02.220]  пополам и плюс x. Да, это вот треугольное число.
[47:02.220 --> 47:04.860]  Значит, это такая форма. Соответственно тому, что мы по
[47:04.860 --> 47:11.380]  диагонали мы идем, перескакивая сразу там из лево-верхнего угла
[47:11.380 --> 47:14.540]  в правый-нижний, идем по диагонали мы так по все более-более высоким.
[47:14.540 --> 47:18.780]  Значит, если мы просто будем нумеровать подряд, то ровно вот
[47:18.780 --> 47:26.260]  эта формула получится. Значит, это пример. Это пример, когда это еще
[47:26.260 --> 47:31.780]  взаимнооднозначное. Вот. Ну, для l и r будет немножко сложнее
[47:31.780 --> 47:36.580]  формула, но ясно, как это делать. Нужно вот это треугольное число
[47:36.580 --> 47:39.140]  называется. Нужно те максимально треугольное число, которое меньше
[47:39.220 --> 47:44.540]  данного, меньше либо равно. Вот. Соответственно, вычесть его из данного
[47:44.540 --> 47:52.660]  получится x, а то, который здесь будет, ну, номер треугольного числа, из номера
[47:52.660 --> 47:59.860]  треугольного числа вычесть x, получится y. Так. Ну, примерно понятно, да?
[47:59.940 --> 48:09.700]  Это не непонятно. Не, ну, тут, смотрите, тут это, это похожее на, ну, это почти
[48:09.700 --> 48:15.780]  будет корень из удвоенного числа, да. То есть, смотрите, вот у вас есть число n,
[48:16.260 --> 48:20.420]  вам нужно эти целые x и y так, чтобы n равнялась вот этому. Как это, как вы это
[48:20.420 --> 48:26.260]  будете делать? Ну, смотрите, вот то, что здесь до центрального плюса, да, это
[48:26.260 --> 48:31.340]  треугольное число. То есть, 0, 1, 3, 6, 10 и так далее. Это сумма архитектurических
[48:31.340 --> 48:36.020]  прогрессий. Да, и нужно сначала найти наибольшее треугольное число, которое
[48:36.020 --> 48:43.660]  будет не больше данного. Вот. Дальше, номер, номер этого треугольного числа это
[48:43.660 --> 48:49.380]  будет x плюс y. Дальше, как найти x? Ну, нужно само это треугольное число
[48:49.380 --> 48:54.220]  вычесть из нашего, получится x. А если мы знаем и x и x плюс y, то и y мы тоже
[48:54.220 --> 49:03.380]  знаем. Вот это будет вычисление l и r. Вот. Хорошо, соответственно, что вот здесь
[49:03.380 --> 49:08.420]  получилось? Значит, здесь получилось, что вот это вот p, и это прям будет код
[49:08.420 --> 49:16.380]  пары. Код пары вот этой из y и z теперь. Значит, код пары из y и z это p. Но как
[49:16.380 --> 49:21.340]  тогда y и z из него получить? Ну, нужно те вот функции, левую и правую, от него
[49:21.340 --> 49:27.340]  взять, да, значит, и получится y и z. Вот. Ещё остается вопрос, что это за d?
[49:27.340 --> 49:36.100]  Значит, что за d? Ну, нужно, чтобы, то есть, значит, d будет, программа, которая
[49:36.100 --> 49:43.300]  вычисляет, ну, вычисляет d в том смысле, что находит ответ, лежит ли данная пара в d или
[49:43.300 --> 49:49.180]  нет. Значит, программа, разрешающая d, будет делать так. Она получает пару из x
[49:49.180 --> 49:55.660]  и p. p, я понимаю, тоже как пару. Из этой пары выуживает левую и правую, то есть
[49:55.660 --> 50:01.420]  y и z. И потом всю эту тройку подаёт на флот программе, которая решает про c. Лежит
[50:01.420 --> 50:07.100]  тройка в c или нет. Вот. Ну и тогда получается, да, что вот эта пара будет
[50:07.100 --> 50:13.060]  лежать в d, тогда это только тогда, когда тройка лежит в c. Вот. Ну а нижнее
[50:13.060 --> 50:20.180]  получается, просто определение 6 уже для, уже для проекции, да, не для, но чтобы, а для
[50:20.180 --> 50:37.740]  проекции. Вот. Так. Ну ничего, пример понятно? Ну, в общем, тут такая важная идея, что вот
[50:37.900 --> 50:44.300]  два одинаковых квантора можно как бы склеивать. На что существует одно, что существует другое,
[50:44.300 --> 50:58.420]  то же самое, что существует пара. Вот. Их вот так можно кодировать. Так. Ну хорошо, какие-нибудь
[50:58.420 --> 51:15.860]  вопросы. Да, да, да. Вот та форма, это взаимнооднозначное, взаимнооднозначное
[51:15.860 --> 51:20.420]  соответствие между парами, натуральные числа, начиная с нуля, и сами натуральные числа, начиная
[51:20.420 --> 51:36.380]  с нуля. Ну, потому что это вот такая номерация, так давайте это нарисую, то я имел в виду,
[51:36.380 --> 51:43.700]  под диагональками, да, то есть это вот такая вот номерация, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
[51:43.700 --> 51:54.900]  10, 11, 12, 13, 14, 15, да, и так далее. В общем, вот такая номерация пар сдается ровно вот этой формой.
[51:54.900 --> 52:01.740]  Значит, почему? Потому что вот без этой добавки это будут те числа, которые здесь по вертикали
[52:01.740 --> 52:08.060]  стоят, по первой вертикали. А дальше, когда мы идем по диагонали вниз, то у нас х плюс у сохраняется,
[52:08.060 --> 52:13.860]  а х увеличивается на единицу. И тут тоже как раз х плюс у сохраняется, х увеличивается на единицу.
[52:20.900 --> 52:26.860]  Ну, грубо говоря, да, нужно носить какое-нибудь число, не знаю, 156, да, оно лежит где-то вот тут.
[52:26.860 --> 52:33.140]  И мы хотим понять, на какой оно диагонали. Мы ищем наибольшее число, которое не больше
[52:33.140 --> 52:39.420]  данного. Это я что-нибудь не соображу, сколько, да, в общем, от 156 нужно там отойти назад,
[52:39.420 --> 52:46.020]  и сколько-то будет вот здесь. И это будет сумма х плюс у. А дальше все, что осталось, это будет х.
[52:46.020 --> 52:54.580]  Все, что осталось от треугольного числа до нашего, это будет х. А у это то, что сколько осталось от х
[52:54.660 --> 53:16.020]  до х плюс у. И так мы найдем х и у. Вот. Ну, хорошо. Хорошо, начнете, наверное, двигаться дальше.
[53:16.020 --> 53:30.860]  Дальше мы приближаемся к неразрешимым задачам. То есть вот то, что мы хотим
[53:30.860 --> 53:40.660]  доказать, значит, теорема, то существует перечислимое, но неразрешимое множество.
[53:41.140 --> 53:55.780]  Но чтобы хотя бы поставить, чтобы сформулировать множество, которое будет таким, нужно немножко
[53:55.780 --> 54:03.500]  еще поговорить про модель вычислений. А именно есть вот такие два похожих, но немножко разных
[54:03.500 --> 54:19.900]  понятия. Одно понятие – это универсальная машина тьюринга, а другое понятие – это
[54:19.900 --> 54:36.340]  универсальная вычислимая функция. Значит, смотрите, что такое универсальная машина тьюринга?
[54:36.340 --> 54:41.340]  Ну, неформально говоря, универсальная машина тьюринга – это компилятор машины тьюринга,
[54:41.340 --> 54:51.100]  который сам написан на машине тьюринга. Тут можно, давайте я вот тут немножко отвлекусь,
[54:51.100 --> 55:00.540]  здесь я вернусь и напишу определение. Здесь немножко расскажу, есть такие два подхода к
[55:00.540 --> 55:10.220]  архитектуре компьютера. Значит, архитектура компьютера.
[55:10.220 --> 55:32.860]  Значит, есть понятие Гарвардская архитектура, Гарвардская и Принстонская,
[55:32.860 --> 55:54.060]  или Неймановская. Гарвардская архитектура устроена так. Значит, есть вот процессор,
[55:54.060 --> 56:17.020]  значит, есть данные, и процессор как-то работает с данными. Соответственно, вся программа зашита
[56:17.020 --> 56:42.060]  в самом процессоре. Программа здесь. По такой логике могут в настоящее время работать какие-то
[56:42.060 --> 56:49.660]  простые устройства, типа там калькулятор. Если он не в телефоне, а отдельное устройство,
[56:49.660 --> 56:56.860]  калькулятор, то оно работает примерно так. То есть, оно конкретно умеет складывать, умножать,
[56:56.860 --> 57:04.780]  можно даже кинетинусы считать, если инженерный калькулятор. Но там, в общем, данные – это более
[57:04.780 --> 57:11.380]  или менее нажатие на кнопки, ну и какая-то память есть, где хранится. А что именно делается,
[57:11.380 --> 57:20.180]  это полностью его схемой определяется. Бывают какие-нибудь даже более хитрые устройства,
[57:20.180 --> 57:24.540]  которые на этой логике основаны. Может быть, какая-нибудь поточная обработка звука, например.
[57:24.540 --> 57:41.180]  Она может быть электронная, но там конкретная программа на уровне железно зашита. Кстати,
[57:41.180 --> 57:46.300]  бывают оборудования для майнинга криптовалют. Она может быть специально для конкретной
[57:46.300 --> 57:52.340]  криптовалюты, с конкретными функциями специально сделана, и вот эту валюту она майнить умеет,
[57:52.340 --> 58:00.100]  а никакой другой не умеет. А что к принцессу? Принцесская архитектура – это, собственно,
[58:00.100 --> 58:06.060]  то, к чему мы привыкли. Все там компьютеры, смартфоны и даже совсем мелкие устройства могут
[58:06.060 --> 58:29.220]  быть сделаны на универсальных чипах. Соответственно, есть процессор, есть память, и эта память разделена
[58:29.220 --> 58:47.680]  так нечетко. В этой памяти есть программа и есть данные. Соответственно, процессор читает
[58:47.680 --> 58:56.500]  программу и потом на данных эту программу выполняет. Это граница пунктирная. Если нужно
[58:56.500 --> 59:00.460]  больше места для программы, выделим место на диске для программы, и будем оттуда читать
[59:00.460 --> 59:10.420]  программу. Если нужно меньше, то эту программу сотрем и будем использовать для данных. Эта граница
[59:10.420 --> 59:22.660]  как бы смещается. Соответственно, если вот этот процессор в гарвардской архитектуре некоторую
[59:22.660 --> 59:29.860]  конкретную программу исполняет, то для чего его сделали. Майнит криптовалюту, обрабатывает звук,
[59:29.860 --> 59:38.620]  суммирует числа. Могут какие-нибудь простые чипы в какой-нибудь сим-карте или еще в каком-нибудь
[59:38.620 --> 59:45.460]  простом устройстве тоже могут по конкретной программе работать. А вот этот процессор может
[59:45.460 --> 59:56.660]  любую программу прочесть из памяти и на данных ее запустить. Любые смартфоны, смарт-часы, компьютеры,
[59:56.660 --> 01:00:05.540]  ноутбуки, планшеты, они все работают вот так. Есть много всего, операционная система,
[01:00:05.540 --> 01:00:11.700]  разный уровень памяти и так далее, но глобально это все вот так. И программы, и данные в одном и том
[01:00:11.780 --> 01:00:24.740]  же месте находятся, и процессор с ними работает. Обычная машина чуринга, как на семинарах,
[01:00:24.740 --> 01:00:33.340]  здесь уже во всех группах было определение, что там есть нож состояний, нож символов, функции
[01:00:33.340 --> 01:00:40.620]  перехода. Это как раз гарвардская артиктура, что там конкретная программа зашита в функцию
[01:00:40.620 --> 01:00:48.460]  перехода. А универсальная машина чуринга получает как бы программу для другой машины
[01:00:48.460 --> 01:00:57.660]  чуринга тоже из памяти и потом ее применяет. Теперь переходим сюда. Универсальная машина
[01:00:57.660 --> 01:01:07.940]  чуринга это у двумя аргументами м и х. Это соответственно, можно сказать, просто равняется
[01:01:07.940 --> 01:01:30.260]  эматык. Значит, словами получаем так, что машина у получает код машины м и вход х.
[01:01:30.260 --> 01:01:45.300]  Соответственно, запускает эматык, ну и возвращает то, что получилось. Универсальная
[01:01:45.300 --> 01:01:58.020]  машина чуринга, функция, это похожая вещь, но чуть более общая. Я как-то пытался написать,
[01:01:58.020 --> 01:02:11.380]  что это такое каллиграфическое у, а это у прямое. У будет просто от пх, там п была пара, здесь
[01:02:11.380 --> 01:02:31.540]  поэта программа. От px это просто вычислимая функция двух аргументов. Для любой вычислимой
[01:02:31.540 --> 01:02:41.940]  функции одного аргумента, любой вычислимой функции f одного аргумента, существует такое p,
[01:02:41.940 --> 01:02:54.620]  но для любого x, значит, у от px равняется f от x. Значит, универсальная вычислимая функция,
[01:02:54.620 --> 01:03:00.940]  это немножко более общее понятие. Можно сказать, что это универсальный язык программирования.
[01:03:00.940 --> 01:03:09.740]  Можно считать, что p – это текст программы, x – это входные данные программы, а у – это компилятор.
[01:03:09.740 --> 01:03:21.420]  Вот как здесь. Программа p, данные x, они закодированы какой-то парой, поэтому хранятся
[01:03:21.420 --> 01:03:26.900]  в одном и том же месте. А вот этот процессор – это функция у, которая что-то вычисляет.
[01:03:26.900 --> 01:03:39.020]  Ну да, давайте раз уж не так.
[01:03:39.020 --> 01:04:07.620]  В узком смысле универсальный машинный тюринг – это в узком смысле, а в широком смысле универсальный
[01:04:07.620 --> 01:04:11.700]  машинный тюринг – это любая машина двух аргументов, которая вычисляет универсальную
[01:04:11.700 --> 01:04:30.540]  вычислимую функцию. В широком смысле универсальная машина тюринга – это просто машина тюринга,
[01:04:30.540 --> 01:04:45.780]  вычисляющая универсальную вычисляющую универсальную машину тюрингу. Есть такой спорт – это попытаться
[01:04:45.780 --> 01:04:51.860]  построить универсальный машинный тюринг, который будет как можно меньше постояней и символов
[01:04:51.860 --> 01:04:58.820]  алфавита. И там вообще какие-то однозначные числа, типа там четыре состояния, семь символов,
[01:04:58.820 --> 01:05:06.100]  или чуть ли не меньше. Но это будет универсальная вычислимая функция именно в широком смысле,
[01:05:06.100 --> 01:05:21.940]  то есть в узком смысле так и не хватит. Но теорема, которую тюринг доказал – это то,
[01:05:21.940 --> 01:05:33.900]  что универсальная машина тюринга существует. Ну и в принципе это не то, чтобы что-то прям
[01:05:33.900 --> 01:05:39.980]  сложное, но немножко такое мутурное рассуждение. То есть нужно сначала как-то договориться о том,
[01:05:39.980 --> 01:05:49.460]  как мы данные кодируем. В чем тут трудность? Трудность в том, что у модели, у ЕМО и машины
[01:05:49.460 --> 01:05:56.660]  М, может быть сколько угодно символов алфавития и сколько угодно состояний. А у моделирующей
[01:05:56.660 --> 01:06:04.220]  машины У должно быть фиксированное число состояния, фиксированное число символов алфавития. Поэтому
[01:06:04.220 --> 01:06:10.060]  нужно как-то договориться, как мы кодируем произвольное множество через ограниченное число символов.
[01:06:19.460 --> 01:06:28.820]  Сейчас, что еще раз вычислимо? Сейчас, вот здесь П – это просто число.
[01:06:28.820 --> 01:06:43.220]  Сейчас, смотрите, здесь некоторая тонкость. Это мы чуть позже будем обсуждать. Значит,
[01:06:43.220 --> 01:06:50.300]  здесь именно то, что написано, что существует такое П, а откуда его взять – это как бы непонятно.
[01:06:50.300 --> 01:06:55.620]  То есть вполне может быть так, что есть какое-нибудь простое семейство функций,
[01:06:55.620 --> 01:07:07.660]  например, прибавление фиксированного числа. То есть, что f от x – это x плюс константа. И хотелось бы,
[01:07:07.700 --> 01:07:14.380]  чтобы по этой константе было бы легко понять, какое тут П. Но это определение вообще не
[01:07:14.380 --> 01:07:20.620]  гарантирует. То есть, там нужна некоторая настройка, чтобы можно было понять, как именно искать это П.
[01:07:20.620 --> 01:07:29.580]  Значит, здесь только утверждать, что оно существует. Хорошо, в общем, формально я
[01:07:29.580 --> 01:07:38.980]  в тюрем не буду доказывать. Но идея такая, что нужно как-то закодировать. Идея доказательства
[01:07:38.980 --> 01:08:01.780]  значит, что нужно закодировать программу M и конфигурация M.
[01:08:01.780 --> 01:08:13.740]  Значит, так, чтобы вычисление на этой самом машине было бы цепочкой простых строковых
[01:08:13.740 --> 01:08:34.620]  преобразований. Так что, вычисление на M было бы последовательностью простых строковых преобразований.
[01:08:34.620 --> 01:08:50.820]  Ну, типа того, что выделить под строку похожий шаблон, и с этим шаблоном провести, заменить на
[01:08:50.820 --> 01:09:01.420]  другую строку, которая следует из программ машины Turing. Ну и, соответственно, тогда машина U уже
[01:09:01.460 --> 01:09:13.140]  должна выполнять эти преобразования. То есть, вот эта машина U красивая должна выполнять эти
[01:09:13.140 --> 01:09:28.460]  преобразования. Вот так. Ну, значит, детали мы не будем изучать. При необходимости, я думаю,
[01:09:28.460 --> 01:09:39.020]  вы это сможете легко сделать. Но не думаю, что необходимости возникнет. Ну, значит,
[01:09:39.020 --> 01:09:45.860]  собственно, мы почти добрались до неразрешимых задач. Но получается, что начнем с них в следующий
[01:09:45.860 --> 01:09:53.020]  раз. Давайте я их пока сформулирую. Значит, что мы будем изучать в следующий раз? Мы будем изучать
[01:09:53.220 --> 01:10:08.500]  две проблемы. Много разных проблем изучать. Значит, неразрешимые проблемы, вязанные с машинами
[01:10:08.500 --> 01:10:21.780]  Turing. Вязаны с машинами Turing. Так, значит, первое. Первое – это проблема самоприменимости.
[01:10:21.780 --> 01:10:39.540]  Проблема самоприменимости. Значит, это, скажем, S, который есть множество таких машин. Значит,
[01:10:39.540 --> 01:10:54.940]  что универсальная машина на вот таком диагональном входе останавливается. Так,
[01:10:54.940 --> 01:11:05.740]  что-то имеется в виду. Я тут, значит, я немножко смазываю обозначение, потому что такие пуристы
[01:11:05.740 --> 01:11:10.580]  говорят, что вот тут надо писать M, а тут надо писать код M. То есть число,
[01:11:10.580 --> 01:11:17.060]  которое как бы или номер, или наоборот, и там, и там номер. Но вообще, я это буду отождествлять.
[01:11:17.060 --> 01:11:24.380]  То есть мы как-то, мы уже научились пары кодировать в числа. Ну, а машина Turing – это набор
[01:11:24.380 --> 01:11:29.340]  каких-то конечных множеств. Мы их так потихоньку все закодируем в одну большую строку или в число.
[01:11:29.340 --> 01:11:38.100]  Ну и, соответственно, можем машину Turing запустить на своем собственном коде. И дальше
[01:11:38.100 --> 01:11:42.780]  что-то получится. Может, она остановится и что-то скажет. Может, никогда не остановится.
[01:11:42.780 --> 01:11:51.780]  Но есть такой игрушечный пример. Будем смотреть машина Turing на какие-нибудь программы. Программа
[01:11:51.780 --> 01:12:00.740]  должна понять, есть ли в лове на входе символ твердый знак. Значит, как это может делать программа?
[01:12:00.740 --> 01:12:04.780]  Может быть, программа, в которой в том тексте программ будет твердый знак. Значит, именно там
[01:12:04.780 --> 01:12:11.740]  константа символ равен твердому знаку, и мы идем по всем символам, сравним с твердым знаком.
[01:12:11.740 --> 01:12:18.380]  Вот эта программа, где твердый знак есть. А, и мы будем считать, что эта программа, она как бы ищет,
[01:12:18.380 --> 01:12:24.140]  пока не найдет, а если его нет, то она никогда не остановится. Она ходит по циклу и ищет твердый знак.
[01:12:24.140 --> 01:12:29.580]  Если твердого знака нет, она никогда не остановится. Но если ей ее собственный код дать, то она
[01:12:29.580 --> 01:12:35.940]  остановится, потому что там есть твердый знак. А может быть, другая программа, которая будет
[01:12:35.940 --> 01:12:45.580]  описана следующая. Возьмем символ SHA, а потом возьмем следующий символ. И будем этот следующий
[01:12:45.580 --> 01:12:53.820]  символ искать, также по кругу. Тогда понятно, что эта программа делала то же самое. Но в тексте ее твердого знака нет.
[01:12:53.820 --> 01:13:01.660]  Соответственно, получается, что это может быть осмыслено, что может быть
[01:13:01.660 --> 01:13:08.380]  осмыслено программу запускать на самой себе, как в коде. И соответственно, она может остановиться,
[01:13:08.380 --> 01:13:23.100]  может не остановиться, даже если она, вообще говоря, делала то же самое. Второй пример это
[01:13:23.100 --> 01:13:34.780]  проблема остановки. Или иногда говорят, проблема останова. Как бы такой инженерный более термин.
[01:13:34.780 --> 01:13:44.060]  Халтинг проблем. Тут уже просто два дается на вход. Аргументы и машина, и сам аргумент.
[01:13:44.060 --> 01:13:48.900]  Так что просто у от mx останавливается.
[01:13:48.900 --> 01:14:08.260]  Вот так. Ну и давайте еще третий пример. Проблема тотальности заключается в том,
[01:14:08.260 --> 01:14:19.380]  что у нас дана только машина m. А нам нужно понять, верно ли, что для любого x от mx
[01:14:19.380 --> 01:14:30.820]  определена. То есть у от mx остановится. Верно ли, что машина останавливается всегда? Вот так.
[01:14:30.820 --> 01:14:39.300]  Ну в общем, давайте я оставлю спойлеры, что мы изучим в следующий раз. Это получается перечислимо,
[01:14:39.300 --> 01:14:52.580]  но неразрешимо. Это тоже перечислимо, но неразрешимо. А вот это получается не перечислимо,
[01:14:52.580 --> 01:15:07.300]  и дополнение тоже не перечислимо. Вот, соответственно, вот эти вещи мы будем
[01:15:07.300 --> 01:15:11.420]  доказывать в следующий раз. Попутно изучим несколько интересных техник,
[01:15:11.420 --> 01:15:18.420]  ну и может быть еще примеры изучим. Спасибо за внимание.
