[00:00.000 --> 00:13.820]  У нас было понятие элементарной эквивалентности моделей,
[00:13.820 --> 00:18.980]  и это означает, что то, что я называл элементарной
[00:18.980 --> 00:21.180]  теорией моделей, просто совпадает.
[00:21.180 --> 00:24.180]  Я напомню, что это такое.
[00:24.180 --> 00:26.780]  Элементарная теория модели – это те замкнутые формулы,
[00:26.780 --> 00:27.980]  которые в этой модели истины.
[00:27.980 --> 00:28.980]  Множество всех таких формул.
[00:28.980 --> 00:33.800]  И если они совпадают для двух моделей, понятно, что
[00:33.800 --> 00:37.340]  сигнатура тогда должна совпадать, то эти модели
[00:37.340 --> 00:40.220]  называются элементарно эквивалентными.
[00:40.220 --> 00:43.600]  И мы рассматривали модели без функциональных символовых
[00:43.600 --> 00:50.780]  констант, и для них рассмотрели игры Ренфойхта на паре
[00:50.780 --> 00:51.780]  моделей.
[00:51.780 --> 01:02.540]  Я выписывать прям подробности не буду, просто коротко
[01:02.540 --> 01:03.540]  напомню.
[01:03.540 --> 01:04.860]  Игра Ренфойхта устроена так.
[01:04.860 --> 01:07.180]  Есть два игрока – новатор и консерватор.
[01:07.180 --> 01:10.440]  Новатор делает первый ход и объявляет некоторое
[01:10.440 --> 01:13.860]  число k, какое хочет.
[01:13.860 --> 01:21.980]  После этого игра идет ровно к раундов.
[01:21.980 --> 01:24.300]  Игра состоит в том, что на каждом очередном ходе
[01:24.300 --> 01:29.180]  новатор выбирает в одной из моделей элемент, а консерватор
[01:29.180 --> 01:31.500]  должен ответить в другой модели.
[01:31.500 --> 01:34.620]  То есть после каждого раунда у нас добавляется
[01:34.620 --> 01:37.300]  пара элементов, один в первой модели, принадлежит
[01:37.300 --> 01:38.300]  другой в второй.
[01:38.300 --> 01:43.020]  И заканчивается игра тем, что появляется, скажем,
[01:43.020 --> 01:49.620]  после раундов было k, появляются две таких последовательности.
[01:49.620 --> 01:54.260]  Инноватор выиграл, если найдется в сигнатуре предикат,
[01:54.260 --> 01:57.220]  который принимает разные значения на этих наборах.
[01:57.220 --> 01:59.900]  То есть он не обязательно от всех k может зависеть.
[01:59.900 --> 02:04.540]  Например, вы выбирали а1, а5 и а7, и у вас есть торнарный
[02:04.540 --> 02:07.540]  предикат, и он принимает не такое значение, как
[02:07.540 --> 02:12.740]  на наборе b1, b5, b7.
[02:12.740 --> 02:15.220]  То есть мы можем только часть использовать.
[02:15.220 --> 02:20.340]  Мы в прошлый раз немножко пообсуждали эти модели,
[02:20.340 --> 02:22.180]  был в том числе и довольно нетривиальный пример, он
[02:22.180 --> 02:23.780]  нам сегодня еще раз понадобится.
[02:23.780 --> 02:29.860]  И более-менее научились анализировать в конкретных
[02:29.860 --> 02:33.220]  ситуациях, у кого из игроков есть выигрышная стратегия.
[02:33.220 --> 02:37.340]  Это не всегда просто, но зачастую не так уж и сложно.
[02:37.340 --> 02:46.500]  А оказывается, что элементарная эквивалентность модели
[02:46.500 --> 02:57.620]  – это в точности утверждение о том, что… Я даже запишу
[02:57.620 --> 02:59.100]  все-таки немножко сложнее.
[02:59.100 --> 03:03.860]  Если модели элементарно эквивалентны, то есть выигрывающая
[03:03.860 --> 03:11.340]  стратегия в игре на этой паре моделей у новатора,
[03:11.340 --> 03:14.180]  у консерватора, прошу прощения, если не эквивалентная.
[03:14.180 --> 03:29.780]  А если не эквивалентная, то тогда у новатора.
[03:29.780 --> 03:35.180]  Ну полезно, конечно, спросить, наверное.
[03:35.180 --> 03:39.420]  Понятно ли, почему я не захотел записать знак равносильности?
[03:39.420 --> 03:42.460]  Вот чем вот такая пара утверждений отличалась от того, что
[03:42.460 --> 03:45.260]  я хотел написать в начале, что элементарная эквивалентность
[03:45.260 --> 03:47.500]  модели равносильна тому, что существует выигрышная
[03:47.500 --> 03:48.500]  стратегия у консерватора.
[03:48.500 --> 03:58.540]  Да, формально, логически рассуждая, можно сказать
[03:58.540 --> 04:01.500]  а вдруг в игре нет выигрышной стратегии ни у новатора,
[04:01.500 --> 04:02.500]  ни у консерватора.
[04:02.500 --> 04:05.220]  Тогда предыдущая запись была бы неверна.
[04:05.220 --> 04:07.460]  Вот эта запись показывает, что на самом деле это не
[04:07.460 --> 04:11.100]  так, потому что два множества равны или не равны.
[04:11.100 --> 04:13.100]  И соответственно, если они равны, то есть стратегия
[04:13.100 --> 04:16.380]  у консерватора, если не равны, есть стратегия у новатора.
[04:16.380 --> 04:18.220]  Но вообще это очень интересный вопрос.
[04:18.220 --> 04:20.940]  Для любой игры существует выигрышная стратегия,
[04:20.940 --> 04:24.980]  ну вот такого типа, выигрышная стратегия у одного из игроков.
[04:24.980 --> 04:29.340]  Ответ удивительным образом зависит от аксиоматики
[04:29.340 --> 04:30.340]  теории множества.
[04:30.340 --> 04:35.100]  То есть разные математики, которые верят в разные аксиоматики,
[04:35.100 --> 04:37.180]  дадут вам противоположные ответы.
[04:37.180 --> 04:39.780]  Стандартные аксиоматики, которые признают практически
[04:39.780 --> 04:41.980]  все математики, ну вот то, что называется аксиоматика
[04:41.980 --> 04:44.900]  Церумиала Френкеля, я о ней уже говорил, можно доказать
[04:44.900 --> 04:47.820]  существование игр, как говорят, недетерминированных,
[04:47.820 --> 04:49.500]  в которых нет выигрышной стратегии ни одного из
[04:49.500 --> 04:50.500]  игроков.
[04:51.500 --> 04:57.020]  А другие математики говорят, нет, это вы все неправильно
[04:57.020 --> 05:00.460]  делаете, нужно принять из аксиома, что любая игра
[05:00.460 --> 05:02.700]  детерминированная, ну там определенного вида.
[05:02.700 --> 05:08.260]  И тогда получается другая математика, она в чем-то
[05:08.260 --> 05:09.660]  похожа, в чем-то отличается.
[05:09.660 --> 05:14.220]  Но это нас слишком далеко в сторону заведет.
[05:14.220 --> 05:17.100]  Конечно, для игр Renfroycton на самом деле можно доказать
[05:17.100 --> 05:20.500]  существование, поскольку они идут, ну они идут бесконечное
[05:20.500 --> 05:22.980]  количество ходов, ну такое условно бесконечное, то
[05:22.980 --> 05:25.140]  есть первым ходом новатор выбирает какая будет
[05:25.140 --> 05:26.140]  конечная игра.
[05:26.140 --> 05:29.940]  И можно, конечно, доказать существование стратегии
[05:29.940 --> 05:31.900]  у одного из игроков относительно просто.
[05:31.900 --> 05:36.260]  То есть это, я просто на всякий случай обратил ваше
[05:36.260 --> 05:40.020]  внимание, что мы докажем все это вот честно, не используя
[05:40.020 --> 05:42.860]  предположения, что есть у одного из двух игроков.
[05:42.860 --> 05:47.420]  Ну собственно, мы и будем доказывать просто две разные
[05:47.420 --> 05:48.420]  ситуации рассматривать.
[05:48.420 --> 05:52.140]  Как это доказывается?
[05:52.140 --> 06:03.260]  Ну тут нужно, естественно, нам понадобится какой-то
[06:03.260 --> 06:08.380]  анализ формул первого порядка, ну у нас это множество состоит
[06:08.380 --> 06:11.060]  из формул истинных моделях, ясно, что про формулы нужно
[06:11.060 --> 06:12.060]  понимать.
[06:12.060 --> 06:19.220]  Ну я начну с того, что нарисую такую условную картинку
[06:19.220 --> 06:20.220]  формулы.
[06:20.220 --> 06:29.780]  И нас будет сейчас интересовать вот такое разбиение, не такое,
[06:29.780 --> 06:38.140]  как было раньше, а немножко другое, вот тут где-то атомарные,
[06:38.140 --> 06:41.500]  ну а дальше уже термы.
[06:41.500 --> 06:45.780]  Вот нас будет интересовать структура формулы там,
[06:45.780 --> 06:48.580]  где она разделяется булевые связки и кванторы, то есть
[06:48.580 --> 06:51.660]  когда мы идем сверху, у нас может оказаться, что
[06:51.660 --> 06:54.700]  формула, ну в начале идут какие-то булевые связки,
[06:54.700 --> 06:59.260]  а потом уже идут под формулы, которые начинаются с квантора.
[06:59.260 --> 07:01.900]  Вот нас будет интересна эта граница и будет также
[07:01.900 --> 07:04.900]  интересна еще один параметр формулы, который называется
[07:04.900 --> 07:05.900]  кванторная глубина.
[07:05.900 --> 07:25.620]  Максимальное количество кванторов, это по определению,
[07:25.620 --> 07:29.820]  на пути из корня в лист.
[07:29.820 --> 07:35.860]  Ну, определение дается в терминах дерева разбора
[07:35.860 --> 07:37.500]  формулы, так удобнее.
[07:37.500 --> 07:39.820]  Можно дать аксиоматическое определение, но мне кажется
[07:39.820 --> 07:40.820]  так нагляднее.
[07:40.820 --> 07:43.580]  Вот смотрите, мы берем на каждом пути из дерева в
[07:43.580 --> 07:45.740]  лист, может быть, могут встречаться кванторы, могут
[07:45.740 --> 07:48.020]  не встречаться, если встречаются, то их какое-то определенное
[07:48.020 --> 07:49.020]  количество.
[07:49.020 --> 07:51.220]  На одном пути их может быть два, на другом их может
[07:51.220 --> 07:52.220]  быть 22.
[07:52.220 --> 07:55.460]  Вот мы берем максимальное число, это и есть кванторная
[07:55.460 --> 07:56.460]  глубина.
[07:56.460 --> 07:58.540]  То есть если у нас вообще есть ветка, где кванторов
[07:58.540 --> 08:00.500]  очень много, то это дает уже большую кванторную
[08:00.500 --> 08:01.500]  глубину.
[08:01.500 --> 08:04.380]  Чтобы кванторная глубина была не больше, чем h, это
[08:04.380 --> 08:13.340]  значит на любой ветке не больше, чем h кванторов.
[08:13.340 --> 08:18.380]  Ну и теперь мы готовы к тому, чтобы доказывать эту
[08:18.380 --> 08:19.380]  теорему.
[08:19.380 --> 08:23.260]  Но доказывать, вот смотрите, это некоторая общая проблема.
[08:23.260 --> 08:26.260]  Когда мы хотим что-то доказывать о множестве замкнутых формул,
[08:26.260 --> 08:27.260]  это не очень удобно.
[08:27.500 --> 08:29.660]  В логике почти все доказательства происходят по индукции.
[08:29.660 --> 08:32.020]  А какая здесь может быть индукция?
[08:32.020 --> 08:34.700]  Если вы начнете разбирать замкнутую формулу, она
[08:34.700 --> 08:37.300]  под формулы уже будет не замкнутая.
[08:37.300 --> 08:40.020]  Поэтому почти всегда, когда вам нужно что-то доказывать
[08:40.020 --> 08:44.300]  про формулы, даже про замкнутые формулы, нужно вначале переформулировать
[08:44.300 --> 08:48.500]  это утверждение так, чтобы оно работало и для каких-то
[08:48.500 --> 08:49.500]  не замкнутых формул.
[08:49.500 --> 08:52.500]  И вот я сейчас эту основную лему, которую буду доказывать,
[08:52.500 --> 08:53.500]  и сформулирую.
[08:53.500 --> 09:03.500]  Так, давайте, ну я опять зафиксировал пару моделей.
[09:03.500 --> 09:07.740]  Игра рэффуэта на этих моделях.
[09:07.740 --> 09:11.180]  И вот предположим, что у нас есть позиция в этой
[09:11.180 --> 09:12.180]  игре.
[09:12.180 --> 09:14.300]  Ну я ее так обозначу две последовательности через
[09:14.300 --> 09:17.340]  точку с запятой, можно было бы просто две разные последовательности
[09:17.340 --> 09:20.380]  написать, но я хочу подчеркнуть, что позиция это именно пара
[09:20.380 --> 09:21.380]  последовательностей.
[09:21.500 --> 09:25.420]  То есть вот уже сделаны какие-то выборы, вот мы находимся
[09:25.420 --> 09:27.100]  в таком месте.
[09:27.100 --> 09:34.660]  Осталось не больше, чем L раунда.
[09:34.660 --> 09:45.420]  Ну понятно, что в этой позиции опять есть выиграющая стратегия
[09:45.420 --> 09:47.260]  либо у консерватора, либо у новатора.
[09:47.260 --> 09:49.420]  Ну может не быть ни у кого, формально, логически, но
[09:49.460 --> 09:53.340]  сейчас сформулирую об общении теоремы, где будет утверждаться.
[09:53.340 --> 10:04.420]  Значит первое, если существует такая формула, у которой
[10:04.420 --> 10:13.620]  множество параметров x1, xm, такая формула, что она принимает
[10:13.620 --> 10:16.500]  разные значения вот на этих наборах.
[10:16.500 --> 10:26.700]  Это скажем в первой модели, и значение не такое, как
[10:26.700 --> 10:30.140]  у той же самой формулы, формулы у нас в одной сигнатуре,
[10:30.140 --> 10:33.500]  поэтому мы можем применить формулу, вычислить оценку
[10:33.500 --> 10:35.660]  и в одной, и в другой модели, вот она принимает разные
[10:35.660 --> 10:36.660]  значения.
[10:36.700 --> 10:40.620]  При этом что от формулы требуется?
[10:40.620 --> 10:48.460]  Кванторная глубина A не больше, чем L.
[10:48.460 --> 10:53.100]  L это вот количество оставшихся раундов.
[10:53.100 --> 10:56.020]  Предположим, что нашлась формула небольшой кванторной
[10:56.020 --> 11:01.300]  глубины, которая разделяет уже объявленные значения.
[11:01.300 --> 11:09.980]  И тогда выигрывающая стратегия есть у новатора, то есть начиная
[11:09.980 --> 11:11.540]  с этой позиции новатор выиграет.
[11:11.540 --> 11:13.340]  Мы теперь рассматриваем выигрышные стратегии не
[11:13.340 --> 11:17.100]  из начальной позиции, где вообще ничего нет, а вот
[11:17.100 --> 11:19.700]  из позиции в игре, то есть мы уже знаем сколько раундов
[11:19.700 --> 11:22.940]  и какие-то ходы сделаны, они там в виде параметра
[11:22.940 --> 11:23.940]  m ходов сделаны.
[11:23.940 --> 11:41.260]  Ну и второе, если такое нет, то выигрышная стратегия
[11:41.260 --> 11:42.260]  у консерватора.
[11:42.260 --> 11:48.780]  Ну, если посмотреть на теорему, я сейчас теорему
[11:48.780 --> 11:51.180]  сотру, потому что видно, что это частный случай.
[11:51.180 --> 11:53.220]  Какой частный случай?
[11:53.220 --> 11:56.340]  Ну, во-первых, нужно положить m равным нулю, то есть мы
[11:56.340 --> 11:59.060]  находимся в начальной позиции, еще никакие ходы не сделаны.
[11:59.060 --> 12:09.700]  И, соответственно, у нас формула тогда должна быть
[12:09.700 --> 12:12.780]  замкнутой, потому что у нее нет ни одного параметра.
[12:12.780 --> 12:16.540]  Значит, если есть замкнутая формула кванторной глубины
[12:16.540 --> 12:21.220]  не больше, чем число ходов, вот представьте, что модели
[12:21.220 --> 12:24.300]  элементарно не эквивалентны, тогда нашлась формула,
[12:24.300 --> 12:25.300]  которая их разделяет.
[12:25.300 --> 12:29.660]  Ну, но новатор просто объявит в качестве числа раундов
[12:29.660 --> 12:33.820]  кванторную глубину этой формулы и, пользуясь леммой,
[12:33.820 --> 12:34.820]  стратегия из леммы выиграет.
[12:34.820 --> 12:41.980]  А если элементарные теории моделей равны, то какую
[12:41.980 --> 12:45.580]  бы формулу мы не взяли, какую бы кванторную глубину
[12:45.580 --> 12:49.740]  не объявил бы новатор, мы окажемся во второй части
[12:49.740 --> 12:52.700]  леммы, потому что не будет формулы, которая разделяет
[12:52.700 --> 12:59.020]  вот эту начальную позицию в разных моделях.
[12:59.020 --> 13:02.020]  Ну, значит, вот эту теорему я сотру, то есть это явное
[13:02.020 --> 13:03.020]  обобщение.
[13:03.020 --> 13:09.500]  И в сущности, из этой леммы я уже теорему доказал.
[13:09.500 --> 13:14.180]  А теперь надо доказывать лему.
[13:14.180 --> 13:17.820]  Доказательства существенно разные в этих двух сулучаях,
[13:17.820 --> 13:19.620]  но их будем доказывать по отдельности.
[13:19.620 --> 13:24.460]  Ну, давайте начнем.
[13:24.460 --> 13:27.420]  Значит, где у меня новатор выигрывает в первой части?
[13:27.420 --> 13:28.420]  Хорошо.
[13:28.420 --> 13:34.300]  Значит, вот я сейчас первую часть и буду доказывать.
[13:34.300 --> 13:39.860]  Доказательства, конечно, индукция по… Ну, почему-то.
[13:39.860 --> 13:42.100]  Ну, в данном случае удобно по кванторной глубине,
[13:42.100 --> 13:45.100]  то есть по L.
[13:45.100 --> 13:55.100]  База индукции.
[13:55.100 --> 13:57.860]  Давайте посмотрим, что говорит наша лемма, если L равно
[13:57.860 --> 13:58.860]  нулю.
[13:58.860 --> 14:04.060]  Раундов не осталось, мы находимся в какой-то позиции.
[14:04.060 --> 14:06.620]  И что мы знаем?
[14:06.620 --> 14:11.180]  Мы знаем, что должна быть разделяющая формула кванторной
[14:11.180 --> 14:12.180]  глубины ноль.
[14:12.860 --> 14:15.660]  А что такое формула кванторной глубины ноль?
[14:15.660 --> 14:18.980]  Это формула бескванторная.
[14:18.980 --> 14:20.420]  У нее просто ни одного квантора нет.
[14:20.420 --> 14:22.100]  Потому что если появляется квантор, он на какой-то
[14:22.100 --> 14:24.300]  ветке сидит, значит, кванторная глубина уже положительная.
[14:24.300 --> 14:28.740]  Да, и я прошу прощения, я забыл еще сказать важную
[14:28.740 --> 14:37.620]  вещь, но вот я… Сейчас ее дополню.
[14:37.620 --> 14:41.420]  Я на картинке обозначил, но забыл обратить ваше
[14:41.420 --> 14:42.780]  внимание на это.
[14:42.780 --> 14:45.300]  Мы будем рассматривать формулы, в которых ходит только квантор
[14:45.300 --> 14:46.300]  существования.
[14:46.300 --> 14:49.940]  Это не ограничивает общности почему, потому что квантор
[14:49.940 --> 14:52.500]  всеобщенность, вот я написал, равносильность.
[14:52.500 --> 14:57.100]  Формула для любого XA равносильно отрицанию формулы существует
[14:57.100 --> 14:59.660]  X не A.
[14:59.660 --> 15:01.900]  Мы это уже несколько раз использовали, вот сейчас
[15:01.900 --> 15:04.020]  это еще раз используется, если у нас есть формула
[15:04.020 --> 15:07.300]  общего вида, мы сделаем подстановки вот такие.
[15:07.300 --> 15:10.020]  Причем видно, что эта подстановка никак не изменяет кванторную
[15:10.020 --> 15:11.020]  глубину.
[15:11.100 --> 15:13.260]  Как был один квантор, так и остался.
[15:13.260 --> 15:19.700]  Вместо вот такой вот ветки для любого X тут A, мы напишем
[15:19.700 --> 15:23.660]  в начале отрицание, потом квантор существования,
[15:23.660 --> 15:27.580]  потом еще раз отрицание, и потом то же самое A.
[15:27.580 --> 15:32.380]  То есть у нас на этой ветке квантор остался один, поэтому
[15:32.380 --> 15:33.380]  кванторная глубина не изменилась.
[15:33.380 --> 15:37.180]  Это мне сейчас будет существенное, мы только такие формулы
[15:37.180 --> 15:39.340]  рассматриваем, но это не ограничивает общности.
[15:40.180 --> 15:43.940]  Для базы это, впрочем, не нужно, потому что, смотрите,
[15:43.940 --> 15:48.060]  есть бескванторная формула, которая различает наши
[15:48.060 --> 15:49.060]  два набора.
[15:49.060 --> 15:55.460]  Но бескванторная формула, вот предположим, я буду
[15:55.460 --> 15:58.540]  постоянно эту картинку менять, доски у меня мало, предположим,
[15:58.540 --> 16:01.140]  вот здесь стоят атомарные формулы.
[16:01.140 --> 16:08.540]  А заметьте, что у нас термы очень простые, только переменные.
[16:08.580 --> 16:11.500]  Потому что нет функциональных символов и константов.
[16:11.500 --> 16:16.380]  Значит, тут стоят атомарные формулы, а вся наша формула
[16:16.380 --> 16:19.700]  является булевой комбинацией этих атомарных, то есть какая-то
[16:19.700 --> 16:22.100]  булева функция от значения атомарных форм.
[16:22.100 --> 16:26.500]  И вот мы находимся в первой части леммы, то есть мы знаем,
[16:26.500 --> 16:30.260]  что в двух моделях у нас нашлась атомарная форма,
[16:30.260 --> 16:34.220]  нашлась какая-то бескванторная формула, которая дает разные
[16:34.220 --> 16:37.900]  значения на наборе a i t в одной модели, на наборе
[16:37.900 --> 16:39.060]  b i t и в другой модели.
[16:39.060 --> 16:42.940]  Но значение этой формулы это в любом случае булева
[16:42.940 --> 16:46.540]  функции, одна и та же булева функция от значения атомарных
[16:46.540 --> 16:47.540]  форм.
[16:47.540 --> 16:51.100]  Но раз значения функции отличаются, то и аргументы
[16:51.100 --> 16:54.060]  должны отличаться, то есть хотя бы одна из этих атомарных
[16:54.060 --> 16:57.380]  формул тоже должна принимать разные значения в этих двух
[16:57.380 --> 16:58.380]  моделях.
[16:58.380 --> 17:02.820]  Ну а что такое атомарная формула, как я уже говорил,
[17:02.820 --> 17:06.860]  это обязательно будет вот что-то просто переменное,
[17:06.860 --> 17:09.740]  подставленное в какой-то предикат из сигнатуры.
[17:09.740 --> 17:13.180]  И это как раз и есть условия выигрыша в игре Renfog.
[17:13.180 --> 17:20.420]  Мы нашли набор, нашли такой элементарный предикат,
[17:20.420 --> 17:22.980]  который различает наш набор, то есть подставив соответственное
[17:22.980 --> 17:25.500]  значение из a i t и b i t, мы получаем разные значения
[17:25.500 --> 17:26.500]  предиката.
[17:27.220 --> 17:34.900]  То есть база получается вот так вот буквально применением
[17:34.900 --> 17:38.380]  всего этого рассуждения.
[17:38.380 --> 17:39.380]  Шаг индукции.
[17:39.380 --> 17:40.740]  Шагом индукции посложнее.
[17:40.740 --> 17:50.220]  Значит мы считаем, что для кванторной глубины меньше
[17:50.220 --> 17:53.700]  либо равняется 1, l или минус 1, верно.
[17:54.180 --> 17:57.020]  И теперь рассматриваем формулу кванторной глубины l.
[17:57.020 --> 18:00.740]  Я опять использую эту картинку.
[18:00.740 --> 18:03.420]  Смотрите, что я делаю.
[18:03.420 --> 18:07.220]  Я беру формулу, дохожу до первых кванторов существования.
[18:07.220 --> 18:09.980]  Они у меня обязательно кванторы существования, я так рисовал
[18:09.980 --> 18:12.180]  с самого начала, но не говорил.
[18:12.180 --> 18:15.380]  А дальше стоят, под кванторами существования стоят какие-то
[18:15.380 --> 18:16.380]  формулы.
[18:16.380 --> 18:23.020]  И кванторная глубина этих формул, вот если здесь
[18:23.060 --> 18:27.580]  кванторная глубина не больше чем l, то здесь она не больше
[18:27.580 --> 18:30.540]  чем l минус 1, потому что у нас вот квантор есть.
[18:30.540 --> 18:34.820]  То есть мы двигаясь по веткам, доходим до ближайшего квантора.
[18:34.820 --> 18:37.700]  И под этим квантором, поскольку максимальная глубина не
[18:37.700 --> 18:41.740]  больше чем l, под этим квантором уже может быть не больше
[18:41.740 --> 18:42.980]  чем l минус 1 квантор.
[18:42.980 --> 18:43.980]  1 квантор уже появился.
[18:43.980 --> 18:52.380]  Ну теперь смотрите, я допустим обозначу как-то эти формулы
[18:52.380 --> 18:59.820]  фи 1, фи там не знаю, r, вся наша формула это какая-то
[18:59.820 --> 19:08.020]  булева функция от значений вот этих вот подформул.
[19:08.020 --> 19:11.740]  Рассуждение то же самое, раз у нас, мы сейчас первую
[19:11.740 --> 19:20.580]  часть лям мы доказываем, раз у нас формула различает,
[19:20.580 --> 19:24.260]  то должна одна из вот этих вот формул, которые начинаются
[19:24.260 --> 19:27.340]  с квантора существования тоже различать.
[19:27.340 --> 19:32.900]  Потому что смотрите, раз значение a не равно в двух
[19:32.900 --> 19:39.180]  моделях, то тогда и значение какого-то, какой-то вот этой
[19:39.180 --> 19:40.940]  формулы тоже должно быть не равно.
[19:40.940 --> 19:47.260]  Ну такое простое наблюдение, что если значения функции
[19:47.260 --> 19:49.380]  различаются, то аргумент хотя бы один тоже должен
[19:49.380 --> 19:51.780]  различаться, это свойство функции.
[19:51.780 --> 19:57.540]  Отлично, давайте теперь возьмем вот эту вот формулу
[19:57.540 --> 20:04.580]  фиитую, она имеет вид, существует x, ну там какой-то x, давайте
[20:04.580 --> 20:11.020]  я ему прям цинично придам имя x, m плюс 1, я напомню,
[20:11.020 --> 20:12.020]  у меня уже m выбрано.
[20:12.020 --> 20:17.500]  Ну это связанная переменная, вы знаете, что можно менять
[20:17.500 --> 20:22.180]  как угодно связанные переменные, ну вот я заменил на x, m плюс
[20:22.180 --> 20:23.180]  1.
[20:23.180 --> 20:27.660]  И здесь стоит какая-то формула, в ней могут быть параметры,
[20:27.660 --> 20:32.140]  которые были раньше, и вот может быть вот дополнительный
[20:32.140 --> 20:34.620]  еще вот этот параметр, который связан квантором, больше
[20:34.620 --> 20:39.260]  ничего быть не может, потому что у формулы фиитая вот
[20:39.260 --> 20:43.020]  это вот параметры, значит максимум может добавиться
[20:43.020 --> 20:45.220]  под квантором, под одним квантором, может добавиться
[20:45.220 --> 20:47.980]  еще один параметр, но вот по переменной этого квантора.
[20:47.980 --> 20:52.180]  Давайте я прям эту формулу тоже аитой назову, чтобы
[20:52.180 --> 20:56.300]  подчеркнуть ее связь с фиитой, то есть вот где-то вот здесь
[20:56.300 --> 21:02.100]  у нас есть такая формула, которая различает.
[21:02.100 --> 21:08.300]  Ну что значит, что она различает, давайте для определенности
[21:08.300 --> 21:16.100]  считать, что фиитая в модели 1 истинна, а фиитая в модели
[21:16.100 --> 21:17.100]  2 ложна.
[21:17.100 --> 21:19.620]  Ну понятно, что я не ограничу общность, и всегда модели
[21:19.620 --> 21:23.140]  можно переставить, если будет наоборот, ну просто я перенумирую
[21:23.140 --> 21:24.140]  модели.
[21:24.140 --> 21:27.620]  И это означает, смотрите, что если я подставлю вот
[21:27.620 --> 21:36.460]  сюда параметры a1, am, ну чтобы оценивать формулу, я должен
[21:36.460 --> 21:37.940]  придать значение параметрам.
[21:37.940 --> 21:41.460]  Я придал значение a1, am, и у меня осталась вот эта
[21:41.460 --> 21:42.460]  связанная переменная.
[21:42.460 --> 21:48.820]  Но раз фиитая истина, то найдется такое ам+, что
[21:48.820 --> 21:58.820]  аит, вот набора уже из m+, 1 тоже истинна, но это просто
[21:58.820 --> 22:01.700]  определение оценки квантора существования, когда он
[22:01.700 --> 22:04.900]  истинный, когда при каком-то значении переменной, на
[22:04.980 --> 22:08.340]  вешается квантор, формула под квантором истинна.
[22:08.340 --> 22:10.260]  Значит вот такое обязательно найдется.
[22:10.260 --> 22:17.900]  Вот в эту ам+, 1 новатор и будет делать ход, он выберет
[22:17.900 --> 22:20.940]  на следующем ходу m+, 1.
[22:20.940 --> 22:22.980]  А что делать консерватору?
[22:22.980 --> 22:27.580]  А консерватору тоже нужно выбрать какое-то bm+, 1.
[22:28.140 --> 22:39.780]  Но если вы посмотрите, у нас вот эта вот формула,
[22:39.780 --> 22:43.340]  поскольку фиитая во второй модели ложна, эта формула
[22:43.340 --> 22:44.340]  ложна.
[22:44.340 --> 22:47.220]  Значит какое бы значение не выбрал консерватор,
[22:47.220 --> 22:49.700]  когда формула с квантором существования ложна, когда
[22:49.700 --> 22:53.180]  при подстановке любого значения вместо xm+, 1 вы получаете
[22:53.180 --> 22:54.180]  ложь.
[22:54.180 --> 23:08.620]  Значит какой бы не выбрал ход консерватор, у вас вот
[23:08.620 --> 23:11.740]  эта вот формула, у которой уже кванторная глубина,
[23:11.740 --> 23:15.300]  я напомню, на единичку меньше.
[23:15.300 --> 23:17.260]  Принимает другое значение, то есть мы оказываемся
[23:17.260 --> 23:20.860]  в условиях леммы опять-таки, количество раундов на единицу
[23:20.860 --> 23:24.100]  уменьшилось и у нас есть индуктивное предположение,
[23:24.100 --> 23:26.380]  что лемма верна для такого количества раундов.
[23:26.380 --> 23:28.660]  Ну значит, после того, как новатор сделал такой
[23:28.660 --> 23:31.220]  ход, как бы консерватор не ответил, в получившуюся
[23:31.220 --> 23:33.820]  позицию у новатора есть выигрышная стратегия.
[23:33.820 --> 23:36.820]  То есть в сущности мы предъявили выигрышную стратегию для
[23:36.820 --> 23:37.820]  новатора.
[23:37.820 --> 23:47.220]  Нужно искать такую формулу с квантором, всю нашу формулу
[23:47.220 --> 23:50.020]  нужно вот так проанализировать, найти вот эти самые верхние
[23:50.020 --> 23:55.580]  кванторы, и потом с каждой из этих формул понять, какая
[23:55.580 --> 23:57.740]  различает модель, какая это должна различать.
[23:57.740 --> 24:06.500]  Хорошо, это мы разобрались с пунктом 1, то есть теперь
[24:06.500 --> 24:08.980]  уже лемма доказана в случае пункта 1.
[24:08.980 --> 24:16.780]  В случае пункта 2 все немножко сложнее, я, наверное, уже
[24:16.780 --> 24:18.060]  эту картинку сотру.
[24:18.060 --> 24:22.460]  Ну, про кванторную глубину я в случае чего повторю,
[24:22.460 --> 24:26.060]  просто мне тут нужна будет не картинка, для начала
[24:26.060 --> 24:27.980]  во-первых, нужно будет некоторое вспомогательное
[24:27.980 --> 24:28.980]  утверждение.
[24:28.980 --> 24:31.020]  Значит, смотрите, теперь мы хотим доказывать вторую
[24:31.020 --> 24:32.020]  часть леммы.
[24:32.020 --> 24:37.700]  Я прям так вот сотру, пока тут я все стирать не буду,
[24:37.700 --> 24:39.780]  потому что индукция все равно будет по Эль.
[24:39.780 --> 24:43.140]  Вот это я сотру, потому что это не понадобится.
[24:43.140 --> 24:45.420]  Но мне понадобится еще одна вспомогательная лемма.
[24:45.420 --> 24:59.620]  И здесь вот как раз очень существенно, что у нас нет
[24:59.620 --> 25:03.780]  функциональных символов и константов.
[25:03.780 --> 25:17.860]  Лемма такая, для любых h и m существует лишь конечное
[25:17.860 --> 25:30.780]  множество попарно неравносильных форм.
[25:30.780 --> 25:50.700]  С параметрами, ну, я прям напишу явно, мы будем выбирать
[25:50.700 --> 25:54.220]  параметры из множества x1, xm, то есть из такого множества
[25:54.220 --> 26:01.500]  переменных и кванторной глубины, ну, пусть будет
[26:01.500 --> 26:04.220]  меньше, чем h, на самом деле можно и h, понятно, это ничего
[26:04.220 --> 26:05.220]  не меняет.
[26:05.220 --> 26:07.260]  То есть, что утверждается, если я задал количество
[26:07.260 --> 26:11.860]  параметров формуле и задал ее кванторную глубину,
[26:11.860 --> 26:14.100]  то у меня есть лишь конечное количество вариантов
[26:14.100 --> 26:16.220]  выписать разные формулы.
[26:16.220 --> 26:22.380]  То есть, вообще формул бесконечно много, даже бескванторных.
[26:23.360 --> 26:29.220]  Но, оказывается, что они, если в сигнатуре нет функциональных
[26:29.220 --> 26:32.240]  символов и константов, они, в общем-то в основном,
[26:32.240 --> 26:33.780]  все эквивалентны друг к другу.
[26:33.780 --> 26:35.760]  То есть, если мы зададимся кванторной глубиной, понятно,
[26:35.760 --> 26:37.260]  что если кванторная глубина растет, мы можем получать
[26:37.260 --> 26:42.280]  попарно не эквивалентные формулы в любом количестве,
[26:42.280 --> 26:44.220]  ну, вот если, ну, в том числе и бесконечное количество.
[26:44.220 --> 26:47.900]  Ну, вот если у нас нет функциональных символов
[26:47.900 --> 26:51.680]  и константов в сигнатуре, то при заданных вот этих
[26:51.680 --> 26:58.520]  у нас всего конечное множество классов эквивалентности относительно равносильности. То есть варианты
[26:58.520 --> 27:05.040]  высказать какое-то логическое условие у нас конечное количество, если мы ограничены в количестве
[27:05.040 --> 27:15.320]  параметров и в кванторной глубине. Вот здесь нужно обратить внимание, тут есть некоторая тонкость,
[27:15.320 --> 27:20.720]  что если бы я не зафиксировал множество параметров, то меня бы могли тут же уличить. Ну как же,
[27:20.720 --> 27:25.720]  мне бы сказали, давайте просто менять имя параметра. Скажем, параметр вообще всего один. Ну вот он,
[27:25.720 --> 27:29.680]  подставим одну переменную в качестве параметра, другую переменную в качестве параметра. У нас
[27:29.680 --> 27:35.120]  эти формулы будут не эквивалентные, их бесконечно много. Вот именно для этого я имена переменных
[27:35.120 --> 27:40.320]  жестко прибил. То есть я хочу, чтобы мои формулы использовали вполне определенные имена для
[27:40.320 --> 27:52.280]  параметра. И тогда, оказывается, конечность. Ну доказательства тоже индукции. Опять-таки по
[27:52.280 --> 28:16.520]  кванторной глубине, которая у меня сейчас аж обозначена. Ну база. Бескванторная формула от
[28:16.520 --> 28:45.960]  параметров x1, xm. Для любой модели, конечно, я еще забыл сказать. И равносильность в модели.
[28:45.960 --> 28:55.720]  Я прошу прощения. Значит, в этой лемме, конечно, мы должны прибить модель, потому что если мы
[28:55.720 --> 29:00.400]  начнем менять модели, у нас тоже может возникнуть бесконечно много разных вариантов. Возьмите
[29:00.400 --> 29:07.240]  просто атомарную формулу, ее же можно интерпретировать невероятным количеством способов. Нет, модель
[29:07.240 --> 29:13.240]  прибита. То есть вот конкретные модели, у нас есть только конечное число способов что-то сказать,
[29:13.240 --> 29:19.560]  если зафиксированы параметры и кванторная глубина. Ну и в случае базы понятно почему. Опять-таки мы
[29:19.560 --> 29:27.120]  уже это использовали. Бескванторная формула это формула, куда вместо переменных подставлены
[29:27.120 --> 29:36.120]  атомарные формулы. Сколько есть атомарных формул? Их конечное количество, потому что список
[29:36.120 --> 29:47.320]  параметров у нас зафиксирован. Сигнатура у нас тоже зафиксирована, она конечная. И это существенно,
[29:47.320 --> 29:52.520]  я даже не помню, говорил я или нет, что критерий с помощью Игоря Рэнфоэта он только для конечной
[29:52.520 --> 30:01.920]  сигнатуры работает. По-моему в прошлый раз говорил, сейчас проверю дома по конспекту, но это конечно
[30:01.920 --> 30:12.080]  важно. Это если что надо поправить. Значит у нас есть n большое атомарных формул. То есть мы берем
[30:12.080 --> 30:19.160]  какой-то предикат и какие-то подставляем в него параметры в количестве равномарности предиката,
[30:19.160 --> 30:24.160]  но вот наборов таких параметров конечное число. Потому что вы должны выбирать, у вас есть m
[30:24.160 --> 30:29.600]  параметров, вот вы должны подставить на k мест, но сколько это? Сколько функций из m элементов
[30:29.600 --> 30:36.640]  множества в k элементах, то есть k в степени m. Ну и еще есть выбор предиката, но это какое-то
[30:36.640 --> 30:44.360]  конечное количество n. А дальше, когда вы уже знаете значение вот этих предикатов,
[30:44.360 --> 30:49.720]  бескванторная формула просто вычисляет какую-то булевую функцию, но булевых функций от n
[30:49.720 --> 30:59.640]  большой переменных. Их конечное количество. Их 2 в степени 2 в степени n. Ну это вы, наверное,
[30:59.640 --> 31:05.240]  считали в прошлом году. В общем, несложно посчитать. У вас есть 2 в степени n наборов. Каждый набор
[31:05.240 --> 31:11.880]  может иметь значение 0 или 1, но значит всего их 2 в степени 2 в степени n. Ну значит неравносильных
[31:11.880 --> 31:17.560]  бескванторных формул их не больше, чем булевых функций. Потому что если они совпадают, как булевые
[31:17.560 --> 31:23.600]  функции, вы подставили одни и те же атомарные формулы, то у вас, конечно, получится равносильные
[31:23.600 --> 31:34.280]  формулы. Я теперь атомарные формулы рассматриваю как такие имена переменных, и вот от них у меня
[31:34.280 --> 31:39.400]  будет вот столько булевых функций. Если две бескванторные формулы задают одну и ту же
[31:39.400 --> 31:43.600]  булевую функцию, они просто равносильны в этой модели. Потому что подставляются одни и те же
[31:43.680 --> 31:59.800]  значения всегда. Хорошо, значит теперь мне нужна еще доска. Вот это я пока здесь проведу вот так,
[31:59.800 --> 32:17.400]  вот это сейчас пока доказательство еще леммы идет. Шах, значит лемма, ну как-нибудь давайте
[32:17.400 --> 32:22.600]  я и два, что ли, номер дам, а то у меня две леммы уже появились. Лемма два, шах индукции.
[32:22.600 --> 32:38.960]  Значит уже доказано там для h меньше l, и вот теперь мы рассматриваем формулы уже кванторной
[32:38.960 --> 32:45.720]  глубины l. Да, и заметьте, что мое доказательство, оно индукция по h одновременно для всех
[32:45.720 --> 32:52.320]  возможных значений числа параметров. Шах индукции будет устроен так же. Я предполагаю,
[32:52.320 --> 33:00.200]  что для всех формул кванторной глубины меньше h, для любого m есть только конечное количество
[33:00.200 --> 33:08.160]  попарно неравносильных формул с параметрами x1, xm и кванторной глубины h. Мне это сейчас будет
[33:08.160 --> 33:12.400]  важно, потому что в рассуждении я буду, чтобы доказывать для m переходить к m плюс 1 с меньшим
[33:12.400 --> 33:22.160]  числом параметров. Ну, рано я стер, конечно. Опять я нарисую схематический вид формулы,
[33:22.160 --> 33:29.960]  дерево разбора формулы. Опять мне нужна вот эта граница, где появляются кванторы, опять это
[33:29.960 --> 33:38.200]  только кванторы существования. Теперь у меня эта формула имеет кванторную глубину l. Ну не это,
[33:38.200 --> 33:46.160]  а эти. Их, в принципе, много. Ну, смотрите, что мы знаем. Вот под каждым квантором существования
[33:46.160 --> 34:00.360]  стоит какая-то формула кванторной глубины меньше l. И таких формул, да, здесь мы можем написать
[34:00.360 --> 34:15.000]  качестве параметра как раз xm плюс 1. Их конечное количество. Но тогда и вот таких вот формул
[34:15.000 --> 34:23.200]  неравносильных конечное количество. То есть, смотрите, я беру формулу кванторной глубины
[34:23.200 --> 34:39.360]  строго меньше l, подставляю в нее m плюс 1 параметр. Ну, уже формула, которая под квантором. И таких
[34:39.360 --> 34:44.520]  формул мы знаем, что неравносильных конечное количество. Ну, а когда я навешиваю квантор,
[34:44.520 --> 34:50.040]  понятно, что если я навешиваю квантор на две равносильные формулы по одной и той же переменной,
[34:50.040 --> 34:56.440]  то я получу равносильные формулы. Ну, когда я вычисляю, существует xa и существует xb,
[34:56.440 --> 35:01.360]  если a и b в модели равносильные, то и формулы с навешенным квантором тоже будут равносильные.
[35:01.360 --> 35:09.080]  Значит, вот таких вот формул тоже конечное количество. Но, заметьте, их количество уже
[35:09.080 --> 35:14.440]  совпадает с количеством формул, которые мы оцениваем, меньшей кванторной глубины,
[35:14.440 --> 35:19.720]  но с большим количеством параметров. Поэтому мне важно проводить доказательства сразу для
[35:19.720 --> 35:24.760]  всех значений m, потому что на шаге индукции мне для доказательства с m параметрами нужно
[35:24.760 --> 35:30.600]  предположение индукции с m плюс одним параметром. Отсюда получается рекуррента, я ее не выписываю,
[35:30.600 --> 35:36.320]  потому что она абсолютно нечеловеческая, но вы видите, вот здесь нужно написать что-то там типа
[35:36.320 --> 35:46.200]  k в степени m, вот такое число. А дальше еще вот это все будет итерироваться, то есть это какие-то
[35:46.200 --> 35:50.640]  безумные башни степеней двойки, поэтому я предпочитаю просто говорить конечное количество,
[35:50.640 --> 35:58.080]  не улыбляясь в детали сколько их. Хотя из этого доказательства рекуррента получается. Ну и дальше
[35:58.080 --> 36:03.280]  я повторяю то же самое рассуждение. Раз таких формул конечное количество, наша формула это
[36:03.280 --> 36:09.120]  булева функция от значений этих формул, булевых функций от этого конечного количества тоже конечное
[36:09.120 --> 36:16.040]  количество. Ну правда вот так великовато, значит если нужно взять два в степени, два в степени это
[36:16.040 --> 36:22.720]  конечное количество. Ну что поделать, ну много их будет, ну конечно. И после этого точно так же,
[36:22.720 --> 36:29.720]  как в базе, просто аргументировать, что если две булевые функции совпали, ну и все, они совпали.
[36:29.720 --> 36:37.760]  То есть мы фактически берем вот эту вот булевую часть нашей формулы, подставляем всеми возможными
[36:37.760 --> 36:43.480]  способами. Формулы кванторной глубины меньше l с m плюс одним параметром, навешивая на них
[36:43.480 --> 36:49.320]  квантор существования. Получаем такое большое количество переменных, от них какие-то булевые
[36:49.320 --> 36:56.560]  функции. Вот неравносильные модели формулы будут отвечать разным булевым функциям, поэтому их
[36:56.560 --> 37:04.760]  будет конечное количество. Вот такая вот лемма. Да и похоже до перерыва я уже не успею доказать
[37:04.760 --> 37:10.800]  ну свою основную лему. Давайте я тогда, поскольку это такое длинное было отступление, давайте перед
[37:10.800 --> 37:18.240]  перерывом просто зафиксирую, где мы находились. Вот это мы доказали. Теперь мы доказываем второй
[37:18.240 --> 37:26.200]  шаг. Значит у нас ситуация такая, чтобы после перерыва уже перейти к доказательству. У нас
[37:26.200 --> 37:34.560]  есть две модели, есть наборы длины m из одной и с другой модели, и мы знаем, что никакая формула
[37:34.560 --> 37:42.840]  кванторной глубины меньше либо равняется l не различает эти наборы. Нам нужно доказать,
[37:42.840 --> 37:54.880]  что есть стратегия у консерватора в игре Айренфойта, где играются l-раундов. Ну давайте сейчас уже
[37:54.880 --> 38:00.920]  лучше сделать перерыв, может быть начнем чуть раньше, после перерыва, потому что смысла
[38:00.920 --> 38:12.480]  даваться в подробности, рассуждения сейчас нет. Доказательства опять индукции по кванторной
[38:12.480 --> 38:19.560]  глубине второй части леммы, и база в данном случае совсем простая. Смотрите, что при l равном нулю
[38:19.560 --> 38:27.320]  утверждается наша лемма, что все бескванторные формулы не различают эти два набора. Ходов уже
[38:27.320 --> 38:36.000]  нет, у нас есть наборы а1, ам и б1, бм, и все бескванторные формулы их не различают. Но то,
[38:36.000 --> 38:43.880]  что мы используем в критерии для игры Айренфойта, это тоже бескванторная формула, ну какая-то,
[38:43.880 --> 38:51.480]  потому что формула, предикатный символ из сигнатуры, дальше какие-то переменные, это тоже
[38:51.560 --> 39:08.280]  бескванторная формула, значит они не различают тоже. Вот и вся база. Тут проще, чем в первом случае.
[39:08.280 --> 39:23.640]  А вот шах индукции, пожалуй, посложнее. Вот мы сейчас хотим для какой-то кванторной глубины
[39:23.640 --> 39:32.640]  не больше, чем l доказывать. У нас уже сделано m ходов, осталось сделать l ходов, и вот формулами
[39:32.640 --> 39:43.120]  кванторной глубины не выше l, мы не можем различить эти два набора параметров. Как тут поступить? Нам
[39:43.120 --> 39:56.760]  нужно придумать, да, сразу можно зафиксировать, что новатор пошел в какой-то вот элемент, скажем,
[39:56.760 --> 40:00.520]  первой модели. Вот тут как раз меня сейчас спросили, я еще раз по этому всем повторю.
[40:00.520 --> 40:05.640]  Правила игре info это такие, что новатор на своем ходе может выбирать из какой модели он берет
[40:05.640 --> 40:11.440]  следующий элемент. Это консерватор обязан ответить в противоположной модели, а новатор имеет возможность
[40:11.440 --> 40:18.880]  выбрать. Я говорю, что он выбрал в первой модели, но просто все рассуждения можно повторить, если он
[40:18.880 --> 40:27.840]  выбрал второй модели с заменами буквы a и b. Что делает консерватор? Ему нужно придумать ход.
[40:27.840 --> 40:53.520]  Для этого он составляет список все попарно неравносильные формулы кванторной глубины
[40:57.840 --> 41:23.400]  на единичку меньше, а с количеством параметров на единичку больше. Вот такой вот список. Это
[41:23.400 --> 41:34.080]  формулы, у них m плюс один параметр. Дальше консерватор записывает такую формулу.
[41:34.080 --> 42:01.480]  Конъюнкция вот по этим всем формулам. Я сейчас напишу, а потом прокомментирую.
[42:01.480 --> 42:29.400]  Тут давайте я напишу все-таки свободные параметры. Во-первых, это формула, поскольку формулы
[42:30.000 --> 42:39.040]  кванторной глубины не больше, чем l минус один. Но есть один нюанс, на который я хочу обратить
[42:39.040 --> 42:44.920]  внимание. В нашей сигнатуре нет константа, поэтому то, что написано вот здесь, вообще говоря,
[42:44.920 --> 42:55.480]  не совсем корректно. У нас в формуле первого порядка нет этого члена. Но что здесь написано,
[42:55.480 --> 43:02.400]  что BIT совпадает на наборе a1, am плюс один и на наборе x1, xm плюс один. А вот это вот,
[43:02.400 --> 43:08.360]  у нас уже новатор сделал ход, то есть вот это совершенно определенные элементы первой модели,
[43:08.360 --> 43:21.560]  и оценки всех этих формул в этой модели получаются одинаковыми. Чего у нас тут? В первой
[43:21.560 --> 43:34.160]  модели тут надо написать вот эту формулу или ее отрицание. Если значение этой формулы на
[43:34.160 --> 43:40.160]  наборе, в первой модели на наборе a1, am плюс один истинно, мы должны написать саму формулу,
[43:40.160 --> 43:46.160]  тогда эквивалентность будет выполняться. Если тут написана ложь, мы должны писать вместо формулы
[43:46.160 --> 43:54.680]  BIT и отрицание BIT, тогда тоже эквивалентность будет выполняться. То есть вот это вот, на самом
[43:54.680 --> 44:03.200]  деле символическая запись, ну вот таких вот литералами их не назовешь, а формулы или отрицания
[44:03.200 --> 44:10.720]  от x1, xm плюс один, вот это более корректная запись, но менее понятная, потому что вот эти альфаиты
[44:10.720 --> 44:15.800]  нуждаются в объяснениях. А эта запись очень наглядна, ее удобно в рассуждении дальше использовать.
[44:15.800 --> 44:24.000]  То есть вот консерватор смотрит на такую формулу. Что мы знаем про эту формулу? По
[44:24.000 --> 44:41.280]  предположению индукции, по условию LEM, эта формула не различает наши наборы a1, am и b1, bm. У нее кванторная
[44:41.280 --> 45:06.400]  глубина LEP по условию не различает. Ну тогда что? Тогда если мы... Эта формула заведома в первой
[45:06.400 --> 45:13.160]  модели истинна, потому что если мы подставим вместо x1, xm, a1, am, то вот этот квантор существования,
[45:13.160 --> 45:18.520]  это будет просто am плюс один, потому что у нас получится, ну как бы, что формула а, эквивалентная
[45:18.520 --> 45:23.520]  формуля а. То есть в первой модели она всегда истинна. Значит она истинна и во второй модели. То есть
[45:23.520 --> 45:35.440]  если я сюда подставлю b1, bm, будет существовать какой-то bm плюс первый. Такое, что если я выберу
[45:35.440 --> 45:40.680]  значение параметра xm плюс один, bm плюс один, то у меня формула станет истиной. То есть все вот эти
[45:40.680 --> 45:46.400]  вот формулы, которые у меня есть, они будут истинны или ложны в зависимости от значения формулы на
[45:46.400 --> 45:55.520]  втором наборе, наборе аиты. Ну вот консерватор и будет ходить в этот bm плюс один. Это его ответ.
[45:55.520 --> 46:07.720]  Что после этого хода получается? Получается, что мы находимся в условиях леммы, но на единичку
[46:07.720 --> 46:13.440]  меньше кванторной глубиной. Потому что смотрите, у нас на наборах а1, ам плюс один, b1, bm плюс один,
[46:13.440 --> 46:22.800]  должны совпадать все формулы с м плюс одним, с кванторной глубиной меньше l, то есть меньше
[46:22.800 --> 46:29.240]  либо равной l минус один. Потому что, напомню еще раз, вот сюда я вставил список всех вообще формул,
[46:29.240 --> 46:35.280]  которые мы можем написать. Вот тут лемма еще не стерта, их конечное количество. Поэтому я могу
[46:35.280 --> 46:41.320]  составить такой список. Это будет пусть длинная, но это будет формула, конечное слово. И поэтому
[46:41.320 --> 46:46.600]  мы остаемся в условиях леммы. Можем применить индуктивное предположение. После этого мы оказываемся
[46:46.600 --> 46:52.320]  во второй части леммы по индуктивному предположению. У консерватора есть выигрышная стратегия. Вот он
[46:52.320 --> 46:58.400]  продолжает так играть. Такое вот достаточно хитрое рассуждение в случае игры с консерватором,
[46:58.400 --> 47:05.840]  которое, разумеется, совершенно непрактично. Потому что написать все мыслимые формулы кванторной
[47:05.840 --> 47:12.840]  глубины уже там два с тремя параметрами, это какое-то достаточно сложное занятие. Вы видели,
[47:12.840 --> 47:19.720]  как все быстро растет. Но, тем не менее, это дает доказательство, что стратегия есть. Стратегии,
[47:19.720 --> 47:24.320]  которые мы придумывали, не такие уж сложные. Мы доказываем существование стратегии. Не обязательно
[47:24.320 --> 47:28.520]  она должна быть вот такой сложной. И консерватору не обязательно выписывать эти формулы. Может быть,
[47:28.520 --> 47:39.160]  он как-то может свою стратегию сформулировать проще. Но на этом лемма доказана. Доказана тем
[47:39.160 --> 47:44.200]  самым и теорема об играх и Ренфоих. То есть построен критерий элементарной эквивалентности.
[47:44.200 --> 47:51.040]  Я напомню для каких пар моделей. Модели должны иметь конечную сигнатуру только из предикатных
[47:51.040 --> 47:56.080]  символов. Доказательство видно, что и то, и то существенно. Конечность сигнатура существенна
[47:56.080 --> 48:02.160]  вот для этой части. Ничего бы не получилось, если бы сигнатура была бесконечной. И для нее же на
[48:02.160 --> 48:07.160]  самом деле существенно, что нет функциональных символов. Потому что, если есть функциональные
[48:07.160 --> 48:15.320]  символы, то не очень сложно построить огромное количество. То есть я могу, допустим, если у меня
[48:15.320 --> 48:20.920]  даже есть унарный функциональный символ, я его могу к переменной применять много-много раз. Это
[48:20.920 --> 48:25.160]  получится все так существенно разные термы. Потом навешивать какой-то предикатный символ. У меня
[48:25.160 --> 48:30.000]  может вообще говоря, ну там понятно, может быть какая-то модель, где их все равно конечное
[48:30.000 --> 48:35.120]  количество. Допустим, конечная модель. Но если модель бесконечная, то может оказаться бесконечно
[48:35.120 --> 48:40.360]  много разных предикатов несовпадающих. Поэтому опять-таки вот эта вторая часть не проходит.
[48:40.360 --> 48:46.080]  Но вот в этих предположениях, что сигнатура конечная и нет функциональных предикатных символов,
[48:46.080 --> 48:54.720]  это доказательство работает. И мало того, что мы получаем такой достаточно мощный способ
[48:54.720 --> 49:01.400]  проверки элементарной эквивалентности теории. Возвращаясь к вопросу о выразимости,
[49:01.480 --> 49:06.680]  мы получаем еще один инструмент для доказательства выразимости и невыразимости предикатов. Потому что,
[49:06.680 --> 49:13.360]  заметьте, я доказал вот эту лему. Для выразимости предикатов удобно использовать ее не при m равном
[49:13.360 --> 49:19.800]  нулю, а скажем при m равном единице. В общем, какая арность предиката. Я сейчас это проиллюстрирую на
[49:19.800 --> 49:32.880]  сравнительно простом примере. Ну точнее даже на двух примерах. Второй будет немножко, ну его
[49:32.880 --> 49:38.760]  можно подогнать под эту схему, но он немножко про другое. А первый пример такой. Вот у нас уже
[49:38.760 --> 49:48.600]  была модель в прошлый раз. Я напомню, что такое порядок n плюс n. Это мы берем две копии натуральных
[49:48.600 --> 49:58.680]  чисел и упорядочим их так, что числа во второй копии, которые вот я со штрихами пишу, они больше
[49:58.680 --> 50:04.920]  всех чисел без штрихов в первой копии. Вот такой вот линейный порядок. У нас есть единственный предикат меньше.
[50:04.920 --> 50:17.000]  Ну квантор здесь иллюминировать не получится. Почему? Потому что есть, без кванторная формула тут
[50:17.000 --> 50:21.200]  вообще ничего интересного не скажет. Допустим про унарный предикат, потому что он скажет x меньше x,
[50:21.200 --> 50:27.600]  но это же действительно ложно и все. У нас нет функциональных символов. А что-то нетривиальное выразить можно.
[50:27.600 --> 50:40.440]  Вот что, например, выражает вот такой вот предикат с квантором и с одним параметром. Какой-то унарный
[50:40.440 --> 50:49.560]  предикат выражается. Для любого у неверно, что у строго меньше x, но есть такой ровно 1 x, для которого это
[50:49.560 --> 50:55.480]  выполняется. Это вот этот вот самый не штрихованный ноль. То есть предикат x равно не штрихованному нулю,
[50:55.480 --> 51:09.120]  он выражается. А скажем предикат x штрихованное число, ну то есть попадает во вторую копию, не выражается.
[51:09.120 --> 51:20.040]  Как это доказать? Ну на самом деле я честно признаюсь, что для простоты я взял очень простой
[51:20.040 --> 51:27.000]  случай и с эллиминацией кванторов тоже можно побороться, можно расширить сигнатуру подходящим образом.
[51:27.000 --> 51:31.600]  Расширение сигнатура такая палка о двух концах. Я же могу этот предикат, сигнатуру добавить, тогда он
[51:31.600 --> 51:36.280]  конечно выражаться будет. То есть мне надо так расширить, чтобы все-таки он еще не выражался.
[51:36.280 --> 51:42.720]  Но тут это сделать можно, потому что реально кроме этого предиката, который выражает ноль, у нас по сути
[51:42.720 --> 51:49.840]  ничего интересного мы в этом порядке выразить не сможем. И поэтому можно просто добавить ровно
[51:49.840 --> 51:57.680]  вот такой вот предикат ноль и доказывать уже, что возможна эллиминация кванторов. Ну это отдельная
[51:57.680 --> 52:05.200]  история. Я сейчас хочу объяснить, как с помощью игры RunFloat доказать, что x штрихованное не выражается.
[52:05.200 --> 52:14.880]  Давайте рассмотрим игру RunFloat на паре моделей, которые совпадают. Вот этой модели я обозначу
[52:14.880 --> 52:26.520]  m и возьму игру RunFloat на паре моделей m и m. Ну никто не запрещает. Конечно, когда мы проверяем
[52:26.520 --> 52:31.200]  критерии элементарной эквивалентности, это какое-то безумие, потому что консерватор просто тот
[52:31.200 --> 52:36.960]  же самый элемент будет выбирать, всё время ничего не изменится. Но Lemmo можно применить сходом.
[52:36.960 --> 52:49.120]  Давайте применим Lemmo, когда a1 у нас равно, ну там не знаю, допустим, значит я рассуждаю от противного,
[52:49.120 --> 53:00.120]  пусть формула phi выражает, предикат как-нибудь, ну давайте звёздочку поставлю, просто чтобы не
[53:00.120 --> 53:10.360]  придумывать, выражает звёздочку. Кванторная её глубина, допустим h. Если есть формула,
[53:10.360 --> 53:15.200]  которая выражает конечное слово, в ней кванторную глубину можно посчитать какое-то конечное число.
[53:15.200 --> 53:27.280]  И мы теперь применяем Lemmo так, мы берем пару a1 это 2 в степень h плюс 1, а b1 это тоже число,
[53:27.280 --> 53:39.560]  но в штрихованной копии. Вот на такой паре позиции мы применяем Lemmo, с каким значением l, а l как
[53:39.560 --> 53:50.720]  раз равняется h. Ну Lemmo нам говорит, что мы предположили, что есть формула, которая выражает
[53:50.720 --> 53:57.840]  предикат, значит она будет различать эти два a1 и b1, а 1 в нештрихованной части, b1 в штрихованной.
[53:57.840 --> 54:06.920]  Но то есть по Lemmo это означает, что выраженная стратегия должна быть у новатора. На самом
[54:06.920 --> 54:13.600]  деле выраженная стратегия у консерватора есть в этой игре, которая начинается с такой позиции,
[54:13.600 --> 54:24.720]  и это по сути дела очень несложная модификация того, что у нас было в прошлый раз. Я напомню,
[54:24.720 --> 54:30.920]  что там я доказывал элементарную эквивалентность такого порядка и просто натуральных чисел. И,
[54:30.920 --> 54:37.880]  кстати, те, кто смотрели конспект лекции, обратили внимание, что я допустил ошибку. Я когда
[54:37.880 --> 54:43.800]  объяснял стратегию консерватора, я одну вещь упустил. Консерватору нужно еще поддерживать,
[54:43.800 --> 54:51.520]  вот когда он поддерживает некоторый порядковый изоморфизм. Я сейчас буду постепенно напоминать,
[54:51.520 --> 55:04.040]  что имеется в виду. Тут по сути дела мне тоже самое нужно сделать. Вот он поддерживает такой
[55:04.040 --> 55:09.440]  порядковый изоморфизм на выбранных структурах. Он обязательно в него должен включать ноль. То
[55:09.440 --> 55:16.120]  есть игра начинается, прежде чем консерватор начинает поддерживать инвариант, он сразу ставит ноль.
[55:16.120 --> 55:24.000]  Поэтому, например, если количество ходов большое, и новатор выбирает один, консерватор обязан
[55:24.000 --> 55:30.560]  выбрать один. Иначе ему будет плохо, иначе новатор его загонит в ноль, и если он выберет другое
[55:30.560 --> 55:36.720]  число, то там возникнет разница. Поэтому ноль нужно поддерживать. А вот здесь у нас еще были такие
[55:36.720 --> 55:49.000]  вот разрывы уровня И. То есть это что разность переменных не меньше, чем два в степени И.
[55:49.000 --> 55:55.320]  Основная идея инварианта, который поддерживает консерватор, что очень большие расстояния никак
[55:55.320 --> 56:02.360]  не различимы за небольшое количество ходов. Вот так совсем неформально, что мы можем делать с
[56:02.360 --> 56:08.760]  большим отрезком? Мы его можем поделить примерно пополам. Поэтому, если расстояние больше чем два
[56:08.760 --> 56:16.360]  в степени возможное количество ходов, ну мы не исчерпаем отрезок. То есть у нас там останутся
[56:16.360 --> 56:21.560]  какие-то числа, у нас никакого противоречия мы не найдем. То есть если один отрезок очень большой
[56:21.560 --> 56:28.480]  одной длины, другой очень большой другой длины, то мы не уличим в этом консерваторе, ну или даже
[56:28.480 --> 56:34.920]  бесконечной длины. Здесь то же самое. Здесь нужно поддерживать аналогичный инвариант. Единственное,
[56:34.920 --> 56:43.640]  что начинать нужно не с ноль-ноль, а вот вот с этой вот пары. Вот мы сразу должны вставить 2h
[56:43.640 --> 56:52.200]  плюс один, а сюда вставить 2h плюс один с треховыми. То есть вот у нас перед самым первым ходом
[56:52.200 --> 56:56.960]  новатора, консерватор, который свою стратегию разрабатывает, он сразу берет вот такие две
[56:56.960 --> 57:05.040]  обстоятельства. Они порядково изоморфны, потому что вот здесь вот разрывы большие, уровня больше h.
[57:05.040 --> 57:13.840]  Ну один вообще бесконечный, а второй он больше, чем h. И идея стратегии консерватора состоит
[57:13.840 --> 57:19.200]  в том, что бесконечный разрыв от очень большого конечного различить невозможно, значит вот на этой
[57:19.200 --> 57:25.280]  паре он выиграет. То есть как бы не ходил новатор, ну там я не буду все подробности стратегии рассказывать,
[57:25.280 --> 57:33.960]  но хотя бы один из, он ходит в какой-то из отрезков интервалов, хотя бы один из интервалов,
[57:33.960 --> 57:38.200]  если интервал был бесконечным уровнем h, хотя бы один из интервалов будет бесконечным уровнем h
[57:38.200 --> 57:45.520]  минус 1, и консерватор имеет возможность сделать ход, который обеспечит ему, что вот соответствующий
[57:45.520 --> 57:51.640]  интервал тоже уровня h минус 1 бесконечный. Ну а если какой-то конечный, консерватор отступит ровно
[57:51.640 --> 57:56.800]  это конечное количество. И здесь все то же самое, то есть никакой разницы нет, рассуждение,
[57:56.800 --> 58:03.360]  которое было, оно применяется и здесь. Я его подробно пересказывать не буду, потому что и так
[58:03.360 --> 58:12.160]  как-то по времени чуть-чуть я затянул. Ну идея, я думаю, понятна, то есть вот мы доказали, что
[58:12.160 --> 58:20.200]  предикат невыразим, просто сославшись на то, что есть стратегия консерватора, а если бы он был
[58:20.200 --> 58:29.120]  выразим, должна была быть стратегия инноватора. Еще один пример, который, ну я почему его хочу
[58:29.120 --> 58:34.960]  привести, потому что это одно из самых известных приложений игры Renfoy. Там задач очень много,
[58:34.960 --> 58:46.040]  я скажу только самую простую, а вообще там большая сложная наука. Мы можем применять вот,
[58:46.040 --> 58:53.560]  заметьте, вот эту лему и к конечным моделям тоже. Вообще в конечных моделях все вроде бы очень
[58:53.560 --> 58:59.960]  просто, потому что там всего конечное количество элементов, инноватор, если они элементарно
[58:59.960 --> 59:05.600]  не эквивалентны, инноватор там выберет больше, чем количество элементов модели и все. То есть там
[59:05.600 --> 59:16.880]  только изоморфизм остается. Но можно рассматривать такие семейства конечных моделей и смотреть на них.
[59:16.880 --> 59:21.680]  Это в принципе все укладывается вот такую же схему, но удобно это формулировать иначе. Я вот сейчас
[59:21.680 --> 59:28.360]  скажу на конкретном примере. Давайте рассматривать теорию графов. Значит, что такое графы с точки
[59:28.360 --> 59:39.960]  зрения модели? Вот у нас есть граф G, у нас есть предикат равенства, x и y это вершины, и у нас
[59:39.960 --> 59:50.480]  есть предикат как бы его обозначить. Ну давайте я вот так вот просто напишу. Два бинарных предиката,
[59:50.480 --> 59:57.680]  просто x равно y, ну как-то не иметь равенства неудобно, и пара x и y является ребром в нашем
[59:57.680 --> 01:00:04.320]  графе. Графы будем для простоты считать простыми и неориентированными, это большой разницы нет,
[01:00:04.320 --> 01:00:10.960]  раз у нас есть равенства, мы всегда можем там различать петли, это все не проблема. То есть
[01:00:10.960 --> 01:00:16.680]  фактически мы ограничиваем наш выразительный язык таким очень естественным образом. Ну что мы
[01:00:16.680 --> 01:00:24.080]  про графы можем говорить? Ну какие-то вершины инцидиантны каким-то, какие-то равны. И можем
[01:00:24.080 --> 01:00:32.080]  использовать кванторы по вершинам. Ну получаем какие-то формулы. Эти формулы,
[01:00:32.080 --> 01:00:40.520]  замкнутые, выражают какие-то свойства графов. Я вот утверждаю, что в логике первого порядка
[01:00:40.520 --> 01:00:57.280]  не выразим предикат граф связный. Вот тут смотрите, почему я делал оговорки. Предикат,
[01:00:57.280 --> 01:01:02.640]  который я хочу выразить, он уже не в наших моделях. Это утверждение про графы. То есть
[01:01:02.640 --> 01:01:09.520]  фактически я смотрю на задачу так, у меня есть много моделей, в каждой модели у меня есть одна и
[01:01:09.520 --> 01:01:15.000]  та же сигнатура, и каждая замкнутая формула задает ну какой-то предикат на этой модели. А
[01:01:15.000 --> 01:01:23.600]  если формула замкнутая, то она задает просто истину или ложь. Соответственно, если мы взяли
[01:01:23.600 --> 01:01:29.200]  какую-то замкнутую формулу в этой сигнатуре, она определяет уже предикат на моделях. В данном
[01:01:29.200 --> 01:01:36.440]  случае на графах. То есть для графа формула верна или формула не верна. Ну например, в графе есть
[01:01:36.440 --> 01:01:46.120]  вершина степени 3. Это предикат выражается в нашей сигнатуре. Почему? Потому что нужно сказать,
[01:01:46.120 --> 01:01:54.600]  что существует вершина. Такая, что есть там v, такая, что есть x, y, z, попарно различные. И такие,
[01:01:54.600 --> 01:02:02.560]  что они смежные, вот используя вот этот предикат, они смежные с v. А для любой другой вершины,
[01:02:02.560 --> 01:02:10.720]  там t, она не смежна с v. Мы получаем предикат, что существует вершина степени 3. Существует
[01:02:10.720 --> 01:02:15.200]  крик размера 3. То есть, в общем, вот такие вот локальные свойства мы все выразить можем. А
[01:02:15.200 --> 01:02:20.640]  глобальное свойство, как связность, выразить не удается. И тому есть очень важное объяснение.
[01:02:20.640 --> 01:02:31.080]  Предположим, что у нас есть какая-то формула, там phi, которая выражает связность. Значит,
[01:02:31.080 --> 01:02:44.080]  она должна, это замкнутая форма, она должна на... и у нее кванторная глубина, там не знаю, h. Она
[01:02:44.080 --> 01:02:49.880]  должна на связанных графах давать один ответ, она не связанных к другому. Ну, одно значение,
[01:02:49.880 --> 01:02:58.880]  она не связанных к другому. Давайте возьмем в качестве одного графа цикл, там не знаю, длины 2
[01:02:58.880 --> 01:03:11.520]  в степени 2h, а в качестве другого два цикла длины 2 в степени 2h. Это граф g1, граф g2. Если мы
[01:03:11.520 --> 01:03:16.080]  интерпретируем нашу формулу в первой модели, должна быть истина, если во второй должна быть
[01:03:16.080 --> 01:03:23.480]  ложь. Но утверждение, которое я теперь делаю, смотрите, вот внимательно следите за руками,
[01:03:23.560 --> 01:03:30.440]  я утверждаю, что эти модели, конечно, нельзя сказать, что они элементарно эквивалентны,
[01:03:30.440 --> 01:03:37.360]  потому что если я напишу формулу, в которой там больше чем 2h плюс 1 переменных, 2 степени 2h
[01:03:37.360 --> 01:03:47.920]  плюс 1, то я их различу. Но, если я рассматриваю формулы кванторной глубины h, то они все принимают
[01:03:47.920 --> 01:03:53.680]  одинаковое значение на этих моделях. А наша лемма позволяет доказывать такие утверждения,
[01:03:53.680 --> 01:03:59.440]  потому что, по сути дела, она говорит, что нам нужно доказать, чтобы прийти к противоречию,
[01:03:59.440 --> 01:04:06.320]  нам нужно доказать, что в игре Ренфойхта на h раундах тут уже новатор не имеет возможности. Мы как бы
[01:04:06.320 --> 01:04:10.280]  смотрим на игру после того, как новатор объявил ход. Раз у нас есть формула кванторной глубины h,
[01:04:10.280 --> 01:04:17.680]  то различающие эти две модели, то новатор, мы забираем у него эту степень свободы, мы говорим,
[01:04:17.680 --> 01:04:23.440]  что раз есть такая различающая формула, следуя этой лемме, мы можем утверждать, что новатор
[01:04:23.440 --> 01:04:31.800]  должен выигрывать за h раундов. Эта лемма дает нам и такую информацию. Ну а доказать, что на самом
[01:04:31.800 --> 01:04:36.000]  деле тут выигрывает консерватор не очень сложно. Это очень похоже на вот тот пример, который мы
[01:04:36.000 --> 01:04:42.320]  разбирали. Почему? Потому что, смотрите, что фактически наши предикаты задают? Расстояние между
[01:04:42.320 --> 01:04:50.800]  вершинами 0, это если они совпадают, и расстояние между вершинами 1, это если они смежны. Больше мы
[01:04:50.800 --> 01:04:57.240]  ничего, в общем-то, про расстояние сказать не можем. Поэтому если мы будем подходящим
[01:04:57.240 --> 01:05:03.040]  образом модифицировать это понятие порядкового изоморфизма, ну у нас теперь циклы, но мы хотим
[01:05:03.040 --> 01:05:08.280]  поддерживать циклический порядок. Вот и во втором случае тоже у нас вроде бы там два цикла, но мы
[01:05:08.280 --> 01:05:15.360]  будем вставлять один в другой, так мысленно вставлять один в другой, поддерживая вот здесь,
[01:05:15.360 --> 01:05:24.200]  ну так, условно говоря, бесконечный разрыв. Это возможно, потому что если у нас всего h ходов,
[01:05:24.200 --> 01:05:31.000]  мы на цикле 2 в степени 2h выбрали всего h точек, ну какой-то интервал очень большой. То есть,
[01:05:31.000 --> 01:05:36.640]  если вы выбираете две точки, у вас один из интервалов не меньше, чем половина, тут даже не
[01:05:36.640 --> 01:05:43.960]  2h, можно 2 в степени h плюс 1, это я так для подстраховки написал 2h. Ну и дальше мы просто тот же самый
[01:05:43.960 --> 01:05:48.400]  поддержимый вариант, то есть мы немножко меняем понятие порядкового изоморфизма, мы хотим такой
[01:05:48.400 --> 01:05:54.240]  циклический порядок поддерживать на тех элементах моделей, которые выбираются. И утверждаем,
[01:05:54.240 --> 01:05:59.560]  что этот циклический порядок вот с буквальным переформулировкой вот этих вот разрывов уровня
[01:05:59.560 --> 01:06:07.640]  и, то есть теперь это расстояние по графу, он буквально сохраняется. То есть тут тоже, конечно,
[01:06:07.640 --> 01:06:11.520]  расстояние между вершинами из разных связанных компонентов бесконечно, мы видели, что это ничего
[01:06:11.520 --> 01:06:16.640]  не препятствует, очень большое конечное число и бесконечное мы никак не можем различить. Поэтому
[01:06:16.640 --> 01:06:22.360]  получается такое сравнительно легкое доказательство. Ну дальше там много разных теорем про это дело
[01:06:22.360 --> 01:06:35.840]  есть, я в подробности уже вдаваться не буду. И на этом мы вот эту первую часть курса закончили. Я
[01:06:35.840 --> 01:06:42.240]  надеялся закончить чуть быстрее, но оставшиеся 10 минут я хочу все-таки каким-то толком потратить,
[01:06:42.240 --> 01:06:47.960]  значит потому что нам предстоит довольно сложная вторая часть и она будет уже не семь
[01:06:48.920 --> 01:06:54.720]  хотя она сложнее в первой части. Но с другой стороны мы потренировались, вы размялись,
[01:06:54.720 --> 01:07:00.640]  немножко так приучились думать в терминах формул. О чем пойдет дальше речь? Ну я напомню,
[01:07:00.640 --> 01:07:05.000]  что в логике самое интересное, собственно, для чего его создавали, это формализовать не сами
[01:07:05.000 --> 01:07:11.120]  утверждение, а доказательство. И вот мы теперь рассмотрим, что делать с доказательством. Утверждение
[01:07:11.120 --> 01:07:15.800]  мы будем формализовывать вот так, как уже это мы делали, булевыми формулами или формулами
[01:07:15.800 --> 01:07:24.360]  первого порядка. А как формализовывать доказательство? Ну я хочу рассказать два подхода.
[01:07:24.360 --> 01:07:32.200]  Первый подход классический, так логика и возникала, и он имитирует аксиоматический метод,
[01:07:32.200 --> 01:07:40.360]  который восходит еще к древним грекам, геометрии, то есть мы фиксируем какие-то аксиомы, и из этих
[01:07:40.360 --> 01:07:47.320]  аксиом с помощью формальных логических правил вывода выводим новые утверждения. И вот так
[01:07:47.320 --> 01:07:54.920]  постепенно получаем теорию. Вот такой аксиоматический подход возможен, а я его подробно расскажу в такой
[01:07:54.920 --> 01:08:02.960]  сравнительно простой ситуации, когда у нас формулы, булевые формулы. Ну я там даже введу
[01:08:02.960 --> 01:08:06.840]  ограничения, я сейчас про них скажу, наверное, сегодня успею про них сказать, как раз все
[01:08:06.840 --> 01:08:14.600]  предварительные вещи по видео успею сказать. Булевые формулы, а хотим доказывать тавтологии,
[01:08:14.600 --> 01:08:20.800]  то есть теоремы, которые нас интересуют, имеют вид. Формула является тавтологией. Значит, что вот
[01:08:20.800 --> 01:08:25.080]  эта вся программа, которую я сказал, означает? Нам нужно задать аксиомы, то есть выбрать какое-то
[01:08:25.080 --> 01:08:30.040]  множество формул, в которые мы говорим, вот это тавтология, это мы доказывать не будем, это мы
[01:08:30.040 --> 01:08:35.720]  отдельно изучим, почему это тавтология. А дальше мы должны еще сформулировать правила вывода. Вот у нас
[01:08:35.720 --> 01:08:40.680]  есть уже какое-то множество выведенных формул. Мы хотим сказать, что если у нас есть такая-то и
[01:08:40.680 --> 01:08:45.880]  такая-то формула, то еще какая-то формула, тоже мы за один шаг ее выводим, она тоже тавтология. И
[01:08:45.880 --> 01:08:53.080]  цель придумать вот это множество аксиом и правил вывода так, чтобы выводились только тавтологии,
[01:08:53.080 --> 01:08:58.960]  но при этом все тавтологии выводились. То есть двоякая цель. Мы не хотим делать ошибки ни в
[01:08:58.960 --> 01:09:03.760]  одну сторону, мы не хотим вывести случайно какую-то нет тавтологию. Потому что, конечно, есть очень
[01:09:03.840 --> 01:09:11.080]  простое правило вывода подставить любую формулу. Или наоборот сказать, что все формулы это аксиомы.
[01:09:11.080 --> 01:09:19.960]  Тоже хороший способ как бы тревелизовать эту задачу, сказать, пусть у нас аксиомами будут все
[01:09:19.960 --> 01:09:27.760]  тавтологии. Ну на это резонно возразить, но если тавтология сложно устроена, то мы ничего как бы
[01:09:27.760 --> 01:09:36.360]  и не узнаем. Эту же претензию можно предъявить и к более сложным наборам, но идея, которая двигалась
[01:09:36.360 --> 01:09:41.440]  логиками, была следующая, что тавтологии бывают очень сложные, там их очень много, они разноустроенные.
[01:09:41.440 --> 01:09:47.960]  А мы хотим зафиксировать какие-то простые и понятные правила, которые точно уже можно
[01:09:47.960 --> 01:09:54.320]  объявить тавтологиями, а потом все остальное доказывать. На этом пути, если это все
[01:09:54.320 --> 01:10:00.520]  формализовать, это сейчас я начну и в следующий раз мы продолжим, возникают разные проблемы.
[01:10:00.520 --> 01:10:07.440]  В частности, проблема такая, что если у нас много связок, много аксиомов, много правил вывода,
[01:10:07.440 --> 01:10:12.960]  все доказательства будут длинными, потому что нам нужно проверять про все аксиомы что-то,
[01:10:12.960 --> 01:10:17.800]  про правила вывода что-то, и большое количество связок приводит к большому количеству случаев
[01:10:17.800 --> 01:10:24.360]  перебора, какие бывают формулы. С другой стороны, если сделать небольшое количество связок,
[01:10:24.360 --> 01:10:31.560]  а можно ограничиться одной связкой. Если вы возьмете книжку Мендельсона, вы увидите там
[01:10:31.560 --> 01:10:38.640]  формальную систему, в которой выводятся все тавтологии в базисе NAND штрих шефера, то есть
[01:10:38.640 --> 01:10:43.520]  это отрицание к конъюнкции. Если вы вспомните про теория Мопоста, вас и вроде бы учили, это
[01:10:43.520 --> 01:10:49.000]  полная система связок, вот одна такая булевая связка. С любую булевую функцию вы можете выросить.
[01:10:49.000 --> 01:10:55.600]  Некоторые формулы будут получаться тавтологиями. Так вот, тавтологии в этой системе можно вывести
[01:10:55.600 --> 01:11:01.240]  из одной, вообще не из одной формулы, а из одной, как я чуть позже скажу, это формальней схемой
[01:11:01.240 --> 01:11:06.400]  аксиомов, то есть формула, куда мы можем в качестве переменных подставлять какие-то другие формулы.
[01:11:06.400 --> 01:11:14.320]  И вот тут нам совсем хорошо, схема аксиомов всего одна, но доказательства получаются абсолютно
[01:11:14.320 --> 01:11:23.800]  непонимаемые, поэтому нужно выбирать какую-то вот золотую середину. Я такую золотую середину вам
[01:11:23.800 --> 01:11:30.600]  предложу. Как всегда, когда компромисс, не все согласны, что это удачный компромисс. То есть это
[01:11:30.600 --> 01:11:35.320]  не то, что оптимальное решение в каком смысле, экстремальное по какому-то параметру, а мы учитываем
[01:11:35.320 --> 01:11:41.400]  разные параметры и делаем не оптимально ни по одному из них, но как-то вот считаем, что сбалансировали.
[01:11:41.400 --> 01:11:47.360]  Вот я считаю, что это удачное компромиссное решение. Это у нас будет формальная система. Формулы
[01:11:47.360 --> 01:11:56.720]  в этой системе используют только связки импликация и отрицание. Вот отличие от тех формул,
[01:11:56.720 --> 01:12:01.800]  которые у меня было, состоит в том, что я хочу оставить только эти две связки. Это сократит
[01:12:01.800 --> 01:12:06.200]  количество аксиом, которые мне нужны, ну и количество разборов случаев в предоказательствах.
[01:12:06.200 --> 01:12:11.200]  Когда мы разбираем формулу, у нас каждая связка дает отдельный случай для разбора.
[01:12:11.200 --> 01:12:25.440]  Что делать с остальными формулами? Ну в смысле, с остальными связками. Мы же не хотим себя лишать
[01:12:25.440 --> 01:12:30.680]  выразительных возможностей. Здесь юнса, скажем, что это такое. Ну, мы знаем, что это такое на самом
[01:12:30.680 --> 01:12:40.760]  деле. Это х дизюнкция у равносильно формуле из них следует у. Импликация и отрицание тоже полная
[01:12:40.760 --> 01:12:47.480]  система связок. Вот мы будем считать, что дизюнкция формул у нас на самом деле просто означает вот
[01:12:47.480 --> 01:12:58.880]  такую формулу. А конъюнкция, соответственно, будет означать отрицание, как бы не ошибиться.
[01:12:58.880 --> 01:13:08.680]  Вот так вот. Давайте проверим, что это действительно конъюнкция. Если х равен 0,
[01:13:08.680 --> 01:13:21.960]  это 0. Если у равен 0, это 0. Ну а если х и у равны единице, то это единица 0. Ну и эквивалентность
[01:13:21.960 --> 01:13:30.840]  нам может захотеться. Это будет просто из х следует у и из у следует х. Тут я уже конъюнкцию могу
[01:13:30.840 --> 01:13:37.400]  использовать то, что я определил. То есть вот в нашей сокращенной системе мы будем формулами считать
[01:13:37.400 --> 01:13:43.400]  по определению только формулы со связками импликация и отрицания, а остальные связки
[01:13:43.400 --> 01:13:47.760]  будем считать сокращениями. То есть чтобы получить формулу вот в определении вот этого
[01:13:47.760 --> 01:13:53.120]  формального исчисления высказываний, нам нужно вместо конъюнкции и дизюнкции и там эквивалентности
[01:13:53.120 --> 01:14:06.760]  подставить вот такие вот подформулы. В остальном определение более формулы такое же, как у нас было.
[01:14:06.760 --> 01:14:26.520]  Я напомню, что цель моя это выражать тавтологией. Ну как я говорил, мне нужны аксиомы. И вот здесь
[01:14:26.520 --> 01:14:31.800]  первая вещь, которая вас поразит наверное, потому что аксиомами в нашей формальной системе будут
[01:14:31.800 --> 01:14:41.160]  называться формулы, которые не очень-то похожи на простые понятные тавтологии. Я их сейчас напишу,
[01:14:41.160 --> 01:14:53.640]  объясню, что я написал. Это я успею сделать, но больше пореден ничего не успею. Так.
[01:15:11.160 --> 01:15:28.880]  То есть смотрите, я фактически записал три схемы аксиом. Что такое схема формул? Схема формул,
[01:15:28.880 --> 01:15:36.920]  по сути дела, это тоже формула. Но по определению схема формул это множество формул. Она задается
[01:15:36.920 --> 01:15:41.520]  одной формулой, а формулы из этого множества получаются так. Я вместо переменных, ну скажем,
[01:15:41.520 --> 01:15:46.800]  первой схеме, переменной a и b, я могу подставить любую формулу. Единственное, что вместо буквы
[01:15:46.800 --> 01:15:56.200]  я должен подставить одну и ту же. И получаем, ну вот все множество формул такого вида называется
[01:15:56.200 --> 01:16:04.600]  схемой, в данном случае аксиомы a1. Соответственно, такого вида множеством схемы аксиомы a2. Это
[01:16:04.600 --> 01:16:13.600]  аксиомы a3. Ну видите, они довольно странные и дикие, и почему выбраны такие аксиомы, не очень
[01:16:13.600 --> 01:16:20.760]  ясно. Наша цель какая? Наша цель, но она двоякая. Во-первых, мы готовим почву для более сложной
[01:16:20.760 --> 01:16:25.920]  работы с формулами первого порядка. Когда мы будем строить аксиомы и правила вывода для
[01:16:25.920 --> 01:16:33.920]  чрезначимых формул, мы это будем использовать. А во-вторых, мы хотим все построить так, чтобы
[01:16:33.920 --> 01:16:40.800]  доказательства шли как можно проще. И на самом деле выяснится, что вот это вот формулы выбраны
[01:16:40.800 --> 01:16:47.000]  так, чтобы с ними очень легко проходили важные для нас доказательства. То есть это такой искусственный
[01:16:47.000 --> 01:16:53.400]  конструкт. Объяснять почему именно такой набор формул нужно признать самыми очевидными тавтологиями
[01:16:53.400 --> 01:17:00.480]  я не буду. Они удобны для построения формальной системы. Наша цель, чтобы у нас была адекватная
[01:17:00.480 --> 01:17:06.600]  формализация. Ну и они чем проще, смотрите, в отличие от всего множества тавтологии, это очень
[01:17:06.600 --> 01:17:10.600]  трудная алгоритмическая издача проверить, является ли формула тавтологии. В следующем
[01:17:10.600 --> 01:17:15.840]  семестре объяснят точный смысл этого слова. Она, как говорят в науке о сложности, коэнп полная.
[01:17:15.840 --> 01:17:24.360]  А аксиомы образуют простое множество. Есть простой эффективный алгоритм по формуле проверить,
[01:17:24.360 --> 01:17:30.240]  является ли она аксиомой. Что для этого нужно сделать? Нужно сделать разбор формулы и посмотреть,
[01:17:30.240 --> 01:17:37.240]  что верх дерева этого разбора совпадает с одной из этих схем. Ну скажем, с первой схемой аксиом,
[01:17:37.240 --> 01:17:45.320]  что у нас должно быть? Импликация. Вот тут какая-то формула А, а тут импликация, и тут вот тоже должна
[01:17:45.320 --> 01:17:52.360]  быть та же самая формула А. То есть мы должны найти вот такую часть в дереве разбора. Я буквально
[01:17:52.360 --> 01:17:59.080]  на две минуты вас задержу. И убедиться, что вот эта подформула равна вот этой. Если это так,
[01:17:59.080 --> 01:18:05.520]  то эта формула удовлетворяет первой схеме аксиом. И это эффективно проделать, потому что разбор
[01:18:05.520 --> 01:18:10.800]  делается эффективно. Проверять, что две подформулы равны тоже эффективно. То же самое с ними со всеми,
[01:18:10.800 --> 01:18:16.560]  но если вообще любые конечные схемы аксиома написаны, их конечно можно вот так вот разобрать.
[01:18:16.560 --> 01:18:23.720]  Ну и наконец правило вывода. Все равно придется наверное повторять в следующий раз, но я постараюсь
[01:18:23.720 --> 01:18:30.800]  покороче это повторить. Мне все равно придется давать определение формальное. Для этого придется
[01:18:30.800 --> 01:18:36.000]  все выписать. Ну давайте правила вывода хотя бы напишу. У нас будет единственное, это modus ponens.
[01:18:36.000 --> 01:18:43.440]  Если есть формула А и формула из A следует B, мы можем вывести формулу B. Это такой стандартный
[01:18:43.440 --> 01:18:48.640]  рутинный шах математического утверждения. У нас есть лемма, что если A, то B. Мы доказали,
[01:18:48.640 --> 01:18:55.480]  что A верно, значит мы можем заключить, что B верно. Вот это единственное, чем это нравится
[01:18:55.480 --> 01:19:01.920]  логикам, что это такой естественный, понятный шах. Вот так мы рассуждаем математики. Ну и вот мы
[01:19:01.920 --> 01:19:10.040]  хотим это повторять. Ну ладно, тогда на сегодня все. Все остальное в следующий раз.
