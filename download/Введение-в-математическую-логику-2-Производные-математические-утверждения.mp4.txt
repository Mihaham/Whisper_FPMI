[00:00.000 --> 00:09.600]  В прошлый раз я замялся, потому что не уточнил, какой
[00:09.600 --> 00:12.160]  по новому курсу будет форма отчетности.
[00:12.160 --> 00:15.360]  Форма отчетности – дифференцированный зачет, зачет с оценкой.
[00:15.360 --> 00:18.720]  Поэтому программа курса, она в общем-то объявлена,
[00:18.720 --> 00:21.640]  ее можно скачать на сайте кафедры и собственно оценку
[00:21.640 --> 00:24.660]  вам будут ставить преподаватели семинаров, то есть они я
[00:24.660 --> 00:27.880]  думаю вам объяснят, что и как делать, я в своей группе
[00:27.880 --> 00:33.320]  объяснил, ну и в общем, вот так.
[00:33.320 --> 00:38.880]  Это единственное мое организационное объявление, простое и можно
[00:38.880 --> 00:45.880]  переходить к сути.
[00:45.880 --> 00:49.720]  Прошлый раз я напомню, я остановился на том, что
[00:49.720 --> 00:53.520]  определил способ описания буллевых функций.
[00:53.520 --> 00:56.240]  Простейший способ – это таблицы значений задать, но есть
[00:56.240 --> 00:58.200]  более сложный способ – формулы.
[00:58.200 --> 01:01.560]  И формулы у нас появились в двух разных видах.
[01:01.560 --> 01:09.320]  Во-первых, я говорил, что формула – это такое бинарное
[01:09.320 --> 01:19.680]  дерево, корневое, у которого есть в листьях написаны
[01:19.680 --> 01:22.520]  имена переменных, а в каждом внутреннем узле написана
[01:22.520 --> 01:23.520]  связка.
[01:23.720 --> 01:26.320]  Соответственно, оно бинарное, потому что у нас только
[01:26.320 --> 01:27.320]  бинарные связки.
[01:27.320 --> 01:30.840]  Ну и по дереву очень легко определить, как вычисляется
[01:30.840 --> 01:34.040]  значение формулы, когда заданы значения переменных.
[01:34.040 --> 01:36.280]  Это я в прошлый раз делал, сейчас не буду повторять,
[01:36.280 --> 01:39.400]  но это я думаю, процедура достаточно очевидна и все
[01:39.400 --> 01:40.400]  ее запомнили.
[01:40.400 --> 01:45.320]  Но был второй способ, я сказал, что это определение
[01:45.320 --> 01:48.080]  логиком кажется недостаточно строгим и надо много чего
[01:48.080 --> 01:51.080]  математического определять, чтобы это было аккуратно.
[01:51.160 --> 01:54.640]  Поэтому есть другое определение, это значит слова в алфавите.
[01:59.640 --> 02:04.520]  Ну алфавит я напишу так, это символы переменных,
[02:04.520 --> 02:11.280]  это символы для связок, что нам еще нужно и скобки
[02:11.280 --> 02:12.280]  нам нужны.
[02:12.280 --> 02:16.360]  Здесь, по крайней мере, нет запятых и немножко легче
[02:16.360 --> 02:19.440]  хотя бы через запятую можно перечислить и так взять
[02:19.440 --> 02:20.960]  даже фигурные скобки.
[02:20.960 --> 02:24.560]  Это вот алфавит, давайте его как-нибудь sigma обозначу.
[02:24.560 --> 02:31.040]  Алфавит, в котором мы строим слова-формулы, а определение
[02:31.040 --> 02:34.360]  формулы индуктивное, значит слова длины 1, которые состоят
[02:34.360 --> 02:39.360]  из переменных, это формулы.
[02:39.360 --> 02:48.840]  Соответственно если, там не знаю, B и C формулы, то
[02:49.000 --> 02:52.920]  тут два случая надо рассмотреть, вот такое слово, которое
[02:52.920 --> 02:56.160]  начинается с открывающей скобки, дальше отрицание
[02:56.160 --> 03:01.840]  формулы и закрывающая скобка формула и соответственно
[03:01.840 --> 03:06.040]  то же самое, но только с бинарной связкой.
[03:06.040 --> 03:13.520]  Значит вот этот кружочек, это любая бинарная связка.
[03:13.520 --> 03:22.320]  Что у нас там еще было, эквивалентность.
[03:22.320 --> 03:29.440]  Получаем два разных определения, на самом деле это одно и
[03:29.440 --> 03:32.760]  то же определение, это определение равносильное, очень легко
[03:32.760 --> 03:36.960]  понять как по дереву писать формулу, потому что смотрите,
[03:36.960 --> 03:40.520]  вот у меня связка, вот я теперь смотрю на левую
[03:40.520 --> 03:43.960]  подформулу, пишу ее здесь и на правую подформулу
[03:43.960 --> 03:44.960]  пишу здесь.
[03:44.960 --> 03:48.040]  Здесь вообще писать нечего, а здесь конечно надо еще
[03:48.040 --> 03:53.560]  потрудиться, потому что будет связка, будет вот эта
[03:53.560 --> 03:56.440]  вот формула, а здесь нужно еще вот так вот написать.
[03:56.440 --> 04:07.320]  То есть вот получается формула, совершенно естественное
[04:07.320 --> 04:09.600]  построение по дереву формулы.
[04:09.680 --> 04:12.280]  В обратную сторону тоже вроде бы все очень естественно,
[04:12.280 --> 04:14.040]  но возникает проблема.
[04:14.040 --> 04:20.800]  Почему, если я имею слово, которое является формулой,
[04:20.800 --> 04:22.720]  почему дерево получится однозначным?
[04:22.720 --> 04:26.240]  В случае обратного преобразования вроде бы все очевидно, потому
[04:26.240 --> 04:29.560]  что вот то, что я написал, это вот, ну тоже можно сказать,
[04:29.560 --> 04:32.360]  а вдруг мы как-то можем по-другому сопоставить, но это я задал
[04:32.360 --> 04:33.360]  сопоставление.
[04:33.360 --> 04:37.480]  А здесь, если задавать сопоставление, мы должны сказать, вот давайте
[04:37.600 --> 04:41.080]  посмотрим, к какому из трех типов принадлежит формула,
[04:41.080 --> 04:43.560]  этому, этому или этому, и построим соответствующий
[04:43.560 --> 04:46.840]  корень дерева, и дальше будем рекурсивно продолжать
[04:46.840 --> 04:50.400]  в левом и правом потомке, ну или в одном потомке, если
[04:50.400 --> 04:55.720]  бинарная связка, но проблема в том, что для этого нужно
[04:55.720 --> 05:01.240]  быть уверенным, что формуле можно однозначно указать
[05:01.240 --> 05:04.000]  самую последнюю применяемую связку.
[05:04.000 --> 05:06.840]  Вообще говоря это не очевидно, может быть иначе.
[05:06.840 --> 05:11.520]  Это утверждение, оно называется однозначность дерева разбора.
[05:11.520 --> 05:15.960]  Формально у нас будет такая терминология, вот слова
[05:15.960 --> 05:19.720]  это все-таки вот такое, а деревья будут называться
[05:19.720 --> 05:20.720]  деревьями разбора.
[05:20.720 --> 05:34.960]  И вот первая вещь, которую я сейчас хочу доказать,
[05:34.960 --> 05:39.720]  это однозначность дерева разбора для формулы.
[05:39.720 --> 05:42.360]  Рассуждение не сложное, но оно очень поучительное,
[05:42.360 --> 05:45.440]  и к тому же выяснилось, я надеялся, что какие-то
[05:45.440 --> 05:48.200]  остатки контекстно-свободных языков в курсе алгоритмов
[05:48.200 --> 05:51.360]  параллельно останутся, но нет, выяснилось, что там
[05:51.360 --> 05:53.880]  все строго, там будут у вас регулярные языки, а потом
[05:53.880 --> 05:59.520]  сразу уже такие универсальные модели вычислений, разрешимые
[06:00.120 --> 06:01.400]  и так далее.
[06:01.400 --> 06:07.360]  Поэтому контекстно-свободных языков не будет, а на самом
[06:07.360 --> 06:11.400]  деле вот это вот это, при некоторых уточениях, которые
[06:11.400 --> 06:14.440]  я чуть позже сделаю, это типичный пример контекстно-свободного
[06:14.440 --> 06:15.440]  языка.
[06:15.440 --> 06:17.840]  Ну что это такое, я объяснять конечно не буду, это слишком
[06:17.840 --> 06:21.840]  долго, но нам нужны будут конкретно вот такие вот
[06:21.840 --> 06:22.840]  формулы.
[06:22.840 --> 06:25.880]  Будут немножко более сложные формулы, у них тоже будут
[06:25.880 --> 06:28.760]  деревья разбора, то есть вот такое определение, что
[06:28.800 --> 06:31.560]  в нем типично для логики, что вот оно так рекурсивно
[06:31.560 --> 06:37.000]  и скобки позволяют нам определять структуру, что применяется
[06:37.000 --> 06:38.560]  в начале, что применяется потом.
[06:38.560 --> 06:42.200]  И доказательства, которые я расскажу, я не буду уже
[06:42.200 --> 06:44.640]  повторять для более сложных формул, потому что в сущности
[06:44.640 --> 06:49.640]  такой же, там только меняются специальные знаки, которыми
[06:49.640 --> 06:51.800]  помечены вершины дерева.
[06:51.800 --> 06:54.840]  А сама структура дерева, она определяется скобками.
[06:54.840 --> 07:02.600]  И тут полезно доказать лему, достаточно очевидную,
[07:02.600 --> 07:17.040]  что если у нас есть формула, то количество открывающих
[07:17.040 --> 07:25.200]  скобок равняется количеству закрывающих скобок, ну
[07:25.200 --> 07:26.200]  в этой формуле, естественно.
[07:26.200 --> 07:33.400]  Это более-менее очевидное из определения, но давайте
[07:33.400 --> 07:35.320]  посмотрим, как это доказывается, потому что доказательства
[07:35.320 --> 07:37.400]  тоже очень получительные, у меня будет много доказательств
[07:37.400 --> 07:38.400]  такого же типа.
[07:38.400 --> 07:41.200]  Доказательства фактически индукции по длине формулы.
[07:41.200 --> 07:44.600]  Длина формулы – это количество символов в ней.
[07:44.600 --> 07:49.840]  База индукции, естественно, длина 1, переменная, для
[07:49.840 --> 07:54.160]  переменных эта лемма выполняется, там 0 открывающих, 0 закрывающих.
[07:54.160 --> 07:56.200]  А теперь шах индукции.
[07:56.200 --> 07:59.160]  И шах индукции он состоит в том, что если формула
[07:59.160 --> 08:02.800]  имеет длину больше 1, то должны выполняться вот эти
[08:02.800 --> 08:04.640]  вот два случая.
[08:04.640 --> 08:08.680]  Я базу вообще на доске писать не буду для экономии времени,
[08:08.680 --> 08:12.320]  а шах индукции, он распадается на два случая.
[08:12.320 --> 08:18.480]  И имеет вид отрицания, и тогда, смотрите, опять-таки
[08:18.480 --> 08:19.760]  писать нечего.
[08:19.760 --> 08:22.280]  По индуктивному предположению в Б количество открывающих
[08:22.280 --> 08:26.440]  и закрывающих скобок одинаково, ну и мы добавили по одной
[08:26.440 --> 08:29.320]  такого и такого типа, доказано.
[08:29.320 --> 08:34.880]  Теперь второй случай, когда бинарная связка.
[08:34.880 --> 08:39.440]  Ну здесь то же самое, в левой подформуле одинаковое
[08:39.440 --> 08:41.640]  количество открывающих и закрывающих, по индуктивному
[08:41.640 --> 08:43.560]  предположению и в правой.
[08:43.560 --> 08:46.040]  Доказательство такой полной индукции, то есть мы считаем,
[08:46.040 --> 08:49.880]  что для всех меньших длин наше утверждение справедливо.
[08:49.880 --> 08:52.640]  Ну мы добавили по одной открывающей и закрывающей.
[08:52.640 --> 08:54.880]  Рассуждение настолько простое, что его можно было
[08:54.880 --> 08:58.080]  бы очень быстро сказать, словами вообще ничего не
[08:58.080 --> 08:59.080]  записывая.
[08:59.080 --> 09:03.000]  Я хочу подчеркнуть, что оно типично и я буду ссылаться
[09:03.000 --> 09:06.480]  на рассуждение такого типа, как индукция по разбору
[09:06.480 --> 09:07.480]  формулы.
[09:07.480 --> 09:10.360]  То есть вот индукция по разбору формулы, фактически
[09:10.360 --> 09:12.880]  полная индукция по длине формулы, а устроена она
[09:12.880 --> 09:13.880]  так.
[09:13.880 --> 09:15.440]  Мы проверяем для самых простых формул, в данном
[09:15.440 --> 09:17.520]  случае это просто переменные.
[09:17.520 --> 09:20.520]  В каких-то рассуждениях это может быть даже и сложнее.
[09:20.520 --> 09:24.760]  А потом мы зная из определения, которое здесь такое, а в каких-то
[09:24.760 --> 09:28.000]  случаях будет немножко другим, мы рассматриваем возможные
[09:28.000 --> 09:30.280]  случаи, как вот эта формула может быть устроена, ну
[09:30.280 --> 09:33.640]  и доказываем утверждение в одном и в другом случае.
[09:33.640 --> 09:38.280]  То есть это будет типичное для нас рассуждение.
[09:38.280 --> 09:41.000]  И теперь, наконец, вот эта теорема об однозначности
[09:41.000 --> 09:42.000]  разбора.
[09:42.000 --> 09:48.520]  Сейчас я ее докажу, значит она… Для ее доказательства
[09:48.520 --> 09:52.360]  мне понадобится еще одно понятие – скобочный итог.
[09:52.360 --> 10:00.600]  Вот давайте вот это, я так нарисую формулу, выберу
[10:00.600 --> 10:03.240]  какое-то место в ней между символами.
[10:03.240 --> 10:08.440]  В комбинатуре кислов очень часто удобно указывать
[10:08.440 --> 10:12.680]  не символ в слове, а положение между символами.
[10:12.680 --> 10:15.400]  Тогда у нас, во-первых, возникает начальная позиция, конечная
[10:15.400 --> 10:19.800]  позиция, ну и вот позиции между этими.
[10:19.800 --> 10:24.320]  И вот скобочный итог, он по определению равен числу
[10:24.320 --> 10:27.200]  открывающих скобок минус число закрывающих скобок.
[10:27.200 --> 10:28.200]  Вот до этого места.
[10:28.200 --> 10:36.000]  То есть мы дошли до какого-то места, прочитали уже сколько-то
[10:36.000 --> 10:40.880]  символов и считаем разность открывающих и закрывающих
[10:40.880 --> 10:41.880]  скобок.
[10:41.880 --> 10:44.120]  Но тут вот, поскольку скобки мы без того используем в
[10:44.120 --> 10:46.760]  формулах, давайте под индексах что ли напишу, чтобы было
[10:46.760 --> 10:48.400]  ясно, что я ничего в скобки не беру.
[10:48.400 --> 10:53.120]  Мне просто на словах я сказал, ну а записывать все эти слова
[10:53.120 --> 10:56.640]  на доске места немного мне не хочется.
[10:57.560 --> 11:00.480]  Так вот, что верно?
[11:00.480 --> 11:01.480]  Однозначность разбора.
[11:01.480 --> 11:21.200]  В каждой формуле скобочный итог перед любым символом
[11:21.200 --> 11:31.680]  Давайте я напишу короче любой связкой.
[11:31.680 --> 11:35.480]  Я имею в виду символ связки, но просто чтобы писать
[11:35.480 --> 11:38.400]  короче положительный.
[11:38.400 --> 11:57.960]  И если есть связки, то ровно у одной скобочный итог равен
[11:57.960 --> 11:58.960]  плюс один.
[11:58.960 --> 12:02.000]  Вот это и дает нам способ определить самую внешнюю
[12:02.000 --> 12:04.280]  связку, это и будет самая внешняя связка.
[12:04.280 --> 12:07.600]  Дальше доказательства однозначности разбора такое, если формула
[12:07.680 --> 12:11.680]  длины 1, то дерево однозначно строится, потому что у него
[12:11.680 --> 12:15.280]  все одна вершина, а во всех остальных случаях мы применяем
[12:15.280 --> 12:20.280]  определение, но такой же разбор по построению формулы
[12:20.280 --> 12:24.200]  мы находим самую внешнюю связку, она находится однозначно,
[12:24.200 --> 12:27.640]  потому что это вот и есть та связка, у которой скобочный
[12:27.640 --> 12:28.640]  итог 1.
[12:28.640 --> 12:30.880]  Ну давайте в эту сторону посмотрим, ясно, что здесь
[12:30.880 --> 12:33.280]  скобочный итог 1, потому что перед этим только одна
[12:33.280 --> 12:34.920]  открывающая.
[12:35.000 --> 12:39.760]  Здесь может быть чуть менее ясно, но смотрите, здесь
[12:39.760 --> 12:43.600]  уже одна открывающая скобка появилась, дальше внутри
[12:43.600 --> 12:47.640]  формулы B они будут прибавляться и убавляться, но они никогда
[12:47.640 --> 12:50.320]  не станут, по предположению индукции, там никогда не
[12:50.320 --> 12:51.320]  будет отрицательного.
[12:51.320 --> 12:57.840]  И когда мы дойдем до конца, у нас вот на этой вот связке,
[12:57.840 --> 13:00.240]  на всех внутренних связках скобочный итог будет больше
[13:00.240 --> 13:03.280]  единицы, потому что если верно индуктивное предположение,
[13:03.360 --> 13:06.440]  что вот эта единичка добавилась, и тут еще будет какая-то
[13:06.440 --> 13:09.400]  единичка по индуктивным предположениям, значит единственный
[13:09.400 --> 13:13.280]  случай, когда у нас возможно, это вот когда появляется
[13:13.280 --> 13:14.280]  связка.
[13:14.280 --> 13:18.680]  Поскольку вот это свойство, оно не связано с самим построением
[13:18.680 --> 13:22.000]  формулы, с разбиением на подформулы, то мы и получим
[13:22.000 --> 13:25.080]  то, что нам нужно, у нас внешняя связка предназначена.
[13:25.080 --> 13:28.520]  Ну осталось вот это доказательство, на самом деле половину доказательства
[13:28.520 --> 13:31.720]  я уже сказал, пока вот объяснял, что я хочу потом однозначно
[13:31.720 --> 13:32.720]  с разбором выводить.
[13:32.720 --> 13:36.680]  Потому что, смотрите, доказываю это утверждение опять-таки
[13:36.680 --> 13:37.680]  разбором.
[13:37.680 --> 13:40.000]  Ну вот я сейчас повторю то, что я говорил, но уже
[13:40.000 --> 13:41.640]  ровно про это рассуждение.
[13:41.640 --> 13:47.080]  База понятная, там скобок нет, все выполняется, связок
[13:47.080 --> 13:48.440]  нет, все выполняется.
[13:48.440 --> 13:54.120]  Теперь шаг индукции, предположим, у нас есть какая-то формула,
[13:54.120 --> 13:57.800]  если она имеет вид вот такой представлено, то мы знаем,
[13:58.400 --> 14:02.120]  что у этого символа связки скобочный итог один, а дальше
[14:02.120 --> 14:06.320]  для всех символов связки внутри подформулы B скобочный
[14:06.320 --> 14:08.040]  итог будет уже положительный.
[14:08.040 --> 14:12.160]  Больше единицы, извините, потому что по предположению
[14:12.160 --> 14:15.440]  индукции он положительный, но у нас еще добавилась
[14:15.440 --> 14:18.800]  вот эта единичка, и она, когда мы смотрим на позиции
[14:18.800 --> 14:21.640]  внутри подформулы B, эта единичка дает нам увеличение
[14:21.640 --> 14:24.720]  на один, значит плюс один уже никак не будет, будет
[14:24.720 --> 14:25.720]  больше.
[14:25.960 --> 14:29.320]  Ну и все, а потом, конечно, скобочный итог станет равным
[14:29.320 --> 14:31.240]  нулю, когда мы прочитаем последнюю скобку.
[14:31.240 --> 14:32.600]  И здесь такое же рассуждение.
[14:32.600 --> 14:37.800]  Единственное, что теперь у нас нет вот этой вот связки,
[14:37.800 --> 14:42.280]  мы начинаем читать открывающую скобку, потом подформулу,
[14:42.280 --> 14:45.160]  когда мы читаем подформулу, там скобочный итог каждой
[14:45.160 --> 14:48.120]  связки будет положительный, и на самом деле больше единицы,
[14:48.120 --> 14:51.160]  потому что у нас уже единицы еще есть.
[14:51.160 --> 14:54.000]  Только когда эта формула будет полностью прочитана,
[14:54.000 --> 14:57.160]  скобочный итог равен нулю, значит, поэтому скобочный
[14:57.160 --> 14:59.520]  итог вот этой связки будет ровно плюс один.
[14:59.520 --> 15:03.600]  Вот эта вот скобочка, она останется, она же не входит
[15:03.600 --> 15:06.240]  под счет скобок внутри формулы B, поэтому она даст
[15:06.240 --> 15:07.240]  плюс один.
[15:07.240 --> 15:11.120]  Ну вот, в общем-то, и все, и все доказано, то есть я
[15:11.120 --> 15:13.400]  не так мало времени потратил, но мне хотелось, чтобы это
[15:13.400 --> 15:14.400]  было ясно.
[15:14.400 --> 15:17.480]  Я потрачу даже еще чуть больше времени, потому что я хочу
[15:17.480 --> 15:23.360]  сказать, сделать замечание, что это не просто теорема,
[15:23.360 --> 15:24.960]  она дает эффективный алгоритм.
[15:24.960 --> 15:28.600]  То есть если у вас есть слово, которое задает формулу,
[15:28.600 --> 15:32.480]  вы можете действовать таким способом, эффективно найти
[15:32.480 --> 15:36.240]  внешнюю связку и начать строить дерево рекурсивно.
[15:36.240 --> 15:40.880]  Нашли внешнюю связку, это корень дерева, потом рекурсивно
[15:40.880 --> 15:43.400]  вызывает алгоритм разбора на левой подформуле и на
[15:43.400 --> 15:46.280]  правой подформуле, получается там два под дерево, ну или
[15:46.280 --> 15:48.520]  одно, если связка лонарная.
[15:48.520 --> 15:50.640]  Тут только нужно говорить вот что, смотрите, у нас
[15:50.680 --> 15:55.080]  алфавит, у нас алфавит бесконечный.
[15:55.080 --> 15:59.020]  И это для алгоритмов не очень хорошо, потому что
[15:59.020 --> 16:01.920]  мне очень понятно, как на вход алгоритму компьютеру
[16:01.920 --> 16:03.780]  подать символ бесконечного алфавита.
[16:03.780 --> 16:10.320]  Ну нет у нас компьютеров, которые могут читать символы
[16:10.320 --> 16:12.060]  из бесконечного алфавита.
[16:12.060 --> 16:14.880]  Ну эта проблема решается понятно, как бесконечный
[16:14.880 --> 16:17.220]  алфавит надо кодировать в конечном, а потом в конечном
[16:17.220 --> 16:20.340]  счёте в унарном. Конечный алфавит, который я буду
[16:20.340 --> 16:23.340]  всегда подразумевать в таких случаях, он такой.
[16:23.340 --> 16:26.260]  Вот эти символы переменной заменяются на символы
[16:26.260 --> 16:29.820]  решётка 0, 1. Дальше всё то же самое, там меняться
[16:29.820 --> 16:34.100]  вообще ничего не будет. И когда у меня есть символ
[16:34.100 --> 16:43.100]  x этой формули, он будет меняться на вот такое слово, значит,
[16:43.100 --> 16:48.980]  а потом двоичная запись индекса и. Понятно, что если
[16:48.980 --> 16:52.100]  я сделаю такие замены, они обратимы. Когда я буду
[16:52.100 --> 16:54.980]  читать соответствующее слово, если я вижу решётку,
[16:54.980 --> 16:58.820]  мне надо дочитать все 0, 1, которые после решётки
[16:58.820 --> 17:02.220]  стоят до любого следующего символа, отличного от 0,
[17:02.220 --> 17:06.620]  1, и превратить эту запись в число и я буду знать,
[17:06.620 --> 17:12.020]  что там написано переменная x. То есть это вполне такой
[17:12.020 --> 17:14.780]  конструктивный, эффективный способ кодирования формул.
[17:14.780 --> 17:17.620]  Ну а чтобы закодировать двоичного алфавита, ну там
[17:17.620 --> 17:22.020]  можно любой конечный алфавит, можно всегда то, что называется
[17:22.020 --> 17:28.420]  блочное кодирование. Давайте вот я тут sigma f тогда напишу.
[17:28.420 --> 17:31.180]  Выбрать достаточно большое k, ну чтобы 2 степени k было
[17:31.180 --> 17:35.900]  больше размера алфавита, и кодировать как-то, построить
[17:35.900 --> 17:38.060]  то, что называется инъекция. То есть для каждого символа
[17:38.060 --> 17:41.500]  алфавита выбрать ровно одно слово длины k.
[17:41.500 --> 17:48.620]  У решётки смысл такой, что он указывает, что это
[17:48.620 --> 17:52.140]  начинается описание переменной. У нас переменных бесконечно
[17:52.140 --> 17:54.860]  много, мы должны как-то в конечном алфавите это
[17:54.860 --> 17:57.900]  бесконечное множество задавать. Ну это такой простой способ,
[17:57.900 --> 18:00.580]  решётка как указатель, что в этом месте стоит переменная,
[18:00.580 --> 18:03.380]  а какая переменная дальше записана двоичной записью.
[18:03.380 --> 18:08.140]  Ну у нас будут более сложные случаи, когда такие переменные
[18:08.140 --> 18:10.980]  могут иметь два индекса, ну я думаю понятно, что нужно
[18:10.980 --> 18:13.780]  сделать. Нужно поставить одну решётку, первое число,
[18:13.780 --> 18:18.620]  второе, второе число. Думаю, что вам понятно, что такие
[18:18.620 --> 18:21.380]  не сложные проблемы с кодировками решаются. Я буду немножко
[18:21.380 --> 18:25.740]  уточнять, но основная идея дальше, я сейчас потратил
[18:25.740 --> 18:28.940]  довольно много времени, а потом я буду уже достаточно
[18:28.940 --> 18:31.600]  быстро объяснять, как именно мы кодируем какие-то более
[18:31.600 --> 18:34.760]  сложные формулы, потому что идея, она будет той же
[18:34.760 --> 18:37.720]  самой. То есть в конечном счёте мы всё можем закодировать
[18:37.720 --> 18:41.020]  двоичные слова, ну и понятно, что вот этот алгоритм будет
[18:41.020 --> 18:45.760]  работать эффективно, потому что, смотрите, ну читать
[18:45.760 --> 18:48.920]  блоки по k, где k константа, это вообще не проблема, это
[18:48.920 --> 18:51.080]  эффективное действие. Вы прочитали, дальше просто
[18:51.080 --> 18:54.240]  написали разбор случаев, что вы видите на этом месте.
[18:54.240 --> 18:57.520]  То есть можно считать, что ваша программа читает
[18:57.520 --> 19:00.240]  сразу символы из этого конечного алфавита. Ну и
[19:00.240 --> 19:06.920]  дальше, что нужно делать, надо прочитать, следить за
[19:06.920 --> 19:09.240]  скобочным итогом, то есть вы двигаетесь по слову и
[19:09.240 --> 19:12.560]  каждый раз считаете, вы дошли до символа связки, какой
[19:12.560 --> 19:14.480]  в этот момент скобочный итог. Как только он стал
[19:14.480 --> 19:18.040]  равен плюс один, отлично, вы знаете, что у вас слева
[19:18.040 --> 19:21.680]  должна быть подформула, справа должна быть подформула.
[19:21.680 --> 19:24.680]  Применяете рекурсивный алгоритм к построению дерева.
[19:24.680 --> 19:27.920]  Если вам нужно вычислять потом значения, то это вот
[19:27.920 --> 19:30.240]  как я объяснял, если у вас еще есть набор значений
[19:30.240 --> 19:32.920]  для переменных, вы потом на этот набор смотрите и
[19:32.920 --> 19:35.600]  наоборот двигаясь от листьев к корню вычисляете значение
[19:35.600 --> 19:39.840]  формулы. Ясно, что это эффективно, ну по крайней мере в этом
[19:39.840 --> 19:42.040]  случае для более сложных формул это уже вопрос не
[19:42.040 --> 19:44.560]  столь простой, но здесь это эффективно, то есть это
[19:44.560 --> 19:48.320]  дает нам эффективный алгоритм и разбора и вычисления значения
[19:48.320 --> 19:54.240]  формул. Хорошо, давайте продвинемся
[19:54.240 --> 19:57.720]  чуть дальше про формулы. Это еще не все, что я хотел
[19:57.720 --> 20:04.760]  сказать про формулы. У нас в результате сейчас есть
[20:04.760 --> 20:08.320]  два языка описания булевых функций, один таблицами значений,
[20:08.320 --> 20:12.440]  другой формулами. Чем удобнее формулы, как я говорил уже
[20:12.440 --> 20:14.820]  в прошлый раз, они удобны тем, что позволяют компактно
[20:14.820 --> 20:18.240]  задавать функцию. Задание таблицами значений требует
[20:18.240 --> 20:20.560]  всегда указания два в степени n, то есть строка длины два
[20:21.560 --> 20:24.720]  из битов вам нужна как в любом случае. А формула
[20:24.720 --> 20:31.160]  может быть гораздо короче. Там не требуется перечислять
[20:31.160 --> 20:33.920]  все возможные значения переменных, а вот это вот
[20:33.920 --> 20:36.680]  дерево, которое разбора формулы, оно дает просто
[20:36.680 --> 20:39.360]  рецепт как вычислять значения, он может быть намного короче.
[20:39.360 --> 20:46.240]  Но это плюс, но есть минус. Таблица значений функции
[20:46.240 --> 20:51.400]  определяет однозначно. А формула нет. Сейчас появятся
[20:51.400 --> 20:55.140]  примеры, но я думаю вам и так это понятно. Потому
[20:55.140 --> 20:58.040]  что для связок выполняются разные итогиства. Понятно,
[20:58.040 --> 21:00.280]  что если вы используете итогиства, у вас получится
[21:00.280 --> 21:03.080]  равносильная формула, которая имеет те же самые значения.
[21:03.080 --> 21:08.800]  И уже нетривиальным становится вопрос о том, какие формулы
[21:08.800 --> 21:11.440]  представляют очень простые функции. На самом деле самую
[21:11.440 --> 21:15.360]  простую. Самая простая функция тождественно равна единице.
[21:15.360 --> 21:27.040]  Что? Сейчас я скажу. Нулю тоже можно, но так вот получилось.
[21:27.040 --> 21:31.600]  Я объясню почему единица. Давайте я напишу определение.
[21:31.600 --> 21:34.840]  Это правильно. Но 0 и 1 не очень сильно различаются,
[21:34.840 --> 21:38.000]  я сейчас скажу. Просто для нуля нам будет удобнее немножко
[21:38.000 --> 21:44.900]  другое понятие сейчас. Формула Тавтология, если она принимает
[21:44.900 --> 21:51.060]  значение 1 для всех x. То есть задает просто тождественно
[21:51.060 --> 21:56.580]  равную единице функцию. И Тавтологии очень много.
[21:56.580 --> 22:00.000]  Давайте я сразу приведу пару примеров, потом мы их немножко
[22:00.000 --> 22:12.200]  будем обсуждать. Вот, например, x или не x. Или
[22:12.200 --> 22:20.060]  x и из x следует y и из всего этого следует y. Вот примеры
[22:20.060 --> 22:23.300]  Тавтологии можете проверить. Как проверять я обслужу
[22:23.300 --> 22:29.120]  чуть позже. Значит, и родственное понятие, вот возвращаясь
[22:29.120 --> 22:43.600]  к нулю. Такое, phi выполнимое, если phi от x равно единице
[22:43.600 --> 22:54.160]  хотя бы для одного x. Почему так? Я напомню, что в прошлый
[22:54.160 --> 22:57.920]  раз мы уже обсуждали смысл нуля и единицы в логике.
[22:58.040 --> 23:01.760]  Единицы мы кодируем истину, а нулем ложь. Тавтология
[23:01.760 --> 23:05.360]  это не случайно называется Тавтология. Это то, что верно
[23:05.360 --> 23:09.560]  всегда, какие бы вы не подставили логические значения вместо
[23:09.560 --> 23:12.480]  переменных, у вас все равно получится истина. И есть
[23:12.480 --> 23:15.280]  такой основной смысл слова Тавтология, он в обыденном
[23:15.280 --> 23:18.520]  языке носит скорее отрицательный характер, а для логики это
[23:18.520 --> 23:22.920]  наоборот очень важное позитивное понятие. Но часто нам бывает
[23:22.920 --> 23:25.960]  нужно другое, выполнимое. Вот у нас есть какие-то
[23:25.960 --> 23:29.400]  логические условия, мы хотим проверить, можно ли их выполнить.
[23:29.400 --> 23:33.320]  Тогда нас интересует другое, как приписать логические
[23:33.320 --> 23:37.200]  значения переменным, чтобы получилась наша формула равная
[23:37.200 --> 23:40.840]  единице. Например, формула задает условия, там какая-то
[23:40.840 --> 23:44.040]  сложная промышленная установка взрывается, есть ли то-то, то-то,
[23:44.040 --> 23:48.040]  то-то и то-то. И это практически важный вопрос, есть ли набор
[23:48.040 --> 23:50.640]  значений в оливах переменных, при которых установка может
[23:50.640 --> 23:53.520]  взрываться. Потому что если есть, надо как-то специально
[23:53.600 --> 23:57.760]  их отслеживать по мере того, что параметры приближаются
[23:57.760 --> 24:00.080]  к этим опасным значениям, что-то все-таки предпринимать
[24:00.080 --> 24:03.920]  до взрыва, а не после. Ну, это такой простой пример.
[24:03.920 --> 24:07.680]  Ну, в общем-то, я думаю, понятно, что это тоже с точки
[24:07.680 --> 24:10.720]  зрения содержательной вроде бы полезная вещь. Теперь
[24:10.720 --> 24:14.400]  возвращаемся к разговору про тождественно равную
[24:14.400 --> 24:20.040]  нулю функцию. Ну, ее логики скорее назовут противоречием,
[24:20.040 --> 24:22.360]  потому что простейший пример такой функции – это
[24:22.360 --> 24:28.480]  х и не х. Ну, вот она всегда равна нулю, как нетрудно
[24:28.480 --> 24:35.720]  догадаться. И она вроде бы тоже не менее важна, но
[24:35.720 --> 24:38.360]  есть очень простая связь. Значит, смотрите, если фи
[24:38.360 --> 24:45.880]  тавтология, то это равносильно тому, что отрицание фи равно
[24:45.960 --> 24:51.120]  нулю для всех х. То есть, если вас интересует вопрос
[24:51.120 --> 24:55.800]  от автологичности, а вы умеете отвечать на вопрос
[24:55.800 --> 24:59.920]  о том, что функция тождественно равна нулю, ну, привесьте
[24:59.920 --> 25:03.520]  отрицание, и будет вам то, что нужно. И в обратную
[25:03.520 --> 25:06.680]  сторону, потому что отрицание, понятно, оно просто инвертирует
[25:06.680 --> 25:09.320]  бит, поэтому это вот переход в одну и в другую сторону.
[25:09.440 --> 25:13.440]  Ну и эти две связанные, связаны похожим образом. Фи тавтология.
[25:13.440 --> 25:19.240]  Значит, да, на самом деле, если равна нулю, это по
[25:19.240 --> 25:23.040]  сути дела, это как раз отрицание выполнимости. То есть, не
[25:23.040 --> 25:29.560]  фи от х невыполнимо. То есть, вот тут я перепишу это
[25:29.560 --> 25:34.760]  логически более важная вещь, что отрицание фи невыполнимо.
[25:34.760 --> 25:41.360]  Это очень простые преобразования формул. Навесить отрицание
[25:41.360 --> 25:47.160]  никогда несложно. И поэтому переход от вопросов к выполнимости
[25:47.160 --> 25:51.400]  и тавтологичности, но с точностью до замены, равносильно от
[25:51.400 --> 25:57.360]  тавтологичности невыполнимость. И, соответственно, не тавтологичность
[25:57.360 --> 26:01.960]  и выполнимость. Но сам переход простой, поэтому, вообще говоря,
[26:01.960 --> 26:04.720]  из всех этих понятий можно оставить одно. Логики оставляют
[26:04.720 --> 26:09.160]  тавтологии по очень важной причине. У связок, когда я
[26:09.160 --> 26:11.320]  их определял, я думаю, вам было понятно, может быть,
[26:11.320 --> 26:14.480]  я даже про это успел сказать. У связок есть простой логический
[26:14.480 --> 26:18.080]  смысл. Они отвечают за некоторые наши конструкции,
[26:18.080 --> 26:20.200]  которые мы делаем, как мы составляем составные
[26:20.200 --> 26:23.960]  высказывания. А тавтологии отвечают за законы логики.
[26:23.960 --> 26:27.320]  Вот левая тавтология. Что это такое? Х или не х? Это
[26:27.320 --> 26:29.600]  то, что логики называют закон исключенного третьего.
[26:30.520 --> 26:35.520]  Если у вас есть высказывания, то вы твердо уверены, что
[26:35.520 --> 26:39.640]  оно ложно или оно истинно. Поэтому выполняется тавтология.
[26:39.640 --> 26:42.000]  Не все логики с этим согласны, и математики некоторые
[26:42.000 --> 26:45.080]  считают, что нет такого логического закона, и там
[26:45.080 --> 26:48.160]  возникает своя логика, но ее мы обсудить, пожалуйста,
[26:48.160 --> 26:50.840]  вообще не успеем, но посмотрим, если и будем, то существенно
[26:50.840 --> 26:55.440]  позже. Сейчас у нас классическая логика, это выполняется.
[26:55.440 --> 27:00.320]  Вот это называется modus ponens. Ну, modus ponens формально
[27:00.320 --> 27:03.600]  будет у нас называться немножко другая вещь, когда мы дойдем
[27:03.600 --> 27:06.560]  до выводимости, но можно эту тавтологию называть
[27:06.560 --> 27:11.000]  modus ponens. Ее смысл тоже, содержательность совершенно понятен. Как
[27:11.000 --> 27:14.960]  устроена математика? Мы доказываем условные утверждения.
[27:14.960 --> 27:18.360]  Если х, то и у. А дальше мы берем какой-то запас утверждений,
[27:18.360 --> 27:19.960]  про которые мы говорим. Вот эти утверждения заведомо
[27:19.960 --> 27:23.080]  истиной. И из этих условных утверждений мы получаем
[27:23.080 --> 27:25.840]  истинность еще огромного количества других утверждений.
[27:25.840 --> 27:29.320]  Вот так с высоты птичьего полета выглядит математика.
[27:29.320 --> 27:32.560]  И в основе этого приема лежит как раз эта тавтология.
[27:32.560 --> 27:38.240]  Смотрите, если х истинна, то вот эта импликация упрощается
[27:38.240 --> 27:41.360]  до у, мы получаем, что из у следует у. Если х ложна,
[27:41.360 --> 27:44.840]  то вообще посылка ложная в импликации, импликация
[27:44.840 --> 27:47.840]  истина. То есть наше рассуждение основано на том, что если
[27:47.840 --> 27:51.880]  мы уже как-то получили х и из х следует у, мы можем
[27:52.040 --> 27:59.520]  смело сказать, что у тоже есть. Ну и примеров очень
[27:59.520 --> 28:02.920]  много. Я не буду приводить еще примеры. В общем-то их
[28:02.920 --> 28:07.560]  можно продолжать. Что-то, наверное, на семинарах будем
[28:07.560 --> 28:10.840]  разбирать. Потом, когда дойдем до выводимости, там появятся
[28:10.840 --> 28:16.520]  еще примеры. Но это, конечно, только частный случай
[28:16.520 --> 28:18.440]  логических законов. У меня все-таки цель как можно
[28:18.440 --> 28:21.800]  быстрее перейти к самым общим логическим законам.
[28:21.800 --> 28:24.680]  Объяснить, что такое закон математической логики.
[28:24.680 --> 28:28.240]  Не вообще любой логики, потому что люди изобрели
[28:28.240 --> 28:31.480]  много разных логик. Ну, как оситрина, вы знаете, бывает
[28:31.480 --> 28:34.480]  первой свежести, второй свежести, ну вот тут примерно
[28:34.480 --> 28:39.760]  так же. То есть есть логика, есть вот математическая
[28:39.760 --> 28:42.040]  логика, а дальше люди начинают фантазировать разные другие
[28:42.040 --> 28:44.880]  логики. При этом в математической логике изучают совершенно
[28:44.880 --> 28:48.200]  другие системы. Как я сказал, никто вам не гарантирует,
[28:48.200 --> 28:50.200]  что в статье по математической логике выполняется закон
[28:50.200 --> 28:52.800]  исключенного третьего. Наоборот, если там где-то
[28:52.800 --> 28:55.800]  в названии стоит интуционистская логика, вы можете смело
[28:55.800 --> 28:57.800]  знать, что там никакого исключенного третьего
[28:57.800 --> 29:04.800]  нет. Там игра идет по другим правилам. Ну вот, я к тому,
[29:04.800 --> 29:08.840]  что возникает теоретически важная задача. Какие вообще
[29:08.840 --> 29:11.520]  формулы являются тавтологиями? Какие у нас бывают законы
[29:11.520 --> 29:16.480]  логики хотя бы такого вида? Ну и учитывая связь с выполнимостью,
[29:16.480 --> 29:20.360]  это тоже естественно. Вот мы хотим узнать. Ну ладно,
[29:20.360 --> 29:24.760]  про взрыв это я для драматизма сказал. А типичная задача
[29:24.760 --> 29:27.520]  из индустрии такая. У вас есть описание микросхемы.
[29:27.520 --> 29:34.440]  Ну там миллион вентелей. Каждые вентели могут находиться
[29:34.440 --> 29:38.000]  в состоянии 0.1. И у вас получается формула из миллиона переменных,
[29:38.000 --> 29:40.560]  которая описывает, что собственно эта микросхема делает.
[29:40.560 --> 29:44.560]  Конкретно инженеры ее так будут паять. А вам нужно
[29:44.560 --> 29:48.880]  проверить, что эта микросхема вычисляет сложение чисел.
[29:48.880 --> 29:54.320]  Если на входы поданы два массива битов, то на выходе
[29:54.320 --> 29:58.600]  будет именно сумма их, если смотреть на это как на представление
[29:58.600 --> 30:01.520]  чисел. Ну или еще какую-то функцию. Потому что никто
[30:01.520 --> 30:05.480]  же не обещал, инженеры могут ошибаться. Они вот написали
[30:05.480 --> 30:08.120]  какие-то схемы. А что реально происходит? Ну из какого-то
[30:08.120 --> 30:10.520]  конечно здравого смысла. Но что реально происходит?
[30:10.520 --> 30:14.480]  Мало ли где-то человек ошибся. Поэтому возникает вопрос
[30:14.480 --> 30:17.080]  как проверить такую формулу. Саму формулу в результате,
[30:17.080 --> 30:19.960]  когда инженеры принесли свое описание, можно автоматически
[30:19.960 --> 30:22.600]  построить по этому описанию. Никакой проблемы нет. Она
[30:22.600 --> 30:28.320]  будет очень большой. На диск влезет. Миллион переменных.
[30:28.320 --> 30:31.280]  Но формула будет 100 миллионов. Ну поместится. Там небольшой
[30:31.280 --> 30:34.960]  файл получится. Ну надо проверить, выполнима она
[30:34.960 --> 30:38.640]  или нет. Ну или тавтологично это значит, что все условия
[30:38.640 --> 30:43.400]  выполнены и функция работает правильно. И как это делать?
[30:43.400 --> 30:46.960]  Ну один способ мы знаем. Можно используя определение
[30:46.960 --> 30:49.840]  выписать таблицу значений и проверить, что в ней встают
[30:49.840 --> 30:52.840]  только единички. И чем плохо этот способ совершенно
[30:52.840 --> 30:55.040]  понятно. Если у вас миллион переменных, два в миллионной
[30:55.040 --> 30:59.640]  вы уже не выпишете никогда. Ни в одном месте, ни просто
[30:59.640 --> 31:03.400]  у вас не будет времени столько. Есть второй способ, который
[31:03.400 --> 31:07.000]  я уже сейчас проиллюстрировал, вот когда я обсуждал почему
[31:07.000 --> 31:11.520]  вот этот тавтология. Частичный разбор. То есть мы берем
[31:11.520 --> 31:14.400]  какую-нибудь переменную и присваиваем ей два возможных
[31:14.400 --> 31:21.600]  значения. Скажем, беру переменную х. Она может равняться нулю,
[31:21.600 --> 31:25.160]  может равняться единице. Дальше формулу можно упростить.
[31:25.160 --> 31:28.280]  Если х равняется нулю, мы подставляем формулу, части
[31:28.280 --> 31:30.680]  формулы начинают упрощаться. Вот смотрите, если здесь
[31:30.680 --> 31:34.880]  ноль, то вообще вся эта конъюнкция ноль. И у нас получается
[31:34.880 --> 31:39.880]  формула из нуля следует игре. И тут опять-таки есть тождество
[31:39.880 --> 31:43.120]  упрощения. Мы знаем просто, что значение тут равно единице.
[31:43.120 --> 31:47.120]  Уже про у нам ничего знать не нужно. Ну а если единица
[31:47.120 --> 31:50.880]  получается чуть сложнее, но это тоже довольно простой
[31:50.880 --> 31:54.080]  случай. Его конечно придется здесь разбирать. То есть вот
[31:54.080 --> 32:02.480]  чтобы увидеть. Неравномерное дерево разбора. Ну вот оно
[32:02.480 --> 32:06.600]  какое-то такое. Из этого примера видно, что выбирая
[32:06.600 --> 32:08.760]  разные переменные, вообще говорю, у вас будет получаться
[32:08.760 --> 32:15.000]  разное частичное дерево разбора. Ну и нужно как-то
[32:15.000 --> 32:18.400]  говорить правила, как мы применяем упрощение.
[32:18.400 --> 32:20.840]  Это пока только голая идея, как устроим частичный
[32:20.840 --> 32:28.640]  перебор. Ну ее можно довести до конца, и она в принципе
[32:28.640 --> 32:33.240]  лучше, чем полный перебор, конечно, чем составление
[32:33.240 --> 32:38.320]  таблицы значений. Иногда лучше, иногда нет. И все равно
[32:38.320 --> 32:42.800]  обычно не очень хорошо. Позже мы узнаем очень хороший
[32:42.800 --> 32:48.280]  способ проверки тавтологичности, который основан как раз
[32:48.280 --> 32:52.120]  на логическом выводе. Точнее, особо хорош он в сочетании
[32:52.120 --> 32:56.920]  как раз частичным разбором. Это то, на чем основаны
[32:56.920 --> 33:00.320]  современные программы, из-за которых задача проверки
[33:00.320 --> 33:05.000]  тавтологичности формул, ну на самом деле скорее выполнимости,
[33:05.000 --> 33:09.880]  но считается не очень трудной. Считается, что для индустриальных
[33:09.880 --> 33:13.320]  приложений эти современные программы работают достаточно
[33:13.320 --> 33:19.960]  хорошо. Но я должен подчеркнуть, что это иллюзия. Эти программы
[33:19.960 --> 33:24.480]  они так устроены, что, ну, уже совсем сложные программы
[33:24.480 --> 33:27.480]  я не буду утверждать, что можно прям точно все доказать,
[33:27.480 --> 33:29.840]  но основной принцип, который лежит в основе этих программ,
[33:29.840 --> 33:32.280]  его можно проанализировать и убедиться, что не на всех
[33:32.280 --> 33:36.280]  формулах все так хорошо. Иногда вот такой способ
[33:36.280 --> 33:38.960]  тоже дает очень большое время работы, сравнимое
[33:38.960 --> 33:42.960]  с построением таблицы значений. То есть там что-то типа,
[33:42.960 --> 33:50.680]  какая-то экспонента степени n. Ну и возникает вопрос,
[33:50.680 --> 33:53.840]  а можно ли лучше? И на этот вопрос наука ответа не
[33:53.840 --> 33:58.640]  знает. Это по сути дела примерно то же, что одна из знаменитых
[33:58.640 --> 34:01.760]  задач тысячелетия, за которые там институт Квея
[34:01.760 --> 34:05.160]  миллион долларов дает. И в общем-то современные
[34:05.160 --> 34:07.160]  специалисты в теоретической информатике считают ее
[34:07.160 --> 34:10.080]  безнадежно трудно. То есть никаких перспектив решения
[34:10.080 --> 34:14.560]  в обозримом будущем нет. То есть, но поскольку люди
[34:14.560 --> 34:18.040]  над этим долго думали и ничего не придумали, считается,
[34:18.040 --> 34:20.880]  что эта задача с теоретической точки зрения трудная. Мы
[34:20.880 --> 34:23.560]  не только не знаем алгоритма, который бы эффективно ее
[34:23.560 --> 34:28.600]  решал, но у нас нет никаких идей вообще как такой алгоритм
[34:28.600 --> 34:33.480]  построить. То есть все подходы, которые есть, они заведомо
[34:33.480 --> 34:37.080]  будут давать алгоритмы, которые в худшем случае экспоненциальны.
[34:37.080 --> 34:40.240]  Ну это про сложность алгоритмов я уж точно подробно рассказывать
[34:40.240 --> 34:42.280]  не буду, я просто хотел бы, чтобы вы понимали вот эту
[34:42.280 --> 34:46.000]  ситуацию. Как раз с точки зрения проверки тавтологичности
[34:46.000 --> 34:49.440]  формул сейчас есть разрыв между теорией и практикой.
[34:49.440 --> 34:51.680]  С точки зрения практики эта задача хорошая, потому
[34:51.760 --> 34:56.400]  что люди придумывали много хороших алгоритмов ее решения.
[34:56.400 --> 34:59.880]  Но в принципе теория говорит нам, что эти алгоритмы будут
[34:59.880 --> 35:02.880]  не всегда хорошо работать. И проблема понятна, вы не
[35:02.880 --> 35:06.640]  знаете, когда у вас возникло, инженеры вам принесли описание
[35:06.640 --> 35:08.840]  микросхемы, вы не знаете, сработает она на нем или
[35:08.840 --> 35:11.160]  нет. Ну вроде выработала, на похожих работала, но
[35:11.160 --> 35:13.720]  конкретно на вашей может заткнуться и никакого ответа
[35:13.720 --> 35:17.880]  не дать. То есть никакой гарантии, что на конкретно
[35:17.880 --> 35:20.520]  том входе, который вам принесут, будет получен
[35:20.520 --> 35:24.960]  результат, нет. Это важно понимать. Трудность понимается
[35:24.960 --> 35:29.600]  в основном в таком виде. Хорошо, это вот значит я немножко
[35:29.600 --> 35:32.920]  забежал вперед, чтобы тему вот округлить вот эту с
[35:32.920 --> 35:37.560]  булевыми формулами. Но пора двигаться дальше. Пора
[35:37.560 --> 35:44.120]  переходить к более сложному формализму и научиться
[35:44.120 --> 35:46.320]  математически задавать произвольные математические
[35:46.320 --> 35:49.880]  утверждения. Я вам это обещал с самого начала. И более
[35:49.880 --> 35:52.680]  менее ясно, что булевые формулы для этого слишком
[35:52.680 --> 35:56.760]  слабый способ. Они что-то говорят о конечном множестве.
[35:56.760 --> 35:59.480]  Понятно, переменные принимают конечное множество значений.
[35:59.480 --> 36:01.280]  Ну вот об этом конечном множестве булевая формула
[36:01.280 --> 36:04.120]  вам может что-то сказать. Да и то, если формула не
[36:04.120 --> 36:08.040]  очень длинная, тоже это немножко сложно, я не буду
[36:08.040 --> 36:11.320]  говорить подробнее, но легко написать утверждение
[36:11.320 --> 36:14.640]  о конечных объектах, про которые никто не знает,
[36:14.640 --> 36:17.400]  можно ли их задать коротко формулами и утверждениями
[36:17.400 --> 36:20.560]  о формуле типа тавтологичности, выполнимости или нужны
[36:20.560 --> 36:24.000]  существенно более сложные утверждения. А тогда, если
[36:24.000 --> 36:25.880]  нужны существенно более сложные утверждения, все
[36:25.880 --> 36:28.560]  равно, что мы расширяем язык описания булевых
[36:28.560 --> 36:33.240]  функций, непонятно в какую сторону. И то, что на самом
[36:33.240 --> 36:37.220]  деле делают люди, они используют как раз идеи из более общего
[36:37.220 --> 36:43.760]  способа, который приходен в гораздо более широком
[36:43.760 --> 36:48.520]  контексте. Вот к нему мы сейчас и перейдем. Это
[36:48.520 --> 36:51.360]  формализм получается довольно громоздкий, я не буду спешить,
[36:51.360 --> 36:53.960]  потому что формально можно определение минут, наверное,
[36:53.960 --> 36:56.640]  за 15 все написать, но они будут абсолютно непонятны,
[36:56.640 --> 36:58.720]  все равно их придется потом истолковывать. Поэтому
[36:58.720 --> 37:02.240]  давайте действовать индуктивно. Вот представьте, у нас есть
[37:02.240 --> 37:04.880]  задача, мы хотим научиться как-то формально фиксировать
[37:04.880 --> 37:07.240]  математические утверждения. Что нам для этого нужно?
[37:07.240 --> 37:10.240]  Почему не хватает высказываний? Потому что высказывание
[37:10.240 --> 37:12.800]  непонятно о чем, это оно истинное или ложь, а о чем
[37:12.800 --> 37:15.400]  оно вообще сделано. Математики всегда высказываются о
[37:15.400 --> 37:21.600]  чем-то, о каких-то объектах. Ну, например, давайте посмотрим
[37:21.600 --> 37:25.400]  типичный пример математического высказывания. Четыре меньше
[37:25.400 --> 37:30.840]  семи. Это истина или ложь, да? Если я поставлю любые
[37:30.840 --> 37:34.600]  два числа, это будет истина или ложь. И это высказывание
[37:34.600 --> 37:38.800]  значит оно истинное или ложное. Или четыре является
[37:38.800 --> 37:44.760]  делителем семьи. То же истина или ложь. И сложные математические
[37:44.760 --> 37:47.960]  высказывания, они где-то там внизу должны содержать
[37:47.960 --> 37:52.960]  вот какие-то такие простые. Потому что в конечном счете
[37:52.960 --> 37:54.700]  сама структура высказывания может быть существенно
[37:54.700 --> 37:58.640]  сложнее, чем вот такое примитивное указание, что там два объекта
[37:58.640 --> 38:01.480]  сравнили. Но в конечном счете нам нужно про какие-то
[38:01.480 --> 38:06.480]  объекты говорить, как они соотносятся между собой.
[38:06.480 --> 38:09.840]  Вот эти примеры, сравнение чисел или делимость целых
[38:09.840 --> 38:13.240]  чисел, это примеры того, что математики называют
[38:13.240 --> 38:19.680]  отношениями. А логики любят слово предикаты. Предикаты
[38:19.680 --> 38:25.120]  отношения это синонимы. Я буду стараться говорить
[38:25.120 --> 38:28.320]  отношения, когда говорю о семантике и предикат,
[38:28.320 --> 38:30.640]  когда говорю о синтаксе. Но, конечно, могу сбиваться,
[38:30.640 --> 38:42.140]  потому что очень легко запутать. Отношение на множестве,
[38:42.140 --> 38:45.880]  ну давайте, каком-нибудь m, это просто-напросто под
[38:45.880 --> 38:51.240]  множество, но не самого m, а некоторой его декартовой
[38:51.240 --> 38:59.600]  степени. Тогда это отношение называется коарным. Такое
[38:59.600 --> 39:04.000]  название есть унарные отношения, бинарные отношения, тернарные
[39:04.000 --> 39:06.680]  отношения, и многие люди предпочитают в общем случае
[39:06.680 --> 39:11.320]  говорить о коарных отношениях. А некоторым это странное
[39:11.320 --> 39:14.240]  ублюдочное слово не нравится, и они говорят, что есть валентность
[39:14.240 --> 39:17.600]  k и отношения валентности k. Но вроде как по-русски
[39:17.600 --> 39:32.500]  звучит глажа. Что? Не понял. И валентность, но все равно
[39:32.500 --> 39:34.720]  валентность нужно называть, понимаете. То есть отношения
[39:34.720 --> 39:39.800]  валентности k и k отношения это то же самое, но слово
[39:39.800 --> 39:45.020]  длиннее. Ну и предикат это то же самое, я буду иногда
[39:45.500 --> 39:50.340]  говорить, что это предикат. Вот примеры. Меньше это
[39:50.340 --> 39:56.500]  под множество, скажем, действительных чисел. Делимость, пар действительных
[39:56.500 --> 39:59.740]  чисел, делимость это под множество. Ну давайте на целых числах
[39:59.740 --> 40:06.340]  это в принципе можно определить. Так, сейчас перерыв. Давайте
[40:06.340 --> 40:11.760]  в этом месте прервемся. Про отношения я еще не все
[40:11.760 --> 40:16.960]  сказал, но это довольно естественная точка для перерыва. Я определил
[40:16.960 --> 40:20.160]  отношения. Причем, заметьте, в примерах я использовал
[40:20.160 --> 40:23.200]  запись отношений такую инфиксную, как говорят, когда символ
[40:23.200 --> 40:29.440]  отношения стоит между объектами, которые находятся в отношении.
[40:29.440 --> 40:33.880]  Это удобно для бинарных отношений иногда, неудобно
[40:33.880 --> 40:36.920]  для тернарных, в общем даже не очень понятно где этот
[40:36.920 --> 40:40.000]  символ ставить. Поэтому, когда мы будем задавать, у нас
[40:40.000 --> 40:44.040]  дальше будет в основе нашей формализации будут лежать разные
[40:44.040 --> 40:49.520]  предикаты. И вот тут давайте я напишу где-нибудь справа. Значит, это еще пока
[40:49.520 --> 40:54.160]  такой синтаксис, давайте я возьму в кавычке, это не строгие определения, я
[40:54.160 --> 41:00.480]  просто буду объяснять, как я дальше буду писать формально предикаты. Вот это будет
[41:00.480 --> 41:06.440]  выглядеть вот так вот. Тут многоточие, это не синтаксический знак, это может быть
[41:06.440 --> 41:10.920]  много переменных, то есть карное отношение надо указать много переменных. Вот это
[41:10.920 --> 41:24.240]  вот символ отношения, а это переменная. Этого нам будет недостаточно, сейчас я
[41:24.240 --> 41:27.480]  буквально через пять минут уже объясню, чего тут не хватает.
[41:27.480 --> 41:33.840]  Ну вот у нас запись будет именно такой, то есть имя предиката дальше в скобочках
[41:33.840 --> 41:38.560]  через запятую список аргументов, которым относятся эти предикаты. Ну в общем, в языках
[41:38.560 --> 41:43.320]  программирования так задаются и функции, но на предикаты или на отношения можно
[41:43.320 --> 41:48.600]  смотреть как на функцию с значениями 0,1, потому что если вы взяли какой-то набор
[41:48.600 --> 41:53.640]  значений переменных и спрашиваете о значении предиката, отношение либо истинно
[41:53.640 --> 41:58.840]  либо ложно, но можно считать, что предикат вам отправляет этот набор значений
[41:58.840 --> 42:03.300]  переменных 0,1. То есть на предикаты можно смотреть как на функции с
[42:03.300 --> 42:09.520]  логическими значениями или на отношения тоже самое. Еще такое не очень важное
[42:09.520 --> 42:18.640]  замечание, но полезно сделать, что будет если k равно нулю. Тогда у нас есть ровно
[42:18.640 --> 42:29.240]  два. Да, у нас получается так, что тогда у нас есть ровно две возможности. Предикат
[42:29.240 --> 42:33.720]  либо должен быть всегда истинным, либо всегда ложным. То есть нулярный предикат
[42:33.720 --> 42:37.840]  это просто логические значения, истинно или ложно. Никаких аргументов нет, всегда
[42:37.840 --> 42:45.640]  должно быть что-то одно. Их всего два, вот они такие. Ну и с предикатами можно
[42:45.640 --> 42:51.360]  выполнять разные операции. Например, это же множество. Вот я беру там один предикат и
[42:51.360 --> 42:56.280]  другой предикат. Ну и как обычно могу записать объединение этих множеств. Тогда тоже будет
[42:56.280 --> 43:03.400]  предикат по определению. Формально он будет записываться как-то вот так. Значит, что такое
[43:03.400 --> 43:12.200]  объединение? Дизьюнция. То есть мы знаем, что между теоретико-множественными и логическими
[43:12.200 --> 43:16.400]  операциями есть соответствие, поэтому когда мы выполняем какие-то теоретико-множественные
[43:16.400 --> 43:22.480]  операции с предикатами, мы получаем более сложные предикаты, и они записываться будут уже как раз
[43:22.480 --> 43:28.200]  булевыми формулами, потому что в булевых формулах как раз есть вот эти связки. То есть вы видите,
[43:28.200 --> 43:33.120]  почему я так про булевую формулу долго говорил, потому что они нам все равно будут нужны. Один из
[43:33.120 --> 43:38.680]  способов построения новых предикатов это как раз брать какие-то вот такие логические условия,
[43:38.680 --> 43:44.720]  ну или теоретико-множественное это обсуждать. Причем возможны, конечно, ситуации, когда предикаты
[43:44.720 --> 43:53.320]  разной арности. Какое-нибудь такое условие я могу написать. Этот предикат бинарный, этот унарный,
[43:53.320 --> 43:58.280]  и такое тоже вполне возможно. Получится какой-то предикат, который зависит от тех переменных,
[43:58.280 --> 44:05.960]  которые в него входят. Ну зависит как? Зависит формально. В принципе, я могу вот так вот записать,
[44:05.960 --> 44:13.400]  я могу написать r там от x1 xk, а потом сказать, а этот предикат тождественно истинный. Это не
[44:13.400 --> 44:23.640]  возбраняется. Под множество может совпадать со всем m степени k. То есть тут надо различать
[44:23.640 --> 44:29.680]  существенные переменные и формальные зависимости. Конечно, в синтаксисе мы можем только за
[44:29.680 --> 44:35.800]  формальными зависимостьми следить. Ну это что касается предикатов. И в сущности наша идея
[44:35.800 --> 44:44.480]  состоит в том, чтобы строить разные предикаты. Брать какие-то за основу и строить новые. И бунт
[44:44.480 --> 44:49.520]  получает то, что отвечает математическим утверждениям. Ну когда они станут уже нулярными предикатами.
[44:49.520 --> 44:55.360]  В чем проблема? Значит, ну проблем две. Во-первых, как из бинарного предиката сделать нулярный,
[44:55.360 --> 44:59.800]  например. А вторая проблема состоит в том, что видно, что выразительные средства,
[44:59.800 --> 45:04.920]  которые мы задаем предикатами, они не очень удобны. Когда мы говорим о математике, у нас есть еще
[45:04.920 --> 45:13.120]  желание не только сравнивать объекты, что находятся ли они в отношении, но и выполнять с ними действия.
[45:13.120 --> 45:19.240]  Давайте я напишу какой-нибудь типичный пример. x2 плюс 1 равно нулю. Это некоторое утверждение,
[45:19.720 --> 45:26.360]  у него входит неизвестное нам число и экспериментное. Но равенство это, конечно, предикат. Это важный
[45:26.360 --> 45:33.480]  предикат. Равенство, он тоже бинарный, тоже записывается обычно инфиксно. Но здесь написано
[45:33.480 --> 45:40.280]  что? Написано константа. То есть нам бывает удобно каким-то объектам специально присваивать
[45:40.280 --> 45:47.200]  отдельные имена. Ну вот в арифметике и в алгебре очень часто бывает удобно иметь 0 и 1. В левой
[45:47.200 --> 45:59.440]  части возникает другая константа 1. Вот это вот константы. Их полезно в формализм вести. Ну и
[45:59.440 --> 46:07.440]  вот это константы. Ну это предикат, это мы уже знаем. А что еще тут есть? Тут еще есть плюс и вот
[46:07.440 --> 46:21.000]  этот вот квадрат. Что это такое? А это функция. То есть у нас есть возможность делать утверждение
[46:21.000 --> 46:25.000]  о некоторых таких преобразованиях. Берем сколько-то объектов и из них изготавливаем
[46:25.000 --> 46:38.360]  новый по определенному правилу. Ну скажем складываем. Функция это... Мы под функцией всегда
[46:38.360 --> 46:49.000]  будем понимать тотальную функцию. Ну в этом контексте этого формализма. Которая действует из
[46:49.000 --> 47:00.440]  катой декартовой степени в m. И тогда функция называется тоже k-арная. Так же как и предикаты.
[47:00.440 --> 47:08.600]  То есть k указывает на количество аргументов. Тогда на константы можно смотреть вообще как на
[47:08.600 --> 47:17.240]  нулярные функции. Аргументов нет, а значения есть. А минус этого скорее синтоксический. Как
[47:17.240 --> 47:22.880]  записываются функции? Функции записываются похожи на предикаты и совсем похожи на то,
[47:22.880 --> 47:27.680]  как мы это делаем в языках программирования. То есть имя функции дальше в скобках через
[47:27.680 --> 47:32.920]  запятую параметры. Но если бы мы константы... А константы записываются просто буковкой какой-нибудь.
[47:32.920 --> 47:41.440]  Если бы мы считали, что константы это просто нулярные функции, нам пришлось бы задавать более
[47:41.440 --> 47:50.720]  сложный способом константу имя и пара скобок. Но это как-то не хочется писать. А на самом деле
[47:50.720 --> 47:58.680]  есть более важные причины. И константы и функции. Без них можно обойтись. Мы позже наверное это
[47:58.680 --> 48:05.760]  обсудим, что в нашем выразительном формализме выразительные возможности функций можно имитировать
[48:05.760 --> 48:12.760]  предикатами. Примерно понятно как. Если у вас есть функции, вы можете задать k плюс одинмерный
[48:12.760 --> 48:18.880]  предикат, что k плюс одно число принадлежит графику функции. То есть значение функции от первых k
[48:18.880 --> 48:26.280]  аргументов равно k плюс первому числу. И в общем-то более-менее ясно, что это то же самое. Но что
[48:26.280 --> 48:32.960]  такое функции? График функции и функции более-менее одно и то же. Но оказывается, что для чисто
[48:32.960 --> 48:37.840]  логических целей, которые относятся не к выразимости, а к доказательствам, к выводимости,
[48:37.840 --> 48:42.880]  удобно иметь функции константа. Но это будет у нас еще не скоро, поэтому я сейчас только таким
[48:42.880 --> 48:52.840]  коротким замечанием на этот счет ограничусь и не буду пока это продолжать. Но зато когда у нас
[48:52.840 --> 48:59.480]  появляются функции, становится ясным, что вот это вот представление, что мы будем предикаты задавать
[48:59.480 --> 49:09.360]  вот так, оно немножко примитивное. Потому что вот на эту запись можно смотреть как на предикат от
[49:09.360 --> 49:18.080]  одной переменной. То есть это унарный предикат. Он зависит от x. Возьмете какой-нибудь x, подставите,
[49:18.080 --> 49:26.600]  получится верное или неверное равенство. Но его уже вот в таком виде не представить, потому что
[49:26.600 --> 49:33.320]  переменная x одна, а тут еще много чего наворочено. Нам в окончательном формализме придется уметь
[49:33.320 --> 49:39.880]  вот такие вот вещи. То есть формально нам нужно написать что-то такое, там ноль, и дальше вот что-то
[49:39.880 --> 49:48.760]  такое сложное, отвечающее сложению и возведению квадрата единицы, а не переменным. И соответствующий
[49:48.760 --> 49:54.680]  синтоксический объект у нас появится. Сейчас я про него подробно говорить не буду, потому что
[49:54.680 --> 49:58.360]  содержательно понятно, что я хочу сказать. Я хочу сказать, что если у нас уже есть какие-то
[49:58.360 --> 50:03.200]  функции, мы можем одну функцию подставлять в другую, подставлять в них константы, то есть получать
[50:03.200 --> 50:09.240]  функции от другого числа переменных в результате. А формально это называется термой. В следующий раз,
[50:09.240 --> 50:15.840]  я когда буду давать аккуратное определение, мне это слово придется использовать, и оно создает
[50:15.840 --> 50:20.280]  определенные трудности в понимании формального определения. Но сейчас я просто хочу указать,
[50:20.280 --> 50:29.240]  что у нас в синтаксисе будет вот описание таких атомарных высказываний, с которыми мы будем
[50:29.240 --> 50:35.400]  делать. Оно будет чуть более сложным, чем просто имя предиката и имена каких-то объектов переменные,
[50:35.400 --> 50:40.160]  потому что вместо переменных могут стоять какие-то сложно сочиненные конструкции,
[50:40.160 --> 50:50.160]  когда мы переменным еще что-то такое применяем. Ну, функции сильно расширяют наши возможности
[50:50.160 --> 50:55.360]  выразительные, хотя, как я сказал, по сути дела ничего не расширяет. Вот что точно расширяет,
[50:55.360 --> 51:05.360]  то есть у нас есть логические связки, есть функции, но это, как мы увидим, так по сути,
[51:05.360 --> 51:11.240]  то есть это создает удобство, но не меняет, по сути, выразительные силы. А вот что меняет
[51:11.240 --> 51:17.480]  выразительную силу, это вот что. Если у нас есть только выражение того вида, про которое я сказал,
[51:17.480 --> 51:23.120]  совершенно непонятно, как очень простые математические высказывания в ним ими записывать. Ну,
[51:23.120 --> 51:32.280]  например, уравнение x2 plus 1 равно 0 не имеет решения в действительных числах. Это типичное
[51:32.280 --> 51:36.840]  утверждение, которое в математике встречается. Чего нам не хватает? Уравнение само мы задать
[51:36.840 --> 51:44.880]  можем, но когда мы говорим не имеет решений, мы еще что-то делаем. Мы делаем суждение о всех
[51:44.880 --> 51:52.280]  возможных значениях переменных. И фактически мы утверждаем, что для всех, давайте вот этот
[51:52.280 --> 52:00.280]  предикат сложно сочиненный, я как-нибудь назову E от X, и мы фактически делаем утверждение,
[52:00.280 --> 52:14.080]  что E от X сложно, ну или отрицание E от X истинно для всех x. Это очень типичная математики форма,
[52:14.080 --> 52:18.280]  вы с ней заведомо сталкивались, и нам потребуется соответствующая операция с
[52:18.280 --> 52:23.160]  предикатами, которая называется навешивание квантора. Сейчас прямо напишу название.
[52:23.160 --> 52:37.720]  Навешивание квантора состоит в том, что мы записываем формально, вот я уже и на той
[52:37.720 --> 52:50.960]  доске напишу, потому что это элемент синтаксиса. Вот это уже будет кодировать высказывание,
[52:50.960 --> 53:00.160]  что то, что стоит под квантором, истинно при любом значении X. И заметьте, что вот если этот
[53:00.160 --> 53:12.000]  предикат был унарный, то этот предикат уже становится нулярным. Почему? Потому что в этом
[53:12.000 --> 53:17.040]  высказывании мы говорим сразу обо всех возможных значениях X, поэтому от конкретного значения X оно
[53:17.040 --> 53:25.400]  зависеть не может. Значит оно не вообще, поскольку там только от X было зависимое, значит итоговый
[53:25.400 --> 53:31.880]  предикат он нулярный, то есть истина или ложь. Ну и в данном случае мы знаем, что это истина,
[53:31.880 --> 53:38.560]  бывают ложные высказывания. То есть у нас появляется такой вот способ навешивания квантора. Это
[53:38.560 --> 53:46.600]  операция с кванторами, которая по предикату, давайте я как-нибудь запишу, переменные для
[53:46.600 --> 53:57.640]  наглядности назову по-разному. X и еще сколько-то там N переменных Y. И вот я сопоставляю, навешивание
[53:57.640 --> 54:06.880]  квантора сопоставляется, это N плюс один арный предикат. А я сопоставляю ему N-арный предикат,
[54:06.880 --> 54:21.800]  который уже зависит только от значений Y. Тут X надо конечно добавить, прошу прощения. Это
[54:21.800 --> 54:28.960]  вот высказывание того типа, который я сейчас сказал, что для всех X выполняется то, что написано под
[54:28.960 --> 54:33.040]  квантором. Но там могут быть другие переменные, то есть это вообще говоря может быть предикат,
[54:33.040 --> 54:38.640]  но арность предиката при этом уменьшилась. Если мы навесим достаточно много кванторов,
[54:38.640 --> 54:47.080]  из любого предиката мы получим просто истину и лёгушу. Ну и есть другой важный способ навешивать
[54:47.080 --> 54:58.920]  квантор, который мы будем использовать, навесить квантор существования. То есть высказать такое
[54:58.920 --> 55:08.800]  осуждение, что для какого-то X наш предикат истинный. Помните, когда я говорил про автологичность и
[55:08.800 --> 55:12.880]  выполнимость, это очень похожая ситуация, типичный пример квантора существования и квантора
[55:12.880 --> 55:22.440]  всеобщенности. Что это называется? Квантор всеобщенности, а это называется квантор существования. И тот и другой
[55:22.440 --> 55:27.920]  уменьшают арность предиката. Увеличивается арность предиката очень просто. Вы можете,
[55:27.920 --> 55:34.240]  вот как вот в этом примере я писал взять предикат и там, ну тут же может вообще стоять, скажем,
[55:34.240 --> 55:39.760]  X3. Был унарный предикат, был бинарный предикат, я записал вот такое выражение, он стал тернальный.
[55:39.760 --> 55:45.200]  А уменьшается вот как раз у нас, по крайней мере в нашем формализме, он уменьшаться будет
[55:45.200 --> 56:00.280]  именно применением кванторных операций. В каком смысле формальная? Тут давайте у нас,
[56:00.280 --> 56:05.040]  поскольку мы еще и говорим про формализацию, нужно как-то уточнить ваш вопрос. То, что я сказал,
[56:05.040 --> 56:11.680]  это математическое определение. Я описал как, вот у меня есть известный мой предикат, и я
[56:11.680 --> 56:19.880]  описываю новый. Он однозначно определен этим правилам, что я сказал. Если заданы значения Y,
[56:19.880 --> 56:30.040]  то вот этот предикат истинный, если исходный предикат истин при любом значении X. И ложный,
[56:30.040 --> 56:35.800]  если хотя бы при каком-то значении X он ложный. С квантором сочетания наоборот. Он истинный,
[56:35.800 --> 56:41.800]  если хотя бы при одном значении X истинный. И ложный, если при всех ложных. Это математическое
[56:41.800 --> 56:52.080]  определение. Формализм, мы просто будем использовать вот такие записи в качестве формул.
[56:52.080 --> 56:58.520]  Смысл их будет вот ровно тот, который я сказал. То есть, с точки зрения семантики,
[56:58.520 --> 57:06.400]  я дал определение, как устроен такой предикат. А если вы уточните вопрос и скажете,
[57:06.400 --> 57:10.600]  как, чего более формального вы хотите, я попробую на него ответить.
[57:10.600 --> 57:28.040]  Ну, оценки переменных у нас появятся. Смотрите, тогда вы говорите вот о чем. Я
[57:28.040 --> 57:32.600]  пока не дал определение, с какими формулами мы будем иметь дело. Я пока рассуждаю
[57:32.600 --> 57:36.120]  содержательность семантически. У меня есть предикаты, я с ними выполняю какие-то операции. Вот
[57:36.120 --> 57:41.800]  это сейчас еще не синтаксис. Я на правой доске просто отмечаю, какие у нас будут возникать
[57:41.800 --> 57:48.920]  элементы в синтаксисе. Определение я не дал. Формулы первого порядка, которая состоит из этих
[57:48.920 --> 57:55.240]  выразительных средств. Как ее оценивать, тем более не дал. Это пока рано. Прежде чем говорить об
[57:55.240 --> 58:02.120]  этом, нам нужно еще продолжить на семантическом уровне разговор, потому что иначе значение формулы
[58:02.120 --> 58:14.840]  не припишешь. Это тогда другая проблема, что вы сейчас сразу хотите, чтобы речь шла о формулах,
[58:14.840 --> 58:20.800]  но я не хочу торопиться. Я мог бы сейчас прямо определить формулы, начать говорить о них,
[58:20.800 --> 58:29.560]  но давайте все-таки лучше в том порядке, в котором я иду. Смотрите, нужно расставлять
[58:29.560 --> 58:33.600]  приоритеты. Наша основная цель – это формализовать математические утверждения. Поэтому первое,
[58:33.600 --> 58:39.120]  что мы хотим сделать – научиться выражать математические утверждения в каком-то формальном
[58:39.120 --> 58:46.160]  способе. Для этого нужно вначале развить этот формализм и отталкиваться надо от содержательных
[58:46.160 --> 58:49.600]  утверждений, потому что если в содержательных утверждениях есть что-то более сложное, чем мы
[58:49.600 --> 58:59.320]  запасем в формализме, то нам будет трудно. Поэтому я хочу продолжить все-таки сегодня разговор
[58:59.320 --> 59:03.480]  про семантику, а в следующий раз уже более аккуратно говорить про синтаксис. Он, конечно,
[59:03.480 --> 59:08.160]  будет связан с семантикой, значение формулы надо будет определять. Само определение формулы не
[59:08.160 --> 59:16.520]  очень длинное, но давайте лучше пройдемся чуть дальше. Дальше из всех этих элементов, которые
[59:16.520 --> 59:23.200]  я сказал, собираются, это в общем-то даже не только в логике. Есть такая абстрактная алгебра, которая
[59:23.200 --> 59:31.800]  очень близка к этому. Собирается то, что мы будем называть моделью. Что такое модель? Модель – это
[59:31.800 --> 59:37.760]  множество, причем мы договоримся, что оно всегда не пустое. Если у нас есть модель, это называется
[59:37.760 --> 59:52.440]  носитель модели, и он должен быть не пустой. Множество, сколько-то предикатов. Вообще говоря,
[59:52.440 --> 59:56.800]  может быть даже бесконечно много, но я напишу конечное число тут. Какое-то множество предикатов,
[59:56.800 --> 01:00:09.840]  какое-то множество функций и какое-то множество константов. Вот это и есть модель. Множество и
[01:00:09.840 --> 01:00:17.080]  какие-то простейшие вещи, которые мы про элементы этого множества можем делать. Мы можем делать
[01:00:17.080 --> 01:00:22.320]  высказывания, которые зафиксированы в этом списке, применять вот эти функции, и у нас для каких-то
[01:00:22.320 --> 01:00:27.640]  элементов это множество есть зарезервированные имена. Вот это все называться будет сигнатурой.
[01:00:27.640 --> 01:00:40.080]  Нет, переменные в модель не входят. Мы считаем, что у нас достаточно большой запас переменных в
[01:00:40.080 --> 01:00:47.720]  любой модели. То есть мы себя в количестве переменных не ограничиваем. А в базовых предикатах,
[01:00:47.720 --> 01:00:52.320]  из которых мы что-то хотим выражать, мы себя ограничиваем. Дальше возникает то, что можно
[01:00:52.320 --> 01:00:56.800]  назвать алгебра предикатов. Вот у нас есть базовые предикаты и функции, и мы из них,
[01:00:56.800 --> 01:01:01.880]  используя вот эти средства, которые я сейчас описал, можем строить новые предикаты. Можем
[01:01:01.880 --> 01:01:05.880]  брать какие-то булевые формулы, они будут задавать новые предикаты, можем навешивать
[01:01:05.880 --> 01:01:14.000]  квантры и так далее. Получается гораздо больше множество предикатов. И вот это называются предикаты,
[01:01:14.000 --> 01:01:20.840]  выразимые в модели. То есть когда зафиксирована модель и зафиксирован вот этот формализм,
[01:01:20.840 --> 01:01:25.480]  ну в следующий раз мы доопределим аккуратнее, но уже сейчас ясно, какие операции мы выполняем,
[01:01:25.480 --> 01:01:30.460]  то возникает вопрос, на самом деле ясно, я немножко лукавлю, может быть я успею сегодня
[01:01:30.460 --> 01:01:36.800]  прокомментировать точнее, а может быть уже в следующий раз. В общем, пока такое не до конца
[01:01:36.800 --> 01:01:42.640]  формализованное понятие алгебры предикатов, предикатов выразимых в данной модели. Давайте
[01:01:42.640 --> 01:01:47.800]  посмотрим на примеры, потому что так сейчас легко запутаться, потому что определение очень
[01:01:47.800 --> 01:01:51.640]  формальное, да еще и пока не очень строгое. Но прежде чем давать строгое определение,
[01:01:51.640 --> 01:01:59.640]  я хотел бы, чтобы вы посмотрели на примеры, чтобы было потом проще соотносить формальные
[01:01:59.640 --> 01:02:05.800]  синтаксические конструкции и какую-то реальность. Вот давайте посмотрим на такой пример группы.
[01:02:05.920 --> 01:02:14.200]  Вот у нас есть группа, она задает модель. Что является носителем модели? Ну множество
[01:02:14.200 --> 01:02:25.480]  элементов группы. Какие у нас есть предикаты? Предикат 1 равенство, а есть также бинарная
[01:02:25.480 --> 01:02:33.360]  функция умножения, унарная функция взятия обратного, есть константа единица. Вот мы
[01:02:33.360 --> 01:02:38.760]  зафиксировали такую модель и дальше мы можем выражать какие-то другие вещи в этой модели,
[01:02:38.760 --> 01:02:45.360]  какие-то высказывания группе можем выражать. Ну вот, например, я пока использую кванторы,
[01:02:45.360 --> 01:02:54.800]  не очень формально и записываю тоже пока не очень формально. Формализм это превратить достаточно
[01:02:54.800 --> 01:03:09.600]  легко. Вот смотрите, что здесь написано. Единица, да, константа, то есть вот это вот предикат,
[01:03:09.600 --> 01:03:24.520]  это функции, а это константа. Вот давайте смотреть, поскольку у меня вот здесь явно написан бинарный
[01:03:24.520 --> 01:03:29.080]  предикат, я на него два раза навешал кванторы по одной и по другой переменной, должен получиться
[01:03:29.080 --> 01:03:35.160]  нулярный предикат, истина или ложь. Как вы думаете, это истина или ложь? Истина для любой группы,
[01:03:35.160 --> 01:03:43.520]  потому что это просто обычная формула взятия обратного произведения. А если я, скажем,
[01:03:43.520 --> 01:03:53.520]  напишу для любого х, для любого у, х, у равняется ух, это уже мы не можем сразу ответить, истина это
[01:03:53.520 --> 01:03:58.800]  или ложь. Почему? Потому что это зависит от свойств группы. Если в качестве носителя модели мы возьмем
[01:03:58.800 --> 01:04:04.000]  абелевую группу, это будет верно тоже. А если, скажем, возьмем группу перестанова, где больше чем три
[01:04:04.000 --> 01:04:09.280]  элемента, это уже будет неверно. То есть зависимость от того группы абелева или не абелева, это формула
[01:04:09.280 --> 01:04:17.960]  истина или ложна. То есть когда мы пишем вот такое высказывание, строим предикат нашими операциями,
[01:04:17.960 --> 01:04:25.440]  он может в одной модели быть истинным, в другой быть ложным. Потому что вот эти вот элементарные
[01:04:25.440 --> 01:04:31.080]  предикаты и функции, они имеют в разных моделях, могут иметь разную интерпретацию. Вот как в случае
[01:04:31.080 --> 01:04:37.840]  группы. Если же это группа целых чисел, то вторая формула истина. А если же это группа перестановок,
[01:04:37.840 --> 01:04:46.880]  там, скажем, трех элементов, она уже ложна. Но тем не менее, я сейчас говорю про истину и ложь,
[01:04:46.880 --> 01:04:53.600]  а в принципе можно выражать предикаты. То есть какие-то новые отношения выражать с помощью
[01:04:53.600 --> 01:05:04.240]  наших выразительных средств. Ну и здесь очень показательно есть две модели. Давайте я их прямо
[01:05:04.240 --> 01:05:24.400]  напишу. Они у нас будут очень часто возникать. Ну не только они, но эти точно будут возникать.
[01:05:24.640 --> 01:05:32.680]  Ой, а тут... Все время забываю, что сюда нельзя класть, там вода. Наверное, предыдущий подсох.
[01:05:32.680 --> 01:05:49.360]  Первая модель называется алгебратарского. У нее носитель – это действительные числа.
[01:05:49.920 --> 01:05:59.200]  Предикаты – это равенство и неравенство. То есть сравнение чисел на равно и на меньше. Это
[01:05:59.200 --> 01:06:09.800]  арифметические операции. Достаточно сложение и умножение. И константы 0,1, допустим. Вот такая
[01:06:09.800 --> 01:06:15.560]  модель. В ней можно делать высказывания о каких-то действительных числах и о наборах
[01:06:15.560 --> 01:06:22.880]  действительных чисел. Ну вот самый первый пример. 4 меньше 7 – это такой простейший предикат,
[01:06:22.880 --> 01:06:27.960]  который выразим в этой модели. Просто сразу выразим. Такой атомарный предикат. То есть
[01:06:27.960 --> 01:06:35.520]  меньше х и у – это уж точно выразим. То есть предикат меньше выразим по определению. Он у
[01:06:35.520 --> 01:06:50.040]  нас есть. Но можно выразить что-то более сложное. Например, вот есть квадратное уравнение и мы
[01:06:50.040 --> 01:06:55.720]  хотим, а и b мы считаем параметрами, мы хотим написать предикат от а и b, который выражает
[01:06:55.720 --> 01:07:01.160]  такое свойство, это уравнение, что у него есть корни. Но вы, наверное, знаете, как такой предикат
[01:07:01.160 --> 01:07:11.840]  записать, да? Ну да, то есть это будет вот такой вот a квадрат – 4b больше либо равняется нулю. Тут
[01:07:11.840 --> 01:07:19.520]  уже нам нужны функции, которые есть. Четверки у нас нет, у нас константа только один. Но как
[01:07:19.520 --> 01:07:28.460]  сделать из 0 и 1 четверку, я думаю, все догадываются, что можно выразить 4. То есть это можно выразить,
[01:07:28.460 --> 01:07:36.340]  минус можно выразить через сложение. Там это требует некоторых усилий, но можно. Тут сравнение не
[01:07:36.340 --> 01:07:41.420]  строгое, но это тоже не очень сложно. Не строгое сравнение – это дизюнция. Или строгое сравнение,
[01:07:41.420 --> 01:07:47.300]  или равенство. А дизюнция – это объединение, то есть это как раз то, что у нас из булевых форм
[01:07:47.300 --> 01:07:59.580]  приходит булева-связка дизюнция, позволяет нам не строгое, не равенство. Да, имеющиеся функции мы можем,
[01:07:59.580 --> 01:08:11.860]  то есть вот теми способами, которые я говорил, мы подставляем в одну функцию другую. Ну, пожалуйста.
[01:08:11.860 --> 01:08:34.020]  Существует такое s, что? Существует такое x, что x? Ну, давайте вот я буду, чтобы знак умножения был
[01:08:34.020 --> 01:08:48.660]  виден, я его звездочкой буду писать. Звездочка x, x равно 1 плюс 1. Вот, пожалуйста, значит, ой,
[01:08:48.660 --> 01:08:59.220]  извините, я два раза написал кванторы. Вот, тут один, конечно, нужна одна переменная. Вот я написал
[01:08:59.220 --> 01:09:04.420]  такую формулу. Ну, что такое формула, я буду говорить потом, но это операции с предикатами,
[01:09:04.420 --> 01:09:15.540]  сейчас для нас это операции с предикатами, которые определены. Ну, вот хороший вопрос. Вы прям с вами
[01:09:15.540 --> 01:09:23.380]  спешите, я хотел в следующий раз про это поговорить. На самом деле давайте, нет-нет, это буквально то,
[01:09:23.380 --> 01:09:31.300]  о чем я хочу сказать. Понимаете, p выразить вал гибритарского невозможно. Но как это доказать?
[01:09:31.300 --> 01:09:39.280]  Прежде чем это доказывать, тут вот в следующий раз я буду давать строгие определения, они очень
[01:09:39.280 --> 01:09:44.180]  занудные и громоздкие. Чтобы было понятно, почему это приходится делать, это вот нужно обсудить
[01:09:44.180 --> 01:09:50.420]  именно такого рода вопрос. Хорошо, а вал гибритарского p выражается или нет? Или для меня более даже
[01:09:50.420 --> 01:09:57.180]  принципиальный пример, вот такой более простой предикат x целое число, это унарный предикат.
[01:09:57.180 --> 01:10:08.340]  Можно его выразить вал гибритарского или нет? Ну, это такое. Давайте я напишу немножко другой
[01:10:08.340 --> 01:10:22.740]  предикат n от x, это целое положительное и напишу что-нибудь такого типа. Буду применять операции
[01:10:22.740 --> 01:10:42.940]  каким-нибудь таким способом. Значит так, n от единицы. Нет, не так. Я хочу задать n от x.
[01:10:42.940 --> 01:11:02.740]  n от x равняется, значит, или x равняется единице, или существует такое y, что n от y и y плюс 1 равняется x.
[01:11:02.740 --> 01:11:13.740]  Чем не задание? Я знаю, что условия будут влиять только положительное целое число. Ну,
[01:11:13.740 --> 01:11:18.620]  а все целые числа, я думаю, не нужно объяснять, что там, ну, противоположно еще раз. Задать это
[01:11:18.620 --> 01:11:27.460]  легко. Тут надо какие-нибудь скобки поставить, чтобы было понятно, где логика, где математика.
[01:11:27.460 --> 01:11:33.540]  Ну, действительно, либо целое положительное число равно единице, либо есть предыдущее.
[01:11:33.540 --> 01:11:38.620]  В сущности, вот то, что написано вторым условием, это то, что есть предыдущее число. Предыдущее
[01:11:38.620 --> 01:11:44.780]  такое, которое на единичку меньше. Оно тоже целое. И понятно, что только целые числа попадут в это
[01:11:44.780 --> 01:12:02.080]  определение. Ну как, вот устраивает вас такое? Что? Нет, вы торопитесь. Устраивает ли вас такой
[01:12:02.080 --> 01:12:10.940]  способ задать предикат x целое в рифметике тарского? Почему? Да, на самом деле, потому что
[01:12:10.940 --> 01:12:16.420]  использованы индуктивные определения. А вообще, логика знает много разных способов определений.
[01:12:16.420 --> 01:12:23.940]  Индуктивные не самые сложные. Есть то, что называется определение с неподвижной точкой. Это
[01:12:23.940 --> 01:12:28.940]  почти индуктивное. Это можно было бы переписать как логику с неподвижной точкой, но там чуть
[01:12:28.940 --> 01:12:34.260]  более общая конструкция, которая... Сейчас мне не хочется тратить время, например, где она будет
[01:12:34.260 --> 01:12:40.860]  отличаться от индуктивного определения. И если мы это разрешаем, у нас будут одни выразительные
[01:12:40.860 --> 01:12:46.100]  возможности. Если не разрешаем, другие. То есть, прежде чем доказывать, что что-то нельзя выразить,
[01:12:46.100 --> 01:13:02.780]  нам надо зафиксировать, ну вот как говорят модели. Кстати, вопрос про x равно pi вы мне напомните. Я
[01:13:02.780 --> 01:13:08.420]  никогда не думал, я думаю, что не очень трудно доказать, что невыразимо. Ну, предикат x равно pi,
[01:13:08.420 --> 01:13:12.220]  такой вот унарный предикат. Он равен единице только на pi. Потому что что значит выразить
[01:13:12.220 --> 01:13:16.060]  констант? Это по сути дела вот такой унарный предикат задать. Что мы можем различать,
[01:13:16.060 --> 01:13:22.540]  ну как я с корнем из двух делал. По сути дела, это способ, если убрать вот это вот существует,
[01:13:22.540 --> 01:13:29.660]  то это способ задать предикат, что s это корень из двух. Он равен единице, ну надо еще, наверное,
[01:13:29.740 --> 01:13:41.740]  написать условия, да. И s больше 0. Как-нибудь вот так. И это уже будет предикат, который вот такой
[01:13:41.740 --> 01:13:48.500]  вот. То есть, он будет истиннее, если s корень из двух и ложь его всех остальных случаев. Вот про x
[01:13:48.500 --> 01:13:58.900]  равно pi. Про x равно pi, я уверен, что задать его, конечно, нельзя. Но как это?
[01:13:58.900 --> 01:14:07.740]  Доказать. Давайте я подумаю. Я сейчас не готов сходу. Ну, даже про их целое я знаю,
[01:14:07.740 --> 01:14:11.620]  как доказывать, почему невыразимо. Я не готов сейчас рассказывать, вам даже определение не
[01:14:11.620 --> 01:14:16.180]  дал еще. А, конечно, там доказательства еще используют некоторый довольно мощный прием
[01:14:16.180 --> 01:14:22.580]  рассуждения. Так что давайте это мы подвесим через некоторое время. И более того, я не докажу
[01:14:22.580 --> 01:14:29.580]  основное утверждение про алгебру тарского, из которого следует способ доказательства невыразимости
[01:14:29.580 --> 01:14:35.140]  вот таких предикатов. Я только объясню, как можно доказать. Там довольно громоздкое доказательство,
[01:14:35.140 --> 01:14:40.500]  я само доказательство планирую пропустить. Мы похожие утверждения про другие модели будем
[01:14:40.500 --> 01:14:46.180]  рассматривать, а это мы пропустим. Но это мы опять забежали вперед. Тут вот, понимаете,
[01:14:46.180 --> 01:14:50.060]  некоторая проблема в том, что хочется от формализма быстрее перейти к каким-то
[01:14:50.060 --> 01:14:53.940]  содержательным вопросам. Но логика в этом смысле очень коварная, что пока мы не зафиксировали
[01:14:53.940 --> 01:14:59.940]  формализм, можно очень много времени тратить впустую просто из-за того, что спорить будет это,
[01:14:59.940 --> 01:15:06.220]  выражать или не будет, и как избавиться от таких выражений. Понимаете, да, мы избавимся тем,
[01:15:06.220 --> 01:15:11.860]  что просто четко зададим вот ту неформальную алгебру предикатов, которую я сказал. Но я хочу
[01:15:11.860 --> 01:15:21.780]  сразу, почему у меня вот этот предикат очень важен, я хочу сразу задать модель,
[01:15:21.780 --> 01:15:26.380]  которую я буду называть арифметикой, которая отличается от алгебритарского в сущности только
[01:15:26.380 --> 01:15:37.700]  носителем. Это тоже сравнение чисел, тоже арифметические операции с числами и константы
[01:15:37.700 --> 01:15:45.820]  0 и 1, но на множестве неотрицательных целых чисел. Вот это я буду называть арифметикой
[01:15:45.820 --> 01:15:55.180]  для определенности. И хотя тут действительно числа тут натуральные, неожиданным образом это
[01:15:55.180 --> 01:16:03.500]  я сразу анонсирую, выразительные способности арифметики гораздо выше. И связано это с очень
[01:16:03.500 --> 01:16:11.940]  важной причиной. Мы когда изучали алгебру, мы рассматривали деление с остатком. Мы можем
[01:16:11.940 --> 01:16:19.580]  написать условия, что число делится на другое число с остатком. А существуют такие Q и R,
[01:16:19.580 --> 01:16:29.780]  что A равняется QR плюс QB, прошу прощения, плюс R. Ну и R еще должно быть, как вы помните,
[01:16:29.780 --> 01:16:37.820]  когда мы говорим про остаток, оно должно быть, тут два неравенства еще должно быть. Так вот,
[01:16:37.820 --> 01:16:44.140]  этот предикат, его можно записать и в алгебритарском, но в алгебритарском ничего интересного не
[01:16:44.140 --> 01:16:50.980]  выражают, потому что более-менее всегда, там за исключением какого-то выраженного случая нуля,
[01:16:50.980 --> 01:16:55.940]  вы можете подобрать остаток равный нулю, ну то есть у вас действительно числа можно делить
[01:16:55.940 --> 01:17:02.500]  друг на друга. Если B не равно нулю, лучше, чтобы B не равнялось нулю и пределение со остатком.
[01:17:02.500 --> 01:17:08.180]  А если B не равняется нулю, у вас этот предикат всегда истинный по тривиальным причинам. Остаток
[01:17:08.180 --> 01:17:14.780]  ноль, а Q это частное, A разделить на B, для действительных чисел. То есть в этом смысле,
[01:17:14.780 --> 01:17:19.860]  говорят, что в действительных числах нет деления с остатком, у вас нет вот этого возможности
[01:17:19.860 --> 01:17:28.620]  разделить число на частное и на остаток. Вот у вас все сливается. И это сильно уменьшает выразительные
[01:17:28.620 --> 01:17:33.460]  способности алгебритарского, как мы позже увидим. Тем не менее, мне осталось пара минут и я хочу
[01:17:33.460 --> 01:17:40.140]  про алгебритарского сказать, но уже очень бегло. В конспектах я может быть какие-то более подробные
[01:17:40.140 --> 01:17:44.620]  напишу слова, чтобы было понятно, но на самом деле я надеюсь, что это не очень сложно. Вообще,
[01:17:44.620 --> 01:17:49.580]  за что отвечают выразительные возможности алгебритарского? Ну, прежде всего за
[01:17:49.580 --> 01:17:54.620]  элементарную геометрию. То есть алгебритарского, хотя называется алгеброй, но это такое естественное
[01:17:54.620 --> 01:17:59.180]  место, где живет элементарная геометрия. Ну, знаете, там всякие теоремы, что все прямые
[01:17:59.180 --> 01:18:05.180]  проходят через одну точку, все точки лежат на одной окружности, таких много. Ничего удивляюсь,
[01:18:05.180 --> 01:18:11.900]  есть такие теоремы. Ну, не совсем такие, но есть. Ну, что высоты пересекаются в одной точке. Хорошо,
[01:18:12.060 --> 01:18:17.820]  есть треугольник, его высоты пересекаются в одной точке. Три прямые проходят через одну точку. Ну,
[01:18:17.820 --> 01:18:23.300]  не все, но вот три. Но таких теорем очень много. Там прямых в треугольнике можно провести сотни,
[01:18:23.300 --> 01:18:29.220]  и все тройками, и все эти тройки будут иметь общую точку. Поэтому я так немножко ехидно говорю,
[01:18:29.220 --> 01:18:35.900]  что все. Конечно, не все. Но теорем таких очень много. Почему это можно выразить в алгебритарского?
[01:18:35.900 --> 01:18:41.980]  Это… Время у меня почти заканчится, я только скажу общую идею. Это, естественно, просто метод
[01:18:41.980 --> 01:18:47.820]  координата, аналитическая геометрия. Вы можете задать точки на плоскости парами чисел, уравнения
[01:18:47.820 --> 01:18:53.500]  прямой записываются алгебраически, уравнения окружности записываются алгебравически, пересечение
[01:18:53.500 --> 01:18:58.700]  прямой и окружности или прямой и прямой задается просто условием, что существуют такие x и y,
[01:18:58.700 --> 01:19:04.500]  что вот выполняются два уравнения. Что такое высота? Ну, это условие перпендикулярности двух
[01:19:04.500 --> 01:19:09.620]  прямых, но тоже его можно записать алгебраически. Например, используя скалярное произведение.
[01:19:09.620 --> 01:19:15.500]  Скалярное же произведение позволяет обходиться без углов там с градусами или с pi, неважно. Мы
[01:19:15.500 --> 01:19:19.300]  вместо этого будем говорить о скалярных произведениях единичных векторов. Это будет
[01:19:19.300 --> 01:19:24.260]  более-менее то же самое, что косинус угла. И все теоремы элементарной геометрии, которые вы знаете,
[01:19:24.260 --> 01:19:31.980]  можно пересказать. Единственное, что там действительно появятся условия, что для любых там трех точек выполняется
[01:19:31.980 --> 01:19:36.780]  то-то и то-то. Или для любых трех точек существует еще какая-то точка, для которой выполняется,
[01:19:36.780 --> 01:19:41.220]  допустим, существует описанная окружность. Как это сказать? Ну, вот существует точка,
[01:19:41.220 --> 01:19:49.020]  существует еще ее радиус такой, что все три вершины треугольника лежат на этой окружности.
[01:19:49.020 --> 01:19:57.020]  И комбинируя вот эти вот операции с кванторами, можно любые теоремы выразить. Ну, и это более-менее
[01:19:57.300 --> 01:20:03.540]  все. На самом деле, если не говорить о планеметрии, а взять произвольную размерность, то вообще
[01:20:03.540 --> 01:20:09.340]  получится более-менее как раз то же самое. То, что называют полуалгебрайческие множества. То есть
[01:20:09.340 --> 01:20:16.100]  у нас есть возможность задавать не просто решение системы линии уравнений алгебрайческих, а решение
[01:20:16.100 --> 01:20:27.540]  алгебрайческих уравнений и неравенств. Вот в этом разница. Ну, почему так? Это я немножко объясню.
[01:20:27.540 --> 01:20:34.180]  Я говорю, до конца я, по видео, это не доведу рассуждения, но основной способ, что надо сделать,
[01:20:34.180 --> 01:20:44.860]  я объясню. И это будет чуть позже. В следующий раз мы наконец определим все формально. Но потом
[01:20:44.860 --> 01:20:48.940]  нам надо будет еще поупражняться с аналогами тавтологии. Только после этого уже начнем
[01:20:48.940 --> 01:20:53.020]  доказывать невыразимость разных предикатов. Ну, на сегодня все.
