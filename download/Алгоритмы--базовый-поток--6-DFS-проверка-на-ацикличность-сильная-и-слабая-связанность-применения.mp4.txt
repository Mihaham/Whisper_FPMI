[00:00.000 --> 00:15.840]  Так, всем добрый день. Сегодня мы говорим про обход в глубину. Я напомню, что в прошлый раз мы с вами начали модуль,
[00:15.840 --> 00:24.480]  посвященный графам, и разговаривали про обходы в ширину. И, собственно, поговорили про применение
[00:24.480 --> 00:28.840]  обходов в ширину, поняли, что он помогает нам искать компоненты связанности для неоритированных графов,
[00:28.840 --> 00:33.640]  он позволяет искать множество достижимых вершин. Ну и, соответственно, главное применение — это,
[00:33.640 --> 00:41.480]  соответственно, поиск кратчайшего пути в графе, в невзвешенном графе. Ну и в конце чуть-чуть поговорили
[00:41.480 --> 00:46.880]  про взвешенные графы, и, соответственно, семинары тоже, думаю, надеюсь, об этом тоже говорили.
[00:46.880 --> 00:52.040]  Значит, сегодня мы говорим про обход графа в глубину. И обход графа в глубину на самом деле — это
[00:52.040 --> 01:00.840]  гораздо более применимая штука. В общем, она будет встречаться вплоть до конца наших с вами лекций.
[01:00.840 --> 01:04.760]  То есть, так или иначе, она будет постоянно находить все новые и новые применения. В этом смысле она,
[01:04.760 --> 01:09.440]  наверное, в хозяйстве более полезная вещь. Ну, собственно, давайте про нее поговорим.
[01:09.440 --> 01:13.400]  Ну, я напоминаю, в чем стоит задача обхода в глубину. Задача обхода в глубину стоит в том,
[01:13.400 --> 01:18.920]  что у нас есть некоторый граф, в графе есть вершина, в графе есть ребра. Соответственно, нужно все эти
[01:18.920 --> 01:22.240]  вершины и ребра этого графа каким-то образом посетить, причем в некотором определенном порядке,
[01:22.240 --> 01:27.400]  который каким-то образом зависит от непосредственно структуры графа. И, соответственно,
[01:27.400 --> 01:33.920]  напоминаю, что у нас был обход BFS. Кстати, я, по-моему, в прошлый раз забыл сказать,
[01:33.920 --> 01:48.240]  как расшифровывается BFS. Ну, то есть, поиск сначала в глубину. Соответственно, в чем стоит идея обхода
[01:48.240 --> 01:53.640]  в ширину? Идея обхода в ширину заключается в следующем. Вы сначала обходите какую-нибудь вершинку,
[01:53.640 --> 01:57.160]  потом, соответственно, ее ближайших соседей, потом следующих соседей, ну и так далее,
[01:57.160 --> 02:04.000]  вот так вот постепенно увеличивая область обнаружения элементов. Вот, обход в глубину устроен
[02:04.000 --> 02:16.840]  гораздо более простым образом. Ну, как более простым образом? То есть, поиск сначала в глубину,
[02:16.840 --> 02:21.880]  поиск в глубину. Значит, поиск устроен буквально следующим образом. У нас есть какая-то вершина,
[02:21.880 --> 02:26.120]  ну и давайте, просто недолго думая, пойдем в произвольном направлении. То есть, вот у нас есть
[02:26.120 --> 02:37.160]  какое-то ребро. Давайте первое ребро, которое мы обнаружили, мы по нему пойдем. Зняли, пошли по
[02:37.160 --> 02:41.200]  ребру. Вот, потом мы эту вершину снова смотрим. Если у нее какое-то ребро, если у нее есть какое-то
[02:41.200 --> 02:45.560]  ребро, то, соответственно, абсолютно в произвольном направлении двигаемся. Ну, и так далее,
[02:45.560 --> 02:52.280]  до тех пор, пока у нас идется. Ну и, соответственно, таким вот образом мы все глубже и глубже внедряемся,
[02:52.280 --> 02:59.080]  внедряемся в наш граф. Вот, естественно, я думаю, вы понимаете, что в какой-то момент эта история
[02:59.080 --> 03:01.840]  может просто-напросто прекратиться. Ну, в какой момент это может прекратиться? Ну, например,
[03:01.840 --> 03:06.120]  вот у вершины может в принципе не оказаться соседей. Да? То есть, если у соседей вообще нет
[03:06.120 --> 03:11.240]  исходящих ребер, то идти больше некуда. Ну или, например, у нее соседей есть, вот какие-то такие,
[03:11.240 --> 03:16.320]  но при этом все эти соседи, они уже пройдены. Вот, все-таки мы хотим, если мы обходим граф,
[03:16.320 --> 03:19.360]  то все-таки каждую вершину хотим обещать ровно один раз. И вот, соответственно, вот таким
[03:19.360 --> 03:23.520]  вот образом вот на этой вершине обход прекращается. Вот. Что мы в этом случае делаем? Ну, какие есть
[03:23.520 --> 03:27.760]  предложения? Вот если вот мы шли-шли-шли, и в какой-то момент пришли до вершины, из которой в новую вершину,
[03:27.760 --> 03:34.000]  к сожалению, пойти нельзя. Да, давайте просто-напросто откатимся, вот забудем про эту вершину, скажем,
[03:34.000 --> 03:39.960]  что все, из нее все пути исчерпаны. Да, откатимся в последнюю посещенную вершину, и уже из нее будем
[03:39.960 --> 03:44.720]  продолжать, соответственно, наш обход. Вот. Ну, и снова, если из этой вершины больше некуда идти,
[03:44.720 --> 03:47.680]  то, соответственно, мы говорим, что все про нее мы забываем, из нее больше никаких путей мы
[03:47.680 --> 03:52.240]  найти не можем, и, соответственно, переходим в предыдущую вершину. Ну и так далее. Да, то есть,
[03:52.240 --> 03:55.520]  в принципе, история довольно понятна. То есть, алгоритм, ну, можно сказать, такой жадный. То есть,
[03:55.520 --> 03:59.800]  мы идем, пока идется, как только встретили какое-то препятствие, откатываемся назад и пытаемся
[03:59.800 --> 04:08.440]  пройти уже в какое-то другое место из предыдущей вершины. Вот. Все довольно, надеюсь, просто. Ну,
[04:08.440 --> 04:13.680]  собственно вот, алгоритм славесно описан здесь. Берем произвольную вершину. Проходим из нее
[04:13.680 --> 04:19.520]  произвольную, ничего не посещенную вершину по ребру. Вот. Если из черной вершины больше нет никакого
[04:19.520 --> 04:24.040]  ребра, то, соответственно, возвращаемся в предыдущую вершину и продолжаем обход. Вот. Если в итоге. Да,
[04:24.040 --> 04:27.920]  в итоге у нас что получится, в итоге, скажем, из этой вершины больше идти некуда, из этой вершины
[04:27.920 --> 04:32.380]  больше идти некуда, откатываемся назад. Идти некуда, идти некуда, идти некуда. Если мы в итоге вернулись
[04:32.380 --> 04:37.600]  старту вершины из нее снова идти некуда, то на этом наш обход завершается. Соответственно, мы обошли все
[04:37.600 --> 04:46.100]  вершины, до которых, в принципе, могли дотянуться. Вот. Пока все просто, да? Отлично. Так, значит,
[04:46.100 --> 04:56.900]  давайте еще раз нарисуем какой-нибудь граф и поговорим. В процессе, в результате реализации
[04:56.900 --> 05:03.420]  алгоритма, мы сейчас будем, точнее, вот наш алгоритм, алгоритм DFS, в процессе своей работы он,
[05:03.420 --> 05:10.460]  как правило, красит вершины в один из трех цветов. Ну, то есть, это принятое терминологи, что в процессе
[05:10.460 --> 05:14.420]  обхода в глубину у нас вершины красится в некоторый цвет. Значит, давайте о них договоримся. Значит,
[05:14.420 --> 05:19.060]  давайте помечать белым цветом вершины, которые еще не посещены. Ну, в частности, например, исходный
[05:19.060 --> 05:22.780]  граф, на котором мы еще не запустили обход глубину, он целиком белый, потому что у меня одной вершины
[05:22.780 --> 05:26.340]  еще не посетили. Дальше, соответственно, если мы посещаем какую-то вершину, например, вот выбрали в качестве
[05:27.220 --> 05:32.980]  стартную вершину вот эту вершину, соответственно мы ее помечаем серым цветом. Значит, сером цвета
[05:32.980 --> 05:38.100]  мы помечаем вершины, из которых в данный момент осуществляется обход глубину. То есть из которых мы
[05:38.100 --> 05:43.660]  в данный момент ищем какой-нибудь путь. Ну и, соответственно, давайте какой-нибудь пример
[05:43.660 --> 05:47.940]  придем. Вот у нас серая вершина, из нее мы идем в какую-нибудь другую вершину. Соответственно, мы ее
[05:47.940 --> 05:52.740]  обнаружили и покрасили в серый цвет. Дальше пошли вот в эту вершину покрасили в серый цвет. И, соответственно,
[05:52.740 --> 05:56.240]  Как только мы понимаем, что из вершины больше никакого пути мы не найдем,
[05:56.240 --> 06:01.360]  то есть как только мы понимаем, что из вершины все пути в уже пройденные вершины мы обошли,
[06:01.360 --> 06:03.740]  соответственно, в этот момент мы красим вершину в черный цвет.
[06:03.740 --> 06:08.260]  Т. ч., черный цвет означает, что вершина уже была обнаружена и из нее доступных путей нет.
[06:08.260 --> 06:13.060]  То есть не торчит ли бы ни одного ребра, либо все ребра торчат в уже высеченные вершины.
[06:13.180 --> 06:16.040]  Ну вот в частности, вот эта вершина ровно какая.
[06:16.040 --> 06:18.920]  Соответственно, мы заканчиваем ее обработку, красим ее в черный цвет.
[06:18.920 --> 06:20.780]  То же самое для...스� żдмhora
[06:20.780 --> 06:25.660]  то сами верны. Никаких новых вершин из нее обнаружить мы не можем. Красим в черный цвет.
[06:25.660 --> 06:29.220]  Вот дальше возвращаемся в эту вершину. Ну идем, не знаю, например, вот сюда. Красим в серый цвет.
[06:29.220 --> 06:33.340]  Из этой вершины можем пройти вот сюда, красим в серый цвет. Из этой вершины, например, вот сюда
[06:33.340 --> 06:38.300]  красим в серый цвет. Из этой вершины никуда пройти не можем, красим на черный цвет. Возвращаемся,
[06:38.300 --> 06:43.180]  идем, например, сюда, красим в серый цвет. Пройти больше некуда. Черный цвет. Возвращаемся сюда,
[06:43.180 --> 06:49.420]  черный цвет. Возвращаемся сюда, можем пройти вот по этом�,-HO-о сюда. соответственно, дальше
[06:49.420 --> 06:57.300]  все вершины у нас будут покрашены черный цвет. Ну да-да, красок никаких не надо использовать,
[06:57.300 --> 07:03.900]  нет. Да, то есть просто какие-то меточки. Белый, серый, черный. Да, 0, 1, 2. В общем, как вам удобно.
[07:03.900 --> 07:12.940]  Ну в общем случае нет. Иногда да, иногда нет. Вот в общем случае используем три цвета.
[07:12.940 --> 07:15.860]  Хотя в каком смысле хватит? Мы еще не знаем, для чего они нам нужны в принципе.
[07:15.860 --> 07:24.460]  Это отличный вопрос, о нем поговорим ближе к концу, когда будем говорить про свойства обхода в
[07:24.460 --> 07:29.300]  глубину, чем он вообще может быть полезен. На самом деле уже отсюда понятно, ну то есть одно из
[07:29.300 --> 07:36.940]  применений. Сток? Ну нет, на самом деле ничего таким образом мы не находим. В смысле, сток можно найти
[07:36.940 --> 07:42.860]  и просто на самом деле глядя на матрицу смежности или на списке смежности, для этого не обязательно
[07:42.860 --> 07:47.020]  доходить. Тут, например, понятное дело, что представьте, что у вас вот такой еще граф есть,
[07:47.020 --> 07:54.460]  такая компонента. Вот, вы в этом графе запустили обход глубины из этой вершины. Ну таким образом вы
[07:54.460 --> 08:01.860]  нашли все вершины, которые достижимы из вот этой стартовой вершины. Ну, например. Вот такое вот
[08:01.860 --> 08:05.360]  самое простое применение. Ну или скажем, если представьте, что у вас граф неориентированный,
[08:05.360 --> 08:08.500]  то есть у вас нет ориентации на ребрах, тогда вы просто находитесь в компонент у связанности.
[08:08.500 --> 08:13.500]  То есть все вершины, из которых компоненты, внутри которых, из любой вершины,
[08:13.500 --> 08:14.500]  можно добраться в любой другой.
[08:14.500 --> 08:24.500]  Если бы так было? Да, конечно.
[08:24.500 --> 08:26.500]  То есть я и говорю, что в случае ориентированного графа
[08:26.500 --> 08:28.500]  мы лишь находим множество достижимых из этих вершин.
[08:28.500 --> 08:32.500]  Нет, нет, естественно, в данном случае нет.
[08:32.500 --> 08:36.500]  Но ровно как и обход в ширину, тоже естественно обходят не все вершины,
[08:36.500 --> 08:39.500]  если вы запускаете из одной старта вершины.
[08:39.500 --> 08:42.500]  Вот. Да.
[08:42.500 --> 08:45.500]  Ну, значит, про свойства, какие вершины мы на самом деле обойдем, какие не обойдем,
[08:45.500 --> 08:46.500]  об этом тоже поговорим чуть позже.
[08:46.500 --> 08:49.500]  Да, кстати, еще один важный момент, про который я не сказал.
[08:49.500 --> 08:51.500]  Значит, параллельно давайте еще введем два таких понятия,
[08:51.500 --> 08:53.500]  которые нам в будущем пригодятся.
[08:53.500 --> 08:55.500]  Ну, соответственно, давайте введем их тоже.
[08:55.500 --> 08:57.500]  Сейчас пока изучаем алгоритм.
[08:57.500 --> 09:00.500]  Значит, тайм-ин, тайм-аут – это момент первого обнаружения вершин.
[09:00.500 --> 09:02.500]  То есть у нас еще дополнительно будет некоторое время.
[09:02.500 --> 09:05.500]  То есть, опять же, не в виде секундомера, а просто в виде некоторого счетчика.
[09:05.500 --> 09:08.500]  То есть, есть некоторое время тайм, которое изначально равно нулю.
[09:08.500 --> 09:11.500]  И, соответственно, после каждого действия мы этот счетчик постоянно увеличиваем.
[09:11.500 --> 09:15.500]  Вот. И, соответственно, вот по этому счетчику мы смотрим, в какой момент времени мы обнаружили...
[09:15.500 --> 09:19.500]  Мы впервые обнаружили вершины, в какой момент времени мы вышли из вершины, да, закончили обработку.
[09:19.500 --> 09:24.500]  Ну, не знаю, давайте быстренько вот с этим графом разберемся.
[09:24.500 --> 09:26.500]  По поводу времен.
[09:26.500 --> 09:30.500]  Ну, соответственно, давайте вот время захода будет в начале,
[09:30.500 --> 09:33.500]  и через черту будет время выхода.
[09:33.500 --> 09:38.180]  Вот, соответственно, стартовую вершину S мы обнаружили, естественно, в нулевой момент времени,
[09:38.180 --> 09:41.860]  дальше пошли вот в эту вершину. Дальше пошли в эту вершину, обнаружили ее
[09:41.860 --> 09:44.980]  в первый момент времени, дальше пошли в эту вершину. Обнаружили в второй момент времени,
[09:44.980 --> 09:48.820]  соответственно, закончили ее обработку в третий момент времени. Дальше вернулись
[09:48.820 --> 09:53.340]  в эту вершину, закончили обработку в четвертый момент времени, вернулись в эту вершину,
[09:53.340 --> 09:57.980]  и дальше пошли, ну, как мы ходили... вот сюда, соответственно, это произошло в пятый момент
[09:57.980 --> 10:01.600]  момент времени, дальше пошли сюда, это произошло в шестом
[10:01.600 --> 10:05.380]  момент времени, дальше пошли сюда, седьмой момент времени,
[10:05.380 --> 10:09.200]  потом сюда, восьмой момент времени, так, тут закончили
[10:09.200 --> 10:13.840]  обработку, нет, торопимся, значит пошли сюда, обнаружили
[10:13.840 --> 10:15.800]  эту вершину в седьмой момент времени, из неё больше
[10:15.800 --> 10:18.200]  никуда нельзя пойти, соответственно, мы закончим обработку
[10:18.200 --> 10:21.960]  и заканчиваем обработку в áсlordLEET invited τα cri夠com
[10:21.960 --> 10:24.880] Loose padSINGING tonal over bonding over systemsrea camp activity
[10:24.880 --> 10:30.000]  9 момент времени. В 10 момент времени мы завершили обработку. Дальше возвращаемся сюда, завершаем
[10:30.000 --> 10:37.320]  работу, 11, возвращаемся сюда, переходим вот сюда, 12, ну и соответственно и вершим таким образом
[10:37.320 --> 10:52.960]  обыденный. Смысл понятен, да? Вот, отлично. Ну и соответственно сам алгоритм, те в декоде,
[10:52.960 --> 10:58.040]  выглядит следующим образом. То есть у нас есть вот этот самый массив цветов, да, то есть мы, опять же,
[10:58.040 --> 11:01.440]  напоминаю, что мы договорились, что для каждой вершины, что каждая вершина у нас номируется
[11:01.440 --> 11:07.400]  некоторым уникальным идентификатором, да, некоторым уникальным числом от 0 до v-1. Вот,
[11:07.400 --> 11:11.720]  поэтому можем просто-напросто завести массив цветов. Вот, ну опять же там white это просто какой-то, ну либо,
[11:11.720 --> 11:17.600]  если мы говорим про C++, это какой-нибудь enumeration, да, или просто какая-нибудь чиселка 0, 1, 2 и так
[11:17.600 --> 11:22.840]  далее. Вот, изначально все вершины белые, дальше время захода в каждую вершину бесконечно,
[11:22.840 --> 11:28.280]  потому что мы не знаем пока ничего про них. Время выхода то же самое, ну и глобальное время равно 0.
[11:28.280 --> 11:34.880]  Вот, ну и соответственно глобально процедура обхода графа в глубину состоит из одной рекурсивной
[11:34.880 --> 11:39.520]  функции, которая вызывает сама себя. Ну, как обойти мне вершину, да, то есть у меня есть процедура
[11:39.520 --> 11:44.560]  dps-visit, которая принимает граф и принимает вершину, которую я в данный момент посещаю. Вот, в данный
[11:44.560 --> 11:48.840]  момент я посещаю вершину v, соответственно, что я должен сделать, когда я впервые вижу вершину v? Ну,
[11:48.840 --> 12:01.600]  я должен покрасить ее в серый цвет, да, ну вот одной, одной чертой. Вот так. Вот, потом время обхода
[12:01.600 --> 12:05.360]  тоже, соответственно, увеличиваю счетчик и присваиваю соответствующую ячейку.
[12:05.360 --> 12:13.920]  Time in — это время первого обнаружения вершины, то есть, ну просто время обнаружения вершины.
[12:13.920 --> 12:18.200]  Time out — это время завершения обработки вершины. То есть, когда мы в вершину только вошли,
[12:18.200 --> 12:24.160]  когда мы из вершины в последний раз вышли. Вот. Ну и дальше, собственно, просто-напросто в цикле
[12:24.160 --> 12:29.960]  перебираем всех соседей вершины v, да, и говорим, что если сосед белый, то есть, если сосед еще не
[12:29.960 --> 12:34.600]  посещен, да, но, соответственно, непосещенные вершины — это только белые вершины, мы рекурсивно
[12:34.600 --> 12:41.440]  запускаем обход из вершины u, да. Ну, то есть, вот как раз таки вот это и есть тот самый, значит,
[12:41.440 --> 12:46.160]  вот встретили непосещенного соседа, идем в него и уже продолжаем поиск из него. Вот. После того,
[12:46.660 --> 12:50.480]  как это поиск завершится, да, то есть, что это означает. Это означает, что я перешел,
[12:50.480 --> 12:54.640]  соответственно, в своего соседа и, соответственно, все допустимые пути уже перебрал.
[12:54.640 --> 13:00.580]  ТрCameron после этого я вернусь вот в эту исходную вершину В. Ну и продолжу, соответственно, обход,
[13:00.580 --> 13:06.500]  ну просто-напросто буду продолжать искать доступного соседа. Все, после того, как все
[13:06.500 --> 13:10.640]  соседи были, после того как все соседи я перебрал, да. Соответственно, что произойдет после этого цикла.
[13:10.640 --> 13:16.000]  Ну после этого цикла я просто-напросто уверен, что у меня все соседи точно не белые, да.君 меня не
[13:16.000 --> 13:19.600]  осталось белых соседей, соответственно, идти мне больше из этой вершины некуда. Ну все, значит в
[13:19.600 --> 13:25.080]  этот момент я могу завершать обработку вершины v, то есть я говорю, что цвет вершины v черный,
[13:25.080 --> 13:31.840]  и соответственно назначаю время выхода для вершины v, ну плюс-плюс time. Все в доход понятен, да?
[13:31.840 --> 13:41.240]  Окей, соответственно, ну вот ключевой вопрос здесь, каково время работы обхода графа в глубину,
[13:41.240 --> 13:51.120]  как вы думаете? Ну вот время в зависимости от числа вершин и в зависимости от числа ребер.
[13:51.120 --> 14:09.800]  Это от v плюс e, почему? Ну почти, да, действительно, смотрите, что делает вот этот вот рекурсивный
[14:09.800 --> 14:15.920]  запуск обхода в глубину. Ну смотрите, в худшем случае он посетит, ну сколько в худшем случае
[14:15.920 --> 14:20.600]  у нас будет запуска в DFS-визит? Ну не более чем v, да, то есть каждую вершину мы посещаем не больше
[14:20.600 --> 14:24.200]  чем один раз. Почему? Потому что как только мы посещаем вершину, она сразу становится серой,
[14:24.200 --> 14:28.400]  но это значит, что вызова DFS-визита от нее больше не будет, да, потому что новые DFS-визиты,
[14:28.400 --> 14:33.040]  они порождаются только для белых вершин. Вот, поэтому вот суммарно, вот если рассуждать,
[14:33.040 --> 14:37.280]  вот если посмотреть на все рекурсивные вызовы в ретерспективе, то соответственно мы увидим,
[14:37.280 --> 14:42.400]  что вот эти вот куски, которые занимают от единицы времени, они выполняются максимум v раз.
[14:42.400 --> 14:49.600]  Соответственно отсюда берется вот этот член v. Вот откуда берется вот это вот влагаемое e? Ну
[14:49.600 --> 14:54.520]  давайте просто-напросто посмотрим, сколько всего раз суммарно, да, за все время алгоритма у нас
[14:54.520 --> 14:59.200]  отработает, ну какое будет общее количество итераций вот этого цикла? Ну какое будет общее
[14:59.200 --> 15:05.000]  количество итераций этого цикла? Да, просто-напросто думаем о степеней вершин, да, потому что мы в каждую
[15:05.000 --> 15:08.880]  вершину заходим не более одного раза, и для каждой вершины мы просматриваем всех соседей.
[15:08.880 --> 15:13.000]  Ну соответственно, просматривая всех соседей вершины, мы, давайте вот тут распишем дальше,
[15:13.000 --> 15:19.720]  что это означает. Ну это, во-первых, тета от v, плюс тета от сумма по всем вершинам v,
[15:19.720 --> 15:27.200]  где v. Вот, ну а мы, собственно, говорили, что сумма степеней вершин, если что иное,
[15:27.200 --> 15:43.880]  как, ну просто-напросто e. Ну e или 2e? Где плюс? Ну в полустепени сходы, да. Ну опять же,
[15:43.880 --> 15:48.840]  тут есть небольшой нюанс, который связан со следующим. Тут мы должны обязательно уточнить,
[15:48.840 --> 15:56.280]  что, когда мы говорим про сложность работы над графом? Что? Ну, не обязательно. Тут, на самом деле,
[15:56.280 --> 16:00.320]  это же оценка сверху. То есть, действительно, у нас может быть какой-нибудь большой-большой граф здесь,
[16:00.320 --> 16:04.840]  с большим количеством вершин, ребер и так далее, и может быть маленький граф здесь,
[16:04.840 --> 16:13.080]  и мы запустили DFS вот на этом графе. Вот это все-таки, это оценка сверху. Вот. Я про другое. Я про то,
[16:13.080 --> 16:19.240]  что, да, вот, отлично, как хранить граф, а как мы тут храним граф? Мы тут об этом же не говорили. Вот.
[16:19.240 --> 16:24.040]  Ну, на что, на самом деле, тут влияет? Ну, где тут, на самом деле, возникает проблема с хранением
[16:24.040 --> 16:29.320]  графа? То есть, что там, что тут нам, на самом деле, нужно от графа? Ну, кажется, что нам единственное,
[16:29.320 --> 16:33.240]  что нужно, это узнавать с соседей вершины. То есть, у нас есть вершина, и мы хотим получить список ее
[16:33.240 --> 16:38.240]  соседей. Так вот, соответственно, если мы храним граф в виде матрицы смежности, да, то вот этот шаг
[16:38.240 --> 16:46.240]  сколько занимает? Да. Ну, соответственно, он занимает O от V. Вот. Что, соответственно, что, соответственно,
[16:46.240 --> 16:53.080]  приводит к тому, что появляется дополнительный член плюс V квадрат. Это для матрицы смежности.
[16:53.080 --> 16:58.000]  Вот. Ну, почему так, да? Потому что, еще раз повторю, что DFS-Visit для каждой вершины
[16:58.000 --> 17:01.920]  вызывается максимум один раз. Соответственно, мы максимум один раз для каждой вершины попросим
[17:01.920 --> 17:06.400]  список ее соседей. Ну, а в случае матриц смежности у нас список соседей получается за V. Ну, поэтому
[17:06.400 --> 17:14.720]  получается V на V, V квадрат. Вот. Если мы храним, соответственно, граф в виде списков смежности,
[17:14.720 --> 17:20.000]  да, то списки смежности мы из список соседей получаем за, ну, либо за DegWay, либо за вот единицы,
[17:20.000 --> 17:23.520]  в зависимости того, что мы под этим подразумеваем. Ну, так или иначе, это все равно на симптотику не
[17:23.520 --> 17:40.960]  влияет. Да? Это понятная история. Да, согласен. Тут O лучше писать. Да, ну, собственно, если мы один
[17:40.960 --> 17:45.680]  раз запустили DFS-Visit всего лишь одной вершины, то, да, действительно такая штука. Вот.
[17:45.680 --> 17:57.640]  Окей? Ну, вот, да, соответственно, при использовании списка смежности от V
[17:57.640 --> 18:04.400]  плюс E и для матриц смежности от V квадрат. Вот. Соответственно, можно теперь дать некоторую
[18:04.400 --> 18:11.560]  новую интерпретацию вот этим самым белым и серым вершинам. Да, вот у нас есть белые вершины,
[18:11.560 --> 18:14.840]  есть у нас серые вершины, есть черные. Что мы про них говорили раньше? Мы говорили, что белые
[18:15.080 --> 18:18.840]  вершины — те вершины, которые еще не поисчены, серые вершины — это те, из которых мы в данный
[18:18.840 --> 18:23.160]  момент ищем путь. Вот, и черные вершины — это те, на которые мы и завершили обработку. Ну, вот,
[18:23.160 --> 18:26.580]  в терминах, это алгоритмы, которые мы только что рассмотрели, можно им дать, соответственно,
[18:26.580 --> 18:30.800]  некоторую алгоритмическую интерпретацию в терминах нашего псевдокода. То есть что такое белая
[18:30.800 --> 18:36.080]  вершина? Белая вершина, из которой мы еще ни разу не запустили DFS-Visit. Да? То есть DFS-Visit
[18:36.080 --> 18:41.280]  еще ни разу не был запущен с аргументом V. Это такая вершина. Ну и что такое серая вершина?
[18:41.280 --> 18:45.220]  Серая вершина — это та вершина, из которой в данный момент происходит вызов DFS-Visit.
[18:45.220 --> 18:50.100]  И тут я хочу сделать следующее замечание, что, я надеюсь, вы понимаете,
[18:50.100 --> 18:52.820]  что серые вершины в любой момент времени в графе образуют некоторый путь.
[18:52.820 --> 18:57.500]  Почему? Потому что у нас DFS-Visit процедура какая? Она рекурсивная. И как она выглядит?
[18:57.500 --> 19:11.140]  У нас есть вызов DFS-Visit от вершины, допустим, V0. Этот вызов порождает вызов DFS-Visit от
[19:11.140 --> 19:21.700]  V1. Дальше этот вызов порождает вызов DFS-Visit от V2. Ну и так далее. Что можно сказать про вершины
[19:21.700 --> 19:27.740]  V0, V1, V2? Ну они все в данный момент серые, согласны? Потому что в данный момент мы занимаем всех
[19:27.740 --> 19:34.760]  обработки и в данный момент мы ищем из них некоторый путь, некоторый обход. Соответственно,
[19:34.760 --> 19:38.940]  во-первых, серая вершина — это та вершина, из которой в данный момент запущен DFS. А во-вторых,
[19:38.940 --> 19:43.460]  так как мы имеем представление о стеке вызовов, о том, что стек вызовов — это некоторая, скажем так,
[19:43.460 --> 19:47.300]  линейная структура данных, то это означает, что серая вершина в любой момент времени в графе
[19:47.300 --> 19:53.820]  образует путь. Согласны? Вот. Ну и наконец, черная вершина — это та вершина, от которой был запущен
[19:53.820 --> 20:07.060]  когда-то DFS-Visit, но при этом этот вызов уже завершился. Окей? Окей. Отлично. Ну и соответственно,
[20:07.060 --> 20:12.100]  вот то, о чем вы как раз говорили. Что если мы хотим на самом деле запустить DFS, ну, запустить
[20:12.100 --> 20:16.060]  обход глубину не от одной вершины, ну, то есть взять ни одну стартовую вершину, а сделать так,
[20:16.060 --> 20:19.740]  чтобы обход обошел все вершины сразу, можно воспользоваться еще вот таким вот алгоритмом,
[20:19.740 --> 20:25.660]  просто алгоритмом DFS, который просто принимает граф. Соответственно, в этой функции мы задаем
[20:25.660 --> 20:30.580]  начальные цвета, задаем время обхода, время выхода и просто текущее время. Ну и соответственно,
[20:30.580 --> 20:34.740]  просто в цикле запускаем DFS-Visit от каждой вершины. Ну, точнее, не от каждой вершины, а вот, скажем,
[20:35.460 --> 20:39.480]  берем какую-нибудь произвольную вершину, да, смотрим, если эту вершину мы еще ни разу не посещали,
[20:39.480 --> 20:43.160]  то, соответственно, используем эту вершину как стартовую, да, запускаем из нее DFS-Visit.
[20:43.160 --> 20:47.920]  То есть этот вызов DFS-Visit таким образом обходит какую-то часть графа, соответственно,
[20:47.920 --> 20:52.600]  какая-то часть графа оказывается посещенной, а какая-то часть графа не посещена, вот. Соответственно,
[20:52.600 --> 20:57.340]  вот в этом цикле мы ищем первую не посещенную вершину и запускаем из нее DFS-Visit. Ну и соответственно,
[20:57.340 --> 21:02.420]  после того, как все вершины окажутся в итоге посещены, мы завершаем общий обход DFS. Ну понятно, да?
[21:02.420 --> 21:09.420]  Давайте еще проговорим следующую историю, для чего может быть полезен вот такой вот алгоритм.
[21:09.420 --> 21:12.420]  Ну, представьте себе, что у вас какой-то вот такой вот граф.
[21:12.420 --> 21:22.420]  Вот, и вы хотите найти, пронумеруем как-нибудь 0, 1, 2, 3, 4, 5, 6.
[21:22.420 --> 21:25.420]  Вот, и вы хотите найти компоненты связности.
[21:25.420 --> 21:29.420]  Да, у нас есть такой компонент связности, это значит, наибольший по включению под граф,
[21:29.420 --> 21:31.420]  в котором мы из любой вершины можем добраться до любой другой.
[21:31.420 --> 21:33.420]  Ну, это в неориентированном графе.
[21:33.420 --> 21:36.420]  Ну, соответственно, что мы делаем? Мы запускаемся из вершины номер 0.
[21:36.420 --> 21:42.420]  И вот этот вот вызов DFSVisit от 0 посетит мне вот эти вершины.
[21:42.420 --> 21:45.420]  Дальше, соответственно, я возвращаюсь в исходную функцию DFS.
[21:45.420 --> 21:48.420]  Ищу первую непосещенную вершину. Первую непосещенную вершину, допустим, это 1.
[21:48.420 --> 21:51.420]  Из нее запускаю DFS, и это DFS и DFSVisit.
[21:51.420 --> 21:54.420]  Этот DFSVisit обойдет все вот эти вершины.
[21:54.420 --> 21:56.420]  Дальше, соответственно, в этом цикле найду вершину 5.
[21:56.420 --> 21:59.420]  Запущу от нее DFSVisit, который посетит только ее.
[21:59.420 --> 22:01.420]  Ну и дальше вершина 6 обойдет только ее.
[22:01.420 --> 22:06.420]  Соответственно, каждый вызов dfs-visit в этом цикле найдет мне свою компоненту связанности.
[22:06.420 --> 22:08.420]  Понятно?
[22:08.420 --> 22:10.420]  Окей.
[22:14.420 --> 22:16.420]  Да, ну и давайте еще...
[22:16.420 --> 22:19.420]  Соответственно, если с алгоритмом все более-менее понятно,
[22:19.420 --> 22:22.420]  то есть как его реализовывать, как он работает и так далее,
[22:22.420 --> 22:25.420]  давайте поговорим про чуть более теоретические вещи.
[22:25.420 --> 22:28.420]  Ну, значит, для начала поговорим про классификацию ребер,
[22:28.420 --> 22:31.420]  потом поговорим, докажем корректность, соответственно, обхода в глубину,
[22:31.420 --> 22:36.420]  то есть действительно покажем, что алгоритм действительно корректно обойдет все вершины и и так далее,
[22:36.420 --> 22:43.420]  ну а потом в конце поговорим про несколько н context relevant
[22:43.420 --> 22:47.420]  Так, о чем хочется сейчас поговорить...
[22:47.420 --> 22:49.420]  Давайте поговорим про дерево обхода в глубину.
[22:49.420 --> 22:57.420]  Вот в процессе обхода в глубину процедуры dfs-visit строит некоторое дерево обхода.
[22:57.420 --> 23:03.780]  дерево обхода. Ну что такое дерево обхода? Давайте я вот этот граф перельсую и покажу на примере.
[23:03.780 --> 23:22.100]  Допустим, в качестве стартовой вершины взяли эту вершину. Соответственно, как у нас устроен обход?
[23:22.100 --> 23:25.820]  Ну допустим, то есть обход, понятное дело, может идти в произвольном порядке, в зависимости от
[23:26.240 --> 23:29.560]  нумерации или в зависимости от обхода соседей, то допустим у нас обход устроен следующим образом.
[23:29.560 --> 23:34.580]  Мы сначала прошлись по вот этому ребру, потом из этой вершины пошли по вот этого ребру,
[23:34.580 --> 23:40.940]  потом, соответственно, и так как больше некуда вернулись в эту вершину, пошли из этой вершины
[23:40.940 --> 23:46.080]  вот сюда, из нее идти больше некуда, поэтому вернулись сюда и вернулись сюда и прошли вот по этому
[23:46.080 --> 23:52.600]  ребру. Давайте посмотрим вот на красные ребра, посмотрим на те ребра, по которым мы в процессе
[23:52.600 --> 23:57.360]  обходы в глубину. Согласны ли вы, что эти вершины, что эти рёбра, ну и вообще вот этот
[23:57.360 --> 24:02.480]  граф, красным цветом, который был обозначен, образует дерево. Ну это понятно, да, потому что
[24:02.480 --> 24:07.800]  какое у нас свойство, что такое ориентированное бинарное дерево. Значит, это дерево, у которого у каждой
[24:07.800 --> 24:13.240]  вершины есть ровно одно входящее ребро, кроме, может быть, одной, которая, собственно,
[24:13.240 --> 24:17.240]  является корнем. Ну и действительно так и есть. Мы каждую вершину обнаруживаем по какому-то
[24:17.240 --> 24:22.400]  ребру, ну и плюс у нас есть ровно одна вершина, из которой мы стартовали обход DFSVisit. Понятно.
[24:22.400 --> 24:27.520]  Вот. Соответственно, вот такое вот дерево, которое образовано рёбрами, по которым мы находили
[24:27.520 --> 24:36.080]  непосещенные вершины, называется деревом обхода в глубину. Отлично. Соответственно, да, если у вас
[24:36.080 --> 24:43.600]  есть несколько компонент, если у вас было несколько компонент, несколько компонент связности,
[24:43.600 --> 24:48.160]  и вы несколько раз запускались, запускали DFSVisit, то, соответственно, каждый DFSVisit вам
[24:48.160 --> 24:53.200]  породит своё собственное дерево обхода в глубину, и вот этот вот набор деревь называется лесом
[24:53.200 --> 24:58.400]  обхода в глубину. Ну это, значит, что касается терминологии. Пока всё нормально, да? Отлично.
[24:58.400 --> 25:04.920]  Значит, ну и давайте, собственно, в связи с этим, в связи с этим, каждое ребро,
[25:04.920 --> 25:10.320]  каждый ребро графа может быть отнесено к одному из четырёх видов. Вот давайте про них поговорим.
[25:10.320 --> 25:20.320]  Тут я немного, давайте вернём чёрный цвет, чтобы было консистентно с тем, что написано там.
[25:20.320 --> 25:27.880]  Значит, каждое ребро графа после обхода в глубину может быть отнесено к одному из четырёх видов.
[25:27.880 --> 25:34.000]  Значит, первый вид ребер – это ребра дерева. Вот, ну давайте, они жирным чёрным цветом обозначены.
[25:34.000 --> 25:39.040]  Значит, ребра дерева – это те ребра, по которым я находил новые вершины. Собственно,
[25:39.040 --> 25:44.040]  ребра дерева – это ровно те ребра, которые образуют дерево обхода в глубину. Окей? Окей.
[25:44.040 --> 25:49.280]  Соответственно, давайте, наверное, вот на этом графе, на этот граф перейдём.
[25:49.280 --> 26:12.200]  Вот так. Ну и соответственно, давайте зададим какой-нибудь обход.
[26:12.200 --> 26:16.840]  Ну давайте скажем, пусть обход проходил следующим образом. Мы стартовали из нулевой вершины,
[26:16.880 --> 26:23.080]  дальше пошли вершину с номером 2. Соответственно, так как мы вершину номер 2 обнаружили вот по
[26:23.080 --> 26:28.040]  этому ребру, то это ребро будет являться ребром дерева. Дальше, соответственно, мы пошли куда?
[26:28.040 --> 26:35.080]  Ну давайте пойдём вот так. Вершина номер 1. Соответственно, вот это ребро тоже стало ребром дерева.
[26:35.080 --> 26:41.400]  Дальше пошли вот сюда. Это ребро тоже стало ребром дерева. Дальше пошли, ну вернулись обратно в единицу,
[26:41.400 --> 26:46.280]  пошли сюда. Ребро 1-4 тоже стало ребром дерева. Ну и соответственно, закончили обход. Вот, соответственно,
[26:46.280 --> 26:51.840]  вот эти вот четыре ребра – это ребра дерева. Потому что они принадлежат дереву обхода в глубину.
[26:51.840 --> 26:55.880]  Дальше обратные ребра. Значит, обратными ребрами мы будем называть такие ребра,
[26:55.880 --> 27:03.320]  которые ведут из потомка в предка. То есть, грубо говоря, ведут ребра, которые ведут обратно в
[27:03.320 --> 27:08.560]  корень, ну или обратно поближе к корню. Ну соответственно, такие у нас остались неклассифицированные
[27:08.560 --> 27:13.680]  ребра. Значит, вот это ребро, вот это ребро и вот это ребро. Какой из этих трёх ребр, как вы думаете,
[27:13.680 --> 27:23.280]  относится к классу обратных ребр? Что такое первое ребро? Да, ну ребро 3-0. Да, действительно,
[27:23.280 --> 27:27.960]  ребро 3-0 в данном случае является обратным ребром. Почему? Потому что если мы посмотрим на ребра
[27:27.960 --> 27:32.680]  дерева, то что у нас происходит? У нас стройка является потомком нуля и при этом ребро из стройки
[27:32.680 --> 27:38.000]  ведет в 0. То есть, ведет из потомка в предка. То есть, ребро 3-0 – это обратное ребро. Дальше,
[27:38.000 --> 27:43.280]  следующий набор ребра – это прямые ребра. Прямые ребра – это наоборот. Те ребра,
[27:43.580 --> 27:48.360]  которые ведут из предков в потомков, но при этом не своих непосредственных сыновей. Ну, короче говоря,
[27:48.360 --> 27:51.840]  можно сказать, что прямое ребро, это ребро, которое ведет из предков в потомка, но при этом не является
[27:51.840 --> 27:59.780]  ребром дерева. Ну и допустим вот, ребро дерева – это отношение типа там – отец сын. Соответственно
[27:59.780 --> 28:05.720]  прямое ребро – это отношение там дедушка сын… ой, дедушка. Ну и собственно, ребенок. Есть ли здесь
[28:05.720 --> 28:12.160]  в этом графе прямые ребра? Да, ребро 0-4 является действительно прямым. Потому что, действительно,
[28:12.160 --> 28:18.880]  это ребро ведет из предка в потомка, то есть они связаны непосредственно родцом 0.1.4, но при этом
[28:18.880 --> 28:23.720]  четверка не является непосредственным сыном нуля. Ну и последний класс ребер, значит про него
[28:23.720 --> 28:27.760]  можно сказать следующее, что все остальные ребра относятся к классу перекрестных ребер, но мы скажем
[28:27.760 --> 28:33.440]  следующее, что перекрестное ребро это такое ребро, которое соединяет два разных поддерева. То есть,
[28:33.440 --> 28:37.040]  смотрите, ребра дерева, они соединяют родственные вершины. Родственные вершины в том смысле, что,
[28:37.040 --> 28:43.360]  скажем, это родитель, это ребенок. Соответственно, обратное ребро ведет из потомка в предка. Прямое
[28:43.360 --> 28:47.440]  ребро ведет из предка в потомка. А если ребро соединяет какие-то вершины, которые не соединены
[28:47.440 --> 28:51.400]  каким-то родством, не соединяя отношения предок-потомок, то соответственно такое ребро будет
[28:51.400 --> 28:59.160]  называться перекрестным. Ну и соответственно тут интриги нет, то есть ребро 4.2 является перекрестным
[28:59.160 --> 29:02.880]  ребром. Почему? Потому что ни четверка не является предком двойки, ни двойка не является предком
[29:02.880 --> 29:08.040]  четверки. То есть, вот это ребро соединяет два разных поддерева. То есть, вот это поддерево и вот
[29:08.040 --> 29:21.320]  это поддерево, которое стоит только из двойки. Понятно, да? Вот такая вот классификация. Ну и
[29:21.320 --> 29:29.680]  действительно, кажется, получилось так, как нужно. Ну и соответственно, главный вопрос. Вот мы ввели какую-то
[29:29.680 --> 29:33.240]  классификацию. Пока на самом деле не понятно, для чего мы ее ввели, но она нам будет удобна, когда
[29:33.240 --> 29:37.320]  мы будем говорить про всякие ребра Grab, когда будем обсуждать всякого рода применения. То есть,
[29:37.320 --> 29:41.960]  мне будет удобнее говорить про то, что вот если мы нашли обратное ребро, если у нас есть прямое
[29:41.960 --> 29:46.040]  ребро и так далее, вот в таких терминах будет рассуждать проще. Ну прежде чем в таких терминах
[29:46.040 --> 29:50.560]  рассуждать, давайте обсудим следующую вещь. Ну хорошо, вот мы умеем запускать DFS. Вот сейчас
[29:50.560 --> 29:55.120]  научились работать с алгоритмом DFS. То есть, привели псевдокод и так далее. Ну и ключевой вопрос
[29:55.120 --> 29:59.520]  получается следующим. А можно ли как-то во время обхода в глубину понять, а какое ребро сейчас перед
[29:59.520 --> 30:04.680]  нами? То есть, вот я сейчас нашел какое-то ребро из вершины V, вершины U. Мне хочется понять, а это
[30:04.680 --> 30:09.720]  ребро какое? Оно ребро дерева, оно прямое ребро, обратное ребро и так далее. Вот какие у вас есть на этот
[30:09.720 --> 30:17.640]  счет идеи? Вот, например, давайте пойдем в порядок. Вот как мне понять, передо мной ребро дерева или нет?
[30:17.640 --> 30:32.200]  В каком смысле прошлись? Да, ребро дерева очень просто. По ребро дерева мы просто-напросто обнаруживаем
[30:32.200 --> 30:36.760]  белые вершины. Согласны? Просто-напросто, по определению, ребра дерева это те ребра, по которым мы
[30:36.760 --> 30:45.240]  проходим в новые вершины. Обнаружили белую вершину. То есть, если ребро ведет в белую вершину, то
[30:45.240 --> 30:52.960]  соответственно это ребро является ребром дерева. То есть, это в процессе обхода в глубину. Дальше, как понять, что
[30:52.960 --> 30:57.000]  передо мной обратное ребро? Да.
[31:13.000 --> 31:17.880]  А вот сам алгоритм как устроен? То есть, вы предлагаете пройтись по всему графу и найти все
[31:17.880 --> 31:19.880]  переходы из белой вершины в серую вершину?
[31:19.880 --> 31:47.880]  Да, кстати, 0,4. Ну, то есть, нет, ваше предложение понятно. То есть, если ребро 3 лежит в форме 0,4, то это
[31:47.880 --> 31:54.880]  если ребро 3 лежит в пределах от того времени, когда я посетил вершину 0 и закончил ее обработку, то
[31:54.880 --> 32:02.880]  соответственно это ее предок. В принципе, норм, план нормальный, но можно гораздо проще. В терминах
[32:02.880 --> 32:16.880]  используй просто цвет. Так, ну давайте обсудим черную ли серую. Вот смотрите, вот у меня есть вершина, она
[32:16.880 --> 32:23.880]  серая. И вот я обнаружил ребро в черную вершину. Верно ли, что это ребро обратное? Нет, почему?
[32:23.880 --> 32:30.880]  Потому что, ну банальный пример, ну да, оно может быть вполне себе перекрестом. Вот как здесь, да?
[32:30.880 --> 32:36.880]  Ну, кстати, вот здесь такая ситуация была. Вот, я сначала прошел в двойку, потом, допустим, прошел в четверку,
[32:36.880 --> 32:41.880]  и соответственно это уже будет у меня перекрестное ребро. Вот, ну хорошо, а теперь давайте рассмотрим ситуацию
[32:41.880 --> 32:53.880]  все-таки. Вот, смотри, действительно, а если я обнаружил ребро, которое ведет в серую вершину, если я обнаружил
[32:53.880 --> 32:57.880]  ребро, которое ведет в серую вершину, то это как раз то, что мне нужно. А почему? Потому что, опять же, мы
[32:57.880 --> 33:05.880]  говорили про то, что серые вершины всегда образуют путь, да? Да, и, соответственно, да, вот, соответственно,
[33:05.880 --> 33:15.880]  если я обнаружил какое-нибудь такое ребро, то, собственно, это и означает ровно то, что мне нужно, да? То есть,
[33:15.880 --> 33:19.880]  эта вершина является непосредственным предком вот этой вершины. Вот, соответственно, из этой вершины,
[33:19.880 --> 33:26.880]  из потомка я нашел, я нашел ребро, которое ведет в предко. Все, соответственно, второй пункт обнаружили.
[33:33.880 --> 33:34.880]  Да.
[33:42.880 --> 33:43.880]  Нет, просто вот так проще.
[33:50.880 --> 33:56.880]  Смотрите, что у нас происходит, как происходит классификация, как происходит классификация ребр.
[33:56.880 --> 33:58.880]  Бла-бла-бла, где у нас алгоритм?
[34:04.880 --> 34:09.880]  Вот, то есть мы можем классифицировать ребра непосредственно во время обхода, во время обхода в глубину.
[34:09.880 --> 34:15.880]  Да, каким образом? Вот, смотрите, у нас тут, вот у нас есть цикл по всем соседям. Значит, тут, если сосед у нас белый,
[34:15.880 --> 34:20.880]  соответственно, тут мы можем вставить там какую-нибудь строчку типа «ребро ВУ является ребром дерева».
[34:20.880 --> 34:26.880]  Дальше, тут мы можем дополнительно еще вставить проверку, что если мой сосед серый, то это значит, что ребро ВУ является обратным ребром.
[34:26.880 --> 34:33.880]  И все, и без там всяких проверок на там таймин, таймалт и так далее. Вот. Вот это про это.
[34:33.880 --> 34:47.880]  Так, ну у нас осталось еще два, у нас осталось еще два типа ребер. Это прямые и перекрестные ребра.
[34:47.880 --> 34:58.880]  Ну, я думаю, вы понимаете, что и прямое и перекрестное ребро – это те ребра, по которым мы обнаруживаем,
[34:59.880 --> 35:08.880]  обнаружили черную вершину. Вот.
[35:08.880 --> 35:16.880]  Но как при этом отличить прямой ребро от перекрестного? Какие есть предложения?
[35:16.880 --> 35:25.880]  Вот как понять? Ну, смотрите, у меня есть вот такая вот ситуация. Есть вершина В, есть вершина У.
[35:25.880 --> 35:35.880]  Я хочу понять, это прямое или перекрестное?
[35:35.880 --> 35:41.880]  Так нет, у нас всегда, мы сказали, что если мы обнаружим белую вершину, то это ребро дерева.
[35:41.880 --> 35:47.880]  То есть мы сказали, что если мы обнаружим белую вершину, то это ребро дерева.
[35:47.880 --> 35:55.880]  Если мы обнаружили серую вершину, то это обратный ребро. Соответственно нас остается одна возможность,
[35:55.880 --> 35:59.880]  если мы видим черную вершину. Ну а черную вершину, вершину мы видим в одном из двух случаев.
[35:59.880 --> 36:02.880]  Точнее, мы видим черную вершину и в случае, когда мы видим прямой ребро,
[36:02.880 --> 36:04.880]  и в случае, когда мы видим перекрестное ребро.
[36:04.880 --> 36:08.880]  Вопрос теперь как вот? Мы поняли, что мы видим черную вершину.
[36:08.880 --> 36:20.880]  Так, ну действительно, смотрите, я, допустим, видел черную вершину, и что я знаю?
[36:20.880 --> 36:26.880]  Допустим, я знаю, что время обнаружения этой вершины было раньше, чем время обнаружения этой вершины.
[36:26.880 --> 36:32.880]  Что это означает? Это означает, что под дерево, связанное с этой вершиной, я уже обошел.
[36:32.880 --> 36:36.880]  И в данный момент я обхожусь совсем другое под дерево.
[36:36.880 --> 36:58.880]  Но, собственно, это и означает, что, собственно, если у меня время входа в эту вершину было раньше, то, соответственно, все нормально.
[36:58.880 --> 37:04.880]  Если время входа в эту вершину было раньше, то, соответственно, это под дерево я обошел когда-то давно.
[37:04.880 --> 37:07.880]  Вот, и теперь из какого-то другого под дерево вижу вот эту вершину.
[37:07.880 --> 37:09.880]  Согласны?
[37:09.880 --> 37:12.880]  Вот, то есть, тут что можно будет писать для такого случая, что...
[37:12.880 --> 37:15.880]  Так, третий случай у нас прямое ребро. Ой, перекрестное ребро.
[37:15.880 --> 37:26.880]  Да, что у меня тайминут В, тайминут У меньше, чем тайминут В.
[37:26.880 --> 37:29.880]  Ну, обратная ситуация. Мы рассмотрели случай перекрестного ребра.
[37:29.880 --> 37:31.880]  А теперь представляем себе случай прямого ребра.
[37:31.880 --> 37:39.880]  Это означает, что я когда-то встретил вот эту вершину, что-то обходил, обходил, обходил.
[37:39.880 --> 37:42.880]  Вот, в какой-то момент завершил обработку вот этой вершины.
[37:42.880 --> 37:45.880]  И потом снова из этой вершины обнаружил вот эту вершину.
[37:45.880 --> 37:46.880]  Да?
[37:46.880 --> 37:48.880]  Ну, ситуация примерно вот такая.
[37:48.880 --> 37:55.880]  У меня есть вершина В, у нее есть какое-то под дерево, тут есть вершина У.
[37:55.880 --> 38:00.880]  Соответственно, я сначала нашел какой-то путь до У, а потом, с помощью этого ребра, с помощью какого-то другого ребра, снова нашел путь до У.
[38:00.880 --> 38:01.880]  Да?
[38:01.880 --> 38:04.880]  Но в этот момент вершина У уже черная, потому что я ее обработку раньше завершил.
[38:04.880 --> 38:05.880]  Понятно?
[38:06.880 --> 38:13.880]  Все, соответственно, этот случай, когда у меня тайминут В, наоборот, меньше, чем...
[38:18.880 --> 38:19.880]  Что еще раз?
[38:21.880 --> 38:22.880]  Вот для этого?
[38:22.880 --> 38:25.880]  Ну, смотри, давайте тут ведем времена.
[38:26.880 --> 38:32.880]  То есть, допустим, тут время входа – ноль, тут время входа – 1, тут время входа 2, время входа 3, время входа 4.
[38:32.880 --> 38:33.880]  Вот.
[38:33.880 --> 38:34.880]  Давайте рассмотрим пример.
[38:34.880 --> 38:37.880]  Вот я вижу вот такой, в какой-то момент я видел вот такое ребро.
[38:37.880 --> 38:40.880]  Значит, это ребро вело из серой вершины в черную вершину.
[38:40.880 --> 38:41.880]  Да? Я смотрю.
[38:41.880 --> 38:43.880]  Тайминут В – ответ этой вершины.
[38:43.880 --> 38:45.880]  Месячем тайминут В от этой вершины.
[38:45.880 --> 38:47.880]  Соответственно, это прямое ребро.
[38:47.880 --> 38:48.880]  Вот.
[38:48.880 --> 38:50.880]  Давайте теперь рассмотрим случай синего ребра.
[38:50.880 --> 38:56.440]  У меня timeIn исходной, то есть начальной вершины больше, чем время входа в конечную вершину
[38:56.440 --> 38:58.440]  Но, соответственно, это перекрестное ребро
[38:58.440 --> 39:00.440]  Понятно?
[39:00.440 --> 39:03.440]  Тут 0,4, тут 4,1
[39:03.440 --> 39:09.440]  То есть в зависимости от того, где у вас timeIn раньше, вы относите либо к перекрестному случае, либо к прямому случаю
[39:09.440 --> 39:11.440]  Понятно?
[39:11.440 --> 39:13.440]  Нормально?
[39:13.440 --> 39:15.440]  Окей
[39:15.440 --> 39:19.440]  Так, ну и давайте делаем перерыв, ну и перед перерывом небольшое упражнение на подумать
[39:20.000 --> 39:25.000]  Вот докажите, что в случае неориентированного графа, вот если у вас граф неориентированный
[39:25.000 --> 39:29.000]  В неориентированном графе не существует ни третьего, ни четвертого случая
[39:29.000 --> 39:33.000]  То есть в неориентированном графе всегда встречается либо ребро дерева, либо обратное ребро
[39:33.000 --> 39:35.000]  Вот других ребер нет
[39:35.000 --> 39:38.000]  Вот, ну и так, упражнение
[39:38.000 --> 39:40.000]  Всё, перерыв
[39:40.000 --> 39:44.000]  Да, соответственно, разобрались с классификацией ребер
[39:44.000 --> 39:46.000]  Что там дальше, интересно
[39:46.000 --> 39:48.000]  А, корректность, отлично
[39:48.560 --> 39:50.560]  Соответственно
[39:51.560 --> 39:54.560]  Значит, давайте теперь перейдём к тому, что
[39:54.560 --> 39:58.560]  Докажем, собственно, несколько свойств обхода в глубину
[39:58.560 --> 40:04.560]  Ну и вообще докажем корректность, что действительно наш алгоритм обхода в глубину посетит нужные нам вершины
[40:04.560 --> 40:09.560]  То есть всё-таки, вроде как это понятно, но всё-таки надо это строго обосновать
[40:09.560 --> 40:12.560]  Ну а потом перейдём к некоторым применениям
[40:12.560 --> 40:16.560]  Ну, соответственно, ключевое утверждение заключается в следующем
[40:17.120 --> 40:21.120]  Значит, если вы возьмёте обход в глубину, вот, допустим, вот вы запустили обход глубину
[40:21.120 --> 40:25.120]  Вот, говорит, работает, работает, работает, вот, в какой-то момент вы нажали на паузу
[40:25.120 --> 40:32.120]  Вот, нажали на паузу и решили просто-напросто посмотреть, вот, в графе какие, вот, какие цвета вершина есть, какие переходы, при переходе есть графさ
[40:33.120 --> 40:38.120]  Так вот утверждается следующее, что ни в какой момент времени, в какой момент времени, вы не остановили ваш алгоритм
[40:38.120 --> 40:41.120]  Вы не найдёте чёрно-белого перехода
[40:41.120 --> 40:46.120]  То есть не существует такого, не в один момент времени не может быть такого, что у вас есть чёрная вершина
[40:46.120 --> 40:50.120]  И из нее ведет ребро в белую вершину. Вот.
[40:53.120 --> 40:55.120]  И с определением чего?
[40:55.120 --> 40:59.120]  Ну, из построения алгоритма действительно утверждение тривиально.
[40:59.120 --> 41:02.120]  Давайте очень короткое доказательство.
[41:02.120 --> 41:05.120]  Допустим, такое есть.
[41:05.120 --> 41:08.120]  Допустим, у меня есть какая-то вершина В, и есть вершина У.
[41:08.120 --> 41:11.120]  Из черной вершины В ведет переход в белую вершину У.
[41:11.120 --> 41:13.120]  Кого?
[41:13.120 --> 41:16.120]  Да, давайте посмотрим, вот что произошло.
[41:16.120 --> 41:25.120]  Что было, короче, до того, как В стала черной.
[41:25.120 --> 41:27.120]  Что было?
[41:27.120 --> 41:30.120]  Вот непосредственно до того, как вершина В почернела.
[41:32.120 --> 41:35.120]  Отлично. А в алгоритме что происходило?
[41:36.120 --> 41:45.120]  Да, мы обошли всех соседей.
[41:45.120 --> 41:47.120]  Вот.
[41:48.120 --> 42:05.120]  Если сосед белый, то запускаем DFS-визит от него.
[42:07.120 --> 42:09.120]  Но что мы видим?
[42:09.120 --> 42:11.120]  Мы видим, что у нас есть вершина В.
[42:11.120 --> 42:13.120]  Мы обходили всех ее соседей.
[42:13.120 --> 42:16.120]  Если ее сосед был белый, то мы запускали от нее DFS-визит.
[42:16.120 --> 42:20.120]  Но если мы запускали от нее DFS-визит, то она как минимум должна быть серой.
[42:20.120 --> 42:26.120]  Потому что у нас вершины в графе только чернеют со временем, как бананы.
[42:26.120 --> 42:28.120]  Понятно, да?
[42:28.120 --> 42:31.120]  Поэтому белой вершины У никак остаться не могло.
[42:31.120 --> 42:33.120]  Поэтому мы пришли к противоречию.
[42:33.120 --> 42:40.120]  У не могла остаться белой.
[42:41.120 --> 42:43.120]  Все.
[42:45.120 --> 42:49.120]  Тривиальное просто утверждение, которое просто следует из дизайна алгоритма.
[42:49.120 --> 42:51.120]  Значит, упражнения.
[42:51.120 --> 42:54.120]  Оказывается, что только черно-белых переходов не существует.
[42:54.120 --> 42:56.120]  Все остальные переходы, возможно.
[42:56.120 --> 43:02.120]  Возможно, в ситуации, что из графе есть белый-черный переход, белый-серый переход, серый-черный, серый-серый и так далее.
[43:02.120 --> 43:04.120]  Все остальные переходы, возможно, только такого нет.
[43:04.120 --> 43:10.120]  Упражнения просто попробуйте привести примеры для каждой из ситуаций.
[43:10.120 --> 43:12.120]  Понятно, да?
[43:12.120 --> 43:14.120]  Окей.
[43:14.120 --> 43:20.120]  Ну и, наконец, основная теорема, из которой следует почти все применения обходов в глубину,
[43:20.120 --> 43:24.120]  ну вообще все теоремы о корректности других алгоритмов,
[43:24.120 --> 43:28.120]  они так или иначе опираются на так называемую лему о белых путях.
[43:28.120 --> 43:30.120]  Значит, звучит она следующим образом.
[43:30.120 --> 43:34.120]  Допустим, у меня есть вызов DFSVisitOTV.
[43:34.120 --> 43:36.120]  Вот я запускаю DFSVisitOTV.
[43:36.120 --> 43:38.120]  И допустим, в процессе этого вызова я посетил вершину U.
[43:38.120 --> 43:40.120]  Так вот, это происходит в том и только в том случае,
[43:40.120 --> 43:46.120]  если в момент вызова DFSVisitOTV у меня существовал путь, состоящий из белых вершин, из V в U.
[43:46.120 --> 43:48.120]  Понятно?
[43:48.120 --> 43:52.120]  Вот если в момент вызова DFSVisitOTV у меня есть путь, состоящий только из белых вершин,
[43:52.120 --> 43:54.120]  то это значит, что вершину U я в любом случае посещу.
[43:54.120 --> 43:56.120]  Ну и обратное тоже верно.
[43:56.120 --> 43:58.120]  Если я вершину U посетил, то это значит, что изначально у меня был белый путь
[43:58.120 --> 44:00.120]  из вершины V, вершины U.
[44:00.120 --> 44:02.120]  Понятно?
[44:02.120 --> 44:04.120]  Ну давайте докажем.
[44:04.120 --> 44:06.120]  В одну сторону, на самом деле, довольно очевидно.
[44:06.120 --> 44:08.120]  Да?
[44:08.120 --> 44:10.120]  Какую?
[44:10.120 --> 44:12.120]  Кажется, что в эту сторону.
[44:16.120 --> 44:18.120]  Да?
[44:18.120 --> 44:20.120]  Так как путь
[44:20.120 --> 44:22.120]  путь
[44:28.120 --> 44:30.120]  так как путь обнаруживается
[44:32.120 --> 44:34.120]  только по
[44:36.120 --> 44:38.120]  белым вершинам.
[44:38.120 --> 44:40.120]  Это понятно, да?
[44:40.120 --> 44:42.120]  То есть мы, если мы находим новый вершин,
[44:42.120 --> 44:44.120]  то мы всегда переходим только в белые вершины.
[44:44.120 --> 44:46.120]  Соответственно, если мы нашли путь из V в U,
[44:46.120 --> 44:48.120]  то значит, что у нас существовал путь,
[44:48.120 --> 44:50.120]  состоящий только из белых вершин.
[44:50.120 --> 44:52.120]  Вот.
[44:52.120 --> 44:54.120]  Да.
[44:54.120 --> 44:56.120]  Теперь в обратную сторону.
[44:56.120 --> 44:58.120]  Путь менее очевидно.
[44:58.120 --> 45:00.120]  Значит, пусть
[45:02.120 --> 45:04.120]  в момент
[45:04.120 --> 45:06.120]  давайте я коротко напишу,
[45:06.120 --> 45:08.120]  в момент вызова DFS от V
[45:08.120 --> 45:10.120]  посетовал
[45:10.120 --> 45:12.120]  белый
[45:12.120 --> 45:14.120]  путь
[45:14.120 --> 45:16.120]  до U. Ну давайте его как-нибудь изобразим.
[45:16.120 --> 45:18.120]  Вот у нас есть вершина V,
[45:18.120 --> 45:20.120]  есть еще какая-то вершина,
[45:20.120 --> 45:22.120]  и так далее.
[45:22.120 --> 45:24.120]  Вершина U.
[45:24.120 --> 45:26.120]  Ну, вершина V, понятное дело,
[45:26.120 --> 45:28.120]  стала серой, вот, существовал белый путь.
[45:28.120 --> 45:30.120]  Вот.
[45:30.120 --> 45:32.120]  Ну и допустим,
[45:32.120 --> 45:34.120]  в момент
[45:36.120 --> 45:38.120]  момент
[45:38.120 --> 45:40.120]  завершения
[45:40.120 --> 45:42.120]  DFS от V
[45:42.120 --> 45:44.120]  U не стало черной.
[45:46.120 --> 45:48.120]  Ну, давайте так. U осталось белой.
[45:48.120 --> 45:50.120]  Вот так.
[45:50.120 --> 45:52.120]  U осталось
[45:52.120 --> 45:54.120]  белой.
[45:54.120 --> 45:56.120]  Ну, есть в момент завершения
[45:56.120 --> 45:58.120]  у меня такая ситуация. Есть вершина V,
[45:58.120 --> 46:00.120]  дальше тут какие-то вершины.
[46:02.120 --> 46:04.120]  Тут вершина U.
[46:04.120 --> 46:06.120]  Вот. И она по-прежнему осталась белой.
[46:06.120 --> 46:08.120]  Что можно сказать про такую ситуацию?
[46:08.120 --> 46:10.120]  Во-первых, согласны ли вы,
[46:10.120 --> 46:12.120]  что тут нет серых вершин?
[46:12.120 --> 46:14.120]  Потому что
[46:14.120 --> 46:16.120]  серые вершины, во-первых, всегда образуют путь,
[46:16.120 --> 46:18.120]  а, во-вторых, серые вершины образуются так вызовом.
[46:18.120 --> 46:20.120]  Ну, так как у меня вызов DFS от V завершился,
[46:20.120 --> 46:22.120]  значит, что все рекурсивные вызовы,
[46:22.120 --> 46:24.120]  которые породил DFS в виде DFS V, тоже завершились.
[46:24.120 --> 46:26.120]  Поэтому тут новых серых вершин
[46:26.120 --> 46:28.120]  появиться не могло. Изначально тут
[46:28.120 --> 46:30.120]  серых вершин не было, и, соответственно, серых вершин
[46:30.120 --> 46:32.120]  тоже появиться не могло. Потому что все последующие
[46:32.120 --> 46:34.120]  рекурсивные вызовы, они были завершены.
[46:34.120 --> 46:36.120]  Понятно? Окей.
[46:36.120 --> 46:38.120]  Значит, вот тут
[46:38.120 --> 46:40.120]  серых нет.
[46:40.120 --> 46:42.120]  Так.
[46:42.120 --> 46:44.120]  А что можно сказать про черные?
[46:46.620 --> 46:48.620]  Могут ли тут быть черные...
[46:48.620 --> 46:52.120]  Хорошо, тут нет серых, соответственно, тут либо черные, либо белые вершины.
[46:52.120 --> 46:55.120]  Попрос, могут ли тут остаться белые вершины?
[46:55.120 --> 46:57.120]  Почему?
[46:59.120 --> 47:02.120]  Да, смотрите, у нас тут и черных вершин нет.
[47:02.120 --> 47:04.120]  Черных нет.
[47:04.120 --> 47:07.120]  Ну, можно рассуждать по-разному, можно просто нам самим показать,
[47:07.120 --> 47:10.120]  что если у — это белая вершина, а в — это черная вершина,
[47:10.120 --> 47:12.120]  то есть где-то тут есть черно-белый переход.
[47:12.120 --> 47:16.120]  Ну как там, теорема монотонной функции, которая пересекает ноль, ну понятно, да?
[47:16.120 --> 47:19.120]  Ну а можно просто сказать, что ну, смотри, давайте посмотрим вот вершину,
[47:19.120 --> 47:21.120]  давайте посмотрим ребро v, v1.
[47:21.120 --> 47:26.120]  Мы прошлым утверждением доказали, что у нас не существует черно-белых переходов, да?
[47:26.120 --> 47:29.120]  Соответственно, эта вершина черная, да?
[47:29.120 --> 47:31.120]  Дальше, смотрим вот на этот переход v1, v2.
[47:31.120 --> 47:33.120]  Ну, а нет черно-белых переходов.
[47:33.120 --> 47:36.120]  Ну да, соответственно, вот на этом пути мы,
[47:36.120 --> 47:40.120]  рассуждая индуктивно, получаем, что и у тоже стало черной.
[47:40.120 --> 47:44.120]  Но, соответственно, это означает, что вершина у все-таки была посещена, да?
[47:44.120 --> 47:46.120]  То есть противоречие.
[47:48.120 --> 47:50.120]  Вот.
[47:51.120 --> 47:53.120]  Ну вот, собственно, доказали.
[47:56.120 --> 47:58.120]  Все ясно?
[47:58.120 --> 48:03.120]  То есть, на самом деле, оказывается, что когда мы запускаем процедуры DFS V от какой-либо вершины,
[48:03.120 --> 48:07.120]  то мы посещаем только те вершины, до которых существует белый путь.
[48:07.120 --> 48:11.120]  Если до какой-либо вершины белого пути не существует, то, соответственно, такие вершины мы не посещаем.
[48:14.120 --> 48:16.120]  Ну, соответственно, вот в этом и заключается корректность.
[48:16.120 --> 48:20.120]  Ну и, соответственно, вот на основании этой теории мы теперь можем поговорить и про применение DFS.
[48:20.120 --> 48:24.120]  Ну и уже говорить там с абсолютной точностью, что действительно это корректное применение,
[48:24.120 --> 48:28.120]  потому что, собственно, это применение следует из теории, о которой мы доказали.
[48:28.120 --> 48:30.120]  Значит, ну смотрите, во-первых,
[48:30.120 --> 48:36.120]  во-первых, мы с вами в самом начале, когда говорили про, когда был задан вопрос про применение DFS,
[48:36.120 --> 48:40.120]  я сказал, что мы таким образом можем найти множество достижимых вершин.
[48:40.120 --> 48:45.120]  То есть, для каждой вершины мы можем найти, соответственно, множество вершин, до которых существует какой-то путь.
[48:45.120 --> 48:48.120]  Ну и действительно, это тоже следует напрямую из длимы о белых путях.
[48:48.120 --> 48:52.120]  То есть, если у меня изначально граф белый, и я запускаю DFS V от какой-либо вершины,
[48:52.120 --> 48:56.120]  то что означает, что у меня до какой-либо вершины существует белый путь?
[48:56.120 --> 48:59.120]  По сути, это гвариентно тому, что у меня, в принципе, путь существует, согласны?
[48:59.120 --> 49:01.120]  То есть у меня изначально все вершины белые.
[49:01.120 --> 49:07.120]  Ну все, это означает, что DFS V от V действительно посетит те и только те вершины, до которых он может дотянуться.
[49:07.120 --> 49:10.120]  Это следует из теоремы о белых путях.
[49:13.120 --> 49:17.120]  Ну, соответственно, таким же образом можно найти компоненты связанности неориентированного графа.
[49:17.120 --> 49:20.120]  Ну, снова, то же самое. Запускаем DFS V от какой-либо произвольной вершины.
[49:20.120 --> 49:25.120]  Соответственно, все те вершины, которые лежат в одной из них компоненте связанности, до них всех есть белый путь.
[49:25.120 --> 49:27.120]  Все эти вершины мы посетим.
[49:27.120 --> 49:32.120]  А все эти вершины, которые мы не посетили, они не лежат в нашей компоненте связанности.
[49:32.120 --> 49:34.120]  Потому что до них нет белого пути, не было белого пути.
[49:34.120 --> 49:36.120]  Ну и так далее.
[49:36.120 --> 49:41.120]  И следующие вершины мы находим в сети вершины, до которых мы можем дотянуться.
[49:41.120 --> 49:43.120]  А дотянуться мы до них можно только по белым вершинам.
[49:43.120 --> 49:46.120]  Все, соответственно, всю эту компоненту тоже посетим.
[49:47.120 --> 49:49.120]  Тут все понятно.
[49:49.120 --> 49:56.960]  Менее тривиальное применение – проверка на ацикличность.
[49:56.960 --> 50:04.120]  Сейчас мы научимся проверять граф на ацикличность, то есть проверять, существует ли цикл в графе или нет.
[50:04.120 --> 50:12.520]  Критерий такой. В графе g есть цикл, в том и только в том случае, если при обходе в глубину вы нашли серую вершину.
[50:12.520 --> 50:18.320]  То есть критерий очень простой. Как определить, существует ли в графе цикл или нет?
[50:18.360 --> 50:27.080]  Если в какой-то момент вы нашли серую вершину,speaker, pardon, точнее вы нашли ребро, который ведёт с серой вершины, то всё, значит, в вашем графе точно есть цикл.
[50:27.080 --> 50:32.200]  Ну и обратная вершина на самом деле тоже верно, то есть если вы нашли серую вершину.
[50:36.720 --> 50:41.640]  это критерий, то если у вас проф警 eth videos There is a cycle.
[50:41.640 --> 50:46.420]  하면서
[50:46.420 --> 50:53.420]  Ну, в одну сторону тривиально, в какую? Ну, в обратную на самом деле, да?
[50:53.420 --> 50:56.420]  Ну, вот вы на самом деле уже сказали, да, что
[50:56.420 --> 51:08.420]  переход серую в вершину, но это то же самое, что
[51:08.420 --> 51:10.420]  обратное ребро, да?
[51:16.420 --> 51:19.420]  Да, ну, обратное ребро это, как раз, то ребро, который образует цикл, да?
[51:19.420 --> 51:23.420]  Потому что обратное ребро – это то ребро, которое ведет из потомков-предков.
[51:23.420 --> 51:32.420]  То есть у вас есть путь из предков-потомков, и из потомков есть ребро впредка.
[51:32.420 --> 51:35.420]  Ну, соответственно, это в чистом виде цикл.
[51:35.420 --> 51:39.420]  Поэтому если вы нашли серую вершину, то как бы тут всё очевидно, цикл точно есть.
[51:39.420 --> 51:43.420]  Так, теперь하� менее тривиальная штука. Вот почему, если у вас в графе есть цикл
[51:43.420 --> 51:45.420]  вы по-любому найд�이т серую вершину?
[51:45.420 --> 51:49.020]  Ну как бы это же, ну вот это на самом деле непонятно, да? Сразу.
[51:49.020 --> 51:55.820]  То есть вдруг у вас обход устроен таким образом, что он вот обходит, обходит, и так вот тщательно избегает серой вершины.
[51:55.820 --> 51:59.220]  Но вот такого на самом деле происходить не будет. И вот почему.
[51:59.220 --> 52:07.420]  Давайте рассмотрим цикл в графе.
[52:08.420 --> 52:20.420]  Ну пусть какой-то такой цикл, значит, вершина v0, v1, v2, ну и так далее vn.
[52:20.420 --> 52:23.420]  Вот такой вот цикл v0, v1, v2, и так далее vn.
[52:24.420 --> 52:48.420]  Значит, ну без ограничений общности давайте считать, что пусть v0 это первая, первая вершина цикла, из которой был запущен DFS.
[52:49.420 --> 52:56.420]  Ну то есть у меня обход в глубину как-то обходит, обходит вершины, и в какой-то момент пришел вершина v0.
[52:56.420 --> 53:00.420]  Ну и v0 это вообще в принципе первая вот на этом цикле вершина, которая была посещена. Понятно?
[53:00.420 --> 53:06.420]  То есть не в принципе первая вершина обхода, а вот первая вершина именно из цикла.
[53:06.420 --> 53:08.420]  Что можно сказать?
[53:08.420 --> 53:18.420]  Давайте я начну. А по лемме о белых путях, что можно сказать про запуск DFS от v0?
[53:18.420 --> 53:38.420]  Ну смотрите, мне нужно, вот я сейчас хочу показать, что вот та серая вершина, которую я встречу, как раз таки будет v0.
[53:38.420 --> 53:41.420]  Ну как минимум v0, серую вершину я точно встречу.
[53:41.420 --> 53:47.420]  Смотрите, по лемме о белых путях, ну смотрите, какой у меня тут есть белый путь?
[53:47.420 --> 53:53.420]  У меня тут есть белый путь, в момент запуска DFS от v0 у меня есть белый путь, который идет до вершины vn. Согласны?
[53:53.420 --> 54:05.420]  Следовательно, по лемме о белых путях DFS от v0 посетит вершину vn.
[54:05.420 --> 54:14.420]  Ну то есть на самом деле не факт, что он посетит именно по этому циклу, он может так как-то бродить, но в любом случае дойдет до этой вершины.
[54:14.420 --> 54:22.420]  По предположению, пусть v0 это первая вершина, из которой был запущен DFS.
[54:22.420 --> 54:27.420]  То есть мы предполагаем, что v0 это самая первая вершина, которую мы посетили из этого цикла, то есть все остальные белые.
[54:27.420 --> 54:32.420]  И вот v0 стало серой. То есть по предположению естественно у нас белый путь есть.
[54:33.420 --> 54:39.420]  То есть по лемме о белых путях, когда мы запускаем DFS от v0, этот DFS как-то ходит-ходит-ходит и доберется до вершины vn.
[54:39.420 --> 54:42.420]  А что произойдет, когда мы будем посетить вершину vn?
[54:44.420 --> 54:49.420]  Да, ну собственно смотрите, в момент посетения вершины vn мы будем обходить всех ее соседей.
[54:49.420 --> 54:55.420]  Ну а в момент, когда мы будем обходить всех соседей, мы как раз-таки встретим серую вершину v0. Победа, согласны?
[54:56.420 --> 55:01.420]  Ну все, то есть по лемме о белых путях DFS от v0 посетит вершину vn.
[55:01.420 --> 55:24.420]  Ну а в момент, в момент посещения vn встретим серую вершину v0.
[55:24.420 --> 55:26.420]  Ну все.
[55:28.420 --> 55:34.420]  То есть как ни крути, если у меня в графе есть цикл, то соответственно я какую-то серую вершину туда встречу в любом случае.
[55:35.420 --> 55:37.420]  Все понятно?
[55:45.420 --> 55:49.420]  Так вот, так я и говорю, что возможно мы запустили DFS с какой-то другой вершины.
[55:49.420 --> 55:53.420]  Как-то гуляем-гуляем-гуляем, но v0 это первая вершина именно из цикла, которую мы встретили.
[55:53.420 --> 55:56.420]  Это не первая вершина в принципе, с которой мы запустили DFS.
[55:56.420 --> 56:01.420]  А первая, среди вот этих вершин, вот эта вершина оказалась самой первой, которую мы встретили.
[56:04.420 --> 56:07.420]  Ну смотрите, если у нас DFS устроено так, что мы в любом случае...
[56:07.420 --> 56:11.420]  Ну помните, у нас была процедура DFS, в которой мы просто в цикле проходились.
[56:11.420 --> 56:14.420]  То есть в любом случае мы до этого цикла тоже дойдем.
[56:14.420 --> 56:16.420]  Понятно?
[56:16.420 --> 56:17.420]  Вот.
[56:17.420 --> 56:20.420]  Ну сейчас давайте перейдем к псевдокоду, и вот я покажу.
[56:20.420 --> 56:23.420]  Вот, то есть вот у нас вот эта процедура DFS видят.
[56:23.420 --> 56:25.420]  То есть есть алгоритм hasCycle.
[56:25.420 --> 56:27.420]  Как устроена процедура hasCycle.
[56:27.420 --> 56:30.420]  Ну, там мы значаем цвета.
[56:30.420 --> 56:34.420]  Дальше вот в цикле проходимся по всем вершинам.
[56:34.420 --> 56:37.420]  Если вершина была белая, то есть если вершины мы еще не посетили,
[56:37.420 --> 56:40.420]  то мы из нее запускаем рекурсивную процедуру hasCycle.dfs.
[56:40.420 --> 56:42.420]  Окей?
[56:42.420 --> 56:47.420]  Если вот эта процедура рекурсивная вернула true, то есть она говорит, что мы нашли цикл,
[56:47.420 --> 56:51.420]  то мы тоже на самом деле можем завершиться и вернуть true.
[56:51.420 --> 56:55.420]  Если в процессе обхода всех вершин, то есть когда мы посетили вообще все и все вершины,
[56:55.420 --> 56:58.420]  мы не нашли ни одного цикла, то мы возвращаем false.
[56:58.420 --> 57:00.420]  Теперь, как устроена вот эта рекурсивная процедура?
[57:00.420 --> 57:03.420]  Вот эта рекурсивная процедура, она как раз-таки устроена просто как DFS.
[57:03.420 --> 57:05.420]  То есть мы говорим, что цвет вершины серый.
[57:05.420 --> 57:09.420]  Дальше в цикле перебираем всех соседей.
[57:09.420 --> 57:12.420]  Если встретили серого соседа, то возвращаем true, то есть мы нашли цикл.
[57:12.420 --> 57:14.420]  Окей?
[57:14.420 --> 57:19.420]  Дальше, соответственно, если сосед белый, то мы рекурсивно запускаем из него hasCycle.dfs.
[57:19.420 --> 57:22.420]  Если этот рекурсивный вызов нашел какой-то цикл,
[57:22.420 --> 57:24.420]  то мы сразу можем завершиться и сказать true.
[57:24.420 --> 57:26.420]  Если нет, то, соответственно, продолжаем работу.
[57:26.420 --> 57:29.420]  Ну и в конце, как обычно, говорим, что цвет вершины черный.
[57:29.420 --> 57:33.420]  И, соответственно, если вот эта процедура рекурсивная ни разу не вернула true,
[57:33.420 --> 57:35.420]  то, соответственно, возвращаем false.
[57:35.420 --> 57:37.420]  Все понятно?
[57:38.420 --> 57:41.420]  То есть, по сути, это обычная DFS,
[57:41.420 --> 57:46.420]  в которую просто засунули проверку на серую вершину.
[57:46.420 --> 57:52.420]  Ну и просто засунули проверку, что вернула ли нам процедура hasCycle true или нет.
[57:52.420 --> 57:54.420]  Все окей?
[57:54.420 --> 57:59.420]  Ну и, смотрите, так как нам тут на самом деле нужны всего лишь,
[57:59.420 --> 58:02.420]  скажем так, мы проверяем обратно у нас ребра или нет,
[58:02.420 --> 58:06.420]  то, соответственно, времени входа, таймин, тайм-аут мы не используем.
[58:06.420 --> 58:08.420]  То есть нам достаточно всего лишь цветов, да?
[58:08.420 --> 58:10.420]  То есть мы используем всего лишь цвета.
[58:10.420 --> 58:12.420]  Там белый, серый, черный, и вот.
[58:12.420 --> 58:14.420]  И вот вы спрашивали недостаточно нам двух цветов.
[58:14.420 --> 58:16.420]  Вот двух тут как раз недостаточно,
[58:16.420 --> 58:18.420]  понимаете почему?
[58:18.420 --> 58:21.420]  Потому что нам важно отличать серую вершину от черной вершины.
[58:21.420 --> 58:24.420]  То есть, мы закончили обработку вершины или нет.
[58:24.420 --> 58:27.420]  Соответственно, если мы обработку вершины закончили,
[58:27.420 --> 58:29.420]  то эта вершина не входит в Cycle.
[58:29.420 --> 58:31.420]  Если мы обработку вершины еще не закончили, то она серая,
[58:31.420 --> 58:33.420]  то, соответственно, эта вершина образует нам Cycle.
[58:33.420 --> 58:40.220]  нам цикл. Есть по этому вопросу?
[58:43.740 --> 58:48.940]  Ну и тут есть несколько замечаний
[58:48.940 --> 58:53.020]  по поводу реализации этого алгоритма на
[58:53.020 --> 58:55.020]  практике. Тут есть, возможно, несколько
[58:55.020 --> 58:57.460]  сложностей. Первое замечание
[58:57.460 --> 58:58.700]  заключается в следующем, что если в задаче
[58:58.700 --> 59:01.660]  вам вдруг требуется не
[59:01.660 --> 59:03.940]  просто сообщить о наличии цикла или о
[59:03.940 --> 59:05.820]  отсутствии, а вам нужно восстановить сам цикл,
[59:05.820 --> 59:07.660]  то есть предъявить какой-то цикл.
[59:07.660 --> 59:10.100]  Скажем, доказать, что вы говорите не
[59:10.100 --> 59:11.380]  просто, что цикл есть, а еще и
[59:11.380 --> 59:13.180]  показываете, что цикл проходит по
[59:13.180 --> 59:14.580]  таким вершинам. То можно дополнительно
[59:14.580 --> 59:16.620]  хранить еще массив parent, ну как мы это
[59:16.620 --> 59:18.380]  делали в BFS, то есть из какой вершины мы
[59:18.380 --> 59:21.180]  обнаружили данную вершину. И потом
[59:21.180 --> 59:22.420]  просто-напросто взять какую-нибудь
[59:22.420 --> 59:24.140]  вершину из цикла и пройтись
[59:24.140 --> 59:25.780]  по родителям обратно, и соответственно
[59:25.780 --> 59:28.180]  кеморсу вы восстанавливаете цикл.
[59:28.780 --> 59:31.780]  Понятно, как это происходит.
[59:33.300 --> 59:35.500]  Да, хоть произвольный цикл вы ходите таким
[59:35.500 --> 59:38.220]  образом. Задача поиска всех циклов, она
[59:38.220 --> 59:41.580]  естественно сложная. Это задача поиска
[59:41.580 --> 59:43.940]  хотя бы какого-то цикла, ну или цикла, в котором
[59:43.940 --> 59:46.420]  лежит какая-то конкретная вершина.
[59:46.420 --> 59:49.500]  Дальше. Ну про замечание два мы на самом
[59:49.500 --> 59:50.860]  деле уже говорили в прошлый раз, давайте
[59:50.860 --> 59:52.580]  еще раз ее обсудим. Вот, допустим, вам
[59:52.580 --> 59:54.700]  нужно найти цикл в неориетерном графе.
[59:54.700 --> 59:59.500]  Вот такая вот история. Вот как мы
[59:59.500 --> 01:00:00.700]  обычно представляем неориетерный
[01:00:00.700 --> 01:00:02.220]  граф? Ну неориетерный граф мы как
[01:00:02.220 --> 01:00:03.180]  правило представляем в виде
[01:00:03.180 --> 01:00:04.620]  ориентированного с двунаправленными
[01:00:04.620 --> 01:00:07.500]  ребрами. Да, вот так. В чем тут возможна
[01:00:07.500 --> 01:00:12.860]  проблема? Да, на самом деле вот если мы
[01:00:12.860 --> 01:00:14.300]  запустим просто-напросто в тупую алгоритм
[01:00:14.300 --> 01:00:15.580]  вот в таком графе, то соответственно мы
[01:00:15.580 --> 01:00:17.860]  всегда будем получать цикл.
[01:00:17.860 --> 01:00:23.660]  Как решить эту проблему? Да, на самом деле
[01:00:23.660 --> 01:00:24.980]  просто-напросто достаточно, ну смотрите,
[01:00:24.980 --> 01:00:29.860]  вот эта вершина В, эта вершина, давайте скажем,
[01:00:29.860 --> 01:00:35.260]  это parent от В, а эта вершина В. Вот, нам
[01:00:35.260 --> 01:00:37.980]  просто достаточно проверить, что, ну когда мы
[01:00:37.980 --> 01:00:42.740]  идем в цикле, да, for u, in, g.соседи,
[01:00:42.740 --> 01:00:45.140]  вершины В, да, нам достаточно проверить,
[01:00:45.140 --> 01:00:51.980]  что u не равно parent от В. Понятно?
[01:00:52.620 --> 01:00:54.140]  Ну, то есть, если вдруг у нас получается
[01:00:54.140 --> 01:00:55.700]  такая ситуация, что мы идем обратно в
[01:00:55.700 --> 01:00:57.340]  родители, то мы говорим, что нет, вот такая
[01:00:57.340 --> 01:00:59.700]  ситуация не является циклом, окей? То есть, ее мы
[01:00:59.700 --> 01:01:03.700]  просто скипываем. Но, тут есть еще одна беда.
[01:01:03.700 --> 01:01:05.820]  Да, соответственно, в этом случае одно
[01:01:05.820 --> 01:01:07.180]  ребро всегда будет давать цикл, чтобы
[01:01:07.180 --> 01:01:08.180]  не происходило, нужно отдельно рассмотреть
[01:01:08.180 --> 01:01:09.900]  случай, когда сосед это родитель в дереве обхода.
[01:01:09.900 --> 01:01:12.340]  Значит, это решение понятно, да? Но тут, возможно,
[01:01:12.340 --> 01:01:15.380]  другая беда. А что если у меня изначально
[01:01:15.380 --> 01:01:21.300]  в графе были кратные ребра? Тогда мне на
[01:01:21.300 --> 01:01:23.420]  самом деле с родителей не нужно пропускать,
[01:01:23.420 --> 01:01:25.100]  да, потому что если я пропущу родителей, то я
[01:01:25.100 --> 01:01:26.340]  уже вот такой вот цикл просто-напросто
[01:01:26.340 --> 01:01:32.140]  пропущу. Беда понятно? Хорошо, а что в таком
[01:01:32.140 --> 01:01:34.700]  случае делать? Вот, допустим, у вас и неориентированный
[01:01:34.700 --> 01:01:37.100]  граф, а еще и кратные ребра есть, и поэтому
[01:01:37.100 --> 01:01:38.460]  вот родители вы игнорировать не можете.
[01:01:38.460 --> 01:01:44.540]  Как действовать в таком случае? Очень
[01:01:44.540 --> 01:01:46.220]  забавно, что этот вопрос ставят в тупик
[01:01:46.220 --> 01:01:48.180]  уже третий год, на самом деле. Очень
[01:01:48.180 --> 01:01:57.940]  интересно. Еще какие предложения?
[01:01:57.940 --> 01:02:03.540]  Ладно, решение на самом деле очень простое.
[01:02:03.540 --> 01:02:07.220]  Если у вас есть кратное ребро, то это по-любому цикл,
[01:02:07.220 --> 01:02:12.380]  все. Все, если вы видите граф, у вас в графе есть кратное
[01:02:12.380 --> 01:02:14.420]  ребро неориентированное, то все, вы как бы даже
[01:02:14.420 --> 01:02:16.060]  алгоритм не запускаете, говорите, а все, вот цикл,
[01:02:16.540 --> 01:02:19.260]  и на этом завершаете работу. Все, то есть
[01:02:19.260 --> 01:02:20.900]  тут делать ничего не надо, на самом деле, то есть
[01:02:20.900 --> 01:02:22.140]  это даже не проблема, короче говоря.
[01:02:26.140 --> 01:02:29.660]  То у нее либо слишком большое ограничение по
[01:02:29.660 --> 01:02:35.460]  времени, либо, ну либо там вы находите, ну либо
[01:02:35.580 --> 01:02:36.660]  время, на самом деле, в таком случае, вы можете
[01:02:36.660 --> 01:02:39.780]  просто нумеровать ребра. Скажем, завести там
[01:02:39.780 --> 01:02:41.380]  индексы у ребер, то есть это нулевой ребро, это
[01:02:41.380 --> 01:02:44.340]  первый ребро, и уже игнорировать не родители,
[01:02:44.340 --> 01:02:45.620]  а игнорировать непосредственно ребра.
[01:02:46.180 --> 01:02:47.780]  Скажем, если вы прошлись по ребру 0, то
[01:02:47.780 --> 01:02:49.580]  соответственно, это ребро меня не устраивает,
[01:02:49.580 --> 01:02:51.140]  потому что я по нему пришел к самому вершину.
[01:02:51.420 --> 01:02:53.460]  Если вы видите ребро 1, то соответственно, значит,
[01:02:53.460 --> 01:03:00.180]  другое ребро по нему надо пройтись. Вот.
[01:03:02.180 --> 01:03:05.420]  Все понятно? Отлично.
[01:03:06.500 --> 01:03:12.140]  Ну и, собственно, в конце, коротко
[01:03:12.140 --> 01:03:14.860]  говорим про связанность в ориентированных графах.
[01:03:15.460 --> 01:03:17.260]  Значит, смотрите, одно из применений DFS, как мы
[01:03:17.260 --> 01:03:19.500]  обсудили, это поиск компонент связанности в
[01:03:19.500 --> 01:03:20.380]  неориентированном графе.
[01:03:21.500 --> 01:03:23.420]  Да, то есть если у вас в графе не заданы ориентации
[01:03:23.420 --> 01:03:28.820]  на ребрах, такая вот штука, то, соответственно, DFS
[01:03:28.820 --> 01:03:31.100]  позволяет вам найти компоненты связанности.
[01:03:32.140 --> 01:03:33.460]  В прошлый раз мы затрагивали следующую
[01:03:33.460 --> 01:03:35.020]  проблему. Ну хорошо, смотрите, вот если у
[01:03:35.020 --> 01:03:39.980]  меня граф ориентированный, вот такой, вот
[01:03:39.980 --> 01:03:41.340]  является этот граф связанным или нет?
