[00:00.000 --> 00:12.000]  Начинаем нашу лекцию про System Safety. В этой лекции мы изучим систему типов RAST. Мы изучим то,
[00:12.000 --> 00:18.420]  как RAST нам гарантирует safety, как он разрешает либо запрещает нашу программу. Также мы чуть-чуть
[00:18.420 --> 00:22.880]  посмотрим на примеры того, как он unsafe нам может сломать программу, если мы им неправильно
[00:22.880 --> 00:30.720]  пользуемся. Это конкретный наш план. Сначала мы узнаем, что такое lifetime. Потом узнаем,
[00:30.720 --> 00:38.120]  как RAST все это время от нас прятал lifetime. В том числе, как он прятал lifetime в наших функциях,
[00:38.120 --> 00:46.000]  в closures. Потом будет самая веселая часть лекции, subtyping и variance. В этой части лекции мы узнаем,
[00:46.000 --> 00:54.000]  собственно, каким образом RAST гарантирует безопасность программы. Затем у нас будет
[00:54.000 --> 00:59.640]  drop checker, ну и conclusion. На этот раз conclusion это будет не просто один слайд, а мы прямо обсудим,
[00:59.640 --> 01:05.680]  как это все устроено. Еще раз посмотрим сверху. Попробуем на этот вопрос еще раз ответить,
[01:05.680 --> 01:11.360]  чтобы как-то подытожить лекцию. Если что, таких лекций я в интернете по крайней мере не знаю. Так
[01:11.360 --> 01:16.960]  что действительно мне пришлось ее делать с нуля полного. Большая часть основывался на RAST и на
[01:16.960 --> 01:26.160]  Mecon, но если у вас будут вопросы, то говорите, это очень важно. Lifetime. Что вы знаете о lifetime за
[01:26.160 --> 01:34.040]  время, которое вы писали что-то в домашнем? Например, когда ссылки надо куда-то там
[01:34.040 --> 01:42.560]  прообразывать? Получается lifetime, и у вас решались по большей части, что компилятор попросил, кто и написал.
[01:42.560 --> 01:47.920]  В каком-то смысле это хорошо, потому что я так и планировал. В каком-то смысле плохо, потому что мы
[01:47.920 --> 01:52.440]  не разобрались с такой достаточно фундаментальной частью языка, которая иногда в нем возникает,
[01:52.440 --> 01:58.360]  и вам приходилось мучиться. Это, наверное, то, что я не показал на первых лекциях, это какая-то
[01:58.360 --> 02:08.360]  моя ошибка. Давайте для начала в общих чертах поговорим про RAST. У каждого языка есть какие свои
[02:08.360 --> 02:14.160]  цели, которые он преследует. Если вы пишете на плюсах, плюсы это язык, который в первую очередь про
[02:14.160 --> 02:23.560]  зеркал Abstr, про то, что был быстрый код и все такое. У RAST есть три конкретные цели. Эти цели
[02:23.560 --> 02:30.840]  определяют то, каким он является, какие у него сильные и слабые стороны. Три конкретные – это
[02:30.840 --> 02:36.120]  Performance, Reliability и Productivity. Performance – это как раз про скорость, про то, чтобы быть таким же
[02:36.120 --> 02:43.080]  быстрым, как C, C++. Reliability – это то же самое, по сути, что и Safety – дать вашей программе возможность
[02:43.080 --> 02:49.480]  быть безопасной. Не стрелять по памяти, не вызывать какой-то unsafety, не ломать вам прот,
[02:49.480 --> 02:55.160]  не вызывать defined behavior, чтобы потом было больно добажить и вылавливать случай, на котором вы
[02:55.160 --> 03:00.440]  собственно сломались. Ну и Productivity. Наверное, Productivity – это, наверное, та вещь, которую вы
[03:00.440 --> 03:05.000]  пока что не заметили, пока вы изучали RAST. На самом деле, это RAST – это такой язык, на котором очень
[03:05.000 --> 03:09.600]  быстро можно писать код, очень быстро писать приложение. Не так быстро, как на Python, но вообще
[03:09.600 --> 03:16.640]  язык очень продуктивный по сравнению с теми же плюсами. Вы можете переиспользовать какие-то крейты,
[03:16.640 --> 03:21.640]  буквально там написать манифесты, после этого – оп-оп, все компилируется, там быстренько собирается,
[03:21.640 --> 03:28.080]  и вы пользуетесь какими-то уже продвинутыми фичами. Можете заимпортить целые вебсяки,
[03:28.080 --> 03:35.840]  чтобы прикрутить. Ну это то, что вы поймете, наверное, в тот момент, когда вы перестанете уже
[03:35.840 --> 03:43.200]  бороться с боровым чекером и увидите остальное преимущество языка. Ну как я говорил, мы тут
[03:43.200 --> 03:52.200]  собираемся обсуждать преимущественно систему типа RAST и то, как она будет соединена конкретно с
[03:52.200 --> 04:04.120]  performance и safety. Есть разные ошибки в memory-safety, это не полный их список, но вот это те, которые
[04:04.120 --> 04:11.120]  мы будем преимущественно расследовать на этой лекции, как от них избавляться. Например, double free,
[04:11.120 --> 04:20.960]  null pointer, dereference, aliasing и прочее. Первое очень легко фиксится даже в плюсах, вы просто
[04:20.960 --> 04:29.120]  пользуетесь EDOM и RAE, у вас все хорошо получается. Ну то есть довольно сложно сделать не exactly one
[04:29.120 --> 04:34.760]  free, когда у вас хорошо написан код, и вы пользуетесь RAE, то есть тот код, который вы здесь используете.
[04:34.760 --> 04:41.800]  Поэтому в какой-то смысле это проблема решена, в том числе уже в плюсах, не все, все нужно это руками
[04:41.800 --> 04:55.280]  все еще менеджить. Кстати, совсем недавно была такая новость, вышел язык, называется hair,
[04:55.280 --> 05:08.080]  как вы читаете, hair, что-то такое, четыре буквы, h-a-r-y, вот. Этот язык такой с виду, это про abrasion
[05:08.080 --> 05:15.560]  c, в котором есть defer, как раз, и обработка ошибок как растя с результатом. Это показывает какие-то
[05:15.560 --> 05:21.960]  такие интересные направления в индустрии, что люди хотят избавиться, по крайней мере, от этих двух
[05:21.960 --> 05:27.640]  ошибок так точно, то есть нормально обрабатывать эти ошибки, во-вторых, хотят поправить с точки
[05:27.640 --> 05:35.040]  зрения double play. Вот, ну можете почитать, если вам интересно. Вообще язык, мне кажется, так как у него
[05:35.040 --> 05:45.720]  фичей, в принципе, нет, наверное, мертворожден. Вот. Потом есть, ну, такие проблемы, как null pointer
[05:46.320 --> 05:52.080]  вы можете, в принципе, проверять просто не null или ваш указатель. Да, это будет дополнительное
[05:52.080 --> 05:54.280]  какое-то boilerplate, но вы можете это сделать.
[05:54.280 --> 06:21.160]  Ну, в принципе, да, если ты записываешь, наверное, это не УБ, но если читаешь, то точно УБ.
[06:24.280 --> 06:38.560]  Интересно. Вот. Ну, еще можно просто не создавать всякие null pointer, то есть гарантировать внутри
[06:38.560 --> 06:44.880]  своего кода, что у вас не будет null pointer, в чем бы и нет. Ну, что делать с остальными ошибками? У нас
[06:44.880 --> 06:55.600]  так много других ошибок в memory-safety, и все они, всем вам подвержены те же самые плюсы и си. Так. Как вы
[06:55.600 --> 07:04.080]  знаете, конфиляторы хотят оптимизировать код. Ну и, в общем, мы хотим как-то удобно писать код,
[07:04.080 --> 07:14.080]  и с другой стороны компиляторы хотят его оптимизировать. Так. Вернусь, Селен. Я потом скину
[07:14.080 --> 07:26.560]  ссылку на него, если это... В общем, новости кину. Так. Вот. Почему нам важен алисинг? Потому что мы
[07:26.560 --> 07:33.520]  хотим оптимизировать код и быть, с другой стороны, как-то несложно, чтобы наш язык был. Мы не
[07:33.520 --> 07:37.480]  писали на ассемблере, и в том числе он был быстрым, потому что компиляторы как-то хотят оптимизировать,
[07:37.480 --> 07:44.600]  а мы хотим писать читабельнику. И одна из проблем, которая тут может возникнуть, это алисинг. Вы с ним
[07:44.600 --> 07:52.360]  уже однозначно знакомы с курса Minimacos, Restrict указателей и все такое. Мы рассказывали про эту
[07:52.360 --> 07:57.560]  проблему и про то, как она мешает оптимизировать компилятор. В том числе мы сейчас посмотрим на
[07:57.560 --> 08:03.640]  один из примеров. Ну, так как мы в расе хотим быть быстрыми, давайте мы подумаем о том, почему для
[08:03.640 --> 08:11.720]  нас вообще важно понятие алисинга. Давайте рассмотрим вот такую вот функцию. Эта функция принимает
[08:11.720 --> 08:20.720]  на вход какой-то U32 и output mute U32. Мы проверяем, что у нас там за input, и соответственно с тем,
[08:20.720 --> 08:26.440]  какой у нас input, у нас получается какой-то определенный output. Здесь можно обратить внимание на то,
[08:26.440 --> 08:34.440]  что если у нас input больше чем десятка, то в таком случае у нас output обязательно единочка. Ну как,
[08:34.440 --> 08:43.520]  двойка. Мы хотим, естественно, этот код оптимизировать примерно вот так вот. Это то, что примерно хочет
[08:43.520 --> 08:54.760]  сделать компилятор, когда он смотрит на такой код. Компилятор хочет сделать такой код. Если больше
[08:54.760 --> 09:02.760]  десятки, сразу же двойка. Иначе мы проверим только тогда пятерку. Достаточно лишней инструкции
[09:02.760 --> 09:08.480]  исполнять нам не хочется. Если мы сделаем эту оптимизацию в других языках, в частности,
[09:08.480 --> 09:15.160]  раз уж мы так постоянно сравним с плюсами C++, то этот код не будет безопасным, потому что если вы
[09:15.160 --> 09:21.240]  передадите две одинаковые ссылки, то в таком случае код будет просто некорректен, потому что вы
[09:21.240 --> 09:30.840]  будете менять output, который меняется через input. Наоборот input меняется через output.
[09:30.840 --> 09:35.560]  Соответственно у нас результат второго if, а в случае, если у нас две ссылки одинаковые, будет
[09:35.560 --> 09:41.800]  другой. То есть если мы больше десяти, мы станем единичка, и после этого больше пяти не выполнится.
[09:41.800 --> 09:44.920]  Вспомнили про алисинг?
[09:44.920 --> 09:51.280]  Это не вспомнил или как?
[09:51.280 --> 10:09.160]  Я, конечно, говорю про пересекающийся регион памяти сейчас.
[10:09.160 --> 10:14.640]  А почему это в Rust будет безопасно сделать?
[10:14.640 --> 10:27.320]  Да, если у нас там mute-borrow, то соответственно мы уже input просто не сможем создать. Или если мы
[10:27.320 --> 10:32.440]  создали input, мы уже не сможем создать output, поэтому у нас одновременно две ссылки на один регион памяти
[10:32.440 --> 10:39.880]  в рамках Rust существовать не может. Поэтому мы можем сделать такую оптимизацию в рамках компилятора.
[10:39.880 --> 10:45.760]  Вот как я говорил на одной из прошлых лекций, у нас компилятор Rust, он повсюду вставлял те
[10:45.760 --> 10:53.040]  рестрикты, в итоге ломал LVM. Сейчас LVM чуть-чуть починилось, и там включено в зависимости от того,
[10:53.040 --> 10:59.400]  с каким вы компилятором компилируетесь Rust. Потом в конечном итоге, может быть, навсегда включат,
[10:59.400 --> 11:11.600]  но это зависит от того, какой у нас будет прогресс в LVM. Вот это все правило, которое мы все это время
[11:11.600 --> 11:20.040]  обсуждали, называется на самом деле AXM, aliasing-sormitability, то есть либо мы имеем aliasing,
[11:20.040 --> 11:26.400]  несколько ссылок, shared ссылочек, те, которые не мутабельные, либо одну мутабельную ссылочку.
[11:26.400 --> 11:34.560]  Этого вы можете часто встретить в статьях AXM, в том числе в госсеселях, которые, я надеюсь,
[11:34.560 --> 11:47.600]  мы на следующей лекции успеем пройти. Алисинг, анализ, в общем, анализ aliasing очень важен,
[11:47.600 --> 11:55.040]  он дает возможность сделать некоторые важные оптимизации. Некоторые из них я тут скопировал
[11:55.040 --> 12:02.920]  Rastonomecon, чисто для примера. Например, что мы можем, например, убирать всякие записи,
[12:02.920 --> 12:09.200]  если мы после этого не делаем никаких частей, не гарантированно. А так бы мы уже не могли так
[12:09.200 --> 12:18.240]  сделать, потому что у нас есть aliasing, поэтому могут возникнуть проблемы. Так,
[12:18.240 --> 12:28.520]  наконец мы сейчас закончим общее обсуждение Rasta. Несмотря на то, что мы все это время знали об AXM,
[12:28.520 --> 12:34.200]  мы не знали, как это все работает, как Rast проверял наш код на окрестности. На самом деле,
[12:34.200 --> 12:41.080]  вот давайте такой вот есть известный факт, каждая система типов, в том числе система типов Rasta,
[12:41.080 --> 12:46.960]  которая есть, она гарантирует, в общем, разрешает какое-то множество программ и запрещает какое-то
[12:46.960 --> 12:52.160]  множество программ. Мы, естественно, хотим, чтобы у нас в идеале запретились все неправильные
[12:52.160 --> 12:57.520]  программы, разрешились все правильные. Правильные с точки зрения того, что мы хотим системы типов.
[12:57.520 --> 13:05.800]  В плюсах, например, у нас нет memory-safety, поэтому в принципе memory-unsafe программы там валидные.
[13:05.800 --> 13:10.120]  Вот в Rast такие программы уже не будут валидными, они просто не скомпилируются, потому что система
[13:10.120 --> 13:16.680]  типов вам не позволит. Вот давайте сейчас выясним, как это работает. Две самые главные
[13:16.680 --> 13:23.120]  проблемы среди тех из списка, которые мы рассматриваем. Это invalid memory-access и use-after-free.
[13:23.120 --> 13:30.280]  Кстати, еще были data-race в том списке. Если что, мы про них поговорим на следующей лекции. Мы
[13:30.280 --> 13:37.080]  memory-safety разберем на этой, а потом на следующей прям красиво посмотрим на то, как вывозится из
[13:37.080 --> 13:43.000]  memory-safety в однопоточном случае и memory-safety в многопоточном, буквально введением двух трейтов.
[13:43.000 --> 13:50.880]  Давайте разберемся с тем, как вы сделали так, чтобы у нас не было доступа к неправильной памяти и
[13:50.880 --> 13:56.600]  чтобы у нас не было use-after-free. То есть, я имею в виду, вы здесь используете память, которая не
[13:56.600 --> 14:01.720]  интеллигирована, например, в втором случае, когда у вас уже, понятное дело, например, вектор удалился
[14:01.720 --> 14:07.680]  и вы им пользуетесь дальше. Как вы думаете, как же Rast это определяет?
[14:07.680 --> 14:21.560]  Конечно, раз уж у нас лекция в большей части про lifetime и ответ lifetime. Rast это делает через lifetime.
[14:21.560 --> 14:27.280]  Неформально. Там есть прям формальное определение через логику, но для этого нужно почитать статью,
[14:27.280 --> 14:34.240]  которая формально доказывает, что Rast безопасен. Есть такая, показывала в первом лекции. Lifetime
[14:34.240 --> 14:40.240]  это какой-то именованный регион кода. В чем-то произвольный регион кода. Настолько произвольный,
[14:40.240 --> 14:45.120]  что в нем могут быть дырки или он может, например, если у вас if, то внутри у вас может одного
[14:45.120 --> 14:50.240]  бронча примерно существовать, а внутри другого уже нет. Сейчас посмотрим на конкретные примеры,
[14:50.240 --> 14:58.120]  как это работает. Фундаментальная идея такая. Давайте мы каждому объекту скажем, он живет
[14:58.120 --> 15:03.800]  внутри вот такого вот lifetime. Если он живет внутри такого lifetime, то соответственно все ссылки не
[15:03.800 --> 15:09.760]  могут его переживать. Соответственно у ссылки будет какой-то lifetime, то есть мы будем привязаны
[15:09.760 --> 15:16.480]  к кому-то региону кода и за этот регион кода мы выйти не сможем. Примерно такая идея. Это такое
[15:16.480 --> 15:24.040]  с высокого полета. Примерно понятно? Давайте посмотрим, как, во-первых, объявляется lifetime.
[15:24.040 --> 15:33.800]  Они объявляются через вот такой вот штрюшочек. Структура персона у нас есть. Есть first name, last name и они
[15:33.800 --> 15:39.120]  обозначены lifetime. В структурах мы вынуждены это делать для того, чтобы мы явно показывали,
[15:39.120 --> 15:44.600]  что структура зависит от этого lifetime. Сейчас будет чуть понятнее, когда мы начнем дальше обсуждать,
[15:44.600 --> 15:55.320]  что значит зависит от lifetime. Вот, ну тут понятно. Так, важное замечание. Lifetimes,
[15:55.320 --> 16:01.920]  они в общем-то не являются типами, но они являются частью типа. То есть, например,
[16:01.920 --> 16:12.720]  I32 является типом, но тем не менее, например, ссылка с lifetime A на I32 и ссылка с lifetime static,
[16:12.720 --> 16:18.920]  вы видели, наверное, когда-то static lifetime. I32 это, на самом деле, два разных типа. Просто банально.
[16:18.920 --> 16:27.880]  Вот. Раст с помощью, как мы дальше выясним, некоторых макинаций делает так, чтобы у нас дальше
[16:27.880 --> 16:34.440]  программа была безопасна. Как-то так. Я думаю, будет понятнее где-то ближе к середине лекции,
[16:34.440 --> 16:39.280]  пока что так. Чуть туманно. В общем, lifetime – это регион кода и мы привязались к региону кода.
[16:39.280 --> 16:47.200]  Плюс ко всему, это часть типа, которую мы тоже проверяем. В локальных скопах вам
[16:47.200 --> 16:52.400]  никогда практически не приходится писать lifetime. Ну, вам же внутри функции конкретно не приходилось
[16:52.400 --> 16:58.160]  писать, какой lifetime там у ссылки на str, например. Ну, потому что inference работает хорошо у Rasta,
[16:58.160 --> 17:08.080]  в том числе lifetime выводы. Давайте посмотрим вот на такой примерчик. У нас есть x равный нулю y,
[17:08.080 --> 17:14.400]  ссылка на x и z, ссылка на y. Как выглядит тут lifetime? Здесь lifetime очень простой. Это просто скоп.
[17:14.400 --> 17:22.400]  Смотрите, lifetime a – это какой-то скоп, внутри него я объявляю x, равный нулю. Потом у меня внутри
[17:22.400 --> 17:30.600]  появляется еще один новый lifetime. Пустой комментарий. Так. Вот. Еще один новый lifetime.
[17:30.600 --> 17:43.240]  Внутри объявляется ссылка с lifetime b на x. И внутри c, где z – это ссылка с lifetime c на ссылку с lifetime b на i32.
[17:43.240 --> 17:54.280]  Итак. Проблема в чем? В том, что вот этот вот lifetime… Ну, смотрите. Понятно, что происходит с x конкретно.
[17:54.280 --> 17:58.880]  Он валиден только в течение этих трех строчек кода. Поэтому появился вот такой lifetime с трех
[17:58.920 --> 18:07.760]  строчек кода. Потом есть y. Y у нас валиден на протяжении этих двух строчек кода. Поэтому мы указываем ему,
[18:07.760 --> 18:17.360]  вот я валиден на протяжении b. Я не могу пережить b. Так. Потом есть c. Ну и тут то же самое. У нас
[18:17.360 --> 18:25.680]  ссылка на c на ссылку с lifetime b. По сути, это означает, что мы валидны на протяжении lifetime c. То есть мы
[18:25.680 --> 18:32.600]  здесь будем валидны только на протяжении одной строчки. Вот так вот примерно с регионами кода работает.
[18:32.600 --> 18:47.160]  Очень важно сейчас понять, что произошло здесь. Да, мы ставим lifetime объектов, на которые мы… Ну,
[18:47.160 --> 18:54.160]  lifetime и ссылок не должны перемешать lifetime объектов. Мы ставим, получается, меньше из lifetime ссылки
[18:54.160 --> 18:59.920]  объектов. То есть здесь в теории можно и a поставить. Тоже корректно. Потому что мы можем
[18:59.920 --> 19:13.840]  содержать ссылку как минимум на протяжении lifetime a. Так. Сейчас ты утверждаешь, что в объявлении y мы можем указать lifetime a.
[19:13.840 --> 19:18.800]  Ну, конкретно в данном случае у нас будет именно lifetime b, но вообще, да, можем и a указать. Потому что
[19:18.800 --> 19:23.640]  ссылка валидна на протяжении lifetime a. Но это ж правда, у нас объект не будет стёрт всё это время.
[19:23.640 --> 19:30.960]  Поэтому мы будем валидны на протяжении всего a. И эту ссылку мы можем держать на протяжении региона кода a.
[19:30.960 --> 19:36.640]  После этого момента мы уже будем не правы, если мы будем продолжать держать эту ссылку, иначе у нас
[19:36.640 --> 19:40.080]  объект удалился, а ссылка осталась. Как-то плохо.
[19:40.080 --> 19:46.240]  То есть по умочению до совершения нового lifetime мы можем чуть-чуть помочь и респректировать?
[19:47.080 --> 19:55.960]  Ну, вообще, так. На самом деле, вот эти вот lifetime a, если что, это некорректный расход.
[19:55.960 --> 20:03.960]  В локальных скопах они как бы существуют, но ты их не видишь. Их раз, на самом деле, вывозит сам компилятор.
[20:03.960 --> 20:15.760]  Ну, конкретно, что значит вот эта вот штука? Я валиден на протяжении lifetime такого-то.
[20:15.760 --> 20:21.960]  Здесь можно и a написать, как я уже сказал. Потому что наша ссылка валидна на протяжении всего lifetime a.
[20:21.960 --> 20:32.160]  На протяжении lifetime b мы тем более валидны, потому что он меньше. Как-то так. А тебя понятно?
[20:32.160 --> 20:42.960]  Окей, давайте второй пример. Он чуть-чуть, капелька сложнее. У нас будет какой-то x, z.
[20:42.960 --> 20:48.600]  Z, кстати, не интеллизируется. Потом встанет y, и как бы представить значение y.
[20:48.600 --> 20:56.400]  Ничего такого сложного не происходит. Просто вместо того, чтобы сделать let z равняется y снизу,
[20:56.400 --> 21:02.000]  я let z объявил чуть повыше, не интеллизируем. Чуть пониже сделал так.
[21:02.000 --> 21:10.080]  Оно рассахарится примерно вот в такую штуку. То же самое с x. Потом мне создается z,
[21:10.080 --> 21:17.440]  который валидна на протяжении lifetime b. Обратите внимание, что Rust будет видеть,
[21:17.440 --> 21:22.000]  что эта перемена не интеллизирована, и он не даст ей воспользоваться, например, где-то вот тут,
[21:22.000 --> 21:30.880]  посередине. Он будет трекить это. А вообще эта ссылка до тех пор, в тот момент, когда она
[21:30.880 --> 21:37.080]  не интеллизирована, она валидна на протяжении всего lifetime b, и даже lifetime a, потому что у нас
[21:37.080 --> 21:39.880]  эта ссылка на x будет в конечном итоге.
[21:53.000 --> 22:01.680]  Так, ну потом дальше мы создаем новый lifetime. Внутри у нас есть y, у которого lifetime b. Мы присваиваем
[22:01.680 --> 22:08.120]  значение вот такой ссылочки на x. Да, кстати, он получается чуть-чуть приврал. Мы не на протяжении
[22:08.120 --> 22:19.320]  lifetime b будем валидны. Сейчас скажу. Будем просто валидны на протяжении того, на протяжении чего.
[22:19.320 --> 22:24.120]  А, все-все-все, все правильно. Я вам не соврал. Можете ничего не стараться изговорить. Все правильно.
[22:24.120 --> 22:31.120]  Просто про свое значение y, на самом деле, там будет копирование. Я просто совмещал, что позабуду.
[22:35.120 --> 22:42.320]  Ну, примерно как-то так. Если у нас есть ссылка с lifetime a на какой-то тип t, это означает, что ссылку
[22:42.320 --> 22:48.120]  можно держать на протяжении lifetime a. Она валидна в регионе кода a. Как-то так.
[22:49.320 --> 23:00.320]  Лайфтайм c? Ну, потому что, смотри, у тебя как раз… Да, это хороший вопрос. Если ты здесь напишешь c,
[23:00.320 --> 23:07.320]  то в таком случае у тебя у y будет тип ссылка с lifetime c на y32. Ты будешь попытаться присвоить к ссылке
[23:07.320 --> 23:14.320]  на b на y32. Если бы это было возможно, тогда бы ты к ссылку, которая имеет меньше потенциально lifetime,
[23:14.320 --> 23:20.320]  смог бы присвоить к ссылке, которая имеет больше lifetime. И, соответственно, ты потенциально мог бы
[23:20.320 --> 23:28.320]  сделать unsafety. Потому что ты бы был… Вот меньше lifetime, вот больше lifetime. Ты взял ссылку отсюда,
[23:28.320 --> 23:32.320]  присвоил сюда. Соответственно, будет какой-то регион кода, в котором ты не валиден просто.
[23:32.320 --> 23:48.320]  Ну, вообще, это не придется никогда самостоятельно выводить. Да, они выведутся, например, в компиляторе
[23:48.320 --> 23:58.320]  как-то так. Как-то так все просто. Давайте попробуем найти вот эту ошибку. Для начала давайте посмотрим
[23:58.320 --> 24:12.320]  на верхний пример. Какая тут ошибка? Да, мы возвращаем ссылку, например, из локального сколка.
[24:12.320 --> 24:23.320]  Вот. И здесь мы отлично уже видим, что происходит. У нас есть b какой-то внутри. И мы пытаемся
[24:23.320 --> 24:31.320]  из b вернуть ссылку с lifetime as, а у нас s живет на протяжении lifetime b. И, соответственно, получается,
[24:31.320 --> 24:37.320]  что когда мы пытаемся вернуть ссылку на s, мы просто не можем расширить опять же эту ссылку,
[24:37.320 --> 24:42.320]  как в прошлом примере. Она может иметь максимум lifetime b, потому что объект имеет lifetime b.
[24:42.320 --> 25:06.320]  Так, все ли понятно? Вот это вот означает, что ты generic по lifetime a. Это означает, что ты принимаешь
[25:06.320 --> 25:14.320]  ссылку с lifetime a на u32 и возвращаешь ссылку на какой-то объект, который имеет такой же lifetime,
[25:14.320 --> 25:27.320]  типа str. Ну, конкретно в данном случае они не обязаны жить одновременно. Мы чуть позже
[25:27.320 --> 25:32.320]  обсудим, но вообще тебе ничего не мешало в данном случае вернуть строку статичную,
[25:32.320 --> 25:37.320]  какой-нибудь, hello world. Тогда бы здесь был статик lifetime и, понятное дело, статик lifetime живет
[25:37.320 --> 25:42.320]  не меньше, чем lifetime a. И тогда бы было конкретно вернуть, ну, корректно вернуть эту ссылку.
[25:42.320 --> 25:50.320]  Вот. Ну, конкретно в данном случае это означает, что мы как минимум должны жить не меньше,
[25:50.320 --> 25:57.320]  чем a. Здесь мы живем не меньше, чем a какой-то lifetime, и здесь мы живем не меньше, чем a тоже.
[25:57.320 --> 26:07.320]  Так, давайте четвертый пример еще посмотрим. Как вы думаете, как компилятор найдет ошибку?
[26:07.320 --> 26:12.320]  Ну, вообще, с этим примером мы знакомы еще с первой лекции. Пытаемся запушить вектор тогда,
[26:12.320 --> 26:18.320]  когда у нас есть на него ссылка. Смотрите, опять мы обессахурием, у нас получается lifetime a,
[26:18.320 --> 26:23.320]  в котором валиден вектор, lifetime b, в котором появляется ссылка. Вот это вот напоминаю,
[26:23.320 --> 26:29.320]  помните, мы дерево смотрели, на самом деле, вот эти вот квадратные скобочки просто синаптический сахар.
[26:29.320 --> 26:37.320]  Поэтому оно быстро выглядит так. Потом у нас есть lifetime c. И вот проблема в том, что компилятор уже
[26:37.320 --> 26:44.320]  в данном случае видит, что на протяжении lifetime b у нас есть ссылка с lifetime b, shared. Здесь внутри,
[26:44.320 --> 26:50.320]  в lifetime c, ну, короче, внутри этого региона кода мы пытаемся создать вторую ссылку. Это некорректно.
[26:50.320 --> 26:57.320]  Поэтому REST это запрещает. Чтобы создать эту ссылку, нам нужно выйти из этого региона кода
[26:57.320 --> 26:59.320]  и создать ее еще раз.
[26:59.320 --> 27:02.320]  А выйти мы не можем, потому что мы все предъявляем.
[27:02.320 --> 27:04.320]  Да.
[27:04.320 --> 27:06.320]  Как-то пока что просто, да?
[27:06.320 --> 27:10.320]  Сейчас видите, у нас не важен мутабельный раз.
[27:10.320 --> 27:14.320]  Да, здесь не мутабельная ссылка. Но когда ты делаешь дейтапу, то тогда тебе приходится
[27:14.320 --> 27:17.320]  брать мутабельную ссылку на вектор, ты его мутируешь.
[27:17.320 --> 27:22.320]  Сейчас покажите, где у нас, например, ссылка?
[27:22.320 --> 27:27.320]  Вот смотри, x это первая ссылочка, видишь, вот дейта. Потом, когда ты делаешь push,
[27:27.320 --> 27:31.320]  то ты должен взять, ну, помнишь мют селф ссылочка? Вот ты должен взять
[27:31.320 --> 27:36.320]  мутабельную ссылку на дейта. Это вот обессахаренный вид того, как на самом деле работает
[27:36.320 --> 27:40.320]  дейтапуш. Вот так вот. Вот тебе появляется тут вторая ссылочка, которую ты пытаешь
[27:40.320 --> 27:45.320]  создать. И это невозможно в этом lifetime. В этом lifetime ты можешь создать только еще
[27:45.320 --> 27:46.320]  широкие ссылки.
[27:46.320 --> 27:50.320]  Сейчас, получается, пентаятор видит, что он пытается делать мутабельность
[27:50.320 --> 27:56.320]  ссылку на дейта, но при этом он как-то по x знает, что он сделан из не мутабельной
[27:56.320 --> 27:58.320]  ссылки на дейта.
[27:58.320 --> 28:00.320]  Так, повтори, пожалуйста.
[28:00.320 --> 28:05.320]  Смотри, мы в ассоциированной функции index передаем не мутабельность ссылки на дейта,
[28:05.320 --> 28:11.320]  а результат сохраняем как под именем x, а последняя страница как будто бы эта ссылка
[28:11.320 --> 28:13.320]  куда-то ушла.
[28:13.320 --> 28:17.320]  Ссылка никуда не ушла, она же живет на протяжении b, она вся валидна на протяжении b.
[28:17.320 --> 28:19.320]  А, вот эта ссылка, которая...
[28:19.320 --> 28:20.320]  А, вот эта вот b дейта?
[28:20.320 --> 28:21.320]  Да, я...
[28:21.320 --> 28:23.320]  Нет, ты ее передал, а она сразу же умерла здесь.
[28:23.320 --> 28:26.320]  Все, ну ты ее как бы создал и вернул.
[28:26.320 --> 28:32.320]  Сейчас, а как тогда компендатор понимает, что x все еще сделан из дейта?
[28:32.320 --> 28:35.320]  Ну, это выглядит как какой-то просто corner case, который нужно разобрать во время
[28:35.320 --> 28:38.320]  создания самого нового скоба lifetime.
[28:38.320 --> 28:42.320]  Ну, смотрите, мы уже можем обратить внимание после всех этих примеров.
[28:42.320 --> 28:44.320]  Так выглядит, будто LED это у нас...
[28:44.320 --> 28:47.320]  Это у нас штука, которая объявляет новую власть в видимости.
[28:47.320 --> 28:50.320]  Собственно, нам важна только первая строчка.
[28:50.320 --> 28:52.320]  В этом смысле.
[28:52.320 --> 28:56.320]  Вот первые строчки я знаю, например, у меня создается x с lifetime таким-то ссылочком.
[28:56.320 --> 28:59.320]  После этого я, например, знаю, что все, у меня больше много будет дальше
[28:59.320 --> 29:01.320]  только шире ссылки на протяжении lifetime.
[29:05.320 --> 29:07.320]  Вот, что-то еще хотел сказать.
[29:07.320 --> 29:09.320]  А, вот.
[29:09.320 --> 29:11.320]  А, я, кстати, тебе соврал.
[29:11.320 --> 29:13.320]  Она не умерла, конечно же, ссылка.
[29:13.320 --> 29:15.320]  Ты заборвил дейту.
[29:17.320 --> 29:19.320]  Но при этом у тебя появилась x.
[29:19.320 --> 29:21.320]  Это какая-то другая штука, отдельная.
[29:21.320 --> 29:23.320]  Но она имеет тот же lifetime.
[29:23.320 --> 29:27.320]  Из-за этого получается, что ты не можешь создать еще одну ссылку mute на дейту.
[29:27.320 --> 29:30.320]  Потому что это ссылается как бы на это.
[29:30.320 --> 29:33.320]  А не с одним lifetime, соответственно, ты заборвил дейту.
[29:33.320 --> 29:36.320]  Тут самое важное, что нужно обратить внимание, это на то, что
[29:36.320 --> 29:39.320]  мы на самом деле ничего не знаем о том, что мы конкретно вектором пользуемся.
[29:39.320 --> 29:41.320]  Нам по барабану.
[29:41.320 --> 29:43.320]  Вот это тебе вопрос, да.
[29:43.320 --> 29:45.320]  Из кода не понятно, что мы...
[29:45.320 --> 29:48.320]  И дальше по коду не особо понятно, что мы вектором пользуемся.
[29:48.320 --> 29:51.320]  Ну, то есть дальше будет еще один пример, мы это еще отработаем.
[29:51.320 --> 29:54.320]  Но тут суть в том, что конкретно b здесь повторяется, конечно же.
[29:56.320 --> 29:58.320]  Так, важно, никто не теряется.
[29:58.320 --> 30:00.320]  Очень важно.
[30:00.320 --> 30:02.320]  Вот lifetime может быть более, чем scope.
[30:02.320 --> 30:05.320]  Здесь я обессахарит при всем своем желании не смогу.
[30:08.320 --> 30:11.320]  Ну, смотрите, у меня вот здесь вот создается какая-то ссылка на x.
[30:11.320 --> 30:16.320]  Внутри, если сам condition выполняется, вот здесь вот x у меня используется.
[30:16.320 --> 30:18.320]  А вот здесь вот и не используется.
[30:18.320 --> 30:21.320]  И конкретно регион кода будет выглядеть так,
[30:21.320 --> 30:25.320]  что я валиден на протяжении от x до конца ifa,
[30:25.320 --> 30:30.320]  не так, я буду валиден в строчке, где x объявляется, естественно, это 100%.
[30:30.320 --> 30:33.320]  И буду валиден вот в этого части ifa.
[30:33.320 --> 30:35.320]  А вот здесь вот меня не будет.
[30:35.320 --> 30:38.320]  То есть lifetime выглядит, сворачивает просто.
[30:38.320 --> 30:43.320]  Это регион кода, это не просто scope, как мы до этого посмотрели, примерно.
[30:43.320 --> 30:47.320]  Это регион кода, в течение которого мы валидны.
[30:47.320 --> 30:49.320]  Как-то так.
[30:49.320 --> 30:52.320]  Но более того, мы еще можем иметь дырки.
[30:52.320 --> 30:55.320]  То есть, смотрите, вот у нас полный линейный код.
[30:55.320 --> 30:59.320]  У нас тут x опять ссылочка, мы там выводим этот x.
[30:59.320 --> 31:04.320]  После этого мы сделаем data push и опять все что-то присваиваем.
[31:04.320 --> 31:08.320]  Это все тип один и тот же.
[31:08.320 --> 31:10.320]  Мы же let mute x сделали, да?
[31:10.320 --> 31:12.320]  Это все один и тот же тип.
[31:12.320 --> 31:14.320]  Ну, как-то так.
[31:14.320 --> 31:16.320]  Я ее здесь вот мутирую.
[31:16.320 --> 31:18.320]  Это вся та же самая ссылка.
[31:18.320 --> 31:20.320]  Но здесь вот мы не валидны.
[31:20.320 --> 31:24.320]  Это валидно сделать push, потому что я делаю после этого новый x.
[31:24.320 --> 31:28.320]  За счет этого компилятор может сделать дырку.
[31:28.320 --> 31:32.320]  Мы понимаем, что мы дальше не пользуемся старым значением.
[31:32.320 --> 31:34.320]  Мы просто его убираем.
[31:34.320 --> 31:38.320]  И вот здесь мы делаем дырку.
[31:38.320 --> 31:42.320]  Мы понимаем, что мы дальше не пользуемся старым значением.
[31:42.320 --> 31:44.320]  Мы просто его убираем.
[31:49.320 --> 31:52.320]  Вот, да, это как раз то, что я хотел сказать.
[31:52.320 --> 31:56.320]  Let создает новую область видимости.
[31:56.320 --> 31:59.320]  То есть внутри локальных скопов, когда вы пишете let,
[31:59.320 --> 32:02.320]  у вас создается какая-то область видимости, какой-то lifetime.
[32:02.320 --> 32:05.320]  Какой-то регион кода становится местом,
[32:05.320 --> 32:08.320]  который может жить и использоваться валидно.
[32:11.320 --> 32:14.320]  К сожалению, бров чекер – это не идеальная вещь.
[32:14.320 --> 32:17.320]  Он умеет запрещать код.
[32:17.320 --> 32:23.320]  Умеет, может, будет запрещать код, который, кажется, должен был бы скомпилироваться.
[32:23.320 --> 32:28.320]  Это один из примеров, который, возможно, конкретно данный пример,
[32:28.320 --> 32:33.320]  когда-то перестанет, ну, начнет компилироваться,
[32:33.320 --> 32:36.320]  но сейчас он пока что не компилируется.
[32:36.320 --> 32:38.320]  Как вы думаете, что здесь происходит?
[32:44.320 --> 32:47.320]  Не, ну, когда что-то происходит, понятно.
[32:47.320 --> 32:50.320]  Мы пытаемся достать значение из макро,
[32:50.320 --> 32:53.320]  если не получается, то вставляем дефолтное,
[32:53.320 --> 32:55.320]  возвращаем дефолт, ну, ссылку на него.
[32:55.320 --> 32:58.320]  Так, давай, более четко покажем, нигде проблемы.
[32:58.320 --> 33:02.320]  Ну, ты так уманно сказал, но ты мне уже наскорчал.
[33:02.320 --> 33:05.320]  Ты что, у нас сошло, ну, делайте нигде проблемы.
[33:05.320 --> 33:09.320]  И чтобы сканировать объект, требуется ссылка.
[33:11.320 --> 33:15.320]  Не, нужна просто обычная ссылка на объект, чтобы сканировать.
[33:16.320 --> 33:19.320]  Ну, тут, если что, ошибка не в KeyClaw.
[33:19.320 --> 33:23.320]  Если что, вы, если что, никогда не пишите getDefault.
[33:23.320 --> 33:27.320]  Если что, в мэпе, хэшмэпе можно написать entry,
[33:27.320 --> 33:30.320]  а после этого orDefault написать, или orInsert.
[33:30.320 --> 33:33.320]  Это все будет работать прекрасно.
[33:33.320 --> 33:36.320]  Или orInsertWidth, по-моему, еще есть.
[33:36.320 --> 33:40.320]  Ну, в общем, есть целый API, который вместо этой функции можно использовать.
[33:42.320 --> 33:45.320]  Ну, что-то такое.
[33:49.320 --> 33:52.320]  Сейчас, где проблема?
[33:52.320 --> 33:56.320]  Ты очень близок к проблеме, но компилятор нам все-таки,
[33:56.320 --> 33:59.320]  ну, то есть это тоже проблемная строчка будет,
[33:59.320 --> 34:02.320]  но компилятор все-таки на другой покажет.
[34:02.320 --> 34:05.320]  Он покажет наверх.
[34:05.320 --> 34:09.320]  Что произойдет? Вот, смотрите, у нас здесь getMute.
[34:09.320 --> 34:12.320]  У нас здесь мутабельная ссылочка.
[34:12.320 --> 34:16.320]  Создается на какой-то ключ, получается, на ссылку на MuteV.
[34:16.320 --> 34:20.320]  Если у нас это какое-то значение, то есть у нас действительно есть
[34:20.320 --> 34:23.320]  такой ключ, в том случае мы просто вернем значение.
[34:23.320 --> 34:26.320]  Здесь компилятор спорить не будет.
[34:26.320 --> 34:29.320]  Просто взяли, вернули ссылочку.
[34:29.320 --> 34:32.320]  А вот здесь вот дело в том, что наша ссылка на MuteV
[34:32.320 --> 34:35.320]  полидна в течение всего матча в данный момент.
[34:35.320 --> 34:38.320]  В течение всего. И, соответственно, когда вы попробуете сделать
[34:38.320 --> 34:41.320]  mapInsert, то, соответственно, здесь вот будет MuteСсылка.
[34:41.320 --> 34:44.320]  И здесь вот будет MuteСсылка.
[34:44.320 --> 34:47.320]  А если бы мы MuteInsert закомментировали, то по-прежнему?
[34:47.320 --> 34:51.320]  Ну, по идее он должен сказать, что он, мол, пытается getMute сделать еще раз.
[34:56.320 --> 34:59.320]  Ну, это вещь, которую, скорее всего, когда-то починят
[34:59.320 --> 35:02.320]  и сделают так, чтобы там умнее был BorrowChecker, скидывал ссылки
[35:02.320 --> 35:05.320]  в разных кусках матча.
[35:05.320 --> 35:08.320]  Но пока что он продолжает lifetime объекта, который попадает
[35:08.320 --> 35:11.320]  отсюда на протяжении всего матча.
[35:11.320 --> 35:15.320]  Вот. Прямо вот так вот будет выглядеть ошибка к регуляции.
[35:17.320 --> 35:21.320]  Вот как я и сказал, здесь вот getMute есть, у нас firstMutableBorrow
[35:21.320 --> 35:24.320]  мэпа и потом secondMutableBorrow.
[35:28.320 --> 35:31.320]  Так.
[35:31.320 --> 35:34.320]  Еще вы могли заметить, что REST от нас не требует
[35:34.320 --> 35:37.320]  писать постоянно lifetime повсюду.
[35:37.320 --> 35:40.320]  Мы иногда просто писали ссылку на что-то, и оно прекрасно работает.
[35:40.320 --> 35:43.320]  Причем именно в сигнат рейф-функции.
[35:44.320 --> 35:47.320]  Это называется lifetime elision.
[35:47.320 --> 35:50.320]  Давайте мы изучим, как это работает.
[35:50.320 --> 35:53.320]  В-первых, у нас есть понятие как input и output.
[35:55.320 --> 35:58.320]  lifetime позиции. Давайте чуть конкретнее посмотрим.
[35:58.320 --> 36:01.320]  Для всяких функций
[36:01.320 --> 36:04.320]  input — это то, что, соответственно, написано вот здесь,
[36:04.320 --> 36:07.320]  output — это то, что написано вот тут.
[36:07.320 --> 36:10.320]  И эти lifetime позиции...
[36:10.320 --> 36:13.320]  Конкретно покажите мне в данном случае, где lifetime позиция.
[36:13.320 --> 36:16.320]  На принципе на слайде написано.
[36:19.320 --> 36:22.320]  Где ampersand, там и lifetime.
[36:22.320 --> 36:25.320]  Соответственно, здесь одна input позиция,
[36:25.320 --> 36:28.320]  две output позиции.
[36:28.320 --> 36:31.320]  Это такая формалистика чуть-чуть. Понятно, что здесь нет.
[36:31.320 --> 36:34.320]  Для имплов, соответственно, все типы,
[36:34.320 --> 36:37.320]  которые вы вводите, в дженерике пишете,
[36:37.320 --> 36:40.320]  это все input.
[36:40.320 --> 36:43.320]  Конкретно в данном случае у нас здесь, заметьте,
[36:43.320 --> 36:46.320]  два lifetimes убрана.
[36:46.320 --> 36:49.320]  А здесь вот только один.
[36:49.320 --> 36:52.320]  Потому что для каждого объявления здесь вот есть input.
[36:52.320 --> 36:55.320]  А, надо уже давать отдельную дженерику структуры
[36:55.320 --> 36:58.320]  и отдельную дженерику рейфа.
[36:58.320 --> 37:01.320]  И поэтому для каждого своего рейфа.
[37:01.320 --> 37:04.320]  Так, ну давайте, это, на самом деле,
[37:04.320 --> 37:07.320]  сфекция, так что давайте активненько работать.
[37:07.320 --> 37:10.320]  Это вот простача часть реально.
[37:10.320 --> 37:13.320]  Смотрите, для начала, для всех lifetime в input позициях,
[37:13.320 --> 37:16.320]  вот как работает правило вывода lifetime,
[37:16.320 --> 37:19.320]  каждая input позиция становится уникальна
[37:19.320 --> 37:22.320]  в lifetime. Ну смотрите, у нас в принте одна есть input позиция,
[37:22.320 --> 37:25.320]  и мы ее заполнили каким-то lifetime.
[37:25.320 --> 37:28.320]  То есть мы написали вот такое вот, а компилятор, на самом деле,
[37:28.320 --> 37:31.320]  не явно написал такое.
[37:31.320 --> 37:34.320]  Здесь debug. Здесь у нас тоже одна input позиция только.
[37:34.320 --> 37:37.320]  То есть несмотря на то, что у level нет никаких lifetimes,
[37:37.320 --> 37:40.320]  компилятор посчитал, что это, в общем,
[37:40.320 --> 37:43.320]  здесь lifetimes нет, все правильно.
[37:48.320 --> 37:51.320]  Он только там, где нужно lifetime считает.
[37:51.320 --> 37:54.320]  То же самое, например, если у нас две строчки,
[37:54.320 --> 37:57.320]  то в таком случае он сделает два отдельных lifetimes.
[37:57.320 --> 38:00.320]  Ну и, наконец,
[38:00.320 --> 38:03.320]  третий пример.
[38:03.320 --> 38:06.320]  Если у нас здесь уже один из lifetimes написан,
[38:06.320 --> 38:09.320]  то в таком случае мы не считаем, что это lifetime position,
[38:09.320 --> 38:12.320]  и мы скипаем его.
[38:12.320 --> 38:15.320]  Ну что-то такое, просто где не написан lifetime, там компилятор,
[38:15.320 --> 38:18.320]  а здесь input position.
[38:21.320 --> 38:24.320]  Потом, если у нас есть точно одна input позиция,
[38:24.320 --> 38:27.320]  то в таком случае мы
[38:27.320 --> 38:30.320]  присваиваем всем output позициям
[38:30.320 --> 38:33.320]  вот этот input lifetime.
[38:33.320 --> 38:36.320]  Смотрите, у нас есть substring.
[38:36.320 --> 38:39.320]  Здесь у нас только одна input позиция.
[38:39.320 --> 38:42.320]  Соответственно, я написал здесь astr, и здесь тоже сделал astr
[38:42.320 --> 38:45.320]  позиция всех. Если бы здесь было 10 строк, то все бы имели lifetime
[38:45.320 --> 38:48.320]  штриха.
[38:48.320 --> 38:51.320]  А вот это вот не сработает, потому что у нас две input
[38:51.320 --> 38:54.320]  позиции. Соответственно, a, b, там компилятор не знает, что
[38:54.320 --> 38:57.320]  вернется lifetime a или lifetime b, и говорит, не отказываюсь
[38:57.320 --> 39:00.320]  выводить сам напиши. То есть, эти правила сделаны
[39:00.320 --> 39:03.320]  для того, чтобы в большинстве случаев правильно
[39:03.320 --> 39:06.320]  выводить, какие lifetimes вы хотите.
[39:06.320 --> 39:09.320]  В принципе, правила очень простые, но их хватает
[39:09.320 --> 39:12.320]  в большинстве ситуаций.
[39:12.320 --> 39:15.320]  Потом, если у нас есть несколько input позиции,
[39:15.320 --> 39:18.320]  ну одна из них self, то в таком случае
[39:18.320 --> 39:21.320]  мы для всех output позиций пишем
[39:21.320 --> 39:24.320]  именно lifetime self.
[39:24.320 --> 39:27.320]  Логично предположить, что если мы входим
[39:27.320 --> 39:30.320]  в какую-то функцию,
[39:30.320 --> 39:33.320]  в таком случае мы, скорее всего, хотим что-то отself
[39:33.320 --> 39:36.320]  вернуть. Поэтому компилятор поставит за нас ручками
[39:36.320 --> 39:39.320]  lifetime на self позицию.
[39:39.320 --> 39:42.320]  Например, в getnewt он просто
[39:42.320 --> 39:45.320]  self
[39:45.320 --> 39:48.320]  и в output позицию.
[39:48.320 --> 39:51.320]  Также и в ARX у нас получается вот здесь
[39:51.320 --> 39:54.320]  две input позиции.
[39:54.320 --> 39:57.320]  Каждый из них мы дали свой собственный lifetime,
[39:57.320 --> 40:00.320]  но так как у нас есть self, то мы поставили автоматически
[40:00.320 --> 40:03.320]  все outputы.
[40:03.320 --> 40:06.320]  Теми, какие у self.
[40:06.320 --> 40:09.320]  Как так?
[40:09.320 --> 40:12.320]  В противном случае это ошибка выводить lifetime.
[40:12.320 --> 40:15.320]  Например, если у нас нет lifetime слева
[40:15.320 --> 40:18.320]  и справа что-то есть, то когда компилятор не понимает,
[40:18.320 --> 40:21.320]  какой ты вообще lifetime собираешься выводить?
[40:21.320 --> 40:24.320]  Я таких не знаю.
[40:24.320 --> 40:27.320]  Если это отдельно настоящая строка,
[40:27.320 --> 40:30.320]  скорее всего это будет static.
[40:30.320 --> 40:33.320]  А если это статическая функция
[40:33.320 --> 40:36.320]  какой-то ерунды, то в таком случае непонятно,
[40:36.320 --> 40:39.320]  какой именно lifetime там будет.
[40:39.320 --> 40:42.320]  Compairs.
[40:45.320 --> 40:48.320]  Еще, например,
[40:48.320 --> 40:51.320]  итераторы тоже зависят.
[40:51.320 --> 40:54.320]  Мы видели в примере с вектором, когда мы берем ссылочку
[40:54.320 --> 40:57.320]  на вектор.
[40:57.320 --> 41:00.320]  У нас была ссылка на вектор,
[41:00.320 --> 41:03.320]  и с тем же lifetime мы делали обычную
[41:03.320 --> 41:06.320]  shared отсылку.
[41:06.320 --> 41:09.320]  Это все потому, что мы ссылались с lifetime на вектор.
[41:09.320 --> 41:12.320]  То же самое итераторы делают.
[41:12.320 --> 41:15.320]  Они имеют какой-то lifetime.
[41:15.320 --> 41:18.320]  И по умолчанию, раз тот вас требует
[41:18.320 --> 41:21.320]  их написать, но вы можете написать нижнее
[41:21.320 --> 41:24.320]  подчеркивание и ему сказать,
[41:24.320 --> 41:27.320]  выведите за меня по правилам lifetime и legion.
[41:27.320 --> 41:30.320]  То есть он будет это считать, просто позиция какая-то,
[41:30.320 --> 41:33.320]  как обычно выведу.
[41:33.320 --> 41:36.320]  Это дженерик выведет сам.
[41:40.320 --> 41:43.320]  Кстати, обратите внимание, тут же трешочек есть
[41:43.320 --> 41:46.320]  перед underscope,
[41:46.320 --> 41:49.320]  чтобы RAST понимал, что выводите именно lifetime.
[41:49.320 --> 41:52.320]  Теперь давайте поговорим про некоторые
[41:52.320 --> 41:55.320]  сложности с тем, как работать
[41:55.320 --> 41:58.320]  с системой типа RAST.
[41:58.320 --> 42:01.320]  Естественно, какие-то программы
[42:01.320 --> 42:04.320]  будут поднимать неправильно.
[42:04.320 --> 42:07.320]  Возможно написать программу, которая будет компилироваться,
[42:07.320 --> 42:10.320]  но при этом семантически не будет верны.
[42:10.320 --> 42:13.320]  Например, вот у нас есть byteEther,
[42:13.320 --> 42:16.320]  который имеет какой-то остаток,
[42:16.320 --> 42:19.320]  то есть slice внутри.
[42:19.320 --> 42:22.320]  То, что мы делаем, это либо если остаток пустой,
[42:22.320 --> 42:25.320]  то возвращаем нам, иначе мы берем ссылочку
[42:25.320 --> 42:28.320]  на первый byte, reminder это все, что после первого byte
[42:29.320 --> 42:32.320]  достаточно просто.
[42:32.320 --> 42:35.320]  И даже будет в каком-то смысле работать.
[42:35.320 --> 42:38.320]  То есть вот я сделал byteEther,
[42:38.320 --> 42:41.320]  вот сделал reminder на какую-то
[42:41.320 --> 42:44.320]  статическую строчку из единички,
[42:44.320 --> 42:47.320]  это какая-то byteWrite строка.
[42:47.320 --> 42:50.320]  Вот я вызвал next, и оно сработало.
[42:50.320 --> 42:53.320]  Второй раз now оно сработало. Прекрасно.
[42:53.320 --> 42:56.320]  Теперь давайте второй раз сделаем next.
[42:56.320 --> 42:59.320]  Ну, конечно, не догадайтесь, что произойдет.
[42:59.320 --> 43:02.320]  Ладно, догадайтесь, но вы не знаете, наверное, почему.
[43:02.320 --> 43:05.320]  Потому что из-за того, что мы вызвали next два раза,
[43:05.320 --> 43:08.320]  у нас не скомпилируется в данный момент программа.
[43:08.320 --> 43:11.320]  Вот с такой вот ошибкой.
[43:11.320 --> 43:14.320]  Что же пошло не так?
[43:14.320 --> 43:17.320]  Раз нас измучил, да, просто написали какой-то
[43:17.320 --> 43:20.320]  простейший итератор, и он просто заблокировал нам программу.
[43:20.320 --> 43:23.320]  Как неправильно.
[43:24.320 --> 43:27.320]  Как вы думаете, что произошло?
[43:33.320 --> 43:36.320]  На самом деле мы знаем ответ.
[43:36.320 --> 43:39.320]  В том блоке...
[43:39.320 --> 43:42.320]  Волт подпозиционного проставил, у нас теперь...
[43:42.320 --> 43:45.320]  Так, давай, полностью разведи.
[43:45.320 --> 43:48.320]  Получается, он приводит lifetime
[43:48.320 --> 43:51.320]  и проставил lifetime self
[43:51.320 --> 43:54.320]  волт подпозицион.
[43:54.320 --> 43:57.320]  Получается, мы дважды вызвали next.
[43:57.320 --> 44:00.320]  Он нам вернул две ссылки
[44:00.320 --> 44:03.320]  с одинаковым lifetime.
[44:06.320 --> 44:09.320]  Это правда, вернулось две мутабельные ссылки
[44:09.320 --> 44:12.320]  с одинаковым lifetime.
[44:12.320 --> 44:15.320]  Две мутабельные ссылки.
[44:15.320 --> 44:18.320]  Да, да, да.
[44:21.320 --> 44:24.320]  Да, да, ну, в общем, ты абсолютно прав,
[44:24.320 --> 44:27.320]  ты абсолютно правильно сказал ответ.
[44:27.320 --> 44:30.320]  Да, сейчас вот
[44:30.320 --> 44:33.320]  еще раз будет на слайдах, еще раз проговорим, давайте.
[44:33.320 --> 44:36.320]  Давайте попробуем воспользоваться правилами lifetime
[44:36.320 --> 44:39.320]  и legion, чтобы понять, что здесь конкретно происходит.
[44:39.320 --> 44:42.320]  Выпишем для начала.
[44:42.320 --> 44:45.320]  Прям с именами, чтобы было понятно.
[44:45.320 --> 44:48.320]  Смотрите, ну, вместо A и B
[44:48.320 --> 44:51.320]  я написал там remainder, чтобы было чуть понятнее.
[44:51.320 --> 44:54.320]  Вот. У нас есть lifetime
[44:54.320 --> 44:57.320]  remainder. Потом я беру
[44:57.320 --> 45:00.320]  by theta с remainder. И смотрите,
[45:00.320 --> 45:03.320]  по правилам lifetime и legion у нас одна input позиция,
[45:03.320 --> 45:06.320]  здесь одна output позиция. Он берет
[45:06.320 --> 45:09.320]  штрих A, вот сюда штрих A, штрих A.
[45:09.320 --> 45:12.320]  Ну, я назвал, конечно, не штриха, а rself.
[45:12.320 --> 45:15.320]  Ссылка на self. И смотрите, у нас возвращается
[45:15.320 --> 45:18.320]  ссылка
[45:18.320 --> 45:21.320]  rself на u8.
[45:21.320 --> 45:24.320]  Это означает, что мы, если попробуем
[45:24.320 --> 45:27.320]  второй раз вызвать next, в таком случае мы второй раз
[45:27.320 --> 45:30.320]  попробуем заборвить mute self.
[45:30.320 --> 45:33.320]  Это точно такой же пример, как у нас был
[45:33.320 --> 45:36.320]  до этого с вектором, когда мы делали index
[45:36.320 --> 45:39.320]  и, соответственно, мы заборвали по lifetime вектор.
[45:39.320 --> 45:42.320]  То же самое мы сейчас по lifetime заборвали наш self.
[45:42.320 --> 45:45.320]  Второй раз.
[45:45.320 --> 45:48.320]  Так, так, что?
[45:48.320 --> 45:51.320]  Да, это один и тот же lifetime
[45:51.320 --> 45:54.320]  будет.
[45:54.320 --> 45:57.320]  Ну, прям получится, смотри, у тебя в этом коде
[45:57.320 --> 46:00.320]  у тебя будет by theta, у тебя, соответственно, там
[46:00.320 --> 46:03.320]  откроется скоп какой-то, да, штриха, и потом
[46:03.320 --> 46:06.320]  ты будешь дважды возвращать next от
[46:06.320 --> 46:09.320]  next.
[46:09.320 --> 46:12.320]  И потом ты будешь дважды возвращать next от
[46:12.320 --> 46:15.320]  штриха bytes, ну там, ссылка
[46:15.320 --> 46:18.320]  штриха mute bytes.
[46:18.320 --> 46:21.320]  Да.
[46:24.320 --> 46:27.320]  Да, абсолютно правильно. Нужно написать
[46:27.320 --> 46:30.320]  remainder, потому что у нас byte вступает с remainder.
[46:30.320 --> 46:33.320]  Мы бороем remainder, а не self. Мы не
[46:33.320 --> 46:36.320]  iterator бороем, мы бороем то, что под iterator.
[46:37.320 --> 46:40.320]  Вот. Ну, это как раз то, что мы
[46:40.320 --> 46:43.320]  уже обсудили здесь написано на слайде.
[46:49.320 --> 46:52.320]  В общем, раз считает, что наш
[46:52.320 --> 46:54.320]  опшен возвращает ссылку на byte
[46:54.320 --> 46:57.320]  iter, но на самом деле мы возвращаем ссылку на remainder.
[46:57.320 --> 47:00.320]  Мы хотим это починить, конечно. Ну, потому что мы
[47:00.320 --> 47:03.320]  только что нарушили xsm, причем нам раз-то верно показал,
[47:03.320 --> 47:06.320]  что мы его нарушили. Вот давайте мы допишем
[47:06.320 --> 47:09.320]  remainder, просто явно, и все заработает.
[47:09.320 --> 47:12.320]  Теперь мы сможем запустить next дважды.
[47:12.320 --> 47:15.320]  И мы будем с точки зрения rasta дважды
[47:15.320 --> 47:18.320]  боровить remainder под ним. Ну, то есть там
[47:18.320 --> 47:21.320]  будет shared boro и он, естественно, будет работать, потому что shared
[47:21.320 --> 47:24.320]  boro может несколько раз делать. Все
[47:24.320 --> 47:27.320]  логично.
[47:27.320 --> 47:30.320]  А почему раз компилировал первые случаи
[47:30.320 --> 47:33.320]  Итак, это кажется, это
[47:33.320 --> 47:36.320]  потерялось. Да, это
[47:36.320 --> 47:39.320]  это потерявшиеся какие-то слайды.
[47:44.320 --> 47:47.320]  У меня есть подозрения, знаете, вот здесь вот
[47:47.320 --> 47:50.320]  first case, я знаю, что тут должно быть. Здесь должно быть
[47:50.320 --> 47:53.320]  про mysell, такую штучку. Давайте я посмотрю,
[47:53.320 --> 47:56.320]  точно ли мы ничего не пропустили.
[47:56.320 --> 47:59.320]  Наверное, даже проще вот сюда.
[48:00.320 --> 48:03.320]  Такс.
[48:14.320 --> 48:17.320]  Может быть, это просто... Ладно, давайте пока что
[48:17.320 --> 48:20.320]  забьем. Если там не будет, то тогда
[48:20.320 --> 48:23.320]  если что скажем. Вот, это слайды,
[48:23.320 --> 48:26.320]  которые фафали не туда, куда должны были.
[48:26.320 --> 48:29.320]  Достаточно сложно в техе на самом деле
[48:29.320 --> 48:32.320]  регулировать порядок слайдов, чтобы они
[48:32.320 --> 48:35.320]  копируются и так далее, потому что это...
[48:41.320 --> 48:44.320]  Примерно понятно ли после этого, что такое
[48:44.320 --> 48:47.320]  locktime? Мы пока что не претендуем на самое крутое
[48:47.320 --> 48:50.320]  понимание того, как это работает после этой части лекции.
[48:50.320 --> 48:53.320]  Мы должны просто понять, что у нас есть какие-то регионы кода,
[48:53.320 --> 48:56.320]  в течение которых нас валидны переменные,
[48:56.320 --> 48:59.320]  и мы делаем ссылочку, то на самом деле мы боруем объект,
[48:59.320 --> 49:02.320]  который под ссылкой, внутри этого lifetime,
[49:02.320 --> 49:05.320]  и проверяем с помощью BorrowChecker,
[49:05.320 --> 49:08.320]  что мы на самом деле делаем либо много шер и ссылку, либо
[49:08.320 --> 49:11.320]  одну мьюту. Это все.
[49:11.320 --> 49:14.320]  Ну и естественно, заботимся о том, чтобы у нас
[49:14.320 --> 49:17.320]  не переживали ссылки объекта.
[49:19.320 --> 49:22.320]  Вот. Дошли до такой вот штуки
[49:22.320 --> 49:25.320]  higherRankTradeBounds.
[49:26.320 --> 49:29.320]  Давайте попробуем reimplementить
[49:29.320 --> 49:32.320]  фильтр option. Фильтр
[49:32.320 --> 49:35.320]  такая штука, которая принимает на вход какую-то функцию,
[49:35.320 --> 49:38.320]  если она правда возвращает труд,
[49:38.320 --> 49:41.320]  в таком случае мы возвращаем some value,
[49:41.320 --> 49:44.320]  и при условии, что у нас value, конечно же, есть в option,
[49:44.320 --> 49:47.320]  либо none. Вот. Смотрите на этот код,
[49:47.320 --> 49:50.320]  понятен ли вы?
[49:56.320 --> 49:59.320]  Не помнишь fntrade?
[50:01.320 --> 50:04.320]  Да, помню.
[50:04.320 --> 50:07.320]  Ну, было на лекции у нас, кажется, прошлый, наверное.
[50:07.320 --> 50:10.320]  Да, на прошлый closures была первая часть лекции.
[50:10.320 --> 50:13.320]  Вот. Это fntrade.
[50:13.320 --> 50:16.320]  Вспомнил, да.
[50:16.320 --> 50:19.320]  Вот. Принимаем на вход какую-то функцию, которую можно
[50:19.320 --> 50:22.320]  вызвать, по крайней мере, один раз, но это неважно.
[50:22.320 --> 50:25.320]  Не будем мы потом задумываться. Мы про lifetime тут думаем,
[50:25.320 --> 50:28.320]  что у нас lifetime. Это, конечно, скомпилируется,
[50:28.320 --> 50:31.320]  но давайте попробуем явно написать lifetime.
[50:31.320 --> 50:34.320]  У нас получается какой-то option at,
[50:34.320 --> 50:37.320]  а потом мы думаем, а как же нам написать lifetime
[50:37.320 --> 50:40.320]  для fn1?
[50:40.320 --> 50:43.320]  Какие у вас есть идеи?
[50:43.320 --> 50:46.320]  Не важно. Можете мне говорить самое глупое решение,
[50:46.320 --> 50:49.320]  даже если оно неправильное, мы его разберем.
[50:49.320 --> 50:52.320]  Сейчас, погоди.
[50:52.320 --> 50:55.320]  Оно простаивает lifetime b.
[51:06.320 --> 51:09.320]  Ну, кажется, что вообще, ну, сука,
[51:09.320 --> 51:12.320]  которую мы туда пигдаем, оно должно быть как-то подвесно
[51:12.320 --> 51:15.320]  к lifetime option.
[51:15.320 --> 51:18.320]  Сейчас, сейчас, сейчас, стоп. А хотя-то чем?
[51:18.320 --> 51:21.320]  В каком-то направлении ты думаешь.
[51:26.320 --> 51:29.320]  Да, нам, наверное, пофиг на lifetime.
[51:29.320 --> 51:32.320]  Ну ладно, я ожидал услышать какое-нибудь такое глупое решение.
[51:32.320 --> 51:35.320]  Давайте, зафигачим сверху фильтр lifetime
[51:35.320 --> 51:38.320]  и запишем его сверху.
[51:38.320 --> 51:41.320]  Ладно, давайте посмотрим дальше, что будет.
[51:41.320 --> 51:44.320]  Вот. Как нам вообще это все написать?
[51:44.320 --> 51:47.320]  В общем, первая же идея, которая приходит в голову,
[51:47.320 --> 51:50.320]  наверное, неопытному пользователю Rust,
[51:50.320 --> 51:52.320]  это написать сверху, вот здесь,
[51:52.320 --> 51:55.320]  стрейшочек a, ну, fnfilter,
[51:55.320 --> 51:58.320]  стрейшочек af, да, и после этого fnonce,
[51:58.320 --> 52:01.320]  стрейшочек at, вроде бы.
[52:01.320 --> 52:04.320]  Да, оно не согласуется с тем, что внутри.
[52:04.320 --> 52:07.320]  Ну, давайте мы это попробуем один раз проделать,
[52:07.320 --> 52:10.320]  раз мы начали.
[52:10.320 --> 52:13.320]  Вот, у нас есть ссылочка a.
[52:13.320 --> 52:16.320]  Да, и теперь получается, что мы возвращаем,
[52:16.320 --> 52:18.320]  что у нас value из себя представляет
[52:18.320 --> 52:21.320]  какую-то переменную с lifetime b,
[52:21.320 --> 52:24.320]  потому что мы взяли self,
[52:24.320 --> 52:27.320]  заметьте, мы self взяли по значению,
[52:27.320 --> 52:30.320]  потом мы сделали let some value self,
[52:30.320 --> 52:33.320]  здесь lifetime b в течение которого value валидно.
[52:33.320 --> 52:36.320]  Потом у нас есть if, ссылочка на b,
[52:36.320 --> 52:39.320]  value корректно, тогда вернет some value.
[52:39.320 --> 52:42.320]  Вот, раз на этот код пожалуется,
[52:42.320 --> 52:45.320]  в первую очередь, он скажет, что
[52:45.320 --> 52:48.320]  у нас тенни живет достаточно долго,
[52:48.320 --> 52:51.320]  что у нас value не способно прожить
[52:51.320 --> 52:54.320]  на протяжении a.
[52:54.320 --> 52:57.320]  Давайте я вам объясню, что значит
[52:57.320 --> 53:00.320]  тенни может прожить на протяжении a.
[53:00.320 --> 53:03.320]  Дело в том, что когда вы пишете lifetime
[53:03.320 --> 53:06.320]  в генериках функции, то вы говорите про какие-то внешние
[53:06.320 --> 53:09.320]  по отношению к вам lifetime.
[53:09.320 --> 53:12.320]  А здесь происходит какой-то внутренний.
[53:12.320 --> 53:15.320]  Вы не можете сослаться на внутренний lifetime, да?
[53:15.320 --> 53:18.320]  То есть когда вы пишете
[53:18.320 --> 53:21.320]  штрих a, то в таком случае это для input
[53:21.320 --> 53:24.320]  аргументов, это про какие-то внешние lifetime,
[53:24.320 --> 53:27.320]  которые у вас вызывают речь.
[53:27.320 --> 53:30.320]  Вот, и здесь происходит какая-то
[53:30.320 --> 53:33.320]  такая локальная история,
[53:33.320 --> 53:36.320]  бы сказал Иван Генрихович.
[53:36.320 --> 53:39.320]  Вот, ну давайте мы попробуем
[53:39.320 --> 53:42.320]  компилятор зафигачить штрих a, он же так нам советует.
[53:42.320 --> 53:45.320]  Оставили штрешочек a на t.
[53:45.320 --> 53:48.320]  Все, как ты просишь, компилятор. Блин.
[53:51.320 --> 53:54.320]  Вот, и получается такая история, что мы пишем
[53:54.320 --> 53:57.320]  штрешочек a, и нам теперь утверждают,
[53:57.320 --> 54:00.320]  что у нас lifetime,
[54:00.320 --> 54:03.320]  ну в общем наша ссылочка, которая валидна
[54:03.320 --> 54:06.320]  на протяжении b, как мы выяснили,
[54:06.320 --> 54:09.320]  да, она живет меньше, чем a, а a это какой-то внешний lifetime.
[54:09.320 --> 54:12.320]  А раз уж он внешний, то он живет, по крайней мере, на протяжении всей функции.
[54:12.320 --> 54:15.320]  А у нас на протяжении всей функции
[54:15.320 --> 54:18.320]  локальная переменная, конечно, не живет.
[54:18.320 --> 54:21.320]  Ну, всей функции, в этом плане, переживает
[54:21.320 --> 54:24.320]  функцию, прям ее вызвать.
[54:26.320 --> 54:29.320]  Вот блин, да?
[54:29.320 --> 54:32.320]  Ну, в общем, запомните.
[54:32.320 --> 54:35.320]  Мы ему дали внешний lifetime, а он
[54:35.320 --> 54:38.320]  что-то заведомо меньше. Да, да.
[54:38.320 --> 54:41.320]  Именно так. Более маленький lifetime.
[54:41.320 --> 54:44.320]  Вот. Соответственно, мы
[54:44.320 --> 54:47.320]  ну вот, запомните, что
[54:47.320 --> 54:50.320]  в агроментах функций мы говорим про какие-то внешние lifetime.
[54:50.320 --> 54:53.320]  То есть, мы говорим про те lifetime, которые нам передают наши пользователи.
[54:53.320 --> 54:56.320]  Вот. А
[54:56.320 --> 54:59.320]  ну, а мы тут внутри хотим что-то локальное написать.
[54:59.320 --> 55:02.320]  Ну, и в данном случае
[55:02.320 --> 55:05.320]  ну, если бы мы написали а, то в таком случае
[55:05.320 --> 55:08.320]  а должно было бы быть локальным lifetime.
[55:08.320 --> 55:11.320]  Ну, к сожалению, это не так. Как же это решается?
[55:11.320 --> 55:14.320]  Кстати, да, тут еще есть ремарочка
[55:14.320 --> 55:17.320]  при том, как решать.
[55:17.320 --> 55:20.320]  Раст, ну, вот мы начинаем потихонечку заглядывать за кулисы.
[55:20.320 --> 55:23.320]  Раст четко требует от вас, чтобы вы написали
[55:23.320 --> 55:26.320]  сигнатуру функции.
[55:26.320 --> 55:29.320]  И input аргумента, и output аргумента, что там, конечно, выведет за вас.
[55:29.320 --> 55:32.320]  Ну, вот.
[55:32.320 --> 55:35.320]  Какие-то ограничения на lifetime, какие-то ограничения
[55:35.320 --> 55:38.320]  на имплементацию трейтов объектами вы пишете функции.
[55:38.320 --> 55:41.320]  И сигнатура функции должна четко задавать, как эта функция работает.
[55:41.320 --> 55:44.320]  То есть, какие...
[55:44.320 --> 55:47.320]  Например, если вы принимаете на вход статическую
[55:47.320 --> 55:50.320]  строку, которые живет на протяжении a только,
[55:50.320 --> 55:53.320]  и возвращаете строчку на протяжении a,
[55:53.320 --> 55:56.320]  то она не может жить меньше. Она должна жить
[55:56.320 --> 55:59.320]  как минимум как та строчка, которую вы передали.
[55:59.320 --> 56:02.320]  То есть, идея
[56:02.320 --> 56:05.320]  вся эта за Rast будет в том, чтобы
[56:05.320 --> 56:08.320]  правильно, ну, не только что-то в локальном скопу сделать,
[56:08.320 --> 56:11.320]  но и в том, чтобы понять, как у нас
[56:11.320 --> 56:14.320]  работают сигнатура функции.
[56:14.320 --> 56:17.320]  Если у нас сигнатура функции согласуется с тем кодом,
[56:17.320 --> 56:20.320]  который вызывает,
[56:20.320 --> 56:23.320]  то в таком случае у нас обязательно должно получиться save
[56:23.320 --> 56:26.320]  приложение. Это формально доказывается,
[56:26.320 --> 56:29.320]  но мы это не будем делать. Конечно, лекции у нас более-менее практичные.
[56:29.320 --> 56:32.320]  Там прям кок, использовали язык,
[56:32.320 --> 56:35.320]  доказывали все.
[56:35.320 --> 56:38.320]  Это тоже такая ремарочка, что у нас
[56:38.320 --> 56:41.320]  комьюнити тоже стремится
[56:41.320 --> 56:44.320]  сделать так, чтобы у нас был такой readable code, но на самом деле
[56:44.320 --> 56:47.320]  это не просто идиом, а это даже в каком-то смысле
[56:47.320 --> 56:50.320]  это ограничение Rasta, потому что он вас заставляет
[56:50.320 --> 56:53.320]  создавать понятные функции,
[56:53.320 --> 56:56.320]  что и как они возвращают, и что и как они делают.
[56:56.320 --> 56:59.320]  Иначе у вас просто разломается программа.
[57:09.320 --> 57:12.320]  То, что ты не можешь возвращать авто, связано с тем, что есть
[57:12.320 --> 57:15.320]  Type Inference такая штука. Там есть система типов
[57:15.320 --> 57:18.320]  Hindley-Millner, как-то так называется,
[57:18.320 --> 57:21.320]  и Rasta просто для того, чтобы выводить аргументы
[57:21.320 --> 57:24.320]  в локальных скопах было удобно, требует от функций, чтобы
[57:24.320 --> 57:27.320]  они точно указывали, что они возвращают.
[57:27.320 --> 57:30.320]  И тогда тебе становится очень легко выводить.
[57:30.320 --> 57:33.320]  Ну и авто, плюс не говорить ничего о сигнатуре функции,
[57:33.320 --> 57:36.320]  просто потому что это плохо как-то
[57:36.320 --> 57:39.320]  писать авто, и приходится человеку заглядывать внутрь функции.
[57:39.320 --> 57:42.320]  Ну как же мы обсуждали на лекции?
[57:42.320 --> 57:45.320]  Impel FM.
[57:49.320 --> 57:52.320]  Вот так.
[57:52.320 --> 57:55.320]  Это как решается эта проблема. Смотрите, у нас есть специальный
[57:55.320 --> 57:58.320]  синтекс, который называется High-Rank Trade Bond.
[57:58.320 --> 58:01.320]  Мы пишем, что наша функция
[58:01.320 --> 58:04.320]  должна быть валидна для любого лайфтайма A.
[58:04.320 --> 58:07.320]  Естественно, у нас там может быть
[58:07.320 --> 58:10.320]  произвольным образом двигаться лайфтайма
[58:10.320 --> 58:13.320]  внутрь скопа, но мы должны быть валидны для любого из них.
[58:13.320 --> 58:16.320]  Поэтому мы пишем, что для любого лайфтайма A
[58:16.320 --> 58:19.320]  функция ссылка
[58:19.320 --> 58:22.320]  на tab будет коррект.
[58:22.320 --> 58:25.320]  И это скомпилируется.
[58:25.320 --> 58:28.320]  И это то, как это нужно написать.
[58:28.320 --> 58:31.320]  Если вы хотите, конечно, указать лайфтайм.
[58:31.320 --> 58:34.320]  В большую часть времени,
[58:34.320 --> 58:37.320]  как я сказал, вот это вот пример, если вы не будете явно писать лайфтайм,
[58:37.320 --> 58:40.320]  компилятор будет за вас HRTB
[58:40.320 --> 58:43.320]  ставить.
[58:43.320 --> 58:46.320]  То есть он будет
[58:46.320 --> 58:49.320]  явно за вас выводить,
[58:49.320 --> 58:52.320]  что там for, lifetime, и там такие же правила lifetime и legion,
[58:52.320 --> 58:55.320]  как и у обычных функций.
[58:55.320 --> 58:58.320]  Например, здесь одна input-позиция, он просто поймет, что ей нужно
[58:58.320 --> 59:01.320]  зафигачить лайфтайм A и допишет сам за вас HRTB.
[59:01.320 --> 59:04.320]  Эта штука очень редкая.
[59:04.320 --> 59:07.320]  Это прям редкий покемон.
[59:07.320 --> 59:10.320]  В стандартной библиотеке встречается только лишь трижды,
[59:10.320 --> 59:13.320]  чтобы вы понимали.
[59:13.320 --> 59:16.320]  Даже в этом вот случае, несмотря на то, что я показал такой пример,
[59:16.320 --> 59:19.320]  где можно воспользоваться HRBT, в нем, на самом деле, HRBT не нужно,
[59:19.320 --> 59:22.320]  потому что компилятор умеет выводить его за вас.
[59:22.320 --> 59:25.320]  Это скорее нужно тогда, когда у вас функция будет принимать
[59:25.320 --> 59:28.320]  несколько аргументов. Тогда компилятор с помощью lifetime и legion
[59:28.320 --> 59:31.320]  не сможет вывести, скажет вам, напиши лайфтаймы,
[59:31.320 --> 59:34.320]  а чтобы написать лайфтайм, вам уже может понадобиться HRBT.
[59:34.320 --> 59:37.320]  Вот.
[59:37.320 --> 59:40.320]  Понятно ли, что такое HRTB,
[59:40.320 --> 59:43.320]  и зачем это нам нужно?
[59:43.320 --> 59:46.320]  А в этих бандах можно писать не только лайфтаймы?
[59:46.320 --> 59:49.320]  Нет, только лайфтаймы.
[59:49.320 --> 59:52.320]  Это прям настолько захардкоженный синтакс,
[59:52.320 --> 59:55.320]  в каком-то смысле, что если ты попробуешь написать тип,
[59:55.320 --> 59:58.320]  то раз ошибку парсинга вообще выдаст.
[59:58.320 --> 01:00:01.320]  То есть он даже не поймет,
[01:00:01.320 --> 01:00:04.320]  что значит фор, открывающий кавычка,
[01:00:04.320 --> 01:00:07.320]  без штышка.
[01:00:16.320 --> 01:00:19.320]  Ну это все равно какой-то очень специальный и редкий синтакс,
[01:00:19.320 --> 01:00:22.320]  поэтому, наверное, это все равно та вещь,
[01:00:22.320 --> 01:00:25.320]  которая пользуется только профи.
[01:00:25.320 --> 01:00:28.320]  Поэтому можно забить, возможно, о них.
[01:00:31.320 --> 01:00:34.320]  Вот. Вопроски есть?
[01:00:37.320 --> 01:00:40.320]  Так, у нас есть еще такая общая ошибка,
[01:00:40.320 --> 01:00:43.320]  которую я с вами тоже хочу обсудить.
[01:00:43.320 --> 01:00:46.320]  С ней сталкивалось в личке...
[01:00:46.320 --> 01:00:49.320]  Я даже специально у людей порой спрашивал,
[01:00:49.320 --> 01:00:52.320]  не считаешь ли ты, когда он мне спрашивает вопрос,
[01:00:52.320 --> 01:00:55.320]  что T это только владеющий тип.
[01:00:55.320 --> 01:00:58.320]  И мне обычно отвечали, да, я так считаю.
[01:00:58.320 --> 01:01:01.320]  Давайте мы это рассмотрим.
[01:01:01.320 --> 01:01:04.320]  Представьте, что у нас есть какой-то трейд,
[01:01:04.320 --> 01:01:07.320]  мы написали в него три импла.
[01:01:07.320 --> 01:01:10.320]  Для T, для ссылки на T, для muteT.
[01:01:10.320 --> 01:01:13.320]  Когда вы пишете T, то в таком случае
[01:01:13.320 --> 01:01:16.320]  вы на самом деле мачите вообще любой тип.
[01:01:16.320 --> 01:01:19.320]  Это может быть любой T, например, это может быть I32,
[01:01:19.320 --> 01:01:22.320]  это может быть ссылка на I32, это тоже какой-то тип T,
[01:01:22.320 --> 01:01:25.320]  отдельный, другой тип, он тоже сюда подходит,
[01:01:25.320 --> 01:01:28.320]  T32 тоже будет ходить сюда.
[01:01:28.320 --> 01:01:31.320]  А вот если вы напишете ссылочку на тип T,
[01:01:31.320 --> 01:01:34.320]  то в таком случае раз будет мачить только ссылочные типы.
[01:01:34.320 --> 01:01:37.320]  То есть ссылка на I32, ссылка на ссылку muteT32
[01:01:37.320 --> 01:01:40.320]  и подобное.
[01:01:40.320 --> 01:01:43.320]  То есть когда вы дженерик по какому-то типу T,
[01:01:43.320 --> 01:01:46.320]  то в таком случае вы, если не налагаете никаких ограничений,
[01:01:46.320 --> 01:01:49.320]  то в таком случае вам подходит вообще любой T.
[01:01:51.320 --> 01:01:54.320]  Ну и поэтому не удивляйтесь, например,
[01:01:54.320 --> 01:01:57.320]  импульс для T и для ссылки на T какой-то фигни,
[01:01:57.320 --> 01:02:00.320]  и она не скомпилируется, потому что она скажет,
[01:02:00.320 --> 01:02:03.320]  что они друг с другом конфликтируют.
[01:02:03.320 --> 01:02:06.320]  Потому что в T входит ссылка на T как под множество.
[01:02:06.320 --> 01:02:09.320]  А можно ли писать более сложные мачи?
[01:02:09.320 --> 01:02:12.320]  В каком смысле?
[01:02:12.320 --> 01:02:15.320]  Ну, после фора писать ссылка на ссылку muteT?
[01:02:18.320 --> 01:02:21.320]  Блин, не знаю. Наверное, можно.
[01:02:21.320 --> 01:02:24.320]  Но я не буду гарантировать, нужно проверить.
[01:02:28.320 --> 01:02:31.320]  Наверное, это примерно никому не нужно.
[01:02:31.320 --> 01:02:34.320]  В принципе, можешь попробовать написать ссылку на ссылку на mute,
[01:02:34.320 --> 01:02:37.320]  и я поставлю вероятность больше 50%, что оно должно сработать.
[01:02:40.320 --> 01:02:43.320]  Это такая вот вещь получается.
[01:02:43.320 --> 01:02:46.320]  Ну, соответственно, в T входит ссылка на T
[01:02:46.320 --> 01:02:49.320]  и ссылка на muteT как два множества.
[01:02:49.320 --> 01:02:52.320]  И они пересекаются, соответственно.
[01:02:52.320 --> 01:02:55.320]  Потому что одно начинает с ссылки, другое начинает с ссылки на mute.
[01:02:55.320 --> 01:02:58.320]  И в том числе в T входит какие-то типы,
[01:02:58.320 --> 01:03:01.320]  которые не входят ни туда ни туда, например, 32,
[01:03:01.320 --> 01:03:04.320]  потому что он не ссылочный.
[01:03:04.320 --> 01:03:07.320]  Ну, соответственно, это как раз то, что я сказал.
[01:03:07.320 --> 01:03:10.320]  Супер множество от ссылки на T на muteT
[01:03:10.320 --> 01:03:13.320]  и то, что этим не пересекающееся множество.
[01:03:20.320 --> 01:03:23.320]  Ну, если ты начинаешь ссылки, то уже точно может быть.
[01:03:23.320 --> 01:03:26.320]  Ссылки на muteT 32 может быть.
[01:03:26.320 --> 01:03:29.320]  А, ссылки на muteT 32?
[01:03:29.320 --> 01:03:32.320]  Нет, такое не может быть, потому что это именно ссылка на T ожидаешь.
[01:03:32.320 --> 01:03:35.320]  Это подойдет только сюда.
[01:03:42.320 --> 01:03:45.320]  Ну, я бы даже сказал, мне больше нравится об этом думать,
[01:03:45.320 --> 01:03:48.320]  как о pattern matching.
[01:03:49.320 --> 01:03:52.320]  Ну, даже не так. Мы добавили ссылку перед T,
[01:03:52.320 --> 01:03:55.320]  и вот теперь все T пробегаем.
[01:03:55.320 --> 01:03:58.320]  И все T, которыми пробегаем, по сути, это вот множество.
[01:03:58.320 --> 01:04:01.320]  Просто что перед ним теперь ссылка стоит.
[01:04:03.320 --> 01:04:06.320]  Запомните, что T это не обязательно владеющий тип.
[01:04:06.320 --> 01:04:09.320]  Это может быть ссылочный тип тоже.
[01:04:10.320 --> 01:04:13.320]  Еще есть такая штука Unbounded lifetime.
[01:04:13.320 --> 01:04:16.320]  Это lifetime, который больше всех.
[01:04:16.320 --> 01:04:19.320]  Этот lifetime валиден на протяжении всей программы.
[01:04:21.320 --> 01:04:24.320]  Он не налагает никаких ограничений на ваш тип.
[01:04:24.320 --> 01:04:27.320]  Если у вас статик ссылка, то в таком случае
[01:04:27.320 --> 01:04:30.320]  ее можно никогда не инвалидировать.
[01:04:30.320 --> 01:04:33.320]  То есть, если до этого у нас была ссылка на A,
[01:04:33.320 --> 01:04:36.320]  то в таком случае это означало, что мы на протяжении региона кода A валидны.
[01:04:36.320 --> 01:04:39.320]  А если у вас статик, то вы валидны на протяжении всей программы
[01:04:39.320 --> 01:04:42.320]  и делаете с этой ссылкой что хотите.
[01:04:42.320 --> 01:04:45.320]  Никаких ограничений нет.
[01:04:46.320 --> 01:04:51.320]  Вот частный случай, что у нас есть статическая какая-то строчка.
[01:04:51.320 --> 01:04:54.320]  И оно все работает.
[01:04:55.320 --> 01:04:58.320]  Еще, нам важно понять, что значит
[01:04:58.320 --> 01:05:04.320]  T''A и ссылка с lifetime'ом A на T.
[01:05:04.320 --> 01:05:07.320]  И чем они отличаются?
[01:05:07.320 --> 01:05:10.320]  Скажите, вам в домашней программе приходилось писать
[01:05:10.320 --> 01:05:14.320]  bound в духе T''A или self'A?
[01:05:15.320 --> 01:05:18.320]  Кажется, в боре надо было.
[01:05:18.320 --> 01:05:21.320]  Да, в боре точно нужно было такое делать.
[01:05:24.320 --> 01:05:27.320]  Что это означает?
[01:05:27.320 --> 01:05:30.320]  Это означает, что self должен жить на протяжении, по крайней мере, A.
[01:05:30.320 --> 01:05:33.320]  Должен быть валиден, по крайней мере, A.
[01:05:33.320 --> 01:05:36.320]  Более даже правильно сказать, академично,
[01:05:36.320 --> 01:05:39.320]  это что все lifetime параметры T переживают A.
[01:05:39.320 --> 01:05:42.320]  Что такое lifetime параметры?
[01:05:42.320 --> 01:05:45.320]  Например, это всякие, если у вас там структура,
[01:05:45.320 --> 01:05:48.320]  которая зависит от T'A, T'B.
[01:05:48.320 --> 01:05:51.320]  Кажется, там дальше как раз должен быть примерчик.
[01:05:51.320 --> 01:05:54.320]  Так что посмотрим сейчас.
[01:05:54.320 --> 01:05:57.320]  Давайте поймем, что это значит.
[01:05:57.320 --> 01:06:00.320]  Вот у меня есть какой-то trait, который требует lifetime'A.
[01:06:00.320 --> 01:06:03.320]  И, соответственно, пишем where self'A.
[01:06:03.320 --> 01:06:06.320]  Все, что делает этот trait, просто налагает ограничения.
[01:06:06.320 --> 01:06:11.320]  И структура CRF, которая содержит какую-то ссылочку.
[01:06:11.320 --> 01:06:14.320]  Смотрите, если я напишу, что мы generic по lifetime'у A,
[01:06:14.320 --> 01:06:17.320]  соответственно, импрометирую этот trait для этой ссылочки,
[01:06:17.320 --> 01:06:20.320]  то все будет правильно.
[01:06:20.320 --> 01:06:23.320]  Мы же валидны на протяжении A, так?
[01:06:23.320 --> 01:06:26.320]  Наша ссылка может проживать A.
[01:06:26.320 --> 01:06:29.320]  Это правда.
[01:06:29.320 --> 01:06:32.320]  А вот если мы потребуем lifetime static,
[01:06:32.320 --> 01:06:35.320]  то наша ссылка способна только на протяжении A жить.
[01:06:35.320 --> 01:06:38.320]  А мы хотим на протяжении всей программы.
[01:06:38.320 --> 01:06:41.320]  Потому что наш тип живет только на протяжении A.
[01:06:41.320 --> 01:06:44.320]  Так, да?
[01:06:44.320 --> 01:06:47.320]  Что-что?
[01:06:59.320 --> 01:07:02.320]  Не меньше, скорее.
[01:07:02.320 --> 01:07:05.320]  Может, я подолбался?
[01:07:05.320 --> 01:07:08.320]  Outlive, ну все правильно.
[01:07:08.320 --> 01:07:11.320]  Переживает.
[01:07:11.320 --> 01:07:14.320]  Может быть, self-static, но тогда все будет хорошо.
[01:07:14.320 --> 01:07:17.320]  Impl'A require lifetime'A for Fstatic.
[01:07:17.320 --> 01:07:20.320]  Это корректно. Потому что вы проживаете любой lifetime.
[01:07:20.320 --> 01:07:23.320]  Переживаете все. Вы проживаете Вселенную.
[01:07:23.320 --> 01:07:26.320]  Переживаете программу.
[01:07:29.320 --> 01:07:32.320]  Так.
[01:07:32.320 --> 01:07:35.320]  А что если с vect'A, например, сделать?
[01:07:35.320 --> 01:07:38.320]  Мы написали require lifetime от vect'A.
[01:07:38.320 --> 01:07:41.320]  То же самое, но только смотрите.
[01:07:41.320 --> 01:07:44.320]  Наш vect'A ссылка A на I32.
[01:07:44.320 --> 01:07:47.320]  Естественно, мы переживаем A наш vect'A.
[01:07:47.320 --> 01:07:50.320]  Но мы не можем пережить static. Почему?
[01:07:50.320 --> 01:07:53.320]  Потому что если наш vect'A будет жить больше, чем A,
[01:07:53.320 --> 01:07:56.320]  то в таком случае у него будут внутри невалидные ссылки потенциально.
[01:07:56.320 --> 01:07:59.320]  Это запрещает система типа Rasta.
[01:07:59.320 --> 01:08:02.320]  Поэтому на самом деле
[01:08:02.320 --> 01:08:05.320]  вот этот vect'A, который мы написали,
[01:08:05.320 --> 01:08:08.320]  у T есть какие-то lifetime параметры, получается.
[01:08:08.320 --> 01:08:11.320]  Которые мы не видим, но мы их тянем вместе с собой.
[01:08:11.320 --> 01:08:14.320]  Более конкретно. Давайте посмотрим.
[01:08:14.320 --> 01:08:17.320]  Вот есть Holder. У Holder'а есть какие-то две ссылочки.
[01:08:17.320 --> 01:08:20.320]  Одна на str, другая на u, с lifetime'A.
[01:08:20.320 --> 01:08:23.320]  Потом сами t и u есть.
[01:08:23.320 --> 01:08:26.320]  И дело в том, что у t и u
[01:08:26.320 --> 01:08:29.320]  тоже могут быть какие-то ограничения.
[01:08:29.320 --> 01:08:32.320]  Например, t может быть ссылкой t на I32.
[01:08:35.320 --> 01:08:38.320]  Ну, ссылка с lifetime'ом t.
[01:08:38.320 --> 01:08:41.320]  Соответственно, наш Holder, который мы создадим,
[01:08:41.320 --> 01:08:44.320]  раз за нас увидит lifetime'ы,
[01:08:44.320 --> 01:08:47.320]  и поймешь, что Holder не может переживать
[01:08:47.320 --> 01:08:50.320]  ни одну из этих ссылок.
[01:08:50.320 --> 01:08:53.320]  Он выберет наименее строгую.
[01:08:53.320 --> 01:08:56.320]  Ну, наиболее строгую, точнее.
[01:08:56.320 --> 01:08:59.320]  Как-то так. Поэтому, когда мы пишем тип,
[01:08:59.320 --> 01:09:02.320]  мы на самом деле тащим с ним lifetime'ы параметры.
[01:09:02.320 --> 01:09:05.320]  Потому что мы не должны переживать этот тип.
[01:09:08.320 --> 01:09:11.320]  Как вы думаете, что значит t статик?
[01:09:24.320 --> 01:09:27.320]  Да, мы хотим, чтобы t жил всю программу.
[01:09:27.320 --> 01:09:30.320]  Можете писать, сказать какие-нибудь примеры?
[01:09:30.320 --> 01:09:33.320]  Так, а еще что-нибудь?
[01:09:36.320 --> 01:09:39.320]  Глобальная переменная тоже подходит,
[01:09:39.320 --> 01:09:42.320]  по сути, статические строчки.
[01:09:42.320 --> 01:09:45.320]  Что-нибудь чуть-чуть менее тривиально.
[01:09:45.320 --> 01:09:48.320]  На самом деле, вы с этим постоянно сталкиваетесь
[01:09:48.320 --> 01:09:51.320]  со всякими t статиками.
[01:09:53.320 --> 01:09:56.320]  Ну, давайте я ответ подскажу.
[01:09:56.320 --> 01:09:59.320]  Например, во-первых, это означает,
[01:09:59.320 --> 01:10:02.320]  что t не имеет никаких ограничений
[01:10:02.320 --> 01:10:05.320]  по lifetime'ам.
[01:10:05.320 --> 01:10:08.320]  То есть, это не значит то, что у него
[01:10:08.320 --> 01:10:11.320]  не должно быть никаких штриха внутри.
[01:10:11.320 --> 01:10:14.320]  Они могут быть, но эти штриха должны быть статик.
[01:10:14.320 --> 01:10:17.320]  То есть, в итоге вывестись как статик.
[01:10:17.320 --> 01:10:20.320]  Иначе мы будем жить меньше, чем статик.
[01:10:20.320 --> 01:10:23.320]  То есть, по нашему определению получается,
[01:10:23.320 --> 01:10:26.320]  что t можно валидно хранить
[01:10:26.320 --> 01:10:29.320]  на протяжении всей программы.
[01:10:29.320 --> 01:10:32.320]  То есть, нет никаких параметров,
[01:10:32.320 --> 01:10:35.320]  оно верно в любом скопе.
[01:10:35.320 --> 01:10:38.320]  Обратите внимание, у нас валидная t статик
[01:10:38.320 --> 01:10:41.320]  это и i32, и vextring, и range, и size.
[01:10:41.320 --> 01:10:44.320]  Это все правильно.
[01:10:44.320 --> 01:10:47.320]  Потому что их можно хранить на протяжении всей программы.
[01:10:47.320 --> 01:10:50.320]  То есть, например, i32, какие проблемы хранить
[01:10:50.320 --> 01:10:53.320]  всю программу, это же не ссылка,
[01:10:53.320 --> 01:10:56.320]  которая ограничена тем, на кого она ссылается.
[01:10:56.320 --> 01:10:59.320]  У нас i32 — это прям владеющий тип, который имеет...
[01:10:59.320 --> 01:11:02.320]  Ну, в общем, владеет данными.
[01:11:02.320 --> 01:11:05.320]  Так что, по сути, t статик — это все владеющие типы.
[01:11:05.320 --> 01:11:08.320]  В том числе всякие статические.
[01:11:08.320 --> 01:11:11.320]  Какие-то такие вот дела.
[01:11:11.320 --> 01:11:14.320]  Но при этом, несмотря на то, что t статик,
[01:11:14.320 --> 01:11:17.320]  вы не обязаны это дропать
[01:11:17.320 --> 01:11:20.320]  именно в конце программы.
[01:11:20.320 --> 01:11:23.320]  Это означает просто, что нет никаких ограничений этого типа.
[01:11:23.320 --> 01:11:26.320]  Вот.
[01:11:26.320 --> 01:11:29.320]  Их можно и создавать, и удалять специально спокойно.
[01:11:29.320 --> 01:11:32.320]  Ну и более конкретно.
[01:11:32.320 --> 01:11:35.320]  Ta — это множество типов,
[01:11:35.320 --> 01:11:38.320]  которые ограничены lifetime a.
[01:11:38.320 --> 01:11:41.320]  Ну то есть, как минимум, переживают a.
[01:11:41.320 --> 01:11:44.320]  Такое вот.
[01:11:44.320 --> 01:11:47.320]  Ну и множество всех ta включает,
[01:11:47.320 --> 01:11:50.320]  в том числе, ссылки с lifetime a.
[01:11:50.320 --> 01:11:53.320]  Ну почему?
[01:11:53.320 --> 01:11:56.320]  Потому что ссылка с lifetime a живет,
[01:11:56.320 --> 01:11:59.320]  естественно, по крайней мере a.
[01:11:59.320 --> 01:12:02.320]  Все логично звучит.
[01:12:02.320 --> 01:12:05.320]  Ну и в том числе, например, в ta входит
[01:12:05.320 --> 01:12:08.320]  статик ссылок.
[01:12:08.320 --> 01:12:11.320]  Это тоже входит множество,
[01:12:11.320 --> 01:12:14.320]  потому что она живет, по крайней мере, a.
[01:12:14.320 --> 01:12:17.320]  Вот. Мы дошли до самой сложной части, Алексей.
[01:12:17.320 --> 01:12:20.320]  Так.
[01:12:20.320 --> 01:12:23.320]  Давайте перейдем к сабтайпингу.
[01:12:23.320 --> 01:12:26.320]  Вы, когда смотрите на такое слово,
[01:12:26.320 --> 01:12:29.320]  у вас есть представление, что это значит?
[01:12:29.320 --> 01:12:32.320]  Хорошо, плюсовое значение.
[01:12:32.320 --> 01:12:35.320]  Наследование.
[01:12:35.320 --> 01:12:38.320]  Так.
[01:12:38.320 --> 01:12:41.320]  Наследование.
[01:12:41.320 --> 01:12:44.320]  И немножечко про мир виртуальных функций
[01:12:44.320 --> 01:12:47.320]  и как варианты подрешаемых типов.
[01:12:47.320 --> 01:12:50.320]  Да. Особенно слово «кавариантно»
[01:12:50.320 --> 01:12:53.320]  сейчас мы будем смотреть на это.
[01:12:53.320 --> 01:12:56.320]  Так. Вообще у нас в расе, как вы уже знаете,
[01:12:56.320 --> 01:12:59.320]  нет наследования данных.
[01:12:59.320 --> 01:13:02.320]  У нас есть наследование интерфейсов,
[01:13:02.320 --> 01:13:05.320]  наследование поведения.
[01:13:05.320 --> 01:13:08.320]  Вот. Даже несмотря на то, что его нет,
[01:13:08.320 --> 01:13:11.320]  у нас есть понятие сабтайпинга.
[01:13:11.320 --> 01:13:14.320]  Вот сейчас нам нужно запомнить очень практичное
[01:13:14.320 --> 01:13:17.320]  и хорошее определение сабтайпинга.
[01:13:17.320 --> 01:13:20.320]  Если мы его не запомним, то нам придется погрузиться
[01:13:20.320 --> 01:13:23.320]  в теорию категорий. Я вам не советую.
[01:13:23.320 --> 01:13:26.320]  Давайте мы запомним простое житейское определение,
[01:13:26.320 --> 01:13:29.320]  чтобы в 100% случаях сработать на этой лекции
[01:13:29.320 --> 01:13:32.320]  и в жизни потом же.
[01:13:32.320 --> 01:13:35.320]  Сабтайпинг – это концепт, который означает,
[01:13:35.320 --> 01:13:38.320]  что один объект как минимум настолько же полезен,
[01:13:38.320 --> 01:13:41.320]  как и другой. At least as user.
[01:13:41.320 --> 01:13:44.320]  То есть если у вас A под тип B,
[01:13:44.320 --> 01:13:47.320]  то в таком случае A как минимум настолько же полезен,
[01:13:47.320 --> 01:13:50.320]  насколько и B. Логично, да?
[01:13:50.320 --> 01:13:53.320]  У нас есть животное, там есть кот, есть собака.
[01:13:53.320 --> 01:13:56.320]  Здесь N потерялся.
[01:13:56.320 --> 01:13:59.320]  Cat and dog – это подтипы animal.
[01:13:59.320 --> 01:14:02.320]  Animal – это их супертип.
[01:14:02.320 --> 01:14:05.320]  Понимаете, мы как бы наследуемся от animal,
[01:14:05.320 --> 01:14:08.320]  у нас есть больше каких-то методов,
[01:14:08.320 --> 01:14:11.320]  но мы по крайней мере настолько же полезны,
[01:14:11.320 --> 01:14:14.320]  насколько полезен trait animal.
[01:14:14.320 --> 01:14:17.320]  Мы умеем как минимум столько же. Мы умеем snuggle
[01:14:17.320 --> 01:14:20.320]  и возможно умеем что-то еще.
[01:14:20.320 --> 01:14:23.320]  Подобный код сработает потому,
[01:14:23.320 --> 01:14:26.320]  что в расте сабтайпинг есть.
[01:14:26.320 --> 01:14:29.320]  У нас есть динамический указатель на какой-то animal,
[01:14:29.320 --> 01:14:32.320]  класс мы.
[01:14:32.320 --> 01:14:35.320]  Динамический толстый указатель
[01:14:35.320 --> 01:14:38.320]  на тип, который является animal,
[01:14:38.320 --> 01:14:41.320]  то есть имплементирует animal.
[01:14:41.320 --> 01:14:44.320]  У нас есть какой-то код, мы для него имплементировали
[01:14:44.320 --> 01:14:47.320]  нужные трейты и после этого попробовали
[01:14:47.320 --> 01:14:50.320]  вызваться от кота и это даже скомпилировать,
[01:14:50.320 --> 01:14:53.320]  потому что кота можно использовать как животное.
[01:14:53.320 --> 01:14:56.320]  Он же является животным,
[01:14:56.320 --> 01:14:59.320]  поэтому все приведет раст и все получится.
[01:14:59.320 --> 01:15:02.320]  Более того, у нас до этого
[01:15:02.320 --> 01:15:05.320]  это было на плюсы похоже,
[01:15:05.320 --> 01:15:08.320]  а теперь мы уже будем спускаться в то,
[01:15:08.320 --> 01:15:11.320]  как это на самом деле работает в расте.
[01:15:11.320 --> 01:15:14.320]  В расте у нас на самом деле lifetime тоже поддерживает сабтайпинг.
[01:15:14.320 --> 01:15:17.320]  И более того, у нас сабтайпинг в расте
[01:15:17.320 --> 01:15:20.320]  существует практически только для lifetime.
[01:15:20.320 --> 01:15:23.320]  То есть то, что вы до этого видели,
[01:15:23.320 --> 01:15:26.320]  это скорее исключение из правил.
[01:15:26.320 --> 01:15:29.320]  На самом деле сабтайпинг, когда видите в расте,
[01:15:29.320 --> 01:15:32.320]  это почти 100% речь про lifetime.
[01:15:32.320 --> 01:15:35.320]  Давайте посмотрим такой примерчик.
[01:15:35.320 --> 01:15:38.320]  У нас есть функция, которая принимает две строчки
[01:15:38.320 --> 01:15:41.320]  и возвращает из них кратчешу.
[01:15:41.320 --> 01:15:44.320]  У нас есть а, которая является статической строчкой,
[01:15:44.320 --> 01:15:47.320]  и b, которая является какой-то динамической строчкой,
[01:15:47.320 --> 01:15:50.320]  в которой мы создаем рамтайп.
[01:15:50.320 --> 01:15:53.320]  Вызываем short статутом.
[01:15:53.320 --> 01:15:56.320]  Во-первых, почему это компилируется?
[01:15:56.320 --> 01:15:59.320]  Как вы думаете?
[01:15:59.320 --> 01:16:02.320]  Погромче скажи, пожалуйста.
[01:16:02.320 --> 01:16:05.320]  Ну да, правильные lifetime,
[01:16:05.320 --> 01:16:08.320]  но вообще хотелось бы сказать,
[01:16:08.320 --> 01:16:11.320]  здесь ссылка на static стринг,
[01:16:11.320 --> 01:16:14.320]  здесь какая-то ссылка на какой-то a стринг.
[01:16:14.320 --> 01:16:17.320]  Здесь мы засовываем, получается,
[01:16:17.320 --> 01:16:20.320]  статик и засовываем a стринг.
[01:16:20.320 --> 01:16:23.320]  И казалось бы, почему это работает?
[01:16:23.320 --> 01:16:26.320]  Потому что статик приводится к a.
[01:16:26.320 --> 01:16:29.320]  Логично, статик переживает a,
[01:16:29.320 --> 01:16:32.320]  соответственно, какая проблема?
[01:16:32.320 --> 01:16:35.320]  Мы скажем, что a живет, вообще не беда.
[01:16:36.320 --> 01:16:39.320]  Да, и это очень важное замечание.
[01:16:39.320 --> 01:16:42.320]  Статик – это под тип a.
[01:16:42.320 --> 01:16:45.320]  И обратите внимание, статик больше lifetime,
[01:16:45.320 --> 01:16:48.320]  но он под тип, он визуально выглядит так,
[01:16:48.320 --> 01:16:51.320]  что статик содержит в себе всех,
[01:16:51.320 --> 01:16:54.320]  и все для него под типы.
[01:16:54.320 --> 01:16:57.320]  Но на самом деле прямо наоборот,
[01:16:57.320 --> 01:17:00.320]  статик под тип всех lifetime.
[01:17:00.320 --> 01:17:03.320]  Это самый частный случай.
[01:17:03.320 --> 01:17:06.320]  Давайте мы теперь посмотрим
[01:17:06.320 --> 01:17:09.320]  такой примерчик.
[01:17:09.320 --> 01:17:12.320]  Мы можем потребовать lifetime,
[01:17:12.320 --> 01:17:15.320]  чтобы он не строго переживал другой lifetime.
[01:17:15.320 --> 01:17:18.320]  Давайте сначала посмотрим на сигнатуру foo
[01:17:18.320 --> 01:17:21.320]  и поймем, что значит штрих b
[01:17:21.320 --> 01:17:24.320]  до иточия штриха.
[01:17:24.320 --> 01:17:27.320]  B – это какой-то lifetime не меньше.
[01:17:27.320 --> 01:17:30.320]  Да, а в теории, в плане саптайпинга,
[01:17:30.320 --> 01:17:33.320]  то есть b как минимум настолько же полезно,
[01:17:33.320 --> 01:17:36.320]  насколько и a.
[01:17:36.320 --> 01:17:39.320]  Это определение очень эффективно и хорошее.
[01:17:39.320 --> 01:17:42.320]  У нас есть два lifetime,
[01:17:42.320 --> 01:17:45.320]  и мы говорим, что b должен быть настолько же,
[01:17:45.320 --> 01:17:48.320]  как и a, полезно, возможно, больше.
[01:17:48.320 --> 01:17:51.320]  В данном случае это бесполезно,
[01:17:51.320 --> 01:17:54.320]  но просто такой немножко искусственный пример
[01:17:54.320 --> 01:17:57.320]  для того, чтобы показать вам,
[01:17:57.320 --> 01:18:00.320]  как они друг с другом соотносятся в расте.
[01:18:00.320 --> 01:18:03.320]  Ну и вот примерчик.
[01:18:03.320 --> 01:18:06.320]  У нас тут создается строчка,
[01:18:06.320 --> 01:18:09.320]  вторая строчка. У обеих разные lifetime,
[01:18:09.320 --> 01:18:12.320]  мы их засовываем в foo.
[01:18:12.320 --> 01:18:15.320]  Вот b в данном случае уже будет статик lifetime.
[01:18:15.320 --> 01:18:18.320]  Не как в первом случае.
[01:18:18.320 --> 01:18:21.320]  То есть напрямую подставится,
[01:18:21.320 --> 01:18:24.320]  не будет ничего приводиться.
[01:18:24.320 --> 01:18:27.320]  Ну смотри, у нас one – это best,
[01:18:27.320 --> 01:18:30.320]  а 2 – это aster.
[01:18:30.320 --> 01:18:33.320]  Смотри, вот этот 1 имеет lifetime a.
[01:18:33.320 --> 01:18:36.320]  Ну пусть b – это будет lifetime a.
[01:18:36.320 --> 01:18:39.320]  И вот смотри, вот он больше,
[01:18:39.320 --> 01:18:42.320]  вот мы его засовываем сюда и вот сюда.
[01:18:42.320 --> 01:18:45.320]  Соответственно, получается, b под тип a больше.
[01:18:45.320 --> 01:18:48.320]  Все правильно. Соответственно, будет два разных lifetime строк,
[01:18:48.320 --> 01:18:51.320]  когда ты будешь подставлять.
[01:18:51.320 --> 01:18:54.320]  Это бы тоже работало,
[01:18:54.320 --> 01:18:57.320]  просто тогда был lifetime, который вот этот более широкий,
[01:18:57.320 --> 01:19:00.320]  он привел бы его в более момент.
[01:19:00.320 --> 01:19:03.320]  Ну компилятор,
[01:19:03.320 --> 01:19:06.320]  как я говорил, берет, смотрит сигнатуру функций,
[01:19:06.320 --> 01:19:09.320]  все ли подходит. Он такой смотрит.
[01:19:09.320 --> 01:19:12.320]  Ага, вот здесь у меня статик,
[01:19:12.320 --> 01:19:15.320]  здесь вот штрих a.
[01:19:15.320 --> 01:19:18.320]  И такой смотрит, подходит ли это под ограничение.
[01:19:18.320 --> 01:19:21.320]  Ну вроде подходит, статик у меня по тип a, все хорошо.
[01:19:21.320 --> 01:19:24.320]  Плюс смотрит на сигнатуру функций, действительно я возвращаю
[01:19:24.320 --> 01:19:27.320]  штрих aster. Действительно, штрих aster возвращаю,
[01:19:27.320 --> 01:19:30.320]  потому что у нас one как минимум уже столько же, сколько я.
[01:19:30.320 --> 01:19:33.320]  Я, кстати, попрошу заметить, когда вы начнете этим пользоваться,
[01:19:33.320 --> 01:19:36.320]  то вот эта вот возвращаемая строчка
[01:19:36.320 --> 01:19:39.320]  будет жить только на протяжении вот этого вот скопа.
[01:19:39.320 --> 01:19:42.320]  Потому что мы возвращаем штрих a,
[01:19:42.320 --> 01:19:45.320]  и соответственно у нас lifetime будет такой же,
[01:19:45.320 --> 01:19:48.320]  внимание.
[01:19:48.320 --> 01:19:51.320]  Что-то такое вот.
[01:19:51.320 --> 01:19:54.320]  Да, это было все,
[01:19:54.320 --> 01:19:57.320]  что нужно было сказать про subtapping на самом деле.
[01:19:57.320 --> 01:20:00.320]  Сейчас будет самое интересное, bearings. Потому что на самом деле,
[01:20:00.320 --> 01:20:03.320]  когда мы говорим, что один lifetime под тип другого,
[01:20:03.320 --> 01:20:06.320]  мы сейчас вычислим, как они на самом деле работают
[01:20:06.320 --> 01:20:09.320]  относится друг к другу.
[01:20:09.320 --> 01:20:12.320]  Вот, давайте попробуем поотвечать на некоторые вопросы, чтобы
[01:20:12.320 --> 01:20:15.320]  приобрести понимание.
[01:20:15.320 --> 01:20:18.320]  Такой вопрос. Статический lifetime под тип?
[01:20:18.320 --> 01:20:21.320]  lifetime a?
[01:20:21.320 --> 01:20:24.320]  Ну, ссылка на статический t.
[01:20:24.320 --> 01:20:27.320]  Да, это так.
[01:20:27.320 --> 01:20:30.320]  Это действительно под тип.
[01:20:33.320 --> 01:20:36.320]  Да, ну как минимум настолько же полезно.
[01:20:36.320 --> 01:20:39.320]  Неформально определение советуем пользоваться, очень хорошая штука.
[01:20:39.320 --> 01:20:42.320]  Увидел когда-то на стримах Rast of Rast, и стало очень понятно.
[01:20:42.320 --> 01:20:45.320]  Ну, там есть такой очень шаристый человек,
[01:20:45.320 --> 01:20:48.320]  который в том числе написал книжку, одну.
[01:20:48.320 --> 01:20:51.320]  Rast of Rastassians, очень советую.
[01:20:51.320 --> 01:20:54.320]  Теперь, ссылка a, t.
[01:20:54.320 --> 01:20:57.320]  Это под тип на ссылку a, u,
[01:20:57.320 --> 01:21:00.320]  где t это под тип u.
[01:21:03.320 --> 01:21:06.320]  Ну, мы же можем, ну да, это под тип действительно.
[01:21:06.320 --> 01:21:09.320]  Мы можем же t привести к u, это же под тип.
[01:21:09.320 --> 01:21:12.320]  Так, логично.
[01:21:12.320 --> 01:21:15.320]  Окей, теперь у нас статик mute t.
[01:21:15.320 --> 01:21:18.320]  Это под тип, ссылки a, mute t.
[01:21:22.320 --> 01:21:25.320]  Тоже да, да, действительно, как минимум настолько же полезно.
[01:21:27.320 --> 01:21:30.320]  А вот это, ссылка a, mute t.
[01:21:30.320 --> 01:21:33.320]  Это под тип на a, mute u, где t это под тип u.
[01:21:36.320 --> 01:21:39.320]  Ты проиграл.
[01:21:39.320 --> 01:21:42.320]  Я вас всех обману, это не под тип.
[01:21:42.320 --> 01:21:45.320]  И мы сейчас поймем почему.
[01:21:45.320 --> 01:21:48.320]  Потому что это формальная математика.
[01:21:48.320 --> 01:21:51.320]  Смотри, на самом деле программу мы можем сломать,
[01:21:51.320 --> 01:21:54.320]  если мы такое разрешим.
[01:21:54.320 --> 01:21:57.320]  И сейчас мы это увидим. Как?
[01:21:57.320 --> 01:22:00.320]  Это может выглядеть не интуитивно,
[01:22:00.320 --> 01:22:03.320]  но давайте такой, ну, для начала простой пример,
[01:22:03.320 --> 01:22:06.320]  потом у нас будет в коде еще.
[01:22:06.320 --> 01:22:09.320]  Предположим, что мы берем в какой-то функции ссылку
[01:22:09.320 --> 01:22:12.320]  на mute vec astring.
[01:22:12.320 --> 01:22:15.320]  Эта вот функция принимает на вход такую вот.
[01:22:15.320 --> 01:22:18.320]  И мы засовываем туда mute static string.
[01:22:18.320 --> 01:22:21.320]  В качестве аргумента.
[01:22:21.320 --> 01:22:24.320]  Функция эта внутри будет думать, что
[01:22:24.320 --> 01:22:27.320]  статик, оно же как минимум настолько же полезно.
[01:22:27.320 --> 01:22:30.320]  Если бы мы разрешили это быть под типом,
[01:22:30.320 --> 01:22:33.320]  то в таком случае мы бы могли
[01:22:33.320 --> 01:22:36.320]  засунуть внутрь ссылку astring,
[01:22:36.320 --> 01:22:39.320]  а не ссылку на static string.
[01:22:39.320 --> 01:22:42.320]  Смотрите.
[01:22:42.320 --> 01:22:45.320]  Наверное, живой более лучший пример.
[01:22:45.320 --> 01:22:48.320]  Тут прикол в том,
[01:22:48.320 --> 01:22:51.320]  что если мы такое разрешим,
[01:22:51.320 --> 01:22:54.320]  то в таком случае мы сломаем нам программу.
[01:22:54.320 --> 01:22:57.320]  Смотрите, вот этот как раз пример
[01:22:57.320 --> 01:23:00.320]  инвариантности.
[01:23:00.320 --> 01:23:03.320]  Вот так называемая инвариантность, мы сейчас разберем, что такое.
[01:23:03.320 --> 01:23:06.320]  Когда вы будете просматривать лекцию,
[01:23:06.320 --> 01:23:09.320]  еще раз, возможно, или слайды, то вы тут видите
[01:23:09.320 --> 01:23:12.320]  инвариантности, и вы воскликнете, что я это понимаю теперь.
[01:23:12.320 --> 01:23:15.320]  А не то, что в тот момент на лекции.
[01:23:15.320 --> 01:23:18.320]  У нас есть вектор, который действительно
[01:23:18.320 --> 01:23:21.320]  принимает какой-то вектор, ссылки на astr,
[01:23:21.320 --> 01:23:24.320]  es, astr. И засовываем туда
[01:23:24.320 --> 01:23:27.320]  вектор push.
[01:23:27.320 --> 01:23:30.320]  Вот такой вот сработает первый вариант.
[01:23:30.320 --> 01:23:33.320]  У нас есть ссылочка,
[01:23:33.320 --> 01:23:36.320]  какая-то строчка, которая живет в какой-то lifetime.
[01:23:36.320 --> 01:23:39.320]  Мы создаем вектор,
[01:23:39.320 --> 01:23:42.320]  и потом пытаемся засунуть все это.
[01:23:42.320 --> 01:23:45.320]  И это дело сработает.
[01:23:45.320 --> 01:23:48.320]  Если вы думаете, что как бы непонятно,
[01:23:48.320 --> 01:23:51.320]  как раз на это все посмотрят.
[01:23:51.320 --> 01:23:54.320]  В данном случае a, который мы пытаемся засунуть,
[01:23:54.320 --> 01:23:57.320]  оно вот здесь вот находится.
[01:23:57.320 --> 01:24:00.320]  Потом, раз посмотреть на то,
[01:24:00.320 --> 01:24:03.320]  какой вектор имеет lifetime.
[01:24:03.320 --> 01:24:06.320]  Тут я, наверное, зря, конечно, не написал прям какой-нибудь
[01:24:06.320 --> 01:24:09.320]  конкретный тип, хотя бы комментарий.
[01:24:09.320 --> 01:24:12.320]  Что же тут произойдет?
[01:24:12.320 --> 01:24:15.320]  Он просто посмотрит, что astr и astr совпадают,
[01:24:15.320 --> 01:24:18.320]  и, соответственно, он выведет, что у этого вектора lifetime
[01:24:18.320 --> 01:24:21.320]  век ссылка на astr,
[01:24:21.320 --> 01:24:24.320]  а это вот lifetime ссылочки.
[01:24:24.320 --> 01:24:27.320]  Как-то так это будет работать.
[01:24:27.320 --> 01:24:30.320]  А во втором случае это уже не скомпилируется.
[01:24:30.320 --> 01:24:33.320]  Смотрите, я создаю вектор со статической строчкой.
[01:24:33.320 --> 01:24:36.320]  Этот вектор будет иметь тип век ссылки
[01:24:36.320 --> 01:24:39.320]  на static str.
[01:24:39.320 --> 01:24:42.320]  Потом я создаю какую-то строчку s,
[01:24:42.320 --> 01:24:45.320]  тоже с каким-то ограниченным lifetime,
[01:24:45.320 --> 01:24:48.320]  если бы мы могли использовать под тип,
[01:24:48.320 --> 01:24:51.320]  смотрите, вот у меня a выводится,
[01:24:51.320 --> 01:24:54.320]  он как бы раз смотрит на a,
[01:24:54.320 --> 01:24:57.320]  ажка моя, и скопа вон там.
[01:24:57.320 --> 01:25:00.320]  Если бы мы разрешили использовать под тип,
[01:25:00.320 --> 01:25:03.320]  то в таком случае в качестве a мы бы просто static lifetime
[01:25:03.320 --> 01:25:06.320]  сузили до a, ну какая разница, static же переживает,
[01:25:06.320 --> 01:25:09.320]  и могли бы запушить сюда.
[01:25:09.320 --> 01:25:12.320]  И это бы действительно скомпилировалось,
[01:25:12.320 --> 01:25:15.320]  и соответственно, когда мы бы сюда вот вышли,
[01:25:15.320 --> 01:25:18.320]  в таком случае у нас код просто бы сломался,
[01:25:18.320 --> 01:25:21.320]  потому что у нас здесь у строка,
[01:25:21.320 --> 01:25:24.320]  которая уже очистилась находится.
[01:25:33.320 --> 01:25:36.320]  Да, это ровно то же самое здесь написано,
[01:25:36.320 --> 01:25:39.320]  просто это пример.
[01:25:39.320 --> 01:25:42.320]  Вот, соответственно, получается, что когда
[01:25:42.320 --> 01:25:45.320]  речь про ссылку на mute,
[01:25:45.320 --> 01:25:48.320]  t, то t, ну, в общем, нельзя приводить
[01:25:48.320 --> 01:25:51.320]  к под типу, ну, к под типу нельзя, в более общем,
[01:25:51.320 --> 01:25:54.320]  потому что иначе вот как в таком примере
[01:25:54.320 --> 01:25:57.320]  это бы могло сломаться, и у нас бы внутри
[01:25:57.320 --> 01:26:00.320]  была неволидная ссылочка.
[01:26:00.320 --> 01:26:03.320]  На самом деле у этого феномена всего есть название,
[01:26:03.320 --> 01:26:06.320]  называется variance,
[01:26:06.320 --> 01:26:09.320]  и у каждого типа есть какой-то свой variance.
[01:26:09.320 --> 01:26:12.320]  Ну, то есть это какая-то характеристика
[01:26:12.320 --> 01:26:15.320]  типа.
[01:26:15.320 --> 01:26:18.320]  Она определяет то, как похожие типы, скажем так,
[01:26:18.320 --> 01:26:21.320]  друг к другу взаимодействуют, то есть под типы там
[01:26:21.320 --> 01:26:24.320]  и супертипы относительно друг к другу.
[01:26:24.320 --> 01:26:27.320]  Есть три разных типа вариантности.
[01:26:27.320 --> 01:26:30.320]  Вариантность, инвариантность и контравариантность.
[01:26:30.320 --> 01:26:33.320]  Теперь вот следим за слайдами, очень важно.
[01:26:33.320 --> 01:26:36.320]  Нужно понять.
[01:26:36.320 --> 01:26:39.320]  Вот.
[01:26:39.320 --> 01:26:42.320]  У нас тип кавариантный тогда, когда мы можем использовать
[01:26:42.320 --> 01:26:45.320]  под тип на его месте. Это самый общий тип вариантности.
[01:26:45.320 --> 01:26:48.320]  Смотрите, у нас есть, например, ссылочка.
[01:26:48.320 --> 01:26:51.320]  Обычная ссылочка a, t.
[01:26:51.320 --> 01:26:54.320]  Мы получаемся кавариантный по a, потому что мы можем
[01:26:54.320 --> 01:26:57.320]  использовать в качестве a под тип какой-то.
[01:26:57.320 --> 01:27:00.320]  Можем использовать статик.
[01:27:00.320 --> 01:27:03.320]  А t мы можем использовать какой-то под тип.
[01:27:03.320 --> 01:27:06.320]  Если что, то, что я дальше вам
[01:27:06.320 --> 01:27:09.320]  показываю, ссылка a, t.
[01:27:09.320 --> 01:27:12.320]  Эти все вещи, кавариантность, инвариантность
[01:27:12.320 --> 01:27:15.320]  и контравариантность, они на самом деле были выведены умными
[01:27:15.320 --> 01:27:18.320]  дядьками, которые посмотрели, в каких случаях
[01:27:18.320 --> 01:27:21.320]  дать максимум и при этом не сломать.
[01:27:21.320 --> 01:27:24.320]  Поэтому то, что там, например, вот это кавариантное,
[01:27:24.320 --> 01:27:27.320]  это как бы выведено просто
[01:27:27.320 --> 01:27:30.320]  на риске бумаги, грубо говоря.
[01:27:30.320 --> 01:27:33.320]  Что оно так должно быть, что оно никогда не ломает
[01:27:33.320 --> 01:27:36.320]  и вот как-то так.
[01:27:36.320 --> 01:27:39.320]  Ну и пример кавариантности, например.
[01:27:39.320 --> 01:27:42.320]  В качестве кота я могу
[01:27:42.320 --> 01:27:45.320]  засунуть и домашнего кота, который по типу обычных котов,
[01:27:45.320 --> 01:27:48.320]  и просто кота, несмотря на то, что я принимаю кота,
[01:27:48.320 --> 01:27:51.320]  потому что домашнего кота я могу привести к обычному коту,
[01:27:51.320 --> 01:27:54.320]  использовать его по типу.
[01:27:54.320 --> 01:27:57.320]  Это то, чтобы разрешить использовать
[01:27:57.320 --> 01:28:00.320]  на месте супертипа его подтип.
[01:28:00.320 --> 01:28:03.320]  То есть использовать
[01:28:03.320 --> 01:28:06.320]  более общий тип на месте менее общий.
[01:28:06.320 --> 01:28:09.320]  Ну точнее наоборот, менее общий тип на месте менее общий.
[01:28:09.320 --> 01:28:12.320]  То есть, соответственно, animal у нас не сработает,
[01:28:12.320 --> 01:28:15.320]  потому что animal не cat.
[01:28:18.320 --> 01:28:21.320]  Typ invariantian, если он обязан
[01:28:21.320 --> 01:28:24.320]  точный тип предоставить.
[01:28:24.320 --> 01:28:27.320]  Без саптайфинга все типы
[01:28:27.320 --> 01:28:30.320]  должны были быть invariantian.
[01:28:30.320 --> 01:28:33.320]  И в первых версиях
[01:28:33.320 --> 01:28:36.320]  все типы были invariantian.
[01:28:36.320 --> 01:28:39.320]  Представить было, естественно, очень тяжело кота,
[01:28:39.320 --> 01:28:42.320]  потому что lifetime не приводились.
[01:28:45.320 --> 01:28:48.320]  Ну, в общем, один из главных примеров
[01:28:48.320 --> 01:28:51.320]  в вариантности — это как раз ссылка mute на t.
[01:28:51.320 --> 01:28:54.320]  Мы получаемся к вариантной посылке,
[01:28:54.320 --> 01:28:57.320]  но мы действительно можем засунуть какую-то ссылку,
[01:28:57.320 --> 01:29:00.320]  которая живет больше.
[01:29:00.320 --> 01:29:03.320]  Но как мы выяснили, есть пример,
[01:29:03.320 --> 01:29:06.320]  если мы разрешаем к вариантность по t,
[01:29:06.320 --> 01:29:09.320]  в таком случае у нас получается засунуть, например,
[01:29:09.320 --> 01:29:12.320]  менее долгоживущую строчку.
[01:29:12.320 --> 01:29:15.320]  Поэтому было решено сделать invariant t.
[01:29:15.320 --> 01:29:18.320]  Поэтому мы должны засунуть точно тип,
[01:29:18.320 --> 01:29:21.320]  который нужен, то есть именно astro,
[01:29:21.320 --> 01:29:24.320]  не меньше, не больше, именно его.
[01:29:24.320 --> 01:29:27.320]  Если бы мы засунули больше, еще бы было нормально,
[01:29:27.320 --> 01:29:30.320]  но меньше уже тем более плохо.
[01:29:30.320 --> 01:29:33.320]  Так как есть случаи, в которых мы ломаемся,
[01:29:33.320 --> 01:29:36.320]  нам приходится от системы типов расто приходить к консессу
[01:29:36.320 --> 01:29:39.320]  того, что мы иногда можем сломаться,
[01:29:39.320 --> 01:29:42.320]  если сделаем не invariantian, и все.
[01:29:42.320 --> 01:29:45.320]  В том есть контравариантность.
[01:29:45.320 --> 01:29:48.320]  Самая редкая штука в табличке.
[01:29:48.320 --> 01:29:51.320]  Контравариантность – это наоборот.
[01:29:51.320 --> 01:29:54.320]  Если ковариантность была про то, чтобы использовать
[01:29:54.320 --> 01:29:57.320]  по типу на месте типа, то контравариантность наоборот,
[01:29:57.320 --> 01:30:00.320]  а то чтобы использовать супертипы на месте типа.
[01:30:00.320 --> 01:30:03.320]  То есть это в обратную сторону двигается.
[01:30:03.320 --> 01:30:06.320]  У вас есть последовательность типов, т.е. текущий тип.
[01:30:06.320 --> 01:30:09.320]  Если вот эта ковариантность,
[01:30:09.320 --> 01:30:12.320]  вот эта вот контравариантность.
[01:30:12.320 --> 01:30:15.320]  А invariantness – это точно тип, который нужен.
[01:30:15.320 --> 01:30:18.320]  То есть, грубо говоря, два луча, смотрящие в разные стороны.
[01:30:21.320 --> 01:30:24.320]  Ну и смотрите, единственный
[01:30:24.320 --> 01:30:27.320]  источник контравариантности в языке –
[01:30:27.320 --> 01:30:30.320]  это аргументы входные функций.
[01:30:30.320 --> 01:30:33.320]  У нас есть функция at,
[01:30:33.320 --> 01:30:36.320]  возвращающая u,
[01:30:36.320 --> 01:30:39.320]  и мы ковариантны по t в данном случае.
[01:30:39.320 --> 01:30:42.320]  Контравариантны по t, да.
[01:30:42.320 --> 01:30:45.320]  Вот можно увидеть такой вот пример.
[01:30:45.320 --> 01:30:48.320]  Вот сейчас, если честно, я и сам себе ломал мозг,
[01:30:48.320 --> 01:30:51.320]  когда я пытался понять контравариантность.
[01:30:51.320 --> 01:30:54.320]  И сейчас я тоже, наверное, чувствую, что я так сходу не скажу, наверное.
[01:30:54.320 --> 01:30:57.320]  Ну, смотри, давай так.
[01:30:57.320 --> 01:31:04.320]  Если у нас есть функция, которая возвращает цвет кожного покрова животного,
[01:31:04.320 --> 01:31:07.320]  тогда, поскольку код является животным,
[01:31:07.320 --> 01:31:10.320]  то функция, которая работает с животными,
[01:31:10.320 --> 01:31:13.320]  является функцией, которая работает с котами.
[01:31:13.320 --> 01:31:16.320]  Да, поэтому получается подтип.
[01:31:16.320 --> 01:31:19.320]  Ну и соответственно, у меня есть один из примеров.
[01:31:19.320 --> 01:31:22.320]  Вот этот более конкретный пример.
[01:31:22.320 --> 01:31:25.320]  У нас есть контравариантность, которая принимает строго статик строки,
[01:31:25.320 --> 01:31:28.320]  но мы можем засунуть именно ту функцию,
[01:31:28.320 --> 01:31:31.320]  которую у нас просят,
[01:31:31.320 --> 01:31:34.320]  которая принимает какие-то лайфтаймы меньше, не статические.
[01:31:34.320 --> 01:31:37.320]  И при этом это тоже будет корректно,
[01:31:37.320 --> 01:31:40.320]  потому что если мы работаем с любым лайфтаймом из этих,
[01:31:40.320 --> 01:31:43.320]  то мы и статическим работаем.
[01:31:43.320 --> 01:31:46.320]  Логично, да?
[01:31:46.320 --> 01:31:49.320]  Да, соответственно, получается, что несмотря на то,
[01:31:49.320 --> 01:31:54.320]  что у нас там статик стр, это подтип стр,
[01:31:54.320 --> 01:31:57.320]  у нас функция от астр, это подтип статик,
[01:31:57.320 --> 01:32:00.320]  функция от астр.
[01:32:00.320 --> 01:32:03.320]  Вот в этом есть.
[01:32:03.320 --> 01:32:06.320]  Должна быть обернута функция, если что.
[01:32:11.320 --> 01:32:14.320]  Вот это единственный источник контравариантности в языке.
[01:32:14.320 --> 01:32:17.320]  Больше нигде его нет.
[01:32:17.320 --> 01:32:20.320]  Естественно, если вы напишете fnt в t,
[01:32:20.320 --> 01:32:23.320]  то в таком случае вы получите инвариантность.
[01:32:23.320 --> 01:32:26.320]  Потому что в одном случае контравариантный,
[01:32:26.320 --> 01:32:29.320]  в другом инвариантный.
[01:32:29.320 --> 01:32:32.320]  Соответственно, инвариантность всегда можно,
[01:32:32.320 --> 01:32:35.320]  потому что это тот же тип, который вы просите.
[01:32:39.320 --> 01:32:42.320]  Есть целая такая табличка.
[01:32:42.320 --> 01:32:45.320]  Как я говорил, выводили у меня дядю.
[01:32:45.320 --> 01:32:48.320]  Есть базовые такие типы в языке,
[01:32:48.320 --> 01:32:51.320]  которые имеют заданные вариантности.
[01:32:51.320 --> 01:32:54.320]  Эта табличка мне показывается скорее для того,
[01:32:54.320 --> 01:32:57.320]  чтобы вы с ней ознакомились.
[01:32:57.320 --> 01:33:00.320]  Когда она не нужна будет.
[01:33:00.320 --> 01:33:03.320]  Это надо к экзамену учить?
[01:33:03.320 --> 01:33:06.320]  Экзамена не будет.
[01:33:06.320 --> 01:33:09.320]  Так вы такое не говорили.
[01:33:09.320 --> 01:33:12.320]  Зачем ты пугаешь людей просто так?
[01:33:12.320 --> 01:33:15.320]  Да я тебя пугаю, не беспокойся.
[01:33:15.320 --> 01:33:18.320]  Если эта табличка придется работать только в одном случае,
[01:33:18.320 --> 01:33:21.320]  когда вы будете писать unsafe code,
[01:33:21.320 --> 01:33:24.320]  тогда вам придется действительно смотреть табличку
[01:33:24.320 --> 01:33:27.320]  и гарантировать то, что ваши типы действительно
[01:33:27.320 --> 01:33:30.320]  правильно работают с lifetime.
[01:33:30.320 --> 01:33:33.320]  Мы еще посмотрим, например, того, как это с unsafe code работает.
[01:33:33.320 --> 01:33:36.320]  Но для начала давайте посмотрим какие-нибудь другие примеры.
[01:33:36.320 --> 01:33:39.320]  Например, контрольный вопрос.
[01:33:39.320 --> 01:33:42.320]  Какая вариантность этого типа?
[01:33:42.320 --> 01:33:45.320]  Вариантность вычисляется от каждого входного аргумента.
[01:33:45.320 --> 01:33:48.320]  Я дам подсказку. У нас три входных аргумента.
[01:33:48.320 --> 01:33:51.320]  A, B и C.
[01:33:54.320 --> 01:33:57.320]  А может кажется...
[01:34:07.320 --> 01:34:10.320]  Можно, можно.
[01:34:10.320 --> 01:34:13.320]  Если что, ссылка на 1.3.
[01:34:13.320 --> 01:34:16.320]  А второй lifetime где был?
[01:34:16.320 --> 01:34:19.320]  Внутри этажки.
[01:34:19.320 --> 01:34:22.320]  Трейд у нас просто тоже от lifetime code зависит.
[01:34:22.320 --> 01:34:25.320]  По внешнему lifetime, которые все очень интенсивные варианты.
[01:34:42.320 --> 01:34:45.320]  На самом деле это очень просто.
[01:34:45.320 --> 01:34:48.320]  По пугам это просто понять, почему табличка такая уже.
[01:34:48.320 --> 01:34:51.320]  Для этого нужны примеры какие-то.
[01:34:51.320 --> 01:34:54.320]  Я не советую.
[01:34:54.320 --> 01:34:57.320]  Если хочешь, можешь посмотреть статье,
[01:34:57.320 --> 01:35:00.320]  которая доказывает формальный моделер аста.
[01:35:00.320 --> 01:35:03.320]  Так вообще лучше просто пользоваться табличкой.
[01:35:12.320 --> 01:35:15.320]  Я даже сам проверил.
[01:35:15.320 --> 01:35:18.320]  Я себя, скажем так, проверил.
[01:35:21.320 --> 01:35:24.320]  Ну ладно.
[01:35:24.320 --> 01:35:27.320]  Да, потому что у нас ссылка.
[01:35:27.320 --> 01:35:30.320]  Здесь ссылка A на T.
[01:35:30.320 --> 01:35:33.320]  T какой-то там не важно.
[01:35:33.320 --> 01:35:36.320]  По A мы кавариантны. Ура.
[01:35:36.320 --> 01:35:39.320]  Потом у нас T.
[01:35:39.320 --> 01:35:42.320]  Заранее запоминаем.
[01:35:42.320 --> 01:35:45.320]  Здесь все представляет из себя T.
[01:35:45.320 --> 01:35:48.320]  Поэтому T мы кавариантны.
[01:35:48.320 --> 01:35:51.320]  Заранее говорю.
[01:35:51.320 --> 01:35:54.320]  Если бы внутри нашлась где-то контовариантность,
[01:35:54.320 --> 01:35:57.320]  кавариантность дает инвариантность.
[01:35:57.320 --> 01:36:00.320]  Просто мы налагаем друг друга, пересекаем.
[01:36:00.320 --> 01:36:03.320]  По трейду, где lifetime B, что у нас там получается?
[01:36:03.320 --> 01:36:06.320]  А нет, наврал.
[01:36:06.320 --> 01:36:09.320]  Соответственно, да, мы инвариантны по B.
[01:36:09.320 --> 01:36:12.320]  Потому что мы кавариантны по всему этому.
[01:36:12.320 --> 01:36:15.320]  Соответственно, как минимум кавариантны по этим типам.
[01:36:15.320 --> 01:36:18.320]  Мы по B инвариантны по табличке.
[01:36:18.320 --> 01:36:21.320]  Это кавариантность и инвариантность.
[01:36:21.320 --> 01:36:24.320]  Инвариантность это как бы конкретная часть этого луча.
[01:36:24.320 --> 01:36:27.320]  Потом у нас есть еще C.
[01:36:27.320 --> 01:36:30.320]  C мы конечно кавариантны.
[01:36:30.320 --> 01:36:33.320]  Потому что кавариантность на кавариантность.
[01:36:33.320 --> 01:36:36.320]  Как-то так.
[01:36:36.320 --> 01:36:39.320]  Сложная штука.
[01:36:39.320 --> 01:36:42.320]  Так.
[01:36:42.320 --> 01:36:45.320]  Припоминаете ли вы, что на самом деле Dintrade это type и reg?
[01:36:45.320 --> 01:36:48.320]  Да.
[01:36:48.320 --> 01:36:51.320]  Ну, в общем, естественно, если это type и reg,
[01:36:51.320 --> 01:36:54.320]  а у нас lifetime это часть типа,
[01:36:54.320 --> 01:36:57.320]  то в таком случае, если бы мы стерли lifetime, было бы очень плохо.
[01:36:57.320 --> 01:37:00.320]  Поэтому на самом деле, именно поэтому вот в этой табличке
[01:37:00.320 --> 01:37:03.320]  вообще Dintrade имеет еще какой-то lifetime.
[01:37:03.320 --> 01:37:06.320]  Плюс A.
[01:37:06.320 --> 01:37:09.320]  Он всегда есть, вы его почти никогда не видите.
[01:37:12.320 --> 01:37:15.320]  Поэтому конкретно в данном случае вы будете иметь,
[01:37:15.320 --> 01:37:18.320]  представим, что у нас есть какая-то функция,
[01:37:18.320 --> 01:37:21.320]  которая создает внутри строчку.
[01:37:21.320 --> 01:37:24.320]  Потом, при условии, что эта строчка реализует какой-то trade,
[01:37:24.320 --> 01:37:27.320]  мы создаем box.
[01:37:27.320 --> 01:37:30.320]  У этого box на самом деле внутри будет плюс A lifetime.
[01:37:30.320 --> 01:37:33.320]  Этот lifetime A будет на протяжении нашей функции.
[01:37:33.320 --> 01:37:36.320]  У нас есть вернуть мне функции. О, ошибка, да?
[01:37:36.320 --> 01:37:39.320]  Потому это будет не скомпилировать.
[01:37:39.320 --> 01:37:42.320]  Нужно было, наверное, справиться с функцией написать.
[01:37:42.320 --> 01:37:45.320]  Поэтому у нас никуда не деваться lifetime,
[01:37:45.320 --> 01:37:48.320]  и когда вы создаете Dintrade,
[01:37:48.320 --> 01:37:51.320]  то у вас там на самом деле еще живет lifetime внутри.
[01:37:51.320 --> 01:37:54.320]  Так. Как думаете, чего этот код не компилируется?
[01:37:54.320 --> 01:37:57.320]  У нас будет много примеров на лекции,
[01:37:57.320 --> 01:38:00.320]  потому что мы так ничего не понимаем.
[01:38:04.320 --> 01:38:07.320]  Понятно.
[01:38:27.320 --> 01:38:30.320]  Ну, кажется, потому что из-за...
[01:38:30.320 --> 01:38:32.320]  Сейчас у нас первый аргумент
[01:38:32.320 --> 01:38:35.320]  и был в фигурке.
[01:38:35.320 --> 01:38:38.320]  Это мутабельная ссылка
[01:38:38.320 --> 01:38:41.320]  на немутабельную статическую строчку.
[01:38:41.320 --> 01:38:44.320]  Поскольку мы вариантные,
[01:38:44.320 --> 01:38:47.320]  кажется, второй аргумент
[01:38:47.320 --> 01:38:50.320]  тогда тоже должен был быть,
[01:38:50.320 --> 01:38:53.320]  ссылка на статическую строчку,
[01:38:53.320 --> 01:38:56.320]  но тут у нас lifetime будет поменьше.
[01:38:56.320 --> 01:38:59.320]  Я чуть-чуть запутался в том, что ты говоришь,
[01:38:59.320 --> 01:39:02.320]  что это правда.
[01:39:02.320 --> 01:39:05.320]  Ну, смотри.
[01:39:05.320 --> 01:39:08.320]  У нас тут ссылка на mute.t.
[01:39:08.320 --> 01:39:11.320]  Как мы помним, в результате мы по t-инвариантно.
[01:39:11.320 --> 01:39:14.320]  Хоть мы здесь получается у нас любой t,
[01:39:14.320 --> 01:39:17.320]  там мы вариантны по t,
[01:39:17.320 --> 01:39:20.320]  и, соответственно, не получится привести друг к другу t-шки,
[01:39:20.320 --> 01:39:23.320]  в случае чего.
[01:39:23.320 --> 01:39:26.320]  И, соответственно, t-шка у нас какая должна быть?
[01:39:26.320 --> 01:39:29.320]  Такой должен быть ссылка на a,
[01:39:29.320 --> 01:39:32.320]  то, что bark имеет.
[01:39:32.320 --> 01:39:35.320]  Такой должен быть у t.
[01:39:35.320 --> 01:39:38.320]  Соответственно, t представляет ссылку a на str.
[01:39:38.320 --> 01:39:41.320]  Вот вы пытаетесь засунуть ссылку a на str,
[01:39:41.320 --> 01:39:44.320]  потому что вы привели это все дело.
[01:39:44.320 --> 01:39:47.320]  Вот у вас ссылка на a-str,
[01:39:47.320 --> 01:39:50.320]  потом mute, ссылка a-str,
[01:39:50.320 --> 01:39:53.320]  и появляется mute-ссылка на a-str.
[01:39:53.320 --> 01:39:56.320]  И, соответственно, вы пытаетесь statics присунуть.
[01:39:56.320 --> 01:39:59.320]  И дело в том, что
[01:39:59.320 --> 01:40:02.320]  статическая строка, так как мы инвариантны
[01:40:02.320 --> 01:40:05.320]  по нашему аргументу t,
[01:40:05.320 --> 01:40:08.320]  мы не можем привести нашу статическую ссылку к a,
[01:40:08.320 --> 01:40:11.320]  даже несмотря на то, что вроде бы она живет больше.
[01:40:11.320 --> 01:40:14.320]  Просто она запрещает нам.
[01:40:14.320 --> 01:40:17.320]  Система типов нас ограничивает, чтобы мы в том числе
[01:40:17.320 --> 01:40:20.320]  не делали ошибки в других местах.
[01:40:20.320 --> 01:40:23.320]  Могли бы.
[01:40:28.320 --> 01:40:31.320]  Так, примерно понятно.
[01:40:31.320 --> 01:40:34.320]  Ну, это как раз desugared.
[01:40:34.320 --> 01:40:37.320]  Зря, наверное, не попало в следующий раз.
[01:40:37.320 --> 01:40:40.320]  Вот как раз ссылка на a-str,
[01:40:40.320 --> 01:40:43.320]  и тут как раз хорошо видно, что у нас происходит.
[01:40:43.320 --> 01:40:46.320]  Мы засовываем какую-то строчку,
[01:40:46.320 --> 01:40:49.320]  и там мы не можем статическую строчку
[01:40:49.320 --> 01:40:52.320]  в разном случае.
[01:40:55.320 --> 01:40:58.320]  Так, как вы думаете, насколько нам
[01:40:58.320 --> 01:41:01.320]  это часто нужно?
[01:41:01.320 --> 01:41:04.320]  Мы все это начали изучать,
[01:41:04.320 --> 01:41:07.320]  теперь давайте подумаем.
[01:41:07.320 --> 01:41:10.320]  Ну,
[01:41:10.320 --> 01:41:13.320]  зависит от того, насколько ты сложный код пишешь.
[01:41:13.320 --> 01:41:16.320]  Как я говорил, это полезно знать
[01:41:16.320 --> 01:41:19.320]  в любой момент времени,
[01:41:19.320 --> 01:41:22.320]  чтобы понимать, как код компилируется.
[01:41:22.320 --> 01:41:25.320]  Но на самом деле это действительно существенно
[01:41:25.320 --> 01:41:28.320]  только тогда, когда вы пишете unsafe код.
[01:41:28.320 --> 01:41:31.320]  В unsafe коде вы можете прямо напортачить.
[01:41:31.320 --> 01:41:34.320]  Вот давайте поймем, как мы можем напортачить,
[01:41:34.320 --> 01:41:37.320]  если мы начинаем писать unsafe.
[01:41:37.320 --> 01:41:40.320]  Мы в принципе unsafe не знаем, но я не думаю,
[01:41:40.320 --> 01:41:43.320]  что у нас возникают проблемы здесь.
[01:41:44.320 --> 01:41:47.320]  У нас какая-то тэшка,
[01:41:47.320 --> 01:41:50.320]  потом внутри мы пытаемся сделать set,
[01:41:50.320 --> 01:41:53.320]  написать такую функцию.
[01:41:53.320 --> 01:41:56.320]  Просто для нашего удобства я написал здесь
[01:41:56.320 --> 01:41:59.320]  сигнатуру функции write,
[01:41:59.320 --> 01:42:02.320]  которая сидит по второму write.
[01:42:02.320 --> 01:42:05.320]  То, что она делает, она пишет по указателю.
[01:42:05.320 --> 01:42:08.320]  Естественно, она ничего не проверяет,
[01:42:08.320 --> 01:42:11.320]  она просто пишет по указателю.
[01:42:11.320 --> 01:42:14.320]  Она просто привозит ее к указателю,
[01:42:14.320 --> 01:42:17.320]  а потом записывает ее new value.
[01:42:17.320 --> 01:42:20.320]  Казалось бы, что может пойти не так.
[01:42:20.320 --> 01:42:23.320]  Просто записали в тэ.
[01:42:23.320 --> 01:42:26.320]  Нам даже дали владеющий тип,
[01:42:26.320 --> 01:42:29.320]  казалось бы, не владеющий, какой-то тип.
[01:42:29.320 --> 01:42:32.320]  Как раз здесь один из приколов возникает,
[01:42:32.320 --> 01:42:35.320]  что это не обязательно владеющий.
[01:42:35.320 --> 01:42:38.320]  Вот смотрите, у нас тэшка,
[01:42:38.320 --> 01:42:41.320]  мы пытаемся записать.
[01:42:41.320 --> 01:42:44.320]  Как вы думаете, что может пойти не так?
[01:42:44.320 --> 01:42:47.320]  Если что, там дальше надо слать следующий пример.
[01:42:47.320 --> 01:42:50.320]  Хотя, наверное, давайте сразу примеры начнем.
[01:42:50.320 --> 01:42:53.320]  Что здесь пойдет не так?
[01:42:53.320 --> 01:42:56.320]  Здесь, на самом деле, прям явная ошибка.
[01:42:59.320 --> 01:43:02.320]  Похоже, мы смогли успешно записать ссылку
[01:43:02.320 --> 01:43:05.320]  и не подумать о том, что она могла не дожить.
[01:43:06.320 --> 01:43:09.320]  Жить меньше, чем mySell.
[01:43:09.320 --> 01:43:12.320]  Да, наш mySell имеет ограничение статик.
[01:43:12.320 --> 01:43:15.320]  То есть, он содержит ссылку на какую-то статическую переменную.
[01:43:15.320 --> 01:43:18.320]  Нам, конечно же, это не по кайфу,
[01:43:18.320 --> 01:43:21.320]  когда мы начинаем писать фу что-то.
[01:43:21.320 --> 01:43:24.320]  Потому что мы пытаемся записать уже какую-то ссылку
[01:43:24.320 --> 01:43:27.320]  с лайфтаймом a на i3d2.
[01:43:27.320 --> 01:43:30.320]  Соответственно, когда мы выйдем отсюда,
[01:43:30.320 --> 01:43:33.320]  вот здесь все будет хорошо, а когда мы выйдем уже из фу,
[01:43:33.320 --> 01:43:36.320]  то, соответственно, у нас ссылка будет на невалидный регион памяти.
[01:43:36.320 --> 01:43:39.320]  То есть шутка в том, что она внутри ссылы,
[01:43:39.320 --> 01:43:42.320]  а ссылка на i3d2.
[01:43:42.320 --> 01:43:45.320]  И мы ничего не проверим.
[01:43:45.320 --> 01:43:48.320]  Поэтому нужно указать, что t в лайфтаймом трэшке
[01:43:48.320 --> 01:43:51.320]  должен быть под типом лайфтайма server.
[01:43:54.320 --> 01:43:57.320]  Ну, что-то такое, да.
[01:43:57.320 --> 01:44:00.320]  Нужно написать, но вообще тебе нужно сделать тип invariant.
[01:44:03.320 --> 01:44:06.320]  Смотри.
[01:44:06.320 --> 01:44:09.320]  У тебя проблема в том, что mysell – это ссылка на i3d2.
[01:44:09.320 --> 01:44:12.320]  С самого начала здесь ты создаешь счастливый mysell
[01:44:12.320 --> 01:44:15.320]  на статик какой-то i3d2.
[01:44:15.320 --> 01:44:18.320]  Это статическая ссылка.
[01:44:21.320 --> 01:44:24.320]  Тут просто запись указателя.
[01:44:26.320 --> 01:44:29.320]  Потом мы берем такие value,
[01:44:29.320 --> 01:44:32.320]  которые равен 13.
[01:44:32.320 --> 01:44:35.320]  У нас mysell на i3d2.
[01:44:35.320 --> 01:44:38.320]  Когда мы делаем set, мы записываем ссылку
[01:44:38.320 --> 01:44:41.320]  на этот...
[01:44:41.320 --> 01:44:44.320]  Да, когда мы отсюда выходим,
[01:44:44.320 --> 01:44:47.320]  у нас ссылка очищается.
[01:44:47.320 --> 01:44:50.320]  Ну, не очищается ссылка, а становится невалидной.
[01:44:50.320 --> 01:44:53.320]  То есть это один из возможных выводов программы.
[01:44:53.320 --> 01:44:56.320]  В первый раз у нас все было хорошо, 13.
[01:44:56.320 --> 01:44:59.320]  Действительно все было валидно, а во второй раз у нас какой-то мусор.
[01:44:59.320 --> 01:45:02.320]  Вот мы получили memory unsafety
[01:45:02.320 --> 01:45:05.320]  просто за бесплатно, потому что у нас на самом деле что-то...
[01:45:05.320 --> 01:45:08.320]  Мы бы попользовались unsafety.
[01:45:08.320 --> 01:45:11.320]  На самом деле мы еще, когда будем рассматривать unsafety,
[01:45:11.320 --> 01:45:14.320]  там такие еще приколы будут.
[01:45:14.320 --> 01:45:17.320]  Будет стрелять в самых неожиданных местах,
[01:45:17.320 --> 01:45:20.320]  потому что вы какие-то пререквизиты unsafety не выполняете.
[01:45:20.320 --> 01:45:23.320]  Как раз вспоминаем первую лекцию, где был пример с mem.copy.
[01:45:23.320 --> 01:45:26.320]  Кажется, Илина Сторвальс говорила, что этот весь код
[01:45:26.320 --> 01:45:29.320]  нужно тестировать, и вы сами виноваты, что у вас функция
[01:45:29.320 --> 01:45:32.320]  не предупреждает о пересечениях и все такое.
[01:45:32.320 --> 01:45:35.320]  А другие сказали, ну вы виноваты, это из покон веков
[01:45:35.320 --> 01:45:38.320]  существует ограничение mem.copy, и сами виноваты программисты,
[01:45:38.320 --> 01:45:41.320]  что такое написали. Ну вот Rust говорит, что вы
[01:45:41.320 --> 01:45:44.320]  должны писать хороший интерфейс, а все плюс-плюс говорят,
[01:45:44.320 --> 01:45:47.320]  ну вы сами виноваты, вот пользуйтесь нормально, пишите нормальный код.
[01:45:47.320 --> 01:45:50.320]  Что в ссылку там пишете? Как-то так.
[01:45:50.320 --> 01:45:55.320]  Если я unsaved не пишу, то от чего меня Rust защищается?
[01:45:55.320 --> 01:45:58.320]  Если не пишешь unsaved, у тебя никогда не будет mem.ariant-safety.
[01:45:58.320 --> 01:46:02.320]  Не будет такого никогда. В худшем случае просто программа
[01:46:02.320 --> 01:46:05.320]  запаникует сразу же, как только что-то сломается.
[01:46:05.320 --> 01:46:10.320]  А в случае плюсов, ты бы мог получить произвольные
[01:46:10.320 --> 01:46:13.320]  инварианты, могли бы произвольно сбиться, все что угодно,
[01:46:13.320 --> 01:46:17.320]  зависит от оптимизации компилятора и всего такого,
[01:46:17.320 --> 01:46:21.320]  как в итоге код работает.
[01:46:21.320 --> 01:46:24.320]  Давайте посмотрим, что произошло еще раз.
[01:46:24.320 --> 01:46:28.320]  Мы какую-то I32
[01:46:28.320 --> 01:46:31.320]  сохранили в статике 32
[01:46:31.320 --> 01:46:35.320]  с помощью unsaved, и мы никаких проверок не сделали.
[01:46:35.320 --> 01:46:38.320]  По умолчанию компилятор не даст нам сделать, потому что
[01:46:38.320 --> 01:46:41.320]  когда мы пытаемся...
[01:46:41.320 --> 01:46:44.320]  Если бы мы писали в сейв, в таком случае нам бы пришлось
[01:46:44.320 --> 01:46:48.320]  сделать. Да, и это инвариантность.
[01:46:48.320 --> 01:46:52.320]  MySaleT это получение к вариантной вещам.
[01:46:52.320 --> 01:46:56.320]  То есть можно в качестве T использовать какие-то подтипа.
[01:46:56.320 --> 01:47:00.320]  Вот у нас получилось засунуть подтип, но при этом
[01:47:00.320 --> 01:47:04.320]  unsaved был использован неправильно, и мы сломались на уровне
[01:47:04.320 --> 01:47:08.320]  того, что мы сломали AXM, то есть
[01:47:08.320 --> 01:47:12.320]  Lessing Sormitability, просто неправильно в lifetime поставили.
[01:47:12.320 --> 01:47:16.320]  В итоге это закончилось тем, что у нас в MySale есть слишком маленькая
[01:47:16.320 --> 01:47:19.320]  строчка теперь.
[01:47:19.320 --> 01:47:23.320]  Вот как раз то, что было про MuteSelf, почему этот код не компилируется?
[01:47:23.320 --> 01:47:27.320]  Потому что у нас MuteSelf это инвариантная штука.
[01:47:27.320 --> 01:47:31.320]  Давайте мы чуть более конкретно посмотрим, потому что
[01:47:31.320 --> 01:47:35.320]  здесь нужно обессахарить, чтобы понять, что происходит.
[01:47:35.320 --> 01:47:39.320]  Обессахаренно оно выглядит так, конечно.
[01:47:39.320 --> 01:47:43.320]  У нас, во-первых, два input параметра.
[01:47:43.320 --> 01:47:47.320]  У нас Myself представляет из себя
[01:47:47.320 --> 01:47:51.320]  Myself at, at это ссылка на I32.
[01:47:51.320 --> 01:47:55.320]  Поэтому оно обессахаренно выглядит примерно вот так.
[01:47:55.320 --> 01:47:59.320]  У нас будет ссылка с слотами A, Mute, Myself.
[01:47:59.320 --> 01:48:03.320]  И кажется, да, вот здесь должна быть
[01:48:03.320 --> 01:48:07.320]  B.
[01:48:07.320 --> 01:48:11.320]  Тоже на записи, чтобы было видно, вот в этом месте B.
[01:48:11.320 --> 01:48:15.320]  Вот как-то так.
[01:48:15.320 --> 01:48:19.320]  Из-за того, что мы инвариантные, нам раз не позволят записать это значение,
[01:48:19.320 --> 01:48:23.320]  потому что просто не вызовется, не сможет он привести A
[01:48:23.320 --> 01:48:27.320]  здесь будет статику, здесь будет A, и соответственно
[01:48:27.320 --> 01:48:31.320]  он A к статику привести не может и пожалуется.
[01:48:31.320 --> 01:48:35.320]  SunSafe, да, пожалуйста, мы используем просто ссылку на Self,
[01:48:35.320 --> 01:48:39.320]  она кавариантно смогли привести, внутри Unsafe, и все сломалось.
[01:48:39.320 --> 01:48:43.320]  А вот, например, такой код не скомпилируется.
[01:48:43.320 --> 01:48:47.320]  Это просто Sell. То же самое на Sell.
[01:48:51.320 --> 01:48:55.320]  Что произошло? Просто Sell инвариантино.
[01:48:55.320 --> 01:48:59.320]  Как это сделано?
[01:48:59.320 --> 01:49:03.320]  Как это сделано? Ну, это хороший вопрос. Там в компиляторе прописан
[01:49:03.320 --> 01:49:07.320]  такой тип Macros, называется
[01:49:07.320 --> 01:49:11.320]  Length равняется UnsafeSell,
[01:49:11.320 --> 01:49:15.320]  ну, это называется UnsafeSell написано. UnsafeSell у нас
[01:49:15.320 --> 01:49:19.320]  по T инвариантен. Sell внутри использует UnsafeSell.
[01:49:19.320 --> 01:49:23.320]  Соответственно, получается инвариантность Sell.
[01:49:23.320 --> 01:49:27.320]  И он не пропустит еще раньше.
[01:49:27.320 --> 01:49:31.320]  Sell у нас инвариантен, никакого варианта.
[01:49:31.320 --> 01:49:35.320]  Вот такая ошибочка получится.
[01:49:35.320 --> 01:49:39.320]  Он скажет нам, смотрите, у нас здесь lifetime1,
[01:49:39.320 --> 01:49:43.320]  а эта ссылка на притяжение lifetime1 не живет.
[01:49:43.320 --> 01:49:47.320]  Все вроде бы понятно, когда начинаешь
[01:49:47.320 --> 01:49:51.320]  разбираться.
[01:49:51.320 --> 01:49:55.320]  Вот этот вот код почему в целом компилируется?
[01:50:01.320 --> 01:50:05.320]  Ну,
[01:50:05.320 --> 01:50:09.320]  мы считаем, что там есть функция.
[01:50:09.320 --> 01:50:13.320]  Ну, я тоже это уже проговорил,
[01:50:13.320 --> 01:50:17.320]  на самом деле.
[01:50:31.320 --> 01:50:35.320]  Что?
[01:50:35.320 --> 01:50:39.320]  Неважно, может считать, что пустая функция.
[01:50:47.320 --> 01:50:51.320]  Просто чтобы lifetime продлить.
[01:50:51.320 --> 01:50:55.320]  Потому что иначе у нас lifetime sell будет такой вот.
[01:50:55.320 --> 01:50:59.320]  А мы хотим, чтобы он прожил на протяжении всего.
[01:50:59.320 --> 01:51:03.320]  Поэтому мы дропы делаем, чтобы он дожил до сего.
[01:51:03.320 --> 01:51:07.320]  Просто явно пишем здесь lifetime.
[01:51:11.320 --> 01:51:15.320]  Давайте я слух еще расскажу.
[01:51:15.320 --> 01:51:19.320]  У нас ссылка на Sell ковариант, ну просто ссылка на что-то ковариантно.
[01:51:19.320 --> 01:51:23.320]  Поэтому получается, что потомка вариантная и вот этот код с компилируется.
[01:51:23.320 --> 01:51:27.320]  Ну, смотри.
[01:51:27.320 --> 01:51:31.320]  У нас ссылка на Sell. Ссылка АТ ковариантная и по А, и по Т.
[01:51:31.320 --> 01:51:35.320]  Здесь у нас какой-то lifetime А, но Sell это myself.
[01:51:35.320 --> 01:51:39.320]  Мы ковариантные потому и потом. Соответственно мы ковариантные.
[01:51:39.320 --> 01:51:43.320]  Все.
[01:51:43.320 --> 01:51:47.320]  Мы ковариантные по Т.
[01:51:47.320 --> 01:51:51.320]  Так.
[01:51:51.320 --> 01:51:55.320]  Мы ковариантные по Т. То есть мы все можем
[01:51:55.320 --> 01:51:59.320]  что-то передать любой партизим?
[01:51:59.320 --> 01:52:03.320]  Получается да.
[01:52:03.320 --> 01:52:07.320]  Как раз по ссылке мы смотрим только. Просто если я без сахаритета,
[01:52:07.320 --> 01:52:11.320]  тогда получится ссылка на А и 32 и естественно ты не сможешь просто так
[01:52:11.320 --> 01:52:15.320]  и 32 как бы
[01:52:15.320 --> 01:52:19.320]  записать что-то вместо и 32.
[01:52:19.320 --> 01:52:23.320]  Ты будешь вариантным только по lifetime.
[01:52:23.320 --> 01:52:27.320]  Потому что и 32 это уже какой-то конкретный Т.
[01:52:27.320 --> 01:52:31.320]  Вариантным ты именно по lifetime будешь в этом случае.
[01:52:31.320 --> 01:52:35.320]  А статик это по типу?
[01:52:35.320 --> 01:52:39.320]  Да, статик по типу всего.
[01:52:43.320 --> 01:52:47.320]  Давай там где-то.
[01:52:47.320 --> 01:52:51.320]  Давай прикинем, что здесь нет мюта.
[01:52:51.320 --> 01:52:55.320]  У нас Т это ссылка на статик.
[01:52:55.320 --> 01:52:59.320]  Соответственно вместо А здесь убедит статик,
[01:52:59.320 --> 01:53:03.320]  и здесь убедит статик.
[01:53:03.320 --> 01:53:07.320]  По отношению к этому коду.
[01:53:07.320 --> 01:53:11.320]  Здесь у нас
[01:53:11.320 --> 01:53:15.320]  Myself имеет тип ссылка на статик и 32.
[01:53:15.320 --> 01:53:19.320]  Соответственно Т это ссылка на статик и 32.
[01:53:19.320 --> 01:53:23.320]  Соответственно вместо ссылки на А и 32
[01:53:23.320 --> 01:53:27.320]  нужно написать ссылку на статик и 32.
[01:53:27.320 --> 01:53:31.320]  И в качестве value тоже.
[01:53:31.320 --> 01:53:35.320]  Сейчас в качестве value будет ссылка на статик.
[01:53:35.320 --> 01:53:39.320]  Там дальше ты передаешь ссылку с меньшим lifetime.
[01:53:39.320 --> 01:53:43.320]  С меньшим lifetime,
[01:53:43.320 --> 01:53:47.320]  потому что здесь вот
[01:53:47.320 --> 01:53:51.320]  тут должен быть вариант.
[01:53:51.320 --> 01:53:55.320]  Тут будут контраварианты в какой-то стороне?
[01:53:55.320 --> 01:53:59.320]  Не, контравариантности точно нет.
[01:53:59.320 --> 01:54:03.320]  Скорее всего причина просто это выписать вот здесь вот и внимательно посмотреть.
[01:54:03.320 --> 01:54:07.320]  Я думаю, что это чисто так.
[01:54:07.320 --> 01:54:11.320]  Можете это в качестве упражнения проделать.
[01:54:11.320 --> 01:54:15.320]  Я думаю, это совсем несложно.
[01:54:15.320 --> 01:54:19.320]  Скорее всего в ассоциированной функции вывелся не статический lifetime,
[01:54:19.320 --> 01:54:23.320]  но мы туда в качестве по типу передали myself статическим lifetime.
[01:54:23.320 --> 01:54:27.320]  И все варианты все отработали.
[01:54:27.320 --> 01:54:31.320]  Вот это больше на правду похоже.
[01:54:31.320 --> 01:54:35.320]  Нужно прямо написать.
[01:54:35.320 --> 01:54:39.320]  Я просто в голове у меня не получается обессахарить все и проверить.
[01:54:39.320 --> 01:54:43.320]  Дроб чекер.
[01:54:43.320 --> 01:54:47.320]  Это самую тяжелую главу. Мы можем с собой гордиться.
[01:54:47.320 --> 01:54:51.320]  Если вы даже примерно что-то поняли, то это вообще замечательно.
[01:54:51.320 --> 01:54:55.320]  Через какое-то время будете шарящими в одной из тем,
[01:54:55.320 --> 01:54:59.320]  которые практически никто не шарит из ростовиков.
[01:54:59.320 --> 01:55:03.320]  Дроб чекер.
[01:55:03.320 --> 01:55:07.320]  У нас есть такая штука, что
[01:55:07.320 --> 01:55:11.320]  как все плюс-плюс, у нас есть какой-то порядок объявлений.
[01:55:11.320 --> 01:55:15.320]  И в обратном порядке мы удаляем переменные.
[01:55:15.320 --> 01:55:19.320]  Структурное программирование это называется.
[01:55:19.320 --> 01:55:23.320]  Поэтому в том порядке, в котором мы создаем переменные, мы их и удаляем.
[01:55:23.320 --> 01:55:27.320]  Но бывают ситуации, когда мы не понимаем, в каком порядке их нужно удалять.
[01:55:27.320 --> 01:55:31.320]  Вот, например, вектор и вектор.
[01:55:31.320 --> 01:55:35.320]  У нас в расе сказано, что
[01:55:35.320 --> 01:55:39.320]  первый элемент тюпла должен умереть первым, второй элемент тюпла — вторым.
[01:55:39.320 --> 01:55:43.320]  Но при этом в глазах брови чекера левый вектор
[01:55:43.320 --> 01:55:47.320]  будет ли строго переживать правый?
[01:55:47.320 --> 01:55:51.320]  Если один же, с самого начала, один дропается,
[01:55:51.320 --> 01:55:55.320]  а потом второй. Кто кого переживает?
[01:55:55.320 --> 01:55:59.320]  Вообще в глазах брови чекера есть такое понятие?
[01:55:59.320 --> 01:56:03.320]  Какой лайфтайм каждого будет?
[01:56:03.320 --> 01:56:07.320]  У кого больше? У первого или у второго?
[01:56:07.320 --> 01:56:11.320]  Но пока непонятно, должны ли они вообще зависеть как-то друг от друга?
[01:56:11.320 --> 01:56:15.320]  Да.
[01:56:15.320 --> 01:56:19.320]  Шутка в том, что они никак друг от друга не зависят.
[01:56:19.320 --> 01:56:23.320]  В глазах брови чекера они имеют один и тот же лайфтайм.
[01:56:23.320 --> 01:56:27.320]  Потому что это все один тип, все внутри.
[01:56:27.320 --> 01:56:31.320]  Для него это все один тип.
[01:56:31.320 --> 01:56:35.320]  Вообще у нас вообще это беспокоит. В каком порядке переменная должна умирать?
[01:56:35.320 --> 01:56:39.320]  Давайте вот на такой код посмотрим.
[01:56:39.320 --> 01:56:43.320]  Он скомпилируется?
[01:57:05.320 --> 01:57:09.320]  Это не для планирования, когда трейд клоун все портит.
[01:57:19.320 --> 01:57:23.320]  Ну, чтобы он компилировался на каким-то магическим образом,
[01:57:23.320 --> 01:57:27.320]  необходимо дропать инспектора раньше, чтобы сука там никого не переживала.
[01:57:27.320 --> 01:57:31.320]  Вообще, кстати, структура все дропается именно в том порядке, в котором объявлены.
[01:57:31.320 --> 01:57:35.320]  То есть в каком объявлены структуры сначала экспектора, потом дни.
[01:57:35.320 --> 01:57:39.320]  Конкретно данный код скомпилируется.
[01:57:39.320 --> 01:57:43.320]  Этот код скомпилируется.
[01:57:43.320 --> 01:57:47.320]  Но что с ним добавим дроп?
[01:58:01.320 --> 01:58:05.320]  То есть все, что отличается в этом коде,
[01:58:05.320 --> 01:58:09.320]  это то, что для инспектора какой-то дроп выдал.
[01:58:09.320 --> 01:58:13.320]  И все.
[01:58:13.320 --> 01:58:17.320]  Что?
[01:58:17.320 --> 01:58:21.320]  Да, это и есть вопрос.
[01:58:21.320 --> 01:58:25.320]  Что-то есть надежда, что ничего не поменяется, если что-то дропится в правильном порядке,
[01:58:25.320 --> 01:58:29.320]  и поэтому что-то появится в аналитическом бизнесе.
[01:58:29.320 --> 01:58:33.320]  Ну, вообще правда в том, что
[01:58:33.320 --> 01:58:37.320]  это достаточно сложно анализировать, что там в каком порядке должно дропаться.
[01:58:37.320 --> 01:58:41.320]  Может, там есть какой-то порядок, что сначала третье поле, потом пятое, потом первое.
[01:58:41.320 --> 01:58:45.320]  В плюсах все проще.
[01:58:45.320 --> 01:58:49.320]  Ну, такое дело в плюсах. В плюсах небезопасный язык.
[01:58:49.320 --> 01:58:53.320]  Если у тебя неправильный порядок дропа, ты можешь случайно отстрелить ногу.
[01:58:53.320 --> 01:58:57.320]  Просто из-за того, что у тебя деструктор пораньше.
[01:58:57.320 --> 01:59:01.320]  Ну, смотри, конкретно здесь у нас такая ситуация. У нас инспектор владеет кое-что ссылкой.
[01:59:01.320 --> 01:59:05.320]  Мы хотим, чтобы эта ссылка пережила.
[01:59:05.320 --> 01:59:09.320]  Дело в том, что эта ссылка живет вместе с нами в ворлде.
[01:59:09.320 --> 01:59:13.320]  Умеет такой же лайфтайм, как мы.
[01:59:13.320 --> 01:59:17.320]  Проблема в том, что этот код не скомпилируется.
[01:59:17.320 --> 01:59:21.320]  Если бы мы не скомпилировались первыми, в таком случае инспектор
[01:59:21.320 --> 01:59:27.320]  попробовал бы к уже денициализированной памяти обратиться.
[01:59:27.320 --> 01:59:31.320]  А то есть не гарантируется, как это по итогу будет дропаться, да?
[01:59:31.320 --> 01:59:37.320]  Нет. Тебе гарантируют. Тебе говорят порядок такой же, как вебилейная структура в тюпах.
[01:59:37.320 --> 01:59:41.320]  Такой же порядок, как с левой направо первого.
[01:59:41.320 --> 01:59:45.320]  У тебя переменная скопия в реверсном порядке.
[01:59:45.320 --> 01:59:49.320]  При этом дроп-чекер такой?
[01:59:49.320 --> 01:59:53.320]  Да, дроп-чекер тебе скажет. Нет, я это не скомпилирую.
[01:59:53.320 --> 01:59:57.320]  Сейчас я тебе скажу.
[01:59:57.320 --> 02:00:01.320]  Еще одна причина, почему у нас не стоит использовать.
[02:00:01.320 --> 02:00:07.320]  То есть тогда мы что-то фиксируем, а потом начинаем обмазывать это все.
[02:00:07.320 --> 02:00:11.320]  Ну слушай, зафиксировали, но тут такая проблема.
[02:00:11.320 --> 02:00:15.320]  Это, кстати, фиксировали, потому что много кода на это рассчитывали когда-то.
[02:00:15.320 --> 02:00:19.320]  И поэтому сказали, ну сломайте много код, давайте не будем ничего менять.
[02:00:23.320 --> 02:00:27.320]  Да, в конкретном данном случае у нас сначала дропнется инспектор, потом дни.
[02:00:35.320 --> 02:00:37.320]  Ну подождите.
[02:00:37.320 --> 02:00:41.320]  Это проблема называется Sound Generic Drop.
[02:00:41.320 --> 02:00:45.320]  Потому что единственное, кто должен заботиться вообще об этой проблеме,
[02:00:45.320 --> 02:00:49.320]  это те, у кого есть какие-то Generic Lifetime.
[02:00:49.320 --> 02:00:51.320]  Ну вообще есть Lifetime.
[02:00:51.320 --> 02:00:55.320]  Ну это просто ее название исходит из того, что если у вас есть,
[02:00:55.320 --> 02:00:59.320]  как в инспекторе ссылка на какую-нибудь U8,
[02:00:59.320 --> 02:01:01.320]  то у вас появляется и Lifetime.
[02:01:01.320 --> 02:01:05.320]  И, соответственно, за счет этого Lifetime'а
[02:01:05.320 --> 02:01:09.320]  появляется зависимость в каком порядке у вас дропнется порядок.
[02:01:09.320 --> 02:01:13.320]  А так вообще, по линии у которых нет никаких Generic'ов,
[02:01:13.320 --> 02:01:15.320]  никаких Lifetime-зависимости, какая разница?
[02:01:15.320 --> 02:01:17.320]  Они просто в каком-то...
[02:01:17.320 --> 02:01:21.320]  Там без разницы в каком порядке все дропнется.
[02:01:21.320 --> 02:01:23.320]  Вот.
[02:01:23.320 --> 02:01:27.320]  Давайте придумаем самое глупое правило для того,
[02:01:27.320 --> 02:01:29.320]  чтобы у нас получился Sound Drop.
[02:01:29.320 --> 02:01:33.320]  То есть мы хотим, чтобы у нас дроп гарантированно...
[02:01:33.320 --> 02:01:37.320]  В общем, дроп был так, что у нас не было бы Memory and Safety.
[02:01:37.320 --> 02:01:41.320]  Иначе бы мы могли в дропе написать в неправильном порядке поля,
[02:01:41.320 --> 02:01:43.320]  и у нас бы все сломалось.
[02:01:43.320 --> 02:01:47.320]  Ворлд и инспектор поломать, местами поменять и все.
[02:01:47.320 --> 02:01:51.320]  Мы хотим, чтобы Lifetime-параметры в дроповом объекте были не меньше,
[02:01:51.320 --> 02:01:55.320]  чем в темпараметрах Selfie.
[02:01:55.320 --> 02:01:59.320]  А ты не сможешь в дропе указать эти параметры?
[02:01:59.320 --> 02:02:03.320]  Нет, потому что она в дропе же есть, как у Selfie?
[02:02:03.320 --> 02:02:05.320]  Ну, у Selfie, да, есть.
[02:02:05.320 --> 02:02:11.320]  Мы хотим, чтобы он был не больше, чем то, к чему мы обращаемся.
[02:02:11.320 --> 02:02:13.320]  А к чему ты обращаешься?
[02:02:13.320 --> 02:02:15.320]  Ну, как в инспекторе было.
[02:02:15.320 --> 02:02:19.320]  Ты понимаешь, как примеры с двумя векторами, ты не знаешь.
[02:02:19.320 --> 02:02:23.320]  Ты можешь, конечно, положиться на то, в каком порядке они ломаются,
[02:02:23.320 --> 02:02:25.320]  но, блин, дропаются.
[02:02:25.320 --> 02:02:29.320]  Там проблема в том, что в таком случае у тебя бы компилированность кода
[02:02:29.320 --> 02:02:31.320]  зависела бы от порядка полей.
[02:02:31.320 --> 02:02:33.320]  Что-то плохое, да?
[02:02:33.320 --> 02:02:35.320]  У тебя бы Lifetime-ы начали зависеть от этого.
[02:02:35.320 --> 02:02:39.320]  Я вроде как раз хочу, чтобы у меня Lifetime были вот какие-то...
[02:02:39.320 --> 02:02:45.320]  Чтобы они были достаточно долгими, значит они не могут как минимум как-то заломить...
[02:02:45.320 --> 02:02:51.320]  как перекликаться с Lifetime в объект, который дропает.
[02:02:51.320 --> 02:02:55.320]  Было бы прикольно, если бы ты в чате потом написал.
[02:02:55.320 --> 02:02:57.320]  Я не знаю.
[02:02:57.320 --> 02:02:59.320]  Просто вот как ты показывал вот эти...
[02:02:59.320 --> 02:03:03.320]  Как это мне называлось?
[02:03:03.320 --> 02:03:05.320]  Сейчас.
[02:03:05.320 --> 02:03:13.320]  Ты там ранее до лекции показал крышку.
[02:03:13.320 --> 02:03:17.320]  Что-то по поводу того, что Lifetime-параметры дженерика должны быть не меньше,
[02:03:17.320 --> 02:03:19.320]  чем Lifetime-объекты.
[02:03:19.320 --> 02:03:23.320]  Ты, наверное, хотел сказать, что Lifetime-параметры...
[02:03:23.320 --> 02:03:27.320]  Ну да, у нас Lifetime-ы ссылок должны быть не больше, чем Lifetime-объекты,
[02:03:27.320 --> 02:03:31.320]  но сам по себе Lifetime-объекты не должны быть больше,
[02:03:31.320 --> 02:03:33.320]  чем любой из Lifetime-ов.
[02:03:33.320 --> 02:03:35.320]  Да, я об этом вот.
[02:03:35.320 --> 02:03:37.320]  Я хотел бы так, чтобы вот это тут бы не помешало.
[02:03:37.320 --> 02:03:41.320]  Ну вообще самое простое решение данной проблемы это просто сказать,
[02:03:41.320 --> 02:03:49.320]  давайте мы потребуем, чтобы наш объект, который имплементирует дроп,
[02:03:49.320 --> 02:03:53.320]  строго переживал все Lifetime-ы, которые он имеет.
[02:03:53.320 --> 02:03:55.320]  То есть, например, если у нас ссылка на U8,
[02:03:55.320 --> 02:03:59.320]  в таком случае мы хотим строго пережить нашу ссылку.
[02:03:59.320 --> 02:04:01.320]  Ну точнее...
[02:04:01.320 --> 02:04:03.320]  Ссылка нас переживает.
[02:04:03.320 --> 02:04:05.320]  Да, строго чтобы пережила.
[02:04:05.320 --> 02:04:07.320]  Причем строго, чтобы не было одинаковых Lifetime-ов.
[02:04:07.320 --> 02:04:09.320]  До этого у нас все это время...
[02:04:09.320 --> 02:04:12.320]  Это важное отличие как раз от того, что я пытался описать.
[02:04:12.320 --> 02:04:14.320]  У нас там могло быть совпадение, а тут нет.
[02:04:14.320 --> 02:04:18.320]  Да, до этого мы всегда работали с таким вот...
[02:04:18.320 --> 02:04:21.320]  Ну вот, это самое простое решение.
[02:04:21.320 --> 02:04:25.320]  До этого мы лишь вот на такое вот смотрели,
[02:04:25.320 --> 02:04:31.320]  что если A было под типом B, в таком случае никто не мешал A и B совпадать.
[02:04:31.320 --> 02:04:34.320]  Сейчас у нас в дроп-чекере появилась такая проблемка с дропом,
[02:04:34.320 --> 02:04:38.320]  что если у нас дроп будет в неправильном порядке дропать,
[02:04:38.320 --> 02:04:40.320]  ну в каком-то, который вы не ожидаете,
[02:04:40.320 --> 02:04:44.320]  в таком случае у вас может быть доступ к неинтересированной памяти.
[02:04:44.320 --> 02:04:51.320]  Поэтому наш дроп требует того, чтобы мы все переживали свои зависимости.
[02:04:51.320 --> 02:04:53.320]  Можете обратиться.
[02:04:53.320 --> 02:04:54.320]  Куда?
[02:04:54.320 --> 02:04:56.320]  Ну, туда.
[02:04:56.320 --> 02:04:58.320]  Давай следующий случай.
[02:04:58.320 --> 02:05:00.320]  Сейчас.
[02:05:08.320 --> 02:05:16.320]  А у нас получается, что одно поле славится на другое поле.
[02:05:17.320 --> 02:05:18.320]  Да.
[02:05:30.320 --> 02:05:34.320]  Ну вообще ссылку на самого себя безобщенно сделать вообще не получится.
[02:05:34.320 --> 02:05:38.320]  Во-первых, потому что было бы не безопасно, вы бы смогли, например,
[02:05:38.320 --> 02:05:40.320]  мовнуть объект и все сломать.
[02:05:40.320 --> 02:05:44.320]  Плюс тут даже не в общем дело в том, что вы на бокс указываете.
[02:05:44.320 --> 02:05:46.320]  Бокс на кучу.
[02:05:46.320 --> 02:05:49.320]  Если бы там был просто УБ-8, то вы бы не смогли взять ссылку.
[02:05:49.320 --> 02:05:52.320]  Опять же, мов сделали, и у вас плайма у вас ссылка.
[02:05:55.320 --> 02:05:57.320]  Это тут понятно?
[02:06:02.320 --> 02:06:05.320]  Вратите внимание, что мы никогда не...
[02:06:05.320 --> 02:06:11.320]  Здесь мы никакие поля в инспекторе, от которых мы действительно зависим lifetime объекта,
[02:06:11.320 --> 02:06:13.320]  мы не трогаем.
[02:06:13.320 --> 02:06:15.320]  Но при этом все равно наш код не компилируется.
[02:06:15.320 --> 02:06:23.320]  То есть мы не трогаем наш штрих У-8, но при этом все равно РАСТ не дает.
[02:06:25.320 --> 02:06:29.320]  Он строго требует, чтобы мы переживали все lifetime параметры.
[02:06:29.320 --> 02:06:31.320]  Ну ладно.
[02:06:33.320 --> 02:06:37.320]  Ну и вот еще один есть такой примерчик.
[02:06:37.320 --> 02:06:46.320]  Даже несмотря на то, что мы не трогаем данные внутри, все равно не компилируется.
[02:06:50.320 --> 02:06:52.320]  Но здесь конкретно уже тай тип.
[02:06:52.320 --> 02:06:55.320]  Кажется, он выводится как ссылка.
[02:06:55.320 --> 02:06:57.320]  Да.
[02:06:57.320 --> 02:07:00.320]  И тем самым не безосыграняется, поскольку у вас как-то...
[02:07:00.320 --> 02:07:01.320]  Да, да.
[02:07:01.320 --> 02:07:03.320]  Он обессахарится в какую-то ссылку.
[02:07:10.320 --> 02:07:13.320]  Плюс ко всему, на первой лекции я вам такую вот показываю.
[02:07:13.320 --> 02:07:15.320]  Возможно, вы помните.
[02:07:15.320 --> 02:07:18.320]  Я вам тогда сказал, на самом деле Вектор в РАСТе выглядит не так.
[02:07:18.320 --> 02:07:20.320]  Чуть иначе.
[02:07:20.320 --> 02:07:22.320]  Тут такое дело.
[02:07:22.320 --> 02:07:27.320]  Из-за дроп-чекера он будет считать, что мы никакими значениями t не владеем.
[02:07:27.320 --> 02:07:29.320]  У нас есть какой-то указатель, мы указатели.
[02:07:29.320 --> 02:07:30.320]  А владеть не владеем никакими.
[02:07:30.320 --> 02:07:32.320]  Значит, не дропаем никакие.
[02:07:32.320 --> 02:07:34.320]  Значит, мы не зависим от lifetime в t.
[02:07:38.320 --> 02:07:40.320]  Потому что у нас просто указатели.
[02:07:41.320 --> 02:07:43.320]  А чтобы у нас это все работало через указатель,
[02:07:43.320 --> 02:07:46.320]  опять же unsaved, мы тут с какой-то проблемой сталкиваемся,
[02:07:46.320 --> 02:07:49.320]  нам нужно добавить такую штуку, которая называется PhantomData.
[02:07:49.320 --> 02:07:53.320]  PhantomData притворяется, что оно содержит тип, который у него есть.
[02:07:53.320 --> 02:07:56.320]  На самом деле, это ZST тип, вот такой компиляторный.
[02:07:58.320 --> 02:08:00.320]  Вылез вот так вот.
[02:08:00.320 --> 02:08:03.320]  На самом деле, не костыли, но еще иногда нужно даже не unsaved,
[02:08:03.320 --> 02:08:06.320]  в том числе в меню frunk задачи.
[02:08:07.320 --> 02:08:09.320]  Какая правильная читать.
[02:08:09.320 --> 02:08:11.320]  Как мы выяснили на немецком.
[02:08:11.320 --> 02:08:13.320]  Так.
[02:08:17.320 --> 02:08:20.320]  Не увеличивается, потому что ZST, PhantomData.
[02:08:20.320 --> 02:08:23.320]  Он только притворяется, что он содержит t.
[02:08:23.320 --> 02:08:25.320]  То есть компилятору кажется, ага,
[02:08:25.320 --> 02:08:28.320]  ну теперь ты, наверное, где-то тут векторе t содержишь,
[02:08:28.320 --> 02:08:30.320]  но на самом деле это не так.
[02:08:32.320 --> 02:08:36.320]  Да, ну вот это ограничение системов типа RAST.
[02:08:36.320 --> 02:08:40.320]  Как я говорил, у нас какое-то число правильных программ теперь запрещается.
[02:08:40.320 --> 02:08:44.320]  Ну, так же, как и запрещается какое-то огромное множество программ,
[02:08:44.320 --> 02:08:46.320]  которые неправильные.
[02:08:46.320 --> 02:08:52.320]  И вот в том числе программы, которые были правильными,
[02:08:52.320 --> 02:08:55.320]  в общем, ну вот мы их запретили только что.
[02:08:56.320 --> 02:08:58.320]  Из-за, например, DropChecker.
[02:08:58.320 --> 02:09:01.320]  Это такое логическое ограничение системы типов.
[02:09:01.320 --> 02:09:03.320]  Это все чего-то стоит, скажем так.
[02:09:03.320 --> 02:09:05.320]  Не бесплатно.
[02:09:05.320 --> 02:09:07.320]  Вот спина E в RAST и нет.
[02:09:07.320 --> 02:09:09.320]  Прекрасно.
[02:09:09.320 --> 02:09:12.320]  Вот это, не знаю, это выглядит как не лучше.
[02:09:12.320 --> 02:09:17.320]  Не знаю, вот сейчас это самая непонятная лекция из всех на самом деле.
[02:09:17.320 --> 02:09:20.320]  После этого ничего сложного не будет.
[02:09:20.320 --> 02:09:23.320]  Это ничего не сложного не будет, вы все поймете.
[02:09:23.320 --> 02:09:26.320]  Это все связано с тем, что вам приходится писать unsafe code.
[02:09:26.320 --> 02:09:28.320]  Вот опять указатель какой-то возникает.
[02:09:28.320 --> 02:09:33.320]  И если бы не было указателей, то вам бы не пришлось, например, PhantomData здесь вводить.
[02:09:34.320 --> 02:09:37.320]  В следующий раз мы поговорим сейчас про concurrency.
[02:09:37.320 --> 02:09:41.320]  В следующий раз мы спросим про параллельность unsafe и concurrency.
[02:09:41.320 --> 02:09:43.320]  Ну там как пойдет.
[02:09:43.320 --> 02:09:46.320]  То есть вы бы пришли и все две параллельности по попросу брать.
[02:09:46.320 --> 02:09:48.320]  Посмотрим.
[02:09:50.320 --> 02:09:52.320]  Так, ну тут понятно, да.
[02:09:52.320 --> 02:09:56.320]  PhantomData это такое, притворяющееся, что владеет типом.
[02:09:58.320 --> 02:10:00.320]  Теперь дошли до конкурса.
[02:10:00.320 --> 02:10:02.320]  Конклужин.
[02:10:02.320 --> 02:10:05.320]  Конклужин, кстати, сколько он занимает?
[02:10:05.320 --> 02:10:07.320]  О, целых 14 слайдов.
[02:10:07.320 --> 02:10:09.320]  Самое важное.
[02:10:09.320 --> 02:10:11.320]  Так.
[02:10:11.320 --> 02:10:14.320]  Смотрите, давайте мы подытожим все то, что мы узнали.
[02:10:14.320 --> 02:10:17.320]  Кстати, по дроп-чекеру у вас уже нет вопросов?
[02:10:17.320 --> 02:10:21.320]  Такой вынужденный костыль, связанный с тем, что у нас есть дропы,
[02:10:21.320 --> 02:10:24.320]  с тем, что у нас есть лайфтаймы, которые могут быть одинаковыми.
[02:10:24.320 --> 02:10:28.320]  Нам приходится требовать того, чтобы мы переживали все наши зависимости,
[02:10:28.320 --> 02:10:30.320]  строго переживали.
[02:10:30.320 --> 02:10:34.320]  Возможно, были равны и по типу бегали.
[02:10:34.320 --> 02:10:42.320]  Во-первых, ключевая идея системы типа фраз-то это проверять lifetime объект.
[02:10:42.320 --> 02:10:48.320]  Мы изводим такое понятие как lifetime, это какая-то часть кода расовского.
[02:10:48.320 --> 02:10:54.320]  И мы трекаем, что мы действительно, например, ссылки наши не переживают.
[02:10:54.320 --> 02:10:56.320]  Есть lifetime.
[02:10:56.320 --> 02:10:58.320]  Лайфтаймы – это вложенные вещи.
[02:10:58.320 --> 02:11:01.320]  Я, опять же, оставлю это без пруфа.
[02:11:01.320 --> 02:11:04.320]  Но скажу, что, во-первых, формальные пруфы нам не нужны,
[02:11:04.320 --> 02:11:08.320]  но скажу, что нам нужно только лишь трекать локальный lifetime.
[02:11:08.320 --> 02:11:10.320]  Нам этого хватает.
[02:11:10.320 --> 02:11:15.320]  То есть мы где-то внутри функции посоздавались какие-то объекты.
[02:11:18.320 --> 02:11:20.320]  Ну и все, в принципе.
[02:11:20.320 --> 02:11:23.320]  И дальше нам нужно только generic definition всякие.
[02:11:23.320 --> 02:11:25.320]  То, как у нас объявляются структуры,
[02:11:25.320 --> 02:11:28.320]  енамы, функции, имплы.
[02:11:28.320 --> 02:11:31.320]  Это для нас самое важное.
[02:11:31.320 --> 02:11:35.320]  Мы за ними просто следим, что у нас точно объекты, которые попадают,
[02:11:35.320 --> 02:11:37.320]  они удовлетворяют всем свойствам,
[02:11:37.320 --> 02:11:40.320]  и соответственно у нас получается сейфти в сумме.
[02:11:40.320 --> 02:11:43.320]  Каким-то несложным образом.
[02:11:45.320 --> 02:11:50.320]  У каждого generic definition могут быть разные lifetime и разные генеричные типы.
[02:11:51.320 --> 02:11:58.320]  Например, у нас может быть такой, что у нас есть штрих A и T.
[02:11:58.320 --> 02:12:01.320]  Они имеют какие-то разные lifetimes.
[02:12:01.320 --> 02:12:04.320]  Когда у нас 2D generic.
[02:12:06.320 --> 02:12:08.320]  Потом.
[02:12:08.320 --> 02:12:10.320]  По умолчанию у нас, конечно, нет lifetime параметров,
[02:12:10.320 --> 02:12:15.320]  когда мы создаем структуру, в которой U32, потом вектор и так далее.
[02:12:15.320 --> 02:12:18.320]  У нас по умолчанию нет никаких lifetime параметров.
[02:12:18.320 --> 02:12:22.320]  Они обычно появляются именно в ссылках.
[02:12:22.320 --> 02:12:25.320]  И означает, что я не могу там пережить этот lifetime.
[02:12:25.320 --> 02:12:28.320]  В основном, эта идея распространяется на ссылке.
[02:12:28.320 --> 02:12:30.320]  Subtaping существует для ссылок.
[02:12:30.320 --> 02:12:34.320]  Variants, соответственно, тоже преимущественно для ссылок.
[02:12:34.320 --> 02:12:36.320]  Хотя не только для них.
[02:12:36.320 --> 02:12:40.320]  Ну или могут попасться в quantum data.
[02:12:42.320 --> 02:12:46.320]  Это все было про то, где у нас встречаются вообще lifetime.
[02:12:46.320 --> 02:12:50.320]  То есть у нас общая идея просто трекаем lifetimes.
[02:12:50.320 --> 02:12:54.320]  И lifetimes встречаются в всяких generic definitions.
[02:12:59.320 --> 02:13:02.320]  Когда вы пишете вот такую примерно штуку.
[02:13:02.320 --> 02:13:06.320]  Это какая-то произвольная функция, которая выдумалась головой.
[02:13:06.320 --> 02:13:09.320]  Вот вы, например, написали.
[02:13:09.320 --> 02:13:11.320]  У вас есть lifetime A, T и U.
[02:13:11.320 --> 02:13:13.320]  Написали T и T.
[02:13:13.320 --> 02:13:16.320]  Интератор, в который переходит T.
[02:13:16.320 --> 02:13:19.320]  Обязательный итератор с айтомом U.
[02:13:19.320 --> 02:13:22.320]  А этот U, в свою очередь, клоун.
[02:13:22.320 --> 02:13:24.320]  И живет как минимум A.
[02:13:24.320 --> 02:13:28.320]  Тем самым вы задали множество значений, которые подходят к этой функции.
[02:13:28.320 --> 02:13:31.320]  То, что разделает, он проверяет.
[02:13:33.320 --> 02:13:36.320]  Что типы, которые мы ввели, корректны.
[02:13:39.320 --> 02:13:42.320]  Мы это делаем, конечно же, в соответствии с variants.
[02:13:42.320 --> 02:13:45.320]  Если у нас есть какие-то ссылки.
[02:13:45.320 --> 02:13:48.320]  И они не точно такие, как требует функция.
[02:13:48.320 --> 02:13:50.320]  Мы можем их привести.
[02:13:50.320 --> 02:13:52.320]  Но в соответствии с их variants.
[02:13:52.320 --> 02:13:54.320]  Для того, чтобы все было безопасно.
[02:13:54.320 --> 02:13:57.320]  Это тоже вещь, которая выводится в формальной теории.
[02:13:57.320 --> 02:14:00.320]  В принципе, все, что я сказал, это может быть доказано.
[02:14:00.320 --> 02:14:04.320]  Что этого хватает для того, чтобы получить memory-safe приложение.
[02:14:04.320 --> 02:14:07.320]  Конечно, там есть всякие еще нюансы.
[02:14:07.320 --> 02:14:10.320]  Про которые, например, мы еще скажем.
[02:14:10.320 --> 02:14:13.320]  В принципе, этого всего хватает.
[02:14:16.320 --> 02:14:19.320]  Когда, например, просто такая ремарочка.
[02:14:19.320 --> 02:14:22.320]  Например, импл блоки. Они у вас могут пересекаться.
[02:14:23.320 --> 02:14:25.320]  Помните, наверное, что вы там можете написать.
[02:14:25.320 --> 02:14:27.320]  Что у вас один импл блок, где T это default.
[02:14:27.320 --> 02:14:30.320]  Потом второй импл блок, где у вас T это клоун.
[02:14:30.320 --> 02:14:32.320]  Может быть такой у вас.
[02:14:32.320 --> 02:14:34.320]  По-моему, это вторая лекция или третья.
[02:14:36.320 --> 02:14:37.320]  Они могут пересекаться.
[02:14:37.320 --> 02:14:40.320]  Может быть какое-то наименование, которое одинаково.
[02:14:41.320 --> 02:14:43.320]  Просто-напросто.
[02:14:44.320 --> 02:14:46.320]  Ну, функция, которая с одинаковым именем.
[02:14:46.320 --> 02:14:48.320]  Как раз проверяет это пересечение.
[02:14:48.320 --> 02:14:50.320]  Он просто смотрит, ага.
[02:14:50.320 --> 02:14:52.320]  Мог ли эти имплы пересекаться?
[02:14:52.320 --> 02:14:55.320]  Пересекаются ли множество значений, которые принимают?
[02:14:55.320 --> 02:14:59.320]  Мы как раз здесь делали какое-то множество значений.
[02:14:59.320 --> 02:15:01.320]  И мы пытаемся...
[02:15:01.320 --> 02:15:03.320]  Ну, раз проверяет, он проверяет.
[02:15:03.320 --> 02:15:06.320]  Пересекается ли множество значений хотя бы на одном каком-то типе.
[02:15:08.320 --> 02:15:11.320]  Поэтому он может это без инстанциализации как в плюсах.
[02:15:11.320 --> 02:15:13.320]  Ответить на этот вопрос.
[02:15:15.320 --> 02:15:16.320]  Вот.
[02:15:16.320 --> 02:15:18.320]  Так же, как мы выяснили.
[02:15:18.320 --> 02:15:26.320]  Если у нас есть деструкторы, то, к сожалению, нам не хватает просто быть под типом по lifetime.
[02:15:26.320 --> 02:15:30.320]  Нам хочется строго переживать все параметры нашего типа.
[02:15:32.320 --> 02:15:35.320]  Ну, иначе у нас получится memory safety в дропе.
[02:15:38.320 --> 02:15:39.320]  Так.
[02:15:39.320 --> 02:15:41.320]  Ну, и вот это вот очень важный момент.
[02:15:42.320 --> 02:15:44.320]  Мы писали какие-то lifetimes.
[02:15:44.320 --> 02:15:47.320]  Например, написали вот такую функцию опять же.
[02:15:48.320 --> 02:15:51.320]  Если у нас будут разные ашки,
[02:15:51.320 --> 02:15:55.320]  то это не значит, что у нас в бинарном коде, который компилируется с компилятором,
[02:15:55.320 --> 02:15:57.320]  будут разные инстанции функции example.
[02:15:57.320 --> 02:15:59.320]  Абсолютно одинаковые.
[02:15:59.320 --> 02:16:03.320]  На самом деле Rust, когда проверил семантику вашего языка, он lifetime стирает.
[02:16:03.320 --> 02:16:05.320]  Они дальше не важны.
[02:16:05.320 --> 02:16:09.320]  То есть, он проверил, что ваша программа корректна, там нет aliasing,
[02:16:09.320 --> 02:16:12.320]  нет use after free и все такое за счет lifetime.
[02:16:12.320 --> 02:16:14.320]  После этого просто убрал, выкинул их.
[02:16:14.320 --> 02:16:16.320]  Остается это важно.
[02:16:16.320 --> 02:16:18.320]  Ну, это, в общем, не важно.
[02:16:18.320 --> 02:16:22.320]  И для генерации кода достаточно того, что осталось.
[02:16:22.320 --> 02:16:24.320]  То есть типов уже непосредственных.
[02:16:24.320 --> 02:16:26.320]  Это исключительно семантика языка.
[02:16:31.320 --> 02:16:32.320]  Да.
[02:16:32.320 --> 02:16:36.320]  Ну и последний еще момент, который я оставлю только лишь маленькой ремарочкой.
[02:16:36.320 --> 02:16:40.320]  Несмотря на то, что там есть небольшая глава, например, в Станом и Коне про это,
[02:16:40.320 --> 02:16:43.320]  там ничего сложного, в принципе, нет.
[02:16:43.320 --> 02:16:48.320]  Например, вы не можете в Rust спокойно приводить типа друг к другу.
[02:16:48.320 --> 02:16:51.320]  У вас, например, в плюсах вы можете void к int привести,
[02:16:51.320 --> 02:16:54.320]  а у вас void там к nint, нифига.
[02:16:54.320 --> 02:16:56.320]  И вот вы получили membrane safety.
[02:16:56.320 --> 02:17:00.320]  Просто потому что вы что-то не проверили, сделали неправильный tab-question.
[02:17:00.320 --> 02:17:02.320]  Ну, это не очень удачный пример.
[02:17:02.320 --> 02:17:04.320]  Ну, это банальный пример.
[02:17:04.320 --> 02:17:08.320]  Просто как бы, наверное, стоит привести какой-нибудь такой полный тип.
[02:17:08.320 --> 02:17:10.320]  Прям структуру какую-нибудь.
[02:17:10.320 --> 02:17:12.320]  А хотя бы шорты int этого уже было.
[02:17:14.320 --> 02:17:16.320]  Ну, суть ясна, я думаю, да.
[02:17:16.320 --> 02:17:17.320]  В Rust.
[02:17:17.320 --> 02:17:21.320]  Не совсем, просто потому что звездочка слишком особая фигня,
[02:17:21.320 --> 02:17:23.320]  которая используется слишком часто.
[02:17:23.320 --> 02:17:24.320]  Ладно, наверное...
[02:17:24.320 --> 02:17:26.320]  Все нормально как раз.
[02:17:26.320 --> 02:17:28.320]  То есть это я красто привык,
[02:17:28.320 --> 02:17:30.320]  что звездочку как части по плюсах нет.
[02:17:30.320 --> 02:17:32.320]  Это про это?
[02:17:32.320 --> 02:17:33.320]  Ну, я про...
[02:17:33.320 --> 02:17:35.320]  Нет, здесь звездочка, конечно, тоже здесь нет.
[02:17:35.320 --> 02:17:38.320]  Проблема в том, что void звездочка, это вот как раз местные они.
[02:17:38.320 --> 02:17:40.320]  Ну, сихные они, так сказать.
[02:17:40.320 --> 02:17:42.320]  А, ты все понял о чем-то.
[02:17:42.320 --> 02:17:43.320]  Был бы два пола.
[02:17:43.320 --> 02:17:44.320]  Да, void это просто они, да.
[02:17:44.320 --> 02:17:47.320]  Здесь можно было бы шорт написать, вместо void, да и получилось бы...
[02:17:47.320 --> 02:17:49.320]  Точно скалявал бы, да.
[02:17:49.320 --> 02:17:53.320]  Или, например, если бы у нас здесь был, не знаю, int32,
[02:17:53.320 --> 02:17:55.320]  а здесь int64t.
[02:17:55.320 --> 02:17:57.320]  Не безопасно приводить их друг к другу.
[02:17:57.320 --> 02:18:00.320]  Rust позволяет только некоторые типы коэрсии.
[02:18:00.320 --> 02:18:02.320]  Это можно прочитать.
[02:18:02.320 --> 02:18:04.320]  Насколько я помню, у меня даже должно быть.
[02:18:04.320 --> 02:18:08.320]  Некоторые приведения типов,
[02:18:08.320 --> 02:18:10.320]  например, u32q64,
[02:18:10.320 --> 02:18:12.320]  можно спокойно привести.
[02:18:12.320 --> 02:18:14.320]  Там не будет никаких проблем.
[02:18:14.320 --> 02:18:16.320]  Тип месяца и так далее.
[02:18:16.320 --> 02:18:18.320]  Там несложный список.
[02:18:18.320 --> 02:18:20.320]  Я думаю, вы легко разберетесь.
[02:18:21.320 --> 02:18:23.320]  Обсуждать его, я думаю, мало смысла.
[02:18:23.320 --> 02:18:25.320]  Просто что Rust не дает вам еще
[02:18:25.320 --> 02:18:27.320]  переинтерпретировать байты
[02:18:27.320 --> 02:18:29.320]  просто так, по-другому.
[02:18:29.320 --> 02:18:31.320]  Иначе тоже могли бы взять,
[02:18:31.320 --> 02:18:33.320]  переинтерпретировать тип по-другому,
[02:18:33.320 --> 02:18:35.320]  и у Rust все опять бы сломалось.
[02:18:36.320 --> 02:18:38.320]  Его хрупкая система типов
[02:18:38.320 --> 02:18:40.320]  может сломаться в любой момент,
[02:18:40.320 --> 02:18:42.320]  особенно когда вы пользуете unsafe.
[02:18:42.320 --> 02:18:44.320]  Ну ладно, она не ломается просто так,
[02:18:44.320 --> 02:18:46.320]  только если вы unsafe пользуетесь.
[02:18:46.320 --> 02:18:48.320]  Ну вообще, знаете.
[02:18:48.320 --> 02:18:50.320]  Кажется, это все.
[02:18:50.320 --> 02:18:52.320]  Да, это все.
[02:18:52.320 --> 02:18:54.320]  Понятно ли в общих чертах,
[02:18:54.320 --> 02:18:56.320]  устроенном mrsafety.
[02:18:58.320 --> 02:19:00.320]  Просто lifetime.
[02:19:00.320 --> 02:19:02.320]  И все.
[02:19:02.320 --> 02:19:04.320]  И variance.
[02:19:06.320 --> 02:19:08.320]  А еще дроп-чекеры и typecatch.
[02:19:12.320 --> 02:19:14.320]  Кажется, все одно.
