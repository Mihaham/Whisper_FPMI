[00:00.000 --> 00:13.000]  Теперь можно перейти к структуре данных из всей суффиксной приады.
[00:13.000 --> 00:18.000]  Мы, конечно, не сегодня будем говорить про дерево тандемных повторов,
[00:18.000 --> 00:21.000]  потому что это не суффиксная структура.
[00:21.000 --> 00:24.000]  Ну а красивая она или нет, это уже другая вопрос.
[00:24.000 --> 00:32.000]  Итак, как говорится, поиск под структур в заданной строке в онлайне способ номер три.
[00:32.000 --> 00:40.000]  Способ номер три на этот раз будет такой.
[00:40.000 --> 00:44.000]  Ну естественно, так как у вас есть формалки, то вам не надо объяснять, что такое автомат в принципе.
[00:44.000 --> 00:48.000]  Чем отличается детерминированный автомат от недетерминированного?
[00:48.000 --> 00:51.000]  Отлично.
[00:51.000 --> 01:01.000]  Ну вот, тогда можно сразу сформулировать, что такое вообще суффиксный автомат для строки.
[01:02.000 --> 01:09.000]  Тогда бы просто замгновенно пишем, что определение суффиксный автомат.
[01:20.000 --> 01:25.000]  Или его еще называют down, вот s.
[01:25.000 --> 01:30.000]  Ну или там с индексом s.
[01:30.000 --> 01:41.000]  Ну короче, расшифровывается это как you're directed at cyclic внезапно word graph.
[01:41.000 --> 01:48.000]  Пока не в оригинальной статье, почему-то автор его вот таким вот образом называл.
[01:48.000 --> 02:11.000]  Так вот, это минимальный детерминированный конечный автомат, принимающий,
[02:11.000 --> 02:36.000]  ну давайте уж не будем тут уже мелочиться, надо экономить на словах все суффиксы строки s и только их.
[02:36.000 --> 02:41.000]  Можно тогда сформулировать принимающий язык всех суффиксов строки s.
[02:41.000 --> 02:44.000]  Можно и так, да.
[02:44.000 --> 02:47.000]  А можно и так.
[02:47.000 --> 02:55.000]  Да, действительно, мы будем говорить языка туда.
[02:55.000 --> 03:00.000]  То есть в общем-то вот идея, ну в чем собственно идея?
[03:00.000 --> 03:05.000]  Ну придумать просто какой-нибудь автомат, который принимает все суффиксы строки s.
[03:05.000 --> 03:07.000]  В общем-то не сильно сложно.
[03:07.000 --> 03:09.000]  Может чего?
[03:09.000 --> 03:11.000]  Детерминированный.
[03:11.000 --> 03:13.000]  Ну ладно.
[03:13.000 --> 03:17.000]  Ну как придумать просто какой-нибудь автомат детерминированный, который принимает суффиксы?
[03:17.000 --> 03:19.000]  Тупо построить борь.
[03:19.000 --> 03:24.000]  Да мало кто знает, но борь это тоже детерминированный конечный автомат.
[03:24.000 --> 03:28.000]  Правда я бы не самый оптимальный.
[03:28.000 --> 03:30.000]  Почему?
[03:30.000 --> 03:34.000]  Да просто потому, что если этот борь нарисовать, например,
[03:34.000 --> 03:40.000]  ну там, то есть ну обычно там вот, ну там суффиксный борь у нас вот как-то вот так вот будет выглядеть.
[03:40.000 --> 03:42.000]  Может вот так, вот так, вот так вот еще.
[03:42.000 --> 03:44.000]  Ну а сразу оптимизация.
[03:44.000 --> 03:49.000]  А давайте-ка вот эти все листы объединим, скажем, в одну вершину.
[03:49.000 --> 03:53.000]  Вот. Уже стало вершинней.
[03:53.000 --> 03:55.000]  Оп.
[03:55.000 --> 03:57.000]  И соответственно вот.
[03:57.000 --> 03:59.000]  Вот какая-то такая красота, да?
[03:59.000 --> 04:01.000]  Вот.
[04:01.000 --> 04:06.000]  Ну а там, скорее всего, еще и вот эти первые символы-то можно пообъединять и так далее все.
[04:06.000 --> 04:08.000]  Ну вот.
[04:08.000 --> 04:14.000]  Ну вообще говоря, а что такое минимальный детерминированный конечный автомат вообще?
[04:14.000 --> 04:16.000]  Что это такое вообще?
[04:20.000 --> 04:25.000]  Ну по сути у него каждая вершина — это классиколитность слов.
[04:25.000 --> 04:27.000]  Классиколитность?
[04:27.000 --> 04:31.000]  Да, где эквалидность задается как то, что если дописать какое-то слово,
[04:31.000 --> 04:35.000]  оно либо ли обои будет лежать в языке, либо не будет.
[04:37.000 --> 04:40.000]  Так. Какой-то классиколитность.
[04:41.000 --> 04:45.000]  А почему он за это? Так это разве будет не в любом?
[04:45.000 --> 04:47.000]  В смысле?
[04:47.000 --> 04:51.000]  Ну минимально, минимально, ну еще и бэдэк крайненько такая.
[04:51.000 --> 04:54.000]  Его вершина, по сути, это классиколитность.
[04:54.000 --> 04:56.000]  Какие-то вершины эквивалентные.
[04:56.000 --> 04:59.000]  Ну да. А что означает эквивалентная?
[04:59.000 --> 05:03.000]  Ну вот, не знаю, например, слова В — эквивалентные.
[05:03.000 --> 05:08.000]  Если для любого слова W, ВВ и УВ либо одновременно в языке, либо одновременно не в языке.
[05:08.000 --> 05:13.000]  Ну да. Ну да, хотелось бы как-бы исполковать человеческий язык.
[05:14.000 --> 05:17.000]  Ну хотя, ладно, человеческость тут, конечно, понятие относительное.
[05:17.000 --> 05:19.000]  Ну да, действительно.
[05:19.000 --> 05:22.000]  То есть основная ключевая идея минимальностью заключается в том,
[05:22.000 --> 05:25.000]  что для каждой вершины можно определить ее язык.
[05:25.000 --> 05:31.000]  То есть, по сути, по каким словам из этой вершины можно дойти детерминальных вершин?
[05:31.000 --> 05:37.000]  И можно действительно заметить, что если оказывается у двух вершин языки тупо совпадают,
[05:37.000 --> 05:39.000]  то что тогда можно сделать?
[05:39.000 --> 05:43.000]  Тогда можно просто эти две вершины обедить в одну и никто не пострадает.
[05:44.000 --> 05:48.000]  То есть, по большому счету, необходимым условием минимальности является то,
[05:48.000 --> 05:53.000]  что в минимальном детерминированном конечном автомате языки всех вершин попарно различны.
[05:54.000 --> 05:58.000]  Правда, отсюда же можно аккуратно сделать вывод, что в минимальном автомате,
[05:58.000 --> 06:02.000]  в общем, минимальный автомат в общем-то заточен сюда из амортизма единственный.
[06:03.000 --> 06:09.000]  Ну, по весьма банальной причине, потому что, в общем-то, необходимые языки банально порождаются.
[06:10.000 --> 06:16.000]  Ну то есть, действительно, можно даже попробовать построить автомат для какой-нибудь строки.
[06:16.000 --> 06:19.000]  Ну вот, например, для какой?
[06:20.000 --> 06:22.000]  Чтоб, ну так, чтобы интересно было.
[06:25.000 --> 06:27.000]  А вот давайте я его для абабасы построю.
[06:28.000 --> 06:31.000]  О, интересно, получится то, что я хочу.
[06:33.000 --> 06:35.000]  Вот как построить суффиксный автомат в принципе?
[06:36.000 --> 06:37.000]  Чтобы сразу минимальный.
[06:37.000 --> 06:40.000]  Ну, во-первых, начнем с того, что у него должна быть стартовая вершина,
[06:41.000 --> 06:43.000]  у которой будет язык.
[06:43.000 --> 06:44.000]  Язык.
[06:45.000 --> 06:48.000]  Ну или там, не знаю, как он называется.
[06:50.000 --> 06:55.000]  Вот так, не знаю, может он там человек автоматов, язык вершины как-то по-другому называется.
[06:59.000 --> 07:02.000]  Ну, по каким словам можно из вершины дойти на терминальный?
[07:04.000 --> 07:05.000]  Как это называется?
[07:06.000 --> 07:08.000]  Вот было множество вершин, которые недостижимы.
[07:09.000 --> 07:10.000]  Нет, это другое.
[07:10.000 --> 07:14.000]  Это как-то обозначалось, не помню какого термина специально.
[07:15.000 --> 07:16.000]  Ну ладно, будем называть это язык вершины.
[07:17.000 --> 07:18.000]  Какой язык в этой вершине?
[07:19.000 --> 07:20.000]  Ну так и пишем.
[07:20.000 --> 07:37.000]  Эпсилон, А, СА, АЦА, БАЦА, АВАЦА, БАБАЦА и АБАБАЦА.
[07:40.000 --> 07:41.000]  АБАБАЦА это не глагол, да.
[07:42.000 --> 07:43.000]  Вот.
[07:44.000 --> 07:46.000]  Вот, ну что можно сказать?
[07:47.000 --> 07:52.000]  Эпсилон показывает, что вершина терминальная.
[07:53.000 --> 08:01.000]  И мы видим, что из этой вершины обязательно должны быть переходы по буквам А, Б и С, а других переходов быть не должно.
[08:03.000 --> 08:04.000]  Так, ну давайте нарисуем.
[08:05.000 --> 08:06.000]  Куда должен быть переход по букве А?
[08:07.000 --> 08:13.000]  По букве А должен быть переход в состояние, из которого по терминальным вершинам можно зайти в какие слова?
[08:13.000 --> 08:20.000]  Ну, во все слова, которые тут начинались в буквы А, только без этой первой буквы А.
[08:21.000 --> 08:29.000]  Получается вот, из А получаем Эпсилон, из А получаем СА, тут получаем БАЦА и тут получаем БАБАЦА.
[08:30.000 --> 08:32.000]  Так, неплохо.
[08:33.000 --> 08:35.000]  Ну ладно, будем работать BFS.
[08:36.000 --> 08:39.000]  Значит, еще тут должен быть переход по Б.
[08:40.000 --> 08:41.000]  Оп.
[08:41.000 --> 08:42.000]  Оп.
[08:43.000 --> 08:45.000]  Так, так, так, так, так.
[08:46.000 --> 08:47.000]  Значит, это у нас БАЦА.
[08:48.000 --> 08:49.000]  БАЦА и БАБАЦА.
[08:50.000 --> 08:58.000]  Значит, тут, соответственно, получается язык этого состояния АЦА и БАЦА получается.
[09:01.000 --> 09:02.000]  Вот.
[09:02.000 --> 09:12.000]  И буква С, которая нас отправляет, собственно, в язык, состоящий из слова А.
[09:13.000 --> 09:19.000]  Обе эти вершины не терминальные, потому что в их языках нет Эпсилона, а вот тут и есть, поэтому тут терминальный.
[09:21.000 --> 09:22.000]  Так.
[09:23.000 --> 09:25.000]  Так, идем дальше.
[09:26.000 --> 09:27.000]  Так, теперь смотрите.
[09:27.000 --> 09:32.000]  Как-то тут сразу все начинает едва ли не схлопываться.
[09:33.000 --> 09:43.000]  Потому что, смотрите, если мы пойдем отсюда по букве С, то мы перейдем в состояние, у которого язык это слово А.
[09:44.000 --> 09:45.000]  Оно же есть.
[09:46.000 --> 09:47.000]  Да, такой язык у нас есть.
[09:48.000 --> 09:49.000]  Вот он.
[09:50.000 --> 09:52.000]  Так, что еще?
[09:53.000 --> 09:54.000]  А если перейти по...
[09:55.000 --> 09:56.000]  Буква С.
[09:57.000 --> 09:58.000]  Да, да.
[09:59.000 --> 10:03.000]  А еще есть переход по букве Б, которая ведет нас вот в это состояние.
[10:04.000 --> 10:05.000]  Опа.
[10:06.000 --> 10:07.000]  Так, не понял.
[10:08.000 --> 10:10.000]  Так, что я где забыл?
[10:11.000 --> 10:12.000]  Ничего.
[10:13.000 --> 10:14.000]  Прошли первые буквы.
[10:15.000 --> 10:19.000]  А, да, все нормально, я ничего не забыл.
[10:20.000 --> 10:24.000]  Просто тут еще два состояния остались, с ними все в порядке.
[10:24.000 --> 10:25.000]  Так.
[10:26.000 --> 10:27.000]  Ну, БФС так БФС.
[10:28.000 --> 10:30.000]  Так, ну отсюда у нас есть переход.
[10:31.000 --> 10:32.000]  Какой?
[10:33.000 --> 10:34.000]  Ну, здесь так.
[10:35.000 --> 10:37.000]  Если рисовать планарный граф, то получится так.
[10:38.000 --> 10:39.000]  Можно здесь нарисовать переход по букве С.
[10:40.000 --> 10:41.000]  Нет.
[10:42.000 --> 10:43.000]  Ну, точнее так.
[10:44.000 --> 10:45.000]  Тут пока вообще один переход есть по букве А.
[10:46.000 --> 10:47.000]  И тут получается какой язык?
[10:48.000 --> 10:50.000]  Ца и Бац.
[10:51.000 --> 10:52.000]  Так.
[10:53.000 --> 10:56.000]  Ну, здесь замечаем, что по букве С мы переходим автоматически сюда.
[10:57.000 --> 11:00.000]  А по букве Б вот тут уже становится интереснее.
[11:01.000 --> 11:04.000]  Тут, оказывается, язык Аца.
[11:05.000 --> 11:06.000]  Не оттуда.
[11:07.000 --> 11:08.000]  А, не оттуда.
[11:09.000 --> 11:10.000]  Ну ладно, уйдите отсюда.
[11:11.000 --> 11:12.000]  Ага.
[11:13.000 --> 11:14.000]  Так, ладно.
[11:15.000 --> 11:16.000]  Значит, смотри.
[11:17.000 --> 11:18.000]  Б.
[11:19.000 --> 11:20.000]  Значит, тут у нас переход.
[11:21.000 --> 11:22.000]  Значит, Аца.
[11:23.000 --> 11:25.000]  Ну и здесь, в общем-то, тут уже интриги никакой нет.
[11:26.000 --> 11:27.000]  Да, что-то как-то неудачную строку.
[11:28.000 --> 11:30.000]  Неудачная строка получилась, как видно.
[11:31.000 --> 11:32.000]  А, в конце.
[11:33.000 --> 11:35.000]  Я считаю, что вы можете...
[11:36.000 --> 11:37.000]  Ну, да.
[11:38.000 --> 11:39.000]  А и Ц.
[11:42.000 --> 11:43.000]  Так.
[11:44.000 --> 11:45.000]  А, ну и кое-что мы забыли.
[11:47.000 --> 11:49.000]  Опа, еще одну терминальную вершину.
[11:50.000 --> 11:51.000]  С языком Эпсилон.
[11:52.000 --> 11:53.000]  Вот.
[11:54.000 --> 11:56.000]  И сказать, что на этом все с вами были подписаны.
[11:58.000 --> 11:59.000]  Вот.
[12:02.000 --> 12:03.000]  Да.
[12:04.000 --> 12:06.000]  Ну да, получилось что-то не самое удачное.
[12:07.000 --> 12:08.000]  Не самое удачное в том плане...
[12:09.000 --> 12:10.000]  Чего? Чего не так?
[12:11.000 --> 12:15.000]  Ну да, на самом деле, да, я заметил, что мы тут, конечно, немножко вот так вот...
[12:16.000 --> 12:17.000]  Ну что вы вы narисовали.
[12:18.000 --> 12:20.000]  На самом деле, если правильно нарисовать, можно заметить, что это как бы...
[12:21.000 --> 12:23.000]  Состояние, это просто мы проходимся по строке АББАЦА.
[12:25.000 --> 12:29.000]  И еще какие-то там переходы между собой добавляем, на самом деле.
[12:30.000 --> 12:31.000]  Вот, обратите внимание.
[12:32.000 --> 12:34.000]  Ну, могут быть и альтернативные версии.
[12:35.000 --> 12:37.000]  То есть, это явно не всегда так.
[12:38.000 --> 12:44.000]  Потому что, на самом деле, может быть, какая-нибудь строка на скидку АББББ.
[12:46.000 --> 12:54.520]  Ну давайте попробуем сразу. Ну, во-первых, понятно, что в состоянии вот переходы
[12:54.520 --> 13:24.520]  вот эти АББББББББББББББББББББББББББББББББББББББББББ БББ БББ ББ ББ Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б
[13:24.520 --> 13:35.760]  Бэб
[13:41.760 --> 13:43.720]  Так, ну поехали.
[13:43.720 --> 13:49.600]  Если мы делаем переход по букве А, то тут как бы этот процесс, язык явно схлопывается.
[13:49.600 --> 13:51.440]  Получается ББББ.
[13:51.440 --> 13:54.160]  Тут получается ББББ.
[13:54.160 --> 14:08.380]  Ну есть еще переход по букве B, и вот тут он как бы чуть-чуть поумнее становится.
[14:08.380 --> 14:16.180]  Что он делает? Так, какой язык я тут должен нарисовать?
[14:16.180 --> 14:29.700]  да но именно до 5 не до 6 обротеть внимание
[14:29.700 --> 14:45.060]  ну да здесь уже да в общем язык конечно намекает ничего больше не будет так 4 3 2
[14:45.060 --> 15:02.140]  1 и внезапно боль вот такая неожиданная красота
[15:02.140 --> 15:14.820]  б-б-б-б и эпсилом ровный за который у меня тут терминал ну тут уже б-б-б-б-б-эпсилом
[15:14.820 --> 15:27.500]  соответственно б-б-б-эпсилом б-эпсилом и все да видите может быть даже подозрительно
[15:27.500 --> 15:31.620]  показаться кажется что тут как бы две абсолютно одинаковые цепочки но нам
[15:31.620 --> 15:35.220]  принципиально но как бы в суффиксном автомате нам принципиально что эти вершины
[15:35.220 --> 15:43.020]  терминальный а эти нет и это единственная разница то есть в принципе можно заметить
[15:43.020 --> 15:48.020]  что если бы у нас цель была построить автомат который принимает все под строте
[15:48.020 --> 15:56.700]  они все суффиксы то тогда на самом деле то тогда на самом деле действительно мы
[15:56.700 --> 16:00.260]  могли бы тогда эти цепочки тут так жественно объединить ничего не было
[16:00.260 --> 16:04.460]  если обратить внимание то есть суффиксный автомат это минимальный автомат принимающий
[16:04.460 --> 16:13.740]  именно суффиксы а не под строту вот так что вот такая вот неожиданная красота
[16:13.740 --> 16:23.500]  но он не минимальный тут есть где-то одинаковые классы
[16:23.500 --> 16:33.940]  ну точнее так автомат является минимальный мы термируем автомат является минимальным тогда
[16:33.940 --> 16:40.220]  и только тогда когда во первых через любую вершину проходит путь от стартовой вершины
[16:40.380 --> 16:48.180]  какой-то
[16:48.180 --> 16:54.920]  и тогда собственно автомат получается не Fail.
[16:58.140 --> 17:02.160]  Ну и наша механизм показывает что если вы правильно строить только те вершины
[17:02.160 --> 17:07.140]  который мы вынуждены строить mio получается действительно минимальный автомат да
[17:07.140 --> 17:09.140]  Да, согласен. Это просто скучно и вообще.
[17:09.140 --> 17:11.140]  Да.
[17:11.140 --> 17:13.140]  Можно просто, тут нельзя было
[17:13.140 --> 17:15.140]  пойти при грубе один раз,
[17:15.140 --> 17:17.140]  а потом пойти наверх,
[17:17.140 --> 17:19.140]  без стрелочек нарисовать.
[17:19.140 --> 17:21.140]  Куда наверх?
[17:21.140 --> 17:23.140]  В верхние языки
[17:23.140 --> 17:25.140]  там для просто бэшн.
[17:26.140 --> 17:28.140]  Ну как сказать?
[17:28.140 --> 17:30.140]  Ну нельзя было.
[17:30.140 --> 17:32.140]  Ну как-то есть язык B-B-B-B, а есть язык H такой.
[17:32.140 --> 17:34.140]  Это разная вещь.
[17:37.140 --> 17:39.140]  Ну нельзя из левой нижней вершины
[17:39.140 --> 17:41.140]  нарисовать шесть стрелок
[17:41.140 --> 17:43.140]  в верхней вершине.
[17:43.140 --> 17:45.140]  Шесть стрелок?
[17:45.140 --> 17:47.140]  Да.
[17:47.140 --> 17:49.140]  По какой букве?
[17:49.140 --> 17:51.140]  Да, они будут тренированы.
[17:51.140 --> 17:53.140]  А, ну в эпсилон, да, так-то можно было.
[17:53.140 --> 17:55.140]  Поэтому мы и правильно.
[17:55.140 --> 17:57.140]  Мы говорим про детерминированный автомат.
[17:57.140 --> 17:59.140]  Ну потому что искать подстройки
[17:59.140 --> 18:01.140]  в строке с помощью не детерминированного автомата
[18:01.140 --> 18:03.140]  это DFS какой-то запускает.
[18:03.140 --> 18:05.140]  Это нам не выше.
[18:05.140 --> 18:07.140]  Вот. Значит, поехали.
[18:07.140 --> 18:09.140]  Ну вот это мы поговорили
[18:09.140 --> 18:11.140]  что это такое на уровне автомата.
[18:13.140 --> 18:15.140]  А теперь поговорим
[18:15.140 --> 18:17.140]  что это такое.
[18:17.140 --> 18:19.140]  Попробуем поговорить на уровне строки.
[18:19.140 --> 18:21.140]  Вот.
[18:21.140 --> 18:23.140]  Но на самом деле
[18:25.140 --> 18:27.140]  Вот.
[18:27.140 --> 18:29.140]  Но на самом деле вот это вот красненькое
[18:29.140 --> 18:31.140]  ну по-разному.
[18:31.140 --> 18:33.140]  Для состояния это называется язык
[18:33.140 --> 18:35.140]  а для подстроки
[18:35.140 --> 18:37.140]  назовем правой контекст.
[18:37.140 --> 18:39.140]  То есть на самом деле можно ввести такое
[18:39.140 --> 18:41.140]  независимое определение.
[18:43.140 --> 18:45.140]  Значит, пусть
[18:45.140 --> 18:47.140]  у нас допустим
[18:47.140 --> 18:49.140]  пусть у нас допустим
[18:49.140 --> 18:51.140]  P под строка S.
[18:55.140 --> 18:57.140]  Тогда
[18:57.140 --> 18:59.140]  правым контекстом
[19:07.140 --> 19:09.140]  и будем называть его там
[19:09.140 --> 19:11.140]  R с индексом S от P
[19:13.140 --> 19:15.140]  то есть под строки P
[19:15.140 --> 19:17.140]  ну там
[19:17.140 --> 19:19.140]  под строки P относительно S
[19:19.140 --> 19:21.140]  он называется, да.
[19:21.140 --> 19:23.140]  P относительно строки S.
[19:23.140 --> 19:25.140]  Назовем
[19:29.140 --> 19:31.140]  множество таких строк W
[19:31.140 --> 19:33.140]  что PW
[19:33.140 --> 19:35.140]  суффикс S.
[19:45.140 --> 19:47.140]  Ну да.
[19:49.140 --> 19:51.140]  Отсюда в данной ситуации
[19:51.140 --> 19:53.140]  политологи рекомендуют.
[19:55.140 --> 19:57.140]  Так.
[19:57.140 --> 19:59.140]  Ну заметим, что почему я рисую
[19:59.140 --> 20:01.140]  правый контекст и вот эти вот языки
[20:01.140 --> 20:03.140]  состояний
[20:03.140 --> 20:05.140]  одним и тем же цветом.
[20:05.140 --> 20:07.140]  Ну, ровно потому, что
[20:07.140 --> 20:09.140]  ну действительно.
[20:09.140 --> 20:11.140]  То есть по большому счету
[20:11.140 --> 20:13.140]  если P под строка S
[20:13.140 --> 20:15.140]  то по ней вы в автомате должны пройти
[20:15.140 --> 20:17.140]  ну не факт, что там в терминальную вершину
[20:17.140 --> 20:19.140]  конечно, но должны пройти
[20:19.140 --> 20:21.140]  и при этом попасть в вершину, у которой язык этой
[20:21.140 --> 20:23.140]  вершины должен в точности
[20:23.140 --> 20:25.140]  совпадать с тем, что мы называем правым контекстом.
[20:27.140 --> 20:29.140]  Вот. Это что такое с точки зрения
[20:29.140 --> 20:31.140]  автомата.
[20:31.140 --> 20:33.140]  А с точки зрения
[20:33.140 --> 20:35.140]  строки S это выглядит
[20:35.140 --> 20:37.140]  следующим образом. То есть есть
[20:37.140 --> 20:39.140]  под строка P. У нее есть несколько
[20:39.140 --> 20:41.140]  вхождений.
[20:41.140 --> 20:43.140]  Допустим, вот они.
[20:43.140 --> 20:45.140]  Допустим, это вот под строка P
[20:45.140 --> 20:47.140]  входит здесь, входит здесь.
[20:47.140 --> 20:49.140]  А еще совершенно случайно здесь
[20:49.140 --> 20:51.140]  вхождения могут пересекаться.
[20:51.140 --> 20:53.140]  И тогда
[20:53.140 --> 20:55.140]  ее правым контекстом
[20:55.140 --> 20:57.140]  являются вот
[20:57.140 --> 20:59.140]  такие
[20:59.140 --> 21:01.140]  суффиксы.
[21:01.140 --> 21:03.140]  Вот.
[21:07.140 --> 21:09.140]  Вот.
[21:09.140 --> 21:11.140]  Теперь мы говорили что-то
[21:11.140 --> 21:13.140]  про классы эквивалентности, да?
[21:13.140 --> 21:15.140]  Вот давайте
[21:15.140 --> 21:17.140]  снова посмотрим, что такое
[21:17.140 --> 21:19.140]  классы эквивалентности относительно именно здесь.
[21:19.140 --> 21:21.140]  То есть, ну понятно, в
[21:21.140 --> 21:23.140]  суффиксах в автомате понятно, мы говорили, что
[21:23.140 --> 21:25.140]  строки эквивалентные, если мы по ним можем
[21:25.140 --> 21:27.140]  пройти и прийти в один и тот же состояние,
[21:27.140 --> 21:29.140]  правда?
[21:29.140 --> 21:31.140]  Значит, теперь мы
[21:31.140 --> 21:33.140]  что мы теперь тут скажем?
[21:33.140 --> 21:35.140]  Так, тоже давайте
[21:35.140 --> 21:37.140]  определение.
[21:37.140 --> 21:39.140]  Скажем мы.
[21:41.140 --> 21:43.140]  То есть, это называется
[21:43.140 --> 21:45.140]  подстроен от P и Q.
[21:45.140 --> 21:47.140]  P и Q
[21:47.140 --> 21:49.140]  эквивалентны, будем
[21:49.140 --> 21:51.140]  говорить, относительно строки
[21:51.140 --> 21:53.140]  S,
[21:53.140 --> 21:55.140]  если
[21:55.140 --> 21:57.140]  их правые контексты
[21:57.140 --> 21:59.140]  относительно строки S
[21:59.140 --> 22:01.140]  совпадают.
[22:07.140 --> 22:09.140]  Вот.
[22:13.140 --> 22:15.140]  Вот.
[22:27.140 --> 22:29.140]  Хорошо так?
[22:29.140 --> 22:31.140]  Хорошо так?
[22:31.140 --> 22:33.140]  Вот.
[22:35.140 --> 22:37.140]  Вот действительно.
[22:37.140 --> 22:39.140]  То есть, получается, видите, эквивалентность
[22:39.140 --> 22:41.140]  можно выразить просто чисто в строковых
[22:41.140 --> 22:43.140]  церквах, понимаете, да?
[22:43.140 --> 22:45.140]  Вот понятно, что вот в автомате
[22:45.140 --> 22:47.140]  и тут это одно и то же.
[22:47.140 --> 22:49.140]  Но, когда мы смотрим
[22:49.140 --> 22:51.140]  на это сюда,
[22:55.140 --> 22:57.140]  то, ну вот, то есть, здесь
[22:57.140 --> 22:59.140]  просто если нарисовать банально
[22:59.140 --> 23:01.140]  что это такое, да?
[23:01.140 --> 23:03.140]  Вот что это такое вообще у P и Q
[23:03.140 --> 23:05.140]  одинаковый правый контекст?
[23:05.140 --> 23:07.140]  Это означает, что
[23:07.140 --> 23:09.140]  все вхождения строк
[23:09.140 --> 23:11.140]  P и Q заканчиваются
[23:11.140 --> 23:13.140]  в одних и тех же
[23:13.140 --> 23:15.140]  позициях.
[23:17.140 --> 23:19.140]  Логично, да?
[23:21.140 --> 23:23.140]  Да.
[23:23.140 --> 23:25.140]  Вот.
[23:25.140 --> 23:27.140]  А отсюда, просто уже
[23:27.140 --> 23:29.140]  в этой картинке
[23:29.140 --> 23:31.140]  возникает первое утверждение.
[23:31.140 --> 23:33.140]  Пусть
[23:35.140 --> 23:37.140]  допустим вот
[23:37.140 --> 23:39.140]  ну давайте пусть с отсылкой на картинку
[23:39.140 --> 23:41.140]  допустим, да?
[23:47.140 --> 23:49.140]  Пусть P эквивалентно Q
[23:51.140 --> 23:53.140]  и соответственно
[23:53.140 --> 23:55.140]  P длиннее Q.
[23:57.140 --> 23:59.140]  Вот.
[23:59.140 --> 24:01.140]  Тогда утверждаю
[24:01.140 --> 24:03.140]  я.
[24:07.140 --> 24:09.140]  Ну тогда я утверждаю, что Q
[24:09.140 --> 24:11.140]  это суффикс
[24:11.140 --> 24:13.140]  значит, во-первых, я утверждаю
[24:13.140 --> 24:15.140]  Q это суффикс.
[24:15.140 --> 24:17.140]  Во-первых, Q это
[24:17.140 --> 24:19.140]  суффикс P.
[24:19.140 --> 24:21.140]  Ну а просто из картинки очевидно,
[24:21.140 --> 24:23.140]  правда?
[24:23.140 --> 24:25.140]  Ну и во-вторых,
[24:25.140 --> 24:27.140]  заметим еще следующее.
[24:31.140 --> 24:33.140]  Все
[24:33.140 --> 24:35.140]  суффиксы P
[24:41.140 --> 24:43.140]  более, ну вот,
[24:43.140 --> 24:45.140]  более длинные, чем Q.
[24:45.140 --> 24:47.140]  Эквивалентный
[24:47.140 --> 24:49.140]  P.
[24:59.140 --> 25:01.140]  Ну просто логично, да?
[25:01.140 --> 25:03.140]  Что если P их все
[25:03.140 --> 25:05.140]  не утверждает,
[25:05.140 --> 25:07.140]  то это
[25:07.140 --> 25:13.140]  просто
[25:13.140 --> 25:15.140]  логично, да?
[25:15.140 --> 25:17.140]  Что если все вхождения P и Q
[25:17.140 --> 25:19.140]  заканчиваются в этих позициях,
[25:19.140 --> 25:21.140]  то, наверное, если я возьму какой-нибудь
[25:21.140 --> 25:23.140]  более длинный суффикс,
[25:23.140 --> 25:25.140]  то заметим, что
[25:25.140 --> 25:27.140]  все его вхождения
[25:27.140 --> 25:29.140]  находятся, ну во-первых,
[25:29.140 --> 25:31.140]  так как он суффикс P,
[25:31.140 --> 25:33.140]  то они здесь находятся,
[25:33.140 --> 25:35.140]  а с другой стороны, так как
[25:35.140 --> 25:37.140]  каждое из них еще и вхождение Q,
[25:37.140 --> 25:39.140]  то получается, в других местах оно не находится.
[25:39.140 --> 25:41.140]  То есть вообще заметим, да?
[25:41.140 --> 25:43.140]  Если вы возьмете какую-нибудь под строку P
[25:43.140 --> 25:45.140]  и будете отпиливать у нее по одному символу,
[25:45.140 --> 25:47.140]  то некоторое время у вас вхождения будут те же,
[25:47.140 --> 25:49.140]  а потом, например, те же вхождения
[25:49.140 --> 25:51.140]  останутся, но появится еще
[25:51.140 --> 25:53.140]  одну, ну или там несколько, да?
[25:53.140 --> 25:55.140]  Ну два там, и так далее.
[25:55.140 --> 25:57.140]  Когда вот так расширяется, то есть как бы множество
[25:57.140 --> 25:59.140]  экстенсивно расширяется, то есть старые
[25:59.140 --> 26:01.140]  окончания не исчезают, новые появляются.
[26:01.140 --> 26:03.140]  Это вот полезно себе просто такую
[26:03.140 --> 26:05.140]  картинку в голове иметь.
[26:05.140 --> 26:07.140]  Вот.
[26:09.140 --> 26:11.140]  Ну такое мистическое свойство
[26:11.140 --> 26:13.140]  дает нам возможность ввести
[26:13.140 --> 26:15.140]  понятие, там, ввести понятие
[26:15.140 --> 26:17.140]  класс эквивалентности.
[26:19.140 --> 26:21.140]  То есть так и записать. То есть определение.
[26:21.140 --> 26:23.140]  Да?
[26:23.140 --> 26:25.140]  То есть класс, ну вот,
[26:25.140 --> 26:27.140]  то есть вот это вот P
[26:27.140 --> 26:29.140]  с индексом S,
[26:29.140 --> 26:31.140]  это класс эквивалентности.
[26:35.140 --> 26:37.140]  Настепе
[26:37.140 --> 26:39.140]  под, соответственно,
[26:39.140 --> 26:41.140]  S.
[26:41.140 --> 26:43.140]  Да, вот обратите внимание, я тут
[26:43.140 --> 26:45.140]  индекс пишу, потому что класс эквивалентности
[26:45.140 --> 26:47.140]  он разный.
[26:47.140 --> 26:49.140]  Да, обратите внимание, ну вот,
[26:49.140 --> 26:51.140]  ну конечно в ядном виде хренить этот класс эквивалентности
[26:51.140 --> 26:53.140]  мы не будем, но такое понятие
[26:53.140 --> 26:55.140]  введем.
[26:55.140 --> 26:57.140]  Понятно, да?
[26:57.140 --> 26:59.140]  То есть он описывает все
[26:59.140 --> 27:01.140]  подстройки S, у которых
[27:01.140 --> 27:03.140]  конечной позиции
[27:03.140 --> 27:05.140]  Ну да, конечной позиции
[27:05.140 --> 27:07.140]  те же, что и у P.
[27:07.140 --> 27:09.140]  Да.
[27:09.140 --> 27:11.140]  Вот.
[27:11.140 --> 27:13.140]  Более того,
[27:13.140 --> 27:15.140]  мы еще можем ввести,
[27:15.140 --> 27:17.140]  давайте в том же определении
[27:17.140 --> 27:19.140]  еще введем такое понятие,
[27:19.140 --> 27:21.140]  как longest.
[27:23.140 --> 27:25.140]  Вот так класс эквивалентности.
[27:27.140 --> 27:29.140]  Это будет длиннейшее.
[27:33.140 --> 27:35.140]  Шея строка
[27:35.140 --> 27:37.140]  этого класса.
[27:37.140 --> 27:39.140]  Да, как вы уже убедились,
[27:39.140 --> 27:41.140]  она определяется однозначно.
[27:41.140 --> 27:43.140]  Понимаете, да?
[27:43.140 --> 27:45.140]  Вот.
[27:45.140 --> 27:47.140]  И нам еще пригодится понятие
[27:47.140 --> 27:49.140]  len.
[27:49.140 --> 27:51.140]  Ну это просто
[27:51.140 --> 27:53.140]  длина
[27:53.140 --> 27:55.140]  longest, максимальная длина.
[27:55.140 --> 27:57.140]  То есть не путать, да?
[27:57.140 --> 27:59.140]  То есть разница будет в том, что
[27:59.140 --> 28:01.140]  из этих трех понятий мы реально
[28:01.140 --> 28:03.140]  в вершинах будем хранить len.
[28:03.140 --> 28:05.140]  Ну понятно, в сами строки мы хранить
[28:05.140 --> 28:07.140]  не будем, а вот их длину запросто.
[28:09.140 --> 28:11.140]  Ну в общем-то, если мы суфистный автомат
[28:11.140 --> 28:13.140]  откуда-то выкопаем, то в общем-то
[28:13.140 --> 28:15.140]  по len потом восстановить
[28:15.140 --> 28:17.140]  то есть в общем-то, если вы уже суфистный
[28:17.140 --> 28:19.140]  автомат выкопали, то в общем-то и len,
[28:19.140 --> 28:21.140]  а потом еще и восстанавливает longest,
[28:21.140 --> 28:23.140]  в общем-то не сложно, правда?
[28:25.140 --> 28:27.140]  Ну потому что, например, можно
[28:27.140 --> 28:29.140]  для каждого состояния, например,
[28:29.140 --> 28:31.140]  можно найти, скажем,
[28:31.140 --> 28:33.140]  какую-нибудь самую короткую
[28:33.140 --> 28:35.140]  строчку, которая через это состояние
[28:35.140 --> 28:37.140]  проходит.
[28:37.140 --> 28:39.140]  Как найти?
[28:39.140 --> 28:41.140]  Нет, даже не самую короткую строчку,
[28:41.140 --> 28:43.140]  а самый короткий суфикс.
[28:43.140 --> 28:45.140]  Как найти? Да очень просто.
[28:45.140 --> 28:47.140]  С помощью динамики для каждой вершины
[28:47.140 --> 28:49.140]  можно найти корочайший путь истартовый.
[28:49.140 --> 28:51.140]  Ну как?
[28:51.140 --> 28:53.140]  Да, динамика называется BFS.
[28:53.140 --> 28:55.140]  Но граф ициклический,
[28:55.140 --> 28:57.140]  да, мистический факт.
[28:57.140 --> 28:59.140]  Очевидно, что суфиксный автомат
[28:59.140 --> 29:01.140]  обязан быть ициклическим графом, согласны?
[29:01.140 --> 29:03.140]  Ну просто потому что у нас конечный язык.
[29:03.140 --> 29:05.140]  Вот.
[29:05.140 --> 29:07.140]  Вверх конечный язык, вот этот автомат
[29:07.140 --> 29:09.140]  минимальный, потому что теоретически не минимальный
[29:09.140 --> 29:11.140]  суфиксный автомат может быть циклическим,
[29:11.140 --> 29:13.140]  но просто этот цикл может быть.
[29:13.140 --> 29:15.140]  А во вторых еще можно
[29:15.140 --> 29:17.140]  динамикой для каждой вершины написать
[29:17.140 --> 29:19.140]  найти корочайший путь до терминальной,
[29:19.140 --> 29:21.140]  правда?
[29:21.140 --> 29:23.140]  И тогда комбинируете две строчки,
[29:23.140 --> 29:25.140]  то есть эти два пути, получаем какой-то
[29:25.140 --> 29:27.140]  суфикс, и вершина должна находиться
[29:27.140 --> 29:29.140]  на какой-то позиции, соответственно получаем
[29:29.140 --> 29:31.140]  какой под строке он соответствует.
[29:31.140 --> 29:33.140]  В общем, можно найти корочайший путь отстартовый,
[29:33.140 --> 29:35.140]  а можно найти длиннейший.
[29:35.140 --> 29:37.140]  Ну потому что у нас наибраточная динамика,
[29:37.140 --> 29:39.140]  но граф ициклический,
[29:39.140 --> 29:41.140]  поэтому можно все.
[29:41.140 --> 29:43.140]  Ну по факту этого не будет,
[29:43.140 --> 29:45.140]  потому что реально мы при построении
[29:45.140 --> 29:47.140]  будем поддерживать лент
[29:47.140 --> 29:49.140]  и жестко им пользоваться.
[29:51.140 --> 29:53.140]  Так что вот такие понятия.
[29:53.140 --> 29:55.140]  Логист, конечно, механик не будет, класс эквалиптости
[29:55.140 --> 29:57.140]  будем иметь в виду.
[29:59.140 --> 30:01.140]  Вот, как же мы это будем делать?
[30:03.140 --> 30:05.140]  Но для того, чтобы действительно
[30:05.140 --> 30:07.140]  строить какой-то автомат,
[30:07.140 --> 30:09.140]  ну как бы да, нам как бы надо строить,
[30:09.140 --> 30:11.140]  и вообще попутно еще подумать, а зачем нам его строить?
[30:11.140 --> 30:13.140]  Потому что вдруг выяснится,
[30:13.140 --> 30:15.140]  что размер этого минимального автомата
[30:15.140 --> 30:17.140]  это, там, я не знаю, квадрат.
[30:19.140 --> 30:21.140]  Вот нельзя для условно обоцам
[30:21.140 --> 30:23.140]  бы построить ничего принципиально лучше,
[30:23.140 --> 30:25.140]  нежели борт.
[30:25.140 --> 30:27.140]  Может же быть такое?
[30:29.140 --> 30:31.140]  Ну, по камере, пока не очень.
[30:31.140 --> 30:33.140]  Но для того, чтобы это стало понятно,
[30:33.140 --> 30:35.140]  давайте подумаем вот о чем.
[30:35.140 --> 30:37.140]  Давайте внимательно посмотрим
[30:37.140 --> 30:39.140]  на этих логистов.
[30:41.140 --> 30:43.140]  Кто они?
[30:45.140 --> 30:47.140]  Какие подстроки являются
[30:47.140 --> 30:49.140]  логистами своих класса эквалиптости?
[30:51.140 --> 30:53.140]  Ну, это префиксы
[30:53.140 --> 30:55.140]  для начала.
[30:55.140 --> 30:57.140]  Сейчас.
[30:59.140 --> 31:01.140]  Класса эквалиптости и все остальные
[31:01.140 --> 31:03.140]  это суффиксы логистов.
[31:03.140 --> 31:05.140]  Правильно.
[31:05.140 --> 31:07.140]  У нас интересует такой, да,
[31:07.140 --> 31:09.140]  но это для любой строки верни.
[31:09.140 --> 31:11.140]  Ну, у любой строки, как бы да,
[31:11.140 --> 31:13.140]  есть несколько ю-суффиксов эквалетные,
[31:13.140 --> 31:15.140]  а еще есть кто-то, кто вернили.
[31:15.140 --> 31:17.140]  Кто-то, кто вернили.
[31:21.140 --> 31:23.140]  Ну, давайте, значит, смотрите.
[31:23.140 --> 31:25.140]  Сейчас подумаем вот о чем.
[31:25.140 --> 31:27.140]  Рассмотрим строчку.
[31:29.140 --> 31:31.140]  И подумаем. Давайте так.
[31:31.140 --> 31:33.140]  Какая строка, что означает,
[31:33.140 --> 31:35.140]  что строка не является
[31:35.140 --> 31:37.140]  логистом?
[31:39.140 --> 31:41.140]  Вот такая строка P,
[31:41.140 --> 31:43.140]  допустим, не является
[31:43.140 --> 31:45.140]  логистом в своем классе эквалиптости.
[31:45.140 --> 31:47.140]  Значит, слева от всех
[31:47.140 --> 31:49.140]  храждений одинаковый символ? Да.
[31:49.140 --> 31:51.140]  То есть, в принципе, это означает, что существует хотя бы на один символ
[31:51.140 --> 31:53.140]  более длинная строка,
[31:53.140 --> 31:55.140]  суффиксом, который является P, который эквалиптост.
[31:55.140 --> 31:57.140]  То есть, который заканчивается на тени тут же.
[31:57.140 --> 31:59.140]  Это означает,
[31:59.140 --> 32:01.140]  что
[32:01.140 --> 32:03.140]  перед всеми
[32:03.140 --> 32:05.140]  храждениями
[32:07.140 --> 32:09.140]  перед храждениями P, на самом деле,
[32:09.140 --> 32:11.140]  находится один и тот же символ.
[32:13.140 --> 32:15.140]  То есть, можно сформулировать так, что строка
[32:15.140 --> 32:17.140]  не является логистом.
[32:17.140 --> 32:19.140]  Ну, как минимум, если, во-первых,
[32:19.140 --> 32:21.140]  то есть, для этого нужно,
[32:21.140 --> 32:23.140]  чтобы, во-первых, P не была суффиксом,
[32:23.140 --> 32:25.140]  то префиксом, обратите внимание, да?
[32:25.140 --> 32:27.140]  А во-вторых, перед всеми
[32:27.140 --> 32:29.140]  храждениями P были абсолютно отдельные символы.
[32:29.140 --> 32:31.140]  Видите, да?
[32:31.140 --> 32:33.140]  Это необходимо.
[32:33.140 --> 32:35.140]  Но это и достаточно,
[32:35.140 --> 32:37.140]  обратите внимание, правда?
[32:37.140 --> 32:39.140]  Поэтому сейчас я эту лему,
[32:39.140 --> 32:41.140]  то есть, на самом деле, лему можно
[32:41.140 --> 32:43.140]  сформулировали не в ранг теория,
[32:43.140 --> 32:45.140]  но это прям ключевая лемма,
[32:45.140 --> 32:47.140]  на самом деле,
[32:47.140 --> 32:49.140]  нот, которая нам даст все.
[32:51.140 --> 32:53.140]  Она говорит нам следующее.
[32:53.140 --> 32:55.140]  То есть, я ее сформулирую так.
[32:55.140 --> 32:57.140]  Пусть у нас P под строка S.
[33:03.140 --> 33:05.140]  Пусть P под строка S.
[33:11.140 --> 33:13.140]  Так? Да.
[33:15.140 --> 33:17.140]  Тогда что?
[33:17.140 --> 33:19.140]  Тогда, смотрите,
[33:19.140 --> 33:21.140]  P равно
[33:21.140 --> 33:23.140]  является лонгестом,
[33:23.140 --> 33:25.140]  ладно, синим потом допишу,
[33:25.140 --> 33:27.140]  лонгестом в своем классике валентности.
[33:35.140 --> 33:37.140]  Тогда и только тогда,
[33:37.140 --> 33:39.140]  когда выполнено хотя бы одно,
[33:39.140 --> 33:41.140]  то есть, следующее букву утверждений.
[33:41.140 --> 33:43.140]  Второе утверждение
[33:43.140 --> 33:45.140]  будет, значит,
[33:45.140 --> 33:47.140]  P префикс S.
[33:55.140 --> 33:57.140]  И второе,
[33:57.140 --> 33:59.140]  в алфавите
[33:59.140 --> 34:01.140]  существуют такие две
[34:01.140 --> 34:03.140]  буковки.
[34:05.140 --> 34:07.140]  Ну и что, давайте я на всякий случай
[34:07.140 --> 34:09.140]  для педантов напишу,
[34:09.140 --> 34:11.140]  что A не равно B.
[34:13.140 --> 34:15.140]  Такие что?
[34:15.140 --> 34:17.140]  A, P
[34:17.140 --> 34:19.140]  и B, P
[34:21.140 --> 34:23.140]  под строки S.
[34:37.140 --> 34:39.140]  Ну, конечно,
[34:39.140 --> 34:41.140]  правда.
[34:45.140 --> 34:47.140]  Ну вот,
[34:47.140 --> 34:49.140]  как бы, да,
[34:49.140 --> 34:51.140]  казалось бы,
[34:51.140 --> 34:53.140]  видите, мы ничего
[34:53.140 --> 34:55.140]  мегаумного не заметили,
[34:55.140 --> 34:57.140]  да, но чуть-чуть переформулировали
[34:57.140 --> 34:59.140]  и уже выглядит
[34:59.140 --> 35:01.140]  солидно.
[35:03.140 --> 35:05.140]  О,
[35:05.140 --> 35:07.140]  вот.
[35:09.140 --> 35:11.140]  И тогда получается следующее.
[35:11.140 --> 35:13.140]  Значит, теперь давайте подумаем вот о чем.
[35:17.140 --> 35:19.140]  Значит, ну вот, если говорить про вот A, P
[35:19.140 --> 35:21.140]  и B, P под строки S,
[35:21.140 --> 35:23.140]  ну, то есть, вообще, вот, когда у нас
[35:23.140 --> 35:25.140]  возникают подстроки и продолжение влево,
[35:25.140 --> 35:27.140]  на самом деле, это может вызвать ассоциации
[35:27.140 --> 35:29.140]  с построением суффиксного дерева,
[35:29.140 --> 35:31.140]  только не для самой строки,
[35:31.140 --> 35:33.140]  а для развертки.
[35:35.140 --> 35:37.140]  То есть, тогда, по большому счету,
[35:37.140 --> 35:39.140]  если мы строим суффиксное дерево для развертки
[35:39.140 --> 35:41.140]  на строке S, то обратите внимание, что
[35:41.140 --> 35:43.140]  тогда вот это утверждение означает,
[35:43.140 --> 35:45.140]  что под строка P приходит вершина
[35:45.140 --> 35:47.140]  с развилкой, правда?
[35:47.140 --> 35:49.140]  Ну, у нас не все вершины,
[35:49.140 --> 35:51.140]  ну вот.
[35:55.140 --> 35:57.140]  Но, заметим, что
[35:57.140 --> 35:59.140]  в суффиксном автомате это тоже
[35:59.140 --> 36:01.140]  имеет отражение.
[36:01.140 --> 36:03.140]  Вот, нам пришло время ввести
[36:03.140 --> 36:05.140]  такое мистическое понятие, как
[36:05.140 --> 36:07.140]  суффиксная ссылка.
[36:11.140 --> 36:13.140]  Да, и снова с нами понятие
[36:13.140 --> 36:15.140]  суффиксная ссылка.
[36:15.140 --> 36:17.140]  Но на этот раз,
[36:17.140 --> 36:19.140]  но сейчас это понятие будет вообще
[36:19.140 --> 36:21.140]  никак не связанно ни с какими украинами
[36:21.140 --> 36:23.140]  и там прочими карасиками.
[36:23.140 --> 36:25.140]  Значит, определим.
[36:29.140 --> 36:31.140]  Значит, пусть
[36:31.140 --> 36:33.140]  у нас,
[36:33.140 --> 36:35.140]  пусть у нас действительно
[36:35.140 --> 36:37.140]  действительно P
[36:37.140 --> 36:39.140]  под строка S.
[36:39.140 --> 36:41.140]  П, не пустая
[36:41.140 --> 36:43.140]  под строка S.
[36:45.140 --> 36:47.140]  Не пустая под строка
[36:49.140 --> 36:51.140]  S.
[36:55.140 --> 36:57.140]  Тогда мы вводим понятие
[36:57.140 --> 36:59.140]  суффиксная ссылка.
[36:59.140 --> 37:01.140]  Суфф
[37:01.140 --> 37:03.140]  от P
[37:03.140 --> 37:05.140]  всегда.
[37:05.140 --> 37:07.140]  Что же это такое?
[37:13.140 --> 37:15.140]  Так вот.
[37:17.140 --> 37:19.140]  Ну, даже суффиксную ссылку
[37:19.140 --> 37:21.140]  будем вводить даже не от P,
[37:21.140 --> 37:23.140]  а от класса
[37:23.140 --> 37:25.140]  эквивалентности.
[37:25.140 --> 37:27.140]  Ну, тут тоже,
[37:27.140 --> 37:29.140]  тут суффикс можно писать,
[37:29.140 --> 37:31.140]  S можно не писать,
[37:31.140 --> 37:33.140]  он аналогично писать.
[37:33.140 --> 37:35.140]  Значит, что это такое?
[37:35.140 --> 37:37.140]  Ну, то есть ссылка класса
[37:37.140 --> 37:39.140]  эквивалентности.
[37:39.140 --> 37:41.140]  Это тоже класс эквивалентности.
[37:43.140 --> 37:45.140]  Q
[37:47.140 --> 37:49.140]  с индексом S.
[37:49.140 --> 37:51.140]  Такой, что
[37:51.140 --> 37:53.140]  Q
[37:53.140 --> 37:55.140]  Q
[37:55.140 --> 37:57.140]  Q, короче,
[37:59.140 --> 38:01.140]  ну вот, суффикс,
[38:01.140 --> 38:03.140]  можно не писать даже, что собственный,
[38:03.140 --> 38:05.140]  суффикс P.
[38:07.140 --> 38:09.140]  Значит, Q не эквивалентен
[38:09.140 --> 38:11.140]  P
[38:11.140 --> 38:13.140]  по S. И длина
[38:13.140 --> 38:15.140]  Q максимально возможна.
[38:17.140 --> 38:19.140]  Не эквивалентен.
[38:19.140 --> 38:21.140]  Не эквивалентен.
[38:23.140 --> 38:25.140]  Суфф
[38:29.140 --> 38:31.140]  это класс эквивалентности.
[38:31.140 --> 38:33.140]  Нет, ну да.
[38:33.140 --> 38:35.140]  Ну или в переводе говорят,
[38:35.140 --> 38:37.140]  что суффиксная ссылка
[38:37.140 --> 38:39.140]  с точки зрения автомата, она ведет
[38:39.140 --> 38:41.140]  из вершины в вершину.
[38:43.140 --> 38:45.140]  Везде могу черные нарисовать.
[38:53.140 --> 38:55.140]  Вот.
[38:57.140 --> 38:59.140]  Значит, как-то,
[38:59.140 --> 39:01.140]  чтобы понять, как выглядят суффиксные
[39:01.140 --> 39:03.140]  ссылки, давайте, вот у нас есть
[39:03.140 --> 39:05.140]  два примера автоматов, а вот давайте
[39:05.140 --> 39:07.140]  посмотрим, вот каждая вершина соответствует
[39:07.140 --> 39:09.140]  классу эквивалентности, да?
[39:09.140 --> 39:11.140]  Вот давайте попробуем эти классы эквивалентности
[39:11.140 --> 39:13.140]  изобразить. Вот, например,
[39:13.140 --> 39:15.140]  у этой вершины, какой класс эквивалентности?
[39:19.140 --> 39:21.140]  Да, совершенно верно.
[39:21.140 --> 39:23.140]  Да, кстати, отсюда
[39:23.140 --> 39:25.140]  такое есть приятное
[39:25.140 --> 39:27.140]  мистическое устройство во всех строчках.
[39:29.140 --> 39:31.140]  Класс эквивалентности ε равен
[39:31.140 --> 39:33.140]  множеству из ε.
[39:35.140 --> 39:37.140]  Ну, действительно, логично,
[39:37.140 --> 39:39.140]  потому что, вот, кстати, да,
[39:39.140 --> 39:41.140]  как-то чему равен правый контекст
[39:41.140 --> 39:43.140]  ε?
[39:43.140 --> 39:45.140]  Эпсилон?
[39:47.140 --> 39:49.140]  Вот, там же, наверное, написано.
[39:49.140 --> 39:51.140]  А шерть такое?
[39:51.140 --> 39:53.140]  А в общем случае?
[39:53.140 --> 39:55.140]  Все суффиксы.
[39:55.140 --> 39:57.140]  Да, то есть, заметим, что
[39:57.140 --> 39:59.140]  правым контекстом
[39:59.140 --> 40:01.140]  эпсилона, нет, классом эквивалентности
[40:01.140 --> 40:03.140]  эпсилон является эпсилон, а правым контекстом
[40:03.140 --> 40:05.140]  эпсилоны является все суффиксы
[40:05.140 --> 40:07.140]  от кустово до самой спрессы.
[40:07.140 --> 40:09.140]  Оба раза ключи.
[40:09.140 --> 40:11.140]  Вот, значит, идем дальше.
[40:11.140 --> 40:13.140]  Так, ну, теперь
[40:13.140 --> 40:15.140]  попробуем V-faces тоже.
[40:15.140 --> 40:17.140]  Все мы сделали, вот, черный эпсилон
[40:17.140 --> 40:19.140]  для вершины.
[40:19.140 --> 40:21.140]  Это класс эквалентности
[40:21.140 --> 40:23.140]  этой вершины.
[40:23.140 --> 40:25.140]  То есть, мы помним, что...
[40:25.140 --> 40:27.140]  То есть, слово.
[40:27.140 --> 40:29.140]  Ну, да, то есть, я по большому счету...
[40:29.140 --> 40:31.140]  Да, эпсилон это не в смысле пустой...
[40:31.140 --> 40:33.140]  Да, пустое множество, оно вот так
[40:33.140 --> 40:35.140]  в смысле. А эпсилон
[40:35.140 --> 40:37.140]  пустое слово. Множество из пустого
[40:37.140 --> 40:39.140]  слова и пустое множество, это разные вещи.
[40:39.140 --> 40:41.140]  Так, топелька.
[40:41.140 --> 40:43.140]  Ну, давайте
[40:43.140 --> 40:45.140]  попробуем. То есть, заметим, с точки зрения автомата
[40:45.140 --> 40:47.140]  класс эквалентности вершины, это
[40:47.140 --> 40:49.140]  по каким строчкам мы в нее можем прийти,
[40:49.140 --> 40:51.140]  по большому счету, правда?
[40:51.140 --> 40:53.140]  Поэтому вот здесь у нас класс эквалентности, это
[40:53.140 --> 40:55.140]  A. Здесь, вот
[40:55.140 --> 40:57.140]  по этой вершине мы можем прийти отсюда,
[40:57.140 --> 40:59.140]  можем прийти отсюда. Получается
[40:59.140 --> 41:01.140]  молодое. B и AB.
[41:01.140 --> 41:03.140]  Ну да. B и AB.
[41:03.140 --> 41:05.140]  Так.
[41:05.140 --> 41:07.140]  Так.
[41:07.140 --> 41:09.140]  По этой вершине мы можем прийти только отсюда,
[41:09.140 --> 41:11.140]  поэтому получается B, A
[41:11.140 --> 41:13.140]  и A, B, A.
[41:15.140 --> 41:17.140]  Так, что дальше?
[41:17.140 --> 41:19.140]  Так, вот здесь становится
[41:19.140 --> 41:21.140]  интереснее. Сюда можно прийти
[41:21.140 --> 41:23.140]  по строкам BAB
[41:23.140 --> 41:25.140]  и ABAB.
[41:25.140 --> 41:27.140]  Сюда, соответственно,
[41:27.140 --> 41:29.140]  BAB
[41:29.140 --> 41:31.140]  и ABBA. И ABBA
[41:31.140 --> 41:33.140]  нас ведут.
[41:33.140 --> 41:35.140]  Теперь вот сюда объединяем.
[41:35.140 --> 41:37.140]  Что у нас появляется?
[41:39.140 --> 41:41.140]  Объединяем вот это и это,
[41:41.140 --> 41:43.140]  и приписываем C. Получается
[41:43.140 --> 41:45.140]  BATS, ABATS,
[41:45.140 --> 41:47.140]  что еще там получается?
[41:49.140 --> 41:51.140]  BABATS
[41:51.140 --> 41:53.140]  и ABABATS.
[41:53.140 --> 41:55.140]  Еще C было.
[41:55.140 --> 41:57.140]  А просто C откуда?
[41:57.140 --> 41:59.140]  И старый.
[41:59.140 --> 42:01.140]  И старый?
[42:01.140 --> 42:03.140]  Еще стрелочка.
[42:03.140 --> 42:05.140]  Ой, а у нас еще...
[42:07.140 --> 42:09.140]  А, ну да,
[42:09.140 --> 42:11.140]  потому что мы еще забыли ATS
[42:11.140 --> 42:13.140]  отсюда
[42:13.140 --> 42:15.140]  и, собственно, C.
[42:15.140 --> 42:17.140]  То есть, видите, да,
[42:17.140 --> 42:19.140]  в классе квалицитета, наоборот, он под конец разгоняется.
[42:19.140 --> 42:21.140]  Да, вот получается
[42:21.140 --> 42:23.140]  C, A, C.
[42:23.140 --> 42:25.140]  Ну и здесь, соответственно, уже
[42:25.140 --> 42:27.140]  тесно перечисляем
[42:27.140 --> 42:29.140]  все суффиксы, начиная
[42:29.140 --> 42:31.140]  с третьего.
[42:31.140 --> 42:33.140]  C, A, ATSA,
[42:33.140 --> 42:35.140]  BATS, ABATS,
[42:35.140 --> 42:37.140]  BABATS
[42:39.140 --> 42:41.140]  и ABABATS.
[42:45.140 --> 42:47.140]  Вот.
[42:47.140 --> 42:49.140]  Там еще C, A.
[42:53.140 --> 42:55.140]  C, A.
[42:55.140 --> 42:57.140]  Прямо сразу
[42:57.140 --> 42:59.140]  скучная стройка.
[42:59.140 --> 43:01.140]  Вот здесь как-то повеселее.
[43:01.140 --> 43:03.140]  А, ну здесь, в общем-то, да,
[43:03.140 --> 43:05.140]  и писать удобнее.
[43:05.140 --> 43:07.140]  Потому что, смотрите, здесь F,
[43:07.140 --> 43:09.140]  здесь A, AB,
[43:09.140 --> 43:11.140]  ABATS,
[43:11.140 --> 43:13.140]  ABABB.
[43:13.140 --> 43:15.140]  Ну здесь просто подстрок у этой строки мало.
[43:15.140 --> 43:17.140]  Видите, состояние внука, зато подстрок
[43:17.140 --> 43:19.140]  мало. ABABB.
[43:21.140 --> 43:23.140]  И здесь вот идем сюда, получается
[43:23.140 --> 43:25.140]  F, B,
[43:25.140 --> 43:27.140]  B, B.
[43:27.140 --> 43:29.140]  B, B, B.
[43:29.140 --> 43:31.140]  В машине хватает.
[43:31.140 --> 43:33.140]  B, B, B.
[43:33.140 --> 43:35.140]  B, B, B, B.
[43:39.140 --> 43:41.140]  И что еще? А, ну и тут всего
[43:41.140 --> 43:43.140]  две строчки, да.
[43:43.140 --> 43:45.140]  A, B, B, B, B.
[43:45.140 --> 43:47.140]  B и B, B, B.
[43:47.140 --> 43:49.140]  B, B, B.
[43:49.140 --> 43:51.140]  Вот.
[43:53.140 --> 43:55.140]  Да, видите, тут подстрочек много,
[43:55.140 --> 43:57.140]  но они как-то удачно
[43:57.140 --> 43:59.140]  скомпоновались.
[43:59.140 --> 44:01.140]  Подстрочек мало, и там просто едва лиги
[44:01.140 --> 44:03.140]  по одной максимуму распихались
[44:03.140 --> 44:05.140]  по всем состояниям.
[44:05.140 --> 44:07.140]  Вот.
[44:07.140 --> 44:09.140]  Так что вот, интересное зрение.
[44:09.140 --> 44:11.140]  Так, чему я это все вообще?
[44:11.140 --> 44:13.140]  Так, мы начали с того, что мы определили
[44:13.140 --> 44:15.140]  суффиксный ссылок. Вот давайте
[44:15.140 --> 44:17.140]  попробуем порисовать.
[44:17.140 --> 44:19.140]  А куда у нас, например, ведут
[44:19.140 --> 44:21.140]  здесь суффиксные ссылки?
[44:21.140 --> 44:23.140]  Вот, например, вот из этого состояния.
[44:23.140 --> 44:25.140]  Куда у нас ведет суффиксная ссылка?
[44:25.140 --> 44:27.140]  Вот из этого.
[44:27.140 --> 44:29.140]  Вот берем абабацу и находим максимальный
[44:29.140 --> 44:31.140]  ее суффикс, который не в этом классике валютности.
[44:33.140 --> 44:35.140]  Но, очевидно, это суффикс A.
[44:35.140 --> 44:37.140]  Поэтому
[44:37.140 --> 44:39.140]  где у нас классик валютности с A?
[44:39.140 --> 44:41.140]  Он, соответственно, вот здесь.
[44:41.140 --> 44:43.140]  Так.
[44:43.140 --> 44:45.140]  А куда суффиксная ссылка ведет отсюда?
[44:51.140 --> 44:53.140]  Вот.
[44:53.140 --> 44:55.140]  Тут тоже A есть.
[44:55.140 --> 44:57.140]  Да, тут C, конечно.
[44:57.140 --> 44:59.140]  Поэтому
[44:59.140 --> 45:01.140]  так.
[45:01.140 --> 45:03.140]  А отсюда
[45:03.140 --> 45:05.140]  куда?
[45:07.140 --> 45:09.140]  Да вот сюда.
[45:11.140 --> 45:13.140]  Тут все так.
[45:13.140 --> 45:15.140]  Тут что?
[45:15.140 --> 45:17.140]  А
[45:17.140 --> 45:19.140]  Б
[45:19.140 --> 45:21.140]  А
[45:21.140 --> 45:23.140]  А
[45:23.140 --> 45:25.140]  Б
[45:25.140 --> 45:27.140]  А
[45:27.140 --> 45:29.140]  Б
[45:29.140 --> 45:31.140]  И
[45:31.140 --> 45:33.140]  А
[45:33.140 --> 45:35.140]  Б
[45:35.140 --> 45:37.140]  А
[45:37.140 --> 45:39.140]  А
[45:39.140 --> 45:41.140]  А
[45:41.140 --> 45:43.140]  А
[45:43.140 --> 45:53.140]  А ну и отсюда. Ну здесь у нас сопротивление бесполезное. Так, вот такая красота получается.
[45:54.140 --> 45:58.140]  Так, а тут у нас это как будет выглядеть.
[45:58.140 --> 46:15.140]  Ну тут проще когда-то. Все в старт выглядело.
[46:15.140 --> 46:20.140]  Ну давайте выберем любую письму. Пойдем по А из стартовой.
[46:20.140 --> 46:23.140]  Так, отсюда куда?
[46:23.140 --> 46:28.140]  Отсюда идет в Б, то есть это будет вниз-влево.
[46:28.140 --> 46:29.140]  Ну да.
[46:29.140 --> 46:31.140]  Отсюда в Б-Б.
[46:31.140 --> 46:36.140]  О, смотрите, да, тут такая красота получается.
[46:36.140 --> 46:41.140]  Вот так, вот так. Ой, отсюда куда?
[46:42.140 --> 46:48.140]  Отсюда в 5 Б, вот наизданных.
[46:48.140 --> 46:51.140]  Да-да. А из этих Б куда идет?
[46:51.140 --> 46:52.140]  Обратно от другого.
[46:52.140 --> 46:55.140]  Ага, ну да, здесь вообще красота.
[46:56.140 --> 47:00.140]  Какие обратные рёбра, вспомнили потом.
[47:04.140 --> 47:09.140]  Так что вот можно хранить еще такой сутик, такие сутиксные сынки.
[47:09.140 --> 47:16.140]  Ну, очевидно, что эти суфиксные сынки образуют, по большому счету, подвешенное дерево.
[47:16.140 --> 47:24.140]  Причем не просто подвешенное дерево, а подвешенное дерево с корнем в стартовой вершине. Правда?
[47:29.140 --> 47:34.140]  Да, просто потому что в рафоциклический и у каждой вершины есть куда вести суфиксные сынки, кроме стартовой.
[47:34.140 --> 47:38.140]  Например, по этому. Этого уже достаточно, чтобы сказать, что это дерево.
[47:38.140 --> 47:41.140]  Нет, дерево на суфиксных сынках нет.
[47:41.140 --> 47:45.140]  Ну да. Сам автомат, конечно, деревом не является.
[47:45.140 --> 47:49.140]  Но суфиксные сынки образуют подвешенное дерево с корнем стартовой вершины.
[47:51.140 --> 47:53.140]  Это все, что я утверждаю.
[47:55.140 --> 47:56.140]  Или в это не верится?
[47:56.140 --> 47:57.140]  Нет, не очевидно.
[47:57.140 --> 47:58.140]  Не очевидно?
[47:58.140 --> 48:03.140]  Ну, утверждение такое. Заметим, что у нас есть у каждой вершины класс эквивалентности.
[48:03.140 --> 48:09.140]  И суфиксная ссылка всегда ведет в класс эквивалентности со строго меньшей длиной лонгеста. Правда?
[48:09.140 --> 48:10.140]  Да.
[48:10.140 --> 48:12.140]  Значит, граф из суфиксных сынок, он ациклический.
[48:12.140 --> 48:13.140]  Логично.
[48:14.140 --> 48:18.140]  Из каждой вершины есть ребро, кроме стартовой.
[48:20.140 --> 48:26.140]  Ну, следовательно, отсюда получается, что если вы будете идти из любой вершины, то просто рано или поздно дойдете до стартовой вершины.
[48:26.140 --> 48:27.140]  Хорошо.
[48:27.140 --> 48:28.140]  Больше нет.
[48:29.140 --> 48:35.140]  Так что получается, здесь тоже можно говорить о дереве суфиксных сынов.
[48:37.140 --> 48:42.140]  Причем у этого дерева есть маленькие приятные свойства.
[48:45.140 --> 48:48.140]  Вот давайте посмотрим, что нам вот эта лемма говорит.
[48:51.140 --> 48:53.140]  Эта лемма говорит о следующем.
[48:53.140 --> 48:56.140]  Она говорит, что жила была вершина, допустим.
[48:58.140 --> 48:59.140]  И теперь может быть какая-то вопрос.
[48:59.140 --> 49:03.140]  Да, у нее может быть куда-то там суфиксные ссылки ведет, может это стартовая вершина.
[49:03.140 --> 49:05.140]  А теперь внимание, вопрос.
[49:06.140 --> 49:09.140]  А сколько у нее детей?
[49:13.140 --> 49:16.140]  По суфиксам всегда.
[49:16.140 --> 49:23.140]  Вот допустим, что это вот у нас класс эквивалентности P, причем тут P равно логисту этого класса эквивалентности.
[49:25.140 --> 49:27.140]  Вот это вот типо P, да?
[49:30.140 --> 49:31.140]  Тогда мы знаем вот что.
[49:31.140 --> 49:32.140]  У нее два варианта.
[49:32.140 --> 49:34.140]  Либо P это префикс S.
[49:37.140 --> 49:41.140]  Либо у этого, это P это префикс С.
[49:41.140 --> 49:46.140]  Либо у этого, это P можно продолжить влево двумя разными способами.
[49:46.140 --> 49:47.140]  Хотя бы двумя.
[49:48.140 --> 49:56.140]  Но заметим, что если эти два способа есть, то на самом деле из этих способов в P обязательно ведет суфиксная ссылка.
[49:56.140 --> 49:57.140]  Обратите внимание.
[49:59.140 --> 50:02.140]  Ну что, рассмотрим класс эквивалентности вот этого вот AP, да?
[50:02.140 --> 50:05.140]  Так как P логисту, то P этому AP не эквивалентен.
[50:05.140 --> 50:08.140]  Значит из этого класса эквивалентности суфиксная ссылка не эквивалентна.
[50:08.140 --> 50:12.140]  То есть смотрите, то есть можно, видите, с другой стороны смотреть на самом деле на это.
[50:12.140 --> 50:21.140]  То есть можно смотреть, что если мы расширяем подстроки влево, то как бы каждая суфиксная ссылка ведущая в P это как бы продолжение по какой-нибудь букве.
[50:22.140 --> 50:23.140]  Понимаете, да?
[50:26.140 --> 50:30.140]  То есть собственно это приводит нас к маленькой приятной вещи.
[50:31.140 --> 50:32.140]  Вот.
[50:33.140 --> 50:36.140]  То есть собственно это приводит нас к маленькой приятной вещи.
[50:37.140 --> 50:45.140]  Что у очень, что у почти всех, ну что у большого количества вершин есть хотя бы два ребёнка.
[50:48.140 --> 50:50.140]  Ну утверждение можно сформировать так.
[50:51.140 --> 50:52.140]  Утверждение.
[50:52.140 --> 50:53.140]  Утверждение.
[50:58.140 --> 51:15.140]  То есть количество вершин с менее, не более чем одним ребёнком в дереве суфиксных ссылок,
[51:15.140 --> 51:31.140]  в дереве суф, не превосходят, не превосходят чего?
[51:38.140 --> 51:39.140]  Включать количество префиксов.
[51:40.140 --> 51:41.140]  А сколько у нас префиксов?
[51:42.140 --> 51:43.140]  Хотя бы N-1.
[51:45.140 --> 51:46.140]  На S-1.
[51:47.140 --> 51:49.140]  Ну да, можно сказать S-1.
[51:50.140 --> 51:52.140]  Но я даже уточню.
[51:54.140 --> 51:55.140]  Надо сказать S.
[51:55.140 --> 51:57.140]  Я бы даже, ну вот.
[51:58.140 --> 51:59.140]  Я бы даже так.
[52:00.140 --> 52:08.140]  Не превосходит S, модуля S, если S не равно просто a в степени N.
[52:09.140 --> 52:11.140]  Ну а в степени модуля в смысле.
[52:11.140 --> 52:24.140]  Ну потому что заметим, что если у строки хотя бы два символа, то в корень ведёт как минимум две ссылочки.
[52:25.140 --> 52:26.140]  Ну потому что заметим.
[52:27.140 --> 52:31.140]  Сколько детей у стартовой вершины?
[52:32.140 --> 52:33.140]  Ответ.
[52:34.140 --> 52:36.140]  Ровно столько, сколько различных символов встречается в строке.
[52:37.140 --> 52:38.140]  Логично, да?
[52:39.140 --> 52:47.140]  Вот, поэтому если у нас S не равно a, то у стартовой вершины хотя бы два ребёнка есть.
[52:48.140 --> 52:50.140]  Поэтому детей не более чем S.
[52:52.140 --> 53:02.140]  Ну вот и, ну и соответственно, ну здесь уже не интересно, равно модуля S плюс один иначе.
[53:08.140 --> 53:09.140]  Ну, кстати, на эту тему.
[53:10.140 --> 53:13.140]  А давайте себе вообразим, как выглядит суффиксный автомат для строки A.
[53:15.140 --> 53:16.140]  Как он выглядит?
[53:20.140 --> 53:24.140]  Ну просто последовательность, типа a шага, а свинца на 1 назад.
[53:25.140 --> 53:28.140]  Ну да, в полном соответствии с, действительно, названием.
[53:32.140 --> 53:33.140]  Вот как-то так.
[53:33.140 --> 53:34.140]  Вот как-то так.
[53:35.140 --> 53:38.140]  Если у нас строка A.
[53:41.140 --> 53:44.140]  И соответственно все вершины терминальны.
[53:46.140 --> 53:50.140]  Терминал, терминал.
[53:51.140 --> 53:54.140]  Ну и тупой вопрос суффиксной ссылки, как выглядит.
[53:58.140 --> 54:00.140]  Назад через 1 шаг.
[54:01.140 --> 54:03.140]  Прямо цепочкой.
[54:10.140 --> 54:13.140]  Да, но это вот конкретно отдельный случай.
[54:17.140 --> 54:23.140]  Но как это ни странно, через суффиксные ссылки мы пришли к важной мистической теории.
[54:24.140 --> 54:29.140]  Если у нас строка равна a, то количество состояний в ней равно модуле S плюс один.
[54:31.140 --> 54:34.140]  Ну теперь внимание, вопрос.
[54:35.140 --> 54:43.140]  Если у вас есть дерево, в котором количество вершин с одним или менее вебетком не превосходит в модуле S.
[54:44.140 --> 54:48.140]  А сколько в нем может быть вершин всего?
[54:57.140 --> 54:58.140]  Наверное.
[55:00.140 --> 55:04.140]  Логика очень простая. Как выглядит дерево?
[55:05.140 --> 55:08.140]  У нас дерево в некоторых вершинах развитвляется.
[55:09.140 --> 55:12.140]  Вот у нас есть корень, допустим он развитвился, у нас есть 2 вершины.
[55:13.140 --> 55:15.140]  В каждой из них цепочка идет, идет, идет и тоже развитвляется.
[55:16.140 --> 55:18.140]  Разветвляется, потом развитвляется и так далее.
[55:19.140 --> 55:22.140]  То есть в итоге у нас каждая развилка увеличивает количество веточек хотя бы на одну.
[55:23.140 --> 55:26.140]  А если там развилка тройная, то на две. Если четверная, то на три и так далее.
[55:26.140 --> 55:33.100]  и так далее. Но в самом конце у нас на этих цепочечек должно быть n, получается, не более
[55:33.100 --> 55:40.060]  чем n. Следовательно, развилок было не более чем n-1. То есть могло быть вот такое доказательство,
[55:40.060 --> 55:50.300]  хотя, наверное, на дискогне вы сдавали что-то более строго индукционное. Не сдавали? А, ну ладно,
[55:50.300 --> 55:55.140]  видимо, подразумевается, что это задачка на оценку 1.
[55:56.140 --> 56:05.940]  Это можно просмотреть? Почему, доказали? Нет, мы его доказали. Почему? Потому что, откуда мы это взяли? Потому что
[56:05.940 --> 56:13.060]  там доказательство такое. Рассмотрим вершину, рассмотрим ее логнист. Да? Да. Так, если у нее не двое детей,
[56:13.060 --> 56:21.060]  значит P является ее префиксом S. Не двое, а в смысле один? Один или менее. И да. Это может быть только в том
[56:21.060 --> 56:28.060]  случае, если P-префикс С. Ну да. Кстати, эти утверждения, думаю, не противоречат. Может быть и то, и то
[56:28.060 --> 56:40.660]  одновременно. Вполне себе. Вот тем не менее. А, за примером даже далеко ходить не надо. А, ну вот, пожалуйста,
[56:40.660 --> 56:47.940]  вот у вас был префикс А, видите, да? То есть А с одной стороны префикс, а с другой стороны двое детей у него есть.
[56:47.940 --> 56:57.900]  Вот. Вот. Поэтому утверждения, ну, по префиксу у нас всего не более чем С, а мы еще и докрутили, что вообще
[56:57.900 --> 57:04.260]  С плюс один, но, как бы, если хотя бы два символа есть, то тогда пустая класса квалифтости пустой строки имеет
[57:04.260 --> 57:17.140]  хотя бы двух детей. Поэтому выкидываем. Поэтому следствие, мистическое следствие, я его только
[57:17.460 --> 57:35.980]  напишу. Значит, если модуль С, если плена строки больше либо равно двух, больше либо равно, то размер,
[57:35.980 --> 57:52.980]  только количество вершин дауг от С не превосходит два С минусы.
[58:02.140 --> 58:02.640]  Неплохо.
[58:05.980 --> 58:13.180]  Да, что-то как-то, да, знаете, что-то как-то тихой сапой даже получилось. То есть, знаете, тривиально, то есть типа простое
[58:13.180 --> 58:18.580]  наблюдение, простое наблюдение, простое понятие, простое наблюдение. Опа! Автомат линейный.
[58:18.580 --> 58:23.580]  Почему мы утверждаем еще раз, что нас равно С плюс один иначе?
[58:23.580 --> 58:28.300]  Потому что иначе это строка С вот эта а-а-а-а-а-а и автомат выглядит вот так.
[58:28.300 --> 58:30.140]  А, если С не равно, да, да, да, все нормально.
[58:30.140 --> 58:37.260]  Да, именно не равно. То есть вот мы внезапно доказали, что количества вершин в автомате оказывается мало.
[58:37.260 --> 58:45.220]  Два С минус один. В качестве сейчас еще одного такого, знаете, прикольного упражнения на понимание
[58:45.220 --> 58:55.420]  вообще автомата, мы сейчас выведем еще. Мы выведем еще такое интересное утверждение,
[58:55.420 --> 58:59.900]  так что из этого можно стереть. Господи, все так жалко стереть, если честно.
[58:59.900 --> 59:11.020]  Впрочем, это и неважно. Ну ладно, сейчас будет на самом деле мелочевочка по этому плану.
[59:11.020 --> 59:18.180]  Определение суффиксного автомата, наверное, мы уже выучили. Вот автомат хочется оставить.
[59:18.180 --> 59:32.700]  Просто есть еще мистическое утверждение. Если С, модуль С больше либо равно два, то размер
[59:32.700 --> 59:47.220]  даугат С прям равен два модуля С минус один, тогда и только тогда, когда С равно лежит в каком-то множестве.
[59:47.220 --> 59:59.020]  Вот загадка. А что же это за мистические строчки, для которых периодически?
[59:59.020 --> 01:00:16.780]  На высоких видах А, Б, Б, Б, Б, Б, Б. Чемой? Это откуда? Ну вот у нас, например... У вас на формалах был суффиксный автомат?
[01:00:16.780 --> 01:00:29.660]  У нас было задача, докажите, что количество вершин в таком дереве не больше, чем два С минус один.
[01:00:29.660 --> 01:00:39.380]  Мы это доказали очень странно. Вспользует суффиксный автомат, но странно.
[01:00:39.380 --> 01:00:52.180]  Ну, по сути, когда это раньше выполняется, нам нужно, чтобы все вершины с не более чем одним ребенком были уже листьями, да?
[01:00:52.180 --> 01:00:59.420]  Ну, да. То есть, чтобы не было вершин с ровно одним ребенком. Да, ну, во-первых, да. Во-первых, они... Ну, на самом деле, да.
[01:00:59.420 --> 01:01:11.100]  Ну, и еще, чтобы все, чтобы детей было ровно, чтобы таких вершин было ровно С. То есть, чтобы все непустые префиксы были как раз...
[01:01:11.100 --> 01:01:15.380]  Так, ну давайте рассмотрим. Ну, во-первых, так. Ну да. Есть такое, да.
[01:01:15.380 --> 01:01:24.700]  Более своими классными вариантов. Ну, желательно, да. Что-то получается, да, чтобы... Смотрите. То есть, надо, то есть, желательно, да.
[01:01:24.700 --> 01:01:36.900]  Ну, во-первых... Ну, давайте начнем с простого. Во-первых, нужно, чтобы развилок было ровно С-1. Заметим, что если у нас есть хотя бы одна тройная развилка, то развилок не более чем С-2, правда?
[01:01:36.900 --> 01:01:49.980]  Тогда это означает, что, например, корень, корень явно является развилкой не более чем на 2. Ну, на самом деле, да. Поэтому сразу можно рассмотреть в случае. Давайте так.
[01:01:49.980 --> 01:02:00.300]  То есть, теперь вопрос... То есть, из этого следует, что различных символов у нас в строке может быть не более чем 2. Логично, да? Не более чем 2.
[01:02:00.300 --> 01:02:09.860]  Ну, если там всего один различный символ, то модуль С плюс один нас не интересует. Ну, потому что... Когда модуль С плюс один равен два модуль С минус один?
[01:02:09.860 --> 01:02:20.940]  Ну, да. То есть, поэтому нам придется добавить сюда строку вида, там, допустим, АА.
[01:02:20.940 --> 01:02:33.140]  Но, если брать, я думал вообще не написать, что модуля С больше чем два, чтобы было красивее. Ну, и так и быть, вот, слушайте. Я двойки рассматриваю, так и быть.
[01:02:33.220 --> 01:02:43.940]  И теперь, если у нас символов больше чем один, то их должно быть ровно два. Ну, хотя бы два. Ну, а теперь следующее свойство.
[01:02:43.940 --> 01:02:58.740]  То есть, у нас, точнее, должно быть ровно два символа, и при этом должно быть, что все префиксы, все состояния соответствующих префиксам, они являются листьями.
[01:02:58.940 --> 01:03:01.340]  А что означает, что префикс является листом?
[01:03:12.340 --> 01:03:13.340]  Это не период?
[01:03:13.940 --> 01:03:15.340]  Нет, что ли?
[01:03:15.340 --> 01:03:18.340]  Почему? Откуда у вас тут понятие период вообще период?
[01:03:19.540 --> 01:03:21.340]  Значит, если из префикса...
[01:03:21.340 --> 01:03:22.340]  Ой.
[01:03:25.340 --> 01:03:27.540]  Что ни к одному префику слева нельзя добавить ничего.
[01:03:28.340 --> 01:03:32.740]  Для каждого префикса, суфиксная ссылка ведет вопсилами.
[01:03:32.740 --> 01:03:34.740]  То есть, обратите внимание, да.
[01:03:36.740 --> 01:03:37.740]  Нет, правда, нет.
[01:03:37.740 --> 01:03:39.740]  Нет. Это не то же самое.
[01:03:39.740 --> 01:03:41.740]  Значит, суфиксная ссылка...
[01:03:41.740 --> 01:03:43.740]  Значит, у него не меняются такие ссылки.
[01:03:44.740 --> 01:03:46.740]  Да, а что значит, что в вершину не ведет суфиксную ссылку?
[01:03:46.740 --> 01:03:48.740]  Значит, что нельзя продлить слева.
[01:03:48.740 --> 01:03:56.740]  Да, то есть ни один префикс, ни к одному префиксу нельзя добавить слева символ, так, чтоб получился еще одна кастрада, правильно?
[01:03:56.740 --> 01:04:00.740]  чтобы получилось по строка s. Понятно, о чем я говорю?
[01:04:00.740 --> 01:04:02.740]  Нет.
[01:04:02.740 --> 01:04:04.740]  Ну, давайте думать.
[01:04:04.740 --> 01:04:08.740]  Смотрите, что такое суффиксная ссылка, ведущая в вершину p, где p это лонгест.
[01:04:08.740 --> 01:04:17.740]  То есть, у нас ведет вершина вот отсюда, это означает, что к p можно прерисовать какой-то символ a и получить вот это состояние, правда?
[01:04:17.740 --> 01:04:19.740]  Точнее, строку, лежащую в этом состоянии, да?
[01:04:19.740 --> 01:04:27.740]  То есть, каждая суффиксная ссылка соответствует продолжению лонгеста на один символ влево, так, чтобы строка осталась под строкой, правда?
[01:04:31.740 --> 01:04:33.740]  Так, чтобы это стало выкраской?
[01:04:33.740 --> 01:04:37.740]  Нет, так, чтобы под строка осталась под строкой. Вот p была под строкой, да?
[01:04:37.740 --> 01:04:38.740]  Да.
[01:04:38.740 --> 01:04:44.740]  Так вот, вот эта суффиксная ссылка, так сказать, по символу a, означает, что ap это тоже под строка строки s.
[01:04:44.740 --> 01:04:54.740]  Вот. Если две ведут, значит, как бы, таких продолжений два. Ну, если три, то три, четыре, четыре и так далее. Логично, да?
[01:04:54.740 --> 01:04:56.740]  А что означает, что он больно?
[01:04:58.740 --> 01:05:00.740]  Влево, ничего нельзя выписать.
[01:05:00.740 --> 01:05:03.740]  Да. То есть, получается, строка не просто, но тогда что это означает?
[01:05:03.740 --> 01:05:08.740]  Это означает, что под строка префикс, причем у нее единственное вхождение, это, собственно, в префиксе, правда?
[01:05:08.740 --> 01:05:10.740]  А теперь, смотрите.
[01:05:10.740 --> 01:05:12.740]  И это должно выполняться у всех суффиксов.
[01:05:12.740 --> 01:05:15.740]  В том числе и у суффикса длины 1.
[01:05:15.740 --> 01:05:20.740]  Вот, предположим, что этот суффикс имеет символ a без ограничения в обществе, да?
[01:05:20.740 --> 01:05:26.740]  Тогда получается, что это под строка a больше нигде не встречается.
[01:05:26.740 --> 01:05:32.740]  То есть, если она встречалась где-то, то тут суффиксная ссылка у этого префикса бы откровенно была.
[01:05:32.740 --> 01:05:34.740]  Получается, ее нигде нет.
[01:05:34.740 --> 01:05:36.740]  То есть, получается, что это за мистическая строка?
[01:05:36.740 --> 01:05:38.740]  Получается, ее нигде нет.
[01:05:38.740 --> 01:05:40.740]  То есть, получается, что это за мистическая строка?
[01:05:40.740 --> 01:05:44.740]  У которой всего два различных символа, причем первый символ больше нигде не встречается.
[01:05:44.740 --> 01:05:46.740]  A...
[01:05:52.740 --> 01:05:53.740]  Вот.
[01:05:56.740 --> 01:06:00.740]  То есть, соответственно, получается A...
[01:06:00.740 --> 01:06:04.740]  И AB в степени получается K.
[01:06:04.740 --> 01:06:13.740]  где a и b лежат в алфавите, а не равно b, естественно, и, соответственно, k – натуральное число.
[01:06:13.740 --> 01:06:17.740]  Ну, натуральное, понятно, в русском смысле.
[01:06:17.740 --> 01:06:21.740]  Что значит в русском смысле?
[01:06:21.740 --> 01:06:28.740]  В русском смысле – да, потому что там, в какой-нибудь Европе, 0 – это натуральное число.
[01:06:29.740 --> 01:06:31.740]  Да, вот такой сын.
[01:06:31.740 --> 01:06:33.740]  И на формалке.
[01:06:33.740 --> 01:06:36.740]  На формалке с Матлоги 0 тоже натуральное число.
[01:06:36.740 --> 01:06:44.740]  Ну, значит, да. Значит, Матлоги исповедуют другую школу.
[01:06:44.740 --> 01:06:46.740]  Ну, окей, ладно.
[01:06:46.740 --> 01:06:48.740]  Ну, поэтому вот тут и говоримся.
[01:06:48.740 --> 01:06:53.740]  Хотя тут уже, да, я, ладно, ладно, обычно я тут перестраховываюсь и тогда пишу z+.
[01:06:53.740 --> 01:06:54.740]  Всё.
[01:06:54.740 --> 01:06:55.740]  А ещё bb?
[01:06:55.740 --> 01:06:57.740]  А, а – это символ, я понял.
[01:06:57.740 --> 01:06:59.740]  Да, оно же bb.
[01:06:59.740 --> 01:07:02.740]  Ну, понятно, что если кто-то пишет b, а разницы не будет.
[01:07:02.740 --> 01:07:05.740]  Или там xzzzzzz.
[01:07:05.740 --> 01:07:07.740]  А ещё я могу написать.
[01:07:07.740 --> 01:07:08.740]  Вот.
[01:07:08.740 --> 01:07:10.740]  Слушайте, красота.
[01:07:10.740 --> 01:07:14.740]  Красота получается у нас такая.
[01:07:14.740 --> 01:07:19.740]  Но, на самом деле, линейность этим даже не ограничивается.
[01:07:19.740 --> 01:07:20.740]  Ну, что хорошо.
[01:07:20.740 --> 01:07:22.740]  Состояние у нас линейное количество.
[01:07:22.740 --> 01:07:25.740]  В общем, заметим, от размера алфавита, кстати, состоит количество состояний.
[01:07:25.740 --> 01:07:27.740]  Вот такое ограничение не зависит никак.
[01:07:30.740 --> 01:07:32.740]  Ну, что с ребрами?
[01:07:37.740 --> 01:07:39.740]  Сколько же может быть ребр?
[01:07:41.740 --> 01:07:42.740]  Ну, автомат.
[01:07:42.740 --> 01:07:43.740]  Субъективный ссылок?
[01:07:43.740 --> 01:07:46.740]  Не-не-не, ну, субъективный ссылок, понятно, не более, чем 2s-2.
[01:07:49.740 --> 01:07:50.740]  Обычно?
[01:07:50.740 --> 01:07:51.740]  Обычно, скажи так.
[01:07:52.740 --> 01:07:57.740]  Ну, нам тоже же интересно, что, как бы, матчики, что у нас какую-то память жрут.
[01:07:57.740 --> 01:08:01.740]  И спрашивают, сколько памяти они сожрут.
[01:08:01.740 --> 01:08:03.740]  Там граф планарный, почему-то.
[01:08:05.740 --> 01:08:09.740]  Значит, их не более, чем либо минус 6.
[01:08:10.740 --> 01:08:11.740]  Ну.
[01:08:16.740 --> 01:08:18.740]  Один был, да, конечно, два графа.
[01:08:18.740 --> 01:08:19.740]  Неделька.
[01:08:21.740 --> 01:08:22.740]  Я бы упоминал.
[01:08:22.740 --> 01:08:23.740]  Кто упоминал?
[01:08:24.740 --> 01:08:26.740]  Здесь, ну, вот, мы вот так строили.
[01:08:26.740 --> 01:08:27.740]  Ну.
[01:08:28.740 --> 01:08:32.740]  Здесь мы его, я бы сказал, мы рассмотрели три примера, и везде он получился планарным.
[01:08:32.740 --> 01:08:33.740]  Да.
[01:08:33.740 --> 01:08:36.740]  Ну, как бы, возможно, это случайное совпадение.
[01:08:37.740 --> 01:08:40.740]  Но если тут про 3 и минус 6, я бы сказал, скажу, нет, у нас не будет такой.
[01:08:40.740 --> 01:08:42.740]  Оценки мы докажем, что бывает получше.
[01:08:43.740 --> 01:08:44.740]  То есть он не планарный?
[01:08:44.740 --> 01:08:45.740]  Нет.
[01:08:45.740 --> 01:08:46.740]  Хорошо.
[01:08:46.740 --> 01:08:47.740]  Так что нет, да.
[01:08:47.740 --> 01:08:49.740]  Так что не надо пользоваться планарным, да.
[01:08:49.740 --> 01:08:50.740]  Не будет.
[01:08:50.740 --> 01:08:51.740]  Планарность или планарный граф?
[01:08:51.740 --> 01:08:52.740]  Хотя, да, это фильм, да.
[01:08:53.740 --> 01:08:54.740]  Да, это фильм всегда.
[01:08:54.740 --> 01:08:55.740]  Поэтому, да, очень важно.
[01:08:55.740 --> 01:08:58.740]  Когда вы будете делать тесты на задачу с решением суффиксного автомата,
[01:08:58.740 --> 01:09:01.740]  обязательно вставляйте тесты, где суффиксный автомат не планарен.
[01:09:01.740 --> 01:09:04.740]  А то мало ли кто придумает решение,
[01:09:04.740 --> 01:09:07.740]  в котором будет пользоваться тем, что суффиксный автомат планарен.
[01:09:08.740 --> 01:09:11.740]  Нет, это же надо еще задачу такую придумать, чтобы так можно было.
[01:09:13.740 --> 01:09:16.740]  Что бы желать ошибки неискусственные, типа, возьмите суффиксный автомат,
[01:09:16.740 --> 01:09:19.740]  там, я не знаю, и сделайте что-нибудь там на нем, как на графе.
[01:09:21.740 --> 01:09:22.740]  Так.
[01:09:23.740 --> 01:09:24.740]  Ну, давайте думать.
[01:09:25.740 --> 01:09:27.740]  Реально, а сколько тут ребер вообще?
[01:09:32.740 --> 01:09:33.740]  Вот.
[01:09:33.740 --> 01:09:35.740]  Ну, значит, это мы будем сделать так.
[01:09:37.740 --> 01:09:40.740]  Значит, чтобы понять, сколько у нас ребер будет,
[01:09:42.740 --> 01:09:43.740]  мы будем говорить так.
[01:09:44.740 --> 01:09:45.740]  Смотрите.
[01:09:45.740 --> 01:09:47.740]  Запустим DFS.
[01:09:47.740 --> 01:09:50.740]  Только смотрите, у нас не стартовые вершины,
[01:09:50.740 --> 01:09:53.740]  а из, так сказать, финишной.
[01:09:54.740 --> 01:09:58.740]  Ну, заметим, что у нас в автомате всегда будет
[01:09:58.740 --> 01:10:01.740]  ровно одна вершина, из которой ребер не торчит.
[01:10:02.740 --> 01:10:05.740]  Ну, класс эквалидности и, соответственно, всей строки.
[01:10:07.740 --> 01:10:09.740]  Он так и называется.
[01:10:15.740 --> 01:10:16.740]  Да.
[01:10:18.740 --> 01:10:19.740]  А теперь смотрите.
[01:10:20.740 --> 01:10:24.740]  Ну, заметим, что до этой вершины можно найти из всех вершин.
[01:10:26.740 --> 01:10:27.740]  Ну, доказательств очень простые.
[01:10:27.740 --> 01:10:29.740]  Из каждой вершины давайте будем в тупую уйти до тех пор,
[01:10:29.740 --> 01:10:30.740]  пока не упрёмся в тупик.
[01:10:30.740 --> 01:10:31.740]  А это единственный тупик.
[01:10:31.740 --> 01:10:33.740]  Ну, потому что, если бы было два тупика, то, наверное,
[01:10:33.740 --> 01:10:37.740]  либо один из этих тупиков не терминальный, мы бы его вытянули просто,
[01:10:38.740 --> 01:10:44.740]  либо эти два терминальных, казались бы, все терминальные тупики – это эквивалидные вершины.
[01:10:44.740 --> 01:10:45.740]  Да.
[01:10:45.740 --> 01:10:46.740]  Вот.
[01:10:46.740 --> 01:10:48.740]  Вот, видите, то есть типичная математика.
[01:10:48.740 --> 01:10:52.740]  То есть, видите, ничего сложного, но умные фразы уже появляются.
[01:10:53.740 --> 01:10:55.740]  Можно как всегда.
[01:10:56.740 --> 01:10:57.740]  Так вот.
[01:10:57.740 --> 01:11:00.740]  Поэтому можно запустить, так сказать, ДФС по обратным ребрам.
[01:11:04.740 --> 01:11:05.740]  Вот.
[01:11:08.740 --> 01:11:10.740]  Ну, примерно так это будет выглядеть.
[01:11:10.740 --> 01:11:11.740]  Вот.
[01:11:12.740 --> 01:11:15.740]  Вот тут где-то стартовая вершина вот эта будет.
[01:11:18.740 --> 01:11:19.740]  Вот.
[01:11:20.740 --> 01:11:24.740]  Ну, заметим, что в это дерево ДФС по обратным ребрам войдёт.
[01:11:24.740 --> 01:11:25.740]  Сколько ребра?
[01:11:26.740 --> 01:11:31.740]  Не более чем два модулес минус два.
[01:11:31.740 --> 01:11:32.740]  Логично, да?
[01:11:32.740 --> 01:11:37.740]  Ну, если вершин всего не более чем два с минус один, то, наверное, и в дереве ребра не более чем два с минус два, правда?
[01:11:38.740 --> 01:11:39.740]  Вот.
[01:11:41.740 --> 01:11:42.740]  Так вот.
[01:11:43.740 --> 01:11:46.740]  Но в автомате, естественно, есть и другие ребра, которые в этот ДФС не вошли.
[01:11:51.740 --> 01:11:52.740]  Вот.
[01:11:52.740 --> 01:11:53.740]  Но заметим теперь следующее.
[01:11:54.740 --> 01:11:56.740]  Рассмотрим, что происходит.
[01:11:57.740 --> 01:11:58.740]  Вот.
[01:11:58.740 --> 01:12:00.740]  Но заметим теперь следующее.
[01:12:01.740 --> 01:12:03.740]  Рассмотрим каждое такое ребро.
[01:12:03.740 --> 01:12:04.740]  Вот, допустим.
[01:12:10.740 --> 01:12:11.740]  Так вот.
[01:12:11.740 --> 01:12:16.740]  Каждому ребру, ну, заметим, что до каждой вершины можно дойти из стартовой вершины, правда?
[01:12:17.740 --> 01:12:18.740]  Поэтому идея такая.
[01:12:18.740 --> 01:12:20.740]  Вот, допустим, мы тут как-нибудь можем дойти.
[01:12:21.740 --> 01:12:22.740]  Вот так, вот так, вот так.
[01:12:22.740 --> 01:12:23.740]  Вот так, вот так, вот так.
[01:12:23.740 --> 01:12:24.740]  Я так обалдусь.
[01:12:24.740 --> 01:12:25.740]  Не обязательно по оттоку черным ребрам.
[01:12:25.740 --> 01:12:27.740]  Эти тоже можно использовать, пожалуйста.
[01:12:28.740 --> 01:12:29.740]  Вот.
[01:12:30.740 --> 01:12:31.740]  Так вот.
[01:12:31.740 --> 01:12:38.740]  Я поверю, что каждому такому ребру можно поставить в соответствие вот такого рода путь.
[01:12:38.740 --> 01:12:39.740]  Смотрите.
[01:12:41.740 --> 01:12:46.740]  Значит, путь, он будет состоять, он как угодно доходит до этой вершины, проходит по этому ребру.
[01:12:46.740 --> 01:12:49.740]  А дальше, обратите внимание, идет...
[01:12:53.740 --> 01:12:56.740]  Строго по этому дереву ДФСа.
[01:12:59.740 --> 01:13:00.740]  Я запутался.
[01:13:01.740 --> 01:13:03.740]  Мы пустили ДФС из финишной.
[01:13:03.740 --> 01:13:04.740]  Ну, смотрите.
[01:13:05.740 --> 01:13:17.740]  Теперь я каждому ребру, не вошедшему дереву ДФС, сопоставляю путь, который из эпсилона, ну, из стартовой вершины в тубик, который проходит через это ребро.
[01:13:17.740 --> 01:13:19.740]  Причем после этого ребра он ведет строго по дереву ДФС.
[01:13:19.740 --> 01:13:20.740]  Доет, но как угодно.
[01:13:20.740 --> 01:13:21.740]  Да.
[01:13:21.740 --> 01:13:22.740]  Да, хорошо.
[01:13:24.740 --> 01:13:25.740]  Тогда заметим следующее.
[01:13:26.740 --> 01:13:33.740]  Что мы различным черным ребром поставили в соответствие различные пути, правда?
[01:13:35.740 --> 01:13:38.740]  Ну, потому что каждый путь задается по каждому пути.
[01:13:38.740 --> 01:13:40.740]  Можно посмотреть, по какому ребру мы его построили.
[01:13:40.740 --> 01:13:42.740]  Это последнее черное ребро на пути, правда?
[01:13:43.740 --> 01:13:44.740]  Да.
[01:13:44.740 --> 01:13:49.740]  А еще можно заметить, что чем, что такое строка соответствующей этому пути?
[01:13:51.740 --> 01:14:01.740]  Это относится к словам, в которых одинаковый суффис.
[01:14:03.740 --> 01:14:04.740]  Чего?
[01:14:04.740 --> 01:14:06.740]  Что строка этому нужен?
[01:14:06.740 --> 01:14:07.740]  А, строка пути.
[01:14:07.740 --> 01:14:08.740]  Ладно.
[01:14:13.740 --> 01:14:15.740]  Что же это за строка такая?
[01:14:21.740 --> 01:14:33.740]  Окачивается некоторый...
[01:14:51.740 --> 01:15:10.740]  Ну, мы хотим сказать, что у каждого решина, наверное, указывается параметр степь.
[01:15:10.740 --> 01:15:11.740]  Поэтому...
[01:15:11.740 --> 01:15:21.740]  Пусть черное ребро входит в решину У.
[01:15:21.740 --> 01:15:22.740]  Тогда...
[01:15:29.740 --> 01:15:31.740]  Пусть каждый классик ролевый степь входит куда?
[01:15:33.740 --> 01:15:38.740]  Ну, у нас в последствии черное ребро, ребро в котором мы построили, разрезует то, что мы...
[01:15:42.740 --> 01:15:44.740]  Нашли новый классик уремности подобный.
[01:15:45.740 --> 01:15:46.740]  Чего?
[01:15:46.740 --> 01:15:47.740]  Почему?
[01:15:47.740 --> 01:15:49.740]  У черного ребра могут входить и в одну и ту же вершину.
[01:15:54.740 --> 01:15:59.740]  Я спрашиваю не что такое ребро, а чем является строка, которая у нас тут.
[01:16:01.740 --> 01:16:02.740]  Вот что это за строка?
[01:16:03.740 --> 01:16:06.740]  Что такое строка, по которой мы прошли стартовые вершины в тупе?
[01:16:06.740 --> 01:16:08.740]  Что про нее можно сказать?
[01:16:11.740 --> 01:16:12.740]  Совершенно верно.
[01:16:12.740 --> 01:16:17.740]  Причем, можно даже более сильно сказать это суффикс строки С, эквивалентный самой строки С.
[01:16:17.740 --> 01:16:19.740]  Но это нам сейчас пока даже не надо.
[01:16:19.740 --> 01:16:25.740]  Хотя вот можем учесть, что это суффикс строки С, который больше нигде, кроме как в конце строки С, не встречается.
[01:16:25.740 --> 01:16:27.740]  Но это же неважно.
[01:16:27.740 --> 01:16:29.740]  А важно другое.
[01:16:29.740 --> 01:16:31.740]  А сколько у нас таких суффиксов?
[01:16:31.740 --> 01:16:33.740]  Их не более чем модуль С.
[01:16:33.740 --> 01:16:35.740]  Потому что не пустой суффикс строки С.
[01:16:35.740 --> 01:16:37.740]  Их не более чем модуль С.
[01:16:37.740 --> 01:16:38.740]  Правда?
[01:16:38.740 --> 01:16:39.740]  Не пустой суффикс строки С.
[01:16:39.740 --> 01:16:41.740]  Их не более чем модуль С.
[01:16:42.740 --> 01:16:50.740]  Но при этом заметим, что один из таких суффиксов, по одному из таких суффиксов, уже ДФС дошел до стартовых вершин.
[01:16:51.740 --> 01:17:00.740]  Поэтому получается, что отсюда следует, что получается вот этих черных ребр не более чем модуль С-1.
[01:17:00.740 --> 01:17:28.740]  То есть поэтому возникает сразу естественное утверждение, что действительно если модуль С больше либо равно 2, то размер, так сказать, количество вершин, то есть количество ребр не превосходит 3 модуль С-3.
[01:17:30.740 --> 01:17:40.740]  Причем...
[01:17:40.740 --> 01:17:42.740]  А мы тут сделали очень грубую оценку, да?
[01:17:42.740 --> 01:17:43.740]  Ну почему?
[01:17:43.740 --> 01:17:45.740]  Просто различные суффиксы не более чем С.
[01:17:45.740 --> 01:17:47.740]  Каждый такой путь черная вершина.
[01:17:47.740 --> 01:17:48.740]  Ну давайте вот...
[01:17:48.740 --> 01:17:50.740]  А давайте думать просто.
[01:17:50.740 --> 01:17:52.740]  Давайте думать, насколько центр эта груба.
[01:17:52.740 --> 01:18:02.740]  Причем давайте говорить, что модуль Е да угод С равно 3 модуль С-3 тогда и только тогда, когда С лежит.
[01:18:02.740 --> 01:18:04.740]  И вот теперь давайте думать.
[01:18:04.740 --> 01:18:07.740]  А что это за мистическая строка должна быть?
[01:18:12.740 --> 01:18:17.740]  Ну во-первых начнем с того, что в ней прям жестко должно быть 2С-1 вершин.
[01:18:17.740 --> 01:18:20.740]  Правда?
[01:18:20.740 --> 01:18:23.740]  Должно быть?
[01:18:23.740 --> 01:18:27.740]  Что? Откуда? Ну нет.
[01:18:27.740 --> 01:18:29.740]  Это же просто строка С какая-то.
[01:18:29.740 --> 01:18:31.740]  А, причем я понял.
[01:18:31.740 --> 01:18:39.740]  Ну просто смотрите, то есть помните у нас синий ребр ровно количество вершин минус 1 и еще не более чем модуль С-1 черный ребр, да?
[01:18:39.740 --> 01:18:40.740]  Да.
[01:18:40.740 --> 01:18:45.740]  Тогда чтобы 3С-3 достигалось надо чтобы синий ребр был 2С-2.
[01:18:45.740 --> 01:18:49.740]  Ну тогда и вершин должно быть 2С-1.
[01:18:49.740 --> 01:18:52.740]  Тогда получается у нас...
[01:18:55.740 --> 01:18:58.740]  Ну вот тогда у нас получается что...
[01:18:58.740 --> 01:18:59.740]  Что у нас получается?
[01:18:59.740 --> 01:19:01.740]  Это же самое, что С это либо А, либо...
[01:19:01.740 --> 01:19:02.740]  Ну то есть С...
[01:19:02.740 --> 01:19:07.740]  То есть необходимое условие, что С лежит где-то в этом росте.
[01:19:07.740 --> 01:19:11.740]  Ну давайте проверять АА нам подходит? Сколько ребр в автомате АА?
[01:19:27.740 --> 01:19:28.740]  Хорошо.
[01:19:28.740 --> 01:19:29.740]  Это два.
[01:19:29.740 --> 01:19:35.740]  Ну два, вот просто. Автомата А, вот на самом деле вот эти два ребра не счастливые.
[01:19:35.740 --> 01:19:37.740]  Поэтому АА нам не подходит.
[01:19:39.740 --> 01:19:43.740]  Сколько у нас ребр будет в АВ степени К?
[01:19:46.740 --> 01:19:48.740]  Ну в принципе вот пример уже был, да?
[01:19:48.740 --> 01:19:50.740]  То есть заметим, что здесь у нас...
[01:19:50.740 --> 01:19:52.740]  Сколько у нас ребра?
[01:19:52.740 --> 01:19:56.740]  Ну да, то есть здесь ребр будет получается 2К-1.
[01:19:57.740 --> 01:19:59.740]  А в каких случаях тогда это...
[01:20:00.740 --> 01:20:03.740]  3 модуль С минус 3.
[01:20:03.740 --> 01:20:04.740]  Ведь что такое С?
[01:20:04.740 --> 01:20:05.740]  Это равно...
[01:20:05.740 --> 01:20:07.740]  Ну вот 3К, короче, можно писать.
[01:20:07.740 --> 01:20:10.740]  Потому что модуль С это К плюс 1, правда?
[01:20:13.740 --> 01:20:14.740]  Понимаете, да?
[01:20:14.740 --> 01:20:16.740]  Модуль С К плюс 1.
[01:20:16.740 --> 01:20:18.740]  Да, да, согласен.
[01:20:18.740 --> 01:20:19.740]  Ну да.
[01:20:19.740 --> 01:20:22.740]  Но это эквивалент на тому, что К равно 1.
[01:20:22.740 --> 01:20:24.740]  К плюс 1 равно 3К, правда?
[01:20:24.740 --> 01:20:25.740]  Да.
[01:20:25.740 --> 01:20:28.740]  То есть получается 3С-3 достигается только в одном случае.
[01:20:29.740 --> 01:20:31.740]  Когда С равно АВ.
[01:20:38.740 --> 01:20:42.740]  То есть да, мораль 3С-3 это неточная оценка.
[01:20:43.740 --> 01:20:44.740]  Ну точнее так вот.
[01:20:44.740 --> 01:20:46.740]  Пример, конечно, есть.
[01:20:46.740 --> 01:20:50.740]  Но видите, он как бы не распространяется.
[01:20:50.740 --> 01:20:52.740]  То есть следствие такое.
[01:20:52.740 --> 01:20:57.740]  Если модуль С больше либо равно 3,
[01:20:57.740 --> 01:21:02.740]  то модуль Е даунг от С
[01:21:02.740 --> 01:21:07.740]  меньше либо равен даже 3 модуль С минус 4.
[01:21:09.740 --> 01:21:10.740]  Вот.
[01:21:12.740 --> 01:21:13.740]  Причем...
[01:21:14.740 --> 01:21:17.740]  А вот давайте теперь вот прежде чем пойдем на перерыв подумаем.
[01:21:17.740 --> 01:21:21.740]  Е даунг от С равно 3 модуль С минус 4.
[01:21:21.740 --> 01:21:22.740]  Тогда и только так.
[01:21:22.740 --> 01:21:24.740]  А когда С равно...
[01:21:24.740 --> 01:21:26.740]  Вот теперь давайте реально подумаем.
[01:21:27.740 --> 01:21:29.740]  А что это должна быть за строка?
[01:21:29.740 --> 01:21:32.740]  Вот 3С-3 у нас не получилось.
[01:21:37.740 --> 01:21:38.740]  Заметим, что...
[01:21:38.740 --> 01:21:42.740]  Ну заметим, что сколько вершин в этом автомате может быть?
[01:21:53.740 --> 01:21:56.740]  Ну хотя бы 2С-2.
[01:21:56.740 --> 01:21:57.740]  Да, хотя бы 2С-2.
[01:21:57.740 --> 01:21:59.740]  Ну потому что если 2 там...
[01:21:59.740 --> 01:22:00.740]  Нет, почему?
[01:22:00.740 --> 01:22:01.740]  Сейчас.
[01:22:03.740 --> 01:22:05.740]  Ну да, хотя получается да.
[01:22:07.740 --> 01:22:08.740]  Или этого уже все?
[01:22:10.740 --> 01:22:11.740]  Нет, ну как всякие.
[01:22:11.740 --> 01:22:14.740]  Ну вершин действительно хотя бы 2С-2.
[01:22:14.740 --> 01:22:17.740]  Потому что если вершин 2С-3, например, да,
[01:22:17.740 --> 01:22:20.740]  то синих ребер у нас получается 2С-4.
[01:22:20.740 --> 01:22:23.740]  И добавляем черных коих не более чем С-1,
[01:22:23.740 --> 01:22:25.740]  получается 3С-5 мало, правильно?
[01:22:26.740 --> 01:22:29.740]  То есть вершин должно быть хотя бы 2С-2.
[01:22:29.740 --> 01:22:32.740]  Но при С-3 вершин 2С-1 быть не может,
[01:22:32.740 --> 01:22:34.740]  мы поняли, что этого не хватает.
[01:22:36.740 --> 01:22:37.740]  Отлично.
[01:22:37.740 --> 01:22:40.740]  Значит, вершин должно быть 2С-2.
[01:22:42.740 --> 01:22:44.740]  Так, ну давайте думать.
[01:22:45.740 --> 01:22:47.740]  Вершин 2С-2.
[01:22:50.740 --> 01:22:52.740]  Но при этом, если...
[01:22:52.740 --> 01:22:57.740]  Вот, если вершин 2С-2, то мы замечаем, что...
[01:22:58.740 --> 01:23:01.740]  Вот, вершин 2С-2 и получается, что...
[01:23:02.740 --> 01:23:05.740]  что черный ребер должен быть ровно С-1.
[01:23:05.740 --> 01:23:06.740]  Видите, да?
[01:23:07.740 --> 01:23:08.740]  Что это означает?
[01:23:09.740 --> 01:23:11.740]  Ну, что их должно...
[01:23:11.740 --> 01:23:12.740]  Ну вот.
[01:23:12.740 --> 01:23:16.740]  Раз их С-1, это означает, обратите внимание,
[01:23:16.740 --> 01:23:19.740]  что все, что как бы получается,
[01:23:19.740 --> 01:23:22.740]  то есть на самом деле все не пустые суффиксы на самом деле проходят сюда.
[01:23:22.740 --> 01:23:24.740]  Потому что сюда приходит аж С-суффиксов.
[01:23:24.740 --> 01:23:28.740]  То есть вот этот синий и еще С-1 черный, правда?
[01:23:30.740 --> 01:23:34.740]  А теперь смотрите, а что это за мистическая такая ситуация,
[01:23:34.740 --> 01:23:38.740]  когда у вас все суффиксы эквивалентны самой строке С?
[01:23:41.740 --> 01:23:43.740]  Что это за мистическая ситуация?
[01:23:44.740 --> 01:23:46.740]  Что это за мистическая ситуация?
[01:23:49.740 --> 01:23:52.740]  Получается, что последние символы строки вообще больше не встречаются.
[01:23:52.740 --> 01:23:53.740]  Да.
[01:23:54.740 --> 01:23:55.740]  Действительно.
[01:23:55.740 --> 01:24:00.740]  То есть если мы хотим, чтобы суффиксы с последнего символа тоже были эквивалентны на этой строке,
[01:24:00.740 --> 01:24:04.740]  то получается, мы вынуждены заключить, что он больше нигде не встречается.
[01:24:04.740 --> 01:24:06.740]  Потому что, иначе у него было бы больше, чем оно вхождение.
[01:24:06.740 --> 01:24:08.740]  Подключается к третьей С.
[01:24:08.740 --> 01:24:09.740]  Так, неплохо.
[01:24:09.740 --> 01:24:11.740]  То есть смотрите, то есть у нас есть...
[01:24:11.740 --> 01:24:16.740]  То есть имеется в виду какая-то строка, у которой вот есть последний символ,
[01:24:16.740 --> 01:24:18.740]  назовем его С,
[01:24:19.740 --> 01:24:21.740]  и он больше нигде не встречается.
[01:24:21.740 --> 01:24:28.740]  Так, это необходимо и достаточно, чтобы заявлять, что в черных рыбах С-1, да?
[01:24:30.740 --> 01:24:36.740]  Так, а теперь давайте думать, что же должна быть строчка?
[01:24:36.740 --> 01:24:38.740]  То есть какие у нас должны быть послабления?
[01:24:38.740 --> 01:24:45.740]  Такие, чтобы у строчки, получается, количество состояний было 2С-1 или 2С-2.
[01:24:46.740 --> 01:24:50.740]  При этом, обратите внимание, последний символ не повторялся.
[01:24:56.740 --> 01:25:01.740]  Но, видимо, если мы берем последний символ, то получится строчка как раз из первого труждения,
[01:25:01.740 --> 01:25:06.740]  из самого верхнего, что у него будет 2 на 1-1.
[01:25:06.740 --> 01:25:07.740]  Почему?
[01:25:08.740 --> 01:25:13.740]  Потому что добавление последнего символа добавляет только одно новое состояние картины.
[01:25:13.740 --> 01:25:14.740]  Почему?
[01:25:18.740 --> 01:25:21.740]  Ну, как-то да, но и что? Что значит добавление?
[01:25:21.740 --> 01:25:25.740]  Ну, значит, что еще взять строку без последнего символа, то у него будет на одном состоянии меньше.
[01:25:25.740 --> 01:25:26.740]  Ну, да.
[01:25:28.740 --> 01:25:31.740]  Ну, там такое. Не факт, на самом деле.
[01:25:31.740 --> 01:25:33.740]  Хотя нет, факт.
[01:25:33.740 --> 01:25:39.740]  Там, знаете, надо тогда доказывать, что для строки без последнего символа автомат там действительно не поменяется.
[01:25:41.740 --> 01:25:43.740]  Хочется пока это же их делать.
[01:25:45.740 --> 01:25:50.740]  Нет, вот мы выяснили, да, смотрите, что у нас за строки, у которых состояние 2С-1?
[01:25:50.740 --> 01:25:54.740]  Мы выяснили, что это только такие строки, и больше они никакие нам не подходят.
[01:25:55.740 --> 01:25:57.740]  А теперь давайте вспомним, откуда мы так мыслили?
[01:25:57.740 --> 01:26:00.740]  Ну, мы мыслили, что у нас префиксы, во-первых.
[01:26:00.740 --> 01:26:08.740]  Что там для того, чтобы было 2С-1, надо чтобы, получается, надо чтобы префиксы все вели в листья, то есть никакой префикс нигде не встречался, правда?
[01:26:09.740 --> 01:26:10.740]  Было дело?
[01:26:11.740 --> 01:26:14.740]  Вот. И отсюда мы вывели, что это должно быть вот А на БВБ.
[01:26:14.740 --> 01:26:16.740]  А, ну еще нам надо было, чтобы там...
[01:26:18.740 --> 01:26:24.740]  Ну, еще там выяснилось, что вот А, А, А, А нам все не подходят, поэтому получается корень тоже развилкой, нам надо было, чтобы там было движение.
[01:26:24.740 --> 01:26:31.740]  А, ну можно так сказать, если у нас всего два разных символа в строке, то это будет, типа, АС и Ми будет очень малая ребра.
[01:26:32.740 --> 01:26:36.740]  А вот давайте, кстати, подумаем, да, вот сколько символов может быть?
[01:26:36.740 --> 01:26:40.740]  Ну, как минимум, один символ, ну, этот символ больше не повторяется.
[01:26:40.740 --> 01:26:49.740]  Но если там кроме нее только один символ, то есть вот если вот ААААС, то давайте подумаем, сколько состояния, сколько ребр будет в ААААС?
[01:26:49.740 --> 01:26:54.740]  Модуля с плюс один, кажется.
[01:26:54.740 --> 01:26:59.740]  Ну да, то есть если у вас строка А в степени КС, то там как это будет выглядеть?
[01:26:59.740 --> 01:27:14.740]  Ну, во-первых, вся вот эта цепочка, да, ААААА, да, и тут вот С еще, да, вот такая вот АААА, АААА, вот.
[01:27:15.740 --> 01:27:19.740]  И при этом еще верно, что из всех вершин еще есть переход по символу С.
[01:27:23.740 --> 01:27:25.740]  Ну и сколько тут получается?
[01:27:25.740 --> 01:27:26.740]  Регерд 2К.
[01:27:26.740 --> 01:27:28.740]  Получается, да, тут...
[01:27:28.740 --> 01:27:29.740]  Кажется.
[01:27:29.740 --> 01:27:32.740]  Сейчас. Нет, почему? Значит, АС у нас К.
[01:27:32.740 --> 01:27:33.740]  2К плюс один.
[01:27:33.740 --> 01:27:38.740]  С под С значит К плюс один, плюс, и сколько у нас еще переходов по С?
[01:27:38.740 --> 01:27:42.740]  Их получается, ну сколько там получается? Тоже К плюс один.
[01:27:44.740 --> 01:27:46.740]  Нет, реально, смотрите.
[01:27:46.740 --> 01:27:48.740]  Вот этих вот вершин.
[01:27:48.740 --> 01:27:51.740]  А, потому что вот это вот не считается, да.
[01:27:51.740 --> 01:27:52.740]  А этих К.
[01:27:52.740 --> 01:27:55.740]  Получается, что 2К плюс один.
[01:27:57.740 --> 01:28:02.740]  Так, 2К плюс один versus...
[01:28:02.740 --> 01:28:05.740]  Ну то есть, да, 2К плюс один, это что такое?
[01:28:05.740 --> 01:28:07.740]  2С плюс один.
[01:28:07.740 --> 01:28:08.740]  Два модуля С.
[01:28:08.740 --> 01:28:10.740]  Минус один.
[01:28:10.740 --> 01:28:11.740]  Чего?
[01:28:11.740 --> 01:28:12.740]  Да.
[01:28:12.740 --> 01:28:14.740]  Ну плюс С это К плюс один.
[01:28:15.740 --> 01:28:19.740]  То есть, мы получили еще какие-то строчки, у которых количество составит...
[01:28:19.740 --> 01:28:21.740]  А, количество геобер.
[01:28:21.740 --> 01:28:24.740]  Ну, а это равно 3С минус 4, когда С равно 3.
[01:28:24.740 --> 01:28:26.740]  Ну да.
[01:28:26.740 --> 01:28:28.740]  Отлично.
[01:28:28.740 --> 01:28:31.740]  Ну да, то есть это равно 3С минус 4, когда С равно 3.
[01:28:31.740 --> 01:28:36.740]  То есть, получается, что если мы рассматриваем АС, то получается, значит...
[01:28:36.740 --> 01:28:39.740]  Получается АС, соответственно.
[01:28:39.740 --> 01:28:43.740]  Но если мы хотим большей длины, то у нас проблема.
[01:28:45.740 --> 01:28:46.740]  Ну теперь, смотрите.
[01:28:46.740 --> 01:28:48.740]  Тогда получается, что у нас...
[01:28:48.740 --> 01:28:55.740]  Строчки, если хотим длины 3, там длины больше 3, то получается, что нам должны быть 3 различных символов, правда?
[01:28:57.740 --> 01:29:00.740]  То есть, в коре тройная развилка.
[01:29:00.740 --> 01:29:03.740]  А это уже значит, что все остальные префиксы больше не встречаются.
[01:29:03.740 --> 01:29:05.740]  Значит, на первых символах только один.
[01:29:05.740 --> 01:29:07.740]  Значит, префиксы больше жестко не встречаются.
[01:29:07.740 --> 01:29:09.740]  Так что мы вынуждены заключить, что тут...
[01:29:09.740 --> 01:29:13.740]  Значит, дальше будет АВ в степени КС.
[01:29:13.740 --> 01:29:16.740]  Значит, соответственно, АВ и СА.
[01:29:16.740 --> 01:29:21.740]  Значит, А не равно В, не равно С, не равно А.
[01:29:21.740 --> 01:29:25.740]  И, соответственно, то это К.
[01:29:30.740 --> 01:29:32.740]  Да, красота.
[01:29:38.740 --> 01:29:44.740]  Осталось только придумать задачу, в которой можно скатиться.
[01:29:44.740 --> 01:29:47.740]  В смысле, что в автомате в решении более чем 3 Ка плюс 7.
[01:29:47.740 --> 01:29:49.740]  В контресе плюс 7, то решение тупое.
[01:29:49.740 --> 01:29:52.740]  А в противном случае рассмотрим следующий.
[01:29:58.740 --> 01:30:02.740]  А для АВ в КТЦ у нас сколько будет ВВ?
[01:30:02.740 --> 01:30:04.740]  А, ой, действительно.
[01:30:04.740 --> 01:30:07.740]  Это же получается, что мы написали необходимую, что ли?
[01:30:07.740 --> 01:30:08.740]  Ну ладно.
[01:30:08.740 --> 01:30:12.740]  В качестве упражнения остается проверить, что эту подходит.
[01:30:14.740 --> 01:30:15.740]  Так.
[01:30:15.740 --> 01:30:16.740]  Почему в качестве упражнения?
[01:30:16.740 --> 01:30:17.740]  В качестве упражнения?
[01:30:17.740 --> 01:30:18.740]  Потому что, я думаю, да.
[01:30:18.740 --> 01:30:21.740]  Пришло время, наверное, перелетчику строить.
[01:30:21.740 --> 01:30:22.740]  Или не хотите?
[01:30:22.740 --> 01:30:24.740]  Да, давайте сейчас.
[01:30:24.740 --> 01:30:25.740]  Да, давайте.
[01:30:25.740 --> 01:30:27.740]  Нет, ну я думаю, да.
[01:30:27.740 --> 01:30:30.740]  Прежде чем совершить последний матч-бросок
[01:30:30.740 --> 01:30:33.740]  и, собственно, это теперь за линию еще и построить.
[01:30:33.740 --> 01:30:34.740]  Но вопрос вот тут.
[01:30:34.740 --> 01:30:35.740]  Про черные ребра.
[01:30:35.740 --> 01:30:38.740]  Поэтому мы их висели ДФС, нашли дерево ДФС.
[01:30:38.740 --> 01:30:41.740]  Дэйвилл говорил, что количество черных ребр не более чем С-1.
[01:30:41.740 --> 01:30:42.740]  Да.
[01:30:42.740 --> 01:30:46.740]  Ну потому что, по сути, каждому из них соответствует...
[01:30:46.740 --> 01:30:47.740]  Какой-то суффикс.
[01:30:47.740 --> 01:30:48.740]  Суффикс.
[01:30:48.740 --> 01:30:49.740]  Ну какой-то непустой суффикс.
[01:30:49.740 --> 01:30:51.740]  Даже из класса эквалентности вот этого.
[01:30:51.740 --> 01:30:53.740]  А почему еще раз?
[01:30:53.740 --> 01:30:56.740]  Потому что мы ему ставим в соответствии такой суффикс.
[01:30:56.740 --> 01:30:57.740]  А как?
[01:30:57.740 --> 01:30:59.740]  Ну, если рассматриваем путь,
[01:30:59.740 --> 01:31:04.740]  рассматриваем путь из стартовой вершины в ту вершину через это ребро.
[01:31:04.740 --> 01:31:09.740]  Причем путь строим таким образом, чтобы после этого ребра путь шел строго под дерево ДФС.
[01:31:09.740 --> 01:31:13.740]  Это гарантирует нам, что для разных черных ребров пути будут различны.
[01:31:16.740 --> 01:31:18.740]  Да, мы его так считаем, да.
[01:31:25.740 --> 01:31:28.740]  Так, ну мы вот, в общем-то, изучили.
[01:31:28.740 --> 01:31:30.740]  Соответственно, даже достаточно устройства автомата.
[01:31:30.740 --> 01:31:34.740]  Теперь остается сделать еще пару шагов и получить еще алгоритм,
[01:31:34.740 --> 01:31:39.740]  как строить, действительно, этот автомат за линию.
[01:31:40.740 --> 01:31:41.740]  Вот.
[01:31:41.740 --> 01:31:44.740]  А попутно, может быть, еще что-нибудь про него понять.
[01:31:44.740 --> 01:31:47.740]  Ну, если там останется время.
[01:31:52.740 --> 01:31:53.740]  Значит, смотри.
[01:31:59.740 --> 01:32:06.740]  Строить автомат, мы, как это ни странно, будем абсолютно тем же способом,
[01:32:06.740 --> 01:32:10.740]  ну, пока я не говорил, идейно, как и суффиксное дерево.
[01:32:10.740 --> 01:32:11.740]  В каком плане?
[01:32:11.740 --> 01:32:12.740]  Тем же способом.
[01:32:12.740 --> 01:32:19.740]  У нас снова будет какая-то пустая строка, в которой мы будем дописывать символы по одному
[01:32:19.740 --> 01:32:22.740]  и модифицировать автомат.
[01:32:24.740 --> 01:32:25.740]  Понятная идея, да?
[01:32:25.740 --> 01:32:26.740]  Вот.
[01:32:27.740 --> 01:32:33.740]  Поэтому основное, что для нас будет интересовать, это следующее.
[01:32:33.740 --> 01:32:37.740]  Вот, предположим, мы к строке S приписываем символ C.
[01:32:38.740 --> 01:32:41.740]  Как поменяются автоматы?
[01:32:46.740 --> 01:32:47.740]  Как они поменяются?
[01:32:49.740 --> 01:32:51.740]  Ну, во-первых,
[01:32:51.740 --> 01:32:53.740]  ну, начнем с простого утверждения.
[01:32:58.740 --> 01:33:08.740]  Если x равно longest относительно x относительно строки S,
[01:33:08.740 --> 01:33:10.740]  то, очевидно,
[01:33:10.740 --> 01:33:15.740]  относительно S, он тоже будет longest, по вон той уже имеемой модели, правда?
[01:33:22.740 --> 01:33:24.740]  Ну, или что то же самое.
[01:33:24.740 --> 01:33:27.740]  Если какая-то строка под строка S стала longest,
[01:33:27.740 --> 01:33:30.740]  то в процессе добавления новых символов она останется longest,
[01:33:30.740 --> 01:33:31.740]  на всякий случай.
[01:33:31.740 --> 01:33:37.740]  То есть, если мы будем дописывать символы по одному и модифицировать автомат,
[01:33:37.740 --> 01:33:40.740]  то в процессе добавления новых символов она останется longestов навсегда.
[01:33:42.740 --> 01:33:43.740]  Логично, да?
[01:33:47.740 --> 01:33:49.740]  Вот, по сути, что это утверждение значит.
[01:33:49.740 --> 01:33:51.740]  Давайте я еще вот так вот сотру.
[01:33:57.740 --> 01:33:58.740]  Ну, действительно.
[01:33:58.740 --> 01:34:01.740]  Ну, просто вот из этого утверждения очевидно, что, да, то есть,
[01:34:01.740 --> 01:34:04.740]  строка является longest тогда, это тогда, когда выполнено оба еще утверждения.
[01:34:04.740 --> 01:34:07.740]  Видно, что если хотя бы одно из этих утверждений стало выполнено,
[01:34:07.740 --> 01:34:09.740]  то оно теперь выполнено навсегда, правда?
[01:34:11.740 --> 01:34:14.740]  Разве что, разница будет в том, что эти продолжения может количество увеличиваться,
[01:34:14.740 --> 01:34:17.740]  но меньше двух уже не станет.
[01:34:20.740 --> 01:34:22.740]  Поэтому нам теперь даже интересно кое-что больше.
[01:34:24.740 --> 01:34:26.740]  Вот даже более такое культовое утверждение сейчас будет.
[01:34:28.740 --> 01:34:29.740]  Пусть
[01:34:30.740 --> 01:34:31.740]  x
[01:34:34.740 --> 01:34:35.740]  Значит, давайте так.
[01:34:37.740 --> 01:34:38.740]  Значит, x
[01:34:39.740 --> 01:34:41.740]  равно longest в ССС
[01:34:48.740 --> 01:34:49.740]  тогда, только тогда,
[01:34:50.740 --> 01:34:54.740]  когда выполнено одно из следующих утверждений.
[01:34:59.740 --> 01:35:00.740]  Ну, первое очевидно.
[01:35:02.740 --> 01:35:03.740]  x
[01:35:04.740 --> 01:35:05.740]  longest от x
[01:35:06.740 --> 01:35:07.740]  в ССС
[01:35:14.740 --> 01:35:15.740]  Ну, а теперь подумаем.
[01:35:16.740 --> 01:35:18.740]  А какие мистические подстроки?
[01:35:18.740 --> 01:35:20.740]  А что же это вообще теперь, давайте подумаем.
[01:35:20.740 --> 01:35:23.740]  Вот здесь мы должны перечислить мистические подстроки
[01:35:24.740 --> 01:35:26.740]  у строки ССС, которые
[01:35:27.740 --> 01:35:31.740]  ну вот, которые не являются longest-ами в строке ССС.
[01:35:32.740 --> 01:35:33.740]  Что это за строки?
[01:35:34.740 --> 01:35:35.740]  Это швейк ССС.
[01:35:37.740 --> 01:35:38.740]  Почему?
[01:35:38.740 --> 01:35:41.740]  Ну, если они не содержат последней силы, то они играются в строке ССС.
[01:35:42.740 --> 01:35:43.740]  Эээ, и что?
[01:35:43.740 --> 01:35:44.740]  Сейчас.
[01:35:45.740 --> 01:35:46.740]  Вот тут надо куда?
[01:36:01.740 --> 01:36:03.740]  Ну, они либо субексы, да, и ССС.
[01:36:04.740 --> 01:36:06.740]  А если они не являются, то их как бы, их
[01:36:07.740 --> 01:36:09.740]  набор обхождения не поменялся на концовках последней.
[01:36:10.740 --> 01:36:12.740]  А если они стали longest-ами, значит,
[01:36:13.740 --> 01:36:15.740]  ну, типа, субекс
[01:36:16.740 --> 01:36:20.740]  элемент на один больше его классик валяности перестал быть его классик валяности.
[01:36:21.740 --> 01:36:22.740]  То есть, у него
[01:36:23.740 --> 01:36:24.740]  ну, это просто невозможно.
[01:36:25.740 --> 01:36:26.740]  Ну, это просто невозможно.
[01:36:26.740 --> 01:36:27.740]  Ну, да, вот сейчас мы докрутим.
[01:36:28.740 --> 01:36:29.740]  Давайте начнем вот с чего.
[01:36:30.740 --> 01:36:34.740]  Начнем с того, что под строка Х, вот это, она может быть под строкой С,
[01:36:35.740 --> 01:36:36.740]  а может не быть.
[01:36:37.740 --> 01:36:38.740]  А давайте подумаем.
[01:36:39.740 --> 01:36:43.740]  А что это за строки такие, которые являются под строками СС, но не являются под строками СС?
[01:36:45.740 --> 01:36:46.740]  Субексы ССС.
[01:36:47.740 --> 01:36:48.740]  Все?
[01:36:49.740 --> 01:36:51.740]  Да, ну, они должны быть суфиксами ССС,
[01:36:52.740 --> 01:36:54.740]  но они должны быть суфиксами ССС.
[01:36:54.740 --> 01:36:57.740]  Да, ну, они должны быть суфиксами ССС, но это не все суфиксы.
[01:36:58.740 --> 01:37:01.740]  А на самом деле это класс эквивалентности СС.
[01:37:02.740 --> 01:37:03.740]  В автомате по СС, правильно?
[01:37:04.740 --> 01:37:05.740]  Это в точности те строки,
[01:37:06.740 --> 01:37:08.740]  у которых в рождении ровно одно.
[01:37:09.740 --> 01:37:10.740]  Вот.
[01:37:11.740 --> 01:37:13.740]  Но, очевидно, из них логистом является кто?
[01:37:16.740 --> 01:37:18.740]  Ну, да. Поэтому мы здесь и пишем.
[01:37:19.740 --> 01:37:21.740]  ХСС. Х равно ССС.
[01:37:22.740 --> 01:37:23.740]  А вот теперь начинаем думать.
[01:37:24.740 --> 01:37:28.740]  Теперь, значит, нам нужно найти такую строку Х,
[01:37:30.740 --> 01:37:35.740]  которая является под строкой С.
[01:37:36.740 --> 01:37:37.740]  Но при этом, обратите внимание,
[01:37:38.740 --> 01:37:40.740]  в СС она логистом не была,
[01:37:41.740 --> 01:37:43.740]  а в СС, опа, неожиданно стала.
[01:37:46.740 --> 01:37:48.740]  Внимание, вопрос.
[01:37:49.740 --> 01:37:50.740]  Что это?
[01:37:54.740 --> 01:37:55.740]  Что же это такая мстика?
[01:37:56.740 --> 01:38:00.740]  То есть жила-была вот какая-то подстрока мистическая,
[01:38:01.740 --> 01:38:03.740]  и у нее было вхождение.
[01:38:04.740 --> 01:38:06.740]  То есть, видите, даже, может быть, несколько вхождений было.
[01:38:07.740 --> 01:38:08.740]  Давайте поменьше вхождение буду рисовать.
[01:38:10.740 --> 01:38:12.740]  Причем обратите внимание,
[01:38:13.740 --> 01:38:14.740]  до, то есть, ну, обратите внимание,
[01:38:15.740 --> 01:38:16.740]  логистом она не была.
[01:38:17.740 --> 01:38:18.740]  Она не была.
[01:38:19.740 --> 01:38:20.740]  Она не была.
[01:38:21.740 --> 01:38:22.740]  Она не была.
[01:38:22.740 --> 01:38:23.740]  То есть, обратите внимание,
[01:38:24.740 --> 01:38:25.740]  логистом она не была.
[01:38:26.740 --> 01:38:27.740]  То есть, претиксом строки С она не является.
[01:38:28.740 --> 01:38:29.740]  Правда?
[01:38:30.740 --> 01:38:31.740]  Претиксом не является,
[01:38:32.740 --> 01:38:33.740]  и перед всеми ее вхождениями стоит один и тот же символ Х.
[01:38:34.740 --> 01:38:36.740]  Да, и в конце тут везде ССС.
[01:38:40.740 --> 01:38:42.740]  Но тут, неожиданно выясняется,
[01:38:43.740 --> 01:38:47.740]  неожиданно выясняется, что вот здесь, конкретно здесь,
[01:38:48.740 --> 01:38:49.740]  стоит другой символ.
[01:38:53.740 --> 01:38:57.740]  То есть, получается, если я назову эту строку, допустим, С0,
[01:38:58.740 --> 01:38:59.740]  то получается интересный факт.
[01:39:00.740 --> 01:39:06.740]  С0 является, это такой суффикс СС, который является под строкой С.
[01:39:07.740 --> 01:39:12.740]  Но при этом, при этом самый, чуть больший суффикс строки СС
[01:39:13.740 --> 01:39:16.740]  под строкой строки С уже не является.
[01:39:16.740 --> 01:39:20.740]  Поэтому внезапно мы здесь пишем, Х равно С0.
[01:39:21.740 --> 01:39:22.740]  Где С0?
[01:39:23.740 --> 01:39:39.740]  Это максимально, но это длиннейший суффикс СС,
[01:39:39.740 --> 01:39:53.740]  СС, являющийся под строкой С.
[01:40:01.740 --> 01:40:03.740]  Вот такое интересное утверждение.
[01:40:03.740 --> 01:40:04.740]  Вот.
[01:40:07.740 --> 01:40:10.740]  Кстати, это утверждение является еще одним доказательством того,
[01:40:11.740 --> 01:40:14.740]  что количество состояний в суффиксном автомате не превосходит 2С-1.
[01:40:17.740 --> 01:40:19.740]  Потому что количество лонгестов с добавлением одного символа
[01:40:20.740 --> 01:40:22.740]  увеличивается на не более чем два, обратите внимание.
[01:40:24.740 --> 01:40:25.740]  Неплохо, правда?
[01:40:26.740 --> 01:40:27.740]  Видите?
[01:40:28.740 --> 01:40:29.740]  Вот.
[01:40:30.740 --> 01:40:33.740]  Можно еще раз утверждение доказать, что я не логист.
[01:40:34.740 --> 01:40:35.740]  Или хотя бы случай, когда мы разыграем.
[01:40:36.740 --> 01:40:37.740]  Значит, поехали.
[01:40:38.740 --> 01:40:39.740]  Так, ну давайте смотреть.
[01:40:40.740 --> 01:40:42.740]  Итак, давайте, кто может быть лонгестом в СС?
[01:40:43.740 --> 01:40:46.740]  Ну, во-первых, если эта строка не является даже под строкой СС,
[01:40:47.740 --> 01:40:49.740]  то мы выяснили, что все эти строки это суффикс СС
[01:40:50.740 --> 01:40:53.740]  и несколько чуть более коротких суффиксов, которые не встречаются в СС.
[01:40:54.740 --> 01:40:56.740]  И они все в одном классе приводительности СС лежат, правда?
[01:40:58.740 --> 01:40:59.740]  Ну, то есть...
[01:41:00.740 --> 01:41:01.740]  Ну, то и да.
[01:41:02.740 --> 01:41:03.740]  Нет.
[01:41:04.740 --> 01:41:05.740]  Утверждение.
[01:41:06.740 --> 01:41:09.740]  Сейчас будет очень тупое утверждение, но будет очень умно звучать.
[01:41:12.740 --> 01:41:18.740]  Все подстроки строки СС, не являющиеся подстроками строки С,
[01:41:19.740 --> 01:41:23.740]  лежат в одном классе эквивалентности относительно СС.
[01:41:24.740 --> 01:41:25.740]  Да.
[01:41:25.740 --> 01:41:26.740]  Он является, ну, СС.
[01:41:27.740 --> 01:41:29.740]  Да, это в классе эквивалентности строки СС.
[01:41:30.740 --> 01:41:33.740]  И он состоит из строки СС и нескольких еще чуть более коротких суффиксов,
[01:41:34.740 --> 01:41:35.740]  которые не встречаются в СС подстройке.
[01:41:36.740 --> 01:41:37.740]  Да, вот.
[01:41:38.740 --> 01:41:39.740]  Отлично.
[01:41:40.740 --> 01:41:41.740]  И это какой случай?
[01:41:42.740 --> 01:41:43.740]  Второй.
[01:41:44.740 --> 01:41:45.740]  Хорошо.
[01:41:46.740 --> 01:41:49.740]  Теперь мы рассматриваем случаи, когда Х это под строка С.
[01:41:50.740 --> 01:41:51.740]  Тогда у нас два варианта.
[01:41:52.740 --> 01:41:54.740]  Либо она уже была лонгестом.
[01:41:55.740 --> 01:41:58.740]  Либо это такая мистическая строка Х,
[01:41:59.740 --> 01:42:05.740]  которая в С лонгестом не была, а в С неожиданно стала.
[01:42:06.740 --> 01:42:08.740]  И тут мы рассуждаем, что это строка.
[01:42:09.740 --> 01:42:10.740]  Ну, начнем с того, что это суффикс.
[01:42:11.740 --> 01:42:13.740]  Ну, очевидно, что значит, что она не была лонгестом?
[01:42:14.740 --> 01:42:15.740]  Это значит, что в С не была префиксом,
[01:42:16.740 --> 01:42:18.740]  и перед всеми ее вхождениями стоял один и тот же символик.
[01:42:21.740 --> 01:42:24.740]  Как тогда может быть, что с добавлением С она неожиданно стала лонгестом?
[01:42:25.740 --> 01:42:27.740]  Ну, префиксом строки С она от этого не стала.
[01:42:28.740 --> 01:42:30.740]  Следовательно, у нее должно появиться второй символ перед ней.
[01:42:31.740 --> 01:42:35.740]  Значит, получается, С0 было в конце, и перед ним стоит символ отличный от X.
[01:42:36.740 --> 01:42:40.740]  Тогда получается, что это С0 суффикс СС, который входит в С как под строка.
[01:42:41.740 --> 01:42:44.740]  Причем, если я добавлю к нему этот символ перед ним,
[01:42:45.740 --> 01:42:48.740]  то этот суффикс уже как под строка в С не входит.
[01:42:49.740 --> 01:42:50.740]  Да, и это третий случай?
[01:42:51.740 --> 01:42:52.740]  И это в точности третий случай.
[01:42:52.740 --> 01:42:54.740]  Но там нет дополнительного условия.
[01:42:55.740 --> 01:42:56.740]  Какого?
[01:42:57.740 --> 01:43:00.740]  Что если добавить, ну, что если добавить Y, то он не входит в С.
[01:43:02.740 --> 01:43:05.740]  Но нет, он Y может сам по себе как символ входить в С.
[01:43:06.740 --> 01:43:08.740]  Но суффикс еще и с Y не входит в С.
[01:43:09.740 --> 01:43:13.740]  Это не обязательно, потому что заметим, что эта строка,
[01:43:14.740 --> 01:43:16.740]  вот эта строка, длиннейшая суффикс, являющаяся под строкой С,
[01:43:17.740 --> 01:43:19.740]  она по-любому является лонгестом СС.
[01:43:19.740 --> 01:43:22.740]  Независимо от того, входит ли игрок С0 как под строка или нет.
[01:43:23.740 --> 01:43:25.740]  А, хотя нет, игрок С0 по-любому не входит.
[01:43:26.740 --> 01:43:30.740]  Потому что С0 – это длиннейший суффикс СС, являющийся под строкой С.
[01:43:31.740 --> 01:43:35.740]  То есть это по определению означает, что игрок С0 по-любому не входит.
[01:43:40.740 --> 01:43:43.740]  Да, могло быть так, что тут уже игроков тут нет,
[01:43:44.740 --> 01:43:46.740]  но тут какие-то Z и X тут уже могли быть,
[01:43:46.740 --> 01:43:50.740]  но это означает, что просто первый и третий случай сошлись вместе.
[01:43:53.740 --> 01:43:58.740]  И более того, кстати, что приятно, в строке СС на самом деле,
[01:43:59.740 --> 01:44:02.740]  в строке СС на самом деле, обратите внимание,
[01:44:03.740 --> 01:44:06.740]  то есть будет уже видно так, у нас будет состояние вот этого,
[01:44:07.740 --> 01:44:14.740]  обязательно СС, и из него обязательно будет вести суффиксная ссылка в состояние С0.
[01:44:16.740 --> 01:44:18.740]  Прямо вот обязательно.
[01:44:32.740 --> 01:44:34.740]  А теперь давайте вот что думаем.
[01:44:35.740 --> 01:44:37.740]  А теперь надо подумать, какие состояния будем создавать.
[01:44:38.740 --> 01:44:41.740]  Ну, заметим, что состояние фактически эквиваленты логистам, правда?
[01:44:42.740 --> 01:44:45.740]  Каждому логисту по состоянию, каждому состоянию по логисту, правда?
[01:44:47.740 --> 01:44:52.740]  Состояние график, класс эквалентности, он за логистом.
[01:44:53.740 --> 01:44:58.740]  Ну да, ну как бы каждому состоянию в графе соответствует логист.
[01:44:59.740 --> 01:45:05.740]  Поэтому можно сделать вывод следующий, что у нас, когда мы заменяем С на СС, что может произойти?
[01:45:06.740 --> 01:45:11.740]  Ну, во-первых, все старые логисты сохраняются, и все состояния между ними мы сохраним.
[01:45:12.740 --> 01:45:16.740]  Но при этом добавится, во-первых, состояние на СС,
[01:45:17.740 --> 01:45:24.740]  и, в-третьих, что самое главное, обязательно мы должны проследить, что логистом должно стать вот эта штука.
[01:45:26.740 --> 01:45:27.740]  Что это значит?
[01:45:28.740 --> 01:45:31.740]  Ну тут два варианта, либо она уже была логистом, и тогда нового состояния здесь не появится,
[01:45:32.740 --> 01:45:36.740]  либо она логистом не была, и тогда...
[01:45:37.740 --> 01:45:39.740]  А что дальше?
[01:45:42.740 --> 01:45:49.740]  А тогда вот что. Это означает, что у нас в строке С было мистическое состояние,
[01:45:50.740 --> 01:45:58.740]  у которого был класс эквалентности в лице нескольких строчек,
[01:45:59.740 --> 01:46:01.740]  и одной из них была строка неожиданно С0.
[01:46:02.740 --> 01:46:05.740]  Еще в не логистом, обратите внимание, да?
[01:46:06.740 --> 01:46:08.740]  А теперь, бах-бах, ничего не поменялось.
[01:46:08.740 --> 01:46:16.740]  Все подстроки строки С сохранили свои статусы, то есть логист остался логистом, не логист остался не логистом,
[01:46:17.740 --> 01:46:19.740]  окромя С0.
[01:46:24.740 --> 01:46:27.740]  С0 неожиданно не был логистом, теперь объявился.
[01:46:28.740 --> 01:46:29.740]  Ну что это означает?
[01:46:29.740 --> 01:46:38.740]  Это означает, то есть в этом случае мы вынуждены заключить, что у нас теперь есть две,
[01:46:39.740 --> 01:46:43.740]  из этой одной вершины у нас получилось две вершины.
[01:46:44.740 --> 01:46:54.740]  Одна отвечает за вот эти более длинные строчки, две, а вот эта отвечает за С0 и все остальное.
[01:46:59.740 --> 01:47:20.740]  Что же отчего это нас приводит?
[01:47:21.740 --> 01:47:25.740]  Остается только один маленький вопрос.
[01:47:26.740 --> 01:47:29.740]  Как же нам будет отличать один случай от другого?
[01:47:30.740 --> 01:47:34.740]  Ну мы сейчас пока временно забьем на вопрос о том, откуда мы будем выкапывать ребра.
[01:47:35.740 --> 01:47:39.740]  Ну давайте предположим, что как бы нам главное построить правильные вершины,
[01:47:40.740 --> 01:47:44.740]  а ребра и допустим суффиксные ссылки нам будут присылать с небес по факсу.
[01:47:44.740 --> 01:47:49.740]  Ну как всегда, пока с небес по факсу, потом небеса и факс мы как всегда,
[01:47:50.740 --> 01:47:54.740]  сначала изобретем факс, потом изобретем небеса.
[01:47:55.740 --> 01:47:57.740]  Или наоборот порядок 35.
[01:47:58.740 --> 01:47:59.740]  Так вот.
[01:48:00.740 --> 01:48:01.740]  Ну давайте подумаем вот о чем.
[01:48:02.740 --> 01:48:04.740]  А как вообще понять, хотя бы теоретически?
[01:48:05.740 --> 01:48:09.740]  Предположим, внимание, сразу скажу, уровень алгоритма такой.
[01:48:09.740 --> 01:48:13.740]  Так, ну думаю вот эти базовые определения можно будет стирать, да?
[01:48:14.740 --> 01:48:18.740]  Ну вот эти я, вот эти я, пожалуй, не буду стирать, но я думаю там совсем...
[01:48:19.740 --> 01:48:22.740]  Тем более, там на языке правых контекстов мы, наверное, уже и говорите и будем.
[01:48:23.740 --> 01:48:27.740]  Как говорится, они уже сделают свое дело и могут ухудить.
[01:48:28.740 --> 01:48:29.740]  Ой.
[01:48:30.740 --> 01:48:31.740]  Ого.
[01:48:32.740 --> 01:48:35.740]  Да, что-то вот эта губка как-то лучше работает.
[01:48:36.740 --> 01:48:37.740]  Да?
[01:48:38.740 --> 01:48:39.740]  Это следы не оставляет.
[01:48:40.740 --> 01:48:41.740]  Да?
[01:48:42.740 --> 01:48:43.740]  Да?
[01:48:44.740 --> 01:48:45.740]  Это оставляет маркер.
[01:48:46.740 --> 01:48:47.740]  Ага.
[01:48:48.740 --> 01:48:50.740]  Ну надо это стирать до самого края.
[01:48:51.740 --> 01:48:52.740]  Да-да-да.
[01:48:53.740 --> 01:48:54.740]  Да, то есть это подмести еще.
[01:48:55.740 --> 01:48:56.740]  А как же это сделать?
[01:48:57.740 --> 01:48:58.740]  Ну как же это сделать?
[01:48:59.740 --> 01:49:00.740]  Ну как же это сделать?
[01:49:01.740 --> 01:49:02.740]  Ну как же это сделать?
[01:49:02.740 --> 01:49:03.740]  Да-да-да.
[01:49:04.740 --> 01:49:05.740]  Да, то есть это подмести еще.
[01:49:06.740 --> 01:49:07.740]  Да-да-да.
[01:49:08.740 --> 01:49:09.740]  Ну давай сюда.
[01:49:10.740 --> 01:49:11.740]  Ну ничего.
[01:49:12.740 --> 01:49:13.740]  Да нет, нормально.
[01:49:14.740 --> 01:49:15.740]  Ну вот нормально.
[01:49:16.740 --> 01:49:17.740]  Как говорится, да.
[01:49:18.740 --> 01:49:19.740]  У вас как бы да.
[01:49:20.740 --> 01:49:21.740]  Ну как бы да.
[01:49:22.740 --> 01:49:24.740]  Ну да, любишь мыть полы любикудные.
[01:49:25.740 --> 01:49:27.740]  Да я теперь нужно ее поставить сверху, чтобы не было...
[01:49:28.740 --> 01:49:29.740]  Да-да.
[01:49:30.740 --> 01:49:32.740]  Ну, все это, конечно, можно, да.
[01:49:33.740 --> 01:49:34.740]  Ну давайте.
[01:49:35.740 --> 01:49:36.740]  Идеально.
[01:49:37.740 --> 01:49:38.740]  Ой, красота.
[01:49:39.740 --> 01:49:40.740]  Так вот.
[01:49:41.740 --> 01:49:42.740]  Значит, ну давайте начнем вот с чего.
[01:49:43.740 --> 01:49:44.740]  Значит, как же мы будем сродиться с автоматом?
[01:49:45.740 --> 01:49:46.740]  Вот даже.
[01:49:47.740 --> 01:49:50.740]  Ну, как всегда, начнем реализацию с того, значит, состояния.
[01:49:51.740 --> 01:49:52.740]  Стракт.
[01:49:53.740 --> 01:49:54.740]  Как мы назовем состояние?
[01:49:56.740 --> 01:49:57.740]  Ноги.
[01:49:57.740 --> 01:49:58.740]  Ну естественно.
[01:49:59.740 --> 01:50:01.740]  Ну не в стейджи, действительно, да.
[01:50:02.740 --> 01:50:03.740]  Ну.
[01:50:04.740 --> 01:50:05.740]  Ну естественно, да.
[01:50:06.740 --> 01:50:07.740]  Так.
[01:50:08.740 --> 01:50:09.740]  Ну, что тут у нас есть?
[01:50:10.740 --> 01:50:11.740]  Так.
[01:50:12.740 --> 01:50:13.740]  Ну, во-первых, у нас есть какие-нибудь ребра.
[01:50:14.740 --> 01:50:15.740]  Давайте, как всегда, в мапочке.
[01:50:16.740 --> 01:50:17.740]  Так.
[01:50:18.740 --> 01:50:19.740]  Как здесь переходы называются?
[01:50:20.740 --> 01:50:21.740]  Убекская.
[01:50:28.740 --> 01:50:29.740]  Ладно.
[01:50:30.740 --> 01:50:31.740]  Go.
[01:50:32.740 --> 01:50:33.740]  Угу.
[01:50:34.740 --> 01:50:35.740]  Так.
[01:50:36.740 --> 01:50:37.740]  Значит, это было ноде.
[01:50:38.740 --> 01:50:39.740]  Что нам еще потребуется?
[01:50:40.740 --> 01:50:41.740]  Так.
[01:50:42.740 --> 01:50:44.740]  Но нам еще не помешает такая техническая переменная лента самая.
[01:50:44.740 --> 01:50:45.740]  И суф.
[01:50:46.740 --> 01:50:47.740]  Ну, она же линка.
[01:50:48.740 --> 01:50:49.740]  Она же вообще.
[01:50:52.740 --> 01:50:53.740]  Все.
[01:50:57.740 --> 01:50:59.740]  Ну, вы уже догадываетесь, да, что суфт на автомат.
[01:51:00.740 --> 01:51:01.740]  Ну, конечно, будем в конечках.
[01:51:03.740 --> 01:51:04.740]  То есть где-то так ноде.
[01:51:05.740 --> 01:51:06.740]  Ну, соответственно, лодис.
[01:51:07.740 --> 01:51:08.740]  Ну.
[01:51:09.740 --> 01:51:10.740]  Ну.
[01:51:11.740 --> 01:51:12.740]  Ну.
[01:51:12.740 --> 01:51:13.740]  Ну, соответственно, лодис.
[01:51:14.740 --> 01:51:15.740]  А, ну ладно.
[01:51:16.740 --> 01:51:17.740]  Где-то там потом когда-нибудь.
[01:51:18.740 --> 01:51:19.740]  Значит, еще надо.
[01:51:20.740 --> 01:51:21.740]  Важно обратить внимание.
[01:51:22.740 --> 01:51:27.740]  Нам еще потребуется хранить булифлаг, типа, не является этой вершиной терминальной.
[01:51:28.740 --> 01:51:29.740]  Да.
[01:51:30.740 --> 01:51:31.740]  Важная оговорка.
[01:51:32.740 --> 01:51:41.740]  Когда я говорил, что мы будем строить по автомату С, автомату СС модифицировать, мы будем устроить прям предельно честно, но по модулю того, что мы не будем достраивать терминальные вершины.
[01:51:42.740 --> 01:51:47.740]  Ну, потому что заметим, да, что там терминальные вершины иногда-то будут меняться очень сильно.
[01:51:48.740 --> 01:51:50.740]  То есть там просто там n выключаться, n включаться.
[01:51:51.740 --> 01:52:00.740]  Ну, на самом деле, мы заметим, что в самом-самом-самом конце, на самом деле, если мы уже насчитали лену и суффиксные ссылки, то насчитать терминальные вершины, если надо. Очень просто.
[01:52:01.740 --> 01:52:02.740]  Как это сделать?
[01:52:05.740 --> 01:52:06.740]  Вот, кстати, давайте так.
[01:52:07.740 --> 01:52:09.740]  Такое воспоминание того, что такое суффиксная ссылка.
[01:52:12.740 --> 01:52:18.740]  Вот дан автомат, все, лены построены, суффы построены, гоу построены, осталось только понять, кто терминальная вершина.
[01:52:27.740 --> 01:52:28.740]  Ну просто от всей строки по суффиксным ссылкам.
[01:52:29.740 --> 01:52:36.740]  Ну да. Ну, на самом деле, этого даже не нужно, потому что, забегая вперед, скажу, что мы в каждый момент времени будем сохранить вот это вот состояние, соответствующие полной строке.
[01:52:37.740 --> 01:52:38.740]  Да.
[01:52:39.740 --> 01:52:40.740]  Совершенно верно.
[01:52:40.740 --> 01:52:52.740]  То есть, действительно, то есть, на самом деле, там в конце надо просто взять это состояние s и, собственно, из него по суффиксным ссылкам до корня пробежаться.
[01:52:53.740 --> 01:52:54.740]  Ну, корень в смысле стартовая вершина.
[01:52:55.740 --> 01:52:57.740]  Это в смысле старта, да, а это в смысле.
[01:52:58.740 --> 01:52:59.740]  Вот.
[01:53:00.740 --> 01:53:03.740]  То есть, ну действительно, заметим, что тут это соответствует всей строке s и нескольким и суффиксам.
[01:53:04.740 --> 01:53:07.740]  Суффиксная ссылка соответствует некоторым следующим, тут еще следующим, ну и так далее.
[01:53:07.740 --> 01:53:19.740]  Это я просто нарисовал, что, как бы, если мы пойдем, возьмем эту стоковую вершину и пройдем из нее по всем суффиксам, то мы пройдем в точности по всем вершинам, которые должны быть терминальными.
[01:53:20.740 --> 01:53:26.740]  Или что то же самое, в точности по всем вершинам, классами эквивалентности которых являются суффиксы строки s.
[01:53:27.740 --> 01:53:28.740]  Стокова это...
[01:53:29.740 --> 01:53:31.740]  Из которой нет ребра.
[01:53:32.740 --> 01:53:33.740]  То есть, последняя.
[01:53:34.740 --> 01:53:36.740]  Да. Она же класс эквивалентности самой строки s.
[01:53:37.740 --> 01:53:38.740]  Содержащей саму строку s.
[01:53:39.740 --> 01:53:41.740]  Да, и мы хотим от нее пойти...
[01:53:42.740 --> 01:53:43.740]  Да, по суффиксам.
[01:53:44.740 --> 01:53:45.740]  Хотим по суффиксам, просто по суффиксным ссылкам.
[01:53:46.740 --> 01:53:47.740]  А, по суффиксным ссылкам.
[01:53:48.740 --> 01:53:49.740]  И говорим, что все, которые...
[01:53:50.740 --> 01:53:51.740]  Все, которые загорите, они терминальны?
[01:53:52.740 --> 01:53:53.740]  Да, а все остальные идут.
[01:53:54.740 --> 01:53:55.740]  Почему они терминальны?
[01:53:56.740 --> 01:54:02.740]  Ну, потому что заметим, что, ну, вершина играет терминальна тогда, когда ее класс эквивалентности состоит из суффиксов.
[01:54:03.740 --> 01:54:04.740]  Правда?
[01:54:07.740 --> 01:54:11.740]  Ну, напоминаю, автоматный строй, который принимает суффиксы только из игр, да.
[01:54:12.740 --> 01:54:17.740]  Следует, на каждое состояние оно, как бы у него класс эквивалентности, либо только из суффиксов, либо только из не суффиксов.
[01:54:25.740 --> 01:54:26.740]  Да.
[01:54:31.740 --> 01:54:32.740]  Не понял.
[01:54:32.740 --> 01:54:33.740]  Так, начнем.
[01:54:34.740 --> 01:54:37.740]  Так, у нас язык, состоящий из суффиксов, сказать, есть только язык.
[01:54:38.740 --> 01:54:39.740]  Да, все это.
[01:54:40.740 --> 01:54:41.740]  Значит, терминальная вершина должна состоять...
[01:54:42.740 --> 01:54:45.740]  Класс эквалентности терминальной вершины должен состоять только из суффиксов.
[01:54:54.740 --> 01:54:59.740]  Ну, то есть не может быть так, что мы в вершину можем прийти и по суффиксу, и по не суффиксу.
[01:55:03.740 --> 01:55:06.740]  Да, хорошо. Ну, некоторых суффиксов.
[01:55:07.740 --> 01:55:08.740]  Терминальная вершина?
[01:55:09.740 --> 01:55:10.740]  Да, не обязательно всех.
[01:55:11.740 --> 01:55:12.740]  Да, некоторые.
[01:55:13.740 --> 01:55:19.540]  Либо это класс эквалентности, состоит только из суффиксов, не обязательно всех, но только из суффиксов,
[01:55:19.740 --> 01:55:24.740]  либо он состоит только из строк, которые суффиксами не являются.
[01:55:25.740 --> 01:55:26.740]  Тоже не всех.
[01:55:27.740 --> 01:55:28.740]  Ну, и тоже некоторые.
[01:55:28.740 --> 01:55:35.740]  И она тогда будет терминальна? Тогда она будет не терминальна.
[01:55:35.740 --> 01:55:38.740]  Ну тогда она не терминальна. Да.
[01:55:38.740 --> 01:55:45.740]  То есть следовательно нам надо найти все вершины, в классе эквалютности которых лежат суффиксы.
[01:55:45.740 --> 01:55:51.740]  Значит поехали. Самый длинный суффикс, суффикс это строка S.
[01:55:51.740 --> 01:55:54.740]  Вот ее там. Это стоковая вершина.
[01:55:55.740 --> 01:56:01.740]  В нее приходят в эквалютности строка S и несколько там чуть покороче суффиксов.
[01:56:01.740 --> 01:56:05.740]  И вот есть первый суффикс. Он у нас кстати S0 называется.
[01:56:05.740 --> 01:56:09.740]  Кстати это S0. Поприветствуем.
[01:56:09.740 --> 01:56:13.740]  Обратите внимание. И он.
[01:56:13.740 --> 01:56:17.740]  Ну вот это первый суффикс, который вот здесь не лежит.
[01:56:18.740 --> 01:56:24.740]  Там лежат все до какого-то момента.
[01:56:24.740 --> 01:56:29.740]  И этот момент называется S0. И он лежит в другом месте.
[01:56:29.740 --> 01:56:33.740]  Заметим, что этот момент описан в определении суффиксной ссылки.
[01:56:33.740 --> 01:56:36.740]  Переходим в суффиксную ссылку и говорим что эта вершина тоже терминальная.
[01:56:36.740 --> 01:56:40.740]  В ней лежат этот суффикс и еще несколько суффиксов предыдущих подряд.
[01:56:40.740 --> 01:56:45.740]  До какого-то момента. Этот момент описан в суффиксной ссылке уже из нее.
[01:56:46.740 --> 01:56:49.740]  В общем, почему других не будет терминальных?
[01:56:49.740 --> 01:56:53.740]  А потому что мы все суффиксы аккуратненько перебрали.
[01:56:57.740 --> 01:57:03.740]  Ну как бы, если объединить классы эквалютности этих вершин будут в точности все суффиксы.
[01:57:05.740 --> 01:57:12.740]  Потому что, напоминаю, в каждой вершине классы эквалютности состоит из одной строки и идущих подряд по длинам суффиксов.
[01:57:12.740 --> 01:57:13.740]  Причем без дыр.
[01:57:15.740 --> 01:57:20.740]  То есть у нас есть строка, строка без одного символа, строка без двух символов, строка без трех и так далее.
[01:57:20.740 --> 01:57:21.740]  Дыр не было.
[01:57:22.740 --> 01:57:25.740]  То есть каждый класс эквалютности выдаётся в этой ступе?
[01:57:25.740 --> 01:57:26.740]  Да.
[01:57:28.740 --> 01:57:31.740]  Да, к сожалению, это было в четвертом утверждении.
[01:57:32.740 --> 01:57:33.740]  Она же не цепится.
[01:57:33.740 --> 01:57:37.740]  Ну, в смысле, первая длинная и последняя?
[01:57:37.740 --> 01:57:38.740]  Ну да.
[01:57:38.740 --> 01:57:39.740]  Понял?
[01:57:39.740 --> 01:57:46.740]  У нас же говорили, что если у нас есть две строки в одной вершине, то они не просто одна из них суффиксов, а все суффиксы промежуточных длин тоже там есть.
[01:57:47.740 --> 01:57:50.740]  Поэтому как бы тут все суффиксы аккуратненько перечислены.
[01:57:52.740 --> 01:57:53.740]  Да, согласен.
[01:57:53.740 --> 01:57:54.740]  Вот, ура!
[01:57:55.740 --> 01:57:59.740]  Да, мы не знаем их, мы знаем только, ну правда, мы знаем длины лонгестов.
[01:57:59.740 --> 01:58:00.740]  Понятно, да?
[01:58:01.740 --> 01:58:02.740]  Вот.
[01:58:03.740 --> 01:58:05.740]  Вот, поэтому, ну это я к чему.
[01:58:05.740 --> 01:58:12.740]  Это я сказал, что в самом-самом конце, если нам очень надо, в 99% случаев, кстати, помечать в конце терминальность вершины нам не надо.
[01:58:14.740 --> 01:58:16.740]  Ну там хватает обычно.
[01:58:18.740 --> 01:58:19.740]  Вот.
[01:58:19.740 --> 01:58:21.740]  Значит, что тогда получается?
[01:58:21.740 --> 01:58:25.740]  То есть мы там в конце терминальней вершины пометим, это для нас не проблема.
[01:58:27.740 --> 01:58:28.740]  Вот.
[01:58:28.740 --> 01:58:30.740]  Но теперь давайте выясним вот что.
[01:58:31.740 --> 01:58:32.740]  Давайте же выясним.
[01:58:34.740 --> 01:58:37.740]  Является, значит, как найти S0?
[01:58:39.740 --> 01:58:41.740]  Как найти, куда входит S0?
[01:58:42.740 --> 01:58:46.740]  Вот как найти эту максимальную подстрочку?
[01:58:48.740 --> 01:58:54.740]  То есть максимальный суффикс строки С, который входит в S как подстрока?
[01:58:57.740 --> 01:58:58.740]  Как его найти?
[01:59:01.740 --> 01:59:04.740]  Если у нас есть автомат строки S, напоминаем.
[01:59:24.740 --> 01:59:26.740]  Суффикс на слухе, хочу, чтобы это поделилось.
[01:59:26.740 --> 01:59:32.740]  Мы от текущей максимальной строки смотрим, можно ли пройти по символу С.
[01:59:32.740 --> 01:59:33.740]  Ну да.
[01:59:33.740 --> 01:59:40.740]  То есть смотрите, что означает максимальный суффикс строки СС, который встречается в S как подстрока?
[01:59:40.740 --> 01:59:45.740]  Это максимальный суффикс строки S, из которого можно прыгнуть по символу С.
[01:59:46.740 --> 01:59:49.740]  То есть это означает, то есть на картинке это будет выглядеть так.
[01:59:51.740 --> 01:59:52.740]  Значит, смотрите.
[01:59:53.740 --> 01:59:55.740]  Так, значит, как это распил?
[01:59:55.740 --> 01:59:57.740]  Ну ладно, как это будет распил выглядеть?
[01:59:58.740 --> 02:00:00.740]  Сейчас я туда, и мы увидим вот что.
[02:00:01.740 --> 02:00:05.740]  Значит так, жила-было состояние S.
[02:00:06.740 --> 02:00:10.740]  Ну, эта строка является префиксом, она вообще никуда, то есть эта вершина никуда не денется.
[02:00:10.740 --> 02:00:13.740]  Ну, как вы уже поняли, старые вершины вообще никуда не денутся.
[02:00:14.740 --> 02:00:15.740]  Так вот, значит, поехали.
[02:00:16.740 --> 02:00:21.740]  То есть ищем первой, первой, первой, первой.
[02:00:25.740 --> 02:00:28.740]  То есть первой вершины на суффиксном пути.
[02:00:34.740 --> 02:00:36.740]  Из которой можно перейти по символу С.
[02:00:36.740 --> 02:00:46.740]  Так, бывает, кстати, один крайний случай, когда вы так дошли до стартовой вершины, и так ни одного либора по символу С не нашли.
[02:00:47.740 --> 02:00:48.740]  Может такое быть.
[02:00:49.740 --> 02:00:50.740]  Первый раз с вами встречались.
[02:00:51.740 --> 02:00:52.740]  Мне даже не обязательно.
[02:00:53.740 --> 02:00:55.740]  Нет, там даже не обязательно.
[02:00:56.740 --> 02:00:58.740]  Ну, теоретически такое может быть.
[02:00:59.740 --> 02:01:01.740]  Ну, практически, если тогда, ну вот.
[02:01:01.740 --> 02:01:02.740]  Ну, если тогда, ну вот.
[02:01:03.740 --> 02:01:04.740]  Ну, а теперь давайте, ну вот.
[02:01:04.740 --> 02:01:05.740]  Ну, если такое.
[02:01:10.740 --> 02:01:11.740]  Ну да, на самом деле, ну вот.
[02:01:12.740 --> 02:01:13.740]  Нет, на самом деле, нет.
[02:01:14.740 --> 02:01:18.740]  Нет, такое может быть только в том случае, в том и том и том случае, когда символ С новый для строки С.
[02:01:20.740 --> 02:01:25.740]  Потому что если вы даже стартовые вершины не можете перейти по символу С, значит, в строке С такого символа не было, правда?
[02:01:28.740 --> 02:01:29.740]  Логично, да?
[02:01:29.740 --> 02:01:36.740]  Помните, да, что у нас из стартовой вершины точить количество ребра по одному либу на каждый символ, встречающийся в строке С, правда?
[02:01:38.740 --> 02:01:44.740]  Поэтому да, то есть если символ С новый, то значит, вы так по суффиксным ссылкам заскачете до стартовой, так этого перехода не найдете.
[02:01:46.740 --> 02:01:51.740]  Но в этом случае все становится тривиально, тогда в этом случае С0, очевидно, равен просто Эпсилому, правда?
[02:01:54.740 --> 02:01:56.740]  То есть никакой новой вершины создавать не надо будет.
[02:01:56.740 --> 02:02:01.740]  То есть в этом случае вы там создадите просто новую вершину С и в общем-то все.
[02:02:02.740 --> 02:02:05.740]  Ну, с точки зрения вершин, напоминаю, не ребер.
[02:02:06.740 --> 02:02:07.740]  Понимаете, да?
[02:02:08.740 --> 02:02:09.740]  Топереча.
[02:02:10.740 --> 02:02:11.740]  Топереча.
[02:02:12.740 --> 02:02:16.740]  А теперь предположим, что вы шли и шли по суффиксным ссылкам, и вот основной случай.
[02:02:17.740 --> 02:02:25.740]  Когда С вы нашли, тогда заметим, что эта вершина является классом эквивалента.
[02:02:26.740 --> 02:02:27.740]  Эквивалентности С0.
[02:02:31.740 --> 02:02:33.740]  Но ключевой вопрос теперь какой?
[02:02:34.740 --> 02:02:36.740]  Является ли это С0 лонгистым в эйсе?
[02:02:39.740 --> 02:02:40.740]  Да или нет?
[02:02:44.740 --> 02:02:45.740]  Теперь внимание вопрос.
[02:02:46.740 --> 02:02:48.740]  А вот как нам теперь понять?
[02:02:49.740 --> 02:02:52.740]  Потому что важно это отличить, потому что если она является лонгистым, то ничего интересного.
[02:02:52.740 --> 02:02:57.740]  А если она не является лонгистым, ну тогда нам придется пострадать.
[02:02:58.740 --> 02:03:02.740]  То есть тогда нам придется как-то распределить этот класс эквивалентности на две.
[02:03:03.740 --> 02:03:06.740]  Нам надо посмотреть на л, этих двух вершинок.
[02:03:07.740 --> 02:03:09.740]  Заметьте, вот если это вершина П, а это вершина Q.
[02:03:10.740 --> 02:03:12.740]  Внимание, вопрос. Чему равна длина С0 в этих терминах?
[02:03:15.740 --> 02:03:16.740]  ЛНП плюс один.
[02:03:16.740 --> 02:03:17.740]  Да, совершенно верно.
[02:03:18.740 --> 02:03:22.740]  Вот модуль С0 равно ЛНП плюс один.
[02:03:23.740 --> 02:03:29.740]  Еще мы знаем, что длина С0 меньше либо равна ЛНК, естественно.
[02:03:33.740 --> 02:03:34.740]  Это мы уже точно знаем.
[02:03:35.740 --> 02:03:36.740]  И теперь нам остается только проверить.
[02:03:37.740 --> 02:03:39.740]  Откуда мы знаем, что ЛНК в пластиковой сной?
[02:03:40.740 --> 02:03:49.740]  Ну мы знаем, потому что С0 – это длина какой-то строки в этом классе эквалентности, а ЛНК – это длина максимальной строки в этом классе эквалентности.
[02:03:54.740 --> 02:03:56.740]  Поэтому, что же у нас получается?
[02:03:57.740 --> 02:03:58.740]  Ну поэтому теперь все, что нам остается, это проверить.
[02:03:59.740 --> 02:04:04.740]  Это неравенство является равенством или строгим неравенством? Прям проверить.
[02:04:05.740 --> 02:04:06.740]  То есть прям честно.
[02:04:06.740 --> 02:04:08.740]  А теперь думать, что тогда происходит?
[02:04:09.740 --> 02:04:10.740]  Ну тогда просто проверяем.
[02:04:11.740 --> 02:04:16.740]  То есть если ЛНК равно ЛНП плюс один, то тогда что происходит?
[02:04:17.740 --> 02:04:21.740]  Тогда мы просто создаем новую СЦ.
[02:04:29.740 --> 02:04:30.740]  О, мне идея.
[02:04:31.740 --> 02:04:34.740]  Ну не пришло ли время нам использовать новый маркер?
[02:04:37.740 --> 02:04:38.740]  Вот.
[02:04:45.740 --> 02:04:46.740]  Вот.
[02:04:47.740 --> 02:04:49.740]  Ну чтоб просто помечать у нас.
[02:04:51.740 --> 02:04:52.740]  Маленький.
[02:04:53.740 --> 02:04:54.740]  Это серийный маркер.
[02:04:55.740 --> 02:04:58.740]  Ладно, давайте кто скажет, это манджиэнта, это бирюзовый маркер.
[02:05:00.740 --> 02:05:01.740]  Ладно, потом да.
[02:05:01.740 --> 02:05:02.740]  А потом более продвинутые на самом деле.
[02:05:03.740 --> 02:05:05.740]  На самом деле это и начнут эти бинарные копиковые.
[02:05:09.740 --> 02:05:10.740]  Еще можно так, да.
[02:05:12.740 --> 02:05:13.740]  Вот.
[02:05:14.740 --> 02:05:15.740]  Вот.
[02:05:16.740 --> 02:05:17.740]  Есть ноль тоже маленькая.
[02:05:18.740 --> 02:05:20.740]  Я жалко сразу не сообразил, но ладно.
[02:05:21.740 --> 02:05:22.740]  Вот.
[02:05:23.740 --> 02:05:24.740]  Значит, смотрите.
[02:05:25.740 --> 02:05:28.740]  Итак, я, собственно, к чему я это сделал?
[02:05:28.740 --> 02:05:29.740]  Я это все.
[02:05:30.740 --> 02:05:31.740]  Я это все потому, что я хочу вот.
[02:05:32.740 --> 02:05:35.740]  Ну, малиновым мне хочется просто создавать вот типа новые датчики.
[02:05:36.740 --> 02:05:37.740]  Вот у меня есть этот С0.
[02:05:38.740 --> 02:05:39.740]  Да?
[02:05:40.740 --> 02:05:41.740]  Значит, ну давайте рассматривать.
[02:05:42.740 --> 02:05:43.740]  Вот есть у меня этот С0.
[02:05:44.740 --> 02:05:45.740]  Ну начнем с того, что ЛН здесь.
[02:05:46.740 --> 02:05:47.740]  Ну понятно, равен ЛН здесь плюс один.
[02:05:48.740 --> 02:05:49.740]  Ну или что, тоже самая длина этой строки.
[02:05:50.740 --> 02:05:51.740]  В общем, мне интересно.
[02:05:52.740 --> 02:05:54.740]  Ну, мы пока про переходы не говорим, но теперь нам интересно.
[02:05:55.740 --> 02:05:56.740]  Так, вот давайте.
[02:05:56.740 --> 02:05:57.740]  Мне казалось, что вот тут равенство.
[02:05:58.740 --> 02:06:01.740]  Тогда мы поняли, что новые вершины ставить не надо.
[02:06:06.740 --> 02:06:10.740]  И тогда мы выясняем, что все, что нам остается, это найти пока.
[02:06:11.740 --> 02:06:13.740]  А куда у нас суффиксная ссылка отсюда отправится?
[02:06:17.740 --> 02:06:18.740]  Все?
[02:06:19.740 --> 02:06:20.740]  Ну да.
[02:06:20.740 --> 02:06:21.740]  Ну и соответственно и останется.
[02:06:22.740 --> 02:06:26.740]  Останется только просто вот у этой свежеприготовленной вершины отправить суффиксную ссылку сюда и больше не тут.
[02:06:27.740 --> 02:06:28.740]  Автомат готов.
[02:06:29.740 --> 02:06:30.740]  Ну ладно, еще ребра надо.
[02:06:31.740 --> 02:06:32.740]  Срочно будем я сейчас отбираться.
[02:06:34.740 --> 02:06:36.740]  Ну а теперь давайте более интересный случай.
[02:06:37.740 --> 02:06:41.740]  А что делать, если неожиданно выяснилось, что здесь строго больше?
[02:06:42.740 --> 02:06:43.740]  Ну, я думаю, что здесь будет больше.
[02:06:44.740 --> 02:06:48.740]  А что делать, если неожиданно выяснилось, что здесь строго больше?
[02:06:48.740 --> 02:06:49.740]  Что здесь строго больше?
[02:06:51.740 --> 02:06:52.740]  Что делать?
[02:06:55.740 --> 02:06:56.740]  Ну все, давайте выяснить.
[02:06:57.740 --> 02:06:59.740]  Тогда мы обнаружим следующее.
[02:07:01.740 --> 02:07:08.740]  Тогда мы обнаружим, что нам придется сказать, что ладно, эта вершина, у нее там был свой лонгест, этому лонгесту она и останется соответствует.
[02:07:10.740 --> 02:07:15.740]  Мы сказали, если у нас была лонгестом, то мы суффиксную ссылку...
[02:07:16.740 --> 02:07:20.740]  То мы суффиксную ссылку из ССС просто в эту курю отправляем.
[02:07:23.740 --> 02:07:27.740]  А сейчас, значит, придется создать новую вершину для ареста.
[02:07:28.740 --> 02:07:29.740]  То есть, что произошло, напоминаю?
[02:07:30.740 --> 02:07:34.740]  Произошло то, что у нас был класс эквивалентности у этой строки, да?
[02:07:35.740 --> 02:07:37.740]  И он разбился на два.
[02:07:38.740 --> 02:07:39.740]  Почему он разбился на два?
[02:07:40.740 --> 02:07:42.740]  Он разбился на два по одной причине.
[02:07:42.740 --> 02:07:46.740]  Начиная с С0, вот эти строки стали суффиксами строки СС, а эти...
[02:07:47.740 --> 02:07:49.740]  А эти не являются суффиксами строки СС.
[02:07:51.740 --> 02:07:52.740]  Понятно, да?
[02:07:53.740 --> 02:07:54.740]  Почему?
[02:07:55.740 --> 02:07:56.740]  Ну, потому так получилось.
[02:07:57.740 --> 02:07:58.740]  Слушай, напоминаю.
[02:07:59.740 --> 02:08:04.740]  Потому что С0 это максимальный суффикс строки СС, который есть в строке С как подстрока.
[02:08:05.740 --> 02:08:06.740]  Почему выше у меня суффиксы?
[02:08:07.740 --> 02:08:08.740]  А, все, да, ясно.
[02:08:09.740 --> 02:08:10.740]  Потому что это две строки.
[02:08:10.740 --> 02:08:12.740]  А эти суффиксы и все, кто дальше, тоже будут суффиксами.
[02:08:13.740 --> 02:08:16.740]  То есть, обратите внимание, на самом деле, ровно поэтому класс разваливается.
[02:08:17.740 --> 02:08:19.740]  Потому что, как бы, чем они отличаются с точки зрения...
[02:08:20.740 --> 02:08:25.740]  То есть, с точки зрения правых контекстов, на самом деле, правые контекста отличаются тем, что к этим строчкам добавился эпсилом.
[02:08:27.740 --> 02:08:28.740]  Ну, в смысле, последняя.
[02:08:29.740 --> 02:08:30.740]  А у этих ничего не поменялось.
[02:08:31.740 --> 02:08:32.740]  Ну, не поменялось в смысле, вот, где вот они заканчиваются.
[02:08:33.740 --> 02:08:36.740]  То есть, понятно, там все строки увеличились на СМОС, естественно, в правом контексте, да?
[02:08:36.740 --> 02:08:37.740]  Но конкретно здесь еще появился дополнительный эпсил.
[02:08:38.740 --> 02:08:43.740]  Поэтому это мы отправим в кул, а этой вершине мы составим понятие клон.
[02:08:44.740 --> 02:08:45.740]  Мы ее назовем клон.
[02:08:46.740 --> 02:08:47.740]  Понятно, да?
[02:08:48.740 --> 02:08:49.740]  Вот.
[02:08:51.740 --> 02:08:54.740]  И суффиксные ссылки теперь направятся там.
[02:08:55.740 --> 02:08:56.740]  Вот.
[02:08:57.740 --> 02:08:58.740]  Вот.
[02:08:58.740 --> 02:08:59.740]  Вот.
[02:09:00.740 --> 02:09:01.740]  Вот.
[02:09:03.740 --> 02:09:06.740]  И суффиксные ссылки теперь направятся так.
[02:09:07.740 --> 02:09:10.740]  То есть, смотрите, вот у кул была какая-то суффиксная ссылка, да?
[02:09:12.740 --> 02:09:14.740]  Вот она вела в какую-то мистическую вершину.
[02:09:15.740 --> 02:09:16.740]  Там, видите?
[02:09:17.740 --> 02:09:18.740]  Тоже вот.
[02:09:19.740 --> 02:09:20.740]  Еще тоже.
[02:09:21.740 --> 02:09:22.740]  Вот это, да?
[02:09:23.740 --> 02:09:29.740]  Тогда заметим, что так как этот клас разбавился, то теперь, значит, мы из клона эту суффиксную ссылку направляем сюда.
[02:09:32.740 --> 02:09:35.740]  А из кул суффиксная ссылка направляется в клона.
[02:09:36.740 --> 02:09:37.740]  Ну, по определению, правда?
[02:09:38.740 --> 02:09:39.740]  Да.
[02:09:40.740 --> 02:09:46.740]  И, конечно же, из этой вершины, так или иначе, суффиксная ссылка отправляется в клон.
[02:09:53.740 --> 02:09:54.740]  Вот такая красота.
[02:10:00.740 --> 02:10:04.740]  То есть, вот получается, таким вот образом мы можем хитро разбираться
[02:10:04.740 --> 02:10:11.740]  на тему того, действительно, какие новые вершины у нас появятся.
[02:10:12.740 --> 02:10:13.740]  Можем даже их в явном виде почислять.
[02:10:15.740 --> 02:10:18.740]  Ну, мы на слайдинге себе оставим вопрос, почему это работает за лигию.
[02:10:20.740 --> 02:10:23.740]  Слушай, за лигию будем оценивать уже, когда сейчас подумаем.
[02:10:24.740 --> 02:10:27.740]  Подумаем, а как же нам все-таки восстанавливать веру?
[02:10:28.740 --> 02:10:31.740]  Прежде чем мы снимаем это, понятно ли, как строить все, кроме игры?
[02:10:32.740 --> 02:10:35.740]  Нет, а что мы только что научились сделать?
[02:10:36.740 --> 02:10:41.740]  Мы научились понимать, какие новые вершины у нас появятся.
[02:10:42.740 --> 02:10:44.740]  И какие будут у них суффиксные ссылки.
[02:10:46.740 --> 02:10:50.740]  Ну, то есть, появится дополнительный оборот, да, но, возможно, еще клон или нет?
[02:10:51.740 --> 02:10:54.740]  Да, возможно, клон. Причем мы научились даже понимать, появится он или нет.
[02:10:55.740 --> 02:10:56.740]  И все.
[02:10:56.740 --> 02:10:57.740]  Да.
[02:10:59.740 --> 02:11:01.740]  Еще мы научились пересчитывать у новых вершин суффиксные ссылки.
[02:11:02.740 --> 02:11:06.740]  Еще иногда вот у одной вершины, в одном случае, видите, перенаправлять старую.
[02:11:07.740 --> 02:11:08.740]  Да.
[02:11:09.740 --> 02:11:12.740]  А еще я предпочитаю, что мы научились у этих новых вершин вычислять лены.
[02:11:16.740 --> 02:11:20.740]  И вот еще, конечно, мы научились делать с клонами.
[02:11:21.740 --> 02:11:25.740]  Ну, создаем новую вершину, называем ее по каким-то пока непонятным причинам клон.
[02:11:26.740 --> 02:11:27.740]  Вот.
[02:11:28.740 --> 02:11:31.740]  И говорим, что она соответствует теперь S0.
[02:11:33.740 --> 02:11:37.740]  То есть, как бы у нас класс эквалентности вершины Q развивался на два.
[02:11:38.740 --> 02:11:41.740]  Вот в клоне будет то, что S0 ниже, а то, что выше, останется в Q.
[02:11:42.740 --> 02:11:43.740]  Вот.
[02:11:44.740 --> 02:11:45.740]  Вот и все.
[02:11:46.740 --> 02:11:48.740]  И после этого мы говорим, что суффиксные ссылки перенаправляются так.
[02:11:49.740 --> 02:11:52.740]  Из клона суффиксные ссылки ведет туда, куда она вела из вершины Q.
[02:11:53.740 --> 02:11:58.740]  Из Q суффиксная ссылка теперь ведет в клона, и из S0, естественно, она тоже ведет в клона.
[02:11:59.740 --> 02:12:01.740]  Все это, если говорить на уровне алберта.
[02:12:02.740 --> 02:12:04.740]  Ну, конечно, будет интересно понимать, почему это так.
[02:12:09.740 --> 02:12:10.740]  Вот почему это так.
[02:12:14.740 --> 02:12:15.740]  Так, понятно, почему это так.
[02:12:16.740 --> 02:12:19.740]  Ну, потому что теперь основание как раз небольшой суффикс.
[02:12:19.740 --> 02:12:22.740]  Да, поэтому из S0 суффиксная ссылка ведет в него, это да.
[02:12:23.740 --> 02:12:28.740]  Из Q в него ведет теперь ссылка, потому что, ну, потому что класс эквалентности разбился на два.
[02:12:29.740 --> 02:12:32.740]  И очевидно, в этом случае из верхнего класса эквалентности ссылка теперь ведет в нижний.
[02:12:33.740 --> 02:12:39.740]  Ну, а из нижнего, получается, суффиксная ссылка ведет туда, куда она из, собственно, этого производившегося класса раньше вела.
[02:12:42.740 --> 02:12:47.740]  В общем, да, если вы хорошо понимаете, как устроены классы эквалентности, то это все очень простые утверждения.
[02:12:50.740 --> 02:12:51.740]  То есть это дело привычки, в общем.
[02:12:52.740 --> 02:12:53.740]  В чем разница между Q и Qn?
[02:12:54.740 --> 02:12:55.740]  Сейчас.
[02:12:56.740 --> 02:12:57.740]  Они создают разные классы эквалентности.
[02:12:58.740 --> 02:12:59.740]  Они создают разные классы эквалентности.
[02:13:01.740 --> 02:13:04.740]  Ведь S0 теперь у клона, а сверху там не S0, сверху...
[02:13:06.740 --> 02:13:13.740]  Ну, сверху какие-то строки, которые раньше до появления CWLX были эквалентны S0, а теперь перестали.
[02:13:19.740 --> 02:13:20.740]  Отличия...
[02:13:21.740 --> 02:13:22.740]  Кстати, да, чем они отличаются?
[02:13:23.740 --> 02:13:26.740]  Вот забегая вперед на все ноли, отличаются они следующим.
[02:13:27.740 --> 02:13:32.740]  То есть, заметим, что в их классе, то есть, их правые контекста отличаются только одним.
[02:13:33.740 --> 02:13:38.740]  В правом контексте нижнего класса есть эксилон, потому что это является суффиксами С.
[02:13:39.740 --> 02:13:42.740]  А те, кто выше S0, они суффиксами не являются.
[02:13:43.740 --> 02:13:44.740]  Вот.
[02:13:45.740 --> 02:13:50.740]  Но так как у нас, кроме этого суффикса, у них хождение заканчивалось в одних и тех же позициях,
[02:13:51.740 --> 02:13:52.740]  то тогда получается, что...
[02:13:53.740 --> 02:13:57.740]  Получается, что, действительно, то есть, правый контекст этого, это как правый контекст этого, только плюс эксилон.
[02:13:58.740 --> 02:14:02.740]  Вот, кстати, почему мы понимаем, что n называют вершину клон?
[02:14:03.740 --> 02:14:11.740]  Потому что отсюда следует очевидная вещь, что мы тогда переходы, которые ведут из вершины клон, тупо копируем из вершины Q.
[02:14:13.740 --> 02:14:15.740]  Я тупо берем и копирую.
[02:14:16.740 --> 02:14:18.740]  Почему у них совпадают правые контесты?
[02:14:19.740 --> 02:14:24.740]  Ну, потому что у них позиции окончания, эти вхождения этих строк совпадают.
[02:14:25.740 --> 02:14:30.740]  Ну, до появления, смотри, до появления символа С они совпадали прям идентичные, да?
[02:14:31.740 --> 02:14:38.740]  Но при появлении символа С у этой строти и у ее потомков появился ровно одно вхождение в самом конце.
[02:14:39.740 --> 02:14:40.740]  Да, ясно.
[02:14:40.740 --> 02:14:43.740]  То есть, получается, отличие этой вершины от этой только одно.
[02:14:44.740 --> 02:14:48.740]  По сути, эта вершина будет терминальной, а эта нет. Все.
[02:14:54.740 --> 02:14:57.740]  В общем-то, а переходы у них одни и те же.
[02:14:58.740 --> 02:14:59.740]  Понимаете, да?
[02:15:00.740 --> 02:15:02.740]  Переходы, которые ведут из.
[02:15:03.740 --> 02:15:05.740]  То есть, они ведут вот, потому что другие классы эквализуют.
[02:15:06.740 --> 02:15:12.740]  Ну, там надо может поразбирать случаи, потому что может быть там, оказалось, что эта вершина Q тоже на этом пути в принципе лежит.
[02:15:13.740 --> 02:15:14.740]  Может быть, такое, да?
[02:15:15.740 --> 02:15:18.740]  Там она лежит и там, может быть, из нее надо сделать новый переход.
[02:15:19.740 --> 02:15:20.740]  Ну, теперь, кстати, об этом.
[02:15:21.740 --> 02:15:25.740]  Какие новые переходы надо делать вообще?
[02:15:26.740 --> 02:15:31.740]  Ну, из класса эквализации S в С в классе эквализации С в С в С.
[02:15:32.740 --> 02:15:34.740]  Да, да. Ну, давайте думать.
[02:15:35.740 --> 02:15:37.740]  Так, ну, во-первых, давайте подумаем.
[02:15:38.740 --> 02:15:39.740]  Значит, какие новые переходы?
[02:15:40.740 --> 02:15:41.740]  Ну, во-первых, алгоритм будет устроен так.
[02:15:42.740 --> 02:15:48.740]  Что, во-первых, заметим, что из всех вот этих вот товарищей нужно сделать переход по символу С.
[02:15:49.740 --> 02:15:50.740]  Да, то есть, напоминаю.
[02:15:50.740 --> 02:15:55.740]  Напоминаю, из этих всех вершин перехода по символу С не было.
[02:15:56.740 --> 02:15:58.740]  Ну, здесь из этой вершины вообще переходов не было.
[02:15:59.740 --> 02:16:00.740]  А тут вот.
[02:16:01.740 --> 02:16:02.740]  Вот я так.
[02:16:08.740 --> 02:16:10.740]  Ну, во-первых, находить переходы сразу можно.
[02:16:11.740 --> 02:16:13.740]  Прям, вы скачете по суффиксным ссылкам, прямо нет перехода.
[02:16:14.740 --> 02:16:16.740]  Ладно, добавляете в новую вершину и, собственно, радуете.
[02:16:17.740 --> 02:16:24.740]  Действительно, такие переходы должны быть, потому что, действительно, мы перебираем суффиксы строки С.
[02:16:25.740 --> 02:16:33.740]  И мы знаем, что если к ним приписать С, то должны получиться суффиксы строки СС, причем которые нигде, кроме как в конце СС, не встречаются.
[02:16:34.740 --> 02:16:36.740]  Поэтому переходы по символу С из них должны отправиться сюда.
[02:16:37.740 --> 02:16:38.740]  Понимаете, да?
[02:16:39.740 --> 02:16:44.740]  И вот мы нашли первую вершину, у которой переход по символу С есть.
[02:16:44.740 --> 02:16:45.740]  Так.
[02:16:46.740 --> 02:16:49.740]  Говорим мы. Ой-ой-ой. Ой-ой-ой. Ой-ой-ой.
[02:16:50.740 --> 02:16:56.740]  Так, заметим, что начиная с этого момента, переходы по символу С, в общем-то, перенаправлять сюда не надо.
[02:16:57.740 --> 02:17:03.740]  Потому что там уже начнутся строки, которые, помимо, вроде как в конце СС, встречаются где-то еще.
[02:17:04.740 --> 02:17:05.740]  Понимаете, да?
[02:17:07.740 --> 02:17:08.740]  Вот.
[02:17:09.740 --> 02:17:10.740]  Так легко.
[02:17:10.740 --> 02:17:11.740]  Так легко.
[02:17:12.740 --> 02:17:14.740]  Ну, теперь, значит, с чего начнем?
[02:17:15.740 --> 02:17:16.740]  Значит, начнем с простого случая.
[02:17:17.740 --> 02:17:30.740]  Так, ну давайте, самый простой случай у нас, это когда мы прям вот, давайте, прям шли-шли-шли-шли, вот давайте, для разминочки, и прям вот до стартовой вершины и дошли.
[02:17:30.740 --> 02:17:37.740]  И обнаружили, что ни одного перехода по символу С у нас, вот самый простой случай.
[02:17:45.740 --> 02:17:46.740]  Что тогда делать?
[02:17:47.740 --> 02:17:52.740]  Ну, естественно, из них мы перекидываем переход по символу С.
[02:17:53.740 --> 02:17:54.740]  Ну, теперь возникает естественный вопрос.
[02:17:54.740 --> 02:17:58.740]  А нужно ли добавлять какие-то еще переходы?
[02:17:59.740 --> 02:18:03.740]  Или, может быть, какие-то переходы надо удалить или поменять?
[02:18:08.740 --> 02:18:11.740]  Ну, это означает, что С встречаются впервые?
[02:18:12.740 --> 02:18:13.740]  Да.
[02:18:14.740 --> 02:18:15.740]  Ну да.
[02:18:16.740 --> 02:18:17.740]  И, значит, с чего начнем?
[02:18:17.740 --> 02:18:19.740]  Ну, это означает, что С встречаются впервые?
[02:18:20.740 --> 02:18:21.740]  Да.
[02:18:22.740 --> 02:18:23.740]  Ну да.
[02:18:24.740 --> 02:18:31.740]  Из этого автоматически означает, что да, что переходы по символу С должны быть в точности из стратеи С и юсуфиксов и вести сюда, больше вариантов нет.
[02:18:32.740 --> 02:18:33.740]  Отлично.
[02:18:34.740 --> 02:18:36.740]  А что можно сказать по другим переходам?
[02:18:37.740 --> 02:18:44.740]  Хорошо, да, у нас там не было переходов по символу С, но ведь там были переходы по разным другим нуклам, может быть, там надо как-то поменять?
[02:18:45.740 --> 02:18:48.740]  Вот да, мы помнили, что вершины не меняются, а переходы.
[02:18:49.740 --> 02:18:53.740]  Ну, понятно, что да, но пока не считаются никакие переходы, кроме вот этих переходов по С.
[02:18:54.740 --> 02:18:55.740]  А почему это?
[02:18:56.740 --> 02:18:57.740]  А почему это? Понятно.
[02:18:58.740 --> 02:19:03.740]  Ну, у нас каждой вершины соответствует набор слов, да, по которым можно у него поискать.
[02:19:04.740 --> 02:19:05.740]  Да, классы квалифиций.
[02:19:06.740 --> 02:19:07.740]  И он классы квалифиций этих подстроек, и он не изменился.
[02:19:08.740 --> 02:19:09.740]  Ну да.
[02:19:10.740 --> 02:19:11.740]  Ну вот добавился новый классы квалифиций для СС.
[02:19:12.740 --> 02:19:13.740]  Ну да.
[02:19:14.740 --> 02:19:18.740]  Так что символ не С, оно как бы вело из одного классы квалифиций в другой, так оно и будет вести.
[02:19:19.740 --> 02:19:20.740]  Да и в принципе верно, действительно.
[02:19:21.740 --> 02:19:27.740]  Давайте вспомним, что вообще означает, что ребро ведет из класса, по любому символу, не важно там какому, игр.
[02:19:28.740 --> 02:19:33.740]  Вот что означает, что ребро ведет из класса эквалентности в класс эквалентности по символу игр?
[02:19:34.740 --> 02:19:35.740]  Что это означает?
[02:19:36.740 --> 02:19:39.740]  Это означает следующее, что тут есть какой-то класс эквалентности из каких-то строчек.
[02:19:40.740 --> 02:19:49.740]  И ребро ведет в класс эквалентности, где есть все вот эти же строчки, только с приписанным к нему символом игр.
[02:19:50.740 --> 02:20:00.740]  Ну может быть, ну на самом деле, если уж полностью рисовать как тут устроено, то на самом деле может быть там еще какие-то продвинутые строчки есть.
[02:20:01.740 --> 02:20:10.740]  То есть если рассмотреть какие вообще символы ведут, то есть ребра ведут в вершину, то вообще можно обнаружить интересный факт.
[02:20:11.740 --> 02:20:12.740]  Да, то есть можно обнаружить.
[02:20:13.740 --> 02:20:15.740]  Давайте, чтобы это обнаружить, я еще маркер возьму.
[02:20:16.740 --> 02:20:21.740]  Да, что тут вот, можно взять подлиннее, вот так вот.
[02:20:22.740 --> 02:20:25.740]  Так вот, допустим, такие две строчки.
[02:20:26.740 --> 02:20:30.740]  Тут у нас будет чуть-чуть еще там пара строчек.
[02:20:31.740 --> 02:20:32.740]  Ладно, даже три строчки.
[02:20:33.740 --> 02:20:36.740]  Вот это сюда, это сюда, это сюда.
[02:20:37.740 --> 02:20:38.740]  Вот.
[02:20:39.740 --> 02:20:42.740]  И если из них, ну вот, и получится следующее.
[02:20:43.740 --> 02:20:45.740]  И из них всех будут вести их вот так вот.
[02:20:46.740 --> 02:20:50.740]  И тогда класс эквалентности получится в точности быть.
[02:20:51.740 --> 02:20:55.740]  Там игрок, видите, вот два плюс вот эти вот три, да.
[02:20:58.740 --> 02:20:59.740]  Вот.
[02:21:00.740 --> 02:21:01.740]  Еще вот эти три.
[02:21:02.740 --> 02:21:05.740]  Да, тут подлинном, конечно, не очень сходится, но вот так вот.
[02:21:06.740 --> 02:21:08.740]  И более того, там еще.
[02:21:09.740 --> 02:21:14.740]  Ну естественно, кстати, все эти как бы товарищи связаны с суффиксными ссылками, кстати, что приятно.
[02:21:15.740 --> 02:21:16.740]  Вот.
[02:21:17.740 --> 02:21:18.740]  Оп.
[02:21:19.740 --> 02:21:20.740]  Оп-оп.
[02:21:21.740 --> 02:21:26.740]  То есть мы тут идем, идем, тут везде переходы по игроку есть, да, все переходы.
[02:21:27.740 --> 02:21:35.740]  Кстати, интересный факт отсюда следует, что в каждую вершину все ребра, все ребра, кто входит в вершину, они по одному и тому же символу, обратите внимание.
[02:21:36.740 --> 02:21:38.740]  Еще такое интересное.
[02:21:39.740 --> 02:21:40.740]  Да, конечно.
[02:21:41.740 --> 02:21:45.740]  Ну просто потому, что все, все классы эквалентности заканчиваются на один и тот же символ.
[02:21:46.740 --> 02:21:47.740]  Так что, да.
[02:21:47.740 --> 02:21:59.740]  Ну и тут, естественно, может произойти, когда наконец-то произошло, когда тут ребро идет куда-то еще, это означает, что это вот суффиксная ссылка, потому что наконец-то вот этот класс эквалентности закончился.
[02:22:00.740 --> 02:22:09.740]  То есть видите, мы взяли такие последовательные классы эквалентности, такие по суффиксным ссылкам, приписали к ним игрок, обнаружили, что строчки объединились в большой класс эквалентности.
[02:22:10.740 --> 02:22:12.740]  То есть вот так это выглядит.
[02:22:14.740 --> 02:22:15.740]  Понятно, да?
[02:22:17.740 --> 02:22:18.740]  Да, в целом.
[02:22:19.740 --> 02:22:22.740]  Вот. То есть это означает, да, видите, что означает, что ребро идет отсюда-сюда.
[02:22:23.740 --> 02:22:28.740]  Значит, если мы к этому классу эквалентности припишем игрок, то это станет частью вот этого класса эквалентности.
[02:22:29.740 --> 02:22:36.740]  Но заметим, что вот в этом особенно случае классы эквалентности, ну кроме вот этого, не поменялись от слова вообще.
[02:22:37.740 --> 02:22:44.740]  Следовательно, и ребра между ними, вот между ними, которые были, неважно, кстати, по символу C или не по символу C, не поменялись от слова вообще.
[02:22:45.740 --> 02:22:46.740]  Понятно, да?
[02:22:48.740 --> 02:22:50.740]  Поэтому становится верно автоматически следующее.
[02:22:51.740 --> 02:23:00.740]  То есть даже не просто этот случай, а вот давайте следующий у нас по сложности случай говорит нам о том, что вот допустим мы тут все-таки нашли этот вот S0.
[02:23:01.740 --> 02:23:02.740]  Вот это я убираю.
[02:23:04.740 --> 02:23:10.740]  Вот. И говорю, вот неожиданно вот этот вот S0 нашелся, но неожиданно выяснилось, что это вершина Q.
[02:23:10.740 --> 02:23:16.740]  И здесь оказалось, что, допустим, S0 равно лонгестот S0 от своего плана.
[02:23:17.740 --> 02:23:18.740]  Лонгестот, допустим.
[02:23:20.740 --> 02:23:25.740]  Тогда мы замечаем следующее, что классы эквалентности, опять же, не поменялись, правда?
[02:23:26.740 --> 02:23:36.740]  То есть поменялись они только в том плане, что довалился вот этот S, но все ребра, которые должны вести в него, мы и провели, а ребра грядущих из него быть не должно.
[02:23:36.740 --> 02:23:39.740]  Поэтому получается, что тоже вообще ничего менять не надо, правда?
[02:23:40.740 --> 02:23:41.740]  Понимаете?
[02:23:42.740 --> 02:23:47.740]  То есть ну и по ядой, как всегда, нарисовали суффиксную ссылку и возрадовались.
[02:23:51.740 --> 02:23:57.740]  И чуть-чуть-чуть-чуть более сложным оказывается случай с флоном.
[02:23:57.740 --> 02:24:08.740]  Потому что если оказалось, что S0 не равен, то мы также снаобъявляем, что у нас классы эквалентности Q, вот этот вот, С, С, С, С.
[02:24:09.740 --> 02:24:13.740]  Неожиданно, скулков нет, разбился на B.
[02:24:20.740 --> 02:24:21.740]  Ну тогда что это значит?
[02:24:21.740 --> 02:24:33.740]  С точки зрения ребр, которые ведут из этих классов эквалентности, мы замечаем, что на самом деле ребра, ведущие из этих классов эквалентности, из этого и из этого, они идентичны, правда?
[02:24:36.740 --> 02:24:37.740]  Логично, да?
[02:24:37.740 --> 02:24:45.740]  Да, ну, кстати, единственная только оговорка, что могло так случиться, что мы для вершины Q, пока тут шли, уже создали этот новый переход по символу С.
[02:24:46.740 --> 02:24:47.740]  Вот.
[02:24:48.740 --> 02:24:51.740]  Ну там надо либо доказать, что этого не произошло, либо...
[02:24:53.740 --> 02:24:54.740]  Не важно.
[02:24:55.740 --> 02:24:56.740]  Вот.
[02:24:56.740 --> 02:24:58.740]  Поэтому дальше происходит следующее.
[02:24:58.740 --> 02:25:03.740]  Обратите внимание, что тогда получается, что переходы мы прям копируем, прям вот, прям копипаста.
[02:25:06.740 --> 02:25:19.740]  А что касается переходов в клон, то замечаем, что на самом деле, раз класс эквалентности разбился на 2, значит просто часть переходов, которые вели в эту вершину, они получается просто теперь должны вести в клон.
[02:25:19.740 --> 02:25:20.740]  Причем, как они устроены?
[02:25:20.740 --> 02:25:25.740]  Вот мы знаем, что у нас был набор переходов, ведущие в нашу вершину Q, да?
[02:25:27.740 --> 02:25:30.740]  И теперь мы знаем следующее, что класс эквалентности разбился на 2.
[02:25:31.740 --> 02:25:36.740]  То есть мы знаем, что в принципе все вершины, из которых ведут ребра по этому символу, они вот устроены так.
[02:25:38.740 --> 02:25:44.740]  И мы видим, что, для этого, мы знаем, что все вершины, из которых ведут ребра по этому символу, они вот устроены так.
[02:25:44.740 --> 02:25:53.740]  И мы видим, что, если как бы имелись в виду строчки длинные с 0 или меньше, то тогда теперь ребра должны быть перенаправлены в клон.
[02:25:53.740 --> 02:25:56.740]  А те, кто были длин больше, то они как в Q или так и остались.
[02:25:57.740 --> 02:26:10.740]  Ну, тогда получается, то есть получается, раз мы тут создали клона, то получается, что самая длинная строчка, которую надо перенаправить, она вот здесь и есть, лент П плюс 1, она же и столь, правда?
[02:26:10.740 --> 02:26:16.200]  вот здесь и есть лент П плюс один, а она же столь, правда? То есть получается вот конкретно ее надо
[02:26:16.200 --> 02:26:26.240]  перенаправить. И все последующие. Да, и все последующие, которые ввели в Q. То есть получается вот так.
[02:26:26.240 --> 02:26:32.420]  То есть дальше получается мы делаем, то есть получается алгоритм строим так. Мы идем дальше
[02:26:32.420 --> 02:26:39.860]  по суффиксным ссылкам до тех пор, пока тут ведут переходы по символу С. Ну вот, и перенаправляем
[02:26:39.860 --> 02:26:52.060]  их в клон. Тут по символу С. Именно в Q. И все эти ребра перенаправляем. А по остальным буквам
[02:26:52.060 --> 02:26:55.300]  получается больше ничего не поменял.
[02:27:03.420 --> 02:27:18.580]  Ну это все. От клона до С. От клона до С. А вот давайте подумаем. Ведь, естественно, надо еще подумать,
[02:27:18.580 --> 02:27:25.340]  что могли бы какие-нибудь экзотические случаи, типа из клона в С, может быть из клона в Q какое-нибудь
[02:27:25.340 --> 02:27:29.900]  ребро появилось, мало ли из Q в клон. Ну из Q в клон они появились по очевидным причинам,
[02:27:29.900 --> 02:27:37.380]  потому что в клоне класса квалетности длин меньше, чем Q, правда? Но теоретически, наверное,
[02:27:37.380 --> 02:27:42.580]  могло быть так, что из клона тоже должно появиться не только старое ребро в СQ, надо скопировать,
[02:27:42.580 --> 02:27:51.700]  но еще и нарисовать ребро в СЦ. Но давайте подумаем, а что это такое вообще? Что это означает? То есть из
[02:27:51.700 --> 02:28:03.140]  клона надо привести ребро по, видимо, символу С. Почему? Ну давайте подумаем, происходит это в каком-то
[02:28:03.140 --> 02:28:09.060]  случае. Ну заметим следующее, что если у нас была строка С и стал символ С, и если мы из нее должны
[02:28:09.060 --> 02:28:16.860]  нарисовать ребро по символу С, то что это значит? Как минимум это означает, что С0 не просто суффикс С,
[02:28:16.860 --> 02:28:30.740]  но он еще и суффикс строки С. Ну все и не все. Нет, на самом деле такое может быть, если тут ССССС,
[02:28:30.740 --> 02:28:43.020]  тут какая-нибудь буква А и какая-нибудь градость. А тут вот ССССС больше не встречается. Так что такое,
[02:28:43.020 --> 02:28:56.700]  в принципе, возможно. Но есть один маленький нюанс. Тогда в этом случае заметим, что... Смотрите,
[02:28:56.700 --> 02:29:14.100]  раз СССССС это суффикс, тогда я утверждаю следующее. Вот тогда мы думаем, если вот это вот клон,
[02:29:14.100 --> 02:29:22.620]  вот это вот СССС стало новым лонгистом. Но это означает, что действительно СССС встречалось
[02:29:22.620 --> 02:29:41.580]  здесь. Может быть еще где-то там как минимум СССС встречалось. Ну короче говоря, просто заметим,
[02:29:41.580 --> 02:29:50.140]  что вот это вот ССС, оно на самом деле, то есть сама по себе вот эта строка СССС, которая
[02:29:50.140 --> 02:29:58.420]  соответствовала строке даже, получается, Q, она являлась суффиксом строки С. То есть она
[02:29:58.420 --> 02:30:06.380]  встретилась на этом пути. А раз она встретилась на этом пути, это означает, что мы пока тут ходили,
[02:30:06.380 --> 02:30:16.140]  создали из нее переход по силу С, и получается он скопировался. Понимаете, да? То есть поэтому
[02:30:16.140 --> 02:30:23.300]  получается, что алгоритм хитрый. Оказывается, когда мы копировали переход, мы как бы новый
[02:30:23.300 --> 02:30:28.860]  переход скопировали. Но правда для этого, чтобы совсем довести это до аккуратности,
[02:30:28.860 --> 02:30:33.500]  надо теперь показать, что на самом деле тут как бы либо этот переход всегда будет,
[02:30:33.500 --> 02:30:41.740]  ли этот переход всегда не будет. Ну мы сказали, что действительно, если переход неожиданно из
[02:30:41.860 --> 02:30:54.700]  С0, по символу S сюда нужен. То есть из этой лиршины переход в СС нужен тогда и
[02:30:54.700 --> 02:31:08.380]  только тогда, когда действительно С0 состоит только из символа С., то есть как мы только locally
[02:31:08.380 --> 02:31:21.380]  Ну, конечно, потому что вы сказали, что из этой штуки должен быть переход по символу c сюда, тогда и только тогда, когда s0 это суффикс s, правда?
[02:31:21.380 --> 02:31:26.380]  Это происходит, но тогда у нас с0 это и суффикс sc, и суффикс s.
[02:31:26.380 --> 02:31:32.380]  Значит, получается, что s0 просто состоит из строк sc и всё.
[02:31:32.380 --> 02:31:37.380]  Это я понял.
[02:31:37.380 --> 02:31:53.380]  Но я утверждаю, что это произойдёт тогда и только тогда, когда вершина q тоже лежит на этом суффиксном пути где-то выше.
[02:31:54.380 --> 02:32:08.380]  Ну вот, раз мы верим даже в тогда и только тогда, тогда получается, что либо тогда sq был создан, этот переход, и он будет скопирован, либо он не создан, и тогда его и здесь создавать не надо.
[02:32:08.380 --> 02:32:16.380]  Всё. Вот такая магия.
[02:32:16.380 --> 02:32:25.380]  В результате это превращает last, то есть даёт нам весьма простой ход.
[02:32:25.380 --> 02:32:29.380]  Вот мы заводим строку s.
[02:32:29.380 --> 02:32:38.380]  То есть что мы храним? Мы храним string s и ещё вот эту вершину last.
[02:32:38.380 --> 02:32:49.380]  Ну last это мы будем хранить, ну вот типа классы квалентности строки s, ну последнюю вершину, stop.
[02:32:49.380 --> 02:32:59.380]  В результате, ну там понятно, инициализация будет привиальная.
[02:32:59.380 --> 02:33:09.380]  Ну во-первых, мы создадим, понятно, одну вершину.
[02:33:09.380 --> 02:33:14.380]  И в этой вершине будет, понятно, пустой мапчик.
[02:33:14.380 --> 02:33:16.380]  Тут можно так писать?
[02:33:21.380 --> 02:33:24.380]  Тут вроде можно, а то мне предради, что тут ноди писать обязательно.
[02:33:34.380 --> 02:33:36.380]  Ну мало ли, не скомпилиться.
[02:33:37.380 --> 02:33:43.380]  Нет, понятно, что вы, наверное, в состоянии, видите, ну вот, нулевую стартовую вершину будет, естественно, ноль.
[02:33:43.380 --> 02:33:46.380]  Суфиксная ссылка будет равна минус один.
[02:33:46.380 --> 02:33:50.380]  Так, ну, и это безобразие мы в полсу.
[02:33:55.380 --> 02:34:04.380]  Вот, нодис понятно, s понятно, s равно it, it, ну и last равно нулю.
[02:34:06.380 --> 02:34:12.380]  Вот, пока все просто.
[02:34:12.380 --> 02:34:20.380]  Ну, знаете, я подозреваю, что если я пишу код, а вы можете с ремаксом смиряться, не получится ли то же самое.
[02:34:20.380 --> 02:34:26.380]  Потому что, в отличие от, видимо, суфиксного массива, тут, видимо, сложно написать код как-то не так.
[02:34:26.380 --> 02:34:30.380]  Итак, добавляем новый символ, господа.
[02:34:30.380 --> 02:34:32.380]  Добавляем новый символ.
[02:34:32.380 --> 02:34:36.380]  Ну, давайте его малиновыми называть.
[02:34:36.380 --> 02:34:38.380]  Чак Ч.
[02:34:38.380 --> 02:34:40.380]  Чак С.
[02:34:44.380 --> 02:34:46.380]  Что мы там будем делать?
[02:34:46.380 --> 02:34:48.380]  Ну, во-первых.
[02:34:50.380 --> 02:34:54.380]  Ну, во-первых, давайте создадим вершину mlast.
[02:34:54.380 --> 02:34:57.380]  Вот, мы будем называть эту вершину mlast.
[02:34:57.380 --> 02:35:07.380]  Вот, и так и напишем int nlast равно, ну, очевидно чему, nodis.size.
[02:35:09.380 --> 02:35:11.380]  Вот.
[02:35:11.380 --> 02:35:13.380]  И так, создаем.
[02:35:13.380 --> 02:35:19.380]  Значит, в nodis соответственно делаем pushback.
[02:35:19.380 --> 02:35:23.380]  Нет, не так делаем pushback.
[02:35:23.380 --> 02:35:29.380]  Ну, сейчас, малиновых делаем pushback.
[02:35:29.380 --> 02:35:35.380]  Ну, если не получается, то мы будем делать pushback.
[02:35:35.380 --> 02:35:39.380]  Ну сейчас мариновую сделаем.
[02:35:46.380 --> 02:35:49.380]  Нет, здесь мы не настолько, давайте уж честно.
[02:35:50.380 --> 02:35:52.380]  Я олдскульщик, я так вижу.
[02:35:53.380 --> 02:35:55.380]  Так, ну поехали. Переходов не будет.
[02:35:56.380 --> 02:35:58.380]  Лен равно чему?
[02:35:59.380 --> 02:36:01.380]  Ну, в генестрии я все-таки не еду.
[02:36:02.380 --> 02:36:03.380]  Ага.
[02:36:04.380 --> 02:36:07.380]  Так, ой, а знаете что, давайте-ка я тут где-нибудь припишу.
[02:36:08.380 --> 02:36:11.380]  Сразу, для удобства. S.pushback от C.
[02:36:17.380 --> 02:36:21.380]  А еще можно сказать, что это Лен от Last писал?
[02:36:22.380 --> 02:36:23.380]  Ну давайте.
[02:36:24.380 --> 02:36:27.380]  Я тут. Легче уже S.lens написать.
[02:36:28.380 --> 02:36:35.380]  Так, сувиксная ссылка я пока не знаю куда, поэтому пишу минус один.
[02:36:36.380 --> 02:36:39.380]  Ну и это безобразие тоже.
[02:36:43.380 --> 02:36:45.380]  Вот я создал новую вершинку.
[02:36:52.380 --> 02:36:54.380]  Это я создал вот mlast.
[02:36:58.380 --> 02:36:59.380]  Это вот правая верхняя?
[02:36:59.380 --> 02:37:00.380]  Это что?
[02:37:00.380 --> 02:37:01.380]  Это правая верхняя?
[02:37:01.380 --> 02:37:06.380]  Да, это вот я создал вот эту вершину.
[02:37:09.380 --> 02:37:11.380]  Теперь я сделаю следующее.
[02:37:12.380 --> 02:37:17.380]  int p равно last.
[02:37:18.380 --> 02:37:19.380]  Ну ладно сейчас.
[02:37:19.380 --> 02:37:29.380]  While, вот я аккуратно говорю, не can go из вершины P по символу C.
[02:37:32.380 --> 02:37:34.380]  Ну давайте я через while это напишу.
[02:37:35.380 --> 02:37:38.380]  Там часто через folie, там где Max может через folie пишет.
[02:37:40.380 --> 02:37:41.380]  Я вот так напишу.
[02:37:42.380 --> 02:37:43.380]  Ну дальше что я делаю?
[02:37:43.380 --> 02:37:45.380]  Я создаю переход по символу C.
[02:37:46.380 --> 02:37:48.380]  Там пишем что-то.
[02:37:49.380 --> 02:37:57.380]  nodis от P.go от C равно mlast.
[02:38:04.380 --> 02:38:06.380]  Ну и здесь конечно P равно.
[02:38:11.380 --> 02:38:15.380]  Ну допустим nodis от P.su.
[02:38:19.380 --> 02:38:43.380]  Ну правда сразу обнаружим, что сразу в этом while мы даже заподозрили, что уже что-то не ладно.
[02:38:43.380 --> 02:38:51.380]  Потому что могла возникнуть такая ситуация, когда мы просто вылетим в трубу, правда?
[02:38:52.380 --> 02:39:01.380]  Поэтому надо по-хорошему писать while P больше либо равно нуля, and end не can go.
[02:39:02.380 --> 02:39:10.380]  Ну можно было конечно в can go еще прописать, что нельзя ходить по символу C из вершины P, которая не существует.
[02:39:11.380 --> 02:39:14.380]  Но это сложновато мне кажется.
[02:39:15.380 --> 02:39:18.380]  Лучше уж тогда так, написать подозрение can go в валидную вершину.
[02:39:19.380 --> 02:39:23.380]  Я технический работник, мне дали вершину, я проверил. Если мне дали хрен знает что, я взлыл.
[02:39:24.380 --> 02:39:25.380]  Это безопаснее.
[02:39:27.380 --> 02:39:36.380]  На самом деле если ваши сотрудники воют от того, что вы дали не совсем корректную работу, то это на самом деле более безопасно, чем когда они умеют за вас что-то думать.
[02:39:37.380 --> 02:39:43.380]  Потому что чем больше ваши сотрудники додумывают за вас независимо от вас, тем больше вероятность, что они сделают то, что вы не ожидаете.
[02:39:44.380 --> 02:39:46.380]  Это называется miscommunication.
[02:39:48.380 --> 02:39:50.380]  На жаргонном языке орков.
[02:39:54.380 --> 02:39:56.380]  Так что лучше вот как бы.
[02:40:01.380 --> 02:40:03.380]  Чего там лицо плюсов?
[02:40:04.380 --> 02:40:05.380]  Принцип плюсов.
[02:40:06.380 --> 02:40:08.380]  Принцип программирования в целом на самом деле.
[02:40:09.380 --> 02:40:17.380]  То есть как бы хотите надежного программирования, то есть надо писать так, чтобы каждая функция была максимально понятна, что она делает желательно из названий без неожиданных специфик.
[02:40:18.380 --> 02:40:24.380]  Это как хороший программист посмотрит на лево, посмотрит на право при переходе дороги, настроен без сна.
[02:40:26.380 --> 02:40:27.380]  Не, не, не.
[02:40:28.380 --> 02:40:34.380]  Ну как сказать, хороший программист настроит так, чтобы действительно все, кому надо переходить дорогу, смотрели только на право.
[02:40:35.380 --> 02:40:36.380]  Хотя...
[02:40:37.380 --> 02:40:39.380]  Ну то есть это называется скорее перестраховка, так?
[02:40:40.380 --> 02:40:44.380]  Нет, нет, это у меня ассоциация, это у меня другое немножко вызывает ассоциацию про таблицы.
[02:40:45.380 --> 02:40:48.380]  Вот вы не столкнулись, так, вы еще не столкнулись с Нишкой 99 советов для программистов?
[02:40:51.380 --> 02:40:55.380]  Нет? Все еще не столкнулись? Я просто должен был уже цитировать вам, наверное, как-то за полгода работы.
[02:40:56.380 --> 02:41:00.380]  Просто там один из советов говорят так, что там сейчас, как там было устроено.
[02:41:00.380 --> 02:41:09.380]  Сейчас не скажу, как известно, но многие считают, что компиляция программы, там действительно что-то там устроено так,
[02:41:10.380 --> 02:41:17.380]  что значит там это, что там что-то, значит программа, значит, считывается, переводится, там все файлы переводятся в объектные,
[02:41:18.380 --> 02:41:21.380]  дальше происходит какая-то магия, и там создается ХЗ.
[02:41:22.380 --> 02:41:23.380]  Магия это линковка.
[02:41:24.380 --> 02:41:29.380]  Потому что там все, потому что названием начинаются соответствовать какие-то реализации в других местах.
[02:41:30.380 --> 02:41:32.380]  Ну вот, и все считают, что линковка какая-то магия, не надо в ней играть.
[02:41:33.380 --> 02:41:34.380]  Так вот, ребята, это не так.
[02:41:35.380 --> 02:41:39.380]  Linker это предельно тупая программа, которая вот смотрит на звание, смотрит какие функции есть,
[02:41:40.380 --> 02:41:43.380]  устанавливает между этими списками, заносит их в свою таблицу, все.
[02:41:44.380 --> 02:41:46.380]  Так что не надо, ну там вот какой-то такой совет был.
[02:41:47.380 --> 02:41:50.380]  Вот. Что, Мишель нам тоже это не цитировал?
[02:41:51.380 --> 02:41:52.380]  Какое безобрение.
[02:41:53.380 --> 02:41:55.380]  Ну ладно.
[02:41:55.380 --> 02:41:56.380]  Ну вот.
[02:42:01.380 --> 02:42:03.380]  Ну вот, то есть какая-то вот такая ассоциация возникла.
[02:42:04.380 --> 02:42:05.380]  Так вот.
[02:42:06.380 --> 02:42:08.380]  Поэтому давайте теперь аккуратненько проверим этот случай.
[02:42:09.380 --> 02:42:12.380]  Если выяснилось, что мы, вот сразу случай номер ноль,
[02:42:13.380 --> 02:42:19.380]  если П вылетел куда подальше, то мы делаем очень простую вещь.
[02:42:20.380 --> 02:42:24.380]  Простая вещь заключается в том, что тогда мы вообще ничего не создаем,
[02:42:25.380 --> 02:42:30.380]  все что нам остается это сказать, то есть ну как бы все нужные переходы уже создали получается,
[02:42:31.380 --> 02:42:32.380]  и да, это сказать только одно.
[02:42:33.380 --> 02:42:35.380]  А куда введет суффиксная ссылка из эссе?
[02:42:43.380 --> 02:42:48.380]  То есть нодис от вот этого nlast.sub.
[02:42:50.380 --> 02:42:51.380]  Куда она должна вести?
[02:42:54.380 --> 02:42:55.380]  Ноль.
[02:42:56.380 --> 02:42:57.380]  Ну да.
[02:42:58.380 --> 02:42:59.380]  Где у нас корень?
[02:43:00.380 --> 02:43:01.380]  В нуле, очевидно.
[02:43:02.380 --> 02:43:03.380]  Ну а где?
[02:43:04.380 --> 02:43:05.380]  Согласно ниту.
[02:43:06.380 --> 02:43:10.380]  Ну да. Ну и теперь пишем last равно nlast.
[02:43:11.380 --> 02:43:14.380]  Вот в этом месте nlast становится нормальной синей вершиной.
[02:43:15.380 --> 02:43:16.380]  И мы выбрасываемся.
[02:43:20.380 --> 02:43:21.380]  Вот.
[02:43:24.380 --> 02:43:25.380]  Ну теперь поеду.
[02:43:26.380 --> 02:43:31.380]  Ну а теперь, пожалуй, я даже кое-куда перейду.
[02:43:39.380 --> 02:43:43.380]  Так, давайте я вот сюда кое-куда перейду и буду писать.
[02:43:44.380 --> 02:43:46.380]  Да, то есть типа n продолжается.
[02:43:47.380 --> 02:43:48.380]  И только n.
[02:43:49.380 --> 02:43:50.380]  Так и так.
[02:43:52.380 --> 02:43:56.380]  Ну а теперь пишем int q равно.
[02:43:57.380 --> 02:43:58.380]  Чему равно?
[02:44:00.380 --> 02:44:02.380]  Ну, ну я-то честно пишу.
[02:44:13.380 --> 02:44:14.380]  Вот.
[02:44:16.380 --> 02:44:17.380]  Ну вот, значит, смотрите.
[02:44:17.380 --> 02:44:19.380]  Ну и теперь соответственно у нас как всегда два вопроса.
[02:44:20.380 --> 02:44:22.380]  В первый случай давайте простой способ.
[02:44:23.380 --> 02:44:36.380]  Если оказалось, что nodis от p.len плюс 1 равно равно nodis от q.len.
[02:44:37.380 --> 02:44:38.380]  Что мы тогда делаем?
[02:44:48.380 --> 02:44:53.380]  Нужно заликовать из s, c в q.
[02:44:57.380 --> 02:44:58.380]  Ну да.
[02:44:59.380 --> 02:45:04.380]  То есть опять пишем nodis от last.suf равно.
[02:45:05.380 --> 02:45:06.380]  Чему он там равно?
[02:45:07.380 --> 02:45:08.380]  Ну да.
[02:45:08.380 --> 02:45:09.380]  Ну да.
[02:45:10.380 --> 02:45:14.380]  Suf равно на этот раз q.
[02:45:15.380 --> 02:45:17.380]  Ну откровенно говоря q.
[02:45:18.380 --> 02:45:21.380]  Ну а дальше как всегда last равно last не забыть.
[02:45:22.380 --> 02:45:24.380]  И выпустится.
[02:45:32.380 --> 02:45:33.380]  Ну это тогда потом придется.
[02:45:33.380 --> 02:45:34.380]  Ну смотрите.
[02:45:35.380 --> 02:45:37.380]  Нет, знаете, правильнее делать так, вот почему.
[02:45:38.380 --> 02:45:41.380]  Потому что, ну, совсем идеально с точки зрения промышленного программирования, да.
[02:45:42.380 --> 02:45:47.380]  Если это все происходит, если вот это все хранится в классе, а это все в привате.
[02:45:49.380 --> 02:45:50.380]  Это все в классе.
[02:45:51.380 --> 02:45:53.380]  Ну я не знаю, я сейчас немножко по алипиадам напишу.
[02:45:54.380 --> 02:45:55.380]  А мы алипиады все...
[02:45:56.380 --> 02:45:57.380]  Ну да.
[02:45:58.380 --> 02:45:59.380]  Отлично.
[02:46:00.380 --> 02:46:01.380]  Ну вот.
[02:46:01.380 --> 02:46:02.380]  Отлично.
[02:46:03.380 --> 02:46:06.380]  Ну тогда внутри этой структуры, тогда вот этот last находится внутри этой структуры.
[02:46:07.380 --> 02:46:08.380]  Вообще по-хорошему, а метод add внешний.
[02:46:09.380 --> 02:46:10.380]  То есть в принципе, да.
[02:46:11.380 --> 02:46:15.380]  То есть как бы пользователь вообще не должен знать, что у вас там какой-то last есть.
[02:46:16.380 --> 02:46:18.380]  То есть это как бы его личное дело.
[02:46:19.380 --> 02:46:21.380]  То есть вы ему там предоставляете какой-то интерфейс ходьбы по автомату.
[02:46:22.380 --> 02:46:26.380]  Если вы очень жадный, то вы даже не сообщаете существование вот этих полей в принципе.
[02:46:27.380 --> 02:46:28.380]  Потому что он сказал автомат.
[02:46:28.380 --> 02:46:29.380]  Определение.
[02:46:30.380 --> 02:46:32.380]  Словарное определение слова детермирует на конечный автомат.
[02:46:33.380 --> 02:46:34.380]  Он никаких суффикс персылать не подразумевает.
[02:46:35.380 --> 02:46:37.380]  Так, а то, что я их там храню, это мое личное дело.
[02:46:38.380 --> 02:46:39.380]  Вот.
[02:46:40.380 --> 02:46:41.380]  Ну можете так заявить на алипиадах?
[02:46:42.380 --> 02:46:43.380]  Вы вряд ли себе такое заявлять будете, конечно.
[02:46:44.380 --> 02:46:45.380]  Ну ладно.
[02:46:46.380 --> 02:46:47.380]  В алипиадах вы, конечно, это мое имя.
[02:46:48.380 --> 02:46:49.380]  За словом приват ругаться не будете, я подозреваю.
[02:46:50.380 --> 02:46:51.380]  Или будете?
[02:46:52.380 --> 02:46:53.380]  Все будете?
[02:46:54.380 --> 02:46:55.380]  Ну хотя бы по ситуации.
[02:46:55.380 --> 02:46:59.380]  На самом деле, если писать какой-нибудь большой код, то он может лучше приватом и поругаться.
[02:47:00.380 --> 02:47:01.380]  Себе же как бы безопасность будет.
[02:47:02.380 --> 02:47:06.380]  Или, по крайней мере, каждый раз, когда вы вместо что-то выносите в паблик, вы хоть себе там это подробно расписываете.
[02:47:07.380 --> 02:47:08.380]  Почему вы так делаете?
[02:47:09.380 --> 02:47:12.380]  Вообще, конечно, на алипиадах обычно этим, конечно, пренебрегают для скорости.
[02:47:13.380 --> 02:47:18.380]  Вот это один из тех моментов, когда и понятно, где надо просто загнать в тестер-лапшу и забыть о ней навсегда.
[02:47:19.380 --> 02:47:20.380]  Или там надо написать код, который будет.
[02:47:21.380 --> 02:47:23.380]  Вот который будут читать там через много-много лет.
[02:47:23.380 --> 02:47:25.380]  В том числе и вы, как всегда.
[02:47:26.380 --> 02:47:27.380]  Так, ладно.
[02:47:28.380 --> 02:47:31.380]  Значит, теперь самое интересное начинается.
[02:47:32.380 --> 02:47:34.380]  Нам пришло время создать клона.
[02:47:36.380 --> 02:47:39.380]  И получается маленькая приятная вещь.
[02:47:41.380 --> 02:47:42.380]  Итак, поехали.
[02:47:43.380 --> 02:47:48.380]  int клон равно, ну естественно, ну понятно, чему.
[02:47:49.380 --> 02:47:51.380]  Вот именно поэтому вам могло показаться.
[02:47:51.380 --> 02:47:56.380]  А почему нельзя сказать, что там каждый nlast равно там last плюс один или что-нибудь еще в этом роде.
[02:47:57.380 --> 02:47:58.380]  А вот ровно из-за этого.
[02:48:07.380 --> 02:48:09.380]  И теперь мы, а сейчас мы четыре.
[02:48:10.380 --> 02:48:18.380]  В полном соответствии с названием мы заявим nodis.pushback nodis.com.
[02:48:21.380 --> 02:48:37.380]  Вот такой вот из себя красота.
[02:48:38.380 --> 02:48:43.380]  Так, ну правда мы его скопировали, но скопировали мы от этого только переходы.
[02:48:44.380 --> 02:48:48.380]  Могли скопировать, могли сразу pushback-нуть правильно.
[02:48:49.380 --> 02:48:50.380]  Ну типа.
[02:48:51.380 --> 02:48:54.380]  Нет, ну мы не, ну нет, сначала мы ее pushback'ем, а потом будем уже у нее менять.
[02:48:55.380 --> 02:48:56.380]  Ну можно сразу.
[02:48:57.380 --> 02:48:59.380]  Нет, сразу нельзя, потому что nodis.cold поменяться не должна.
[02:49:00.380 --> 02:49:01.380]  В смысле?
[02:49:02.380 --> 02:49:04.380]  Ну nodis.cold должна обойтись в меня, не поменяйте, только в суффиксной ссылке.
[02:49:05.380 --> 02:49:09.380]  Нет, в смысле мы можем в nodis.cold сразу pushback'ать правильный нод.
[02:49:09.380 --> 02:49:15.380]  Не копировать nodis.cold, копировать только go, а остальные их оставлять сразу.
[02:49:16.380 --> 02:49:19.380]  А, ну допустим конечно.
[02:49:20.380 --> 02:49:22.380]  Ну просто в этом случае что получится?
[02:49:23.380 --> 02:49:26.380]  Ну вот если так по чесноку делать, то ну поехали, что тут будет.
[02:49:27.380 --> 02:49:29.380]  nodis.cold.go.
[02:49:30.380 --> 02:49:31.380]  Да?
[02:49:32.380 --> 02:49:33.380]  nodis.cold.go.
[02:49:34.380 --> 02:49:36.380]  Так, ну хорошо, да, Лен допустим надо.
[02:49:36.380 --> 02:49:46.380]  nodis.cold.p.ln.plus1 и что-то еще.
[02:49:47.380 --> 02:49:49.380]  Вот, p давайте так оставим.
[02:49:50.380 --> 02:49:55.380]  И что Лену вот, так, что там дальше, суффиксную ссылку у нас мы откуда берем?
[02:49:57.380 --> 02:50:01.380]  nodis.cold.sul. Прям честно копируем.
[02:50:07.380 --> 02:50:09.380]  А, ну и конечно форс потом в конце.
[02:50:14.380 --> 02:50:15.380]  Так, ой.
[02:50:16.380 --> 02:50:18.380]  А, а еще тут должны быть фигурные столбки, да?
[02:50:19.380 --> 02:50:21.380]  А еще тут надо emplaceback писать, да, да, да.
[02:50:22.380 --> 02:50:24.380]  Если писать emplaceback, то не будет сколько не нужно как раз, вот было правильно.
[02:50:25.380 --> 02:50:26.380]  А, черт.
[02:50:27.380 --> 02:50:29.380]  Вот называется, я не привык писать emplaceback, да.
[02:50:31.380 --> 02:50:35.380]  А один раз я загнался дальше просто поменяв pushback на emplaceback и ничего больше.
[02:50:37.380 --> 02:50:38.380]  Несет.
[02:50:39.380 --> 02:50:41.380]  Ну хорошо, ладно, пусть так будет.
[02:50:43.380 --> 02:50:44.380]  Ну вот.
[02:50:45.380 --> 02:50:46.380]  Ну не знаю, вот у меня поэтому и было.
[02:50:47.380 --> 02:50:54.380]  Можно так написать, а можно написать emplaceback, pushback nodis.cold, а потом написать nodis.cold.ln, но вот это.
[02:50:55.380 --> 02:50:57.380]  По-моему у символов было бы меньше.
[02:50:58.380 --> 02:50:59.380]  Зато одна строчка.
[02:51:01.380 --> 02:51:02.380]  Ну да, для желающих одну строчку.
[02:51:03.380 --> 02:51:04.380]  Ну напиши эту вторую строчку сюда.
[02:51:04.380 --> 02:51:05.380]  Да.
[02:51:06.380 --> 02:51:07.380]  Ах да, это плохо, да.
[02:51:08.380 --> 02:51:09.380]  Так, ну хорошо.
[02:51:10.380 --> 02:51:13.380]  Давайте вкуп меняем suf на нашу плану.
[02:51:14.380 --> 02:51:16.380]  О, так, вот теперь, так, погодите, погодите.
[02:51:17.380 --> 02:51:18.380]  Сейчас все будет.
[02:51:19.380 --> 02:51:20.380]  Так, значит теперь поехали.
[02:51:21.380 --> 02:51:25.380]  Значит, во-первых, давайте сразу поменяем suf к смыслу.
[02:51:26.380 --> 02:51:29.380]  Ну, кстати, что уж так, что уж только вкуп-то сразу.
[02:51:30.380 --> 02:51:38.380]  Nodis.cold.suf мы поменяем не только там, а еще и можно сразу в emlast отправиться.
[02:51:43.380 --> 02:51:45.380]  И он везде будет равен этому клону.
[02:51:48.380 --> 02:51:54.380]  Тут мы напишем klona, тут мы напишем emlast, тут мы напишем suf.
[02:52:00.380 --> 02:52:02.380]  А теперь самое интересное.
[02:52:03.380 --> 02:52:04.380]  Хорошо, суфки-суфки перенаправили.
[02:52:05.380 --> 02:52:06.380]  Теперь самое интересное.
[02:52:07.380 --> 02:52:09.380]  Вот это перенаправление.
[02:52:12.380 --> 02:52:13.380]  Ну да.
[02:52:14.380 --> 02:52:15.380]  Значит, как все, и пишем опять.
[02:52:16.380 --> 02:52:19.380]  While аккуратно, пожалуйста, p больше либо равно нуля.
[02:52:20.380 --> 02:52:31.380]  endend nodis.go.c, ну там go.c всегда существует, поэтому можно не проверять.
[02:52:32.380 --> 02:52:33.380]  Почему всегда существует?
[02:52:34.380 --> 02:52:41.380]  Ну, если из какой-то класса эквалент есть переход по символу c, то по всем меньшим его сувексом точным переход это символу c есть.
[02:52:42.380 --> 02:52:45.380]  А из p он есть, потому что он у нас по определению p.
[02:52:46.380 --> 02:53:04.380]  И так вот, пока он есть и равен q, ну он всегда есть, но пока он равен q, то мы заявляем, что он теперь, что это вот go от этого равно теперь клону.
[02:53:05.380 --> 02:53:11.380]  Ну и в конце напишу, да, ну давайте тут молимо напишу, go.c равно теперь клон.
[02:53:11.380 --> 02:53:12.380]  Ну вот.
[02:53:13.380 --> 02:53:15.380]  И вот это вот пластическая фруктика.
[02:53:16.380 --> 02:53:18.380]  p равно nodis.p.
[02:53:27.380 --> 02:53:28.380]  Красота.
[02:53:29.380 --> 02:53:30.380]  Благодарь.
[02:53:34.380 --> 02:53:35.380]  Ну, на этом вроде как все.
[02:53:42.380 --> 02:53:44.380]  Last равно last.
[02:53:45.380 --> 02:53:46.380]  Ой-ой-ой.
[02:53:49.380 --> 02:53:51.380]  И можно еще и retour написать.
[02:53:57.380 --> 02:53:58.380]  Ну теперь уж точно.
[02:53:59.380 --> 02:54:03.380]  Вот. Чем приятен сувексовый автомат, что это все.
[02:54:04.380 --> 02:54:08.380]  Ладно, то есть все, что вам теперь осталось тут дописать, это функцию can go.
[02:54:09.380 --> 02:54:15.380]  Ну понятно, тут просто удвините строчку и написайте это nodis.p.count.c, да?
[02:54:17.380 --> 02:54:19.380]  Ну вы же так проверяете, если переход, правда?
[02:54:20.380 --> 02:54:22.380]  Нет, есть более быстрый способ, формально.
[02:54:23.380 --> 02:54:24.380]  Какой?
[02:54:25.380 --> 02:54:28.380]  nodis.v.go.find.c не равно nodis.v.go.end.
[02:54:29.380 --> 02:54:30.380]  Это быстрее, чем count.
[02:54:31.380 --> 02:54:32.380]  Count вызывает эту штуку, вроде бы.
[02:54:33.380 --> 02:54:34.380]  Да?
[02:54:35.380 --> 02:54:37.380]  Особенно это у вас, например, в мультимапе, ну понятно.
[02:54:38.380 --> 02:54:40.380]  А, ну в общем так лучше после этого.
[02:54:41.380 --> 02:54:42.380]  Ну хорошо, пожалуйста.
[02:54:43.380 --> 02:54:45.380]  Ладно, ну ладно, поверим.
[02:54:46.380 --> 02:54:48.380]  Но не так принципально, конечно.
[02:54:49.380 --> 02:55:05.380]  Если nodis.p.go.find.c не равно nodis.p.go.end.
[02:55:09.380 --> 02:55:11.380]  find.c, естественно.
[02:55:12.380 --> 02:55:15.380]  О, теперь прям вообще все написали.
[02:55:16.380 --> 02:55:19.380]  Ну ладно, там include и using place, то есть со стд вы как-нибудь напишите.
[02:55:20.380 --> 02:55:22.380]  Или даже это using case, стд vector, стд map, там вот это все.
[02:55:24.380 --> 02:55:27.380]  Так, что осталось?
[02:55:30.380 --> 02:55:32.380]  Ну, функцию проверки.
[02:55:33.380 --> 02:55:34.380]  Какая функция проверки?
[02:55:35.380 --> 02:55:37.380]  Ну, у нас мы построили софтомат, который метод основается.
[02:55:38.380 --> 02:55:39.380]  А?
[02:55:40.380 --> 02:55:41.380]  Какая функция?
[02:55:42.380 --> 02:55:44.380]  Не, ну функция проверки элементарно уж как-нибудь пишется.
[02:55:45.380 --> 02:55:51.380]  Нет, по этой логике у нас еще осталось, это, как бы, потом поласту, это построить еще терминальные вершины.
[02:55:52.380 --> 02:55:53.380]  А, да.
[02:55:54.380 --> 02:55:56.380]  Но всякие эти подобные мелочи, как бы, это уже зависит от решения.
[02:55:57.380 --> 02:56:02.380]  Я говорю, по моему ощущению почти никогда, например, строить терминальные вершины в явном виде никому не надо.
[02:56:03.380 --> 02:56:09.380]  Просто потому что половина вещей, которые вам на самом деле надо, они на самом деле иногда из этого вот лена и выкровыкиваются.
[02:56:12.380 --> 02:56:16.380]  Вот знаете, сразу первая базовая задача на суфекстофтомат такая.
[02:56:17.380 --> 02:56:21.380]  Ну, практически там вам какую-то мистику описывают, какую-то черную магию, а по сути она говорит так.
[02:56:22.380 --> 02:56:28.380]  Найдите, пожалуйста, размеры всех классов эквивалентности, отсортируйте их по возрастанию, вы видите последователь кисел.
[02:56:29.380 --> 02:56:35.380]  Вот, кстати, внимание, вопрос. Как найти числа, которые являются размерами классов эквивалентности?
[02:56:36.380 --> 02:56:38.380]  Классов эквалентности суфекса?
[02:56:39.380 --> 02:56:42.380]  Классов эквалентности, нет, пси вообще под строк.
[02:56:43.380 --> 02:56:44.380]  А лены?
[02:56:45.380 --> 02:56:48.380]  Может быть, если нет, то там пси, которые меньше него, то...
[02:56:49.380 --> 02:56:50.380]  Нет, не до конца.
[02:56:51.380 --> 02:56:52.380]  Не до конца.
[02:56:53.380 --> 02:56:54.380]  А там, против, про пушить начало?
[02:56:55.380 --> 02:56:56.380]  Нет.
[02:56:57.380 --> 02:56:58.380]  Ой, пушить.
[02:56:59.380 --> 02:57:01.380]  Нет, первое тупое решение простое.
[02:57:02.380 --> 02:57:05.380]  Напишем динамику, для каждой вершины посчитаем, с какими способами в нее можно прийти.
[02:57:06.380 --> 02:57:07.380]  Все.
[02:57:08.380 --> 02:57:09.380]  Можно задачи наполнить?
[02:57:10.380 --> 02:57:11.380]  Ну, задача.
[02:57:12.380 --> 02:57:13.380]  Ну, давайте так.
[02:57:14.380 --> 02:57:18.380]  Две строки называются эквалентными, если у них совпадают правые контексты.
[02:57:19.380 --> 02:57:21.380]  Ну, там написано по-другому, но суть такая.
[02:57:21.380 --> 02:57:26.380]  Пожалуйста, найдите, у каждого из классов эквалентности, найдите их размеры.
[02:57:27.380 --> 02:57:30.380]  И все эти размеры отсортируйте и напечатайте на экран.
[02:57:31.380 --> 02:57:32.380]  Ясно.
[02:57:34.380 --> 02:57:37.380]  Ну, мы уже знаем для каждой же вершинки самую длинную?
[02:57:38.380 --> 02:57:39.380]  Да, длину самую длинную, да.
[02:57:40.380 --> 02:57:43.380]  А, надо же, можно еще найти длину самую короткой, наверное.
[02:57:44.380 --> 02:57:47.380]  Ну да, можно найти длину самого длинного суфекса, который в ней не лежит.
[02:57:48.380 --> 02:57:49.380]  Да, и, собственно, по сути...
[02:57:49.380 --> 02:57:50.380]  Да, по сути...
[02:57:51.380 --> 02:57:57.380]  Поэтому размер класса эквалентности это, как бы, лен от v минус лен от супа v.
[02:57:58.380 --> 02:57:59.380]  Да.
[02:58:00.380 --> 02:58:01.380]  Вот.
[02:58:02.380 --> 02:58:06.380]  Если вы напишете какую-нибудь динамику, то есть, если вы напишете еще динамику,
[02:58:07.380 --> 02:58:10.380]  где для каждой вершины найдете, скажем, самый короткий путь до стока,
[02:58:11.380 --> 02:58:12.380]  или самый длинный путь до стока,
[02:58:13.380 --> 02:58:18.380]  то, возможно, вы для этих вершин еще и можете сами эти вершины, сами эти ломбисы находить.
[02:58:19.380 --> 02:58:20.380]  Да.
[02:58:21.380 --> 02:58:22.380]  Ну, как подстроить.
[02:58:23.380 --> 02:58:24.380]  Вот.
[02:58:25.380 --> 02:58:27.380]  То есть там всякое такое можно делать, там разные вещи можно делать.
[02:58:28.380 --> 02:58:29.380]  Вот.
[02:58:30.380 --> 02:58:35.380]  Так что, ну, это, то есть, это все уже техника, это уже зависит от того, там, что надо делать.
[02:58:36.380 --> 02:58:41.380]  Так что самое интересное сейчас вообще такое, за какую симптомику это вообще работает?
[02:58:42.380 --> 02:58:44.380]  Надо бы сказать, что за линию.
[02:58:45.380 --> 02:58:47.380]  За линию на алгоритм от развернутой.
[02:58:47.380 --> 02:58:48.380]  На алгоритм от развернутой.
[02:58:49.380 --> 02:58:50.380]  Ну, понятно.
[02:58:51.380 --> 02:58:52.380]  А с нас только доказать почему это работает за линию.
[02:58:53.380 --> 02:58:54.380]  Да.
[02:58:55.380 --> 02:58:56.380]  Ну да.
[02:58:57.380 --> 02:58:58.380]  Скажите, сколько это работает?
[02:59:00.380 --> 02:59:03.380]  Давайте посмотрим, что у нас вообще может не быстро работать.
[02:59:04.380 --> 02:59:05.380]  Угу.
[02:59:06.380 --> 02:59:07.380]  Ну, уходить по этим.
[02:59:08.380 --> 02:59:09.380]  Ну, ухожение по существенным словам у нас вообще.
[02:59:10.380 --> 02:59:11.380]  Ну, это, это вот эти вот вайлы.
[02:59:12.380 --> 02:59:14.380]  Это единственное вообще шоу, у нас тут вообще как-то нелинейная работа.
[02:59:15.380 --> 02:59:16.380]  Да, у нас два причина.
[02:59:17.380 --> 02:59:18.380]  Давайте смотреть.
[02:59:19.380 --> 02:59:20.380]  Давайте их пометим.
[02:59:22.380 --> 02:59:23.380]  Мы их пометим.
[02:59:24.380 --> 02:59:29.380]  Так, вот это мы пометим коричневым, вот этот вайл мы пометим коричневым цветом.
[02:59:32.380 --> 02:59:35.380]  А вот этот вайл мы пометим голубым цветом.
[02:59:38.380 --> 02:59:39.380]  Значит, идея у меня такая.
[02:59:40.380 --> 02:59:44.380]  Я буду мысленно, вот мысленно, в явном виде я делать не буду, но теоретически я могу делать так.
[02:59:44.380 --> 02:59:51.380]  Я буду мысленно поддерживать, во-первых, суффиксную ссылку из ласта.
[02:59:52.380 --> 02:59:54.380]  Вот, кстати, обратите внимание, да, это ласт.
[03:00:01.380 --> 03:00:02.380]  Вот.
[03:00:03.380 --> 03:00:08.380]  А голубой указателем я буду на суффиксную ссылку от суффиксной ссылки.
[03:00:09.380 --> 03:00:10.380]  От ласта.
[03:00:11.380 --> 03:00:12.380]  Отлично.
[03:00:14.380 --> 03:00:15.380]  А теперь смотрите.
[03:00:16.380 --> 03:00:20.380]  Первый вайл занимается тем, что оба эти указателя двигаются до вершины П.
[03:00:22.380 --> 03:00:28.380]  Вот, двигаются, двигаются, двигаются, и вот, наконец, коричневый указатель указывает на П, голубой указатель, соответственно, сюда.
[03:00:32.380 --> 03:00:40.380]  После этого этот указатель такжестно переходит, ну там, в худшем случае, наклон, а в лучшем случае, наклон.
[03:00:41.380 --> 03:00:42.380]  Ну, давайте сейчас рассмотрим, в случае, когда наклон.
[03:00:42.380 --> 03:00:43.380]  Видите, да?
[03:00:44.380 --> 03:00:48.380]  А теперь как бы нам теперь найти суффиксную ссылку клона?
[03:00:49.380 --> 03:00:52.380]  Так вот, на самом деле более продвинутая версия алгоритма могла бы выглядеть так.
[03:00:53.380 --> 03:01:00.380]  Этот голубой указатель продолжает вот так вот скакать, скакать, скакать до тех пор, пока у него ребра указывают в К, да?
[03:01:01.380 --> 03:01:07.380]  Тогда он, значит, проходит сюда, а теперь заметим, что из этой вершины, ну если он там в аут не вылетел, да,
[03:01:08.380 --> 03:01:18.380]  то тогда мы обнаружим, что здесь переход по символу С есть, и он не просто есть, а на самом деле вот эта бывшая суффиксная ссылка,
[03:01:19.380 --> 03:01:23.380]  которой в этом случае нету, она вела ровно сюда.
[03:01:24.380 --> 03:01:25.380]  Понимаете, да?
[03:01:27.380 --> 03:01:34.380]  Поэтому голубой указатель сюда переходит, то есть, заметим, что оценить время работы можно как О от количества,
[03:01:34.380 --> 03:01:38.380]  суммарного количества скачков этих указателей, согласны?
[03:01:39.380 --> 03:01:43.380]  Ну там плюс еще какие-нибудь M10, которые вы там забывали, в общем, ну вот.
[03:01:44.380 --> 03:01:51.380]  Ну а теперь заметим, что каждый указатель скачет несколько раз, ноль или более раз скачет по суффиксным ссылкам,
[03:01:52.380 --> 03:01:54.380]  а потом, возможно, проходит по символу С.
[03:01:55.380 --> 03:02:00.380]  Тогда, если у этого указателя смотреть такую штуку, как лен, вершины, в которые он указывает, да,
[03:02:00.380 --> 03:02:07.380]  то каждый скачок этот лен уменьшает, а каждый переход по символу С, обратите внимание,
[03:02:08.380 --> 03:02:13.380]  он тут так устроен, что лен увеличивается ровно на 1, обратите внимание.
[03:02:14.380 --> 03:02:17.380]  Понимаете, да? Вот тут вот так четко устроено.
[03:02:18.380 --> 03:02:23.380]  То есть, конечно, неверно, то есть, как мы уже выяснили, не всегда верно, что если вы перейдете по ебру,
[03:02:24.380 --> 03:02:26.380]  то лен у вас увеличится именно на 1, он может увеличиться и на больше.
[03:02:26.380 --> 03:02:32.380]  Ну, потому что, видите, вот по этих вершинах, например, вот из этих вершин тут этот лен больше, чем вот этот лен плюс один, правда?
[03:02:33.380 --> 03:02:35.380]  Чем дальше, чем сильнее больше.
[03:02:36.380 --> 03:02:39.380]  Но конкретно здесь это не так, он увеличивается ровно на 1.
[03:02:40.380 --> 03:02:43.380]  Это потому, что мы прошли до последней такой, ну да.
[03:02:44.380 --> 03:02:49.380]  Ну либо, ладно, есть еще один случай, когда там оба эти указателя там вылетели и потом пришли в ноль.
[03:02:50.380 --> 03:02:52.380]  Но это тоже не очень интересно, понимаете, да?
[03:02:53.380 --> 03:02:57.380]  То есть там лишние вот единицы действия, когда вы вылетели за пределы нуля,
[03:02:58.380 --> 03:03:00.380]  быстро это поняли, вернулись в ноль, сказали stop.
[03:03:02.380 --> 03:03:06.380]  Но отсюда, в общем-то, думаю, линейность алгоритма становится очевидной.
[03:03:07.380 --> 03:03:11.380]  Другой способ доказательства может быть заключаться в том, что,
[03:03:12.380 --> 03:03:17.380]  то есть заключается в том, что давайте в качестве потенциала рассмотрим длину суфферского пути из ласта.
[03:03:17.380 --> 03:03:23.380]  Ну там заметим, что длина суфферского пути, то есть мы работаем за от вот этих вот вершин
[03:03:24.380 --> 03:03:27.380]  и заметим, что вместо этой части пути тут остается две вершины, да.
[03:03:28.380 --> 03:03:31.380]  А после этого заметим, что тут идет какой-то путь, тут идет какой-то путь,
[03:03:32.380 --> 03:03:35.380]  и тут количество вершин не более чем количество вершин, тут плюс один.
[03:03:36.380 --> 03:03:37.380]  Что можно сказать?
[03:03:38.380 --> 03:03:39.380]  По суфферским путям?
[03:03:40.380 --> 03:03:41.380]  Ну да, если это по суфферским путям дальше идти, да.
[03:03:42.380 --> 03:03:43.380]  Точно, да.
[03:03:43.380 --> 03:03:48.380]  Ну да, если это по суффиксным путям дальше идти, да.
[03:03:48.380 --> 03:03:55.380]  То есть поэтому вы как бы работали за O от L, и потенциал ваш стал уменьшился на L и увеличился на 2.
[03:03:55.380 --> 03:03:58.380]  Ладно, на 3 может быть.
[03:03:58.380 --> 03:04:03.380]  Ну тут не очевиден факт, почему для двух нет никаких вершин.
[03:04:03.380 --> 03:04:08.380]  А вот поэтому, видите, потому что, смотрите, вот у вас есть суффиксный путь, да?
[03:04:08.380 --> 03:04:12.380]  И вот вы из этих всех вершин пытаетесь пройти по символу C.
[03:04:12.380 --> 03:04:16.380]  И как бы эти вершины, как бы нексты, идущие подряд вершины, слопываются в одну.
[03:04:16.380 --> 03:04:19.380]  Худший случай, когда они прям вот так параллельно идут.
[03:04:19.380 --> 03:04:23.380]  И тогда эта длина плюс один, потому что там еще в конце все есть.
[03:04:23.380 --> 03:04:25.380]  Вот.
[03:04:25.380 --> 03:04:31.380]  Да, но тут уже как конкретно это доказывает, в общем выбирайте сами, тут вам как намекнет.
[03:04:31.380 --> 03:04:37.380]  Не знаю, я предпочитаю указатели, потому что этот метод у нас уже есть, давайте им пользоваться.
[03:04:37.380 --> 03:04:41.380]  Сейчас ты еще раз вноси, длина суффиксного пути из власт.
[03:04:45.380 --> 03:04:53.380]  Утверждение, длина суффиксного пути N last не более чем длина из суффиксного пути last.
[03:04:53.380 --> 03:04:58.380]  Минус вот это вот расстояние до этой вершины.
[03:04:58.380 --> 03:05:02.380]  Плюс 3.
[03:05:02.380 --> 03:05:06.380]  Ну до этой вершины, это в смысле, до куда мы там дошли.
[03:05:06.380 --> 03:05:09.380]  То есть до первой вершины, из которой есть переход по C.
[03:05:09.380 --> 03:05:10.380]  Нет.
[03:05:10.380 --> 03:05:12.380]  Нет-нет-нет-нет, смотрите, вот мы как ходим.
[03:05:12.380 --> 03:05:18.380]  Сначала мы идем пока нет перехода по символу C, а потом дальше идем пока есть переход в ту же самую вершину.
[03:05:18.380 --> 03:05:30.380]  То есть тогда, если вот количество этих вершин равно там Z, то тогда длина суффиксного пути N last это не более чем длина суффиксного пути от last.
[03:05:30.380 --> 03:05:33.380]  Минус Z, то есть минус вот это вот.
[03:05:33.380 --> 03:05:35.380]  Плюс 2.
[03:05:35.380 --> 03:05:38.380]  Вот ну за счет вот этих вершин.
[03:05:38.380 --> 03:05:40.380]  Ну самих N last и clone.
[03:05:40.380 --> 03:05:44.380]  И плюс может быть 1 вон там.
[03:05:44.380 --> 03:05:46.380]  То есть плюс 3, короче, в сумме получается.
[03:05:46.380 --> 03:05:48.380]  А 1, в смысле, если мы дошли до корня?
[03:05:48.380 --> 03:05:49.380]  Да.
[03:05:49.380 --> 03:05:56.380]  То есть если, если тут прям, когда мы тут шли до корня, то есть каждый, каждый вершины переход по символу C был прям в честную, в новую вершину.
[03:05:56.380 --> 03:06:05.380]  Тогда там как бы параллель, параллель, параллель, параллель, параллель, параллель, из эпсела на параллель сюда, и отсюда суффиксная суффигина в этот же эпсел.
[03:06:05.380 --> 03:06:07.380]  Вот.
[03:06:07.380 --> 03:06:09.380]  То есть можно было так доказывать.
[03:06:09.380 --> 03:06:17.380]  Ну вот с этими указателями, просто метод вот этих вот двух указателей, по-моему, у нас уже в дереве будем другую.
[03:06:17.380 --> 03:06:20.380]  Ну вот то есть вот видите.
[03:06:20.380 --> 03:06:22.380]  То есть как-то опять эта классика, да.
[03:06:22.380 --> 03:06:27.380]  То есть как бы фокус можно показывать с горящими, с горящими мечами или с топорами, там называется.
[03:06:27.380 --> 03:06:29.380]  Но технология фокуса одна и та же.
[03:06:31.380 --> 03:06:32.380]  Экшн лов.
