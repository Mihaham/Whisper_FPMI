[00:00.000 --> 00:06.160]  Сегодня хочу много успеть.
[00:06.160 --> 00:20.160]  Значит, во-первых, за мной долг про задачу штрих с
[00:20.160 --> 00:22.960]  прошлой лекции, когда мы хотели найти все вхождения
[00:22.960 --> 00:25.340]  всех словарных слов в текст, значит, давайте я кратко
[00:25.340 --> 00:26.340]  напомню.
[00:27.340 --> 00:32.340]  Есть n слов, есть текст t, надо найти все вхождения.
[00:32.340 --> 00:40.340]  Причем найти это значит не количество найти, а,
[00:40.340 --> 00:42.340]  грубо говоря, вот прям выписать весь список, что
[00:42.340 --> 00:45.340]  на какой-то позиции заканчивается вхождение там из первого,
[00:45.340 --> 00:47.340]  здесь закончилось вхождение со второго и так далее.
[00:47.340 --> 00:49.340]  Вот прям все вхождения выписать, да, написать кто,
[00:49.340 --> 00:50.340]  где заканчивается.
[00:50.340 --> 00:51.340]  Вот.
[00:51.340 --> 00:55.340]  Ну и давайте вспомним, как мы эту задачу решали.
[00:55.340 --> 01:00.340]  У нас, когда мы t скармливаем нашему, ну, по сути, автомату
[01:00.340 --> 01:02.340]  ахкарасик, да, то есть мы построили бор на вот этих
[01:02.340 --> 01:06.340]  вот словарных словах, потом посчитали все вот эти вот
[01:06.340 --> 01:11.340]  су-ссылки и переходы go, да, для каждой вершины,
[01:11.340 --> 01:14.340]  для каждой буквы, мы как бы знаем, куда мы переходим,
[01:14.340 --> 01:16.340]  если такую-то букву прочитаем.
[01:16.340 --> 01:23.340]  Вот, затем мы встаем в корень бора, и каждая следующая
[01:24.340 --> 01:30.340]  вершинка получается из предыдущей переходом по очередной
[01:30.340 --> 01:31.340]  букве текста.
[01:31.340 --> 01:35.340]  То есть мы просто много-много раз делаем переход go по
[01:35.340 --> 01:37.340]  очередной букве нашего текста, t1, t2 и так далее.
[01:37.340 --> 01:38.340]  Вот.
[01:38.340 --> 01:43.340]  И мы с вами вроде как обсудили, что vt в каждый момент времени
[01:43.340 --> 01:50.340]  это будет самый длинный, самый длинный суффикс,
[01:54.340 --> 01:58.340]  строки с t1 по ti, которые есть в боре.
[02:05.340 --> 02:06.340]  Вот.
[02:06.340 --> 02:08.340]  Но это простое утверждение, потому что каждый раз,
[02:08.340 --> 02:09.340]  что такое go?
[02:09.340 --> 02:12.340]  Go – это приписывание одного символа и оставление максимально
[02:12.340 --> 02:14.340]  возможного суффикса, который был в боре.
[02:14.340 --> 02:17.340]  Ну, собственно, если мы так проделаем все и раз, то
[02:17.340 --> 02:19.340]  есть написали первый символ, оставили максимальный
[02:19.340 --> 02:21.340]  суффикс, дописали второй символ, оставили максимальный
[02:21.340 --> 02:24.340]  суффикс и так далее, то в конце после этого шага
[02:24.340 --> 02:26.340]  у вас будет как раз равно тому самому максимальному
[02:26.340 --> 02:27.340]  суффиксу.
[02:27.340 --> 02:28.340]  Вот.
[02:28.340 --> 02:34.340]  Значит, vi – это самая, давайте, картиночка, вот vi – это
[02:34.340 --> 02:37.340]  какой-то такой суффикс, самый длинный, интересующий
[02:37.340 --> 02:38.340]  нас.
[02:38.340 --> 02:41.340]  И мы понимаем, что в этой позиции, как только пришел
[02:41.340 --> 02:45.340]  символ ti, у нас могли появиться некоторые вхождения.
[02:45.340 --> 02:48.160]  Некоторые вхождения словарных слов могли только что кончиться.
[02:48.160 --> 02:49.160]  Ну, какие-то слова?
[02:49.160 --> 02:53.340]  Это те слова, которые являются суффиксами вот этой штуки.
[02:53.340 --> 02:55.340]  А суффиксами вот этой штуки мы знаем, кто являются.
[02:55.340 --> 02:57.340]  Это все что достижено по суфсылкам.
[02:57.340 --> 03:00.840]  Потому что суффиксная ссылка для vaïtae – это максимальный
[03:00.840 --> 03:03.040]  собственный суффикс, который есть в боре, суфиксная
[03:03.040 --> 03:06.340]  ссылка суффиксной ссылки – это второй по максимальности
[03:06.340 --> 03:08.340]  собственно, суффикс вaïtae, который есть в боре и так
[03:08.340 --> 03:09.340]  далее.
[03:09.340 --> 03:12.340]  все возможные слова, которые могли здесь закончиться,
[03:12.340 --> 03:14.940]  все возможные словарные слова sg, которые могли только
[03:14.940 --> 03:18.940]  что получить полностью свое вхождение, являются
[03:18.940 --> 03:23.260]  достижимыми из vi по слух-ссылкам, то есть если я рассмотрю
[03:23.260 --> 03:34.340]  все вершины vi, link от vi, link от link от vi и так далее,
[03:34.340 --> 03:38.900]  то те из них, которые являются терминальными и будут соответствовать
[03:39.140 --> 03:41.180]  словам, которые только что получили вхождение.
[03:41.180 --> 03:45.660]  Вот если скажем вот эта терминальная, вот это терминальная,
[03:45.660 --> 03:47.820]  вот это терминальная значит как разhong錯но эти слова
[03:47.820 --> 03:50.580]  только что получили вхождение, так как являются суффиксами
[03:50.580 --> 03:53.440]  vi, но с другой стороны они являются словарными словами,
[03:53.440 --> 03:55.060]  потому что они терминальные, а терминальные в точности
[03:55.060 --> 03:58.900]  словарные одни из вот этих слов.
[03:58.900 --> 04:01.020]  Значит мне нужно просто на вот этом вот пути по
[04:01.020 --> 04:05.900]  instagram сblocks найти все терминальные и каждый из них только что
[04:05.900 --> 04:12.620]  получила вхождение. Давайте я так и напишу, на пути по совсылкам, на пути по
[04:12.620 --> 04:37.100]  совсылкам. Из ВИ надо найти все терминальные. Делать это очень просто. Давайте просто для каждой
[04:37.100 --> 04:44.220]  шина хранить не просто совсылку, как вот здесь, а так называемую длинную совсылку, это ссылка на
[04:44.220 --> 04:50.700]  ближайший терминальный вот на этом пути. Давайте еще что-нибудь здесь нарисую. Здесь было линк в
[04:50.700 --> 04:59.740]  кубе от ВИ, здесь линк в четвертое от ВИ. Так вот длинная суффиксная ссылка будет вести на
[04:59.740 --> 05:06.620]  ближайшую вот в этом пути, которая является терминальной. То есть длинная совсылка отсюда
[05:06.620 --> 05:12.140]  будет вести сюда, отсюда сюда, отсюда сюда, отсюда сюда. То есть мы не будем прыгать по
[05:12.140 --> 05:17.180]  совсылкам все вот эти вот разы до первой терминальной, а сразу предпочитаем какая из них,
[05:17.180 --> 05:21.980]  то есть сколько раз нужно прыгнуть, чтобы мы оказались в его терминальной вершине. Давайте
[05:21.980 --> 05:29.820]  это напишу как-нибудь типа, ну кажется я это обычно называю компрест, компрест,
[05:29.820 --> 05:42.500]  линк, типа сжатая сжатая совсылка. От В это ссылка на самый длинный суффикс В,
[05:42.500 --> 05:56.060]  самый длинный, собственный суффикс В, который является при этом терминальной вершиной,
[05:56.060 --> 06:12.460]  которая является терминальной вершиной. Если у меня такие сжатые компрест линк будут посчитаны,
[06:12.460 --> 06:18.060]  то найти вот на этом длинном пути все терминальные очень просто, нужно просто прыгать по компрест
[06:18.060 --> 06:23.620]  линкам. Мы встали в ВИ, если она терминальная, ее надо вывести, затем применяем к ней компрест
[06:23.620 --> 06:27.740]  линк, попадаем сразу в терминальную вершину, ее выводим, потом опять применяем компрест линк,
[06:27.740 --> 06:31.620]  попадаем в следующую терминальную, ее выводим и так далее. То есть вместо прыжков по линкам
[06:31.620 --> 06:37.980]  мы будем прыгать по вот этим сжатым сжатым сс ссылкам компрест линк, только попадая в те самые
[06:37.980 --> 06:43.540]  нужные терминальные вершины. Ну а чтобы их посчитать, как найти их? Найти очень просто,
[06:43.540 --> 06:56.140]  значит, компрест линк от В, это либо просто линк от В, если это терминальная вершина,
[06:56.140 --> 07:06.500]  линк от В, если линк от В это терминальная. А иначе мы понимаем, что как бы один прыжок
[07:06.500 --> 07:10.540]  недостаточно, то есть мы один раз прыгнули по су ссылке, попали в ней терминальную,
[07:10.540 --> 07:16.380]  значит нам нужно от нее взять первую терминальную, а это у нас уже лежит в компрест линк,
[07:16.380 --> 07:31.020]  поэтому здесь я пишу компрест линк от линк от В. Вот, и тогда соответственно эти сжатые ссылки
[07:31.020 --> 07:35.740]  можно посчитать просто BFS-ом точно так же, как мы считали в алгоритме Ахкарасик сверху вниз,
[07:35.740 --> 07:41.980]  если для всех более коротких слов насчитаны компрест линк, то для В мы также можем посчитать
[07:41.980 --> 07:49.820]  эту самую сжатую ссылку. Вот, соответственно подсчет суммарно за то же линейное время.
[07:49.820 --> 08:00.180]  Ну я напишу от В, где В число вершин, потому что для каждой вершины за от 1 это насчитывается.
[08:00.180 --> 08:06.340]  Ну и вот потом, когда мы текст обрабатываем, мне нужно просто вместо линк прыгать по компрест
[08:06.340 --> 08:24.660]  линк и все. Вопросы? Что-то понятно? Так, ну тогда, а да, а симпточку надо тогда ответить,
[08:24.660 --> 08:32.700]  значит а симптотика решение вот той исходной задачи будет такая. Ну, во-первых, надо сначала
[08:32.700 --> 08:39.940]  построить БОР плюс автомат Ахкарасик на исходном множестве слов. Это будет что-то такое, да? Сумма
[08:39.940 --> 08:46.980]  длин всех SI умножить на размер алфавита. Так, ну тут у меня не очень хорошее обозначение,
[08:46.980 --> 08:56.020]  ну пусть будет так. Да, то есть это суммирование, это алфавит. Плюс текст мы обрабатываем за его длину
[08:56.020 --> 09:08.580]  просто и плюс величина ответа, где ans это суммарное число всех вхождений, суммарное число вхождений
[09:08.580 --> 09:23.700]  словарных слов текст, словарных слов текст. Потому что каждое вхождение мы находим за единицу,
[09:23.700 --> 09:28.540]  вот мы встали в ВИ, взяли компрест линк, это вхождение словарного слова в текст, взяли еще
[09:28.540 --> 09:34.340]  раз компрест линк, это еще вхождение. То есть каждый прыжок по компрест линк дает нам какой-то
[09:34.660 --> 09:38.820]  информации, которую нужно напечатать, нам мы нашли очередное вхождение и получается, что каждое
[09:38.820 --> 09:44.180]  вхождение мы обрабатываем как бы за единицу. Поэтому, ну понятно, что нам, если нам нужно вывести все
[09:44.180 --> 09:48.500]  вхождения, то у нас в каком-то смысле здесь будет зависимость от ответа, чем больше вхождений,
[09:48.500 --> 09:53.500]  тем больше время работы. Но на самом деле каждое такое вхождение мы находим за единицу, потому что
[09:53.500 --> 09:58.780]  компрест линк как раз прыгает только по вхождениям. Поэтому симптомика вот такая, здесь появляется
[09:58.780 --> 10:03.900]  вот эта слагаемая зависящая от ответа, но оно как бы с коэффициентом будет один,
[10:03.900 --> 10:07.820]  потому что каждое вхождение находится за единицу. Вот.
[10:28.780 --> 10:38.980]  Так, хорошо. Тогда идем дальше. Сегодня у нас суфик массив, основная тема.
[10:38.980 --> 10:55.020]  Суфиксный массив. Задача такая, у нас есть строка. Давайте в ноль индексации сразу.
[10:55.020 --> 11:09.580]  Есть строка из n символов. Наша задача это лексикографически отсортировать все ее суфиксы.
[11:09.580 --> 11:17.300]  Давайте пока не будем задаваться вопросом, зачем это нужно. Давайте пока сначала зачем-то это сделаем.
[11:17.300 --> 11:26.220]  Отсортировать. Ну понятно, что лексик графический, потому что строки мы сравним по умолчанию
[11:26.220 --> 11:41.460]  лексик графический. Давайте я это пропишу. Лексику графически и ее суфиксы. Ну какой-нибудь пример.
[11:41.460 --> 11:52.380]  Традиционно такой. Давайте я занумирую. Вот тогда сортировка здесь будет такая.
[11:52.380 --> 12:01.380]  Сначала идет суфикс, который начинается с шестой позиции, то есть просто А. Потом будет суфикс,
[12:01.380 --> 12:21.940]  который начинается с четвертой позиции, это А. Потом будет А, ЦАБа целиком. Так А, ЦАБа, БА, БА, ЦАБа и ЦАБа.
[12:21.940 --> 12:30.220]  Ну легко понять, что все эти строки сверху внизу порядочны как раз лексик графически. И все суфиксы здесь присутствуют.
[12:31.100 --> 12:38.620]  Вот по сути нам нужна перестановка, какому порядку здесь написаны все суфиксы. Ясно, что каждый суфикс
[12:38.620 --> 12:43.940]  однозначно определяется своим первым символом. Вот этот суфикс, который начинается с шестого символа,
[12:43.940 --> 12:48.140]  это суфикс, который начинается с второго символа и т.д. то есть вместо суфиса можно написать
[12:48.140 --> 12:54.700]  его первый номер. Номер первого символа в этом суф принципе. Поэтому нам нужнаuberестановка.
[12:54.700 --> 13:04.700]  и я ее буду обозначать. Порядок сортировки всех суффиксов в лекс-порядке. Так, вот это нам
[13:04.700 --> 13:12.780]  нужно сделать. Ну, давайте для удобства мы дополним нашу строчку справа каким-нибудь символом,
[13:12.780 --> 13:22.140]  который заведомо меньше в лекс-порядке всех символов строки. Давайте я вместо s буду писать
[13:22.140 --> 13:30.460]  с решетка. Добавил в конец какой-то символ, который гарантированно меньше всех символов исходной
[13:30.460 --> 13:34.380]  строки. Если нам известно, что исходные все символы, скажем, маленькие латинские буквы,
[13:34.380 --> 13:39.620]  то всегда подойдет решетка, потому что у нее ASCII код меньше, чем у всех маленьких латинских
[13:39.620 --> 13:49.380]  букв. Вот, и более того, мы вот эту строчку, давайте я теперь вот это, вот это теперь s,
[13:49.380 --> 13:59.460]  то есть я как бы сделал s плюс равно решетка. Я добавил решетку и теперь считаю, что это новая
[13:59.460 --> 14:06.260]  строка s. И давайте я ее еще и зациклю. То есть буду как бы символы строки располагать не так
[14:06.260 --> 14:17.020]  слева-направо, а по циклу. В том смысле, что после решетки опять идет начало строки,
[14:17.020 --> 14:25.380]  первый символ a, ну точнее нулевой. 0, 1, 2, 3, 4, 5, 6, 7. После 7 опять 0, то есть символ a.
[14:25.380 --> 14:35.540]  Вот, зациклили, прибавили решетку, и тогда мы можем определить для любого i,
[14:35.540 --> 14:41.380]  для любого k под строку, которая начинается в позиции i длины k. Нужно просто встать в эту
[14:41.380 --> 14:48.260]  позицию и читать k символов против всего стрелки, ну в порядке возрастания номеров до тех пор,
[14:48.260 --> 14:52.940]  пока мы k символов не прочитаем. Если раньше под строка у меня, скажем, было ограничено концом
[14:52.940 --> 14:57.540]  строки, то теперь у меня уже такого ограничения нету, я могу сколько угодно долго петлять по этому
[14:57.540 --> 15:01.780]  кругу, хоть там, не знаю, сто раз его обойти, это все будет под строка вот этот зацикленные строки.
[15:01.780 --> 15:18.140]  То есть под строка с началом в i и длины k, ну это понятно, что такое, нужно встать в i-ты символ
[15:18.140 --> 15:22.620]  на круге и читать вот так вот k символов, порядка возрастания номеров до тех пор, пока k символов
[15:22.620 --> 15:31.220]  не прочитаем. Так, ну давайте я не буду писать, понятно, что имеется в виду s i, s i плюс 1 и так
[15:31.220 --> 15:37.500]  далее, там, вплоть до конца строки, s 0 и так далее и так далее, ну в общем, мы ее зациклили, да, можем
[15:37.500 --> 15:50.340]  как бы начинать сначала, главное, чтобы здесь было ровно k символов. И теперь мы будем делать
[15:50.340 --> 15:56.940]  следующее, вместо того, чтобы сортировать суффиксы, мы будем сортировать все под строки, длины которых
[15:56.940 --> 16:08.580]  являются степенями двойки. Значит, на нулевом шаге мы отсортируем, отсортируем все под строки длины 1,
[16:08.580 --> 16:21.860]  на первом шаге все под строки длины 2, на втором шаге все под строки длины 4, ну и так далее по
[16:21.860 --> 16:28.680]  степеням двойки 8, 16 и так далее, пока не отсортируем все строки достаточно большой длины, чтобы считать,
[16:28.680 --> 16:37.400]  что все суффиксы тоже отсортированы. Ну давайте сразу конец поймем, что вдруг вот, давайте
[16:37.400 --> 16:42.220]  предположим, что мы отсортировали все под строки длины, являющиеся степенью двойки, которая больше
[16:42.220 --> 16:50.260]  равна, чем длина исходной строки. Значит, там на каком-то примерно log n там шаге отсортированы все
[16:50.260 --> 17:00.380]  под строки длины там какой-то 2 в степени r, которая больше и равна длины исходной строки n. Да,
[17:00.380 --> 17:11.620]  да, да, да. Ну она, конечно, не обязательно там присутствует, но если происходит зацикливание,
[17:11.620 --> 17:17.900]  то там решетка и 0 символ. Так вот, мы делаем так сколько-то итераций, например, как-то мы умеем
[17:17.900 --> 17:22.580]  эффективно переходить вот одной итерацией к другой, и пусть на последней итерации у меня
[17:22.580 --> 17:36.700]  отсортированы все подстройки длины степени двойки больше либо равно, чем n. Больше либо равно,
[17:36.700 --> 17:45.540]  сейчас, секунду. Ну давайте рассмотрим какие-нибудь две вот такие подстроки длины хотя бы n. Во-первых,
[17:45.540 --> 17:49.940]  раз у них длина хотя бы n, значит, что они целиком как минимум один раз весь круг огибают,
[17:49.940 --> 17:55.620]  поэтому там точно есть решетка. Да, раз длина больше либо равно, чем n, то целиком весь круг,
[17:55.620 --> 18:00.980]  по крайней мере, один раз обходится, в них есть решетка. Поэтому, если я их запишу как строки
[18:00.980 --> 18:09.460]  обычные, то в них где-то на разных местах будет решетка. На разных местах, потому что начало
[18:09.460 --> 18:15.420]  разные, значит, и первое вхождение решетки тоже разное. Итого, у меня будет вот такая вот
[18:15.420 --> 18:21.100]  сортировка всех подстрок длины 2 степени r, и здесь на всех разных местах будет решетка по одному
[18:21.100 --> 18:26.020]  разу, ну что-то такое. И все они будут, более того, обязательно друг друга строго меньше,
[18:26.020 --> 18:31.260]  ну потому что соседние не могут быть равные, потому что там решетка в разных местах,
[18:31.260 --> 18:37.780]  значит, они друг друга строго лицеграфически меньше, вот в таком порядке с верху вниз. Ну
[18:37.780 --> 18:47.660]  тогда, если я оставлю вот эти вот куски моих строк, то есть все до решетки, то я получу суффиксный
[18:47.660 --> 18:56.300]  массив. Потому что, что значит, что эта строка меньше, чем эта? Это значит, что, скажем, вот эта
[18:56.300 --> 19:02.260]  штука равна вот этой, а здесь решетка, здесь что-то больше решетки, либо отличие между ними где-то
[19:02.260 --> 19:06.580]  вот здесь, вот и скажем, у них вот такой префикс совпадает, а эти символы меньше. То есть,
[19:06.580 --> 19:13.180]  если одна строка меньше другой с дописанной вот здесь правой решеткой, то после удаления решетки
[19:13.180 --> 19:17.660]  первая строка будет меньше равна, чем вторая. Потому что, если есть две строки, одна меньше другой,
[19:17.660 --> 19:22.140]  у них в конце дописан один и тот же символ решетки. Ну то есть, я игнорирую все, что правее решетки,
[19:22.140 --> 19:29.300]  потому что это точно уже не влияет на сравнение. Вот. Одна меньше второй в конце у обеих решетки,
[19:29.300 --> 19:33.380]  если решетки сотрут, то неравенство может максимум стать нестрогим. Но, на самом деле,
[19:34.180 --> 19:38.780]  потому что у них длины будут разные у всех, поэтому равенства там точно не будет. Вот. Значит,
[19:38.780 --> 19:44.620]  если я просто вот так вот напишу все эти строки, все эти подстроки, то они будут в порядке возрастания
[19:44.620 --> 19:49.500]  идти, во-первых. Во-вторых, это будут суффиксы, потому что это некие конечные куски, после которых
[19:49.500 --> 19:54.660]  идет решетка, то есть конец строки. Значит, все вот это суффиксы в некотором порядке, все suffix
[19:54.660 --> 19:59.560]  в нашей строке, и они идут в лексиграфическом порядке. Поэтому, чтобы решить исходную задачу,
[19:59.560 --> 20:01.920]  задачу, достаточно научиться сортировать все подстроки
[20:01.920 --> 20:07.040]  длины вот такой вот, хотя бы n. Согласны? Вот, значит,
[20:07.040 --> 20:09.000]  вместо исхода мы будем решать вот эти задачи.
[20:09.000 --> 20:28.480]  Не совсем, потому что,
[20:28.780 --> 20:36.920]  что
[20:36.920 --> 20:41.120]  потому что вам нужно сохранить вот если у вас есть два такие суффиксы и вам
[20:41.120 --> 20:44.920]  нужно чтобы это было меньше этого, чтобы при удалении решетки это было
[20:44.920 --> 20:48.800]  меньше, чем вот это. Потому что иначе, если бы у вас решетка была бы больше,
[20:48.800 --> 20:52.800]  чем a в вас был бы порядок наоборот, и соответственно это считалось бы меньше,
[20:52.800 --> 20:57.600]  чем вот это. Но... То есть вам нужно чтобы решетка была примерно эквивалентно
[20:57.600 --> 21:00.880]  на концу строки, то есть если какая-то строка заканчивается
[21:00.880 --> 21:03.240]  решеткой, то это должно быть меньше, то есть это как
[21:03.240 --> 21:06.400]  бы знак конца строки, более короткая длина у этой
[21:06.400 --> 21:08.200]  строки, поэтому она должна быть меньше, чем что угодно
[21:08.200 --> 21:09.200]  другое.
[21:09.200 --> 21:16.920]  Так, ну что, давайте сортировать все подстроки длины 1.
[21:16.920 --> 21:20.240]  Ну, этот шаг тривиален, как отсортировать все подстроки
[21:20.240 --> 21:23.240]  длины 1?
[21:23.240 --> 21:33.960]  Ну да, обычные или подсчетом каким-нибудь, если мы считаем,
[21:33.960 --> 21:36.040]  что все символы строки это там какие-нибудь маленькие
[21:36.040 --> 21:40.440]  латинские буквы, ну ладно, не важно, пусть есть какой-то
[21:40.440 --> 21:51.040]  алфавит, там сигма, давайте я пройдусь по нашей строке,
[21:51.040 --> 21:56.520]  подсчитаю число вхождения каждого символа, ну в общем
[21:56.520 --> 21:59.880]  сейчас будет обычная сортировка подсчетом, подсчитал количество
[21:59.880 --> 22:03.840]  вхождения каждого символа, вот, а дальше, ну зависит
[22:03.840 --> 22:08.880]  от того, как вы привыкли писать эту самую сортировку,
[22:08.880 --> 22:12.080]  значит я давайте напишу ее сразу стабильно, вот так,
[22:12.080 --> 22:18.600]  мы это когда-то год назад, кажется, делали, там не больше
[22:18.600 --> 22:28.400]  чем размер алфавита, knt it плюс равно knt i минус 1, то
[22:28.400 --> 22:32.200]  есть сейчас knt it это количество символов неравных i, а меньше
[22:32.200 --> 22:40.440]  равных i, вот, а дальше мы пойдем по нашей строке
[22:40.440 --> 22:52.880]  право-налево и напишем что-то типа так, вроде так, это
[22:52.880 --> 23:06.480]  должно написаться, похоже на правду, да, давайте кратко
[23:06.480 --> 23:08.880]  что-нибудь нарисую, вот была у меня, например, такая
[23:08.880 --> 23:13.880]  строка, давайте я все буквы сразу переведу в нули, короче,
[23:13.880 --> 23:21.120]  в числа, 0, 2, 0, 1, 2, 1, что-нибудь вот такое, значит после
[23:21.120 --> 23:25.480]  вот этого knt у меня будет knt нулевое, это 3, потому
[23:25.480 --> 23:29.120]  что есть 3 нуля, knt вот 1 это будет 5, потому что 3 нуля
[23:29.120 --> 23:33.640]  и 2 единицы, knt двойки будет 7, и вот это число, которое
[23:33.640 --> 23:38.000]  тут написано, отвечает тому, какая последняя позиция
[23:38.000 --> 23:40.800]  должна быть у нуля, то есть на какую позицию нужно
[23:40.800 --> 23:43.520]  положить самый правый ноль, на третью, потому что их
[23:43.520 --> 23:46.800]  здесь 3, на третьем месте должен быть последний ноль,
[23:46.800 --> 23:49.240]  на пятом месте должна быть последняя единица, на седьмом
[23:49.240 --> 23:51.520]  месте должна быть вторая двойка, потому что ассортированная
[23:51.520 --> 23:55.560]  версия будет вот такой, как раз на третьем последний
[23:55.560 --> 23:57.840]  ноль, на пятом последняя единица, на седьмом последняя
[23:57.840 --> 24:00.320]  двойка, и если я по этому массиву теперь буду идти
[24:00.320 --> 24:05.800]  справа-налево, скажем встречаю 0, вот оно si равно нулю, тогда
[24:05.800 --> 24:08.920]  у меня knt от si это та самая последняя позиция, куда
[24:08.920 --> 24:13.400]  нужно положить вот это вот число, ну в 1 индексации,
[24:13.400 --> 24:16.040]  я ее дальше уменьшаю на 1, чтобы получить 0 индексацию,
[24:16.040 --> 24:19.200]  и вот сюда кладу то самое i, если i было здесь, я его положил
[24:19.200 --> 24:22.760]  сюда, дальше иду в единицу, вижу, ага, единицу нужно
[24:22.760 --> 24:26.320]  положить на 5 место, вычитаю, ну в 0 индексации получаю
[24:26.320 --> 24:29.760]  4 место, кладу вот сюда, вот это вот, там i-1, дальше
[24:29.760 --> 24:32.360]  беру двойку, вот эту двойку кладу сюда, эта единица
[24:32.360 --> 24:35.240]  уже пойдет сюда, потому что knt от 1 уже на 1 меньше,
[24:35.240 --> 24:38.080]  да, оно перейдет сюда, ну и так далее, сидя справа-налево
[24:38.080 --> 24:43.840]  я раскладываю каждый элемент в последний, как бы, в конец
[24:43.840 --> 24:46.000]  своей корзинки, то есть я определил, что вот эта корзинка
[24:46.000 --> 24:49.480]  нулей, эта корзинка единицы, эта корзинка двоек, и кладу
[24:49.480 --> 24:52.360]  последнюю двойку на последнее место в корзинке двоек,
[24:52.360 --> 24:59.560]  ну и так далее, кажется, такое мы делали, да, пока
[24:59.560 --> 25:15.960]  первый шаг, ну нулевой, точнее, вот, значит, дальше
[25:15.960 --> 25:20.040]  идея следующая, чтобы переходить там от шага k к шагу k плюс
[25:20.040 --> 25:23.320]  1, смотрите, предположим, что у нас отсортированы
[25:23.320 --> 25:25.920]  все подстроки длины 2 в катой, да, мы идем по степеням
[25:25.920 --> 25:28.880]  двойки, на каком-то k там шаге отсортированы все подстроки
[25:29.300 --> 25:31.400]  длины 2 в катой, а теперь мне нужно отсортировать
[25:31.400 --> 25:34.400]  подстроки длины 2 в степенька плюс 1, ну понятно, что любая
[25:35.080 --> 25:39.100]  подстрока длины 2 в степенька плюс 1 разбивается на две
[25:39.100 --> 25:41.560]  одинаковых кусочка по длине, одинаковых по длине кусочка
[25:41.560 --> 25:45.360]  длины 2 в степеника, да, и если вдруг мне нужно сравнить
[25:45.360 --> 25:49.200]  между собой две подстроки длины 2 в степенька плюс
[25:49.200 --> 25:54.820]  1, чтобы понять какая из них больше, какая меньше
[25:54.820 --> 25:58.000]  мне нужно в каком-то смысле разбить ее на два кусочка,
[25:58.000 --> 26:02.200]  каждую из них разбить на два кусочка, сравнить, какой здесь знак, какой здесь знак.
[26:02.560 --> 26:08.680]  Если, например, вот здесь вот точно уже значок меньше, то есть этот кусок меньше этого, то и суммарно вот это меньше, чем вот это.
[26:09.160 --> 26:14.560]  Если здесь равенство, то знак неравенства между длинными строками определяется знаком неравенства вот между этими двумя.
[26:16.160 --> 26:18.480]  И по сути мне нужно просто сделать церковку пар.
[26:19.360 --> 26:25.760]  Потому что разбив длинную строку на две короткие, я сначала делаю сравнение по первому элементу пары,
[26:26.240 --> 26:30.720]  если равно, то делаю сравнение по второму. Это в чистом виде сортировка пар.
[26:31.880 --> 26:40.720]  Значит, если я каким-то образом смогу представить вот эти вот все более короткие куски в виде чисел, то мне нужно будет отсортировать массив пар.
[26:40.720 --> 26:58.480]  Ну, давайте, значит, этот массив чисел заведем. Что за массив чисел?
[26:58.480 --> 27:06.360]  Мне нужно каждой подстроке длины два степеника сопоставить некое число так, чтобы равным строкам отвечали равные числа,
[27:07.120 --> 27:11.280]  а разным строкам отвечали числа, которые соотносятся также как исходные строчки.
[27:11.280 --> 27:19.080]  Если одна строка меньше другой, то число, отвечающее первой строке, должно быть меньше числа, отвечающего второй строке.
[27:20.400 --> 27:22.400]  Значит, это то, что у нас будет называться класс эквивалентности.
[27:25.080 --> 27:27.080]  Класс эквивалентности.
[27:28.080 --> 27:36.080]  Для каждой подстроки длины два вкаты я буду хранить некое число, которое будет называться ее классом эквивалентности.
[27:36.080 --> 27:41.080]  И эти классы между собой, как числа, соотносятся также как исходные строки.
[27:41.080 --> 27:49.080]  То есть если исходные строки были равны, то у них одинаковые классы эквивалентности, а если одна строка меньше другой, то класс первый должен быть меньше, чем класс второй.
[27:49.080 --> 27:59.080]  Такое числовое отображение, ну точнее отображение из строк в числа, сохраняющее знак меньше, сохраняющее меньше и равно.
[28:01.080 --> 28:07.080]  Ну тогда давайте введем. Усицы ИТ – это тот самый класс эквивалентности.
[28:07.080 --> 28:09.080]  Класс эквивалентности.
[28:09.080 --> 28:16.080]  Строки, которые начинаются с позиции И, имеют длину два степеника.
[28:20.080 --> 28:22.080]  Класс эквивалентности такой строки.
[28:22.080 --> 28:32.080]  Ну понятно, здесь там зацикливание, да, и если эта штука больше, чем N, то она берется по модулю и как бы вот этот круг обходится через разрез.
[28:32.080 --> 28:35.080]  И с конца в начало обходится.
[28:40.080 --> 28:42.080]  Еще раз?
[28:49.080 --> 28:51.080]  Не, мы не будем так делать.
[28:54.080 --> 28:56.080]  Ну это интересная идея, да.
[29:01.080 --> 29:10.080]  Так можно, но там синтетика будет чуть хуже, потому что когда вы умножаете на два вкаты, у вас в лучшем случае будут числа порядка N квадрата.
[29:10.080 --> 29:15.080]  Да, получается, если номер класса умножено на длину, то это N квадрат примерно в лучшем случае.
[29:15.080 --> 29:21.080]  И их сортировать уже, вот такой сортировка не получится. Сортировка под счетом там уже не пройдет.
[29:22.080 --> 29:29.080]  Да, там можно обычно сортировку какую-нибудь, ну, quick sort, но тогда будет чуть хуже синтетика. Но идея интересная, правда.
[29:38.080 --> 29:40.080]  Еще раз?
[29:40.080 --> 29:42.080]  Ну это число.
[29:45.080 --> 29:55.080]  А, вы про это? Нет, считаете, что вы не знаете теорию групп?
[29:55.080 --> 30:00.080]  Окей, номер класса эквиваленции, так будет лучше?
[30:00.080 --> 30:04.080]  Так, хорошо, секунду.
[30:04.080 --> 30:07.080]  Окей, это название просто. Смотрите еще раз, что мы хотим?
[30:07.080 --> 30:12.080]  Мы хотим в каждой строке длины два степенька сопоставить некое число.
[30:12.080 --> 30:18.080]  Так что, если две строки длины два степенька равны, то им отвечают одинаковые числа.
[30:18.080 --> 30:24.080]  А если одна строка длины два степенька меньше другой, то число, отвечающее этой строке, меньше, чем вот это число.
[30:24.080 --> 30:32.080]  То есть, по сути, мне нужен, извините, гомоморфизм частично упорядоченных множеств.
[30:32.080 --> 30:36.080]  Да, то есть, как бы, отображение в числа сохраняющего значок меньше.
[30:36.080 --> 30:40.080]  Если это меньше этого, то число, отвечающее этому, меньше числа, отвечающее этому.
[30:41.080 --> 30:44.080]  Вот.
[30:44.080 --> 30:54.080]  Ну блин, я так назвал эквивалентность, потому что как бы у вас бывают подстроки, встречающиеся в разных позициях, но которые одинаковые.
[30:54.080 --> 30:59.080]  И мне нужно сказать, что они как бы одинаковые, они как строки длины два вката одинаковые, эквивалентны.
[30:59.080 --> 31:04.080]  Поэтому им должно отвечать одно и то же число.
[31:04.080 --> 31:10.080]  Да, ну окей, это как бы эквивалентность подстрок на вот этих первых два степенька символов.
[31:10.080 --> 31:13.080]  Да, вы правы, все, я сам затупил.
[31:13.080 --> 31:23.080]  То есть, это да, скорее номер класса, то есть число, вот то самое числовое отображение из подстроки в число, сохраняющее значок меньше.
[31:25.080 --> 31:31.080]  Вот, ну а теперь мы понимаем, что если у меня есть некие две подстроки длины два степенька плюс один.
[31:35.080 --> 31:39.080]  То мне нужно просто сравнить сначала С от этой штуки с С вот этой штуки.
[31:39.080 --> 31:43.080]  Если тут значок меньше, то значит меньше из них, то у кого значок меньше.
[31:43.080 --> 31:47.080]  Если равно, то я сравниваю по номеру класса вот этих вторых половинок.
[31:47.080 --> 31:53.080]  И это в точности сортировка пар. То есть, если я каждую строку, да, давайте я здесь веду позицию И.
[31:54.080 --> 32:00.080]  То такую подстроку я могу отнаждествить с парой СИ запятая С и плюс два степенька.
[32:00.080 --> 32:07.080]  Ну а номер класса левой половинки, номер класса правой половинки.
[32:07.080 --> 32:10.080]  То же самое для любой другой подстроки.
[32:10.080 --> 32:13.080]  Теперь мне нужно посортировать эти пары.
[32:15.080 --> 32:20.080]  Ну и как бы у меня будет готова уже сортировка вот на этом К плюс первом этапе.
[32:20.080 --> 32:26.080]  Если у меня раньше была сортировка для подстрок длины два вкатый, то теперь будет готова сортировка для подстрока длины два в степени К плюс один.
[32:27.080 --> 32:31.080]  Вот. Вопрос, как эту сортировку делать максимально эффективно.
[32:31.080 --> 32:35.080]  Да, конечно, можно запустить там произвольный алгоритм за N log N.
[32:35.080 --> 32:38.080]  Ну тогда симптотика будет N log квадрат.
[32:38.080 --> 32:55.080]  Если пары сортировать за N log N, то итоговая симптотика будет N log квадрат.
[32:56.080 --> 33:06.080]  Ну потому что на каждом шаге мы сортируем за N log N и у нас лог, лог итерации.
[33:06.080 --> 33:09.080]  Потому что мы переходим к К плюс один, К плюс два и так далее.
[33:09.080 --> 33:13.080]  По степеням двойки до тех пор пока у нас вот эта степень двойки не будет больше иначе N.
[33:13.080 --> 33:15.080]  Таких шагов алгоритм примерно.
[33:15.080 --> 33:18.080]  Вот. Значит будет ассинтотика N log квадрат.
[33:18.080 --> 33:22.080]  Но мы можем с вами эти пары сортировать за линию.
[33:22.080 --> 33:24.080]  Не за N log, а за линию.
[33:24.080 --> 33:28.080]  Потому что все элементы пар у меня не больше, чем N.
[33:28.080 --> 33:30.080]  Маленькие числа не больше, чем N.
[33:30.080 --> 33:33.080]  Потому что всего подсрока для недвовката не больше, чем N.
[33:33.080 --> 33:37.080]  Значит и номеров класса эквалентности нам достаточно максимум N.
[33:37.080 --> 33:41.080]  Поэтому все вот эти числа всегда будут не больше, чем N.
[33:41.080 --> 33:46.080]  А значит мы по сути можем сделать ту же самую сортировку подсчетом, только это будет сортировка пар.
[33:46.080 --> 33:49.080]  А пары мы сортировать тоже уже когда-то учились.
[33:54.080 --> 34:19.080]  Итак, вместо такой сортировки будем использовать сортировку пар за линейное время.
[34:25.080 --> 34:29.080]  Кто-то помнит, как выполнять сортировку пар за линейное время?
[34:30.080 --> 34:32.080]  Да, да, да, все правильно.
[34:32.080 --> 34:38.080]  Сначала выполняем произвольную сортировку, сравнивая пары по второму элементу.
[34:38.080 --> 34:41.080]  Затем стабильно по первому.
[34:43.080 --> 34:47.080]  Это будет как раз верно, потому что в последнюю очередь будет сортировка по первому элементу.
[34:47.080 --> 34:53.080]  То есть если у двух пар первые элементы разные, то порядок между ними будет такой, какой надо.
[34:53.080 --> 34:57.080]  Потому что в конце была сортировка по первому элементу пары.
[34:57.080 --> 35:09.080]  А если у них вот эти штуки одинаковые, то из-за стабильности сортировки порядок между ними будет такой же, как порядок между этими двумя цшками.
[35:10.080 --> 35:18.080]  Поэтому в случае равенства первых элементов у меня сравнение будет происходить как раз по второму элементу из-за стабильности этой сортировки.
[35:18.080 --> 35:26.080]  Как вот здесь, мы просто делаем ту же самую сортировку подсчетом, только сначала по второму элементу пар, потом по первому.
[35:29.080 --> 35:31.080]  Итого алгоритма такой.
[35:36.080 --> 35:45.080]  Поддерживаем P и C для каждой террации.
[35:49.080 --> 35:54.080]  На какой-то cut иterации пусть у нас было P и C.
[35:54.080 --> 36:02.080]  Чтобы перейти от cut иterации к следующей, K плюс первый, мне нужно создать вот тот массив пар.
[36:02.080 --> 36:21.080]  Дальше мы его так хитро сортируем. Сначала по второму элементу, потом стабильно по первому.
[36:21.080 --> 36:27.080]  Сортируем в скобочках сначала по второму.
[36:32.080 --> 36:34.080]  Потом стабильно по первому.
[36:43.080 --> 36:48.080]  Эта сортировка уже дает нам новый порядок P.
[36:48.080 --> 36:50.080]  Давайте я назову P штрих.
[36:52.080 --> 36:59.080]  Это дает P штрих, потому что у меня есть новый порядок следования всех подстрок длины 2 в степени K плюс 1.
[37:00.080 --> 37:03.080]  Ну а также отсюда легко извлечь C штрих.
[37:03.080 --> 37:11.080]  Легко найти C штрих, потому что теперь эти пары, если они равны, то они в одном классе эквивалентности.
[37:11.080 --> 37:16.080]  Если пары различные, то в разных, и нам нужно изменить как классы эквивалентности.
[37:16.080 --> 37:19.080]  Сейчас про эти детали мы еще поговорим.
[37:29.080 --> 37:41.080]  С точки зрения кода.
[37:41.080 --> 37:44.080]  Вот это я оставляю. Это нулевая итерация.
[37:44.080 --> 37:49.080]  К этому моменту мы посчитали массив P на нулевой итерации.
[37:49.080 --> 37:54.080]  Еще нам нужно найти массив C.
[37:54.080 --> 38:00.080]  Ну, например, это можно сделать так.
[38:12.080 --> 38:14.080]  Лапень.
[38:24.080 --> 38:26.080]  Массив.
[38:55.080 --> 38:56.080]  Что я тут написал?
[38:56.080 --> 39:05.080]  Напоминаю, что в перестановке P написаны некий порядок всех суффиксов, то есть порядок всех подстрок длины 1.
[39:05.080 --> 39:12.080]  То есть там находится, по сути, какая-то перестановка всех номеров индексов, всех индексов в каком-то порядке.
[39:12.080 --> 39:15.080]  Что такое C от P от нуля?
[39:15.080 --> 39:19.080]  P от нуля – это тот, точнее, тап от строка длины 1, который я посчитал минимальный.
[39:19.080 --> 39:22.080]  Потому что в массиве P они написаны в порядке возрастания.
[39:22.080 --> 39:24.080]  P0 – это минимальная строка.
[39:24.080 --> 39:27.080]  Значит, номер классикоэвалентности должен быть нулевым.
[39:27.080 --> 39:30.080]  Ну, минимальным. Я назначаю ей минимальный номер.
[39:30.080 --> 39:41.080]  Дальше. Я иду по моей перестановке P и изначально говорю, что следующая подстрока имеет тот же самый классикоэвалентности, что и предыдущая.
[39:41.080 --> 39:44.080]  Номер класса для P равен номер класса для P-1.
[39:44.080 --> 39:48.080]  Но только если там написаны, на самом деле, различные символы.
[39:48.080 --> 39:58.080]  То есть, если символ, написанный на позиции P, не равен символу, написанному позиции P-1, то тогда я увеличу текущий номер класса эквалентности.
[39:58.080 --> 40:04.080]  Вот, например, если у меня была… Давайте я восстановлю эту штуку.
[40:04.080 --> 40:10.080]  Вот после сортировки всех символов исходной строки у меня будет вот такой массив.
[40:10.080 --> 40:16.080]  Значит, ну это не P, это скорее там сейчас, ну ладно.
[40:22.080 --> 40:25.080]  Значит, это то, что получается после сортировки.
[40:25.080 --> 40:29.080]  Дальше я иду по… А здесь как бы написаны некие индексы.
[40:29.080 --> 40:36.080]  Так, кто-то записывал вот исходную перестановку, которая у меня тут была написана, строка из 0 единиц и 2?
[40:41.080 --> 40:44.080]  Спасибо. Вот.
[40:46.080 --> 40:49.080]  Соответственно, переставка P будет такая.
[40:51.080 --> 40:55.080]  Значит, 1 будет 3,5, 2 будет 1,4.
[40:55.080 --> 41:06.080]  Вот это будет P, то есть в каком порядке нужно писать все суффиксы, точнее все подстроки длины 1, чтобы получилось все в порядке сортировки вот этого вот массива, был лексографический сортировок.
[41:06.080 --> 41:13.080]  Сначала ноль. Я говорю, что вот он, да, нулевая позиция, это будет нулевой класс эквалютности.
[41:13.080 --> 41:20.080]  Здесь будет ноль. Дальше, я вижу 2, вижу, что здесь символ такой же, как предыдущий, эта символ thunderstorm.
[41:20.080 --> 41:24.080]  Поэтому номер класса оставляю. Здесь номер класса такой же, потому что символы равны.
[41:24.080 --> 41:34.080]  А дальше я сначала как бы пытаюсь поставить ноль и изначально говорю, что здесь будет ноль , но потом вижу, что этот символ отличен от предыдущего, поэтому здесь номер класса будет другой.
[41:34.080 --> 41:39.360]  здесь будет 1, вот, ну и по сути я просто прохожусь по вот этой перестановке, да,
[41:39.360 --> 41:43.920]  если вижу, что очередной встретившийся символ не равен предыдущему, то я должен
[41:43.920 --> 41:47.120]  увеличить номер класса эквивалентности, тогда как раз у меня выполняется то
[41:47.120 --> 41:51.640]  свойство, которое мне нужно от класса эквивалентности, что равным строкам
[41:51.640 --> 41:56.200]  отвечают равные классы эквивалентности, а разным, да, когда я перехожу от одного, от
[41:56.200 --> 42:00.360]  одной строки к другой, я уже номер класса увеличиваю, и если предыдущая строка
[42:00.360 --> 42:03.560]  была меньше, то значит и номер класса эквивалентности у нее тоже меньше,
[42:03.560 --> 42:07.520]  потому что я увеличил на один, номер класса стал больше, значит, если тут будет
[42:07.520 --> 42:11.120]  значок меньше, то здесь будет тоже значок меньше.
[42:11.120 --> 42:25.800]  Потому что класса всегда будет не больше, чем n.
[42:25.800 --> 42:34.680]  Ну, правда.
[42:34.680 --> 42:42.240]  Ну, потому что под строк всего n, каждую по строке мы назначаем какое-то число,
[42:42.240 --> 42:46.560]  да, ну новое, не отрицательное, и их тогда максимум n нам нужно.
[42:46.560 --> 42:56.600]  Вот, значит, нулевой шаг мы вроде как сделали, теперь делаем переход к следующему.
[42:56.600 --> 43:05.640]  Ну, давайте считать, что там у меня сделаны первые k шагов, и у меня после k шага правильно
[43:05.640 --> 43:11.840]  подсчитаны массивы c и p. Теперь делаем тогда переход к k плюс 1.
[43:11.840 --> 43:24.880]  Хорошо, значит, во-первых, мне нужно найти порядок сортировки всех построк длины 2 в степени k плюс 1.
[43:24.880 --> 43:34.440]  Я должен все подстроки сгруппировать вот такими парами по 2 в степени k подряд идущие и выполнить
[43:34.440 --> 43:40.800]  сортировку. Сначала мне нужна сортировка по вот этим вторым половинкам, да, по вторым аргументам.
[43:40.800 --> 43:46.880]  Но смотрите, на самом деле, когда я сортирую все пары по вторым половинкам, я, по сути,
[43:46.880 --> 43:52.560]  сортирую все подстроки длины 2 в степени k, да, потому что все правые половинки всех подстрок
[43:52.560 --> 43:58.320]  это в точности все подстроки длины 2 в степени k. Но такое мы уже делали, это по сути просто перестановка
[43:58.320 --> 44:05.400]  p. На p это порядок сортировки всех подстрок длины 2 в степени k. А теперь мне нужно делать то же самое,
[44:05.400 --> 44:10.680]  вот когда я сортирую пары, давайте я восстановлю это вот, по сути, я должен отсостровать пары вот
[44:10.680 --> 44:16.720]  такие вот, по вот этому аргументу. То есть я опять-таки сортирую все подстроки длины 2 в степени k,
[44:16.720 --> 44:22.840]  только теперь они уже как бы начинаются не вот здесь, а как бы вот здесь вот. И тогда, давайте
[44:22.840 --> 44:31.960]  назову p new, тогда новое, p n пусть будет, тогда то, что новое должно быть на нулевой позиции, это
[44:31.960 --> 44:42.360]  что-то типа p 0 плюс 2 в степени k, да, потому что если p 0 это вот это вот это вот, да,
[44:42.360 --> 44:48.280]  тогда самая маленькая строка длины 2 в степени k начинается где-то вот здесь, например. Тогда p n
[44:48.280 --> 44:53.440]  от нуля, то есть когда я сортирую вот эти вот пары по второму аргументу, самая маленькая должна
[44:53.440 --> 44:57.840]  встречаться вот здесь. То есть я игнорирую первую половину и беру, чтобы вот это, хочу чтобы вот
[44:57.840 --> 45:03.200]  это было самой маленькой среди всех подстрок длины 2 в степени k. Поэтому минимальной строкой вот в
[45:03.200 --> 45:07.600]  этом вот порядке сортировки будет просто вот это. Мне даже не нужно заново ничего пересортировать,
[45:07.600 --> 45:13.040]  потому что они у меня уже отсортированы, только единственное, нужно сделать поправку по вот этому
[45:13.040 --> 45:20.680]  2 в степени k. Да, да, спасибо, минус, конечно, минус, да, потому что если вот это это p 0,
[45:20.680 --> 45:28.160]  то p n от нуля наоборот на 2 степени k левее. Вот, ну и так далее, да, если я знаю, что там p i
[45:28.160 --> 45:33.860]  t находится на i-том месте, то p n i t это то, что находится на 2 степени k левее, поэтому первый
[45:33.860 --> 45:47.540]  шаг очень простой. p n i t это просто p i t минус 2 степени k. Ну, если это число отрицательно,
[45:47.540 --> 45:59.540]  нужно прибавить n, чтобы не, то есть давайте так напишу, да, если p n i меньше нуля, тогда p n i
[45:59.540 --> 46:05.440]  плюс равно n. Ну, я считаю, что как бы если происходит зацикливание, то максимум на 1
[46:05.440 --> 46:14.160]  оборот круга, то есть он не может быть сильно отрицательным. Вот, ну а дальше я не буду так
[46:14.160 --> 46:18.920]  подробно прописывать, понятно, что все вот эти вот вычисления, они как бы по модулю n происходят,
[46:18.920 --> 46:23.960]  потому что я зацикливаю мой круг, да, и все, что там отрицательно, на самом деле соответствует
[46:23.960 --> 46:44.100]  какому там числу, которое не отрицательно по модулю n. Смотрите, p это порядок сортировки,
[46:44.100 --> 46:52.500]  p 0 это номер начала самой маленькой строки, p 1 это как бы вторая по минимальности и так далее,
[46:52.500 --> 46:58.520]  то есть вот есть у меня все подстроки d n 2 в степени k, они все начинаются в какой-то позиции,
[46:58.520 --> 47:05.000]  соответственно, каждая подстрока d n 2 в степени k отреждествлена с номером начала, если k фиксировано,
[47:05.000 --> 47:10.320]  то просто подстрока это по сути номер начала. Когда я их сортирую, у меня получается некий порядок
[47:10.320 --> 47:15.480]  вот этих вот начал, да, там сначала одна строка, потом другая, третья и так далее, и p как раз
[47:15.480 --> 47:20.800]  говорит в каком порядке все эти начала расположены. p 0 это такое число, что вот эта вот строка
[47:20.820 --> 47:28.780]  минимальная, p 1 это вторая в порядке сортировки, p 2 третья и так далее. И тогда вот как раз здесь когда я
[47:28.780 --> 47:33.920]  взял в качестве p 0 минимальную вот этот вот индекс, то чтобы взять минимальный с точки зрения p
[47:33.920 --> 47:37.460]  над нуля, с точки зрения сортировки пар, нужно просто на два в степени k влево прыгнуть,
[47:37.460 --> 47:41.820]  потому что вот эта сортировка как раз пока что игнорирует первые два в степени k символов и
[47:41.820 --> 47:45.540]  сортирует все по вот этой правой половинке, поэтому здесь нужно сделать прыжок на два
[47:45.540 --> 47:51.240]  степенька влево. Вот, а c – это следующее, сит – это
[47:51.240 --> 48:05.720]  номер класса эквивалентности, строки, si, и так далее, si
[48:05.720 --> 48:08.380]  плюс два степенька минус один. То есть я встал в it-ую
[48:08.380 --> 48:11.160]  позицию, прочитал строку для n2-го степенька и сохранил
[48:11.160 --> 48:13.540]  номер класса эквивалентности. Поэтому, когда я здесь
[48:13.540 --> 48:17.740]  пишу c от i в степени 2, от i плюс два степенька, я имею
[48:17.740 --> 48:26.060]  ввиду номер класса эквивалентности вот этой строки. Так, ну что,
[48:26.060 --> 48:30.860]  вот сейчас мы сделали первый из двух шагов сортировки.
[48:30.860 --> 48:32.980]  Напоминаю, сортировка у нас из двух шагов. Сначала
[48:32.980 --> 48:35.540]  по вторым элементам пары, потом по первым. Вот по
[48:35.540 --> 48:37.540]  вторым только что сделал. Тут даже никакой сортировки
[48:37.540 --> 48:40.260]  нет, это просто как бы перенумерация. Вот этот
[48:40.260 --> 48:44.620]  двиг влево на два степенька. Остается сделать стабильную
[48:44.620 --> 48:51.980]  сортировку по первому аргументу. Ну, это мы умеем делать,
[48:51.980 --> 48:57.300]  у меня есть массив, мне нужно сделать сортировку стабильную
[48:57.300 --> 49:00.100]  по нему. Ну, давайте я сделаю обычную стабильную сортировку
[49:01.100 --> 49:13.100]  Я за нулю все, что есть в кнт. Обнулил все содержимое.
[49:13.100 --> 49:21.340]  Дальше проходимся по всей строке. Делаем плюс плюс
[49:21.340 --> 49:28.300]  кнт от ci. Потому что мне нужно сделать сортировку
[49:28.300 --> 49:31.020]  по вот этим штукам по номерам классов. Ну, давайте я для
[49:31.020 --> 49:32.900]  каждого класса посчитаю, сколько раз он встречается.
[49:32.900 --> 49:51.300]  Давайте я здесь напишу. Опять префиксные суммы.
[49:51.300 --> 50:09.900]  Складываем в кнт сумму на префиксе до него. Здесь
[50:09.900 --> 50:13.660]  вроде бы можно писать не больше, чем n, потому что
[50:13.660 --> 50:16.060]  номера классов эквилептности, которые я здесь присваиваю,
[50:16.060 --> 50:18.980]  я уже сказал, что все классы – это гарантированное число
[50:18.980 --> 50:23.260]  от 0 до n-1. Потому что под строк максимум n на каждом
[50:23.260 --> 50:26.420]  шаге, значит, номеров классов тоже достаточно максимум
[50:26.420 --> 50:30.500]  n. Поэтому здесь, когда я делаю переходы, здесь достаточно
[50:30.500 --> 50:34.700]  и рассматривать максимум n-1. В итоге, вроде это правильно.
[50:34.700 --> 50:39.460]  То есть, вот так префиксные суммы я насчитал. А потом
[50:39.460 --> 50:42.980]  нужно расположить их стабильно. То есть, у меня есть некий
[50:42.980 --> 50:47.420]  порядок pn. Это порядок следования элементов. И теперь я должен
[50:47.420 --> 50:51.420]  его переупорядочить стабильно с использованием этой массивы
[50:51.420 --> 50:57.620]  префиксных сумм knt. Ну давайте делать. Я должен пройтись
[51:17.620 --> 51:31.620]  Вот вроде так это будет выглядеть. Ужасно. Значит, еще раз, что
[51:31.620 --> 51:36.340]  тут произошло? pn – это перестановка, которую я должен как бы пересортировать
[51:36.340 --> 51:40.620]  стабильно по какому-то параметру. Поэтому вот здесь вот я
[51:40.620 --> 51:44.780]  иду, у меня здесь всегда внутри pn и, вот оно pn и, вот оно pn и,
[51:44.780 --> 51:48.340]  я иду по массиву pn от и справа налево. То есть, это как бы текущий порядок
[51:48.340 --> 51:51.580]  сортировки. В каком-то порядке у меня все элементы там переставлены. Точнее, вот
[51:51.580 --> 51:55.860]  в порядке вот этой вот сортировки по вторым аргументам. Там находится некий
[51:55.860 --> 52:00.340]  порядок следования всех элементов, какая-то перестановка. Дальше я иду по ней
[52:00.340 --> 52:05.580]  справа налево, узнаю номер класса, узнаю номер класса левой половины, то есть
[52:05.580 --> 52:09.700]  вот как раз вот эту штуку узнаю. Ну а дальше все как обычно. Узнаю, где он,
[52:10.260 --> 52:17.300]  какая позиция ему отведена в перестановке p, это вот этот самый knt, вот c. Он говорит,
[52:17.300 --> 52:21.340]  на какую позицию надо его поставить. В один индексации. Затем делаю минус-минус,
[52:21.340 --> 52:25.180]  чтобы получить ноль индексации и заодно сдвинуть этот самый указатель, сдвинуть
[52:25.180 --> 52:29.620]  корзинку на один влево. И дальше в эту позицию кладут то самое p на ты. То есть, я
[52:29.620 --> 52:33.140]  взял элемент из перестановки, понял на какую позицию надо поставить и туда его
[52:33.140 --> 52:40.100]  поставил. И теперь у меня массив p уже будет хранить правильную перестановку
[52:40.100 --> 52:45.020]  сортировки всех по строкам 2 в степенька плюс 1. То есть, я как бы старый массив p
[52:45.020 --> 52:48.740]  переиспользовал, он мне больше не нужен. Если раньше p это была сортировка всех
[52:48.740 --> 52:53.660]  по строкам 2 в степенька, то теперь p это сортировка всех по строкам 2 в
[52:53.660 --> 52:59.940]  степенька плюс 1. Ну вот вроде все. То есть, по сути, вот эта строка ровно такая же,
[52:59.940 --> 53:05.140]  как была там, только по модулю того, что я сортирую не перестановку 0,1,2 и так далее,
[53:05.140 --> 53:14.020]  n-1, а перестановку p-n. Вот в том же порядке справа налево по ней прохожусь. Так, все,
[53:14.020 --> 53:27.660]  теперь p это нужная сортировка. p искомая сортировка для 2 в степенька плюс 1. Потому что сначала я
[53:27.700 --> 53:32.340]  сортировал по вторым элементам, потом по первым стабильно. Теперь p это то, что нужно. Вот и
[53:32.340 --> 53:42.420]  остается насчитать массив c. Так, как я делаю массив c. Видимо, я завожу вспомогательный,
[53:42.420 --> 53:52.340]  потом перекопирую из него в c. Да, окей. Давайте напишу код, потом мы разберемся,
[53:52.340 --> 53:54.380]  что он делает то, что нужно.
[54:22.340 --> 54:25.260]  Уф!
[55:22.340 --> 55:32.780]  Так, ну здесь ничего хитрого. Значит, мне нужно завести новые классы эквивалентности c,
[55:32.780 --> 55:38.660]  n для всех подстроков длины 2 в степенька плюс 1. Я знаю, что p-0 это самая маленькая подстрока длины
[55:38.660 --> 55:44.180]  2 в степенька плюс 1, поэтому для нее класс это 0. Потом я иду по перестановке p слева направо,
[55:44.180 --> 55:48.820]  в порядке возрастания индексов, и хочу посчитать номер класса эквивалентности для очередной
[55:48.820 --> 55:53.260]  подстроке длины 2 в степенька плюс 1. По умолчанию я считаю, что номер класса такой же,
[55:53.260 --> 55:58.900]  как у предыдущей. То есть, я считаю, что текущая строка равна предыдущей. Но только если номер
[55:58.900 --> 56:03.700]  класса левой половинки у текущей строки не равен номер класса эквивалентности левой половинки
[56:03.700 --> 56:08.900]  прошлой строки, тогда мне нужно увеличить текущий номер класса. То есть, я взял как бы вот,
[56:08.900 --> 56:19.300]  вот у меня есть p, текущая строка, есть p-1, предыдущая строка, состоящая из двух кусков длины
[56:19.300 --> 56:27.260]  2 в степенька, тут 2 в степенька, тут 2 в степенька, здесь и здесь. Если вдруг номер класса t старый,
[56:27.260 --> 56:32.780]  в порядке 2 в степенька, если номер класса эквивалентности этой половинки не равен вот этому,
[56:32.780 --> 56:38.340]  значит вот эта строка и вот это различны, мне нужно увеличить текущий номер класса. То есть,
[56:38.340 --> 56:42.900]  я как бы иду в порядке возрастания по ним, по умолчанию считаю, что они одинаковые, но если вдруг
[56:42.900 --> 56:47.540]  я вижу, что это не равно этому, то я перешел к новой строке, нужно номер класса увеличить. У меня
[56:47.540 --> 56:53.980]  изменился класс эквивалентности. Если же они одинаковые else, вот здесь скажем равенство, но при
[56:53.980 --> 56:59.700]  этом вот здесь вот не равенство, вот это не равно вот этому. Это как раз вот эти штуки, это в точности
[56:59.700 --> 57:06.300]  сравнение класса эквивалентности для вот этих кусков длины 2 в степенька. pt плюс 2 вкатой, это вот оно,
[57:06.300 --> 57:12.140]  и по имени с первой плюс 2 вкатой, это вот оно. Если эти классы различны, значит тоже нужно увеличить
[57:12.140 --> 57:16.500]  номер класса эквивалентности. А если это не выполнено, то получается, что у меня левые куски равны,
[57:16.500 --> 57:25.500]  правые равны, и ничего делать не нужно, и значение по умолчанию верное. Все. В конце я прошел всю
[57:25.500 --> 57:30.860]  перестановку p, посчитал cn как номер класса эквивалентности всех построк новой длины,
[57:30.860 --> 57:39.020]  2 в степени k плюс 1, и чтобы это cn переместить на место c, я делаю мем цп и просто копирую в c
[57:39.020 --> 57:47.940]  содержимое массива cn. Все, теперь вот после вот этих вот, после всего этого безобразия, у меня p и c,
[57:47.940 --> 57:56.300]  это то, что нужно для k плюс первой итерации. То есть это сортировка плюс класса эквивалентности,
[57:56.300 --> 58:15.260]  плюс класса эквивалентности всех построк длины 2 в степени k плюс 1. Что нам собственно и требовалось,
[58:15.260 --> 58:20.580]  мы начали с p и c, которые решали задачу для построка длины 2 в степени k, а теперь после
[58:20.740 --> 58:25.500]  переобразований получили, что в p и c лежат то же самое, только для 2 в степени k плюс 1. Победа.
[58:25.500 --> 58:33.460]  Вот. Ну и все, и таким образом мы делаем вот это вот преобразование столько раз,
[58:33.460 --> 58:38.340]  пока 2 в степени k не станет больше либо равно, чем n, и в конце мы уже говорили, что перестановка p
[58:38.340 --> 58:43.860]  будет совпадать с суффиксным массивом, потому что там вот мы говорили, что если отбросить все,
[58:43.860 --> 58:49.100]  начиная от решетки вправо, то это будет та же самая перестановка суффиксов. Там неравенство будет
[58:49.100 --> 58:58.500]  сохраняться, поэтому то, что у вас будет в конце в массиве p, это и будет суффиксным массивом,
[58:58.500 --> 59:06.220]  это и будет сортировкой всех суффиксов. Все, поэтому алгоритм суффиксного массива мы построили.
[59:06.220 --> 59:20.620]  Так, ну а симптотика понятна какая, давайте фиксируем. А симптотика будет n log n,
[59:20.620 --> 59:28.180]  потому что log итераций и каждый раз это за линейное время, потому что все, что сейчас написано на
[59:28.180 --> 59:33.700]  доске, работает за линейное время. Это просто какие-то форики, перекопирование, зануление
[59:33.700 --> 59:37.580]  содержимого массива, это все за линию работает. И таких итераций всего алгоритм.
[59:46.700 --> 59:57.260]  Так, шикарно. Дальше, чтобы это все как-то использовать, нам нужна еще следующая штука,
[59:57.300 --> 01:00:01.700]  следующая надстройка над этим суффиксным массивом, это так называемый массив lcp.
[01:00:01.700 --> 01:00:14.420]  Массив lcp. Значит, lcp расшифровывается как longest common prefix. Ну и смысл очень простой,
[01:00:14.420 --> 01:00:19.420]  у двух произвольных строк lcp находит длину самого длинного их общего префикса.
[01:00:19.420 --> 01:00:32.660]  Например, если у меня есть какая-нибудь abats и, не знаю, aba-abada, то их lcp равно
[01:00:32.660 --> 01:00:36.340]  трём. Длина наибольшего общего префикса равно тройке, потому что вот она abba,
[01:00:36.340 --> 01:00:42.220]  и дальше продлить ее нельзя. Просто длина наибольшего общего префикса.
[01:00:42.220 --> 01:00:53.140]  Так, давайте я для нашей строки abatsabba восстановлю суффмасс с учетом того,
[01:00:53.140 --> 01:00:54.820]  что в конце у меня еще дописана решетка.
[01:01:12.220 --> 01:01:40.260]  А решетка, точнее abba, решетка, abatsabba, решетка,
[01:01:40.260 --> 01:02:01.020]  вот. После дописывания решетки суффмасс будет выглядеть так. Собственно,
[01:02:01.020 --> 01:02:07.100]  вот массив P после исполнения всех хатератов будет выглядеть ровно вот так. 7, 6, 4, и дальше
[01:02:07.100 --> 01:02:12.780]  вот это вот все содержимое. Если нам нужно получить массив для исходной строки s без решетки,
[01:02:12.780 --> 01:02:16.100]  то мне нужно просто везде эту решетку игнорировать, и эта же самая пересновка
[01:02:16.100 --> 01:02:22.700]  будет суффмассом для исходной строки. Это мы уже обсуждали. Массив lcp делает следующее. Он
[01:02:22.700 --> 01:02:29.300]  для каждой пары соседних строк в этом порядке находит их lcp. То есть для всех соседей в этом
[01:02:29.300 --> 01:02:34.860]  порядке мы подсчитаем длину наибольшего общего префикса. Давайте считать. Здесь 0,
[01:02:34.860 --> 01:02:40.620]  но нет общих символов. Здесь 1, вот она h, только h общего, больше ничего нет. Здесь 3,
[01:02:40.620 --> 01:02:49.260]  да, потому что abba общая, дальше уже не общая. Тут единица, видимо, только a общая, здесь 0,
[01:02:49.260 --> 01:03:00.060]  здесь 2, потому что ba здесь 0. Значит, массив lcp это массив наибольших, точнее длин, наибольших
[01:03:00.060 --> 01:03:14.780]  общих префиксов для всех пар соседей в этом суффмассе. lcp it, lcp it, это длина lcp it,
[01:03:14.780 --> 01:03:32.940]  точнее it и plus первого суффикса в порядке лексиографической сортировки. Я взял два
[01:03:32.940 --> 01:03:37.300]  последовательных суффикса из суффмасса, нашел у них lcp и это положил в lcp it.
[01:03:44.780 --> 01:04:12.780]  Давайте от массива lcp читаем. Пусть у меня уже посчитан массив b, то есть посчитан суффмасс
[01:04:12.780 --> 01:04:17.940]  для всей моей строки abba-tsaba решет. Теперь я хочу как-то быстро, эффективно насчитать
[01:04:17.940 --> 01:04:23.060]  вот эти вот lcp-шки всех пар соседей, наибольшие общие префиксы всех пар соседних строк в этом
[01:04:23.060 --> 01:04:36.740]  порядке. Утверждение. Пусть в какой-то момент времени мы нашли lcp неких двух соседних строк
[01:04:36.740 --> 01:04:45.220]  в нашем суффмассе и этот lcp хотя бы двойка. Пусть вот здесь lcp было хотя бы двойка у двух
[01:04:45.220 --> 01:04:53.860]  соседей. Причем вот эта штука начиналась с позиции и. Вот здесь первый символ в этом суффиксе имел
[01:04:53.860 --> 01:05:02.580]  номер и. Тогда если я отброшу вот этот it из моей первой строки и рассмотрю суффикс, начинающий
[01:05:02.580 --> 01:05:11.500]  с позиции с 1, то его lcp с чуваком, который ниже, будет хотя бы это число минус 1. Давайте
[01:05:11.500 --> 01:05:22.700]  здесь нашу все-таки k. Тогда здесь будет хотя бы k-1. Давайте текстами я это напишу. Пусть
[01:05:22.700 --> 01:05:44.260]  p житое равно i и lcp житое равно k, хотя бы двойка. Пусть p какой-нибудь там s это i плюс 1,
[01:05:44.260 --> 01:05:57.860]  тогда lcp с больше равно, чем камень 1. Что тут написано? Пусть где-то в суффмассе на
[01:05:57.860 --> 01:06:03.700]  каком-то житом месте находится суффикс, начинающий с позиции и. На житом месте была строка и. И здесь
[01:06:03.700 --> 01:06:09.340]  же вот эта lcp, у lcp номерация такая же, как у суффмассива. Пусть здесь lcp было хотя бы два,
[01:06:09.340 --> 01:06:15.900]  равно k, хотя бы двойка. Дальше пусть позиция и плюс один, точнее суффикс начинается в позиции
[01:06:15.900 --> 01:06:21.220]  и плюс один, встречается в моем суффмассе где-то на позиции и. Вот она, строка начинается с и плюс
[01:06:21.220 --> 01:06:27.900]  один, и это какая-то истая позиция. Тогда здесь lcp и, то есть вот это вот lcp, будет хотя бы k-1.
[01:06:27.900 --> 01:06:34.780]  То есть если где-то мы знаем lcp и, то для и плюс один, который находится где-то там в произвольном
[01:06:34.780 --> 01:06:45.700]  месте его суффмасса, lcp будет хотя бы k-1. Так, ну доказательств здесь очень простое. Смотрите,
[01:06:50.380 --> 01:06:59.780]  давайте нарисуем вот эти две строки. У них есть некий общий префикс, длины k. Вот это одинаковое,
[01:06:59.780 --> 01:07:05.820]  вот эти k символов одинаковые. А дальше символ написан вот здесь, вот меньше символ написан вот
[01:07:05.820 --> 01:07:12.580]  здесь. Здесь какой-нибудь x, здесь какой-нибудь y, здесь значок меньше. Потому что это с одной стороны
[01:07:12.580 --> 01:07:17.660]  k это lcp, с другой стороны они отсортированы в порядке возрастания, поэтому первые различные
[01:07:17.660 --> 01:07:24.940]  символы упорядочены ровно так. Раз это строка раньше, значит x меньше чем y. И это был суффикс,
[01:07:24.940 --> 01:07:30.300]  начинающийся с позиции и. Если я отбрасываю первый символ вот здесь вот, и перехожу к суффиксу,
[01:07:30.300 --> 01:07:39.620]  который начинается с и плюс один, я отбросил первый этот символ и. Дальше у меня понятное дело,
[01:07:39.620 --> 01:07:46.660]  что вот эти вот первые там k-1 символ будут такими же. Вот эти вот k-1 такие же, как здесь k-1,
[01:07:46.660 --> 01:07:56.700]  потому что один символ откусил. Дальше идет x. Если я выполню самое вот с этой строкой, отброшу
[01:07:56.700 --> 01:08:01.900]  первый символ, то у меня тоже самое. У меня опять будет вот эти вот k-1 символ, такой же как здесь,
[01:08:01.900 --> 01:08:08.580]  потом y, больше чем x. Поэтому вот эта строка, получается отбрасыванием первого символа из
[01:08:08.580 --> 01:08:14.540]  этой строки, идет точно в суффмассе где-то ниже, чем вот это. То есть давайте я нарисую стрелку,
[01:08:14.940 --> 01:08:19.460]  после отбрасывания первого символа переход сюда, а это после отбрасывания первого символа вот
[01:08:19.460 --> 01:08:25.300]  туда. Потому что здесь идет вот те же самые k-1 символ, потом символ y, который заведомо больше
[01:08:25.300 --> 01:08:30.700]  чем x. Поэтому это больше чем это, гарантированно. Но возможно кто-то между ними еще вклеился,
[01:08:30.700 --> 01:08:37.420]  а в принципе такое может быть. Никто не говорит, что здесь обязательно никого не
[01:08:37.420 --> 01:08:44.420]  появляется. Вполне возможно, что здесь кто-то другой встревает. Отсюда уже очень легко
[01:08:44.420 --> 01:08:52.220]  заключить, что lcp, то есть смотрите, мы знаем, что lcp вот этих двух, ровно k-1. Потому что было k,
[01:08:52.220 --> 01:08:58.860]  я отбросил первый символ, стало k-1, а следующий уже точно различен. То есть вот здесь будет
[01:08:58.860 --> 01:09:06.140]  k-1 общий символ, здесь будет y. Между ними lcp ровно k-1. Но тогда понятно, что между каждыми
[01:09:06.140 --> 01:09:18.100]  соседями в этой отрезке lcp будет хотя бы k-1. Потому что если хоть где-то lcp меньше,
[01:09:18.100 --> 01:09:25.900]  чем k-1, то значит общие символы там, не знаю, пусть например lcp это k-2. Когда вот здесь k-2 общие,
[01:09:25.900 --> 01:09:32.460]  а здесь будут разные, там k-1 символ будут различны. Но извините, вот здесь вот k-1 символ
[01:09:32.460 --> 01:09:37.140]  совпадали вот с этим, то все, что между ними, строчки больше, чем это, но меньше это, они должны
[01:09:37.140 --> 01:09:42.780]  конечно же такой же общий префикс иметь lcp ровно k-1. Поэтому никаких различий в позициях с номерами
[01:09:42.780 --> 01:09:48.220]  k-1 быть не может. Значит, все, что было здесь по дороге, они имели все тот же префикс длины k-1.
[01:09:48.220 --> 01:09:56.900]  А значит, это lcp наследуется здесь в этой отрезке длины хотя бы k-1. Оно будет здесь везде. Вот,
[01:09:56.900 --> 01:10:11.340]  ну как мог, обрисовал. Поэтому алгоритм будет следующий, очень простой, ну в плане. Нельзя,
[01:10:11.340 --> 01:10:15.620]  потому что сюда мог кто-то встрять. Вот здесь вот вполне возможно могут быть какие-то строчки,
[01:10:15.620 --> 01:10:24.100]  между ними. И поэтому здесь, да, между этой и этой k-1, но между этой и следующей вполне возможно
[01:10:24.100 --> 01:10:43.420]  больше, чем k-1. Значит, алгоритм будет следующий. Сначала заводим k равно нулю. Так, да. Нет,
[01:10:43.420 --> 01:10:49.740]  perdон. Значит, сначала, чтобы вот с этими индексами будет большая запара, да, вот это gs,
[01:10:49.740 --> 01:10:55.180]  мне нужен массив обратный к массиву p. То есть, p это у меня сейчас перестановка всех в каком-то
[01:10:55.180 --> 01:10:59.820]  порядке. А чтобы, наоборот, чтобы по i, чтобы по суффиксу, по нему позицию в суффмассе,
[01:10:59.820 --> 01:11:05.940]  мне нужен вот этот обратный массив. Значит, это будет у меня pos. pos это массив обратный к
[01:11:05.940 --> 01:11:20.260]  суффиксному. Массив обратный p. Находится он просто. Находится он очень просто. pos от p от i равно
[01:11:20.260 --> 01:11:45.500]  i. Просто обратная перестановка. Значит, дальше. Я буду идти по всем порядке убывания длины. То есть,
[01:11:45.500 --> 01:11:50.140]  первый суффикс, который я рассматриваю, длину полную, да, начиная с позиции 0, потом с позиции
[01:11:50.140 --> 01:11:57.380]  1 и так далее. Значит, первым делом вот я вижу, что при переходе вот i плюс 1 у меня текущая lcp
[01:11:57.380 --> 01:12:03.260]  может уменьшиться максимум на 1. Поэтому тут я пишу такую строчку. k равно максимум из k-1 и нуля.
[01:12:03.260 --> 01:12:11.540]  Если k это найденная lcp на предыдущем шаге, то при переходе к i плюс 1 может в худшем случае
[01:12:11.540 --> 01:12:20.340]  упасть максимум на 1, но при этом, конечно, не может быть. Вот. Ну и дальше я делаю следующее.
[01:12:20.340 --> 01:12:34.940]  Если pos it равно чему-то, видимо, n-1, тогда continue. Да, если текущий рассматриваемый суффикс,
[01:12:34.940 --> 01:12:38.740]  максимальный вообще во всем суффмассе. То есть, если его позиция в вхождении в суффмасс,
[01:12:38.740 --> 01:12:45.620]  это n-1. То есть это максимальный суффикс. У меня не с кем брать lcp, потому что я беру lcp текущего
[01:12:45.620 --> 01:12:50.500]  со следующим, да. Следующего за этим, за последним нету, поэтому я просто его игнорирую. lcp здесь
[01:12:50.500 --> 01:12:58.260]  не будет разделён. В этом случае делаю continue. А иначе, значит, я завожу j. Ну давайте, ну да,
[01:12:58.260 --> 01:13:07.660]  пусть будет j. Это тот чувак, который сразу под ним идёт. То есть, pos i плюс 1. Потому что pos i — это
[01:13:07.660 --> 01:13:15.580]  та позиция, где находится i, а j — это, соответственно, что находится прямо под ним. Вот здесь будет i, а здесь
[01:13:15.580 --> 01:13:22.340]  будет j сразу под ним. И я знаю, что у текущих двух строк, по крайней мере, первые k символов точно
[01:13:22.340 --> 01:13:30.260]  одинаковы. Из-за вот этого перехода точно первые k символов одинаковы. Возможно, кто-то ещё. Но
[01:13:30.260 --> 01:13:36.780]  вот давайте, пока следующие символы одинаковы, я буду увеличивать k. Прям так и напишем. Пока
[01:13:36.780 --> 01:13:46.780]  s и плюс k равно s g плюс k. Ну, там надо ещё добавить проверку, пока мы не вышли за пределы строки,
[01:13:46.780 --> 01:13:52.940]  но мне лень это делать. Я делаю плюс плюс k. Пока вот эти символы одинаковы, я просто увеличиваю
[01:13:52.940 --> 01:14:03.380]  текущую длину lcp. Ну и в конце пишу lcp pos it равно k. Конец.
[01:14:03.380 --> 01:14:22.260]  Вот, значит, что я сделал. По сути, здесь просто как бы вот, ну, как у нас недавно было с z функцией,
[01:14:22.260 --> 01:14:29.300]  мы точно знаем, что ответ хотя бы такой, а дальше я его просто купую и перебираю. Пока тут равенство,
[01:14:29.300 --> 01:14:33.340]  я увеличиваю k. Так же, как было с z функцией. Я точно знаю, что ответ, по крайней мере, такой,
[01:14:33.340 --> 01:14:38.500]  а следующий символ, если одинаковый, то я просто наивно расширяю текущую k. Пока здесь равенство,
[01:14:38.500 --> 01:14:46.940]  я увеличу эту границу. Вот, while. И в конце в lcp создает то самое k. А симптотика здесь будет тем
[01:14:46.940 --> 01:14:53.260]  же причинам линейная, потому что понятно, что вся трудность только в цикле while, но основная
[01:14:53.260 --> 01:14:57.380]  сложность только в цикле while, всё, понятно дело, за линейное время работает. Но каждый трансвит
[01:14:57.380 --> 01:15:03.380]  цикловал увеличивает k на 1, при этом k уменьшается на 1 всего один раз для каждого i. Значит,
[01:15:03.380 --> 01:15:09.740]  уменьшение k будет максимум n, поэтому увеличение будет 2n, поскольку k ограничено точно mk.
[01:15:09.740 --> 01:15:27.900]  Значит, время работы будет линейное. Норм? Не норм? Вопрос, может?
[01:15:39.740 --> 01:15:47.780]  Нет, это скорее, ну, можно считать, что это часть алгоритма, да, но по сути, это как бы два
[01:15:47.780 --> 01:15:52.740]  независимых алгоритма, потому что мы сначала построили sufmas, потом на его основе построили
[01:15:52.740 --> 01:15:58.540]  массив lcp. Ну, причем здесь не столько используется там алгоритм, сколько мне нужно просто знать
[01:15:58.540 --> 01:16:04.980]  все и вот обратно к нему pos. То есть, зная sufmas, мы можем поставить массив lcp, но пока это не
[01:16:04.980 --> 01:16:28.620]  применение еще. Вот применение сейчас будет. 10 минут. Так, да, хорошо. Значит, ну, применение тут такие.
[01:16:28.620 --> 01:16:52.580]  Да, значит, первое это lcp двух подстрок. Есть строка s, запросы вида там l1, r1, l2, r2. Какие-то две
[01:16:52.660 --> 01:17:03.100]  подстроки мне выделяют в моей строке. Мне нужно узнать у них lcp, ну, точнее длину lcp. Делаю следующим
[01:17:03.100 --> 01:17:09.620]  образом. Я нахожу, где в моем суфиксном массиве включается суфикс, начинающий с l1, и где суфикс,
[01:17:09.620 --> 01:17:19.380]  начинающий с l2. Вот давайте их как-то нарисую. Вот он где-то l1, вот он где-то l2. Между ними там
[01:17:19.380 --> 01:17:23.940]  может быть какое-то произвольное количество других суффиксов. Я утверждаю, что чтобы найти
[01:17:23.940 --> 01:17:31.620]  lcp двух вот этих суффиксов, мне нужно взять минимум на отрезке lcp в этом массиве. То есть,
[01:17:31.620 --> 01:17:37.020]  если я знаю lcp для всех соседей, то lcp для двух произвольных суффиксов это просто минимум на
[01:17:37.020 --> 01:17:44.940]  отрезке. Давайте примерно нарисуем вот здесь вот скажем. Вот надо мне найти lcp вот этого чувака
[01:17:44.940 --> 01:17:54.260]  и вот этого. Тогда я беру минимум из двух чисел единиц и тройки, потому что единица это lcp вот этого
[01:17:54.260 --> 01:18:00.020]  и вот этого, а тройка это lcp вот этого и вот этого. Из них минимально это единица. Как видим совпало,
[01:18:00.020 --> 01:18:09.620]  lcp у них равно единице. В общем случае, есть два суффикса, давайте нарисую что-нибудь вот такое.
[01:18:09.620 --> 01:18:17.940]  Есть два суффикса и я знаю lcp на всем отрезке между ними. То есть, я знаю lcp вот здесь,
[01:18:17.940 --> 01:18:22.980]  lcp вот здесь, lcp вот здесь, lcp вот здесь. Тогда lcp вот этих двух крайних это минимум на отрезке.
[01:18:22.980 --> 01:18:33.460]  Ну почему? Давайте как-нибудь это все пронумеруем, не знаю, x1, и далее xm. Пусть k это минимальный из
[01:18:33.460 --> 01:18:43.500]  x. Значит, во-первых, если k это минимум среди всех значений lcp, то гарантированно к символов во
[01:18:43.500 --> 01:18:50.820]  всех этих суффиксах одинаковые. Вот начало длины k у них у всех одинаковое. Потому что если k это
[01:18:50.820 --> 01:18:59.300]  минимум среди всех x, то значит все x больше равны чем k, а значит у любых двух соседей lcp хотя бы k.
[01:18:59.300 --> 01:19:05.980]  Значит, просто вот эти первые k символов перекочевали, они равны, эти первые k символов равны вот этим k,
[01:19:05.980 --> 01:19:11.220]  эти символы равны вот этим k, ну и так далее. Поэтому если k это минимум среди всех на отрезке,
[01:19:11.220 --> 01:19:17.180]  то значит первые k символов точно уже одинаковые у них у всех. У двух крайних одинаковые. Ну и у всех
[01:19:17.180 --> 01:19:25.900]  посередине тоже. Согласны? Вот почему k плюс первый нельзя взять? То есть мы поняли, что первые
[01:19:25.900 --> 01:19:30.860]  k символов точно одинаковые, почему k плюс один не одинаковые? Ну если бы не были одинаковые,
[01:19:30.860 --> 01:19:37.660]  вот скажем, этот символ равен вот этому. Давайте какой-нибудь c и c. Пусть они одинаковые. Но тогда
[01:19:37.660 --> 01:19:43.140]  из-за того, что эти строки расположены между ними, здесь тоже должны быть везде символы c. Потому что
[01:19:43.140 --> 01:19:48.060]  с одной стороны вот эта строка больше собрана чем это, с другой стороны меньше собрана чем это.
[01:19:48.060 --> 01:19:52.980]  Поэтому никакой другой символ отличный от c здесь не может. Если здесь какой-нибудь d, то значит
[01:19:52.980 --> 01:19:58.180]  здесь вот противоречие это с этим. Если тут a, то здесь противоречие это с этим. Поэтому единственный
[01:19:58.180 --> 01:20:03.860]  способ сделать так, чтобы здесь строка была между ними двумя, это обязательно здесь c. И между ними
[01:20:03.860 --> 01:20:12.500]  всеми тоже будет c. Поэтому если k плюс первые символы у крайних строк тоже равны, то и между
[01:20:12.500 --> 01:20:18.260]  ними всеми, то есть на всем этом строке тоже должно быть c на k плюс первой позиции. А значит,
[01:20:18.340 --> 01:20:23.420]  тогда минимум должен быть не k, а k плюс один, потому что у них не просто к символов совпадает,
[01:20:23.420 --> 01:20:28.380]  но и k плюс один тоже везде совпадает. Поэтому тогда k это не правильный минимум, на самом деле
[01:20:28.380 --> 01:20:35.980]  k плюс один был бы правильный минимум противоречия. Давайте еще раз утверждение напишу это.
[01:20:48.260 --> 01:21:07.300]  Так пусть pos l меньше pos l тогда длина наибольшего общего префикса, суффиксы начинаются с l этой
[01:21:07.300 --> 01:21:20.060]  позиции и суффиксы начинаются с r этой позиции. Это в то же время минимум среди всех l на отрезке
[01:21:20.060 --> 01:21:46.900]  от pos l до pos r минус 1. pos l это позиция, где встречается суффикс, начинающийся с позиции l. pos r это
[01:21:46.900 --> 01:21:51.180]  позиция, где встречается суффикс, начинающийся с позиции r. Ну и здесь я вычислил ничку, потому что,
[01:21:51.180 --> 01:21:59.380]  ну давайте вернемся сюда. Вот оно, да, вот здесь написано будет lcp там pos l, то есть вот это вот
[01:21:59.380 --> 01:22:05.700]  это lcp pos l того со следующим, а это lcp pos r минус 1 со следующим, то есть pos r. Мне не нужно
[01:22:05.700 --> 01:22:10.060]  брать вот этот pos r, lcp не нужно закончиться на предыдущем, потому что вниз идти не нужно,
[01:22:10.060 --> 01:22:15.140]  этого с последующим брать не нужно. Поэтому ровно на таком отрезке нужно взять lcp,
[01:22:15.140 --> 01:22:21.620]  а минимум, sorry, на таком отрезке массива lcp нужно взять. Вот, но чтобы его находить,
[01:22:21.620 --> 01:22:27.460]  мне достаточно начислять спарстейбу. Чтобы находить минимум на отрезке,
[01:22:27.460 --> 01:22:35.460]  достаточно построить спарстейбу.
[01:22:48.700 --> 01:22:54.700]  Не надо, потому что у меня есть некий фиксированный lcp, я могу за n log n насчитать, ну как бы строить
[01:22:54.700 --> 01:22:59.020]  структуру, которая потом за единицу позволит мне находить минимум на отрезке. Ну вот, собственно,
[01:22:59.020 --> 01:23:07.340]  здесь оно и используется, за единицу мы находим минимум на отрезке. Вот, значит, если мы научились
[01:23:07.340 --> 01:23:13.700]  находить lcp любых двух суффиксов, скажем, вот это вот мы знаем, что lcp, тогда lcp любых двух подстрок,
[01:23:13.700 --> 01:23:20.380]  это ну реально насчитывается, нужно просто обрубить наши суффиксы до вот тех позиций, которые, в общем,
[01:23:20.380 --> 01:23:24.540]  которые мы рассматриваем. То есть, если lcp вдруг вылезает за пределы рассматриваемой строки,
[01:23:24.540 --> 01:23:39.180]  то нужно lcp уменьшить до длинной строки. Вот и все. То есть, когда я посчитал lcp двух суффиксов,
[01:23:39.180 --> 01:23:46.860]  чтобы посчитать lcp двух подстрок, мне нужно его уменьшить до длин обеих строк, чтобы он был
[01:23:46.860 --> 01:24:00.260]  не больше, чем длинный обеих подстрок. Вот так. Вот все. Присвоить. Вот это мы решили задачу
[01:24:00.260 --> 01:24:05.620]  нахождения lcp двух произвольных подстрок. Вторая задача, немедленно вытекающая из этой,
[01:24:05.620 --> 01:24:20.060]  это верка равенства двух подстрок. То же самое с некой фиксированной длинной строка s,
[01:24:20.060 --> 01:24:27.660]  вам дают ее какие-то кусочка с l1pr1 и с l2pr2, спрашивают, правда ли, что они равны,
[01:24:27.660 --> 01:24:33.020]  как подстроки, правда ли, что это равные подстроки. Решается очень просто. Ну,
[01:24:33.020 --> 01:24:40.300]  во-первых, мы проверяем, что у них одинаковые длины. Во-вторых, мы проверяем, что lcp этих
[01:24:40.300 --> 01:24:52.340]  двух подстрок в точности равны линии произвольной из них. Если lcp равно, то значит,
[01:24:52.340 --> 01:25:03.180]  просто вот эти символы работают этим. И все. Вот. Заметьте, что это мы решили решение задачи,
[01:25:03.180 --> 01:25:07.760]  которые осматривали на первой лекции, которые мы решали через хэши. Чтобы проверить равенство
[01:25:07.760 --> 01:25:12.500]  двух подстрок, мы считали хэш их обеих, проверяли их на равенство. И там с небольшой вероятностью мы
[01:25:12.500 --> 01:25:16.460]  могли ошибаться. А здесь детенцированный алгоритм, который, да, чуть дольше работает,
[01:25:16.460 --> 01:25:21.220]  потому что это n-лугена, там было oatn. Ну окей, чуть дольше работает, но зато никогда не ошибается,
[01:25:21.220 --> 01:25:25.140]  всегда воздушает правильно. Вот. Все, спасибо.
