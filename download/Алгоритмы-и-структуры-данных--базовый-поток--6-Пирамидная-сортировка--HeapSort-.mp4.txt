[00:00.000 --> 00:10.920]  сегодня у нас будет давайте поменяю еще так вот так лучше сегодня у нас будет с вами завершающая
[00:10.920 --> 00:18.760]  тема по сортировкам в каком-то виде мы больше на них останавливаться не будем мы наконец сегодня
[00:18.760 --> 00:25.160]  поговорим о последний из них который мы должны разобрать в нашем курсе и как раз таки постараемся
[00:25.160 --> 00:34.840]  с ней понять что это такое что называется пирамидальные и что там происходит вот кто
[00:34.840 --> 00:43.440]  не знаком с такой сортировкой ура это для всех что-то новое это хорошо потому что quicksort
[00:43.440 --> 00:50.400]  обычно знаком mordsort тоже пирамидальная не всегда вот хотя сортировка достаточно забавная и
[00:50.400 --> 00:59.520]  интересная в том плане за счет чего она построена и первое что там есть ну как бы это что вообще такое
[00:59.520 --> 01:08.280]  пирамида смотрите пирамида вот здесь вот так сказано это пасть это объект массив во первых
[01:08.280 --> 01:15.280]  который можно рассматривать почти как почти полное бинарное дерево у кого-то видимо закончился
[01:15.280 --> 01:29.120]  семинар или я не знаю да вот понял так вот в общем-то здесь так написано объект массив который
[01:29.120 --> 01:36.400]  можно рассматривать как бинарное дерево смотрите само по себе бинарное дерево это один из вопросов
[01:36.400 --> 01:43.680]  того вообще что это такое и как это выглядит мы с вами проговорим про бинарные деревья попозже
[01:43.680 --> 01:50.320]  пока все что вам нужно знать про бинарные деревья это то что у этого дерева есть корень и у всех его
[01:50.320 --> 01:59.240]  вершин есть не более двух детей то есть если рассматривать именно бинарные деревья то
[01:59.240 --> 02:08.520]  можно называется бинарная потому что би-2 вот можно вот так вот сделать можно здесь вообще
[02:09.320 --> 02:15.820]  это будет бинарным деревом но это не является пирамиды что такое почти полная пирамида с точки
[02:15.820 --> 02:20.760]  зрения ой после полная бинарные дерева с точки зрения пирамида если мы с вами
[02:20.760 --> 02:27.080]  возьмем пирамидку то есть почти винарное дерево какое-нибудь если у него заполнены
[02:27.080 --> 02:37.420]  в те слои кроме быть может последнего и последний должен быть заполнен слева направо полностью то
[02:37.420 --> 02:41.880]  то есть вот это является пирамидой если я добавлю вот так элемент это тоже
[02:41.880 --> 02:48.280]  будет являться пирамидой но если вдруг я возьму и уберу здесь левого сына а
[02:48.280 --> 02:53.960]  скажу что у меня будет правой то это уже не является пирамидой понятно сейчас
[02:53.960 --> 02:56.440]  что было
[02:59.400 --> 03:05.200]  хорошо давайте еще раз а когда мы говорим с вами о пирамиде мы с вами
[03:05.200 --> 03:09.900]  говорим о бинарных деревьев понятно что такое бинарное дерево пока не больше
[03:09.900 --> 03:15.020]  двух детей хорошо бинарное дерево это такое
[03:15.020 --> 03:23.060]  такая некоторая сущность где у нас есть корень вот это и у каждой из вершин
[03:23.060 --> 03:31.100]  не более чем двое детей и все что подвластно этому принципу это является
[03:31.100 --> 03:35.740]  бинарным деревом существует различные виды бинарных деревьев бинарные деревья
[03:35.740 --> 03:39.900]  поиска пирамиды и так далее они все обладают каким-то определенным
[03:39.900 --> 03:44.420]  свойствам которые необходимы но сама бина само бинарное дерево оно любого
[03:44.420 --> 03:52.320]  такого вида даже вот это является бинарным деревом
[03:53.020 --> 03:57.980]  но у меня есть корень и у каждого не более одного у не более двух детей
[03:57.980 --> 04:05.580]  понятно вот а если же мы с вами говорим про пирамиду то это почти полное бинарное
[04:05.580 --> 04:10.900]  дерево почти полное будет означать здесь в этом контексте что у нас заполнены все
[04:10.900 --> 04:18.300]  уровни этой пирамиды кроме быть может последнего то есть мы не можем сделать
[04:18.300 --> 04:22.740]  вот так если мы не заполнили предыдущий уровень нас такого здесь
[04:22.740 --> 04:29.340]  невозможно это раз а во-вторых последний уровень должен быть заполнен полностью
[04:29.340 --> 04:35.460]  слева направо то есть не может быть такого вот если это пирамида то я к
[04:35.460 --> 04:39.700]  примеру уберу отсюда вершину скажу что она у меня будет здесь нет мне сначала
[04:39.700 --> 04:50.580]  должна быть вершинка здесь теперь стал понятнее всем хорошо вот то есть вот
[04:50.580 --> 04:57.020]  такое называется пирамида и почему это называется объект массивом типа почему
[04:57.020 --> 05:04.940]  с чего бы а в действительности пирамида это такой такой приятный объект который
[05:04.940 --> 05:12.900]  можно перекладывать с точки зрения пирамидки а на массивы и так далее причем важное
[05:12.900 --> 05:21.540]  свойство пирамида если это пирамида по максимуму как в этом примере что родитель всегда больше
[05:21.540 --> 05:27.500]  своих детей вот это будет означать что это пирамида по максимуму если всегда меньше то
[05:27.500 --> 05:36.220]  пирамид по минимуму ничего сложного здесь окей а давайте напишем какие-нибудь чиселки скажем
[05:36.220 --> 05:42.660]  что вот у нас такая пирамида как это переложить массив ну давайте здесь возьмем там 10 9
[05:42.660 --> 06:00.220]  8 7 6 4 да пирамида и куча это одно и то же но я предпочитаю все-таки пирамида потому
[06:00.220 --> 06:06.980]  что она слово hip вот и все это в англоязычной литературе все-таки хип у нас применяется
[06:06.980 --> 06:11.900]  вот таком виде а куча больше применима к динамической памяти потому что динамическую
[06:11.900 --> 06:18.460]  память тоже периодически называют кучей может быть путаница здесь я предпочитаю слово пирамид вот
[06:18.460 --> 06:24.740]  смотрите здесь все выполняет тому свойству что у нас каждый из родителей больше чем его дети
[06:24.740 --> 06:33.580]  равно быть равно может здесь у нас нет такой категоричности я просто показываю на таком
[06:33.580 --> 06:40.980]  примере вот у нас вот такая вот есть пирамидка нужно что-то делать и как-то ее перевести в
[06:40.980 --> 06:47.380]  понятный нам вид с точки зрения языка программирования то есть понять как это
[06:47.380 --> 06:53.740]  вообще легко перевести сделать как это можно сделать а это делается достаточно просто вы
[06:53.740 --> 07:03.220]  должны заполнять массив идя по уровням сверху вниз и слева направо что это означает здесь это
[07:03.220 --> 07:13.260]  означает здесь следующее что вы можете взять сначала 10 потом 9 потом 8 7 6 и 4
[07:13.260 --> 07:27.700]  10 9 8 7 6 4 вот в таком порядке можно перекидывать эту пирамиду вообще с пирамиды связано
[07:27.700 --> 07:35.100]  достаточно много интересных вещей на тему того что типа ее применение с точки зрения сортировки
[07:35.100 --> 07:46.740]  вот вам очевидно но на самом деле она удобно и периодически бывают такие структуры что вам
[07:46.740 --> 07:52.740]  нужно вставить там куда-то в середину какие-то элементы в массиве и для того чтобы это делать
[07:52.740 --> 07:58.500]  быстро это удобно использовать здесь пирамиду на самом чтобы сохранялось какое-то определенное
[07:58.500 --> 08:07.060]  свойство а потому что здесь мы как бы говорим с вами про больше меньше но больше и меньше может
[08:07.060 --> 08:13.860]  быть по любому признаку из объектов только обязательно по числу который там стоит может
[08:13.860 --> 08:19.500]  быть именно по ключу может быть еще что-то на самом деле здесь много разных применений вы еще
[08:19.500 --> 08:28.080]  увидите применение пирамиды с точки зрения так называемой очереди с приоритетами с декартовым
[08:28.080 --> 08:35.220]  деревом вот все это там будет применяться поэтому это такой важный объект на самом деле но первое
[08:35.220 --> 08:41.340]  где мы рассмотрим это сортировки самое понятное самое простое что происходит с ней вот пока
[08:41.340 --> 08:56.420]  понятно что я сделал да 7 и 8 да что нет да мне никто не запрещает здесь поставить
[08:56.420 --> 09:15.020]  семья здесь поставить 8 мысля родитель больше детей все нет конечно конечно будет наоборот здесь
[09:15.020 --> 09:31.740]  у нас главное свойство оно одно что родитель больше максимум за единичку ну как извлекаем ну
[09:31.740 --> 09:40.020]  так ну ну да тут примерно в этом на самом деле и мы к этому придем но по чуть-чуть вот у нас
[09:40.020 --> 09:47.220]  есть такая пирамидка классно прикольно что с ней делать непонятно в принципе вы часто будете с
[09:47.220 --> 09:53.740]  таким сталкиваться на самом деле поэтому нужно понять что вообще с ней делать пирамиды бывают
[09:53.740 --> 09:58.180]  не только по максимум бывает по минимуму то есть можно развернуть эту пирамидку и сделать так
[09:58.180 --> 10:15.340]  что сверху минимум но я буду рассматривать с максимум просто для удобства мне да нет но здесь
[10:15.340 --> 10:24.300]  их нельзя поменять местами потому что 8 иначе мы нарушим да ну смотрите можно пирамиду сделать
[10:24.300 --> 10:43.180]  примерно следующую не знаю там давайте 15 а 4 13 0 2 им могу здесь еще сделать 7 здесь давайте там
[10:43.180 --> 10:53.260]  не знаю 11 здесь там минус 1 пирамида пирамида что еще раз
[10:57.260 --> 11:07.660]  да нет смотрите дети справа здесь они меньше а дети справа здесь больше получается разной
[11:08.100 --> 11:19.260]  но именно так просто взяли да повернули нет в действительности здесь неважно как это дети
[11:19.260 --> 11:24.340]  располагаются между собой нас вообще это не интересует нас интересует одно лишь
[11:24.340 --> 11:33.780]  свойство от родитель всегда больше чем его дети все и вот вопрос когда я перевел вот это вот
[11:33.780 --> 11:46.540]  эту пирамидку к примеру а к массиву давайте расставим индексы в этом массиве 0 1 2 3 4 5 скажите
[11:46.540 --> 11:53.380]  кто-нибудь видеть закономерность точки того как связаны дети с родителем по индексам могу ли
[11:53.380 --> 12:03.300]  я понять что является из этого ну вот то есть вот у 8 понять что девятка его родители нет
[12:03.300 --> 12:27.820]  так и что делать и что делать не а как нет но это перебор тогда мы тогда было долго
[12:27.820 --> 12:34.700]  не интересно рассказывать вот ну как интересно но долго вот что-нибудь полегче да пробуйте
[12:34.700 --> 12:47.900]  понять закономерно давайте я расставлю 0 1 2 3 4 5 а ну давайте даже продолжу у меня будет здесь
[12:47.900 --> 12:56.900]  какой-нибудь 6 здесь седьмой нет мы хотим по индексу понять кто родитель а кто ребенок
[12:56.900 --> 13:16.780]  смысле 3 7 минус 3 4 индекс седьмое здесь 3 минус 1 нацело на 2 это что будет означать
[13:16.780 --> 13:25.700]  индекс родителя да первое что вы должны были заметить что если у нас есть индекс то его
[13:25.700 --> 13:46.820]  родителям этого индекса будет индекс минус 1 пополам у этого 7 минус 1 3 6 поделить на 2
[13:46.820 --> 13:53.000]  не договорил вот если я взял бы здесь восьмой какой-нибудь элементик тогда 8 минус 1 это 7 7
[13:53.040 --> 14:03.200]  численно на 2 3 и так далее тут для всего бы так получилось то и смотрите первое что я легко
[14:03.200 --> 14:10.280]  заметил что я теперь могу легко определить родителя и получил такую взаимосвязь вопрос
[14:10.280 --> 14:18.840]  а теперь у меня есть индекс я хочу получить левого ребенка у меня есть индекс я хочу получить
[14:18.840 --> 14:33.720]  правого ребенка что делать дам здесь это у меня будет двоим плюс один а здесь будет двоим
[14:33.720 --> 14:41.880]  плюс два а если бы мы рассматривали своими массивы в которых начинается все с единички
[14:41.880 --> 14:49.320]  но здесь был бы может попроще и пополам 2 и 2 и плюс 1 но сути не изменилось ничего не изменилось
[14:49.320 --> 14:59.440]  и в действительности взаимосвязь с родителями важна с родителями с детьми и так далее помните
[14:59.440 --> 15:10.720]  об этом вот это всегда важно это всегда нужно в том числе и здесь а кроме того а интересный
[15:10.720 --> 15:17.160]  факт так как это почти полное бинарное дерево и у него заполнены все уровни кроме быть может
[15:17.160 --> 15:23.760]  последнего то его высота всегда тета от логарифма потому что у нас всегда на степени ну степень
[15:23.760 --> 15:33.040]  двойки присутствует понятно это почему вот это все достаточно просто пока ясно откуда все взялось
[15:33.040 --> 15:42.400]  посмотрели поняли отлично а я иногда да буду так пролистывать небольшие спойлеры а потом
[15:42.400 --> 15:48.280]  заново возвращаться всякий случай чтобы они вам ничего не забыл хорошо вот мы с вами это все
[15:48.280 --> 15:57.800]  получили а что же нам вообще с этим делать а для того чтобы перейти к тому мы же как-то должны
[15:57.800 --> 16:02.760]  получить пирамиду вот у нас есть какой-то массив данных мы должны как-то получить эту пирамиду
[16:02.760 --> 16:07.680]  должны что-то с ней сделать мы должны с вами понять а как вообще можно восстанавливать
[16:07.680 --> 16:13.640]  свойства и вот то что я сейчас находил вот эти взаимосвязи поможет нам восстанавливать
[16:13.640 --> 16:18.920]  те самые свойства и первое свойство следующее представьте у меня есть какая-то пирамида
[16:18.920 --> 16:33.720]  ну давайте опять возьму там 15 не знаю 11 10 105 скажу что слева меньше давай что-нибудь придумаем
[16:33.720 --> 16:48.040]  здесь а 9 8 а нет нет ладно хорошо тогда наоборот здесь 6 5 9 8 вот так вот сделаем
[16:48.040 --> 16:57.920]  что пока подходит что вы смеете почему здесь этот больше этого здесь это и больше этих
[16:57.920 --> 17:22.400]  я вас понял пусть будет так здесь 2 4 например здесь 0 1 здесь давайте возьмем не знаю там
[17:22.960 --> 17:31.480]  3 например так вот я хочу сделать таким вот образом представьте следующую картину какой-то
[17:31.480 --> 17:45.200]  момент а я осознаю что вот это 11 мне не надо просто не хочу и беру из меня его 11 на к примеру
[17:45.200 --> 17:59.400]  минус 1 видите у меня нарушилось свойство пирамида я хочу его восстановить что мне с этим делать
[18:02.400 --> 18:12.680]  нет здесь не севтап здесь вот правильная мысль смотрите я в начале должен поменять с кем-то из
[18:12.680 --> 18:20.680]  детей для того чтобы причем с максимальным из них для того чтобы сохранилось свойство то есть
[18:20.680 --> 18:26.320]  если я поставлю сюда пятерку у меня все также будет грустно но если я поставлю сюда шестерку
[18:26.320 --> 18:34.720]  то шестерка больше чем 5 и все хорошо поэтому я попытаюсь поменять это такими местами получаю
[18:34.720 --> 18:41.960]  с вами 15 давайте только ту ветки напишу но помните что есть другая ветка хорошо просто для
[18:41.960 --> 18:50.920]  экономии времени я получу с вами 15 6 здесь минус 1 здесь 2 4 ну и так далее здесь что-то еще существует
[18:50.920 --> 18:58.460]  у меня все еще нарушено это правило то есть я опять должен посмотреть на его детей выбрать
[18:58.460 --> 19:05.320]  максимальный и поднять его наверх то есть вот здесь получить 4 и тогда после всех этих
[19:05.320 --> 19:27.000]  манипуляций я с вами получу такую пирамиду 15 6 10 здесь у меня будет 4 2 минус 1 5 0 1 10 8 9 3
[19:27.000 --> 19:38.360]  я восстановил свойство пирамида вот это то что я сейчас с вами проделал называется просеиванием
[19:38.360 --> 19:46.720]  вниз да потому как бы вниз этот элементик прокатывается потому что он уменьшился в случае
[19:46.720 --> 19:56.240]  пирамида по минимуму наоборот он увеличивается и тогда он тоже просеивается вниз вот я смотрю
[19:56.240 --> 20:03.920]  именно на вот этот вот момент и понимаю ага если я элемент изменю тогда я могу восстановить
[20:03.920 --> 20:11.320]  его свойства восстановить свойства пирамида во всем этом массиве причем я могу это сделать
[20:11.320 --> 20:17.000]  достаточно просто почему я же тут должен найти из детей какие-нибудь максимальные элементы
[20:17.000 --> 20:33.280]  обращаться к детям я умею ладно пусть будет так вот и поэтому я могу быстро за от единички
[20:33.280 --> 20:41.400]  найти темист самого большого ребенка среди возможных из этих двух или одного смотря кто
[20:41.400 --> 20:49.280]  это есть здесь хорошо вот таким вот образом я могу реализовать тот самый сив даун сив даун
[20:49.280 --> 20:56.000]  как выглядит ну смотрите я в начале с вами беру левой и нахожу левого ребенка с помощью вот этой
[20:56.000 --> 21:04.600]  формулы вот здесь написанный а после я нахожу правого ребенка ну и говорю что пусть у меня
[21:04.600 --> 21:09.440]  максимальный все еще находится в этом индексе потому что я не знаю я должен остановиться или нет
[21:09.440 --> 21:16.880]  потому что представьте что вместо здесь а ну здесь у двойки там было бы минус 5 минус 7 здесь
[21:16.880 --> 21:26.560]  минус 8 минус 3 вот я бы поставил минус 1 я дальше бы просеивать не должен был то есть у меня
[21:26.560 --> 21:33.240]  должны быть какие-то остановочные механизмы здесь все они должен прям вниз вниз эти и здесь
[21:33.240 --> 21:38.840]  звучит следующее давайте я возьму предположу что этот индекс является максимальным после
[21:38.840 --> 21:45.080]  чего я проверю со всеми его детьми причем заметьте у меня здесь написан а их и тут
[21:45.080 --> 21:51.240]  написано кстати неправильно написано если левт меньше сайза или если рай меньше сайза поправлю
[21:51.240 --> 21:59.480]  потом в итоговой презентации просто меньше и меньше и меньше равно не должно быть ссоре здесь
[21:59.480 --> 22:10.160]  ошибочка в общем-то если левый ребенок меньше сайза и а само значение лево ребенка оно больше
[22:10.160 --> 22:15.400]  чем моего максимального тогда я должен сказать что максимальный значит это ребенок
[22:15.400 --> 22:25.960]  тоже косяк простите давайте перепишем это красиво давайте с вами это быстро сделаем я не думаю что
[22:25.960 --> 22:40.360]  займет много-много времени я сделаю это где-нибудь вот здесь прошу прощения делал достаточно быстро то есть
[22:40.360 --> 22:59.160]  смотрите наш некоторые севдан а это и сайз вот ну у меня есть левый ребенок но я его просто
[22:59.160 --> 23:12.280]  нахожу у меня есть правый ребенок но я говорю что этот максимальный он равен и и что я должен
[23:12.280 --> 23:22.600]  сделать на всякий случай вам все здесь напишу есть ли у меня левый индекс меньше чем сайз именно
[23:22.600 --> 23:41.400]  меньше и а от левта больше чем а от моего максимального тогда в этом случае я буду
[23:41.400 --> 24:03.000]  что-то делать скажите мне а что если левт будет больше а бывает такое что левт больше райт да где
[24:03.000 --> 24:19.320]  индексы ну левт левт это именно вот вызов этой функции да что размер массива ну количество
[24:19.320 --> 24:32.280]  элементиков вот это левт чайлд от и это рай чайлд ты хорошо я прям допишу это именно индексы
[24:32.280 --> 24:45.400]  возвращают вот вопрос вот это выполнится или нет ну вот я могу обратиться к левт
[24:45.400 --> 24:58.520]  а правильно короткая логика слушайте этого человека как тебя зовут слушайте артур и не
[24:58.520 --> 25:11.400]  будет вам горе мне видимо сегодня много будет цитат ладно короче в действительности а с точки
[25:11.400 --> 25:16.960]  зрения плюсов существует короткая логика и короткая логика говорит нам о чем если у нас
[25:16.960 --> 25:24.360]  есть и и выполнен и не выполнено первые условия то второй мы даже проведать не будем потому что
[25:24.360 --> 25:35.000]  ноль и что-то всегда ноль понятно то есть если вот это окажется фолс то согласны что окажется
[25:35.000 --> 25:43.720]  фолс все выражение да вот это и есть та самая короткая логика которая иногда играет роль вот
[25:43.720 --> 25:49.720]  вам пример этого обращения то есть он не будет вот это высчитывать он не будет даже сюда заходить
[25:49.720 --> 25:57.160]  потому что если это фолс тогда и мне не важно что здесь это все будет фолс понятно это важный
[25:57.160 --> 26:12.600]  момент здесь и здесь написано корректно с точки зрения плюсов вот тогда все тогда вот я ну то
[26:12.600 --> 26:21.360]  есть у тебя в какой-то момент ты выйдешь за границу массива и будьте грустно вот и в этом случае
[26:21.360 --> 26:29.040]  что мы говорим мы говорим просто что у нас максимальный элемент он равен тому самому
[26:29.040 --> 26:35.200]  левт но а потом для того чтобы найти все-таки самый максимальный среди всех всех этих трех
[26:35.200 --> 26:42.120]  элементов мыши должны сравнить с правым ребенком вот но здесь аналогично мы с вами делаем только
[26:42.120 --> 26:50.720]  здесь мы говорим что райд меньше сайза заметьте мне тут тоже нужно писать потому что иногда
[26:50.720 --> 27:03.400]  бывает левый ребенок существует а правого нет вот райд меньше сайза и а от райд будет
[27:03.400 --> 27:10.480]  больше чем а от этого максимального причем мы не знаем этот максимально уже стал левым ребенком
[27:10.480 --> 27:16.360]  или нет или все еще остался самим родителям непонятно здесь поэтому в этом случае мы просто
[27:16.360 --> 27:20.200]  должны именно сравнить таким вот образ и дальше мы говорим что вот этот максимальный ребенок
[27:20.200 --> 27:35.760]  в этом случае это тот самый правый а зачем а зачем проверять что левыми а конечно конечно здесь
[27:35.760 --> 27:43.000]  это все уже есть вот таким вот образом мы с вами находим и нам нужно понять а так как мы рекурсивно
[27:43.000 --> 27:49.000]  должны снижаться спускаться вниз потому что мы если один раз пустились мы дальше еще раз должны
[27:49.000 --> 27:55.440]  для детей проверить и еще раз и еще раз до тех пор пока не остановимся какой момент мы понимаем что
[27:55.440 --> 28:01.840]  мы останавливаемся мы понимаем это в тот момент когда у нас максимальный среди вот этих трех
[28:01.840 --> 28:09.040]  элементов вот то есть вот здесь вот минус 1 6 5 вот здесь вот это минус 1 2 4 и так далее вот
[28:09.120 --> 28:14.960]  мы среди этих троек смотрим когда мы говорим о том что нас максимальный среди этих трех
[28:14.960 --> 28:21.920]  это тот самый элемент с индексом и и в этот момент мы с вами останавливаемся поэтому условия
[28:21.920 --> 28:27.040]  остановки точнее здесь не условия остановки условия продолжения рекурсии скорее написано
[28:27.040 --> 28:37.720]  оно звучит следующим образом что если у нас вот этот максимальный не равен и это означает
[28:37.720 --> 28:44.680]  следующее что среди его детей нашелся элемент больший значит нужно продолжать что-то делать с
[28:44.680 --> 28:57.240]  этим тогда в этом случае мы с вами берем просто и свопаем а а от и и а от этого максимального
[28:57.240 --> 29:11.480]  и кроме того мы должны сделать еще один сев даун для этого элемента то есть для
[29:11.480 --> 29:23.840]  а индексом largest и с размером size размер никак не изменился вот мы это обязаны еще
[29:23.840 --> 29:29.120]  раз сделать для того чтобы вот избежать случая вот когда вот здесь опять нужно его опустить
[29:29.120 --> 29:39.360]  или и так далее размер всего массива размер все пирамиды вот вот вот вот смотри у сколько тут
[29:39.360 --> 29:49.680]  элементов 1 2 3 4 5 6 7 8 9 10 11 12 ну я вот это не беру вот это является сайзом если вы
[29:49.680 --> 29:55.840]  представите это видимо сива ну вот этот элемент вот эту пирамиду то это 15 давайте
[29:55.840 --> 30:05.280]  здесь напишем 15 что там а минус 1 нет давайте возьмем итоговую пирамиду лучше чтобы не
[30:05.280 --> 30:34.680]  запутали 6 10 4 5 8 9 2 минус 1 0 1 ну здесь 3 вот размер этого массива ну здесь в этом массиве
[30:34.680 --> 30:41.000]  столько же элементов сколько пирамид согласны вот и получается что размер это
[30:41.000 --> 30:47.280]  количество элементов это массиве или количество элементов пирамиде все одно и то же
[30:47.280 --> 31:07.400]  вот это когда это работает ну возьми вот этот элемент у него индекс 11 11 умножить на 2 плюс
[31:07.400 --> 31:33.000]  1 это 20 3 ой да я уже все да это 23 23 больше сайза у него нет детей такая логика да
[31:33.000 --> 31:41.800]  вот это и будет означать что у нас нет и никого
[31:41.800 --> 31:52.120]  почему у нас эти функции они просто возвращают 2 и плюс 1 или 2 и плюс 2 они возвращают 2 и плюс
[31:52.120 --> 31:58.280]  1 и 2 и плюс 2 вот эти функции это левый ребенок это правый ребенок нам никто не обещает что мы
[31:58.280 --> 32:08.000]  не выйдем за границу массива вот еще есть вопросы к сейвдауна понятно что здесь было вот таким
[32:08.000 --> 32:13.320]  образом мы восстановили нашу пирамиду в случае изменения одного массива причем уменьшение его
[32:13.320 --> 32:24.760]  элемента а что делать если увеличится да нужно просить его вверх это называется просеивание вверх
[32:24.760 --> 32:34.560]  и в том здесь все еще проще просто сравнить два элемента да потому что здесь ну давайте
[32:34.560 --> 32:48.840]  что-нибудь нарисуем еще а давайте сделаем здесь опять 15 а 4 7 1 2 ну возьму такой простейший какой-нибудь
[32:49.280 --> 33:00.600]  и вот я поменяю 2 на 8 если всего один элемент то означает что вот здесь вот второй ребенок он
[33:00.600 --> 33:08.600]  всегда меньше чем его родитель а если я этот элемент увеличил и он стал больше родителя то он
[33:08.600 --> 33:16.640]  автоматически больше и второго ребенка понятно поэтому если я поменяю их местами то у меня все
[33:16.640 --> 33:21.400]  будет хорошо и я так должен опять же буду продолжать до тех пор пока не остановлюсь вот здесь
[33:21.400 --> 33:30.480]  мне всего до одного раза достаточно окей вот ну и сфтап ну как бы нам нужно здесь уже обращение
[33:30.480 --> 33:38.600]  к перренту я пока здесь дальше вернусь к ремне работа нам нужно всего лишь обращение к перренту
[33:38.600 --> 33:45.640]  то есть я смотрю кто у меня является родителем и просматриваю если этот родитель он меньше чем
[33:45.640 --> 33:55.160]  этот элемент тогда его про я их меняю местами и делу сфтап опять все ничего здесь критичного нет
[33:55.160 --> 34:10.640]  окей вот а теперь вернемся к времени работы вроде бы очевидно правда что всегда он работает за
[34:11.520 --> 34:19.840]  что если я скажу что не очень чем возьмем какой-нибудь пирамидку
[34:29.800 --> 34:40.160]  я сделаю вот так вот я могу просеивать либо влево либо вправо либо влево либо вправо согласны
[34:40.800 --> 34:46.280]  но просеиваясь вниз вот здесь вот элемент стоять тикс он может либо сюда ути либо сюда ути
[34:46.280 --> 34:54.840]  плюс-минус равно вероятно назовем это так неважно а плохо что делать
[35:01.360 --> 35:01.680]  да
[35:01.680 --> 35:11.080]  сверху можно ограничить как алгоритм почему
[35:11.080 --> 35:18.840]  да так
[35:18.840 --> 35:36.880]  на один могут различаться почему кто вам такой рассказал то есть денечка не считает смотрите
[35:36.880 --> 35:42.880]  я объясню в чем здесь кроется проблема если вы говорите что у нас есть логарифм
[35:42.880 --> 35:50.720]  например двоичный оттен и логарифм двоичный оттен минус один такой минус один
[35:50.720 --> 35:59.720]  константы я не отрицаю вопрос сколько у нас элементов минусуется вот этих пример
[35:59.720 --> 36:11.000]  а что пытаюсь типа просто понять вашу логику да да да это понятно
[36:17.000 --> 36:22.080]  вот вы представляете типа минус половинка элементов вы сделали
[36:22.080 --> 36:39.640]  так да это это правда да в действительности это можно объяснить именно так это хорошее
[36:39.640 --> 36:45.600]  объяснение здесь но есть более формально более формально звучит следующим образом даже если
[36:45.600 --> 36:51.680]  мы возьмем почти полное вот с левой стороны мы возьмем как будто бы полное дерево справа
[36:51.680 --> 36:56.800]  и не полное дерево так разделим пополам что вот здесь у нас максимум элементов здесь нет а всего
[36:56.800 --> 37:06.320]  элементов пирамиде n когда спойлер такой маленький будет меньше либо равно чем 2 и на 3 здесь меньше
[37:06.320 --> 37:16.960]  либо равно чем и попало всегда вот эта часть максимум дает 1 третью n вы даже можете посмотреть
[37:17.360 --> 37:23.240]  на это все дерево и понять почему смотрите у меня здесь четыре элемента здесь у меня только 6
[37:23.240 --> 37:35.760]  вот ну если в общем смотреть типа на все это корень как бы относится то сюда то сюда плюс
[37:35.760 --> 37:46.640]  минус 1 но в том суть что вот тут количество элементов оно больше чем здесь если что интересный
[37:46.640 --> 37:55.960]  факт вот если рассматривать это с такой точки зрения то в этом случае вы говорите что у вас
[37:55.960 --> 38:03.720]  всегда уменьшается разброс по элементам которым вы ходите то есть вот это вот t от n оно придет
[38:03.720 --> 38:12.600]  максимум к t от n t от 2 в третьих n ну потому что у нас время алгоритма оно должно зависеть как-то
[38:12.600 --> 38:21.160]  от n я говорю что один раз пустится это тоже самое что там t от единички это раз плюс спустится
[38:21.160 --> 38:28.840]  по под дереву из двух третьих элементов максимум потому что здесь две третьих здесь их n полам то
[38:28.840 --> 38:47.960]  есть максимум мой будет вот такой 2n на 3 можно можно интересно вот но суть примерно в этом ok
[38:47.960 --> 39:03.920]  продолжаем дальше вам перерыв не нужен нужен дальше хорошо можно дальше да
[39:03.920 --> 39:18.160]  вот это вам вопросик как раз таки на подумать но если ты порисуешь ну вот ты можешь просто
[39:18.160 --> 39:27.600]  сначала порисовать деревья увидишь что вот здесь количество листьев так почему две трети на самом
[39:27.600 --> 39:33.520]  деле это связано с количеством листьев в дереве из n элементов грубо говоря то есть смотри вот
[39:33.520 --> 39:43.000]  это x вот это x но они одинаковые сколько у дерева с x элементами может быть листьев
[39:43.000 --> 40:01.000]  в самом деле x плюс 1 вот такое объяснение вот так что так окейм что касается сифта по аналогично
[40:01.000 --> 40:04.680]  на самом деле но здесь так как мы вообще поднимаемся вверх то у нас не может быть
[40:04.680 --> 40:11.120]  определение типа мы уменьшаемся в две трети ну в 3 вторых раза старая раз здесь всегда будем
[40:11.120 --> 40:16.760]  уменьшаться типа на уровне и всегда смотреть на эти уровни поэтому получаем тот самый благориф
[40:16.760 --> 40:26.200]  заветный тоже и вот мы подходим к самому интересному представим следующий у нас есть
[40:26.200 --> 40:34.800]  с вами массив данными и вам ему нужно построить пирамиду у кого какие идеи как это делать
[40:34.800 --> 40:45.640]  мы мы идем к пирамидальной сортировке чтобы сортировать элементы я понял так
[40:45.640 --> 40:52.920]  а как мы можем восстановить свойства пирамиды смотрите мы восстанавливали
[40:52.920 --> 40:57.880]  свойства пирамидов в случае когда пирамида всего один элемент в ней менялся
[41:09.880 --> 41:15.480]  у меня вопрос в этом случае а что делать если оно там не выполнено нескольких уровней
[41:15.480 --> 41:21.800]  так
[41:26.200 --> 41:32.480]  так так то есть вы мне предлагаете создать то мы массив правильно
[41:32.480 --> 41:44.480]  так и там закидывать все самые или элементики
[41:51.600 --> 41:58.920]  тогда за сколько будет работать по строению пирамида которые мне назвали прикольное это
[42:02.640 --> 42:15.880]  надо быстрее быстрее выше сильнее нужно всегда к этому а это сортировку пока я пирамиду строю
[42:20.280 --> 42:20.840]  так
[42:20.840 --> 42:35.560]  ну вообще в действительности добавляйте по одному элементику это логично но что еще раз
[42:35.560 --> 42:42.160]  как
[42:42.160 --> 42:54.040]  ты их просто так не солью что-то корня нет вот если корень был туда я вообще не отрицаю но
[42:54.040 --> 43:03.320]  без корня ты их просто так не солью а тогда где под корень останется этого корня
[43:03.320 --> 43:14.800]  получается опять благорифа пойдем не понял в общем в действительности рассуждение о том что
[43:14.800 --> 43:21.920]  добавлять элементы пирамидку по одному и как-то сев дауни они имеют смысл и это правильно и
[43:21.920 --> 43:37.520]  хорошо но нужно и делать это с другого конца а а давайте с вами напишем какие-нибудь данные и
[43:37.520 --> 43:46.040]  построим пирамиду тогда я думаю вы поймете что я имею ввиду продиктуйте мне любые чиселки 3
[43:46.040 --> 44:13.560]  7 10 давайте чуть так 5 6 1 28 учился в этой школе сразу видно так а минус 7 давайте так
[44:13.560 --> 44:25.920]  и остановимся пожалуйста вот хорошо у нас есть вот такая вот недопирамидка и она не выполнил
[44:25.920 --> 44:32.040]  здесь свойство о том что у нас в действительности лежат максимальные элементы сверху смотрите я
[44:32.040 --> 44:40.600]  вот эти связи пока уберу вот у меня эти элементы есть что я хочу сделать я хочу сказать вот на
[44:40.600 --> 44:54.120]  этом примере следующие возьму сначала все листы которые у меня есть 1 2 3 4 5 это мои
[44:54.120 --> 45:12.600]  листы пирамиде листы это у кого нет детей вот будем 7 лет так живу а вот смотрите у нас есть
[45:12.600 --> 45:20.120]  листы у которых нет детей согласны и то что а элементы пирамиды из одного элемента является
[45:20.120 --> 45:30.280]  корректный согласны ли вы тогда что вот это все является под корректной пирамидой ми по факту
[45:30.280 --> 45:38.920]  правда давайте теперь рассмотрим добавление нового элемента я рассматриваю эту пятерку и
[45:38.920 --> 45:47.040]  она образует под собой вот такую вот пирамиду из трех элементов мне необходимо восстановить
[45:47.040 --> 45:52.920]  корректность что я могу сделать для того чтобы остановить здесь корректность попробовать так
[45:52.920 --> 46:00.520]  как вот эти корректны а вот этот некорректен если у нас в корне находится некорректный элемент
[46:00.520 --> 46:09.280]  что я должен сделать просеивать вниз то есть сив даун я здесь делаю с вами сив даун и получаю
[46:09.280 --> 46:26.440]  вот это 5 и 179 я меняю их местами и получаю здесь 179 и 5 хорошо ну хорошо вот рассмотрим
[46:26.440 --> 46:38.520]  следующий элемент он образует под собой вот и его дети являются корректной пирамидой
[46:38.520 --> 46:44.800]  значит у нас один элемент всего лишь неверный и он находится в корне значит все что мы можем
[46:44.800 --> 46:50.560]  с ним сделать это сив даун и опять смотрю что здесь будет происходить ну когда я сделаю здесь
[46:50.560 --> 47:02.520]  сив даун я получу здесь 28 а здесь 10 пойду дальше стим им 6 и 179 ну очевидно
[47:08.520 --> 47:17.600]  смотри этот элемент находится в корне ну вот момент эти элементы в корне конечно потому что
[47:17.600 --> 47:25.280]  только он является некорректным все его дети являются корректными пирамидами ну потому что
[47:25.280 --> 47:31.280]  во-первых листы были здесь корректны но это корректные пирамиды да я добавил один элементик
[47:31.280 --> 47:38.000]  вот здесь к примеру он и сделал сив даун я восстановил корректность пирамида понятно а
[47:38.000 --> 47:43.160]  если я восстановил корректность пирамида то это тоже стало корректной пирамиды и получается
[47:43.160 --> 47:48.240]  когда я уже сел я говорю что у него этот корректный пирамид на пирамиды
[47:58.840 --> 48:06.740]  ну почти почти почти но нет ну смотрите я сейчас дальше это другой вопрос пока я просто иду с
[48:06.740 --> 48:18.620]  низу вверх и справа налево вот вот у меня вот такие элементы здесь 28 являются корректными
[48:18.620 --> 48:29.820]  пирами вот я добавляю последний свой элемент корень но он у меня некорректен значит я с
[48:29.820 --> 48:42.020]  вами должен что сделать сив даун я делусь даун и меняю 3 со 179 но не ограничивается только тем
[48:42.020 --> 48:51.180]  что он опускает на один раз он же и рекурсивно это делает поэтому сравнить 3 и стать сюда ставлю
[48:51.180 --> 49:02.340]  7 сюда 3 дальше 3 5 минус 7 но очевидно что сюда становится и смотрите корректно ли это пирамида
[49:02.340 --> 49:12.980]  корректно за счет чего она становится корректно за счет того что в каждый момент времени у нас
[49:12.980 --> 49:20.660]  есть корректный под пирамида грубо говоря с корнями в каких-то числах и мы с ними работаем
[49:20.660 --> 49:27.860]  выглядит вот так кто мне скажет почему я иду сайза минус один пополам
[49:27.860 --> 49:37.100]  родитель для самого последнего элемента
[49:37.100 --> 49:53.420]  да это первый лист запомните во-первых пирамиде что в пирамиде все листы
[49:53.420 --> 50:02.260]  имеют индекс какие 2 и плюс один ну мы как должны найти индексы листов то есть я
[50:02.260 --> 50:08.060]  же начинал там с листов грубо говоря смотреть а я говорю следующее вот у меня есть 2 и плюс
[50:08.060 --> 50:14.900]  один что означает лист что 2 и плюс один больше либо равен чем size и 2 и плюс два больше чем
[50:14.900 --> 50:21.340]  больше либо равен size но очевидно что я буду рассмотреть чисто первое уравнение неравенство
[50:21.340 --> 50:31.300]  вот получается что здесь и больше либо равен чем size 1 полам вот это все является листами все
[50:31.300 --> 50:38.980]  элементы с таким вот индексом являются листами поэтому я иду вот у меня построение оно шло
[50:38.980 --> 50:46.420]  откуда оно шло с листов вот все листы они и так корректно их трогать не надо нужно идти левее
[50:46.420 --> 50:53.380]  а потом вверх все листы являются корректными пирамидами
[51:02.540 --> 51:13.180]  где они не входят больше либо равны сайс минус один пополам сайс минус один пополам а вот а вот это
[51:13.180 --> 51:20.220]  так еще раз если это лист у него нет ребенка значит если у него нет ребенка значит его дети
[51:20.220 --> 51:34.500]  грубо говоря находится замыселем чем нет зачем ну у тебя гранично сверху сайзом еще раз все индексы
[51:34.500 --> 51:45.900]  листов находятся от сайс минус один пополам до сайза не включая зачем только вот то есть
[51:45.900 --> 51:52.580]  смотрите благодаря вот этому вот мы можем сказать что мы знаем индексы листов и здесь и здесь и
[51:52.580 --> 51:59.060]  напред и на последнем уровне и на предпоследнем уровне вот мой любимый вопрос который ставит
[51:59.060 --> 52:05.700]  обычные людей в тупик на экзамене скажи мне индексы листов мне вот говорят то и такое ну вот
[52:05.700 --> 52:13.580]  я нарисовал вот эту вот пирамидку где у меня есть и этот части это части я спрашиваю а тут и все
[52:13.580 --> 52:19.940]  ломаются в этот момент не ломайтесь проблема в том что вот достаточно вот этих вот вещей понятно
[52:19.940 --> 52:40.060]  а нет что получить индексы листов которые везде где угодно которые могут быть и на последнем и
[52:40.060 --> 52:44.300]  не на последнем у тебя пирамида может быть полной прям бинарным полным деревом то есть
[52:44.300 --> 52:55.100]  для всего работает она работает для таких пирамид и для я имею ввиду под полный я имею в виду вот
[52:55.100 --> 53:15.220]  такую пирамиду если я сделаю сев даун для листа что-нибудь изменится ну типа и вы можете там
[53:15.220 --> 53:26.700]  написать сайз минус один пополам минус один вот единственное там даун ту нулик вот за это опять
[53:26.700 --> 53:36.580]  прошу прощения вот не вычел но да надо делать это до нуля у нас пирамида с нуля строить вот а ты
[53:36.580 --> 53:45.940]  понял или нет на чем люди ломались обычно экзамен когда я говорю вот у меня есть пирамида скажи
[53:45.940 --> 53:52.340]  мне индексы листов мало кто забывал вот что что для индексов листов достаточно вот этого
[53:52.340 --> 54:03.620]  те пытались вывести мне через степени двойки это все из-за этого были проблемы запомните все
[54:03.620 --> 54:13.180]  гениально просто индекс где мы находимся вот
[54:13.180 --> 54:25.220]  достаточно достаточно я только из него и делаю вот этот вывод вот ну просто написать нужно и
[54:25.220 --> 54:32.540]  то и другое вот ну и да инвариант это как раз таки то что я с вами говорил то что у нас когда
[54:32.540 --> 54:39.620]  мы находимся на и там месте вот здесь вот и то я подразумевается итерация на и и и и и то у нас
[54:39.620 --> 54:48.180]  все индексы и плюс один и так далее до сайз минус один они являются корректными пирамидами сначала
[54:48.180 --> 54:53.300]  все листы являются потом у нас добавляется один элементик мы восстанавливаем корректность пирамида
[54:53.300 --> 55:07.220]  она становится опять корректный и так далее за сколько это работает за еще раз за инлуген согласно
[55:07.220 --> 55:18.540]  что за инлуген плохо плохо и кто мне скажут на экзамене что это работает за инлуген я
[55:18.540 --> 55:27.740]  честное слово даю вот прям вот на те крест не знаю типа я отправлю на приздачу у меня уже иногда
[55:27.740 --> 55:33.020]  нерв не хватает на это все это не работает за инлуген хотя хоть это так и выглядит
[55:33.020 --> 55:42.860]  почему по очень простой причине вот помните вы мне предлагали строить дей строить пирамиду добавлять
[55:42.860 --> 55:47.420]  элемент потом и вы там севда у нас и втапить и так далее здесь я предлагаю немного другую
[55:47.420 --> 55:54.460]  системы мы делаем просто севда он всегда это раз и вопрос а сколько мы будем раз севда у них
[55:54.460 --> 56:00.180]  согласна ли вы с тем что если элемент находится на предпоследней то мы его максимум один раз
[56:00.180 --> 56:11.980]  севда а если ну чуть повыше то два и так далее здесь уже логариф я не спорю правильно док смотрите
[56:11.980 --> 56:24.180]  здесь количество элементов большое а здесь он один то есть у нас количество действий вниз не
[56:24.180 --> 56:32.020]  так много но элементов много количество действий вниз много но элементов мало это нужно просто
[56:32.020 --> 56:39.500]  аккуратно расписать всегда и тогда у вас все получится не квадрат это вот он работает
[56:39.500 --> 56:45.260]  сейчас вот покажем с вами как это работает смотрите а что такое высота в пирамиде на высоту в
[56:45.260 --> 56:53.220]  пирамиде мы возьмем это как число ребер в самом длинном простом нисходящем пути как бы это
[56:53.220 --> 56:58.700]  страшно не звучало простой нисходящий путь означает что там нельзя крутиться постоянно ну туда-сюда
[56:58.700 --> 57:06.580]  ходить вот нисходящий вниз идет и вот мы сколько идем до как до самого дальнего листа вот так это
[57:06.580 --> 57:16.980]  является высотой вот такое определение ну высота у нас естественно округление логарифом просто вот
[57:16.980 --> 57:25.060]  есть следующее утверждение над которым я предлагаю вам именно подумать его достаточно просто его
[57:25.060 --> 57:32.980]  сможете объяснить что на любом уровне на высоте аш находится n делить на 2 в степени аж плюс один
[57:32.980 --> 58:00.140]  элементов а нижний уровень у него а аш 0 количество ребер вот ну 2 в степени 0 плюс 1 это 2 ну то
[58:00.140 --> 58:07.900]  есть на последнем уровне не более чем он пополам вон я с вами показывался немножко выше в два раза
[58:07.900 --> 58:18.060]  меньше на 4 и так далее в этом суть вот и тогда что мы можем сказать о времени работе время работы
[58:18.060 --> 58:26.700]  здесь это т ну это сумма от высоты нуля до округления логарифма это раз ну мы суммируем по всем
[58:26.700 --> 58:32.380]  высотам сколько находятся элементов на каждой высоте это n делить на 2 степень аж плюс один и
[58:32.380 --> 58:40.900]  за сколько работает севдалм в этом случае в худшем за от аж правильно не он не за от
[58:40.900 --> 58:49.940]  логарифма в этом случае а за от аж согласны а у это такая линейная функция можно мне все вносить
[58:49.940 --> 58:59.060]  это не страшно но если у вас есть сумма вот я вношу сумму и я выношу n и 2 потому что сумма не
[58:59.060 --> 59:06.980]  зависит от n ну там нет параметра n там аш идет вот поэтому это могу вынести получается нас о
[59:06.980 --> 59:16.620]  от n пополам и сумма аж делить на 2 степень аж смотрите а вы дошли до рядов маклоуэрна вот
[59:16.620 --> 59:25.420]  это все нет что тогда тогда вот примечание это для вас если у вас есть x и оно делится на 2
[59:25.420 --> 59:40.940]  степени x то это бесконечный ряд имеет сумму 2 это хорошо что тебя очевидно вот но в действительности
[59:40.940 --> 59:46.580]  это бесконечный ряд имеет сумму 2 ну и все а значит я вот эту сумму которая у меня есть а аж
[59:46.580 --> 59:53.380]  делить на 2 степень аж могу сверху оценить двойкой просто но это если это бесконечности рассмотрю
[59:53.380 --> 01:00:05.700]  согласна все у нас получается вот он да да
[01:00:10.940 --> 01:00:38.700]  сейчас 2 3 4 5 6 7 8 9 9 согласен 9 лимитов а ой подожди вот какой левой у них высота 0
[01:00:38.780 --> 01:00:47.820]  они отдельно считаются вот здесь высота 0 вот здесь высота 0 вот здесь 0 вот здесь
[01:00:47.820 --> 01:01:04.580]  0 вот здесь 0 вот здесь 1 вот здесь 1 в семерке 2 ну где вы видите здесь нисходящий путь из рёбер
[01:01:04.580 --> 01:01:06.380]  в универ
[01:01:06.380 --> 01:01:17.180]  у них высоты другие у них высоты не то что вот это вот все является высотой 1 нет тоже важно
[01:01:17.180 --> 01:01:29.540]  понимать окей конечно принято
[01:01:36.820 --> 01:01:44.620]  какую еще раз формула почему она получается вот это именно какой конкретно кусочек не ясен
[01:01:44.620 --> 01:01:56.820]  первый шаг смотрите у нас на высоте аж находится а n делить на два степень аж
[01:01:56.820 --> 01:02:03.260]  плюс один элементов согласен а сев да он за сколько работает за о от аж но от высоты
[01:02:03.260 --> 01:02:09.780]  максимум высоты вот получается что у меня по n делить на два степень аж плюс один на о
[01:02:10.540 --> 01:02:16.340]  согласен вот столько будет там элемент но я же должен просуммировать по всем высотам
[01:02:16.340 --> 01:02:25.500]  возможным получаю вот эту сумму суммы согласен отлично а теперь о является линейной функцией ну
[01:02:25.500 --> 01:02:31.860]  то есть все суммы которые не запихая они нормально будут там жить поэтому о я могу вынести за скобку
[01:02:31.860 --> 01:02:42.700]  а внутри у меня остается n делить на два аж плюс один еще аж от ошки и все ну грубо
[01:02:42.700 --> 01:02:52.380]  говоря у меня получается там а n делить на два степени аж плюс один и аж вот это все является
[01:02:52.380 --> 01:03:03.420]  под суммой но эта сумма она идет по аж значит я могу вынести n пополам к примеру но n не
[01:03:03.420 --> 01:03:12.740]  зависит от аж они ну они зависящие но не в этом смысле здесь не по n идет у нас сумма а по аж вот
[01:03:12.740 --> 01:03:24.060]  а здесь получается аж аж делить на два степени аж но дальше это ограничено двоечкой
[01:03:24.060 --> 01:03:37.660]  окей принято в каком-то виде хотя бы ладно так что да допомните этот факт обязательно
[01:03:37.660 --> 01:03:44.340]  экзамен спрошу и спрошу только не только я вот одного человека так отчислил что вы были
[01:03:44.340 --> 01:03:58.060]  серьезными момент а вообще я отчислил по моему жизни своей только одного человека но там было
[01:03:58.060 --> 01:04:10.420]  коллегиальное решение не только мою вот а там не только в этом скажу честно ну как бы да там же
[01:04:10.420 --> 01:04:17.980]  для того чтобы вас отчислить нужно сначала вам дать передачу потом комиссию и только вот после
[01:04:17.980 --> 01:04:25.420]  комиссии вас отчисляют на комиссии всегда присутствует два человека так что там успокойтесь просто так вас
[01:04:25.420 --> 01:04:31.660]  не отчислят если вы что-то дознаете нет никакой беды если вы конечно с переперездачей больше не
[01:04:31.660 --> 01:04:45.140]  получите но это так отдельно причем заметьте снег то уже выпал вот это пора да да а вот так вот
[01:04:45.140 --> 01:04:51.100]  ладно а переходим к самой пирамидальной сортировке на самом деле у пирамидальной
[01:04:51.100 --> 01:04:59.260]  сортировке достаточно простая идея вот если у нас есть с вами пирамида построенная уже построена то
[01:04:59.260 --> 01:05:07.100]  как я могу из нее получить отсортированный массив давайте вот здесь вот это опять же нарисую вот у
[01:05:07.100 --> 01:05:21.980]  меня с вами это пирамидка давайте обсудите колок попозже вот завтра все верно а при
[01:05:21.980 --> 01:05:28.620]  пирамидальной сортировке смотрите согласны что сверху у меня всегда стоит максимум давайте
[01:05:28.620 --> 01:05:35.940]  но я же хочу отсортировать их по возрастанию вот моя задачка здесь давайте я вот этот вот
[01:05:35.940 --> 01:05:43.940]  максимум отправлю в конец массива и забуду про него то есть в этом случае если рассмотреть
[01:05:43.940 --> 01:05:53.140]  весь мой массив давайте первоначально он будет выглядеть как 179 число состоящее из трех цифр
[01:05:53.140 --> 01:06:11.100]  неприятно писать долго 5 6 11 10 10 3 и 7 вот мой массив чего
[01:06:11.100 --> 01:06:25.900]  чего логен так ладно а
[01:06:25.900 --> 01:06:37.740]  минус 7 вот чего я делаю на первом своем действии я говорю следующее давайте я поменяю 179 и
[01:06:37.740 --> 01:06:51.380]  минус 7 местами я получу здесь 179 здесь минус 7 здесь все также 7 28 5 6 11 10 и 3 я получаю
[01:06:51.380 --> 01:07:00.620]  вот такой кусочек и говорю ага тогда в этом случае вот здесь это выглядит как 179 а здесь
[01:07:00.620 --> 01:07:12.020]  минус 7 и я обрубаю вот эту связь то есть я просто уменьшаю сайз пирамида на 1 тогда в этом
[01:07:12.020 --> 01:07:20.020]  случае у меня пирамида теперь будет строиться до вот этих элементов и здесь 179 уже стоит на
[01:07:20.020 --> 01:07:28.580]  верном месте это максимум из всех чисел и все что у меня плохо в пирамиде это минус 7 которое
[01:07:28.580 --> 01:07:36.340]  стоит здесь согласно а если у меня изменилось всего одно число как в корне то как мне восстановить
[01:07:36.340 --> 01:07:44.660]  корректность пирамиды сделать сев даун я делу сев даун это минус семерки она уходит сейчас скажу
[01:07:44.660 --> 01:08:00.460]  сюда 28 вот сюда она уходит а здесь был 11 вот а у меня получается 28 я теперь ставлю 28 в
[01:08:00.460 --> 01:08:11.980]  конец ну то есть промежуточным шагом когда я сделал сев даун у меня будет здесь 28 7 11 5 6
[01:08:11.980 --> 01:08:21.940]  минус 7 10 3 вот это промежуточный шаг и я снова беру этот максимум который у меня здесь есть и
[01:08:21.940 --> 01:08:36.500]  ставлю его уже в конец этой пирамида а конец этой пирамида это тройка получать здесь 28 179 3 7 11 5 6
[01:08:36.500 --> 01:08:45.340]  минус 7 10 теперь я буду пирамиду строить до сюда то есть когда я вытащил этот максимум то я
[01:08:45.340 --> 01:08:51.260]  уменьшать буду пирамиду когда его положил в конец смотрите я просто свопают местами и
[01:08:51.260 --> 01:08:57.780]  получаю то что мне нужно и я буду продолжать так делать дальше делаю сев даун для тройки
[01:08:57.780 --> 01:09:03.700]  заметьте сверху оказывается не всегда самый маленький элемент минус 7 вот здесь вообще живет
[01:09:03.700 --> 01:09:12.820]  но сев даун я должен продолжать дальше у меня встанет туда на место места 11 потом 10 ну и так
[01:09:12.820 --> 01:09:18.980]  далее и я вот закидываете элементы в конец всегда получу то что мне нужно и я так получу
[01:09:18.980 --> 01:09:39.140]  необходимую мне отсортированную последовательность понятно что я сделал да да да да
[01:09:42.820 --> 01:10:01.620]  что у нас левт больше сайза сайз меняется да и что но опять же еще раз там же короткая логика как
[01:10:01.620 --> 01:10:09.340]  делает мы вначале проверяем вот этот левт меньше сайза и если это правда тогда мы только продолжаем
[01:10:09.340 --> 01:10:18.420]  что-то они наоборот вот поэтому пирамидальная сортировка выглядит вот так здесь тоже даун ту
[01:10:18.420 --> 01:10:23.580]  андаун ту единичка здесь правильно потому что элементы за одной пирамидки это будет там
[01:10:23.580 --> 01:10:31.140]  минимальный элемент то есть смотрите я вначале делаю билд хип трое пирамиду по имеющимся данным
[01:10:31.140 --> 01:10:38.500]  причем я как бы не создаю дополнительные массивы ничего такого не делаю дальше я прохожусь от
[01:10:38.500 --> 01:10:48.740]  сайз минус 1 до единички и делаю следующее я свопаю но его элемент с и там свопнул уменьшил
[01:10:48.740 --> 01:10:56.020]  размер моей пирамиды и делаю сев даун сделал сев даун значит восстановилась корректность
[01:10:56.020 --> 01:11:03.100]  моей пирамиды появился сверху опять максимум опять его закидываю в конец уменьшаю сайз и
[01:11:03.100 --> 01:11:13.500]  делаю сев даун и так продолжаю вот это является пирамидальной сортировкой есть ли к ней вопросы
[01:11:21.500 --> 01:11:29.780]  нлоган всегда но вас самый худший случай какой здесь возможен на самом деле возможен
[01:11:29.780 --> 01:11:37.740]  следующее если верхний элемент всегда вниз будет скатываться правда ну прям вниз вниз вниз высота
[01:11:37.740 --> 01:11:44.500]  пирамиды чему равно лого риф сколько раз он может скатиться вниз вот прям до лого рифма
[01:11:44.500 --> 01:12:02.100]  вот весь крайность крайность типа а смотрите у меня есть элемент на самом верху но тут
[01:12:02.100 --> 01:12:09.100]  какое-то действие вот у вас есть последний вот этот уровень находясь еще на глубине
[01:12:09.100 --> 01:12:16.220]  лого рифм двоечный а сколько раз вот этот элемент может оказаться вот здесь снизу то есть
[01:12:16.220 --> 01:12:24.860]  я сев даун же буду минимум все время вниз ну а меньше n пополам но может быть n пополам
[01:12:24.860 --> 01:12:37.420]  то есть худшее время работы n пополам возможен ага потому что здесь 2 в нулевой 2 первые и так далее
[01:12:37.860 --> 01:12:45.180]  количество элемент если рассматривать у нас всегда в два раза больше здесь будет сумма двоичная а
[01:12:45.180 --> 01:12:51.240]  здесь будет просто 2 в степени эту штука поэтому здесь всегда может быть н пополам элементов то
[01:12:51.240 --> 01:12:57.700]  есть здесь меньше либо равно чем n пополам а это означает только лишь одно что если это меньше
[01:12:57.700 --> 01:13:05.020]  либо равно чем n пополам то возможен случай когда мы n пополам раз будем ходить лого рифм двоичных
[01:13:05.020 --> 01:13:21.880]  от Н. Ну и у вас вот у от Н логин. Понятно? Да. Билдхип действительно за у от Н. Сивдаун
[01:13:21.880 --> 01:13:34.360]  сколько сколько стоит сивдаун? Логорифм. Согласен? Да. А сколько раз повторяешь
[01:13:34.360 --> 01:13:43.960]  сивдаун? Н. Вот. Но это самое простое, с простое это объяснение. Лучше всего
[01:13:43.960 --> 01:13:48.440]  вот говорить, как я сейчас вам рассказал про худший случай, грубо говоря. Вот он
[01:13:48.440 --> 01:13:54.160]  вариант, что у вас на глубине логорифм двоечных от Н может быть Н пополам
[01:13:54.160 --> 01:14:13.880]  элементов. Значит в этом случае вот, ну вот, худший вариант. Вот. Смотрите, а хипсорт
[01:14:13.880 --> 01:14:20.080]  работает хуже, чем мерчсорт. Вот. Но иногда бывает лучше, чем квиксорт. А
[01:14:20.080 --> 01:14:29.680]  маленький спойлер такой на то, чтобы вы выжили в итоговом контесте. Если вдруг
[01:14:29.680 --> 01:14:38.880]  вам в итоговом контесте просят написать сортировку с 99 процентами вероятности
[01:14:38.880 --> 01:14:47.080]  квиксорта вы не написали. Спойлер. Ну типа это проверялось много раз. Много кто пытался
[01:14:47.080 --> 01:14:58.480]  это делать. И такое, ну чтобы вы понимали, ну сколько я тут, 7 лет учусь. Там и то и другое
[01:14:58.480 --> 01:15:09.400]  бывает, но чаще всего типа то, что вы писать не умеете его. Вот. В баск. Но я говорю, это не
[01:15:09.400 --> 01:15:15.720]  только вы, типа это и мой первый курс такой был, и потом был, и потом, и потом. Вот все это
[01:15:15.720 --> 01:15:21.880]  время, пока я вот на все это смотрел. У всех, все кто выходил с контестов всегда говорили, типа блин,
[01:15:21.880 --> 01:15:32.720]  у меня квиксорт не зашел. Вот. А в общем, а мой посыл следующий. Если вы понимаете, что там
[01:15:32.720 --> 01:15:39.760]  нужна у вас логарифмическая сортировка, мерчсорт сложно ошибиться. Хипсорт тоже сложно ошибиться.
[01:15:39.760 --> 01:15:47.800]  Если вы их поняли, то они очень простые. Вот. Квиксорт просто ошибится. Поэтому осторожней. Но это
[01:15:47.800 --> 01:15:56.120]  так, типа, ваши в будущее, вот те, кто там досмотрел до этого момента. Может быть, они там поймут какое-нибудь
[01:15:56.120 --> 01:16:03.200]  священное знание. Вы, главное, что вы запомните это. Поверьте, вспоминайте эти слова во время
[01:16:03.200 --> 01:16:18.560]  контеста итогового. Это другой вопрос. Да нет, почему? Окей. Вот. В принципе, именно относительно
[01:16:18.560 --> 01:16:26.280]  пирамиды, это все, что я вам хотел рассказать. Единственное, что существует, мы почти не остановимся
[01:16:26.280 --> 01:16:35.680]  на этом. Очередь с приоритетами называется такая штука. Вот. Очередь с приоритетами — это вот это. Вот.
[01:16:35.680 --> 01:16:43.160]  То, что является пирамидой, является очередь с приоритетами по факту. И приоритетом там выступают
[01:16:43.160 --> 01:16:52.160]  какие-то ключи чаще всего. Ну, представьте, не знаю, типа, вы пришли в МФЦ, вот. Но у вас там
[01:16:52.160 --> 01:17:00.800]  работает знакомая. Вот у вас нулевой приоритет. Вас проведут моментально. Но если вы пришли,
[01:17:00.800 --> 01:17:07.520]  как обычный человек, тогда ваш приоритет там один, грубо говоря. И вот здесь устанавливаются
[01:17:07.520 --> 01:17:12.960]  приоритеты. И все идут в порядке очереди, но только вначале обрабатываются там нулевые приоритеты,
[01:17:12.960 --> 01:17:21.400]  потом только первые, потом вторые и так далее. Понятно? Вот. А сущность вот примерно в следующем.
[01:17:21.400 --> 01:17:44.520]  Есть ли у вас какие-нибудь вопросы? Да. Этот вопрос я оставлю без отсвета. А что поделать?
[01:17:44.520 --> 01:17:59.520]  Это не четыре ребенка. А что поделать? Кто? А пирамида является ли это сортировкой? Смотрите,
[01:17:59.520 --> 01:18:08.920]  с точки зрения стабильности она нестабильна. Она нестабильна. Она может их поменять местами,
[01:18:08.920 --> 01:18:13.720]  и ты этого не заметишь. Поэтому данная сортировка не является стабильной. Количество
[01:18:13.720 --> 01:18:25.000]  здесь свопов тоже N log N. То есть все свопы – это те самые сивдауны. Вот. Важный момент про… Я вам
[01:18:25.000 --> 01:18:32.840]  же сказал, что иногда квадратичные сортировки лучше, чем все остальные. Или нет? Нет. Возможно,
[01:18:32.840 --> 01:18:38.360]  я кому-то это сказал, когда ко мне подходили после. Но это важный момент. Смотрите,
[01:18:38.360 --> 01:18:44.360]  когда мы с вами говорили про количество свопов, мы говорили, что оно также играет роль. То есть время
[01:18:44.360 --> 01:18:50.120]  работы – это одно, количество свопов – это другое. Представьте, что вам нужно менять между собой не
[01:18:50.120 --> 01:18:58.040]  просто элементы, а массивы. Массивы из N элементов. Поменять массивы из N элементов, когда это будет
[01:18:58.040 --> 01:19:04.040]  в некоторой структурке вашей, вам необходимо будет, для того чтобы одно перемещение сделать,
[01:19:04.040 --> 01:19:09.000]  это будет работать за O от N. Потому что вам нужно посвопать все элементы в массивах. Чисто
[01:19:09.000 --> 01:19:18.560]  указатель не сойдет. Вот. Смотря что ты будешь менять, но если я говорю про векторат, то нет. Ну,
[01:19:18.560 --> 01:19:27.720]  там не так это будет. Вот. И если я возьму ту же сортировку выбора, где количество свопов всего
[01:19:27.720 --> 01:19:33.880]  за O от N, тогда эта сортировка, с одной стороны, по времени работает за N квадрат. Согласны? Вот
[01:19:33.880 --> 01:19:40.440]  в нынешней ситуации. Но из-за того, что у нас свопов O от N, то эти свопы выполнятся тоже за O от N
[01:19:40.440 --> 01:19:46.200]  квадрат. Ага. А теперь представьте, у меня есть быстрая сортировка. Она работает как бы за N лог N.
[01:19:46.200 --> 01:19:54.440]  Но у нее N лог N свопов. А каждый своп работает за O от N. Тогда за сколько работает эта сортировка?
[01:19:54.440 --> 01:20:05.120]  За N квадрат лог N. Она хуже, чем сортировка выбора. Вот такие вот удивительные метаморфозы вы
[01:20:05.120 --> 01:20:11.360]  можете встречать. Вы об этом должны всегда думать. И в этом плане не забывать. Во всем остальном,
[01:20:11.360 --> 01:20:16.240]  в принципе, все на сегодня. Всем хорошего вечера и удачи!
