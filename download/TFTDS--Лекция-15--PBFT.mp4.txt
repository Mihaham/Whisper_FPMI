[00:00.000 --> 00:11.640]  Ну что, поехали? Напомню, что в прошлый раз мы с вами перешли в новую модель сбоев,
[00:11.640 --> 00:17.160]  византийских сбоев, где сбоенные узлы могли не просто рестартовать, не просто перезагружаться,
[00:17.160 --> 00:24.080]  они могли еще и произвольным образом нарушать протокол. И в этой модели мы делили узлы не на
[00:24.080 --> 00:31.280]  корректные и сбоенные, а скорее на честные и нечестные, на честные узлы и злоумышленников,
[00:31.280 --> 00:37.520]  которые пытаются систему привести в какое-то некорректное состояние, возможно, кооперируя
[00:37.520 --> 00:44.400]  свои действия. И в этой модели мы по-прежнему хотим уметь решать задачу консенсуса, то есть задачу
[00:44.400 --> 00:53.520]  репликации через задачу консенсуса. И в прошлый раз мы с вами показали, во-первых, что решать задачу
[00:53.520 --> 00:58.600]  консенсуса в модели с византийскими сбоями, где узлы произвольным образом нарушают протокол,
[00:58.600 --> 01:14.960]  можно, если число узлов в три раза больше, число честных, число реплик в три раза больше, чем число
[01:14.960 --> 01:22.880]  сбоев, которые мы закладываем. Мы доказали вот эту нижнюю оценку двумя способами. Во-первых,
[01:22.880 --> 01:29.640]  для разных условий. Во-первых, мы доказали, что даже в случае, когда у нас сеть синхронная,
[01:29.640 --> 01:36.600]  но когда честный узел может в голове, сбойный узел может в голове моделировать честные узлы,
[01:36.600 --> 01:43.360]  то вот в таких условиях нижнюю оценка справедлива. И во-вторых, мы показали, что если сеть частично
[01:43.360 --> 01:48.080]  синхронная, то даже имея механизм цифровых подписей, даже имея инфраструктуру открытых ключей,
[01:48.080 --> 01:58.480]  мы не можем переживать вот больше, чем f сбоев, если у нас 3f плюс 1. Помимо этой оценки, мы с вами
[01:58.480 --> 02:04.320]  построили алгоритм Ben Oro, который решал такую довольно искусственную задачу бинарного консенсуса,
[02:04.320 --> 02:17.360]  причем решал ее не очень эффективно, а именно ему требовалось 5f плюс одна реплика. Этот результат
[02:17.360 --> 02:23.120]  сам по себе для нас не очень ценен, все-таки мы заботимся о том, чтобы строить что-то прикладное,
[02:23.120 --> 02:30.400]  что-то эффективное. Но все же мы, разбираясь с этим алгоритмом и с такой наивной задачей консенсус
[02:30.400 --> 02:38.080]  изолированной, мы с вами изучили две полезные техники, которые мы с вами сможем добавить в свой
[02:38.080 --> 02:44.160]  арсенал и с помощью них строить что-то более практичное, тема сегодняшнего занятия. Во-первых,
[02:44.160 --> 02:50.160]  мы с вами обратили внимание, что для того, чтобы вообще строить какие-либо алгоритмы в
[02:50.160 --> 02:56.240]  бизантийской модели, нам нужно решать задачу аутентификации. Если узел A получает сообщение от
[02:56.240 --> 03:01.360]  узла B, то узел A должен действительно убедиться, что это сообщение отправлено именно узлом B,
[03:01.360 --> 03:06.480]  а не каким-то другим узлом-злоумышленником, который только представляется как B. И для этого нам
[03:06.480 --> 03:16.840]  был нужен механизм цифровых подписей. Это не единственный механизм, с помощью которого можно
[03:16.840 --> 03:24.080]  решать задачу аутентификации, и мы сегодня рассмотрим другой. Но в первую очередь мы сегодня
[03:24.080 --> 03:28.320]  будем работать именно с цифровыми подписами. Это будет наш основной механизм аутентификации.
[03:28.320 --> 03:36.680]  Вторая техника, которую мы увидели, обобщала ранее известную. Раньше мы работали с простыми
[03:36.680 --> 03:41.920]  системы кворумов, где кворумы пересекаются, по крайней мере, по одному узлу. Сейчас нам этого мало,
[03:41.920 --> 03:47.320]  потому что в пересечении кворумов может быть нечестный византийский узел, и он нам может
[03:47.320 --> 03:56.240]  соврать. Поэтому мы перешли к технике византийских кворумов, где кворумы пересекаются либо по 2f
[03:56.640 --> 04:01.480]  плюс в одном узлу, такая система кворумов называется маскирующей, или по f плюс
[04:01.480 --> 04:06.420]  в одном узлу. В первом случае, когда в пересечении f плюс в один узел, мы знаем, что в пересечении
[04:06.420 --> 04:12.840]  большинству честных, и вот большинство честных могут подавить нечестные просто количества. Если же
[04:12.840 --> 04:17.680]  кворумы пересекаются по крайней мере по f плюс в одном узлу, то мы уверены, что в пересечении есть
[04:17.680 --> 04:23.860]  по крайней мере один честный узел, и, если через кворумы, через пересещение кворумов, передаются
[04:23.860 --> 04:27.860]  аутентифицированные данные, то есть данные, снабженные подписями, то этого
[04:27.860 --> 04:30.860]  будет достаточно. Вот сегодня мы будем использовать именно такие системы
[04:30.860 --> 04:36.860]  кворумов, они называются dissemination, системы кворумов, рассеивающие это так.
[04:36.860 --> 04:42.860]  Но все же, у нас есть нижняя оценка n больше 3f, у нас есть цифровые
[04:42.860 --> 04:46.860]  подписи, у нас есть византийские кворумы.
[04:47.860 --> 04:54.860]  Но мы пока не знаем, достижима ли эта оценка снизу.
[04:54.860 --> 04:58.860]  Можем ли мы построить алгоритм консенсуса, который будет переживать
[04:58.860 --> 05:05.860]  f византийских сбоев и обходиться 3f плюс 1 репликой, а не 5f плюс 1?
[05:05.860 --> 05:10.860]  Вот сегодня мы изучим такой алгоритм, и он будет называться practical BFT.
[05:10.860 --> 05:16.860]  BFT.
[05:16.860 --> 05:28.860]  Это результат 1999 года, авторы Мегель Кастро и Барбара Лисков.
[05:28.860 --> 05:37.860]  И этот алгоритм будет решать незадачу консенсуса в изоляции, как когда-то
[05:37.860 --> 05:41.860]  мы называли single degree praxis, а этот алгоритм будет решать задачу
[05:41.860 --> 05:45.860]  репликации лога, как multipaxis или как raft.
[05:45.860 --> 05:50.860]  И этот алгоритм снова будет работать как multipaxis или raft в некоторые
[05:50.860 --> 05:54.860]  жесткой фиксированные конфигурации, но уже в конфигурации оптимального размера,
[05:54.860 --> 06:03.860]  а именно в конфигурации из 3f плюс 1 узла.
[06:03.860 --> 06:07.860]  Вообще говоря, в византийской модели различают два подхода.
[06:07.860 --> 06:10.860]  Когда мы фиксируем количество реплик и когда мы не фиксируем.
[06:10.860 --> 06:15.860]  Вот когда мы фиксируем количество реплик, такой подход называется permissioned.
[06:15.860 --> 06:23.860]  В следующий раз у нас будет bitcoin, и там число реплик не фиксировано,
[06:23.860 --> 06:26.860]  реплики могут свободно присоединяться к сети и уходить.
[06:26.860 --> 06:31.860]  Такой подход называется permissionless.
[06:31.860 --> 06:35.860]  Ну что, давайте поговорим про то, как этот алгоритм работает.
[06:35.860 --> 06:39.860]  Точнее, не так. Прежде чем говорить про то, как он работает,
[06:39.860 --> 06:41.860]  нужно вообще представить, зачем он нам.
[06:41.860 --> 06:46.860]  Вот он реплицирует некоторый лог, а этот лог нужен для чего?
[06:46.860 --> 06:48.860]  Каково состояние, которое мы будем реплицировать?
[06:48.860 --> 06:51.860]  Раньше мы говорили, что это не очень важно.
[06:51.860 --> 06:54.860]  Пусть мы реплицируем некоторый автомат.
[06:54.860 --> 06:58.860]  В него поступают команды, нам эти команды нужно упорядочить на разных репликах,
[06:58.860 --> 07:01.860]  и эти реплики будут применять в одном и том же порядке
[07:01.860 --> 07:03.860]  и двигаться по полной той же истории.
[07:03.860 --> 07:10.860]  Сегодня мы все еще будем абстрагироваться от конкретного реплицированного состояния,
[07:10.860 --> 07:14.860]  но на будущее скажем, что все-таки оно не совсем произвольное,
[07:14.860 --> 07:16.860]  потому что с этим состоянием работают клиенты,
[07:16.860 --> 07:19.860]  среди которых тоже могут быть византийские узлы,
[07:19.860 --> 07:21.860]  которые тоже могут быть злоумышленниками.
[07:21.860 --> 07:23.860]  Поэтому, вообще говоря, само реплицируемое состояние
[07:23.860 --> 07:26.860]  должно быть устойчиво к нечестным клиентам.
[07:26.860 --> 07:30.860]  Как именно это состояние будет устроено?
[07:30.860 --> 07:32.860]  Мы поговорим в следующий раз на примере Биткоина.
[07:32.860 --> 07:37.860]  Ну а пока лишь скажем, что мы будем использовать немного альтернативную лексику,
[07:37.860 --> 07:41.860]  мы будем говорить не про команды, мы будем говорить про транзакции.
[07:41.860 --> 07:44.860]  И вот пусть у нас есть 3F плюс 1 реплика.
[07:44.860 --> 07:49.860]  Мы зафиксируем, пусть мы готовы пережить один отказ,
[07:49.860 --> 07:52.860]  и поэтому мы используем 4 реплики.
[07:52.860 --> 07:55.860]  На картинках у нас всегда будет сегодня 4 узла.
[07:55.860 --> 08:03.860]  И вот они как-то решают задачу репликации лога.
[08:03.860 --> 08:06.860]  Они реализуют некоторый ordering service.
[08:06.860 --> 08:08.860]  Пока даже не важно каким образом.
[08:08.860 --> 08:12.860]  И с этой системой работает клиент.
[08:12.860 --> 08:17.860]  Клиент отправляет сюда свою транзакцию.
[08:18.860 --> 08:22.860]  Он хочет, чтобы транзакция зафиксировалась
[08:22.860 --> 08:25.860]  в порядковой номеротности на других транзакций,
[08:25.860 --> 08:29.860]  и рано или поздно применилась к некоторому репликированному состоянию.
[08:29.860 --> 08:33.860]  После чего клиент получит некоторый ответ.
[08:39.860 --> 08:43.860]  Мы сейчас говорим про то, как устроен протокол клиента.
[08:48.860 --> 08:52.860]  Во-первых, заметим, что с византийской системой
[08:52.860 --> 08:55.860]  вот так вот прям взаимодействовать нельзя.
[08:55.860 --> 08:58.860]  Мы могли так взаимодействовать с мультипакс и с мультирафтом,
[08:58.860 --> 09:01.860]  потому что каждый узел вел себя честно.
[09:01.860 --> 09:05.860]  Но сейчас, если мы отправляем свою транзакцию к какому-то конкретному узлу,
[09:05.860 --> 09:09.860]  а он окажется с византийским, то он может нам просто выдумать ответ.
[09:09.860 --> 09:12.860]  Базовое правило любой византийской системы,
[09:12.860 --> 09:16.860]  мы никогда не можем доверять ответу какого-то конкретного узла.
[09:16.860 --> 09:20.860]  Мы всегда должны доверять только группе узлов.
[09:20.860 --> 09:23.860]  Поэтому на месте клиента нам мало дождаться одного ответа.
[09:23.860 --> 09:28.860]  Видимо, нам нужно дождаться некоторого количества ответов от разных реплик.
[09:28.860 --> 09:31.860]  У нас всего 3f плюс 1 реплика.
[09:31.860 --> 09:36.860]  Из них f могут быть византийскими или просто отказать.
[09:36.860 --> 09:41.860]  Поэтому мы можем рассчитывать на то, что мы дождемся 2f плюс 1 ответа.
[09:46.860 --> 09:56.860]  Эти ответы могут быть разными, потому что среди реплик, которые ответили клиенту,
[09:56.860 --> 09:59.860]  есть честные, есть византийские.
[09:59.860 --> 10:05.860]  Но мы предполагаем, что все честные реплики ответили одинаково.
[10:05.860 --> 10:11.860]  И мы знаем, что среди... раз всего мы получили 2f плюс 1 ответ,
[10:11.860 --> 10:21.860]  то среди них есть, по крайней мере, среди этих ответов есть не более чем f ответов от византийских реплик,
[10:21.860 --> 10:25.860]  а значит, по крайней мере, f плюс 1 ответ от честной реплики.
[10:25.860 --> 10:29.860]  И вот эти честные ответы смогут перекрыть византийские.
[10:29.860 --> 10:35.860]  Что мы делаем? Мы на месте клиента дожидаемся, ждем такого количества ответов
[10:35.860 --> 10:40.860]  и выбираем ответ, который повторяется, по крайней мере, f плюс 1 раз.
[10:50.860 --> 10:56.860]  Разумеется, мы должны учитывать, что византийские узлы могут пробовать представляться другими узлами,
[10:56.860 --> 11:00.860]  поэтому все респонсы должны быть снабжены цифровыми подписами.
[11:00.860 --> 11:05.860]  То есть, когда какая-то реплика отвечает, то она подписывает свой ответ.
[11:08.860 --> 11:11.860]  Так что на месте клиента мы дожидаемся такого количества ответов,
[11:11.860 --> 11:17.860]  выбираем f плюс 1 одинаковый, и мы теперь уверены, что среди этих f плюс 1 одинакового
[11:17.860 --> 11:20.860]  есть ответ, по крайней мере, от одного честного узла.
[11:20.860 --> 11:26.860]  Ну а значит, если честные узлы корректно решают задачу консенсуса,
[11:26.860 --> 11:34.860]  то значит и все честные узлы дали бы такой же ответ, так что мы выбираем его.
[11:34.860 --> 11:41.860]  Правда, в таком протоколе есть неудобство, а именно клиент отправляет запрос одному узлу,
[11:41.860 --> 11:46.860]  получит ответ от многих. Нам все же было бы удобно работать в модели клиент-сервер,
[11:46.860 --> 11:50.860]  где мы общаемся только с одним узлом через некоторое соединение.
[11:51.860 --> 11:56.860]  В принципе, такое техническое ограничение, желание сделать именно так,
[11:56.860 --> 11:59.860]  никак не мешает нам воспользоваться тем же самым протоколом.
[11:59.860 --> 12:05.860]  Просто пусть вот этот набор сообщений, которые служат доказательствам того,
[12:05.860 --> 12:11.860]  что честные узлы выбрали некоторый ответ, может накапливать не сам клиент,
[12:11.860 --> 12:15.860]  а может накапливать узел, с которым клиент общается.
[12:16.860 --> 12:20.860]  То есть мы вот эти стрелки сотрем,
[12:25.860 --> 12:31.860]  и пусть другие реплики ответят не напрямую клиенту,
[12:31.860 --> 12:34.860]  а вот тому узлу, который с клиентом общался.
[12:36.860 --> 12:42.860]  И вот уже этот узел отправит клиенту не один респонс,
[12:42.860 --> 12:48.860]  а вот такой набор респонсов, каждый из которых снабжен цифровой подписью.
[12:48.860 --> 12:53.860]  И вот этот набор подписанных ответов мы будем называть сегодня
[12:53.860 --> 12:55.860]  коронным тертификатом.
[12:55.860 --> 13:24.860]  Вот именно с помощью коронных тертификатов
[13:24.860 --> 13:28.860]  в византийской системе, конкретно в Practical BFT,
[13:28.860 --> 13:32.860]  узлы смогут доказывать другим что-то про третьи узлы.
[13:32.860 --> 13:36.860]  То есть здесь один узел может сказать нам, что ответная система именно такой,
[13:36.860 --> 13:38.860]  и приложить вот этот коронный сертификат,
[13:38.860 --> 13:42.860]  тем самым клиент сможет действительно проверить, что его не обманули.
[13:43.860 --> 13:47.860]  Правда тут можно быть еще аккуратнее и подумать над тем,
[13:47.860 --> 13:51.860]  что вдруг византийский узел отправит коронный сертификат,
[13:51.860 --> 13:53.860]  но просто для другой транзакции.
[13:53.860 --> 13:57.860]  Поэтому мы можем сделать еще более аккуратно
[13:57.860 --> 14:04.860]  и сказать, что у нас респонс привязан к некоторому дайджесту,
[14:04.860 --> 14:12.860]  где дайджест это криптографический хэш транзакции.
[14:12.860 --> 14:16.860]  Вот если транзакции уникальные, то есть у них хэши будут разными,
[14:16.860 --> 14:22.860]  ну по модулю того, что конечно в хэш функции может возникнуть какая-нибудь коллизия.
[14:22.860 --> 14:28.860]  Ну вот, если все же транзакции можно различать по хэшам,
[14:28.860 --> 14:32.860]  а мы в следующий раз увидим в Биткоине, что действительно это можно делать,
[14:32.860 --> 14:36.860]  то пусть реплики, которые отвечают клиенту,
[14:36.860 --> 14:41.860]  привязывают свои ответы к хэшу транзакции, подписывают свой ответ,
[14:41.860 --> 14:45.860]  и тогда здесь мы на месте клиента будем уверены,
[14:45.860 --> 14:49.860]  что нам дали сертификат именно для нашей транзакции.
[14:52.860 --> 14:56.860]  Ну и это конечно еще не все, потому что что же делать клиенту,
[14:56.860 --> 15:00.860]  который просто не получил ответ от реплики?
[15:00.860 --> 15:04.860]  Он конечно же завел тайм-аут, завел таймер, отправил свою транзакцию,
[15:04.860 --> 15:08.860]  и если этот таймер протух, если тайм-аут истек,
[15:08.860 --> 15:11.860]  то клиент вообще говоря не понимает, что происходит.
[15:11.860 --> 15:14.860]  Может быть, конечно, этот узел умер, а может быть, этот узел злоумышленника
[15:14.860 --> 15:19.860]  он намеренно умолчал об этой транзакции и просто игнорировал ее.
[15:19.860 --> 15:22.860]  Вот нужно какие-то дополнительные действия придумывать,
[15:22.860 --> 15:26.860]  но мы к ним вернемся позже, а пока заметим еще одну важную деталь.
[15:26.860 --> 15:33.860]  Вот здесь клиент, работая с системой, должен проверять цифровые подписи ответов от реплик.
[15:33.860 --> 15:37.860]  Ну и для того, чтобы их проверять, он собственно должен понимать,
[15:37.860 --> 15:41.860]  какие открытые ключи у этих самых реплик.
[15:41.860 --> 15:44.860]  Для этого нам нужна некоторая вспомогательная инфраструктура.
[15:44.860 --> 15:47.860]  Ну вот для того, чтобы вообще пользоваться цифровыми подписями,
[15:47.860 --> 15:51.860]  нам нужна цифровая инфраструктура, которая называется удостоверяющим центром.
[15:51.860 --> 15:58.860]  Вот представим себе, что вы браузер,
[15:58.860 --> 16:07.860]  и вы идете общаться с некоторым сервером по безопасному соединению.
[16:10.860 --> 16:16.860]  Вы должны узнать открытый ключ у этого сервера, чтобы дальше там работала криптография,
[16:16.860 --> 16:19.860]  чтобы работало безопасное соединение.
[16:19.860 --> 16:26.860]  Но если вам сервер отправит просто пару, я, сервер, и вот мой открытый ключ,
[16:26.860 --> 16:30.860]  то, конечно же, у вас нет оснований ему верить.
[16:30.860 --> 16:34.860]  А что если это с вами разговаривает на самом деле злоумышленник?
[16:34.860 --> 16:47.860]  Поэтому этот документ, который связывает identity и открытый ключ,
[16:47.860 --> 16:51.860]  нужно чем-то подкрепить.
[16:51.860 --> 16:53.860]  Но вот браузер серверу не доверяет.
[16:53.860 --> 16:58.860]  У серверов много разных на свете, мы не можем доверять каждому по умолчанию.
[16:58.860 --> 17:07.860]  Но, может быть, есть некоторый участник удостоверяющий центр.
[17:14.860 --> 17:17.860]  И мы считаем, что вот этому участнику доверяют все.
[17:17.860 --> 17:27.860]  Доверяют в том смысле, что для него открытый ключ этого Си всем известен.
[17:27.860 --> 17:33.860]  И тогда, чтобы сервер мог представиться нам, чтобы он мог сообщить нам открытый ключ,
[17:33.860 --> 17:39.860]  он идет в удостоверяющий центр, и удостоверяющий центр выпускает вот такой документ,
[17:39.860 --> 17:47.860]  который называется цифровым сертификатом, который связывает С и открытый ключ,
[17:47.860 --> 17:54.860]  и этот сертификат подписан секретным ключом удостоверяющего центра.
[17:55.860 --> 17:58.860]  После чего сервер может отправить нам этот сертификат,
[17:58.860 --> 18:04.860]  и если мы доверяем С, то значит, мы теперь можем доверять и серверу.
[18:08.860 --> 18:12.860]  Вот эта конструкция называется инфраструктура открытых ключей.
[18:16.860 --> 18:19.860]  И наш протокол, раз он пользует этими цифровыми подписями,
[18:19.860 --> 18:25.860]  раз клиент все это проверяет, эти кормные сертификаты, ему нуждается инфраструктура.
[18:25.860 --> 18:31.860]  Вопрос, почему мы доверяем в конце концов какому-то одному удостоверяющему центру?
[18:31.860 --> 18:37.860]  Ведь весь смысл нашей конструкции состоит в том, что мы можем взять много реплик
[18:37.860 --> 18:43.860]  и разместить, доверить их эксплуатацию разным организациям.
[18:43.860 --> 18:47.860]  Но говорят в этом контексте про консорциям, есть разные организации,
[18:47.860 --> 18:50.860]  каждый из них отвечает за какую-то группу реплик,
[18:50.860 --> 18:53.860]  и мы каждой конкретной организации на месте клиента не доверяем,
[18:53.860 --> 19:00.860]  но мы все же считаем, что две трети этих организаций, две трети реплик будут честными.
[19:00.860 --> 19:05.860]  Нам этого достаточно. А тут мы почему-то доверяем одному удостоверяющему центру.
[19:05.860 --> 19:08.860]  Но это на самом деле не страшно.
[19:08.860 --> 19:12.860]  Можно доверять и нескольким удостоверяющим центрам,
[19:12.860 --> 19:16.860]  и тогда можно отсеять каких-то подозрительных.
[19:16.860 --> 19:24.860]  То есть не то чтобы у нас есть одна единственная точка доверия, их можно дублировать.
[19:24.860 --> 19:30.860]  И если говорить про реальную жизнь, то тут не то чтобы прям один удостоверяющий центр,
[19:30.860 --> 19:33.860]  потому что он бы, конечно, не выдержал такой нагрузки.
[19:33.860 --> 19:38.860]  На самом деле в жизни у нас есть целая иерархия удостоверяющих центров.
[19:38.860 --> 19:43.860]  И когда вы приходите к серверу, он дает вам сертификат, который подписан
[19:43.860 --> 19:46.860]  с некоторым удостоверяющим центром.
[19:46.860 --> 19:48.860]  Откуда вы знаете его сертификат?
[19:48.860 --> 19:51.860]  Откуда вы знаете его открытый ключ?
[19:51.860 --> 19:54.860]  Для этого ключа есть свой собственный сертификат,
[19:54.860 --> 19:59.860]  который подписан удостоверяющим центром более высокого уровня.
[19:59.860 --> 20:02.860]  Ну а у этого удостоверяющего центра более высокого уровня снова есть некоторые родители,
[20:02.860 --> 20:04.860]  которые выпускают для него сертификат.
[20:04.860 --> 20:07.860]  Ну, и в конце концов мы приходим в некоторые корневые удостоверяющие центр.
[20:07.860 --> 20:13.860]  и если вы браузер, то просто вы в себе несете сертификат
[20:13.860 --> 20:16.860]  этого самого корневого удостоверяющего центра.
[20:16.860 --> 20:19.860]  После этого вы можете спуститься по цепочке и проверить
[20:19.860 --> 20:26.860]  сертификат какого-то конкретного узла.
[20:26.860 --> 20:28.860]  В общем, такая инфраструктура нам требуется.
[20:28.860 --> 20:30.860]  Мы ей сегодня не явно пользуемся,
[20:30.860 --> 20:33.860]  просто потому что мы пользуемся цифровыми подписами.
[20:33.860 --> 20:36.860]  Итак, мы обсудили протокол клиента,
[20:36.860 --> 20:38.860]  как ему получить ответ от системы,
[20:38.860 --> 20:43.860]  как среди разных ответов выбрать ответ честных узлов,
[20:43.860 --> 20:46.860]  в предположении, что византийских узлов все-таки не больше,
[20:46.860 --> 20:48.860]  чем заложенный параметр f.
[20:48.860 --> 20:50.860]  Ну а если больше, то рассчитывать тут не на что, конечно.
[20:50.860 --> 20:52.860]  Мы об этом в прошлый раз говорили.
[20:52.860 --> 20:56.860]  А теперь нужно разобраться, что все-таки внутри этого контуры происходит.
[20:56.860 --> 20:59.860]  Как именно будет устроен сегодняшний алгоритм?
[20:59.860 --> 21:03.860]  Вот пока вся эта конструкция, этот алгоритм мало зависела.
[21:03.860 --> 21:05.860]  Зависела, но не правда, она зависела,
[21:05.860 --> 21:08.860]  но только в том смысле, что этот алгоритм, он permission,
[21:08.860 --> 21:10.860]  то есть он фиксирует число реплика.
[21:10.860 --> 21:12.860]  Теперь перейдем внутрь этого контуры
[21:12.860 --> 21:15.860]  и поговорим, как устроен PBFT.
[21:15.860 --> 21:18.860]  Этот алгоритм возник не на пустом месте,
[21:18.860 --> 21:20.860]  он развивает идеи другого алгоритма,
[21:20.860 --> 21:23.860]  который называется just-time replication.
[21:29.860 --> 21:39.860]  Это алгоритм, который реплицирует лог
[21:39.860 --> 21:41.860]  на не византийской модели, а в обычной,
[21:41.860 --> 21:43.860]  где есть рестарты и отказы узлов.
[21:43.860 --> 21:46.860]  То есть это некоторый аналог мультипаксиса и RAFTA.
[21:46.860 --> 21:50.860]  Но любопытно, что этот алгоритм был придуман раньше и RAFTA,
[21:50.860 --> 21:52.860]  который был придуман в 2012-13 году,
[21:52.860 --> 21:56.860]  и мультипаксиса, который придуман в начале 90-х.
[21:56.860 --> 22:01.860]  Just-time replication придуман в 1988 году.
[22:04.860 --> 22:10.860]  Но так случилось, что он не получил популярности,
[22:10.860 --> 22:12.860]  не получил распространения,
[22:12.860 --> 22:15.860]  и мы знаем про мультипаксис, мы знаем про RAFTA,
[22:15.860 --> 22:18.860]  а про just-time replication мы говорим в контексте
[22:18.860 --> 22:22.860]  такого алгоритма, который опирается на VR.
[22:22.860 --> 22:25.860]  И вообще говоря, это удивительно,
[22:25.860 --> 22:28.860]  потому что just-time replication — это алгоритм,
[22:28.860 --> 22:34.860]  который очень разумно, очень понятно устроен.
[22:34.860 --> 22:37.860]  В нём, как и в мультипаксисе, как и в RAFTA,
[22:37.860 --> 22:39.860]  есть понятие эпохи.
[22:39.860 --> 22:42.860]  Только название у этих эпох, опять, особенное.
[22:42.860 --> 22:46.860]  В паксисе это были ballot numbers, в RAFTA это были термы.
[22:46.860 --> 22:50.860]  В just-time replication эпохи называются view.
[22:50.860 --> 22:53.860]  Отсюда и название протокола.
[22:55.860 --> 22:59.860]  И к этим эпохам, к этим view, как и в RAFTA,
[22:59.860 --> 23:02.860]  привязано понятие лидера, привязан лидер.
[23:02.860 --> 23:05.860]  Узел, который занимается упорядочиванием
[23:05.860 --> 23:08.860]  всех команд, транзакций, которые поступают от клиентов.
[23:08.860 --> 23:11.860]  Этот лидер называется primary.
[23:13.860 --> 23:16.860]  Primary всегда находится в некотором терме.
[23:20.860 --> 23:24.860]  Опять же, just-time replication использует эти view
[23:24.860 --> 23:28.860]  ровно таким же способом, как их использует RAFTA,
[23:28.860 --> 23:32.860]  просто для того, чтобы блокировать устаревших лидеров.
[23:32.860 --> 23:35.860]  Если система перешла в новую эпоху,
[23:35.860 --> 23:38.860]  если большинство узлов следует уже за новым primary,
[23:38.860 --> 23:42.860]  то старый primary не может закомитить новую транзакцию,
[23:42.860 --> 23:45.860]  потому что в пересечении будут реплики,
[23:45.860 --> 23:48.860]  в пересечение его кворума и кворума, которые уже проголосовали
[23:48.860 --> 23:51.860]  и в праймари будет реплика, которая отвергнет,
[23:51.860 --> 23:57.860]  глядя на эту view, сообщение от праймари из прошлой эпохи.
[23:57.860 --> 24:01.860]  На этом сходство не заканчивается, их довольно много.
[24:01.860 --> 24:06.860]  Я бы сказал, что этот алгоритм довольно сильно напоминает RAFTA,
[24:06.860 --> 24:10.860]  потому что, так же, как и в RAFTA, этот алгоритм декомпозирован
[24:10.860 --> 24:16.860]  по двум фазам. Фаза, где есть primary
[24:16.860 --> 24:19.860]  и он занимается репликацией,
[24:19.860 --> 24:21.860]  и есть фаза, где выбирается новый primary,
[24:21.860 --> 24:23.860]  она называется viewchange.
[24:23.860 --> 24:26.860]  Вообще, когда авторы RAFTA писали свою статью,
[24:26.860 --> 24:29.860]  они там отдельно говорят, они сравнивают свой алгоритм
[24:29.860 --> 24:31.860]  с мультипаксосом и говорят, что он проще,
[24:31.860 --> 24:34.860]  потому что в мультипаксосе выбрана неверная декомпозиция,
[24:34.860 --> 24:37.860]  что задача репликации лого поделена по слотам,
[24:37.860 --> 24:40.860]  и в каждом слоте решаются свои независимые задачи консенсуса,
[24:40.860 --> 24:44.860]  и ее решение не имеет какого-то осязаемого физического смысла.
[24:44.860 --> 24:47.860]  Сложно увидеть физический смысл в sync-decrep-аксосе,
[24:47.860 --> 24:49.860]  пока мы его не промасштабируем на весь лог.
[24:49.860 --> 24:51.860]  Только тогда у нас появится понятие эпохи,
[24:51.860 --> 24:55.860]  лидера, блокировки старых лидеров и так далее.
[24:55.860 --> 24:58.860]  Так вот, эта идея декомпозиции по фазам,
[24:58.860 --> 25:01.860]  по фазе выбора лидера и по фазе репликации,
[25:01.860 --> 25:03.860]  она была придумана еще в 1988 году.
[25:03.860 --> 25:07.860]  Причем мне кажется, что даже в этом подходе
[25:07.860 --> 25:09.860]  была выбрана более удачная лексика,
[25:09.860 --> 25:13.860]  потому что в RAFTA смена эпохи называется выбором лидера,
[25:13.860 --> 25:17.860]  а в view-stamped replication она называется view-change.
[25:19.860 --> 25:22.860]  И мне кажется, что этот термин лучше подходит,
[25:22.860 --> 25:25.860]  потому что он лучше отражает суть сложность задачи.
[25:25.860 --> 25:28.860]  Сложность задачи не в том, чтобы выбрать нового лидера,
[25:28.860 --> 25:30.860]  а в том, чтобы аккуратно сменить эпоху
[25:30.860 --> 25:33.860]  и не забыть все ранее закоммиченные команды.
[25:33.860 --> 25:35.860]  Напомню, что в RAFTA доказывали,
[25:35.860 --> 25:37.860]  что транзакция команды закоммичена,
[25:37.860 --> 25:39.860]  если она переживает смену эпохи,
[25:39.860 --> 25:45.860]  и она будет непременно находиться в логе лидера любого будущего терма.
[25:45.860 --> 25:48.860]  Вот сложность в том, чтобы аккуратно эпоху сменить.
[25:48.860 --> 25:51.860]  И лексика view-stamped replication эта сложность подчеркивает.
[25:52.860 --> 25:56.860]  Почему же алгоритм, если он такой разумный, был надолго забыт?
[25:56.860 --> 26:01.860]  Дело в том, что оригинальная статья вышла довольно, кажется, запутанной,
[26:01.860 --> 26:05.860]  и там алгоритм view-stamped replication, сам алгоритм репликации,
[26:05.860 --> 26:09.860]  в том, что эпоха декомпозирован от каких-то ненужных инженерных подробностей,
[26:09.860 --> 26:14.860]  но, кажется, уже в 2000-х годах авторы этого алгоритма
[26:14.860 --> 26:16.860]  переписали статью заново,
[26:16.860 --> 26:19.860]  написали статью, которая называется view-stamped replication revisited,
[26:19.860 --> 26:22.860]  и вот она уже очень хорошая, очень понятная,
[26:22.860 --> 26:24.860]  и я всем рекомендую ее прочитать.
[26:24.860 --> 26:30.860]  Ну хорошо, мы собираемся сегодня для репликации использовать
[26:30.860 --> 26:33.860]  примерно такие же идеи.
[26:33.860 --> 26:35.860]  У нас четыре реплики.
[26:35.860 --> 26:39.860]  Давайте мы нарисуем процедуру репликации.
[26:45.860 --> 26:47.860]  У нас будут четыре реплики.
[26:47.860 --> 27:05.860]  И среди них одна из реплик назначена primary.
[27:05.860 --> 27:21.860]  Давайте немного передвинем нашу картинку.
[27:21.860 --> 27:24.860]  По-другому организуем пространство.
[27:24.860 --> 27:29.860]  Нарисуем ее вот здесь, чтобы места было побольше.
[27:35.860 --> 27:46.860]  Вторая реплика является primary.
[27:46.860 --> 27:50.860]  Ее функция упорядочивать транзакции,
[27:50.860 --> 27:53.860]  которые поступают от пользователей.
[27:53.860 --> 27:56.860]  Мы пока не говорим, откуда этот primary взялся,
[27:56.860 --> 27:58.860]  как именно он выбран.
[27:58.860 --> 28:01.860]  Пусть он уже есть, но и мы будем пользоваться этим фактом.
[28:01.860 --> 28:06.860]  Он получает транзакцию от пользователя,
[28:06.860 --> 28:12.860]  и его задача выбрать для этой транзакции порядковый номер,
[28:12.860 --> 28:14.860]  выбрать ее позицию в логе.
[28:14.860 --> 28:20.860]  После чего primary раздаст эту транзакцию с присвоенным порядковым номером другим репликом.
[28:20.860 --> 28:22.860]  Это первая фаза.
[28:22.860 --> 28:37.860]  Здесь мы отправляем сообщение, которое называется prepare.
[28:37.860 --> 28:45.860]  Primary говорит остальным репликам, что в текущей эпохе В
[28:45.860 --> 28:51.860]  я присвоил порядковый номер S транзакции с дайджестом,
[28:51.860 --> 28:57.860]  здесь криптографическим хэшом D.
[28:57.860 --> 29:01.860]  И разумеется, он свое сообщение подписывает.
[29:01.860 --> 29:03.860]  Своим секретным ключом.
[29:03.860 --> 29:07.860]  И отдельно предлагает к этому prepare собственно отправленную транзакцию.
[29:07.860 --> 29:13.860]  То есть в этом сообщении только хэш, а здесь отдельно сама транзакция.
[29:13.860 --> 29:18.860]  Обратите внимание, что сегодня мы говорим именно про сообщение.
[29:18.860 --> 29:24.860]  Вот скажем, в протоколе RAFT в статье используется термин RPC, то есть удаленный вызов.
[29:24.860 --> 29:28.860]  Вот нам сегодня важно, что это не RPC, это именно сообщение,
[29:28.860 --> 29:32.860]  потому что мы эти сообщения дальше будем пересылать другим узлам.
[29:32.860 --> 29:35.860]  Но чуть позже увидим, как это будет работать.
[29:35.860 --> 29:39.860]  Итак, у нас есть реплики, они получили от primary команду,
[29:39.860 --> 29:45.860]  потому что нужно положить в слот S транзакцию с дайджестом D вот в текущей эпохе.
[29:45.860 --> 29:54.860]  Но, конечно же, да, и вот в USTMP replication дальше эти реплики добавляли себе в лог эту транзакцию,
[29:54.860 --> 29:57.860]  отправляли подтверждение primary, primary собирал quorum,
[29:57.860 --> 30:01.860]  и в общем команда после этого коммитилась.
[30:01.860 --> 30:08.860]  Разумеется, в нашей византийской модели такого наивного протокола будет уже недостаточно.
[30:08.860 --> 30:11.860]  Потому что просто-напросто primary может быть византийским,
[30:11.860 --> 30:15.860]  и он может не исполнить функции, которые у него возложены.
[30:15.860 --> 30:21.860]  Вот давайте подумаем, что может делать primary, как он может нарушать протокол.
[30:21.860 --> 30:25.860]  Ну скажем, он может получить транзакцию и продублировать ее,
[30:25.860 --> 30:29.860]  то есть назначить ей сразу несколько порядковых номеров.
[30:29.860 --> 30:34.860]  Или он может транзакции игнорировать, может игнорировать все транзакции,
[30:34.860 --> 30:39.860]  может игнорировать транзакции какого-то пользователя, которого primary не любит.
[30:39.860 --> 30:45.860]  Не знаю почему. То есть он может выкидывать какие-то конкретные транзакции.
[30:45.860 --> 30:53.860]  Ну и наконец, primary может назначать транзакции в разном порядке для разных реплик.
[30:53.860 --> 31:00.860]  Или это можно сказать по-другому, что для какого-то порядкового номера S
[31:00.860 --> 31:07.860]  primary может назначить разные транзакции разным репликам.
[31:07.860 --> 31:14.860]  Можно придумывать еще некоторые случаи византийского поведения, но основные эти.
[31:14.860 --> 31:22.860]  И наша задача сейчас придумать, а как же мы можем с таким поведением византийского primary справиться.
[31:22.860 --> 31:26.860]  Хотя стойте, нужно подумать над другим вопросом.
[31:26.860 --> 31:29.860]  А зачем мы вообще выбрали византийского primary?
[31:29.860 --> 31:36.860]  Может быть наша беда в этом, может быть нам не нужно справляться со всеми этими действиями нечестного primary,
[31:36.860 --> 31:39.860]  может быть нам просто нужно изменить протокол выбора этого primary.
[31:39.860 --> 31:47.860]  Конечно же так не выйдет, потому что primary может начать вести себя по-византийски уже после того,
[31:47.860 --> 31:52.860]  как он выбран primary. А до этого он может вести себя честно, вводя другие заблуждения.
[31:52.860 --> 31:55.860]  То есть он злоумышленник, но он ведет себя честно, соблюдает протокол до тех пор,
[31:55.860 --> 32:01.860]  пока он не станет primary, а после этого он уже начинает действовать вот так вот вредно.
[32:01.860 --> 32:06.860]  Дублировать транзакции, выкидывать транзакции, назначить разные транзакции в один слот.
[32:06.860 --> 32:11.860]  Так что мы от этого обязаны защититься на уровне протокола.
[32:11.860 --> 32:15.860]  Давайте с каждой проблемой разберемся.
[32:15.860 --> 32:23.860]  Начнем с дублирования транзакций. Вот как раз эту проблему на уровне протокола репликации, наверное, решать не стоит.
[32:23.860 --> 32:29.860]  Мне кажется, что эту проблему нужно делегировать вот тому состоянию выше, которое мы реплицируем.
[32:29.860 --> 32:36.860]  Вот если вы вспомните рафты, если вы писали в домашней работе в рафте exactly once,
[32:36.860 --> 32:42.860]  то и думали про снапшоты, чтобы обрезать лог, то вы должны понимать,
[32:42.860 --> 32:48.860]  что exactly once реализуется скорее на уровне автомата, а не на уровне самого рафта.
[32:48.860 --> 32:54.860]  От рафта требуется семантика at least once, чтобы каждая команда была реплицирована по крайней мере один раз.
[32:54.860 --> 32:59.860]  А вот exactly once или, может быть, at most once после некоторого TTL
[32:59.860 --> 33:06.860]  вы должны гарантировать уже на уровне самого реплицируемого состояния, которое потом снапшотится.
[33:06.860 --> 33:13.860]  Короче говоря, мы эту задачу обсудим, но обсудим в следующий раз и на уровне,
[33:13.860 --> 33:18.860]  например, биткоина, на уровне криптовалюты, которую мы будем строить.
[33:18.860 --> 33:22.860]  Вот там дублирование транзакций никак не помешает.
[33:22.860 --> 33:28.860]  Так что сегодня это не проблема, если primary задублирует транзакцию.
[33:28.860 --> 33:31.860]  Подозрительно, но не смертельно.
[33:31.860 --> 33:39.860]  Но вот если primary выкинет транзакцию, то это уже печально, потому что мы теряем свойство liveness.
[33:39.860 --> 33:46.860]  Для клиента выглядит так. Мы отправляем систему транзакцию и ожидаем, что eventually она упорядочится относительно других транзакций
[33:46.860 --> 33:52.860]  и применится к нашему реплицированному состоянию.
[33:52.860 --> 33:57.860]  Тут наш транзакцию может выкинуть.
[33:57.860 --> 34:03.860]  Ну хорошо, давайте вернемся на эту картинку и подумаем, как справиться с таким поведением primary.
[34:03.860 --> 34:06.860]  Что делать, если он выкидывает нашу транзакцию?
[34:06.860 --> 34:15.860]  Видимо, мы не получаем ответа, то есть мы не получаем этого кворомного сертификата.
[34:15.860 --> 34:21.860]  У нас истекает некоторый таймер.
[34:21.860 --> 34:27.860]  Что после этого мы делаем? Мы, конечно, подозреваем primary.
[34:27.860 --> 34:32.860]  И мы этим своим соображением, что primary, возможно, византийский,
[34:32.860 --> 34:36.860]  но может быть он просто отказал, может быть он византийский, мы это пока не понимаем,
[34:36.860 --> 34:45.860]  и мы этим делимся с остальными репликами.
[34:45.860 --> 34:52.860]  Мы отправляем им транзакцию.
[34:52.860 --> 34:57.860]  И что делает каждая реплика? Она просто сама теперь становится клиентом.
[34:57.860 --> 35:02.860]  То есть смотрите, вот здесь клиент, не дождавшись ответа от системы,
[35:02.860 --> 35:05.860]  говорит остальным репликам, что я отправлял транзакцию,
[35:05.860 --> 35:08.860]  отправлял транзакцию, видимо, primary, да, я не проговорил это,
[35:08.860 --> 35:13.860]  конечно же клиент общается с primary.
[35:13.860 --> 35:17.860]  Так вот, клиент не получил от primary ответа,
[35:17.860 --> 35:21.860]  пожаловался на этого primary другим узлам,
[35:21.860 --> 35:27.860]  но сама по себе такая жалоба не должна приводить к тому, что узлы, скажем,
[35:27.860 --> 35:31.860]  перевыберут новую primary, потому что эта жалоба, ну потому что клиент мог
[35:31.860 --> 35:35.860]  просто оклеветать primary, он мог ничего ему не отправлять.
[35:35.860 --> 35:40.860]  Так что что делает честный узел, который получил транзакцию от клиента в обход primary?
[35:40.860 --> 35:44.860]  Он сам перепроверяет верно ли, что primary честный, он сам становится клиентом
[35:44.860 --> 35:48.860]  и отправляет primary эту транзакцию.
[35:48.860 --> 35:52.860]  Но я вот воспользуюсь этой стрелочкой, она имела другой смысл,
[35:52.860 --> 35:55.860]  ну вот я, ладно, нарисую новую.
[35:55.860 --> 35:59.860]  Реплика отправляет эту транзакцию на primary.
[35:59.860 --> 36:07.860]  И теперь эта реплика знает, что если от primary транзакции не приходят
[36:07.860 --> 36:11.860]  по истечении некоторого тайм-аута,
[36:11.860 --> 36:16.860]  то primary, видимо, ее выкидывает, видимо, primary нарушает свой протокол.
[36:16.860 --> 36:22.860]  И тогда уже, видимо, эта реплика захочет primary поменять.
[36:22.860 --> 36:27.860]  Пока реплика не знает ничего про эту транзакцию, то она, конечно же,
[36:27.860 --> 36:30.860]  может доверять текущему primary.
[36:30.860 --> 36:34.860]  В конце концов, византийский primary может не отправлять транзакции
[36:34.860 --> 36:37.860]  остальным репликам, но может отправлять какие-нибудь, скажем,
[36:37.860 --> 36:40.860]  хардбиты о том, что он все еще жив.
[36:40.860 --> 36:45.860]  И честная реплика, пока она не поговорила с клиентом напрямую,
[36:45.860 --> 36:47.860]  она не различает две ситуации.
[36:47.860 --> 36:49.860]  Когда у primary просто не было транзакции,
[36:49.860 --> 36:52.860]  или когда клиент ее отправил, а primary ее проигнорировал.
[36:52.860 --> 36:55.860]  Вот для того, чтобы эти два сценария отличить,
[36:55.860 --> 36:57.860]  клиент сам отправляет транзакцию репликам,
[36:57.860 --> 37:01.860]  реплики пересылают ее, заводят у себя таймер.
[37:01.860 --> 37:06.860]  И если этот таймер истекает, а primary так и не прислал нам
[37:06.860 --> 37:10.860]  сообщения при API.PR, то реплика справедливо считает,
[37:10.860 --> 37:14.860]  что primary византийский и, наверное, его меняет.
[37:14.860 --> 37:17.860]  Про смену эпохи мы поговорим чуть позже.
[37:17.860 --> 37:22.860]  Вернемся пока на эту картинку и вспомним, что мы разбирали три проблемы.
[37:22.860 --> 37:25.860]  Дублирование транзакций, выкидывание транзакций.
[37:25.860 --> 37:27.860]  Вот с выкидыванием транзакций мы разобрались.
[37:27.860 --> 37:30.860]  По модулю того, что мы пока не описали, как именно поменять эпоху,
[37:30.860 --> 37:32.860]  как именно поменять primary.
[37:32.860 --> 37:36.860]  Но если мы это умеем делать, то, значит, и с таким поведением тоже справимся.
[37:36.860 --> 37:42.860]  И остается третья проблема, а именно, что primary по разному порядочевой транзакции
[37:42.860 --> 37:47.860]  выбирает разных реплик или для некоторого порядкового номера S,
[37:47.860 --> 37:53.860]  для некоторого слота primary выбирает разные транзакции для разных реплик.
[37:53.860 --> 37:55.860]  Давайте я здесь поясню.
[37:55.860 --> 38:01.860]  V – это view, в котором лежит primary.S – это слот, порядковый номер.
[38:01.860 --> 38:14.860]  Итак, реплики ждут prepare, получают его, но, правда, они не понимают,
[38:14.860 --> 38:18.860]  может быть, primary раздал разные транзакции этим самым репликам.
[38:18.860 --> 38:22.860]  Доверять primary, вообще говоря, оснований нет.
[38:22.860 --> 38:26.860]  Точнее, мы надеемся, что он честный, но на всякий случай мы должны проверить,
[38:26.860 --> 38:31.860]  что он все же не обманывает нас.
[38:31.860 --> 38:39.860]  Для этого мы заводим дополнительную фазу, где каждая реплика посылает другим репликам,
[38:39.860 --> 38:44.860]  здесь происходит такая квадратичная коммуникация, все общаются со всеми,
[38:44.860 --> 38:54.860]  каждая реплика посылает другим сообщение, которое мы назовем,
[38:54.860 --> 39:00.860]  ну не мы назовем, в фибиофейне так называются, сообщение prepare.
[39:00.860 --> 39:08.860]  Сообщение означает, что я и эта реплика получила от primary в эпохе V,
[39:08.860 --> 39:13.860]  в слоте S, транзакцию с дайджестом D.
[39:13.860 --> 39:17.860]  И, разумеется, я свое сообщение и эта реплика подписываю.
[39:17.860 --> 39:29.860]  И теперь, если я какая-то реплика, вот здесь вот,
[39:29.860 --> 39:42.860]  по истечении фазы prepare, собрала 2F плюс один одинаковый prepare,
[39:42.860 --> 40:04.860]  то я и эта реплика, говорю, что я подготовила транзакцию с этим дайджестом в эпохе V,
[40:04.860 --> 40:16.860]  в слоте S, predicate prepared.
[40:16.860 --> 40:24.860]  По-человечески это значит вот что, если какая-то реплика собрала вот такое количество prepare,
[40:24.860 --> 40:34.860]  то она уверена, что на большинстве честных реплик в эпохе V, в слоте S, лежит одна и та же транзакция.
[40:34.860 --> 40:40.860]  Ну и дальше можно заметить, что поскольку мы собираем вот такое количество одинаковых preparов,
[40:40.860 --> 40:51.860]  то в пределах одной эпохи не бывает двух разных подготовленных транзакций.
[40:51.860 --> 41:01.860]  Почему? Потому что если две реплики подготовили разные транзакции, то каждая из них собрала вот такой кворум.
[41:01.860 --> 41:07.860]  Вот это prepare для транзакции Tx, это Tx'.
[41:07.860 --> 41:15.860]  И вот пересечение этих кворумов prepare есть, по крайней мере, здесь 2F плюс одно сообщение, prepare здесь 2F плюс одно.
[41:15.860 --> 41:27.860]  В пересечении этих кворумов, по крайней мере, F плюс одно сообщение, пересечение этих кворумов, по крайней мере, F плюс один реплик,
[41:27.860 --> 41:37.860]  а значит, по крайней мере, одна честная.
[41:37.860 --> 41:46.860]  Ну и эта реплика честная, получается, проголосовала, отправила разные prepare в одной и той же эпохе за разные транзакции,
[41:46.860 --> 41:56.860]  чего и делать запрещается. Так что не бывает двух разных подготовленных транзакций для одного и того же слота в одной и той же эпохе.
[41:56.860 --> 42:05.860]  Ну и теперь возникает естественный вопрос. Вот мы какая-то реплика, мы получили транзакцию от primary,
[42:05.860 --> 42:13.860]  положили ее в какой-то слот лога и после этого убедились, что эта транзакция лежит на большинстве частных узлов.
[42:13.860 --> 42:19.860]  Другой такой транзакции не будет. Можем ли мы считать, что эта транзакция закомичена?
[42:19.860 --> 42:30.860]  Можем ли мы зафиксировать ее в некотором порядке, зафиксировать ее с порядковым номером S и дальше применять к автомату, если переднее тоже зафиксировалось?
[42:30.860 --> 42:39.860]  Вот этот вопрос сложный, и мы сейчас его разберем. Я вернусь немного в прошлое, вставлю маленькое замечание, что вот эту картинку мы рисуем в разрезе
[42:39.860 --> 42:45.860]  некоторого фиксированного слота S. Вот вся эта картинка. Для разных слотов эта картинка будет дублироваться.
[42:45.860 --> 42:52.860]  Пока у нас есть в этой картинке две фазы. Первая prepar, для упорядочивания, вторая prepar, для того, чтобы реплика поняла,
[42:52.860 --> 43:04.860]  что на большинстве частных реплик лежит та же самая транзакция. Ну и вот реплика это поняла, она набрала вот такой набор сообщений.
[43:04.860 --> 43:09.860]  И нас интересует вопрос, можно ли считать такую транзакцию закомиченной?
[43:09.860 --> 43:20.860]  Вот если мы вспомним понятие комита в рафте, то для него мы доказывали, что из определения комита следует, что транзакция переживет смену эпохи.
[43:20.860 --> 43:34.860]  Что эта команда, которая удовлетворяет определению комита, непременно будет находиться в логах лидеров всех последующих эпох.
[43:34.860 --> 43:43.860]  Здесь нам нужно сделать то же самое. Показать, что если команда закомичена, то она переживает смену эпохи,
[43:43.860 --> 43:51.860]  а для этого нужно описать процедуру смены эпохи, смены праймари, потому что пока мы этого с вами не сделали.
[43:51.860 --> 44:00.860]  Ну вот давайте пока остановимся здесь, остановимся на реплике, которая собрала вот такое множество сообщений, такой сертификат.
[44:00.860 --> 44:07.860]  Позже мы назовем его сертификатом. Она знает, что на большинстве частных лежит эта же транзакция.
[44:07.860 --> 44:13.860]  А теперь случается смена эпохи. Немножко освободим место.
[44:24.860 --> 44:28.860]  Поговорим про смену эпохи, которая называется, напомню, view change.
[44:28.860 --> 44:44.860]  Смена эпохи означает, ну смена эпохи это смена праймари. Нужно выбрать нового праймари.
[44:44.860 --> 44:49.860]  Почему? Потому что, видимо, старый праймари ведет себя подозрительно.
[44:49.860 --> 44:56.860]  Ну вот какая-то реплика получила транзакцию от клиента, сказала, что праймари почему-то не комитит эту транзакцию.
[44:56.860 --> 45:00.860]  Мы на месте клиента не получаем кворн сертификат с ответом.
[45:00.860 --> 45:03.860]  Реплика говорит, ну хорошо, давайте проверим.
[45:03.860 --> 45:09.860]  Посылает транзакцию, преодолесует транзакцию праймари, ждет у него при ЭППР, заводит таймер, таймер протухает.
[45:09.860 --> 45:15.860]  И, видимо, мы подозреваем в чем-то праймари. Видимо, теперь праймари становится подозрительным.
[45:18.860 --> 45:20.860]  Нужно выбрать нового.
[45:20.860 --> 45:30.860]  Как это сделать? Как должна быть устроена процедура выбора этого нового праймари?
[45:30.860 --> 45:37.860]  В RAFT для того, чтобы обеспечить лайв нас, а нам в конце концов праймари нужен для того, чтобы обеспечить лайв нас, как всегда, выбор лидера.
[45:37.860 --> 45:45.860]  В RAFT для этого достаточно было выбрать любого лидера. Все узлы были честными.
[45:45.860 --> 45:53.860]  В раме достаточно было, чтобы кто-то из них стал лидером и назначал команды и реплицировал их на логи фолливеров.
[45:53.860 --> 46:00.860]  Здесь у нас требования более сложные, потому что мы хотим не просто выбрать какого-то лидера,
[46:00.860 --> 46:03.860]  ну, например, потому что этот праймари просто отказал,
[46:03.860 --> 46:13.860]  а мы хотим, чтобы эвентуал был выбран честный лидер, честный праймари, который гарантированно закомитит транзакции пользователей.
[46:13.860 --> 46:18.860]  Но как же отличить честный узел от нечестного?
[46:18.860 --> 46:22.860]  Потому что мы сказали, что мы же не можем гарантированно выбрать честного праймари,
[46:22.860 --> 46:28.860]  потому что византийский узел может вести себя нечестным, до тех пор, пока он не будет выбран праймари.
[46:28.860 --> 46:32.860]  Но можно было бы сказать следующее, что мы выбираем праймари каким-то образом,
[46:32.860 --> 46:35.860]  и если он себя скомпрометирует, например, в таком протоколе,
[46:35.860 --> 46:43.860]  то мы запишем, что он, видимо, подозрительный византийский, и после этого его будем на следующих выборах игнорировать.
[46:43.860 --> 46:50.860]  Вот так делать опасно, потому что в конце концов в этом протоколе мы не то чтобы понимаем, что праймари византийский,
[46:50.860 --> 46:54.860]  мы скорее понимаем, что праймари чего-то долго не делает.
[46:54.860 --> 47:02.860]  И может быть он действительно злоумышленник, и он действительно игнорирует намеренно команды конкретного пользователя, транзакции конкретного пользователя.
[47:02.860 --> 47:08.860]  А может быть он честный, ну просто я не знаю, он залип в какой-то паузе, он затормозил почему-то.
[47:08.860 --> 47:13.860]  Может быть он работал на какой-то виртуалке, которую засаспендили и переносили на другую машину.
[47:13.860 --> 47:19.860]  В общем, можно себе разные сценарии представить, и мы не то чтобы понимаем, что праймари византийский,
[47:19.860 --> 47:22.860]  мы скорее понимаем, что праймари подозрительный.
[47:22.860 --> 47:26.860]  Но если мы ошиблись, если все-таки он был честным, просто он залип,
[47:26.860 --> 47:33.860]  то если мы его исключим из последующих выборов, то мы, значит, рано или поздно можем так потерять все честные узлы.
[47:33.860 --> 47:36.860]  Так что мы должны каждому давать второй шанс.
[47:36.860 --> 47:45.860]  И при этом гарантировать каким-то образом, что eventually некоторые честные узел станет праймари.
[47:45.860 --> 47:48.860]  Для этого нам нужна новая идея. Ну как новая?
[47:48.860 --> 47:52.860]  Она в Объяснительном репликейшене была с самого основания с 1988 года.
[47:52.860 --> 47:58.860]  Но для нас она будет новая, и она будет нам полезна именно в контексте византийских систем.
[47:58.860 --> 48:05.860]  Мы будем использовать такую идею. Мы не будем лидера выбирать, мы будем лидера праймари назначать.
[48:13.860 --> 48:19.860]  Давайте я, чтобы опять поместиться, немного перенесу картинку.
[48:23.860 --> 48:28.860]  У нас будет идея rotating primary,
[48:33.860 --> 48:42.860]  где primary в эпохе v назначается узел v по модулю n,
[48:43.860 --> 48:46.860]  где n это общее число узлов.
[48:46.860 --> 48:56.860]  То есть мы перебираем праймари просто по кругу.
[48:56.860 --> 48:59.860]  Если один нам не нравится, мы берем следующий.
[48:59.860 --> 49:05.860]  Он нам тоже кажется подозрительным, мы продолжаем выбираем следующего и вот так вот просто двигаемся по кругу.
[49:05.860 --> 49:16.860]  Отлично. Если мы в такой схеме умеем подозревать праймари в византийском поведении,
[49:16.860 --> 49:23.860]  то мы просто меняем эпоху, передаем право быть праймари следующему узлу,
[49:23.860 --> 49:28.860]  и так рано или поздно мы дойдем до некоторого честного узла.
[49:28.860 --> 49:34.860]  Мы здесь при этом никого не исключаем, у каждого есть второй, третий и так далее шанс.
[49:34.860 --> 49:42.860]  Хорошо. Допустим, вот какой-то узел в чем-то подозревает праймари.
[49:42.860 --> 49:45.860]  Допустим, он даже честный.
[49:45.860 --> 49:51.860]  Вот достаточно ли этого, чтобы сменилась эпоха и сменился лидер?
[49:51.860 --> 50:01.860]  В RAF-те, если кто-то какой-то узел не получал heartbeat и append entries от лидера в течение реакшн тайм-аута рандомизированного,
[50:01.860 --> 50:05.860]  то он становился кандидатом и призвал всех перейти в новую эпоху.
[50:05.860 --> 50:09.860]  То есть достаточно было одного такого участника.
[50:09.860 --> 50:15.860]  Здесь у нас система византийская, поэтому снова мы не можем доверять конкретному участнику, мы не можем доверять конкретному узлу.
[50:15.860 --> 50:19.860]  Желания одного узла перевести систему в новую эпоху недостаточно,
[50:19.860 --> 50:27.860]  потому что этот желающий узел может быть византийским, и он просто хочет сбросить строна от текущего честного праймари.
[50:27.860 --> 50:37.860]  Поэтому, чтобы праймари поменять, нам нужно получить голоса нескольких узлов.
[50:37.860 --> 50:39.860]  Собрать голоса нескольких узлов.
[50:39.860 --> 50:42.860]  Итак, у нас есть снова четыре узла.
[50:42.860 --> 50:50.860]  У нас есть праймари в эпохе view 5 и есть узел, который станет следующим праймари в эпохе 6.
[50:50.860 --> 50:54.860]  Вот пока праймари вот этот.
[50:54.860 --> 51:04.860]  Если он каким-то образом себя скомпрометировал, то участники уведомляют об этом узел, который должен стать праймари следующим.
[51:04.860 --> 51:08.860]  Они отправляют ему сообщение в view change.
[51:13.860 --> 51:20.860]  В том числе сам P6, он может проголосовать за то, чтобы сменить праймари из прошлой эпохи.
[51:27.860 --> 51:31.860]  view change, эпохи В.
[51:31.860 --> 51:35.860]  Нам нужно получить какое-то количество голосов.
[51:35.860 --> 51:38.860]  Но вопрос, сколько голосов достаточно, чтобы P6 честный?
[51:38.860 --> 51:43.860]  Чтобы вот этот узел, третья реплика, стала праймари в шестой эпохе.
[51:49.860 --> 51:57.860]  Какого количества сообщений в view change достаточно, чтобы P6 действительно посчитало, что нужно поменять эпоху?
[51:57.860 --> 52:01.860]  Потому что, может быть, P6 честная, а P5 тоже честный.
[52:01.860 --> 52:07.860]  Просто византийские узлы хотят эпоху продвинуть вперед и мешать вот этому честному праймари.
[52:07.860 --> 52:15.860]  Казалось бы, достаточно получить на месте вот этого узла F plus 1 view change.
[52:15.860 --> 52:24.860]  Потому что среди этих F plus 1 view change будет, по крайней мере, одна честная реплика, которая пожелала сменить праймари.
[52:24.860 --> 52:32.860]  И вроде бы этого достаточно. Если хотя бы одна честная реплика подозревает праймари, значит у нее есть основание, значит мы должны сменить эпоху.
[52:32.860 --> 52:44.860]  Но, тем не менее, в протоколе view change, в PBFT мы дожидаемся 2 F плюс 1 сообщение view change.
[52:52.860 --> 52:56.860]  Ну, разумеется, эти сообщения подписаны, потому что иначе как мы собираемся эти кормы.
[53:02.860 --> 53:18.860]  То есть мы почему-то требуем больше view change, и пока, наверное, мы не понимаем зачем, но в будущем это прояснится.
[53:18.860 --> 53:30.860]  Хорошо. Ну, а дальше, если узел получил много view change, который переводит систему в следующую эпоху, в которой он должен быть праймари,
[53:30.860 --> 53:43.860]  то этот узел отправляет всем репликам сообщение new view. Можно переходить в новую эпоху.
[53:43.860 --> 54:05.860]  В таком протоколе пока очень много каких-то непонятных, странных мест. Тут очень большой простор для византийских узлов повлияет на все это.
[54:05.860 --> 54:15.860]  Ну вот смотрите, даже в византийских, что делать, если нам в текущей праймари не нравится, мы проголосовали за следующего праймари,
[54:15.860 --> 54:25.860]  а он почему-то на new view не посылает. Ну почему? Потому что просто этот узел отказал. У нас в конфигурации заложена возможность F отказов.
[54:25.860 --> 54:34.860]  Этот F включает в себя и злоумышленников, и просто взорвавшиеся узлы. Так вот, что если этот третий узел взорвался и никогда на new view не отправит?
[54:34.860 --> 54:49.860]  А он в следующей очереди. В этом случае, когда мы отправляем view change, мы заводим еще и таймер.
[54:49.860 --> 54:54.860]  И если он истекает, мы переходим вот еще в следующую эпоху, в следующую промежуточную эпоху.
[54:54.860 --> 55:09.860]  Но тут есть некоторые тонкости, а именно, что таймеру нужно экспоненциально увеличивать, чтобы потом реплики, которые пытаются пережить отказавших праймари, синхронизировались по эпохам.
[55:09.860 --> 55:17.860]  В общем, в этом месте лучше к статье обратиться, потому что мы сейчас запутаемся, если будем в это погружаться сильно. Это нас скорее отвлечет сейчас.
[55:17.860 --> 55:24.860]  В общем, эта проблема решается. Но есть другая проблема, которая нас больше, наверное, сейчас интересует.
[55:24.860 --> 55:33.860]  А именно, это случай, когда следующий праймари византийский.
[55:33.860 --> 55:43.860]  Или даже так. Что мешает в таком наивном протоколе третьему узлу, который должен стать праймари в эпохе 6,
[55:43.860 --> 55:51.860]  что ему мешает просто, не получая вьючейнжа, отправить сообщение new view остальным репликам и перевести всех в новую эпоху.
[55:51.860 --> 55:57.860]  То есть ему текущий праймари честно не нравится, он нечестно и хочет управлять всем сам.
[55:57.860 --> 56:05.860]  Как обычно, мы возвращаемся к идее, которая была найдена нами еще в клиентском протоколе.
[56:05.860 --> 56:11.860]  А именно, мы никогда не доверяем ответу конкретного узла. Мы всегда доверяем сертификату.
[56:11.860 --> 56:23.860]  Если узел стал праймари и хочет перевести все реплики за собой в новую эпоху,
[56:23.860 --> 56:29.860]  он должен доказать, что достаточно много реплик проголосовали за смену эпохи.
[56:29.860 --> 56:38.860]  Для этого он может приложить вот этот вот кворомный сертификат, обозначив его V, к своему сообщению вьючейнж.
[56:44.860 --> 56:52.860]  И тогда, если мы реплика получаем сообщение new view, то мы проверяем этот сертификат, проверяем подпись.
[56:52.860 --> 57:02.860]  И действительно, мы теперь уверены, что эпоха сменилась, потому что набрался квором из большинства честных.
[57:06.860 --> 57:12.860]  Хорошо. Следующая проблема, которая в этом протоколе пока неясна, не разрешилась.
[57:12.860 --> 57:25.860]  А именно, что если у третьего узла, который станет праймари в эпохе 6, просто-напросто не полный лог?
[57:25.860 --> 57:32.860]  В RAFT мы выбирали лидера всегда с полным логом. Мы там аккуратно тюнили правила голосования.
[57:32.860 --> 57:38.860]  Мы голосовали за кандидата на месте фолловера, только если у кандидата старшая эпоха в логе больше,
[57:38.860 --> 57:44.860]  либо равна нашей, но сам лог содержит больше записей. Здесь праймари назначается детерминированно,
[57:44.860 --> 57:50.860]  и мы просто не уверены, что у него будут все данные. Поэтому, когда мы отправляем вьючейнж,
[57:50.860 --> 57:57.860]  да, вот здесь я не написал, конечно, вьючейнж тоже подписывается, чтобы потом эти подписи можно было проверять здесь.
[57:57.860 --> 58:06.860]  Мы в этом вьючейнже отправляем еще и лог. То есть на месте реплики, которая голосует о смене эпохи,
[58:06.860 --> 58:16.860]  мы прикладываем к этому сообщению вьючейнж еще и свои собственные транзакции, которые у нас уже в логе есть.
[58:22.860 --> 58:32.860]  Но все же этого мало. Понятно, что да, праймари, если он честно и получает эти логи, он их...
[58:32.860 --> 58:40.860]  Давайте так. По задумке праймари должен получить эти логи, каким-то образом скомбинировать их в лог для светлого будущего
[58:40.860 --> 58:45.860]  и отправить этот лог для светлого будущего вместе с new view.
[58:48.860 --> 58:54.860]  Ну, тут могут быть разные варианты. А что, если новый праймари, скажем, византийский, и он просто отправил всем пустой лог?
[58:55.860 --> 59:03.860]  Ну, у него это сделать не получится, потому что вместе с этим логом он отправляет сертификат для смены эпохи, сертификат В,
[59:03.860 --> 59:10.860]  и каждый реплик, который его получает, может проверить действительно, что праймари пересобрал новый лог правильно.
[59:14.860 --> 59:20.860]  В PBFT все-таки немного не так все работает. Я сейчас не совсем корректно все это рассказываю, но...
[59:21.860 --> 59:26.860]  Пока нас дополнительные детали здесь запутают.
[59:28.860 --> 59:34.860]  Хорошо. Значит, если праймари византийский, то, скорее всего, его можно будет перепроверить.
[59:34.860 --> 59:42.860]  Но вот как поступать честному праймари, который получает view change как и от честных узлов, так и от византийских?
[59:42.860 --> 59:49.860]  Дело в том, что честные узлы, видимо, отправляют какие-то похожие логи, а вот византийские узлы могут эти логи
[59:49.860 --> 59:59.860]  просто придумывать, менять транзакции. Как мы гарантируем, что транзакции, которые мы считаем закоммиченными,
[59:59.860 --> 01:00:05.860]  а я напомню, что закоммиченной мы хотели бы считать транзакцию, которая лежит на большинстве честных логов,
[01:00:05.860 --> 01:00:11.860]  как гарантировать, что такая транзакция переживет смену эпохи? Почему, собственно, если у нас есть
[01:00:11.860 --> 01:00:17.860]  праймари следующий, и вот он собрал вот такой вот quorum view change,
[01:00:22.860 --> 01:00:26.860]  почему непременно он узнает про закоммиченную транзакцию?
[01:00:26.860 --> 01:00:34.860]  Ну вот тут можно и заметить, зачем мы использовали, зачем мы дожидались именно 2f плюс 1 view change.
[01:00:34.860 --> 01:00:43.860]  Именно для того, чтобы пересечься, вот в этом quorum есть большинство честных узлов,
[01:00:43.860 --> 01:00:49.860]  ну и, видимо, большинство честных узлов есть в quorum для подготовленной транзакции.
[01:00:49.860 --> 01:00:59.860]  Так что посмотрим, как эти quorums пересекаются. Здесь quorum узлов, которые отправили в view change для смены эпохи,
[01:00:59.860 --> 01:01:05.860]  здесь quorum узлов, которые отправили в prepare для какого-то view change v,
[01:01:05.860 --> 01:01:16.860]  и здесь prepare v, s, d. В каждом из этих quorum'ов 2f плюс 1 узел.
[01:01:19.860 --> 01:01:25.860]  Смотрим на пересечение опять. Тут по крайней мере f плюс 1 узел, то есть, по крайней мере,
[01:01:25.860 --> 01:01:31.860]  давайте нарисуем его, по крайней мере, один честный.
[01:01:31.860 --> 01:01:39.860]  Опять те же самые рассуждения, та же самая dissemination система quorum'ов.
[01:01:39.860 --> 01:01:47.860]  И, казалось бы, если транзакция подготовлена какой-то репликой, если транзакция подготовлена,
[01:01:47.860 --> 01:01:54.860]  и эта реплика знает об этом, если эта реплика подготовила транзакцию d в слоте s в эпохе v,
[01:01:54.860 --> 01:01:59.860]  то известно, что глобально на большинстве честных узлов лежит транзакция,
[01:01:59.860 --> 01:02:04.860]  а значит, в пересечении этих quorum'ов будет честный узел, который, с одной стороны,
[01:02:04.860 --> 01:02:08.860]  эту транзакцию у себя имеет, а с другой стороны, он проголосовал за смену эпохи
[01:02:08.860 --> 01:02:14.860]  и отправил новому primary свой лог. Так что новый primary мог бы из лога вот этой реплики
[01:02:14.860 --> 01:02:19.860]  забрать эту транзакцию, и тогда она переживет смену эпохи.
[01:02:19.860 --> 01:02:25.860]  Напомню, что мы об этом и волновались. Мы говорили, можно ли считать вот этот preparat
[01:02:25.860 --> 01:02:31.860]  свой предикат preparat сигналом к комиту.
[01:02:31.860 --> 01:02:37.860]  Ну, пока рассуждения разумные, правда, не совсем понятно, вот что.
[01:02:37.860 --> 01:02:45.860]  Ну да, мы теперь на месте p6 уверены, что хотя бы один viewchange
[01:02:45.860 --> 01:02:55.860]  хотя бы от одного узла содержит препарат транзакцию.
[01:02:55.860 --> 01:03:00.860]  Но не очень понятно, как на месте нового primary из всего этого quorum'а,
[01:03:00.860 --> 01:03:06.860]  из всех ответов выбрать именно ответ этого узла.
[01:03:06.860 --> 01:03:11.860]  Потому что он же получает и другие ответы. Ответы от византийских узлов, ответы от узлов,
[01:03:11.860 --> 01:03:18.860]  которые не попали в этот quorum.
[01:03:18.860 --> 01:03:23.860]  Было бы здорово, если бы вот эта честная реплика, которая попала в пересечение этих quorum'ов,
[01:03:23.860 --> 01:03:29.860]  смогла бы каким-то образом primary честному доказать, что именно ее транзакцию
[01:03:29.860 --> 01:03:35.860]  из слота S нужно взять. Как же это сделать?
[01:03:35.860 --> 01:03:41.860]  Как же этой честной реплике доказать, что именно ее нужно слушать?
[01:03:41.860 --> 01:03:47.860]  Ну вот мы это делали уже несколько раз. Если мы один узел хотели кого-то в чем-то убедить,
[01:03:47.860 --> 01:03:53.860]  скажем, мы primary отвечали клиенту, или мы новый primary отправляли всем сообщения
[01:03:53.860 --> 01:03:58.860]  о смене эпохи, мы всегда к нему прикладывали quorum'ный сертификат.
[01:03:58.860 --> 01:04:03.860]  То есть набор сообщений, подписанных большинством честных узлов,
[01:04:03.860 --> 01:04:09.860]  и этот сертификат удостоверял ответ, удостоверял право смены эпохи.
[01:04:09.860 --> 01:04:15.860]  И вот мы на месте этого честного узла, было бы здорово, если бы мы этот честный узел
[01:04:15.860 --> 01:04:23.860]  смогли предоставить вот такой аналогичный quorum'ный сертификат для подготовленной транзакции.
[01:04:23.860 --> 01:04:41.860]  То есть мы бы хотели новому primary передать вот такой вот, назовем его, prepare сертификат.
[01:04:41.860 --> 01:04:49.860]  Если бы у нас у зеленой реплики он был, то, разумеется, новый primary, третий узел,
[01:04:49.860 --> 01:04:56.860]  непременно бы эту реплику послушал, потому что ему бы нечего было выбирать,
[01:04:56.860 --> 01:05:02.860]  потому что мы сказали, что в пределах одной эпохи для одного слота не бывает
[01:05:02.860 --> 01:05:09.860]  двух разных подготовленных транзакций, не бывает двух транзакций с сертификатами.
[01:05:09.860 --> 01:05:15.860]  Просто primary вот здесь, получив эти view changes, выбрал бы ту транзакцию,
[01:05:15.860 --> 01:05:21.860]  у которой есть prepare сертификат. А теперь возвращаемся к исходному вопросу.
[01:05:21.860 --> 01:05:28.860]  Почему? Потому что эта реплика с помощью этого сертификата умеет доказать,
[01:05:28.860 --> 01:05:36.860]  что вот какое-то большинство честных реплик проголосовали за эту транзакцию.
[01:05:36.860 --> 01:05:41.860]  Ну, картинка не самая аккуратная, но в принципе должна быть понять.
[01:05:41.860 --> 01:05:45.860]  Так вот, теперь можно вернуться к исходному вопросу и разобраться,
[01:05:45.860 --> 01:05:48.860]  можно ли считать подготовленную транзакцию закомеченной?
[01:05:48.860 --> 01:05:52.860]  Может ли узел IT, который собрал prepare сертификат для транзакции,
[01:05:52.860 --> 01:05:56.860]  считать, что эта транзакция переживет смену эпохи?
[01:05:56.860 --> 01:06:01.860]  Транзакция переживет смену эпохи, если в пересечение кворумов,
[01:06:01.860 --> 01:06:08.860]  репликации и view change попадет реплика, у которой будет prepare сертификат.
[01:06:08.860 --> 01:06:16.860]  Давайте мы здесь его нарисуем.
[01:06:16.860 --> 01:06:26.860]  Но пока вот это условие означает лишь, что эта реплика знает, что у нее есть prepare сертификат.
[01:06:26.860 --> 01:06:30.860]  И если она попадет в пересечение кворумов, то она, конечно,
[01:06:30.860 --> 01:06:35.860]  новому праймари про транзакцию сообщит и сертификат предоставит.
[01:06:35.860 --> 01:06:40.860]  Но вообще-то в пересечение кворумов можно попасть в любая из реплик.
[01:06:40.860 --> 01:06:44.860]  Так вот, мы транзакцию назовем закомеченной,
[01:06:52.860 --> 01:07:00.860]  когда она подготовлена на 2F плюс 1 реплик.
[01:07:01.860 --> 01:07:07.860]  Когда она подготовлена на большинстве честных реплик.
[01:07:07.860 --> 01:07:12.860]  Вот такое определение не совсем корректно, если аккуратно подумать.
[01:07:12.860 --> 01:07:17.860]  Но вот команда закомечена, когда большинство честных реплик подготовили ее,
[01:07:17.860 --> 01:07:20.860]  то есть сформировали prepare сертификат.
[01:07:20.860 --> 01:07:26.860]  И тогда кто бы из этого большинства не попал в пересечение кворумов с view change,
[01:07:26.860 --> 01:07:30.860]  чтобы этот кто-то, эта честная реплика сможет предоставить prepare сертификат
[01:07:30.860 --> 01:07:34.860]  и новой праймари им непременно воспользуется.
[01:07:34.860 --> 01:07:37.860]  Но вот такое определение коммита, оно глобальное.
[01:07:37.860 --> 01:07:41.860]  То есть на большинстве честных транзакция подготовлена.
[01:07:41.860 --> 01:07:47.860]  Но пока у нас эта реплика этого не понимает.
[01:07:47.860 --> 01:07:51.860]  Она знает, что на большинстве честных транзакция просто находится в логе.
[01:07:51.860 --> 01:07:54.860]  Но она не уверена, что большинство честных набрали prepare сертификат
[01:07:54.860 --> 01:08:01.860]  и могут с помощью него доказать факт подготовленности на большинстве лидеров следующей эпохи.
[01:08:01.860 --> 01:08:06.860]  Поэтому мы в наш протокол добавляем еще одну фазу.
[01:08:06.860 --> 01:08:14.860]  Вот можно вспомнить здесь даже single degree of access, в котором есть определение коммита,
[01:08:14.860 --> 01:08:18.860]  определение chosen proposal.
[01:08:18.860 --> 01:08:26.860]  Значение выбрано, если нашелся proposal nv, за который проголосовала большинство аксепторов.
[01:08:26.860 --> 01:08:32.860]  Опять, это определение, это глобальное свойство для набора узлов, для набора аксепторов.
[01:08:32.860 --> 01:08:37.860]  Но при этом каждый аксептор не наблюдает выполнение этого условия,
[01:08:37.860 --> 01:08:40.860]  каждый аксептор всего лишь голосует локально.
[01:08:40.860 --> 01:08:45.860]  И нужно, чтобы какой-то пропозер набрал этот quorum
[01:08:45.860 --> 01:08:51.860]  и сказал остальным аксепторам, что значение выбрано.
[01:08:51.860 --> 01:08:53.860]  Сами аксепторы этого не понимают.
[01:08:53.860 --> 01:08:55.860]  Вот здесь та же самая история.
[01:08:55.860 --> 01:09:00.860]  Эта реплика знает, что на большинстве честных лежит одна и та же транзакция,
[01:09:00.860 --> 01:09:05.860]  но она не уверена, что другие честные тоже знают об этом.
[01:09:05.860 --> 01:09:10.860]  Поэтому для того, чтобы конкретно реплике понять, что транзакция закоммичена,
[01:09:10.860 --> 01:09:14.860]  она еще раз отправляет всем сообщение,
[01:09:14.860 --> 01:09:19.860]  ну и все реплики снова отправляют всем сообщение,
[01:09:19.860 --> 01:09:21.860]  семантика которого такая.
[01:09:21.860 --> 01:09:27.860]  Я и та реплика подготовила транзакцию, я собрала препарат-сертификат,
[01:09:27.860 --> 01:09:32.860]  и я говорю это вам.
[01:09:32.860 --> 01:09:39.860]  Сообщение commit vsd.
[01:09:39.860 --> 01:09:52.860]  И вот если реплика здесь набрала 2f плюс 1 одинаковый commit,
[01:09:52.860 --> 01:10:02.860]  то вот тогда уже она может заключить, что действительно транзакция закоммичена,
[01:10:02.860 --> 01:10:07.860]  что выполняется такое глобальное свойство, что транзакция подготовлена
[01:10:07.860 --> 01:10:09.860]  на большинстве честных узлов.
[01:10:09.860 --> 01:10:14.860]  После этого можно транзакцию применить к своему состоянию,
[01:10:14.860 --> 01:10:21.860]  ну и в конце концов отправить ответ primary.
[01:10:21.860 --> 01:10:33.860]  И primary, собрав эти ответы в сертификат, отправит его клиент.
[01:10:33.860 --> 01:10:37.860]  Давайте здесь тоже сертификат нарисуем.
[01:10:45.860 --> 01:10:49.860]  На самом деле и это еще не все,
[01:10:49.860 --> 01:10:55.860]  потому что если внимательно подумать над протоколом,
[01:10:55.860 --> 01:10:57.860]  промоделировать различные исполнения,
[01:10:57.860 --> 01:11:02.860]  то окажется, что я, строго говоря, ничего пока не доказал.
[01:11:02.860 --> 01:11:09.860]  Я скорее сформулировал некоторую интуицию и не рассказал вот про что.
[01:11:09.860 --> 01:11:16.860]  Вот как будто бы новый primary, когда он собирает view changer,
[01:11:16.860 --> 01:11:22.860]  если ему присылают лог и в этом логе есть транзакция,
[01:11:22.860 --> 01:11:26.860]  а у него есть сертификат, то казалось бы primary избавлен от выбора.
[01:11:26.860 --> 01:11:30.860]  Он знает, что не будет другой транзакции с сертификатом.
[01:11:30.860 --> 01:11:32.860]  Просто потому что пересекают скворы,
[01:11:32.860 --> 01:11:38.860]  в пересечении есть один честный узел, ноги и так далее.
[01:11:38.860 --> 01:11:42.860]  На самом деле все хитрее, потому что оказывается,
[01:11:42.860 --> 01:11:47.860]  что при смене эпохи узел, который должен стать в следующем primary,
[01:11:47.860 --> 01:11:52.860]  может получить разные логи с разными транзакциями,
[01:11:52.860 --> 01:11:55.860]  и эти транзакции будут сертифицированы.
[01:11:55.860 --> 01:11:58.860]  Но, разумеется, они не могут быть сертифицированы в одной эпохе,
[01:11:58.860 --> 01:12:02.860]  поэтому они будут сертифицированы в разных view.
[01:12:02.860 --> 01:12:10.860]  И тогда новый primary должен выбрать при смене эпохи сертификат с наибольшим номером.
[01:12:10.860 --> 01:12:16.860]  И вот это уже будет настоящий PBFT.
[01:12:16.860 --> 01:12:18.860]  Ну и строг говоря, тут нужно все это доказывать,
[01:12:18.860 --> 01:12:22.860]  но примерно рассуждение там похоже на то, что было раньше.
[01:12:22.860 --> 01:12:25.860]  Честно говоря, не хочется все это сейчас повторять.
[01:12:25.860 --> 01:12:27.860]  Если вам интересно, можно обратиться к статье,
[01:12:27.860 --> 01:12:32.860]  но вот я сам протокол и всю интуицию, кажется, здесь для него изложил.
[01:12:32.860 --> 01:12:36.860]  Что этому протоколу не хватает?
[01:12:36.860 --> 01:12:52.860]  Не хватает, наверное, разговора про смену эпохи,
[01:12:52.860 --> 01:12:55.860]  потому что вот эта процедура, она вроде бы описана,
[01:12:55.860 --> 01:13:03.860]  мы вроде бы поговорили, каким образом эта процедура противостоит сбоям старого primary,
[01:13:03.860 --> 01:13:06.860]  нового primary, отдельных реплик.
[01:13:06.860 --> 01:13:08.860]  Но все же она остается очень громоздкой,
[01:13:08.860 --> 01:13:12.860]  потому что, ну, в самом деле, представьте, вы здесь отправляете целый лог,
[01:13:12.860 --> 01:13:19.860]  и к каждой записи этого лога вы прикладываете сертификат, в котором много сообщений.
[01:13:19.860 --> 01:13:22.860]  Ну вот, да, я забыл об этом сказать.
[01:13:22.860 --> 01:13:25.860]  Мы говорим именно про сообщения, а не RPC,
[01:13:25.860 --> 01:13:29.860]  потому что мы постоянно эти кормные сертификаты перепосылаем.
[01:13:29.860 --> 01:13:32.860]  Ну, в смысле, набираем и посылаем другим.
[01:13:32.860 --> 01:13:35.860]  Нам нужно иметь именно вот такие подписанные сообщения.
[01:13:35.860 --> 01:13:40.860]  Ну вот, здесь очень много сообщений, мы отправляем их потом еще раздаем,
[01:13:40.860 --> 01:13:43.860]  и лог у нас растет, копится, копится, копится,
[01:13:43.860 --> 01:13:47.860]  и вот мы повторяем всю эту процедуру при каждой смене эпохи.
[01:13:47.860 --> 01:13:51.860]  Хотелось бы как-то иметь здесь лог какой-то ограниченной длины.
[01:13:54.860 --> 01:13:57.860]  Ну и мы такую задачу уже решали с вами.
[01:13:57.860 --> 01:13:59.860]  Мы хотим сейчас научиться делать snapshot.
[01:13:59.860 --> 01:14:03.860]  То есть мы хотим просто префикс лога, закомиченный, обрезать
[01:14:03.860 --> 01:14:06.860]  и представлять его как-то более компактно.
[01:14:06.860 --> 01:14:10.860]  То есть мы хотим поддерживать, вместо префикса лога,
[01:14:10.860 --> 01:14:14.860]  схлопнуть его в какое-то итоговое состояние,
[01:14:14.860 --> 01:14:17.860]  которое получается применением всех транзакций этого,
[01:14:17.860 --> 01:14:20.860]  всех закомиченных транзакций этого префикса.
[01:14:23.860 --> 01:14:27.860]  Мы когда говорили про RAFT, в лекции по Access Made Life,
[01:14:27.860 --> 01:14:29.860]  мы говорили про то, как делать снапшоты.
[01:14:29.860 --> 01:14:32.860]  Мы говорили об этом на семинаре про crash consistency.
[01:14:34.860 --> 01:14:38.860]  Но вот прям такая процедура нам не подойдет,
[01:14:38.860 --> 01:14:40.860]  потому что когда мы там делали снапшоты,
[01:14:40.860 --> 01:14:44.860]  и каждая реплика делала их независимо для своих собственных индексов,
[01:14:44.860 --> 01:14:47.860]  в этом протоколе так сделать не получится.
[01:14:47.860 --> 01:14:51.860]  Вот представим, что мы научимся делать снапшоты,
[01:14:51.860 --> 01:14:54.860]  и когда мы будем менять эпоху, мы вместо полного длинного лога
[01:14:54.860 --> 01:14:58.860]  будем отправлять s-snapshot
[01:15:01.860 --> 01:15:04.860]  для некоторого префикса и вот некоторый суффикс.
[01:15:04.860 --> 01:15:10.860]  И непонятно, почему мы на месте праймари нового
[01:15:10.860 --> 01:15:14.860]  должны доверять вот полученному снапшоту здесь.
[01:15:14.860 --> 01:15:17.860]  Почему мы доверяли логу, мы поговорили,
[01:15:17.860 --> 01:15:21.860]  потому что с транзакцией в этом логе был связан сертификат.
[01:15:21.860 --> 01:15:24.860]  А почему мы доверяем вот этому снапшоту, непонятно.
[01:15:27.860 --> 01:15:30.860]  Опять, мы не можем доверять на месте праймари одному узлу.
[01:15:30.860 --> 01:15:34.860]  Нам нужно, чтобы к этому снапшоту было приложено
[01:15:34.860 --> 01:15:37.860]  некоторое криптографическое доказательство того,
[01:15:37.860 --> 01:15:41.860]  что вот этот снапшот разделяется между разными репликами.
[01:15:41.860 --> 01:15:45.860]  Поэтому правило построения снапшотов будет чуть сложнее
[01:15:45.860 --> 01:15:49.860]  относительно того же RAF.
[01:16:00.860 --> 01:16:03.860]  Во-первых, мы будем делать снапшоты синхронно.
[01:16:03.860 --> 01:16:08.860]  Но синхронно, разумеется, не во времени, а синхронно по индексам.
[01:16:08.860 --> 01:16:12.860]  Ну вот скажем, каждую сотую позицию в логе.
[01:16:18.860 --> 01:16:21.860]  Мы здесь построили снапшот.
[01:16:31.860 --> 01:16:37.860]  А теперь нужно каким-то образом научиться доказывать новому праймари,
[01:16:37.860 --> 01:16:40.860]  что этот снапшот действительно похож на снапшот других узлов.
[01:16:40.860 --> 01:16:42.860]  Поэтому мы снова отправляем этот снапшот...
[01:16:42.860 --> 01:16:45.860]  Ладно, мы отправляем не целый снапшот, это было бы тяжело.
[01:16:45.860 --> 01:16:58.860]  Мы отправляем другим узлам, другим репликам сообщение снапшот,
[01:16:58.860 --> 01:17:03.860]  который сделан в кат и позиции.
[01:17:03.860 --> 01:17:09.860]  И этот снапшот имеет hashD.
[01:17:14.860 --> 01:17:17.860]  И, разумеется, свое сообщение подписываем.
[01:17:17.860 --> 01:17:20.860]  И так делает каждая реплика.
[01:17:28.860 --> 01:17:40.860]  И теперь, если какая-то ИТ реплика построила снапшот
[01:17:40.860 --> 01:17:47.860]  и получила еще 2F голосов, 2F подтверждений того,
[01:17:47.860 --> 01:17:51.860]  что на других репликах есть снапшот с таким же hash,
[01:17:51.860 --> 01:18:00.860]  то она может к своему снапшоту прикрепить снова quorum-сертификат.
[01:18:00.860 --> 01:18:26.860]  И этот quorum-сертификат приложить к своему снапшоту в viewChange.
[01:18:26.860 --> 01:18:30.860]  То есть метод, в принципе, такой же.
[01:18:30.860 --> 01:18:36.860]  Таким образом мы сможем все же не повторять сложную процедуру
[01:18:36.860 --> 01:18:40.860]  после каждой смены эпохи, потому что закомиченный префикс
[01:18:40.860 --> 01:18:45.860]  будет компактиться и заменяться с помощью такой процедуры
[01:18:45.860 --> 01:18:50.860]  на более компактные представления.
[01:18:50.860 --> 01:19:01.860]  Ну и последняя идея, которая, последняя техника на сегодня,
[01:19:01.860 --> 01:19:05.860]  касается аутентификации.
[01:19:05.860 --> 01:19:11.860]  В этом протоколе мы использовали для аутентификации цифровые подписи.
[01:19:11.860 --> 01:19:13.860]  Использовали их очень часто.
[01:19:13.860 --> 01:19:16.860]  Вот мы каждое сообщение подписывали.
[01:19:17.860 --> 01:19:23.860]  Но цифровые подписи это не единственный механизм аутентификации.
[01:19:23.860 --> 01:19:28.860]  Вот скажем, если мы говорим про безопасные соединения,
[01:19:28.860 --> 01:19:31.860]  если мы браузер и мы общаемся с сервером,
[01:19:31.860 --> 01:19:36.860]  то в пределах этого соединения мы не то чтобы каждое сообщение,
[01:19:36.860 --> 01:19:42.860]  каждый пакетик подписываем с помощью асимметричной криптографии.
[01:19:42.860 --> 01:19:47.860]  Мы не то чтобы постоянно используем все эти операции над рептическими кривыми,
[01:19:47.860 --> 01:19:51.860]  это было бы очень неэффективно.
[01:19:51.860 --> 01:19:57.860]  Когда мы открываем сессию защищенную, то вместо этого мы делаем следующее.
[01:19:57.860 --> 01:20:03.860]  Давайте я смотрю цифровые подписи
[01:20:03.860 --> 01:20:06.860]  и поговорю про альтернативный способ аутентификации,
[01:20:06.860 --> 01:20:10.860]  который называется коды аутентификации сообщений.
[01:20:10.860 --> 01:20:37.860]  Итак, мы браузер и сервер.
[01:20:37.860 --> 01:20:41.860]  Вот между нами есть сессия.
[01:20:41.860 --> 01:20:49.860]  И мы с помощью цифровых подписей, мы узнали сертификат, мы можем его провалидировать.
[01:20:49.860 --> 01:20:53.860]  Мы с помощью механизма цифровых подписей и с помощью протокола Диффи Хелмана
[01:20:53.860 --> 01:20:59.860]  договариваемся о некотором разделяемом секрете между двумя этими узлами.
[01:20:59.860 --> 01:21:05.860]  Мы договариваемся о сессионном ключе S.
[01:21:05.860 --> 01:21:18.860]  Давайте я переименую сервер и B в Алису и Боба и буду про них уже говорить.
[01:21:18.860 --> 01:21:22.860]  У нас есть Алиса, у нас есть Боб.
[01:21:22.860 --> 01:21:27.860]  Они договариваются между собой о разделяемом секрете AB с сессионным ключем.
[01:21:27.860 --> 01:21:33.860]  И если Алиса отправляет сообщение Бобу,
[01:21:33.860 --> 01:21:39.860]  то она к этому сообщению прикладывает хэш криптографический
[01:21:39.860 --> 01:21:46.860]  от конкатинации сообщения плюс этого самого секрета.
[01:21:46.860 --> 01:21:52.860]  И вот этот хэш мы назовем аутентификатором.
[01:21:52.860 --> 01:21:56.860]  Не подписью уже, другое название аутентификатор.
[01:21:56.860 --> 01:22:02.860]  Альфа AB от M.
[01:22:02.860 --> 01:22:06.860]  И теперь Боб, получая сообщение и получает аутентификатор,
[01:22:06.860 --> 01:22:10.860]  действительно может удостовериться, что сообщение отправило именно Алиса.
[01:22:10.860 --> 01:22:16.860]  Он конкатинирует полученное сообщение с секретом, который узнает только они вдвоем,
[01:22:16.860 --> 01:22:20.860]  считает хэш, что гораздо проще, чем проверка подписи.
[01:22:20.860 --> 01:22:25.860]  И сравнивается с аутентификатором, который получил сообщение.
[01:22:25.860 --> 01:22:30.860]  Вопрос, в котором задаются авторы.
[01:22:30.860 --> 01:22:36.860]  А можем ли мы заменить в нашем протоколе,
[01:22:36.860 --> 01:22:41.860]  где постоянно используются цифровые подписи, механизм аутентификации
[01:22:41.860 --> 01:22:45.860]  с цифровых подписей на эти самые маки?
[01:22:45.860 --> 01:22:49.860]  Потому что получится эффективнее, потому что они гораздо быстрее.
[01:22:49.860 --> 01:22:54.860]  И они тоже решают задачу аутентификации.
[01:22:54.860 --> 01:22:58.860]  Но все же так сделать нельзя.
[01:22:58.860 --> 01:23:02.860]  Потому что способы разные, и этот способ эффективнее,
[01:23:02.860 --> 01:23:05.860]  но он в некотором смысле слабее.
[01:23:05.860 --> 01:23:11.860]  Он не имеет очень важного свойства, которые нам предоставляют цифровые подписи.
[01:23:11.860 --> 01:23:18.860]  И это свойство называется non-repudiation.
[01:23:18.860 --> 01:23:22.860]  Невозможность отказаться от собственных слов.
[01:23:31.860 --> 01:23:34.860]  Ну вот представьте себе ситуацию.
[01:23:34.860 --> 01:23:45.860]  У нас есть Алиса, у нас есть Боб и у нас есть некоторый Виктор.
[01:23:45.860 --> 01:23:53.860]  И Алиса отправляет Бобу сообщение, допустим, подписанное Алисой.
[01:23:53.860 --> 01:23:57.860]  Алиса отправит сообщение, подписанное Алисой. Это разумно.
[01:23:57.860 --> 01:24:01.860]  И Боб посылает... Что может сделать Боб?
[01:24:01.860 --> 01:24:07.860]  Боб всегда может доказать Виктору, что он получил это сообщение от Алисы.
[01:24:07.860 --> 01:24:11.860]  Он может отправить это сообщение Виктору с цифровой подписью,
[01:24:11.860 --> 01:24:13.860]  и Виктор может проверить эту подпись.
[01:24:13.860 --> 01:24:17.860]  Коль скоро у них есть удостоверяющий центр, есть сертификаты,
[01:24:17.860 --> 01:24:20.860]  можно узнать открытый ключ узла А Алисы.
[01:24:27.860 --> 01:24:34.860]  Можно ли на месте Боба доказать, что Боб получил сообщение от Алисы,
[01:24:34.860 --> 01:24:40.860]  если Алиса вместо цифровой подписи приложила к сообщению mAuthenticator?
[01:24:46.860 --> 01:24:49.860]  Это проблема, потому что Боб... Но что он может сделать?
[01:24:49.860 --> 01:24:52.860]  Он может проверить этот аутентификатор, то есть он может убедиться,
[01:24:52.860 --> 01:24:54.860]  что сообщение отправило именно Алиса.
[01:24:57.860 --> 01:25:01.860]  Но если он отправит этот аутентификатор Виктору,
[01:25:01.860 --> 01:25:04.860]  то Виктор уже этим аутентификатором воспользоваться не сможет,
[01:25:04.860 --> 01:25:08.860]  потому что он не знает сессионного ключа между A и B,
[01:25:08.860 --> 01:25:11.860]  к которому этот аутентификатор был привязан.
[01:25:12.860 --> 01:25:17.860]  Ну ладно, не беда. Может быть, Алиса сможет написать два аутентификатора?
[01:25:20.860 --> 01:25:27.860]  AB и AV. Один из них предназначается Бобу, а другой предназначается Виктору,
[01:25:27.860 --> 01:25:30.860]  которому сообщение будет пересылаться.
[01:25:30.860 --> 01:25:35.860]  И тогда Боб проверяет этот аутентификатор, а Виктор проверяет этот аутентификатор.
[01:25:37.860 --> 01:25:40.860]  Почему нам вообще это важно? Почему нам важно...
[01:25:41.860 --> 01:25:44.860]  Почему нам важно на месте Виктора понимать, кто отправил сообщение?
[01:25:44.860 --> 01:25:48.860]  Ну потому что мы постоянно пользуемся здесь кормными сертификатами.
[01:25:48.860 --> 01:25:51.860]  Это наш такой основной рабочий инструмент сегодня.
[01:25:51.860 --> 01:25:57.860]  Мы их использовали в протоколе клиента, мы их использовали в протоколе смены эпохи,
[01:25:57.860 --> 01:26:03.860]  и мы их использовали для того, чтобы подтвердить, что транзакция реплицирована.
[01:26:05.860 --> 01:26:08.860]  Мы всегда перепосылаем сообщение.
[01:26:08.860 --> 01:26:13.860]  Вот во viewChange отправляем препэры, которые мы получили от других узлов.
[01:26:15.860 --> 01:26:21.860]  То есть, например, здесь одна реплика посылает другое сообщение препэр,
[01:26:22.860 --> 01:26:28.860]  а здесь эта реплика голосует за смену эпохи
[01:26:32.860 --> 01:26:36.860]  и прикладывает в этот viewChange этот самый препэр.
[01:26:37.860 --> 01:26:40.860]  То есть перепосылает это сообщение.
[01:26:40.860 --> 01:26:44.860]  Ну а теперь почувствуем разницу между двумя вот этими механизмами.
[01:26:44.860 --> 01:26:50.860]  Пусть у нас есть этот самый V, который в данном случае новый primary,
[01:26:50.860 --> 01:26:53.860]  который набирает viewChange.
[01:26:53.860 --> 01:26:56.860]  Он получает этот V от чужих сообщений,
[01:26:56.860 --> 01:27:01.860]  и он хочет проверить их подпись или аутентификатор.
[01:27:01.860 --> 01:27:07.860]  Вот, допустим, V получил сообщение через Боба от Алисы,
[01:27:07.860 --> 01:27:12.860]  и он видит, что это сообщение было снабжено, допустим, цифровой подписью,
[01:27:12.860 --> 01:27:16.860]  и Виктор видит, что цифровая подпись не сходится.
[01:27:16.860 --> 01:27:20.860]  О чем это говорит? Какой вывод может сделать Виктор?
[01:27:22.860 --> 01:27:25.860]  Может ли Боб быть византийским?
[01:27:25.860 --> 01:27:30.860]  Конечно, может, потому что он прислал сообщение с неправильной цифровой подписью.
[01:27:30.860 --> 01:27:34.860]  А может ли Боб быть честным, а Алиса быть византийской?
[01:27:35.860 --> 01:27:40.860]  Ну, это было бы странно, это странная конфигурация,
[01:27:40.860 --> 01:27:45.860]  потому что если Алиса была византийской и отправила сообщение с неправильной цифровой подписью,
[01:27:45.860 --> 01:27:50.860]  а Боб был честный, то Боб был бы в первую очередь обязан проверить это сообщение,
[01:27:50.860 --> 01:27:54.860]  проверить эту подпись. Зачем же он нам посылает ее тогда?
[01:27:54.860 --> 01:27:59.860]  То есть здесь не бывает такого, что Алиса нечестная и сломала подпись,
[01:27:59.860 --> 01:28:02.860]  отправила неправильную подпись, а Боб честный,
[01:28:02.860 --> 01:28:06.860]  потому что он бы проверил это раньше и нам бы сообщение посылать не стал.
[01:28:07.860 --> 01:28:15.860]  А что если мы пользуемся вместо одной подписи такой вот парой аутентификаторов?
[01:28:15.860 --> 01:28:21.860]  Что видит Виктор? Виктор видит, что, допустим, вот этот компонент аутентификатора,
[01:28:21.860 --> 01:28:27.860]  αав, скомпрометирован, то есть он просто испорчен.
[01:28:27.860 --> 01:28:34.860]  Мы считаем хэш от сообщения с нашим секретом, от а до в,
[01:28:34.860 --> 01:28:38.860]  и видим, что не сходится этот аутентификатор с этим хэшом.
[01:28:38.860 --> 01:28:44.860]  Что мы можем думать про а и б?
[01:28:44.860 --> 01:28:48.860]  Может ли а быть, может ли б быть нечестным?
[01:28:48.860 --> 01:28:52.860]  Ну, разумеется, Алиса была честная, отправила аав, аав не были обыкорректны,
[01:28:52.860 --> 01:28:55.860]  а Боб аав сломал.
[01:28:55.860 --> 01:28:59.860]  А может ли а быть нечестным, а б быть честным?
[01:28:59.860 --> 01:29:06.860]  Тоже может, потому что Алиса отправила Бобу корректный аав, и Боб его проверил.
[01:29:06.860 --> 01:29:10.860]  Но отправила ему сломанный ав, но Боб этого проверить не может,
[01:29:10.860 --> 01:29:14.860]  потому что он не знает сессионного ключа между а и в.
[01:29:14.860 --> 01:29:20.860]  Так что он просто проверяет свою компоненту и перепосылает весь аутентификатор Виктору.
[01:29:21.860 --> 01:29:27.860]  В итоге Виктор плохо понимает, что случилось.
[01:29:27.860 --> 01:29:30.860]  Валидин ли...
[01:29:30.860 --> 01:29:34.860]  Он не различает два случая, а почему для нас PBFT это важно?
[01:29:34.860 --> 01:29:41.860]  Вот представим, что мы primary, и мы получили quorum-сертификат здесь.
[01:29:41.860 --> 01:29:46.860]  То есть нам какая-то реплика говорит, что в слоте S
[01:29:46.860 --> 01:29:54.860]  транзакция T подготовлена, и вот набор сообщений, которые это доказывают.
[01:29:54.860 --> 01:29:59.860]  И если транзакция закоммичена, то вообще говоря,
[01:29:59.860 --> 01:30:03.860]  в пересечение с view-change может попасться только один честный узел,
[01:30:03.860 --> 01:30:07.860]  который сможет этот сертификат предоставить.
[01:30:07.860 --> 01:30:14.860]  А теперь представим, что мы на месте византийского узла что можем сделать?
[01:30:14.860 --> 01:30:19.860]  Мы можем сертификат вот этого узла, который попадет в пересечение,
[01:30:19.860 --> 01:30:26.860]  взять и отравить с помощью неправильного аутентификатора у prepare.
[01:30:26.860 --> 01:30:31.860]  То есть мы вот какая-то реплика...
[01:30:36.860 --> 01:30:41.860]  Мы допустим вот эта реплика, отправили первые реплики prepare
[01:30:41.860 --> 01:30:46.860]  и подписали, добавили к этому prepare
[01:30:50.860 --> 01:30:54.860]  корректный аутентификатор для вот такой пары
[01:30:54.860 --> 01:31:01.860]  и некорректный аутентификатор для пары четвертая реплика, третья реплика.
[01:31:01.860 --> 01:31:05.860]  И в итоге первая реплика собрала quorum-сертификат,
[01:31:05.860 --> 01:31:10.860]  она надеется с помощью него доказать новому primary,
[01:31:10.860 --> 01:31:13.860]  что транзакция должна попасть в следующую эпоху.
[01:31:13.860 --> 01:31:18.860]  Но так получилось, что в этом quorum-сертификате одно сообщение отравлено,
[01:31:18.860 --> 01:31:28.860]  потому что отравлен аутентификатор, который адресуется третьему узлу, следующему primary.
[01:31:28.860 --> 01:31:32.860]  И реплика, которая собирает здесь вот этот quorum-сертификат,
[01:31:32.860 --> 01:31:36.860]  она не может это проверить, потому что для нее этот prepare правильный,
[01:31:36.860 --> 01:31:39.860]  для нее компоненты аутентификатора правильные.
[01:31:43.860 --> 01:31:45.860]  Итак, подводим итог.
[01:31:45.860 --> 01:31:50.860]  У нас один византийский узел может серьезно испортить весь протокол,
[01:31:50.860 --> 01:31:55.860]  если мы используем коды аутентификации сообщений вместо цифровых подписей.
[01:31:55.860 --> 01:32:01.860]  Казалось бы, у нас одна цифровая подпись заменяет целым векторам аутентификаторов
[01:32:01.860 --> 01:32:03.860]  для каждого потенциального адресата.
[01:32:03.860 --> 01:32:08.860]  Но утверждается авторами, что даже так получится эффективнее.
[01:32:08.860 --> 01:32:12.860]  Но правда, из коробки просто взять и поменять не работает.
[01:32:12.860 --> 01:32:17.860]  Но в PhD одного из авторов есть целая глава про то,
[01:32:17.860 --> 01:32:23.860]  как можно PBFT переложить на аутентификаторы все-таки вместо цифровых подписей,
[01:32:23.860 --> 01:32:28.860]  немного усложнив процедуру смены эпохи, но тем не менее это можно сделать.
[01:32:29.860 --> 01:32:36.860]  Мой пояс сейчас скорее в том, что цифровые подписи – это не единственный механизм аутентификации.
[01:32:36.860 --> 01:32:43.860]  Есть коды аутентификации сообщений, но они по своим возможностям не эквивалентные.
[01:32:43.860 --> 01:32:49.860]  Коды аутентификации сообщений эффективнее, но они теряют свойство non-repudiation,
[01:32:49.860 --> 01:32:55.860]  то есть нам сложно перепосылать сообщения, которые мы получили от других узлов.
[01:32:58.860 --> 01:33:06.860]  Так что принципиально важно, что весь этот протокол изложен именно в терминах цифровых подписей.
[01:33:09.860 --> 01:33:11.860]  Ну что ж, нужно подвести итог.
[01:33:14.860 --> 01:33:19.860]  Мы с вами построили протокол, который пока не слишком эффективный.
[01:33:19.860 --> 01:33:25.860]  Тут много таких фаз происходит, тут довольно громоздкая процедура выбора лидера.
[01:33:25.860 --> 01:33:29.860]  Но все же мы добились оптимального числа реплик, ну и построили протокол,
[01:33:29.860 --> 01:33:33.860]  который в принципе похож на то, что было раньше, на multipax, на wrap.
[01:33:33.860 --> 01:33:35.860]  Есть все-таки в нем довольно много сходств,
[01:33:35.860 --> 01:33:41.860]  а есть зато и много отличий, которые позволяют нам решать задачу именно византийской модели.
[01:33:41.860 --> 01:33:46.860]  Ну и давайте как-то соберем вместе все техники, которые мы здесь использовали.
[01:33:46.860 --> 01:33:50.860]  Во-первых, мы унаследовали техники, которые были придуманы еще в прошлый раз.
[01:33:50.860 --> 01:33:56.860]  Мы используем цифровые подписи повсеместно и существенно пользуемся свойством non-repudiation.
[01:33:56.860 --> 01:34:00.860]  И мы используем византийские кворумы, которые пересекаются,
[01:34:00.860 --> 01:34:04.860]  по крайней мере, по f плюс 1 узлу или по 1 честному узлу.
[01:34:06.860 --> 01:34:11.860]  А из новых техник у нас есть две очень мощные идеи.
[01:34:11.860 --> 01:34:14.860]  Во-первых, как мы обеспечивали лайвнес?
[01:34:14.860 --> 01:34:18.860]  Мы обеспечивали лайвнес с помощью протейтинг праймари.
[01:34:20.860 --> 01:34:25.860]  Мы не пытались выбрать честного праймари, это невозможно, кажется.
[01:34:25.860 --> 01:34:30.860]  Мы научились подозревать подозрительных праймари
[01:34:30.860 --> 01:34:35.860]  и менять эпохи так, чтобы просто в эпохах ротировались лидеры.
[01:34:35.860 --> 01:34:38.860]  И таким образом мы гарантировали, что рано или поздно,
[01:34:38.860 --> 01:34:42.860]  не зная какие узлы честные и какие нечестные, не умея их отличать друг от друга,
[01:34:42.860 --> 01:34:47.860]  мы гарантировали, что eventually право упорядочивать транзакции,
[01:34:47.860 --> 01:34:51.860]  перейдет формировать лог предыдущей транзакции, перейдет к некоторому честному узлу.
[01:34:51.860 --> 01:34:55.860]  Вот эту идею мы дальше будем развивать.
[01:34:55.860 --> 01:35:00.860]  Мы увидим, как эта идея совершенно альтернативным образом
[01:35:00.860 --> 01:35:05.860]  представлена в протоколе репликации в блокчейне биткоина.
[01:35:05.860 --> 01:35:10.860]  И через еще одну лекцию мы увидим, как эту идею можно,
[01:35:10.860 --> 01:35:15.860]  вдохновляясь в биткоин, оптимизировать, сделать еще эффективнее.
[01:35:15.860 --> 01:35:20.860]  То есть сократить накладные расходы на вот эту громоздкую процедуру смены эпохи.
[01:35:20.860 --> 01:35:24.860]  И вторая техника, которой мы сегодня пользовались,
[01:35:24.860 --> 01:35:29.860]  которой раньше не было, это кворумные сертификаты.
[01:35:29.860 --> 01:35:33.860]  Вот кворумные сертификаты мы использовали в протоколе клиента,
[01:35:33.860 --> 01:35:37.860]  и мы использовали вот с такими системами кворумов.
[01:35:37.860 --> 01:35:41.860]  В пересечении был по крайней мере один узел,
[01:35:41.860 --> 01:35:46.860]  и вот здесь через это пересечение с помощью кворумного сертификата
[01:35:46.860 --> 01:35:52.860]  мы могли убедить нового праймари, что большинство честных узлов согласны с нами.
[01:35:52.860 --> 01:35:58.860]  Опять же, эту идею мы еще воспользуемся через два занятия,
[01:35:58.860 --> 01:36:06.860]  когда мы будем говорить про протокол репликации уже правда блокчейна Hot Stuff.
[01:36:07.860 --> 01:36:12.860]  И еще одна занятная вещь, на которую я хотел бы обратить на последок внимание,
[01:36:12.860 --> 01:36:18.860]  это то, как устроен вот этот протокол именно репликации в разрезе одного слота.
[01:36:18.860 --> 01:36:25.860]  Тут происходят некоторые забавные вещи в смысле знания отдельных узлов.
[01:36:25.860 --> 01:36:29.860]  Когда мы после первой фазы проходим через вторую,
[01:36:29.860 --> 01:36:35.860]  то у нас накапливается знание, что на большинстве честных лежит некоторая транзакция.
[01:36:35.860 --> 01:36:41.860]  Мы собираем такой вот кворумный сертификат, вот этот вот.
[01:36:41.860 --> 01:36:47.860]  Мы честный узел знаем, что на большинстве честных одна и та же транзакция.
[01:36:47.860 --> 01:36:51.860]  После следующей фазы commit наше знание усложняется.
[01:36:51.860 --> 01:37:00.860]  Теперь мы знаем, что большинство честных знает, что на большинстве честных лежит одна и та же транзакция.
[01:37:00.860 --> 01:37:05.860]  И теперь большинство честных узлов, некоторое большинство честных узлов,
[01:37:05.860 --> 01:37:11.860]  этот факт, знания того, что транзакция лежит на большинстве честных,
[01:37:11.860 --> 01:37:15.860]  могут доказать потому, что у них есть кворумный сертификат.
[01:37:15.860 --> 01:37:17.860]  То есть вот здесь мы собираем кворумный сертификат,
[01:37:17.860 --> 01:37:23.860]  а здесь мы собираем можно сказать кворумный сертификат кворумного сертификата.
[01:37:23.860 --> 01:37:50.860]  Не то чтобы прямо сейчас я этим наблюдением собираюсь воспользоваться, но через неделю я продемонстрирую некоторую аналогию, как именно похожее накопление знаний, голосов возникает в Биткоине,
[01:37:50.860 --> 01:38:08.860]  а еще позже, когда мы будем говорить про Hot Stuff, я покажу, как можно идеи Биткоина и идеи PBFT совместить в более эффективный протокол, который будет эффективно пайплайнить вот сборку этих кворумов, кворумов, кворумов и так далее.
[01:38:11.860 --> 01:38:14.860]  Ну что ж, тогда на сегодня все. Спасибо.
