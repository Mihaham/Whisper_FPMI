[00:00.000 --> 00:11.640]  Ну что, поехали? Напомню, что в прошлый раз мы с вами перешли в новую модель сбоев,
[00:11.640 --> 00:17.160]  византийских сбоев, где сбоенные узлы могли не просто рестартовать, не просто перезагружаться,
[00:17.160 --> 00:24.080]  они могли еще и произвольным образом нарушать протокол. И в этой модели мы делили узлы не на
[00:24.080 --> 00:31.280]  корректные и сбоенные, а скорее на честные и нечестные, на честные узлы и злоумышленников,
[00:31.280 --> 00:37.520]  которые пытаются систему привести в какое-то некорректное состояние, возможно, кооперируя
[00:37.520 --> 00:44.400]  свои действия. И в этой модели мы по-прежнему хотим уметь решать задачу консенсуса, то есть задачу
[00:44.400 --> 00:53.520]  репликации через задачу консенсуса. И в прошлый раз мы с вами показали, во-первых, что решать задачу
[00:53.520 --> 00:58.600]  консенсуса в модели с византийскими сбоями, где узлы произвольным образом нарушают протокол,
[00:58.600 --> 01:14.960]  можно, если число узлов в три раза больше, число честных, число реплик в три раза больше, чем число
[01:14.960 --> 01:22.880]  сбоев, которые мы закладываем. Мы доказали вот эту нижнюю оценку двумя способами. Во-первых,
[01:22.880 --> 01:29.640]  для разных условий. Во-первых, мы доказали, что даже в случае, когда у нас сеть синхронная,
[01:29.640 --> 01:36.600]  но когда честный узел может в голове, сбойный узел может в голове моделировать честные узлы,
[01:36.600 --> 01:43.360]  то вот в таких условиях нижнюю оценка справедлива. И во-вторых, мы показали, что если сеть частично
[01:43.360 --> 01:48.080]  синхронная, то даже имея механизм цифровых подписей, даже имея инфраструктуру открытых ключей,
[01:48.080 --> 01:58.480]  мы не можем переживать вот больше, чем f сбоев, если у нас 3f плюс 1. Помимо этой оценки, мы с вами
[01:58.480 --> 02:04.320]  построили алгоритм Ben Oro, который решал такую довольно искусственную задачу бинарного консенсуса,
[02:04.320 --> 02:17.360]  причем решал ее не очень эффективно, а именно ему требовалось 5f плюс одна реплика. Этот результат
[02:17.360 --> 02:23.120]  сам по себе для нас не очень ценен, все-таки мы заботимся о том, чтобы строить что-то прикладное,
[02:23.120 --> 02:30.400]  что-то эффективное. Но все же мы, разбираясь с этим алгоритмом и с такой наивной задачей консенсус
[02:30.400 --> 02:38.080]  изолированной, мы с вами изучили две полезные техники, которые мы с вами сможем добавить в свой
[02:38.080 --> 02:44.160]  арсенал и с помощью них строить что-то более практичное, тема сегодняшнего занятия. Во-первых,
[02:44.160 --> 02:50.160]  мы с вами обратили внимание, что для того, чтобы вообще строить какие-либо алгоритмы в
[02:50.160 --> 02:56.240]  бизантийской модели, нам нужно решать задачу аутентификации. Если узел A получает сообщение от
[02:56.240 --> 03:01.360]  узла B, то узел A должен действительно убедиться, что это сообщение отправлено именно узлом B,
[03:01.360 --> 03:06.480]  а не каким-то другим узлом-злоумышленником, который только представляется как B. И для этого нам
[03:06.480 --> 03:16.840]  был нужен механизм цифровых подписей. Это не единственный механизм, с помощью которого можно
[03:16.840 --> 03:24.080]  решать задачу аутентификации, и мы сегодня рассмотрим другой. Но в первую очередь мы сегодня
[03:24.080 --> 03:28.320]  будем работать именно с цифровыми подписами. Это будет наш основной механизм аутентификации.
[03:28.320 --> 03:36.680]  Вторая техника, которую мы увидели, обобщала ранее известную. Раньше мы работали с простыми
[03:36.680 --> 03:41.920]  системы кворумов, где кворумы пересекаются, по крайней мере, по одному узлу. Сейчас нам этого мало,
[03:41.920 --> 03:47.320]  потому что в пересечении кворумов может быть нечестный византийский узел, и он нам может
[03:47.320 --> 03:56.240]  соврать. Поэтому мы перешли к технике византийских кворумов, где кворумы пересекаются либо по 2f
[03:56.640 --> 04:01.480]  плюс в одном узлу, такая система кворумов называется маскирующей, или по f плюс
[04:01.480 --> 04:06.420]  в одном узлу. В первом случае, когда в пересечении f плюс в один узел, мы знаем, что в пересечении
[04:06.420 --> 04:12.840]  большинству честных, и вот большинство честных могут подавить нечестные просто количества. Если же
[04:12.840 --> 04:17.680]  кворумы пересекаются по крайней мере по f плюс в одном узлу, то мы уверены, что в пересечении есть
[04:17.680 --> 04:23.860]  по крайней мере один честный узел, и, если через кворумы, через пересещение кворумов, передаются
[04:23.860 --> 04:27.860]  аутентифицированные данные, то есть данные, снабженные подписями, то этого
[04:27.860 --> 04:30.860]  будет достаточно. Вот сегодня мы будем использовать именно такие системы
[04:30.860 --> 04:36.860]  кворумов, они называются dissemination, системы кворумов, рассеивающие это так.
[04:36.860 --> 04:42.860]  Но все же, у нас есть нижняя оценка n больше 3f, у нас есть цифровые
[04:42.860 --> 04:46.860]  подписи, у нас есть византийские кворумы.
[04:47.860 --> 04:54.860]  Но мы пока не знаем, достижима ли эта оценка снизу.
[04:54.860 --> 04:58.860]  Можем ли мы построить алгоритм консенсуса, который будет переживать
[04:58.860 --> 05:05.860]  f византийских сбоев и обходиться 3f плюс 1 репликой, а не 5f плюс 1?
[05:05.860 --> 05:10.860]  Вот сегодня мы изучим такой алгоритм, и он будет называться practical BFT.
[05:10.860 --> 05:16.860]  BFT.
[05:16.860 --> 05:28.860]  Это результат 1999 года, авторы Мегель Кастро и Барбара Лисков.
[05:28.860 --> 05:37.860]  И этот алгоритм будет решать незадачу консенсуса в изоляции, как когда-то
[05:37.860 --> 05:41.860]  мы называли single degree praxis, а этот алгоритм будет решать задачу
[05:41.860 --> 05:45.860]  репликации лога, как multipaxis или как raft.
[05:45.860 --> 05:50.860]  И этот алгоритм снова будет работать как multipaxis или raft в некоторые
[05:50.860 --> 05:54.860]  жесткой фиксированные конфигурации, но уже в конфигурации оптимального размера,
[05:54.860 --> 06:03.860]  а именно в конфигурации из 3f плюс 1 узла.
[06:03.860 --> 06:07.860]  Вообще говоря, в византийской модели различают два подхода.
[06:07.860 --> 06:10.860]  Когда мы фиксируем количество реплик и когда мы не фиксируем.
[06:10.860 --> 06:15.860]  Вот когда мы фиксируем количество реплик, такой подход называется permissioned.
[06:15.860 --> 06:23.860]  В следующий раз у нас будет bitcoin, и там число реплик не фиксировано,
[06:23.860 --> 06:26.860]  реплики могут свободно присоединяться к сети и уходить.
[06:26.860 --> 06:31.860]  Такой подход называется permissionless.
[06:31.860 --> 06:35.860]  Ну что, давайте поговорим про то, как этот алгоритм работает.
[06:35.860 --> 06:39.860]  Точнее, не так. Прежде чем говорить про то, как он работает,
[06:39.860 --> 06:41.860]  нужно вообще представить, зачем он нам.
[06:41.860 --> 06:46.860]  Вот он реплицирует некоторый лог, а этот лог нужен для чего?
[06:46.860 --> 06:48.860]  Каково состояние, которое мы будем реплицировать?
[06:48.860 --> 06:51.860]  Раньше мы говорили, что это не очень важно.
[06:51.860 --> 06:54.860]  Пусть мы реплицируем некоторый автомат.
[06:54.860 --> 06:58.860]  В него поступают команды, нам эти команды нужно упорядочить на разных репликах,
[06:58.860 --> 07:01.860]  и эти реплики будут применять в одном и том же порядке
[07:01.860 --> 07:03.860]  и двигаться по полной той же истории.
[07:03.860 --> 07:10.860]  Сегодня мы все еще будем абстрагироваться от конкретного реплицированного состояния,
[07:10.860 --> 07:14.860]  но на будущее скажем, что все-таки оно не совсем произвольное,
[07:14.860 --> 07:16.860]  потому что с этим состоянием работают клиенты,
[07:16.860 --> 07:19.860]  среди которых тоже могут быть византийские узлы,
[07:19.860 --> 07:21.860]  которые тоже могут быть злоумышленниками.
[07:21.860 --> 07:23.860]  Поэтому, вообще говоря, само реплицируемое состояние
[07:23.860 --> 07:26.860]  должно быть устойчиво к нечестным клиентам.
[07:26.860 --> 07:30.860]  Как именно это состояние будет устроено?
[07:30.860 --> 07:32.860]  Мы поговорим в следующий раз на примере Биткоина.
[07:32.860 --> 07:37.860]  Ну а пока лишь скажем, что мы будем использовать немного альтернативную лексику,
[07:37.860 --> 07:41.860]  мы будем говорить не про команды, мы будем говорить про транзакции.
[07:41.860 --> 07:44.860]  И вот пусть у нас есть 3F плюс 1 реплика.
[07:44.860 --> 07:49.860]  Мы зафиксируем, пусть мы готовы пережить один отказ,
[07:49.860 --> 07:52.860]  и поэтому мы используем 4 реплики.
[07:52.860 --> 07:55.860]  На картинках у нас всегда будет сегодня 4 узла.
[07:55.860 --> 08:03.860]  И вот они как-то решают задачу репликации лога.
[08:03.860 --> 08:06.860]  Они реализуют некоторый ordering service.
[08:06.860 --> 08:08.860]  Пока даже не важно каким образом.
[08:08.860 --> 08:12.860]  И с этой системой работает клиент.
[08:12.860 --> 08:17.860]  Клиент отправляет сюда свою транзакцию.
[08:18.860 --> 08:22.860]  Он хочет, чтобы транзакция зафиксировалась
[08:22.860 --> 08:25.860]  в порядковой номеротности на других транзакций,
[08:25.860 --> 08:29.860]  и рано или поздно применилась к некоторому репликированному состоянию.
[08:29.860 --> 08:33.860]  После чего клиент получит некоторый ответ.
[08:39.860 --> 08:43.860]  Мы сейчас говорим про то, как устроен протокол клиента.
[08:48.860 --> 08:52.860]  Во-первых, заметим, что с византийской системой
[08:52.860 --> 08:55.860]  вот так вот прям взаимодействовать нельзя.
[08:55.860 --> 08:58.860]  Мы могли так взаимодействовать с мультипакс и с мультирафтом,
[08:58.860 --> 09:01.860]  потому что каждый узел вел себя честно.
[09:01.860 --> 09:05.860]  Но сейчас, если мы отправляем свою транзакцию к какому-то конкретному узлу,
[09:05.860 --> 09:09.860]  а он окажется с византийским, то он может нам просто выдумать ответ.
[09:09.860 --> 09:12.860]  Базовое правило любой византийской системы,
[09:12.860 --> 09:16.860]  мы никогда не можем доверять ответу какого-то конкретного узла.
[09:16.860 --> 09:20.860]  Мы всегда должны доверять только группе узлов.
[09:20.860 --> 09:23.860]  Поэтому на месте клиента нам мало дождаться одного ответа.
[09:23.860 --> 09:28.860]  Видимо, нам нужно дождаться некоторого количества ответов от разных реплик.
[09:28.860 --> 09:31.860]  У нас всего 3f плюс 1 реплика.
[09:31.860 --> 09:36.860]  Из них f могут быть византийскими или просто отказать.
[09:36.860 --> 09:41.860]  Поэтому мы можем рассчитывать на то, что мы дождемся 2f плюс 1 ответа.
[09:46.860 --> 09:56.860]  Эти ответы могут быть разными, потому что среди реплик, которые ответили клиенту,
[09:56.860 --> 09:59.860]  есть честные, есть византийские.
[09:59.860 --> 10:05.860]  Но мы предполагаем, что все честные реплики ответили одинаково.
[10:05.860 --> 10:11.860]  И мы знаем, что среди... раз всего мы получили 2f плюс 1 ответ,
[10:11.860 --> 10:21.860]  то среди них есть, по крайней мере, среди этих ответов есть не более чем f ответов от византийских реплик,
[10:21.860 --> 10:25.860]  а значит, по крайней мере, f плюс 1 ответ от честной реплики.
[10:25.860 --> 10:29.860]  И вот эти честные ответы смогут перекрыть византийские.
[10:29.860 --> 10:35.860]  Что мы делаем? Мы на месте клиента дожидаемся, ждем такого количества ответов
[10:35.860 --> 10:40.860]  и выбираем ответ, который повторяется, по крайней мере, f плюс 1 раз.
[10:50.860 --> 10:56.860]  Разумеется, мы должны учитывать, что византийские узлы могут пробовать представляться другими узлами,
[10:56.860 --> 11:00.860]  поэтому все респонсы должны быть снабжены цифровыми подписами.
[11:00.860 --> 11:05.860]  То есть, когда какая-то реплика отвечает, то она подписывает свой ответ.
[11:08.860 --> 11:11.860]  Так что на месте клиента мы дожидаемся такого количества ответов,
[11:11.860 --> 11:17.860]  выбираем f плюс 1 одинаковый, и мы теперь уверены, что среди этих f плюс 1 одинакового
[11:17.860 --> 11:20.860]  есть ответ, по крайней мере, от одного честного узла.
[11:20.860 --> 11:26.860]  Ну а значит, если честные узлы корректно решают задачу консенсуса,
[11:26.860 --> 11:34.860]  то значит и все честные узлы дали бы такой же ответ, так что мы выбираем его.
[11:34.860 --> 11:41.860]  Правда, в таком протоколе есть неудобство, а именно клиент отправляет запрос одному узлу,
[11:41.860 --> 11:46.860]  получит ответ от многих. Нам все же было бы удобно работать в модели клиент-сервер,
[11:46.860 --> 11:50.860]  где мы общаемся только с одним узлом через некоторое соединение.
[11:51.860 --> 11:56.860]  В принципе, такое техническое ограничение, желание сделать именно так,
[11:56.860 --> 11:59.860]  никак не мешает нам воспользоваться тем же самым протоколом.
[11:59.860 --> 12:05.860]  Просто пусть вот этот набор сообщений, которые служат доказательствам того,
[12:05.860 --> 12:11.860]  что честные узлы выбрали некоторый ответ, может накапливать не сам клиент,
[12:11.860 --> 12:15.860]  а может накапливать узел, с которым клиент общается.
[12:16.860 --> 12:20.860]  То есть мы вот эти стрелки сотрем,
[12:25.860 --> 12:31.860]  и пусть другие реплики ответят не напрямую клиенту,
[12:31.860 --> 12:34.860]  а вот тому узлу, который с клиентом общался.
[12:36.860 --> 12:42.860]  И вот уже этот узел отправит клиенту не один респонс,
[12:42.860 --> 12:48.860]  а вот такой набор респонсов, каждый из которых снабжен цифровой подписью.
[12:48.860 --> 12:53.860]  И вот этот набор подписанных ответов мы будем называть сегодня
[12:53.860 --> 12:55.860]  коронным тертификатом.
[12:55.860 --> 13:24.860]  Вот именно с помощью коронных тертификатов
[13:24.860 --> 13:28.860]  в византийской системе, конкретно в Practical BFT,
[13:28.860 --> 13:32.860]  узлы смогут доказывать другим что-то про третьи узлы.
[13:32.860 --> 13:36.860]  То есть здесь один узел может сказать нам, что ответная система именно такой,
[13:36.860 --> 13:38.860]  и приложить вот этот коронный сертификат,
[13:38.860 --> 13:42.860]  тем самым клиент сможет действительно проверить, что его не обманули.
[13:43.860 --> 13:47.860]  Правда тут можно быть еще аккуратнее и подумать над тем,
[13:47.860 --> 13:51.860]  что вдруг византийский узел отправит коронный сертификат,
[13:51.860 --> 13:53.860]  но просто для другой транзакции.
[13:53.860 --> 13:57.860]  Поэтому мы можем сделать еще более аккуратно
[13:57.860 --> 14:04.860]  и сказать, что у нас респонс привязан к некоторому дайджесту,
[14:04.860 --> 14:12.860]  где дайджест это криптографический хэш транзакции.
[14:12.860 --> 14:16.860]  Вот если транзакции уникальные, то есть у них хэши будут разными,
[14:16.860 --> 14:22.860]  ну по модулю того, что конечно в хэш функции может возникнуть какая-нибудь коллизия.
[14:22.860 --> 14:28.860]  Ну вот, если все же транзакции можно различать по хэшам,
[14:28.860 --> 14:32.860]  а мы в следующий раз увидим в Биткоине, что действительно это можно делать,
[14:32.860 --> 14:36.860]  то пусть реплики, которые отвечают клиенту,
[14:36.860 --> 14:41.860]  привязывают свои ответы к хэшу транзакции, подписывают свой ответ,
[14:41.860 --> 14:45.860]  и тогда здесь мы на месте клиента будем уверены,
[14:45.860 --> 14:49.860]  что нам дали сертификат именно для нашей транзакции.
[14:52.860 --> 14:56.860]  Ну и это конечно еще не все, потому что что же делать клиенту,
[14:56.860 --> 15:00.860]  который просто не получил ответ от реплики?
[15:00.860 --> 15:04.860]  Он конечно же завел тайм-аут, завел таймер, отправил свою транзакцию,
[15:04.860 --> 15:08.860]  и если этот таймер протух, если тайм-аут истек,
[15:08.860 --> 15:11.860]  то клиент вообще говоря не понимает, что происходит.
[15:11.860 --> 15:14.860]  Может быть, конечно, этот узел умер, а может быть, этот узел злоумышленника
[15:14.860 --> 15:19.860]  он намеренно умолчал об этой транзакции и просто игнорировал ее.
[15:19.860 --> 15:22.860]  Вот нужно какие-то дополнительные действия придумывать,
[15:22.860 --> 15:26.860]  но мы к ним вернемся позже, а пока заметим еще одну важную деталь.
[15:26.860 --> 15:33.860]  Вот здесь клиент, работая с системой, должен проверять цифровые подписи ответов от реплик.
[15:33.860 --> 15:37.860]  Ну и для того, чтобы их проверять, он собственно должен понимать,
[15:37.860 --> 15:41.860]  какие открытые ключи у этих самых реплик.
[15:41.860 --> 15:44.860]  Для этого нам нужна некоторая вспомогательная инфраструктура.
[15:44.860 --> 15:47.860]  Ну вот для того, чтобы вообще пользоваться цифровыми подписями,
[15:47.860 --> 15:51.860]  нам нужна цифровая инфраструктура, которая называется удостоверяющим центром.
[15:51.860 --> 15:58.860]  Вот представим себе, что вы браузер,
[15:58.860 --> 16:07.860]  и вы идете общаться с некоторым сервером по безопасному соединению.
[16:10.860 --> 16:16.860]  Вы должны узнать открытый ключ у этого сервера, чтобы дальше там работала криптография,
[16:16.860 --> 16:19.860]  чтобы работало безопасное соединение.
[16:19.860 --> 16:26.860]  Но если вам сервер отправит просто пару, я, сервер, и вот мой открытый ключ,
[16:26.860 --> 16:30.860]  то, конечно же, у вас нет оснований ему верить.
[16:30.860 --> 16:34.860]  А что если это с вами разговаривает на самом деле злоумышленник?
[16:34.860 --> 16:47.860]  Поэтому этот документ, который связывает identity и открытый ключ,
[16:47.860 --> 16:51.860]  нужно чем-то подкрепить.
[16:51.860 --> 16:53.860]  Но вот браузер серверу не доверяет.
[16:53.860 --> 16:58.860]  У серверов много разных на свете, мы не можем доверять каждому по умолчанию.
[16:58.860 --> 17:07.860]  Но, может быть, есть некоторый участник удостоверяющий центр.
[17:14.860 --> 17:17.860]  И мы считаем, что вот этому участнику доверяют все.
[17:17.860 --> 17:27.860]  Доверяют в том смысле, что для него открытый ключ этого Си всем известен.
[17:27.860 --> 17:33.860]  И тогда, чтобы сервер мог представиться нам, чтобы он мог сообщить нам открытый ключ,
[17:33.860 --> 17:39.860]  он идет в удостоверяющий центр, и удостоверяющий центр выпускает вот такой документ,
[17:39.860 --> 17:47.860]  который называется цифровым сертификатом, который связывает С и открытый ключ,
[17:47.860 --> 17:54.860]  и этот сертификат подписан секретным ключом удостоверяющего центра.
[17:55.860 --> 17:58.860]  После чего сервер может отправить нам этот сертификат,
[17:58.860 --> 18:04.860]  и если мы доверяем С, то значит, мы теперь можем доверять и серверу.
[18:08.860 --> 18:12.860]  Вот эта конструкция называется инфраструктура открытых ключей.
[18:16.860 --> 18:19.860]  И наш протокол, раз он пользует этими цифровыми подписями,
[18:19.860 --> 18:25.860]  раз клиент все это проверяет, эти кормные сертификаты, ему нуждается инфраструктура.
[18:25.860 --> 18:31.860]  Вопрос, почему мы доверяем в конце концов какому-то одному удостоверяющему центру?
[18:31.860 --> 18:37.860]  Ведь весь смысл нашей конструкции состоит в том, что мы можем взять много реплик
[18:37.860 --> 18:43.860]  и разместить, доверить их эксплуатацию разным организациям.
[18:43.860 --> 18:47.860]  Но говорят в этом контексте про консорциям, есть разные организации,
[18:47.860 --> 18:50.860]  каждый из них отвечает за какую-то группу реплик,
[18:50.860 --> 18:53.860]  и мы каждой конкретной организации на месте клиента не доверяем,
[18:53.860 --> 19:00.860]  но мы все же считаем, что две трети этих организаций, две трети реплик будут честными.
[19:00.860 --> 19:05.860]  Нам этого достаточно. А тут мы почему-то доверяем одному удостоверяющему центру.
[19:05.860 --> 19:08.860]  Но это на самом деле не страшно.
[19:08.860 --> 19:12.860]  Можно доверять и нескольким удостоверяющим центрам,
[19:12.860 --> 19:16.860]  и тогда можно отсеять каких-то подозрительных.
[19:16.860 --> 19:24.860]  То есть не то чтобы у нас есть одна единственная точка доверия, их можно дублировать.
[19:24.860 --> 19:30.860]  И если говорить про реальную жизнь, то тут не то чтобы прям один удостоверяющий центр,
[19:30.860 --> 19:33.860]  потому что он бы, конечно, не выдержал такой нагрузки.
[19:33.860 --> 19:38.860]  На самом деле в жизни у нас есть целая иерархия удостоверяющих центров.
[19:38.860 --> 19:43.860]  И когда вы приходите к серверу, он дает вам сертификат, который подписан
[19:43.860 --> 19:46.860]  с некоторым удостоверяющим центром.
[19:46.860 --> 19:48.860]  Откуда вы знаете его сертификат?
[19:48.860 --> 19:51.860]  Откуда вы знаете его открытый ключ?
[19:51.860 --> 19:54.860]  Для этого ключа есть свой собственный сертификат,
[19:54.860 --> 19:59.860]  который подписан удостоверяющим центром более высокого уровня.
[19:59.860 --> 20:02.860]  Ну а у этого удостоверяющего центра более высокого уровня снова есть некоторые родители,
[20:02.860 --> 20:04.860]  которые выпускают для него сертификат.
[20:04.860 --> 20:07.860]  Ну, и в конце концов мы приходим в некоторые корневые удостоверяющие центр.
[20:07.860 --> 20:13.860]  и если вы браузер, то просто вы в себе несете сертификат
[20:13.860 --> 20:16.860]  этого самого корневого удостоверяющего центра.
[20:16.860 --> 20:19.860]  После этого вы можете спуститься по цепочке и проверить
[20:19.860 --> 20:26.860]  сертификат какого-то конкретного узла.
[20:26.860 --> 20:28.860]  В общем, такая инфраструктура нам требуется.
[20:28.860 --> 20:30.860]  Мы ей сегодня не явно пользуемся,
[20:30.860 --> 20:33.860]  просто потому что мы пользуемся цифровыми подписами.
[20:33.860 --> 20:36.860]  Итак, мы обсудили протокол клиента,
[20:36.860 --> 20:38.860]  как ему получить ответ от системы,
[20:38.860 --> 20:43.860]  как среди разных ответов выбрать ответ честных узлов,
[20:43.860 --> 20:46.860]  в предположении, что византийских узлов все-таки не больше,
[20:46.860 --> 20:48.860]  чем заложенный параметр f.
[20:48.860 --> 20:50.860]  Ну а если больше, то рассчитывать тут не на что, конечно.
[20:50.860 --> 20:52.860]  Мы об этом в прошлый раз говорили.
[20:52.860 --> 20:56.860]  А теперь нужно разобраться, что все-таки внутри этого контуры происходит.
[20:56.860 --> 20:59.860]  Как именно будет устроен сегодняшний алгоритм?
[20:59.860 --> 21:03.860]  Вот пока вся эта конструкция, этот алгоритм мало зависела.
[21:03.860 --> 21:05.860]  Зависела, но не правда, она зависела,
[21:05.860 --> 21:08.860]  но только в том смысле, что этот алгоритм, он permission,
[21:08.860 --> 21:10.860]  то есть он фиксирует число реплика.
[21:10.860 --> 21:12.860]  Теперь перейдем внутрь этого контуры
[21:12.860 --> 21:15.860]  и поговорим, как устроен PBFT.
[21:15.860 --> 21:18.860]  Этот алгоритм возник не на пустом месте,
[21:18.860 --> 21:20.860]  он развивает идеи другого алгоритма,
[21:20.860 --> 21:23.860]  который называется just-time replication.
[21:29.860 --> 21:39.860]  Это алгоритм, который реплицирует лог
[21:39.860 --> 21:41.860]  на не византийской модели, а в обычной,
[21:41.860 --> 21:43.860]  где есть рестарты и отказы узлов.
[21:43.860 --> 21:46.860]  То есть это некоторый аналог мультипаксиса и RAFTA.
[21:46.860 --> 21:50.860]  Но любопытно, что этот алгоритм был придуман раньше и RAFTA,
[21:50.860 --> 21:52.860]  который был придуман в 2012-13 году,
[21:52.860 --> 21:56.860]  и мультипаксиса, который придуман в начале 90-х.
[21:56.860 --> 22:01.860]  Just-time replication придуман в 1988 году.
[22:04.860 --> 22:10.860]  Но так случилось, что он не получил популярности,
[22:10.860 --> 22:12.860]  не получил распространения,
[22:12.860 --> 22:15.860]  и мы знаем про мультипаксис, мы знаем про RAFTA,
[22:15.860 --> 22:18.860]  а про just-time replication мы говорим в контексте
[22:18.860 --> 22:22.860]  такого алгоритма, который опирается на VR.
[22:22.860 --> 22:25.860]  И вообще говоря, это удивительно,
[22:25.860 --> 22:28.860]  потому что just-time replication — это алгоритм,
[22:28.860 --> 22:34.860]  который очень разумно, очень понятно устроен.
[22:34.860 --> 22:37.860]  В нём, как и в мультипаксисе, как и в RAFTA,
[22:37.860 --> 22:39.860]  есть понятие эпохи.
[22:39.860 --> 22:42.860]  Только название у этих эпох, опять, особенное.
[22:42.860 --> 22:46.860]  В паксисе это были ballot numbers, в RAFTA это были термы.
[22:46.860 --> 22:50.860]  В just-time replication эпохи называются view.
[22:50.860 --> 22:53.860]  Отсюда и название протокола.
[22:55.860 --> 22:59.860]  И к этим эпохам, к этим view, как и в RAFTA,
[22:59.860 --> 23:02.860]  привязано понятие лидера, привязан лидер.
[23:02.860 --> 23:05.860]  Узел, который занимается упорядочиванием
[23:05.860 --> 23:08.860]  всех команд, транзакций, которые поступают от клиентов.
[23:08.860 --> 23:11.860]  Этот лидер называется primary.
[23:13.860 --> 23:16.860]  Primary всегда находится в некотором терме.
[23:20.860 --> 23:24.860]  Опять же, just-time replication использует эти view
[23:24.860 --> 23:28.860]  ровно таким же способом, как их использует RAFTA,
[23:28.860 --> 23:32.860]  просто для того, чтобы блокировать устаревших лидеров.
[23:32.860 --> 23:35.860]  Если система перешла в новую эпоху,
[23:35.860 --> 23:38.860]  если большинство узлов следует уже за новым primary,
[23:38.860 --> 23:42.860]  то старый primary не может закомитить новую транзакцию,
[23:42.860 --> 23:45.860]  потому что в пересечении будут реплики,
[23:45.860 --> 23:48.860]  в пересечение его кворума и кворума, которые уже проголосовали
[23:48.860 --> 23:51.860]  и в праймари будет реплика, которая отвергнет,
[23:51.860 --> 23:57.860]  глядя на эту view, сообщение от праймари из прошлой эпохи.
[23:57.860 --> 24:01.860]  На этом сходство не заканчивается, их довольно много.
[24:01.860 --> 24:06.860]  Я бы сказал, что этот алгоритм довольно сильно напоминает RAFTA,
[24:06.860 --> 24:10.860]  потому что, так же, как и в RAFTA, этот алгоритм декомпозирован
[24:10.860 --> 24:16.860]  по двум фазам. Фаза, где есть primary
[24:16.860 --> 24:19.860]  и он занимается репликацией,
[24:19.860 --> 24:21.860]  и есть фаза, где выбирается новый primary,
[24:21.860 --> 24:23.860]  она называется viewchange.
[24:23.860 --> 24:26.860]  Вообще, когда авторы RAFTA писали свою статью,
[24:26.860 --> 24:29.860]  они там отдельно говорят, они сравнивают свой алгоритм
[24:29.860 --> 24:31.860]  с мультипаксосом и говорят, что он проще,
[24:31.860 --> 24:34.860]  потому что в мультипаксосе выбрана неверная декомпозиция,
[24:34.860 --> 24:37.860]  что задача репликации лого поделена по слотам,
[24:37.860 --> 24:40.860]  и в каждом слоте решаются свои независимые задачи консенсуса,
[24:40.860 --> 24:44.860]  и ее решение не имеет какого-то осязаемого физического смысла.
[24:44.860 --> 24:47.860]  Сложно увидеть физический смысл в sync-decrep-аксосе,
[24:47.860 --> 24:49.860]  пока мы его не промасштабируем на весь лог.
[24:49.860 --> 24:51.860]  Только тогда у нас появится понятие эпохи,
[24:51.860 --> 24:55.860]  лидера, блокировки старых лидеров и так далее.
[24:55.860 --> 24:58.860]  Так вот, эта идея декомпозиции по фазам,
[24:58.860 --> 25:01.860]  по фазе выбора лидера и по фазе репликации,
[25:01.860 --> 25:03.860]  она была придумана еще в 1988 году.
[25:03.860 --> 25:07.860]  Причем мне кажется, что даже в этом подходе
[25:07.860 --> 25:09.860]  была выбрана более удачная лексика,
[25:09.860 --> 25:13.860]  потому что в RAFTA смена эпохи называется выбором лидера,
[25:13.860 --> 25:17.860]  а в view-stamped replication она называется view-change.
[25:19.860 --> 25:22.860]  И мне кажется, что этот термин лучше подходит,
[25:22.860 --> 25:25.860]  потому что он лучше отражает суть сложность задачи.
[25:25.860 --> 25:28.860]  Сложность задачи не в том, чтобы выбрать нового лидера,
[25:28.860 --> 25:30.860]  а в том, чтобы аккуратно сменить эпоху
[25:30.860 --> 25:33.860]  и не забыть все ранее закоммиченные команды.
[25:33.860 --> 25:35.860]  Напомню, что в RAFTA доказывали,
[25:35.860 --> 25:37.860]  что транзакция команды закоммичена,
[25:37.860 --> 25:39.860]  если она переживает смену эпохи,
[25:39.860 --> 25:45.860]  и она будет непременно находиться в логе лидера любого будущего терма.
[25:45.860 --> 25:48.860]  Вот сложность в том, чтобы аккуратно эпоху сменить.
[25:48.860 --> 25:51.860]  И лексика view-stamped replication эта сложность подчеркивает.
[25:52.860 --> 25:56.860]  Почему же алгоритм, если он такой разумный, был надолго забыт?
[25:56.860 --> 26:01.860]  Дело в том, что оригинальная статья вышла довольно, кажется, запутанной,
[26:01.860 --> 26:05.860]  и там алгоритм view-stamped replication, сам алгоритм репликации,
[26:05.860 --> 26:09.860]  в том, что эпоха декомпозирован от каких-то ненужных инженерных подробностей,
[26:09.860 --> 26:14.860]  но, кажется, уже в 2000-х годах авторы этого алгоритма
[26:14.860 --> 26:16.860]  переписали статью заново,
[26:16.860 --> 26:19.860]  написали статью, которая называется view-stamped replication revisited,
[26:19.860 --> 26:22.860]  и вот она уже очень хорошая, очень понятная,
[26:22.860 --> 26:24.860]  и я всем рекомендую ее прочитать.
[26:24.860 --> 26:30.860]  Ну хорошо, мы собираемся сегодня для репликации использовать
[26:30.860 --> 26:33.860]  примерно такие же идеи.
[26:33.860 --> 26:35.860]  У нас четыре реплики.
[26:35.860 --> 26:39.860]  Давайте мы нарисуем процедуру репликации.
[26:45.860 --> 26:47.860]  У нас будут четыре реплики.
[26:47.860 --> 27:05.860]  И среди них одна из реплик назначена primary.
[27:05.860 --> 27:21.860]  Давайте немного передвинем нашу картинку.
[27:21.860 --> 27:24.860]  По-другому организуем пространство.
[27:24.860 --> 27:29.860]  Нарисуем ее вот здесь, чтобы места было побольше.
[27:35.860 --> 27:46.860]  Вторая реплика является primary.
[27:46.860 --> 27:50.860]  Ее функция упорядочивать транзакции,
[27:50.860 --> 27:53.860]  которые поступают от пользователей.
[27:53.860 --> 27:56.860]  Мы пока не говорим, откуда этот primary взялся,
[27:56.860 --> 27:58.860]  как именно он выбран.
[27:58.860 --> 28:01.860]  Пусть он уже есть, но и мы будем пользоваться этим фактом.
[28:01.860 --> 28:06.860]  Он получает транзакцию от пользователя,
[28:06.860 --> 28:12.860]  и его задача выбрать для этой транзакции порядковый номер,
[28:12.860 --> 28:14.860]  выбрать ее позицию в логе.
[28:14.860 --> 28:20.860]  После чего primary раздаст эту транзакцию с присвоенным порядковым номером другим репликом.
[28:20.860 --> 28:22.860]  Это первая фаза.
[28:22.860 --> 28:37.860]  Здесь мы отправляем сообщение, которое называется prepare.
[28:37.860 --> 28:45.860]  Primary говорит остальным репликам, что в текущей эпохе В
[28:45.860 --> 28:51.860]  я присвоил порядковый номер S транзакции с дайджестом,
[28:51.860 --> 28:57.860]  здесь криптографическим хэшом D.
[28:57.860 --> 29:01.860]  И разумеется, он свое сообщение подписывает.
[29:01.860 --> 29:03.860]  Своим секретным ключом.
[29:03.860 --> 29:07.860]  И отдельно предлагает к этому prepare собственно отправленную транзакцию.
[29:07.860 --> 29:13.860]  То есть в этом сообщении только хэш, а здесь отдельно сама транзакция.
[29:13.860 --> 29:18.860]  Обратите внимание, что сегодня мы говорим именно про сообщение.
[29:18.860 --> 29:24.860]  Вот скажем, в протоколе RAFT в статье используется термин RPC, то есть удаленный вызов.
[29:24.860 --> 29:28.860]  Вот нам сегодня важно, что это не RPC, это именно сообщение,
[29:28.860 --> 29:32.860]  потому что мы эти сообщения дальше будем пересылать другим узлам.
[29:32.860 --> 29:35.860]  Но чуть позже увидим, как это будет работать.
[29:35.860 --> 29:39.860]  Итак, у нас есть реплики, они получили от primary команду,
[29:39.860 --> 29:45.860]  потому что нужно положить в слот S транзакцию с дайджестом D вот в текущей эпохе.
[29:45.860 --> 29:54.860]  Но, конечно же, да, и вот в USTMP replication дальше эти реплики добавляли себе в лог эту транзакцию,
[29:54.860 --> 29:57.860]  отправляли подтверждение primary, primary собирал quorum,
[29:57.860 --> 30:01.860]  и в общем команда после этого коммитилась.
[30:01.860 --> 30:08.860]  Разумеется, в нашей византийской модели такого наивного протокола будет уже недостаточно.
[30:08.860 --> 30:11.860]  Потому что просто-напросто primary может быть византийским,
[30:11.860 --> 30:15.860]  и он может не исполнить функции, которые у него возложены.
[30:15.860 --> 30:21.860]  Вот давайте подумаем, что может делать primary, как он может нарушать протокол.
[30:21.860 --> 30:25.860]  Ну скажем, он может получить транзакцию и продублировать ее,
[30:25.860 --> 30:29.860]  то есть назначить ей сразу несколько порядковых номеров.
[30:29.860 --> 30:34.860]  Или он может транзакции игнорировать, может игнорировать все транзакции,
[30:34.860 --> 30:39.860]  может игнорировать транзакции какого-то пользователя, которого primary не любит.
[30:39.860 --> 30:45.860]  Не знаю почему. То есть он может выкидывать какие-то конкретные транзакции.
[30:45.860 --> 30:53.860]  Ну и наконец, primary может назначать транзакции в разном порядке для разных реплик.
[30:53.860 --> 31:00.860]  Или это можно сказать по-другому, что для какого-то порядкового номера S
[31:00.860 --> 31:07.860]  primary может назначить разные транзакции разным репликам.
[31:07.860 --> 31:14.860]  Можно придумывать еще некоторые случаи византийского поведения, но основные эти.
[31:14.860 --> 31:22.860]  И наша задача сейчас придумать, а как же мы можем с таким поведением византийского primary справиться.
[31:22.860 --> 31:26.860]  Хотя стойте, нужно подумать над другим вопросом.
[31:26.860 --> 31:29.860]  А зачем мы вообще выбрали византийского primary?
[31:29.860 --> 31:36.860]  Может быть наша беда в этом, может быть нам не нужно справляться со всеми этими действиями нечестного primary,
[31:36.860 --> 31:39.860]  может быть нам просто нужно изменить протокол выбора этого primary.
[31:39.860 --> 31:47.860]  Конечно же так не выйдет, потому что primary может начать вести себя по-византийски уже после того,
[31:47.860 --> 31:52.860]  как он выбран primary. А до этого он может вести себя честно, вводя другие заблуждения.
[31:52.860 --> 31:55.860]  То есть он злоумышленник, но он ведет себя честно, соблюдает протокол до тех пор,
[31:55.860 --> 32:01.860]  пока он не станет primary, а после этого он уже начинает действовать вот так вот вредно.
[32:01.860 --> 32:06.860]  Дублировать транзакции, выкидывать транзакции, назначить разные транзакции в один слот.
[32:06.860 --> 32:11.860]  Так что мы от этого обязаны защититься на уровне протокола.
[32:11.860 --> 32:15.860]  Давайте с каждой проблемой разберемся.
[32:15.860 --> 32:23.860]  Начнем с дублирования транзакций. Вот как раз эту проблему на уровне протокола репликации, наверное, решать не стоит.
[32:23.860 --> 32:29.860]  Мне кажется, что эту проблему нужно делегировать вот тому состоянию выше, которое мы реплицируем.
[32:29.860 --> 32:36.860]  Вот если вы вспомните рафты, если вы писали в домашней работе в рафте exactly once,
[32:36.860 --> 32:42.860]  то и думали про снапшоты, чтобы обрезать лог, то вы должны понимать,
[32:42.860 --> 32:48.860]  что exactly once реализуется скорее на уровне автомата, а не на уровне самого рафта.
[32:48.860 --> 32:54.860]  От рафта требуется семантика at least once, чтобы каждая команда была реплицирована по крайней мере один раз.
[32:54.860 --> 32:59.860]  А вот exactly once или, может быть, at most once после некоторого TTL
[32:59.860 --> 33:06.860]  вы должны гарантировать уже на уровне самого реплицируемого состояния, которое потом снапшотится.
[33:06.860 --> 33:13.860]  Короче говоря, мы эту задачу обсудим, но обсудим в следующий раз и на уровне,
[33:13.860 --> 33:18.860]  например, биткоина, на уровне криптовалюты, которую мы будем строить.
[33:18.860 --> 33:22.860]  Вот там дублирование транзакций никак не помешает.
[33:22.860 --> 33:28.860]  Так что сегодня это не проблема, если primary задублирует транзакцию.
[33:28.860 --> 33:31.860]  Подозрительно, но не смертельно.
[33:31.860 --> 33:39.860]  Но вот если primary выкинет транзакцию, то это уже печально, потому что мы теряем свойство liveness.
[33:39.860 --> 33:46.860]  Для клиента выглядит так. Мы отправляем систему транзакцию и ожидаем, что eventually она упорядочится относительно других транзакций
[33:46.860 --> 33:52.860]  и применится к нашему реплицированному состоянию.
[33:52.860 --> 33:57.860]  Тут наш транзакцию может выкинуть.
[33:57.860 --> 34:03.860]  Ну хорошо, давайте вернемся на эту картинку и подумаем, как справиться с таким поведением primary.
[34:03.860 --> 34:06.860]  Что делать, если он выкидывает нашу транзакцию?
[34:06.860 --> 34:15.860]  Видимо, мы не получаем ответа, то есть мы не получаем этого кворомного сертификата.
[34:15.860 --> 34:21.860]  У нас истекает некоторый таймер.
[34:21.860 --> 34:27.860]  Что после этого мы делаем? Мы, конечно, подозреваем primary.
[34:27.860 --> 34:32.860]  И мы этим своим соображением, что primary, возможно, византийский,
[34:32.860 --> 34:36.860]  но может быть он просто отказал, может быть он византийский, мы это пока не понимаем,
[34:36.860 --> 34:45.860]  и мы этим делимся с остальными репликами.
[34:45.860 --> 34:52.860]  Мы отправляем им транзакцию.
[34:52.860 --> 34:57.860]  И что делает каждая реплика? Она просто сама теперь становится клиентом.
[34:57.860 --> 35:02.860]  То есть смотрите, вот здесь клиент, не дождавшись ответа от системы,
[35:02.860 --> 35:05.860]  говорит остальным репликам, что я отправлял транзакцию,
[35:05.860 --> 35:08.860]  отправлял транзакцию, видимо, primary, да, я не проговорил это,
[35:08.860 --> 35:13.860]  конечно же клиент общается с primary.
[35:13.860 --> 35:17.860]  Так вот, клиент не получил от primary ответа,
[35:17.860 --> 35:21.860]  пожаловался на этого primary другим узлам,
[35:21.860 --> 35:27.860]  но сама по себе такая жалоба не должна приводить к тому, что узлы, скажем,
[35:27.860 --> 35:31.860]  перевыберут новую primary, потому что эта жалоба, ну потому что клиент мог
[35:31.860 --> 35:35.860]  просто оклеветать primary, он мог ничего ему не отправлять.
[35:35.860 --> 35:40.860]  Так что что делает честный узел, который получил транзакцию от клиента в обход primary?
[35:40.860 --> 35:44.860]  Он сам перепроверяет верно ли, что primary честный, он сам становится клиентом
[35:44.860 --> 35:48.860]  и отправляет primary эту транзакцию.
[35:48.860 --> 35:52.860]  Но я вот воспользуюсь этой стрелочкой, она имела другой смысл,
[35:52.860 --> 35:55.860]  ну вот я, ладно, нарисую новую.
[35:55.860 --> 35:59.860]  Реплика отправляет эту транзакцию на primary.
[35:59.860 --> 36:07.860]  И теперь эта реплика знает, что если от primary транзакции не приходят
[36:07.860 --> 36:11.860]  по истечении некоторого тайм-аута,
[36:11.860 --> 36:16.860]  то primary, видимо, ее выкидывает, видимо, primary нарушает свой протокол.
[36:16.860 --> 36:22.860]  И тогда уже, видимо, эта реплика захочет primary поменять.
[36:22.860 --> 36:27.860]  Пока реплика не знает ничего про эту транзакцию, то она, конечно же,
[36:27.860 --> 36:30.860]  может доверять текущему primary.
[36:30.860 --> 36:34.860]  В конце концов, византийский primary может не отправлять транзакции
[36:34.860 --> 36:37.860]  остальным репликам, но может отправлять какие-нибудь, скажем,
[36:37.860 --> 36:40.860]  хардбиты о том, что он все еще жив.
[36:40.860 --> 36:45.860]  И честная реплика, пока она не поговорила с клиентом напрямую,
[36:45.860 --> 36:47.860]  она не различает две ситуации.
[36:47.860 --> 36:49.860]  Когда у primary просто не было транзакции,
[36:49.860 --> 36:52.860]  или когда клиент ее отправил, а primary ее проигнорировал.
[36:52.860 --> 36:55.860]  Вот для того, чтобы эти два сценария отличить,
[36:55.860 --> 36:57.860]  клиент сам отправляет транзакцию репликам,
[36:57.860 --> 37:01.860]  реплики пересылают ее, заводят у себя таймер.
[37:01.860 --> 37:06.860]  И если этот таймер истекает, а primary так и не прислал нам
[37:06.860 --> 37:10.860]  сообщения при API.PR, то реплика справедливо считает,
[37:10.860 --> 37:14.860]  что primary византийский и, наверное, его меняет.
[37:14.860 --> 37:17.860]  Про смену эпохи мы поговорим чуть позже.
[37:17.860 --> 37:22.860]  Вернемся пока на эту картинку и вспомним, что мы разбирали три проблемы.
[37:22.860 --> 37:25.860]  Дублирование транзакций, выкидывание транзакций.
[37:25.860 --> 37:27.860]  Вот с выкидыванием транзакций мы разобрались.
[37:27.860 --> 37:30.860]  По модулю того, что мы пока не описали, как именно поменять эпоху,
[37:30.860 --> 37:32.860]  как именно поменять primary.
[37:32.860 --> 37:36.860]  Но если мы это умеем делать, то, значит, и с таким поведением тоже справимся.
[37:36.860 --> 37:42.860]  И остается третья проблема, а именно, что primary по разному порядочевой транзакции
[37:42.860 --> 37:47.860]  выбирает разных реплик или для некоторого порядкового номера S,
[37:47.860 --> 37:53.860]  для некоторого слота primary выбирает разные транзакции для разных реплик.
[37:53.860 --> 37:55.860]  Давайте я здесь поясню.
[37:55.860 --> 38:01.860]  V – это view, в котором лежит primary.S – это слот, порядковый номер.
[38:01.860 --> 38:14.860]  Итак, реплики ждут prepare, получают его, но, правда, они не понимают,
[38:14.860 --> 38:18.860]  может быть, primary раздал разные транзакции этим самым репликам.
[38:18.860 --> 38:22.860]  Доверять primary, вообще говоря, оснований нет.
[38:22.860 --> 38:26.860]  Точнее, мы надеемся, что он честный, но на всякий случай мы должны проверить,
[38:26.860 --> 38:31.860]  что он все же не обманывает нас.
[38:31.860 --> 38:39.860]  Для этого мы заводим дополнительную фазу, где каждая реплика посылает другим репликам,
[38:39.860 --> 38:44.860]  здесь происходит такая квадратичная коммуникация, все общаются со всеми,
[38:44.860 --> 38:54.860]  каждая реплика посылает другим сообщение, которое мы назовем,
[38:54.860 --> 39:00.860]  ну не мы назовем, в фибиофейне так называются, сообщение prepare.
[39:00.860 --> 39:08.860]  Сообщение означает, что я и эта реплика получила от primary в эпохе V,
[39:08.860 --> 39:13.860]  в слоте S, транзакцию с дайджестом D.
[39:13.860 --> 39:17.860]  И, разумеется, я свое сообщение и эта реплика подписываю.
[39:17.860 --> 39:29.860]  И теперь, если я какая-то реплика, вот здесь вот,
[39:29.860 --> 39:42.860]  по истечении фазы prepare, собрала 2F плюс один одинаковый prepare,
[39:42.860 --> 40:04.860]  то я и эта реплика, говорю, что я подготовила транзакцию с этим дайджестом в эпохе V,
[40:04.860 --> 40:16.860]  в слоте S, predicate prepared.
[40:16.860 --> 40:24.860]  По-человечески это значит вот что, если какая-то реплика собрала вот такое количество prepare,
[40:24.860 --> 40:34.860]  то она уверена, что на большинстве честных реплик в эпохе V, в слоте S, лежит одна и та же транзакция.
[40:34.860 --> 40:40.860]  Ну и дальше можно заметить, что поскольку мы собираем вот такое количество одинаковых preparов,
[40:40.860 --> 40:51.860]  то в пределах одной эпохи не бывает двух разных подготовленных транзакций.
[40:51.860 --> 41:01.860]  Почему? Потому что если две реплики подготовили разные транзакции, то каждая из них собрала вот такой кворум.
[41:01.860 --> 41:07.860]  Вот это prepare для транзакции Tx, это Tx'.
[41:07.860 --> 41:15.860]  И вот пересечение этих кворумов prepare есть, по крайней мере, здесь 2F плюс одно сообщение, prepare здесь 2F плюс одно.
[41:15.860 --> 41:27.860]  В пересечении этих кворумов, по крайней мере, F плюс одно сообщение, пересечение этих кворумов, по крайней мере, F плюс один реплик,
[41:27.860 --> 41:37.860]  а значит, по крайней мере, одна честная.
[41:37.860 --> 41:46.860]  Ну и эта реплика честная, получается, проголосовала, отправила разные prepare в одной и той же эпохе за разные транзакции,
[41:46.860 --> 41:56.860]  чего и делать запрещается. Так что не бывает двух разных подготовленных транзакций для одного и того же слота в одной и той же эпохе.
[41:56.860 --> 42:05.860]  Ну и теперь возникает естественный вопрос. Вот мы какая-то реплика, мы получили транзакцию от primary,
[42:05.860 --> 42:13.860]  положили ее в какой-то слот лога и после этого убедились, что эта транзакция лежит на большинстве частных узлов.
[42:13.860 --> 42:19.860]  Другой такой транзакции не будет. Можем ли мы считать, что эта транзакция закомичена?
[42:19.860 --> 42:30.860]  Можем ли мы зафиксировать ее в некотором порядке, зафиксировать ее с порядковым номером S и дальше применять к автомату, если переднее тоже зафиксировалось?
[42:30.860 --> 42:39.860]  Вот этот вопрос сложный, и мы сейчас его разберем. Я вернусь немного в прошлое, вставлю маленькое замечание, что вот эту картинку мы рисуем в разрезе
[42:39.860 --> 42:45.860]  некоторого фиксированного слота S. Вот вся эта картинка. Для разных слотов эта картинка будет дублироваться.
[42:45.860 --> 42:52.860]  Пока у нас есть в этой картинке две фазы. Первая prepar, для упорядочивания, вторая prepar, для того, чтобы реплика поняла,
[42:52.860 --> 43:04.860]  что на большинстве частных реплик лежит та же самая транзакция. Ну и вот реплика это поняла, она набрала вот такой набор сообщений.
[43:04.860 --> 43:09.860]  И нас интересует вопрос, можно ли считать такую транзакцию закомиченной?
[43:09.860 --> 43:20.860]  Вот если мы вспомним понятие комита в рафте, то для него мы доказывали, что из определения комита следует, что транзакция переживет смену эпохи.
[43:20.860 --> 43:34.860]  Что эта команда, которая удовлетворяет определению комита, непременно будет находиться в логах лидеров всех последующих эпох.
[43:34.860 --> 43:43.860]  Здесь нам нужно сделать то же самое. Показать, что если команда закомичена, то она переживает смену эпохи,
[43:43.860 --> 43:51.860]  а для этого нужно описать процедуру смены эпохи, смены праймари, потому что пока мы этого с вами не сделали.
[43:51.860 --> 44:00.860]  Ну вот давайте пока остановимся здесь, остановимся на реплике, которая собрала вот такое множество сообщений, такой сертификат.
[44:00.860 --> 44:07.860]  Позже мы назовем его сертификатом. Она знает, что на большинстве частных лежит эта же транзакция.
[44:07.860 --> 44:13.860]  А теперь случается смена эпохи. Немножко освободим место.
[44:24.860 --> 44:28.860]  Поговорим про смену эпохи, которая называется, напомню, view change.
[44:28.860 --> 44:44.860]  Смена эпохи означает, ну смена эпохи это смена праймари. Нужно выбрать нового праймари.
[44:44.860 --> 44:49.860]  Почему? Потому что, видимо, старый праймари ведет себя подозрительно.
[44:49.860 --> 44:56.860]  Ну вот какая-то реплика получила транзакцию от клиента, сказала, что праймари почему-то не комитит эту транзакцию.
[44:56.860 --> 45:00.860]  Мы на месте клиента не получаем кворн сертификат с ответом.
[45:00.860 --> 45:03.860]  Реплика говорит, ну хорошо, давайте проверим.
[45:03.860 --> 45:09.860]  Посылает транзакцию, преодолесует транзакцию праймари, ждет у него при ЭППР, заводит таймер, таймер протухает.
[45:09.860 --> 45:15.860]  И, видимо, мы подозреваем в чем-то праймари. Видимо, теперь праймари становится подозрительным.
[45:18.860 --> 45:20.860]  Нужно выбрать нового.
[45:20.860 --> 45:30.860]  Как это сделать? Как должна быть устроена процедура выбора этого нового праймари?
[45:30.860 --> 45:37.860]  В RAFT для того, чтобы обеспечить лайв нас, а нам в конце концов праймари нужен для того, чтобы обеспечить лайв нас, как всегда, выбор лидера.
[45:37.860 --> 45:45.860]  В RAFT для этого достаточно было выбрать любого лидера. Все узлы были честными.
[45:45.860 --> 45:53.860]  В раме достаточно было, чтобы кто-то из них стал лидером и назначал команды и реплицировал их на логи фолливеров.
[45:53.860 --> 46:00.860]  Здесь у нас требования более сложные, потому что мы хотим не просто выбрать какого-то лидера,
[46:00.860 --> 46:03.860]  ну, например, потому что этот праймари просто отказал,
[46:03.860 --> 46:13.860]  а мы хотим, чтобы эвентуал был выбран честный лидер, честный праймари, который гарантированно закомитит транзакции пользователей.
[46:13.860 --> 46:18.860]  Но как же отличить честный узел от нечестного?
[46:18.860 --> 46:22.860]  Потому что мы сказали, что мы же не можем гарантированно выбрать честного праймари,
[46:22.860 --> 46:28.860]  потому что византийский узел может вести себя нечестным, до тех пор, пока он не будет выбран праймари.
[46:28.860 --> 46:32.860]  Но можно было бы сказать следующее, что мы выбираем праймари каким-то образом,
[46:32.860 --> 46:35.860]  и если он себя скомпрометирует, например, в таком протоколе,
[46:35.860 --> 46:43.860]  то мы запишем, что он, видимо, подозрительный византийский, и после этого его будем на следующих выборах игнорировать.
[46:43.860 --> 46:50.860]  Вот так делать опасно, потому что в конце концов в этом протоколе мы не то чтобы понимаем, что праймари византийский,
[46:50.860 --> 46:54.860]  мы скорее понимаем, что праймари чего-то долго не делает.
[46:54.860 --> 47:02.860]  И может быть он действительно злоумышленник, и он действительно игнорирует намеренно команды конкретного пользователя, транзакции конкретного пользователя.
[47:02.860 --> 47:08.860]  А может быть он честный, ну просто я не знаю, он залип в какой-то паузе, он затормозил почему-то.
[47:08.860 --> 47:13.860]  Может быть он работал на какой-то виртуалке, которую засаспендили и переносили на другую машину.
[47:13.860 --> 47:19.860]  В общем, можно себе разные сценарии представить, и мы не то чтобы понимаем, что праймари византийский,
[47:19.860 --> 47:22.860]  мы скорее понимаем, что праймари подозрительный.
[47:22.860 --> 47:26.860]  Но если мы ошиблись, если все-таки он был честным, просто он залип,
[47:26.860 --> 47:33.860]  то если мы его исключим из последующих выборов, то мы, значит, рано или поздно можем так потерять все честные узлы.
[47:33.860 --> 47:36.860]  Так что мы должны каждому давать второй шанс.
[47:36.860 --> 47:45.860]  И при этом гарантировать каким-то образом, что eventually некоторые честные узел станет праймари.
[47:45.860 --> 47:48.860]  Для этого нам нужна новая идея. Ну как новая?
[47:48.860 --> 47:52.860]  Она в Объяснительном репликейшене была с самого основания с 1988 года.
[47:52.860 --> 47:58.860]  Но для нас она будет новая, и она будет нам полезна именно в контексте византийских систем.
[47:58.860 --> 48:05.860]  Мы будем использовать такую идею. Мы не будем лидера выбирать, мы будем лидера праймари назначать.
[48:13.860 --> 48:19.860]  Давайте я, чтобы опять поместиться, немного перенесу картинку.
[48:23.860 --> 48:28.860]  У нас будет идея rotating primary,
[48:33.860 --> 48:42.860]  где primary в эпохе v назначается узел v по модулю n,
[48:43.860 --> 48:46.860]  где n это общее число узлов.
[48:46.860 --> 48:56.860]  То есть мы перебираем праймари просто по кругу.
[48:56.860 --> 48:59.860]  Если один нам не нравится, мы берем следующий.
[48:59.860 --> 49:05.860]  Он нам тоже кажется подозрительным, мы продолжаем выбираем следующего и вот так вот просто двигаемся по кругу.
[49:05.860 --> 49:16.860]  Отлично. Если мы в такой схеме умеем подозревать праймари в византийском поведении,
[49:16.860 --> 49:23.860]  то мы просто меняем эпоху, передаем право быть праймари следующему узлу,
[49:23.860 --> 49:28.860]  и так рано или поздно мы дойдем до некоторого честного узла.
[49:28.860 --> 49:34.860]  Мы здесь при этом никого не исключаем, у каждого есть второй, третий и так далее шанс.
[49:34.860 --> 49:42.860]  Хорошо. Допустим, вот какой-то узел в чем-то подозревает праймари.
[49:42.860 --> 49:45.860]  Допустим, он даже честный.
[49:45.860 --> 49:51.860]  Вот достаточно ли этого, чтобы сменилась эпоха и сменился лидер?
[49:51.860 --> 50:01.860]  В RAF-те, если кто-то какой-то узел не получал heartbeat и append entries от лидера в течение реакшн тайм-аута рандомизированного,
[50:01.860 --> 50:05.860]  то он становился кандидатом и призвал всех перейти в новую эпоху.
[50:05.860 --> 50:09.860]  То есть достаточно было одного такого участника.
[50:09.860 --> 50:15.860]  Здесь у нас система византийская, поэтому снова мы не можем доверять конкретному участнику, мы не можем доверять конкретному узлу.
[50:15.860 --> 50:19.860]  Желания одного узла перевести систему в новую эпоху недостаточно,
[50:19.860 --> 50:27.860]  потому что этот желающий узел может быть византийским, и он просто хочет сбросить строна от текущего честного праймари.
[50:27.860 --> 50:37.860]  Поэтому, чтобы праймари поменять, нам нужно получить голоса нескольких узлов.
[50:37.860 --> 50:39.860]  Собрать голоса нескольких узлов.
[50:39.860 --> 50:42.860]  Итак, у нас есть снова четыре узла.
