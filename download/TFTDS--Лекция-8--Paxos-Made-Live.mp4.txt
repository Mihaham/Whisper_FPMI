[00:00.000 --> 00:10.000]  Сегодня у нас две лекции, хотя мы их не различаем, в принципе, но я различаю.
[00:10.000 --> 00:14.000]  Мы хотим в следующий раз успеть новую лекцию и новый семинар, поэтому нужно как-то уплотниться.
[00:14.000 --> 00:22.000]  Поэтому мы сегодня немного бодрее. Итак, вторая лекция на сегодня называется Paxos made live или Paxos в продакшене.
[00:22.000 --> 00:32.000]  И что я вообще имею под этим в виду? С одной стороны, лекция Paxos в продакшене про то, как взять протокол, типа multipaxos или raft, который мы изучили,
[00:32.000 --> 00:41.000]  и вот довести его до какого-то production ready RSM, то есть какие еще задачи нужно решить, помимо, собственно, репликации лога, чтобы из этого построить реплицированный автомат.
[00:41.000 --> 00:48.000]  Это, во-первых, а с другой стороны, можно посмотреть на название Paxos в продакшене по-другому.
[00:48.000 --> 00:53.000]  А как вообще Paxos или Consensus выглядит в продакшене?
[00:53.000 --> 00:58.000]  С одной стороны, это, видимо, библиотека Consensus.
[00:58.000 --> 01:05.000]  Я показывал вам сайт RAFTA, где есть ссылки на репозиторию с реализациями на разных языках.
[01:05.000 --> 01:14.000]  Если вы хотите использовать Consensus, RAFTA или multipaxos, вы берете open source реализацию, включаете свой бинарник и дальше с ней работаете.
[01:14.000 --> 01:20.000]  Но если вы посмотрите, давайте я вам сейчас это покажу.
[01:20.000 --> 01:28.000]  Если мы сейчас посмотрим на статью, которую опубликовал Google в 2000-х, в середине, про свою инфраструктуру.
[01:28.000 --> 01:37.000]  Ну, они писали статью про Bigtable, я уже немного говорил про GFS, про reproduce и еще про Chubby, сервис блокировок.
[01:37.000 --> 01:46.000]  Так вот, Google строил отказоустойчивую инфраструктуру, но сначала он строил GFS, вы про нее знаете, что это не самая отказоустойчивая вещь на свете.
[01:46.000 --> 01:49.000]  Но потом, конечно, они так больше не делали.
[01:49.000 --> 01:56.000]  И Bigtable, их большое кивалию хранилища, которое используется и сейчас, оно, конечно же, отказоустойчивое.
[01:56.000 --> 01:59.000]  Но для отказоустойчивости вам нужен Consensus.
[01:59.000 --> 02:08.000]  И Google говорит, что мы вместо того, чтобы писать библиотеку Consensus, смотрите, паксисом,
[02:08.000 --> 02:17.000]  подключать ее к каждой новой системе, которая хочет использовать Consensus внутри себя,
[02:17.000 --> 02:21.000]  мы вместо этого напишем сервис блокировок.
[02:21.000 --> 02:23.000]  Вот lock service.
[02:23.000 --> 02:34.000]  И будем эту систему, сервис блокировок использовать, мы скажем, что это и есть Consensus as a service.
[02:34.000 --> 02:40.000]  То есть вы не включаете библиотеку multipax в свой код, вы используете внешнюю систему,
[02:40.000 --> 02:46.000]  которая предоставляет вам почему-то описать блокировками с lock-unlock, с acquire-release.
[02:46.000 --> 02:53.000]  И с помощью этого решаете те задачи, которые вы бы решали, используя multipax в своем коде.
[02:53.000 --> 02:56.000]  Почему это разумно? У них про это есть параграф.
[02:56.000 --> 02:58.000]  Почему они так хотят делать?
[02:58.000 --> 03:00.000]  Тут причины разные.
[03:00.000 --> 03:05.000]  Они в том числе говорят где-то вот здесь, что блокировки более понятны людям, чем Consensus.
[03:05.000 --> 03:08.000]  С другой стороны, вы знаете, что с блокировками можно портачить.
[03:08.000 --> 03:12.000]  А распределенные блокировки, это вообще вещь довольно сомнительная, о которой мы сейчас поговорим.
[03:12.000 --> 03:21.000]  Тем не менее, они такую систему построили, и вот тот же самый Bigtable, он эту систему использует,
[03:21.000 --> 03:23.000]  использовал уж по крайней мере.
[03:23.000 --> 03:32.000]  Использует, да, и сейчас, наверное, тоже использует для хранения данных и для еще чего-то, о чем мы поговорим чуть позже.
[03:32.000 --> 03:39.000]  Ну, в общем, я начну не с того, как, не с той половины паксов в продакшене, где нужно что-то оптимизировать
[03:39.000 --> 03:46.000]  или дополнительные какие-то фичи прикручивать к RSM, а с другого взгляда на Consensus в продакшене,
[03:46.000 --> 03:51.000]  на Consensus как сервис и вот на сервис блокировок.
[03:51.000 --> 03:56.000]  Вот давайте вообще представим, что бы это могло быть.
[03:56.000 --> 04:06.000]  Ну, сервис блокировок – это нечто отказоустойчивое, что реализует APIS вызовами lock и unlock.
[04:06.000 --> 04:12.000]  И, конечно же, этот сервис блокировок должен быть отказоустойчивым, поэтому он сам является RSM,
[04:12.000 --> 04:17.000]  и вы каким-то образом Consensus внутри него используете как сервис.
[04:17.000 --> 04:34.000]  Итак, lock-сервис – это RSM, и вы как клиент можете пойти в него и взять блокировку.
[04:35.000 --> 04:40.000]  Вам могу сказать, хорошо, вы блокировку захватили.
[04:40.000 --> 04:46.000]  Ну, конечно, не то чтобы это один глобальный Mutex какой-то, это было бы странно.
[04:46.000 --> 04:49.000]  У вас, наверное, в программе много Mutex может быть.
[04:49.000 --> 04:57.000]  Плюс замысел сервиса блокировок в том, что разные системы могут использовать один и тот же lock-сервис.
[04:57.000 --> 05:01.000]  Совершенно разные, не пересекающиеся друг с другом, они могут использовать его как
[05:01.000 --> 05:05.000]  инфраструктурный сервис, с помощью которого они внутри себя координацию выполняют.
[05:05.000 --> 05:07.000]  Поэтому нужно как-то адресовать блокировки.
[05:07.000 --> 05:12.000]  Но вот у нас в коде просто имена переменных, а в случае с Chabi, в случае с lock-сервисом,
[05:12.000 --> 05:15.000]  у нас есть некоторая иерархия имен.
[05:15.000 --> 05:19.000]  Ну, то есть такое дерево, и вы можете лочить, скажем, его узлы.
[05:19.000 --> 05:23.000]  Так что мы здесь говорим какой-то путь.
[05:23.000 --> 05:28.000]  Ну, почему иерархия? Потому что, скажем, у каждой подсистемы может быть своя ветка в этом дереве.
[05:28.000 --> 05:32.000]  А в одной ветке одной подсистемы могут быть еще какие-то там вспомогательные поддеревья.
[05:32.000 --> 05:38.000]  Ну, это не очень важно. Мы поговорим на другом курсе про Zookieper, и там все будет очень наглядно.
[05:38.000 --> 05:46.000]  А пока вот вы просто берете блокировки, адресуете их вот некоторым путем в дерево.
[05:46.000 --> 05:52.000]  И вам говорят, что вот вместо Paxos вам нужен такой вот сервис.
[05:52.000 --> 05:57.000]  Разумно ли это звучит? Но в таком виде это абсолютно дико звучит, конечно.
[05:57.000 --> 06:02.000]  Вот я хочу понять, ну, в смысле хочу, чтобы вы поняли, чего же пока в этой конструкции,
[06:02.000 --> 06:07.000]  чего не хватает, почему это выглядит безумно.
[06:07.000 --> 06:13.000]  Вообще идея распределенных блокировок, ну, идея вот блокировок локальных там на одной машине,
[06:13.000 --> 06:17.000]  она еще куда не шла. Мы вроде бы умеем с этим работать.
[06:17.000 --> 06:23.000]  Мы знаем, что блокировки нужно в каком-то порядке брать.
[06:23.000 --> 06:27.000]  Ну, а с распределенными блокировками что не так? Вот нельзя просто так взять Mute и сказать, что
[06:27.000 --> 06:31.000]  а теперь он распределенный Mutex.
[06:31.000 --> 06:35.000]  Ну, вот смотрите, вы взяли блокировку. Что вы должны с ней сделать?
[06:35.000 --> 06:42.000]  Ну, вот может быть и нет. Может быть, ты этого совсем не хочешь.
[06:42.000 --> 06:46.000]  Может быть, ты ее взял, чтобы держать бесконечно долго.
[06:46.000 --> 06:52.000]  Но это нормальное намерение. Собственно, сервис блокировок, он не для того, чтобы ты
[06:52.000 --> 06:56.000]  брал блокировку на секунду, он для того, чтобы ты брал блокировку надолго.
[06:56.000 --> 07:00.000]  Это основной сценарий, и вот вы пока можете подумать, о чем я говорю.
[07:00.000 --> 07:05.000]  Но если, да, и сам сервис блокировок отказоустойчивый, то есть если одна машина ломается в нем,
[07:05.000 --> 07:10.000]  но все-таки собирается квором, то, конечно же, ваша блокировка логически остается жить.
[07:10.000 --> 07:14.000]  Ну, потому что это сам по себе RSM, отказоустойчивая сущность.
[07:14.000 --> 07:16.000]  Вот. Но что делать, если вы сломаетесь?
[07:18.000 --> 07:21.000]  Вот. Но вы с собой эту блокировку унесете.
[07:21.000 --> 07:25.000]  Вот. Это очень странно. То есть ее никто больше взять не сможет.
[07:25.000 --> 07:30.000]  Поэтому что вы хотите сделать, ну, помимо того, чтобы отдать блокировку пользователю?
[07:33.000 --> 07:36.000]  Ну, вы хотите быть уверенными, что он выживет.
[07:36.000 --> 07:40.000]  Но вы этого не можете гарантировать, он тоже не может. Он, конечно, может умереть.
[07:40.000 --> 07:46.000]  Поэтому вы даете ему не блокировку. Вы даете ему блокировку с тайм-аутом.
[07:50.000 --> 07:57.000]  А это называется лиза. То есть он не получает во владение эту блокировку, он получает ее в аренду.
[07:57.000 --> 08:02.000]  Вот. И эту аренду можно назвать в одностороннем порядке, если вдруг этот клиент умрет.
[08:02.000 --> 08:04.000]  Вот. А как понять, что он умер?
[08:04.000 --> 08:10.000]  Ну, видимо, клиент с системой как-то взаимодействует, помимо того, что он берет блокировку.
[08:10.000 --> 08:15.000]  Вот. Он устанавливает сессию.
[08:18.000 --> 08:20.000]  Вот. У каждого клиента есть своя сессия.
[08:20.000 --> 08:29.000]  Ну. И он отправляет сессию, такое логическое соединение, поддерживаемое клиентской библиотекой.
[08:29.000 --> 08:34.000]  И он состоит в том, что вы просто посылаете хардбиты какой-то из реплик,
[08:34.000 --> 08:40.000]  и система понимает, что вы все еще живы, и вы продляете эту блокировку, вы все еще и владеете.
[08:40.000 --> 08:46.000]  Если вдруг протухает тайм-аут какой-то здесь, потому что вы вдруг отказали,
[08:46.000 --> 08:49.000]  то, видимо, блокировка у вас отнимается, она становится свободной,
[08:49.000 --> 08:55.000]  и другой кандидат, который на нее претендовал, его теперь, ему ее можно выдать.
[08:56.000 --> 08:59.000]  Ну, то есть у нас здесь есть сессия, в ней есть какие-то хардбиты,
[08:59.000 --> 09:05.000]  то есть механизм обнаружения сбоев, вот. И блокировка отзывается в одностороннем порядке.
[09:07.000 --> 09:12.000]  Да, разумеется, если у вас вот этот узел умрет, то это не обязательно значит,
[09:12.000 --> 09:15.000]  что сессия порвалась, и что блокировка будет отобрана.
[09:15.000 --> 09:17.000]  Ну, потому что это проблема системы, а не клиента.
[09:17.000 --> 09:22.000]  Вот. Так что сама система, она может реплицировать не только состояние дерева,
[09:22.000 --> 09:26.000]  то есть кто какие блокировки взял, а и состояние сессии.
[09:27.000 --> 09:30.000]  Так что здесь смерть узла может быть даже незаметной.
[09:30.000 --> 09:33.000]  Но если вот клиент умер, то точно у него блокировку нужно изъять.
[09:38.000 --> 09:40.000]  Хорошо ли это?
[09:41.000 --> 09:45.000]  Это необходимость некоторая, то есть мы не можем отказаться, разумеется.
[09:45.000 --> 09:47.000]  Но к чему это может привести?
[09:52.000 --> 10:00.000]  Ну, видимо, у тебя здесь может быть тайм-аут не прямо на секунду,
[10:00.000 --> 10:04.000]  потому что если вдруг там секундная пауза, чтобы у тебя не терялась большая работа.
[10:04.000 --> 10:07.000]  Действительно. Но дело-то не в этом.
[10:07.000 --> 10:10.000]  Зачем ты берешь блокировку вообще?
[10:12.000 --> 10:16.000]  Вот, здесь некоторый код, который должен выполняться только тобой.
[10:16.000 --> 10:22.000]  Вот. И видимо, у тебя есть конкурент не потому, что он твой соперник,
[10:22.000 --> 10:24.000]  а потому, что он хочет тебя подстраховать.
[10:26.000 --> 10:28.000]  Ну, вряд ли ты на одной машине выполняешь какую-то работу.
[10:28.000 --> 10:30.000]  Если она умрет, то вся работа не будет выполнена.
[10:30.000 --> 10:34.000]  Видимо, у тебя есть какая-то другая машина, на которую ты переключишься, если это упадет.
[10:35.000 --> 10:40.000]  Вот. И если у тебя блокировку отберут, то она ее подхватит.
[10:40.000 --> 10:47.000]  Вот. Тот же самый зеленый паз.
[10:53.000 --> 10:59.000]  Ну, а мы, кажется, уже знаем, что довольно трудно отличить медленный узел от сбоенного.
[11:01.000 --> 11:05.000]  И что может получиться? Что вы почему-то, ну, не знаю, вы залипли...
[11:05.000 --> 11:08.000]  У вас, вы пишете вообще код на джави, у вас клиентская библиотека написана на джави,
[11:08.000 --> 11:10.000]  и она хардбиты шлет. Вот.
[11:10.000 --> 11:12.000]  Тут случилась пауза, сборка мусора.
[11:12.000 --> 11:15.000]  Вот. И вы не отправляли эти хардбиты.
[11:15.000 --> 11:18.000]  В итоге сессия у вас протухла, но вы при этом живы.
[11:18.000 --> 11:21.000]  Но если вы умерли, то как раз все хорошо, это хороший сценарий.
[11:21.000 --> 11:23.000]  Вас подстрахуют. Вот.
[11:23.000 --> 11:27.000]  Но если вы все еще живы, но вы очень медленный, и у вас протухла сессия,
[11:27.000 --> 11:32.000]  то блокировка логически освободится с системой и будет передана другому узлу.
[11:33.000 --> 11:35.000]  Вот. А зачем вы берете блокировку?
[11:35.000 --> 11:40.000]  Видимо, за тем, чтобы работать с каким-то внешним состоянием.
[11:40.000 --> 11:42.000]  Ну, например.
[11:42.000 --> 11:48.000]  И получается, что красный узел, красный клиент блокировку получил
[11:48.000 --> 11:52.000]  и собирается что-то написать в это состояние, как-то с ним работать.
[11:52.000 --> 11:55.000]  А зеленый все еще думает, что он ее владеет.
[11:55.000 --> 11:57.000]  И тоже собирается писать.
[12:02.000 --> 12:04.000]  Что же им делать?
[12:04.000 --> 12:07.000]  Точнее, что же делать вот здесь вот?
[12:07.000 --> 12:10.000]  Потому что, если мы делаем распределенные блокировки,
[12:10.000 --> 12:14.000]  то они как бы бай-дизайн не могут гарантировать заименные исключения.
[12:14.000 --> 12:16.000]  Это невозможно.
[12:19.000 --> 12:22.000]  Вот. Нужно как-то помнить, кто из них был первым, а кто вторым,
[12:22.000 --> 12:26.000]  чтобы понять, что на самом деле этот запрос уже не актуален.
[12:26.000 --> 12:28.000]  Нужно сказать, что когда мы получаем блокировку,
[12:28.000 --> 12:31.000]  мы не просто получаем подтверждение, что мы ее владеем.
[12:31.000 --> 12:34.000]  А мы еще получаем эпоху вместе с ней.
[12:39.000 --> 12:42.000]  И вот здесь эпоха 1 будет, а здесь эпоха 2.
[12:42.000 --> 12:47.000]  И если вы уже в этом месте перешли в новую эпоху,
[12:47.000 --> 12:52.000]  то вы отвергаете те изменения, которые вам шлет старый клиент.
[12:52.000 --> 12:55.000]  Но он рано или поздно поймет, что он уже не актуален.
[12:55.000 --> 12:57.000]  Но пока он это сделает, время какое-то пройдет,
[12:57.000 --> 12:59.000]  нужно, чтобы он за это время ничего не сломал.
[12:59.000 --> 13:03.000]  Но это по сути та же самая ситуация с конкуренцией лидеров,
[13:03.000 --> 13:06.000]  которая у нас была в Multipax, которая может быть в RAF.
[13:06.000 --> 13:09.000]  В RAF тоже не бывает так, что лидер прямо один во времени.
[13:09.000 --> 13:11.000]  Их может быть двое, просто не в разных термах.
[13:11.000 --> 13:13.000]  Есть старший и есть младший.
[13:13.000 --> 13:15.000]  И вот нужно слушать того, кто в старшем терме находится,
[13:15.000 --> 13:17.000]  и гонировать того, кто младший.
[13:17.000 --> 13:21.000]  И если мы посмотрим на статью GoogleChab,
[13:21.000 --> 13:27.000]  то на API, которая эта система нам предоставляет,
[13:30.000 --> 13:31.000]  видно что-то.
[13:31.000 --> 13:33.000]  А, перебор же, да?
[13:35.000 --> 13:41.000]  То смотрите, это с одной стороны Acquire,
[13:41.000 --> 13:45.000]  а с другой стороны это Sequencer.
[13:45.000 --> 13:48.000]  То есть вы, как владелец блокировки, вы понимаете,
[13:48.000 --> 13:50.000]  как его порядочно относительно других владелец.
[13:50.000 --> 13:52.000]  Это важно, потому что они могут быть живы,
[13:52.000 --> 13:56.000]  и вы можете в каком-то смысле владеть блокировкой параллельно.
[13:56.000 --> 14:00.000]  То есть с точки зрения системы, которая была нарисована,
[14:00.000 --> 14:02.000]  лог только у одного клиента.
[14:02.000 --> 14:05.000]  А с точки зрения клиентов, они могут думать немного по-другому,
[14:05.000 --> 14:07.000]  потому что знание это распределенное.
[14:07.000 --> 14:09.000]  Вот система знает, что вы не владеете блокировкой,
[14:09.000 --> 14:11.000]  а вы думаете, что еще владеете.
[14:11.000 --> 14:15.000]  Так что чтобы сами клиенты не поломали жизнь друг другу,
[14:15.000 --> 14:18.000]  они должны быть упорядочены самой системой.
[14:18.000 --> 14:20.000]  Ну а теперь вопрос.
[14:20.000 --> 14:22.000]  Зачем все это?
[14:22.000 --> 14:24.000]  Ну то есть зачем нам распределенные блокировки
[14:24.000 --> 14:29.000]  и почему нам дают вместо библиотеки консенсус, а сервис блокировок?
[14:29.000 --> 14:31.000]  Как мы собираемся его использовать?
[14:31.000 --> 14:36.000]  Мы разработчики какой-то другой системы, скажем Bigtable.
[14:41.000 --> 14:44.000]  Какой смысл эти блокировки? Зачем они?
[14:44.000 --> 14:46.000]  Кто их берет?
[14:46.000 --> 14:49.000]  Просто пока это довольно абстрактно все, да?
[14:50.000 --> 14:53.000]  Вот я беру блокировку, это что означает?
[14:54.000 --> 14:56.000]  Кто я?
[14:56.000 --> 14:59.000]  Что я собираюсь с ней делать?
[15:04.000 --> 15:08.000]  Смотри, Bigtable – это киволюхранилище большое.
[15:08.000 --> 15:13.000]  И я про него уже рассказывал в довольно смешном контексте.
[15:13.000 --> 15:15.000]  Сейчас напомню.
[15:15.000 --> 15:19.000]  Мы говорили про GFS, про распределенные файловые системы.
[15:19.000 --> 15:23.000]  А потом я сказал, что мы говорили сначала про LSM, про локальное хранилище.
[15:23.000 --> 15:26.000]  Про roxdb в частности, про leveldb-roxdb.
[15:26.000 --> 15:28.000]  И что оно реализует LSM?
[15:28.000 --> 15:31.000]  Вот у вас есть log, у вас есть memtable, у вас есть ass stable.
[15:31.000 --> 15:36.000]  Потом поговорили с вами про дизайн распределенной файловой системы.
[15:36.000 --> 15:39.000]  А потом я сказал, что раз уж мы умеем делать
[15:39.000 --> 15:42.000]  LSM киволюхранилище поверх локальной файловой системы
[15:42.000 --> 15:45.000]  и умеем делать распределенные файловые системы, то какая разница?
[15:45.000 --> 15:48.000]  Давайте построим LSM поверх распределенной файловой системы
[15:48.000 --> 15:52.000]  и получим key-value хранилища от козоустойчивой уже,
[15:52.000 --> 15:57.000]  потому что сама файловая система DFS распределенная от козоустойчивой.
[15:57.000 --> 16:02.000]  Но key-value оно большое, то есть пространство ключей большое,
[16:02.000 --> 16:07.000]  поэтому мы разделим его на диапазоны, на рейнджи,
[16:07.000 --> 16:14.000]  и каждый рейндж будет отдельным вот таким вот LSM-ом поверх распределенной файловой системы.
[16:14.000 --> 16:18.000]  Bigtable так реализован, там есть понятие Tablet, Tablet это shard,
[16:18.000 --> 16:21.000]  это кусочек, отвечающий за диапазон ключей,
[16:21.000 --> 16:26.000]  и каждый кусочек хранит все свои данные в GFS.
[16:26.000 --> 16:32.000]  А GFS, ну, колоссус, там сложно.
[16:32.000 --> 16:35.000]  В общем, в базовом дизайне у вас есть GFS,
[16:35.000 --> 16:41.000]  Bigtable хранит там данные Tablet в виде LSM.
[16:41.000 --> 16:47.000]  Храняться-то ненадежно, и все помещается, потому что DFS масштабируется.
[16:47.000 --> 16:53.000]  Но каждому Tablet нужна точка обслуживания, то есть в чьей памяти будет жить MemTable?
[16:53.000 --> 16:56.000]  Кто будет добавлять в лог?
[16:56.000 --> 16:59.000]  Должен быть какой-то узел, который это делает для каждого Tablet.
[16:59.000 --> 17:03.000]  То есть данные хранятся на многих узлах в файловой системе,
[17:03.000 --> 17:05.000]  но кто-то все равно должен обслуживать запросы,
[17:05.000 --> 17:08.000]  кто-то должен хранить все MemTable, кто-то должен его дампить.
[17:08.000 --> 17:10.000]  Этот узел должен быть один.
[17:10.000 --> 17:21.000]  Так вот, Bigtable, сейчас я покажу в статье.
[17:21.000 --> 17:29.000]  Bigtable использует Chubby, в частности, для выбора лидера.
[17:29.000 --> 17:33.000]  И сам смысл лог-сервиса – это задача выбора лидера.
[17:33.000 --> 17:37.000]  Вот тот, кто взял блокировку, он становится лидером среди других кандидатов
[17:37.000 --> 17:39.000]  и как-то координирует действия других.
[17:39.000 --> 17:43.000]  Но поскольку невозможно гарантировать, что лидеры только один во времени,
[17:43.000 --> 17:49.000]  ну, пока невозможно, они могут конкурировать, нужно разделить их по эпохам.
[17:49.000 --> 17:51.000]  Кто из них первый, кто второй, кто третий.
[17:51.000 --> 17:53.000]  Игнорировать, блокировать старых лидеров.
[17:53.000 --> 17:58.000]  Но вот ровно для этого у наших блокировок есть эти самые эпохи.
[17:58.000 --> 18:01.000]  Или там Sequencer, неважно, как мы это назовем.
[18:01.000 --> 18:06.000]  То есть вы выносите задачу выбора лидера и упорядочивания лидеров в такой вот сервис,
[18:06.000 --> 18:09.000]  и он вам заменяет собственный multiprocess.
[18:09.000 --> 18:13.000]  Ну а дальше это полезно тем, что вы можете, ну, у вас много распределенных систем
[18:13.000 --> 18:16.000]  или много инсталляций распределенной системы,
[18:16.000 --> 18:20.000]  и можно в каждой консенсус заводить, а можно установить, как бы,
[18:20.000 --> 18:25.000]  развернуть один лог-сервис, и чтобы все им пользовались.
[18:25.000 --> 18:27.000]  У вас в параллельном курсе будет ZooKeeper.
[18:27.000 --> 18:33.000]  Это система, которая была написана как раз по мотивам Google Chubby.
[18:33.000 --> 18:37.000]  Но что мне интересно, тут плохо опять видно,
[18:37.000 --> 18:40.000]  что ZooKeeper, он решает те же самые задачи,
[18:40.000 --> 18:46.000]  но в отличие от Chubby, вместо блокировок он вам предлагает атомики.
[18:46.000 --> 18:48.000]  Потому что они говорят, что давайте сделаем лучше атомики,
[18:48.000 --> 18:51.000]  потому что из атомиков можно сделать блокировки,
[18:51.000 --> 18:59.000]  но как бы можно, как сказать-то, но можно lock-free или wait-free строить из них.
[18:59.000 --> 19:01.000]  То есть это больше соответствует духу распределенных систем,
[19:01.000 --> 19:06.000]  потому что wait-free это есть аналог сбоев, бесконечная пауза, но то есть сбой.
[19:06.000 --> 19:11.000]  Поэтому в ZooKeeper нет lock-unlock, но зато вы можете построить обычный тикет spin-lock,
[19:11.000 --> 19:15.000]  и мы это в лекции сделаем поверх атомиков, которые есть в ZooKeeper.
[19:15.000 --> 19:20.000]  Короче, это все вот как бы связано, и все вот это это консенсус как сервис.
[19:20.000 --> 19:24.000]  Это было такое длинное вступление в эту лекцию.
[19:24.000 --> 19:28.000]  Сейчас последняя часть этого вступления.
[19:28.000 --> 19:30.000]  Почему лекция так называется?
[19:30.000 --> 19:33.000]  Потому что про Google Chubby была написана статья,
[19:33.000 --> 19:36.000]  которая называется Paxos Made Life.
[19:36.000 --> 19:39.000]  Почти мачится.
[19:39.000 --> 19:43.000]  О чем она была? О том, что инженеры написали этот Chubby
[19:43.000 --> 19:45.000]  и делятся своим опытом.
[19:45.000 --> 19:54.000]  Они пишут, что если мы читаем код Paxos, то он там вмещается в одну страничку, там 20 строчек.
[19:54.000 --> 19:58.000]  Но почему-то продакшн реализация на C++ занимает тысячи строк.
[19:58.000 --> 20:00.000]  Как же так получилось?
[20:00.000 --> 20:05.000]  Но вот они пишут, что дело не в том, что C++ многословный какой-то.
[20:05.000 --> 20:09.000]  Дело не в этом. Дело в том, что просто есть зазор содержательный
[20:09.000 --> 20:14.000]  между базовым алгоритмами репликации лога и нуждами промышленной системы.
[20:14.000 --> 20:18.000]  Но она должна больше уметь, и она должна быть просто эффективнее,
[20:18.000 --> 20:22.000]  лучше масштабироваться и быстрее работать.
[20:22.000 --> 20:26.000]  И как раз сегодня на этой лекции мы поговорим о том,
[20:26.000 --> 20:30.000]  какие задачи нужно еще добавить к Крафту или Мультипаксусу,
[20:30.000 --> 20:34.000]  чтобы он сдеплоился в какой-то промышленной системе,
[20:34.000 --> 20:38.000]  и как в нем можно что-то ускорить или промасштабировать.
[20:44.000 --> 20:48.000]  Ну вот, давайте чего-то начнем.
[20:52.000 --> 20:56.000]  Мы пишем RSM. Какие задачи нам необходимо решить,
[20:56.000 --> 21:00.000]  что нам нужно сделать, чтобы вообще его как бы развернуть?
[21:00.000 --> 21:04.000]  Во-первых, нам нужно выбрать число реплик.
[21:04.000 --> 21:09.000]  Мы доказывали для произвольного алгоритма консенс сверхнюю оценку.
[21:09.000 --> 21:13.000]  Выбираем число реплик.
[21:14.000 --> 21:18.000]  Мы доказывали, что любой алгоритм консенсуса,
[21:18.000 --> 21:22.000]  который гарантирует safety свойства agreement в любых сценариях
[21:22.000 --> 21:26.000]  с любым количеством отказов, должен блокироваться, когда отказов слишком много.
[21:26.000 --> 21:30.000]  То есть у него есть граница на отказоустойчивость.
[21:30.000 --> 21:36.000]  Эту оценку сверху можно трансформировать в какую-то инструкцию для нас,
[21:36.000 --> 21:40.000]  для разработчиков, для инженеров. Если мы хотим пережить f отказов,
[21:40.000 --> 21:46.000]  то мы должны взять число реплик как 2f плюс 1.
[21:46.000 --> 21:54.000]  Этого достаточно, а больше не нужно, потому что кворумы растут и становятся только медленные.
[21:54.000 --> 21:58.000]  Маленькое замечание конкретно про паксос и мультипаксос.
[21:58.000 --> 22:04.000]  Алгоритм паксос мы излагали в двух ролях, пропозор и аксепторы.
[22:04.000 --> 22:08.000]  В мультипаксосе у нас есть пропозор, аксепторы, еще клиенты.
[22:08.000 --> 22:16.000]  Так вот, если переложить оценку на роли, а не на число реплик,
[22:16.000 --> 22:20.000]  если считать, что роли могут быть на разных узлах физически находиться,
[22:20.000 --> 22:24.000]  то получится чуть более общим.
[22:24.000 --> 22:34.000]  У нас есть клиенты, и они отправляют свои команды пропозорам.
[22:34.000 --> 22:44.000]  Пропозоры общаются с аксепторами.
[22:44.000 --> 22:50.000]  Вот их, допустим, тоже 3.
[22:50.000 --> 22:58.000]  Мы должны сначала пройти через первую фазу, потом через вторую, потом через третью.
[22:58.000 --> 23:04.000]  Один раунд трип, второй раунд трип. Первая фаза, вторая фаза.
[23:04.000 --> 23:14.000]  Вот, команда зафиксирована в логе, и после этого мы можем отправить ее куда? На реплику.
[23:14.000 --> 23:18.000]  Вот это все разные роли алгоритме.
[23:18.000 --> 23:24.000]  Мы, когда говорили на прошлой неделе про мультипаксос, говорили, что это все один узел.
[23:24.000 --> 23:32.000]  Но если мы их разнесем, то получится, чтобы пережить f отказов, нам нужно сколько пропозоров?
[23:32.000 --> 23:40.000]  f плюс 1. Сколько аксепторов? 2 f плюс 1. Сколько реплика? f плюс 1.
[23:40.000 --> 23:48.000]  То есть мы чуть аккуратнее сформулировали число ролей, которые нам нужны.
[23:48.000 --> 23:54.000]  И если вдруг аксепторы отделены от пропозоров, а это может быть разумно по некоторым причинам,
[23:54.000 --> 23:58.000]  как мы сегодня увидим, то можно сказать чуть точнее, что пропозоров нам много не нужно,
[23:58.000 --> 24:04.000]  реплик у нас тоже много не нужно, нам нужно аксепторов много, чтобы коврово собирать.
[24:04.000 --> 24:14.000]  Но смотрите, когда я говорю, что вот 2 f плюс 1, f отказов, значит 2 f плюс 1 реплик.
[24:14.000 --> 24:20.000]  Я вот тут, ну и вы, наверное, тоже вместе со мной думаете неявно, что отказываете независимые.
[24:20.000 --> 24:26.000]  Вот если мы хотим пережить 3 отказа, то, видимо, мы считаем, что возьмем сколько 7 реплик.
[24:26.000 --> 24:33.000]  И почему мы берем 3 отказа? Потому что мы считаем, что ни разу не случатся. Невелика вероятность этого.
[24:33.000 --> 24:39.000]  То есть диск может выйти из строя, но вот 2 разом или 3 разом это уже гораздо ниже вероятности.
[24:39.000 --> 24:43.000]  Но это так, но не всегда. Потому что вы можете поступить неаккуратно.
[24:43.000 --> 24:48.000]  Вы можете взять и свои реплики поместить, скажем, в одну стойку в дата-центре.
[24:48.000 --> 24:51.000]  Помните, я показывал вам картинки, там шкафы такие, стоят в них провода.
[24:51.000 --> 24:57.000]  Ну вот, у вас есть рэк.
[24:57.000 --> 25:07.000]  Если там окажутся 2 реплики, то мы их можем потерять разом, потому что в этой стойке откажет коммутатор.
[25:07.000 --> 25:12.000]  И в итоге мы потеряем все машины, которые в ней находятся, в том числе две реплики.
[25:12.000 --> 25:17.000]  Поэтому любая разумная промышленная система не подбищает реплики в одну стойку, она знает про них.
[25:18.000 --> 25:25.000]  В общем случае говорят про понятие, которое называется доменалказов, fail-domain.
[25:33.000 --> 25:43.000]  Fail-domain это компонент инфраструктуры, который может выйти из строя разом, весь в результате какого-то одного сбоя.
[25:43.000 --> 25:49.000]  Ну скажем, если у вас поломался диск, то вы потеряли машину.
[25:49.000 --> 25:57.000]  Если у вас поломался коммутатор в стойке, то вы потеряли сразу много машин.
[25:57.000 --> 26:08.000]  Ну стойки организованы в здании DC. В общем случае можно сказать, что это там зона доступности.
[26:08.000 --> 26:18.000]  Почему вы можете потерять целое здание? Потому что, не знаю, пожар, наводнения, проблемы с питанием, не знаю, подстанции.
[26:18.000 --> 26:24.000]  Ну там есть резервные питания, конечно, но всякое бывает. Выкопали кабели к этому DC.
[26:24.000 --> 26:30.000]  Но можно подняться еще выше и говорить про регион целый.
[26:30.000 --> 26:39.000]  Регион – это какая-то местность большая, в которой расставлены разные дата-центры на большом удалении друг от друга.
[26:39.000 --> 26:47.000]  В чем смысл? В том, что вы можете потерять весь уровень из-за какой-то проблемы.
[26:47.000 --> 26:55.000]  Начался ураган, смело DC просто все. Ну то есть это возможно.
[26:55.000 --> 27:11.000]  Но вероятность коррелированного сбоя, она с ростом, с каждым уровнем в этой иерархии, она становится все ниже.
[27:11.000 --> 27:15.000]  Вот здесь у вас есть один диск, и вы потеряете его и лишитесь машины.
[27:15.000 --> 27:19.000]  Поэтому здесь у вас есть много машин с независимыми дисками.
[27:19.000 --> 27:23.000]  Но зато с одним коммутатором или с двумя.
[27:23.000 --> 27:27.000]  Но в дата-центре у вас уже много стоек, там немного коммутаторов.
[27:27.000 --> 27:33.000]  Но правда у них у всех общая подстанция или общая система охлаждения.
[27:33.000 --> 27:37.000]  Ну тогда вы переходите на уровень еще выше, там у вас это тоже задублировано.
[27:37.000 --> 27:42.000]  У вас теперь много зданий, у каждого своя система питания, своя система охлаждения.
[27:42.000 --> 27:51.000]  То есть вы, поднимаясь по уровням этой иерархии, резервируете то, что могло сломаться на предыдущем уровне.
[27:51.000 --> 27:53.000]  И какая польза от этого знания?
[27:53.000 --> 27:58.000]  Что когда вы говорите, что я выбираю 2F плюс одну реплику, вы должны сказать, на каком уровне вы находитесь.
[27:58.000 --> 28:03.000]  То есть как вы их расставляете? Вы их расставляете по разным стойкам, или вы их расставляете по разным дата-центрам,
[28:03.000 --> 28:06.000]  или вы их расставляете по разным континентам.
[28:06.000 --> 28:15.000]  Понятно, что чем выше вы их размещаете, то есть выбираете разные континенты, например, тем вы снижаете вероятность кавелированного отказа.
[28:15.000 --> 28:19.000]  Но с другой стороны, вы проигрываете, потому что у вас растут задержки.
[28:19.000 --> 28:23.000]  Потому что, поднимаясь выше, вы просто ударяете друг от друга машины.
[28:23.000 --> 28:27.000]  И здесь это, наверное, еще не очень страшно.
[28:27.000 --> 28:30.000]  То, что вы по разным стойкам расставили, это бесплатно.
[28:30.000 --> 28:36.000]  Но если вы размещаете их в разных дата-центрах, или в разных регионах, то вы получаете уже большие задержки просто по проводам.
[28:36.000 --> 28:42.000]  Потому что вы в состоянии физически большие. Свету долго лететь.
[28:42.000 --> 28:50.000]  И вы должны выбирать, на каком же уровне вы работаете.
[28:50.000 --> 28:54.000]  Хорошо, с этим разобрались.
[28:54.000 --> 28:57.000]  Следующий вопрос.
[28:57.000 --> 29:01.000]  Даже не вопрос, а наблюдение, скорее, которое мы раньше не делали.
[29:01.000 --> 29:05.000]  Почему вас беспокоит вот эта географическая удаленность рефликта друг от друга?
[29:05.000 --> 29:08.000]  Ну, потому что вы же кворумы собираете.
[29:08.000 --> 29:16.000]  Вы пересекаете там, не знаю, Северную Америку, Западу на Восток и Востока на Запад, или Афлантику пересекаете.
[29:16.000 --> 29:22.000]  Вот здесь вот, когда кворумы собираете на фазах паксуса.
[29:22.000 --> 29:27.000]  И вы так делаете для разных аксепторов.
[29:27.000 --> 29:33.000]  Я весь семестр очень аккуратно говорил вместо слова большинства слово «кворум».
[29:33.000 --> 29:38.000]  Вот кворумы, это еще одна деталь, которую можно...
[29:38.000 --> 29:41.000]  Стойте, рано про кворумы.
[29:41.000 --> 29:43.000]  Стойте, стойте, стойте.
[29:43.000 --> 29:51.000]  Вот выбрали реплики, число реплик, расположили их, выбрали уровень в иерархии доминов отказов.
[29:51.000 --> 29:54.000]  И вот реплики живут. Система ваша живет.
[29:54.000 --> 29:56.000]  А потом что-то ломается.
[29:56.000 --> 30:01.000]  Вот там совсем машина взрывалась. Ее раздавил бульдозер.
[30:01.000 --> 30:07.000]  Или вы хотите повысить отказоустойчивость, добавить новые реплики.
[30:07.000 --> 30:09.000]  Вот мы тогда этого момента не делали.
[30:09.000 --> 30:13.000]  Мы всегда на каждой лекции говорили, пусть у нас есть там три реплики в мультипакс,
[30:13.000 --> 30:16.000]  три реплики в рафте, там пять реплик, неважно.
[30:16.000 --> 30:20.000]  Мы не меняем их состав, потому что плывут кворумы.
[30:20.000 --> 30:27.000]  Вот смотрите, что вообще может произойти, когда вы захотите добавить или изменить состав вашей системы.
[30:27.000 --> 30:32.000]  Почему так делать нельзя? Совершенно наивно.
[30:32.000 --> 30:37.000]  Вот были у вас три реплики.
[30:37.000 --> 30:43.000]  Одна вот, ну не знаю, все, она не нужна вам больше. Не нравится.
[30:43.000 --> 30:51.000]  Вы хотите ее вытащить из этой конфигурации, из состава RSM, а новую добавить?
[30:51.000 --> 30:54.000]  Можно ли так делать?
[31:04.000 --> 31:08.000]  Ну, сообщить, ладно, ты не можешь всем сразу сообщить.
[31:08.000 --> 31:18.000]  Вот, а вообще-то вот такая конструкция, она выглядит как...
[31:18.000 --> 31:22.000]  Ну, если ты сделаешь тянение аккуратно, это все будет выглядеть как замена диска у машины.
[31:22.000 --> 31:26.000]  В смысле, ты берешь и стираешь ее диск.
[31:26.000 --> 31:31.000]  То есть у вас по-прежнему три реплики, но почему-то третья реплика больше не помнит никаких обещаний, ничего не знает.
[31:31.000 --> 31:34.000]  А она раньше участвовала в кормах.
[31:34.000 --> 31:36.000]  Ну, так себе идея.
[31:36.000 --> 31:41.000]  Давай немного попроще сделаем. Вот у тебя есть три реплики.
[31:41.000 --> 31:48.000]  Нет, пусть четыре есть. Это странно, конечно, что у тебя четыре реплики, но все же.
[31:48.000 --> 31:54.000]  Ты хочешь, не то чтобы что-то поменять, ты хочешь отказустойчивость повысить и добавлять реплики по одной.
[31:54.000 --> 31:57.000]  Вот ты хочешь пятую добавить, потом шестую, но сначала пятую.
[31:57.000 --> 31:59.000]  Вот можете добавить пятую?
[32:08.000 --> 32:10.000]  Какой quorum сейчас у этих реплик?
[32:15.000 --> 32:17.000]  На большинство, да.
[32:22.000 --> 32:26.000]  Вот, если мы добавим сюда пятую реплику, то кажется это безопасно.
[32:26.000 --> 32:29.000]  То есть можно сказать иначе, что у нас было пять реплик с самого начала,
[32:29.000 --> 32:32.000]  просто одна была мертва долгое время, потом ее все-таки реанимировали,
[32:32.000 --> 32:35.000]  и вот она теперь в какой-то зоме появился.
[32:35.000 --> 32:38.000]  Но quorum не возросли, поэтому абсолютно легальная операция.
[32:38.000 --> 32:42.000]  Значит, это переход от четного числа к нечетному.
[32:42.000 --> 32:44.000]  Странно, что у нас нечетное число возникло.
[32:44.000 --> 32:50.000]  Оно возникло по пути, потому что до этого мы говорили про добавление к нечетному еще одного.
[32:53.000 --> 32:55.000]  А вот так можно делать?
[32:57.000 --> 33:00.000]  Но у нас сейчас quorum размера два.
[33:03.000 --> 33:06.000]  А с четырьмя они должны увеличиться.
[33:07.000 --> 33:09.000]  Стать размера три.
[33:10.000 --> 33:12.000]  Вроде бы не безопасно.
[33:12.000 --> 33:14.000]  Или безопасно?
[33:16.000 --> 33:22.000]  Но смотрите, я добавляю этот узел сюда, видимо, ожидаю, что он знает про все существующие.
[33:23.000 --> 33:28.000]  То есть у него у узла либо старая картина мира, где вот есть эта тройка и quorum и 2,
[33:28.000 --> 33:31.000]  либо это новый узел, он знает про все, то есть у него quorum и 3.
[33:31.000 --> 33:36.000]  Если мы расскажем этому узлу, что появился новый, то у него тоже будет quorum и 3.
[33:36.000 --> 33:40.000]  Но окажется, что 2 и 3 на четырех узлах все равно пересекаются.
[33:47.000 --> 33:49.000]  Что же получается-то?
[33:49.000 --> 33:53.000]  Что я могу просто брать и добавлять по одному узлу, или нет?
[33:55.000 --> 33:58.000]  Посмотри, к трем могу добавить один.
[33:58.000 --> 34:00.000]  К трем могу добавить один.
[34:00.000 --> 34:03.000]  В случае четного и нечетного исчерпались.
[34:06.000 --> 34:08.000]  Но где-то обман, конечно, есть.
[34:13.000 --> 34:18.000]  Ну не знают, она собирает quorum размера два, но это нормально, потому что quorum пересекаются.
[34:18.000 --> 34:20.000]  А что им еще нужно?
[34:24.000 --> 34:25.000]  Что?
[34:25.000 --> 34:29.000]  Ну она же потом узнает, будет же она в неведении находиться.
[34:36.000 --> 34:39.000]  Она же будет собирать quorum из трех узлов, или как?
[34:39.000 --> 34:42.000]  Ну если она знает про это, значит она знает про все пять, получается.
[34:42.000 --> 34:44.000]  Иначе странно.
[34:45.000 --> 34:48.000]  Ну обман-то не в этом, в этом обмана нет никакого смысла.
[34:48.000 --> 34:50.000]  Действительно ничего не ломается.
[34:50.000 --> 34:55.000]  Проблема в том, что, а что если вам нужно добавить не один узел, а два?
[34:55.000 --> 34:57.000]  Потому что, в конце концов, это ваша цель.
[34:57.000 --> 35:00.000]  Чтобы сущность повысить, вам нужно добавить два узла к трем.
[35:00.000 --> 35:01.000]  Вот.
[35:01.000 --> 35:03.000]  Добавить один, а потом добавить один.
[35:03.000 --> 35:06.000]  А что если вы прямо сейчас не можете достучаться до всех узлов?
[35:08.000 --> 35:11.000]  И вот если вы добавите один, а потом еще один,
[35:12.000 --> 35:15.000]  то вот уже неприятная ситуация может возникнуть.
[35:15.000 --> 35:17.000]  У вас было три.
[35:17.000 --> 35:19.000]  У вас есть еще два.
[35:21.000 --> 35:23.000]  И они, допустим, про все знают.
[35:23.000 --> 35:25.000]  Но у вас есть какие-то...
[35:27.000 --> 35:31.000]  У вас есть узлы, которые знают только про очень маленькие quorums.
[35:33.000 --> 35:35.000]  И вот у вас здесь какой-то есть узел.
[35:35.000 --> 35:38.000]  Вот он почему-то считает, что quorum размера два.
[35:38.000 --> 35:39.000]  Размер два.
[35:39.000 --> 35:42.000]  Почему-то потому, что он жил в мире, где quorum были размера два.
[35:42.000 --> 35:43.000]  Вот.
[35:43.000 --> 35:45.000]  А теперь у вас еще есть этот узел и этот.
[35:45.000 --> 35:47.000]  А они живут в мире, где quorum размера три.
[35:47.000 --> 35:49.000]  И вот теперь они перестали пересекаться.
[35:53.000 --> 35:56.000]  Ну, вы скажете, а давайте не будем добавлять машины,
[35:56.000 --> 35:59.000]  пока все не знают про старое обновление.
[36:00.000 --> 36:03.000]  Но это не очень отказоустойчиво, потому что если у нас partition есть,
[36:03.000 --> 36:05.000]  то получается, мы не можем ничего сделать.
[36:05.000 --> 36:07.000]  Если мы не можем синхронно достучаться до всех машин,
[36:07.000 --> 36:09.000]  а мы не можем все так сделать, потому что в большом классе
[36:09.000 --> 36:11.000]  всегда кто-то не работает, потому что диски поломаны.
[36:11.000 --> 36:13.000]  И там их меняют, и перезагружают.
[36:13.000 --> 36:17.000]  В общем, в этом наивном протоколе добавить один узел,
[36:17.000 --> 36:22.000]  потом дождаться всех не работает то, что нужно дождаться всех.
[36:22.000 --> 36:24.000]  Это не отказоустойчиво.
[36:24.000 --> 36:28.000]  Поэтому тут варианта два.
[36:28.000 --> 36:31.000]  Либо делать неаккуратно, ну тогда мы пожертвуем согласованностью,
[36:31.000 --> 36:33.000]  потому что quorum перестанут пересекаться.
[36:33.000 --> 36:39.000]  Либо, ну как не знаю, выключить все,
[36:39.000 --> 36:42.000]  переконфигуировать, включить заново.
[36:42.000 --> 36:45.000]  Вот нам это не нравится.
[36:45.000 --> 36:48.000]  Мы бы хотели, чтобы мы могли переконфигуировать систему,
[36:48.000 --> 36:50.000]  то есть заменять в ней узлы, добавлять новые,
[36:50.000 --> 36:56.000]  ударять какие-то без остановки системы на лету.
[36:56.000 --> 37:01.000]  Система продолжает работать, и при этом в ней меняется состав узлов динамически.
[37:01.000 --> 37:02.000]  В чем здесь сложность?
[37:02.000 --> 37:05.000]  В том, что если мы говорим про мультипаксос,
[37:05.000 --> 37:10.000]  то в каком-то слоте этого мультипаксоса разные реплики могут разойтись
[37:10.000 --> 37:14.000]  относительно конфигурации, в которой они работают.
[37:14.000 --> 37:17.000]  То есть одна может быть, что у нас конфигурация вот такая из трех узлов,
[37:17.000 --> 37:19.000]  а другая, что из пяти уже.
[37:19.000 --> 37:21.000]  И в итоге quorum не пересекутся.
[37:21.000 --> 37:26.000]  Вот беда в этом, что слот лога 1, задача консенсуса одна,
[37:26.000 --> 37:30.000]  а миры конфигурации, в которых живут реплики, она разная.
[37:30.000 --> 37:32.000]  Поэтому возникает очень естественное решение.
[37:32.000 --> 37:34.000]  Какое?
[37:36.000 --> 37:40.000]  Видимо, упорядочить конфигурации относительно остальных команд.
[37:44.000 --> 37:46.000]  Да? Нет?
[37:50.000 --> 37:54.000]  Тут у нас как бы реплики, которые совмещают в себе разные роли.
[37:54.000 --> 37:56.000]  Нет, acceptor не должны ничего знать.
[37:56.000 --> 37:59.000]  Acceptor это узел, который просто реагирует на сообщения.
[37:59.000 --> 38:01.000]  Он ни с кем не общается.
[38:01.000 --> 38:03.000]  Proposer должен знать.
[38:03.000 --> 38:07.000]  Каждый узел тут и proposer, и acceptor.
[38:07.000 --> 38:09.000]  Кому будет легче?
[38:09.000 --> 38:13.000]  Я не очень понял, что ты предлагаешь.
[38:22.000 --> 38:24.000]  А может быть столько же?
[38:24.000 --> 38:26.000]  Ну вот зуки перейти одни и те же узлы, например.
[38:26.000 --> 38:30.000]  Так что давай так считать.
[38:30.000 --> 38:33.000]  Проблема не в том, что их меньше, а в том, что нужно до всех достучаться.
[38:33.000 --> 38:35.000]  Это не отказуствует чего уже.
[38:37.000 --> 38:39.000]  Так что делать?
[38:39.000 --> 38:41.000]  Я же решение рассказал.
[38:41.000 --> 38:43.000]  Нет?
[38:47.000 --> 38:53.000]  Смотрите, в слоте разные proposer могут думать про разные конфигурации.
[38:56.000 --> 39:00.000]  Ну вот давайте упорядочим смену конфигурации относительно остальных команд.
[39:00.000 --> 39:02.000]  А что это значит?
[39:06.000 --> 39:10.000]  Вот у нас есть реплика, у нее есть лог.
[39:14.000 --> 39:18.000]  Давайте считать, что сначала, когда мы только RSM запустили в первый раз в жизни,
[39:18.000 --> 39:22.000]  мы выдали всем репликам конфигурацию Ц0.
[39:22.000 --> 39:28.000]  И вот реплика живет и знает, что во всех слотах лога нужно использовать конфигурацию Ц0.
[39:28.000 --> 39:30.000]  А потом мы хотим перейти к конфигурации Ц1.
[39:30.000 --> 39:32.000]  Что мы для этого делаем?
[39:32.000 --> 39:34.000]  Мы администратор этой системы.
[39:42.000 --> 39:48.000]  Вот смотрите, вот система, а вот администратор.
[39:52.000 --> 39:54.000]  Что он делает?
[40:04.000 --> 40:08.000]  Он посылает команду, которая называется реконфигурация.
[40:14.000 --> 40:16.000]  Ну он просто ее предлагает.
[40:16.000 --> 40:20.000]  То есть это такая служебная команда, которая не подается на вход, конечно же, автомату.
[40:20.000 --> 40:24.000]  Но тем не менее, эта команда, она должна куда-то попасть в лог.
[40:24.000 --> 40:28.000]  То есть пропозер, лидер должен выбрать для нее слот и положить ее туда.
[40:30.000 --> 40:32.000]  Вот она сюда закомитилась.
[40:34.000 --> 40:36.000]  Как-то нам помогло.
[40:38.000 --> 40:42.000]  Но, видимо, давайте считать дальше, что мы до этого момента жили в конфигурации Ц0,
[40:42.000 --> 40:46.000]  а с этого момента мы живем в конфигурации Ц1.
[40:50.000 --> 40:54.000]  Что скажете?
[41:00.000 --> 41:04.000]  Это нам помогает, что теперь все реплики понимают, в какой конфигурации нужно работать в каждом слоте.
[41:04.000 --> 41:06.000]  А что нам еще нужно было?
[41:10.000 --> 41:14.000]  Под конфигурация я понимаю набор узлов, которые образуют RSM.
[41:20.000 --> 41:26.000]  Я хочу добавить две реплики.
[41:26.000 --> 41:32.000]  Беда раньше была в том, что тебя один пропозер жил в одном слоте в одной конфигурации, другой в другом.
[41:32.000 --> 41:38.000]  Ну вот я сделал переконфигурацию служебной командой и упорядочил ее через лог,
[41:38.000 --> 41:42.000]  ну а через что мне еще упорядочивать их, с другими командами.
[41:42.000 --> 41:46.000]  В итоге теперь я знаю, что вот здесь конфигурация Ц1, а здесь была Ц0.
[41:50.000 --> 41:56.000]  Вот то, что это работает, сомнения же, не вызывает?
[41:56.000 --> 41:58.000]  Ну в принципе-то понятен, да?
[41:58.000 --> 42:00.000]  Это просто плохо работает, так делать нельзя.
[42:00.000 --> 42:04.000]  Но хотя бы что это работает, понятно?
[42:04.000 --> 42:10.000]  А почему это плохо работает? Почему так делать в продакшене нельзя?
[42:10.000 --> 42:20.000]  Ну вот смотрите, вы реплика в мультипаксисе.
[42:20.000 --> 42:22.000]  У вас есть такой лог.
[42:22.000 --> 42:24.000]  Вот у вас есть какой-то закоммиченный префикс уже.
[42:24.000 --> 42:26.000]  Ну то есть там какие-то команды лежат.
[42:26.000 --> 42:30.000]  И вам приходят две команды.
[42:30.000 --> 42:36.000]  Что вы с ними делали?
[42:36.000 --> 42:42.000]  Ну что вы с ними делаете, что мы с ними делали в прошлый раз?
[42:42.000 --> 42:48.000]  Ну вот мы запускаем два паксиса.
[42:48.000 --> 42:54.000]  Один пытается положить команду move в пятый слот, а другой команду jump в шестой слот.
[42:54.000 --> 42:58.000]  И мы живем в конфигурации Ц0 пока еще.
[42:58.000 --> 43:02.000]  Вот утверждается, что уже все плохо.
[43:02.000 --> 43:12.000]  Потому что у нас есть другая реплика, которая получила команду от администратора переконфигурации.
[43:12.000 --> 43:18.000]  И сейчас пытается положить в слот 5 переконфигурацию.
[43:18.000 --> 43:20.000]  Ей это удается.
[43:20.000 --> 43:28.000]  И это означает, что команда в слоте 6 должна коммититься через паксис относительно конфигурации Ц1.
[43:28.000 --> 43:32.000]  А мы уже начали состараться ноль.
[43:32.000 --> 43:38.000]  В итоге пока мы не зафиксировали этот слот, мы не можем заполнять этот слот.
[43:38.000 --> 43:42.000]  В итоге у нас теперь ноль параллельности. Мы команды коммитим только по одной.
[43:42.000 --> 43:48.000]  Как это починить?
[43:48.000 --> 44:00.000]  Тебя все устраивает, да?
[44:00.000 --> 44:02.000]  Решение такое.
[44:02.000 --> 44:06.000]  Ну как добавить больше параллелизма?
[44:06.000 --> 44:14.000]  Мы не можем начать следующую команду, потому что здесь может быть переконфигурация.
[44:14.000 --> 44:20.000]  Но это нормальная ситуация. Мы не знаем предыдущей команды, мы не хотим, чтобы нас ограничивало.
[44:20.000 --> 44:26.000]  И даже если здесь окажется переконфигурация, мы не хотим, чтобы она у нас сразу влияла.
[44:26.000 --> 44:32.000]  Как нам тогда перестроить наш алгоритм переконфигурации?
[44:32.000 --> 44:37.000]  Давайте скажем, что переконфигурация имеет отложенный эффект.
[44:37.000 --> 44:41.000]  Вот у нас сначала конфигурация Ц0, а здесь оказалась Ц1.
[44:41.000 --> 44:45.000]  Вот это называется альфа-метод.
[44:45.000 --> 44:47.000]  Грандиозное название.
[44:47.000 --> 44:56.000]  Смысл в том, что конфигурация Ц1, если оно закоммитчено в слоте К, начинает действовать только со слота К плюс альфа.
[44:56.000 --> 45:04.000]  Тут некоторые глобальные параметры, которые выбираются один раз, которые, видимо, лучше дальше не трогать.
[45:04.000 --> 45:10.000]  И вот здесь мы живем в конфигурации Ц0, а здесь мы переходим уже в конфигурацию Ц1.
[45:10.000 --> 45:15.000]  Так что у нас есть такое окно альфы, в которое мы можем параллельно предлагать команды.
[45:15.000 --> 45:24.000]  Но если вдруг у нас есть команды, которые могли бы добавить в лог, но альфа-команд назад все еще не зафиксировано окно,
[45:24.000 --> 45:28.000]  то мы должны остановиться и ждать, пока там что-то не закоммитится.
[45:34.000 --> 45:36.000]  Понятная идея?
[45:36.000 --> 45:40.000]  На самом деле это некоторый обман, потому что звучит очень просто, очень просто звучит.
[45:40.000 --> 45:45.000]  А на самом деле там есть еще масса частных случаев, которые нужно решать, если вы пишете код.
[45:45.000 --> 45:48.000]  Про это есть отдельная статья, мы не успеем все.
[45:48.000 --> 45:51.000]  Хотя вообще-то было бы здорово написать.
[45:51.000 --> 45:54.000]  Встребовался сразу.
[45:54.000 --> 46:01.000]  Еще есть проблема в том, что у тебя есть ограничение на альфа, оно тебя тормозит, даже когда переконфигурации нет.
[46:01.000 --> 46:03.000]  Это неприятно.
[46:03.000 --> 46:10.000]  Вот какое-то место, которое можно было бы улучшить, но даже сейчас не проулучшен.
[46:10.000 --> 46:13.000]  Вопрос такой очень хитрый.
[46:13.000 --> 46:16.000]  Теперь вы знаете алгоритм RAFT.
[46:16.000 --> 46:19.000]  Громко сказано, что знаете, пока не написали, не знаете.
[46:19.000 --> 46:26.000]  Вы читаете статью, и там есть собственный протокол переконфигурации, собственный алгоритм.
[46:26.000 --> 46:30.000]  Видимо, он там есть неспроста, но чем-то этот не устроил.
[46:30.000 --> 46:38.000]  Вот оказывается, что RAFT с этой конструкцией не работает.
[46:38.000 --> 46:44.000]  Я вот не знаю, то ли это сложный вопрос на зачет, то ли я хочу рассказать вам сейчас.
[46:44.000 --> 46:49.000]  Как мне поступить?
[46:49.000 --> 46:56.000]  Он останется на зачете все равно, а ты забудешь все равно.
[46:56.000 --> 47:07.000]  Смотрите, вот жил был RAFT, у него было альф равно 3.
[47:07.000 --> 47:14.000]  Выбрал был лидер, он получил три команды, записал их в три реплики.
[47:14.000 --> 47:18.000]  Я, кстати, не сказал, что RAFT может реплицировать сразу пачки команд.
[47:18.000 --> 47:20.000]  Он не по одной это делает.
[47:20.000 --> 47:23.000]  Он собрал пять команд в клиента и сразу суффикс длины 5 отправил.
[47:23.000 --> 47:28.000]  В общем, у него был префикс длины 3, он заполнил его тремя командами какими-то,
[47:28.000 --> 47:35.000]  отреплицировал их на фоллеров и взорвался, перезагрузился вернее.
[47:35.000 --> 47:43.000]  Команды не закоммичены, потому что он об этом никому не сказал и сам пока не знает.
[47:43.000 --> 47:52.000]  Он стартует, перезагружается, стартует, переходит в следующую эпоху, в следующий терм.
[47:52.000 --> 47:56.000]  Как ему быть дальше?
[47:56.000 --> 48:07.000]  С одной стороны, чтобы работать дальше, ему нужно подумать, что с этим всем происходит.
[48:07.000 --> 48:12.000]  У него есть три команды в логе.
[48:12.000 --> 48:16.000]  Знает ли он, что они закоммичены?
[48:16.000 --> 48:22.000]  Нет, чтобы узнать, что команда закоммичена, ему нужно закоммитить еще одну команду из текущего терма.
[48:22.000 --> 48:26.000]  Вот, собственно, про это и было правило коммита в RAFT-е особенное.
[48:26.000 --> 48:28.000]  Закоммитить четвертую команду ему нужно.
[48:28.000 --> 48:32.000]  А с другой стороны, чтобы коммитить четвертую команду, ему нужно, если альфа-3,
[48:32.000 --> 48:39.000]  чтобы он был уверен, что в логе в позиции 0 не переконфигурация, он этого не знает.
[48:39.000 --> 48:43.000]  То есть, с одной стороны, переконфигурация и альфа запрещают ему коммитить новые команды.
[48:43.000 --> 48:47.000]  С другой стороны, чтобы убедиться, что переконфигурации не будет, он должен закоммитить.
[48:47.000 --> 48:52.000]  То есть, у него проблемы некоторые. Понятно или нет?
[48:52.000 --> 48:57.000]  Еще раз, закоммитить новую команду он хочет, но не может, потому что альфа ему запрещает.
[48:57.000 --> 49:04.000]  Потому что может быть переконфигурация.
[49:04.000 --> 49:12.000]  То есть, делать ничего нельзя.
[49:12.000 --> 49:19.000]  Еще раз, ты лидер, ты в терме 2, перезагрузился в терме 2, у тебя 3 команды в логе.
[49:19.000 --> 49:23.000]  Ты получаешь новые команды от клиента, что ты с ними делаешь?
[49:23.000 --> 49:26.000]  А как же ты можешь коммитить, когда ты не знаешь, что у тебя в логе в позиции 0?
[49:26.000 --> 49:28.000]  Ты не уверен, что эта команда закоммичена?
[49:28.000 --> 49:32.000]  Пока она не закоммичена, там может быть переконфигурация.
[49:32.000 --> 49:36.000]  Но чтобы ее там не было, ты должен закоммитить этот префикс.
[49:36.000 --> 49:40.000]  Но ты не можешь его закоммитить, потому что у тебя альфа исчерпалась.
[49:40.000 --> 49:43.000]  Ну все, не нужно использовать этот протокол в RAFT.
[49:43.000 --> 49:46.000]  Вот, собственно, поэтому авторы и не используют.
[49:46.000 --> 49:55.000]  Неприятная ситуация. Так что RAFT еще в одном месте нас подкачал, подвел.
[49:55.000 --> 49:59.000]  Итак, переконфигурация. Переконфигурация необходима для RSM.
[49:59.000 --> 50:02.000]  Как мы без этого будем деплоить в продакшене все это?
[50:05.000 --> 50:07.000]  Дальше. Что еще необходимо для продакшена?
[50:07.000 --> 50:09.000]  Ну, чтобы вообще это все заработало.
[50:09.000 --> 50:13.000]  Я говорил об этом на лекции про томик Broadcast.
[50:13.000 --> 50:16.000]  Мы должны убедиться, что у нас автомат детерминированный.
[50:16.000 --> 50:22.000]  Ну, то есть, да, RSM реплицирует логи, да, команды в одном порядке, история изменений.
[50:22.000 --> 50:26.000]  Но при этом, если автомат будет делать недетерминированные переходы, то все поломается.
[50:26.000 --> 50:31.000]  Вот. А с недетерминизмом сложно, потому что он может браться из разных мест.
[50:31.000 --> 50:40.000]  Ну, например, не то чтобы вы монетки подкидываете, а дело в том, что вы можете использовать в своей реализации хэшмэпы.
[50:40.000 --> 50:46.000]  А в хэшмэпах есть хэш-функции, а хэш-функции могут инициализироваться каким-то, не знаю, адресом в памяти.
[50:46.000 --> 50:50.000]  Вот хэш-таблицы AppSale, Google AppSale, их Open Source библиотеки.
[50:50.000 --> 50:52.000]  Очень быстрые хэш-таблицы так и работают.
[50:53.000 --> 50:59.000]  И если вдруг вы запустили два процесса, то у них как бы выбираются две хэш-функции на разных узлах с разными параметрами,
[50:59.000 --> 51:02.000]  потому что там адресное пространство процессорандомизируется.
[51:02.000 --> 51:06.000]  Ну и все. В этих хэш-таблицах получается разный порядок итерации.
[51:06.000 --> 51:09.000]  Если вдруг от него что-то зависит, то у вас реплики могут разойтись.
[51:09.000 --> 51:15.000]  Ну или у вас время используется, вы там, не знаете, ставите атрибуты в DFS, время последнего обращения к файлу,
[51:15.000 --> 51:19.000]  или последней записи в файл. На каждой реплике свои часы.
[51:19.000 --> 51:22.000]  Вот непонятно, как там синхронизировать это все.
[51:22.000 --> 51:29.000]  Или же у вас просто реплики меняют, вы обновляете код на репликах, код самого RSM.
[51:29.000 --> 51:34.000]  Вы не можете выключить, а потом включить новую версию, это неэффективно, вы останавливаетесь.
[51:34.000 --> 51:39.000]  Вы хотите на лету это делать. В итоге у вас есть реплики с новым кодом, реплики со старым кодом.
[51:39.000 --> 51:42.000]  И вдруг они ведут себя немного по-разному, нужно об этом думать.
[51:42.000 --> 51:46.000]  Они могут общаться на разных версиях протокола, нужно обратную совместимость поддерживать.
[51:46.000 --> 51:51.000]  И вдруг вы здесь что-то нарушите, то реплики могут разойтись.
[51:51.000 --> 51:56.000]  Вот нужно все это учитывать. Ну там в общем случае можно взять это недотерминизмом.
[51:56.000 --> 52:04.000]  Еще одна проблема, которую необходимо решать в промышленной реализации, это семантика экзеклианса.
[52:04.000 --> 52:08.000]  Точнее, это гарантия, которую вы очень хотите достичь.
[52:08.000 --> 52:13.000]  Вы клиент, вы общаетесь с RSM, то есть общаетесь с какой-то машиной из этого RSM,
[52:13.000 --> 52:18.000]  отправляете ей свою команду, эта машина, допустим, лидер, начинает ее реплицировать.
[52:18.000 --> 52:21.000]  Допустим, даже это удается, а потом она перезагружается и соединение рвется.
[52:21.000 --> 52:28.000]  И вы не понимаете, что произошло. То ли соединение провалилось до того, как команда применилась к автомату, то ли после.
[52:28.000 --> 52:31.000]  Если вы ретравитесь в первом случае, то ничего страшного.
[52:31.000 --> 52:34.000]  Если вы ретравитесь в втором случае, то вы применили команду дважды.
[52:34.000 --> 52:39.000]  Она может быть недопотентная, может быть вы какой-то инкремент делаете или CAS.
[52:39.000 --> 52:47.000]  Так что даже имея multipaxos или raft в своем распоряжении, вы сходу этот экзеклианс не получаете.
[52:47.000 --> 52:53.000]  Это протокол, который должен быть делан частично на стороне RSM, а частично на стороне клиента.
[52:53.000 --> 52:58.000]  И про это рассказывать не буду, потому что про это домашка есть следующая, так что будет.
[52:58.000 --> 53:01.000]  Так что там вы попробуете придумать сами.
[53:01.000 --> 53:09.000]  Ну вот про такие вещи статья Paxos Made Live.
[53:09.000 --> 53:14.000]  Но я хочу поговорить не только про то, что вам необходимо делать, типа переконфигурации, экзеклианс,
[53:14.000 --> 53:18.000]  а про то, что можно делать, чтобы RSM ускорить.
[53:18.000 --> 53:26.000]  Потому что ускорить RSM или масштабировать RSM, это немного разные задачи, непросто.
[53:26.000 --> 53:28.000]  Давайте про масштабирование говорить.
[53:28.000 --> 53:30.000]  То есть что понимается под масштабированием?
[53:30.000 --> 53:34.000]  Мы можем добавлять новые машины, система работает лучше, быстрее, производительнее,
[53:34.000 --> 53:36.000]  у нее растет пропускная способность.
[53:36.000 --> 53:41.000]  Вот у RSM при добавлении реплик ничего лучше не становится, становится только хуже.
[53:41.000 --> 53:43.000]  Потому что отказоустойчивость растет.
[53:43.000 --> 53:48.000]  Ну как бы, бог с ним, мы уже ее выбрали, зафиксировали с самого начала, сколько мы готовы отказов пережить.
[53:48.000 --> 53:56.000]  А дальше мы хотим при заданной отказоустойчивости просто увеличивать число запросов, которые RSM способен перевалить.
[53:56.000 --> 54:00.000]  И тут беда, потому что просто добавлением узлов ничего делу не поможешь.
[54:00.000 --> 54:02.000]  Мы добавляем еще 10 аксепторов и становятся только хуже.
[54:02.000 --> 54:08.000]  Quorum растут, самая медленная машина из Quorum остановится еще как бы дальше от нас,
[54:08.000 --> 54:14.000]  в смысле дальше по времени, еще медленнее, поэтому мы все медленнее делаем.
[54:14.000 --> 54:16.000]  Мы хотим, наоборот, быстрее и больше.
[54:16.000 --> 54:22.000]  Вот давайте подумаем, в чем проблема, почему RSM медленный?
[54:22.000 --> 54:24.000]  Кто в этом виноват?
[54:26.000 --> 54:30.000]  Ну это неизбежно, если ты используешь консенсус.
[54:30.000 --> 54:32.000]  Мы не можем этого избежать.
[54:32.000 --> 54:34.000]  Тут есть разные места, которые можно тюнить.
[54:34.000 --> 54:36.000]  Вот давайте я вам покажу сначала.
[54:36.000 --> 54:38.000]  Есть очевидное место.
[54:38.000 --> 54:40.000]  Вот у вас есть лидер и через него все проходит.
[54:40.000 --> 54:42.000]  На нем очень много работы.
[54:42.000 --> 54:44.000]  Ну буквально вся работа.
[54:44.000 --> 54:46.000]  Вот.
[54:46.000 --> 54:48.000]  Но это понятное точка, понятное узкое место.
[54:48.000 --> 54:50.000]  Я хочу вам рассказать про неожиданное узкое место.
[54:50.000 --> 54:54.000]  Не то, что про узкое место, а про место, в котором можно неожиданным образом что-то потюнить.
[54:54.000 --> 54:56.000]  Про кворумы.
[54:56.000 --> 55:00.000]  Вот я весь семестр очень аккуратно говорил про кворумы.
[55:00.000 --> 55:02.000]  Говорил всегда не о большинстве, а о кворумах.
[55:02.000 --> 55:06.000]  Потому что сегодня кворумы перестанут быть большинством.
[55:06.000 --> 55:10.000]  Помните ли вы, как мы доказывали корректность паксуса?
[55:10.000 --> 55:12.000]  Или рафта?
[55:12.000 --> 55:14.000]  Это одно и то же.
[55:14.000 --> 55:16.000]  Вот мы два кружка рисовали.
[55:16.000 --> 55:18.000]  Но это были разноцветные кружки.
[55:18.000 --> 55:20.000]  Почему разноцветные?
[55:20.000 --> 55:30.000]  Потому что здесь была фаза prepare, а здесь была фаза accept.
[55:30.000 --> 55:36.000]  То есть мы говорили, что если значение выбрано, то есть за него проголосовали большинство accept,
[55:36.000 --> 55:38.000]  ну, кворум аксепторов,
[55:38.000 --> 55:42.000]  и если у нас появился какой-то пропозор с большим номером, с большей эпохой,
[55:42.000 --> 55:44.000]  и он прошел через фазу prepare,
[55:44.000 --> 55:46.000]  то обязательно в пересечении будет какая-то реплика.
[55:46.000 --> 55:52.000]  И это означает, что через эту реплику этот новый пропозор узнает про уже выбранное значение и его не поменяет.
[55:52.000 --> 55:58.000]  Так вот, из этих рассуждений следует нехитрое наблюдение.
[55:58.000 --> 56:04.000]  В алгоритме Paxos мы нигде не требовали, чтобы, скажем, пересекались кворумы одной фазы.
[56:04.000 --> 56:08.000]  Нам достаточно пересечение кворумов разных фаз.
[56:08.000 --> 56:14.000]  И вот я сейчас собираюсь здесь и здесь использовать разные кворумы.
[56:14.000 --> 56:18.000]  Раньше у нас были просто большинства, и любые два большинства пересекаются.
[56:18.000 --> 56:20.000]  А теперь я хочу разделить систему кворумов на две.
[56:20.000 --> 56:30.000]  Значит, система кворумов, которая про первую фазу и система кворумов про вторую фазу.
[56:34.000 --> 56:38.000]  Как это мне поможет? Как я собираюсь это использовать?
[56:38.000 --> 56:42.000]  А я собираюсь сейчас увеличить количество аксепторов.
[56:42.000 --> 56:46.000]  Вот давайте я возьму 10 аксепторов.
[56:52.000 --> 57:00.000]  Сначала нарисую тупо. Раз, два, три, четыре, шесть. Отлично, 10 аксепторов.
[57:00.000 --> 57:04.000]  И давайте я буду в качестве кворумов...
[57:04.000 --> 57:10.000]  Ну и смотрите, что важно-то, что в алгоритме multipaxos есть кворумы более частые и более редкие.
[57:10.000 --> 57:14.000]  Репер — это выбор лидера нового. Он редко происходит.
[57:14.000 --> 57:18.000]  Зато на каждую команду собирается кворум из аксептов.
[57:18.000 --> 57:24.000]  То есть в RAF-те у вас есть иногда кворум на request-vote,
[57:24.000 --> 57:28.000]  и всегда кворум на append-entries при каждой репликации, при каждой команде.
[57:28.000 --> 57:33.000]  Так вот, давайте сделаем кворумы, которые собираются чаще, поменьше.
[57:33.000 --> 57:39.000]  Вот я скажу, что у меня кворум на accept будет вот такой вот.
[57:39.000 --> 57:45.000]  Три. То есть любая тройка.
[57:45.000 --> 57:51.000]  А кворум на prepare какой у меня станет?
[57:51.000 --> 57:55.000]  Ох, ну пусть 8.
[57:55.000 --> 57:59.000]  Не слишком клёвая идея пока, но в таком виде.
[57:59.000 --> 58:03.000]  Ну не клёвая идея здесь, а здесь она клёвая.
[58:03.000 --> 58:07.000]  Понятно ли почему?
[58:07.000 --> 58:11.000]  Что я собираюсь здесь выиграть?
[58:11.000 --> 58:15.000]  Но в чём профит-то?
[58:15.000 --> 58:19.000]  Если бы я взял с самого начала пять реплик, то у меня было бы...
[58:19.000 --> 58:23.000]  То есть смотри, я переживаю по-прежнему два отказа.
[58:23.000 --> 58:27.000]  Два отказа мне достаточно сколько реплик взять? Пять.
[58:27.000 --> 58:31.000]  А я взял десять. И переживаю два отказа.
[58:31.000 --> 58:35.000]  Где-то должен быть смысл.
[58:35.000 --> 58:39.000]  Вот я собираюсь не число отказов увеличивать, потому что я отказы зафиксировал.
[58:39.000 --> 58:43.000]  У меня устраивает два. Я хочу accept разгрузить.
[58:43.000 --> 58:47.000]  Я сделал их больше, и хочу что сейчас сделать?
[58:47.000 --> 58:51.000]  Понятно или нет?
[58:51.000 --> 58:57.000]  Ну да, можно сказать, что если мы хотим из десяти выбрать три быстро,
[58:57.000 --> 59:01.000]  то это проще, чем из пяти.
[59:01.000 --> 59:05.000]  Там меньше шансов, что кто-то будет тормозить.
[59:05.000 --> 59:09.000]  Но смысл не в этом.
[59:09.000 --> 59:13.000]  Вот смотрите, есть технология RAID. Знаете про неё?
[59:13.000 --> 59:17.000]  Это redundant array of independent disks.
[59:17.000 --> 59:21.000]  То есть это способ брать диски и строить из них такие виртуальные диски,
[59:21.000 --> 59:25.000]  у которых отказоустойчивость вышла, но какие-то свойства лучше.
[59:25.000 --> 59:29.000]  Вот есть разные уровни RAID. Вот есть RAID 1,
[59:29.000 --> 59:33.000]  когда мы берём два диска, и когда пишем блок в диск, то мы пишем в два диска сразу.
[59:33.000 --> 59:37.000]  Отказоустойчивость повысилась.
[59:37.000 --> 59:41.000]  А можно делать RAID 0. Вот RAID 1 это mirroring, то есть мы беззеркалируем диски.
[59:41.000 --> 59:45.000]  Они одинаковые теперь. А есть RAID 0, это striping.
[59:45.000 --> 59:49.000]  Мы когда пишем, пишем сначала то на один диск, то на другой, потом на один диск, то на другой.
[59:49.000 --> 59:53.000]  В итоге у нас пропускная способность удваивается. Мы пишем два раза больше.
[59:53.000 --> 59:57.000]  За одно и то же время.
[59:57.000 --> 01:00:01.000]  Смотрите, вот есть система, которая называется lock device.
[01:00:01.000 --> 01:00:05.000]  Это система очередей, которую написали в Facebook.
[01:00:05.000 --> 01:00:09.000]  У нас будет на лекциях кавка, это что-то похожее, но не совсем.
[01:00:09.000 --> 01:00:13.000]  В первом пробежении пусть будет похоже.
[01:00:13.000 --> 01:00:17.000]  Раид там использует консенсус, во-первых.
[01:00:17.000 --> 01:00:21.000]  Ну вот, вы можете почитать. Вот тут есть история про консенсус.
[01:00:21.000 --> 01:00:25.000]  У них есть слайды, и смотрите. Ну вот они сначала говорят, вот возьмём,
[01:00:25.000 --> 01:00:29.000]  действительно тупо очень сделаем, возьмём большие кворумы.
[01:00:29.000 --> 01:00:33.000]  Кворум на PPR огромный, кворум на accept маленький.
[01:00:33.000 --> 01:00:39.000]  Зато мы можем теперь выбирать, на какие аксепторы мы пишем какие данные.
[01:00:39.000 --> 01:00:43.000]  И чередовать. То есть первую команду мы запишем на эти три.
[01:00:43.000 --> 01:00:47.000]  Вторую команду мы напишем на эти три. Третью команду на эти три.
[01:00:47.000 --> 01:00:51.000]  Четвёртую команду мы вообще как-то разбросаем.
[01:00:51.000 --> 01:00:55.000]  В итоге каждый аксептор будет обрабатывать меньше команд, у него будет меньше работы.
[01:00:55.000 --> 01:00:59.000]  Нагрузка на каждую машину будет меньше. Отказоустойчивость та же.
[01:00:59.000 --> 01:01:03.000]  Но эти машины остаются разгруженными, более разгруженными.
[01:01:03.000 --> 01:01:07.000]  Ну как бы для RAF это не подойдёт вообще.
[01:01:07.000 --> 01:01:11.000]  Потому что никогда не поздно рекламировать Paxos в лишний раз.
[01:01:11.000 --> 01:01:15.000]  В RAF протокол работает, когда вы знаете предыдущую команду в логе.
[01:01:15.000 --> 01:01:19.000]  Здесь вы не знаете, а Paxos всё равно.
[01:01:19.000 --> 01:01:23.000]  Поэтому вы можете выбирать разные тройки и в итоге писать несколько раз быстрее.
[01:01:23.000 --> 01:01:27.000]  Что делать к клиенту?
[01:01:27.000 --> 01:01:31.000]  Смотрите, LogDevice это система очередей.
[01:01:31.000 --> 01:01:35.000]  Она просто слушает все реплики и из них клеит один непрерывный лог.
[01:01:35.000 --> 01:01:39.000]  Понятно ли идея?
[01:01:39.000 --> 01:01:43.000]  Ну вот так можно всё промасштабировать.
[01:01:43.000 --> 01:01:47.000]  А теперь...
[01:01:47.000 --> 01:01:51.000]  О, это было чётче.
[01:01:51.000 --> 01:01:55.000]  А теперь про вот эту штуку.
[01:01:55.000 --> 01:01:59.000]  Кворумы маленькие на второй фазе мы можем использовать.
[01:01:59.000 --> 01:02:03.000]  А теперь гигантский корм на первой фазе. Можно сделать умнее?
[01:02:03.000 --> 01:02:07.000]  Расскажи.
[01:02:07.000 --> 01:02:11.000]  Наверняка можно, да?
[01:02:15.000 --> 01:02:19.000]  Сейчас. У нас 10, да?
[01:02:19.000 --> 01:02:23.000]  Да, я по-другому нарисую картинку.
[01:02:23.000 --> 01:02:27.000]  Пусть стало сколько? 12?
[01:02:27.000 --> 01:02:31.000]  12.
[01:02:31.000 --> 01:02:35.000]  Допустим, я хочу выбирать кворумы зелёные маленькими.
[01:02:39.000 --> 01:02:43.000]  Вот, как мне теперь строить кворумы первой фазы, но не такие большие?
[01:02:43.000 --> 01:02:47.000]  Ну вот, можно взять строчку, да.
[01:02:47.000 --> 01:02:51.000]  Вот это то, что называется Great Quarums.
[01:02:51.000 --> 01:02:57.000]  Ну то есть мы, сохраняя отказоустойчивость, зафиксировав её,
[01:02:57.000 --> 01:03:03.000]  и зафиксировав размер кворума для второй фазы, который позволяет нам делать striping,
[01:03:03.000 --> 01:03:07.000]  можем уменьшить кворумы до первой фазы.
[01:03:07.000 --> 01:03:11.000]  Так, чтобы они всё равно пересекались. Нам этого достаточно.
[01:03:11.000 --> 01:03:15.000]  Но вот так делать всё равно не нужно.
[01:03:15.000 --> 01:03:19.000]  Почему? Потому что это уже следующая ступень понимания
[01:03:19.000 --> 01:03:23.000]  кворумов.
[01:03:23.000 --> 01:03:27.000]  Почему вообще у вас столько машин?
[01:03:27.000 --> 01:03:31.000]  Вы хотите что-то ускорить.
[01:03:31.000 --> 01:03:35.000]  А с другой стороны, вы хотите повысить отказоустойчивость.
[01:03:35.000 --> 01:03:39.000]  Ну, в смысле, с другой стороны, у вас отказоустойчивость беспокоит.
[01:03:39.000 --> 01:03:43.000]  Вот, есть некоторая недоработка у нас. Мы выбрали себе f
[01:03:43.000 --> 01:03:47.000]  и сказали, что вот для f нужно 2f плюс 1.
[01:03:47.000 --> 01:03:51.000]  Ну, если вы говорите о разной уровне доменов отказов,
[01:03:51.000 --> 01:03:55.000]  то отказы же бывают на разных уровнях.
[01:03:55.000 --> 01:03:59.000]  Это просто отказ из одного узла. Но f – это количество узлов, которые мы можем пережить.
[01:03:59.000 --> 01:04:03.000]  Но вообще-то у вас может не узел сломаться, у вас может до центра выйти из строя.
[01:04:03.000 --> 01:04:07.000]  И вы потеряете сразу много узлов.
[01:04:07.000 --> 01:04:11.000]  Поэтому, когда вы говорите, что я выбираю себе отказоустойчивость f,
[01:04:11.000 --> 01:04:15.000]  вообще-то у вас не одно должно быть f, а разные f.
[01:04:15.000 --> 01:04:19.000]  Я готов пережить сбой, потерю 1 dc целиком.
[01:04:19.000 --> 01:04:23.000]  Или 2 dc целиком.
[01:04:23.000 --> 01:04:27.000]  Так что у вас есть f маленькие, есть f побольше.
[01:04:27.000 --> 01:04:31.000]  И вот смотрите, пусть у вас 12 машин, но они находятся в 4 dc.
[01:04:31.000 --> 01:04:35.000]  Приберите зону.
[01:04:35.000 --> 01:04:39.000]  Вот 4 штуки.
[01:04:39.000 --> 01:04:43.000]  И допустим, вы берете такие кворумы. Вот чем это вам грозит?
[01:04:43.000 --> 01:04:47.000]  Но если мы говорим про репликацию, если одна зона умерла,
[01:04:47.000 --> 01:04:51.000]  1 dc отказал. Это не страшно, потому что вы пишете в другой dc.
[01:04:51.000 --> 01:04:55.000]  Пока хотя бы один жив, кворум собирается.
[01:04:55.000 --> 01:05:01.000]  Но в такой системе кворумов смерть любой зоны доступности, любого dc
[01:05:01.000 --> 01:05:05.000]  автоматически убивает любой кворум на фазу 1.
[01:05:05.000 --> 01:05:09.000]  Так что ваши кворумы с одной стороны переживают 2 любых отказа,
[01:05:09.000 --> 01:05:13.000]  а с другой стороны они не переживают смерть 1 dc.
[01:05:13.000 --> 01:05:17.000]  А мы не можем гарантировать, что ее не будет.
[01:05:17.000 --> 01:05:21.000]  То есть это просто один отказ фактически. В смысле это одно событие.
[01:05:21.000 --> 01:05:25.000]  И оно нас сразу убивает. Поэтому как быть?
[01:05:25.000 --> 01:05:29.000]  Вот выберем себе 2 f. Скажем, что f маленькое это 2 отказа,
[01:05:29.000 --> 01:05:33.000]  мы готовы пережить отказ 2 любых машин.
[01:05:33.000 --> 01:05:37.000]  И мы готовы пережить смерть 1 f большое около 1 dc.
[01:05:37.000 --> 01:05:41.000]  И какие мы кворумы построим?
[01:05:41.000 --> 01:05:45.000]  Я сейчас нарисую примеры, вы поймете, надеюсь.
[01:05:51.000 --> 01:05:57.000]  Вот я беру из каждого dc majority просто 2 машина.
[01:05:57.000 --> 01:06:03.000]  Сейчас, ну, ерунду конечно написал. Здесь один в каждом dc.
[01:06:03.000 --> 01:06:07.000]  Нет, 2 наверное тоже зайдет.
[01:06:07.000 --> 01:06:13.000]  Я беру majority в каждом dc и для одного кворума беру на уровне zone.
[01:06:13.000 --> 01:06:17.000]  Я беру с одной стороны f плюс 1 zone для 2 фазы.
[01:06:17.000 --> 01:06:21.000]  А для первой фазы беру число zone минус f.
[01:06:21.000 --> 01:06:27.000]  И в итоге я переживаю здесь, ну, в каждом dc смерть машины,
[01:06:27.000 --> 01:06:31.000]  я переживаю смерть всей зоны целиком. Я просто как бы ее обойду.
[01:06:31.000 --> 01:06:41.000]  Ну что, понятна идея?
[01:06:41.000 --> 01:06:47.000]  Ну, это кворум, смотри, ты для кворума выбираешь прямоугольных себе.
[01:06:47.000 --> 01:06:51.000]  Ты выбираешь число машин в каждой зоне, вот эта сторона,
[01:06:51.000 --> 01:06:55.000]  и число зон, которые ты захватываешь.
[01:06:55.000 --> 01:06:59.000]  Вот я для двух кворумов выбираю во второй фазе f плюс 1 зону,
[01:06:59.000 --> 01:07:05.000]  чтобы пережить отказ одной, чтобы не потерять данные, которые я записал.
[01:07:05.000 --> 01:07:07.000]  А здесь я беру z минус f, чтобы эти кворумы пересеклись с одной стороны.
[01:07:07.000 --> 01:07:11.000]  То есть если я беру f1, то я беру здесь 2 зоны, здесь 3 зоны,
[01:07:11.000 --> 01:07:15.000]  и мне не нужно всех четырех сразу. Вот так что я одно могу потерять.
[01:07:23.000 --> 01:07:28.000]  Вот здесь вот? И здесь проблема была в том, что когда у нас умирает дата-центр,
[01:07:28.000 --> 01:07:33.000]  то мы теряем весь столбец, а один столбец убивает нам любую строку.
[01:07:43.000 --> 01:07:46.000]  Да можно вообще полную вещь творить.
[01:07:46.000 --> 01:07:51.000]  Представь себе, любой путь с севера на юг, с запада на восток, они где-то пересекутся,
[01:07:51.000 --> 01:07:55.000]  но это уже математика, это не программирование.
[01:07:55.000 --> 01:07:58.000]  Что делает Фейсбук в своей системе? Они делают еще сложнее,
[01:07:58.000 --> 01:08:02.000]  потому что они думают не только про смерть ДЦ, они думают еще про смерть регионов.
[01:08:04.000 --> 01:08:07.000]  Вот сейчас мы постараемся разглядеть.
[01:08:11.000 --> 01:08:15.000]  Сейчас, у нас есть три региона, вот есть Орегон, Каролина, Северный и Техас.
[01:08:15.000 --> 01:08:19.000]  В каждом регионе есть 3 ДЦ, а в каждом ДЦ две машины.
[01:08:19.000 --> 01:08:23.000]  Ну в смысле машин-то много, это в смысле реплики.
[01:08:23.000 --> 01:08:29.000]  Вот мы хотим, чтобы у нас для наших данных, для нашего лога в Логдевайсе
[01:08:29.000 --> 01:08:37.000]  реплики были в трех зонах, в 9 ДЦ, в 18 копиях.
[01:08:37.000 --> 01:08:42.000]  И когда мы собираем кворум на запись, ну мы их размазываем, чтобы был страйпинг,
[01:08:42.000 --> 01:08:48.000]  а с другой стороны мы выбираем такой кворум, чтобы в нем было 4 узла как минимум,
[01:08:48.000 --> 01:08:52.000]  из трех зон как минимум и из двух регионов.
[01:08:52.000 --> 01:08:55.000]  И вот если такой кворум собирается, то все.
[01:08:55.000 --> 01:09:00.000]  То есть тут мы не говорим, что мы отправляем данные на все узлы и дожидаемся кворума.
[01:09:00.000 --> 01:09:04.000]  Мы вот именно выбираем под множество, на него отправляем.
[01:09:04.000 --> 01:09:09.000]  За счет этого нагрузка на отдельные реплики снижается, и при этом мы переживаем отказ
[01:09:09.000 --> 01:09:14.000]  трех узлов двух зон доступности одного региона целиком.
[01:09:14.000 --> 01:09:29.000]  Ну как? Понятно? Вот такие системы кворумов.
[01:09:29.000 --> 01:09:31.000]  Тут можно, конечно, совершенно дикие варианты изобретать.
[01:09:31.000 --> 01:09:38.000]  Я просто показываю, что в продакшене люди используют.
[01:09:38.000 --> 01:09:40.000]  Окей, идем дальше.
[01:09:40.000 --> 01:09:44.000]  Что нас еще беспокоит с точки зрения производительности, с точки зрения масштабируемости?
[01:09:44.000 --> 01:09:49.000]  Ну у нас есть совершенно тупое место, совершенно тупое узкое место, которое нужно сразу же пооптимизировать,
[01:09:49.000 --> 01:09:54.000]  а мы этого не делаем. Вот есть лидер. К нему приходят клиенты все.
[01:09:54.000 --> 01:09:59.000]  И лидер для каждой команды запускает свой консенсус.
[01:09:59.000 --> 01:10:02.000]  Свои фазы там проходят. Ну одну фазу, две фазы, неважно.
[01:10:02.000 --> 01:10:05.000]  Для каждой команды у него отдельная запись в логе.
[01:10:05.000 --> 01:10:11.000]  Как это пооптимизировать? Как уменьшить работу на одну команду?
[01:10:11.000 --> 01:10:22.000]  Ну вот нужно, я не знаю, поставить перед клиентами еще слой прокси.
[01:10:22.000 --> 01:10:34.000]  Вот они набирают запросы с клиентов, строят из них пачки и уже их отправляют лидеру.
[01:10:34.000 --> 01:10:41.000]  Вот они накопили за полсекунды 2000 запросов, упаковали их в одну пачку и отправили.
[01:10:41.000 --> 01:10:46.000]  В итоге у нас вся работа РСМ относительно пачек происходит уже.
[01:10:46.000 --> 01:10:52.000]  То есть на уровне автомата это все распаковывается в отдельные команды, но вся промежуточная деятельность,
[01:10:52.000 --> 01:10:59.000]  то есть мы не делаем тысячу фаз, мы не делаем тысячу аксептов, мы делаем один аксепт для пачки.
[01:10:59.000 --> 01:11:04.000]  Вот это такая была наивная оптимизация.
[01:11:04.000 --> 01:11:19.000]  Что? Сколько не жалко? Ну f плюс один, по крайней мере.
[01:11:19.000 --> 01:11:25.000]  Что? Ну это такое естественное место, чтобы, не знаю, отделить одно от другого.
[01:11:25.000 --> 01:11:33.000]  Просто лидер занимается массой вещей. Он бачит команды, он выкладывает их в лог, он собирает кворумы.
[01:11:33.000 --> 01:11:40.000]  Вот все это можно разнести. Скажем, вот собирать кворумы тоже можно делегировать работой кому-то,
[01:11:40.000 --> 01:11:44.000]  потому что как бы кворумы в разных фактах собираются независимо, поэтому можно было бы...
[01:11:44.000 --> 01:11:50.000]  Ну это уже такая странная оптимизация, она в академических статьях есть, а в продакшене я не слышал, чтобы вот прямо так делали.
[01:11:50.000 --> 01:11:56.000]  Но есть оптимизация суперважная, которую необходимо делать. И про нее я тоже когда-то рассказывал уже.
[01:11:56.000 --> 01:12:00.000]  Должен был. Итак, вы лидер, вы получаете команды.
[01:12:00.000 --> 01:12:05.000]  И я говорил, что вот на уровне мультипакса или рафта вы не знаете, что это за команды.
[01:12:05.000 --> 01:12:09.000]  Вы просто их упорядочиваете, кормите ими, стоит машина, она дальше уже реагирует на них.
[01:12:09.000 --> 01:12:14.000]  Вот кое-что полезно было бы знать. Полезно было бы различать...
[01:12:19.000 --> 01:12:26.000]  Полезно было бы различать команды, которые изменяют состояние, которые не изменяют состояние автомата.
[01:12:26.000 --> 01:12:36.000]  Как бы это вам помогло?
[01:12:36.000 --> 01:12:46.000]  Совсем наивно. Вы сервис-блокер, киволю хранилища, и вам сыпется операция пута и гета.
[01:12:46.000 --> 01:12:50.000]  И гетов у вас в сто раз больше, чем путов. Ну так жизнь устроена.
[01:12:50.000 --> 01:12:55.000]  А вы, тем не менее, и эти геты не меняют состояние автомата.
[01:12:55.000 --> 01:12:59.000]  А вы все все равно проплетите через лог, через RSM.
[01:12:59.000 --> 01:13:02.000]  Вот может быть, можно быстрее делать, раз они не меняют состояние.
[01:13:02.000 --> 01:13:07.000]  Вот можно ли просто прочесть текущее состояние с реплики и ответить клиенту сразу?
[01:13:07.000 --> 01:13:11.000]  У нас же есть копия киволю хранилища, ну там какого-то кусочка его таблито.
[01:13:11.000 --> 01:13:18.000]  Вот читаем сразу локальные значения и отдаем пользователю.
[01:13:18.000 --> 01:13:21.000]  Но это, конечно, работать не будет, потому что у вас реплики могут отставать,
[01:13:21.000 --> 01:13:23.000]  у них могут быть пустые логи, по крайней мере, в мультипаксесе.
[01:13:23.000 --> 01:13:27.000]  Если они будут отвечать на чтение, то будет странно.
[01:13:27.000 --> 01:13:39.000]  Это называется stale read. Устаревшее, протухшее чтение. Мы такого не хотим.
[01:13:39.000 --> 01:13:43.000]  Вот, следующая идея. Давайте пусть лидер отвечает на чтение.
[01:13:43.000 --> 01:13:48.000]  Он-то точно знает, что происходит? Почему это не работает?
[01:13:48.000 --> 01:13:53.000]  У него такая нагрузка и была.
[01:13:53.000 --> 01:13:57.000]  Это что же еще? Я говорю, чтобы вместо того, чтобы команду в лог запускать,
[01:13:57.000 --> 01:14:03.000]  я просто прочту без лога. Нагрузки меньше станет. Это моя цель.
[01:14:03.000 --> 01:14:13.000]  Я же увеличиваю пропуску способности системы. Будет ли это работать?
[01:14:13.000 --> 01:14:17.000]  Это супер понятно звучит. Ты лидер, у тебя есть полная история,
[01:14:17.000 --> 01:14:24.000]  ты получаешь чтение, локально его обслуживаешь, возвращаешь сразу.
[01:14:24.000 --> 01:14:29.000]  Дело не в том, что лидер будет жить или нет, а дело в том, что он думает,
[01:14:29.000 --> 01:14:34.000]  что он лидер, но у других может быть другое мнение по этому поводу.
[01:14:34.000 --> 01:14:38.000]  То есть ты в multiplex выиграешь себя как избрался сам лидером,
[01:14:38.000 --> 01:14:42.000]  потому что у тебя самый старший ID. Но ты просто в маленькой части partition находишься,
[01:14:42.000 --> 01:14:45.000]  а в апдейтах не знаешь, они к тебе не попадают.
[01:14:45.000 --> 01:14:49.000]  Думаешь, что лидер, а в другой половине кластера в большей части,
[01:14:49.000 --> 01:14:53.000]  уже новый апдейт копится. И ты их не учитываешь, когда отвечаешь.
[01:14:53.000 --> 01:14:59.000]  Ну понятно, что у вас тут три реплики, вот partition, и вот здесь лидер новый,
[01:14:59.000 --> 01:15:05.000]  здесь лидер все еще старый, а все запросы ходят сюда,
[01:15:05.000 --> 01:15:12.000]  и все мутации происходят здесь. А вы здесь без общения с другими отвечаете сразу клиенту.
[01:15:12.000 --> 01:15:22.000]  Как это подчинить?
[01:15:22.000 --> 01:15:29.000]  Мы даже про это сегодня говорили в контексте RAFTA.
[01:15:29.000 --> 01:15:33.000]  Ну так придумай.
[01:15:33.000 --> 01:15:37.000]  Ты можешь быть уже не лидером, думать, что ты лидером,
[01:15:37.000 --> 01:15:43.000]  но не важно, для multipax, для RAFTA все равно одно и то же.
[01:15:43.000 --> 01:15:51.000]  Вот у тебя есть какой-то лог у тебя, у лидера.
[01:15:51.000 --> 01:15:59.000]  Вот если он полный, то все хорошо, безопасно ответите на чтение без консенсуса.
[01:15:59.000 --> 01:16:03.000]  Но может быть, у тебя в системе есть новый лидер, у него лог уже более полный,
[01:16:03.000 --> 01:16:08.000]  он больше того накомитил. Ну давайте опросим Quorum.
[01:16:08.000 --> 01:16:13.000]  Если у нас есть альтернативный лидер, который успел закомитить что-то еще,
[01:16:13.000 --> 01:16:22.000]  то мы с его Quorum на запись пересечемся, и от реплики в пересечение узнаем, что мы отстали.
[01:16:22.000 --> 01:16:29.000]  Понятная идея, да? В случае RAFTA мы можем просто опросить Quorum и узнать,
[01:16:29.000 --> 01:16:35.000]  верно ли, что есть Quorum с нашим термом. Если Quorum с нашим термом не набирается,
[01:16:35.000 --> 01:16:41.000]  значит, видимо, кто-то ушел вперед уже, есть новый лидер, он что-то успел закомитить.
[01:16:41.000 --> 01:16:45.000]  Но вот это все все равно выполняется на лидере.
[01:16:45.000 --> 01:16:49.000]  Но вот эту идею можно вынести на все остальные реплики.
[01:16:49.000 --> 01:16:54.000]  То есть размазать чтение не только... все записи, например, RAFTA проходят через лидера,
[01:16:54.000 --> 01:16:59.000]  это неизбежно. А вот чтение можно размазать по остальным узлам.
[01:16:59.000 --> 01:17:04.000]  И это, конечно, сильно лидеру поможет. Как это сделать?
[01:17:04.000 --> 01:17:12.000]  У вас есть реплика, у нее есть какой-то лог, но не то чтобы полный.
[01:17:12.000 --> 01:17:19.000]  Она возьмет и опросит Quorum и узнает старший индекс, который в логах Quorum есть.
[01:17:19.000 --> 01:17:23.000]  Но не факт, что все команды закоммитчены. Может быть, какие-то закоммитчены,
[01:17:23.000 --> 01:17:29.000]  какие-то только будут закоммитчены. Но безопасно... вот этот старший индекс вот здесь.
[01:17:29.000 --> 01:17:38.000]  Вот безопасно узнать этот старший индекс, а потом подождать, пока до него все не закоммитится.
[01:17:38.000 --> 01:17:45.000]  Тогда мы учтем все завершенные к моменту запросы команды и часть команд, которые с нами конкурировали.
[01:17:45.000 --> 01:17:50.000]  То есть так или иначе чтение линейризуется относительно других записей.
[01:17:50.000 --> 01:17:56.000]  Так что мы опрашиваем Quorum и ждем. Но причем, разумеется, это можно делать сразу для пачки команд.
[01:17:56.000 --> 01:18:04.000]  То есть мы получили тысячу чтений, опросили один раз Quorum, узнали, что самый длинный лог на 300 дальше чем наш,
[01:18:04.000 --> 01:18:10.000]  подождали, пока 300 заполнится, и после этого ответили сразу на тысячу запросов.
[01:18:16.000 --> 01:18:22.000]  Вот так можно разгрузить лидера на чтение. А можно сделать еще лучше.
[01:18:22.000 --> 01:18:29.000]  Потому что... сделать еще лучше в том смысле, что избавиться от этого Quorum.
[01:18:29.000 --> 01:18:32.000]  То есть вообще ни с кем не общаться и при этом отвечать.
[01:18:36.000 --> 01:18:40.000]  Но мы так уже делали, ни с кем не общаться и что-то делать при этом в True Time.
[01:18:40.000 --> 01:18:45.000]  То есть мы время задействовали. Вот мы сейчас делаем то же самое.
[01:18:45.000 --> 01:18:52.000]  Смотрите, вы лидер в эпохе там, не знаю, три, в терме три.
[01:18:54.000 --> 01:19:00.000]  И вот вы были бы рады отвечать на запросы на чтение без коммуникации с другими узлами.
[01:19:00.000 --> 01:19:07.000]  Но вы так не можете делать, потому что в терме вы единственный в RAF, но может уже начаться новый терм
[01:19:07.000 --> 01:19:14.000]  и с вами конкурировать во времени. Давайте сделаем так, что устроим такую процедуру,
[01:19:14.000 --> 01:19:18.000]  чтобы гарантировать, что лидеры не могут пересекаться во времени.
[01:19:21.000 --> 01:19:25.000]  Если мы это гарантируем, то можно будет отвечать на чтение сразу, локально, ни с кем не общаясь.
[01:19:29.000 --> 01:19:34.000]  Вот я сегодня писал уже слово Лиза. Вот мы сейчас построим Лизу.
[01:19:37.000 --> 01:19:42.000]  Это речь про лидера. У лидера полный лог, у него может быть не полный лог,
[01:19:42.000 --> 01:19:47.000]  только потому что появился уже новый лидер. Вот если мы разобьем их во времени, то все будет хорошо.
[01:19:47.000 --> 01:19:51.000]  Итак, мы стали лидером.
[01:19:59.000 --> 01:20:05.000]  Что надо делать дальше? Мы не хотим, чтобы с нами кто-то пересекался во времени.
[01:20:05.000 --> 01:20:10.000]  Поэтому давайте мы попросим всех остальных реплик.
[01:20:12.000 --> 01:20:15.000]  Скажем, пожалуйста, не голосуйте,
[01:20:23.000 --> 01:20:27.000]  не голосуйте, пожалуйста, со других лидеров в течение времени дельта.
[01:20:27.000 --> 01:20:31.000]  Ну и, допустим, мы собрали к ворам подтверждения.
[01:20:31.000 --> 01:20:35.000]  Одного хватит, потому что мы сами себе тоже верим.
[01:20:39.000 --> 01:20:47.000]  И вот реплика R3 и R1, если они дали подтверждения свои, то они в течение некоторого времени дельта
[01:20:50.000 --> 01:20:54.000]  в новых выборах не участвуют.
[01:20:54.000 --> 01:21:00.000]  Вот дельта – это как бы зазор, когда мы можем быть спокойны, что конкурентов у нас не будет.
[01:21:00.000 --> 01:21:04.000]  Правда, дельта вот здесь отчитывается от этого момента времени.
[01:21:04.000 --> 01:21:11.000]  Здесь был T0 какой-то, здесь T1, T2. Вот мы эти T1, T2 не знаем.
[01:21:11.000 --> 01:21:15.000]  Но мы знаем, что T0 не больше, чем T1 в любом случае.
[01:21:15.000 --> 01:21:22.000]  Поэтому мы у себя дельта отчитываем от отправки нашего сообщения.
[01:21:23.000 --> 01:21:30.000]  И вот от этого момента вот до этого момента мы точно можем обслуживать чтение локально,
[01:21:30.000 --> 01:21:36.000]  ни с кем не общаясь, потому что мы уверены, что вот до этого момента точно другие реплики
[01:21:36.000 --> 01:21:40.000]  не могут участвовать в выборах, отдавать голоса и выбирать нового лидера.
[01:21:45.000 --> 01:21:51.000]  Мы сейчас говорим скорее про RAFT, но про Paxos тут нужно какие-то еще пары замечаний сделать, я ренюсь.
[01:21:51.000 --> 01:21:56.000]  Давайте про RAFT. Какие выбирать дельта?
[01:22:03.000 --> 01:22:12.000]  Ну, сейчас, большие, Grand Lease, маленькие выбирать плохо, потому что мы же хотим надолго
[01:22:12.000 --> 01:22:18.000]  получить уверенность в том, что с нами не конкурируют, а большие выбирать плохо,
[01:22:18.000 --> 01:22:22.000]  потому что если мы вдруг умрем, то мы заблокируем систему надолго.
[01:22:22.000 --> 01:22:29.000]  Поэтому мы выбираем небольшое дельта, но когда время подходит, мы просто обновляем свою ризу.
[01:22:48.000 --> 01:22:57.000]  Ну, то есть мы сказали, мы еще живы, мы еще живы, мы еще живы, пожалуйста, сохраняй обещание.
[01:22:57.000 --> 01:23:03.000]  То есть если мы вдруг перестанем это, то есть дельта небольшая, если мы вдруг умрем
[01:23:03.000 --> 01:23:08.000]  и перестанем эти ринью отправлять, то реплика понимает, что, видимо, все, нас нет,
[01:23:08.000 --> 01:23:13.000]  и можно про обещание забыть спустя дельта. И вот этот период будет небольшой,
[01:23:13.000 --> 01:23:18.000]  то есть мы подвисим систему ненадолго, потому что пока эта дельта живет, у нас система не может
[01:23:18.000 --> 01:23:25.000]  восстановиться после сбоя узла. Но все-таки нам хочется, мы же лидер стабильный,
[01:23:25.000 --> 01:23:30.000]  мы надолго выбрались в RAFT на неделю, и вот мы хотим, чтобы всю неделю мы могли обслуживать
[01:23:30.000 --> 01:23:39.000]  чтение без коммуникации с другими. Понятно? Вот, что здесь может не работать?
[01:23:40.000 --> 01:23:44.000]  Но мы здесь используем время, время это опасно довольно.
[01:23:44.000 --> 01:23:47.000]  Вот какие предположения о времени мы сейчас делаем?
[01:23:51.000 --> 01:23:54.000]  Где это мы делаем такое предположение?
[01:23:58.000 --> 01:24:05.000]  Сейчас, ну, t1 больше, чем t0, не меньше, чем t0 по причинам хода времени, что найдет вперед.
[01:24:05.000 --> 01:24:13.000]  Да, но мы это точно уверены, в смысле, t1 и t0 это время абсолютное, его никто не знает,
[01:24:13.000 --> 01:24:19.000]  но это неважно. Где ты здесь сравниваешь t0 и t1? Сравниваешь где-то?
[01:24:22.000 --> 01:24:27.000]  Ты не сравниваешь, что надо делать, только заводишь локальный таймер на время дельта,
[01:24:27.000 --> 01:24:31.000]  и твоя задача – успеть отправить renew и получить ответ до того, как этот таймер растечет.
[01:24:31.000 --> 01:24:37.000]  Время раунд-tрипа, конечно, меньше, да, это больше, чем время раунд-tрипа,
[01:24:37.000 --> 01:24:40.000]  чтобы запас, чтобы не протухал часто.
[01:24:42.000 --> 01:24:45.000]  Вот время идет с одинаковой скоростью, то есть часы не дрейфуют.
[01:24:45.000 --> 01:24:48.000]  А что будет, если они, например, вот здесь будут спешить?
[01:24:49.000 --> 01:24:54.000]  То мы откажемся от обещания раньше, чем, то есть лидер этот будет думать,
[01:24:54.000 --> 01:24:57.000]  что обещание все еще в стиле, а мы от него отказались уже.
[01:24:57.000 --> 01:25:02.000]  Если здесь часы будут замедленно идти, то получается, что будем ждать дольше, чем нужно.
[01:25:02.000 --> 01:25:07.000]  Поэтому мы берем вот этот ro, который был, значит, миллионные доли,
[01:25:07.000 --> 01:25:11.000]  в которых часы могут торопиться или опаздывать, и здесь мы, получается,
[01:25:11.000 --> 01:25:14.000]  интервал немножко увеличиваем.
[01:25:16.000 --> 01:25:18.000]  Время ожидания увеличиваем.
[01:25:19.000 --> 01:25:22.000]  А здесь мы локально его пессимизируем.
[01:25:27.000 --> 01:25:29.000]  Х, это умножить, да.
[01:25:35.000 --> 01:25:38.000]  Ну вот, и тогда все должно быть хорошо.
[01:25:42.000 --> 01:25:44.000]  Покажу вам...
[01:25:47.000 --> 01:25:51.000]  Я вам не рассказывал про Джепсон, совершенно напрасно, но еще повод представиться.
[01:25:51.000 --> 01:25:56.000]  Есть человек, его зовут Карл Кингсбри, он занимается тем, что ломает базы данных.
[01:25:58.000 --> 01:26:03.000]  Ну, в смысле, это его хобби, но работа его, которая, кажется, началась с хобби.
[01:26:09.000 --> 01:26:12.000]  Я вам уже показывал этот сайт на самом деле.
[01:26:17.000 --> 01:26:22.000]  Здесь была диаграмма модели согласованности, помните ее?
[01:26:22.000 --> 01:26:28.000]  Вот, он тестирует промышленные базы данных чаще всего, кучу систем.
[01:26:30.000 --> 01:26:33.000]  То есть он тестирует их на выполнение модели согласованности.
[01:26:33.000 --> 01:26:35.000]  То есть ему говорят, система линеризуемая.
[01:26:35.000 --> 01:26:39.000]  В буклете рекламной написано, он берет и начинает задавать запросы,
[01:26:39.000 --> 01:26:43.000]  при этом ломая сеть, ломая узлы, ломая часы, и проверяет, верно ли,
[01:26:43.000 --> 01:26:46.000]  что во всех исполнениях она будет линеризуемой.
[01:26:46.000 --> 01:26:48.000]  И вот у него есть...
[01:26:48.000 --> 01:26:52.000]  Ну, кстати, это смешно, потому что я сегодня про ETCD уже упоминал.
[01:26:59.000 --> 01:27:06.000]  Ну, в смысле, он берет виртуальные машины, начинает между ними настраивать кучу униксовых футилит,
[01:27:06.000 --> 01:27:08.000]  которые позволяют себе сеть настраивать.
[01:27:08.000 --> 01:27:14.000]  Но он делает это прям с кодом и с настоящим всем этим секундом.
[01:27:14.000 --> 01:27:20.000]  Вот я вам показывал уже про ETCD сегодня, про то, что из-за этой системы возник доунтайм на 6 часов,
[01:27:20.000 --> 01:27:24.000]  из-за того, что сеть поломалась, и Рафт к этому был не готов.
[01:27:24.000 --> 01:27:27.000]  Вторая история про ETCD, но это случайно получилось на...
[01:27:34.000 --> 01:27:36.000]  Вот, вторая история.
[01:27:36.000 --> 01:27:43.000]  Он говорит, что он запустил систему, ну, в смысле, запустил тест и получил нелинеризуемое исполнение.
[01:27:43.000 --> 01:27:45.000]  И дело оказалось...
[01:27:46.000 --> 01:27:48.000]  И он написал об этом разработчикам.
[01:27:48.000 --> 01:27:50.000]  Мне кажется, даже выяснил, в чем дело было.
[01:27:50.000 --> 01:27:52.000]  Он написал разработчикам, и они сделали патч.
[01:27:52.000 --> 01:27:54.000]  И этот патч его то ли взбесил, то ли насмешил.
[01:27:54.000 --> 01:27:56.000]  Вот патч выглядел так.
[01:27:56.000 --> 01:27:58.000]  Сейчас найду его.
[01:28:04.000 --> 01:28:06.000]  Сейчас тут видно название коммита, да?
[01:28:06.000 --> 01:28:10.000]  Ну, вот как бы изменилось это дельта, и вот система стала проходить тест.
[01:28:10.000 --> 01:28:16.000]  Но это, конечно, не является надежным фиксом этой проблемы.
[01:28:16.000 --> 01:28:18.000]  Смотрите.
[01:28:22.000 --> 01:28:24.000]  Какова здесь мораль?
[01:28:24.000 --> 01:28:27.000]  Мораль в том, что вы здесь, используя время,
[01:28:27.000 --> 01:28:32.000]  подвергаете угрозе нелинеризуемой своей системы.
[01:28:32.000 --> 01:28:34.000]  Если вдруг у вас действительно вот эти...
[01:28:34.000 --> 01:28:38.000]  Ну, где-то что-то будет быстрее и медленнее,
[01:28:38.000 --> 01:28:41.000]  вы можете ответить на запрос локальным чтением,
[01:28:41.000 --> 01:28:43.000]  а при этом вы уже можете быть нелидером,
[01:28:43.000 --> 01:28:45.000]  и чтение станет старым.
[01:28:47.000 --> 01:28:52.000]  Так что вы здесь безопасность рафта нарушаете, вмешиваясь в его протокол упорядочивания команд.
[01:28:54.000 --> 01:28:57.000]  Так что автор советует отключить эту опцию.
[01:28:57.000 --> 01:29:00.000]  То есть ее не нужно отключать, конечно.
[01:29:00.000 --> 01:29:04.000]  Она для масштабируемости важна, для пропуску способности.
[01:29:04.000 --> 01:29:07.000]  Но, тем не менее, вы должны что-то выключивать здесь с запасом.
[01:29:07.000 --> 01:29:09.000]  И у вас страйдов такой.
[01:29:09.000 --> 01:29:13.000]  Либо время паузы при смерти узла, либо линеризуемость.
[01:29:17.000 --> 01:29:19.000]  Ладно, последнее, что я расскажу,
[01:29:19.000 --> 01:29:22.000]  не расскажу даже просто коротко, за 5 минут.
[01:29:23.000 --> 01:29:27.000]  Что еще можно пооптимизировать в мультипаксисе или в рафте?
[01:29:27.000 --> 01:29:29.000]  Ну, что мы сделали?
[01:29:29.000 --> 01:29:31.000]  Мы здесь устроили страйпинг на аксепторах.
[01:29:31.000 --> 01:29:36.000]  Мы здесь сделали бачен для того, чтобы просто на одну команду было меньше работы.
[01:29:36.000 --> 01:29:39.000]  Мы поэкономили на чтениях.
[01:29:40.000 --> 01:29:44.000]  Но еще есть одна функция, которая вот плохо масштабируется.
[01:29:44.000 --> 01:29:46.000]  Это упорядочивание команд.
[01:29:46.000 --> 01:29:49.000]  Вот все равно у вас есть лидер, который принимает все команды
[01:29:49.000 --> 01:29:51.000]  и выкладывает их подряд в лог.
[01:29:51.000 --> 01:29:53.000]  И это выглядит почти неизбежно.
[01:29:53.000 --> 01:29:56.000]  И вот то, что у вас лидер один, через него все проходит,
[01:29:56.000 --> 01:30:00.000]  является особенно печально, когда у вас система геораспределенная.
[01:30:01.000 --> 01:30:05.000]  Вот пусть у вас есть три реплики в Северной Америке,
[01:30:05.000 --> 01:30:07.000]  в Европе и где-нибудь еще далеко.
[01:30:07.000 --> 01:30:10.000]  Восточном, Западном побережье в Европе.
[01:30:10.000 --> 01:30:12.000]  Вот далекие машины.
[01:30:13.000 --> 01:30:15.000]  Свет долго идет.
[01:30:15.000 --> 01:30:18.000]  Почему вам от RSM плохо?
[01:30:19.000 --> 01:30:22.000]  С одной стороны, мы пооптимизировали фазу в мультипаксисе.
[01:30:22.000 --> 01:30:25.000]  Ну или в рафте просто всегда одна фаза в репликации.
[01:30:25.000 --> 01:30:27.000]  В мультипаксисе почти всегда одна фаза.
[01:30:27.000 --> 01:30:37.000]  Но у вас же относительно лидера одна фаза.
[01:30:37.000 --> 01:30:41.000]  Но с другой стороны, вам нужно сначала на лидера команду принести.
[01:30:41.000 --> 01:30:45.000]  То есть у вас один раунд трип от клиента до лидера
[01:30:45.000 --> 01:30:47.000]  и один раунд трип кворумный.
[01:30:47.000 --> 01:30:49.000]  От лидера до реплик.
[01:30:49.000 --> 01:30:54.000]  И вот то, что у вас кворум собирается в геораспределенной системе, это неминуемо.
[01:30:54.000 --> 01:30:57.000]  Но плохо здесь то, что вы клиент, находитесь в Европе,
[01:30:57.000 --> 01:30:59.000]  а лидер сейчас находится в Штатах.
[01:30:59.000 --> 01:31:02.000]  И вы просто чтобы прислать ему команду должны отправиться сначала туда,
[01:31:02.000 --> 01:31:04.000]  а потом еще раз обратно.
[01:31:04.000 --> 01:31:07.000]  А потом еще раз обратно, чтобы ответ получить.
[01:31:07.000 --> 01:31:11.000]  То есть вы делаете два раунд трипа через Атлантику.
[01:31:11.000 --> 01:31:16.000]  Так вот, есть подходы в вариации мультипаксиса,
[01:31:16.000 --> 01:31:21.000]  где строится не линейный порядок на командах, а частичный порядок на командах.
[01:31:21.000 --> 01:31:23.000]  И система становится симметричной в том смысле,
[01:31:23.000 --> 01:31:26.000]  что у вас все пропозеры могут выстраивать часть своего порядка.
[01:31:26.000 --> 01:31:34.000]  И в итоге, если все идет хорошо, то вы делаете только один раунд трип через Атлантику, а не два.
[01:31:34.000 --> 01:31:38.000]  То есть вы ходите к своей близкой машине и не ходите далеко.
[01:31:38.000 --> 01:31:45.000]  Ну вот, в общем, ровно поэтому в мультипаксисе 100 статей было на странице, я вам показывал в прошлый раз.
[01:31:45.000 --> 01:31:49.000]  Потому что вот каждое место можно потюнить более-менее.
[01:31:49.000 --> 01:31:53.000]  Ну в RAFT все же, в RAFT так делать не стоит,
[01:31:53.000 --> 01:32:00.000]  но потому что вы видели, даже переконфигурации нельзя потюнить, там можно что-то сломать.
[01:32:00.000 --> 01:32:05.000]  Ну в меньшей степени свободы.
[01:32:05.000 --> 01:32:10.000]  Ну что ж, наверное, это все, что у меня поместилось сегодня.
[01:32:10.000 --> 01:32:17.000]  Но я не рассказал вам до конца историю, потому что RSM, RSM еще кое-чего не хватает.
[01:32:17.000 --> 01:32:21.000]  Это я вам рассказывал в следующего семинара, наверное.
[01:32:21.000 --> 01:32:24.000]  Вот у вас RSM держит лог.
[01:32:24.000 --> 01:32:27.000]  И он растет, растет, растет. Что делать, если он переполнится?
[01:32:27.000 --> 01:32:29.000]  В смысле, он растет бесконечно.
[01:32:29.000 --> 01:32:31.000]  Что делать, если у вас машина перезагрузится?
[01:32:31.000 --> 01:32:36.000]  Что, историю заметить накатывать на себя, что ли?
[01:32:36.000 --> 01:32:42.000]  Или просто у вас лог слишком большой, но он не помещается уже в одну машину, нужно что-то с ним делать.
[01:32:42.000 --> 01:32:46.000]  Ну вот, мы не поговорили про то, как этот лог сокращать, как делать снапшоты,
[01:32:46.000 --> 01:32:48.000]  как вообще работать с диском надежно.
[01:32:48.000 --> 01:32:52.000]  Ну вот в следующий раз мы об этом и поговорим, наверное.
[01:32:52.000 --> 01:32:54.000]  Про то, что файлы это сложно.
[01:32:54.000 --> 01:32:56.000]  Файловая система это сложно. Если вы хотите сделать это надежно,
[01:32:56.000 --> 01:33:00.000]  это сложно не только потому, что машины отказывают,
[01:33:00.000 --> 01:33:03.000]  а потому что еще файловая система работает очень странно.
[01:33:03.000 --> 01:33:05.000]  Не так вы от нее ожидаете.
[01:33:05.000 --> 01:33:07.000]  Ну на сегодня все, спасибо.
