[00:00.000 --> 00:12.880]  Ну хорошо, наверное, нужно начинать. У нас сегодня начинается последняя, третья часть.
[00:12.880 --> 00:22.840]  И мы будем обсуждать вопросы, связанные с алгоритмами. Алгоритмы, как мы выясним, тесно
[00:22.840 --> 00:32.360]  связаны с логикой. И мы получим в конце совершенно неожиданное следствие для такой
[00:32.360 --> 00:40.680]  классической логики, что для некоторых моделей не существует удобной эксиоматики. Удобной в том
[00:40.680 --> 00:48.280]  смысле, что она разумна, нужно уточнить, что это такое, и полна. Но до этого нужно разобраться
[00:48.280 --> 00:54.120]  вообще с тем, что такое алгоритмы. Вы, конечно, с алгоритмами имеете дело постоянно, все-таки вы
[00:54.120 --> 01:00.320]  учитесь на таком факультете. У вас и курс был введение алгоритмы, и у нас в курсе алгоритмы
[01:00.320 --> 01:08.680]  встречались. Но в чем особенность того, что я буду рассказывать? Нас будет интересовать, прежде
[01:08.680 --> 01:15.000]  все, принципиальный вопрос. Существуют алгоритмы-то какие-то задачи или не существуют? То есть не то,
[01:15.000 --> 01:20.960]  что мы хотим алгоритмом получше или что-то, а вот есть вообще он или нет. Выяснится, что не для
[01:20.960 --> 01:27.240]  всех задачей это алгоритм. И тут возникает такая сложность. Что такое алгоритм неформально? Ну,
[01:27.240 --> 01:35.320]  это инструкция, которая состоит из точно описанного порядка исполнения простых действий. Простых в том
[01:35.320 --> 01:41.280]  смысле, что их можно исполнить, ну, без всякой фантазии, воображения, просто абсолютно механическим
[01:41.280 --> 01:46.880]  образом. Другими словами, можно себе представить, что алгоритм — это программа для идеализированного
[01:46.880 --> 01:52.280]  компьютера. Почему идеализированного? Когда мы говорим об алгоритме, у нас нет ограничений на
[01:52.280 --> 01:58.240]  ресурсы. Алгоритм может работать неограниченно долго, использовать сколько угодно памяти,
[01:58.240 --> 02:05.560]  лишь бы конечное число. То есть мы не смотрим, затем может ли это поместиться в какие-то реальные
[02:06.160 --> 02:11.440]  устройства. В этом смысле идеализировано. А так это абсолютно программа. Если вы представите себе
[02:11.440 --> 02:16.440]  программу в каком-то языке программирования, но только забудете о том, что есть ограничение на
[02:16.440 --> 02:23.160]  размеры данных и так далее, то у вас получится одно из возможных уточнений понятия алгоритма.
[02:23.160 --> 02:31.880]  И такое неформальное понимание достаточно, пока мы рассматриваем примеры алгоритма. Я привел
[02:31.880 --> 02:37.120]  пример алгоритма. Вы посмотрели — ну да, вот все шаги достаточно простые, ясно, что каждый
[02:37.120 --> 02:43.000]  можно запрограммировать, ничего там сложного нет. Но если мы хотим доказать, что для какой-то
[02:43.000 --> 02:49.480]  конкретной задачи нет алгоритма, такого подхода недостаточно. Нам нужны какие-то определения,
[02:49.480 --> 02:53.680]  потому как доказать, что чего-то нет, если у нас нет определений, тогда не будет математически
[02:53.680 --> 03:00.760]  утверждено. Поэтому рано или поздно нам потребуются формальные модели вычислений, которые описывают
[03:00.760 --> 03:11.240]  все алгоритмы. Это можно сделать очень многими способами. И основная беда со всеми этими
[03:11.240 --> 03:16.960]  точными определениями алгоритма состоит в том, что они очень громоздкие. Если использованы
[03:16.960 --> 03:22.000]  такое определение, достаточно трудно доказывать очень простые вещи. Какое-то простое действие,
[03:22.000 --> 03:27.800]  которое мы привыкли считать, что ничего сложного в нем нет. Скажем, разбить память на зоны и в каждой
[03:27.800 --> 03:34.960]  зоне, выполнять какие-то свои действия, то есть запускать программы, которые, какая-то дополнительная
[03:34.960 --> 03:40.200]  программа переключается между ними. Идей на это очень понятная вещь, а большинстве моделей
[03:40.200 --> 03:45.000]  вычислений это не так легко организовать и доказать корректность соответствующих процедур. Хотя,
[03:45.000 --> 03:52.840]  конечно, возможно. Поэтому я предпочту, как уже несколько лет я это делаю, другой подход. Давайте
[03:52.840 --> 03:58.480]  начнем с того, что вообще поймем основную структуру вопросов и понятия теории алгоритма,
[03:58.480 --> 04:03.720]  не используя точного понятия определения алгоритма. Вот, ограничиваясь вот таким
[04:03.720 --> 04:08.320]  неформальным, наивным представлением, что алгоритм — это инструкция, и представлением,
[04:08.320 --> 04:18.400]  что какие-то действия мы способны выполнить с помощью алгоритма. И после того, как у нас возникнет
[04:18.400 --> 04:23.680]  эта общая картина, уже будем обсуждать, какая нам нужна точная модель. Это в следующий раз
[04:23.680 --> 04:29.800]  я буду делать, что нам от нее нужно. И, конечно, у меня появится точное определение, здесь зафиксирую,
[04:29.800 --> 04:36.360]  что такое алгоритм. И придется потратить не так мало времени на то, чтобы убедиться, что такая
[04:36.360 --> 04:42.840]  простая модель отвечает нашему интуитивному представлению об алгоритме. А сейчас давайте
[04:42.920 --> 04:49.680]  считать, что алгоритм — это, как я сказал, просто какая-то инструкция, достаточно точно описанная,
[04:49.680 --> 04:56.520]  все шаги достаточно простые, чтобы мы могли исполнять компьютер. Что нам будет нужно? Прежде
[04:56.520 --> 05:02.880]  всего, алгоритмы бывают очень разные. Ну, в каком-то смысле операционная система — это тоже алгоритмы,
[05:02.880 --> 05:08.000]  вы понимаете, что она выполняет какие-то очень сложные задачи, потому что она запускает процессы,
[05:08.000 --> 05:13.600]  останавливает процессы. Такими алгоритмами мы заниматься не будем. Основной для нас класс
[05:13.600 --> 05:26.360]  алгоритмов, не единственный, но основной — это алгоритмы вычисления. Очень часто в книжках прямо
[05:26.360 --> 05:34.520]  пишут алгоритмы, просто говоря об алгоритмах вычисления. Ну, это сейчас не очень точно. Что это такое?
[05:34.640 --> 05:46.000]  Какие-то данные подаются на вход этому алгоритму. Алгоритм работает и дает результат. Или, возможный
[05:46.000 --> 05:53.400]  вариант, не дает никакого результата. Например, входит в бесконечный цикл. Мы будем допускать
[05:53.400 --> 05:58.800]  такую возможность. Если у вас есть опыт реального программирования, я думаю, вас не удивит, что
[05:58.800 --> 06:07.080]  программа может неожиданно не захотеть заканчиваться. Это обычное дело. Поэтому алгоритм,
[06:07.080 --> 06:24.920]  по сути дела, вычисляет частичную функцию из входов в результат. Вообще говоря, частично. Где-то
[06:24.920 --> 06:32.800]  она может быть неожиданно. Это очень важно. Мы увидим, что... Я, может быть, даже не буду
[06:32.800 --> 06:37.520]  доказывать сегодня, но, может быть, чуть позже докажу. Или вы сами как простое упражнение сделаете.
[06:37.520 --> 06:44.000]  Мы увидим, что универсальную модель вычисления невозможно построить, ограничиваясь только тотальной
[06:44.000 --> 06:52.040]  функцией, которая всюду определяется. Нам нужны частичные функции. Это принципиально. Ну, теперь
[06:52.040 --> 07:00.120]  давайте конкретизировать эту картину. Что здесь написано в качестве входов в результат? Варианта
[07:00.120 --> 07:06.600]  много. Самый естественный... Мы имеем дело с реальными компьютерами, потому самое естественное
[07:06.600 --> 07:14.960]  считать, что входа как какой-то файл и выход тоже какой-то файл. Но файл это, по сути дела,
[07:14.960 --> 07:22.200]  двоичное слово. Что такое файл? Ну, двоичное слово в какой-то длине. Он может иметь какую-то структуру,
[07:22.200 --> 07:30.960]  но это неважно. По крайней мере, все равно хранятся нули и единицы. Поэтому можно считать, что это
[07:30.960 --> 07:41.600]  функция из множества двоичных слов до множества двоичных слов. Вот функция вычислимая, если это
[07:41.600 --> 07:52.000]  результат работы некоторого алгоритма. То есть у нас возникает такое базовое понятие для теории
[07:52.000 --> 07:57.440]  алгоритма. Вычислимая функция. Ну, скажем, из двоичных слов двоичные слова. Оказывается, это понятие
[07:57.440 --> 08:02.880]  очень, как бы сказать, грубое. Его можно определять очень по-разному. Будет получаться один и тот же
[08:02.880 --> 08:13.680]  класс функции. Но более того, сами множество входов и результатов тоже можно очень сильно менять.
[08:13.680 --> 08:19.680]  Например, можно рассматривать в качестве входа в натуральные числа и в качестве результатов тоже
[08:19.680 --> 08:25.760]  натуральные числа. Почему? Потому что между двоичными словами и натуральными числами есть очень
[08:25.760 --> 08:30.800]  простое соответствие, даже объекция, которая, очевидно, вычисляется алгоритмом. Ну, вот смотрите,
[08:30.960 --> 08:44.160]  давайте возьмем так вот. Возьмем двоичное слово. Запишем слово, которому слева приписана единица.
[08:44.160 --> 08:52.800]  Возьмем число, которое задается двоичной какой записью и вычтем единичку. Я утверждаю, что это
[08:52.800 --> 09:01.920]  объекция. Скажем, если слово пустое, получится один минус один ноль. Словом из одного нуля будет
[09:01.920 --> 09:07.840]  отвечать, что один ноль это два, минус один это один. Ну и так далее. Проверить, что это объекция очень
[09:07.840 --> 09:16.080]  легко, на самом деле. Потому что мы знаем, что любое число записывается в двоичной системе,
[09:16.080 --> 09:20.520]  конечно, не совсем однозначно. Вот этот трюк с приписыванием единицы и вычитанием единицы,
[09:20.520 --> 09:27.640]  он нужен для однозначно. Чтобы избежать начальных нулей, если мы припишем слева
[09:27.640 --> 09:32.840]  к двоичной записи числа нули, значение числа не изменится. Вот чтобы это убить, я хочу все время
[09:32.840 --> 09:38.520]  начинать с единицы. Вот она нужно будет на единичку уменьшить, потому что, еще раз напомню,
[09:38.520 --> 09:46.680]  давайте единицу 10 напишу. Натуральные числа у меня это целые не отрицательные числа. Я всегда
[09:46.680 --> 09:56.040]  понимаю код вот таким ажурным n целые не отрицательные числа. Ну это не единственное,
[09:56.040 --> 10:05.280]  что можно преобразовать. Я определил функции от одного аргумента. Функция запоставляет входу х,
[10:05.280 --> 10:11.440]  запоставляет результат y или ничего не запоставляет. Но мы знаем, что бывают функции от двух и более
[10:11.440 --> 10:16.200]  аргумента. Давайте я буду говорить для определенности от двух аргументов. Совершенно то же самое можно
[10:16.200 --> 10:24.680]  сказать и для больших числа. Никакой новой общности при этом не возникает. Почему? Потому что пары,
[10:24.680 --> 10:30.080]  скажем, двоичных слов, можно сопоставить тоже алгоритмически вычислимую биекцию с двоичными
[10:30.080 --> 10:36.960]  словами. Еще проще это сделать, если это пары натуральных чисел. Представьте, что x и y это
[10:36.960 --> 10:47.840]  натуральные числа. Как сопоставить такой паре число? Это известный плюк, который многим известен.
[10:47.840 --> 10:58.200]  Нужно перебирать пары по диагональ. Вот так вот. То есть вот это ноль, это один, это два, это три, это четыре, это пять, ну и так
[10:58.200 --> 11:08.680]  далее. Ясно, что это будет биекция. И ясно, что она вычисляется алгоритмически в одну и другую
[11:08.680 --> 11:17.640]  сторону. В общем, если кто-то в этом сомневается, я очень рекомендую написать программу, как уже по паре
[11:17.640 --> 11:24.080]  x и y строит ее номер и по номеру строит пар. И та и другая программа пишется очень легко. То есть вы можете
[11:24.080 --> 11:28.280]  даже не писать на каком-то языке программирование, просто подумать, как это задать алгоритмически.
[11:28.280 --> 11:37.160]  Ничего сложного. Ну и на самом деле из x, из пар в числа, там есть даже простая формула. Многие ее может
[11:37.160 --> 11:43.800]  не знают, но я даже ее не буду приводить. Можете изобрести ее самостоятельно. В общем, я буду все время
[11:43.800 --> 11:49.560]  говорить о функциях одного аргумента, но когда мне будет нужно, я буду рассматривать функцию двух
[11:49.560 --> 11:57.800]  аргументов. Считаю, что я имею в виду, что я из этих двух аргументов делаю номер и потом считаю
[11:57.800 --> 12:06.240]  соответствующую функцию от этого номера. То есть вот такие вот условности и соглашения с тем, чтобы
[12:06.240 --> 12:13.720]  нам проще было жить. Вот двоичная слова более естественная область для входа и результатов
[12:13.720 --> 12:19.800]  работы алгоритма. Но натуральные числа, они в некотором смысле проще. Почему проще? Потому что,
[12:19.800 --> 12:25.440]  ну вы знаете, у нас есть такие простые алгоритмические действия, как, допустим, запустить цикл. Цикл хочется
[12:25.440 --> 12:31.400]  запускать по натуральной перемене, перебирать числа 0, 1, 2. Разумеется, не сложно перебирать двоичные
[12:31.400 --> 12:41.320]  слова, но проще просто сразу подразумевать, что у нас есть вот биекция, которую я описал, и перебирать
[12:41.320 --> 12:45.400]  натуральные числа. Но в каком порядке будет перебираться двоичные слова, вы легко сообразите.
[12:45.400 --> 12:51.160]  Совершенно естественно, если вы начали бы перебирать двоичные слова в каком-то порядке.
[12:51.160 --> 13:00.040]  Вот скорее всего именно такой порядок и придумали. Хорошо. Значит, это такие предварительные замечания,
[13:00.040 --> 13:09.320]  потому что нам надо от чего-то отталкиваться. Идем дальше. Дальше оказывается, что, помимо
[13:09.320 --> 13:14.360]  вычислимых функций, которые действительно базовое понятие, основной этой теории алгоритмов,
[13:14.360 --> 13:30.360]  есть еще важные понятия, относящиеся к множеству. Давайте я сейчас для определенности буду говорить,
[13:30.360 --> 13:35.640]  что у меня двоичные слова. Потом я в какой-то момент перейду на натуральные числа, но я буду
[13:35.640 --> 13:41.800]  свободно менять формат записи алгоритма, потому что вот я потратил какое-то время и объяснил,
[13:41.800 --> 13:50.200]  что еще тут сложного нет. Оказывается, что не менее важны чем вычислимые функции, мы множество
[13:50.200 --> 13:58.040]  с ними связаны. Для этого нам нужны особые алгоритмы, которые называются алгоритмы разрешения.
[13:58.040 --> 14:15.200]  Особенность состоит в том, что эти алгоритмы отображают входы в множество. То есть у этого
[14:15.200 --> 14:24.440]  алгоритма только два возможных результата, 0 и 0. И мы говорим, что множество разрешимо.
[14:24.440 --> 14:43.760]  Вот это очень важное определение. Д разрешимо, если его характеристическая функция вычисли.
[14:43.760 --> 14:52.600]  Давайте я напомню, как определяется характеристическая функция. Она равняется единице
[14:52.600 --> 15:01.360]  для х превращен в д и нулю для остальных. То есть другими словами в более логических терминах,
[15:01.360 --> 15:10.560]  что такое подмножество? Это кумагный предикат на, скажем, двоичных словах. Предикат принимает
[15:10.560 --> 15:16.840]  значение 0 или 1. Если у него один оппонент, он как раз задает подмножество тех двоичных слов,
[15:16.840 --> 15:22.720]  на которых он истинен. И это то же самое, что характеристическая функция. То есть другими
[15:22.720 --> 15:29.040]  словами, на задачу разрешения можно смотреть вот так. У нас задано некоторое множество единиц
[15:29.040 --> 15:33.640]  характеристического множества д. И алгоритм должен ответить на вопрос, принадлежит ли уход
[15:33.640 --> 15:40.160]  этому множеству или нет. И если множество разрешимо, существует алгоритм, который всегда дает ответ.
[15:40.160 --> 15:46.720]  Вот обратите внимание, характеристическая функция всю доопределена. Вообще у нас функции
[15:46.720 --> 15:51.880]  вычислимые могут быть частичными, характеристическая функция всю доопределена. Нам нужен алгоритм,
[15:51.880 --> 15:59.520]  который про любой х заведомо скажет. Принадлежит ли этот х множеству д или нет. Вот в этом случае
[15:59.520 --> 16:05.280]  множество д называется разрешение. И это в каком-то смысле самые простые множества, потому что
[16:05.280 --> 16:13.480]  мы представляем себе это так, что мы можем эффективно проверить какое-то свойство. Ну вот
[16:13.480 --> 16:20.280]  свойство задаваемое этим предикатом или свойство принадлежимости некоторого множества. Ну, например,
[16:20.280 --> 16:36.080]  давайте сразу какие-нибудь примеры из логики рассмотрим. Вот скажем множество тавтологии,
[16:36.080 --> 16:41.800]  разрешимо оно или нет. Тут, конечно, возникает вопрос. Тавтологии это формула, то есть это слова
[16:41.800 --> 16:49.920]  вообще в бесконечном алкоголике. А у меня я определил разрешимое множество для двоичных
[16:49.920 --> 16:57.320]  слов или для слов или для натуральных чисел. Там есть биекция. А что делать с формулами,
[16:57.320 --> 17:01.720]  которые слова в бесконечном алкоголике? Ну, тут на самом деле все не очень сложно. Смотрите,
[17:01.720 --> 17:09.840]  вот у меня есть форма. Я буду постоянно иметь в виду вот такое преобразование формул. Первого
[17:09.840 --> 17:17.040]  порядка или булевых формул, неважно, двоичные слова. Формуля это слово в бесконечном алкоголике.
[17:17.040 --> 17:32.960]  Я сопоставлю слово в конечном алкоголике. Значит, у нас там будут, ну, если говорить о
[17:32.960 --> 17:43.280]  булевых формулах, какие у нас там были значки скобки, связки и перемены. Так вот,
[17:43.280 --> 17:50.400]  вместо переменных я буду теперь использовать три дополнительных символа. То есть это получается
[17:50.400 --> 17:57.120]  конечное алкоголь. Смотрите. Раз, два, три, четыре, пять, шесть, семь, восемь, девять. А алкоголь
[17:57.120 --> 18:02.800]  размера девять. И слово я буду сопоставлять очень естественно. Если мне нужно написать переменную,
[18:03.200 --> 18:18.200]  я буду сопоставлять ей такое слово. Решетка и дальше двоичная запись. Ну, видно, что это
[18:18.200 --> 18:22.120]  инъективное отображение. Разным формулам будут отвечать разные записи, потому что
[18:22.120 --> 18:28.680]  просто одному символу я буду сопоставлять какое-то такое длинное слово, но оно вполне однозначно
[18:28.680 --> 18:36.920]  задано. И тут я еще пользуюсь тем, что у меня, ну, неважно, даже если бы две переменные, может,
[18:36.920 --> 18:42.600]  могли идти подряд, поскольку они начинаются с решетки, мы не имеем проблем с тем, чтобы определить,
[18:42.600 --> 18:48.160]  где заканчивается это слово. Потому что следующий символ, либо это конец слова, либо следующий символ,
[18:48.160 --> 18:57.760]  должен отличаться от 0 единицы. Вот так мы кодируем формулы с вами в конечном алкоголите. Ну,
[18:57.760 --> 19:05.920]  теперь надо закодировать эти слова в двоичном алфавите. Ну, тут, я думаю, вас не затруднит,
[19:05.920 --> 19:11.440]  если есть слово в алфавите размера 9, как его записать в двоичном алфавите. Давайте каждый
[19:11.440 --> 19:20.040]  символ кодировать четырьмя битами. Всего значение четырех битов шестнадцать, это чуть
[19:20.040 --> 19:25.440]  много, но какие-то не будем вообще использовать. Просто вот зададим для каждого из этих девяти
[19:25.440 --> 19:31.840]  символов свою четверку и запишем просто конкатинацию кодов. То есть, когда у нас есть
[19:31.840 --> 19:36.320]  слово в конечном алфавите, запишем такую конкатинацию кодов. Поскольку мы знаем, что каждый код,
[19:36.320 --> 19:41.760]  так называемое равномерное кодирование, каждый код имеет длину 4, декодировать очень легко. Вы
[19:41.760 --> 19:48.600]  просто разбиваете биты на блоке по четыре и для каждой четверки смотрите, кодом какого символа
[19:48.600 --> 19:58.200]  наявляются. Поэтому это тоже имиерокса. Ну и вот эти слова, а потом у нас еще будет в какой-то
[19:58.200 --> 20:04.040]  момент натуральное число или номеральное слово, мы будем называть формой. То есть, когда я буду
[20:04.040 --> 20:11.360]  говорить множество форм, это будет сокращение для результата вот такой процедуры. Множество тех
[20:11.360 --> 20:19.920]  двоичных слов, которые получаются из множества форм. Ну в случае логики первого порядка там
[20:19.920 --> 20:25.440]  бывает чуть сложнее. У нас там же, вы помните, бывают редикатные символы. Давайте я сразу
[20:25.440 --> 20:35.640]  скажу. Я как-нибудь так запишу. Двоичная запись И. То есть, решетка, потом решетка, двоичная
[20:35.640 --> 20:41.640]  запись С. Соглашений может быть очень много. Нам единственное, что нужно, чтобы можно было
[20:41.640 --> 20:47.120]  однозначно декодировать. Это можно добиться очень многими способами. То же самое с функциональными
[20:47.120 --> 20:52.560]  символами. Только и того, что здесь может быть вместо решетки нужно поставить еще какой-то
[20:52.560 --> 20:58.240]  символ. Нам нужно конечное количество символов. Там и количество символов будет другое. Понятно,
[20:58.240 --> 21:06.120]  что такая кодировка есть и я буду ее подразумевать. Итак, возвращаемся к вопросу, который я начал
[21:06.120 --> 21:29.640]  обсуждать. Это автология. Разрешимое множество или нет? Я говорю да, разрешимое. Почему? Ну, мы
[21:29.640 --> 21:33.800]  обсуждали алгоритм разрешения. Смотрите, нам надо, прежде всего, что сделать? Берем формулу,
[21:33.800 --> 21:40.440]  устраиваем, строим дерево разбора. Это мы обсуждали как делать. Этот алгоритм есть и то,
[21:40.440 --> 21:45.320]  что мы переменной будем записывать такими словами. Нам от переменных, в сущности, все что нужно,
[21:45.320 --> 21:52.200]  это смотреть в каких местах формулы написана одна и та же переменная. Понятно, что слова такого вида
[21:52.200 --> 21:57.480]  мы можем сравнивать на равенство. Это не сложное алгоритмическое действие. После того, как построено
[21:57.480 --> 22:03.280]  дерево разбором, уже очень просто вычислять значение формулы в какой-то при каких-то значениях
[22:03.280 --> 22:08.720]  переменных. Вот у нас есть переменные, мы уже знаем сколько их после разбора. И мы начинаем
[22:08.720 --> 22:15.600]  приславить всеми возможными способами нуля и единицы. И вычисляем значение формулы. Если каждый раз
[22:15.600 --> 22:19.280]  получается единица, если в какой-то момент получилось нуля, алгоритм сразу же возвращает
[22:19.280 --> 22:25.000]  ответ на нет автологии. Если все время получилось единица и мы перебрали все возможные наборы нуля
[22:25.000 --> 22:30.840]  и единиц, алгоритм говорит автология. Алгоритм неэффективный, он работает долго, мы это уже
[22:30.840 --> 22:35.520]  обсуждали, но нас сейчас интересует принципиальное существование алгоритма. Заметьте, в определении
[22:35.520 --> 22:47.680]  ничего про ресурсы низка. Второй пример. Истинные формулы алгебритарства. Это уже формулы первого
[22:47.680 --> 22:53.520]  порядка в подходящей сигнатуре. Там у нас будут предикатные функциональные символы, но опять-таки
[22:53.520 --> 23:01.520]  мы их как кодируем? Мы записываем переменные в том же порядке, поскольку у нас конечная сигнатура,
[23:01.520 --> 23:06.000]  мы можем просто считать, что у нас такой конечный алфавит, который содержит знаки для умножения,
[23:06.000 --> 23:12.720]  сложения, равенства, неравенства, констант 0 и 1. Ну и всех специальных знаков, которые нам нужны,
[23:12.720 --> 23:17.680]  включая квантор, это будет сколько-то, какое-то конечное множество знаков, мы их равномерно
[23:17.680 --> 23:23.480]  кодируем двоечными славами, получаем вот это множество, которое я буду называть множеством формул в
[23:23.480 --> 23:30.040]  алгебритарстве. У нас интересуют истинные формулы. То есть они должны быть замутными и истинными. Я утверждаю,
[23:30.040 --> 23:40.720]  что это тоже множество разрешено. Но алгоритм, который разрешает это множество, мы тоже, по сути дела,
[23:40.720 --> 23:48.000]  обсуждали. Это тот самый алгоритм иллюминации квантора. Вот вспомните, что мы делаем. Если формула
[23:48.000 --> 23:55.960]  замкнута, проверить замкнутость формулы очень легко, если мы проделаем разбор формулы. Если формула
[23:55.960 --> 24:02.040]  не замкнута, она точно в этом множестве не входит. Если формула замкнута, мы должны, как положено,
[24:02.040 --> 24:10.960]  начать истреблять кванторы существования, начиная с самого нижнего, используя ту процедуру,
[24:10.960 --> 24:17.320]  которую я описал, которая тоже работает очень долго, еще больше, чем проверка топтологии. Но что
[24:17.320 --> 24:24.040]  существенно, эта процедура все равно будет работать конечное время. Для длинной формулы это время может
[24:24.040 --> 24:30.560]  быть астрономически велико, но не важно. Нас интересует опять-таки возможность. За конечное время
[24:30.560 --> 24:40.880]  мы получим бескванторную формулу. А что такое бескванторная формула, которая замкнута? В ней
[24:40.880 --> 24:47.720]  нет вообще переменных, потому что, поскольку нет кванторов, то переменные давали бы нам не замкнутую
[24:47.720 --> 24:52.240]  формулу. Раз нет переменных, значит там стоят константы, какие-то арихметические действия с
[24:52.240 --> 24:58.400]  этими константами, какие-то сравнения и булевая координация. Глядя на такую формулу, мы можем
[24:58.400 --> 25:04.480]  вычислить ее значение. Так же, как в предыдущем случае, сделаем дерево разбора и посчитаем. В начале
[25:04.480 --> 25:10.640]  подставим, вычисляем значение термов, арихметические операции выполним, потом сделаем сравнение,
[25:10.640 --> 25:18.000]  получим логические операции. Ну и дальше получится булева формула татамарной, и мы вычислим ее
[25:18.000 --> 25:24.280]  значение так же, как мы это обычно делаем для булевой формы. И то, что получится, и будет значением формулы.
[25:24.280 --> 25:31.760]  Если она равно единице, значит дожит нашу множество. Рано или нет, значит нет. Выдадим в качестве
[25:31.760 --> 25:40.360]  результата, результат работы этой процедуры и лиминации. Это примеры из логики, разумеется,
[25:40.360 --> 25:47.160]  есть очень много примеров из каких-то других областей математики. Я не буду на них подробно
[25:47.160 --> 25:58.080]  останавливаться. Я думаю, вы знаете, много примеров свойств, которые проверяются алгоритмически.
[25:58.080 --> 26:05.960]  Например, число проспоры. Зная определение простого числа, очень сложно придумать алгоритм.
[26:05.960 --> 26:12.320]  Нас не интересует эффективность этого алгоритма. Сложно придумать алгоритм, который проверяется.
[26:12.320 --> 26:27.120]  Следующий шаг, он уже труднее. Он состоит в том, что мы рассматриваем общезначенную формулу.
[26:27.120 --> 26:32.720]  Опять-таки номера или двоичные слова, отличающие общезначенную формулу.
[26:32.720 --> 26:42.880]  Я напомню, что в прошлый раз я тоже предложил некоторую процедуру алгоритмического характера,
[26:42.880 --> 26:48.360]  которая проверяет общезначенность формулы. Но процедура имеет совершенно другой вид, не такой,
[26:48.360 --> 26:53.760]  как в определении разрешимого. Я напомню, что у меня была. У меня была, по сути дела, система доказательств.
[26:53.760 --> 27:06.880]  То есть у меня был алгоритм, который получает на вход, можно сказать, два двоичных слова или два текста.
[27:06.880 --> 27:32.960]  Формула и доказательства. Значение его 0,1. И что мы знаем? Если формула общезначена, то для какого-то p алгоритм выдаст единицу.
[27:33.040 --> 27:41.760]  Вспомним все, что мы делали. Мы должны взять отрицание формулы, привезти к pnf, потом сколонизировать,
[27:41.760 --> 27:52.560]  потом построить множество универсальных дезюмптов. И мы знаем, что если формула общезначена, то для полученного множества универсальных дезюмптов есть вывод противоречия.
[27:52.560 --> 28:20.160]  Мы запишем все это в p и все шаги, мы в прошлый раз за этим посмотрели, все шаги там алгоритмические. Ну а соответственно, если f не общезначен, то чтобы вы не попытались дать системе доказательств в качестве доказательства,
[28:20.160 --> 28:35.760]  система доказательства и доказательства отвергнута. Ну потому что система доказательства, она проверяет, что построена корректная построенность множества универсальных дезюмптов и из него корректно выведен пустой дезюмпт.
[28:35.760 --> 28:53.360]  Если вы в каком-то месте что-то нарушите, ну ваша система доказательств скажет нет, это не является доказательством для этой формы. А нарушить что-то придется, потому что мы знаем, что если формула не общезначена, из этого множество универсальных дезюмптов пустой дезюмпт не будет.
[28:53.360 --> 29:22.960]  Поэтому вот есть такое свойство. Но заметьте, это не отвечает, если я посмотрю на множество общезначенных формул, этот алгоритм, это алгоритм, но он не дает ответа на вопрос, принадлежит ли формула этому множеству, он дает ответ на другой вопрос, верно ли, что некоторое слово является доказательством того, что эта формула общезначена.
[29:22.960 --> 29:48.560]  Понимаете, да, разницу? Мы отвечаем на другой вопрос. Это действительно алгоритм, он вычисляет тотальную функцию для любой пары f и p, он выдает гумицу или ноль, но вид другой. Вот давайте с этим разбираться, это центральное понятие для сегодняшнего рассказа. У нас появится много разных характеризаций этого понятия, но прежде всего давайте его немножко обобщим.
[29:52.960 --> 30:06.560]  И рассмотрим такой класс множеств, который называется проекцией разрешения.
[30:06.560 --> 30:28.160]  Что это означает? Это означает, что у нас есть вычислимая тотальная функция от двух аргументов.
[30:28.160 --> 30:53.760]  И еще говорят, что у нас определен предикат бинарный вычислимый. Предикат для каждой пары дает значение 0 или 1, и он вычислимый в том же самом смысле, который был в определенном расширении.
[30:53.760 --> 31:07.360]  И теперь я могу определить, то есть фактически у меня задано множество пар, то есть R я могу считать, что это множество пар.
[31:07.360 --> 31:16.360]  Давайте я, вот сейчас мне уже удобно окончательно перейти к натуральным числам, дальше появятся какие-то доказательства, мне там будет удобно считать, что входы натуральные числа.
[31:16.960 --> 31:31.960]  То есть, когда я буду говорить про множество общезначимых формул, я буду иметь в виду множество натуральных чисел, которые являются номерами общезначимых формул в том соответствии, в котором я поступил.
[31:31.960 --> 31:43.560]  То есть, этот предикат задает подножство Декартового произведения ДНР, и с любым таким подножством мы можем выполнить операцию проекции.
[31:43.560 --> 31:56.560]  Что это такое? Давайте я прям нарисую картинку, я думаю, что слово проекция вы знаете, и примерно представляете, как оно устроено.
[31:57.160 --> 32:14.160]  Вот так вот оно устроено, мы забываем про значение координата у и смотрим, какие получаются значения х, то есть, другими словами, это такие х, что существует у, для которого Rx или правильный у.
[32:14.160 --> 32:24.160]  То есть, если у нас такое у найдется, то это входит в проекцию, если не найдется, то не входит.
[32:24.760 --> 32:34.760]  Такая тень нашего множества у нас в Декартовом квадрате есть множество, и мы смотрим тень на одну из координатов.
[32:34.760 --> 32:47.760]  И видно, что система доказательств дает нам представление множества общезначимых формул, как проекцию.
[32:48.360 --> 32:57.360]  Ну вот, смотрите, эти два условия корректности и полноты как раз гарантируют нам, что проекция даст то, что нужно.
[32:57.360 --> 33:07.360]  Для общезначимой формулы найдется доказательство, то есть, она попадает вот сюда в тень, а для необщезначимой не найдется, она не попадает в тень.
[33:07.360 --> 33:12.360]  То есть, общезначимые формулы являются проекцией разрешимого множества.
[33:18.360 --> 33:20.360]  Ну, а являются ли они разрешимым множеством?
[33:21.360 --> 33:29.360]  Вообще, нам бы, конечно, хотелось иметь вот алгоритм, который всегда дает ответ по формуле, дает ответ общезначимой аналии.
[33:29.360 --> 33:33.360]  Ну, как в случае тавтологии, в случае истинных формул алгоритм Тарского.
[33:33.360 --> 33:39.360]  Позже я докажу, что такого алгоритма нет, что на самом деле множество ВЭЛИК не разрешено.
[33:39.960 --> 33:44.960]  Но это потребует довольно больших усилий, это несколько шагов нам придется сделать.
[33:44.960 --> 33:46.960]  Пока это я так просто анонсирую.
[33:48.960 --> 33:52.960]  Ну и в целом класс проекции разрешимого множества, он шире, чем разрешимого множества.
[33:54.960 --> 33:57.960]  И это, я надеюсь, вас, в этом, я надеюсь, вас убедить уже сегодня.
[33:58.560 --> 34:03.560]  И вот этот класс проекции разрешимого.
[34:03.560 --> 34:09.560]  В следующем семestре у вас будет уже курс, который ближе к теории вычислительной сложности.
[34:09.560 --> 34:14.560]  Там вы будете смотреть не только на существование алгоритмов, но и на ресурсы, которые они тратят.
[34:14.560 --> 34:17.560]  Алгоритмы должны будут работать какое-то не очень большое время.
[34:17.560 --> 34:22.560]  И там будет аналог вот этих вот проекций разрешимых множества, что называется класс МП.
[34:22.560 --> 34:26.560]  И вы будете там изучать разные свойства этого класса.
[34:27.160 --> 34:31.160]  Потому что это тоже довольно важно с точки зрения приложений.
[34:31.160 --> 34:36.160]  И это один из простейших и важнейших классов в теории структуры сложности.
[34:36.160 --> 34:43.160]  Ну, на самом деле растет он вот из этой вот общей теории алгоритмов.
[34:43.160 --> 34:50.160]  Есть понятие класса проекции разрешимого множества, у которого, как я говорил, будет несколько разных определений.
[34:50.160 --> 34:55.160]  И я тут же хочу дать еще одно определение.
[34:55.160 --> 35:01.160]  Вот смотрите, мне хочется построить алгоритм, который отвечает на вопрос, формула общезначима или нет.
[35:01.160 --> 35:04.160]  У меня есть система доказательств.
[35:04.160 --> 35:07.160]  Что я могу сделать? Я могу начать перебирать доказательства одно за другим.
[35:07.160 --> 35:10.160]  Теперь я под доказательством понимаю его номер.
[35:10.160 --> 35:13.160]  По номеру я могу восстановить доказательства.
[35:13.160 --> 35:23.160]  Значит, я перебираю доказательства одно за другим и применяю вот этот алгоритм, чтобы вычислить, является ли это доказательством для формулы или не.
[35:25.160 --> 35:31.160]  Если является, я доволен, говорю, все, формула общезначима.
[35:31.160 --> 35:36.160]  А вот если не является, я ничего не говорю.
[35:36.160 --> 35:41.160]  Потому что, возможно, доказательств бесконечно много, мой алгоритм в этом случае просто не останется.
[35:41.160 --> 35:46.160]  Вот если выполняется вторая строчка, такой алгоритм просто никогда не останется.
[35:46.160 --> 35:49.160]  Это отличает от этого определения.
[35:49.160 --> 35:54.160]  Сейчас зафиксирую это свойство в виде другого определения.
[36:05.160 --> 36:08.160]  Множество. Ну давайте.
[36:10.160 --> 36:12.160]  Полуразрешение.
[36:12.160 --> 36:22.160]  Если вычислить моего полухарактеристическая функция.
[36:22.160 --> 36:25.160]  Вот давайте я ее как-нибудь вот так вот обозначу.
[36:25.160 --> 36:28.160]  His tilde.
[36:28.160 --> 36:33.160]  А определение полухарактеристической функции, вот примерно такое, как я только что назвал.
[36:33.160 --> 36:40.160]  Если вход принадлежит нашему мнению, то алгоритм останавливается и выдает результат 1.
[36:40.160 --> 36:44.160]  А если не принадлежит, то результат нет.
[36:44.160 --> 36:47.160]  Это уже частично.
[36:53.160 --> 36:55.160]  Видите, есть разница.
[36:55.160 --> 36:59.160]  Здесь мы на каждом входе должны вывести результат 1 или 0.
[36:59.160 --> 37:04.160]  А в этом случае мы только половину цели достигаем.
[37:04.160 --> 37:08.160]  Мы если х принадлежит нашему мнению, то мы получаем ответ да.
[37:08.160 --> 37:11.160]  А если не принадлежит, мы такого ответа не получим.
[37:11.160 --> 37:14.160]  Это в точности отвечает ситуации с общезначимыми формулами.
[37:14.160 --> 37:19.160]  Если вы запустите, примените метод резолюции, начнете проверять общезначимость формулы,
[37:19.160 --> 37:22.160]  то вообще говоря, результат будет такой.
[37:22.160 --> 37:26.160]  Вы будете перебирать разные выводы, резолютивные.
[37:26.160 --> 37:33.160]  И либо в какой-то момент вы увидите пустой дизюнт, в этот момент вы можете остановиться и сказать, что формула общезначимая исходная.
[37:33.160 --> 37:36.160]  Либо вы не увидите пустого дизюнта, но тогда вы не можете остановиться,
[37:36.160 --> 37:39.160]  потому что он может появиться спустя очень большое количество шагов,
[37:39.160 --> 37:42.160]  после того как вы сделаете еще какие-то остановки и так далее.
[37:42.160 --> 37:48.160]  Вот видно, что это разные определения, и на самом деле это действительно разные классы.
[37:48.160 --> 37:56.160]  Моя ближайшая цель – доказать, что полуразрешимые и проекции разрешимых – это один и тот же класс.
[37:56.160 --> 38:05.160]  Ну, в сущности, в одну сторону я уже это сделал.
[38:05.160 --> 38:28.160]  Если у нас есть множество, которое является проекцией разрешимого,
[38:28.160 --> 38:31.160]  существует полухарактеристическая функция – вычислимо.
[38:31.160 --> 38:33.160]  Я привел алгоритм вычисления.
[38:33.160 --> 38:38.160]  Нужно просто перебирать все Y один за другим, вычислять R.
[38:38.160 --> 38:43.160]  R – всюду определенная функция, поэтому вычисление в какой-то момент закончится.
[38:43.160 --> 38:50.160]  В тот момент, когда оно закончилось, если результат единицы – отлично, мы выдаем результат нашего алгоритма тоже единицу.
[38:50.160 --> 38:55.160]  А если ноль, то мы переходим к следующему Y.
[38:55.160 --> 38:57.160]  То есть мы перебираем все Y, пока не найдем единицу.
[38:57.160 --> 39:05.160]  Если такого не существует, то есть если у нас вход X не принадлежит проекции,
[39:05.160 --> 39:11.160]  наш алгоритм не останавливается – это отличное определение полухарактеристической функции.
[39:11.160 --> 39:20.160]  Но теперь я хочу доказать другую сторону, что всякое полуразрешимое множество.
[39:20.160 --> 39:25.160]  То есть у меня есть алгоритм, который вычисляет полухарактеристическую функцию.
[39:25.160 --> 39:35.160]  Я теперь хочу доказать, что тогда соответствующее множество можно представить как проекцию разрешимого.
[39:38.160 --> 39:42.160]  Ну так, на первый взгляд, не очень понятно, что можно сделать с этим алгоритмом.
[39:42.160 --> 39:46.160]  Такое простое действие, только что я выполнил, не очень понятно, что дает.
[39:46.160 --> 39:50.160]  Мне нужно какой-то предикат от двух перемен всюду вычислить.
[39:50.160 --> 39:56.160]  У меня есть алгоритм, который вычисляет частичную функцию от одного аргумента,
[39:56.160 --> 40:00.160]  а нужен сюда определенный предикат от двух аргументов.
[40:00.160 --> 40:03.160]  Но есть очень простой способ это сделать.
[40:03.160 --> 40:05.160]  Давайте сейчас сделаем перерыв.
[40:05.160 --> 40:09.160]  Это будет уже первое недревяленное рассуждение за сегодняшнюю лекцию.
[40:09.160 --> 40:13.160]  И полезно в этот момент остановиться, передохнуть,
[40:13.160 --> 40:21.160]  и приготовиться слушать уже доказательства, а не только определения.
[40:21.160 --> 40:25.160]  Так, ну ладно, давайте продолжим.
[40:25.160 --> 40:32.160]  Я вот это доказал, что проекция разрешима и полуразрешимая.
[40:32.160 --> 40:35.160]  Я хочу сказать, что полуразрешимая является проекцией разрешимой.
[40:35.160 --> 40:38.160]  Я перед перерывом объяснил, в чем сложность.
[40:38.160 --> 40:40.160]  У меня есть алгоритм, который вычисляет эту функцию.
[40:40.160 --> 40:43.160]  Давайте я его как-нибудь назову А.
[40:43.160 --> 40:49.160]  А мне нужен другой алгоритм, который вычисляет уже бинарный предикат.
[40:49.160 --> 40:52.160]  Что я буду делать?
[40:52.160 --> 40:57.160]  Я воспользуюсь, мне нужно что-то еще про алгоритмы знать,
[40:57.160 --> 41:00.160]  кроме того, что мы можем делать циклы.
[41:00.160 --> 41:04.160]  Давайте вспомним, что алгоритм – это инструкция выполнения действий.
[41:04.160 --> 41:08.160]  Каждое действие простое, которое мы называем шагом.
[41:08.160 --> 41:11.160]  Алгоритм исполняется по шагам.
[41:11.160 --> 41:16.160]  И тогда, если мы про это вспомним, у нас возникает такая дополнительная возможность.
[41:16.160 --> 41:20.160]  Если у нас есть алгоритм, мы можем его модифицировать.
[41:20.160 --> 41:23.160]  А именно, мы можем добавить к нему счетчик шагов.
[41:23.160 --> 41:27.160]  Вот мы исполняем алгоритм А, и при этом, где-то в дополнительной памяти,
[41:27.160 --> 41:31.160]  считаем, сколько шагов этот алгоритм А сделает.
[41:31.160 --> 41:35.160]  Тут нужно поверить, что это возможно, но я думаю, что это не должно быть.
[41:35.160 --> 41:39.160]  Все-таки современным людям, которые имеют опыт реального программирования,
[41:39.160 --> 41:42.160]  не должно возникать проблемы, что у вас есть алгоритм,
[41:42.160 --> 41:44.160]  который исполняется по каким-то шагам,
[41:44.160 --> 41:48.160]  и вы можете еще привинтить к нему счетчик, который считает число этих шагов.
[41:48.160 --> 41:50.160]  Вроде бы ясно, что может.
[41:52.160 --> 41:55.160]  Задумайтесь, в чем может быть проблема?
[41:55.160 --> 41:59.160]  Вы выполнили шаг, и после этого у вас еще есть отдельная переменная целочистная,
[41:59.160 --> 42:02.160]  вы должны ее увеличить на единицу, ни на чем плохо.
[42:02.160 --> 42:04.160]  Просто помимо действия этого шага,
[42:04.160 --> 42:07.160]  еще увеличение дополнительной целочистой переменной на единицу.
[42:07.160 --> 42:10.160]  Снова получится четкая инструкция,
[42:10.160 --> 42:12.160]  и, разумеется, увеличение переменной на единицу
[42:12.160 --> 42:15.160]  это тоже вполне себе алгоритмическое действие.
[42:17.160 --> 42:19.160]  А потом этот счетчик мы можем как-то использовать.
[42:19.160 --> 42:24.160]  Вот я буду строить алгоритм, вот этот вот бинарный предикат,
[42:24.160 --> 42:28.160]  вычисление этого бинарного предиката с помощью этого счетчика.
[42:28.160 --> 42:31.160]  Смотрите, что происходит. Я буду строить такой алгоритм.
[42:31.160 --> 42:37.160]  У него входы X и T, два входа.
[42:40.160 --> 42:42.160]  И он работает так.
[42:47.160 --> 42:54.160]  Выполняет алгоритм A со счетчиками.
[42:54.160 --> 42:59.160]  И каждый раз проверяет.
[42:59.160 --> 43:02.160]  Давайте я даже не буду писать, это вот он делает.
[43:02.160 --> 43:11.160]  Значит, если число шагу не превосходит T,
[43:11.160 --> 43:14.160]  и A выдал результат.
[43:17.160 --> 43:20.160]  То есть каждый раз, когда мы делаем очередной шагол на ритм A,
[43:20.160 --> 43:22.160]  мы еще делаем вот такую проверку.
[43:22.160 --> 43:24.160]  То есть увеличиваем счетчики, делаем такой проверку.
[43:24.160 --> 43:27.160]  Если число шагов не превосходит входа T,
[43:27.160 --> 43:33.160]  и алгоритм A уже выдал результат, то мы выдаем результат 1.
[43:36.160 --> 43:42.160]  А вот если число шагов уже стало больше T,
[43:42.160 --> 43:52.160]  и A не выдал результат, то мы выдаем результат 2.
[43:55.160 --> 44:00.160]  Прежде всего нужно понять, что на любой паре X и T наш алгоритм выдаст либо 1, либо 0.
[44:00.160 --> 44:02.160]  И это очень легко.
[44:02.160 --> 44:06.160]  Выполняем A на входе X. У A есть вход X.
[44:07.160 --> 44:13.160]  Это понять очень легко, потому что мы делаем шаги.
[44:13.160 --> 44:18.160]  Четчик шагов увеличивается, и у нас есть порог T.
[44:18.160 --> 44:24.160]  Если до достижения этого порога наш алгоритм A выдал результат,
[44:24.160 --> 44:27.160]  то мы тоже выдадим результат.
[44:27.160 --> 44:32.160]  А если этот порог будет превзойден, то мы тут же выдаем результат 1.
[44:32.160 --> 44:37.160]  Поэтому, конечно, на любой паре X и T алгоритм R выдаст результат.
[44:37.160 --> 44:45.160]  И все, что я хочу теперь утверждать, что вот эта вот полухарактеристическая функция...
[44:51.160 --> 44:55.160]  Нет, тут множество X. У нас есть алгоритм, я мечтаю о полухарактеристической функции.
[44:56.160 --> 45:03.160]  На самом деле, проекция вот этого самого предиката, который я так определил.
[45:03.160 --> 45:07.160]  Это совершенно понятно. Посмотрите на устройство алгоритма.
[45:07.160 --> 45:15.160]  Если существует такой оттеш, что результат 1, это означает, что алгоритм A, который вычисляет полухарактеристическую функцию, дал ответ 1.
[45:15.160 --> 45:19.160]  И мы знаем, что он корректно вычисляет полухарактеристическую функцию.
[45:19.160 --> 45:25.160]  Посмотрите на первую точку в таблице X, то вход X принадлежит множеству X.
[45:25.160 --> 45:35.160]  А если для любого T вот этот алгоритм дает результат 0, то есть какую бы границу числа шагов вы не задали,
[45:35.160 --> 45:39.160]  все равно ваш алгоритм еще не выдал результат 1.
[45:39.160 --> 45:42.160]  Но это означает, что имеет место второй случай.
[45:42.160 --> 45:46.160]  Потому что первый случай достигается за какое-то конечное число шагов.
[45:46.160 --> 45:52.160]  Тут очень важно, что все наши алгоритмы исполняются, если он дает результат, то он дает его за конечное число шагов.
[45:52.160 --> 45:55.160]  Может быть очень большое, но за конечное.
[45:55.160 --> 46:05.160]  Поэтому получаем такое радость, и оно доказывает это вытверждение в другую сторону.
[46:05.160 --> 46:11.160]  Итак, мы получили, что полуразрешимые и проекции разрешимых – это одно и то.
[46:11.160 --> 46:14.160]  Один и тот же класс множества.
[46:14.160 --> 46:19.160]  Но это не все. На самом деле этот класс очень важен.
[46:19.160 --> 46:23.160]  В каком-то смысле даже важнее, чем класс разрешимых в нашей теоретической точки зрения.
[46:23.160 --> 46:28.160]  Потому что для него есть очень много разных характеризаций.
[46:28.160 --> 46:33.160]  Все это приводить не буду, но одну я заведомо приведу.
[46:33.160 --> 46:41.160]  Хотя бы потому, что и в русско-иландоязычной литературе название этого класса обычно не проекции разрешимых и не полуразрешимые,
[46:41.160 --> 46:46.160]  а вот это третье слово, которое я сейчас приведу, я прямо его напишу.
[46:46.160 --> 46:49.160]  Перечислимое множество.
[46:53.160 --> 46:58.160]  Я докажу, что это то же самое, что тот класс, который у меня уже появился.
[46:58.160 --> 47:02.160]  Но для начала мне надо определить, что такое перечислимое множество.
[47:02.160 --> 47:05.160]  Давайте этим займемся.
[47:05.160 --> 47:10.160]  Наверное, вот так лучше проекции я оставлю. Более сложное понятие.
[47:20.160 --> 47:25.160]  Для перечислимых множества нужны алгоритмы перечисления. Это другой вид алгоритма.
[47:25.160 --> 47:35.160]  Значит, входа алгоритма перечисления нет вообще.
[47:35.160 --> 47:46.160]  Алгоритм работает время от времени, печатает.
[47:46.160 --> 47:53.160]  Давайте для определенности я буду говорить число, хотя, конечно, формат перечисления может быть разный.
[47:53.160 --> 47:58.160]  Я могу перечислять числа, могу двоичные слова, могу формулы.
[47:58.160 --> 48:03.160]  Все объекты, которые можно кодировать таким способом, как я описывал выше.
[48:03.160 --> 48:09.160]  Мне сейчас проще говорить про число. Печатает число.
[48:09.160 --> 48:18.160]  Печатает тут наглядный образ. Вы запустили алгоритм, и он время от времени на принтер что-то посылаешь.
[48:18.160 --> 48:22.160]  Что тут важно? Важно, конечно, не принтер, а важна необратимость.
[48:22.160 --> 48:26.160]  То, что он это число напечатал, то он уже этот фактор не может.
[48:26.160 --> 48:29.160]  В своей внутренней памяти он может менять все как угодно.
[48:29.160 --> 48:32.160]  А то, что напечатал, то так на бумаге остался.
[48:32.160 --> 48:44.160]  В результате, результат работы алгоритма, это как раз последовательность чисел, которую он напечатал.
[48:44.160 --> 48:48.160]  Последовательность, вообще говоря, может быть и конечной, и бесконечной.
[48:48.160 --> 48:50.160]  Алгоритм может и не останавливаться.
[48:50.160 --> 48:53.160]  Ну, простейшее алгоритм перечисления.
[48:53.160 --> 48:59.160]  Он перебирает циклы числа от 0, 1, 2, то есть добавляет 1 и печатает каждую числу.
[48:59.160 --> 49:03.160]  Он так перечисляет все натуральные числа.
[49:03.160 --> 49:11.160]  А можно перечислить квадраты. То есть он тоже делает такой бесконечный цикл, но каждое число еще проверяет квадраты или нет.
[49:11.160 --> 49:15.160]  Это же легко сделать. Есть алгоритм, который проверяет и является числом полным квадратным.
[49:15.160 --> 49:18.160]  Если квадрат печатает, если не квадрат, то не печатает.
[49:18.160 --> 49:21.160]  Перечислим.
[49:21.160 --> 49:26.160]  В общем, можно много примеров построить.
[49:26.160 --> 49:44.160]  Значит, что мы говорим? Мы говорим, что множество А перечислимо, если А это результат перечисления какого-то алгоритма.
[49:44.160 --> 49:56.160]  Первое важное замечание – алгоритмы дают последовательность.
[49:56.160 --> 50:02.160]  Результаты работы алгоритма перечисления – это последовательность чисел.
[50:02.160 --> 50:07.160]  Потому что мы знаем, что первым напечатанным числом, скажем, было 2, вторым – 200, а третьим – 3.
[50:07.160 --> 50:15.160]  Порядок не важен. Мы можем печатать числа не в порядке возраста. В каком порядке печатает, таком и печатает.
[50:15.160 --> 50:25.160]  Повторы тоже разрешены. У нас нет никаких ограничений, но потом, когда мы уже закончили работу через бесконечное число,
[50:25.160 --> 50:30.160]  у нас появилась эта последовательность, и элементы этой последовательности образуют некоторое множество.
[50:30.160 --> 50:44.160]  Вот это и есть множество, которое перечисляется этим алгоритмом. Такие множества называются перечислимами.
[50:44.160 --> 50:51.160]  Тут очень важно, давайте я скажу, рискуя вас запутать, но тем не менее скажу.
[50:51.160 --> 50:58.160]  Потому что кому-то это и так понятно, и может быть хуже станет это замечание, но некоторые путаются.
[50:58.160 --> 51:02.160]  Есть еще понятие счетного множества. Вот почти заведомо его слышали.
[51:02.160 --> 51:08.160]  Вот очень важно понимать, они звучат очень похоже по-русски – перечислимая, счетная, но есть принципиальная разница.
[51:08.160 --> 51:17.160]  Что такое счетное множество? Это множество, которое равномочно множеству натуральных чисел.
[51:17.160 --> 51:24.160]  То есть вот счетное множество S мы можем установить в диекцию между S и множеством натуральных чисел.
[51:24.160 --> 51:34.160]  В этом смысле мы можем расположить элементы S в последовательности, но свойство перечислимости гораздо более сильное.
[51:34.160 --> 51:43.160]  Нам нужно не просто расположить в последовательности, а такую последовательность, которая может быть результатом работы какого-то алгорита.
[51:43.160 --> 51:47.160]  Это принципиальное ограничение, потому что биекций намного больше.
[51:47.160 --> 51:54.160]  Если говорить о мощностных соображениях, сколько у нас разных биекций? Ну их континент.
[51:54.160 --> 52:02.160]  Давайте, если кто не понимает то, что я сейчас говорю, просто пропустите. Это такое замечание не очень существенное для дальнейшего.
[52:02.160 --> 52:05.160]  Но все равно будем более сильные вещи делать. Их континент.
[52:05.160 --> 52:12.160]  А алгоритма в счетное множество, потому что алгоритм задается программой, программа – это текст, то есть алгоритма в счетное множество.
[52:12.160 --> 52:17.160]  Значит, для каких-то биекций точно программ нет.
[52:17.160 --> 52:21.160]  И действительно мы потом увидим, что бывают неперечислимые множества.
[52:21.160 --> 52:29.160]  А заметьте, все множества, которые я обсуждаю, это либо под множество натуральных чисел, либо под множество двоичных слов.
[52:29.160 --> 52:32.160]  Но это под множество счетного множества, поэтому они счетные всегда.
[52:32.160 --> 52:37.160]  Все множества, которые мы обсуждаем, или конечные, или счетные, других у нас вообще нет.
[52:37.160 --> 52:44.160]  То есть вся эта сложная теория множества вы можете про нее забыть, потому что у нас максимум, что бывает, это счетные множества.
[52:44.160 --> 52:50.160]  Вот которые равномочные с множеством натуральных чисел.
[52:50.160 --> 52:53.160]  Некоторые из них перечислимые, а некоторые – нет.
[52:53.160 --> 52:56.160]  И вот эта разница нас будет интересовать.
[52:57.160 --> 53:13.160]  Значит, после вот этих вот определений я наконец начну доказывать, что перечислимое множество совпадает с проекциями разрешимок из полуразрешения.
[53:13.160 --> 53:21.160]  Ну, давайте вначале докажем, что вот эту стрим – перечислимое множество полуразрешения.
[53:27.160 --> 53:29.160]  Значит, что у нас есть в посылке?
[53:29.160 --> 53:37.160]  В посылке у нас есть алгоритм А, который перечисляет множество…
[53:37.160 --> 53:40.160]  Ну, как-нибудь вы давайте кресом.
[53:44.160 --> 53:48.160]  А мне нужен другой алгоритм, который вычисляет полукарактеристическую функцию.
[53:48.160 --> 53:50.160]  Как я это буду делать?
[53:50.160 --> 53:52.160]  Смотрите, алгоритм.
[53:52.160 --> 53:58.160]  Учисление полукарактеристической функции.
[53:58.160 --> 54:05.160]  На входе Х мы делаем следующее.
[54:05.160 --> 54:23.160]  Запускаем алгоритм А каждый раз, когда А печатает какое-то…
[54:23.160 --> 54:28.160]  Ну, давайте говорить для определенности число или дворечное слово, или какой у нас формат алгоритма перечисления.
[54:28.160 --> 54:30.160]  Вот он печатает Х.
[54:30.160 --> 54:31.160]  Проверяем.
[54:31.160 --> 54:36.160]  Ой, КХ у нас на входе задан, так что печатает мы какой-нибудь А.
[54:36.160 --> 54:38.160]  Проверяем.
[54:42.160 --> 54:45.160]  Верно ли, что А совпадает со входом?
[54:45.160 --> 54:54.160]  Если да, результат единица.
[54:54.160 --> 54:56.160]  Иначе продолжаем.
[55:01.160 --> 55:03.160]  Вот этот алгоритм А.
[55:03.160 --> 55:11.160]  То есть мы запускаем алгоритм перечисления, и каждый раз, когда он хочет что-то напечатать, мы то, что он хочет напечатать, сравниваем со входом.
[55:11.160 --> 55:16.160]  Если оказалось, что это и есть вход, мы выдаем результат 1.
[55:16.160 --> 55:20.160]  Иначе мы ничего не делаем, продолжаем имитировать алгоритм перечисления.
[55:20.160 --> 55:22.160]  Почему вычисляется полукарактеристическая функция?
[55:22.160 --> 55:24.160]  Ну, вспомним определение.
[55:24.160 --> 55:29.160]  Она должна равняться единице на элемент окно S.
[55:29.160 --> 55:31.160]  Наш алгоритм перечисляет magnificent S.
[55:31.160 --> 55:35.160]  Значит, рано или поздно алгоритм перечисления выдаст X.
[55:35.160 --> 55:39.160]  X же входит в этом можете, значит он должен встретиться в результате перечисления.
[55:39.160 --> 55:41.160]  И в этот момент будет получена единица.
[55:42.160 --> 55:48.160]  А если X не входит в S, то он никогда не появит, не будет напечатан алгоритм перечисления.
[55:48.160 --> 55:51.160]  Алгоритм перечисления печатает в точности из S.
[55:51.160 --> 55:58.160]  Значит, результат единицы никогда не будет исполнен, алгоритм вообще никогда не остановится.
[55:58.160 --> 56:02.160]  Потому что, видно, единственное место, где алгоритм останавливается, вот это.
[56:02.160 --> 56:08.160]  Это и означает полукрактистическую функцию.
[56:08.160 --> 56:12.160]  Ну, вы можете сказать, а если алгоритм перечисления сдунует, остановится.
[56:12.160 --> 56:16.160]  Ну да, нужно уточнить, что если алгоритм перечисления A захотел остановиться,
[56:16.160 --> 56:22.160]  мы входим в бесконечную циклу, чтобы было неопределенно.
[56:22.160 --> 56:28.160]  Итак, я доказал, что перечислимое множество являются полуразрешимыми.
[56:28.160 --> 56:32.160]  Ну давайте вспомним логику. Я хочу доказать, что все три класса совпадают.
[56:32.160 --> 56:36.160]  У меня есть такая стрелка, такая стрелка. Мне нужно цикл замкнуть.
[56:36.160 --> 56:42.160]  То есть мне нужна теперь вот такая стрелка, чтобы проекция разрешимого перечислила.
[56:42.160 --> 56:46.160]  Ну давайте, вот я специально не стирал определение.
[56:46.160 --> 56:51.160]  Давайте на него посмотрим. Вот у нас проекция разрешимого.
[56:51.160 --> 56:53.160]  Как ее перечислить?
[56:59.160 --> 57:01.160]  Ну, перебираем пару.
[57:04.160 --> 57:06.160]  Как перебирать пары натуральных чисел?
[57:06.160 --> 57:08.160]  Ну, у нас есть биекция.
[57:08.160 --> 57:12.160]  А можно сказать так, мы перебираем порядки возрастания суммы и x плюсы.
[57:12.160 --> 57:16.160]  А при делах одинакового значения суммы мы начинаем с меньших значений x.
[57:16.160 --> 57:18.160]  Или с больших значений x.
[57:18.160 --> 57:22.160]  Перебираем. Каждый раз вычисляем r от цикли.
[57:25.160 --> 57:27.160]  И если он равен единице, то...
[57:32.160 --> 57:34.160]  Печатаем.
[57:39.160 --> 57:41.160]  И все, больше ничего не делаем.
[57:41.160 --> 57:44.160]  Смотрите, я утверждаю, что будет напечатана в точности проекция.
[57:44.160 --> 57:52.160]  Почему? Потому что если x принадлежит проекции, значит для какого-то y r от x и y краем единицы.
[57:52.160 --> 57:56.160]  Мы до такой пары x и y обязательно дойдем. Мы перебираем все пары.
[57:56.160 --> 58:01.160]  В этот момент, когда мы дойдем до этой пары, мы здесь получим единицу и напечатаем.
[58:01.160 --> 58:08.160]  Теперь, если x не принадлежит проекции, тогда для любого y r от x и y равен 0.
[58:09.160 --> 58:18.160]  Значит, в этой строчке у нас проверка будет всегда давать 0, и x точно не будет напечатан.
[58:18.160 --> 58:20.160]  Вот и все.
[58:20.160 --> 58:22.160]  Тогда и только тогда.
[58:22.160 --> 58:29.160]  То есть, это доказывает существование алгоритма перечисления для проекции разрешенного множества.
[58:29.160 --> 58:34.160]  Итак, у нас получился класс с несколькими равносильными определениями.
[58:34.160 --> 58:39.160]  Появится еще, кстати, одна характеризация этого класса, но уже может быть не сегодня.
[58:39.160 --> 58:41.160]  Боюсь, что сегодня я уже не успею.
[58:41.160 --> 58:45.160]  Может быть, в самом конце я успею. Посмотрим.
[58:45.160 --> 58:48.160]  Ну, есть несколько разных характеризаций.
[58:48.160 --> 58:58.160]  То есть, перечислимые множества связаны с самыми разными способами, с вычислимыми функциями, с разрешимыми множествами.
[58:58.160 --> 59:02.160]  И, как я уже говорил, вообще говоря, этот класс шире.
[59:03.160 --> 59:07.160]  То есть, давайте этот тезис как-нибудь отдельно где-нибудь напишу.
[59:22.160 --> 59:29.160]  Существуют перечислимые неразрешимые множества.
[59:32.160 --> 59:44.160]  Ну, вообще-то я вам обещал больше. Я обещал, что общезначимые формулы образуют такое множество.
[59:44.160 --> 59:47.160]  Но это трудный результат. Мы до него не сразу дойдем.
[59:47.160 --> 59:56.160]  Сейчас за остаток лекции я хочу объяснить в пределах такой наивной теории множеств, почему вообще такое возможно.
[59:56.160 --> 59:58.160]  Заметьте, что мощностные соображения тут не работают.
[59:58.160 --> 01:00:05.160]  Перечислимых множеств тоже счетное количество, потому что алгоритмов счетный, то каждое перечислимое множество задается каким-то алгоритмом.
[01:00:05.160 --> 01:00:11.160]  Поэтому сказать, как в случае, что вообще есть неразрешимое множество, очень легко.
[01:00:11.160 --> 01:00:17.160]  Можно сказать, что под множество Continuum разрешимых счетное, значит есть неразрешимые.
[01:00:17.160 --> 01:00:20.160]  Но вот существование перечислимого неразрешимого множества так и не извлечешь.
[01:00:20.160 --> 01:00:28.500]  потому что оба класса множеств счетные, и почему бы им не совпадать. Вот оказывается,
[01:00:28.500 --> 01:00:36.480]  они не совпадают, и это удивительным образом можно объяснить опять-таки вот на пальцах,
[01:00:36.480 --> 01:00:43.480]  не вводя сложных формальных определений, точных определений алгоритм. Но нужно совершить очередной
[01:00:43.840 --> 01:00:52.600]  акт веры в то, что существует некоторый алгоритм особого вещества. Этот акт веры уже посложнее,
[01:00:52.600 --> 01:01:08.520]  но я думаю, что вы мне поверите. Что я хочу? Я хочу сказать, что есть универсальный алгоритм.
[01:01:08.520 --> 01:01:18.520]  Сейчас я объясню, что это такое. Смотрите, алгоритма в счетное количество, но алгоритма
[01:01:18.520 --> 01:01:23.320]  на какой-то текст. Давайте эти тексты опять-таки, как у меня было соответствие двоичных слов
[01:01:23.320 --> 01:01:27.560]  на натуральных чисел, заменим на номер. Мне сейчас удобно говорить о натуральных числах. Вот
[01:01:27.560 --> 01:01:38.760]  P это программа или алгоритм. Мы все алгоритмы занумеровали. Мы знаем, что каждый алгоритм вычисляет
[01:01:38.760 --> 01:01:48.520]  частичную функцию, которую я так и обозначу. P от X. То есть вот P у меня будет обозначать
[01:01:48.520 --> 01:02:03.960]  имя алгоритма, нам номер алгоритма X, его аргумент. Так вот, вот эта функция U это просто функция двух
[01:02:03.960 --> 01:02:15.560]  аргументов P и X и должно выполняться равенство в обобщенном смысле. Что это означает? Для любых P и X
[01:02:15.960 --> 01:02:21.140]  выполняются равенства в обобщенном смысле. Почему я говорю про обобщенный смысл? Давайте вспомним,
[01:02:21.140 --> 01:02:28.400]  что у нас функции, вообще говоря, частичные. И что делать, если у нас написано равенство?
[01:02:28.400 --> 01:02:32.840]  Левая часть имеет значение, а правая не имеет значение. Вот, мы будем считать,
[01:02:32.840 --> 01:02:37.640]  что равенство в этом случаеità неполняется. Равенство об обобщенном смысле означает следующее,
[01:02:37.640 --> 01:02:41.880]  что если определена левая часть равенства, то правая часть равенства тоже определена и
[01:02:41.880 --> 01:02:46.080]  получаются одинаковые значения. Если определена правая часть равенства, левая
[01:02:46.080 --> 01:02:48.920]  часть равенства тоже определенная и принимаются одинаковые значения.
[01:02:48.920 --> 01:02:53.160]  Ну и соответственно если не определенна левая часть, то не определен условия правой rolling.
[01:02:53.160 --> 01:03:01.280]  То есть у нас появляется как бы дополнительное значение не определено, и равенство должно
[01:03:01.280 --> 01:03:04.240]  быть уже для такой тотальной функции врашины температуры значения.
[01:03:04.240 --> 01:03:13.360]  где мы добавили значок неопределённый. И вот мы хотим... Я утверждаю, что есть алгоритм, который вычисляет.
[01:03:13.360 --> 01:03:20.000]  То есть по программе и в ходу этой программы выдаёт результат работы этой программы на этом ходе.
[01:03:20.000 --> 01:03:27.400]  Ну, казалось бы... А поднимите руки. Кому кажется очевидным, что такой алгоритм существует?
[01:03:27.400 --> 01:03:43.920]  Да, это, как любят говорить философы, развитие идёт по спирали. История такая, когда-то давно,
[01:03:43.920 --> 01:03:48.800]  когда ещё я был студентом, это считалось очень сложным утверждением. Для него в книжках писали
[01:03:48.800 --> 01:03:54.240]  очень длинные формальные доказательства. Потом, ну, это уже вот прям на моей памяти,
[01:03:54.240 --> 01:04:01.720]  я с этим столкнулся, что просто кто-то из студентов мне это сказал. Я как-то никогда не задумывался,
[01:04:01.720 --> 01:04:07.720]  потому что меня ещё учили как-то в серьёзном, сложных доказательствах, десятки страниц. Я как-то
[01:04:07.720 --> 01:04:12.160]  привык считать, что это действительно какая-то сложная террина. А парень мне сказал очень простую
[01:04:12.160 --> 01:04:18.160]  вещь. Ну, я слышал, что такое У. Это транслятор с языка программика. Ну, точнее говоря, это интерпретатор.
[01:04:18.160 --> 01:04:23.320]  Вот что такое интерпретатор, если мы сталкивались вообще с таким памятником? Он получает на вход
[01:04:23.320 --> 01:04:29.760]  писание программы и описание входа, и выдаёт результат. Компилятор делает более сложную вещь,
[01:04:29.760 --> 01:04:37.320]  он создаёт какую-то программу, которая уже исполняется. А интерпретатор, у него действительно два входа.
[01:04:37.320 --> 01:05:00.600]  Текст программы и текст входа. Ну, давайте, это очень важно. Давайте привыкнем к мысли,
[01:05:00.600 --> 01:05:06.320]  что алгоритмы можем задавать разными способами. Можем записывать его как текст в некотором языке
[01:05:06.520 --> 01:05:11.840]  программики. Можем задавать как двоичное слово. То есть возьмём файл, который содержит запись этого
[01:05:11.840 --> 01:05:17.840]  текста. А можем взять натуральное число, которое соответствует этому двоичному слову. Вот по тому
[01:05:17.840 --> 01:05:24.800]  правилу, который я называл. И разницы для нас никакой нет. То есть я ж не случайно писал программу,
[01:05:24.800 --> 01:05:29.480]  чтобы стало понятнее, что алгоритмы программы на каком-то языке программики.
[01:05:29.480 --> 01:05:54.880]  Нет, такого не бывает по определению. Вот смотрите, ещё раз алгоритмы – это
[01:05:54.880 --> 01:06:01.720]  чётко определенная инструкция. То есть это текст. Вот к технике раньше всегда выдавали бумажку.
[01:06:01.720 --> 01:06:08.000]  Инструкция по использованию. Сейчас уже часто не выдают. Но вот алгоритм – это вот такая инструкция.
[01:06:08.000 --> 01:06:15.400]  То есть вы имеете список действий, которые вы должны выполнять. Он чёткий и однозначный. Если
[01:06:15.400 --> 01:06:20.000]  вы находитесь в данном месте, вы должны выполнить то-то и перейти в какое-то другое место,
[01:06:20.600 --> 01:06:28.880]  в другую страну. Поэтому алгоритм по определению не на вот это. Когда мы будем давать формальное
[01:06:28.880 --> 01:06:33.800]  определение алгоритма, у нас вот это понятие инструкции будет уточняться. Но в любом случае
[01:06:33.800 --> 01:06:40.960]  вот этому общему, общей рамки это будет соответствовать. Это может быть ответ в программе на синем. Это
[01:06:40.960 --> 01:06:52.120]  тоже вот писание алгоритма. Но никакого способа написать что-то сложное, из чего как-то получится
[01:06:52.120 --> 01:06:58.080]  алгоритм. Мы не предусматриваем алгоритм. Это вот чётко определенная последовательность инструкции.
[01:06:58.080 --> 01:07:04.720]  Они не то что выполняются одна за другой. Там могут быть циклы, могут быть рекурсии. Всё,
[01:07:04.720 --> 01:07:10.000]  что угодно может быть. Но порядок действий должен однозначно определяться этим текстом.
[01:07:10.000 --> 01:07:19.040]  В общем, у меня осталось уже буквально три минуты, но на самом деле не так сложно. Если вы поверите в
[01:07:19.040 --> 01:07:26.240]  существование универсальной нечислимой функции, которая по программе и по блогу этот результат
[01:07:26.240 --> 01:07:32.400]  работы этой программы, то нужное нам нечислимое неразрешимое множество это очень простая вещь.
[01:07:40.000 --> 01:07:47.800]  Это мы возьмём, будем запускать программу на себе самой. У нас же входы имеют один и тот
[01:07:47.800 --> 01:07:53.500]  же формат, поэтому мы можем программу запустить на себе самой. И вот те х, для которых это
[01:07:53.500 --> 01:07:58.520]  определено, образуют множество. Это множество перечислимо. Почему? Потому что, смотрите,
[01:07:58.520 --> 01:08:04.280]  полухарактеристическая функция вычисляется очень легко. Беру вход х, запускаю алгоритм
[01:08:04.280 --> 01:08:10.600]  учисления универсальной функции на паре x, x. Если он останавливается, я выдаю результат 1.
[01:08:10.600 --> 01:08:15.480]  Когда я запускаю алгоритм, я могу заметить момент, когда он хочет остановиться. В момент,
[01:08:15.480 --> 01:08:20.000]  какой результат я не выдаю, я выдаю результат 1. А если он не останавливается,
[01:08:20.000 --> 01:08:30.800]  ну какого результата я не буду. То есть h точно перечислимо. Но я утверждаю, что оно неразрешимо.
[01:08:30.800 --> 01:08:44.880]  Для этого используется знаменитое диагональное рассуждение. От противного.
[01:08:44.880 --> 01:09:00.680]  Пусть у нас есть алгоритм, который разрешает, то есть вычисляет характеристическую функцию h.
[01:09:00.680 --> 01:09:09.080]  Тогда давайте построим другой алгоритм. Я ему номер сопоставлю h'. Он устроен так. Вычисляет
[01:09:09.080 --> 01:09:25.000]  на входе х, вычисляем p от x. И дальше так. Если p от x равно 0, то бесконечный цикл. Ну нам важно,
[01:09:25.000 --> 01:09:32.200]  чтобы результат был на фиге. Удобно говорить, что мы запускаем бесконечный цикл. Если p от x равно 0,
[01:09:32.200 --> 01:09:50.560]  то этот алгоритм выдаёт 1. И теперь у нас возникает проблема с тем принадлежит ли h'. Вот смотрите,
[01:09:50.560 --> 01:09:59.560]  что будет давать такой алгоритм. p' это его номер. Я описал алгоритм, это его номер. На себе само.
[01:09:59.560 --> 01:10:12.720]  Если это определено, смотрим на описание. Определено в том случае, когда p от x равно 0. Но
[01:10:12.720 --> 01:10:25.040]  p от x вычисляет характеристическую функцию h. Это означает, что у p' не принадлежит нашему
[01:10:25.040 --> 01:10:36.480]  множеству остановок. Ну, значит, результат должен быть неопределен. Когда у нас результат неопределен?
[01:10:36.480 --> 01:10:43.800]  Когда p от p', мы же запускаем в начале p, алгоритм начинания характеристической функции,
[01:10:43.800 --> 01:10:53.080]  равен единице. А это означает, что p' принадлежит нашему множеству, потому что единица означает,
[01:10:53.080 --> 01:10:57.200]  что мы характеристическую функцию вычисляем. Это означает, что p' принадлежит множеству.
[01:10:57.200 --> 01:11:07.960]  Получили противоречие. То есть, если бы у нас был алгоритм, который вычислял бы эту характеристическую
[01:11:07.960 --> 01:11:12.280]  функцию, мы могли бы его обмануть. Могли бы его запустить, построить другой алгоритм,
[01:11:12.280 --> 01:11:19.640]  который запускает этот алгоритм и потом ломает, меняет поведение на противоположье. И тогда в
[01:11:19.640 --> 01:11:30.280]  соответствующей точке, на диагонали p'-p', у нас возникает проблема. Ну все, я немножко задержался,
[01:11:30.280 --> 01:11:40.800]  прошу прощения. Вот это рассуждение, оно для вас, наверное, новое. Оно очень важное. И в следующий
[01:11:40.800 --> 01:11:48.480]  раз, я надеюсь, его повторить уже для конкретной модели вычисления. Чтобы, ну вот, мне говорили,
[01:11:48.520 --> 01:11:54.000]  что возникают какие-то сомнения. Вообще, вот такое изложение алгоритма в наивном уровне,
[01:11:54.000 --> 01:11:59.600]  оно оставляет у некоторых людей ощущение недосказанности. Потому что мы не зафиксировали
[01:11:59.600 --> 01:12:08.840]  определение. Всегда есть опасность, что мы где-то себя обманут. Ну, я постараюсь, чтобы для важных
[01:12:08.840 --> 01:12:18.080]  для меня теорем логических дырок не осталось. Но вот то, что я сегодня рассказывал, оно гораздо
[01:12:18.080 --> 01:12:23.360]  проще для понимания, то есть понять вот эти общие определения, разрешимого причину оно,
[01:12:23.360 --> 01:12:31.000]  что проще, если мы говорим в терминах наивного алгоритма, не фиксируя конкретную модель. Нам это,
[01:12:31.000 --> 01:12:36.320]  как видите, было особо не нужно. Все действия, которые мы выполняли, не очень сложные. Легко
[01:12:36.320 --> 01:12:42.720]  поверить, что они выполняются алгоритмами. А уж как этот алгоритм реализовать конкретные модели
[01:12:42.720 --> 01:12:49.240]  вычисления, это может быть непросто. В частности, если модель вычисления очень слабая, реализовать
[01:12:49.240 --> 01:12:56.960]  универсальные алгоритмы не так легко. Ну, даже написать транслятор си на си, если кто-то это
[01:12:56.960 --> 01:13:03.680]  делал, это уже задача. Есть, конечно, очень мощные языки программирования. Есть языки
[01:13:03.680 --> 01:13:10.720]  программирования, в которых транслятор с этого языка на этот язык занимает полстраницы распечатка.
[01:13:10.720 --> 01:13:15.480]  Настолько мощные языки программирования, что транслятор там задается очень быстро.
[01:13:15.480 --> 01:13:25.040]  Я своими глазами видел транслятор с рифала на рифале, и он действительно даже не полную страницу, а четвертую.
[01:13:25.040 --> 01:13:33.920]  Вот ладно, на этом все. Спасибо за внимание. В следующий раз продолжу.
