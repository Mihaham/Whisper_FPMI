[00:00.000 --> 00:11.100]  Мы остановились на выводе вот этого факта, да, и там
[00:11.100 --> 00:14.520]  были вопросы всякие про то, почему там что-то существует
[00:14.520 --> 00:26.280]  про спектральное разложение и про то, как нам это поможет
[00:26.280 --> 00:31.480]  в доказательстве принадлежности, ну совпадение множества.
[00:31.480 --> 00:37.560]  Так, да, напоминаю, что мы типа живем, сейчас пытаемся понять вот конусы, там
[00:37.560 --> 00:42.080]  сопряженные, вот определение у нас было, более-менее обсудили вот эти вот
[00:42.080 --> 00:49.160]  свойства, которые тут перечислены. Помнят? Помните, да, было такое? На семинарах это уже
[00:49.160 --> 01:01.440]  было, наверное. Почему вот это что, конус или выпуклый конус? Ну вот давайте возьмем
[01:01.440 --> 01:06.440]  любой элементик и наположительное число умножим. Вы получите какой-то новый
[01:06.440 --> 01:09.400]  игр, который тоже этому будет удовлетворить, потому что вы наположительное число
[01:09.400 --> 01:14.480]  умножаете обе части неравенства, у вас ничего не портится. Просто по определению.
[01:14.480 --> 01:25.640]  Берете, поставляете, получаете победу. Так, еще вопросы? Так, вопросов нет, окей. Да,
[01:25.640 --> 01:32.840]  значит, мы остановились на том, что вот про Rn+, вроде стало всем очевидно, почему
[01:32.840 --> 01:42.080]  он самый сопряженный. Все еще очевидно или надо повторить? Вроде понятно. Всем
[01:42.080 --> 01:54.240]  понятно или нет? А завтра? Что-что? Давайте, ну смотрите, у нас есть, ну надо пару слов
[01:54.240 --> 01:58.280]  просто сказать, я не знаю, честно говоря. Так, сейчас погодите, последняя попытка заставить
[01:58.280 --> 02:09.320]  эту штуку работать. Не знаю, ничего не происходит. У нас есть вектор, у которого все
[02:09.320 --> 02:17.240]  элементы неотрицательные, и нам нужно как бы найти такой набор векторов, что скалярные
[02:17.240 --> 02:21.560]  произведения с этими векторами будут всегда неотрицательными. Ну то есть, если
[02:21.560 --> 02:25.040]  у вас вы возьмете все вектора с неотрицательными элементами, то сложение
[02:25.040 --> 02:30.600]  положительных чисел даст вам положительное число, ну не отрицательное. Или надо написать,
[02:30.600 --> 02:38.960]  или на слух тяжело. Окей, тогда допустим, есть вектор, у которого какая-то компонента отрицательная.
[02:38.960 --> 02:49.680]  Тогда взяв вектор из нашего конуса с элементами 0,0,0 и 1 в нужной нам позиции,
[02:49.680 --> 02:54.280]  мы получим отрицательное число противоречия, поэтому включение в обе стороны.
[02:54.280 --> 03:01.960]  Это, собственно, простые рассуждения про Rn+. Абсолютно такие же рассуждения работают и для
[03:01.960 --> 03:09.160]  второго конца, второго порядка. Я их расписывать не буду, пришлю PDF через пару дней, где все
[03:09.160 --> 03:13.920]  это будет детально написано, чтобы время не терять. Вот. Про Rn+, поинтереснее немножко,
[03:13.920 --> 03:24.040]  поэтому давайте я это все распишу. А всем видно вообще, что происходит? И плохо. Как? Нормально
[03:24.040 --> 03:35.200]  видно? Всем? Окей. Так, да, что? Так, это еще успеем. Так, ага. А, да, проблем, конечно, сейчас будет. Ну,
[03:35.200 --> 03:44.080]  ладно, пока. Пока вроде. Что там? А, ничего не видно. Ладно, пока вроде. Хватит, надеюсь. Ну,
[03:44.080 --> 03:50.320]  в общем, что хотим? Напоминаю, что у нас колярное произведение между матрицами записывается,
[03:50.320 --> 03:57.480]  как след от их произведения, такого хитрого. Тоже в прошлый раз было. Кстати, а так может
[03:57.480 --> 04:06.000]  лучше, чем на большом проекторе? Поднимите руки, кому так больше нравится. Так, ну, что-то
[04:06.000 --> 04:10.960]  меньшинству подавляющему, ладно. А, ну, наверное, когда светло, это действительно лучше, чем в
[04:10.960 --> 04:17.120]  большом проекторе. Ладно, осталось научиться это все на две доски разбивать, всем будет хорошо. Ладно,
[04:17.120 --> 04:28.960]  да, и нам надо показать, что утверждение такое, что S&+, сопряженное, это есть он сам. Вот, то есть
[04:28.960 --> 04:37.560]  надо показать, что если, первый факт, что если вы берете любую элемент из S&+, то это будет следовать,
[04:37.560 --> 04:44.800]  что скалярное произведение между X и Y больше либо равно 0 для любого X из S&+.
[04:45.040 --> 04:52.560]  Потому что вот это, это не что иное, как определение сопряженного конуса. Скалярное
[04:52.560 --> 04:56.440]  произведение отрицательно. У нас вот матрицы, скалярное произведение между ними определено
[04:56.440 --> 05:01.280]  на первой строчке, проверяем по определению. Это в одну сторону. Давайте это покажем, это не
[05:01.280 --> 05:10.320]  сложно. Так, ну, у нас есть вот эта штука. Ну, транспонирование пропало, потому что все симметрично,
[05:10.320 --> 05:19.840]  поэтому чтобы лишние не писать символы, все пропало. Вот. Раз так, то можно представить,
[05:19.840 --> 05:26.600]  да, все матрицы, там, правильные, симметрично положительно полуопределенные, то можно разложить
[05:26.600 --> 05:31.200]  вот эту самую матрицу X по, собственно, векторам. Вот таким хитрым образом. Так,
[05:31.200 --> 05:36.720]  лямбда ИТ, Q, ИТ, Q, ИТ транспонированы. Эта штука больше либо равно 0, это все на X
[05:36.720 --> 05:47.920]  умножается. Вот, то есть это X равно, ну, условно Q, лямбда, Q транспонированные. Вот, вот это вот
[05:47.920 --> 05:59.080]  равенство записано, да, а, ну вот, да, вот, вот, я в это опасался, что так сейчас оно и будет. Так,
[05:59.080 --> 06:13.800]  ладно, давайте. Пока... Вы узнаете как? Давайте, на что нажать? На это нажать? Давайте нажму. Нет,
[06:13.800 --> 06:26.600]  и без проблем, просто он вроде не работает. О, может надо сюда было нажать? Ага. А, погодите,
[06:26.600 --> 06:34.720]  так может... Не, наверное, наверное, да, нужен фон белый. Другая проблема. Сейчас, а что? Да,
[06:34.720 --> 06:41.840]  вот я могу теперь тут рисовать. О, стоп, сейчас. Блин, конечно, безумие, ну, ладно. Можно рисовать там,
[06:41.840 --> 06:48.040]  где могу рисовать я. Ну, короче, нет, это плохо совсем будет, слушайте, не пойдет. Ладно, в общем,
[06:48.040 --> 06:51.920]  мы и разобрались, как включать эту штуку. Потом можно будет на презентацию просто переключить,
[06:51.920 --> 06:56.000]  и все заработает. Ладно, дело не в этом. Дело в том, что я хотел зарядку подключить,
[06:56.000 --> 07:09.920]  чтобы экран не гац. Нет, все это, все это какое-то болестрадание. Так, так, ну что, дотянется?
[07:09.920 --> 07:31.560]  Так, да, понятно. Да, да, да, вот сейчас как раз я ждал этих вопросов. Ну, смотрите, вот эта штука,
[07:31.560 --> 07:40.920]  это диагональная матрица, лямдами на диагонали, упорядоченными балбубаниями. Ну, Q это матрица,
[07:40.920 --> 07:46.320]  ну, вот я тут сейчас могу немножко запутаться, но в целом это либо строки, либо столбцы матрицы Q,
[07:46.320 --> 07:53.400]  это QIT. Вот, и вы просто если распишете вот эту штуку в виде суммы произведений матриц ранга 1
[07:53.400 --> 08:02.240]  на лямды и вы получите ровно это. Помогло? Спектральное разглажение по собственным векторам
[08:02.240 --> 08:09.560]  раскладываем. В базе там существует. Вот, поскольку х изо стан плюс, то все лямды не отрицательны.
[08:09.560 --> 08:33.680]  Напоминаю, да, и тут вот так. Так, окей. Вопросы? Ну, короче, вот так. То есть,
[08:33.680 --> 08:42.360]  начиная с самого большого. Там все живы? Окей. Короче, вот. Сорри, если я оговорился. Ну вот,
[08:42.360 --> 08:52.320]  дальше пользуемся линейностью следа. Что значит? Значит, что вот так можно записать. Ну, тут лямды
[08:52.320 --> 09:03.360]  ты, понятно, можно вынести. Останется вот так. Вот. Ну, а дальше говорим, что след АВ равен следу БА.
[09:03.360 --> 09:15.600]  Это как бы факт известный, я надеюсь. Вот. Поэтому с силой этой штуки у вас след будет переписан как
[09:22.320 --> 09:35.680]  понятно почему да вот ну не сложно увидеть что первых вот это число а во вторых это еще и не
[09:35.680 --> 09:42.720]  отрицательное число потому что у тоже положительно полуопределено но вот эту штуку больше либо равно
[09:43.320 --> 09:53.640]  все это вместе тоже больше 0 в одну сторону показали так понятно почему справедливо первое неравенство
[10:02.920 --> 10:08.960]  а что с размерностью при все произведения существует
[10:12.880 --> 10:18.960]  ничего не квадратная а вот здесь у вас что какие-то требования на квадратность разве есть
[10:18.960 --> 10:25.760]  а это все это на двести это не очевидно что для любых матриц это выполнена окей вопрос понятен
[10:25.760 --> 10:41.880]  ну давайте что такое АВ АВ коэффициент ИЖ АИКВКЖ сумма пока от одного там до П не знаю это было
[10:41.880 --> 10:51.800]  я надеюсь замечательно что ко след след матрицы ц это сумма диагональных элементов
[10:57.960 --> 11:08.080]  давайте это соединим вместе эти два факта и поймем что след от АВ это сумма
[11:08.080 --> 11:30.200]  так а и к б к и и равно же я просто приравнял ничего не произошло а сумма по и пока понятно
[11:30.200 --> 11:43.200]  да вот так ну понятно что мы можем теперь сказать что ну поменять просто местами а и б и у нас
[11:43.200 --> 11:57.240]  получится ровно то же самое только для б а стало ли понятнее все супер так ну в итоге 1 1 включение
[11:57.240 --> 12:04.040]  получили так прекрасно давайте теперь другую сторону покажем но в другую сторону пока
[12:04.040 --> 12:19.840]  палки да как всегда как бы другую сторону показывать ебут идеи
[12:29.840 --> 12:30.240]  ну-ка
[12:34.040 --> 12:40.440]  не все очень просто давайте как это когда мы смотрели на rn плюс у нас была идея противно
[12:40.440 --> 12:45.480]  показать но давайте предположим что у нас есть некоторые матрицы так вторая второе так это было
[12:45.480 --> 12:50.840]  первое наверное где-то я написал первое второе пусть существует некоторая матрица y чертой
[12:50.840 --> 12:58.480]  которая в этом конусе не лежит и проверим может ли она может ли она принадлежать сопряженному
[12:58.480 --> 13:05.720]  конусу короче говоря вот для этого надо проверить что короче пока ничего не проверять вопрос
[13:05.720 --> 13:15.480]  принадлежит ли там да принадлежит ли сн плюс а звездочкой это вопрос ну смотрите поскольку она
[13:15.480 --> 13:23.560]  не положительно полуопределена что это значит и значит найдется некоторый вектор q с крышкой
[13:23.560 --> 13:29.440]  такое что q с крышкой транспонировано y чертой q с крышкой меньше нуля
[13:29.440 --> 13:40.240]  какой-то найдется вот дальше немножко на гостей за руками вот эта штука это число да это понятно
[13:40.240 --> 13:51.200]  я надеюсь вот ну можно на него навесить операцию взять от следа ничего не поменяется вот в общем
[13:51.200 --> 13:57.720]  ничего вроде все все вроде пока нормально а дальше воспользовавшись тем же самым ну и
[13:57.720 --> 14:03.280]  это число меньше нуля данная воспользовавшись тем же самым выражением мы получим что это след
[14:03.280 --> 14:13.320]  который вот так вот вот это некоторая матрица x с крышкой да это штука меньше нуля и матрица
[14:13.320 --> 14:23.680]  x с крышкой внезапно лежит в нашем конусе сн плюс вопрос понятно ли почему что вот хорошо кому-то
[14:23.680 --> 14:35.520]  понятно почему она ну почему она симметрично здесь очевидно или нет правила про транспонирование
[14:35.520 --> 14:41.840]  произведения все помнят хорошо почему она положительно полуопределена теперь
[14:41.840 --> 14:45.960]  по всеку не ранг
[14:45.960 --> 14:58.560]  ранг 1 конечно вот ранг такой матрица 1 можете по определению то можно проверить но в целом
[14:58.560 --> 15:06.320]  это общее такое правило что если у вас у вас матрица какая-то ув где у это вот такая ска
[15:06.320 --> 15:16.960]  столбцами а вы это вот такая ска строками то ранг ув такой равенка вот ну и поэтому есть по
[15:16.960 --> 15:24.440]  определению просто подставить что какой-нибудь у транспонированная куз крышкой куз крышкой
[15:24.440 --> 15:30.640]  транспонированная у есть не что иное как у с крышкой транспонированная у в квадрате что
[15:30.640 --> 15:38.120]  больше вернули все победа подставили получили вот ну и соответственно получить в итоге
[15:38.120 --> 15:46.200]  противоречие потому что противоречие потому что мы нашли такую матрицу x крышкой из нашего
[15:46.200 --> 15:51.800]  конуса для которой наше скалярное произведение отрицатель на эти противоречие определению
[15:51.800 --> 15:52.560]  спряженного конуса
[15:57.560 --> 15:58.400]  понятно что произошло
[16:05.320 --> 16:09.040]  так вопросы по шагам которые мы провели
[16:19.040 --> 16:20.280]  так все
[16:22.280 --> 16:29.800]  кто переписывает переписали да так да окей это мы закончили про сам спряженные конусы на
[16:29.800 --> 16:35.320]  самом деле конусов которые нам будут полезны чуть чуть больше там еще плюс один плюс два и мы
[16:35.320 --> 16:41.080]  с ними встретимся когда будем соответствующие задачи обсуждать значит помимо просто конусы
[16:41.080 --> 16:47.560]  есть еще типа немножко более такое емкая предъемка понятия правильный конус вот который
[16:47.560 --> 16:52.280]  содержит себе все нужные нам свойства собственно так и называется то есть будем
[16:52.280 --> 16:56.520]  называть конус правильным если он выпуклый замкнутый прямых не содержит и внутренность
[16:56.520 --> 17:06.520]  не пустая вот то есть ну для чего сейчас увидите ну то есть не содержит прямых это то есть типа
[17:06.520 --> 17:15.400]  рн нам не подходит типа такого что-то вот ну и собственно да в общем прожмение покажите
[17:15.400 --> 17:26.680]  что все то что было до этого удовлетворяет всем этим требованиям вот но у вас есть типа выпуклый
[17:27.680 --> 17:42.680]  рн выпуклый конус прямые содержит вот рн не подходит вот в общем да основной вопрос который
[17:42.680 --> 17:48.920]  обычно возникает в этом месте это зачем все это надо это множество наворотили там сопряженные что-то
[17:48.920 --> 17:57.520]  сложно непонятно что зачем это все делается вот в общем магия в том что если конус правильный то
[17:57.520 --> 18:04.280]  с помощью конусов можно вводить отношение порядка то есть заменять стандартные неравенства
[18:04.280 --> 18:12.040]  которым все привыкли на число прямой на неравенство относительно конуса вот то есть если написано вот
[18:12.040 --> 18:18.960]  так что один элемент меньше либо равен другого по отношению конусу то это значит что их разность
[18:18.960 --> 18:25.680]  лежит в конусе ну что довольно понятно что мы просто x переносите сюда и получается что если
[18:25.680 --> 18:34.560]  что-то какой-то вектор больше либраем смысле конуса то он ему принадлежит вот ну понятно что если
[18:34.560 --> 18:44.160]  конус обычный рн плюс то мы получаем стандартное определение на число прямой вот если же конус
[18:44.160 --> 18:49.140]  например типа конус положить на плюных матриц то одна матрица больше либо другое по отношению к
[18:49.140 --> 18:55.000]  этому конусу значит что их разность принадлежит этому конусу то есть поэтому не пугайтесь если вы
[18:55.000 --> 19:00.960]  вдруг увидите что там пишут что типа одна матрица меньше либо равно в смысле определенности другой
[19:00.960 --> 19:06.840]  матрице это значит просто что их разность положительно там и отрицательна полупределена вот то есть
[19:06.840 --> 19:13.480]  понятно что есть отдельная операция по компоненту но но она встречает достаточно редко и ну в общем
[19:13.480 --> 19:20.000]  ее довольно легко отличить вот ну собственно если у вас было стандартно зачленено программирование
[19:20.000 --> 19:27.560]  то она переписывается в таком вот виде то есть мы ограничение на x не на отрицательность x просто
[19:27.560 --> 19:35.240]  заменяем на то что x конусе лежит в нужном нам вот в rn плюс например вот ну и соответственно вся
[19:35.240 --> 19:43.400]  эта как бы вся эта машинерия была ну проделывалась свое время ровно ради того чтобы сказать что вот
[19:43.400 --> 19:50.120]  если у нас для линейного программирования такая вот аналогия то в общем случае нам нужно что-то
[19:50.120 --> 19:56.880]  про общий вид выпуклых задач сказать то достаточно вот здесь вот rn плюс на другой
[19:56.880 --> 20:02.120]  какой-то конус заменить и все будет работать вот то есть мы как бы там 10 десятки лет потратили
[20:02.120 --> 20:07.960]  на то чтобы теорию для вот этого разработать а потом чтобы как бы не перелопачиваться теорию
[20:07.960 --> 20:15.120]  с нуля для когда здесь что-то нелинейное здесь что-то нелинейное но выпуклое вот то мы просто
[20:15.120 --> 20:20.800]  скажем что давайте мы как бы научимся автоматически более менее сводить произвольную задачу которую мы
[20:20.800 --> 20:28.720]  видели на одном из там первых слайдов на первой лекции к задачи когда у нас минимизируется
[20:28.720 --> 20:36.840]  линейная функция при линейных ограничениях равенствах и искомый вектор будет лежать в некотором конусе и
[20:36.840 --> 20:44.200]  вот вся нелинейность которая у нас там возникнет в процессе моделирования она уйдет в конус вот
[20:44.200 --> 20:52.520]  то есть давайте сейчас это довольно не сложно показать почему можно привести всегда к целевой
[20:52.520 --> 21:01.720]  функции которая будет линейна почему можно привести любое ограничение так что да почему
[21:01.720 --> 21:15.920]  можно привести любую вот такую задачу к тому что вот здесь вот это ограничение можно избавиться
[21:15.920 --> 21:20.840]  и сказать что вот такое ограничение будет эквивалент на тому что какой-то вектор будет
[21:20.840 --> 21:26.640]  лежать в конусе это мы поймем в следующий раз там про выпуклое функции будет отдельное специальное
[21:26.640 --> 21:33.440]  свойство который будет это нам обеспечивать вот сейчас поймем почему от fx можно избавиться вот
[21:33.440 --> 21:41.440]  ну так вроде бы про прообразование задачи еще не говорила если если вдруг это уже было вы
[21:41.440 --> 21:49.400]  сейчас скажете мне ну идея основная в том что если у вас вот такая вот задача есть то это то
[21:49.400 --> 22:02.240]  же самое что и минимизировать число при условии что ваша целевая функция число не превосходит вот
[22:02.240 --> 22:14.560]  ну и соответственно эта штука уже линейна все хорошо понятно ли почему это одно и то же или
[22:14.560 --> 22:18.160]  нужно нарисовать картинку я вообще уже это рассказывал
[22:18.160 --> 22:33.440]  видимо не рассказывать так нужно ли пояснять давайте замечательно ну смотрите и девочка
[22:33.440 --> 22:39.480]  простая вот изначально у нас например с какой-то функции и мы хотим ее минимум найти да вот такая
[22:39.480 --> 22:44.200]  вот и вот мы как бы идем по иксам и спокойно ищем какой-то вот здесь вот
[22:44.200 --> 22:49.080]  икс со звездочкой и тут соответствующие фат икс со звездочкой это как бы исходно
[22:49.080 --> 22:57.080]  постановка вот вместе с тем мы можем делать следующие та же самая функция вот но теперь
[22:57.080 --> 23:04.240]  у нас тут будет т а тут будет икс и выбрав каждый раз новое т и по красным давайте буду отмечать
[23:04.240 --> 23:12.040]  вот мы такие окей вот давайте теперь для вот этого t у нас иксы допустимые лежат вот здесь и
[23:12.040 --> 23:20.640]  окей это вот наши ну как бы для такого t наши допустимые иксы вот тут теперь можем ли мы взять
[23:20.640 --> 23:28.160]  т поменьше чтобы такие иксы что f от x меньше левернуте нашлись ответ да давайте возьмем
[23:28.360 --> 23:35.680]  вот здесь теперь у нас допустимые иксы вот тут лежат ну в общем и так далее минимизируя вот
[23:35.680 --> 23:41.760]  эту вот эту линию как бы уровней мы так или иначе придем в ту же самую точку в которой будет
[23:41.760 --> 23:49.960]  достигаться равенства так понятно почему это одно и то же теперь или еще надо что-то сказать
[23:53.960 --> 24:02.280]  то есть здесь мы сейчас секунду да то есть здесь мы ищем просто f от x как собственно образ ну
[24:02.280 --> 24:08.600]  минимизация минимум некоторые функции как таковой а тут мы ищем такое число которое больше
[24:08.600 --> 24:14.520]  либо равно чем это функции и по всем иксам и т то есть как бы увеличиваем размер на единицу и
[24:14.520 --> 24:28.200]  смотрим на сам график функции как на еще одну переменную так вопросы да вроде правильные
[24:38.680 --> 24:44.600]  почему равно будет как почему будет больше
[24:48.160 --> 24:56.720]  для фиксированного t ну вот я же нарисовал видите вот тут вот для этого t допустим и иксы вот тут
[24:56.720 --> 25:04.400]  лежат уменьшает и вы будете сужать допустимость иксов и в точке минимум вы найдете только икса
[25:05.400 --> 25:11.920]  а то что там типа функции еще где-то при дна вас от не волнует у вас же т фиксировано так все супер
[25:11.920 --> 25:20.720]  так мы все перейдем перерыв давайте и потом понятно приблизительно так чего да то есть такая
[25:20.720 --> 25:26.920]  штука дает нам линейную целевую функцию при наличии вот этих ограничений и еще каких-то возможно
[25:26.920 --> 25:36.680]  вот этих вот что делать с ними в следующий раз я надеюсь успеем вот так покей едем дальше так
[25:36.680 --> 25:45.440]  дальше немножко пару слов про отделимость это нам понадобится в одном месте ближе к середине октября
[25:45.440 --> 25:53.840]  наверное вот значит два множества отделимые если в общем предельно простое определение два
[25:53.840 --> 26:00.400]  множества наделимый если есть гибер плоскость которая их разделяет ничего удивительного вот
[26:00.400 --> 26:05.800]  то что она их разделяет означает выполнимость двух неравенств для любой тот любых точек из
[26:05.800 --> 26:11.240]  одного множества есть другого множества то есть вектор а нормальный вектор б ну понятно сдвиг
[26:11.240 --> 26:27.600]  нет не хотим возможно хотим приписать что-нибудь типа сейчас что для любой точки из объединения
[26:27.600 --> 26:37.160]  этих множеств короче она не лежит на гибер плоскости наверное вот это надо приписать но
[26:37.240 --> 26:49.040]  не важно ну нам такие тонкости будут не столь существенно вот так ну две теоремы собственно
[26:49.040 --> 26:55.280]  доказательства которых я тоже вышли в пдф ки что если есть выпукло не пересекающиеся множество
[26:55.280 --> 27:11.120]  то они отделимы очень просто вот ну и второе что как бы вот этот ток в одну сторону вот для
[27:11.120 --> 27:18.880]  того что получилось другую надо потребовать открыться одного из этих множеств вот ну
[27:19.080 --> 27:25.480]  я надеюсь что кондор пример вот здесь не сложно привести про ну выпукло множество
[27:25.480 --> 27:41.440]  которые отделимы но пересекаются вот громче что именно первое и второе первое непонятно
[27:41.440 --> 27:51.640]  а смотрите есть два множества они как-то там расположены в рн вот они не пересекаются вот и
[27:51.640 --> 27:57.760]  вот за счет этого того что они выпукло то что они не пересекаются можно конструктивно построить
[27:57.760 --> 28:03.040]  ну либо конструктивно построить либо указать на существование вот собственно вот этого вот
[28:03.040 --> 28:12.400]  вектора и вот этого числа такого что вот это будет выполнено ну я могу картинку нарисовать
[28:12.400 --> 28:20.240]  может быть поможет так где тут картинка доска но вот условно есть у вас квадратик есть кружочек
[28:20.240 --> 28:27.840]  вот они не пересекаются они выпуклые вот и вот есть точно гибер плоскость который их разделяет
[28:27.840 --> 28:37.560]  ну то есть по одну сторону для одного элемент подобного что у вас отрицательная не отрицать
[28:37.560 --> 28:44.760]  неположительное значение на линии функции а тут не не положительная не отрицательный
[28:44.760 --> 28:55.760]  положительный да вот ну и я думаю доказательства вот для такого случая когда они замкнуты и не
[28:55.760 --> 29:10.320]  пересекаются совсем простое кто понимает какое нет смотрите вот случаи когда они замкнуты не
[29:10.320 --> 29:24.960]  пересекаются вот не пересекаются причем ну вот как бы сейчас понятно лишь то я хочу понятно
[29:24.960 --> 29:31.240]  чем какой есть пример когда множество не пересекаются но не совсем вот так как здесь
[29:31.240 --> 29:41.080]  нет замкнутость ну да типа вот вот такая вот такую ситуацию пока не хочется рассматривать
[29:41.080 --> 29:47.160]  когда у вас ветка парабол и вот здесь вот и втором но что вот здесь вот они вроде как не
[29:47.160 --> 29:54.400]  пересекаются но но и там их короче вот здесь вот у них там бесконечно не близки друг другу понятно
[29:55.400 --> 30:04.080]  вот ну здесь можно сказать очень простые слова что раз они выпуклые и замкнуты то найдутся две
[30:04.080 --> 30:10.640]  точки расстояние между которыми минимально ну на границе где-то вам удобно так сидеть
[30:10.640 --> 30:23.000]  окей вот ну и соответственно вы их находите проводите прямую их среду отрезок их соединяющий
[30:23.000 --> 30:30.240]  берет серединку проводить перпендикуляр получаете результат нужный конец вот собственно это общая
[30:30.240 --> 30:38.760]  идея формально я это формальности будут приведены в пдф так стало ли понятнее это замечательно так
[30:38.760 --> 30:46.760]  гуд так ну вот второй факт требует открытости для того чтобы было в одном в обе стороны ну
[30:46.760 --> 30:55.160]  собственно ровно ситуация когда типа два замка может касается в одной точке противоречит тому
[30:55.160 --> 31:04.360]  что первое утверждение было было бы обе стороны поэтому так окей это в каком-то месте нам
[31:04.360 --> 31:13.040]  понадобится с этим с отделимостью то есть да важный комментарий мы работаем в рэн отделимость
[31:13.040 --> 31:19.000]  у нас будет такая немножко игрушечная более основательная абстрактная делимость у вас будет
[31:19.000 --> 31:23.840]  функциональным аналитик когда вы будете там еще сепарабельные всякие множество рассматривать
[31:23.840 --> 31:30.720]  по моему они так называются вот там во всей красе это вся история всплывет вот значит лемма
[31:30.720 --> 31:38.480]  фаркаша это пример так называемых теориям об альтернативах их довольно много разных и все они
[31:38.480 --> 31:42.440]  формулируются одинаково ну собственно формулировка написано вот здесь первой
[31:42.440 --> 31:50.320]  нам первой строчки формулировки леммы вот и то есть даны некоторые две системы и утверждается
[31:50.320 --> 31:55.480]  что разрешима одна и только одна из них вот собственно поэтому теориям об альтернативах то
[31:55.480 --> 32:04.080]  есть либо одно либо другое тут как по нему одновременно быть не может давайте поймем почему это как-то
[32:04.080 --> 32:10.960]  связано со делимостью вот ну давайте для начала просто разберем систем что геометрически
[32:10.960 --> 32:18.000]  означает первое условие чтобы такое множество не пусто что это означает геометрически
[32:21.720 --> 32:26.120]  громче нет геверпольске тут пока нет
[32:26.120 --> 32:36.920]  где в нем это правда но что это замножится геометрически
[32:41.480 --> 32:48.320]  ну не совсем ну не напрямых пересечения но там под пространство все-таки наверное
[32:48.320 --> 32:50.200]  надо что-то сказать про это если вы так хотите
[32:56.200 --> 33:03.520]  да ну в общем пока вы не совсем про то думаете давайте я скажу в чем тут суть идея в том что
[33:03.520 --> 33:09.160]  вот если такое множество давайте как бы будем называть одни и те же вещи разными словами в
[33:09.160 --> 33:13.640]  надежде получить какое-то новое понимание происходящего вот это множество оно что
[33:13.640 --> 33:20.920]  означает это набор иксов да такие что они все не отрицательны это во-первых во-вторых
[33:20.920 --> 33:25.400]  линейная комбинация столбцов матрицы с ними с этими коэффициентами дает некоторую точку
[33:25.400 --> 33:38.320]  точка фиксировано так то есть это означает что вот эта точка b она лежит в некотором множестве
[33:38.320 --> 33:49.160]  которая образована вот так не отрицательными комбинациями столбцов матрица а давайте или не
[33:49.160 --> 34:02.560]  очень понятно осознали или что-то надо сказать что то есть у нас есть столбцы у нас есть точка
[34:02.560 --> 34:08.320]  ну собственно столбцы матрица и точку б и мы хотим понять найдутся ли такие коэффициенты
[34:08.320 --> 34:13.680]  с которыми надо взять эти самые столбцы причем коэффициенты не отрицательные чтобы мы получили
[34:13.680 --> 34:23.120]  точку b прекрасно теперь вопрос что это за множество вот этой столбцы матрицы
[34:23.120 --> 34:27.040]  а такие ну то есть какое множество получается задают столбцы матрица а
[34:27.040 --> 34:36.400]  нелинейная
[34:36.400 --> 34:49.240]  видите вот ограничение если бы не это было бы сумма равна там единицы в о это конус конечно то
[34:49.240 --> 34:52.640]  есть мы берем взяли там ка столбцов видите тут про размерность ничего не
[34:52.640 --> 35:00.000]  говорится взяли ка столбцов и сформировали их коническую оболочку получив все вектора
[35:00.000 --> 35:06.240]  которые представимы в виде ну и конечной комбинации вот и хотим понять будет ли
[35:06.240 --> 35:11.120]  там точка б лежать или не будет собственно альтернатива собственно в этом и заключается то
[35:11.120 --> 35:16.920]  есть у вас либо точка лежит в конусе либо она не лежит в конусе так третей ситуации быть не может вот
[35:16.920 --> 35:25.960]  смотрите у вас есть была матрица там ка столбцов вы взяли и сформировали множество которое
[35:25.960 --> 35:35.400]  стоит из векторов полученных с теми коническими комбинациями этих столбцов все то есть ну грубо
[35:35.400 --> 35:44.160]  говоря давайте я тоже картинку нарисую то есть допустим вот ой вот было у вас раз вектор и два
[35:44.160 --> 35:52.200]  вектор вот один столбец другой столбец там один один и че минус один один да и вот у вас все вот
[35:52.200 --> 35:58.960]  это вот и получится вот все то что между ними и там улетает ну понятно бесконечность вот то
[35:58.960 --> 36:09.840]  есть где тут какая-нибудь сриховка так вспоминаем линию алгебру что такое произведение матрицы на
[36:09.840 --> 36:19.760]  вектор то есть вот здесь матрица на вектор это взять столбцы с коэффициентами которые из
[36:19.760 --> 36:32.880]  элемента вектор на котором нажается так супер так да ну собственно поскольку у нас точка b она
[36:32.880 --> 36:39.360]  либо лежит в конусе либо не лежит а конус вот такой вот он выпуклый замкнутый там с нулем со
[36:39.360 --> 36:45.560]  внутренностью все как полагается то вспоминаем замечательные наши вот эти две теоремы что
[36:45.560 --> 36:54.720]  ну одно множество у нас это конус оно выпукло ну это легко проверить я надеюсь у вас все получится
[36:54.720 --> 37:00.240]  при необходимости а другой множество просто одна точка который выпукл по определению вот мы их
[37:00.240 --> 37:07.120]  можем отделить друг от друга гипер плоскостью вот и собственно следующее место будет занято тем
[37:07.120 --> 37:14.160]  чтобы понять как вектор гипер плоскости связан с вектором п который будет существовать и то
[37:14.160 --> 37:24.800]  почему константа которая здесь заявлена должна быть нулем вот ведь тут нет константа никакой
[37:24.800 --> 37:32.680]  вот почему это так сейчас будем будем разбираться но идея предельно простая то есть так
[37:32.680 --> 37:48.600]  так сейчас сейчас я секундочку то есть еще раз так ну то есть вот тут были какие-то столбцы там
[37:48.600 --> 38:01.080]  а1 а2 а3 вот и они как там конус образует еще у нас есть точка б вот и вот это 0 да и вот конус
[38:01.080 --> 38:08.840]  который натянут на вот эти вот столбцы он отделяется гипер плоскость от точки б вот
[38:08.840 --> 38:16.600]  это гипер плоскость есть нормаль какая-то впустим ц вот и надо понять как связан вектор
[38:16.600 --> 38:23.320]  п который должен существовать по утверждение вот этому вот вязан с тем вектором ц который
[38:23.320 --> 38:40.920]  будет в нормале что просите что именно да потому что бы не лежит в конусе это как бы следствие
[38:41.000 --> 38:51.440]  все очень просто так это я уже проговорил так вот собственно то что отделимость вот у нас
[38:51.440 --> 38:58.280]  есть вектор ц нормальный есть число d тин-тин тут вот на самом деле строгая делимость потому что
[38:58.280 --> 39:06.480]  там строгая делимость на самом деле вот это ну то есть строгая делимость вот в этом месте будет
[39:06.480 --> 39:12.640]  следовать напрямую доказательства на самом деле поэтому тут немножко посильнее утверждение чем
[39:12.640 --> 39:27.600]  да да да там на самом деле там этих отделимости что называется вагона маленькая тележка вот там
[39:27.600 --> 39:36.720]  есть строгая сильная как-то просто отделимость с сильной там по-моему что-то просуправим у инфиума
[39:36.720 --> 39:47.040]  скалярных произведений там своя наука немножко вот сейчас не так важно значит ну поскольку 0 лежит
[39:47.040 --> 39:53.480]  на нашем конусе а вот это условие выполн для любого элемента конуса то д больше нуля весь
[39:53.480 --> 40:03.000]  понятно вот ну и у нас наши направляющие столбцы матрица как из которых этот конус был построен
[40:03.000 --> 40:07.400]  вот они тоже ляжут в конусе поэтому если мы их умножим на положительное число тоже получим
[40:07.400 --> 40:16.800]  что-то из конуса ну и теперь если явно подставим произвольный элемент вида а икс для ненатрицательного
[40:16.800 --> 40:26.200]  икса в этом наши неравенства вот это то получим что ну в общем вот это ну поделим на альфу устреним
[40:26.200 --> 40:31.280]  альфа бесконечности плюс ну и получим предельный переход что эта штука мне должно быть меньше
[40:31.280 --> 40:38.480]  либо нуля быть потому что мы можем как бы бесконечно большое число умножать элементы с конусов получать
[40:38.480 --> 40:49.320]  элементы с конусов понятно то есть грубо говоря вот это будет работать для любого множества выпуклого
[40:49.320 --> 40:54.640]  но поскольку у нас конус то появляется моя специфика в том что можно каким числом может быть
[40:54.640 --> 40:57.720]  д что мы собственно проделываем
[40:57.720 --> 41:05.080]  c это вектор нормальной гибер плоскости
[41:13.080 --> 41:15.240]  вот c это то что здесь написано а
[41:15.240 --> 41:26.600]  что я сейчас будем получать погодите то есть пока нет как бы написано только то что написано не
[41:26.600 --> 41:30.800]  надо вот это п путать с тем ц к которому мы пока что просто существует некоторые векторы сейчас
[41:30.800 --> 41:36.080]  будем получать п для которого справедливо неравенство пока мы только как бы ну подходит скажем так хотя
[41:36.080 --> 41:52.280]  уже близко так а x равно b это не конус где-то написано что это конус а вот смотрите конус к
[41:52.280 --> 42:01.120]  образован столцами матрицы вот эта фраза означает что мы берем столбцы матрицы и формируем множество
[42:01.120 --> 42:09.280]  которое образовано взятием конических комбинаций этих столбцов то есть мы берем набор коэффициентов
[42:09.280 --> 42:14.400]  не отрицательных и складываем эти столбцы с этими коэффициентами там какие-то 0 какие-то
[42:14.400 --> 42:19.920]  положительные получаем некоторые множество вот я пытался нарисовать не очень успешно это нам
[42:19.920 --> 42:33.360]  конус к дает вот и дальше начинается игра с тем где лежит точка б ну именно так да поэтому в
[42:33.360 --> 42:37.000]  одном случае у нас тут больше нуля будет а в другом меньше либо равно потому что для конуса
[42:37.000 --> 42:51.280]  больше нуля да ну вот вот ну и соответственно взял возьмем п равноминусе получим вот это все
[42:51.280 --> 42:58.440]  просто ну то есть дальше все просто как только удалось избавиться от д и получить не не строгая
[42:58.440 --> 43:07.320]  неравенство то все хорошо дальше так вопросы просто нет
[43:07.320 --> 43:30.440]  шаг не странный шаг про то что если вы где-то ошиблись со знаком то ничего страшного не беда
[43:37.320 --> 43:44.280]  не смотрите еще раз утверждение какое будет сюда посмотреть выполнено одно и только одно первое
[43:44.280 --> 43:52.280]  означает вот это если оно не выполнено то выполнено вот это ну совместно быть не может
[43:52.280 --> 44:05.800]  собственно про это вся история так еще вопросы так давайте что где в каком конце вот тут а что
[44:07.360 --> 44:08.240]  вот здесь непонятно
[44:13.000 --> 44:19.840]  ну подставьте просто ну что вы ну смотрите что-то как бы пт на а я понял вопрос пт на а это что
[44:19.840 --> 44:28.680]  такое это умножение вектора п на каждый столбец матрицы что мы здесь и видим
[44:28.680 --> 44:40.240]  ну а знак просто бы совпадал вот то что здесь написано ну например здесь вы ошибли там забыли
[44:40.240 --> 44:47.600]  перепутали ничего страшного взяли минус все получилось он существование показать да вот это
[44:51.600 --> 44:57.800]  нет ну вот смотрите вот вот здесь непонятно хорошо альфа стремится к бесконечности потому
[44:57.800 --> 45:05.440]  что у нас для конуса для любого положительного альфа выполнена принадлежность так ну а дальше
[45:05.440 --> 45:15.120]  у нас есть вот это условие ики поэтому чтобы для любого элемента из конуса это было выполнено
[45:15.120 --> 45:21.000]  нам нужно как бы ну мы берем альфа и бесконечно устремляем и тогда у нас это будет занулиться
[45:21.000 --> 45:32.480]  благополучно да что мы получаем вот здесь до 0 ну и собственно вот этот молик он отсюда и берется
[45:41.200 --> 45:46.040]  именно так но вот отсюда у нас есть два уплых множества и не пересекают с одного
[45:46.040 --> 45:53.000]  уплых множества это конус второе уплых множество это точка они там замкнут и с ними все хорошо
[46:02.240 --> 46:12.960]  нет нет нет наоборот наоборот вот это второе слово точка не лежит в конусе а первая точка лежит в конусе
[46:16.040 --> 46:20.080]  поэтому существует икс который ее представляет через столбцы
[46:24.880 --> 46:26.640]  так еще вопросы
[46:35.200 --> 46:39.440]  просто да ничего сильно нового не произошло
[46:39.440 --> 46:52.880]  так окей приложение ну давайте приложение пропустим если будут вопросы в следующий
[46:52.880 --> 46:58.320]  раз можно по этому подробнее поговорить вот приложение из финансов про то как
[46:58.320 --> 47:04.600]  устанавливать цены на активы так чтобы была гарантирована выигрышная стратегия звать
[47:05.600 --> 47:12.600]  вот сводится к некоторой сдачи по выбору цены и ее границ определение полного рынка тоже может
[47:12.600 --> 47:19.680]  быть кому-то встретиться связано именно с этим вот так но в общем мы обсудили наконец-то что
[47:19.680 --> 47:24.840]  такое спряженные конусы и какая у него геометрическая интерпретация про векторы которые
[47:24.840 --> 47:30.160]  образуют не отрицательные углы с любым вектором из конуса осознали что такое самый спряженные
[47:30.800 --> 47:37.520]  их финансов cater и как в принципе что-то делать поэтому может что-то выводить по
[47:37.520 --> 47:43.760]  Lakani в folding и про отделение особо говорили даже периодические деление тоже будет сплывать
[47:43.760 --> 47:49.120]  поэтому в общем такая тема потому с чем эта отделимость такая странная тема которая
[47:49.120 --> 47:52.880]  как бы кажется не нужной неважная потом самое ответственный момент она оказывается
[47:52.880 --> 47:58.680]  основым ключом который позвол Obi-inate доказать как бы это странно не показалась в общем немного
[47:58.680 --> 48:03.800]  вот обычно если что-то сложное то оно как бы в виде начинает всплывать а тут как бы вроде не
[48:03.800 --> 48:14.320]  очень конкретно но в виде надо оказывается так это по конусам и их спряженным так вопрос
[48:14.520 --> 48:16.080]  есть в целом по блоку
[48:24.920 --> 48:32.200]  так вопросов нет все понятно замечательно так ладно ой я тут забыл кое что дописать ну ладно
[48:32.200 --> 48:39.320]  пишу короче говоря вторая половина которая закончится через 15 минут вот будет про то что
[48:39.320 --> 48:48.680]  такое градиенты десианы и как их считать легко и свободно что называется вот значит сначала
[48:48.680 --> 48:54.000]  определение простой дифференцируемый функции думаю все знают что значит найдет такой вектор
[48:54.000 --> 49:00.880]  что тут такой вот предел к нулю равен нулю область определения а int это внутренность
[49:00.880 --> 49:08.960]  вот проверить что такой вектор единственный несложно от противного насколько я помню
[49:08.960 --> 49:16.500]  это делается вот еще одно тоже простое упражнение покажите что производная по направлению равна
[49:16.500 --> 49:26.520]  скалярному произведению скалярному произведению градиента на это направление вот тут напоминание
[49:26.600 --> 49:34.440]  простой упражнение это не сложно вот десиан это матрица вторых производных да тут я тут я
[49:34.440 --> 49:40.640]  добавлю еще это определение прошу прощения ну как хотите хотите два слова назовите хотите одно я
[49:40.640 --> 49:52.560]  предпочитаю одно нет ну хешин матрикс ну более-менее более-менее стандартное обозначение то есть
[49:52.560 --> 50:07.440]  матрица аж от икс наверное да с компонентами и и жи это д ой д 2 f под икс и д икс жи вот в общем
[50:07.440 --> 50:14.000]  мы ее будем следующей лекции активно использовать потому что она нам будет говорить давать всю
[50:14.000 --> 50:20.400]  информацию о выпуклости функции которая которая которую можно дважды непрерывно продеференцировать
[50:20.400 --> 50:29.440]  короче вот так да в общем как посчитать градиент можно можно по-разному можно аналитически вот по
[50:29.440 --> 50:38.320]  определению например ну почти по определению вот то есть берете считаете значение функции скаляр да
[50:38.320 --> 50:44.960]  это важно чтобы это был скаляр по элементу вектора как по ком той компоненте компонента градиента
[50:44.960 --> 50:52.160]  которого будет получаться на семинарах кто-нибудь уже что-нибудь подобное считал но вот кто-то считал
[50:52.160 --> 51:04.240]  но не очень много видимо так понять он первый способ или на такой пример привести что-то все
[51:04.240 --> 51:17.280]  молчат вот там молчат тут молчат люди вы там живы аллё нет понятно или нет как считать понятно
[51:17.280 --> 51:28.040]  хорошо все так а вы что как у вас тут дела да да да да да я просто доделал вот по дороге сюда
[51:28.040 --> 51:36.920]  поэтому еще не залил вот так окей это понятно второй понятно можно численно посчитать взять
[51:36.920 --> 51:46.560]  маленькое число аж на компьютере там 10-6 вот и поменять x на чуть-чуть аж умножить на соответствующий
[51:46.560 --> 51:53.840]  орд включать разность поделить наш получить какое-то приближение элемента градиента вот
[51:53.840 --> 51:58.960]  собственно вся все дефуры урмоты и прочее отчасти на этом строится что это хорошо неплохая
[51:58.960 --> 52:05.160]  практимация в каком-то там смысле а вот ну в общем тут проблем с устойчивость со скоростью не
[52:05.160 --> 52:09.960]  самый хороший способ но какое-то время назад и сейчас там некоторые методы они основаны вот
[52:09.960 --> 52:14.840]  на вот такой вот истории что мы не хотим считать градиент это может точно это может быть сложно
[52:14.840 --> 52:20.120]  и долго но нам дешево функцию посчитать давайте посчитаем 2 2 значения функции вычтем поделим и
[52:20.120 --> 52:31.320]  будем считать что это в принципе не так плохо вот так окей понятный способ третий способ
[52:31.320 --> 52:36.280]  называется символи на вычисления вот тут можно посмотреть больше примеров идея в следующем что
[52:36.280 --> 52:42.920]  вы задаете некоторые типа символи ну кто не значит символи вычисления так понятно в общем так
[52:42.920 --> 52:47.840]  хорошо кто-нибудь пользовался в альфа рамом так отлично в общем король с когда вы пользовались
[52:47.840 --> 52:57.000]  в альфа рамом то он проводит именно это вот он вы задаёте ему там переменные вот и ну
[52:57.000 --> 53:02.360]  набор правил вы не задаете они там внутри есть вот вызываете правильные функции ну типа функции
[53:02.360 --> 53:08.080]  которые там определены говорите хочу производно от sin x по переменной x x это там некоторые типа
[53:08.080 --> 53:14.920]  некоторая переменная которая свой тип имеет он вам выдает функцию которая как бы этой штуке равна
[53:14.920 --> 53:19.360]  вот можно типа tangents по x продеференцировать он вам выдаст вот такое странное выражение
[53:19.360 --> 53:36.240]  заметьте что это не совсем то к чему все привыкли почти вот значит он возвращает насколько я помню
[53:36.240 --> 53:42.600]  функцию который можно подать ну такой объект ну понятно что он так напечатал потому что метод
[53:42.600 --> 53:49.240]  как как метод предопределен поэтому он и так напечатал вот но он выдает некоторые объект
[53:49.240 --> 53:52.680]  который можно отправить другой объекту посчитать какое-то значение то есть типа
[53:52.680 --> 53:58.240]  такая вот странная штука короче подробности вот по ссылке можно будет посмотреть вот ну и
[53:58.240 --> 54:01.800]  последнее самое главное это автоматическое дифференцирование который мы оставшие 10
[54:01.800 --> 54:11.400]  слайдов я надеюсь успеем вот про то как все это работает в общем да вот здесь все сложно в общем
[54:11.400 --> 54:16.920]  случае на самом деле тяжело там и не всегда устойчиво сколько я помню в общем это все а
[54:16.920 --> 54:25.560]  вот это вот в принципе более менее надо пользоваться чего
[54:41.400 --> 54:52.560]  так спасибо за историческую справку окей ладно ну вот вот вот набор ингредиентов которые вот
[54:52.560 --> 54:57.960]  есть вот здесь вот хотя бы ну можете посмотреть я как бы про кастомную сейчас будет короче
[54:57.960 --> 55:02.840]  автоматизм дифференцирование как работает основа называется почтительный граф причем
[55:02.840 --> 55:11.400]  это не просто граф но направленный без циклов в общем идея следующим вот у нас есть какая-то
[55:11.400 --> 55:20.120]  функция более менее практически важная вот и мы почти всегда ее можем разбить на кусочки супер
[55:20.120 --> 55:30.320]  позиции которых она является понятно да я надеюсь идея вот ну и дальше мы можем оснастить ну да
[55:30.320 --> 55:36.160]  пример какой-то будет типа простейшие функции вот типа супер позиции трех функций а икс минус
[55:36.160 --> 55:42.800]  б вторая норма квадрат можно еще конечно сделал типа одна функция которая делает перемножать
[55:42.800 --> 55:49.200]  матрицу на вектор другая функция вещать разность векторов ну короче понятно как это все получается
[55:49.200 --> 56:07.040]  да так хорошо как градиент почитать по иксу как это называется так правила из мотонализа да
[56:07.040 --> 56:12.000]  сложная функция правильно получаем сложную функцию для вычления для вычления градиента по иксу
[56:12.000 --> 56:22.240]  нам в итоге надо знать то как что как от параметров зависи ну то есть производную
[56:22.240 --> 56:28.080]  каждой этих функций а потом правильно ордом их скомбинировать это собственно и происходит то есть
[56:28.080 --> 56:35.720]  если у нас есть такая вот функция пока что внутренно внутренность который отображает в
[56:35.800 --> 56:43.560]  то здесь у нас даже у по ну в общем произведение такое где даже по ду это понятное число а до
[56:43.560 --> 56:50.200]  под икс это вектор или матрица если у вас объект и функции от матрицы у нас такое будет немного
[56:50.200 --> 57:01.280]  иногда вот ну типа ладно пока не буду говорить это вы испугаетесь да очень важно смотреть на
[57:01.280 --> 57:06.480]  размерности и понимать чтобы ваш градиенцев подал по размерности с аргументом функции от
[57:06.480 --> 57:11.360]  которой вычисляется вот более хитрая история про векторный случай когда у вас внутренняя
[57:11.360 --> 57:20.320]  функция она отображает вектор одной размерности вектор другой размерности вот тогда наш градиент
[57:20.320 --> 57:27.640]  представляет вот из себя вот такую вот странную штуковину видите тут как бы d h g по dx к который
[57:27.640 --> 57:37.960]  как бы типа и кабиана да понятно что произошло да в общем вот это все у вас был в мат анализе в
[57:37.960 --> 57:48.080]  общем-то я тут это скорее для того чтобы напомнить перечисляю вот было было окей так соответственно
[57:48.080 --> 57:53.360]  посмотрите внимательно индексы который стоит вот здесь и по которым происходит суммирование
[57:53.360 --> 58:01.440]  легко понять что вот здесь на самом деле стоит умножение матрицы и коби джей транспонированные
[58:01.440 --> 58:05.840]  потому что тут индекс надо поменять чтобы тут был кат и компонент надо чтобы кат индекс был
[58:05.840 --> 58:14.720]  вне ну первым короче из тех которые сворачиваются умноженный на градиент dg по d h то есть градиент
[58:14.720 --> 58:20.920]  самой вот этой функции которая отображает вектор в число в итоге у вас получится вектор что и хотелось
[58:20.920 --> 58:31.960]  так понятие например теперь давайте это все обобщим называется чейн рулл собственно
[58:31.960 --> 58:38.000]  производная сложная функция для чейн рулл вот и автодив вот кому интересно вот тут вот книжка
[58:38.000 --> 58:47.080]  большая про все это рекомендую в общем есть интересно почитать вот если теперь у нас концеп
[58:47.080 --> 58:54.120]  идет не скаляр а основа вектор то есть мы как бы вот так идем n в к к в м надо бы на
[58:54.120 --> 59:02.080]  самом деле поменять местами окей вот тогда итоговый к бян джей будет просто произведение вот этих
[59:02.080 --> 59:08.120]  бянов вот ну вот формула то есть до этого у нас было произведение матрицы на вектор а сейчас
[59:08.120 --> 59:16.280]  поскольку у нас и финальная функция тоже отображает не в число объект а в размер больше единицы то у
[59:16.280 --> 59:26.360]  нас получилась формула произведения матрицы то есть естественно некоторые усложнения пошло понятно
[59:26.360 --> 59:42.880]  вопросы точно понятно хорошо ну вообще не понятно давайте мы супер позицию l большой функции представим
[59:42.880 --> 59:51.080]  в виде графа и посчитаем итоговый и к бян который будет либо вектором либо там в общем зависимости
[59:51.080 --> 59:56.800]  от того что на выходе получается как произведение этих самых пенов вы собственно два способа
[59:56.800 --> 01:00:02.400]  вычисления либо слева направо либо справа налево если считать справа налево это вот так это
[01:00:02.400 --> 01:00:07.920]  называется форвард мол дифференцирование если вычислять слева направо то есть вот так называется
[01:00:08.560 --> 01:00:22.560]  сейчас будет видно форвард мол основная идея вычисляем вот эту величину зафиксировав к и
[01:00:22.560 --> 01:00:36.440]  считаем для всех и то есть у нас f типа какой-то размерности типа 10 вот ну и мы для всех этих
[01:00:36.440 --> 01:00:42.920]  10 размерности вычисляем ну как бы производную только для фиксированного аргумента к фиксированного
[01:00:42.920 --> 01:00:51.320]  элемента аргумента вот то есть по сути дела формируем столбец вот этой матрице gf gf итоговый
[01:00:51.320 --> 01:00:57.760]  который был вот здесь это некоторые матрица и вот эти два способа по сути ее формирование
[01:00:57.760 --> 01:01:09.280]  либо по столбцам либо по срокам так понятная идея вот делать это так убирается элемент сдается
[01:01:09.280 --> 01:01:15.800]  же соответствующий орд а дальше идет умножение справа налево рекурсивно то есть мы умножаем
[01:01:15.800 --> 01:01:22.320]  вот эту штуку на ну то есть то есть что происходит мы умножаем сначала g1 на у потом результат
[01:01:22.320 --> 01:01:28.840]  умножаем на g2 и так далее даже л то есть идем не формируя вот эту вот огромную матрицу
[01:01:28.840 --> 01:01:34.280]  который там может быть непоняткой размерности а просто умножаем постоянные и кубяна на вектор
[01:01:34.280 --> 01:01:48.280]  это называется тремя волшебными буквами в сгп или вектор джакобин продукт вот соответственно
[01:01:48.280 --> 01:01:54.080]  поскольку мы идем видите вместе с вычислением самих функций то есть мы идем сначала же один
[01:01:54.080 --> 01:01:58.880]  умножаем потом же 2 и так далее потом же l это значит что мы можем эти вычисления проводить
[01:01:58.880 --> 01:02:04.920]  параллельно с вычислением самой функции то есть вот вы вычисляете какую-то супер позицию и вы
[01:02:04.920 --> 01:02:11.760]  в процессе получения супер позиции получаете заодно и соответствующий блок в градиенте ну или
[01:02:11.760 --> 01:02:21.240]  в кабиане это быстро вот но чтобы это работал надо для каждой функции ее переопределить так
[01:02:21.240 --> 01:02:26.320]  чтобы по ней он действует самой функции у вас была бы функция которым нажать ее и кабиан на
[01:02:26.320 --> 01:02:36.000]  вектор ну я надеюсь это понятно исходя из вот этого то есть условно вы считаете там sin от
[01:02:36.000 --> 01:02:42.440]  cos tan tan от логарифма и вот чтобы у вас все заработал вам надо и cos sin tan и все эти ваши
[01:02:42.440 --> 01:02:47.160]  функции до определить методами которые будет вычислять вот эту штуку при этом понятно что
[01:02:47.160 --> 01:02:52.520]  сами произведи сами градиенты сами кабианы от этих функций вы знаете поэтому можете это сделать
[01:02:52.520 --> 01:03:10.440]  так понятно или не очень или все уже выпали что происходит собственно backward mode или
[01:03:10.440 --> 01:03:16.760]  backpropagation который делается в нейронках он делает наоборот он говорит такое сначала давайте
[01:03:16.760 --> 01:03:29.280]  зафиксируем наш элемент в нашем выходе и посчитаем за один проход для всех аргументов и вот это вот
[01:03:29.280 --> 01:03:34.880]  хорошо работает в нейронках почему потому что целевая функция там скалярная поэтому заданная
[01:03:34.880 --> 01:03:42.440]  к это самое одно число и за один проход все получается вот делайте абсолютно так же кроме
[01:03:42.440 --> 01:03:51.400]  того что считается рекурсивно с лево направо теперь то считается g l там g l минус 1 так далее
[01:03:51.400 --> 01:03:59.160]  до g 1 поэтому надо сначала посчитать функцию пройти вперед по графу сохранить все промежуточные
[01:03:59.160 --> 01:04:05.360]  результаты которые будут необходимы для вычтения градиентов а потом после посчитали значение
[01:04:05.360 --> 01:04:11.240]  функции посчитать те же самые градиенты проход пройдясь назад то есть от вашей финальной функции
[01:04:11.240 --> 01:04:21.720]  к листам так насколько это получилось представить или так себе
[01:04:21.720 --> 01:04:35.000]  у нам затем что вот здесь мы как бы вырезаем строку или столбец нашей матрицы g f просто в случае
[01:04:35.000 --> 01:04:44.120]  когда это ну собственно житая строка написано то есть мы как бы чтобы получить эту строку мы
[01:04:44.120 --> 01:04:52.560]  умножаем матрицу на и вектор где единичка соответствующим орте а вот сейчас сейчас будет
[01:04:52.560 --> 01:04:59.200]  понятно да это понятно да но в общем вот тут написано что если у вас функции скалярной то
[01:04:59.200 --> 01:05:06.840]  просто у равно единицы запускаете все получается частный случай так да я не успел ну ладно в
[01:05:06.840 --> 01:05:13.480]  следующий раз на этом продолжим и примеры и почему их 2 и почему это важно тоже будет я
[01:05:13.480 --> 01:05:17.200]  надеюсь понятно так все всем спасибо до следующей недели надеюсь что
