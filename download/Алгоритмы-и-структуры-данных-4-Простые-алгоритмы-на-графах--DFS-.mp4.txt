[00:00.000 --> 00:16.520]  Добрый вечер, давайте начинать. Мы закончили более-менее с динамикой, переходим к графам,
[00:16.520 --> 00:22.040]  до конца семестра у нас будут графы. Мы их многократно уже на самом деле затрагивали,
[00:22.040 --> 00:31.680]  в этом семестре и в прошлом. Давайте немножко формализую, что мы хотим. Ориентированный граф
[00:31.680 --> 00:46.520]  это следующее. Формально это просто пара из двух множеств В и Е, где В это произвольное
[00:46.520 --> 01:03.760]  конечное множество, а Е это какое-то подмножество из декартового квадрата В на В. Дальше,
[01:03.760 --> 01:09.240]  если я буду элементы множества В называть вершинами, рисовать их точечками, а элементы
[01:09.240 --> 01:16.800]  множества Е представлять как какие-то стрелки из первого элемента пары во второй, то можно,
[01:16.800 --> 01:25.800]  например, нарисовать какой-нибудь вот такой вот граф. Граф на четырех вершинах, давайте скажем,
[01:25.800 --> 01:30.440]  на пяти ребрах. Ну и вот если есть какая-то ориентированная стрелочка из одной вершины
[01:30.440 --> 01:37.400]  в другую, значит такая пара, скажем, пара три-четыре, лежит в множестве ребер. Формально для такого
[01:37.400 --> 01:43.960]  графа Е это просто все вот эти пары, которые соответствуют стрелочкам. Значит один-два первая
[01:43.960 --> 02:02.240]  пара, один-четыре, четыре-два, два-три, три-четыре. Вот это ориентированный граф, когда у всех ребер
[02:02.240 --> 02:07.560]  есть ориентация, то есть каждый ребро это на самом деле стрелочка из одной в другую. И формально это
[02:07.560 --> 02:18.160]  значит, что у нас пары упорядоченные. Откуда-куда ведет ребро. Росовое определение это неориентированный
[02:18.160 --> 02:25.120]  граф. Это то же самое, когда ребра у вас соответственно неориентированная. С точки зрения пары,
[02:25.120 --> 02:30.160]  это значит, что пара у вас не упорядоченная. Как обычно неориентированный граф это пара В.Е,
[02:30.280 --> 02:41.400]  где В по-прежнему это конечное множество, а Е, я так напишу, под множество CСВ по 2. Где ССВ по 2
[02:41.400 --> 02:47.200]  это всевозможное двуэлементное под множество множество В. То есть я из вот этого множества
[02:47.200 --> 02:51.840]  могу выбрать любые два элемента, взять двуэлементное под множество, и любое такое
[02:51.840 --> 02:56.120]  двуэлементное под множество может выступать ребром нашего графа. Ну и соответственно, если я
[02:56.120 --> 03:05.120]  Если я здесь, в этом графе, затру все стрелочки, то получу другой уже неориентированный граф.
[03:05.120 --> 03:07.120]  Вот и формально множество ребер здесь.
[03:07.120 --> 03:09.120]  Ну, поскольку у меня ребра теперь неориентированные,
[03:09.120 --> 03:12.120]  каждый ребро, на самом деле, тогда неупорядоченная пара.
[03:12.120 --> 03:15.120]  И здесь у меня E – это уже множество из таких пар.
[03:15.120 --> 03:18.120]  Значит, 1, 2, 1, 4.
[03:18.120 --> 03:24.120]  Ну, то же самое, только уже я пишу не пары, а двуэлементное множество.
[03:29.120 --> 03:31.120]  Ну, это же не число, а множество.
[03:31.120 --> 03:37.120]  Если вы до этого определяли C из множества по 2, то, наверное, так и определяли.
[03:37.120 --> 03:39.120]  Я вот так определяю.
[03:39.120 --> 03:43.120]  C из множества по k – это всевозможные коэлементные подношения в этом множестве.
[03:44.120 --> 03:47.120]  Ну, я думаю, все с этим знакомы.
[03:48.120 --> 03:51.120]  Значит, определение пути, цикла и так далее я давать не буду.
[03:51.120 --> 03:53.120]  Они все очень интуитивные.
[03:53.120 --> 03:55.120]  Да, путь – это когда можно просто вот так вот по стрелочкам пройти
[03:55.120 --> 03:57.120]  и попасть из одной вершины в другую.
[03:57.120 --> 03:58.120]  Там тут то же самое.
[03:58.120 --> 04:01.120]  Цикла – это когда вы начали в одной вершине и закончились в ней же.
[04:01.120 --> 04:04.120]  То есть это такой путь, чтобы заканчивать там же, где начали.
[04:05.120 --> 04:06.120]  Вот.
[04:06.120 --> 04:08.120]  Ну, что-то такое.
[04:08.120 --> 04:12.120]  Значит, сегодня самый простой алгоритм у нас будет DFS.
[04:12.120 --> 04:14.120]  Давайте сразу его напишем.
[04:14.120 --> 04:28.120]  Значит, алгоритм DFS расшифровывается как поиск в глубину или depth first search.
[04:37.120 --> 04:39.120]  Значит, он работает следующим образом.
[04:39.120 --> 04:42.120]  Ну, интуитивно он просто – это рекурсивный алгоритм,
[04:42.120 --> 04:45.120]  который при запуске из какой-то определенной вершины
[04:45.120 --> 04:48.120]  рассматривает все возможные исходящие из нее ребра
[04:52.120 --> 04:56.120]  и пытается пойти вдоль тех ребр, которые ведут его в новое, еще не посещенное вершина.
[04:56.120 --> 04:59.120]  То есть алгоритм DFS просто хочет обойти весь граф,
[04:59.120 --> 05:01.120]  ну и там не знаю, что-нибудь в них записать,
[05:01.120 --> 05:03.120]  понять, какие вершинки он посетил, какие не посетил.
[05:03.120 --> 05:07.120]  И DFS просто берет и смотрит на список всех исходящих ребр
[05:07.120 --> 05:09.120]  из данной вершины, где он находится,
[05:09.120 --> 05:13.120]  выбирает из них то, которое ведет в первую, не посещенную вершину
[05:13.120 --> 05:17.120]  и рекурсивно запускается от вот этой вот вершинки, куда он может перейти.
[05:17.120 --> 05:19.120]  Дальше что-то там здесь обходит,
[05:19.120 --> 05:23.120]  рекурсия отсюда завершается, поднимается наверх
[05:23.120 --> 05:27.120]  и берется следующее вершина, ну как бы следующий сосед,
[05:27.120 --> 05:30.120]  точнее следующее ребро, которое ведет в новую, не посещенную вершину.
[05:30.120 --> 05:33.120]  И так далее, пока просто есть не посещенные соседи,
[05:33.120 --> 05:35.120]  мы в них переходим.
[05:36.120 --> 05:40.120]  Вот, ну давайте это напишем,
[05:40.120 --> 05:42.120]  с какой-то степенью точности.
[05:42.120 --> 05:46.120]  Во-первых, я буду считать, что граф у меня будет храниться,
[05:46.120 --> 05:48.120]  скажем, в векторе векторов.
[05:52.120 --> 05:54.120]  Ну я вот так вот напишу.
[06:00.120 --> 06:02.120]  В том понимании, что для каждой вершины V
[06:02.120 --> 06:04.120]  у меня будет список всех ее соседей.
[06:04.120 --> 06:06.120]  То есть у меня для каждой вершинки V
[06:06.120 --> 06:11.120]  будет в векторе G с индексом V хранится список всех ее соседей,
[06:11.120 --> 06:15.120]  то есть всех тех товарищей, куда можно попасть за один шаг из V.
[06:16.120 --> 06:20.120]  Это просто список всех соседей.
[06:25.120 --> 06:28.120]  То есть то, куда есть ребра из вершинки V.
[06:28.120 --> 06:30.120]  Что еще?
[06:31.120 --> 06:32.120]  Ну вроде все.
[06:32.120 --> 06:34.120]  Значит, я как-нибудь веду вспомогательные массивы.
[06:34.120 --> 06:37.120]  Давайте тоже пусть у меня будет массив parent,
[06:37.120 --> 06:39.120]  у меня будет массив color,
[06:40.120 --> 06:42.120]  массив ta-in, массив ta-out.
[06:44.120 --> 06:45.120]  Вот это будут какие-то массивы,
[06:45.120 --> 06:46.120]  которые индексированы номерами вершин.
[06:46.120 --> 06:48.120]  Да, я буду считать еще, что у меня вершины,
[06:48.120 --> 06:51.120]  это просто целый число от нуля до минус одного
[06:51.120 --> 06:53.120]  для удобства.
[06:53.120 --> 06:54.120]  Ну чтобы у них были простые номера,
[06:54.120 --> 06:57.120]  чтобы можно было обращаться, скажем, parent тот V,
[06:57.120 --> 06:59.120]  это родители вершины V.
[06:59.120 --> 07:01.120]  Сейчас я объясню, что это все такое.
[07:02.120 --> 07:04.120]  Вот, значит, алгоритм будет работать следующим образом.
[07:04.120 --> 07:07.120]  Давайте сначала покрасим все вершины в белый цвет.
[07:09.120 --> 07:11.120]  И в момент, когда мы заходим в вершинку,
[07:11.120 --> 07:12.120]  будем красить ее в серый.
[07:12.120 --> 07:14.120]  Серый значит, что она сейчас в обработке.
[07:14.120 --> 07:16.120]  И мы будем красить ее в серый.
[07:16.120 --> 07:18.120]  И мы будем красить ее в серый.
[07:18.120 --> 07:20.120]  И мы будем красить ее в серый.
[07:20.120 --> 07:24.120]  А когда заходим в вершинку,ela,
[07:24.120 --> 07:26.120]  будем красить ее в серый.
[07:26.120 --> 07:27.120]  Серый значит, что она в обработке.
[07:27.120 --> 07:29.120]  Мы сейчас пытаемся из нее что-то найти.
[07:29.120 --> 07:31.120]  Мы пытаемся из нее рассмотреть все ребра.
[07:31.120 --> 07:33.120]  Когда заходим, мы красим ее в серый.
[07:35.120 --> 07:37.120]  И в конце, когда мы уже все обошли,
[07:37.120 --> 07:39.120]  когда рекурсия из вершинки V завершилась,
[07:39.120 --> 07:41.120]  мы обошли все, что потенциально можно было.
[07:41.120 --> 07:43.120]  Мы говорим, что окей, мы эту вершинку закрываем
[07:43.120 --> 07:45.120]  и красим ее в черный.
[07:46.120 --> 07:48.120]  Белый, значит, мы еще к ней вообще не прикасались,
[07:48.120 --> 07:51.600]  находится в процессе обработки. Мы на нее смотрим и перебираем ребра из нее.
[07:51.600 --> 07:55.840]  Черные, когда мы ее полностью обработали, и больше вообще туда не смотрим. Когда мы
[07:55.840 --> 08:03.880]  обошли все, что из нее достижимо. Ну, примерно так. Вот. TNT out это моменты
[08:03.880 --> 08:10.920]  времени входа и выхода в вершину. Давайте запишу, что это моменты времени. Нам понадобится
[08:10.920 --> 08:19.760]  это чуть позже. Я их сразу сейчас веду. Моменты времени входа и выхода в вершину.
[08:19.760 --> 08:26.880]  Ну, у нас алгоритм какой-то такой итеративный. Он пришел в одну вершину, пришел в другую, в третью,
[08:26.880 --> 08:30.320]  в четвертую и так далее. В какой-то момент он больше из вершины никуда пойти не может.
[08:30.320 --> 08:33.640]  Говоришь, что окей, я из нее выхожу. То есть у меня формально рекурсия просто в данной
[08:33.640 --> 08:37.000]  вершине завершается, потому что больше идти некуда. Рекурсия завершается, мы говорим,
[08:37.160 --> 08:43.120]  из вершины выходим. Красим ее в черный цвет и поднимаемся по стеку рекурсии наверх. Дальше мы
[08:43.120 --> 08:47.960]  отмечаем, когда мы зашли в вершину, когда мы вышли из вершины. Когда рекурсия, соответственно,
[08:47.960 --> 08:56.120]  попала в V, когда она из нее вышла. Ну и давайте это напишем. Давайте какой-нибудь DFS,
[08:56.120 --> 09:08.240]  который принимает вершину V, работает примерно так. Во-первых, мы вошли в вершину. Когда мы в нее
[09:08.240 --> 09:13.000]  входим, мне нужно поменять у нее цвет. Во-первых, мы говорим, что мы в нее вошли и сразу цвет
[09:13.000 --> 09:19.760]  становится серым. Давайте так и напишу. Давайте по-английски напишу, не по-русски. Мы говорим,
[09:19.760 --> 09:24.800]  что у нее цвет серый. Дальше мы говорим, что мы в нее зашли и время входа в нее это вот какой-то
[09:25.040 --> 09:33.280]  текущее время. Вот пусть таймер это текущий таймер времени. Ну и я его сразу увеличу,
[09:33.280 --> 09:39.240]  чтобы следующие события происходили в следующие моменты времени. Я напишу вот так вот. Таймер
[09:39.240 --> 09:45.080]  плюс-плюс. Значит, якобы таймер положил сюда и сам таймер увеличил на единичку. Следующие события
[09:45.080 --> 09:48.840]  уже происходят в следующие моменты времени. Я время увеличил. Я зашел в вершину, нажал счетчик,
[09:48.840 --> 09:55.440]  время увеличилось. Так, все. Теперь я просто перебираю всех соседей. То есть все возможные
[09:55.440 --> 10:06.600]  вершины, куда можно перейти из данной. Это просто все возможные элементы списка ГОТВ. И теперь я
[10:06.600 --> 10:13.160]  от них запускаюсь рекурсивно, но только в случае, если они белые. Только в случае, если я их еще
[10:13.160 --> 10:18.040]  вообще не видел, если это новые вершинки, то я от них буду запускаться. Потому что если я в них
[10:18.040 --> 10:22.480]  уже был, если они уже серые или черные, то нет смысла еще раз идти туда же. У меня и так там DFS
[10:22.480 --> 10:27.880]  уже либо и так работает сейчас, либо уже вообще отработал. Поэтому запускаться еще раз с DFS от
[10:27.880 --> 10:34.040]  серых или черных вершин я не буду. Я запускаюсь только от белых. Поэтому я пишу, что если color2
[10:34.040 --> 10:50.480]  не white, то я ее просто скипаю, делаю continue. Вот, а иначе запускаюсь рекурсивно. Ну давайте,
[10:50.480 --> 10:58.120]  давайте я так, давайте еще вот здесь допишу, что parent от tu равно v и перейду рекурсивно в вершинку
[10:58.120 --> 11:09.680]  tu. Parent будет для каждой вершины говорить из какой вершины я в нее пришел. То есть если я вот сейчас
[11:09.680 --> 11:17.080]  иду вдоль ребра из v в tu, то я для вершинки tu записал, что ее parent является v. Ну просто
[11:17.080 --> 11:23.520]  родительская вершина в этом обходе. Все, то есть я буквально просто обхожу все, что можно по всем
[11:23.520 --> 11:29.160]  белым, по всем белым вершинкам. Это я обошел всех сосей и теперь у меня это все завершилось. Надо
[11:29.160 --> 11:33.880]  выйти из рекурса и поместь, что вершина, вершина пройдена. Значит для этого мне нужно у нее проставить
[11:33.880 --> 11:40.520]  черный цвет и сказать, что я из нее вышел в данный момент времени. Поэтому я пишу просто color
[11:40.520 --> 11:55.240]  от v это black и видимо tu от v равно тоже timer++. То есть вот в тот момент времени, когда я сюда пришел,
[11:55.240 --> 12:00.800]  я кладу в tu от v этот таймер и увеличу его, потому что все остальные события происходят в следующий
[12:00.800 --> 12:10.040]  момент времени. Вот вроде весь DFS. Вот такой простой код, ну который в каком-то смысле жадно
[12:10.040 --> 12:14.040]  просто идет туда, куда можно. Идет туда, куда есть смысл. Понятно, нет смысла идти туда,
[12:14.040 --> 12:19.560]  где мы уже были, вот. А там, где мы не были, просто давайте туда пойдем вот такой рекурсией. Видит
[12:19.560 --> 12:30.720]  первую попавшуюся вершину, идет туда. Вот, значит оказывается, что здесь ну удобно сформулировать
[12:30.720 --> 12:36.720]  следующую лему, называется лема о белых путях, которая что-то говорит о работе DFS.
[12:36.720 --> 12:43.840]  Давайте я сейчас скажу, что я живу в случае ориентированного графа. Пока что у меня все
[12:43.840 --> 12:48.200]  ребра ориентированные и все вот здесь вот тоже происходит в ориентированном мире. Поэтому я здесь
[12:48.200 --> 12:52.840]  напишу, что граф уже ориентированный. Про неориентированный мы как-нибудь попозже поговорим.
[12:52.840 --> 13:05.440]  Лема такая. Вот давайте рассмотрим момент времени tu от v. Моменты входа и выхода из вершинки v. Вот
[13:05.440 --> 13:10.480]  что происходит за то время, пока мы как бы обрабатываем вершину v. То есть за время от входа в
[13:10.480 --> 13:17.200]  нее до выхода из нее. Кого мы посетим? Что вообще изменится в график, там какие вершинки поместятся
[13:17.200 --> 13:26.280]  посещенными, у каких поменяются цвета и так далее. Я утверждаю, что за этот промежуток времени произведет
[13:26.280 --> 13:45.120]  ровно следующее. Для любой вершинки v за время от tu от v, то есть от входа v до tu от v алгоритм
[13:45.120 --> 14:13.320]  посетит все вершины, достиженные по белым путям из v и больше никого не посетит. И только их.
[14:13.320 --> 14:23.640]  Вот, то есть если к моменту времени входа v, к моменту времени входа здесь был какой-то
[14:23.640 --> 14:29.520]  полностью белый путь, то есть путь по исключительно белым вершинкам, вот если здесь все были белые на
[14:29.520 --> 14:34.840]  этом пути, то тогда к моменту времени выхода из v все эти вершинки посетятся, то есть от них
[14:34.840 --> 14:42.320]  вот всех запустится dfs, они все перекрасятся в черный и никаких других вершин в черный не перекрасится.
[14:42.320 --> 14:47.000]  То есть вот если здесь был белый путь, давайте я их dubly v-шками обозначу, white, если не все
[14:47.000 --> 14:55.040]  были белые, то они становятся черными. Вот, и никаких других вершин я не посещу, никаких
[14:55.040 --> 15:00.440]  других вершин за вот это вот время, за промежуток времени вот это вот, я никаких других вершин не
[15:00.440 --> 15:11.520]  увижу. Давайте попробуем доказать. Ну, смотрите, с одной стороны понятно, что ничего другого
[15:11.520 --> 15:17.200]  за это время я точно не увижу, потому что что происходит в момент времени с этого поэта?
[15:17.200 --> 15:26.840]  Вот я был в вершинке v, вот я в нее когда-то впервые зашел, потом я что-то делаю и рано или поздно я
[15:26.840 --> 15:33.080]  запускаю, точнее завершаю рекурсивный запуск dfs от v, но понятно, что за это время я только спускался
[15:33.080 --> 15:39.240]  по каким-то ребрам, да и запускал dfs рекурсивно только от тех вершин, в которые вело ребро,
[15:39.360 --> 15:44.400]  поэтому максимум, что я мог посетить, это какие-то вот такие вот пути ведущие из v, вот что-то такое я
[15:44.400 --> 15:51.720]  мог делать, но понятно, что никакие другие вершины недостижимые из v по путям я достичь не мог,
[15:51.720 --> 15:57.960]  так dfs работает, он идет только по ребрам, как бы да, по ребрам вот из текущей вершины. Ну и с другой
[15:57.960 --> 16:03.520]  стороны, если вдруг что-то было достижимое и оно было, скажем там, серое или черное, то в них я
[16:03.520 --> 16:08.440]  тоже не зайду, потому что dfs не заходит в небелые вершины, он запускается только от белых вершин.
[16:08.440 --> 16:13.640]  Поэтому вот эта вот часть про и только их, она более-менее очевидна, ничего другого мы посетить не
[16:13.640 --> 16:30.800]  можем. Давайте запишем это, что других вершин посетить не могли. Вот, теперь почему посетим все,
[16:30.800 --> 16:57.880]  что нужно? Ну, давайте подумаем. Значит, во-первых, давайте поймем вообще, что представляют у себя
[16:57.880 --> 17:05.080]  серые вершины в какой-либо момент времени. То есть белые, черные есть серые. Вот что такое серые? Вот
[17:05.080 --> 17:10.280]  если я алгоритм в какой-то момент остановлю, заморожу картинку, посмотрю какие вершины являются
[17:10.280 --> 17:17.920]  серыми, то на самом деле легко понять, что они образуют сплошной путь и они все лежат на стеке
[17:17.920 --> 17:29.200]  рекурсии. Вот если вот эти товарищи все серые, то они как раз образуют путь и они все лежат
[17:29.200 --> 17:50.800]  в стеке рекурсии. Образуют путь и лежат на стеке рекурсии. Ну почему? Потому что вот когда-то
[17:50.800 --> 17:54.800]  ДФС там запустился от какой-то вершины, от стартовой вершины он запустился, пометил ее серой,
[17:54.800 --> 18:00.040]  потом куда-то спустился, покрасил ее серой опять-таки. Если он дальше куда-то спускается и пометил что-то
[18:00.040 --> 18:04.600]  серое, то значит он опять спустился по ребру. Ну и так далее. А если внезапно он пытается из вершины
[18:04.600 --> 18:10.440]  пойти там, то есть если он что-то обошел и пытается пойти дальше, скажем, вот он эту ветку обошел и
[18:10.440 --> 18:15.200]  потом переходит в какую-то новую вершинку. Значит, к моменту перехода все эти уже будут черные,
[18:15.200 --> 18:20.800]  потому что я когда завершаю рекурсивный вызов, я перекрашиваю серой в черную. Поэтому у меня всегда
[18:20.800 --> 18:27.840]  на стеке рекурсии будут как раз вот последовательность серых вершин на пути. Понятно
[18:27.840 --> 18:38.280]  же это? Ну вот, значит получается, что с серыми все более-менее понятно. Это какой-то стек
[18:38.280 --> 18:50.280]  рекурсии, пусть вот это вот В. Ну тогда понятно, что при моменте входа в нее,
[18:50.280 --> 18:55.320]  у меня граф просто вот такой, больше ничего нет. Ну точнее стек рекурсии вот такой. То есть это
[18:55.320 --> 18:59.280]  последняя рассмотренная вершина, она лежит на стеке рекурсии. К моменту времени выхода из нее
[18:59.280 --> 19:04.480]  стек тоже будет такой, потому что мне нужно ее будет из стека удалить, стек будет пустой. Значит,
[19:04.480 --> 19:12.240]  никаких других серых вершин к моменту времени выхода не появится. Мораль такая, что от, ну точнее
[19:12.240 --> 19:21.600]  не так, да? К моменту Та от В новых серых не появляется. Новых серых не появляется.
[19:21.600 --> 19:33.720]  Потому что это стек, да, я из вот этого состояния вернулся к нему же, потому что я зашел, когда
[19:33.720 --> 19:37.520]  захожу в В у меня было такое состояние стека, когда выхожу тоже должно было быть такое, чтобы я В
[19:38.080 --> 19:47.840]  удалил. Поэтому других серых не появилось. Могли появиться, значит, только черные. Вот. Хорошо.
[19:47.840 --> 19:53.440]  Значит, что теперь я хочу? Я хочу доказать утверждение вот этого, да, что алгоритм пустит все
[19:53.440 --> 20:04.800]  вершины, достижимые по белым путям. Давайте доказывать. Вот есть В. Давайте пойдем от противного,
[20:04.800 --> 20:09.840]  пусть нашелся какой-то путь по белым вершинам, на котором не все вершины покрасились в черный.
[20:09.840 --> 20:18.240]  Ладно, сейчас пойду от противного. Пусть есть какой-то путь, который в момент времени входа в В был
[20:18.240 --> 20:23.840]  полностью белый, то есть все вот эти вот товарищи были белые. И пусть к моменту времени выхода из В
[20:23.840 --> 20:30.040]  он не весь черный, то есть я его не весь посетил. Понятно, серыми они стать не могли, потому что
[20:30.040 --> 20:33.800]  стек-рекурс у меня сохранился, они не могут быть серые в момент времени выхода, но кто-то из них
[20:33.800 --> 20:38.440]  может быть черным, а кто-то может остаться белым. Так вот, давайте тогда посмотрим самую глубокую,
[20:38.440 --> 20:51.200]  оставшуюся белой. Пусть это будет какая-нибудь У. Пусть У, самая глубокая на этом пути, самая
[20:51.200 --> 21:05.080]  глубокая, оставшаяся белой. Ну, для нее тогда что-то точно пошло не так, потому что если У была
[21:05.080 --> 21:10.120]  белой и осталась белой, то родители ее, вот это вот да, Parent Tattoo, как раз предыдущий вершин на этом
[21:10.120 --> 21:16.560]  пути, она точно превратилась в черную. Ну, потому что мы взяли как раз, наоборот, извините, самую
[21:17.560 --> 21:28.560]  наименее глубокую я имел ввиду, то есть самую высокую, извините. На этом пути у меня к моменту
[21:28.560 --> 21:32.720]  времени выхода из В вот эта, скажем, стала черной, эта стала черной, эта стала черной, а эта осталась
[21:32.720 --> 21:39.480]  белой. Но тогда для этой вершины явно что-то пошло не так, потому что вершина перекрасилась из белого
[21:39.480 --> 21:44.160]  в черный, но у нее осталось ребро, ведущее в белую вершину, то есть она как была белой, так и осталась
[21:44.160 --> 21:49.720]  белой. Ну, противоречие, потому что DFS, если из вершины видит ребро в белую, он обязательно сначала
[21:49.720 --> 21:58.960]  в него перейдет и только потом может перекрасить эту вершину в черный. Противоречие.
[21:58.960 --> 22:06.360]  Значит, еще раз быстренько, вот если у меня был белый путь и какая-то вершина не перекрасилась
[22:06.360 --> 22:10.560]  в черный, давайте возьмем самую высокую, такую не перекрасилась в черный. Вот эти все перекрасились
[22:10.560 --> 22:14.880]  в черную, а эта осталась белой. Но тогда для вот этой вершины что-то пошло не так. Ну, как бы
[22:14.880 --> 22:21.040]  алгоритм DFS так не мог работать, что он перекрасил одну вершину из белой в черную, а вершину в
[22:21.040 --> 22:25.440]  которой есть ребро оставил белой, потому что в момент рассмотрения вот этой вершинки он обязательно
[22:25.440 --> 22:28.960]  должен был просмотреть это ребро и, значит, запуститься рекурсивно отсюда. Противоречие.
[22:28.960 --> 22:41.320]  Тут утверждение как бы для какого-то тривиального алгоритма, но оно нам будет несколько раз нужно,
[22:41.320 --> 22:58.400]  поэтому я его в общей строгости доказываю. Отсюда следует две вещи. Из этой леммы следует два
[22:58.400 --> 23:08.360]  факта. Во-первых, простой факт, который так был более-менее очевиден, это следующее, что если мы
[23:08.360 --> 23:13.640]  изначально покрасим весь граф в белый цвет, все вершины в белый цвет и запустимся DFS от какой-то
[23:13.640 --> 23:19.000]  старта вершинки S, то тогда к моменту завершения DFS мы обойдем в точности все, что было достижимо
[23:19.000 --> 23:40.600]  в принципе. Если изначально все вершины белые, то после, давайте так, то DFS от S пометит черными
[23:40.600 --> 23:59.960]  все достижимые из S вершины. Ну понятно, просто лемма в белых путях, потому что все, что достижимо,
[23:59.960 --> 24:04.680]  оно достижимо по белым путям, значит будет объединено DFS и будет перекрашено в черный.
[24:04.680 --> 24:14.160]  Ну и второе следствие, чуть более уже интересное, это проверка графа на
[24:14.160 --> 24:20.940]  оцикличность и поиск цикла. Следствие второе. Ну опять, я считаю, что все вершины у меня изначально
[24:20.940 --> 24:31.720]  покрашены в белый цвет. Вот, значит тогда я утверждаю, что DFS от S находит ребров серую вершину,
[24:31.720 --> 24:44.480]  если и только если в исходном графе есть цикл достижимый из S.
[24:44.480 --> 25:09.160]  То есть какая-то вот такая картинка, вот если есть цикл, то мы его обязательно найдем. Вот,
[25:09.160 --> 25:13.720]  значит есть ребро, находит ребро в серую вершинку, но вот здесь, смотрите, мы перебираем все ребра графа,
[25:13.760 --> 25:20.040]  вот если в этот момент времени я вижу ребро из VF2 и 2 при этом серое, то есть вот здесь вот,
[25:20.040 --> 25:24.320]  ну по факту, когда я просто перебираю все ребра, если я вижу ребро в серую вершинку,
[25:24.320 --> 25:28.760]  то есть если вот здесь добавлю условия, если color of 2 равно gray, тогда я нашел цикл.
[25:28.760 --> 25:41.880]  Вот если в этот момент времени color of 2 серый, тогда найден цикл. Вот, ну почему? Почему? Смотрите,
[25:41.880 --> 25:46.760]  слева-направо более-менее просто. Почему, если DFS от S нашел ребро в серую вершину,
[25:46.760 --> 25:54.480]  то обязательно есть цикл? Скажите, пожалуйста. Ну да, потому что у меня серые вершины образуются
[25:54.480 --> 26:01.160]  так рекурсии и при этом путь. На все серые вершины обязательно путь. Если я из текущей вершины V
[26:01.160 --> 26:07.720]  внезапно увидел ребро в серую, значит я обязательно нашел ребро в какую-то из вершины этого пути,
[26:07.720 --> 26:16.520]  значит я замкнул цикл. Если я увидел ребро, то я точно нашел цикл. Ну теперь надо обратно показать,
[26:16.520 --> 26:27.680]  что если цикл есть, то обязательно найду его таким образом. Да, ну поэтому я говорю,
[26:27.680 --> 26:50.440]  что цикл достижимый из S. Так, обратно. Пусть есть цикл достижимый из S, давайте его нарисуем.
[26:50.440 --> 27:02.280]  Вот такой вот он есть. Я хочу показать, что я в каком-то смысле его найду. То есть что я
[27:02.280 --> 27:08.200]  найду какое-то ребро в серую вершину хоть когда-то. Ну, смотрите, давайте вот в этом цикле,
[27:08.200 --> 27:13.760]  который в нашем графе присутствует, давайте возьмем вершину с минимальным TEIN. Я так буду
[27:13.760 --> 27:19.200]  несколько раз делать за сегодня. Среди интересующих меня вершин давайте найдем вершину с минимальным
[27:19.200 --> 27:38.200]  TEIN. Пусть, скажем, U это вершина цикла с минимальным значением TEIN от U. Где-то вот она здесь есть.
[27:38.200 --> 27:46.080]  Ну потому что, вообще говоря, непонятно, какую именно из вершин цикла я найду в первую очередь.
[27:46.080 --> 27:51.800]  Потому что, да, у меня есть какой-то цикл, но совершенно необязательно, что DFS ровно вот по этому
[27:51.800 --> 27:56.760]  пути пойдет и в таком порядке их посетит. Он, например, мог пойти как-то вот так. Я же не говорю,
[27:56.760 --> 28:01.800]  что нет других ребер. Они вполне себе могут быть. DFS, поскольку я здесь никак не специфицирую,
[28:01.800 --> 28:05.640]  как именно я, в каком порядке я обхожу ребра, может обходить их совершенно произвольно,
[28:05.640 --> 28:10.600]  ну и поэтому он мог дойти до этого цикла как-то по-другому. Например, вот так. Поэтому просто из
[28:10.600 --> 28:18.480]  всех возможных вершин цикла я возьму самую первую, ту, которую я впервые увижу. Ну а дальше давайте
[28:18.480 --> 28:24.440]  рассмотрим вот этот момент времени TEIN на ТУ. В этот момент времени, поскольку U это первая
[28:24.440 --> 28:31.080]  вершина на цикле, все остальные еще белые. Все остальные еще не посещены, я их еще не видел,
[28:31.080 --> 28:36.400]  у них больше момент времени входа. Поэтому они все еще белые, вот эти все белые. А когда я сюда
[28:36.400 --> 28:43.760]  захожу, я ее перекрашиваю в серый. Ну а дальше просто левый в белых путях. У меня есть вот такой вот белый
[28:43.760 --> 28:51.440]  путь. Я сказал, что все эти вершинки белые. Поэтому, в частности, к моменту времени выхода из U я вот
[28:51.440 --> 28:58.280]  эти все вершины успею обойти. Я от них от всех запущу рекурсивный DFS. В частности, DFS рано или
[28:58.280 --> 29:03.280]  поздно запустится вот от этой вершинки V, которая предшествовала U на цикле. То есть я от них от всех
[29:03.280 --> 29:06.480]  в каком-то порядке, я не обязательно говорю, что в таком, но в каком-то порядке я запускаю DFS,
[29:06.480 --> 29:14.400]  так или иначе я запущу DFS от V. Ну, значит, я увижу ребро в серую вершинку. Потому что до того, как я
[29:14.400 --> 29:19.320]  вышел из U, я обязательно запустил DFS от всех этих чуваков, возможно, в каком-то произвольном порядке,
[29:19.320 --> 29:24.840]  неважно. Главное, что я запустил DFS от этой вершинки, вот предыдущей вершины на цикле. И поэтому этот DFS
[29:24.840 --> 29:33.400]  увидит ребро в серую вершинку. Значит, цикл будет найден. Пусть V это предыдущая вершина на цикле,
[29:33.400 --> 29:49.560]  тогда по лейме DFS от V запустится раньше, чем завершится запуск DFS от U.
[29:55.360 --> 29:58.400]  Давайте напишу так, запустится раньше, чем U перекрасится в черный.
[29:58.400 --> 30:08.240]  Ну, это как раз значит, что мы нашли ребро в серую вершинку.
[30:18.720 --> 30:19.280]  Так, окей.
[30:19.280 --> 30:22.280]  Хорошо.
[30:24.840 --> 30:30.360]  Тогда едем дальше.
[30:54.840 --> 31:10.920]  Следующее, что я хочу сделать, это построить топологическую сортировку ациклического графа.
[31:10.920 --> 31:21.000]  Ну, во-первых, обозначение в каком-то смысле. Я буду писать DAC, чтобы сказать
[31:21.000 --> 31:28.400]  ориентированный ациклический граф. Ну, это так расшифровывается, directed acyclic graph на ориентированный
[31:28.400 --> 31:36.760]  ациклический граф. Ориентированный ациклический, то есть без циклов, граф.
[31:36.760 --> 31:46.520]  Ну, давайте скажем, представим, что мы сделали эту проверку, не нашли ребер в серую вершинку,
[31:46.520 --> 31:54.560]  то есть у меня в графе нету циклов. Вот, тогда для таких графов определяется так называемая
[31:54.560 --> 32:04.360]  топологическая сортировка. Топологическая сортировка, ну, вот такого графа.
[32:04.360 --> 32:12.680]  То есть неформально просто скажу, это такая перестановка вершин, что все ребра идут только
[32:12.680 --> 32:18.640]  слева-направо из вершин с меньшими номерами, вершин с большими номерами. То есть я могу так
[32:18.640 --> 32:23.960]  изобразить вершины на кардинатной прямой, что все ребра ведут только слева-направо.
[32:23.960 --> 32:38.920]  Перестановка вершин. Такая, что все ребра ведут слева-направо.
[32:38.920 --> 32:56.880]  Вот, значит, ну, вообще это очень удобное представление графа, если он, конечно, циклический,
[32:56.880 --> 33:01.640]  потому что, ну, вот на самом деле, когда мы говорим что-то про какие-либо динамики,
[33:01.640 --> 33:06.840]  да, и пишем формулу пересчета для динамики, если построить граф вот этих вот переходов,
[33:06.840 --> 33:12.320]  где вершинами выступает как раз состояние динамики, ну, скажем, там элементы массива,
[33:12.320 --> 33:16.840]  а стрелочкой обозначают зависимость. То есть как мы, из каких значений мы пересчитываем
[33:16.840 --> 33:22.120]  новые значения динамики. Тогда вот там как раз получается это все адекватно решать только в
[33:22.120 --> 33:27.000]  случае, если граф зависимости в DP-шке у вас как раз циклический, что у вас там есть какие-то
[33:27.000 --> 33:30.160]  вершины, которые определяются сами по себе, а дальше все остальные пересчитываются через то,
[33:30.160 --> 33:34.560]  что вы уже посчитали. Ну, как раз в этом смысле, да, что если вы знаете, скажем,
[33:34.560 --> 33:38.760]  ответ для вот этой вершинки, то для всех остальных вы ответ считаете как ответ там,
[33:38.760 --> 33:45.920]  ну, завище от всех. Короче, если скажем, для этой вершинки, чтобы посчитать DP-шку,
[33:45.920 --> 33:51.640]  вам нужно рассмотреть все ведущие вот сюда вот ребра, то есть те состояния, от которых это зависит.
[33:51.640 --> 33:59.960]  Ну и дальше ответ как-то склеить из того, что вы здесь получили. Вот. Ну, а если вы сделали топ
[33:59.960 --> 34:03.680]  сорт этого графа, то по факту вы просто знаете, что вот если слева направо идти,
[34:03.680 --> 34:08.880]  то у вас каждая новая вершина будет как раз зависеть только от предыдущих, то есть в нее ведут ребра
[34:08.880 --> 34:13.600]  только из предыдущих, поэтому DP-шка очень просто насчитывается, если так слева направо расположить.
[34:13.600 --> 34:21.800]  Вот. Ну, не знаю, простое утверждение, давайте даже замечание это скажу, что топ сорт существует
[34:21.800 --> 34:36.440]  только для дагов. Топологическая сортировка существует только для дагов, только для
[34:36.440 --> 34:44.360]  ациклических графов. Ну, потому что если граф не ациклический, в нем есть цикл, то вы его никак
[34:44.360 --> 34:49.840]  напрямую не расположите при условии, что в серебре ток слева направо. Если ребро идет слева направо
[34:50.080 --> 34:54.760]  и есть цикл, то вам надо рано или поздно вернуться как бы справа налево, иначе цикл вы не нарисуете.
[34:54.760 --> 35:02.880]  Вот. Ну и давайте построим алгоритм, предъявим алгоритм нахождения топ сорта.
[35:02.880 --> 35:08.360]  Алгоритм нахождения топ сорта.
[35:08.360 --> 35:22.960]  Работает он следующим образом. Сначала, как всегда, я крашу все вершины в белый цвет,
[35:22.960 --> 35:28.960]  говорю, что все вершины еще чистые и не посещенные. А дальше я запускаюсь DFS,
[35:28.960 --> 35:36.760]  запускаю цикл, скажем, по всем вершинам и вызываю DFS от тех вершин, которые пока что белые. Давайте
[35:36.760 --> 35:47.440]  как-то так это напишу. Я перебираю все S там от 0 до N. 0 до N-1. Если она белая, то я запускаю DFS.
[35:47.440 --> 36:01.800]  Если color от S пока что белый, тогда запускаю DFS. Вот. Ну и как меня уже спрашивали, граф не
[36:01.800 --> 36:08.560]  обязательно связанный, поэтому, возможно, вам придется несколько раз в этом цикле от
[36:08.560 --> 36:13.680]  нескольких разных S запускать DFS, потому что там могут быть какие-то просто не связанные между
[36:13.680 --> 36:19.360]  собой компоненты, или, например, может быть, что-нибудь вот такое, и вы не угадали, DFS сначала
[36:19.360 --> 36:25.080]  запустили отсюда, потом отсюда, потом отсюда. Ну и тогда каждый будет независимый новый запуск
[36:25.080 --> 36:34.040]  из вот этого вот, ну, из внешнего цикла. Короче, этот DFS может вызваться несколько раз. А дальше
[36:34.040 --> 36:38.240]  я утверждаю, что если вы просто возьмете и напишете все вершины в порядке убывания Таута,
[36:38.240 --> 36:51.360]  вы получите топ-сорт. Топ-сорт – это сортировка всех вершин в порядке убывания Таут.
[36:51.360 --> 37:18.280]  Я здесь могу говорить про Таут, потому что у меня DFS от всех вершин так или иначе запустились,
[37:18.280 --> 37:22.280]  у каждой вершины определен правильный Таут в момент времени выхода из нее. И вот теперь,
[37:22.280 --> 37:28.120]  если я посортирую по этому значению, по Таутам в порядке убывания, то у меня будет
[37:28.120 --> 37:33.320]  я утверждаю корректный топ-сорт. Ну, давайте сначала скажу про время работы. Вот я тут говорю
[37:33.320 --> 37:39.000]  «сортировка». На самом деле легко заметить, что все Тауты у меня очень маленькие числа. В данной
[37:39.000 --> 37:45.480]  реализации максимум 2n, потому что таймер у меня увеличивается два раза на каждую вершину. Поэтому
[37:45.480 --> 37:50.200]  значения Таута всегда маленькие, и сортировку можно сделать не за n-логен, а просто за линейное
[37:50.200 --> 37:57.120]  время, сортировкой подсчетом, скажем. Сортировка подсчетом давайте здесь уточню, чтобы лишних
[37:57.120 --> 38:04.760]  логарифмов не возникало. Сортировка подсчетом. Ну и все это суммарно будет работать за линейное время,
[38:04.760 --> 38:16.080]  потому что сортировка вот этот шаг работает за линейное время. Дальше надо проанализировать,
[38:16.080 --> 38:22.200]  как работает DFS. Ну понятно, мы просто запускаем DFS в худшем случае от всех вершин. Если посмотреть
[38:22.200 --> 38:26.760]  на этот код внимательно, то тоже понятно, что в каждую вершину мы зайдем максимум один раз,
[38:26.760 --> 38:32.160]  потому что мы заходим только в те, которые белые, и каждое ребро мы тоже просмотрим максимум один
[38:32.160 --> 38:37.320]  раз, ну точнее ровно один раз, потому что мы ребро просматриваем только если мы находимся в данной
[38:37.320 --> 38:46.680]  вершине сейчас. Поэтому симпатика будет линейная от числа вершин плюс число ребер, то есть от n
[38:46.680 --> 39:00.000]  плюс m. Ну вот, теперь доказательства корректности. Почему то, что я делаю, такая странная
[39:00.000 --> 39:08.320]  перестановка вершин является на самом деле топ-сортом. Ну для этого достаточно доказать
[39:08.320 --> 39:16.040]  следующий факт, что если внезапно у вас есть в графе какое-то ребро у v, то tout для u будет больше
[39:16.040 --> 39:23.480]  чем tout от v, потому что как раз это и означает, что если tout от u больше чем tout от v, то значит u в
[39:23.480 --> 39:39.520]  нашей сортировке идет раньше чем v. Достаточно доказать, что если у v это ребро, то вышли из u мы
[39:39.520 --> 39:50.760]  позже чем из v. Это как раз и будет означать, что вот этой нашей сортировке в обратном порядке
[39:50.760 --> 40:15.560]  по tout, u будет раньше. Давайте докажем. Для этого я хочу рассмотреть два случая опять, в какую из них я
[40:15.560 --> 40:22.600]  зашел раньше. Давайте сравним у них t in и разберем два случая. Первый случай, скажем, когда t in от u
[40:22.600 --> 40:34.000]  меньше чем t in от v, то есть я зашел в u раньше чем v. Я зашел сначала сюда, потом в v. Почему тогда верно
[40:34.000 --> 40:56.280]  вот такое неравенство на tout? Ну да, по факту это опять лемма о белых путях, потому что к моменту
[40:56.280 --> 41:03.440]  времени входа в u это еще белое, к моменту времени входа в v еще белое, значит к моменту времени
[41:03.440 --> 41:10.120]  выхода из u я из v тоже уже выйду. Значит я сначала вышел отсюда, только потом вышел отсюда. Значит
[41:10.120 --> 41:28.120]  нужно неравенство на tout сохраниться. Опять по лемме о белых путях. ДФС от v запустится раньше
[41:28.120 --> 41:51.480]  чем у станет черной. Значит я из v выйду раньше чем из u. Теперь в обратную сторону пусть t in от u
[41:51.480 --> 42:00.360]  наоборот больше чем t in от v. То есть наоборот ситуация симметричная. Я сначала каким-то образом попал
[42:00.360 --> 42:11.640]  в v, а u к моменту времени входа в v еще белое. Что тогда сделать? Почему верно вот это неравенство?
[42:11.640 --> 42:21.400]  Ну да, можно сказать, что смотрите, у нас же граф на самом деле ациклический, значит не существует
[42:21.400 --> 42:29.200]  пути из v в u. Таких пути не существует в принципе, потому что иначе был бы цикл. А значит, ну мы это
[42:29.200 --> 42:34.480]  тоже формулировали, мы знаем, что из v достижимы только те, будут покрашены в черной к моменту
[42:34.480 --> 42:39.800]  времени выхода, только те, которые достижимы по ребрам, по белым путям. Поскольку u недостижима
[42:39.800 --> 42:44.960]  по путям, значит u не будет покрашена в черной, и к моменту времени выхода из v u вообще будет
[42:44.960 --> 42:59.480]  еще даже не затронута. В этом случае, поскольку нет пути из v в u, то к моменту времени выхода из v,
[42:59.480 --> 43:16.400]  то есть к моменту t out от v, u все еще будет белый. Ну а раз к моменту времени выхода отсюда
[43:16.400 --> 43:20.600]  она еще будет белой, то еще только после этого мы в нее зайдем, еще после выйдем.
[43:20.600 --> 43:31.960]  Значит, мне нравится, что по давным выполняются. Ну давайте тогда перерыв небольшой, продолжим потом.
[43:31.960 --> 43:41.840]  Дальше мне нужно будет следующее определение. Пусть, как обычно, g это у меня ориентированный
[43:41.840 --> 43:56.880]  граф. Я ввожу в следующее отношение на вершинах. Я пишу u tilde v и говорю, что u и v сильно связаны,
[43:56.880 --> 44:08.560]  сильно связаны, если между ними существуют пути в обе стороны. То есть, если существует путь из
[44:08.560 --> 44:26.160]  u в v и существует путь из v в u. Мне нужно требовать пути в обе стороны. Если бы я жил в неориентированном
[44:26.160 --> 44:30.720]  случае, то здесь по факту просто написано определение связанности, достижимости двух вершин друг
[44:30.720 --> 44:38.040]  из друга, но поскольку у меня уже ребра ориентированы, я не могу сказать, что путь от u до v является путем
[44:38.040 --> 44:43.000]  от v до u, просто в обратном порядке пройдя. Поэтому мне нужно требовать, ну чтобы это было адекватное
[44:43.000 --> 44:49.240]  определение, мне нужно требовать наличия пути в обе стороны. Дальше я утверждаю, что это отношение
[44:49.240 --> 45:01.480]  является отношением эквивалентности. Тильда является отношением эквивалентности. Это значит,
[45:01.480 --> 45:06.800]  что по этому отношению все вершины графа разбиваются на некоторые непересекающиеся куски,
[45:06.800 --> 45:15.360]  на какие-то подмножества. Такие, что внутри подмножества, они все попарны друг другом,
[45:15.360 --> 45:19.200]  сильно связаны. То есть, если я рассмотрю две вершины внутри одного вот такого множества,
[45:19.200 --> 45:24.680]  то будут пути в обе стороны. А если я рассмотрю вершины из разных множеств, то есть из разных
[45:24.680 --> 45:28.640]  классов эквивалентности, то по крайней мере в одну из двух сторон пути не будет. Скажем,
[45:28.640 --> 45:37.600]  вот такого пути нет. Доказательства. Ну значит, просто по определению, чтобы доказать,
[45:37.600 --> 45:42.120]  что отношение является отношением эквалентности, нужно доказать три вещи. Во-первых,
[45:42.120 --> 45:56.600]  надо доказать рефлексивность. Да, это очевидно. Ну понятно, что у сильно связана сама с собой,
[45:56.600 --> 46:01.160]  потому что путь из У это стоит на месте, и путь из в обратную сторону тоже стоит на месте,
[46:01.160 --> 46:08.440]  ничего не делать. Значит, дальше симметричность тоже очевидна. Если У и В сильно связаны,
[46:08.440 --> 46:13.000]  то В и У тоже сильно связаны, потому что у меня определение симметричное относительно перестановки
[46:13.000 --> 46:24.240]  У и В. Ну и третья, значит, транзитивность. Если, скажем, У и В сильно связаны, а также В и В
[46:24.240 --> 46:32.040]  сильно связаны, то почему У и В сильно связаны. Ну просто по картинке, раз есть путь из У В,
[46:32.040 --> 46:39.680]  давайте его нарисуем, есть путь из В до В В. Значит, если просто их склеит, то получится один больший
[46:39.680 --> 46:46.540]  путь из у В В и обратно, поскольку В и В сильно связаны, то есть вот такой вот путь, поскольку
[46:46.540 --> 46:50.300]  в В и У сильно связаны все идет такой путь. Дальше, если их склеит, то получится как раз путь в
[46:50.300 --> 47:01.780]  обратную сторону. Ну все, значит, реально все вершины распадаются на такие классы
[47:01.780 --> 47:06.860]  эквивалентности. И вот задача – найти эти самые классы эквивалентности. Надо выделить
[47:06.860 --> 47:11.580]  классы эквивалентности по этому отношению, которые также называются компонентами сильной
[47:11.580 --> 47:26.540]  связности. Вот это вот все. Это компоненты сильной связности. Вот их надо выделить,
[47:26.540 --> 47:29.900]  надо разбить граф на компоненты сильной связности.
[47:29.900 --> 47:59.660]  Сейчас эту задачу решает алгоритм Касараю. Алгоритм Касараю
[47:59.660 --> 48:10.940]  выделение компонент сильной связности. Выделение компонент сильной связности. КСС для краткости.
[48:10.940 --> 48:22.940]  Он устроен следующим образом. Во-первых, я проделаю то же самое, что делал для поиска
[48:22.940 --> 48:28.580]  топологической сортировки ациклического графа. Я также сначала все вершины покрашу в белый,
[48:28.580 --> 48:36.620]  потом фориком запущусь ДФСом от всех белых вершин и в конце построю перестановку в порядке
[48:36.620 --> 48:43.660]  убывания т-аутов. Давайте этот первый шаг также напишу. Аналогично поиску топ-сорт,
[48:43.660 --> 48:51.860]  поиска топологической сортировки, так аналогично поиску топологической сортировки, получим
[48:51.860 --> 48:55.620]  перестановку вершин в порядке убывания т-аутов.
[48:55.620 --> 49:25.380]  Вот, а второй шаг следующий. Давайте я скажу, что давайте я вот здесь еще раз
[49:25.380 --> 49:34.300]  все вершины опять покрашу в белый. Вновь красим все вершины в белый, красим все в белый.
[49:34.300 --> 49:49.580]  И дальше я буду идти по вот этой перестановке, которую я получил, и запускаться ДФСом по обратным
[49:49.580 --> 50:10.340]  ребрам. В порядке перестановки запускаю, я вот этого назначу, давайте ДФС реверснутая от В, где ДФС
[50:10.340 --> 50:16.140]  реверснутая это как бы ДФС по обратным ребрам. То есть вот если в исходном графе у меня все
[50:16.140 --> 50:21.900]  ребра имели какую-то ориентацию, были стрелочки какие-то, то ДФС реверснутый ходит наоборот по
[50:21.900 --> 50:27.420]  обратным стрелкам. То есть если у меня была стрелка из У в, то он наоборот пойдет по стрелке В в стрелка
[50:27.420 --> 50:33.420]  У. То есть он разворачивает все стрелки как бы и ходит уже по ним в новом графе. Я получил
[50:33.420 --> 50:36.500]  какую-то перестановку, дальше я просто иду по этой перестановке в том порядке, в котором там
[50:36.500 --> 50:42.180]  элементы написаны, и если вершина еще белая, то я запускаю ДФС по обратным ребрам из нее.
[50:42.180 --> 50:52.660]  И я утверждаю, что то, что обойдет очередной запуск этого ДФС, это будет очередная КСС. То есть
[50:52.660 --> 50:58.980]  вот когда я запускаю ДФС по обратным ребрам от вершины В, все что он посетит, обходя вот так вот
[50:58.980 --> 51:06.780]  по обратным ребрам в этом графе, все что он посетит, это будет в точности его КСС. Очередная КСС.
[51:06.780 --> 51:17.020]  Потом он посмотрит на следующую вершинку в перестановке, какую-нибудь У, опять по обратным
[51:17.020 --> 51:23.620]  ребрам обойдет всю ее компоненту сильной связности, ну и так далее. Все вершинки пройдет. Для каждой,
[51:23.620 --> 51:28.260]  если она еще белая, то есть если я еще ее ни в какую компоненту сильной связанности не отнес, то я
[51:28.260 --> 51:32.860]  запускаю от нее ДФС по обратным ребрам, и он обходит всю компоненту связанности. Тем самым как раз
[51:32.860 --> 51:37.300]  весь граф подразбивает на вот такие вот облачка, которые являются компонентом сильной связанности.
[51:37.300 --> 51:47.940]  В первом пункте я делаю то же самое, что делал только что для поиска топ-сорта. Значит, а именно,
[51:47.940 --> 51:53.060]  я крашу все в белый, потом в цикле по всем вершинам запускаю ДФС от всех вершин, ну если они
[51:53.060 --> 52:03.980]  белые. И дальше сорчу все вершины в порядке убывания ТАУТ. Тот же самый топ-сорт, я не говорю,
[52:03.980 --> 52:13.340]  что это топ-сорт, потому что граф может быть с циклами. Код точно такой же, да. Нет, уже может
[52:13.340 --> 52:17.420]  быть граф с циклами, более того, КСС разумно находить только в случае, если граф с циклами.
[52:17.420 --> 52:25.420]  Вот я говорю, аналогично поиску топ-сорта. Я не говорю, что я получаю топ-сорт, но я пишу тот же
[52:25.420 --> 52:33.380]  самый код. Я крашу все в белый, потом по всем вершинам запускаю ДФС, теперь у меня все вершины
[52:33.380 --> 52:38.380]  имеют какой-то свой ТАУТ. Вот давайте их посортируем в порядке убывания ТАУТ, так же, как было в топ-сорте.
[52:38.380 --> 52:44.220]  Теперь я получу какую-то перестановку вершин. Я не говорю, что это топ-сорт, но эта перестановка
[52:44.220 --> 52:48.980]  такая же, как строюсь в алгоритме топ-сорта. И дальше я с ней работаю вот таким вот образом.
[52:48.980 --> 52:58.780]  Вот, утверждаю, что не можем, это надо доказывать, сейчас будем делать. Вот утверждается, что очередной
[52:58.780 --> 53:03.180]  каждый такой запуск обойдет в точности ровно одну компонентную силу населения, ничего больше,
[53:03.180 --> 53:21.740]  ничего лишнего не обойдет. Так, перед тем, как перейти к доказательству корректности, давайте
[53:21.740 --> 53:28.900]  про детали всякие поговорим, несущественные. Ну, во-первых, как реализовать ДФС реверснутый,
[53:28.900 --> 53:34.380]  как сделать ДФС по обратным ребрам. Ну, кажется, самое простое, это просто завести явным образом
[53:34.380 --> 53:39.980]  обратный граф, где каждое ребро поменяло свою ориентацию. Если было ребро УВ, то теперь есть
[53:39.980 --> 53:45.420]  ребро ВУ. И дальше этот ДФС по обратным ребрам ведет себя, как обычный ДФС, но уже в новом графе.
[53:45.420 --> 53:50.580]  Когда я поменял ориентацию всех ребер, обратные стали обычными прямыми, я просто запускаю обычный
[53:50.580 --> 53:57.980]  ДФС вот в этом уже новом графе, в реверснутом. Поэтому эта штука, это просто ДФС, ну, на новом
[53:57.980 --> 54:08.980]  графе по факту. Обычный ДФС. И асимпточку надо еще сказать. Здесь пока что тривиальная линия,
[54:08.980 --> 54:18.700]  ну, потому что здесь тривиальные проходы. Это как топсорт работает за N+, мы уже говорили,
[54:18.700 --> 54:25.180]  это линия. Дальше опять ДФС по всем вершинам. Мы знаем, что суммарное время работы всех ДФС
[54:25.260 --> 54:29.420]  это линия опять. Потому что каждый вершина будет просмотрена максимум один раз, точнее ДФС
[54:29.420 --> 54:33.580]  в нее зашел максимум один раз. И каждый ребро просмотрен тоже один раз, потому что он просмотрен
[54:33.580 --> 54:41.740]  только из одного из двух концов. Поэтому время работы здесь будет линейное. Ну вот, теперь
[54:41.740 --> 54:52.060]  давайте доказывать корректность. Мне нужно доказать, что то, что я делаю, действительно находят мне все
[54:52.060 --> 55:03.260]  КСС. Ну, смотрите, во-первых, понятно, что если я запустил в какое-то время ДФС от вершинки В,
[55:03.260 --> 55:11.580]  то по крайней мере всю ее КСС я точно обойду. Потому что она вся, понятное дело, достижима по
[55:11.580 --> 55:17.940]  ребрам из В, потому что есть пути из всех вершин В. Значит, я по обратным ребрам ее всю обойду. Вопрос
[55:17.940 --> 55:22.140]  только, не обойду ли я чего-нибудь лишнего. То есть я точно обойду всю свою компоненту, потому
[55:22.140 --> 55:28.540]  что она достижима по ребрам. Почему не обойду лишнего? Вот это надо только понять. Надо показать,
[55:28.540 --> 55:37.340]  что ДФС по обратным ребрам от вершины В не обходит лишнего.
[55:48.780 --> 55:57.060]  Вот. Ну, для этого давайте такое утверждение докажем. Пусть у нас есть две компоненты
[55:57.060 --> 56:09.820]  соссетительной связности, между которыми есть ребро. Пусть есть хотя бы одно ребро из С1 в С2.
[56:17.940 --> 56:20.220]  Значит, тогда верно следующее.
[56:47.940 --> 56:57.540]  То есть вот есть у меня одна компонент С1 и другая С2. Пусть между ними есть какое-то
[56:57.540 --> 57:02.860]  ребро. Возможно, их может быть несколько, потому что, скажем, может идти ребро отсюда сюда, отсюда
[57:02.860 --> 57:10.980]  сюда, отсюда сюда и так далее. Неважно. Вот. Если есть хотя бы одно, тогда я утверждаю, что максимальный
[57:10.980 --> 57:17.580]  ТА по всем вершинкам отсюда больше, чем максимальный ТА по всем вершинкам здесь. То есть, грубо говоря,
[57:17.580 --> 57:27.420]  момент времени выхода отсюда больше момента времени выхода отсюда. Зачем это нам нужно? Ну вот
[57:27.420 --> 57:32.220]  ровно для того, чтобы показать, что мы ничего лишнего не находим. Потому что в этом случае,
[57:32.220 --> 57:37.660]  если я докажу, что при наличии ребра вот этот, что ТА вот отсюда больше, чем ТА вот отсюда,
[57:37.660 --> 57:42.780]  это будет означать, что как раз вот эта вот вершина, где достигается от максимуму, вот этот В,
[57:43.380 --> 57:48.520]  где достигается максимум ТАута, να в пересновке будет раньше, чем все что вот это вот. Потому что
[57:48.520 --> 57:55.420]  у нее ТАут больше, чем все вот эти вот. Значит, ДФС-реверснутый сначала запустится от В и только
[57:55.420 --> 58:00.880]  потом от каких-то вершин вот этой компоненты, потому что у неё ТАут чем у всех остальных. Значит,
[58:00.880 --> 58:06.300]  сначала ДФС-реверснутый запустится от нее, обойдет все, что достижено по обратным ребрам. Это как раз
[58:06.300 --> 58:10.980]  вот эта компонента связанности. А потом в будущем запустится от какой-то вершины из этой компоненты.
[58:10.980 --> 58:15.480]  Он обойдет всю С2, но в С1 уже не пойдет, потому что там уже были.
[58:15.480 --> 58:18.480]  На все эти вершины уже отнесены какой-то КСС.
[58:18.480 --> 58:22.480]  Поэтому мы по этому ребру не пойдем, то есть хотя и есть вот это обратное ребро,
[58:22.480 --> 58:26.480]  но мы по нему не идем, потому что они все и так уже назначены в какой-то КСС.
[58:28.480 --> 58:29.480]  Окей?
[58:29.980 --> 58:31.480]  Ну что, давайте доказывать.
[58:36.480 --> 58:39.480]  Так, кстати вопрос, а может ли быть вот в такой картинке,
[58:39.480 --> 58:42.980]  если у меня есть ребро из С1 в С2, может ли быть обратный ребро из С2 в С1?
[58:43.980 --> 58:47.980]  Не может, да, потому что иначе, если бы оно было, это бы все скрылось в одну КСС,
[58:47.980 --> 58:51.980]  потому что есть пути как бы и отсюда-сюда, и отсюда-сюда, они все были бы в одной КСС.
[58:51.980 --> 58:53.980]  Поэтому точно таких обратных ребер нет.
[58:55.980 --> 58:57.980]  Ну теперь давайте вот это вот доказывать.
[59:01.980 --> 59:03.980]  Я мальчик ленивый, сделаю то же самое.
[59:03.980 --> 59:07.980]  Давайте посмотрим из всех вот этих вот вершин вершину с минимальным тейном.
[59:09.980 --> 59:18.980]  Среди всех вершин С1 и С2 выберем вершину с минимальным тейном.
[59:21.980 --> 59:26.980]  Выберем вершину с минимальным значением тейном.
[59:33.980 --> 59:34.980]  Ну опять два случая.
[59:35.980 --> 59:37.980]  Откуда она, из С1 или из С2?
[59:39.980 --> 59:42.980]  Пусть она в С1.
[59:52.980 --> 59:58.980]  Вот, то есть Тин от Х меньше, чем Тин от всех остальных вот этих вершин.
[01:00:01.980 --> 01:00:04.980]  Ну тогда вроде понятно, к моменту времени входа в Х
[01:00:04.980 --> 01:00:07.980]  все остальные вершины обеих компонентов еще белые,
[01:00:08.480 --> 01:00:11.480]  и более того, из Х есть пути в них вовсе,
[01:00:11.480 --> 01:00:14.480]  потому что внутри компоненты сильной связанности есть все пути.
[01:00:14.480 --> 01:00:17.480]  Более того, из Х можно добраться досюда,
[01:00:17.480 --> 01:00:20.480]  а потом с помощью ребра досюда и посетить всю С2.
[01:00:20.480 --> 01:00:23.480]  Поэтому из Х достижимо и С1 и С2 целиком.
[01:00:25.480 --> 01:00:28.480]  Поэтому к моменту времени выхода из Х
[01:00:28.480 --> 01:00:31.480]  все вот это вот уже будет помещено черным.
[01:00:31.480 --> 01:00:33.480]  Потому что из Х все это достижимо,
[01:00:33.480 --> 01:00:37.480]  значит к моменту времени выхода из Х, опять по леме о белых путях,
[01:00:37.980 --> 01:00:39.980]  все вот это перекрасится в черный,
[01:00:39.980 --> 01:00:42.980]  значит Та от Х будет больше, чем все остальное.
[01:00:44.980 --> 01:00:47.980]  То есть по леме о белых путях,
[01:00:50.980 --> 01:00:54.980]  к моменту времени выхода из Х,
[01:00:54.980 --> 01:00:57.980]  то есть к моменту Та от Х,
[01:01:00.980 --> 01:01:03.980]  С2 и С1 целиком перекрасятся в черный цвет.
[01:01:04.480 --> 01:01:06.480]  Ну это как раз и означает,
[01:01:06.480 --> 01:01:10.480]  что Та от Х больше,
[01:01:10.480 --> 01:01:14.480]  чем максимально возможное значение Та по всем вершинам С2.
[01:01:22.480 --> 01:01:24.480]  То есть я сначала из них из всех вышел,
[01:01:24.480 --> 01:01:26.480]  только потом из Х.
[01:01:26.480 --> 01:01:29.480]  То есть, если я из них вышел из С2,
[01:01:29.980 --> 01:01:31.980]  то есть я сначала из них из всех вышел,
[01:01:31.980 --> 01:01:33.980]  только потом из Х.
[01:01:40.980 --> 01:01:42.980]  Нормально?
[01:01:47.980 --> 01:01:50.980]  Так, ну теперь противоположный случай,
[01:01:50.980 --> 01:01:53.980]  когда она наоборот в С2.
[01:01:54.980 --> 01:01:56.980]  Пусть она в С2.
[01:01:59.980 --> 01:02:03.980]  То есть вершина с минимальным Тином,
[01:02:03.980 --> 01:02:06.980]  она находится во второй компоненте,
[01:02:06.980 --> 01:02:08.980]  сильно связанная с С2.
[01:02:12.980 --> 01:02:14.980]  Вот, ну тогда я утверждаю,
[01:02:14.980 --> 01:02:16.980]  что к моменту времени выхода из нее,
[01:02:16.980 --> 01:02:19.980]  С2 вся перекрасится в черный,
[01:02:19.980 --> 01:02:21.980]  а С1 останется белый.
[01:02:22.480 --> 01:02:26.480]  То есть к моменту Та от Х,
[01:02:28.480 --> 01:02:30.480]  вся С2 перекрасится в черный,
[01:02:36.480 --> 01:02:38.480]  а С1 останется белый.
[01:02:52.480 --> 01:02:54.480]  Да, ну потому что мы уже поняли,
[01:02:54.480 --> 01:02:57.480]  что не просто даже нет ребер из С2 в С1,
[01:02:57.480 --> 01:02:59.480]  а даже нет путей из С2 в С1.
[01:02:59.480 --> 01:03:01.480]  Потому что если бы был какой-то путь из С2 в С1,
[01:03:01.480 --> 01:03:03.480]  то они бы все замкнулись в один большой цикл
[01:03:03.480 --> 01:03:05.480]  и была бы одна общая КСС.
[01:03:06.480 --> 01:03:08.480]  Значит, полямия белых путях,
[01:03:08.480 --> 01:03:10.480]  к моменту времени выхода из Х,
[01:03:10.480 --> 01:03:12.480]  я в С1 вообще даже не зайду,
[01:03:12.480 --> 01:03:14.480]  потому что оно недостижимо просто.
[01:03:14.480 --> 01:03:16.480]  Поэтому сначала обойдется вся С2,
[01:03:16.480 --> 01:03:18.480]  вся она поместится в черный,
[01:03:18.480 --> 01:03:20.480]  и только потом когда-то в будущем посетится С1.
[01:03:20.480 --> 01:03:22.480]  То есть Та у Т вот отсюда больше,
[01:03:22.480 --> 01:03:24.480]  чем Та вот отсюда.
[01:03:24.480 --> 01:03:26.480]  Тогда...
[01:03:30.480 --> 01:03:32.480]  Ну может даже так написать,
[01:03:32.480 --> 01:03:34.480]  для любого В из С1,
[01:03:34.480 --> 01:03:36.480]  для любого У из С2,
[01:03:36.480 --> 01:03:38.480]  Та у В больше, чем Та у.
[01:03:43.480 --> 01:03:45.480]  Потому что сначала вся С2,
[01:03:45.480 --> 01:03:47.480]  а потом только после этого вся С1.
[01:03:50.480 --> 01:03:52.480]  Вот, вроде доказали.
[01:03:52.480 --> 01:03:54.480]  Корректность доказали,
[01:03:54.480 --> 01:03:56.480]  то есть мы реально,
[01:03:56.480 --> 01:03:58.480]  мы в хорошем порядке обходим все эти КССки,
[01:03:58.480 --> 01:04:00.480]  что мы никогда не пытаемся
[01:04:00.480 --> 01:04:02.480]  по обратному ребру перейти
[01:04:02.480 --> 01:04:04.480]  из одной компоненты в другую.
[01:04:04.480 --> 01:04:06.480]  Мы именно их сначала вот эту обойдем,
[01:04:06.480 --> 01:04:08.480]  потом вот эту, потом эту и так далее.
[01:04:08.480 --> 01:04:10.480]  То есть мы ничего лишнего никогда не обходим.
[01:04:10.480 --> 01:04:12.480]  Ну, например, давайте картинка какая-то.
[01:04:12.480 --> 01:04:14.480]  Например, вот если такой граф, скажем,
[01:04:16.480 --> 01:04:18.480]  на пяти вершинах.
[01:04:18.480 --> 01:04:20.480]  На пяти вершинах.
[01:04:22.480 --> 01:04:24.480]  Ну, здесь понятно, здесь каждая вершина
[01:04:24.480 --> 01:04:26.480]  это отдельное КСС,
[01:04:26.480 --> 01:04:28.480]  потому что нет циклов.
[01:04:30.480 --> 01:04:32.480]  Ну и тогда утверждается,
[01:04:32.480 --> 01:04:34.480]  что мы обязательно сначала вот перед тем,
[01:04:34.480 --> 01:04:36.480]  как вот эту вот вершинку обработать
[01:04:36.480 --> 01:04:38.480]  и сказать, что она сама по себе КСС,
[01:04:38.480 --> 01:04:40.480]  мы обязаны будем обойти вот это и вот это.
[01:04:42.480 --> 01:04:44.480]  Ну понятно, у них просто будет больше Та,
[01:04:44.480 --> 01:04:46.480]  чем у нее, в любом случае.
[01:04:46.480 --> 01:04:48.480]  То есть сначала, скажем, обойдем это, это,
[01:04:48.480 --> 01:04:50.480]  потом это, потом вот эти две.
[01:04:56.480 --> 01:04:58.480]  Так, вопросы, может, какие-то?
[01:05:04.480 --> 01:05:06.480]  Ну, хорошо.
[01:05:06.480 --> 01:05:08.480]  Еще раз?
[01:05:08.480 --> 01:05:10.480]  Не, ну как красим?
[01:05:10.480 --> 01:05:12.480]  Они где-то там внутри,
[01:05:12.480 --> 01:05:14.480]  вот они где-то внутри ДФСа,
[01:05:14.480 --> 01:05:16.480]  но я знаю, что вот если я рассматриваю момент времени, скажем,
[01:05:16.480 --> 01:05:18.480]  от Тин до ТАУТ Х,
[01:05:18.480 --> 01:05:20.480]  то у меня новых серых не появляется,
[01:05:20.480 --> 01:05:22.480]  у меня только какие-то белые перекрасились в черные,
[01:05:22.480 --> 01:05:24.480]  поэтому здесь как бы серые нигде
[01:05:24.480 --> 01:05:26.480]  не появляются, они где-то внутри, внутри ДФСа
[01:05:26.480 --> 01:05:28.480]  появляются,
[01:05:28.480 --> 01:05:30.480]  но вот как бы к моменту времени
[01:05:30.480 --> 01:05:32.480]  ТАУТ от Х,
[01:05:32.480 --> 01:05:34.480]  они уже не просто серыми, они уже и черными стали,
[01:05:34.480 --> 01:05:36.480]  поэтому новых серых здесь нигде не появляются.
[01:05:44.480 --> 01:05:46.480]  Так, значит, мне нужно будет
[01:05:46.480 --> 01:05:48.480]  еще такое наблюдение,
[01:05:48.480 --> 01:05:50.480]  давайте следствие напишу, что ли.
[01:05:50.480 --> 01:05:52.480]  Значит, пусть
[01:05:52.480 --> 01:05:54.480]  для каждой вершинки
[01:05:54.480 --> 01:05:56.480]  у меня заводится некое значение
[01:05:56.480 --> 01:05:58.480]  ID от В,
[01:05:58.480 --> 01:06:00.480]  это номер КСС,
[01:06:00.480 --> 01:06:02.480]  содержащий
[01:06:02.480 --> 01:06:04.480]  вершину В.
[01:06:08.480 --> 01:06:10.480]  В том порядке, в котором
[01:06:10.480 --> 01:06:12.480]  его находят
[01:06:12.480 --> 01:06:14.480]  алгоритм Косараю.
[01:06:16.480 --> 01:06:18.480]  В порядке из
[01:06:18.480 --> 01:06:20.480]  алгоритма Косараю.
[01:06:24.480 --> 01:06:26.480]  Ну то есть он же в каком-то порядке
[01:06:26.480 --> 01:06:28.480]  эти компоненты находит,
[01:06:28.480 --> 01:06:30.480]  он сначала нашел одну, потом другую, потом третью и так далее.
[01:06:30.480 --> 01:06:32.480]  Вот давайте ID-шники им всем поставим.
[01:06:32.480 --> 01:06:34.480]  Когда я обхожу очередную КСС,
[01:06:34.480 --> 01:06:36.480]  я говорю, что это там, это нулевая компонента,
[01:06:36.480 --> 01:06:38.480]  здесь везде будут нолики и ID-шники,
[01:06:38.480 --> 01:06:40.480]  это первая, здесь все единичные и так далее.
[01:06:40.480 --> 01:06:42.480]  То есть в каждой вершинке можно записать номер ее КСС,
[01:06:42.480 --> 01:06:44.480]  в какую компоненту я ее отнес.
[01:06:46.480 --> 01:06:48.480]  Вот.
[01:06:48.480 --> 01:06:50.480]  Значит тогда,
[01:06:50.480 --> 01:06:52.480]  если у меня есть какое-то ребро,
[01:06:52.480 --> 01:06:54.480]  скажем, АВ,
[01:06:56.480 --> 01:06:58.480]  тогда у меня есть неравенство
[01:06:58.480 --> 01:07:00.480]  на ID-шники между ними.
[01:07:00.480 --> 01:07:02.480]  Именно, видимо, что ID от А
[01:07:02.480 --> 01:07:04.480]  меньше равно ID от В.
[01:07:10.480 --> 01:07:12.480]  Вот.
[01:07:12.480 --> 01:07:14.480]  Ну вроде более-менее тривиально.
[01:07:14.480 --> 01:07:16.480]  Значит давайте разберем два случая,
[01:07:16.480 --> 01:07:18.480]  в одной они компоненте или нет.
[01:07:18.480 --> 01:07:20.480]  Значит, если
[01:07:20.480 --> 01:07:22.480]  А и В в одной КСС,
[01:07:24.480 --> 01:07:26.480]  то, ну понятно дело, ID-шники просто равны.
[01:07:28.480 --> 01:07:30.480]  Да, мы доказали, что Косараю корректно работает
[01:07:30.480 --> 01:07:32.480]  и все.
[01:07:32.480 --> 01:07:34.480]  А если,
[01:07:34.480 --> 01:07:36.480]  если у меня есть неравенство,
[01:07:36.480 --> 01:07:38.480]  если у меня есть неравенство,
[01:07:38.480 --> 01:07:40.480]  мы доказали, что Косараю корректно работает
[01:07:40.480 --> 01:07:42.480]  и все вершины разбивают правильным образом
[01:07:42.480 --> 01:07:44.480]  на компоненте сильно связанности,
[01:07:44.480 --> 01:07:46.480]  значит если они в одной КСС, то у них будет одинаковый номер.
[01:07:48.480 --> 01:07:50.480]  Если в разных,
[01:07:50.480 --> 01:07:52.480]  то они обязательно вот в какой-то
[01:07:52.480 --> 01:07:54.480]  такой вот картинке лежат.
[01:07:54.480 --> 01:07:56.480]  Поскольку у меня есть ребро из А в В,
[01:07:56.480 --> 01:07:58.480]  и они в разных КСС, то вот это вот А, вот это вот В.
[01:07:58.480 --> 01:08:00.480]  На этой картинке они лежат в разных КСС,
[01:08:00.480 --> 01:08:02.480]  между которыми есть ребро,
[01:08:02.480 --> 01:08:04.480]  и вот именно А и В концы этого ребра.
[01:08:04.480 --> 01:08:06.480]  Иначе,
[01:08:06.480 --> 01:08:08.480]  у меня картинка ровно вот такая.
[01:08:14.480 --> 01:08:16.480]  Тогда я хочу доказать, что ID от А
[01:08:16.480 --> 01:08:18.480]  строго меньше, чем ID от В.
[01:08:22.480 --> 01:08:24.480]  Ну, вроде понятно.
[01:08:24.480 --> 01:08:26.480]  Мы доказывали, что если у меня есть ребро
[01:08:26.480 --> 01:08:28.480]  между компонентами,
[01:08:28.480 --> 01:08:30.480]  то сначала обойдется вот это, потом вот это.
[01:08:32.480 --> 01:08:34.480]  Да, значит есть ребро.
[01:08:36.480 --> 01:08:38.480]  То есть,
[01:08:40.480 --> 01:08:42.480]  из С1 в С2,
[01:08:42.480 --> 01:08:44.480]  следовательно,
[01:08:44.480 --> 01:08:46.480]  DFS, вот этот вот реверснутый,
[01:08:46.480 --> 01:08:48.480]  сначала обойдется С1, потом С2.
[01:08:58.480 --> 01:09:00.480]  Значит, ID-шники
[01:09:00.480 --> 01:09:02.480]  соотносят так, как нам нужно.
[01:09:02.480 --> 01:09:04.480]  Значит, ID от А будет даже строго
[01:09:04.480 --> 01:09:06.480]  меньше, чем ID от В.
[01:09:22.480 --> 01:09:24.480]  Правда же?
[01:09:26.480 --> 01:09:28.480]  Хорошо.
[01:09:28.480 --> 01:09:30.480]  Тогда, зачем мне это нужно?
[01:09:30.480 --> 01:09:32.480]  Для следующей задачи.
[01:09:38.480 --> 01:09:40.480]  Задача называется
[01:09:40.480 --> 01:09:42.480]  два-сад.
[01:09:44.480 --> 01:09:46.480]  Задача такая.
[01:09:46.480 --> 01:09:48.480]  Представьте себе, что у вас есть
[01:09:48.480 --> 01:09:50.480]  пропозициональная формула в виде
[01:09:50.480 --> 01:09:52.480]  два KNF.
[01:09:52.480 --> 01:09:54.480]  Например, какая-то вот такая.
[01:09:54.480 --> 01:09:56.480]  Х или не Y,
[01:09:56.480 --> 01:09:58.480]  и
[01:09:58.480 --> 01:10:00.480]  Z и Y,
[01:10:00.480 --> 01:10:02.480]  и там, скажем, A или
[01:10:02.480 --> 01:10:04.480]  не X. Ну, короче, вот что-то такое.
[01:10:04.480 --> 01:10:06.480]  То есть, конъюнкция
[01:10:06.480 --> 01:10:08.480]  скобок. В каждой скобке
[01:10:08.480 --> 01:10:10.480]  дизъюнкция литералов
[01:10:10.480 --> 01:10:12.480]  переменных или их отрицаний.
[01:10:14.480 --> 01:10:16.480]  Соответственно, формула в два KNF.
[01:10:24.480 --> 01:10:26.480]  Давайте научимся
[01:10:26.480 --> 01:10:28.480]  проверять ее на выполнимость.
[01:10:30.480 --> 01:10:32.480]  То есть, что такое два-сад?
[01:10:32.480 --> 01:10:34.480]  Два от, собственно, два KNF,
[01:10:34.480 --> 01:10:36.480]  сад от solo satisfiability, выполнимость формулы.
[01:10:36.480 --> 01:10:38.480]  Давайте узнаем, выполнима она или нет.
[01:10:38.480 --> 01:10:40.480]  То есть, существует ли хоть какой-то набор,
[01:10:40.480 --> 01:10:42.480]  на котором она единичная.
[01:10:42.480 --> 01:10:44.480]  Соответственно, вопрос.
[01:10:44.480 --> 01:10:46.480]  Существует ли
[01:10:46.480 --> 01:10:48.480]  набор значений переменных,
[01:10:48.480 --> 01:10:50.480]  на котором она единичная?
[01:10:56.480 --> 01:10:58.480]  Давайте сделаем следующее.
[01:10:58.480 --> 01:11:00.480]  Давайте мы все вот эти
[01:11:00.480 --> 01:11:02.480]  дизъюнкции, которые все должны
[01:11:02.480 --> 01:11:04.480]  одновременно выполняться,
[01:11:04.480 --> 01:11:06.480]  поскольку у меня идет конъюнкция скобок,
[01:11:06.480 --> 01:11:08.480]  мне нужно, чтобы все дизъюнкции
[01:11:08.480 --> 01:11:10.480]  выполнялись одновременно.
[01:11:10.480 --> 01:11:12.480]  Чтобы все скобки одновременно выполнились.
[01:11:12.480 --> 01:11:14.480]  Давайте каждую скобку заменим
[01:11:14.480 --> 01:11:16.480]  на две эквивалентные импликации.
[01:11:16.480 --> 01:11:18.480]  То есть, а именно
[01:11:18.480 --> 01:11:20.480]  вот такую дизъюнкцию
[01:11:20.480 --> 01:11:22.480]  можно эквивалентным образом
[01:11:22.480 --> 01:11:24.480]  переписать, как вот такую импликацию.
[01:11:24.480 --> 01:11:34.120]  переписать как вот такую импликацию. Или как вот такую импликацию. Это всё
[01:11:34.120 --> 01:11:37.800]  эквивалентная запись. Потому что если мне нужно, чтобы хотя бы одно из них было
[01:11:37.800 --> 01:11:45.720]  истина, то значит, если не первое, то второе, если не второе, то первое. А дальше давайте
[01:11:45.720 --> 01:11:50.760]  эти импликации воспринимать как стрелки в графе, как ребра в графе. То есть буквально
[01:11:50.760 --> 01:11:55.680]  давайте заведем граф, вершинами которого будет выступать все переменные отрицания.
[01:11:55.680 --> 01:12:08.280]  Сейчас я заведу граф. Вершины все p и не p, то есть все переменные отрицания
[01:12:08.280 --> 01:12:12.520]  переменных. Ну а ребра вот такие, как нам диктуют вот эти вот импликации. То есть я
[01:12:12.520 --> 01:12:16.960]  каждую скобку расписываю как вот такие две эквивалентные импликации и провожу буквально
[01:12:16.960 --> 01:12:26.720]  вот такие ребра, как оно говорит. Из не a в b, из не b в a. На ребра как диктуют импликации.
[01:12:26.720 --> 01:12:40.680]  Так, мотлок же у всех был, да? Никого не пугает с левой импликации.
[01:12:40.680 --> 01:13:04.080]  Вот, построил граф. Ну а дальше теорема. Я утверждаю, что phi выполнимо,
[01:13:04.080 --> 01:13:16.360]  то есть у нее существует набор, на котором она единична, если и только если для каждой
[01:13:16.360 --> 01:13:23.000]  переменной p. p и не p находятся в разных компонентах сильной связности.
[01:13:23.000 --> 01:13:39.400]  Формула выполнима, если и только если для каждой переменной, а на ее отрицание находится в
[01:13:39.400 --> 01:13:48.000]  разных кусках, в разных компонентах сильной связности. Доказались. Давайте слева направо
[01:13:48.000 --> 01:13:57.000]  от противного. Пусть и выполнимо, но при этом для какой-то переменной она и ее отрицание лежат
[01:13:57.000 --> 01:14:09.400]  в одной компоненте сильной связности. То есть i. p равно i. p. Ну что это значит? Значит,
[01:14:09.400 --> 01:14:15.840]  они лежат в каком-то таком общем облачке, а что есть пути обе стороны? Ну, есть вот такой
[01:14:15.840 --> 01:14:26.520]  какой-то путь по ребрам и есть обратный путь по ребрам. По импликациям на самом деле. Вот,
[01:14:26.520 --> 01:14:31.080]  ну тогда это значит, что phi точно выполнимо быть не может, потому что p никакое значение принять не
[01:14:31.080 --> 01:14:39.840]  может. Потому что, например, если по единичке, представьте, p равно 1, тогда все, что достижено
[01:14:39.840 --> 01:14:43.240]  из p по стрелкам, тоже должно быть истинным на самом деле, потому что у нас есть правило,
[01:14:43.240 --> 01:14:47.760]  что для истинности импликации из нички может следовать только единичка, из истинной следует
[01:14:47.760 --> 01:14:53.640]  только истина. Поэтому если здесь 1, то все вот эти товарищи тоже 1. То есть если это истинно,
[01:14:53.640 --> 01:14:57.600]  то все вот эти по дороге тоже истины. Значит, не по истинно, что не может быть одновременно с
[01:14:57.600 --> 01:15:03.040]  тем, что по истинно. Ну и обратно, если не по истинно, то вдоль этого пути все должны быть истинны,
[01:15:03.040 --> 01:15:07.720]  то есть p должно быть истинно противоречием. Просто p не может принять никакое значение.
[01:15:07.720 --> 01:15:29.400]  Согласны? Вот, это простую сторону. Теперь обратно. Теперь обратно. Утверждается,
[01:15:29.400 --> 01:15:34.560]  что если такого выраженного случая не произошло, если мы не нашли явного противоречия, то что здесь
[01:15:34.560 --> 01:15:38.960]  написано? Здесь написано, что по факту p и p должны принять одинаковые значения, потому что отсюда
[01:15:38.960 --> 01:15:43.040]  следует это, отсюда следует это. Они все должны принять равное значение. Такого быть не может,
[01:15:43.040 --> 01:15:48.080]  потому что p и p обязательно дополняют друг друга. Вот утверждается, что если такого выраженного
[01:15:48.080 --> 01:15:53.560]  случая не получилось, то никаких других противоречий нету, и можно подобрать правильный набор значений
[01:15:53.560 --> 01:16:02.520]  переменных, который бы нашу формулу заединищил. Давайте его построим. Значит, построим явным
[01:16:02.520 --> 01:16:15.280]  образом выполняющий набор. Построим выполняющий набор. А именно, для каждой переменной p, поскольку
[01:16:15.280 --> 01:16:20.280]  она и ее отрицания лежат в разных компонентах сильно связанности, то здесь написано какое-то
[01:16:20.280 --> 01:16:27.560]  неравенство, меньше или больше. Давайте тогда скажем, что истинен тот литерал, который и лежит в
[01:16:27.560 --> 01:16:35.600]  большей компоненте сильно связанности. А именно, для любой p сделаю следующее. Если id p больше,
[01:16:35.600 --> 01:16:47.560]  чем id не p, то я говорю, что p равно единице, а иначе ноль. Иначе, если, наоборот, в обратную
[01:16:47.560 --> 01:17:02.200]  сторону id не p больше, то, наоборот, p равно нулю. Я считаю, что истинен тот литерал, который лежит в
[01:17:02.200 --> 01:17:07.240]  большей компоненте сильно связанности, с большим номером в смысле. Вот здесь id p больше, поэтому
[01:17:07.240 --> 01:17:13.960]  p единичка. И здесь id не p больше, поэтому вот это истинно, то есть p равно нулю. Вот давайте так
[01:17:13.960 --> 01:17:29.840]  фиксируем значение всех переменных. Давайте так фиксируем значение всех переменных.
[01:17:29.840 --> 01:17:41.480]  Теперь докажем, что этот набор значений действительно выполняющий. Докажем, что
[01:17:41.480 --> 01:18:04.280]  это набор выполняющий. Ну вот противно. Пусть не так, пусть мы фиксировали значение всех
[01:18:04.280 --> 01:18:10.680]  переменных, и фи почему-то ноль. Ну раз фи ноль, значит какая-то конкретная скобка нулевая.
[01:18:10.680 --> 01:18:15.960]  А фи это конъюнкция скобок. Если конъюнкция нулевая, значит какая-то конкретная скобка равна нулю.
[01:18:15.960 --> 01:18:23.000]  Значит, тогда существует конкретная скобка х или у, которая равна нулю при вот том вот конкретном
[01:18:23.000 --> 01:18:30.200]  наборе значений. Возможно, там х идет с отрицанием, у с отрицанием неважно. Я считаю, что это как бы
[01:18:30.200 --> 01:18:34.960]  литерал. То есть х сам по себе может быть сам отрицанием. Возможно, здесь написано не х,
[01:18:34.960 --> 01:18:43.080]  или здесь написано не у. Это неважно. Здесь дюнкция нулевая. Это значит, что обе переменные нулевые.
[01:18:43.080 --> 01:18:51.760]  Точнее оба литерала нулевые. х и у равны нулю. Давайте вспоминать, когда мы переменной могли
[01:18:51.760 --> 01:19:01.840]  поставить нулевое значение. Только если у нее ID-шник и ее отрицание больше, чем ID от нее самой.
[01:19:01.840 --> 01:19:10.520]  Это правило, по которому мы выставляем значение переменных. Если оно ноль, значит у нее у отрицания
[01:19:10.520 --> 01:19:24.480]  и ID-шник больше. Ну и то же самое для у. Но, более того, кроме этого, я еще могу заметить следующее,
[01:19:24.480 --> 01:19:31.840]  что в графе у меня обязательно есть два ребра. Есть ребро из не х в у и из не у в х.
[01:19:31.840 --> 01:19:45.320]  И осталось применить вот этот факт, что при наличии ребра в графе у меня таким
[01:19:45.320 --> 01:19:55.920]  образом соотносятся одишники. Давайте все это склеим. Смотрите, давайте начнем с ID не х,
[01:19:55.920 --> 01:20:03.400]  вот этой штуки. За счет того, что существует ребро в у, ID от не х будет меньше либо равно,
[01:20:03.400 --> 01:20:16.560]  чем ID от у. Это вот это вот следствие. Дальше, ID от у строго меньше, чем ID от не у. Вот тут
[01:20:16.560 --> 01:20:24.560]  это написано. Дальше, из не у есть ребро в х, поэтому опять-таки последствию это значение не больше,
[01:20:24.560 --> 01:20:34.160]  чем ID от х, потому что есть вот такой ребро. Но при этом ID от х меньше, чем ID от не х.
[01:20:34.160 --> 01:20:52.360]  Значит мы получили что число меньше, чем оно само, противоречие. Вот, то есть тот набор
[01:20:52.360 --> 01:20:58.120]  значений, который мы определили, реально выполняет все скобки одновременно. Потому что если какую-то не
[01:20:58.120 --> 01:21:03.880]  выполняет, то мы можем легко прийти к противоречию с помощью вот этого факта. Все. Поэтому для того,
[01:21:03.880 --> 01:21:08.520]  чтобы решить эту задачу, для того чтобы найти у фи какой-нибудь выполняющий набор, мне достаточно
[01:21:08.520 --> 01:21:15.040]  построить граф, выделить в нем кс ски и всем переменным присвоить какое-то значение в зависимости
[01:21:15.040 --> 01:21:24.080]  того, у кого ID компоненты больше. Работает опять-таки за линейное время. Если у меня сколько-то
[01:21:24.080 --> 01:21:29.600]  переменных и сколько-то скобок, то у меня граф на удвоенном количестве переменных идет,
[01:21:29.600 --> 01:21:34.960]  потому что для каждой переменной две вершины, она и отрицание. И для каждой скобки,
[01:21:34.960 --> 01:21:42.560]  для каждой скобки коих с, у меня будет суммарно 2 умножить на с ребер, потому что каждая скобка
[01:21:42.560 --> 01:21:49.320]  дает мне две стрелки на два ребра. То есть время работы получается линейным от к плюс с,
[01:21:49.320 --> 01:21:56.000]  где к число переменных, с число скобок. Как-то так. Все, спасибо.
