[00:00.000 --> 00:18.000]  Сегодня последняя лекция по динамику, на следующей неделе у нас годной, потому что праздники, и к следующему неделю лекция по динамику.
[00:18.000 --> 00:37.000]  Вот, а сегодня я буду говорить про динамику по маскам, по подножию.
[00:37.000 --> 00:51.000]  Сначала договоримся, как мы можем удобно кодировать маленькие множества.
[00:51.000 --> 01:00.000]  Вот такое множество, зарегиум какое-нибудь небольшое число.
[01:00.000 --> 01:05.000]  Я обычно говорю, что n примерно 30.
[01:05.000 --> 01:07.000]  Давайте так и оставим.
[01:07.000 --> 01:09.000]  n не больше чем 30.
[01:09.000 --> 01:14.000]  Я хотел бы иметь образ, иметь эффективно кодировать его под множество.
[01:14.000 --> 01:26.000]  Понятно, что это всего 2,7n, включая все множество.
[01:26.000 --> 01:28.000]  И как мы будем кодировать эти множества?
[01:28.000 --> 01:32.000]  Ну, мы могли бы кодировать их, например, просто списком элементов.
[01:32.000 --> 01:40.000]  Или как-нибудь, например, бинарной строковой динамик, которая имеет линию на тех местах, где элементы есть, и ноль их там, где нет.
[01:40.000 --> 01:42.000]  Но все это очень эффективно.
[01:42.000 --> 01:46.000]  Мы будем в виде чисел.
[01:46.000 --> 01:51.000]  Мы запишем вот столько бинного числа в зависимости от системы числения.
[01:51.000 --> 01:55.000]  Ну и будем опять-таки ставить ноль там, где числа нет, и ноль там, где числа есть.
[01:55.000 --> 02:00.000]  Только еще я разверну это множество и буду писать рог матш.
[02:00.000 --> 02:06.000]  Вот, например, давайте я ставлю у меня универсум.
[02:06.000 --> 02:10.000]  Я его немножечко сейчас переверну.
[02:10.000 --> 02:14.000]  Например, вот такой он у меня.
[02:14.000 --> 02:22.000]  Это если я хочу закодировать множество, например, 4, 3 и 1,
[02:22.000 --> 02:24.000]  то на этой битовой маске будет вот такая строка.
[02:24.000 --> 02:30.000]  Мы ноль у нас нет, мы ставим ноль, 1 есть на 1, 2 нет, 3 и 4 есть, 4 нет.
[02:30.000 --> 02:36.000]  Значит, вот эта битовая строка, если мы будем воспринимать ее как число в зависимости от системы числения,
[02:36.000 --> 02:39.000]  будет наша маска, наша множество.
[02:39.000 --> 02:42.000]  Соответственно, ее можно перейти в дизельную систему числения.
[02:42.000 --> 02:47.000]  Что это будет? Будет 2, плюс 8, плюс 16. Ну, сколько там будет? Это 26.
[02:47.000 --> 02:51.000]  Таким образом, мы, получается, любому подморостю смогли поставить битовую строчку,
[02:51.000 --> 02:53.000]  а значит, просто обычное число.
[02:53.000 --> 02:55.000]  И коль скоро на сцену вот такое не очень большое,
[02:55.000 --> 02:58.000]  то мы можем это даже в какой-нибудь, типа, инт поместить.
[02:58.000 --> 03:03.000]  Если надо, если там, например, до 60, то мы можем использовать long block.
[03:03.000 --> 03:05.000]  Ну и так далее.
[03:05.000 --> 03:09.000]  То есть мы, в принципе, можем какой-нибудь стандартных данных использовать для хранения множества.
[03:10.000 --> 03:14.000]  Вот. И это чтобы подниматься маской нашего множества A.
[03:14.000 --> 03:16.000]  Маска A.
[03:19.000 --> 03:20.000]  Вот.
[03:20.000 --> 03:23.000]  Таким образом, мы научились довольно компактно,
[03:23.000 --> 03:30.000]  используя всего одну, по сути, переменную хранить разовольное подморство заранее фиксированного множества.
[03:30.000 --> 03:34.000]  Да, еще раз повторюсь, что мы записываем биты, как бы, вот наших Сашин.
[03:34.000 --> 03:38.000]  То есть с правой, с правой с конца отвечает мю,
[03:38.000 --> 03:42.000]  с второй с конца единица, с третьей с конца двойки, и так далее.
[03:45.000 --> 03:47.000]  Вот. Ну и раз мы договорились с этим кодированием,
[03:47.000 --> 03:49.000]  то давайте научимся еще что-нибудь с ними делать.
[03:49.000 --> 03:53.000]  Да, например, давайте научимся этим множествам как-нибудь пересекать, обеднять, и так далее.
[03:55.000 --> 04:00.000]  Ну вот представьте себе, у меня были два множества заданные какими-нибудь масками.
[04:00.000 --> 04:03.000]  Ну давайте я назову вот эту маску A, эту маску B.
[04:03.000 --> 04:05.000]  Как их объединить?
[04:07.000 --> 04:11.000]  Что происходит с этими масками, что происходит с этими строчками,
[04:11.000 --> 04:13.000]  когда я пытаюсь объединить два множества?
[04:15.000 --> 04:18.000]  Ну не всем складывается, они скорее логично или берется у них.
[04:19.000 --> 04:25.000]  Потому что в тех позициях, на тех разрядах, где есть хотя бы одна единичка в A или в B,
[04:25.000 --> 04:29.000]  то есть есть элемент в объединении, значит мы должны здесь тоже поставить единичку.
[04:29.000 --> 04:33.000]  А если здесь и здесь контр разрядик были нули, значит и в объединении нет этого элемента,
[04:33.000 --> 04:36.000]  значит и в логическом или их небудь.
[04:36.000 --> 04:40.000]  То есть получается логическая или действует вроде так, как объединение маски.
[04:40.000 --> 04:42.000]  Как объединение множества, окей?
[04:43.000 --> 04:48.000]  Просто по разряну, по битвам мы смотрим, какой элемент есть тут, какой элемент есть тут,
[04:48.000 --> 04:53.000]  и понимаем, что объединение, это в точности дизинкси, да? В точности логической или.
[04:53.000 --> 04:58.000]  Вот, ну аналогично, значит, давайте я вот так вот написать.
[04:58.000 --> 05:02.000]  Пересечение это канюкция, побитывая i, потому что чтобы
[05:02.000 --> 05:05.000]  какой-то разряд, какой-то элемент был в пересечении,
[05:05.000 --> 05:07.000]  не нужно чтобы он был там и там, а это соответственно
[05:07.000 --> 05:11.000]  в точности отражается в логической операции i.
[05:11.000 --> 05:15.000]  Так, что еще?
[05:15.000 --> 05:19.000]  Ну, симметрическая разность бывает полезна довольно часто.
[05:19.000 --> 05:25.000]  Это ксор.
[05:25.000 --> 05:31.000]  Симметрическая разность, давайте я Кругейлера нависую.
[05:31.000 --> 05:35.000]  Симметрическая разность это все, что лежит ровно в одном из двух нольцев.
[05:35.000 --> 05:38.000]  Вот так выглядит.
[05:38.000 --> 05:41.000]  То есть это объединение без пересечения, можно так сказать.
[05:41.000 --> 05:43.000]  Ну и ксор делает ровно вот это.
[05:43.000 --> 05:45.000]  Что такое ксор, да?
[05:45.000 --> 05:48.000]  В конкретном разряде в ксоре у меня единичка получается
[05:48.000 --> 05:52.000]  когда и только тогда, когда ровно один из двух предыдущих битиков был единичкой.
[05:52.000 --> 05:56.000]  То есть я смотрю на этот разряд, чтобы в этом разряде у ксора была единица,
[05:56.000 --> 05:59.000]  либо чтобы здесь была единица, а здесь нет, либо наоборот.
[05:59.000 --> 06:00.000]  Ну это вот сочность тошной картины.
[06:00.000 --> 06:02.000]  Тогда либо я попадаю сюда, либо сюда.
[06:02.000 --> 06:06.000]  Ну не сюда и не сюда. То есть не в пересечении и не во внешности.
[06:06.000 --> 06:08.000]  Окей?
[06:08.000 --> 06:13.000]  Так, разность.
[06:13.000 --> 06:16.000]  А тут есть миллион способов, дайте какой-нибудь предложительный и его задержишь.
[06:28.000 --> 06:31.000]  Да, вот то, что я первое понял, давайте я его напишу.
[06:31.000 --> 06:34.000]  Так, сори, только маленькие буквы я не напишу.
[06:34.000 --> 06:39.000]  Да, я сначала возьму, дизинуюсь, а потом выступаю.
[06:39.000 --> 06:40.000]  Так это годится.
[06:40.000 --> 06:45.000]  То есть вот эта вот штука, это я сначала взял все объединение, включая пересечение.
[06:45.000 --> 06:47.000]  И потом с помощью ксора я вычел B.
[06:47.000 --> 06:50.000]  И осталась у меня только вот эта вот часть A без B.
[06:50.000 --> 06:51.000]  Вот.
[06:51.000 --> 06:52.000]  Так работает.
[06:52.000 --> 06:54.000]  Значит, почему без этого не работал?
[06:54.000 --> 06:57.000]  Если вопрос написал A ксор B, ну мы знаем, что это уже симметрическая разность.
[06:57.000 --> 07:00.000]  Значит, мне нужно, чтобы вот этот ксор работал именно как исключение.
[07:00.000 --> 07:04.000]  Чтобы он работал как исключение, нужно сначала B насильно туда вставить.
[07:04.000 --> 07:08.000]  Я сначала B как бы добавляю A и потом его высекаю через ксор.
[07:09.000 --> 07:10.000]  Например, так.
[07:11.000 --> 07:12.000]  Так.
[07:12.000 --> 07:14.000]  Ну, еще давайте...
[07:16.000 --> 07:17.000]  Все, операция, наверное, хватит.
[07:17.000 --> 07:21.000]  Еще полезный проверка того, что одно множество, это подношение другого.
[07:28.000 --> 07:32.000]  Есть две маски, как проверить, что одна это подношение другого?
[07:33.000 --> 07:34.000]  Пересечение.
[07:34.000 --> 07:35.000]  Пересечение?
[07:35.000 --> 07:36.000]  Нет, подношение.
[07:36.000 --> 07:42.000]  Сначала берем первые две маски и потом сравним, равна ли она с той, которая была.
[07:42.000 --> 07:43.000]  А что пересечение равно A?
[07:43.000 --> 07:44.000]  Да, пересечение равно A.
[07:44.000 --> 07:46.000]  Про или я тоже не понял.
[07:46.000 --> 07:48.000]  У нас есть первая маска, есть вторая маска.
[07:48.000 --> 07:49.000]  Ага.
[07:49.000 --> 07:50.000]  Мы берем...
[07:50.000 --> 07:51.000]  Обычные или?
[07:51.000 --> 07:52.000]  Обычные или.
[07:52.000 --> 07:53.000]  Получится вторая.
[07:53.000 --> 07:54.000]  Она...
[07:54.000 --> 07:55.000]  А.
[07:55.000 --> 07:56.000]  Если одна вторая, то...
[07:56.000 --> 07:57.000]  Да-да-да-да-да-да.
[07:57.000 --> 07:58.000]  Логично, действительно.
[07:58.000 --> 08:01.000]  Ну, давайте я тоже первый, который понял, напишу.
[08:01.000 --> 08:04.000]  Значит, загодется такая проверка.
[08:04.000 --> 08:06.000]  Конъюнция равна верминку.
[08:10.000 --> 08:11.000]  Да, потому что что такое вот это?
[08:11.000 --> 08:13.000]  Мы знаем, что это сочности пересечения.
[08:15.000 --> 08:20.000]  Если это верно, то есть если пересечение равно A, то получается это множество A входит как подношение и сюда и сюда.
[08:20.000 --> 08:22.000]  Значит, A это подношение B.
[08:22.000 --> 08:27.000]  И наоборот, если A это подношение B, ну, собственно, короче, в обратную сторону тривиальный рассуждение.
[08:27.000 --> 08:29.000]  То есть это может быть верно.
[08:29.000 --> 08:36.000]  Ну, в общем, ант двух массок равен 1 из них, если только если вот эта вот одна из них вложена во вторую.
[08:36.000 --> 08:38.000]  Потому что это тривиальный рассуждение.
[08:38.000 --> 08:39.000]  Вот.
[08:39.000 --> 08:41.000]  Но такой нам лучше не нужен.
[08:43.000 --> 08:44.000]  Окей?
[08:45.000 --> 08:46.000]  Так, ну, хорошо.
[08:46.000 --> 08:49.000]  Вроде операция нам хватит.
[08:49.000 --> 08:51.000]  Ну, давайте дальше повторим.
[08:59.000 --> 09:01.000]  Дан граф.
[09:05.000 --> 09:07.000]  Пусть он опять-таки задан материзмежности.
[09:09.000 --> 09:11.000]  Задан он еще.
[09:14.000 --> 09:16.000]  Материзмежности.
[09:20.000 --> 09:23.000]  Надо найти в нем наиболее что по размеру клику.
[09:29.000 --> 09:33.000]  Значит, клика – это набор вершин, которые попарно соединены между собой ребрами.
[09:38.000 --> 09:40.000]  Вот, например, клика на четырех вершинах.
[09:40.000 --> 09:44.000]  Значит, четыре точки, все попарно между собой соединены.
[09:44.000 --> 09:47.000]  Если хотя бы одного из ребр нет, то это уже не клика.
[09:47.000 --> 09:50.000]  Нужно, чтобы вот прям все, все ребра были между ними.
[09:50.000 --> 09:51.000]  То есть есть некий граф.
[09:51.000 --> 09:54.000]  Давайте скажем, на N, N, N, N, N.
[09:54.000 --> 09:57.000]  Есть материзмежности, то есть таблица N на N,
[09:57.000 --> 10:01.000]  которая говорит, соединены соответствующей вершинкой или нет ребром.
[10:01.000 --> 10:04.000]  Ну и вот мне нужно найти как можно больше вершин,
[10:04.000 --> 10:06.000]  так чтобы они попарно были соединены,
[10:06.000 --> 10:10.000]  то есть чтобы в материзмежности, в соответствующей вершине были единички.
[10:13.000 --> 10:14.000]  Понятны условия?
[10:14.000 --> 10:15.000]  Да.
[10:15.000 --> 10:16.000]  Ну, вот.
[10:16.000 --> 10:17.000]  Ну, вот.
[10:17.000 --> 10:18.000]  Ну, вот.
[10:18.000 --> 10:19.000]  Ну, вот.
[10:19.000 --> 10:20.000]  Ну, вот.
[10:20.000 --> 10:21.000]  Ну, вот.
[10:22.000 --> 10:24.000]  Понятны условия?
[10:27.000 --> 10:28.000]  Хорошо.
[10:28.000 --> 10:31.000]  Значит, ну давайте сначала что-нибудь совсем простое.
[10:33.000 --> 10:36.000]  Я обычно здесь в три шага решение рассказываю.
[10:36.000 --> 10:39.000]  Ну, давайте попробуем проследовать.
[10:39.000 --> 10:41.000]  Значит, первое решение просто перебор.
[10:42.000 --> 10:43.000]  Полный перебор.
[10:48.000 --> 10:49.000]  За сколько он работает?
[10:49.000 --> 10:54.000]  Ну, смотрите, подмножество всего два в степени N,
[10:54.000 --> 11:00.000]  и каждое подмножество на корректность можно проверить за квадратичное время,
[11:00.000 --> 11:02.000]  потому что если у нас здесь, скажем, K вершин,
[11:02.000 --> 11:04.000]  которые я хочу проверить на кликовость,
[11:04.000 --> 11:06.000]  то мне нужно за K квадрат перебрать все пары
[11:06.000 --> 11:08.000]  и проверить, что там есть ребро.
[11:08.000 --> 11:12.000]  Поэтому получается решение за два ВН, это N пара.
[11:14.000 --> 11:17.000]  То есть мы сначала перебиваем маску.
[11:19.000 --> 11:22.000]  Перебираем подмножество.
[11:25.000 --> 11:31.000]  И потом за квадрат проверяем, что в этом маске является клик или нет.
[11:35.000 --> 11:41.000]  Проверка подмножества на кликовости.
[11:49.000 --> 11:50.000]  Так.
[11:50.000 --> 11:54.000]  Ну, для этого вот, в частности, например, нужна будет следующая процедурка.
[11:54.000 --> 11:56.000]  Давайте я тоже выпишу.
[11:59.000 --> 12:01.000]  Здесь вот, пожалуйста, будет.
[12:01.000 --> 12:03.000]  Процедура извлечения бита.
[12:12.000 --> 12:17.000]  Это, собственно, способ узнать, что вот здесь стоит на каком-то конкретном месте.
[12:17.000 --> 12:18.000]  Вот здесь маска.
[12:18.000 --> 12:21.000]  Я хочу узнать, какой у нее там бит, скажем, итый.
[12:21.000 --> 12:25.000]  То есть какой бит находится на итом с конца места.
[12:25.000 --> 12:27.000]  Ничто или нет.
[12:27.000 --> 12:28.000]  Процедура.
[12:28.000 --> 12:30.000]  Я ее так буду обозначать.
[12:30.000 --> 12:31.000]  Бит.
[12:31.000 --> 12:33.000]  Как извлечение бита.
[12:33.000 --> 12:35.000]  Где и далее маску.
[12:37.000 --> 12:39.000]  Ну и позицию.
[12:40.000 --> 12:43.000]  Нужно узнать, что стоит на постом месте нашей маски маска.
[12:47.000 --> 12:48.000]  Так.
[12:59.000 --> 13:00.000]  Так.
[13:00.000 --> 13:02.000]  Вот это все знают, что такое больше-больше?
[13:03.000 --> 13:04.000]  Ага.
[13:04.000 --> 13:06.000]  Значит, почему это работает?
[13:06.000 --> 13:08.000]  Вот у меня была маска.
[13:09.000 --> 13:12.000]  Я хочу узнать, что здесь находится на посте справа позиции.
[13:12.000 --> 13:13.000]  Вот на пост.
[13:13.000 --> 13:16.000]  Тогда я сначала сдвигаю ее вправо битого на пост.
[13:16.000 --> 13:17.000]  На пост бить вправо.
[13:17.000 --> 13:18.000]  Что это значит?
[13:18.000 --> 13:21.000]  Это по факту значит, что я вот здесь вот ее обрезаю.
[13:21.000 --> 13:23.000]  Все, что было левее, за нуляю.
[13:23.000 --> 13:25.000]  Да, и вот получается моя маска.
[13:25.000 --> 13:29.000]  Поэтому ее последним битом теперь станет тот, кто раньше был постом.
[13:29.000 --> 13:32.000]  Тот, кто раньше был постом, теперь последний.
[13:32.000 --> 13:35.000]  Ну и чтобы его извлечь, нужно просто поандить соединичкой, собственно.
[13:35.000 --> 13:39.000]  Тогда, если последний бит был единичкой, то у меня в ане будет один.
[13:39.000 --> 13:41.000]  Если последний бит был ноль, то ан будет ноль.
[13:41.000 --> 13:46.000]  Поэтому логическое значение вот этого числа это в точности значение нужном не битом.
[13:46.000 --> 13:47.000]  Согласны?
[13:48.000 --> 13:49.000]  Вот.
[13:49.000 --> 13:50.000]  Можно делать наоборот.
[13:50.000 --> 13:53.000]  Можно андить маску с два в степени поз.
[13:53.000 --> 13:57.000]  То есть оставить маску так, как бы было, посчитать число.
[13:57.000 --> 13:59.000]  Вот это вот здесь единичка, а здесь ноль.
[13:59.000 --> 14:00.000]  То есть один нынче-нынче поз.
[14:00.000 --> 14:01.000]  И поандить.
[14:01.000 --> 14:03.000]  Тоже работает с такой реализацией.
[14:03.000 --> 14:08.000]  Но там, когда ан будет не совсем ноль или один, а будет ноль или два в степени поз.
[14:08.000 --> 14:10.000]  Два в степени поз костуется к true, конечно.
[14:10.000 --> 14:12.000]  Но...
[14:15.000 --> 14:18.000]  Ну, короче, тогда надо понимать, что у вас там возвращается...
[14:18.000 --> 14:22.000]  Вот в этой вот штуке, на самом деле, как бы не было возвращается, а integer.
[14:22.000 --> 14:26.000]  И оно костуется к true, и вот как бы у вас либо ноль, либо два в степени поз.
[14:26.000 --> 14:31.000]  Поэтому, если вы пишите по-другому, то тоже как бы понимаете, как оно работает.
[14:31.000 --> 14:36.000]  То есть если вы сначала единичку сбегаете вправо, и потом андите маску и вот этот вот два в степени поз,
[14:36.000 --> 14:40.000]  тогда он как бы считает два в степени поз, а не единичку.
[14:42.000 --> 14:45.000]  Ну вот, значит, давайте здесь какой-нибудь другой код напишу.
[14:45.000 --> 14:51.000]  Перебор массы, понятно, от нуля до два в степени n-1.
[14:54.000 --> 14:59.000]  Дальше давайте сначала скажу, что эта масса хорошая, от равно true.
[14:59.000 --> 15:05.000]  Потом по всем биткам проходимся и от нуля до n-1.
[15:06.000 --> 15:09.000]  Уже от нуля до n-1.
[15:09.000 --> 15:13.000]  Если оба эти бита включены в маску, то между ними должно быть ребро.
[15:14.000 --> 15:18.000]  Ну давайте я здесь даже сделаю не от нуля, а от i-1.
[15:21.000 --> 15:22.000]  Вот.
[15:22.000 --> 15:30.000]  Значит, соответственно, если это неверно, то есть если оба бита есть на выясненном реброне, то маска плохая.
[15:30.000 --> 15:45.000]  Если бит маск i, и бит маск j, и неверно, что между ними есть ребро, то есть матрица смежности нет или брается и в j,
[15:45.000 --> 15:51.000]  ну, напишу так, м и т же т равно 0.
[15:51.000 --> 15:53.000]  Да, тогда вот равно 0.
[15:53.000 --> 16:06.000]  Ну вроде все, тогда получается на каждой маске мы, по завершению вот этого цикла, знаем корректина на линии.
[16:06.000 --> 16:08.000]  Является на клипе линии.
[16:08.000 --> 16:10.000]  Да?
[16:10.000 --> 16:11.000]  Вот.
[16:11.000 --> 16:18.000]  А как вы считаете, что есть, например, как узнать, какого размера эта маска, то есть сколько там вершин она содержит?
[16:23.000 --> 16:32.000]  То есть мы сейчас знаем, для каждой маски, вот после этого фора, там ток либо true, либо false, корректная она или некорректная клика.
[16:32.000 --> 16:35.000]  Как узнать размер, то есть как узнать, сколько вершин в ней находится?
[16:40.000 --> 16:48.000]  Да, например, так, можно еще один цикл по всем битам запустить, просумирую, сколько раз оно вышло в единичку, да, я думаю, в сущности размер.
[16:48.000 --> 16:49.000]  Вот.
[16:49.000 --> 16:58.000]  Либо же можно воспользоваться встроенной функцией в плюсах, по крайней мере, если вот такая вот, built into count.
[17:05.000 --> 17:06.000]  Вот.
[17:06.000 --> 17:11.000]  Эта функция, которая вам за единицу разрешает количество бит в маске.
[17:12.000 --> 17:19.000]  Соответственно, вместо того, чтобы писать еще один цикл, можно вызвать встроенную функцию, которая вам размер маски вернет.
[17:19.000 --> 17:26.000]  То есть давайте напишем, что это возвращает количество единиц в маску.
[17:29.000 --> 17:30.000]  Вот.
[17:30.000 --> 17:36.000]  Ну и соответственно, нужно вывести маску, которая является кликой, то есть которая, ок, равно true, и вот это значение максимально возможно.
[17:41.000 --> 17:42.000]  Так.
[17:42.000 --> 17:45.000]  Решение второе.
[17:45.000 --> 17:50.000]  Будет за, я в ступене nine.
[17:50.000 --> 17:52.000]  Смотрите.
[17:52.000 --> 17:56.000]  Давайте мы, вот эти значения, оке, давайте будем вспоминать.
[17:56.000 --> 18:01.000]  Давайте для каждой маски, для которой мы уже нашли ответ, сохраним в какой-нибудь DP-шку.
[18:01.000 --> 18:04.000]  Пусть DP вот маска.
[18:04.000 --> 18:09.000]  Ну и соответственно, true или false, является ли маской или кликой.
[18:09.000 --> 18:11.000]  True.
[18:11.000 --> 18:14.000]  Если маска, то клика.
[18:16.000 --> 18:19.000]  False и nine.
[18:19.000 --> 18:21.000]  True.
[18:21.000 --> 18:24.000]  Если маска, то клика.
[18:24.000 --> 18:27.000]  False и nine.
[18:28.000 --> 18:31.000]  False и nine.
[18:35.000 --> 18:37.000]  Будем эту пэшу насчитывать.
[18:37.000 --> 18:42.000]  Если мы ее всю насчитаем, то опять-таки мы для каждой маски знаем, является ли она кликой или нет.
[18:42.000 --> 18:47.000]  И с клик нужно выбрать самую большую, потом поразумерить, с помощью built-in попкана, например.
[18:47.000 --> 18:51.000]  Значит, как это делать?
[18:51.000 --> 18:53.000]  Как это делать? Смотрите.
[18:53.000 --> 18:58.000]  Вот если есть какое-то множество маск, как проверить, что он является кликой?
[18:58.000 --> 19:00.000]  Например, можно сделать следующее.
[19:00.000 --> 19:07.000]  Давайте мы из этого множества вытащим одну произвольную вышивку.
[19:07.000 --> 19:10.000]  Откусим В из множества.
[19:10.000 --> 19:13.000]  Соответственно, тогда мне нужно, чтобы вот это все было кликой.
[19:13.000 --> 19:15.000]  То есть маска без В была кликой.
[19:15.000 --> 19:19.000]  А еще В была бы соединена со всеми вот этими вот вышивками.
[19:21.000 --> 19:23.000]  Вот вам решение.
[19:23.000 --> 19:28.000]  То есть мы сначала находим произвольную вышивку В, отбрасываем ее из маски, проверяем, что маска без В это клика.
[19:28.000 --> 19:32.000]  А потом за линию проверяем, что В соединена со всеми вышивками из маски.
[19:36.000 --> 19:42.000]  Значит, пусть В произвольная линия в маске.
[19:43.000 --> 19:53.000]  Давайте я пока напишу так вот, как неудобно.
[19:53.000 --> 19:56.000]  А маска без В является кликой.
[19:56.000 --> 19:59.000]  То есть эта штука равна трубе.
[19:59.000 --> 20:05.000]  И В соединена со всеми вершинами из множества маски без В.
[20:12.000 --> 20:28.000]  То тогда маска это клика.
[20:33.000 --> 20:36.000]  Ну вот, собственно, необходимая достаточная условия.
[20:36.000 --> 20:39.000]  Мы можем любую вершину откручивать, проверить, что остаток это клика.
[20:39.000 --> 20:42.000]  И отборщенную вершину со всеми предыдущими соединяем.
[20:47.000 --> 20:49.000]  Ну, собственно, вроде бы все.
[20:49.000 --> 20:55.000]  Если у меня фиксирована какая-то маска, я сначала за линию нахожу в ней какой-нибудь бит, включенный произвольно.
[20:55.000 --> 20:57.000]  То есть я делаю цикл по всем позициям.
[20:57.000 --> 20:59.000]  Узнаю, какой бит у меня включен.
[20:59.000 --> 21:01.000]  Пусть кажется, это какой-то В.
[21:01.000 --> 21:03.000]  Проверяю, обязательно у меня должна быть маска без В.
[21:03.000 --> 21:05.000]  Это должна быть клика.
[21:05.000 --> 21:07.000]  И В еще одним циклом.
[21:07.000 --> 21:09.000]  Я проверяю, что В соединена со всеми вот этими товарищами.
[21:09.000 --> 21:11.000]  Это еще один нынешний цикл.
[21:11.000 --> 21:13.000]  Итого, если точка будет ровно З.
[21:14.000 --> 21:15.000]  Окей?
[21:16.000 --> 21:17.000]  Хорошо.
[21:21.000 --> 21:24.000]  Так, а как мы, кстати, вот это вот в коде реализуем?
[21:25.000 --> 21:26.000]  Вычитание элемента.
[21:26.000 --> 21:27.000]  Сор.
[21:34.000 --> 21:36.000]  Сор с чем?
[21:42.000 --> 21:44.000]  Как его построить?
[21:45.000 --> 21:47.000]  Да, да, да, все правильно.
[21:47.000 --> 21:49.000]  Эту штуку можно писать так.
[21:49.000 --> 21:53.000]  Маск, сор, один меньше В.
[21:54.000 --> 21:56.000]  Так, потому что один меньше на HV.
[21:56.000 --> 21:59.000]  Это как раз вы написали 2-ичное число.
[21:59.000 --> 22:01.000]  В смысле, число в зависимости от единицы.
[22:01.000 --> 22:06.000]  Потом ее бинарно 2-ичное сдвинули налево на В шаговку.
[22:06.000 --> 22:08.000]  У вас получается единичка, за ней вынулись.
[22:08.000 --> 22:10.000]  То есть представьте, у вас был вход число 1.
[22:10.000 --> 22:12.000]  Вы взяли его сдвинули на В влево.
[22:12.000 --> 22:15.000]  Причем все позиции, которые появились, вы заполнили 0.
[22:15.000 --> 22:19.000]  То есть когда вы двигаетесь на В влево, у вас единичка получается как раз в этом разряде.
[22:19.000 --> 22:21.000]  А справа все остаются умеряя.
[22:21.000 --> 22:25.000]  Поэтому эта штука это в точности вот эта вношность лежащая только в В.
[22:25.000 --> 22:27.000]  Но если вы это не исключите, то можете делать XOR.
[22:27.000 --> 22:29.000]  Можно с вами просто минус написать.
[22:29.000 --> 22:36.000]  Потому что если мы знаем, что в маске так это В находится, то вычитание сейчас работает точно так же, как XOR.
[22:36.000 --> 22:39.000]  Поэтому можно XOR, можно минус. Не особо важно.
[22:39.000 --> 22:45.000]  XOR, наверное, побыстрее, но минус, скорее всего, так дооптимизирован в этом случае до XOR.
[22:45.000 --> 22:47.000]  Поэтому не важно.
[22:47.000 --> 22:49.000]  Так.
[22:51.000 --> 22:53.000]  Хорошо.
[22:53.000 --> 22:58.000]  Значит, теперь смотрите, чтобы получить решение за просто 2 ступени m.
[23:04.000 --> 23:08.000]  И нужно учиться вот эти два шага находить за под единицей.
[23:08.000 --> 23:12.000]  Во-первых, проверять, находить, точнее, какой это перед из маски.
[23:12.000 --> 23:14.000]  Во-вторых, делать вот эту проверку.
[23:14.000 --> 23:18.000]  В соединяет со всеми вершинами с кого-то множеством.
[23:18.000 --> 23:20.000]  За единицей.
[23:20.000 --> 23:22.000]  Давайте оба эти шага сделаем.
[23:22.000 --> 23:24.000]  Во-первых, как находить какой-то бит.
[23:27.000 --> 23:31.000]  Как находить какой-то бит.
[23:36.000 --> 23:38.000]  Вот здесь, повторюсь, нам не важно, какой была В.
[23:38.000 --> 23:42.000]  В была произвольной вершинкой, я мог брать ее какой угодно.
[23:42.000 --> 23:46.000]  Вот. Обычно, очень часто, очень удобно использовать старший бит.
[23:49.000 --> 23:51.000]  Усть твой это старший бит.
[23:53.000 --> 23:59.000]  То есть вершина с наибольшим номером, который мы имеем в нашем множестве масок.
[23:59.000 --> 24:06.000]  Тогда, как меняется старший бит у числа, если я буду перебирать наши маски именно вот в таком порядке, в порядок увеличения.
[24:06.000 --> 24:09.000]  От 0 до маски всех верениц.
[24:12.000 --> 24:17.000]  Ну понятно, там, типа, сначала старший бит это единичка, потом двойка, потом тройка, потом четверка и так далее.
[24:17.000 --> 24:20.000]  Причем меняется она только на степнях двойки.
[24:20.000 --> 24:28.000]  Потому что, например, у вот такого числа, да, у вот такого числа, старший бит это двойка, а второй с конца бит в ноль дексации.
[24:28.000 --> 24:34.000]  Потом у вас эта двойка будет кучу раз старшим битом.
[24:34.000 --> 24:39.000]  Вот. А потом, очередной раз, когда у вас меняется старший бит, вы переходите через следы двойки.
[24:39.000 --> 24:43.000]  У вас старший бит сдвигается влево на единичку.
[24:43.000 --> 24:50.000]  Поэтому, если мы просто перебираем маски в порядок увеличения, то мне нужно увеличить старший бит на единицу каждый раз, когда мы перевалились за степень двойки.
[24:50.000 --> 24:56.000]  То есть, точнее, каждый раз, когда мы стали следами двойки.
[24:56.000 --> 24:57.000]  Вот.
[24:57.000 --> 25:02.000]  Значит, это можно сделать так.
[25:02.000 --> 25:04.000]  Потому что мы храним полдист.
[25:04.000 --> 25:09.000]  Как раз таки старший бит.
[25:09.000 --> 25:13.000]  Ну, для нулевой маски какие-то проблемы, наверное, со старшим битом.
[25:13.000 --> 25:15.000]  Там вообще не исключенных бит, поэтому мы нулевую маску.
[25:15.000 --> 25:17.000]  Для нулевой маски мы старший бит не определяем.
[25:17.000 --> 25:20.000]  А вот для тех, кто остается, спокойно можно.
[25:20.000 --> 25:25.000]  Значит, для всех масок к единичке до 2 степени минус 1.
[25:25.000 --> 25:29.000]  Если маска до степени двойки, то надо сделать плюс-плюс олдист.
[25:29.000 --> 25:32.000]  Тогда, как раз, олдист будет всегда текущим старшим битом.
[25:32.000 --> 25:33.000]  Вот.
[25:33.000 --> 25:38.000]  А как проверять то, что маска является степенью двойки, мы уже когда-то делали.
[25:38.000 --> 25:40.000]  Когда Спарстейл писали.
[25:40.000 --> 25:42.000]  Но давайте я здесь какое условие как бы.
[25:42.000 --> 25:43.000]  Я пишу словарно.
[25:43.000 --> 25:49.000]  Если маска до степени двойки.
[25:49.000 --> 25:56.000]  Если мы пришли к еще одной степени двойки, она сделает плюс-плюс олдист.
[25:56.000 --> 26:00.000]  Да, тогда, например, для маски равной единицы, единицы до степени двойки.
[26:00.000 --> 26:03.000]  Мы получим олдист равно 0.
[26:03.000 --> 26:05.000]  То есть как раз у единицы старший бит это 0.
[26:05.000 --> 26:08.000]  Ну, то есть самый левый культурный бит это 0.
[26:08.000 --> 26:10.000]  Дальше для маски равной двойки мы еще раз увеличиваем.
[26:10.000 --> 26:13.000]  Будет 1, 4, 8 и так далее.
[26:13.000 --> 26:16.000]  Каждый раз олдист будет увеличиваться.
[26:16.000 --> 26:17.000]  Вот.
[26:17.000 --> 26:21.000]  Ну, можно по-разному это сделать.
[26:21.000 --> 26:23.000]  Я пишу вот так.
[26:31.000 --> 26:38.000]  Степень двойки это в точности те случаи, когда при конъюнкции с предыдущим числом у вас получается 0.
[26:38.000 --> 26:42.000]  А потому что маска это получается 1, 0, 0, 0, 0, 0.
[26:42.000 --> 26:44.000]  А маска минус 1 это 0, 1, 1, 1, 1, 1.
[26:44.000 --> 26:46.000]  Тогда понятно, что это конъюнкция нулевая.
[26:46.000 --> 26:47.000]  Вот.
[26:47.000 --> 26:53.000]  А если бы у вас была не степень двойки, то у вас тогда хотя бы одна единичка вот здесь вот сохранилась бы при переходе к маске минус 1.
[26:53.000 --> 26:58.000]  И у вас там был бы какой-то не нулевой, ну в смысле, да, не нулевой бит.
[27:01.000 --> 27:02.000]  Вот.
[27:02.000 --> 27:03.000]  Вроде все.
[27:03.000 --> 27:07.000]  Теперь мы олдист знаем, собственно, для всех масок за единичку.
[27:07.000 --> 27:10.000]  Для каждой маски я посоветую вычитать олдист за единичку.
[27:10.000 --> 27:11.000]  Окей?
[27:16.000 --> 27:17.000]  Так.
[27:17.000 --> 27:18.000]  Ну и второй шаг.
[27:18.000 --> 27:23.000]  Мне нужно проверить, что вот этот олдист конкретный, да, соединен со всеми словами множества.
[27:23.000 --> 27:26.000]  Ну как это сделать, ваше предложение?
[27:32.000 --> 27:33.000]  Кого?
[27:33.000 --> 27:34.000]  Детей.
[27:34.000 --> 27:35.000]  Ну соседней скорее.
[27:35.000 --> 27:36.000]  Ну да.
[27:37.000 --> 27:41.000]  Действительно, да, давайте мы просто заведем какой-нибудь массив.
[27:41.000 --> 27:43.000]  Давайте его назовем neighbor.
[27:46.000 --> 27:47.000]  Для каждой вершины.
[27:47.000 --> 27:50.000]  Это маска соседей вершины В.
[27:52.000 --> 27:56.000]  Маска соседей вершины В.
[27:59.000 --> 28:04.000]  Ну мы знаем, что соседей вершины В это какое-то множество, да, вот с кем вводится имя.
[28:04.000 --> 28:07.000]  Ну с какими-нибудь вершинами, да, это конкретное множество.
[28:07.000 --> 28:09.000]  Ну давайте это множество представим в виде маски.
[28:09.000 --> 28:11.000]  Уже умеем множество маскам задавать.
[28:11.000 --> 28:12.000]  Вот зададим.
[28:12.000 --> 28:14.000]  Так сделан для каждой вершины.
[28:15.000 --> 28:21.000]  Тогда, чтобы проверить, что вот эта вот наша область соединена со всеми из кого-то множества,
[28:21.000 --> 28:25.000]  мне нужно просто проверить, что вот то множество, да, маска без областа,
[28:25.000 --> 28:28.000]  маска без областа, в этом В я пишу,
[28:31.000 --> 28:35.000]  должно быть вложено в множество соседей вершины.
[28:35.000 --> 28:39.000]  Это как раз пример того, что В с ними со всеми соединена.
[29:05.000 --> 29:09.000]  Соответственно, если я этот массив neighbor посчитаю на всех вершин,
[29:09.000 --> 29:12.000]  то я могу за единицу проверять,
[29:12.000 --> 29:14.000]  что В с ними со всеми соединена.
[29:14.000 --> 29:16.000]  Мы уже вот здесь вот недавно было
[29:16.000 --> 29:18.000]  в проверке того, что одно множество в одно что другое,
[29:18.000 --> 29:21.000]  можно сделать за единицу, там какой-то AND, XOR, короче, да,
[29:21.000 --> 29:23.000]  проверка на равность вам.
[29:24.000 --> 29:26.000]  В общем, как-то за единицу мы это научились делать уже.
[29:26.000 --> 29:28.000]  Ну вот здесь вот и есть пути.
[29:29.000 --> 29:30.000]  Вот.
[29:30.000 --> 29:32.000]  В общем, как-то за единицу мы это научились делать уже.
[29:32.000 --> 29:34.000]  Ну вот здесь вот и есть пути.
[29:35.000 --> 29:36.000]  Вот.
[29:36.000 --> 29:38.000]  Ну а neighbor посчитать будешь просто,
[29:38.000 --> 29:40.000]  надо просто пройтись по всем ребрам графа,
[29:40.000 --> 29:42.000]  если у В какое-то,
[29:42.000 --> 29:45.000]  то мне нужно в neighbor от В добавить вершинку У,
[29:45.000 --> 29:47.000]  а в neighbor от У добавить вершинку В.
[29:47.000 --> 29:49.000]  Это просто, ну там, включение какого-то битика.
[29:50.000 --> 29:51.000]  Вот.
[29:51.000 --> 29:54.000]  Все, получили за два степени, два степени на решение.
[29:55.000 --> 29:56.000]  Окей?
[30:00.000 --> 30:01.000]  Так.
[30:07.000 --> 30:08.000]  Так.
[30:08.000 --> 30:11.000]  Ну и теперь, собственно, кульминация,
[30:11.000 --> 30:13.000]  это решение за два степени наполам.
[30:17.000 --> 30:19.000]  Так, это будет сантимальное решение,
[30:23.000 --> 30:25.000]  за два степени наполам.
[30:25.000 --> 30:26.000]  Вот.
[30:28.000 --> 30:30.000]  Если предыдущие решения работали
[30:30.000 --> 30:32.000]  за адекватное время, там,
[30:32.000 --> 30:34.000]  для n порядка 20-30,
[30:34.000 --> 30:36.000]  то это вполне себе нормально работает
[30:36.000 --> 30:38.000]  для n порядка 50-60.
[30:38.000 --> 30:41.000]  То есть, если мы в два раза сократили показатель,
[30:41.000 --> 30:43.000]  то за то же время
[30:43.000 --> 30:45.000]  мы работаем для входа
[30:45.000 --> 30:47.000]  в порядок двух ручек.
[30:48.000 --> 30:49.000]  Итак.
[30:52.000 --> 30:53.000]  Как будем действовать?
[30:53.000 --> 30:55.000]  Давайте мы наш граф
[30:55.000 --> 30:57.000]  довольно случайно,
[30:57.000 --> 30:58.000]  ну, точнее, довольно произвольно
[30:58.000 --> 31:00.000]  поделим на две равные части.
[31:01.000 --> 31:02.000]  l и r.
[31:03.000 --> 31:05.000]  Скажем, что в l будут лежать вершины с номерами
[31:05.000 --> 31:07.000]  от 0 до n пополам,
[31:07.000 --> 31:08.000]  минус 1.
[31:09.000 --> 31:11.000]  В r, вот n пополам,
[31:11.000 --> 31:12.000]  до n минус 1.
[31:12.000 --> 31:13.000]  Ну, короче,
[31:13.000 --> 31:14.000]  первую половинку влево,
[31:14.000 --> 31:16.000]  а вторую половинку в правой.
[31:17.000 --> 31:19.000]  Тогда шутку любая клика.
[31:19.000 --> 31:21.000]  Как выглядит произвольная клика?
[31:22.000 --> 31:24.000]  Ну, она немножко вершин вот отсюда содержит,
[31:24.000 --> 31:26.000]  и немножко вот отсюда.
[31:26.000 --> 31:27.000]  В общем случае.
[31:27.000 --> 31:29.000]  Она как-то содержится и там, и там.
[31:29.000 --> 31:31.000]  При этом, что мне нужно?
[31:31.000 --> 31:33.000]  Мне нужно, чтобы вот этот кусочек был кликой
[31:33.000 --> 31:35.000]  сам по себе.
[31:35.000 --> 31:37.000]  Вот этот кусочек был кликой сам по себе.
[31:38.000 --> 31:40.000]  И они попарно между собой,
[31:40.000 --> 31:42.000]  между долями были тоже соединены
[31:42.000 --> 31:43.000]  попарно лево.
[31:44.000 --> 31:45.000]  То есть, внутри условия,
[31:45.000 --> 31:47.000]  которые необходимы и достаточно,
[31:47.000 --> 31:48.000]  для того, чтобы это было кликой.
[31:48.000 --> 31:49.000]  Еще раз.
[31:49.000 --> 31:51.000]  Во-первых, в сужении на левую долю клика,
[31:51.000 --> 31:54.000]  во-вторых, в сужении на правую долю клика,
[31:54.000 --> 31:55.000]  и в-третьих,
[31:56.000 --> 31:58.000]  попарные ребра между сужением на левую долю
[31:58.000 --> 32:00.000]  и на правую долю все есть.
[32:00.000 --> 32:02.000]  То есть, есть все ребра слева направо.
[32:04.000 --> 32:05.000]  Вот.
[32:05.000 --> 32:07.000]  Ну, будем это делать.
[32:15.000 --> 32:16.000]  Так.
[32:19.000 --> 32:21.000]  Ну, смотрите, я сделаю следующее.
[32:21.000 --> 32:23.000]  Давайте я веду новую нумерацию
[32:23.000 --> 32:25.000]  на наших обеих долях.
[32:25.000 --> 32:27.000]  Раньше исходная нумерация была вот такая.
[32:27.000 --> 32:29.000]  Теперь давайте я пронумеру ее и слева
[32:29.000 --> 32:32.000]  все вершины от нуля до этого пополам.
[32:32.000 --> 32:34.000]  И справа тоже все от нуля до этого пополам.
[32:34.000 --> 32:36.000]  То есть, теперь формально каждая вершина,
[32:36.000 --> 32:38.000]  она задается не только номером, но и своей долей.
[32:38.000 --> 32:40.000]  Где она лежит, то и номер в этой доле.
[32:40.000 --> 32:41.000]  Вот.
[32:41.000 --> 32:42.000]  Вот.
[32:42.000 --> 32:43.000]  Вот.
[32:43.000 --> 32:44.000]  Вот.
[32:44.000 --> 32:45.000]  Вот.
[32:45.000 --> 32:46.000]  Вот.
[32:46.000 --> 32:47.000]  Вот.
[32:47.000 --> 32:48.000]  Вот.
[32:48.000 --> 32:50.000]  И у нас будет такое номер в этой доле.
[32:50.000 --> 32:52.000]  И мы их не будем путать, потому что
[32:52.000 --> 32:54.000]  нули здесь и нули здесь находятся в разных долях.
[32:54.000 --> 32:56.000]  Но я для удобства нумеровал динамик.
[32:56.000 --> 32:58.000]  Для удобства представления дальнейшего.
[33:01.000 --> 33:06.000]  Значит, нам нужно будет несколько динамиков.
[33:06.000 --> 33:11.000]  Во-первых, для всех подмножеств левой доли
[33:11.000 --> 33:15.000]  я хочу проверить является ли данная ноздка клипой.
[33:15.000 --> 33:19.000]  Давайте я это назову, скажем, ДПЛ.
[33:19.000 --> 33:23.000]  ДПЛ. Вот маски.
[33:23.000 --> 33:27.000]  Это случай, когда маск – это какие-то вершины в левой доле.
[33:27.000 --> 33:32.000]  И я просто хочу узнать, трогалифолс является ли это множество клика или нет.
[33:32.000 --> 33:37.000]  Значит, маск – это какое-то множество левой доли.
[33:37.000 --> 33:43.000]  Вопрос является ли клика.
[33:43.000 --> 33:49.000]  Ну, благо, вот только что мы научились за 2х размер графа проверять все его подножства на кликовость.
[33:49.000 --> 33:55.000]  Поэтому этот шаг мы можем сделать спокойно за 2,5.
[33:55.000 --> 34:03.000]  Давайте сделаем то же самое для правой доли.
[34:03.000 --> 34:06.000]  Теперь маск – это какое подножство правой доли.
[34:06.000 --> 34:08.000]  Ну, как вы знаете, является ли оно кликой.
[34:08.000 --> 34:10.000]  Тоже самое, да, является ли оно кликой.
[34:10.000 --> 34:18.000]  И работает тоже за 2,5.
[34:18.000 --> 34:25.000]  Так, и третья.
[34:25.000 --> 34:29.000]  Самая интеллектуальная динамика будет следующая.
[34:30.000 --> 34:37.000]  Маск – это множество вершин правой доли.
[34:37.000 --> 34:45.000]  А значение динамики равно наибольшему размеру под клики, которая целиком вложена в маску.
[34:45.000 --> 35:05.000]  ДП – это размер наибольшей клики, которая лежала бы внутри маска.
[35:05.000 --> 35:09.000]  То есть, вот здесь какое-то множество справа, вот здесь маска.
[35:09.000 --> 35:14.000]  Маска самой по себе, возможно, кликой не является, но там может быть довольно большая клика.
[35:14.000 --> 35:16.000]  Вот, например, вот это вот все, это клика.
[35:16.000 --> 35:19.000]  То есть несколько вершин надо удалить, чтобы получилась клика.
[35:19.000 --> 35:24.000]  И вот я хочу для каждой маски знать, какой будет наибольший размер клики, вложенный в эту маску.
[35:24.000 --> 35:28.000]  Окей?
[35:28.000 --> 35:32.000]  Тогда, смотрите, вот если у меня все это есть, как я буду действовать?
[35:32.000 --> 35:39.000]  Сейчас нарисую.
[35:39.000 --> 35:43.000]  Как я буду действовать?
[35:43.000 --> 35:49.000]  Я перебираю множество вершин в левой доле, которые образуют клику.
[35:49.000 --> 35:53.000]  Давайте это будет у меня А.
[35:53.000 --> 35:56.000]  Я перебираю клику в левой доле.
[35:56.000 --> 35:57.000]  Дальше.
[35:57.000 --> 36:07.000]  Я знаю, это довольно просто сделать, я, в принципе, знаю множество вершин, которые были бы соединены со всеми вершинами из А.
[36:07.000 --> 36:11.000]  То есть, есть такие вершины, которые соединены со всеми вершинами множества А.
[36:11.000 --> 36:13.000]  Вот такой вот полный граф у нас получается.
[36:13.000 --> 36:15.000]  Полный двудольный граф.
[36:15.000 --> 36:18.000]  Вот это для меня, конечно, маска.
[36:18.000 --> 36:30.000]  Если я знаю эту маску, то в дополнение к А, чтобы получить клику, мне нужно как раз взять ДП от маски.
[36:30.000 --> 36:36.000]  То есть, еще раз, если А это клика, давайте подпишем, что А это клика,
[36:36.000 --> 36:44.000]  Маск это множество всех вершин правой доли, которые соединены со всеми вершинами из А.
[36:44.000 --> 36:54.000]  Множество вершин Р, соединенных со всеми из А.
[36:54.000 --> 36:59.000]  То есть, это все потенциальные кандидаты на добавление в клику.
[36:59.000 --> 37:03.000]  Итого, если мы возьмем А и что угодно из маски, то мы выполним уже два условия из трех.
[37:03.000 --> 37:07.000]  Мы выполним, что А это клика, и что есть ребра между долями или Р.
[37:07.000 --> 37:10.000]  Осталось делать так, чтобы вот здесь была еще клика.
[37:10.000 --> 37:14.000]  Но из всех возможных под кликой этого множества, мне нужно наибольших понятных делать.
[37:14.000 --> 37:17.000]  Потому что уже я выполнил свое выполнение, осталось одно.
[37:17.000 --> 37:19.000]  Мне осталось, чтобы здесь выбралось клика.
[37:19.000 --> 37:21.000]  А это идет за помощью ДП.
[37:21.000 --> 37:24.000]  И вот если я научусь находить наибольшую под клику в данном множестве,
[37:24.000 --> 37:30.000]  то объединение А и, собственно, это наибольшее под клики, это один из потенциальных эффектов.
[37:30.000 --> 37:32.000]  Дальше я просто перебираю все вот эти возможные А,
[37:32.000 --> 37:34.000]  нахожу размер вот этого ДП от маски,
[37:34.000 --> 37:38.000]  и это, как бы, одна из ровнорных кликов.
[37:38.000 --> 37:39.000]  Ты жив?
[37:39.000 --> 37:43.000]  Вопрос я еще раз письменно запишу, что я здесь делал.
[37:43.000 --> 37:44.000]  Повторю.
[37:44.000 --> 37:45.000]  Что такое клика?
[37:45.000 --> 37:50.000]  Да, любая клика в нашем графе развивается на два кусочка, левая и правая.
[37:50.000 --> 37:53.000]  То есть, ее стужение на левую долю и на правую долю.
[37:53.000 --> 37:55.000]  Клика характеризуется тремя свойствами.
[37:55.000 --> 37:57.000]  Во-первых, слева клика.
[37:57.000 --> 37:59.000]  То есть, вот это множество самого бы себе клика.
[37:59.000 --> 38:01.000]  Для него вернули ДПР или ОТС.
[38:01.000 --> 38:03.000]  Второе условие.
[38:03.000 --> 38:05.000]  Все, что справа, это клика.
[38:05.000 --> 38:07.000]  ДПР, вот эта маска, должна быть труп.
[38:07.000 --> 38:08.000]  И третье условие.
[38:08.000 --> 38:11.000]  Есть все попавшие ребра между вершиной слева и справа.
[38:13.000 --> 38:15.000]  Как будет работать наш алдейфинг?
[38:15.000 --> 38:23.000]  Во-первых, перебираем А под множество левой доли, которая является кликой.
[38:23.000 --> 38:25.000]  Тем самым, первую сходу можно выполнить.
[38:25.000 --> 38:27.000]  Слева клика.
[38:27.000 --> 38:29.000]  Второе.
[38:29.000 --> 38:32.000]  Каким-то образом мы находим маск.
[38:32.000 --> 38:37.000]  Это множество всех вершин правой доли, которые соединись со всеми вершинами из А.
[38:37.000 --> 38:39.000]  Вот я так пока что не учу.
[38:39.000 --> 38:46.000]  Как-то находим маск из ДР.
[38:46.000 --> 38:49.000]  Это множество всех вершин.
[38:49.000 --> 38:51.000]  Это множество всех вершин.
[38:56.000 --> 38:59.000]  Соединенных со всеми из А.
[39:03.000 --> 39:06.000]  Тем самым, я уже удовлетворил третье условие.
[39:06.000 --> 39:09.000]  Есть все ребра попавшие слева направо.
[39:09.000 --> 39:14.000]  Просто по определению, маск содержит те и только те вершины, которые сведены со всеми из А.
[39:14.000 --> 39:16.000]  Третье условие уже есть.
[39:16.000 --> 39:22.000]  И последнее, что осталось сделать, это в этой маске эту маску превратить в клику.
[39:22.000 --> 39:26.000]  Но поскольку она сама по себе, возможно, кликой не была,
[39:26.000 --> 39:28.000]  мне нужно в ней выбрать наибольшую под клику.
[39:28.000 --> 39:30.000]  А это в точности ДП.
[39:30.000 --> 39:35.000]  Вот это все доступные вершины, но мне в них нужно выбрать под клику.
[39:35.000 --> 39:37.000]  А это в неизвестности ДП.
[39:37.000 --> 39:40.000]  Мне нужно из данного множества выбрать наибольшую под множество вершин клики.
[39:40.000 --> 39:42.000]  Это ДП просто.
[39:43.000 --> 39:57.000]  Наибольшая клика это А в объедении ДП от маски.
[39:57.000 --> 40:01.000]  То есть А вот отсюда и ДП от маски вот отсюда.
[40:05.000 --> 40:07.000]  Что осталось нам сделать?
[40:07.000 --> 40:11.000]  Это каким-то образом научиться находить эту маску.
[40:11.000 --> 40:14.000]  Но что всех соседей всех лишен из А.
[40:14.000 --> 40:19.000]  И, видимо, ДП вот на одном числе находиться.
[40:19.000 --> 40:22.000]  Давайте пойду с конца, как насчитывать ДП.
[40:42.000 --> 40:46.000]  Ну, смотрите, вот есть некое множество маски.
[40:46.000 --> 40:51.000]  Я хочу в ней найти наибольшую под клику.
[40:51.000 --> 40:53.000]  Наибольшая подножие является кликой.
[40:53.000 --> 40:57.000]  Значит, понятно, что если маска сама по себе клика, то делать нечего.
[40:57.000 --> 40:59.000]  Наибольшая под клика это она сама.
[40:59.000 --> 41:08.000]  В первый случай, если ДП от маски, то ДП от маски это, собственно,
[41:08.000 --> 41:11.000]  давайте на шоу, built-in pop count от маски.
[41:11.000 --> 41:15.000]  Я хочу хранить размер, поэтому с ДП я буду хранить прям размер.
[41:15.000 --> 41:27.000]  Вот ДП от маски это просто-напросто количество бит нашей маски.
[41:27.000 --> 41:30.000]  Потому что это уже клик.
[41:34.000 --> 41:36.000]  Дальше. Пусть это не так.
[41:36.000 --> 41:38.000]  Маска сама по себе это не клика.
[41:38.000 --> 41:42.000]  Давайте опять посмотрим какую-то произвольную режим из нашей маски.
[41:42.000 --> 41:44.000]  Мы знаем, что произвольная это обычно старший бит.
[41:44.000 --> 41:47.000]  Вот давайте рассмотрим старший бит oldest.
[41:47.000 --> 41:53.000]  И давайте спросим себя, а входит ли этот старший бит в нашу маску, в нашу лучшую клику?
[41:53.000 --> 41:56.000]  Входит ли oldest в наибольшую клику?
[41:56.000 --> 42:00.000]  Но если не входит, то можно просто смело откусить
[42:00.000 --> 42:04.000]  и найти ответ для ДП маски без oldest.
[42:04.000 --> 42:06.000]  Второй случай.
[42:06.000 --> 42:19.000]  Если oldest не входит в наибольшую подклику, а в наибольшую подклику, то.
[42:19.000 --> 42:21.000]  Значит он в принципе не участвует в этой клике.
[42:21.000 --> 42:23.000]  Его можно выкинуть.
[42:23.000 --> 42:26.000]  И находить наибольшую подклику маски уже поменьше.
[42:26.000 --> 42:29.000]  Маски без oldest, если мы будем перебирать маски в порядке возрастания,
[42:29.000 --> 42:34.000]  то ДП вот в маске без oldest будет нашим ответом.
[42:34.000 --> 42:37.000]  ДП вот в маске.
[42:37.000 --> 42:45.000]  ДП вот в маске без oldest.
[42:45.000 --> 42:49.000]  Согласны?
[42:49.000 --> 42:55.000]  Ну и последний случай, когда oldest входит в нашу подклику.
[42:55.000 --> 42:58.000]  Oldest входит в подклику.
[42:58.000 --> 43:07.000]  Значит мы можем брать только вершины,
[43:07.000 --> 43:09.000]  которые являются соседними вершинками в oldest.
[43:09.000 --> 43:13.000]  Только вот эти вот вершины.
[43:13.000 --> 43:17.000]  Значит есть вот эти хорошие, есть все остальные плохие,
[43:17.000 --> 43:19.000]  которые точно брать нельзя, потому что если я взял oldest,
[43:19.000 --> 43:22.000]  то соответственно не соседей oldest брать нельзя.
[43:22.000 --> 43:24.000]  Ну и поэтому вот отсюда из всех соседей мы должны выбрать
[43:24.000 --> 43:26.000]  теперь опять-таки наибольшую подклику.
[43:26.000 --> 43:30.000]  Если я обещаю себе, что я oldest в нашу клику взял,
[43:30.000 --> 43:36.000]  то мне необходимо и достаточно взять клику вот в этом подмножке вершин всех соседей.
[43:36.000 --> 43:38.000]  Потому что ну всех других брать точно нельзя.
[43:38.000 --> 43:40.000]  А если я здесь возьму любую подклику,
[43:40.000 --> 43:44.000]  то oldest можно будет спокойно к ней добавить.
[43:44.000 --> 43:46.000]  Поэтому я напишу так.
[43:46.000 --> 43:58.000]  Если oldest входит в наибольшую подклику,
[43:58.000 --> 44:02.000]  тогда оно будет выполнить что-то в стиле следующего.
[44:02.000 --> 44:08.000]  Такой вот маски это единица за счет собственно oldest'а
[44:08.000 --> 44:10.000]  плюс db.
[44:10.000 --> 44:14.000]  Мне нужно маску сузить на множество соседей вершины oldest.
[44:14.000 --> 44:16.000]  Это что такое?
[44:16.000 --> 44:22.000]  Это пересечение маски и всех соседей вершины oldest.
[44:26.000 --> 44:28.000]  Вот и все.
[44:34.000 --> 44:36.000]  Еще раз картинка, вот последний случай.
[44:36.000 --> 44:38.000]  Есть все множество маски.
[44:38.000 --> 44:42.000]  Есть вершина, которая я предполагаю обязательно лежит в нашей подклике.
[44:42.000 --> 44:44.000]  Вот она oldest.
[44:44.000 --> 44:46.000]  Она точно в нашей клике лежит.
[44:46.000 --> 44:48.000]  Если не лежит, в же случае разоба.
[44:48.000 --> 44:54.000]  Если она лежит, то в дополнение к ней я могу брать только ее соседей.
[44:54.000 --> 44:56.000]  Вот если я всех соседей нарисую, вот они все.
[44:56.000 --> 44:58.000]  Я могу брать только вот эти вот вершины.
[44:58.000 --> 45:02.000]  Но более того, из них я могу брать кого угодно.
[45:02.000 --> 45:04.000]  В дополнение к oldest я могу брать что угодно,
[45:04.000 --> 45:08.000]  будь оно кликой, oldest можно к ним спокойно брать.
[45:08.000 --> 45:10.000]  Потому что она и так совсем не несоединена.
[45:10.000 --> 45:12.000]  Поэтому теперь мне нужно в этом множестве
[45:12.000 --> 45:14.000]  маск пересеченная с ней брат oldest
[45:14.000 --> 45:16.000]  найти наибольшую подклику
[45:16.000 --> 45:20.000]  и добавить и расширить ее единичкой за счет oldest.
[45:20.000 --> 45:22.000]  Ну вот форму, пожалуйста.
[45:28.000 --> 45:30.000]  Все, мы начитали db за 20 минут пополам.
[45:30.000 --> 45:32.000]  Потому что у меня
[45:32.000 --> 45:34.000]  у нас есть вот такая форма.
[45:34.000 --> 45:36.000]  Ну то есть как? Я сначала делаю проверку
[45:36.000 --> 45:38.000]  является ли она кликой.
[45:38.000 --> 45:40.000]  Если является, то собственно вот это вот верное
[45:40.000 --> 45:42.000]  больше делать ничего не надо.
[45:42.000 --> 45:44.000]  А если не является, то у меня oldest уже известен.
[45:44.000 --> 45:46.000]  Мы oldest для всех масок посчитали
[45:46.000 --> 45:48.000]  за линейное время от их количества.
[45:48.000 --> 45:50.000]  И дальше просто выбираю, да,
[45:50.000 --> 45:52.000]  наибольшие значения кладу его в dp от маска.
[45:52.000 --> 45:54.000]  Все это считается спокойно за единицу.
[45:54.000 --> 45:56.000]  Здесь там обращение к dp,
[45:56.000 --> 45:58.000]  здесь обращение к ней, обращение к dp,
[45:58.000 --> 46:00.000]  плюс один, это все за единицу работает.
[46:00.000 --> 46:02.000]  Ну суммарно все вот это dp
[46:02.000 --> 46:08.000]  насчитывается за 20 минут пополам.
[46:16.000 --> 46:18.000]  Вопросики?
[46:20.000 --> 46:22.000]  Нет вопросиков.
[46:22.000 --> 46:24.000]  Так.
[46:24.000 --> 46:26.000]  Последний шаг.
[46:28.000 --> 46:30.000]  Это вот это вот.
[46:34.000 --> 46:36.000]  Помножившим левой долей,
[46:36.000 --> 46:38.000]  найти, умножившим правой долей,
[46:38.000 --> 46:40.000]  которая связана со всеми слева.
[46:40.000 --> 46:42.000]  Значит как находится маска?
[46:42.000 --> 46:44.000]  Ну как вы можете сделать n
[46:44.000 --> 46:46.000]  с делами ракселя?
[46:46.000 --> 46:48.000]  Ну да, но только перерятки
[46:48.000 --> 46:50.000]  не можно, потому что будет еще
[46:50.000 --> 46:52.000]  умножитель на n.
[46:52.000 --> 46:54.000]  Если мы все переберем.
[46:54.000 --> 47:06.000]  Вот, а так можно просто dp
[47:06.000 --> 47:08.000]  еще один.
[47:08.000 --> 47:10.000]  Да, то есть если мы знаем
[47:10.000 --> 47:16.000]  Если мы знаем AND всех, кроме одной, тогда еще AND не вновь последний, и получается результат, да, собственно, да.
[47:16.000 --> 47:19.000]  Вот, значит, нам нужна мне еще одна деклажина.
[47:19.000 --> 47:27.000]  Так, ну, буквы кончились, давайте на другу как-нибудь G, что ли.
[47:27.000 --> 47:29.000]  G вот A.
[47:29.000 --> 47:33.000]  Собственно, собственно, вот этот вот маск.
[47:33.000 --> 47:36.000]  Значит, как ее находить? Если у меня есть...
[47:36.000 --> 47:38.000]  Давайте опять картинку больше нарисую.
[47:38.000 --> 47:42.000]  Вот если есть большое множество A слева,
[47:42.000 --> 47:44.000]  что такое, как правильно заметили?
[47:44.000 --> 47:46.000]  Что такое все соседи всех вершин из A?
[47:46.000 --> 47:53.000]  Это на самом деле конъюнкция, то есть пересечение всех множеств соседей вершин вот отсюда.
[47:53.000 --> 48:00.000]  То есть, если я знаю множество соседей вот этой вершинки, множество соседей этой вершинки, вот этой и так далее,
[48:00.000 --> 48:03.000]  то мне посуднее вопрос, всех множеств пересечь?
[48:03.000 --> 48:21.000]  Если я знаю, с кем соседствуют все вершины из А в правой доле, то мне нужно просто все эти множества пересечь, потому что это множество соседей первой вершины, это множество соседей второй вершины, это третьей, и так далее.
[48:21.000 --> 48:24.000]  Вершины соседей со всеми ними – это пересечение этих множеств.
[48:24.000 --> 48:34.000]  Поэтому мне нужно взять множество соседей всех этих вершин пересечь их, и это будет с точностью нашу желудку А. Множество всех вершин соединено совсем из А.
[48:34.000 --> 48:49.000]  Поскольку я не хочу делать перебор бита из А, давайте я какой-нибудь бит исключу, буду знать пересечение вот этих вот всех множеств, то есть всех кроме одного, потом пересеку его с последним, и будет у меня желудка.
[48:49.000 --> 49:10.000]  Сейчас мы будем писать вот так. Желудка – это желудка без олдеста пересечь, ну собственно, с множеством соседей олдеста в правой доле.
[49:10.000 --> 49:22.000]  Давайте я его паркну еще по особенному зву, давайте я его назову neighbor с индексом R от олдеста.
[49:22.000 --> 49:34.000]  Да, потому что вот он – олдест, вот какой-нибудь битик, neighbor у меня исходит в множество соседей, но сейчас мне нужны соседи только из правой доли, поэтому я вот вел такой neighbor с индексом R.
[49:34.000 --> 49:46.000]  Да, я знаю все соседи из правой доли, которые соседи с этим олдестом. Мне нужно просто взять и пересечь это множество с G от A без олдеста.
[49:46.000 --> 49:55.000]  И тем самым у меня в конце G вот так будет пересечение всех тех множеств, которые мне нужны.
[49:55.000 --> 50:13.000]  Профит. Что-то понятно? Ну хорошо. Но скажу, что это тоже работает за два в степень и пополам, потому что олдест мы знаем, neighbor мы изначально посчитали, то есть эта масса за единицу мы можем к ней обращаться.
[50:13.000 --> 50:16.000]  Ну и все, вот здесь переход тоже за единицу.
[50:25.000 --> 50:36.000]  Так, круто. Вот все, мы наконец-то научились находить наибольшую клику за два в степень и пополам.
[50:36.000 --> 50:44.000]  Вообще говоря, опять, здесь на самом деле тоже прикол, что в задаче с рюкзаком. Этот алгоритм, он тривиальный с кондициацией.
[50:44.000 --> 50:49.000]  Он здесь прям так и написан, два в степени. Размер графа пополам.
[50:49.000 --> 50:59.000]  И пока что опять-таки неизвестны алгоритмы, в которые бы работали запылено. Неизвестно ни одного алгоритма, который бы находил наибольшую клику в графе.
[50:59.000 --> 51:04.000]  А можно попробовать этот шанс алгоритма применять в теннингах?
[51:11.000 --> 51:13.000]  Мы же можем, в принципе, все время, если просим...
[51:13.000 --> 51:14.000]  Я такого не знаю.
[51:14.000 --> 51:15.000]  Саму клику?
[51:15.000 --> 51:16.000]  А?
[51:16.000 --> 51:20.000]  Мы же вроде как можем, в принципе, все время, если просим, хранить саму клику, которую мы нашли...
[51:20.000 --> 51:22.000]  Ну конечно, да.
[51:23.000 --> 51:28.000]  Не знаю. Сходу, мне кажется, не рабочий, потому что вам все равно...
[51:28.000 --> 51:32.000]  Чтобы все стыковать, вам все равно примерно такое время.
[51:32.000 --> 51:36.000]  Есть какие-то другие алгоритмы, которые работают чуть быстрее, но там другие идеи используются.
[51:36.000 --> 51:39.000]  То есть скорее это вы не до оптимизации, не до чего докладываться.
[51:39.000 --> 51:41.000]  Есть другие, как бы чуть получше.
[51:41.000 --> 51:45.000]  Потому что, насколько я знаю, есть примерно вот такого, примерно 8.
[51:45.000 --> 51:48.000]  Но это ни пофрес какое улучшение.
[51:48.000 --> 51:50.000]  Хоть какое-то, но...
[51:50.000 --> 51:53.000]  Есть там еще чуть-чуть лучше, но это все экспоненты все равно.
[51:53.000 --> 51:56.000]  Каждый полином никому не поддался.
[51:58.000 --> 51:59.000]  Вот.
[52:01.000 --> 52:02.000]  Так, ну что, идем дальше.
[52:02.000 --> 52:04.000]  Тогда следующая задача.
[52:07.000 --> 52:10.000]  Задача о хроматическом числе графа.
[52:10.000 --> 52:13.000]  Значит, задача есть граф, надо найти его хроматическое число.
[52:13.000 --> 52:15.000]  Чистое хроматическое число.
[52:17.000 --> 52:18.000]  Значит, это следующее.
[52:18.000 --> 52:23.000]  Мне нужно покрасить все вершины в несколько цветов.
[52:23.000 --> 52:28.000]  Так чтобы вершины, соединенные ребрами, были разного цвета.
[52:29.000 --> 52:36.000]  А вот, например, если есть какой-то ребро, то в конце этого ребра то хроматическое число будет разным цветом.
[52:36.000 --> 52:41.000]  А вот, например, если какой-то ребро, то в конце этого ребра должно быть обязательно разный цвет.
[52:41.000 --> 52:46.000]  Например, это один, вот этот два, вот этот три, вот этот один, вот этот четыре.
[52:46.000 --> 52:49.000]  Это корректная расчет Rank.
[52:49.000 --> 52:52.000]  То есть, если вершины сせstate ребром, то они должны быть обязательно разным цветом.
[52:52.000 --> 52:54.000]  Можно?!
[52:54.000 --> 52:58.200] モху так выاجать
[52:58.200 --> 53:00.000]  Да, извините.
[53:02.000 --> 53:04.000]  Да, если соединены ребром, то они обязательно разным цветом.
[53:04.000 --> 53:10.200]  И наша цель это смочь покрасить наш граф в как можно меньше
[53:10.200 --> 53:11.200]  чемого цветов.
[53:11.200 --> 53:13.020]  Например, вот здесь понятно дело, что четверка совершенно
[53:13.020 --> 53:16.680]  изыгрышная, можно здесь поставить единичку, а уже
[53:16.680 --> 53:18.400]  меньше чем тремя цветами не обойтись, потому что
[53:18.400 --> 53:24.880]  есть этот цикл, его меньше цвета не распрасишь.
[53:24.880 --> 53:33.920]  Найти наименьшее к, такое, чтобы граф, ну давайте
[53:33.920 --> 53:41.320]  лучше вершины графа, можно правильным образом раскрасить
[53:41.320 --> 54:09.000]  граф к цвету.
[54:09.000 --> 54:16.000]  Независимая лимба, называется форма включения-включения.
[54:16.000 --> 54:30.120]  Так, пусть, у нас есть tn под множеством множеством
[54:30.120 --> 54:48.040]  m, в объединении дающейся все b, тогда мощность множества
[54:48.040 --> 54:53.800]  перед всеми дополнениями равна вот такой сумме.
[54:54.800 --> 55:03.800]  Так, x под множество множество индексов, минус один степень
[55:03.800 --> 55:16.800]  мощность x, мощность пересечения из x, незнакомая запись.
[55:17.800 --> 55:20.800]  Ну формула, наверное, вы многие знаете.
[55:24.800 --> 55:25.800]  Чудесно.
[55:25.800 --> 55:28.800]  Ну, возможно, задача не привычная, но давайте я,
[55:28.800 --> 55:31.800]  я все равно без доказательства, я даже не говорю, что я
[55:31.800 --> 55:34.800]  буду есть какой-то основной полюс, но тем не менее.
[55:34.800 --> 55:37.800]  Что это значит, смотрите.
[55:38.800 --> 55:42.800]  Представьте себе, что вот эти h, как плохие множества.
[55:46.800 --> 55:49.800]  Тогда, что такое хорошее, значит, вот это вот плохие
[55:49.800 --> 55:55.800]  множество, а я хочу узнать количество хороших элементов.
[55:55.800 --> 55:58.800]  Так, нет, наверное, вот это вот глупо.
[55:58.800 --> 56:00.800]  Сейчас, наверное, не лишнее.
[56:00.800 --> 56:03.800]  Да, сейчас будут все плохие.
[56:05.800 --> 56:08.800]  Так, сейчас извините на всякий случай.
[56:11.800 --> 56:15.800]  Да, это я лишнее, это я лишнее взял.
[56:15.800 --> 56:18.800]  Так вот, пусть это плохие множества, мне нужно Mage
[56:18.800 --> 56:19.800]  количество хороших элементов.
[56:19.800 --> 56:21.800]  То есть, те, которые не попадают ни в одно множество, — это
[56:21.800 --> 56:24.800]  как раз размер множества пересечений дополнений.
[56:24.800 --> 56:27.800]  Доболнение — это как раз не попадающее в АИТ,
[56:27.800 --> 56:29.800]  пересечение всех дополнений, это те элементы,
[56:29.800 --> 56:30.800]  которые никуда не попадают.
[56:30.800 --> 56:33.800]  Так вот множество элементов, которые никуда не попадают,
[56:33.800 --> 56:35.800]  это что такое?
[56:35.800 --> 56:54.800]  Это все множество, все элементы, кроме тех, которые попали в а1 и т.д. а, плюс те, которые попали в 2 из них,
[56:54.800 --> 56:59.800]  минус те, которые попали в 3 из них, ну и т.д.
[56:59.800 --> 57:03.800]  А это уже обычная, собственно, формировка форму в члене исключения.
[57:03.800 --> 57:09.800]  То есть мы сначала берем все, как бы все элементы, это будет слагаемо,
[57:09.800 --> 57:12.800]  означает, что их равно к кустовому множеству, когда здесь будет 1,
[57:12.800 --> 57:16.800]  перечисление по кустовому множеству считается равным b, то есть всему универсуму.
[57:16.800 --> 57:24.800]  Ну и дальше вычитание по одному элементу, прибавление попарных переченей, вычитание по троечных переченей, ну и т.д.
[57:26.800 --> 57:27.800]  Так вроде нормально.
[57:33.800 --> 57:51.800]  Дальше, смотрите, давайте я скажу, что b это множество вершин нашего графа, множество вершин нашего графа g.
[57:51.800 --> 57:57.800]  А в качестве вот этих ашек я возьму все независимые множества нашего графа.
[57:57.800 --> 58:05.800]  Значит, клика, вот только что у нас были клики, это наборы вершин, которые попарно ребрами соединены,
[58:05.800 --> 58:09.800]  а независимые наоборот, когда нет ни одного ребра.
[58:09.800 --> 58:21.800]  Значит, вот давайте я все заминирую, пусть и 1 и так далее, и самым большой, это все независимые множества.
[58:21.800 --> 58:29.800]  Независимые это такие, внутри которых нет ребр.
[58:36.800 --> 58:39.800]  Независимые множества внутри него нет ребр.
[58:39.800 --> 58:47.800]  Смотрите, зачем нам они нужны?
[58:47.800 --> 58:54.800]  Например, вот на этой картинке мы можем легко заметить, что если я рассмотрю множество конкретного цвета,
[58:54.800 --> 58:59.800]  например, вот здесь я рассмотрел вершины столько первого цвета, это гарантированно независимая множество.
[58:59.800 --> 59:03.800]  Потому что пусть между ними ребро, они не могли бы быть оба одного цвета.
[59:03.800 --> 59:06.800]  Не могли бы быть эти вершинки одного цвета.
[59:06.800 --> 59:13.800]  Ну и в общем случае, если у нас есть корректный раскраску концветов, то множество любого конкретного цвета,
[59:13.800 --> 59:17.800]  множество вершин покрашенных определенного цвета С, это всегда независимое множество,
[59:17.800 --> 59:20.800]  потому что между ними не может быть ребр по определению.
[59:20.800 --> 59:26.800]  Вершины одного цвета, они обязательно не соединились, потому что если соединились, то должны быть разные.
[59:26.800 --> 59:33.800]  Поэтому наша цель, в какое-то смысле множество В, это разбить в объединение независимых множеств.
[59:33.800 --> 59:35.800]  Давайте я нарисую такую картинку.
[59:35.800 --> 59:38.800]  Мне нужно взять несколько независимых множеств,
[59:38.800 --> 59:43.800]  а там Исим в режиме И1, Исим в режиме И2, Исим в режиме И3.
[59:43.800 --> 59:50.800]  И соответственно покрасить все вот эти в первый цвет, все вот эти во второй, эти в третий и так далее.
[59:50.800 --> 59:56.800]  Если моя цель это найти раскраску в конец цветов, то мне нужно В покрыть К независимой множеством.
[59:56.800 --> 59:58.800]  Согласны?
[59:58.800 --> 01:00:00.800]  Согласны.
[01:00:03.800 --> 01:00:19.800]  Я запишу, что раскраска цветов, это то же самое, что покрытие В, покрытие В к независимому множеству.
[01:00:28.800 --> 01:00:38.800]  Более того, для простоты мы позволим себе этим множеством пересекаться.
[01:00:38.800 --> 01:00:41.800]  Мы позволим, что эти множества могут между собой пересекаться.
[01:00:49.800 --> 01:00:55.800]  Ну, если по-прежнему выполняется, что объединение всех этих независимых множеств по-прежнему В,
[01:00:55.800 --> 01:00:58.800]  то мы все равно имеем корректную раскраску в конец цветов.
[01:00:58.800 --> 01:01:06.800]  Ну, потому что если есть пересечения, то я могу спокойно одно из высших множеств сузить до такого, чтобы у меня раскраска однозначно определялась.
[01:01:06.800 --> 01:01:09.800]  От того, что они пересекаются, мне только как бы легче жить.
[01:01:09.800 --> 01:01:14.800]  Потому что если они пересекаются, то значит я вот эти вершины могу покрасить и во второй, и в третий цвет.
[01:01:14.800 --> 01:01:16.800]  Но главное, что хоть как-то могу.
[01:01:16.800 --> 01:01:19.800]  Поэтому я не буду заботиться о том, что они не пересекаются.
[01:01:19.800 --> 01:01:24.800]  Вообще говоря, в нормальном мире раскраска – это именно разбиение вершин на несколько независимых множеств.
[01:01:24.800 --> 01:01:29.800]  Так что множество вершин покрашено в первых цветовых сторонах, и они не пересекаются очевидно.
[01:01:29.800 --> 01:01:34.800]  Но я для того, чтобы решить задачу, не буду в этом заботиться.
[01:01:34.800 --> 01:01:46.800]  Давайте это отдельно пропишу, что независимые множества могут пересекаться.
[01:01:49.800 --> 01:01:52.800]  Главное это обеспечить то, что они в объединении покрывают все В.
[01:01:52.800 --> 01:01:57.800]  Если они в объединении покрыли все В, то у меня точно есть правильный раскраска цветов.
[01:02:09.800 --> 01:02:11.800]  Чудно.
[01:02:11.800 --> 01:02:12.800]  Что я хочу?
[01:02:12.800 --> 01:02:19.800]  Я хочу научиться покрывать В несколькими независимыми множеств.
[01:02:19.800 --> 01:02:22.800]  Точнее, ровно к независимым множествам.
[01:02:22.800 --> 01:02:24.800]  Вот хочу такую штуку сделать.
[01:02:42.800 --> 01:02:44.800]  Сейчас, момент.
[01:02:47.800 --> 01:02:48.800]  Да.
[01:02:49.800 --> 01:02:51.800]  Вот что обозначим.
[01:02:54.800 --> 01:02:56.800]  Out X.
[01:02:59.800 --> 01:03:01.800]  Out X.
[01:03:01.800 --> 01:03:06.800]  Это количество таких независимых множеств, которые с X не пересекаются.
[01:03:08.800 --> 01:03:15.800]  Количество таких, давайте скажем, жи, что и житое пересечение с X это пустое множество.
[01:03:18.800 --> 01:03:23.800]  Есть отдельно X, есть отдельно независимые множества из X уже.
[01:03:23.800 --> 01:03:29.800]  А вот X это количество независимых множеств, не пересекающихся с X.
[01:03:30.800 --> 01:03:35.800]  Тогда, теорема.
[01:03:40.800 --> 01:03:48.800]  Количество покрытий В с помощью K независимых множеств
[01:03:48.800 --> 01:04:16.800]  равно сумме по всем X под множеством V минус 1 в степени мощности X на Out X в степени K.
[01:04:18.800 --> 01:04:33.800]  Вроде правильно.
[01:04:33.800 --> 01:04:41.800]  Да, конечно, это тоже трудная задача, там на коленом надеяться нельзя.
[01:04:41.800 --> 01:04:46.800]  Значит, смотрите, давайте поймем, что это написано.
[01:04:46.800 --> 01:04:51.800]  Вот тут есть слагаемое нулевое, для X все равно пустое множество.
[01:04:58.800 --> 01:05:07.800]  Что это за сумма, смотрите, для X все равно пустое множество, у меня получается слагаемое Out пустого в степени K.
[01:05:07.800 --> 01:05:12.800]  Что такое Out пустого множества в степени K?
[01:05:16.800 --> 01:05:26.800]  Да, общее количество зависимых множеств.
[01:05:26.800 --> 01:05:30.800]  Я вам обозначил N большого, это будет N большого в степени K.
[01:05:30.800 --> 01:05:36.800]  Out пустого множества, понятно, что любое независимое пересекается с пустым по пустому множеству.
[01:05:36.800 --> 01:05:40.800]  Поэтому Out пустого множества это вообще все независимые множества.
[01:05:40.800 --> 01:05:43.800]  Что это такое, соответственно, это N в степени K?
[01:05:43.800 --> 01:05:50.800]  По факту это общее количество вот таких вот наборов, упорядоченных наборов, I, I1 и так далее, I и K,
[01:05:50.800 --> 01:05:54.800]  где все I-шки это независимые множества, но произвольные, произвольные независимые множества.
[01:05:54.800 --> 01:06:02.800]  То есть вот это вот количество, первое слагаемое в нашей сумме, это общее количество кортежей длины K из независимых множеств.
[01:06:02.800 --> 01:06:09.800]  Дальше, мне нужно из них вычесть те, которые, скажем, не покрыли первую вершину.
[01:06:09.800 --> 01:06:15.800]  Да, потому что если я учел все возможные кортежи длины K из независимых множеств,
[01:06:15.800 --> 01:06:19.800]  то из них плохие те, кто первую вершину не покрыли, потому что мне нужно покрыть все.
[01:06:19.800 --> 01:06:24.800]  Это соответствует слагаемой для X равно множество из единиц.
[01:06:24.800 --> 01:06:34.800]  Тогда как раз А от множества из единицы это в точности количество независимых, не содержащих единицу.
[01:06:34.800 --> 01:06:44.800]  То есть количество независимых множеств, не содержащих вершину номер один.
[01:06:49.800 --> 01:06:53.800]  Их я вычитаю, потому что здесь будет минус один.
[01:06:53.800 --> 01:07:01.800]  И соответственно я вычитаю все возможные кортежи длины K из независимых множеств, такие, что в них нет единиц.
[01:07:01.800 --> 01:07:05.800]  Дальше я вычитаю все, которые не содержат двойки, тройки, так далее, m.
[01:07:05.800 --> 01:07:08.800]  Потом прибавляю все попарные.
[01:07:08.800 --> 01:07:17.800]  То есть, скажем, когда х равно 1 на 2, я, наоборот, прибавлю все возможные кортежи длины K из независимых множеств,
[01:07:17.800 --> 01:07:20.800]  которые не содержат ни единичек, ни двойки.
[01:07:20.800 --> 01:07:26.800]  Потом по множеству размера 3 я их вычитаю, по множеству размера 4 прибавляю.
[01:07:26.800 --> 01:07:33.800]  То есть по факту я просто использую форму исключений, где b это общее количество покрытий,
[01:07:33.800 --> 01:07:37.800]  общее количество, точнее, кортежей длины K из независимых множеств.
[01:07:37.800 --> 01:07:44.800]  А все h, 1, так далее, am, это кортежи без какой-то конкретной вершины.
[01:07:44.800 --> 01:07:53.800]  Сейчас давайте напишу конкретно это все, и получится, что мы теперь мы казали.
[01:07:53.800 --> 01:07:56.800]  Значит, по факту доказательства из двух строчек.
[01:07:56.800 --> 01:07:59.800]  b это...
[01:08:05.800 --> 01:08:14.800]  Давайте просто так напишу. Все кортежи из K из независимых множеств.
[01:08:14.800 --> 01:08:21.800]  А и t это то же самое.
[01:08:32.800 --> 01:08:37.800]  Но причем эти множества должны не содержать вершин. Не содержащих.
[01:08:44.800 --> 01:08:57.800]  Тогда то, что написано в левой части нашей леммы, вот это вот,
[01:08:57.800 --> 01:09:04.800]  количество кортежей длины K, которые не лежат ни в одном из аи.
[01:09:04.800 --> 01:09:07.800]  Это точно все кортежи, покрывающие целиком множество v.
[01:09:07.800 --> 01:09:12.800]  Потому что принадлежность к любому из аи, это значит, что какой-то элемент в нашем покрытии не участвует.
[01:09:12.800 --> 01:09:17.800]  А если я лежу в пересечении дополнений к аи, тогда у меня по-красному все вершины покрыты.
[01:09:17.800 --> 01:09:23.800]  Получается, что количество хороших покрытий нашего v, то есть по факту то, что мы ищем,
[01:09:23.800 --> 01:09:29.800]  равно вот такой сумме, ну и собственно там какие-то пересечения по под множествам аи,
[01:09:29.800 --> 01:09:34.800]  ну пересечения по множеству аи, если я пересеку какие-то ашки,
[01:09:34.800 --> 01:09:44.800]  то у меня будет в точности вот это вот количество всех независимых, которые не содержат ни одной из вершин данного множества.
[01:09:44.800 --> 01:09:50.800]  То есть формально просто вот это вот лемма для должных а и b.
[01:09:50.800 --> 01:09:58.800]  Вот, ну и таким образом, смотрите, если я научился каким-то образом находить для каждого икса
[01:09:58.800 --> 01:10:04.800]  количество независимых множеств не пересекающих x, то я могу посчитать эту сумму,
[01:10:04.800 --> 01:10:08.800]  если она больше нуля, то значит есть раскраска в кадр цветов.
[01:10:09.800 --> 01:10:12.800]  Давайте напишем следствие.
[01:10:12.800 --> 01:10:15.800]  Раскраска в кадр цветов существует.
[01:10:18.800 --> 01:10:21.800]  Раскраска в кадр цветов существует.
[01:10:25.800 --> 01:10:28.800]  Только если эта сумма больше нуля.
[01:10:38.800 --> 01:10:40.800]  Вот так вот.
[01:11:08.800 --> 01:11:24.800]  То есть мне осталось научиться делать следующий шаг.
[01:11:24.800 --> 01:11:30.800]  Мне нужно для каждого множества научиться находить количество независимых не пересекающихся из данного множества x.
[01:11:30.800 --> 01:11:39.800]  Как найти all of x для всех x?
[01:11:46.800 --> 01:11:48.800]  Так, сейчас, момент.
[01:11:53.800 --> 01:11:55.800]  Ну, давайте немножко переформулируем.
[01:11:55.800 --> 01:12:05.800]  Во-первых, all of x это все такие независимые множества, которые вложены в a без из.
[01:12:08.800 --> 01:12:12.800]  Да, потому что не пересекающие с x, а то же самое, что вложено в дополнение x.
[01:12:15.800 --> 01:12:22.800]  Поэтому теперь мне достаточно научиться для каждого множества, давайте еще переформулируем, назову их как-нибудь y.
[01:12:22.800 --> 01:12:32.800]  Вот если я напишу, что b вот y, это множество всех независимых множеств, вложенных в y,
[01:12:32.800 --> 01:12:38.800]  то дальше просто all of x, сейчас будет y просто, ну, как бы сменой маски напротиволожных.
[01:12:38.800 --> 01:12:42.800]  А all of x это будет b без x.
[01:12:43.800 --> 01:12:47.800]  Поэтому достаточно научиться находить вот эту b.
[01:12:47.800 --> 01:12:55.800]  Мне достаточно научиться для каждой маски узнавать, сколько в ней есть независимых подмасок.
[01:12:55.800 --> 01:12:58.800]  То есть множество маска, да, какая-то y.
[01:12:58.800 --> 01:13:01.800]  Нужно узнать, сколько в ней есть независимых подможеств.
[01:13:01.800 --> 01:13:03.800]  Внутри этого множество есть.
[01:13:07.800 --> 01:13:09.800]  Так, ну давайте сделаем.
[01:13:17.800 --> 01:13:33.800]  Мне нужна будет еще одна вспомогательная штука, это мы уже делали.
[01:13:33.800 --> 01:13:36.800]  Это проверка того, что y является независимым.
[01:13:36.800 --> 01:13:47.800]  То есть штука, если y независима множеством, но если иначе, да, иначе.
[01:13:50.800 --> 01:13:53.800]  Тогда b это просто сумма c по всем подмножествам.
[01:13:56.800 --> 01:14:04.800]  Это сумма по всем, ну давайте z там из y, c вот z.
[01:14:04.800 --> 01:14:06.800]  То есть я перебираю все подмножества.
[01:14:06.800 --> 01:14:10.800]  И либо оно независимое, тогда оно дает 1 в нашу сумму.
[01:14:10.800 --> 01:14:13.800]  А если оно не независимое, то оно дает 0 в нашу сумму.
[01:14:13.800 --> 01:14:16.800]  Как раз мы считаем количество из этих множеств.
[01:14:18.800 --> 01:14:23.800]  То есть смотрите, у меня есть массив c, который мы уже умеем считать за 2 в степени n.
[01:14:23.800 --> 01:14:33.800]  Раньше мы для каждой маски могли посчитать динамику за вот такое время,
[01:14:33.800 --> 01:14:35.800]  которая проверяет, является она клика или нет.
[01:14:35.800 --> 01:14:37.800]  Но то же самое работает с независимыми множествами,
[01:14:37.800 --> 01:14:39.800]  потому что клика и независима очень похожи.
[01:14:39.800 --> 01:14:45.800]  Можно просто взять дополнение графа, когда поменять ребро на отсутствие ребра,
[01:14:45.800 --> 01:14:47.800]  и наоборот отсутствие ребра пролететь в ребро.
[01:14:47.800 --> 01:14:50.800]  Когда у вас клика и независимое множество поменяются места.
[01:14:50.800 --> 01:14:53.800]  Так вот, мы можем посчитать от массива за 2 в степени n,
[01:14:53.800 --> 01:14:59.800]  а дальше мне нужно учиться находить сумму по подмаскам вот этого массива c.
[01:14:59.800 --> 01:15:03.800]  То есть я фиксировал какую-то маску, нужно брать все подмаски и найти сумму cоз.
[01:15:06.800 --> 01:15:08.800]  Ну давайте быстренько это сделаем.
[01:15:08.800 --> 01:15:32.800]  Значит, пусть dp, mask, pos, эта сумма по всем подмаскам,
[01:15:32.800 --> 01:15:35.800]  совпадающих с маской хотя бы в pos первых бит,
[01:15:36.800 --> 01:15:46.800]  Так, нужна буква f, я браю все подмаски,
[01:15:46.800 --> 01:15:52.800]  и при этом f и mask совпадают в первых, по крайней мере, pos бит.
[01:15:54.800 --> 01:16:01.800]  Совпадают хотя бы в первых pos бит.
[01:16:05.800 --> 01:16:07.800]  С от f.
[01:16:13.800 --> 01:16:15.800]  Ну тогда если мы такую динамику ввели,
[01:16:15.800 --> 01:16:20.800]  тогда соответственно ответ у нас b от y.
[01:16:21.800 --> 01:16:23.800]  Это просто dp от y.
[01:16:27.800 --> 01:16:29.800]  Да, потому что когда pos равно 0,
[01:16:29.800 --> 01:16:33.800]  это значит, что мы не накладываем никакое ограничение на подмаске.
[01:16:33.800 --> 01:16:35.800]  А здесь если pos какой-то,
[01:16:35.800 --> 01:16:37.800]  то мы опять-таки рассматриваем сумму по всем подмаскам,
[01:16:37.800 --> 01:16:41.800]  но только они, вот эти подмаски f должны обязательно совпадать в первых pos битах.
[01:16:41.800 --> 01:16:44.800]  Если pos равно 0, то это точно то, что нам нужно.
[01:16:44.800 --> 01:16:46.800]  Как бы не требуется никакое совпадение.
[01:16:46.800 --> 01:16:48.800]  Теперь как делать переходы.
[01:16:48.800 --> 01:16:51.800]  Ну точнее давайте начнем с базы.
[01:16:51.800 --> 01:16:59.800]  База dp, mask, b, это просто c от маски.
[01:17:00.800 --> 01:17:04.800]  Потому что если мне нужна подмаска данной маски,
[01:17:04.800 --> 01:17:06.800]  совпадающая с ней в первых n битах,
[01:17:06.800 --> 01:17:08.800]  то это просто она сама.
[01:17:08.800 --> 01:17:10.800]  У нас сумма ведется по одному элементу,
[01:17:10.800 --> 01:17:12.800]  остается просто c от маски.
[01:17:12.800 --> 01:17:14.800]  Вот, ну теперь переход.
[01:17:15.800 --> 01:17:17.800]  Давайте я самый сложный случай рассмотрю.
[01:17:17.800 --> 01:17:19.800]  Представьте, у вас была маска какая-то.
[01:17:22.800 --> 01:17:25.800]  Вот вы хотите найти dp, mask, pos.
[01:17:25.800 --> 01:17:27.800]  Если здесь единица,
[01:17:27.800 --> 01:17:30.800]  то мы можем эту единичку проварировать.
[01:17:30.800 --> 01:17:32.800]  То есть в подмасках она либо 0, либо 1.
[01:17:34.800 --> 01:17:36.800]  В подмасках она либо 0, либо 1.
[01:17:36.800 --> 01:17:38.800]  И соответственно тогда совпадают первые pos минус...
[01:17:38.800 --> 01:17:40.800]  совпадают...
[01:17:40.800 --> 01:17:42.800]  Так, наоборот я иду с конца.
[01:17:42.800 --> 01:17:47.800]  Да, значит я могу фиксировать этот бит каким-нибудь.
[01:17:47.800 --> 01:17:50.800]  И тогда сказать, что совпадает не первый pos бит, а первый pos плюс один бит.
[01:17:50.800 --> 01:17:52.800]  И будет такая форма, по примеру.
[01:17:55.800 --> 01:17:57.800]  Так, извините, пару минут мне еще нужно.
[01:18:00.800 --> 01:18:02.800]  Значит, если...
[01:18:02.800 --> 01:18:04.800]  если...
[01:18:04.800 --> 01:18:06.800]  после письма еще...
[01:18:11.800 --> 01:18:13.800]  тогда dp, mask, pos.
[01:18:16.800 --> 01:18:19.800]  Это dp.
[01:18:19.800 --> 01:18:21.800]  То есть я сначала этот бит оставляю.
[01:18:22.800 --> 01:18:26.800]  И говорю, что мы совпадаем в pos плюс одном бит.
[01:18:26.800 --> 01:18:29.800]  То есть я здесь насильно оставил единичку.
[01:18:29.800 --> 01:18:32.800]  И скажу, что мы совпадаем еще на одном бите побольше.
[01:18:32.800 --> 01:18:34.800]  То есть я оставил там гарантированную единичку.
[01:18:34.800 --> 01:18:37.800]  Либо же я могу эту единицу занулить.
[01:18:37.800 --> 01:18:41.800]  И соответственно взять dp от маски без...
[01:18:43.800 --> 01:18:45.800]  ну без вот этого бита.
[01:18:45.800 --> 01:18:47.800]  Это будет что-то в стиле...
[01:18:48.800 --> 01:18:50.800]  2 в стиле не минус pos.
[01:18:52.800 --> 01:18:54.800]  Да, потому что номер этого бита...
[01:18:54.800 --> 01:18:56.800]  примерно как раз 2 в стиле не минус pos.
[01:18:56.800 --> 01:19:00.800]  Ну и опять-таки совпадают с первым pos и с одном битем.
[01:19:02.800 --> 01:19:04.800]  То есть еще раз, если в маске здесь была единица,
[01:19:04.800 --> 01:19:07.800]  а я хочу, чтобы они совпадали в этих вот битах первых,
[01:19:07.800 --> 01:19:09.800]  то я перебираю, что стоит здесь.
[01:19:09.800 --> 01:19:11.800]  Что в подмаске стоит в этом бите? Либо 0, либо 1.
[01:19:11.800 --> 01:19:14.800]  Если 0, тогда соответственно я могу здесь насильно поставить 0.
[01:19:14.800 --> 01:19:16.800]  Его вычеркнуть из маски.
[01:19:16.800 --> 01:19:18.800]  И сказать, что мы совпадаем с первым pos и с одном битем.
[01:19:18.800 --> 01:19:22.800]  Либо здесь стоит 1, и я совпадаю просто с pos и с одном битем.
[01:19:22.800 --> 01:19:24.800]  Вот дыру, которую пошел.
[01:19:24.800 --> 01:19:27.800]  Соответственно я в этой сумме разбил слагами на две части.
[01:19:27.800 --> 01:19:29.800]  Те, у которых тут 1 и те, у которых тут 0.
[01:19:29.800 --> 01:19:31.800]  Ну и сложил, которые сложил через dp.
[01:19:35.800 --> 01:19:36.800]  Вот.
[01:19:37.800 --> 01:19:39.800]  Все, тем самым у меня получается ответ.
[01:19:39.800 --> 01:19:41.800]  Я насчитал за...
[01:19:41.800 --> 01:19:43.800]  ну типа 2 в стиле не минус 5.
[01:19:46.800 --> 01:19:49.800]  Все, теперь значит, с конца пройдемся еще раз.
[01:19:49.800 --> 01:19:51.800]  Мы не считали dp.
[01:19:51.800 --> 01:19:55.800]  То есть мы для каждого множества знаем, сколько у меня есть независимых подмножек.
[01:19:55.800 --> 01:19:58.800]  Значит, знаем массив a, вот этот вот, который нам был нужен.
[01:19:58.800 --> 01:20:02.800]  Ну и теперь, если там с правильными процентами их сложить все, в каты степени возвести,
[01:20:02.800 --> 01:20:06.800]  то мы будем знать количество покрытий k независимым множеством.
[01:20:06.800 --> 01:20:10.800]  А этот раз решает нашу дачу про k-раскраску.
[01:20:12.800 --> 01:20:14.800]  Все, спасибо. Извините, что я немножко субботно.
