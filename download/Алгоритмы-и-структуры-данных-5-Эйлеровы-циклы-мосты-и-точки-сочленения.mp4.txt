[00:00.000 --> 00:06.400]  Так, давайте начинать.
[00:06.400 --> 00:10.840]  Я принял решение, мы, наверно, возместим лекцию, которая
[00:10.840 --> 00:14.040]  в 21 февраля у нас пропала, потому что иначе я не могу
[00:14.040 --> 00:17.520]  состыковать программу семинаров с лекциями, там будут дурки.
[00:17.520 --> 00:26.760]  Вот, поэтому у нас точно неделя, а какое это получается?
[00:26.760 --> 00:27.760]  16-е.
[00:28.520 --> 00:31.040]  Вот, я проведу две лекции, одну в обычное время и сразу
[00:31.040 --> 00:32.040]  следующую за ней.
[00:32.040 --> 00:41.800]  Вот, со своей стороны могу только пообещать, что
[00:41.800 --> 00:46.080]  ее материал не будет нужен для следующих лекций, поэтому
[00:46.080 --> 00:50.240]  как бы если вы категорически отрицаете поход на лекции,
[00:50.240 --> 00:52.760]  которые выпадают на праздники, можете не приходить, типа
[00:52.760 --> 00:54.960]  на следующих лекциях вам это не понадобится, но
[00:54.960 --> 00:57.080]  она будет обязательна в том смысле, что там и контесты
[00:57.080 --> 01:02.440]  на нее и в экзамене она будет, поэтому на ваш вкус.
[01:02.440 --> 01:08.160]  Вот, а аудиторию я еще сообщу дополнительно, о чем я начну
[01:08.160 --> 01:11.440]  на первой лекции, я начну, короче, по окончающей пути
[01:11.440 --> 01:14.960]  все там будет, я начну БФС да икстра, а звездочка,
[01:14.960 --> 01:18.320]  а на второй будет Форд Делман и Флойд.
[01:18.320 --> 01:28.760]  Так, окей, давайте вернемся к нашим орграфам, значит
[01:28.760 --> 01:32.360]  в прошлый раз, я так понимаю, я закончил на таком утверждении,
[01:32.360 --> 01:36.360]  что если есть ребро из-за А в Б, то алгоритм Касараю
[01:36.360 --> 01:43.240]  скажет, что ID от А меньше, что равно ID от Б, вот было
[01:43.240 --> 01:44.240]  такое?
[01:44.240 --> 01:48.040]  Вроде да, хорошо, значит, сейчас мы будем этим
[01:48.040 --> 01:51.000]  пользоваться для решения следующей задачи, задача
[01:51.000 --> 02:06.080]  называется два SAT, SAT от Solace Satisfiability, два выполнимости,
[02:06.080 --> 02:07.920]  значит представьте себе такую задачу, у вас есть
[02:07.920 --> 02:15.040]  формула в виде два KNF, насчет такой два KNF это конъюнкция
[02:15.040 --> 02:18.080]  скобок, в каждой скобке дезъюнкция двух литералов,
[02:18.080 --> 02:22.640]  вот это примерно что-то типа такого Х или Y, и не
[02:22.640 --> 02:29.800]  А или Б, и не Y или не В, вот такая конъюнкция скобок
[02:29.800 --> 02:32.640]  в каждой скобке дезъюнкция двух литералов, литерал
[02:32.640 --> 02:35.640]  это переменная или отрицание переменной, вот, и наша
[02:35.640 --> 02:41.040]  задача посчитать, извините, найти какой-нибудь выполняющий
[02:41.040 --> 02:51.840]  набор, найти выполняющий набор, то есть такой набор
[02:51.840 --> 02:54.160]  значений переменных, на котором вот эта формула
[02:54.160 --> 03:00.320]  равна единице, то есть набор, на котором формула равна
[03:00.320 --> 03:15.200]  единице, вот, значит решается следующим образом, мы заводим
[03:15.200 --> 03:19.200]  граф, в котором вершины будут выступать вот как
[03:19.200 --> 03:22.800]  раз эти литералы, переменные и отрицания переменных,
[03:22.800 --> 03:32.400]  значит мы заводим граф, вершины, это все литералы,
[03:32.400 --> 03:35.160]  то есть все переменные и отрицания переменных,
[03:35.160 --> 03:40.360]  например, вот здесь у меня будет Х не Х, Y не Y, а не А,
[03:40.360 --> 03:43.400]  Б не Б, короче, для каждой переменной, которая состоится
[03:43.400 --> 03:47.040]  в формуле, я завожу по две вершинки и помещаю их соответственно
[03:47.040 --> 03:49.520]  пометками, там, переменная и отрицание переменной,
[03:50.480 --> 03:53.680]  а дальше провожу очень естественные стрелочки, которые по сути
[03:53.680 --> 03:57.400]  эквивалентны вот этим дизюнкциям, если стрелочка воспринимать
[03:57.400 --> 04:00.880]  как импликации, то я могу записать все эти инвункции
[04:00.880 --> 04:03.760]  в виде импликации и в виде стрелок нашего графа, значит
[04:03.760 --> 04:08.840]  смотрите, что такое дизюнкция А или Б, значит это то же самое,
[04:08.840 --> 04:13.680]  что сказать, что из не А следует Б, и то же самое, что если
[04:13.680 --> 04:19.080]  сказать из не Б следует А, ну понятно, потому что дизюнкция
[04:19.080 --> 04:22.120]  что хотя бы один должен быть истинной, это что значит,
[04:22.120 --> 04:24.000]  значит если первым не верим, то обязательно верим в
[04:24.000 --> 04:27.960]  второй, если не А то Б, ну наоборот если не Б то А, такое
[04:27.960 --> 04:31.520]  очень простое замечание, ну давай тогда если видим
[04:31.520 --> 04:34.920]  такую скобку, то проведем вот эти все стрелки, то есть
[04:34.920 --> 04:37.560]  если я вижу такую скобку, ну тут ее нет, но если бы
[04:37.560 --> 04:41.880]  она была, я бы провел ребро из не А в Б, а это есть у
[04:41.880 --> 04:44.240]  меня вершина в нашем графе, соответственно ребро из
[04:44.240 --> 04:48.360]  не Б в А, вот и так для каждой скобки, перебираем все скобочки,
[04:48.360 --> 04:51.960]  и проводим два соответствующих ребра, которые по факту
[04:51.960 --> 04:55.000]  эквивалентны, то есть если ребра воспринимают как
[04:55.000 --> 04:58.400]  компликации, как эти логические следствия, то они эквивалентны
[04:58.400 --> 05:00.800]  просто-напросто в нашей дизюнкции, значит делаем
[05:00.800 --> 05:14.320]  так для каждой скобки, значит теперь смотрите, смысл такой,
[05:14.320 --> 05:18.320]  я хочу сказать, что каждая вершина это какой-то логический
[05:18.340 --> 05:22.780]  значение, true или false, это humidific tragedy, и если у
[05:22.780 --> 05:25.020]  меня есть стрелочка откуда-то, и если вот это вот
[05:25.040 --> 05:27.860]  откуда-то равно единице, то тогда все, что достигнуто
[05:27.860 --> 05:30.340]  по стрелочке тоже должно быть единицей, ну, потому
[05:30.340 --> 05:33.200]  что, да, вот представьте себе, что это истина литералка,
[05:33.200 --> 05:35.720]  то не А равно единице, тогда для этого должно быть
[05:35.720 --> 05:39.240]  В, ну потому что имплекация так работает, если посылка
[05:39.240 --> 05:41.620]  истина, то заключение должно быть истинным, чтобы эта
[05:41.620 --> 05:45.080]  имплекация была истинная, потому что если была 1 0,
[05:45.080 --> 05:47.940]  то эта имплекация была бы ложная, на мне надо�
[05:47.940 --> 05:50.740]  Нам не нужно, чтобы если единица, то здесь тоже единица.
[05:50.760 --> 05:53.820]  Поэтому вот эти ребра, они как бы проталкивают единицу
[05:53.840 --> 05:55.240]  из позиции во все остальные.
[05:55.260 --> 05:58.220]  То есть если где-то один, если где-то получился истинный лейтенант,
[05:58.240 --> 06:01.760]  то все, что из них достеремо, тоже должно быть истинным.
[06:01.780 --> 06:10.120]  Вот, ну и поэтому утверждение формула Фи выполнило,
[06:10.120 --> 06:16.940]  если и только если для любой переменной P,
[06:16.960 --> 06:20.920]  вот в этом графе, который мы построили,
[06:20.940 --> 06:26.360]  ну я напишу так id от P, не равно id от не P.
[06:26.380 --> 06:34.600]  То есть для каждой переменной, она, точнее вершина, отвечающая этой переменной,
[06:34.620 --> 06:36.920]  и вершина, отвечающая отрицание этой переменной,
[06:36.940 --> 06:39.240]  лежат в разных компонентах сильной связности,
[06:39.280 --> 06:43.340]  а id-шники, это вот ровно то самое, те самые id-шники из алгоритма Касараю.
[06:43.360 --> 06:46.360]  Вот эти id нам проставляют в алгоритм Касараю.
[06:52.000 --> 06:55.280]  Соответственно тогда задачу мы решим так, нам дали формулу,
[06:55.300 --> 06:57.440]  какую-то такую вот, да, мы строим граф,
[06:57.460 --> 07:01.520]  для каждой скобки, проводя по два ребра,
[07:01.540 --> 07:03.940]  затем запускаем на этом графе алгоритм Касараю,
[07:03.960 --> 07:07.540]  он всем вершинам, все вершины разбивает на компоненты сильной связности,
[07:07.540 --> 07:09.640]  то есть у каждой вершинки поставляет id-шник,
[07:09.660 --> 07:12.460]  номер компонент и сильность связности, где вершина лежит.
[07:12.480 --> 07:14.280]  Ну и дальше просто по всем вершинам проходим,
[07:14.300 --> 07:17.040]  если видим, что вершина лежит со своим отрицанием,
[07:17.060 --> 07:19.340]  точнее если перемена со своим отрицанием в одной ксс,
[07:19.360 --> 07:22.240]  в одной компоненте, тогда мы говорим, что решения нет.
[07:22.260 --> 07:25.620]  Вот, ну а если это для всех вершин выполняется,
[07:25.640 --> 07:29.340]  то есть если тут неверно для всех, то значит решения есть.
[07:29.360 --> 07:32.080]  Не штекарайся с вами.
[07:32.100 --> 07:36.300]  Ну, слева-направо очевидно,
[07:38.320 --> 07:43.300]  потому что если было верно бы обратное, да, давайте от противного,
[07:46.120 --> 07:49.120]  если бы существовала некоторая переменная,
[07:49.140 --> 07:52.140]  которая попала бы в одну ксс со своим отрицанием,
[07:55.620 --> 07:57.820]  что это бы значило? Вот здесь какая-то ксс,
[07:57.840 --> 08:00.340]  здесь есть п, здесь есть не п.
[08:01.320 --> 08:03.720]  Что значит, что они лежат в одной компоненте сильной связности?
[08:03.740 --> 08:05.740]  Значит, они друг с другом достижены в обе стороны.
[08:05.760 --> 08:09.440]  Просто по определению, компоненты сильной связности – это класс эквивалентности,
[08:09.460 --> 08:13.660]  то есть внутри компоненты у нас есть пути в обе стороны, по определению просто.
[08:13.680 --> 08:15.680]  То есть есть такой путь, есть вот такой путь.
[08:17.280 --> 08:21.280]  Ну, тогда извините, давайте спросим себя, а какая из этих переменных истина?
[08:22.120 --> 08:24.120]  Точнее, какой из этих литералов истинный?
[08:24.140 --> 08:26.880]  Мы же знаем, что p должно быть либо 0, либо 1 равно
[08:26.900 --> 08:28.900]  вот в этом выполняющем наборе.
[08:28.920 --> 08:30.320]  Вот чему оно равно?
[08:30.340 --> 08:32.040]  Но понимаете, что если по едиplayful,
[08:32.080 --> 08:35.080]  тогда при проходе по этим стрелкам не p тоже должно быть едицей.
[08:36.280 --> 08:39.500]  Ну потому что вот я здесь заметил, что если я где-то ставлю единицу,
[08:39.520 --> 08:42.900]  то все, что достижено по стрелкам, потому что должны быть истинные эkaции,
[08:42.920 --> 08:44.420]  здесь тоже должно быть едицей.
[08:44.700 --> 08:46.340]  Ну, противоречие – у меня не может быть переменных,
[08:46.360 --> 08:48.560]  и отрицание переменных одновременно истинными.
[08:48.580 --> 08:51.560]  И наоборот, если едиzenцвт 01 здесь в не p,
[08:51.580 --> 08:54.520]  тогда при проходе по стрелкам получаем, что
[08:54.540 --> 08:56.340]  p тоже должно быть едицей. Противоречие.
[08:57.240 --> 08:59.240]  Ну, значит тогда никто из...
[08:59.240 --> 09:12.840]  по и не по не может быть единицей, противоречие.
[09:12.840 --> 09:15.880]  Так это было простую сторону, теперь обратно, почему
[09:15.880 --> 09:18.120]  если вот это верно, то форма выполнима.
[09:18.120 --> 09:25.840]  Значит, давайте я скажу следующее, давайте я рассмотрю произвольную
[09:25.840 --> 09:28.760]  переменную, и здесь есть два варианта.
[09:28.760 --> 09:30.560]  Сейчас посмотрим, кто из них больше, у кого одишник
[09:30.560 --> 09:31.560]  больше, УП или УНИП.
[09:31.560 --> 09:37.960]  Вот я скажу, что если УП-одишник больше, чем УНИП, тогда я
[09:37.960 --> 09:42.360]  назначу переменную П в значении 1, а если меньше, то ноль.
[09:42.360 --> 09:52.520]  Ну, я напишу так, давайте не П равно 1, то есть П равно
[09:52.520 --> 09:53.520]  нулю.
[09:54.520 --> 09:58.760]  То есть я рассматриваю вот эти две вершинки, переменные
[09:58.760 --> 10:02.800]  и отрицания к переменной, и та из них, у кого больше
[10:02.800 --> 10:06.520]  одишник, истинна, то есть в этом случае у меня УП-одишник
[10:06.520 --> 10:09.720]  больше, я говорю, что П-истина, а здесь у НИП-одишник больше,
[10:09.720 --> 10:12.000]  поэтому я говорю, что НИП равно 1, то есть у кого одишник
[10:12.000 --> 10:13.000]  больше, то это истинный.
[10:13.000 --> 10:17.560]  Вот, таким образом я задал какой-то набор в значении
[10:17.560 --> 10:20.960]  всех переменных, но поскольку у меня для всех выполняется
[10:20.960 --> 10:23.440]  либо это, либо это, нет равенств, то точно какой-то
[10:23.440 --> 10:26.040]  набор в значении переменных, надо доказать, что выполняющий.
[10:26.040 --> 10:27.040]  Покажем, что это выполняющий набор.
[10:27.040 --> 10:46.480]  Вот, пусть не так, что значит, что этот набор не выполняющий?
[10:46.480 --> 10:48.880]  Значит, вот наша коньюция не верна, коньюция скобок
[10:48.880 --> 10:51.520]  не верна, то есть не верна как минимум одна из скобок,
[10:51.520 --> 10:56.280]  то есть есть какая-то скобка вида х или у, которая на
[10:56.280 --> 10:57.280]  этом наборе ложна.
[10:57.280 --> 11:03.960]  Ну, что такое дизюнция ложная, значит х равно 0, у равно 0,
[11:03.960 --> 11:08.320]  то есть в терминах вот этих одишников у х одишник
[11:08.320 --> 11:12.600]  меньше, чем у не х, и у у одишник меньше, чем у у,
[11:12.600 --> 11:22.440]  на idx меньше id не x, и idy меньше id не y.
[11:22.440 --> 11:26.200]  Значит, здесь я не умоляю опшности, потому что под
[11:26.200 --> 11:29.560]  x и y может сковаться не переменная, а, например,
[11:29.560 --> 11:32.680]  отрицание переменной, тогда отрицание литерала,
[11:32.680 --> 11:34.680]  значит, если там два отрицания, они съедаются.
[11:34.680 --> 11:37.400]  Например, если у меня здесь было написано не х или
[11:37.400 --> 11:39.800]  у, тогда мне здесь было бы написано не х, а здесь
[11:39.800 --> 11:40.800]  не не х, то есть х.
[11:41.600 --> 11:44.360]  Здесь как бы, это именно литералы могут быть, x и
[11:44.360 --> 11:47.040]  y могут быть литералами, не обязательно переменными.
[11:47.040 --> 11:51.160]  Ну, а дальше очень просто, значит, мы с вами знаем, что
[11:51.160 --> 11:53.760]  если есть такая скобка, то у меня точно есть такие
[11:53.760 --> 11:54.760]  вот ребра.
[11:54.760 --> 12:00.000]  Из не х есть ребро в у, давайте я вот так вот нарисую,
[12:00.000 --> 12:01.320]  из не у есть ребро в х.
[12:01.320 --> 12:07.440]  Да, это я вот там нарисовал, что если есть такая скобочка,
[12:07.440 --> 12:09.320]  то я провожу вот эти вот импликации, потому что
[12:09.320 --> 12:14.000]  если не х, то должно быть верно у, если не у, то должно
[12:14.000 --> 12:15.000]  быть верно х.
[12:15.000 --> 12:18.040]  Но вместе с тем утверждением, которым я в начале лекции
[12:18.040 --> 12:22.640]  вспомнил, я могу написать, значит, давайте, я уже забыл,
[12:22.640 --> 12:25.360]  как оно формулируется, значит, айдишник в начале меньше,
[12:25.360 --> 12:26.360]  чем в конце.
[12:26.360 --> 12:27.360]  Ну да, да.
[12:27.360 --> 12:32.720]  Значит, ну давайте напишем вот здесь, айди не х меньше
[12:32.720 --> 12:37.680]  равно, чем конец этого ребра, айди вот у, так это утверждение
[12:38.000 --> 12:39.000]  с левой доски.
[12:39.000 --> 12:40.000]  Дальше.
[12:40.000 --> 12:42.200]  По вот этому неравенству айди вот у строго меньше,
[12:42.200 --> 12:43.200]  чем айди вот не у.
[12:43.200 --> 12:44.200]  Дальше.
[12:44.200 --> 12:49.400]  Есть ребро из не у в х.
[12:49.400 --> 12:51.760]  Значит, здесь можно продолжить не строгое неравенство,
[12:51.760 --> 12:52.760]  айди вот х.
[12:52.760 --> 12:56.480]  Ну а и от х мы знаем, что строго меньше, чем айди
[12:56.480 --> 12:57.480]  вот не х.
[12:57.480 --> 13:03.240]  Все противоречия получили, что значение строго меньше,
[13:03.240 --> 13:04.240]  чем оно же само.
[13:05.240 --> 13:06.240]  Противоречия.
[13:10.240 --> 13:11.240]  Нормально?
[13:23.240 --> 13:24.240]  Так, все активно пишут.
[13:28.240 --> 13:29.240]  Вопроски есть?
[13:31.240 --> 13:33.240]  Хорошо, ну давайте еще раз повторю, да, то есть, если
[13:33.240 --> 13:36.240]  у меня была форма вот такого вида, что в каждой
[13:36.240 --> 13:39.240]  скупке два литерала всего через дизюнкцию идут, то
[13:39.240 --> 13:42.240]  можно построить граф импликации, который равен населению
[13:42.240 --> 13:43.240]  нашей формы.
[13:43.240 --> 13:46.240]  Мне нужно, чтобы все импликации были верны и просто проверить,
[13:46.240 --> 13:48.240]  что никакая перемена не попала своим отрицанием
[13:48.240 --> 13:49.240]  в одно и то же КСС.
[13:49.240 --> 13:52.240]  Если это верно, то вот, например, так можно выбрать
[13:52.240 --> 13:53.240]  выполняющий набор.
[14:03.240 --> 14:11.240]  Вот, ну и эта басата, она такая довольно полезная
[14:11.240 --> 14:12.240]  задача.
[14:12.240 --> 14:15.240]  Всюду, где у вас выборы с двух опций может быть,
[14:15.240 --> 14:17.240]  да, ну там не знаю, например, у вас какая-нибудь задача
[14:17.240 --> 14:19.240]  по каким-нибудь выключателю, что вы можете нажать на
[14:19.240 --> 14:21.240]  выключатель или можете не нажимать на выключатель
[14:21.240 --> 14:23.240]  и должно там что-то выполняться.
[14:23.240 --> 14:25.240]  Тогда вы можете просто вести буливскую перемену
[14:25.240 --> 14:27.240]  для каждого выключателя, типа, используете вы его
[14:27.240 --> 14:30.240]  или нет, ну и написать там необходимые условия.
[14:30.240 --> 14:33.240]  Если задача достаточно хорошая, да будет как раз
[14:33.240 --> 14:36.240]  форма в виде 20, ну и вот 20 решить, собственно, таким
[14:36.240 --> 14:38.240]  образом, как мы обсудили.
[14:48.240 --> 14:52.240]  Так, следующий микросюжет – это эйлеровость.
[14:52.240 --> 14:55.240]  Эйлеровые, ну эйлеровость пусть будет.
[15:00.240 --> 15:03.240]  Ну пусть будет определение, что ли, не знаю.
[15:03.240 --> 15:06.240]  Эйлеровым циклом в графе называется цикл, который
[15:06.240 --> 15:08.240]  проходит по всем ребрам ровно по одному разу.
[15:14.240 --> 15:21.240]  Цикл, проходящий по всем ребрам графа ровно один раз.
[15:30.240 --> 15:44.240]  Ну давайте, сразу тярема, тярема один.
[15:51.240 --> 15:53.240]  Так, сейчас.
[16:00.240 --> 16:15.240]  Пусть ориентированный граф G слабосвязан.
[16:15.240 --> 16:21.240]  Слабосвязан – это значит связан как неориентированный
[16:21.240 --> 16:23.240]  граф после удаления стрелочек на ребрах.
[16:23.240 --> 16:26.240]  То есть в ориентированном графе у меня все ребра имеют
[16:26.240 --> 16:27.240]  начало и конец.
[16:27.240 --> 16:30.240]  Вот, когда я говорю слабосвязан, значит я как бы отбрасываю
[16:30.240 --> 16:33.240]  требования одностороннести, я могу ходить по ребру в
[16:33.240 --> 16:34.240]  обе стороны.
[16:34.240 --> 16:36.240]  Он будет связан, ну как обычный неориентированный
[16:36.240 --> 16:37.240]  граф.
[16:37.240 --> 16:38.240]  То есть любой вершин есть путь любой другой.
[16:38.240 --> 16:43.240]  Так вот, пусть орг граф G слабосвязан после удаления
[16:49.240 --> 16:51.240]  всех висячих вершин.
[16:51.240 --> 16:59.240]  Висячие – это те, у которых, короче, вершины без ребер
[16:59.240 --> 17:00.240]  вообще.
[17:00.240 --> 17:01.240]  Без входящих, без исходящих.
[17:01.240 --> 17:03.240]  То есть это вершины без ребер.
[17:03.240 --> 17:05.240]  Вершины без ребер.
[17:05.240 --> 17:06.240]  Вот.
[17:06.240 --> 17:11.240]  Значит тогда это уже дает, что в таком графе существует
[17:11.240 --> 17:15.240]  эйверов цикл, если только, если входная степень равная,
[17:15.240 --> 17:17.240]  входящая степень равная исходящей до всех вершин.
[17:17.240 --> 17:23.240]  Тогда в G есть эйверов цикл.
[17:23.240 --> 17:31.240]  Ну как угодно, давайте напишу изолированную, если вам так
[17:31.240 --> 17:32.240]  приятнее.
[17:32.240 --> 17:36.240]  Да, вы правы, извините, мой косяк, да, изолированная,
[17:36.240 --> 17:37.240]  да.
[17:37.240 --> 17:40.240]  Это я с деревом перепутал, там действительно одно.
[17:40.240 --> 17:41.240]  Да, изолированных.
[17:41.240 --> 17:42.240]  Спасибо.
[17:42.240 --> 17:43.240]  Да, спасибо, спасибо.
[17:43.240 --> 17:48.240]  В G эйверов цикл, если только, если для любовью вершины
[17:48.240 --> 17:49.240]  V.
[17:49.240 --> 17:54.240]  Ну я картинку давайте нарисую.
[17:54.240 --> 18:00.240]  Числов входящих равно числу исходящих.
[18:00.240 --> 18:09.240]  Можно написать in degree равна out degree.
[18:09.240 --> 18:10.240]  Вот.
[18:11.240 --> 18:16.240]  Ну и второе, значит, все то же самое, только существует
[18:16.240 --> 18:17.240]  эйверов путь.
[18:17.240 --> 18:20.240]  Если это верно для всех вершин, кроме двух, ну а две
[18:20.240 --> 18:23.240]  вот это вот как раз, то есть если у меня есть какое-то
[18:23.240 --> 18:26.240]  начало пути и конец пути, то в начале, получается,
[18:26.240 --> 18:29.240]  у меня должно быть на одно меньше входящее, а в конце
[18:29.240 --> 18:30.240]  на одно меньше исходящее.
[18:30.240 --> 18:36.240]  Так, ну давайте я вот это вот скопирую, да, CTRL-C, CTRL-V,
[18:36.240 --> 18:39.240]  вот это вот все, то есть это общая преамбула.
[18:39.240 --> 18:49.240]  Значит, тогда в G есть эйверов путь, если и только если
[18:49.240 --> 18:54.240]  для всех вершин кроме двух выполняется вот это, а
[18:54.240 --> 18:58.240]  для одной из оставшихся входная на одно меньше
[18:58.240 --> 19:08.240]  входящее, а еще для последней оставшейся, значит, ну
[19:08.240 --> 19:12.240]  наоборот, да, сейчас, давайте все напишем.
[19:12.240 --> 19:23.240]  Значит, если и только если, неприятный слой, значит,
[19:23.240 --> 19:26.240]  надо еще оставить в случае, если есть сам цикл, да.
[19:27.240 --> 19:30.240]  Слабо связано, значит, связано после игнорирования
[19:30.240 --> 19:32.240]  ориентации, то есть у меня ребра со стрелочками,
[19:32.240 --> 19:34.240]  а если убираю стрелочку, то должен быть просто
[19:34.240 --> 19:36.240]  слабо, ну как бы связан, как неориентированный граф.
[19:39.240 --> 19:47.240]  Так, для всех V, для всех вершин кроме, возможно, двух,
[19:47.240 --> 19:50.240]  вот так напишу, кроме, возможно, двух
[19:50.240 --> 19:57.240]  вершин, выполняется требование про входную и выходную
[19:57.240 --> 20:09.240]  степени, вот, ну а для двух оставшихся, для двух оставшихся,
[20:09.240 --> 20:17.240]  ну там, короче, одно на один больше, другое на один
[20:17.240 --> 20:19.240]  меньше, другое на один меньше.
[20:26.240 --> 20:28.240]  В этом случае, например, плюс один, в другом случае
[20:28.240 --> 20:30.240]  минус один.
[20:34.240 --> 20:37.240]  Так, давайте я напишу не V только, а, например, S и T,
[20:37.240 --> 20:43.240]  значит, indegree больше для конца, для точки T, и меньше
[20:43.240 --> 20:47.240]  для точки S. Можно так сделать.
[20:57.240 --> 20:59.240]  Не понял?
[21:07.240 --> 21:09.240]  И не, еще раз, смотрите,
[21:10.240 --> 21:14.240]  сейчас, сознательно две картинки всего может быть,
[21:14.240 --> 21:20.240]  то есть у нас либо есть L-ров цикл, ну это он автоматически
[21:20.240 --> 21:23.240]  путем является, и это вот этот вот случай, когда есть
[21:23.240 --> 21:25.240]  цикл, соответственно, у всех indegree верну outdegree,
[21:25.240 --> 21:32.240]  либо вот такая картинка, где есть две точки S и T
[21:32.240 --> 21:35.240]  отдельно выделенные, у которых indegree и outdegree
[21:35.240 --> 21:37.240]  вот так соотносят, то есть для S верно вот это, для
[21:37.240 --> 21:39.240]  T верно вот это, а для всех остальных выполняется
[21:39.240 --> 21:41.240]  все же самое, что indegree верну outdegree.
[21:43.240 --> 21:45.240]  Вот, поэтому я тут написал, кроме, возможно, 2, то есть
[21:45.240 --> 21:48.240]  возможно для всех верно, что вот эти вот равенство
[21:48.240 --> 21:51.240]  соблюдается, когда есть просто цикл, вот, а иначе
[21:51.240 --> 21:53.240]  должно быть максимум 2, и для них должно быть такое
[21:53.240 --> 21:55.240]  соотношение верно.
[21:55.240 --> 21:58.240]  Значит, ну, это уже, наверное, многие из вас видели, я
[21:58.240 --> 22:02.240]  здесь подчеркну только вот это. Тут важно сказать,
[22:02.240 --> 22:07.240]  что он связан просто удаление изолированных вершин,
[22:07.240 --> 22:11.240]  потому что, если забыть про связанность и просто
[22:11.240 --> 22:14.240]  требовать вот этой вот штуки, тогда, ну, у вас не обязательно
[22:14.240 --> 22:16.240]  есть реверс цикл, потому что если вы нарисуете какие-нибудь
[22:16.240 --> 22:20.240]  два треугольника просто вот таких вот, да, здесь у
[22:20.240 --> 22:25.240]  всех indegree равно outdegree, но реверс цикла нет. Другой
[22:25.240 --> 22:27.240]  вопрос, конечно, что можно все покрыть циклами, да,
[22:27.240 --> 22:29.240]  то есть можно взять вот этот цикл и вот этот цикл,
[22:29.240 --> 22:31.240]  и это будет покрытие всех реверс циклами, но это
[22:31.240 --> 22:34.240]  все-таки не ailer цикл, потому что это все-таки один цикл
[22:34.240 --> 22:37.240]  должен быть, а здесь их в два. Вот, поэтому если мы
[22:37.240 --> 22:41.240]  хотим прям один цикл покрыть, то мне нужно, как бы, чтобы
[22:41.240 --> 22:43.240]  все покрывалось, то есть чтобы была одна компонента
[22:43.240 --> 22:45.240]  связанности в каком-то смысле, чтобы можно было
[22:45.240 --> 22:48.240]  где-то начать, все пройти, где-то закончить и прям
[22:48.240 --> 22:50.240]  все реверсы посетить. На, поэтому не забывайте, пожалуйста,
[22:50.240 --> 22:53.240]  говорить, что у нас граф, типа, связанный. Связанность
[22:53.240 --> 22:57.240]  будет в этом смысле, что он связанный после удаления
[22:57.240 --> 23:00.240]  ориентации и всех изолированных вершин, потому что изолированные,
[23:00.240 --> 23:06.240]  их не нужно посещать, и они мешают на пределе связанности,
[23:06.240 --> 23:08.880]  потому что если бы сюда вот к треугольнику добавить
[23:08.880 --> 23:11.120]  изолированную вершину, то у нас все равно есть в этом
[23:11.120 --> 23:14.840]  граф иллеров цикл, то есть изолированная вершина
[23:14.840 --> 23:15.840]  не мешает ничему.
[23:15.840 --> 23:20.360]  Значит, это в случае неориентированных графов.
[23:20.360 --> 23:26.720]  В случае ориентированных условия чуть проще, надо
[23:26.720 --> 23:29.240]  просто требовать связанность, и чтобы у каждой вершины
[23:29.240 --> 23:30.240]  была отчетная степень.
[23:30.240 --> 23:34.960]  Значит, быстренько давайте запишем тирема два, пусть
[23:34.960 --> 23:46.880]  G неорграф, G связан после удаления всех изолированных.
[23:46.880 --> 24:05.080]  Тогда цикл в нем есть, иллеров цикл в нем есть, если все
[24:05.080 --> 24:06.080]  степени четные.
[24:06.080 --> 24:30.640]  Степени все совершенно четные, и уже есть иллеров
[24:30.640 --> 24:53.920]  путь, если только есть степени всех, кроме, возможно, двух
[24:54.920 --> 25:20.520]  Так, давайте это я доказывать не буду, оно будет автоматически
[25:21.520 --> 25:22.520]  истинно.
[25:22.520 --> 25:31.560]  Ну, смотрите, здесь требование слева-направо очевидно
[25:31.560 --> 25:32.560]  в обоих случаях.
[25:32.560 --> 25:37.360]  Давайте пункт А, когда есть иллеров цикл в орграфе.
[25:37.360 --> 25:40.760]  Ну, как бы понятно, что как выглядят иллеров цикл.
[25:40.760 --> 25:44.800]  Мы где-то начали, в какой-то точке S, как-то ходим, можем
[25:44.800 --> 25:48.000]  куда-то заходить, где уже были, и заканчиваем там же,
[25:48.000 --> 25:49.000]  где начали.
[25:49.240 --> 25:51.020]  Ну, тогда понятно, что в каждую вершину мы как-бы
[25:51.020 --> 25:54.900]  возможно многократно зашли и вышли, зашли и вышли,
[25:54.900 --> 25:57.520]  поэтому каждый проход через вершину как бы использует
[25:57.520 --> 26:00.160]  одно входное и одно исходящее ребро, одно входящее и одно
[26:00.160 --> 26:01.160]  исходящее.
[26:01.160 --> 26:02.840]  Поэтому у нее обязательно количество входящих равно
[26:02.840 --> 26:04.840]  количество исходящих.
[26:04.840 --> 26:09.480]  На IN degree равно OUT degree.
[26:09.480 --> 26:13.960]  Ну, просто потому что цикл использует все ребра, то
[26:13.960 --> 26:16.360]  есть мы все ребра учли, и при этом вошли в вершину
[26:16.360 --> 26:18.640]  ровно столько раз, сколько вышли из нее.
[26:18.640 --> 26:22.840]  Значит, суммарно для каждой вершины, количество вхождений равно количеству выходов из нее.
[26:23.720 --> 26:26.920]  Это требование тривиально. Ну, пункт B, собственно,
[26:28.840 --> 26:33.800]  тоже очевиден. Если у меня есть, что такое Эллеров путь, я это уже тут рисовал. Это либо
[26:34.440 --> 26:41.480]  реально путь, то есть который начинается и заканчивается в разных вершинках, тогда выполняется вот это вот, на что есть две вершины, для которых
[26:41.480 --> 26:49.880]  цикл, ну, понятно, indigree, audigree отличается на единицу. Либо это просто цикл, то есть цикл тоже является путем и
[26:50.280 --> 26:52.960]  значит выполняется вообще условие пункта А, а значит тоже все хорошо.
[26:54.640 --> 27:00.280]  Вот, теперь в обратную сторону, почему если верно вот это условие про степени,
[27:00.680 --> 27:04.240]  то мы как-то найдем обязательно Эллеров путь, Эллеров цикл.
[27:04.960 --> 27:07.640]  Давайте сначала пункт B мы сведем к пункту А,
[27:07.640 --> 27:09.640]  проведя ребро из ТВС.
[27:20.080 --> 27:28.400]  Тем самым я увеличу здесь indigree, а здесь audigree, и если было верно вот это вот, то есть, если у меня было две вершины, для которых выполнялись вот эти вот условия,
[27:28.600 --> 27:37.560]  то я теперь увеличу indigree для S и audigree для T. Тем самым у меня у всех вершин выровняются indigree и audigree, входящие и сходящие степени.
[27:38.480 --> 27:41.520]  И значит, граф будет уже удовлетворять условие пункта А.
[27:42.720 --> 27:51.240]  Поэтому в нем достаточно будет найти Эллеров цикл, если мы найдем там Эллеров цикл и потом удалим ребро из ТВС, то у меня как раз получше Эллеров путь.
[27:51.240 --> 27:55.360]  Потому что цикл это что такое, мы как-то там ходим, используем это ребро, все посещаем.
[27:55.440 --> 28:01.000]  Теперь если я из цикла этого выкинул ребро из ТВС, то значит у меня получше просто некий путь из С в Т.
[28:01.960 --> 28:05.760]  Значит мне достаточно научиться как-то конструктивно находить Эллеров цикл
[28:06.760 --> 28:08.760]  в случае пункта А.
[28:14.960 --> 28:21.200]  Вот, ну а вторая теорема, то есть это я сейчас делаю алгоритм предъявляем, а вторая теорема
[28:22.480 --> 28:28.680]  собственно там такое же доказательство в этом пункте, да, то есть тривиальное следствие, если есть Эллеров цикл, то там очевидно все степени четные.
[28:28.960 --> 28:34.080]  В обратную сторону тоже тот же самый алгоритм сгодится для того, чтобы найти цикл в графе с четными степенями.
[28:35.760 --> 28:43.320]  Значит так, пункт А, справа налево.
[28:50.760 --> 28:56.240]  Так, ну давайте игнорировать все изолированные вершины, давайте возьмем какую-нибудь вершину неизолированную, С.
[28:57.560 --> 28:59.560]  И давайте из нее запустим
[29:00.760 --> 29:04.600]  тупой ДФС. Что такое тупой ДФС? Это ДФС, который
[29:05.880 --> 29:11.040]  не переисползывает ребра, ну потому что там нельзя использовать ребра дважды, но при этом ему
[29:12.000 --> 29:14.400]  допустимо заходить в одну и ту же вершину несколько раз.
[29:15.520 --> 29:17.520]  Например, если я нарисую что-нибудь вот такое,
[29:24.720 --> 29:32.960]  то ДФС может работать так, значит мы сначала зашли сюда, потом сюда, потом вот здесь, вот потом вернулись сюда, это все еще
[29:33.440 --> 29:38.120]  как бы рекурсивные запуски ДФСа, то есть мы из этой вершины опять запускаемся, находим этот путь,
[29:38.560 --> 29:44.680]  доходим до сюда и вот тут завершаемся. В какой-то момент видим, что дошли до вершины, из нее уже нету как бы неиспользованных ребер.
[29:44.840 --> 29:46.840]  То есть по факту такой ДФС
[29:47.360 --> 29:49.360]  без запоминания, напишу в кавычках,
[29:50.080 --> 29:52.080]  будьте здоровы,
[29:52.320 --> 29:54.240]  без запоминания,
[29:54.240 --> 30:00.480]  то есть мы можем как бы повторно запускаться ДФСом из вершин, где уже были.
[30:03.960 --> 30:05.960]  Можем запускать ДФС
[30:08.960 --> 30:10.960]  из вершин, где уже были.
[30:17.960 --> 30:24.960]  Значит единственное надо запретить себе переиспользовать ребра, потому что в Эйлер вам цикле я должен все ребра использовать только единожды.
[30:25.960 --> 30:31.960]  Мне нужно как-то в вершине, когда я нахожусь в вершине, научиться находить из него какое-то исходящее рядо, которое я еще не сделал.
[30:33.680 --> 30:37.560]  Это можно делать, например, так, мы можем в каждой вершине завести некий
[30:37.620 --> 30:43.120]  указатель или номер ребра, 就是 первого непросмотренного ребра.
[30:43.120 --> 30:48.520]  И тогда когда я наступаю в вершину, то у меня уже внутри хранится первый неиспользованный ребро, то есть указатель на param neispoz infrastructure.
[30:48.620 --> 30:52.560]  Я беру его и использую и сдвигаю тот указатель, который я только что использовал,
[30:53.680 --> 30:59.320]  представьте себе вот какая-то вершина, есть исходящее ребра и мне говорят ты вот эти уже использовал, а вот это перв Онииспользованный.
[30:59.320 --> 31:04.400]  тогда при запуске я сначала иду вот в это самое первое неиспользованное и
[31:04.400 --> 31:07.920]  сдвигаю указатель вот сюда то есть теперь первое неиспользованное это вот
[31:07.920 --> 31:13.960]  это очень простой значит очень простой алгоритм то есть можно какой-нибудь там
[31:13.960 --> 31:18.240]  птр от вы поддерживать это либо указатель либо просто номер первого
[31:18.240 --> 31:27.600]  неиспользованы ребра номер первого неиспользованного и ребра
[31:32.800 --> 31:39.120]  ребра в жевать в на то есть если же от в список всех ребер исходящих то как
[31:39.120 --> 31:42.720]  раз птр может просто нам указывать на первую неиспользована взяли использовала
[31:42.720 --> 31:47.360]  рекурсивно выпустились вот отсюда то есть мы нашли его из в ту рекурсивно
[31:47.360 --> 31:51.320]  запускаемся до фс мату и увеличиваем то есть перейдем как рекурсивно
[31:51.320 --> 31:57.560]  запустится увеличиваем птр от вы то есть я делал плюс плюс птр от вы и
[31:57.560 --> 32:01.440]  рекурсивно запускаю до фс от то
[32:04.480 --> 32:11.880]  так вот давайте хоть примерно рисую еще по по интеллектуален чем тот например
[32:11.880 --> 32:23.280]  может быть вот такой вот град так здесь конец от росток так ну еще какая-нибудь
[32:23.280 --> 32:29.800]  здесь петля вот что давайте на примере посмотрим как только гритм работает
[32:29.800 --> 32:34.080]  он может быть например так мы запускаемся до фс от с это произвольно старта
[32:34.080 --> 32:37.160]  вершина в ней ничего особенного нет я как угодно выделил главное что мы была
[32:37.360 --> 32:42.360]  неизолированная да значит я запускаюсь ну пусть например до фс обошел вот так
[32:42.360 --> 32:48.200]  вот так вот так вот так вот так дошел до с видишь что из нее не осталось не
[32:48.200 --> 32:52.920]  использованы хребр и в этом случае он он делает следующее он разворачивает
[32:52.920 --> 32:57.280]  стек рекурсии то есть как бы ну проходит назад разворачивает рекурсию с конца
[32:57.280 --> 33:01.840]  начала и все вот эти вот ребра которые он прошел добавляет в ответ ну как бы
[33:01.840 --> 33:10.120]  вот с конца с конца в начало с права налево то есть я беру вот эти вот все
[33:10.120 --> 33:16.440]  ребра в порядке от конца к началу добавляю ответ вот это вот добавил
[33:16.440 --> 33:21.440]  ответ вот это добавил в ответ а дальше вижу вершину из которой дальше
[33:21.440 --> 33:25.160]  продолжает работать потому что из нее есть не использованы ребра он берет и
[33:25.160 --> 33:28.600]  запускает из этой вершинки до фс например он найдет что-нибудь вот такое
[33:28.600 --> 33:34.600]  нашел вот такой вот цикл опять мы попали в ту же самую вершину из которой
[33:34.600 --> 33:38.000]  теперь нет не использованный хребр я все ребра использовал поэтому в этом
[33:38.000 --> 33:42.200]  случае я начинаю откатываться в стеке рекурсии до тех пор пока не дойдут до
[33:42.200 --> 33:47.680]  вершины из которых есть не использованы ребра то есть я иду от наиболее свежих
[33:47.680 --> 33:52.660]  ребр и наиболее старом и добавляю их в ответ ну как бы в конце да то есть они
[33:52.660 --> 33:57.000]  будут идти вот в конце до шоу завершения опять вижу здесь есть
[33:57.000 --> 34:04.360]  неиспользованные ребра, я беру их все использую и тут у меня ДФЗ заканчивается, опять нет ни
[34:04.360 --> 34:08.760]  одному неиспользованного ребра, тогда в этом случае опять я раскрываю весь стейк рекурсии,
[34:08.760 --> 34:14.400]  записываю все эти ребра в том порядке, в котором они шли у меня в стейк рекурсии, вот, ну и
[34:14.400 --> 34:18.960]  соответственно здесь, да, здесь будет раскрытие стейка рекурсии, вплоть до самого начала я дойду,
[34:18.960 --> 34:25.240]  до вышинки С, с которой начал, тогда смотрите, если я как бы, если я печатал эти ребра в том
[34:25.240 --> 34:29.680]  порядке, в котором вот мой ДФЗ их раскрывал, то у меня будет как бы вот такой вот цикл, а вот,
[34:29.680 --> 34:35.640]  вот такой вот, вот такой, ну естественно тогда надо просто его развернуть, потому что эти все
[34:35.640 --> 34:39.880]  ребра были в противоположном порядке записаны, то есть я записывал, когда я нашел последнее ребро,
[34:39.880 --> 34:44.320]  вот это вот ребро, я его как бы самым первым напечатал, потом вот это было предпоследним,
[34:44.320 --> 34:49.040]  это предпоследним и так далее, вот, ну получается они просто в порядке с конца, с конца, с права
[34:49.040 --> 34:53.200]  налево написаны короче, и чтобы восстановить правильный цикл, в нашем случае вот такой,
[34:53.200 --> 35:03.920]  надо просто их с права налево все прочитать, вот, ну почему это работает всегда, потому что вот в
[35:03.920 --> 35:10.080]  тот момент, когда я дошел до вершины, из которой нет исходящих ребер, такая вершина всегда единственная,
[35:10.080 --> 35:15.560]  потому что смотрите, вот в самом начале я запустил ДФЗ от С, он что-то там походил, вот когда в первый
[35:15.560 --> 35:20.280]  момент мы начинаем выводить ребра, когда мы впервые поняли, что нет новых неиспользованных ребер,
[35:20.280 --> 35:26.920]  вот обязательно это должно было быть, когда мы дошли до С, потому что если я начал в С, как-то там
[35:26.920 --> 35:32.720]  хожу, что-то использую, и пришел в вершину, из которой нет неиспользованных ребер, то это,
[35:32.720 --> 35:37.800]  блядь, на С, ну потому что каждый раз, когда я захожу в вершину и выхожу из нее, я уменьшаю
[35:37.800 --> 35:43.160]  IN Degree и OUT Degree на единицу, но если они всегда равны, если для всех вершин они одинаковые,
[35:43.160 --> 35:48.920]  то есть момент времени, когда я могу дойти до вершины без исходящих ребер, это только С,
[35:48.920 --> 35:53.880]  потому что если я вошел в какую-то другую вершинку, вот например в эту, тогда у нее я использовал одно
[35:53.880 --> 35:58.600]  исходящее, значит у нее есть как минимум еще одно исходящее, потому что они равны, значит единственный
[35:58.600 --> 36:05.280]  момент, когда я мог вот так вот зациклиться и не увидеть больше новых неиспользованных, это значит
[36:05.280 --> 36:10.520]  я должен был дойти до вот этого С. Потом, значит, я этот цикл раскручиваю, опять вижу вершинку,
[36:10.520 --> 36:18.000]  в которой, ну вот, то есть если я использую все то, что в стеке рекурсии и то, что уже напечатано,
[36:18.000 --> 36:25.680]  то эта вершина единственная, у которой, ну у нее есть непросмотренные, неиспользованные ребра,
[36:25.680 --> 36:30.920]  я вот так вот их запускаю, и опять, поскольку здесь я использовал только одно, то есть я начал,
[36:30.920 --> 36:36.920]  по сути, искать цикл вот отсюда, из этой вершинки, то закончусь я обязательно именно вот здесь вот,
[36:36.920 --> 36:40.280]  потому что это опять единственная вершина, у которой я использовал ребер на одно больше,
[36:40.280 --> 36:44.920]  чем, то есть исходящих на одно больше, чем входящих, поэтому вот этот вот цикл опять-таки
[36:44.920 --> 36:50.520]  замкнется вот здесь, и вот таким образом я все вот эти циклы как бы склею в одну большую цепочку.
[36:50.520 --> 37:06.680]  Так, окей, вот, ну хорошо, так, значит это тогда мы сделали, пункт b, повторюсь, решается просто
[37:06.680 --> 37:12.240]  добавлением вот такого ребра из tfs, то есть если я знаю, где должно начинаться, где должно
[37:12.240 --> 37:17.040]  заканчиваться, просто по сравнению in degree и out degree, то я могу добавить одно ребро,
[37:17.040 --> 37:21.880]  найти таким же алгоритмом Эйлеров цикл и удалить из него одно ребро из tfs, получив тем самым
[37:21.880 --> 37:27.840]  Эйлеров путь. Вот, а в случае неориентированного графа все даже еще проще, потому что когда
[37:27.840 --> 37:32.480]  ребра у меня неориентированы, то есть без вот этих вот стрелочек, мне даже не нужно будет в конце
[37:32.480 --> 37:37.360]  разворачивать наш путь, то есть вот здесь, вот когда я строю Эйлеров цикл в ориентированном графе,
[37:37.360 --> 37:42.440]  у меня ребра как бы они идут, ну вот в таком неправильном порядке, что сначала последнее ребро,
[37:43.360 --> 37:47.700]  потом последнее, потом это среднее и так далее, а если бы они были неориентированными, то мне бы на
[37:47.700 --> 37:51.200]  самом деле можно было бы считать, что это прям правильный порядок Эйлерового цикла, потому что
[37:51.200 --> 37:56.240]  если здесь убрать ориентацию, то то что я прохожу, это тоже будет Эйлеров цикл, вот прям в этом
[37:56.240 --> 38:02.240]  порядке, вот это, вот это, вот это, ну короче все эти ребра, это будет Эйлеров цикл после
[38:02.240 --> 38:09.440]  игнорируемой ориентации. Ну и собственно все тогда даже можно будет не разворачивать в этот список,
[38:09.440 --> 38:12.840]  то есть я могу просто печатать все эти ребра в том порядке, в котором я их нахожу в ДФС,
[38:12.840 --> 38:20.520]  вот печатаю и это будет обязательно эйлеров цикл, который, ну то есть его можно пройти двумя способами,
[38:20.520 --> 38:26.520]  вот я его как-то прошел, да там, справа налево, против всего стрелки, ну и он будет все равно
[38:26.520 --> 38:36.240]  всем удовлетворять. Так, чего, давайте перерыв тогда. Я перехожу к ДФС в неориентированных графах,
[38:36.240 --> 38:54.720]  сейчас поговорим про неориентированные еще графы. Ау, сценарий, ну сюжет типа того, да. Значит,
[38:54.720 --> 39:02.560]  смотрите, здесь, в отличие от ориентированных графов, есть небольшое упрощение в том плане,
[39:02.560 --> 39:10.320]  что, ну вот смотрите, давайте нарисую картинку в случае обычных ориентированных графов и в случае
[39:10.320 --> 39:17.600]  неориентированных графов. Смотрите, в этом случае, если у меня ДФС идет как бы вот так вот влево,
[39:17.600 --> 39:21.920]  то что он делает? Он покрасит эту вершинку в серый, эту в серый, эту в серый, потом отсюда,
[39:21.920 --> 39:26.000]  ребер нет, он красит ее в черный, разворачивается, красит эту в черный, подошед сюда,
[39:26.000 --> 39:30.200]  видит ребра в черную вершину. То есть в какой-то момент вот эта вершинка серая,
[39:30.200 --> 39:42.680]  а это черная на грейблэк бывает ребров в черную а здесь причем как бы как бы это эта вершинка
[39:42.680 --> 39:50.360]  как бы ниже находится на а здесь смотрите вот когда я иду опять-таки здесь слева по левой стороне то
[39:50.360 --> 39:55.520]  я покрасил эту шинку в серый эту серый эту серый и вижу как то есть вот это вот ребро я просматриваю
[39:55.520 --> 40:00.200]  как бы при просмотре снизу вверх уже и это будет как бы ребро между серой и серой да то есть и
[40:00.200 --> 40:05.240]  серой серая такие ребра уже как бы мы знаем это показали того что этот цикл мы помним что
[40:05.240 --> 40:12.160]  ребро в серую это как бы цикл и в общем в неориентированном графе как раз проблема здесь
[40:12.160 --> 40:16.880]  в том что это ребро ориентирован сверху вниз и как бы я не нахожу цикла вот при таком проходе
[40:16.880 --> 40:22.000]  потому что как бы нету снизу вверх а здесь оно есть снизу вверх вот поэтому в неориентированных
[40:22.000 --> 40:28.680]  графах мне даже не столько нужны вот эти вот цвета белый серый и черный мне достаточно будет
[40:28.680 --> 40:34.280]  просто знать бывал я в вершине когда-то или нет потому что если я вижу что я в вершине бывал то
[40:34.280 --> 40:39.480]  мне не важно какая она серая или черная да потому что это все равно значит что как бы у меня нашелся
[40:39.480 --> 40:49.040]  цикл поэтому вместо цветов вместо цветов просто храним метки посещенности
[40:49.040 --> 40:59.960]  метки посещенности ну вот там можно считать что какой-нибудь вектор был
[40:59.960 --> 41:10.960]  юст тру если мы вершинку когда-то уже заходили в полце если еще никогда не заходили вот и тогда
[41:10.960 --> 41:18.320]  dfs обычный да переписывается просто так что вместо проставления цветов white соответственно gray и
[41:18.320 --> 41:24.120]  black я изначально говорю что все юзды это false а потом когда я захожу в вершину я ставлю в ней
[41:24.120 --> 41:32.520]  юст равно true то есть у меня изначально здесь все false вот а когда я пишу dfs
[41:32.520 --> 41:44.120]  значит я не помню я вот здесь передавал parent или нет не передавал хорошо давайте давайте тогда
[41:44.120 --> 41:52.920]  не буду передавать значит я записываю что юст от в равно true то есть зашел сразу использовал
[41:52.920 --> 41:57.680]  то есть это как бы пометка на серое или черное можно считать что true это значит
[41:57.680 --> 42:02.360]  серая или черный вершин вот дальше там как обычно если надо проставляю всякие тыны
[42:02.360 --> 42:13.760]  вот вроде все здесь больше ничего не нужно перебираем все исходящие ребра
[42:22.640 --> 42:31.160]  и запускаем dfs только тех решений где еще не были то есть если это вершина белая если она еще не юст
[42:31.160 --> 42:41.720]  тогда dfs отту вот что-то примерно такое да там еще всякие да вот можно писать но не буду не
[42:41.720 --> 42:46.440]  буду писать что мы можем просто отказаться от цветов и использовать только вот эти вот
[42:46.440 --> 42:53.600]  меточки true или false значит давайте еще нарисую какую-нибудь картинку побольше
[43:06.920 --> 43:14.320]  вот сейчас вот например есть такой граф пунктирные рёбра тоже есть давайте их
[43:14.320 --> 43:21.440]  слабенькими нарисую они они тоже есть графе но по ним dfs как бы ходить не будет значит как может
[43:21.440 --> 43:27.000]  быть как работает dfs мы начинаем здесь спускаемся вот поэтому репорт давайте я на ребре нарисую
[43:27.000 --> 43:34.520]  ориентацию это означает что я его прошел в dfs то есть я взял и dfs прошел вот отсюда сюда то есть
[43:34.520 --> 43:39.760]  я находясь в верхней вершине запустился dfs от нижней за прошел вот сюда потом нашел вот до
[43:39.760 --> 43:45.640]  сюда все здесь больше никаких ребер нету внизу рекурсия поднимается сюда потом идет например вот
[43:45.640 --> 43:52.240]  сюда здесь вот сюда видит в этот момент времени смотрите он увидел ребро снизу вверх вот такие
[43:52.240 --> 44:00.360]  рёбра которые ведутся внизу вверх я буду называть обратными обратное ребро то есть это такое ребро
[44:00.360 --> 44:03.880]  которое я вот здесь вот не рассматривал потому что она ведет уже использованную вершинку да то
[44:03.880 --> 44:09.760]  есть оно ведет уже уже юзанную вершину где юз равно труп потому что она посещена раньше там юз
[44:09.760 --> 44:16.280]  равно труп вот ну значит здесь дальше поднимаюсь выше те вот эти вот ребра назначаю древесными то
[44:16.280 --> 44:21.840]  есть у них их ориентирую сверху вниз вот дальше рекурсия поднимается видит еще например вот это
[44:21.840 --> 44:29.200]  вот одно ребро снизу вверх оно тоже будет обратным да но она как бы ведет вот в противоположном
[44:29.200 --> 44:34.080]  направлении как бы снизу вверх меня ведет но будет тоже обратная его никак не использую просто
[44:34.080 --> 44:39.200]  ну если чё вот вижу обратные бро да например если мне нужно было бы узнать есть ли цикл в графе я
[44:39.200 --> 44:44.280]  мог бы по наличию вот такого обратного ребра понять что он есть если я вижу такой ребро значит
[44:44.280 --> 44:52.760]  есть цикл поднимаюсь вот да то есть здесь дфс все обошел рекурсия развернулась вернулась сюда
[44:52.760 --> 44:57.720]  смотрите вот в этот момент мы еще например еще раз видим вот это вот ребро которая как бы обратная
[44:57.720 --> 45:02.480]  то есть мы вот это обратное ребро увидели дважды снизу вверх и сверху вниз но на оба раза
[45:02.480 --> 45:06.800]  прогнарируется потому что к моменту когда я нахожусь здесь и вижу это ребро этой вышины уже
[45:06.800 --> 45:15.000]  использована вот ну дальше там пошел пошел наверх здесь все ориентировал увидел еще одно обратное
[45:15.000 --> 45:19.920]  ребро ну и собственно собственно это он в ход закончил и того смотрите мораль какая у меня есть
[45:19.920 --> 45:25.080]  на самом деле всего два типа ребер древесные это вот те которые я обхожу сверху вниз в процессе нашего
[45:25.480 --> 45:36.280]  древесные ребра и обратное причем обратное я как бы два раза смотрю я на обратной смотрю когда
[45:36.280 --> 45:42.720]  я нахожусь внизу и смотрю вверх и когда нахожусь сверху и смотрю вниз поэтому надо это иногда
[45:42.720 --> 45:47.280]  учитывать аккуратно понимать что если я вижу ребро в вершинку который уже юст написан до
[45:47.280 --> 45:51.920]  которой у которой уже использована тут либо ребро сверху не слили бы брос внизу вверх это надо
[45:51.920 --> 45:57.400]  всегда всегда помнить что ну короче где мы находимся на вот тут или тут это на самом деле
[45:57.400 --> 46:01.400]  довольно легко отследить потому что если вы например проставляете вот эти вот т.ин. и то
[46:01.400 --> 46:07.040]  по соотношению на т.ин. и в этих двух концах мы сразу можем понять кто из них лежит выше а кто
[46:07.040 --> 46:12.640]  ниже потому что понятно что если вышина выше то у нее т.ин. меньше а если ниже тут и больше поэтому
[46:12.640 --> 46:16.400]  если мы видим обратное ребро то понять какого оно типа вверх или вниз да то есть я его вот отсюда
[46:16.400 --> 46:21.080]  вижу или вот отсюда вижу на сверху вниз или сниз вверх я могу просто сравнить т.ин. у этих
[46:21.080 --> 46:29.000]  двух вершин x и y вот и там где меньше там собственно начало вот здесь будет т.ин. от x меньше то есть
[46:29.000 --> 46:34.160]  это ребро будет сверху вниз а если если я нахожусь в игреке то есть т.ин. от y больше чем т.ин. от x то
[46:34.160 --> 46:42.600]  я вижу вот этот как раз ребро снизу вверх вот но и главное еще что можно что можно сказать что у
[46:42.600 --> 46:47.800]  меня не бывает вот таких вот перекрестных ребер как бы между под деревьями потому что вот ну
[46:47.800 --> 46:51.280]  например если бы такое ребро у меня было то есть представьте что у меня есть такой граф есть такое
[46:51.280 --> 46:57.000]  ребро когда я бы на самом деле вот в процессе обхода вот этого dfs слева в левом под деревья
[46:57.000 --> 47:02.440]  я на самом деле и вот до сюда бы тоже дошел и все вот это вот на самом деле как бы было подвешено
[47:02.440 --> 47:06.520]  вот сюда то есть вот это вот все вот это вот все на самом деле висело бы где-то вот здесь если
[47:06.520 --> 47:12.040]  такой ребро есть вот поэтому таких ребер вот перекрестных между двумя разными под деревьями
[47:12.040 --> 47:17.920]  не бывает все ребра это либо прямые древесные ребра сверху вниз которые я в dfs обхожу либо
[47:17.920 --> 47:23.000]  обратные когда я поднимаюсь в одного из предков то есть на самом деле в одну из вершин которые
[47:23.000 --> 47:28.000]  в стеке рекурсии лежат то есть я спускаю сверху вниз вот они у меня все лежали на стеке стек
[47:28.000 --> 47:34.000]  рекурсии и обратное ребро может вести только в одну из вершин на в этом стеке то есть в одного
[47:34.000 --> 47:44.800]  из предков в этом дереве вот таких перекрестных ребер не бывает вот хорошо хорошо еще там и сказали
[47:44.800 --> 47:52.320]  теперь самая такая наверное популярная датчика про неориентированные графы это поиск мостов
[47:53.160 --> 48:01.920]  значит определение уже это связанный граф связанный не ориентированный граф
[48:08.760 --> 48:09.240]  тогда
[48:09.240 --> 48:13.440]  ребро г называется мостом
[48:13.440 --> 48:29.840]  если после его удаления граф перестает быть связан я напишу так ли ни во же минус я не связан
[48:29.840 --> 48:43.480]  например какая-нибудь вот такая вот картинка два треугольника с перемычкой вот это ребро мост
[48:43.480 --> 48:50.400]  потому что изначально граф связан если его удали то граф становится да он распадается на две
[48:50.400 --> 48:58.200]  компоненты связанности становится не связан вот ну и второе определение здесь же опять-таки пусть
[48:58.200 --> 49:08.640]  же связанный граф связанный не ориентированный граф тогда вершина в называется точка сочленения
[49:08.640 --> 49:30.480]  так ну тут по-английски как-то лаконичней получается cutpoint тут cutpoint но здесь
[49:30.480 --> 49:37.680]  соответственно бридж так и есть значит точка сочленения если но аналогично ее
[49:37.680 --> 49:46.360]  удаление из графа увеличивает делать граф не связан если же минус в не связан
[49:46.360 --> 49:56.520]  вот тут поинтереснее пример это когда два треугольника зацеплены по вершинке
[49:56.520 --> 50:04.860]  такой граф тогда вот это точка и точку сочленения потому что если ее если убрать но понятно что
[50:04.860 --> 50:09.080]  когда удаляю вершину я также удаляю все ребра которые ей инцидент на то есть я удаю не
[50:09.080 --> 50:13.040]  только точку но и собственно все вот эти вот ребра все эти 12-فр Está понятно что graph
[50:13.040 --> 50:22.140]  распадается на две компоненты связанности вот это и вот это ну и собственно вопрос который
[50:22.140 --> 50:25.740]  естественно себе поставить, это найдите, пожалуйста, все мосты, все точки соединения.
[50:25.740 --> 50:36.140]  Весьма полезная штука, потому что многие коммуникационные сети моделируются как раз в виде графов,
[50:36.140 --> 50:40.300]  то есть если у вас в вершинках какие-то клиенты, какие-то агенты, которые могут между собой общаться,
[50:40.300 --> 50:47.020]  а ребра — это каналы взаимодействия, то вот мосты — это те каналы, удаление которых делает вашу сеть
[50:47.020 --> 50:53.100]  не связано, то есть как раз вам нужно хоть расшибиться, но уметь поддерживать отказ
[50:53.100 --> 50:57.940]  за устойчивость этого канала, потому что если он сломается, то вы не можете передать информацию отсюда
[50:57.940 --> 51:03.260]  и сюда вообще никак, поэтому, наверное, вам надо особенно сфокусироваться на мостах, вам нужно,
[51:03.260 --> 51:08.020]  чтобы они всегда работали. То же самое с точками сочленения, если у вас как-нибудь клиенты
[51:08.020 --> 51:12.780]  вот так вот общаются, вот эти два между собой через него, то вам надо, чтобы этот клиент был
[51:12.780 --> 51:16.780]  достаточно мощным, чтобы он умел все вот эти запросы передавать, потому что если он откажет,
[51:16.780 --> 51:26.740]  то они между собой уже никак не свяжутся. Ну, давайте тогда найдем все мосты точек сочленения в графе.
[51:26.740 --> 51:43.660]  Так.
[51:43.660 --> 51:53.860]  Для этого мне понадобится следующая довольно нехитрая динамика. Смотрите, я хочу для каждой
[51:53.860 --> 52:04.700]  вершины V ввести следующую функцию red от V. Какой смысл у этой штуки? Вот представьте себе,
[52:04.700 --> 52:11.340]  что мы запустили какой-то DFS в нашем графе, он как-то, соответственно, там ориентировал все
[52:11.340 --> 52:15.580]  ребра, древесные ребра ориентировал сверху вниз, обратные ребра не ориентировал, но они как бы идут
[52:15.580 --> 52:23.860]  снизу вверх, мы считаем. Вот, значит, вот тут есть что-то достижимое из V под древесным ребром. Вот это
[52:23.860 --> 52:31.460]  вот все как бы под дерево, все что ниже V лежит. В качестве red от V я хочу брать самую высокую
[52:31.460 --> 52:38.020]  вершину, которая достижима вот отсюда прыжком по одному обратному ребру. То есть я могу сначала
[52:38.020 --> 52:44.700]  из V куда-то вниз спуститься, потом взять и прыгнуть вверх по обратному ребру. Вот из всех таких
[52:44.700 --> 52:49.100]  прыжков вверх я хочу выбрать самый высокий. То есть, например, отсюда я могу прыгнуть сюда,
[52:49.100 --> 52:55.540]  отсюда вот сюда и отсюда вот туда. Тогда из всех этих прыжков я хочу выбрать вот этот самый высокий.
[52:55.540 --> 53:03.060]  Ну а самый высокий — это, понятное дело, вершина с минимальным TIN, потому что все они ведут ну вот
[53:03.060 --> 53:08.060]  куда-то куда-то сюда, то есть в стек-рекурсе в момент времени входа в V, то есть это как бы родитель
[53:08.060 --> 53:13.940]  V или дедушка V или как бы прадедушка V и так далее, и они все понятны упорядочным по TIN,
[53:13.940 --> 53:18.900]  потому что как раз TIN как раз сверху внизу не идет. Поэтому я могу написать формально следующее — это
[53:18.900 --> 53:28.260]  минимум из. Во-первых, я напишу TIN от V это на случай, если я выше, чем V, прыгнуть никуда не могу. То
[53:28.260 --> 53:32.580]  есть у меня, например, есть какое-то вот такое вот ребро до V, но выше, то есть вот этих вот всех
[53:32.580 --> 53:37.900]  ребер нету. Выше, чем V я прыгнуть, например, не могу. Тогда мне нужен TIN от V здесь оставить. Вот.
[53:37.900 --> 53:52.940]  Либо же это минимум по всем. Так, давайте я напишу WU — ребро графа таким, что W лежит в поддереве V.
[53:52.940 --> 54:05.740]  Поддереве V, а WU — это обратное ребро. Обратное ребро. И по ним по всем нужно взять минимальный TIN
[54:05.740 --> 54:13.140]  от U. То есть если здесь вести буковки, то я сначала спускаюсь от V куда-то до W и потом
[54:13.140 --> 54:19.860]  одним прыжком прыгаю до U. Вот. Из всех таких вот прыжков с помощью одного обратного ребра нужно
[54:19.860 --> 54:27.300]  взять самый высокий, то есть U с минимальным TIN. Поэтому я здесь беру минимум по TIN. Так,
[54:27.300 --> 54:36.060]  вот это согласуется с тем, что я описал словами? Хорошо. Представьте, что мы это как-то насчитали.
[54:36.060 --> 54:43.500]  То есть в каком-то смысле я знаю, как высоко я могу из каждого под дерево прыгнуть. Вот если
[54:43.500 --> 54:47.900]  у меня есть V, то из всего, что вот как бы ниже, да, из всего, что достижено под ревесным ребром,
[54:47.900 --> 54:52.220]  я знаю, как высоко я могу прыгнуть, используя один прыжок назад, то есть используя одно
[54:52.220 --> 55:02.060]  обратное ребро вверх. Значит тогда, простое утверждение следующее. Ребро E является мостом,
[55:02.060 --> 55:13.540]  если и только если, во-первых, оно древесное, то есть это ребро, который мы прошли в DFS. То есть
[55:13.540 --> 55:20.500]  какое-то ребро сверху вниз, ну давайте я его назову там УВ, ВТУ. То есть вот такое вот ребро
[55:20.500 --> 55:31.500]  должно быть. И во-вторых, должно быть одновременно выполнено, что вот отсюда я не могу прыгнуть выше,
[55:31.500 --> 55:50.100]  чем ТУ. Это можно написать так. Ред от ТУ равно ТИ на ТУ. Вот, то есть на картинке, если у меня есть
[55:50.100 --> 55:55.540]  древесное ребро из ВТУ, проверить то, что оно является мостом, можно так. Надо посмотреть на все
[55:55.540 --> 56:00.380]  вот это вот под дерево, то есть все, что достижено из ТУ, и надо понять, что отсюда нельзя прыгнуть
[56:00.380 --> 56:07.100]  выше, чем до ТУ. Потому что ред от ТУ это самый высокий прыжок, самый высокий прыжок вверх. И
[56:07.100 --> 56:11.060]  получается, что, смотрите, я могу допрыгнуть до ТУ, то есть, ну, например, там как-нибудь вот так вот,
[56:11.060 --> 56:16.780]  но выше не могу. Это значит, нет ни одного ребра ни сюда, ни куда-то еще выше. То есть вот таких
[56:16.780 --> 56:21.580]  ребер нету. Ну тогда автоматически, значит, удаление этого ребра это мост. Ну, точнее, удаление
[56:21.580 --> 56:28.300]  ребра делает граф несвязан. Собственно, я практически все проговорил, давайте немножечко напишем
[56:28.300 --> 56:50.340]  здесь. Доказать. Ну что, слева направо. Значит, во-первых, очевидно оно древесное,
[56:50.340 --> 56:55.580]  недревесные ребра мостами быть не могут, потому что если ребро недревесное, значит его ДФС,
[56:55.580 --> 57:00.620]  ну, как будто бы не увидел. То есть он шел сверху вниз. Все, что он достиг, он достиг с помощью древесных
[57:00.620 --> 57:06.260]  ребер, те, которые ориентировал сверху вниз. А обратные ребра, они как бы, ну, они с связанности
[57:06.260 --> 57:11.300]  не помогали. Они это какие-то ребра снизу вверх. Понятно тогда, что это ребро мостом быть не может,
[57:11.300 --> 57:15.660]  потому что его удаление на связанность никак не влияет. Мы его что-то раньше не видели в ДФС,
[57:15.660 --> 57:21.260]  что теперь не будем видеть. Поэтому как бы недревесным оно быть не может. Чтобы быть мостом,
[57:21.260 --> 57:29.860]  оно обязано было быть просмотрено в ДФС. Значит, очевидно, иначе граф останется связанным
[57:29.860 --> 57:47.660]  под ревесным ребром. Так, второе. Значит, почему верно вот то вот равенство. Ну, что значит,
[57:47.660 --> 57:55.820]  что ВТУ это мост. Это значит, что после его удаления у меня пропадает путь между ВТУ. То есть
[57:55.820 --> 58:00.220]  раньше у меня был между ними путь, между ВТУ у меня есть ребро. А теперь после удаления оно
[58:00.220 --> 58:04.460]  должно пропасть. Ну, потому что если путь между ВТУ сохранится, то значит и вся связанность
[58:04.460 --> 58:08.940]  сохранится. Если как бы я удалил ребро между вершинами и между ними остался какой-то путь
[58:08.940 --> 58:13.900]  вот такой, то очевидно связанность у тебя все как бы сохранилась. У меня связанность тогда,
[58:13.900 --> 58:18.220]  получается, сохраняется вся. Значит, у меня должен пропасть путь из ВТУ. То есть если я
[58:18.220 --> 58:23.700]  нарисую вот это вот под дерево ТУ, то есть то, что достижено из ТУ под ревесным ребром и все
[58:23.700 --> 58:29.180]  остальное, все, что находится выше, у меня между ними не должно быть никаких ребер. Ну, то есть,
[58:29.180 --> 58:33.740]  соответственно, вот из этого под дерево нет ни одного вот такого вот ребра в ВТУ или куда-то
[58:33.740 --> 58:38.060]  выше. То есть таких обратных ребер нету. Значит, все обратные ребра, которые здесь есть, они либо
[58:38.060 --> 58:45.100]  сюда вот ведут, либо еще вообще куда-то ниже. Поэтому самый высокий прыжок, доступный из этого
[58:45.100 --> 58:58.540]  под дерево, он ведет в сущность в ТУ. Потому что иначе у меня была бы связанность. Вот,
[58:58.540 --> 59:05.340]  значит, в одну сторону. Ну, в обратную как бы все аналогично. Значит, если у меня есть древесное
[59:05.340 --> 59:16.860]  ребро вот с этим вот равенством. Ну, давайте просто перерисую. Надо еще что-то говорить. Нет,
[59:16.860 --> 59:26.940]  вроде уже все и так сказал. Ну, собственно, да, единственный способ, как у меня может сохраниться
[59:26.940 --> 59:31.420]  связанность после удаления этого ребра, это только что из вот этого под дерево я должен как-то
[59:31.420 --> 59:36.020]  прыгнуть вот сюда. То есть должно быть вот такое какое-то ребро. Ну, мы знаем, что такое ребро это
[59:36.020 --> 59:41.620]  ребро из под дерева ТУ куда-то вверх. Значит, это обязательно ребро, которое я должен просмотреть при
[59:41.620 --> 59:46.060]  вот этом определении ред. И у него ТИН обязательно должен быть меньше, потому что такое ребро обязательно
[59:46.060 --> 59:53.020]  ведет куда-то на самом деле в предка. То есть, ну, от корня, откуда мы запустились, то есть это ребро
[59:53.020 --> 01:00:00.260]  куда-то вот до сюда. Оно ведет в одного из предков вершины ТУ. Ну, а поскольку самый высокий прыжок
[01:00:00.260 --> 01:00:07.020]  доступный это только в ТУ, то значит в ТУ это обязательно мост. Ну, потому что вот этой вот
[01:00:07.020 --> 01:00:13.660]  связанности мы никак уже не обеспечим. Ну, короче, то же самое сказал. Тут вопрос есть по корректности
[01:00:13.660 --> 01:00:24.420]  вот этого критерия? Хорошо. Так, это с мостами. Теперь давайте точку слинения сначала тоже критерий
[01:00:24.420 --> 01:00:49.620]  выведем и потом напишем, как именно этот ред насчитывать. Вершина В является точкой слинии,
[01:00:49.620 --> 01:01:02.100]  если верно, одной из двух. Либо В это корень, то есть мы из него запускали внешний ДФС. В это корень,
[01:01:02.100 --> 01:01:16.980]  и при этом из В есть хотя бы два древесных ребра. Из В исходит хотя бы два древесных ребра.
[01:01:20.580 --> 01:01:38.140]  Либо же второй вариант В не корень, но есть какое-то древесное ребро из В в ТУ. Но есть древесное
[01:01:38.140 --> 01:02:01.020]  ребро из В в ТУ такое, что ред от ТУ больше либо равно ТИ на ТВ. То есть самое высокое,
[01:02:01.020 --> 01:02:05.900]  куда мы можем прыгнуть из этого поддерева, это только ТУ. Ну, или даже, возможно, sorry,
[01:02:05.900 --> 01:02:13.220]  это только В или даже, возможно, ТУ. То есть самое высокое, куда я могу прыгнуть из этого поддерева,
[01:02:13.220 --> 01:02:28.180]  это В или даже ниже. Тогда В это точка слининия. Так, ну, я, наверное, докажу, что, не буду доказывать
[01:02:28.180 --> 01:02:35.060]  такую эквивалентность, я докажу, что первое, докажу, что если В это корень, то факт того,
[01:02:35.060 --> 01:02:39.300]  что это точка слининия равносильна тому, что есть два древесных сходящих ребра. Ну, по факту это
[01:02:39.300 --> 01:02:47.300]  пункт 1. Вот, смотрите, пусть В это корень, то есть это вершина, из которой запускается внешний
[01:02:47.300 --> 01:02:53.340]  ДФС. Вот мы из мейна или из какой-то решающей функции запускаем ДФС от вершинки В, под стартовой
[01:02:53.340 --> 01:02:58.820]  вершинке. Она все обходит, да, как-нибудь там еще насчитала вот эти вот реты, все таины. И
[01:02:58.820 --> 01:03:04.820]  так оказалось, что вот у В есть несколько исходящих древесных ребер. Либо одно, либо хотя бы два.
[01:03:04.820 --> 01:03:11.620]  Несколько. Ну, если ноль, то неинтересно. Это тогда просто изолированная вершина. Вот понятно,
[01:03:11.620 --> 01:03:16.020]  что если одно ребро исходящее, то получается, что я взял в самом начале, нашел какое-то ребро,
[01:03:16.020 --> 01:03:23.020]  запустил рекурсивно ДФСом отсюда и обошел вообще все. Я обошел вообще все достижимые
[01:03:23.020 --> 01:03:27.900]  вершины, потому что иначе, если было бы что-то недостижимое, то вот здесь что-то было бы
[01:03:27.900 --> 01:03:34.500]  недостижимое, я должен был туда прыгнуть бы из В. Но таких ребер нет. То есть если у меня одно
[01:03:34.500 --> 01:03:41.620]  исходящее ребро, то получается я взял, с его помощью дошел до куда-то, и из конца этого ребра дошел до
[01:03:41.620 --> 01:03:46.060]  всех остальных вершин. Значит В, понятное дело, не точка соширения, потому что вот я ее удаляю,
[01:03:46.060 --> 01:03:55.980]  граф остается связанным, вот здесь все связанности сохраняются. Если у В всего одно исходящее древесное
[01:03:55.980 --> 01:04:14.500]  ребро, то В это не точка соширения. А если хотя бы два исходящих ребра, то это уже гарантирована
[01:04:14.500 --> 01:04:19.620]  точка соширения, потому что как может быть из корня два исходящих ребра. Вот я вот здесь начинаю,
[01:04:19.620 --> 01:04:26.580]  как работает ДФС. Он посещает все, что можно. Лемма в белых путях, туда-сюда. Все, что было
[01:04:26.580 --> 01:04:31.780]  достижимо по белым путям, все достижимо. То есть если все достигнется, если я спускаюсь по ребру
[01:04:31.780 --> 01:04:39.060]  и потом здесь обхожу все, что достижимо, а потом мне нужно подняться и еще что-то обойти, значит
[01:04:39.060 --> 01:04:46.220]  вот отсюда до сюда я никак не пройду без В. То есть я спустился по первому ребру, здесь обошел все,
[01:04:46.220 --> 01:04:51.940]  что можно, но что-то не обошел. Отсюда до сюда никак без В я не попаду. Вот таких ребер у меня нету.
[01:04:51.940 --> 01:04:57.540]  Таких ребер нету. Ну значит получается В автоматически точка соширения, потому что после ее удаления
[01:04:57.540 --> 01:05:10.700]  между этими вот вершинками нет пути. Наоборот, если у В хотя бы два исходящих древесных ребра,
[01:05:10.700 --> 01:05:27.300]  то В это точка соширения. Мы с корнем разобрались. Какие ребра мы назначили древесными? То есть мы
[01:05:27.300 --> 01:05:31.460]  знаем, какие ребра мы назначили древесными, значит мы можем понять корень является точка соширения.
[01:05:31.460 --> 01:05:39.580]  Так, ну теперь второй кейс, когда В это не корень.
[01:05:39.580 --> 01:06:01.060]  Это пункт два. Раз В не корень, значит у него есть родитель в нашем дереве ДФС. Вот есть В,
[01:06:01.060 --> 01:06:07.460]  есть вершина, из которой мы непосредственно в В пришли. То есть вот есть какой-то родитель
[01:06:07.460 --> 01:06:13.700]  П такой, что П В это древесное ребро. То есть я сначала от корня дошел до П, потом из П
[01:06:13.700 --> 01:06:20.460]  рекурсивно запустился в В. На вот есть такое ребро. Дальше, значит у меня надо сказать,
[01:06:20.460 --> 01:06:28.580]  что В это точка соширения есть ли есть какое-то такое ребро. Ну хорошо, надо рассмотреть два
[01:06:28.580 --> 01:06:33.140]  случая. Когда есть такое ребро исходящее, вот совсем неравенство, и когда такого нет. Вот видите,
[01:06:33.140 --> 01:06:39.060]  первый случай, когда такое ребро есть. Вот пусть есть какое-то древесное ребро в ВТУ. Такое,
[01:06:39.060 --> 01:06:48.860]  что ред от ТУ больше равно ТИ на ТВ. Ну тогда вроде понятно, что В это точка соширения,
[01:06:48.860 --> 01:06:56.260]  потому что после ее удаления у меня пропадает путь между ТУ и П. Потому что вот что, что
[01:06:56.260 --> 01:07:01.380]  означает это неравенство? Это значит, что из всего вот этого поддерева, то есть из всей вот этой вот
[01:07:01.540 --> 01:07:06.980]  компонентно-связанности после удаления В, я не могу прыгнуть никуда кроме как сюда или сюда. То
[01:07:06.980 --> 01:07:11.800]  есть по факту все обратные ребра из вот этого поддерева вели либо В, либо вообще оставались
[01:07:11.800 --> 01:07:15.700]  внутри этого поддерева. Вот это вот неравенство означает, что не куда выше, чем В я прыгнуть не
[01:07:15.700 --> 01:07:22.900]  могу. Самое высокое это только В или даже ниже. Ну значит, после удаления В у меня вот это все
[01:07:22.900 --> 01:07:28.460]  поддерево остается компонентно-связанности, из которой я никуда перепрыгнуть уже не могу. То есть
[01:07:28.460 --> 01:07:32.460]  не сюда не могу да потому что если было такое ребро у меня было бы здесь неравенство меньше
[01:07:32.460 --> 01:07:36.820]  ну и так далее короче я из этого по дереву никуда не выберусь поэтому в этом случае обязательно в
[01:07:36.820 --> 01:07:53.980]  эту точку сшли так как пропадает путь между ту и п пропадает путь тупая вот значит это
[01:07:54.120 --> 01:08:00.780]  да существует pega с таким не равенствует существует и такими раменстве теперь второй
[01:08:00.780 --> 01:08:07.900]  случае когда его не существует надо задать тогда в не точка сшли но вот что за что не существует
[01:08:07.900 --> 01:08:15.020]  значит для любого ту для любого сына у меня это мер avons что выполняется в обратную сторону то
[01:08:15.020 --> 01:08:22.440]  есть если вот это вот скажем ну давайте ихemás 1 у 2 и так далее ука для них для всех RED от Уит Halloween
[01:08:22.440 --> 01:08:35.640]  строго меньше, чем tn от v. Надо тогда показать, что удаление v не нарушает связности. Вот. Ну,
[01:08:35.640 --> 01:08:46.160]  чего? Удаление v не нарушает связанности. Что означает вот это неравенство? Это значит,
[01:08:46.160 --> 01:08:52.760]  что из любого поддерева, у 1, у 2 и так далее, у к, из всех поддеревьев есть обратное ребро,
[01:08:52.760 --> 01:08:58.440]  ведучие в p или выше. Потому что раз ред строго меньше, чем tn от v, значит мы можем прыгнуть
[01:08:58.440 --> 01:09:03.560]  куда-то выше, чем v. Строго меньше, значит мы можем прыгнуть строго выше. То есть всегда есть
[01:09:03.560 --> 01:09:09.120]  обратное ребро куда-то сюда или даже еще выше, куда-нибудь выше. Тогда после удаления v,
[01:09:09.120 --> 01:09:14.880]  давайте представим, что я v удаляю, я удалил v и все вот эти вот ребра. Ну, тогда связанность у
[01:09:14.880 --> 01:09:20.160]  меня хранилась, потому что из каждого поддерева я могу прыгнуть куда-то высоко, ну и потом,
[01:09:20.160 --> 01:09:24.760]  если надо. Например, может быть такое, что у меня вот есть такой длинный путь и у меня есть вот
[01:09:24.760 --> 01:09:29.320]  такое вот обратное ребро, вот такое обратное ребро. Тогда я могу из этого поддетего сначала
[01:09:29.320 --> 01:09:34.320]  прыгнуть сюда высоко, потом дойти до p. Получается, что я сохранил связанность между этим поддеревом
[01:09:34.320 --> 01:09:38.960]  и вершинкой p. Ну тоже самое для всех остальных поддеревьев, есть какой-то прыжок достаточно
[01:09:38.960 --> 01:09:44.040]  высоко, и потом, если что, его можно спуститься до p, тем самым сохраняется связанность любого
[01:09:44.040 --> 01:09:49.080]  под дерево и p. А если все связанности сохранились, то значит у меня связанности не исчезло.
[01:09:49.080 --> 01:10:05.200]  Поэтому в этом случае v не точек осуществления. Согласны? Ну все, значит мы вывели критерий в
[01:10:05.200 --> 01:10:12.600]  терминах этого red. Осталось написать алгоритм, который все эти red насчитает, и тогда я уже все
[01:10:12.600 --> 01:10:18.800]  ребра умею проверять, на то являются они мостами или нет, и все вершины, на то являются они точкой
[01:10:18.800 --> 01:10:38.320]  насчления или нет. Так, давайте его сделаем быстренько. Алгоритм нахождения red.
[01:10:38.320 --> 01:11:02.920]  Алгоритм нахождения red. Он очень простой и устроен следующим образом. Смотрите,
[01:11:02.920 --> 01:11:10.320]  у меня из каждой вершины, когда я попадаю в вершинку v, интересных ребер всего две
[01:11:10.320 --> 01:11:17.000]  категории. Это либо древесные ребра, которые мы с помощью DFS проходим сверху вниз, и обратные
[01:11:17.000 --> 01:11:27.160]  ребра, ведущие куда-то наверх. Значит куда-нибудь в u. Тогда как достигается red от u? Я утверждаю,
[01:11:27.160 --> 01:11:31.480]  что это надо либо сразу прыгнуть по обратному ребру, то есть даже никуда вниз не спускаться.
[01:11:31.880 --> 01:11:38.640]  Я сейчас хочу найти red от v. Тогда это либо мне нужно сразу прыгнуть наверх по обратному ребру,
[01:11:38.640 --> 01:11:42.960]  никуда вниз не спускаясь, просто вижу обратно и сразу прыгаю по нему. Это один из возможных
[01:11:42.960 --> 01:11:50.020]  способов. Либо мне нужно сначала куда-то спуститься в одно из поддеревьев и в нем прыгнуть наверх. То
[01:11:50.020 --> 01:11:54.640]  есть я сначала куда-то спускаюсь и там беру red от, собственно, вот этой вершинки. Потому что,
[01:11:54.640 --> 01:11:59.040]  если я хочу сначала куда-то спуститься, я выбираю, в какой из поддеревьев я спускаюсь,
[01:11:59.040 --> 01:12:04.600]  например, вот сюда. И если я здесь знаю уже корректное значение red от u, то я, получается,
[01:12:04.600 --> 01:12:08.640]  знаю, насколько высоко я могу прыгнуть из всего этого поддерева. То есть я знаю какой-то такой
[01:12:08.640 --> 01:12:13.920]  прыжок. Может куда-то еще выше ведет. Поэтому мне нужно просто все вот эти вот red'ы просмотреть
[01:12:13.920 --> 01:12:20.520]  и выбрать из них самый высокий, самый маленький. Из всех вот этих red'ов, которые я уже посчитал,
[01:12:21.080 --> 01:12:30.000]  рекурсивно, нужно выбрать просто самый маленький. Ну, собственно, все. Просто все прыжки я таким
[01:12:30.000 --> 01:12:33.880]  образом рассмотрю, потому что они либо сразу вверх, либо сначала в какое-то поддерево спускаются и
[01:12:33.880 --> 01:12:44.800]  оттуда уже прыгут вверх, используя вот этот уже найденный red. Давайте я напишу то, что мне нужно.
[01:12:44.800 --> 01:12:50.760]  Ну, я какие-то строчки опускаю, то есть там я юст опущу, я напишу только самое интересное.
[01:12:50.760 --> 01:13:00.040]  Во-первых, мне, конечно, нужен tein, потому что я по нему определяю, какая вершинка выше,
[01:13:00.040 --> 01:13:04.240]  какая вершинка ниже. Изначально я говорю, что red от v это tein от v,
[01:13:04.240 --> 01:13:16.120]  потому что можно стоять на месте, и это уже какой-то прыжок вверх. Дальше перебираем все вершины.
[01:13:16.120 --> 01:13:28.920]  И, значит, если я вижу прямое древесное ребро, если вижу древесное ребро, давайте я словами напишу,
[01:13:29.000 --> 01:13:44.920]  если v2 это древесное ребро. Ну, в коде это означает, что не юст ату, не юст ату, потому что как раз
[01:13:44.920 --> 01:13:50.720]  древесное это то, которое ведет в непосещенную вершинку, то есть там как раз-таки, где юст
[01:13:50.720 --> 01:13:56.320]  еще стоит false. Вот, значит, если я вижу древесное ребро, то я сначала запускаюсь,
[01:13:56.320 --> 01:14:06.440]  давайте я вот так вот хотя бы сделаю, то я сначала запускаюсь рекурсивным dfs,
[01:14:06.440 --> 01:14:15.400]  и потом мой red обновляю через вот этот red. red от v равно минимум из red от v и red от tu.
[01:14:15.400 --> 01:14:24.480]  Это вот этот случай, что я сначала использую древесное ребро, там рекурсивно, то есть я
[01:14:24.480 --> 01:14:29.440]  считаю, что рекурсивный запуск dfs от tu мне рекурсивно правильно нашел red от tu, и после
[01:14:29.440 --> 01:14:41.280]  этого я red от v обновляю через red от tu. Вот, но иначе, если же я вижу обратное ребро, обратное
[01:14:41.280 --> 01:14:50.480]  ребро вверх, то есть как раз вот такое, что я из v могу сразу прыгнуть наверх, тогда нужно
[01:14:50.480 --> 01:15:07.520]  просто обновить red от v через tu и tu. red от v, минимум из red от v и tu и tu. Все.
[01:15:07.520 --> 01:15:28.160]  Да, секунду. Правильное замечание, да. Ну, потому что в каком-то смысле вот это вот ребро родителя,
[01:15:28.160 --> 01:15:38.240]  это обратное древесное ребро. Можно по-разному это сделать. Ну, давайте вот здесь вот подпишу,
[01:15:38.240 --> 01:15:47.560]  не в родителя, обратное ребро вверх, не в родителя. То есть это как бы в плане реализации
[01:15:47.560 --> 01:15:54.120]  я подчеркиваю, в плане описания вот это вот ребро, которое я вижу, то есть если я прошел по
[01:15:54.120 --> 01:15:58.720]  древесному ребру сверху вниз, в этой вершинке я в частности тоже вижу вот это вот ребро,
[01:15:58.720 --> 01:16:05.520]  которое меня ведет в родителя. Я это ребро всегда-всегда игнорирую, потому что это типа обратное
[01:16:05.520 --> 01:16:10.200]  древесное ребро. То есть я это ребро уже ориентировал как бы сверху вниз, понятно, что снизу вверх я
[01:16:10.200 --> 01:16:15.440]  по нему пройти уже не могу. Но с точки зрения кода мы же на самом деле не вводим ориентацию на
[01:16:15.440 --> 01:16:21.320]  ребрах, мы там не удаляем вот это вот обратное ребро снизу вверх, то есть отсюда сюда. Но как бы надо
[01:16:21.320 --> 01:16:27.000]  проследить, что если я вижу ребро в родителя, то я его просто игнорирую, потому что ребро в родителя
[01:16:27.000 --> 01:16:31.640]  это то ребро, с помощью которого я только что пришел. Его нужно вообще игнорировать, оно ни на что
[01:16:31.640 --> 01:16:36.920]  не влияет. То есть вот можно было бы вот здесь вот написать, что если ту это родитель в,
[01:16:36.920 --> 01:16:48.120]  то просто continue. Вот, тогда жизнь была бы проще, потому что такие ребра я уже сразу отсек. И дальше
[01:16:48.120 --> 01:16:53.400]  как раз остается только древесное сверху вниз, либо обратное, но опять повторюсь, обратное у меня
[01:16:53.400 --> 01:17:00.480]  бывают вверх и вниз, потому что находясь скажем где-нибудь вот здесь, я мог бы его увидеть вверх,
[01:17:00.480 --> 01:17:06.280]  а находясь здесь я его увижу вниз. Ну как бы можно вести, можно добавить это условие, что я
[01:17:06.280 --> 01:17:10.800]  рассматриваю только обратный вверх, потому что если нахожусь здесь и вижу вот это вот обратное
[01:17:10.800 --> 01:17:16.280]  ребро вниз, то оно на самом деле ни на что не повлияет. Здесь и так будет ред меньше, чем здесь.
[01:17:16.280 --> 01:17:21.840]  То есть это можно не проверять, но как бы для красоты лучше вот такие вот ребра сверху вниз вообще
[01:17:21.840 --> 01:17:32.320]  тоже не смотреть. Обратный сверху вниз мы тоже пропускаем. Так, ну все. Значит мы с вами все реды
[01:17:32.320 --> 01:17:37.240]  насчитали, мы с вами знаем, мы ориентировали как бы все ребра, мы знаем кто из них древесный и кто
[01:17:37.240 --> 01:17:41.960]  нет. И дальше просто вот есть два критерия, с их помощью можно проверять ребра на мосты и точке
[01:17:41.960 --> 01:17:46.000]  слинии и вершины на точке слинии. Вот так все, спасибо.
