[00:00.000 --> 00:15.740]  Давайте начинать. Извините меня немножко задержали. Сегодня у нас ключевая лекция про
[00:15.740 --> 00:39.420]  неразрешимые задачи. У нас есть теория, в которой мы докажем, что существует множество,
[00:39.420 --> 00:57.500]  которое перечислимо, но неразрешимо. Теорема, что существует перечислимое, но неразрешимое множество.
[00:57.500 --> 01:07.660]  Ну и в отличие от теоремы, что существует просто неразрешимое множество, здесь мы не можем
[01:07.660 --> 01:15.940]  пользоваться соображением мощности. Просто потому, что и перечислимых, и разрешимых множество в счетное
[01:15.940 --> 01:22.820]  число, то есть их одинаковое количество, ну и вообще нельзя из соображения количества сказать,
[01:22.820 --> 01:32.900]  что есть множество, которое одно, но не другое. Но, тем не менее, перечислимое, но неразрешимое
[01:32.900 --> 01:45.340]  множество существует, и довольно много. И сейчас мы обсудим, откуда они берутся.
[01:45.340 --> 02:00.340]  Значит, мы будем работать с двумя ключевыми примерами. Одно множество я назову S.
[02:00.340 --> 02:19.180]  Значит, S это множество... Сейчас, дайте я лучше словами пока напишу. Это множество машин тюринга,
[02:19.180 --> 02:31.700]  которые останавливаются на, ну можно сказать, собственном тексте или собственном номере,
[02:31.700 --> 02:44.860]  на собственном коде. Ну дайте я напишу на собственном номере. Значит, что имеется в виду?
[02:44.860 --> 02:52.380]  Ну я сведу, что любую машину тюринга можно представить как некоторый картеж, записать,
[02:52.380 --> 02:59.300]  закодировать как некоторые тексты, а после этого можно этот текст перекодировать в число. И можно
[02:59.300 --> 03:05.820]  спрашивать, вот эта машина на этом числе будет останавливаться или не будет. Ну или, может быть,
[03:05.820 --> 03:12.700]  эта машина работает, собственно, с текстами, тогда можно спрашивать работы, останавливается ли она
[03:12.700 --> 03:29.260]  на собственном тексте. Вот. Ну я только что объяснил. Да-да, мы как-то взяли и занумировали.
[03:29.260 --> 03:38.460]  Как именно, это не очень важно. Давайте я напишу разные варианты, значит, на тексте, коде и так далее.
[03:38.460 --> 03:45.180]  Каким-то образом мы перекодировали машину тюринга так, что ее можно ей самой подать на вход.
[03:45.180 --> 03:55.020]  Так, ну а, соответственно, h. Да, и это называется проблемой самопременимости. Давайте я тут напишу.
[03:55.020 --> 04:15.740]  Значит, S это проблема самопременимости. А h, это от слова halting, значит, это проблема остановки.
[04:15.740 --> 04:22.900]  Вот. Ну или есть такой более традиционный термин останов.
[04:22.900 --> 04:40.540]  Вот. Соответственно, h это множество пар, соответственно, машины тюринга и вход.
[04:40.540 --> 04:48.780]  Таких, что эта машина останавливается на этом входе.
[04:48.780 --> 04:59.820]  Эта машина останавливается на этом входе.
[04:59.820 --> 05:11.260]  Вот. Ну и тут, на самом деле, видно, что S это такой частный случай h.
[05:11.260 --> 05:23.660]  Да, то есть тут в h у нас вход произвольный, а в S у нас вход вполне конкретный, который равняется номеру или тексту машины.
[05:23.660 --> 05:38.460]  Ну и, на самом деле, ясно, мы будем доказывать, что S неразрешимо. Ну и тогда, как следствие, h тоже будет неразрешимо.
[05:38.460 --> 05:44.700]  Потому что такое вообще S? Ну, можно сказать, что S это пересечение h с диагональю.
[05:44.700 --> 05:49.100]  То есть диагональ, когда вход, это то же самое, что машина тюринга.
[05:50.060 --> 05:54.700]  Вот. Ну и диагональ, само в себе, ясное дело, разрешимая множество.
[05:54.700 --> 06:00.140]  Поэтому, если бы h было разрешимо, то S тоже было бы разрешимо, как пересечение двух разрешимых.
[06:00.140 --> 06:12.940]  Да, то есть вот можно, я тут напишу, что у нас S, это будет h пересечение с диагональю.
[06:13.740 --> 06:30.860]  Значит, это, да, это диагональное множество. Значит, множество пар x, x.
[06:31.740 --> 06:48.780]  Вот. Ну и поскольку, соответственно, если бы h было бы разрешимым, то тогда и S разрешимо, так как D разрешимо.
[06:49.660 --> 06:52.460]  Ну, а мы докажем, что S неразрешимо.
[06:52.460 --> 07:09.660]  Значит, мы докажем, что S неразрешимо, ну и, следовательно, h тоже неразрешимо.
[07:10.540 --> 07:20.540]  Вот. При этом h перечислимо.
[07:21.420 --> 07:39.420]  Вот. При этом h перечислимо, как область определения вычислимой функции.
[07:40.300 --> 07:52.300]  А что это за вычислимая функция? Ну, дайте я верну сюда. Что такое h?
[07:52.300 --> 07:58.300]  Значит, h это множество пар, машина, тюринг и вход. Такая, что машина останавливается на этом входе.
[07:58.300 --> 08:00.300]  Но вот эта функция, это будет просто такой компилятор.
[08:00.300 --> 08:04.300]  Да, мы про это немножко говорили в конце поза прошлой лекции.
[08:05.180 --> 08:09.180]  То это как раз машина, которая получает код другой машины и вход,
[08:09.180 --> 08:13.180]  и моделирует работу той и другой машины на этом входе.
[08:13.180 --> 08:17.180]  Ну и, соответственно, она тот же самый выход и возвращает.
[08:21.180 --> 08:25.180]  Вот. Соответственно, эта универсальная вычислимая функция,
[08:26.060 --> 08:34.060]  у которой h область определения, это есть универсальная вычислимая функция.
[08:44.060 --> 08:48.060]  Ну и вот про то, что это за объект и как он связан с универсальной машиной тюринга,
[08:48.060 --> 08:52.060]  я как раз сейчас немножко поговорил подробнее.
[08:52.940 --> 08:58.940]  Так, нет ли каких-нибудь вопросов по рассказанному?
[09:04.940 --> 09:06.940]  Нет, h будет неразрешимо.
[09:10.940 --> 09:14.940]  Нет, если h разрешимо, то тогда s разрешимо.
[09:14.940 --> 09:18.940]  Потому что d разрешимо, и тогда s будет причислением двух разрешимых множеств.
[09:19.820 --> 09:25.820]  Вот. Но мы докажем, что вот это неверно, значит, по контрпозиции это неверно.
[09:25.820 --> 09:29.820]  С другой стороны, h перечислимо, каково у нас это определение?
[09:29.820 --> 09:33.820]  Вот у нас получается пример. Да, давайте я этот вывод запишу.
[09:33.820 --> 09:41.820]  То есть h перечислимо, но неразрешимо.
[09:41.820 --> 09:45.820]  Значит, это общая схема доказательства.
[09:46.700 --> 09:52.700]  Значит, перечислимо, каково это определение училимой функции.
[09:52.700 --> 09:56.700]  Неразрешимо, потому что мы сейчас докажем, почему.
[10:02.700 --> 10:06.700]  Значит, вот такая общая схема.
[10:06.700 --> 10:10.700]  Теперь подробнее поговорим про универсальную училимую функцию.
[10:11.580 --> 10:17.580]  Значит, вообще говоря, можно действовать с двух сторон.
[10:17.580 --> 10:21.580]  Значит, можно действовать с стороны машин тюринга.
[10:21.580 --> 10:25.580]  И это то, что было в самом конце позапрошлой лекции.
[10:25.580 --> 10:29.580]  Что мы построим универсальную машину тюринга,
[10:29.580 --> 10:35.580]  которая как раз получает код машины, вход и эмулирует эту машину.
[10:35.580 --> 10:39.580]  Вот я в чате присылал несколько эмуляторов.
[10:40.460 --> 10:44.460]  Можно это теремам доказывать, а можно сослаться на тезис Чорча.
[10:44.460 --> 10:48.460]  Тезис Чорча говорит, что всё, что можно запрограммировать
[10:48.460 --> 10:52.460]  на реальной машине, можно и на машине тюринга.
[10:52.460 --> 10:55.460]  Соответственно, можно же машину тюринга запрограммировать.
[10:55.460 --> 10:59.460]  Значит, нам, на машине тюринга, можно машину тюринга запрограммировать.
[10:59.460 --> 11:04.460]  И это, конечно, это не доказательство.
[11:04.460 --> 11:08.460]  Доказательство, это предъявление машины тюринга,
[11:08.460 --> 11:15.060]  что нужно. Так, вот, значит, можно вот с этой стороны идти, что мы прямо делаем
[11:15.060 --> 11:19.460]  универсальную машину и говорим, что универсальная функция это то, что вычисляет
[11:19.460 --> 11:25.340]  универсальная машина. А можно пойти с другой стороны, можно определить
[11:25.340 --> 11:30.100]  универсальную учителем и функции непосредственно, что я сейчас и сделаю.
[11:30.100 --> 11:42.100]  Так, значит, универсальная вычислимая функция. Значит, это у нас функция двух
[11:42.100 --> 11:48.100]  аргументов. Ну, опять же, можешь считать, что у нас аргументы это конечные слова,
[11:48.100 --> 11:55.100]  можешь считать, что аргументы это натуральные числа. Ну, давайте я для конечных слов напишу.
[11:55.100 --> 12:06.100]  Значит, вот у нас функция получает два слова и возвращает одно слово. Вот, на нее два условия
[12:06.100 --> 12:15.100]  накладываются. Значит, во-первых, сама по себе U должна быть вычислима как функция двух аргументов.
[12:15.100 --> 12:34.100]  Значит, U вычислима как функция двух аргументов. Ну, а это уже непосредственно определяется,
[12:34.100 --> 12:39.100]  либо через двухленточную машину, либо через запись через пробел, либо через кодирование пар.
[12:39.100 --> 12:44.100]  В общем, так или иначе вычислимую функцию двух аргументов можно определить.
[12:44.100 --> 12:58.100]  Так, и второе. Значит, для любой F функции одного аргумента вычислимой.
[12:58.100 --> 13:17.100]  Значит, для любой вычислимой функции одного аргумента существует такое P, что для любого x U под Px равно F от x.
[13:17.100 --> 13:26.100]  Вот, значит, можно... Как это все смотреть? Можно считать, что U это такой компилятор.
[13:26.100 --> 13:35.100]  Значит, U это компилятор, и первый аргумент U это программа, а второй аргумент U это аргумент уже этой программы.
[13:35.100 --> 13:41.100]  Вот, а компилятор должен эту программу скомпилировать, запустить и вернуть тот же самый результат.
[13:41.100 --> 13:47.100]  Но, соответственно, если не определена, то компилятор тоже будет неопределен.
[13:47.100 --> 13:53.100]  Если определена, то он выдает соответствующее значение.
[13:53.100 --> 13:58.100]  Вот, значит, теперь что говорят наши условия первое и второе?
[13:58.100 --> 14:08.100]  Первое говорит, что сам по себе компилятор вычислимый, что он сам вычисляется на какой-то машине.
[14:08.100 --> 14:18.100]  А второе условие, это условие универсальности, что все, что можно запрограммировать, можно запрограммировать вот на этом языке программирования.
[14:18.100 --> 14:26.100]  То есть для любой вычислимой функции есть программа, которая ровно эту функцию вычисляет.
[14:26.100 --> 14:36.100]  Вот такое вот определение.
[14:36.100 --> 14:54.100]  Ну и дальше для любой нормальной модели вычислений должна быть теорема о том, что такая штука существует.
[14:54.100 --> 15:08.100]  То есть это в принципе не обязательно может быть машина тюринга, это может там машинку другого вида, может быть даже какой-нибудь обычный язык программирования.
[15:08.100 --> 15:13.100]  Но обычный язык программирования очень удобен, потому что математически это очень сложный объект.
[15:13.100 --> 15:21.100]  То есть в любом нормальном языке программирования есть очень много каких-то конструкций синтоксических,
[15:21.100 --> 15:31.100]  и в принципе, чтобы там что-то доказывать, нужно доказывать, что все эти конструкции можно обработать с использованием самих этих конструкций.
[15:31.100 --> 15:37.100]  Ясно, что если у вас там 15 разных конструкций есть, то это уже очень сложно доказывать.
[15:37.100 --> 15:42.100]  В машине тюринг все гораздо проще. В машине тюринг у нас все команды одного и того же вида.
[15:42.100 --> 15:47.100]  Ну, может быть, там налево и направо немножко по-разному обрабатываются.
[15:47.100 --> 15:52.100]  Но глобально тут нет 15 разных конструкций, которые нужно обработать.
[15:52.100 --> 16:00.100]  Но с другой стороны, бывают и другие простые модели.
[16:00.100 --> 16:12.100]  Бывают такие алгорифмы Маркова, есть рекурсивные функции Чорча и так далее.
[16:12.100 --> 16:18.100]  И в принципе для каждой такой модели есть арея осуществования вот такого объекта.
[16:18.100 --> 16:26.100]  Соответственно, вычислимость вот здесь вот и вычислимость вот здесь вот должны пониматься в смысле одной и той же модели вычислений.
[16:26.100 --> 16:32.100]  Ну, в нашем случае в смысле машины тюринга.
[16:32.100 --> 16:38.100]  Так, ну, в общем, давайте я это сформирую как теорему.
[16:38.100 --> 16:50.100]  Значит, теорема, что универсальная вычислимая функция существует.
[16:50.100 --> 17:02.100]  А полностью я не буду доказывать, но один из возможных путей доказательства это вот через универсальную машину тюринга.
[17:02.100 --> 17:24.100]  Идея доказательства может стоять в том, что она вычисляется универсальной машиной тюринга.
[17:24.100 --> 17:40.100]  Ну и тогда если мы докажем существование универсальной машины тюринга, ну, а это технически сложная задача, но концептуально не очень сложная,
[17:40.100 --> 17:48.100]  то тогда вот это уже будет, ну, в общем, и то и другое будет почти очевидно.
[17:48.100 --> 17:58.100]  То есть первое будет, по определению, раз это машина тюринга, хоть и универсальная, значит она вычислимую функцию создает.
[17:58.100 --> 18:04.100]  Ну а второе тоже получается, что если f вычислимо, то она вычисляет какой-то машиной тюринга.
[18:04.100 --> 18:10.100]  И если мы как раз эту машину тюринга, которая вычисляет f, подставим вот сюда, то ровное отравимство и должно быть выполнено.
[18:10.100 --> 18:20.100]  Так, ну хорошо, ну что, убедительно.
[18:20.100 --> 18:34.100]  Ладно, в общем, технические сложности опустим.
[18:34.100 --> 18:42.100]  Значит, теперь, что дальше? Да, дальше, если у нас есть какая-то универсальная вычислимая функция,
[18:42.100 --> 18:52.100]  то мы теперь можем, соответственно, проблемы самоприменимости и остановки записать в ее терминах.
[18:52.100 --> 19:04.100]  То есть теперь мы можем написать, что вот s, значит, проблема самоприменимости, это будет множество таких n, что просто u от n, n определено.
[19:04.100 --> 19:14.100]  А h будет множеством пар n, x, что u от n, x определено.
[19:24.100 --> 19:32.100]  Ну и в принципе другая u задает в принципе другие множества s и h, но теоремы о их неразрешимости универсальные.
[19:32.100 --> 19:42.100]  То есть универсальная.
[19:42.100 --> 19:56.100]  Хорошо, ну давай теперь доказывать. Так, теорема s неразрешима.
[19:56.100 --> 20:04.100]  Так, доказательства.
[20:04.100 --> 20:10.100]  Значит, пусть, пусть, если разрешима.
[20:10.100 --> 20:18.100]  Вообще сейчас будет использован диагональный метод, который у нас уже был,
[20:18.100 --> 20:28.100]  когда мы доказывали несчетность континуума, несчетность бесконечных последовательностей,
[20:28.100 --> 20:34.100]  в чем была идея диагонального метода, что мы берем диагональ и делаем наоборот.
[20:34.100 --> 20:40.100]  Вот сейчас мы тоже так сделаем.
[20:40.100 --> 20:50.100]  Значит, тогда вычислимо характеристическая функция.
[20:50.100 --> 21:08.100]  Хи s от n, который равняется единице, если n принадлежит s, и ноль, если n не принадлежит s.
[21:08.100 --> 21:28.100]  Вот, но тогда вычислимо такая функция.
[21:28.100 --> 21:46.100]  Ну тут можно действовать по-разному.
[21:46.100 --> 21:54.100]  На самом деле это будет полухарактеристическая функция для дополнения к s.
[21:54.100 --> 21:58.100]  Значит, давайте я как-нибудь покороче обозначу.
[21:58.100 --> 22:06.100]  На там h от n, но вообще она будет полухарактеристическая функция для дополнения к s.
[22:07.100 --> 22:17.100]  Значит, это будет неопределено, если n принадлежит s.
[22:17.100 --> 22:27.100]  И, скажем, один, если n не принадлежит s.
[22:27.100 --> 22:37.100]  Тогда для этой h от n можно применить наше условие.
[22:37.100 --> 22:47.100]  Вот это условие мы теперь для h применим.
[22:47.100 --> 22:51.100]  Так, что получим?
[22:51.100 --> 23:05.100]  Получим, что существует такое p, что для любого x у...
[23:05.100 --> 23:11.100]  Давайте для любого n лучше.
[23:11.100 --> 23:15.100]  Чтобы не слишком разные были обозначения.
[23:15.100 --> 23:21.100]  Существует p, что для любого n u от pn равно h от n.
[23:21.100 --> 23:31.100]  Значит, это из универсальности.
[23:31.100 --> 23:43.100]  Ну а теперь подставим n равное p, как раз диагональ.
[23:43.100 --> 23:55.100]  Тогда получим, что h от p равно u от pn.
[23:55.100 --> 24:03.100]  Так, ну теперь сейчас будет спротиворечие.
[24:03.100 --> 24:21.100]  Теперь получается, что если p принадлежит s, то тогда u от pn у нас определено, а h от p не определено.
[24:21.100 --> 24:31.100]  Потому что в точности s это множество тех, где u от p определено с одной стороны.
[24:31.100 --> 24:35.100]  А с другой стороны у нас вот здесь было определение, что h...
[24:35.100 --> 24:41.100]  Значит, если p лежит в s, то h от p должно быть не определено.
[24:41.100 --> 24:45.100]  Это получается противоречие.
[24:45.100 --> 24:49.100]  Если p не принадлежит s, то... Аналогичное противоречие.
[24:49.100 --> 24:57.100]  Значит, если p не принадлежит s, то тогда u от p не определено.
[24:57.100 --> 25:01.100]  Потому что s мы так определяли.
[25:01.100 --> 25:07.100]  А h от p равно 1.
[25:07.100 --> 25:13.100]  Ну и в любом случае равенство невозможно.
[25:13.100 --> 25:17.100]  По определению s.
[25:17.100 --> 25:21.100]  Потому что s это и есть множество тех n.
[25:21.100 --> 25:25.100]  Ну сейчас где это у нас было? Вот здесь вот.
[25:25.100 --> 25:29.100]  Вот определение s.
[25:29.100 --> 25:37.100]  Соответственно, если мы p подставляем, то оно должно быть вот так вот.
[25:37.100 --> 25:41.100]  Ну, значит, получается в любом случае противоречие.
[25:41.100 --> 25:49.100]  В любом случае противоречие.
[25:57.100 --> 26:03.100]  Ну вот и получается, что s неразрешимо.
[26:07.100 --> 26:17.100]  Значит, s неразрешимо.
[26:27.100 --> 26:33.100]  Ну и тогда, как мы уже обсуждали, h тоже неразрешимо.
[26:33.100 --> 26:37.100]  Значит, следовательно, и h неразрешимо.
[26:53.100 --> 26:55.100]  Ну чего, понятно ли?
[26:55.100 --> 26:59.100]  Вот это, на самом деле, очень мощный метод диагональный.
[26:59.100 --> 27:01.100]  Мы с ним еще встретимся несколько раз.
[27:01.100 --> 27:11.100]  То есть глобально можно это, конечно, таких терминах излагать,
[27:11.100 --> 27:15.100]  что вот пусть у нас есть такой суперанализатор,
[27:15.100 --> 27:21.100]  который позволяет по программе понять, что становится она или нет.
[27:21.100 --> 27:25.100]  Но тогда мы этот суперанализатор встроим в какую-нибудь другую программу,
[27:25.100 --> 27:31.100]  которая делает следующее.
[27:31.100 --> 27:35.100]  Значит, которая берет какую-то еще программу,
[27:35.100 --> 27:39.100]  спрашивает про нее анализаторы, делает наоборот.
[27:39.100 --> 27:45.100]  И потом мы задаемся вопросом, что будет, если в эту программу поставить ее саму.
[27:45.100 --> 27:49.100]  Тогда она должна делать не то же самое, что она делает, а такое невозможно.
[27:55.100 --> 27:57.100]  Хорошо.
[27:57.100 --> 28:09.100]  Вот это действительно очень важное достижение тьюринга 1936 года.
[28:13.100 --> 28:15.100]  Хорошо, что дальше?
[28:15.100 --> 28:19.100]  Дальше можно сказать, что по теореме пусто.
[28:19.100 --> 28:27.100]  При этом S и H перечислимые.
[28:27.100 --> 28:33.100]  Про H мы уже сказали, а S, на самом деле, по той же самой причине.
[28:33.100 --> 28:39.100]  Ну или можно сказать, что S это пересечение перечислимого и разрешимого.
[28:39.100 --> 28:44.100]  Пересечение перечислимого и разрешимого будет перечислимым.
[28:44.100 --> 29:02.100]  И поэтому по теореме пусто дополнение S с чертой и H с чертой неперечислимое.
[29:02.100 --> 29:14.100]  Потому что если бы кто-то из них был перечислимым, то, соответственно, S было бы разрешимым или H.
[29:14.100 --> 29:20.100]  Отсюда получается явный пример неперечислимого множества.
[29:20.100 --> 29:30.100]  Но тем не менее, эти дополнения S и H это такие неперечислимые множества, к которым дополнение перечислимо.
[29:30.100 --> 29:58.100]  Ну и возникает вопрос, можно ли явно описать множество, которое неперечислимо,
[29:58.100 --> 30:10.100]  неперечислимо и имеет неперечислимое дополнение?
[30:10.100 --> 30:26.100]  То, что не явно понятно, что такие есть сопряжение мощности.
[30:26.100 --> 30:36.100]  Потому что перечислимых счетное число с перечислимым дополнением тоже счетное число, а всего континуум.
[30:36.100 --> 30:42.100]  Кстати, перечислимое дополнение называется ко-перечислимое.
[30:42.100 --> 30:58.100]  Определение множества A ко-перечислимо, если дополнение K перечислимо.
[30:58.100 --> 31:02.100]  Но вообще вот это вот ko, это часто встречается в математике.
[31:02.100 --> 31:16.100]  Синус, косинус, в топологии разные штуки бывают, в гомологии когомология, градиент, коградиент и так далее.
[31:16.100 --> 31:24.100]  Вектор, ковектор. В общем, в разных частях математики такие двойственные штуки встречаются.
[31:24.100 --> 31:32.100]  Но и в частности, и в теории вычислимости, и дальше в теории сложности вычислений есть такие вот ko-классы.
[31:32.100 --> 31:40.100]  То есть если есть какое-то свойство множеств, то у него есть и ko-свойство, которое означает, что дополнение этим свойством обладает.
[31:40.100 --> 31:46.100]  Но вот для разрешимого это одно и то же. То есть ko-разрешимое то же самое, что разрешимое.
[31:46.100 --> 31:50.100]  А вот для перечислимого это другая штука.
[31:50.100 --> 31:58.100]  Ну вот, соответственный вопрос. Как описать множества, которые не перечислимые и не ko-перечислимые?
[31:58.100 --> 32:14.100]  Так, ну да. Что еще раз? Ko-перечислимо.
[32:14.100 --> 32:26.100]  Вот. Так, ну давайте я сейчас напишу, что это за множество, после перерыва расскажу.
[32:26.100 --> 32:32.100]  Да, значит, пример вот такой вот.
[32:32.100 --> 32:44.100]  Значит, t это множество таких m, что для любого x у от nx определено.
[32:44.100 --> 32:50.100]  То есть это множество всюда определенных программ.
[32:50.100 --> 32:54.100]  Так, ну ладно, сейчас перерыв, потом поговорим, почему же это нужны множества.
[32:55.100 --> 33:02.100]  Так, значит, сначала давайте я попробую интуитивно рассказать, почему такое t должно подходить.
[33:02.100 --> 33:04.100]  Ну, смотрите, в чем вообще смысл перечислимости.
[33:04.100 --> 33:10.100]  Ну смысл перечислимости в том, что мы можем доказать принадлежность к этому множеству.
[33:10.100 --> 33:15.100]  А вот непринадлежность – не факт, что можем.
[33:15.100 --> 33:21.100]  То есть перечислимые, но не разрешимые, означает, что принадлежность мы можем доказать, а непринадлежность не можем.
[33:21.100 --> 33:41.100]  А вот такое... Теорема стоит в том, что вот это вот T неперечислимо и некоперечислимо.
[33:41.100 --> 33:49.100]  Это значит, что мы не можем доказать ни принадлежность к T, ни непринадлежность.
[33:49.100 --> 33:53.100]  Ну а что такое вообще T, что здесь написано?
[33:53.100 --> 33:57.100]  T, слово total, это множество всюда определённых функций.
[33:57.100 --> 34:07.100]  Верно ли, верно ли, что для данного N, для данной программы, чтобы в неё не подставить, она остановится?
[34:07.100 --> 34:14.100]  Ну вот, смотрите, чтобы доказать, что это верно, что нам нужно сделать?
[34:14.100 --> 34:21.100]  Нам как-то нужно попытаться эту программу на всех ходах запустить и проверить, что она везде остановится.
[34:21.100 --> 34:25.100]  Но как-то ясно, что вроде так не должно получится сделать.
[34:25.100 --> 34:29.100]  Их же бесконечно много, мы не можем прямо на всех запустить.
[34:29.100 --> 34:35.100]  А с другой стороны, каким образом доказать, что все подходят, в общем случае тоже непонятно.
[34:35.100 --> 34:44.100]  Ну а что значит, что T неверно? Что значит, что программа не на всех останавливается?
[34:44.100 --> 34:47.100]  Ну значит, она каком-то не останавливается.
[34:47.100 --> 34:54.100]  Но мы же уже знаем, что проблема остановки неразрешима, но при этом доказать, что программа остановится, можно.
[34:54.100 --> 34:57.100]  А доказать, что она не остановится, нельзя.
[34:57.100 --> 35:00.100]  Ну а здесь нам тоже самое нужно фактически сделать.
[35:00.100 --> 35:04.100]  Соответственно, мы этого тоже не сможем сделать.
[35:04.100 --> 35:12.100]  Получается, что чтобы сказать, что T неверно, нужно доказать, что на каком-то одном входе не остановится.
[35:12.100 --> 35:17.100]  А чтобы доказать, что T верно, нужно бесконечное число входов проверить.
[35:17.100 --> 35:21.100]  Поэтому ни того, ни другого не должно быть.
[35:21.100 --> 35:28.100]  Что бы доказывать формально, нам нужен некоторый инструментарий.
[35:28.100 --> 35:34.100]  И это тоже еще одна очень важная концепция в теории вычислений.
[35:34.100 --> 35:38.100]  И вообще вычислимости, и сложности вычислений.
[35:38.100 --> 35:41.100]  Это концепция сводимости.
[35:41.100 --> 35:55.100]  И в данном случае тут понятие, которое мы будем использовать, это понятие M-сводимости.
[35:59.100 --> 36:03.100]  Значит, что означает буковка M?
[36:03.100 --> 36:06.100]  В общем, разные говорят разные.
[36:06.100 --> 36:08.100]  Я знаю минимум две версии.
[36:08.100 --> 36:11.100]  Одна версия, что M – это слово mapping.
[36:11.100 --> 36:14.100]  Mapping – read usability, а mapping – это отображение.
[36:14.100 --> 36:17.100]  То есть там сейчас будет некоторая функция.
[36:17.100 --> 36:22.100]  А другая интерпретация, что M означает many to one.
[36:22.100 --> 36:26.100]  Соответственно, много могут к одному сводиться.
[36:26.100 --> 36:30.100]  И это тоже сейчас будет понятно, что за many to one.
[36:30.100 --> 36:35.100]  В общем, другие сводимости, они прям точно известны, почему.
[36:35.100 --> 36:39.100]  Бывает T-сводимость – это часть юринга.
[36:39.100 --> 36:47.100]  Бывает, маленькими буквами ТТ – это truth table на таблице истинности.
[36:47.100 --> 36:51.100]  Ну и так далее. А для буковки M есть разные интерпретации.
[36:51.100 --> 36:53.100]  Что это такое?
[36:53.100 --> 36:57.100]  Значит, обозначение вот так вот.
[36:57.100 --> 36:59.100]  Есть два множества.
[36:59.100 --> 37:03.100]  И обозначение – это прям такой значок меньше либо равно с индексом.
[37:03.100 --> 37:05.100]  Читается, M сводится.
[37:05.100 --> 37:09.100]  А M сводится к B.
[37:10.100 --> 37:24.100]  Значит, если существует вычислимая всюду определенная F,
[37:24.100 --> 37:36.100]  значит, такая, что X принадлежит A тогда и только тогда, когда F от X принадлежит B.
[37:39.100 --> 37:45.100]  Соответственно, вот это F – это то самое мэпинг, который букв кем,
[37:45.100 --> 37:51.100]  но и many to one, потому что для разных X может быть одно и то же значение F от X.
[37:51.100 --> 37:55.100]  В чем идея?
[37:55.100 --> 38:01.100]  Но идея в том, что если мы умеем решать задачу B в каком-то смысле,
[38:01.100 --> 38:05.100]  то мы умеем решать и задачу A.
[38:09.100 --> 38:14.100]  Это, видимо, самое важное.
[38:14.100 --> 38:18.100]  Давайте я это вначале напишу.
[38:18.100 --> 38:28.100]  Первое свойство, что если A сводится к B,
[38:28.100 --> 38:39.100]  значит, а B разрешима, то тогда A тоже разрешима.
[38:39.100 --> 38:43.100]  Но почему это так?
[38:43.100 --> 38:49.100]  B разрешима означает, что мы умеем отвечать на этот вопрос для F от X.
[38:49.100 --> 38:52.100]  То есть для F от X мы умеем определять, лежит ли оно в B.
[38:52.100 --> 38:55.100]  Но кроме того, поскольку F вычислимая всюду определенная,
[38:55.100 --> 38:59.100]  то по X мы всегда можем вычислить F от X.
[38:59.100 --> 39:04.100]  Значит, у нас есть X, мы по нему вычисляем F от X,
[39:04.100 --> 39:08.100]  дальше определяем, лежит ли F от X в B,
[39:08.100 --> 39:18.100]  и ответ на этот вопрос будет в точности ответом на то, лежит ли X в A.
[39:19.100 --> 39:29.100]  Доказательство состоит в том, что характеристическая функция множества A от X
[39:29.100 --> 39:36.100]  это то же самое, что характеристическая функция множества B от F от X.
[39:36.100 --> 39:41.100]  Ну и поскольку F вычислимо, всюду определено, и хиB тоже вычислимые,
[39:41.100 --> 39:45.100]  всюду определено, то и композиция тоже вычислимые, всюду определена,
[39:45.100 --> 39:47.100]  и дает правильный ответ.
[39:53.100 --> 39:55.100]  Ну ничего, понятно.
[39:55.100 --> 39:58.100]  Так, ну вот это вот ключевое свойство.
[39:58.100 --> 40:03.100]  Но есть еще, в принципе, несколько полезных свойств.
[40:03.100 --> 40:06.100]  Ну, например, транзитивность.
[40:06.100 --> 40:15.100]  Значит, если A им сводится к B, а B им сводится к C, то тогда A им сводится к C.
[40:17.100 --> 40:20.100]  Так, ну это как доказывается...
[40:23.100 --> 40:32.100]  Ну, тут идея в том, что X пронжит A тогда и только тогда, когда F от X пронжит B,
[40:32.100 --> 40:38.100]  а это тогда и только тогда, когда G от F от X пронжит C.
[40:38.100 --> 40:43.100]  То есть здесь F это функция из определения сводимости A к B,
[40:43.100 --> 40:47.100]  G это функция из определения сводимости B к C.
[40:47.100 --> 40:53.100]  Ну а соответственно их композиция G на F будет сводить A к C,
[40:53.100 --> 40:58.100]  и тоже будет вычислимая всюду определенно.
[41:03.100 --> 41:06.100]  Так, ну ничего, понятно.
[41:08.100 --> 41:11.100]  Так, дальше.
[41:15.100 --> 41:20.100]  Третье свойство, наверное, самое элементарное, вот такое вот.
[41:20.100 --> 41:26.100]  A им сводится к B тогда и только тогда, когда дополнение к A
[41:26.100 --> 41:29.100]  им сводится к дополнению к B.
[41:33.100 --> 41:37.100]  Вот, ну это просто мы берем отрицание.
[41:41.100 --> 41:45.100]  Ну ладно, давайте я напишу, да, это очень легко.
[41:45.100 --> 41:52.100]  Значит, X пронжит A равносильно тому, что F от X пронжит B.
[41:52.100 --> 41:56.100]  Вот эта равносильность равносильна другой равносильности,
[41:56.100 --> 42:04.100]  то X не пронжит A тогда и только тогда, когда F от X не пронжит B.
[42:04.100 --> 42:09.100]  Ну а это не принадлежность A, это есть принадлежность к дополнению.
[42:19.100 --> 42:24.100]  Ну и на самом деле правоперечислимость тоже все аналогично получается.
[42:24.100 --> 42:36.100]  Значит, если A им сводится к B, а B перечислимо, то тогда и A перечислимо.
[42:43.100 --> 42:51.100]  Ну, например, тут можно действовать через полухарактеристическую функцию.
[42:51.100 --> 43:02.100]  То есть здесь точно так же получится, что A с крышкой от X это будет B с крышкой от F от X.
[43:04.100 --> 43:08.100]  Ну и то, что композиции вычислимы, будет вычислимое.
[43:08.100 --> 43:27.100]  Так, ну и использовать мы будем следствие, значит, логические следствия из этих свойств.
[43:27.100 --> 43:35.100]  Наоборот, если A, это надо называть условной контрпозиция.
[43:35.100 --> 43:39.100]  Значит, вот у нас здесь что было?
[43:39.100 --> 43:43.100]  Значит, если A сводится к B и B разрешимы, то A разрешима.
[43:43.100 --> 43:45.100]  А здесь будет наоборот.
[43:45.100 --> 43:53.100]  Если A сводится к B и A неразрешима, тогда B неразрешима.
[43:54.100 --> 44:10.100]  И, соответственно, значит, если A сводится к B и A неперечислимо, то тогда B неперечислимо.
[44:14.100 --> 44:22.100]  Вот, и это нам позволяет получать, у нас как бы уже есть какие-то неперечислимые множества, да, типа A с чертой.
[44:22.100 --> 44:26.100]  Вот, и это позволяет еще новые непречислимые множества получать.
[44:26.100 --> 44:33.100]  Ну и финальное свойство, третье.
[44:33.100 --> 45:00.100]  Смотрите, если A, M сводится к B, и A, M сводится к B с чертой, и A неперечислимо, то из этого получается, что B неперечислимо и не коперечислимо.
[45:03.100 --> 45:16.100]  Вот.
[45:16.100 --> 45:22.100]  Так, ну это из чего следует?
[45:23.100 --> 45:32.100]  Ну, так вроде понятно более-менее, что первая часть...
[45:32.100 --> 45:43.100]  Ну да, фактически получается, что мы применили второе и к B, и к B с чертой.
[45:43.100 --> 45:52.100]  А вот это нам еще говорит, что мы в принципе можем менять черту, вместо того чтобы вот здесь ее написать, написать ее вот здесь.
[45:52.100 --> 45:58.100]  Сейчас посмотрим, как будет удобнее.
[45:58.100 --> 46:08.100]  Получается, что нам нужно свести, чтобы доказать, что T какое нам нужно.
[46:08.100 --> 46:35.100]  Значит, для доказательства того, что T неперечислимо и не коперечислимо,
[46:35.100 --> 46:55.100]  значит, достаточно доказать, что H, M сводится к T, и H, M сводится к T с чертой.
[47:05.100 --> 47:11.100]  Вот.
[47:11.100 --> 47:17.100]  Так, ну сейчас будем это показывать.
[47:17.100 --> 47:23.100]  На самом деле вот то, что я сейчас буду рассказывать, на самом деле сама теорема.
[47:23.100 --> 47:27.100]  Она верна не то чтобы для любой функции U.
[47:27.100 --> 47:37.100]  Давайте я обратно промотаю.
[47:37.100 --> 47:46.100]  Вот это теорема дать я тут сделаю оговорку.
[47:46.100 --> 47:56.100]  Для хороших U.
[47:56.100 --> 48:00.100]  А что им называется хорошее U?
[48:00.100 --> 48:05.100]  Может, сегодня еще успеем, а так мы про это будем подробно в следующий раз говорить.
[48:05.100 --> 48:11.100]  То есть можно действительно построить такую функцию, чтобы это было неверно.
[48:11.100 --> 48:16.100]  Но для U. это верно.
[48:16.100 --> 48:22.100]  В общем, это сложные вещи, что они не все хорошие, но сейчас я, по крайней мере,
[48:22.100 --> 48:28.100]  сейчас в доказательстве будет видно, где именно мы используем специфику машины тюринга,
[48:28.100 --> 48:33.100]  или вообще к чему мы привыкли.
[48:33.100 --> 48:38.100]  Так.
[48:38.100 --> 48:49.100]  Хорошо.
[48:49.100 --> 48:59.100]  Первая часть, h сводится к t.
[48:59.100 --> 49:27.100]  Значит, рассмотрим такую Q, что для любого входа Y U от Qy равняется U от Px.
[49:27.100 --> 49:39.100]  Вот тут как раз, чтобы такое можно было сделать, нужны определенные свойства для U.
[49:39.100 --> 49:51.100]  Почему это будет верно для обычных наших представлений о том, что такое U?
[49:51.100 --> 49:56.100]  Ну, Px это какой-то параметр.
[49:56.100 --> 50:01.100]  Вот если я это сделаю, то тогда будет верно.
[50:01.100 --> 50:05.100]  Сейчас, что еще раз?
[50:05.100 --> 50:11.100]  Нет, у это вообще внутренняя переменная, а Q строится по Px.
[50:11.100 --> 50:21.100]  Вот что, значит, что Px принадлежит h, тогда и только тогда, когда Q принадлежит t.
[50:21.100 --> 50:31.100]  И мы хотим, чтобы можно было Q построить по паре Px, и чтобы это была всю дополненную учтимая функция.
[50:31.100 --> 50:49.100]  Соответственно, нужно, чтобы преобразование из пары P и X в Q было вычислимым.
[50:49.100 --> 51:05.100]  Но вычислимым и всюду определенным.
[51:05.100 --> 51:15.100]  Почему мы можем на это надеяться?
[51:15.100 --> 51:23.100]  Потому что можно себе представить, пусть даже это не машина тюринга, а просто какой-то обычный язык программирования.
[51:23.100 --> 51:32.100]  И этот язык программирования имеет доступ к тексту программы компилятора, к тексту U.
[51:32.100 --> 51:41.100]  Тогда можно писать такую программу, чтобы прямо в тексте программы написать значение константа P.
[51:41.100 --> 51:45.100]  Потом прямо в тексте программы написать значение константа X.
[51:45.100 --> 52:00.100]  И потом в связи с программой, что вход мы вообще игнорируем, а вместо этого берем P и X из текста программы и запускаем U от Px.
[52:00.100 --> 52:07.100]  Но, соответственно, если это какой-то нормальный язык программирования, то там можно делать шаблон.
[52:07.100 --> 52:17.100]  Шаблон, что X равно тому-то, и после этого мы значение Px подставляем в U и выводим.
[52:17.100 --> 52:28.100]  И, соответственно, преобразование пары P и X в Q заключается в том, что мы в шаблон подставляем конкретное значение P и X.
[52:28.100 --> 52:33.100]  Ну и тогда, если это так устроено, то понятно, что это будет вычислим, и всюду определенно.
[52:33.100 --> 52:38.100]  Это какая-то простая строковая операция в шаблон подставить как конкретное значение.
[52:41.100 --> 52:50.100]  Ну вот, так сказать, хороший компилятор, хорошая универсальная вычисляемая функция — это та, для которой это можно сделать.
[52:50.100 --> 53:07.100]  Ну, может, сейчас договорю без точного определения, а потом, наверное, сегодня еще останется некоторое время на то, чтобы формально сказать, что это значит.
[53:07.100 --> 53:11.100]  Так, ну чего, понятно, что происходит?
[53:11.100 --> 53:20.100]  Да, Q игнорирует вход, и она просто из своего текста берет, что она делает.
[53:20.100 --> 53:28.100]  Да, вход она игнорирует. Вход игнорирует, вместо этого берет откуда-то у себя записанный P и X.
[53:28.100 --> 53:37.100]  Она говорит, что я буду делать, вот у меня написано, что я делаю на ком входе, а вход игнорирую.
[53:37.100 --> 53:47.100]  Ну, тогда действительно, то если она на любом входе делает одно и то же, то если то, что она делает, определено, то она будет везде определенна.
[53:47.100 --> 53:56.100]  Если то, что она делает, неопределена, то она будет нигде неопределена, но, в частности, не везде определена.
[54:07.100 --> 54:10.980]  Так, ну чего, понятно?
[54:16.220 --> 54:26.500]  Дальше вторую часть. Вторую часть будет удобнее, наоборот, дополнение к h,
[54:26.500 --> 54:32.700]  дополнение к h сводить к t. Мы уже обсудили, что это неважно, где
[54:32.700 --> 54:41.140]  стоят черта, да, вот здесь или вот здесь. Так, вот тут вот, значит, вот тут вот уже
[54:41.140 --> 54:54.820]  программа Q будет зависеть от входа. Значит, здесь у от Q и n будет равно
[54:54.820 --> 55:10.740]  следующему. Значит, это будет равно единице, если у от Px не остановилось за n шагов.
[55:12.740 --> 55:20.380]  Значит, и не определено иначе.
[55:24.820 --> 55:49.860]  Вот. Ну и тогда то же самое. Значит, тогда если пара Px не принадлежит h,
[55:49.900 --> 56:02.100]  тогда это только тогда, когда Q принадлежит t. Почему это так? Ну, потому что если у от Px
[56:02.100 --> 56:08.380]  вообще не останавливается, то в частности, ни для какого конкретного n оно не останавливается
[56:08.380 --> 56:13.620]  за n шагов. Тогда получится, что для любого конкретного n оно не остановится, значит, будет
[56:13.620 --> 56:21.980]  единица, то есть это будет функция, которая всюду равна единице. Вот. А если Px лежит в h, то тогда
[56:21.980 --> 56:28.820]  у от Px, ну, за какое-то конкретное число шагов останавливается. Да, то есть когда мы в качестве n
[56:28.820 --> 56:34.380]  подставим число шагов, на котором останавливается, за которые останавливается у от Px, то вот это
[56:34.380 --> 56:39.380]  условие не будет выполнено, соответственно, будет не определено. Вот. Ну и тогда это будет функция,
[56:39.380 --> 56:46.780]  которая сначала равна единице, а потом с какого-то момента не определена. Вот. Так же действительно такое
[56:46.780 --> 56:55.660]  получаем. Вот. Ну и опять же, да, значит, если мы можем не просто запускать компилятор, а еще как бы
[56:55.660 --> 57:04.300]  считать количество шагов, да, то тогда тоже преобразование, значит, опять же нам нужно, чтобы
[57:04.300 --> 57:18.340]  преобразование Px в Q, значит, это было, значит, это у нас вычислимая всю доопределенная функция,
[57:18.340 --> 57:32.940]  вычислимая всю доопределенная функция. Вот. Ну опять же, да, можно подготовить шаблон,
[57:32.940 --> 57:40.260]  что, опять же, Px мы берем откуда-то из памяти, из внутренней памяти программы, ну а дальше,
[57:40.260 --> 57:46.900]  если мы умеем вот так от Px пошагов запускать, то можем запустить на n шагов, где n мы уже берем
[57:46.900 --> 57:55.020]  со входа. N берем на входе, такое число шагов запускаем, ну и, соответственно, смотрим,
[57:55.020 --> 58:02.380]  остановился или не остановился. Вот. Ну опять же, да, опыт программирования говорит, что любой
[58:02.380 --> 58:08.300]  нормальный компилятор имеет режим пошагового запуска. Ну, обычно шаги прям не совсем уж
[58:08.300 --> 58:15.660]  элементарные, если это только не машинотюрнинг из того сайта, который я выкладывал, да, но,
[58:15.660 --> 58:30.700]  тем не менее, да, на какие-то шаги в средах разработки обычно можно запускать. Вот. Ну вот,
[58:30.700 --> 58:36.180]  получается, что обе сводимости есть, и две сводимости вместе говорят, что нет ни перечислимости,
[58:36.180 --> 58:54.940]  ни ко перечислимости. Так. Ну что же, есть ли какие-нибудь вопросы? Я думаю, что мы тогда успеем
[58:54.940 --> 59:01.620]  поговорить, что такое вот эта хорошая функция, которая нам нужна, и, соответственно, вот эту
[59:01.620 --> 59:17.540]  учислимость я покажу формально. Так. Я, наверное, перейду на новый слайд. Значит, хорошая функция
[59:17.540 --> 59:35.420]  называется главная, универсальная, вычислимая функция. Значит, здесь первые два условия такие
[59:35.420 --> 59:43.780]  же, как были. Да, то есть это тоже у, значит, которое отображает 0,1 со звездочкой, да, значит,
[59:43.780 --> 59:56.020]  на 0,1 со звездочкой в 0,1 со звездочкой. Так. Ну и свойства первое. Первое свойство, что уучислимо,
[59:56.020 --> 01:00:10.980]  как функция двух аргументов. Второе то же самое, значит, для любой f из 0,1 со звездочкой,
[01:00:10.980 --> 01:00:23.300]  0,1 со звездочкой вычислимой, значит, существует p, что для любого x, у от px равно f от x. Да,
[01:00:23.300 --> 01:00:27.580]  в общем, первые два свойства повторяют. То же самое, да, то есть тут, как вы видите,
[01:00:27.580 --> 01:00:31.500]  три предлагательных главные универсально вычислимые. Соответственно, первые говорят,
[01:00:31.500 --> 01:00:43.780]  что вычислимые, вторые универсальные, и третьи новые свойства главности. Так. Третье свойство.
[01:00:43.780 --> 01:01:00.900]  Третье свойство выглядит так. Для любой функции v двух аргументов 0,1 со звездочкой на 0,1 со звездочкой
[01:01:00.900 --> 01:01:10.540]  в 0,1 со звездочкой. Теперь для любой, опять же, вычислимой. Значит, для любой вычислимой
[01:01:10.540 --> 01:01:26.860]  функции двух аргументов. Так. Существует t из 0,1 со звездочкой в 0,1 со звездочкой,
[01:01:26.860 --> 01:01:39.340]  тоже вычислимая и всюду определенная. Вычислимая и всюду определенная. Такая,
[01:01:39.340 --> 01:01:56.060]  что верно следующая. Такая, что для любого p и для любого x, v от px это u от t от p и x.
[01:01:56.060 --> 01:02:15.260]  Вот такое вот свойство. Давайте я попробую объяснить, что оно означает. Значит, вообще любую
[01:02:15.260 --> 01:02:25.340]  функцию двух аргументов можно считать таким компилятором. Что можно считать, что в этой
[01:02:25.340 --> 01:02:29.620]  функции двух аргументов первый аргумент это программа, а второй аргумент это, собственно,
[01:02:29.620 --> 01:02:36.500]  аргумент этой программы, вход этой программы. И этот компилятор возвращает результат работы
[01:02:36.500 --> 01:02:44.580]  этой программы на этом входе. Но без универсальности это может быть не универсальный язык
[01:02:44.580 --> 01:02:51.780]  программирования. Тот, на котором не всё что угодно можно сделать, только что-нибудь.
[01:02:51.780 --> 01:03:00.780]  Может быть, предписанный список функций, эти функции можно комбинировать, но их недостаточно,
[01:03:00.780 --> 01:03:08.220]  чтобы вообще всё вычислить. Может быть, какой-нибудь там язык арифметических выражений.
[01:03:08.220 --> 01:03:15.660]  Первый аргумент – это арифметические выражения со скобками плюсами, минусами, умножениями и так далее.
[01:03:15.660 --> 01:03:22.860]  Второй аргумент – это значения переменных. А этот компилятор подставляет эти значения
[01:03:22.860 --> 01:03:31.740]  в это выражение и говорит, чему оно равно. Что здесь утверждается? Утверждается, что есть
[01:03:31.740 --> 01:03:41.420]  вот такая перекодировка. Что вот это вот T, что делает? T перекодирует программу в этом языке
[01:03:41.420 --> 01:03:52.180]  программирования V в наш универсальный U. То есть вот это вот T от P, значит, P – это программа на
[01:03:52.180 --> 01:04:00.220]  языке V, T от P – это программа на языке U. И вот это вот T от P делает то же самое, что P с любым X.
[01:04:00.220 --> 01:04:13.460]  То есть T как бы транслирует. Смотрите, почему это усиление по сравнению просто со вторым?
[01:04:13.460 --> 01:04:19.380]  Значит, конечно, если мы P фиксируем, то вот эта функция от ровного аргумента будет вычислимой.
[01:04:19.380 --> 01:04:26.580]  И тогда второй нам говорит, что есть такое T от P, что на любом X это равенство верно.
[01:04:26.580 --> 01:04:34.460]  Но усиление в том, что не просто для любого P есть T от P, но еще и что это вот преобразование
[01:04:34.460 --> 01:04:50.300]  из P в T от P вычислимое и всюду определено. Вот такое условие. Ну и на самом деле очень сложный
[01:04:50.300 --> 01:04:56.500]  язык программирования, на котором это будет неверно. То есть если вы не специально пишете
[01:04:56.500 --> 01:05:00.940]  его, чтобы это было неверно, а просто для своих целей, и если он у вас универсальный,
[01:05:00.940 --> 01:05:07.500]  то он почти наверняка и таким будет. Но тем не менее можно. Если задаться целью,
[01:05:07.500 --> 01:05:12.940]  то можно делать так, чтобы это было неверно. И мы, наверное, даже в следующий раз обсудим,
[01:05:12.940 --> 01:05:24.580]  как именно это сделать. Ну и давайте, в оставшись пять минут, я покажу, как это определение
[01:05:24.580 --> 01:05:30.420]  используется. Не знаю, может какие-нибудь вопросы есть? Ну действительно это такое
[01:05:30.420 --> 01:05:42.420]  сложное, не очень интуитивное определение, но я думаю, освоите со временем. Хорошо,
[01:05:42.540 --> 01:06:00.620]  дайте я покажу, как это теперь можно использовать. Сначала давайте вот с этим вот. То есть у нас
[01:06:00.620 --> 01:06:26.780]  должен быть на любого у, да? И с третьего следует второй. Ну вообще, наверное, да. Наверное,
[01:06:26.780 --> 01:06:38.460]  это вроде... Ну вообще вы, наверное, правы, что если в качестве V взять уже универсальную,
[01:06:38.460 --> 01:06:46.660]  то тогда получится, что и универсальная. Так что вроде бы да, вроде и с третьего следует второй,
[01:06:46.660 --> 01:06:54.540]  если я ничего не упускаю. Но удобнее все-таки смотреть, что для каждого предлагательного есть
[01:06:54.540 --> 01:07:14.740]  свое, значит, свое свойство. Так, ну вот, значит, давайте вот на это посмотрим. Значит, у от у равно у от
[01:07:14.740 --> 01:07:42.660]  пх. Значит, как это используется? Да, значит, как построить преобразование из px в q, значит,
[01:07:42.660 --> 01:07:58.100]  такое, что для любого у у от qy равно у от px. Так, ну значит, надо сделать следующее. Значит,
[01:07:58.100 --> 01:08:18.780]  мы возьмем V, рассмотрим V, которая получает, так бы, пару px и y, и оно будет равно просто у от px.
[01:08:18.780 --> 01:08:32.420]  Значит, это вычислимое преобразование. Потому что оно получает код пары, разбивает его отдельно
[01:08:32.420 --> 01:08:40.420]  на p и отдельно на x, и это подставляет в у, а у вообще не трогает. Значит, у никак не использует.
[01:08:40.420 --> 01:08:55.140]  Вот тогда, что у нас говорит свойство. Значит, по свойству главно универсальной вычислимой
[01:08:55.140 --> 01:09:08.540]  функции, значит, получаем, что вот для этого V существует T, такое, что для любого... Так,
[01:09:08.580 --> 01:09:14.620]  ну тут будет получаться, что, давайте я так напишу, что для любого z и для любого y,
[01:09:14.620 --> 01:09:31.700]  значит, будет V от zy равняется у от T от z и y. Ну вот, если z будет равно как раз паре px,
[01:09:31.700 --> 01:09:42.500]  то есть получается, что вот это Q будет как раз равно T от px. И как раз у нас по условию
[01:09:42.500 --> 01:09:50.220]  главности получается, что T это всю допределенную вычислимую функция. Но нам и нужно,
[01:09:50.220 --> 01:09:55.940]  значит, нам это и нужно, чтобы Q как раз была всю допределенную вычислимую функцию, чтобы была
[01:09:55.940 --> 01:10:08.660]  сводимость. Ну, почему такой Q подходит? Ну, как раз получается, что у от Qy это будет у от,
[01:10:08.660 --> 01:10:34.220]  соответственно, T от px, y это будет V от px, y, и это равно у от px. Ну вот, в общем, вроде получается.
[01:10:34.220 --> 01:10:40.720]  То есть ровно та вычислемостьюvagartiness, которая есть в определении главности,
[01:10:40.720 --> 01:10:46.200]  она же переходит в эту вычислимостьюvagartiness, которая есть в определении сводимости. То есть
[01:10:46.200 --> 01:10:53.740]  в точности вот это вот T, значит, T это есть функция из определения на сводимости. Ну,
[01:10:53.740 --> 01:11:00.500]  со второй сводимостью га аналогично. Да, нужно только вот здесь вот... В общем, другую форму
[01:11:00.500 --> 01:11:03.940]  поставить вот сюда, будет то же самое.
[01:11:06.300 --> 01:11:11.100]  Так, ну хорошо, есть ли вопросы?
[01:11:14.100 --> 01:11:17.100]  Сейчас, про что?
[01:11:18.420 --> 01:11:22.420]  Так, а что именно повторить?
[01:11:22.420 --> 01:11:37.420]  Ну, смотрите, что тут написано, что у нас есть вот этот транслятор, что у нас есть как бы программа P для языка V,
[01:11:37.420 --> 01:11:41.420]  которая, если мы P фиксируем, то получается какая-то функция.
[01:11:41.420 --> 01:11:45.420]  И можно считать, что P это программа для этой функции в языке V.
[01:11:45.420 --> 01:11:54.420]  А T преобразует программу P для этого языка в какую-то программу T от P для одного и того же универсального языка.
[01:11:54.420 --> 01:11:57.420]  И вот это ровно то, что здесь происходит.
[01:11:57.420 --> 01:12:04.420]  То есть как бы вот эта вот пара Px, код пары Px получается программой вот для такой константе,
[01:12:04.420 --> 01:12:12.420]  а мы преобразуем эту пару вот в программу уже в языке U.
[01:12:15.420 --> 01:12:19.420]  Так, ну хорошо, спасибо за внимание.
