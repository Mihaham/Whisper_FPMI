[00:00.000 --> 00:17.160]  Так, добрый день. Мы начинаем говорить про кратчайшие пути в графах. Давайте пару тривиальных
[00:17.160 --> 00:27.040]  определений. Ну, если у нас есть обычный граф, какой-нибудь, мы можем добавлять к
[00:27.040 --> 00:39.240]  его описанию слова невзвешенный. Это как бы значит, что все ребра одинакового веса,
[00:39.240 --> 00:44.880]  все ребра одинаковой длины, все ребра одинаковой стоимости. И тогда длиной пути мы можем просто
[00:44.880 --> 01:00.000]  называть количество ребер в нем. Тогда, собственно, длина пути – это число ребер в нем. А расстояние
[01:00.000 --> 01:12.320]  между вершинами у и в – это длина самого короткого пути между ними. Расстояние дист у в от у до в
[01:12.320 --> 01:35.800]  – это длина самого короткого пути между ними. Ну, точнее от у до в. Вот, если пути нет, если у
[01:35.800 --> 01:54.560]  недостижимо в, то мы говорим, что дист равно плюс бесконечности, если такого пути нет. Вот,
[01:54.560 --> 01:58.240]  значит, это обычный случай невзвешенного графа, когда все ребра у нас одинаковые, ну, или можно
[01:58.240 --> 02:04.600]  сказать, что они имеют вес один. Ну, еще такой взвешенный граф. Взвешенный граф – это когда на
[02:04.600 --> 02:13.560]  всех ребрах еще написаны какие-то веса. Значит, если g, давайте, напишу, это обычный граф ve и w. Это
[02:13.560 --> 02:24.800]  взвешенный граф. Если вот это вот – это обычный граф, а w – это весовая функция, которая каждому
[02:24.800 --> 02:31.160]  ребру сопоставляет какой-то вес. То есть, взвешенный граф – это когда у нас дан обычный граф ve,
[02:31.160 --> 02:44.840]  а w – это какая-то функция из множества ребер, ну, куда-нибудь, пусть будет в r. Весовая функция.
[02:44.840 --> 02:58.880]  Вот. Тогда в этом случае длиной пути называется сумма весов-рёбер в этом пути. Ну, и, соответственно,
[02:58.880 --> 03:04.960]  расстояние – это, опять-таки, длина самого короткого пути оттуда v, если мы под длиной пути
[03:04.960 --> 03:19.920]  подразумеваем, опять-таки, вот ту самую сумму весов. Длина пути p. Я напишу так. Вес от p – это сумма
[03:19.920 --> 03:32.120]  по всем ребрам входящим, значит, по всем ребрам e входящим в p, вес ребра e. Ну, и расстояние,
[03:32.120 --> 03:36.040]  соответственно, определяется аналогично. Если у нас определена длина пути, то мы выбираем
[03:36.040 --> 03:40.040]  среди всех путей самый короткий по этой длине, и это и есть, собственно, расстояние между вышинами.
[03:40.040 --> 03:48.640]  Вот. Ну, вроде, вроде, вроде стандартное определение, да. Очень естественно мы
[03:48.640 --> 03:55.600]  определили, что такое, собственно, длина пути. Значит, первый алгоритм, который мы рассмотрим,
[03:55.600 --> 04:00.400]  это будет алгоритм BFS, который работает на невзвешенных графах и находит кратчайшее
[04:00.400 --> 04:12.800]  расстояние от одной вершины до всех. Первый алгоритм BFS, значит, по-английски это вот так
[04:12.800 --> 04:38.440]  расшифровывается, по-русски это поиск ширину. Это алгоритм поиска кратчайших путей от одной
[04:38.440 --> 04:52.560]  вершины S до всех остальных. Здесь кайт стартовой вершины, мы хотим найти расстояние от нее до всех
[04:52.560 --> 05:10.860]  остальных в невзвешенном графе, в утяжении взвешенной. Значит, алгоритм очень простой. Давайте
[05:10.860 --> 05:17.600]  заметим следующее, что вот если у нас есть вершинка S, то каково расстояние от S до S? Ну, ясен пень
[05:17.600 --> 05:23.160]  ноль, потому что есть путь, стоящий на месте, использующий ноль ребер, поэтому можем сразу сказать,
[05:23.160 --> 05:32.000]  что dist от S равно нулю. Ну, в массиве dist я буду сохранять найденные вот те самые расстояния,
[05:32.000 --> 05:37.280]  которые я ищу, расстояние от S до всех вершинок. Теперь давайте рассмотрим ребра, исходящие из S.
[05:37.280 --> 05:43.480]  Ну, там какие-то ребра. Понятное дело тогда, что до этих вершин кратчайшее расстояние равно единице,
[05:43.480 --> 05:48.440]  но потому что расстояние ноль быть не может, потому что ноль может быть только для S, мы можем на
[05:48.440 --> 05:54.640]  месте только стоять, а для них есть как бы пудленый один. Значит, для них для всех dist равен единице,
[05:54.640 --> 06:02.440]  то есть меньше нельзя, а единичка уже есть. То же самое для них для всех, если я рассматриваю
[06:02.440 --> 06:09.160]  всех их соседей, то есть рассматриваю все стрелочки из них исходящие, то для них для всех dist уже
[06:09.160 --> 06:15.360]  двойка. Ну, при условии, что это новая вершина, то есть понятно, что нет смысла оставаться там
[06:15.360 --> 06:19.840]  на том же уровне, то есть нет смысла идти в ту вершину, для которой dist уже найдена. Поэтому мы
[06:19.840 --> 06:24.600]  среди всех исходящих ребер рассматриваем только такие, которые ведут в новые вершины, и для них
[06:24.600 --> 06:30.960]  говорим, что dist равно двойке. То есть на этом уровне у всех dist равно двойке. Опять-таки понятно,
[06:30.960 --> 06:36.320]  они не были найдены раньше на уровне 0 и раньше на уровне 1, значит до них нет пути меньше длины,
[06:36.320 --> 06:41.600]  но есть пути длины 2. То, что мы сюда поставили, это правильная вершина ответа. То есть до них
[06:41.600 --> 06:47.040]  реально dist равно 2. Ну и так далее. Мы вот так идем по графу, по уровням, нулевой, первый,
[06:47.040 --> 06:52.200]  второй и так далее. На каждом шаге мы раскрываем вершинку, то есть рассматриваем все исходящие
[06:52.200 --> 06:58.600]  ребра и обновляем ответ для всех этих вершин, которые не достижимы по одному ребру. Вот,
[06:58.600 --> 07:06.640]  все, такой алгоритм, очень простой. Значит, как мы его будем реализовывать? Мы его будем реализовывать
[07:06.640 --> 07:24.760]  с помощью очереди. Значит, будет очередь вершинку, будет вот этот массив dist. Значит, он изначально
[07:24.760 --> 07:31.840]  заполнен, ну давайте я напишу плюс бесконечностями, как знак того, что пока еще никакой путь не найден,
[07:31.840 --> 07:39.520]  ни до какой вершины никакой путь пока не найден. Значит, начинаем, говорим, что вершина s лежит у
[07:39.520 --> 07:48.040]  нас на нулевом слое и добавляем ее в очередь, купуш s. То есть мы нашли вершину s, мы знаем для
[07:48.040 --> 07:53.320]  нее кратчайшее расстояние и добавляем ее в очередь. В очереди у нас будут лежать те вершины,
[07:53.320 --> 07:57.960]  вот которые нам надо раскрыть, те, для которых надо рассмотреть всех соседей, для них обновить ответ.
[07:57.960 --> 08:04.280]  С самого начала это будет только s. Мы рассматриваем потом ее соседей, соседей, соседей и так далее. И вот те,
[08:04.280 --> 08:09.640]  кого мы рассматриваем, в очереди у нас будут лежать. Значит, как мы работаем с очередью? Пока она не
[08:09.640 --> 08:30.720]  пустая, мы достаем оттуда первую вершину. Достаем и сразу удаляем. Куфрант-купоп. Дальше вот то,
[08:30.720 --> 08:34.720]  что я называю раскрытием вершины, то есть просмотров всех соседей и попытка обновить
[08:34.720 --> 08:43.600]  дист для всех соседей. Ну, это мы уже не раз делали. И ребор всех соседей, ну, точнее всех ребер,
[08:43.600 --> 08:50.640]  сходящих из данной вершины, мы делаем вот таким циклом по всем элементам массива g от v. Если g от v это,
[08:50.640 --> 08:57.760]  как обычно, список смежности, то есть список вершин, в которой есть ребро из данных.
[08:57.760 --> 09:05.120]  Вот, соответственно, есть у меня ребро из v в tu. И я хочу сказать, что для вершины tu у меня
[09:05.120 --> 09:10.720]  теперь появился новый путь. Можно сначала дойти до v, потом, используя это ребро, попасть в tu. Ну,
[09:10.720 --> 09:22.200]  давайте это сделаем. Если dist tu равно плюс бесконечности, то есть мы еще не нашли никакого пути
[09:22.320 --> 09:29.760]  tu. Тогда мы нашли путь до v сначала, а потом плюс одно ребро от v до tu. Я говорю, что dist tu
[09:29.760 --> 09:54.360]  равно dist v плюс 1, q pu tu. Конец. Вот весь алгоритм. Так, да, и давайте я еще вот это напишу,
[09:54.360 --> 10:01.240]  что вот это вот то, что я делаю, вот эту циклу, я буду называть раскрытием вершины v. Раскрытие v.
[10:01.240 --> 10:13.960]  Ну, по-английски это expansion. Раскрытие, то есть просмотр всех соседей и обновление для них
[10:13.960 --> 10:21.360]  dist. Вот. Ну, такой очень простой алгоритм, который вот как бы обходит наш граф, собственно,
[10:21.360 --> 10:24.760]  почти так, как надо. Тут, на самом деле, есть небольшая хитрость, почему-то все корректно
[10:24.760 --> 10:29.480]  работает, потому что, на самом деле, вот давайте проследим, как работает, что у нас вообще в очереди
[10:29.480 --> 10:35.040]  лежит. Изначально в очереди только вершинка s. Ну, понятно, она достается, сразу удаляется из
[10:35.040 --> 10:40.160]  очереди. В очередь складываются все вот эти вот вершинки, то есть после обработки s в очереди
[10:40.160 --> 10:45.160]  лежит целиком первый слой. На все вершины расстание 1. Потом мы начинаем постепенно эти вершинки
[10:45.160 --> 10:50.120]  удалять из начала очереди, а в конец очереди сваливать вот эти вот вершинки. То есть, скажем,
[10:50.120 --> 10:56.240]  когда у меня обработается первая вершина первого слоя, очередь вот такой станет. Первая удалится,
[10:56.240 --> 11:02.320]  но вот эти вот добавятся. То есть у меня будет вот это вот начало, вот это конец. То есть, по сути,
[11:02.320 --> 11:07.640]  у меня в очереди будет как бы сначала кусок конец предыдущего слоя и потом начало следующего.
[11:07.640 --> 11:13.440]  Вот. Это как бы полезно иметь в виду, если мы хотим понимать, почему это работает корректно.
[11:13.440 --> 11:18.840]  Что у нас не то, что в очереди лежит очередной слой, мы рассматриваем целиком слой и потом
[11:18.840 --> 11:23.320]  переходим на следующий. И дальше как бы в этом слое работаем. Мы скорее вот так вот. У нас в очереди
[11:23.320 --> 11:28.960]  лежат вершины с двух слоев сразу, из предыдущего и со следующего. Вот. Но эта корректность не мешает,
[11:28.960 --> 11:34.080]  сейчас мы все докажем. Значит, ну, сначала я давайте отмечу, что это, очевидно, работает за линейное время.
[11:34.080 --> 11:46.120]  Так. Ну, собственно, по той же логике, что, например, DFS работает за линейное время,
[11:46.260 --> 11:51.960]  потому что у меня очевидным образом вершина добавится в очередь максимум 1 раз. Но потому что
[11:51.960 --> 11:56.600]  добавляется она только в случае, когда там изначально лежала плюс бесконечность и мы
[11:56.600 --> 12:00.920]  потом исправляем на что-то небесконечное. качестве каждая вершина побывает в очереди
[12:00.920 --> 12:05.920]  максимум 1 раз. Значит, она раскроется максимум 1 раз. Значит, каждое ребро исследуется максимум
[12:05.920 --> 12:10.920]  один раз. Поэтому, собственно, такая симптомика получается немедленно.
[12:10.920 --> 12:21.080]  Теперь корректность. Для доказательств корректности я сформулирую следующие
[12:21.080 --> 12:26.960]  три утверждения про внутренний устройство нашего алгоритма, и всех будут доказывать
[12:26.960 --> 12:30.800]  параллельно друг за другом по итерациям вот этого цикла, цикла while, пока очередь
[12:30.800 --> 12:47.200]  не пустая. Значит, первое. Пусть к – это dist от q.frank. То есть вот пусть в какой-то
[12:47.200 --> 12:52.360]  момент времени у нас там алгоритм что-то поработал, и вершина, лежащая в начале
[12:52.360 --> 13:00.480]  очереди, имеет dist равной в точности k. Тогда я утверждаю, что в очереди лежат
[13:00.480 --> 13:05.280]  вершины в следующем порядке. Сначала идет несколько вершин с dist в точности k,
[13:05.280 --> 13:11.920]  потом несколько, возможно, ноль вершин на расстоянии ровно k плюс 1. То есть вот ровно
[13:11.920 --> 13:16.000]  то, что я говорил. У меня сначала заканчивается предыдущий слой k-тый, потом, возможно,
[13:16.000 --> 13:20.520]  несколько вершин со следующего k плюс 1. То есть в очереди все dist-ы выглядят вот так. Сначала
[13:20.520 --> 13:23.480]  несколько одинаковых равных k, потом несколько одинаковых равных k плюс 1.
[13:23.480 --> 13:40.880]  Насчет первого утверждения. Второе. Значит, в этот момент времени все вершины, для которых
[13:40.880 --> 14:02.320]  настоящий dist-sv не больше чем k, имеют dist от v равный настоящему dist-sv. Здесь такая небольшая
[14:02.320 --> 14:08.240]  путность обозначений в том плане, что dist, когда это массив, то есть квадратные скобки, это то,
[14:08.480 --> 14:14.560]  что наш алгоритм находит. То есть это как бы то, что алгоритмы считают правильным ответом. А dist
[14:14.560 --> 14:18.920]  как функция, соответственно, в круглых скобочках, это настоящий ответ, правильный ответ. То есть я
[14:18.920 --> 14:23.560]  вот эту штуку определял как настоящее, кратчайшее расстояние. А это то, что наш алгоритм считает.
[14:23.560 --> 14:30.320]  Так вот, я утверждаю, что в этот момент времени, если k это вот эта штука, то все вершины,
[14:30.320 --> 14:34.360]  для которых настоящее расстояние не больше чем k, правильно найдено. То есть для них,
[14:34.360 --> 14:46.000]  для всех, уже правильно найдено кратчайшее расстояние. Ну и третье. Каждое обновление
[14:46.000 --> 15:02.200]  dist, ну давайте от tu, всегда корректно. То есть если в нашем алгоритме мы когда-то выставляем
[15:02.200 --> 15:07.280]  dist от вершины равно чему-то, то это на самом деле в точности настоящее кратчайшее расстояние. То
[15:07.280 --> 15:11.680]  есть не бывает такого, что мы в dist положили что-то неправильное. Я утверждаю, что мы всегда кладем
[15:11.680 --> 15:15.080]  только правильные величины. Но собственно отсюда и будет следовать корректно всего нашего алгоритма,
[15:15.080 --> 15:18.760]  потому что если мы для всех вершин выставляем правильные ответы, то тем самым мы как бы для всех
[15:18.760 --> 15:28.440]  вершин в принципе найдем то, что надо. Такое утверждение. Вот совокупность этих двух утверждений
[15:28.440 --> 15:35.120]  мы будем доказывать, наверное, индукцией по количеству итераций цикловайл.
[15:35.120 --> 16:03.240]  Ну начало. Когда еще ни одной итерации цикловайл не сделана база, что мы сделали до вайла?
[16:03.240 --> 16:09.120]  Мы в очередь положили вершинку s, сказали, что на расстоянии ноль. Тем самым у меня в очереди
[16:09.120 --> 16:13.920]  k равно нулю, то есть как бы есть единственная вершинка, для нее dist равно нулю. Понятно,
[16:13.920 --> 16:20.960]  что правильно посчитано и никаких вершин других нет. Значит, база, когда в очереди лежит только
[16:20.960 --> 16:30.720]  вершинка s, для нее k равно нулю и все три утверждения очевидны. Потому что да, верно, что в очереди
[16:30.720 --> 16:34.920]  сначала несколько нулей, потом несколько единиц, но в плане расстояния единиц вообще нет, ну как бы
[16:34.920 --> 16:39.120]  это ничему не мешает. То есть я здесь не утверждал, что здесь обязательно кто-то есть, возможно,
[16:39.120 --> 16:44.360]  их и нет. Сначала несколько нулей, потом несколько единиц. Это верно. Дальше здесь все вершины,
[16:44.360 --> 16:48.920]  для которых настоящее расстояние не больше нуля, имеют корректно выставленный dist. Ну это верно,
[16:48.920 --> 16:54.520]  потому что единственная такая вершина, это s, мы для нее уже поставили dist s равно нулю. А мы уже
[16:54.520 --> 17:02.040]  имеем dist s равно нулю. Ну и третье тоже очевидно, к этому моменту времени у нас только вот это
[17:02.040 --> 17:28.280]  обновление произошло, оно очевидно корректно. Так, еду дальше. Переход. Ну давайте рассмотрим в
[17:28.280 --> 17:34.360]  какой-то момент времени, пусть очередь действительно выполняется, для нее выполняется первое условие.
[17:34.360 --> 17:37.960]  То есть мы как бы доказываем по индукции, пусть в какой-то момент времени в очереди реально вот
[17:37.960 --> 17:43.360]  такие вот dist. То есть для них dist вот такие, для нескольких следующих dist равен k плюс 1.
[17:43.360 --> 17:50.960]  Мы обрабатываем эту вершинку, соответственно удаляем ее из очереди, раскрываем и пытаемся
[17:50.960 --> 17:54.960]  понять, что с очереди произойдет. Вот пусть это была v, мы ее как бы хотим удалить.
[17:54.960 --> 18:02.960]  Нам надо доказать вот эти три утверждения. То есть сделают переход, что все эти утверждения
[18:02.960 --> 18:09.800]  сохраняются. Ну во-первых, смотрите, если за v была еще вершинка с dist ровно k, то у нас
[18:09.800 --> 18:14.320]  структура очереди останется. У нас будет сначала несколько k-шек, потом несколько k плюс 1,
[18:14.320 --> 18:19.880]  и возможно мы в конце еще добавим несколько k плюс 1 за счет того, что мы раскрыли v. От раскрытия v
[18:19.880 --> 18:26.760]  мы рассмотрели несколько вершин, и для них, возможно, присвоили dist равно k плюс 1. И вот эти
[18:26.760 --> 18:32.880]  новые вершинки могут сюда поместиться. Поэтому первая свойство тривиально выполняется. В случае
[18:32.880 --> 18:38.320]  же, если v была единственная вершина с расстоянием k, то есть у меня было k, а потом сразу несколько
[18:38.320 --> 18:45.720]  k плюс 1, и это было единственное v. Ну тогда все еще проще. У нас в конец очереди, возможно,
[18:45.720 --> 18:50.880]  помещается несколько вершин с dist равным k плюс 1, и все. Тогда у меня в очереди вообще
[18:50.880 --> 18:56.400]  все dist одинаковые. Но это тот случай, когда мы целиком обработали очередной слой, и наша
[18:56.400 --> 19:02.320]  очередь в точности состоит из вершин следующего слоя. То есть там даже нет перехода как k плюс 1,
[19:02.320 --> 19:10.880]  там просто вот эта вот величина, ну она одинаковая у всех, все dist одинаковые. Хорошо,
[19:11.040 --> 19:21.560]  первым мы доказали. Второе, что все вершины, для которых dist не больше чем k, имеют правильный
[19:21.560 --> 19:29.480]  dist. Ну тут опять два случая. Либо v была не единственной вершины с dist равным k в очереди,
[19:29.480 --> 19:36.920]  либо единственной. В этом случае, смотрите, к моменту удаления v из очереди, у меня в очереди,
[19:36.920 --> 19:41.240]  ну точнее после обработки вершины v, у меня в очереди по-прежнему будут вот эти вершины с dist
[19:41.240 --> 19:46.600]  равным k, потом несколько вершин с dist k плюс 1, и возможно еще несколько новых вот от раскрытия v.
[19:46.600 --> 19:51.880]  Ну тогда понятно, что если раньше у меня, короче, если вот это вот условие выполнялось раньше,
[19:51.880 --> 19:57.520]  то оно и теперь будет выполняться, потому что k не изменилось. Если раньше для всех вершин с
[19:57.520 --> 20:02.640]  dist не больше k у меня были правильно насчитаны в эти самые dist в массиве, и k не изменилось,
[20:02.640 --> 20:08.040]  потому что после удаления v, в этом случае, у меня k не изменяется, у меня вот это вот dist
[20:08.040 --> 20:15.280]  остается таким же как было. Значит второе условие тривиально сохраняется. Следжательный случай
[20:15.280 --> 20:22.560]  только когда у меня v была единственная вершина с dist равным k. Ну давайте поймем. Вот у меня v,
[20:22.560 --> 20:29.440]  я рассматривал v, и мне говорят, что к моменту ее рассмотрения все вершины с dist не больше
[20:29.440 --> 20:33.760]  чем k правильно обработаны, то есть для них найдено правильное расстояние. А я хочу доказать,
[20:33.760 --> 20:42.320]  что после удаления v, после ее раскрытия, у меня будут правильно найдены все расстояния не больше
[20:42.320 --> 20:47.640]  чем k плюс 1. Потому что я перехожу от k к плюс 1, мне нужно теперь доказать, что все вершины с dist
[20:47.640 --> 20:53.560]  не больше чем k плюс 1 будут правильно обработаны. Зная, что до этого были правильно обработаны все
[20:53.560 --> 21:03.720]  вершины с dist не больше чем k. Ну что такое вершины с dist не больше чем k плюс 1? Что такое dist
[21:03.720 --> 21:13.080]  su не больше чем k плюс 1? Значит это либо меньше либо равно k, и тогда для них уже все хорошо по
[21:13.080 --> 21:21.880]  предположению индукции. Либо это в точности k плюс 1. То есть мне надо сказать, что все вершины с
[21:21.880 --> 21:28.240]  dist k плюс 1 у меня правильно найдутся, что для них я поставлю правильное расстояние. Но это вроде
[21:28.240 --> 21:35.840]  понятно, что значит, что dist su равно k плюс 1. Значит есть какой-то путь из s до u длины в точности
[21:35.840 --> 21:44.680]  k плюс 1. Тогда я могу рассмотреть, точнее последнее ребро на этом пути, какое-то ребро w у. Значит тогда
[21:44.680 --> 21:50.200]  длина пути от s до w это в точности k. Ну раз я последнее ребро отпустил, то здесь осталось k
[21:50.200 --> 21:56.160]  ребер. Ну а значит опять-таки по предположению индукции для w у меня уже все корректно найдено,
[21:56.160 --> 22:05.680]  там dist w равен тому, чему нужно, равен k. И при этом у меня v была последняя рассмотренная вершина с
[22:05.680 --> 22:13.440]  dist равным k. Значит к моменту удаления v из очереди у меня w тоже уже будет удалена и раскрыта. Ну
[22:13.440 --> 22:28.000]  значит для u будет найдено правильное расстояние. То есть к моменту удаления v w уже будет
[22:28.000 --> 22:45.080]  удалена, уже будет раскрыта и удалена. Следовательно, то что нужно мы получаем, что dist u мы найдем таким,
[22:45.080 --> 23:02.120]  каким нужно, dist s u. Профит. Так, вопросики есть? Хорошо, значит второй пункт мы тоже доказали. Ну а
[23:02.120 --> 23:08.680]  третий, собственно, тривиально из этого всего следует. Если у нас все до этого присвоения были
[23:08.680 --> 23:13.800]  корректными, то какие мы делаем присвоения вот в момент раскрытия v? Мы присваиваем только те
[23:13.800 --> 23:21.160]  dist вот этим вот вершинкам, если для них еще dist был не найден. Ну что значит он был не найден?
[23:21.160 --> 23:28.920]  Значит пока что до них не было найдено никакого пути длины меньше либо равно, чем k плюс 1. Но
[23:28.920 --> 23:33.200]  смотрите, все вершины на расстоянии не больше чем k мы уже обработали, для них корректно
[23:33.200 --> 23:38.360]  проставили dist по пункту 2. То есть если бы до вершины был dist не больше чем k, то мы бы ее должны
[23:38.360 --> 23:45.040]  были уже найти по предложении индукции. А раз мы ее не нашли, то до нее расстояние хотя бы k плюс 1.
[23:45.040 --> 23:49.760]  Поэтому если я в этот момент времени, в момент раскрытия v каким-то вершинам проставляю dist равно
[23:49.760 --> 23:54.760]  k плюс 1, то это точно правильный ответ, потому что все вершины с меньшим расстоянием у меня уже
[23:54.760 --> 24:02.000]  обработаны, они уже удалены из кучи даже, из очереди, sorry. Значит когда я выполняю такие присваивания,
[24:02.000 --> 24:08.960]  у меня эти присваивания корректны, это настоящее правильное кратчайшее расстояние. Вот, ну вроде все.
[24:08.960 --> 24:23.080]  Хорошо, значит ну тут на самом деле я, возможно, несколько громоздков все это доказал, на самом
[24:23.080 --> 24:26.920]  деле доказательство оно вот тут нарисовано, что можно было бы просто сказать, ну вот послаем,
[24:26.920 --> 24:31.120]  просто идем и все, как бы все очевидно. Но это было бы очевидно, если бы я сделал типа две очереди,
[24:31.120 --> 24:35.720]  одна очередь у меня хранит как бы вершины на предыдущем слое, а во вторую я вкладываю
[24:35.720 --> 24:39.920]  вершины следующего слоя. И тогда совсем очевидно, то есть я целиком рассматриваю очередной слой,
[24:39.920 --> 24:43.800]  добавляю в следующий слой вершины как бы следующего слоя, понятно, что я их туда все добавлю.
[24:43.800 --> 24:49.760]  Вот, ну тут небольшая тонкость, что чтобы так не делать, чтобы не заводить две очереди, а обойтись
[24:49.760 --> 24:59.040]  одной, ну вот тогда придется чуть повозиться, понять, что как бы оно корректно. Хорошо. Так, ну с
[24:59.040 --> 25:08.640]  БФС мы разобрались вроде. Тогда я иду дальше.
[25:29.040 --> 25:45.720]  Так, следующий алгоритм, это алгоритм 0К БФС. 0, так, ну давайте маленькое К, БФС. Значит, это опять-таки
[25:45.720 --> 25:55.040]  поиск кратчайших расстояний от 1 до всех, но при условии, что граф уже взвешенный и веса всех ребер
[25:55.040 --> 26:06.880]  это целые числа от 0 до K. Значит, граф взвешенный, весовая функция бьет из E в целые числа от 0 до K.
[26:06.880 --> 26:24.040]  И опять-таки мы ищем кратчайшие расстояния от S до всех. Ищем расстояния от S до всех.
[26:24.040 --> 26:40.440]  Вот, уже переходим к взвешенным графам, но с таким ограниченным условием, что все веса, то есть по факту
[26:40.440 --> 26:45.640]  это эффективно, если K какое-нибудь небольшое. То есть представьте, что у вас там в графе почему-то все
[26:45.640 --> 26:50.760]  ребра имеют маленький вес, ну там 0, 1, 2, 3, 4, например. А тогда это, в принципе, вот сейчас будет
[26:50.760 --> 26:55.800]  довольно эффективный алгоритм, как находить себе кратчайшие расстояния. Итак, давайте заметим, во-первых,
[26:55.800 --> 27:05.040]  что в графе такого вида длина любого пути не превосходит что-то типа NK. Ну, точнее, длина любого
[27:05.040 --> 27:19.760]  кратчайшего пути строго меньше, я утверждаю, чем NK. Ну, где N это, как обычно, числовище в графе.
[27:19.760 --> 27:35.480]  Почему? Так. Ну да, да, да. Потому что, на самом деле, можно сказать так, потому что, если есть путь,
[27:35.480 --> 27:45.680]  то есть простой путь. Путь без повторения вершин. Значит, в нем максимум N-1 ребро. Каждое
[27:45.680 --> 27:51.400]  ребро имеет вес максимум K, поэтому я мог бы здесь даже написать не больше, чем N-1 на K. На более
[27:51.400 --> 27:59.360]  точной оценке, но мне такой хватит. Вот. Значит, тогда я сделаю следующее. Я заведу NK очередей.
[27:59.360 --> 28:13.000]  NK очередей. Значит, и в очереди с номером D я буду хранить как бы те вершины, до которых
[28:13.000 --> 28:31.120]  расстояние типа равно D. Вот типа. В D этой очереди храню вершины, до которых найден путь длины D.
[28:31.120 --> 28:50.240]  Вот так напишу. Найден путь длины D. Вот. Значит, тогда, как я это могу реализовать? Ну, я завожу,
[28:50.240 --> 29:00.800]  собственно, массив очередей, как я обещал, размера NK. Так нельзя описать, но я напишу так.
[29:00.800 --> 29:14.120]  Мне можно. Значит, NK очередей. В нулевую я изначально пихаю S. Говорю, что D от S равно 0,
[29:14.120 --> 29:23.720]  но пока сначала такое же. Вот. Но еще мне понадобится массив used, в котором я буду хранить,
[29:23.720 --> 29:40.120]  раскрывал я вершинку или нет. Я завожу вектор bool used. Изначально там все false. И там для каждой
[29:40.120 --> 29:54.520]  вершины сказано, раскрывал я ее или нет. То есть как бы удалил ли я ее уже из очереди. Значит, тогда в цикле по,
[29:54.520 --> 30:04.880]  собственно, всем D, перебираю очереди в порядке возрастания номера. D меньше NK, плюс-плюс D. Я иду
[30:04.880 --> 30:12.240]  под этой очереди. Пока D еще не пустая, достаю первую вершинку, как обычно. Значит, пока неверно,
[30:12.240 --> 30:38.400]  что QD это empty. Достаю QD.front. Сразу ее удаляю. Вот. И раскрываю. Но на самом деле не совсем. Я ее
[30:38.480 --> 30:43.440]  раскрываю, если раньше до этого не раскрывал. То есть на самом деле может быть такое, что я вершину вижу,
[30:43.440 --> 30:48.400]  достаю из очереди несколько раз. Ну потому что, смотрите, очень простой пример. Вот, например,
[30:48.400 --> 30:57.600]  я из S нашел ребро веса 3 в вершину V, а потом нашел более короткий путь, скажем, вот такой, веса 2,
[30:57.600 --> 31:03.360]  в нее же. То есть тогда понятно, что я этот путь тоже обнаружу. Но тогда у меня вершина V будет
[31:03.360 --> 31:07.880]  сразу в двух очередях. Во второй и в третий. Потому что до нее есть путь длины 2, до нее есть путь длины 3.
[31:07.880 --> 31:14.560]  Ну, наверное, понятно, что если я ее раскрыл в момент обработки второго очереди, то нет смысла
[31:14.560 --> 31:19.920]  обрабатывать в момент обработки третьей очереди. Потому что я ее уже раскрыл, я до нее нашел правильное
[31:19.920 --> 31:23.720]  расстояние, а теперь мне говорят, что там есть еще какой-то путь длины 3, но он мне не нужен,
[31:23.720 --> 31:28.320]  мне не надо ее раскрывать. Поэтому вот здесь я напишу, что если я ее уже раскрывал, то я ее
[31:28.320 --> 31:38.840]  игнорирую. Если used в это, то continue. Вот. А иначе я ее сейчас буду раскрывать и сразу помечаю раскрытый.
[31:38.840 --> 31:55.120]  Так. Ну, раскрытие работает очень просто. Как всегда, на самом деле, как в прошлом,
[31:55.120 --> 32:10.520]  как в дейстре, это у нас будет чуть позже. Вот. Значит, раскрытие, собственно. Ну, тут уже смотрите,
[32:10.520 --> 32:16.680]  тут у меня ребра становятся взвешенными, поэтому я не могу просто говорить, что я перебиваю все
[32:16.680 --> 32:21.880]  конечные, все концы ребер. Мне нужно сказать, что я перебиваю реально все исходящие ребра,
[32:21.880 --> 32:29.760]  но вот пусть у меня есть какая-то структурка edge, которая хранит в себе вес ребра и, собственно,
[32:29.760 --> 32:36.480]  то, куда оно ведет. Так вот, я перебираю, как обычно, все исходящие ребра из вершины v,
[32:36.480 --> 32:53.520]  завожу, ну, какой-нибудь x равное, видимо, d плюс e точка кост. Вот. И тем самым я, получается,
[32:53.520 --> 33:00.200]  нашел до вершинки e точка tu. Вот, если у меня есть, если ребро e, оно ведет из текущей вершины v
[33:00.200 --> 33:09.200]  в вершину e точка tu имеет вес e точка кост, то я до этой вершины нашел только что путь длины x. Да,
[33:09.200 --> 33:14.120]  потому что до v есть путь длины d, потом я еще прибавляю новое ребро, вот это вот e, получается
[33:14.120 --> 33:23.240]  путь веса x, путь длины x. И я могу сделать следующее, я могу взять и добавить вершинку вот эту вот в
[33:23.240 --> 33:37.080]  очередь номер x. Ну, если это осмысленно. Так, а dist у меня есть, да. Если dist вот e точка tu больше
[33:37.080 --> 33:43.880]  чем x, то есть получается, что я нашел как бы более эффективный путь до вершинки e точка tu, да,
[33:43.880 --> 33:52.040]  более короткий. Тогда я, собственно, туда его сохраняю, то текущая найденная расстояние равно x,
[33:52.040 --> 34:02.800]  ну и добавляю e точка tu в x в очередь. qxt push e точка tu. Так, все, раскрытие закончилось,
[34:02.800 --> 34:07.200]  while закончился и for по d тоже закончился, конец.
[34:22.040 --> 34:27.920]  Вот, ну давайте какую-нибудь иллюстрацию я приведу. На самом деле вот эта вот лучшая иллюстрация.
[34:27.920 --> 34:33.080]  То есть смотрите, когда я обрабатываю вершинку s, я ее раскрываю и говорю, что эту вершину я
[34:33.080 --> 34:39.720]  ее кладу в первую очередь, а эту в третью. То есть я уже вижу путь длины 1 до нее, путь длины 3 до нее.
[34:39.720 --> 34:45.800]  Потом я иду в порядке увеличения этих дешек, потом я рассматриваю в первую очередь вот эту вершину.
[34:45.800 --> 34:51.600]  И ее я опять раскрываю и нахожу путь до вершинки v длины 2, значит я v кладу во вторую очередь.
[34:51.600 --> 34:56.760]  Тем самым как бы я нашел вот этот путь длины 2 от s до v. Потом у меня вершинка v находится и во
[34:56.760 --> 35:01.840]  второй очереди и в третьей, но если надо, там она опять раскрывается, но только в момент обработки
[35:01.840 --> 35:05.720]  второй очереди. В момент обработки третьей очереди она уже не раскрывается, да.
[35:05.720 --> 35:21.240]  Дерево? Дерево поиска в смысле? Или какое дерево?
[35:21.240 --> 35:33.880]  Это правильно говорите, это вы Dx описываете. И там на самом деле не дерево поиска, а куча
[35:33.880 --> 35:38.120]  достаточно, потому что нам нужно только добавлять и извлекать минимум. Ну это следующий алгоритм,
[35:38.120 --> 35:42.000]  да. Ну вообще вы правы абсолютно. Здесь как бы это просто эффективно, то есть то, что вы говорите
[35:42.000 --> 35:46.320]  добавляет логарифмическое множество, а здесь маленько, то тут нет никакого логарифмического множества.
[35:46.320 --> 35:50.640]  Тут как бы за линию, грубо говоря. Вот, ну абсолютно правильно говорите, но просто другой алгоритм уже,
[35:50.640 --> 36:00.280]  следующий будет. Вот, значит, давайте я сначала опять скажу про симптотику. Симптотика здесь
[36:00.280 --> 36:08.600]  получается m плюс nk. Ну из стандартных соображений, значит, каждую вершину я раскрываю максимум один
[36:08.600 --> 36:15.200]  раз за счет меток юст, поэтому суммарно все вот эти форики работают за отm, за количество ребер
[36:15.200 --> 36:23.920]  в графе. Все раскрытия работают за отm. Ну а все остальное это проход по очередям, да, то есть у меня
[36:23.920 --> 36:29.920]  nk очередей, и плюс еще надо сказать, что каждая вершина добавится максимум в k очередей. Значит,
[36:29.920 --> 36:45.800]  каждая вершина может присутствовать. Так, это, кажется, не важный факт для доказательства симптотики,
[36:45.800 --> 37:00.040]  ну на всякий случай отмечу, присутствует не более, чем в k очередях. Ну, потому что если я в какой-то
[37:00.040 --> 37:07.000]  момент времени нашел до какой-то вершины какой-то путь, что это значит? Значит, я был вот здесь, до нее
[37:07.000 --> 37:13.560]  корректно здесь, это d, потом я взял, рассмотрел какое-то ребро веса e точка кост и нашел расстояние,
[37:13.560 --> 37:20.040]  точнее путь до вот этой вершинки веса x. Вопрос, когда я эту вершинку e точку могу добавить в другую
[37:20.040 --> 37:24.640]  очередь? Ну, во-первых, я ее могу добавить только в очередь с меньшим номером, потому что добавляю
[37:24.640 --> 37:29.480]  я вершину только в случае, когда у нее уменьшается дист, то есть если дист, который там уже лежит,
[37:29.480 --> 37:36.200]  строго больше, чем то, что я нашел. Поэтому если я эту вершину куда-то еще и добавляю, пушу в новой
[37:36.200 --> 37:40.440]  очереди, то их номера будут всегда меньше, чем x, то есть они будут только уменьшаться, уменьшаться,
[37:40.440 --> 37:45.640]  уменьшаться, уменьшаться. Но понятно, что стать меньше, чем d оно не может, потому что если к моменту
[37:45.640 --> 37:50.600]  рассмотрения v у меня e точка tu еще не найдено, ну тогда понятно, что расстояние до него хотя бы d.
[37:50.600 --> 37:56.160]  То есть, грубо говоря, я рассмотрел все вершины на расстоянии не больше, чем d, и эту вершину, так давайте
[37:56.160 --> 38:02.960]  я на самом деле вот так вот скажу, k плюс один может быть, в худшем случае. Вот, значит, к моменту
[38:02.960 --> 38:08.240]  времени рассмотрения v, у меня если e точка tu нет, значит она находится на расстоянии не больше,
[38:08.240 --> 38:14.160]  чем d плюс k. Ну и потом я, получается, ее могу добавить в d плюс k, минус 1, d плюс k, минус 2 и так далее,
[38:14.160 --> 38:18.840]  вплоть до d этой очереди, в случае, если тут есть ребро веса 0, ну и тогда, получается, на максимум k
[38:18.840 --> 38:25.360]  плюс 1 очередь посетит. Вот, поэтому вот опять-таки откуда берется nk, потому что каждые вершины
[38:25.360 --> 38:33.960]  максимум k очереди посещают. Так, вот, ну а корректность здесь, собственно, тоже практически тривиальна.
[38:33.960 --> 38:43.120]  Давайте я не буду доказывать, я просто формулирую утверждение, которое, ну по факту, эту корректность
[38:43.120 --> 39:04.560]  и гарантирует. Так, значит, как это формулировать-то? К моменту начала d этой итерации,
[39:04.560 --> 39:15.160]  начало d этой итерации внешнего вот этого фора, да, то есть когда d равно очередному значению,
[39:15.160 --> 39:25.200]  к моменту начала обработки очередной итерации внешнего фора q dt содержит все вершины на расстоянии d,
[39:25.200 --> 39:31.600]  кроме, возможно, тех, которые достижимы из тех, которые там уже содержатся по путям нулевой длины.
[39:31.600 --> 39:38.480]  То есть q от d реально содержит все вершины на расстоянии d, но, возможно, еще какие-то не содержат,
[39:38.480 --> 39:44.920]  но те, которые не содержат, точно можно обнаружить по путям длины 0. То есть вот q от d это какая-то
[39:44.920 --> 39:52.480]  очередь, и из нее, возможно, есть какие-то пути по нулевым ребрам. И тогда, если я добавлю все вот
[39:52.480 --> 39:57.600]  эти вершины, достижимые по нулям, добавлю в очередь q от d, то тогда это будет полностью все
[39:57.600 --> 40:06.800]  множество вершин на расстоянии ровно d. Сейчас допишу и перерыв. Значит q от d содержит все вершины
[40:06.800 --> 40:15.800]  с dist sv равно d, кроме, возможно, тех,
[40:15.800 --> 40:24.560]  которые достижимы из них по путям нулевой длины.
[40:36.800 --> 40:48.880]  Вот. Ну и тогда как раз, когда эти пути длины 0 обработаются, то есть я обрабатываю все эти вершинки,
[40:48.880 --> 40:54.360]  рассматриваю вот эти ребра веса 0, и они постепенно добавляются в конец этой же очереди.
[40:54.360 --> 40:59.520]  Поскольку здесь q от d равен 0, они все будут добавляться в конец этой же очереди, и значит,
[40:59.520 --> 41:03.480]  они все рассмотрятся к моменту окончания d тетрации. Ну, значит, как раз все вершины на
[41:03.480 --> 41:06.920]  нужном расстоянии рассматриваются. Вот перерыв.
[41:06.920 --> 41:23.280]  Следующий на очередь у нас алгоритм d экстры. Граф, опять-таки, взвешенный, но веса могут
[41:23.280 --> 41:31.080]  быть не обязательно целые маленькие числа, а любые неотрицательные, главное. Граф взвешенный,
[41:31.080 --> 41:44.680]  весовая функция бьет из ребер в r больше равно 0. Я так напишу. Ну, нет, давайте я вот так
[41:44.680 --> 41:59.640]  напишу лучше. То есть все веса неотрицательны. Все веса неотрицательны. Опять-таки,
[41:59.640 --> 42:20.600]  ищем расстояние от 1 до всех. Алгоритм можно написать так. В каждое время у меня все вершины
[42:20.600 --> 42:29.200]  делятся на две группы. Использованные и неиспользованные. Использованные – это,
[42:29.200 --> 42:34.240]  как бы, для которых мы уже нашли дист. Мы знаем, что, ну, то есть корректный дист, да, дист,
[42:34.240 --> 42:39.480]  который мы нашли равен настоящему расстоянию. Вот. И мы их уже как бы все обработали. Это,
[42:39.480 --> 42:48.000]  значит, обработанные. Для них мы уже знаем, то есть нам известен дист. Известен дист.
[42:48.000 --> 42:55.360]  Вот. Они использованы. Это те, для которых у нас есть только оценка на дист. Вот, например,
[42:55.360 --> 43:02.880]  в 0kbfs я, когда раскрываю еще одну вершинку, я по факту нахожу некоторые оценки на дист для
[43:02.880 --> 43:07.440]  концов ребер. То есть я, когда вот рассматриваю v, рассматриваю все исходящие из нее ребра,
[43:07.440 --> 43:12.760]  я знаю, что до этих вершинок есть какие-то пути. То есть я сначала от s кратчайшим путем добираюсь
[43:12.760 --> 43:16.480]  до v, потом использую это ребро. Понятно, что это не обязательно кратчайшее расстояние. Но это
[43:16.480 --> 43:21.520]  оценка на кратчайшее расстояние сверху. То есть это какой-то путь, который есть в графе,
[43:21.520 --> 43:26.240]  который больше равен, чем настоящий дист. Вот. Соответственно, для этих вершин я знаю только
[43:26.240 --> 43:38.280]  какие-то оценки на дист. Известны оценки на дист. Значит, тогда, говорит, там работает так. На каждом
[43:38.280 --> 43:42.920]  шаге из всех неиспользованных я выбираю вершину с минимальной вот этой вот оценкой. То есть вершина,
[43:42.920 --> 43:55.000]  для которой текущий известный дист минимально возможен. Выбираем неиспользованную v с минимальным
[43:55.000 --> 44:00.360]  дист от v. То есть, как всегда, в массиве дист от v у меня хранятся текущие найденные оценки на
[44:00.360 --> 44:05.640]  настоящее расстояние диста от s до v. Из всех неиспользованных вершин v я выбираю ту,
[44:05.640 --> 44:13.480]  у которой минимальная вот эта вот оценка. Ну и объявляю это настоящим дистом. Говорим,
[44:13.480 --> 44:24.960]  что эта, собственно, оценка и равна настоящему ответу. Потом вершину v помечаем использованной
[44:24.960 --> 44:39.040]  и раскрываем. Помечаем v использованной. Ну то есть переносим ее вот в этом множество и раскрываем.
[44:39.040 --> 44:54.840]  То есть, опять рассматриваем все исходящие ребра ведущие из v. Для всех концов этих ребер
[44:54.840 --> 45:00.360]  пытаемся обновить оценку на дист. То есть, скажем, для этой вершины, если я раньше знал какой-нибудь
[45:00.360 --> 45:04.560]  вот такой вот путь до нее, то, возможно, теперь я нашел более оптимальный. Ну, как обычно. То есть,
[45:04.560 --> 45:09.400]  у нас, возможно, был какой-то путь до этого, а сейчас я узнал более короткий. И этим более
[45:09.400 --> 45:17.480]  коротким путем я обновил дист для этой вершинки. Все, весь алгоритм. В конце утверждается, что все
[45:17.480 --> 45:21.040]  достиженные вершинки будут помечены использованными, и для них будет найден корректный дист.
[45:21.040 --> 45:44.080]  Давай сначала с этим дотикой разберемся. Ну, тут есть две реализации. Обе бывают полезными. Самое
[45:44.080 --> 45:50.560]  простое — работать за квадрат. За n квадрат. Потому что, смотрите, по факту что мне нужно сделать?
[45:50.560 --> 45:56.400]  Мне нужно n раз. У меня не больше чем n итерации, потому что, ну, каждая итерация перемещает одну
[45:56.400 --> 46:02.120]  вершинку отсюда-сюда. Итерация не больше чем n. На итерации мне нужно найти вершину с минимальным
[46:02.120 --> 46:07.000]  дистом среди неиспользованных. Но для этого достаточно по ним по всем пробежаться и выбрать
[46:07.000 --> 46:14.080]  минимум просто. Заделся за линию, за отn. А затем мне нужно еще ее раскрыть. То есть, по факту,
[46:14.080 --> 46:19.360]  у меня сначала поиск минимума, потом раскрытие. Поэтому такая симптотика, такой алгоритм работает
[46:19.360 --> 46:25.560]  за n квадрат плюс m. Давайте я напишу один раз. Вот так вот. Потому что у меня n итерации, на каждой
[46:25.560 --> 46:30.040]  итерации я за линию нахожу минимум, и потом еще раскрываю все вершины. Но поскольку каждая
[46:30.040 --> 46:34.320]  вершина раскроется только единожды, значит, каждое ребро рассмотрится только один раз. Значит,
[46:34.320 --> 46:44.880]  суммарный вклад всех раскрытий от m. Но мы живем как бы в парадигме, что у нас m, ну давайте я так
[46:44.880 --> 46:57.720]  напишу, по порядку это хотя бы n и не больше m квадрат. Потому что если m меньше чем n,
[46:57.720 --> 47:03.720]  то понятно, что граф не связанный, и можно тогда решить задачу на какой-то связанной компоненте
[47:03.720 --> 47:09.800]  отдельной. Потому что если m меньше, ну меньше m-1, тогда граф не связанный, даже из s не все
[47:09.800 --> 47:14.360]  достижимо. Значит, сначала мы тогда на первом шаге можем оставить только то, что достижимо из s,
[47:14.360 --> 47:18.640]  и потом уже на этой компоненте связанно что-то делать. И тогда уже будет как раз верно вот это
[47:18.640 --> 47:25.400]  соотношение, что в связанном графе ребер хотя бы n-1. Иначе я могу сузиться на компонент
[47:25.400 --> 47:30.320]  связанности. Ну а и m не больше m квадрат, потому что мы считаем, что граф у нас простые, то есть
[47:30.320 --> 47:37.360]  без кратных ребер. Значит, вообще m не больше, чем n-1 в случае ориентированного графа, потому что
[47:37.360 --> 47:49.280]  нет кратных ребер. Ну поэтому здесь достаточно оставить n квадрат, у меня получается d x из 1 квадрат.
[47:49.280 --> 47:58.400]  Вот, вторая реализация требует времени m log n и работает, если мы будем использовать,
[47:58.720 --> 48:11.120]  например, бинарную кучу. Используем бинарную кучу. Потому что, смотри, давайте поймем, что нам
[48:11.120 --> 48:16.160]  вообще нужно. Вот здесь, когда мы работаем с неиспользованными вершинами, что нам нужно? Мне
[48:16.160 --> 48:22.000]  нужно уметь находить вершину с минимальным, то есть по сути находить минимум, вот здесь, в этом множестве.
[48:22.000 --> 48:27.680]  Извлекать его, то есть удалять, перемещать из неиспользованных в использованные, надо найти
[48:27.680 --> 48:33.520]  минимум, удалить минимум. И вот раскрытие вершины, это, на самом деле, декрестки, несколько декрестки,
[48:33.520 --> 48:39.840]  потому что что такое раскрытие? Это попытка улучшить оценку диста досюда через там какое-то значение.
[48:39.840 --> 48:46.560]  Но если я дисты воспринимаю в качестве ключей, то есть как раз то, что в куче хранится,
[48:46.560 --> 48:51.920]  тогда я их могу только уменьшать. Если у меня уже есть какая-то оценка, то я эту оценку могу
[48:51.920 --> 48:56.480]  только уменьшать, нет смысла увеличивать, потому что я путь только как бы, ну, все более-более короткий
[48:56.480 --> 49:02.600]  и нахожу все более-более оптимально. Значит, мне в куче надо уметь делать, в нашей структуре надо
[49:02.600 --> 49:11.480]  уметь делать декрестки, но это куча просто. Extract-min, get-min и декрестки это куча, все работает за алгоритм.
[49:11.480 --> 49:23.760]  Давайте напишем, что мне здесь нужно. То есть как бы храним кучу неиспользованных вершин,
[49:23.760 --> 49:45.840]  упорядоченных по дист. Значит, тогда мне нужно N раз уметь делать get-min, N раз уметь делать
[49:45.840 --> 49:59.840]  Extract-min и maximum-M раз уметь делать декрестки, потому что декрестки столько, сколько ребер в графе максимум.
[49:59.840 --> 50:07.840]  Вот, каждый из этих штук работает максимум за алгоритм, ну, get-min вообще за единицу, Extract-min за от
[50:07.840 --> 50:14.240]  алгоритма N, декрестки за от алгоритма N. Поэтому в предположении, что M по порядку хотя бы N,
[50:14.240 --> 50:20.240]  здесь основной слогами будет вот это, M log N. То есть там еще будет M log N, но оно несущественно по сравнению с M log N.
[50:20.240 --> 50:28.240]  Поэтому как раз-таки вот эта штука дает нам такой, собственно, вставляющуюся методики M log N.
[50:29.240 --> 50:41.240]  Окей? Вот. Ну, еще для общего развития скажу, что есть не только бинарная куча, например, фибоначьего куча.
[50:41.240 --> 50:54.240]  Так, фибоначьего куча. Это что-то, что основывается там на биномиальной куче, как-то там оно в каком-то смысле
[50:54.240 --> 51:00.240]  ленивая реализация биномиальной кучи, то есть он какие-то операции откладывает на потом, и за счет этого получается лучшая
[51:00.240 --> 51:08.240]  оценка времени работы. Так вот там давайте напишем, за сколько работают все эти операции. Ну, get-min, как, в общем-то,
[51:08.240 --> 51:14.240]  всегда можно всегда реализовать за единицу, потому что можно просто поддерживать указатель на минимум.
[51:15.240 --> 51:18.240]  Экстракт-мин работает за учетную единицу.
[51:23.240 --> 51:25.240]  Нет, get-min за единицу.
[51:32.240 --> 51:40.240]  Значит, экстракт-мин за амортизированную единицу, а декрески, нет, здесь логарифм, извините, здесь логарифм амортизированный,
[51:40.240 --> 51:47.240]  вот декрески за амортизированную единицу работают, декрески за амортизированную единицу.
[51:47.240 --> 51:55.240]  Значит, там идея такая, если вы вдруг помните, как работает там биномиальная куча, как у нас работают декрески.
[51:55.240 --> 52:03.240]  Значит, ну вот мы находим какую-то вершинку, мы ее, мы уменьшаем у нее ключ и хотим как бы ее поднимать наверх,
[52:03.240 --> 52:08.240]  ну сифтап сделать для нее. Так вот фибоначевая куча вместо этих сифтапов мы обычно можем просто вырезать все ее,
[52:08.240 --> 52:13.240]  все вот это вот под дерево и назначить это очередным деревом.
[52:13.240 --> 52:19.240]  Тогда это, соответственно, у меня уже перестанет быть биномиальным деревом, ну будет что-то похожее на биномиальное дерево.
[52:19.240 --> 52:26.240]  То есть я просто беру вот это вот под дерево, вырезаю его целиком из предыдущего под дерево и назначаю это очередным корнем.
[52:26.240 --> 52:30.240]  То есть это как бы очередное дерево в списке деревьев.
[52:30.240 --> 52:34.240]  И там, если все это достаточно хитро сделать, получится учетное стоимость единицу на такой запрос,
[52:34.240 --> 52:39.240]  потому что это работает за единицу, там, высплетить и подвесить к списку корней.
[52:39.240 --> 52:47.240]  Так вот если делать достаточно хитро, то есть там еще что-то поддерживать, то это будет учетная единица, амортизированная единица.
[52:47.240 --> 52:55.240]  Ну и тогда симптотика здесь будет, смотрите, если я перемножу, тут будет n, тут будет n лог n, тут будет m.
[52:55.240 --> 53:03.240]  Поэтому суммарно будет m плюс n лог n. Вот такой прикол.
[53:03.240 --> 53:11.240]  Да, и это может быть лучше, чем обычная реализация бинарной кучей.
[53:11.240 --> 53:17.240]  Ну понятно, потому что если m достаточно большой, то я m не умножаю на алгорифм, а только n умножаю на алгорифм.
[53:17.240 --> 53:21.240]  Ну понятно, что это может быть выгодно.
[53:21.240 --> 53:27.240]  То есть как бы иллюстрация того, что если мы какие-то более крутые структуры разрабатываем,
[53:27.240 --> 53:31.240]  то мы можем вот такие классические алгоритмы типа dx улучшать дотику.
[53:31.240 --> 53:39.240]  Это в принципе довольно хорошо.
[53:39.240 --> 53:51.240]  Так, ну теперь корректность.
[53:51.240 --> 53:59.240]  Почему мы тут все правильно сделаем?
[53:59.240 --> 54:03.240]  Корректность.
[54:03.240 --> 54:09.240]  Ну я хочу доказать, что все вот эти вот перетаскивания вершины из неиспользованных в использованные,
[54:09.240 --> 54:16.240]  то есть вот пометка вершины использованной, они как бы всегда правильные, что в этот момент у меня реально вот это вот верно.
[54:16.240 --> 54:20.240]  Что все вот эти вот, мы говорим что, эти всегда верны.
[54:20.240 --> 54:26.240]  Что когда я перетаскиваю вершину из неиспользованных в использованные, я всегда уже правильно для нее нашел дист.
[54:26.240 --> 54:31.240]  Ну опять доказываем эту индукцию по количеству итераций в нашем алгоритме,
[54:31.240 --> 54:39.240]  по количеству этих перетаскиваний из неиспользованных в использованные.
[54:39.240 --> 54:43.240]  И здесь нам надо заметить следующее.
[54:43.240 --> 54:48.240]  Что вот по дороге, пока мы все это делаем, выполняет следующее соотношение.
[54:48.240 --> 55:08.240]  Значит пусть у неиспользованная, но такая, что существует кратчайший путь до нее из s, не использующий других неиспользованных вершин.
[55:08.240 --> 55:22.240]  Существует кратчайший путь от s до u, который не посещает других неиспользованных вершин.
[55:22.240 --> 55:37.240]  То есть у такая крутая, что путь до нее, ну по крайней мере один из кратчайших путей до нее выглядит вот так.
[55:37.240 --> 55:41.240]  То есть я сначала кратчайшую петляю, потом за одно ребро сразу перемещаюсь в u и заканчиваю.
[55:41.240 --> 55:44.240]  То есть я не использую никаких других вершин отсюда.
[55:44.240 --> 55:47.240]  Только несколько использованных, потом последнее ребро в u.
[55:47.240 --> 55:55.240]  Так вот тогда, это совсем просто, тогда мы уже нашли до нее корректный дист.
[55:55.240 --> 56:04.240]  То есть если есть такой путь, то мы его нашли и наша оценка совпадает с правильным ответом.
[56:04.240 --> 56:14.240]  Ну вроде как бы это очевидно, доказываем это утверждение по индукции вместе с корректностью нашего алгоритма.
[56:14.240 --> 56:20.240]  Если в этот момент в времени эти все использованные, значит вот эта тоже использована, значит для нее правильный найден дист.
[56:20.240 --> 56:29.240]  И она уже раскрыта. Ну а когда она раскрывалась, она как раз передала вот сюда вот в u длину этого пути плюс вес этого ребра.
[56:29.240 --> 56:34.240]  А если этот путь кратчайший, то получается, что мы в u положили дист s у, на профит.
[56:34.240 --> 56:41.240]  То есть если есть путь неиспользующий неиспользованных, тогда мы его уже обнаружили.
[56:41.240 --> 56:46.240]  И значит если что, мы эту вершину можем сразу помечать использованной.
[56:46.240 --> 57:04.240]  Вот, значит это мы заметили тривиальным образом, значит теперь докажем, что вот та вот вершина v выбираем алгоритмом.
[57:11.240 --> 57:16.240]  Действительно удовлетворяет вот этому равенству, что оценка, которую мы нашли совпадает с дистом настоящим.
[57:16.240 --> 57:30.240]  Удовлетворяет равенству дист, найденное равно правильному значению.
[57:30.240 --> 57:44.240]  То, что мы хотим доказать, что все вот эти вот перетаскивания, то есть когда я вершину v нашел на очередном шаге, извлек минимум из кучи, это уже правильный ответ, для него уже правильно посчитано на расстояние.
[57:44.240 --> 57:51.240]  Так вот, ну почему это так? Пусть не так, давайте от противного пойдем, пусть не так.
[57:51.240 --> 58:04.240]  Тогда, если тут не равенство, то здесь значок больше будет. То есть оценка, которую мы нашли, строго больше, чем настоящее расстояние диста с v.
[58:04.240 --> 58:13.240]  Ну меньше быть не может, потому что все, что мы находим, это только оценка сверху на расстояние. Все, что мы находим в дист кладем, это по факту какие-то пути в графе.
[58:13.240 --> 58:23.240]  То есть мы, дист, там не случайных значений, это обязательно какие-то пути до вершины v, поэтому меньше, чем настоящее расстояние быть не могут.
[58:23.240 --> 58:28.240]  Они всегда больше либо равны, но если не равно, то строго больше.
[58:28.240 --> 58:36.240]  Хорошо, давайте тогда рассмотрим какой-нибудь настоящий, кратчайший путь до v, вот этот кратчайший, настоящий путь.
[58:36.240 --> 58:50.240]  Так, оставлю на картинке, рассмотрим настоящий, кратчайший путь из s в v.
[58:50.240 --> 58:55.240]  Как он выглядит?
[58:55.240 --> 59:05.240]  Ну он как-то там петляет поиспользованным, потом, возможно, прыгает внеиспользованные, как-то здесь ходит, возможно, возвращается назад, ну и так далее, зато в конце доходит до v.
[59:05.240 --> 59:08.240]  Какой-то сложный путь.
[59:08.240 --> 59:20.240]  Но давайте рассмотрим первую вершину в этом пути, которая неиспользованная, то есть я сначала хожу по использованным и вот первый прыжок внеиспользованный, давайте я обозначу эту вершинку за u.
[59:20.240 --> 59:27.640]  пути от s до v, первая неиспользованная. Значит понятно, что если u равно v, то вот это вот верно,
[59:27.640 --> 59:33.800]  и мы уже победили на противоречие с предположением. То есть если v это сама по себе первая неиспользованная,
[59:33.800 --> 59:38.520]  то для нее вот этого неравенства быть не может. Мы уже доказали, что для нее точно равенство
[59:38.520 --> 59:44.800]  выполняется. Значит u и v это разные вершины, но тогда смотрите, раз u это, давайте напишу, что u это
[59:44.800 --> 59:57.400]  первая неиспользованная на этом пути. Значит по замещанию, который я выше сделал, то что там
[59:57.400 --> 01:00:16.880]  уже лежит оценка, это правильное расстояние distance u. Понятное дело, что эта штука меньше
[01:00:16.880 --> 01:00:27.240]  равна distance v, потому что если u лежит на коротчайшем пути отсюда до сюда, то понятное дело,
[01:00:27.240 --> 01:00:32.760]  что вот начало это коротчайший путь до u. То есть я сначала коротчайшим путем дошел до u, а потом
[01:00:32.760 --> 01:00:37.120]  еще каким-то образом дошел до v. Понятно, что если это не коротчайший путь, то его можно было бы
[01:00:37.120 --> 01:00:42.720]  сократить, и тогда у меня бы уменьшился путь до v. Поэтому то, что я здесь прохожу, это очевидно
[01:00:42.720 --> 01:00:48.240]  коротчайший путь от s до u. И значит он по весу не больше, чем путь от s до v, потому что там
[01:00:48.240 --> 01:00:53.680]  еще были какие-то ребра не отрицательного веса. Значит расширение пути только увеличивает дист.
[01:00:53.680 --> 01:00:58.720]  Но это не разница тривиальна, если все ребра реально не отрицательные. Вот, но это по предположению
[01:00:58.720 --> 01:01:08.720]  меньше, чем дист от v. В итоге мы получили, что оценка на u меньше, чем оценка на v. Значит в
[01:01:08.720 --> 01:01:21.400]  алгоритме u должна была бы достаться из кучи раньше, чем v. Следовательно u должна быть извлечена из кучи
[01:01:21.400 --> 01:01:48.840]  раньше, чем v. Противоречие. Вот вроде все доказал. Вопросы? Кайф.
[01:01:51.400 --> 01:02:04.280]  Заметьте, здесь было принципиально важно, что все ребра не отрицательны. Потому что если бы
[01:02:04.280 --> 01:02:09.120]  ребра были отрицательного веса, у меня бы, например, вот это не раз не сработало. Ну и вообще как бы
[01:02:09.120 --> 01:02:15.480]  тогда, тогда весь алгоритм не работает на самом деле. Что же делать с отрицательными ребрами? Пока что
[01:02:15.480 --> 01:02:22.240]  у нас ни один из алгоритмов не умеет с ними справляться. Давайте вообще поймем, что нам дают
[01:02:22.240 --> 01:02:30.600]  отрицательные ребра. На самом деле они иногда делают так, что кратчайшее состояние в принципе не
[01:02:30.600 --> 01:02:35.120]  определено. В том смысле, что его можно сделать сколь угодно большим по модуле отрицательным.
[01:02:35.120 --> 01:02:39.760]  Минус 10, минус 100, минус 1000, минус 10 тысяч и так далее. Сколь угодно большим по модуле
[01:02:39.760 --> 01:02:49.440]  отрицательным. Сколь угодно близким к минусу бесконечности. В присутствии в наличии отрицательных
[01:02:49.440 --> 01:03:02.560]  ребер в графе DIST, ну там ST, в соответствии с нашим старым определением, может быть
[01:03:02.560 --> 01:03:14.400]  некорректно определено, а может быть не определено. Ну вот на самом деле я тогда
[01:03:14.400 --> 01:03:22.600]  утверждаю, что по факту это означает, что DIST равен минус бесконечности, то есть я могу
[01:03:22.600 --> 01:03:30.520]  набрать там сколь угодно большой по модуле отрицательный путь. Нет, про простоту нет,
[01:03:30.760 --> 01:03:36.920]  нигде требований. То есть возможно мы там какие-то циклы наматываем. Так вот, в этом случае DIST я
[01:03:36.920 --> 01:03:44.120]  могу объявить равным минус бесконечности, и это по факту означает, что существует цикл отрицательного
[01:03:44.120 --> 01:03:58.360]  веса, цикл C отрицательного веса, ну такой, что он достижим из S и из него достижимо T. То есть
[01:03:58.360 --> 01:04:03.440]  картинка как бы очень тривиальная. Мы сначала из S до кого-то доходим, потом начинаем сколь угодно
[01:04:03.440 --> 01:04:08.960]  долго петлять по циклу отрицательного веса, то есть суммарный вес всех этих ребер меньше нуля,
[01:04:08.960 --> 01:04:17.480]  на вес вот C меньше нуля, и потом я дохожу до T. Ну понятно тогда, что как бы вес можно сделать
[01:04:17.480 --> 01:04:21.680]  сколь угодно большим по модуле отрицательным. Что я говорю, минус здесь, минус 100, минус 1000 и так
[01:04:21.680 --> 01:04:28.360]  далее. Вот, и это я утверждаю единственный способ, когда DIST может быть ну вот так неопределен,
[01:04:28.360 --> 01:04:34.240]  то есть как бы быть с минус бесконечностью по факту. Вот, значит почему здесь я могу поставить
[01:04:34.240 --> 01:04:39.000]  эквивалентность? Ну понятно, что справа налево это очевидно, если такая картинка есть, то реально
[01:04:39.000 --> 01:04:43.720]  DIST можно сделать сколь угодно большим по модуле отрицательно. Дошел, пропетлял столько, сколько надо
[01:04:43.720 --> 01:04:50.240]  раз, достаточно уменьшился, и потом дошел до T. Понятно, что я могу любое наперед заранее, как бы
[01:04:50.240 --> 01:04:57.040]  любое наперед заранее число набрать в качестве веса вот здесь. В обратную сторону, почему если
[01:04:57.040 --> 01:05:06.160]  DIST снизу не ограничен, то обязательно есть цикл? Ну, тут можно такое рассуждение провести, что
[01:05:06.160 --> 01:05:18.760]  значит пусть все веса-рёбер по модуле не превосходят какого-то C, по модуле не превосходят C,
[01:05:18.760 --> 01:05:30.400]  то есть это я сейчас доказываю пункт слева направо, что если DIST не ограничен, то реально есть такой цикл
[01:05:30.400 --> 01:05:35.800]  между ними. Так вот, пусть все веса-рёбер ограничены по модуле к значениям C, понятно, что такое C существует,
[01:05:35.800 --> 01:05:52.280]  потому что w это функция, ну как бы из конечного множества в r. Вот, значит тогда посмотрим путь из S в T
[01:05:52.280 --> 01:06:08.240]  веса меньше, чем минус Cn с минимальным числом рёбер. То есть да, поскольку я знаю, что по
[01:06:08.240 --> 01:06:13.040]  предположению DIST не ограничен, то значит для любой задно-наперед константы я могу набрать
[01:06:13.040 --> 01:06:21.120]  вес, могу набрать путь веса меньше такого, меньше минус Cn. Из всех таких я выбираю путь с
[01:06:21.120 --> 01:06:27.200]  минимальным числом рёбер. Вот. Ну тогда что? Тогда поскольку у меня здесь вес меньше минус Cn,
[01:06:27.200 --> 01:06:37.520]  то в нем обязательно есть цикл. То есть картинка точно выглядит как-то вот так. Потому что если у меня
[01:06:37.520 --> 01:06:43.800]  все ребра по весу не происходят по модулю, а суммарный вес меньше минус Cn, то рёбер точно по крайней
[01:06:43.800 --> 01:06:49.600]  мере n, даже по крайней мере n плюс 1, если тут строгий значок, значит у меня точно вершины
[01:06:49.600 --> 01:06:55.760]  повторяются, поэтому я когда-то в цикл точно войду. Вот. Но при этом, смотрите, если у меня вес
[01:06:55.760 --> 01:07:01.320]  меньше минус Cn и рёбер минимально возможное количество, тогда этот цикл точно отрицательного веса,
[01:07:01.320 --> 01:07:08.480]  потому что если бы он был нетрицательного веса, я мог бы его отбросить и получить путь опять вес
[01:07:08.480 --> 01:07:14.560]  не больше, чем минус Cn и с меньшим числом рёбер. Противоречие. Значит на этом цикле обязательно
[01:07:14.560 --> 01:07:41.040]  отрицательный вес. Обязательно отрицательный вес. Окей? Так, ну чудно. Как же тогда жить с
[01:07:41.040 --> 01:07:51.760]  этими отрицательными циклами и с отрицательными рёберами вообще? Здесь нам нужен алгоритм Форда
[01:07:51.760 --> 01:08:08.240]  Белмана. Алгоритм Форда Белмана. Тут опять мы ищем крошайшие пути от одной до всех,
[01:08:08.240 --> 01:08:13.000]  но весовая функция произвольная. То есть тут уже нет ограничений, что все веса не отрицательные,
[01:08:13.000 --> 01:08:20.360]  веса могут быть отрицательными. Значит w функции с g в r, уже любая без ограничений, ну и ищем
[01:08:20.360 --> 01:08:43.480]  расстояние от s до всех. Вот. Значит тут работает очень простая динамика на самом деле. Смотрите,
[01:08:43.480 --> 01:08:53.280]  давайте мы введем dp в этой каты. Это длина, минимальная длина пути из s в использующей
[01:08:53.280 --> 01:09:06.400]  не больше чем k рёбер. Минимальная длина пути из s в использующей не больше k рёбер. Я насильно
[01:09:06.400 --> 01:09:11.960]  ограничиваю число возможных доступностей для использования рёбер, только максимум k. Вот.
[01:09:11.960 --> 01:09:17.440]  И в этом предположении считаю все крошайшие обстояния. Ввожу такую дпшку. Значит насчитывается
[01:09:17.440 --> 01:09:25.880]  она тривиально. dp v нулевое, это когда я не могу использовать рёбер вообще. Все пути должны
[01:09:25.880 --> 01:09:31.400]  состоять из нуля рёбер. Тогда dp очень просто определяется. Это 0 в случае, когда v равно s,
[01:09:31.400 --> 01:09:39.440]  и плюс бесконечный в случае, когда v не равно s. Ну потому что если я могу использовать только
[01:09:39.440 --> 01:09:44.640]  0 рёбер, то я могу только стоять на месте, а значит я могу только в s находиться, и тогда расстояние
[01:09:44.640 --> 01:09:50.320]  равно нулю. Иначе я никуда добраться не могу, и туда считаю, что путь имеет иную плюс бесконечность.
[01:09:50.320 --> 01:09:54.560]  Вот. Теперь переход. Переход от k в основе k плюс 1.
[01:09:54.560 --> 01:10:05.560]  Например, давайте предположим, что я знаю все расстояния из использующей не больше чем k рёбер.
[01:10:05.560 --> 01:10:10.760]  Теперь я могу добавить к ним одно рибро новое. То есть я могу ко всем путям длины, точнее использующим
[01:10:10.760 --> 01:10:16.640]  не больше чем k рёбер, могу добавить еще одно новое k плюс первое. Но давайте поймем, что такое
[01:10:16.640 --> 01:10:24.520]  например dp в это k плюс первое. dp в это k плюс первое. Ну, во-первых, я могу использовать по-прежнему
[01:10:24.520 --> 01:10:33.680]  не больше чем k рёбер. То есть одно из потенциальных значений, это просто dp в это k. Это когда
[01:10:33.680 --> 01:10:40.240]  я использую не больше чем k рёбер. Либо же, второй случай, я использую в точности k плюс 1 рибро.
[01:10:40.240 --> 01:10:49.280]  Давай тогда рассмотрю последнее. Вот что такое последнее рибро? В используешь k плюс 1 рибро.
[01:10:49.280 --> 01:10:59.480]  Значит, ну это какое-то рибро у В, какого-то веса, да, там кост. Ну и тогда, чтобы попасть в В за
[01:10:59.480 --> 01:11:08.120]  k плюс 1 рибро, мне нужно сначала в У попасть за k рёбер. А это я уже знаю, это dp ut kt. Поэтому здесь
[01:11:08.120 --> 01:11:17.800]  вторая опция, это мне нужно перебрать всевозможные входящие рёбра у В. У В это ребро графа. Здесь
[01:11:17.800 --> 01:11:32.440]  значение равно dp ut kt плюс стоимость ребра у В. Давайте напишем кост ut vt. Очень простой
[01:11:32.440 --> 01:11:36.760]  переход. То есть я либо использую не больше чем k рёбер, либо использую вот это k плюс 1
[01:11:36.760 --> 01:11:43.680]  рибро. Его просто перебираю. Перебираю всевозможные входящие рёбра в В. И если я знаю начало вот
[01:11:43.680 --> 01:11:49.440]  ребра У, то я, получается, сначала должен из С попасть в У за k рёбер, это dp, уже известное,
[01:11:49.440 --> 01:11:57.480]  плюс вес последнего ребра. Вот такой простой пересчёт нашей динамики.
[01:12:13.680 --> 01:12:29.560]  Так, простое замечание. Если в графе нет отрицательных циклов, то нам достаточно посчитать
[01:12:29.560 --> 01:12:44.840]  все слои вплоть до n-1. Если в G нет отрицательных циклов, ну то есть циклов отрицательного веса,
[01:12:44.840 --> 01:12:49.960]  циклов, что их вес, суммарный вес всех рёберов на них меньше нуля. Так вот, если таких циклов нету,
[01:12:49.960 --> 01:13:06.120]  то dp в это n-1 всегда в точности равно distance v. То есть нам достаточно сделать n-1 переход в
[01:13:06.120 --> 01:13:15.160]  нашей динамике, и мы тогда найдём все кратчайшие стоения. Начну это просто, потому что если
[01:13:15.160 --> 01:13:20.440]  отрицательных циклов нету, то истинно настоящий правильный путь, кратчайший, очевидно, содержит не
[01:13:20.440 --> 01:13:30.920]  больше н-1 ребро. Потому что если он содержит хотя бы n-1, то он обязательно зацикливается. Если он
[01:13:30.920 --> 01:13:36.520]  использует хотя бы n-1, то значит в нём какая-то вершина посещена хотя бы дважды, значит мы точно
[01:13:36.520 --> 01:13:43.120]  какой-то кусок проходим, ну короче какой-то цикл у нас на пути есть. А если циклов отрицательных
[01:13:43.120 --> 01:13:49.760]  нету, то получается вес этого цикла не отрицательный, его можно смело отбросить, только улучшив наш дист.
[01:13:49.760 --> 01:13:54.320]  Поэтому не было смысла нам петлять тут по циклу. Значит если реально нет отрицательных циклов,
[01:13:54.320 --> 01:14:01.760]  то мы наверное в первом шаге найдём все правильные дисты. Значит насколько это работает? Это работает
[01:14:01.760 --> 01:14:17.120]  очевидно за nm. Потому что у меня n слоёв, n переходов в динамике, ну и каждый переход, каждый слой я
[01:14:17.120 --> 01:14:24.080]  по факту вот здесь вот перебираю все вешки и перебираю все ребра. Ну это как раз m, за отm работает,
[01:14:24.080 --> 01:14:28.400]  потому что по факту мне нужно просто все ребра в графе перебрать. Вот он, то есть я для каждой вершины
[01:14:28.560 --> 01:14:35.600]  перебиваю все входящие ребра. Это отm. Перебиваю просто все входящие ребра. Вот, поэтому у меня столько
[01:14:35.600 --> 01:14:53.040]  слоёв в динамике, слоёв dp, ну а это время подсчёта очередного слоя. Время на слой, вот. Ну и там как
[01:14:53.040 --> 01:14:59.520]  обычно можно сказать, что нам на самом деле достаточно вот и вот столько времени и, скажем, от n памяти
[01:15:02.640 --> 01:15:07.720]  потому, что как это часто у нас бывает k плюс первый слой выщипывается только через ל�-катый,
[01:15:07.720 --> 01:15:11.560]  поэтому нам достаточно только два слоя хранить, предыдущий и следующий, и, поэтому нам
[01:15:11.560 --> 01:15:16.900]  памяти достаточно линейное количество. То есть у меня динамика двумерная и n на n получается.
[01:15:16.900 --> 01:15:20.680]  Но на самом деле мне достаточно только два слоя хранить, поэтому на самом деле достаточно линии памяти.
[01:15:20.680 --> 01:15:30.680]  Времени-то? Да нет.
[01:15:30.680 --> 01:15:34.680]  Для каждой вершины я перебираю второй карандат и все входящие ребра.
[01:15:34.680 --> 01:15:39.680]  То есть я для каждой вершины по факту вот здесь, вот эта формула работает за число входящих ребров v.
[01:15:39.680 --> 01:15:42.680]  Потому что я просто здесь все перебираю.
[01:15:42.680 --> 01:15:49.680]  Поэтому вот если у меня k и капли с ними фиксировано, то суммарно вот эта штука по всем v работает за от m.
[01:15:49.680 --> 01:15:52.680]  Потому что я для каждой вершины рассматриваю все входящие ребра.
[01:15:52.680 --> 01:15:56.680]  То есть я рассматриваю по факту просто все ребра, их линия, их m.
[01:15:56.680 --> 01:15:59.680]  И так делаю n раз, потому что мне нужно от 0 перейти...
[01:15:59.680 --> 01:16:03.680]  от кара в 0 перейти кара в 1, потом к 2 и так далее вплоть до n-1.
[01:16:03.680 --> 01:16:08.680]  n переходов каждый за m работает.
[01:16:08.680 --> 01:16:17.680]  Так, значит, без отрицательных циклов мы разобрались.
[01:16:17.680 --> 01:16:19.680]  Но что с отрицательными циклами?
[01:16:22.680 --> 01:16:27.680]  Ну, можно игнорировать, конечно, но можно полностью здесь все разобрать.
[01:16:27.680 --> 01:16:29.680]  Сейчас разберем.
[01:16:34.680 --> 01:16:36.680]  Да-да-да, абсолютно правильно.
[01:16:37.680 --> 01:16:39.680]  Так мы и сделаем.
[01:16:39.680 --> 01:16:42.680]  Значит, теперь считаем, что отрицательные циклы могут быть.
[01:16:43.680 --> 01:16:46.680]  Теперь считаем, что могут быть отрицательные циклы.
[01:16:48.680 --> 01:16:53.680]  Что могут быть отрицательные циклы.
[01:16:55.680 --> 01:17:01.680]  Тогда я сделаю еще одну насильную итерацию нашей динамики.
[01:17:01.680 --> 01:17:03.680]  То есть я еще насильно посчитаю n-т слой.
[01:17:06.680 --> 01:17:10.680]  Насчитаем dp на n-м слой.
[01:17:10.680 --> 01:17:12.680]  То есть для всех вершин посчитаю dp в это n-т.
[01:17:18.680 --> 01:17:20.680]  Утверждение.
[01:17:23.680 --> 01:17:35.680]  Если c отрицательный цикл, то, по крайней мере, для одной вершины этого цикла,
[01:17:35.680 --> 01:17:37.680]  существует хотя бы одна вершина на этом цикле,
[01:17:37.680 --> 01:17:40.680]  для которой dp уменьшилось.
[01:17:41.680 --> 01:17:47.680]  Дп в это n-е стало строго меньше, чем dp в это n-1.
[01:17:54.680 --> 01:17:58.680]  То есть если я сделаю всего лишь еще одну итерацию,
[01:17:58.680 --> 01:18:00.680]  то есть много не надо, мне одной хватит.
[01:18:00.680 --> 01:18:02.680]  Если я сделаю всего одну лишнюю итерацию,
[01:18:02.680 --> 01:18:05.680]  то у меня на каждом цикле я обнаружу, по крайней мере,
[01:18:05.680 --> 01:18:07.680]  одну вершину, у которой dp уменьшилось.
[01:18:07.680 --> 01:18:09.680]  Понятно, что в отсутствии отрицательных циклов
[01:18:09.680 --> 01:18:10.680]  такого быть не может.
[01:18:10.680 --> 01:18:13.680]  Мы уже доказали вот здесь, что если у меня циклов отрицательных нет,
[01:18:13.680 --> 01:18:15.680]  то, наверное, в первом шаге я нашел правильный ответ.
[01:18:15.680 --> 01:18:17.680]  И тогда здесь было бы равенство,
[01:18:17.680 --> 01:18:19.680]  потому что если бы я позволил еще одно ребро,
[01:18:19.680 --> 01:18:21.680]  если бы я сделал еще один переход в динамике,
[01:18:21.680 --> 01:18:23.680]  у меня бы dp не изменилось,
[01:18:23.680 --> 01:18:25.680]  потому что нет смысла использовать n на ребро,
[01:18:25.680 --> 01:18:27.680]  если нет отрицательных циклов.
[01:18:27.680 --> 01:18:29.680]  А вот если они есть, тогда на каждом цикле я найду,
[01:18:29.680 --> 01:18:31.680]  по крайней мере, одну вершину, для которой dp уменьшилось.
[01:18:33.680 --> 01:18:35.680]  Ну и тогда давайте я напишу алгоритм.
[01:18:35.680 --> 01:18:37.680]  Это утверждение я уже докажу на следующей лекции.
[01:18:37.680 --> 01:18:39.680]  А сейчас напишу алгоритм.
[01:18:41.680 --> 01:18:47.680]  Мы запускаем dp до n-ного слоя,
[01:18:51.680 --> 01:18:56.680]  дальше находим множество вершин,
[01:18:59.680 --> 01:19:01.680]  до которых dp уменьшилось,
[01:19:01.680 --> 01:19:03.680]  ну то есть для которых
[01:19:03.680 --> 01:19:05.680]  dp уменьшилось.
[01:19:05.680 --> 01:19:07.680]  Вот это мне нравится выполняется.
[01:19:07.680 --> 01:19:09.680]  А dp в это n-ое
[01:19:09.680 --> 01:19:11.680]  уменьшим dp в это n-ое.
[01:19:15.680 --> 01:19:17.680]  И из них всех я запускаю,
[01:19:17.680 --> 01:19:19.680]  ну что типа dfs?
[01:19:19.680 --> 01:19:21.680]  И говорю, что все вершины,
[01:19:21.680 --> 01:19:23.680]  достижимые из них dfs,
[01:19:23.680 --> 01:19:25.680]  имеют минус бесконечный дист.
[01:19:29.680 --> 01:19:31.680]  Из них запускаем dfs,
[01:19:33.680 --> 01:19:39.680]  для всех посещенных вершин
[01:19:43.680 --> 01:19:45.680]  говорим, что дист равно
[01:19:45.680 --> 01:19:47.680]  минус бесконечность.
[01:19:53.680 --> 01:19:55.680]  Ну это вроде почти очевидно,
[01:19:55.680 --> 01:19:57.680]  потому что если мы нашли вершину,
[01:19:57.680 --> 01:19:59.680]  у которой dp уменьшилось,
[01:19:59.680 --> 01:20:01.680]  то это скорее всего вершина
[01:20:01.680 --> 01:20:03.680]  на отрицательном цикле,
[01:20:03.680 --> 01:20:05.680]  значит все, что из нее достижимо,
[01:20:05.680 --> 01:20:07.680]  очевидно, имеет на самом деле
[01:20:07.680 --> 01:20:09.680]  минус бесконечный дист,
[01:20:09.680 --> 01:20:11.680]  потому что я сначала могу от s дойти до v,
[01:20:11.680 --> 01:20:13.680]  потом сколько угодно долго петлять по c,
[01:20:13.680 --> 01:20:15.680]  и потом дойти куда надо, до t.
[01:20:15.680 --> 01:20:17.680]  Поэтому все, что достижимо из v,
[01:20:17.680 --> 01:20:19.680]  на самом деле имеет минус бесконечный дист,
[01:20:19.680 --> 01:20:21.680]  потому что я могу петлять по c.
[01:20:21.680 --> 01:20:23.680]  Я для них объявляю ds равно
[01:20:23.680 --> 01:20:25.680]  минус бесконечность,
[01:20:25.680 --> 01:20:27.680]  ну и собственно все.
[01:20:27.680 --> 01:20:29.680]  И тогда после этого я знаю все вершины,
[01:20:29.680 --> 01:20:31.680]  на самом деле минус бесконечное расстояние,
[01:20:31.680 --> 01:20:33.680]  ну а все остальные,
[01:20:35.680 --> 01:20:37.680]  для них правильный ответ
[01:20:37.680 --> 01:20:39.680]  это просто dp с n минус первого слоя.
[01:20:39.680 --> 01:20:41.680]  То есть если я вершину не посетил
[01:20:41.680 --> 01:20:43.680]  на этом шаге,
[01:20:43.680 --> 01:20:45.680]  то для нее ответ это просто то,
[01:20:45.680 --> 01:20:47.680]  что обычный фортбол он бы нашел.
[01:20:49.680 --> 01:20:51.680]  Докажем это,
[01:20:51.680 --> 01:20:53.680]  сейчас переходим в 202nk,
[01:20:53.680 --> 01:20:55.680]  кто хочет, и там мы докажем,
[01:20:55.680 --> 01:20:57.680]  что это все правильно работает.
