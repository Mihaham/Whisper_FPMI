[00:00.000 --> 00:12.400]  Всем доброго дня! Мы с вами продолжаем наш интересный курс. Сегодня у нас план на лекцию такой.
[00:12.400 --> 00:18.200]  Сначала мы с вами закончим предыдущую тему, а именно рассматриваем, как у нас будет работать
[00:18.200 --> 00:25.640]  Gorbache Collector. А следующий блок у нас будет посвящен тому, каким образом у нас работает
[00:25.640 --> 00:30.560]  функциональная парадигма. Во-первых, в императивных языках программирования, а после этого мы посмотрим,
[00:30.560 --> 00:36.920]  каким образом работает чисто функциональная парадигма на примере того, как работает весь
[00:36.920 --> 00:45.080]  конвейер компиляции в таком языке под названием Haskell. Давайте вспомним, на чем мы с вами в прошлый раз закончили.
[00:45.080 --> 00:50.840]  Мы, кажется, с вами в прошлый раз закончили на типизации Gorbache Collector
[00:50.840 --> 00:57.400]  по времени остановки. У нас есть Stop the World, когда у нас запускается Gorbache Collector на все
[00:57.400 --> 01:03.960]  лоцированные памяти в куче, и есть Stop the Pause, когда у нас Gorbache Collector запускается только на
[01:03.960 --> 01:10.560]  небольшой части объектов в куче. Цель как раз состоит в том, чтобы двинуться дальше и посмотреть,
[01:10.560 --> 01:17.160]  какие вообще Gorbache Collector существуют. Первые из Gorbache Collector, которые у нас есть, это
[01:17.160 --> 01:22.800]  поколенческие Gorbache Collector. То есть, что мы говорим? Мы говорим следующее, что у нас с вами все
[01:22.800 --> 01:27.000]  объекты в памяти делятся по следующему признаку. То есть, количество стадии Gorbache Collector,
[01:27.000 --> 01:34.200]  который пережил данный объект. Самый молодой объект это объект G0. После того, как объекты
[01:34.200 --> 01:40.880]  у нас пережили, одну очистку Gorbache Collector у нас, это все переходит в поколение G1. Дальше у нас
[01:40.880 --> 01:46.400]  дополнительно переходят еще переключения из G1 в G2. Почему темы Gorbache Collector интересны,
[01:46.400 --> 01:55.880]  я сам тут сидел ночью работал и понимал, что в одном месте очень интересный факт оказался,
[01:55.880 --> 02:02.120]  что я загружаю модели параметров в нейросеть. И почему-то, когда я перемещаю их в ГПУ,
[02:02.120 --> 02:10.440]  память остается на цепу. И у меня просто берет и память остается на цепу. Понятно,
[02:10.440 --> 02:17.160]  что такого быть не должно. Не на цепу в оперативной памяти. Важная тема и надо посмотреть,
[02:17.160 --> 02:23.240]  каким образом мы это все делаем. Теперь смотрите, как мы можем реализовать stop-the-pause. Мы должны
[02:23.240 --> 02:30.000]  запускать очень часто сборку мусора в поколении G0. Чуть реже мы должны запускать сборку мусора
[02:30.000 --> 02:38.720]  на, так сказать, G1 и еще реже на G2. Это как раз основная концепция, которую мы хотим преследовать
[02:39.040 --> 02:45.680]  для решения нашей задачи. То есть, грубо говоря, запускать на таких мастодонтов память как можно
[02:45.680 --> 02:59.480]  реже. Здесь есть еще тезис. Если книги существуют 200 лет, то, скорее всего, с высокой степень
[02:59.480 --> 03:06.440]  вероятности она еще проживет 200 лет. Понятно, что какие-то молодые вещи очень часто отмирают.
[03:06.920 --> 03:14.840]  И мы как раз пытаемся реализовать эту концепцию. Здесь нужно посмотреть следующую вещь. Чтобы
[03:14.840 --> 03:23.360]  наша очистка мусора не затрагивала именно большое количество ссылок на объекты G1 и G2. Потому что
[03:23.360 --> 03:31.760]  если у нас есть объект в элементе G0, то понятно, что она будет затрагивать ссылки на G1 и G2. То есть,
[03:32.000 --> 03:39.840]  если есть какой-то указатель, то нам нужно или, допустим, у нас есть объекты G1, которые начинают
[03:39.840 --> 03:46.520]  ссылаться на объекты G0. Понятно, что тот же самый MarkSweep или MarkCompact запускать каждый раз на
[03:46.520 --> 03:52.160]  новых объектов, которые мы присоединили, это очень неприятно. Поэтому здесь нам нужно будет
[03:52.160 --> 03:57.400]  отслеживать именно эти моменты и попытаться каким-то образом найти эти объекты, которые начинают
[03:57.400 --> 04:03.160]  ссылаться на объекты G1. Какие способы запоминания у нас есть? На самом деле, либо списком, либо мы
[04:03.160 --> 04:11.440]  можем использовать множество, либо мы можем использовать грязный хак под названием duty bit.
[04:11.440 --> 04:16.760]  Значит, в чем он заключается? Он заключается в том, что если мы пытаемся обновить область старой
[04:16.760 --> 04:23.360]  памяти, то мы устанавливаем bit, что в странице была произведена запись, тем самым мы ее отвязываем
[04:23.360 --> 04:33.400]  от контекции исполнения. Сразу тут нужно сказать, что те элементы, которые у нас как раз в этом
[04:33.400 --> 04:39.800]  множестве попадают, в принципе, они будут являться корневыми вершинами для запуска сборщика
[04:39.800 --> 04:44.960]  мусора. Потому что мы их прямо записали, а остальные объекты, возможно, уже никаким образом не
[04:44.960 --> 04:51.800]  привязаны. Дополнительно мы можем, кстати, хранить корневые объекты, но в целом еще вершины для
[04:51.800 --> 05:02.880]  запоминания. Почему мы с них стартуем? Как вы думаете? Желательно запускать алгоритм guardbatch
[05:02.880 --> 05:15.680]  коллектора от тех вершин, которые мы привязали к вершинам из предыдущих поколений. То есть суть
[05:15.680 --> 05:24.400]  в чем? У нас есть объекты, значит у нас... А, нет, это у нас объекты из g1 и g2. Мы запускаемся на них и
[05:24.400 --> 05:38.880]  смотрим ссылки на объекты g0. Почему из них можно быть эффективно запускать сборщик мусора? На объекты
[05:38.880 --> 05:49.840]  g0. Ну мы просто скорее всего тогда быстро пометим вершины, которые нам нужны, потому что они
[05:49.840 --> 05:55.560]  ссылаются на новые объекты. И, собственно, мы сразу забетонируем эти объекты, что, пожалуйста,
[05:55.560 --> 06:02.240]  типа вот у вас новый объект, он живой, поэтому желательно не стирать ссылку на этот объект.
[06:02.240 --> 06:12.800]  Вот, значит, и после этого, как у нас есть Generational GC, у нас есть еще другие сборщики мусора,
[06:12.800 --> 06:19.640]  и они заключаются в следующем, что у нас с вами может быть два разных, две разных разновидности
[06:19.640 --> 06:23.880]  горбач-коллекторов. Первая разновидность это incremental garbage collector, который работает по
[06:23.880 --> 06:31.040]  требованию, да, то есть, который запускается раз в какой-то промежуток времени, либо мы можем
[06:31.040 --> 06:37.640]  явно вызвать garbage collector для реализации наших результатов. Вот. И второй это параллельный
[06:37.640 --> 06:41.960]  сборщик мусора, то есть это сборщик мусора, который работает параллельно с исполняющим кодом,
[06:41.960 --> 06:51.280]  и здесь у нас возникают два новых объекта очень важных. Первая роль это у нас сборщик, собственно,
[06:51.280 --> 06:56.920]  который собирает мусор, а второй это mutator, то есть это тот объект, который меняет граф
[06:56.920 --> 07:00.880]  в доступности данных, то есть у нас есть все перемены, у нас есть ссылки, и нам нужно помечать,
[07:00.880 --> 07:08.120]  как у нас объекты взаимодействуют с этими ссылками. Вот. Собственно, давайте посмотрим, как работает
[07:08.120 --> 07:15.760]  именно мутатор. Значит, для этого, как ни странно, нам нужно вспомнить принципы DFS и VFS, да, потому
[07:15.760 --> 07:27.960]  что мутатор будет красить вершины. Да. Давайте вспомним, за что отвечает белый цвет. Ага, серое.
[07:27.960 --> 07:41.200]  Да, да, да. Она находится в теке, мы ее еще не посетили. Есть вершина черного цвета. Да,
[07:41.320 --> 07:49.360]  мы обошли все по дереву, которое было в этой вершине. Все верно. То есть в итоге у нас белая вершина
[07:49.360 --> 07:56.280]  не посещена, серая эта вершина находится в обработке, черная эта вершина посещена. Основные варианты,
[07:56.280 --> 08:04.840]  которые у нас есть в обходах DFS и VFS, что у нас нет в DFS, что у нас нет ребра из черной вершины в белую.
[08:04.840 --> 08:16.680]  Почему? Да, если есть, то она уже не белая. Значит, серая вершина на самом деле находится в структуре данных
[08:16.680 --> 08:22.360]  нашего обхода. В нашем случае это будет структура данных сборщика мусора. И какие у нас, давайте
[08:22.360 --> 08:26.840]  подумаем, какие у нас подводные камни могут быть, когда мы реализуем параллельный горбач-коллектор?
[08:26.840 --> 08:50.800]  Ну, параллельный с работающим кодом. Ну да, то есть первая проблема, которая у нас может быть,
[08:50.800 --> 08:54.720]  это в какой-то момент времени у нас есть серебро из черной вершины в белую. То есть оно просто
[08:54.720 --> 09:01.000]  появилось. Ссылка черная указывает на белый объект. Значит, здесь нужно каким-то образом обработать
[09:01.000 --> 09:23.640]  эту вещь. У кого есть идея, каким образом это можно обработать? Интересный способ. Можно в онлайне
[09:23.640 --> 09:35.600]  попробовать это поменять. Правда, через блокировку. Вот смотрите, если у нас есть какая-то белая вершина,
[09:35.600 --> 09:45.560]  мы аллоцировали с вами какую-то переменную и говорим, что х приводит значение у, то что у нас
[09:45.560 --> 09:50.640]  может произойти? У нас эта вершина внезапно может быть привязана только к текущему объекту. То есть
[09:50.640 --> 09:57.640]  мы с вами создаем поинтер, отвязываем, уходим. У нас срабатывает горбач-коллектор. Он увидит,
[09:57.640 --> 10:05.280]  на самом деле там будет логично, что... Кстати, какие объекты мы должны очистить будем? Какого цвета
[10:05.280 --> 10:16.480]  после обхода графа горбач-коллектора? Да, все белые. Вот, а теперь посмотрите, у нас вершина черная,
[10:16.480 --> 10:23.480]  значит у нее идет ребро в белое. Все, больше у нее никаких сидячих ребер нету. Эта вершина пропадает
[10:23.480 --> 10:32.400]  как только она была создана. Есть некоторые лайфхаки, которые позволят это решить. Есть первая
[10:32.400 --> 10:40.920]  достаточно такая примитивная идея. Да-да-да, мы говорим про новую локацию во время запуска.
[10:40.920 --> 11:01.080]  Ну да, то есть первая вещь, это если мы лоцируем переменную, либо второй способ, который на самом
[11:01.080 --> 11:05.840]  деле чуть-чуть менее приятный, но он заставит нам входить, можно вот эту вершину попробовать серый
[11:05.840 --> 11:13.760]  цвет покрасить. Ну да, но тогда нужно будет аккуратненько обрабатывать. То есть добавить вершину
[11:13.760 --> 11:22.840]  force в черную мусору. Вот, и собственно, на самом деле вы не поверите, есть три разных методики записи,
[11:22.840 --> 11:28.080]  то есть когда мы делаем запись, мы на самом деле делаем такую сущность, как под названием write
[11:28.080 --> 11:34.960]  barrier. И первый способ, как раз, который мы с вами обсуждаем, когда мутатор делает ссылку на белый
[11:34.960 --> 11:41.160]  объект A в черном объекте B, то мы A перекрашиваем в серый цвет. То есть это реально одна из методик.
[11:41.160 --> 11:46.400]  А, подождите, у нас не B перекрашивается в серый цвет, у нас A перекрашивается в серый цвет. Я
[11:46.400 --> 11:51.520]  что-то затупил. Это логично, то есть у нас относительно этого объекта мы говорим, что он
[11:51.520 --> 11:57.560]  лоцируется. Кстати, сразу скажу, что он именно красится не в черный цвет, а в серый цвет,
[11:57.560 --> 12:04.280]  потому что на него тоже могли навешаться ссылки. Значит, второй способ, это мы перекрашиваем B,
[12:04.280 --> 12:09.160]  то есть вот эта методика стиля, то есть, что вот это перекрашивается в серое. И есть два метода,
[12:09.160 --> 12:16.040]  которые украшаются здесь в серое. И есть как раз следующее. Это, по-моему, то, что Гера предложил.
[12:16.040 --> 12:20.640]  Да, то есть все страницы памяти, которые покрашены в черный цвет, устанавливаются в
[12:21.360 --> 12:28.960]  режим. То есть мы ставим жесткий барьер, вот, и когда мы делаем запись в эту страницу, то мы делаем
[12:28.960 --> 12:34.520]  PageFold. То есть мы говорим, что в этом время нельзя записать перемены. Понятно, что тогда нужно
[12:34.520 --> 12:45.080]  реализовывать отложенные вычисления в нашем графе работного кода. Так, эти методики понятны?
[12:45.080 --> 12:56.160]  Хорошо. Так, это когда мы ставим переменную на чтение на запись, то есть что мы делаем. А вторая
[12:56.160 --> 13:03.600]  методика, это методика переменных на чтение, да. И здесь тоже, значит, мы делаем следующее, что как
[13:03.600 --> 13:09.400]  только у нас мутатор получает какую-то ссылку на объект, то есть мы хотим прочитать переменную,
[13:09.400 --> 13:14.440]  и внезапно этот объект стал белым, это означает, что всё равно эта перемена в какой-то момент
[13:14.440 --> 13:19.480]  времени стала доступна. Поэтому её нужно добавить в список вершин на обработке, и мы её добавляем в
[13:19.480 --> 13:28.400]  чёрный цвет, ой, в серый цвет. И Apple тоже придумал ещё одну методику. Значит, когда у нас мутатор
[13:28.400 --> 13:34.720]  получает ссылку на объект B, содержащий в нечёрной странице вертолем памяти, то есть серый или белый,
[13:34.720 --> 13:44.800]  тогда, собственно, любой тот, кто запрашивает эту переменную на чтение, будет красить каждый
[13:44.800 --> 13:51.880]  указатель на чёрный цвет. То есть, типа, мы обратились к этой переменной, а значит, что
[13:51.880 --> 13:57.320]  получается? Это значит, что по факту мы с этим объектом уже можем работать, а всех детей чёрных
[13:57.320 --> 14:01.960]  вершин в серый. То есть мы произвели чтение и в режиме реал тайма обработали эту вершину.
[14:01.960 --> 14:14.240]  То есть инжектим как раз механизм синхронизации. Это что происходит, когда мы в параллельном
[14:14.240 --> 14:37.240]  гарбоч-коллекторе, или stop the pause, это работает либо в stop-pause, либо в параллельном
[14:37.240 --> 14:47.320]  конкарном гарбоч-коллекторе. Так, понятно ли эта методика? То есть, в принципе, мы уже с вами с этим
[14:47.320 --> 14:53.920]  можем работать. Так, ну и теперь давайте рассмотрим примеры гарбоч-коллекторов в разных языках
[14:53.920 --> 15:23.280]  программирования. Сейчас питон активно меняется, вот, это важно сказать, ну да. Вот, ну на самом деле,
[15:23.280 --> 15:28.040]  если мы говорим про всякие нейросети, то просто в какой-то момент намертво после всех проглонов
[15:28.040 --> 15:35.920]  там просто гарбоч-коллектор вызывается. Причем там несколько гарбоч-коллекторов вызывается,
[15:35.920 --> 15:43.600]  там первый гарбоч-коллектор, который вызывается, это, ну, собственно, сам ГЦ, а второй гарбоч-коллектор
[15:43.600 --> 15:51.440]  это торчёвый гарбоч-коллектор, который берет и вычищает CUDA кэш. То есть там какие-то переменные,
[15:51.440 --> 15:53.440]  которые нужно было закушировать, он их очищает.
[15:53.440 --> 15:55.440]  То есть, у которых нет ссылок, но другие объекты.
[15:55.440 --> 15:59.440]  Ну там, кстати, у разных фреймворков есть
[15:59.440 --> 16:01.440]  разные вызовы горбач коллекторов.
[16:01.440 --> 16:03.440]  Итак, значит, в Python у нас
[16:03.440 --> 16:07.440]  GenerationUntil и второй это подсчет
[16:07.440 --> 16:09.440]  числа ссылок.
[16:09.440 --> 16:11.440]  Как оно работает?
[16:11.440 --> 16:15.440]  Собственно, в Python у нас с вами
[16:15.440 --> 16:17.440]  есть вот такой пример.
[16:17.440 --> 16:21.440]  И, значит, здесь у нас как раз указывается
[16:21.440 --> 16:23.440]  sys.getTrashCount, то есть, что позволяет узнать
[16:23.440 --> 16:25.440]  количество ссылок на объект.
[16:25.440 --> 16:29.440]  И дальше мы как раз можем запустить
[16:29.440 --> 16:31.440]  getTrashOld, то есть, узнать пороги
[16:31.440 --> 16:33.440]  для количества объектов, чтобы запускать
[16:33.440 --> 16:35.440]  ГЦ для каждого поколения.
[16:35.440 --> 16:37.440]  В принципе, по-моему, их можно
[16:37.440 --> 16:39.440]  переустановить, поменять.
[16:39.440 --> 16:41.440]  По умолчанию, значит, 700 на поколение G0,
[16:41.440 --> 16:45.440]  10 на поколение G1 и 10 на поколение G2.
[16:45.440 --> 16:47.440]  Это вот такое значение.
[16:47.440 --> 16:49.440]  Возможно, кстати, оно меняется
[16:49.440 --> 16:51.440]  со временем.
[16:51.440 --> 16:53.440]  Давайте попробуем посмотреть.
[16:55.440 --> 16:57.440]  Python 3.
[17:01.440 --> 17:03.440]  Gc, Gc.
[17:03.440 --> 17:05.440]  А, нет, вот.
[17:05.440 --> 17:07.440]  Дальше современных версий
[17:07.440 --> 17:11.440]  из Python пороги те же самые.
[17:11.440 --> 17:13.440]  Это Python 3.12.
[17:13.440 --> 17:15.440]  То есть, за несколько лет
[17:15.440 --> 17:17.440]  у нас ничего не поменялось.
[17:17.440 --> 17:19.440]  Вот, ну и в принципе здесь вот как раз
[17:19.440 --> 17:21.440]  пример, что у нас создается нода.
[17:21.440 --> 17:23.440]  А после этого мы указываем
[17:23.440 --> 17:25.440]  с вами вершину x.
[17:25.440 --> 17:27.440]  После этого считаем количество ссылок
[17:27.440 --> 17:29.440]  на объект x.
[17:29.440 --> 17:31.440]  Кстати, вопрос, почему количество ссылок
[17:31.440 --> 17:33.440]  на объект x
[17:33.440 --> 17:35.440]  равняется 2?
[17:35.440 --> 17:37.440]  О, пример.
[17:43.440 --> 17:45.440]  Ну да.
[17:45.440 --> 17:47.440]  То есть, оно сохраняет ссылку себе,
[17:47.440 --> 17:49.440]  а потом считает количество ссылок.
[17:49.440 --> 17:51.440]  Так, дальше у нас x,
[17:51.440 --> 17:53.440]  значит, что мы делаем?
[17:53.440 --> 17:55.440]  Дальше, значит,
[17:55.440 --> 17:57.440]  мы считаем x.x
[17:57.440 --> 17:59.440]  эта нода.
[17:59.440 --> 18:01.440]  И здесь тоже у x.a.x
[18:01.440 --> 18:03.440]  создаются две ссылки.
[18:03.440 --> 18:05.440]  А дальше мы делаем следующее.
[18:05.440 --> 18:07.440]  Присваиваем переменной a значение x.x.
[18:07.440 --> 18:09.440]  И тогда у нас ревка у нас
[18:09.440 --> 18:11.440]  не будет.
[18:11.440 --> 18:13.440]  И тогда у нас ревка
[18:13.440 --> 18:15.440]  переменной a будет равняться 3.
[18:17.440 --> 18:19.440]  Потому что как раз
[18:19.440 --> 18:21.440]  кто у нас содержит ссылку на этот объект?
[18:21.440 --> 18:23.440]  a и x.
[18:23.440 --> 18:25.440]  Когда удаляем
[18:25.440 --> 18:27.440]  x, у нас количество ссылок
[18:27.440 --> 18:29.440]  на объект a равняется 1.
[18:29.440 --> 18:31.440]  И у нас
[18:31.440 --> 18:33.440]  по факту этот объект остается
[18:33.440 --> 18:35.440]  в памяти. То есть, у нас он не скидывается
[18:35.440 --> 18:37.440]  в горбач-коллектор.
[18:37.440 --> 18:39.440]  Ну, в принципе,
[18:39.440 --> 18:41.440]  всегда можно вызвать gc-коллектор.
[18:41.440 --> 18:43.440]  Поэтому
[18:43.440 --> 18:45.440]  в питоне зачастую используют как раз
[18:45.440 --> 18:47.440]  оператор dell
[18:47.440 --> 18:49.440]  для того, чтобы вызвать коллектор.
[18:57.440 --> 18:59.440]  Нет, конечно же.
[18:59.440 --> 19:01.440]  Там делается dell, да потом gc-коллектор.
[19:05.440 --> 19:07.440]  Работает медленно, но
[19:07.440 --> 19:09.440]  обычно в тех применениях,
[19:09.440 --> 19:11.440]  когда это в питоне требуется,
[19:11.440 --> 19:13.440]  когда нужно явно вызвать горбач-коллектор,
[19:13.440 --> 19:15.440]  несколько десятков
[19:15.440 --> 19:17.440]  миллисекунд переждать
[19:17.440 --> 19:19.440]  это не проблема.
[19:19.440 --> 19:21.440]  Особенно когда обработки идут секунды.
[19:21.440 --> 19:23.440]  Так, это что касается питона.
[19:23.440 --> 19:25.440]  А в джаве
[19:25.440 --> 19:27.440]  значит
[19:27.440 --> 19:29.440]  более сложный механизм.
[19:29.440 --> 19:31.440]  В джаве есть несколько
[19:31.440 --> 19:33.440]  типов горбач-коллекторов.
[19:33.440 --> 19:35.440]  Первая это gc, вторая
[19:35.440 --> 19:37.440]  это full gc.
[19:37.440 --> 19:39.440]  Майнер gc работает
[19:39.440 --> 19:41.440]  на только молодом поколении
[19:41.440 --> 19:43.440]  и есть full gc, в котором происходит
[19:43.440 --> 19:45.440]  полная сборка мусора.
[19:45.440 --> 19:47.440]  В full gc
[19:47.440 --> 19:49.440]  есть 4
[19:49.440 --> 19:51.440]  поколения.
[19:51.440 --> 19:53.440]  Первая это идон,
[19:53.440 --> 19:55.440]  вторая это сурвайвер 0,
[19:55.440 --> 19:57.440]  дальше у нас идет сурвайвер 1
[19:57.440 --> 19:59.440]  и в конце концов
[19:59.440 --> 20:01.440]  у нас возникает объект под названием
[20:01.440 --> 20:03.440]  tenured. То есть это вот финальное
[20:03.440 --> 20:05.440]  поколение, которое у нас есть.
[20:05.440 --> 20:07.440]  И как они меняются
[20:07.440 --> 20:09.440]  между собой? Соответственно они
[20:09.440 --> 20:11.440]  на самом деле хитрую вещь делают.
[20:11.440 --> 20:13.440]  Они говорят следующее, что есть
[20:13.440 --> 20:15.440]  и объекты, которые действительно слишком долго
[20:15.440 --> 20:17.440]  застоялись у нас.
[20:17.440 --> 20:19.440]  Поэтому у нас будет
[20:19.440 --> 20:21.440]  процедура такая, что сначала
[20:21.440 --> 20:23.440]  все молодые объекты, которые
[20:23.440 --> 20:25.440]  пережили горбач-коллектор, переходят
[20:25.440 --> 20:27.440]  в вет
[20:27.440 --> 20:29.440]  в сурвайвер 0.
[20:29.440 --> 20:31.440]  Потом идон плюс сурвайвер 0
[20:31.440 --> 20:33.440]  переходят в сурвайвер 1.
[20:33.440 --> 20:35.440]  Потом, смотрите, интересный момент,
[20:35.440 --> 20:37.440]  что идон плюс сурвайвер 1 переходят в
[20:37.440 --> 20:39.440]  сурвайвер 0.
[20:39.440 --> 20:41.440]  То есть мы возвращаем его
[20:41.440 --> 20:43.440]  и только после некоторых переходов
[20:43.440 --> 20:45.440]  как раз у нас
[20:45.440 --> 20:47.440]  делается... То есть у нас, видите,
[20:47.440 --> 20:49.440]  происходят... молодые объекты
[20:49.440 --> 20:51.440]  перезапускаются всегда, а немолодые
[20:51.440 --> 20:53.440]  объекты, они как бы
[20:53.440 --> 20:55.440]  чередуются между собой.
[20:55.440 --> 20:57.440]  Тем самым мы можем накапливать
[20:57.440 --> 20:59.440]  наши объекты и перемещать их.
[20:59.440 --> 21:01.440]  Но потом, после какого-то момента времени
[21:01.440 --> 21:03.440]  мы понимаем, что есть какие-то объекты,
[21:03.440 --> 21:05.440]  с которыми лучше
[21:05.440 --> 21:07.440]  не сталкиваться,
[21:07.440 --> 21:09.440]  какие-то глобальные объекты,
[21:09.440 --> 21:11.440]  тогда мы с вами уже их перемещаем
[21:11.440 --> 21:13.440]  в поколение под названием тенорт.
[21:15.440 --> 21:17.440]  Так.
[21:17.440 --> 21:19.440]  Понятно ли схема?
[21:21.440 --> 21:23.440]  Хорошо.
[21:23.440 --> 21:25.440]  Так. Это что касается
[21:25.440 --> 21:27.440]  горбач-коллекторов. Мы поняли
[21:27.440 --> 21:29.440]  по идее за...
[21:29.440 --> 21:31.440]  не знаю...
[21:35.440 --> 21:37.440]  А где он был?
[21:43.440 --> 21:45.440]  А где у него реализация есть?
[21:57.440 --> 21:59.440]  Не, мы это в коде
[21:59.440 --> 22:01.440]  я спрашиваю, мы это в коде найдем?
[22:17.440 --> 22:19.440]  Давайте посмотрим, где...
[22:23.440 --> 22:25.440]  У меня все равно есть старый стандарт,
[22:25.440 --> 22:27.440]  который это...
[22:27.440 --> 22:29.440]  Куда мы прыгаем?
[22:29.440 --> 22:31.440]  В memory, видимо?
[22:31.440 --> 22:33.440]  Так, что мы гуглим?
[22:41.440 --> 22:43.440]  О.
[22:55.440 --> 22:57.440]  Ммм...
[23:07.440 --> 23:09.440]  И где это?
[23:11.440 --> 23:13.440]  Он гениально.
[23:17.440 --> 23:19.440]  Memory.
[23:21.440 --> 23:23.440]  А зачем мне судо?
[23:25.440 --> 23:27.440]  Сейчас пропишем свои гаражки.
[23:29.440 --> 23:31.440]  Так, вот он declarable.
[23:31.440 --> 23:33.440]  Значит, вот он у нас.
[23:39.440 --> 23:41.440]  То есть вы в ни одной реализации
[23:41.440 --> 23:43.440]  его не вставили?
[23:43.440 --> 23:45.440]  Да.
[23:45.440 --> 23:47.440]  Стандарт сказал, вот есть функции
[23:47.440 --> 23:49.440]  для сборки мусора, вы их
[23:49.440 --> 23:51.440]  выполняете, но выполнять не обязательно.
[23:53.440 --> 23:55.440]  Гениально.
[23:55.440 --> 23:57.440]  А, я не знаю,
[23:57.440 --> 23:59.440]  что отличается.
[23:59.440 --> 24:01.440]  Need to remove.
[24:03.440 --> 24:05.440]  А есть еще undeclare reachable.
[24:05.440 --> 24:07.440]  Ну да.
[24:07.440 --> 24:09.440]  Смотрите, как оно реализовывается.
[24:09.440 --> 24:11.440]  Очень просто.
[24:11.440 --> 24:13.440]  Вот, как бы вот.
[24:13.440 --> 24:15.440]  Вот идеально.
[24:15.440 --> 24:17.440]  Согласен.
[24:17.440 --> 24:19.440]  Вот.
[24:19.440 --> 24:21.440]  А тут не написано,
[24:21.440 --> 24:23.440]  видимо, тут надо читать
[24:23.440 --> 24:25.440]  в реддите.
[24:25.440 --> 24:27.440]  Информация.
[24:31.440 --> 24:33.440]  Вот, да.
[24:33.440 --> 24:35.440]  То есть в C++
[24:35.440 --> 24:37.440]  есть.
[24:37.440 --> 24:39.440]  И тут надо посмотреть реализации,
[24:39.440 --> 24:41.440]  в которых это все есть.
[24:41.440 --> 24:43.440]  Но, видимо, тут
[24:43.440 --> 24:45.440]  здраво решили убрать.
[24:45.440 --> 24:47.440]  Сказали, что, типа, надо...
[24:51.440 --> 24:53.440]  Ну да.
[24:53.440 --> 24:55.440]  Не, ну можно свой написать,
[24:55.440 --> 24:57.440]  зато...
[24:57.440 --> 24:59.440]  Да, есть такой.
[24:59.440 --> 25:01.440]  Так.
[25:01.440 --> 25:03.440]  Согласен.
[25:03.440 --> 25:05.440]  Я, кстати, читал что-то,
[25:05.440 --> 25:07.440]  что
[25:07.440 --> 25:09.440]  собрались правительства стран
[25:09.440 --> 25:11.440]  или правительства этих
[25:11.440 --> 25:13.440]  советов безопасности
[25:13.440 --> 25:15.440]  каких-то стран и сказали, что
[25:15.440 --> 25:17.440]  C++ небезопасен, давайте на раз
[25:17.440 --> 25:19.440]  переходить.
[25:31.440 --> 25:33.440]  Ну да.
[25:37.440 --> 25:39.440]  Да.
[25:47.440 --> 25:49.440]  Ну да.
[25:49.440 --> 25:51.440]  Да.
[26:07.440 --> 26:09.440]  Так.
[26:19.440 --> 26:21.440]  Ага.
[26:25.440 --> 26:27.440]  Так.
[26:31.440 --> 26:33.440]  Не ненавидит траст?
[26:37.440 --> 26:39.440]  Да.
[27:07.440 --> 27:09.440]  Да.
[27:33.440 --> 27:35.440]  Да.
[27:37.440 --> 27:39.440]  Ну да.
[27:43.440 --> 27:45.440]  Да, допустим.
[27:47.440 --> 27:49.440]  Да, допустим.
[27:57.440 --> 27:59.440]  О, Господи,
[27:59.440 --> 28:01.440]  и как с этим работать?
[28:07.440 --> 28:09.440]  Ну да.
[28:17.440 --> 28:19.440]  Ну да.
[28:25.440 --> 28:27.440]  А почему
[28:27.440 --> 28:29.440]  берется ссылка?
[28:37.440 --> 28:39.440]  Ну да.
[28:39.440 --> 28:41.440]  Ну да.
[28:41.440 --> 28:43.440]  Интересно, конечно.
[28:43.440 --> 28:45.440]  Да.
[29:03.440 --> 29:05.440]  Понятно.
[29:05.440 --> 29:07.440]  Реально получается setup
[29:07.440 --> 29:09.440]  это такие интерфейсы а-ля.
[29:31.440 --> 29:33.440]  Так, в какой сет вставлять?
[29:35.440 --> 29:37.440]  Нет, в какой хэш?
[29:37.440 --> 29:39.440]  В какой сет вставлять?
[29:45.440 --> 29:47.440]  Так это хэш-сет.
[29:51.440 --> 29:53.440]  Да.
[30:05.440 --> 30:07.440]  Ну да.
[30:11.440 --> 30:13.440]  Да, полезен
[30:13.440 --> 30:15.440]  переход.
[30:15.440 --> 30:17.440]  Согласен.
[30:17.440 --> 30:19.440]  Да, да, да, да, да.
[30:27.440 --> 30:29.440]  Да, вот они.
[30:35.440 --> 30:37.440]  Ну, видно.
[30:37.440 --> 30:39.440]  Ждем.
[30:39.440 --> 30:41.440]  Последняя версия BLD
[30:41.440 --> 30:43.440]  была три недели назад.
[30:45.440 --> 30:47.440]  Ну, развиваются все люди.
[30:47.440 --> 30:49.440]  Вот, а мы пойдем все-таки
[30:49.440 --> 30:51.440]  сегодня не...
[30:51.440 --> 30:53.440]  Я предлагаю пойти не в раст.
[30:55.440 --> 30:57.440]  Нет.
[30:57.440 --> 30:59.440]  Нет.
[30:59.440 --> 31:01.440]  А давай, у меня есть
[31:01.440 --> 31:03.440]  вопрос.
[31:03.440 --> 31:05.440]  У меня есть предложение
[31:05.440 --> 31:07.440]  пойти немного в другую парадигму
[31:07.440 --> 31:09.440]  даже.
[31:09.440 --> 31:11.440]  Да, мы пойдем с вами в функциональную парадигму.
[31:11.440 --> 31:13.440]  Тут, наверное, уже
[31:13.440 --> 31:15.440]  любопытные слушатели
[31:15.440 --> 31:17.440]  смогли увидеть, что
[31:17.440 --> 31:19.440]  в вкладке в браузере у меня
[31:19.440 --> 31:21.440]  большое количество
[31:21.440 --> 31:23.440]  складок называется
[31:23.440 --> 31:25.440]  GHC.
[31:25.440 --> 31:27.440]  Но прежде чем мы с вами начнем, давайте посмотрим,
[31:27.440 --> 31:29.440]  как работает функциональная парадигма
[31:29.440 --> 31:31.440]  в классических языках программирования.
[31:31.440 --> 31:33.440]  Вот, значит, смотрите, у меня есть пример,
[31:33.440 --> 31:35.440]  на самом деле, который...
[31:35.440 --> 31:37.440]  При помощи которых я показывал люди, как колбэки
[31:37.440 --> 31:39.440]  работают.
[31:39.440 --> 31:41.440]  Черный экран нормальный, или лучше светлый сделать?
[31:41.440 --> 31:43.440]  Нормально.
[31:43.440 --> 31:45.440]  Нет, просто можно сделать вот так.
[31:45.440 --> 31:47.440]  Просто нормально.
[31:47.440 --> 31:49.440]  Ладно, давайте так.
[31:49.440 --> 31:51.440]  У него есть... Слушай, я вот
[31:51.440 --> 31:53.440]  смотрю, у B3 map
[31:53.440 --> 31:55.440]  есть dockers.
[31:55.440 --> 31:57.440]  А, да?
[31:57.440 --> 31:59.440]  B3 map?
[31:59.440 --> 32:01.440]  Я, короче, его не заметил.
[32:01.440 --> 32:03.440]  Ладно.
[32:03.440 --> 32:05.440]  Вот это вот?
[32:05.440 --> 32:07.440]  Да.
[32:07.440 --> 32:09.440]  А?
[32:09.440 --> 32:11.440]  B3 map.
[32:11.440 --> 32:13.440]  В этом плане все.
[32:13.440 --> 32:15.440]  Ура!
[32:15.440 --> 32:17.440]  Все еще и сестра позвала, потому что после инсерта
[32:17.440 --> 32:19.440]  мы не знаем про объекты инсерта,
[32:19.440 --> 32:21.440]  и хотим получить указатель.
[32:21.440 --> 32:23.440]  Ну, да-да-да.
[32:23.440 --> 32:25.440]  Давайте мы как раз возьмем
[32:25.440 --> 32:27.440]  пример,
[32:27.440 --> 32:29.440]  который я показывал на другом курсе.
[32:29.440 --> 32:31.440]  У нас
[32:31.440 --> 32:33.440]  будет вот такой пример.
[32:33.440 --> 32:35.440]  Я не знаю, видны или нет.
[32:35.440 --> 32:37.440]  Ну, кстати, вам
[32:37.440 --> 32:39.440]  везет, у вас на проекторе
[32:39.440 --> 32:41.440]  немножко световая гамма хорошая.
[32:41.440 --> 32:43.440]  Она у меня немножко выкрученная.
[32:43.440 --> 32:45.440]  То есть то, что у вас зеленое, у меня салатовое.
[32:47.440 --> 32:49.440]  Подкручу профилю.
[32:53.440 --> 32:55.440]  Так, profile, background.
[32:57.440 --> 32:59.440]  А?
[33:03.440 --> 33:05.440]  Вот-вот-вот. Я сейчас как раз для них
[33:05.440 --> 33:07.440]  это еще и настрою.
[33:11.440 --> 33:13.440]  Так.
[33:17.440 --> 33:19.440]  А как вот этот цвет поменять?
[33:19.440 --> 33:21.440]  Сейчас.
[33:21.440 --> 33:23.440]  Тупняк.
[33:23.440 --> 33:25.440]  А?
[33:25.440 --> 33:27.440]  Какой цвет у нас?
[33:29.440 --> 33:31.440]  Ага, это selection, это selection text.
[33:35.440 --> 33:37.440]  Я какой-то цвет не вижу.
[33:37.440 --> 33:39.440]  Какой я цвет не вижу.
[33:39.440 --> 33:41.440]  А, тут вам сложно передать.
[33:49.440 --> 33:51.440]  Вот так сделаю.
[33:51.440 --> 33:53.440]  Да, теперь видно.
[33:53.440 --> 33:55.440]  Бывает сложно настроить профили,
[33:55.440 --> 33:57.440]  но мы справились.
[33:57.440 --> 33:59.440]  Смотрите, здесь функция...
[33:59.440 --> 34:01.440]  В чем стоит особенность?
[34:01.440 --> 34:03.440]  У нас с вами будет функция...
[34:03.440 --> 34:05.440]  Смотрите, давайте разберем код.
[34:05.440 --> 34:07.440]  Здесь запускаются два потока.
[34:07.440 --> 34:09.440]  Первый поток вызывает
[34:09.440 --> 34:11.440]  функцию runner thread
[34:11.440 --> 34:13.440]  с аргументом 100
[34:13.440 --> 34:15.440]  и возвращает функцию callback.
[34:15.440 --> 34:17.440]  То есть у нас функция callback,
[34:17.440 --> 34:19.440]  которая принимает на вход
[34:19.440 --> 34:21.440]  статус код.
[34:21.440 --> 34:23.440]  Следующую инструкцию.
[34:23.440 --> 34:25.440]  У нас поток засыпает на определенный момент времени
[34:25.440 --> 34:27.440]  и дальше у нас выполняется
[34:27.440 --> 34:29.440]  запрос о том, что
[34:29.440 --> 34:31.440]  request у нас completed.
[34:31.440 --> 34:33.440]  И второй поток тоже
[34:33.440 --> 34:35.440]  есть такой же.
[34:35.440 --> 34:37.440]  И вот вопрос. Как это
[34:37.440 --> 34:39.440]  трансформируется в
[34:39.440 --> 34:41.440]  valueM-овский код?
[34:43.440 --> 34:45.440]  Давайте
[34:45.440 --> 34:47.440]  предположение.
[34:47.440 --> 34:49.440]  Ну, создание передо...
[34:49.440 --> 34:51.440]  Ну, как...
[34:51.440 --> 34:53.440]  Надо функцию
[34:53.440 --> 34:55.440]  создать в создании класса
[34:55.440 --> 34:57.440]  под каждую ляму.
[34:57.440 --> 34:59.440]  Да.
[35:05.440 --> 35:07.440]  Так, lvmain.c
[35:07.440 --> 35:09.440]  минус...
[35:09.440 --> 35:11.440]  Да.
[35:25.440 --> 35:27.440]  Да, значит,
[35:27.440 --> 35:29.440]  смотрите, тут у нас будут литералы.
[35:29.440 --> 35:31.440]  Очень много литералов.
[35:31.440 --> 35:33.440]  А, это я сделал
[35:33.440 --> 35:35.440]  include называется.
[35:35.440 --> 35:37.440]  Ладно, проматываем.
[35:37.440 --> 35:39.440]  Так, так, так.
[35:39.440 --> 35:41.440]  О, господи.
[35:41.440 --> 35:43.440]  Во.
[35:43.440 --> 35:45.440]  Значит, что он создал?
[35:45.440 --> 35:47.440]  Видите?
[35:47.440 --> 35:49.440]  Он создал класс под названием
[35:49.440 --> 35:51.440]  std.function
[35:51.440 --> 35:53.440]  на определенную ветку.
[35:53.440 --> 35:55.440]  Причем, смотрите, как интересно
[35:55.440 --> 35:57.440]  он это запускает.
[35:57.440 --> 35:59.440]  Да?
[35:59.440 --> 36:01.440]  То есть, а, это у нас
[36:01.440 --> 36:03.440]  runner.thread. То есть, мы по факту
[36:03.440 --> 36:05.440]  вызываем с вами callback.
[36:05.440 --> 36:07.440]  И это вот такая вот страшная
[36:07.440 --> 36:09.440]  штука,
[36:09.440 --> 36:11.440]  которую мы принимали в определенном
[36:11.440 --> 36:13.440]  аргументе. Причем, смотрите,
[36:13.440 --> 36:15.440]  а хочу обратить ваше внимание,
[36:15.440 --> 36:17.440]  что когда мы указываем c++,
[36:17.440 --> 36:19.440]  в код c++, то у нас
[36:19.440 --> 36:21.440]  с вами работает как раз сигнатура,
[36:21.440 --> 36:23.440]  да, то есть мы проверяем
[36:23.440 --> 36:25.440]  типа, а здесь у нас просто уже передается
[36:25.440 --> 36:27.440]  указательного звездочку.
[36:27.440 --> 36:29.440]  И вот здесь как раз есть какая-то
[36:29.440 --> 36:31.440]  страшная функция называется
[36:31.440 --> 36:33.440]  function if и ee...
[36:35.440 --> 36:37.440]  mangling.
[36:37.440 --> 36:39.440]  Давайте прочитаем.
[36:39.440 --> 36:41.440]  Значит, смотрите,
[36:41.440 --> 36:43.440]  восьмерка это function,
[36:43.440 --> 36:45.440]  а ee это у нас...
[36:45.440 --> 36:47.440]  это у нас
[36:47.440 --> 36:49.440]  vee, это из Void to Wind.
[36:51.440 --> 36:53.440]  E-C-L-G-I. Ну, разберемся.
[36:53.440 --> 36:55.440]  А теперь смотрите, что у нас
[36:55.440 --> 36:57.440]  делается. У нас
[36:57.440 --> 36:59.440]  делается следующая вещь.
[36:59.440 --> 37:01.440]  Мы с вами,
[37:01.440 --> 37:03.440]  значит, получаем наш
[37:03.440 --> 37:05.440]  объект
[37:05.440 --> 37:07.440]  и создаем его.
[37:07.440 --> 37:09.440]  Господи.
[37:13.440 --> 37:15.440]  То есть у нас с вами...
[37:15.440 --> 37:17.440]  Давайте посмотрим. То есть мы
[37:17.440 --> 37:19.440]  как раз создаем вот эту функцию.
[37:19.440 --> 37:21.440]  Раз...
[37:21.440 --> 37:23.440]  А, стоп, стоп,
[37:23.440 --> 37:25.440]  стоп, стоп, стоп. Это у нас
[37:25.440 --> 37:27.440]  этот. Это еще не
[37:27.440 --> 37:29.440]  main. Подождите.
[37:29.440 --> 37:31.440]  Вот он main.
[37:31.440 --> 37:33.440]  Матечная.
[37:35.440 --> 37:37.440]  Ладно, давайте посмотрим, что оно делает.
[37:37.440 --> 37:39.440]  Кстати, хочу подчеркнуть, что
[37:39.440 --> 37:41.440]  видите, у C++,
[37:41.440 --> 37:43.440]  у этого,
[37:43.440 --> 37:45.440]  скажите, у LVM
[37:45.440 --> 37:47.440]  есть опция создания типов.
[37:47.440 --> 37:49.440]  То есть вот этот
[37:49.440 --> 37:51.440]  класс Std.ChronoDuration
[37:51.440 --> 37:53.440]  это как раз структура.
[37:53.440 --> 37:55.440]  Так, значит,
[37:55.440 --> 37:57.440]  что мы с вами делаем? Мы принимаем
[37:57.440 --> 37:59.440]  с вами аргументы и
[37:59.440 --> 38:01.440]  смотрим процессы 3.
[38:01.440 --> 38:03.440]  Процесс 3 и процент 0.
[38:03.440 --> 38:05.440]  Значит, смотрите, что он делает?
[38:05.440 --> 38:07.440]  Он нам алоцирует переменную
[38:07.440 --> 38:09.440]  типа class.anon.
[38:15.440 --> 38:17.440]  Вот, смотрите, то есть у нас
[38:17.440 --> 38:19.440]  вызывается класс anon 0,
[38:19.440 --> 38:21.440]  класс anon
[38:21.440 --> 38:23.440]  другого типа.
[38:23.440 --> 38:25.440]  Почему они разные?
[38:25.440 --> 38:27.440]  А, ну, видимо, это у нас функции такие.
[38:27.440 --> 38:29.440]  Значит, нам нужно будет их с вами найти.
[38:29.440 --> 38:31.440]  После этого мы вызываем с вами
[38:31.440 --> 38:33.440]  running thread функцию.
[38:33.440 --> 38:35.440]  И после этого
[38:35.440 --> 38:37.440]  делаем slip. О, господи.
[38:37.440 --> 38:39.440]  Да, конечно, mangling это
[38:39.440 --> 38:41.440]  очень веселая история.
[38:43.440 --> 38:45.440]  Вот, собственно, мы дальше
[38:45.440 --> 38:47.440]  выполняем join.
[38:47.440 --> 38:49.440]  И возвращаем 0.
[38:51.440 --> 38:53.440]  Вот они как раз у нас
[38:53.440 --> 38:55.440]  вызывают
[38:55.440 --> 38:57.440]  функции join.
[38:57.440 --> 38:59.440]  О, а это у нас
[38:59.440 --> 39:01.440]  получается, это у нас
[39:01.440 --> 39:03.440]  основной контекст.
[39:03.440 --> 39:05.440]  То есть это у нас thread,
[39:05.440 --> 39:07.440]  function main.
[39:07.440 --> 39:09.440]  Да, то есть, видите, у нас это все компилится еще
[39:09.440 --> 39:11.440]  в основную функцию.
[39:11.440 --> 39:13.440]  В общем, получается
[39:13.440 --> 39:15.440]  страшное веселье, в котором мы
[39:15.440 --> 39:17.440]  с вами должны найти
[39:17.440 --> 39:19.440]  anon.
[39:25.440 --> 39:27.440]  Угу.
[39:27.440 --> 39:29.440]  Это у нас
[39:29.440 --> 39:31.440]  наверное не надо было настолько
[39:31.440 --> 39:33.440]  сложный код писать.
[39:33.440 --> 39:35.440]  Давайте простой код
[39:35.440 --> 39:37.440]  напишем.
[39:37.440 --> 39:39.440]  А?
[39:39.440 --> 39:41.440]  Так, смотрите.
[39:41.440 --> 39:43.440]  Значит, мы делаем include
[39:43.440 --> 39:45.440]  function.
[39:45.440 --> 39:47.440]  Test the function.
[39:57.440 --> 39:59.440]  Avoid at int
[39:59.440 --> 40:01.440]  func.
[40:05.440 --> 40:07.440]  В общем,
[40:07.440 --> 40:09.440]  мы делаем
[40:09.440 --> 40:11.440]  include function.
[40:15.440 --> 40:17.440]  Так.
[40:25.440 --> 40:27.440]  То есть мы создаем с вами переменную.
[40:27.440 --> 40:29.440]  Так, точку за пятой делаем, да, func
[40:29.440 --> 40:31.440]  от пяти.
[40:31.440 --> 40:33.440]  Значит, давайте
[40:33.440 --> 40:35.440]  проверим, как это работает.
[40:35.440 --> 40:37.440]  Угу.
[40:43.440 --> 40:45.440]  Ну.
[40:59.440 --> 41:01.440]  Так, function.
[41:01.440 --> 41:03.440]  Угу.
[41:07.440 --> 41:09.440]  Ну да.
[41:15.440 --> 41:17.440]  Так, ну, давайте
[41:17.440 --> 41:19.440]  посмотрим, как эта функция выглядит.
[41:19.440 --> 41:21.440]  А.
[41:31.440 --> 41:33.440]  Угу.
[41:35.440 --> 41:37.440]  Итак, смотрите. У нас снова
[41:37.440 --> 41:39.440]  здесь возник объект
[41:39.440 --> 41:41.440]  класса class.anon.
[41:41.440 --> 41:43.440]  Объект. И дальше мы вызываем
[41:43.440 --> 41:45.440]  страшную функцию,
[41:45.440 --> 41:47.440]  которая называется
[41:47.440 --> 41:49.440]  std void function
[41:49.440 --> 41:51.440]  и так далее.
[41:51.440 --> 41:53.440]  То есть у нас идет как раз
[41:53.440 --> 41:55.440]  вызов нашего объекта.
[41:55.440 --> 41:57.440]  И после этого у нас, кстати,
[41:57.440 --> 41:59.440]  хочу подчеркнуть, что у нас
[41:59.440 --> 42:01.440]  после этого идет
[42:01.440 --> 42:03.440]  tool label wind,
[42:03.440 --> 42:05.440]  пятую метку
[42:05.440 --> 42:07.440]  и unwind label 6. То есть у нас
[42:07.440 --> 42:09.440]  по факту получается два
[42:09.440 --> 42:11.440]  джампа происходят.
[42:11.440 --> 42:13.440]  Вот это вот у нас вызов
[42:13.440 --> 42:15.440]  как раз нашей функции.
[42:17.440 --> 42:19.440]  Вот. И дальше мы выходим
[42:19.440 --> 42:21.440]  из результаты, вычленяем наши
[42:21.440 --> 42:23.440]  значения. То есть у нас
[42:23.440 --> 42:25.440]  по факту здесь
[42:25.440 --> 42:27.440]  стра...
[42:27.440 --> 42:29.440]  Ну, видите, то есть у нас
[42:29.440 --> 42:31.440]  получается с вами создание функции.
[42:31.440 --> 42:33.440]  Это создание прямо отдельных
[42:33.440 --> 42:35.440]  объектов, в которые мы
[42:35.440 --> 42:37.440]  дальше можем прыгать.
[42:37.440 --> 42:39.440]  Вот. То есть и тут
[42:39.440 --> 42:41.440]  как, кстати, еще и другие метки
[42:41.440 --> 42:43.440]  есть. То есть, в принципе,
[42:43.440 --> 42:45.440]  после этого мы вообще можем
[42:45.440 --> 42:47.440]  перепрыгнуть в другую функцию. То есть
[42:47.440 --> 42:49.440]  как бы у нас здесь сохраняется контекст
[42:49.440 --> 42:51.440]  исполнения. Да? То есть мы вызываем
[42:51.440 --> 42:53.440]  с вами вот эту function base,
[42:53.440 --> 42:55.440]  загружаем это все в
[42:55.440 --> 42:57.440]  переменных. То есть у нас по факту
[42:57.440 --> 42:59.440]  класс является своим собственным объектом.
[42:59.440 --> 43:01.440]  То есть вот мы
[43:01.440 --> 43:03.440]  с вами как раз...
[43:03.440 --> 43:05.440]  Это у нас, кстати, main,
[43:05.440 --> 43:07.440]  который алоцировался.
[43:07.440 --> 43:09.440]  Мы, смотрите, создаем class function.
[43:09.440 --> 43:11.440]  Это dialog function.
[43:11.440 --> 43:13.440]  Дальше алоцируем
[43:13.440 --> 43:15.440]  указатель на
[43:15.440 --> 43:17.440]  анонимный элемент, на
[43:17.440 --> 43:19.440]  anonymous. Дальше, значит, мы записываем
[43:19.440 --> 43:21.440]  переменную %1 в %4.
[43:21.440 --> 43:23.440]  То есть вот мы принимаем
[43:23.440 --> 43:25.440]  контекст исполнения функции
[43:25.440 --> 43:27.440]  main. Вот. И после этого
[43:27.440 --> 43:29.440]  уже вызываем нашу
[43:29.440 --> 43:31.440]  функцию, function base.
[43:33.440 --> 43:35.440]  То есть здесь это прямо
[43:39.440 --> 43:41.440]  function
[43:41.440 --> 43:43.440]  мы создаем.
[43:43.440 --> 43:45.440]  А вот она, кстати,
[43:45.440 --> 43:47.440]  вот эта вот функция, у нее как раз
[43:47.440 --> 43:49.440]  нотация вот
[43:49.440 --> 43:51.440]  вот такая вот. Кстати, где у нас
[43:51.440 --> 43:53.440]  здесь printf? Давайте найдем его.
[43:55.440 --> 43:57.440]  Вот она у нас
[43:57.440 --> 43:59.440]  тело функции. То есть у нее
[43:59.440 --> 44:01.440]  как раз манглинг случается
[44:01.440 --> 44:03.440]  вот таким образом. То есть мы с вами
[44:03.440 --> 44:05.440]  алоцируем объект, а дальше
[44:05.440 --> 44:07.440]  уже получаем элемент из
[44:07.440 --> 44:09.440]  аргумента. Значит, почему
[44:09.440 --> 44:11.440]  так сделано? Потому что здесь
[44:11.440 --> 44:13.440]  есть еще capturing переменных.
[44:13.440 --> 44:15.440]  То есть мы можем int
[44:15.440 --> 44:17.440]  y равно 5 сделать и
[44:17.440 --> 44:19.440]  принять.
[44:19.440 --> 44:21.440]  По-моему, вот так принимается.
[44:31.440 --> 44:33.440]  То есть у нас получается уже
[44:33.440 --> 44:35.440]  функция принимает и еще
[44:35.440 --> 44:37.440]  один аргумент.
[44:39.440 --> 44:41.440]  Кстати, подождите.
[44:43.440 --> 44:45.440]  Давайте сделаем x плюс y.
[44:47.440 --> 44:49.440]  Мы с вами
[44:49.440 --> 44:51.440]  ищем переменную.
[44:51.440 --> 44:53.440]  Вот она нам приходит.
[44:53.440 --> 44:55.440]  Значит, откуда она у нас нам приходит?
[44:57.440 --> 44:59.440]  То есть мы делаем процент 6 и
[44:59.440 --> 45:01.440]  процент 8. То есть у нас процент 6
[45:01.440 --> 45:03.440]  загружает наш элемент.
[45:03.440 --> 45:05.440]  И вот смотрите, очень интересный
[45:05.440 --> 45:07.440]  момент. То есть у нас
[45:07.440 --> 45:09.440]  есть переменная класс anon.
[45:09.440 --> 45:11.440]  Именно в этой класс
[45:11.440 --> 45:13.440]  anon мы загружаем значение
[45:13.440 --> 45:15.440]  нулевого элемента.
[45:15.440 --> 45:17.440]  То есть получается
[45:17.440 --> 45:19.440]  вот это значение, которое мы загрузили,
[45:19.440 --> 45:21.440]  это на самом деле элемент структуры
[45:21.440 --> 45:23.440]  нашего класса. Просто у
[45:23.440 --> 45:25.440]  нас получается, здесь у нас нету явных
[45:25.440 --> 45:27.440]  классов в силанге,
[45:27.440 --> 45:29.440]  в львемском, но вот
[45:29.440 --> 45:31.440]  видно все равно, что мы какие-то
[45:31.440 --> 45:33.440]  тут переменные загрузили все-таки.
[45:45.440 --> 45:47.440]  Вот.
[45:47.440 --> 45:49.440]  Ну и что
[45:49.440 --> 45:51.440]  мы с вами в итоге видим?
[45:51.440 --> 45:53.440]  Мы с вами видим интересные
[45:53.440 --> 45:55.440]  объекты.
[45:55.440 --> 45:57.440]  Вот.
[45:57.440 --> 45:59.440]  Вот.
[45:59.440 --> 46:01.440]  Вот.
[46:01.440 --> 46:03.440]  Вот.
[46:03.440 --> 46:05.440]  Вот.
[46:05.440 --> 46:07.440]  Вот.
[46:07.440 --> 46:09.440]  Вот.
[46:09.440 --> 46:11.440]  Вот.
[46:11.440 --> 46:13.440]  Вот.
[46:13.440 --> 46:15.440]  Ну и что мы с вами в итоге видим?
[46:15.440 --> 46:17.440]  Мы с вами видим интересную вещь, что в принципе
[46:17.440 --> 46:19.440]  императивная парадигма
[46:19.440 --> 46:21.440]  программирования нас сталкивает к тому,
[46:21.440 --> 46:23.440]  что наши объекты должны быть экземплярами
[46:23.440 --> 46:25.440]  классов.
[46:25.440 --> 46:27.440]  То есть по факту у нас функция
[46:27.440 --> 46:29.440]  это классы набором аргументов.
[46:29.440 --> 46:31.440]  И по факту, когда мы с вами
[46:31.440 --> 46:33.440]  вот эту вот функцию создаваем, мы создаем
[46:33.440 --> 46:35.440]  с вами конструктор этого класса
[46:35.440 --> 46:37.440]  и принимаем аргумент y и передаем
[46:37.440 --> 46:39.440]  дальше в эту функцию
[46:39.440 --> 46:41.440]  значение x.
[46:41.440 --> 46:43.440]  То есть мы создаем как раз одну функцию
[46:43.440 --> 46:45.440]  с одним аргументом.
[46:45.440 --> 46:47.440]  Да. Собственно, класс
[46:47.440 --> 46:49.440]  Anon%0 это как раз SelfObject.
[46:51.440 --> 46:53.440]  Который у нас есть.
[46:55.440 --> 46:57.440]  Вот. И если мы посмотрим, кстати.
[47:01.440 --> 47:03.440]  Вот.
[47:03.440 --> 47:05.440]  И, кстати, здесь тоже
[47:05.440 --> 47:07.440]  про то, что вы говорили,
[47:07.440 --> 47:09.440]  возвращается AddressOfMain.
[47:09.440 --> 47:11.440]  Называется функция,
[47:11.440 --> 47:13.440]  которая как раз распаковывает
[47:13.440 --> 47:15.440]  объекты по указателю.
[47:19.440 --> 47:21.440]  Вот, конечно, не оптимизировано, но все же.
[47:21.440 --> 47:23.440]  Вот. И AccessFromMain тоже есть.
[47:23.440 --> 47:25.440]  Вот. То есть мы
[47:25.440 --> 47:27.440]  с вами поняли, как работают классы.
[47:27.440 --> 47:29.440]  Так. Понятно ли это?
[47:29.440 --> 47:31.440]  Что объект со структурой.
[47:31.440 --> 47:33.440]  Вот. А теперь вопрос.
[47:33.440 --> 47:35.440]  Как работают чисто функциональные
[47:35.440 --> 47:37.440]  парадигмы? То есть ладно бы,
[47:37.440 --> 47:39.440]  если у нас есть оперативная парадигма,
[47:39.440 --> 47:41.440]  то, на самом деле, очень
[47:41.440 --> 47:43.440]  просто взять и наши объекты
[47:43.440 --> 47:45.440]  скомпилировать
[47:45.440 --> 47:47.440]  в определенный язык.
[47:47.440 --> 47:49.440]  Но что делать, если нам приходится работать
[47:49.440 --> 47:51.440]  с функциональной парадигмой?
[47:51.440 --> 47:53.440]  В моем случае мы можем использовать какой-то граф
[47:53.440 --> 47:55.440]  вычисления, потому что
[47:55.440 --> 47:57.440]  очередной шаг
[47:57.440 --> 47:59.440]  это не вычисление, а довершение
[47:59.440 --> 48:01.440]  внизу в блок графа вычисления.
[48:01.440 --> 48:03.440]  А когда потом нам
[48:03.440 --> 48:05.440]  пришлось такое, что мы
[48:05.440 --> 48:07.440]  будем спрашивать, то у нас будет
[48:07.440 --> 48:09.440]  все части этого графа, которые были
[48:09.440 --> 48:11.440]  напрошены.
[48:11.440 --> 48:13.440]  Ну да.
[48:13.440 --> 48:15.440]  Ну да. На самом деле это похожая вещь.
[48:15.440 --> 48:17.440]  Там просто наша цель
[48:17.440 --> 48:19.440]  будет следующая. Поскольку у нас функциональные
[48:19.440 --> 48:21.440]  языки программирования, они
[48:21.440 --> 48:23.440]  стараются выражать все, во-первых, максимально
[48:23.440 --> 48:25.440]  функционально, а во-вторых, в парадигме
[48:25.440 --> 48:27.440]  линейных вычислений, то конечно же нам
[48:27.440 --> 48:29.440]  нужно запускать граф вычислений и его считать.
[48:29.440 --> 48:31.440]  Только на самом деле
[48:31.440 --> 48:33.440]  нам нужно будет явно задать инструкции.
[48:33.440 --> 48:35.440]  То есть у нас мы строим граф
[48:35.440 --> 48:37.440]  вычислений, и нам нужно попытаться
[48:37.440 --> 48:39.440]  в низком
[48:39.440 --> 48:41.440]  уровне нашего языка попробовать
[48:41.440 --> 48:43.440]  задать эти как раз низкие
[48:43.440 --> 48:45.440]  граф вычислений.
[48:45.440 --> 48:47.440]  Итак, сейчас мы
[48:47.440 --> 48:49.440]  посмотрим с вами на чисто функциональную парадигму,
[48:49.440 --> 48:51.440]  именно посмотрим, как компилиться
[48:51.440 --> 48:53.440]  код на Haskell.
[48:53.440 --> 48:55.440]  Давайте посмотрим.
[48:55.440 --> 48:57.440]  Я взял книгу.
[48:57.440 --> 48:59.440]  Значит,
[48:59.440 --> 49:01.440]  гхс, Haskell-компилер.
[49:01.440 --> 49:03.440]  И сейчас мы с вами как раз попробуем
[49:03.440 --> 49:05.440]  написать нашу фазу.
[49:05.440 --> 49:07.440]  Значит, сразу скажу,
[49:07.440 --> 49:09.440]  что здесь добавляется одна
[49:09.440 --> 49:11.440]  важная фаза, про которую мы с вами
[49:11.440 --> 49:13.440]  не поговорили.
[49:13.440 --> 49:15.440]  Но она не менее важна
[49:15.440 --> 49:17.440]  во всех компиляторах.
[49:17.440 --> 49:19.440]  Вот. Просто мы ее
[49:19.440 --> 49:21.440]  пропустили.
[49:21.440 --> 49:23.440]  Так, смотрите, с чего начинается.
[49:23.440 --> 49:25.440]  Для того, чтобы написать нам
[49:25.440 --> 49:27.440]  код на Haskell,
[49:27.440 --> 49:29.440]  нам нужно начать со следующего.
[49:29.440 --> 49:31.440]  Значит, у нас должен быть файл
[49:31.440 --> 49:33.440]  с расширением Haskell. Haskell у нас
[49:33.440 --> 49:35.440]  компилируется.
[49:35.440 --> 49:37.440]  .hs, да.
[49:37.440 --> 49:39.440]  После этого у нас возникает
[49:39.440 --> 49:41.440]  следующее понятие под названием
[49:41.440 --> 49:43.440]  parse.
[49:43.440 --> 49:45.440]  Ну, распарсить.
[49:45.440 --> 49:47.440]  Да, распарсить. Я думаю, с этим никаких проблем нет.
[49:47.440 --> 49:49.440]  Но авторы Haskell'а утверждают,
[49:49.440 --> 49:51.440]  что у них парсер тоже написан в чисто
[49:51.440 --> 49:53.440]  функциональной парадигме.
[49:53.440 --> 49:55.440]  Ну...
[49:55.440 --> 49:57.440]  Ну да.
[49:57.440 --> 49:59.440]  Условно есть.
[49:59.440 --> 50:01.440]  Р не вообще функциональный
[50:01.440 --> 50:03.440]  парадигм. Да, да, да.
[50:03.440 --> 50:05.440]  В принципе, так и есть.
[50:05.440 --> 50:07.440]  Регион функциональный,
[50:07.440 --> 50:09.440]  пока вы это не отключите.
[50:09.440 --> 50:11.440]  Ну да, то есть удобная работа.
[50:11.440 --> 50:13.440]  Спарсер функциональный парадигм. Ну, в принципе, да.
[50:13.440 --> 50:15.440]  У нас зашли в одну структуру,
[50:15.440 --> 50:17.440]  не смогли ее распарсить,
[50:17.440 --> 50:19.440]  пошли в следующую.
[50:19.440 --> 50:21.440]  Рекурсивный спуск, в принципе.
[50:21.440 --> 50:23.440]  Рекурсивный спуск вообще
[50:23.440 --> 50:25.440]  попал, да.
[50:25.440 --> 50:27.440]  Рекурс вообще функциональный парадигм.
[50:27.440 --> 50:29.440]  Да, да, да.
[50:29.440 --> 50:31.440]  Вторая стадия, смотрите,
[50:31.440 --> 50:33.440]  здесь она называется ренейминг.
[50:33.440 --> 50:35.440]  Значит...
[50:35.440 --> 50:37.440]  Манглинг.
[50:37.440 --> 50:39.440]  Манглинг
[50:39.440 --> 50:41.440]  в прямом смысле слова.
[50:41.440 --> 50:43.440]  В Haskell'е
[50:43.440 --> 50:45.440]  нет такого понятия, как
[50:45.440 --> 50:47.440]  таблица символов.
[50:47.440 --> 50:49.440]  Они сразу
[50:49.440 --> 50:51.440]  перекидывают все
[50:51.440 --> 50:53.440]  на фули квалифайд на мейн-нейм.
[50:53.440 --> 50:55.440]  Все переписывают.
[50:55.440 --> 50:57.440]  При этом
[50:57.440 --> 50:59.440]  это требует некоторое количество проходов,
[50:59.440 --> 51:01.440]  но они говорят, что ну и ладно.
[51:01.440 --> 51:03.440]  Типа
[51:03.440 --> 51:05.440]  не сильно это беда.
[51:05.440 --> 51:07.440]  С учетом того, что у нас обычно все переменные,
[51:07.440 --> 51:09.440]  они как бы анонимные и привязаны в каком-то контексте.
[51:09.440 --> 51:11.440]  Итак.
[51:11.440 --> 51:13.440]  Дальше мы с вами происходим в следующее.
[51:13.440 --> 51:15.440]  У нас с вами происходит тайпчейкер.
[51:15.440 --> 51:17.440]  То есть, ну, опять же, в любом компиляторе
[51:17.440 --> 51:19.440]  у нас должен быть тайпчейкинг.
[51:19.440 --> 51:21.440]  Здесь он тоже некоторый
[51:21.440 --> 51:23.440]  свичной реализон.
[51:23.440 --> 51:25.440]  Дальше следующая стадия
[51:25.440 --> 51:27.440]  называется
[51:27.440 --> 51:29.440]  дешугеринг.
[51:29.440 --> 51:31.440]  То есть, на самом деле
[51:31.440 --> 51:33.440]  большая часть инструкций, которые
[51:33.440 --> 51:35.440]  мы с вами видим в Haskell'е
[51:35.440 --> 51:37.440]  это синтоксический
[51:37.440 --> 51:39.440]  сахар.
[51:39.440 --> 51:41.440]  То есть, на самом деле такого быть не может.
[51:41.440 --> 51:43.440]  И мы с вами понимаем,
[51:43.440 --> 51:45.440]  что если у нас какие-то лямбда функции есть,
[51:45.440 --> 51:47.440]  то зачастую как раз
[51:47.440 --> 51:49.440]  нам нужно их явно писать.
[51:49.440 --> 51:51.440]  То есть, у нас есть только функции
[51:51.440 --> 51:53.440]  и набор аргументов, которые она может принимать.
[51:53.440 --> 51:55.440]  Значит, и здесь мы спускаемся
[51:55.440 --> 51:57.440]  на первый язык, так сказать,
[51:57.440 --> 51:59.440]  который
[51:59.440 --> 52:01.440]  называется ER-ом языка
[52:01.440 --> 52:03.440]  Haskell. Это core.
[52:03.440 --> 52:05.440]  GHC-Core.
[52:05.440 --> 52:07.440]  И вот здесь уже будет некоторый небольшой
[52:07.440 --> 52:09.440]  набор инструкций, который у нас будет.
[52:09.440 --> 52:11.440]  Дальше что мы можем сделать?
[52:11.440 --> 52:13.440]  Дальше мы закидываем это все
[52:13.440 --> 52:15.440]  в операцию simplify.
[52:15.440 --> 52:17.440]  То есть, это упрощение дерева ER,
[52:17.440 --> 52:19.440]  которое у нас было. Мы его
[52:19.440 --> 52:21.440]  просматривали на одной из лекций.
[52:21.440 --> 52:23.440]  И здесь как раз
[52:23.440 --> 52:25.440]  есть некоторые опции,
[52:25.440 --> 52:27.440]  которые мы можем с вами сделать. То есть, мы можем
[52:27.440 --> 52:29.440]  переписать правила, мы можем проверить
[52:29.440 --> 52:31.440]  строгость типов
[52:31.440 --> 52:33.440]  и специализация
[52:33.440 --> 52:35.440]  конструкторов. После этого
[52:35.440 --> 52:37.440]  мы получаем с вами core-tidy,
[52:37.440 --> 52:39.440]  то есть, очистку
[52:39.440 --> 52:41.440]  названия наших перемен
[52:41.440 --> 52:43.440]  явным образом.
[52:43.440 --> 52:45.440]  А дальше
[52:45.440 --> 52:47.440]  что мы можем с вами сделать?
[52:47.440 --> 52:49.440]  Дальше у нас есть две развилки.
[52:49.440 --> 52:51.440]  Либо мы делаем интерфейсный
[52:51.440 --> 52:53.440]  объект, которым можно подключить извне,
[52:53.440 --> 52:55.440]  либо можем впуститься дальше.
[52:55.440 --> 52:57.440]  После этого
[52:57.440 --> 52:59.440]  у нас
[52:59.440 --> 53:01.440]  готовится наш язык
[53:01.440 --> 53:03.440]  промежуточного представления в нормальную
[53:03.440 --> 53:05.440]  форму. Называется aNormalForm.
[53:05.440 --> 53:07.440]  И после этого
[53:07.440 --> 53:09.440]  она трансформируется еще
[53:09.440 --> 53:11.440]  в одну стадию, называется STG.
[53:11.440 --> 53:13.440]  В чем ее суть?
[53:13.440 --> 53:15.440]  Это вот просто уже
[53:15.440 --> 53:17.440]  а-ля байт-машина.
[53:17.440 --> 53:19.440]  А-ля байт-код-машина для
[53:19.440 --> 53:21.440]  нашего этого.
[53:21.440 --> 53:23.440]  Для кого?
[53:23.440 --> 53:25.440]  Для компилятора.
[53:25.440 --> 53:27.440]  И вот из нее мы уже делаем кодогенерацию.
[53:27.440 --> 53:29.440]  Причем, давайте посмотрим, куда мы
[53:29.440 --> 53:31.440]  именно делаем кодогенерацию.
[53:37.440 --> 53:39.440]  А?
[53:39.440 --> 53:41.440]  Да-да-да.
[53:41.440 --> 53:43.440]  То есть либо...
[53:47.440 --> 53:49.440]  Ну да, то есть в принципе оно
[53:49.440 --> 53:51.440]  генерирует в одну из
[53:51.440 --> 53:53.440]  стадий. То есть мы можем даже
[53:53.440 --> 53:55.440]  сгенировать LVM-код.
[53:55.440 --> 53:57.440]  Да.
[53:57.440 --> 53:59.440]  Да, можем
[53:59.440 --> 54:01.440]  сгенировать сечный код. То есть в принципе здесь есть
[54:01.440 --> 54:03.440]  разные
[54:03.440 --> 54:05.440]  различия.
[54:05.440 --> 54:07.440]  Ну и в общем здесь вот эти
[54:07.440 --> 54:09.440]  все стадии мы сейчас потихонечку и разберем.
[54:09.440 --> 54:11.440]  В первую парадигму.
[54:11.440 --> 54:13.440]  Так, понятно структура?
[54:13.440 --> 54:15.440]  Вот, значит
[54:15.440 --> 54:17.440]  что они говорят? Они говорят следующее,
[54:17.440 --> 54:19.440]  что GHC
[54:19.440 --> 54:21.440]  написали свои собственные инструменты.
[54:21.440 --> 54:23.440]  Alex и Happy.
[54:23.440 --> 54:25.440]  Которые аналог Lexa и Yak.
[54:27.440 --> 54:29.440]  Давайте попробуем посмотреть.
[54:29.440 --> 54:31.440]  А?
[54:37.440 --> 54:39.440]  Так, где оно?
[54:39.440 --> 54:41.440]  GHC
[54:41.440 --> 54:43.440]  это интерфейс.
[54:45.440 --> 54:47.440]  Интересно, сколько?
[54:47.440 --> 54:49.440]  85% на Хаскеле написано.
[54:49.440 --> 54:51.440]  Так.
[54:55.440 --> 54:57.440]  Driver, GHC.
[54:57.440 --> 54:59.440]  Нет, это C++.
[55:01.440 --> 55:03.440]  Компилер его.
[55:05.440 --> 55:07.440]  Вот он.
[55:07.440 --> 55:09.440]  То есть вот они у нас в стадии.
[55:09.440 --> 55:11.440]  Здесь они как раз все есть.
[55:11.440 --> 55:13.440]  Так, а где тут
[55:13.440 --> 55:15.440]  Lexer?
[55:15.440 --> 55:17.440]  Парсер есть.
[55:17.440 --> 55:19.440]  Вот у нас парсер и вот он Lexer.
[55:19.440 --> 55:21.440]  Вот он язык
[55:21.440 --> 55:23.440]  Lexera.
[55:23.440 --> 55:25.440]  На
[55:25.440 --> 55:27.440]  Lexer.x
[55:27.440 --> 55:29.440]  Здесь
[55:29.440 --> 55:31.440]  как раз можно увидеть
[55:31.440 --> 55:33.440]  символы, которые у нас есть.
[55:33.440 --> 55:35.440]  То есть variable ID и так далее.
[55:35.440 --> 55:37.440]  То есть в принципе
[55:39.440 --> 55:41.440]  здесь как раз можно увидеть
[55:41.440 --> 55:43.440]  разные
[55:43.440 --> 55:45.440]  комментарии, способы парсинга
[55:45.440 --> 55:47.440]  комментариев. А дальше мы можем
[55:47.440 --> 55:49.440]  делать это, вывод некоторых
[55:49.440 --> 55:51.440]  символов. Вот это называется
[55:51.440 --> 55:53.440]  как называли? Alex.
[55:53.440 --> 55:55.440]  Теперь давайте парсер посмотрим.
[55:55.440 --> 55:57.440]  Где у нас парсер?
[55:57.440 --> 55:59.440]  Я же не парсер.
[56:07.440 --> 56:09.440]  Неужели они его переименовали?
[56:11.440 --> 56:13.440]  Это header.
[56:13.440 --> 56:15.440]  В общем здесь у нас прямо генируется
[56:15.440 --> 56:17.440]  код, который можно
[56:17.440 --> 56:19.440]  посмотреть и пощупать.
[56:21.440 --> 56:23.440]  Вот он, header.
[56:23.440 --> 56:25.440]  Lex.
[56:25.440 --> 56:27.440]  А, вот он, это уже
[56:27.440 --> 56:29.440]  чистые символы. То есть
[56:29.440 --> 56:31.440]  что мы конкретно с вами делаем
[56:31.440 --> 56:33.440]  в определенном случае?
[56:35.440 --> 56:37.440]  Вот, то есть это
[56:37.440 --> 56:39.440]  как раз
[56:39.440 --> 56:41.440]  так это рано.
[56:41.440 --> 56:43.440]  То есть мы получаем этот перемен.
[56:43.440 --> 56:45.440]  Дальше про ренейминг.
[56:45.440 --> 56:47.440]  Это процесс переменования всех
[56:47.440 --> 56:49.440]  инотификаторов в исходном коде
[56:49.440 --> 56:51.440]  Хаскеля.
[56:51.440 --> 56:53.440]  И теперь
[56:53.440 --> 56:55.440]  тут суть в том, что
[56:55.440 --> 56:57.440]  система Хаскеля
[56:57.440 --> 56:59.440]  устроена так, чтобы мы могли
[56:59.440 --> 57:01.440]  перейкспортировать идентифайер.
[57:01.440 --> 57:03.440]  И дальше здесь указано следующее,
[57:03.440 --> 57:05.440]  что если
[57:07.440 --> 57:09.440]  можно большим количеством
[57:09.440 --> 57:11.440]  образом переаккомпилировать наш
[57:11.440 --> 57:13.440]  перезапускать наш код. Дальше здесь
[57:13.440 --> 57:15.440]  описано каким образом происходит
[57:15.440 --> 57:17.440]  type checking. И последнее, что здесь
[57:17.440 --> 57:19.440]  приходит, это как раз
[57:19.440 --> 57:21.440]  то каким образом устроен
[57:21.440 --> 57:23.440]  язык core.
[57:23.440 --> 57:25.440]  После этого, значит, мы генерируем
[57:25.440 --> 57:27.440]  весь язык в STG.
[57:27.440 --> 57:29.440]  И у нас тут есть три механизма.
[57:29.440 --> 57:31.440]  И вот тут как раз
[57:31.440 --> 57:33.440]  есть минимальный язык,
[57:33.440 --> 57:35.440]  в котором нам нужно
[57:35.440 --> 57:37.440]  с вами разобраться.
[57:37.440 --> 57:39.440]  То есть
[57:39.440 --> 57:41.440]  вот по факту это основной синтакс из того,
[57:41.440 --> 57:43.440]  что поддерживает core. То есть у нас есть
[57:43.440 --> 57:45.440]  переменные, у нас есть
[57:45.440 --> 57:47.440]  data конструкторы, у нас есть литералы,
[57:47.440 --> 57:49.440]  у нас с вами есть лямбда функции,
[57:49.440 --> 57:51.440]  которая абстрагирует
[57:51.440 --> 57:53.440]  либо тип, либо переменную.
[57:53.440 --> 57:55.440]  И есть биндинги.
[57:55.440 --> 57:57.440]  Здесь, наверное, сложно это читать,
[57:57.440 --> 57:59.440]  потому что
[57:59.440 --> 58:01.440]  тут детали есть. Поэтому я подготовил
[58:01.440 --> 58:03.440]  еще одну вещь.
[58:03.440 --> 58:05.440]  Так, это не то.
[58:09.440 --> 58:11.440]  А, вот она. Это значит
[58:11.440 --> 58:13.440]  understanding Haskell core features.
[58:13.440 --> 58:15.440]  То есть как оно у нас работает.
[58:15.440 --> 58:17.440]  То есть это именно
[58:17.440 --> 58:19.440]  то, как работает
[58:19.440 --> 58:21.440]  Haskell core. Итак, значит,
[58:21.440 --> 58:23.440]  все, что есть в Haskell
[58:23.440 --> 58:25.440]  это на самом деле
[58:25.440 --> 58:27.440]  синтактический сахар. То есть
[58:27.440 --> 58:29.440]  смотрите.
[58:29.440 --> 58:31.440]  Ну, да.
[58:31.440 --> 58:33.440]  Давайте.
[58:35.440 --> 58:37.440]  Ну, не, ну не совсем.
[58:39.440 --> 58:41.440]  Да. Все, что сложнее, чем лямбда.
[58:41.440 --> 58:43.440]  Давайте прочитаем
[58:43.440 --> 58:45.440]  вот этот вот код.
[58:45.440 --> 58:47.440]  Значит, у нас есть какая-то функция product,
[58:47.440 --> 58:49.440]  которая принимает список.
[58:49.440 --> 58:51.440]  A плюс B и
[58:51.440 --> 58:53.440]  C плюс D. Значит, она
[58:53.440 --> 58:55.440]  использует несколько фичей. Первое
[58:55.440 --> 58:57.440]  это листы тиралы.
[58:57.440 --> 58:59.440]  То есть как у нас списки организовываются.
[58:59.440 --> 59:01.440]  А дальше
[59:01.440 --> 59:03.440]  у нас с вами есть
[59:03.440 --> 59:05.440]  function application. То есть мы применяем функцию.
[59:05.440 --> 59:07.440]  Итак, давайте прочитаем,
[59:07.440 --> 59:09.440]  что же здесь происходит.
[59:09.440 --> 59:11.440]  Что же это за функция product такая?
[59:13.440 --> 59:15.440]  То есть это
[59:15.440 --> 59:17.440]  то же самое, что и здесь.
[59:21.440 --> 59:23.440]  Значит, здесь у нас идет
[59:23.440 --> 59:25.440]  оператор application. То есть у нас есть
[59:25.440 --> 59:27.440]  функция plus.
[59:27.440 --> 59:29.440]  Оператор
[59:29.440 --> 59:31.440]  в двоеточии
[59:31.440 --> 59:33.440]  он занимает письменство
[59:33.440 --> 59:35.440]  в клее в этом списке и делеген.
[59:35.440 --> 59:37.440]  Да, да, да.
[59:37.440 --> 59:39.440]  То есть у нас получается
[59:39.440 --> 59:41.440]  мы учисляем A плюс B, после этого
[59:41.440 --> 59:43.440]  используем двоеточие, потом используем
[59:43.440 --> 59:45.440]  C плюс D, потом...
[59:51.440 --> 59:53.440]  Да, да, да.
[59:53.440 --> 59:55.440]  Ну, и этот код сложно читать.
[59:55.440 --> 59:57.440]  Это был уже чистый функциональный парадигм.
[59:57.440 --> 59:59.440]  То есть мы берем пустой список,
[59:59.440 --> 01:00:01.440]  применяем оператор конкатинации,
[01:00:01.440 --> 01:00:03.440]  прибавления, и дальше
[01:00:03.440 --> 01:00:05.440]  мы получаем
[01:00:05.440 --> 01:00:07.440]  результат.
[01:00:07.440 --> 01:00:09.440]  И, собственно, здесь...
[01:00:11.440 --> 01:00:13.440]  Ну, да, да, да.
[01:00:13.440 --> 01:00:15.440]  То есть как же удобно это все.
[01:00:15.440 --> 01:00:17.440]  И, собственно,
[01:00:17.440 --> 01:00:19.440]  здесь первый шаг — это лексический анализ.
[01:00:19.440 --> 01:00:21.440]  Я думаю, что
[01:00:21.440 --> 01:00:23.440]  здесь мы останавливаться не будем.
[01:00:23.440 --> 01:00:25.440]  Здесь важно просто,
[01:00:25.440 --> 01:00:27.440]  поскольку у нас все является...
[01:00:27.440 --> 01:00:29.440]  Единственный момент, что поскольку у нас
[01:00:29.440 --> 01:00:31.440]  все является синтетическим фасахером,
[01:00:31.440 --> 01:00:33.440]  то нам нужно будет найти в других модулях
[01:00:33.440 --> 01:00:35.440]  реализация этих функций.
[01:00:35.440 --> 01:00:37.440]  Надо проверить, что у нас есть
[01:00:37.440 --> 01:00:39.440]  те или иные контексты.
[01:00:39.440 --> 01:00:41.440]  Более того, мы должны уметь
[01:00:41.440 --> 01:00:43.440]  распарсить эту структуру.
[01:00:43.440 --> 01:00:45.440]  То есть вот эта структура — это у нас
[01:00:45.440 --> 01:00:47.440]  Operation Application, что мы применяем операцию.
[01:00:47.440 --> 01:00:49.440]  То есть нам нужно переставить наш аргумент.
[01:00:49.440 --> 01:00:51.440]  Дальше мы получаем, собственно,
[01:00:51.440 --> 01:00:53.440]  синтетический анализ.
[01:00:53.440 --> 01:00:55.440]  У нас получается синтоксическое дерево.
[01:00:55.440 --> 01:00:57.440]  После этого мы
[01:00:57.440 --> 01:00:59.440]  делаем type checking,
[01:00:59.440 --> 01:01:01.440]  который делает синтокс.
[01:01:01.440 --> 01:01:03.440]  И дальше у нас идет
[01:01:03.440 --> 01:01:05.440]  de-sugaring либо в core,
[01:01:05.440 --> 01:01:07.440]  либо в stg, либо в c-.
[01:01:07.440 --> 01:01:09.440]  Итак, значит,
[01:01:09.440 --> 01:01:11.440]  что у нас есть в коре?
[01:01:11.440 --> 01:01:13.440]  Давайте разбираться.
[01:01:13.440 --> 01:01:15.440]  Значит, у нас в коре есть переменные.
[01:01:15.440 --> 01:01:17.440]  У нас есть литералы.
[01:01:17.440 --> 01:01:19.440]  У нас, на самом деле,
[01:01:19.440 --> 01:01:21.440]  не поверите...
[01:01:31.440 --> 01:01:33.440]  Дальше у нас есть лямда.
[01:01:33.440 --> 01:01:35.440]  Это лямда-функция,
[01:01:35.440 --> 01:01:37.440]  которая принимает аргументы.
[01:01:37.440 --> 01:01:39.440]  В общем, здесь огромное
[01:01:39.440 --> 01:01:41.440]  количество паттернов.
[01:01:41.440 --> 01:01:43.440]  То есть вот они.
[01:01:43.440 --> 01:01:45.440]  У нас есть как раз паттерначик,
[01:01:45.440 --> 01:01:47.440]  который нам надо как раз это все
[01:01:47.440 --> 01:01:49.440]  переобразовать.
[01:01:49.440 --> 01:01:51.440]  А теперь смотрите, что у нас
[01:01:51.440 --> 01:01:53.440]  в коре есть.
[01:01:53.440 --> 01:01:55.440]  Вот все, что у нас есть в коре.
[01:01:55.440 --> 01:01:57.440]  То есть у нас есть
[01:01:57.440 --> 01:01:59.440]  variable-identity, есть lit-literal,
[01:01:59.440 --> 01:02:01.440]  есть application, есть
[01:02:01.440 --> 01:02:03.440]  лямда,
[01:02:03.440 --> 01:02:05.440]  variable-expression, есть bind,
[01:02:05.440 --> 01:02:07.440]  привязать примерно значение.
[01:02:07.440 --> 01:02:09.440]  Смотрите, if-of нет,
[01:02:09.440 --> 01:02:11.440]  то есть оператора verse здесь нет, есть оператор
[01:02:11.440 --> 01:02:13.440]  case, который принимает
[01:02:13.440 --> 01:02:15.440]  набор альтернатив.
[01:02:17.440 --> 01:02:19.440]  И есть
[01:02:19.440 --> 01:02:21.440]  krc.
[01:02:21.440 --> 01:02:23.440]  Причем, смотрите,
[01:02:23.440 --> 01:02:25.440]  здесь описаны прямо данные.
[01:02:25.440 --> 01:02:27.440]  У нас получается есть let-bind-expression,
[01:02:27.440 --> 01:02:29.440]  а вот она bind.
[01:02:29.440 --> 01:02:31.440]  То есть каким он образом работает.
[01:02:31.440 --> 01:02:33.440]  Мы привязываем
[01:02:33.440 --> 01:02:35.440]  наш значение. То есть у нас с вами
[01:02:35.440 --> 01:02:37.440]  по факту есть функции
[01:02:37.440 --> 01:02:39.440]  приложений.
[01:02:39.440 --> 01:02:41.440]  У нас есть лямды.
[01:02:41.440 --> 01:02:43.440]  У нас есть лед-биндинги.
[01:02:43.440 --> 01:02:45.440]  То есть они у нас остаются.
[01:02:45.440 --> 01:02:47.440]  И есть у нас
[01:02:47.440 --> 01:02:49.440]  coefficients.
[01:02:49.440 --> 01:02:51.440]  То есть у нас давайте
[01:02:51.440 --> 01:02:53.440]  чтобы вы понимали,
[01:02:53.440 --> 01:02:55.440]  что такое coefficients.
[01:03:01.440 --> 01:03:03.440]  Итак, читаем документацию.
[01:03:05.440 --> 01:03:07.440]  Что оно
[01:03:07.440 --> 01:03:09.440]  делает?
[01:03:11.440 --> 01:03:13.440]  А,
[01:03:13.440 --> 01:03:15.440]  это pattern-munching у нас.
[01:03:17.440 --> 01:03:19.440]  То есть,
[01:03:19.440 --> 01:03:21.440]  которое позволяет
[01:03:21.440 --> 01:03:23.440]  копировать типа.
[01:03:25.440 --> 01:03:27.440]  Вот, то есть это
[01:03:27.440 --> 01:03:29.440]  именно привязка
[01:03:29.440 --> 01:03:31.440]  переменная к значению.
[01:03:31.440 --> 01:03:33.440]  Вот, то есть у нас есть какие-то
[01:03:33.440 --> 01:03:35.440]  простые именно типа.
[01:03:35.440 --> 01:03:37.440]  И давайте сейчас как раз разберем,
[01:03:37.440 --> 01:03:39.440]  как работают эти
[01:03:39.440 --> 01:03:41.440]  дегринги, например.
[01:03:41.440 --> 01:03:43.440]  Итак, значит, если у нас есть инфиксные операторы,
[01:03:43.440 --> 01:03:45.440]  то они кастуются вот таким образом.
[01:03:45.440 --> 01:03:47.440]  То есть у нас идет трансформация
[01:03:47.440 --> 01:03:49.440]  наших Haskell-Core в операцию
[01:03:49.440 --> 01:03:51.440]  вот такую.
[01:03:51.440 --> 01:03:53.440]  И значит,
[01:03:53.440 --> 01:03:55.440]  здесь у нас происходит следующее,
[01:03:55.440 --> 01:03:57.440]  что это базовая трансляция,
[01:03:57.440 --> 01:03:59.440]  а вот здесь вот у нас
[01:03:59.440 --> 01:04:01.440]  давайте посмотрим, что происходит.
[01:04:01.440 --> 01:04:03.440]  Почему наш код должен быть
[01:04:03.440 --> 01:04:05.440]  именно вот таким?
[01:04:09.440 --> 01:04:11.440]  Типа вот вверх вот здесь.
[01:04:15.440 --> 01:04:17.440]  Да.
[01:04:17.440 --> 01:04:19.440]  Что это означает?
[01:04:19.440 --> 01:04:21.440]  У нас, значит, получается оператор
[01:04:21.440 --> 01:04:23.440]  2i,
[01:04:23.440 --> 01:04:25.440]  который принимает функцию bool
[01:04:25.440 --> 01:04:27.440]  и который
[01:04:27.440 --> 01:04:29.440]  возвращает из bools bool.
[01:04:29.440 --> 01:04:31.440]  То есть мы можем сделать полную спецификацию.
[01:04:31.440 --> 01:04:33.440]  Дальше он принимает переменную
[01:04:33.440 --> 01:04:35.440]  a типа bool и переменную b
[01:04:35.440 --> 01:04:37.440]  типа bool. Ну, точнее не переменную,
[01:04:37.440 --> 01:04:39.440]  как называется,
[01:04:39.440 --> 01:04:41.440]  немутируемый объект типа bool.
[01:04:41.440 --> 01:04:43.440]  Вот.
[01:04:43.440 --> 01:04:45.440]  И теперь давайте посмотрим, каким образом
[01:04:45.440 --> 01:04:47.440]  у нас пишется функция. То есть у нас,
[01:04:47.440 --> 01:04:49.440]  когда мы говорим, что у нас есть функция,
[01:04:49.440 --> 01:04:51.440]  то она у нас кастуется вот таким
[01:04:51.440 --> 01:04:53.440]  образом. То есть f это лямбда функция,
[01:04:53.440 --> 01:04:55.440]  slash это лямбда,
[01:04:55.440 --> 01:04:57.440]  которая принимает x
[01:04:57.440 --> 01:04:59.440]  в двоеточие, возвращает x в двоеточие.
[01:04:59.440 --> 01:05:01.440]  Если нам нужно будет с вами
[01:05:01.440 --> 01:05:03.440]  сохранить какие-то аргументы,
[01:05:03.440 --> 01:05:05.440]  то это производится вот таким образом.
[01:05:05.440 --> 01:05:07.440]  То есть мы берем x и y и говорим,
[01:05:07.440 --> 01:05:09.440]  что это нот x или y.
[01:05:09.440 --> 01:05:11.440]  То есть у нас тут как раз
[01:05:11.440 --> 01:05:13.440]  биндинг аргументов.
[01:05:13.440 --> 01:05:15.440]  С левой стороны направо.
[01:05:15.440 --> 01:05:17.440]  Вот. Если у нас это лямбда функция,
[01:05:17.440 --> 01:05:19.440]  то мы таким же
[01:05:19.440 --> 01:05:21.440]  образом это корректируем.
[01:05:23.440 --> 01:05:25.440]  Вот. Ну и, собственно, если мы с вами
[01:05:25.440 --> 01:05:27.440]  пытаемся использовать многофункцию
[01:05:27.440 --> 01:05:29.440]  в переменную, то мы должны идти
[01:05:29.440 --> 01:05:31.440]  в концепцию каринга.
[01:05:31.440 --> 01:05:33.440]  Напоминаю, что такое каринг. Это когда мы
[01:05:33.440 --> 01:05:35.440]  берем и переносим один аргумент
[01:05:37.440 --> 01:05:39.440]  в отдельную функцию. То есть у нас
[01:05:39.440 --> 01:05:41.440]  когда мы подставляем определенное значение
[01:05:41.440 --> 01:05:43.440]  x, то у нас получается функция,
[01:05:43.440 --> 01:05:45.440]  которая идет из y и возвращает
[01:05:45.440 --> 01:05:47.440]  z. То есть это вот специальный
[01:05:47.440 --> 01:05:49.440]  оператор. Даже есть в функциональных
[01:05:49.440 --> 01:05:51.440]  языках программирования.
[01:05:51.440 --> 01:05:53.440]  То есть карри берет нашу функцию
[01:05:53.440 --> 01:05:55.440]  из x и y в z
[01:05:55.440 --> 01:05:57.440]  и перевращает его функцию, которая
[01:05:57.440 --> 01:05:59.440]  принимает x и дальше
[01:05:59.440 --> 01:06:01.440]  принимает x и возвращает функцию
[01:06:01.440 --> 01:06:03.440]  из y в z. И в этом самом мы можем
[01:06:03.440 --> 01:06:05.440]  вычислять наш результат последовательно.
[01:06:05.440 --> 01:06:07.440]  То есть сначала
[01:06:07.440 --> 01:06:09.440]  получить значение, а потом только посчитать результат
[01:06:09.440 --> 01:06:11.440]  по требованию.
[01:06:11.440 --> 01:06:13.440]  Дальше, значит, паттерн
[01:06:13.440 --> 01:06:15.440]  bindings здесь
[01:06:15.440 --> 01:06:17.440]  делается следующее, что у нас
[01:06:17.440 --> 01:06:19.440]  с вами в коре
[01:06:19.440 --> 01:06:21.440]  получается следующая функция. У нас, допустим,
[01:06:21.440 --> 01:06:23.440]  есть a integer, b bool,
[01:06:23.440 --> 01:06:25.440]  а дальше
[01:06:25.440 --> 01:06:27.440]  делается привязка аргументов.
[01:06:27.440 --> 01:06:29.440]  Собственно, у нас возникает
[01:06:29.440 --> 01:06:31.440]  функция запятая,
[01:06:35.440 --> 01:06:37.440]  которая вычленяет
[01:06:37.440 --> 01:06:39.440]  по факту это оператор
[01:06:39.440 --> 01:06:41.440]  проекции
[01:06:41.440 --> 01:06:43.440]  чистого вида. То есть у нас есть x и y,
[01:06:43.440 --> 01:06:45.440]  мы возвращаем x.
[01:06:47.440 --> 01:06:49.440]  То есть, грубо говоря, альтернативный
[01:06:49.440 --> 01:06:51.440]  вариант.
[01:06:59.440 --> 01:07:01.440]  А потом
[01:07:01.440 --> 01:07:03.440]  как бы
[01:07:03.440 --> 01:07:05.440]  вы меняете
[01:07:05.440 --> 01:07:07.440]  периодическую визу,
[01:07:07.440 --> 01:07:09.440]  то у вас для меня тоже будет
[01:07:09.440 --> 01:07:11.440]  определенное предназначение в форме.
[01:07:11.440 --> 01:07:13.440]  Ну да, вот лучше.
[01:07:13.440 --> 01:07:15.440]  Хорошо у вас
[01:07:15.440 --> 01:07:17.440]  разначение, которое
[01:07:17.440 --> 01:07:19.440]  меняет определенное предназначение.
[01:07:19.440 --> 01:07:21.440]  Ну да.
[01:07:21.440 --> 01:07:23.440]  Вот. Собственно,
[01:07:23.440 --> 01:07:25.440]  оператор значения вот такой.
[01:07:25.440 --> 01:07:27.440]  Значит, и
[01:07:27.440 --> 01:07:29.440]  мы делаем именно проекцию.
[01:07:29.440 --> 01:07:31.440]  Если у нас оператор
[01:07:31.440 --> 01:07:33.440]  однобуквенный, то мы тоже
[01:07:33.440 --> 01:07:35.440]  его преобразуем вот такой вид. То есть
[01:07:35.440 --> 01:07:37.440]  говорим, что
[01:07:37.440 --> 01:07:39.440]  примени наш оператор
[01:07:39.440 --> 01:07:41.440]  или к аргументам a, b.
[01:07:41.440 --> 01:07:43.440]  Tuple
[01:07:43.440 --> 01:07:45.440]  Здесь у нас используется
[01:07:45.440 --> 01:07:47.440]  несколько функций.
[01:07:47.440 --> 01:07:49.440]  И
[01:07:49.440 --> 01:07:51.440]  multi-argument matching.
[01:07:51.440 --> 01:07:53.440]  Здесь делается
[01:07:53.440 --> 01:07:55.440]  следующее. Мы говорим, что
[01:07:55.440 --> 01:07:57.440]  по факту мы делаем
[01:07:57.440 --> 01:07:59.440]  с вами таблицу истинности.
[01:07:59.440 --> 01:08:01.440]  То есть они как раз,
[01:08:01.440 --> 01:08:03.440]  когда мы устанавливаем какие-то значения,
[01:08:03.440 --> 01:08:05.440]  они партятся в дерево свич-кейс.
[01:08:07.440 --> 01:08:09.440]  Вот. Если нам нужно
[01:08:09.440 --> 01:08:11.440]  закопаться
[01:08:11.440 --> 01:08:13.440]  в кейс-экспрешена,
[01:08:13.440 --> 01:08:15.440]  то тоже мы это можем
[01:08:15.440 --> 01:08:17.440]  сделать.
[01:08:19.440 --> 01:08:21.440]  То есть l.
[01:08:21.440 --> 01:08:23.440]  Насинг оператор есть.
[01:08:23.440 --> 01:08:25.440]  Дальше.
[01:08:25.440 --> 01:08:27.440]  Значит
[01:08:27.440 --> 01:08:29.440]  кейс
[01:08:29.440 --> 01:08:31.440]  тоже есть, и в the Nels
[01:08:31.440 --> 01:08:33.440]  конвертируется, кстати.
[01:08:37.440 --> 01:08:39.440]  Так, вопрос
[01:08:39.440 --> 01:08:41.440]  к вам.
[01:08:41.440 --> 01:08:43.440]  Есть ли мысли,
[01:08:43.440 --> 01:08:45.440]  почему core конвертирует вот так?
[01:08:45.440 --> 01:08:47.440]  Нет, нет, нет.
[01:08:47.440 --> 01:08:49.440]  Какой порядок стоит?
[01:08:59.440 --> 01:09:01.440]  Нет, потому что
[01:09:01.440 --> 01:09:03.440]  у них
[01:09:03.440 --> 01:09:05.440]  кейс же у нас
[01:09:05.440 --> 01:09:07.440]  не работает.
[01:09:07.440 --> 01:09:09.440]  А кейс
[01:09:09.440 --> 01:09:11.440]  не работает.
[01:09:11.440 --> 01:09:13.440]  А кейс не работает.
[01:09:13.440 --> 01:09:15.440]  А кейс же у нас
[01:09:15.440 --> 01:09:17.440]  работает как он
[01:09:17.440 --> 01:09:19.440]  если
[01:09:19.440 --> 01:09:21.440]  на самом деле функция true
[01:09:21.440 --> 01:09:23.440]  это функция возвращающей первые аргументы,
[01:09:23.440 --> 01:09:25.440]  а функция false — это так.
[01:09:25.440 --> 01:09:27.440]  Поэтому на самом деле
[01:09:27.440 --> 01:09:29.440]  на самом деле
[01:09:29.440 --> 01:09:31.440]  кейс — это применение
[01:09:31.440 --> 01:09:33.440]  Google Arc в двух аргументах.
[01:09:33.440 --> 01:09:35.440]  Ну, это да.
[01:09:35.440 --> 01:09:37.440]  Скорее всего.
[01:09:37.440 --> 01:09:39.440]  Не, я спрашиваю, почему false впереди true?
[01:09:39.440 --> 01:09:41.440]  Ну да.
[01:09:41.440 --> 01:09:43.440]  Дальше.
[01:09:43.440 --> 01:09:45.440]  Оператор sequential.
[01:09:45.440 --> 01:09:47.440]  Собственно,
[01:09:47.440 --> 01:09:49.440]  который у нас есть, он делает следующее.
[01:09:49.440 --> 01:09:51.440]  Он берет и преобразует наши
[01:09:51.440 --> 01:09:53.440]  поля. То есть sequential ab,
[01:09:53.440 --> 01:09:55.440]  case a of.
[01:09:55.440 --> 01:09:57.440]  Любой аргумент мы получаем, возвращаем b.
[01:09:57.440 --> 01:09:59.440]  Вот такая функция.
[01:09:59.440 --> 01:10:01.440]  То есть она добавляет наши аргументы.
[01:10:01.440 --> 01:10:03.440]  Вот.
[01:10:03.440 --> 01:10:05.440]  То есть если у нас есть f и g,
[01:10:05.440 --> 01:10:07.440]  это case bula,
[01:10:07.440 --> 01:10:09.440]  то дальше мы его дописываем.
[01:10:09.440 --> 01:10:11.440]  Дальше, значит, полиморфизум.
[01:10:17.440 --> 01:10:19.440]  Что это делает?
[01:10:21.440 --> 01:10:23.440]  Вот для всех a
[01:10:27.440 --> 01:10:29.440]  z и x.
[01:10:33.440 --> 01:10:35.440]  В общем, тоже видно конвертацию.
[01:10:35.440 --> 01:10:37.440]  То есть что у нас принимается переменная
[01:10:37.440 --> 01:10:39.440]  а определенного типа.
[01:10:39.440 --> 01:10:41.440]  Дальше мы подставляем значение x
[01:10:41.440 --> 01:10:43.440]  типа a.
[01:10:43.440 --> 01:10:45.440]  И возвращаем этот x.
[01:10:49.440 --> 01:10:51.440]  Собственно, здесь тоже у нас
[01:10:51.440 --> 01:10:53.440]  явно представляют стипы,
[01:10:53.440 --> 01:10:55.440]  если мы захотим.
[01:10:55.440 --> 01:10:57.440]  Дальше у нас
[01:10:57.440 --> 01:10:59.440]  есть
[01:10:59.440 --> 01:11:01.440]  функция длина списка.
[01:11:01.440 --> 01:11:03.440]  Собственно, как она
[01:11:03.440 --> 01:11:05.440]  конвертируется.
[01:11:07.440 --> 01:11:09.440]  Следующая.
[01:11:09.440 --> 01:11:11.440]  То есть у нас
[01:11:11.440 --> 01:11:13.440]  вызываем аргумент.
[01:11:13.440 --> 01:11:15.440]  То есть что у нас есть a и xs.
[01:11:15.440 --> 01:11:17.440]  Мы принимаем
[01:11:17.440 --> 01:11:19.440]  аргумент a и xs и мы возвращаем
[01:11:19.440 --> 01:11:21.440]  длину этого списка.
[01:11:21.440 --> 01:11:23.440]  Дальше, значит, что здесь
[01:11:23.440 --> 01:11:25.440]  интересного есть?
[01:11:25.440 --> 01:11:27.440]  Оператор плюс.
[01:11:27.440 --> 01:11:29.440]  Тут тоже ничего интересного.
[01:11:29.440 --> 01:11:31.440]  Дунотация.
[01:11:31.440 --> 01:11:33.440]  Это как раз, так сказать,
[01:11:33.440 --> 01:11:35.440]  не функцион... Это какой?
[01:11:37.440 --> 01:11:39.440]  Это у нас не функциональный стиль.
[01:11:39.440 --> 01:11:41.440]  То есть можно перейти в не функциональный стиль.
[01:11:41.440 --> 01:11:43.440]  А написать что-то
[01:11:43.440 --> 01:11:45.440]  в императивном.
[01:11:45.440 --> 01:11:47.440]  Конечно, это не рекомендуется.
[01:11:47.440 --> 01:11:49.440]  Но что мы делаем?
[01:11:53.440 --> 01:11:55.440]  Мы как раз это переписываем
[01:11:55.440 --> 01:11:57.440]  в стиле Monad.
[01:11:57.440 --> 01:11:59.440]  То есть как раз переменные привязаны...
[01:11:59.440 --> 01:12:01.440]  Это один из немногих способов,
[01:12:01.440 --> 01:12:03.440]  как мы переменные можем присвоить определенное значение.
[01:12:07.440 --> 01:12:09.440]  То есть как бы мы говорим, что у нас функция Act.
[01:12:09.440 --> 01:12:11.440]  То есть дальше
[01:12:11.440 --> 01:12:13.440]  мы принимаем через этот аргумент
[01:12:13.440 --> 01:12:15.440]  запись в аргумент x.
[01:12:15.440 --> 01:12:17.440]  Потом следующую принимаем
[01:12:17.440 --> 01:12:19.440]  аргумент Act, который
[01:12:19.440 --> 01:12:21.440]  вызывает эти значения
[01:12:21.440 --> 01:12:23.440]  к переменной y.
[01:12:23.440 --> 01:12:25.440]  И только после этого возвращаем
[01:12:25.440 --> 01:12:27.440]  x и y.
[01:12:31.440 --> 01:12:33.440]  Если мы захотим с вами
[01:12:33.440 --> 01:12:35.440]  вызвать вот эту функцию,
[01:12:35.440 --> 01:12:37.440]  то
[01:12:37.440 --> 01:12:39.440]  она вот таким страшным образом выглядит.
[01:12:39.440 --> 01:12:41.440]  То есть видно, что нам приходится переписывать
[01:12:41.440 --> 01:12:43.440]  наши функциональные языки.
[01:12:43.440 --> 01:12:45.440]  И последнее это
[01:12:45.440 --> 01:12:47.440]  Core,
[01:12:47.440 --> 01:12:49.440]  не presented.
[01:12:49.440 --> 01:12:51.440]  Это Cartesian и Cast.
[01:12:55.440 --> 01:12:57.440]  Здесь тоже у нас получается
[01:12:57.440 --> 01:12:59.440]  функции типов,
[01:12:59.440 --> 01:13:01.440]  которые у нас есть.
[01:13:01.440 --> 01:13:03.440]  И получается следующее,
[01:13:03.440 --> 01:13:05.440]  что у нас тут делается.
[01:13:05.440 --> 01:13:07.440]  ID мы объявляем A,
[01:13:07.440 --> 01:13:09.440]  A или B
[01:13:09.440 --> 01:13:11.440]  являются тем же самым типом.
[01:13:11.440 --> 01:13:13.440]  И дальше мы говорим следующее,
[01:13:13.440 --> 01:13:15.440]  что если у нас есть
[01:13:15.440 --> 01:13:17.440]  переменная A определенного типа,
[01:13:17.440 --> 01:13:19.440]  переменная B определенного типа,
[01:13:19.440 --> 01:13:21.440]  и мы по факту говорим,
[01:13:21.440 --> 01:13:23.440]  вот этот оператор %%A,
[01:13:23.440 --> 01:13:25.440]  мы говорим, что если A,
[01:13:27.440 --> 01:13:29.440]  присваиваем значение,
[01:13:29.440 --> 01:13:31.440]  что у нас второй перемен тоже есть.
[01:13:31.440 --> 01:13:33.440]  То есть видно, что здесь
[01:13:33.440 --> 01:13:35.440]  есть разные способы,
[01:13:35.440 --> 01:13:37.440]  как это сделать.
[01:13:37.440 --> 01:13:39.440]  А вот она, кстати,
[01:13:39.440 --> 01:13:41.440]  типичная
[01:13:41.440 --> 01:13:43.440]  каерция,
[01:13:43.440 --> 01:13:45.440]  которая у нас существует.
[01:13:45.440 --> 01:13:47.440]  В принципе, вот это то, что у нас
[01:13:47.440 --> 01:13:49.440]  с вами
[01:13:49.440 --> 01:13:51.440]  может поддерживаться в Haskell.
[01:13:53.440 --> 01:13:55.440]  Это у нас как раз был
[01:13:55.440 --> 01:13:57.440]  Core механизм.
[01:13:57.440 --> 01:13:59.440]  Я думаю, при желании можно будет
[01:13:59.440 --> 01:14:01.440]  транслировать это все в кордере.
[01:14:01.440 --> 01:14:03.440]  То есть у нас язык уже резко сокращается.
[01:14:05.440 --> 01:14:07.440]  Но все равно этот стиль
[01:14:07.440 --> 01:14:09.440]  пока никакой.
[01:14:09.440 --> 01:14:11.440]  Можно ли сразу из него
[01:14:11.440 --> 01:14:13.440]  транслировать в C?
[01:14:15.440 --> 01:14:17.440]  Из вот этих вот всяких вещей.
[01:14:21.440 --> 01:14:23.440]  Не очень. Поэтому нам нужен еще
[01:14:23.440 --> 01:14:25.440]  один способ трансформации.
[01:14:25.440 --> 01:14:27.440]  Это как раз STG.
[01:14:27.440 --> 01:14:29.440]  Здесь это примеры, презентация.
[01:14:33.440 --> 01:14:35.440]  Значит, смотрите, каким образом
[01:14:35.440 --> 01:14:37.440]  выглядит STG.
[01:14:37.440 --> 01:14:39.440]  Я тоже нашел презентацию.
[01:14:39.440 --> 01:14:41.440]  Я потом думаю, можно будет прикрепить
[01:14:41.440 --> 01:14:43.440]  все это дело.
[01:14:43.440 --> 01:14:45.440]  Язык STG. Давайте познакомимся с ним.
[01:14:45.440 --> 01:14:47.440]  Вот с этим уже можно работать.
[01:14:47.440 --> 01:14:49.440]  То есть у нас с вами
[01:14:49.440 --> 01:14:51.440]  есть некоторый набор
[01:14:51.440 --> 01:14:53.440]  переменных x, y, f, g.
[01:14:53.440 --> 01:14:55.440]  Дальше у нас есть конструкторы.
[01:14:55.440 --> 01:14:57.440]  Есть литералы.
[01:14:59.440 --> 01:15:01.440]  У нас целые или действительные числа.
[01:15:01.440 --> 01:15:03.440]  У нас есть атомы.
[01:15:03.440 --> 01:15:05.440]  То есть это аргумент.
[01:15:05.440 --> 01:15:07.440]  Аргументность.
[01:15:07.440 --> 01:15:09.440]  И у нас есть арность нашей функции,
[01:15:09.440 --> 01:15:11.440]  которую мы с вами можем переопределить.
[01:15:11.440 --> 01:15:13.440]  То есть эта арность неизвестна,
[01:15:13.440 --> 01:15:15.440]  эта арность известна.
[01:15:15.440 --> 01:15:17.440]  Дальше у нас выражение может быть базовым.
[01:15:17.440 --> 01:15:19.440]  Это атомная переменная.
[01:15:19.440 --> 01:15:21.440]  Дальше это может быть вузов функции.
[01:15:21.440 --> 01:15:23.440]  Fкатая.
[01:15:23.440 --> 01:15:25.440]  Получается,
[01:15:25.440 --> 01:15:27.440]  арность нашей функции,
[01:15:27.440 --> 01:15:29.440]  она принимает n аргументов.
[01:15:29.440 --> 01:15:31.440]  По действию должно быть fкатой.
[01:15:31.440 --> 01:15:33.440]  Либо мы с вами можем
[01:15:33.440 --> 01:15:35.440]  вызвать примитивную функцию,
[01:15:35.440 --> 01:15:37.440]  если нам нужно.
[01:15:37.440 --> 01:15:39.440]  Дальше, смотрите, здесь есть оператор let,
[01:15:39.440 --> 01:15:41.440]  который позволяет
[01:15:41.440 --> 01:15:43.440]  выделить нам объект
[01:15:43.440 --> 01:15:45.440]  в куче.
[01:15:45.440 --> 01:15:47.440]  Optinye.
[01:15:47.440 --> 01:15:49.440]  То есть записать.
[01:15:49.440 --> 01:15:51.440]  И у нас есть как раз case.
[01:15:51.440 --> 01:15:53.440]  То есть у нас есть case,
[01:15:53.440 --> 01:15:55.440]  которое осуществляет набор альтернативных вариантов.
[01:15:55.440 --> 01:15:57.440]  Какие у нас альтернативные
[01:15:57.440 --> 01:15:59.440]  могут быть?
[01:15:59.440 --> 01:16:01.440]  Либо у нас это pattern matching,
[01:16:01.440 --> 01:16:03.440]  сопоставление с образцом,
[01:16:03.440 --> 01:16:05.440]  либо это альтернативный по умолчанию.
[01:16:05.440 --> 01:16:07.440]  То есть наша цель научиться в первую очередь
[01:16:07.440 --> 01:16:09.440]  конвертировать кейсы.
[01:16:09.440 --> 01:16:11.440]  Если мы научимся конвертировать кейсы,
[01:16:11.440 --> 01:16:13.440]  то будет нам счастье.
[01:16:13.440 --> 01:16:15.440]  И смотрите, дальше что у нас есть?
[01:16:15.440 --> 01:16:17.440]  Мы вызываем функцию арности n.
[01:16:17.440 --> 01:16:19.440]  То есть объект это у нас либо fun,
[01:16:19.440 --> 01:16:21.440]  либо function, который мы лоцируем на куче.
[01:16:21.440 --> 01:16:23.440]  Таким образом, как у нас есть.
[01:16:23.440 --> 01:16:25.440]  Дальше у нас есть par, partial.
[01:16:25.440 --> 01:16:27.440]  То есть частичное применение
[01:16:27.440 --> 01:16:29.440]  функции к аргументам.
[01:16:29.440 --> 01:16:31.440]  И есть полное применение конструктора.
[01:16:31.440 --> 01:16:33.440]  То есть мы создаем с вами объект
[01:16:33.440 --> 01:16:35.440]  нашей функции.
[01:16:35.440 --> 01:16:37.440]  И смотрите, здесь есть специальное это.
[01:16:37.440 --> 01:16:39.440]  Специальные аргументы,
[01:16:39.440 --> 01:16:41.440]  которых изначально не было.
[01:16:41.440 --> 01:16:43.440]  То есть мы пока что в языке корни
[01:16:43.440 --> 01:16:45.440]  каким образом не говорили про отложенные вычисления.
[01:16:45.440 --> 01:16:47.440]  Собственно, чтобы явно сказать,
[01:16:47.440 --> 01:16:49.440]  что у нас отложенное вычисление,
[01:16:49.440 --> 01:16:51.440]  есть оператор Sang.
[01:16:59.440 --> 01:17:01.440]  Это специальная штука врантами,
[01:17:01.440 --> 01:17:03.440]  которая делает ожидание.
[01:17:03.440 --> 01:17:05.440]  Вот.
[01:17:09.440 --> 01:17:11.440]  Да.
[01:17:11.440 --> 01:17:13.440]  Ну и собственно, смотрите, как это выглядит
[01:17:13.440 --> 01:17:15.440]  в STG.
[01:17:17.440 --> 01:17:19.440]  То есть у нас явно указывается
[01:17:19.440 --> 01:17:21.440]  функция с набором аргументов.
[01:17:21.440 --> 01:17:23.440]  Почему? Потому что нам нужно
[01:17:23.440 --> 01:17:25.440]  какие-то параметры
[01:17:25.440 --> 01:17:27.440]  в стг.
[01:17:27.440 --> 01:17:29.440]  То есть у нас явно указывается
[01:17:29.440 --> 01:17:31.440]  функция с набором аргументов.
[01:17:31.440 --> 01:17:33.440]  Почему? Потому что нам нужно каким-то образом
[01:17:33.440 --> 01:17:35.440]  скастовать будет ее
[01:17:35.440 --> 01:17:37.440]  и явно выселить тип.
[01:17:37.440 --> 01:17:39.440]  То есть у нас есть как раз функция фолдинга,
[01:17:39.440 --> 01:17:41.440]  допустим, fx, xx, g,
[01:17:41.440 --> 01:17:43.440]  то мы явно указываем, что
[01:17:43.440 --> 01:17:45.440]  нам надо...
[01:17:45.440 --> 01:17:47.440]  Как это называется?
[01:17:47.440 --> 01:17:49.440]  AsyncEvade это называется.
[01:17:49.440 --> 01:17:51.440]  То есть в современных
[01:17:51.440 --> 01:17:53.440]  языках программирования
[01:17:53.440 --> 01:17:55.440]  есть парадигма, что у нас должна
[01:17:55.440 --> 01:17:57.440]  быть результат выполнения функции,
[01:17:57.440 --> 01:17:59.440]  после этого, возможно, это будет в отдельном потоке,
[01:17:59.440 --> 01:18:01.440]  после этого мы получаем результат.
[01:18:01.440 --> 01:18:03.440]  Вот, значит,
[01:18:03.440 --> 01:18:05.440]  теперь, значит,
[01:18:05.440 --> 01:18:07.440]  здесь есть некоторые ограничения.
[01:18:07.440 --> 01:18:09.440]  Заключается в следующем, что
[01:18:09.440 --> 01:18:11.440]  объекты у нас в куче создаются
[01:18:11.440 --> 01:18:13.440]  только в led-ворожениях.
[01:18:13.440 --> 01:18:15.440]  То есть больше мы нигде не создаем
[01:18:15.440 --> 01:18:17.440]  афемерных объектов, и
[01:18:17.440 --> 01:18:19.440]  выражение приводится к нормальной форме
[01:18:19.440 --> 01:18:21.440]  только в кейс-ворожениях.
[01:18:21.440 --> 01:18:23.440]  Вот, значит, смотрите,
[01:18:23.440 --> 01:18:25.440]  есть вот такой вот пример, давайте поймем,
[01:18:25.440 --> 01:18:27.440]  что он делает.
[01:18:29.440 --> 01:18:31.440]  А?
[01:18:33.440 --> 01:18:35.440]  Это вот чистый
[01:18:35.440 --> 01:18:37.440]  этот...
[01:18:39.440 --> 01:18:41.440]  элемент.
[01:18:41.440 --> 01:18:43.440]  Это чисто функциональный язык.
[01:18:49.440 --> 01:18:51.440]  Давайте поймем, что он делает.
[01:18:59.440 --> 01:19:01.440]  В смысле...
[01:19:03.440 --> 01:19:05.440]  Ну, некоторым математикам,
[01:19:05.440 --> 01:19:07.440]  в кабачках, удобнее...
[01:19:07.440 --> 01:19:09.440]  Да.
[01:19:09.440 --> 01:19:11.440]  ...удобнее выражать
[01:19:11.440 --> 01:19:13.440]  свои идеи на
[01:19:13.440 --> 01:19:15.440]  эти кейс-ворожениях.
[01:19:15.440 --> 01:19:17.440]  Это раз, но, во-вторых, это стриминг объекта.
[01:19:17.440 --> 01:19:19.440]  Стриминг парадигма,
[01:19:19.440 --> 01:19:21.440]  она как раз позволяет
[01:19:21.440 --> 01:19:23.440]  сделать важное
[01:19:23.440 --> 01:19:25.440]  свойство ресайленси.
[01:19:25.440 --> 01:19:27.440]  То есть у нас по факту объекты всегда
[01:19:27.440 --> 01:19:29.440]  эмутируемые.
[01:19:29.440 --> 01:19:31.440]  И мы по факту можем сделать один поток, потом данные
[01:19:31.440 --> 01:19:33.440]  перегонять в другой поток, в третий поток,
[01:19:33.440 --> 01:19:35.440]  в четвертый поток и так далее. То есть такие
[01:19:35.440 --> 01:19:37.440]  штуки проще конвейерить.
[01:19:43.440 --> 01:19:45.440]  Да, кстати...
[01:19:45.440 --> 01:19:47.440]  Да, кстати...
[01:19:55.440 --> 01:19:57.440]  Да, кстати, я видел,
[01:19:57.440 --> 01:19:59.440]  я пока готовился к материалам, я видел
[01:19:59.440 --> 01:20:01.440]  транслятор из
[01:20:01.440 --> 01:20:03.440]  GHC в кок.
[01:20:03.440 --> 01:20:05.440]  Это как раз язык верификаций.
[01:20:05.440 --> 01:20:07.440]  Прямо в GitHub репозитории
[01:20:07.440 --> 01:20:09.440]  какую-то нашел.
[01:20:11.440 --> 01:20:13.440]  Программа, по-моему, что-то такое.
[01:20:13.440 --> 01:20:15.440]  Да, по-моему,
[01:20:15.440 --> 01:20:17.440]  я сейчас могу ошибаться,
[01:20:17.440 --> 01:20:19.440]  Евгений Дашков ведет.
[01:20:19.440 --> 01:20:21.440]  Даже курс по работе
[01:20:21.440 --> 01:20:23.440]  с этим языком.
[01:20:23.440 --> 01:20:25.440]  Можно найти в лектории.
[01:20:33.440 --> 01:20:35.440]  Да, то есть можно походить.
[01:20:35.440 --> 01:20:37.440]  То есть смотрите, что у нас получается.
[01:20:37.440 --> 01:20:39.440]  У нас с вами создается
[01:20:39.440 --> 01:20:41.440]  Fold Natural, S0.
[01:20:41.440 --> 01:20:43.440]  Вот, и здесь как раз
[01:20:45.440 --> 01:20:47.440]  мы вызываем вот эту вещь.
[01:20:47.440 --> 01:20:49.440]  То есть видите,
[01:20:49.440 --> 01:20:51.440]  что такое у нас кон, давайте вспомним.
[01:20:51.440 --> 01:20:53.440]  Полное применение конструктора.
[01:20:53.440 --> 01:20:55.440]  То есть мы вызываем конструктор нашего
[01:20:55.440 --> 01:20:57.440]  объекта, и дальше
[01:20:57.440 --> 01:20:59.440]  мы это... Смотрите,
[01:20:59.440 --> 01:21:01.440]  давайте прочитаем. Data not
[01:21:01.440 --> 01:21:03.440]  это кто у нас с вами?
[01:21:03.440 --> 01:21:05.440]  Это либо 0,
[01:21:05.440 --> 01:21:07.440]  либо...
[01:21:07.440 --> 01:21:09.440]  Либо...
[01:21:09.440 --> 01:21:11.440]  Следующий.
[01:21:11.440 --> 01:21:13.440]  Not это натуральный число.
[01:21:13.440 --> 01:21:15.440]  Да, not это натуральный число.
[01:21:15.440 --> 01:21:17.440]  То есть это либо 0, либо следующее за ним.
[01:21:19.440 --> 01:21:21.440]  Дальше что у нас говорится?
[01:21:21.440 --> 01:21:23.440]  Объявляется, что 0 это 0.
[01:21:23.440 --> 01:21:25.440]  1 это...
[01:21:27.440 --> 01:21:29.440]  Success от 0.
[01:21:31.440 --> 01:21:33.440]  Да, success not.
[01:21:33.440 --> 01:21:35.440]  И дальше мы делаем следующее.
[01:21:35.440 --> 01:21:37.440]  У нас Fold not делает вот такое вот
[01:21:37.440 --> 01:21:39.440]  Fold natural.
[01:21:39.440 --> 01:21:41.440]  Да, то есть что это у нас такое?
[01:21:41.440 --> 01:21:43.440]  Это у нас функция,
[01:21:43.440 --> 01:21:45.440]  которая принимает
[01:21:45.440 --> 01:21:47.440]  a функцию,
[01:21:47.440 --> 01:21:49.440]  потом из a делает
[01:21:49.440 --> 01:21:51.440]  a, потом из него...
[01:21:51.440 --> 01:21:53.440]  Принимает a, принимает функцию
[01:21:53.440 --> 01:21:55.440]  из a в a, принимает not,
[01:21:55.440 --> 01:21:57.440]  надаёт a. Да.
[01:21:59.440 --> 01:22:01.440]  А, это типа...
[01:22:01.440 --> 01:22:03.440]  Проходится с successor?
[01:22:03.440 --> 01:22:05.440]  Да, то есть у нас получается
[01:22:05.440 --> 01:22:07.440]  z as 0
[01:22:07.440 --> 01:22:09.440]  выдаёт 0,
[01:22:09.440 --> 01:22:11.440]  то есть если мы принимаем
[01:22:11.440 --> 01:22:13.440]  0, а если мы принимаем
[01:22:13.440 --> 01:22:15.440]  successor and,
[01:22:15.440 --> 01:22:17.440]  то что мы делаем?
[01:22:17.440 --> 01:22:19.440]  Применяем себя к Foldo.
[01:22:19.440 --> 01:22:21.440]  Да, применяем себя к Foldo.
[01:22:21.440 --> 01:22:23.440]  Вот.
[01:22:23.440 --> 01:22:25.440]  То есть вот такая вот нотация.
[01:22:25.440 --> 01:22:27.440]  Ну и собственно, at a это что у нас получается?
[01:22:31.440 --> 01:22:33.440]  А, это прикрутить
[01:22:33.440 --> 01:22:35.440]  себя для
[01:22:35.440 --> 01:22:37.440]  препроцессора.
[01:22:39.440 --> 01:22:41.440]  То есть у нас
[01:22:41.440 --> 01:22:43.440]  at принимает два аргумента
[01:22:43.440 --> 01:22:45.440]  сам себя.
[01:22:45.440 --> 01:22:47.440]  А, нет, он принимает...
[01:22:47.440 --> 01:22:49.440]  Да, это
[01:22:49.440 --> 01:22:51.440]  ab, ab пропущено.
[01:22:51.440 --> 01:22:53.440]  Это мы
[01:22:53.440 --> 01:22:55.440]  с себя, да,
[01:22:55.440 --> 01:22:57.440]  перекинуть с successor, с себя
[01:22:57.440 --> 01:22:59.440]  на аргумент.
[01:22:59.440 --> 01:23:01.440]  То есть это получается сложение.
[01:23:01.440 --> 01:23:03.440]  Да.
[01:23:03.440 --> 01:23:05.440]  И есть mall.
[01:23:05.440 --> 01:23:07.440]  Это
[01:23:07.440 --> 01:23:09.440]  сделать
[01:23:09.440 --> 01:23:11.440]  от себя.
[01:23:11.440 --> 01:23:13.440]  Да, от себя
[01:23:13.440 --> 01:23:15.440]  в какое-то количество раз.
[01:23:15.440 --> 01:23:17.440]  Так, теперь смотрите, как это работает.
[01:23:17.440 --> 01:23:19.440]  Значит, вот это переписывается вот таким образом.
[01:23:19.440 --> 01:23:21.440]  То есть мы создаём конструктор объектов.
[01:23:21.440 --> 01:23:23.440]  И дальше
[01:23:23.440 --> 01:23:25.440]  мы говорим следующее, что
[01:23:25.440 --> 01:23:27.440]  мы создаём следующий объект в
[01:23:27.440 --> 01:23:29.440]  sNext. Вот такой код.
[01:23:29.440 --> 01:23:31.440]  Собственно. И дальше тут
[01:23:31.440 --> 01:23:33.440]  наверное мы уже
[01:23:33.440 --> 01:23:35.440]  посмотрим это в другой раз.
[01:23:35.440 --> 01:23:37.440]  Потому что здесь уже будет
[01:23:37.440 --> 01:23:39.440]  некоторое веселье и посмотрим
[01:23:39.440 --> 01:23:41.440]  на стратегию вычисления.
[01:23:41.440 --> 01:23:43.440]  Вот этого всего добра.
[01:23:43.440 --> 01:23:45.440]  Конечно, мозг оно сильно ломает.
[01:23:45.440 --> 01:23:47.440]  А?
[01:23:47.440 --> 01:23:49.440]  Более того, ещё сильнее
[01:23:49.440 --> 01:23:51.440]  будет ломать мозг
[01:23:51.440 --> 01:23:53.440]  логические языки
[01:23:53.440 --> 01:23:55.440]  программирования.
[01:23:55.440 --> 01:23:57.440]  Но есть этот быстрый мем, что
[01:23:57.440 --> 01:23:59.440]  шаблоны
[01:23:59.440 --> 01:24:01.440]  будут...
[01:24:01.440 --> 01:24:03.440]  Ну, это...
[01:24:03.440 --> 01:24:05.440]  Шаблон создавал человек, который
[01:24:05.440 --> 01:24:07.440]  заранчен и там
[01:24:07.440 --> 01:24:09.440]  вытекает.
[01:24:09.440 --> 01:24:11.440]  Нет, скорее про лог.
[01:24:11.440 --> 01:24:13.440]  Про лог это логический язык
[01:24:13.440 --> 01:24:15.440]  программирования.
[01:24:15.440 --> 01:24:17.440]  Это не функциональный язык.
[01:24:17.440 --> 01:24:19.440]  Это функциональный язык?
[01:24:19.440 --> 01:24:21.440]  По поводу программирования
[01:24:21.440 --> 01:24:23.440]  да, разумеется, что
[01:24:23.440 --> 01:24:25.440]  программирование шаблона
[01:24:25.440 --> 01:24:27.440]  на неровной местной
[01:24:27.440 --> 01:24:29.440]  тексте
[01:24:29.440 --> 01:24:31.440]  и получаются результаты
[01:24:31.440 --> 01:24:33.440]  поставить функции, да, значительно
[01:24:33.440 --> 01:24:35.440]  приятные.
[01:24:35.440 --> 01:24:37.440]  Но, да, вот все другие
[01:24:37.440 --> 01:24:39.440]  идеи
[01:24:39.440 --> 01:24:41.440]  это, значит, по программовку
[01:24:41.440 --> 01:24:43.440]  линзиной и прочих
[01:24:43.440 --> 01:24:45.440]  поворачивающих.
[01:24:45.440 --> 01:24:47.440]  Да.
[01:24:47.440 --> 01:24:49.440]  Всё.
[01:24:49.440 --> 01:24:51.440]  Ладно, на этом мы остановимся.
[01:24:51.440 --> 01:24:53.440]  Следующий раз продолжим.
[01:24:53.440 --> 01:24:55.440]  Наверное, какие-нибудь вопросы
[01:24:55.440 --> 01:24:57.440]  поотвечаем.
